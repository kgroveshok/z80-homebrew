# File os_mini_sc114.asm
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			 
0000			 
0000			tos:	equ 0f000h 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			SC103_PIO: equ 068h 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 38 95			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $20  
8003			  
8003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_AUTOFILE: equ $21  
8003			STORE_0_BANKRUN: equ $23  
8003			STORE_0_FILERUN: equ $24  
8003			  
8003			; Block 0 offsets for settings  
8003			  
8003			; if set then skip prompt for start up and accept all  
8003			  
8003			STORE_0_QUICKSTART: equ $25  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
8003			  
8003			hardware_config: equ key_face_held - 10  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_config - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003				  
8003			  
8003					;ld a, 0  
8003					;ld (hardware_diag), a  
8003			  
8003					; clear all the buffers  
8003			  
8003 21 fc ed				ld hl, display_fb1  
8006 22 58 ed				ld (display_fb_active), hl  
8009			  
8009 cd 8c 88				call clear_display  
800c			  
800c 21 5a ed				ld hl, display_fb2  
800f 22 58 ed				ld (display_fb_active), hl  
8012			  
8012 cd 8c 88				call clear_display  
8015			  
8015					; init primary frame buffer area  
8015 21 4d ee				ld hl, display_fb0  
8018 22 58 ed				ld (display_fb_active), hl  
801b			  
801b cd 8c 88				call clear_display  
801e			  
801e			  
801e cd 1d d7				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8021			  
8021 cd bf d7			call key_init  
8024 cd ab 80			call storage_init  
8027			  
8027				; setup malloc functions  
8027			  
8027				if MALLOC_1  
8027 cd 5c 8f				call  heap_init  
802a				endif  
802a				if MALLOC_4  
802a					call  heap_init  
802a				endif  
802a			  
802a				; init sound hardware if present  
802a			  
802a				if SOUND_ENABLE  
802a					call sound_init  
802a				endif  
802a			  
802a				; lcd test sequence  
802a					  
802a cd af 88			call update_display  
802d cd 09 88			call delay1s  
8030 3e 2b			ld a,'+'  
8032 cd 91 88			call fill_display  
8035 cd af 88			call update_display  
8038 cd 09 88			call delay1s  
803b 3e 2a			ld a,'*'  
803d cd 91 88			call fill_display  
8040 cd af 88			call update_display  
8043 cd 09 88			call delay1s  
8046 3e 2d			ld a,'-'  
8048 cd 91 88			call fill_display  
804b cd af 88			call update_display  
804e cd 09 88			call delay1s  
8051			  
8051			; boot splash screen  
8051			if display_cols == 20	  
8051 3e 00		        ld a, display_row_1    
8053			else  
8053			        ld a, display_row_1 +10   
8053			endif  
8053 11 84 80			ld de, bootmsg  
8056 cd 9f 88			call str_at_display  
8059 cd af 88			call update_display  
805c			  
805c			  
805c cd 09 88			call delay1s  
805f cd 09 88			call delay1s  
8062			if display_cols == 20	  
8062 3e 2a		            LD   A, display_row_3+2  
8064			else  
8064			            LD   A, display_row_3+12  
8064			endif  
8064 11 99 80			ld de, bootmsg1  
8067 cd 9f 88			call str_at_display  
806a cd af 88			call update_display  
806d cd 09 88			call delay1s  
8070 cd 09 88			call delay1s  
8073			  
8073			;	ld a, display_row_4+3  
8073			;	ld de, bootmsg2  
8073			;	call str_at_display  
8073			;	call update_display  
8073			;	call delay1s  
8073			;	call delay1s  
8073			  
8073			; debug mark setup  
8073			  
8073 3e 5f		ld a, '_'  
8075 32 b7 ee		ld (debug_mark),a  
8078 32 b8 ee		ld (debug_mark+1),a  
807b 32 b9 ee		ld (debug_mark+2),a  
807e 3e 00		ld a,0  
8080 32 ba ee		ld (debug_mark+3),a  
8083			  
8083 c9					ret  
8084			  
8084			  
8084 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
8099 .. 00		bootmsg1:	db "by Kevin Groves",0  
80a9			;bootmsg2:	db "Firmware v0.1",0  
80a9			  
80a9			; a 4x20 lcd  
80a9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80a9			  
80a9			;if display_cols == 20  
80a9			;	include "firmware_lcd_4x20.asm"  
80a9			;endif  
80a9			  
80a9			;if display_cols == 40  
80a9			;	include "firmware_lcd_4x40.asm"  
80a9			;endif  
80a9			  
80a9			;  
80a9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80a9			; TODO abstract the bit bang video out interface for dual display  
80a9			; TODO wire video out to tx pin on rc2014 bus  
80a9			  
80a9			; must supply cin, and cin_wait for low level hardware abstraction   
80a9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80a9			; test scancode  
80a9			  
80a9			;;;;;  
80a9			;;;  
80a9			; Moved out to mini and maxi versions  
80a9			;  
80a9			; include "firmware_key_4x4.asm"  
80a9			; using existing 4 wire x 4 resistor array for input  
80a9			;include "firmware_key_4x10.asm"  
80a9			; need to mod the board for 5 rows due to resistor array  
80a9			;include "firmware_key_5x10.asm"  
80a9			  
80a9			; storage hardware interface  
80a9			  
80a9			; use microchip serial eeprom for storage  
80a9			  
80a9			  
80a9			if STORAGE_SE  
80a9				include "firmware_spi.asm"  
80a9				include "firmware_seeprom.asm"  
80a9			else  
80a9			   ; create some stubs for the labels  
80a9 c9			se_readbyte: ret  
80aa c9			se_writebyte: ret  
80ab c9			storage_init: ret  
80ac			  
80ac			endif  
80ac			  
80ac			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80ac			;include "firmware_cf.asm"  
80ac			  
80ac			; load up high level storage hardward abstractions  
80ac			include "firmware_storage.asm"  
80ac			 
80ac			; persisent storage hardware abstraction layer  
80ac			 
80ac			 
80ac			 
80ac			; Block 0 on storage is a config state 
80ac			 
80ac			 
80ac			 
80ac			; TODO add read phy block and write phy block functions 
80ac			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80ac			 
80ac			; Abstraction layer  
80ac			 
80ac			; Logocial block size is same size as physical size - using tape concept 
80ac			 
80ac			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80ac			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80ac			 
80ac			 
80ac			 
80ac			; Filesystem layout (Logical layout) 
80ac			; 
80ac			; Block 0 - Bank config  
80ac			; 
80ac			;      Byte - 0 file id counter 
80ac			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80ac			;      Byte - 3-20 zero terminated bank label 
80ac			; 
80ac			; Block 1 > File storage 
80ac			; 
80ac			;      Byte 0 file id    - block 0 file details 
80ac			;      Byte 1 block id - block 0 is file  
80ac			;            Byte 2-15 - File name 
80ac			; 
80ac			;       - to end of block data 
80ac			; 
80ac			 
80ac			 
80ac			; Read Block 
80ac			; ---------- 
80ac			; 
80ac			; With current bank 
80ac			;  
80ac			; Get block number to read 
80ac			; Load physical blocks starting at start block into buffer 
80ac			 
80ac			; de points to buffer to use 
80ac			; hl holds logical block number  
80ac			 
80ac			storage_read_block: 
80ac			 
80ac				; TODO bank selection 
80ac			 
80ac				; for each of the physical blocks read it into the buffer 
80ac 06 40			ld b, STORE_BLOCK_PHY 
80ae			 
80ae				if DEBUG_STORESE 
80ae d5					push de 
80af				endif 
80af				 
80af			.rl1:    
80af			 
80af				; read physical block at hl into de 
80af			        ; increment hl and de to next read position on exit 
80af			 
80af e5				push hl 
80b0 d5				push de	 
80b1 c5				push bc 
80b2			;	if DEBUG_STORESE 
80b2			;		push af 
80b2			;		ld a, 'R' 
80b2			;		ld (debug_mark),a 
80b2			;		pop af 
80b2			;		CALLMONITOR 
80b2			;	endif 
80b2 cd a9 80			call se_readbyte 
80b5			;	if DEBUG_STORESE 
80b5			;		ld a,(spi_portbyte) 
80b5			;		ld l, a 
80b5			;		push af 
80b5			;		ld a, '1' 
80b5			;		ld (debug_mark),a 
80b5			;		pop af 
80b5			;		CALLMONITOR 
80b5			;	endif 
80b5 c1				pop bc 
80b6 d1				pop de 
80b7 e1				pop hl 
80b8 12				ld (de),a 
80b9 23				inc hl 
80ba 13				inc de 
80bb			 
80bb			;	if DEBUG_STORESE 
80bb			;		push af 
80bb			;		ld a, 'r' 
80bb			;		ld (debug_mark),a 
80bb			;		pop af 
80bb			;		CALLMONITOR 
80bb			;	endif 
80bb			 
80bb 10 f2			djnz .rl1 
80bd			 
80bd				if DEBUG_STORESE 
80bd					DMARK "SRB" 
80bd f5				push af  
80be 3a d2 80			ld a, (.dmark)  
80c1 32 b7 ee			ld (debug_mark),a  
80c4 3a d3 80			ld a, (.dmark+1)  
80c7 32 b8 ee			ld (debug_mark+1),a  
80ca 3a d4 80			ld a, (.dmark+2)  
80cd 32 b9 ee			ld (debug_mark+2),a  
80d0 18 03			jr .pastdmark  
80d2 ..			.dmark: db "SRB"  
80d5 f1			.pastdmark: pop af  
80d6			endm  
# End of macro DMARK
80d6 d1					pop de 
80d7			; 
80d7			;		push af 
80d7			;		ld a, 'R' 
80d7			;		ld (debug_mark),a 
80d7			;		pop af 
80d7					CALLMONITOR 
80d7 cd 62 93			call break_point_state  
80da				endm  
# End of macro CALLMONITOR
80da				endif 
80da c9				ret	 
80db				 
80db			 
80db			; File Size 
80db			; --------- 
80db			; 
80db			;   hl file id 
80db			; 
80db			;  returns in hl the number of blocks 
80db			 
80db			storage_file_size: 
80db 5d				ld e, l 
80dc 16 00			ld d, 0 
80de 21 40 00			ld hl, STORE_BLOCK_PHY 
80e1					if DEBUG_FORTH_WORDS 
80e1						DMARK "SIZ" 
80e1 f5				push af  
80e2 3a f6 80			ld a, (.dmark)  
80e5 32 b7 ee			ld (debug_mark),a  
80e8 3a f7 80			ld a, (.dmark+1)  
80eb 32 b8 ee			ld (debug_mark+1),a  
80ee 3a f8 80			ld a, (.dmark+2)  
80f1 32 b9 ee			ld (debug_mark+2),a  
80f4 18 03			jr .pastdmark  
80f6 ..			.dmark: db "SIZ"  
80f9 f1			.pastdmark: pop af  
80fa			endm  
# End of macro DMARK
80fa						CALLMONITOR 
80fa cd 62 93			call break_point_state  
80fd				endm  
# End of macro CALLMONITOR
80fd					endif 
80fd cd d1 83			call storage_findnextid 
8100			 
8100 cd e2 8a			call ishlzero 
8103			;	ld a, l 
8103			;	add h 
8103			;	cp 0 
8103 c8				ret z			; block not found so EOF 
8104			 
8104 11 e2 ec			ld de, store_page 
8107 cd ac 80			call storage_read_block 
810a			 
810a 3a e4 ec			ld a, (store_page+2)	 ; get extent count 
810d 6f				ld l, a 
810e 26 00			ld h, 0 
8110 c9			 	ret 
8111			 
8111			 
8111			; Write Block 
8111			; ----------- 
8111			; 
8111			; With current bank 
8111			;  
8111			; Get block number to write 
8111			; Write physical blocks starting at start block from buffer 
8111			  
8111			storage_write_block: 
8111				; TODO bank selection 
8111			 
8111				; for each of the physical blocks read it into the buffer 
8111 06 40			ld b, STORE_BLOCK_PHY 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SWB" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 b7 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 b8 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 b9 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SWB"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c			 
812c					;push af 
812c					;ld a, 'W' 
812c					;ld (debug_mark),a 
812c					;pop af 
812c					CALLMONITOR 
812c cd 62 93			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f			 
812f			; might not be working 
812f			;	call se_writepage 
812f			 
812f			;	ret 
812f			; 
812f			 
812f			 
812f			 
812f			.wl1:    
812f			 
812f				; read physical block at hl into de 
812f			        ; increment hl and de to next read position on exit 
812f			 
812f e5				push hl 
8130 d5				push de	 
8131 c5				push bc 
8132 1a				ld a,(de) 
8133				;if DEBUG_STORESE 
8133			;		push af 
8133			;		ld a, 'W' 
8133			;		ld (debug_mark),a 
8133			;		pop af 
8133			;		CALLMONITOR 
8133			;	endif 
8133 cd aa 80			call se_writebyte 
8136			;	call delay250ms 
8136 00				nop 
8137 00				nop 
8138 00				nop 
8139			;	if DEBUG_STORESE 
8139			;		push af 
8139			;		ld a, 'w' 
8139			;		ld (debug_mark),a 
8139			;		pop af 
8139			;		CALLMONITOR 
8139			;	endif 
8139 c1				pop bc 
813a d1				pop de 
813b e1				pop hl 
813c 23				inc hl 
813d 13				inc de 
813e			 
813e			 
813e 10 ef			djnz .wl1 
8140			 
8140				if DEBUG_STORESE 
8140					DMARK "SW2" 
8140 f5				push af  
8141 3a 55 81			ld a, (.dmark)  
8144 32 b7 ee			ld (debug_mark),a  
8147 3a 56 81			ld a, (.dmark+1)  
814a 32 b8 ee			ld (debug_mark+1),a  
814d 3a 57 81			ld a, (.dmark+2)  
8150 32 b9 ee			ld (debug_mark+2),a  
8153 18 03			jr .pastdmark  
8155 ..			.dmark: db "SW2"  
8158 f1			.pastdmark: pop af  
8159			endm  
# End of macro DMARK
8159			 
8159					;push af 
8159					;ld a, 'W' 
8159					;ld (debug_mark),a 
8159					;pop af 
8159					CALLMONITOR 
8159 cd 62 93			call break_point_state  
815c				endm  
# End of macro CALLMONITOR
815c				endif 
815c c9				ret	 
815d			 
815d			; Init bank 
815d			; --------- 
815d			; 
815d			; With current bank 
815d			; 
815d			; Setup block 0 config 
815d			;     Set 0 file id counter 
815d			;     Set formatted byte pattern 
815d			;     Zero out bank label 
815d			;      
815d			; For every logical block write 0-1 byte as null 
815d			 
815d			storage_get_block_0: 
815d			 
815d				; TODO check presence 
815d			 
815d				; get block 0 config 
815d			 
815d 21 00 00			ld hl, 0 
8160 11 e2 ec			ld de, store_page 
8163 cd ac 80			call storage_read_block 
8166			 
8166				if DEBUG_STORESE 
8166					DMARK "SB0" 
8166 f5				push af  
8167 3a 7b 81			ld a, (.dmark)  
816a 32 b7 ee			ld (debug_mark),a  
816d 3a 7c 81			ld a, (.dmark+1)  
8170 32 b8 ee			ld (debug_mark+1),a  
8173 3a 7d 81			ld a, (.dmark+2)  
8176 32 b9 ee			ld (debug_mark+2),a  
8179 18 03			jr .pastdmark  
817b ..			.dmark: db "SB0"  
817e f1			.pastdmark: pop af  
817f			endm  
# End of macro DMARK
817f 11 e2 ec				ld de, store_page 
8182			;		push af 
8182			;		ld a, 'i' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182					CALLMONITOR 
8182 cd 62 93			call break_point_state  
8185				endm  
# End of macro CALLMONITOR
8185				endif 
8185			 
8185				; is this area formatted? 
8185			 
8185			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8185 2a e3 ec			ld hl, (store_page+1) 
8188 3e 80			ld a,0x80 
818a bd				cp l 
818b 20 22			jr nz, .ininotformatted 
818d				; do a double check 
818d 3e 27			ld a, 0x27 
818f bc				cp h 
8190 20 1d			jr nz, .ininotformatted 
8192			 
8192				; formatted then 
8192			 
8192				if DEBUG_STORESE 
8192					DMARK "SB1" 
8192 f5				push af  
8193 3a a7 81			ld a, (.dmark)  
8196 32 b7 ee			ld (debug_mark),a  
8199 3a a8 81			ld a, (.dmark+1)  
819c 32 b8 ee			ld (debug_mark+1),a  
819f 3a a9 81			ld a, (.dmark+2)  
81a2 32 b9 ee			ld (debug_mark+2),a  
81a5 18 03			jr .pastdmark  
81a7 ..			.dmark: db "SB1"  
81aa f1			.pastdmark: pop af  
81ab			endm  
# End of macro DMARK
81ab					;push af 
81ab					;ld a, 'I' 
81ab					;ld (debug_mark),a 
81ab					;pop af 
81ab					CALLMONITOR 
81ab cd 62 93			call break_point_state  
81ae				endm  
# End of macro CALLMONITOR
81ae				endif 
81ae c9				ret 
81af			 
81af			.ininotformatted: 
81af				; bank not formatted so poke various bits to make sure 
81af			 
81af				if DEBUG_STORESE 
81af					DMARK "SB2" 
81af f5				push af  
81b0 3a c4 81			ld a, (.dmark)  
81b3 32 b7 ee			ld (debug_mark),a  
81b6 3a c5 81			ld a, (.dmark+1)  
81b9 32 b8 ee			ld (debug_mark+1),a  
81bc 3a c6 81			ld a, (.dmark+2)  
81bf 32 b9 ee			ld (debug_mark+2),a  
81c2 18 03			jr .pastdmark  
81c4 ..			.dmark: db "SB2"  
81c7 f1			.pastdmark: pop af  
81c8			endm  
# End of macro DMARK
81c8					;push af 
81c8					;ld a, 'f' 
81c8					;ld (debug_mark),a 
81c8					;pop af 
81c8					CALLMONITOR 
81c8 cd 62 93			call break_point_state  
81cb				endm  
# End of macro CALLMONITOR
81cb				endif 
81cb			 
81cb cd cc 87			call storage_clear_page 
81ce			 
81ce 21 e2 ec			ld hl, store_page 
81d1 3e 00			ld a, 0 
81d3				 
81d3 77				ld (hl),a   ; reset file counter 
81d4			 
81d4 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81d7 22 e3 ec		 	ld (store_page+1), hl	 
81da			 
81da				; set default label 
81da			 
81da 21 76 82			ld hl, .defaultbanklabl 
81dd 11 e5 ec		 	ld de, store_page+3 
81e0 01 0f 00			ld bc, 15 
81e3 ed b0			ldir 
81e5			 
81e5				; Append the current bank id 
81e5 21 ee ec			ld hl, store_page+3+9 
81e8 3a c7 ec			ld a, (spi_device_id) 
81eb 77				ld (hl), a 
81ec			 
81ec				; save default page 0 
81ec			 
81ec 21 00 00			ld hl, 0 
81ef 11 e2 ec			ld de, store_page 
81f2				if DEBUG_STORESE 
81f2					DMARK "SB3" 
81f2 f5				push af  
81f3 3a 07 82			ld a, (.dmark)  
81f6 32 b7 ee			ld (debug_mark),a  
81f9 3a 08 82			ld a, (.dmark+1)  
81fc 32 b8 ee			ld (debug_mark+1),a  
81ff 3a 09 82			ld a, (.dmark+2)  
8202 32 b9 ee			ld (debug_mark+2),a  
8205 18 03			jr .pastdmark  
8207 ..			.dmark: db "SB3"  
820a f1			.pastdmark: pop af  
820b			endm  
# End of macro DMARK
820b			;		push af 
820b			;		ld a, 'F' 
820b			;		ld (debug_mark),a 
820b			;		pop af 
820b					CALLMONITOR 
820b cd 62 93			call break_point_state  
820e				endm  
# End of macro CALLMONITOR
820e				endif 
820e cd 11 81			call storage_write_block 
8211				if DEBUG_STORESE 
8211					DMARK "SB4" 
8211 f5				push af  
8212 3a 26 82			ld a, (.dmark)  
8215 32 b7 ee			ld (debug_mark),a  
8218 3a 27 82			ld a, (.dmark+1)  
821b 32 b8 ee			ld (debug_mark+1),a  
821e 3a 28 82			ld a, (.dmark+2)  
8221 32 b9 ee			ld (debug_mark+2),a  
8224 18 03			jr .pastdmark  
8226 ..			.dmark: db "SB4"  
8229 f1			.pastdmark: pop af  
822a			endm  
# End of macro DMARK
822a			;		push af 
822a			;		ld a, '>' 
822a			;		ld (debug_mark),a 
822a			;		pop af 
822a					CALLMONITOR 
822a cd 62 93			call break_point_state  
822d				endm  
# End of macro CALLMONITOR
822d				endif 
822d			 
822d 00				nop 
822e 00				nop 
822f 00				nop 
8230			 
8230				; now set 0 in every page to mark as a free block 
8230			 
8230 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8232 21 40 00			ld hl, STORE_BLOCK_PHY 
8235			 
8235 3e 00		.setmark1:   	ld a,0 
8237 e5					push hl 
8238 c5					push bc 
8239 cd aa 80				call se_writebyte 
823c 3e 0a			ld a, 10 
823e cd ee 87			call aDelayInMS 
8241 23				inc hl 
8242 cd aa 80				call se_writebyte 
8245 3e 0a			ld a, 10 
8247 cd ee 87			call aDelayInMS 
824a 2b				dec hl 
824b c1					pop bc 
824c e1					pop hl 
824d 3e 40				ld a, STORE_BLOCK_PHY 
824f cd b9 8a				call addatohl 
8252 10 e1				djnz .setmark1 
8254			 
8254 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8256 3e 00		.setmark2:   	ld a,0 
8258 e5					push hl 
8259 c5					push bc 
825a cd aa 80				call se_writebyte 
825d 3e 0a			ld a, 10 
825f cd ee 87			call aDelayInMS 
8262 23				inc hl 
8263 cd aa 80				call se_writebyte 
8266 3e 0a			ld a, 10 
8268 cd ee 87			call aDelayInMS 
826b 2b				dec hl 
826c c1					pop bc 
826d e1					pop hl 
826e 3e 40				ld a, STORE_BLOCK_PHY 
8270 cd b9 8a				call addatohl 
8273 10 e1				djnz .setmark2 
8275			 
8275					 
8275			 
8275			 
8275 c9				ret 
8276			 
8276			 
8276			 
8276			 
8276 .. 00		.defaultbanklabl:   db "BankLabel_",0 
8281			 
8281			 
8281			 
8281			; Label Bank 
8281			; ---------- 
8281			; 
8281			; With current bank 
8281			; Read block 0 
8281			; Set label 
8281			; Write block 0 
8281			 
8281			; label str pointer in hl 
8281			 
8281			storage_label:     
8281			 
8281				if DEBUG_STORESE 
8281					DMARK "LBL" 
8281 f5				push af  
8282 3a 96 82			ld a, (.dmark)  
8285 32 b7 ee			ld (debug_mark),a  
8288 3a 97 82			ld a, (.dmark+1)  
828b 32 b8 ee			ld (debug_mark+1),a  
828e 3a 98 82			ld a, (.dmark+2)  
8291 32 b9 ee			ld (debug_mark+2),a  
8294 18 03			jr .pastdmark  
8296 ..			.dmark: db "LBL"  
8299 f1			.pastdmark: pop af  
829a			endm  
# End of macro DMARK
829a					CALLMONITOR 
829a cd 62 93			call break_point_state  
829d				endm  
# End of macro CALLMONITOR
829d				endif 
829d			 
829d e5				push hl 
829e			 
829e cd 5d 81			call storage_get_block_0 
82a1			 
82a1				; set default label 
82a1			 
82a1 e1				pop hl 
82a2			 
82a2 11 e5 ec		 	ld de, store_page+3 
82a5 01 0f 00			ld bc, 15 
82a8				if DEBUG_STORESE 
82a8					DMARK "LB3" 
82a8 f5				push af  
82a9 3a bd 82			ld a, (.dmark)  
82ac 32 b7 ee			ld (debug_mark),a  
82af 3a be 82			ld a, (.dmark+1)  
82b2 32 b8 ee			ld (debug_mark+1),a  
82b5 3a bf 82			ld a, (.dmark+2)  
82b8 32 b9 ee			ld (debug_mark+2),a  
82bb 18 03			jr .pastdmark  
82bd ..			.dmark: db "LB3"  
82c0 f1			.pastdmark: pop af  
82c1			endm  
# End of macro DMARK
82c1					CALLMONITOR 
82c1 cd 62 93			call break_point_state  
82c4				endm  
# End of macro CALLMONITOR
82c4				endif 
82c4 ed b0			ldir 
82c6				; save default page 0 
82c6			 
82c6 21 00 00			ld hl, 0 
82c9 11 e2 ec			ld de, store_page 
82cc				if DEBUG_STORESE 
82cc					DMARK "LBW" 
82cc f5				push af  
82cd 3a e1 82			ld a, (.dmark)  
82d0 32 b7 ee			ld (debug_mark),a  
82d3 3a e2 82			ld a, (.dmark+1)  
82d6 32 b8 ee			ld (debug_mark+1),a  
82d9 3a e3 82			ld a, (.dmark+2)  
82dc 32 b9 ee			ld (debug_mark+2),a  
82df 18 03			jr .pastdmark  
82e1 ..			.dmark: db "LBW"  
82e4 f1			.pastdmark: pop af  
82e5			endm  
# End of macro DMARK
82e5					CALLMONITOR 
82e5 cd 62 93			call break_point_state  
82e8				endm  
# End of macro CALLMONITOR
82e8				endif 
82e8 cd 11 81			call storage_write_block 
82eb			 
82eb c9				ret 
82ec			 
82ec			 
82ec			 
82ec			; Read Block 0 - Config 
82ec			; --------------------- 
82ec			; 
82ec			; With current bank 
82ec			; Call presence test 
82ec			;    If not present format/init bank  
82ec			; Read block 0  
82ec			;  
82ec			 
82ec			 
82ec			; Dir 
82ec			; --- 
82ec			; 
82ec			; With current bank 
82ec			; Load Block 0 Config 
82ec			; Get max file id number 
82ec			; For each logical block 
82ec			;    Read block read byte 2 
82ec			;      if first block of file 
82ec			;         Display file name 
82ec			;         Display type flags for file 
82ec			;        
82ec			 
82ec			; moving to words as this requires stack control 
82ec			 
82ec			 
82ec			; Delete File 
82ec			; ----------- 
82ec			; 
82ec			; With current bank 
82ec			; 
82ec			; Load Block 0 Config 
82ec			; Get max file id number 
82ec			; For each logical block 
82ec			;    Read block file id 
82ec			;      If first block of file and dont have file id 
82ec			;         if file to delete 
82ec			;         Save file id 
82ec			;         Null file id 
82ec			;         Write this block back 
82ec			;      If file id is one saved 
82ec			;         Null file id 
82ec			;         Write this block back 
82ec			 
82ec			storage_erase: 
82ec			 
82ec				; hl contains the file id 
82ec			 
82ec 5d				ld e, l 
82ed 16 00			ld d, 0 
82ef 21 40 00			ld hl, STORE_BLOCK_PHY 
82f2					if DEBUG_FORTH_WORDS 
82f2						DMARK "ERA" 
82f2 f5				push af  
82f3 3a 07 83			ld a, (.dmark)  
82f6 32 b7 ee			ld (debug_mark),a  
82f9 3a 08 83			ld a, (.dmark+1)  
82fc 32 b8 ee			ld (debug_mark+1),a  
82ff 3a 09 83			ld a, (.dmark+2)  
8302 32 b9 ee			ld (debug_mark+2),a  
8305 18 03			jr .pastdmark  
8307 ..			.dmark: db "ERA"  
830a f1			.pastdmark: pop af  
830b			endm  
# End of macro DMARK
830b						CALLMONITOR 
830b cd 62 93			call break_point_state  
830e				endm  
# End of macro CALLMONITOR
830e					endif 
830e cd d1 83			call storage_findnextid 
8311 cd e2 8a			call ishlzero 
8314 c8				ret z 
8315			 
8315 e5				push hl 
8316			 
8316				; TODO check file not found 
8316			 
8316 11 e2 ec			ld de, store_page 
8319 cd ac 80			call storage_read_block 
831c			 
831c					if DEBUG_FORTH_WORDS 
831c						DMARK "ER1" 
831c f5				push af  
831d 3a 31 83			ld a, (.dmark)  
8320 32 b7 ee			ld (debug_mark),a  
8323 3a 32 83			ld a, (.dmark+1)  
8326 32 b8 ee			ld (debug_mark+1),a  
8329 3a 33 83			ld a, (.dmark+2)  
832c 32 b9 ee			ld (debug_mark+2),a  
832f 18 03			jr .pastdmark  
8331 ..			.dmark: db "ER1"  
8334 f1			.pastdmark: pop af  
8335			endm  
# End of macro DMARK
8335						CALLMONITOR 
8335 cd 62 93			call break_point_state  
8338				endm  
# End of macro CALLMONITOR
8338					endif 
8338 3a e2 ec			ld a, (store_page)	; get file id 
833b 32 db ec			ld (store_tmpid), a 
833e			 
833e 3a e4 ec			ld a, (store_page+2)    ; get count of extends 
8341 32 da ec			ld (store_tmpext), a 
8344			 
8344				; wipe file header 
8344			 
8344 e1				pop hl 
8345 3e 00			ld a, 0 
8347 32 e2 ec			ld (store_page), a 
834a 32 e3 ec			ld (store_page+1),a 
834d 11 e2 ec			ld de, store_page 
8350					if DEBUG_FORTH_WORDS 
8350						DMARK "ER2" 
8350 f5				push af  
8351 3a 65 83			ld a, (.dmark)  
8354 32 b7 ee			ld (debug_mark),a  
8357 3a 66 83			ld a, (.dmark+1)  
835a 32 b8 ee			ld (debug_mark+1),a  
835d 3a 67 83			ld a, (.dmark+2)  
8360 32 b9 ee			ld (debug_mark+2),a  
8363 18 03			jr .pastdmark  
8365 ..			.dmark: db "ER2"  
8368 f1			.pastdmark: pop af  
8369			endm  
# End of macro DMARK
8369						CALLMONITOR 
8369 cd 62 93			call break_point_state  
836c				endm  
# End of macro CALLMONITOR
836c					endif 
836c cd 11 81			call storage_write_block 
836f			 
836f			 
836f				; wipe file extents 
836f			 
836f 3a da ec			ld a, (store_tmpext) 
8372 47				ld b, a 
8373			 
8373			.eraext:	  
8373 c5				push bc 
8374			 
8374 21 40 00			ld hl, STORE_BLOCK_PHY 
8377 3a db ec			ld a,(store_tmpid) 
837a 5f				ld e, a 
837b 50				ld d, b	 
837c					if DEBUG_FORTH_WORDS 
837c						DMARK "ER3" 
837c f5				push af  
837d 3a 91 83			ld a, (.dmark)  
8380 32 b7 ee			ld (debug_mark),a  
8383 3a 92 83			ld a, (.dmark+1)  
8386 32 b8 ee			ld (debug_mark+1),a  
8389 3a 93 83			ld a, (.dmark+2)  
838c 32 b9 ee			ld (debug_mark+2),a  
838f 18 03			jr .pastdmark  
8391 ..			.dmark: db "ER3"  
8394 f1			.pastdmark: pop af  
8395			endm  
# End of macro DMARK
8395						CALLMONITOR 
8395 cd 62 93			call break_point_state  
8398				endm  
# End of macro CALLMONITOR
8398					endif 
8398 cd d1 83			call storage_findnextid 
839b			 
839b e5				push hl 
839c 11 e2 ec			ld de, store_page 
839f cd ac 80			call storage_read_block 
83a2			 
83a2				; free block	 
83a2			 
83a2 3e 00			ld a, 0 
83a4 32 e2 ec			ld (store_page), a 
83a7 32 e3 ec			ld (store_page+1),a 
83aa 11 e2 ec			ld de, store_page 
83ad e1				pop hl 
83ae					if DEBUG_FORTH_WORDS 
83ae						DMARK "ER4" 
83ae f5				push af  
83af 3a c3 83			ld a, (.dmark)  
83b2 32 b7 ee			ld (debug_mark),a  
83b5 3a c4 83			ld a, (.dmark+1)  
83b8 32 b8 ee			ld (debug_mark+1),a  
83bb 3a c5 83			ld a, (.dmark+2)  
83be 32 b9 ee			ld (debug_mark+2),a  
83c1 18 03			jr .pastdmark  
83c3 ..			.dmark: db "ER4"  
83c6 f1			.pastdmark: pop af  
83c7			endm  
# End of macro DMARK
83c7						CALLMONITOR 
83c7 cd 62 93			call break_point_state  
83ca				endm  
# End of macro CALLMONITOR
83ca					endif 
83ca cd 11 81			call storage_write_block 
83cd			 
83cd c1				pop bc 
83ce 10 a3			djnz .eraext 
83d0			 
83d0 c9				ret 
83d1			 
83d1			 
83d1			; Find Free Block 
83d1			; --------------- 
83d1			; 
83d1			; With current bank 
83d1			;  
83d1			; From given starting logical block 
83d1			;    Read block  
83d1			;    If no file id 
83d1			;         Return block id 
83d1			 
83d1			 
83d1			; hl starting page number 
83d1			; hl contains free page number or zero if no pages free 
83d1			; e contains the file id to locate 
83d1			; d contains the block number 
83d1			 
83d1			; TODO change to find file id and use zero for free block 
83d1			 
83d1			storage_findnextid: 
83d1			 
83d1				; now locate first 0 page to mark as a free block 
83d1			 
83d1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83d3			;	ld hl, STORE_BLOCK_PHY 
83d3			 
83d3					if DEBUG_FORTH_WORDS 
83d3					DMARK "FNI" 
83d3 f5				push af  
83d4 3a e8 83			ld a, (.dmark)  
83d7 32 b7 ee			ld (debug_mark),a  
83da 3a e9 83			ld a, (.dmark+1)  
83dd 32 b8 ee			ld (debug_mark+1),a  
83e0 3a ea 83			ld a, (.dmark+2)  
83e3 32 b9 ee			ld (debug_mark+2),a  
83e6 18 03			jr .pastdmark  
83e8 ..			.dmark: db "FNI"  
83eb f1			.pastdmark: pop af  
83ec			endm  
# End of macro DMARK
83ec						CALLMONITOR 
83ec cd 62 93			call break_point_state  
83ef				endm  
# End of macro CALLMONITOR
83ef					endif 
83ef			.ff1:   	 
83ef e5					push hl 
83f0 c5					push bc 
83f1 d5					push de 
83f2 cd a9 80				call se_readbyte 
83f5 5f					ld e,a 
83f6 23					inc hl 
83f7 cd a9 80				call se_readbyte 
83fa 57					ld d, a 
83fb e1					pop hl 
83fc e5					push hl 
83fd cd d7 8a				call cmp16 
8400 28 49				jr z, .fffound 
8402			 
8402 d1					pop de 
8403 c1					pop bc 
8404 e1					pop hl 
8405			 
8405					; is found? 
8405					;cp e 
8405					;ret z 
8405			 
8405 3e 40				ld a, STORE_BLOCK_PHY 
8407 cd b9 8a				call addatohl 
840a 10 e3				djnz .ff1 
840c			 
840c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
840e			.ff2:   	 
840e			 
840e e5					push hl 
840f c5					push bc 
8410 d5					push de 
8411 cd a9 80				call se_readbyte 
8414 5f					ld e,a 
8415 23					inc hl 
8416 cd a9 80				call se_readbyte 
8419 57					ld d, a 
841a			 
841a e1					pop hl 
841b e5					push hl 
841c cd d7 8a				call cmp16 
841f 28 2a				jr z, .fffound 
8421			 
8421 d1					pop de 
8422 c1					pop bc 
8423 e1					pop hl 
8424					; is found? 
8424					;cp e 
8424					;ret z 
8424			 
8424 3e 40				ld a, STORE_BLOCK_PHY 
8426 cd b9 8a				call addatohl 
8429 10 e3				djnz .ff2 
842b			 
842b			 
842b					if DEBUG_FORTH_WORDS 
842b					DMARK "FN-" 
842b f5				push af  
842c 3a 40 84			ld a, (.dmark)  
842f 32 b7 ee			ld (debug_mark),a  
8432 3a 41 84			ld a, (.dmark+1)  
8435 32 b8 ee			ld (debug_mark+1),a  
8438 3a 42 84			ld a, (.dmark+2)  
843b 32 b9 ee			ld (debug_mark+2),a  
843e 18 03			jr .pastdmark  
8440 ..			.dmark: db "FN-"  
8443 f1			.pastdmark: pop af  
8444			endm  
# End of macro DMARK
8444					;	push af 
8444					;	ld a, 'n' 
8444					;	ld (debug_mark),a 
8444					;	pop af 
8444						CALLMONITOR 
8444 cd 62 93			call break_point_state  
8447				endm  
# End of macro CALLMONITOR
8447					endif 
8447				; no free marks! 
8447 21 00 00				ld hl, 0 
844a c9				ret 
844b			.fffound: 
844b				 
844b			 
844b d1					pop de 
844c c1					pop bc 
844d e1					pop hl 
844e					if DEBUG_FORTH_WORDS 
844e					DMARK "FNF" 
844e f5				push af  
844f 3a 63 84			ld a, (.dmark)  
8452 32 b7 ee			ld (debug_mark),a  
8455 3a 64 84			ld a, (.dmark+1)  
8458 32 b8 ee			ld (debug_mark+1),a  
845b 3a 65 84			ld a, (.dmark+2)  
845e 32 b9 ee			ld (debug_mark+2),a  
8461 18 03			jr .pastdmark  
8463 ..			.dmark: db "FNF"  
8466 f1			.pastdmark: pop af  
8467			endm  
# End of macro DMARK
8467					;	push af 
8467					;	ld a, 'n' 
8467					;	ld (debug_mark),a 
8467					;	pop af 
8467						CALLMONITOR 
8467 cd 62 93			call break_point_state  
846a				endm  
# End of macro CALLMONITOR
846a					endif 
846a c9				ret 
846b			 
846b			 
846b			 
846b			; Free Space 
846b			; ---------- 
846b			; 
846b			; With current bank 
846b			; 
846b			; Set block count to zero 
846b			; Starting with first logical block 
846b			;      Find free block  
846b			;      If block id given, increment block count 
846b			; 
846b			;  
846b			 
846b			 
846b			; hl contains count of free blocks 
846b			 
846b			storage_freeblocks: 
846b			 
846b				; now locate first 0 page to mark as a free block 
846b			 
846b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
846d 21 40 00			ld hl, STORE_BLOCK_PHY 
8470 11 00 00			ld de, 0 
8473			 
8473			.fb1:   	 
8473 e5					push hl 
8474 c5					push bc 
8475 d5					push de 
8476 cd a9 80				call se_readbyte 
8479 d1					pop de 
847a c1					pop bc 
847b e1					pop hl 
847c			 
847c					; is free? 
847c fe 00				cp 0 
847e 20 01				jr nz, .ff1cont 
8480 13					inc de 
8481			 
8481			.ff1cont: 
8481			 
8481			 
8481 3e 40				ld a, STORE_BLOCK_PHY 
8483 cd b9 8a				call addatohl 
8486 10 eb				djnz .fb1 
8488			 
8488 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
848a			.fb2:   	 
848a e5					push hl 
848b c5					push bc 
848c d5					push de 
848d cd a9 80				call se_readbyte 
8490 d1					pop de 
8491 c1					pop bc 
8492 e1					pop hl 
8493			 
8493					; is free? 
8493 fe 00				cp 0 
8495 20 01				jr nz, .ff2cont 
8497 13					inc de 
8498			 
8498			.ff2cont: 
8498			 
8498 3e 40				ld a, STORE_BLOCK_PHY 
849a cd b9 8a				call addatohl 
849d 10 eb				djnz .fb2 
849f			 
849f eb				ex de, hl 
84a0 c9				ret 
84a1			 
84a1			; Get File ID 
84a1			; ----------- 
84a1			; 
84a1			; With current bank 
84a1			;  
84a1			; Load Block 0 Config 
84a1			; Get max file id number 
84a1			; For each logical block 
84a1			;    Read block file id 
84a1			;      If first block of file and dont have file id 
84a1			;         if file get id and exit 
84a1			 
84a1			 
84a1			 
84a1			 
84a1			; Create File 
84a1			; ----------- 
84a1			; 
84a1			; With current bank  
84a1			; Load Block 0 Config 
84a1			; Get max file id number 
84a1			; Increment file id number 
84a1			; Save Config 
84a1			; Find free block 
84a1			; Set buffer with file name and file id 
84a1			; Write buffer to free block  
84a1			 
84a1			 
84a1			; hl point to file name 
84a1			; hl returns file id 
84a1			 
84a1			; file format: 
84a1			; byte 0 - file id 
84a1			; byte 1 - extent number 
84a1			; byte 2-> data 
84a1			 
84a1			; format for extent number 0: 
84a1			; 
84a1			; byte 0 - file id 
84a1			; byte 1 - extent 0 
84a1			; byte 2 - extent count 
84a1			; byte 3 -> file name and meta data 
84a1			 
84a1			 
84a1			storage_create: 
84a1				if DEBUG_STORESE 
84a1					DMARK "SCR" 
84a1 f5				push af  
84a2 3a b6 84			ld a, (.dmark)  
84a5 32 b7 ee			ld (debug_mark),a  
84a8 3a b7 84			ld a, (.dmark+1)  
84ab 32 b8 ee			ld (debug_mark+1),a  
84ae 3a b8 84			ld a, (.dmark+2)  
84b1 32 b9 ee			ld (debug_mark+2),a  
84b4 18 03			jr .pastdmark  
84b6 ..			.dmark: db "SCR"  
84b9 f1			.pastdmark: pop af  
84ba			endm  
# End of macro DMARK
84ba					CALLMONITOR 
84ba cd 62 93			call break_point_state  
84bd				endm  
# End of macro CALLMONITOR
84bd				endif 
84bd			 
84bd e5				push hl		; save file name pointer 
84be			 
84be cd 5d 81			call storage_get_block_0 
84c1			 
84c1 3a e2 ec			ld a,(store_page)	; get current file id 
84c4 3c				inc a 
84c5 32 e2 ec			ld (store_page),a 
84c8				 
84c8 32 db ec			ld (store_tmpid),a			; save id 
84cb			 
84cb 21 00 00			ld hl, 0 
84ce 11 e2 ec			ld de, store_page 
84d1				if DEBUG_STORESE 
84d1					DMARK "SCw" 
84d1 f5				push af  
84d2 3a e6 84			ld a, (.dmark)  
84d5 32 b7 ee			ld (debug_mark),a  
84d8 3a e7 84			ld a, (.dmark+1)  
84db 32 b8 ee			ld (debug_mark+1),a  
84de 3a e8 84			ld a, (.dmark+2)  
84e1 32 b9 ee			ld (debug_mark+2),a  
84e4 18 03			jr .pastdmark  
84e6 ..			.dmark: db "SCw"  
84e9 f1			.pastdmark: pop af  
84ea			endm  
# End of macro DMARK
84ea					CALLMONITOR 
84ea cd 62 93			call break_point_state  
84ed				endm  
# End of macro CALLMONITOR
84ed				endif 
84ed cd 11 81			call storage_write_block	 ; save update 
84f0			 
84f0				if DEBUG_STORESE 
84f0 11 e2 ec				ld de, store_page 
84f3					DMARK "SCC" 
84f3 f5				push af  
84f4 3a 08 85			ld a, (.dmark)  
84f7 32 b7 ee			ld (debug_mark),a  
84fa 3a 09 85			ld a, (.dmark+1)  
84fd 32 b8 ee			ld (debug_mark+1),a  
8500 3a 0a 85			ld a, (.dmark+2)  
8503 32 b9 ee			ld (debug_mark+2),a  
8506 18 03			jr .pastdmark  
8508 ..			.dmark: db "SCC"  
850b f1			.pastdmark: pop af  
850c			endm  
# End of macro DMARK
850c					CALLMONITOR 
850c cd 62 93			call break_point_state  
850f				endm  
# End of macro CALLMONITOR
850f				endif 
850f				;  
850f				 
850f 21 40 00			ld hl, STORE_BLOCK_PHY 
8512 11 00 00			ld de, 0 
8515 cd d1 83			call storage_findnextid 
8518			 
8518 22 cc ec			ld (store_tmppageid), hl    ; save page to use  
851b			 
851b				; TODO detect 0 = no spare blocks 
851b			 
851b				; hl now contains the free page to use for the file header page 
851b			 
851b				if DEBUG_STORESE 
851b				DMARK "SCF" 
851b f5				push af  
851c 3a 30 85			ld a, (.dmark)  
851f 32 b7 ee			ld (debug_mark),a  
8522 3a 31 85			ld a, (.dmark+1)  
8525 32 b8 ee			ld (debug_mark+1),a  
8528 3a 32 85			ld a, (.dmark+2)  
852b 32 b9 ee			ld (debug_mark+2),a  
852e 18 03			jr .pastdmark  
8530 ..			.dmark: db "SCF"  
8533 f1			.pastdmark: pop af  
8534			endm  
# End of macro DMARK
8534					CALLMONITOR 
8534 cd 62 93			call break_point_state  
8537				endm  
# End of macro CALLMONITOR
8537				endif 
8537			 
8537 22 cc ec			ld (store_tmppageid), hl 
853a				 
853a 3a db ec			ld a,(store_tmpid)    ; get file id 
853d			;	ld a, (store_filecache)			; save to cache 
853d			 
853d 32 e2 ec			ld (store_page),a    ; set page id 
8540 3e 00			ld a, 0			 ; extent 0 is file header 
8542 32 e3 ec			ld (store_page+1), a   ; set file extent 
8545			 
8545 32 e4 ec			ld (store_page+2), a   ; extent count for the file 
8548			 
8548			;	inc hl 		; init block 0 of file 
8548			;	inc hl   		; skip file and extent id 
8548			 ;       ld a, 0 
8548			;	ld (hl),a 
8548			;	ld a, (store_filecache+1)  	; save to cache 
8548			 
8548			;	inc hl    ; file name 
8548				 
8548				 
8548 11 e5 ec			ld de, store_page+3    ; get buffer for term string to use as file name 
854b				if DEBUG_STORESE 
854b					DMARK "SCc" 
854b f5				push af  
854c 3a 60 85			ld a, (.dmark)  
854f 32 b7 ee			ld (debug_mark),a  
8552 3a 61 85			ld a, (.dmark+1)  
8555 32 b8 ee			ld (debug_mark+1),a  
8558 3a 62 85			ld a, (.dmark+2)  
855b 32 b9 ee			ld (debug_mark+2),a  
855e 18 03			jr .pastdmark  
8560 ..			.dmark: db "SCc"  
8563 f1			.pastdmark: pop af  
8564			endm  
# End of macro DMARK
8564					CALLMONITOR 
8564 cd 62 93			call break_point_state  
8567				endm  
# End of macro CALLMONITOR
8567				endif 
8567 e1				pop hl    ; get zero term string 
8568 e5				push hl 
8569 3e 00			ld a, 0 
856b cd 22 8f			call strlent 
856e 23				inc hl   ; cover zero term 
856f 06 00			ld b,0 
8571 4d				ld c,l 
8572 e1				pop hl 
8573				;ex de, hl 
8573				if DEBUG_STORESE 
8573					DMARK "SCa" 
8573 f5				push af  
8574 3a 88 85			ld a, (.dmark)  
8577 32 b7 ee			ld (debug_mark),a  
857a 3a 89 85			ld a, (.dmark+1)  
857d 32 b8 ee			ld (debug_mark+1),a  
8580 3a 8a 85			ld a, (.dmark+2)  
8583 32 b9 ee			ld (debug_mark+2),a  
8586 18 03			jr .pastdmark  
8588 ..			.dmark: db "SCa"  
858b f1			.pastdmark: pop af  
858c			endm  
# End of macro DMARK
858c					;push af 
858c					;ld a, 'a' 
858c					;ld (debug_mark),a 
858c					;pop af 
858c					CALLMONITOR 
858c cd 62 93			call break_point_state  
858f				endm  
# End of macro CALLMONITOR
858f				endif 
858f ed b0			ldir    ; copy zero term string 
8591				if DEBUG_STORESE 
8591					DMARK "SCA" 
8591 f5				push af  
8592 3a a6 85			ld a, (.dmark)  
8595 32 b7 ee			ld (debug_mark),a  
8598 3a a7 85			ld a, (.dmark+1)  
859b 32 b8 ee			ld (debug_mark+1),a  
859e 3a a8 85			ld a, (.dmark+2)  
85a1 32 b9 ee			ld (debug_mark+2),a  
85a4 18 03			jr .pastdmark  
85a6 ..			.dmark: db "SCA"  
85a9 f1			.pastdmark: pop af  
85aa			endm  
# End of macro DMARK
85aa					CALLMONITOR 
85aa cd 62 93			call break_point_state  
85ad				endm  
# End of macro CALLMONITOR
85ad				endif 
85ad			 
85ad				; write file header page 
85ad			 
85ad 2a cc ec			ld hl,(store_tmppageid) 
85b0 11 e2 ec			ld de, store_page 
85b3				if DEBUG_STORESE 
85b3					DMARK "SCb" 
85b3 f5				push af  
85b4 3a c8 85			ld a, (.dmark)  
85b7 32 b7 ee			ld (debug_mark),a  
85ba 3a c9 85			ld a, (.dmark+1)  
85bd 32 b8 ee			ld (debug_mark+1),a  
85c0 3a ca 85			ld a, (.dmark+2)  
85c3 32 b9 ee			ld (debug_mark+2),a  
85c6 18 03			jr .pastdmark  
85c8 ..			.dmark: db "SCb"  
85cb f1			.pastdmark: pop af  
85cc			endm  
# End of macro DMARK
85cc					;push af 
85cc					;ld a, 'b' 
85cc					;ld (debug_mark),a 
85cc					;pop af 
85cc					CALLMONITOR 
85cc cd 62 93			call break_point_state  
85cf				endm  
# End of macro CALLMONITOR
85cf				endif 
85cf cd 11 81			call storage_write_block 
85d2			 
85d2 3a db ec			ld a, (store_tmpid) 
85d5 6f				ld l, a 
85d6 26 00			ld h,0 
85d8				if DEBUG_STORESE 
85d8					DMARK "SCz" 
85d8 f5				push af  
85d9 3a ed 85			ld a, (.dmark)  
85dc 32 b7 ee			ld (debug_mark),a  
85df 3a ee 85			ld a, (.dmark+1)  
85e2 32 b8 ee			ld (debug_mark+1),a  
85e5 3a ef 85			ld a, (.dmark+2)  
85e8 32 b9 ee			ld (debug_mark+2),a  
85eb 18 03			jr .pastdmark  
85ed ..			.dmark: db "SCz"  
85f0 f1			.pastdmark: pop af  
85f1			endm  
# End of macro DMARK
85f1					CALLMONITOR 
85f1 cd 62 93			call break_point_state  
85f4				endm  
# End of macro CALLMONITOR
85f4				endif 
85f4 c9				ret 
85f5				 
85f5			 
85f5			 
85f5			; 
85f5			; Read File 
85f5			; 
85f5			; h - file id to locate 
85f5			; l - extent to locate 
85f5			; de - pointer to string to read into 
85f5			; 
85f5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85f5			 
85f5			.sr_fail: 
85f5 d1				pop de 
85f6 c9				ret 
85f7			 
85f7			storage_read: 
85f7 d5				push de 
85f8			 
85f8			; TODO BUG the above push is it popped before the RET Z? 
85f8			 
85f8			; TODO how to handle multiple part blocks 
85f8			 
85f8				; locate file extent to read 
85f8			 
85f8 5c				ld e, h 
85f9 55				ld d, l 
85fa 21 40 00			ld hl, STORE_BLOCK_PHY 
85fd				if DEBUG_STORESE 
85fd					DMARK "SRE" 
85fd f5				push af  
85fe 3a 12 86			ld a, (.dmark)  
8601 32 b7 ee			ld (debug_mark),a  
8604 3a 13 86			ld a, (.dmark+1)  
8607 32 b8 ee			ld (debug_mark+1),a  
860a 3a 14 86			ld a, (.dmark+2)  
860d 32 b9 ee			ld (debug_mark+2),a  
8610 18 03			jr .pastdmark  
8612 ..			.dmark: db "SRE"  
8615 f1			.pastdmark: pop af  
8616			endm  
# End of macro DMARK
8616					CALLMONITOR 
8616 cd 62 93			call break_point_state  
8619				endm  
# End of macro CALLMONITOR
8619				endif 
8619 cd d1 83			call storage_findnextid 
861c			 
861c				if DEBUG_STORESE 
861c					DMARK "SRf" 
861c f5				push af  
861d 3a 31 86			ld a, (.dmark)  
8620 32 b7 ee			ld (debug_mark),a  
8623 3a 32 86			ld a, (.dmark+1)  
8626 32 b8 ee			ld (debug_mark+1),a  
8629 3a 33 86			ld a, (.dmark+2)  
862c 32 b9 ee			ld (debug_mark+2),a  
862f 18 03			jr .pastdmark  
8631 ..			.dmark: db "SRf"  
8634 f1			.pastdmark: pop af  
8635			endm  
# End of macro DMARK
8635					CALLMONITOR 
8635 cd 62 93			call break_point_state  
8638				endm  
# End of macro CALLMONITOR
8638				endif 
8638 cd e2 8a			call ishlzero 
863b			;	ld a, l 
863b			;	add h 
863b			;	cp 0 
863b 28 b8			jr z,.sr_fail			; block not found so EOF 
863d			 
863d				; hl contains page number to load 
863d d1				pop de   ; get storage 
863e d5				push de 
863f				if DEBUG_STORESE 
863f					DMARK "SRg" 
863f f5				push af  
8640 3a 54 86			ld a, (.dmark)  
8643 32 b7 ee			ld (debug_mark),a  
8646 3a 55 86			ld a, (.dmark+1)  
8649 32 b8 ee			ld (debug_mark+1),a  
864c 3a 56 86			ld a, (.dmark+2)  
864f 32 b9 ee			ld (debug_mark+2),a  
8652 18 03			jr .pastdmark  
8654 ..			.dmark: db "SRg"  
8657 f1			.pastdmark: pop af  
8658			endm  
# End of macro DMARK
8658					CALLMONITOR 
8658 cd 62 93			call break_point_state  
865b				endm  
# End of macro CALLMONITOR
865b				endif 
865b cd ac 80			call storage_read_block 
865e			 
865e			 
865e			; TODO if block has no zeros then need to read next block  
865e			 
865e			 
865e					 
865e e1				pop hl 		 ; return start of data to show as not EOF 
865f 23				inc hl   ; past file id 
8660 23				inc hl   ; past ext 
8661				if DEBUG_STORESE 
8661					DMARK "SRe" 
8661 f5				push af  
8662 3a 76 86			ld a, (.dmark)  
8665 32 b7 ee			ld (debug_mark),a  
8668 3a 77 86			ld a, (.dmark+1)  
866b 32 b8 ee			ld (debug_mark+1),a  
866e 3a 78 86			ld a, (.dmark+2)  
8671 32 b9 ee			ld (debug_mark+2),a  
8674 18 03			jr .pastdmark  
8676 ..			.dmark: db "SRe"  
8679 f1			.pastdmark: pop af  
867a			endm  
# End of macro DMARK
867a					CALLMONITOR 
867a cd 62 93			call break_point_state  
867d				endm  
# End of macro CALLMONITOR
867d				endif 
867d c9					ret 
867e			 
867e			 
867e			 
867e			; 
867e			; Append File 
867e			; 
867e			; hl - file id to locate 
867e			; de - pointer to (multi block) string to write 
867e			 
867e			.sa_notfound: 
867e d1				pop de 
867f c9				ret 
8680			 
8680			 
8680			storage_append: 
8680				; hl -  file id to append to 
8680				; de - string to append 
8680			 
8680 d5				push de 
8681				 
8681				if DEBUG_STORESE 
8681					DMARK "AP1" 
8681 f5				push af  
8682 3a 96 86			ld a, (.dmark)  
8685 32 b7 ee			ld (debug_mark),a  
8688 3a 97 86			ld a, (.dmark+1)  
868b 32 b8 ee			ld (debug_mark+1),a  
868e 3a 98 86			ld a, (.dmark+2)  
8691 32 b9 ee			ld (debug_mark+2),a  
8694 18 03			jr .pastdmark  
8696 ..			.dmark: db "AP1"  
8699 f1			.pastdmark: pop af  
869a			endm  
# End of macro DMARK
869a					CALLMONITOR 
869a cd 62 93			call break_point_state  
869d				endm  
# End of macro CALLMONITOR
869d				endif 
869d			 
869d 7d				ld a, l 
869e 32 db ec			ld (store_tmpid), a 
86a1			 
86a1				; get file header  
86a1			 
86a1 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
86a3 3a db ec			ld a, (store_tmpid) 
86a6 5f				ld e, a 
86a7			 
86a7 21 40 00				ld hl, STORE_BLOCK_PHY 
86aa cd d1 83				call storage_findnextid 
86ad			 
86ad cd e2 8a			call ishlzero 
86b0 28 cc			jr z, .sa_notfound 
86b2			 
86b2 22 cc ec			ld (store_tmppageid), hl 
86b5			 
86b5				; TODO handle file id not found 
86b5			 
86b5				if DEBUG_STORESE 
86b5					DMARK "AP2" 
86b5 f5				push af  
86b6 3a ca 86			ld a, (.dmark)  
86b9 32 b7 ee			ld (debug_mark),a  
86bc 3a cb 86			ld a, (.dmark+1)  
86bf 32 b8 ee			ld (debug_mark+1),a  
86c2 3a cc 86			ld a, (.dmark+2)  
86c5 32 b9 ee			ld (debug_mark+2),a  
86c8 18 03			jr .pastdmark  
86ca ..			.dmark: db "AP2"  
86cd f1			.pastdmark: pop af  
86ce			endm  
# End of macro DMARK
86ce					CALLMONITOR 
86ce cd 62 93			call break_point_state  
86d1				endm  
# End of macro CALLMONITOR
86d1				endif 
86d1			 
86d1				; update file extent count 
86d1			 
86d1 11 e2 ec			ld de, store_page 
86d4			 
86d4 cd ac 80			call storage_read_block 
86d7			 
86d7				if DEBUG_STORESE 
86d7					DMARK "AP3" 
86d7 f5				push af  
86d8 3a ec 86			ld a, (.dmark)  
86db 32 b7 ee			ld (debug_mark),a  
86de 3a ed 86			ld a, (.dmark+1)  
86e1 32 b8 ee			ld (debug_mark+1),a  
86e4 3a ee 86			ld a, (.dmark+2)  
86e7 32 b9 ee			ld (debug_mark+2),a  
86ea 18 03			jr .pastdmark  
86ec ..			.dmark: db "AP3"  
86ef f1			.pastdmark: pop af  
86f0			endm  
# End of macro DMARK
86f0					CALLMONITOR 
86f0 cd 62 93			call break_point_state  
86f3				endm  
# End of macro CALLMONITOR
86f3				endif 
86f3			;	ld (store_tmppageid), hl 
86f3			 
86f3 3a e4 ec			ld a, (store_page+2) 
86f6 3c				inc a 
86f7 32 e4 ec			ld (store_page+2), a 
86fa 32 da ec			ld (store_tmpext), a 
86fd				 
86fd				if DEBUG_STORESE 
86fd					DMARK "AP3" 
86fd f5				push af  
86fe 3a 12 87			ld a, (.dmark)  
8701 32 b7 ee			ld (debug_mark),a  
8704 3a 13 87			ld a, (.dmark+1)  
8707 32 b8 ee			ld (debug_mark+1),a  
870a 3a 14 87			ld a, (.dmark+2)  
870d 32 b9 ee			ld (debug_mark+2),a  
8710 18 03			jr .pastdmark  
8712 ..			.dmark: db "AP3"  
8715 f1			.pastdmark: pop af  
8716			endm  
# End of macro DMARK
8716					CALLMONITOR 
8716 cd 62 93			call break_point_state  
8719				endm  
# End of macro CALLMONITOR
8719				endif 
8719 2a cc ec			ld hl, (store_tmppageid) 
871c 11 e2 ec			ld de, store_page 
871f cd 11 81			call storage_write_block 
8722			 
8722				; find free block 
8722			 
8722 11 00 00			ld de, 0			 ; file extent to locate 
8725			 
8725 21 40 00				ld hl, STORE_BLOCK_PHY 
8728 cd d1 83				call storage_findnextid 
872b cd e2 8a			call ishlzero 
872e ca 7e 86			jp z, .sa_notfound 
8731			 
8731					; TODO handle no space left 
8731					 
8731 22 cc ec				ld (store_tmppageid), hl 
8734			 
8734				if DEBUG_STORESE 
8734					DMARK "AP4" 
8734 f5				push af  
8735 3a 49 87			ld a, (.dmark)  
8738 32 b7 ee			ld (debug_mark),a  
873b 3a 4a 87			ld a, (.dmark+1)  
873e 32 b8 ee			ld (debug_mark+1),a  
8741 3a 4b 87			ld a, (.dmark+2)  
8744 32 b9 ee			ld (debug_mark+2),a  
8747 18 03			jr .pastdmark  
8749 ..			.dmark: db "AP4"  
874c f1			.pastdmark: pop af  
874d			endm  
# End of macro DMARK
874d					CALLMONITOR 
874d cd 62 93			call break_point_state  
8750				endm  
# End of macro CALLMONITOR
8750				endif 
8750					; init the buffer with zeros so we can id if the buffer is full or not 
8750			 
8750 e5					push hl 
8751 c5					push bc 
8752			 
8752 21 e2 ec				ld hl, store_page 
8755 06 40				ld b, STORE_BLOCK_PHY 
8757 3e 00				ld a, 0 
8759 77			.zeroblock:	ld (hl), a 
875a 23					inc hl 
875b 10 fc				djnz .zeroblock 
875d			 
875d c1					pop bc 
875e e1					pop hl 
875f			 
875f					; construct block 
875f			 
875f 3a db ec				ld a, (store_tmpid) 
8762 32 e2 ec				ld (store_page), a   ; file id 
8765 3a da ec				ld a, (store_tmpext)   ; extent for this block 
8768 32 e3 ec				ld (store_page+1), a 
876b			 
876b e1					pop hl    ; get string to write 
876c 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
876e 11 e4 ec				ld de, store_page+2 
8771			 
8771				if DEBUG_STORESE 
8771					DMARK "AP5" 
8771 f5				push af  
8772 3a 86 87			ld a, (.dmark)  
8775 32 b7 ee			ld (debug_mark),a  
8778 3a 87 87			ld a, (.dmark+1)  
877b 32 b8 ee			ld (debug_mark+1),a  
877e 3a 88 87			ld a, (.dmark+2)  
8781 32 b9 ee			ld (debug_mark+2),a  
8784 18 03			jr .pastdmark  
8786 ..			.dmark: db "AP5"  
8789 f1			.pastdmark: pop af  
878a			endm  
# End of macro DMARK
878a					CALLMONITOR 
878a cd 62 93			call break_point_state  
878d				endm  
# End of macro CALLMONITOR
878d				endif 
878d			 
878d			 
878d			 
878d					; fill buffer with data until end of string or full block 
878d			 
878d 7e			.appd:		ld a, (hl) 
878e 12					ld (de), a 
878f fe 00				cp 0 
8791 28 04				jr z, .appdone 
8793 23					inc hl 
8794 13					inc de 
8795 10 f6				djnz .appd 
8797			 
8797 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8798 f5					push af   		; save last byte dumped 
8799			 
8799			 
8799 2a cc ec			ld hl, (store_tmppageid) 
879c 11 e2 ec			ld de, store_page 
879f				if DEBUG_STORESE 
879f					DMARK "AP6" 
879f f5				push af  
87a0 3a b4 87			ld a, (.dmark)  
87a3 32 b7 ee			ld (debug_mark),a  
87a6 3a b5 87			ld a, (.dmark+1)  
87a9 32 b8 ee			ld (debug_mark+1),a  
87ac 3a b6 87			ld a, (.dmark+2)  
87af 32 b9 ee			ld (debug_mark+2),a  
87b2 18 03			jr .pastdmark  
87b4 ..			.dmark: db "AP6"  
87b7 f1			.pastdmark: pop af  
87b8			endm  
# End of macro DMARK
87b8					CALLMONITOR 
87b8 cd 62 93			call break_point_state  
87bb				endm  
# End of macro CALLMONITOR
87bb				endif 
87bb cd 11 81				call storage_write_block 
87be			 
87be			 
87be				; was that a full block of data written? 
87be				; any more to write out? 
87be			 
87be				; if yes then set vars and jump to start of function again 
87be			 
87be f1					pop af 
87bf d1					pop de 
87c0			 
87c0 fe 00				cp 0		 ; no, string was fully written 
87c2 c8					ret z 
87c3			 
87c3					; setup vars for next cycle 
87c3			 
87c3 3a db ec				ld a, (store_tmpid) 
87c6 6f					ld l, a 
87c7 26 00				ld h, 0 
87c9			 
87c9 c3 80 86			 	jp storage_append	 ; yes, need to write out some more 
87cc			 
87cc			 
87cc			 
87cc			 
87cc			 
87cc			 
87cc			 
87cc			if DEBUG_STORECF 
87cc			storageput:	 
87cc					ret 
87cc			storageread: 
87cc					ld hl, store_page 
87cc					ld b, 200 
87cc					ld a,0 
87cc			.src:		ld (hl),a 
87cc					inc hl 
87cc					djnz .src 
87cc					 
87cc			 
87cc					ld de, 0 
87cc					ld bc, 1 
87cc					ld hl, store_page 
87cc					call cfRead 
87cc			 
87cc				call cfGetError 
87cc				ld hl,scratch 
87cc				call hexout 
87cc				ld hl, scratch+2 
87cc				ld a, 0 
87cc				ld (hl),a 
87cc				ld de, scratch 
87cc				ld a,display_row_1 
87cc				call str_at_display 
87cc				call update_display 
87cc			 
87cc					ld hl, store_page 
87cc					ld (os_cur_ptr),hl 
87cc			 
87cc					ret 
87cc			endif 
87cc			 
87cc			 
87cc			; Clear out the main buffer store (used to remove junk before writing a new block) 
87cc			 
87cc			storage_clear_page: 
87cc e5				push hl 
87cd d5				push de 
87ce c5				push bc 
87cf 21 e2 ec			ld hl, store_page 
87d2 3e 00			ld a, 0 
87d4 77				ld (hl), a 
87d5			 
87d5 11 e3 ec			ld de, store_page+1 
87d8 01 40 00			ld bc, STORE_BLOCK_PHY 
87db			 
87db ed b0			ldir 
87dd				 
87dd c1				pop bc 
87de d1				pop de 
87df e1				pop hl 
87e0 c9				ret 
87e1			 
87e1			; eof 
# End of file firmware_storage.asm
87e1			  
87e1			; support routines for above hardware abstraction layer  
87e1			  
87e1			include "firmware_general.asm"        ; general support functions  
87e1			 
87e1			; word look up 
87e1			 
87e1			; in 
87e1			; a is the index 
87e1			; hl is pointer start of array 
87e1			; 
87e1			; returns 
87e1			; hl to the word 
87e1			; 
87e1			 
87e1			table_lookup:  
87e1 d5					push de 
87e2 eb					ex de, hl 
87e3			 
87e3 6f					ld l, a 
87e4 26 00				ld h, 0 
87e6 29					add hl, hl 
87e7 19					add hl, de 
87e8 7e					ld a, (hl) 
87e9 23					inc hl 
87ea 66					ld h,(hl) 
87eb 6f					ld l, a 
87ec			 
87ec d1					pop de 
87ed c9					ret 
87ee			 
87ee			; Delay loops 
87ee			 
87ee			 
87ee			 
87ee			aDelayInMS: 
87ee c5				push bc 
87ef 47				ld b,a 
87f0			msdelay: 
87f0 c5				push bc 
87f1				 
87f1			 
87f1 01 41 00			ld bc,041h 
87f4 cd 0c 88			call delayloop 
87f7 c1				pop bc 
87f8 05				dec b 
87f9 20 f5			jr nz,msdelay 
87fb			 
87fb			;if CPU_CLOCK_8MHZ 
87fb			;msdelay8: 
87fb			;	push bc 
87fb			;	 
87fb			; 
87fb			;	ld bc,041h 
87fb			;	call delayloop 
87fb			;	pop bc 
87fb			;	dec b 
87fb			;	jr nz,msdelay8 
87fb			;endif 
87fb			 
87fb			 
87fb c1				pop bc 
87fc c9				ret 
87fd			 
87fd			 
87fd			delay250ms: 
87fd				;push de 
87fd 01 00 40			ld bc, 04000h 
8800 c3 0c 88			jp delayloop 
8803			delay500ms: 
8803				;push de 
8803 01 00 80			ld bc, 08000h 
8806 c3 0c 88			jp delayloop 
8809			delay1s: 
8809				;push bc 
8809			   ; Clobbers A, d and e 
8809 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
880c			delayloop: 
880c c5			    push bc 
880d			 
880d			if BASE_CPM 
880d				ld bc, CPM_DELAY_TUNE 
880d			.cpmloop: 
880d				push bc 
880d			 
880d			endif 
880d			 
880d			 
880d			 
880d			delayloopi: 
880d			;	push bc 
880d			;.dl: 
880d cb 47		    bit     0,a    	; 8 
880f cb 47		    bit     0,a    	; 8 
8811 cb 47		    bit     0,a    	; 8 
8813 e6 ff		    and     255  	; 7 
8815 0b			    dec     bc      	; 6 
8816 79			    ld      a,c     	; 4 
8817 b0			    or      b     	; 4 
8818 c2 0d 88		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
881b			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
881b				;pop de 
881b			;pop bc 
881b			 
881b			if BASE_CPM 
881b				pop bc 
881b				 
881b			    dec     bc      	; 6 
881b			    ld      a,c     	; 4 
881b			    or      b     	; 4 
881b			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
881b				 
881b			 
881b			endif 
881b			;if CPU_CLOCK_8MHZ 
881b			;    pop bc 
881b			;    push bc 
881b			;.dl8: 
881b			;    bit     0,a    	; 8 
881b			;    bit     0,a    	; 8 
881b			;    bit     0,a    	; 8 
881b			;    and     255  	; 7 
881b			;    dec     bc      	; 6 
881b			;    ld      a,c     	; 4 
881b			;    or      b     	; 4 
881b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
881b			;endif 
881b			 
881b			;if CPU_CLOCK_10MHZ 
881b			;    pop bc 
881b			;    push bc 
881b			;.dl8: 
881b			;    bit     0,a    	; 8 
881b			;    bit     0,a    	; 8 
881b			;    bit     0,a    	; 8 
881b			;    and     255  	; 7 
881b			;    dec     bc      	; 6 
881b			;    ld      a,c     	; 4 
881b			;    or      b     	; 4 
881b			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
881b			;endif 
881b c1			    pop bc 
881c			 
881c c9				ret 
881d			 
881d			 
881d			 
881d			; eof 
# End of file firmware_general.asm
881d			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
881d			; display routines that use the physical hardware abstraction layer 
881d			 
881d			 
881d			; information window 
881d			 
881d			; pass hl with 1st string to display 
881d			; pass de with 2nd string to display 
881d			 
881d			info_panel: 
881d e5				push hl 
881e			 
881e 2a 58 ed			ld hl, (display_fb_active) 
8821 e5				push hl    ; future de destination 
8822 21 4d ee				ld hl, display_fb0 
8825 22 58 ed				ld (display_fb_active), hl 
8828			 
8828			;	call clear_display 
8828			 
8828				if BASE_CPM 
8828				ld a, '.' 
8828				else 
8828 3e a5			ld a, 165 
882a				endif 
882a cd 91 88			call fill_display 
882d			 
882d			 
882d 3e 2d			ld a, display_row_3 + 5 
882f cd 9f 88			call str_at_display 
8832			 
8832 e1				pop hl 
8833 d1				pop de 
8834			 
8834 e5				push hl 
8835			 
8835			 
8835 3e 19			ld a, display_row_2 + 5 
8837 cd 9f 88			call str_at_display 
883a			 
883a			 
883a cd af 88			call update_display 
883d cd 67 98			call next_page_prompt 
8840 cd 8c 88			call clear_display 
8843			 
8843				 
8843 21 fc ed				ld hl, display_fb1 
8846 22 58 ed				ld (display_fb_active), hl 
8849 cd af 88			call update_display 
884c			 
884c e1				pop hl 
884d			 
884d c9				ret 
884e			 
884e			 
884e			 
884e			 
884e			; TODO windowing? 
884e			 
884e			; TODO scroll line up 
884e			 
884e			scroll_up: 
884e			 
884e e5				push hl 
884f d5				push de 
8850 c5				push bc 
8851			 
8851				; get frame buffer  
8851			 
8851 2a 58 ed			ld hl, (display_fb_active) 
8854 e5				push hl    ; future de destination 
8855			 
8855 11 14 00			ld  de, display_cols 
8858 19				add hl, de 
8859			 
8859 d1				pop de 
885a			 
885a				;ex de, hl 
885a 01 4f 00			ld bc, display_fb_len -1  
885d			;if DEBUG_FORTH_WORDS 
885d			;	DMARK "SCL" 
885d			;	CALLMONITOR 
885d			;endif	 
885d ed b0			ldir 
885f			 
885f				; wipe bottom row 
885f			 
885f			 
885f 2a 58 ed			ld hl, (display_fb_active) 
8862 11 50 00			ld de, display_cols*display_rows 
8865 19				add hl, de 
8866 06 14			ld b, display_cols 
8868 3e 20			ld a, ' ' 
886a			.scwipe: 
886a 77				ld (hl), a 
886b 2b				dec hl 
886c 10 fc			djnz .scwipe 
886e			 
886e				;pop hl 
886e			 
886e c1				pop bc 
886f d1				pop de 
8870 e1				pop hl 
8871			 
8871 c9				ret 
8872			 
8872			 
8872			;scroll_upo: 
8872			;	ld de, display_row_1 
8872			 ;	ld hl, display_row_2 
8872			;	ld bc, display_cols 
8872			;	ldir 
8872			;	ld de, display_row_2 
8872			 ;	ld hl, display_row_3 
8872			;	ld bc, display_cols 
8872			;	ldir 
8872			;	ld de, display_row_3 
8872			 ;	ld hl, display_row_4 
8872			;	ld bc, display_cols 
8872			;	ldir 
8872			 
8872			; TODO clear row 4 
8872			 
8872			;	ret 
8872			 
8872				 
8872			scroll_down: 
8872			 
8872 e5				push hl 
8873 d5				push de 
8874 c5				push bc 
8875			 
8875				; get frame buffer  
8875			 
8875 2a 58 ed			ld hl, (display_fb_active) 
8878			 
8878 11 4f 00			ld de, display_fb_len - 1 
887b 19				add hl, de 
887c			 
887c e5			push hl    ; future de destination 
887d			 
887d 11 14 00			ld  de, display_cols 
8880 ed 52			sbc hl, de 
8882			 
8882			 
8882 d1				pop de 
8883			 
8883			;	ex de, hl 
8883 01 4f 00			ld bc, display_fb_len -1  
8886			 
8886			 
8886				 
8886			 
8886 ed b0			ldir 
8888			 
8888				; wipe bottom row 
8888			 
8888			 
8888			;	ld hl, (display_fb_active) 
8888			;;	ld de, display_cols*display_rows 
8888			;;	add hl, de 
8888			;	ld b, display_cols 
8888			;	ld a, ' ' 
8888			;.scwiped: 
8888			;	ld (hl), a 
8888			;	dec hl 
8888			;	djnz .scwiped 
8888			 
8888				;pop hl 
8888			 
8888 c1				pop bc 
8889 d1				pop de 
888a e1				pop hl 
888b			 
888b c9				ret 
888c			;scroll_down: 
888c			;	ld de, display_row_4 
888c			;	ld hl, display_row_3 
888c			;	ld bc, display_cols 
888c			;	ldir 
888c			;	ld de, display_row_3 
888c			; 	ld hl, display_row_2 
888c			;	ld bc, display_cols 
888c			;	ldir 
888c			;	ld de, display_row_2 
888c			;	ld hl, display_row_1 
888c			;	ld bc, display_cols 
888c			;	ldir 
888c			;;; TODO clear row 1 
888c			;	ret 
888c			 
888c			 
888c			 
888c			 
888c			 
888c			; clear active frame buffer 
888c			 
888c			clear_display: 
888c 3e 20			ld a, ' ' 
888e c3 91 88			jp fill_display 
8891			 
8891			; fill active frame buffer with a char in A 
8891			 
8891			fill_display: 
8891 06 50			ld b,display_fb_len 
8893 2a 58 ed			ld hl, (display_fb_active) 
8896 77			.fd1:	ld (hl),a 
8897 23				inc hl 
8898 10 fc			djnz .fd1 
889a 23				inc hl 
889b 3e 00			ld a,0 
889d 77				ld (hl),a 
889e			 
889e			 
889e c9				ret 
889f			; Write string (DE) at pos (A) to active frame buffer 
889f			 
889f 2a 58 ed		str_at_display:    ld hl,(display_fb_active) 
88a2 06 00					ld b,0 
88a4 4f					ld c,a 
88a5 09					add hl,bc 
88a6 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
88a7 b7			            OR   A              ;Null terminator? 
88a8 c8			            RET  Z              ;Yes, so finished 
88a9 77					ld (hl),a 
88aa 23				inc hl 
88ab 13			            INC  DE             ;Point to next character 
88ac 18 f8		            JR   .sad1     ;Repeat 
88ae c9					ret 
88af			 
88af			; using current frame buffer write to physical display 
88af			 
88af			update_display: 
88af e5				push hl 
88b0 2a 58 ed			ld hl, (display_fb_active) 
88b3 cd 34 d7			call write_display 
88b6 e1				pop hl 
88b7 c9				ret 
88b8			 
88b8			; TODO scrolling 
88b8			 
88b8			 
88b8			; move cursor right one char 
88b8			cursor_right: 
88b8			 
88b8				; TODO shift right 
88b8				; TODO if beyond max col 
88b8				; TODO       cursor_next_line 
88b8			 
88b8 c9				ret 
88b9			 
88b9			 
88b9			cursor_next_line: 
88b9				; TODO first char 
88b9				; TODO line down 
88b9				; TODO if past last row 
88b9				; TODO    scroll up 
88b9			 
88b9 c9				ret 
88ba			 
88ba			cursor_left: 
88ba				; TODO shift left 
88ba				; TODO if beyond left  
88ba				; TODO     cursor prev line 
88ba				 
88ba c9				ret 
88bb			 
88bb			cursor_prev_line: 
88bb				; TODO last char 
88bb				; TODO line up 
88bb				; TODO if past first row 
88bb				; TODO   scroll down 
88bb			 
88bb c9				ret 
88bc			 
88bc			 
88bc			cout: 
88bc				; A - char 
88bc c9				ret 
88bd			 
88bd			 
88bd			; Display a menu and allow item selection (optional toggle items) 
88bd			; 
88bd			; format: 
88bd			; hl pointer to word array with zero term for items 
88bd			; e.g.    db item1 
88bd			;         db .... 
88bd			;         db 0 
88bd			; 
88bd			; a = starting menu item  
88bd			; 
88bd			; de = pointer item toggle array   (todo) 
88bd			; 
88bd			; returns item selected in a 1-... 
88bd			; returns 0 if back button pressed 
88bd			; 
88bd			; NOTE: Uses system frame buffer to display 
88bd			; 
88bd			; LEFT, Q = go back 
88bd			; RIGHT, SPACE, CR = select 
88bd			; UP, A - Up 
88bd			; DOWN, Z - Down 
88bd			 
88bd			 
88bd			 
88bd			 
88bd			 
88bd			menu: 
88bd			 
88bd					; keep array pointer 
88bd			 
88bd 22 e0 ec				ld (store_tmp1), hl 
88c0 32 de ec				ld (store_tmp2), a 
88c3			 
88c3					; check for key bounce 
88c3			 
88c3			if BASE_KEV 
88c3			 
88c3			.mbounce:	call cin 
88c3					cp 0 
88c3					jr nz, .mbounce 
88c3			endif 
88c3					; for ease use ex 
88c3			 
88c3					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
88c3 21 4d ee				ld hl, display_fb0 
88c6 22 58 ed				ld (display_fb_active), hl 
88c9			 
88c9 cd 8c 88		.mloop:		call clear_display 
88cc cd af 88				call update_display 
88cf			 
88cf					; draw selection id '>' at 1 
88cf			 
88cf					; init start of list display 
88cf			 
88cf 3e 05				ld a, 5 
88d1 32 dc ec				ld (store_tmp3), a   ; display row count 
88d4 3a de ec				ld a,( store_tmp2) 
88d7 32 df ec				ld (store_tmp2+1), a   ; display item count 
88da			 
88da					 
88da			.mitem:	 
88da			 
88da			 
88da 3a df ec				ld a,(store_tmp2+1) 
88dd 6f					ld l, a 
88de 26 00				ld h, 0 
88e0 29					add hl, hl 
88e1 ed 5b e0 ec			ld de, (store_tmp1) 
88e5 19					add hl, de 
88e6 7e					ld a, (hl) 
88e7 23					inc hl 
88e8 66					ld h,(hl) 
88e9 6f					ld l, a 
88ea			 
88ea cd e2 8a				call ishlzero 
88ed 28 1a				jr z, .mdone 
88ef			 
88ef eb					ex de, hl 
88f0 3a dc ec				ld a, (store_tmp3) 
88f3 cd 9f 88				call str_at_display 
88f6					 
88f6			 
88f6					; next item 
88f6 3a df ec				ld a, (store_tmp2+1) 
88f9 3c					inc a 
88fa 32 df ec				ld (store_tmp2+1), a   ; display item count 
88fd			 
88fd			 		; next row 
88fd			 
88fd 3a dc ec				ld a, (store_tmp3) 
8900 c6 14				add display_cols 
8902 32 dc ec				ld (store_tmp3), a 
8905			 
8905					; at end of screen? 
8905			 
8905 fe 10				cp display_rows*4 
8907 20 d1				jr nz, .mitem 
8909			 
8909			 
8909			.mdone: 
8909 cd e2 8a				call ishlzero 
890c 28 08				jr z, .nodn 
890e			 
890e 3e 3c				ld a, display_row_4 
8910 11 8f 89				ld de, .mdown 
8913 cd 9f 88				call str_at_display 
8916			 
8916					; draw options to fill the screens with active item on line 1 
8916					; if current option is 2 or more then display ^ in top 
8916			 
8916 3a de ec		.nodn:		ld a, (store_tmp2) 
8919 fe 00				cp 0 
891b 28 08				jr z, .noup 
891d			 
891d 3e 00				ld a, 0 
891f 11 8d 89				ld de, .mup 
8922 cd 9f 88				call str_at_display 
8925			 
8925 3e 02		.noup:		ld a, 2 
8927 11 8b 89				ld de, .msel 
892a cd 9f 88				call str_at_display 
892d			 
892d					; if current option + 1 is not null then display V in bottom 
892d					; get key 
892d cd af 88				call update_display 
8930			 
8930			 
8930					; handle key 
8930			 
8930 cd c0 d7				call cin_wait 
8933			 
8933 fe 05				cp KEY_UP 
8935 28 2b				jr z, .mgoup 
8937 fe 61				cp 'a' 
8939 28 27				jr z, .mgoup 
893b fe 0a				cp KEY_DOWN 
893d 28 32				jr z, .mgod 
893f fe 7a				cp 'z' 
8941 28 2e				jr z, .mgod 
8943 fe 20				cp ' ' 
8945 28 34				jr z, .goend 
8947 fe 0c				cp KEY_RIGHT 
8949 28 30				jr z, .goend 
894b fe 0d				cp KEY_CR 
894d 28 2c				jr z, .goend 
894f fe 71				cp 'q' 
8951 28 0b				jr z, .goback 
8953			 
8953 fe 0b				cp KEY_LEFT 
8955 28 07				jr z, .goback 
8957 fe 08				cp KEY_BS 
8959 28 03				jr z, .goback 
895b c3 c9 88				jp .mloop 
895e			 
895e			.goback: 
895e 3e 00			ld a, 0 
8960 18 1d			jr .goend2 
8962			 
8962				; move up one 
8962			.mgoup: 
8962 3a de ec				ld a, (store_tmp2) 
8965 fe 00				cp 0 
8967 ca c9 88				jp z, .mloop 
896a 3d					dec a 
896b 32 de ec				ld (store_tmp2), a 
896e c3 c9 88				jp .mloop 
8971			 
8971				; move down one 
8971			.mgod: 
8971 3a de ec				ld a, (store_tmp2) 
8974 3c					inc a 
8975 32 de ec				ld (store_tmp2), a 
8978 c3 c9 88				jp .mloop 
897b			 
897b			 
897b			.goend: 
897b					; get selected item number 
897b			 
897b 3a de ec				ld a, (store_tmp2) 
897e 3c					inc a 
897f			 
897f			.goend2: 
897f f5					push af 
8980			 
8980					; restore active fb 
8980					; TODO BUG assumes fb1 
8980			 
8980 21 fc ed				ld hl, display_fb1 
8983 22 58 ed				ld (display_fb_active), hl 
8986			 
8986					; restore main regs 
8986			 
8986			 
8986 cd af 88				call update_display 
8989			 
8989 f1					pop af 
898a			 
898a c9				ret 
898b			 
898b .. 00		.msel:   db ">",0 
898d .. 00		.mup:   db "^",0 
898f .. 00		.mdown:   db "v",0 
8991			 
8991			 
8991			; eof 
8991			 
# End of file firmware_display.asm
8991			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8991			; random number generators 
8991			 
8991			 
8991			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8991			 
8991			 
8991			;-----> Generate a random number 
8991			; output a=answer 0<=a<=255 
8991			; all registers are preserved except: af 
8991			random: 
8991 e5			        push    hl 
8992 d5			        push    de 
8993 2a 3a ed		        ld      hl,(randData) 
8996 ed 5f		        ld      a,r 
8998 57			        ld      d,a 
8999 5e			        ld      e,(hl) 
899a 19			        add     hl,de 
899b 85			        add     a,l 
899c ac			        xor     h 
899d 22 3a ed		        ld      (randData),hl 
89a0 d1			        pop     de 
89a1 e1			        pop     hl 
89a2 c9			        ret 
89a3			 
89a3			 
89a3			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
89a3			 
89a3			 
89a3			 
89a3			;------LFSR------ 
89a3			;James Montelongo 
89a3			;optimized by Spencer Putt 
89a3			;out: 
89a3			; a = 8 bit random number 
89a3			RandLFSR: 
89a3 21 40 ed		        ld hl,LFSRSeed+4 
89a6 5e			        ld e,(hl) 
89a7 23			        inc hl 
89a8 56			        ld d,(hl) 
89a9 23			        inc hl 
89aa 4e			        ld c,(hl) 
89ab 23			        inc hl 
89ac 7e			        ld a,(hl) 
89ad 47			        ld b,a 
89ae cb 13		        rl e  
89b0 cb 12			rl d 
89b2 cb 11		        rl c  
89b4 17				rla 
89b5 cb 13		        rl e  
89b7 cb 12			rl d 
89b9 cb 11		        rl c  
89bb 17				rla 
89bc cb 13		        rl e  
89be cb 12			rl d 
89c0 cb 11		        rl c  
89c2 17				rla 
89c3 67			        ld h,a 
89c4 cb 13		        rl e  
89c6 cb 12			rl d 
89c8 cb 11		        rl c  
89ca 17				rla 
89cb a8			        xor b 
89cc cb 13		        rl e  
89ce cb 12			rl d 
89d0 ac			        xor h 
89d1 a9			        xor c 
89d2 aa			        xor d 
89d3 21 42 ed		        ld hl,LFSRSeed+6 
89d6 11 43 ed		        ld de,LFSRSeed+7 
89d9 01 07 00		        ld bc,7 
89dc ed b8		        lddr 
89de 12			        ld (de),a 
89df c9			        ret 
89e0			 
89e0			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
89e0			 
89e0			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
89e0			 
89e0			 
89e0			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
89e0			 
89e0			prng16: 
89e0			;Inputs: 
89e0			;   (seed1) contains a 16-bit seed value 
89e0			;   (seed2) contains a NON-ZERO 16-bit seed value 
89e0			;Outputs: 
89e0			;   HL is the result 
89e0			;   BC is the result of the LCG, so not that great of quality 
89e0			;   DE is preserved 
89e0			;Destroys: 
89e0			;   AF 
89e0			;cycle: 4,294,901,760 (almost 4.3 billion) 
89e0			;160cc 
89e0			;26 bytes 
89e0 2a 34 ed		    ld hl,(seed1) 
89e3 44			    ld b,h 
89e4 4d			    ld c,l 
89e5 29			    add hl,hl 
89e6 29			    add hl,hl 
89e7 2c			    inc l 
89e8 09			    add hl,bc 
89e9 22 34 ed		    ld (seed1),hl 
89ec 2a 32 ed		    ld hl,(seed2) 
89ef 29			    add hl,hl 
89f0 9f			    sbc a,a 
89f1 e6 2d		    and %00101101 
89f3 ad			    xor l 
89f4 6f			    ld l,a 
89f5 22 32 ed		    ld (seed2),hl 
89f8 09			    add hl,bc 
89f9 c9			    ret 
89fa			 
89fa			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
89fa			 
89fa			rand32: 
89fa			;Inputs: 
89fa			;   (seed1_0) holds the lower 16 bits of the first seed 
89fa			;   (seed1_1) holds the upper 16 bits of the first seed 
89fa			;   (seed2_0) holds the lower 16 bits of the second seed 
89fa			;   (seed2_1) holds the upper 16 bits of the second seed 
89fa			;   **NOTE: seed2 must be non-zero 
89fa			;Outputs: 
89fa			;   HL is the result 
89fa			;   BC,DE can be used as lower quality values, but are not independent of HL. 
89fa			;Destroys: 
89fa			;   AF 
89fa			;Tested and passes all CAcert tests 
89fa			;Uses a very simple 32-bit LCG and 32-bit LFSR 
89fa			;it has a period of 18,446,744,069,414,584,320 
89fa			;roughly 18.4 quintillion. 
89fa			;LFSR taps: 0,2,6,7  = 11000101 
89fa			;291cc 
89fa			;seed1_0=$+1 
89fa			;    ld hl,12345 
89fa			;seed1_1=$+1 
89fa			;    ld de,6789 
89fa			;    ld b,h 
89fa			;    ld c,l 
89fa			;    add hl,hl \ rl e \ rl d 
89fa			;    add hl,hl \ rl e \ rl d 
89fa			;    inc l 
89fa			;    add hl,bc 
89fa			;    ld (seed1_0),hl 
89fa			;    ld hl,(seed1_1) 
89fa			;    adc hl,de 
89fa			;    ld (seed1_1),hl 
89fa			;    ex de,hl 
89fa			;seed2_0=$+1 
89fa			;    ld hl,9876 
89fa			;seed2_1=$+1 
89fa			;    ld bc,54321 
89fa			;    add hl,hl \ rl c \ rl b 
89fa			;    ld (seed2_1),bc 
89fa			;    sbc a,a 
89fa			;    and %11000101 
89fa			;    xor l 
89fa			;    ld l,a 
89fa			;    ld (seed2_0),hl 
89fa			;    ex de,hl 
89fa			;    add hl,bc 
89fa			;    ret 
89fa			; 
89fa			 
89fa			; 16-bit xorshift pseudorandom number generator by John Metcalf 
89fa			; 20 bytes, 86 cycles (excluding ret) 
89fa			 
89fa			; returns   hl = pseudorandom number 
89fa			; corrupts   a 
89fa			 
89fa			; generates 16-bit pseudorandom numbers with a period of 65535 
89fa			; using the xorshift method: 
89fa			 
89fa			; hl ^= hl << 7 
89fa			; hl ^= hl >> 9 
89fa			; hl ^= hl << 8 
89fa			 
89fa			; some alternative shift triplets which also perform well are: 
89fa			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
89fa			 
89fa			;  org 32768 
89fa			 
89fa			xrnd: 
89fa 2a 38 ed		  ld hl,(xrandc)       ; seed must not be 0 
89fd 3e 00		  ld a,0 
89ff bd			  cp l 
8a00 20 02		  jr nz, .xrnd1 
8a02 2e 01		  ld l, 1 
8a04			.xrnd1: 
8a04			 
8a04 7c			  ld a,h 
8a05 1f			  rra 
8a06 7d			  ld a,l 
8a07 1f			  rra 
8a08 ac			  xor h 
8a09 67			  ld h,a 
8a0a 7d			  ld a,l 
8a0b 1f			  rra 
8a0c 7c			  ld a,h 
8a0d 1f			  rra 
8a0e ad			  xor l 
8a0f 6f			  ld l,a 
8a10 ac			  xor h 
8a11 67			  ld h,a 
8a12			 
8a12 22 38 ed		  ld (xrandc),hl 
8a15			 
8a15 c9			  ret 
8a16			;  
8a16			 
8a16			 
8a16			;;;; int maths 
8a16			 
8a16			; https://map.grauw.nl/articles/mult_div_shifts.php 
8a16			; Divide 16-bit values (with 16-bit result) 
8a16			; In: Divide BC by divider DE 
8a16			; Out: BC = result, HL = rest 
8a16			; 
8a16			Div16: 
8a16 21 00 00		    ld hl,0 
8a19 78			    ld a,b 
8a1a 06 08		    ld b,8 
8a1c			Div16_Loop1: 
8a1c 17			    rla 
8a1d ed 6a		    adc hl,hl 
8a1f ed 52		    sbc hl,de 
8a21 30 01		    jr nc,Div16_NoAdd1 
8a23 19			    add hl,de 
8a24			Div16_NoAdd1: 
8a24 10 f6		    djnz Div16_Loop1 
8a26 17			    rla 
8a27 2f			    cpl 
8a28 47			    ld b,a 
8a29 79			    ld a,c 
8a2a 48			    ld c,b 
8a2b 06 08		    ld b,8 
8a2d			Div16_Loop2: 
8a2d 17			    rla 
8a2e ed 6a		    adc hl,hl 
8a30 ed 52		    sbc hl,de 
8a32 30 01		    jr nc,Div16_NoAdd2 
8a34 19			    add hl,de 
8a35			Div16_NoAdd2: 
8a35 10 f6		    djnz Div16_Loop2 
8a37 17			    rla 
8a38 2f			    cpl 
8a39 41			    ld b,c 
8a3a 4f			    ld c,a 
8a3b c9			ret 
8a3c			 
8a3c			 
8a3c			;http://z80-heaven.wikidot.com/math 
8a3c			; 
8a3c			;Inputs: 
8a3c			;     DE and A are factors 
8a3c			;Outputs: 
8a3c			;     A is not changed 
8a3c			;     B is 0 
8a3c			;     C is not changed 
8a3c			;     DE is not changed 
8a3c			;     HL is the product 
8a3c			;Time: 
8a3c			;     342+6x 
8a3c			; 
8a3c			Mult16: 
8a3c			 
8a3c 06 08		     ld b,8          ;7           7 
8a3e 21 00 00		     ld hl,0         ;10         10 
8a41 29			       add hl,hl     ;11*8       88 
8a42 07			       rlca          ;4*8        32 
8a43 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8a45 19			         add hl,de   ;--         -- 
8a46 10 f9		       djnz $-5      ;13*7+8     99 
8a48 c9			ret 
8a49			 
8a49			; 
8a49			; Square root of 16-bit value 
8a49			; In:  HL = value 
8a49			; Out:  D = result (rounded down) 
8a49			; 
8a49			;Sqr16: 
8a49			;    ld de,#0040 
8a49			;    ld a,l 
8a49			;    ld l,h 
8a49			;    ld h,d 
8a49			;    or a 
8a49			;    ld b,8 
8a49			;Sqr16_Loop: 
8a49			;    sbc hl,de 
8a49			;    jr nc,Sqr16_Skip 
8a49			;    add hl,de 
8a49			;Sqr16_Skip: 
8a49			;    ccf 
8a49			;    rl d 
8a49			;    add a,a 
8a49			;    adc hl,hl 
8a49			;    add a,a 
8a49			;    adc hl,hl 
8a49			;    djnz Sqr16_Loop 
8a49			;    ret 
8a49			; 
8a49			; 
8a49			; Divide 8-bit values 
8a49			; In: Divide E by divider C 
8a49			; Out: A = result, B = rest 
8a49			; 
8a49			Div8: 
8a49 af			    xor a 
8a4a 06 08		    ld b,8 
8a4c			Div8_Loop: 
8a4c cb 13		    rl e 
8a4e 17			    rla 
8a4f 91			    sub c 
8a50 30 01		    jr nc,Div8_NoAdd 
8a52 81			    add a,c 
8a53			Div8_NoAdd: 
8a53 10 f7		    djnz Div8_Loop 
8a55 47			    ld b,a 
8a56 7b			    ld a,e 
8a57 17			    rla 
8a58 2f			    cpl 
8a59 c9			    ret 
8a5a			 
8a5a			; 
8a5a			; Multiply 8-bit value with a 16-bit value (unrolled) 
8a5a			; In: Multiply A with DE 
8a5a			; Out: HL = result 
8a5a			; 
8a5a			Mult12U: 
8a5a 2e 00		    ld l,0 
8a5c 87			    add a,a 
8a5d 30 01		    jr nc,Mult12U_NoAdd0 
8a5f 19			    add hl,de 
8a60			Mult12U_NoAdd0: 
8a60 29			    add hl,hl 
8a61 87			    add a,a 
8a62 30 01		    jr nc,Mult12U_NoAdd1 
8a64 19			    add hl,de 
8a65			Mult12U_NoAdd1: 
8a65 29			    add hl,hl 
8a66 87			    add a,a 
8a67 30 01		    jr nc,Mult12U_NoAdd2 
8a69 19			    add hl,de 
8a6a			Mult12U_NoAdd2: 
8a6a 29			    add hl,hl 
8a6b 87			    add a,a 
8a6c 30 01		    jr nc,Mult12U_NoAdd3 
8a6e 19			    add hl,de 
8a6f			Mult12U_NoAdd3: 
8a6f 29			    add hl,hl 
8a70 87			    add a,a 
8a71 30 01		    jr nc,Mult12U_NoAdd4 
8a73 19			    add hl,de 
8a74			Mult12U_NoAdd4: 
8a74 29			    add hl,hl 
8a75 87			    add a,a 
8a76 30 01		    jr nc,Mult12U_NoAdd5 
8a78 19			    add hl,de 
8a79			Mult12U_NoAdd5: 
8a79 29			    add hl,hl 
8a7a 87			    add a,a 
8a7b 30 01		    jr nc,Mult12U_NoAdd6 
8a7d 19			    add hl,de 
8a7e			Mult12U_NoAdd6: 
8a7e 29			    add hl,hl 
8a7f 87			    add a,a 
8a80 d0			    ret nc 
8a81 19			    add hl,de 
8a82 c9			    ret 
8a83			 
8a83			; 
8a83			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a83			; In: Multiply A with DE 
8a83			;      Put lowest value in A for most efficient calculation 
8a83			; Out: HL = result 
8a83			; 
8a83			Mult12R: 
8a83 21 00 00		    ld hl,0 
8a86			Mult12R_Loop: 
8a86 cb 3f		    srl a 
8a88 30 01		    jr nc,Mult12R_NoAdd 
8a8a 19			    add hl,de 
8a8b			Mult12R_NoAdd: 
8a8b cb 23		    sla e 
8a8d cb 12		    rl d 
8a8f b7			    or a 
8a90 c2 86 8a		    jp nz,Mult12R_Loop 
8a93 c9			    ret 
8a94			 
8a94			; 
8a94			; Multiply 16-bit values (with 32-bit result) 
8a94			; In: Multiply BC with DE 
8a94			; Out: BCHL = result 
8a94			; 
8a94			Mult32: 
8a94 79			    ld a,c 
8a95 48			    ld c,b 
8a96 21 00 00		    ld hl,0 
8a99 06 10		    ld b,16 
8a9b			Mult32_Loop: 
8a9b 29			    add hl,hl 
8a9c 17			    rla 
8a9d cb 11		    rl c 
8a9f 30 07		    jr nc,Mult32_NoAdd 
8aa1 19			    add hl,de 
8aa2 ce 00		    adc a,0 
8aa4 d2 a8 8a		    jp nc,Mult32_NoAdd 
8aa7 0c			    inc c 
8aa8			Mult32_NoAdd: 
8aa8 10 f1		    djnz Mult32_Loop 
8aaa 41			    ld b,c 
8aab 4f			    ld c,a 
8aac c9			    ret 
8aad			 
8aad			 
8aad			 
8aad			; 
8aad			; Multiply 8-bit values 
8aad			; In:  Multiply H with E 
8aad			; Out: HL = result 
8aad			; 
8aad			Mult8: 
8aad 16 00		    ld d,0 
8aaf 6a			    ld l,d 
8ab0 06 08		    ld b,8 
8ab2			Mult8_Loop: 
8ab2 29			    add hl,hl 
8ab3 30 01		    jr nc,Mult8_NoAdd 
8ab5 19			    add hl,de 
8ab6			Mult8_NoAdd: 
8ab6 10 fa		    djnz Mult8_Loop 
8ab8 c9			    ret 
8ab9			 
8ab9			 
8ab9			 
8ab9			 
8ab9			 
8ab9			 
8ab9			 
8ab9			 
8ab9			;;http://z80-heaven.wikidot.com/math 
8ab9			;;This divides DE by BC, storing the result in DE, remainder in HL 
8ab9			; 
8ab9			;DE_Div_BC:          ;1281-2x, x is at most 16 
8ab9			;     ld a,16        ;7 
8ab9			;     ld hl,0        ;10 
8ab9			;     jp $+5         ;10 
8ab9			;.DivLoop: 
8ab9			;       add hl,bc    ;-- 
8ab9			;       dec a        ;64 
8ab9			;       jr z,.DivLoopEnd        ;86 
8ab9			; 
8ab9			;       sla e        ;128 
8ab9			;       rl d         ;128 
8ab9			;       adc hl,hl    ;240 
8ab9			;       sbc hl,bc    ;240 
8ab9			;       jr nc,.DivLoop ;23|21 
8ab9			;       inc e        ;-- 
8ab9			;       jp .DivLoop+1 
8ab9			; 
8ab9			;.DivLoopEnd: 
8ab9			 
8ab9			;HL_Div_C: 
8ab9			;Inputs: 
8ab9			;     HL is the numerator 
8ab9			;     C is the denominator 
8ab9			;Outputs: 
8ab9			;     A is the remainder 
8ab9			;     B is 0 
8ab9			;     C is not changed 
8ab9			;     DE is not changed 
8ab9			;     HL is the quotient 
8ab9			; 
8ab9			;       ld b,16 
8ab9			;       xor a 
8ab9			;         add hl,hl 
8ab9			;         rla 
8ab9			;         cp c 
8ab9			;         jr c,$+4 
8ab9			;           inc l 
8ab9			;           sub c 
8ab9			;         djnz $-7 
8ab9			 
8ab9			; https://plutiedev.com/z80-add-8bit-to-16bit 
8ab9			 
8ab9			addatohl: 
8ab9 85			    add   a, l    ; A = A+L 
8aba 6f			    ld    l, a    ; L = A+L 
8abb 8c			    adc   a, h    ; A = A+L+H+carry 
8abc 95			    sub   l       ; A = H+carry 
8abd 67			    ld    h, a    ; H = H+carry 
8abe c9			ret 
8abf			 
8abf			addatode: 
8abf 83			    add   a, e    ; A = A+L 
8ac0 5f			    ld    e, a    ; L = A+L 
8ac1 8a			    adc   a, d    ; A = A+L+H+carry 
8ac2 93			    sub   e       ; A = H+carry 
8ac3 57			    ld    d, a    ; H = H+carry 
8ac4 c9			ret 
8ac5			 
8ac5			 
8ac5			addatobc: 
8ac5 81			    add   a, c    ; A = A+L 
8ac6 4f			    ld    c, a    ; L = A+L 
8ac7 88			    adc   a, b    ; A = A+L+H+carry 
8ac8 91			    sub   c       ; A = H+carry 
8ac9 47			    ld    b, a    ; H = H+carry 
8aca c9			ret 
8acb			 
8acb			subafromhl: 
8acb			   ; If A=0 do nothing 
8acb			    ; Otherwise flip A's sign. Since 
8acb			    ; the upper byte becomes -1, also 
8acb			    ; substract 1 from H. 
8acb ed 44		    neg 
8acd ca d6 8a		    jp    z, Skip 
8ad0 25			    dec   h 
8ad1			     
8ad1			    ; Now add the low byte as usual 
8ad1			    ; Two's complement takes care of 
8ad1			    ; ensuring the result is correct 
8ad1 85			    add   a, l 
8ad2 6f			    ld    l, a 
8ad3 8c			    adc   a, h 
8ad4 95			    sub   l 
8ad5 67			    ld    h, a 
8ad6			Skip: 
8ad6 c9				ret 
8ad7			 
8ad7			 
8ad7			; compare hl and de 
8ad7			; returns:  
8ad7			; if hl = de, z=1, s=0, c0=0 
8ad7			; if hl > de, z=0, s=0, c=0 
8ad7			; if hl < de, z=0, s=1, c=1 
8ad7			cmp16:	 
8ad7 b7				or a 
8ad8 ed 52			sbc hl,de 
8ada e0				ret po 
8adb 7c				ld a,h 
8adc 1f				rra 
8add ee 40			xor 01000000B 
8adf 37				scf 
8ae0 8f				adc a,a 
8ae1 c9				ret 
8ae2			 
8ae2			 
8ae2			; test if hl contains zero   - A is destroyed 
8ae2			 
8ae2			ishlzero:    
8ae2 b7				or a     ; reset flags 
8ae3 7c				ld a, h 
8ae4 b5				or l        	 
8ae5			 
8ae5 c9				ret 
8ae6			 
8ae6			 
8ae6			 
8ae6			 
8ae6			if FORTH_ENABLE_FLOATMATH 
8ae6			;include "float/bbcmath.z80" 
8ae6			include "float/lpfpcalc.asm" 
8ae6			endif 
8ae6			 
8ae6			 
8ae6			; eof 
8ae6			 
# End of file firmware_maths.asm
8ae6			include "firmware_strings.asm"   ; string handling  
8ae6			 
8ae6			 
8ae6			; TODO string len 
8ae6			; input text string, end on cr with zero term 
8ae6			; a offset into frame buffer to start prompt 
8ae6			; d is max length 
8ae6			; e is display size TODO 
8ae6			; c is current cursor position 
8ae6			; hl is ptr to where string will be stored 
8ae6			 
8ae6			 
8ae6			; TODO check limit of buffer for new inserts 
8ae6			; TODO check insert does not push beyond buffer 
8ae6			; TODO scroll in a limited display area 
8ae6			; TODO scroll whole screen on page wrap 
8ae6			 
8ae6			 
8ae6			; TODO handle KEY_PREVWORD 
8ae6			; TODO handle KEY_NEXTWORD 
8ae6			; TODO handle KEY_HOME 
8ae6			; TODO handle KEY_END 
8ae6			; TODO use LCD cursor? 
8ae6			 
8ae6 32 b0 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8ae9 81					add c 
8aea 32 ae ee				ld (input_at_cursor),a	; save draw pos of cursor 
8aed 22 b3 ee				ld (input_start), hl     ; save ptr to buffer 
8af0 79					ld a, c 
8af1 cd b9 8a				call addatohl 
8af4 22 b5 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8af7 7a					ld a,d 
8af8 32 b2 ee			        ld (input_size), a       ; save length of input area 
8afb 79					ld a, c 
8afc 32 a1 ee				ld (input_cursor),a      ; init cursor start position  
8aff 7b					ld a,e 
8b00 32 b1 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8b03					 
8b03					 
8b03			 
8b03			;		ld a,(input_ptr) 
8b03			;		ld (input_under_cursor),a 	; save what is under the cursor 
8b03			 
8b03			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8b03					; init cursor shape if not set by the cin routines 
8b03 21 50 ed				ld hl, cursor_shape 
8b06 3e ff				ld a, 255 
8b08 77					ld (hl), a 
8b09 23					inc hl 
8b0a 3e 00				ld a, 0 
8b0c 77					ld (hl), a 
8b0d			 
8b0d 3e 0f				ld a, CUR_BLINK_RATE 
8b0f 32 ac ee				ld (input_cur_flash), a 
8b12 3e 01				ld a, 1 
8b14 32 ab ee				ld (input_cur_onoff),a 
8b17			 
8b17			;	if DEBUG_INPUT 
8b17			;		push af 
8b17			;		ld a, 'I' 
8b17			;		ld (debug_mark),a 
8b17			;		pop af 
8b17			;		CALLMONITOR 
8b17			;	endif 
8b17			.is1:		; main entry loop 
8b17			 
8b17			 
8b17			 
8b17					; pause 1ms 
8b17			 
8b17 3e 01				ld a, 1 
8b19 cd ee 87				call aDelayInMS 
8b1c			 
8b1c					; dec flash counter 
8b1c 3a ac ee				ld a, (input_cur_flash) 
8b1f 3d					dec a 
8b20 32 ac ee				ld (input_cur_flash), a 
8b23 fe 00				cp 0 
8b25 20 0d				jr nz, .nochgstate 
8b27			 
8b27			 
8b27					; change state 
8b27 3a ab ee				ld a,(input_cur_onoff) 
8b2a ed 44				neg 
8b2c 32 ab ee				ld (input_cur_onoff),a 
8b2f			 
8b2f			 
8b2f					; reset on change of state 
8b2f 3e 0f				ld a, CUR_BLINK_RATE 
8b31 32 ac ee				ld (input_cur_flash), a 
8b34			 
8b34			.nochgstate: 
8b34					 
8b34					 
8b34			 
8b34					; display cursor  
8b34			 
8b34			;		ld hl, (input_start) 
8b34			;		ld a, (input_cursor) 
8b34			;		call addatohl 
8b34			 
8b34					; get char under cursor and replace with cursor 
8b34 2a b5 ee		ld hl, (input_ptr) 
8b37			;		ld a, (hl) 
8b37			;		ld (input_under_cursor),a 
8b37			;		ld a, '_' 
8b37			;		ld (hl), a 
8b37			 
8b37					; display string 
8b37			 
8b37 ed 5b b3 ee			ld de, (input_start) 
8b3b 3a b0 ee				ld a, (input_at_pos) 
8b3e cd 9f 88				call str_at_display 
8b41			;	        call update_display 
8b41			 
8b41					; find place to put the cursor 
8b41			;		add h 
8b41			;		ld l, display_row_1 
8b41			;		sub l 
8b41			; (input_at_pos) 
8b41					;ld c, a 
8b41			;		ld a, (input_cursor) 
8b41			;		ld l, (input_at_pos) 
8b41			;		;ld b, h 
8b41			;		add l 
8b41			;		ld (input_at_cursor),a 
8b41					;ld l,h 
8b41			 
8b41			;		ld h, 0 
8b41			;		ld l,(input_at_pos) 
8b41			;		ld a, (input_cursor) 
8b41			;		call addatohl 
8b41			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8b41			;		call subafromhl 
8b41			;		ld a,l 
8b41			;		ld (input_at_cursor), a 
8b41			 
8b41				if DEBUG_INPUT 
8b41					ld a, (hardware_diag) 
8b41					cp 0 
8b41					jr z, .skip_input_diag 
8b41			 
8b41					ld a,(input_at_pos) 
8b41					ld hl, LFSRSeed 
8b41					call hexout 
8b41					ld a, (input_cursor) 
8b41					ld hl, LFSRSeed+2 
8b41					call hexout 
8b41					ld a,(input_at_cursor) 
8b41					ld hl, LFSRSeed+4 
8b41					call hexout 
8b41			 
8b41					ld a,(input_cur_onoff) 
8b41					ld hl, LFSRSeed+6 
8b41					call hexout 
8b41			 
8b41					ld a,(input_cur_flash) 
8b41					ld hl, LFSRSeed+8 
8b41					call hexout 
8b41			 
8b41					ld a,(input_len) 
8b41					ld hl, LFSRSeed+10 
8b41					call hexout 
8b41					ld hl, LFSRSeed+12 
8b41					ld a, 0 
8b41					ld (hl),a 
8b41					ld a, display_row_4 
8b41					ld de, LFSRSeed 
8b41					call str_at_display 
8b41					.skip_input_diag: 
8b41				endif 
8b41			 
8b41					; decide on if we are showing the cursor this time round 
8b41			 
8b41 3a ab ee				ld a, (input_cur_onoff) 
8b44 fe ff				cp 255 
8b46 28 13				jr z, .skipcur 
8b48			 
8b48			 
8b48 3a ae ee				ld a,(input_at_cursor) 
8b4b 11 50 ed				ld de, cursor_shape 
8b4e cd 9f 88				call str_at_display 
8b51			 
8b51					; save length of current input string 
8b51 2a b3 ee				ld hl, (input_start) 
8b54 cd 17 8f				call strlenz 
8b57 7d					ld a,l 
8b58 32 a6 ee				ld (input_len),a 
8b5b			 
8b5b			.skipcur: 
8b5b			 
8b5b cd af 88			        call update_display 
8b5e					 
8b5e			 
8b5e			 
8b5e					; wait 
8b5e				 
8b5e					; TODO loop without wait to flash the cursor and char under cursor	 
8b5e cd c6 d7				call cin    ; _wait 
8b61			 
8b61 fe 00				cp 0 
8b63 ca 17 8b				jp z, .is1 
8b66			 
8b66					; get ptr to char to input into 
8b66			 
8b66 4f					ld c,a 
8b67 2a b3 ee				ld hl, (input_start) 
8b6a 3a a1 ee				ld a, (input_cursor) 
8b6d cd b9 8a				call addatohl 
8b70 22 b5 ee				ld (input_ptr), hl 
8b73 79					ld a,c 
8b74			 
8b74					; replace char under cursor 
8b74			 
8b74			;		ld hl, (input_ptr) 
8b74			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b74			;		ld (hl), a 
8b74			 
8b74			;	if DEBUG_INPUT 
8b74			;		push af 
8b74			;		ld a, 'i' 
8b74			;		ld (debug_mark),a 
8b74			;		pop af 
8b74			;		CALLMONITOR 
8b74			;	endif 
8b74 fe 0e				cp KEY_HOME 
8b76 20 0e				jr nz, .iske 
8b78			 
8b78 3a b0 ee				ld a, (input_at_pos) 
8b7b 32 ae ee				ld (input_at_cursor),a 
8b7e 3e 00				ld a, 0 
8b80 32 a1 ee				ld (input_cursor), a 
8b83 c3 17 8b				jp .is1 
8b86					 
8b86 fe 0f		.iske:		cp KEY_END 
8b88 20 03				jr nz, .isknw 
8b8a c3 17 8b				jp .is1 
8b8d			 
8b8d fe 06		.isknw:		cp KEY_NEXTWORD 
8b8f 20 1b				jr nz, .iskpw 
8b91			 
8b91 2a b5 ee		.isknwm:	ld hl, (input_ptr) 
8b94 7e					ld a,(hl)	 
8b95 fe 00				cp 0 
8b97 ca 17 8b				jp z, .is1    ; end of string 
8b9a fe 20				cp ' ' 
8b9c ca 17 8b				jp z, .is1    ; end of word 
8b9f 23					inc hl 
8ba0 22 b5 ee				ld (input_ptr), hl 
8ba3 3a ae ee				ld a, (input_at_cursor) 
8ba6 3c					inc a 
8ba7 32 ae ee				ld (input_at_cursor), a 
8baa 18 e5				jr .isknwm 
8bac			 
8bac fe 07		.iskpw:		cp KEY_PREVWORD 
8bae 20 1b				jr nz, .iskl 
8bb0			.iskpwm:	 
8bb0 2a b5 ee				ld hl, (input_ptr) 
8bb3 7e					ld a,(hl)	 
8bb4 fe 00				cp 0  
8bb6 ca 17 8b				jp z, .is1    ; end of string 
8bb9 fe 20				cp ' ' 
8bbb ca 17 8b				jp z, .is1    ; end of word 
8bbe 2b					dec hl 
8bbf 22 b5 ee				ld (input_ptr), hl 
8bc2 3a ae ee				ld a, (input_at_cursor) 
8bc5 3d					dec a 
8bc6 32 ae ee				ld (input_at_cursor), a 
8bc9 18 e5				jr .iskpwm 
8bcb			 
8bcb			 
8bcb fe 0b		.iskl:		cp KEY_LEFT 
8bcd 20 27				jr nz, .isk1 
8bcf			 
8bcf 3a a1 ee				ld a, (input_cursor) 
8bd2			 
8bd2 fe 00				cp 0 
8bd4 ca 17 8b				jp z, .is1 		; at start of line to ignore  
8bd7			 
8bd7 3d					dec  a 		; TODO check underflow 
8bd8 32 a1 ee				ld (input_cursor), a 
8bdb			 
8bdb 2a b5 ee				ld hl, (input_ptr) 
8bde 2b					dec hl 
8bdf 22 b5 ee				ld (input_ptr), hl 
8be2					 
8be2 3a ae ee				ld a, (input_at_cursor) 
8be5 3d					dec a 
8be6 32 ae ee				ld (input_at_cursor), a 
8be9			 
8be9 3e 01				ld a, 1		; show cursor moving 
8beb 32 ab ee				ld (input_cur_onoff),a 
8bee 3e 0f				ld a, CUR_BLINK_RATE 
8bf0 32 ac ee				ld (input_cur_flash), a 
8bf3			 
8bf3 c3 17 8b				jp .is1 
8bf6			 
8bf6 fe 0c		.isk1:		cp KEY_RIGHT 
8bf8 20 2a				jr nz, .isk2 
8bfa			 
8bfa 3a a6 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8bfd 5f					ld e,a 
8bfe 3a a1 ee				ld a, (input_cursor) 
8c01 bb					cp e 
8c02 ca 17 8b				jp z, .is1		; at the end of string so dont go right 
8c05			 
8c05 3c					inc  a 		; TODO check overflow 
8c06 32 a1 ee				ld (input_cursor), a 
8c09			 
8c09 3a ae ee				ld a, (input_at_cursor) 
8c0c 3c					inc a 
8c0d 32 ae ee				ld (input_at_cursor), a 
8c10			 
8c10 2a b5 ee				ld hl, (input_ptr) 
8c13 23					inc hl 
8c14 22 b5 ee				ld (input_ptr), hl 
8c17			 
8c17 3e 01				ld a, 1		; show cursor moving 
8c19 32 ab ee				ld (input_cur_onoff),a 
8c1c 3e 0f				ld a, CUR_BLINK_RATE 
8c1e 32 ac ee				ld (input_cur_flash), a 
8c21			 
8c21 c3 17 8b				jp .is1 
8c24			 
8c24 fe 05		.isk2:		cp KEY_UP 
8c26			 
8c26 20 26				jr nz, .isk3 
8c28			 
8c28					; swap last command with the current on 
8c28			 
8c28					; move cursor to start of string 
8c28 2a b3 ee				ld hl, (input_start) 
8c2b 22 b5 ee				ld (input_ptr), hl 
8c2e			 
8c2e 3a b0 ee				ld a, (input_at_pos) 
8c31 32 ae ee				ld (input_at_cursor), a 
8c34			 
8c34 3e 00				ld a, 0 
8c36 32 a1 ee				ld (input_cursor), a 
8c39					 
8c39					; swap input and last command buffers 
8c39			 
8c39 21 04 e8				ld hl, os_cli_cmd 
8c3c 11 03 e9				ld de, os_last_cmd 
8c3f 06 ff				ld b, 255 
8c41 7e			.swap1:		ld a, (hl) 
8c42 4f					ld c,a 
8c43 1a					ld a, (de) 
8c44 77					ld (hl), a 
8c45 79					ld a,c 
8c46 12					ld (de),a 
8c47 23					inc hl 
8c48 13					inc de 
8c49 10 f6				djnz .swap1 
8c4b			 
8c4b			 
8c4b			 
8c4b			 
8c4b			 
8c4b c3 17 8b				jp .is1 
8c4e			 
8c4e fe 08		.isk3:		cp KEY_BS 
8c50 20 3c				jr nz, .isk4 
8c52			 
8c52 3a a1 ee				ld a, (input_cursor) 
8c55			 
8c55 fe 00				cp 0 
8c57 ca 17 8b				jp z, .is1 		; at start of line to ignore  
8c5a			 
8c5a 3d					dec  a 		; TODO check underflow 
8c5b 32 a1 ee				ld (input_cursor), a 
8c5e			 
8c5e					; hl is source 
8c5e					; de needs to be source - 1 
8c5e			 
8c5e			;		ld a, 0 
8c5e			;		dec hl 
8c5e			;		ld (hl), a 
8c5e			 
8c5e 2a b5 ee				ld hl, (input_ptr) 
8c61 2b					dec hl 
8c62 22 b5 ee				ld (input_ptr), hl 
8c65			 
8c65					; shift all data 
8c65			 
8c65 e5					push hl 
8c66 23					inc hl 
8c67 d1					pop de 
8c68 3a a6 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c6b 4f					ld c,a 
8c6c 06 00				ld b,0 
8c6e ed b0				ldir  
8c70			 
8c70			 
8c70			 
8c70			 
8c70 3a ae ee				ld a, (input_at_cursor) 
8c73 3d					dec a 
8c74 32 ae ee				ld (input_at_cursor), a 
8c77			 
8c77			 
8c77 3e 01				ld a, 1		; show cursor moving 
8c79 32 ab ee				ld (input_cur_onoff),a 
8c7c 3e 0f				ld a, CUR_BLINK_RATE 
8c7e 32 ac ee				ld (input_cur_flash), a 
8c81			 
8c81					; remove char 
8c81 3a ae ee				ld a, (input_at_cursor) 
8c84 3c					inc a 
8c85 11 0f 8d				ld de,.iblank 
8c88 cd 9f 88				call str_at_display 
8c8b			 
8c8b c3 17 8b				jp .is1 
8c8e			 
8c8e fe 0d		.isk4:		cp KEY_CR 
8c90 28 6c				jr z, .endinput 
8c92			 
8c92					; else add the key press to the end 
8c92			 
8c92 4f					ld c, a			; save key pressed 
8c93			 
8c93 7e					ld a,(hl)		; get what is currently under char 
8c94			 
8c94 fe 00				cp 0			; we are at the end of the string 
8c96 20 2f				jr nz, .onchar 
8c98					 
8c98					; add a char to the end of the string 
8c98				 
8c98 71					ld (hl),c 
8c99 23					inc hl 
8c9a			;		ld a,' ' 
8c9a			;		ld (hl),a 
8c9a			;		inc hl 
8c9a 3e 00				ld a,0 
8c9c 77					ld (hl),a 
8c9d 2b					dec hl 
8c9e			 
8c9e 3a a1 ee				ld a, (input_cursor) 
8ca1 3c					inc a				; TODO check max string length and scroll  
8ca2 32 a1 ee				ld (input_cursor), a		; inc cursor pos 
8ca5							 
8ca5 3a ae ee				ld a, (input_at_cursor) 
8ca8 3c					inc a 
8ca9 32 ae ee				ld (input_at_cursor), a 
8cac			 
8cac 2a b5 ee				ld hl, (input_ptr) 
8caf 23					inc hl 
8cb0 22 b5 ee				ld (input_ptr), hl 
8cb3			 
8cb3 2a b5 ee				ld hl, (input_ptr) 
8cb6 23					inc hl 
8cb7 22 b5 ee				ld (input_ptr), hl 
8cba			;	if DEBUG_INPUT 
8cba			;		push af 
8cba			;		ld a, '+' 
8cba			;		ld (debug_mark),a 
8cba			;		pop af 
8cba			;		CALLMONITOR 
8cba			;	endif 
8cba 3e 01				ld a, 1		; show cursor moving 
8cbc 32 ab ee				ld (input_cur_onoff),a 
8cbf 3e 0f				ld a, CUR_BLINK_RATE 
8cc1 32 ac ee				ld (input_cur_flash), a 
8cc4 c3 17 8b				jp .is1 
8cc7					 
8cc7			 
8cc7			 
8cc7					; if on a char then insert 
8cc7			.onchar: 
8cc7			 
8cc7					; TODO over flow check: make sure insert does not blow out buffer 
8cc7			 
8cc7					; need to do some maths to use lddr 
8cc7			 
8cc7 e5					push hl   ; save char pos 
8cc8 c5					push bc 
8cc9			 
8cc9 2a b3 ee				ld hl, (input_start) 
8ccc 3a a6 ee				ld a, (input_len) 
8ccf cd b9 8a				call addatohl  		; end of string 
8cd2 23					inc hl 
8cd3 23					inc hl		; past zero term 
8cd4 e5					push hl 
8cd5 23					inc hl 
8cd6 e5					push hl  
8cd7			 
8cd7								; start and end of lddr set, now how much to move? 
8cd7			 
8cd7							 
8cd7 3a a1 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8cda 47					ld b,a 
8cdb 3a a6 ee				ld a,(input_len) 
8cde 5f					ld e,a 
8cdf 90					sub b 
8ce0 3c					inc a		;?? 
8ce1 3c					inc a		;?? 
8ce2 3c					inc a		;?? 
8ce3			 
8ce3 06 00				ld b,0 
8ce5 4f					ld c,a 
8ce6			 
8ce6				if DEBUG_INPUT 
8ce6					push af 
8ce6					ld a, 'i' 
8ce6					ld (debug_mark),a 
8ce6					pop af 
8ce6			;		CALLMONITOR 
8ce6				endif 
8ce6 d1					pop de 
8ce7 e1					pop hl 
8ce8				if DEBUG_INPUT 
8ce8					push af 
8ce8					ld a, 'I' 
8ce8					ld (debug_mark),a 
8ce8					pop af 
8ce8			;		CALLMONITOR 
8ce8				endif 
8ce8 ed b8				lddr 
8cea				 
8cea			 
8cea			 
8cea					; TODO have a key for insert/overwrite mode???? 
8cea c1					pop bc 
8ceb e1					pop hl 
8cec 71					ld (hl), c		; otherwise overwrite current char 
8ced					 
8ced			 
8ced			 
8ced			 
8ced 3a a1 ee				ld a, (input_cursor) 
8cf0 3c					inc  a 		; TODO check overflow 
8cf1 32 a1 ee				ld (input_cursor), a 
8cf4			 
8cf4 3a ae ee				ld a, (input_at_cursor) 
8cf7 3c					inc a 
8cf8 32 ae ee				ld (input_at_cursor), a 
8cfb			 
8cfb c3 17 8b				jp .is1 
8cfe			 
8cfe			.endinput:	; TODO look for end of string 
8cfe			 
8cfe					; add trailing space for end of token 
8cfe			 
8cfe 2a b3 ee				ld hl, (input_start) 
8d01 3a a6 ee				ld a,(input_len) 
8d04 cd b9 8a				call addatohl 
8d07 3e 20				ld a, ' ' 
8d09 77					ld (hl),a 
8d0a					; TODO eof of parse marker 
8d0a			 
8d0a 23					inc hl 
8d0b 3e 00				ld a, 0 
8d0d 77					ld (hl),a 
8d0e			 
8d0e			 
8d0e c9					ret 
8d0f			 
8d0f .. 00		.iblank: db " ",0 
8d11			 
8d11			 
8d11 32 b0 ee		input_str_prev:	ld (input_at_pos), a 
8d14 22 b3 ee				ld (input_start), hl 
8d17 3e 01				ld a,1			; add cursor 
8d19 77					ld (hl),a 
8d1a 23					inc hl 
8d1b 3e 00				ld a,0 
8d1d 77					ld (hl),a 
8d1e 22 b5 ee				ld (input_ptr), hl 
8d21 7a					ld a,d 
8d22 32 b2 ee				ld (input_size), a 
8d25 3e 00				ld a,0 
8d27 32 a1 ee				ld (input_cursor),a 
8d2a			.instr1:	 
8d2a			 
8d2a					; TODO do block cursor 
8d2a					; TODO switch cursor depending on the modifer key 
8d2a			 
8d2a					; update cursor shape change on key hold 
8d2a			 
8d2a 2a b5 ee				ld hl, (input_ptr) 
8d2d 2b					dec hl 
8d2e 3a 50 ed				ld a,(cursor_shape) 
8d31 77					ld (hl), a 
8d32			 
8d32					; display entered text 
8d32 3a b0 ee				ld a,(input_at_pos) 
8d35 cd 24 d7		            	CALL fLCD_Pos       ;Position cursor to location in A 
8d38 ed 5b b3 ee	            	LD   de, (input_start) 
8d3c cd 1e d7		            	CALL fLCD_Str       ;Display string pointed to by DE 
8d3f			 
8d3f cd c6 d7				call cin 
8d42 fe 00				cp 0 
8d44 28 e4				jr z, .instr1 
8d46			 
8d46					; proecess keyboard controls first 
8d46			 
8d46 2a b5 ee				ld hl,(input_ptr) 
8d49			 
8d49 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8d4b 28 5a				jr z, .instrcr 
8d4d			 
8d4d fe 08				cp KEY_BS 	; back space 
8d4f 20 0f				jr nz, .instr2 
8d51					; process back space 
8d51			 
8d51					; TODO stop back space if at start of string 
8d51 2b					dec hl 
8d52 2b					dec hl ; to over write cursor 
8d53 3a 50 ed				ld a,(cursor_shape) 
8d56					;ld a,0 
8d56 77					ld (hl),a 
8d57 23					inc hl 
8d58 3e 20				ld a," " 
8d5a 77					ld (hl),a 
8d5b 22 b5 ee				ld (input_ptr),hl 
8d5e					 
8d5e			 
8d5e 18 ca				jr .instr1 
8d60			 
8d60 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d62 20 06				jr nz, .instr3 
8d64 2b					dec hl 
8d65 22 b5 ee				ld (input_ptr),hl 
8d68 18 c0				jr .instr1 
8d6a				 
8d6a fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d6c 20 06				jr nz, .instr4 
8d6e 23					inc hl 
8d6f 22 b5 ee				ld (input_ptr),hl 
8d72 18 b6				jr .instr1 
8d74			 
8d74 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d76 20 06				jr nz, .instr5 
8d78 2b					dec hl 
8d79 22 b5 ee				ld (input_ptr),hl 
8d7c 18 ac				jr .instr1 
8d7e			 
8d7e fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d80 20 06				jr nz, .instr6 
8d82 2b					dec hl 
8d83 22 b5 ee				ld (input_ptr),hl 
8d86 18 a2				jr .instr1 
8d88 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d8a 20 0b				jr nz, .instrnew 
8d8c			 
8d8c 21 dd e4			ld hl, scratch 
8d8f 11 03 e9			ld de, os_last_cmd 
8d92 cd b0 8d			call strcpy 
8d95 18 93				jr .instr1 
8d97			 
8d97			 
8d97			.instrnew:	; no special key pressed to see if we have room to store it 
8d97			 
8d97					; TODO do string size test 
8d97			 
8d97 2b					dec hl ; to over write cursor 
8d98 77					ld (hl),a 
8d99 23					inc hl 
8d9a 3a 50 ed				ld a,(cursor_shape) 
8d9d 77					ld (hl),a 
8d9e 23					inc hl 
8d9f 3e 00				ld a,0 
8da1 77					ld (hl),a 
8da2			 
8da2 22 b5 ee				ld (input_ptr),hl 
8da5					 
8da5 18 83				jr .instr1 
8da7 2b			.instrcr:	dec hl		; remove cursor 
8da8 3e 20				ld a,' '	; TODO add a trailing space for safety 
8daa 77					ld (hl),a 
8dab 23					inc hl 
8dac 3e 00				ld a,0 
8dae 77					ld (hl),a 
8daf			 
8daf			 
8daf					; if at end of line scroll up    
8daf					; TODO detecting only end of line 4 for scroll up  
8daf			 
8daf					;ld   
8daf			 
8daf c9					ret 
8db0			 
8db0			 
8db0			; strcpy hl = dest, de source 
8db0			 
8db0 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8db1 b7			            OR   A              ;Null terminator? 
8db2 c8			            RET  Z              ;Yes, so finished 
8db3 1a					ld a,(de) 
8db4 77					ld (hl),a 
8db5 13			            INC  DE             ;Point to next character 
8db6 23					inc hl 
8db7 18 f7		            JR   strcpy       ;Repeat 
8db9 c9					ret 
8dba			 
8dba			 
8dba			; TODO string_at  
8dba			; pass string which starts with lcd offset address and then null term string 
8dba			 
8dba			; TODO string to dec 
8dba			; TODO string to hex 
8dba			; TODO byte to string hex 
8dba			; TODO byte to string dec 
8dba			 
8dba			 
8dba			 
8dba			; from z80uartmonitor 
8dba			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dba			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8dba			; pass hl for where to put the text 
8dba			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dba c5			hexout:	PUSH BC 
8dbb f5					PUSH AF 
8dbc 47					LD B, A 
8dbd					; Upper nybble 
8dbd cb 3f				SRL A 
8dbf cb 3f				SRL A 
8dc1 cb 3f				SRL A 
8dc3 cb 3f				SRL A 
8dc5 cd d5 8d				CALL tohex 
8dc8 77					ld (hl),a 
8dc9 23					inc hl	 
8dca					 
8dca					; Lower nybble 
8dca 78					LD A, B 
8dcb e6 0f				AND 0FH 
8dcd cd d5 8d				CALL tohex 
8dd0 77					ld (hl),a 
8dd1 23					inc hl	 
8dd2					 
8dd2 f1					POP AF 
8dd3 c1					POP BC 
8dd4 c9					RET 
8dd5					 
8dd5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dd5			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8dd5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dd5			tohex: 
8dd5 e5					PUSH HL 
8dd6 d5					PUSH DE 
8dd7 16 00				LD D, 0 
8dd9 5f					LD E, A 
8dda 21 e2 8d				LD HL, .DATA 
8ddd 19					ADD HL, DE 
8dde 7e					LD A, (HL) 
8ddf d1					POP DE 
8de0 e1					POP HL 
8de1 c9					RET 
8de2			 
8de2			.DATA: 
8de2 30					DEFB	30h	; 0 
8de3 31					DEFB	31h	; 1 
8de4 32					DEFB	32h	; 2 
8de5 33					DEFB	33h	; 3 
8de6 34					DEFB	34h	; 4 
8de7 35					DEFB	35h	; 5 
8de8 36					DEFB	36h	; 6 
8de9 37					DEFB	37h	; 7 
8dea 38					DEFB	38h	; 8 
8deb 39					DEFB	39h	; 9 
8dec 41					DEFB	41h	; A 
8ded 42					DEFB	42h	; B 
8dee 43					DEFB	43h	; C 
8def 44					DEFB	44h	; D 
8df0 45					DEFB	45h	; E 
8df1 46					DEFB	46h	; F 
8df2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8df2			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8df2			;;    subtract $30, if result > 9 then subtract $7 more 
8df2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8df2			atohex: 
8df2 d6 30				SUB $30 
8df4 fe 0a				CP 10 
8df6 f8					RET M		; If result negative it was 0-9 so we're done 
8df7 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8df9 c9					RET		 
8dfa			 
8dfa			 
8dfa			 
8dfa			 
8dfa			; Get 2 ASCII characters as hex byte from pointer in hl 
8dfa			 
8dfa			BYTERD: 
8dfa 16 00			LD	D,00h		;Set up 
8dfc cd 04 8e			CALL	HEXCON		;Get byte and convert to hex 
8dff 87				ADD	A,A		;First nibble so 
8e00 87				ADD	A,A		;multiply by 16 
8e01 87				ADD	A,A		; 
8e02 87				ADD	A,A		; 
8e03 57				LD	D,A		;Save hi nibble in D 
8e04			HEXCON: 
8e04 7e				ld a, (hl)		;Get next chr 
8e05 23				inc hl 
8e06 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8e08 fe 0a			CP	00Ah		;Is it 0-9 ? 
8e0a 38 02			JR	C,NALPHA	;If so miss next bit 
8e0c d6 07			SUB	007h		;Else convert alpha 
8e0e			NALPHA: 
8e0e b2				OR	D		;Add hi nibble back 
8e0f c9				RET			; 
8e10			 
8e10			 
8e10			; 
8e10			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8e10			; Since the routines get_byte and therefore get_nibble are called, only valid 
8e10			; characters (0-9a-f) are accepted. 
8e10			; 
8e10			;get_word        push    af 
8e10			;                call    get_byte        ; Get the upper byte 
8e10			;                ld      h, a 
8e10			;                call    get_byte        ; Get the lower byte 
8e10			;                ld      l, a 
8e10			;                pop     af 
8e10			;                ret 
8e10			; 
8e10			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8e10			; the routine get_nibble is used only valid characters are accepted - the  
8e10			; input routine only accepts characters 0-9a-f. 
8e10			; 
8e10 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8e11 7e					ld a,(hl) 
8e12 23					inc hl 
8e13 cd 38 8e		                call    nibble2val      ; Get upper nibble 
8e16 cb 07		                rlc     a 
8e18 cb 07		                rlc     a 
8e1a cb 07		                rlc     a 
8e1c cb 07		                rlc     a 
8e1e 47			                ld      b, a            ; Save upper four bits 
8e1f 7e					ld a,(hl) 
8e20 cd 38 8e		                call    nibble2val      ; Get lower nibble 
8e23 b0			                or      b               ; Combine both nibbles 
8e24 c1			                pop     bc              ; Restore B (and C) 
8e25 c9			                ret 
8e26			; 
8e26			; Get a hexadecimal digit from the serial line. This routine blocks until 
8e26			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8e26			; to the serial line interface. The lower 4 bits of A contain the value of  
8e26			; that particular digit. 
8e26			; 
8e26			;get_nibble      ld a,(hl)           ; Read a character 
8e26			;                call    to_upper        ; Convert to upper case 
8e26			;                call    is_hex          ; Was it a hex digit? 
8e26			;                jr      nc, get_nibble  ; No, get another character 
8e26			 ;               call    nibble2val      ; Convert nibble to value 
8e26			 ;               call    print_nibble 
8e26			 ;               ret 
8e26			; 
8e26			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8e26			; A valid hexadecimal digit is denoted by a set C flag. 
8e26			; 
8e26			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8e26			;                ret     nc              ; Yes 
8e26			;                cp      '0'             ; Less than '0'? 
8e26			;                jr      nc, is_hex_1    ; No, continue 
8e26			;                ccf                     ; Complement carry (i.e. clear it) 
8e26			;                ret 
8e26			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8e26			;                ret     c               ; Yes 
8e26			;                cp      'A'             ; Less than 'A'? 
8e26			;                jr      nc, is_hex_2    ; No, continue 
8e26			;                ccf                     ; Yes - clear carry and return 
8e26			;                ret 
8e26			;is_hex_2        scf                     ; Set carry 
8e26			;                ret 
8e26			; 
8e26			; Convert a single character contained in A to upper case: 
8e26			; 
8e26 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8e28 d8			                ret     c 
8e29 fe 7b		                cp      'z' + 1         ; > 'z'? 
8e2b d0			                ret     nc              ; Nothing to do, either 
8e2c e6 5f		                and     $5f             ; Convert to upper case 
8e2e c9			                ret 
8e2f			 
8e2f			 
8e2f			to_lower: 
8e2f			 
8e2f			   ; if char is in [A-Z] make it lower case 
8e2f			 
8e2f			   ; enter : a = char 
8e2f			   ; exit  : a = lower case char 
8e2f			   ; uses  : af 
8e2f			 
8e2f fe 41		   cp 'A' 
8e31 d8			   ret c 
8e32			    
8e32 fe 5b		   cp 'Z'+1 
8e34 d0			   ret nc 
8e35			    
8e35 f6 20		   or $20 
8e37 c9			   ret 
8e38			 
8e38			; 
8e38			; Expects a hexadecimal digit (upper case!) in A and returns the 
8e38			; corresponding value in A. 
8e38			; 
8e38 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8e3a 38 02		                jr      c, nibble2val_1 ; Yes 
8e3c d6 07		                sub     7               ; Adjust for A-F 
8e3e d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8e40 e6 0f		                and     $f              ; Only return lower 4 bits 
8e42 c9			                ret 
8e43			; 
8e43			; Print_nibble prints a single hex nibble which is contained in the lower  
8e43			; four bits of A: 
8e43			; 
8e43			;print_nibble    push    af              ; We won't destroy the contents of A 
8e43			;                and     $f              ; Just in case... 
8e43			;                add     a, '0'             ; If we have a digit we are done here. 
8e43			;                cp      '9' + 1         ; Is the result > 9? 
8e43			;                jr      c, print_nibble_1 
8e43			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8e43			;print_nibble_1  call    putc            ; Print the nibble and 
8e43			;                pop     af              ; restore the original value of A 
8e43			;                ret 
8e43			;; 
8e43			;; Send a CR/LF pair: 
8e43			; 
8e43			;crlf            push    af 
8e43			;                ld      a, cr 
8e43			;                call    putc 
8e43			;                ld      a, lf 
8e43			;                call    putc 
8e43			;                pop     af 
8e43			;                ret 
8e43			; 
8e43			; Print_word prints the four hex digits of a word to the serial line. The  
8e43			; word is expected to be in HL. 
8e43			; 
8e43			;print_word      push    hl 
8e43			;                push    af 
8e43			;                ld      a, h 
8e43			;                call    print_byte 
8e43			;                ld      a, l 
8e43			;                call    print_byte 
8e43			;                pop     af 
8e43			;                pop     hl 
8e43			;                ret 
8e43			; 
8e43			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8e43			; The byte to be printed is expected to be in A. 
8e43			; 
8e43			;print_byte      push    af              ; Save the contents of the registers 
8e43			;                push    bc 
8e43			;                ld      b, a 
8e43			;                rrca 
8e43			;                rrca 
8e43			;                rrca 
8e43			;                rrca 
8e43			;                call    print_nibble    ; Print high nibble 
8e43			;                ld      a, b 
8e43			;                call    print_nibble    ; Print low nibble 
8e43			;                pop     bc              ; Restore original register contents 
8e43			;                pop     af 
8e43			;                ret 
8e43			 
8e43			 
8e43			 
8e43			 
8e43			 
8e43			fourehexhl:  
8e43 7e				ld a,(hl) 
8e44 cd f2 8d			call atohex 
8e47 cb 3f				SRL A 
8e49 cb 3f				SRL A 
8e4b cb 3f				SRL A 
8e4d cb 3f				SRL A 
8e4f 47				ld b, a 
8e50 23				inc hl 
8e51 7e				ld a,(hl) 
8e52 23				inc hl 
8e53 cd f2 8d			call atohex 
8e56 80				add b 
8e57 57				ld d,a 
8e58 7e				ld a,(hl) 
8e59 cd f2 8d			call atohex 
8e5c cb 3f				SRL A 
8e5e cb 3f				SRL A 
8e60 cb 3f				SRL A 
8e62 cb 3f				SRL A 
8e64 47				ld b, a 
8e65 23				inc hl 
8e66 7e				ld a,(hl) 
8e67 23				inc hl 
8e68 cd f2 8d			call atohex 
8e6b 80				add b 
8e6c 5f				ld e, a 
8e6d d5				push de 
8e6e e1				pop hl 
8e6f c9				ret 
8e70			 
8e70			; pass hl. returns z set if the byte at hl is a digit 
8e70			;isdigithl:  
8e70			;	push bc 
8e70			;	ld a,(hl) 
8e70			;	cp ':' 
8e70			;	jr nc, .isdf 		; > 
8e70			;	cp '0' 
8e70			;	jr c, .isdf		; < 
8e70			; 
8e70			;	; TODO find a better way to set z 
8e70			; 
8e70			;	ld b,a 
8e70			;	cp b 
8e70			;	pop bc 
8e70			;	ret 
8e70			; 
8e70			;.isdf:	; not digit so clear z 
8e70			; 
8e70			;	; TODO find a better way to unset z 
8e70			; 
8e70			;	ld b,a 
8e70			;	inc b 
8e70			;	cp b 
8e70			; 
8e70			;	pop bc 
8e70			;	ret 
8e70				 
8e70				 
8e70			 
8e70			 
8e70			; pass hl as the four byte address to load 
8e70			 
8e70			get_word_hl:  
8e70 e5				push hl 
8e71 cd 10 8e			call get_byte 
8e74				 
8e74 47				ld b, a 
8e75			 
8e75 e1				pop hl 
8e76 23				inc hl 
8e77 23				inc hl 
8e78			 
8e78			; TODO not able to handle a-f  
8e78 7e				ld a,(hl) 
8e79			;	;cp ':' 
8e79			;	cp 'g' 
8e79			;	jr nc, .single_byte_hl 		; > 
8e79			;	cp 'G' 
8e79			;	jr nc, .single_byte_hl 		; > 
8e79			;	cp '0' 
8e79			;	jr c, .single_byte_hl		; < 
8e79			 
8e79				;call isdigithl 
8e79 fe 00			cp 0 
8e7b 28 06			jr z, .single_byte_hl 
8e7d			 
8e7d			.getwhln:   ; hex word so get next byte 
8e7d			 
8e7d cd 10 8e			call get_byte 
8e80 6f				ld l, a 
8e81 60				ld h,b 
8e82 c9				ret 
8e83 68			.single_byte_hl:   ld l,b 
8e84 26 00				ld h,0 
8e86 c9					ret 
8e87			 
8e87			 
8e87			 
8e87			 
8e87 21 06 96			ld hl,asc+1 
8e8a			;	ld a, (hl) 
8e8a			;	call nibble2val 
8e8a cd 10 8e			call get_byte 
8e8d			 
8e8d			;	call fourehexhl 
8e8d 32 11 e5			ld (scratch+52),a 
8e90				 
8e90 21 0f e5			ld hl,scratch+50 
8e93 22 00 e8			ld (os_cur_ptr),hl 
8e96			 
8e96 c9				ret 
8e97			 
8e97			 
8e97			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e97			 
8e97			; Decimal Unsigned Version 
8e97			 
8e97			;Number in a to decimal ASCII 
8e97			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e97			;Example: display a=56 as "056" 
8e97			;input: a = number 
8e97			;Output: a=0,value of a in the screen 
8e97			;destroys af,bc (don't know about hl and de) 
8e97			DispAToASCII: 
8e97 0e 9c			ld	c,-100 
8e99 cd a3 8e			call	.Na1 
8e9c 0e f6			ld	c,-10 
8e9e cd a3 8e			call	.Na1 
8ea1 0e ff			ld	c,-1 
8ea3 06 2f		.Na1:	ld	b,'0'-1 
8ea5 04			.Na2:	inc	b 
8ea6 81				add	a,c 
8ea7 38 fc			jr	c,.Na2 
8ea9 91				sub	c		;works as add 100/10/1 
8eaa f5				push af		;safer than ld c,a 
8eab 78				ld	a,b		;char is in b 
8eac			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8eac f1				pop af		;safer than ld a,c 
8ead c9				ret 
8eae			 
8eae			; Decimal Signed Version 
8eae			 
8eae			; DispA 
8eae			; -------------------------------------------------------------- 
8eae			; Converts a signed integer value to a zero-terminated ASCII 
8eae			; string representative of that value (using radix 10). 
8eae			; -------------------------------------------------------------- 
8eae			; INPUTS: 
8eae			;     HL     Value to convert (two's complement integer). 
8eae			;     DE     Base address of string destination. (pointer). 
8eae			; -------------------------------------------------------------- 
8eae			; OUTPUTS: 
8eae			;     None 
8eae			; -------------------------------------------------------------- 
8eae			; REGISTERS/MEMORY DESTROYED 
8eae			; AF HL 
8eae			; -------------------------------------------------------------- 
8eae			 
8eae			;DispHLToASCII: 
8eae			;   push    de 
8eae			;   push    bc 
8eae			; 
8eae			;; Detect sign of HL. 
8eae			;    bit    7, h 
8eae			;    jr     z, ._DoConvert 
8eae			; 
8eae			;; HL is negative. Output '-' to string and negate HL. 
8eae			;    ld     a, '-' 
8eae			;    ld     (de), a 
8eae			;    inc    de 
8eae			; 
8eae			;; Negate HL (using two's complement) 
8eae			;    xor    a 
8eae			;    sub    l 
8eae			;    ld     l, a 
8eae			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8eae			;    sbc    a, h 
8eae			;    ld     h, a 
8eae			; 
8eae			;; Convert HL to digit characters 
8eae			;._DoConvert: 
8eae			;    ld     b, 0     ; B will count character length of number 
8eae			;-   ld     a, 10 
8eae			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8eae			;    push   af 
8eae			;    inc    b 
8eae			;    ld     a, h 
8eae			;    or     l 
8eae			;    jr     nz, - 
8eae			; 
8eae			;; Retrieve digits from stack 
8eae			;-   pop    af 
8eae			;    or     $30 
8eae			;    ld     (de), a 
8eae			;    inc    de 
8eae			;    djnz   - 
8eae			; 
8eae			;; Terminate string with NULL 
8eae			;    xor    a 
8eae			;    ld     (de), a 
8eae			; 
8eae			;    pop    bc 
8eae			;    pop    de 
8eae			;    ret 
8eae			 
8eae			;Comments 
8eae			; 
8eae			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8eae			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8eae			;    Note that the output string will not be fixed-width. 
8eae			; 
8eae			;Example Usage 
8eae			; 
8eae			;    ld    hl, -1004 
8eae			;    ld    de, OP1 
8eae			;    call  DispA 
8eae			;    ld    hl, OP1 
8eae			;    syscall  PutS 
8eae			 
8eae			 
8eae			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8eae			 
8eae			 
8eae			;Converts an ASCII string to an unsigned 16-bit integer 
8eae			;Quits when it reaches a non-decimal digit 
8eae			 
8eae			string_to_uint16: 
8eae			atoui_16: 
8eae			;Input: 
8eae			;     DE points to the string 
8eae			;Outputs: 
8eae			;     HL is the result 
8eae			;     A is the 8-bit value of the number 
8eae			;     DE points to the byte after the number 
8eae			;Destroys: 
8eae			;     BC 
8eae			;       if the string is non-empty, BC is HL/10 
8eae			;Size:  24 bytes 
8eae			;Speed: 42+d(104+{0,9}) 
8eae			;       d is the number of digits in the number 
8eae			;       max is 640 cycles for a 5 digit number 
8eae			;Assuming no leading zeros: 
8eae			;1 digit:  146cc 
8eae			;2 digit:  250cc 
8eae			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8eae			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8eae			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8eae			;avg: 544.81158447265625cc (544+13297/16384) 
8eae			;=============================================================== 
8eae 21 00 00		  ld hl,0 
8eb1			.u16a: 
8eb1 1a			  ld a,(de) 
8eb2 d6 30		  sub 30h 
8eb4 fe 0a		  cp 10 
8eb6 d0			  ret nc 
8eb7 13			  inc de 
8eb8 44			  ld b,h 
8eb9 4d			  ld c,l 
8eba 29			  add hl,hl 
8ebb 29			  add hl,hl 
8ebc 09			  add hl,bc 
8ebd 29			  add hl,hl 
8ebe 85			  add a,l 
8ebf 6f			  ld l,a 
8ec0 30 ef		  jr nc,.u16a 
8ec2 24			  inc h 
8ec3 c3 b1 8e		  jp .u16a 
8ec6			 
8ec6			 
8ec6			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8ec6			 
8ec6			;written by Zeda 
8ec6			;Converts a 16-bit unsigned integer to an ASCII string. 
8ec6			 
8ec6			uitoa_16: 
8ec6			;Input: 
8ec6			;   DE is the number to convert 
8ec6			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8ec6			;Output: 
8ec6			;   HL points to the null-terminated ASCII string 
8ec6			;      NOTE: This isn't necessarily the same as the input HL. 
8ec6 d5			  push de 
8ec7 c5			  push bc 
8ec8 f5			  push af 
8ec9 eb			  ex de,hl 
8eca			 
8eca 01 f0 d8		  ld bc,-10000 
8ecd 3e 2f		  ld a,'0'-1 
8ecf 3c			  inc a 
8ed0 09			  add hl,bc  
8ed1 38 fc		   jr c,$-2 
8ed3 12			  ld (de),a 
8ed4 13			  inc de 
8ed5			 
8ed5 01 e8 03		  ld bc,1000 
8ed8 3e 3a		  ld a,'9'+1 
8eda 3d			  dec a  
8edb 09			  add hl,bc  
8edc 30 fc		   jr nc,$-2 
8ede 12			  ld (de),a 
8edf 13			  inc de 
8ee0			 
8ee0 01 9c ff		  ld bc,-100 
8ee3 3e 2f		  ld a,'0'-1 
8ee5 3c			  inc a  
8ee6 09			  add hl,bc  
8ee7 38 fc		   jr c,$-2 
8ee9 12			  ld (de),a 
8eea 13			  inc de 
8eeb			 
8eeb 7d			  ld a,l 
8eec 26 3a		  ld h,'9'+1 
8eee 25			  dec h  
8eef c6 0a		  add a,10  
8ef1 30 fb		   jr nc,$-3 
8ef3 c6 30		  add a,'0' 
8ef5 eb			  ex de,hl 
8ef6 72			  ld (hl),d 
8ef7 23			  inc hl 
8ef8 77			  ld (hl),a 
8ef9 23			  inc hl 
8efa 36 00		  ld (hl),0 
8efc			 
8efc			;Now strip the leading zeros 
8efc 0e fa		  ld c,-6 
8efe 09			  add hl,bc 
8eff 3e 30		  ld a,'0' 
8f01 23			  inc hl  
8f02 be			  cp (hl)  
8f03 28 fc		  jr z,$-2 
8f05			 
8f05			;Make sure that the string is non-empty! 
8f05 7e			  ld a,(hl) 
8f06 b7			  or a 
8f07 20 01		  jr nz,.atoub 
8f09 2b			  dec hl 
8f0a			.atoub: 
8f0a			 
8f0a f1			  pop af 
8f0b c1			  pop bc 
8f0c d1			  pop de 
8f0d c9			  ret 
8f0e			 
8f0e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8f0e			 
8f0e			toUpper: 
8f0e			;A is the char. 
8f0e			;If A is a lowercase letter, this sets it to the matching uppercase 
8f0e			;18cc or 30cc or 41cc 
8f0e			;avg: 26.75cc 
8f0e fe 61		  cp 'a' 
8f10 d8			  ret c 
8f11 fe 7b		  cp 'z'+1 
8f13 d0			  ret nc 
8f14 d6 20		  sub 'a'-'A' 
8f16 c9			  ret 
8f17			 
8f17			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8f17			 
8f17			; String Length 
8f17			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8f17			 
8f17			; Get the length of the null-terminated string starting at $8000 hl 
8f17			;    LD     HL, $8000 
8f17			 
8f17			strlenz: 
8f17			 
8f17 af			    XOR    A               ; Zero is the value we are looking for. 
8f18 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8f19 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8f1a			                           ; 65, 536 bytes (the entire addressable memory space). 
8f1a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f1c			 
8f1c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f1c 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8f1d 6f			    LD     L, A             ; number of bytes 
8f1e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f20 2b			    DEC    HL              ; Compensate for null. 
8f21 c9				ret 
8f22			 
8f22			; Get the length of the A terminated string starting at $8000 hl 
8f22			;    LD     HL, $8000 
8f22			 
8f22			strlent: 
8f22			 
8f22			                  ; A is the value we are looking for. 
8f22 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8f24 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8f26			                           ; 65, 536 bytes (the entire addressable memory space). 
8f26 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f28			 
8f28			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f28 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8f2a 2e 00		    LD     L, 0             ; number of bytes 
8f2c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f2e 2b			    DEC    HL              ; Compensate for null. 
8f2f c9				ret 
8f30			 
8f30			 
8f30			;Comparing Strings 
8f30			 
8f30			;IN    HL     Address of string1. 
8f30			;      DE     Address of string2. 
8f30			 
8f30			; doc given but wrong??? 
8f30			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8f30			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8f30			; tested 
8f30			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8f30			 
8f30			strcmp_old: 
8f30 e5			    PUSH   HL 
8f31 d5			    PUSH   DE 
8f32			 
8f32 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8f33 be			    CP     (HL)            ; (want to minimize work). 
8f34 38 01		    JR     C, Str1IsBigger 
8f36 7e			    LD     A, (HL) 
8f37			 
8f37			Str1IsBigger: 
8f37 4f			    LD     C, A             ; Put length in BC 
8f38 06 00		    LD     B, 0 
8f3a 13			    INC    DE              ; Increment pointers to meat of string. 
8f3b 23			    INC    HL 
8f3c			 
8f3c			CmpLoop: 
8f3c 1a			    LD     A, (DE)          ; Compare bytes. 
8f3d ed a1		    CPI 
8f3f 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8f41 13			    INC    DE              ; Update pointer. 
8f42 ea 3c 8f		    JP     PE, CmpLoop 
8f45			 
8f45 d1			    POP    DE 
8f46 e1			    POP    HL 
8f47 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8f48 be			    CP     (HL) 
8f49 c9			    RET 
8f4a			 
8f4a			NoMatch: 
8f4a 2b			    DEC    HL 
8f4b be			    CP     (HL)            ; Compare again to affect carry. 
8f4c d1			    POP    DE 
8f4d e1			    POP    HL 
8f4e c9			    RET 
8f4f			 
8f4f			;; test strmp 
8f4f			; 
8f4f			;ld de, .str1 
8f4f			;ld hl, .str2 
8f4f			;call strcmp 
8f4f			;jr z, .z1 
8f4f			;;this 
8f4f			;	if DEBUG_FORTH_WORDS 
8f4f			;		DMARK "NZ1" 
8f4f			;		CALLMONITOR 
8f4f			;	endif 
8f4f			;.z1: 
8f4f			; 
8f4f			;	if DEBUG_FORTH_WORDS 
8f4f			;		DMARK "ZZ1" 
8f4f			;		CALLMONITOR 
8f4f			;	endif 
8f4f			; 
8f4f			;ld de, .str1 
8f4f			;ld hl, .str1 
8f4f			;call strcmp 
8f4f			;jr z, .z2 
8f4f			;;this 
8f4f			;	if DEBUG_FORTH_WORDS 
8f4f			;		DMARK "NZ2" 
8f4f			;		CALLMONITOR 
8f4f			;	endif 
8f4f			;.z2: 
8f4f			; 
8f4f			;	if DEBUG_FORTH_WORDS 
8f4f			;		DMARK "ZZ2" 
8f4f			;		CALLMONITOR 
8f4f			;	endif 
8f4f			; 
8f4f			;ld de, .str1 
8f4f			;ld hl, .str2 
8f4f			;call strcmp 
8f4f			;jr c, .c1 
8f4f			; 
8f4f			;	if DEBUG_FORTH_WORDS 
8f4f			;		DMARK "Nc1" 
8f4f			;		CALLMONITOR 
8f4f			;	endif 
8f4f			;.c1: 
8f4f			;;this 
8f4f			;	if DEBUG_FORTH_WORDS 
8f4f			;		DMARK "cc1" 
8f4f			;		CALLMONITOR 
8f4f			;	endif 
8f4f			; 
8f4f			;ld de, .str1 
8f4f			;ld hl, .str1 
8f4f			;call strcmp 
8f4f			;jr c, .c2 
8f4f			;;this 
8f4f			;	if DEBUG_FORTH_WORDS 
8f4f			;		DMARK "Nc2" 
8f4f			;		CALLMONITOR 
8f4f			;	endif 
8f4f			;.c2: 
8f4f			; 
8f4f			;	if DEBUG_FORTH_WORDS 
8f4f			;		DMARK "cc2" 
8f4f			;		CALLMONITOR 
8f4f			;	endif 
8f4f			;	NEXTW 
8f4f			;.str1:   db "string1",0 
8f4f			;.str2:   db "string2",0 
8f4f			 
8f4f			; only care about direct match or not 
8f4f			; hl and de strings 
8f4f			; zero set if the same 
8f4f			 
8f4f			strcmp: 
8f4f 1a				ld a, (de) 
8f50 be				cp (hl) 
8f51 28 02			jr z, .ssame 
8f53 b7				or a 
8f54 c9				ret 
8f55			 
8f55			.ssame:  
8f55 fe 00			cp 0 
8f57 c8				ret z 
8f58			 
8f58 23				inc hl 
8f59 13				inc de 
8f5a 18 f3			jr strcmp 
8f5c				 
8f5c				 
8f5c			 
8f5c			 
8f5c			 
8f5c			 
8f5c			; eof 
8f5c			 
8f5c			 
8f5c			 
8f5c			 
8f5c			 
8f5c			 
# End of file firmware_strings.asm
8f5c			include "firmware_memory.asm"   ; malloc and free  
8f5c			 
8f5c			if DEBUG_FORTH_MALLOC_HIGH 
8f5c			.mallocsize: db "Wants malloc >256",0 
8f5c			.mallocasize: db "MALLOC gives >256",0 
8f5c			.malloczero: db "MALLOC gives zero",0 
8f5c			 
8f5c			malloc_guard_zerolen: 
8f5c				push hl 
8f5c				push de 
8f5c				push af 
8f5c			 
8f5c				ld de, 0 
8f5c			        call cmp16 
8f5c				jr nz, .lowalloz 
8f5c			 
8f5c				push hl 
8f5c				push de 
8f5c					ld hl, display_fb0 
8f5c					ld (display_fb_active), hl 
8f5c				call clear_display 
8f5c				ld a, 0 
8f5c				ld de, .malloczero 
8f5c				call str_at_display 
8f5c				call update_display 
8f5c				call delay1s 
8f5c				call delay1s 
8f5c				ld a, 0 
8f5c				ld (os_view_disable), a 
8f5c			 
8f5c				pop de 
8f5c				pop hl 
8f5c			 
8f5c				 
8f5c			 
8f5c				CALLMONITOR 
8f5c			.lowalloz: 
8f5c			 
8f5c			 
8f5c				pop af 
8f5c				pop de 
8f5c				pop hl 
8f5c			ret 
8f5c			 
8f5c			malloc_guard_entry: 
8f5c				push hl 
8f5c				push de 
8f5c				push af 
8f5c			 
8f5c			 	or a      ;clear carry flag 
8f5c				push hl 
8f5c				ld de, 255 
8f5c				sbc hl, de 
8f5c				jr c, .lowalloc 
8f5c			 
8f5c				push de 
8f5c					ld hl, display_fb0 
8f5c					ld (display_fb_active), hl 
8f5c				call clear_display 
8f5c				ld a, 0 
8f5c				ld de, .mallocsize 
8f5c				call str_at_display 
8f5c				call update_display 
8f5c				call delay1s 
8f5c				call delay1s 
8f5c				ld a, 0 
8f5c				ld (os_view_disable), a 
8f5c			 
8f5c				pop de 
8f5c				pop hl 
8f5c			 
8f5c				 
8f5c			 
8f5c				CALLMONITOR 
8f5c				jr .lowdone 
8f5c			.lowalloc: 
8f5c			 
8f5c			 
8f5c				pop hl 
8f5c			.lowdone:	pop af 
8f5c				pop de 
8f5c				pop hl 
8f5c			ret 
8f5c			 
8f5c			malloc_guard_exit: 
8f5c				push hl 
8f5c				push de 
8f5c				push af 
8f5c			 
8f5c			 	or a      ;clear carry flag 
8f5c				push hl 
8f5c				ld de, 255 
8f5c				sbc hl, de 
8f5c				jr c, .lowallocx 
8f5c			 
8f5c				push de 
8f5c					ld hl, display_fb0 
8f5c					ld (display_fb_active), hl 
8f5c				call clear_display 
8f5c				ld a, 0 
8f5c				ld de, .mallocasize 
8f5c				call str_at_display 
8f5c				call update_display 
8f5c				call delay1s 
8f5c				call delay1s 
8f5c				ld a, 0 
8f5c				ld (os_view_disable), a 
8f5c				pop de 
8f5c				pop hl 
8f5c			 
8f5c				CALLMONITOR 
8f5c				jr .lowdonex 
8f5c			.lowallocx: 
8f5c			 
8f5c				pop hl 
8f5c			.lowdonex:	pop af 
8f5c				pop de 
8f5c				pop hl 
8f5c			ret 
8f5c			endif 
8f5c			 
8f5c			if MALLOC_2 
8f5c			; Z80 Malloc and Free Functions 
8f5c			 
8f5c			; Malloc Function: 
8f5c			; Input: 
8f5c			;   HL: Size of block to allocate 
8f5c			; Output: 
8f5c			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f5c			 
8f5c			malloc: 
8f5c				 
8f5c			if DEBUG_FORTH_MALLOC_HIGH 
8f5c			call malloc_guard_entry 
8f5c			endif 
8f5c			 
8f5c			 
8f5c			 
8f5c			 
8f5c					if DEBUG_FORTH_MALLOC 
8f5c						DMARK "mal" 
8f5c						CALLMONITOR 
8f5c					endif 
8f5c			    push af            ; Save AF register 
8f5c			    ld a, l            ; Load low byte of size into A 
8f5c			    or h               ; Check if size is zero 
8f5c			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f5c			 
8f5c			    ; Allocate memory 
8f5c			    ld hl, (heap_start) ; Load start of heap into HL 
8f5c					if DEBUG_FORTH_MALLOC 
8f5c						DMARK "ma1" 
8f5c						CALLMONITOR 
8f5c					endif 
8f5c			    call malloc_internal ; Call internal malloc function 
8f5c			    pop af             ; Restore AF register 
8f5c			if DEBUG_FORTH_MALLOC_HIGH 
8f5c			call malloc_guard_exit 
8f5c			call malloc_guard_zerolen 
8f5c			endif 
8f5c			    ret                ; Return 
8f5c			 
8f5c			; Free Function: 
8f5c			; Input: 
8f5c			;   HL: Pointer to memory block to free 
8f5c			; Output: 
8f5c			;   None 
8f5c			 
8f5c			free: 
8f5c			    push af            ; Save AF register 
8f5c			    ld a, l            ; Load low byte of pointer into A 
8f5c			    or h               ; Check if pointer is NULL 
8f5c			    jp z, free_exit    ; If pointer is NULL, exit 
8f5c			 
8f5c			    ; Free memory 
8f5c			    ld hl, (heap_start) ; Load start of heap into HL 
8f5c			    call free_internal  ; Call internal free function 
8f5c			    pop af             ; Restore AF register 
8f5c			    ret                ; Return 
8f5c			 
8f5c			; Internal Malloc Function: 
8f5c			; Input: 
8f5c			;   HL: Size of block to allocate 
8f5c			; Output: 
8f5c			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f5c			 
8f5c			malloc_internal: 
8f5c			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f5c			    add hl, bc         ; Add management overhead to requested size 
8f5c			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f5c					if DEBUG_FORTH_MALLOC 
8f5c						DMARK "ma2" 
8f5c						CALLMONITOR 
8f5c					endif 
8f5c			 
8f5c			    ; Search for free memory block 
8f5c			    ld de, (heap_end)  ; Load end of heap into DE 
8f5c			    ld bc, 0           ; Initialize counter 
8f5c			 
8f5c					if DEBUG_FORTH_MALLOC 
8f5c						DMARK "ma2" 
8f5c						CALLMONITOR 
8f5c					endif 
8f5c			malloc_search_loop: 
8f5c			    ; Check if current block is free 
8f5c			    ld a, (hl)         ; Load current block's status (free or used) 
8f5c			    cp 0               ; Compare with zero (free) 
8f5c			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f5c			 
8f5c			    ; Check if current block is large enough 
8f5c			    ld a, (hl+1)       ; Load high byte of block size 
8f5c			    cp l               ; Compare with low byte of requested size 
8f5c			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f5c			 
8f5c			    ld a, (hl+2)       ; Load low byte of block size 
8f5c			    cp h               ; Compare with high byte of requested size 
8f5c			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f5c			 
8f5c			    ; Mark block as used 
8f5c			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f5c			 
8f5c			    ; Calculate remaining space in block 
8f5c			    ld bc, 0           ; Clear BC 
8f5c			    add hl, bc         ; Increment HL to point to start of data block 
8f5c			    add hl, de         ; HL = HL + DE (total size) 
8f5c			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f5c			    add hl, bc         ; Add management overhead to start of data block 
8f5c			 
8f5c			    ; Save pointer to allocated block in HL 
8f5c			if DEBUG_FORTH_MALLOC_HIGH 
8f5c						DMARK "ma5" 
8f5c			call malloc_guard_exit 
8f5c			call malloc_guard_zerolen 
8f5c			endif 
8f5c			    ret 
8f5c			 
8f5c			malloc_skip_block_check: 
8f5c			    ; Move to the next block 
8f5c			    ld bc, 3           ; Size of management overhead 
8f5c			    add hl, bc         ; Move to the next block 
8f5c			    inc de             ; Increment counter 
8f5c			 
8f5c			    ; Check if we have reached the end of heap 
8f5c			    ld a, e            ; Load low byte of heap end address 
8f5c			    cp (hl)            ; Compare with low byte of current address 
8f5c			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f5c			    ld a, d            ; Load high byte of heap end address 
8f5c			    cp 0               ; Check if it's zero (end of memory) 
8f5c			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f5c			 
8f5c			    ; If we reached here, allocation failed 
8f5c			    xor a              ; Set result to NULL 
8f5c			if DEBUG_FORTH_MALLOC_HIGH 
8f5c						DMARK "ma6" 
8f5c			call malloc_guard_exit 
8f5c			call malloc_guard_zerolen 
8f5c			endif 
8f5c			    ret 
8f5c			malloc_exit: 
8f5c			if DEBUG_FORTH_MALLOC_HIGH 
8f5c						DMARK "ma7" 
8f5c			call malloc_guard_exit 
8f5c			call malloc_guard_zerolen 
8f5c			endif 
8f5c			    ret 
8f5c			 
8f5c			; Internal Free Function: 
8f5c			; Input: 
8f5c			;   HL: Pointer to memory block to free 
8f5c			; Output: 
8f5c			;   None 
8f5c			 
8f5c			free_internal: 
8f5c			    ld de, (heap_start) ; Load start of heap into DE 
8f5c			    ld bc, 0            ; Initialize counter 
8f5c			 
8f5c			free_search_loop: 
8f5c			    ; Check if current block contains the pointer 
8f5c			    ld a, l             ; Load low byte of pointer 
8f5c			    cp (hl+1)           ; Compare with high byte of current block's address 
8f5c			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f5c			    ld a, h             ; Load high byte of pointer 
8f5c			    cp (hl+2)           ; Compare with low byte of current block's address 
8f5c			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f5c			 
8f5c			    ; Mark block as free 
8f5c			    ld (hl), 0          ; Set status byte to indicate free block 
8f5c			    ret                 ; Return 
8f5c			 
8f5c			free_skip_block_check: 
8f5c			    ; Move to the next block 
8f5c			    ld bc, 3            ; Size of management overhead 
8f5c			    add hl, bc          ; Move to the next block 
8f5c			    inc de              ; Increment counter 
8f5c			 
8f5c			    ; Check if we have reached the end of heap 
8f5c			    ld a, e             ; Load low byte of heap end address 
8f5c			    cp (hl)             ; Compare with low byte of current address 
8f5c			    jr nz, free_search_loop  ; If not equal, continue searching 
8f5c			    ld a, d             ; Load high byte of heap end address 
8f5c			    cp 0                ; Check if it's zero (end of memory) 
8f5c			    jr nz, free_search_loop  ; If not zero, continue searching 
8f5c			 
8f5c			    ; If we reached here, pointer is not found in heap 
8f5c			    ret 
8f5c			 
8f5c			free_exit: 
8f5c			    ret                 ; Return 
8f5c			 
8f5c			; Define heap start and end addresses 
8f5c			;heap_start:    .dw 0xC000   ; Start of heap 
8f5c			;heap_end:      .dw 0xE000   ; End of heap 
8f5c			 
8f5c			endif 
8f5c			 
8f5c			 
8f5c			if MALLOC_1 
8f5c			 
8f5c			 
8f5c			 
8f5c			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f5c			 
8f5c			;moved to firmware.asm 
8f5c			;heap_start        .equ  0x9000      ; Starting address of heap 
8f5c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f5c			 
8f5c			;      .org 0 
8f5c			;      jp    main 
8f5c			 
8f5c			 
8f5c			;      .org  0x100 
8f5c			;main: 
8f5c			;      ld    HL, 0x8100 
8f5c			;      ld    SP, HL 
8f5c			; 
8f5c			;      call  heap_init 
8f5c			; 
8f5c			;      ; Make some allocations 
8f5c			;      ld    HL, 12 
8f5c			;      call  malloc            ; Allocates 0x9004 
8f5c			; 
8f5c			;      ld    HL, 12 
8f5c			;      call  malloc            ; Allocates 0x9014 
8f5c			; 
8f5c			;      ld    HL, 12 
8f5c			;      call  malloc            ; Allocates 0x9024 
8f5c			; 
8f5c			;      ; Free some allocations 
8f5c			;      ld    HL, 0x9014 
8f5c			;      call  free 
8f5c			; 
8f5c			;      ld    HL, 0x9004 
8f5c			;      call  free 
8f5c			; 
8f5c			;      ld    HL, 0x9024 
8f5c			;      call  free 
8f5c			; 
8f5c			; 
8f5c			;      halt 
8f5c			 
8f5c			 
8f5c			;------------------------------------------------------------------------------ 
8f5c			;     heap_init                                                               : 
8f5c			;                                                                             : 
8f5c			; Description                                                                 : 
8f5c			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f5c			;                                                                             : 
8f5c			;     The heap is maintained as a linked list, starting with an initial       : 
8f5c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f5c			;     the first free block in the heap. Each block then points to the next    : 
8f5c			;     free block within the heap, and the free list ends at the first block   : 
8f5c			;     with a null pointer to the next free block.                             : 
8f5c			;                                                                             : 
8f5c			; Parameters                                                                  : 
8f5c			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f5c			;     address of the heap and its size are required, along with a memory      : 
8f5c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f5c			;     principally stores a pointer to the first free block in the heap.       : 
8f5c			;                                                                             : 
8f5c			; Returns                                                                     : 
8f5c			;     Nothing                                                                 : 
8f5c			;------------------------------------------------------------------------------ 
8f5c			heap_init: 
8f5c e5			      push  HL 
8f5d			 
8f5d			      ; Initialise free list struct 
8f5d 21 e4 d7		      ld    HL, heap_start 
8f60 22 df d7		      ld    (free_list), HL 
8f63 21 00 00		      ld    HL, 0 
8f66 22 e1 d7		      ld    (free_list+2), HL 
8f69			 
8f69			      ; Insert first free block at bottom of heap, consumes entire heap 
8f69 21 bf e4		      ld    HL, heap_start+heap_size-4 
8f6c 22 e4 d7		      ld    (heap_start), HL        ; Next block (end of free list) 
8f6f 21 db 0c		      ld    HL, heap_size-4 
8f72 22 e6 d7		      ld    (heap_start+2), HL      ; Block size 
8f75			 
8f75			      ; Insert end of free list block at top of heap - two null words will 
8f75			      ; terminate the free list 
8f75 21 00 00		      ld    HL, 0 
8f78 22 c1 e4		      ld    (heap_start+heap_size-2), HL 
8f7b 22 bf e4		      ld    (heap_start+heap_size-4), HL 
8f7e			 
8f7e e1			      pop   HL 
8f7f			 
8f7f c9			      ret 
8f80			 
8f80			 
8f80			;------------------------------------------------------------------------------ 
8f80			;     malloc                                                                  : 
8f80			;                                                                             : 
8f80			; Description                                                                 : 
8f80			;     Allocates the wanted space from the heap and returns the address of the : 
8f80			;     first useable byte of the allocation.                                   : 
8f80			;                                                                             : 
8f80			;     Allocations can happen in one of two ways:                              : 
8f80			;                                                                             : 
8f80			;     1. A free block may be found which is the exact size wanted. In this    : 
8f80			;        case the block is removed from the free list and retuedn to the      : 
8f80			;        caller.                                                              : 
8f80			;     2. A free block may be found which is larger than the size wanted. In   : 
8f80			;        this case, the larger block is split into two. The first portion of  : 
8f80			;        this block will become the requested space by the malloc call and    : 
8f80			;        is returned to the caller. The second portion becomes a new free     : 
8f80			;        block, and the free list is adjusted to maintain continuity via this : 
8f80			;        newly created block.                                                 : 
8f80			;                                                                             : 
8f80			;     malloc does not set any initial value in the allocated space, the       : 
8f80			;     caller is required to do this as required.                              : 
8f80			;                                                                             : 
8f80			;     This implementation of malloc uses the stack exclusively, and is        : 
8f80			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f80			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f80			;     to avoid the use of malloc inside ISRs in general.                      : 
8f80			;                                                                             : 
8f80			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f80			;                                                                             : 
8f80			; Parameters                                                                  : 
8f80			;     HL  Number of bytes wanted                                              : 
8f80			;                                                                             : 
8f80			; Returns                                                                     : 
8f80			;     HL  Address of the first useable byte of the allocation                 : 
8f80			;                                                                             : 
8f80			; Flags                                                                       : 
8f80			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f80			;                                                                             : 
8f80			; Stack frame                                                                 : 
8f80			;       |             |                                                       : 
8f80			;       +-------------+                                                       : 
8f80			;       |     BC      |                                                       : 
8f80			;       +-------------+                                                       : 
8f80			;       |     DE      |                                                       : 
8f80			;       +-------------+                                                       : 
8f80			;       |     IX      |                                                       : 
8f80			;       +-------------+                                                       : 
8f80			;       |  prev_free  |                                                       : 
8f80			;   +4  +-------------+                                                       : 
8f80			;       |  this_free  |                                                       : 
8f80			;   +2  +-------------+                                                       : 
8f80			;       |  next_free  |                                                       : 
8f80			;   +0  +-------------+                                                       : 
8f80			;       |             |                                                       : 
8f80			;                                                                             : 
8f80			;------------------------------------------------------------------------------ 
8f80			 
8f80			 
8f80			;malloc: 
8f80			; 
8f80			;	SAVESP ON 1 
8f80			; 
8f80			;	call malloc_code 
8f80			; 
8f80			;	CHECKSP ON 1 
8f80			;	ret 
8f80			 
8f80			 
8f80			malloc: 
8f80 c5			      push  BC 
8f81 d5			      push  DE 
8f82 dd e5		      push  IX 
8f84			if DEBUG_FORTH_MALLOC_HIGH 
8f84			call malloc_guard_entry 
8f84			endif 
8f84			 
8f84					if DEBUG_FORTH_MALLOC 
8f84						DMARK "mal" 
8f84						CALLMONITOR 
8f84					endif 
8f84 7c			      ld    A, H                    ; Exit if no space requested 
8f85 b5			      or    L 
8f86 ca 45 90		      jp    Z, malloc_early_exit 
8f89			 
8f89			;inc hl 
8f89			;inc hl 
8f89			;inc hl 
8f89			; 
8f89			;inc hl 
8f89			;inc hl 
8f89			;inc hl 
8f89			;inc hl 
8f89			;inc hl 
8f89			;inc hl 
8f89			;inc hl 
8f89			;inc hl 
8f89			;inc hl 
8f89			 
8f89			 
8f89			 
8f89			 
8f89					if DEBUG_FORTH_MALLOC 
8f89						DMARK "maA" 
8f89						CALLMONITOR 
8f89					endif 
8f89			      ; Set up stack frame 
8f89 eb			      ex    DE, HL 
8f8a 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f8d 39			      add   HL, SP 
8f8e f9			      ld    SP, HL 
8f8f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f93 dd 39		      add   IX, SP 
8f95			 
8f95			      ; Setup initial state 
8f95 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f98 19			      add   HL, DE 
8f99			 
8f99 44			      ld    B, H                    ; Move want to BC 
8f9a 4d			      ld    C, L 
8f9b			 
8f9b 21 df d7		      ld    HL, free_list           ; Store prev_free ptr to stack 
8f9e dd 75 04		      ld    (IX+4), L 
8fa1 dd 74 05		      ld    (IX+5), H 
8fa4			 
8fa4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8fa5 23			      inc   HL 
8fa6 56			      ld    D, (HL) 
8fa7 dd 73 02		      ld    (IX+2), E 
8faa dd 72 03		      ld    (IX+3), D 
8fad eb			      ex    DE, HL                  ; this_free ptr into HL 
8fae			 
8fae					if DEBUG_FORTH_MALLOC 
8fae						DMARK "maB" 
8fae						CALLMONITOR 
8fae					endif 
8fae			      ; Loop through free block list to find some space 
8fae			malloc_find_space: 
8fae 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8faf 23			      inc   HL 
8fb0 56			      ld    D, (HL) 
8fb1			 
8fb1 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8fb2 b3			      or    E 
8fb3 ca 3f 90		      jp    Z, malloc_no_space 
8fb6			 
8fb6 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8fb9 dd 72 01		      ld    (IX+1), D 
8fbc			 
8fbc			      ; Does this block have enough space to make the allocation? 
8fbc 23			      inc   HL                      ; Load free block size into DE 
8fbd 5e			      ld    E, (HL) 
8fbe 23			      inc   HL 
8fbf 56			      ld    D, (HL) 
8fc0			 
8fc0 eb			      ex    DE, HL                  ; Check size of block against want 
8fc1 b7			      or    A                       ; Ensure carry flag clear 
8fc2 ed 42		      sbc   HL, BC 
8fc4 e5			      push  HL                      ; Store the result for later (new block size) 
8fc5			 
8fc5 ca 14 90		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8fc8 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8fca			 
8fca			      ; this_free block is not big enough, setup ptrs to test next free block 
8fca e1			      pop   HL                      ; Discard previous result 
8fcb			 
8fcb dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8fce dd 66 03		      ld    H, (IX+3) 
8fd1 dd 75 04		      ld    (IX+4), L 
8fd4 dd 74 05		      ld    (IX+5), H 
8fd7			 
8fd7 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8fda dd 66 01		      ld    H, (IX+1) 
8fdd dd 75 02		      ld    (IX+2), L 
8fe0 dd 74 03		      ld    (IX+3), H 
8fe3			 
8fe3					if DEBUG_FORTH_MALLOC 
8fe3						DMARK "MA>" 
8fe3						CALLMONITOR 
8fe3					endif 
8fe3 18 c9		      jr    malloc_find_space 
8fe5			 
8fe5			      ; split a bigger block into two - requested size and remaining size 
8fe5			malloc_alloc_split: 
8fe5					if DEBUG_FORTH_MALLOC 
8fe5						DMARK "MAs" 
8fe5						CALLMONITOR 
8fe5					endif 
8fe5 eb			      ex    DE, HL                  ; Calculate address of new free block 
8fe6 2b			      dec   HL 
8fe7 2b			      dec   HL 
8fe8 2b			      dec   HL 
8fe9 09			      add   HL, BC 
8fea			 
8fea			      ; Create a new block and point it at next_free 
8fea dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8fed dd 56 01		      ld    D, (IX+1) 
8ff0			 
8ff0 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8ff1 23			      inc   HL 
8ff2 72			      ld    (HL), D 
8ff3			 
8ff3 d1			      pop   DE                      ; Store size of new block into new block 
8ff4 23			      inc   HL 
8ff5 73			      ld    (HL), E 
8ff6 23			      inc   HL 
8ff7 72			      ld    (HL), D 
8ff8			 
8ff8			      ; Update this_free ptr to point to new block 
8ff8 2b			      dec   HL 
8ff9 2b			      dec   HL 
8ffa 2b			      dec   HL 
8ffb			 
8ffb dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8ffe dd 56 03		      ld    D, (IX+3) 
9001			 
9001 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9004 dd 74 03		      ld    (IX+3), H 
9007			 
9007			      ; Modify this_free block to be allocation 
9007 eb			      ex    DE, HL 
9008 af			      xor   A                       ; Null the next block ptr of allocated block 
9009 77			      ld    (HL), A 
900a 23			      inc   HL 
900b 77			      ld    (HL), A 
900c			 
900c 23			      inc   HL                      ; Store want size into allocated block 
900d 71			      ld    (HL), C 
900e 23			      inc   HL 
900f 70			      ld    (HL), B 
9010 23			      inc   HL 
9011 e5			      push  HL                      ; Address of allocation to return 
9012			 
9012 18 19		      jr    malloc_update_links 
9014			 
9014			malloc_alloc_fit: 
9014 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9015			 
9015					if DEBUG_FORTH_MALLOC 
9015						DMARK "MAf" 
9015						CALLMONITOR 
9015					endif 
9015			      ; Modify this_free block to be allocation 
9015 eb			      ex    DE, HL 
9016 2b			      dec   HL 
9017 2b			      dec   HL 
9018 2b			      dec   HL 
9019			 
9019 af			      xor   A                       ; Null the next block ptr of allocated block 
901a 77			      ld    (HL), A 
901b 23			      inc   HL 
901c 77			      ld    (HL), A 
901d			 
901d 23			      inc   HL                      ; Store address of allocation to return 
901e 23			      inc   HL 
901f 23			      inc   HL 
9020 e5			      push  HL 
9021			 
9021			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9021 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9024 dd 66 01		      ld    H, (IX+1) 
9027			 
9027 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
902a dd 74 03		      ld    (IX+3), H 
902d			 
902d			 
902d			malloc_update_links: 
902d			      ; Update prev_free ptr to point to this_free 
902d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9030 dd 66 05		      ld    H, (IX+5) 
9033			 
9033 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9036 dd 56 03		      ld    D, (IX+3) 
9039			 
9039 73			      ld    (HL), E                 ; this_free ptr into prev_free 
903a 23			      inc   HL 
903b 72			      ld    (HL), D 
903c			 
903c					if DEBUG_FORTH_MALLOC 
903c						DMARK "Mul" 
903c						CALLMONITOR 
903c					endif 
903c			      ; Clear the Z flag to indicate successful allocation 
903c 7a			      ld    A, D 
903d b3			      or    E 
903e			 
903e d1			      pop   DE                      ; Address of allocation 
903f					if DEBUG_FORTH_MALLOC 
903f						DMARK "MAu" 
903f						CALLMONITOR 
903f					endif 
903f			 
903f			malloc_no_space: 
903f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9042 39			      add   HL, SP 
9043 f9			      ld    SP, HL 
9044			 
9044 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9045					if DEBUG_FORTH_MALLOC 
9045						DMARK "MAN" 
9045						CALLMONITOR 
9045					endif 
9045			 
9045			malloc_early_exit: 
9045					if DEBUG_FORTH_MALLOC 
9045						DMARK "MAx" 
9045						CALLMONITOR 
9045					endif 
9045 dd e1		      pop   IX 
9047 d1			      pop   DE 
9048 c1			      pop   BC 
9049			 
9049			if DEBUG_FORTH_MALLOC_HIGH 
9049			call malloc_guard_exit 
9049			call malloc_guard_zerolen 
9049			endif 
9049 c9			      ret 
904a			 
904a			 
904a			;------------------------------------------------------------------------------ 
904a			;     free                                                                    : 
904a			;                                                                             : 
904a			; Description                                                                 : 
904a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
904a			;     returned by malloc, otherwise the behaviour is undefined.               : 
904a			;                                                                             : 
904a			;     Where possible, directly adjacent free blocks will be merged together   : 
904a			;     into larger blocks to help ensure that the heap does not become         : 
904a			;     excessively fragmented.                                                 : 
904a			;                                                                             : 
904a			;     free does not clear or set any other value into the freed space, and    : 
904a			;     therefore its contents may be visible through subsequent malloc's. The  : 
904a			;     caller should clear the freed space as required.                        : 
904a			;                                                                             : 
904a			;     This implementation of free uses the stack exclusively, and is          : 
904a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
904a			;     advisable to disable interrupts before calling free, and recommended    : 
904a			;     to avoid the use of free inside ISRs in general.                        : 
904a			;                                                                             : 
904a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
904a			;                                                                             : 
904a			; Parameters                                                                  : 
904a			;     HL  Pointer to address of first byte of allocation to be freed          : 
904a			;                                                                             : 
904a			; Returns                                                                     : 
904a			;     Nothing                                                                 : 
904a			;                                                                             : 
904a			; Stack frame                                                                 : 
904a			;       |             |                                                       : 
904a			;       +-------------+                                                       : 
904a			;       |     BC      |                                                       : 
904a			;       +-------------+                                                       : 
904a			;       |     DE      |                                                       : 
904a			;       +-------------+                                                       : 
904a			;       |     IX      |                                                       : 
904a			;       +-------------+                                                       : 
904a			;       |  prev_free  |                                                       : 
904a			;   +2  +-------------+                                                       : 
904a			;       |  next_free  |                                                       : 
904a			;   +0  +-------------+                                                       : 
904a			;       |             |                                                       : 
904a			;                                                                             : 
904a			;------------------------------------------------------------------------------ 
904a			free: 
904a c5			      push  BC 
904b d5			      push  DE 
904c dd e5		      push  IX 
904e			 
904e 7c			      ld    A, H                    ; Exit if ptr is null 
904f b5			      or    L 
9050 ca 14 91		      jp    Z, free_early_exit 
9053			 
9053			      ; Set up stack frame 
9053 eb			      ex    DE, HL 
9054 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9057 39			      add   HL, SP 
9058 f9			      ld    SP, HL 
9059 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
905d dd 39		      add   IX, SP 
905f			 
905f			      ; The address in HL points to the start of the useable allocated space, 
905f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
905f			      ; address of the block itself. 
905f eb			      ex    DE, HL 
9060 11 fc ff		      ld    DE, -4 
9063 19			      add   HL, DE 
9064			 
9064			      ; An allocated block must have a null next block pointer in it 
9064 7e			      ld    A, (HL) 
9065 23			      inc   HL 
9066 b6			      or    (HL) 
9067 c2 0f 91		      jp    NZ, free_done 
906a			 
906a 2b			      dec   HL 
906b			 
906b 44			      ld    B, H                    ; Copy HL to BC 
906c 4d			      ld    C, L 
906d			 
906d			      ; Loop through the free list to find the first block with an address 
906d			      ; higher than the block being freed 
906d 21 df d7		      ld    HL, free_list 
9070			 
9070			free_find_higher_block: 
9070 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9071 23			      inc   HL 
9072 56			      ld    D, (HL) 
9073 2b			      dec   HL 
9074			 
9074 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9077 dd 72 01		      ld    (IX+1), D 
907a dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
907d dd 74 03		      ld    (IX+3), H 
9080			 
9080 78			      ld    A, B                    ; Check if DE is greater than BC 
9081 ba			      cp    D                       ; Compare MSB first 
9082 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9084 30 04		      jr    NC, free_find_higher_block_skip 
9086 79			      ld    A, C 
9087 bb			      cp    E                       ; Then compare LSB 
9088 38 08		      jr    C, free_found_higher_block 
908a			 
908a			free_find_higher_block_skip: 
908a 7a			      ld    A, D                    ; Reached the end of the free list? 
908b b3			      or    E 
908c ca 0f 91		      jp    Z, free_done 
908f			 
908f eb			      ex    DE, HL 
9090			 
9090 18 de		      jr    free_find_higher_block 
9092			 
9092			free_found_higher_block: 
9092			      ; Insert freed block between prev and next free blocks 
9092 71			      ld    (HL), C                 ; Point prev free block to freed block 
9093 23			      inc   HL 
9094 70			      ld    (HL), B 
9095			 
9095 60			      ld    H, B                    ; Point freed block at next free block 
9096 69			      ld    L, C 
9097 73			      ld    (HL), E 
9098 23			      inc   HL 
9099 72			      ld    (HL), D 
909a			 
909a			      ; Check if the freed block is adjacent to the next free block 
909a 23			      inc   HL                      ; Load size of freed block into HL 
909b 5e			      ld    E, (HL) 
909c 23			      inc   HL 
909d 56			      ld    D, (HL) 
909e eb			      ex    DE, HL 
909f			 
909f 09			      add   HL, BC                  ; Add addr of freed block and its size 
90a0			 
90a0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
90a3 dd 56 01		      ld    D, (IX+1) 
90a6			 
90a6 b7			      or    A                       ; Clear the carry flag 
90a7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
90a9 20 22		      jr    NZ, free_check_adjacent_to_prev 
90ab			 
90ab			      ; Freed block is adjacent to next, merge into one bigger block 
90ab eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
90ac 5e			      ld    E, (HL) 
90ad 23			      inc   HL 
90ae 56			      ld    D, (HL) 
90af e5			      push  HL                      ; Save ptr to next block for later 
90b0			 
90b0 60			      ld    H, B                    ; Store ptr from next block into freed block 
90b1 69			      ld    L, C 
90b2 73			      ld    (HL), E 
90b3 23			      inc   HL 
90b4 72			      ld    (HL), D 
90b5			 
90b5 e1			      pop   HL                      ; Restore ptr to next block 
90b6 23			      inc   HL                      ; Load size of next block into DE 
90b7 5e			      ld    E, (HL) 
90b8 23			      inc   HL 
90b9 56			      ld    D, (HL) 
90ba d5			      push  DE                      ; Save next block size for later 
90bb			 
90bb 60			      ld    H, B                    ; Load size of freed block into HL 
90bc 69			      ld    L, C 
90bd 23			      inc   HL 
90be 23			      inc   HL 
90bf 5e			      ld    E, (HL) 
90c0 23			      inc   HL 
90c1 56			      ld    D, (HL) 
90c2 eb			      ex    DE, HL 
90c3			 
90c3 d1			      pop   DE                      ; Restore size of next block 
90c4 19			      add   HL, DE                  ; Add sizes of both blocks 
90c5 eb			      ex    DE, HL 
90c6			 
90c6 60			      ld    H, B                    ; Store new bigger size into freed block 
90c7 69			      ld    L, C 
90c8 23			      inc   HL 
90c9 23			      inc   HL 
90ca 73			      ld    (HL), E 
90cb 23			      inc   HL 
90cc 72			      ld    (HL), D 
90cd			 
90cd			free_check_adjacent_to_prev: 
90cd			      ; Check if the freed block is adjacent to the prev free block 
90cd dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
90d0 dd 66 03		      ld    H, (IX+3) 
90d3			 
90d3 23			      inc   HL                      ; Size of prev free block into DE 
90d4 23			      inc   HL 
90d5 5e			      ld    E, (HL) 
90d6 23			      inc   HL 
90d7 56			      ld    D, (HL) 
90d8 2b			      dec   HL 
90d9 2b			      dec   HL 
90da 2b			      dec   HL 
90db			 
90db 19			      add   HL, DE                  ; Add prev block addr and size 
90dc			 
90dc b7			      or    A                       ; Clear the carry flag 
90dd ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90df 20 2e		      jr    NZ, free_done 
90e1			 
90e1			      ; Freed block is adjacent to prev, merge into one bigger block 
90e1 60			      ld    H, B                    ; Load next ptr from freed block into DE 
90e2 69			      ld    L, C 
90e3 5e			      ld    E, (HL) 
90e4 23			      inc   HL 
90e5 56			      ld    D, (HL) 
90e6 e5			      push  HL                      ; Save freed block ptr for later 
90e7			 
90e7 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90ea dd 66 03		      ld    H, (IX+3) 
90ed 73			      ld    (HL), E 
90ee 23			      inc   HL 
90ef 72			      ld    (HL), D 
90f0			 
90f0 e1			      pop   HL                      ; Restore freed block ptr 
90f1 23			      inc   HL                      ; Load size of freed block into DE 
90f2 5e			      ld    E, (HL) 
90f3 23			      inc   HL 
90f4 56			      ld    D, (HL) 
90f5 d5			      push  DE                      ; Save freed block size for later 
90f6			 
90f6 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
90f9 dd 66 03		      ld    H, (IX+3) 
90fc 23			      inc   HL 
90fd 23			      inc   HL 
90fe 5e			      ld    E, (HL) 
90ff 23			      inc   HL 
9100 56			      ld    D, (HL) 
9101			 
9101 e1			      pop   HL                      ; Add sizes of both blocks 
9102 19			      add   HL, DE 
9103 eb			      ex    DE, HL 
9104			 
9104 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9107 dd 66 03		      ld    H, (IX+3) 
910a 23			      inc   HL 
910b 23			      inc   HL 
910c 73			      ld    (HL), E 
910d 23			      inc   HL 
910e 72			      ld    (HL), D 
910f			 
910f			free_done: 
910f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9112 39			      add   HL, SP 
9113 f9			      ld    SP, HL 
9114			 
9114			free_early_exit: 
9114 dd e1		      pop   IX 
9116 d1			      pop   DE 
9117 c1			      pop   BC 
9118			 
9118 c9			      ret 
9119			 
9119			; moved to firmware.asm 
9119			; 
9119			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9119			;                  .dw   0 
9119			 
9119			 
9119			endif 
9119			 
9119			 
9119			if MALLOC_3 
9119			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9119			;heap_start        .equ  0x9000      ; Starting address of heap 
9119			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9119			; 
9119			 ;     .org 0 
9119			  ;    jp    main 
9119			; 
9119			; 
9119			 ;     .org  0x100 
9119			;main: 
9119			 ;     ld    HL, 0x8100 
9119			  ;    ld    SP, HL 
9119			; 
9119			;      call  heap_init 
9119			 
9119			      ; Make some allocations 
9119			;      ld    HL, 12 
9119			;      call  malloc            ; Allocates 0x9004 
9119			; 
9119			 ;     ld    HL, 12 
9119			;      call  malloc            ; Allocates 0x9014 
9119			 
9119			;      ld    HL, 12 
9119			;      call  malloc            ; Allocates 0x9024 
9119			 
9119			      ; Free some allocations 
9119			;      ld    HL, 0x9014 
9119			;      call  free 
9119			 
9119			;      ld    HL, 0x9004 
9119			;      call  free 
9119			; 
9119			;      ld    HL, 0x9024 
9119			;      call  free 
9119			 
9119			 
9119			 ;     halt 
9119			 
9119			 
9119			;------------------------------------------------------------------------------ 
9119			;     heap_init                                                               : 
9119			;                                                                             : 
9119			; Description                                                                 : 
9119			;     Initialise the heap and make it ready for malloc and free operations.   : 
9119			;                                                                             : 
9119			;     The heap is maintained as a linked list, starting with an initial       : 
9119			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9119			;     the first free block in the heap. Each block then points to the next    : 
9119			;     free block within the heap, and the free list ends at the first block   : 
9119			;     with a null pointer to the next free block.                             : 
9119			;                                                                             : 
9119			; Parameters                                                                  : 
9119			;     Inputs are compile-time only. Two defines which specify the starting    : 
9119			;     address of the heap and its size are required, along with a memory      : 
9119			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9119			;     principally stores a pointer to the first free block in the heap.       : 
9119			;                                                                             : 
9119			; Returns                                                                     : 
9119			;     Nothing                                                                 : 
9119			;------------------------------------------------------------------------------ 
9119			heap_init: 
9119			      push  HL 
9119			 
9119			      ; Initialise free list struct 
9119			      ld    HL, heap_start 
9119			      ld    (free_list), HL 
9119			      ld    HL, 0 
9119			      ld    (free_list+2), HL 
9119			 
9119			      ; Insert first free block at bottom of heap, consumes entire heap 
9119			      ld    HL, heap_start+heap_size-4 
9119			      ld    (heap_start), HL        ; Next block (end of free list) 
9119			      ld    HL, heap_size-4 
9119			      ld    (heap_start+2), HL      ; Block size 
9119			 
9119			      ; Insert end of free list block at top of heap - two null words will 
9119			      ; terminate the free list 
9119			      ld    HL, 0 
9119			      ld    (heap_start+heap_size-2), HL 
9119			      ld    (heap_start+heap_size-4), HL 
9119			 
9119			      pop   HL 
9119			 
9119			      ret 
9119			 
9119			 
9119			;------------------------------------------------------------------------------ 
9119			;     malloc                                                                  : 
9119			;                                                                             : 
9119			; Description                                                                 : 
9119			;     Allocates the wanted space from the heap and returns the address of the : 
9119			;     first useable byte of the allocation.                                   : 
9119			;                                                                             : 
9119			;     Allocations can happen in one of two ways:                              : 
9119			;                                                                             : 
9119			;     1. A free block may be found which is the exact size wanted. In this    : 
9119			;        case the block is removed from the free list and retuedn to the      : 
9119			;        caller.                                                              : 
9119			;     2. A free block may be found which is larger than the size wanted. In   : 
9119			;        this case, the larger block is split into two. The first portion of  : 
9119			;        this block will become the requested space by the malloc call and    : 
9119			;        is returned to the caller. The second portion becomes a new free     : 
9119			;        block, and the free list is adjusted to maintain continuity via this : 
9119			;        newly created block.                                                 : 
9119			;                                                                             : 
9119			;     malloc does not set any initial value in the allocated space, the       : 
9119			;     caller is required to do this as required.                              : 
9119			;                                                                             : 
9119			;     This implementation of malloc uses the stack exclusively, and is        : 
9119			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9119			;     advisable to disable interrupts before calling malloc, and recommended  : 
9119			;     to avoid the use of malloc inside ISRs in general.                      : 
9119			;                                                                             : 
9119			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9119			;                                                                             : 
9119			; Parameters                                                                  : 
9119			;     HL  Number of bytes wanted                                              : 
9119			;                                                                             : 
9119			; Returns                                                                     : 
9119			;     HL  Address of the first useable byte of the allocation                 : 
9119			;                                                                             : 
9119			; Flags                                                                       : 
9119			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9119			;                                                                             : 
9119			; Stack frame                                                                 : 
9119			;       |             |                                                       : 
9119			;       +-------------+                                                       : 
9119			;       |     BC      |                                                       : 
9119			;       +-------------+                                                       : 
9119			;       |     DE      |                                                       : 
9119			;       +-------------+                                                       : 
9119			;       |     IX      |                                                       : 
9119			;       +-------------+                                                       : 
9119			;       |  prev_free  |                                                       : 
9119			;   +4  +-------------+                                                       : 
9119			;       |  this_free  |                                                       : 
9119			;   +2  +-------------+                                                       : 
9119			;       |  next_free  |                                                       : 
9119			;   +0  +-------------+                                                       : 
9119			;       |             |                                                       : 
9119			;                                                                             : 
9119			;------------------------------------------------------------------------------ 
9119			malloc: 
9119			      push  BC 
9119			      push  DE 
9119			      push  IX 
9119			 
9119			      ld    A, H                    ; Exit if no space requested 
9119			      or    L 
9119			      jp    Z, malloc_early_exit 
9119			 
9119			      ; Set up stack frame 
9119			      ex    DE, HL 
9119			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9119			      add   HL, SP 
9119			      ld    SP, HL 
9119			      ld    IX, 0                   ; Use IX as a frame pointer 
9119			      add   IX, SP 
9119			 
9119			      ; Setup initial state 
9119			      ld    HL, 4                   ; want must also include space used by block struct 
9119			      add   HL, DE 
9119			 
9119			      ld    B, H                    ; Move want to BC 
9119			      ld    C, L 
9119			 
9119			      ld    HL, free_list           ; Store prev_free ptr to stack 
9119			      ld    (IX+4), L 
9119			      ld    (IX+5), H 
9119			 
9119			      ld    E, (HL)                 ; Store this_free ptr to stack 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			      ld    (IX+2), E 
9119			      ld    (IX+3), D 
9119			      ex    DE, HL                  ; this_free ptr into HL 
9119			 
9119			      ; Loop through free block list to find some space 
9119			malloc_find_space: 
9119			      ld    E, (HL)                 ; Load next_free ptr into DE 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			 
9119			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9119			      or    E 
9119			      jp    Z, malloc_no_space 
9119			 
9119			      ld    (IX+0), E               ; Store next_free ptr to stack 
9119			      ld    (IX+1), D 
9119			 
9119			      ; Does this block have enough space to make the allocation? 
9119			      inc   HL                      ; Load free block size into DE 
9119			      ld    E, (HL) 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			 
9119			      ex    DE, HL                  ; Check size of block against want 
9119			      or    A                       ; Ensure carry flag clear 
9119			      sbc   HL, BC 
9119			      push  HL                      ; Store the result for later (new block size) 
9119			 
9119			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9119			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9119			 
9119			      ; this_free block is not big enough, setup ptrs to test next free block 
9119			      pop   HL                      ; Discard previous result 
9119			 
9119			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9119			      ld    H, (IX+3) 
9119			      ld    (IX+4), L 
9119			      ld    (IX+5), H 
9119			 
9119			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9119			      ld    H, (IX+1) 
9119			      ld    (IX+2), L 
9119			      ld    (IX+3), H 
9119			 
9119			      jr    malloc_find_space 
9119			 
9119			      ; split a bigger block into two - requested size and remaining size 
9119			malloc_alloc_split: 
9119			      ex    DE, HL                  ; Calculate address of new free block 
9119			      dec   HL 
9119			      dec   HL 
9119			      dec   HL 
9119			      add   HL, BC 
9119			 
9119			      ; Create a new block and point it at next_free 
9119			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9119			      ld    D, (IX+1) 
9119			 
9119			      ld    (HL), E                 ; Store next_free ptr into new block 
9119			      inc   HL 
9119			      ld    (HL), D 
9119			 
9119			      pop   DE                      ; Store size of new block into new block 
9119			      inc   HL 
9119			      ld    (HL), E 
9119			      inc   HL 
9119			      ld    (HL), D 
9119			 
9119			      ; Update this_free ptr to point to new block 
9119			      dec   HL 
9119			      dec   HL 
9119			      dec   HL 
9119			 
9119			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9119			      ld    D, (IX+3) 
9119			 
9119			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9119			      ld    (IX+3), H 
9119			 
9119			      ; Modify this_free block to be allocation 
9119			      ex    DE, HL 
9119			      xor   A                       ; Null the next block ptr of allocated block 
9119			      ld    (HL), A 
9119			      inc   HL 
9119			      ld    (HL), A 
9119			 
9119			      inc   HL                      ; Store want size into allocated block 
9119			      ld    (HL), C 
9119			      inc   HL 
9119			      ld    (HL), B 
9119			      inc   HL 
9119			      push  HL                      ; Address of allocation to return 
9119			 
9119			      jr    malloc_update_links 
9119			 
9119			malloc_alloc_fit: 
9119			      pop   HL                      ; Dont need new block size, want is exact fit 
9119			 
9119			      ; Modify this_free block to be allocation 
9119			      ex    DE, HL 
9119			      dec   HL 
9119			      dec   HL 
9119			      dec   HL 
9119			 
9119			      xor   A                       ; Null the next block ptr of allocated block 
9119			      ld    (HL), A 
9119			      inc   HL 
9119			      ld    (HL), A 
9119			 
9119			      inc   HL                      ; Store address of allocation to return 
9119			      inc   HL 
9119			      inc   HL 
9119			      push  HL 
9119			 
9119			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9119			      ld    L, (IX+0)               ; next_free to HL 
9119			      ld    H, (IX+1) 
9119			 
9119			      ld    (IX+2), L               ; HL to this_free 
9119			      ld    (IX+3), H 
9119			 
9119			 
9119			malloc_update_links: 
9119			      ; Update prev_free ptr to point to this_free 
9119			      ld    L, (IX+4)               ; prev_free ptr to HL 
9119			      ld    H, (IX+5) 
9119			 
9119			      ld    E, (IX+2)               ; this_free ptr to DE 
9119			      ld    D, (IX+3) 
9119			 
9119			      ld    (HL), E                 ; this_free ptr into prev_free 
9119			      inc   HL 
9119			      ld    (HL), D 
9119			 
9119			      ; Clear the Z flag to indicate successful allocation 
9119			      ld    A, D 
9119			      or    E 
9119			 
9119			      pop   DE                      ; Address of allocation 
9119			 
9119			malloc_no_space: 
9119			      ld    HL, 6                   ; Clean up stack frame 
9119			      add   HL, SP 
9119			      ld    SP, HL 
9119			 
9119			      ex    DE, HL                  ; Alloc addr into HL for return 
9119			 
9119			malloc_early_exit: 
9119			      pop   IX 
9119			      pop   DE 
9119			      pop   BC 
9119			 
9119			      ret 
9119			 
9119			 
9119			;------------------------------------------------------------------------------ 
9119			;     free                                                                    : 
9119			;                                                                             : 
9119			; Description                                                                 : 
9119			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9119			;     returned by malloc, otherwise the behaviour is undefined.               : 
9119			;                                                                             : 
9119			;     Where possible, directly adjacent free blocks will be merged together   : 
9119			;     into larger blocks to help ensure that the heap does not become         : 
9119			;     excessively fragmented.                                                 : 
9119			;                                                                             : 
9119			;     free does not clear or set any other value into the freed space, and    : 
9119			;     therefore its contents may be visible through subsequent malloc's. The  : 
9119			;     caller should clear the freed space as required.                        : 
9119			;                                                                             : 
9119			;     This implementation of free uses the stack exclusively, and is          : 
9119			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9119			;     advisable to disable interrupts before calling free, and recommended    : 
9119			;     to avoid the use of free inside ISRs in general.                        : 
9119			;                                                                             : 
9119			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9119			;                                                                             : 
9119			; Parameters                                                                  : 
9119			;     HL  Pointer to address of first byte of allocation to be freed          : 
9119			;                                                                             : 
9119			; Returns                                                                     : 
9119			;     Nothing                                                                 : 
9119			;                                                                             : 
9119			; Stack frame                                                                 : 
9119			;       |             |                                                       : 
9119			;       +-------------+                                                       : 
9119			;       |     BC      |                                                       : 
9119			;       +-------------+                                                       : 
9119			;       |     DE      |                                                       : 
9119			;       +-------------+                                                       : 
9119			;       |     IX      |                                                       : 
9119			;       +-------------+                                                       : 
9119			;       |  prev_free  |                                                       : 
9119			;   +2  +-------------+                                                       : 
9119			;       |  next_free  |                                                       : 
9119			;   +0  +-------------+                                                       : 
9119			;       |             |                                                       : 
9119			;                                                                             : 
9119			;------------------------------------------------------------------------------ 
9119			free: 
9119			      push  BC 
9119			      push  DE 
9119			      push  IX 
9119			 
9119			      ld    A, H                    ; Exit if ptr is null 
9119			      or    L 
9119			      jp    Z, free_early_exit 
9119			 
9119			      ; Set up stack frame 
9119			      ex    DE, HL 
9119			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9119			      add   HL, SP 
9119			      ld    SP, HL 
9119			      ld    IX, 0                   ; Use IX as a frame pointer 
9119			      add   IX, SP 
9119			 
9119			      ; The address in HL points to the start of the useable allocated space, 
9119			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9119			      ; address of the block itself. 
9119			      ex    DE, HL 
9119			      ld    DE, -4 
9119			      add   HL, DE 
9119			 
9119			      ; An allocated block must have a null next block pointer in it 
9119			      ld    A, (HL) 
9119			      inc   HL 
9119			      or    (HL) 
9119			      jp    NZ, free_done 
9119			 
9119			      dec   HL 
9119			 
9119			      ld    B, H                    ; Copy HL to BC 
9119			      ld    C, L 
9119			 
9119			      ; Loop through the free list to find the first block with an address 
9119			      ; higher than the block being freed 
9119			      ld    HL, free_list 
9119			 
9119			free_find_higher_block: 
9119			      ld    E, (HL)                 ; Load next ptr from free block 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			      dec   HL 
9119			 
9119			      ld    (IX+0), E               ; Save ptr to next free block 
9119			      ld    (IX+1), D 
9119			      ld    (IX+2), L               ; Save ptr to prev free block 
9119			      ld    (IX+3), H 
9119			 
9119			      ld    A, B                    ; Check if DE is greater than BC 
9119			      cp    D                       ; Compare MSB first 
9119			      jr    Z, $+4                  ; MSB the same, compare LSB 
9119			      jr    NC, free_find_higher_block_skip 
9119			      ld    A, C 
9119			      cp    E                       ; Then compare LSB 
9119			      jr    C, free_found_higher_block 
9119			 
9119			free_find_higher_block_skip: 
9119			      ld    A, D                    ; Reached the end of the free list? 
9119			      or    E 
9119			      jp    Z, free_done 
9119			 
9119			      ex    DE, HL 
9119			 
9119			      jr    free_find_higher_block 
9119			 
9119			free_found_higher_block: 
9119			      ; Insert freed block between prev and next free blocks 
9119			      ld    (HL), C                 ; Point prev free block to freed block 
9119			      inc   HL 
9119			      ld    (HL), B 
9119			 
9119			      ld    H, B                    ; Point freed block at next free block 
9119			      ld    L, C 
9119			      ld    (HL), E 
9119			      inc   HL 
9119			      ld    (HL), D 
9119			 
9119			      ; Check if the freed block is adjacent to the next free block 
9119			      inc   HL                      ; Load size of freed block into HL 
9119			      ld    E, (HL) 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			      ex    DE, HL 
9119			 
9119			      add   HL, BC                  ; Add addr of freed block and its size 
9119			 
9119			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9119			      ld    D, (IX+1) 
9119			 
9119			      or    A                       ; Clear the carry flag 
9119			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9119			      jr    NZ, free_check_adjacent_to_prev 
9119			 
9119			      ; Freed block is adjacent to next, merge into one bigger block 
9119			      ex    DE, HL                  ; Load next ptr from next block into DE 
9119			      ld    E, (HL) 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			      push  HL                      ; Save ptr to next block for later 
9119			 
9119			      ld    H, B                    ; Store ptr from next block into freed block 
9119			      ld    L, C 
9119			      ld    (HL), E 
9119			      inc   HL 
9119			      ld    (HL), D 
9119			 
9119			      pop   HL                      ; Restore ptr to next block 
9119			      inc   HL                      ; Load size of next block into DE 
9119			      ld    E, (HL) 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			      push  DE                      ; Save next block size for later 
9119			 
9119			      ld    H, B                    ; Load size of freed block into HL 
9119			      ld    L, C 
9119			      inc   HL 
9119			      inc   HL 
9119			      ld    E, (HL) 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			      ex    DE, HL 
9119			 
9119			      pop   DE                      ; Restore size of next block 
9119			      add   HL, DE                  ; Add sizes of both blocks 
9119			      ex    DE, HL 
9119			 
9119			      ld    H, B                    ; Store new bigger size into freed block 
9119			      ld    L, C 
9119			      inc   HL 
9119			      inc   HL 
9119			      ld    (HL), E 
9119			      inc   HL 
9119			      ld    (HL), D 
9119			 
9119			free_check_adjacent_to_prev: 
9119			      ; Check if the freed block is adjacent to the prev free block 
9119			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9119			      ld    H, (IX+3) 
9119			 
9119			      inc   HL                      ; Size of prev free block into DE 
9119			      inc   HL 
9119			      ld    E, (HL) 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			      dec   HL 
9119			      dec   HL 
9119			      dec   HL 
9119			 
9119			      add   HL, DE                  ; Add prev block addr and size 
9119			 
9119			      or    A                       ; Clear the carry flag 
9119			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9119			      jr    NZ, free_done 
9119			 
9119			      ; Freed block is adjacent to prev, merge into one bigger block 
9119			      ld    H, B                    ; Load next ptr from freed block into DE 
9119			      ld    L, C 
9119			      ld    E, (HL) 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			      push  HL                      ; Save freed block ptr for later 
9119			 
9119			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9119			      ld    H, (IX+3) 
9119			      ld    (HL), E 
9119			      inc   HL 
9119			      ld    (HL), D 
9119			 
9119			      pop   HL                      ; Restore freed block ptr 
9119			      inc   HL                      ; Load size of freed block into DE 
9119			      ld    E, (HL) 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			      push  DE                      ; Save freed block size for later 
9119			 
9119			      ld    L, (IX+2)               ; Load size of prev block into DE 
9119			      ld    H, (IX+3) 
9119			      inc   HL 
9119			      inc   HL 
9119			      ld    E, (HL) 
9119			      inc   HL 
9119			      ld    D, (HL) 
9119			 
9119			      pop   HL                      ; Add sizes of both blocks 
9119			      add   HL, DE 
9119			      ex    DE, HL 
9119			 
9119			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9119			      ld    H, (IX+3) 
9119			      inc   HL 
9119			      inc   HL 
9119			      ld    (HL), E 
9119			      inc   HL 
9119			      ld    (HL), D 
9119			 
9119			free_done: 
9119			      ld    HL, 4                   ; Clean up stack frame 
9119			      add   HL, SP 
9119			      ld    SP, HL 
9119			 
9119			free_early_exit: 
9119			      pop   IX 
9119			      pop   DE 
9119			      pop   BC 
9119			 
9119			      ret 
9119			 
9119			 
9119			;      .org 0x8000 
9119			; 
9119			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9119			 ;                 .dw   0 
9119			 
9119			endif 
9119			 
9119			 
9119			if MALLOC_4 
9119			 
9119			; My memory allocation code. Very very simple.... 
9119			; allocate space under 250 chars 
9119			 
9119			heap_init: 
9119				; init start of heap as zero 
9119				;  
9119			 
9119				ld hl, heap_start 
9119				ld a, 0 
9119				ld (hl), a      ; empty block 
9119				inc hl 
9119				ld a, 0 
9119				ld (hl), a      ; length of block 
9119				; write end of list 
9119				inc hl 
9119				ld a,(hl) 
9119				inc hl 
9119				ld a,(hl) 
9119				 
9119			 
9119				; init some malloc vars 
9119			 
9119				ld hl, 0 
9119				ld (free_list), hl       ; store last malloc location 
9119			 
9119				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9119				ld a, 0 
9119				ld (hl), a 
9119			 
9119			 
9119				ld hl, heap_start 
9119				;  
9119				  
9119				ret 
9119			 
9119			 
9119			;    free block marker 
9119			;    requested size  
9119			;    pointer to next block 
9119			;    .... 
9119			;    next block marker 
9119			 
9119			 
9119			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9119			; 
9119			 
9119			 
9119			malloc:  
9119				push de 
9119				push bc 
9119				push af 
9119			 
9119				; hl space required 
9119				 
9119				ld c, l    ; hold space   (TODO only a max of 255) 
9119			 
9119			;	inc c     ; TODO BUG need to fix memory leak on push str 
9119			;	inc c 
9119			;	inc c 
9119			;	inc c 
9119			;	inc c 
9119			;	inc c 
9119			;	inc c 
9119			 
9119			 
9119			 
9119				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9119			 
9119				ld a, (free_list+3) 
9119				cp 0 
9119				jr z, .contheap 
9119			 
9119				ld hl, (free_list)     ; get last alloc 
9119					if DEBUG_FORTH_MALLOC_INT 
9119						DMARK "mrs" 
9119						CALLMONITOR 
9119					endif 
9119				jr .startalloc 
9119			 
9119			.contheap: 
9119				ld hl, heap_start 
9119			 
9119			.startalloc: 
9119			 
9119					if DEBUG_FORTH_MALLOC_INT 
9119						DMARK "mym" 
9119						CALLMONITOR 
9119					endif 
9119			.findblock: 
9119					if DEBUG_FORTH_MALLOC_INT 
9119						DMARK "mmf" 
9119						CALLMONITOR 
9119					endif 
9119			 
9119				ld a,(hl)  
9119				; if byte is zero then clear to use 
9119			 
9119				cp 0 
9119				jr z, .foundemptyblock 
9119			 
9119				; if byte is not clear 
9119				;     then byte is offset to next block 
9119			 
9119				inc hl 
9119				ld a, (hl) ; get size 
9119			.nextblock:	inc hl 
9119					ld e, (hl) 
9119					inc hl 
9119					ld d, (hl) 
9119					ex de, hl 
9119			;	inc hl  ; move past the store space 
9119			;	inc hl  ; move past zero index  
9119			 
9119				; TODO detect no more space 
9119			 
9119				push hl 
9119				ld de, heap_end 
9119				call cmp16 
9119				pop hl 
9119				jr nc, .nospace 
9119			 
9119				jr .findblock 
9119			 
9119			.nospace: ld hl, 0 
9119				jp .exit 
9119			 
9119			 
9119			.foundemptyblock:	 
9119					if DEBUG_FORTH_MALLOC_INT 
9119						DMARK "mme" 
9119						CALLMONITOR 
9119					endif 
9119			 
9119			; TODO has block enough space if reusing??? 
9119			 
9119				;  
9119			 
9119			; see if this block has been previously used 
9119				inc hl 
9119				ld a, (hl) 
9119				dec hl 
9119				cp 0 
9119				jr z, .newblock 
9119			 
9119					if DEBUG_FORTH_MALLOC_INT 
9119						DMARK "meR" 
9119						CALLMONITOR 
9119					endif 
9119			 
9119			; no reusing previously allocated block 
9119			 
9119			; is it smaller than previously used? 
9119				 
9119				inc hl    ; move to size 
9119				ld a, c 
9119				sub (hl)        ; we want c < (hl) 
9119				dec hl    ; move back to marker 
9119			        jr z, .findblock 
9119			 
9119				; update with the new size which should be lower 
9119			 
9119			        ;inc  hl   ; negate next move. move back to size  
9119			 
9119			.newblock: 
9119				; need to be at marker here 
9119			 
9119					if DEBUG_FORTH_MALLOC_INT 
9119						DMARK "meN" 
9119						CALLMONITOR 
9119					endif 
9119			 
9119			 
9119				ld a, c 
9119			 
9119				ld (free_list+3), a	 ; flag resume from last malloc  
9119				ld (free_list), hl    ; save out last location 
9119			 
9119			 
9119				;inc a     ; space for length byte 
9119				ld (hl), a     ; save block in use marker 
9119			 
9119				inc hl   ; move to space marker 
9119				ld (hl), a    ; save new space 
9119			 
9119				inc hl   ; move to start of allocated area 
9119				 
9119			;	push hl     ; save where we are - 1  
9119			 
9119			;	inc hl  ; move past zero index  
9119				; skip space to set down new marker 
9119			 
9119				; provide some extra space for now 
9119			 
9119				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9119				inc a 
9119				inc a 
9119			 
9119				push hl   ; save where we are in the node block 
9119			 
9119				call addatohl 
9119			 
9119				; write linked list point 
9119			 
9119				pop de     ; get our node position 
9119				ex de, hl 
9119			 
9119				ld (hl), e 
9119				inc hl 
9119				ld (hl), d 
9119			 
9119				inc hl 
9119			 
9119				; now at start of allocated data so save pointer 
9119			 
9119				push hl 
9119			 
9119				; jump to position of next node and setup empty header in DE 
9119			 
9119				ex de, hl 
9119			 
9119			;	inc hl ; move past end of block 
9119			 
9119				ld a, 0 
9119				ld (hl), a   ; empty marker 
9119				inc hl 
9119				ld (hl), a   ; size 
9119				inc hl  
9119				ld (hl), a   ; ptr 
9119				inc hl 
9119				ld (hl), a   ; ptr 
9119			 
9119			 
9119				pop hl 
9119			 
9119					if DEBUG_FORTH_MALLOC_INT 
9119						DMARK "mmr" 
9119						CALLMONITOR 
9119					endif 
9119			 
9119			.exit: 
9119				pop af 
9119				pop bc 
9119				pop de  
9119				ret 
9119			 
9119			 
9119			 
9119			 
9119			free:  
9119				push hl 
9119				push af 
9119				; get address in hl 
9119			 
9119					if DEBUG_FORTH_MALLOC_INT 
9119						DMARK "fre" 
9119						CALLMONITOR 
9119					endif 
9119				; data is at hl - move to block count 
9119				dec hl 
9119				dec hl    ; get past pointer 
9119				dec hl 
9119			 
9119				ld a, (hl)    ; need this for a validation check 
9119			 
9119				dec hl    ; move to block marker 
9119			 
9119				; now check that the block count and block marker are the same  
9119			        ; this checks that we are on a malloc node and not random memory 
9119			        ; OK a faint chance this could be a problem but rare - famous last words! 
9119			 
9119				ld c, a 
9119				ld a, (hl)    
9119			 
9119				cp c 
9119				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9119			 
9119				; yes good chance we are on a malloc node 
9119			 
9119				ld a, 0      
9119				ld (hl), a   ; mark as free 
9119			 
9119				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9119			 
9119			.freeignore:  
9119			 
9119				pop af 
9119				pop hl 
9119			 
9119				ret 
9119			 
9119			 
9119			 
9119			endif 
9119			 
9119			; eof 
# End of file firmware_memory.asm
9119			  
9119			; device C  
9119			if SOUND_ENABLE  
9119				include "firmware_sound.asm"  
9119			endif  
9119			  
9119			include "firmware_diags.asm"  
9119			; Hardware diags menu 
9119			 
9119			 
9119			config: 
9119			 
9119 3e 00			ld a, 0 
911b 21 49 91			ld hl, .configmn 
911e cd bd 88			call menu 
9121			 
9121 fe 00			cp 0 
9123 c8				ret z 
9124			 
9124 fe 01			cp 1 
9126 cc 08 92			call z, .savetostore 
9129			 
9129 fe 02			cp 2 
912b cc f4 91			call z, .selautoload 
912e fe 03			cp 3 
9130 cc ea 91			call z, .disautoload 
9133 fe 04			cp 4 
9135 cc fe 91			call z, .selbank 
9138 fe 05			cp 5 
913a cc 29 92			call z, .debug_tog 
913d fe 06			cp 6 
913f cc 6c 93			call z, .bpsgo 
9142 fe 07			cp 7 
9144 cc 4f 92			call z, hardware_diags 
9147			 
9147 18 d0			jr config 
9149			 
9149			.configmn: 
9149 59 91			dw .c3 
914b 70 91			dw .c2 
914d 85 91			dw .c2a 
914f 9b 91			dw .c2b 
9151			;	dw .c4 
9151 b8 91			dw .m4 
9153 d3 91			dw .m4b 
9155 db 91			dw .c1 
9157 00 00			dw 0 
9159				 
9159			 
9159 .. 00		.c3: db "Add Dictionary To File",0 
9170 .. 00		.c2: db "Select Autoload File",0 
9185 .. 00		.c2a: db "Disable Autoload File", 0 
919b .. 00		.c2b: db "Select Storage Bank",0 
91af .. 00		.c4: db "Settings",0 
91b8 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
91d3 .. 00		.m4b:   db "Monitor",0 
91db .. 00		.c1: db "Hardware Diags",0 
91ea			 
91ea			 
91ea			.disautoload: 
91ea				if STORAGE_SE 
91ea				ld a, $fe      ; bit 0 clear 
91ea				ld (spi_device), a 
91ea			 
91ea				call storage_get_block_0 
91ea			 
91ea				ld a, 0 
91ea				ld (store_page+STORE_0_AUTOFILE), a 
91ea			 
91ea					ld hl, 0 
91ea					ld de, store_page 
91ea				call storage_write_block	 ; save update 
91ea				else 
91ea			 
91ea 21 12 92			ld hl, .notav 
91ed 11 28 92			ld de, .empty 
91f0 cd 1d 88			call info_panel 
91f3				endif 
91f3			 
91f3			 
91f3 c9				ret 
91f4			 
91f4			 
91f4			 
91f4			; Select auto start 
91f4			 
91f4			.selautoload: 
91f4			 
91f4				 
91f4				if STORAGE_SE 
91f4			 
91f4					call config_dir 
91f4				        ld hl, scratch 
91f4					ld a, 0 
91f4					call menu 
91f4			 
91f4					cp 0 
91f4					ret z 
91f4			 
91f4					dec a 
91f4			 
91f4			 
91f4					; locate menu option 
91f4			 
91f4					ld hl, scratch 
91f4					call table_lookup 
91f4			 
91f4					if DEBUG_FORTH_WORDS 
91f4						DMARK "ALl" 
91f4						CALLMONITOR 
91f4					endif 
91f4					; with the pointer to the menu it, the byte following the zero term is the file id 
91f4			 
91f4					ld a, 0 
91f4					ld bc, 50   ; max of bytes to look at 
91f4					cpir  
91f4			 
91f4					if DEBUG_FORTH_WORDS 
91f4						DMARK "ALb" 
91f4						CALLMONITOR 
91f4					endif 
91f4					;inc hl 
91f4			 
91f4					ld a, (hl)   ; file id 
91f4					 
91f4				        ; save bank and file ids 
91f4			 
91f4					push af 
91f4			 
91f4			; TODO need to save to block 0 on bank 1	 
91f4			 
91f4					call storage_get_block_0 
91f4			 
91f4					if DEBUG_FORTH_WORDS 
91f4						DMARK "AL0" 
91f4						CALLMONITOR 
91f4					endif 
91f4					pop af 
91f4			 
91f4					ld (store_page+STORE_0_FILERUN),a 
91f4					 
91f4					; save bank id 
91f4			 
91f4					ld a,(spi_device) 
91f4					ld (store_page+STORE_0_BANKRUN),a 
91f4			 
91f4					; enable auto run of store file 
91f4			 
91f4					ld a, 1 
91f4					ld (store_page+STORE_0_AUTOFILE),a 
91f4			 
91f4					; save buffer 
91f4			 
91f4					ld hl, 0 
91f4					ld de, store_page 
91f4					if DEBUG_FORTH_WORDS 
91f4						DMARK "ALw" 
91f4						CALLMONITOR 
91f4					endif 
91f4				call storage_write_block	 ; save update 
91f4			  
91f4			 
91f4			 
91f4			 
91f4					ld hl, scratch 
91f4					call config_fdir 
91f4			 
91f4				else 
91f4			 
91f4 21 12 92			ld hl, .notav 
91f7 11 28 92			ld de, .empty 
91fa cd 1d 88			call info_panel 
91fd			 
91fd				endif 
91fd c9				ret 
91fe			 
91fe			 
91fe			 
91fe			; Select storage bank 
91fe			 
91fe			.selbank: 
91fe			 
91fe				if STORAGE_SE 
91fe				else 
91fe			 
91fe 21 12 92			ld hl, .notav 
9201 11 28 92			ld de, .empty 
9204 cd 1d 88			call info_panel 
9207				endif 
9207				 
9207 c9				ret 
9208			 
9208			if STORAGE_SE 
9208			 
9208			.config_ldir:   
9208				; Load storage bank labels into menu array 
9208			 
9208				 
9208			 
9208			 
9208				ret 
9208			 
9208			 
9208			endif 
9208			 
9208			 
9208			; Save user words to storage 
9208			 
9208			.savetostore: 
9208			 
9208				if STORAGE_SE 
9208			 
9208					call config_dir 
9208				        ld hl, scratch 
9208					ld a, 0 
9208					call menu 
9208					 
9208					ld hl, scratch 
9208					call config_fdir 
9208			 
9208				else 
9208			 
9208 21 12 92			ld hl, .notav 
920b 11 28 92			ld de, .empty 
920e cd 1d 88			call info_panel 
9211			 
9211				endif 
9211			 
9211 c9				ret 
9212 .. 00		.notav:    db "Feature not available",0 
9228 .. 00		.empty:    db "",0 
9229			 
9229			 
9229			 
9229			if STORAGE_SE 
9229			 
9229			config_fdir: 
9229				; using the scratch dir go through and release the memory allocated for each string 
9229				 
9229				ld hl, scratch 
9229			.cfdir:	ld e,(hl) 
9229				inc hl 
9229				ld d,(hl) 
9229				inc hl 
9229			 
9229				ex de, hl 
9229				call ishlzero 
9229				ret z     ; return on null pointer 
9229				call free 
9229				ex de, hl 
9229				jr .cfdir 
9229			 
9229			 
9229				ret 
9229			 
9229			 
9229			config_dir: 
9229			 
9229				; for the config menus that need to build a directory of storage call this routine 
9229				; it will construct a menu in scratch to pass to menu 
9229			 
9229				; open storage device 
9229			 
9229				; execute DIR to build a list of files and their ids into scratch in menu format 
9229				; once the menu has finished then will need to call config_fdir to release the strings 
9229				 
9229				; c = number items 
9229			 
9229				 
9229				call storage_get_block_0 
9229			 
9229				ld hl, store_page     ; get current id count 
9229				ld b, (hl) 
9229				ld c, 0    ; count of files   
9229			 
9229			 
9229				ld hl, scratch 
9229				ld (store_tmp2), hl    ; location to poke strings 
9229			 
9229				; check for empty drive 
9229			 
9229				ld a, 0 
9229				cp b 
9229				jp z, .dirdone 
9229			 
9229				 
9229					if DEBUG_FORTH_WORDS 
9229						DMARK "Cdc" 
9229						CALLMONITOR 
9229					endif 
9229			 
9229			 
9229			.diritem:	 
9229				push bc 
9229				; for each of the current ids do a search for them and if found push to stack 
9229			 
9229					ld hl, STORE_BLOCK_PHY 
9229					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9229					ld e,b 
9229			 
9229					call storage_findnextid 
9229			 
9229			 
9229					; if found hl will be non zero 
9229			 
9229					call ishlzero 
9229					jr z, .dirnotfound 
9229			 
9229					; increase count 
9229			 
9229					pop bc	 
9229					inc c 
9229					push bc 
9229					 
9229			 
9229					; get file header and push the file name 
9229			 
9229					ld de, store_page 
9229					call storage_read_block 
9229			 
9229					; push file id to stack 
9229				 
9229					ld a, (store_page) 
9229					ld h, 0 
9229					ld l, a 
9229			 
9229					;call forth_push_numhl 
9229					; TODO store id 
9229			 
9229					push hl 
9229			 
9229					; push extent count to stack  
9229				 
9229					ld hl, store_page+3 
9229			 
9229					; get file name length 
9229			 
9229					call strlenz   
9229			 
9229					inc hl   ; cover zero term 
9229					inc hl  ; stick the id at the end of the area 
9229			 
9229					push hl 
9229					pop bc    ; move length to bc 
9229			 
9229					call malloc 
9229			 
9229					; TODO save malloc area to scratch 
9229			 
9229					ex de, hl 
9229					ld hl, (store_tmp2) 
9229					ld (hl), e 
9229					inc hl 
9229					ld (hl), d 
9229					inc hl 
9229					ld (store_tmp2), hl 
9229			 
9229					 
9229			 
9229					;pop hl   ; get source 
9229			;		ex de, hl    ; swap aronund	 
9229			 
9229					ld hl, store_page+3 
9229					if DEBUG_FORTH_WORDS 
9229						DMARK "CFd" 
9229						CALLMONITOR 
9229					endif 
9229					ldir 
9229			 
9229					; de is past string, move back one and store id 
9229					 
9229					dec de 
9229			 
9229					; store file id 
9229			 
9229					pop hl 
9229					ex de,hl 
9229					ld (hl), e 
9229			 
9229					if DEBUG_FORTH_WORDS 
9229						DMARK "Cdi" 
9229						CALLMONITOR 
9229					endif 
9229					 
9229			.dirnotfound: 
9229					pop bc     
9229					djnz .diritem 
9229				 
9229			.dirdone:	 
9229			 
9229					ld a, 0 
9229					ld hl, (store_tmp2) 
9229					ld (hl), a 
9229					inc hl 
9229					ld (hl), a 
9229					inc hl 
9229					; push a count of the dir items found 
9229			 
9229			;		ld h, 0 
9229			;		ld l, c 
9229			 
9229				ret 
9229			 
9229			endif 
9229			 
9229			 
9229			; Settings 
9229			; Run  
9229			 
9229			 
9229			 
9229			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9229			;;hd_menu2:   db "        2: Editor",0   
9229			;hd_menu2:   db "        2: Editor       6: Menu",0   
9229			;hd_menu3:   db "        3: Storage",0 
9229			;hd_menu4:   db "0=quit  4: Debug",0 
9229			;hd_don:     db "ON",0 
9229			;hd_doff:     db "OFF",0 
9229			; 
9229			; 
9229			; 
9229			;hardware_diags_old:       
9229			; 
9229			;.diagmenu: 
9229			;	call clear_display 
9229			;	ld a, display_row_1 
9229			;	ld de, hd_menu1 
9229			;	call str_at_display 
9229			; 
9229			;	ld a, display_row_2 
9229			;	ld de, hd_menu2 
9229			;	call str_at_display 
9229			; 
9229			;	ld a, display_row_3 
9229			;	ld de, hd_menu3 
9229			;	call str_at_display 
9229			; 
9229			;	ld a,  display_row_4 
9229			;	ld de, hd_menu4 
9229			;	call str_at_display 
9229			; 
9229			;	; display debug state 
9229			; 
9229			;	ld de, hd_don 
9229			;	ld a, (os_view_disable) 
9229			;	cp 0 
9229			;	jr z, .distog 
9229			;	ld de, hd_doff 
9229			;.distog: ld a, display_row_4+17 
9229			;	call str_at_display 
9229			; 
9229			;	call update_display 
9229			; 
9229			;	call cin_wait 
9229			; 
9229			; 
9229			; 
9229			;	cp '4' 
9229			;	jr nz, .diagn1 
9229			; 
9229			;	; debug toggle 
9229			; 
9229			;	ld a, (os_view_disable) 
9229			;	ld b, '*' 
9229			;	cp 0 
9229			;	jr z, .debtog 
9229			;	ld b, 0 
9229			;.debtog:	 
9229			;	ld a,b 
9229			;	ld (os_view_disable),a 
9229			; 
9229			;.diagn1: cp '0' 
9229			;	 ret z 
9229			; 
9229			;;	cp '1' 
9229			;;       jp z, matrix	 
9229			;;   TODO keyboard matrix test 
9229			; 
9229			;	cp '2' 
9229			;	jp z, .diagedit 
9229			; 
9229			;;	cp '6' 
9229			;;	jp z, .menutest 
9229			;;if ENABLE_BASIC 
9229			;;	cp '6' 
9229			;;	jp z, basic 
9229			;;endif 
9229			 ; 
9229			;	jp .diagmenu 
9229			; 
9229			; 
9229			;	ret 
9229			 
9229			 
9229			.debug_tog: 
9229 21 70 92			ld hl, .menudebug 
922c				 
922c 3a ce e4			ld a, (os_view_disable) 
922f fe 2a			cp '*' 
9231 20 04			jr nz,.tdon  
9233 3e 01			ld a, 1 
9235 18 02			jr .tog1 
9237 3e 00		.tdon: ld a, 0 
9239			 
9239			.tog1: 
9239 cd bd 88			call menu 
923c fe 00			cp 0 
923e c8				ret z 
923f fe 01			cp 1    ; disable debug 
9241 28 04			jr z, .dtog0 
9243 3e 2a			ld a, '*' 
9245 18 02			jr .dtogset 
9247 3e 00		.dtog0: ld a, 0 
9249 32 ce e4		.dtogset:  ld (os_view_disable), a 
924c c3 29 92			jp .debug_tog 
924f			 
924f			 
924f			hardware_diags:       
924f			 
924f			.diagm: 
924f 21 62 92			ld hl, .menuitems 
9252 3e 00			ld a, 0 
9254 cd bd 88			call menu 
9257			 
9257 fe 00		         cp 0 
9259 c8				 ret z 
925a			 
925a fe 02			cp 2 
925c ca bb 92			jp z, .diagedit 
925f			 
925f			;	cp '6' 
925f			;	jp z, .menutest 
925f			;if ENABLE_BASIC 
925f			;	cp '6' 
925f			;	jp z, basic 
925f			;endif 
925f			  
925f c3 4f 92			jp .diagm 
9262			 
9262				 
9262 76 92		.menuitems:   	dw .m1 
9264 81 92				dw .m2 
9266 88 92				dw .m3 
9268 90 92				dw .m5 
926a 96 92				dw .m5a 
926c 9f 92				dw .m5b 
926e 00 00				dw 0 
9270			 
9270			.menudebug: 
9270 a8 92				dw .m6 
9272 b1 92				dw .m7 
9274 00 00				dw 0 
9276			 
9276 .. 00		.m1:   db "Key Matrix",0 
9281 .. 00		.m2:   db "Editor",0 
9288 .. 00		.m3:   db "Storage",0 
9290 .. 00		.m5:   db "Sound",0 
9296 .. 00		.m5a:  db "RAM Test",0 
929f .. 00		.m5b:  db "LCD Test",0 
92a8			 
92a8 .. 00		.m6:   db "Debug ON",0 
92b1 .. 00		.m7:   db "Debug OFF",0 
92bb			 
92bb			; debug editor 
92bb			 
92bb			.diagedit: 
92bb			 
92bb 21 dd e4			ld hl, scratch 
92be			;	ld bc, 250 
92be			;	ldir 
92be				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
92be 3e 00			ld a, 0 
92c0 77				ld (hl), a 
92c1 23				inc hl 
92c2 77				ld (hl), a 
92c3 23				inc hl 
92c4 77				ld (hl), a 
92c5			 
92c5 cd 8c 88		        call clear_display 
92c8 cd af 88			call update_display 
92cb				;ld a, 1 
92cb				;ld (hardware_diag), a 
92cb			.diloop: 
92cb 3e 00			ld a, display_row_1 
92cd 0e 00			ld c, 0 
92cf 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
92d1 1e 28			ld e, 40 
92d3			 
92d3 21 dd e4			ld hl, scratch	 
92d6 cd e6 8a			call input_str 
92d9			 
92d9 3e 14			ld a, display_row_2 
92db 11 dd e4			ld de, scratch 
92de cd 9f 88			call str_at_display 
92e1 cd af 88			call update_display 
92e4			 
92e4 c3 cb 92			jp .diloop 
92e7			 
92e7			 
92e7			; pass word in hl 
92e7			; a has display location 
92e7			display_word_at: 
92e7 f5				push af 
92e8 e5				push hl 
92e9 7c				ld a,h 
92ea 21 e2 e7			ld hl, os_word_scratch 
92ed cd ba 8d			call hexout 
92f0 e1				pop hl 
92f1 7d				ld a,l 
92f2 21 e4 e7			ld hl, os_word_scratch+2 
92f5 cd ba 8d			call hexout 
92f8 21 e6 e7			ld hl, os_word_scratch+4 
92fb 3e 00			ld a,0 
92fd 77				ld (hl),a 
92fe 11 e2 e7			ld de,os_word_scratch 
9301 f1				pop af 
9302 cd 9f 88				call str_at_display 
9305 c9				ret 
9306			 
9306			display_ptr_state: 
9306			 
9306				; to restore afterwards 
9306			 
9306 d5				push de 
9307 c5				push bc 
9308 e5				push hl 
9309 f5				push af 
930a			 
930a				; for use in here 
930a			 
930a			;	push bc 
930a			;	push de 
930a			;	push hl 
930a			;	push af 
930a			 
930a cd 8c 88			call clear_display 
930d			 
930d 11 e0 94			ld de, .ptrstate 
9310 3e 00			ld a, display_row_1 
9312 cd 9f 88			call str_at_display 
9315			 
9315				; display debug step 
9315			 
9315			 
9315 11 b7 ee			ld de, debug_mark 
9318 3e 12			ld a, display_row_1+display_cols-2 
931a cd 9f 88			call str_at_display 
931d			 
931d				; display a 
931d 11 ea 94			ld de, .ptrcliptr 
9320 3e 14			ld a, display_row_2 
9322 cd 9f 88			call str_at_display 
9325			 
9325 f1				pop af 
9326 2a a8 ec			ld hl,(cli_ptr) 
9329 3e 1c			ld a, display_row_2+8 
932b cd e7 92			call display_word_at 
932e			 
932e			 
932e				; display hl 
932e			 
932e			 
932e 11 f2 94			ld de, .ptrclioptr 
9331 3e 1e			ld a, display_row_2+10 
9333 cd 9f 88			call str_at_display 
9336			; 
9336			;	pop hl 
9336 3e 21			ld a, display_row_2+13 
9338 2a a6 ec			ld hl,(cli_origptr) 
933b cd e7 92			call display_word_at 
933e			; 
933e			;	 
933e			;	; display de 
933e			 
933e			;	ld de, .regstatede 
933e			;	ld a, display_row_3 
933e			;	call str_at_display 
933e			 
933e			;	pop de 
933e			;	ld h,d 
933e			;	ld l, e 
933e			;	ld a, display_row_3+3 
933e			;	call display_word_at 
933e			 
933e			 
933e				; display bc 
933e			 
933e			;	ld de, .regstatebc 
933e			;	ld a, display_row_3+10 
933e			;	call str_at_display 
933e			 
933e			;	pop bc 
933e			;	ld h,b 
933e			;	ld l, c 
933e			;	ld a, display_row_3+13 
933e			;	call display_word_at 
933e			 
933e			 
933e				; display dsp 
933e			 
933e			;	ld de, .regstatedsp 
933e			;	ld a, display_row_4 
933e			;	call str_at_display 
933e			 
933e				 
933e			;	ld hl,(cli_data_sp) 
933e			;	ld a, display_row_4+4 
933e			;	call display_word_at 
933e			 
933e				; display rsp 
933e			 
933e 11 21 95			ld de, .regstatersp 
9341 3e 46			ld a, display_row_4+10 
9343 cd 9f 88			call str_at_display 
9346			 
9346				 
9346 2a 8e ec			ld hl,(cli_ret_sp) 
9349 3e 4a			ld a, display_row_4+14 
934b cd e7 92			call display_word_at 
934e			 
934e cd af 88			call update_display 
9351			 
9351 cd 09 88			call delay1s 
9354 cd 09 88			call delay1s 
9357 cd 09 88			call delay1s 
935a			 
935a			 
935a cd 67 98			call next_page_prompt 
935d			 
935d				; restore  
935d			 
935d f1				pop af 
935e e1				pop hl 
935f c1				pop bc 
9360 d1				pop de 
9361 c9				ret 
9362			 
9362			break_point_state: 
9362 f5				push af 
9363			 
9363				; see if disabled 
9363			 
9363 3a ce e4			ld a, (os_view_disable) 
9366 fe 2a			cp '*' 
9368 20 02			jr nz, .bpsgo 
936a f1				pop af 
936b c9				ret 
936c			 
936c			.bpsgo: 
936c f1				pop af 
936d f5				push af 
936e 22 ca e4			ld (os_view_hl), hl 
9371 ed 53 c8 e4		ld (os_view_de), de 
9375 ed 43 c6 e4		ld (os_view_bc), bc 
9379 e5				push hl 
937a 6f				ld l, a 
937b 26 00			ld h, 0 
937d 22 cc e4			ld (os_view_af),hl 
9380			 
9380 21 4d ee				ld hl, display_fb0 
9383 22 58 ed				ld (display_fb_active), hl 
9386 e1				pop hl	 
9387			 
9387 3e 31			ld a, '1' 
9389 fe 2a		.bps1:  cp '*' 
938b 20 03			jr nz, .bps1b 
938d 32 ce e4			ld (os_view_disable),a 
9390 fe 31		.bps1b:  cp '1' 
9392 20 14			jr nz, .bps2 
9394			 
9394				; display reg 
9394			 
9394				 
9394			 
9394 3a cc e4			ld a, (os_view_af) 
9397 2a ca e4			ld hl, (os_view_hl) 
939a ed 5b c8 e4		ld de, (os_view_de) 
939e ed 4b c6 e4		ld bc, (os_view_bc) 
93a2 cd 3c 94			call display_reg_state 
93a5 c3 28 94			jp .bpschk 
93a8			 
93a8 fe 32		.bps2:  cp '2' 
93aa 20 08			jr nz, .bps3 
93ac				 
93ac				; display hl 
93ac 2a ca e4			ld hl, (os_view_hl) 
93af cd 26 95			call display_dump_at_hl 
93b2			 
93b2 18 74			jr .bpschk 
93b4			 
93b4 fe 33		.bps3:  cp '3' 
93b6 20 08			jr nz, .bps4 
93b8			 
93b8			        ; display de 
93b8 2a c8 e4			ld hl, (os_view_de) 
93bb cd 26 95			call display_dump_at_hl 
93be			 
93be 18 68			jr .bpschk 
93c0 fe 34		.bps4:  cp '4' 
93c2 20 08			jr nz, .bps5 
93c4			 
93c4			        ; display bc 
93c4 2a c6 e4			ld hl, (os_view_bc) 
93c7 cd 26 95			call display_dump_at_hl 
93ca			 
93ca 18 5c			jr .bpschk 
93cc fe 35		.bps5:  cp '5' 
93ce 20 08		        jr nz, .bps7 
93d0			 
93d0				; display cur ptr 
93d0 2a a8 ec			ld hl, (cli_ptr) 
93d3 cd 26 95			call display_dump_at_hl 
93d6			 
93d6 18 50			jr .bpschk 
93d8 fe 36		.bps7:  cp '6' 
93da 20 08			jr nz, .bps8b 
93dc				 
93dc				; display cur orig ptr 
93dc 2a a6 ec			ld hl, (cli_origptr) 
93df cd 26 95			call display_dump_at_hl 
93e2 18 44			jr .bpschk 
93e4 fe 37		.bps8b:  cp '7' 
93e6 20 08			jr nz, .bps9 
93e8				 
93e8				; display dsp 
93e8 2a 8a ec			ld hl, (cli_data_sp) 
93eb cd 26 95			call display_dump_at_hl 
93ee			 
93ee 18 38			jr .bpschk 
93f0 fe 39		.bps9:  cp '9' 
93f2 20 05			jr nz, .bps8c 
93f4				 
93f4				; display SP 
93f4			;	ld hl, sp 
93f4 cd 26 95			call display_dump_at_hl 
93f7			 
93f7 18 2f			jr .bpschk 
93f9 fe 38		.bps8c:  cp '8' 
93fb 20 08			jr nz, .bps8d 
93fd				 
93fd				; display rsp 
93fd 2a 8e ec			ld hl, (cli_ret_sp) 
9400 cd 26 95			call display_dump_at_hl 
9403			 
9403 18 23			jr .bpschk 
9405 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9407 20 05			jr nz, .bps8 
9409 cd 5d 96			call monitor 
940c			 
940c 18 1a			jr .bpschk 
940e fe 30		.bps8:  cp '0' 
9410 20 16			jr nz, .bpschk 
9412			 
9412 21 fc ed				ld hl, display_fb1 
9415 22 58 ed				ld (display_fb_active), hl 
9418 cd af 88				call update_display 
941b			 
941b				;ld a, (os_view_af) 
941b 2a ca e4			ld hl, (os_view_hl) 
941e ed 5b c8 e4		ld de, (os_view_de) 
9422 ed 4b c6 e4		ld bc, (os_view_bc) 
9426 f1				pop af 
9427 c9				ret 
9428			 
9428			.bpschk:   
9428 cd 09 88			call delay1s 
942b 3e 4f		ld a,display_row_4 + display_cols - 1 
942d 11 65 98		        ld de, endprg 
9430 cd 9f 88			call str_at_display 
9433 cd af 88			call update_display 
9436 cd c0 d7			call cin_wait 
9439			 
9439 c3 89 93			jp .bps1 
943c			 
943c			 
943c			display_reg_state: 
943c			 
943c				; to restore afterwards 
943c			 
943c d5				push de 
943d c5				push bc 
943e e5				push hl 
943f f5				push af 
9440			 
9440				; for use in here 
9440			 
9440 c5				push bc 
9441 d5				push de 
9442 e5				push hl 
9443 f5				push af 
9444			 
9444 cd 8c 88			call clear_display 
9447			 
9447 11 fc 94			ld de, .regstate 
944a 3e 00			ld a, display_row_1 
944c cd 9f 88			call str_at_display 
944f			 
944f				; display debug step 
944f			 
944f			 
944f 11 b7 ee			ld de, debug_mark 
9452 3e 11			ld a, display_row_1+display_cols-3 
9454 cd 9f 88			call str_at_display 
9457			 
9457				; display a 
9457 11 18 95			ld de, .regstatea 
945a 3e 14			ld a, display_row_2 
945c cd 9f 88			call str_at_display 
945f			 
945f e1				pop hl 
9460			;	ld h,0 
9460			;	ld l, a 
9460 3e 17			ld a, display_row_2+3 
9462 cd e7 92			call display_word_at 
9465			 
9465			 
9465				; display hl 
9465			 
9465			 
9465 11 0c 95			ld de, .regstatehl 
9468 3e 1e			ld a, display_row_2+10 
946a cd 9f 88			call str_at_display 
946d			 
946d e1				pop hl 
946e 3e 21			ld a, display_row_2+13 
9470 cd e7 92			call display_word_at 
9473			 
9473				 
9473				; display de 
9473			 
9473 11 10 95			ld de, .regstatede 
9476 3e 28			ld a, display_row_3 
9478 cd 9f 88			call str_at_display 
947b			 
947b e1				pop hl 
947c			;	ld h,d 
947c			;	ld l, e 
947c 3e 2b			ld a, display_row_3+3 
947e cd e7 92			call display_word_at 
9481			 
9481			 
9481				; display bc 
9481			 
9481 11 14 95			ld de, .regstatebc 
9484 3e 32			ld a, display_row_3+10 
9486 cd 9f 88			call str_at_display 
9489			 
9489 e1				pop hl 
948a			;	ld h,b 
948a			;	ld l, c 
948a 3e 35			ld a, display_row_3+13 
948c cd e7 92			call display_word_at 
948f			 
948f			 
948f				; display dsp 
948f			 
948f 11 1c 95			ld de, .regstatedsp 
9492 3e 3c			ld a, display_row_4 
9494 cd 9f 88			call str_at_display 
9497			 
9497				 
9497 2a 8a ec			ld hl,(cli_data_sp) 
949a 3e 40			ld a, display_row_4+4 
949c cd e7 92			call display_word_at 
949f			 
949f				; display rsp 
949f			 
949f 11 21 95			ld de, .regstatersp 
94a2 3e 46			ld a, display_row_4+10 
94a4 cd 9f 88			call str_at_display 
94a7			 
94a7				 
94a7 2a 8e ec			ld hl,(cli_ret_sp) 
94aa 3e 4a			ld a, display_row_4+14 
94ac cd e7 92			call display_word_at 
94af			 
94af cd af 88			call update_display 
94b2			 
94b2			;	call delay1s 
94b2			;	call delay1s 
94b2			;	call delay1s 
94b2			 
94b2			 
94b2			;	call next_page_prompt 
94b2			 
94b2				; restore  
94b2			 
94b2 f1				pop af 
94b3 e1				pop hl 
94b4 c1				pop bc 
94b5 d1				pop de 
94b6 c9				ret 
94b7			 
94b7 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
94cb .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
94e0 .. 00		.ptrstate:	db "Ptr State",0 
94ea .. 00		.ptrcliptr:     db "cli_ptr",0 
94f2 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
94fc .. 00		.regstate:	db "Reg State (1/0)",0 
950c .. 00		.regstatehl:	db "HL:",0 
9510 .. 00		.regstatede:	db "DE:",0 
9514 .. 00		.regstatebc:	db "BC:",0 
9518 .. 00		.regstatea:	db "A :",0 
951c .. 00		.regstatedsp:	db "DSP:",0 
9521 .. 00		.regstatersp:	db "RSP:",0 
9526			 
9526			display_dump_at_hl: 
9526 e5				push hl 
9527 d5				push de 
9528 c5				push bc 
9529 f5				push af 
952a			 
952a 22 00 e8			ld (os_cur_ptr),hl	 
952d cd 8c 88			call clear_display 
9530 cd 6f 97			call dumpcont 
9533			;	call delay1s 
9533			;	call next_page_prompt 
9533			 
9533			 
9533 f1				pop af 
9534 c1				pop bc 
9535 d1				pop de 
9536 e1				pop hl 
9537 c9				ret 
9538			 
9538			;if ENABLE_BASIC 
9538			;	include "nascombasic.asm" 
9538			;	basic: 
9538			;	include "forth/FORTH.ASM" 
9538			;endif 
9538			 
9538			; eof 
9538			 
9538			 
# End of file firmware_diags.asm
9538			  
9538			  
9538			  
9538			  
9538			; eof  
9538			  
# End of file firmware.asm
9538			 
9538			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9538			;if BASE_KEV  
9538			;baseram: equ 08000h 
9538			;endif 
9538			 
9538			;if BASE_SC114 
9538			;baseram:     equ    endofcode 
9538			;endif 
9538			 
9538			 
9538			; start system 
9538			 
9538			coldstart: 
9538				; set sp 
9538				; di/ei 
9538			 
9538 f3				di 
9539 31 00 f0			ld sp, tos 
953c			;	ei 
953c			 
953c			 
953c				; disable breakpoint by default 
953c			 
953c 3e 2a			ld a,'*' 
953e 32 ce e4			ld (os_view_disable),a 
9541			 
9541				; init hardware 
9541			 
9541				; init keyboard and screen hardware 
9541			 
9541 cd 03 80			call hardware_init 
9544			 
9544			 
9544				; detect if any keys are held down to enable breakpoints at start up 
9544			 
9544 cd c6 d7			call cin  
9547 fe 00			cp 0 
9549 28 03			jr z, .nokeys 
954b			 
954b				;call hardware_diags 
954b cd 19 91			call config 
954e			 
954e			;	ld de, .bpen 
954e			;	ld a, display_row_4 
954e			;	call str_at_display 
954e			;	call update_display 
954e			; 
954e			;	ld a,0 
954e			;	ld (os_view_disable),a 
954e			; 
954e			;.bpwait: 
954e			;	call cin 
954e			;	cp 0 
954e			;	jr z, .bpwait 
954e			;	jr .nokeys 
954e			; 
954e			; 
954e			;.bpen:  db "Break points enabled!",0 
954e			 
954e			 
954e			 
954e			 
954e			 
954e			 
954e			.nokeys: 
954e			 
954e			 
954e				 
954e			 
954e			;jp  testkey 
954e			 
954e			;call storage_get_block_0 
954e			; 
954e			;ld hl, 0 
954e			;ld de, store_page 
954e			;call storage_read_block 
954e			 
954e				 
954e			;ld hl, 10 
954e			;ld de, store_page 
954e			;call storage_read_block 
954e			 
954e			 
954e			 
954e			 
954e			 
954e			;stop:	nop 
954e			;	jp stop 
954e			 
954e			 
954e			 
954e			main: 
954e cd 8c 88			call clear_display 
9551 cd af 88			call update_display 
9554			 
9554			 
9554			 
9554			;	call testlcd 
9554			 
9554			 
9554			 
9554 cd 2d 9c			call forth_init 
9557			 
9557			 
9557			warmstart: 
9557 cd 03 9c			call forth_warmstart 
955a			 
955a				; run startup word load 
955a			        ; TODO prevent this running at warmstart after crash  
955a			 
955a				if STARTUP_ENABLE 
955a					if STORAGE_SE 
955a						call forth_autoload 
955a					endif 
955a cd 5a d4				call forth_startup 
955d			 
955d			 
955d				endif 
955d			 
955d				; show free memory after boot 
955d 11 f7 95			ld de, freeram 
9560 3e 00			ld a, display_row_1 
9562 cd 9f 88			call str_at_display 
9565			 
9565			; Or use heap_size word???? 
9565 21 c3 e4			ld hl, heap_end 
9568 11 e4 d7			ld de, heap_start 
956b ed 52			sbc hl, de 
956d e5				push hl 
956e 7c				ld a,h	         	 
956f 21 e2 e7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9572 cd ba 8d			call hexout 
9575 e1			   	pop hl 
9576			 
9576 7d				ld a,l 
9577 21 e4 e7			ld hl, os_word_scratch+2 
957a cd ba 8d			call hexout 
957d 21 e6 e7			ld hl, os_word_scratch+4 
9580 3e 00			ld a, 0 
9582 77				ld (hl),a 
9583 11 e2 e7			ld de, os_word_scratch 
9586 3e 0d			ld a, display_row_1 + 13 
9588 cd 9f 88			call str_at_display 
958b cd af 88			call update_display 
958e			 
958e			 
958e				;call demo 
958e			 
958e			 
958e				; init scratch input area for cli commands 
958e			 
958e 21 04 e8			ld hl, os_cli_cmd 
9591 3e 00			ld a,0 
9593 77				ld (hl),a 
9594 23				inc hl 
9595 77				ld (hl),a 
9596			 
9596 3e 00			ld a,0 
9598 32 03 e9			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
959b			 
959b 32 00 e8			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
959e 32 01 e8			ld (os_cur_ptr+1),a	 
95a1			 
95a1 32 e2 e7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
95a4 32 e3 e7			ld (os_word_scratch+1),a	 
95a7				 
95a7			 
95a7				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95a7 21 04 e8			ld hl, os_cli_cmd 
95aa			 
95aa 3e 00			ld a, 0		 ; init cli input 
95ac 77				ld (hl), a 
95ad 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95af			cli: 
95af				; show cli prompt 
95af				;push af 
95af				;ld a, 0 
95af				;ld de, prompt 
95af				;call str_at_display 
95af			 
95af				;call update_display 
95af				;pop af 
95af				;inc a 
95af				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
95af 0e 00			ld c, 0 
95b1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
95b3 1e 28			ld e, 40 
95b5			 
95b5 21 04 e8			ld hl, os_cli_cmd 
95b8			 
95b8				STACKFRAME OFF $fefe $9f9f 
95b8				if DEBUG_STACK_IMB 
95b8					if OFF 
95b8						exx 
95b8						ld de, $fefe 
95b8						ld a, d 
95b8						ld hl, curframe 
95b8						call hexout 
95b8						ld a, e 
95b8						ld hl, curframe+2 
95b8						call hexout 
95b8						ld hl, $fefe 
95b8						push hl 
95b8						ld hl, $9f9f 
95b8						push hl 
95b8						exx 
95b8					endif 
95b8				endif 
95b8			endm 
# End of macro STACKFRAME
95b8			 
95b8 cd e6 8a			call input_str 
95bb			 
95bb				STACKFRAMECHK OFF $fefe $9f9f 
95bb				if DEBUG_STACK_IMB 
95bb					if OFF 
95bb						exx 
95bb						ld hl, $9f9f 
95bb						pop de   ; $9f9f 
95bb						call cmp16 
95bb						jr nz, .spnosame 
95bb						ld hl, $fefe 
95bb						pop de   ; $fefe 
95bb						call cmp16 
95bb						jr z, .spfrsame 
95bb						.spnosame: call showsperror 
95bb						.spfrsame: nop 
95bb						exx 
95bb					endif 
95bb				endif 
95bb			endm 
# End of macro STACKFRAMECHK
95bb			 
95bb				; copy input to last command 
95bb			 
95bb 21 04 e8			ld hl, os_cli_cmd 
95be 11 03 e9			ld de, os_last_cmd 
95c1 01 ff 00			ld bc, 255 
95c4 ed b0			ldir 
95c6			 
95c6				; wipe current buffer 
95c6			 
95c6			;	ld a, 0 
95c6			;	ld hl, os_cli_cmd 
95c6			;	ld de, os_cli_cmd+1 
95c6			;	ld bc, 254 
95c6			;	ldir 
95c6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
95c6			;	call strcpy 
95c6			;	ld a, 0 
95c6			;	ld (hl), a 
95c6			;	inc hl 
95c6			;	ld (hl), a 
95c6			;	inc hl 
95c6			;	ld (hl), a 
95c6			 
95c6				; switch frame buffer to program  
95c6			 
95c6 21 fc ed				ld hl, display_fb1 
95c9 22 58 ed				ld (display_fb_active), hl 
95cc			 
95cc			;	nop 
95cc				STACKFRAME ON $fbfe $8f9f 
95cc				if DEBUG_STACK_IMB 
95cc					if ON 
95cc						exx 
95cc						ld de, $fbfe 
95cc						ld a, d 
95cc						ld hl, curframe 
95cc						call hexout 
95cc						ld a, e 
95cc						ld hl, curframe+2 
95cc						call hexout 
95cc						ld hl, $fbfe 
95cc						push hl 
95cc						ld hl, $8f9f 
95cc						push hl 
95cc						exx 
95cc					endif 
95cc				endif 
95cc			endm 
# End of macro STACKFRAME
95cc				; first time into the parser so pass over the current scratch pad 
95cc 21 04 e8			ld hl,os_cli_cmd 
95cf				; tokenise the entered statement(s) in HL 
95cf cd a6 9c			call forthparse 
95d2			        ; exec forth statements in top of return stack 
95d2 cd e6 9c			call forthexec 
95d5				;call forthexec_cleanup 
95d5			;	call parsenext 
95d5			 
95d5				STACKFRAMECHK ON $fbfe $8f9f 
95d5				if DEBUG_STACK_IMB 
95d5					if ON 
95d5						exx 
95d5						ld hl, $8f9f 
95d5						pop de   ; $8f9f 
95d5						call cmp16 
95d5						jr nz, .spnosame 
95d5						ld hl, $fbfe 
95d5						pop de   ; $fbfe 
95d5						call cmp16 
95d5						jr z, .spfrsame 
95d5						.spnosame: call showsperror 
95d5						.spfrsame: nop 
95d5						exx 
95d5					endif 
95d5				endif 
95d5			endm 
# End of macro STACKFRAMECHK
95d5				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
95d5			 
95d5 3e 3c			ld a, display_row_4 
95d7 11 09 96			ld de, endprog 
95da			 
95da cd af 88			call update_display		 
95dd			 
95dd cd 67 98			call next_page_prompt 
95e0			 
95e0				; switch frame buffer to cli 
95e0			 
95e0 21 4d ee				ld hl, display_fb0 
95e3 22 58 ed				ld (display_fb_active), hl 
95e6			 
95e6			 
95e6 cd 8c 88		        call clear_display 
95e9 cd af 88			call update_display		 
95ec			 
95ec 21 04 e8			ld hl, os_cli_cmd 
95ef			 
95ef 3e 00			ld a, 0		 ; init cli input 
95f1 77				ld (hl), a 
95f2			 
95f2				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
95f2			 
95f2				; now on last line 
95f2			 
95f2				; TODO scroll screen up 
95f2			 
95f2				; TODO instead just clear screen and place at top of screen 
95f2			 
95f2			;	ld a, 0 
95f2			;	ld (f_cursor_ptr),a 
95f2			 
95f2				;call clear_display 
95f2				;call update_display 
95f2			 
95f2				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95f2 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95f4 c3 af 95			jp cli 
95f7			 
95f7 .. 00		freeram: db "Free bytes: $",0 
9605 ..			asc: db "1A2F" 
9609 .. 00		endprog: db "End prog...",0 
9615			 
9615			testenter2:   
9615 21 0f e5			ld hl,scratch+50 
9618 22 00 e8			ld (os_cur_ptr),hl 
961b c3 af 95			jp cli 
961e			 
961e			testenter:  
961e			 
961e 21 05 96			ld hl,asc 
9621			;	ld a,(hl) 
9621			;	call nibble2val 
9621 cd 10 8e			call get_byte 
9624			 
9624			 
9624			;	ld a,(hl) 
9624			;	call atohex 
9624			 
9624			;	call fourehexhl 
9624 32 0f e5			ld (scratch+50),a 
9627			 
9627			 
9627			 
9627 21 07 96			ld hl,asc+2 
962a			;	ld a, (hl) 
962a			;	call nibble2val 
962a cd 10 8e			call get_byte 
962d			 
962d			;	call fourehexhl 
962d 32 11 e5			ld (scratch+52),a 
9630				 
9630 21 0f e5			ld hl,scratch+50 
9633 22 00 e8			ld (os_cur_ptr),hl 
9636 c3 af 95			jp cli 
9639			 
9639			enter:	 
9639 3a e1 e4			ld a,(scratch+4) 
963c fe 00			cp 0 
963e 28 0c			jr z, .entercont 
9640				; no, not a null term line so has an address to work out.... 
9640			 
9640 21 df e4			ld hl,scratch+2 
9643 cd 70 8e			call get_word_hl 
9646			 
9646 22 00 e8			ld (os_cur_ptr),hl	 
9649 c3 af 95			jp cli 
964c			 
964c			 
964c			.entercont:  
964c			 
964c 21 df e4			ld hl, scratch+2 
964f cd 10 8e			call get_byte 
9652			 
9652 2a 00 e8		   	ld hl,(os_cur_ptr) 
9655 77					ld (hl),a 
9656 23					inc hl 
9657 22 00 e8				ld (os_cur_ptr),hl 
965a				 
965a			; get byte  
965a			 
965a			 
965a c3 af 95			jp cli 
965d			 
965d			 
965d			; basic monitor support 
965d			 
965d			monitor: 
965d				;  
965d cd 8c 88			call clear_display 
9660 3e 00			ld a, 0 
9662 11 aa 96			ld de, .monprompt 
9665 cd 9f 88			call str_at_display 
9668 cd af 88			call update_display 
966b			 
966b				; get a monitor command 
966b			 
966b 0e 00			ld c, 0     ; entry at top left 
966d 16 64			ld d, 100   ; max buffer size 
966f 1e 0f			ld e, 15    ; input scroll area 
9671 3e 00			ld a, 0     ; init string 
9673 21 db e6			ld hl, os_input 
9676 77				ld (hl), a 
9677 23				inc hl 
9678 77				ld (hl), a 
9679 21 db e6			ld hl, os_input 
967c 3e 01			ld a, 1     ; init string 
967e cd e6 8a			call input_str 
9681			 
9681 cd 8c 88		        call clear_display 
9684 cd af 88			call update_display		 
9687			 
9687 3a db e6			ld a, (os_input) 
968a cd 0e 8f			call toUpper 
968d fe 48		        cp 'H' 
968f 28 6f		        jr z, .monhelp 
9691 fe 44			cp 'D'		; dump 
9693 ca 21 97			jp z, .mondump	 
9696 fe 43			cp 'C'		; dump 
9698 ca 3b 97			jp z, .moncdump	 
969b fe 4d			cp 'M'		; dump 
969d ca ac 96			jp z, .moneditstart 
96a0 fe 55			cp 'U'		; dump 
96a2 28 14			jr z, .monedit	 
96a4 fe 51			cp 'Q'		; dump 
96a6 c8				ret z	 
96a7			 
96a7			 
96a7				; TODO "S" to access symbol by name and not need the address 
96a7				; TODO "F" to find a string in memory 
96a7			 
96a7 c3 5d 96			jp monitor 
96aa			 
96aa .. 00		.monprompt: db ">", 0 
96ac			 
96ac			.moneditstart: 
96ac				; get starting address 
96ac			 
96ac 21 dd e6			ld hl,os_input+2 
96af cd 70 8e			call get_word_hl 
96b2			 
96b2 22 00 e8			ld (os_cur_ptr),hl	 
96b5			 
96b5 c3 5d 96			jp monitor 
96b8			 
96b8			.monedit: 
96b8				; get byte to load 
96b8			 
96b8 21 dd e6			ld hl,os_input+2 
96bb cd 10 8e			call get_byte 
96be			 
96be				; get address to update 
96be 2a 00 e8			ld hl, (os_cur_ptr) 
96c1			 
96c1				; update byte 
96c1			 
96c1 77				ld (hl), a 
96c2			 
96c2				; move to next address and save it 
96c2			 
96c2 23				inc hl 
96c3 22 00 e8			ld (os_cur_ptr),hl	 
96c6			 
96c6 c3 5d 96			jp monitor 
96c9			 
96c9			 
96c9 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
96dd .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
96f9 .. 00		.monhelptext3:  db "Q-Quit",0 
9700			        
9700			.monhelp: 
9700 3e 00			ld a, display_row_1 
9702 11 c9 96		        ld de, .monhelptext1 
9705			 
9705 cd 9f 88			call str_at_display 
9708 3e 14			ld a, display_row_2 
970a 11 dd 96		        ld de, .monhelptext2 
970d					 
970d cd 9f 88			call str_at_display 
9710 3e 28			ld a, display_row_3 
9712 11 f9 96		        ld de, .monhelptext3 
9715					 
9715 cd 9f 88			call str_at_display 
9718 cd af 88			call update_display		 
971b			 
971b cd 67 98			call next_page_prompt 
971e c3 5d 96			jp monitor 
9721			 
9721			.mondump:    
9721 21 dd e6			ld hl,os_input+2 
9724 cd 70 8e			call get_word_hl 
9727			 
9727 22 00 e8			ld (os_cur_ptr),hl	 
972a cd 6f 97			call dumpcont 
972d 3e 3c			ld a, display_row_4 
972f 11 09 96			ld de, endprog 
9732			 
9732 cd af 88			call update_display		 
9735			 
9735 cd 67 98			call next_page_prompt 
9738 c3 5d 96			jp monitor 
973b			.moncdump: 
973b cd 6f 97			call dumpcont 
973e 3e 3c			ld a, display_row_4 
9740 11 09 96			ld de, endprog 
9743			 
9743 cd af 88			call update_display		 
9746			 
9746 cd 67 98			call next_page_prompt 
9749 c3 5d 96			jp monitor 
974c			 
974c			 
974c			; TODO symbol access  
974c			 
974c			.symbols:     ;; A list of symbols that can be called up  
974c 4d ee			dw display_fb0 
974e .. 00			db "fb0",0  
9752 e2 ec		     	dw store_page 
9754 .. 00			db "store_page",0 
975f			 
975f			 
975f			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
975f			 
975f 3a de e4			ld a,(scratch+1) 
9762 fe 00			cp 0 
9764 28 09			jr z, dumpcont 
9766			 
9766				; no, not a null term line so has an address to work out.... 
9766			 
9766 21 df e4			ld hl,scratch+2 
9769 cd 70 8e			call get_word_hl 
976c			 
976c 22 00 e8			ld (os_cur_ptr),hl	 
976f			 
976f			 
976f			 
976f			dumpcont: 
976f			 
976f				; dump bytes at ptr 
976f			 
976f			 
976f 3e 00			ld a, display_row_1 
9771 2a 58 ed			ld hl, (display_fb_active) 
9774 cd b9 8a			call addatohl 
9777 cd 9f 97			call .dumpbyterow 
977a			 
977a 3e 14			ld a, display_row_2 
977c 2a 58 ed			ld hl, (display_fb_active) 
977f cd b9 8a			call addatohl 
9782 cd 9f 97			call .dumpbyterow 
9785			 
9785			 
9785 3e 28			ld a, display_row_3 
9787 2a 58 ed			ld hl, (display_fb_active) 
978a cd b9 8a			call addatohl 
978d cd 9f 97			call .dumpbyterow 
9790			 
9790 3e 3c			ld a, display_row_4 
9792 2a 58 ed			ld hl, (display_fb_active) 
9795 cd b9 8a			call addatohl 
9798 cd 9f 97			call .dumpbyterow 
979b			 
979b cd af 88			call update_display 
979e			;		jp cli 
979e c9				ret 
979f			 
979f			.dumpbyterow: 
979f			 
979f				;push af 
979f			 
979f e5				push hl 
97a0			 
97a0				; calc where to poke the ascii 
97a0			if display_cols == 20 
97a0 3e 10			ld a, 16 
97a2			else 
97a2				ld a, 31 
97a2			endif 
97a2			 
97a2 cd b9 8a			call addatohl 
97a5 22 e2 e7			ld (os_word_scratch),hl  		; save pos for later 
97a8			 
97a8			 
97a8			; display decoding address 
97a8 2a 00 e8		   	ld hl,(os_cur_ptr) 
97ab			 
97ab 7c				ld a,h 
97ac e1				pop hl 
97ad e5				push hl 
97ae			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97ae cd ba 8d			call hexout 
97b1 2a 00 e8		   	ld hl,(os_cur_ptr) 
97b4			 
97b4 7d				ld a,l 
97b5 e1				pop hl 
97b6 23				inc hl 
97b7 23				inc hl 
97b8 e5				push hl 
97b9			;	ld hl, os_word_scratch+2 
97b9 cd ba 8d			call hexout 
97bc e1				pop hl 
97bd 23				inc hl 
97be 23				inc hl 
97bf				;ld hl, os_word_scratch+4 
97bf 3e 3a			ld a, ':' 
97c1 77				ld (hl),a 
97c2 23				inc hl 
97c3				;ld a, 0 
97c3				;ld (hl),a 
97c3				;ld de, os_word_scratch 
97c3				;pop af 
97c3				;push af 
97c3			;		ld a, display_row_2 
97c3			;		call str_at_display 
97c3			;		call update_display 
97c3			 
97c3			 
97c3			;pop af 
97c3			;	add 5 
97c3			 
97c3			if display_cols == 20 
97c3 06 04			ld b, 4 
97c5			else 
97c5				ld b, 8 
97c5			endif	 
97c5			 
97c5			.dumpbyte: 
97c5 c5				push bc 
97c6 e5				push hl 
97c7			 
97c7			 
97c7 2a 00 e8		   	ld hl,(os_cur_ptr) 
97ca 7e					ld a,(hl) 
97cb			 
97cb					; poke the ascii to display 
97cb 2a e2 e7				ld hl,(os_word_scratch) 
97ce 77					ld (hl),a 
97cf 23					inc hl 
97d0 22 e2 e7				ld (os_word_scratch),hl 
97d3			 
97d3					 
97d3			 
97d3			 
97d3 e1					pop hl 
97d4 e5					push hl 
97d5			 
97d5 cd ba 8d				call hexout 
97d8			 
97d8					 
97d8 2a 00 e8		   	ld hl,(os_cur_ptr) 
97db 23				inc hl 
97dc 22 00 e8		   	ld (os_cur_ptr),hl 
97df			 
97df e1					pop hl 
97e0 23					inc hl 
97e1 23					inc hl 
97e2 23					inc hl 
97e3			 
97e3			 
97e3			 
97e3					;ld a,0 
97e3					;ld (os_word_scratch+2),a 
97e3					;pop af 
97e3					;push af 
97e3			 
97e3					;ld de, os_word_scratch 
97e3					;call str_at_display 
97e3			;		call update_display 
97e3			;		pop af 
97e3 c1					pop bc 
97e4 c6 03				add 3 
97e6 10 dd			djnz .dumpbyte 
97e8			 
97e8				 
97e8			 
97e8 c9				ret 
97e9			 
97e9			jump:	 
97e9			 
97e9 21 df e4			ld hl,scratch+2 
97ec cd 70 8e			call get_word_hl 
97ef				;ld hl,(scratch+2) 
97ef				;call fourehexhl 
97ef			 
97ef 22 00 e8			ld (os_cur_ptr),hl	 
97f2			 
97f2 e9				jp (hl) 
97f3			 
97f3			 
97f3			 
97f3			; TODO implement a basic monitor mode to start with 
97f3			 
97f3			 
97f3			 
97f3			 
97f3			 
97f3			 
97f3			 
97f3			 
97f3			 
97f3			; testing and demo code during development 
97f3			 
97f3			 
97f3 .. 00		str1: db "Enter some text...",0 
9806 .. 00		clear: db "                    ",0 
981b			 
981b			demo: 
981b			 
981b			 
981b			 
981b			;	call update_display 
981b			 
981b				; init scratch input area for testing 
981b 21 dd e4			ld hl, scratch	 
981e 3e 00			ld a,0 
9820 77				ld (hl),a 
9821			 
9821			 
9821 3e 14		            LD   A, display_row_2 
9823			;            CALL fLCD_Pos       ;Position cursor to location in A 
9823 11 f3 97		            LD   DE, str1 
9826 cd 9f 88			call str_at_display 
9829			 
9829			;            CALL fLCD_Str       ;Display string pointed to by DE 
9829			cloop:	 
9829 3e 28		            LD   A, display_row_3 
982b			;            CALL fLCD_Pos       ;Position cursor to location in A 
982b 11 06 98		            LD   DE, clear 
982e			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
982e cd 9f 88				call str_at_display 
9831 3e 3c			ld a, display_row_4 
9833 11 63 98			ld de, prompt 
9836			 
9836 cd 9f 88				call str_at_display 
9839 cd af 88			call update_display 
983c			 
983c 3e 3d			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
983e 16 0a			ld d, 10 
9840 21 dd e4			ld hl, scratch	 
9843 cd e6 8a			call input_str 
9846			 
9846			;	call clear_display 
9846			;'	call update_display 
9846			 
9846 3e 00		            LD   A, display_row_1 
9848			;            CALL fLCD_Pos       ;Position cursor to location in A 
9848 11 06 98		            LD   DE, clear 
984b cd 9f 88				call str_at_display 
984e			;            CALL fLCD_Str       ;Display string pointed to by DE 
984e 3e 00		            LD   A, display_row_1 
9850			;            CALL fLCD_Pos       ;Position cursor to location in A 
9850 11 dd e4		            LD   DE, scratch 
9853			;            CALL fLCD_Str       ;Display string pointed to by DE 
9853 cd 9f 88				call str_at_display 
9856 cd af 88			call update_display 
9859			 
9859 3e 00				ld a,0 
985b 21 dd e4			ld hl, scratch 
985e 77				ld (hl),a 
985f			 
985f 00				nop 
9860 c3 29 98			jp cloop 
9863			 
9863			 
9863			 
9863			; OS Prompt 
9863			 
9863 .. 00		prompt: db ">",0 
9865 .. 00		endprg: db "?",0 
9867			 
9867			 
9867			; handy next page prompt 
9867			next_page_prompt: 
9867 e5				push hl 
9868 d5				push de 
9869 f5				push af 
986a c5				push bc 
986b			 
986b 3e 4f			ld a,display_row_4 + display_cols - 1 
986d 11 65 98		        ld de, endprg 
9870 cd 9f 88			call str_at_display 
9873 cd af 88			call update_display 
9876 cd c0 d7			call cin_wait 
9879 c1				pop bc 
987a f1				pop af 
987b d1				pop de 
987c e1				pop hl 
987d			 
987d			 
987d c9				ret 
987e			 
987e			 
987e			; forth parser 
987e			 
987e			; My forth kernel 
987e			include "forth_kernel.asm" 
987e			; 
987e			; kernel to the forth OS 
987e			 
987e			DS_TYPE_STR: equ 1     ; string type 
987e			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
987e			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
987e			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
987e			 
987e			FORTH_PARSEV1: equ 0 
987e			FORTH_PARSEV2: equ 0 
987e			FORTH_PARSEV3: equ 0 
987e			FORTH_PARSEV4: equ 0 
987e			FORTH_PARSEV5: equ 1 
987e			 
987e			;if FORTH_PARSEV5 
987e			;	FORTH_END_BUFFER: equ 0 
987e			;else 
987e			FORTH_END_BUFFER: equ 127 
987e			;endif 
987e			 
987e			FORTH_TRUE: equ 1 
987e			FORTH_FALSE: equ 0 
987e			 
987e			if FORTH_PARSEV4 
987e			include "forth_stackops.asm" 
987e			endif 
987e			 
987e			if FORTH_PARSEV5 
987e			include "forth_stackopsv5.asm" 
987e			 
987e			; Stack operations for v5 parser on wards 
987e			; * DATA stack 
987e			; * LOOP stack 
987e			; * RETURN stack 
987e			 
987e			 
987e			 
987e			FORTH_CHK_DSP_UNDER: macro 
987e				push hl 
987e				push de 
987e				ld hl,(cli_data_sp) 
987e				ld de, cli_data_stack 
987e				call cmp16 
987e				jp c, fault_dsp_under 
987e				pop de 
987e				pop hl 
987e				endm 
987e			 
987e			 
987e			FORTH_CHK_RSP_UNDER: macro 
987e				push hl 
987e				push de 
987e				ld hl,(cli_ret_sp) 
987e				ld de, cli_ret_stack 
987e				call cmp16 
987e				jp c, fault_rsp_under 
987e				pop de 
987e				pop hl 
987e				endm 
987e			 
987e			FORTH_CHK_LOOP_UNDER: macro 
987e				push hl 
987e				push de 
987e				ld hl,(cli_loop_sp) 
987e				ld de, cli_loop_stack 
987e				call cmp16 
987e				jp c, fault_loop_under 
987e				pop de 
987e				pop hl 
987e				endm 
987e			 
987e			FORTH_ERR_TOS_NOTSTR: macro 
987e				; TOSO might need more for checks when used 
987e				push af 
987e				ld a,(hl) 
987e				cp DS_TYPE_STR 
987e				jp nz, type_faultn   
987e				pop af 
987e				endm 
987e			 
987e			FORTH_ERR_TOS_NOTNUM: macro 
987e				push af 
987e				ld a,(hl) 
987e				cp DS_TYPE_INUM 
987e				jp nz, type_faultn   
987e				pop af 
987e				endm 
987e			 
987e			 
987e			; increase data stack pointer and save hl to it 
987e				 
987e			FORTH_DSP_NEXT: macro 
987e				call macro_forth_dsp_next 
987e				endm 
987e			 
987e			 
987e			macro_forth_dsp_next: 
987e				if DEBUG_FORTH_STACK_GUARD 
987e cd 24 d5				call check_stacks 
9881				endif 
9881 e5				push hl 
9882 d5				push de 
9883 eb				ex de,hl 
9884 2a 8a ec			ld hl,(cli_data_sp) 
9887 23				inc hl 
9888 23				inc hl 
9889			 
9889			; PARSEV5 
9889 23				inc hl 
988a 22 8a ec			ld (cli_data_sp),hl 
988d 73				ld (hl), e 
988e 23				inc hl 
988f 72				ld (hl), d 
9890 d1				pop de 
9891 e1				pop hl 
9892				if DEBUG_FORTH_STACK_GUARD 
9892 cd 24 d5				call check_stacks 
9895				endif 
9895 c9				ret 
9896			 
9896			 
9896			; increase ret stack pointer and save hl to it 
9896				 
9896			FORTH_RSP_NEXT: macro 
9896				call macro_forth_rsp_next 
9896				endm 
9896			 
9896			macro_forth_rsp_next: 
9896				if DEBUG_FORTH_STACK_GUARD 
9896 cd 24 d5				call check_stacks 
9899				endif 
9899 e5				push hl 
989a d5				push de 
989b eb				ex de,hl 
989c 2a 8e ec			ld hl,(cli_ret_sp) 
989f 23				inc hl 
98a0 23				inc hl 
98a1 22 8e ec			ld (cli_ret_sp),hl 
98a4 73				ld (hl), e 
98a5 23				inc hl 
98a6 72				ld (hl), d 
98a7 d1				pop de 
98a8 e1				pop hl 
98a9				if DEBUG_FORTH_STACK_GUARD 
98a9 cd 24 d5				call check_stacks 
98ac				endif 
98ac c9				ret 
98ad			 
98ad			; get current ret stack pointer and save to hl  
98ad				 
98ad			FORTH_RSP_TOS: macro 
98ad				call macro_forth_rsp_tos 
98ad				endm 
98ad			 
98ad			macro_forth_rsp_tos: 
98ad				;push de 
98ad 2a 8e ec			ld hl,(cli_ret_sp) 
98b0 cd e8 98			call loadhlptrtohl 
98b3				;ld e, (hl) 
98b3				;inc hl 
98b3				;ld d, (hl) 
98b3				;ex de, hl 
98b3					if DEBUG_FORTH_WORDS 
98b3			;			DMARK "RST" 
98b3						CALLMONITOR 
98b3 cd 62 93			call break_point_state  
98b6				endm  
# End of macro CALLMONITOR
98b6					endif 
98b6				;pop de 
98b6 c9				ret 
98b7			 
98b7			; pop ret stack pointer 
98b7				 
98b7			FORTH_RSP_POP: macro 
98b7				call macro_forth_rsp_pop 
98b7				endm 
98b7			 
98b7			 
98b7			macro_forth_rsp_pop: 
98b7				if DEBUG_FORTH_STACK_GUARD 
98b7			;		DMARK "RPP" 
98b7 cd 24 d5				call check_stacks 
98ba					FORTH_CHK_RSP_UNDER 
98ba e5				push hl 
98bb d5				push de 
98bc 2a 8e ec			ld hl,(cli_ret_sp) 
98bf 11 48 ec			ld de, cli_ret_stack 
98c2 cd d7 8a			call cmp16 
98c5 da 38 d6			jp c, fault_rsp_under 
98c8 d1				pop de 
98c9 e1				pop hl 
98ca				endm 
# End of macro FORTH_CHK_RSP_UNDER
98ca				endif 
98ca e5				push hl 
98cb 2a 8e ec			ld hl,(cli_ret_sp) 
98ce			 
98ce			 
98ce				if FORTH_ENABLE_FREE 
98ce			 
98ce					; get pointer 
98ce			 
98ce					push de 
98ce					push hl 
98ce			 
98ce					ld e, (hl) 
98ce					inc hl 
98ce					ld d, (hl) 
98ce			 
98ce					ex de, hl 
98ce					call free 
98ce			 
98ce					pop hl 
98ce					pop de 
98ce			 
98ce			 
98ce				endif 
98ce			 
98ce			 
98ce 2b				dec hl 
98cf 2b				dec hl 
98d0 22 8e ec			ld (cli_ret_sp), hl 
98d3				; do stack underflow checks 
98d3 e1				pop hl 
98d4				if DEBUG_FORTH_STACK_GUARD 
98d4 cd 24 d5				call check_stacks 
98d7					FORTH_CHK_RSP_UNDER 
98d7 e5				push hl 
98d8 d5				push de 
98d9 2a 8e ec			ld hl,(cli_ret_sp) 
98dc 11 48 ec			ld de, cli_ret_stack 
98df cd d7 8a			call cmp16 
98e2 da 38 d6			jp c, fault_rsp_under 
98e5 d1				pop de 
98e6 e1				pop hl 
98e7				endm 
# End of macro FORTH_CHK_RSP_UNDER
98e7				endif 
98e7 c9				ret 
98e8			 
98e8			 
98e8			 
98e8			; routine to load word pointed to by hl into hl 
98e8			 
98e8			loadhlptrtohl: 
98e8			 
98e8 d5				push de 
98e9 5e				ld e, (hl) 
98ea 23				inc hl 
98eb 56				ld d, (hl) 
98ec eb				ex de, hl 
98ed d1				pop de 
98ee			 
98ee c9				ret 
98ef			 
98ef			 
98ef			 
98ef			 
98ef			 
98ef			; push a number held in HL onto the data stack 
98ef			; entry point for pushing a value when already in hl used in function above 
98ef			 
98ef			forth_push_numhl: 
98ef			 
98ef e5				push hl    ; save value to push 
98f0			 
98f0			if DEBUG_FORTH_PUSH 
98f0				; see if disabled 
98f0			 
98f0			 
98f0 f5				push af 
98f1 3a ce e4			ld a, (os_view_disable) 
98f4 fe 2a			cp '*' 
98f6 28 34			jr z, .pskip2 
98f8 e5				push hl 
98f9 e5			push hl 
98fa cd 8c 88			call clear_display 
98fd e1			pop hl 
98fe 7c				ld a,h 
98ff 21 e2 e7			ld hl, os_word_scratch 
9902 cd ba 8d			call hexout 
9905 e1				pop hl 
9906 7d				ld a,l 
9907 21 e4 e7			ld hl, os_word_scratch+2 
990a cd ba 8d			call hexout 
990d			 
990d 21 e6 e7			ld hl, os_word_scratch+4 
9910 3e 00			ld a,0 
9912 77				ld (hl),a 
9913 11 e2 e7			ld de,os_word_scratch 
9916 3e 14				ld a, display_row_2 
9918 cd 9f 88				call str_at_display 
991b 11 32 c4			ld de, .push_num 
991e 3e 00			ld a, display_row_1 
9920			 
9920 cd 9f 88				call str_at_display 
9923			 
9923			 
9923 cd af 88			call update_display 
9926 cd 09 88			call delay1s 
9929 cd 09 88			call delay1s 
992c			.pskip2:  
992c			 
992c f1				pop af 
992d			endif	 
992d			 
992d			 
992d				FORTH_DSP_NEXT 
992d cd 7e 98			call macro_forth_dsp_next 
9930				endm 
# End of macro FORTH_DSP_NEXT
9930			 
9930 2a 8a ec			ld hl, (cli_data_sp) 
9933			 
9933				; save item type 
9933 3e 02			ld a,  DS_TYPE_INUM 
9935 77				ld (hl), a 
9936 23				inc hl 
9937			 
9937				; get word off stack 
9937 d1				pop de 
9938 7b				ld a,e 
9939 77				ld (hl), a 
993a 23				inc hl 
993b 7a				ld a,d 
993c 77				ld (hl), a 
993d			 
993d			if DEBUG_FORTH_PUSH 
993d 2b				dec hl 
993e 2b				dec hl 
993f 2b				dec hl 
9940						DMARK "PH5" 
9940 f5				push af  
9941 3a 55 99			ld a, (.dmark)  
9944 32 b7 ee			ld (debug_mark),a  
9947 3a 56 99			ld a, (.dmark+1)  
994a 32 b8 ee			ld (debug_mark+1),a  
994d 3a 57 99			ld a, (.dmark+2)  
9950 32 b9 ee			ld (debug_mark+2),a  
9953 18 03			jr .pastdmark  
9955 ..			.dmark: db "PH5"  
9958 f1			.pastdmark: pop af  
9959			endm  
# End of macro DMARK
9959				CALLMONITOR 
9959 cd 62 93			call break_point_state  
995c				endm  
# End of macro CALLMONITOR
995c			endif	 
995c			 
995c c9				ret 
995d			 
995d			 
995d			; Push a string to stack pointed to by hl 
995d			 
995d			forth_push_str: 
995d			 
995d			if DEBUG_FORTH_PUSH 
995d						DMARK "PSQ" 
995d f5				push af  
995e 3a 72 99			ld a, (.dmark)  
9961 32 b7 ee			ld (debug_mark),a  
9964 3a 73 99			ld a, (.dmark+1)  
9967 32 b8 ee			ld (debug_mark+1),a  
996a 3a 74 99			ld a, (.dmark+2)  
996d 32 b9 ee			ld (debug_mark+2),a  
9970 18 03			jr .pastdmark  
9972 ..			.dmark: db "PSQ"  
9975 f1			.pastdmark: pop af  
9976			endm  
# End of macro DMARK
9976				CALLMONITOR 
9976 cd 62 93			call break_point_state  
9979				endm  
# End of macro CALLMONITOR
9979			endif	 
9979			    
9979 e5				push hl 
997a e5				push hl 
997b			 
997b			;	ld a, 0   ; find end of string 
997b cd 17 8f			call strlenz 
997e			if DEBUG_FORTH_PUSH 
997e						DMARK "PQ2" 
997e f5				push af  
997f 3a 93 99			ld a, (.dmark)  
9982 32 b7 ee			ld (debug_mark),a  
9985 3a 94 99			ld a, (.dmark+1)  
9988 32 b8 ee			ld (debug_mark+1),a  
998b 3a 95 99			ld a, (.dmark+2)  
998e 32 b9 ee			ld (debug_mark+2),a  
9991 18 03			jr .pastdmark  
9993 ..			.dmark: db "PQ2"  
9996 f1			.pastdmark: pop af  
9997			endm  
# End of macro DMARK
9997				CALLMONITOR 
9997 cd 62 93			call break_point_state  
999a				endm  
# End of macro CALLMONITOR
999a			endif	 
999a eb				ex de, hl 
999b e1				pop hl   ; get ptr to start of string 
999c			if DEBUG_FORTH_PUSH 
999c						DMARK "PQ3" 
999c f5				push af  
999d 3a b1 99			ld a, (.dmark)  
99a0 32 b7 ee			ld (debug_mark),a  
99a3 3a b2 99			ld a, (.dmark+1)  
99a6 32 b8 ee			ld (debug_mark+1),a  
99a9 3a b3 99			ld a, (.dmark+2)  
99ac 32 b9 ee			ld (debug_mark+2),a  
99af 18 03			jr .pastdmark  
99b1 ..			.dmark: db "PQ3"  
99b4 f1			.pastdmark: pop af  
99b5			endm  
# End of macro DMARK
99b5				CALLMONITOR 
99b5 cd 62 93			call break_point_state  
99b8				endm  
# End of macro CALLMONITOR
99b8			endif	 
99b8 19				add hl,de 
99b9			if DEBUG_FORTH_PUSH 
99b9						DMARK "PQE" 
99b9 f5				push af  
99ba 3a ce 99			ld a, (.dmark)  
99bd 32 b7 ee			ld (debug_mark),a  
99c0 3a cf 99			ld a, (.dmark+1)  
99c3 32 b8 ee			ld (debug_mark+1),a  
99c6 3a d0 99			ld a, (.dmark+2)  
99c9 32 b9 ee			ld (debug_mark+2),a  
99cc 18 03			jr .pastdmark  
99ce ..			.dmark: db "PQE"  
99d1 f1			.pastdmark: pop af  
99d2			endm  
# End of macro DMARK
99d2				CALLMONITOR 
99d2 cd 62 93			call break_point_state  
99d5				endm  
# End of macro CALLMONITOR
99d5			endif	 
99d5			 
99d5 2b				dec hl    ; see if there is an optional trailing double quote 
99d6 7e				ld a,(hl) 
99d7 fe 22			cp '"' 
99d9 20 03			jr nz, .strnoq 
99db 3e 00			ld a, 0      ; get rid of double quote 
99dd 77				ld (hl), a 
99de 23			.strnoq: inc hl 
99df			 
99df 3e 00			ld a, 0 
99e1 77				ld (hl), a     ; add null term and get rid of trailing double quote 
99e2			 
99e2 13				inc de ; add one for the type string 
99e3 13				inc de ; add one for null term??? 
99e4			 
99e4				; tos is get string pointer again 
99e4				; de contains space to allocate 
99e4				 
99e4 d5				push de 
99e5			 
99e5 eb				ex de, hl 
99e6			 
99e6				;push af 
99e6			 
99e6			if DEBUG_FORTH_PUSH 
99e6						DMARK "PHm" 
99e6 f5				push af  
99e7 3a fb 99			ld a, (.dmark)  
99ea 32 b7 ee			ld (debug_mark),a  
99ed 3a fc 99			ld a, (.dmark+1)  
99f0 32 b8 ee			ld (debug_mark+1),a  
99f3 3a fd 99			ld a, (.dmark+2)  
99f6 32 b9 ee			ld (debug_mark+2),a  
99f9 18 03			jr .pastdmark  
99fb ..			.dmark: db "PHm"  
99fe f1			.pastdmark: pop af  
99ff			endm  
# End of macro DMARK
99ff				CALLMONITOR 
99ff cd 62 93			call break_point_state  
9a02				endm  
# End of macro CALLMONITOR
9a02			endif	 
9a02 cd 80 8f			call malloc	; on ret hl now contains allocated memory 
9a05				if DEBUG_FORTH_MALLOC_GUARD 
9a05 cc 8a c4				call z,malloc_error 
9a08				endif 
9a08			 
9a08				 
9a08 c1				pop bc    ; get length 
9a09 d1				pop de   ;  get string start    
9a0a			 
9a0a				; hl has destination from malloc 
9a0a			 
9a0a eb				ex de, hl    ; prep for ldir 
9a0b			 
9a0b d5				push de   ; save malloc area for DSP later 
9a0c				;push hl   ; save malloc area for DSP later 
9a0c			 
9a0c			if DEBUG_FORTH_PUSH 
9a0c						DMARK "PHc" 
9a0c f5				push af  
9a0d 3a 21 9a			ld a, (.dmark)  
9a10 32 b7 ee			ld (debug_mark),a  
9a13 3a 22 9a			ld a, (.dmark+1)  
9a16 32 b8 ee			ld (debug_mark+1),a  
9a19 3a 23 9a			ld a, (.dmark+2)  
9a1c 32 b9 ee			ld (debug_mark+2),a  
9a1f 18 03			jr .pastdmark  
9a21 ..			.dmark: db "PHc"  
9a24 f1			.pastdmark: pop af  
9a25			endm  
# End of macro DMARK
9a25				CALLMONITOR 
9a25 cd 62 93			call break_point_state  
9a28				endm  
# End of macro CALLMONITOR
9a28			endif	 
9a28			 
9a28			 
9a28 ed b0			ldir 
9a2a			 
9a2a			 
9a2a				; push malloc to data stack     macro?????  
9a2a			 
9a2a				FORTH_DSP_NEXT 
9a2a cd 7e 98			call macro_forth_dsp_next 
9a2d				endm 
# End of macro FORTH_DSP_NEXT
9a2d			 
9a2d				; save value and type 
9a2d			 
9a2d 2a 8a ec			ld hl, (cli_data_sp) 
9a30			 
9a30				; save item type 
9a30 3e 01			ld a,  DS_TYPE_STR 
9a32 77				ld (hl), a 
9a33 23				inc hl 
9a34			 
9a34				; get malloc word off stack 
9a34 d1				pop de 
9a35 73				ld (hl), e 
9a36 23				inc hl 
9a37 72				ld (hl), d 
9a38			 
9a38			 
9a38			 
9a38			if DEBUG_FORTH_PUSH 
9a38 2a 8a ec			ld hl, (cli_data_sp) 
9a3b						DMARK "PHS" 
9a3b f5				push af  
9a3c 3a 50 9a			ld a, (.dmark)  
9a3f 32 b7 ee			ld (debug_mark),a  
9a42 3a 51 9a			ld a, (.dmark+1)  
9a45 32 b8 ee			ld (debug_mark+1),a  
9a48 3a 52 9a			ld a, (.dmark+2)  
9a4b 32 b9 ee			ld (debug_mark+2),a  
9a4e 18 03			jr .pastdmark  
9a50 ..			.dmark: db "PHS"  
9a53 f1			.pastdmark: pop af  
9a54			endm  
# End of macro DMARK
9a54				CALLMONITOR 
9a54 cd 62 93			call break_point_state  
9a57				endm  
# End of macro CALLMONITOR
9a57			;	ex de,hl 
9a57			endif	 
9a57				; in case of spaces, skip the ptr past the copied string 
9a57				;pop af 
9a57				;ld (cli_origptr),hl 
9a57			 
9a57 c9				ret 
9a58			 
9a58			 
9a58			 
9a58			; TODO ascii push input onto stack given hl to start of input 
9a58			 
9a58			; identify type 
9a58			; if starts with a " then a string 
9a58			; otherwise it is a number 
9a58			;  
9a58			; if a string 
9a58			;     scan for ending " to get length of string to malloc for + 1 
9a58			;     malloc 
9a58			;     put pointer to string on stack first byte flags as string 
9a58			; 
9a58			; else a number 
9a58			;    look for number format identifier 
9a58			;    $xx hex 
9a58			;    %xxxxx bin 
9a58			;    xxxxx decimal 
9a58			;    convert number to 16bit word.  
9a58			;    malloc word + 1 with flag to identiy as num 
9a58			;    put pointer to number on stack 
9a58			;   
9a58			;  
9a58			  
9a58			forth_apush: 
9a58				; kernel push 
9a58			 
9a58			if DEBUG_FORTH_PUSH 
9a58						DMARK "PSH" 
9a58 f5				push af  
9a59 3a 6d 9a			ld a, (.dmark)  
9a5c 32 b7 ee			ld (debug_mark),a  
9a5f 3a 6e 9a			ld a, (.dmark+1)  
9a62 32 b8 ee			ld (debug_mark+1),a  
9a65 3a 6f 9a			ld a, (.dmark+2)  
9a68 32 b9 ee			ld (debug_mark+2),a  
9a6b 18 03			jr .pastdmark  
9a6d ..			.dmark: db "PSH"  
9a70 f1			.pastdmark: pop af  
9a71			endm  
# End of macro DMARK
9a71				CALLMONITOR 
9a71 cd 62 93			call break_point_state  
9a74				endm  
# End of macro CALLMONITOR
9a74			endif	 
9a74				; identify input type 
9a74			 
9a74 7e				ld a,(hl) 
9a75 fe 22			cp '"' 
9a77 28 0a			jr z, .fapstr 
9a79 fe 24			cp '$' 
9a7b ca a3 9a			jp z, .faphex 
9a7e fe 25			cp '%' 
9a80 ca 8b 9a			jp z, .fapbin 
9a83			;	cp 'b' 
9a83			;	jp z, .fabin 
9a83				; else decimal 
9a83			 
9a83				; TODO do decimal conversion 
9a83				; decimal is stored as a 16bit word 
9a83			 
9a83				; by default everything is a string if type is not detected 
9a83			.fapstr: ; 
9a83 fe 22			cp '"' 
9a85 20 01			jr nz, .strnoqu 
9a87 23				inc hl 
9a88			.strnoqu: 
9a88 c3 5d 99			jp forth_push_str 
9a8b			 
9a8b			 
9a8b			 
9a8b			.fapbin:    ; push a binary string.  
9a8b 11 00 00			ld de, 0   ; hold a 16bit value 
9a8e			 
9a8e 23			.fapbinshift:	inc hl  
9a8f 7e				ld a,(hl) 
9a90 fe 00			cp 0     ; done scanning  
9a92 28 0b			jr z, .fapbdone  	; got it in HL so push  
9a94			 
9a94				; left shift de 
9a94 eb				ex de, hl	 
9a95 29				add hl, hl 
9a96			 
9a96				; is 1 
9a96 fe 31			cp '1' 
9a98 20 02			jr nz, .binzero 
9a9a cb 4d			bit 1, l 
9a9c			.binzero: 
9a9c eb				ex de, hl	 ; save current de 
9a9d 18 ef			jr .fapbinshift 
9a9f			 
9a9f			.fapbdone: 
9a9f eb				ex de, hl 
9aa0 c3 ef 98			jp forth_push_numhl 
9aa3			 
9aa3			 
9aa3			.faphex:   ; hex is always stored as a 16bit word 
9aa3				; skip number prefix 
9aa3 23				inc hl 
9aa4				; turn ascii into number 
9aa4 cd 70 8e			call get_word_hl	; ret 16bit word in hl 
9aa7			 
9aa7 c3 ef 98			jp forth_push_numhl 
9aaa			 
9aaa 00				 nop 
9aab			 
9aab			.fabin:   ; TODO bin conversion 
9aab			 
9aab			 
9aab c9				ret 
9aac			 
9aac			 
9aac			; get either a string ptr or a 16bit word from the data stack 
9aac			 
9aac			FORTH_DSP: macro 
9aac				call macro_forth_dsp 
9aac				endm 
9aac			 
9aac			macro_forth_dsp: 
9aac				; data stack pointer points to current word on tos 
9aac			 
9aac 2a 8a ec			ld hl,(cli_data_sp) 
9aaf			 
9aaf				if DEBUG_FORTH_PUSH 
9aaf						DMARK "DSP" 
9aaf f5				push af  
9ab0 3a c4 9a			ld a, (.dmark)  
9ab3 32 b7 ee			ld (debug_mark),a  
9ab6 3a c5 9a			ld a, (.dmark+1)  
9ab9 32 b8 ee			ld (debug_mark+1),a  
9abc 3a c6 9a			ld a, (.dmark+2)  
9abf 32 b9 ee			ld (debug_mark+2),a  
9ac2 18 03			jr .pastdmark  
9ac4 ..			.dmark: db "DSP"  
9ac7 f1			.pastdmark: pop af  
9ac8			endm  
# End of macro DMARK
9ac8			 
9ac8 cd bf c4				call display_data_sp 
9acb				;call break_point_state 
9acb				;rst 030h 
9acb				CALLMONITOR 
9acb cd 62 93			call break_point_state  
9ace				endm  
# End of macro CALLMONITOR
9ace				endif 
9ace			 
9ace c9				ret 
9acf			 
9acf			; return hl to start of value on stack 
9acf			 
9acf			FORTH_DSP_VALUE: macro 
9acf				call macro_forth_dsp_value 
9acf				endm 
9acf			 
9acf			macro_forth_dsp_value: 
9acf			 
9acf				FORTH_DSP 
9acf cd ac 9a			call macro_forth_dsp 
9ad2				endm 
# End of macro FORTH_DSP
9ad2			 
9ad2 d5				push de 
9ad3			 
9ad3 23				inc hl ; skip type 
9ad4			 
9ad4 5e				ld e, (hl) 
9ad5 23				inc hl 
9ad6 56				ld d, (hl) 
9ad7 eb				ex de,hl  
9ad8			 
9ad8 d1				pop de 
9ad9			 
9ad9 c9				ret 
9ada			 
9ada			; return hl to start of value to second item on stack 
9ada			 
9ada			FORTH_DSP_VALUEM1: macro 
9ada				call macro_forth_dsp_value_m1 
9ada				endm 
9ada			 
9ada			macro_forth_dsp_value_m1: 
9ada			 
9ada				FORTH_DSP 
9ada cd ac 9a			call macro_forth_dsp 
9add				endm 
# End of macro FORTH_DSP
9add			 
9add 2b				dec hl 
9ade 2b				dec hl 
9adf			;	dec hl 
9adf			 
9adf d5				push de 
9ae0			 
9ae0 5e				ld e, (hl) 
9ae1 23				inc hl 
9ae2 56				ld d, (hl) 
9ae3 eb				ex de,hl  
9ae4			 
9ae4 d1				pop de 
9ae5			 
9ae5 c9				ret 
9ae6			 
9ae6				 
9ae6			 
9ae6			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9ae6			 
9ae6			FORTH_DSP_POP: macro 
9ae6				call macro_forth_dsp_pop 
9ae6				endm 
9ae6			 
9ae6			 
9ae6			; get the tos data type 
9ae6			 
9ae6			FORTH_DSP_TYPE:   macro 
9ae6			 
9ae6				;FORTH_DSP_VALUE 
9ae6				FORTH_DSP 
9ae6				 
9ae6				; hl points to value 
9ae6				; check type 
9ae6			 
9ae6				ld a,(hl) 
9ae6			 
9ae6				endm 
9ae6			 
9ae6			; load the tos value into hl 
9ae6			 
9ae6			 
9ae6			FORTH_DSP_VALUEHL:  macro 
9ae6				call macro_dsp_valuehl 
9ae6				endm 
9ae6			 
9ae6			 
9ae6			 
9ae6			macro_dsp_valuehl: 
9ae6				FORTH_DSP_VALUE 
9ae6 cd cf 9a			call macro_forth_dsp_value 
9ae9				endm 
# End of macro FORTH_DSP_VALUE
9ae9			 
9ae9				;FORTH_ERR_TOS_NOTNUM 
9ae9			 
9ae9				;inc hl   ; skip type id 
9ae9			 
9ae9			;	push de 
9ae9			; 
9ae9			;	ld e, (hl) 
9ae9			;	inc hl 
9ae9			;	ld d, (hl) 
9ae9			;	ex de,hl  
9ae9			 
9ae9			;	pop de 
9ae9			 
9ae9				if DEBUG_FORTH_PUSH 
9ae9						DMARK "DVL" 
9ae9 f5				push af  
9aea 3a fe 9a			ld a, (.dmark)  
9aed 32 b7 ee			ld (debug_mark),a  
9af0 3a ff 9a			ld a, (.dmark+1)  
9af3 32 b8 ee			ld (debug_mark+1),a  
9af6 3a 00 9b			ld a, (.dmark+2)  
9af9 32 b9 ee			ld (debug_mark+2),a  
9afc 18 03			jr .pastdmark  
9afe ..			.dmark: db "DVL"  
9b01 f1			.pastdmark: pop af  
9b02			endm  
# End of macro DMARK
9b02				CALLMONITOR 
9b02 cd 62 93			call break_point_state  
9b05				endm  
# End of macro CALLMONITOR
9b05				endif 
9b05 c9				ret 
9b06			 
9b06			forth_apushstrhl:      
9b06				; push of string requires use of cli_origptr 
9b06				; bodge use 
9b06			 
9b06				; get current cli_origptr, save, update with temp pointer  
9b06 ed 5b a6 ec		ld de, (cli_origptr) 
9b0a 22 a6 ec			ld (cli_origptr), hl 
9b0d d5				push de 
9b0e cd 58 9a			call forth_apush 
9b11 d1				pop de 
9b12 ed 53 a6 ec		ld (cli_origptr), de 
9b16 c9			        ret	 
9b17			 
9b17			 
9b17			; increase loop stack pointer and save hl to it 
9b17				 
9b17			FORTH_LOOP_NEXT: macro 
9b17				call macro_forth_loop_next 
9b17				;nop 
9b17				endm 
9b17			 
9b17			macro_forth_loop_next: 
9b17				if DEBUG_FORTH_STACK_GUARD 
9b17 cd 24 d5				call check_stacks 
9b1a				endif 
9b1a e5				push hl 
9b1b d5				push de 
9b1c eb				ex de,hl 
9b1d 2a 8c ec			ld hl,(cli_loop_sp) 
9b20 23				inc hl 
9b21 23				inc hl 
9b22					if DEBUG_FORTH_WORDS 
9b22						DMARK "LNX" 
9b22 f5				push af  
9b23 3a 37 9b			ld a, (.dmark)  
9b26 32 b7 ee			ld (debug_mark),a  
9b29 3a 38 9b			ld a, (.dmark+1)  
9b2c 32 b8 ee			ld (debug_mark+1),a  
9b2f 3a 39 9b			ld a, (.dmark+2)  
9b32 32 b9 ee			ld (debug_mark+2),a  
9b35 18 03			jr .pastdmark  
9b37 ..			.dmark: db "LNX"  
9b3a f1			.pastdmark: pop af  
9b3b			endm  
# End of macro DMARK
9b3b						CALLMONITOR 
9b3b cd 62 93			call break_point_state  
9b3e				endm  
# End of macro CALLMONITOR
9b3e					endif 
9b3e 22 8c ec			ld (cli_loop_sp),hl 
9b41 73				ld (hl), e 
9b42 23				inc hl 
9b43 72				ld (hl), d 
9b44 d1				pop de    ; been reversed so save a swap on restore 
9b45 e1				pop hl 
9b46				if DEBUG_FORTH_STACK_GUARD 
9b46 cd 24 d5				call check_stacks 
9b49				endif 
9b49 c9				ret 
9b4a			 
9b4a			; get current ret stack pointer and save to hl  
9b4a				 
9b4a			FORTH_LOOP_TOS: macro 
9b4a				call macro_forth_loop_tos 
9b4a				endm 
9b4a			 
9b4a			macro_forth_loop_tos: 
9b4a d5				push de 
9b4b 2a 8c ec			ld hl,(cli_loop_sp) 
9b4e 5e				ld e, (hl) 
9b4f 23				inc hl 
9b50 56				ld d, (hl) 
9b51 eb				ex de, hl 
9b52 d1				pop de 
9b53 c9				ret 
9b54			 
9b54			; pop loop stack pointer 
9b54				 
9b54			FORTH_LOOP_POP: macro 
9b54				call macro_forth_loop_pop 
9b54				endm 
9b54			 
9b54			 
9b54			macro_forth_loop_pop: 
9b54				if DEBUG_FORTH_STACK_GUARD 
9b54					DMARK "LPP" 
9b54 f5				push af  
9b55 3a 69 9b			ld a, (.dmark)  
9b58 32 b7 ee			ld (debug_mark),a  
9b5b 3a 6a 9b			ld a, (.dmark+1)  
9b5e 32 b8 ee			ld (debug_mark+1),a  
9b61 3a 6b 9b			ld a, (.dmark+2)  
9b64 32 b9 ee			ld (debug_mark+2),a  
9b67 18 03			jr .pastdmark  
9b69 ..			.dmark: db "LPP"  
9b6c f1			.pastdmark: pop af  
9b6d			endm  
# End of macro DMARK
9b6d cd 24 d5				call check_stacks 
9b70					FORTH_CHK_LOOP_UNDER 
9b70 e5				push hl 
9b71 d5				push de 
9b72 2a 8c ec			ld hl,(cli_loop_sp) 
9b75 11 46 eb			ld de, cli_loop_stack 
9b78 cd d7 8a			call cmp16 
9b7b da 3e d6			jp c, fault_loop_under 
9b7e d1				pop de 
9b7f e1				pop hl 
9b80				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b80				endif 
9b80 e5				push hl 
9b81 2a 8c ec			ld hl,(cli_loop_sp) 
9b84 2b				dec hl 
9b85 2b				dec hl 
9b86 22 8c ec			ld (cli_loop_sp), hl 
9b89				; TODO do stack underflow checks 
9b89 e1				pop hl 
9b8a				if DEBUG_FORTH_STACK_GUARD 
9b8a cd 24 d5				call check_stacks 
9b8d					FORTH_CHK_LOOP_UNDER 
9b8d e5				push hl 
9b8e d5				push de 
9b8f 2a 8c ec			ld hl,(cli_loop_sp) 
9b92 11 46 eb			ld de, cli_loop_stack 
9b95 cd d7 8a			call cmp16 
9b98 da 3e d6			jp c, fault_loop_under 
9b9b d1				pop de 
9b9c e1				pop hl 
9b9d				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b9d				endif 
9b9d c9				ret 
9b9e			 
9b9e			macro_forth_dsp_pop: 
9b9e			 
9b9e e5				push hl 
9b9f			 
9b9f				; release malloc data 
9b9f			 
9b9f				if DEBUG_FORTH_STACK_GUARD 
9b9f cd 24 d5				call check_stacks 
9ba2					FORTH_CHK_DSP_UNDER 
9ba2 e5				push hl 
9ba3 d5				push de 
9ba4 2a 8a ec			ld hl,(cli_data_sp) 
9ba7 11 44 ea			ld de, cli_data_stack 
9baa cd d7 8a			call cmp16 
9bad da 32 d6			jp c, fault_dsp_under 
9bb0 d1				pop de 
9bb1 e1				pop hl 
9bb2				endm 
# End of macro FORTH_CHK_DSP_UNDER
9bb2				endif 
9bb2				;ld hl,(cli_data_sp) 
9bb2			if DEBUG_FORTH_DOT 
9bb2				DMARK "DPP" 
9bb2				CALLMONITOR 
9bb2			endif	 
9bb2			 
9bb2			 
9bb2			if FORTH_ENABLE_DSPPOPFREE 
9bb2			 
9bb2				FORTH_DSP 
9bb2 cd ac 9a			call macro_forth_dsp 
9bb5				endm 
# End of macro FORTH_DSP
9bb5			 
9bb5 7e				ld a, (hl) 
9bb6 fe 01			cp DS_TYPE_STR 
9bb8 20 07			jr nz, .skippopfree 
9bba			 
9bba				FORTH_DSP_VALUEHL 
9bba cd e6 9a			call macro_dsp_valuehl 
9bbd				endm 
# End of macro FORTH_DSP_VALUEHL
9bbd 00				nop 
9bbe			if DEBUG_FORTH_DOT 
9bbe				DMARK "DPf" 
9bbe				CALLMONITOR 
9bbe			endif	 
9bbe cd 4a 90			call free 
9bc1			.skippopfree: 
9bc1				 
9bc1			 
9bc1			endif 
9bc1			 
9bc1			if DEBUG_FORTH_DOT_KEY 
9bc1				DMARK "DP2" 
9bc1				CALLMONITOR 
9bc1			endif	 
9bc1			 
9bc1				; move pointer down 
9bc1			 
9bc1 2a 8a ec			ld hl,(cli_data_sp) 
9bc4 2b				dec hl 
9bc5 2b				dec hl 
9bc6			; PARSEV5 
9bc6 2b				dec hl 
9bc7 22 8a ec			ld (cli_data_sp), hl 
9bca			 
9bca				if DEBUG_FORTH_STACK_GUARD 
9bca cd 24 d5				call check_stacks 
9bcd					FORTH_CHK_DSP_UNDER 
9bcd e5				push hl 
9bce d5				push de 
9bcf 2a 8a ec			ld hl,(cli_data_sp) 
9bd2 11 44 ea			ld de, cli_data_stack 
9bd5 cd d7 8a			call cmp16 
9bd8 da 32 d6			jp c, fault_dsp_under 
9bdb d1				pop de 
9bdc e1				pop hl 
9bdd				endm 
# End of macro FORTH_CHK_DSP_UNDER
9bdd				endif 
9bdd			 
9bdd e1				pop hl 
9bde			 
9bde c9				ret 
9bdf			 
9bdf			getwordathl: 
9bdf				; hl points to an address 
9bdf				; load hl with the word at that address 
9bdf			 
9bdf d5				push de 
9be0			 
9be0 5e				ld e, (hl) 
9be1 23				inc hl 
9be2 56				ld d, (hl) 
9be3 eb				ex de, hl 
9be4			 
9be4 d1				pop de 
9be5 c9				ret 
9be6			 
9be6			 
9be6			 
9be6			 
9be6			 
9be6			; eof 
9be6			 
# End of file forth_stackopsv5.asm
9be6			endif 
9be6			 
9be6			user_word_eol:  
9be6				; hl contains the pointer to where to create a linked list item from the end 
9be6				; of the user dict to continue on at the system word dict 
9be6				 
9be6				; poke the stub of the word list linked list to repoint to rom words 
9be6			 
9be6				; stub format 
9be6				; db   word id 
9be6				; dw    link to next word 
9be6			        ; db char length of token 
9be6				; db string + 0 term 
9be6				; db exec code....  
9be6			 
9be6 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9be8 77				ld (hl), a		; word id 
9be9 23				inc hl 
9bea			 
9bea 11 b0 9d			ld de, sysdict 
9bed 73				ld (hl), e		; next word link ie system dict 
9bee 23				inc hl 
9bef 72				ld (hl), d		; next word link ie system dict 
9bf0 23				inc hl	 
9bf1			 
9bf1			;	ld (hl), sysdict		; next word link ie system dict 
9bf1			;	inc hl 
9bf1			;	inc hl 
9bf1			 
9bf1			;	inc hl 
9bf1			;	inc hl 
9bf1			 
9bf1 3e 02			ld a, 2			; word length is 0 
9bf3 77				ld (hl), a	 
9bf4 23				inc hl 
9bf5			 
9bf5 3e 7e			ld a, '~'			; word length is 0 
9bf7 77				ld (hl), a	 
9bf8 23				inc hl 
9bf9 3e 00			ld a, 0			; save empty word 
9bfb 77				ld (hl), a 
9bfc			 
9bfc c9				ret 
9bfd			 
9bfd				 
9bfd			 
9bfd			forthexec_cleanup: 
9bfd				FORTH_RSP_POP 
9bfd cd b7 98			call macro_forth_rsp_pop 
9c00				endm 
# End of macro FORTH_RSP_POP
9c00 c9				ret 
9c01			 
9c01			forth_call_hl: 
9c01				; taking hl 
9c01 e5				push hl 
9c02 c9				ret 
9c03			 
9c03			; this is called to reset Forth system but keep existing uwords etc 
9c03			 
9c03			forth_warmstart: 
9c03				; setup stack over/under flow checks 
9c03				if DEBUG_FORTH_STACK_GUARD 
9c03 cd 0a d5				call chk_stk_init 
9c06				endif 
9c06			 
9c06				; init stack pointers  - * these stacks go upwards *  
9c06 21 48 ec			ld hl, cli_ret_stack 
9c09 22 8e ec			ld (cli_ret_sp), hl	 
9c0c				; set bottom of stack 
9c0c 3e 00			ld a,0 
9c0e 77				ld (hl),a 
9c0f 23				inc hl 
9c10 77				ld (hl),a 
9c11			 
9c11 21 44 ea			ld hl, cli_data_stack 
9c14 22 8a ec			ld (cli_data_sp), hl	 
9c17				; set bottom of stack 
9c17 3e 00			ld a,0 
9c19 77				ld (hl),a 
9c1a 23				inc hl 
9c1b 77				ld (hl),a 
9c1c			 
9c1c 21 46 eb			ld hl, cli_loop_stack 
9c1f 22 8c ec			ld (cli_loop_sp), hl	 
9c22				; set bottom of stack 
9c22 3e 00			ld a,0 
9c24 77				ld (hl),a 
9c25 23				inc hl 
9c26 77				ld (hl),a 
9c27			 
9c27				; init extent of current open file 
9c27			 
9c27 3e 00			ld a, 0 
9c29 32 d9 ec			ld (store_openext), a 
9c2c			 
9c2c c9				ret 
9c2d			 
9c2d			 
9c2d			; Cold Start - this is called to setup the whole Forth system 
9c2d			 
9c2d			forth_init: 
9c2d			 
9c2d				; setup stack over/under flow checks 
9c2d			 
9c2d			;	if DEBUG_FORTH_STACK_GUARD 
9c2d			;		call chk_stk_init 
9c2d			;	endif 
9c2d			 
9c2d				; enable auto display updates (slow.....) 
9c2d			 
9c2d 3e 01			ld a, 1 
9c2f 32 a4 ec			ld (cli_autodisplay), a 
9c32			 
9c32			 
9c32			 
9c32				; show start up screen 
9c32			 
9c32 cd 8c 88			call clear_display 
9c35			 
9c35 3e 00			ld a,0 
9c37 32 c6 ec			ld (f_cursor_ptr), a 
9c3a			 
9c3a				; set start of word list in start of ram - for use when creating user words 
9c3a			 
9c3a 21 d5 d7			ld hl, baseram 
9c3d 22 da e7			ld (os_last_new_uword), hl 
9c40 cd e6 9b			call user_word_eol 
9c43				 
9c43			;		call display_data_sp 
9c43			;		call next_page_prompt 
9c43			 
9c43			 
9c43			 
9c43			 
9c43 c9				ret 
9c44			 
9c44 .. 00		.bootforth: db " Forth Kernel Init ",0 
9c58			 
9c58			; TODO push to stack 
9c58			 
9c58			;  
9c58			 
9c58			if FORTH_PARSEV2 
9c58			 
9c58			 
9c58				include "forth_parserv2.asm" 
9c58			 
9c58			endif 
9c58			 
9c58			 
9c58			; parse cli version 1 
9c58			 
9c58			if FORTH_PARSEV1 
9c58			 
9c58			 
9c58			 
9c58			      include "forth_parserv1.asm" 
9c58			endif 
9c58				 
9c58			if FORTH_PARSEV3 
9c58			 
9c58			 
9c58			 
9c58			      include "forth_parserv3.asm" 
9c58				include "forth_wordsv3.asm" 
9c58			endif 
9c58			 
9c58			if FORTH_PARSEV4 
9c58			 
9c58			 
9c58			 
9c58			      include "forth_parserv4.asm" 
9c58				include "forth_wordsv4.asm" 
9c58			endif 
9c58			 
9c58			if FORTH_PARSEV5 
9c58			 
9c58			 
9c58			 
9c58			      include "forth_parserv5.asm" 
9c58			 
9c58			 
9c58			; A better parser without using malloc and string copies all over the place.  
9c58			; Exec in situ should be faster 
9c58			 
9c58			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9c58			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9c58			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9c58			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9c58			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9c58			WORD_SYS_END: equ 0   ; Opcode for all user words 
9c58			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9c58			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9c58			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9c58			 
9c58			; Core word preamble macro 
9c58			 
9c58			CWHEAD:   macro nxtword opcode lit len opflags 
9c58				db WORD_SYS_CORE+opcode             
9c58				; internal op code number 
9c58				dw nxtword            
9c58				; link to next dict word block 
9c58				db len + 1 
9c58				; literal length of dict word inc zero term 
9c58				db lit,0              
9c58				; literal dict word 
9c58			        ; TODO db opflags        
9c58				endm 
9c58			 
9c58			 
9c58			NEXTW: macro  
9c58				jp macro_next 
9c58				endm 
9c58			 
9c58			macro_next: 
9c58			if DEBUG_FORTH_PARSE_KEY 
9c58				DMARK "NXT" 
9c58				CALLMONITOR 
9c58			endif	 
9c58			;	inc hl  ; skip token null term  
9c58 ed 4b a8 ec		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9c5c ed 5b a6 ec		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9c60 2a de e7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9c63			if DEBUG_FORTH_PARSE_KEY 
9c63				DMARK "}AA" 
9c63				CALLMONITOR 
9c63			endif	 
9c63 c3 66 9d			jp execnext 
9c66				;jp exec1 
9c66			       
9c66			 
9c66			 
9c66			; Another go at the parser to compile  
9c66			 
9c66			 
9c66			; TODO rework parser to change all of the string words to byte tokens 
9c66			; TODO do a search for  
9c66			 
9c66			; TODO first run normal parser to zero term sections 
9c66			; TODO for each word do a token look up to get the op code 
9c66			; TODO need some means to flag to the exec that this is a byte code form    
9c66			 
9c66			 
9c66			forthcompile: 
9c66			 
9c66			; 
9c66			; line parse: 
9c66			;       parse raw input buffer 
9c66			;       tokenise the words 
9c66			;       malloc new copy (for looping etc) 
9c66			;       copy to malloc + current pc in line to start of string and add line term 
9c66			;       save on new rsp 
9c66			; 
9c66			 
9c66			; hl to point to the line to tokenise 
9c66			 
9c66			;	push hl 
9c66 22 de e7			ld (os_tok_ptr), hl  ; save ptr to string 
9c69			 
9c69			;	ld a,0		; string term on input 
9c69			;	call strlent 
9c69			 
9c69			;	ld (os_tok_len), hl	 ; save string length 
9c69			 
9c69			;if DEBUG_FORTH_TOK 
9c69			;	ex de,hl		 
9c69			;endif 
9c69			 
9c69			;	pop hl 		; get back string pointer 
9c69			 
9c69			if DEBUG_FORTH_TOK 
9c69						DMARK "TOc" 
9c69				CALLMONITOR 
9c69			endif 
9c69 7e			.cptoken2:    ld a,(hl) 
9c6a 23				inc hl 
9c6b fe 7f			cp FORTH_END_BUFFER 
9c6d 28 29			jr z, .cptokendone2 
9c6f fe 00			cp 0 
9c71 28 25			jr z, .cptokendone2 
9c73 fe 22			cp '"' 
9c75 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9c77 fe 20			cp ' ' 
9c79 20 ee			jr nz,  .cptoken2 
9c7b			 
9c7b			; TODO consume comments held between ( and ) 
9c7b			 
9c7b				; we have a space so change to zero term for dict match later 
9c7b 2b				dec hl 
9c7c 3e 00			ld a,0 
9c7e 77				ld (hl), a 
9c7f 23				inc hl 
9c80 18 e7			jr .cptoken2 
9c82				 
9c82			 
9c82			.cptokenstr2: 
9c82				; skip all white space until either eol (because forgot to term) or end double quote 
9c82			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c82				;inc hl ; skip current double quote 
9c82 7e				ld a,(hl) 
9c83 23				inc hl 
9c84 fe 22			cp '"' 
9c86 28 e1			jr z, .cptoken2 
9c88 fe 7f			cp FORTH_END_BUFFER 
9c8a 28 0c			jr z, .cptokendone2 
9c8c fe 00			cp 0 
9c8e 28 08			jr z, .cptokendone2 
9c90 fe 20			cp ' ' 
9c92 28 02			jr z, .cptmp2 
9c94 18 ec			jr .cptokenstr2 
9c96			 
9c96			.cptmp2:	; we have a space so change to zero term for dict match later 
9c96				;dec hl 
9c96				;ld a,"-"	; TODO remove this when working 
9c96				;ld (hl), a 
9c96				;inc hl 
9c96 18 ea			jr .cptokenstr2 
9c98			 
9c98			.cptokendone2: 
9c98				;inc hl 
9c98 3e 7f			ld a, FORTH_END_BUFFER 
9c9a 77				ld (hl),a 
9c9b 23				inc hl 
9c9c 3e 21			ld a, '!' 
9c9e 77				ld (hl),a 
9c9f			 
9c9f 2a de e7			ld hl,(os_tok_ptr) 
9ca2			         
9ca2			if DEBUG_FORTH_TOK 
9ca2						DMARK "Tc1" 
9ca2				CALLMONITOR 
9ca2			endif 
9ca2			 
9ca2				; push exec string to top of return stack 
9ca2				FORTH_RSP_NEXT 
9ca2 cd 96 98			call macro_forth_rsp_next 
9ca5				endm 
# End of macro FORTH_RSP_NEXT
9ca5 c9				ret 
9ca6			 
9ca6			; Another go at the parser need to simplify the process 
9ca6			 
9ca6			forthparse: 
9ca6			 
9ca6			; 
9ca6			; line parse: 
9ca6			;       parse raw input buffer 
9ca6			;       tokenise the words 
9ca6			;       malloc new copy (for looping etc) 
9ca6			;       copy to malloc + current pc in line to start of string and add line term 
9ca6			;       save on new rsp 
9ca6			; 
9ca6			 
9ca6			; hl to point to the line to tokenise 
9ca6			 
9ca6			;	push hl 
9ca6 22 de e7			ld (os_tok_ptr), hl  ; save ptr to string 
9ca9			 
9ca9			;	ld a,0		; string term on input 
9ca9			;	call strlent 
9ca9			 
9ca9			;	ld (os_tok_len), hl	 ; save string length 
9ca9			 
9ca9			;if DEBUG_FORTH_TOK 
9ca9			;	ex de,hl		 
9ca9			;endif 
9ca9			 
9ca9			;	pop hl 		; get back string pointer 
9ca9			 
9ca9			if DEBUG_FORTH_TOK 
9ca9						DMARK "TOK" 
9ca9				CALLMONITOR 
9ca9			endif 
9ca9 7e			.ptoken2:    ld a,(hl) 
9caa 23				inc hl 
9cab fe 7f			cp FORTH_END_BUFFER 
9cad 28 29			jr z, .ptokendone2 
9caf fe 00			cp 0 
9cb1 28 25			jr z, .ptokendone2 
9cb3 fe 22			cp '"' 
9cb5 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9cb7 fe 20			cp ' ' 
9cb9 20 ee			jr nz,  .ptoken2 
9cbb			 
9cbb			; TODO consume comments held between ( and ) 
9cbb			 
9cbb				; we have a space so change to zero term for dict match later 
9cbb 2b				dec hl 
9cbc 3e 00			ld a,0 
9cbe 77				ld (hl), a 
9cbf 23				inc hl 
9cc0 18 e7			jr .ptoken2 
9cc2				 
9cc2			 
9cc2			.ptokenstr2: 
9cc2				; skip all white space until either eol (because forgot to term) or end double quote 
9cc2			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9cc2				;inc hl ; skip current double quote 
9cc2 7e				ld a,(hl) 
9cc3 23				inc hl 
9cc4 fe 22			cp '"' 
9cc6 28 e1			jr z, .ptoken2 
9cc8 fe 7f			cp FORTH_END_BUFFER 
9cca 28 0c			jr z, .ptokendone2 
9ccc fe 00			cp 0 
9cce 28 08			jr z, .ptokendone2 
9cd0 fe 20			cp ' ' 
9cd2 28 02			jr z, .ptmp2 
9cd4 18 ec			jr .ptokenstr2 
9cd6			 
9cd6			.ptmp2:	; we have a space so change to zero term for dict match later 
9cd6				;dec hl 
9cd6				;ld a,"-"	; TODO remove this when working 
9cd6				;ld (hl), a 
9cd6				;inc hl 
9cd6 18 ea			jr .ptokenstr2 
9cd8			 
9cd8			.ptokendone2: 
9cd8				;inc hl 
9cd8 3e 7f			ld a, FORTH_END_BUFFER 
9cda 77				ld (hl),a 
9cdb 23				inc hl 
9cdc 3e 21			ld a, '!' 
9cde 77				ld (hl),a 
9cdf			 
9cdf 2a de e7			ld hl,(os_tok_ptr) 
9ce2			         
9ce2			if DEBUG_FORTH_TOK 
9ce2						DMARK "TK1" 
9ce2				CALLMONITOR 
9ce2			endif 
9ce2			 
9ce2				; push exec string to top of return stack 
9ce2				FORTH_RSP_NEXT 
9ce2 cd 96 98			call macro_forth_rsp_next 
9ce5				endm 
# End of macro FORTH_RSP_NEXT
9ce5 c9				ret 
9ce6			 
9ce6			; 
9ce6			;	; malloc size + buffer pointer + if is loop flag 
9ce6			;	ld hl,(os_tok_len) 		 ; get string length 
9ce6			; 
9ce6			;	ld a,l 
9ce6			; 
9ce6			;	cp 0			; we dont want to use a null string 
9ce6			;	ret z 
9ce6			; 
9ce6			;;	add 3    ; prefix malloc with buffer for current word ptr 
9ce6			; 
9ce6			;	add 5     ; TODO when certain not over writing memory remove 
9ce6			; 
9ce6			;		 
9ce6			; 
9ce6			;if DEBUG_FORTH_TOK 
9ce6			;			DMARK "TKE" 
9ce6			;	CALLMONITOR 
9ce6			;endif 
9ce6			; 
9ce6			;	ld l,a 
9ce6			;	ld h,0 
9ce6			;;	push hl   ; save required space for the copy later 
9ce6			;	call malloc 
9ce6			;if DEBUG_FORTH_TOK 
9ce6			;			DMARK "TKM" 
9ce6			;	CALLMONITOR 
9ce6			;endif 
9ce6			;	if DEBUG_FORTH_MALLOC_GUARD 
9ce6			;		push af 
9ce6			;		call ishlzero 
9ce6			;;		ld a, l 
9ce6			;;		add h 
9ce6			;;		cp 0 
9ce6			;		pop af 
9ce6			;		 
9ce6			;		call z,malloc_error 
9ce6			;	endif 
9ce6			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9ce6			; 
9ce6			; 
9ce6			;if DEBUG_FORTH_TOK 
9ce6			;			DMARK "TKR" 
9ce6			;	CALLMONITOR 
9ce6			;endif 
9ce6			; 
9ce6			;	FORTH_RSP_NEXT 
9ce6			; 
9ce6			;	;inc hl	 ; go past current buffer pointer 
9ce6			;	;inc hl 
9ce6			;	;inc hl   ; and past if loop flag 
9ce6			;		; TODO Need to set flag  
9ce6			; 
9ce6			;	 
9ce6			;	 
9ce6			;	ex de,hl	; malloc is dest 
9ce6			;	ld hl, (os_tok_len) 
9ce6			;;	pop bc 
9ce6			;	ld c, l                
9ce6			;	ld b,0 
9ce6			;	ld hl, (os_tok_ptr) 
9ce6			; 
9ce6			;if DEBUG_FORTH_TOK 
9ce6			;			DMARK "TKT" 
9ce6			;	CALLMONITOR 
9ce6			;endif 
9ce6			; 
9ce6			;	; do str cpy 
9ce6			; 
9ce6			;	ldir      ; copy byte in hl to de 
9ce6			; 
9ce6			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9ce6			; 
9ce6			;if DEBUG_FORTH_TOK 
9ce6			; 
9ce6			;			DMARK "TKY" 
9ce6			;	CALLMONITOR 
9ce6			;endif 
9ce6			;	;ld a,0 
9ce6			;	;ld a,FORTH_END_BUFFER 
9ce6			;	ex de, hl 
9ce6			;	;dec hl			 ; go back over the space delim at the end of word 
9ce6			;	;ld (hl),a 
9ce6			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9ce6			;	ld a,FORTH_END_BUFFER 
9ce6			;	ld (hl),a 
9ce6			;	inc hl 
9ce6			;	ld a,FORTH_END_BUFFER 
9ce6			;	ld (hl),a 
9ce6			; 
9ce6			;	; init the malloc area data 
9ce6			;	; set pc for in current area 
9ce6			;	;ld hl, (os_tok_malloc) 
9ce6			;	;inc hl 
9ce6			;	;inc hl 
9ce6			;	;inc hl 
9ce6			;	;ex de,hl 
9ce6			;	;ld hl, (os_tok_malloc) 
9ce6			;	;ld (hl),e 
9ce6			;	;inc hl 
9ce6			;	;ld (hl),d 
9ce6			; 
9ce6			; 
9ce6			;	ld hl,(os_tok_malloc) 
9ce6			;if DEBUG_FORTH_PARSE_KEY 
9ce6			;			DMARK "TKU" 
9ce6			;	CALLMONITOR 
9ce6			;endif 
9ce6			; 
9ce6			;	ret 
9ce6			 
9ce6			forthexec: 
9ce6			 
9ce6			; line exec: 
9ce6			; forth parser 
9ce6			 
9ce6			; 
9ce6			;       get current exec line on rsp 
9ce6			 
9ce6				FORTH_RSP_TOS 
9ce6 cd ad 98			call macro_forth_rsp_tos 
9ce9				endm 
# End of macro FORTH_RSP_TOS
9ce9			 
9ce9			;       restore current pc - hl points to malloc of data 
9ce9			 
9ce9				;ld e, (hl) 
9ce9				;inc hl 
9ce9				;ld d, (hl) 
9ce9				;ex de,hl 
9ce9			 
9ce9			 
9ce9			exec1: 
9ce9 22 de e7			ld (os_tok_ptr), hl 
9cec			 
9cec				; copy our PC to working vars  
9cec 22 a8 ec			ld (cli_ptr), hl 
9cef 22 a6 ec			ld (cli_origptr), hl 
9cf2			 
9cf2 7e				ld a,(hl) 
9cf3 fe 7f			cp FORTH_END_BUFFER 
9cf5 c8				ret z 
9cf6			 
9cf6				; skip any nulls 
9cf6			 
9cf6 fe 00			cp 0 
9cf8 20 03			jr nz, .execword 
9cfa 23				inc hl 
9cfb 18 ec			jr exec1 
9cfd			 
9cfd			 
9cfd			.execword: 
9cfd			 
9cfd			 
9cfd			 
9cfd			if DEBUG_FORTH_PARSE_KEY 
9cfd						DMARK "KYQ" 
9cfd				CALLMONITOR 
9cfd			endif 
9cfd			;       while at start of word: 
9cfd			; get start of dict (in user area first) 
9cfd			 
9cfd 21 d5 d7		ld hl, baseram 
9d00			;ld hl, sysdict 
9d00 22 aa ec		ld (cli_nextword),hl 
9d03			;           match word at pc 
9d03			;           exec word 
9d03			;           or push to dsp 
9d03			;           forward to next token 
9d03			;           if line term pop rsp and exit 
9d03			;        
9d03			 
9d03			if DEBUG_FORTH_PARSE_KEY 
9d03						DMARK "KYq" 
9d03				CALLMONITOR 
9d03			endif 
9d03			 
9d03			; 
9d03			; word comp 
9d03			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9d03			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9d03			;    move to start of word  
9d03			;    compare word to cli_token 
9d03			 
9d03			.execpnword:	; HL at start of a word in the dictionary to check 
9d03			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9d03			;	ld (cli_ptr), hl 
9d03			 
9d03 2a aa ec			ld hl,(cli_nextword) 
9d06			 
9d06 cd a9 9d			call forth_tok_next 
9d09			; tok next start here 
9d09			;	; TODO skip compiled symbol for now 
9d09			;	inc hl 
9d09			; 
9d09			;	; save pointer to next word 
9d09			; 
9d09			;	; hl now points to the address of the next word pointer  
9d09			;	ld e, (hl) 
9d09			;	inc hl 
9d09			;	ld d, (hl) 
9d09			;	inc l 
9d09			; 
9d09			;	ex de,hl 
9d09			;if DEBUG_FORTH_PARSE_NEXTWORD 
9d09			;	push bc 
9d09			;	ld bc, (cli_nextword) 
9d09			;			DMARK "NXW" 
9d09			;	CALLMONITOR 
9d09			;	pop bc 
9d09			;endif 
9d09			; tok next end here 
9d09 22 aa ec			ld (cli_nextword), hl     ; save for next check if no match on this word 
9d0c eb				ex de, hl 
9d0d			 
9d0d			 
9d0d				; save the pointer of the current token - 1 to check against 
9d0d				 
9d0d 22 ae ec			ld (cli_token), hl   
9d10				; TODO maybe remove below save if no debug 
9d10				; save token string ptr for any debug later 
9d10 23				inc hl  
9d11 22 b0 ec			ld (cli_origtoken), hl 
9d14 2b				dec hl 
9d15				; save pointer to the start of the next dictionay word 
9d15 7e				ld a,(hl)   ; get string length 
9d16 47				ld b,a 
9d17			.execpnwordinc:  
9d17 23				inc hl 
9d18 10 fd			djnz .execpnwordinc 
9d1a 22 ac ec			ld (cli_execword), hl      ; save start of this words code 
9d1d			 
9d1d				; now check the word token against the string being parsed 
9d1d			 
9d1d 2a ae ec			ld hl,(cli_token) 
9d20 23				inc hl     ; skip string length (use zero term instead to end) 
9d21 22 ae ec			ld (cli_token), hl 
9d24			 
9d24			if DEBUG_FORTH_PARSE_KEY 
9d24						DMARK "KY2" 
9d24			endif 
9d24			if DEBUG_FORTH_PARSE_EXEC 
9d24				; see if disabled 
9d24			 
9d24				ld a, (os_view_disable) 
9d24				cp '*' 
9d24				jr z, .skip 
9d24			 
9d24				push hl 
9d24				push hl 
9d24				call clear_display 
9d24				ld de, .compword 
9d24				ld a, display_row_1 
9d24				call str_at_display 
9d24				pop de 
9d24				ld a, display_row_2 
9d24				call str_at_display 
9d24				ld hl,(cli_ptr) 
9d24				ld a,(hl) 
9d24			        ld hl, os_word_scratch 
9d24				ld (hl),a 
9d24				ld a,0 
9d24				inc hl 
9d24				ld (hl),a 	 
9d24				ld de, os_word_scratch 
9d24				ld a, display_row_2+10 
9d24				call str_at_display 
9d24				call update_display 
9d24				ld a, 100 
9d24				call aDelayInMS 
9d24				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d24				call delay250ms 
9d24				endif 
9d24				pop hl 
9d24			.skip:  
9d24			endif	 
9d24			.execpnchar:    ; compare char between token and string to parse 
9d24			 
9d24			if DEBUG_FORTH_PARSE_KEY 
9d24						DMARK "Ky3" 
9d24			endif 
9d24			if DEBUG_FORTH_PARSE_EXEC 
9d24				; see if disabled 
9d24			 
9d24				ld a, (os_view_disable) 
9d24				cp '*' 
9d24				jr z, .skip2 
9d24			 
9d24			;	call clear_display 
9d24			ld hl,(cli_token) 
9d24			ld a,(hl) 
9d24			ld (os_word_scratch),a 
9d24				ld hl,(cli_ptr) 
9d24			ld a,(hl) 
9d24				ld (os_word_scratch+1),a 
9d24				ld a,0 
9d24				ld (os_word_scratch+2),a 
9d24				ld de,os_word_scratch 
9d24				ld a,display_row_4 
9d24				call str_at_display 
9d24				call update_display 
9d24			.skip2:  
9d24			endif 
9d24 2a ae ec			ld hl,(cli_token) 
9d27 7e				ld a, (hl)	 ; char in word token 
9d28 23				inc hl 		; move to next char 
9d29 22 ae ec			ld (cli_token), hl ; and save it 
9d2c 47				ld b,a 
9d2d			 
9d2d 2a a8 ec			ld hl,(cli_ptr) ;	get the char from the string to parse 
9d30 7e				ld a,(hl) 
9d31 23				inc hl 
9d32 22 a8 ec			ld (cli_ptr), hl		; move to next char 
9d35 cd 0e 8f			call toUpper 		; make sure the input string matches case 
9d38			 
9d38			if DEBUG_FORTH_PARSE 
9d38			endif 
9d38			 
9d38				; input stream end of token is a space so get rid of it 
9d38			 
9d38			;	cp ' ' 
9d38			;	jr nz, .pnskipspace 
9d38			; 
9d38			;	ld a, 0		; make same term as word token term 
9d38			; 
9d38			;.pnskipspace: 
9d38			 
9d38			if DEBUG_FORTH_PARSE_KEY 
9d38						DMARK "KY7" 
9d38			endif 
9d38 b8				cp b 
9d39 c2 4f 9d			jp nz, .execpnskipword	 ; no match so move to next word 
9d3c				 
9d3c			;    if same 
9d3c			;       scan for string terms 0 for token and 32 for input 
9d3c			 
9d3c				 
9d3c			if DEBUG_FORTH_PARSE_KEY 
9d3c						DMARK "KY8" 
9d3c			endif 
9d3c			 
9d3c 80				add b			 
9d3d fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9d3f							; TODO need to make sure last word in zero term string is accounted for 
9d3f 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9d41			 
9d41			 
9d41				; at end of both strings so both are exact match 
9d41			 
9d41			;       skip ptr for next word 
9d41			 
9d41 2a a8 ec			ld hl,(cli_ptr) 	; at input string term 
9d44 23				inc hl			 ; at next char 
9d45 22 a8 ec			ld (cli_ptr), hl     ; save for next round of the parser 
9d48 22 a6 ec			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9d4b				 
9d4b				 
9d4b			if DEBUG_FORTH_PARSE_KEY 
9d4b						DMARK "KY3" 
9d4b			endif 
9d4b			 
9d4b			 
9d4b			 
9d4b			;       exec code block 
9d4b			if DEBUG_FORTH_JP 
9d4b				call clear_display 
9d4b				call update_display 
9d4b				call delay1s 
9d4b				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d4b				ld a,h 
9d4b				ld hl, os_word_scratch 
9d4b				call hexout 
9d4b				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d4b				ld a,l 
9d4b				ld hl, os_word_scratch+2 
9d4b				call hexout 
9d4b				ld hl, os_word_scratch+4 
9d4b				ld a,0 
9d4b				ld (hl),a 
9d4b				ld de,os_word_scratch 
9d4b				call str_at_display 
9d4b					ld a, display_row_2 
9d4b					call str_at_display 
9d4b				ld de, (cli_origtoken) 
9d4b				ld a, display_row_1+10 
9d4b					call str_at_display 
9d4b			 
9d4b				ld a,display_row_1 
9d4b				ld de, .foundword 
9d4b				ld a, display_row_3 
9d4b				call str_at_display 
9d4b				call update_display 
9d4b				call delay1s 
9d4b				call delay1s 
9d4b				call delay1s 
9d4b			endif 
9d4b			 
9d4b			if DEBUG_FORTH_PARSE_KEY 
9d4b						DMARK "KYj" 
9d4b			endif 
9d4b				; TODO save the word pointer in this exec 
9d4b			 
9d4b 2a ac ec			ld hl,(cli_execword) 
9d4e e9				jp (hl) 
9d4f			 
9d4f			 
9d4f			;    if not same 
9d4f			;	scan for zero term 
9d4f			;	get ptr for next word 
9d4f			;	goto word comp 
9d4f			 
9d4f			.execpnskipword:	; get pointer to next word 
9d4f 2a aa ec			ld hl,(cli_nextword) 
9d52			 
9d52 7e				ld a,(hl) 
9d53 fe 00			cp WORD_SYS_END 
9d55			;	cp 0 
9d55 28 09			jr z, .execendofdict			 ; at end of words 
9d57			 
9d57			if DEBUG_FORTH_PARSE_KEY 
9d57						DMARK "KY4" 
9d57			endif 
9d57			if DEBUG_FORTH_PARSE_EXEC 
9d57			 
9d57				; see if disabled 
9d57			 
9d57				ld a, (os_view_disable) 
9d57				cp '*' 
9d57				jr z, .noskip 
9d57			 
9d57			 
9d57				ld de, .nowordfound 
9d57				ld a, display_row_3 
9d57				call str_at_display 
9d57				call update_display 
9d57				ld a, 100 
9d57				call aDelayInMS 
9d57				 
9d57				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d57					call delay250ms 
9d57				endif 
9d57			.noskip:  
9d57			 
9d57			endif	 
9d57			 
9d57 2a a6 ec			ld hl,(cli_origptr) 
9d5a 22 a8 ec			ld (cli_ptr),hl 
9d5d			 
9d5d			if DEBUG_FORTH_PARSE_KEY 
9d5d						DMARK "KY5" 
9d5d			endif 
9d5d c3 03 9d			jp .execpnword			; else go to next word 
9d60			 
9d60			.execendofdict:  
9d60			 
9d60			if DEBUG_FORTH_PARSE_KEY 
9d60						DMARK "KYe" 
9d60			endif 
9d60			if DEBUG_FORTH_PARSE_EXEC 
9d60				; see if disabled 
9d60			 
9d60				ld a, (os_view_disable) 
9d60				cp '*' 
9d60				jr z, .ispskip 
9d60			 
9d60				call clear_display 
9d60				call update_display 
9d60				call delay1s 
9d60				ld de, (cli_origptr) 
9d60				ld a, display_row_1 
9d60				call str_at_display 
9d60				 
9d60				ld de, .enddict 
9d60				ld a, display_row_3 
9d60				call str_at_display 
9d60				call update_display 
9d60				ld a, 100 
9d60				call aDelayInMS 
9d60				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d60				call delay1s 
9d60				call delay1s 
9d60				call delay1s 
9d60				endif 
9d60			.ispskip:  
9d60				 
9d60			endif	 
9d60			 
9d60			 
9d60			 
9d60				; if the word is not a keyword then must be a literal so push it to stack 
9d60			 
9d60			; push token to stack to end of word 
9d60			 
9d60				STACKFRAME ON $1efe $2f9f 
9d60				if DEBUG_STACK_IMB 
9d60					if ON 
9d60						exx 
9d60						ld de, $1efe 
9d60						ld a, d 
9d60						ld hl, curframe 
9d60						call hexout 
9d60						ld a, e 
9d60						ld hl, curframe+2 
9d60						call hexout 
9d60						ld hl, $1efe 
9d60						push hl 
9d60						ld hl, $2f9f 
9d60						push hl 
9d60						exx 
9d60					endif 
9d60				endif 
9d60			endm 
# End of macro STACKFRAME
9d60			 
9d60 2a de e7		ld hl,(os_tok_ptr) 
9d63 cd 58 9a		call forth_apush 
9d66			 
9d66				STACKFRAMECHK ON $1efe $2f9f 
9d66				if DEBUG_STACK_IMB 
9d66					if ON 
9d66						exx 
9d66						ld hl, $2f9f 
9d66						pop de   ; $2f9f 
9d66						call cmp16 
9d66						jr nz, .spnosame 
9d66						ld hl, $1efe 
9d66						pop de   ; $1efe 
9d66						call cmp16 
9d66						jr z, .spfrsame 
9d66						.spnosame: call showsperror 
9d66						.spfrsame: nop 
9d66						exx 
9d66					endif 
9d66				endif 
9d66			endm 
# End of macro STACKFRAMECHK
9d66			 
9d66			execnext: 
9d66			 
9d66			if DEBUG_FORTH_PARSE_KEY 
9d66						DMARK "KY>" 
9d66			endif 
9d66			; move past token to next word 
9d66			 
9d66 2a de e7		ld hl, (os_tok_ptr) 
9d69 3e 00		ld a, 0 
9d6b 01 ff 00		ld bc, 255     ; input buffer size 
9d6e ed b1		cpir 
9d70			 
9d70			if DEBUG_FORTH_PARSE_KEY 
9d70						DMARK "KY!" 
9d70				CALLMONITOR 
9d70			endif	 
9d70			; TODO this might place hl on the null, so will need to forward on??? 
9d70			;inc hl   ; see if this gets onto the next item 
9d70			 
9d70			 
9d70			; TODO pass a pointer to the buffer to push 
9d70			; TODO call function to push 
9d70			 
9d70			; look for end of input 
9d70			 
9d70			;inc hl 
9d70			;ld a,(hl) 
9d70			;cp FORTH_END_BUFFER 
9d70			;ret z 
9d70			 
9d70			 
9d70 c3 e9 9c		jp exec1 
9d73			 
9d73			 
9d73			 
9d73			 
9d73			 
9d73			 
9d73			 
9d73			 
9d73			 
9d73			findnexttok: 
9d73			 
9d73				; hl is pointer to move 
9d73				; de is the token to locate 
9d73			 
9d73					if DEBUG_FORTH 
9d73						DMARK "NTK" 
9d73						CALLMONITOR 
9d73					endif 
9d73 d5				push de 
9d74			 
9d74			.fnt1:	 
9d74				; find first char of token to locate 
9d74			 
9d74 1a				ld a, (de) 
9d75 4f				ld c,a 
9d76 7e				ld a,(hl) 
9d77 cd 0e 8f			call toUpper 
9d7a					if DEBUG_FORTH 
9d7a						DMARK "NT1" 
9d7a						CALLMONITOR 
9d7a					endif 
9d7a b9				cp c 
9d7b			 
9d7b 28 03			jr z, .fnt2cmpmorefirst	 
9d7d			 
9d7d				; first char not found move to next char 
9d7d			 
9d7d 23				inc hl 
9d7e 18 f4			jr .fnt1 
9d80			 
9d80			.fnt2cmpmorefirst:	 
9d80				; first char of token found.  
9d80			 
9d80 e5				push hl     ; save start of token just in case it is the right one 
9d81 d9				exx 
9d82 e1				pop hl        ; save it to hl' 
9d83 d9				exx 
9d84			 
9d84			 
9d84			.fnt2cmpmore:	 
9d84				; compare the rest 
9d84				 
9d84 23				inc hl 
9d85 13				inc de 
9d86				 
9d86 1a				ld a, (de) 
9d87 4f				ld c,a 
9d88 7e				ld a,(hl) 
9d89 cd 0e 8f			call toUpper 
9d8c			 
9d8c					if DEBUG_FORTH 
9d8c						DMARK "NT2" 
9d8c						CALLMONITOR 
9d8c					endif 
9d8c				; c has the token to find char 
9d8c				; a has the mem to scan char 
9d8c			 
9d8c b9				cp c 
9d8d 28 04			jr z,.fntmatch1 
9d8f			 
9d8f				; they are not the same 
9d8f			 
9d8f					if DEBUG_FORTH 
9d8f						DMARK "NT3" 
9d8f						CALLMONITOR 
9d8f					endif 
9d8f d1				pop de	; reset de token to look for 
9d90 d5				push de 
9d91 18 e1			jr .fnt1 
9d93				 
9d93			.fntmatch1: 
9d93			 
9d93				; is the same char a null which means we might have a full hit? 
9d93					if DEBUG_FORTH 
9d93						DMARK "NT4" 
9d93						CALLMONITOR 
9d93					endif 
9d93			 
9d93 fe 00			cp 0 
9d95 28 0b			jr z, .fntmatchyes 
9d97			 
9d97				; are we at the end of the token to find? 
9d97			 
9d97					if DEBUG_FORTH 
9d97						DMARK "NT5" 
9d97						CALLMONITOR 
9d97					endif 
9d97 3e 00			ld a, 0 
9d99 b9				cp c 
9d9a			 
9d9a c2 84 9d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9d9d			 
9d9d					if DEBUG_FORTH 
9d9d						DMARK "NT6" 
9d9d						CALLMONITOR 
9d9d					endif 
9d9d				; token to find is exhusted but no match to stream 
9d9d			 
9d9d				; restore tok pointer and continue on 
9d9d d1				pop de 
9d9e d5				push de 
9d9f c3 74 9d			jp .fnt1 
9da2			 
9da2			 
9da2			.fntmatchyes: 
9da2			 
9da2				; hl now contains the end of the found token 
9da2			 
9da2				; get rid of saved token pointer to find 
9da2			 
9da2 d1				pop de 
9da3			 
9da3					if DEBUG_FORTH 
9da3						DMARK "NT9" 
9da3						CALLMONITOR 
9da3					endif 
9da3			 
9da3				; hl will be on the null term so forward on 
9da3			 
9da3				; get back the saved start of the token 
9da3			 
9da3 d9				exx 
9da4 e5				push hl     ; save start of token just in case it is the right one 
9da5 d9				exx 
9da6 e1				pop hl        ; save it to hl 
9da7			 
9da7 c9				ret 
9da8			 
9da8			 
9da8			; LIST needs to find a specific token   
9da8			; FORGET needs to find a spefici token 
9da8			 
9da8			; SAVE needs to find all tokens by flag 
9da8			; WORDS just needs to scan through all  by flag 
9da8			; UWORDS needs to scan through all by flag 
9da8			 
9da8			 
9da8			; given hl as pointer to start of dict look up string 
9da8			; return hl as pointer to start of word block 
9da8			; or 0 if not found 
9da8			 
9da8			forth_find_tok: 
9da8 c9				ret 
9da9			 
9da9			; given hl as pointer to dict structure 
9da9			; move to the next dict block structure 
9da9			 
9da9			forth_tok_next: 
9da9				; hl now points to the address of the next word pointer  
9da9				; TODO skip compiled symbol for now 
9da9			;	push de 
9da9 23				inc hl 
9daa 5e				ld e, (hl) 
9dab 23				inc hl 
9dac 56				ld d, (hl) 
9dad 23				inc hl 
9dae			 
9dae eb				ex de,hl 
9daf			if DEBUG_FORTH_PARSE_NEXTWORD 
9daf				push bc 
9daf				ld bc, (cli_nextword) 
9daf						DMARK "NXW" 
9daf				CALLMONITOR 
9daf				pop bc 
9daf			endif 
9daf			;	pop de	 
9daf c9				ret 
9db0			 
9db0			 
9db0			 
9db0			; eof 
# End of file forth_parserv5.asm
9db0				include "forth_wordsv4.asm" 
9db0			 
9db0			; the core word dictionary v4 
9db0			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9db0			 
9db0			; this is a linked list for each of the system words used 
9db0			; user defined words will follow the same format but will be in ram 
9db0			 
9db0			 
9db0			; 
9db0			; 
9db0			; define linked list: 
9db0			; 
9db0			; 1. compiled byte op code 
9db0			; 2. len of text word 
9db0			; 3. text word 
9db0			; 4. ptr to next dictionary word 
9db0			; 5. asm, calls etc for the word 
9db0			; 
9db0			;  if 1 == 0 then last word in dict  
9db0			;   
9db0			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9db0			;  
9db0			;  
9db0			; create basic standard set of words 
9db0			; 
9db0			;  
9db0			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9db0			; 2DUP 2DROP 2SWAP  
9db0			; @ C@ - get byte  
9db0			; ! C! - store byte 
9db0			; 0< true if less than zero 
9db0			; 0= true if zero 
9db0			; < >  
9db0			; = true if same 
9db0			; variables 
9db0			 
9db0			 
9db0			; Hardware specific words I may need 
9db0			; 
9db0			; IN OUT  
9db0			; calls to key util functions 
9db0			; calls to hardward abstraction stuff 
9db0			; easy control of frame buffers and lcd i/o 
9db0			; keyboard  
9db0			 
9db0			 
9db0			;DICT: macro 
9db0			; op_code, len, word, next 
9db0			;    word: 
9db0			;    db op_code 
9db0			;    ds word zero term 
9db0			;    dw next 
9db0			;    endm 
9db0			 
9db0			 
9db0			 
9db0			 
9db0			; op code 1 is a flag for user define words which are to be handled differently 
9db0			 
9db0			 
9db0			; 
9db0			; 
9db0			;    TODO on entry to a word this should be the expected environment 
9db0			;    hl - tos value if number then held, if string this is the ptr 
9db0			;    de -  
9db0			 
9db0			 
9db0			; opcode ranges 
9db0			; 0 - end of word dict 
9db0			; 255 - user define words 
9db0			 
9db0			sysdict: 
9db0			include "forth_opcodes.asm" 
9db0			; op codes for forth keywords 
9db0			; free to use code 0  
9db0				OPCODE_HEAP: equ  1 
9db0				OPCODE_EXEC: equ 2 
9db0				OPCODE_DUP: equ 3 
9db0				OPCODE_SWAP: equ 4 
9db0				OPCODE_COLN: equ 5 
9db0				OPCODE_SCOLN: equ 6 
9db0				OPCODE_DROP: equ 7 
9db0				OPCODE_DUP2: equ 8 
9db0				OPCODE_DROP2: equ 9 
9db0				OPCODE_SWAP2: equ 10 
9db0				OPCODE_AT: equ 11 
9db0				OPCODE_CAT: equ 12 
9db0				OPCODE_BANG: equ 13 
9db0				OPCODE_CBANG: equ 14 
9db0				OPCODE_SCALL: equ 15 
9db0				OPCODE_DEPTH: equ 16 
9db0				OPCODE_OVER: equ 17 
9db0				OPCODE_PAUSE: equ 18 
9db0				OPCODE_PAUSES: equ 19 
9db0				OPCODE_ROT: equ 20 
9db0			;free to reuse	OPCODE_WORDS: equ 21 
9db0			        OPCODE_NOT: equ 21 
9db0				OPCODE_UWORDS: equ 22 
9db0				OPCODE_BP: equ 23 
9db0				OPCODE_MONITOR: equ 24  
9db0				OPCODE_MALLOC: equ 25 
9db0				OPCODE_FREE: equ 26 
9db0				OPCODE_LIST: equ 27 
9db0				OPCODE_FORGET: equ 28 
9db0				OPCODE_NOP: equ 29 
9db0				OPCODE_COMO: equ 30 
9db0				OPCODE_COMC: equ 31 
9db0			;free to reuse	OPCODE_ENDCORE: equ 32 
9db0				OPCODE_AFTERSOUND: equ 33 
9db0				OPCODE_GP2: equ 34 
9db0				OPCODE_GP3: equ 35 
9db0				OPCODE_GP4: equ 36 
9db0				OPCODE_SIN: equ 37 
9db0				OPCODE_SOUT: equ 38 
9db0				OPCODE_SPIO: equ 39 
9db0				OPCODE_SPICEH: equ 40 
9db0				OPCODE_SPIOb: equ 41 
9db0				OPCODE_SPII: equ 42 
9db0				OPCODE_SESEL: equ 43 
9db0				OPCODE_CARTDEV: equ 44 
9db0			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9db0				OPCODE_FB: equ 46 
9db0				OPCODE_EMIT: equ 47 
9db0				OPCODE_DOTH: equ 48 
9db0				OPCODE_DOTF: equ 49 
9db0				OPCODE_DOT: equ 50 
9db0				OPCODE_CLS: equ 51 
9db0				OPCODE_DRAW: equ 52 
9db0				OPCODE_DUMP: equ 53 
9db0				OPCODE_CDUMP: equ 54 
9db0				OPCODE_DAT: equ 55 
9db0				OPCODE_HOME: equ 56 
9db0				OPCODE_SPACE: equ 57 
9db0				OPCODE_SPACES: equ 58 
9db0				OPCODE_SCROLL: equ 59 
9db0				OPCODE_ATQ: equ 60 
9db0				OPCODE_AUTODSP: equ 61 
9db0				OPCODE_MENU: equ 62 
9db0			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9db0				OPCODE_THEN: equ 64 
9db0				OPCODE_ELSE: equ 65 
9db0				OPCODE_DO: equ 66 
9db0				OPCODE_LOOP: equ 67 
9db0				OPCODE_I: equ 68 
9db0				OPCODE_DLOOP: equ 69  
9db0				OPCODE_REPEAT: equ 70  
9db0				OPCODE_UNTIL: equ 71 
9db0				OPCODE_ENDFLOW: equ 72 
9db0				OPCODE_WAITK: equ 73 
9db0				OPCODE_ACCEPT: equ 74 
9db0				OPCODE_EDIT: equ 75 
9db0			;free to reuse	OPCODE_ENDKEY: equ 76 
9db0				OPCODE_LZERO: equ 77 
9db0				OPCODE_TZERO: equ 78 
9db0				OPCODE_LESS: equ 79 
9db0				OPCODE_GT: equ 80 
9db0				OPCODE_EQUAL: equ 81  
9db0			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9db0				OPCODE_NEG: equ 83 
9db0				OPCODE_DIV: equ 84 
9db0				OPCODE_MUL: equ 85 
9db0				OPCODE_MIN: equ 86 
9db0				OPCODE_MAX: equ 87 
9db0				OPCODE_RND16: equ 88 
9db0				OPCODE_RND8: equ 89 
9db0				OPCODE_RND: equ 90 
9db0			;free to reuse	OPCODE_ENDMATHS: equ 91  
9db0				OPCODE_BYNAME: equ 92 
9db0				OPCODE_DIR: equ 93 
9db0				OPCODE_SAVE: equ 94 
9db0				OPCODE_LOAD: equ 95 
9db0				OPCODE_BSAVE: equ 96 
9db0				OPCODE_BLOAD: equ 97 
9db0				OPCODE_SEO: equ 98  
9db0				OPCODE_SEI: equ 99 
9db0				OPCODE_SFREE: equ 100 
9db0				OPCODE_SIZE: equ 101 
9db0				OPCODE_CREATE: equ 102 
9db0				OPCODE_APPEND: equ 103 
9db0				OPCODE_SDEL: equ 104 
9db0				OPCODE_OPEN: equ 105 
9db0				OPCODE_READ: equ 106 
9db0				OPCODE_EOF: equ 106 
9db0				OPCODE_FORMAT: equ 107 
9db0				OPCODE_LABEL: equ 108 
9db0				OPCODE_LABELS: equ 109 
9db0			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9db0				OPCODE_UPPER: equ 111 
9db0				OPCODE_LOWER: equ 112 
9db0				OPCODE_SUBSTR: equ 113 
9db0				OPCODE_LEFT: equ 114 
9db0				OPCODE_RIGHT: equ 115 
9db0				OPCODE_STR2NUM: equ 116 
9db0				OPCODE_NUM2STR: equ 117 
9db0				OPCODE_CONCAT: equ 118 
9db0				OPCODE_FIND: equ 119 
9db0				OPCODE_LEN: equ 120 
9db0				OPCODE_CHAR: equ 121 
9db0			; free to reuse	OPCODE_STRLEN: equ 122 
9db0			; free to reuse	OPCODE_ENDSTR: equ 123 
9db0				OPCODE_V0S: equ 124 
9db0				OPCODE_V0Q: equ 125 
9db0				OPCODE_V1S: equ 126 
9db0				OPCODE_V1Q: equ 127 
9db0				OPCODE_V2S: equ 128 
9db0				OPCODE_V2Q: equ 129 
9db0				OPCODE_V3S: equ 130 
9db0				OPCODE_V3Q: equ 131 
9db0			;free to reuse	OPCODE_END: equ 132 
9db0				OPCODE_ZDUP: equ 133 
9db0			 
9db0			; eof 
# End of file forth_opcodes.asm
9db0			 
9db0			include "forth_words_core.asm" 
9db0			 
9db0			; | ## Core Words 
9db0			 
9db0			;if MALLOC_4 
9db0			 
9db0			.HEAP: 
9db0				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9db0 15				db WORD_SYS_CORE+OPCODE_HEAP             
9db1 ef 9d			dw .EXEC            
9db3 05				db 4 + 1 
9db4 .. 00			db "HEAP",0              
9db9				endm 
# End of macro CWHEAD
9db9			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9db9			; | | u1 - Current number of bytes in the heap 
9db9			; | | u2 - Remaining bytes left on the heap 
9db9			; | |  
9db9			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9db9			 
9db9			 
9db9					if DEBUG_FORTH_WORDS_KEY 
9db9						DMARK "HEP" 
9db9 f5				push af  
9dba 3a ce 9d			ld a, (.dmark)  
9dbd 32 b7 ee			ld (debug_mark),a  
9dc0 3a cf 9d			ld a, (.dmark+1)  
9dc3 32 b8 ee			ld (debug_mark+1),a  
9dc6 3a d0 9d			ld a, (.dmark+2)  
9dc9 32 b9 ee			ld (debug_mark+2),a  
9dcc 18 03			jr .pastdmark  
9dce ..			.dmark: db "HEP"  
9dd1 f1			.pastdmark: pop af  
9dd2			endm  
# End of macro DMARK
9dd2						CALLMONITOR 
9dd2 cd 62 93			call break_point_state  
9dd5				endm  
# End of macro CALLMONITOR
9dd5					endif 
9dd5 2a df d7				ld hl, (free_list )      
9dd8 11 e4 d7				ld de, heap_start 
9ddb			 
9ddb ed 52				sbc hl, de  
9ddd			 
9ddd cd ef 98				call forth_push_numhl 
9de0			 
9de0			 
9de0 ed 5b df d7			ld de, (free_list )      
9de4 21 c3 e4				ld hl, heap_end 
9de7			 
9de7 ed 52				sbc hl, de 
9de9			 
9de9 cd ef 98				call forth_push_numhl 
9dec					 
9dec			 
9dec					 
9dec			 
9dec			 
9dec			 
9dec					NEXTW 
9dec c3 58 9c			jp macro_next 
9def				endm 
# End of macro NEXTW
9def			;endif 
9def			 
9def			.EXEC: 
9def			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9def			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9def			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9def			;; > > 
9def			;; > >   
9def			;	STACKFRAME OFF $5efe $5f9f 
9def			; 
9def			;		if DEBUG_FORTH_WORDS_KEY 
9def			;			DMARK "EXE" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			; 
9def			;	FORTH_DSP_VALUEHL 
9def			; 
9def			;	FORTH_DSP_POP 
9def			; 
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EX1" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			;;	ld e,(hl) 
9def			;;	inc hl 
9def			;;	ld d,(hl) 
9def			;;	ex de,hl 
9def			; 
9def			;;		if DEBUG_FORTH_WORDS 
9def			;;			DMARK "EX2" 
9def			;;			CALLMONITOR 
9def			;;		endif 
9def			;	push hl 
9def			; 
9def			;	;ld a, 0 
9def			;	;ld a, FORTH_END_BUFFER 
9def			;	call strlenz 
9def			;	inc hl   ; include zero term to copy 
9def			;	inc hl   ; include term 
9def			;	inc hl   ; include term 
9def			;	ld b,0 
9def			;	ld c,l 
9def			;	pop hl 
9def			;	ld de, execscratch 
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EX3" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			;	ldir 
9def			; 
9def			; 
9def			;	ld hl, execscratch 
9def			; 
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EXe" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			; 
9def			;	call forthparse 
9def			;	call forthexec 
9def			;;	call forthexec_cleanup 
9def			;;	call forthparse 
9def			;;	call forthexec 
9def			; 
9def			;	STACKFRAMECHK OFF $5efe $5f9f 
9def			; 
9def			;	; an immediate word so no need to process any more words 
9def			;	ret 
9def			;	NEXTW 
9def			 
9def			; dead code - old version  
9def			;	FORTH_RSP_NEXT 
9def			 
9def			;  
9def			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9def			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9def			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9def			;	push hl 
9def			;	push de 
9def			;	push bc 
9def			; 
9def			; 
9def			;		if DEBUG_FORTH_WORDS_KEY 
9def			;			DMARK "EXR" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			; 
9def			; 
9def			; 
9def			;	;v5 FORTH_DSP_VALUE 
9def			;	FORTH_DSP_VALUEHL 
9def			; 
9def			;	; TODO do string type checks 
9def			; 
9def			;;v5	inc hl   ; skip type 
9def			; 
9def			;	push hl  ; source code  
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EX1" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			;	ld a, 0 
9def			;	call strlent 
9def			; 
9def			;	inc hl 
9def			;	inc hl 
9def			;	inc hl 
9def			;	inc hl 
9def			; 
9def			;	push hl    ; size 
9def			; 
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EX2" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			;	call malloc 
9def			; 
9def			;	ex de, hl    ; de now contains malloc area 
9def			;	pop bc   	; get byte count 
9def			;	pop hl      ; get string to copy 
9def			; 
9def			;	push de     ; save malloc for free later 
9def			; 
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EX3" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			;	ldir       ; duplicate string 
9def			; 
9def			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9def			;	 
9def			;	; TODO fix the parse would be better than this...  
9def			;	ex de, hl 
9def			;	dec hl 
9def			;	ld a, 0 
9def			;	ld (hl), a 
9def			;	dec hl 
9def			;	ld a, ' ' 
9def			;	ld (hl), a 
9def			;	dec hl 
9def			;	ld (hl), a 
9def			; 
9def			;	dec hl 
9def			;	ld (hl), a 
9def			; 
9def			; 
9def			;	FORTH_DSP_POP  
9def			; 
9def			;	pop hl     
9def			;	push hl    ; save malloc area 
9def			; 
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EX4" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			; 
9def			;	call forthparse 
9def			;	call forthexec 
9def			;	 
9def			;	pop hl 
9def			;	if DEBUG_FORTH_WORDS 
9def			;		DMARK "EX5" 
9def			;		CALLMONITOR 
9def			;	endif 
9def			; 
9def			;	if FORTH_ENABLE_FREE 
9def			;	call free 
9def			;	endif 
9def			; 
9def			;	if DEBUG_FORTH_WORDS 
9def			;		DMARK "EX6" 
9def			;		CALLMONITOR 
9def			;	endif 
9def			; 
9def			;	pop bc 
9def			;	pop de 
9def			;	pop hl 
9def			;;	FORTH_RSP_POP	  
9def			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9def			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9def			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9def			; 
9def			;	if DEBUG_FORTH_WORDS 
9def			;		DMARK "EX7" 
9def			;		CALLMONITOR 
9def			;	endif 
9def			;	NEXTW 
9def			 
9def			;.STKEXEC: 
9def			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9def			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9def			; 
9def			; 
9def			;		if DEBUG_FORTH_WORDS_KEY 
9def			;			DMARK "STX" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			; 
9def			;	FORTH_DSP_VALUEHL 
9def			; 
9def			;	ld (store_tmp1), hl    ; count 
9def			; 
9def			;	FORTH_DSP_POP 
9def			;.stkexec1: 
9def			;	ld hl, (store_tmp1)   ; count 
9def			;	ld a, 0 
9def			;	cp l 
9def			;	ret z 
9def			; 
9def			;	dec hl 
9def			;	ld (store_tmp1), hl    ; count 
9def			;	 
9def			;	FORTH_DSP_VALUEHL 
9def			;	push hl 
9def			;	 
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EXp" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			;	FORTH_DSP_POP 
9def			; 
9def			;	call strlenz 
9def			;	inc hl   ; include zero term to copy 
9def			;	inc hl   ; include zero term to copy 
9def			;	inc hl   ; include zero term to copy 
9def			;	ld b,0 
9def			;	ld c,l 
9def			;	pop hl 
9def			;	ld de, execscratch 
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EX3" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			;	ldir 
9def			; 
9def			; 
9def			;	ld hl, execscratch 
9def			; 
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EXP" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			; 
9def			;	call forthparse 
9def			;	ld hl, execscratch 
9def			;		if DEBUG_FORTH_WORDS 
9def			;			DMARK "EXx" 
9def			;			CALLMONITOR 
9def			;		endif 
9def			;	call forthexec 
9def			; 
9def			;	jp .stkexec1 
9def			; 
9def			;	ret 
9def			 
9def			 
9def			.DUP: 
9def				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9def 17				db WORD_SYS_CORE+OPCODE_DUP             
9df0 65 9e			dw .ZDUP            
9df2 04				db 3 + 1 
9df3 .. 00			db "DUP",0              
9df7				endm 
# End of macro CWHEAD
9df7			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9df7			 
9df7					if DEBUG_FORTH_WORDS_KEY 
9df7						DMARK "DUP" 
9df7 f5				push af  
9df8 3a 0c 9e			ld a, (.dmark)  
9dfb 32 b7 ee			ld (debug_mark),a  
9dfe 3a 0d 9e			ld a, (.dmark+1)  
9e01 32 b8 ee			ld (debug_mark+1),a  
9e04 3a 0e 9e			ld a, (.dmark+2)  
9e07 32 b9 ee			ld (debug_mark+2),a  
9e0a 18 03			jr .pastdmark  
9e0c ..			.dmark: db "DUP"  
9e0f f1			.pastdmark: pop af  
9e10			endm  
# End of macro DMARK
9e10						CALLMONITOR 
9e10 cd 62 93			call break_point_state  
9e13				endm  
# End of macro CALLMONITOR
9e13					endif 
9e13			 
9e13					FORTH_DSP 
9e13 cd ac 9a			call macro_forth_dsp 
9e16				endm 
# End of macro FORTH_DSP
9e16			 
9e16 7e					ld a, (HL) 
9e17 fe 01				cp DS_TYPE_STR 
9e19 20 25				jr nz, .dupinum 
9e1b			 
9e1b					; push another string 
9e1b			 
9e1b					FORTH_DSP_VALUEHL     		 
9e1b cd e6 9a			call macro_dsp_valuehl 
9e1e				endm 
# End of macro FORTH_DSP_VALUEHL
9e1e			 
9e1e				if DEBUG_FORTH_WORDS 
9e1e					DMARK "DUs" 
9e1e f5				push af  
9e1f 3a 33 9e			ld a, (.dmark)  
9e22 32 b7 ee			ld (debug_mark),a  
9e25 3a 34 9e			ld a, (.dmark+1)  
9e28 32 b8 ee			ld (debug_mark+1),a  
9e2b 3a 35 9e			ld a, (.dmark+2)  
9e2e 32 b9 ee			ld (debug_mark+2),a  
9e31 18 03			jr .pastdmark  
9e33 ..			.dmark: db "DUs"  
9e36 f1			.pastdmark: pop af  
9e37			endm  
# End of macro DMARK
9e37					CALLMONITOR 
9e37 cd 62 93			call break_point_state  
9e3a				endm  
# End of macro CALLMONITOR
9e3a				endif 
9e3a cd 5d 99				call forth_push_str 
9e3d			 
9e3d					NEXTW 
9e3d c3 58 9c			jp macro_next 
9e40				endm 
# End of macro NEXTW
9e40			 
9e40			 
9e40			.dupinum: 
9e40					 
9e40			 
9e40			 
9e40					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e40 cd e6 9a			call macro_dsp_valuehl 
9e43				endm 
# End of macro FORTH_DSP_VALUEHL
9e43			 
9e43				; TODO add floating point number detection 
9e43			 
9e43				if DEBUG_FORTH_WORDS 
9e43					DMARK "DUi" 
9e43 f5				push af  
9e44 3a 58 9e			ld a, (.dmark)  
9e47 32 b7 ee			ld (debug_mark),a  
9e4a 3a 59 9e			ld a, (.dmark+1)  
9e4d 32 b8 ee			ld (debug_mark+1),a  
9e50 3a 5a 9e			ld a, (.dmark+2)  
9e53 32 b9 ee			ld (debug_mark+2),a  
9e56 18 03			jr .pastdmark  
9e58 ..			.dmark: db "DUi"  
9e5b f1			.pastdmark: pop af  
9e5c			endm  
# End of macro DMARK
9e5c					CALLMONITOR 
9e5c cd 62 93			call break_point_state  
9e5f				endm  
# End of macro CALLMONITOR
9e5f				endif 
9e5f			 
9e5f cd ef 98				call forth_push_numhl 
9e62					NEXTW 
9e62 c3 58 9c			jp macro_next 
9e65				endm 
# End of macro NEXTW
9e65			.ZDUP: 
9e65				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9e65 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9e66 9d 9e			dw .SWAP            
9e68 05				db 4 + 1 
9e69 .. 00			db "?DUP",0              
9e6e				endm 
# End of macro CWHEAD
9e6e			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9e6e			 
9e6e					if DEBUG_FORTH_WORDS_KEY 
9e6e						DMARK "qDU" 
9e6e f5				push af  
9e6f 3a 83 9e			ld a, (.dmark)  
9e72 32 b7 ee			ld (debug_mark),a  
9e75 3a 84 9e			ld a, (.dmark+1)  
9e78 32 b8 ee			ld (debug_mark+1),a  
9e7b 3a 85 9e			ld a, (.dmark+2)  
9e7e 32 b9 ee			ld (debug_mark+2),a  
9e81 18 03			jr .pastdmark  
9e83 ..			.dmark: db "qDU"  
9e86 f1			.pastdmark: pop af  
9e87			endm  
# End of macro DMARK
9e87						CALLMONITOR 
9e87 cd 62 93			call break_point_state  
9e8a				endm  
# End of macro CALLMONITOR
9e8a					endif 
9e8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e8a cd e6 9a			call macro_dsp_valuehl 
9e8d				endm 
# End of macro FORTH_DSP_VALUEHL
9e8d			 
9e8d e5					push hl 
9e8e			 
9e8e					; is it a zero? 
9e8e			 
9e8e 3e 00				ld a, 0 
9e90 84					add h 
9e91 85					add l 
9e92			 
9e92 e1					pop hl 
9e93			 
9e93 fe 00				cp 0 
9e95 28 03				jr z, .dup2orig 
9e97			 
9e97			 
9e97 cd ef 98				call forth_push_numhl 
9e9a			 
9e9a			 
9e9a				; TODO add floating point number detection 
9e9a			 
9e9a			.dup2orig: 
9e9a			 
9e9a					NEXTW 
9e9a c3 58 9c			jp macro_next 
9e9d				endm 
# End of macro NEXTW
9e9d			.SWAP: 
9e9d				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9e9d 18				db WORD_SYS_CORE+OPCODE_SWAP             
9e9e dc 9e			dw .COLN            
9ea0 05				db 4 + 1 
9ea1 .. 00			db "SWAP",0              
9ea6				endm 
# End of macro CWHEAD
9ea6			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9ea6					if DEBUG_FORTH_WORDS_KEY 
9ea6						DMARK "SWP" 
9ea6 f5				push af  
9ea7 3a bb 9e			ld a, (.dmark)  
9eaa 32 b7 ee			ld (debug_mark),a  
9ead 3a bc 9e			ld a, (.dmark+1)  
9eb0 32 b8 ee			ld (debug_mark+1),a  
9eb3 3a bd 9e			ld a, (.dmark+2)  
9eb6 32 b9 ee			ld (debug_mark+2),a  
9eb9 18 03			jr .pastdmark  
9ebb ..			.dmark: db "SWP"  
9ebe f1			.pastdmark: pop af  
9ebf			endm  
# End of macro DMARK
9ebf						CALLMONITOR 
9ebf cd 62 93			call break_point_state  
9ec2				endm  
# End of macro CALLMONITOR
9ec2					endif 
9ec2			 
9ec2					FORTH_DSP_VALUEHL 
9ec2 cd e6 9a			call macro_dsp_valuehl 
9ec5				endm 
# End of macro FORTH_DSP_VALUEHL
9ec5 e5					push hl     ; w2 
9ec6			 
9ec6					FORTH_DSP_POP 
9ec6 cd 9e 9b			call macro_forth_dsp_pop 
9ec9				endm 
# End of macro FORTH_DSP_POP
9ec9			 
9ec9					FORTH_DSP_VALUEHL 
9ec9 cd e6 9a			call macro_dsp_valuehl 
9ecc				endm 
# End of macro FORTH_DSP_VALUEHL
9ecc			 
9ecc					FORTH_DSP_POP 
9ecc cd 9e 9b			call macro_forth_dsp_pop 
9ecf				endm 
# End of macro FORTH_DSP_POP
9ecf			 
9ecf d1					pop de     ; w2	, hl = w1 
9ed0			 
9ed0 eb					ex de, hl 
9ed1 d5					push de 
9ed2			 
9ed2 cd ef 98				call forth_push_numhl 
9ed5			 
9ed5 e1					pop hl 
9ed6			 
9ed6 cd ef 98				call forth_push_numhl 
9ed9					 
9ed9			 
9ed9					NEXTW 
9ed9 c3 58 9c			jp macro_next 
9edc				endm 
# End of macro NEXTW
9edc			.COLN: 
9edc				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9edc 19				db WORD_SYS_CORE+OPCODE_COLN             
9edd 68 a0			dw .SCOLN            
9edf 02				db 1 + 1 
9ee0 .. 00			db ":",0              
9ee2				endm 
# End of macro CWHEAD
9ee2			; | : ( -- )         Create new word | DONE 
9ee2			 
9ee2					if DEBUG_FORTH_WORDS_KEY 
9ee2						DMARK "CLN" 
9ee2 f5				push af  
9ee3 3a f7 9e			ld a, (.dmark)  
9ee6 32 b7 ee			ld (debug_mark),a  
9ee9 3a f8 9e			ld a, (.dmark+1)  
9eec 32 b8 ee			ld (debug_mark+1),a  
9eef 3a f9 9e			ld a, (.dmark+2)  
9ef2 32 b9 ee			ld (debug_mark+2),a  
9ef5 18 03			jr .pastdmark  
9ef7 ..			.dmark: db "CLN"  
9efa f1			.pastdmark: pop af  
9efb			endm  
# End of macro DMARK
9efb						CALLMONITOR 
9efb cd 62 93			call break_point_state  
9efe				endm  
# End of macro CALLMONITOR
9efe					endif 
9efe				STACKFRAME OFF $8efe $989f 
9efe				if DEBUG_STACK_IMB 
9efe					if OFF 
9efe						exx 
9efe						ld de, $8efe 
9efe						ld a, d 
9efe						ld hl, curframe 
9efe						call hexout 
9efe						ld a, e 
9efe						ld hl, curframe+2 
9efe						call hexout 
9efe						ld hl, $8efe 
9efe						push hl 
9efe						ld hl, $989f 
9efe						push hl 
9efe						exx 
9efe					endif 
9efe				endif 
9efe			endm 
# End of macro STACKFRAME
9efe				; get parser buffer length  of new word 
9efe			 
9efe				 
9efe			 
9efe					; move tok past this to start of name defintition 
9efe					; TODO get word to define 
9efe					; TODO Move past word token 
9efe					; TODO get length of string up to the ';' 
9efe			 
9efe 2a de e7			ld hl, (os_tok_ptr) 
9f01 23				inc hl 
9f02 23				inc hl 
9f03			 
9f03 3e 3b			ld a, ';' 
9f05 cd 22 8f			call strlent 
9f08			 
9f08 7d				ld a,l 
9f09 32 d9 e4			ld (os_new_parse_len), a 
9f0c			 
9f0c			 
9f0c			if DEBUG_FORTH_UWORD 
9f0c ed 5b de e7		ld de, (os_tok_ptr) 
9f10						DMARK ":01" 
9f10 f5				push af  
9f11 3a 25 9f			ld a, (.dmark)  
9f14 32 b7 ee			ld (debug_mark),a  
9f17 3a 26 9f			ld a, (.dmark+1)  
9f1a 32 b8 ee			ld (debug_mark+1),a  
9f1d 3a 27 9f			ld a, (.dmark+2)  
9f20 32 b9 ee			ld (debug_mark+2),a  
9f23 18 03			jr .pastdmark  
9f25 ..			.dmark: db ":01"  
9f28 f1			.pastdmark: pop af  
9f29			endm  
# End of macro DMARK
9f29				CALLMONITOR 
9f29 cd 62 93			call break_point_state  
9f2c				endm  
# End of macro CALLMONITOR
9f2c			endif 
9f2c			 
9f2c			; 
9f2c			;  new word memory layout: 
9f2c			;  
9f2c			;    : adg 6666 ;  
9f2c			; 
9f2c			;    db   1     ; user defined word  
9f2c 23				inc hl    
9f2d			;    dw   sysdict 
9f2d 23				inc hl 
9f2e 23				inc hl 
9f2f			;    db <word len>+1 (for null) 
9f2f 23				inc hl 
9f30			;    db .... <word> 
9f30			; 
9f30			 
9f30 23				inc hl    ; some extras for the word preamble before the above 
9f31 23				inc hl 
9f32 23				inc hl 
9f33 23				inc hl 
9f34 23				inc hl 
9f35 23				inc hl 
9f36 23				inc hl  
9f37 23				inc hl 
9f38 23				inc hl 
9f39 23				inc hl 
9f3a 23				inc hl 
9f3b 23				inc hl 
9f3c 23				inc hl 
9f3d 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9f3e			;       exec word buffer 
9f3e			;	<ptr word>   
9f3e 23				inc hl 
9f3f 23				inc hl 
9f40			;       <word list><null term> 7F final term 
9f40			 
9f40			 
9f40			if DEBUG_FORTH_UWORD 
9f40						DMARK ":02" 
9f40 f5				push af  
9f41 3a 55 9f			ld a, (.dmark)  
9f44 32 b7 ee			ld (debug_mark),a  
9f47 3a 56 9f			ld a, (.dmark+1)  
9f4a 32 b8 ee			ld (debug_mark+1),a  
9f4d 3a 57 9f			ld a, (.dmark+2)  
9f50 32 b9 ee			ld (debug_mark+2),a  
9f53 18 03			jr .pastdmark  
9f55 ..			.dmark: db ":02"  
9f58 f1			.pastdmark: pop af  
9f59			endm  
# End of macro DMARK
9f59				CALLMONITOR 
9f59 cd 62 93			call break_point_state  
9f5c				endm  
# End of macro CALLMONITOR
9f5c			endif 
9f5c			 
9f5c				 
9f5c					; malloc the size 
9f5c			 
9f5c cd 80 8f				call malloc 
9f5f 22 db e4				ld (os_new_malloc), hl     ; save malloc start 
9f62			 
9f62			;    db   1     ; user defined word  
9f62 3e 01				ld a, WORD_SYS_UWORD  
9f64 77					ld (hl), a 
9f65				 
9f65 23				inc hl    
9f66			;    dw   sysdict 
9f66 11 b0 9d			ld de, sysdict       ; continue on with the scan to the system dict 
9f69 73				ld (hl), e 
9f6a 23				inc hl 
9f6b 72				ld (hl), d 
9f6c 23				inc hl 
9f6d			 
9f6d			 
9f6d			;    Setup dict word 
9f6d			 
9f6d 23				inc hl 
9f6e 22 d5 e4			ld (os_new_work_ptr), hl     ; save start of dict word  
9f71			 
9f71				; 1. get length of dict word 
9f71			 
9f71			 
9f71 2a de e7			ld hl, (os_tok_ptr) 
9f74 23				inc hl 
9f75 23				inc hl    ; position to start of dict word 
9f76 3e 00			ld a, 0 
9f78 cd 22 8f			call strlent 
9f7b			 
9f7b			 
9f7b 23				inc hl    ; to include null??? 
9f7c			 
9f7c				; write length of dict word 
9f7c			 
9f7c ed 5b d5 e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f80 1b				dec de 
9f81 eb				ex de, hl 
9f82 73				ld (hl), e 
9f83 eb				ex de, hl 
9f84			 
9f84				 
9f84			 
9f84				; copy  
9f84 4d				ld c, l 
9f85 06 00			ld b, 0 
9f87 ed 5b d5 e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f8b 2a de e7			ld hl, (os_tok_ptr) 
9f8e 23				inc hl 
9f8f 23				inc hl    ; position to start of dict word 
9f90				 
9f90			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9f90				 
9f90				; TODO need to convert word to upper case 
9f90			 
9f90			ucasetok:	 
9f90 7e				ld a,(hl) 
9f91 cd 0e 8f			call toUpper 
9f94 77				ld (hl),a 
9f95 ed a0			ldi 
9f97 f2 90 9f		 	jp p, ucasetok 
9f9a			 
9f9a			 
9f9a			 
9f9a				; de now points to start of where the word body code should be placed 
9f9a ed 53 d5 e4		ld (os_new_work_ptr), de 
9f9e				; hl now points to the words to throw at forthexec which needs to be copied 
9f9e 22 d3 e4			ld (os_new_src_ptr), hl 
9fa1			 
9fa1				; TODO add 'call to forthexec' 
9fa1			 
9fa1			if DEBUG_FORTH_UWORD 
9fa1 c5				push bc 
9fa2 ed 4b db e4		ld bc, (os_new_malloc) 
9fa6						DMARK ":0x" 
9fa6 f5				push af  
9fa7 3a bb 9f			ld a, (.dmark)  
9faa 32 b7 ee			ld (debug_mark),a  
9fad 3a bc 9f			ld a, (.dmark+1)  
9fb0 32 b8 ee			ld (debug_mark+1),a  
9fb3 3a bd 9f			ld a, (.dmark+2)  
9fb6 32 b9 ee			ld (debug_mark+2),a  
9fb9 18 03			jr .pastdmark  
9fbb ..			.dmark: db ":0x"  
9fbe f1			.pastdmark: pop af  
9fbf			endm  
# End of macro DMARK
9fbf				CALLMONITOR 
9fbf cd 62 93			call break_point_state  
9fc2				endm  
# End of macro CALLMONITOR
9fc2 c1				pop bc 
9fc3			endif 
9fc3			 
9fc3			 
9fc3				; create word preamble which should be: 
9fc3			 
9fc3			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9fc3			 
9fc3				;    ld hl, <word code> 
9fc3				;    jp user_exec 
9fc3			        ;    <word code bytes> 
9fc3			 
9fc3			 
9fc3			;	inc de     ; TODO ??? or are we already past the word's null 
9fc3 eb				ex de, hl 
9fc4			 
9fc4 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9fc6			 
9fc6 23				inc hl 
9fc7 22 cf e4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9fca 23				inc hl 
9fcb			 
9fcb 23				inc hl 
9fcc 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9fce			 
9fce 01 b8 c3			ld bc, user_exec 
9fd1 23				inc hl 
9fd2 71				ld (hl), c     ; poke address of user_exec 
9fd3 23				inc hl 
9fd4 70				ld (hl), b     
9fd5			 ; 
9fd5			;	inc hl 
9fd5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9fd5			; 
9fd5			; 
9fd5			;	ld bc, macro_forth_rsp_next 
9fd5			;	inc hl 
9fd5			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9fd5			;	inc hl 
9fd5			;	ld (hl), b     
9fd5			 ; 
9fd5			;	inc hl 
9fd5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9fd5			; 
9fd5			; 
9fd5			;	inc hl 
9fd5			;	ld bc, forthexec 
9fd5			;	ld (hl), c     ; poke address of forthexec 
9fd5			;	inc hl 
9fd5			;	ld (hl), b      
9fd5			; 
9fd5			;	inc hl 
9fd5			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9fd5			; 
9fd5			;	ld bc, user_dict_next 
9fd5			;	inc hl 
9fd5			;	ld (hl), c     ; poke address of forthexec 
9fd5			;	inc hl 
9fd5			;	ld (hl), b      
9fd5			 
9fd5				; hl is now where we need to copy the word byte data to save this 
9fd5			 
9fd5 23				inc hl 
9fd6 22 d1 e4			ld (os_new_exec), hl 
9fd9				 
9fd9				; copy definition 
9fd9			 
9fd9 eb				ex de, hl 
9fda			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9fda			;	inc de    ; skip the PC for this parse 
9fda 3a d9 e4			ld a, (os_new_parse_len) 
9fdd 4f				ld c, a 
9fde 06 00			ld b, 0 
9fe0 ed b0			ldir		 ; copy defintion 
9fe2			 
9fe2			 
9fe2				; poke the address of where the new word bytes live for forthexec 
9fe2			 
9fe2 2a cf e4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9fe5			 
9fe5 ed 5b d1 e4		ld de, (os_new_exec)      
9fe9				 
9fe9 73				ld (hl), e 
9fea 23				inc hl 
9feb 72				ld (hl), d 
9fec			 
9fec					; TODO copy last user dict word next link to this word 
9fec					; TODO update last user dict word to point to this word 
9fec			; 
9fec			; hl f923 de 812a ; bc 811a 
9fec			 
9fec			if DEBUG_FORTH_UWORD 
9fec c5				push bc 
9fed ed 4b db e4		ld bc, (os_new_malloc) 
9ff1						DMARK ":0A" 
9ff1 f5				push af  
9ff2 3a 06 a0			ld a, (.dmark)  
9ff5 32 b7 ee			ld (debug_mark),a  
9ff8 3a 07 a0			ld a, (.dmark+1)  
9ffb 32 b8 ee			ld (debug_mark+1),a  
9ffe 3a 08 a0			ld a, (.dmark+2)  
a001 32 b9 ee			ld (debug_mark+2),a  
a004 18 03			jr .pastdmark  
a006 ..			.dmark: db ":0A"  
a009 f1			.pastdmark: pop af  
a00a			endm  
# End of macro DMARK
a00a				CALLMONITOR 
a00a cd 62 93			call break_point_state  
a00d				endm  
# End of macro CALLMONITOR
a00d c1				pop bc 
a00e			endif 
a00e			if DEBUG_FORTH_UWORD 
a00e c5				push bc 
a00f ed 4b db e4		ld bc, (os_new_malloc) 
a013 03				inc bc 
a014 03				inc bc 
a015 03				inc bc 
a016 03				inc bc 
a017 03				inc bc 
a018 03				inc bc 
a019 03				inc bc 
a01a 03				inc bc 
a01b			 
a01b						DMARK ":0B" 
a01b f5				push af  
a01c 3a 30 a0			ld a, (.dmark)  
a01f 32 b7 ee			ld (debug_mark),a  
a022 3a 31 a0			ld a, (.dmark+1)  
a025 32 b8 ee			ld (debug_mark+1),a  
a028 3a 32 a0			ld a, (.dmark+2)  
a02b 32 b9 ee			ld (debug_mark+2),a  
a02e 18 03			jr .pastdmark  
a030 ..			.dmark: db ":0B"  
a033 f1			.pastdmark: pop af  
a034			endm  
# End of macro DMARK
a034				CALLMONITOR 
a034 cd 62 93			call break_point_state  
a037				endm  
# End of macro CALLMONITOR
a037 c1				pop bc 
a038			endif 
a038			 
a038			; update word dict linked list for new word 
a038			 
a038			 
a038 2a da e7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a03b 23			inc hl     ; move to next work linked list ptr 
a03c			 
a03c ed 5b db e4	ld de, (os_new_malloc)		 ; new next word 
a040 73			ld (hl), e 
a041 23			inc hl 
a042 72			ld (hl), d 
a043			 
a043			if DEBUG_FORTH_UWORD 
a043 ed 4b da e7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a047			endif 
a047			 
a047 ed 53 da e7	ld (os_last_new_uword), de      ; update last new uword ptr 
a04b			 
a04b			 
a04b			if DEBUG_FORTH_UWORD 
a04b						DMARK ":0+" 
a04b f5				push af  
a04c 3a 60 a0			ld a, (.dmark)  
a04f 32 b7 ee			ld (debug_mark),a  
a052 3a 61 a0			ld a, (.dmark+1)  
a055 32 b8 ee			ld (debug_mark+1),a  
a058 3a 62 a0			ld a, (.dmark+2)  
a05b 32 b9 ee			ld (debug_mark+2),a  
a05e 18 03			jr .pastdmark  
a060 ..			.dmark: db ":0+"  
a063 f1			.pastdmark: pop af  
a064			endm  
# End of macro DMARK
a064				CALLMONITOR 
a064 cd 62 93			call break_point_state  
a067				endm  
# End of macro CALLMONITOR
a067			endif 
a067			 
a067				STACKFRAMECHK OFF $8efe $989f 
a067				if DEBUG_STACK_IMB 
a067					if OFF 
a067						exx 
a067						ld hl, $989f 
a067						pop de   ; $989f 
a067						call cmp16 
a067						jr nz, .spnosame 
a067						ld hl, $8efe 
a067						pop de   ; $8efe 
a067						call cmp16 
a067						jr z, .spfrsame 
a067						.spnosame: call showsperror 
a067						.spfrsame: nop 
a067						exx 
a067					endif 
a067				endif 
a067			endm 
# End of macro STACKFRAMECHK
a067			 
a067 c9			ret    ; dont process any remaining parser tokens as they form new word 
a068			 
a068			 
a068			 
a068			 
a068			;		NEXT 
a068			.SCOLN: 
a068			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a068 06				db OPCODE_SCOLN 
a069 b4 a0			dw .DROP 
a06b 02				db 2 
a06c .. 00			db ";",0           
a06e			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a06e					if DEBUG_FORTH_WORDS_KEY 
a06e						DMARK "SCN" 
a06e f5				push af  
a06f 3a 83 a0			ld a, (.dmark)  
a072 32 b7 ee			ld (debug_mark),a  
a075 3a 84 a0			ld a, (.dmark+1)  
a078 32 b8 ee			ld (debug_mark+1),a  
a07b 3a 85 a0			ld a, (.dmark+2)  
a07e 32 b9 ee			ld (debug_mark+2),a  
a081 18 03			jr .pastdmark  
a083 ..			.dmark: db "SCN"  
a086 f1			.pastdmark: pop af  
a087			endm  
# End of macro DMARK
a087						CALLMONITOR 
a087 cd 62 93			call break_point_state  
a08a				endm  
# End of macro CALLMONITOR
a08a					endif 
a08a					FORTH_RSP_TOS 
a08a cd ad 98			call macro_forth_rsp_tos 
a08d				endm 
# End of macro FORTH_RSP_TOS
a08d e5					push hl 
a08e					FORTH_RSP_POP 
a08e cd b7 98			call macro_forth_rsp_pop 
a091				endm 
# End of macro FORTH_RSP_POP
a091 e1					pop hl 
a092			;		ex de,hl 
a092 22 de e7				ld (os_tok_ptr),hl 
a095			 
a095			if DEBUG_FORTH_UWORD 
a095						DMARK "SCL" 
a095 f5				push af  
a096 3a aa a0			ld a, (.dmark)  
a099 32 b7 ee			ld (debug_mark),a  
a09c 3a ab a0			ld a, (.dmark+1)  
a09f 32 b8 ee			ld (debug_mark+1),a  
a0a2 3a ac a0			ld a, (.dmark+2)  
a0a5 32 b9 ee			ld (debug_mark+2),a  
a0a8 18 03			jr .pastdmark  
a0aa ..			.dmark: db "SCL"  
a0ad f1			.pastdmark: pop af  
a0ae			endm  
# End of macro DMARK
a0ae				CALLMONITOR 
a0ae cd 62 93			call break_point_state  
a0b1				endm  
# End of macro CALLMONITOR
a0b1			endif 
a0b1					NEXTW 
a0b1 c3 58 9c			jp macro_next 
a0b4				endm 
# End of macro NEXTW
a0b4			 
a0b4			.DROP: 
a0b4				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a0b4 1b				db WORD_SYS_CORE+OPCODE_DROP             
a0b5 df a0			dw .DUP2            
a0b7 05				db 4 + 1 
a0b8 .. 00			db "DROP",0              
a0bd				endm 
# End of macro CWHEAD
a0bd			; | DROP ( w -- )   drop the TOS item   | DONE 
a0bd					if DEBUG_FORTH_WORDS_KEY 
a0bd						DMARK "DRP" 
a0bd f5				push af  
a0be 3a d2 a0			ld a, (.dmark)  
a0c1 32 b7 ee			ld (debug_mark),a  
a0c4 3a d3 a0			ld a, (.dmark+1)  
a0c7 32 b8 ee			ld (debug_mark+1),a  
a0ca 3a d4 a0			ld a, (.dmark+2)  
a0cd 32 b9 ee			ld (debug_mark+2),a  
a0d0 18 03			jr .pastdmark  
a0d2 ..			.dmark: db "DRP"  
a0d5 f1			.pastdmark: pop af  
a0d6			endm  
# End of macro DMARK
a0d6						CALLMONITOR 
a0d6 cd 62 93			call break_point_state  
a0d9				endm  
# End of macro CALLMONITOR
a0d9					endif 
a0d9					FORTH_DSP_POP 
a0d9 cd 9e 9b			call macro_forth_dsp_pop 
a0dc				endm 
# End of macro FORTH_DSP_POP
a0dc					NEXTW 
a0dc c3 58 9c			jp macro_next 
a0df				endm 
# End of macro NEXTW
a0df			.DUP2: 
a0df				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a0df 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a0e0 24 a1			dw .DROP2            
a0e2 05				db 4 + 1 
a0e3 .. 00			db "2DUP",0              
a0e8				endm 
# End of macro CWHEAD
a0e8			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a0e8					if DEBUG_FORTH_WORDS_KEY 
a0e8						DMARK "2DU" 
a0e8 f5				push af  
a0e9 3a fd a0			ld a, (.dmark)  
a0ec 32 b7 ee			ld (debug_mark),a  
a0ef 3a fe a0			ld a, (.dmark+1)  
a0f2 32 b8 ee			ld (debug_mark+1),a  
a0f5 3a ff a0			ld a, (.dmark+2)  
a0f8 32 b9 ee			ld (debug_mark+2),a  
a0fb 18 03			jr .pastdmark  
a0fd ..			.dmark: db "2DU"  
a100 f1			.pastdmark: pop af  
a101			endm  
# End of macro DMARK
a101						CALLMONITOR 
a101 cd 62 93			call break_point_state  
a104				endm  
# End of macro CALLMONITOR
a104					endif 
a104					FORTH_DSP_VALUEHL 
a104 cd e6 9a			call macro_dsp_valuehl 
a107				endm 
# End of macro FORTH_DSP_VALUEHL
a107 e5					push hl      ; 2 
a108			 
a108					FORTH_DSP_POP 
a108 cd 9e 9b			call macro_forth_dsp_pop 
a10b				endm 
# End of macro FORTH_DSP_POP
a10b					 
a10b					FORTH_DSP_VALUEHL 
a10b cd e6 9a			call macro_dsp_valuehl 
a10e				endm 
# End of macro FORTH_DSP_VALUEHL
a10e			;		push hl      ; 1 
a10e			 
a10e					FORTH_DSP_POP 
a10e cd 9e 9b			call macro_forth_dsp_pop 
a111				endm 
# End of macro FORTH_DSP_POP
a111			 
a111			;		pop hl       ; 1 
a111 d1					pop de       ; 2 
a112			 
a112 cd ef 98				call forth_push_numhl 
a115 eb					ex de, hl 
a116 cd ef 98				call forth_push_numhl 
a119			 
a119					 
a119 eb					ex de, hl 
a11a			 
a11a cd ef 98				call forth_push_numhl 
a11d eb					ex de, hl 
a11e cd ef 98				call forth_push_numhl 
a121			 
a121			 
a121					NEXTW 
a121 c3 58 9c			jp macro_next 
a124				endm 
# End of macro NEXTW
a124			.DROP2: 
a124				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a124 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a125 53 a1			dw .SWAP2            
a127 06				db 5 + 1 
a128 .. 00			db "2DROP",0              
a12e				endm 
# End of macro CWHEAD
a12e			; | 2DROP ( w w -- )    Double drop | DONE 
a12e					if DEBUG_FORTH_WORDS_KEY 
a12e						DMARK "2DR" 
a12e f5				push af  
a12f 3a 43 a1			ld a, (.dmark)  
a132 32 b7 ee			ld (debug_mark),a  
a135 3a 44 a1			ld a, (.dmark+1)  
a138 32 b8 ee			ld (debug_mark+1),a  
a13b 3a 45 a1			ld a, (.dmark+2)  
a13e 32 b9 ee			ld (debug_mark+2),a  
a141 18 03			jr .pastdmark  
a143 ..			.dmark: db "2DR"  
a146 f1			.pastdmark: pop af  
a147			endm  
# End of macro DMARK
a147						CALLMONITOR 
a147 cd 62 93			call break_point_state  
a14a				endm  
# End of macro CALLMONITOR
a14a					endif 
a14a					FORTH_DSP_POP 
a14a cd 9e 9b			call macro_forth_dsp_pop 
a14d				endm 
# End of macro FORTH_DSP_POP
a14d					FORTH_DSP_POP 
a14d cd 9e 9b			call macro_forth_dsp_pop 
a150				endm 
# End of macro FORTH_DSP_POP
a150					NEXTW 
a150 c3 58 9c			jp macro_next 
a153				endm 
# End of macro NEXTW
a153			.SWAP2: 
a153				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a153 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a154 7c a1			dw .AT            
a156 06				db 5 + 1 
a157 .. 00			db "2SWAP",0              
a15d				endm 
# End of macro CWHEAD
a15d			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a15d					if DEBUG_FORTH_WORDS_KEY 
a15d						DMARK "2SW" 
a15d f5				push af  
a15e 3a 72 a1			ld a, (.dmark)  
a161 32 b7 ee			ld (debug_mark),a  
a164 3a 73 a1			ld a, (.dmark+1)  
a167 32 b8 ee			ld (debug_mark+1),a  
a16a 3a 74 a1			ld a, (.dmark+2)  
a16d 32 b9 ee			ld (debug_mark+2),a  
a170 18 03			jr .pastdmark  
a172 ..			.dmark: db "2SW"  
a175 f1			.pastdmark: pop af  
a176			endm  
# End of macro DMARK
a176						CALLMONITOR 
a176 cd 62 93			call break_point_state  
a179				endm  
# End of macro CALLMONITOR
a179					endif 
a179					NEXTW 
a179 c3 58 9c			jp macro_next 
a17c				endm 
# End of macro NEXTW
a17c			.AT: 
a17c				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a17c 1f				db WORD_SYS_CORE+OPCODE_AT             
a17d ae a1			dw .CAT            
a17f 02				db 1 + 1 
a180 .. 00			db "@",0              
a182				endm 
# End of macro CWHEAD
a182			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a182			 
a182					if DEBUG_FORTH_WORDS_KEY 
a182						DMARK "AT." 
a182 f5				push af  
a183 3a 97 a1			ld a, (.dmark)  
a186 32 b7 ee			ld (debug_mark),a  
a189 3a 98 a1			ld a, (.dmark+1)  
a18c 32 b8 ee			ld (debug_mark+1),a  
a18f 3a 99 a1			ld a, (.dmark+2)  
a192 32 b9 ee			ld (debug_mark+2),a  
a195 18 03			jr .pastdmark  
a197 ..			.dmark: db "AT."  
a19a f1			.pastdmark: pop af  
a19b			endm  
# End of macro DMARK
a19b						CALLMONITOR 
a19b cd 62 93			call break_point_state  
a19e				endm  
# End of macro CALLMONITOR
a19e					endif 
a19e			.getbyteat:	 
a19e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a19e cd e6 9a			call macro_dsp_valuehl 
a1a1				endm 
# End of macro FORTH_DSP_VALUEHL
a1a1					 
a1a1			;		push hl 
a1a1				 
a1a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1a1 cd 9e 9b			call macro_forth_dsp_pop 
a1a4				endm 
# End of macro FORTH_DSP_POP
a1a4			 
a1a4			;		pop hl 
a1a4			 
a1a4 7e					ld a, (hl) 
a1a5			 
a1a5 6f					ld l, a 
a1a6 26 00				ld h, 0 
a1a8 cd ef 98				call forth_push_numhl 
a1ab			 
a1ab					NEXTW 
a1ab c3 58 9c			jp macro_next 
a1ae				endm 
# End of macro NEXTW
a1ae			.CAT: 
a1ae				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a1ae 20				db WORD_SYS_CORE+OPCODE_CAT             
a1af d7 a1			dw .BANG            
a1b1 03				db 2 + 1 
a1b2 .. 00			db "C@",0              
a1b5				endm 
# End of macro CWHEAD
a1b5			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a1b5					if DEBUG_FORTH_WORDS_KEY 
a1b5						DMARK "CAA" 
a1b5 f5				push af  
a1b6 3a ca a1			ld a, (.dmark)  
a1b9 32 b7 ee			ld (debug_mark),a  
a1bc 3a cb a1			ld a, (.dmark+1)  
a1bf 32 b8 ee			ld (debug_mark+1),a  
a1c2 3a cc a1			ld a, (.dmark+2)  
a1c5 32 b9 ee			ld (debug_mark+2),a  
a1c8 18 03			jr .pastdmark  
a1ca ..			.dmark: db "CAA"  
a1cd f1			.pastdmark: pop af  
a1ce			endm  
# End of macro DMARK
a1ce						CALLMONITOR 
a1ce cd 62 93			call break_point_state  
a1d1				endm  
# End of macro CALLMONITOR
a1d1					endif 
a1d1 c3 9e a1				jp .getbyteat 
a1d4					NEXTW 
a1d4 c3 58 9c			jp macro_next 
a1d7				endm 
# End of macro NEXTW
a1d7			.BANG: 
a1d7				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a1d7 21				db WORD_SYS_CORE+OPCODE_BANG             
a1d8 0d a2			dw .CBANG            
a1da 02				db 1 + 1 
a1db .. 00			db "!",0              
a1dd				endm 
# End of macro CWHEAD
a1dd			; | ! ( x w -- ) Store x at address w      | DONE 
a1dd					if DEBUG_FORTH_WORDS_KEY 
a1dd						DMARK "BNG" 
a1dd f5				push af  
a1de 3a f2 a1			ld a, (.dmark)  
a1e1 32 b7 ee			ld (debug_mark),a  
a1e4 3a f3 a1			ld a, (.dmark+1)  
a1e7 32 b8 ee			ld (debug_mark+1),a  
a1ea 3a f4 a1			ld a, (.dmark+2)  
a1ed 32 b9 ee			ld (debug_mark+2),a  
a1f0 18 03			jr .pastdmark  
a1f2 ..			.dmark: db "BNG"  
a1f5 f1			.pastdmark: pop af  
a1f6			endm  
# End of macro DMARK
a1f6						CALLMONITOR 
a1f6 cd 62 93			call break_point_state  
a1f9				endm  
# End of macro CALLMONITOR
a1f9					endif 
a1f9			 
a1f9			.storebyteat:		 
a1f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1f9 cd e6 9a			call macro_dsp_valuehl 
a1fc				endm 
# End of macro FORTH_DSP_VALUEHL
a1fc					 
a1fc e5					push hl 
a1fd				 
a1fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1fd cd 9e 9b			call macro_forth_dsp_pop 
a200				endm 
# End of macro FORTH_DSP_POP
a200			 
a200					; get byte to poke 
a200			 
a200					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a200 cd e6 9a			call macro_dsp_valuehl 
a203				endm 
# End of macro FORTH_DSP_VALUEHL
a203 e5					push hl 
a204			 
a204			 
a204					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a204 cd 9e 9b			call macro_forth_dsp_pop 
a207				endm 
# End of macro FORTH_DSP_POP
a207			 
a207			 
a207 d1					pop de 
a208 e1					pop hl 
a209			 
a209 73					ld (hl),e 
a20a			 
a20a			 
a20a					NEXTW 
a20a c3 58 9c			jp macro_next 
a20d				endm 
# End of macro NEXTW
a20d			.CBANG: 
a20d				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a20d 22				db WORD_SYS_CORE+OPCODE_CBANG             
a20e 36 a2			dw .SCALL            
a210 03				db 2 + 1 
a211 .. 00			db "C!",0              
a214				endm 
# End of macro CWHEAD
a214			; | C!  ( x w -- ) Store x at address w  | DONE 
a214					if DEBUG_FORTH_WORDS_KEY 
a214						DMARK "CBA" 
a214 f5				push af  
a215 3a 29 a2			ld a, (.dmark)  
a218 32 b7 ee			ld (debug_mark),a  
a21b 3a 2a a2			ld a, (.dmark+1)  
a21e 32 b8 ee			ld (debug_mark+1),a  
a221 3a 2b a2			ld a, (.dmark+2)  
a224 32 b9 ee			ld (debug_mark+2),a  
a227 18 03			jr .pastdmark  
a229 ..			.dmark: db "CBA"  
a22c f1			.pastdmark: pop af  
a22d			endm  
# End of macro DMARK
a22d						CALLMONITOR 
a22d cd 62 93			call break_point_state  
a230				endm  
# End of macro CALLMONITOR
a230					endif 
a230 c3 f9 a1				jp .storebyteat 
a233					NEXTW 
a233 c3 58 9c			jp macro_next 
a236				endm 
# End of macro NEXTW
a236			.SCALL: 
a236				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a236 23				db WORD_SYS_CORE+OPCODE_SCALL             
a237 6a a2			dw .DEPTH            
a239 05				db 4 + 1 
a23a .. 00			db "CALL",0              
a23f				endm 
# End of macro CWHEAD
a23f			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a23f					if DEBUG_FORTH_WORDS_KEY 
a23f						DMARK "CLL" 
a23f f5				push af  
a240 3a 54 a2			ld a, (.dmark)  
a243 32 b7 ee			ld (debug_mark),a  
a246 3a 55 a2			ld a, (.dmark+1)  
a249 32 b8 ee			ld (debug_mark+1),a  
a24c 3a 56 a2			ld a, (.dmark+2)  
a24f 32 b9 ee			ld (debug_mark+2),a  
a252 18 03			jr .pastdmark  
a254 ..			.dmark: db "CLL"  
a257 f1			.pastdmark: pop af  
a258			endm  
# End of macro DMARK
a258						CALLMONITOR 
a258 cd 62 93			call break_point_state  
a25b				endm  
# End of macro CALLMONITOR
a25b					endif 
a25b			 
a25b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a25b cd e6 9a			call macro_dsp_valuehl 
a25e				endm 
# End of macro FORTH_DSP_VALUEHL
a25e			 
a25e			;		push hl 
a25e			 
a25e					; destroy value TOS 
a25e			 
a25e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a25e cd 9e 9b			call macro_forth_dsp_pop 
a261				endm 
# End of macro FORTH_DSP_POP
a261			 
a261						 
a261			;		pop hl 
a261			 
a261					; how to do a call with hl???? save SP? 
a261 cd 01 9c				call forth_call_hl 
a264			 
a264			 
a264					; TODO push value back onto stack for another op etc 
a264			 
a264 cd ef 98				call forth_push_numhl 
a267					NEXTW 
a267 c3 58 9c			jp macro_next 
a26a				endm 
# End of macro NEXTW
a26a			.DEPTH: 
a26a				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a26a 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a26b a7 a2			dw .OVER            
a26d 06				db 5 + 1 
a26e .. 00			db "DEPTH",0              
a274				endm 
# End of macro CWHEAD
a274			; | DEPTH ( -- u ) Push count of stack | DONE 
a274					; take current TOS and remove from base value div by two to get count 
a274					if DEBUG_FORTH_WORDS_KEY 
a274						DMARK "DEP" 
a274 f5				push af  
a275 3a 89 a2			ld a, (.dmark)  
a278 32 b7 ee			ld (debug_mark),a  
a27b 3a 8a a2			ld a, (.dmark+1)  
a27e 32 b8 ee			ld (debug_mark+1),a  
a281 3a 8b a2			ld a, (.dmark+2)  
a284 32 b9 ee			ld (debug_mark+2),a  
a287 18 03			jr .pastdmark  
a289 ..			.dmark: db "DEP"  
a28c f1			.pastdmark: pop af  
a28d			endm  
# End of macro DMARK
a28d						CALLMONITOR 
a28d cd 62 93			call break_point_state  
a290				endm  
# End of macro CALLMONITOR
a290					endif 
a290			 
a290			 
a290 2a 8a ec			ld hl, (cli_data_sp) 
a293 11 44 ea			ld de, cli_data_stack 
a296 ed 52			sbc hl,de 
a298				 
a298				; div by size of stack item 
a298			 
a298 5d				ld e,l 
a299 0e 03			ld c, 3 
a29b cd 49 8a			call Div8 
a29e			 
a29e 6f				ld l,a 
a29f 26 00			ld h,0 
a2a1			 
a2a1				;srl h 
a2a1				;rr l 
a2a1			 
a2a1 cd ef 98				call forth_push_numhl 
a2a4					NEXTW 
a2a4 c3 58 9c			jp macro_next 
a2a7				endm 
# End of macro NEXTW
a2a7			.OVER: 
a2a7				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a2a7 42				db WORD_SYS_CORE+46             
a2a8 ee a2			dw .PAUSE            
a2aa 05				db 4 + 1 
a2ab .. 00			db "OVER",0              
a2b0				endm 
# End of macro CWHEAD
a2b0			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a2b0					if DEBUG_FORTH_WORDS_KEY 
a2b0						DMARK "OVR" 
a2b0 f5				push af  
a2b1 3a c5 a2			ld a, (.dmark)  
a2b4 32 b7 ee			ld (debug_mark),a  
a2b7 3a c6 a2			ld a, (.dmark+1)  
a2ba 32 b8 ee			ld (debug_mark+1),a  
a2bd 3a c7 a2			ld a, (.dmark+2)  
a2c0 32 b9 ee			ld (debug_mark+2),a  
a2c3 18 03			jr .pastdmark  
a2c5 ..			.dmark: db "OVR"  
a2c8 f1			.pastdmark: pop af  
a2c9			endm  
# End of macro DMARK
a2c9						CALLMONITOR 
a2c9 cd 62 93			call break_point_state  
a2cc				endm  
# End of macro CALLMONITOR
a2cc					endif 
a2cc			 
a2cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2cc cd e6 9a			call macro_dsp_valuehl 
a2cf				endm 
# End of macro FORTH_DSP_VALUEHL
a2cf e5					push hl    ; n2 
a2d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2d0 cd 9e 9b			call macro_forth_dsp_pop 
a2d3				endm 
# End of macro FORTH_DSP_POP
a2d3			 
a2d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2d3 cd e6 9a			call macro_dsp_valuehl 
a2d6				endm 
# End of macro FORTH_DSP_VALUEHL
a2d6 e5					push hl    ; n1 
a2d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2d7 cd 9e 9b			call macro_forth_dsp_pop 
a2da				endm 
# End of macro FORTH_DSP_POP
a2da			 
a2da d1					pop de     ; n1 
a2db e1					pop hl     ; n2 
a2dc			 
a2dc d5					push de 
a2dd e5					push hl 
a2de d5					push de 
a2df			 
a2df					; push back  
a2df			 
a2df e1					pop hl 
a2e0 cd ef 98				call forth_push_numhl 
a2e3 e1					pop hl 
a2e4 cd ef 98				call forth_push_numhl 
a2e7 e1					pop hl 
a2e8 cd ef 98				call forth_push_numhl 
a2eb					NEXTW 
a2eb c3 58 9c			jp macro_next 
a2ee				endm 
# End of macro NEXTW
a2ee			 
a2ee			.PAUSE: 
a2ee				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a2ee 43				db WORD_SYS_CORE+47             
a2ef 23 a3			dw .PAUSES            
a2f1 08				db 7 + 1 
a2f2 .. 00			db "PAUSEMS",0              
a2fa				endm 
# End of macro CWHEAD
a2fa			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a2fa					if DEBUG_FORTH_WORDS_KEY 
a2fa						DMARK "PMS" 
a2fa f5				push af  
a2fb 3a 0f a3			ld a, (.dmark)  
a2fe 32 b7 ee			ld (debug_mark),a  
a301 3a 10 a3			ld a, (.dmark+1)  
a304 32 b8 ee			ld (debug_mark+1),a  
a307 3a 11 a3			ld a, (.dmark+2)  
a30a 32 b9 ee			ld (debug_mark+2),a  
a30d 18 03			jr .pastdmark  
a30f ..			.dmark: db "PMS"  
a312 f1			.pastdmark: pop af  
a313			endm  
# End of macro DMARK
a313						CALLMONITOR 
a313 cd 62 93			call break_point_state  
a316				endm  
# End of macro CALLMONITOR
a316					endif 
a316					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a316 cd e6 9a			call macro_dsp_valuehl 
a319				endm 
# End of macro FORTH_DSP_VALUEHL
a319			;		push hl    ; n2 
a319					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a319 cd 9e 9b			call macro_forth_dsp_pop 
a31c				endm 
# End of macro FORTH_DSP_POP
a31c			;		pop hl 
a31c			 
a31c 7d					ld a, l 
a31d cd ee 87				call aDelayInMS 
a320				       NEXTW 
a320 c3 58 9c			jp macro_next 
a323				endm 
# End of macro NEXTW
a323			.PAUSES:  
a323				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a323 44				db WORD_SYS_CORE+48             
a324 92 a3			dw .ROT            
a326 06				db 5 + 1 
a327 .. 00			db "PAUSE",0              
a32d				endm 
# End of macro CWHEAD
a32d			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a32d					if DEBUG_FORTH_WORDS_KEY 
a32d						DMARK "PAU" 
a32d f5				push af  
a32e 3a 42 a3			ld a, (.dmark)  
a331 32 b7 ee			ld (debug_mark),a  
a334 3a 43 a3			ld a, (.dmark+1)  
a337 32 b8 ee			ld (debug_mark+1),a  
a33a 3a 44 a3			ld a, (.dmark+2)  
a33d 32 b9 ee			ld (debug_mark+2),a  
a340 18 03			jr .pastdmark  
a342 ..			.dmark: db "PAU"  
a345 f1			.pastdmark: pop af  
a346			endm  
# End of macro DMARK
a346						CALLMONITOR 
a346 cd 62 93			call break_point_state  
a349				endm  
# End of macro CALLMONITOR
a349					endif 
a349					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a349 cd e6 9a			call macro_dsp_valuehl 
a34c				endm 
# End of macro FORTH_DSP_VALUEHL
a34c			;		push hl    ; n2 
a34c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a34c cd 9e 9b			call macro_forth_dsp_pop 
a34f				endm 
# End of macro FORTH_DSP_POP
a34f			;		pop hl 
a34f 45					ld b, l 
a350					if DEBUG_FORTH_WORDS 
a350						DMARK "PAU" 
a350 f5				push af  
a351 3a 65 a3			ld a, (.dmark)  
a354 32 b7 ee			ld (debug_mark),a  
a357 3a 66 a3			ld a, (.dmark+1)  
a35a 32 b8 ee			ld (debug_mark+1),a  
a35d 3a 67 a3			ld a, (.dmark+2)  
a360 32 b9 ee			ld (debug_mark+2),a  
a363 18 03			jr .pastdmark  
a365 ..			.dmark: db "PAU"  
a368 f1			.pastdmark: pop af  
a369			endm  
# End of macro DMARK
a369						CALLMONITOR 
a369 cd 62 93			call break_point_state  
a36c				endm  
# End of macro CALLMONITOR
a36c					endif 
a36c c5			.pauses1:	push bc 
a36d cd 09 88				call delay1s 
a370 c1					pop bc 
a371					if DEBUG_FORTH_WORDS 
a371						DMARK "PA1" 
a371 f5				push af  
a372 3a 86 a3			ld a, (.dmark)  
a375 32 b7 ee			ld (debug_mark),a  
a378 3a 87 a3			ld a, (.dmark+1)  
a37b 32 b8 ee			ld (debug_mark+1),a  
a37e 3a 88 a3			ld a, (.dmark+2)  
a381 32 b9 ee			ld (debug_mark+2),a  
a384 18 03			jr .pastdmark  
a386 ..			.dmark: db "PA1"  
a389 f1			.pastdmark: pop af  
a38a			endm  
# End of macro DMARK
a38a						CALLMONITOR 
a38a cd 62 93			call break_point_state  
a38d				endm  
# End of macro CALLMONITOR
a38d					endif 
a38d 10 dd				djnz .pauses1 
a38f			 
a38f				       NEXTW 
a38f c3 58 9c			jp macro_next 
a392				endm 
# End of macro NEXTW
a392			.ROT: 
a392				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a392 45				db WORD_SYS_CORE+49             
a393 e0 a3			dw .UWORDS            
a395 04				db 3 + 1 
a396 .. 00			db "ROT",0              
a39a				endm 
# End of macro CWHEAD
a39a			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a39a					if DEBUG_FORTH_WORDS_KEY 
a39a						DMARK "ROT" 
a39a f5				push af  
a39b 3a af a3			ld a, (.dmark)  
a39e 32 b7 ee			ld (debug_mark),a  
a3a1 3a b0 a3			ld a, (.dmark+1)  
a3a4 32 b8 ee			ld (debug_mark+1),a  
a3a7 3a b1 a3			ld a, (.dmark+2)  
a3aa 32 b9 ee			ld (debug_mark+2),a  
a3ad 18 03			jr .pastdmark  
a3af ..			.dmark: db "ROT"  
a3b2 f1			.pastdmark: pop af  
a3b3			endm  
# End of macro DMARK
a3b3						CALLMONITOR 
a3b3 cd 62 93			call break_point_state  
a3b6				endm  
# End of macro CALLMONITOR
a3b6					endif 
a3b6			 
a3b6					FORTH_DSP_VALUEHL 
a3b6 cd e6 9a			call macro_dsp_valuehl 
a3b9				endm 
# End of macro FORTH_DSP_VALUEHL
a3b9 e5					push hl    ; u3  
a3ba			 
a3ba					FORTH_DSP_POP 
a3ba cd 9e 9b			call macro_forth_dsp_pop 
a3bd				endm 
# End of macro FORTH_DSP_POP
a3bd			   
a3bd					FORTH_DSP_VALUEHL 
a3bd cd e6 9a			call macro_dsp_valuehl 
a3c0				endm 
# End of macro FORTH_DSP_VALUEHL
a3c0 e5					push hl     ; u2 
a3c1			 
a3c1					FORTH_DSP_POP 
a3c1 cd 9e 9b			call macro_forth_dsp_pop 
a3c4				endm 
# End of macro FORTH_DSP_POP
a3c4			 
a3c4					FORTH_DSP_VALUEHL 
a3c4 cd e6 9a			call macro_dsp_valuehl 
a3c7				endm 
# End of macro FORTH_DSP_VALUEHL
a3c7 e5					push hl     ; u1 
a3c8			 
a3c8					FORTH_DSP_POP 
a3c8 cd 9e 9b			call macro_forth_dsp_pop 
a3cb				endm 
# End of macro FORTH_DSP_POP
a3cb			 
a3cb c1					pop bc      ; u1 
a3cc e1					pop hl      ; u2 
a3cd d1					pop de      ; u3 
a3ce			 
a3ce			 
a3ce c5					push bc 
a3cf d5					push de 
a3d0 e5					push hl 
a3d1			 
a3d1			 
a3d1 e1					pop hl 
a3d2 cd ef 98				call forth_push_numhl 
a3d5			 
a3d5 e1					pop hl 
a3d6 cd ef 98				call forth_push_numhl 
a3d9			 
a3d9 e1					pop hl 
a3da cd ef 98				call forth_push_numhl 
a3dd					 
a3dd			 
a3dd			 
a3dd			 
a3dd			 
a3dd			 
a3dd				       NEXTW 
a3dd c3 58 9c			jp macro_next 
a3e0				endm 
# End of macro NEXTW
a3e0			 
a3e0			.UWORDS: 
a3e0				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a3e0 50				db WORD_SYS_CORE+60             
a3e1 a2 a4			dw .BP            
a3e3 07				db 6 + 1 
a3e4 .. 00			db "UWORDS",0              
a3eb				endm 
# End of macro CWHEAD
a3eb			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a3eb			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a3eb			; | | Following the count are the individual words. 
a3eb			; | | 
a3eb			; | | e.g. UWORDS 
a3eb			; | | BOX DIRLIST 2 
a3eb			; | |  
a3eb			; | | Can be used to save the words to storage via: 
a3eb			; | | UWORDS $01 DO $01 APPEND LOOP 
a3eb				if DEBUG_FORTH_WORDS_KEY 
a3eb					DMARK "UWR" 
a3eb f5				push af  
a3ec 3a 00 a4			ld a, (.dmark)  
a3ef 32 b7 ee			ld (debug_mark),a  
a3f2 3a 01 a4			ld a, (.dmark+1)  
a3f5 32 b8 ee			ld (debug_mark+1),a  
a3f8 3a 02 a4			ld a, (.dmark+2)  
a3fb 32 b9 ee			ld (debug_mark+2),a  
a3fe 18 03			jr .pastdmark  
a400 ..			.dmark: db "UWR"  
a403 f1			.pastdmark: pop af  
a404			endm  
# End of macro DMARK
a404					CALLMONITOR 
a404 cd 62 93			call break_point_state  
a407				endm  
# End of macro CALLMONITOR
a407				endif 
a407 21 d5 d7				ld hl, baseram 
a40a					;ld hl, baseusermem 
a40a 01 00 00				ld bc, 0    ; start a counter 
a40d			 
a40d				; skip dict stub 
a40d			 
a40d cd a9 9d				call forth_tok_next 
a410			 
a410			 
a410			; while we have words to look for 
a410			 
a410 7e			.douscan:	ld a, (hl)      
a411				if DEBUG_FORTH_WORDS 
a411					DMARK "UWs" 
a411 f5				push af  
a412 3a 26 a4			ld a, (.dmark)  
a415 32 b7 ee			ld (debug_mark),a  
a418 3a 27 a4			ld a, (.dmark+1)  
a41b 32 b8 ee			ld (debug_mark+1),a  
a41e 3a 28 a4			ld a, (.dmark+2)  
a421 32 b9 ee			ld (debug_mark+2),a  
a424 18 03			jr .pastdmark  
a426 ..			.dmark: db "UWs"  
a429 f1			.pastdmark: pop af  
a42a			endm  
# End of macro DMARK
a42a					CALLMONITOR 
a42a cd 62 93			call break_point_state  
a42d				endm  
# End of macro CALLMONITOR
a42d				endif 
a42d fe 00				cp WORD_SYS_END 
a42f 28 4d				jr z, .udone 
a431 fe 01				cp WORD_SYS_UWORD 
a433 20 44				jr nz, .nuword 
a435			 
a435				if DEBUG_FORTH_WORDS 
a435					DMARK "UWu" 
a435 f5				push af  
a436 3a 4a a4			ld a, (.dmark)  
a439 32 b7 ee			ld (debug_mark),a  
a43c 3a 4b a4			ld a, (.dmark+1)  
a43f 32 b8 ee			ld (debug_mark+1),a  
a442 3a 4c a4			ld a, (.dmark+2)  
a445 32 b9 ee			ld (debug_mark+2),a  
a448 18 03			jr .pastdmark  
a44a ..			.dmark: db "UWu"  
a44d f1			.pastdmark: pop af  
a44e			endm  
# End of macro DMARK
a44e					CALLMONITOR 
a44e cd 62 93			call break_point_state  
a451				endm  
# End of macro CALLMONITOR
a451				endif 
a451					; we have a uword so push its name to the stack 
a451			 
a451 e5				   	push hl  ; save so we can move to next dict block 
a452			 
a452					; skip opcode 
a452 23					inc hl  
a453					; skip next ptr 
a453 23					inc hl  
a454 23					inc hl 
a455					; skip len 
a455 23					inc hl 
a456				if DEBUG_FORTH_WORDS 
a456					DMARK "UWt" 
a456 f5				push af  
a457 3a 6b a4			ld a, (.dmark)  
a45a 32 b7 ee			ld (debug_mark),a  
a45d 3a 6c a4			ld a, (.dmark+1)  
a460 32 b8 ee			ld (debug_mark+1),a  
a463 3a 6d a4			ld a, (.dmark+2)  
a466 32 b9 ee			ld (debug_mark+2),a  
a469 18 03			jr .pastdmark  
a46b ..			.dmark: db "UWt"  
a46e f1			.pastdmark: pop af  
a46f			endm  
# End of macro DMARK
a46f					CALLMONITOR 
a46f cd 62 93			call break_point_state  
a472				endm  
# End of macro CALLMONITOR
a472				endif 
a472 03					inc bc 
a473			 
a473 c5					push bc 
a474 cd 5d 99				call forth_push_str 
a477 c1					pop bc 
a478			 
a478 e1					pop hl 	 
a479			 
a479 cd a9 9d		.nuword:	call forth_tok_next 
a47c 18 92				jr .douscan  
a47e			 
a47e			.udone:		 ; push count of uwords found 
a47e c5					push bc 
a47f e1					pop hl 
a480			 
a480				if DEBUG_FORTH_WORDS 
a480					DMARK "UWc" 
a480 f5				push af  
a481 3a 95 a4			ld a, (.dmark)  
a484 32 b7 ee			ld (debug_mark),a  
a487 3a 96 a4			ld a, (.dmark+1)  
a48a 32 b8 ee			ld (debug_mark+1),a  
a48d 3a 97 a4			ld a, (.dmark+2)  
a490 32 b9 ee			ld (debug_mark+2),a  
a493 18 03			jr .pastdmark  
a495 ..			.dmark: db "UWc"  
a498 f1			.pastdmark: pop af  
a499			endm  
# End of macro DMARK
a499					CALLMONITOR 
a499 cd 62 93			call break_point_state  
a49c				endm  
# End of macro CALLMONITOR
a49c				endif 
a49c cd ef 98				call forth_push_numhl 
a49f			 
a49f			 
a49f				       NEXTW 
a49f c3 58 9c			jp macro_next 
a4a2				endm 
# End of macro NEXTW
a4a2			 
a4a2			.BP: 
a4a2				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a4a2 54				db WORD_SYS_CORE+64             
a4a3 d8 a4			dw .MONITOR            
a4a5 03				db 2 + 1 
a4a6 .. 00			db "BP",0              
a4a9				endm 
# End of macro CWHEAD
a4a9			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a4a9			; | | $00 Will enable the break points within specific code paths 
a4a9			; | | $01 Will disable break points 
a4a9			; | |  
a4a9			; | | By default break points are off. Either the above can be used to enable them 
a4a9			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a4a9			; | | and on release of the pressed key a message will be disaplayed to notify 
a4a9			; | | that break points are enabled. Pressing any key will then continue boot process. 
a4a9					; get byte count 
a4a9					if DEBUG_FORTH_WORDS_KEY 
a4a9						DMARK "BP." 
a4a9 f5				push af  
a4aa 3a be a4			ld a, (.dmark)  
a4ad 32 b7 ee			ld (debug_mark),a  
a4b0 3a bf a4			ld a, (.dmark+1)  
a4b3 32 b8 ee			ld (debug_mark+1),a  
a4b6 3a c0 a4			ld a, (.dmark+2)  
a4b9 32 b9 ee			ld (debug_mark+2),a  
a4bc 18 03			jr .pastdmark  
a4be ..			.dmark: db "BP."  
a4c1 f1			.pastdmark: pop af  
a4c2			endm  
# End of macro DMARK
a4c2						CALLMONITOR 
a4c2 cd 62 93			call break_point_state  
a4c5				endm  
# End of macro CALLMONITOR
a4c5					endif 
a4c5			 
a4c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4c5 cd e6 9a			call macro_dsp_valuehl 
a4c8				endm 
# End of macro FORTH_DSP_VALUEHL
a4c8			 
a4c8			;		push hl 
a4c8			 
a4c8					; destroy value TOS 
a4c8			 
a4c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4c8 cd 9e 9b			call macro_forth_dsp_pop 
a4cb				endm 
# End of macro FORTH_DSP_POP
a4cb			 
a4cb			;		pop hl 
a4cb			 
a4cb 3e 00				ld a,0 
a4cd bd					cp l 
a4ce 28 02				jr z, .bpset 
a4d0 3e 2a				ld a, '*' 
a4d2			 
a4d2 32 ce e4		.bpset:		ld (os_view_disable), a 
a4d5			 
a4d5			 
a4d5					NEXTW 
a4d5 c3 58 9c			jp macro_next 
a4d8				endm 
# End of macro NEXTW
a4d8			 
a4d8			 
a4d8			.MONITOR: 
a4d8				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a4d8 55				db WORD_SYS_CORE+65             
a4d9 0b a5			dw .MALLOC            
a4db 08				db 7 + 1 
a4dc .. 00			db "MONITOR",0              
a4e4				endm 
# End of macro CWHEAD
a4e4			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a4e4			; | | At start the current various registers will be displayed with contents. 
a4e4			; | | Top right corner will show the most recent debug marker seen. 
a4e4			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a4e4			; | | and the return stack pointer (RSP). 
a4e4			; | | Pressing: 
a4e4			; | |    1 - Initial screen 
a4e4			; | |    2 - Display a data dump of HL 
a4e4			; | |    3 - Display a data dump of DE 
a4e4			; | |    4 - Display a data dump of BC 
a4e4			; | |    5 - Display a data dump of HL 
a4e4			; | |    6 - Display a data dump of DSP 
a4e4			; | |    7 - Display a data dump of RSP 
a4e4			; | |    8 - Display a data dump of what is at DSP 
a4e4			; | |    9 - Display a data dump of what is at RSP 
a4e4			; | |    0 - Exit monitor and continue running. This will also enable break points 
a4e4			; | |    * - Disable break points 
a4e4			; | |    # - Enter traditional monitor mode 
a4e4			; | | 
a4e4			; | | Monitor Mode 
a4e4			; | | ------------ 
a4e4			; | | A prompt of '>' will be shown for various commands: 
a4e4			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a4e4			; | |    C - Continue display a data dump from the last set address 
a4e4			; | |    M xxxx - Set start of memory edit at address xx 
a4e4			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a4e4			; | |    Q - Return to previous 
a4e4					if DEBUG_FORTH_WORDS_KEY 
a4e4						DMARK "MON" 
a4e4 f5				push af  
a4e5 3a f9 a4			ld a, (.dmark)  
a4e8 32 b7 ee			ld (debug_mark),a  
a4eb 3a fa a4			ld a, (.dmark+1)  
a4ee 32 b8 ee			ld (debug_mark+1),a  
a4f1 3a fb a4			ld a, (.dmark+2)  
a4f4 32 b9 ee			ld (debug_mark+2),a  
a4f7 18 03			jr .pastdmark  
a4f9 ..			.dmark: db "MON"  
a4fc f1			.pastdmark: pop af  
a4fd			endm  
# End of macro DMARK
a4fd						CALLMONITOR 
a4fd cd 62 93			call break_point_state  
a500				endm  
# End of macro CALLMONITOR
a500					endif 
a500 3e 00				ld a, 0 
a502 32 ce e4				ld (os_view_disable), a 
a505			 
a505					CALLMONITOR 
a505 cd 62 93			call break_point_state  
a508				endm  
# End of macro CALLMONITOR
a508			 
a508			;	call monitor 
a508			 
a508					NEXTW 
a508 c3 58 9c			jp macro_next 
a50b				endm 
# End of macro NEXTW
a50b			 
a50b			 
a50b			.MALLOC: 
a50b				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a50b 56				db WORD_SYS_CORE+66             
a50c 34 a5			dw .MALLOC2            
a50e 06				db 5 + 1 
a50f .. 00			db "ALLOT",0              
a515				endm 
# End of macro CWHEAD
a515			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a515					if DEBUG_FORTH_WORDS_KEY 
a515						DMARK "ALL" 
a515 f5				push af  
a516 3a 2a a5			ld a, (.dmark)  
a519 32 b7 ee			ld (debug_mark),a  
a51c 3a 2b a5			ld a, (.dmark+1)  
a51f 32 b8 ee			ld (debug_mark+1),a  
a522 3a 2c a5			ld a, (.dmark+2)  
a525 32 b9 ee			ld (debug_mark+2),a  
a528 18 03			jr .pastdmark  
a52a ..			.dmark: db "ALL"  
a52d f1			.pastdmark: pop af  
a52e			endm  
# End of macro DMARK
a52e						CALLMONITOR 
a52e cd 62 93			call break_point_state  
a531				endm  
# End of macro CALLMONITOR
a531					endif 
a531 c3 5b a5				jp .mallocc 
a534			.MALLOC2: 
a534				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a534 56				db WORD_SYS_CORE+66             
a535 72 a5			dw .FREE            
a537 07				db 6 + 1 
a538 .. 00			db "MALLOC",0              
a53f				endm 
# End of macro CWHEAD
a53f			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a53f					; get byte count 
a53f					if DEBUG_FORTH_WORDS_KEY 
a53f						DMARK "MAL" 
a53f f5				push af  
a540 3a 54 a5			ld a, (.dmark)  
a543 32 b7 ee			ld (debug_mark),a  
a546 3a 55 a5			ld a, (.dmark+1)  
a549 32 b8 ee			ld (debug_mark+1),a  
a54c 3a 56 a5			ld a, (.dmark+2)  
a54f 32 b9 ee			ld (debug_mark+2),a  
a552 18 03			jr .pastdmark  
a554 ..			.dmark: db "MAL"  
a557 f1			.pastdmark: pop af  
a558			endm  
# End of macro DMARK
a558						CALLMONITOR 
a558 cd 62 93			call break_point_state  
a55b				endm  
# End of macro CALLMONITOR
a55b					endif 
a55b			.mallocc: 
a55b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a55b cd e6 9a			call macro_dsp_valuehl 
a55e				endm 
# End of macro FORTH_DSP_VALUEHL
a55e			 
a55e			;		push hl 
a55e			 
a55e					; destroy value TOS 
a55e			 
a55e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a55e cd 9e 9b			call macro_forth_dsp_pop 
a561				endm 
# End of macro FORTH_DSP_POP
a561			 
a561			;		pop hl 
a561 cd 80 8f				call malloc 
a564				if DEBUG_FORTH_MALLOC_GUARD 
a564 f5					push af 
a565 cd e2 8a				call ishlzero 
a568			;		ld a, l 
a568			;		add h 
a568			;		cp 0 
a568 f1					pop af 
a569					 
a569 cc 8a c4				call z,malloc_error 
a56c				endif 
a56c			 
a56c cd ef 98				call forth_push_numhl 
a56f					NEXTW 
a56f c3 58 9c			jp macro_next 
a572				endm 
# End of macro NEXTW
a572			 
a572			.FREE: 
a572				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a572 57				db WORD_SYS_CORE+67             
a573 a3 a5			dw .LIST            
a575 05				db 4 + 1 
a576 .. 00			db "FREE",0              
a57b				endm 
# End of macro CWHEAD
a57b			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a57b					if DEBUG_FORTH_WORDS_KEY 
a57b						DMARK "FRE" 
a57b f5				push af  
a57c 3a 90 a5			ld a, (.dmark)  
a57f 32 b7 ee			ld (debug_mark),a  
a582 3a 91 a5			ld a, (.dmark+1)  
a585 32 b8 ee			ld (debug_mark+1),a  
a588 3a 92 a5			ld a, (.dmark+2)  
a58b 32 b9 ee			ld (debug_mark+2),a  
a58e 18 03			jr .pastdmark  
a590 ..			.dmark: db "FRE"  
a593 f1			.pastdmark: pop af  
a594			endm  
# End of macro DMARK
a594						CALLMONITOR 
a594 cd 62 93			call break_point_state  
a597				endm  
# End of macro CALLMONITOR
a597					endif 
a597					; get address 
a597			 
a597					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a597 cd e6 9a			call macro_dsp_valuehl 
a59a				endm 
# End of macro FORTH_DSP_VALUEHL
a59a			 
a59a			;		push hl 
a59a			 
a59a					; destroy value TOS 
a59a			 
a59a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a59a cd 9e 9b			call macro_forth_dsp_pop 
a59d				endm 
# End of macro FORTH_DSP_POP
a59d			 
a59d			;		pop hl 
a59d			if FORTH_ENABLE_MALLOCFREE 
a59d cd 4a 90				call free 
a5a0			endif 
a5a0					NEXTW 
a5a0 c3 58 9c			jp macro_next 
a5a3				endm 
# End of macro NEXTW
a5a3			.LIST: 
a5a3				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a5a3 5c				db WORD_SYS_CORE+72             
a5a4 91 a7			dw .FORGET            
a5a6 05				db 4 + 1 
a5a7 .. 00			db "LIST",0              
a5ac				endm 
# End of macro CWHEAD
a5ac			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a5ac			; | | The quoted word must be in upper case. 
a5ac				if DEBUG_FORTH_WORDS_KEY 
a5ac					DMARK "LST" 
a5ac f5				push af  
a5ad 3a c1 a5			ld a, (.dmark)  
a5b0 32 b7 ee			ld (debug_mark),a  
a5b3 3a c2 a5			ld a, (.dmark+1)  
a5b6 32 b8 ee			ld (debug_mark+1),a  
a5b9 3a c3 a5			ld a, (.dmark+2)  
a5bc 32 b9 ee			ld (debug_mark+2),a  
a5bf 18 03			jr .pastdmark  
a5c1 ..			.dmark: db "LST"  
a5c4 f1			.pastdmark: pop af  
a5c5			endm  
# End of macro DMARK
a5c5					CALLMONITOR 
a5c5 cd 62 93			call break_point_state  
a5c8				endm  
# End of macro CALLMONITOR
a5c8				endif 
a5c8			 
a5c8					FORTH_DSP_VALUEHL 
a5c8 cd e6 9a			call macro_dsp_valuehl 
a5cb				endm 
# End of macro FORTH_DSP_VALUEHL
a5cb			 
a5cb e5					push hl 
a5cc					FORTH_DSP_POP 
a5cc cd 9e 9b			call macro_forth_dsp_pop 
a5cf				endm 
# End of macro FORTH_DSP_POP
a5cf c1					pop bc 
a5d0			 
a5d0			; Start format of scratch string 
a5d0			 
a5d0 21 dd e4				ld hl, scratch 
a5d3			 
a5d3 3e 3a				ld a, ':' 
a5d5 77					ld (hl),a 
a5d6 23					inc hl 
a5d7 3e 20				ld a, ' ' 
a5d9 77					ld (hl), a 
a5da			 
a5da					; Get ptr to the word we need to look up 
a5da			 
a5da			;		FORTH_DSP_VALUEHL 
a5da					;v5 FORTH_DSP_VALUE 
a5da				; TODO type check 
a5da			;		inc hl    ; Skip type check  
a5da			;		push hl 
a5da			;		ex de, hl    ; put into DE 
a5da			 
a5da			 
a5da 21 d5 d7				ld hl, baseram 
a5dd					;ld hl, baseusermem 
a5dd			 
a5dd e5			push hl   ; sacreifical push 
a5de			 
a5de			.ldouscanm: 
a5de e1				pop hl 
a5df			.ldouscan: 
a5df				if DEBUG_FORTH_WORDS 
a5df					DMARK "LSs" 
a5df f5				push af  
a5e0 3a f4 a5			ld a, (.dmark)  
a5e3 32 b7 ee			ld (debug_mark),a  
a5e6 3a f5 a5			ld a, (.dmark+1)  
a5e9 32 b8 ee			ld (debug_mark+1),a  
a5ec 3a f6 a5			ld a, (.dmark+2)  
a5ef 32 b9 ee			ld (debug_mark+2),a  
a5f2 18 03			jr .pastdmark  
a5f4 ..			.dmark: db "LSs"  
a5f7 f1			.pastdmark: pop af  
a5f8			endm  
# End of macro DMARK
a5f8					CALLMONITOR 
a5f8 cd 62 93			call break_point_state  
a5fb				endm  
# End of macro CALLMONITOR
a5fb				endif 
a5fb				; skip dict stub 
a5fb cd a9 9d				call forth_tok_next 
a5fe			 
a5fe			 
a5fe			; while we have words to look for 
a5fe			 
a5fe 7e				ld a, (hl)      
a5ff				if DEBUG_FORTH_WORDS 
a5ff					DMARK "LSk" 
a5ff f5				push af  
a600 3a 14 a6			ld a, (.dmark)  
a603 32 b7 ee			ld (debug_mark),a  
a606 3a 15 a6			ld a, (.dmark+1)  
a609 32 b8 ee			ld (debug_mark+1),a  
a60c 3a 16 a6			ld a, (.dmark+2)  
a60f 32 b9 ee			ld (debug_mark+2),a  
a612 18 03			jr .pastdmark  
a614 ..			.dmark: db "LSk"  
a617 f1			.pastdmark: pop af  
a618			endm  
# End of macro DMARK
a618					CALLMONITOR 
a618 cd 62 93			call break_point_state  
a61b				endm  
# End of macro CALLMONITOR
a61b				endif 
a61b					;cp WORD_SYS_END 
a61b					;jp z, .lunotfound 
a61b			 
a61b					; if we hit non uwords then gone too far 
a61b fe 01				cp WORD_SYS_UWORD 
a61d c2 4d a7				jp nz, .lunotfound 
a620			 
a620				if DEBUG_FORTH_WORDS 
a620					DMARK "LSu" 
a620 f5				push af  
a621 3a 35 a6			ld a, (.dmark)  
a624 32 b7 ee			ld (debug_mark),a  
a627 3a 36 a6			ld a, (.dmark+1)  
a62a 32 b8 ee			ld (debug_mark+1),a  
a62d 3a 37 a6			ld a, (.dmark+2)  
a630 32 b9 ee			ld (debug_mark+2),a  
a633 18 03			jr .pastdmark  
a635 ..			.dmark: db "LSu"  
a638 f1			.pastdmark: pop af  
a639			endm  
# End of macro DMARK
a639					CALLMONITOR 
a639 cd 62 93			call break_point_state  
a63c				endm  
# End of macro CALLMONITOR
a63c				endif 
a63c			 
a63c					; found a uword but is it the one we want... 
a63c			 
a63c c5					push bc     ; uword to find is on bc 
a63d d1					pop de 
a63e			 
a63e e5					push hl  ; to save the ptr 
a63f			 
a63f					; skip opcode 
a63f 23					inc hl  
a640					; skip next ptr 
a640 23					inc hl  
a641 23					inc hl 
a642					; skip len 
a642 23					inc hl 
a643			 
a643				if DEBUG_FORTH_WORDS 
a643					DMARK "LSc" 
a643 f5				push af  
a644 3a 58 a6			ld a, (.dmark)  
a647 32 b7 ee			ld (debug_mark),a  
a64a 3a 59 a6			ld a, (.dmark+1)  
a64d 32 b8 ee			ld (debug_mark+1),a  
a650 3a 5a a6			ld a, (.dmark+2)  
a653 32 b9 ee			ld (debug_mark+2),a  
a656 18 03			jr .pastdmark  
a658 ..			.dmark: db "LSc"  
a65b f1			.pastdmark: pop af  
a65c			endm  
# End of macro DMARK
a65c					CALLMONITOR 
a65c cd 62 93			call break_point_state  
a65f				endm  
# End of macro CALLMONITOR
a65f				endif 
a65f cd 4f 8f				call strcmp 
a662 c2 de a5				jp nz, .ldouscanm 
a665				 
a665			 
a665			 
a665					; we have a uword so push its name to the stack 
a665			 
a665			;	   	push hl  ; save so we can move to next dict block 
a665 e1			pop hl 
a666			 
a666				if DEBUG_FORTH_WORDS 
a666					DMARK "LSm" 
a666 f5				push af  
a667 3a 7b a6			ld a, (.dmark)  
a66a 32 b7 ee			ld (debug_mark),a  
a66d 3a 7c a6			ld a, (.dmark+1)  
a670 32 b8 ee			ld (debug_mark+1),a  
a673 3a 7d a6			ld a, (.dmark+2)  
a676 32 b9 ee			ld (debug_mark+2),a  
a679 18 03			jr .pastdmark  
a67b ..			.dmark: db "LSm"  
a67e f1			.pastdmark: pop af  
a67f			endm  
# End of macro DMARK
a67f					CALLMONITOR 
a67f cd 62 93			call break_point_state  
a682				endm  
# End of macro CALLMONITOR
a682				endif 
a682			 
a682					; skip opcode 
a682 23					inc hl  
a683					; skip next ptr 
a683 23					inc hl  
a684 23					inc hl 
a685					; skip len 
a685 7e					ld a, (hl)   ; save length to add 
a686				if DEBUG_FORTH_WORDS 
a686					DMARK "LS2" 
a686 f5				push af  
a687 3a 9b a6			ld a, (.dmark)  
a68a 32 b7 ee			ld (debug_mark),a  
a68d 3a 9c a6			ld a, (.dmark+1)  
a690 32 b8 ee			ld (debug_mark+1),a  
a693 3a 9d a6			ld a, (.dmark+2)  
a696 32 b9 ee			ld (debug_mark+2),a  
a699 18 03			jr .pastdmark  
a69b ..			.dmark: db "LS2"  
a69e f1			.pastdmark: pop af  
a69f			endm  
# End of macro DMARK
a69f					CALLMONITOR 
a69f cd 62 93			call break_point_state  
a6a2				endm  
# End of macro CALLMONITOR
a6a2				endif 
a6a2			 
a6a2					; save this location 
a6a2				 
a6a2 e5					push hl 
a6a3			 
a6a3 23					inc hl 
a6a4 11 df e4				ld de, scratch+2 
a6a7 4f					ld c, a 
a6a8 06 00				ld b, 0 
a6aa			 
a6aa				if DEBUG_FORTH_WORDS 
a6aa					DMARK "LSn" 
a6aa f5				push af  
a6ab 3a bf a6			ld a, (.dmark)  
a6ae 32 b7 ee			ld (debug_mark),a  
a6b1 3a c0 a6			ld a, (.dmark+1)  
a6b4 32 b8 ee			ld (debug_mark+1),a  
a6b7 3a c1 a6			ld a, (.dmark+2)  
a6ba 32 b9 ee			ld (debug_mark+2),a  
a6bd 18 03			jr .pastdmark  
a6bf ..			.dmark: db "LSn"  
a6c2 f1			.pastdmark: pop af  
a6c3			endm  
# End of macro DMARK
a6c3					CALLMONITOR 
a6c3 cd 62 93			call break_point_state  
a6c6				endm  
# End of macro CALLMONITOR
a6c6				endif 
a6c6			 
a6c6					; copy uword name to scratch 
a6c6			 
a6c6 ed b0				ldir 
a6c8			 
a6c8 1b					dec de 
a6c9 3e 20				ld a, ' '    ; change null to space 
a6cb 12					ld (de), a 
a6cc			 
a6cc 13					inc de 
a6cd			 
a6cd d5					push de 
a6ce c1					pop bc     ; move scratch pointer to end of word name and save it 
a6cf			 
a6cf e1					pop hl 
a6d0 7e					ld a, (hl) 
a6d1					;inc hl 
a6d1					; skip word string 
a6d1 cd b9 8a				call addatohl 
a6d4			 
a6d4 23					inc hl 
a6d5			 
a6d5				if DEBUG_FORTH_WORDS 
a6d5					DMARK "LS3" 
a6d5 f5				push af  
a6d6 3a ea a6			ld a, (.dmark)  
a6d9 32 b7 ee			ld (debug_mark),a  
a6dc 3a eb a6			ld a, (.dmark+1)  
a6df 32 b8 ee			ld (debug_mark+1),a  
a6e2 3a ec a6			ld a, (.dmark+2)  
a6e5 32 b9 ee			ld (debug_mark+2),a  
a6e8 18 03			jr .pastdmark  
a6ea ..			.dmark: db "LS3"  
a6ed f1			.pastdmark: pop af  
a6ee			endm  
# End of macro DMARK
a6ee					CALLMONITOR 
a6ee cd 62 93			call break_point_state  
a6f1				endm  
# End of macro CALLMONITOR
a6f1				endif 
a6f1					; should now be at the start of the machine code to setup the eval of the uword 
a6f1					; now locate the ptr to the string defintion 
a6f1			 
a6f1					; skip ld hl, 
a6f1					; then load the ptr 
a6f1			; TODO use get from hl ptr 
a6f1 23					inc hl 
a6f2 5e					ld e, (hl) 
a6f3 23					inc hl 
a6f4 56					ld d, (hl) 
a6f5 eb					ex de, hl 
a6f6			 
a6f6			 
a6f6				if DEBUG_FORTH_WORDS 
a6f6					DMARK "LSt" 
a6f6 f5				push af  
a6f7 3a 0b a7			ld a, (.dmark)  
a6fa 32 b7 ee			ld (debug_mark),a  
a6fd 3a 0c a7			ld a, (.dmark+1)  
a700 32 b8 ee			ld (debug_mark+1),a  
a703 3a 0d a7			ld a, (.dmark+2)  
a706 32 b9 ee			ld (debug_mark+2),a  
a709 18 03			jr .pastdmark  
a70b ..			.dmark: db "LSt"  
a70e f1			.pastdmark: pop af  
a70f			endm  
# End of macro DMARK
a70f					CALLMONITOR 
a70f cd 62 93			call break_point_state  
a712				endm  
# End of macro CALLMONITOR
a712				endif 
a712			 
a712			; cant push right now due to tokenised strings  
a712			 
a712			; get the destination of where to copy this definition to. 
a712			 
a712 c5					push bc 
a713 d1					pop de 
a714			 
a714 7e			.listl:         ld a,(hl) 
a715 fe 00				cp 0 
a717 28 09				jr z, .lreplsp     ; replace zero with space 
a719					;cp FORTH_END_BUFFER 
a719 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a71b 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a71d				 
a71d					; just copy this char as is then 
a71d			 
a71d 12					ld (de), a 
a71e			 
a71e 23			.listnxt:	inc hl 
a71f 13					inc de 
a720 18 f2				jr .listl 
a722			 
a722 3e 20		.lreplsp:	ld a,' ' 
a724 12					ld (de), a 
a725 18 f7				jr .listnxt 
a727			 
a727			; close up uword def 
a727			 
a727			.listdone: 
a727 12					ld (de), a 
a728 13					inc de 
a729 3e 00				ld a, 0 
a72b 12					ld (de), a 
a72c			 
a72c			; now have def so clean up and push to stack 
a72c			 
a72c 21 dd e4				ld hl, scratch 
a72f				if DEBUG_FORTH_WORDS 
a72f					DMARK "Ltp" 
a72f f5				push af  
a730 3a 44 a7			ld a, (.dmark)  
a733 32 b7 ee			ld (debug_mark),a  
a736 3a 45 a7			ld a, (.dmark+1)  
a739 32 b8 ee			ld (debug_mark+1),a  
a73c 3a 46 a7			ld a, (.dmark+2)  
a73f 32 b9 ee			ld (debug_mark+2),a  
a742 18 03			jr .pastdmark  
a744 ..			.dmark: db "Ltp"  
a747 f1			.pastdmark: pop af  
a748			endm  
# End of macro DMARK
a748					CALLMONITOR 
a748 cd 62 93			call break_point_state  
a74b				endm  
# End of macro CALLMONITOR
a74b				endif 
a74b			 
a74b 18 1f			jr .listpush 
a74d			 
a74d			;.lnuword:	pop hl 
a74d			;		call forth_tok_next 
a74d			;		jp .ldouscan  
a74d			 
a74d			.lunotfound:		  
a74d			 
a74d				if DEBUG_FORTH_WORDS 
a74d					DMARK "LSn" 
a74d f5				push af  
a74e 3a 62 a7			ld a, (.dmark)  
a751 32 b7 ee			ld (debug_mark),a  
a754 3a 63 a7			ld a, (.dmark+1)  
a757 32 b8 ee			ld (debug_mark+1),a  
a75a 3a 64 a7			ld a, (.dmark+2)  
a75d 32 b9 ee			ld (debug_mark+2),a  
a760 18 03			jr .pastdmark  
a762 ..			.dmark: db "LSn"  
a765 f1			.pastdmark: pop af  
a766			endm  
# End of macro DMARK
a766					CALLMONITOR 
a766 cd 62 93			call break_point_state  
a769				endm  
# End of macro CALLMONITOR
a769				endif 
a769			 
a769					 
a769			;		FORTH_DSP_POP 
a769			;		ld hl, .luno 
a769			 
a769					NEXTW			 
a769 c3 58 9c			jp macro_next 
a76c				endm 
# End of macro NEXTW
a76c			 
a76c			.listpush: 
a76c				if DEBUG_FORTH_WORDS 
a76c					DMARK "LS>" 
a76c f5				push af  
a76d 3a 81 a7			ld a, (.dmark)  
a770 32 b7 ee			ld (debug_mark),a  
a773 3a 82 a7			ld a, (.dmark+1)  
a776 32 b8 ee			ld (debug_mark+1),a  
a779 3a 83 a7			ld a, (.dmark+2)  
a77c 32 b9 ee			ld (debug_mark+2),a  
a77f 18 03			jr .pastdmark  
a781 ..			.dmark: db "LS>"  
a784 f1			.pastdmark: pop af  
a785			endm  
# End of macro DMARK
a785					CALLMONITOR 
a785 cd 62 93			call break_point_state  
a788				endm  
# End of macro CALLMONITOR
a788				endif 
a788 cd 5d 99				call forth_push_str 
a78b			 
a78b			 
a78b			 
a78b					NEXTW 
a78b c3 58 9c			jp macro_next 
a78e				endm 
# End of macro NEXTW
a78e			 
a78e			;.luno:    db "Word not found",0 
a78e			 
a78e			 
a78e			 
a78e			 
a78e			 
a78e			;		push hl   ; save pointer to start of uword def string 
a78e			; 
a78e			;; look for FORTH_EOL_LINE 
a78e			;		ld a, FORTH_END_BUFFER 
a78e			;		call strlent 
a78e			; 
a78e			;		inc hl		 ; space for coln def 
a78e			;		inc hl 
a78e			;		inc hl          ; space for terms 
a78e			;		inc hl 
a78e			; 
a78e			;		ld a, 20   ; TODO get actual length 
a78e			;		call addatohl    ; include a random amount of room for the uword name 
a78e			; 
a78e			;		 
a78e			;	if DEBUG_FORTH_WORDS 
a78e			;		DMARK "Lt1" 
a78e			;		CALLMONITOR 
a78e			;	endif 
a78e			;		 
a78e			; 
a78e			;; malloc space for the string because we cant change it 
a78e			; 
a78e			;		call malloc 
a78e			;	if DEBUG_FORTH_MALLOC_GUARD 
a78e			;		push af 
a78e			;		call ishlzero 
a78e			;		pop af 
a78e			;		 
a78e			;		call z,malloc_error 
a78e			;	endif 
a78e			; 
a78e			;	if DEBUG_FORTH_WORDS 
a78e			;		DMARK "Lt2" 
a78e			;		CALLMONITOR 
a78e			;	endif 
a78e			;		pop de 
a78e			;		push hl    ; push the malloc to release later 
a78e			;		push hl   ;  push back a copy for the later stack push 
a78e			;		 
a78e			;; copy the string swapping out the zero terms for spaces 
a78e			; 
a78e			;		; de has our source 
a78e			;		; hl has our dest 
a78e			; 
a78e			;; add the coln def 
a78e			; 
a78e			;		ld a, ':' 
a78e			;		ld (hl), a 
a78e			;		inc hl 
a78e			;		ld a, ' ' 
a78e			;		ld (hl), a 
a78e			;		inc hl 
a78e			; 
a78e			;; add the uname word 
a78e			;		push de   ; save our string for now 
a78e			;		ex de, hl 
a78e			; 
a78e			;		FORTH_DSP_VALUE 
a78e			;		;v5 FORTH_DSP_VALUE 
a78e			; 
a78e			;		inc hl   ; skip type but we know by now this is OK 
a78e			; 
a78e			;.luword:	ld a,(hl) 
a78e			;		cp 0 
a78e			;		jr z, .luword2 
a78e			;		ld (de), a 
a78e			;		inc de 
a78e			;		inc hl 
a78e			;		jr .luword 
a78e			; 
a78e			;.luword2:	ld a, ' ' 
a78e			;		ld (de), a 
a78e			;;		inc hl 
a78e			;;		inc de 
a78e			;;		ld (de), a 
a78e			;;		inc hl 
a78e			;		inc de 
a78e			; 
a78e			;		ex de, hl 
a78e			;		pop de 
a78e			;		 
a78e			;		 
a78e			; 
a78e			;; detoken that string and copy it 
a78e			; 
a78e			;	if DEBUG_FORTH_WORDS 
a78e			;		DMARK "Lt2" 
a78e			;		CALLMONITOR 
a78e			;	endif 
a78e			;.ldetok:	ld a, (de) 
a78e			;		cp FORTH_END_BUFFER 
a78e			;		jr z, .ldetokend 
a78e			;		; swap out any zero term for space 
a78e			;		cp 0 
a78e			;		jr nz, .ldetoknext 
a78e			;		ld a, ' ' 
a78e			; 
a78e			;	if DEBUG_FORTH_WORDS 
a78e			;		DMARK "LtS" 
a78e			;		CALLMONITOR 
a78e			;	endif 
a78e			;.ldetoknext:	ld (hl), a 
a78e			;		inc de 
a78e			;		inc hl 
a78e			;		jr .ldetok 
a78e			; 
a78e			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a78e			;		ld (hl), a  
a78e			; 
a78e			;; free that temp malloc 
a78e			; 
a78e			;		pop hl    
a78e			; 
a78e			;	if DEBUG_FORTH_WORDS 
a78e			;		DMARK "Lt4" 
a78e			;		CALLMONITOR 
a78e			;	endif 
a78e			;		call forth_apushstrhl 
a78e			; 
a78e			;		; get rid of temp malloc area 
a78e			; 
a78e			;		pop hl 
a78e			;		call free 
a78e			; 
a78e			;		jr .ludone 
a78e			; 
a78e			;.lnuword:	pop hl 
a78e			;		call forth_tok_next 
a78e			;		jp .ldouscan  
a78e			; 
a78e			;.ludone:		 pop hl 
a78e			; 
a78e					NEXTW 
a78e c3 58 9c			jp macro_next 
a791				endm 
# End of macro NEXTW
a791			 
a791			.FORGET: 
a791				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a791 5d				db WORD_SYS_CORE+73             
a792 0a a8			dw .NOP            
a794 07				db 6 + 1 
a795 .. 00			db "FORGET",0              
a79c				endm 
# End of macro CWHEAD
a79c			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a79c			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a79c			; | |  
a79c			; | | e.g. "MORE" forget 
a79c					if DEBUG_FORTH_WORDS_KEY 
a79c						DMARK "FRG" 
a79c f5				push af  
a79d 3a b1 a7			ld a, (.dmark)  
a7a0 32 b7 ee			ld (debug_mark),a  
a7a3 3a b2 a7			ld a, (.dmark+1)  
a7a6 32 b8 ee			ld (debug_mark+1),a  
a7a9 3a b3 a7			ld a, (.dmark+2)  
a7ac 32 b9 ee			ld (debug_mark+2),a  
a7af 18 03			jr .pastdmark  
a7b1 ..			.dmark: db "FRG"  
a7b4 f1			.pastdmark: pop af  
a7b5			endm  
# End of macro DMARK
a7b5						CALLMONITOR 
a7b5 cd 62 93			call break_point_state  
a7b8				endm  
# End of macro CALLMONITOR
a7b8					endif 
a7b8			 
a7b8				; find uword 
a7b8			        ; update start of word with "_" 
a7b8				; replace uword with deleted flag 
a7b8			 
a7b8			 
a7b8			;	if DEBUG_FORTH_WORDS 
a7b8			;		DMARK "FOG" 
a7b8			;		CALLMONITOR 
a7b8			;	endif 
a7b8			 
a7b8			 
a7b8					; Get ptr to the word we need to look up 
a7b8			 
a7b8					FORTH_DSP_VALUEHL 
a7b8 cd e6 9a			call macro_dsp_valuehl 
a7bb				endm 
# End of macro FORTH_DSP_VALUEHL
a7bb					;v5 FORTH_DSP_VALUE 
a7bb				; TODO type check 
a7bb			;		inc hl    ; Skip type check  
a7bb e5					push hl 
a7bc c1					pop bc 
a7bd			;		ex de, hl    ; put into DE 
a7bd			 
a7bd			 
a7bd 21 d5 d7				ld hl, baseram 
a7c0					;ld hl, baseusermem 
a7c0			 
a7c0				; skip dict stub 
a7c0			;	call forth_tok_next 
a7c0 e5			push hl   ; sacreifical push 
a7c1			 
a7c1			.fldouscanm: 
a7c1 e1				pop hl 
a7c2			.fldouscan: 
a7c2			;	if DEBUG_FORTH_WORDS 
a7c2			;		DMARK "LSs" 
a7c2			;		CALLMONITOR 
a7c2			;	endif 
a7c2				; skip dict stub 
a7c2 cd a9 9d				call forth_tok_next 
a7c5			 
a7c5			 
a7c5			; while we have words to look for 
a7c5			 
a7c5 7e				ld a, (hl)      
a7c6			;	if DEBUG_FORTH_WORDS 
a7c6			;		DMARK "LSk" 
a7c6			;		CALLMONITOR 
a7c6			;	endif 
a7c6 fe 00				cp WORD_SYS_END 
a7c8 ca 04 a8				jp z, .flunotfound 
a7cb fe 01				cp WORD_SYS_UWORD 
a7cd c2 c2 a7				jp nz, .fldouscan 
a7d0			 
a7d0			;	if DEBUG_FORTH_WORDS 
a7d0			;		DMARK "LSu" 
a7d0			;		CALLMONITOR 
a7d0			;	endif 
a7d0			 
a7d0					; found a uword but is it the one we want... 
a7d0			 
a7d0 c5					push bc     ; uword to find is on bc 
a7d1 d1					pop de 
a7d2			 
a7d2 e5					push hl  ; to save the ptr 
a7d3			 
a7d3					; skip opcode 
a7d3 23					inc hl  
a7d4					; skip next ptr 
a7d4 23					inc hl  
a7d5 23					inc hl 
a7d6					; skip len 
a7d6 23					inc hl 
a7d7			 
a7d7			;	if DEBUG_FORTH_WORDS 
a7d7			;		DMARK "LSc" 
a7d7			;		CALLMONITOR 
a7d7			;	endif 
a7d7 cd 4f 8f				call strcmp 
a7da c2 c1 a7				jp nz, .fldouscanm 
a7dd			; 
a7dd			; 
a7dd			;; while we have words to look for 
a7dd			; 
a7dd			;.fdouscan:	ld a, (hl)      
a7dd			;	if DEBUG_FORTH_WORDS 
a7dd			;		DMARK "LSs" 
a7dd			;		CALLMONITOR 
a7dd			;	endif 
a7dd			;		cp WORD_SYS_END 
a7dd			;		jp z, .fudone 
a7dd			;		cp WORD_SYS_UWORD 
a7dd			;		jp nz, .fnuword 
a7dd			; 
a7dd			;	if DEBUG_FORTH_WORDS 
a7dd			;		DMARK "FGu" 
a7dd			;		CALLMONITOR 
a7dd			;	endif 
a7dd			; 
a7dd			;		; found a uword but is it the one we want... 
a7dd			; 
a7dd			; 
a7dd			;	        pop de   ; get back the dsp name 
a7dd			;		push de 
a7dd			; 
a7dd			;		push hl  ; to save the ptr 
a7dd			; 
a7dd			;		; skip opcode 
a7dd			;		inc hl  
a7dd			;		; skip next ptr 
a7dd			;		inc hl  
a7dd			;		inc hl 
a7dd			;		; skip len 
a7dd			;		inc hl 
a7dd			; 
a7dd			;	if DEBUG_FORTH_WORDS 
a7dd			;		DMARK "FGc" 
a7dd			;		CALLMONITOR 
a7dd			;	endif 
a7dd			;		call strcmp 
a7dd			;		jp nz, .fnuword 
a7dd			 
a7dd			 
a7dd e1			pop hl 
a7de			 
a7de				 
a7de				if DEBUG_FORTH_WORDS 
a7de					DMARK "FGm" 
a7de f5				push af  
a7df 3a f3 a7			ld a, (.dmark)  
a7e2 32 b7 ee			ld (debug_mark),a  
a7e5 3a f4 a7			ld a, (.dmark+1)  
a7e8 32 b8 ee			ld (debug_mark+1),a  
a7eb 3a f5 a7			ld a, (.dmark+2)  
a7ee 32 b9 ee			ld (debug_mark+2),a  
a7f1 18 03			jr .pastdmark  
a7f3 ..			.dmark: db "FGm"  
a7f6 f1			.pastdmark: pop af  
a7f7			endm  
# End of macro DMARK
a7f7					CALLMONITOR 
a7f7 cd 62 93			call break_point_state  
a7fa				endm  
# End of macro CALLMONITOR
a7fa				endif 
a7fa			 
a7fa			 
a7fa			 
a7fa					; we have a uword so push its name to the stack 
a7fa			 
a7fa			;	   	push hl  ; save so we can move to next dict block 
a7fa			;pop hl 
a7fa			 
a7fa					; update opcode to deleted 
a7fa 3e 03				ld a, WORD_SYS_DELETED 
a7fc 77					ld (hl), a 
a7fd			 
a7fd 23					inc hl  
a7fe					; skip next ptr 
a7fe 23					inc hl  
a7ff 23					inc hl 
a800					; skip len 
a800 23					inc hl 
a801			 
a801					; TODO change parser to skip deleted words but for now mark it out 
a801 3e 5f				ld a, "_" 
a803 77					ld  (hl),a 
a804			 
a804			;		jr .fudone 
a804			; 
a804			;.fnuword:	pop hl 
a804			;		call forth_tok_next 
a804			;		jp .fdouscan  
a804			 
a804			.flunotfound:		  
a804			 
a804			 
a804					 
a804					FORTH_DSP_POP 
a804 cd 9e 9b			call macro_forth_dsp_pop 
a807				endm 
# End of macro FORTH_DSP_POP
a807			;		ld hl, .luno 
a807			;.fudone:		 pop hl 
a807					NEXTW 
a807 c3 58 9c			jp macro_next 
a80a				endm 
# End of macro NEXTW
a80a			.NOP: 
a80a				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a80a 61				db WORD_SYS_CORE+77             
a80b 31 a8			dw .COMO            
a80d 04				db 3 + 1 
a80e .. 00			db "NOP",0              
a812				endm 
# End of macro CWHEAD
a812			; | NOP (  --  ) Do nothing | DONE 
a812					if DEBUG_FORTH_WORDS_KEY 
a812						DMARK "NOP" 
a812 f5				push af  
a813 3a 27 a8			ld a, (.dmark)  
a816 32 b7 ee			ld (debug_mark),a  
a819 3a 28 a8			ld a, (.dmark+1)  
a81c 32 b8 ee			ld (debug_mark+1),a  
a81f 3a 29 a8			ld a, (.dmark+2)  
a822 32 b9 ee			ld (debug_mark+2),a  
a825 18 03			jr .pastdmark  
a827 ..			.dmark: db "NOP"  
a82a f1			.pastdmark: pop af  
a82b			endm  
# End of macro DMARK
a82b						CALLMONITOR 
a82b cd 62 93			call break_point_state  
a82e				endm  
# End of macro CALLMONITOR
a82e					endif 
a82e				       NEXTW 
a82e c3 58 9c			jp macro_next 
a831				endm 
# End of macro NEXTW
a831			.COMO: 
a831				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a831 6e				db WORD_SYS_CORE+90             
a832 83 a8			dw .COMC            
a834 02				db 1 + 1 
a835 .. 00			db "(",0              
a837				endm 
# End of macro CWHEAD
a837			; | ( ( -- )  Start of comment | DONE 
a837			 
a837			 
a837 2a de e7				ld hl, ( os_tok_ptr) 
a83a 11 7e a8			ld de, .closepar 
a83d					 
a83d					if DEBUG_FORTH_WORDS 
a83d						DMARK ").." 
a83d f5				push af  
a83e 3a 52 a8			ld a, (.dmark)  
a841 32 b7 ee			ld (debug_mark),a  
a844 3a 53 a8			ld a, (.dmark+1)  
a847 32 b8 ee			ld (debug_mark+1),a  
a84a 3a 54 a8			ld a, (.dmark+2)  
a84d 32 b9 ee			ld (debug_mark+2),a  
a850 18 03			jr .pastdmark  
a852 ..			.dmark: db ").."  
a855 f1			.pastdmark: pop af  
a856			endm  
# End of macro DMARK
a856						CALLMONITOR 
a856 cd 62 93			call break_point_state  
a859				endm  
# End of macro CALLMONITOR
a859					endif 
a859 cd 73 9d			call findnexttok  
a85c			 
a85c					if DEBUG_FORTH_WORDS 
a85c						DMARK "IF5" 
a85c f5				push af  
a85d 3a 71 a8			ld a, (.dmark)  
a860 32 b7 ee			ld (debug_mark),a  
a863 3a 72 a8			ld a, (.dmark+1)  
a866 32 b8 ee			ld (debug_mark+1),a  
a869 3a 73 a8			ld a, (.dmark+2)  
a86c 32 b9 ee			ld (debug_mark+2),a  
a86f 18 03			jr .pastdmark  
a871 ..			.dmark: db "IF5"  
a874 f1			.pastdmark: pop af  
a875			endm  
# End of macro DMARK
a875						CALLMONITOR 
a875 cd 62 93			call break_point_state  
a878				endm  
# End of macro CALLMONITOR
a878					endif 
a878				; replace below with ) exec using tok_ptr 
a878 22 de e7			ld (os_tok_ptr), hl 
a87b c3 e9 9c			jp exec1 
a87e			 
a87e .. 00			.closepar:   db ")",0 
a880			 
a880				       NEXTW 
a880 c3 58 9c			jp macro_next 
a883				endm 
# End of macro NEXTW
a883			.COMC: 
a883				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a883 6f				db WORD_SYS_CORE+91             
a884 8c a8			dw .SCRATCH            
a886 02				db 1 + 1 
a887 .. 00			db ")",0              
a889				endm 
# End of macro CWHEAD
a889			; | ) ( -- )  End of comment |  DONE  
a889				       NEXTW 
a889 c3 58 9c			jp macro_next 
a88c				endm 
# End of macro NEXTW
a88c			 
a88c			.SCRATCH: 
a88c				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a88c 6f				db WORD_SYS_CORE+91             
a88d c7 a8			dw .INC            
a88f 08				db 7 + 1 
a890 .. 00			db "SCRATCH",0              
a898				endm 
# End of macro CWHEAD
a898			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a898			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a898			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a898			; | |  
a898			; | | e.g.    : score $00 scratch ; 
a898			; | |  
a898			; | | $00 score ! 
a898			; | | $01 score +! 
a898			; | |  
a898			; | | e.g.   : varword $0a scratch ;  
a898			; | | 
a898			; | | $8000 varword ! 
a898					if DEBUG_FORTH_WORDS_KEY 
a898						DMARK "SCR" 
a898 f5				push af  
a899 3a ad a8			ld a, (.dmark)  
a89c 32 b7 ee			ld (debug_mark),a  
a89f 3a ae a8			ld a, (.dmark+1)  
a8a2 32 b8 ee			ld (debug_mark+1),a  
a8a5 3a af a8			ld a, (.dmark+2)  
a8a8 32 b9 ee			ld (debug_mark+2),a  
a8ab 18 03			jr .pastdmark  
a8ad ..			.dmark: db "SCR"  
a8b0 f1			.pastdmark: pop af  
a8b1			endm  
# End of macro DMARK
a8b1						CALLMONITOR 
a8b1 cd 62 93			call break_point_state  
a8b4				endm  
# End of macro CALLMONITOR
a8b4					endif 
a8b4			 
a8b4					FORTH_DSP_VALUEHL 
a8b4 cd e6 9a			call macro_dsp_valuehl 
a8b7				endm 
# End of macro FORTH_DSP_VALUEHL
a8b7				 
a8b7					FORTH_DSP_POP 
a8b7 cd 9e 9b			call macro_forth_dsp_pop 
a8ba				endm 
# End of macro FORTH_DSP_POP
a8ba			 
a8ba 7d					ld a, l 
a8bb 21 02 ea				ld hl, os_var_array 
a8be cd b9 8a				call addatohl 
a8c1			 
a8c1 cd ef 98				call forth_push_numhl 
a8c4			 
a8c4				       NEXTW 
a8c4 c3 58 9c			jp macro_next 
a8c7				endm 
# End of macro NEXTW
a8c7			 
a8c7			.INC: 
a8c7				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a8c7 6f				db WORD_SYS_CORE+91             
a8c8 1b a9			dw .DEC            
a8ca 03				db 2 + 1 
a8cb .. 00			db "+!",0              
a8ce				endm 
# End of macro CWHEAD
a8ce			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a8ce					if DEBUG_FORTH_WORDS_KEY 
a8ce						DMARK "+s_" 
a8ce f5				push af  
a8cf 3a e3 a8			ld a, (.dmark)  
a8d2 32 b7 ee			ld (debug_mark),a  
a8d5 3a e4 a8			ld a, (.dmark+1)  
a8d8 32 b8 ee			ld (debug_mark+1),a  
a8db 3a e5 a8			ld a, (.dmark+2)  
a8de 32 b9 ee			ld (debug_mark+2),a  
a8e1 18 03			jr .pastdmark  
a8e3 ..			.dmark: db "+s_"  
a8e6 f1			.pastdmark: pop af  
a8e7			endm  
# End of macro DMARK
a8e7						CALLMONITOR 
a8e7 cd 62 93			call break_point_state  
a8ea				endm  
# End of macro CALLMONITOR
a8ea					endif 
a8ea			 
a8ea					FORTH_DSP_VALUEHL 
a8ea cd e6 9a			call macro_dsp_valuehl 
a8ed				endm 
# End of macro FORTH_DSP_VALUEHL
a8ed			 
a8ed e5					push hl   ; save address 
a8ee			 
a8ee					FORTH_DSP_POP 
a8ee cd 9e 9b			call macro_forth_dsp_pop 
a8f1				endm 
# End of macro FORTH_DSP_POP
a8f1			 
a8f1					FORTH_DSP_VALUEHL 
a8f1 cd e6 9a			call macro_dsp_valuehl 
a8f4				endm 
# End of macro FORTH_DSP_VALUEHL
a8f4			 
a8f4					FORTH_DSP_POP 
a8f4 cd 9e 9b			call macro_forth_dsp_pop 
a8f7				endm 
# End of macro FORTH_DSP_POP
a8f7			 
a8f7					; hl contains value to add to byte at a 
a8f7				 
a8f7 eb					ex de, hl 
a8f8			 
a8f8 e1					pop hl 
a8f9			 
a8f9					if DEBUG_FORTH_WORDS 
a8f9						DMARK "INC" 
a8f9 f5				push af  
a8fa 3a 0e a9			ld a, (.dmark)  
a8fd 32 b7 ee			ld (debug_mark),a  
a900 3a 0f a9			ld a, (.dmark+1)  
a903 32 b8 ee			ld (debug_mark+1),a  
a906 3a 10 a9			ld a, (.dmark+2)  
a909 32 b9 ee			ld (debug_mark+2),a  
a90c 18 03			jr .pastdmark  
a90e ..			.dmark: db "INC"  
a911 f1			.pastdmark: pop af  
a912			endm  
# End of macro DMARK
a912						CALLMONITOR 
a912 cd 62 93			call break_point_state  
a915				endm  
# End of macro CALLMONITOR
a915					endif 
a915			 
a915 7e					ld a,(hl) 
a916 83					add e 
a917 77					ld (hl),a 
a918			 
a918			 
a918			 
a918				       NEXTW 
a918 c3 58 9c			jp macro_next 
a91b				endm 
# End of macro NEXTW
a91b			 
a91b			.DEC: 
a91b				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a91b 6f				db WORD_SYS_CORE+91             
a91c 6c a9			dw .INC2            
a91e 03				db 2 + 1 
a91f .. 00			db "-!",0              
a922				endm 
# End of macro CWHEAD
a922			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a922					if DEBUG_FORTH_WORDS_KEY 
a922						DMARK "-s_" 
a922 f5				push af  
a923 3a 37 a9			ld a, (.dmark)  
a926 32 b7 ee			ld (debug_mark),a  
a929 3a 38 a9			ld a, (.dmark+1)  
a92c 32 b8 ee			ld (debug_mark+1),a  
a92f 3a 39 a9			ld a, (.dmark+2)  
a932 32 b9 ee			ld (debug_mark+2),a  
a935 18 03			jr .pastdmark  
a937 ..			.dmark: db "-s_"  
a93a f1			.pastdmark: pop af  
a93b			endm  
# End of macro DMARK
a93b						CALLMONITOR 
a93b cd 62 93			call break_point_state  
a93e				endm  
# End of macro CALLMONITOR
a93e					endif 
a93e			 
a93e					FORTH_DSP_VALUEHL 
a93e cd e6 9a			call macro_dsp_valuehl 
a941				endm 
# End of macro FORTH_DSP_VALUEHL
a941			 
a941 e5					push hl   ; save address 
a942			 
a942					FORTH_DSP_POP 
a942 cd 9e 9b			call macro_forth_dsp_pop 
a945				endm 
# End of macro FORTH_DSP_POP
a945			 
a945					FORTH_DSP_VALUEHL 
a945 cd e6 9a			call macro_dsp_valuehl 
a948				endm 
# End of macro FORTH_DSP_VALUEHL
a948			 
a948					; hl contains value to add to byte at a 
a948				 
a948 eb					ex de, hl 
a949			 
a949 e1					pop hl 
a94a			 
a94a					if DEBUG_FORTH_WORDS 
a94a						DMARK "DEC" 
a94a f5				push af  
a94b 3a 5f a9			ld a, (.dmark)  
a94e 32 b7 ee			ld (debug_mark),a  
a951 3a 60 a9			ld a, (.dmark+1)  
a954 32 b8 ee			ld (debug_mark+1),a  
a957 3a 61 a9			ld a, (.dmark+2)  
a95a 32 b9 ee			ld (debug_mark+2),a  
a95d 18 03			jr .pastdmark  
a95f ..			.dmark: db "DEC"  
a962 f1			.pastdmark: pop af  
a963			endm  
# End of macro DMARK
a963						CALLMONITOR 
a963 cd 62 93			call break_point_state  
a966				endm  
# End of macro CALLMONITOR
a966					endif 
a966			 
a966 7e					ld a,(hl) 
a967 93					sub e 
a968 77					ld (hl),a 
a969			 
a969			 
a969			 
a969				       NEXTW 
a969 c3 58 9c			jp macro_next 
a96c				endm 
# End of macro NEXTW
a96c			 
a96c			.INC2: 
a96c				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a96c 6f				db WORD_SYS_CORE+91             
a96d 16 aa			dw .DEC2            
a96f 04				db 3 + 1 
a970 .. 00			db "+2!",0              
a974				endm 
# End of macro CWHEAD
a974			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a974			 
a974					if DEBUG_FORTH_WORDS_KEY 
a974						DMARK "+2s" 
a974 f5				push af  
a975 3a 89 a9			ld a, (.dmark)  
a978 32 b7 ee			ld (debug_mark),a  
a97b 3a 8a a9			ld a, (.dmark+1)  
a97e 32 b8 ee			ld (debug_mark+1),a  
a981 3a 8b a9			ld a, (.dmark+2)  
a984 32 b9 ee			ld (debug_mark+2),a  
a987 18 03			jr .pastdmark  
a989 ..			.dmark: db "+2s"  
a98c f1			.pastdmark: pop af  
a98d			endm  
# End of macro DMARK
a98d						CALLMONITOR 
a98d cd 62 93			call break_point_state  
a990				endm  
# End of macro CALLMONITOR
a990					endif 
a990			 
a990					; Address 
a990			 
a990					FORTH_DSP_VALUEHL 
a990 cd e6 9a			call macro_dsp_valuehl 
a993				endm 
# End of macro FORTH_DSP_VALUEHL
a993			 
a993 e5					push hl    ; save address 
a994			 
a994					; load content into de 
a994			 
a994 5e					ld e,(hl) 
a995 23					inc hl 
a996 56					ld d, (hl) 
a997			 
a997					if DEBUG_FORTH_WORDS 
a997						DMARK "+2a" 
a997 f5				push af  
a998 3a ac a9			ld a, (.dmark)  
a99b 32 b7 ee			ld (debug_mark),a  
a99e 3a ad a9			ld a, (.dmark+1)  
a9a1 32 b8 ee			ld (debug_mark+1),a  
a9a4 3a ae a9			ld a, (.dmark+2)  
a9a7 32 b9 ee			ld (debug_mark+2),a  
a9aa 18 03			jr .pastdmark  
a9ac ..			.dmark: db "+2a"  
a9af f1			.pastdmark: pop af  
a9b0			endm  
# End of macro DMARK
a9b0						CALLMONITOR 
a9b0 cd 62 93			call break_point_state  
a9b3				endm  
# End of macro CALLMONITOR
a9b3					endif 
a9b3			 
a9b3					FORTH_DSP_POP 
a9b3 cd 9e 9b			call macro_forth_dsp_pop 
a9b6				endm 
# End of macro FORTH_DSP_POP
a9b6			 
a9b6					; Get value to add 
a9b6			 
a9b6					FORTH_DSP_VALUE 
a9b6 cd cf 9a			call macro_forth_dsp_value 
a9b9				endm 
# End of macro FORTH_DSP_VALUE
a9b9			 
a9b9					if DEBUG_FORTH_WORDS 
a9b9						DMARK "+2v" 
a9b9 f5				push af  
a9ba 3a ce a9			ld a, (.dmark)  
a9bd 32 b7 ee			ld (debug_mark),a  
a9c0 3a cf a9			ld a, (.dmark+1)  
a9c3 32 b8 ee			ld (debug_mark+1),a  
a9c6 3a d0 a9			ld a, (.dmark+2)  
a9c9 32 b9 ee			ld (debug_mark+2),a  
a9cc 18 03			jr .pastdmark  
a9ce ..			.dmark: db "+2v"  
a9d1 f1			.pastdmark: pop af  
a9d2			endm  
# End of macro DMARK
a9d2						CALLMONITOR 
a9d2 cd 62 93			call break_point_state  
a9d5				endm  
# End of macro CALLMONITOR
a9d5					endif 
a9d5			 
a9d5 19					add hl, de 
a9d6			 
a9d6					if DEBUG_FORTH_WORDS 
a9d6						DMARK "+2+" 
a9d6 f5				push af  
a9d7 3a eb a9			ld a, (.dmark)  
a9da 32 b7 ee			ld (debug_mark),a  
a9dd 3a ec a9			ld a, (.dmark+1)  
a9e0 32 b8 ee			ld (debug_mark+1),a  
a9e3 3a ed a9			ld a, (.dmark+2)  
a9e6 32 b9 ee			ld (debug_mark+2),a  
a9e9 18 03			jr .pastdmark  
a9eb ..			.dmark: db "+2+"  
a9ee f1			.pastdmark: pop af  
a9ef			endm  
# End of macro DMARK
a9ef						CALLMONITOR 
a9ef cd 62 93			call break_point_state  
a9f2				endm  
# End of macro CALLMONITOR
a9f2					endif 
a9f2			 
a9f2					; move result to de 
a9f2			 
a9f2 eb					ex de, hl 
a9f3			 
a9f3					; Address 
a9f3			 
a9f3 e1					pop hl 
a9f4			 
a9f4					; save it back 
a9f4			 
a9f4 73					ld (hl), e 
a9f5 23					inc hl 
a9f6 72					ld (hl), d 
a9f7			 
a9f7					if DEBUG_FORTH_WORDS 
a9f7						DMARK "+2e" 
a9f7 f5				push af  
a9f8 3a 0c aa			ld a, (.dmark)  
a9fb 32 b7 ee			ld (debug_mark),a  
a9fe 3a 0d aa			ld a, (.dmark+1)  
aa01 32 b8 ee			ld (debug_mark+1),a  
aa04 3a 0e aa			ld a, (.dmark+2)  
aa07 32 b9 ee			ld (debug_mark+2),a  
aa0a 18 03			jr .pastdmark  
aa0c ..			.dmark: db "+2e"  
aa0f f1			.pastdmark: pop af  
aa10			endm  
# End of macro DMARK
aa10						CALLMONITOR 
aa10 cd 62 93			call break_point_state  
aa13				endm  
# End of macro CALLMONITOR
aa13					endif 
aa13			 
aa13			 
aa13			 
aa13			 
aa13			 
aa13				       NEXTW 
aa13 c3 58 9c			jp macro_next 
aa16				endm 
# End of macro NEXTW
aa16			 
aa16			.DEC2: 
aa16				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aa16 6f				db WORD_SYS_CORE+91             
aa17 c2 aa			dw .GET2            
aa19 04				db 3 + 1 
aa1a .. 00			db "-2!",0              
aa1e				endm 
# End of macro CWHEAD
aa1e			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
aa1e			 
aa1e			 
aa1e					if DEBUG_FORTH_WORDS_KEY 
aa1e						DMARK "-2s" 
aa1e f5				push af  
aa1f 3a 33 aa			ld a, (.dmark)  
aa22 32 b7 ee			ld (debug_mark),a  
aa25 3a 34 aa			ld a, (.dmark+1)  
aa28 32 b8 ee			ld (debug_mark+1),a  
aa2b 3a 35 aa			ld a, (.dmark+2)  
aa2e 32 b9 ee			ld (debug_mark+2),a  
aa31 18 03			jr .pastdmark  
aa33 ..			.dmark: db "-2s"  
aa36 f1			.pastdmark: pop af  
aa37			endm  
# End of macro DMARK
aa37						CALLMONITOR 
aa37 cd 62 93			call break_point_state  
aa3a				endm  
# End of macro CALLMONITOR
aa3a					endif 
aa3a			 
aa3a					; Address 
aa3a			 
aa3a					FORTH_DSP_VALUEHL 
aa3a cd e6 9a			call macro_dsp_valuehl 
aa3d				endm 
# End of macro FORTH_DSP_VALUEHL
aa3d			 
aa3d e5					push hl    ; save address 
aa3e			 
aa3e					; load content into de 
aa3e			 
aa3e 5e					ld e,(hl) 
aa3f 23					inc hl 
aa40 56					ld d, (hl) 
aa41			 
aa41					if DEBUG_FORTH_WORDS 
aa41						DMARK "-2a" 
aa41 f5				push af  
aa42 3a 56 aa			ld a, (.dmark)  
aa45 32 b7 ee			ld (debug_mark),a  
aa48 3a 57 aa			ld a, (.dmark+1)  
aa4b 32 b8 ee			ld (debug_mark+1),a  
aa4e 3a 58 aa			ld a, (.dmark+2)  
aa51 32 b9 ee			ld (debug_mark+2),a  
aa54 18 03			jr .pastdmark  
aa56 ..			.dmark: db "-2a"  
aa59 f1			.pastdmark: pop af  
aa5a			endm  
# End of macro DMARK
aa5a						CALLMONITOR 
aa5a cd 62 93			call break_point_state  
aa5d				endm  
# End of macro CALLMONITOR
aa5d					endif 
aa5d			 
aa5d					FORTH_DSP_POP 
aa5d cd 9e 9b			call macro_forth_dsp_pop 
aa60				endm 
# End of macro FORTH_DSP_POP
aa60			 
aa60					; Get value to remove 
aa60			 
aa60					FORTH_DSP_VALUE 
aa60 cd cf 9a			call macro_forth_dsp_value 
aa63				endm 
# End of macro FORTH_DSP_VALUE
aa63			 
aa63					if DEBUG_FORTH_WORDS 
aa63						DMARK "-2v" 
aa63 f5				push af  
aa64 3a 78 aa			ld a, (.dmark)  
aa67 32 b7 ee			ld (debug_mark),a  
aa6a 3a 79 aa			ld a, (.dmark+1)  
aa6d 32 b8 ee			ld (debug_mark+1),a  
aa70 3a 7a aa			ld a, (.dmark+2)  
aa73 32 b9 ee			ld (debug_mark+2),a  
aa76 18 03			jr .pastdmark  
aa78 ..			.dmark: db "-2v"  
aa7b f1			.pastdmark: pop af  
aa7c			endm  
# End of macro DMARK
aa7c						CALLMONITOR 
aa7c cd 62 93			call break_point_state  
aa7f				endm  
# End of macro CALLMONITOR
aa7f					endif 
aa7f			 
aa7f eb					ex de, hl 
aa80 ed 52				sbc hl, de 
aa82			 
aa82					if DEBUG_FORTH_WORDS 
aa82						DMARK "-2d" 
aa82 f5				push af  
aa83 3a 97 aa			ld a, (.dmark)  
aa86 32 b7 ee			ld (debug_mark),a  
aa89 3a 98 aa			ld a, (.dmark+1)  
aa8c 32 b8 ee			ld (debug_mark+1),a  
aa8f 3a 99 aa			ld a, (.dmark+2)  
aa92 32 b9 ee			ld (debug_mark+2),a  
aa95 18 03			jr .pastdmark  
aa97 ..			.dmark: db "-2d"  
aa9a f1			.pastdmark: pop af  
aa9b			endm  
# End of macro DMARK
aa9b						CALLMONITOR 
aa9b cd 62 93			call break_point_state  
aa9e				endm  
# End of macro CALLMONITOR
aa9e					endif 
aa9e			 
aa9e					; move result to de 
aa9e			 
aa9e eb					ex de, hl 
aa9f			 
aa9f					; Address 
aa9f			 
aa9f e1					pop hl 
aaa0			 
aaa0					; save it back 
aaa0			 
aaa0 73					ld (hl), e 
aaa1 23					inc hl 
aaa2 72					ld (hl), d 
aaa3			 
aaa3					if DEBUG_FORTH_WORDS 
aaa3						DMARK "-2e" 
aaa3 f5				push af  
aaa4 3a b8 aa			ld a, (.dmark)  
aaa7 32 b7 ee			ld (debug_mark),a  
aaaa 3a b9 aa			ld a, (.dmark+1)  
aaad 32 b8 ee			ld (debug_mark+1),a  
aab0 3a ba aa			ld a, (.dmark+2)  
aab3 32 b9 ee			ld (debug_mark+2),a  
aab6 18 03			jr .pastdmark  
aab8 ..			.dmark: db "-2e"  
aabb f1			.pastdmark: pop af  
aabc			endm  
# End of macro DMARK
aabc						CALLMONITOR 
aabc cd 62 93			call break_point_state  
aabf				endm  
# End of macro CALLMONITOR
aabf					endif 
aabf			 
aabf			 
aabf			 
aabf			 
aabf			 
aabf				       NEXTW 
aabf c3 58 9c			jp macro_next 
aac2				endm 
# End of macro NEXTW
aac2			.GET2: 
aac2				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aac2 6f				db WORD_SYS_CORE+91             
aac3 f2 aa			dw .BANG2            
aac5 03				db 2 + 1 
aac6 .. 00			db "2@",0              
aac9				endm 
# End of macro CWHEAD
aac9			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
aac9					if DEBUG_FORTH_WORDS_KEY 
aac9						DMARK "2A_" 
aac9 f5				push af  
aaca 3a de aa			ld a, (.dmark)  
aacd 32 b7 ee			ld (debug_mark),a  
aad0 3a df aa			ld a, (.dmark+1)  
aad3 32 b8 ee			ld (debug_mark+1),a  
aad6 3a e0 aa			ld a, (.dmark+2)  
aad9 32 b9 ee			ld (debug_mark+2),a  
aadc 18 03			jr .pastdmark  
aade ..			.dmark: db "2A_"  
aae1 f1			.pastdmark: pop af  
aae2			endm  
# End of macro DMARK
aae2						CALLMONITOR 
aae2 cd 62 93			call break_point_state  
aae5				endm  
# End of macro CALLMONITOR
aae5					endif 
aae5			 
aae5					FORTH_DSP_VALUEHL 
aae5 cd e6 9a			call macro_dsp_valuehl 
aae8				endm 
# End of macro FORTH_DSP_VALUEHL
aae8			 
aae8 5e					ld e, (hl) 
aae9 23					inc hl 
aaea 56					ld d, (hl) 
aaeb			 
aaeb eb					ex de, hl 
aaec			 
aaec cd ef 98				call forth_push_numhl 
aaef			 
aaef				       NEXTW 
aaef c3 58 9c			jp macro_next 
aaf2				endm 
# End of macro NEXTW
aaf2			.BANG2: 
aaf2				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
aaf2 6f				db WORD_SYS_CORE+91             
aaf3 2a ab			dw .CONFIG            
aaf5 03				db 2 + 1 
aaf6 .. 00			db "2!",0              
aaf9				endm 
# End of macro CWHEAD
aaf9			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
aaf9					if DEBUG_FORTH_WORDS_KEY 
aaf9						DMARK "2S_" 
aaf9 f5				push af  
aafa 3a 0e ab			ld a, (.dmark)  
aafd 32 b7 ee			ld (debug_mark),a  
ab00 3a 0f ab			ld a, (.dmark+1)  
ab03 32 b8 ee			ld (debug_mark+1),a  
ab06 3a 10 ab			ld a, (.dmark+2)  
ab09 32 b9 ee			ld (debug_mark+2),a  
ab0c 18 03			jr .pastdmark  
ab0e ..			.dmark: db "2S_"  
ab11 f1			.pastdmark: pop af  
ab12			endm  
# End of macro DMARK
ab12						CALLMONITOR 
ab12 cd 62 93			call break_point_state  
ab15				endm  
# End of macro CALLMONITOR
ab15					endif 
ab15			 
ab15					FORTH_DSP_VALUEHL 
ab15 cd e6 9a			call macro_dsp_valuehl 
ab18				endm 
# End of macro FORTH_DSP_VALUEHL
ab18			 
ab18 e5					push hl   ; save address 
ab19			 
ab19			 
ab19					FORTH_DSP_POP 
ab19 cd 9e 9b			call macro_forth_dsp_pop 
ab1c				endm 
# End of macro FORTH_DSP_POP
ab1c			 
ab1c					 
ab1c					FORTH_DSP_VALUEHL 
ab1c cd e6 9a			call macro_dsp_valuehl 
ab1f				endm 
# End of macro FORTH_DSP_VALUEHL
ab1f			 
ab1f					FORTH_DSP_POP 
ab1f cd 9e 9b			call macro_forth_dsp_pop 
ab22				endm 
# End of macro FORTH_DSP_POP
ab22			 
ab22 eb					ex de, hl    ; value now in de 
ab23			 
ab23 e1					pop hl 
ab24			 
ab24 73					ld (hl), e 
ab25			 
ab25 23					inc hl 
ab26			 
ab26 72					ld (hl), d 
ab27			 
ab27			 
ab27				       NEXTW 
ab27 c3 58 9c			jp macro_next 
ab2a				endm 
# End of macro NEXTW
ab2a			.CONFIG: 
ab2a				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ab2a 6f				db WORD_SYS_CORE+91             
ab2b 3b ab			dw .ENDCORE            
ab2d 07				db 6 + 1 
ab2e .. 00			db "CONFIG",0              
ab35				endm 
# End of macro CWHEAD
ab35			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ab35			 
ab35 cd 19 91				call config 
ab38					NEXTW 
ab38 c3 58 9c			jp macro_next 
ab3b				endm 
# End of macro NEXTW
ab3b			.ENDCORE: 
ab3b			 
ab3b			; eof 
ab3b			 
ab3b			 
# End of file forth_words_core.asm
ab3b			include "forth_words_flow.asm" 
ab3b			 
ab3b			; | ## Program Flow Words 
ab3b			 
ab3b			.IF: 
ab3b				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ab3b 1e				db WORD_SYS_CORE+10             
ab3c 30 ac			dw .THEN            
ab3e 03				db 2 + 1 
ab3f .. 00			db "IF",0              
ab42				endm 
# End of macro CWHEAD
ab42			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ab42			; 
ab42					if DEBUG_FORTH_WORDS_KEY 
ab42						DMARK "IF." 
ab42 f5				push af  
ab43 3a 57 ab			ld a, (.dmark)  
ab46 32 b7 ee			ld (debug_mark),a  
ab49 3a 58 ab			ld a, (.dmark+1)  
ab4c 32 b8 ee			ld (debug_mark+1),a  
ab4f 3a 59 ab			ld a, (.dmark+2)  
ab52 32 b9 ee			ld (debug_mark+2),a  
ab55 18 03			jr .pastdmark  
ab57 ..			.dmark: db "IF."  
ab5a f1			.pastdmark: pop af  
ab5b			endm  
# End of macro DMARK
ab5b						CALLMONITOR 
ab5b cd 62 93			call break_point_state  
ab5e				endm  
# End of macro CALLMONITOR
ab5e					endif 
ab5e			; eval TOS 
ab5e			 
ab5e				FORTH_DSP_VALUEHL 
ab5e cd e6 9a			call macro_dsp_valuehl 
ab61				endm 
# End of macro FORTH_DSP_VALUEHL
ab61			 
ab61			;	push hl 
ab61				FORTH_DSP_POP 
ab61 cd 9e 9b			call macro_forth_dsp_pop 
ab64				endm 
# End of macro FORTH_DSP_POP
ab64			;	pop hl 
ab64			 
ab64					if DEBUG_FORTH_WORDS 
ab64						DMARK "IF1" 
ab64 f5				push af  
ab65 3a 79 ab			ld a, (.dmark)  
ab68 32 b7 ee			ld (debug_mark),a  
ab6b 3a 7a ab			ld a, (.dmark+1)  
ab6e 32 b8 ee			ld (debug_mark+1),a  
ab71 3a 7b ab			ld a, (.dmark+2)  
ab74 32 b9 ee			ld (debug_mark+2),a  
ab77 18 03			jr .pastdmark  
ab79 ..			.dmark: db "IF1"  
ab7c f1			.pastdmark: pop af  
ab7d			endm  
# End of macro DMARK
ab7d						CALLMONITOR 
ab7d cd 62 93			call break_point_state  
ab80				endm  
# End of macro CALLMONITOR
ab80					endif 
ab80 b7				or a        ; clear carry flag 
ab81 11 00 00			ld de, 0 
ab84 eb				ex de,hl 
ab85 ed 52			sbc hl, de 
ab87 c2 11 ac			jp nz, .iftrue 
ab8a			 
ab8a					if DEBUG_FORTH_WORDS 
ab8a						DMARK "IF2" 
ab8a f5				push af  
ab8b 3a 9f ab			ld a, (.dmark)  
ab8e 32 b7 ee			ld (debug_mark),a  
ab91 3a a0 ab			ld a, (.dmark+1)  
ab94 32 b8 ee			ld (debug_mark+1),a  
ab97 3a a1 ab			ld a, (.dmark+2)  
ab9a 32 b9 ee			ld (debug_mark+2),a  
ab9d 18 03			jr .pastdmark  
ab9f ..			.dmark: db "IF2"  
aba2 f1			.pastdmark: pop af  
aba3			endm  
# End of macro DMARK
aba3						CALLMONITOR 
aba3 cd 62 93			call break_point_state  
aba6				endm  
# End of macro CALLMONITOR
aba6					endif 
aba6			 
aba6			; if not true then skip to THEN 
aba6			 
aba6				; TODO get tok_ptr 
aba6				; TODO consume toks until we get to THEN 
aba6			 
aba6 2a de e7			ld hl, (os_tok_ptr) 
aba9					if DEBUG_FORTH_WORDS 
aba9						DMARK "IF3" 
aba9 f5				push af  
abaa 3a be ab			ld a, (.dmark)  
abad 32 b7 ee			ld (debug_mark),a  
abb0 3a bf ab			ld a, (.dmark+1)  
abb3 32 b8 ee			ld (debug_mark+1),a  
abb6 3a c0 ab			ld a, (.dmark+2)  
abb9 32 b9 ee			ld (debug_mark+2),a  
abbc 18 03			jr .pastdmark  
abbe ..			.dmark: db "IF3"  
abc1 f1			.pastdmark: pop af  
abc2			endm  
# End of macro DMARK
abc2						CALLMONITOR 
abc2 cd 62 93			call break_point_state  
abc5				endm  
# End of macro CALLMONITOR
abc5						 
abc5					endif 
abc5 11 0c ac			ld de, .ifthen 
abc8					if DEBUG_FORTH_WORDS 
abc8						DMARK "IF4" 
abc8 f5				push af  
abc9 3a dd ab			ld a, (.dmark)  
abcc 32 b7 ee			ld (debug_mark),a  
abcf 3a de ab			ld a, (.dmark+1)  
abd2 32 b8 ee			ld (debug_mark+1),a  
abd5 3a df ab			ld a, (.dmark+2)  
abd8 32 b9 ee			ld (debug_mark+2),a  
abdb 18 03			jr .pastdmark  
abdd ..			.dmark: db "IF4"  
abe0 f1			.pastdmark: pop af  
abe1			endm  
# End of macro DMARK
abe1						CALLMONITOR 
abe1 cd 62 93			call break_point_state  
abe4				endm  
# End of macro CALLMONITOR
abe4					endif 
abe4 cd 73 9d			call findnexttok  
abe7			 
abe7					if DEBUG_FORTH_WORDS 
abe7						DMARK "IF5" 
abe7 f5				push af  
abe8 3a fc ab			ld a, (.dmark)  
abeb 32 b7 ee			ld (debug_mark),a  
abee 3a fd ab			ld a, (.dmark+1)  
abf1 32 b8 ee			ld (debug_mark+1),a  
abf4 3a fe ab			ld a, (.dmark+2)  
abf7 32 b9 ee			ld (debug_mark+2),a  
abfa 18 03			jr .pastdmark  
abfc ..			.dmark: db "IF5"  
abff f1			.pastdmark: pop af  
ac00			endm  
# End of macro DMARK
ac00						CALLMONITOR 
ac00 cd 62 93			call break_point_state  
ac03				endm  
# End of macro CALLMONITOR
ac03					endif 
ac03				; TODO replace below with ; exec using tok_ptr 
ac03 22 de e7			ld (os_tok_ptr), hl 
ac06 c3 e9 9c			jp exec1 
ac09				NEXTW 
ac09 c3 58 9c			jp macro_next 
ac0c				endm 
# End of macro NEXTW
ac0c			 
ac0c .. 00		.ifthen:  db "THEN",0 
ac11			 
ac11			.iftrue:		 
ac11				; Exec next words normally 
ac11			 
ac11				; if true then exec following IF as normal 
ac11					if DEBUG_FORTH_WORDS 
ac11						DMARK "IFT" 
ac11 f5				push af  
ac12 3a 26 ac			ld a, (.dmark)  
ac15 32 b7 ee			ld (debug_mark),a  
ac18 3a 27 ac			ld a, (.dmark+1)  
ac1b 32 b8 ee			ld (debug_mark+1),a  
ac1e 3a 28 ac			ld a, (.dmark+2)  
ac21 32 b9 ee			ld (debug_mark+2),a  
ac24 18 03			jr .pastdmark  
ac26 ..			.dmark: db "IFT"  
ac29 f1			.pastdmark: pop af  
ac2a			endm  
# End of macro DMARK
ac2a						CALLMONITOR 
ac2a cd 62 93			call break_point_state  
ac2d				endm  
# End of macro CALLMONITOR
ac2d					endif 
ac2d			 
ac2d					NEXTW 
ac2d c3 58 9c			jp macro_next 
ac30				endm 
# End of macro NEXTW
ac30			.THEN: 
ac30				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ac30 1f				db WORD_SYS_CORE+11             
ac31 58 ac			dw .ELSE            
ac33 05				db 4 + 1 
ac34 .. 00			db "THEN",0              
ac39				endm 
# End of macro CWHEAD
ac39			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ac39					if DEBUG_FORTH_WORDS_KEY 
ac39						DMARK "THN" 
ac39 f5				push af  
ac3a 3a 4e ac			ld a, (.dmark)  
ac3d 32 b7 ee			ld (debug_mark),a  
ac40 3a 4f ac			ld a, (.dmark+1)  
ac43 32 b8 ee			ld (debug_mark+1),a  
ac46 3a 50 ac			ld a, (.dmark+2)  
ac49 32 b9 ee			ld (debug_mark+2),a  
ac4c 18 03			jr .pastdmark  
ac4e ..			.dmark: db "THN"  
ac51 f1			.pastdmark: pop af  
ac52			endm  
# End of macro DMARK
ac52						CALLMONITOR 
ac52 cd 62 93			call break_point_state  
ac55				endm  
# End of macro CALLMONITOR
ac55					endif 
ac55					NEXTW 
ac55 c3 58 9c			jp macro_next 
ac58				endm 
# End of macro NEXTW
ac58			.ELSE: 
ac58				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ac58 20				db WORD_SYS_CORE+12             
ac59 80 ac			dw .DO            
ac5b 03				db 2 + 1 
ac5c .. 00			db "ELSE",0              
ac61				endm 
# End of macro CWHEAD
ac61			; | ELSE ( -- ) Not supported - does nothing | TODO 
ac61			 
ac61					if DEBUG_FORTH_WORDS_KEY 
ac61						DMARK "ELS" 
ac61 f5				push af  
ac62 3a 76 ac			ld a, (.dmark)  
ac65 32 b7 ee			ld (debug_mark),a  
ac68 3a 77 ac			ld a, (.dmark+1)  
ac6b 32 b8 ee			ld (debug_mark+1),a  
ac6e 3a 78 ac			ld a, (.dmark+2)  
ac71 32 b9 ee			ld (debug_mark+2),a  
ac74 18 03			jr .pastdmark  
ac76 ..			.dmark: db "ELS"  
ac79 f1			.pastdmark: pop af  
ac7a			endm  
# End of macro DMARK
ac7a						CALLMONITOR 
ac7a cd 62 93			call break_point_state  
ac7d				endm  
# End of macro CALLMONITOR
ac7d					endif 
ac7d			 
ac7d			 
ac7d					NEXTW 
ac7d c3 58 9c			jp macro_next 
ac80				endm 
# End of macro NEXTW
ac80			.DO: 
ac80				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ac80 21				db WORD_SYS_CORE+13             
ac81 a7 ad			dw .LOOP            
ac83 03				db 2 + 1 
ac84 .. 00			db "DO",0              
ac87				endm 
# End of macro CWHEAD
ac87			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ac87			 
ac87					if DEBUG_FORTH_WORDS_KEY 
ac87						DMARK "DO." 
ac87 f5				push af  
ac88 3a 9c ac			ld a, (.dmark)  
ac8b 32 b7 ee			ld (debug_mark),a  
ac8e 3a 9d ac			ld a, (.dmark+1)  
ac91 32 b8 ee			ld (debug_mark+1),a  
ac94 3a 9e ac			ld a, (.dmark+2)  
ac97 32 b9 ee			ld (debug_mark+2),a  
ac9a 18 03			jr .pastdmark  
ac9c ..			.dmark: db "DO."  
ac9f f1			.pastdmark: pop af  
aca0			endm  
# End of macro DMARK
aca0						CALLMONITOR 
aca0 cd 62 93			call break_point_state  
aca3				endm  
# End of macro CALLMONITOR
aca3					endif 
aca3			;  push pc to rsp stack past the DO 
aca3			 
aca3 2a de e7				ld hl, (os_tok_ptr) 
aca6 23					inc hl   ; D 
aca7 23					inc hl  ; O 
aca8 23					inc hl   ; null 
aca9					if DEBUG_FORTH_WORDS 
aca9						DMARK "DO2" 
aca9 f5				push af  
acaa 3a be ac			ld a, (.dmark)  
acad 32 b7 ee			ld (debug_mark),a  
acb0 3a bf ac			ld a, (.dmark+1)  
acb3 32 b8 ee			ld (debug_mark+1),a  
acb6 3a c0 ac			ld a, (.dmark+2)  
acb9 32 b9 ee			ld (debug_mark+2),a  
acbc 18 03			jr .pastdmark  
acbe ..			.dmark: db "DO2"  
acc1 f1			.pastdmark: pop af  
acc2			endm  
# End of macro DMARK
acc2						CALLMONITOR 
acc2 cd 62 93			call break_point_state  
acc5				endm  
# End of macro CALLMONITOR
acc5					endif 
acc5					FORTH_RSP_NEXT 
acc5 cd 96 98			call macro_forth_rsp_next 
acc8				endm 
# End of macro FORTH_RSP_NEXT
acc8					if DEBUG_FORTH_WORDS 
acc8						DMARK "DO3" 
acc8 f5				push af  
acc9 3a dd ac			ld a, (.dmark)  
accc 32 b7 ee			ld (debug_mark),a  
accf 3a de ac			ld a, (.dmark+1)  
acd2 32 b8 ee			ld (debug_mark+1),a  
acd5 3a df ac			ld a, (.dmark+2)  
acd8 32 b9 ee			ld (debug_mark+2),a  
acdb 18 03			jr .pastdmark  
acdd ..			.dmark: db "DO3"  
ace0 f1			.pastdmark: pop af  
ace1			endm  
# End of macro DMARK
ace1						CALLMONITOR 
ace1 cd 62 93			call break_point_state  
ace4				endm  
# End of macro CALLMONITOR
ace4					endif 
ace4			 
ace4					;if DEBUG_FORTH_WORDS 
ace4				;		push hl 
ace4			;		endif  
ace4			 
ace4			; get counters from data stack 
ace4			 
ace4			 
ace4					FORTH_DSP_VALUEHL 
ace4 cd e6 9a			call macro_dsp_valuehl 
ace7				endm 
# End of macro FORTH_DSP_VALUEHL
ace7 e5					push hl		 ; hl now has starting counter which needs to be tos 
ace8			 
ace8					if DEBUG_FORTH_WORDS 
ace8						DMARK "DO4" 
ace8 f5				push af  
ace9 3a fd ac			ld a, (.dmark)  
acec 32 b7 ee			ld (debug_mark),a  
acef 3a fe ac			ld a, (.dmark+1)  
acf2 32 b8 ee			ld (debug_mark+1),a  
acf5 3a ff ac			ld a, (.dmark+2)  
acf8 32 b9 ee			ld (debug_mark+2),a  
acfb 18 03			jr .pastdmark  
acfd ..			.dmark: db "DO4"  
ad00 f1			.pastdmark: pop af  
ad01			endm  
# End of macro DMARK
ad01						CALLMONITOR 
ad01 cd 62 93			call break_point_state  
ad04				endm  
# End of macro CALLMONITOR
ad04					endif 
ad04					FORTH_DSP_POP 
ad04 cd 9e 9b			call macro_forth_dsp_pop 
ad07				endm 
# End of macro FORTH_DSP_POP
ad07			 
ad07					if DEBUG_FORTH_WORDS 
ad07						DMARK "DO5" 
ad07 f5				push af  
ad08 3a 1c ad			ld a, (.dmark)  
ad0b 32 b7 ee			ld (debug_mark),a  
ad0e 3a 1d ad			ld a, (.dmark+1)  
ad11 32 b8 ee			ld (debug_mark+1),a  
ad14 3a 1e ad			ld a, (.dmark+2)  
ad17 32 b9 ee			ld (debug_mark+2),a  
ad1a 18 03			jr .pastdmark  
ad1c ..			.dmark: db "DO5"  
ad1f f1			.pastdmark: pop af  
ad20			endm  
# End of macro DMARK
ad20						CALLMONITOR 
ad20 cd 62 93			call break_point_state  
ad23				endm  
# End of macro CALLMONITOR
ad23					endif 
ad23			 
ad23					FORTH_DSP_VALUEHL 
ad23 cd e6 9a			call macro_dsp_valuehl 
ad26				endm 
# End of macro FORTH_DSP_VALUEHL
ad26			;		push hl		 ; hl now has starting limit counter 
ad26			 
ad26					if DEBUG_FORTH_WORDS 
ad26						DMARK "DO6" 
ad26 f5				push af  
ad27 3a 3b ad			ld a, (.dmark)  
ad2a 32 b7 ee			ld (debug_mark),a  
ad2d 3a 3c ad			ld a, (.dmark+1)  
ad30 32 b8 ee			ld (debug_mark+1),a  
ad33 3a 3d ad			ld a, (.dmark+2)  
ad36 32 b9 ee			ld (debug_mark+2),a  
ad39 18 03			jr .pastdmark  
ad3b ..			.dmark: db "DO6"  
ad3e f1			.pastdmark: pop af  
ad3f			endm  
# End of macro DMARK
ad3f						CALLMONITOR 
ad3f cd 62 93			call break_point_state  
ad42				endm  
# End of macro CALLMONITOR
ad42					endif 
ad42					FORTH_DSP_POP 
ad42 cd 9e 9b			call macro_forth_dsp_pop 
ad45				endm 
# End of macro FORTH_DSP_POP
ad45			 
ad45			; put counters on the loop stack 
ad45			 
ad45			;		pop hl			 ; limit counter 
ad45 d1					pop de			; start counter 
ad46			 
ad46					; push limit counter 
ad46			 
ad46					if DEBUG_FORTH_WORDS 
ad46						DMARK "DO7" 
ad46 f5				push af  
ad47 3a 5b ad			ld a, (.dmark)  
ad4a 32 b7 ee			ld (debug_mark),a  
ad4d 3a 5c ad			ld a, (.dmark+1)  
ad50 32 b8 ee			ld (debug_mark+1),a  
ad53 3a 5d ad			ld a, (.dmark+2)  
ad56 32 b9 ee			ld (debug_mark+2),a  
ad59 18 03			jr .pastdmark  
ad5b ..			.dmark: db "DO7"  
ad5e f1			.pastdmark: pop af  
ad5f			endm  
# End of macro DMARK
ad5f						CALLMONITOR 
ad5f cd 62 93			call break_point_state  
ad62				endm  
# End of macro CALLMONITOR
ad62					endif 
ad62					FORTH_LOOP_NEXT 
ad62 cd 17 9b			call macro_forth_loop_next 
ad65				endm 
# End of macro FORTH_LOOP_NEXT
ad65			 
ad65					; push start counter 
ad65			 
ad65 eb					ex de, hl 
ad66					if DEBUG_FORTH_WORDS 
ad66						DMARK "DO7" 
ad66 f5				push af  
ad67 3a 7b ad			ld a, (.dmark)  
ad6a 32 b7 ee			ld (debug_mark),a  
ad6d 3a 7c ad			ld a, (.dmark+1)  
ad70 32 b8 ee			ld (debug_mark+1),a  
ad73 3a 7d ad			ld a, (.dmark+2)  
ad76 32 b9 ee			ld (debug_mark+2),a  
ad79 18 03			jr .pastdmark  
ad7b ..			.dmark: db "DO7"  
ad7e f1			.pastdmark: pop af  
ad7f			endm  
# End of macro DMARK
ad7f						CALLMONITOR 
ad7f cd 62 93			call break_point_state  
ad82				endm  
# End of macro CALLMONITOR
ad82					endif 
ad82					FORTH_LOOP_NEXT 
ad82 cd 17 9b			call macro_forth_loop_next 
ad85				endm 
# End of macro FORTH_LOOP_NEXT
ad85			 
ad85			 
ad85					; init first round of I counter 
ad85			 
ad85 22 02 e8				ld (os_current_i), hl 
ad88			 
ad88					if DEBUG_FORTH_WORDS 
ad88						DMARK "DO8" 
ad88 f5				push af  
ad89 3a 9d ad			ld a, (.dmark)  
ad8c 32 b7 ee			ld (debug_mark),a  
ad8f 3a 9e ad			ld a, (.dmark+1)  
ad92 32 b8 ee			ld (debug_mark+1),a  
ad95 3a 9f ad			ld a, (.dmark+2)  
ad98 32 b9 ee			ld (debug_mark+2),a  
ad9b 18 03			jr .pastdmark  
ad9d ..			.dmark: db "DO8"  
ada0 f1			.pastdmark: pop af  
ada1			endm  
# End of macro DMARK
ada1						CALLMONITOR 
ada1 cd 62 93			call break_point_state  
ada4				endm  
# End of macro CALLMONITOR
ada4					endif 
ada4			 
ada4					NEXTW 
ada4 c3 58 9c			jp macro_next 
ada7				endm 
# End of macro NEXTW
ada7			.LOOP: 
ada7				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ada7 22				db WORD_SYS_CORE+14             
ada8 bf ae			dw .I            
adaa 05				db 4 + 1 
adab .. 00			db "LOOP",0              
adb0				endm 
# End of macro CWHEAD
adb0			; | LOOP ( -- ) Increment and test loop counter  | DONE 
adb0			 
adb0				; pop tos as current loop count to hl 
adb0			 
adb0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
adb0			 
adb0				FORTH_LOOP_TOS 
adb0 cd 4a 9b			call macro_forth_loop_tos 
adb3				endm 
# End of macro FORTH_LOOP_TOS
adb3 e5				push hl 
adb4			 
adb4					if DEBUG_FORTH_WORDS_KEY 
adb4						DMARK "LOP" 
adb4 f5				push af  
adb5 3a c9 ad			ld a, (.dmark)  
adb8 32 b7 ee			ld (debug_mark),a  
adbb 3a ca ad			ld a, (.dmark+1)  
adbe 32 b8 ee			ld (debug_mark+1),a  
adc1 3a cb ad			ld a, (.dmark+2)  
adc4 32 b9 ee			ld (debug_mark+2),a  
adc7 18 03			jr .pastdmark  
adc9 ..			.dmark: db "LOP"  
adcc f1			.pastdmark: pop af  
adcd			endm  
# End of macro DMARK
adcd						CALLMONITOR 
adcd cd 62 93			call break_point_state  
add0				endm  
# End of macro CALLMONITOR
add0					endif 
add0				; next item on the stack is the limit. get it 
add0			 
add0			 
add0				FORTH_LOOP_POP 
add0 cd 54 9b			call macro_forth_loop_pop 
add3				endm 
# End of macro FORTH_LOOP_POP
add3			 
add3				FORTH_LOOP_TOS 
add3 cd 4a 9b			call macro_forth_loop_tos 
add6				endm 
# End of macro FORTH_LOOP_TOS
add6			 
add6 d1				pop de		 ; de = i, hl = limit 
add7			 
add7					if DEBUG_FORTH_WORDS 
add7						DMARK "LP1" 
add7 f5				push af  
add8 3a ec ad			ld a, (.dmark)  
addb 32 b7 ee			ld (debug_mark),a  
adde 3a ed ad			ld a, (.dmark+1)  
ade1 32 b8 ee			ld (debug_mark+1),a  
ade4 3a ee ad			ld a, (.dmark+2)  
ade7 32 b9 ee			ld (debug_mark+2),a  
adea 18 03			jr .pastdmark  
adec ..			.dmark: db "LP1"  
adef f1			.pastdmark: pop af  
adf0			endm  
# End of macro DMARK
adf0						CALLMONITOR 
adf0 cd 62 93			call break_point_state  
adf3				endm  
# End of macro CALLMONITOR
adf3					endif 
adf3			 
adf3				; go back to previous word 
adf3			 
adf3 d5				push de    ; save I for inc later 
adf4			 
adf4			 
adf4				; get limit 
adf4				;  is I at limit? 
adf4			 
adf4			 
adf4					if DEBUG_FORTH_WORDS 
adf4						DMARK "LP1" 
adf4 f5				push af  
adf5 3a 09 ae			ld a, (.dmark)  
adf8 32 b7 ee			ld (debug_mark),a  
adfb 3a 0a ae			ld a, (.dmark+1)  
adfe 32 b8 ee			ld (debug_mark+1),a  
ae01 3a 0b ae			ld a, (.dmark+2)  
ae04 32 b9 ee			ld (debug_mark+2),a  
ae07 18 03			jr .pastdmark  
ae09 ..			.dmark: db "LP1"  
ae0c f1			.pastdmark: pop af  
ae0d			endm  
# End of macro DMARK
ae0d						CALLMONITOR 
ae0d cd 62 93			call break_point_state  
ae10				endm  
# End of macro CALLMONITOR
ae10					endif 
ae10			 
ae10 ed 52			sbc hl, de 
ae12			 
ae12			 
ae12				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
ae12			 
ae12 20 26				jr nz, .loopnotdone 
ae14			 
ae14 e1				pop hl   ; get rid of saved I 
ae15				FORTH_LOOP_POP     ; get rid of limit 
ae15 cd 54 9b			call macro_forth_loop_pop 
ae18				endm 
# End of macro FORTH_LOOP_POP
ae18			 
ae18				FORTH_RSP_POP     ; get rid of DO ptr 
ae18 cd b7 98			call macro_forth_rsp_pop 
ae1b				endm 
# End of macro FORTH_RSP_POP
ae1b			 
ae1b			if DEBUG_FORTH_WORDS 
ae1b						DMARK "LP>" 
ae1b f5				push af  
ae1c 3a 30 ae			ld a, (.dmark)  
ae1f 32 b7 ee			ld (debug_mark),a  
ae22 3a 31 ae			ld a, (.dmark+1)  
ae25 32 b8 ee			ld (debug_mark+1),a  
ae28 3a 32 ae			ld a, (.dmark+2)  
ae2b 32 b9 ee			ld (debug_mark+2),a  
ae2e 18 03			jr .pastdmark  
ae30 ..			.dmark: db "LP>"  
ae33 f1			.pastdmark: pop af  
ae34			endm  
# End of macro DMARK
ae34				CALLMONITOR 
ae34 cd 62 93			call break_point_state  
ae37				endm  
# End of macro CALLMONITOR
ae37			endif 
ae37			 
ae37					NEXTW 
ae37 c3 58 9c			jp macro_next 
ae3a				endm 
# End of macro NEXTW
ae3a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ae3a			 
ae3a			.loopnotdone: 
ae3a			 
ae3a e1				pop hl    ; get I 
ae3b 23				inc hl 
ae3c			 
ae3c			   	; save new I 
ae3c			 
ae3c			 
ae3c					; set I counter 
ae3c			 
ae3c 22 02 e8				ld (os_current_i), hl 
ae3f			 
ae3f					if DEBUG_FORTH_WORDS 
ae3f						DMARK "LPN" 
ae3f f5				push af  
ae40 3a 54 ae			ld a, (.dmark)  
ae43 32 b7 ee			ld (debug_mark),a  
ae46 3a 55 ae			ld a, (.dmark+1)  
ae49 32 b8 ee			ld (debug_mark+1),a  
ae4c 3a 56 ae			ld a, (.dmark+2)  
ae4f 32 b9 ee			ld (debug_mark+2),a  
ae52 18 03			jr .pastdmark  
ae54 ..			.dmark: db "LPN"  
ae57 f1			.pastdmark: pop af  
ae58			endm  
# End of macro DMARK
ae58					CALLMONITOR 
ae58 cd 62 93			call break_point_state  
ae5b				endm  
# End of macro CALLMONITOR
ae5b					endif 
ae5b					 
ae5b				FORTH_LOOP_NEXT 
ae5b cd 17 9b			call macro_forth_loop_next 
ae5e				endm 
# End of macro FORTH_LOOP_NEXT
ae5e			 
ae5e			 
ae5e					if DEBUG_FORTH_WORDS 
ae5e eb						ex de,hl 
ae5f					endif 
ae5f			 
ae5f			;	; get DO ptr 
ae5f			; 
ae5f					if DEBUG_FORTH_WORDS 
ae5f						DMARK "LP7" 
ae5f f5				push af  
ae60 3a 74 ae			ld a, (.dmark)  
ae63 32 b7 ee			ld (debug_mark),a  
ae66 3a 75 ae			ld a, (.dmark+1)  
ae69 32 b8 ee			ld (debug_mark+1),a  
ae6c 3a 76 ae			ld a, (.dmark+2)  
ae6f 32 b9 ee			ld (debug_mark+2),a  
ae72 18 03			jr .pastdmark  
ae74 ..			.dmark: db "LP7"  
ae77 f1			.pastdmark: pop af  
ae78			endm  
# End of macro DMARK
ae78					CALLMONITOR 
ae78 cd 62 93			call break_point_state  
ae7b				endm  
# End of macro CALLMONITOR
ae7b					endif 
ae7b				FORTH_RSP_TOS 
ae7b cd ad 98			call macro_forth_rsp_tos 
ae7e				endm 
# End of macro FORTH_RSP_TOS
ae7e			 
ae7e					if DEBUG_FORTH_WORDS 
ae7e						DMARK "LP8" 
ae7e f5				push af  
ae7f 3a 93 ae			ld a, (.dmark)  
ae82 32 b7 ee			ld (debug_mark),a  
ae85 3a 94 ae			ld a, (.dmark+1)  
ae88 32 b8 ee			ld (debug_mark+1),a  
ae8b 3a 95 ae			ld a, (.dmark+2)  
ae8e 32 b9 ee			ld (debug_mark+2),a  
ae91 18 03			jr .pastdmark  
ae93 ..			.dmark: db "LP8"  
ae96 f1			.pastdmark: pop af  
ae97			endm  
# End of macro DMARK
ae97					CALLMONITOR 
ae97 cd 62 93			call break_point_state  
ae9a				endm  
# End of macro CALLMONITOR
ae9a					endif 
ae9a				;push hl 
ae9a			 
ae9a				; not going to DO any more 
ae9a				; get rid of the RSP pointer as DO will add it back in 
ae9a				;FORTH_RSP_POP 
ae9a				;pop hl 
ae9a			 
ae9a				;ld hl,(cli_ret_sp) 
ae9a				;ld e, (hl) 
ae9a				;inc hl 
ae9a				;ld d, (hl) 
ae9a				;ex de,hl 
ae9a 22 de e7			ld (os_tok_ptr), hl 
ae9d					if DEBUG_FORTH_WORDS 
ae9d						DMARK "LP<" 
ae9d f5				push af  
ae9e 3a b2 ae			ld a, (.dmark)  
aea1 32 b7 ee			ld (debug_mark),a  
aea4 3a b3 ae			ld a, (.dmark+1)  
aea7 32 b8 ee			ld (debug_mark+1),a  
aeaa 3a b4 ae			ld a, (.dmark+2)  
aead 32 b9 ee			ld (debug_mark+2),a  
aeb0 18 03			jr .pastdmark  
aeb2 ..			.dmark: db "LP<"  
aeb5 f1			.pastdmark: pop af  
aeb6			endm  
# End of macro DMARK
aeb6					CALLMONITOR 
aeb6 cd 62 93			call break_point_state  
aeb9				endm  
# End of macro CALLMONITOR
aeb9				endif 
aeb9 c3 e9 9c			jp exec1 
aebc			 
aebc					 
aebc			 
aebc			 
aebc					NEXTW 
aebc c3 58 9c			jp macro_next 
aebf				endm 
# End of macro NEXTW
aebf			.I:  
aebf			 
aebf				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
aebf 5e				db WORD_SYS_CORE+74             
aec0 ea ae			dw .DLOOP            
aec2 02				db 1 + 1 
aec3 .. 00			db "I",0              
aec5				endm 
# End of macro CWHEAD
aec5			; | I ( -- ) Current loop counter | DONE 
aec5					if DEBUG_FORTH_WORDS_KEY 
aec5						DMARK "I.." 
aec5 f5				push af  
aec6 3a da ae			ld a, (.dmark)  
aec9 32 b7 ee			ld (debug_mark),a  
aecc 3a db ae			ld a, (.dmark+1)  
aecf 32 b8 ee			ld (debug_mark+1),a  
aed2 3a dc ae			ld a, (.dmark+2)  
aed5 32 b9 ee			ld (debug_mark+2),a  
aed8 18 03			jr .pastdmark  
aeda ..			.dmark: db "I.."  
aedd f1			.pastdmark: pop af  
aede			endm  
# End of macro DMARK
aede						CALLMONITOR 
aede cd 62 93			call break_point_state  
aee1				endm  
# End of macro CALLMONITOR
aee1					endif 
aee1			 
aee1 2a 02 e8				ld hl,(os_current_i) 
aee4 cd ef 98				call forth_push_numhl 
aee7			 
aee7					NEXTW 
aee7 c3 58 9c			jp macro_next 
aeea				endm 
# End of macro NEXTW
aeea			.DLOOP: 
aeea				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
aeea 5f				db WORD_SYS_CORE+75             
aeeb cb af			dw .REPEAT            
aeed 06				db 5 + 1 
aeee .. 00			db "-LOOP",0              
aef4				endm 
# End of macro CWHEAD
aef4			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
aef4				; pop tos as current loop count to hl 
aef4					if DEBUG_FORTH_WORDS_KEY 
aef4						DMARK "-LP" 
aef4 f5				push af  
aef5 3a 09 af			ld a, (.dmark)  
aef8 32 b7 ee			ld (debug_mark),a  
aefb 3a 0a af			ld a, (.dmark+1)  
aefe 32 b8 ee			ld (debug_mark+1),a  
af01 3a 0b af			ld a, (.dmark+2)  
af04 32 b9 ee			ld (debug_mark+2),a  
af07 18 03			jr .pastdmark  
af09 ..			.dmark: db "-LP"  
af0c f1			.pastdmark: pop af  
af0d			endm  
# End of macro DMARK
af0d						CALLMONITOR 
af0d cd 62 93			call break_point_state  
af10				endm  
# End of macro CALLMONITOR
af10					endif 
af10			 
af10				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
af10			 
af10				FORTH_LOOP_TOS 
af10 cd 4a 9b			call macro_forth_loop_tos 
af13				endm 
# End of macro FORTH_LOOP_TOS
af13 e5				push hl 
af14			 
af14					if DEBUG_FORTH_WORDS 
af14						DMARK "-LP" 
af14 f5				push af  
af15 3a 29 af			ld a, (.dmark)  
af18 32 b7 ee			ld (debug_mark),a  
af1b 3a 2a af			ld a, (.dmark+1)  
af1e 32 b8 ee			ld (debug_mark+1),a  
af21 3a 2b af			ld a, (.dmark+2)  
af24 32 b9 ee			ld (debug_mark+2),a  
af27 18 03			jr .pastdmark  
af29 ..			.dmark: db "-LP"  
af2c f1			.pastdmark: pop af  
af2d			endm  
# End of macro DMARK
af2d						CALLMONITOR 
af2d cd 62 93			call break_point_state  
af30				endm  
# End of macro CALLMONITOR
af30					endif 
af30				; next item on the stack is the limit. get it 
af30			 
af30			 
af30				FORTH_LOOP_POP 
af30 cd 54 9b			call macro_forth_loop_pop 
af33				endm 
# End of macro FORTH_LOOP_POP
af33			 
af33				FORTH_LOOP_TOS 
af33 cd 4a 9b			call macro_forth_loop_tos 
af36				endm 
# End of macro FORTH_LOOP_TOS
af36			 
af36 d1				pop de		 ; de = i, hl = limit 
af37			 
af37					if DEBUG_FORTH_WORDS 
af37						DMARK "-L1" 
af37 f5				push af  
af38 3a 4c af			ld a, (.dmark)  
af3b 32 b7 ee			ld (debug_mark),a  
af3e 3a 4d af			ld a, (.dmark+1)  
af41 32 b8 ee			ld (debug_mark+1),a  
af44 3a 4e af			ld a, (.dmark+2)  
af47 32 b9 ee			ld (debug_mark+2),a  
af4a 18 03			jr .pastdmark  
af4c ..			.dmark: db "-L1"  
af4f f1			.pastdmark: pop af  
af50			endm  
# End of macro DMARK
af50						CALLMONITOR 
af50 cd 62 93			call break_point_state  
af53				endm  
# End of macro CALLMONITOR
af53					endif 
af53			 
af53				; go back to previous word 
af53			 
af53 d5				push de    ; save I for inc later 
af54			 
af54			 
af54				; get limit 
af54				;  is I at limit? 
af54			 
af54			 
af54					if DEBUG_FORTH_WORDS 
af54						DMARK "-L1" 
af54 f5				push af  
af55 3a 69 af			ld a, (.dmark)  
af58 32 b7 ee			ld (debug_mark),a  
af5b 3a 6a af			ld a, (.dmark+1)  
af5e 32 b8 ee			ld (debug_mark+1),a  
af61 3a 6b af			ld a, (.dmark+2)  
af64 32 b9 ee			ld (debug_mark+2),a  
af67 18 03			jr .pastdmark  
af69 ..			.dmark: db "-L1"  
af6c f1			.pastdmark: pop af  
af6d			endm  
# End of macro DMARK
af6d						CALLMONITOR 
af6d cd 62 93			call break_point_state  
af70				endm  
# End of macro CALLMONITOR
af70					endif 
af70			 
af70 ed 52			sbc hl, de 
af72			 
af72			 
af72				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
af72			 
af72 20 26				jr nz, .mloopnotdone 
af74			 
af74 e1				pop hl   ; get rid of saved I 
af75				FORTH_LOOP_POP     ; get rid of limit 
af75 cd 54 9b			call macro_forth_loop_pop 
af78				endm 
# End of macro FORTH_LOOP_POP
af78			 
af78				FORTH_RSP_POP     ; get rid of DO ptr 
af78 cd b7 98			call macro_forth_rsp_pop 
af7b				endm 
# End of macro FORTH_RSP_POP
af7b			 
af7b			if DEBUG_FORTH_WORDS 
af7b						DMARK "-L>" 
af7b f5				push af  
af7c 3a 90 af			ld a, (.dmark)  
af7f 32 b7 ee			ld (debug_mark),a  
af82 3a 91 af			ld a, (.dmark+1)  
af85 32 b8 ee			ld (debug_mark+1),a  
af88 3a 92 af			ld a, (.dmark+2)  
af8b 32 b9 ee			ld (debug_mark+2),a  
af8e 18 03			jr .pastdmark  
af90 ..			.dmark: db "-L>"  
af93 f1			.pastdmark: pop af  
af94			endm  
# End of macro DMARK
af94				CALLMONITOR 
af94 cd 62 93			call break_point_state  
af97				endm  
# End of macro CALLMONITOR
af97			endif 
af97			 
af97					NEXTW 
af97 c3 58 9c			jp macro_next 
af9a				endm 
# End of macro NEXTW
af9a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
af9a			 
af9a			.mloopnotdone: 
af9a			 
af9a e1				pop hl    ; get I 
af9b 2b				dec hl 
af9c			 
af9c			   	; save new I 
af9c			 
af9c			 
af9c					; set I counter 
af9c			 
af9c 22 02 e8				ld (os_current_i), hl 
af9f			 
af9f					 
af9f				FORTH_LOOP_NEXT 
af9f cd 17 9b			call macro_forth_loop_next 
afa2				endm 
# End of macro FORTH_LOOP_NEXT
afa2			 
afa2			 
afa2					if DEBUG_FORTH_WORDS 
afa2 eb						ex de,hl 
afa3					endif 
afa3			 
afa3			;	; get DO ptr 
afa3			; 
afa3				FORTH_RSP_TOS 
afa3 cd ad 98			call macro_forth_rsp_tos 
afa6				endm 
# End of macro FORTH_RSP_TOS
afa6			 
afa6				;push hl 
afa6			 
afa6				; not going to DO any more 
afa6				; get rid of the RSP pointer as DO will add it back in 
afa6				;FORTH_RSP_POP 
afa6				;pop hl 
afa6			 
afa6			 
afa6 22 de e7			ld (os_tok_ptr), hl 
afa9					if DEBUG_FORTH_WORDS 
afa9						DMARK "-L<" 
afa9 f5				push af  
afaa 3a be af			ld a, (.dmark)  
afad 32 b7 ee			ld (debug_mark),a  
afb0 3a bf af			ld a, (.dmark+1)  
afb3 32 b8 ee			ld (debug_mark+1),a  
afb6 3a c0 af			ld a, (.dmark+2)  
afb9 32 b9 ee			ld (debug_mark+2),a  
afbc 18 03			jr .pastdmark  
afbe ..			.dmark: db "-L<"  
afc1 f1			.pastdmark: pop af  
afc2			endm  
# End of macro DMARK
afc2					CALLMONITOR 
afc2 cd 62 93			call break_point_state  
afc5				endm  
# End of macro CALLMONITOR
afc5				endif 
afc5 c3 e9 9c			jp exec1 
afc8			 
afc8					 
afc8			 
afc8			 
afc8			 
afc8				NEXTW 
afc8 c3 58 9c			jp macro_next 
afcb				endm 
# End of macro NEXTW
afcb			 
afcb			 
afcb			 
afcb			 
afcb			.REPEAT: 
afcb				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
afcb 71				db WORD_SYS_CORE+93             
afcc 1e b0			dw .UNTIL            
afce 06				db 5 + 1 
afcf .. 00			db "REPEAT",0              
afd6				endm 
# End of macro CWHEAD
afd6			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
afd6			;  push pc to rsp stack past the REPEAT 
afd6					if DEBUG_FORTH_WORDS_KEY 
afd6						DMARK "REP" 
afd6 f5				push af  
afd7 3a eb af			ld a, (.dmark)  
afda 32 b7 ee			ld (debug_mark),a  
afdd 3a ec af			ld a, (.dmark+1)  
afe0 32 b8 ee			ld (debug_mark+1),a  
afe3 3a ed af			ld a, (.dmark+2)  
afe6 32 b9 ee			ld (debug_mark+2),a  
afe9 18 03			jr .pastdmark  
afeb ..			.dmark: db "REP"  
afee f1			.pastdmark: pop af  
afef			endm  
# End of macro DMARK
afef						CALLMONITOR 
afef cd 62 93			call break_point_state  
aff2				endm  
# End of macro CALLMONITOR
aff2					endif 
aff2			 
aff2 2a de e7				ld hl, (os_tok_ptr) 
aff5 23					inc hl   ; R 
aff6 23					inc hl  ; E 
aff7 23					inc hl   ; P 
aff8 23					inc hl   ; E 
aff9 23					inc hl   ; A 
affa 23					inc hl   ; T 
affb 23					inc hl   ; zero 
affc					FORTH_RSP_NEXT 
affc cd 96 98			call macro_forth_rsp_next 
afff				endm 
# End of macro FORTH_RSP_NEXT
afff			 
afff			 
afff					if DEBUG_FORTH_WORDS 
afff						DMARK "REP" 
afff f5				push af  
b000 3a 14 b0			ld a, (.dmark)  
b003 32 b7 ee			ld (debug_mark),a  
b006 3a 15 b0			ld a, (.dmark+1)  
b009 32 b8 ee			ld (debug_mark+1),a  
b00c 3a 16 b0			ld a, (.dmark+2)  
b00f 32 b9 ee			ld (debug_mark+2),a  
b012 18 03			jr .pastdmark  
b014 ..			.dmark: db "REP"  
b017 f1			.pastdmark: pop af  
b018			endm  
# End of macro DMARK
b018						;pop bc    ; TODO BUG ?????? what is this for???? 
b018						CALLMONITOR 
b018 cd 62 93			call break_point_state  
b01b				endm  
# End of macro CALLMONITOR
b01b					endif 
b01b			 
b01b					NEXTW 
b01b c3 58 9c			jp macro_next 
b01e				endm 
# End of macro NEXTW
b01e			;	       NEXTW 
b01e			 
b01e			.UNTIL: 
b01e				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b01e 72				db WORD_SYS_CORE+94             
b01f b5 b0			dw .ENDFLOW            
b021 06				db 5 + 1 
b022 .. 00			db "UNTIL",0              
b028				endm 
# End of macro CWHEAD
b028			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b028			 
b028				; pop tos as check 
b028			 
b028				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b028			 
b028				FORTH_DSP_VALUEHL 
b028 cd e6 9a			call macro_dsp_valuehl 
b02b				endm 
# End of macro FORTH_DSP_VALUEHL
b02b			 
b02b					if DEBUG_FORTH_WORDS_KEY 
b02b						DMARK "UNT" 
b02b f5				push af  
b02c 3a 40 b0			ld a, (.dmark)  
b02f 32 b7 ee			ld (debug_mark),a  
b032 3a 41 b0			ld a, (.dmark+1)  
b035 32 b8 ee			ld (debug_mark+1),a  
b038 3a 42 b0			ld a, (.dmark+2)  
b03b 32 b9 ee			ld (debug_mark+2),a  
b03e 18 03			jr .pastdmark  
b040 ..			.dmark: db "UNT"  
b043 f1			.pastdmark: pop af  
b044			endm  
# End of macro DMARK
b044						CALLMONITOR 
b044 cd 62 93			call break_point_state  
b047				endm  
# End of macro CALLMONITOR
b047					endif 
b047			 
b047			;	push hl 
b047				FORTH_DSP_POP 
b047 cd 9e 9b			call macro_forth_dsp_pop 
b04a				endm 
# End of macro FORTH_DSP_POP
b04a			 
b04a			;	pop hl 
b04a			 
b04a				; test if true 
b04a			 
b04a cd e2 8a			call ishlzero 
b04d			;	ld a,l 
b04d			;	add h 
b04d			; 
b04d			;	cp 0 
b04d			 
b04d 20 3e			jr nz, .untilnotdone 
b04f			 
b04f					if DEBUG_FORTH_WORDS 
b04f						DMARK "UNf" 
b04f f5				push af  
b050 3a 64 b0			ld a, (.dmark)  
b053 32 b7 ee			ld (debug_mark),a  
b056 3a 65 b0			ld a, (.dmark+1)  
b059 32 b8 ee			ld (debug_mark+1),a  
b05c 3a 66 b0			ld a, (.dmark+2)  
b05f 32 b9 ee			ld (debug_mark+2),a  
b062 18 03			jr .pastdmark  
b064 ..			.dmark: db "UNf"  
b067 f1			.pastdmark: pop af  
b068			endm  
# End of macro DMARK
b068						CALLMONITOR 
b068 cd 62 93			call break_point_state  
b06b				endm  
# End of macro CALLMONITOR
b06b					endif 
b06b			 
b06b			 
b06b			 
b06b				FORTH_RSP_POP     ; get rid of DO ptr 
b06b cd b7 98			call macro_forth_rsp_pop 
b06e				endm 
# End of macro FORTH_RSP_POP
b06e			 
b06e			if DEBUG_FORTH_WORDS 
b06e						DMARK "UN>" 
b06e f5				push af  
b06f 3a 83 b0			ld a, (.dmark)  
b072 32 b7 ee			ld (debug_mark),a  
b075 3a 84 b0			ld a, (.dmark+1)  
b078 32 b8 ee			ld (debug_mark+1),a  
b07b 3a 85 b0			ld a, (.dmark+2)  
b07e 32 b9 ee			ld (debug_mark+2),a  
b081 18 03			jr .pastdmark  
b083 ..			.dmark: db "UN>"  
b086 f1			.pastdmark: pop af  
b087			endm  
# End of macro DMARK
b087				CALLMONITOR 
b087 cd 62 93			call break_point_state  
b08a				endm  
# End of macro CALLMONITOR
b08a			endif 
b08a			 
b08a					NEXTW 
b08a c3 58 9c			jp macro_next 
b08d				endm 
# End of macro NEXTW
b08d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b08d			 
b08d			.untilnotdone: 
b08d			 
b08d			 
b08d			;	; get DO ptr 
b08d			; 
b08d				FORTH_RSP_TOS 
b08d cd ad 98			call macro_forth_rsp_tos 
b090				endm 
# End of macro FORTH_RSP_TOS
b090			 
b090				;push hl 
b090			 
b090				; not going to DO any more 
b090				; get rid of the RSP pointer as DO will add it back in 
b090				;FORTH_RSP_POP 
b090				;pop hl 
b090			 
b090			 
b090 22 de e7			ld (os_tok_ptr), hl 
b093					if DEBUG_FORTH_WORDS 
b093						DMARK "UN<" 
b093 f5				push af  
b094 3a a8 b0			ld a, (.dmark)  
b097 32 b7 ee			ld (debug_mark),a  
b09a 3a a9 b0			ld a, (.dmark+1)  
b09d 32 b8 ee			ld (debug_mark+1),a  
b0a0 3a aa b0			ld a, (.dmark+2)  
b0a3 32 b9 ee			ld (debug_mark+2),a  
b0a6 18 03			jr .pastdmark  
b0a8 ..			.dmark: db "UN<"  
b0ab f1			.pastdmark: pop af  
b0ac			endm  
# End of macro DMARK
b0ac					CALLMONITOR 
b0ac cd 62 93			call break_point_state  
b0af				endm  
# End of macro CALLMONITOR
b0af				endif 
b0af c3 e9 9c			jp exec1 
b0b2			 
b0b2					 
b0b2			 
b0b2			 
b0b2					NEXTW 
b0b2 c3 58 9c			jp macro_next 
b0b5				endm 
# End of macro NEXTW
b0b5			 
b0b5			 
b0b5			.ENDFLOW: 
b0b5			 
b0b5			; eof 
b0b5			 
# End of file forth_words_flow.asm
b0b5			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b0b5			include "forth_words_logic.asm" 
b0b5			 
b0b5			; | ## Logic Words 
b0b5			 
b0b5			.NOT: 
b0b5				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b0b5 2d				db WORD_SYS_CORE+25             
b0b6 fd b0			dw .IS            
b0b8 04				db 3 + 1 
b0b9 .. 00			db "NOT",0              
b0bd				endm 
# End of macro CWHEAD
b0bd			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b0bd					if DEBUG_FORTH_WORDS_KEY 
b0bd						DMARK "NOT" 
b0bd f5				push af  
b0be 3a d2 b0			ld a, (.dmark)  
b0c1 32 b7 ee			ld (debug_mark),a  
b0c4 3a d3 b0			ld a, (.dmark+1)  
b0c7 32 b8 ee			ld (debug_mark+1),a  
b0ca 3a d4 b0			ld a, (.dmark+2)  
b0cd 32 b9 ee			ld (debug_mark+2),a  
b0d0 18 03			jr .pastdmark  
b0d2 ..			.dmark: db "NOT"  
b0d5 f1			.pastdmark: pop af  
b0d6			endm  
# End of macro DMARK
b0d6						CALLMONITOR 
b0d6 cd 62 93			call break_point_state  
b0d9				endm  
# End of macro CALLMONITOR
b0d9					endif 
b0d9					FORTH_DSP 
b0d9 cd ac 9a			call macro_forth_dsp 
b0dc				endm 
# End of macro FORTH_DSP
b0dc 7e					ld a,(hl)	; get type of value on TOS 
b0dd fe 02				cp DS_TYPE_INUM  
b0df 28 03				jr z, .noti 
b0e1					NEXTW 
b0e1 c3 58 9c			jp macro_next 
b0e4				endm 
# End of macro NEXTW
b0e4			.noti:          FORTH_DSP_VALUEHL 
b0e4 cd e6 9a			call macro_dsp_valuehl 
b0e7				endm 
# End of macro FORTH_DSP_VALUEHL
b0e7			;		push hl 
b0e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0e7 cd 9e 9b			call macro_forth_dsp_pop 
b0ea				endm 
# End of macro FORTH_DSP_POP
b0ea			;		pop hl 
b0ea 3e 00				ld a,0 
b0ec bd					cp l 
b0ed 28 04				jr z, .not2t 
b0ef 2e 00				ld l, 0 
b0f1 18 02				jr .notip 
b0f3			 
b0f3 2e ff		.not2t:		ld l, 255 
b0f5			 
b0f5 26 00		.notip:		ld h, 0	 
b0f7			 
b0f7 cd ef 98				call forth_push_numhl 
b0fa					NEXTW 
b0fa c3 58 9c			jp macro_next 
b0fd				endm 
# End of macro NEXTW
b0fd			 
b0fd			.IS: 
b0fd				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b0fd 2d				db WORD_SYS_CORE+25             
b0fe 23 b1			dw .LZERO            
b100 03				db 2 + 1 
b101 .. 00			db "IS",0              
b104				endm 
# End of macro CWHEAD
b104			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b104					if DEBUG_FORTH_WORDS_KEY 
b104						DMARK "IS." 
b104 f5				push af  
b105 3a 19 b1			ld a, (.dmark)  
b108 32 b7 ee			ld (debug_mark),a  
b10b 3a 1a b1			ld a, (.dmark+1)  
b10e 32 b8 ee			ld (debug_mark+1),a  
b111 3a 1b b1			ld a, (.dmark+2)  
b114 32 b9 ee			ld (debug_mark+2),a  
b117 18 03			jr .pastdmark  
b119 ..			.dmark: db "IS."  
b11c f1			.pastdmark: pop af  
b11d			endm  
# End of macro DMARK
b11d						CALLMONITOR 
b11d cd 62 93			call break_point_state  
b120				endm  
# End of macro CALLMONITOR
b120					endif 
b120					NEXTW 
b120 c3 58 9c			jp macro_next 
b123				endm 
# End of macro NEXTW
b123			.LZERO: 
b123				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b123 2d				db WORD_SYS_CORE+25             
b124 2d b1			dw .TZERO            
b126 03				db 2 + 1 
b127 .. 00			db "0<",0              
b12a				endm 
# End of macro CWHEAD
b12a			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b12a					NEXTW 
b12a c3 58 9c			jp macro_next 
b12d				endm 
# End of macro NEXTW
b12d			.TZERO: 
b12d				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b12d 2e				db WORD_SYS_CORE+26             
b12e 74 b1			dw .LESS            
b130 03				db 2 + 1 
b131 .. 00			db "0=",0              
b134				endm 
# End of macro CWHEAD
b134			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b134				; TODO add floating point number detection 
b134					;v5 FORTH_DSP_VALUE 
b134					if DEBUG_FORTH_WORDS_KEY 
b134						DMARK "0=." 
b134 f5				push af  
b135 3a 49 b1			ld a, (.dmark)  
b138 32 b7 ee			ld (debug_mark),a  
b13b 3a 4a b1			ld a, (.dmark+1)  
b13e 32 b8 ee			ld (debug_mark+1),a  
b141 3a 4b b1			ld a, (.dmark+2)  
b144 32 b9 ee			ld (debug_mark+2),a  
b147 18 03			jr .pastdmark  
b149 ..			.dmark: db "0=."  
b14c f1			.pastdmark: pop af  
b14d			endm  
# End of macro DMARK
b14d						CALLMONITOR 
b14d cd 62 93			call break_point_state  
b150				endm  
# End of macro CALLMONITOR
b150					endif 
b150					FORTH_DSP 
b150 cd ac 9a			call macro_forth_dsp 
b153				endm 
# End of macro FORTH_DSP
b153 7e					ld a,(hl)	; get type of value on TOS 
b154 fe 02				cp DS_TYPE_INUM  
b156 28 00				jr z, .tz_inum 
b158			 
b158				if FORTH_ENABLE_FLOATMATH 
b158					jr .tz_done 
b158			 
b158				endif 
b158					 
b158			 
b158			.tz_inum: 
b158					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b158 cd e6 9a			call macro_dsp_valuehl 
b15b				endm 
# End of macro FORTH_DSP_VALUEHL
b15b			 
b15b			;		push hl 
b15b			 
b15b					; destroy value TOS 
b15b			 
b15b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b15b cd 9e 9b			call macro_forth_dsp_pop 
b15e				endm 
# End of macro FORTH_DSP_POP
b15e			 
b15e			;		pop hl 
b15e			 
b15e 3e 00				ld a,0 
b160			 
b160 bd					cp l 
b161 20 08				jr nz, .tz_notzero 
b163			 
b163 bc					cp h 
b164			 
b164 20 05				jr nz, .tz_notzero 
b166			 
b166			 
b166 21 01 00				ld hl, FORTH_TRUE 
b169 18 03				jr .tz_done 
b16b			 
b16b 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b16e			 
b16e					; push value back onto stack for another op etc 
b16e			 
b16e			.tz_done: 
b16e cd ef 98				call forth_push_numhl 
b171			 
b171					NEXTW 
b171 c3 58 9c			jp macro_next 
b174				endm 
# End of macro NEXTW
b174			.LESS: 
b174				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b174 2f				db WORD_SYS_CORE+27             
b175 dd b1			dw .GT            
b177 02				db 1 + 1 
b178 .. 00			db "<",0              
b17a				endm 
# End of macro CWHEAD
b17a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b17a				; TODO add floating point number detection 
b17a					if DEBUG_FORTH_WORDS_KEY 
b17a						DMARK "LES" 
b17a f5				push af  
b17b 3a 8f b1			ld a, (.dmark)  
b17e 32 b7 ee			ld (debug_mark),a  
b181 3a 90 b1			ld a, (.dmark+1)  
b184 32 b8 ee			ld (debug_mark+1),a  
b187 3a 91 b1			ld a, (.dmark+2)  
b18a 32 b9 ee			ld (debug_mark+2),a  
b18d 18 03			jr .pastdmark  
b18f ..			.dmark: db "LES"  
b192 f1			.pastdmark: pop af  
b193			endm  
# End of macro DMARK
b193						CALLMONITOR 
b193 cd 62 93			call break_point_state  
b196				endm  
# End of macro CALLMONITOR
b196					endif 
b196					FORTH_DSP 
b196 cd ac 9a			call macro_forth_dsp 
b199				endm 
# End of macro FORTH_DSP
b199					;v5 FORTH_DSP_VALUE 
b199 7e					ld a,(hl)	; get type of value on TOS 
b19a fe 02				cp DS_TYPE_INUM  
b19c 28 00				jr z, .less_inum 
b19e			 
b19e				if FORTH_ENABLE_FLOATMATH 
b19e					jr .less_done 
b19e			 
b19e				endif 
b19e					 
b19e			 
b19e			.less_inum: 
b19e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b19e cd e6 9a			call macro_dsp_valuehl 
b1a1				endm 
# End of macro FORTH_DSP_VALUEHL
b1a1			 
b1a1 e5					push hl  ; u2 
b1a2			 
b1a2					; destroy value TOS 
b1a2			 
b1a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1a2 cd 9e 9b			call macro_forth_dsp_pop 
b1a5				endm 
# End of macro FORTH_DSP_POP
b1a5			 
b1a5			 
b1a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1a5 cd e6 9a			call macro_dsp_valuehl 
b1a8				endm 
# End of macro FORTH_DSP_VALUEHL
b1a8			 
b1a8 e5					push hl    ; u1 
b1a9			 
b1a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1a9 cd 9e 9b			call macro_forth_dsp_pop 
b1ac				endm 
# End of macro FORTH_DSP_POP
b1ac			 
b1ac			 
b1ac b7			 or a      ;clear carry flag 
b1ad 01 00 00		 ld bc, FORTH_FALSE 
b1b0 e1			  pop hl    ; u1 
b1b1 d1			  pop de    ; u2 
b1b2 ed 52		  sbc hl,de 
b1b4 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b1b6			 
b1b6 01 01 00		 ld bc, FORTH_TRUE 
b1b9			.lscont:  
b1b9 c5					push bc 
b1ba e1					pop hl 
b1bb			 
b1bb					if DEBUG_FORTH_WORDS 
b1bb						DMARK "LT1" 
b1bb f5				push af  
b1bc 3a d0 b1			ld a, (.dmark)  
b1bf 32 b7 ee			ld (debug_mark),a  
b1c2 3a d1 b1			ld a, (.dmark+1)  
b1c5 32 b8 ee			ld (debug_mark+1),a  
b1c8 3a d2 b1			ld a, (.dmark+2)  
b1cb 32 b9 ee			ld (debug_mark+2),a  
b1ce 18 03			jr .pastdmark  
b1d0 ..			.dmark: db "LT1"  
b1d3 f1			.pastdmark: pop af  
b1d4			endm  
# End of macro DMARK
b1d4						CALLMONITOR 
b1d4 cd 62 93			call break_point_state  
b1d7				endm  
# End of macro CALLMONITOR
b1d7					endif 
b1d7 cd ef 98				call forth_push_numhl 
b1da			 
b1da					NEXTW 
b1da c3 58 9c			jp macro_next 
b1dd				endm 
# End of macro NEXTW
b1dd			.GT: 
b1dd				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b1dd 30				db WORD_SYS_CORE+28             
b1de 46 b2			dw .EQUAL            
b1e0 02				db 1 + 1 
b1e1 .. 00			db ">",0              
b1e3				endm 
# End of macro CWHEAD
b1e3			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b1e3				; TODO add floating point number detection 
b1e3					if DEBUG_FORTH_WORDS_KEY 
b1e3						DMARK "GRT" 
b1e3 f5				push af  
b1e4 3a f8 b1			ld a, (.dmark)  
b1e7 32 b7 ee			ld (debug_mark),a  
b1ea 3a f9 b1			ld a, (.dmark+1)  
b1ed 32 b8 ee			ld (debug_mark+1),a  
b1f0 3a fa b1			ld a, (.dmark+2)  
b1f3 32 b9 ee			ld (debug_mark+2),a  
b1f6 18 03			jr .pastdmark  
b1f8 ..			.dmark: db "GRT"  
b1fb f1			.pastdmark: pop af  
b1fc			endm  
# End of macro DMARK
b1fc						CALLMONITOR 
b1fc cd 62 93			call break_point_state  
b1ff				endm  
# End of macro CALLMONITOR
b1ff					endif 
b1ff					FORTH_DSP 
b1ff cd ac 9a			call macro_forth_dsp 
b202				endm 
# End of macro FORTH_DSP
b202					;FORTH_DSP_VALUE 
b202 7e					ld a,(hl)	; get type of value on TOS 
b203 fe 02				cp DS_TYPE_INUM  
b205 28 00				jr z, .gt_inum 
b207			 
b207				if FORTH_ENABLE_FLOATMATH 
b207					jr .gt_done 
b207			 
b207				endif 
b207					 
b207			 
b207			.gt_inum: 
b207					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b207 cd e6 9a			call macro_dsp_valuehl 
b20a				endm 
# End of macro FORTH_DSP_VALUEHL
b20a			 
b20a e5					push hl  ; u2 
b20b			 
b20b					; destroy value TOS 
b20b			 
b20b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b20b cd 9e 9b			call macro_forth_dsp_pop 
b20e				endm 
# End of macro FORTH_DSP_POP
b20e			 
b20e			 
b20e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b20e cd e6 9a			call macro_dsp_valuehl 
b211				endm 
# End of macro FORTH_DSP_VALUEHL
b211			 
b211 e5					push hl    ; u1 
b212			 
b212					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b212 cd 9e 9b			call macro_forth_dsp_pop 
b215				endm 
# End of macro FORTH_DSP_POP
b215			 
b215			 
b215 b7			 or a      ;clear carry flag 
b216 01 00 00		 ld bc, FORTH_FALSE 
b219 e1			  pop hl    ; u1 
b21a d1			  pop de    ; u2 
b21b ed 52		  sbc hl,de 
b21d 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b21f			 
b21f 01 01 00		 ld bc, FORTH_TRUE 
b222			.gtcont:  
b222 c5					push bc 
b223 e1					pop hl 
b224			 
b224					if DEBUG_FORTH_WORDS 
b224						DMARK "GT1" 
b224 f5				push af  
b225 3a 39 b2			ld a, (.dmark)  
b228 32 b7 ee			ld (debug_mark),a  
b22b 3a 3a b2			ld a, (.dmark+1)  
b22e 32 b8 ee			ld (debug_mark+1),a  
b231 3a 3b b2			ld a, (.dmark+2)  
b234 32 b9 ee			ld (debug_mark+2),a  
b237 18 03			jr .pastdmark  
b239 ..			.dmark: db "GT1"  
b23c f1			.pastdmark: pop af  
b23d			endm  
# End of macro DMARK
b23d						CALLMONITOR 
b23d cd 62 93			call break_point_state  
b240				endm  
# End of macro CALLMONITOR
b240					endif 
b240 cd ef 98				call forth_push_numhl 
b243			 
b243					NEXTW 
b243 c3 58 9c			jp macro_next 
b246				endm 
# End of macro NEXTW
b246			.EQUAL: 
b246				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b246 31				db WORD_SYS_CORE+29             
b247 b1 b2			dw .ENDLOGIC            
b249 02				db 1 + 1 
b24a .. 00			db "=",0              
b24c				endm 
# End of macro CWHEAD
b24c			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b24c				; TODO add floating point number detection 
b24c					if DEBUG_FORTH_WORDS_KEY 
b24c						DMARK "EQ." 
b24c f5				push af  
b24d 3a 61 b2			ld a, (.dmark)  
b250 32 b7 ee			ld (debug_mark),a  
b253 3a 62 b2			ld a, (.dmark+1)  
b256 32 b8 ee			ld (debug_mark+1),a  
b259 3a 63 b2			ld a, (.dmark+2)  
b25c 32 b9 ee			ld (debug_mark+2),a  
b25f 18 03			jr .pastdmark  
b261 ..			.dmark: db "EQ."  
b264 f1			.pastdmark: pop af  
b265			endm  
# End of macro DMARK
b265						CALLMONITOR 
b265 cd 62 93			call break_point_state  
b268				endm  
# End of macro CALLMONITOR
b268					endif 
b268					FORTH_DSP 
b268 cd ac 9a			call macro_forth_dsp 
b26b				endm 
# End of macro FORTH_DSP
b26b					;v5 FORTH_DSP_VALUE 
b26b 7e					ld a,(hl)	; get type of value on TOS 
b26c fe 02				cp DS_TYPE_INUM  
b26e 28 00				jr z, .eq_inum 
b270			 
b270				if FORTH_ENABLE_FLOATMATH 
b270					jr .eq_done 
b270			 
b270				endif 
b270					 
b270			 
b270			.eq_inum: 
b270					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b270 cd e6 9a			call macro_dsp_valuehl 
b273				endm 
# End of macro FORTH_DSP_VALUEHL
b273			 
b273 e5					push hl 
b274			 
b274					; destroy value TOS 
b274			 
b274					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b274 cd 9e 9b			call macro_forth_dsp_pop 
b277				endm 
# End of macro FORTH_DSP_POP
b277			 
b277			 
b277					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b277 cd e6 9a			call macro_dsp_valuehl 
b27a				endm 
# End of macro FORTH_DSP_VALUEHL
b27a			 
b27a					; one value on hl get other one back 
b27a			 
b27a e5					push hl 
b27b			 
b27b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b27b cd 9e 9b			call macro_forth_dsp_pop 
b27e				endm 
# End of macro FORTH_DSP_POP
b27e			 
b27e 0e 00				ld c, FORTH_FALSE 
b280			 
b280 e1					pop hl 
b281 d1					pop de 
b282			 
b282 7b					ld a, e 
b283 bd					cp l 
b284			 
b284 20 06				jr nz, .eq_done 
b286			 
b286 7a					ld a, d 
b287 bc					cp h 
b288			 
b288 20 02				jr nz, .eq_done 
b28a			 
b28a 0e 01				ld c, FORTH_TRUE 
b28c					 
b28c			 
b28c			 
b28c			.eq_done: 
b28c			 
b28c					; TODO push value back onto stack for another op etc 
b28c			 
b28c 26 00				ld h, 0 
b28e 69					ld l, c 
b28f					if DEBUG_FORTH_WORDS 
b28f						DMARK "EQ1" 
b28f f5				push af  
b290 3a a4 b2			ld a, (.dmark)  
b293 32 b7 ee			ld (debug_mark),a  
b296 3a a5 b2			ld a, (.dmark+1)  
b299 32 b8 ee			ld (debug_mark+1),a  
b29c 3a a6 b2			ld a, (.dmark+2)  
b29f 32 b9 ee			ld (debug_mark+2),a  
b2a2 18 03			jr .pastdmark  
b2a4 ..			.dmark: db "EQ1"  
b2a7 f1			.pastdmark: pop af  
b2a8			endm  
# End of macro DMARK
b2a8						CALLMONITOR 
b2a8 cd 62 93			call break_point_state  
b2ab				endm  
# End of macro CALLMONITOR
b2ab					endif 
b2ab cd ef 98				call forth_push_numhl 
b2ae			 
b2ae					NEXTW 
b2ae c3 58 9c			jp macro_next 
b2b1				endm 
# End of macro NEXTW
b2b1			 
b2b1			 
b2b1			.ENDLOGIC: 
b2b1			; eof 
b2b1			 
b2b1			 
# End of file forth_words_logic.asm
b2b1			include "forth_words_maths.asm" 
b2b1			 
b2b1			; | ## Maths Words 
b2b1			 
b2b1			.PLUS:	 
b2b1				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b2b1 15				db WORD_SYS_CORE+1             
b2b2 f3 b2			dw .NEG            
b2b4 02				db 1 + 1 
b2b5 .. 00			db "+",0              
b2b7				endm 
# End of macro CWHEAD
b2b7			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b2b7					if DEBUG_FORTH_WORDS_KEY 
b2b7						DMARK "PLU" 
b2b7 f5				push af  
b2b8 3a cc b2			ld a, (.dmark)  
b2bb 32 b7 ee			ld (debug_mark),a  
b2be 3a cd b2			ld a, (.dmark+1)  
b2c1 32 b8 ee			ld (debug_mark+1),a  
b2c4 3a ce b2			ld a, (.dmark+2)  
b2c7 32 b9 ee			ld (debug_mark+2),a  
b2ca 18 03			jr .pastdmark  
b2cc ..			.dmark: db "PLU"  
b2cf f1			.pastdmark: pop af  
b2d0			endm  
# End of macro DMARK
b2d0						CALLMONITOR 
b2d0 cd 62 93			call break_point_state  
b2d3				endm  
# End of macro CALLMONITOR
b2d3					endif 
b2d3					; add top two values and push back result 
b2d3			 
b2d3					;for v5 FORTH_DSP_VALUE 
b2d3					FORTH_DSP 
b2d3 cd ac 9a			call macro_forth_dsp 
b2d6				endm 
# End of macro FORTH_DSP
b2d6 7e					ld a,(hl)	; get type of value on TOS 
b2d7 fe 02				cp DS_TYPE_INUM  
b2d9 28 03				jr z, .dot_inum 
b2db			 
b2db					NEXTW 
b2db c3 58 9c			jp macro_next 
b2de				endm 
# End of macro NEXTW
b2de			 
b2de			; float maths 
b2de			 
b2de				if FORTH_ENABLE_FLOATMATH 
b2de						inc hl      ; now at start of numeric as string 
b2de			 
b2de					if DEBUG_FORTH_MATHS 
b2de						DMARK "ADD" 
b2de				CALLMONITOR 
b2de					endif 
b2de			 
b2de					;ld ix, hl 
b2de					call CON 
b2de			 
b2de			 
b2de					push hl 
b2de					 
b2de					 
b2de			 
b2de						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b2de			 
b2de					; get next number 
b2de			 
b2de						FORTH_DSP_VALUE 
b2de			 
b2de						inc hl      ; now at start of numeric as string 
b2de			 
b2de					;ld ix, hl 
b2de					call CON 
b2de			 
b2de					push hl 
b2de			 
b2de			 
b2de						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2de			 
b2de						; TODO do add 
b2de			 
b2de						call IADD 
b2de			 
b2de						; TODO get result back as ascii 
b2de			 
b2de						; TODO push result  
b2de			 
b2de			 
b2de			 
b2de						jr .dot_done 
b2de				endif 
b2de			 
b2de			.dot_inum: 
b2de			 
b2de			 
b2de					if DEBUG_FORTH_DOT 
b2de						DMARK "+IT" 
b2de				CALLMONITOR 
b2de					endif 
b2de			 
b2de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2de cd e6 9a			call macro_dsp_valuehl 
b2e1				endm 
# End of macro FORTH_DSP_VALUEHL
b2e1			 
b2e1				; TODO add floating point number detection 
b2e1			 
b2e1 e5					push hl 
b2e2			 
b2e2					; destroy value TOS 
b2e2			 
b2e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2e2 cd 9e 9b			call macro_forth_dsp_pop 
b2e5				endm 
# End of macro FORTH_DSP_POP
b2e5			 
b2e5			 
b2e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2e5 cd e6 9a			call macro_dsp_valuehl 
b2e8				endm 
# End of macro FORTH_DSP_VALUEHL
b2e8			 
b2e8					; one value on hl get other one back 
b2e8			 
b2e8 d1					pop de 
b2e9			 
b2e9					; do the add 
b2e9			 
b2e9 19					add hl,de 
b2ea			 
b2ea					; save it 
b2ea			 
b2ea			;		push hl	 
b2ea			 
b2ea					; 
b2ea			 
b2ea					; destroy value TOS 
b2ea			 
b2ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2ea cd 9e 9b			call macro_forth_dsp_pop 
b2ed				endm 
# End of macro FORTH_DSP_POP
b2ed			 
b2ed					; TODO push value back onto stack for another op etc 
b2ed			 
b2ed			;		pop hl 
b2ed			 
b2ed			.dot_done: 
b2ed cd ef 98				call forth_push_numhl 
b2f0			 
b2f0					NEXTW 
b2f0 c3 58 9c			jp macro_next 
b2f3				endm 
# End of macro NEXTW
b2f3			.NEG: 
b2f3			 
b2f3				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b2f3 17				db WORD_SYS_CORE+3             
b2f4 36 b3			dw .DIV            
b2f6 02				db 1 + 1 
b2f7 .. 00			db "-",0              
b2f9				endm 
# End of macro CWHEAD
b2f9			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b2f9					if DEBUG_FORTH_WORDS_KEY 
b2f9						DMARK "SUB" 
b2f9 f5				push af  
b2fa 3a 0e b3			ld a, (.dmark)  
b2fd 32 b7 ee			ld (debug_mark),a  
b300 3a 0f b3			ld a, (.dmark+1)  
b303 32 b8 ee			ld (debug_mark+1),a  
b306 3a 10 b3			ld a, (.dmark+2)  
b309 32 b9 ee			ld (debug_mark+2),a  
b30c 18 03			jr .pastdmark  
b30e ..			.dmark: db "SUB"  
b311 f1			.pastdmark: pop af  
b312			endm  
# End of macro DMARK
b312						CALLMONITOR 
b312 cd 62 93			call break_point_state  
b315				endm  
# End of macro CALLMONITOR
b315					endif 
b315			 
b315			 
b315				; TODO add floating point number detection 
b315					; v5 FORTH_DSP_VALUE 
b315					FORTH_DSP 
b315 cd ac 9a			call macro_forth_dsp 
b318				endm 
# End of macro FORTH_DSP
b318 7e					ld a,(hl)	; get type of value on TOS 
b319 fe 02				cp DS_TYPE_INUM  
b31b 28 03				jr z, .neg_inum 
b31d			 
b31d					NEXTW 
b31d c3 58 9c			jp macro_next 
b320				endm 
# End of macro NEXTW
b320			 
b320			; float maths 
b320			 
b320				if FORTH_ENABLE_FLOATMATH 
b320					jr .neg_done 
b320			 
b320				endif 
b320					 
b320			 
b320			.neg_inum: 
b320					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b320 cd e6 9a			call macro_dsp_valuehl 
b323				endm 
# End of macro FORTH_DSP_VALUEHL
b323			 
b323 e5					push hl 
b324			 
b324					; destroy value TOS 
b324			 
b324					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b324 cd 9e 9b			call macro_forth_dsp_pop 
b327				endm 
# End of macro FORTH_DSP_POP
b327			 
b327			 
b327					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b327 cd e6 9a			call macro_dsp_valuehl 
b32a				endm 
# End of macro FORTH_DSP_VALUEHL
b32a			 
b32a					; one value on hl get other one back 
b32a			 
b32a d1					pop de 
b32b			 
b32b					; do the sub 
b32b			;		ex de, hl 
b32b			 
b32b ed 52				sbc hl,de 
b32d			 
b32d					; save it 
b32d			 
b32d			;		push hl	 
b32d			 
b32d					; 
b32d			 
b32d					; destroy value TOS 
b32d			 
b32d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b32d cd 9e 9b			call macro_forth_dsp_pop 
b330				endm 
# End of macro FORTH_DSP_POP
b330			 
b330					; TODO push value back onto stack for another op etc 
b330			 
b330			;		pop hl 
b330			 
b330 cd ef 98				call forth_push_numhl 
b333			.neg_done: 
b333			 
b333					NEXTW 
b333 c3 58 9c			jp macro_next 
b336				endm 
# End of macro NEXTW
b336			.DIV: 
b336				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b336 18				db WORD_SYS_CORE+4             
b337 83 b3			dw .MUL            
b339 02				db 1 + 1 
b33a .. 00			db "/",0              
b33c				endm 
# End of macro CWHEAD
b33c			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b33c					if DEBUG_FORTH_WORDS_KEY 
b33c						DMARK "DIV" 
b33c f5				push af  
b33d 3a 51 b3			ld a, (.dmark)  
b340 32 b7 ee			ld (debug_mark),a  
b343 3a 52 b3			ld a, (.dmark+1)  
b346 32 b8 ee			ld (debug_mark+1),a  
b349 3a 53 b3			ld a, (.dmark+2)  
b34c 32 b9 ee			ld (debug_mark+2),a  
b34f 18 03			jr .pastdmark  
b351 ..			.dmark: db "DIV"  
b354 f1			.pastdmark: pop af  
b355			endm  
# End of macro DMARK
b355						CALLMONITOR 
b355 cd 62 93			call break_point_state  
b358				endm  
# End of macro CALLMONITOR
b358					endif 
b358				; TODO add floating point number detection 
b358					; v5 FORTH_DSP_VALUE 
b358					FORTH_DSP 
b358 cd ac 9a			call macro_forth_dsp 
b35b				endm 
# End of macro FORTH_DSP
b35b 7e					ld a,(hl)	; get type of value on TOS 
b35c fe 02				cp DS_TYPE_INUM  
b35e 28 03				jr z, .div_inum 
b360			 
b360				if FORTH_ENABLE_FLOATMATH 
b360					jr .div_done 
b360			 
b360				endif 
b360					NEXTW 
b360 c3 58 9c			jp macro_next 
b363				endm 
# End of macro NEXTW
b363			.div_inum: 
b363			 
b363					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b363 cd e6 9a			call macro_dsp_valuehl 
b366				endm 
# End of macro FORTH_DSP_VALUEHL
b366			 
b366 e5					push hl    ; to go to bc 
b367			 
b367					; destroy value TOS 
b367			 
b367					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b367 cd 9e 9b			call macro_forth_dsp_pop 
b36a				endm 
# End of macro FORTH_DSP_POP
b36a			 
b36a			 
b36a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b36a cd e6 9a			call macro_dsp_valuehl 
b36d				endm 
# End of macro FORTH_DSP_VALUEHL
b36d			 
b36d					; hl to go to de 
b36d			 
b36d e5					push hl 
b36e			 
b36e c1					pop bc 
b36f d1					pop de		 
b370			 
b370			 
b370					if DEBUG_FORTH_MATHS 
b370						DMARK "DIV" 
b370				CALLMONITOR 
b370					endif 
b370					; one value on hl but move to a get other one back 
b370			 
b370			        
b370 cd 16 8a			call Div16 
b373			 
b373			;	push af	 
b373 e5				push hl 
b374 c5				push bc 
b375			 
b375					if DEBUG_FORTH_MATHS 
b375						DMARK "DI1" 
b375				CALLMONITOR 
b375					endif 
b375			 
b375					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b375 cd 9e 9b			call macro_forth_dsp_pop 
b378				endm 
# End of macro FORTH_DSP_POP
b378			 
b378			 
b378			 
b378 e1					pop hl    ; result 
b379			 
b379 cd ef 98				call forth_push_numhl 
b37c			 
b37c e1					pop hl    ; reminder 
b37d			;		ld h,0 
b37d			;		ld l,d 
b37d			 
b37d cd ef 98				call forth_push_numhl 
b380			.div_done: 
b380					NEXTW 
b380 c3 58 9c			jp macro_next 
b383				endm 
# End of macro NEXTW
b383			.MUL: 
b383				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b383 19				db WORD_SYS_CORE+5             
b384 c8 b3			dw .MIN            
b386 02				db 1 + 1 
b387 .. 00			db "*",0              
b389				endm 
# End of macro CWHEAD
b389			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b389				; TODO add floating point number detection 
b389					if DEBUG_FORTH_WORDS_KEY 
b389						DMARK "MUL" 
b389 f5				push af  
b38a 3a 9e b3			ld a, (.dmark)  
b38d 32 b7 ee			ld (debug_mark),a  
b390 3a 9f b3			ld a, (.dmark+1)  
b393 32 b8 ee			ld (debug_mark+1),a  
b396 3a a0 b3			ld a, (.dmark+2)  
b399 32 b9 ee			ld (debug_mark+2),a  
b39c 18 03			jr .pastdmark  
b39e ..			.dmark: db "MUL"  
b3a1 f1			.pastdmark: pop af  
b3a2			endm  
# End of macro DMARK
b3a2						CALLMONITOR 
b3a2 cd 62 93			call break_point_state  
b3a5				endm  
# End of macro CALLMONITOR
b3a5					endif 
b3a5					FORTH_DSP 
b3a5 cd ac 9a			call macro_forth_dsp 
b3a8				endm 
# End of macro FORTH_DSP
b3a8					; v5 FORTH_DSP_VALUE 
b3a8 7e					ld a,(hl)	; get type of value on TOS 
b3a9 fe 02				cp DS_TYPE_INUM  
b3ab 28 03				jr z, .mul_inum 
b3ad			 
b3ad				if FORTH_ENABLE_FLOATMATH 
b3ad					jr .mul_done 
b3ad			 
b3ad				endif 
b3ad			 
b3ad					NEXTW 
b3ad c3 58 9c			jp macro_next 
b3b0				endm 
# End of macro NEXTW
b3b0			.mul_inum:	 
b3b0			 
b3b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3b0 cd e6 9a			call macro_dsp_valuehl 
b3b3				endm 
# End of macro FORTH_DSP_VALUEHL
b3b3			 
b3b3 e5					push hl 
b3b4			 
b3b4					; destroy value TOS 
b3b4			 
b3b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3b4 cd 9e 9b			call macro_forth_dsp_pop 
b3b7				endm 
# End of macro FORTH_DSP_POP
b3b7			 
b3b7			 
b3b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3b7 cd e6 9a			call macro_dsp_valuehl 
b3ba				endm 
# End of macro FORTH_DSP_VALUEHL
b3ba			 
b3ba					; one value on hl but move to a get other one back 
b3ba			 
b3ba 7d					ld a, l 
b3bb			 
b3bb d1					pop de 
b3bc			 
b3bc					; do the mull 
b3bc			;		ex de, hl 
b3bc			 
b3bc cd 3c 8a				call Mult16 
b3bf					; save it 
b3bf			 
b3bf			;		push hl	 
b3bf			 
b3bf					; 
b3bf			 
b3bf					; destroy value TOS 
b3bf			 
b3bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3bf cd 9e 9b			call macro_forth_dsp_pop 
b3c2				endm 
# End of macro FORTH_DSP_POP
b3c2			 
b3c2					; TODO push value back onto stack for another op etc 
b3c2			 
b3c2			;		pop hl 
b3c2			 
b3c2 cd ef 98				call forth_push_numhl 
b3c5			 
b3c5			.mul_done: 
b3c5					NEXTW 
b3c5 c3 58 9c			jp macro_next 
b3c8				endm 
# End of macro NEXTW
b3c8			 
b3c8			 
b3c8			 
b3c8			 
b3c8			.MIN: 
b3c8				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b3c8 49				db WORD_SYS_CORE+53             
b3c9 49 b4			dw .MAX            
b3cb 04				db 3 + 1 
b3cc .. 00			db "MIN",0              
b3d0				endm 
# End of macro CWHEAD
b3d0			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b3d0					if DEBUG_FORTH_WORDS_KEY 
b3d0						DMARK "MIN" 
b3d0 f5				push af  
b3d1 3a e5 b3			ld a, (.dmark)  
b3d4 32 b7 ee			ld (debug_mark),a  
b3d7 3a e6 b3			ld a, (.dmark+1)  
b3da 32 b8 ee			ld (debug_mark+1),a  
b3dd 3a e7 b3			ld a, (.dmark+2)  
b3e0 32 b9 ee			ld (debug_mark+2),a  
b3e3 18 03			jr .pastdmark  
b3e5 ..			.dmark: db "MIN"  
b3e8 f1			.pastdmark: pop af  
b3e9			endm  
# End of macro DMARK
b3e9						CALLMONITOR 
b3e9 cd 62 93			call break_point_state  
b3ec				endm  
# End of macro CALLMONITOR
b3ec					endif 
b3ec					; get u2 
b3ec			 
b3ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3ec cd e6 9a			call macro_dsp_valuehl 
b3ef				endm 
# End of macro FORTH_DSP_VALUEHL
b3ef			 
b3ef e5					push hl   ; u2 
b3f0			 
b3f0					; destroy value TOS 
b3f0			 
b3f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3f0 cd 9e 9b			call macro_forth_dsp_pop 
b3f3				endm 
# End of macro FORTH_DSP_POP
b3f3			 
b3f3					; get u1 
b3f3			 
b3f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3f3 cd e6 9a			call macro_dsp_valuehl 
b3f6				endm 
# End of macro FORTH_DSP_VALUEHL
b3f6			 
b3f6 e5					push hl  ; u1 
b3f7			 
b3f7					; destroy value TOS 
b3f7			 
b3f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3f7 cd 9e 9b			call macro_forth_dsp_pop 
b3fa				endm 
# End of macro FORTH_DSP_POP
b3fa			 
b3fa b7			 or a      ;clear carry flag 
b3fb e1			  pop hl    ; u1 
b3fc d1			  pop de    ; u2 
b3fd e5				push hl   ; saved in case hl is lowest 
b3fe ed 52		  sbc hl,de 
b400 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b402			 
b402 e1				pop hl 
b403					if DEBUG_FORTH_WORDS 
b403						DMARK "MIN" 
b403 f5				push af  
b404 3a 18 b4			ld a, (.dmark)  
b407 32 b7 ee			ld (debug_mark),a  
b40a 3a 19 b4			ld a, (.dmark+1)  
b40d 32 b8 ee			ld (debug_mark+1),a  
b410 3a 1a b4			ld a, (.dmark+2)  
b413 32 b9 ee			ld (debug_mark+2),a  
b416 18 03			jr .pastdmark  
b418 ..			.dmark: db "MIN"  
b41b f1			.pastdmark: pop af  
b41c			endm  
# End of macro DMARK
b41c						CALLMONITOR 
b41c cd 62 93			call break_point_state  
b41f				endm  
# End of macro CALLMONITOR
b41f					endif 
b41f cd ef 98				call forth_push_numhl 
b422			 
b422				       NEXTW 
b422 c3 58 9c			jp macro_next 
b425				endm 
# End of macro NEXTW
b425			 
b425			.mincont:  
b425 c1				pop bc   ; tidy up 
b426 eb				ex de , hl  
b427					if DEBUG_FORTH_WORDS 
b427						DMARK "MI1" 
b427 f5				push af  
b428 3a 3c b4			ld a, (.dmark)  
b42b 32 b7 ee			ld (debug_mark),a  
b42e 3a 3d b4			ld a, (.dmark+1)  
b431 32 b8 ee			ld (debug_mark+1),a  
b434 3a 3e b4			ld a, (.dmark+2)  
b437 32 b9 ee			ld (debug_mark+2),a  
b43a 18 03			jr .pastdmark  
b43c ..			.dmark: db "MI1"  
b43f f1			.pastdmark: pop af  
b440			endm  
# End of macro DMARK
b440						CALLMONITOR 
b440 cd 62 93			call break_point_state  
b443				endm  
# End of macro CALLMONITOR
b443					endif 
b443 cd ef 98				call forth_push_numhl 
b446			 
b446				       NEXTW 
b446 c3 58 9c			jp macro_next 
b449				endm 
# End of macro NEXTW
b449			.MAX: 
b449				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b449 4a				db WORD_SYS_CORE+54             
b44a ca b4			dw .RND16            
b44c 04				db 3 + 1 
b44d .. 00			db "MAX",0              
b451				endm 
# End of macro CWHEAD
b451			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b451					if DEBUG_FORTH_WORDS_KEY 
b451						DMARK "MAX" 
b451 f5				push af  
b452 3a 66 b4			ld a, (.dmark)  
b455 32 b7 ee			ld (debug_mark),a  
b458 3a 67 b4			ld a, (.dmark+1)  
b45b 32 b8 ee			ld (debug_mark+1),a  
b45e 3a 68 b4			ld a, (.dmark+2)  
b461 32 b9 ee			ld (debug_mark+2),a  
b464 18 03			jr .pastdmark  
b466 ..			.dmark: db "MAX"  
b469 f1			.pastdmark: pop af  
b46a			endm  
# End of macro DMARK
b46a						CALLMONITOR 
b46a cd 62 93			call break_point_state  
b46d				endm  
# End of macro CALLMONITOR
b46d					endif 
b46d					; get u2 
b46d			 
b46d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b46d cd e6 9a			call macro_dsp_valuehl 
b470				endm 
# End of macro FORTH_DSP_VALUEHL
b470			 
b470 e5					push hl   ; u2 
b471			 
b471					; destroy value TOS 
b471			 
b471					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b471 cd 9e 9b			call macro_forth_dsp_pop 
b474				endm 
# End of macro FORTH_DSP_POP
b474			 
b474					; get u1 
b474			 
b474					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b474 cd e6 9a			call macro_dsp_valuehl 
b477				endm 
# End of macro FORTH_DSP_VALUEHL
b477			 
b477 e5					push hl  ; u1 
b478			 
b478					; destroy value TOS 
b478			 
b478					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b478 cd 9e 9b			call macro_forth_dsp_pop 
b47b				endm 
# End of macro FORTH_DSP_POP
b47b			 
b47b b7			 or a      ;clear carry flag 
b47c e1			  pop hl    ; u1 
b47d d1			  pop de    ; u2 
b47e e5				push hl   ; saved in case hl is lowest 
b47f ed 52		  sbc hl,de 
b481 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b483			 
b483 e1				pop hl 
b484					if DEBUG_FORTH_WORDS 
b484						DMARK "MAX" 
b484 f5				push af  
b485 3a 99 b4			ld a, (.dmark)  
b488 32 b7 ee			ld (debug_mark),a  
b48b 3a 9a b4			ld a, (.dmark+1)  
b48e 32 b8 ee			ld (debug_mark+1),a  
b491 3a 9b b4			ld a, (.dmark+2)  
b494 32 b9 ee			ld (debug_mark+2),a  
b497 18 03			jr .pastdmark  
b499 ..			.dmark: db "MAX"  
b49c f1			.pastdmark: pop af  
b49d			endm  
# End of macro DMARK
b49d						CALLMONITOR 
b49d cd 62 93			call break_point_state  
b4a0				endm  
# End of macro CALLMONITOR
b4a0					endif 
b4a0 cd ef 98				call forth_push_numhl 
b4a3			 
b4a3				       NEXTW 
b4a3 c3 58 9c			jp macro_next 
b4a6				endm 
# End of macro NEXTW
b4a6			 
b4a6			.maxcont:  
b4a6 c1				pop bc   ; tidy up 
b4a7 eb				ex de , hl  
b4a8					if DEBUG_FORTH_WORDS 
b4a8						DMARK "MA1" 
b4a8 f5				push af  
b4a9 3a bd b4			ld a, (.dmark)  
b4ac 32 b7 ee			ld (debug_mark),a  
b4af 3a be b4			ld a, (.dmark+1)  
b4b2 32 b8 ee			ld (debug_mark+1),a  
b4b5 3a bf b4			ld a, (.dmark+2)  
b4b8 32 b9 ee			ld (debug_mark+2),a  
b4bb 18 03			jr .pastdmark  
b4bd ..			.dmark: db "MA1"  
b4c0 f1			.pastdmark: pop af  
b4c1			endm  
# End of macro DMARK
b4c1						CALLMONITOR 
b4c1 cd 62 93			call break_point_state  
b4c4				endm  
# End of macro CALLMONITOR
b4c4					endif 
b4c4 cd ef 98				call forth_push_numhl 
b4c7				       NEXTW 
b4c7 c3 58 9c			jp macro_next 
b4ca				endm 
# End of macro NEXTW
b4ca			 
b4ca			.RND16: 
b4ca				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b4ca 4e				db WORD_SYS_CORE+58             
b4cb f9 b4			dw .RND8            
b4cd 06				db 5 + 1 
b4ce .. 00			db "RND16",0              
b4d4				endm 
# End of macro CWHEAD
b4d4			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b4d4					if DEBUG_FORTH_WORDS_KEY 
b4d4						DMARK "R16" 
b4d4 f5				push af  
b4d5 3a e9 b4			ld a, (.dmark)  
b4d8 32 b7 ee			ld (debug_mark),a  
b4db 3a ea b4			ld a, (.dmark+1)  
b4de 32 b8 ee			ld (debug_mark+1),a  
b4e1 3a eb b4			ld a, (.dmark+2)  
b4e4 32 b9 ee			ld (debug_mark+2),a  
b4e7 18 03			jr .pastdmark  
b4e9 ..			.dmark: db "R16"  
b4ec f1			.pastdmark: pop af  
b4ed			endm  
# End of macro DMARK
b4ed						CALLMONITOR 
b4ed cd 62 93			call break_point_state  
b4f0				endm  
# End of macro CALLMONITOR
b4f0					endif 
b4f0 cd e0 89				call prng16  
b4f3 cd ef 98				call forth_push_numhl 
b4f6				       NEXTW 
b4f6 c3 58 9c			jp macro_next 
b4f9				endm 
# End of macro NEXTW
b4f9			.RND8: 
b4f9				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b4f9 60				db WORD_SYS_CORE+76             
b4fa 2e b5			dw .RND            
b4fc 05				db 4 + 1 
b4fd .. 00			db "RND8",0              
b502				endm 
# End of macro CWHEAD
b502			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b502					if DEBUG_FORTH_WORDS_KEY 
b502						DMARK "RN8" 
b502 f5				push af  
b503 3a 17 b5			ld a, (.dmark)  
b506 32 b7 ee			ld (debug_mark),a  
b509 3a 18 b5			ld a, (.dmark+1)  
b50c 32 b8 ee			ld (debug_mark+1),a  
b50f 3a 19 b5			ld a, (.dmark+2)  
b512 32 b9 ee			ld (debug_mark+2),a  
b515 18 03			jr .pastdmark  
b517 ..			.dmark: db "RN8"  
b51a f1			.pastdmark: pop af  
b51b			endm  
# End of macro DMARK
b51b						CALLMONITOR 
b51b cd 62 93			call break_point_state  
b51e				endm  
# End of macro CALLMONITOR
b51e					endif 
b51e 2a 38 ed				ld hl,(xrandc) 
b521 23					inc hl 
b522 cd fa 89				call xrnd 
b525 6f					ld l,a	 
b526 26 00				ld h,0 
b528 cd ef 98				call forth_push_numhl 
b52b				       NEXTW 
b52b c3 58 9c			jp macro_next 
b52e				endm 
# End of macro NEXTW
b52e			.RND: 
b52e				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b52e 60				db WORD_SYS_CORE+76             
b52f 34 b6			dw .ENDMATHS            
b531 04				db 3 + 1 
b532 .. 00			db "RND",0              
b536				endm 
# End of macro CWHEAD
b536			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b536			 
b536					if DEBUG_FORTH_WORDS_KEY 
b536						DMARK "RND" 
b536 f5				push af  
b537 3a 4b b5			ld a, (.dmark)  
b53a 32 b7 ee			ld (debug_mark),a  
b53d 3a 4c b5			ld a, (.dmark+1)  
b540 32 b8 ee			ld (debug_mark+1),a  
b543 3a 4d b5			ld a, (.dmark+2)  
b546 32 b9 ee			ld (debug_mark+2),a  
b549 18 03			jr .pastdmark  
b54b ..			.dmark: db "RND"  
b54e f1			.pastdmark: pop af  
b54f			endm  
# End of macro DMARK
b54f						CALLMONITOR 
b54f cd 62 93			call break_point_state  
b552				endm  
# End of macro CALLMONITOR
b552					endif 
b552					 
b552					FORTH_DSP_VALUEHL    ; upper range 
b552 cd e6 9a			call macro_dsp_valuehl 
b555				endm 
# End of macro FORTH_DSP_VALUEHL
b555			 
b555 22 3c ed				ld (LFSRSeed), hl	 
b558			 
b558					if DEBUG_FORTH_WORDS 
b558						DMARK "RN1" 
b558 f5				push af  
b559 3a 6d b5			ld a, (.dmark)  
b55c 32 b7 ee			ld (debug_mark),a  
b55f 3a 6e b5			ld a, (.dmark+1)  
b562 32 b8 ee			ld (debug_mark+1),a  
b565 3a 6f b5			ld a, (.dmark+2)  
b568 32 b9 ee			ld (debug_mark+2),a  
b56b 18 03			jr .pastdmark  
b56d ..			.dmark: db "RN1"  
b570 f1			.pastdmark: pop af  
b571			endm  
# End of macro DMARK
b571						CALLMONITOR 
b571 cd 62 93			call break_point_state  
b574				endm  
# End of macro CALLMONITOR
b574					endif 
b574					FORTH_DSP_POP 
b574 cd 9e 9b			call macro_forth_dsp_pop 
b577				endm 
# End of macro FORTH_DSP_POP
b577			 
b577					FORTH_DSP_VALUEHL    ; low range 
b577 cd e6 9a			call macro_dsp_valuehl 
b57a				endm 
# End of macro FORTH_DSP_VALUEHL
b57a			 
b57a					if DEBUG_FORTH_WORDS 
b57a						DMARK "RN2" 
b57a f5				push af  
b57b 3a 8f b5			ld a, (.dmark)  
b57e 32 b7 ee			ld (debug_mark),a  
b581 3a 90 b5			ld a, (.dmark+1)  
b584 32 b8 ee			ld (debug_mark+1),a  
b587 3a 91 b5			ld a, (.dmark+2)  
b58a 32 b9 ee			ld (debug_mark+2),a  
b58d 18 03			jr .pastdmark  
b58f ..			.dmark: db "RN2"  
b592 f1			.pastdmark: pop af  
b593			endm  
# End of macro DMARK
b593						CALLMONITOR 
b593 cd 62 93			call break_point_state  
b596				endm  
# End of macro CALLMONITOR
b596					endif 
b596 22 3e ed				ld (LFSRSeed+2), hl 
b599			 
b599					FORTH_DSP_POP 
b599 cd 9e 9b			call macro_forth_dsp_pop 
b59c				endm 
# End of macro FORTH_DSP_POP
b59c			 
b59c e5					push hl 
b59d			 
b59d e1			.inrange:	pop hl 
b59e cd e0 89				call prng16  
b5a1					if DEBUG_FORTH_WORDS 
b5a1						DMARK "RN3" 
b5a1 f5				push af  
b5a2 3a b6 b5			ld a, (.dmark)  
b5a5 32 b7 ee			ld (debug_mark),a  
b5a8 3a b7 b5			ld a, (.dmark+1)  
b5ab 32 b8 ee			ld (debug_mark+1),a  
b5ae 3a b8 b5			ld a, (.dmark+2)  
b5b1 32 b9 ee			ld (debug_mark+2),a  
b5b4 18 03			jr .pastdmark  
b5b6 ..			.dmark: db "RN3"  
b5b9 f1			.pastdmark: pop af  
b5ba			endm  
# End of macro DMARK
b5ba						CALLMONITOR 
b5ba cd 62 93			call break_point_state  
b5bd				endm  
# End of macro CALLMONITOR
b5bd					endif 
b5bd					 
b5bd					; if the range is 8bit knock out the high byte 
b5bd			 
b5bd ed 5b 3c ed			ld de, (LFSRSeed)     ; check high level 
b5c1			 
b5c1 3e 00				ld a, 0 
b5c3 ba					cp d  
b5c4 20 1e				jr nz, .hirange 
b5c6 26 00				ld h, 0   ; knock it down to 8bit 
b5c8			 
b5c8					if DEBUG_FORTH_WORDS 
b5c8						DMARK "RNk" 
b5c8 f5				push af  
b5c9 3a dd b5			ld a, (.dmark)  
b5cc 32 b7 ee			ld (debug_mark),a  
b5cf 3a de b5			ld a, (.dmark+1)  
b5d2 32 b8 ee			ld (debug_mark+1),a  
b5d5 3a df b5			ld a, (.dmark+2)  
b5d8 32 b9 ee			ld (debug_mark+2),a  
b5db 18 03			jr .pastdmark  
b5dd ..			.dmark: db "RNk"  
b5e0 f1			.pastdmark: pop af  
b5e1			endm  
# End of macro DMARK
b5e1						CALLMONITOR 
b5e1 cd 62 93			call break_point_state  
b5e4				endm  
# End of macro CALLMONITOR
b5e4					endif 
b5e4			.hirange:   
b5e4 e5					push hl  
b5e5 b7					or a  
b5e6 ed 52		                sbc hl, de 
b5e8			 
b5e8					;call cmp16 
b5e8			 
b5e8 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b5ea e1					pop hl 
b5eb e5					push hl 
b5ec			 
b5ec					if DEBUG_FORTH_WORDS 
b5ec						DMARK "RN4" 
b5ec f5				push af  
b5ed 3a 01 b6			ld a, (.dmark)  
b5f0 32 b7 ee			ld (debug_mark),a  
b5f3 3a 02 b6			ld a, (.dmark+1)  
b5f6 32 b8 ee			ld (debug_mark+1),a  
b5f9 3a 03 b6			ld a, (.dmark+2)  
b5fc 32 b9 ee			ld (debug_mark+2),a  
b5ff 18 03			jr .pastdmark  
b601 ..			.dmark: db "RN4"  
b604 f1			.pastdmark: pop af  
b605			endm  
# End of macro DMARK
b605						CALLMONITOR 
b605 cd 62 93			call break_point_state  
b608				endm  
# End of macro CALLMONITOR
b608					endif 
b608 ed 5b 3e ed			ld de, (LFSRSeed+2)   ; check low range 
b60c					;call cmp16 
b60c				 
b60c b7					or a  
b60d ed 52		                sbc hl, de 
b60f 38 8c				jr c, .inrange 
b611			 
b611 e1					pop hl 
b612					 
b612					if DEBUG_FORTH_WORDS 
b612						DMARK "RNd" 
b612 f5				push af  
b613 3a 27 b6			ld a, (.dmark)  
b616 32 b7 ee			ld (debug_mark),a  
b619 3a 28 b6			ld a, (.dmark+1)  
b61c 32 b8 ee			ld (debug_mark+1),a  
b61f 3a 29 b6			ld a, (.dmark+2)  
b622 32 b9 ee			ld (debug_mark+2),a  
b625 18 03			jr .pastdmark  
b627 ..			.dmark: db "RNd"  
b62a f1			.pastdmark: pop af  
b62b			endm  
# End of macro DMARK
b62b						CALLMONITOR 
b62b cd 62 93			call break_point_state  
b62e				endm  
# End of macro CALLMONITOR
b62e					endif 
b62e			 
b62e			 
b62e cd ef 98				call forth_push_numhl 
b631				       NEXTW 
b631 c3 58 9c			jp macro_next 
b634				endm 
# End of macro NEXTW
b634			 
b634			.ENDMATHS: 
b634			 
b634			; eof 
b634			 
# End of file forth_words_maths.asm
b634			include "forth_words_display.asm" 
b634			 
b634			; | ## Display Words 
b634			 
b634			.INFO: 
b634			 
b634				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b634 62				db WORD_SYS_CORE+78             
b635 51 b6			dw .ATP            
b637 05				db 4 + 1 
b638 .. 00			db "INFO",0              
b63d				endm 
# End of macro CWHEAD
b63d			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b63d					FORTH_DSP_VALUEHL 
b63d cd e6 9a			call macro_dsp_valuehl 
b640				endm 
# End of macro FORTH_DSP_VALUEHL
b640			 
b640					FORTH_DSP_POP 
b640 cd 9e 9b			call macro_forth_dsp_pop 
b643				endm 
# End of macro FORTH_DSP_POP
b643			 
b643 e5					push hl 
b644			 
b644					FORTH_DSP_VALUEHL 
b644 cd e6 9a			call macro_dsp_valuehl 
b647				endm 
# End of macro FORTH_DSP_VALUEHL
b647			 
b647					FORTH_DSP_POP 
b647 cd 9e 9b			call macro_forth_dsp_pop 
b64a				endm 
# End of macro FORTH_DSP_POP
b64a			 
b64a d1					pop de 
b64b			 
b64b cd 1d 88				call info_panel 
b64e			 
b64e			 
b64e					NEXTW 
b64e c3 58 9c			jp macro_next 
b651				endm 
# End of macro NEXTW
b651			.ATP: 
b651				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b651 62				db WORD_SYS_CORE+78             
b652 c8 b6			dw .FB            
b654 04				db 3 + 1 
b655 .. 00			db "AT?",0              
b659				endm 
# End of macro CWHEAD
b659			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b659					if DEBUG_FORTH_WORDS_KEY 
b659						DMARK "AT?" 
b659 f5				push af  
b65a 3a 6e b6			ld a, (.dmark)  
b65d 32 b7 ee			ld (debug_mark),a  
b660 3a 6f b6			ld a, (.dmark+1)  
b663 32 b8 ee			ld (debug_mark+1),a  
b666 3a 70 b6			ld a, (.dmark+2)  
b669 32 b9 ee			ld (debug_mark+2),a  
b66c 18 03			jr .pastdmark  
b66e ..			.dmark: db "AT?"  
b671 f1			.pastdmark: pop af  
b672			endm  
# End of macro DMARK
b672						CALLMONITOR 
b672 cd 62 93			call break_point_state  
b675				endm  
# End of macro CALLMONITOR
b675					endif 
b675 3a c6 ec				ld a, (f_cursor_ptr) 
b678			 
b678			if DEBUG_FORTH_WORDS 
b678				DMARK "AT?" 
b678 f5				push af  
b679 3a 8d b6			ld a, (.dmark)  
b67c 32 b7 ee			ld (debug_mark),a  
b67f 3a 8e b6			ld a, (.dmark+1)  
b682 32 b8 ee			ld (debug_mark+1),a  
b685 3a 8f b6			ld a, (.dmark+2)  
b688 32 b9 ee			ld (debug_mark+2),a  
b68b 18 03			jr .pastdmark  
b68d ..			.dmark: db "AT?"  
b690 f1			.pastdmark: pop af  
b691			endm  
# End of macro DMARK
b691				CALLMONITOR 
b691 cd 62 93			call break_point_state  
b694				endm  
# End of macro CALLMONITOR
b694			endif	 
b694					; count the number of rows 
b694			 
b694 06 00				ld b, 0 
b696 4f			.atpr:		ld c, a    ; save in case we go below zero 
b697 d6 14				sub display_cols 
b699 f2 9f b6				jp p, .atprunder 
b69c 04					inc b 
b69d 18 f7				jr .atpr 
b69f			.atprunder:	 
b69f			if DEBUG_FORTH_WORDS 
b69f				DMARK "A?2" 
b69f f5				push af  
b6a0 3a b4 b6			ld a, (.dmark)  
b6a3 32 b7 ee			ld (debug_mark),a  
b6a6 3a b5 b6			ld a, (.dmark+1)  
b6a9 32 b8 ee			ld (debug_mark+1),a  
b6ac 3a b6 b6			ld a, (.dmark+2)  
b6af 32 b9 ee			ld (debug_mark+2),a  
b6b2 18 03			jr .pastdmark  
b6b4 ..			.dmark: db "A?2"  
b6b7 f1			.pastdmark: pop af  
b6b8			endm  
# End of macro DMARK
b6b8				CALLMONITOR 
b6b8 cd 62 93			call break_point_state  
b6bb				endm  
# End of macro CALLMONITOR
b6bb			endif	 
b6bb 26 00				ld h, 0 
b6bd 69					ld l, c 
b6be cd ef 98				call forth_push_numhl 
b6c1 68					ld l, b  
b6c2 cd ef 98				call forth_push_numhl 
b6c5			 
b6c5			 
b6c5				NEXTW 
b6c5 c3 58 9c			jp macro_next 
b6c8				endm 
# End of macro NEXTW
b6c8			 
b6c8			.FB: 
b6c8				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b6c8 1b				db WORD_SYS_CORE+7             
b6c9 16 b7			dw .EMIT            
b6cb 03				db 2 + 1 
b6cc .. 00			db "FB",0              
b6cf				endm 
# End of macro CWHEAD
b6cf			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b6cf			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b6cf			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b6cf			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b6cf					if DEBUG_FORTH_WORDS_KEY 
b6cf						DMARK "FB." 
b6cf f5				push af  
b6d0 3a e4 b6			ld a, (.dmark)  
b6d3 32 b7 ee			ld (debug_mark),a  
b6d6 3a e5 b6			ld a, (.dmark+1)  
b6d9 32 b8 ee			ld (debug_mark+1),a  
b6dc 3a e6 b6			ld a, (.dmark+2)  
b6df 32 b9 ee			ld (debug_mark+2),a  
b6e2 18 03			jr .pastdmark  
b6e4 ..			.dmark: db "FB."  
b6e7 f1			.pastdmark: pop af  
b6e8			endm  
# End of macro DMARK
b6e8						CALLMONITOR 
b6e8 cd 62 93			call break_point_state  
b6eb				endm  
# End of macro CALLMONITOR
b6eb					endif 
b6eb			 
b6eb					FORTH_DSP_VALUEHL 
b6eb cd e6 9a			call macro_dsp_valuehl 
b6ee				endm 
# End of macro FORTH_DSP_VALUEHL
b6ee			 
b6ee 7d					ld a, l 
b6ef fe 01				cp 1 
b6f1 20 05				jr nz, .fbn1 
b6f3 21 fc ed				ld hl, display_fb1 
b6f6 18 15				jr .fbset 
b6f8 fe 02		.fbn1:		cp 2 
b6fa 20 05				jr nz, .fbn2 
b6fc 21 5a ed				ld hl, display_fb2 
b6ff 18 0c				jr .fbset 
b701 fe 03		.fbn2:		cp 3 
b703 20 05				jr nz, .fbn3 
b705 21 ab ed				ld hl, display_fb3 
b708 18 03				jr .fbset 
b70a			.fbn3:		 ; if invalid number select first 
b70a 21 fc ed				ld hl, display_fb1 
b70d 22 58 ed		.fbset:		ld (display_fb_active), hl 
b710			 
b710					FORTH_DSP_POP 
b710 cd 9e 9b			call macro_forth_dsp_pop 
b713				endm 
# End of macro FORTH_DSP_POP
b713			 
b713					NEXTW 
b713 c3 58 9c			jp macro_next 
b716				endm 
# End of macro NEXTW
b716			 
b716			 
b716			.EMIT: 
b716				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b716 1b				db WORD_SYS_CORE+7             
b717 67 b7			dw .DOTH            
b719 05				db 4 + 1 
b71a .. 00			db "EMIT",0              
b71f				endm 
# End of macro CWHEAD
b71f			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b71f					; get value off TOS and display it 
b71f			 
b71f					if DEBUG_FORTH_WORDS_KEY 
b71f						DMARK "EMT" 
b71f f5				push af  
b720 3a 34 b7			ld a, (.dmark)  
b723 32 b7 ee			ld (debug_mark),a  
b726 3a 35 b7			ld a, (.dmark+1)  
b729 32 b8 ee			ld (debug_mark+1),a  
b72c 3a 36 b7			ld a, (.dmark+2)  
b72f 32 b9 ee			ld (debug_mark+2),a  
b732 18 03			jr .pastdmark  
b734 ..			.dmark: db "EMT"  
b737 f1			.pastdmark: pop af  
b738			endm  
# End of macro DMARK
b738						CALLMONITOR 
b738 cd 62 93			call break_point_state  
b73b				endm  
# End of macro CALLMONITOR
b73b					endif 
b73b			 
b73b					FORTH_DSP_VALUEHL 
b73b cd e6 9a			call macro_dsp_valuehl 
b73e				endm 
# End of macro FORTH_DSP_VALUEHL
b73e			 
b73e 7d					ld a,l 
b73f			 
b73f					; TODO write to display 
b73f			 
b73f 32 db e6				ld (os_input), a 
b742 3e 00				ld a, 0 
b744 32 dc e6				ld (os_input+1), a 
b747					 
b747 3a c6 ec				ld a, (f_cursor_ptr) 
b74a 11 db e6				ld de, os_input 
b74d cd 9f 88				call str_at_display 
b750			 
b750			 
b750 3a a4 ec				ld a,(cli_autodisplay) 
b753 fe 00				cp 0 
b755 28 03				jr z, .enoupdate 
b757 cd af 88						call update_display 
b75a					.enoupdate: 
b75a			 
b75a 3a c6 ec				ld a, (f_cursor_ptr) 
b75d 3c					inc a 
b75e 32 c6 ec				ld (f_cursor_ptr), a   ; save new pos 
b761			 
b761			 
b761					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b761 cd 9e 9b			call macro_forth_dsp_pop 
b764				endm 
# End of macro FORTH_DSP_POP
b764			  
b764			 
b764					NEXTW 
b764 c3 58 9c			jp macro_next 
b767				endm 
# End of macro NEXTW
b767			.DOTH: 
b767				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b767 1c				db WORD_SYS_CORE+8             
b768 97 b7			dw .DOTF            
b76a 03				db 2 + 1 
b76b .. 00			db ".-",0              
b76e				endm 
# End of macro CWHEAD
b76e			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b76e					; get value off TOS and display it 
b76e					if DEBUG_FORTH_WORDS_KEY 
b76e						DMARK "DTD" 
b76e f5				push af  
b76f 3a 83 b7			ld a, (.dmark)  
b772 32 b7 ee			ld (debug_mark),a  
b775 3a 84 b7			ld a, (.dmark+1)  
b778 32 b8 ee			ld (debug_mark+1),a  
b77b 3a 85 b7			ld a, (.dmark+2)  
b77e 32 b9 ee			ld (debug_mark+2),a  
b781 18 03			jr .pastdmark  
b783 ..			.dmark: db "DTD"  
b786 f1			.pastdmark: pop af  
b787			endm  
# End of macro DMARK
b787						CALLMONITOR 
b787 cd 62 93			call break_point_state  
b78a				endm  
# End of macro CALLMONITOR
b78a					endif 
b78a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b78c 3e 00			ld a, 0 
b78e 32 a5 ec			ld (cli_mvdot), a 
b791 c3 ee b7			jp .dotgo 
b794				NEXTW 
b794 c3 58 9c			jp macro_next 
b797				endm 
# End of macro NEXTW
b797			.DOTF: 
b797				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b797 1c				db WORD_SYS_CORE+8             
b798 c5 b7			dw .DOT            
b79a 03				db 2 + 1 
b79b .. 00			db ".>",0              
b79e				endm 
# End of macro CWHEAD
b79e			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b79e					; get value off TOS and display it 
b79e			        ; TODO BUG adds extra spaces 
b79e			        ; TODO BUG handle numerics? 
b79e					if DEBUG_FORTH_WORDS_KEY 
b79e						DMARK "DTC" 
b79e f5				push af  
b79f 3a b3 b7			ld a, (.dmark)  
b7a2 32 b7 ee			ld (debug_mark),a  
b7a5 3a b4 b7			ld a, (.dmark+1)  
b7a8 32 b8 ee			ld (debug_mark+1),a  
b7ab 3a b5 b7			ld a, (.dmark+2)  
b7ae 32 b9 ee			ld (debug_mark+2),a  
b7b1 18 03			jr .pastdmark  
b7b3 ..			.dmark: db "DTC"  
b7b6 f1			.pastdmark: pop af  
b7b7			endm  
# End of macro DMARK
b7b7						CALLMONITOR 
b7b7 cd 62 93			call break_point_state  
b7ba				endm  
# End of macro CALLMONITOR
b7ba					endif 
b7ba 3e 01			ld a, 1 
b7bc 32 a5 ec			ld (cli_mvdot), a 
b7bf c3 ee b7			jp .dotgo 
b7c2				NEXTW 
b7c2 c3 58 9c			jp macro_next 
b7c5				endm 
# End of macro NEXTW
b7c5			 
b7c5			.DOT: 
b7c5				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b7c5 1c				db WORD_SYS_CORE+8             
b7c6 51 b8			dw .CLS            
b7c8 02				db 1 + 1 
b7c9 .. 00			db ".",0              
b7cb				endm 
# End of macro CWHEAD
b7cb			        ; | . ( u -- ) Display TOS | DONE 
b7cb					; get value off TOS and display it 
b7cb			 
b7cb					if DEBUG_FORTH_WORDS_KEY 
b7cb						DMARK "DOT" 
b7cb f5				push af  
b7cc 3a e0 b7			ld a, (.dmark)  
b7cf 32 b7 ee			ld (debug_mark),a  
b7d2 3a e1 b7			ld a, (.dmark+1)  
b7d5 32 b8 ee			ld (debug_mark+1),a  
b7d8 3a e2 b7			ld a, (.dmark+2)  
b7db 32 b9 ee			ld (debug_mark+2),a  
b7de 18 03			jr .pastdmark  
b7e0 ..			.dmark: db "DOT"  
b7e3 f1			.pastdmark: pop af  
b7e4			endm  
# End of macro DMARK
b7e4						CALLMONITOR 
b7e4 cd 62 93			call break_point_state  
b7e7				endm  
# End of macro CALLMONITOR
b7e7					endif 
b7e7 3e 00			ld a, 0 
b7e9 32 a5 ec			ld (cli_mvdot), a 
b7ec 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b7ee				 
b7ee			 
b7ee			.dotgo: 
b7ee			 
b7ee			; move up type to on stack for parserv5 
b7ee					FORTH_DSP 
b7ee cd ac 9a			call macro_forth_dsp 
b7f1				endm 
# End of macro FORTH_DSP
b7f1				;FORTH_DSP_VALUE  
b7f1			 
b7f1			if DEBUG_FORTH_DOT 
b7f1				DMARK "DOT" 
b7f1				CALLMONITOR 
b7f1			endif	 
b7f1			;		.print: 
b7f1			 
b7f1 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b7f2 23				inc hl   ; position to the actual value 
b7f3 fe 01			cp DS_TYPE_STR 
b7f5 20 06			jr nz, .dotnum1  
b7f7			 
b7f7			; display string 
b7f7				FORTH_DSP_VALUE  
b7f7 cd cf 9a			call macro_forth_dsp_value 
b7fa				endm 
# End of macro FORTH_DSP_VALUE
b7fa eb				ex de,hl 
b7fb 18 11			jr .dotwrite 
b7fd			 
b7fd			.dotnum1: 
b7fd fe 02			cp DS_TYPE_INUM 
b7ff 20 0c			jr nz, .dotflot 
b801			 
b801			 
b801			; display number 
b801			 
b801			;	push hl 
b801			;	call clear_display 
b801			;	pop hl 
b801			 
b801 5e				ld e, (hl) 
b802 23				inc hl 
b803 56				ld d, (hl) 
b804 21 dd e4			ld hl, scratch 
b807			if DEBUG_FORTH_DOT 
b807				DMARK "DT1" 
b807				CALLMONITOR 
b807			endif	 
b807			 
b807 cd c6 8e			call uitoa_16 
b80a eb				ex de,hl 
b80b			 
b80b			if DEBUG_FORTH_DOT 
b80b				DMARK "DT2" 
b80b				CALLMONITOR 
b80b			endif	 
b80b			 
b80b			;	ld de, os_word_scratch 
b80b 18 01			jr .dotwrite 
b80d			 
b80d 00			.dotflot:   nop 
b80e			; TODO print floating point number 
b80e			 
b80e			.dotwrite:		 
b80e			 
b80e					; if c is set then set all '-' to spaces 
b80e					; need to also take into account .>  
b80e			 
b80e 3e 01				ld a, 1 
b810 b9					cp c 
b811 20 13				jr nz, .nodashswap 
b813			 
b813					; DE has the string to write, working with HL 
b813			 
b813 06 ff				ld b, 255 
b815 d5					push de 
b816 e1					pop hl 
b817			 
b817			if DEBUG_FORTH_DOT 
b817				DMARK "DT-" 
b817				CALLMONITOR 
b817			endif	 
b817 7e			.dashscan:	ld a, (hl) 
b818 fe 00				cp 0 
b81a 28 0a				jr z, .nodashswap 
b81c fe 2d				cp '-' 
b81e 20 03				jr nz, .dashskip 
b820 3e 20				ld a, ' ' 
b822 77					ld (hl), a 
b823 23			.dashskip:	inc hl 
b824			if DEBUG_FORTH_DOT 
b824				DMARK "D-2" 
b824				CALLMONITOR 
b824			endif	 
b824 10 f1				djnz .dashscan 
b826			 
b826			if DEBUG_FORTH_DOT 
b826				DMARK "D-1" 
b826				CALLMONITOR 
b826			endif	 
b826			 
b826			.nodashswap: 
b826			 
b826 e5					push hl   ; save string start in case we need to advance print 
b827			 
b827 3a c6 ec				ld a, (f_cursor_ptr) 
b82a cd 9f 88				call str_at_display 
b82d 3a a4 ec				ld a,(cli_autodisplay) 
b830 fe 00				cp 0 
b832 28 03				jr z, .noupdate 
b834 cd af 88						call update_display 
b837					.noupdate: 
b837			 
b837			 
b837					; see if we need to advance the print position 
b837			 
b837 e1					pop hl   ; get back string 
b838			 
b838 3a a5 ec				ld a, (cli_mvdot) 
b83b			if DEBUG_FORTH_DOT 
b83b					ld e,a 
b83b				DMARK "D>1" 
b83b				CALLMONITOR 
b83b			endif	 
b83b fe 00				cp 0 
b83d 28 0c				jr z, .noadv 
b83f					; yes, lets advance the print position 
b83f 3e 00				ld a, 0 
b841 cd 22 8f				call strlent 
b844 3a c6 ec				ld a, (f_cursor_ptr) 
b847 85					add a,l 
b848					;call addatohl 
b848					;ld a, l 
b848 32 c6 ec				ld (f_cursor_ptr), a   ; save new pos 
b84b			 
b84b			if DEBUG_FORTH_DOT 
b84b				DMARK "D->" 
b84b				CALLMONITOR 
b84b			endif	 
b84b			 
b84b			.noadv:	 
b84b			 
b84b					if DEBUG_FORTH_DOT_WAIT 
b84b							call next_page_prompt 
b84b					endif	 
b84b			; TODO this pop off the stack causes a crash. i dont know why 
b84b			 
b84b			 
b84b			if DEBUG_FORTH_DOT 
b84b				DMARK "DTh" 
b84b				CALLMONITOR 
b84b			endif	 
b84b			 
b84b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b84b cd 9e 9b			call macro_forth_dsp_pop 
b84e				endm 
# End of macro FORTH_DSP_POP
b84e			 
b84e			if DEBUG_FORTH_DOT 
b84e				DMARK "DTi" 
b84e				CALLMONITOR 
b84e			endif	 
b84e			 
b84e			 
b84e					NEXTW 
b84e c3 58 9c			jp macro_next 
b851				endm 
# End of macro NEXTW
b851			 
b851			.CLS: 
b851				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b851 35				db WORD_SYS_CORE+33             
b852 7e b8			dw .DRAW            
b854 04				db 3 + 1 
b855 .. 00			db "CLS",0              
b859				endm 
# End of macro CWHEAD
b859			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b859					if DEBUG_FORTH_WORDS_KEY 
b859						DMARK "CLS" 
b859 f5				push af  
b85a 3a 6e b8			ld a, (.dmark)  
b85d 32 b7 ee			ld (debug_mark),a  
b860 3a 6f b8			ld a, (.dmark+1)  
b863 32 b8 ee			ld (debug_mark+1),a  
b866 3a 70 b8			ld a, (.dmark+2)  
b869 32 b9 ee			ld (debug_mark+2),a  
b86c 18 03			jr .pastdmark  
b86e ..			.dmark: db "CLS"  
b871 f1			.pastdmark: pop af  
b872			endm  
# End of macro DMARK
b872						CALLMONITOR 
b872 cd 62 93			call break_point_state  
b875				endm  
# End of macro CALLMONITOR
b875					endif 
b875 cd 8c 88				call clear_display 
b878 c3 8c b9				jp .home		; and home cursor 
b87b					NEXTW 
b87b c3 58 9c			jp macro_next 
b87e				endm 
# End of macro NEXTW
b87e			 
b87e			.DRAW: 
b87e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b87e 36				db WORD_SYS_CORE+34             
b87f a9 b8			dw .DUMP            
b881 05				db 4 + 1 
b882 .. 00			db "DRAW",0              
b887				endm 
# End of macro CWHEAD
b887			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b887					if DEBUG_FORTH_WORDS_KEY 
b887						DMARK "DRW" 
b887 f5				push af  
b888 3a 9c b8			ld a, (.dmark)  
b88b 32 b7 ee			ld (debug_mark),a  
b88e 3a 9d b8			ld a, (.dmark+1)  
b891 32 b8 ee			ld (debug_mark+1),a  
b894 3a 9e b8			ld a, (.dmark+2)  
b897 32 b9 ee			ld (debug_mark+2),a  
b89a 18 03			jr .pastdmark  
b89c ..			.dmark: db "DRW"  
b89f f1			.pastdmark: pop af  
b8a0			endm  
# End of macro DMARK
b8a0						CALLMONITOR 
b8a0 cd 62 93			call break_point_state  
b8a3				endm  
# End of macro CALLMONITOR
b8a3					endif 
b8a3 cd af 88				call update_display 
b8a6					NEXTW 
b8a6 c3 58 9c			jp macro_next 
b8a9				endm 
# End of macro NEXTW
b8a9			 
b8a9			.DUMP: 
b8a9				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b8a9 37				db WORD_SYS_CORE+35             
b8aa e1 b8			dw .CDUMP            
b8ac 05				db 4 + 1 
b8ad .. 00			db "DUMP",0              
b8b2				endm 
# End of macro CWHEAD
b8b2			; | DUMP ( x -- ) With address x display dump   | DONE 
b8b2			; TODO pop address to use off of the stack 
b8b2					if DEBUG_FORTH_WORDS_KEY 
b8b2						DMARK "DUM" 
b8b2 f5				push af  
b8b3 3a c7 b8			ld a, (.dmark)  
b8b6 32 b7 ee			ld (debug_mark),a  
b8b9 3a c8 b8			ld a, (.dmark+1)  
b8bc 32 b8 ee			ld (debug_mark+1),a  
b8bf 3a c9 b8			ld a, (.dmark+2)  
b8c2 32 b9 ee			ld (debug_mark+2),a  
b8c5 18 03			jr .pastdmark  
b8c7 ..			.dmark: db "DUM"  
b8ca f1			.pastdmark: pop af  
b8cb			endm  
# End of macro DMARK
b8cb						CALLMONITOR 
b8cb cd 62 93			call break_point_state  
b8ce				endm  
# End of macro CALLMONITOR
b8ce					endif 
b8ce cd 8c 88				call clear_display 
b8d1			 
b8d1					; get address 
b8d1			 
b8d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8d1 cd e6 9a			call macro_dsp_valuehl 
b8d4				endm 
# End of macro FORTH_DSP_VALUEHL
b8d4				 
b8d4					; save it for cdump 
b8d4			 
b8d4 22 00 e8				ld (os_cur_ptr),hl 
b8d7			 
b8d7					; destroy value TOS 
b8d7			 
b8d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8d7 cd 9e 9b			call macro_forth_dsp_pop 
b8da				endm 
# End of macro FORTH_DSP_POP
b8da			 
b8da cd 6f 97				call dumpcont	; skip old style of param parsing	 
b8dd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b8de					NEXTW 
b8de c3 58 9c			jp macro_next 
b8e1				endm 
# End of macro NEXTW
b8e1			.CDUMP: 
b8e1				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b8e1 38				db WORD_SYS_CORE+36             
b8e2 11 b9			dw .DAT            
b8e4 06				db 5 + 1 
b8e5 .. 00			db "CDUMP",0              
b8eb				endm 
# End of macro CWHEAD
b8eb			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b8eb					if DEBUG_FORTH_WORDS_KEY 
b8eb						DMARK "CDP" 
b8eb f5				push af  
b8ec 3a 00 b9			ld a, (.dmark)  
b8ef 32 b7 ee			ld (debug_mark),a  
b8f2 3a 01 b9			ld a, (.dmark+1)  
b8f5 32 b8 ee			ld (debug_mark+1),a  
b8f8 3a 02 b9			ld a, (.dmark+2)  
b8fb 32 b9 ee			ld (debug_mark+2),a  
b8fe 18 03			jr .pastdmark  
b900 ..			.dmark: db "CDP"  
b903 f1			.pastdmark: pop af  
b904			endm  
# End of macro DMARK
b904						CALLMONITOR 
b904 cd 62 93			call break_point_state  
b907				endm  
# End of macro CALLMONITOR
b907					endif 
b907 cd 8c 88				call clear_display 
b90a cd 6f 97				call dumpcont	 
b90d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b90e					NEXTW 
b90e c3 58 9c			jp macro_next 
b911				endm 
# End of macro NEXTW
b911			 
b911			 
b911			 
b911			 
b911			.DAT: 
b911				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b911 3d				db WORD_SYS_CORE+41             
b912 67 b9			dw .HOME            
b914 03				db 2 + 1 
b915 .. 00			db "AT",0              
b918				endm 
# End of macro CWHEAD
b918			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b918					if DEBUG_FORTH_WORDS_KEY 
b918						DMARK "AT." 
b918 f5				push af  
b919 3a 2d b9			ld a, (.dmark)  
b91c 32 b7 ee			ld (debug_mark),a  
b91f 3a 2e b9			ld a, (.dmark+1)  
b922 32 b8 ee			ld (debug_mark+1),a  
b925 3a 2f b9			ld a, (.dmark+2)  
b928 32 b9 ee			ld (debug_mark+2),a  
b92b 18 03			jr .pastdmark  
b92d ..			.dmark: db "AT."  
b930 f1			.pastdmark: pop af  
b931			endm  
# End of macro DMARK
b931						CALLMONITOR 
b931 cd 62 93			call break_point_state  
b934				endm  
# End of macro CALLMONITOR
b934					endif 
b934					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b934 cd e6 9a			call macro_dsp_valuehl 
b937				endm 
# End of macro FORTH_DSP_VALUEHL
b937			 
b937			 
b937					; TODO save cursor row 
b937 7d					ld a,l 
b938 fe 02				cp 2 
b93a 20 04				jr nz, .crow3 
b93c 3e 14				ld a, display_row_2 
b93e 18 12				jr .ccol1 
b940 fe 03		.crow3:		cp 3 
b942 20 04				jr nz, .crow4 
b944 3e 28				ld a, display_row_3 
b946 18 0a				jr .ccol1 
b948 fe 04		.crow4:		cp 4 
b94a 20 04				jr nz, .crow1 
b94c 3e 3c				ld a, display_row_4 
b94e 18 02				jr .ccol1 
b950 3e 00		.crow1:		ld a,display_row_1 
b952 f5			.ccol1:		push af			; got row offset 
b953 6f					ld l,a 
b954 26 00				ld h,0 
b956					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b956 cd 9e 9b			call macro_forth_dsp_pop 
b959				endm 
# End of macro FORTH_DSP_POP
b959					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b959 cd e6 9a			call macro_dsp_valuehl 
b95c				endm 
# End of macro FORTH_DSP_VALUEHL
b95c					; TODO save cursor col 
b95c f1					pop af 
b95d 85					add l		; add col offset 
b95e 32 c6 ec				ld (f_cursor_ptr), a 
b961					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b961 cd 9e 9b			call macro_forth_dsp_pop 
b964				endm 
# End of macro FORTH_DSP_POP
b964			 
b964					; calculate  
b964			 
b964					NEXTW 
b964 c3 58 9c			jp macro_next 
b967				endm 
# End of macro NEXTW
b967			 
b967			 
b967			.HOME: 
b967				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b967 41				db WORD_SYS_CORE+45             
b968 94 b9			dw .SPACE            
b96a 05				db 4 + 1 
b96b .. 00			db "HOME",0              
b970				endm 
# End of macro CWHEAD
b970			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b970					if DEBUG_FORTH_WORDS_KEY 
b970						DMARK "HOM" 
b970 f5				push af  
b971 3a 85 b9			ld a, (.dmark)  
b974 32 b7 ee			ld (debug_mark),a  
b977 3a 86 b9			ld a, (.dmark+1)  
b97a 32 b8 ee			ld (debug_mark+1),a  
b97d 3a 87 b9			ld a, (.dmark+2)  
b980 32 b9 ee			ld (debug_mark+2),a  
b983 18 03			jr .pastdmark  
b985 ..			.dmark: db "HOM"  
b988 f1			.pastdmark: pop af  
b989			endm  
# End of macro DMARK
b989						CALLMONITOR 
b989 cd 62 93			call break_point_state  
b98c				endm  
# End of macro CALLMONITOR
b98c					endif 
b98c 3e 00		.home:		ld a, 0		; and home cursor 
b98e 32 c6 ec				ld (f_cursor_ptr), a 
b991					NEXTW 
b991 c3 58 9c			jp macro_next 
b994				endm 
# End of macro NEXTW
b994			 
b994			 
b994			.SPACE: 
b994				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
b994 46				db WORD_SYS_CORE+50             
b995 c2 b9			dw .SPACES            
b997 03				db 2 + 1 
b998 .. 00			db "BL",0              
b99b				endm 
# End of macro CWHEAD
b99b			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
b99b					if DEBUG_FORTH_WORDS_KEY 
b99b						DMARK "BL." 
b99b f5				push af  
b99c 3a b0 b9			ld a, (.dmark)  
b99f 32 b7 ee			ld (debug_mark),a  
b9a2 3a b1 b9			ld a, (.dmark+1)  
b9a5 32 b8 ee			ld (debug_mark+1),a  
b9a8 3a b2 b9			ld a, (.dmark+2)  
b9ab 32 b9 ee			ld (debug_mark+2),a  
b9ae 18 03			jr .pastdmark  
b9b0 ..			.dmark: db "BL."  
b9b3 f1			.pastdmark: pop af  
b9b4			endm  
# End of macro DMARK
b9b4						CALLMONITOR 
b9b4 cd 62 93			call break_point_state  
b9b7				endm  
# End of macro CALLMONITOR
b9b7					endif 
b9b7 21 c0 b9				ld hl, .blstr 
b9ba cd 5d 99				call forth_push_str 
b9bd					 
b9bd				       NEXTW 
b9bd c3 58 9c			jp macro_next 
b9c0				endm 
# End of macro NEXTW
b9c0			 
b9c0 .. 00		.blstr: db " ", 0 
b9c2			 
b9c2			.SPACES: 
b9c2				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
b9c2 47				db WORD_SYS_CORE+51             
b9c3 5d ba			dw .SCROLL            
b9c5 07				db 6 + 1 
b9c6 .. 00			db "SPACES",0              
b9cd				endm 
# End of macro CWHEAD
b9cd			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
b9cd					if DEBUG_FORTH_WORDS_KEY 
b9cd						DMARK "SPS" 
b9cd f5				push af  
b9ce 3a e2 b9			ld a, (.dmark)  
b9d1 32 b7 ee			ld (debug_mark),a  
b9d4 3a e3 b9			ld a, (.dmark+1)  
b9d7 32 b8 ee			ld (debug_mark+1),a  
b9da 3a e4 b9			ld a, (.dmark+2)  
b9dd 32 b9 ee			ld (debug_mark+2),a  
b9e0 18 03			jr .pastdmark  
b9e2 ..			.dmark: db "SPS"  
b9e5 f1			.pastdmark: pop af  
b9e6			endm  
# End of macro DMARK
b9e6						CALLMONITOR 
b9e6 cd 62 93			call break_point_state  
b9e9				endm  
# End of macro CALLMONITOR
b9e9					endif 
b9e9			 
b9e9			 
b9e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9e9 cd e6 9a			call macro_dsp_valuehl 
b9ec				endm 
# End of macro FORTH_DSP_VALUEHL
b9ec			 
b9ec			;		push hl    ; u 
b9ec					if DEBUG_FORTH_WORDS 
b9ec						DMARK "SPA" 
b9ec f5				push af  
b9ed 3a 01 ba			ld a, (.dmark)  
b9f0 32 b7 ee			ld (debug_mark),a  
b9f3 3a 02 ba			ld a, (.dmark+1)  
b9f6 32 b8 ee			ld (debug_mark+1),a  
b9f9 3a 03 ba			ld a, (.dmark+2)  
b9fc 32 b9 ee			ld (debug_mark+2),a  
b9ff 18 03			jr .pastdmark  
ba01 ..			.dmark: db "SPA"  
ba04 f1			.pastdmark: pop af  
ba05			endm  
# End of macro DMARK
ba05						CALLMONITOR 
ba05 cd 62 93			call break_point_state  
ba08				endm  
# End of macro CALLMONITOR
ba08					endif 
ba08			 
ba08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba08 cd 9e 9b			call macro_forth_dsp_pop 
ba0b				endm 
# End of macro FORTH_DSP_POP
ba0b			;		pop hl 
ba0b 4d					ld c, l 
ba0c 06 00				ld b, 0 
ba0e 21 dd e4				ld hl, scratch  
ba11			 
ba11					if DEBUG_FORTH_WORDS 
ba11						DMARK "SP2" 
ba11 f5				push af  
ba12 3a 26 ba			ld a, (.dmark)  
ba15 32 b7 ee			ld (debug_mark),a  
ba18 3a 27 ba			ld a, (.dmark+1)  
ba1b 32 b8 ee			ld (debug_mark+1),a  
ba1e 3a 28 ba			ld a, (.dmark+2)  
ba21 32 b9 ee			ld (debug_mark+2),a  
ba24 18 03			jr .pastdmark  
ba26 ..			.dmark: db "SP2"  
ba29 f1			.pastdmark: pop af  
ba2a			endm  
# End of macro DMARK
ba2a						CALLMONITOR 
ba2a cd 62 93			call break_point_state  
ba2d				endm  
# End of macro CALLMONITOR
ba2d					endif 
ba2d 3e 20				ld a, ' ' 
ba2f c5			.spaces1:	push bc 
ba30 77					ld (hl),a 
ba31 23					inc hl 
ba32 c1					pop bc 
ba33 10 fa				djnz .spaces1 
ba35 3e 00				ld a,0 
ba37 77					ld (hl),a 
ba38 21 dd e4				ld hl, scratch 
ba3b					if DEBUG_FORTH_WORDS 
ba3b						DMARK "SP3" 
ba3b f5				push af  
ba3c 3a 50 ba			ld a, (.dmark)  
ba3f 32 b7 ee			ld (debug_mark),a  
ba42 3a 51 ba			ld a, (.dmark+1)  
ba45 32 b8 ee			ld (debug_mark+1),a  
ba48 3a 52 ba			ld a, (.dmark+2)  
ba4b 32 b9 ee			ld (debug_mark+2),a  
ba4e 18 03			jr .pastdmark  
ba50 ..			.dmark: db "SP3"  
ba53 f1			.pastdmark: pop af  
ba54			endm  
# End of macro DMARK
ba54						CALLMONITOR 
ba54 cd 62 93			call break_point_state  
ba57				endm  
# End of macro CALLMONITOR
ba57					endif 
ba57 cd 58 9a				call forth_apush 
ba5a			 
ba5a				       NEXTW 
ba5a c3 58 9c			jp macro_next 
ba5d				endm 
# End of macro NEXTW
ba5d			 
ba5d			 
ba5d			 
ba5d			.SCROLL: 
ba5d				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
ba5d 53				db WORD_SYS_CORE+63             
ba5e 8a ba			dw .SCROLLD            
ba60 07				db 6 + 1 
ba61 .. 00			db "SCROLL",0              
ba68				endm 
# End of macro CWHEAD
ba68			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
ba68					if DEBUG_FORTH_WORDS_KEY 
ba68						DMARK "SCR" 
ba68 f5				push af  
ba69 3a 7d ba			ld a, (.dmark)  
ba6c 32 b7 ee			ld (debug_mark),a  
ba6f 3a 7e ba			ld a, (.dmark+1)  
ba72 32 b8 ee			ld (debug_mark+1),a  
ba75 3a 7f ba			ld a, (.dmark+2)  
ba78 32 b9 ee			ld (debug_mark+2),a  
ba7b 18 03			jr .pastdmark  
ba7d ..			.dmark: db "SCR"  
ba80 f1			.pastdmark: pop af  
ba81			endm  
# End of macro DMARK
ba81						CALLMONITOR 
ba81 cd 62 93			call break_point_state  
ba84				endm  
# End of macro CALLMONITOR
ba84					endif 
ba84			 
ba84 cd 4e 88			call scroll_up 
ba87			;	call update_display 
ba87			 
ba87					NEXTW 
ba87 c3 58 9c			jp macro_next 
ba8a				endm 
# End of macro NEXTW
ba8a			 
ba8a			 
ba8a			 
ba8a			;		; get dir 
ba8a			; 
ba8a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba8a			; 
ba8a			;		push hl 
ba8a			; 
ba8a			;		; destroy value TOS 
ba8a			; 
ba8a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba8a			; 
ba8a			;		; get count 
ba8a			; 
ba8a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba8a			; 
ba8a			;		push hl 
ba8a			; 
ba8a			;		; destroy value TOS 
ba8a			; 
ba8a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba8a			; 
ba8a			;		; one value on hl get other one back 
ba8a			; 
ba8a			;		pop bc    ; count 
ba8a			; 
ba8a			;		pop de   ; dir 
ba8a			; 
ba8a			; 
ba8a			;		ld b, c 
ba8a			; 
ba8a			;.scrolldir:     push bc 
ba8a			;		push de 
ba8a			; 
ba8a			;		ld a, 0 
ba8a			;		cp e 
ba8a			;		jr z, .scrollup  
ba8a			;		call scroll_down 
ba8a			;		jr .scrollnext 
ba8a			;.scrollup:	call scroll_up 
ba8a			; 
ba8a			;		 
ba8a			;.scrollnext: 
ba8a			;		pop de 
ba8a			;		pop bc 
ba8a			;		djnz .scrolldir 
ba8a			; 
ba8a			; 
ba8a			; 
ba8a			; 
ba8a			; 
ba8a			;		NEXTW 
ba8a			 
ba8a			.SCROLLD: 
ba8a				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
ba8a 53				db WORD_SYS_CORE+63             
ba8b b8 ba			dw .ATQ            
ba8d 08				db 7 + 1 
ba8e .. 00			db "SCROLLD",0              
ba96				endm 
# End of macro CWHEAD
ba96			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
ba96					if DEBUG_FORTH_WORDS_KEY 
ba96						DMARK "SCD" 
ba96 f5				push af  
ba97 3a ab ba			ld a, (.dmark)  
ba9a 32 b7 ee			ld (debug_mark),a  
ba9d 3a ac ba			ld a, (.dmark+1)  
baa0 32 b8 ee			ld (debug_mark+1),a  
baa3 3a ad ba			ld a, (.dmark+2)  
baa6 32 b9 ee			ld (debug_mark+2),a  
baa9 18 03			jr .pastdmark  
baab ..			.dmark: db "SCD"  
baae f1			.pastdmark: pop af  
baaf			endm  
# End of macro DMARK
baaf						CALLMONITOR 
baaf cd 62 93			call break_point_state  
bab2				endm  
# End of macro CALLMONITOR
bab2					endif 
bab2			 
bab2 cd 72 88			call scroll_down 
bab5			;	call update_display 
bab5			 
bab5					NEXTW 
bab5 c3 58 9c			jp macro_next 
bab8				endm 
# End of macro NEXTW
bab8			 
bab8			 
bab8			.ATQ: 
bab8				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bab8 62				db WORD_SYS_CORE+78             
bab9 16 bb			dw .AUTODSP            
babb 04				db 3 + 1 
babc .. 00			db "AT@",0              
bac0				endm 
# End of macro CWHEAD
bac0			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bac0					if DEBUG_FORTH_WORDS_KEY 
bac0						DMARK "ATA" 
bac0 f5				push af  
bac1 3a d5 ba			ld a, (.dmark)  
bac4 32 b7 ee			ld (debug_mark),a  
bac7 3a d6 ba			ld a, (.dmark+1)  
baca 32 b8 ee			ld (debug_mark+1),a  
bacd 3a d7 ba			ld a, (.dmark+2)  
bad0 32 b9 ee			ld (debug_mark+2),a  
bad3 18 03			jr .pastdmark  
bad5 ..			.dmark: db "ATA"  
bad8 f1			.pastdmark: pop af  
bad9			endm  
# End of macro DMARK
bad9						CALLMONITOR 
bad9 cd 62 93			call break_point_state  
badc				endm  
# End of macro CALLMONITOR
badc					endif 
badc			 
badc			 
badc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
badc cd e6 9a			call macro_dsp_valuehl 
badf				endm 
# End of macro FORTH_DSP_VALUEHL
badf			 
badf					; TODO save cursor row 
badf 7d					ld a,l 
bae0 fe 02				cp 2 
bae2 20 04				jr nz, .crow3aq 
bae4 3e 14				ld a, display_row_2 
bae6 18 12				jr .ccol1aq 
bae8 fe 03		.crow3aq:		cp 3 
baea 20 04				jr nz, .crow4aq 
baec 3e 28				ld a, display_row_3 
baee 18 0a				jr .ccol1aq 
baf0 fe 04		.crow4aq:		cp 4 
baf2 20 04				jr nz, .crow1aq 
baf4 3e 3c				ld a, display_row_4 
baf6 18 02				jr .ccol1aq 
baf8 3e 00		.crow1aq:		ld a,display_row_1 
bafa f5			.ccol1aq:		push af			; got row offset 
bafb 6f					ld l,a 
bafc 26 00				ld h,0 
bafe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bafe cd 9e 9b			call macro_forth_dsp_pop 
bb01				endm 
# End of macro FORTH_DSP_POP
bb01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb01 cd e6 9a			call macro_dsp_valuehl 
bb04				endm 
# End of macro FORTH_DSP_VALUEHL
bb04					; TODO save cursor col 
bb04 f1					pop af 
bb05 85					add l		; add col offset 
bb06			 
bb06					; add current frame buffer address 
bb06 2a 58 ed				ld hl, (display_fb_active) 
bb09 cd b9 8a				call addatohl 
bb0c			 
bb0c			 
bb0c			 
bb0c			 
bb0c					; get char frame buffer location offset in hl 
bb0c			 
bb0c 7e					ld a,(hl) 
bb0d 26 00				ld h, 0 
bb0f 6f					ld l, a 
bb10			 
bb10 cd ef 98				call forth_push_numhl 
bb13			 
bb13			 
bb13					NEXTW 
bb13 c3 58 9c			jp macro_next 
bb16				endm 
# End of macro NEXTW
bb16			 
bb16			.AUTODSP: 
bb16				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bb16 63				db WORD_SYS_CORE+79             
bb17 2c bb			dw .MENU            
bb19 05				db 4 + 1 
bb1a .. 00			db "ADSP",0              
bb1f				endm 
# End of macro CWHEAD
bb1f			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bb1f			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bb1f			 
bb1f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb1f cd e6 9a			call macro_dsp_valuehl 
bb22				endm 
# End of macro FORTH_DSP_VALUEHL
bb22			 
bb22			;		push hl 
bb22			 
bb22					; destroy value TOS 
bb22			 
bb22					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb22 cd 9e 9b			call macro_forth_dsp_pop 
bb25				endm 
# End of macro FORTH_DSP_POP
bb25			 
bb25			;		pop hl 
bb25			 
bb25 7d					ld a,l 
bb26 32 a4 ec				ld (cli_autodisplay), a 
bb29				       NEXTW 
bb29 c3 58 9c			jp macro_next 
bb2c				endm 
# End of macro NEXTW
bb2c			 
bb2c			.MENU: 
bb2c				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bb2c 70				db WORD_SYS_CORE+92             
bb2d d5 bb			dw .ENDDISPLAY            
bb2f 05				db 4 + 1 
bb30 .. 00			db "MENU",0              
bb35				endm 
# End of macro CWHEAD
bb35			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bb35			 
bb35			;		; get number of items on the stack 
bb35			; 
bb35				 
bb35					FORTH_DSP_VALUEHL 
bb35 cd e6 9a			call macro_dsp_valuehl 
bb38				endm 
# End of macro FORTH_DSP_VALUEHL
bb38				 
bb38					if DEBUG_FORTH_WORDS_KEY 
bb38						DMARK "MNU" 
bb38 f5				push af  
bb39 3a 4d bb			ld a, (.dmark)  
bb3c 32 b7 ee			ld (debug_mark),a  
bb3f 3a 4e bb			ld a, (.dmark+1)  
bb42 32 b8 ee			ld (debug_mark+1),a  
bb45 3a 4f bb			ld a, (.dmark+2)  
bb48 32 b9 ee			ld (debug_mark+2),a  
bb4b 18 03			jr .pastdmark  
bb4d ..			.dmark: db "MNU"  
bb50 f1			.pastdmark: pop af  
bb51			endm  
# End of macro DMARK
bb51						CALLMONITOR 
bb51 cd 62 93			call break_point_state  
bb54				endm  
# End of macro CALLMONITOR
bb54					endif 
bb54			 
bb54 45					ld b, l	 
bb55 05					dec b 
bb56			 
bb56					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb56 cd 9e 9b			call macro_forth_dsp_pop 
bb59				endm 
# End of macro FORTH_DSP_POP
bb59			 
bb59			 
bb59					; go directly through the stack to pluck out the string pointers and build an array 
bb59			 
bb59			;		FORTH_DSP 
bb59			 
bb59					; hl contains top most stack item 
bb59				 
bb59 11 dd e4				ld de, scratch 
bb5c			 
bb5c			.mbuild: 
bb5c			 
bb5c					FORTH_DSP_VALUEHL 
bb5c cd e6 9a			call macro_dsp_valuehl 
bb5f				endm 
# End of macro FORTH_DSP_VALUEHL
bb5f			 
bb5f					if DEBUG_FORTH_WORDS 
bb5f						DMARK "MN3" 
bb5f f5				push af  
bb60 3a 74 bb			ld a, (.dmark)  
bb63 32 b7 ee			ld (debug_mark),a  
bb66 3a 75 bb			ld a, (.dmark+1)  
bb69 32 b8 ee			ld (debug_mark+1),a  
bb6c 3a 76 bb			ld a, (.dmark+2)  
bb6f 32 b9 ee			ld (debug_mark+2),a  
bb72 18 03			jr .pastdmark  
bb74 ..			.dmark: db "MN3"  
bb77 f1			.pastdmark: pop af  
bb78			endm  
# End of macro DMARK
bb78						CALLMONITOR 
bb78 cd 62 93			call break_point_state  
bb7b				endm  
# End of macro CALLMONITOR
bb7b					endif 
bb7b eb					ex de, hl 
bb7c 73					ld (hl), e 
bb7d 23					inc hl 
bb7e 72					ld (hl), d 
bb7f 23					inc hl 
bb80 eb					ex de, hl 
bb81			 
bb81					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb81 cd 9e 9b			call macro_forth_dsp_pop 
bb84				endm 
# End of macro FORTH_DSP_POP
bb84			 
bb84 10 d6				djnz .mbuild 
bb86			 
bb86					; done add term 
bb86			 
bb86 eb					ex de, hl 
bb87 36 00				ld (hl), 0 
bb89 23					inc hl 
bb8a 36 00				ld (hl), 0 
bb8c			 
bb8c				 
bb8c					 
bb8c 21 dd e4				ld hl, scratch 
bb8f			 
bb8f					if DEBUG_FORTH_WORDS 
bb8f						DMARK "MNx" 
bb8f f5				push af  
bb90 3a a4 bb			ld a, (.dmark)  
bb93 32 b7 ee			ld (debug_mark),a  
bb96 3a a5 bb			ld a, (.dmark+1)  
bb99 32 b8 ee			ld (debug_mark+1),a  
bb9c 3a a6 bb			ld a, (.dmark+2)  
bb9f 32 b9 ee			ld (debug_mark+2),a  
bba2 18 03			jr .pastdmark  
bba4 ..			.dmark: db "MNx"  
bba7 f1			.pastdmark: pop af  
bba8			endm  
# End of macro DMARK
bba8						CALLMONITOR 
bba8 cd 62 93			call break_point_state  
bbab				endm  
# End of macro CALLMONITOR
bbab					endif 
bbab			 
bbab			 
bbab			 
bbab 3e 00				ld a, 0 
bbad cd bd 88				call menu 
bbb0			 
bbb0			 
bbb0 6f					ld l, a 
bbb1 26 00				ld h, 0 
bbb3			 
bbb3					if DEBUG_FORTH_WORDS 
bbb3						DMARK "MNr" 
bbb3 f5				push af  
bbb4 3a c8 bb			ld a, (.dmark)  
bbb7 32 b7 ee			ld (debug_mark),a  
bbba 3a c9 bb			ld a, (.dmark+1)  
bbbd 32 b8 ee			ld (debug_mark+1),a  
bbc0 3a ca bb			ld a, (.dmark+2)  
bbc3 32 b9 ee			ld (debug_mark+2),a  
bbc6 18 03			jr .pastdmark  
bbc8 ..			.dmark: db "MNr"  
bbcb f1			.pastdmark: pop af  
bbcc			endm  
# End of macro DMARK
bbcc						CALLMONITOR 
bbcc cd 62 93			call break_point_state  
bbcf				endm  
# End of macro CALLMONITOR
bbcf					endif 
bbcf			 
bbcf cd ef 98				call forth_push_numhl 
bbd2			 
bbd2			 
bbd2			 
bbd2			 
bbd2				       NEXTW 
bbd2 c3 58 9c			jp macro_next 
bbd5				endm 
# End of macro NEXTW
bbd5			 
bbd5			 
bbd5			.ENDDISPLAY: 
bbd5			 
bbd5			; eof 
# End of file forth_words_display.asm
bbd5			include "forth_words_str.asm" 
bbd5			 
bbd5			; | ## String Words 
bbd5			 
bbd5			.PTR:   
bbd5			 
bbd5				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bbd5 48				db WORD_SYS_CORE+52             
bbd6 02 bc			dw .STYPE            
bbd8 04				db 3 + 1 
bbd9 .. 00			db "PTR",0              
bbdd				endm 
# End of macro CWHEAD
bbdd			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bbdd			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bbdd			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bbdd			 
bbdd					if DEBUG_FORTH_WORDS_KEY 
bbdd						DMARK "PTR" 
bbdd f5				push af  
bbde 3a f2 bb			ld a, (.dmark)  
bbe1 32 b7 ee			ld (debug_mark),a  
bbe4 3a f3 bb			ld a, (.dmark+1)  
bbe7 32 b8 ee			ld (debug_mark+1),a  
bbea 3a f4 bb			ld a, (.dmark+2)  
bbed 32 b9 ee			ld (debug_mark+2),a  
bbf0 18 03			jr .pastdmark  
bbf2 ..			.dmark: db "PTR"  
bbf5 f1			.pastdmark: pop af  
bbf6			endm  
# End of macro DMARK
bbf6						CALLMONITOR 
bbf6 cd 62 93			call break_point_state  
bbf9				endm  
# End of macro CALLMONITOR
bbf9					endif 
bbf9					FORTH_DSP_VALUEHL 
bbf9 cd e6 9a			call macro_dsp_valuehl 
bbfc				endm 
# End of macro FORTH_DSP_VALUEHL
bbfc cd ef 98				call forth_push_numhl 
bbff			 
bbff			 
bbff					NEXTW 
bbff c3 58 9c			jp macro_next 
bc02				endm 
# End of macro NEXTW
bc02			.STYPE: 
bc02				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bc02 48				db WORD_SYS_CORE+52             
bc03 51 bc			dw .UPPER            
bc05 06				db 5 + 1 
bc06 .. 00			db "STYPE",0              
bc0c				endm 
# End of macro CWHEAD
bc0c			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bc0c					if DEBUG_FORTH_WORDS_KEY 
bc0c						DMARK "STY" 
bc0c f5				push af  
bc0d 3a 21 bc			ld a, (.dmark)  
bc10 32 b7 ee			ld (debug_mark),a  
bc13 3a 22 bc			ld a, (.dmark+1)  
bc16 32 b8 ee			ld (debug_mark+1),a  
bc19 3a 23 bc			ld a, (.dmark+2)  
bc1c 32 b9 ee			ld (debug_mark+2),a  
bc1f 18 03			jr .pastdmark  
bc21 ..			.dmark: db "STY"  
bc24 f1			.pastdmark: pop af  
bc25			endm  
# End of macro DMARK
bc25						CALLMONITOR 
bc25 cd 62 93			call break_point_state  
bc28				endm  
# End of macro CALLMONITOR
bc28					endif 
bc28					FORTH_DSP 
bc28 cd ac 9a			call macro_forth_dsp 
bc2b				endm 
# End of macro FORTH_DSP
bc2b					;v5 FORTH_DSP_VALUE 
bc2b			 
bc2b 7e					ld a, (hl) 
bc2c			 
bc2c f5					push af 
bc2d			 
bc2d			; Dont destroy TOS		FORTH_DSP_POP 
bc2d			 
bc2d f1					pop af 
bc2e			 
bc2e fe 01				cp DS_TYPE_STR 
bc30 28 09				jr z, .typestr 
bc32			 
bc32 fe 02				cp DS_TYPE_INUM 
bc34 28 0a				jr z, .typeinum 
bc36			 
bc36 21 4f bc				ld hl, .tna 
bc39 18 0a				jr .tpush 
bc3b			 
bc3b 21 4b bc		.typestr:	ld hl, .tstr 
bc3e 18 05				jr .tpush 
bc40 21 4d bc		.typeinum:	ld hl, .tinum 
bc43 18 00				jr .tpush 
bc45			 
bc45			.tpush: 
bc45			 
bc45 cd 5d 99				call forth_push_str 
bc48			 
bc48					NEXTW 
bc48 c3 58 9c			jp macro_next 
bc4b				endm 
# End of macro NEXTW
bc4b .. 00		.tstr:	db "s",0 
bc4d .. 00		.tinum:  db "i",0 
bc4f .. 00		.tna:   db "?", 0 
bc51			 
bc51			 
bc51			.UPPER: 
bc51				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bc51 48				db WORD_SYS_CORE+52             
bc52 8c bc			dw .LOWER            
bc54 06				db 5 + 1 
bc55 .. 00			db "UPPER",0              
bc5b				endm 
# End of macro CWHEAD
bc5b			; | UPPER ( s -- s ) Upper case string s  | DONE 
bc5b					if DEBUG_FORTH_WORDS_KEY 
bc5b						DMARK "UPR" 
bc5b f5				push af  
bc5c 3a 70 bc			ld a, (.dmark)  
bc5f 32 b7 ee			ld (debug_mark),a  
bc62 3a 71 bc			ld a, (.dmark+1)  
bc65 32 b8 ee			ld (debug_mark+1),a  
bc68 3a 72 bc			ld a, (.dmark+2)  
bc6b 32 b9 ee			ld (debug_mark+2),a  
bc6e 18 03			jr .pastdmark  
bc70 ..			.dmark: db "UPR"  
bc73 f1			.pastdmark: pop af  
bc74			endm  
# End of macro DMARK
bc74						CALLMONITOR 
bc74 cd 62 93			call break_point_state  
bc77				endm  
# End of macro CALLMONITOR
bc77					endif 
bc77			 
bc77					FORTH_DSP 
bc77 cd ac 9a			call macro_forth_dsp 
bc7a				endm 
# End of macro FORTH_DSP
bc7a					 
bc7a			; TODO check is string type 
bc7a			 
bc7a					FORTH_DSP_VALUEHL 
bc7a cd e6 9a			call macro_dsp_valuehl 
bc7d				endm 
# End of macro FORTH_DSP_VALUEHL
bc7d			; get pointer to string in hl 
bc7d			 
bc7d 7e			.toup:		ld a, (hl) 
bc7e fe 00				cp 0 
bc80 28 07				jr z, .toupdone 
bc82			 
bc82 cd 26 8e				call to_upper 
bc85			 
bc85 77					ld (hl), a 
bc86 23					inc hl 
bc87 18 f4				jr .toup 
bc89			 
bc89					 
bc89			 
bc89			 
bc89			; for each char convert to upper 
bc89					 
bc89			.toupdone: 
bc89			 
bc89			 
bc89					NEXTW 
bc89 c3 58 9c			jp macro_next 
bc8c				endm 
# End of macro NEXTW
bc8c			.LOWER: 
bc8c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bc8c 48				db WORD_SYS_CORE+52             
bc8d c7 bc			dw .TCASE            
bc8f 06				db 5 + 1 
bc90 .. 00			db "LOWER",0              
bc96				endm 
# End of macro CWHEAD
bc96			; | LOWER ( s -- s ) Lower case string s  | DONE 
bc96					if DEBUG_FORTH_WORDS_KEY 
bc96						DMARK "LWR" 
bc96 f5				push af  
bc97 3a ab bc			ld a, (.dmark)  
bc9a 32 b7 ee			ld (debug_mark),a  
bc9d 3a ac bc			ld a, (.dmark+1)  
bca0 32 b8 ee			ld (debug_mark+1),a  
bca3 3a ad bc			ld a, (.dmark+2)  
bca6 32 b9 ee			ld (debug_mark+2),a  
bca9 18 03			jr .pastdmark  
bcab ..			.dmark: db "LWR"  
bcae f1			.pastdmark: pop af  
bcaf			endm  
# End of macro DMARK
bcaf						CALLMONITOR 
bcaf cd 62 93			call break_point_state  
bcb2				endm  
# End of macro CALLMONITOR
bcb2					endif 
bcb2			 
bcb2					FORTH_DSP 
bcb2 cd ac 9a			call macro_forth_dsp 
bcb5				endm 
# End of macro FORTH_DSP
bcb5					 
bcb5			; TODO check is string type 
bcb5			 
bcb5					FORTH_DSP_VALUEHL 
bcb5 cd e6 9a			call macro_dsp_valuehl 
bcb8				endm 
# End of macro FORTH_DSP_VALUEHL
bcb8			; get pointer to string in hl 
bcb8			 
bcb8 7e			.tolow:		ld a, (hl) 
bcb9 fe 00				cp 0 
bcbb 28 07				jr z, .tolowdone 
bcbd			 
bcbd cd 2f 8e				call to_lower 
bcc0			 
bcc0 77					ld (hl), a 
bcc1 23					inc hl 
bcc2 18 f4				jr .tolow 
bcc4			 
bcc4					 
bcc4			 
bcc4			 
bcc4			; for each char convert to low 
bcc4					 
bcc4			.tolowdone: 
bcc4					NEXTW 
bcc4 c3 58 9c			jp macro_next 
bcc7				endm 
# End of macro NEXTW
bcc7			.TCASE: 
bcc7				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bcc7 48				db WORD_SYS_CORE+52             
bcc8 fd bd			dw .SUBSTR            
bcca 06				db 5 + 1 
bccb .. 00			db "TCASE",0              
bcd1				endm 
# End of macro CWHEAD
bcd1			; | TCASE ( s -- s ) Title case string s  | DONE 
bcd1					if DEBUG_FORTH_WORDS_KEY 
bcd1						DMARK "TCS" 
bcd1 f5				push af  
bcd2 3a e6 bc			ld a, (.dmark)  
bcd5 32 b7 ee			ld (debug_mark),a  
bcd8 3a e7 bc			ld a, (.dmark+1)  
bcdb 32 b8 ee			ld (debug_mark+1),a  
bcde 3a e8 bc			ld a, (.dmark+2)  
bce1 32 b9 ee			ld (debug_mark+2),a  
bce4 18 03			jr .pastdmark  
bce6 ..			.dmark: db "TCS"  
bce9 f1			.pastdmark: pop af  
bcea			endm  
# End of macro DMARK
bcea						CALLMONITOR 
bcea cd 62 93			call break_point_state  
bced				endm  
# End of macro CALLMONITOR
bced					endif 
bced			 
bced					FORTH_DSP 
bced cd ac 9a			call macro_forth_dsp 
bcf0				endm 
# End of macro FORTH_DSP
bcf0					 
bcf0			; TODO check is string type 
bcf0			 
bcf0					FORTH_DSP_VALUEHL 
bcf0 cd e6 9a			call macro_dsp_valuehl 
bcf3				endm 
# End of macro FORTH_DSP_VALUEHL
bcf3			; get pointer to string in hl 
bcf3			 
bcf3					if DEBUG_FORTH_WORDS 
bcf3						DMARK "TC1" 
bcf3 f5				push af  
bcf4 3a 08 bd			ld a, (.dmark)  
bcf7 32 b7 ee			ld (debug_mark),a  
bcfa 3a 09 bd			ld a, (.dmark+1)  
bcfd 32 b8 ee			ld (debug_mark+1),a  
bd00 3a 0a bd			ld a, (.dmark+2)  
bd03 32 b9 ee			ld (debug_mark+2),a  
bd06 18 03			jr .pastdmark  
bd08 ..			.dmark: db "TC1"  
bd0b f1			.pastdmark: pop af  
bd0c			endm  
# End of macro DMARK
bd0c						CALLMONITOR 
bd0c cd 62 93			call break_point_state  
bd0f				endm  
# End of macro CALLMONITOR
bd0f					endif 
bd0f			 
bd0f					; first time in turn to upper case first char 
bd0f			 
bd0f 7e					ld a, (hl) 
bd10 c3 9a bd				jp .totsiptou 
bd13			 
bd13			 
bd13 7e			.tot:		ld a, (hl) 
bd14 fe 00				cp 0 
bd16 ca de bd				jp z, .totdone 
bd19			 
bd19					if DEBUG_FORTH_WORDS 
bd19						DMARK "TC2" 
bd19 f5				push af  
bd1a 3a 2e bd			ld a, (.dmark)  
bd1d 32 b7 ee			ld (debug_mark),a  
bd20 3a 2f bd			ld a, (.dmark+1)  
bd23 32 b8 ee			ld (debug_mark+1),a  
bd26 3a 30 bd			ld a, (.dmark+2)  
bd29 32 b9 ee			ld (debug_mark+2),a  
bd2c 18 03			jr .pastdmark  
bd2e ..			.dmark: db "TC2"  
bd31 f1			.pastdmark: pop af  
bd32			endm  
# End of macro DMARK
bd32						CALLMONITOR 
bd32 cd 62 93			call break_point_state  
bd35				endm  
# End of macro CALLMONITOR
bd35					endif 
bd35					; check to see if current char is a space 
bd35			 
bd35 fe 20				cp ' ' 
bd37 28 21				jr z, .totsp 
bd39 cd 2f 8e				call to_lower 
bd3c					if DEBUG_FORTH_WORDS 
bd3c						DMARK "TC3" 
bd3c f5				push af  
bd3d 3a 51 bd			ld a, (.dmark)  
bd40 32 b7 ee			ld (debug_mark),a  
bd43 3a 52 bd			ld a, (.dmark+1)  
bd46 32 b8 ee			ld (debug_mark+1),a  
bd49 3a 53 bd			ld a, (.dmark+2)  
bd4c 32 b9 ee			ld (debug_mark+2),a  
bd4f 18 03			jr .pastdmark  
bd51 ..			.dmark: db "TC3"  
bd54 f1			.pastdmark: pop af  
bd55			endm  
# End of macro DMARK
bd55						CALLMONITOR 
bd55 cd 62 93			call break_point_state  
bd58				endm  
# End of macro CALLMONITOR
bd58					endif 
bd58 18 63				jr .totnxt 
bd5a			 
bd5a			.totsp:         ; on a space, find next char which should be upper 
bd5a			 
bd5a					if DEBUG_FORTH_WORDS 
bd5a						DMARK "TC4" 
bd5a f5				push af  
bd5b 3a 6f bd			ld a, (.dmark)  
bd5e 32 b7 ee			ld (debug_mark),a  
bd61 3a 70 bd			ld a, (.dmark+1)  
bd64 32 b8 ee			ld (debug_mark+1),a  
bd67 3a 71 bd			ld a, (.dmark+2)  
bd6a 32 b9 ee			ld (debug_mark+2),a  
bd6d 18 03			jr .pastdmark  
bd6f ..			.dmark: db "TC4"  
bd72 f1			.pastdmark: pop af  
bd73			endm  
# End of macro DMARK
bd73						CALLMONITOR 
bd73 cd 62 93			call break_point_state  
bd76				endm  
# End of macro CALLMONITOR
bd76					endif 
bd76					;; 
bd76			 
bd76 fe 20				cp ' ' 
bd78 20 20				jr nz, .totsiptou 
bd7a 23					inc hl 
bd7b 7e					ld a, (hl) 
bd7c					if DEBUG_FORTH_WORDS 
bd7c						DMARK "TC5" 
bd7c f5				push af  
bd7d 3a 91 bd			ld a, (.dmark)  
bd80 32 b7 ee			ld (debug_mark),a  
bd83 3a 92 bd			ld a, (.dmark+1)  
bd86 32 b8 ee			ld (debug_mark+1),a  
bd89 3a 93 bd			ld a, (.dmark+2)  
bd8c 32 b9 ee			ld (debug_mark+2),a  
bd8f 18 03			jr .pastdmark  
bd91 ..			.dmark: db "TC5"  
bd94 f1			.pastdmark: pop af  
bd95			endm  
# End of macro DMARK
bd95						CALLMONITOR 
bd95 cd 62 93			call break_point_state  
bd98				endm  
# End of macro CALLMONITOR
bd98					endif 
bd98 18 c0				jr .totsp 
bd9a fe 00		.totsiptou:    cp 0 
bd9c 28 40				jr z, .totdone 
bd9e					; not space and not zero term so upper case it 
bd9e cd 26 8e				call to_upper 
bda1			 
bda1					if DEBUG_FORTH_WORDS 
bda1						DMARK "TC6" 
bda1 f5				push af  
bda2 3a b6 bd			ld a, (.dmark)  
bda5 32 b7 ee			ld (debug_mark),a  
bda8 3a b7 bd			ld a, (.dmark+1)  
bdab 32 b8 ee			ld (debug_mark+1),a  
bdae 3a b8 bd			ld a, (.dmark+2)  
bdb1 32 b9 ee			ld (debug_mark+2),a  
bdb4 18 03			jr .pastdmark  
bdb6 ..			.dmark: db "TC6"  
bdb9 f1			.pastdmark: pop af  
bdba			endm  
# End of macro DMARK
bdba						CALLMONITOR 
bdba cd 62 93			call break_point_state  
bdbd				endm  
# End of macro CALLMONITOR
bdbd					endif 
bdbd			 
bdbd			 
bdbd			.totnxt: 
bdbd			 
bdbd 77					ld (hl), a 
bdbe 23					inc hl 
bdbf					if DEBUG_FORTH_WORDS 
bdbf						DMARK "TC7" 
bdbf f5				push af  
bdc0 3a d4 bd			ld a, (.dmark)  
bdc3 32 b7 ee			ld (debug_mark),a  
bdc6 3a d5 bd			ld a, (.dmark+1)  
bdc9 32 b8 ee			ld (debug_mark+1),a  
bdcc 3a d6 bd			ld a, (.dmark+2)  
bdcf 32 b9 ee			ld (debug_mark+2),a  
bdd2 18 03			jr .pastdmark  
bdd4 ..			.dmark: db "TC7"  
bdd7 f1			.pastdmark: pop af  
bdd8			endm  
# End of macro DMARK
bdd8						CALLMONITOR 
bdd8 cd 62 93			call break_point_state  
bddb				endm  
# End of macro CALLMONITOR
bddb					endif 
bddb c3 13 bd				jp .tot 
bdde			 
bdde					 
bdde			 
bdde			 
bdde			; for each char convert to low 
bdde					 
bdde			.totdone: 
bdde					if DEBUG_FORTH_WORDS 
bdde						DMARK "TCd" 
bdde f5				push af  
bddf 3a f3 bd			ld a, (.dmark)  
bde2 32 b7 ee			ld (debug_mark),a  
bde5 3a f4 bd			ld a, (.dmark+1)  
bde8 32 b8 ee			ld (debug_mark+1),a  
bdeb 3a f5 bd			ld a, (.dmark+2)  
bdee 32 b9 ee			ld (debug_mark+2),a  
bdf1 18 03			jr .pastdmark  
bdf3 ..			.dmark: db "TCd"  
bdf6 f1			.pastdmark: pop af  
bdf7			endm  
# End of macro DMARK
bdf7						CALLMONITOR 
bdf7 cd 62 93			call break_point_state  
bdfa				endm  
# End of macro CALLMONITOR
bdfa					endif 
bdfa					NEXTW 
bdfa c3 58 9c			jp macro_next 
bdfd				endm 
# End of macro NEXTW
bdfd			 
bdfd			.SUBSTR: 
bdfd				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bdfd 48				db WORD_SYS_CORE+52             
bdfe 5b be			dw .LEFT            
be00 07				db 6 + 1 
be01 .. 00			db "SUBSTR",0              
be08				endm 
# End of macro CWHEAD
be08			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
be08			 
be08					if DEBUG_FORTH_WORDS_KEY 
be08						DMARK "SST" 
be08 f5				push af  
be09 3a 1d be			ld a, (.dmark)  
be0c 32 b7 ee			ld (debug_mark),a  
be0f 3a 1e be			ld a, (.dmark+1)  
be12 32 b8 ee			ld (debug_mark+1),a  
be15 3a 1f be			ld a, (.dmark+2)  
be18 32 b9 ee			ld (debug_mark+2),a  
be1b 18 03			jr .pastdmark  
be1d ..			.dmark: db "SST"  
be20 f1			.pastdmark: pop af  
be21			endm  
# End of macro DMARK
be21						CALLMONITOR 
be21 cd 62 93			call break_point_state  
be24				endm  
# End of macro CALLMONITOR
be24					endif 
be24			; TODO check string type 
be24					FORTH_DSP_VALUEHL 
be24 cd e6 9a			call macro_dsp_valuehl 
be27				endm 
# End of macro FORTH_DSP_VALUEHL
be27			 
be27 e5					push hl      ; string length 
be28			 
be28					FORTH_DSP_POP 
be28 cd 9e 9b			call macro_forth_dsp_pop 
be2b				endm 
# End of macro FORTH_DSP_POP
be2b			 
be2b					FORTH_DSP_VALUEHL 
be2b cd e6 9a			call macro_dsp_valuehl 
be2e				endm 
# End of macro FORTH_DSP_VALUEHL
be2e			 
be2e e5					push hl     ; start char 
be2f			 
be2f					FORTH_DSP_POP 
be2f cd 9e 9b			call macro_forth_dsp_pop 
be32				endm 
# End of macro FORTH_DSP_POP
be32			 
be32			 
be32					FORTH_DSP_VALUE 
be32 cd cf 9a			call macro_forth_dsp_value 
be35				endm 
# End of macro FORTH_DSP_VALUE
be35			 
be35 d1					pop de    ; get start post offset 
be36			 
be36 19					add hl, de    ; starting offset 
be37			 
be37 c1					pop bc 
be38 c5					push bc      ; grab size of string 
be39			 
be39 e5					push hl    ; save string start  
be3a			 
be3a 26 00				ld h, 0 
be3c 69					ld l, c 
be3d 23					inc hl 
be3e 23					inc hl 
be3f			 
be3f cd 80 8f				call malloc 
be42				if DEBUG_FORTH_MALLOC_GUARD 
be42 cc 8a c4				call z,malloc_error 
be45				endif 
be45			 
be45 eb					ex de, hl      ; save malloc area for string copy 
be46 e1					pop hl    ; get back source 
be47 c1					pop bc    ; get length of string back 
be48			 
be48 d5					push de    ; save malloc area for after we push 
be49 ed b0				ldir     ; copy substr 
be4b			 
be4b			 
be4b eb					ex de, hl 
be4c 3e 00				ld a, 0 
be4e 77					ld (hl), a   ; term substr 
be4f			 
be4f					 
be4f e1					pop hl    ; get malloc so we can push it 
be50 e5					push hl   ; save so we can free it afterwards 
be51			 
be51 cd 5d 99				call forth_push_str 
be54			 
be54 e1					pop hl 
be55 cd 4a 90				call free 
be58			 
be58					 
be58					 
be58			 
be58			 
be58					NEXTW 
be58 c3 58 9c			jp macro_next 
be5b				endm 
# End of macro NEXTW
be5b			 
be5b			.LEFT: 
be5b				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
be5b 48				db WORD_SYS_CORE+52             
be5c 83 be			dw .RIGHT            
be5e 05				db 4 + 1 
be5f .. 00			db "LEFT",0              
be64				endm 
# End of macro CWHEAD
be64			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
be64					if DEBUG_FORTH_WORDS_KEY 
be64						DMARK "LEF" 
be64 f5				push af  
be65 3a 79 be			ld a, (.dmark)  
be68 32 b7 ee			ld (debug_mark),a  
be6b 3a 7a be			ld a, (.dmark+1)  
be6e 32 b8 ee			ld (debug_mark+1),a  
be71 3a 7b be			ld a, (.dmark+2)  
be74 32 b9 ee			ld (debug_mark+2),a  
be77 18 03			jr .pastdmark  
be79 ..			.dmark: db "LEF"  
be7c f1			.pastdmark: pop af  
be7d			endm  
# End of macro DMARK
be7d						CALLMONITOR 
be7d cd 62 93			call break_point_state  
be80				endm  
# End of macro CALLMONITOR
be80					endif 
be80			 
be80					NEXTW 
be80 c3 58 9c			jp macro_next 
be83				endm 
# End of macro NEXTW
be83			.RIGHT: 
be83				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
be83 48				db WORD_SYS_CORE+52             
be84 ac be			dw .STR2NUM            
be86 06				db 5 + 1 
be87 .. 00			db "RIGHT",0              
be8d				endm 
# End of macro CWHEAD
be8d			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
be8d					if DEBUG_FORTH_WORDS_KEY 
be8d						DMARK "RIG" 
be8d f5				push af  
be8e 3a a2 be			ld a, (.dmark)  
be91 32 b7 ee			ld (debug_mark),a  
be94 3a a3 be			ld a, (.dmark+1)  
be97 32 b8 ee			ld (debug_mark+1),a  
be9a 3a a4 be			ld a, (.dmark+2)  
be9d 32 b9 ee			ld (debug_mark+2),a  
bea0 18 03			jr .pastdmark  
bea2 ..			.dmark: db "RIG"  
bea5 f1			.pastdmark: pop af  
bea6			endm  
# End of macro DMARK
bea6						CALLMONITOR 
bea6 cd 62 93			call break_point_state  
bea9				endm  
# End of macro CALLMONITOR
bea9					endif 
bea9			 
bea9					NEXTW 
bea9 c3 58 9c			jp macro_next 
beac				endm 
# End of macro NEXTW
beac			 
beac			 
beac			.STR2NUM: 
beac				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
beac 48				db WORD_SYS_CORE+52             
bead 38 bf			dw .NUM2STR            
beaf 08				db 7 + 1 
beb0 .. 00			db "STR2NUM",0              
beb8				endm 
# End of macro CWHEAD
beb8			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
beb8			 
beb8			 
beb8			; TODO STR type check to do 
beb8					if DEBUG_FORTH_WORDS_KEY 
beb8						DMARK "S2N" 
beb8 f5				push af  
beb9 3a cd be			ld a, (.dmark)  
bebc 32 b7 ee			ld (debug_mark),a  
bebf 3a ce be			ld a, (.dmark+1)  
bec2 32 b8 ee			ld (debug_mark+1),a  
bec5 3a cf be			ld a, (.dmark+2)  
bec8 32 b9 ee			ld (debug_mark+2),a  
becb 18 03			jr .pastdmark  
becd ..			.dmark: db "S2N"  
bed0 f1			.pastdmark: pop af  
bed1			endm  
# End of macro DMARK
bed1						CALLMONITOR 
bed1 cd 62 93			call break_point_state  
bed4				endm  
# End of macro CALLMONITOR
bed4					endif 
bed4			 
bed4					;FORTH_DSP 
bed4					FORTH_DSP_VALUE 
bed4 cd cf 9a			call macro_forth_dsp_value 
bed7				endm 
# End of macro FORTH_DSP_VALUE
bed7					;inc hl 
bed7			 
bed7 eb					ex de, hl 
bed8					if DEBUG_FORTH_WORDS 
bed8						DMARK "S2a" 
bed8 f5				push af  
bed9 3a ed be			ld a, (.dmark)  
bedc 32 b7 ee			ld (debug_mark),a  
bedf 3a ee be			ld a, (.dmark+1)  
bee2 32 b8 ee			ld (debug_mark+1),a  
bee5 3a ef be			ld a, (.dmark+2)  
bee8 32 b9 ee			ld (debug_mark+2),a  
beeb 18 03			jr .pastdmark  
beed ..			.dmark: db "S2a"  
bef0 f1			.pastdmark: pop af  
bef1			endm  
# End of macro DMARK
bef1						CALLMONITOR 
bef1 cd 62 93			call break_point_state  
bef4				endm  
# End of macro CALLMONITOR
bef4					endif 
bef4 cd ae 8e				call string_to_uint16 
bef7			 
bef7					if DEBUG_FORTH_WORDS 
bef7						DMARK "S2b" 
bef7 f5				push af  
bef8 3a 0c bf			ld a, (.dmark)  
befb 32 b7 ee			ld (debug_mark),a  
befe 3a 0d bf			ld a, (.dmark+1)  
bf01 32 b8 ee			ld (debug_mark+1),a  
bf04 3a 0e bf			ld a, (.dmark+2)  
bf07 32 b9 ee			ld (debug_mark+2),a  
bf0a 18 03			jr .pastdmark  
bf0c ..			.dmark: db "S2b"  
bf0f f1			.pastdmark: pop af  
bf10			endm  
# End of macro DMARK
bf10						CALLMONITOR 
bf10 cd 62 93			call break_point_state  
bf13				endm  
# End of macro CALLMONITOR
bf13					endif 
bf13			;		push hl 
bf13					FORTH_DSP_POP 
bf13 cd 9e 9b			call macro_forth_dsp_pop 
bf16				endm 
# End of macro FORTH_DSP_POP
bf16			;		pop hl 
bf16					 
bf16					if DEBUG_FORTH_WORDS 
bf16						DMARK "S2b" 
bf16 f5				push af  
bf17 3a 2b bf			ld a, (.dmark)  
bf1a 32 b7 ee			ld (debug_mark),a  
bf1d 3a 2c bf			ld a, (.dmark+1)  
bf20 32 b8 ee			ld (debug_mark+1),a  
bf23 3a 2d bf			ld a, (.dmark+2)  
bf26 32 b9 ee			ld (debug_mark+2),a  
bf29 18 03			jr .pastdmark  
bf2b ..			.dmark: db "S2b"  
bf2e f1			.pastdmark: pop af  
bf2f			endm  
# End of macro DMARK
bf2f						CALLMONITOR 
bf2f cd 62 93			call break_point_state  
bf32				endm  
# End of macro CALLMONITOR
bf32					endif 
bf32 cd ef 98				call forth_push_numhl	 
bf35			 
bf35				 
bf35				       NEXTW 
bf35 c3 58 9c			jp macro_next 
bf38				endm 
# End of macro NEXTW
bf38			.NUM2STR: 
bf38				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
bf38 48				db WORD_SYS_CORE+52             
bf39 47 bf			dw .CONCAT            
bf3b 08				db 7 + 1 
bf3c .. 00			db "NUM2STR",0              
bf44				endm 
# End of macro CWHEAD
bf44			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
bf44			 
bf44			;		; malloc a string to target 
bf44			;		ld hl, 10     ; TODO max string size should be fine 
bf44			;		call malloc 
bf44			;		push hl    ; save malloc location 
bf44			; 
bf44			; 
bf44			;; TODO check int type 
bf44			;		FORTH_DSP_VALUEHL 
bf44			;		ld a, l 
bf44			;		call DispAToASCII   
bf44			;;TODO need to chage above call to dump into string 
bf44			; 
bf44			; 
bf44			 
bf44				       NEXTW 
bf44 c3 58 9c			jp macro_next 
bf47				endm 
# End of macro NEXTW
bf47			 
bf47			.CONCAT: 
bf47				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
bf47 48				db WORD_SYS_CORE+52             
bf48 fa bf			dw .FIND            
bf4a 07				db 6 + 1 
bf4b .. 00			db "CONCAT",0              
bf52				endm 
# End of macro CWHEAD
bf52			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
bf52			 
bf52			; TODO check string type 
bf52			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
bf52			 
bf52					if DEBUG_FORTH_WORDS_KEY 
bf52						DMARK "CON" 
bf52 f5				push af  
bf53 3a 67 bf			ld a, (.dmark)  
bf56 32 b7 ee			ld (debug_mark),a  
bf59 3a 68 bf			ld a, (.dmark+1)  
bf5c 32 b8 ee			ld (debug_mark+1),a  
bf5f 3a 69 bf			ld a, (.dmark+2)  
bf62 32 b9 ee			ld (debug_mark+2),a  
bf65 18 03			jr .pastdmark  
bf67 ..			.dmark: db "CON"  
bf6a f1			.pastdmark: pop af  
bf6b			endm  
# End of macro DMARK
bf6b						CALLMONITOR 
bf6b cd 62 93			call break_point_state  
bf6e				endm  
# End of macro CALLMONITOR
bf6e					endif 
bf6e			 
bf6e			 
bf6e					FORTH_DSP_VALUE 
bf6e cd cf 9a			call macro_forth_dsp_value 
bf71				endm 
# End of macro FORTH_DSP_VALUE
bf71 e5					push hl   ; s2 
bf72			 
bf72					FORTH_DSP_POP 
bf72 cd 9e 9b			call macro_forth_dsp_pop 
bf75				endm 
# End of macro FORTH_DSP_POP
bf75			 
bf75					FORTH_DSP_VALUE 
bf75 cd cf 9a			call macro_forth_dsp_value 
bf78				endm 
# End of macro FORTH_DSP_VALUE
bf78			 
bf78 e5					push hl   ; s1 
bf79			 
bf79					FORTH_DSP_POP 
bf79 cd 9e 9b			call macro_forth_dsp_pop 
bf7c				endm 
# End of macro FORTH_DSP_POP
bf7c					 
bf7c			 
bf7c					; copy s1 
bf7c			 
bf7c				 
bf7c					; save ptr 
bf7c e1					pop hl  
bf7d e5					push hl 
bf7e 3e 00				ld a, 0 
bf80 cd 22 8f				call strlent 
bf83					;inc hl    ; zer0 
bf83 06 00				ld b, 0 
bf85 4d					ld c, l 
bf86 e1					pop hl		 
bf87 11 dd e4				ld de, scratch	 
bf8a					if DEBUG_FORTH_WORDS 
bf8a						DMARK "CO1" 
bf8a f5				push af  
bf8b 3a 9f bf			ld a, (.dmark)  
bf8e 32 b7 ee			ld (debug_mark),a  
bf91 3a a0 bf			ld a, (.dmark+1)  
bf94 32 b8 ee			ld (debug_mark+1),a  
bf97 3a a1 bf			ld a, (.dmark+2)  
bf9a 32 b9 ee			ld (debug_mark+2),a  
bf9d 18 03			jr .pastdmark  
bf9f ..			.dmark: db "CO1"  
bfa2 f1			.pastdmark: pop af  
bfa3			endm  
# End of macro DMARK
bfa3						CALLMONITOR 
bfa3 cd 62 93			call break_point_state  
bfa6				endm  
# End of macro CALLMONITOR
bfa6					endif 
bfa6 ed b0				ldir 
bfa8			 
bfa8 e1					pop hl 
bfa9 e5					push hl 
bfaa d5					push de 
bfab			 
bfab			 
bfab 3e 00				ld a, 0 
bfad cd 22 8f				call strlent 
bfb0 23					inc hl    ; zer0 
bfb1 23					inc hl 
bfb2 06 00				ld b, 0 
bfb4 4d					ld c, l 
bfb5 d1					pop de 
bfb6 e1					pop hl		 
bfb7					if DEBUG_FORTH_WORDS 
bfb7						DMARK "CO2" 
bfb7 f5				push af  
bfb8 3a cc bf			ld a, (.dmark)  
bfbb 32 b7 ee			ld (debug_mark),a  
bfbe 3a cd bf			ld a, (.dmark+1)  
bfc1 32 b8 ee			ld (debug_mark+1),a  
bfc4 3a ce bf			ld a, (.dmark+2)  
bfc7 32 b9 ee			ld (debug_mark+2),a  
bfca 18 03			jr .pastdmark  
bfcc ..			.dmark: db "CO2"  
bfcf f1			.pastdmark: pop af  
bfd0			endm  
# End of macro DMARK
bfd0						CALLMONITOR 
bfd0 cd 62 93			call break_point_state  
bfd3				endm  
# End of macro CALLMONITOR
bfd3					endif 
bfd3 ed b0				ldir 
bfd5			 
bfd5			 
bfd5			 
bfd5 21 dd e4				ld hl, scratch 
bfd8					if DEBUG_FORTH_WORDS 
bfd8						DMARK "CO5" 
bfd8 f5				push af  
bfd9 3a ed bf			ld a, (.dmark)  
bfdc 32 b7 ee			ld (debug_mark),a  
bfdf 3a ee bf			ld a, (.dmark+1)  
bfe2 32 b8 ee			ld (debug_mark+1),a  
bfe5 3a ef bf			ld a, (.dmark+2)  
bfe8 32 b9 ee			ld (debug_mark+2),a  
bfeb 18 03			jr .pastdmark  
bfed ..			.dmark: db "CO5"  
bff0 f1			.pastdmark: pop af  
bff1			endm  
# End of macro DMARK
bff1						CALLMONITOR 
bff1 cd 62 93			call break_point_state  
bff4				endm  
# End of macro CALLMONITOR
bff4					endif 
bff4			 
bff4 cd 5d 99				call forth_push_str 
bff7			 
bff7			 
bff7			 
bff7			 
bff7				       NEXTW 
bff7 c3 58 9c			jp macro_next 
bffa				endm 
# End of macro NEXTW
bffa			 
bffa			 
bffa			.FIND: 
bffa				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
bffa 4b				db WORD_SYS_CORE+55             
bffb b8 c0			dw .LEN            
bffd 05				db 4 + 1 
bffe .. 00			db "FIND",0              
c003				endm 
# End of macro CWHEAD
c003			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c003			 
c003					if DEBUG_FORTH_WORDS_KEY 
c003						DMARK "FND" 
c003 f5				push af  
c004 3a 18 c0			ld a, (.dmark)  
c007 32 b7 ee			ld (debug_mark),a  
c00a 3a 19 c0			ld a, (.dmark+1)  
c00d 32 b8 ee			ld (debug_mark+1),a  
c010 3a 1a c0			ld a, (.dmark+2)  
c013 32 b9 ee			ld (debug_mark+2),a  
c016 18 03			jr .pastdmark  
c018 ..			.dmark: db "FND"  
c01b f1			.pastdmark: pop af  
c01c			endm  
# End of macro DMARK
c01c						CALLMONITOR 
c01c cd 62 93			call break_point_state  
c01f				endm  
# End of macro CALLMONITOR
c01f					endif 
c01f			 
c01f			; TODO check string type 
c01f					FORTH_DSP_VALUE 
c01f cd cf 9a			call macro_forth_dsp_value 
c022				endm 
# End of macro FORTH_DSP_VALUE
c022			 
c022 e5					push hl    
c023 7e					ld a,(hl)    ; char to find   
c024			; TODO change char to substr 
c024			 
c024 f5					push af 
c025					 
c025			 
c025			 
c025					if DEBUG_FORTH_WORDS 
c025						DMARK "FN1" 
c025 f5				push af  
c026 3a 3a c0			ld a, (.dmark)  
c029 32 b7 ee			ld (debug_mark),a  
c02c 3a 3b c0			ld a, (.dmark+1)  
c02f 32 b8 ee			ld (debug_mark+1),a  
c032 3a 3c c0			ld a, (.dmark+2)  
c035 32 b9 ee			ld (debug_mark+2),a  
c038 18 03			jr .pastdmark  
c03a ..			.dmark: db "FN1"  
c03d f1			.pastdmark: pop af  
c03e			endm  
# End of macro DMARK
c03e						CALLMONITOR 
c03e cd 62 93			call break_point_state  
c041				endm  
# End of macro CALLMONITOR
c041					endif 
c041			 
c041					FORTH_DSP_POP 
c041 cd 9e 9b			call macro_forth_dsp_pop 
c044				endm 
# End of macro FORTH_DSP_POP
c044			 
c044					; string to search 
c044			 
c044					FORTH_DSP_VALUE 
c044 cd cf 9a			call macro_forth_dsp_value 
c047				endm 
# End of macro FORTH_DSP_VALUE
c047			 
c047 d1					pop de  ; d is char to find  
c048			 
c048					if DEBUG_FORTH_WORDS 
c048						DMARK "FN2" 
c048 f5				push af  
c049 3a 5d c0			ld a, (.dmark)  
c04c 32 b7 ee			ld (debug_mark),a  
c04f 3a 5e c0			ld a, (.dmark+1)  
c052 32 b8 ee			ld (debug_mark+1),a  
c055 3a 5f c0			ld a, (.dmark+2)  
c058 32 b9 ee			ld (debug_mark+2),a  
c05b 18 03			jr .pastdmark  
c05d ..			.dmark: db "FN2"  
c060 f1			.pastdmark: pop af  
c061			endm  
# End of macro DMARK
c061						CALLMONITOR 
c061 cd 62 93			call break_point_state  
c064				endm  
# End of macro CALLMONITOR
c064					endif 
c064					 
c064 01 00 00				ld bc, 0 
c067 7e			.findchar:      ld a,(hl) 
c068 fe 00				cp 0   		 
c06a 28 27				jr z, .finddone     
c06c ba					cp d 
c06d 28 20				jr z, .foundchar 
c06f 03					inc bc 
c070 23					inc hl 
c071					if DEBUG_FORTH_WORDS 
c071						DMARK "FN3" 
c071 f5				push af  
c072 3a 86 c0			ld a, (.dmark)  
c075 32 b7 ee			ld (debug_mark),a  
c078 3a 87 c0			ld a, (.dmark+1)  
c07b 32 b8 ee			ld (debug_mark+1),a  
c07e 3a 88 c0			ld a, (.dmark+2)  
c081 32 b9 ee			ld (debug_mark+2),a  
c084 18 03			jr .pastdmark  
c086 ..			.dmark: db "FN3"  
c089 f1			.pastdmark: pop af  
c08a			endm  
# End of macro DMARK
c08a						CALLMONITOR 
c08a cd 62 93			call break_point_state  
c08d				endm  
# End of macro CALLMONITOR
c08d					endif 
c08d 18 d8				jr .findchar 
c08f			 
c08f			 
c08f c5			.foundchar:	push bc 
c090 e1					pop hl 
c091 18 03				jr .findexit 
c093			 
c093			 
c093							 
c093			 
c093			.finddone:     ; got to end of string with no find 
c093 21 00 00				ld hl, 0 
c096			.findexit: 
c096			 
c096					if DEBUG_FORTH_WORDS 
c096						DMARK "FNd" 
c096 f5				push af  
c097 3a ab c0			ld a, (.dmark)  
c09a 32 b7 ee			ld (debug_mark),a  
c09d 3a ac c0			ld a, (.dmark+1)  
c0a0 32 b8 ee			ld (debug_mark+1),a  
c0a3 3a ad c0			ld a, (.dmark+2)  
c0a6 32 b9 ee			ld (debug_mark+2),a  
c0a9 18 03			jr .pastdmark  
c0ab ..			.dmark: db "FNd"  
c0ae f1			.pastdmark: pop af  
c0af			endm  
# End of macro DMARK
c0af						CALLMONITOR 
c0af cd 62 93			call break_point_state  
c0b2				endm  
# End of macro CALLMONITOR
c0b2					endif 
c0b2 cd ef 98			call forth_push_numhl 
c0b5			 
c0b5				       NEXTW 
c0b5 c3 58 9c			jp macro_next 
c0b8				endm 
# End of macro NEXTW
c0b8			 
c0b8			.LEN: 
c0b8				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c0b8 4c				db WORD_SYS_CORE+56             
c0b9 ed c0			dw .CHAR            
c0bb 06				db 5 + 1 
c0bc .. 00			db "COUNT",0              
c0c2				endm 
# End of macro CWHEAD
c0c2			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c0c2			 
c0c2					if DEBUG_FORTH_WORDS_KEY 
c0c2						DMARK "CNT" 
c0c2 f5				push af  
c0c3 3a d7 c0			ld a, (.dmark)  
c0c6 32 b7 ee			ld (debug_mark),a  
c0c9 3a d8 c0			ld a, (.dmark+1)  
c0cc 32 b8 ee			ld (debug_mark+1),a  
c0cf 3a d9 c0			ld a, (.dmark+2)  
c0d2 32 b9 ee			ld (debug_mark+2),a  
c0d5 18 03			jr .pastdmark  
c0d7 ..			.dmark: db "CNT"  
c0da f1			.pastdmark: pop af  
c0db			endm  
# End of macro DMARK
c0db						CALLMONITOR 
c0db cd 62 93			call break_point_state  
c0de				endm  
# End of macro CALLMONITOR
c0de					endif 
c0de			; TODO check string type 
c0de					FORTH_DSP 
c0de cd ac 9a			call macro_forth_dsp 
c0e1				endm 
# End of macro FORTH_DSP
c0e1					;v5FORTH_DSP_VALUE 
c0e1			 
c0e1 23					inc hl 
c0e2			 
c0e2 3e 00				ld a, 0 
c0e4 cd 22 8f				call strlent 
c0e7			 
c0e7 cd ef 98				call forth_push_numhl 
c0ea			 
c0ea			 
c0ea			 
c0ea				       NEXTW 
c0ea c3 58 9c			jp macro_next 
c0ed				endm 
# End of macro NEXTW
c0ed			.CHAR: 
c0ed				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c0ed 4d				db WORD_SYS_CORE+57             
c0ee 23 c1			dw .ENDSTR            
c0f0 05				db 4 + 1 
c0f1 .. 00			db "CHAR",0              
c0f6				endm 
# End of macro CWHEAD
c0f6			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c0f6					if DEBUG_FORTH_WORDS_KEY 
c0f6						DMARK "CHR" 
c0f6 f5				push af  
c0f7 3a 0b c1			ld a, (.dmark)  
c0fa 32 b7 ee			ld (debug_mark),a  
c0fd 3a 0c c1			ld a, (.dmark+1)  
c100 32 b8 ee			ld (debug_mark+1),a  
c103 3a 0d c1			ld a, (.dmark+2)  
c106 32 b9 ee			ld (debug_mark+2),a  
c109 18 03			jr .pastdmark  
c10b ..			.dmark: db "CHR"  
c10e f1			.pastdmark: pop af  
c10f			endm  
# End of macro DMARK
c10f						CALLMONITOR 
c10f cd 62 93			call break_point_state  
c112				endm  
# End of macro CALLMONITOR
c112					endif 
c112					FORTH_DSP 
c112 cd ac 9a			call macro_forth_dsp 
c115				endm 
# End of macro FORTH_DSP
c115					;v5 FORTH_DSP_VALUE 
c115 23					inc hl      ; now at start of numeric as string 
c116			 
c116			;		push hl 
c116			 
c116					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c116 cd 9e 9b			call macro_forth_dsp_pop 
c119				endm 
# End of macro FORTH_DSP_POP
c119			 
c119			;		pop hl 
c119			 
c119					; push the content of a onto the stack as a value 
c119			 
c119 7e					ld a,(hl)   ; get char 
c11a 26 00				ld h,0 
c11c 6f					ld l,a 
c11d cd ef 98				call forth_push_numhl 
c120			 
c120				       NEXTW 
c120 c3 58 9c			jp macro_next 
c123				endm 
# End of macro NEXTW
c123			 
c123			 
c123			 
c123			 
c123			.ENDSTR: 
c123			; eof 
c123			 
# End of file forth_words_str.asm
c123			include "forth_words_key.asm" 
c123			 
c123			; | ## Keyboard Words 
c123			 
c123			.KEY: 
c123				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c123 3e				db WORD_SYS_CORE+42             
c124 53 c1			dw .WAITK            
c126 04				db 3 + 1 
c127 .. 00			db "KEY",0              
c12b				endm 
# End of macro CWHEAD
c12b			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c12b			 
c12b					if DEBUG_FORTH_WORDS_KEY 
c12b						DMARK "KEY" 
c12b f5				push af  
c12c 3a 40 c1			ld a, (.dmark)  
c12f 32 b7 ee			ld (debug_mark),a  
c132 3a 41 c1			ld a, (.dmark+1)  
c135 32 b8 ee			ld (debug_mark+1),a  
c138 3a 42 c1			ld a, (.dmark+2)  
c13b 32 b9 ee			ld (debug_mark+2),a  
c13e 18 03			jr .pastdmark  
c140 ..			.dmark: db "KEY"  
c143 f1			.pastdmark: pop af  
c144			endm  
# End of macro DMARK
c144						CALLMONITOR 
c144 cd 62 93			call break_point_state  
c147				endm  
# End of macro CALLMONITOR
c147					endif 
c147			; TODO currently waits 
c147 cd c6 d7				call cin 
c14a					;call cin_wait 
c14a 6f					ld l, a 
c14b 26 00				ld h, 0 
c14d cd ef 98				call forth_push_numhl 
c150					NEXTW 
c150 c3 58 9c			jp macro_next 
c153				endm 
# End of macro NEXTW
c153			.WAITK: 
c153				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c153 3f				db WORD_SYS_CORE+43             
c154 85 c1			dw .ACCEPT            
c156 06				db 5 + 1 
c157 .. 00			db "WAITK",0              
c15d				endm 
# End of macro CWHEAD
c15d			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c15d					if DEBUG_FORTH_WORDS_KEY 
c15d						DMARK "WAI" 
c15d f5				push af  
c15e 3a 72 c1			ld a, (.dmark)  
c161 32 b7 ee			ld (debug_mark),a  
c164 3a 73 c1			ld a, (.dmark+1)  
c167 32 b8 ee			ld (debug_mark+1),a  
c16a 3a 74 c1			ld a, (.dmark+2)  
c16d 32 b9 ee			ld (debug_mark+2),a  
c170 18 03			jr .pastdmark  
c172 ..			.dmark: db "WAI"  
c175 f1			.pastdmark: pop af  
c176			endm  
# End of macro DMARK
c176						CALLMONITOR 
c176 cd 62 93			call break_point_state  
c179				endm  
# End of macro CALLMONITOR
c179					endif 
c179 cd c0 d7				call cin_wait 
c17c 6f					ld l, a 
c17d 26 00				ld h, 0 
c17f cd ef 98				call forth_push_numhl 
c182					NEXTW 
c182 c3 58 9c			jp macro_next 
c185				endm 
# End of macro NEXTW
c185			.ACCEPT: 
c185				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c185 40				db WORD_SYS_CORE+44             
c186 e3 c1			dw .EDIT            
c188 07				db 6 + 1 
c189 .. 00			db "ACCEPT",0              
c190				endm 
# End of macro CWHEAD
c190			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c190					; TODO crashes on push 
c190					if DEBUG_FORTH_WORDS_KEY 
c190						DMARK "ACC" 
c190 f5				push af  
c191 3a a5 c1			ld a, (.dmark)  
c194 32 b7 ee			ld (debug_mark),a  
c197 3a a6 c1			ld a, (.dmark+1)  
c19a 32 b8 ee			ld (debug_mark+1),a  
c19d 3a a7 c1			ld a, (.dmark+2)  
c1a0 32 b9 ee			ld (debug_mark+2),a  
c1a3 18 03			jr .pastdmark  
c1a5 ..			.dmark: db "ACC"  
c1a8 f1			.pastdmark: pop af  
c1a9			endm  
# End of macro DMARK
c1a9						CALLMONITOR 
c1a9 cd 62 93			call break_point_state  
c1ac				endm  
# End of macro CALLMONITOR
c1ac					endif 
c1ac 21 db e6				ld hl, os_input 
c1af 3e 00				ld a, 0 
c1b1 77					ld (hl),a 
c1b2 3a c6 ec				ld a,(f_cursor_ptr) 
c1b5 16 64				ld d, 100 
c1b7 0e 00				ld c, 0 
c1b9 1e 28				ld e, 40 
c1bb cd e6 8a				call input_str 
c1be					; TODO perhaps do a type check and wrap in quotes if not a number 
c1be 21 db e6				ld hl, os_input 
c1c1					if DEBUG_FORTH_WORDS 
c1c1						DMARK "AC1" 
c1c1 f5				push af  
c1c2 3a d6 c1			ld a, (.dmark)  
c1c5 32 b7 ee			ld (debug_mark),a  
c1c8 3a d7 c1			ld a, (.dmark+1)  
c1cb 32 b8 ee			ld (debug_mark+1),a  
c1ce 3a d8 c1			ld a, (.dmark+2)  
c1d1 32 b9 ee			ld (debug_mark+2),a  
c1d4 18 03			jr .pastdmark  
c1d6 ..			.dmark: db "AC1"  
c1d9 f1			.pastdmark: pop af  
c1da			endm  
# End of macro DMARK
c1da						CALLMONITOR 
c1da cd 62 93			call break_point_state  
c1dd				endm  
# End of macro CALLMONITOR
c1dd					endif 
c1dd cd 5d 99				call forth_push_str 
c1e0					NEXTW 
c1e0 c3 58 9c			jp macro_next 
c1e3				endm 
# End of macro NEXTW
c1e3			 
c1e3			.EDIT: 
c1e3				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c1e3 40				db WORD_SYS_CORE+44             
c1e4 85 c2			dw .ENDKEY            
c1e6 05				db 4 + 1 
c1e7 .. 00			db "EDIT",0              
c1ec				endm 
# End of macro CWHEAD
c1ec			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c1ec			 
c1ec					; TODO does not copy from stack 
c1ec					if DEBUG_FORTH_WORDS_KEY 
c1ec						DMARK "EDT" 
c1ec f5				push af  
c1ed 3a 01 c2			ld a, (.dmark)  
c1f0 32 b7 ee			ld (debug_mark),a  
c1f3 3a 02 c2			ld a, (.dmark+1)  
c1f6 32 b8 ee			ld (debug_mark+1),a  
c1f9 3a 03 c2			ld a, (.dmark+2)  
c1fc 32 b9 ee			ld (debug_mark+2),a  
c1ff 18 03			jr .pastdmark  
c201 ..			.dmark: db "EDT"  
c204 f1			.pastdmark: pop af  
c205			endm  
# End of macro DMARK
c205						CALLMONITOR 
c205 cd 62 93			call break_point_state  
c208				endm  
# End of macro CALLMONITOR
c208					endif 
c208			 
c208					;FORTH_DSP 
c208					FORTH_DSP_VALUEHL 
c208 cd e6 9a			call macro_dsp_valuehl 
c20b				endm 
# End of macro FORTH_DSP_VALUEHL
c20b			;		inc hl    ; TODO do type check 
c20b			 
c20b			;		call get_word_hl 
c20b e5					push hl 
c20c					if DEBUG_FORTH_WORDS 
c20c						DMARK "EDp" 
c20c f5				push af  
c20d 3a 21 c2			ld a, (.dmark)  
c210 32 b7 ee			ld (debug_mark),a  
c213 3a 22 c2			ld a, (.dmark+1)  
c216 32 b8 ee			ld (debug_mark+1),a  
c219 3a 23 c2			ld a, (.dmark+2)  
c21c 32 b9 ee			ld (debug_mark+2),a  
c21f 18 03			jr .pastdmark  
c221 ..			.dmark: db "EDp"  
c224 f1			.pastdmark: pop af  
c225			endm  
# End of macro DMARK
c225						CALLMONITOR 
c225 cd 62 93			call break_point_state  
c228				endm  
# End of macro CALLMONITOR
c228					endif 
c228				;	ld a, 0 
c228 cd 17 8f				call strlenz 
c22b 23					inc hl 
c22c			 
c22c 06 00				ld b, 0 
c22e 4d					ld c, l 
c22f			 
c22f e1					pop hl 
c230 11 db e6				ld de, os_input 
c233					if DEBUG_FORTH_WORDS_KEY 
c233						DMARK "EDc" 
c233 f5				push af  
c234 3a 48 c2			ld a, (.dmark)  
c237 32 b7 ee			ld (debug_mark),a  
c23a 3a 49 c2			ld a, (.dmark+1)  
c23d 32 b8 ee			ld (debug_mark+1),a  
c240 3a 4a c2			ld a, (.dmark+2)  
c243 32 b9 ee			ld (debug_mark+2),a  
c246 18 03			jr .pastdmark  
c248 ..			.dmark: db "EDc"  
c24b f1			.pastdmark: pop af  
c24c			endm  
# End of macro DMARK
c24c						CALLMONITOR 
c24c cd 62 93			call break_point_state  
c24f				endm  
# End of macro CALLMONITOR
c24f					endif 
c24f ed b0				ldir 
c251			 
c251			 
c251 21 db e6				ld hl, os_input 
c254					;ld a, 0 
c254					;ld (hl),a 
c254 3a c6 ec				ld a,(f_cursor_ptr) 
c257 16 64				ld d, 100 
c259 0e 00				ld c, 0 
c25b 1e 28				ld e, 40 
c25d cd e6 8a				call input_str 
c260					; TODO perhaps do a type check and wrap in quotes if not a number 
c260 21 db e6				ld hl, os_input 
c263					if DEBUG_FORTH_WORDS 
c263						DMARK "ED1" 
c263 f5				push af  
c264 3a 78 c2			ld a, (.dmark)  
c267 32 b7 ee			ld (debug_mark),a  
c26a 3a 79 c2			ld a, (.dmark+1)  
c26d 32 b8 ee			ld (debug_mark+1),a  
c270 3a 7a c2			ld a, (.dmark+2)  
c273 32 b9 ee			ld (debug_mark+2),a  
c276 18 03			jr .pastdmark  
c278 ..			.dmark: db "ED1"  
c27b f1			.pastdmark: pop af  
c27c			endm  
# End of macro DMARK
c27c						CALLMONITOR 
c27c cd 62 93			call break_point_state  
c27f				endm  
# End of macro CALLMONITOR
c27f					endif 
c27f cd 5d 99				call forth_push_str 
c282					NEXTW 
c282 c3 58 9c			jp macro_next 
c285				endm 
# End of macro NEXTW
c285			 
c285			 
c285			 
c285			.ENDKEY: 
c285			; eof 
c285			 
# End of file forth_words_key.asm
c285			 
c285			if STORAGE_SE 
c285			   	include "forth_words_storage.asm" 
c285			endif 
c285				include "forth_words_device.asm" 
c285			; Device related words 
c285			 
c285			; | ## Device Words 
c285			 
c285			if SOUND_ENABLE 
c285			.NOTE: 
c285				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c285			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c285					if DEBUG_FORTH_WORDS_KEY 
c285						DMARK "NTE" 
c285						CALLMONITOR 
c285					endif 
c285			 
c285				 
c285			 
c285					NEXTW 
c285			.AFTERSOUND: 
c285			endif 
c285			 
c285			 
c285			USE_GPIO: equ 0 
c285			 
c285			if USE_GPIO 
c285			.GP1: 
c285				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c285			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c285					NEXTW 
c285			.GP2: 
c285				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c285			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c285			 
c285					NEXTW 
c285			 
c285			.GP3: 
c285				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c285			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c285			 
c285					NEXTW 
c285			 
c285			.GP4: 
c285				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c285			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c285			 
c285					NEXTW 
c285			.SIN: 
c285			 
c285			 
c285			endif 
c285			 
c285			 
c285				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c285 33				db WORD_SYS_CORE+31             
c286 ba c2			dw .SOUT            
c288 03				db 2 + 1 
c289 .. 00			db "IN",0              
c28c				endm 
# End of macro CWHEAD
c28c			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c28c					if DEBUG_FORTH_WORDS_KEY 
c28c						DMARK "IN." 
c28c f5				push af  
c28d 3a a1 c2			ld a, (.dmark)  
c290 32 b7 ee			ld (debug_mark),a  
c293 3a a2 c2			ld a, (.dmark+1)  
c296 32 b8 ee			ld (debug_mark+1),a  
c299 3a a3 c2			ld a, (.dmark+2)  
c29c 32 b9 ee			ld (debug_mark+2),a  
c29f 18 03			jr .pastdmark  
c2a1 ..			.dmark: db "IN."  
c2a4 f1			.pastdmark: pop af  
c2a5			endm  
# End of macro DMARK
c2a5						CALLMONITOR 
c2a5 cd 62 93			call break_point_state  
c2a8				endm  
# End of macro CALLMONITOR
c2a8					endif 
c2a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2a8 cd e6 9a			call macro_dsp_valuehl 
c2ab				endm 
# End of macro FORTH_DSP_VALUEHL
c2ab			 
c2ab e5					push hl 
c2ac			 
c2ac					; destroy value TOS 
c2ac			 
c2ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2ac cd 9e 9b			call macro_forth_dsp_pop 
c2af				endm 
# End of macro FORTH_DSP_POP
c2af			 
c2af					; one value on hl get other one back 
c2af			 
c2af c1					pop bc 
c2b0			 
c2b0					; do the sub 
c2b0			;		ex de, hl 
c2b0			 
c2b0 ed 68				in l,(c) 
c2b2			 
c2b2					; save it 
c2b2			 
c2b2 26 00				ld h,0 
c2b4			 
c2b4					; TODO push value back onto stack for another op etc 
c2b4			 
c2b4 cd ef 98				call forth_push_numhl 
c2b7					NEXTW 
c2b7 c3 58 9c			jp macro_next 
c2ba				endm 
# End of macro NEXTW
c2ba			.SOUT: 
c2ba				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c2ba 34				db WORD_SYS_CORE+32             
c2bb 0d c3			dw .SPIO            
c2bd 04				db 3 + 1 
c2be .. 00			db "OUT",0              
c2c2				endm 
# End of macro CWHEAD
c2c2			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c2c2					if DEBUG_FORTH_WORDS_KEY 
c2c2						DMARK "OUT" 
c2c2 f5				push af  
c2c3 3a d7 c2			ld a, (.dmark)  
c2c6 32 b7 ee			ld (debug_mark),a  
c2c9 3a d8 c2			ld a, (.dmark+1)  
c2cc 32 b8 ee			ld (debug_mark+1),a  
c2cf 3a d9 c2			ld a, (.dmark+2)  
c2d2 32 b9 ee			ld (debug_mark+2),a  
c2d5 18 03			jr .pastdmark  
c2d7 ..			.dmark: db "OUT"  
c2da f1			.pastdmark: pop af  
c2db			endm  
# End of macro DMARK
c2db						CALLMONITOR 
c2db cd 62 93			call break_point_state  
c2de				endm  
# End of macro CALLMONITOR
c2de					endif 
c2de			 
c2de					; get port 
c2de			 
c2de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2de cd e6 9a			call macro_dsp_valuehl 
c2e1				endm 
# End of macro FORTH_DSP_VALUEHL
c2e1			 
c2e1 e5					push hl 
c2e2			 
c2e2					; destroy value TOS 
c2e2			 
c2e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2e2 cd 9e 9b			call macro_forth_dsp_pop 
c2e5				endm 
# End of macro FORTH_DSP_POP
c2e5			 
c2e5					; get byte to send 
c2e5			 
c2e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2e5 cd e6 9a			call macro_dsp_valuehl 
c2e8				endm 
# End of macro FORTH_DSP_VALUEHL
c2e8			 
c2e8			;		push hl 
c2e8			 
c2e8					; destroy value TOS 
c2e8			 
c2e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2e8 cd 9e 9b			call macro_forth_dsp_pop 
c2eb				endm 
# End of macro FORTH_DSP_POP
c2eb			 
c2eb					; one value on hl get other one back 
c2eb			 
c2eb			;		pop hl 
c2eb			 
c2eb c1					pop bc 
c2ec			 
c2ec					if DEBUG_FORTH_WORDS 
c2ec						DMARK "OUT" 
c2ec f5				push af  
c2ed 3a 01 c3			ld a, (.dmark)  
c2f0 32 b7 ee			ld (debug_mark),a  
c2f3 3a 02 c3			ld a, (.dmark+1)  
c2f6 32 b8 ee			ld (debug_mark+1),a  
c2f9 3a 03 c3			ld a, (.dmark+2)  
c2fc 32 b9 ee			ld (debug_mark+2),a  
c2ff 18 03			jr .pastdmark  
c301 ..			.dmark: db "OUT"  
c304 f1			.pastdmark: pop af  
c305			endm  
# End of macro DMARK
c305						CALLMONITOR 
c305 cd 62 93			call break_point_state  
c308				endm  
# End of macro CALLMONITOR
c308					endif 
c308			 
c308 ed 69				out (c), l 
c30a			 
c30a					NEXTW 
c30a c3 58 9c			jp macro_next 
c30d				endm 
# End of macro NEXTW
c30d			 
c30d			 
c30d			.SPIO: 
c30d			 
c30d			if STORAGE_SE 
c30d				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c30d			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c30d			 
c30d					call spi_ce_low 
c30d			    NEXTW 
c30d			 
c30d			.SPICEH: 
c30d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c30d			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c30d			 
c30d					call spi_ce_high 
c30d			    NEXTW 
c30d			 
c30d			 
c30d			.SPIOb: 
c30d			 
c30d				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c30d			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c30d			 
c30d					; get port 
c30d			 
c30d			 
c30d					; get byte to send 
c30d			 
c30d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c30d			 
c30d			;		push hl    ; u1  
c30d			 
c30d					; destroy value TOS 
c30d			 
c30d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c30d			 
c30d					; one value on hl get other one back 
c30d			 
c30d			;		pop hl   ; u2 - addr 
c30d			 
c30d					; TODO Send SPI byte 
c30d			 
c30d					ld a, l 
c30d					call spi_send_byte 
c30d			 
c30d					NEXTW 
c30d			 
c30d			.SPII: 
c30d				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c30d			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c30d			 
c30d					; TODO Get SPI byte 
c30d			 
c30d					call spi_read_byte 
c30d			 
c30d					ld h, 0 
c30d					ld l, a 
c30d					call forth_push_numhl 
c30d			 
c30d					NEXTW 
c30d			 
c30d			 
c30d			 
c30d			.SESEL: 
c30d				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c30d			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c30d					if DEBUG_FORTH_WORDS_KEY 
c30d						DMARK "BNK" 
c30d						CALLMONITOR 
c30d					endif 
c30d			 
c30d					ld a, 255 
c30d					ld (spi_cartdev), a 
c30d			 
c30d					; get bank 
c30d			 
c30d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c30d			 
c30d			;		push hl 
c30d			 
c30d					; destroy value TOS 
c30d			 
c30d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c30d			 
c30d					; one value on hl get other one back 
c30d			 
c30d			;		pop hl 
c30d			 
c30d			 
c30d					ld c, SPI_CE_HIGH 
c30d					ld b, '0'    ; human readable bank number 
c30d			 
c30d					ld a, l 
c30d			 
c30d					if DEBUG_FORTH_WORDS 
c30d						DMARK "BNK" 
c30d						CALLMONITOR 
c30d					endif 
c30d			 
c30d					; active low 
c30d			 
c30d					cp 0 
c30d					jr z, .bset 
c30d					cp 1 
c30d					jr nz, .b2 
c30d					res 0, c 
c30d					ld b, '1'    ; human readable bank number 
c30d			.b2:		cp 2 
c30d					jr nz, .b3 
c30d					res 1, c 
c30d					ld b, '2'    ; human readable bank number 
c30d			.b3:		cp 3 
c30d					jr nz, .b4 
c30d					res 2, c 
c30d					ld b, '3'    ; human readable bank number 
c30d			.b4:		cp 4 
c30d					jr nz, .b5 
c30d					res 3, c 
c30d					ld b, '4'    ; human readable bank number 
c30d			.b5:		cp 5 
c30d					jr nz, .bset 
c30d					res 4, c 
c30d					ld b, '5'    ; human readable bank number 
c30d			 
c30d			.bset: 
c30d					ld a, c 
c30d					ld (spi_device),a 
c30d					ld a, b 
c30d					ld (spi_device_id),a 
c30d					if DEBUG_FORTH_WORDS 
c30d						DMARK "BN2" 
c30d						CALLMONITOR 
c30d					endif 
c30d			 
c30d					NEXTW 
c30d			 
c30d			.CARTDEV: 
c30d				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c30d			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c30d					if DEBUG_FORTH_WORDS_KEY 
c30d						DMARK "CDV" 
c30d						CALLMONITOR 
c30d					endif 
c30d			 
c30d					; disable se storage bank selection 
c30d			 
c30d					ld a, SPI_CE_HIGH		; ce high 
c30d					ld (spi_device), a 
c30d			 
c30d					; get bank 
c30d			 
c30d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c30d			 
c30d			;		push hl 
c30d			 
c30d					; destroy value TOS 
c30d			 
c30d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c30d			 
c30d					; one value on hl get other one back 
c30d			 
c30d			;		pop hl 
c30d			 
c30d					; active low 
c30d			 
c30d					ld c, 255 
c30d			 
c30d					ld a, l 
c30d					if DEBUG_FORTH_WORDS 
c30d						DMARK "CDV" 
c30d						CALLMONITOR 
c30d					endif 
c30d					cp 0 
c30d					jr z, .cset 
c30d					cp 1 
c30d					jr nz, .c2 
c30d					res 0, c 
c30d			.c2:		cp 2 
c30d					jr nz, .c3 
c30d					res 1, c 
c30d			.c3:		cp 3 
c30d					jr nz, .c4 
c30d					res 2, c 
c30d			.c4:		cp 4 
c30d					jr nz, .c5 
c30d					res 3, c 
c30d			.c5:		cp 5 
c30d					jr nz, .c6 
c30d					res 4, c 
c30d			.c6:		cp 6 
c30d					jr nz, .c7 
c30d					res 5, c 
c30d			.c7:		cp 7 
c30d					jr nz, .c8 
c30d					res 6, c 
c30d			.c8:		cp 8 
c30d					jr nz, .cset 
c30d					res 7, c 
c30d			.cset:		ld a, c 
c30d					ld (spi_cartdev),a 
c30d			 
c30d					if DEBUG_FORTH_WORDS 
c30d						DMARK "CD2" 
c30d						CALLMONITOR 
c30d					endif 
c30d					NEXTW 
c30d			endif 
c30d			 
c30d			.ENDDEVICE: 
c30d			; eof 
c30d			 
# End of file forth_words_device.asm
c30d			 
c30d			; var handler 
c30d			 
c30d			 
c30d			.VARS: 
c30d				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c30d 78				db WORD_SYS_CORE+100             
c30e 25 c3			dw .V0Q            
c310 04				db 3 + 1 
c311 .. 00			db "V0!",0              
c315				endm 
# End of macro CWHEAD
c315			;| V0! ( u1 -- )  Store value to v0  | DONE 
c315			 
c315					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c315 cd e6 9a			call macro_dsp_valuehl 
c318				endm 
# End of macro FORTH_DSP_VALUEHL
c318			 
c318 11 90 ec				ld de, cli_var_array 
c31b			 
c31b eb					ex de, hl 
c31c 73					ld (hl), e 
c31d 23					inc hl 
c31e 72					ld (hl), d 
c31f			 
c31f					; destroy value TOS 
c31f			 
c31f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c31f cd 9e 9b			call macro_forth_dsp_pop 
c322				endm 
# End of macro FORTH_DSP_POP
c322			 
c322				       NEXTW 
c322 c3 58 9c			jp macro_next 
c325				endm 
# End of macro NEXTW
c325			.V0Q: 
c325				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c325 79				db WORD_SYS_CORE+101             
c326 36 c3			dw .V1S            
c328 04				db 3 + 1 
c329 .. 00			db "V0@",0              
c32d				endm 
# End of macro CWHEAD
c32d			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c32d 2a 90 ec				ld hl, (cli_var_array) 
c330 cd ef 98				call forth_push_numhl 
c333			 
c333				       NEXTW 
c333 c3 58 9c			jp macro_next 
c336				endm 
# End of macro NEXTW
c336			.V1S: 
c336				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c336 7a				db WORD_SYS_CORE+102             
c337 4e c3			dw .V1Q            
c339 04				db 3 + 1 
c33a .. 00			db "V1!",0              
c33e				endm 
# End of macro CWHEAD
c33e			;| V1! ( u1 -- )  Store value to v1 | DONE 
c33e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c33e cd e6 9a			call macro_dsp_valuehl 
c341				endm 
# End of macro FORTH_DSP_VALUEHL
c341			 
c341 11 92 ec				ld de, cli_var_array+2 
c344				 
c344 eb					ex de, hl 
c345 73					ld (hl), e 
c346 23					inc hl 
c347 72					ld (hl), d 
c348			 
c348					; destroy value TOS 
c348			 
c348					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c348 cd 9e 9b			call macro_forth_dsp_pop 
c34b				endm 
# End of macro FORTH_DSP_POP
c34b				       NEXTW 
c34b c3 58 9c			jp macro_next 
c34e				endm 
# End of macro NEXTW
c34e			.V1Q: 
c34e				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c34e 7b				db WORD_SYS_CORE+103             
c34f 5f c3			dw .V2S            
c351 04				db 3 + 1 
c352 .. 00			db "V1@",0              
c356				endm 
# End of macro CWHEAD
c356			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c356 2a 92 ec				ld hl, (cli_var_array+2) 
c359 cd ef 98				call forth_push_numhl 
c35c				       NEXTW 
c35c c3 58 9c			jp macro_next 
c35f				endm 
# End of macro NEXTW
c35f			.V2S: 
c35f				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c35f 7c				db WORD_SYS_CORE+104             
c360 77 c3			dw .V2Q            
c362 04				db 3 + 1 
c363 .. 00			db "V2!",0              
c367				endm 
# End of macro CWHEAD
c367			;| V2! ( u1 -- )  Store value to v2 | DONE 
c367					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c367 cd e6 9a			call macro_dsp_valuehl 
c36a				endm 
# End of macro FORTH_DSP_VALUEHL
c36a			 
c36a 11 94 ec				ld de, cli_var_array+4 
c36d				 
c36d eb					ex de, hl 
c36e 73					ld (hl), e 
c36f 23					inc hl 
c370 72					ld (hl), d 
c371			 
c371					; destroy value TOS 
c371			 
c371					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c371 cd 9e 9b			call macro_forth_dsp_pop 
c374				endm 
# End of macro FORTH_DSP_POP
c374				       NEXTW 
c374 c3 58 9c			jp macro_next 
c377				endm 
# End of macro NEXTW
c377			.V2Q: 
c377				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c377 7d				db WORD_SYS_CORE+105             
c378 88 c3			dw .V3S            
c37a 04				db 3 + 1 
c37b .. 00			db "V2@",0              
c37f				endm 
# End of macro CWHEAD
c37f			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c37f 2a 94 ec				ld hl, (cli_var_array+4) 
c382 cd ef 98				call forth_push_numhl 
c385				       NEXTW 
c385 c3 58 9c			jp macro_next 
c388				endm 
# End of macro NEXTW
c388			.V3S: 
c388				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c388 7c				db WORD_SYS_CORE+104             
c389 a0 c3			dw .V3Q            
c38b 04				db 3 + 1 
c38c .. 00			db "V3!",0              
c390				endm 
# End of macro CWHEAD
c390			;| V3! ( u1 -- )  Store value to v3 | DONE 
c390					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c390 cd e6 9a			call macro_dsp_valuehl 
c393				endm 
# End of macro FORTH_DSP_VALUEHL
c393			 
c393 11 96 ec				ld de, cli_var_array+6 
c396				 
c396 eb					ex de, hl 
c397 73					ld (hl), e 
c398 23					inc hl 
c399 72					ld (hl), d 
c39a			 
c39a					; destroy value TOS 
c39a			 
c39a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c39a cd 9e 9b			call macro_forth_dsp_pop 
c39d				endm 
# End of macro FORTH_DSP_POP
c39d				       NEXTW 
c39d c3 58 9c			jp macro_next 
c3a0				endm 
# End of macro NEXTW
c3a0			.V3Q: 
c3a0				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c3a0 7d				db WORD_SYS_CORE+105             
c3a1 b1 c3			dw .END            
c3a3 04				db 3 + 1 
c3a4 .. 00			db "V3@",0              
c3a8				endm 
# End of macro CWHEAD
c3a8			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c3a8 2a 96 ec				ld hl, (cli_var_array+6) 
c3ab cd ef 98				call forth_push_numhl 
c3ae				       NEXTW 
c3ae c3 58 9c			jp macro_next 
c3b1				endm 
# End of macro NEXTW
c3b1			 
c3b1			 
c3b1			 
c3b1			 
c3b1			 
c3b1			; end of dict marker 
c3b1			 
c3b1 00			.END:    db WORD_SYS_END 
c3b2 00 00			dw 0 
c3b4 00				db 0 
c3b5			 
c3b5			; use to jp here for user dict words to save on macro expansion  
c3b5			 
c3b5			user_dict_next: 
c3b5				NEXTW 
c3b5 c3 58 9c			jp macro_next 
c3b8				endm 
# End of macro NEXTW
c3b8			 
c3b8			 
c3b8			user_exec: 
c3b8				;    ld hl, <word code> 
c3b8				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c3b8				;    call forthexec 
c3b8				;    jp user_dict_next   (NEXT) 
c3b8			        ;    <word code bytes> 
c3b8 eb				ex de, hl 
c3b9 2a de e7			ld hl,(os_tok_ptr) 
c3bc				 
c3bc				FORTH_RSP_NEXT 
c3bc cd 96 98			call macro_forth_rsp_next 
c3bf				endm 
# End of macro FORTH_RSP_NEXT
c3bf			 
c3bf			if DEBUG_FORTH_UWORD 
c3bf						DMARK "UEX" 
c3bf f5				push af  
c3c0 3a d4 c3			ld a, (.dmark)  
c3c3 32 b7 ee			ld (debug_mark),a  
c3c6 3a d5 c3			ld a, (.dmark+1)  
c3c9 32 b8 ee			ld (debug_mark+1),a  
c3cc 3a d6 c3			ld a, (.dmark+2)  
c3cf 32 b9 ee			ld (debug_mark+2),a  
c3d2 18 03			jr .pastdmark  
c3d4 ..			.dmark: db "UEX"  
c3d7 f1			.pastdmark: pop af  
c3d8			endm  
# End of macro DMARK
c3d8				CALLMONITOR 
c3d8 cd 62 93			call break_point_state  
c3db				endm  
# End of macro CALLMONITOR
c3db			endif 
c3db			 
c3db			 
c3db			 
c3db eb				ex de, hl 
c3dc 22 de e7			ld (os_tok_ptr), hl 
c3df				 
c3df				; Don't use next - Skips the first word in uword. 
c3df			 
c3df c3 e9 9c			jp exec1 
c3e2			;	NEXT 
c3e2			 
c3e2			 
c3e2			; eof 
# End of file forth_wordsv4.asm
c3e2			endif 
c3e2			;;;;;;;;;;;;;; Debug code 
c3e2			 
c3e2			 
c3e2			;if DEBUG_FORTH_PARSE 
c3e2 .. 00		.nowordfound: db "No match",0 
c3eb .. 00		.compword:	db "Comparing word ",0 
c3fb .. 00		.nextwordat:	db "Next word at",0 
c408 .. 00		.charmatch:	db "Char match",0 
c413			;endif 
c413			if DEBUG_FORTH_JP 
c413			.foundword:	db "Word match. Exec..",0 
c413			endif 
c413			;if DEBUG_FORTH_PUSH 
c413 .. 00		.enddict:	db "Dict end. Push.",0 
c423 .. 00		.push_str:	db "Pushing string",0 
c432 .. 00		.push_num:	db "Pushing number",0 
c441 .. 00		.data_sp:	db "SP:",0 
c445 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c457 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c469 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c47b			;endif 
c47b			;if DEBUG_FORTH_MALLOC 
c47b .. 00		.push_malloc:	db "Malloc address",0 
c48a			;endif 
c48a			 
c48a			 
c48a			 
c48a			; display malloc address and current data stack pointer  
c48a			 
c48a			malloc_error: 
c48a d5				push de 
c48b f5				push af 
c48c e5				push hl 
c48d cd 8c 88			call clear_display 
c490 11 b2 c4			ld de, .mallocerr 
c493 3e 00			ld a,0 
c495			;	ld de,os_word_scratch 
c495 cd 9f 88			call str_at_display 
c498 3e 11			ld a, display_row_1+17 
c49a 11 b7 ee			ld de, debug_mark 
c49d cd 9f 88			call str_at_display 
c4a0 cd af 88			call update_display 
c4a3				;call break_point_state 
c4a3 cd c0 d7			call cin_wait 
c4a6			 
c4a6 3e 20			ld a, ' ' 
c4a8 32 ce e4			ld (os_view_disable), a 
c4ab e1				pop hl 
c4ac f1				pop af 
c4ad d1				pop de	 
c4ae				CALLMONITOR 
c4ae cd 62 93			call break_point_state  
c4b1				endm  
# End of macro CALLMONITOR
c4b1 c9				ret 
c4b2			 
c4b2 .. 00		.mallocerr: 	db "Malloc Error",0 
c4bf			;if DEBUG_FORTH_PUSH 
c4bf			display_data_sp: 
c4bf f5				push af 
c4c0			 
c4c0				; see if disabled 
c4c0			 
c4c0 3a ce e4			ld a, (os_view_disable) 
c4c3 fe 2a			cp '*' 
c4c5 28 67			jr z, .skipdsp 
c4c7			 
c4c7 e5				push hl 
c4c8 e5				push hl 
c4c9 e5			push hl 
c4ca cd 8c 88			call clear_display 
c4cd e1			pop hl 
c4ce 7c				ld a,h 
c4cf 21 e2 e7			ld hl, os_word_scratch 
c4d2 cd ba 8d			call hexout 
c4d5 e1				pop hl 
c4d6 7d				ld a,l 
c4d7 21 e4 e7			ld hl, os_word_scratch+2 
c4da cd ba 8d			call hexout 
c4dd 21 e6 e7			ld hl, os_word_scratch+4 
c4e0 3e 00			ld a,0 
c4e2 77				ld (hl),a 
c4e3 11 e2 e7			ld de,os_word_scratch 
c4e6 3e 14				ld a, display_row_2 
c4e8 cd 9f 88				call str_at_display 
c4eb 11 45 c4			ld de, .wordinhl 
c4ee 3e 00			ld a, display_row_1 
c4f0			 
c4f0 cd 9f 88				call str_at_display 
c4f3 11 b7 ee			ld de, debug_mark 
c4f6 3e 11			ld a, display_row_1+17 
c4f8			 
c4f8 cd 9f 88				call str_at_display 
c4fb			 
c4fb				; display current data stack pointer 
c4fb 11 41 c4			ld de,.data_sp 
c4fe 3e 1c				ld a, display_row_2 + 8 
c500 cd 9f 88				call str_at_display 
c503			 
c503 2a 8a ec			ld hl,(cli_data_sp) 
c506 e5				push hl 
c507 7c				ld a,h 
c508 21 e2 e7			ld hl, os_word_scratch 
c50b cd ba 8d			call hexout 
c50e e1				pop hl 
c50f 7d				ld a,l 
c510 21 e4 e7			ld hl, os_word_scratch+2 
c513 cd ba 8d			call hexout 
c516 21 e6 e7			ld hl, os_word_scratch+4 
c519 3e 00			ld a,0 
c51b 77				ld (hl),a 
c51c 11 e2 e7			ld de,os_word_scratch 
c51f 3e 1f				ld a, display_row_2 + 11 
c521 cd 9f 88				call str_at_display 
c524			 
c524			 
c524 cd af 88			call update_display 
c527 cd 09 88			call delay1s 
c52a cd 09 88			call delay1s 
c52d e1				pop hl 
c52e			.skipdsp: 
c52e f1				pop af 
c52f c9				ret 
c530			 
c530			display_data_malloc: 
c530			 
c530 f5				push af 
c531 e5				push hl 
c532 e5				push hl 
c533 e5			push hl 
c534 cd 8c 88			call clear_display 
c537 e1			pop hl 
c538 7c				ld a,h 
c539 21 e2 e7			ld hl, os_word_scratch 
c53c cd ba 8d			call hexout 
c53f e1				pop hl 
c540 7d				ld a,l 
c541 21 e4 e7			ld hl, os_word_scratch+2 
c544 cd ba 8d			call hexout 
c547 21 e6 e7			ld hl, os_word_scratch+4 
c54a 3e 00			ld a,0 
c54c 77				ld (hl),a 
c54d 11 e2 e7			ld de,os_word_scratch 
c550 3e 14				ld a, display_row_2 
c552 cd 9f 88				call str_at_display 
c555 11 7b c4			ld de, .push_malloc 
c558 3e 00			ld a, display_row_1 
c55a			 
c55a cd 9f 88				call str_at_display 
c55d			 
c55d				; display current data stack pointer 
c55d 11 41 c4			ld de,.data_sp 
c560 3e 1c				ld a, display_row_2 + 8 
c562 cd 9f 88				call str_at_display 
c565			 
c565 2a 8a ec			ld hl,(cli_data_sp) 
c568 e5				push hl 
c569 7c				ld a,h 
c56a 21 e2 e7			ld hl, os_word_scratch 
c56d cd ba 8d			call hexout 
c570 e1				pop hl 
c571 7d				ld a,l 
c572 21 e4 e7			ld hl, os_word_scratch+2 
c575 cd ba 8d			call hexout 
c578 21 e6 e7			ld hl, os_word_scratch+4 
c57b 3e 00			ld a,0 
c57d 77				ld (hl),a 
c57e 11 e2 e7			ld de,os_word_scratch 
c581 3e 1f				ld a, display_row_2 + 11 
c583 cd 9f 88				call str_at_display 
c586			 
c586 cd af 88			call update_display 
c589 cd 09 88			call delay1s 
c58c cd 09 88			call delay1s 
c58f e1				pop hl 
c590 f1				pop af 
c591 c9				ret 
c592			;endif 
c592			 
c592			include "forth_autostart.asm" 
c592			; list of commands to perform at system start up 
c592			 
c592			startcmds: 
c592			;	dw test11 
c592			;	dw test12 
c592			;	dw test13 
c592			;	dw test14 
c592			;	dw test15 
c592			;	dw test16 
c592			;	dw test17 
c592			;	dw ifthtest1 
c592			;	dw ifthtest2 
c592			;	dw ifthtest3 
c592			;	dw mmtest1 
c592			;	dw mmtest2 
c592			;	dw mmtest3 
c592			;	dw mmtest4 
c592			;	dw mmtest5 
c592			;	dw mmtest6 
c592			;	dw iftest1 
c592			;	dw iftest2 
c592			;	dw iftest3 
c592			;	dw looptest1 
c592			;	dw looptest2 
c592			;	dw test1 
c592			;	dw test2 
c592			;	dw test3 
c592			;	dw test4 
c592			;	dw game2r 
c592			;	dw game2b1 
c592			;	dw game2b2 
c592			 
c592				; start up words that are actually useful 
c592			 
c592 f0 c5			dw clrstack 
c594 23 c6			dw type 
c596 e4 c7			dw stest 
c598 47 c6			dw strncpy 
c59a 85 c7			dw list 
c59c a8 c6			dw start1 
c59e ba c6			dw start2 
c5a0			;	dw start3 
c5a0 cd c6			dw start3b 
c5a2 25 c7			dw start3c 
c5a4			 
c5a4				; (unit) testing words 
c5a4			 
c5a4 5b c8			dw mtesta 
c5a6 10 c9			dw mtestb 
c5a8 b3 c9			dw mtestc 
c5aa 68 ca			dw mtestd 
c5ac 0c cb			dw mteste 
c5ae			 
c5ae				; demo/game words 
c5ae			 
c5ae 18 d2		        dw game3w 
c5b0 46 d2		        dw game3p 
c5b2 64 d2		        dw game3sc 
c5b4 95 d2		        dw game3vsi 
c5b6 c1 d2		        dw game3vs 
c5b8				 
c5b8 0b d0			dw game2b 
c5ba 79 d0			dw game2bf 
c5bc c3 d0			dw game2mba 
c5be 59 d1			dw game2mbas 
c5c0 9b d1			dw game2mb 
c5c2			 
c5c2 cc cc			dw game1 
c5c4 dd cc			dw game1a 
c5c6 3f cd			dw game1b 
c5c8 74 cd			dw game1c 
c5ca aa cd			dw game1d 
c5cc db cd			dw game1s 
c5ce ef cd			dw game1t 
c5d0 04 ce			dw game1f 
c5d2 38 ce			dw game1z 
c5d4 7c ce			dw game1zz 
c5d6			 
c5d6 c2 cb			dw test5 
c5d8 fa cb			dw test6 
c5da 32 cc			dw test7 
c5dc 46 cc			dw test8 
c5de 72 cc			dw test9 
c5e0 88 cc			dw test10 
c5e2				 
c5e2 53 cf		        dw ssv5 
c5e4 37 cf		        dw ssv4 
c5e6 1b cf		        dw ssv3 
c5e8 e5 ce		        dw ssv2 
c5ea 6c cf		        dw ssv1 
c5ec b4 cf		        dw ssv1cpm 
c5ee			;	dw keyup 
c5ee			;	dw keydown 
c5ee			;	dw keyleft 
c5ee			;	dw keyright 
c5ee			;	dw 	keyf1 
c5ee			;	dw keyf2 
c5ee			;	dw keyf3 
c5ee			;	dw keyf4 
c5ee			;	dw keyf5 
c5ee			;	dw keyf6 
c5ee			;	dw keyf7 
c5ee			;	dw keyf8 
c5ee			;	dw keyf9 
c5ee			;	dw keyf10 
c5ee			;	dw keyf11 
c5ee			;	dw keyf12 
c5ee			;	dw keytab 
c5ee			;	dw keycr 
c5ee			;	dw keyhome 
c5ee			;	dw keyend 
c5ee			;	dw keybs 
c5ee 00 00			db 0, 0	 
c5f0			 
c5f0			 
c5f0			; clear stack  
c5f0			 
c5f0 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c623			 
c623			; type ( addr count - ) 
c623 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c647			 
c647			; some direct memory words 
c647			; strncpy ( len t f -- t ) 
c647			 
c647 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c6a8			 
c6a8 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c6ba .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c6cd			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c6cd .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c725 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c785			 
c785			 
c785			; a handy word to list items on the stack 
c785			 
c785 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c7e4			 
c7e4			 
c7e4			; test stack  
c7e4			; rnd8 stest 
c7e4			 
c7e4 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c85b			 
c85b			; random malloc and free cycles 
c85b			 
c85b .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c910			 
c910			; fixed malloc and free cycles 
c910			 
c910 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c9b3			 
c9b3			; fixed double string push and drop cycle  
c9b3			 
c9b3 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
ca68			 
ca68			; consistent fixed string push and drop cycle  
ca68			 
ca68 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cb0c			 
cb0c .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cbc2			 
cbc2			;test1:		db ": aa 1 2 3 ;", 0 
cbc2			;test2:     	db "111 aa 888 999",0 
cbc2			;test3:     	db ": bb 77 ;",0 
cbc2			;test4:     	db "$02 $01 do i . loop bb",0 
cbc2			 
cbc2 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cbfa .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cc32 .. 00		test7:     	db ": box hline vline ;",0 
cc46 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cc72 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cc88 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
ccad .. 00		test11:     	db "hello create .",0 
ccbc .. 00		test12:     	db "hello2 create .",0 
cccc			 
cccc			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cccc			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cccc			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cccc			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cccc			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cccc			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cccc			 
cccc			;iftest1:     	db "$0001 IF cls .",0 
cccc			;iftest2:     	db "$0000 IF cls .",0 
cccc			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cccc			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cccc			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cccc			 
cccc			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cccc			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cccc			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cccc			 
cccc			 
cccc			 
cccc			; a small guess the number game 
cccc			 
cccc .. 00		game1:          db ": gsn rnd8 v1! ;",0 
ccdd .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
cd3f			 
cd3f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
cd74 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
cdaa .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
cddb .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cdef .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
ce04 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
ce38 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
ce7c			 
ce7c			; Using 'ga' save a high score across multiple runs using external storage 
ce7c			 
ce7c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
cee5			 
cee5			 
cee5			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
cee5			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
cee5			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
cee5			 
cee5			; simple screen saver to test code memory reuse to destruction 
cee5			 
cee5 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
cf1b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
cf37 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
cf53 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
cf6c .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
cfb4 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d00b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d00b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d00b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d00b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d00b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d00b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d00b			 
d00b			 
d00b			 
d00b			; minesweeper/battleship finding game 
d00b			; draws a game board of random ship/mine positions 
d00b			; user enters coords to see if it hits on 
d00b			; game ends when all are hit 
d00b			; when hit or miss says how many may be in the area 
d00b			 
d00b			; setup the game board and then hide it 
d00b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d079 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d0c3			; prompt for where to target 
d0c3 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d159 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d17e			; TODO see if the entered coords hits or misses pushes char hit of miss 
d17e .. 00		game2mbht:      db ": mbckht nop ;",0 
d18d .. 00		game2mbms:      db ": mbcms nop ;",0 
d19b			; TODO how many might be near by 
d19b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d218			 
d218			; Game 3 
d218			 
d218			; Vert scroller ski game - avoid the trees! 
d218			 
d218			; v0 score (ie turns) 
d218			; v1 player pos 
d218			; v2 left wall 
d218			; v3 right wall 
d218			 
d218			; Draw side walls randomly 
d218			 
d218 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d246			 
d246			; Draw player 
d246 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d264			 
d264			; TODO Get Key 
d264			 
d264			; TODO Move left right 
d264			 
d264			; scroll and move walls a bit 
d264			 
d264 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d295			 
d295			; main game loop 
d295			 
d295 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d2c1 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d300			 
d300			; key board defs 
d300			 
d300 .. 00		keyup:       db ": keyup $05 ;",0 
d30e .. 00		keydown:       db ": keydown $0a ;",0 
d31e .. 00		keyleft:       db ": keyleft $0b ;",0 
d32e .. 00		keyright:       db ": keyright $0c ;",0 
d33f .. 00		keyf1:       db ": keyf1 $10 ;",0 
d34d .. 00		keyf2:       db ": keyf2 $11 ;",0 
d35b .. 00		keyf3:       db ": keyf3 $12 ;",0 
d369 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d377 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d385 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d393 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d3a1 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d3af .. 00		keyf9:       db ": keyf9 $18 ;",0 
d3bd .. 00		keyf10:       db ": keyf10 $19 ;",0 
d3cc .. 00		keyf11:       db ": keyf11 $1a ;",0 
d3db .. 00		keyf12:       db ": keyf12 $1b ;",0 
d3ea			 
d3ea .. 00		keytab:       db ": keytab $09 ;",0 
d3f9 .. 00		keycr:       db ": keycr $0d ;",0 
d407 .. 00		keyhome:       db ": keyhome $0e ;",0 
d417 .. 00		keyend:       db ": keyend $0f ;",0 
d426 .. 00		keybs:       db ": keybs $08 ;",0 
d434			 
d434			   
d434			 
d434			 
d434			 
d434			; eof 
# End of file forth_autostart.asm
d434			 
d434 .. 00		sprompt1: db "Startup load...",0 
d444 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d45a			 
d45a			 
d45a			 
d45a			 
d45a			forth_startup: 
d45a 21 92 c5			ld hl, startcmds 
d45d 3e 00			ld a, 0 
d45f 32 03 e9			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d462			 
d462 e5			.start1:	push hl 
d463 cd 8c 88			call clear_display 
d466 11 34 d4			ld de, sprompt1 
d469 3e 00		        ld a, display_row_1 
d46b cd 9f 88			call str_at_display 
d46e 11 44 d4			ld de, sprompt2 
d471 3e 14		        ld a, display_row_2 
d473 cd 9f 88			call str_at_display 
d476 e1				pop hl 
d477 e5				push hl 
d478 5e				ld e,(hl) 
d479 23				inc hl 
d47a 56				ld d,(hl) 
d47b 3e 28		        ld a, display_row_3 
d47d cd 9f 88			call str_at_display 
d480 cd af 88			call update_display 
d483			 
d483			 
d483 3a 03 e9			ld a, (os_last_cmd) 
d486 fe 00			cp 0 
d488 28 05			jr z, .startprompt 
d48a cd fd 87			call delay250ms 
d48d 18 24			jr .startdo 
d48f				 
d48f				 
d48f			 
d48f			.startprompt: 
d48f			 
d48f 3e 4f			ld a,display_row_4 + display_cols - 1 
d491 11 65 98		        ld de, endprg 
d494 cd 9f 88			call str_at_display 
d497 cd af 88			call update_display 
d49a cd 09 88			call delay1s 
d49d cd c0 d7			call cin_wait 
d4a0						 
d4a0 fe 2a			cp '*' 
d4a2 28 5e			jr z, .startupend1 
d4a4 fe 23			cp '#' 
d4a6 20 07			jr nz, .startno 
d4a8 3e 01			ld a, 1 
d4aa 32 03 e9			ld (os_last_cmd),a 
d4ad 18 04			jr .startdo 
d4af fe 31		.startno:	cp '1' 
d4b1 28 3a			jr z,.startnxt  
d4b3			 
d4b3				; exec startup line 
d4b3			.startdo:	 
d4b3 e1				pop hl 
d4b4 e5				push hl 
d4b5				 
d4b5 5e				ld e,(hl) 
d4b6 23				inc hl 
d4b7 56				ld d,(hl) 
d4b8 eb				ex de,hl 
d4b9			 
d4b9 e5				push hl 
d4ba			 
d4ba 3e 00			ld a, 0 
d4bc				;ld a, FORTH_END_BUFFER 
d4bc cd 22 8f			call strlent 
d4bf 23				inc hl   ; include zero term to copy 
d4c0 06 00			ld b,0 
d4c2 4d				ld c,l 
d4c3 e1				pop hl 
d4c4 11 dd e4			ld de, scratch 
d4c7 ed b0			ldir 
d4c9			 
d4c9			 
d4c9 21 dd e4			ld hl, scratch 
d4cc cd a6 9c			call forthparse 
d4cf cd e6 9c			call forthexec 
d4d2 cd fd 9b			call forthexec_cleanup 
d4d5			 
d4d5 3e 3c			ld a, display_row_4 
d4d7 11 09 96			ld de, endprog 
d4da			 
d4da cd af 88			call update_display		 
d4dd			 
d4dd 3a 03 e9			ld a, (os_last_cmd) 
d4e0 fe 00			cp 0 
d4e2 20 09			jr nz, .startnxt 
d4e4 cd 67 98			call next_page_prompt 
d4e7 cd 8c 88		        call clear_display 
d4ea cd af 88			call update_display		 
d4ed			 
d4ed				; move onto next startup line? 
d4ed			.startnxt: 
d4ed			 
d4ed cd fd 87			call delay250ms 
d4f0 e1				pop hl 
d4f1			 
d4f1 23				inc hl 
d4f2 23				inc hl 
d4f3			 
d4f3 e5				push hl 
d4f4 5e				ld e, (hl) 
d4f5 23				inc hl 
d4f6 56				ld d, (hl) 
d4f7 e1				pop hl 
d4f8				; TODO replace 0 test 
d4f8			 
d4f8 eb				ex de, hl 
d4f9 cd e2 8a			call ishlzero 
d4fc			;	ld a,e 
d4fc			;	add d 
d4fc			;	cp 0    ; any left to do? 
d4fc eb				ex de, hl 
d4fd c2 62 d4			jp nz, .start1 
d500 18 01			jr .startupend 
d502			 
d502 e1			.startupend1: pop hl 
d503			.startupend: 
d503			 
d503 cd 8c 88			call clear_display 
d506 cd af 88			call update_display 
d509 c9				ret 
d50a			 
d50a			 
d50a			; stack over and underflow checks 
d50a			 
d50a			; init the words to detect the under/overflow 
d50a			 
d50a			chk_stk_init: 
d50a				; a vague random number to check so we dont get any "lucky" hits 
d50a 3e 2d			ld a, 45 
d50c 6f				ld l, a 
d50d 00				nop 
d50e 3e 17			ld a, 23 
d510 67				ld h, a 
d511			 
d511 22 c4 e4			ld (chk_word), hl     ; the word we need to check against 
d514			 
d514			;	ld (chk_stund), hl	; stack points.... 
d514 22 00 ef			ld (chk_stovr), hl 
d517 22 88 ec			ld (chk_ret_und), hl 
d51a 22 46 ec			ld (chk_ret_ovr), hl 
d51d 22 44 eb			ld (chk_loop_ovr), hl 
d520 22 42 ea			ld (chk_data_ovr), hl 
d523 c9				ret 
d524				 
d524			check_stacks: 
d524				; check all stack words 
d524			 
d524 e5				push hl 
d525 d5				push de 
d526			 
d526			;	ld de,(chk_word) 
d526			;	ld hl, (chk_stund)	; stack points.... 
d526			;	if DEBUG_STK_FAULT 
d526			;		DMARK "FAa" 
d526			;		CALLMONITOR 
d526			;	endif 
d526			;	call cmp16 
d526			;	jp z, .chk_faulta 
d526			; 
d526			;	ld de, sfaultsu 
d526			;	jp .chk_fault 
d526			 
d526 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d529 ed 5b c4 e4		ld de,(chk_word) 
d52d				if DEBUG_STK_FAULT 
d52d					DMARK "FAb" 
d52d					CALLMONITOR 
d52d				endif 
d52d cd d7 8a			call cmp16 
d530 28 06			jr z, .chk_fault1 
d532 11 d3 d5			ld de, sfaultso 
d535 c3 87 d5			jp .chk_fault 
d538			.chk_fault1:  
d538 2a 88 ec			ld hl, (chk_ret_und) 
d53b ed 5b c4 e4		ld de,(chk_word) 
d53f				if DEBUG_STK_FAULT 
d53f					DMARK "FAU" 
d53f					CALLMONITOR 
d53f				endif 
d53f cd d7 8a			call cmp16 
d542 ca 4b d5			jp z, .chk_fault2 
d545 11 e3 d5			ld de, sfaultru 
d548 c3 87 d5			jp .chk_fault 
d54b			.chk_fault2:  
d54b 2a 46 ec			ld hl, (chk_ret_ovr) 
d54e ed 5b c4 e4		ld de,(chk_word) 
d552				if DEBUG_STK_FAULT 
d552					DMARK "FA1" 
d552					CALLMONITOR 
d552				endif 
d552 cd d7 8a			call cmp16 
d555 ca 5e d5			jp z, .chk_fault3 
d558 11 f1 d5			ld de, sfaultro 
d55b c3 87 d5			jp .chk_fault 
d55e			.chk_fault3:  
d55e 2a 44 eb			ld hl, (chk_loop_ovr) 
d561 ed 5b c4 e4		ld de,(chk_word) 
d565				if DEBUG_STK_FAULT 
d565					DMARK "FA2" 
d565					CALLMONITOR 
d565				endif 
d565 cd d7 8a			call cmp16 
d568 ca 71 d5			jp z, .chk_fault4 
d56b 11 0b d6			ld de, sfaultlo 
d56e c3 87 d5			jp .chk_fault 
d571			.chk_fault4:  
d571 2a 42 ea			ld hl, (chk_data_ovr) 
d574 ed 5b c4 e4		ld de,(chk_word) 
d578				if DEBUG_STK_FAULT 
d578					DMARK "FA3" 
d578					CALLMONITOR 
d578				endif 
d578 cd d7 8a			call cmp16 
d57b ca 84 d5			jp z, .chk_fault5 
d57e 11 25 d6			ld de, sfaultdo 
d581 c3 87 d5			jp .chk_fault 
d584			 
d584			 
d584			.chk_fault5:  
d584 d1				pop de 
d585 e1				pop hl 
d586			 
d586 c9				ret 
d587			 
d587 cd 8c 88		.chk_fault: 	call clear_display 
d58a 3e 14				ld a, display_row_2 
d58c cd 9f 88				call str_at_display 
d58f 11 b5 d5				   ld de, .stackfault 
d592 3e 00				ld a, display_row_1 
d594 cd 9f 88				call str_at_display 
d597 11 b7 ee				    ld de, debug_mark 
d59a 3e 11				ld a, display_row_1+17 
d59c cd 9f 88				call str_at_display 
d59f cd af 88				call update_display 
d5a2			 
d5a2				; prompt before entering montior for investigating issue 
d5a2			 
d5a2 3e 3c			ld a, display_row_4 
d5a4 11 09 96			ld de, endprog 
d5a7			 
d5a7 cd af 88			call update_display		 
d5aa			 
d5aa cd 67 98			call next_page_prompt 
d5ad			 
d5ad d1				pop de 
d5ae e1				pop hl 
d5af cd 5d 96				call monitor 
d5b2 c3 57 95				jp warmstart 
d5b5					;jp 0 
d5b5					;halt 
d5b5			 
d5b5			 
d5b5			 
d5b5 .. 00		.stackfault: 	db "Stack fault:",0 
d5c2			 
d5c2 .. 00		sfaultsu: 	db	"Stack under flow",0 
d5d3 .. 00		sfaultso: 	db	"Stack over flow",0 
d5e3 .. 00		sfaultru:	db "RTS underflow",0 
d5f1 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d60b .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d625 .. 00		sfaultdo:	db "DTS overflow", 0 
d632			 
d632			 
d632			fault_dsp_under: 
d632 11 44 d6			ld de, .dsp_under 
d635 c3 f4 d6			jp .show_fault 
d638			 
d638			fault_rsp_under: 
d638 11 52 d6			ld de, .rsp_under 
d63b c3 f4 d6			jp .show_fault 
d63e			fault_loop_under: 
d63e 11 60 d6			ld de, .loop_under 
d641 c3 f4 d6			jp .show_fault 
d644			 
d644 .. 00		.dsp_under: db "DSP Underflow",0 
d652 .. 00		.rsp_under: db "RSP Underflow",0 
d660 .. 00		.loop_under: db "LOOP Underflow",0 
d66f			 
d66f			 
d66f d5			type_faultn: 	push de 
d670 e5					push hl 
d671 cd 8c 88				call clear_display 
d674 11 9b d6				   ld de, .typefaultn 
d677 3e 00				ld a, display_row_1 
d679 cd 9f 88				call str_at_display 
d67c 11 b7 ee				    ld de, debug_mark 
d67f 3e 11				ld a, display_row_1+17 
d681 cd 9f 88				call str_at_display 
d684 cd af 88				call update_display 
d687			 
d687				; prompt before entering montior for investigating issue 
d687			 
d687 3e 3c			ld a, display_row_4 
d689 11 09 96			ld de, endprog 
d68c			 
d68c cd af 88			call update_display		 
d68f			 
d68f cd 67 98			call next_page_prompt 
d692			 
d692 e5					push hl 
d693 d5					push de 
d694 cd 5d 96				call monitor 
d697 c3 57 95				jp warmstart 
d69a 76					halt 
d69b			 
d69b			 
d69b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d6b2			 
d6b2 d5			type_faults: 	push de 
d6b3 e5					push hl 
d6b4 cd 8c 88				call clear_display 
d6b7 11 dd d6				   ld de, .typefaults 
d6ba 3e 00				ld a, display_row_1 
d6bc cd 9f 88				call str_at_display 
d6bf 11 b7 ee				    ld de, debug_mark 
d6c2 3e 11				ld a, display_row_1+17 
d6c4 cd 9f 88				call str_at_display 
d6c7 cd af 88				call update_display 
d6ca			 
d6ca				; prompt before entering montior for investigating issue 
d6ca			 
d6ca 3e 3c			ld a, display_row_4 
d6cc 11 09 96			ld de, endprog 
d6cf			 
d6cf cd af 88			call update_display		 
d6d2			 
d6d2 cd 67 98			call next_page_prompt 
d6d5			 
d6d5 e1					pop hl 
d6d6 d1					pop de 
d6d7 cd 5d 96				call monitor 
d6da c3 57 95				jp warmstart 
d6dd			 
d6dd			 
d6dd .. 00		.typefaults: db "STR Type Expected TOS!",0 
d6f4			 
d6f4			.show_fault: 	 
d6f4 d5					push de 
d6f5 cd 8c 88				call clear_display 
d6f8 d1					pop de 
d6f9 3e 00				ld a, display_row_1 
d6fb cd 9f 88				call str_at_display 
d6fe 11 b7 ee				    ld de, debug_mark 
d701 3e 11				ld a, display_row_1+17 
d703 cd 9f 88				call str_at_display 
d706 cd af 88				call update_display 
d709			 
d709				; prompt before entering montior for investigating issue 
d709			 
d709 3e 3c			ld a, display_row_4 
d70b 11 09 96			ld de, endprog 
d70e			 
d70e cd af 88			call update_display		 
d711			 
d711 cd 67 98			call next_page_prompt 
d714			 
d714 e1					pop hl 
d715 d1					pop de 
d716 cd 5d 96				call monitor 
d719			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d719			; TODO Make optional fault restart to cli or warm boot? 
d719					;jp warmstart 
d719 c3 af 95				jp cli 
d71c 76					halt 
d71d			 
d71d			; handle the auto run of code from files in storage 
d71d			 
d71d			 
d71d			if STORAGE_SE 
d71d			 
d71d			sprompt3: db "Loading from start-up file?:",0 
d71d			sprompt4: db "(Y=Any key/N=No)",0 
d71d			 
d71d			 
d71d			forth_autoload: 
d71d			 
d71d				; load block 0 of store 1 
d71d				 
d71d				ld a, $fe      ; bit 0 clear 
d71d				ld (spi_device), a 
d71d			 
d71d				call storage_get_block_0 
d71d			 
d71d				ld a, (store_page+STORE_0_AUTOFILE) 
d71d			 
d71d				cp 0 
d71d				ret z     ; auto start not enabled 
d71d			 
d71d				call clear_display 
d71d			 
d71d				; set bank 
d71d			 
d71d					ld a, (store_page+STORE_0_BANKRUN) 
d71d					ld (spi_device), a 
d71d			 
d71d				; get file id to load from and get the file name to display 
d71d			 
d71d					ld a, (store_page+STORE_0_FILERUN) 
d71d			 
d71d					ld l, 0 
d71d					ld h, a 
d71d					ld de, store_page 
d71d			 
d71d					if DEBUG_FORTH_WORDS 
d71d						DMARK "ASp" 
d71d						CALLMONITOR 
d71d					endif 
d71d					call storage_read 
d71d			 
d71d					if DEBUG_FORTH_WORDS 
d71d						DMARK "ASr" 
d71d						CALLMONITOR 
d71d					endif 
d71d			 
d71d					call ishlzero 
d71d					ret z             ; file not found 
d71d			 
d71d					ld a, display_row_2 + 10 
d71d					ld de, store_page+3 
d71d					call str_at_display 
d71d				 
d71d			; 
d71d			 
d71d				ld a, display_row_1+5 
d71d				ld de, sprompt3 
d71d				call str_at_display 
d71d				ld a, display_row_3+15 
d71d				ld de, sprompt4 
d71d				call str_at_display 
d71d			 
d71d				call update_display 
d71d			 
d71d				call cin_wait 
d71d				cp 'n' 
d71d				ret z 
d71d				cp 'N' 
d71d				ret z 
d71d			 
d71d				call delay1s 
d71d			 
d71d				ld a, (store_page+2) 
d71d				ld (store_openmaxext), a    ; save count of ext 
d71d				ld a, 1  
d71d				ld (store_openext), a    ; save count of ext 
d71d			 
d71d			.autof:  
d71d				ld l , a 
d71d				 
d71d				ld a, (store_page) 
d71d				ld h, a	 
d71d				ld de, store_page 
d71d					if DEBUG_FORTH_WORDS 
d71d						DMARK "ASl" 
d71d						CALLMONITOR 
d71d					endif 
d71d					call storage_read 
d71d				call ishlzero 
d71d				ret z 
d71d			;	jr z, .autoend 
d71d			 
d71d					if DEBUG_FORTH_WORDS 
d71d						DMARK "ASc" 
d71d						CALLMONITOR 
d71d					endif 
d71d				ld de, store_page+2 
d71d				ld a, display_row_4 
d71d				call str_at_display 
d71d			 
d71d				call update_display 
d71d				call delay250ms 
d71d			 
d71d			 
d71d			 
d71d				ld hl, store_page+2 
d71d				call forthparse 
d71d				call forthexec 
d71d				call forthexec_cleanup 
d71d			 
d71d				 
d71d				ld a, (store_openext) 
d71d				inc a 
d71d				ld (store_openext), a    ; save count of ext 
d71d			 
d71d				jr .autof 
d71d			;.autofdone: 
d71d			; 
d71d			;		if DEBUG_FORTH_WORDS 
d71d			;			DMARK "ASx" 
d71d			;			CALLMONITOR 
d71d			;		endif 
d71d			;;	call clear_display 
d71d			;	ret 
d71d			 
d71d			 
d71d			 
d71d			endif 
d71d			 
d71d			 
d71d			; eof 
# End of file forth_kernel.asm
d71d			;include "nascombasic.asm" 
d71d			 
d71d			 
d71d			; find out where the code ends if loaded into RAM (for SC114) 
d71d			;endofcode:  
d71d			;	nop 
d71d			 
d71d			 
d71d			; eof 
d71d			 
# End of file main.asm
d71d			;include "firmware_lcd_4x20.asm" 
d71d			;include "firmware_key_4x4.asm" 
d71d			include "firmware_serial_display.asm" 
d71d			 
d71d			; Serial display interface for SC114 
d71d			 
d71d			 
d71d			display_row_1: equ 0 
d71d			display_row_2: equ display_row_1+display_cols 
d71d			display_row_3: equ display_row_2 + display_cols 
d71d			display_row_4: equ display_row_3 + display_cols 
d71d			 
d71d			kLCDWidth:  EQU display_cols             ;Width in characters 
d71d			kLCD_Line1: EQU 0x00  
d71d			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d71d			; E1 
d71d			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d71d			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d71d			 
d71d			lcd_init: 
d71d				; no init as handled by the SCM bios 
d71d c9				ret 
d71e			 
d71e			 
d71e			; low level functions for direct screen writes 
d71e			 
d71e			; output char at pos? 
d71e			fLCD_Str: 
d71e			        ;out (SC114_SIO_1_OUT),a 
d71e c5				push bc 
d71f 0e 02			ld c, $02 
d721 f7				rst $30 
d722 c1				pop bc 
d723 c9				ret 
d724			 
d724			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d724			fLCD_Pos: 
d724				; use ASCII escape to position 
d724			        ;out (SC114_SIO_1_OUT),a 
d724 c5				push bc 
d725 0e 02			ld c, $02 
d727 f7				rst $30 
d728 c1				pop bc 
d729			 
d729 c9				ret 
d72a			 
d72a			; output char at pos 
d72a			fLCD_Data: 
d72a			      ;  out (SC114_SIO_1_OUT),a 
d72a c5				push bc 
d72b 0e 02			ld c, $02 
d72d f7				rst $30 
d72e c1				pop bc 
d72f			 
d72f c9				ret 
d730			 
d730			; ascii cls  
d730			 
d730 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d734			 
d734			; write the frame buffer given in hl to hardware  
d734			write_display: 
d734			 
d734			API: equ 0 
d734			 
d734			if API 
d734				push bc 
d734				ld b, 4 
d734			 
d734			        ld (display_write_tmp), hl 	  
d734			 
d734				; clear and home cursor 
d734			 
d734				ld c, 6 
d734				ld de, .cls 
d734				rst $30 
d734			 
d734			 
d734			.writeln: 
d734			 
d734				ld de, (display_write_tmp) 
d734				ld c, 6 
d734				rst $30 
d734				ld c, 7 
d734				rst $30 
d734			 
d734				ld hl, (display_write_tmp) 
d734				ld de, display_cols 
d734				add hl,de 
d734				ld (display_write_tmp),hl 
d734			 
d734				djnz  .writeln 
d734			 
d734				pop bc 
d734			 
d734			 
d734				ret 
d734			endif 
d734 e5				push hl 
d735 c5				push bc 
d736 d5				push de 
d737			 
d737			;	ld c, 2 
d737			;	;ld de, .cls 
d737			;	ld a, 27 
d737			;	rst $30 
d737			;	ld c, 2 
d737			;	;ld de, .cls 
d737			;	ld a, '[' 
d737			;	rst $30 
d737			; 
d737			;	ld c, 2 
d737			;	;ld de, .cls 
d737			;	ld a, 'H' 
d737			;	rst $30 
d737			; 
d737			 
d737 0e 02			ld c, 2 
d739				;ld de, .cls 
d739 3e 1b			ld a, 27 
d73b f7				rst $30 
d73c			 
d73c			 
d73c 0e 02			ld c, 2 
d73e				;ld de, .cls 
d73e 3e 5b			ld a, '[' 
d740 f7				rst $30 
d741 0e 02			ld c, 2 
d743				;ld de, .cls 
d743 3e 32			ld a, '2' 
d745 f7				rst $30 
d746 0e 02			ld c, 2 
d748				;ld de, .cls 
d748 3e 4a			ld a, 'J' 
d74a f7				rst $30 
d74b d1				pop de 
d74c c1				pop bc 
d74d e1				pop hl 
d74e			 
d74e			 
d74e 22 55 ed		        ld (display_write_tmp), hl 	  
d751 3e 00			ld a, kLCD_Line1 
d753			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d753 06 14			ld b, display_cols 
d755 ed 5b 55 ed		ld de, (display_write_tmp) 
d759 cd b7 d7			call write_len_string 
d75c				 
d75c			 
d75c e5			push hl 
d75d d5			push de 
d75e c5			push bc 
d75f 0e 07			ld c, 7 
d761 f7				rst $30 
d762 c1			pop bc 
d763 d1			pop de 
d764 e1			pop hl 
d765			 
d765				 
d765 2a 55 ed			ld hl, (display_write_tmp) 
d768 11 14 00			ld de, display_cols 
d76b 19				add hl,de 
d76c 22 55 ed			ld (display_write_tmp),hl 
d76f			 
d76f				 
d76f 3e 14			ld a, kLCD_Line2 
d771			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d771 06 14			ld b, display_cols 
d773 ed 5b 55 ed		ld de, (display_write_tmp) 
d777 cd b7 d7			call write_len_string 
d77a				 
d77a 2a 55 ed			ld hl, (display_write_tmp) 
d77d 11 14 00			ld de, display_cols 
d780 19				add hl,de 
d781 22 55 ed			ld (display_write_tmp),hl 
d784			 
d784 e5			push hl 
d785 d5			push de 
d786 c5			push bc 
d787 0e 07			ld c, 7 
d789 f7				rst $30 
d78a c1			pop bc 
d78b d1			pop de 
d78c e1			pop hl 
d78d			 
d78d				 
d78d 3e 28			ld a, kLCD_Line3 
d78f			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d78f 06 14			ld b, display_cols 
d791 ed 5b 55 ed		ld de, (display_write_tmp) 
d795 cd b7 d7			call write_len_string 
d798				 
d798 2a 55 ed			ld hl, (display_write_tmp) 
d79b 11 14 00			ld de, display_cols 
d79e 19				add hl,de 
d79f 22 55 ed			ld (display_write_tmp),hl 
d7a2			 
d7a2 e5			push hl 
d7a3 d5			push de 
d7a4 c5			push bc 
d7a5 0e 07			ld c, 7 
d7a7 f7				rst $30 
d7a8 c1			pop bc 
d7a9 d1			pop de 
d7aa e1			pop hl 
d7ab			 
d7ab				 
d7ab 3e 3c			ld a, kLCD_Line4 
d7ad			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d7ad 06 14			ld b, display_cols 
d7af ed 5b 55 ed		ld de, (display_write_tmp) 
d7b3 cd b7 d7			call write_len_string 
d7b6 c9					ret 
d7b7			 
d7b7			 
d7b7				; write out a fixed length string given in b from de 
d7b7			 
d7b7 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d7b8 cd 2a d7		            CALL fLCD_Data      ;Write character to display 
d7bb 13				inc de 
d7bc 10 f9			djnz write_len_string 
d7be c9				ret 
d7bf			 
d7bf			 
d7bf			; eof 
# End of file firmware_serial_display.asm
d7bf			include "firmware_key_serial.asm" 
d7bf			; Serial keyboard interface for SC114 
d7bf			 
d7bf			key_init: 
d7bf				; no init as handled by the SCM bios 
d7bf c9				ret 
d7c0			 
d7c0			 
d7c0			cin_wait: 
d7c0			;	ld a, 0 
d7c0			;	ret 
d7c0			 
d7c0				;in a,(SC114_SIO_1_IN) 
d7c0			        ; Use SCM API to get from whatever console device we are using 
d7c0 c5				push bc 
d7c1 0e 01			ld c, $01 
d7c3 f7				rst $30 
d7c4 c1				pop bc 
d7c5 c9				ret 
d7c6			 
d7c6			cin: 
d7c6			 
d7c6			 
d7c6 c5				push bc 
d7c7			 
d7c7				; any key waiting to process? 
d7c7 0e 03			ld c, $03 
d7c9 f7				rst $30 
d7ca 28 05			jr z, .cin_skip 
d7cc			 
d7cc				; yep, get it 
d7cc			 
d7cc 0e 01			ld c, $01 
d7ce f7				rst $30 
d7cf c1				pop bc 
d7d0 c9				ret 
d7d1			.cin_skip: 
d7d1 3e 00			ld a, 0 
d7d3 c1				pop bc 
d7d4 c9				ret 
d7d5			 
d7d5			 
d7d5			 
d7d5			 
# End of file firmware_key_serial.asm
d7d5			 
d7d5			baseram:  
d7d5			endofcode: 
d7d5 00				nop 
d7d6			 
d7d6			heap_start: equ baseram+15  ; Starting address of heap 
d7d6			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d7d6			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d7d6			; 
d7d6			 
# End of file os_mini_sc114.asm
d7d6
