# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 ed 17			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3c holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_FILERUN: equ $3c  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $3c  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ os_input  
0003			os_new_parse_len: equ os_new_malloc + 2  
0003			os_new_word_len: equ os_new_parse_len + 2  
0003			os_new_work_ptr: equ os_new_word_len + 2  
0003			os_new_src_ptr: equ os_new_work_ptr + 2  
0003			os_new_exec: equ os_new_src_ptr + 2  
0003			os_new_exec_ptr: equ os_new_exec + 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ scratch - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd 97 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd 97 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd 97 0a				call clear_display  
0023			  
0023			  
0023 cd 5b 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd f2 66			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd 6e 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 2b 13				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd ba 0a			call update_display  
0035 cd 45 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd 9c 0a			call fill_display  
003d cd ba 0a			call update_display  
0040 cd 45 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd 9c 0a			call fill_display  
0048 cd ba 0a			call update_display  
004b cd 45 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd 9c 0a			call fill_display  
0053 cd ba 0a			call update_display  
0056 cd 45 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd aa 0a			call str_at_display  
0061 cd ba 0a			call update_display  
0064			  
0064			  
0064 cd 45 0a			call delay1s  
0067 cd 45 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd aa 0a			call str_at_display  
0072 cd ba 0a			call update_display  
0075 cd 45 0a			call delay1s  
0078 cd 45 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 5d f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 5d f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 5d f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 5d f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 5d f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 5f f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 5c f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 5c f8			ld (spi_device), a 
01e3 32 5f f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 5d f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 5d f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 5d f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 5d f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 5d f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 5d f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 5d f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 5d f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 2a 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 5d f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 5d f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 5d f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 5d f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 5d f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 5d f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 5d f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 5d f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 2a 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 5d f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 5d f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 5d f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 5d f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 33 ee			ld hl,scratch+2 
02be cd 82 10			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 54 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 38 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 54 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 54 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 54 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 54 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 59 ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 59 ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 54 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 54 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 59 ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 54 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 17 16			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 17 16			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 2a 06			call storage_findnextid 
0360			 
0360 cd f4 0c			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 17 16			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 17 16			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 17 16			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 17 16			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 17 16			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b 21 62 f8			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 63 f8		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 d3 04			ld hl, .defaultbanklabl 
043a 11 65 f8		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; Append the current bank id 
0442 21 6e f8			ld hl, store_page+3+9 
0445 3a 5b f8			ld a, (spi_device_id) 
0448 77				ld (hl), a 
0449			 
0449				; save default page 0 
0449			 
0449 21 00 00			ld hl, 0 
044c 11 62 f8			ld de, store_page 
044f				if DEBUG_STORESE 
044f					DMARK "SB3" 
044f f5				push af  
0450 3a 64 04			ld a, (.dmark)  
0453 32 77 fb			ld (debug_mark),a  
0456 3a 65 04			ld a, (.dmark+1)  
0459 32 78 fb			ld (debug_mark+1),a  
045c 3a 66 04			ld a, (.dmark+2)  
045f 32 79 fb			ld (debug_mark+2),a  
0462 18 03			jr .pastdmark  
0464 ..			.dmark: db "SB3"  
0467 f1			.pastdmark: pop af  
0468			endm  
# End of macro DMARK
0468			;		push af 
0468			;		ld a, 'F' 
0468			;		ld (debug_mark),a 
0468			;		pop af 
0468					CALLMONITOR 
0468 cd 17 16			call break_point_state  
046b				endm  
# End of macro CALLMONITOR
046b				endif 
046b cd 71 03			call storage_write_block 
046e				if DEBUG_STORESE 
046e					DMARK "SB4" 
046e f5				push af  
046f 3a 83 04			ld a, (.dmark)  
0472 32 77 fb			ld (debug_mark),a  
0475 3a 84 04			ld a, (.dmark+1)  
0478 32 78 fb			ld (debug_mark+1),a  
047b 3a 85 04			ld a, (.dmark+2)  
047e 32 79 fb			ld (debug_mark+2),a  
0481 18 03			jr .pastdmark  
0483 ..			.dmark: db "SB4"  
0486 f1			.pastdmark: pop af  
0487			endm  
# End of macro DMARK
0487			;		push af 
0487			;		ld a, '>' 
0487			;		ld (debug_mark),a 
0487			;		pop af 
0487					CALLMONITOR 
0487 cd 17 16			call break_point_state  
048a				endm  
# End of macro CALLMONITOR
048a				endif 
048a			 
048a 00				nop 
048b 00				nop 
048c 00				nop 
048d			 
048d				; now set 0 in every page to mark as a free block 
048d			 
048d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048f 21 40 00			ld hl, STORE_BLOCK_PHY 
0492			 
0492 3e 00		.setmark1:   	ld a,0 
0494 e5					push hl 
0495 c5					push bc 
0496 cd ea 01				call se_writebyte 
0499 3e 0a			ld a, 10 
049b cd 2a 0a			call aDelayInMS 
049e 23				inc hl 
049f cd ea 01				call se_writebyte 
04a2 3e 0a			ld a, 10 
04a4 cd 2a 0a			call aDelayInMS 
04a7 2b				dec hl 
04a8 c1					pop bc 
04a9 e1					pop hl 
04aa 3e 40				ld a, STORE_BLOCK_PHY 
04ac cd cb 0c				call addatohl 
04af 10 e1				djnz .setmark1 
04b1			 
04b1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b3 3e 00		.setmark2:   	ld a,0 
04b5 e5					push hl 
04b6 c5					push bc 
04b7 cd ea 01				call se_writebyte 
04ba 3e 0a			ld a, 10 
04bc cd 2a 0a			call aDelayInMS 
04bf 23				inc hl 
04c0 cd ea 01				call se_writebyte 
04c3 3e 0a			ld a, 10 
04c5 cd 2a 0a			call aDelayInMS 
04c8 2b				dec hl 
04c9 c1					pop bc 
04ca e1					pop hl 
04cb 3e 40				ld a, STORE_BLOCK_PHY 
04cd cd cb 0c				call addatohl 
04d0 10 e1				djnz .setmark2 
04d2			 
04d2					 
04d2			 
04d2			 
04d2 c9				ret 
04d3			 
04d3			 
04d3			 
04d3			 
04d3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04de			 
04de			 
04de			 
04de			; Label Bank 
04de			; ---------- 
04de			; 
04de			; With current bank 
04de			; Read block 0 
04de			; Set label 
04de			; Write block 0 
04de			 
04de			; label str pointer in hl 
04de			 
04de			storage_label:     
04de			 
04de				if DEBUG_STORESE 
04de					DMARK "LBL" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 77 fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 78 fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 79 fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LBL"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd 17 16			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa			 
04fa e5				push hl 
04fb			 
04fb cd bd 03			call storage_get_block_0 
04fe			 
04fe				; set default label 
04fe			 
04fe e1				pop hl 
04ff			 
04ff 11 65 f8		 	ld de, store_page+3 
0502 01 0f 00			ld bc, 15 
0505				if DEBUG_STORESE 
0505					DMARK "LB3" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 77 fb			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 78 fb			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 79 fb			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "LB3"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e					CALLMONITOR 
051e cd 17 16			call break_point_state  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 ed b0			ldir 
0523				; save default page 0 
0523			 
0523 21 00 00			ld hl, 0 
0526 11 62 f8			ld de, store_page 
0529				if DEBUG_STORESE 
0529					DMARK "LBW" 
0529 f5				push af  
052a 3a 3e 05			ld a, (.dmark)  
052d 32 77 fb			ld (debug_mark),a  
0530 3a 3f 05			ld a, (.dmark+1)  
0533 32 78 fb			ld (debug_mark+1),a  
0536 3a 40 05			ld a, (.dmark+2)  
0539 32 79 fb			ld (debug_mark+2),a  
053c 18 03			jr .pastdmark  
053e ..			.dmark: db "LBW"  
0541 f1			.pastdmark: pop af  
0542			endm  
# End of macro DMARK
0542					CALLMONITOR 
0542 cd 17 16			call break_point_state  
0545				endm  
# End of macro CALLMONITOR
0545				endif 
0545 cd 71 03			call storage_write_block 
0548			 
0548 c9				ret 
0549			 
0549			 
0549			 
0549			; Read Block 0 - Config 
0549			; --------------------- 
0549			; 
0549			; With current bank 
0549			; Call presence test 
0549			;    If not present format/init bank  
0549			; Read block 0  
0549			;  
0549			 
0549			 
0549			; Dir 
0549			; --- 
0549			; 
0549			; With current bank 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block read byte 2 
0549			;      if first block of file 
0549			;         Display file name 
0549			;         Display type flags for file 
0549			;        
0549			 
0549			; moving to words as this requires stack control 
0549			 
0549			 
0549			; Delete File 
0549			; ----------- 
0549			; 
0549			; With current bank 
0549			; 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block file id 
0549			;      If first block of file and dont have file id 
0549			;         if file to delete 
0549			;         Save file id 
0549			;         Null file id 
0549			;         Write this block back 
0549			;      If file id is one saved 
0549			;         Null file id 
0549			;         Write this block back 
0549			 
0549			storage_erase: 
0549			 
0549				; hl contains the file id 
0549			 
0549 5d				ld e, l 
054a 16 00			ld d, 0 
054c 21 40 00			ld hl, STORE_BLOCK_PHY 
054f					if DEBUG_FORTH_WORDS 
054f						DMARK "ERA" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 77 fb			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 78 fb			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 79 fb			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "ERA"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568						CALLMONITOR 
0568 cd 17 16			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b cd 2a 06			call storage_findnextid 
056e			 
056e e5				push hl 
056f			 
056f				; TODO check file not found 
056f			 
056f 11 62 f8			ld de, store_page 
0572 cd 0c 03			call storage_read_block 
0575			 
0575					if DEBUG_FORTH_WORDS 
0575						DMARK "ER1" 
0575 f5				push af  
0576 3a 8a 05			ld a, (.dmark)  
0579 32 77 fb			ld (debug_mark),a  
057c 3a 8b 05			ld a, (.dmark+1)  
057f 32 78 fb			ld (debug_mark+1),a  
0582 3a 8c 05			ld a, (.dmark+2)  
0585 32 79 fb			ld (debug_mark+2),a  
0588 18 03			jr .pastdmark  
058a ..			.dmark: db "ER1"  
058d f1			.pastdmark: pop af  
058e			endm  
# End of macro DMARK
058e						CALLMONITOR 
058e cd 17 16			call break_point_state  
0591				endm  
# End of macro CALLMONITOR
0591					endif 
0591 3a 62 f8			ld a, (store_page)	; get file id 
0594 32 5b f8			ld (store_tmpid), a 
0597			 
0597 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
059a 32 5a f8			ld (store_tmpext), a 
059d			 
059d				; wipe file header 
059d			 
059d e1				pop hl 
059e 3e 00			ld a, 0 
05a0 32 62 f8			ld (store_page), a 
05a3 32 63 f8			ld (store_page+1),a 
05a6 11 62 f8			ld de, store_page 
05a9					if DEBUG_FORTH_WORDS 
05a9						DMARK "ER2" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 77 fb			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 78 fb			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 79 fb			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "ER2"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2						CALLMONITOR 
05c2 cd 17 16			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5					endif 
05c5 cd 71 03			call storage_write_block 
05c8			 
05c8			 
05c8				; wipe file extents 
05c8			 
05c8 3a 5a f8			ld a, (store_tmpext) 
05cb 47				ld b, a 
05cc			 
05cc			.eraext:	  
05cc c5				push bc 
05cd			 
05cd 21 40 00			ld hl, STORE_BLOCK_PHY 
05d0 3a 5b f8			ld a,(store_tmpid) 
05d3 5f				ld e, a 
05d4 50				ld d, b	 
05d5					if DEBUG_FORTH_WORDS 
05d5						DMARK "ER3" 
05d5 f5				push af  
05d6 3a ea 05			ld a, (.dmark)  
05d9 32 77 fb			ld (debug_mark),a  
05dc 3a eb 05			ld a, (.dmark+1)  
05df 32 78 fb			ld (debug_mark+1),a  
05e2 3a ec 05			ld a, (.dmark+2)  
05e5 32 79 fb			ld (debug_mark+2),a  
05e8 18 03			jr .pastdmark  
05ea ..			.dmark: db "ER3"  
05ed f1			.pastdmark: pop af  
05ee			endm  
# End of macro DMARK
05ee						CALLMONITOR 
05ee cd 17 16			call break_point_state  
05f1				endm  
# End of macro CALLMONITOR
05f1					endif 
05f1 cd 2a 06			call storage_findnextid 
05f4			 
05f4 e5				push hl 
05f5 11 62 f8			ld de, store_page 
05f8 cd 0c 03			call storage_read_block 
05fb			 
05fb				; free block	 
05fb			 
05fb 3e 00			ld a, 0 
05fd 32 62 f8			ld (store_page), a 
0600 32 63 f8			ld (store_page+1),a 
0603 11 62 f8			ld de, store_page 
0606 e1				pop hl 
0607					if DEBUG_FORTH_WORDS 
0607						DMARK "ER4" 
0607 f5				push af  
0608 3a 1c 06			ld a, (.dmark)  
060b 32 77 fb			ld (debug_mark),a  
060e 3a 1d 06			ld a, (.dmark+1)  
0611 32 78 fb			ld (debug_mark+1),a  
0614 3a 1e 06			ld a, (.dmark+2)  
0617 32 79 fb			ld (debug_mark+2),a  
061a 18 03			jr .pastdmark  
061c ..			.dmark: db "ER4"  
061f f1			.pastdmark: pop af  
0620			endm  
# End of macro DMARK
0620						CALLMONITOR 
0620 cd 17 16			call break_point_state  
0623				endm  
# End of macro CALLMONITOR
0623					endif 
0623 cd 71 03			call storage_write_block 
0626			 
0626 c1				pop bc 
0627 10 a3			djnz .eraext 
0629			 
0629 c9				ret 
062a			 
062a			 
062a			; Find Free Block 
062a			; --------------- 
062a			; 
062a			; With current bank 
062a			;  
062a			; From given starting logical block 
062a			;    Read block  
062a			;    If no file id 
062a			;         Return block id 
062a			 
062a			 
062a			; hl starting page number 
062a			; hl contains free page number or zero if no pages free 
062a			; e contains the file id to locate 
062a			; d contains the block number 
062a			 
062a			; TODO change to find file id and use zero for free block 
062a			 
062a			storage_findnextid: 
062a			 
062a				; now locate first 0 page to mark as a free block 
062a			 
062a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062c			;	ld hl, STORE_BLOCK_PHY 
062c			 
062c					if DEBUG_FORTH_WORDS 
062c					DMARK "FNI" 
062c f5				push af  
062d 3a 41 06			ld a, (.dmark)  
0630 32 77 fb			ld (debug_mark),a  
0633 3a 42 06			ld a, (.dmark+1)  
0636 32 78 fb			ld (debug_mark+1),a  
0639 3a 43 06			ld a, (.dmark+2)  
063c 32 79 fb			ld (debug_mark+2),a  
063f 18 03			jr .pastdmark  
0641 ..			.dmark: db "FNI"  
0644 f1			.pastdmark: pop af  
0645			endm  
# End of macro DMARK
0645						CALLMONITOR 
0645 cd 17 16			call break_point_state  
0648				endm  
# End of macro CALLMONITOR
0648					endif 
0648			.ff1:   	 
0648 e5					push hl 
0649 c5					push bc 
064a d5					push de 
064b cd 8c 02				call se_readbyte 
064e 5f					ld e,a 
064f 23					inc hl 
0650 cd 8c 02				call se_readbyte 
0653 57					ld d, a 
0654 e1					pop hl 
0655 e5					push hl 
0656 cd e9 0c				call cmp16 
0659 28 49				jr z, .fffound 
065b			 
065b d1					pop de 
065c c1					pop bc 
065d e1					pop hl 
065e			 
065e					; is found? 
065e					;cp e 
065e					;ret z 
065e			 
065e 3e 40				ld a, STORE_BLOCK_PHY 
0660 cd cb 0c				call addatohl 
0663 10 e3				djnz .ff1 
0665			 
0665 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0667			.ff2:   	 
0667			 
0667 e5					push hl 
0668 c5					push bc 
0669 d5					push de 
066a cd 8c 02				call se_readbyte 
066d 5f					ld e,a 
066e 23					inc hl 
066f cd 8c 02				call se_readbyte 
0672 57					ld d, a 
0673			 
0673 e1					pop hl 
0674 e5					push hl 
0675 cd e9 0c				call cmp16 
0678 28 2a				jr z, .fffound 
067a			 
067a d1					pop de 
067b c1					pop bc 
067c e1					pop hl 
067d					; is found? 
067d					;cp e 
067d					;ret z 
067d			 
067d 3e 40				ld a, STORE_BLOCK_PHY 
067f cd cb 0c				call addatohl 
0682 10 e3				djnz .ff2 
0684			 
0684			 
0684					if DEBUG_FORTH_WORDS 
0684					DMARK "FN-" 
0684 f5				push af  
0685 3a 99 06			ld a, (.dmark)  
0688 32 77 fb			ld (debug_mark),a  
068b 3a 9a 06			ld a, (.dmark+1)  
068e 32 78 fb			ld (debug_mark+1),a  
0691 3a 9b 06			ld a, (.dmark+2)  
0694 32 79 fb			ld (debug_mark+2),a  
0697 18 03			jr .pastdmark  
0699 ..			.dmark: db "FN-"  
069c f1			.pastdmark: pop af  
069d			endm  
# End of macro DMARK
069d					;	push af 
069d					;	ld a, 'n' 
069d					;	ld (debug_mark),a 
069d					;	pop af 
069d						CALLMONITOR 
069d cd 17 16			call break_point_state  
06a0				endm  
# End of macro CALLMONITOR
06a0					endif 
06a0				; no free marks! 
06a0 21 00 00				ld hl, 0 
06a3 c9				ret 
06a4			.fffound: 
06a4				 
06a4			 
06a4 d1					pop de 
06a5 c1					pop bc 
06a6 e1					pop hl 
06a7					if DEBUG_FORTH_WORDS 
06a7					DMARK "FNF" 
06a7 f5				push af  
06a8 3a bc 06			ld a, (.dmark)  
06ab 32 77 fb			ld (debug_mark),a  
06ae 3a bd 06			ld a, (.dmark+1)  
06b1 32 78 fb			ld (debug_mark+1),a  
06b4 3a be 06			ld a, (.dmark+2)  
06b7 32 79 fb			ld (debug_mark+2),a  
06ba 18 03			jr .pastdmark  
06bc ..			.dmark: db "FNF"  
06bf f1			.pastdmark: pop af  
06c0			endm  
# End of macro DMARK
06c0					;	push af 
06c0					;	ld a, 'n' 
06c0					;	ld (debug_mark),a 
06c0					;	pop af 
06c0						CALLMONITOR 
06c0 cd 17 16			call break_point_state  
06c3				endm  
# End of macro CALLMONITOR
06c3					endif 
06c3 c9				ret 
06c4			 
06c4			 
06c4			 
06c4			; Free Space 
06c4			; ---------- 
06c4			; 
06c4			; With current bank 
06c4			; 
06c4			; Set block count to zero 
06c4			; Starting with first logical block 
06c4			;      Find free block  
06c4			;      If block id given, increment block count 
06c4			; 
06c4			;  
06c4			 
06c4			 
06c4			; hl contains count of free blocks 
06c4			 
06c4			storage_freeblocks: 
06c4			 
06c4				; now locate first 0 page to mark as a free block 
06c4			 
06c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c6 21 40 00			ld hl, STORE_BLOCK_PHY 
06c9 11 00 00			ld de, 0 
06cc			 
06cc			.fb1:   	 
06cc e5					push hl 
06cd c5					push bc 
06ce d5					push de 
06cf cd 8c 02				call se_readbyte 
06d2 d1					pop de 
06d3 c1					pop bc 
06d4 e1					pop hl 
06d5			 
06d5					; is free? 
06d5 fe 00				cp 0 
06d7 20 01				jr nz, .ff1cont 
06d9 13					inc de 
06da			 
06da			.ff1cont: 
06da			 
06da			 
06da 3e 40				ld a, STORE_BLOCK_PHY 
06dc cd cb 0c				call addatohl 
06df 10 eb				djnz .fb1 
06e1			 
06e1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e3			.fb2:   	 
06e3 e5					push hl 
06e4 c5					push bc 
06e5 d5					push de 
06e6 cd 8c 02				call se_readbyte 
06e9 d1					pop de 
06ea c1					pop bc 
06eb e1					pop hl 
06ec			 
06ec					; is free? 
06ec fe 00				cp 0 
06ee 20 01				jr nz, .ff2cont 
06f0 13					inc de 
06f1			 
06f1			.ff2cont: 
06f1			 
06f1 3e 40				ld a, STORE_BLOCK_PHY 
06f3 cd cb 0c				call addatohl 
06f6 10 eb				djnz .fb2 
06f8			 
06f8 eb				ex de, hl 
06f9 c9				ret 
06fa			 
06fa			; Get File ID 
06fa			; ----------- 
06fa			; 
06fa			; With current bank 
06fa			;  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; For each logical block 
06fa			;    Read block file id 
06fa			;      If first block of file and dont have file id 
06fa			;         if file get id and exit 
06fa			 
06fa			 
06fa			 
06fa			 
06fa			; Create File 
06fa			; ----------- 
06fa			; 
06fa			; With current bank  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; Increment file id number 
06fa			; Save Config 
06fa			; Find free block 
06fa			; Set buffer with file name and file id 
06fa			; Write buffer to free block  
06fa			 
06fa			 
06fa			; hl point to file name 
06fa			; hl returns file id 
06fa			 
06fa			; file format: 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent number 
06fa			; byte 2-> data 
06fa			 
06fa			; format for extent number 0: 
06fa			; 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent 0 
06fa			; byte 2 - extent count 
06fa			; byte 3 -> file name and meta data 
06fa			 
06fa			 
06fa			storage_create: 
06fa				if DEBUG_STORESE 
06fa					DMARK "SCR" 
06fa f5				push af  
06fb 3a 0f 07			ld a, (.dmark)  
06fe 32 77 fb			ld (debug_mark),a  
0701 3a 10 07			ld a, (.dmark+1)  
0704 32 78 fb			ld (debug_mark+1),a  
0707 3a 11 07			ld a, (.dmark+2)  
070a 32 79 fb			ld (debug_mark+2),a  
070d 18 03			jr .pastdmark  
070f ..			.dmark: db "SCR"  
0712 f1			.pastdmark: pop af  
0713			endm  
# End of macro DMARK
0713					CALLMONITOR 
0713 cd 17 16			call break_point_state  
0716				endm  
# End of macro CALLMONITOR
0716				endif 
0716			 
0716 e5				push hl		; save file name pointer 
0717			 
0717 cd bd 03			call storage_get_block_0 
071a			 
071a 3a 62 f8			ld a,(store_page)	; get current file id 
071d 3c				inc a 
071e 32 62 f8			ld (store_page),a 
0721				 
0721 32 5b f8			ld (store_tmpid),a			; save id 
0724			 
0724 21 00 00			ld hl, 0 
0727 11 62 f8			ld de, store_page 
072a				if DEBUG_STORESE 
072a					DMARK "SCw" 
072a f5				push af  
072b 3a 3f 07			ld a, (.dmark)  
072e 32 77 fb			ld (debug_mark),a  
0731 3a 40 07			ld a, (.dmark+1)  
0734 32 78 fb			ld (debug_mark+1),a  
0737 3a 41 07			ld a, (.dmark+2)  
073a 32 79 fb			ld (debug_mark+2),a  
073d 18 03			jr .pastdmark  
073f ..			.dmark: db "SCw"  
0742 f1			.pastdmark: pop af  
0743			endm  
# End of macro DMARK
0743					CALLMONITOR 
0743 cd 17 16			call break_point_state  
0746				endm  
# End of macro CALLMONITOR
0746				endif 
0746 cd 71 03			call storage_write_block	 ; save update 
0749			 
0749				if DEBUG_STORESE 
0749 11 62 f8				ld de, store_page 
074c					DMARK "SCC" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 77 fb			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 78 fb			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 79 fb			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "SCC"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765					CALLMONITOR 
0765 cd 17 16			call break_point_state  
0768				endm  
# End of macro CALLMONITOR
0768				endif 
0768				;  
0768				 
0768 21 40 00			ld hl, STORE_BLOCK_PHY 
076b 11 00 00			ld de, 0 
076e cd 2a 06			call storage_findnextid 
0771			 
0771 22 60 f8			ld (store_tmppageid), hl    ; save page to use  
0774			 
0774				; TODO detect 0 = no spare blocks 
0774			 
0774				; hl now contains the free page to use for the file header page 
0774			 
0774				if DEBUG_STORESE 
0774				DMARK "SCF" 
0774 f5				push af  
0775 3a 89 07			ld a, (.dmark)  
0778 32 77 fb			ld (debug_mark),a  
077b 3a 8a 07			ld a, (.dmark+1)  
077e 32 78 fb			ld (debug_mark+1),a  
0781 3a 8b 07			ld a, (.dmark+2)  
0784 32 79 fb			ld (debug_mark+2),a  
0787 18 03			jr .pastdmark  
0789 ..			.dmark: db "SCF"  
078c f1			.pastdmark: pop af  
078d			endm  
# End of macro DMARK
078d					CALLMONITOR 
078d cd 17 16			call break_point_state  
0790				endm  
# End of macro CALLMONITOR
0790				endif 
0790			 
0790 22 60 f8			ld (store_tmppageid), hl 
0793				 
0793 3a 5b f8			ld a,(store_tmpid)    ; get file id 
0796			;	ld a, (store_filecache)			; save to cache 
0796			 
0796 32 62 f8			ld (store_page),a    ; set page id 
0799 3e 00			ld a, 0			 ; extent 0 is file header 
079b 32 63 f8			ld (store_page+1), a   ; set file extent 
079e			 
079e 32 64 f8			ld (store_page+2), a   ; extent count for the file 
07a1			 
07a1			;	inc hl 		; init block 0 of file 
07a1			;	inc hl   		; skip file and extent id 
07a1			 ;       ld a, 0 
07a1			;	ld (hl),a 
07a1			;	ld a, (store_filecache+1)  	; save to cache 
07a1			 
07a1			;	inc hl    ; file name 
07a1				 
07a1				 
07a1 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
07a4				if DEBUG_STORESE 
07a4					DMARK "SCc" 
07a4 f5				push af  
07a5 3a b9 07			ld a, (.dmark)  
07a8 32 77 fb			ld (debug_mark),a  
07ab 3a ba 07			ld a, (.dmark+1)  
07ae 32 78 fb			ld (debug_mark+1),a  
07b1 3a bb 07			ld a, (.dmark+2)  
07b4 32 79 fb			ld (debug_mark+2),a  
07b7 18 03			jr .pastdmark  
07b9 ..			.dmark: db "SCc"  
07bc f1			.pastdmark: pop af  
07bd			endm  
# End of macro DMARK
07bd					CALLMONITOR 
07bd cd 17 16			call break_point_state  
07c0				endm  
# End of macro CALLMONITOR
07c0				endif 
07c0 e1				pop hl    ; get zero term string 
07c1 e5				push hl 
07c2 3e 00			ld a, 0 
07c4 cd 34 11			call strlent 
07c7 23				inc hl   ; cover zero term 
07c8 06 00			ld b,0 
07ca 4d				ld c,l 
07cb e1				pop hl 
07cc				;ex de, hl 
07cc				if DEBUG_STORESE 
07cc					DMARK "SCa" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 77 fb			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 78 fb			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 79 fb			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "SCa"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;push af 
07e5					;ld a, 'a' 
07e5					;ld (debug_mark),a 
07e5					;pop af 
07e5					CALLMONITOR 
07e5 cd 17 16			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8				endif 
07e8 ed b0			ldir    ; copy zero term string 
07ea				if DEBUG_STORESE 
07ea					DMARK "SCA" 
07ea f5				push af  
07eb 3a ff 07			ld a, (.dmark)  
07ee 32 77 fb			ld (debug_mark),a  
07f1 3a 00 08			ld a, (.dmark+1)  
07f4 32 78 fb			ld (debug_mark+1),a  
07f7 3a 01 08			ld a, (.dmark+2)  
07fa 32 79 fb			ld (debug_mark+2),a  
07fd 18 03			jr .pastdmark  
07ff ..			.dmark: db "SCA"  
0802 f1			.pastdmark: pop af  
0803			endm  
# End of macro DMARK
0803					CALLMONITOR 
0803 cd 17 16			call break_point_state  
0806				endm  
# End of macro CALLMONITOR
0806				endif 
0806			 
0806				; write file header page 
0806			 
0806 2a 60 f8			ld hl,(store_tmppageid) 
0809 11 62 f8			ld de, store_page 
080c				if DEBUG_STORESE 
080c					DMARK "SCb" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 77 fb			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 78 fb			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 79 fb			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "SCb"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					;push af 
0825					;ld a, 'b' 
0825					;ld (debug_mark),a 
0825					;pop af 
0825					CALLMONITOR 
0825 cd 17 16			call break_point_state  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 71 03			call storage_write_block 
082b			 
082b 3a 5b f8			ld a, (store_tmpid) 
082e 6f				ld l, a 
082f 26 00			ld h,0 
0831				if DEBUG_STORESE 
0831					DMARK "SCz" 
0831 f5				push af  
0832 3a 46 08			ld a, (.dmark)  
0835 32 77 fb			ld (debug_mark),a  
0838 3a 47 08			ld a, (.dmark+1)  
083b 32 78 fb			ld (debug_mark+1),a  
083e 3a 48 08			ld a, (.dmark+2)  
0841 32 79 fb			ld (debug_mark+2),a  
0844 18 03			jr .pastdmark  
0846 ..			.dmark: db "SCz"  
0849 f1			.pastdmark: pop af  
084a			endm  
# End of macro DMARK
084a					CALLMONITOR 
084a cd 17 16			call break_point_state  
084d				endm  
# End of macro CALLMONITOR
084d				endif 
084d c9				ret 
084e				 
084e			 
084e			 
084e			; 
084e			; Read File 
084e			; 
084e			; h - file id to locate 
084e			; l - extent to locate 
084e			; de - pointer to string to read into 
084e			; 
084e			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
084e			storage_read: 
084e d5				push de 
084f			 
084f			; TODO BUG the above push is it popped before the RET Z? 
084f			 
084f			; TODO how to handle multiple part blocks 
084f			 
084f				; locate file extent to read 
084f			 
084f 5c				ld e, h 
0850 55				ld d, l 
0851 21 40 00			ld hl, STORE_BLOCK_PHY 
0854				if DEBUG_STORESE 
0854					DMARK "SRE" 
0854 f5				push af  
0855 3a 69 08			ld a, (.dmark)  
0858 32 77 fb			ld (debug_mark),a  
085b 3a 6a 08			ld a, (.dmark+1)  
085e 32 78 fb			ld (debug_mark+1),a  
0861 3a 6b 08			ld a, (.dmark+2)  
0864 32 79 fb			ld (debug_mark+2),a  
0867 18 03			jr .pastdmark  
0869 ..			.dmark: db "SRE"  
086c f1			.pastdmark: pop af  
086d			endm  
# End of macro DMARK
086d					CALLMONITOR 
086d cd 17 16			call break_point_state  
0870				endm  
# End of macro CALLMONITOR
0870				endif 
0870 cd 2a 06			call storage_findnextid 
0873			 
0873				if DEBUG_STORESE 
0873					DMARK "SRf" 
0873 f5				push af  
0874 3a 88 08			ld a, (.dmark)  
0877 32 77 fb			ld (debug_mark),a  
087a 3a 89 08			ld a, (.dmark+1)  
087d 32 78 fb			ld (debug_mark+1),a  
0880 3a 8a 08			ld a, (.dmark+2)  
0883 32 79 fb			ld (debug_mark+2),a  
0886 18 03			jr .pastdmark  
0888 ..			.dmark: db "SRf"  
088b f1			.pastdmark: pop af  
088c			endm  
# End of macro DMARK
088c					CALLMONITOR 
088c cd 17 16			call break_point_state  
088f				endm  
# End of macro CALLMONITOR
088f				endif 
088f cd f4 0c			call ishlzero 
0892			;	ld a, l 
0892			;	add h 
0892			;	cp 0 
0892 c8				ret z			; block not found so EOF 
0893			 
0893				; hl contains page number to load 
0893 d1				pop de   ; get storage 
0894 d5				push de 
0895				if DEBUG_STORESE 
0895					DMARK "SRg" 
0895 f5				push af  
0896 3a aa 08			ld a, (.dmark)  
0899 32 77 fb			ld (debug_mark),a  
089c 3a ab 08			ld a, (.dmark+1)  
089f 32 78 fb			ld (debug_mark+1),a  
08a2 3a ac 08			ld a, (.dmark+2)  
08a5 32 79 fb			ld (debug_mark+2),a  
08a8 18 03			jr .pastdmark  
08aa ..			.dmark: db "SRg"  
08ad f1			.pastdmark: pop af  
08ae			endm  
# End of macro DMARK
08ae					CALLMONITOR 
08ae cd 17 16			call break_point_state  
08b1				endm  
# End of macro CALLMONITOR
08b1				endif 
08b1 cd 0c 03			call storage_read_block 
08b4			 
08b4			 
08b4			; TODO if block has no zeros then need to read next block  
08b4			 
08b4			 
08b4					 
08b4 e1				pop hl 		 ; return start of data to show as not EOF 
08b5 23				inc hl   ; past file id 
08b6 23				inc hl   ; past ext 
08b7				if DEBUG_STORESE 
08b7					DMARK "SRe" 
08b7 f5				push af  
08b8 3a cc 08			ld a, (.dmark)  
08bb 32 77 fb			ld (debug_mark),a  
08be 3a cd 08			ld a, (.dmark+1)  
08c1 32 78 fb			ld (debug_mark+1),a  
08c4 3a ce 08			ld a, (.dmark+2)  
08c7 32 79 fb			ld (debug_mark+2),a  
08ca 18 03			jr .pastdmark  
08cc ..			.dmark: db "SRe"  
08cf f1			.pastdmark: pop af  
08d0			endm  
# End of macro DMARK
08d0					CALLMONITOR 
08d0 cd 17 16			call break_point_state  
08d3				endm  
# End of macro CALLMONITOR
08d3				endif 
08d3 c9					ret 
08d4			 
08d4			 
08d4			 
08d4			; 
08d4			; Append File 
08d4			; 
08d4			; hl - file id to locate 
08d4			; de - pointer to (multi block) string to write 
08d4			 
08d4			 
08d4			storage_append: 
08d4				; hl -  file id to append to 
08d4				; de - string to append 
08d4			 
08d4 d5				push de 
08d5				 
08d5				if DEBUG_STORESE 
08d5					DMARK "AP1" 
08d5 f5				push af  
08d6 3a ea 08			ld a, (.dmark)  
08d9 32 77 fb			ld (debug_mark),a  
08dc 3a eb 08			ld a, (.dmark+1)  
08df 32 78 fb			ld (debug_mark+1),a  
08e2 3a ec 08			ld a, (.dmark+2)  
08e5 32 79 fb			ld (debug_mark+2),a  
08e8 18 03			jr .pastdmark  
08ea ..			.dmark: db "AP1"  
08ed f1			.pastdmark: pop af  
08ee			endm  
# End of macro DMARK
08ee					CALLMONITOR 
08ee cd 17 16			call break_point_state  
08f1				endm  
# End of macro CALLMONITOR
08f1				endif 
08f1			 
08f1 7d				ld a, l 
08f2 32 5b f8			ld (store_tmpid), a 
08f5			 
08f5				; get file header  
08f5			 
08f5 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08f7 3a 5b f8			ld a, (store_tmpid) 
08fa 5f				ld e, a 
08fb			 
08fb 21 40 00				ld hl, STORE_BLOCK_PHY 
08fe cd 2a 06				call storage_findnextid 
0901			 
0901 22 60 f8			ld (store_tmppageid), hl 
0904			 
0904				; TODO handle file id not found 
0904			 
0904				if DEBUG_STORESE 
0904					DMARK "AP2" 
0904 f5				push af  
0905 3a 19 09			ld a, (.dmark)  
0908 32 77 fb			ld (debug_mark),a  
090b 3a 1a 09			ld a, (.dmark+1)  
090e 32 78 fb			ld (debug_mark+1),a  
0911 3a 1b 09			ld a, (.dmark+2)  
0914 32 79 fb			ld (debug_mark+2),a  
0917 18 03			jr .pastdmark  
0919 ..			.dmark: db "AP2"  
091c f1			.pastdmark: pop af  
091d			endm  
# End of macro DMARK
091d					CALLMONITOR 
091d cd 17 16			call break_point_state  
0920				endm  
# End of macro CALLMONITOR
0920				endif 
0920			 
0920				; update file extent count 
0920			 
0920 11 62 f8			ld de, store_page 
0923			 
0923 cd 0c 03			call storage_read_block 
0926			 
0926				if DEBUG_STORESE 
0926					DMARK "AP3" 
0926 f5				push af  
0927 3a 3b 09			ld a, (.dmark)  
092a 32 77 fb			ld (debug_mark),a  
092d 3a 3c 09			ld a, (.dmark+1)  
0930 32 78 fb			ld (debug_mark+1),a  
0933 3a 3d 09			ld a, (.dmark+2)  
0936 32 79 fb			ld (debug_mark+2),a  
0939 18 03			jr .pastdmark  
093b ..			.dmark: db "AP3"  
093e f1			.pastdmark: pop af  
093f			endm  
# End of macro DMARK
093f					CALLMONITOR 
093f cd 17 16			call break_point_state  
0942				endm  
# End of macro CALLMONITOR
0942				endif 
0942			;	ld (store_tmppageid), hl 
0942			 
0942 3a 64 f8			ld a, (store_page+2) 
0945 3c				inc a 
0946 32 64 f8			ld (store_page+2), a 
0949 32 5a f8			ld (store_tmpext), a 
094c				 
094c				if DEBUG_STORESE 
094c					DMARK "AP3" 
094c f5				push af  
094d 3a 61 09			ld a, (.dmark)  
0950 32 77 fb			ld (debug_mark),a  
0953 3a 62 09			ld a, (.dmark+1)  
0956 32 78 fb			ld (debug_mark+1),a  
0959 3a 63 09			ld a, (.dmark+2)  
095c 32 79 fb			ld (debug_mark+2),a  
095f 18 03			jr .pastdmark  
0961 ..			.dmark: db "AP3"  
0964 f1			.pastdmark: pop af  
0965			endm  
# End of macro DMARK
0965					CALLMONITOR 
0965 cd 17 16			call break_point_state  
0968				endm  
# End of macro CALLMONITOR
0968				endif 
0968 2a 60 f8			ld hl, (store_tmppageid) 
096b 11 62 f8			ld de, store_page 
096e cd 71 03			call storage_write_block 
0971			 
0971				; find free block 
0971			 
0971 11 00 00			ld de, 0			 ; file extent to locate 
0974			 
0974 21 40 00				ld hl, STORE_BLOCK_PHY 
0977 cd 2a 06				call storage_findnextid 
097a			 
097a					; TODO handle no space left 
097a					 
097a 22 60 f8				ld (store_tmppageid), hl 
097d			 
097d				if DEBUG_STORESE 
097d					DMARK "AP4" 
097d f5				push af  
097e 3a 92 09			ld a, (.dmark)  
0981 32 77 fb			ld (debug_mark),a  
0984 3a 93 09			ld a, (.dmark+1)  
0987 32 78 fb			ld (debug_mark+1),a  
098a 3a 94 09			ld a, (.dmark+2)  
098d 32 79 fb			ld (debug_mark+2),a  
0990 18 03			jr .pastdmark  
0992 ..			.dmark: db "AP4"  
0995 f1			.pastdmark: pop af  
0996			endm  
# End of macro DMARK
0996					CALLMONITOR 
0996 cd 17 16			call break_point_state  
0999				endm  
# End of macro CALLMONITOR
0999				endif 
0999					; init the buffer with zeros so we can id if the buffer is full or not 
0999			 
0999 e5					push hl 
099a c5					push bc 
099b			 
099b 21 62 f8				ld hl, store_page 
099e 06 40				ld b, STORE_BLOCK_PHY 
09a0 3e 00				ld a, 0 
09a2 77			.zeroblock:	ld (hl), a 
09a3 23					inc hl 
09a4 10 fc				djnz .zeroblock 
09a6			 
09a6 c1					pop bc 
09a7 e1					pop hl 
09a8			 
09a8					; construct block 
09a8			 
09a8 3a 5b f8				ld a, (store_tmpid) 
09ab 32 62 f8				ld (store_page), a   ; file id 
09ae 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09b1 32 63 f8				ld (store_page+1), a 
09b4			 
09b4 e1					pop hl    ; get string to write 
09b5 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09b7 11 64 f8				ld de, store_page+2 
09ba			 
09ba				if DEBUG_STORESE 
09ba					DMARK "AP5" 
09ba f5				push af  
09bb 3a cf 09			ld a, (.dmark)  
09be 32 77 fb			ld (debug_mark),a  
09c1 3a d0 09			ld a, (.dmark+1)  
09c4 32 78 fb			ld (debug_mark+1),a  
09c7 3a d1 09			ld a, (.dmark+2)  
09ca 32 79 fb			ld (debug_mark+2),a  
09cd 18 03			jr .pastdmark  
09cf ..			.dmark: db "AP5"  
09d2 f1			.pastdmark: pop af  
09d3			endm  
# End of macro DMARK
09d3					CALLMONITOR 
09d3 cd 17 16			call break_point_state  
09d6				endm  
# End of macro CALLMONITOR
09d6				endif 
09d6			 
09d6			 
09d6			 
09d6					; fill buffer with data until end of string or full block 
09d6			 
09d6 7e			.appd:		ld a, (hl) 
09d7 12					ld (de), a 
09d8 fe 00				cp 0 
09da 28 04				jr z, .appdone 
09dc 23					inc hl 
09dd 13					inc de 
09de 10 f6				djnz .appd 
09e0			 
09e0 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e1 f5					push af   		; save last byte dumped 
09e2			 
09e2			 
09e2 2a 60 f8			ld hl, (store_tmppageid) 
09e5 11 62 f8			ld de, store_page 
09e8				if DEBUG_STORESE 
09e8					DMARK "AP6" 
09e8 f5				push af  
09e9 3a fd 09			ld a, (.dmark)  
09ec 32 77 fb			ld (debug_mark),a  
09ef 3a fe 09			ld a, (.dmark+1)  
09f2 32 78 fb			ld (debug_mark+1),a  
09f5 3a ff 09			ld a, (.dmark+2)  
09f8 32 79 fb			ld (debug_mark+2),a  
09fb 18 03			jr .pastdmark  
09fd ..			.dmark: db "AP6"  
0a00 f1			.pastdmark: pop af  
0a01			endm  
# End of macro DMARK
0a01					CALLMONITOR 
0a01 cd 17 16			call break_point_state  
0a04				endm  
# End of macro CALLMONITOR
0a04				endif 
0a04 cd 71 03				call storage_write_block 
0a07			 
0a07			 
0a07				; was that a full block of data written? 
0a07				; any more to write out? 
0a07			 
0a07				; if yes then set vars and jump to start of function again 
0a07			 
0a07 f1					pop af 
0a08 d1					pop de 
0a09			 
0a09 fe 00				cp 0		 ; no, string was fully written 
0a0b c8					ret z 
0a0c			 
0a0c					; setup vars for next cycle 
0a0c			 
0a0c 3a 5b f8				ld a, (store_tmpid) 
0a0f 6f					ld l, a 
0a10 26 00				ld h, 0 
0a12			 
0a12 c3 d4 08			 	jp storage_append	 ; yes, need to write out some more 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			if DEBUG_STORECF 
0a15			storageput:	 
0a15					ret 
0a15			storageread: 
0a15					ld hl, store_page 
0a15					ld b, 200 
0a15					ld a,0 
0a15			.src:		ld (hl),a 
0a15					inc hl 
0a15					djnz .src 
0a15					 
0a15			 
0a15					ld de, 0 
0a15					ld bc, 1 
0a15					ld hl, store_page 
0a15					call cfRead 
0a15			 
0a15				call cfGetError 
0a15				ld hl,scratch 
0a15				call hexout 
0a15				ld hl, scratch+2 
0a15				ld a, 0 
0a15				ld (hl),a 
0a15				ld de, scratch 
0a15				ld a,display_row_1 
0a15				call str_at_display 
0a15				call update_display 
0a15			 
0a15					ld hl, store_page 
0a15					ld (os_cur_ptr),hl 
0a15			 
0a15					ret 
0a15			endif 
0a15			 
0a15			 
0a15			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a15			 
0a15			storage_clear_page: 
0a15 e5				push hl 
0a16 d5				push de 
0a17 c5				push bc 
0a18 21 62 f8			ld hl, store_page 
0a1b 3e 00			ld a, 0 
0a1d 77				ld (hl), a 
0a1e			 
0a1e 11 63 f8			ld de, store_page+1 
0a21 01 40 00			ld bc, STORE_BLOCK_PHY 
0a24			 
0a24 ed b0			ldir 
0a26				 
0a26 c1				pop bc 
0a27 d1				pop de 
0a28 e1				pop hl 
0a29 c9				ret 
0a2a			 
0a2a			; eof 
# End of file firmware_storage.asm
0a2a			  
0a2a			; support routines for above hardware abstraction layer  
0a2a			  
0a2a			include "firmware_general.asm"        ; general support functions  
0a2a			 
0a2a			 
0a2a			 
0a2a			; Delay loops 
0a2a			 
0a2a			 
0a2a			 
0a2a			aDelayInMS: 
0a2a c5				push bc 
0a2b 47				ld b,a 
0a2c			msdelay: 
0a2c c5				push bc 
0a2d				 
0a2d			 
0a2d 01 41 00			ld bc,041h 
0a30 cd 48 0a			call delayloop 
0a33 c1				pop bc 
0a34 05				dec b 
0a35 20 f5			jr nz,msdelay 
0a37			 
0a37			;if CPU_CLOCK_8MHZ 
0a37			;msdelay8: 
0a37			;	push bc 
0a37			;	 
0a37			; 
0a37			;	ld bc,041h 
0a37			;	call delayloop 
0a37			;	pop bc 
0a37			;	dec b 
0a37			;	jr nz,msdelay8 
0a37			;endif 
0a37			 
0a37			 
0a37 c1				pop bc 
0a38 c9				ret 
0a39			 
0a39			 
0a39			delay250ms: 
0a39				;push de 
0a39 01 00 40			ld bc, 04000h 
0a3c c3 48 0a			jp delayloop 
0a3f			delay500ms: 
0a3f				;push de 
0a3f 01 00 80			ld bc, 08000h 
0a42 c3 48 0a			jp delayloop 
0a45			delay1s: 
0a45				;push bc 
0a45			   ; Clobbers A, d and e 
0a45 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a48			delayloop: 
0a48 c5			    push bc 
0a49			 
0a49			if BASE_CPM 
0a49				ld bc, CPM_DELAY_TUNE 
0a49			.cpmloop: 
0a49				push bc 
0a49			 
0a49			endif 
0a49			 
0a49			 
0a49			 
0a49			delayloopi: 
0a49			;	push bc 
0a49			;.dl: 
0a49 cb 47		    bit     0,a    	; 8 
0a4b cb 47		    bit     0,a    	; 8 
0a4d cb 47		    bit     0,a    	; 8 
0a4f e6 ff		    and     255  	; 7 
0a51 0b			    dec     bc      	; 6 
0a52 79			    ld      a,c     	; 4 
0a53 b0			    or      b     	; 4 
0a54 c2 49 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a57			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a57				;pop de 
0a57			;pop bc 
0a57			 
0a57			if BASE_CPM 
0a57				pop bc 
0a57				 
0a57			    dec     bc      	; 6 
0a57			    ld      a,c     	; 4 
0a57			    or      b     	; 4 
0a57			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a57				 
0a57			 
0a57			endif 
0a57			;if CPU_CLOCK_8MHZ 
0a57			;    pop bc 
0a57			;    push bc 
0a57			;.dl8: 
0a57			;    bit     0,a    	; 8 
0a57			;    bit     0,a    	; 8 
0a57			;    bit     0,a    	; 8 
0a57			;    and     255  	; 7 
0a57			;    dec     bc      	; 6 
0a57			;    ld      a,c     	; 4 
0a57			;    or      b     	; 4 
0a57			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a57			;endif 
0a57			 
0a57			;if CPU_CLOCK_10MHZ 
0a57			;    pop bc 
0a57			;    push bc 
0a57			;.dl8: 
0a57			;    bit     0,a    	; 8 
0a57			;    bit     0,a    	; 8 
0a57			;    bit     0,a    	; 8 
0a57			;    and     255  	; 7 
0a57			;    dec     bc      	; 6 
0a57			;    ld      a,c     	; 4 
0a57			;    or      b     	; 4 
0a57			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a57			;endif 
0a57 c1			    pop bc 
0a58			 
0a58 c9				ret 
0a59			 
0a59			 
0a59			 
0a59			; eof 
# End of file firmware_general.asm
0a59			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a59			; display routines that use the physical hardware abstraction layer 
0a59			 
0a59			 
0a59			; TODO windowing? 
0a59			 
0a59			; TODO scroll line up 
0a59			 
0a59			scroll_up: 
0a59			 
0a59 e5				push hl 
0a5a d5				push de 
0a5b c5				push bc 
0a5c			 
0a5c				; get frame buffer  
0a5c			 
0a5c 2a d8 f8			ld hl, (display_fb_active) 
0a5f e5				push hl    ; future de destination 
0a60			 
0a60 11 28 00			ld  de, display_cols 
0a63 19				add hl, de 
0a64			 
0a64 d1				pop de 
0a65			 
0a65				;ex de, hl 
0a65 01 9f 00			ld bc, display_fb_len -1  
0a68			;if DEBUG_FORTH_WORDS 
0a68			;	DMARK "SCL" 
0a68			;	CALLMONITOR 
0a68			;endif	 
0a68 ed b0			ldir 
0a6a			 
0a6a				; wipe bottom row 
0a6a			 
0a6a			 
0a6a 2a d8 f8			ld hl, (display_fb_active) 
0a6d 11 a0 00			ld de, display_cols*display_rows 
0a70 19				add hl, de 
0a71 06 28			ld b, display_cols 
0a73 3e 20			ld a, ' ' 
0a75			.scwipe: 
0a75 77				ld (hl), a 
0a76 2b				dec hl 
0a77 10 fc			djnz .scwipe 
0a79			 
0a79				;pop hl 
0a79			 
0a79 c1				pop bc 
0a7a d1				pop de 
0a7b e1				pop hl 
0a7c			 
0a7c c9				ret 
0a7d			 
0a7d			 
0a7d			;scroll_upo: 
0a7d			;	ld de, display_row_1 
0a7d			 ;	ld hl, display_row_2 
0a7d			;	ld bc, display_cols 
0a7d			;	ldir 
0a7d			;	ld de, display_row_2 
0a7d			 ;	ld hl, display_row_3 
0a7d			;	ld bc, display_cols 
0a7d			;	ldir 
0a7d			;	ld de, display_row_3 
0a7d			 ;	ld hl, display_row_4 
0a7d			;	ld bc, display_cols 
0a7d			;	ldir 
0a7d			 
0a7d			; TODO clear row 4 
0a7d			 
0a7d			;	ret 
0a7d			 
0a7d				 
0a7d			scroll_down: 
0a7d			 
0a7d e5				push hl 
0a7e d5				push de 
0a7f c5				push bc 
0a80			 
0a80				; get frame buffer  
0a80			 
0a80 2a d8 f8			ld hl, (display_fb_active) 
0a83			 
0a83 11 9f 00			ld de, display_fb_len - 1 
0a86 19				add hl, de 
0a87			 
0a87 e5			push hl    ; future de destination 
0a88			 
0a88 11 28 00			ld  de, display_cols 
0a8b ed 52			sbc hl, de 
0a8d			 
0a8d			 
0a8d d1				pop de 
0a8e			 
0a8e			;	ex de, hl 
0a8e 01 9f 00			ld bc, display_fb_len -1  
0a91			 
0a91			 
0a91				 
0a91			 
0a91 ed b0			ldir 
0a93			 
0a93				; wipe bottom row 
0a93			 
0a93			 
0a93			;	ld hl, (display_fb_active) 
0a93			;;	ld de, display_cols*display_rows 
0a93			;;	add hl, de 
0a93			;	ld b, display_cols 
0a93			;	ld a, ' ' 
0a93			;.scwiped: 
0a93			;	ld (hl), a 
0a93			;	dec hl 
0a93			;	djnz .scwiped 
0a93			 
0a93				;pop hl 
0a93			 
0a93 c1				pop bc 
0a94 d1				pop de 
0a95 e1				pop hl 
0a96			 
0a96 c9				ret 
0a97			;scroll_down: 
0a97			;	ld de, display_row_4 
0a97			;	ld hl, display_row_3 
0a97			;	ld bc, display_cols 
0a97			;	ldir 
0a97			;	ld de, display_row_3 
0a97			; 	ld hl, display_row_2 
0a97			;	ld bc, display_cols 
0a97			;	ldir 
0a97			;	ld de, display_row_2 
0a97			;	ld hl, display_row_1 
0a97			;	ld bc, display_cols 
0a97			;	ldir 
0a97			;;; TODO clear row 1 
0a97			;	ret 
0a97			 
0a97			 
0a97			 
0a97			 
0a97			 
0a97			; clear active frame buffer 
0a97			 
0a97			clear_display: 
0a97 3e 20			ld a, ' ' 
0a99 c3 9c 0a			jp fill_display 
0a9c			 
0a9c			; fill active frame buffer with a char in A 
0a9c			 
0a9c			fill_display: 
0a9c 06 a0			ld b,display_fb_len 
0a9e 2a d8 f8			ld hl, (display_fb_active) 
0aa1 77			.fd1:	ld (hl),a 
0aa2 23				inc hl 
0aa3 10 fc			djnz .fd1 
0aa5 23				inc hl 
0aa6 3e 00			ld a,0 
0aa8 77				ld (hl),a 
0aa9			 
0aa9			 
0aa9 c9				ret 
0aaa			; Write string (DE) at pos (A) to active frame buffer 
0aaa			 
0aaa 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0aad 06 00					ld b,0 
0aaf 4f					ld c,a 
0ab0 09					add hl,bc 
0ab1 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ab2 b7			            OR   A              ;Null terminator? 
0ab3 c8			            RET  Z              ;Yes, so finished 
0ab4 77					ld (hl),a 
0ab5 23				inc hl 
0ab6 13			            INC  DE             ;Point to next character 
0ab7 18 f8		            JR   .sad1     ;Repeat 
0ab9 c9					ret 
0aba			 
0aba			; using current frame buffer write to physical display 
0aba			 
0aba			update_display: 
0aba e5				push hl 
0abb 2a d8 f8			ld hl, (display_fb_active) 
0abe cd 87 64			call write_display 
0ac1 e1				pop hl 
0ac2 c9				ret 
0ac3			 
0ac3			; TODO scrolling 
0ac3			 
0ac3			 
0ac3			; move cursor right one char 
0ac3			cursor_right: 
0ac3			 
0ac3				; TODO shift right 
0ac3				; TODO if beyond max col 
0ac3				; TODO       cursor_next_line 
0ac3			 
0ac3 c9				ret 
0ac4			 
0ac4			 
0ac4			cursor_next_line: 
0ac4				; TODO first char 
0ac4				; TODO line down 
0ac4				; TODO if past last row 
0ac4				; TODO    scroll up 
0ac4			 
0ac4 c9				ret 
0ac5			 
0ac5			cursor_left: 
0ac5				; TODO shift left 
0ac5				; TODO if beyond left  
0ac5				; TODO     cursor prev line 
0ac5				 
0ac5 c9				ret 
0ac6			 
0ac6			cursor_prev_line: 
0ac6				; TODO last char 
0ac6				; TODO line up 
0ac6				; TODO if past first row 
0ac6				; TODO   scroll down 
0ac6			 
0ac6 c9				ret 
0ac7			 
0ac7			 
0ac7			cout: 
0ac7				; A - char 
0ac7 c9				ret 
0ac8			 
0ac8			 
0ac8			; Display a menu and allow item selection (optional toggle items) 
0ac8			; 
0ac8			; format: 
0ac8			; hl pointer to word array with zero term for items 
0ac8			; e.g.    db item1 
0ac8			;         db .... 
0ac8			;         db 0 
0ac8			; 
0ac8			; a = starting menu item  
0ac8			; 
0ac8			; de = pointer item toggle array   (todo) 
0ac8			; 
0ac8			; returns item selected in a 1-... 
0ac8			; returns 0 if back button pressed 
0ac8			; 
0ac8			; NOTE: Uses system frame buffer to display 
0ac8			; 
0ac8			; LEFT, Q = go back 
0ac8			; RIGHT, SPACE, CR = select 
0ac8			; UP, A - Up 
0ac8			; DOWN, Z - Down 
0ac8			 
0ac8			 
0ac8			 
0ac8			 
0ac8			 
0ac8			menu: 
0ac8			 
0ac8					; keep array pointer 
0ac8			 
0ac8 22 60 f8				ld (store_tmp1), hl 
0acb 32 5e f8				ld (store_tmp2), a 
0ace			 
0ace					; check for key bounce 
0ace			 
0ace			if BASE_KEV 
0ace			 
0ace cd d2 67		.mbounce:	call cin 
0ad1 fe 00				cp 0 
0ad3 20 f9				jr nz, .mbounce 
0ad5			endif 
0ad5					; for ease use ex 
0ad5			 
0ad5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0ad5 21 bd fa				ld hl, display_fb0 
0ad8 22 d8 f8				ld (display_fb_active), hl 
0adb			 
0adb cd 97 0a		.mloop:		call clear_display 
0ade cd ba 0a				call update_display 
0ae1			 
0ae1					; draw selection id '>' at 1 
0ae1			 
0ae1					; init start of list display 
0ae1			 
0ae1 3e 05				ld a, 5 
0ae3 32 5c f8				ld (store_tmp3), a   ; display row count 
0ae6 3a 5e f8				ld a,( store_tmp2) 
0ae9 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0aec			 
0aec					 
0aec			.mitem:	 
0aec			 
0aec			 
0aec 3a 5f f8				ld a,(store_tmp2+1) 
0aef 6f					ld l, a 
0af0 26 00				ld h, 0 
0af2 29					add hl, hl 
0af3 ed 5b 60 f8			ld de, (store_tmp1) 
0af7 19					add hl, de 
0af8 7e					ld a, (hl) 
0af9 23					inc hl 
0afa 66					ld h,(hl) 
0afb 6f					ld l, a 
0afc			 
0afc cd f4 0c				call ishlzero 
0aff 28 1a				jr z, .mdone 
0b01			 
0b01 eb					ex de, hl 
0b02 3a 5c f8				ld a, (store_tmp3) 
0b05 cd aa 0a				call str_at_display 
0b08					 
0b08			 
0b08					; next item 
0b08 3a 5f f8				ld a, (store_tmp2+1) 
0b0b 3c					inc a 
0b0c 32 5f f8				ld (store_tmp2+1), a   ; display item count 
0b0f			 
0b0f			 		; next row 
0b0f			 
0b0f 3a 5c f8				ld a, (store_tmp3) 
0b12 c6 28				add display_cols 
0b14 32 5c f8				ld (store_tmp3), a 
0b17			 
0b17					; at end of screen? 
0b17			 
0b17 fe 10				cp display_rows*4 
0b19 20 d1				jr nz, .mitem 
0b1b			 
0b1b			 
0b1b			.mdone: 
0b1b cd f4 0c				call ishlzero 
0b1e 28 08				jr z, .nodn 
0b20			 
0b20 3e 78				ld a, display_row_4 
0b22 11 a1 0b				ld de, .mdown 
0b25 cd aa 0a				call str_at_display 
0b28			 
0b28					; draw options to fill the screens with active item on line 1 
0b28					; if current option is 2 or more then display ^ in top 
0b28			 
0b28 3a 5e f8		.nodn:		ld a, (store_tmp2) 
0b2b fe 00				cp 0 
0b2d 28 08				jr z, .noup 
0b2f			 
0b2f 3e 00				ld a, 0 
0b31 11 9f 0b				ld de, .mup 
0b34 cd aa 0a				call str_at_display 
0b37			 
0b37 3e 02		.noup:		ld a, 2 
0b39 11 9d 0b				ld de, .msel 
0b3c cd aa 0a				call str_at_display 
0b3f			 
0b3f					; if current option + 1 is not null then display V in bottom 
0b3f					; get key 
0b3f cd ba 0a				call update_display 
0b42			 
0b42			 
0b42					; handle key 
0b42			 
0b42 cd c1 67				call cin_wait 
0b45			 
0b45 fe 05				cp KEY_UP 
0b47 28 2b				jr z, .mgoup 
0b49 fe 61				cp 'a' 
0b4b 28 27				jr z, .mgoup 
0b4d fe 0a				cp KEY_DOWN 
0b4f 28 32				jr z, .mgod 
0b51 fe 7a				cp 'z' 
0b53 28 2e				jr z, .mgod 
0b55 fe 20				cp ' ' 
0b57 28 34				jr z, .goend 
0b59 fe 0c				cp KEY_RIGHT 
0b5b 28 30				jr z, .goend 
0b5d fe 0d				cp KEY_CR 
0b5f 28 2c				jr z, .goend 
0b61 fe 71				cp 'q' 
0b63 28 0b				jr z, .goback 
0b65			 
0b65 fe 0b				cp KEY_LEFT 
0b67 28 07				jr z, .goback 
0b69 fe 08				cp KEY_BS 
0b6b 28 03				jr z, .goback 
0b6d c3 db 0a				jp .mloop 
0b70			 
0b70			.goback: 
0b70 3e 00			ld a, 0 
0b72 18 1d			jr .goend2 
0b74			 
0b74				; move up one 
0b74			.mgoup: 
0b74 3a 5e f8				ld a, (store_tmp2) 
0b77 fe 00				cp 0 
0b79 ca db 0a				jp z, .mloop 
0b7c 3d					dec a 
0b7d 32 5e f8				ld (store_tmp2), a 
0b80 c3 db 0a				jp .mloop 
0b83			 
0b83				; move down one 
0b83			.mgod: 
0b83 3a 5e f8				ld a, (store_tmp2) 
0b86 3c					inc a 
0b87 32 5e f8				ld (store_tmp2), a 
0b8a c3 db 0a				jp .mloop 
0b8d			 
0b8d			 
0b8d			.goend: 
0b8d					; get selected item number 
0b8d			 
0b8d 3a 5e f8				ld a, (store_tmp2) 
0b90 3c					inc a 
0b91			 
0b91			.goend2: 
0b91 f5					push af 
0b92			 
0b92					; restore active fb 
0b92					; TODO BUG assumes fb1 
0b92			 
0b92 21 1c fa				ld hl, display_fb1 
0b95 22 d8 f8				ld (display_fb_active), hl 
0b98			 
0b98					; restore main regs 
0b98			 
0b98			 
0b98 cd ba 0a				call update_display 
0b9b			 
0b9b f1					pop af 
0b9c			 
0b9c c9				ret 
0b9d			 
0b9d .. 00		.msel:   db ">",0 
0b9f .. 00		.mup:   db "^",0 
0ba1 .. 00		.mdown:   db "v",0 
0ba3			 
0ba3			 
0ba3			; eof 
0ba3			 
# End of file firmware_display.asm
0ba3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ba3			; random number generators 
0ba3			 
0ba3			 
0ba3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ba3			 
0ba3			 
0ba3			;-----> Generate a random number 
0ba3			; output a=answer 0<=a<=255 
0ba3			; all registers are preserved except: af 
0ba3			random: 
0ba3 e5			        push    hl 
0ba4 d5			        push    de 
0ba5 2a ba f8		        ld      hl,(randData) 
0ba8 ed 5f		        ld      a,r 
0baa 57			        ld      d,a 
0bab 5e			        ld      e,(hl) 
0bac 19			        add     hl,de 
0bad 85			        add     a,l 
0bae ac			        xor     h 
0baf 22 ba f8		        ld      (randData),hl 
0bb2 d1			        pop     de 
0bb3 e1			        pop     hl 
0bb4 c9			        ret 
0bb5			 
0bb5			 
0bb5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bb5			 
0bb5			 
0bb5			 
0bb5			;------LFSR------ 
0bb5			;James Montelongo 
0bb5			;optimized by Spencer Putt 
0bb5			;out: 
0bb5			; a = 8 bit random number 
0bb5			RandLFSR: 
0bb5 21 c0 f8		        ld hl,LFSRSeed+4 
0bb8 5e			        ld e,(hl) 
0bb9 23			        inc hl 
0bba 56			        ld d,(hl) 
0bbb 23			        inc hl 
0bbc 4e			        ld c,(hl) 
0bbd 23			        inc hl 
0bbe 7e			        ld a,(hl) 
0bbf 47			        ld b,a 
0bc0 cb 13		        rl e  
0bc2 cb 12			rl d 
0bc4 cb 11		        rl c  
0bc6 17				rla 
0bc7 cb 13		        rl e  
0bc9 cb 12			rl d 
0bcb cb 11		        rl c  
0bcd 17				rla 
0bce cb 13		        rl e  
0bd0 cb 12			rl d 
0bd2 cb 11		        rl c  
0bd4 17				rla 
0bd5 67			        ld h,a 
0bd6 cb 13		        rl e  
0bd8 cb 12			rl d 
0bda cb 11		        rl c  
0bdc 17				rla 
0bdd a8			        xor b 
0bde cb 13		        rl e  
0be0 cb 12			rl d 
0be2 ac			        xor h 
0be3 a9			        xor c 
0be4 aa			        xor d 
0be5 21 c2 f8		        ld hl,LFSRSeed+6 
0be8 11 c3 f8		        ld de,LFSRSeed+7 
0beb 01 07 00		        ld bc,7 
0bee ed b8		        lddr 
0bf0 12			        ld (de),a 
0bf1 c9			        ret 
0bf2			 
0bf2			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0bf2			 
0bf2			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0bf2			 
0bf2			 
0bf2			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0bf2			 
0bf2			prng16: 
0bf2			;Inputs: 
0bf2			;   (seed1) contains a 16-bit seed value 
0bf2			;   (seed2) contains a NON-ZERO 16-bit seed value 
0bf2			;Outputs: 
0bf2			;   HL is the result 
0bf2			;   BC is the result of the LCG, so not that great of quality 
0bf2			;   DE is preserved 
0bf2			;Destroys: 
0bf2			;   AF 
0bf2			;cycle: 4,294,901,760 (almost 4.3 billion) 
0bf2			;160cc 
0bf2			;26 bytes 
0bf2 2a b4 f8		    ld hl,(seed1) 
0bf5 44			    ld b,h 
0bf6 4d			    ld c,l 
0bf7 29			    add hl,hl 
0bf8 29			    add hl,hl 
0bf9 2c			    inc l 
0bfa 09			    add hl,bc 
0bfb 22 b4 f8		    ld (seed1),hl 
0bfe 2a b2 f8		    ld hl,(seed2) 
0c01 29			    add hl,hl 
0c02 9f			    sbc a,a 
0c03 e6 2d		    and %00101101 
0c05 ad			    xor l 
0c06 6f			    ld l,a 
0c07 22 b2 f8		    ld (seed2),hl 
0c0a 09			    add hl,bc 
0c0b c9			    ret 
0c0c			 
0c0c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c0c			 
0c0c			rand32: 
0c0c			;Inputs: 
0c0c			;   (seed1_0) holds the lower 16 bits of the first seed 
0c0c			;   (seed1_1) holds the upper 16 bits of the first seed 
0c0c			;   (seed2_0) holds the lower 16 bits of the second seed 
0c0c			;   (seed2_1) holds the upper 16 bits of the second seed 
0c0c			;   **NOTE: seed2 must be non-zero 
0c0c			;Outputs: 
0c0c			;   HL is the result 
0c0c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c0c			;Destroys: 
0c0c			;   AF 
0c0c			;Tested and passes all CAcert tests 
0c0c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c0c			;it has a period of 18,446,744,069,414,584,320 
0c0c			;roughly 18.4 quintillion. 
0c0c			;LFSR taps: 0,2,6,7  = 11000101 
0c0c			;291cc 
0c0c			;seed1_0=$+1 
0c0c			;    ld hl,12345 
0c0c			;seed1_1=$+1 
0c0c			;    ld de,6789 
0c0c			;    ld b,h 
0c0c			;    ld c,l 
0c0c			;    add hl,hl \ rl e \ rl d 
0c0c			;    add hl,hl \ rl e \ rl d 
0c0c			;    inc l 
0c0c			;    add hl,bc 
0c0c			;    ld (seed1_0),hl 
0c0c			;    ld hl,(seed1_1) 
0c0c			;    adc hl,de 
0c0c			;    ld (seed1_1),hl 
0c0c			;    ex de,hl 
0c0c			;seed2_0=$+1 
0c0c			;    ld hl,9876 
0c0c			;seed2_1=$+1 
0c0c			;    ld bc,54321 
0c0c			;    add hl,hl \ rl c \ rl b 
0c0c			;    ld (seed2_1),bc 
0c0c			;    sbc a,a 
0c0c			;    and %11000101 
0c0c			;    xor l 
0c0c			;    ld l,a 
0c0c			;    ld (seed2_0),hl 
0c0c			;    ex de,hl 
0c0c			;    add hl,bc 
0c0c			;    ret 
0c0c			; 
0c0c			 
0c0c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c0c			; 20 bytes, 86 cycles (excluding ret) 
0c0c			 
0c0c			; returns   hl = pseudorandom number 
0c0c			; corrupts   a 
0c0c			 
0c0c			; generates 16-bit pseudorandom numbers with a period of 65535 
0c0c			; using the xorshift method: 
0c0c			 
0c0c			; hl ^= hl << 7 
0c0c			; hl ^= hl >> 9 
0c0c			; hl ^= hl << 8 
0c0c			 
0c0c			; some alternative shift triplets which also perform well are: 
0c0c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c0c			 
0c0c			;  org 32768 
0c0c			 
0c0c			xrnd: 
0c0c 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0c0f 3e 00		  ld a,0 
0c11 bd			  cp l 
0c12 20 02		  jr nz, .xrnd1 
0c14 2e 01		  ld l, 1 
0c16			.xrnd1: 
0c16			 
0c16 7c			  ld a,h 
0c17 1f			  rra 
0c18 7d			  ld a,l 
0c19 1f			  rra 
0c1a ac			  xor h 
0c1b 67			  ld h,a 
0c1c 7d			  ld a,l 
0c1d 1f			  rra 
0c1e 7c			  ld a,h 
0c1f 1f			  rra 
0c20 ad			  xor l 
0c21 6f			  ld l,a 
0c22 ac			  xor h 
0c23 67			  ld h,a 
0c24			 
0c24 22 b8 f8		  ld (xrandc),hl 
0c27			 
0c27 c9			  ret 
0c28			;  
0c28			 
0c28			 
0c28			;;;; int maths 
0c28			 
0c28			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c28			; Divide 16-bit values (with 16-bit result) 
0c28			; In: Divide BC by divider DE 
0c28			; Out: BC = result, HL = rest 
0c28			; 
0c28			Div16: 
0c28 21 00 00		    ld hl,0 
0c2b 78			    ld a,b 
0c2c 06 08		    ld b,8 
0c2e			Div16_Loop1: 
0c2e 17			    rla 
0c2f ed 6a		    adc hl,hl 
0c31 ed 52		    sbc hl,de 
0c33 30 01		    jr nc,Div16_NoAdd1 
0c35 19			    add hl,de 
0c36			Div16_NoAdd1: 
0c36 10 f6		    djnz Div16_Loop1 
0c38 17			    rla 
0c39 2f			    cpl 
0c3a 47			    ld b,a 
0c3b 79			    ld a,c 
0c3c 48			    ld c,b 
0c3d 06 08		    ld b,8 
0c3f			Div16_Loop2: 
0c3f 17			    rla 
0c40 ed 6a		    adc hl,hl 
0c42 ed 52		    sbc hl,de 
0c44 30 01		    jr nc,Div16_NoAdd2 
0c46 19			    add hl,de 
0c47			Div16_NoAdd2: 
0c47 10 f6		    djnz Div16_Loop2 
0c49 17			    rla 
0c4a 2f			    cpl 
0c4b 41			    ld b,c 
0c4c 4f			    ld c,a 
0c4d c9			ret 
0c4e			 
0c4e			 
0c4e			;http://z80-heaven.wikidot.com/math 
0c4e			; 
0c4e			;Inputs: 
0c4e			;     DE and A are factors 
0c4e			;Outputs: 
0c4e			;     A is not changed 
0c4e			;     B is 0 
0c4e			;     C is not changed 
0c4e			;     DE is not changed 
0c4e			;     HL is the product 
0c4e			;Time: 
0c4e			;     342+6x 
0c4e			; 
0c4e			Mult16: 
0c4e			 
0c4e 06 08		     ld b,8          ;7           7 
0c50 21 00 00		     ld hl,0         ;10         10 
0c53 29			       add hl,hl     ;11*8       88 
0c54 07			       rlca          ;4*8        32 
0c55 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c57 19			         add hl,de   ;--         -- 
0c58 10 f9		       djnz $-5      ;13*7+8     99 
0c5a c9			ret 
0c5b			 
0c5b			; 
0c5b			; Square root of 16-bit value 
0c5b			; In:  HL = value 
0c5b			; Out:  D = result (rounded down) 
0c5b			; 
0c5b			;Sqr16: 
0c5b			;    ld de,#0040 
0c5b			;    ld a,l 
0c5b			;    ld l,h 
0c5b			;    ld h,d 
0c5b			;    or a 
0c5b			;    ld b,8 
0c5b			;Sqr16_Loop: 
0c5b			;    sbc hl,de 
0c5b			;    jr nc,Sqr16_Skip 
0c5b			;    add hl,de 
0c5b			;Sqr16_Skip: 
0c5b			;    ccf 
0c5b			;    rl d 
0c5b			;    add a,a 
0c5b			;    adc hl,hl 
0c5b			;    add a,a 
0c5b			;    adc hl,hl 
0c5b			;    djnz Sqr16_Loop 
0c5b			;    ret 
0c5b			; 
0c5b			; 
0c5b			; Divide 8-bit values 
0c5b			; In: Divide E by divider C 
0c5b			; Out: A = result, B = rest 
0c5b			; 
0c5b			Div8: 
0c5b af			    xor a 
0c5c 06 08		    ld b,8 
0c5e			Div8_Loop: 
0c5e cb 13		    rl e 
0c60 17			    rla 
0c61 91			    sub c 
0c62 30 01		    jr nc,Div8_NoAdd 
0c64 81			    add a,c 
0c65			Div8_NoAdd: 
0c65 10 f7		    djnz Div8_Loop 
0c67 47			    ld b,a 
0c68 7b			    ld a,e 
0c69 17			    rla 
0c6a 2f			    cpl 
0c6b c9			    ret 
0c6c			 
0c6c			; 
0c6c			; Multiply 8-bit value with a 16-bit value (unrolled) 
0c6c			; In: Multiply A with DE 
0c6c			; Out: HL = result 
0c6c			; 
0c6c			Mult12U: 
0c6c 2e 00		    ld l,0 
0c6e 87			    add a,a 
0c6f 30 01		    jr nc,Mult12U_NoAdd0 
0c71 19			    add hl,de 
0c72			Mult12U_NoAdd0: 
0c72 29			    add hl,hl 
0c73 87			    add a,a 
0c74 30 01		    jr nc,Mult12U_NoAdd1 
0c76 19			    add hl,de 
0c77			Mult12U_NoAdd1: 
0c77 29			    add hl,hl 
0c78 87			    add a,a 
0c79 30 01		    jr nc,Mult12U_NoAdd2 
0c7b 19			    add hl,de 
0c7c			Mult12U_NoAdd2: 
0c7c 29			    add hl,hl 
0c7d 87			    add a,a 
0c7e 30 01		    jr nc,Mult12U_NoAdd3 
0c80 19			    add hl,de 
0c81			Mult12U_NoAdd3: 
0c81 29			    add hl,hl 
0c82 87			    add a,a 
0c83 30 01		    jr nc,Mult12U_NoAdd4 
0c85 19			    add hl,de 
0c86			Mult12U_NoAdd4: 
0c86 29			    add hl,hl 
0c87 87			    add a,a 
0c88 30 01		    jr nc,Mult12U_NoAdd5 
0c8a 19			    add hl,de 
0c8b			Mult12U_NoAdd5: 
0c8b 29			    add hl,hl 
0c8c 87			    add a,a 
0c8d 30 01		    jr nc,Mult12U_NoAdd6 
0c8f 19			    add hl,de 
0c90			Mult12U_NoAdd6: 
0c90 29			    add hl,hl 
0c91 87			    add a,a 
0c92 d0			    ret nc 
0c93 19			    add hl,de 
0c94 c9			    ret 
0c95			 
0c95			; 
0c95			; Multiply 8-bit value with a 16-bit value (right rotating) 
0c95			; In: Multiply A with DE 
0c95			;      Put lowest value in A for most efficient calculation 
0c95			; Out: HL = result 
0c95			; 
0c95			Mult12R: 
0c95 21 00 00		    ld hl,0 
0c98			Mult12R_Loop: 
0c98 cb 3f		    srl a 
0c9a 30 01		    jr nc,Mult12R_NoAdd 
0c9c 19			    add hl,de 
0c9d			Mult12R_NoAdd: 
0c9d cb 23		    sla e 
0c9f cb 12		    rl d 
0ca1 b7			    or a 
0ca2 c2 98 0c		    jp nz,Mult12R_Loop 
0ca5 c9			    ret 
0ca6			 
0ca6			; 
0ca6			; Multiply 16-bit values (with 32-bit result) 
0ca6			; In: Multiply BC with DE 
0ca6			; Out: BCHL = result 
0ca6			; 
0ca6			Mult32: 
0ca6 79			    ld a,c 
0ca7 48			    ld c,b 
0ca8 21 00 00		    ld hl,0 
0cab 06 10		    ld b,16 
0cad			Mult32_Loop: 
0cad 29			    add hl,hl 
0cae 17			    rla 
0caf cb 11		    rl c 
0cb1 30 07		    jr nc,Mult32_NoAdd 
0cb3 19			    add hl,de 
0cb4 ce 00		    adc a,0 
0cb6 d2 ba 0c		    jp nc,Mult32_NoAdd 
0cb9 0c			    inc c 
0cba			Mult32_NoAdd: 
0cba 10 f1		    djnz Mult32_Loop 
0cbc 41			    ld b,c 
0cbd 4f			    ld c,a 
0cbe c9			    ret 
0cbf			 
0cbf			 
0cbf			 
0cbf			; 
0cbf			; Multiply 8-bit values 
0cbf			; In:  Multiply H with E 
0cbf			; Out: HL = result 
0cbf			; 
0cbf			Mult8: 
0cbf 16 00		    ld d,0 
0cc1 6a			    ld l,d 
0cc2 06 08		    ld b,8 
0cc4			Mult8_Loop: 
0cc4 29			    add hl,hl 
0cc5 30 01		    jr nc,Mult8_NoAdd 
0cc7 19			    add hl,de 
0cc8			Mult8_NoAdd: 
0cc8 10 fa		    djnz Mult8_Loop 
0cca c9			    ret 
0ccb			 
0ccb			 
0ccb			 
0ccb			 
0ccb			 
0ccb			 
0ccb			 
0ccb			 
0ccb			;;http://z80-heaven.wikidot.com/math 
0ccb			;;This divides DE by BC, storing the result in DE, remainder in HL 
0ccb			; 
0ccb			;DE_Div_BC:          ;1281-2x, x is at most 16 
0ccb			;     ld a,16        ;7 
0ccb			;     ld hl,0        ;10 
0ccb			;     jp $+5         ;10 
0ccb			;.DivLoop: 
0ccb			;       add hl,bc    ;-- 
0ccb			;       dec a        ;64 
0ccb			;       jr z,.DivLoopEnd        ;86 
0ccb			; 
0ccb			;       sla e        ;128 
0ccb			;       rl d         ;128 
0ccb			;       adc hl,hl    ;240 
0ccb			;       sbc hl,bc    ;240 
0ccb			;       jr nc,.DivLoop ;23|21 
0ccb			;       inc e        ;-- 
0ccb			;       jp .DivLoop+1 
0ccb			; 
0ccb			;.DivLoopEnd: 
0ccb			 
0ccb			;HL_Div_C: 
0ccb			;Inputs: 
0ccb			;     HL is the numerator 
0ccb			;     C is the denominator 
0ccb			;Outputs: 
0ccb			;     A is the remainder 
0ccb			;     B is 0 
0ccb			;     C is not changed 
0ccb			;     DE is not changed 
0ccb			;     HL is the quotient 
0ccb			; 
0ccb			;       ld b,16 
0ccb			;       xor a 
0ccb			;         add hl,hl 
0ccb			;         rla 
0ccb			;         cp c 
0ccb			;         jr c,$+4 
0ccb			;           inc l 
0ccb			;           sub c 
0ccb			;         djnz $-7 
0ccb			 
0ccb			; https://plutiedev.com/z80-add-8bit-to-16bit 
0ccb			 
0ccb			addatohl: 
0ccb 85			    add   a, l    ; A = A+L 
0ccc 6f			    ld    l, a    ; L = A+L 
0ccd 8c			    adc   a, h    ; A = A+L+H+carry 
0cce 95			    sub   l       ; A = H+carry 
0ccf 67			    ld    h, a    ; H = H+carry 
0cd0 c9			ret 
0cd1			 
0cd1			addatode: 
0cd1 83			    add   a, e    ; A = A+L 
0cd2 5f			    ld    e, a    ; L = A+L 
0cd3 8a			    adc   a, d    ; A = A+L+H+carry 
0cd4 93			    sub   e       ; A = H+carry 
0cd5 57			    ld    d, a    ; H = H+carry 
0cd6 c9			ret 
0cd7			 
0cd7			 
0cd7			addatobc: 
0cd7 81			    add   a, c    ; A = A+L 
0cd8 4f			    ld    c, a    ; L = A+L 
0cd9 88			    adc   a, b    ; A = A+L+H+carry 
0cda 91			    sub   c       ; A = H+carry 
0cdb 47			    ld    b, a    ; H = H+carry 
0cdc c9			ret 
0cdd			 
0cdd			subafromhl: 
0cdd			   ; If A=0 do nothing 
0cdd			    ; Otherwise flip A's sign. Since 
0cdd			    ; the upper byte becomes -1, also 
0cdd			    ; substract 1 from H. 
0cdd ed 44		    neg 
0cdf ca e8 0c		    jp    z, Skip 
0ce2 25			    dec   h 
0ce3			     
0ce3			    ; Now add the low byte as usual 
0ce3			    ; Two's complement takes care of 
0ce3			    ; ensuring the result is correct 
0ce3 85			    add   a, l 
0ce4 6f			    ld    l, a 
0ce5 8c			    adc   a, h 
0ce6 95			    sub   l 
0ce7 67			    ld    h, a 
0ce8			Skip: 
0ce8 c9				ret 
0ce9			 
0ce9			 
0ce9			; compare hl and de 
0ce9			; returns:  
0ce9			; if hl = de, z=1, s=0, c0=0 
0ce9			; if hl > de, z=0, s=0, c=0 
0ce9			; if hl < de, z=0, s=1, c=1 
0ce9			cmp16:	 
0ce9 b7				or a 
0cea ed 52			sbc hl,de 
0cec e0				ret po 
0ced 7c				ld a,h 
0cee 1f				rra 
0cef ee 40			xor 01000000B 
0cf1 37				scf 
0cf2 8f				adc a,a 
0cf3 c9				ret 
0cf4			 
0cf4			 
0cf4			; test if hl contains zero   - A is destroyed 
0cf4			 
0cf4			ishlzero:    
0cf4 b7				or a     ; reset flags 
0cf5 7c				ld a, h 
0cf6 b5				or l        	 
0cf7			 
0cf7 c9				ret 
0cf8			 
0cf8			 
0cf8			 
0cf8			 
0cf8			if FORTH_ENABLE_FLOATMATH 
0cf8			;include "float/bbcmath.z80" 
0cf8			include "float/lpfpcalc.asm" 
0cf8			endif 
0cf8			 
0cf8			 
0cf8			; eof 
0cf8			 
# End of file firmware_maths.asm
0cf8			include "firmware_strings.asm"   ; string handling  
0cf8			 
0cf8			 
0cf8			; TODO string len 
0cf8			; input text string, end on cr with zero term 
0cf8			; a offset into frame buffer to start prompt 
0cf8			; d is max length 
0cf8			; e is display size TODO 
0cf8			; c is current cursor position 
0cf8			; hl is ptr to where string will be stored 
0cf8			 
0cf8			 
0cf8			; TODO check limit of buffer for new inserts 
0cf8			; TODO check insert does not push beyond buffer 
0cf8			; TODO scroll in a limited display area 
0cf8			; TODO scroll whole screen on page wrap 
0cf8			 
0cf8			 
0cf8			; TODO handle KEY_PREVWORD 
0cf8			; TODO handle KEY_NEXTWORD 
0cf8			; TODO handle KEY_HOME 
0cf8			; TODO handle KEY_END 
0cf8			; TODO use LCD cursor? 
0cf8			 
0cf8 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0cfb 81					add c 
0cfc 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0cff 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0d02 79					ld a, c 
0d03 cd cb 0c				call addatohl 
0d06 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d09 7a					ld a,d 
0d0a 32 72 fb			        ld (input_size), a       ; save length of input area 
0d0d 79					ld a, c 
0d0e 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0d11 7b					ld a,e 
0d12 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d15					 
0d15					 
0d15			 
0d15			;		ld a,(input_ptr) 
0d15			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d15			 
0d15			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d15					; init cursor shape if not set by the cin routines 
0d15 21 d0 f8				ld hl, cursor_shape 
0d18 3e ff				ld a, 255 
0d1a 77					ld (hl), a 
0d1b 23					inc hl 
0d1c 3e 00				ld a, 0 
0d1e 77					ld (hl), a 
0d1f			 
0d1f 3e 0f				ld a, CUR_BLINK_RATE 
0d21 32 6c fb				ld (input_cur_flash), a 
0d24 3e 01				ld a, 1 
0d26 32 6b fb				ld (input_cur_onoff),a 
0d29			 
0d29			;	if DEBUG_INPUT 
0d29			;		push af 
0d29			;		ld a, 'I' 
0d29			;		ld (debug_mark),a 
0d29			;		pop af 
0d29			;		CALLMONITOR 
0d29			;	endif 
0d29			.is1:		; main entry loop 
0d29			 
0d29			 
0d29			 
0d29					; pause 1ms 
0d29			 
0d29 3e 01				ld a, 1 
0d2b cd 2a 0a				call aDelayInMS 
0d2e			 
0d2e					; dec flash counter 
0d2e 3a 6c fb				ld a, (input_cur_flash) 
0d31 3d					dec a 
0d32 32 6c fb				ld (input_cur_flash), a 
0d35 fe 00				cp 0 
0d37 20 0d				jr nz, .nochgstate 
0d39			 
0d39			 
0d39					; change state 
0d39 3a 6b fb				ld a,(input_cur_onoff) 
0d3c ed 44				neg 
0d3e 32 6b fb				ld (input_cur_onoff),a 
0d41			 
0d41			 
0d41					; reset on change of state 
0d41 3e 0f				ld a, CUR_BLINK_RATE 
0d43 32 6c fb				ld (input_cur_flash), a 
0d46			 
0d46			.nochgstate: 
0d46					 
0d46					 
0d46			 
0d46					; display cursor  
0d46			 
0d46			;		ld hl, (input_start) 
0d46			;		ld a, (input_cursor) 
0d46			;		call addatohl 
0d46			 
0d46					; get char under cursor and replace with cursor 
0d46 2a 75 fb		ld hl, (input_ptr) 
0d49			;		ld a, (hl) 
0d49			;		ld (input_under_cursor),a 
0d49			;		ld a, '_' 
0d49			;		ld (hl), a 
0d49			 
0d49					; display string 
0d49			 
0d49 ed 5b 73 fb			ld de, (input_start) 
0d4d 3a 70 fb				ld a, (input_at_pos) 
0d50 cd aa 0a				call str_at_display 
0d53			;	        call update_display 
0d53			 
0d53					; find place to put the cursor 
0d53			;		add h 
0d53			;		ld l, display_row_1 
0d53			;		sub l 
0d53			; (input_at_pos) 
0d53					;ld c, a 
0d53			;		ld a, (input_cursor) 
0d53			;		ld l, (input_at_pos) 
0d53			;		;ld b, h 
0d53			;		add l 
0d53			;		ld (input_at_cursor),a 
0d53					;ld l,h 
0d53			 
0d53			;		ld h, 0 
0d53			;		ld l,(input_at_pos) 
0d53			;		ld a, (input_cursor) 
0d53			;		call addatohl 
0d53			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d53			;		call subafromhl 
0d53			;		ld a,l 
0d53			;		ld (input_at_cursor), a 
0d53			 
0d53				if DEBUG_INPUT 
0d53					ld a, (hardware_diag) 
0d53					cp 0 
0d53					jr z, .skip_input_diag 
0d53			 
0d53					ld a,(input_at_pos) 
0d53					ld hl, LFSRSeed 
0d53					call hexout 
0d53					ld a, (input_cursor) 
0d53					ld hl, LFSRSeed+2 
0d53					call hexout 
0d53					ld a,(input_at_cursor) 
0d53					ld hl, LFSRSeed+4 
0d53					call hexout 
0d53			 
0d53					ld a,(input_cur_onoff) 
0d53					ld hl, LFSRSeed+6 
0d53					call hexout 
0d53			 
0d53					ld a,(input_cur_flash) 
0d53					ld hl, LFSRSeed+8 
0d53					call hexout 
0d53			 
0d53					ld a,(input_len) 
0d53					ld hl, LFSRSeed+10 
0d53					call hexout 
0d53					ld hl, LFSRSeed+12 
0d53					ld a, 0 
0d53					ld (hl),a 
0d53					ld a, display_row_4 
0d53					ld de, LFSRSeed 
0d53					call str_at_display 
0d53					.skip_input_diag: 
0d53				endif 
0d53			 
0d53					; decide on if we are showing the cursor this time round 
0d53			 
0d53 3a 6b fb				ld a, (input_cur_onoff) 
0d56 fe ff				cp 255 
0d58 28 13				jr z, .skipcur 
0d5a			 
0d5a			 
0d5a 3a 6e fb				ld a,(input_at_cursor) 
0d5d 11 d0 f8				ld de, cursor_shape 
0d60 cd aa 0a				call str_at_display 
0d63			 
0d63					; save length of current input string 
0d63 2a 73 fb				ld hl, (input_start) 
0d66 cd 29 11				call strlenz 
0d69 7d					ld a,l 
0d6a 32 66 fb				ld (input_len),a 
0d6d			 
0d6d			.skipcur: 
0d6d			 
0d6d cd ba 0a			        call update_display 
0d70					 
0d70			 
0d70			 
0d70					; wait 
0d70				 
0d70					; TODO loop without wait to flash the cursor and char under cursor	 
0d70 cd d2 67				call cin    ; _wait 
0d73			 
0d73 fe 00				cp 0 
0d75 ca 29 0d				jp z, .is1 
0d78			 
0d78					; get ptr to char to input into 
0d78			 
0d78 4f					ld c,a 
0d79 2a 73 fb				ld hl, (input_start) 
0d7c 3a 61 fb				ld a, (input_cursor) 
0d7f cd cb 0c				call addatohl 
0d82 22 75 fb				ld (input_ptr), hl 
0d85 79					ld a,c 
0d86			 
0d86					; replace char under cursor 
0d86			 
0d86			;		ld hl, (input_ptr) 
0d86			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0d86			;		ld (hl), a 
0d86			 
0d86			;	if DEBUG_INPUT 
0d86			;		push af 
0d86			;		ld a, 'i' 
0d86			;		ld (debug_mark),a 
0d86			;		pop af 
0d86			;		CALLMONITOR 
0d86			;	endif 
0d86 fe 0e				cp KEY_HOME 
0d88 20 0e				jr nz, .iske 
0d8a			 
0d8a 3a 70 fb				ld a, (input_at_pos) 
0d8d 32 6e fb				ld (input_at_cursor),a 
0d90 3e 00				ld a, 0 
0d92 32 61 fb				ld (input_cursor), a 
0d95 c3 29 0d				jp .is1 
0d98					 
0d98 fe 0f		.iske:		cp KEY_END 
0d9a 20 03				jr nz, .isknw 
0d9c c3 29 0d				jp .is1 
0d9f			 
0d9f fe 06		.isknw:		cp KEY_NEXTWORD 
0da1 20 1b				jr nz, .iskpw 
0da3			 
0da3 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0da6 7e					ld a,(hl)	 
0da7 fe 00				cp 0 
0da9 ca 29 0d				jp z, .is1    ; end of string 
0dac fe 20				cp ' ' 
0dae ca 29 0d				jp z, .is1    ; end of word 
0db1 23					inc hl 
0db2 22 75 fb				ld (input_ptr), hl 
0db5 3a 6e fb				ld a, (input_at_cursor) 
0db8 3c					inc a 
0db9 32 6e fb				ld (input_at_cursor), a 
0dbc 18 e5				jr .isknwm 
0dbe			 
0dbe fe 07		.iskpw:		cp KEY_PREVWORD 
0dc0 20 1b				jr nz, .iskl 
0dc2			.iskpwm:	 
0dc2 2a 75 fb				ld hl, (input_ptr) 
0dc5 7e					ld a,(hl)	 
0dc6 fe 00				cp 0  
0dc8 ca 29 0d				jp z, .is1    ; end of string 
0dcb fe 20				cp ' ' 
0dcd ca 29 0d				jp z, .is1    ; end of word 
0dd0 2b					dec hl 
0dd1 22 75 fb				ld (input_ptr), hl 
0dd4 3a 6e fb				ld a, (input_at_cursor) 
0dd7 3d					dec a 
0dd8 32 6e fb				ld (input_at_cursor), a 
0ddb 18 e5				jr .iskpwm 
0ddd			 
0ddd			 
0ddd fe 0b		.iskl:		cp KEY_LEFT 
0ddf 20 27				jr nz, .isk1 
0de1			 
0de1 3a 61 fb				ld a, (input_cursor) 
0de4			 
0de4 fe 00				cp 0 
0de6 ca 29 0d				jp z, .is1 		; at start of line to ignore  
0de9			 
0de9 3d					dec  a 		; TODO check underflow 
0dea 32 61 fb				ld (input_cursor), a 
0ded			 
0ded 2a 75 fb				ld hl, (input_ptr) 
0df0 2b					dec hl 
0df1 22 75 fb				ld (input_ptr), hl 
0df4					 
0df4 3a 6e fb				ld a, (input_at_cursor) 
0df7 3d					dec a 
0df8 32 6e fb				ld (input_at_cursor), a 
0dfb			 
0dfb 3e 01				ld a, 1		; show cursor moving 
0dfd 32 6b fb				ld (input_cur_onoff),a 
0e00 3e 0f				ld a, CUR_BLINK_RATE 
0e02 32 6c fb				ld (input_cur_flash), a 
0e05			 
0e05 c3 29 0d				jp .is1 
0e08			 
0e08 fe 0c		.isk1:		cp KEY_RIGHT 
0e0a 20 2a				jr nz, .isk2 
0e0c			 
0e0c 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e0f 5f					ld e,a 
0e10 3a 61 fb				ld a, (input_cursor) 
0e13 bb					cp e 
0e14 ca 29 0d				jp z, .is1		; at the end of string so dont go right 
0e17			 
0e17 3c					inc  a 		; TODO check overflow 
0e18 32 61 fb				ld (input_cursor), a 
0e1b			 
0e1b 3a 6e fb				ld a, (input_at_cursor) 
0e1e 3c					inc a 
0e1f 32 6e fb				ld (input_at_cursor), a 
0e22			 
0e22 2a 75 fb				ld hl, (input_ptr) 
0e25 23					inc hl 
0e26 22 75 fb				ld (input_ptr), hl 
0e29			 
0e29 3e 01				ld a, 1		; show cursor moving 
0e2b 32 6b fb				ld (input_cur_onoff),a 
0e2e 3e 0f				ld a, CUR_BLINK_RATE 
0e30 32 6c fb				ld (input_cur_flash), a 
0e33			 
0e33 c3 29 0d				jp .is1 
0e36			 
0e36 fe 05		.isk2:		cp KEY_UP 
0e38			 
0e38 20 26				jr nz, .isk3 
0e3a			 
0e3a					; swap last command with the current on 
0e3a			 
0e3a					; move cursor to start of string 
0e3a 2a 73 fb				ld hl, (input_start) 
0e3d 22 75 fb				ld (input_ptr), hl 
0e40			 
0e40 3a 70 fb				ld a, (input_at_pos) 
0e43 32 6e fb				ld (input_at_cursor), a 
0e46			 
0e46 3e 00				ld a, 0 
0e48 32 61 fb				ld (input_cursor), a 
0e4b					 
0e4b					; swap input and last command buffers 
0e4b			 
0e4b 21 58 f1				ld hl, os_cli_cmd 
0e4e 11 57 f2				ld de, os_last_cmd 
0e51 06 ff				ld b, 255 
0e53 7e			.swap1:		ld a, (hl) 
0e54 4f					ld c,a 
0e55 1a					ld a, (de) 
0e56 77					ld (hl), a 
0e57 79					ld a,c 
0e58 12					ld (de),a 
0e59 23					inc hl 
0e5a 13					inc de 
0e5b 10 f6				djnz .swap1 
0e5d			 
0e5d			 
0e5d			 
0e5d			 
0e5d			 
0e5d c3 29 0d				jp .is1 
0e60			 
0e60 fe 08		.isk3:		cp KEY_BS 
0e62 20 3c				jr nz, .isk4 
0e64			 
0e64 3a 61 fb				ld a, (input_cursor) 
0e67			 
0e67 fe 00				cp 0 
0e69 ca 29 0d				jp z, .is1 		; at start of line to ignore  
0e6c			 
0e6c 3d					dec  a 		; TODO check underflow 
0e6d 32 61 fb				ld (input_cursor), a 
0e70			 
0e70					; hl is source 
0e70					; de needs to be source - 1 
0e70			 
0e70			;		ld a, 0 
0e70			;		dec hl 
0e70			;		ld (hl), a 
0e70			 
0e70 2a 75 fb				ld hl, (input_ptr) 
0e73 2b					dec hl 
0e74 22 75 fb				ld (input_ptr), hl 
0e77			 
0e77					; shift all data 
0e77			 
0e77 e5					push hl 
0e78 23					inc hl 
0e79 d1					pop de 
0e7a 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0e7d 4f					ld c,a 
0e7e 06 00				ld b,0 
0e80 ed b0				ldir  
0e82			 
0e82			 
0e82			 
0e82			 
0e82 3a 6e fb				ld a, (input_at_cursor) 
0e85 3d					dec a 
0e86 32 6e fb				ld (input_at_cursor), a 
0e89			 
0e89			 
0e89 3e 01				ld a, 1		; show cursor moving 
0e8b 32 6b fb				ld (input_cur_onoff),a 
0e8e 3e 0f				ld a, CUR_BLINK_RATE 
0e90 32 6c fb				ld (input_cur_flash), a 
0e93			 
0e93					; remove char 
0e93 3a 6e fb				ld a, (input_at_cursor) 
0e96 3c					inc a 
0e97 11 21 0f				ld de,.iblank 
0e9a cd aa 0a				call str_at_display 
0e9d			 
0e9d c3 29 0d				jp .is1 
0ea0			 
0ea0 fe 0d		.isk4:		cp KEY_CR 
0ea2 28 6c				jr z, .endinput 
0ea4			 
0ea4					; else add the key press to the end 
0ea4			 
0ea4 4f					ld c, a			; save key pressed 
0ea5			 
0ea5 7e					ld a,(hl)		; get what is currently under char 
0ea6			 
0ea6 fe 00				cp 0			; we are at the end of the string 
0ea8 20 2f				jr nz, .onchar 
0eaa					 
0eaa					; add a char to the end of the string 
0eaa				 
0eaa 71					ld (hl),c 
0eab 23					inc hl 
0eac			;		ld a,' ' 
0eac			;		ld (hl),a 
0eac			;		inc hl 
0eac 3e 00				ld a,0 
0eae 77					ld (hl),a 
0eaf 2b					dec hl 
0eb0			 
0eb0 3a 61 fb				ld a, (input_cursor) 
0eb3 3c					inc a				; TODO check max string length and scroll  
0eb4 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0eb7							 
0eb7 3a 6e fb				ld a, (input_at_cursor) 
0eba 3c					inc a 
0ebb 32 6e fb				ld (input_at_cursor), a 
0ebe			 
0ebe 2a 75 fb				ld hl, (input_ptr) 
0ec1 23					inc hl 
0ec2 22 75 fb				ld (input_ptr), hl 
0ec5			 
0ec5 2a 75 fb				ld hl, (input_ptr) 
0ec8 23					inc hl 
0ec9 22 75 fb				ld (input_ptr), hl 
0ecc			;	if DEBUG_INPUT 
0ecc			;		push af 
0ecc			;		ld a, '+' 
0ecc			;		ld (debug_mark),a 
0ecc			;		pop af 
0ecc			;		CALLMONITOR 
0ecc			;	endif 
0ecc 3e 01				ld a, 1		; show cursor moving 
0ece 32 6b fb				ld (input_cur_onoff),a 
0ed1 3e 0f				ld a, CUR_BLINK_RATE 
0ed3 32 6c fb				ld (input_cur_flash), a 
0ed6 c3 29 0d				jp .is1 
0ed9					 
0ed9			 
0ed9			 
0ed9					; if on a char then insert 
0ed9			.onchar: 
0ed9			 
0ed9					; TODO over flow check: make sure insert does not blow out buffer 
0ed9			 
0ed9					; need to do some maths to use lddr 
0ed9			 
0ed9 e5					push hl   ; save char pos 
0eda c5					push bc 
0edb			 
0edb 2a 73 fb				ld hl, (input_start) 
0ede 3a 66 fb				ld a, (input_len) 
0ee1 cd cb 0c				call addatohl  		; end of string 
0ee4 23					inc hl 
0ee5 23					inc hl		; past zero term 
0ee6 e5					push hl 
0ee7 23					inc hl 
0ee8 e5					push hl  
0ee9			 
0ee9								; start and end of lddr set, now how much to move? 
0ee9			 
0ee9							 
0ee9 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0eec 47					ld b,a 
0eed 3a 66 fb				ld a,(input_len) 
0ef0 5f					ld e,a 
0ef1 90					sub b 
0ef2 3c					inc a		;?? 
0ef3 3c					inc a		;?? 
0ef4 3c					inc a		;?? 
0ef5			 
0ef5 06 00				ld b,0 
0ef7 4f					ld c,a 
0ef8			 
0ef8				if DEBUG_INPUT 
0ef8					push af 
0ef8					ld a, 'i' 
0ef8					ld (debug_mark),a 
0ef8					pop af 
0ef8			;		CALLMONITOR 
0ef8				endif 
0ef8 d1					pop de 
0ef9 e1					pop hl 
0efa				if DEBUG_INPUT 
0efa					push af 
0efa					ld a, 'I' 
0efa					ld (debug_mark),a 
0efa					pop af 
0efa			;		CALLMONITOR 
0efa				endif 
0efa ed b8				lddr 
0efc				 
0efc			 
0efc			 
0efc					; TODO have a key for insert/overwrite mode???? 
0efc c1					pop bc 
0efd e1					pop hl 
0efe 71					ld (hl), c		; otherwise overwrite current char 
0eff					 
0eff			 
0eff			 
0eff			 
0eff 3a 61 fb				ld a, (input_cursor) 
0f02 3c					inc  a 		; TODO check overflow 
0f03 32 61 fb				ld (input_cursor), a 
0f06			 
0f06 3a 6e fb				ld a, (input_at_cursor) 
0f09 3c					inc a 
0f0a 32 6e fb				ld (input_at_cursor), a 
0f0d			 
0f0d c3 29 0d				jp .is1 
0f10			 
0f10			.endinput:	; TODO look for end of string 
0f10			 
0f10					; add trailing space for end of token 
0f10			 
0f10 2a 73 fb				ld hl, (input_start) 
0f13 3a 66 fb				ld a,(input_len) 
0f16 cd cb 0c				call addatohl 
0f19 3e 20				ld a, ' ' 
0f1b 77					ld (hl),a 
0f1c					; TODO eof of parse marker 
0f1c			 
0f1c 23					inc hl 
0f1d 3e 00				ld a, 0 
0f1f 77					ld (hl),a 
0f20			 
0f20			 
0f20 c9					ret 
0f21			 
0f21 .. 00		.iblank: db " ",0 
0f23			 
0f23			 
0f23 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0f26 22 73 fb				ld (input_start), hl 
0f29 3e 01				ld a,1			; add cursor 
0f2b 77					ld (hl),a 
0f2c 23					inc hl 
0f2d 3e 00				ld a,0 
0f2f 77					ld (hl),a 
0f30 22 75 fb				ld (input_ptr), hl 
0f33 7a					ld a,d 
0f34 32 72 fb				ld (input_size), a 
0f37 3e 00				ld a,0 
0f39 32 61 fb				ld (input_cursor),a 
0f3c			.instr1:	 
0f3c			 
0f3c					; TODO do block cursor 
0f3c					; TODO switch cursor depending on the modifer key 
0f3c			 
0f3c					; update cursor shape change on key hold 
0f3c			 
0f3c 2a 75 fb				ld hl, (input_ptr) 
0f3f 2b					dec hl 
0f40 3a d0 f8				ld a,(cursor_shape) 
0f43 77					ld (hl), a 
0f44			 
0f44					; display entered text 
0f44 3a 70 fb				ld a,(input_at_pos) 
0f47 cd 96 65		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f4a ed 5b 73 fb	            	LD   de, (input_start) 
0f4e cd b8 65		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f51			 
0f51 cd d2 67				call cin 
0f54 fe 00				cp 0 
0f56 28 e4				jr z, .instr1 
0f58			 
0f58					; proecess keyboard controls first 
0f58			 
0f58 2a 75 fb				ld hl,(input_ptr) 
0f5b			 
0f5b fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f5d 28 5a				jr z, .instrcr 
0f5f			 
0f5f fe 08				cp KEY_BS 	; back space 
0f61 20 0f				jr nz, .instr2 
0f63					; process back space 
0f63			 
0f63					; TODO stop back space if at start of string 
0f63 2b					dec hl 
0f64 2b					dec hl ; to over write cursor 
0f65 3a d0 f8				ld a,(cursor_shape) 
0f68					;ld a,0 
0f68 77					ld (hl),a 
0f69 23					inc hl 
0f6a 3e 20				ld a," " 
0f6c 77					ld (hl),a 
0f6d 22 75 fb				ld (input_ptr),hl 
0f70					 
0f70			 
0f70 18 ca				jr .instr1 
0f72			 
0f72 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0f74 20 06				jr nz, .instr3 
0f76 2b					dec hl 
0f77 22 75 fb				ld (input_ptr),hl 
0f7a 18 c0				jr .instr1 
0f7c				 
0f7c fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0f7e 20 06				jr nz, .instr4 
0f80 23					inc hl 
0f81 22 75 fb				ld (input_ptr),hl 
0f84 18 b6				jr .instr1 
0f86			 
0f86 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0f88 20 06				jr nz, .instr5 
0f8a 2b					dec hl 
0f8b 22 75 fb				ld (input_ptr),hl 
0f8e 18 ac				jr .instr1 
0f90			 
0f90 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0f92 20 06				jr nz, .instr6 
0f94 2b					dec hl 
0f95 22 75 fb				ld (input_ptr),hl 
0f98 18 a2				jr .instr1 
0f9a fe 05		.instr6:        cp KEY_UP      ; recall last command 
0f9c 20 0b				jr nz, .instrnew 
0f9e			 
0f9e 21 31 ee			ld hl, scratch 
0fa1 11 57 f2			ld de, os_last_cmd 
0fa4 cd c2 0f			call strcpy 
0fa7 18 93				jr .instr1 
0fa9			 
0fa9			 
0fa9			.instrnew:	; no special key pressed to see if we have room to store it 
0fa9			 
0fa9					; TODO do string size test 
0fa9			 
0fa9 2b					dec hl ; to over write cursor 
0faa 77					ld (hl),a 
0fab 23					inc hl 
0fac 3a d0 f8				ld a,(cursor_shape) 
0faf 77					ld (hl),a 
0fb0 23					inc hl 
0fb1 3e 00				ld a,0 
0fb3 77					ld (hl),a 
0fb4			 
0fb4 22 75 fb				ld (input_ptr),hl 
0fb7					 
0fb7 18 83				jr .instr1 
0fb9 2b			.instrcr:	dec hl		; remove cursor 
0fba 3e 20				ld a,' '	; TODO add a trailing space for safety 
0fbc 77					ld (hl),a 
0fbd 23					inc hl 
0fbe 3e 00				ld a,0 
0fc0 77					ld (hl),a 
0fc1			 
0fc1			 
0fc1					; if at end of line scroll up    
0fc1					; TODO detecting only end of line 4 for scroll up  
0fc1			 
0fc1					;ld   
0fc1			 
0fc1 c9					ret 
0fc2			 
0fc2			 
0fc2			; strcpy hl = dest, de source 
0fc2			 
0fc2 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0fc3 b7			            OR   A              ;Null terminator? 
0fc4 c8			            RET  Z              ;Yes, so finished 
0fc5 1a					ld a,(de) 
0fc6 77					ld (hl),a 
0fc7 13			            INC  DE             ;Point to next character 
0fc8 23					inc hl 
0fc9 18 f7		            JR   strcpy       ;Repeat 
0fcb c9					ret 
0fcc			 
0fcc			 
0fcc			; TODO string_at  
0fcc			; pass string which starts with lcd offset address and then null term string 
0fcc			 
0fcc			; TODO string to dec 
0fcc			; TODO string to hex 
0fcc			; TODO byte to string hex 
0fcc			; TODO byte to string dec 
0fcc			 
0fcc			 
0fcc			 
0fcc			; from z80uartmonitor 
0fcc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fcc			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0fcc			; pass hl for where to put the text 
0fcc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fcc c5			hexout:	PUSH BC 
0fcd f5					PUSH AF 
0fce 47					LD B, A 
0fcf					; Upper nybble 
0fcf cb 3f				SRL A 
0fd1 cb 3f				SRL A 
0fd3 cb 3f				SRL A 
0fd5 cb 3f				SRL A 
0fd7 cd e7 0f				CALL tohex 
0fda 77					ld (hl),a 
0fdb 23					inc hl	 
0fdc					 
0fdc					; Lower nybble 
0fdc 78					LD A, B 
0fdd e6 0f				AND 0FH 
0fdf cd e7 0f				CALL tohex 
0fe2 77					ld (hl),a 
0fe3 23					inc hl	 
0fe4					 
0fe4 f1					POP AF 
0fe5 c1					POP BC 
0fe6 c9					RET 
0fe7					 
0fe7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fe7			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0fe7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fe7			tohex: 
0fe7 e5					PUSH HL 
0fe8 d5					PUSH DE 
0fe9 16 00				LD D, 0 
0feb 5f					LD E, A 
0fec 21 f4 0f				LD HL, .DATA 
0fef 19					ADD HL, DE 
0ff0 7e					LD A, (HL) 
0ff1 d1					POP DE 
0ff2 e1					POP HL 
0ff3 c9					RET 
0ff4			 
0ff4			.DATA: 
0ff4 30					DEFB	30h	; 0 
0ff5 31					DEFB	31h	; 1 
0ff6 32					DEFB	32h	; 2 
0ff7 33					DEFB	33h	; 3 
0ff8 34					DEFB	34h	; 4 
0ff9 35					DEFB	35h	; 5 
0ffa 36					DEFB	36h	; 6 
0ffb 37					DEFB	37h	; 7 
0ffc 38					DEFB	38h	; 8 
0ffd 39					DEFB	39h	; 9 
0ffe 41					DEFB	41h	; A 
0fff 42					DEFB	42h	; B 
1000 43					DEFB	43h	; C 
1001 44					DEFB	44h	; D 
1002 45					DEFB	45h	; E 
1003 46					DEFB	46h	; F 
1004			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1004			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1004			;;    subtract $30, if result > 9 then subtract $7 more 
1004			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1004			atohex: 
1004 d6 30				SUB $30 
1006 fe 0a				CP 10 
1008 f8					RET M		; If result negative it was 0-9 so we're done 
1009 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
100b c9					RET		 
100c			 
100c			 
100c			 
100c			 
100c			; Get 2 ASCII characters as hex byte from pointer in hl 
100c			 
100c			BYTERD: 
100c 16 00			LD	D,00h		;Set up 
100e cd 16 10			CALL	HEXCON		;Get byte and convert to hex 
1011 87				ADD	A,A		;First nibble so 
1012 87				ADD	A,A		;multiply by 16 
1013 87				ADD	A,A		; 
1014 87				ADD	A,A		; 
1015 57				LD	D,A		;Save hi nibble in D 
1016			HEXCON: 
1016 7e				ld a, (hl)		;Get next chr 
1017 23				inc hl 
1018 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
101a fe 0a			CP	00Ah		;Is it 0-9 ? 
101c 38 02			JR	C,NALPHA	;If so miss next bit 
101e d6 07			SUB	007h		;Else convert alpha 
1020			NALPHA: 
1020 b2				OR	D		;Add hi nibble back 
1021 c9				RET			; 
1022			 
1022			 
1022			; 
1022			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1022			; Since the routines get_byte and therefore get_nibble are called, only valid 
1022			; characters (0-9a-f) are accepted. 
1022			; 
1022			;get_word        push    af 
1022			;                call    get_byte        ; Get the upper byte 
1022			;                ld      h, a 
1022			;                call    get_byte        ; Get the lower byte 
1022			;                ld      l, a 
1022			;                pop     af 
1022			;                ret 
1022			; 
1022			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1022			; the routine get_nibble is used only valid characters are accepted - the  
1022			; input routine only accepts characters 0-9a-f. 
1022			; 
1022 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1023 7e					ld a,(hl) 
1024 23					inc hl 
1025 cd 4a 10		                call    nibble2val      ; Get upper nibble 
1028 cb 07		                rlc     a 
102a cb 07		                rlc     a 
102c cb 07		                rlc     a 
102e cb 07		                rlc     a 
1030 47			                ld      b, a            ; Save upper four bits 
1031 7e					ld a,(hl) 
1032 cd 4a 10		                call    nibble2val      ; Get lower nibble 
1035 b0			                or      b               ; Combine both nibbles 
1036 c1			                pop     bc              ; Restore B (and C) 
1037 c9			                ret 
1038			; 
1038			; Get a hexadecimal digit from the serial line. This routine blocks until 
1038			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1038			; to the serial line interface. The lower 4 bits of A contain the value of  
1038			; that particular digit. 
1038			; 
1038			;get_nibble      ld a,(hl)           ; Read a character 
1038			;                call    to_upper        ; Convert to upper case 
1038			;                call    is_hex          ; Was it a hex digit? 
1038			;                jr      nc, get_nibble  ; No, get another character 
1038			 ;               call    nibble2val      ; Convert nibble to value 
1038			 ;               call    print_nibble 
1038			 ;               ret 
1038			; 
1038			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1038			; A valid hexadecimal digit is denoted by a set C flag. 
1038			; 
1038			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1038			;                ret     nc              ; Yes 
1038			;                cp      '0'             ; Less than '0'? 
1038			;                jr      nc, is_hex_1    ; No, continue 
1038			;                ccf                     ; Complement carry (i.e. clear it) 
1038			;                ret 
1038			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1038			;                ret     c               ; Yes 
1038			;                cp      'A'             ; Less than 'A'? 
1038			;                jr      nc, is_hex_2    ; No, continue 
1038			;                ccf                     ; Yes - clear carry and return 
1038			;                ret 
1038			;is_hex_2        scf                     ; Set carry 
1038			;                ret 
1038			; 
1038			; Convert a single character contained in A to upper case: 
1038			; 
1038 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
103a d8			                ret     c 
103b fe 7b		                cp      'z' + 1         ; > 'z'? 
103d d0			                ret     nc              ; Nothing to do, either 
103e e6 5f		                and     $5f             ; Convert to upper case 
1040 c9			                ret 
1041			 
1041			 
1041			to_lower: 
1041			 
1041			   ; if char is in [A-Z] make it lower case 
1041			 
1041			   ; enter : a = char 
1041			   ; exit  : a = lower case char 
1041			   ; uses  : af 
1041			 
1041 fe 41		   cp 'A' 
1043 d8			   ret c 
1044			    
1044 fe 5b		   cp 'Z'+1 
1046 d0			   ret nc 
1047			    
1047 f6 20		   or $20 
1049 c9			   ret 
104a			 
104a			; 
104a			; Expects a hexadecimal digit (upper case!) in A and returns the 
104a			; corresponding value in A. 
104a			; 
104a fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
104c 38 02		                jr      c, nibble2val_1 ; Yes 
104e d6 07		                sub     7               ; Adjust for A-F 
1050 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1052 e6 0f		                and     $f              ; Only return lower 4 bits 
1054 c9			                ret 
1055			; 
1055			; Print_nibble prints a single hex nibble which is contained in the lower  
1055			; four bits of A: 
1055			; 
1055			;print_nibble    push    af              ; We won't destroy the contents of A 
1055			;                and     $f              ; Just in case... 
1055			;                add     a, '0'             ; If we have a digit we are done here. 
1055			;                cp      '9' + 1         ; Is the result > 9? 
1055			;                jr      c, print_nibble_1 
1055			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1055			;print_nibble_1  call    putc            ; Print the nibble and 
1055			;                pop     af              ; restore the original value of A 
1055			;                ret 
1055			;; 
1055			;; Send a CR/LF pair: 
1055			; 
1055			;crlf            push    af 
1055			;                ld      a, cr 
1055			;                call    putc 
1055			;                ld      a, lf 
1055			;                call    putc 
1055			;                pop     af 
1055			;                ret 
1055			; 
1055			; Print_word prints the four hex digits of a word to the serial line. The  
1055			; word is expected to be in HL. 
1055			; 
1055			;print_word      push    hl 
1055			;                push    af 
1055			;                ld      a, h 
1055			;                call    print_byte 
1055			;                ld      a, l 
1055			;                call    print_byte 
1055			;                pop     af 
1055			;                pop     hl 
1055			;                ret 
1055			; 
1055			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1055			; The byte to be printed is expected to be in A. 
1055			; 
1055			;print_byte      push    af              ; Save the contents of the registers 
1055			;                push    bc 
1055			;                ld      b, a 
1055			;                rrca 
1055			;                rrca 
1055			;                rrca 
1055			;                rrca 
1055			;                call    print_nibble    ; Print high nibble 
1055			;                ld      a, b 
1055			;                call    print_nibble    ; Print low nibble 
1055			;                pop     bc              ; Restore original register contents 
1055			;                pop     af 
1055			;                ret 
1055			 
1055			 
1055			 
1055			 
1055			 
1055			fourehexhl:  
1055 7e				ld a,(hl) 
1056 cd 04 10			call atohex 
1059 cb 3f				SRL A 
105b cb 3f				SRL A 
105d cb 3f				SRL A 
105f cb 3f				SRL A 
1061 47				ld b, a 
1062 23				inc hl 
1063 7e				ld a,(hl) 
1064 23				inc hl 
1065 cd 04 10			call atohex 
1068 80				add b 
1069 57				ld d,a 
106a 7e				ld a,(hl) 
106b cd 04 10			call atohex 
106e cb 3f				SRL A 
1070 cb 3f				SRL A 
1072 cb 3f				SRL A 
1074 cb 3f				SRL A 
1076 47				ld b, a 
1077 23				inc hl 
1078 7e				ld a,(hl) 
1079 23				inc hl 
107a cd 04 10			call atohex 
107d 80				add b 
107e 5f				ld e, a 
107f d5				push de 
1080 e1				pop hl 
1081 c9				ret 
1082			 
1082			; pass hl. returns z set if the byte at hl is a digit 
1082			;isdigithl:  
1082			;	push bc 
1082			;	ld a,(hl) 
1082			;	cp ':' 
1082			;	jr nc, .isdf 		; > 
1082			;	cp '0' 
1082			;	jr c, .isdf		; < 
1082			; 
1082			;	; TODO find a better way to set z 
1082			; 
1082			;	ld b,a 
1082			;	cp b 
1082			;	pop bc 
1082			;	ret 
1082			; 
1082			;.isdf:	; not digit so clear z 
1082			; 
1082			;	; TODO find a better way to unset z 
1082			; 
1082			;	ld b,a 
1082			;	inc b 
1082			;	cp b 
1082			; 
1082			;	pop bc 
1082			;	ret 
1082				 
1082				 
1082			 
1082			 
1082			; pass hl as the four byte address to load 
1082			 
1082			get_word_hl:  
1082 e5				push hl 
1083 cd 22 10			call get_byte 
1086				 
1086 47				ld b, a 
1087			 
1087 e1				pop hl 
1088 23				inc hl 
1089 23				inc hl 
108a			 
108a			; TODO not able to handle a-f  
108a 7e				ld a,(hl) 
108b			;	;cp ':' 
108b			;	cp 'g' 
108b			;	jr nc, .single_byte_hl 		; > 
108b			;	cp 'G' 
108b			;	jr nc, .single_byte_hl 		; > 
108b			;	cp '0' 
108b			;	jr c, .single_byte_hl		; < 
108b			 
108b				;call isdigithl 
108b fe 00			cp 0 
108d 28 06			jr z, .single_byte_hl 
108f			 
108f			.getwhln:   ; hex word so get next byte 
108f			 
108f cd 22 10			call get_byte 
1092 6f				ld l, a 
1093 60				ld h,b 
1094 c9				ret 
1095 68			.single_byte_hl:   ld l,b 
1096 26 00				ld h,0 
1098 c9					ret 
1099			 
1099			 
1099			 
1099			 
1099 21 bb 18			ld hl,asc+1 
109c			;	ld a, (hl) 
109c			;	call nibble2val 
109c cd 22 10			call get_byte 
109f			 
109f			;	call fourehexhl 
109f 32 65 ee			ld (scratch+52),a 
10a2				 
10a2 21 63 ee			ld hl,scratch+50 
10a5 22 54 f1			ld (os_cur_ptr),hl 
10a8			 
10a8 c9				ret 
10a9			 
10a9			 
10a9			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10a9			 
10a9			; Decimal Unsigned Version 
10a9			 
10a9			;Number in a to decimal ASCII 
10a9			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10a9			;Example: display a=56 as "056" 
10a9			;input: a = number 
10a9			;Output: a=0,value of a in the screen 
10a9			;destroys af,bc (don't know about hl and de) 
10a9			DispAToASCII: 
10a9 0e 9c			ld	c,-100 
10ab cd b5 10			call	.Na1 
10ae 0e f6			ld	c,-10 
10b0 cd b5 10			call	.Na1 
10b3 0e ff			ld	c,-1 
10b5 06 2f		.Na1:	ld	b,'0'-1 
10b7 04			.Na2:	inc	b 
10b8 81				add	a,c 
10b9 38 fc			jr	c,.Na2 
10bb 91				sub	c		;works as add 100/10/1 
10bc f5				push af		;safer than ld c,a 
10bd 78				ld	a,b		;char is in b 
10be			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10be f1				pop af		;safer than ld a,c 
10bf c9				ret 
10c0			 
10c0			; Decimal Signed Version 
10c0			 
10c0			; DispA 
10c0			; -------------------------------------------------------------- 
10c0			; Converts a signed integer value to a zero-terminated ASCII 
10c0			; string representative of that value (using radix 10). 
10c0			; -------------------------------------------------------------- 
10c0			; INPUTS: 
10c0			;     HL     Value to convert (two's complement integer). 
10c0			;     DE     Base address of string destination. (pointer). 
10c0			; -------------------------------------------------------------- 
10c0			; OUTPUTS: 
10c0			;     None 
10c0			; -------------------------------------------------------------- 
10c0			; REGISTERS/MEMORY DESTROYED 
10c0			; AF HL 
10c0			; -------------------------------------------------------------- 
10c0			 
10c0			;DispHLToASCII: 
10c0			;   push    de 
10c0			;   push    bc 
10c0			; 
10c0			;; Detect sign of HL. 
10c0			;    bit    7, h 
10c0			;    jr     z, ._DoConvert 
10c0			; 
10c0			;; HL is negative. Output '-' to string and negate HL. 
10c0			;    ld     a, '-' 
10c0			;    ld     (de), a 
10c0			;    inc    de 
10c0			; 
10c0			;; Negate HL (using two's complement) 
10c0			;    xor    a 
10c0			;    sub    l 
10c0			;    ld     l, a 
10c0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10c0			;    sbc    a, h 
10c0			;    ld     h, a 
10c0			; 
10c0			;; Convert HL to digit characters 
10c0			;._DoConvert: 
10c0			;    ld     b, 0     ; B will count character length of number 
10c0			;-   ld     a, 10 
10c0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10c0			;    push   af 
10c0			;    inc    b 
10c0			;    ld     a, h 
10c0			;    or     l 
10c0			;    jr     nz, - 
10c0			; 
10c0			;; Retrieve digits from stack 
10c0			;-   pop    af 
10c0			;    or     $30 
10c0			;    ld     (de), a 
10c0			;    inc    de 
10c0			;    djnz   - 
10c0			; 
10c0			;; Terminate string with NULL 
10c0			;    xor    a 
10c0			;    ld     (de), a 
10c0			; 
10c0			;    pop    bc 
10c0			;    pop    de 
10c0			;    ret 
10c0			 
10c0			;Comments 
10c0			; 
10c0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10c0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10c0			;    Note that the output string will not be fixed-width. 
10c0			; 
10c0			;Example Usage 
10c0			; 
10c0			;    ld    hl, -1004 
10c0			;    ld    de, OP1 
10c0			;    call  DispA 
10c0			;    ld    hl, OP1 
10c0			;    syscall  PutS 
10c0			 
10c0			 
10c0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10c0			 
10c0			 
10c0			;Converts an ASCII string to an unsigned 16-bit integer 
10c0			;Quits when it reaches a non-decimal digit 
10c0			 
10c0			string_to_uint16: 
10c0			atoui_16: 
10c0			;Input: 
10c0			;     DE points to the string 
10c0			;Outputs: 
10c0			;     HL is the result 
10c0			;     A is the 8-bit value of the number 
10c0			;     DE points to the byte after the number 
10c0			;Destroys: 
10c0			;     BC 
10c0			;       if the string is non-empty, BC is HL/10 
10c0			;Size:  24 bytes 
10c0			;Speed: 42+d(104+{0,9}) 
10c0			;       d is the number of digits in the number 
10c0			;       max is 640 cycles for a 5 digit number 
10c0			;Assuming no leading zeros: 
10c0			;1 digit:  146cc 
10c0			;2 digit:  250cc 
10c0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10c0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10c0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10c0			;avg: 544.81158447265625cc (544+13297/16384) 
10c0			;=============================================================== 
10c0 21 00 00		  ld hl,0 
10c3			.u16a: 
10c3 1a			  ld a,(de) 
10c4 d6 30		  sub 30h 
10c6 fe 0a		  cp 10 
10c8 d0			  ret nc 
10c9 13			  inc de 
10ca 44			  ld b,h 
10cb 4d			  ld c,l 
10cc 29			  add hl,hl 
10cd 29			  add hl,hl 
10ce 09			  add hl,bc 
10cf 29			  add hl,hl 
10d0 85			  add a,l 
10d1 6f			  ld l,a 
10d2 30 ef		  jr nc,.u16a 
10d4 24			  inc h 
10d5 c3 c3 10		  jp .u16a 
10d8			 
10d8			 
10d8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10d8			 
10d8			;written by Zeda 
10d8			;Converts a 16-bit unsigned integer to an ASCII string. 
10d8			 
10d8			uitoa_16: 
10d8			;Input: 
10d8			;   DE is the number to convert 
10d8			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
10d8			;Output: 
10d8			;   HL points to the null-terminated ASCII string 
10d8			;      NOTE: This isn't necessarily the same as the input HL. 
10d8 d5			  push de 
10d9 c5			  push bc 
10da f5			  push af 
10db eb			  ex de,hl 
10dc			 
10dc 01 f0 d8		  ld bc,-10000 
10df 3e 2f		  ld a,'0'-1 
10e1 3c			  inc a 
10e2 09			  add hl,bc  
10e3 38 fc		   jr c,$-2 
10e5 12			  ld (de),a 
10e6 13			  inc de 
10e7			 
10e7 01 e8 03		  ld bc,1000 
10ea 3e 3a		  ld a,'9'+1 
10ec 3d			  dec a  
10ed 09			  add hl,bc  
10ee 30 fc		   jr nc,$-2 
10f0 12			  ld (de),a 
10f1 13			  inc de 
10f2			 
10f2 01 9c ff		  ld bc,-100 
10f5 3e 2f		  ld a,'0'-1 
10f7 3c			  inc a  
10f8 09			  add hl,bc  
10f9 38 fc		   jr c,$-2 
10fb 12			  ld (de),a 
10fc 13			  inc de 
10fd			 
10fd 7d			  ld a,l 
10fe 26 3a		  ld h,'9'+1 
1100 25			  dec h  
1101 c6 0a		  add a,10  
1103 30 fb		   jr nc,$-3 
1105 c6 30		  add a,'0' 
1107 eb			  ex de,hl 
1108 72			  ld (hl),d 
1109 23			  inc hl 
110a 77			  ld (hl),a 
110b 23			  inc hl 
110c 36 00		  ld (hl),0 
110e			 
110e			;Now strip the leading zeros 
110e 0e fa		  ld c,-6 
1110 09			  add hl,bc 
1111 3e 30		  ld a,'0' 
1113 23			  inc hl  
1114 be			  cp (hl)  
1115 28 fc		  jr z,$-2 
1117			 
1117			;Make sure that the string is non-empty! 
1117 7e			  ld a,(hl) 
1118 b7			  or a 
1119 20 01		  jr nz,.atoub 
111b 2b			  dec hl 
111c			.atoub: 
111c			 
111c f1			  pop af 
111d c1			  pop bc 
111e d1			  pop de 
111f c9			  ret 
1120			 
1120			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1120			 
1120			toUpper: 
1120			;A is the char. 
1120			;If A is a lowercase letter, this sets it to the matching uppercase 
1120			;18cc or 30cc or 41cc 
1120			;avg: 26.75cc 
1120 fe 61		  cp 'a' 
1122 d8			  ret c 
1123 fe 7b		  cp 'z'+1 
1125 d0			  ret nc 
1126 d6 20		  sub 'a'-'A' 
1128 c9			  ret 
1129			 
1129			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1129			 
1129			; String Length 
1129			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1129			 
1129			; Get the length of the null-terminated string starting at $8000 hl 
1129			;    LD     HL, $8000 
1129			 
1129			strlenz: 
1129			 
1129 af			    XOR    A               ; Zero is the value we are looking for. 
112a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
112b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
112c			                           ; 65, 536 bytes (the entire addressable memory space). 
112c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
112e			 
112e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
112e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
112f 6f			    LD     L, A             ; number of bytes 
1130 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1132 2b			    DEC    HL              ; Compensate for null. 
1133 c9				ret 
1134			 
1134			; Get the length of the A terminated string starting at $8000 hl 
1134			;    LD     HL, $8000 
1134			 
1134			strlent: 
1134			 
1134			                  ; A is the value we are looking for. 
1134 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1136 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1138			                           ; 65, 536 bytes (the entire addressable memory space). 
1138 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
113a			 
113a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
113a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
113c 2e 00		    LD     L, 0             ; number of bytes 
113e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1140 2b			    DEC    HL              ; Compensate for null. 
1141 c9				ret 
1142			 
1142			 
1142			;Comparing Strings 
1142			 
1142			;IN    HL     Address of string1. 
1142			;      DE     Address of string2. 
1142			 
1142			; doc given but wrong??? 
1142			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1142			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1142			; tested 
1142			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1142			 
1142			strcmp_old: 
1142 e5			    PUSH   HL 
1143 d5			    PUSH   DE 
1144			 
1144 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1145 be			    CP     (HL)            ; (want to minimize work). 
1146 38 01		    JR     C, Str1IsBigger 
1148 7e			    LD     A, (HL) 
1149			 
1149			Str1IsBigger: 
1149 4f			    LD     C, A             ; Put length in BC 
114a 06 00		    LD     B, 0 
114c 13			    INC    DE              ; Increment pointers to meat of string. 
114d 23			    INC    HL 
114e			 
114e			CmpLoop: 
114e 1a			    LD     A, (DE)          ; Compare bytes. 
114f ed a1		    CPI 
1151 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1153 13			    INC    DE              ; Update pointer. 
1154 ea 4e 11		    JP     PE, CmpLoop 
1157			 
1157 d1			    POP    DE 
1158 e1			    POP    HL 
1159 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
115a be			    CP     (HL) 
115b c9			    RET 
115c			 
115c			NoMatch: 
115c 2b			    DEC    HL 
115d be			    CP     (HL)            ; Compare again to affect carry. 
115e d1			    POP    DE 
115f e1			    POP    HL 
1160 c9			    RET 
1161			 
1161			;; test strmp 
1161			; 
1161			;ld de, .str1 
1161			;ld hl, .str2 
1161			;call strcmp 
1161			;jr z, .z1 
1161			;;this 
1161			;	if DEBUG_FORTH_WORDS 
1161			;		DMARK "NZ1" 
1161			;		CALLMONITOR 
1161			;	endif 
1161			;.z1: 
1161			; 
1161			;	if DEBUG_FORTH_WORDS 
1161			;		DMARK "ZZ1" 
1161			;		CALLMONITOR 
1161			;	endif 
1161			; 
1161			;ld de, .str1 
1161			;ld hl, .str1 
1161			;call strcmp 
1161			;jr z, .z2 
1161			;;this 
1161			;	if DEBUG_FORTH_WORDS 
1161			;		DMARK "NZ2" 
1161			;		CALLMONITOR 
1161			;	endif 
1161			;.z2: 
1161			; 
1161			;	if DEBUG_FORTH_WORDS 
1161			;		DMARK "ZZ2" 
1161			;		CALLMONITOR 
1161			;	endif 
1161			; 
1161			;ld de, .str1 
1161			;ld hl, .str2 
1161			;call strcmp 
1161			;jr c, .c1 
1161			; 
1161			;	if DEBUG_FORTH_WORDS 
1161			;		DMARK "Nc1" 
1161			;		CALLMONITOR 
1161			;	endif 
1161			;.c1: 
1161			;;this 
1161			;	if DEBUG_FORTH_WORDS 
1161			;		DMARK "cc1" 
1161			;		CALLMONITOR 
1161			;	endif 
1161			; 
1161			;ld de, .str1 
1161			;ld hl, .str1 
1161			;call strcmp 
1161			;jr c, .c2 
1161			;;this 
1161			;	if DEBUG_FORTH_WORDS 
1161			;		DMARK "Nc2" 
1161			;		CALLMONITOR 
1161			;	endif 
1161			;.c2: 
1161			; 
1161			;	if DEBUG_FORTH_WORDS 
1161			;		DMARK "cc2" 
1161			;		CALLMONITOR 
1161			;	endif 
1161			;	NEXTW 
1161			;.str1:   db "string1",0 
1161			;.str2:   db "string2",0 
1161			 
1161			; only care about direct match or not 
1161			; hl and de strings 
1161			; zero set if the same 
1161			 
1161			strcmp: 
1161 1a				ld a, (de) 
1162 be				cp (hl) 
1163 28 02			jr z, .ssame 
1165 b7				or a 
1166 c9				ret 
1167			 
1167			.ssame:  
1167 fe 00			cp 0 
1169 c8				ret z 
116a			 
116a 23				inc hl 
116b 13				inc de 
116c 18 f3			jr strcmp 
116e				 
116e				 
116e			 
116e			 
116e			 
116e			 
116e			; eof 
116e			 
116e			 
116e			 
116e			 
116e			 
116e			 
# End of file firmware_strings.asm
116e			include "firmware_memory.asm"   ; malloc and free  
116e			 
116e			if DEBUG_FORTH_MALLOC_HIGH 
116e			.mallocsize: db "Wants malloc >256",0 
116e			.mallocasize: db "MALLOC gives >256",0 
116e			.malloczero: db "MALLOC gives zero",0 
116e			 
116e			malloc_guard_zerolen: 
116e				push hl 
116e				push de 
116e				push af 
116e			 
116e				ld de, 0 
116e			        call cmp16 
116e				jr nz, .lowalloz 
116e			 
116e				push hl 
116e				push de 
116e					ld hl, display_fb0 
116e					ld (display_fb_active), hl 
116e				call clear_display 
116e				ld a, 0 
116e				ld de, .malloczero 
116e				call str_at_display 
116e				call update_display 
116e				call delay1s 
116e				call delay1s 
116e				ld a, 0 
116e				ld (os_view_disable), a 
116e			 
116e				pop de 
116e				pop hl 
116e			 
116e				 
116e			 
116e				CALLMONITOR 
116e			.lowalloz: 
116e			 
116e			 
116e				pop af 
116e				pop de 
116e				pop hl 
116e			ret 
116e			 
116e			malloc_guard_entry: 
116e				push hl 
116e				push de 
116e				push af 
116e			 
116e			 	or a      ;clear carry flag 
116e				push hl 
116e				ld de, 255 
116e				sbc hl, de 
116e				jr c, .lowalloc 
116e			 
116e				push de 
116e					ld hl, display_fb0 
116e					ld (display_fb_active), hl 
116e				call clear_display 
116e				ld a, 0 
116e				ld de, .mallocsize 
116e				call str_at_display 
116e				call update_display 
116e				call delay1s 
116e				call delay1s 
116e				ld a, 0 
116e				ld (os_view_disable), a 
116e			 
116e				pop de 
116e				pop hl 
116e			 
116e				 
116e			 
116e				CALLMONITOR 
116e				jr .lowdone 
116e			.lowalloc: 
116e			 
116e			 
116e				pop hl 
116e			.lowdone:	pop af 
116e				pop de 
116e				pop hl 
116e			ret 
116e			 
116e			malloc_guard_exit: 
116e				push hl 
116e				push de 
116e				push af 
116e			 
116e			 	or a      ;clear carry flag 
116e				push hl 
116e				ld de, 255 
116e				sbc hl, de 
116e				jr c, .lowallocx 
116e			 
116e				push de 
116e					ld hl, display_fb0 
116e					ld (display_fb_active), hl 
116e				call clear_display 
116e				ld a, 0 
116e				ld de, .mallocasize 
116e				call str_at_display 
116e				call update_display 
116e				call delay1s 
116e				call delay1s 
116e				ld a, 0 
116e				ld (os_view_disable), a 
116e				pop de 
116e				pop hl 
116e			 
116e				CALLMONITOR 
116e				jr .lowdonex 
116e			.lowallocx: 
116e			 
116e				pop hl 
116e			.lowdonex:	pop af 
116e				pop de 
116e				pop hl 
116e			ret 
116e			endif 
116e			 
116e			if MALLOC_2 
116e			; Z80 Malloc and Free Functions 
116e			 
116e			; Malloc Function: 
116e			; Input: 
116e			;   HL: Size of block to allocate 
116e			; Output: 
116e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
116e			 
116e			malloc: 
116e				 
116e			if DEBUG_FORTH_MALLOC_HIGH 
116e			call malloc_guard_entry 
116e			endif 
116e			 
116e			 
116e			 
116e			 
116e					if DEBUG_FORTH_MALLOC 
116e						DMARK "mal" 
116e						CALLMONITOR 
116e					endif 
116e			    push af            ; Save AF register 
116e			    ld a, l            ; Load low byte of size into A 
116e			    or h               ; Check if size is zero 
116e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
116e			 
116e			    ; Allocate memory 
116e			    ld hl, (heap_start) ; Load start of heap into HL 
116e					if DEBUG_FORTH_MALLOC 
116e						DMARK "ma1" 
116e						CALLMONITOR 
116e					endif 
116e			    call malloc_internal ; Call internal malloc function 
116e			    pop af             ; Restore AF register 
116e			if DEBUG_FORTH_MALLOC_HIGH 
116e			call malloc_guard_exit 
116e			call malloc_guard_zerolen 
116e			endif 
116e			    ret                ; Return 
116e			 
116e			; Free Function: 
116e			; Input: 
116e			;   HL: Pointer to memory block to free 
116e			; Output: 
116e			;   None 
116e			 
116e			free: 
116e			    push af            ; Save AF register 
116e			    ld a, l            ; Load low byte of pointer into A 
116e			    or h               ; Check if pointer is NULL 
116e			    jp z, free_exit    ; If pointer is NULL, exit 
116e			 
116e			    ; Free memory 
116e			    ld hl, (heap_start) ; Load start of heap into HL 
116e			    call free_internal  ; Call internal free function 
116e			    pop af             ; Restore AF register 
116e			    ret                ; Return 
116e			 
116e			; Internal Malloc Function: 
116e			; Input: 
116e			;   HL: Size of block to allocate 
116e			; Output: 
116e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
116e			 
116e			malloc_internal: 
116e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
116e			    add hl, bc         ; Add management overhead to requested size 
116e			    ex de, hl          ; Save total size in DE, and keep it in HL 
116e					if DEBUG_FORTH_MALLOC 
116e						DMARK "ma2" 
116e						CALLMONITOR 
116e					endif 
116e			 
116e			    ; Search for free memory block 
116e			    ld de, (heap_end)  ; Load end of heap into DE 
116e			    ld bc, 0           ; Initialize counter 
116e			 
116e					if DEBUG_FORTH_MALLOC 
116e						DMARK "ma2" 
116e						CALLMONITOR 
116e					endif 
116e			malloc_search_loop: 
116e			    ; Check if current block is free 
116e			    ld a, (hl)         ; Load current block's status (free or used) 
116e			    cp 0               ; Compare with zero (free) 
116e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
116e			 
116e			    ; Check if current block is large enough 
116e			    ld a, (hl+1)       ; Load high byte of block size 
116e			    cp l               ; Compare with low byte of requested size 
116e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
116e			 
116e			    ld a, (hl+2)       ; Load low byte of block size 
116e			    cp h               ; Compare with high byte of requested size 
116e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
116e			 
116e			    ; Mark block as used 
116e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
116e			 
116e			    ; Calculate remaining space in block 
116e			    ld bc, 0           ; Clear BC 
116e			    add hl, bc         ; Increment HL to point to start of data block 
116e			    add hl, de         ; HL = HL + DE (total size) 
116e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
116e			    add hl, bc         ; Add management overhead to start of data block 
116e			 
116e			    ; Save pointer to allocated block in HL 
116e			if DEBUG_FORTH_MALLOC_HIGH 
116e						DMARK "ma5" 
116e			call malloc_guard_exit 
116e			call malloc_guard_zerolen 
116e			endif 
116e			    ret 
116e			 
116e			malloc_skip_block_check: 
116e			    ; Move to the next block 
116e			    ld bc, 3           ; Size of management overhead 
116e			    add hl, bc         ; Move to the next block 
116e			    inc de             ; Increment counter 
116e			 
116e			    ; Check if we have reached the end of heap 
116e			    ld a, e            ; Load low byte of heap end address 
116e			    cp (hl)            ; Compare with low byte of current address 
116e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
116e			    ld a, d            ; Load high byte of heap end address 
116e			    cp 0               ; Check if it's zero (end of memory) 
116e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
116e			 
116e			    ; If we reached here, allocation failed 
116e			    xor a              ; Set result to NULL 
116e			if DEBUG_FORTH_MALLOC_HIGH 
116e						DMARK "ma6" 
116e			call malloc_guard_exit 
116e			call malloc_guard_zerolen 
116e			endif 
116e			    ret 
116e			malloc_exit: 
116e			if DEBUG_FORTH_MALLOC_HIGH 
116e						DMARK "ma7" 
116e			call malloc_guard_exit 
116e			call malloc_guard_zerolen 
116e			endif 
116e			    ret 
116e			 
116e			; Internal Free Function: 
116e			; Input: 
116e			;   HL: Pointer to memory block to free 
116e			; Output: 
116e			;   None 
116e			 
116e			free_internal: 
116e			    ld de, (heap_start) ; Load start of heap into DE 
116e			    ld bc, 0            ; Initialize counter 
116e			 
116e			free_search_loop: 
116e			    ; Check if current block contains the pointer 
116e			    ld a, l             ; Load low byte of pointer 
116e			    cp (hl+1)           ; Compare with high byte of current block's address 
116e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
116e			    ld a, h             ; Load high byte of pointer 
116e			    cp (hl+2)           ; Compare with low byte of current block's address 
116e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
116e			 
116e			    ; Mark block as free 
116e			    ld (hl), 0          ; Set status byte to indicate free block 
116e			    ret                 ; Return 
116e			 
116e			free_skip_block_check: 
116e			    ; Move to the next block 
116e			    ld bc, 3            ; Size of management overhead 
116e			    add hl, bc          ; Move to the next block 
116e			    inc de              ; Increment counter 
116e			 
116e			    ; Check if we have reached the end of heap 
116e			    ld a, e             ; Load low byte of heap end address 
116e			    cp (hl)             ; Compare with low byte of current address 
116e			    jr nz, free_search_loop  ; If not equal, continue searching 
116e			    ld a, d             ; Load high byte of heap end address 
116e			    cp 0                ; Check if it's zero (end of memory) 
116e			    jr nz, free_search_loop  ; If not zero, continue searching 
116e			 
116e			    ; If we reached here, pointer is not found in heap 
116e			    ret 
116e			 
116e			free_exit: 
116e			    ret                 ; Return 
116e			 
116e			; Define heap start and end addresses 
116e			;heap_start:    .dw 0xC000   ; Start of heap 
116e			;heap_end:      .dw 0xE000   ; End of heap 
116e			 
116e			endif 
116e			 
116e			 
116e			if MALLOC_1 
116e			 
116e			 
116e			 
116e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
116e			 
116e			;moved to firmware.asm 
116e			;heap_start        .equ  0x9000      ; Starting address of heap 
116e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
116e			 
116e			;      .org 0 
116e			;      jp    main 
116e			 
116e			 
116e			;      .org  0x100 
116e			;main: 
116e			;      ld    HL, 0x8100 
116e			;      ld    SP, HL 
116e			; 
116e			;      call  heap_init 
116e			; 
116e			;      ; Make some allocations 
116e			;      ld    HL, 12 
116e			;      call  malloc            ; Allocates 0x9004 
116e			; 
116e			;      ld    HL, 12 
116e			;      call  malloc            ; Allocates 0x9014 
116e			; 
116e			;      ld    HL, 12 
116e			;      call  malloc            ; Allocates 0x9024 
116e			; 
116e			;      ; Free some allocations 
116e			;      ld    HL, 0x9014 
116e			;      call  free 
116e			; 
116e			;      ld    HL, 0x9004 
116e			;      call  free 
116e			; 
116e			;      ld    HL, 0x9024 
116e			;      call  free 
116e			; 
116e			; 
116e			;      halt 
116e			 
116e			 
116e			;------------------------------------------------------------------------------ 
116e			;     heap_init                                                               : 
116e			;                                                                             : 
116e			; Description                                                                 : 
116e			;     Initialise the heap and make it ready for malloc and free operations.   : 
116e			;                                                                             : 
116e			;     The heap is maintained as a linked list, starting with an initial       : 
116e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
116e			;     the first free block in the heap. Each block then points to the next    : 
116e			;     free block within the heap, and the free list ends at the first block   : 
116e			;     with a null pointer to the next free block.                             : 
116e			;                                                                             : 
116e			; Parameters                                                                  : 
116e			;     Inputs are compile-time only. Two defines which specify the starting    : 
116e			;     address of the heap and its size are required, along with a memory      : 
116e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
116e			;     principally stores a pointer to the first free block in the heap.       : 
116e			;                                                                             : 
116e			; Returns                                                                     : 
116e			;     Nothing                                                                 : 
116e			;------------------------------------------------------------------------------ 
116e			heap_init: 
116e e5			      push  HL 
116f			 
116f			      ; Initialise free list struct 
116f 21 0e 80		      ld    HL, heap_start 
1172 22 0a 80		      ld    (free_list), HL 
1175 21 00 00		      ld    HL, 0 
1178 22 0c 80		      ld    (free_list+2), HL 
117b			 
117b			      ; Insert first free block at bottom of heap, consumes entire heap 
117b 21 21 ee		      ld    HL, heap_start+heap_size-4 
117e 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1181 21 13 6e		      ld    HL, heap_size-4 
1184 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1187			 
1187			      ; Insert end of free list block at top of heap - two null words will 
1187			      ; terminate the free list 
1187 21 00 00		      ld    HL, 0 
118a 22 23 ee		      ld    (heap_start+heap_size-2), HL 
118d 22 21 ee		      ld    (heap_start+heap_size-4), HL 
1190			 
1190 e1			      pop   HL 
1191			 
1191 c9			      ret 
1192			 
1192			 
1192			;------------------------------------------------------------------------------ 
1192			;     malloc                                                                  : 
1192			;                                                                             : 
1192			; Description                                                                 : 
1192			;     Allocates the wanted space from the heap and returns the address of the : 
1192			;     first useable byte of the allocation.                                   : 
1192			;                                                                             : 
1192			;     Allocations can happen in one of two ways:                              : 
1192			;                                                                             : 
1192			;     1. A free block may be found which is the exact size wanted. In this    : 
1192			;        case the block is removed from the free list and retuedn to the      : 
1192			;        caller.                                                              : 
1192			;     2. A free block may be found which is larger than the size wanted. In   : 
1192			;        this case, the larger block is split into two. The first portion of  : 
1192			;        this block will become the requested space by the malloc call and    : 
1192			;        is returned to the caller. The second portion becomes a new free     : 
1192			;        block, and the free list is adjusted to maintain continuity via this : 
1192			;        newly created block.                                                 : 
1192			;                                                                             : 
1192			;     malloc does not set any initial value in the allocated space, the       : 
1192			;     caller is required to do this as required.                              : 
1192			;                                                                             : 
1192			;     This implementation of malloc uses the stack exclusively, and is        : 
1192			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1192			;     advisable to disable interrupts before calling malloc, and recommended  : 
1192			;     to avoid the use of malloc inside ISRs in general.                      : 
1192			;                                                                             : 
1192			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1192			;                                                                             : 
1192			; Parameters                                                                  : 
1192			;     HL  Number of bytes wanted                                              : 
1192			;                                                                             : 
1192			; Returns                                                                     : 
1192			;     HL  Address of the first useable byte of the allocation                 : 
1192			;                                                                             : 
1192			; Flags                                                                       : 
1192			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1192			;                                                                             : 
1192			; Stack frame                                                                 : 
1192			;       |             |                                                       : 
1192			;       +-------------+                                                       : 
1192			;       |     BC      |                                                       : 
1192			;       +-------------+                                                       : 
1192			;       |     DE      |                                                       : 
1192			;       +-------------+                                                       : 
1192			;       |     IX      |                                                       : 
1192			;       +-------------+                                                       : 
1192			;       |  prev_free  |                                                       : 
1192			;   +4  +-------------+                                                       : 
1192			;       |  this_free  |                                                       : 
1192			;   +2  +-------------+                                                       : 
1192			;       |  next_free  |                                                       : 
1192			;   +0  +-------------+                                                       : 
1192			;       |             |                                                       : 
1192			;                                                                             : 
1192			;------------------------------------------------------------------------------ 
1192			 
1192			 
1192			;malloc: 
1192			; 
1192			;	SAVESP ON 1 
1192			; 
1192			;	call malloc_code 
1192			; 
1192			;	CHECKSP ON 1 
1192			;	ret 
1192			 
1192			 
1192			malloc: 
1192 c5			      push  BC 
1193 d5			      push  DE 
1194 dd e5		      push  IX 
1196			if DEBUG_FORTH_MALLOC_HIGH 
1196			call malloc_guard_entry 
1196			endif 
1196			 
1196					if DEBUG_FORTH_MALLOC 
1196						DMARK "mal" 
1196						CALLMONITOR 
1196					endif 
1196 7c			      ld    A, H                    ; Exit if no space requested 
1197 b5			      or    L 
1198 ca 57 12		      jp    Z, malloc_early_exit 
119b			 
119b			;inc hl 
119b			;inc hl 
119b			;inc hl 
119b			; 
119b			;inc hl 
119b			;inc hl 
119b			;inc hl 
119b			;inc hl 
119b			;inc hl 
119b			;inc hl 
119b			;inc hl 
119b			;inc hl 
119b			;inc hl 
119b			 
119b			 
119b			 
119b			 
119b					if DEBUG_FORTH_MALLOC 
119b						DMARK "maA" 
119b						CALLMONITOR 
119b					endif 
119b			      ; Set up stack frame 
119b eb			      ex    DE, HL 
119c 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
119f 39			      add   HL, SP 
11a0 f9			      ld    SP, HL 
11a1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11a5 dd 39		      add   IX, SP 
11a7			 
11a7			      ; Setup initial state 
11a7 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11aa 19			      add   HL, DE 
11ab			 
11ab 44			      ld    B, H                    ; Move want to BC 
11ac 4d			      ld    C, L 
11ad			 
11ad 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11b0 dd 75 04		      ld    (IX+4), L 
11b3 dd 74 05		      ld    (IX+5), H 
11b6			 
11b6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11b7 23			      inc   HL 
11b8 56			      ld    D, (HL) 
11b9 dd 73 02		      ld    (IX+2), E 
11bc dd 72 03		      ld    (IX+3), D 
11bf eb			      ex    DE, HL                  ; this_free ptr into HL 
11c0			 
11c0					if DEBUG_FORTH_MALLOC 
11c0						DMARK "maB" 
11c0						CALLMONITOR 
11c0					endif 
11c0			      ; Loop through free block list to find some space 
11c0			malloc_find_space: 
11c0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11c1 23			      inc   HL 
11c2 56			      ld    D, (HL) 
11c3			 
11c3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11c4 b3			      or    E 
11c5 ca 51 12		      jp    Z, malloc_no_space 
11c8			 
11c8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
11cb dd 72 01		      ld    (IX+1), D 
11ce			 
11ce			      ; Does this block have enough space to make the allocation? 
11ce 23			      inc   HL                      ; Load free block size into DE 
11cf 5e			      ld    E, (HL) 
11d0 23			      inc   HL 
11d1 56			      ld    D, (HL) 
11d2			 
11d2 eb			      ex    DE, HL                  ; Check size of block against want 
11d3 b7			      or    A                       ; Ensure carry flag clear 
11d4 ed 42		      sbc   HL, BC 
11d6 e5			      push  HL                      ; Store the result for later (new block size) 
11d7			 
11d7 ca 26 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
11da 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
11dc			 
11dc			      ; this_free block is not big enough, setup ptrs to test next free block 
11dc e1			      pop   HL                      ; Discard previous result 
11dd			 
11dd dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
11e0 dd 66 03		      ld    H, (IX+3) 
11e3 dd 75 04		      ld    (IX+4), L 
11e6 dd 74 05		      ld    (IX+5), H 
11e9			 
11e9 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
11ec dd 66 01		      ld    H, (IX+1) 
11ef dd 75 02		      ld    (IX+2), L 
11f2 dd 74 03		      ld    (IX+3), H 
11f5			 
11f5					if DEBUG_FORTH_MALLOC 
11f5						DMARK "MA>" 
11f5						CALLMONITOR 
11f5					endif 
11f5 18 c9		      jr    malloc_find_space 
11f7			 
11f7			      ; split a bigger block into two - requested size and remaining size 
11f7			malloc_alloc_split: 
11f7					if DEBUG_FORTH_MALLOC 
11f7						DMARK "MAs" 
11f7						CALLMONITOR 
11f7					endif 
11f7 eb			      ex    DE, HL                  ; Calculate address of new free block 
11f8 2b			      dec   HL 
11f9 2b			      dec   HL 
11fa 2b			      dec   HL 
11fb 09			      add   HL, BC 
11fc			 
11fc			      ; Create a new block and point it at next_free 
11fc dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
11ff dd 56 01		      ld    D, (IX+1) 
1202			 
1202 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1203 23			      inc   HL 
1204 72			      ld    (HL), D 
1205			 
1205 d1			      pop   DE                      ; Store size of new block into new block 
1206 23			      inc   HL 
1207 73			      ld    (HL), E 
1208 23			      inc   HL 
1209 72			      ld    (HL), D 
120a			 
120a			      ; Update this_free ptr to point to new block 
120a 2b			      dec   HL 
120b 2b			      dec   HL 
120c 2b			      dec   HL 
120d			 
120d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1210 dd 56 03		      ld    D, (IX+3) 
1213			 
1213 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1216 dd 74 03		      ld    (IX+3), H 
1219			 
1219			      ; Modify this_free block to be allocation 
1219 eb			      ex    DE, HL 
121a af			      xor   A                       ; Null the next block ptr of allocated block 
121b 77			      ld    (HL), A 
121c 23			      inc   HL 
121d 77			      ld    (HL), A 
121e			 
121e 23			      inc   HL                      ; Store want size into allocated block 
121f 71			      ld    (HL), C 
1220 23			      inc   HL 
1221 70			      ld    (HL), B 
1222 23			      inc   HL 
1223 e5			      push  HL                      ; Address of allocation to return 
1224			 
1224 18 19		      jr    malloc_update_links 
1226			 
1226			malloc_alloc_fit: 
1226 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1227			 
1227					if DEBUG_FORTH_MALLOC 
1227						DMARK "MAf" 
1227						CALLMONITOR 
1227					endif 
1227			      ; Modify this_free block to be allocation 
1227 eb			      ex    DE, HL 
1228 2b			      dec   HL 
1229 2b			      dec   HL 
122a 2b			      dec   HL 
122b			 
122b af			      xor   A                       ; Null the next block ptr of allocated block 
122c 77			      ld    (HL), A 
122d 23			      inc   HL 
122e 77			      ld    (HL), A 
122f			 
122f 23			      inc   HL                      ; Store address of allocation to return 
1230 23			      inc   HL 
1231 23			      inc   HL 
1232 e5			      push  HL 
1233			 
1233			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1233 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1236 dd 66 01		      ld    H, (IX+1) 
1239			 
1239 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
123c dd 74 03		      ld    (IX+3), H 
123f			 
123f			 
123f			malloc_update_links: 
123f			      ; Update prev_free ptr to point to this_free 
123f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1242 dd 66 05		      ld    H, (IX+5) 
1245			 
1245 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1248 dd 56 03		      ld    D, (IX+3) 
124b			 
124b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
124c 23			      inc   HL 
124d 72			      ld    (HL), D 
124e			 
124e					if DEBUG_FORTH_MALLOC 
124e						DMARK "Mul" 
124e						CALLMONITOR 
124e					endif 
124e			      ; Clear the Z flag to indicate successful allocation 
124e 7a			      ld    A, D 
124f b3			      or    E 
1250			 
1250 d1			      pop   DE                      ; Address of allocation 
1251					if DEBUG_FORTH_MALLOC 
1251						DMARK "MAu" 
1251						CALLMONITOR 
1251					endif 
1251			 
1251			malloc_no_space: 
1251 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1254 39			      add   HL, SP 
1255 f9			      ld    SP, HL 
1256			 
1256 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1257					if DEBUG_FORTH_MALLOC 
1257						DMARK "MAN" 
1257						CALLMONITOR 
1257					endif 
1257			 
1257			malloc_early_exit: 
1257					if DEBUG_FORTH_MALLOC 
1257						DMARK "MAx" 
1257						CALLMONITOR 
1257					endif 
1257 dd e1		      pop   IX 
1259 d1			      pop   DE 
125a c1			      pop   BC 
125b			 
125b			if DEBUG_FORTH_MALLOC_HIGH 
125b			call malloc_guard_exit 
125b			call malloc_guard_zerolen 
125b			endif 
125b c9			      ret 
125c			 
125c			 
125c			;------------------------------------------------------------------------------ 
125c			;     free                                                                    : 
125c			;                                                                             : 
125c			; Description                                                                 : 
125c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
125c			;     returned by malloc, otherwise the behaviour is undefined.               : 
125c			;                                                                             : 
125c			;     Where possible, directly adjacent free blocks will be merged together   : 
125c			;     into larger blocks to help ensure that the heap does not become         : 
125c			;     excessively fragmented.                                                 : 
125c			;                                                                             : 
125c			;     free does not clear or set any other value into the freed space, and    : 
125c			;     therefore its contents may be visible through subsequent malloc's. The  : 
125c			;     caller should clear the freed space as required.                        : 
125c			;                                                                             : 
125c			;     This implementation of free uses the stack exclusively, and is          : 
125c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
125c			;     advisable to disable interrupts before calling free, and recommended    : 
125c			;     to avoid the use of free inside ISRs in general.                        : 
125c			;                                                                             : 
125c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
125c			;                                                                             : 
125c			; Parameters                                                                  : 
125c			;     HL  Pointer to address of first byte of allocation to be freed          : 
125c			;                                                                             : 
125c			; Returns                                                                     : 
125c			;     Nothing                                                                 : 
125c			;                                                                             : 
125c			; Stack frame                                                                 : 
125c			;       |             |                                                       : 
125c			;       +-------------+                                                       : 
125c			;       |     BC      |                                                       : 
125c			;       +-------------+                                                       : 
125c			;       |     DE      |                                                       : 
125c			;       +-------------+                                                       : 
125c			;       |     IX      |                                                       : 
125c			;       +-------------+                                                       : 
125c			;       |  prev_free  |                                                       : 
125c			;   +2  +-------------+                                                       : 
125c			;       |  next_free  |                                                       : 
125c			;   +0  +-------------+                                                       : 
125c			;       |             |                                                       : 
125c			;                                                                             : 
125c			;------------------------------------------------------------------------------ 
125c			free: 
125c c5			      push  BC 
125d d5			      push  DE 
125e dd e5		      push  IX 
1260			 
1260 7c			      ld    A, H                    ; Exit if ptr is null 
1261 b5			      or    L 
1262 ca 26 13		      jp    Z, free_early_exit 
1265			 
1265			      ; Set up stack frame 
1265 eb			      ex    DE, HL 
1266 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1269 39			      add   HL, SP 
126a f9			      ld    SP, HL 
126b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
126f dd 39		      add   IX, SP 
1271			 
1271			      ; The address in HL points to the start of the useable allocated space, 
1271			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1271			      ; address of the block itself. 
1271 eb			      ex    DE, HL 
1272 11 fc ff		      ld    DE, -4 
1275 19			      add   HL, DE 
1276			 
1276			      ; An allocated block must have a null next block pointer in it 
1276 7e			      ld    A, (HL) 
1277 23			      inc   HL 
1278 b6			      or    (HL) 
1279 c2 21 13		      jp    NZ, free_done 
127c			 
127c 2b			      dec   HL 
127d			 
127d 44			      ld    B, H                    ; Copy HL to BC 
127e 4d			      ld    C, L 
127f			 
127f			      ; Loop through the free list to find the first block with an address 
127f			      ; higher than the block being freed 
127f 21 0a 80		      ld    HL, free_list 
1282			 
1282			free_find_higher_block: 
1282 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1283 23			      inc   HL 
1284 56			      ld    D, (HL) 
1285 2b			      dec   HL 
1286			 
1286 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1289 dd 72 01		      ld    (IX+1), D 
128c dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
128f dd 74 03		      ld    (IX+3), H 
1292			 
1292 78			      ld    A, B                    ; Check if DE is greater than BC 
1293 ba			      cp    D                       ; Compare MSB first 
1294 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1296 30 04		      jr    NC, free_find_higher_block_skip 
1298 79			      ld    A, C 
1299 bb			      cp    E                       ; Then compare LSB 
129a 38 08		      jr    C, free_found_higher_block 
129c			 
129c			free_find_higher_block_skip: 
129c 7a			      ld    A, D                    ; Reached the end of the free list? 
129d b3			      or    E 
129e ca 21 13		      jp    Z, free_done 
12a1			 
12a1 eb			      ex    DE, HL 
12a2			 
12a2 18 de		      jr    free_find_higher_block 
12a4			 
12a4			free_found_higher_block: 
12a4			      ; Insert freed block between prev and next free blocks 
12a4 71			      ld    (HL), C                 ; Point prev free block to freed block 
12a5 23			      inc   HL 
12a6 70			      ld    (HL), B 
12a7			 
12a7 60			      ld    H, B                    ; Point freed block at next free block 
12a8 69			      ld    L, C 
12a9 73			      ld    (HL), E 
12aa 23			      inc   HL 
12ab 72			      ld    (HL), D 
12ac			 
12ac			      ; Check if the freed block is adjacent to the next free block 
12ac 23			      inc   HL                      ; Load size of freed block into HL 
12ad 5e			      ld    E, (HL) 
12ae 23			      inc   HL 
12af 56			      ld    D, (HL) 
12b0 eb			      ex    DE, HL 
12b1			 
12b1 09			      add   HL, BC                  ; Add addr of freed block and its size 
12b2			 
12b2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12b5 dd 56 01		      ld    D, (IX+1) 
12b8			 
12b8 b7			      or    A                       ; Clear the carry flag 
12b9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12bb 20 22		      jr    NZ, free_check_adjacent_to_prev 
12bd			 
12bd			      ; Freed block is adjacent to next, merge into one bigger block 
12bd eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12be 5e			      ld    E, (HL) 
12bf 23			      inc   HL 
12c0 56			      ld    D, (HL) 
12c1 e5			      push  HL                      ; Save ptr to next block for later 
12c2			 
12c2 60			      ld    H, B                    ; Store ptr from next block into freed block 
12c3 69			      ld    L, C 
12c4 73			      ld    (HL), E 
12c5 23			      inc   HL 
12c6 72			      ld    (HL), D 
12c7			 
12c7 e1			      pop   HL                      ; Restore ptr to next block 
12c8 23			      inc   HL                      ; Load size of next block into DE 
12c9 5e			      ld    E, (HL) 
12ca 23			      inc   HL 
12cb 56			      ld    D, (HL) 
12cc d5			      push  DE                      ; Save next block size for later 
12cd			 
12cd 60			      ld    H, B                    ; Load size of freed block into HL 
12ce 69			      ld    L, C 
12cf 23			      inc   HL 
12d0 23			      inc   HL 
12d1 5e			      ld    E, (HL) 
12d2 23			      inc   HL 
12d3 56			      ld    D, (HL) 
12d4 eb			      ex    DE, HL 
12d5			 
12d5 d1			      pop   DE                      ; Restore size of next block 
12d6 19			      add   HL, DE                  ; Add sizes of both blocks 
12d7 eb			      ex    DE, HL 
12d8			 
12d8 60			      ld    H, B                    ; Store new bigger size into freed block 
12d9 69			      ld    L, C 
12da 23			      inc   HL 
12db 23			      inc   HL 
12dc 73			      ld    (HL), E 
12dd 23			      inc   HL 
12de 72			      ld    (HL), D 
12df			 
12df			free_check_adjacent_to_prev: 
12df			      ; Check if the freed block is adjacent to the prev free block 
12df dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
12e2 dd 66 03		      ld    H, (IX+3) 
12e5			 
12e5 23			      inc   HL                      ; Size of prev free block into DE 
12e6 23			      inc   HL 
12e7 5e			      ld    E, (HL) 
12e8 23			      inc   HL 
12e9 56			      ld    D, (HL) 
12ea 2b			      dec   HL 
12eb 2b			      dec   HL 
12ec 2b			      dec   HL 
12ed			 
12ed 19			      add   HL, DE                  ; Add prev block addr and size 
12ee			 
12ee b7			      or    A                       ; Clear the carry flag 
12ef ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
12f1 20 2e		      jr    NZ, free_done 
12f3			 
12f3			      ; Freed block is adjacent to prev, merge into one bigger block 
12f3 60			      ld    H, B                    ; Load next ptr from freed block into DE 
12f4 69			      ld    L, C 
12f5 5e			      ld    E, (HL) 
12f6 23			      inc   HL 
12f7 56			      ld    D, (HL) 
12f8 e5			      push  HL                      ; Save freed block ptr for later 
12f9			 
12f9 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
12fc dd 66 03		      ld    H, (IX+3) 
12ff 73			      ld    (HL), E 
1300 23			      inc   HL 
1301 72			      ld    (HL), D 
1302			 
1302 e1			      pop   HL                      ; Restore freed block ptr 
1303 23			      inc   HL                      ; Load size of freed block into DE 
1304 5e			      ld    E, (HL) 
1305 23			      inc   HL 
1306 56			      ld    D, (HL) 
1307 d5			      push  DE                      ; Save freed block size for later 
1308			 
1308 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
130b dd 66 03		      ld    H, (IX+3) 
130e 23			      inc   HL 
130f 23			      inc   HL 
1310 5e			      ld    E, (HL) 
1311 23			      inc   HL 
1312 56			      ld    D, (HL) 
1313			 
1313 e1			      pop   HL                      ; Add sizes of both blocks 
1314 19			      add   HL, DE 
1315 eb			      ex    DE, HL 
1316			 
1316 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1319 dd 66 03		      ld    H, (IX+3) 
131c 23			      inc   HL 
131d 23			      inc   HL 
131e 73			      ld    (HL), E 
131f 23			      inc   HL 
1320 72			      ld    (HL), D 
1321			 
1321			free_done: 
1321 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1324 39			      add   HL, SP 
1325 f9			      ld    SP, HL 
1326			 
1326			free_early_exit: 
1326 dd e1		      pop   IX 
1328 d1			      pop   DE 
1329 c1			      pop   BC 
132a			 
132a c9			      ret 
132b			 
132b			; moved to firmware.asm 
132b			; 
132b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
132b			;                  .dw   0 
132b			 
132b			 
132b			endif 
132b			 
132b			 
132b			if MALLOC_3 
132b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
132b			;heap_start        .equ  0x9000      ; Starting address of heap 
132b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
132b			; 
132b			 ;     .org 0 
132b			  ;    jp    main 
132b			; 
132b			; 
132b			 ;     .org  0x100 
132b			;main: 
132b			 ;     ld    HL, 0x8100 
132b			  ;    ld    SP, HL 
132b			; 
132b			;      call  heap_init 
132b			 
132b			      ; Make some allocations 
132b			;      ld    HL, 12 
132b			;      call  malloc            ; Allocates 0x9004 
132b			; 
132b			 ;     ld    HL, 12 
132b			;      call  malloc            ; Allocates 0x9014 
132b			 
132b			;      ld    HL, 12 
132b			;      call  malloc            ; Allocates 0x9024 
132b			 
132b			      ; Free some allocations 
132b			;      ld    HL, 0x9014 
132b			;      call  free 
132b			 
132b			;      ld    HL, 0x9004 
132b			;      call  free 
132b			; 
132b			;      ld    HL, 0x9024 
132b			;      call  free 
132b			 
132b			 
132b			 ;     halt 
132b			 
132b			 
132b			;------------------------------------------------------------------------------ 
132b			;     heap_init                                                               : 
132b			;                                                                             : 
132b			; Description                                                                 : 
132b			;     Initialise the heap and make it ready for malloc and free operations.   : 
132b			;                                                                             : 
132b			;     The heap is maintained as a linked list, starting with an initial       : 
132b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
132b			;     the first free block in the heap. Each block then points to the next    : 
132b			;     free block within the heap, and the free list ends at the first block   : 
132b			;     with a null pointer to the next free block.                             : 
132b			;                                                                             : 
132b			; Parameters                                                                  : 
132b			;     Inputs are compile-time only. Two defines which specify the starting    : 
132b			;     address of the heap and its size are required, along with a memory      : 
132b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
132b			;     principally stores a pointer to the first free block in the heap.       : 
132b			;                                                                             : 
132b			; Returns                                                                     : 
132b			;     Nothing                                                                 : 
132b			;------------------------------------------------------------------------------ 
132b			heap_init: 
132b			      push  HL 
132b			 
132b			      ; Initialise free list struct 
132b			      ld    HL, heap_start 
132b			      ld    (free_list), HL 
132b			      ld    HL, 0 
132b			      ld    (free_list+2), HL 
132b			 
132b			      ; Insert first free block at bottom of heap, consumes entire heap 
132b			      ld    HL, heap_start+heap_size-4 
132b			      ld    (heap_start), HL        ; Next block (end of free list) 
132b			      ld    HL, heap_size-4 
132b			      ld    (heap_start+2), HL      ; Block size 
132b			 
132b			      ; Insert end of free list block at top of heap - two null words will 
132b			      ; terminate the free list 
132b			      ld    HL, 0 
132b			      ld    (heap_start+heap_size-2), HL 
132b			      ld    (heap_start+heap_size-4), HL 
132b			 
132b			      pop   HL 
132b			 
132b			      ret 
132b			 
132b			 
132b			;------------------------------------------------------------------------------ 
132b			;     malloc                                                                  : 
132b			;                                                                             : 
132b			; Description                                                                 : 
132b			;     Allocates the wanted space from the heap and returns the address of the : 
132b			;     first useable byte of the allocation.                                   : 
132b			;                                                                             : 
132b			;     Allocations can happen in one of two ways:                              : 
132b			;                                                                             : 
132b			;     1. A free block may be found which is the exact size wanted. In this    : 
132b			;        case the block is removed from the free list and retuedn to the      : 
132b			;        caller.                                                              : 
132b			;     2. A free block may be found which is larger than the size wanted. In   : 
132b			;        this case, the larger block is split into two. The first portion of  : 
132b			;        this block will become the requested space by the malloc call and    : 
132b			;        is returned to the caller. The second portion becomes a new free     : 
132b			;        block, and the free list is adjusted to maintain continuity via this : 
132b			;        newly created block.                                                 : 
132b			;                                                                             : 
132b			;     malloc does not set any initial value in the allocated space, the       : 
132b			;     caller is required to do this as required.                              : 
132b			;                                                                             : 
132b			;     This implementation of malloc uses the stack exclusively, and is        : 
132b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
132b			;     advisable to disable interrupts before calling malloc, and recommended  : 
132b			;     to avoid the use of malloc inside ISRs in general.                      : 
132b			;                                                                             : 
132b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
132b			;                                                                             : 
132b			; Parameters                                                                  : 
132b			;     HL  Number of bytes wanted                                              : 
132b			;                                                                             : 
132b			; Returns                                                                     : 
132b			;     HL  Address of the first useable byte of the allocation                 : 
132b			;                                                                             : 
132b			; Flags                                                                       : 
132b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
132b			;                                                                             : 
132b			; Stack frame                                                                 : 
132b			;       |             |                                                       : 
132b			;       +-------------+                                                       : 
132b			;       |     BC      |                                                       : 
132b			;       +-------------+                                                       : 
132b			;       |     DE      |                                                       : 
132b			;       +-------------+                                                       : 
132b			;       |     IX      |                                                       : 
132b			;       +-------------+                                                       : 
132b			;       |  prev_free  |                                                       : 
132b			;   +4  +-------------+                                                       : 
132b			;       |  this_free  |                                                       : 
132b			;   +2  +-------------+                                                       : 
132b			;       |  next_free  |                                                       : 
132b			;   +0  +-------------+                                                       : 
132b			;       |             |                                                       : 
132b			;                                                                             : 
132b			;------------------------------------------------------------------------------ 
132b			malloc: 
132b			      push  BC 
132b			      push  DE 
132b			      push  IX 
132b			 
132b			      ld    A, H                    ; Exit if no space requested 
132b			      or    L 
132b			      jp    Z, malloc_early_exit 
132b			 
132b			      ; Set up stack frame 
132b			      ex    DE, HL 
132b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
132b			      add   HL, SP 
132b			      ld    SP, HL 
132b			      ld    IX, 0                   ; Use IX as a frame pointer 
132b			      add   IX, SP 
132b			 
132b			      ; Setup initial state 
132b			      ld    HL, 4                   ; want must also include space used by block struct 
132b			      add   HL, DE 
132b			 
132b			      ld    B, H                    ; Move want to BC 
132b			      ld    C, L 
132b			 
132b			      ld    HL, free_list           ; Store prev_free ptr to stack 
132b			      ld    (IX+4), L 
132b			      ld    (IX+5), H 
132b			 
132b			      ld    E, (HL)                 ; Store this_free ptr to stack 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			      ld    (IX+2), E 
132b			      ld    (IX+3), D 
132b			      ex    DE, HL                  ; this_free ptr into HL 
132b			 
132b			      ; Loop through free block list to find some space 
132b			malloc_find_space: 
132b			      ld    E, (HL)                 ; Load next_free ptr into DE 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			 
132b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
132b			      or    E 
132b			      jp    Z, malloc_no_space 
132b			 
132b			      ld    (IX+0), E               ; Store next_free ptr to stack 
132b			      ld    (IX+1), D 
132b			 
132b			      ; Does this block have enough space to make the allocation? 
132b			      inc   HL                      ; Load free block size into DE 
132b			      ld    E, (HL) 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			 
132b			      ex    DE, HL                  ; Check size of block against want 
132b			      or    A                       ; Ensure carry flag clear 
132b			      sbc   HL, BC 
132b			      push  HL                      ; Store the result for later (new block size) 
132b			 
132b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
132b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
132b			 
132b			      ; this_free block is not big enough, setup ptrs to test next free block 
132b			      pop   HL                      ; Discard previous result 
132b			 
132b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
132b			      ld    H, (IX+3) 
132b			      ld    (IX+4), L 
132b			      ld    (IX+5), H 
132b			 
132b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
132b			      ld    H, (IX+1) 
132b			      ld    (IX+2), L 
132b			      ld    (IX+3), H 
132b			 
132b			      jr    malloc_find_space 
132b			 
132b			      ; split a bigger block into two - requested size and remaining size 
132b			malloc_alloc_split: 
132b			      ex    DE, HL                  ; Calculate address of new free block 
132b			      dec   HL 
132b			      dec   HL 
132b			      dec   HL 
132b			      add   HL, BC 
132b			 
132b			      ; Create a new block and point it at next_free 
132b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
132b			      ld    D, (IX+1) 
132b			 
132b			      ld    (HL), E                 ; Store next_free ptr into new block 
132b			      inc   HL 
132b			      ld    (HL), D 
132b			 
132b			      pop   DE                      ; Store size of new block into new block 
132b			      inc   HL 
132b			      ld    (HL), E 
132b			      inc   HL 
132b			      ld    (HL), D 
132b			 
132b			      ; Update this_free ptr to point to new block 
132b			      dec   HL 
132b			      dec   HL 
132b			      dec   HL 
132b			 
132b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
132b			      ld    D, (IX+3) 
132b			 
132b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
132b			      ld    (IX+3), H 
132b			 
132b			      ; Modify this_free block to be allocation 
132b			      ex    DE, HL 
132b			      xor   A                       ; Null the next block ptr of allocated block 
132b			      ld    (HL), A 
132b			      inc   HL 
132b			      ld    (HL), A 
132b			 
132b			      inc   HL                      ; Store want size into allocated block 
132b			      ld    (HL), C 
132b			      inc   HL 
132b			      ld    (HL), B 
132b			      inc   HL 
132b			      push  HL                      ; Address of allocation to return 
132b			 
132b			      jr    malloc_update_links 
132b			 
132b			malloc_alloc_fit: 
132b			      pop   HL                      ; Dont need new block size, want is exact fit 
132b			 
132b			      ; Modify this_free block to be allocation 
132b			      ex    DE, HL 
132b			      dec   HL 
132b			      dec   HL 
132b			      dec   HL 
132b			 
132b			      xor   A                       ; Null the next block ptr of allocated block 
132b			      ld    (HL), A 
132b			      inc   HL 
132b			      ld    (HL), A 
132b			 
132b			      inc   HL                      ; Store address of allocation to return 
132b			      inc   HL 
132b			      inc   HL 
132b			      push  HL 
132b			 
132b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
132b			      ld    L, (IX+0)               ; next_free to HL 
132b			      ld    H, (IX+1) 
132b			 
132b			      ld    (IX+2), L               ; HL to this_free 
132b			      ld    (IX+3), H 
132b			 
132b			 
132b			malloc_update_links: 
132b			      ; Update prev_free ptr to point to this_free 
132b			      ld    L, (IX+4)               ; prev_free ptr to HL 
132b			      ld    H, (IX+5) 
132b			 
132b			      ld    E, (IX+2)               ; this_free ptr to DE 
132b			      ld    D, (IX+3) 
132b			 
132b			      ld    (HL), E                 ; this_free ptr into prev_free 
132b			      inc   HL 
132b			      ld    (HL), D 
132b			 
132b			      ; Clear the Z flag to indicate successful allocation 
132b			      ld    A, D 
132b			      or    E 
132b			 
132b			      pop   DE                      ; Address of allocation 
132b			 
132b			malloc_no_space: 
132b			      ld    HL, 6                   ; Clean up stack frame 
132b			      add   HL, SP 
132b			      ld    SP, HL 
132b			 
132b			      ex    DE, HL                  ; Alloc addr into HL for return 
132b			 
132b			malloc_early_exit: 
132b			      pop   IX 
132b			      pop   DE 
132b			      pop   BC 
132b			 
132b			      ret 
132b			 
132b			 
132b			;------------------------------------------------------------------------------ 
132b			;     free                                                                    : 
132b			;                                                                             : 
132b			; Description                                                                 : 
132b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
132b			;     returned by malloc, otherwise the behaviour is undefined.               : 
132b			;                                                                             : 
132b			;     Where possible, directly adjacent free blocks will be merged together   : 
132b			;     into larger blocks to help ensure that the heap does not become         : 
132b			;     excessively fragmented.                                                 : 
132b			;                                                                             : 
132b			;     free does not clear or set any other value into the freed space, and    : 
132b			;     therefore its contents may be visible through subsequent malloc's. The  : 
132b			;     caller should clear the freed space as required.                        : 
132b			;                                                                             : 
132b			;     This implementation of free uses the stack exclusively, and is          : 
132b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
132b			;     advisable to disable interrupts before calling free, and recommended    : 
132b			;     to avoid the use of free inside ISRs in general.                        : 
132b			;                                                                             : 
132b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
132b			;                                                                             : 
132b			; Parameters                                                                  : 
132b			;     HL  Pointer to address of first byte of allocation to be freed          : 
132b			;                                                                             : 
132b			; Returns                                                                     : 
132b			;     Nothing                                                                 : 
132b			;                                                                             : 
132b			; Stack frame                                                                 : 
132b			;       |             |                                                       : 
132b			;       +-------------+                                                       : 
132b			;       |     BC      |                                                       : 
132b			;       +-------------+                                                       : 
132b			;       |     DE      |                                                       : 
132b			;       +-------------+                                                       : 
132b			;       |     IX      |                                                       : 
132b			;       +-------------+                                                       : 
132b			;       |  prev_free  |                                                       : 
132b			;   +2  +-------------+                                                       : 
132b			;       |  next_free  |                                                       : 
132b			;   +0  +-------------+                                                       : 
132b			;       |             |                                                       : 
132b			;                                                                             : 
132b			;------------------------------------------------------------------------------ 
132b			free: 
132b			      push  BC 
132b			      push  DE 
132b			      push  IX 
132b			 
132b			      ld    A, H                    ; Exit if ptr is null 
132b			      or    L 
132b			      jp    Z, free_early_exit 
132b			 
132b			      ; Set up stack frame 
132b			      ex    DE, HL 
132b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
132b			      add   HL, SP 
132b			      ld    SP, HL 
132b			      ld    IX, 0                   ; Use IX as a frame pointer 
132b			      add   IX, SP 
132b			 
132b			      ; The address in HL points to the start of the useable allocated space, 
132b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
132b			      ; address of the block itself. 
132b			      ex    DE, HL 
132b			      ld    DE, -4 
132b			      add   HL, DE 
132b			 
132b			      ; An allocated block must have a null next block pointer in it 
132b			      ld    A, (HL) 
132b			      inc   HL 
132b			      or    (HL) 
132b			      jp    NZ, free_done 
132b			 
132b			      dec   HL 
132b			 
132b			      ld    B, H                    ; Copy HL to BC 
132b			      ld    C, L 
132b			 
132b			      ; Loop through the free list to find the first block with an address 
132b			      ; higher than the block being freed 
132b			      ld    HL, free_list 
132b			 
132b			free_find_higher_block: 
132b			      ld    E, (HL)                 ; Load next ptr from free block 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			      dec   HL 
132b			 
132b			      ld    (IX+0), E               ; Save ptr to next free block 
132b			      ld    (IX+1), D 
132b			      ld    (IX+2), L               ; Save ptr to prev free block 
132b			      ld    (IX+3), H 
132b			 
132b			      ld    A, B                    ; Check if DE is greater than BC 
132b			      cp    D                       ; Compare MSB first 
132b			      jr    Z, $+4                  ; MSB the same, compare LSB 
132b			      jr    NC, free_find_higher_block_skip 
132b			      ld    A, C 
132b			      cp    E                       ; Then compare LSB 
132b			      jr    C, free_found_higher_block 
132b			 
132b			free_find_higher_block_skip: 
132b			      ld    A, D                    ; Reached the end of the free list? 
132b			      or    E 
132b			      jp    Z, free_done 
132b			 
132b			      ex    DE, HL 
132b			 
132b			      jr    free_find_higher_block 
132b			 
132b			free_found_higher_block: 
132b			      ; Insert freed block between prev and next free blocks 
132b			      ld    (HL), C                 ; Point prev free block to freed block 
132b			      inc   HL 
132b			      ld    (HL), B 
132b			 
132b			      ld    H, B                    ; Point freed block at next free block 
132b			      ld    L, C 
132b			      ld    (HL), E 
132b			      inc   HL 
132b			      ld    (HL), D 
132b			 
132b			      ; Check if the freed block is adjacent to the next free block 
132b			      inc   HL                      ; Load size of freed block into HL 
132b			      ld    E, (HL) 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			      ex    DE, HL 
132b			 
132b			      add   HL, BC                  ; Add addr of freed block and its size 
132b			 
132b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
132b			      ld    D, (IX+1) 
132b			 
132b			      or    A                       ; Clear the carry flag 
132b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
132b			      jr    NZ, free_check_adjacent_to_prev 
132b			 
132b			      ; Freed block is adjacent to next, merge into one bigger block 
132b			      ex    DE, HL                  ; Load next ptr from next block into DE 
132b			      ld    E, (HL) 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			      push  HL                      ; Save ptr to next block for later 
132b			 
132b			      ld    H, B                    ; Store ptr from next block into freed block 
132b			      ld    L, C 
132b			      ld    (HL), E 
132b			      inc   HL 
132b			      ld    (HL), D 
132b			 
132b			      pop   HL                      ; Restore ptr to next block 
132b			      inc   HL                      ; Load size of next block into DE 
132b			      ld    E, (HL) 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			      push  DE                      ; Save next block size for later 
132b			 
132b			      ld    H, B                    ; Load size of freed block into HL 
132b			      ld    L, C 
132b			      inc   HL 
132b			      inc   HL 
132b			      ld    E, (HL) 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			      ex    DE, HL 
132b			 
132b			      pop   DE                      ; Restore size of next block 
132b			      add   HL, DE                  ; Add sizes of both blocks 
132b			      ex    DE, HL 
132b			 
132b			      ld    H, B                    ; Store new bigger size into freed block 
132b			      ld    L, C 
132b			      inc   HL 
132b			      inc   HL 
132b			      ld    (HL), E 
132b			      inc   HL 
132b			      ld    (HL), D 
132b			 
132b			free_check_adjacent_to_prev: 
132b			      ; Check if the freed block is adjacent to the prev free block 
132b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
132b			      ld    H, (IX+3) 
132b			 
132b			      inc   HL                      ; Size of prev free block into DE 
132b			      inc   HL 
132b			      ld    E, (HL) 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			      dec   HL 
132b			      dec   HL 
132b			      dec   HL 
132b			 
132b			      add   HL, DE                  ; Add prev block addr and size 
132b			 
132b			      or    A                       ; Clear the carry flag 
132b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132b			      jr    NZ, free_done 
132b			 
132b			      ; Freed block is adjacent to prev, merge into one bigger block 
132b			      ld    H, B                    ; Load next ptr from freed block into DE 
132b			      ld    L, C 
132b			      ld    E, (HL) 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			      push  HL                      ; Save freed block ptr for later 
132b			 
132b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
132b			      ld    H, (IX+3) 
132b			      ld    (HL), E 
132b			      inc   HL 
132b			      ld    (HL), D 
132b			 
132b			      pop   HL                      ; Restore freed block ptr 
132b			      inc   HL                      ; Load size of freed block into DE 
132b			      ld    E, (HL) 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			      push  DE                      ; Save freed block size for later 
132b			 
132b			      ld    L, (IX+2)               ; Load size of prev block into DE 
132b			      ld    H, (IX+3) 
132b			      inc   HL 
132b			      inc   HL 
132b			      ld    E, (HL) 
132b			      inc   HL 
132b			      ld    D, (HL) 
132b			 
132b			      pop   HL                      ; Add sizes of both blocks 
132b			      add   HL, DE 
132b			      ex    DE, HL 
132b			 
132b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
132b			      ld    H, (IX+3) 
132b			      inc   HL 
132b			      inc   HL 
132b			      ld    (HL), E 
132b			      inc   HL 
132b			      ld    (HL), D 
132b			 
132b			free_done: 
132b			      ld    HL, 4                   ; Clean up stack frame 
132b			      add   HL, SP 
132b			      ld    SP, HL 
132b			 
132b			free_early_exit: 
132b			      pop   IX 
132b			      pop   DE 
132b			      pop   BC 
132b			 
132b			      ret 
132b			 
132b			 
132b			;      .org 0x8000 
132b			; 
132b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
132b			 ;                 .dw   0 
132b			 
132b			endif 
132b			 
132b			 
132b			if MALLOC_4 
132b			 
132b			; My memory allocation code. Very very simple.... 
132b			; allocate space under 250 chars 
132b			 
132b			heap_init: 
132b				; init start of heap as zero 
132b				;  
132b			 
132b				ld hl, heap_start 
132b				ld a, 0 
132b				ld (hl), a      ; empty block 
132b				inc hl 
132b				ld a, 0 
132b				ld (hl), a      ; length of block 
132b				; write end of list 
132b				inc hl 
132b				ld a,(hl) 
132b				inc hl 
132b				ld a,(hl) 
132b				 
132b			 
132b				; init some malloc vars 
132b			 
132b				ld hl, 0 
132b				ld (free_list), hl       ; store last malloc location 
132b			 
132b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
132b				ld a, 0 
132b				ld (hl), a 
132b			 
132b			 
132b				ld hl, heap_start 
132b				;  
132b				  
132b				ret 
132b			 
132b			 
132b			;    free block marker 
132b			;    requested size  
132b			;    pointer to next block 
132b			;    .... 
132b			;    next block marker 
132b			 
132b			 
132b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
132b			; 
132b			 
132b			 
132b			malloc:  
132b				push de 
132b				push bc 
132b				push af 
132b			 
132b				; hl space required 
132b				 
132b				ld c, l    ; hold space   (TODO only a max of 255) 
132b			 
132b			;	inc c     ; TODO BUG need to fix memory leak on push str 
132b			;	inc c 
132b			;	inc c 
132b			;	inc c 
132b			;	inc c 
132b			;	inc c 
132b			;	inc c 
132b			 
132b			 
132b			 
132b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
132b			 
132b				ld a, (free_list+3) 
132b				cp 0 
132b				jr z, .contheap 
132b			 
132b				ld hl, (free_list)     ; get last alloc 
132b					if DEBUG_FORTH_MALLOC_INT 
132b						DMARK "mrs" 
132b						CALLMONITOR 
132b					endif 
132b				jr .startalloc 
132b			 
132b			.contheap: 
132b				ld hl, heap_start 
132b			 
132b			.startalloc: 
132b			 
132b					if DEBUG_FORTH_MALLOC_INT 
132b						DMARK "mym" 
132b						CALLMONITOR 
132b					endif 
132b			.findblock: 
132b					if DEBUG_FORTH_MALLOC_INT 
132b						DMARK "mmf" 
132b						CALLMONITOR 
132b					endif 
132b			 
132b				ld a,(hl)  
132b				; if byte is zero then clear to use 
132b			 
132b				cp 0 
132b				jr z, .foundemptyblock 
132b			 
132b				; if byte is not clear 
132b				;     then byte is offset to next block 
132b			 
132b				inc hl 
132b				ld a, (hl) ; get size 
132b			.nextblock:	inc hl 
132b					ld e, (hl) 
132b					inc hl 
132b					ld d, (hl) 
132b					ex de, hl 
132b			;	inc hl  ; move past the store space 
132b			;	inc hl  ; move past zero index  
132b			 
132b				; TODO detect no more space 
132b			 
132b				push hl 
132b				ld de, heap_end 
132b				call cmp16 
132b				pop hl 
132b				jr nc, .nospace 
132b			 
132b				jr .findblock 
132b			 
132b			.nospace: ld hl, 0 
132b				jp .exit 
132b			 
132b			 
132b			.foundemptyblock:	 
132b					if DEBUG_FORTH_MALLOC_INT 
132b						DMARK "mme" 
132b						CALLMONITOR 
132b					endif 
132b			 
132b			; TODO has block enough space if reusing??? 
132b			 
132b				;  
132b			 
132b			; see if this block has been previously used 
132b				inc hl 
132b				ld a, (hl) 
132b				dec hl 
132b				cp 0 
132b				jr z, .newblock 
132b			 
132b					if DEBUG_FORTH_MALLOC_INT 
132b						DMARK "meR" 
132b						CALLMONITOR 
132b					endif 
132b			 
132b			; no reusing previously allocated block 
132b			 
132b			; is it smaller than previously used? 
132b				 
132b				inc hl    ; move to size 
132b				ld a, c 
132b				sub (hl)        ; we want c < (hl) 
132b				dec hl    ; move back to marker 
132b			        jr z, .findblock 
132b			 
132b				; update with the new size which should be lower 
132b			 
132b			        ;inc  hl   ; negate next move. move back to size  
132b			 
132b			.newblock: 
132b				; need to be at marker here 
132b			 
132b					if DEBUG_FORTH_MALLOC_INT 
132b						DMARK "meN" 
132b						CALLMONITOR 
132b					endif 
132b			 
132b			 
132b				ld a, c 
132b			 
132b				ld (free_list+3), a	 ; flag resume from last malloc  
132b				ld (free_list), hl    ; save out last location 
132b			 
132b			 
132b				;inc a     ; space for length byte 
132b				ld (hl), a     ; save block in use marker 
132b			 
132b				inc hl   ; move to space marker 
132b				ld (hl), a    ; save new space 
132b			 
132b				inc hl   ; move to start of allocated area 
132b				 
132b			;	push hl     ; save where we are - 1  
132b			 
132b			;	inc hl  ; move past zero index  
132b				; skip space to set down new marker 
132b			 
132b				; provide some extra space for now 
132b			 
132b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
132b				inc a 
132b				inc a 
132b			 
132b				push hl   ; save where we are in the node block 
132b			 
132b				call addatohl 
132b			 
132b				; write linked list point 
132b			 
132b				pop de     ; get our node position 
132b				ex de, hl 
132b			 
132b				ld (hl), e 
132b				inc hl 
132b				ld (hl), d 
132b			 
132b				inc hl 
132b			 
132b				; now at start of allocated data so save pointer 
132b			 
132b				push hl 
132b			 
132b				; jump to position of next node and setup empty header in DE 
132b			 
132b				ex de, hl 
132b			 
132b			;	inc hl ; move past end of block 
132b			 
132b				ld a, 0 
132b				ld (hl), a   ; empty marker 
132b				inc hl 
132b				ld (hl), a   ; size 
132b				inc hl  
132b				ld (hl), a   ; ptr 
132b				inc hl 
132b				ld (hl), a   ; ptr 
132b			 
132b			 
132b				pop hl 
132b			 
132b					if DEBUG_FORTH_MALLOC_INT 
132b						DMARK "mmr" 
132b						CALLMONITOR 
132b					endif 
132b			 
132b			.exit: 
132b				pop af 
132b				pop bc 
132b				pop de  
132b				ret 
132b			 
132b			 
132b			 
132b			 
132b			free:  
132b				push hl 
132b				push af 
132b				; get address in hl 
132b			 
132b					if DEBUG_FORTH_MALLOC_INT 
132b						DMARK "fre" 
132b						CALLMONITOR 
132b					endif 
132b				; data is at hl - move to block count 
132b				dec hl 
132b				dec hl    ; get past pointer 
132b				dec hl 
132b			 
132b				ld a, (hl)    ; need this for a validation check 
132b			 
132b				dec hl    ; move to block marker 
132b			 
132b				; now check that the block count and block marker are the same  
132b			        ; this checks that we are on a malloc node and not random memory 
132b			        ; OK a faint chance this could be a problem but rare - famous last words! 
132b			 
132b				ld c, a 
132b				ld a, (hl)    
132b			 
132b				cp c 
132b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
132b			 
132b				; yes good chance we are on a malloc node 
132b			 
132b				ld a, 0      
132b				ld (hl), a   ; mark as free 
132b			 
132b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
132b			 
132b			.freeignore:  
132b			 
132b				pop af 
132b				pop hl 
132b			 
132b				ret 
132b			 
132b			 
132b			 
132b			endif 
132b			 
132b			; eof 
# End of file firmware_memory.asm
132b			  
132b			; device C  
132b			if SOUND_ENABLE  
132b				include "firmware_sound.asm"  
132b			; Sound abstraction layer 
132b			 
132b			; support different sound chips through common interface 
132b			 
132b			SOUND_DEVICE_AY: equ 0 
132b			 
132b			SOUND_DEVICE: equ Device_A 
132b			 
132b			 
132b			 
132b			if SOUND_DEVICE_AY 
132b				include "firmware_sound_ay38910.asm" 
132b			else 
132b				include "firmware_sound_sn76489an.asm" 
132b			 
132b			; Device support for SN76489AN sound chip 
132b			 
132b			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
132b			; http://danceswithferrets.org/geekblog/?p=93 
132b			; https://www.smspower.org/Development/SN76489 
132b			 
132b			; D0 [ 3] 
132b			; D1 [ 2] 
132b			; D2 [ 1] 
132b			; D3 [15] 
132b			; D4 [13] 
132b			; D5 [12] 
132b			; D6 [11] 
132b			; D7 [10] 
132b			; /WE [ 5] 
132b			; CLK [14] 
132b			; /OE [ 6] 
132b			; AUDIO [ 7] 
132b			; GND 8 
132b			; +5 16 
132b			; 
132b			 
132b			; Write sequence: 
132b			; CE low 
132b			; Data bus 
132b			; WE low then high 
132b			; 32 clock cycles / 8ns write time at 4mhz 
132b			; 
132b			; https://github.com/jblang/SN76489 
132b			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
132b			; Tried: 
132b			; 
132b			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
132b			; 
132b			; Connected WE to OR too 
132b			;  
132b			; That enabled the clock when required 
132b			; However still random bus corruption. Need further investigation 
132b			 
132b			 
132b			SOUND_LATCH: equ 10000000B 
132b			SOUND_DATA: equ 0B 
132b			SOUND_CH0:  equ 0B    ; Tone 
132b			SOUND_CH1: equ 0100000B        ; Tone 
132b			SOUND_CH2: equ 1000000B   ; Tone 
132b			SOUND_CH3: equ 1100000B    ; Noise 
132b			SOUND_VOL: equ 10000B 
132b			SOUND_TONE: equ 0B 
132b			 
132b			 
132b			sound_init: 
132b 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
132d cd 42 13			call note_send_byte 
1330 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1332 cd 42 13			call note_send_byte 
1335 cd 39 0a			call delay250ms 
1338 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
133a cd 42 13			call note_send_byte 
133d cd 39 0a			call delay250ms 
1340 c9				ret 
1341			 
1341			; Play a note 
1341			; h = note 
1341			; l = duration 
1341			; a = channel 
1341			 
1341			 
1341			;  frequ = clock / ( 2 x reg valu x 32 )  
1341			 
1341			note:  
1341				 
1341			 
1341 c9				ret 
1342			 
1342			note_send_byte: 
1342				; byte in a 
1342			 
1342				; we high 
1342 d3 40			out (Device_B), a 
1344			;	ld a, 1 
1344			;	call aDelayInMS 
1344 00				nop  
1345 00				nop  
1346 00				nop  
1347 00				nop  
1348				; we low 
1348 d3 40			out (Device_B), a 
134a			;	ld a, 1 
134a			;	call aDelayInMS 
134a 00				nop  
134b 00				nop  
134c 00				nop  
134d 00				nop  
134e				; we high 
134e d3 40			out (Device_B), a 
1350			;	ld a, 1 
1350			;	call aDelayInMS 
1350 00				nop  
1351 00				nop  
1352 00				nop  
1353 00				nop  
1354			 
1354			 
1354 c9				ret 
1355			 
1355			;void SilenceAllChannels() 
1355			;{ 
1355			;  SendByte(0x9f); 
1355			;  SendByte(0xbf); 
1355			;  SendByte(0xdf); 
1355			;  SendByte(0xff); 
1355			;} 
1355			 
1355			 
1355			; eof 
1355			 
# End of file firmware_sound_sn76489an.asm
1355			endif 
1355			 
1355			 
1355			; Abstraction entry points 
1355			 
1355			; init  
1355			 
1355			; sound_init in specific hardware files 
1355			 
1355			; Play a note 
1355			; h = note 
1355			; l = duration 
1355			; a = channel 
1355			 
1355			;note:     
1355			;	ret 
1355			 
1355			 
1355			 
1355			 
1355			; eof 
1355			 
# End of file firmware_sound.asm
1355			endif  
1355			  
1355			include "firmware_diags.asm"  
1355			; Hardware diags menu 
1355			 
1355			 
1355			config: 
1355			 
1355 3e 00			ld a, 0 
1357 21 76 13			ld hl, .configmn 
135a cd c8 0a			call menu 
135d			 
135d fe 00			cp 0 
135f c8				ret z 
1360			 
1360 fe 01			cp 1 
1362 cc fe 13			call z, .savetostore 
1365			 
1365 fe 03			cp 3 
1367 cc fc 13			call z, .selbank 
136a fe 05			cp 5 
136c cc d9 14			call z, .debug_tog 
136f fe 06			cp 6 
1371 cc ff 14			call z, hardware_diags 
1374			 
1374 18 df			jr config 
1376			 
1376			.configmn: 
1376 84 13			dw .c3 
1378 a0 13			dw .c2 
137a b5 13			dw .c2b 
137c c9 13			dw .c4 
137e d2 13			dw .m4 
1380 ed 13			dw .c1 
1382 00 00			dw 0 
1384				 
1384			 
1384 .. 00		.c3: db "Add User Dictionary To File",0 
13a0 .. 00		.c2: db "Select Autoload File",0 
13b5 .. 00		.c2b: db "Select Storage Bank",0 
13c9 .. 00		.c4: db "Settings",0 
13d2 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
13ed .. 00		.c1: db "Hardware Diags",0 
13fc			 
13fc			; Select storage bank 
13fc			 
13fc			.selbank: 
13fc			 
13fc				if STORAGE_SE 
13fc				endif 
13fc				 
13fc c9				ret 
13fd			 
13fd			if STORAGE_SE 
13fd			 
13fd			.config_ldir:   
13fd				; Load storage bank labels into menu array 
13fd			 
13fd				 
13fd			 
13fd			 
13fd c9				ret 
13fe			 
13fe			 
13fe			endif 
13fe			 
13fe			 
13fe			; Save user words to storage 
13fe			 
13fe			.savetostore: 
13fe			 
13fe				if STORAGE_SE 
13fe			 
13fe cd 23 14				call config_dir 
1401 21 31 ee			        ld hl, scratch 
1404 3e 00				ld a, 0 
1406 cd c8 0a				call menu 
1409					 
1409 21 31 ee				ld hl, scratch 
140c cd 10 14				call config_fdir 
140f			 
140f			 
140f				endif 
140f			 
140f c9				ret 
1410			 
1410			 
1410			 
1410			if STORAGE_SE 
1410			 
1410			config_fdir: 
1410				; using the scratch dir go through and release the memory allocated for each string 
1410				 
1410 21 31 ee			ld hl, scratch 
1413 5e			.cfdir:	ld e,(hl) 
1414 23				inc hl 
1415 56				ld d,(hl) 
1416 23				inc hl 
1417			 
1417 eb				ex de, hl 
1418 cd f4 0c			call ishlzero 
141b c8				ret z     ; return on null pointer 
141c cd 5c 12			call free 
141f eb				ex de, hl 
1420 18 f1			jr .cfdir 
1422			 
1422			 
1422 c9				ret 
1423			 
1423			 
1423			config_dir: 
1423			 
1423				; for the config menus that need to build a directory of storage call this routine 
1423				; it will construct a menu in scratch to pass to menu 
1423			 
1423				; open storage device 
1423			 
1423				; execute DIR to build a list of files and their ids into scratch in menu format 
1423				; once the menu has finished then will need to call config_fdir to release the strings 
1423				 
1423				; c = number items 
1423			 
1423				 
1423 cd bd 03			call storage_get_block_0 
1426			 
1426 21 62 f8			ld hl, store_page     ; get current id count 
1429 46				ld b, (hl) 
142a 0e 00			ld c, 0    ; count of files   
142c			 
142c			 
142c 21 31 ee			ld hl, scratch 
142f 22 5e f8			ld (store_tmp2), hl    ; location to poke strings 
1432			 
1432				; check for empty drive 
1432			 
1432 3e 00			ld a, 0 
1434 b8				cp b 
1435 ca cf 14			jp z, .dirdone 
1438			 
1438				 
1438					if DEBUG_FORTH_WORDS 
1438						DMARK "Cdc" 
1438 f5				push af  
1439 3a 4d 14			ld a, (.dmark)  
143c 32 77 fb			ld (debug_mark),a  
143f 3a 4e 14			ld a, (.dmark+1)  
1442 32 78 fb			ld (debug_mark+1),a  
1445 3a 4f 14			ld a, (.dmark+2)  
1448 32 79 fb			ld (debug_mark+2),a  
144b 18 03			jr .pastdmark  
144d ..			.dmark: db "Cdc"  
1450 f1			.pastdmark: pop af  
1451			endm  
# End of macro DMARK
1451						CALLMONITOR 
1451 cd 17 16			call break_point_state  
1454				endm  
# End of macro CALLMONITOR
1454					endif 
1454			 
1454			 
1454			.diritem:	 
1454 c5				push bc 
1455				; for each of the current ids do a search for them and if found push to stack 
1455			 
1455 21 40 00				ld hl, STORE_BLOCK_PHY 
1458 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
145a 58					ld e,b 
145b			 
145b cd 2a 06				call storage_findnextid 
145e			 
145e			 
145e					; if found hl will be non zero 
145e			 
145e cd f4 0c				call ishlzero 
1461 28 69				jr z, .dirnotfound 
1463			 
1463					; increase count 
1463			 
1463 c1					pop bc	 
1464 0c					inc c 
1465 c5					push bc 
1466					 
1466			 
1466					; get file header and push the file name 
1466			 
1466 11 62 f8				ld de, store_page 
1469 cd 0c 03				call storage_read_block 
146c			 
146c					; push file id to stack 
146c				 
146c 3a 62 f8				ld a, (store_page) 
146f 26 00				ld h, 0 
1471 6f					ld l, a 
1472			 
1472					;call forth_push_numhl 
1472					; TODO store id 
1472			 
1472 e5					push hl 
1473			 
1473					; push extent count to stack  
1473				 
1473 21 65 f8				ld hl, store_page+3 
1476			 
1476					; get file name length 
1476			 
1476 cd 29 11				call strlenz   
1479			 
1479 23					inc hl   ; cover zero term 
147a 23					inc hl  ; stick the id at the end of the area 
147b			 
147b e5					push hl 
147c c1					pop bc    ; move length to bc 
147d			 
147d cd 92 11				call malloc 
1480			 
1480					; TODO save malloc area to scratch 
1480			 
1480 eb					ex de, hl 
1481 2a 5e f8				ld hl, (store_tmp2) 
1484 73					ld (hl), e 
1485 23					inc hl 
1486 72					ld (hl), d 
1487 23					inc hl 
1488 22 5e f8				ld (store_tmp2), hl 
148b			 
148b					 
148b			 
148b					;pop hl   ; get source 
148b			;		ex de, hl    ; swap aronund	 
148b			 
148b 21 65 f8				ld hl, store_page+3 
148e					if DEBUG_FORTH_WORDS 
148e						DMARK "CFd" 
148e f5				push af  
148f 3a a3 14			ld a, (.dmark)  
1492 32 77 fb			ld (debug_mark),a  
1495 3a a4 14			ld a, (.dmark+1)  
1498 32 78 fb			ld (debug_mark+1),a  
149b 3a a5 14			ld a, (.dmark+2)  
149e 32 79 fb			ld (debug_mark+2),a  
14a1 18 03			jr .pastdmark  
14a3 ..			.dmark: db "CFd"  
14a6 f1			.pastdmark: pop af  
14a7			endm  
# End of macro DMARK
14a7						CALLMONITOR 
14a7 cd 17 16			call break_point_state  
14aa				endm  
# End of macro CALLMONITOR
14aa					endif 
14aa ed b0				ldir 
14ac			 
14ac					; de is past string, move back one and store id 
14ac					 
14ac 1b					dec de 
14ad			 
14ad					; store file id 
14ad			 
14ad e1					pop hl 
14ae eb					ex de,hl 
14af 73					ld (hl), e 
14b0			 
14b0					if DEBUG_FORTH_WORDS 
14b0						DMARK "Cdi" 
14b0 f5				push af  
14b1 3a c5 14			ld a, (.dmark)  
14b4 32 77 fb			ld (debug_mark),a  
14b7 3a c6 14			ld a, (.dmark+1)  
14ba 32 78 fb			ld (debug_mark+1),a  
14bd 3a c7 14			ld a, (.dmark+2)  
14c0 32 79 fb			ld (debug_mark+2),a  
14c3 18 03			jr .pastdmark  
14c5 ..			.dmark: db "Cdi"  
14c8 f1			.pastdmark: pop af  
14c9			endm  
# End of macro DMARK
14c9						CALLMONITOR 
14c9 cd 17 16			call break_point_state  
14cc				endm  
# End of macro CALLMONITOR
14cc					endif 
14cc					 
14cc			.dirnotfound: 
14cc c1					pop bc     
14cd 10 85				djnz .diritem 
14cf				 
14cf			.dirdone:	 
14cf			 
14cf 3e 00				ld a, 0 
14d1 2a 5e f8				ld hl, (store_tmp2) 
14d4 77					ld (hl), a 
14d5 23					inc hl 
14d6 77					ld (hl), a 
14d7 23					inc hl 
14d8					; push a count of the dir items found 
14d8			 
14d8			;		ld h, 0 
14d8			;		ld l, c 
14d8			 
14d8 c9				ret 
14d9			 
14d9			endif 
14d9			 
14d9			 
14d9			; Settings 
14d9			; Run  
14d9			 
14d9			 
14d9			 
14d9			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14d9			;;hd_menu2:   db "        2: Editor",0   
14d9			;hd_menu2:   db "        2: Editor       6: Menu",0   
14d9			;hd_menu3:   db "        3: Storage",0 
14d9			;hd_menu4:   db "0=quit  4: Debug",0 
14d9			;hd_don:     db "ON",0 
14d9			;hd_doff:     db "OFF",0 
14d9			; 
14d9			; 
14d9			; 
14d9			;hardware_diags_old:       
14d9			; 
14d9			;.diagmenu: 
14d9			;	call clear_display 
14d9			;	ld a, display_row_1 
14d9			;	ld de, hd_menu1 
14d9			;	call str_at_display 
14d9			; 
14d9			;	ld a, display_row_2 
14d9			;	ld de, hd_menu2 
14d9			;	call str_at_display 
14d9			; 
14d9			;	ld a, display_row_3 
14d9			;	ld de, hd_menu3 
14d9			;	call str_at_display 
14d9			; 
14d9			;	ld a,  display_row_4 
14d9			;	ld de, hd_menu4 
14d9			;	call str_at_display 
14d9			; 
14d9			;	; display debug state 
14d9			; 
14d9			;	ld de, hd_don 
14d9			;	ld a, (os_view_disable) 
14d9			;	cp 0 
14d9			;	jr z, .distog 
14d9			;	ld de, hd_doff 
14d9			;.distog: ld a, display_row_4+17 
14d9			;	call str_at_display 
14d9			; 
14d9			;	call update_display 
14d9			; 
14d9			;	call cin_wait 
14d9			; 
14d9			; 
14d9			; 
14d9			;	cp '4' 
14d9			;	jr nz, .diagn1 
14d9			; 
14d9			;	; debug toggle 
14d9			; 
14d9			;	ld a, (os_view_disable) 
14d9			;	ld b, '*' 
14d9			;	cp 0 
14d9			;	jr z, .debtog 
14d9			;	ld b, 0 
14d9			;.debtog:	 
14d9			;	ld a,b 
14d9			;	ld (os_view_disable),a 
14d9			; 
14d9			;.diagn1: cp '0' 
14d9			;	 ret z 
14d9			; 
14d9			;;	cp '1' 
14d9			;;       jp z, matrix	 
14d9			;;   TODO keyboard matrix test 
14d9			; 
14d9			;	cp '2' 
14d9			;	jp z, .diagedit 
14d9			; 
14d9			;;	cp '6' 
14d9			;;	jp z, .menutest 
14d9			;;if ENABLE_BASIC 
14d9			;;	cp '6' 
14d9			;;	jp z, basic 
14d9			;;endif 
14d9			 ; 
14d9			;	jp .diagmenu 
14d9			; 
14d9			; 
14d9			;	ret 
14d9			 
14d9			 
14d9			.debug_tog: 
14d9 21 20 15			ld hl, .menudebug 
14dc				 
14dc 3a 30 ee			ld a, (os_view_disable) 
14df fe 2a			cp '*' 
14e1 20 04			jr nz,.tdon  
14e3 3e 01			ld a, 1 
14e5 18 02			jr .tog1 
14e7 3e 00		.tdon: ld a, 0 
14e9			 
14e9			.tog1: 
14e9 cd c8 0a			call menu 
14ec fe 00			cp 0 
14ee c8				ret z 
14ef fe 01			cp 1    ; disable debug 
14f1 28 04			jr z, .dtog0 
14f3 3e 2a			ld a, '*' 
14f5 18 02			jr .dtogset 
14f7 3e 00		.dtog0: ld a, 0 
14f9 32 30 ee		.dtogset:  ld (os_view_disable), a 
14fc c3 d9 14			jp .debug_tog 
14ff			 
14ff			 
14ff			hardware_diags:       
14ff			 
14ff			.diagm: 
14ff 21 12 15			ld hl, .menuitems 
1502 3e 00			ld a, 0 
1504 cd c8 0a			call menu 
1507			 
1507 fe 00		         cp 0 
1509 c8				 ret z 
150a			 
150a fe 02			cp 2 
150c ca 6b 15			jp z, .diagedit 
150f			 
150f			;	cp '6' 
150f			;	jp z, .menutest 
150f			;if ENABLE_BASIC 
150f			;	cp '6' 
150f			;	jp z, basic 
150f			;endif 
150f			  
150f c3 ff 14			jp .diagm 
1512			 
1512				 
1512 26 15		.menuitems:   	dw .m1 
1514 31 15				dw .m2 
1516 38 15				dw .m3 
1518 40 15				dw .m5 
151a 46 15				dw .m5a 
151c 4f 15				dw .m5b 
151e 00 00				dw 0 
1520			 
1520			.menudebug: 
1520 58 15				dw .m6 
1522 61 15				dw .m7 
1524 00 00				dw 0 
1526			 
1526 .. 00		.m1:   db "Key Matrix",0 
1531 .. 00		.m2:   db "Editor",0 
1538 .. 00		.m3:   db "Storage",0 
1540 .. 00		.m5:   db "Sound",0 
1546 .. 00		.m5a:  db "RAM Test",0 
154f .. 00		.m5b:  db "LCD Test",0 
1558			 
1558 .. 00		.m6:   db "Debug ON",0 
1561 .. 00		.m7:   db "Debug OFF",0 
156b			 
156b			; debug editor 
156b			 
156b			.diagedit: 
156b			 
156b 21 31 ee			ld hl, scratch 
156e			;	ld bc, 250 
156e			;	ldir 
156e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
156e 3e 00			ld a, 0 
1570 77				ld (hl), a 
1571 23				inc hl 
1572 77				ld (hl), a 
1573 23				inc hl 
1574 77				ld (hl), a 
1575			 
1575 cd 97 0a		        call clear_display 
1578 cd ba 0a			call update_display 
157b 3e 01			ld a, 1 
157d 32 7d fb			ld (hardware_diag), a 
1580			.diloop: 
1580 3e 00			ld a, display_row_1 
1582 0e 00			ld c, 0 
1584 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1586 1e 28			ld e, 40 
1588			 
1588 21 31 ee			ld hl, scratch	 
158b cd f8 0c			call input_str 
158e			 
158e 3e 28			ld a, display_row_2 
1590 11 31 ee			ld de, scratch 
1593 cd aa 0a			call str_at_display 
1596 cd ba 0a			call update_display 
1599			 
1599 c3 80 15			jp .diloop 
159c			 
159c			 
159c			; pass word in hl 
159c			; a has display location 
159c			display_word_at: 
159c f5				push af 
159d e5				push hl 
159e 7c				ld a,h 
159f 21 36 f1			ld hl, os_word_scratch 
15a2 cd cc 0f			call hexout 
15a5 e1				pop hl 
15a6 7d				ld a,l 
15a7 21 38 f1			ld hl, os_word_scratch+2 
15aa cd cc 0f			call hexout 
15ad 21 3a f1			ld hl, os_word_scratch+4 
15b0 3e 00			ld a,0 
15b2 77				ld (hl),a 
15b3 11 36 f1			ld de,os_word_scratch 
15b6 f1				pop af 
15b7 cd aa 0a				call str_at_display 
15ba c9				ret 
15bb			 
15bb			display_ptr_state: 
15bb			 
15bb				; to restore afterwards 
15bb			 
15bb d5				push de 
15bc c5				push bc 
15bd e5				push hl 
15be f5				push af 
15bf			 
15bf				; for use in here 
15bf			 
15bf			;	push bc 
15bf			;	push de 
15bf			;	push hl 
15bf			;	push af 
15bf			 
15bf cd 97 0a			call clear_display 
15c2			 
15c2 11 95 17			ld de, .ptrstate 
15c5 3e 00			ld a, display_row_1 
15c7 cd aa 0a			call str_at_display 
15ca			 
15ca				; display debug step 
15ca			 
15ca			 
15ca 11 77 fb			ld de, debug_mark 
15cd 3e 26			ld a, display_row_1+display_cols-2 
15cf cd aa 0a			call str_at_display 
15d2			 
15d2				; display a 
15d2 11 9f 17			ld de, .ptrcliptr 
15d5 3e 28			ld a, display_row_2 
15d7 cd aa 0a			call str_at_display 
15da			 
15da f1				pop af 
15db 2a 3c f8			ld hl,(cli_ptr) 
15de 3e 30			ld a, display_row_2+8 
15e0 cd 9c 15			call display_word_at 
15e3			 
15e3			 
15e3				; display hl 
15e3			 
15e3			 
15e3 11 a7 17			ld de, .ptrclioptr 
15e6 3e 32			ld a, display_row_2+10 
15e8 cd aa 0a			call str_at_display 
15eb			; 
15eb			;	pop hl 
15eb 3e 35			ld a, display_row_2+13 
15ed 2a 3a f8			ld hl,(cli_origptr) 
15f0 cd 9c 15			call display_word_at 
15f3			; 
15f3			;	 
15f3			;	; display de 
15f3			 
15f3			;	ld de, .regstatede 
15f3			;	ld a, display_row_3 
15f3			;	call str_at_display 
15f3			 
15f3			;	pop de 
15f3			;	ld h,d 
15f3			;	ld l, e 
15f3			;	ld a, display_row_3+3 
15f3			;	call display_word_at 
15f3			 
15f3			 
15f3				; display bc 
15f3			 
15f3			;	ld de, .regstatebc 
15f3			;	ld a, display_row_3+10 
15f3			;	call str_at_display 
15f3			 
15f3			;	pop bc 
15f3			;	ld h,b 
15f3			;	ld l, c 
15f3			;	ld a, display_row_3+13 
15f3			;	call display_word_at 
15f3			 
15f3			 
15f3				; display dsp 
15f3			 
15f3			;	ld de, .regstatedsp 
15f3			;	ld a, display_row_4 
15f3			;	call str_at_display 
15f3			 
15f3				 
15f3			;	ld hl,(cli_data_sp) 
15f3			;	ld a, display_row_4+4 
15f3			;	call display_word_at 
15f3			 
15f3				; display rsp 
15f3			 
15f3 11 d6 17			ld de, .regstatersp 
15f6 3e 82			ld a, display_row_4+10 
15f8 cd aa 0a			call str_at_display 
15fb			 
15fb				 
15fb 2a 22 f8			ld hl,(cli_ret_sp) 
15fe 3e 86			ld a, display_row_4+14 
1600 cd 9c 15			call display_word_at 
1603			 
1603 cd ba 0a			call update_display 
1606			 
1606 cd 45 0a			call delay1s 
1609 cd 45 0a			call delay1s 
160c cd 45 0a			call delay1s 
160f			 
160f			 
160f cd 1c 1b			call next_page_prompt 
1612			 
1612				; restore  
1612			 
1612 f1				pop af 
1613 e1				pop hl 
1614 c1				pop bc 
1615 d1				pop de 
1616 c9				ret 
1617			 
1617			break_point_state: 
1617 f5				push af 
1618			 
1618				; see if disabled 
1618			 
1618 3a 30 ee			ld a, (os_view_disable) 
161b fe 2a			cp '*' 
161d 20 02			jr nz, .bpsgo 
161f f1				pop af 
1620 c9				ret 
1621			 
1621			.bpsgo: 
1621 f1				pop af 
1622 f5				push af 
1623 22 2c ee			ld (os_view_hl), hl 
1626 ed 53 2a ee		ld (os_view_de), de 
162a ed 43 28 ee		ld (os_view_bc), bc 
162e e5				push hl 
162f 6f				ld l, a 
1630 26 00			ld h, 0 
1632 22 2e ee			ld (os_view_af),hl 
1635			 
1635 21 bd fa				ld hl, display_fb0 
1638 22 d8 f8				ld (display_fb_active), hl 
163b e1				pop hl	 
163c			 
163c 3e 31			ld a, '1' 
163e fe 2a		.bps1:  cp '*' 
1640 20 03			jr nz, .bps1b 
1642 32 30 ee			ld (os_view_disable),a 
1645 fe 31		.bps1b:  cp '1' 
1647 20 14			jr nz, .bps2 
1649			 
1649				; display reg 
1649			 
1649				 
1649			 
1649 3a 2e ee			ld a, (os_view_af) 
164c 2a 2c ee			ld hl, (os_view_hl) 
164f ed 5b 2a ee		ld de, (os_view_de) 
1653 ed 4b 28 ee		ld bc, (os_view_bc) 
1657 cd f1 16			call display_reg_state 
165a c3 dd 16			jp .bpschk 
165d			 
165d fe 32		.bps2:  cp '2' 
165f 20 08			jr nz, .bps3 
1661				 
1661				; display hl 
1661 2a 2c ee			ld hl, (os_view_hl) 
1664 cd db 17			call display_dump_at_hl 
1667			 
1667 18 74			jr .bpschk 
1669			 
1669 fe 33		.bps3:  cp '3' 
166b 20 08			jr nz, .bps4 
166d			 
166d			        ; display de 
166d 2a 2a ee			ld hl, (os_view_de) 
1670 cd db 17			call display_dump_at_hl 
1673			 
1673 18 68			jr .bpschk 
1675 fe 34		.bps4:  cp '4' 
1677 20 08			jr nz, .bps5 
1679			 
1679			        ; display bc 
1679 2a 28 ee			ld hl, (os_view_bc) 
167c cd db 17			call display_dump_at_hl 
167f			 
167f 18 5c			jr .bpschk 
1681 fe 35		.bps5:  cp '5' 
1683 20 08		        jr nz, .bps7 
1685			 
1685				; display cur ptr 
1685 2a 3c f8			ld hl, (cli_ptr) 
1688 cd db 17			call display_dump_at_hl 
168b			 
168b 18 50			jr .bpschk 
168d fe 36		.bps7:  cp '6' 
168f 20 08			jr nz, .bps8b 
1691				 
1691				; display cur orig ptr 
1691 2a 3a f8			ld hl, (cli_origptr) 
1694 cd db 17			call display_dump_at_hl 
1697 18 44			jr .bpschk 
1699 fe 37		.bps8b:  cp '7' 
169b 20 08			jr nz, .bps9 
169d				 
169d				; display dsp 
169d 2a 1e f8			ld hl, (cli_data_sp) 
16a0 cd db 17			call display_dump_at_hl 
16a3			 
16a3 18 38			jr .bpschk 
16a5 fe 39		.bps9:  cp '9' 
16a7 20 05			jr nz, .bps8c 
16a9				 
16a9				; display SP 
16a9			;	ld hl, sp 
16a9 cd db 17			call display_dump_at_hl 
16ac			 
16ac 18 2f			jr .bpschk 
16ae fe 38		.bps8c:  cp '8' 
16b0 20 08			jr nz, .bps8d 
16b2				 
16b2				; display rsp 
16b2 2a 22 f8			ld hl, (cli_ret_sp) 
16b5 cd db 17			call display_dump_at_hl 
16b8			 
16b8 18 23			jr .bpschk 
16ba fe 23		.bps8d:  cp '#'     ; access monitor sub system 
16bc 20 05			jr nz, .bps8 
16be cd 12 19			call monitor 
16c1			 
16c1 18 1a			jr .bpschk 
16c3 fe 30		.bps8:  cp '0' 
16c5 20 16			jr nz, .bpschk 
16c7			 
16c7 21 1c fa				ld hl, display_fb1 
16ca 22 d8 f8				ld (display_fb_active), hl 
16cd cd ba 0a				call update_display 
16d0			 
16d0				;ld a, (os_view_af) 
16d0 2a 2c ee			ld hl, (os_view_hl) 
16d3 ed 5b 2a ee		ld de, (os_view_de) 
16d7 ed 4b 28 ee		ld bc, (os_view_bc) 
16db f1				pop af 
16dc c9				ret 
16dd			 
16dd			.bpschk:   
16dd cd 45 0a			call delay1s 
16e0 3e 9f		ld a,display_row_4 + display_cols - 1 
16e2 11 1a 1b		        ld de, endprg 
16e5 cd aa 0a			call str_at_display 
16e8 cd ba 0a			call update_display 
16eb cd c1 67			call cin_wait 
16ee			 
16ee c3 3e 16			jp .bps1 
16f1			 
16f1			 
16f1			display_reg_state: 
16f1			 
16f1				; to restore afterwards 
16f1			 
16f1 d5				push de 
16f2 c5				push bc 
16f3 e5				push hl 
16f4 f5				push af 
16f5			 
16f5				; for use in here 
16f5			 
16f5 c5				push bc 
16f6 d5				push de 
16f7 e5				push hl 
16f8 f5				push af 
16f9			 
16f9 cd 97 0a			call clear_display 
16fc			 
16fc 11 b1 17			ld de, .regstate 
16ff 3e 00			ld a, display_row_1 
1701 cd aa 0a			call str_at_display 
1704			 
1704				; display debug step 
1704			 
1704			 
1704 11 77 fb			ld de, debug_mark 
1707 3e 25			ld a, display_row_1+display_cols-3 
1709 cd aa 0a			call str_at_display 
170c			 
170c				; display a 
170c 11 cd 17			ld de, .regstatea 
170f 3e 28			ld a, display_row_2 
1711 cd aa 0a			call str_at_display 
1714			 
1714 e1				pop hl 
1715			;	ld h,0 
1715			;	ld l, a 
1715 3e 2b			ld a, display_row_2+3 
1717 cd 9c 15			call display_word_at 
171a			 
171a			 
171a				; display hl 
171a			 
171a			 
171a 11 c1 17			ld de, .regstatehl 
171d 3e 32			ld a, display_row_2+10 
171f cd aa 0a			call str_at_display 
1722			 
1722 e1				pop hl 
1723 3e 35			ld a, display_row_2+13 
1725 cd 9c 15			call display_word_at 
1728			 
1728				 
1728				; display de 
1728			 
1728 11 c5 17			ld de, .regstatede 
172b 3e 50			ld a, display_row_3 
172d cd aa 0a			call str_at_display 
1730			 
1730 e1				pop hl 
1731			;	ld h,d 
1731			;	ld l, e 
1731 3e 53			ld a, display_row_3+3 
1733 cd 9c 15			call display_word_at 
1736			 
1736			 
1736				; display bc 
1736			 
1736 11 c9 17			ld de, .regstatebc 
1739 3e 5a			ld a, display_row_3+10 
173b cd aa 0a			call str_at_display 
173e			 
173e e1				pop hl 
173f			;	ld h,b 
173f			;	ld l, c 
173f 3e 5d			ld a, display_row_3+13 
1741 cd 9c 15			call display_word_at 
1744			 
1744			 
1744				; display dsp 
1744			 
1744 11 d1 17			ld de, .regstatedsp 
1747 3e 78			ld a, display_row_4 
1749 cd aa 0a			call str_at_display 
174c			 
174c				 
174c 2a 1e f8			ld hl,(cli_data_sp) 
174f 3e 7c			ld a, display_row_4+4 
1751 cd 9c 15			call display_word_at 
1754			 
1754				; display rsp 
1754			 
1754 11 d6 17			ld de, .regstatersp 
1757 3e 82			ld a, display_row_4+10 
1759 cd aa 0a			call str_at_display 
175c			 
175c				 
175c 2a 22 f8			ld hl,(cli_ret_sp) 
175f 3e 86			ld a, display_row_4+14 
1761 cd 9c 15			call display_word_at 
1764			 
1764 cd ba 0a			call update_display 
1767			 
1767			;	call delay1s 
1767			;	call delay1s 
1767			;	call delay1s 
1767			 
1767			 
1767			;	call next_page_prompt 
1767			 
1767				; restore  
1767			 
1767 f1				pop af 
1768 e1				pop hl 
1769 c1				pop bc 
176a d1				pop de 
176b c9				ret 
176c			 
176c .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1780 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1795 .. 00		.ptrstate:	db "Ptr State",0 
179f .. 00		.ptrcliptr:     db "cli_ptr",0 
17a7 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
17b1 .. 00		.regstate:	db "Reg State (1/0)",0 
17c1 .. 00		.regstatehl:	db "HL:",0 
17c5 .. 00		.regstatede:	db "DE:",0 
17c9 .. 00		.regstatebc:	db "BC:",0 
17cd .. 00		.regstatea:	db "A :",0 
17d1 .. 00		.regstatedsp:	db "DSP:",0 
17d6 .. 00		.regstatersp:	db "RSP:",0 
17db			 
17db			display_dump_at_hl: 
17db e5				push hl 
17dc d5				push de 
17dd c5				push bc 
17de f5				push af 
17df			 
17df 22 54 f1			ld (os_cur_ptr),hl	 
17e2 cd 97 0a			call clear_display 
17e5 cd 24 1a			call dumpcont 
17e8			;	call delay1s 
17e8			;	call next_page_prompt 
17e8			 
17e8			 
17e8 f1				pop af 
17e9 c1				pop bc 
17ea d1				pop de 
17eb e1				pop hl 
17ec c9				ret 
17ed			 
17ed			;if ENABLE_BASIC 
17ed			;	include "nascombasic.asm" 
17ed			;	basic: 
17ed			;	include "forth/FORTH.ASM" 
17ed			;endif 
17ed			 
17ed			; eof 
17ed			 
17ed			 
# End of file firmware_diags.asm
17ed			  
17ed			  
17ed			  
17ed			  
17ed			; eof  
17ed			  
# End of file firmware.asm
17ed			 
17ed			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
17ed			;if BASE_KEV  
17ed			;baseram: equ 08000h 
17ed			;endif 
17ed			 
17ed			;if BASE_SC114 
17ed			;baseram:     equ    endofcode 
17ed			;endif 
17ed			 
17ed			 
17ed			; start system 
17ed			 
17ed			coldstart: 
17ed				; set sp 
17ed				; di/ei 
17ed			 
17ed f3				di 
17ee 31 fd ff			ld sp, tos 
17f1			;	ei 
17f1			 
17f1			 
17f1				; disable breakpoint by default 
17f1			 
17f1 3e 2a			ld a,'*' 
17f3 32 30 ee			ld (os_view_disable),a 
17f6			 
17f6				; init hardware 
17f6			 
17f6				; init keyboard and screen hardware 
17f6			 
17f6 cd 03 00			call hardware_init 
17f9			 
17f9			 
17f9				; detect if any keys are held down to enable breakpoints at start up 
17f9			 
17f9 cd d2 67			call cin  
17fc fe 00			cp 0 
17fe 28 03			jr z, .nokeys 
1800			 
1800				;call hardware_diags 
1800 cd 55 13			call config 
1803			 
1803			;	ld de, .bpen 
1803			;	ld a, display_row_4 
1803			;	call str_at_display 
1803			;	call update_display 
1803			; 
1803			;	ld a,0 
1803			;	ld (os_view_disable),a 
1803			; 
1803			;.bpwait: 
1803			;	call cin 
1803			;	cp 0 
1803			;	jr z, .bpwait 
1803			;	jr .nokeys 
1803			; 
1803			; 
1803			;.bpen:  db "Break points enabled!",0 
1803			 
1803			 
1803			 
1803			 
1803			 
1803			 
1803			.nokeys: 
1803			 
1803			 
1803				 
1803			 
1803			;jp  testkey 
1803			 
1803			;call storage_get_block_0 
1803			; 
1803			;ld hl, 0 
1803			;ld de, store_page 
1803			;call storage_read_block 
1803			 
1803				 
1803			;ld hl, 10 
1803			;ld de, store_page 
1803			;call storage_read_block 
1803			 
1803			 
1803			 
1803			 
1803			 
1803			;stop:	nop 
1803			;	jp stop 
1803			 
1803			 
1803			 
1803			main: 
1803 cd 97 0a			call clear_display 
1806 cd ba 0a			call update_display 
1809			 
1809			 
1809			 
1809			;	call testlcd 
1809			 
1809			 
1809			 
1809 cd e2 1e			call forth_init 
180c			 
180c			 
180c			warmstart: 
180c cd b8 1e			call forth_warmstart 
180f			 
180f				; run startup word load 
180f			        ; TODO prevent this running at warmstart after crash  
180f			 
180f				if STARTUP_ENABLE 
180f cd 98 61				call forth_startup 
1812				endif 
1812			 
1812				; show free memory after boot 
1812 11 ac 18			ld de, freeram 
1815 3e 00			ld a, display_row_1 
1817 cd aa 0a			call str_at_display 
181a			 
181a			; Or use heap_size word???? 
181a 21 25 ee			ld hl, heap_end 
181d 11 0e 80			ld de, heap_start 
1820 ed 52			sbc hl, de 
1822 e5				push hl 
1823 7c				ld a,h	         	 
1824 21 36 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1827 cd cc 0f			call hexout 
182a e1			   	pop hl 
182b			 
182b 7d				ld a,l 
182c 21 38 f1			ld hl, os_word_scratch+2 
182f cd cc 0f			call hexout 
1832 21 3a f1			ld hl, os_word_scratch+4 
1835 3e 00			ld a, 0 
1837 77				ld (hl),a 
1838 11 36 f1			ld de, os_word_scratch 
183b 3e 0d			ld a, display_row_1 + 13 
183d cd aa 0a			call str_at_display 
1840 cd ba 0a			call update_display 
1843			 
1843			 
1843				;call demo 
1843			 
1843			 
1843				; init scratch input area for cli commands 
1843			 
1843 21 58 f1			ld hl, os_cli_cmd 
1846 3e 00			ld a,0 
1848 77				ld (hl),a 
1849 23				inc hl 
184a 77				ld (hl),a 
184b			 
184b 3e 00			ld a,0 
184d 32 57 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1850			 
1850 32 54 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1853 32 55 f1			ld (os_cur_ptr+1),a	 
1856			 
1856 32 36 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1859 32 37 f1			ld (os_word_scratch+1),a	 
185c				 
185c			 
185c				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
185c 21 58 f1			ld hl, os_cli_cmd 
185f			 
185f 3e 00			ld a, 0		 ; init cli input 
1861 77				ld (hl), a 
1862 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1864			cli: 
1864				; show cli prompt 
1864				;push af 
1864				;ld a, 0 
1864				;ld de, prompt 
1864				;call str_at_display 
1864			 
1864				;call update_display 
1864				;pop af 
1864				;inc a 
1864				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1864 0e 00			ld c, 0 
1866 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1868 1e 28			ld e, 40 
186a			 
186a 21 58 f1			ld hl, os_cli_cmd 
186d			 
186d				STACKFRAME OFF $fefe $9f9f 
186d				if DEBUG_STACK_IMB 
186d					if OFF 
186d						exx 
186d						ld de, $fefe 
186d						ld a, d 
186d						ld hl, curframe 
186d						call hexout 
186d						ld a, e 
186d						ld hl, curframe+2 
186d						call hexout 
186d						ld hl, $fefe 
186d						push hl 
186d						ld hl, $9f9f 
186d						push hl 
186d						exx 
186d					endif 
186d				endif 
186d			endm 
# End of macro STACKFRAME
186d			 
186d cd f8 0c			call input_str 
1870			 
1870				STACKFRAMECHK OFF $fefe $9f9f 
1870				if DEBUG_STACK_IMB 
1870					if OFF 
1870						exx 
1870						ld hl, $9f9f 
1870						pop de   ; $9f9f 
1870						call cmp16 
1870						jr nz, .spnosame 
1870						ld hl, $fefe 
1870						pop de   ; $fefe 
1870						call cmp16 
1870						jr z, .spfrsame 
1870						.spnosame: call showsperror 
1870						.spfrsame: nop 
1870						exx 
1870					endif 
1870				endif 
1870			endm 
# End of macro STACKFRAMECHK
1870			 
1870				; copy input to last command 
1870			 
1870 21 58 f1			ld hl, os_cli_cmd 
1873 11 57 f2			ld de, os_last_cmd 
1876 01 ff 00			ld bc, 255 
1879 ed b0			ldir 
187b			 
187b				; wipe current buffer 
187b			 
187b			;	ld a, 0 
187b			;	ld hl, os_cli_cmd 
187b			;	ld de, os_cli_cmd+1 
187b			;	ld bc, 254 
187b			;	ldir 
187b				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
187b			;	call strcpy 
187b			;	ld a, 0 
187b			;	ld (hl), a 
187b			;	inc hl 
187b			;	ld (hl), a 
187b			;	inc hl 
187b			;	ld (hl), a 
187b			 
187b				; switch frame buffer to program  
187b			 
187b 21 1c fa				ld hl, display_fb1 
187e 22 d8 f8				ld (display_fb_active), hl 
1881			 
1881			;	nop 
1881				STACKFRAME ON $fbfe $8f9f 
1881				if DEBUG_STACK_IMB 
1881					if ON 
1881						exx 
1881						ld de, $fbfe 
1881						ld a, d 
1881						ld hl, curframe 
1881						call hexout 
1881						ld a, e 
1881						ld hl, curframe+2 
1881						call hexout 
1881						ld hl, $fbfe 
1881						push hl 
1881						ld hl, $8f9f 
1881						push hl 
1881						exx 
1881					endif 
1881				endif 
1881			endm 
# End of macro STACKFRAME
1881				; first time into the parser so pass over the current scratch pad 
1881 21 58 f1			ld hl,os_cli_cmd 
1884				; tokenise the entered statement(s) in HL 
1884 cd 5b 1f			call forthparse 
1887			        ; exec forth statements in top of return stack 
1887 cd 9b 1f			call forthexec 
188a				;call forthexec_cleanup 
188a			;	call parsenext 
188a			 
188a				STACKFRAMECHK ON $fbfe $8f9f 
188a				if DEBUG_STACK_IMB 
188a					if ON 
188a						exx 
188a						ld hl, $8f9f 
188a						pop de   ; $8f9f 
188a						call cmp16 
188a						jr nz, .spnosame 
188a						ld hl, $fbfe 
188a						pop de   ; $fbfe 
188a						call cmp16 
188a						jr z, .spfrsame 
188a						.spnosame: call showsperror 
188a						.spfrsame: nop 
188a						exx 
188a					endif 
188a				endif 
188a			endm 
# End of macro STACKFRAMECHK
188a				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
188a			 
188a 3e 78			ld a, display_row_4 
188c 11 be 18			ld de, endprog 
188f			 
188f cd ba 0a			call update_display		 
1892			 
1892 cd 1c 1b			call next_page_prompt 
1895			 
1895				; switch frame buffer to cli 
1895			 
1895 21 bd fa				ld hl, display_fb0 
1898 22 d8 f8				ld (display_fb_active), hl 
189b			 
189b			 
189b cd 97 0a		        call clear_display 
189e cd ba 0a			call update_display		 
18a1			 
18a1 21 58 f1			ld hl, os_cli_cmd 
18a4			 
18a4 3e 00			ld a, 0		 ; init cli input 
18a6 77				ld (hl), a 
18a7			 
18a7				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
18a7			 
18a7				; now on last line 
18a7			 
18a7				; TODO scroll screen up 
18a7			 
18a7				; TODO instead just clear screen and place at top of screen 
18a7			 
18a7			;	ld a, 0 
18a7			;	ld (f_cursor_ptr),a 
18a7			 
18a7				;call clear_display 
18a7				;call update_display 
18a7			 
18a7				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18a7 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18a9 c3 64 18			jp cli 
18ac			 
18ac .. 00		freeram: db "Free bytes: $",0 
18ba ..			asc: db "1A2F" 
18be .. 00		endprog: db "End prog...",0 
18ca			 
18ca			testenter2:   
18ca 21 63 ee			ld hl,scratch+50 
18cd 22 54 f1			ld (os_cur_ptr),hl 
18d0 c3 64 18			jp cli 
18d3			 
18d3			testenter:  
18d3			 
18d3 21 ba 18			ld hl,asc 
18d6			;	ld a,(hl) 
18d6			;	call nibble2val 
18d6 cd 22 10			call get_byte 
18d9			 
18d9			 
18d9			;	ld a,(hl) 
18d9			;	call atohex 
18d9			 
18d9			;	call fourehexhl 
18d9 32 63 ee			ld (scratch+50),a 
18dc			 
18dc			 
18dc			 
18dc 21 bc 18			ld hl,asc+2 
18df			;	ld a, (hl) 
18df			;	call nibble2val 
18df cd 22 10			call get_byte 
18e2			 
18e2			;	call fourehexhl 
18e2 32 65 ee			ld (scratch+52),a 
18e5				 
18e5 21 63 ee			ld hl,scratch+50 
18e8 22 54 f1			ld (os_cur_ptr),hl 
18eb c3 64 18			jp cli 
18ee			 
18ee			enter:	 
18ee 3a 35 ee			ld a,(scratch+4) 
18f1 fe 00			cp 0 
18f3 28 0c			jr z, .entercont 
18f5				; no, not a null term line so has an address to work out.... 
18f5			 
18f5 21 33 ee			ld hl,scratch+2 
18f8 cd 82 10			call get_word_hl 
18fb			 
18fb 22 54 f1			ld (os_cur_ptr),hl	 
18fe c3 64 18			jp cli 
1901			 
1901			 
1901			.entercont:  
1901			 
1901 21 33 ee			ld hl, scratch+2 
1904 cd 22 10			call get_byte 
1907			 
1907 2a 54 f1		   	ld hl,(os_cur_ptr) 
190a 77					ld (hl),a 
190b 23					inc hl 
190c 22 54 f1				ld (os_cur_ptr),hl 
190f				 
190f			; get byte  
190f			 
190f			 
190f c3 64 18			jp cli 
1912			 
1912			 
1912			; basic monitor support 
1912			 
1912			monitor: 
1912				;  
1912 cd 97 0a			call clear_display 
1915 3e 00			ld a, 0 
1917 11 5f 19			ld de, .monprompt 
191a cd aa 0a			call str_at_display 
191d cd ba 0a			call update_display 
1920			 
1920				; get a monitor command 
1920			 
1920 0e 00			ld c, 0     ; entry at top left 
1922 16 64			ld d, 100   ; max buffer size 
1924 1e 0f			ld e, 15    ; input scroll area 
1926 3e 00			ld a, 0     ; init string 
1928 21 2f f0			ld hl, os_input 
192b 77				ld (hl), a 
192c 23				inc hl 
192d 77				ld (hl), a 
192e 21 2f f0			ld hl, os_input 
1931 3e 01			ld a, 1     ; init string 
1933 cd f8 0c			call input_str 
1936			 
1936 cd 97 0a		        call clear_display 
1939 cd ba 0a			call update_display		 
193c			 
193c 3a 2f f0			ld a, (os_input) 
193f cd 20 11			call toUpper 
1942 fe 48		        cp 'H' 
1944 28 6f		        jr z, .monhelp 
1946 fe 44			cp 'D'		; dump 
1948 ca d6 19			jp z, .mondump	 
194b fe 43			cp 'C'		; dump 
194d ca f0 19			jp z, .moncdump	 
1950 fe 4d			cp 'M'		; dump 
1952 ca 61 19			jp z, .moneditstart 
1955 fe 55			cp 'U'		; dump 
1957 28 14			jr z, .monedit	 
1959 fe 51			cp 'Q'		; dump 
195b c8				ret z	 
195c			 
195c			 
195c				; TODO "S" to access symbol by name and not need the address 
195c				; TODO "F" to find a string in memory 
195c			 
195c c3 12 19			jp monitor 
195f			 
195f .. 00		.monprompt: db ">", 0 
1961			 
1961			.moneditstart: 
1961				; get starting address 
1961			 
1961 21 31 f0			ld hl,os_input+2 
1964 cd 82 10			call get_word_hl 
1967			 
1967 22 54 f1			ld (os_cur_ptr),hl	 
196a			 
196a c3 12 19			jp monitor 
196d			 
196d			.monedit: 
196d				; get byte to load 
196d			 
196d 21 31 f0			ld hl,os_input+2 
1970 cd 22 10			call get_byte 
1973			 
1973				; get address to update 
1973 2a 54 f1			ld hl, (os_cur_ptr) 
1976			 
1976				; update byte 
1976			 
1976 77				ld (hl), a 
1977			 
1977				; move to next address and save it 
1977			 
1977 23				inc hl 
1978 22 54 f1			ld (os_cur_ptr),hl	 
197b			 
197b c3 12 19			jp monitor 
197e			 
197e			 
197e .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1992 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
19ae .. 00		.monhelptext3:  db "Q-Quit",0 
19b5			        
19b5			.monhelp: 
19b5 3e 00			ld a, display_row_1 
19b7 11 7e 19		        ld de, .monhelptext1 
19ba			 
19ba cd aa 0a			call str_at_display 
19bd 3e 28			ld a, display_row_2 
19bf 11 92 19		        ld de, .monhelptext2 
19c2					 
19c2 cd aa 0a			call str_at_display 
19c5 3e 50			ld a, display_row_3 
19c7 11 ae 19		        ld de, .monhelptext3 
19ca					 
19ca cd aa 0a			call str_at_display 
19cd cd ba 0a			call update_display		 
19d0			 
19d0 cd 1c 1b			call next_page_prompt 
19d3 c3 12 19			jp monitor 
19d6			 
19d6			.mondump:    
19d6 21 31 f0			ld hl,os_input+2 
19d9 cd 82 10			call get_word_hl 
19dc			 
19dc 22 54 f1			ld (os_cur_ptr),hl	 
19df cd 24 1a			call dumpcont 
19e2 3e 78			ld a, display_row_4 
19e4 11 be 18			ld de, endprog 
19e7			 
19e7 cd ba 0a			call update_display		 
19ea			 
19ea cd 1c 1b			call next_page_prompt 
19ed c3 12 19			jp monitor 
19f0			.moncdump: 
19f0 cd 24 1a			call dumpcont 
19f3 3e 78			ld a, display_row_4 
19f5 11 be 18			ld de, endprog 
19f8			 
19f8 cd ba 0a			call update_display		 
19fb			 
19fb cd 1c 1b			call next_page_prompt 
19fe c3 12 19			jp monitor 
1a01			 
1a01			 
1a01			; TODO symbol access  
1a01			 
1a01			.symbols:     ;; A list of symbols that can be called up  
1a01 bd fa			dw display_fb0 
1a03 .. 00			db "fb0",0  
1a07 62 f8		     	dw store_page 
1a09 .. 00			db "store_page",0 
1a14			 
1a14			 
1a14			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a14			 
1a14 3a 32 ee			ld a,(scratch+1) 
1a17 fe 00			cp 0 
1a19 28 09			jr z, dumpcont 
1a1b			 
1a1b				; no, not a null term line so has an address to work out.... 
1a1b			 
1a1b 21 33 ee			ld hl,scratch+2 
1a1e cd 82 10			call get_word_hl 
1a21			 
1a21 22 54 f1			ld (os_cur_ptr),hl	 
1a24			 
1a24			 
1a24			 
1a24			dumpcont: 
1a24			 
1a24				; dump bytes at ptr 
1a24			 
1a24			 
1a24 3e 00			ld a, display_row_1 
1a26 2a d8 f8			ld hl, (display_fb_active) 
1a29 cd cb 0c			call addatohl 
1a2c cd 54 1a			call .dumpbyterow 
1a2f			 
1a2f 3e 28			ld a, display_row_2 
1a31 2a d8 f8			ld hl, (display_fb_active) 
1a34 cd cb 0c			call addatohl 
1a37 cd 54 1a			call .dumpbyterow 
1a3a			 
1a3a			 
1a3a 3e 50			ld a, display_row_3 
1a3c 2a d8 f8			ld hl, (display_fb_active) 
1a3f cd cb 0c			call addatohl 
1a42 cd 54 1a			call .dumpbyterow 
1a45			 
1a45 3e 78			ld a, display_row_4 
1a47 2a d8 f8			ld hl, (display_fb_active) 
1a4a cd cb 0c			call addatohl 
1a4d cd 54 1a			call .dumpbyterow 
1a50			 
1a50 cd ba 0a			call update_display 
1a53			;		jp cli 
1a53 c9				ret 
1a54			 
1a54			.dumpbyterow: 
1a54			 
1a54				;push af 
1a54			 
1a54 e5				push hl 
1a55			 
1a55				; calc where to poke the ascii 
1a55			if display_cols == 20 
1a55				ld a, 16 
1a55			else 
1a55 3e 1f			ld a, 31 
1a57			endif 
1a57			 
1a57 cd cb 0c			call addatohl 
1a5a 22 36 f1			ld (os_word_scratch),hl  		; save pos for later 
1a5d			 
1a5d			 
1a5d			; display decoding address 
1a5d 2a 54 f1		   	ld hl,(os_cur_ptr) 
1a60			 
1a60 7c				ld a,h 
1a61 e1				pop hl 
1a62 e5				push hl 
1a63			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a63 cd cc 0f			call hexout 
1a66 2a 54 f1		   	ld hl,(os_cur_ptr) 
1a69			 
1a69 7d				ld a,l 
1a6a e1				pop hl 
1a6b 23				inc hl 
1a6c 23				inc hl 
1a6d e5				push hl 
1a6e			;	ld hl, os_word_scratch+2 
1a6e cd cc 0f			call hexout 
1a71 e1				pop hl 
1a72 23				inc hl 
1a73 23				inc hl 
1a74				;ld hl, os_word_scratch+4 
1a74 3e 3a			ld a, ':' 
1a76 77				ld (hl),a 
1a77 23				inc hl 
1a78				;ld a, 0 
1a78				;ld (hl),a 
1a78				;ld de, os_word_scratch 
1a78				;pop af 
1a78				;push af 
1a78			;		ld a, display_row_2 
1a78			;		call str_at_display 
1a78			;		call update_display 
1a78			 
1a78			 
1a78			;pop af 
1a78			;	add 5 
1a78			 
1a78			if display_cols == 20 
1a78				ld b, 4 
1a78			else 
1a78 06 08			ld b, 8 
1a7a			endif	 
1a7a			 
1a7a			.dumpbyte: 
1a7a c5				push bc 
1a7b e5				push hl 
1a7c			 
1a7c			 
1a7c 2a 54 f1		   	ld hl,(os_cur_ptr) 
1a7f 7e					ld a,(hl) 
1a80			 
1a80					; poke the ascii to display 
1a80 2a 36 f1				ld hl,(os_word_scratch) 
1a83 77					ld (hl),a 
1a84 23					inc hl 
1a85 22 36 f1				ld (os_word_scratch),hl 
1a88			 
1a88					 
1a88			 
1a88			 
1a88 e1					pop hl 
1a89 e5					push hl 
1a8a			 
1a8a cd cc 0f				call hexout 
1a8d			 
1a8d					 
1a8d 2a 54 f1		   	ld hl,(os_cur_ptr) 
1a90 23				inc hl 
1a91 22 54 f1		   	ld (os_cur_ptr),hl 
1a94			 
1a94 e1					pop hl 
1a95 23					inc hl 
1a96 23					inc hl 
1a97 23					inc hl 
1a98			 
1a98			 
1a98			 
1a98					;ld a,0 
1a98					;ld (os_word_scratch+2),a 
1a98					;pop af 
1a98					;push af 
1a98			 
1a98					;ld de, os_word_scratch 
1a98					;call str_at_display 
1a98			;		call update_display 
1a98			;		pop af 
1a98 c1					pop bc 
1a99 c6 03				add 3 
1a9b 10 dd			djnz .dumpbyte 
1a9d			 
1a9d				 
1a9d			 
1a9d c9				ret 
1a9e			 
1a9e			jump:	 
1a9e			 
1a9e 21 33 ee			ld hl,scratch+2 
1aa1 cd 82 10			call get_word_hl 
1aa4				;ld hl,(scratch+2) 
1aa4				;call fourehexhl 
1aa4			 
1aa4 22 54 f1			ld (os_cur_ptr),hl	 
1aa7			 
1aa7 e9				jp (hl) 
1aa8			 
1aa8			 
1aa8			 
1aa8			; TODO implement a basic monitor mode to start with 
1aa8			 
1aa8			 
1aa8			 
1aa8			 
1aa8			 
1aa8			 
1aa8			 
1aa8			 
1aa8			 
1aa8			; testing and demo code during development 
1aa8			 
1aa8			 
1aa8 .. 00		str1: db "Enter some text...",0 
1abb .. 00		clear: db "                    ",0 
1ad0			 
1ad0			demo: 
1ad0			 
1ad0			 
1ad0			 
1ad0			;	call update_display 
1ad0			 
1ad0				; init scratch input area for testing 
1ad0 21 31 ee			ld hl, scratch	 
1ad3 3e 00			ld a,0 
1ad5 77				ld (hl),a 
1ad6			 
1ad6			 
1ad6 3e 28		            LD   A, display_row_2 
1ad8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ad8 11 a8 1a		            LD   DE, str1 
1adb cd aa 0a			call str_at_display 
1ade			 
1ade			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ade			cloop:	 
1ade 3e 50		            LD   A, display_row_3 
1ae0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ae0 11 bb 1a		            LD   DE, clear 
1ae3			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1ae3 cd aa 0a				call str_at_display 
1ae6 3e 78			ld a, display_row_4 
1ae8 11 18 1b			ld de, prompt 
1aeb			 
1aeb cd aa 0a				call str_at_display 
1aee cd ba 0a			call update_display 
1af1			 
1af1 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1af3 16 0a			ld d, 10 
1af5 21 31 ee			ld hl, scratch	 
1af8 cd f8 0c			call input_str 
1afb			 
1afb			;	call clear_display 
1afb			;'	call update_display 
1afb			 
1afb 3e 00		            LD   A, display_row_1 
1afd			;            CALL fLCD_Pos       ;Position cursor to location in A 
1afd 11 bb 1a		            LD   DE, clear 
1b00 cd aa 0a				call str_at_display 
1b03			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b03 3e 00		            LD   A, display_row_1 
1b05			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b05 11 31 ee		            LD   DE, scratch 
1b08			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b08 cd aa 0a				call str_at_display 
1b0b cd ba 0a			call update_display 
1b0e			 
1b0e 3e 00				ld a,0 
1b10 21 31 ee			ld hl, scratch 
1b13 77				ld (hl),a 
1b14			 
1b14 00				nop 
1b15 c3 de 1a			jp cloop 
1b18			 
1b18			 
1b18			 
1b18			; OS Prompt 
1b18			 
1b18 .. 00		prompt: db ">",0 
1b1a .. 00		endprg: db "?",0 
1b1c			 
1b1c			 
1b1c			; handy next page prompt 
1b1c			next_page_prompt: 
1b1c e5				push hl 
1b1d d5				push de 
1b1e f5				push af 
1b1f c5				push bc 
1b20			 
1b20 3e 9f			ld a,display_row_4 + display_cols - 1 
1b22 11 1a 1b		        ld de, endprg 
1b25 cd aa 0a			call str_at_display 
1b28 cd ba 0a			call update_display 
1b2b cd c1 67			call cin_wait 
1b2e c1				pop bc 
1b2f f1				pop af 
1b30 d1				pop de 
1b31 e1				pop hl 
1b32			 
1b32			 
1b32 c9				ret 
1b33			 
1b33			 
1b33			; forth parser 
1b33			 
1b33			; My forth kernel 
1b33			include "forth_kernel.asm" 
1b33			; 
1b33			; kernel to the forth OS 
1b33			 
1b33			DS_TYPE_STR: equ 1     ; string type 
1b33			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b33			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b33			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b33			 
1b33			FORTH_PARSEV1: equ 0 
1b33			FORTH_PARSEV2: equ 0 
1b33			FORTH_PARSEV3: equ 0 
1b33			FORTH_PARSEV4: equ 0 
1b33			FORTH_PARSEV5: equ 1 
1b33			 
1b33			;if FORTH_PARSEV5 
1b33			;	FORTH_END_BUFFER: equ 0 
1b33			;else 
1b33			FORTH_END_BUFFER: equ 127 
1b33			;endif 
1b33			 
1b33			FORTH_TRUE: equ 1 
1b33			FORTH_FALSE: equ 0 
1b33			 
1b33			if FORTH_PARSEV4 
1b33			include "forth_stackops.asm" 
1b33			endif 
1b33			 
1b33			if FORTH_PARSEV5 
1b33			include "forth_stackopsv5.asm" 
1b33			 
1b33			; Stack operations for v5 parser on wards 
1b33			; * DATA stack 
1b33			; * LOOP stack 
1b33			; * RETURN stack 
1b33			 
1b33			 
1b33			 
1b33			FORTH_CHK_DSP_UNDER: macro 
1b33				push hl 
1b33				push de 
1b33				ld hl,(cli_data_sp) 
1b33				ld de, cli_data_stack 
1b33				call cmp16 
1b33				jp c, fault_dsp_under 
1b33				pop de 
1b33				pop hl 
1b33				endm 
1b33			 
1b33			 
1b33			FORTH_CHK_RSP_UNDER: macro 
1b33				push hl 
1b33				push de 
1b33				ld hl,(cli_ret_sp) 
1b33				ld de, cli_ret_stack 
1b33				call cmp16 
1b33				jp c, fault_rsp_under 
1b33				pop de 
1b33				pop hl 
1b33				endm 
1b33			 
1b33			FORTH_CHK_LOOP_UNDER: macro 
1b33				push hl 
1b33				push de 
1b33				ld hl,(cli_loop_sp) 
1b33				ld de, cli_loop_stack 
1b33				call cmp16 
1b33				jp c, fault_loop_under 
1b33				pop de 
1b33				pop hl 
1b33				endm 
1b33			 
1b33			FORTH_ERR_TOS_NOTSTR: macro 
1b33				; TOSO might need more for checks when used 
1b33				push af 
1b33				ld a,(hl) 
1b33				cp DS_TYPE_STR 
1b33				jp nz, type_faultn   
1b33				pop af 
1b33				endm 
1b33			 
1b33			FORTH_ERR_TOS_NOTNUM: macro 
1b33				push af 
1b33				ld a,(hl) 
1b33				cp DS_TYPE_INUM 
1b33				jp nz, type_faultn   
1b33				pop af 
1b33				endm 
1b33			 
1b33			 
1b33			; increase data stack pointer and save hl to it 
1b33				 
1b33			FORTH_DSP_NEXT: macro 
1b33				call macro_forth_dsp_next 
1b33				endm 
1b33			 
1b33			 
1b33			macro_forth_dsp_next: 
1b33				if DEBUG_FORTH_STACK_GUARD 
1b33 cd 62 62				call check_stacks 
1b36				endif 
1b36 e5				push hl 
1b37 d5				push de 
1b38 eb				ex de,hl 
1b39 2a 1e f8			ld hl,(cli_data_sp) 
1b3c 23				inc hl 
1b3d 23				inc hl 
1b3e			 
1b3e			; PARSEV5 
1b3e 23				inc hl 
1b3f 22 1e f8			ld (cli_data_sp),hl 
1b42 73				ld (hl), e 
1b43 23				inc hl 
1b44 72				ld (hl), d 
1b45 d1				pop de 
1b46 e1				pop hl 
1b47				if DEBUG_FORTH_STACK_GUARD 
1b47 cd 62 62				call check_stacks 
1b4a				endif 
1b4a c9				ret 
1b4b			 
1b4b			 
1b4b			; increase ret stack pointer and save hl to it 
1b4b				 
1b4b			FORTH_RSP_NEXT: macro 
1b4b				call macro_forth_rsp_next 
1b4b				endm 
1b4b			 
1b4b			macro_forth_rsp_next: 
1b4b				if DEBUG_FORTH_STACK_GUARD 
1b4b cd 62 62				call check_stacks 
1b4e				endif 
1b4e e5				push hl 
1b4f d5				push de 
1b50 eb				ex de,hl 
1b51 2a 22 f8			ld hl,(cli_ret_sp) 
1b54 23				inc hl 
1b55 23				inc hl 
1b56 22 22 f8			ld (cli_ret_sp),hl 
1b59 73				ld (hl), e 
1b5a 23				inc hl 
1b5b 72				ld (hl), d 
1b5c d1				pop de 
1b5d e1				pop hl 
1b5e				if DEBUG_FORTH_STACK_GUARD 
1b5e cd 62 62				call check_stacks 
1b61				endif 
1b61 c9				ret 
1b62			 
1b62			; get current ret stack pointer and save to hl  
1b62				 
1b62			FORTH_RSP_TOS: macro 
1b62				call macro_forth_rsp_tos 
1b62				endm 
1b62			 
1b62			macro_forth_rsp_tos: 
1b62				;push de 
1b62 2a 22 f8			ld hl,(cli_ret_sp) 
1b65 cd 9d 1b			call loadhlptrtohl 
1b68				;ld e, (hl) 
1b68				;inc hl 
1b68				;ld d, (hl) 
1b68				;ex de, hl 
1b68					if DEBUG_FORTH_WORDS 
1b68			;			DMARK "RST" 
1b68						CALLMONITOR 
1b68 cd 17 16			call break_point_state  
1b6b				endm  
# End of macro CALLMONITOR
1b6b					endif 
1b6b				;pop de 
1b6b c9				ret 
1b6c			 
1b6c			; pop ret stack pointer 
1b6c				 
1b6c			FORTH_RSP_POP: macro 
1b6c				call macro_forth_rsp_pop 
1b6c				endm 
1b6c			 
1b6c			 
1b6c			macro_forth_rsp_pop: 
1b6c				if DEBUG_FORTH_STACK_GUARD 
1b6c			;		DMARK "RPP" 
1b6c cd 62 62				call check_stacks 
1b6f					FORTH_CHK_RSP_UNDER 
1b6f e5				push hl 
1b70 d5				push de 
1b71 2a 22 f8			ld hl,(cli_ret_sp) 
1b74 11 9c f7			ld de, cli_ret_stack 
1b77 cd e9 0c			call cmp16 
1b7a da 76 63			jp c, fault_rsp_under 
1b7d d1				pop de 
1b7e e1				pop hl 
1b7f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b7f				endif 
1b7f e5				push hl 
1b80 2a 22 f8			ld hl,(cli_ret_sp) 
1b83			 
1b83			 
1b83				if FORTH_ENABLE_FREE 
1b83			 
1b83					; get pointer 
1b83			 
1b83					push de 
1b83					push hl 
1b83			 
1b83					ld e, (hl) 
1b83					inc hl 
1b83					ld d, (hl) 
1b83			 
1b83					ex de, hl 
1b83					call free 
1b83			 
1b83					pop hl 
1b83					pop de 
1b83			 
1b83			 
1b83				endif 
1b83			 
1b83			 
1b83 2b				dec hl 
1b84 2b				dec hl 
1b85 22 22 f8			ld (cli_ret_sp), hl 
1b88				; do stack underflow checks 
1b88 e1				pop hl 
1b89				if DEBUG_FORTH_STACK_GUARD 
1b89 cd 62 62				call check_stacks 
1b8c					FORTH_CHK_RSP_UNDER 
1b8c e5				push hl 
1b8d d5				push de 
1b8e 2a 22 f8			ld hl,(cli_ret_sp) 
1b91 11 9c f7			ld de, cli_ret_stack 
1b94 cd e9 0c			call cmp16 
1b97 da 76 63			jp c, fault_rsp_under 
1b9a d1				pop de 
1b9b e1				pop hl 
1b9c				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b9c				endif 
1b9c c9				ret 
1b9d			 
1b9d			 
1b9d			 
1b9d			; routine to load word pointed to by hl into hl 
1b9d			 
1b9d			loadhlptrtohl: 
1b9d			 
1b9d d5				push de 
1b9e 5e				ld e, (hl) 
1b9f 23				inc hl 
1ba0 56				ld d, (hl) 
1ba1 eb				ex de, hl 
1ba2 d1				pop de 
1ba3			 
1ba3 c9				ret 
1ba4			 
1ba4			 
1ba4			 
1ba4			 
1ba4			 
1ba4			; push a number held in HL onto the data stack 
1ba4			; entry point for pushing a value when already in hl used in function above 
1ba4			 
1ba4			forth_push_numhl: 
1ba4			 
1ba4 e5				push hl    ; save value to push 
1ba5			 
1ba5			if DEBUG_FORTH_PUSH 
1ba5				; see if disabled 
1ba5			 
1ba5			 
1ba5 f5				push af 
1ba6 3a 30 ee			ld a, (os_view_disable) 
1ba9 fe 2a			cp '*' 
1bab 28 34			jr z, .pskip2 
1bad e5				push hl 
1bae e5			push hl 
1baf cd 97 0a			call clear_display 
1bb2 e1			pop hl 
1bb3 7c				ld a,h 
1bb4 21 36 f1			ld hl, os_word_scratch 
1bb7 cd cc 0f			call hexout 
1bba e1				pop hl 
1bbb 7d				ld a,l 
1bbc 21 38 f1			ld hl, os_word_scratch+2 
1bbf cd cc 0f			call hexout 
1bc2			 
1bc2 21 3a f1			ld hl, os_word_scratch+4 
1bc5 3e 00			ld a,0 
1bc7 77				ld (hl),a 
1bc8 11 36 f1			ld de,os_word_scratch 
1bcb 3e 28				ld a, display_row_2 
1bcd cd aa 0a				call str_at_display 
1bd0 11 70 51			ld de, .push_num 
1bd3 3e 00			ld a, display_row_1 
1bd5			 
1bd5 cd aa 0a				call str_at_display 
1bd8			 
1bd8			 
1bd8 cd ba 0a			call update_display 
1bdb cd 45 0a			call delay1s 
1bde cd 45 0a			call delay1s 
1be1			.pskip2:  
1be1			 
1be1 f1				pop af 
1be2			endif	 
1be2			 
1be2			 
1be2				FORTH_DSP_NEXT 
1be2 cd 33 1b			call macro_forth_dsp_next 
1be5				endm 
# End of macro FORTH_DSP_NEXT
1be5			 
1be5 2a 1e f8			ld hl, (cli_data_sp) 
1be8			 
1be8				; save item type 
1be8 3e 02			ld a,  DS_TYPE_INUM 
1bea 77				ld (hl), a 
1beb 23				inc hl 
1bec			 
1bec				; get word off stack 
1bec d1				pop de 
1bed 7b				ld a,e 
1bee 77				ld (hl), a 
1bef 23				inc hl 
1bf0 7a				ld a,d 
1bf1 77				ld (hl), a 
1bf2			 
1bf2			if DEBUG_FORTH_PUSH 
1bf2 2b				dec hl 
1bf3 2b				dec hl 
1bf4 2b				dec hl 
1bf5						DMARK "PH5" 
1bf5 f5				push af  
1bf6 3a 0a 1c			ld a, (.dmark)  
1bf9 32 77 fb			ld (debug_mark),a  
1bfc 3a 0b 1c			ld a, (.dmark+1)  
1bff 32 78 fb			ld (debug_mark+1),a  
1c02 3a 0c 1c			ld a, (.dmark+2)  
1c05 32 79 fb			ld (debug_mark+2),a  
1c08 18 03			jr .pastdmark  
1c0a ..			.dmark: db "PH5"  
1c0d f1			.pastdmark: pop af  
1c0e			endm  
# End of macro DMARK
1c0e				CALLMONITOR 
1c0e cd 17 16			call break_point_state  
1c11				endm  
# End of macro CALLMONITOR
1c11			endif	 
1c11			 
1c11 c9				ret 
1c12			 
1c12			 
1c12			; Push a string to stack pointed to by hl 
1c12			 
1c12			forth_push_str: 
1c12			 
1c12			if DEBUG_FORTH_PUSH 
1c12						DMARK "PSQ" 
1c12 f5				push af  
1c13 3a 27 1c			ld a, (.dmark)  
1c16 32 77 fb			ld (debug_mark),a  
1c19 3a 28 1c			ld a, (.dmark+1)  
1c1c 32 78 fb			ld (debug_mark+1),a  
1c1f 3a 29 1c			ld a, (.dmark+2)  
1c22 32 79 fb			ld (debug_mark+2),a  
1c25 18 03			jr .pastdmark  
1c27 ..			.dmark: db "PSQ"  
1c2a f1			.pastdmark: pop af  
1c2b			endm  
# End of macro DMARK
1c2b				CALLMONITOR 
1c2b cd 17 16			call break_point_state  
1c2e				endm  
# End of macro CALLMONITOR
1c2e			endif	 
1c2e			    
1c2e e5				push hl 
1c2f e5				push hl 
1c30			 
1c30			;	ld a, 0   ; find end of string 
1c30 cd 29 11			call strlenz 
1c33			if DEBUG_FORTH_PUSH 
1c33						DMARK "PQ2" 
1c33 f5				push af  
1c34 3a 48 1c			ld a, (.dmark)  
1c37 32 77 fb			ld (debug_mark),a  
1c3a 3a 49 1c			ld a, (.dmark+1)  
1c3d 32 78 fb			ld (debug_mark+1),a  
1c40 3a 4a 1c			ld a, (.dmark+2)  
1c43 32 79 fb			ld (debug_mark+2),a  
1c46 18 03			jr .pastdmark  
1c48 ..			.dmark: db "PQ2"  
1c4b f1			.pastdmark: pop af  
1c4c			endm  
# End of macro DMARK
1c4c				CALLMONITOR 
1c4c cd 17 16			call break_point_state  
1c4f				endm  
# End of macro CALLMONITOR
1c4f			endif	 
1c4f eb				ex de, hl 
1c50 e1				pop hl   ; get ptr to start of string 
1c51			if DEBUG_FORTH_PUSH 
1c51						DMARK "PQ3" 
1c51 f5				push af  
1c52 3a 66 1c			ld a, (.dmark)  
1c55 32 77 fb			ld (debug_mark),a  
1c58 3a 67 1c			ld a, (.dmark+1)  
1c5b 32 78 fb			ld (debug_mark+1),a  
1c5e 3a 68 1c			ld a, (.dmark+2)  
1c61 32 79 fb			ld (debug_mark+2),a  
1c64 18 03			jr .pastdmark  
1c66 ..			.dmark: db "PQ3"  
1c69 f1			.pastdmark: pop af  
1c6a			endm  
# End of macro DMARK
1c6a				CALLMONITOR 
1c6a cd 17 16			call break_point_state  
1c6d				endm  
# End of macro CALLMONITOR
1c6d			endif	 
1c6d 19				add hl,de 
1c6e			if DEBUG_FORTH_PUSH 
1c6e						DMARK "PQE" 
1c6e f5				push af  
1c6f 3a 83 1c			ld a, (.dmark)  
1c72 32 77 fb			ld (debug_mark),a  
1c75 3a 84 1c			ld a, (.dmark+1)  
1c78 32 78 fb			ld (debug_mark+1),a  
1c7b 3a 85 1c			ld a, (.dmark+2)  
1c7e 32 79 fb			ld (debug_mark+2),a  
1c81 18 03			jr .pastdmark  
1c83 ..			.dmark: db "PQE"  
1c86 f1			.pastdmark: pop af  
1c87			endm  
# End of macro DMARK
1c87				CALLMONITOR 
1c87 cd 17 16			call break_point_state  
1c8a				endm  
# End of macro CALLMONITOR
1c8a			endif	 
1c8a			 
1c8a 2b				dec hl    ; see if there is an optional trailing double quote 
1c8b 7e				ld a,(hl) 
1c8c fe 22			cp '"' 
1c8e 20 03			jr nz, .strnoq 
1c90 3e 00			ld a, 0      ; get rid of double quote 
1c92 77				ld (hl), a 
1c93 23			.strnoq: inc hl 
1c94			 
1c94 3e 00			ld a, 0 
1c96 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c97			 
1c97 13				inc de ; add one for the type string 
1c98 13				inc de ; add one for null term??? 
1c99			 
1c99				; tos is get string pointer again 
1c99				; de contains space to allocate 
1c99				 
1c99 d5				push de 
1c9a			 
1c9a eb				ex de, hl 
1c9b			 
1c9b				;push af 
1c9b			 
1c9b			if DEBUG_FORTH_PUSH 
1c9b						DMARK "PHm" 
1c9b f5				push af  
1c9c 3a b0 1c			ld a, (.dmark)  
1c9f 32 77 fb			ld (debug_mark),a  
1ca2 3a b1 1c			ld a, (.dmark+1)  
1ca5 32 78 fb			ld (debug_mark+1),a  
1ca8 3a b2 1c			ld a, (.dmark+2)  
1cab 32 79 fb			ld (debug_mark+2),a  
1cae 18 03			jr .pastdmark  
1cb0 ..			.dmark: db "PHm"  
1cb3 f1			.pastdmark: pop af  
1cb4			endm  
# End of macro DMARK
1cb4				CALLMONITOR 
1cb4 cd 17 16			call break_point_state  
1cb7				endm  
# End of macro CALLMONITOR
1cb7			endif	 
1cb7 cd 92 11			call malloc	; on ret hl now contains allocated memory 
1cba				if DEBUG_FORTH_MALLOC_GUARD 
1cba cc c8 51				call z,malloc_error 
1cbd				endif 
1cbd			 
1cbd				 
1cbd c1				pop bc    ; get length 
1cbe d1				pop de   ;  get string start    
1cbf			 
1cbf				; hl has destination from malloc 
1cbf			 
1cbf eb				ex de, hl    ; prep for ldir 
1cc0			 
1cc0 d5				push de   ; save malloc area for DSP later 
1cc1				;push hl   ; save malloc area for DSP later 
1cc1			 
1cc1			if DEBUG_FORTH_PUSH 
1cc1						DMARK "PHc" 
1cc1 f5				push af  
1cc2 3a d6 1c			ld a, (.dmark)  
1cc5 32 77 fb			ld (debug_mark),a  
1cc8 3a d7 1c			ld a, (.dmark+1)  
1ccb 32 78 fb			ld (debug_mark+1),a  
1cce 3a d8 1c			ld a, (.dmark+2)  
1cd1 32 79 fb			ld (debug_mark+2),a  
1cd4 18 03			jr .pastdmark  
1cd6 ..			.dmark: db "PHc"  
1cd9 f1			.pastdmark: pop af  
1cda			endm  
# End of macro DMARK
1cda				CALLMONITOR 
1cda cd 17 16			call break_point_state  
1cdd				endm  
# End of macro CALLMONITOR
1cdd			endif	 
1cdd			 
1cdd			 
1cdd ed b0			ldir 
1cdf			 
1cdf			 
1cdf				; push malloc to data stack     macro?????  
1cdf			 
1cdf				FORTH_DSP_NEXT 
1cdf cd 33 1b			call macro_forth_dsp_next 
1ce2				endm 
# End of macro FORTH_DSP_NEXT
1ce2			 
1ce2				; save value and type 
1ce2			 
1ce2 2a 1e f8			ld hl, (cli_data_sp) 
1ce5			 
1ce5				; save item type 
1ce5 3e 01			ld a,  DS_TYPE_STR 
1ce7 77				ld (hl), a 
1ce8 23				inc hl 
1ce9			 
1ce9				; get malloc word off stack 
1ce9 d1				pop de 
1cea 73				ld (hl), e 
1ceb 23				inc hl 
1cec 72				ld (hl), d 
1ced			 
1ced			 
1ced			 
1ced			if DEBUG_FORTH_PUSH 
1ced 2a 1e f8			ld hl, (cli_data_sp) 
1cf0						DMARK "PHS" 
1cf0 f5				push af  
1cf1 3a 05 1d			ld a, (.dmark)  
1cf4 32 77 fb			ld (debug_mark),a  
1cf7 3a 06 1d			ld a, (.dmark+1)  
1cfa 32 78 fb			ld (debug_mark+1),a  
1cfd 3a 07 1d			ld a, (.dmark+2)  
1d00 32 79 fb			ld (debug_mark+2),a  
1d03 18 03			jr .pastdmark  
1d05 ..			.dmark: db "PHS"  
1d08 f1			.pastdmark: pop af  
1d09			endm  
# End of macro DMARK
1d09				CALLMONITOR 
1d09 cd 17 16			call break_point_state  
1d0c				endm  
# End of macro CALLMONITOR
1d0c			;	ex de,hl 
1d0c			endif	 
1d0c				; in case of spaces, skip the ptr past the copied string 
1d0c				;pop af 
1d0c				;ld (cli_origptr),hl 
1d0c			 
1d0c c9				ret 
1d0d			 
1d0d			 
1d0d			 
1d0d			; TODO ascii push input onto stack given hl to start of input 
1d0d			 
1d0d			; identify type 
1d0d			; if starts with a " then a string 
1d0d			; otherwise it is a number 
1d0d			;  
1d0d			; if a string 
1d0d			;     scan for ending " to get length of string to malloc for + 1 
1d0d			;     malloc 
1d0d			;     put pointer to string on stack first byte flags as string 
1d0d			; 
1d0d			; else a number 
1d0d			;    look for number format identifier 
1d0d			;    $xx hex 
1d0d			;    %xxxxx bin 
1d0d			;    xxxxx decimal 
1d0d			;    convert number to 16bit word.  
1d0d			;    malloc word + 1 with flag to identiy as num 
1d0d			;    put pointer to number on stack 
1d0d			;   
1d0d			;  
1d0d			  
1d0d			forth_apush: 
1d0d				; kernel push 
1d0d			 
1d0d			if DEBUG_FORTH_PUSH 
1d0d						DMARK "PSH" 
1d0d f5				push af  
1d0e 3a 22 1d			ld a, (.dmark)  
1d11 32 77 fb			ld (debug_mark),a  
1d14 3a 23 1d			ld a, (.dmark+1)  
1d17 32 78 fb			ld (debug_mark+1),a  
1d1a 3a 24 1d			ld a, (.dmark+2)  
1d1d 32 79 fb			ld (debug_mark+2),a  
1d20 18 03			jr .pastdmark  
1d22 ..			.dmark: db "PSH"  
1d25 f1			.pastdmark: pop af  
1d26			endm  
# End of macro DMARK
1d26				CALLMONITOR 
1d26 cd 17 16			call break_point_state  
1d29				endm  
# End of macro CALLMONITOR
1d29			endif	 
1d29				; identify input type 
1d29			 
1d29 7e				ld a,(hl) 
1d2a fe 22			cp '"' 
1d2c 28 0a			jr z, .fapstr 
1d2e fe 24			cp '$' 
1d30 ca 58 1d			jp z, .faphex 
1d33 fe 25			cp '%' 
1d35 ca 40 1d			jp z, .fapbin 
1d38			;	cp 'b' 
1d38			;	jp z, .fabin 
1d38				; else decimal 
1d38			 
1d38				; TODO do decimal conversion 
1d38				; decimal is stored as a 16bit word 
1d38			 
1d38				; by default everything is a string if type is not detected 
1d38			.fapstr: ; 
1d38 fe 22			cp '"' 
1d3a 20 01			jr nz, .strnoqu 
1d3c 23				inc hl 
1d3d			.strnoqu: 
1d3d c3 12 1c			jp forth_push_str 
1d40			 
1d40			 
1d40			 
1d40			.fapbin:    ; push a binary string.  
1d40 11 00 00			ld de, 0   ; hold a 16bit value 
1d43			 
1d43 23			.fapbinshift:	inc hl  
1d44 7e				ld a,(hl) 
1d45 fe 00			cp 0     ; done scanning  
1d47 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d49			 
1d49				; left shift de 
1d49 eb				ex de, hl	 
1d4a 29				add hl, hl 
1d4b			 
1d4b				; is 1 
1d4b fe 31			cp '1' 
1d4d 20 02			jr nz, .binzero 
1d4f cb 4d			bit 1, l 
1d51			.binzero: 
1d51 eb				ex de, hl	 ; save current de 
1d52 18 ef			jr .fapbinshift 
1d54			 
1d54			.fapbdone: 
1d54 eb				ex de, hl 
1d55 c3 a4 1b			jp forth_push_numhl 
1d58			 
1d58			 
1d58			.faphex:   ; hex is always stored as a 16bit word 
1d58				; skip number prefix 
1d58 23				inc hl 
1d59				; turn ascii into number 
1d59 cd 82 10			call get_word_hl	; ret 16bit word in hl 
1d5c			 
1d5c c3 a4 1b			jp forth_push_numhl 
1d5f			 
1d5f 00				 nop 
1d60			 
1d60			.fabin:   ; TODO bin conversion 
1d60			 
1d60			 
1d60 c9				ret 
1d61			 
1d61			 
1d61			; get either a string ptr or a 16bit word from the data stack 
1d61			 
1d61			FORTH_DSP: macro 
1d61				call macro_forth_dsp 
1d61				endm 
1d61			 
1d61			macro_forth_dsp: 
1d61				; data stack pointer points to current word on tos 
1d61			 
1d61 2a 1e f8			ld hl,(cli_data_sp) 
1d64			 
1d64				if DEBUG_FORTH_PUSH 
1d64						DMARK "DSP" 
1d64 f5				push af  
1d65 3a 79 1d			ld a, (.dmark)  
1d68 32 77 fb			ld (debug_mark),a  
1d6b 3a 7a 1d			ld a, (.dmark+1)  
1d6e 32 78 fb			ld (debug_mark+1),a  
1d71 3a 7b 1d			ld a, (.dmark+2)  
1d74 32 79 fb			ld (debug_mark+2),a  
1d77 18 03			jr .pastdmark  
1d79 ..			.dmark: db "DSP"  
1d7c f1			.pastdmark: pop af  
1d7d			endm  
# End of macro DMARK
1d7d			 
1d7d cd fd 51				call display_data_sp 
1d80				;call break_point_state 
1d80				;rst 030h 
1d80				CALLMONITOR 
1d80 cd 17 16			call break_point_state  
1d83				endm  
# End of macro CALLMONITOR
1d83				endif 
1d83			 
1d83 c9				ret 
1d84			 
1d84			; return hl to start of value on stack 
1d84			 
1d84			FORTH_DSP_VALUE: macro 
1d84				call macro_forth_dsp_value 
1d84				endm 
1d84			 
1d84			macro_forth_dsp_value: 
1d84			 
1d84				FORTH_DSP 
1d84 cd 61 1d			call macro_forth_dsp 
1d87				endm 
# End of macro FORTH_DSP
1d87			 
1d87 d5				push de 
1d88			 
1d88 23				inc hl ; skip type 
1d89			 
1d89 5e				ld e, (hl) 
1d8a 23				inc hl 
1d8b 56				ld d, (hl) 
1d8c eb				ex de,hl  
1d8d			 
1d8d d1				pop de 
1d8e			 
1d8e c9				ret 
1d8f			 
1d8f			; return hl to start of value to second item on stack 
1d8f			 
1d8f			FORTH_DSP_VALUEM1: macro 
1d8f				call macro_forth_dsp_value_m1 
1d8f				endm 
1d8f			 
1d8f			macro_forth_dsp_value_m1: 
1d8f			 
1d8f				FORTH_DSP 
1d8f cd 61 1d			call macro_forth_dsp 
1d92				endm 
# End of macro FORTH_DSP
1d92			 
1d92 2b				dec hl 
1d93 2b				dec hl 
1d94			;	dec hl 
1d94			 
1d94 d5				push de 
1d95			 
1d95 5e				ld e, (hl) 
1d96 23				inc hl 
1d97 56				ld d, (hl) 
1d98 eb				ex de,hl  
1d99			 
1d99 d1				pop de 
1d9a			 
1d9a c9				ret 
1d9b			 
1d9b				 
1d9b			 
1d9b			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d9b			 
1d9b			FORTH_DSP_POP: macro 
1d9b				call macro_forth_dsp_pop 
1d9b				endm 
1d9b			 
1d9b			 
1d9b			; get the tos data type 
1d9b			 
1d9b			FORTH_DSP_TYPE:   macro 
1d9b			 
1d9b				;FORTH_DSP_VALUE 
1d9b				FORTH_DSP 
1d9b				 
1d9b				; hl points to value 
1d9b				; check type 
1d9b			 
1d9b				ld a,(hl) 
1d9b			 
1d9b				endm 
1d9b			 
1d9b			; load the tos value into hl 
1d9b			 
1d9b			 
1d9b			FORTH_DSP_VALUEHL:  macro 
1d9b				call macro_dsp_valuehl 
1d9b				endm 
1d9b			 
1d9b			 
1d9b			 
1d9b			macro_dsp_valuehl: 
1d9b				FORTH_DSP_VALUE 
1d9b cd 84 1d			call macro_forth_dsp_value 
1d9e				endm 
# End of macro FORTH_DSP_VALUE
1d9e			 
1d9e				;FORTH_ERR_TOS_NOTNUM 
1d9e			 
1d9e				;inc hl   ; skip type id 
1d9e			 
1d9e			;	push de 
1d9e			; 
1d9e			;	ld e, (hl) 
1d9e			;	inc hl 
1d9e			;	ld d, (hl) 
1d9e			;	ex de,hl  
1d9e			 
1d9e			;	pop de 
1d9e			 
1d9e				if DEBUG_FORTH_PUSH 
1d9e						DMARK "DVL" 
1d9e f5				push af  
1d9f 3a b3 1d			ld a, (.dmark)  
1da2 32 77 fb			ld (debug_mark),a  
1da5 3a b4 1d			ld a, (.dmark+1)  
1da8 32 78 fb			ld (debug_mark+1),a  
1dab 3a b5 1d			ld a, (.dmark+2)  
1dae 32 79 fb			ld (debug_mark+2),a  
1db1 18 03			jr .pastdmark  
1db3 ..			.dmark: db "DVL"  
1db6 f1			.pastdmark: pop af  
1db7			endm  
# End of macro DMARK
1db7				CALLMONITOR 
1db7 cd 17 16			call break_point_state  
1dba				endm  
# End of macro CALLMONITOR
1dba				endif 
1dba c9				ret 
1dbb			 
1dbb			forth_apushstrhl:      
1dbb				; push of string requires use of cli_origptr 
1dbb				; bodge use 
1dbb			 
1dbb				; get current cli_origptr, save, update with temp pointer  
1dbb ed 5b 3a f8		ld de, (cli_origptr) 
1dbf 22 3a f8			ld (cli_origptr), hl 
1dc2 d5				push de 
1dc3 cd 0d 1d			call forth_apush 
1dc6 d1				pop de 
1dc7 ed 53 3a f8		ld (cli_origptr), de 
1dcb c9			        ret	 
1dcc			 
1dcc			 
1dcc			; increase loop stack pointer and save hl to it 
1dcc				 
1dcc			FORTH_LOOP_NEXT: macro 
1dcc				call macro_forth_loop_next 
1dcc				;nop 
1dcc				endm 
1dcc			 
1dcc			macro_forth_loop_next: 
1dcc				if DEBUG_FORTH_STACK_GUARD 
1dcc cd 62 62				call check_stacks 
1dcf				endif 
1dcf e5				push hl 
1dd0 d5				push de 
1dd1 eb				ex de,hl 
1dd2 2a 20 f8			ld hl,(cli_loop_sp) 
1dd5 23				inc hl 
1dd6 23				inc hl 
1dd7					if DEBUG_FORTH_WORDS 
1dd7						DMARK "LNX" 
1dd7 f5				push af  
1dd8 3a ec 1d			ld a, (.dmark)  
1ddb 32 77 fb			ld (debug_mark),a  
1dde 3a ed 1d			ld a, (.dmark+1)  
1de1 32 78 fb			ld (debug_mark+1),a  
1de4 3a ee 1d			ld a, (.dmark+2)  
1de7 32 79 fb			ld (debug_mark+2),a  
1dea 18 03			jr .pastdmark  
1dec ..			.dmark: db "LNX"  
1def f1			.pastdmark: pop af  
1df0			endm  
# End of macro DMARK
1df0						CALLMONITOR 
1df0 cd 17 16			call break_point_state  
1df3				endm  
# End of macro CALLMONITOR
1df3					endif 
1df3 22 20 f8			ld (cli_loop_sp),hl 
1df6 73				ld (hl), e 
1df7 23				inc hl 
1df8 72				ld (hl), d 
1df9 d1				pop de    ; been reversed so save a swap on restore 
1dfa e1				pop hl 
1dfb				if DEBUG_FORTH_STACK_GUARD 
1dfb cd 62 62				call check_stacks 
1dfe				endif 
1dfe c9				ret 
1dff			 
1dff			; get current ret stack pointer and save to hl  
1dff				 
1dff			FORTH_LOOP_TOS: macro 
1dff				call macro_forth_loop_tos 
1dff				endm 
1dff			 
1dff			macro_forth_loop_tos: 
1dff d5				push de 
1e00 2a 20 f8			ld hl,(cli_loop_sp) 
1e03 5e				ld e, (hl) 
1e04 23				inc hl 
1e05 56				ld d, (hl) 
1e06 eb				ex de, hl 
1e07 d1				pop de 
1e08 c9				ret 
1e09			 
1e09			; pop loop stack pointer 
1e09				 
1e09			FORTH_LOOP_POP: macro 
1e09				call macro_forth_loop_pop 
1e09				endm 
1e09			 
1e09			 
1e09			macro_forth_loop_pop: 
1e09				if DEBUG_FORTH_STACK_GUARD 
1e09					DMARK "LPP" 
1e09 f5				push af  
1e0a 3a 1e 1e			ld a, (.dmark)  
1e0d 32 77 fb			ld (debug_mark),a  
1e10 3a 1f 1e			ld a, (.dmark+1)  
1e13 32 78 fb			ld (debug_mark+1),a  
1e16 3a 20 1e			ld a, (.dmark+2)  
1e19 32 79 fb			ld (debug_mark+2),a  
1e1c 18 03			jr .pastdmark  
1e1e ..			.dmark: db "LPP"  
1e21 f1			.pastdmark: pop af  
1e22			endm  
# End of macro DMARK
1e22 cd 62 62				call check_stacks 
1e25					FORTH_CHK_LOOP_UNDER 
1e25 e5				push hl 
1e26 d5				push de 
1e27 2a 20 f8			ld hl,(cli_loop_sp) 
1e2a 11 9a f5			ld de, cli_loop_stack 
1e2d cd e9 0c			call cmp16 
1e30 da 7c 63			jp c, fault_loop_under 
1e33 d1				pop de 
1e34 e1				pop hl 
1e35				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e35				endif 
1e35 e5				push hl 
1e36 2a 20 f8			ld hl,(cli_loop_sp) 
1e39 2b				dec hl 
1e3a 2b				dec hl 
1e3b 22 20 f8			ld (cli_loop_sp), hl 
1e3e				; TODO do stack underflow checks 
1e3e e1				pop hl 
1e3f				if DEBUG_FORTH_STACK_GUARD 
1e3f cd 62 62				call check_stacks 
1e42					FORTH_CHK_LOOP_UNDER 
1e42 e5				push hl 
1e43 d5				push de 
1e44 2a 20 f8			ld hl,(cli_loop_sp) 
1e47 11 9a f5			ld de, cli_loop_stack 
1e4a cd e9 0c			call cmp16 
1e4d da 7c 63			jp c, fault_loop_under 
1e50 d1				pop de 
1e51 e1				pop hl 
1e52				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e52				endif 
1e52 c9				ret 
1e53			 
1e53			macro_forth_dsp_pop: 
1e53			 
1e53 e5				push hl 
1e54			 
1e54				; release malloc data 
1e54			 
1e54				if DEBUG_FORTH_STACK_GUARD 
1e54 cd 62 62				call check_stacks 
1e57					FORTH_CHK_DSP_UNDER 
1e57 e5				push hl 
1e58 d5				push de 
1e59 2a 1e f8			ld hl,(cli_data_sp) 
1e5c 11 98 f3			ld de, cli_data_stack 
1e5f cd e9 0c			call cmp16 
1e62 da 70 63			jp c, fault_dsp_under 
1e65 d1				pop de 
1e66 e1				pop hl 
1e67				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e67				endif 
1e67				;ld hl,(cli_data_sp) 
1e67			if DEBUG_FORTH_DOT 
1e67				DMARK "DPP" 
1e67				CALLMONITOR 
1e67			endif	 
1e67			 
1e67			 
1e67			if FORTH_ENABLE_DSPPOPFREE 
1e67			 
1e67				FORTH_DSP 
1e67 cd 61 1d			call macro_forth_dsp 
1e6a				endm 
# End of macro FORTH_DSP
1e6a			 
1e6a 7e				ld a, (hl) 
1e6b fe 01			cp DS_TYPE_STR 
1e6d 20 07			jr nz, .skippopfree 
1e6f			 
1e6f				FORTH_DSP_VALUEHL 
1e6f cd 9b 1d			call macro_dsp_valuehl 
1e72				endm 
# End of macro FORTH_DSP_VALUEHL
1e72 00				nop 
1e73			if DEBUG_FORTH_DOT 
1e73				DMARK "DPf" 
1e73				CALLMONITOR 
1e73			endif	 
1e73 cd 5c 12			call free 
1e76			.skippopfree: 
1e76				 
1e76			 
1e76			endif 
1e76			 
1e76			if DEBUG_FORTH_DOT_KEY 
1e76				DMARK "DP2" 
1e76				CALLMONITOR 
1e76			endif	 
1e76			 
1e76				; move pointer down 
1e76			 
1e76 2a 1e f8			ld hl,(cli_data_sp) 
1e79 2b				dec hl 
1e7a 2b				dec hl 
1e7b			; PARSEV5 
1e7b 2b				dec hl 
1e7c 22 1e f8			ld (cli_data_sp), hl 
1e7f			 
1e7f				if DEBUG_FORTH_STACK_GUARD 
1e7f cd 62 62				call check_stacks 
1e82					FORTH_CHK_DSP_UNDER 
1e82 e5				push hl 
1e83 d5				push de 
1e84 2a 1e f8			ld hl,(cli_data_sp) 
1e87 11 98 f3			ld de, cli_data_stack 
1e8a cd e9 0c			call cmp16 
1e8d da 70 63			jp c, fault_dsp_under 
1e90 d1				pop de 
1e91 e1				pop hl 
1e92				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e92				endif 
1e92			 
1e92 e1				pop hl 
1e93			 
1e93 c9				ret 
1e94			 
1e94			getwordathl: 
1e94				; hl points to an address 
1e94				; load hl with the word at that address 
1e94			 
1e94 d5				push de 
1e95			 
1e95 5e				ld e, (hl) 
1e96 23				inc hl 
1e97 56				ld d, (hl) 
1e98 eb				ex de, hl 
1e99			 
1e99 d1				pop de 
1e9a c9				ret 
1e9b			 
1e9b			 
1e9b			 
1e9b			 
1e9b			 
1e9b			; eof 
1e9b			 
# End of file forth_stackopsv5.asm
1e9b			endif 
1e9b			 
1e9b			user_word_eol:  
1e9b				; hl contains the pointer to where to create a linked list item from the end 
1e9b				; of the user dict to continue on at the system word dict 
1e9b				 
1e9b				; poke the stub of the word list linked list to repoint to rom words 
1e9b			 
1e9b				; stub format 
1e9b				; db   word id 
1e9b				; dw    link to next word 
1e9b			        ; db char length of token 
1e9b				; db string + 0 term 
1e9b				; db exec code....  
1e9b			 
1e9b 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1e9d 77				ld (hl), a		; word id 
1e9e 23				inc hl 
1e9f			 
1e9f 11 65 20			ld de, sysdict 
1ea2 73				ld (hl), e		; next word link ie system dict 
1ea3 23				inc hl 
1ea4 72				ld (hl), d		; next word link ie system dict 
1ea5 23				inc hl	 
1ea6			 
1ea6			;	ld (hl), sysdict		; next word link ie system dict 
1ea6			;	inc hl 
1ea6			;	inc hl 
1ea6			 
1ea6			;	inc hl 
1ea6			;	inc hl 
1ea6			 
1ea6 3e 02			ld a, 2			; word length is 0 
1ea8 77				ld (hl), a	 
1ea9 23				inc hl 
1eaa			 
1eaa 3e 7e			ld a, '~'			; word length is 0 
1eac 77				ld (hl), a	 
1ead 23				inc hl 
1eae 3e 00			ld a, 0			; save empty word 
1eb0 77				ld (hl), a 
1eb1			 
1eb1 c9				ret 
1eb2			 
1eb2				 
1eb2			 
1eb2			forthexec_cleanup: 
1eb2				FORTH_RSP_POP 
1eb2 cd 6c 1b			call macro_forth_rsp_pop 
1eb5				endm 
# End of macro FORTH_RSP_POP
1eb5 c9				ret 
1eb6			 
1eb6			forth_call_hl: 
1eb6				; taking hl 
1eb6 e5				push hl 
1eb7 c9				ret 
1eb8			 
1eb8			; this is called to reset Forth system but keep existing uwords etc 
1eb8			 
1eb8			forth_warmstart: 
1eb8				; setup stack over/under flow checks 
1eb8				if DEBUG_FORTH_STACK_GUARD 
1eb8 cd 48 62				call chk_stk_init 
1ebb				endif 
1ebb			 
1ebb				; init stack pointers  - * these stacks go upwards *  
1ebb 21 9c f7			ld hl, cli_ret_stack 
1ebe 22 22 f8			ld (cli_ret_sp), hl	 
1ec1				; set bottom of stack 
1ec1 3e 00			ld a,0 
1ec3 77				ld (hl),a 
1ec4 23				inc hl 
1ec5 77				ld (hl),a 
1ec6			 
1ec6 21 98 f3			ld hl, cli_data_stack 
1ec9 22 1e f8			ld (cli_data_sp), hl	 
1ecc				; set bottom of stack 
1ecc 3e 00			ld a,0 
1ece 77				ld (hl),a 
1ecf 23				inc hl 
1ed0 77				ld (hl),a 
1ed1			 
1ed1 21 9a f5			ld hl, cli_loop_stack 
1ed4 22 20 f8			ld (cli_loop_sp), hl	 
1ed7				; set bottom of stack 
1ed7 3e 00			ld a,0 
1ed9 77				ld (hl),a 
1eda 23				inc hl 
1edb 77				ld (hl),a 
1edc			 
1edc				; init extent of current open file 
1edc			 
1edc 3e 00			ld a, 0 
1ede 32 59 f8			ld (store_openext), a 
1ee1			 
1ee1 c9				ret 
1ee2			 
1ee2			 
1ee2			; Cold Start - this is called to setup the whole Forth system 
1ee2			 
1ee2			forth_init: 
1ee2			 
1ee2				; setup stack over/under flow checks 
1ee2			 
1ee2			;	if DEBUG_FORTH_STACK_GUARD 
1ee2			;		call chk_stk_init 
1ee2			;	endif 
1ee2			 
1ee2				; enable auto display updates (slow.....) 
1ee2			 
1ee2 3e 01			ld a, 1 
1ee4 32 38 f8			ld (cli_autodisplay), a 
1ee7			 
1ee7			 
1ee7			 
1ee7				; show start up screen 
1ee7			 
1ee7 cd 97 0a			call clear_display 
1eea			 
1eea 3e 00			ld a,0 
1eec 32 5a f8			ld (f_cursor_ptr), a 
1eef			 
1eef				; set start of word list in start of ram - for use when creating user words 
1eef			 
1eef 21 00 80			ld hl, baseram 
1ef2 22 2e f1			ld (os_last_new_uword), hl 
1ef5 cd 9b 1e			call user_word_eol 
1ef8				 
1ef8			;		call display_data_sp 
1ef8			;		call next_page_prompt 
1ef8			 
1ef8			 
1ef8			 
1ef8			 
1ef8 c9				ret 
1ef9			 
1ef9 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f0d			 
1f0d			; TODO push to stack 
1f0d			 
1f0d			;  
1f0d			 
1f0d			if FORTH_PARSEV2 
1f0d			 
1f0d			 
1f0d				include "forth_parserv2.asm" 
1f0d			 
1f0d			endif 
1f0d			 
1f0d			 
1f0d			; parse cli version 1 
1f0d			 
1f0d			if FORTH_PARSEV1 
1f0d			 
1f0d			 
1f0d			 
1f0d			      include "forth_parserv1.asm" 
1f0d			endif 
1f0d				 
1f0d			if FORTH_PARSEV3 
1f0d			 
1f0d			 
1f0d			 
1f0d			      include "forth_parserv3.asm" 
1f0d				include "forth_wordsv3.asm" 
1f0d			endif 
1f0d			 
1f0d			if FORTH_PARSEV4 
1f0d			 
1f0d			 
1f0d			 
1f0d			      include "forth_parserv4.asm" 
1f0d				include "forth_wordsv4.asm" 
1f0d			endif 
1f0d			 
1f0d			if FORTH_PARSEV5 
1f0d			 
1f0d			 
1f0d			 
1f0d			      include "forth_parserv5.asm" 
1f0d			 
1f0d			 
1f0d			; A better parser without using malloc and string copies all over the place.  
1f0d			; Exec in situ should be faster 
1f0d			 
1f0d			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f0d			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f0d			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f0d			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f0d			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f0d			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f0d			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f0d			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f0d			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f0d			 
1f0d			; Core word preamble macro 
1f0d			 
1f0d			CWHEAD:   macro nxtword opcode lit len opflags 
1f0d				db WORD_SYS_CORE+opcode             
1f0d				; internal op code number 
1f0d				dw nxtword            
1f0d				; link to next dict word block 
1f0d				db len + 1 
1f0d				; literal length of dict word inc zero term 
1f0d				db lit,0              
1f0d				; literal dict word 
1f0d			        ; TODO db opflags        
1f0d				endm 
1f0d			 
1f0d			 
1f0d			NEXTW: macro  
1f0d				jp macro_next 
1f0d				endm 
1f0d			 
1f0d			macro_next: 
1f0d			if DEBUG_FORTH_PARSE_KEY 
1f0d				DMARK "NXT" 
1f0d				CALLMONITOR 
1f0d			endif	 
1f0d			;	inc hl  ; skip token null term  
1f0d ed 4b 3c f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f11 ed 5b 3a f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f15 2a 32 f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f18			if DEBUG_FORTH_PARSE_KEY 
1f18				DMARK "}AA" 
1f18				CALLMONITOR 
1f18			endif	 
1f18 c3 1b 20			jp execnext 
1f1b				;jp exec1 
1f1b			       
1f1b			 
1f1b			 
1f1b			; Another go at the parser to compile  
1f1b			 
1f1b			 
1f1b			; TODO rework parser to change all of the string words to byte tokens 
1f1b			; TODO do a search for  
1f1b			 
1f1b			; TODO first run normal parser to zero term sections 
1f1b			; TODO for each word do a token look up to get the op code 
1f1b			; TODO need some means to flag to the exec that this is a byte code form    
1f1b			 
1f1b			 
1f1b			forthcompile: 
1f1b			 
1f1b			; 
1f1b			; line parse: 
1f1b			;       parse raw input buffer 
1f1b			;       tokenise the words 
1f1b			;       malloc new copy (for looping etc) 
1f1b			;       copy to malloc + current pc in line to start of string and add line term 
1f1b			;       save on new rsp 
1f1b			; 
1f1b			 
1f1b			; hl to point to the line to tokenise 
1f1b			 
1f1b			;	push hl 
1f1b 22 32 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1f1e			 
1f1e			;	ld a,0		; string term on input 
1f1e			;	call strlent 
1f1e			 
1f1e			;	ld (os_tok_len), hl	 ; save string length 
1f1e			 
1f1e			;if DEBUG_FORTH_TOK 
1f1e			;	ex de,hl		 
1f1e			;endif 
1f1e			 
1f1e			;	pop hl 		; get back string pointer 
1f1e			 
1f1e			if DEBUG_FORTH_TOK 
1f1e						DMARK "TOc" 
1f1e				CALLMONITOR 
1f1e			endif 
1f1e 7e			.cptoken2:    ld a,(hl) 
1f1f 23				inc hl 
1f20 fe 7f			cp FORTH_END_BUFFER 
1f22 28 29			jr z, .cptokendone2 
1f24 fe 00			cp 0 
1f26 28 25			jr z, .cptokendone2 
1f28 fe 22			cp '"' 
1f2a 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f2c fe 20			cp ' ' 
1f2e 20 ee			jr nz,  .cptoken2 
1f30			 
1f30			; TODO consume comments held between ( and ) 
1f30			 
1f30				; we have a space so change to zero term for dict match later 
1f30 2b				dec hl 
1f31 3e 00			ld a,0 
1f33 77				ld (hl), a 
1f34 23				inc hl 
1f35 18 e7			jr .cptoken2 
1f37				 
1f37			 
1f37			.cptokenstr2: 
1f37				; skip all white space until either eol (because forgot to term) or end double quote 
1f37			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f37				;inc hl ; skip current double quote 
1f37 7e				ld a,(hl) 
1f38 23				inc hl 
1f39 fe 22			cp '"' 
1f3b 28 e1			jr z, .cptoken2 
1f3d fe 7f			cp FORTH_END_BUFFER 
1f3f 28 0c			jr z, .cptokendone2 
1f41 fe 00			cp 0 
1f43 28 08			jr z, .cptokendone2 
1f45 fe 20			cp ' ' 
1f47 28 02			jr z, .cptmp2 
1f49 18 ec			jr .cptokenstr2 
1f4b			 
1f4b			.cptmp2:	; we have a space so change to zero term for dict match later 
1f4b				;dec hl 
1f4b				;ld a,"-"	; TODO remove this when working 
1f4b				;ld (hl), a 
1f4b				;inc hl 
1f4b 18 ea			jr .cptokenstr2 
1f4d			 
1f4d			.cptokendone2: 
1f4d				;inc hl 
1f4d 3e 7f			ld a, FORTH_END_BUFFER 
1f4f 77				ld (hl),a 
1f50 23				inc hl 
1f51 3e 21			ld a, '!' 
1f53 77				ld (hl),a 
1f54			 
1f54 2a 32 f1			ld hl,(os_tok_ptr) 
1f57			         
1f57			if DEBUG_FORTH_TOK 
1f57						DMARK "Tc1" 
1f57				CALLMONITOR 
1f57			endif 
1f57			 
1f57				; push exec string to top of return stack 
1f57				FORTH_RSP_NEXT 
1f57 cd 4b 1b			call macro_forth_rsp_next 
1f5a				endm 
# End of macro FORTH_RSP_NEXT
1f5a c9				ret 
1f5b			 
1f5b			; Another go at the parser need to simplify the process 
1f5b			 
1f5b			forthparse: 
1f5b			 
1f5b			; 
1f5b			; line parse: 
1f5b			;       parse raw input buffer 
1f5b			;       tokenise the words 
1f5b			;       malloc new copy (for looping etc) 
1f5b			;       copy to malloc + current pc in line to start of string and add line term 
1f5b			;       save on new rsp 
1f5b			; 
1f5b			 
1f5b			; hl to point to the line to tokenise 
1f5b			 
1f5b			;	push hl 
1f5b 22 32 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1f5e			 
1f5e			;	ld a,0		; string term on input 
1f5e			;	call strlent 
1f5e			 
1f5e			;	ld (os_tok_len), hl	 ; save string length 
1f5e			 
1f5e			;if DEBUG_FORTH_TOK 
1f5e			;	ex de,hl		 
1f5e			;endif 
1f5e			 
1f5e			;	pop hl 		; get back string pointer 
1f5e			 
1f5e			if DEBUG_FORTH_TOK 
1f5e						DMARK "TOK" 
1f5e				CALLMONITOR 
1f5e			endif 
1f5e 7e			.ptoken2:    ld a,(hl) 
1f5f 23				inc hl 
1f60 fe 7f			cp FORTH_END_BUFFER 
1f62 28 29			jr z, .ptokendone2 
1f64 fe 00			cp 0 
1f66 28 25			jr z, .ptokendone2 
1f68 fe 22			cp '"' 
1f6a 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f6c fe 20			cp ' ' 
1f6e 20 ee			jr nz,  .ptoken2 
1f70			 
1f70			; TODO consume comments held between ( and ) 
1f70			 
1f70				; we have a space so change to zero term for dict match later 
1f70 2b				dec hl 
1f71 3e 00			ld a,0 
1f73 77				ld (hl), a 
1f74 23				inc hl 
1f75 18 e7			jr .ptoken2 
1f77				 
1f77			 
1f77			.ptokenstr2: 
1f77				; skip all white space until either eol (because forgot to term) or end double quote 
1f77			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f77				;inc hl ; skip current double quote 
1f77 7e				ld a,(hl) 
1f78 23				inc hl 
1f79 fe 22			cp '"' 
1f7b 28 e1			jr z, .ptoken2 
1f7d fe 7f			cp FORTH_END_BUFFER 
1f7f 28 0c			jr z, .ptokendone2 
1f81 fe 00			cp 0 
1f83 28 08			jr z, .ptokendone2 
1f85 fe 20			cp ' ' 
1f87 28 02			jr z, .ptmp2 
1f89 18 ec			jr .ptokenstr2 
1f8b			 
1f8b			.ptmp2:	; we have a space so change to zero term for dict match later 
1f8b				;dec hl 
1f8b				;ld a,"-"	; TODO remove this when working 
1f8b				;ld (hl), a 
1f8b				;inc hl 
1f8b 18 ea			jr .ptokenstr2 
1f8d			 
1f8d			.ptokendone2: 
1f8d				;inc hl 
1f8d 3e 7f			ld a, FORTH_END_BUFFER 
1f8f 77				ld (hl),a 
1f90 23				inc hl 
1f91 3e 21			ld a, '!' 
1f93 77				ld (hl),a 
1f94			 
1f94 2a 32 f1			ld hl,(os_tok_ptr) 
1f97			         
1f97			if DEBUG_FORTH_TOK 
1f97						DMARK "TK1" 
1f97				CALLMONITOR 
1f97			endif 
1f97			 
1f97				; push exec string to top of return stack 
1f97				FORTH_RSP_NEXT 
1f97 cd 4b 1b			call macro_forth_rsp_next 
1f9a				endm 
# End of macro FORTH_RSP_NEXT
1f9a c9				ret 
1f9b			 
1f9b			; 
1f9b			;	; malloc size + buffer pointer + if is loop flag 
1f9b			;	ld hl,(os_tok_len) 		 ; get string length 
1f9b			; 
1f9b			;	ld a,l 
1f9b			; 
1f9b			;	cp 0			; we dont want to use a null string 
1f9b			;	ret z 
1f9b			; 
1f9b			;;	add 3    ; prefix malloc with buffer for current word ptr 
1f9b			; 
1f9b			;	add 5     ; TODO when certain not over writing memory remove 
1f9b			; 
1f9b			;		 
1f9b			; 
1f9b			;if DEBUG_FORTH_TOK 
1f9b			;			DMARK "TKE" 
1f9b			;	CALLMONITOR 
1f9b			;endif 
1f9b			; 
1f9b			;	ld l,a 
1f9b			;	ld h,0 
1f9b			;;	push hl   ; save required space for the copy later 
1f9b			;	call malloc 
1f9b			;if DEBUG_FORTH_TOK 
1f9b			;			DMARK "TKM" 
1f9b			;	CALLMONITOR 
1f9b			;endif 
1f9b			;	if DEBUG_FORTH_MALLOC_GUARD 
1f9b			;		push af 
1f9b			;		call ishlzero 
1f9b			;;		ld a, l 
1f9b			;;		add h 
1f9b			;;		cp 0 
1f9b			;		pop af 
1f9b			;		 
1f9b			;		call z,malloc_error 
1f9b			;	endif 
1f9b			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1f9b			; 
1f9b			; 
1f9b			;if DEBUG_FORTH_TOK 
1f9b			;			DMARK "TKR" 
1f9b			;	CALLMONITOR 
1f9b			;endif 
1f9b			; 
1f9b			;	FORTH_RSP_NEXT 
1f9b			; 
1f9b			;	;inc hl	 ; go past current buffer pointer 
1f9b			;	;inc hl 
1f9b			;	;inc hl   ; and past if loop flag 
1f9b			;		; TODO Need to set flag  
1f9b			; 
1f9b			;	 
1f9b			;	 
1f9b			;	ex de,hl	; malloc is dest 
1f9b			;	ld hl, (os_tok_len) 
1f9b			;;	pop bc 
1f9b			;	ld c, l                
1f9b			;	ld b,0 
1f9b			;	ld hl, (os_tok_ptr) 
1f9b			; 
1f9b			;if DEBUG_FORTH_TOK 
1f9b			;			DMARK "TKT" 
1f9b			;	CALLMONITOR 
1f9b			;endif 
1f9b			; 
1f9b			;	; do str cpy 
1f9b			; 
1f9b			;	ldir      ; copy byte in hl to de 
1f9b			; 
1f9b			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1f9b			; 
1f9b			;if DEBUG_FORTH_TOK 
1f9b			; 
1f9b			;			DMARK "TKY" 
1f9b			;	CALLMONITOR 
1f9b			;endif 
1f9b			;	;ld a,0 
1f9b			;	;ld a,FORTH_END_BUFFER 
1f9b			;	ex de, hl 
1f9b			;	;dec hl			 ; go back over the space delim at the end of word 
1f9b			;	;ld (hl),a 
1f9b			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1f9b			;	ld a,FORTH_END_BUFFER 
1f9b			;	ld (hl),a 
1f9b			;	inc hl 
1f9b			;	ld a,FORTH_END_BUFFER 
1f9b			;	ld (hl),a 
1f9b			; 
1f9b			;	; init the malloc area data 
1f9b			;	; set pc for in current area 
1f9b			;	;ld hl, (os_tok_malloc) 
1f9b			;	;inc hl 
1f9b			;	;inc hl 
1f9b			;	;inc hl 
1f9b			;	;ex de,hl 
1f9b			;	;ld hl, (os_tok_malloc) 
1f9b			;	;ld (hl),e 
1f9b			;	;inc hl 
1f9b			;	;ld (hl),d 
1f9b			; 
1f9b			; 
1f9b			;	ld hl,(os_tok_malloc) 
1f9b			;if DEBUG_FORTH_PARSE_KEY 
1f9b			;			DMARK "TKU" 
1f9b			;	CALLMONITOR 
1f9b			;endif 
1f9b			; 
1f9b			;	ret 
1f9b			 
1f9b			forthexec: 
1f9b			 
1f9b			; line exec: 
1f9b			; forth parser 
1f9b			 
1f9b			; 
1f9b			;       get current exec line on rsp 
1f9b			 
1f9b				FORTH_RSP_TOS 
1f9b cd 62 1b			call macro_forth_rsp_tos 
1f9e				endm 
# End of macro FORTH_RSP_TOS
1f9e			 
1f9e			;       restore current pc - hl points to malloc of data 
1f9e			 
1f9e				;ld e, (hl) 
1f9e				;inc hl 
1f9e				;ld d, (hl) 
1f9e				;ex de,hl 
1f9e			 
1f9e			 
1f9e			exec1: 
1f9e 22 32 f1			ld (os_tok_ptr), hl 
1fa1			 
1fa1				; copy our PC to working vars  
1fa1 22 3c f8			ld (cli_ptr), hl 
1fa4 22 3a f8			ld (cli_origptr), hl 
1fa7			 
1fa7 7e				ld a,(hl) 
1fa8 fe 7f			cp FORTH_END_BUFFER 
1faa c8				ret z 
1fab			 
1fab				; skip any nulls 
1fab			 
1fab fe 00			cp 0 
1fad 20 03			jr nz, .execword 
1faf 23				inc hl 
1fb0 18 ec			jr exec1 
1fb2			 
1fb2			 
1fb2			.execword: 
1fb2			 
1fb2			 
1fb2			 
1fb2			if DEBUG_FORTH_PARSE_KEY 
1fb2						DMARK "KYQ" 
1fb2				CALLMONITOR 
1fb2			endif 
1fb2			;       while at start of word: 
1fb2			; get start of dict (in user area first) 
1fb2			 
1fb2 21 00 80		ld hl, baseram 
1fb5			;ld hl, sysdict 
1fb5 22 3e f8		ld (cli_nextword),hl 
1fb8			;           match word at pc 
1fb8			;           exec word 
1fb8			;           or push to dsp 
1fb8			;           forward to next token 
1fb8			;           if line term pop rsp and exit 
1fb8			;        
1fb8			 
1fb8			if DEBUG_FORTH_PARSE_KEY 
1fb8						DMARK "KYq" 
1fb8				CALLMONITOR 
1fb8			endif 
1fb8			 
1fb8			; 
1fb8			; word comp 
1fb8			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1fb8			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1fb8			;    move to start of word  
1fb8			;    compare word to cli_token 
1fb8			 
1fb8			.execpnword:	; HL at start of a word in the dictionary to check 
1fb8			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1fb8			;	ld (cli_ptr), hl 
1fb8			 
1fb8 2a 3e f8			ld hl,(cli_nextword) 
1fbb			 
1fbb cd 5e 20			call forth_tok_next 
1fbe			; tok next start here 
1fbe			;	; TODO skip compiled symbol for now 
1fbe			;	inc hl 
1fbe			; 
1fbe			;	; save pointer to next word 
1fbe			; 
1fbe			;	; hl now points to the address of the next word pointer  
1fbe			;	ld e, (hl) 
1fbe			;	inc hl 
1fbe			;	ld d, (hl) 
1fbe			;	inc l 
1fbe			; 
1fbe			;	ex de,hl 
1fbe			;if DEBUG_FORTH_PARSE_NEXTWORD 
1fbe			;	push bc 
1fbe			;	ld bc, (cli_nextword) 
1fbe			;			DMARK "NXW" 
1fbe			;	CALLMONITOR 
1fbe			;	pop bc 
1fbe			;endif 
1fbe			; tok next end here 
1fbe 22 3e f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
1fc1 eb				ex de, hl 
1fc2			 
1fc2			 
1fc2				; save the pointer of the current token - 1 to check against 
1fc2				 
1fc2 22 42 f8			ld (cli_token), hl   
1fc5				; TODO maybe remove below save if no debug 
1fc5				; save token string ptr for any debug later 
1fc5 23				inc hl  
1fc6 22 44 f8			ld (cli_origtoken), hl 
1fc9 2b				dec hl 
1fca				; save pointer to the start of the next dictionay word 
1fca 7e				ld a,(hl)   ; get string length 
1fcb 47				ld b,a 
1fcc			.execpnwordinc:  
1fcc 23				inc hl 
1fcd 10 fd			djnz .execpnwordinc 
1fcf 22 40 f8			ld (cli_execword), hl      ; save start of this words code 
1fd2			 
1fd2				; now check the word token against the string being parsed 
1fd2			 
1fd2 2a 42 f8			ld hl,(cli_token) 
1fd5 23				inc hl     ; skip string length (use zero term instead to end) 
1fd6 22 42 f8			ld (cli_token), hl 
1fd9			 
1fd9			if DEBUG_FORTH_PARSE_KEY 
1fd9						DMARK "KY2" 
1fd9			endif 
1fd9			if DEBUG_FORTH_PARSE_EXEC 
1fd9				; see if disabled 
1fd9			 
1fd9				ld a, (os_view_disable) 
1fd9				cp '*' 
1fd9				jr z, .skip 
1fd9			 
1fd9				push hl 
1fd9				push hl 
1fd9				call clear_display 
1fd9				ld de, .compword 
1fd9				ld a, display_row_1 
1fd9				call str_at_display 
1fd9				pop de 
1fd9				ld a, display_row_2 
1fd9				call str_at_display 
1fd9				ld hl,(cli_ptr) 
1fd9				ld a,(hl) 
1fd9			        ld hl, os_word_scratch 
1fd9				ld (hl),a 
1fd9				ld a,0 
1fd9				inc hl 
1fd9				ld (hl),a 	 
1fd9				ld de, os_word_scratch 
1fd9				ld a, display_row_2+10 
1fd9				call str_at_display 
1fd9				call update_display 
1fd9				ld a, 100 
1fd9				call aDelayInMS 
1fd9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1fd9				call delay250ms 
1fd9				endif 
1fd9				pop hl 
1fd9			.skip:  
1fd9			endif	 
1fd9			.execpnchar:    ; compare char between token and string to parse 
1fd9			 
1fd9			if DEBUG_FORTH_PARSE_KEY 
1fd9						DMARK "Ky3" 
1fd9			endif 
1fd9			if DEBUG_FORTH_PARSE_EXEC 
1fd9				; see if disabled 
1fd9			 
1fd9				ld a, (os_view_disable) 
1fd9				cp '*' 
1fd9				jr z, .skip2 
1fd9			 
1fd9			;	call clear_display 
1fd9			ld hl,(cli_token) 
1fd9			ld a,(hl) 
1fd9			ld (os_word_scratch),a 
1fd9				ld hl,(cli_ptr) 
1fd9			ld a,(hl) 
1fd9				ld (os_word_scratch+1),a 
1fd9				ld a,0 
1fd9				ld (os_word_scratch+2),a 
1fd9				ld de,os_word_scratch 
1fd9				ld a,display_row_4 
1fd9				call str_at_display 
1fd9				call update_display 
1fd9			.skip2:  
1fd9			endif 
1fd9 2a 42 f8			ld hl,(cli_token) 
1fdc 7e				ld a, (hl)	 ; char in word token 
1fdd 23				inc hl 		; move to next char 
1fde 22 42 f8			ld (cli_token), hl ; and save it 
1fe1 47				ld b,a 
1fe2			 
1fe2 2a 3c f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
1fe5 7e				ld a,(hl) 
1fe6 23				inc hl 
1fe7 22 3c f8			ld (cli_ptr), hl		; move to next char 
1fea cd 20 11			call toUpper 		; make sure the input string matches case 
1fed			 
1fed			if DEBUG_FORTH_PARSE 
1fed			endif 
1fed			 
1fed				; input stream end of token is a space so get rid of it 
1fed			 
1fed			;	cp ' ' 
1fed			;	jr nz, .pnskipspace 
1fed			; 
1fed			;	ld a, 0		; make same term as word token term 
1fed			; 
1fed			;.pnskipspace: 
1fed			 
1fed			if DEBUG_FORTH_PARSE_KEY 
1fed						DMARK "KY7" 
1fed			endif 
1fed b8				cp b 
1fee c2 04 20			jp nz, .execpnskipword	 ; no match so move to next word 
1ff1				 
1ff1			;    if same 
1ff1			;       scan for string terms 0 for token and 32 for input 
1ff1			 
1ff1				 
1ff1			if DEBUG_FORTH_PARSE_KEY 
1ff1						DMARK "KY8" 
1ff1			endif 
1ff1			 
1ff1 80				add b			 
1ff2 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1ff4							; TODO need to make sure last word in zero term string is accounted for 
1ff4 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1ff6			 
1ff6			 
1ff6				; at end of both strings so both are exact match 
1ff6			 
1ff6			;       skip ptr for next word 
1ff6			 
1ff6 2a 3c f8			ld hl,(cli_ptr) 	; at input string term 
1ff9 23				inc hl			 ; at next char 
1ffa 22 3c f8			ld (cli_ptr), hl     ; save for next round of the parser 
1ffd 22 3a f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2000				 
2000				 
2000			if DEBUG_FORTH_PARSE_KEY 
2000						DMARK "KY3" 
2000			endif 
2000			 
2000			 
2000			 
2000			;       exec code block 
2000			if DEBUG_FORTH_JP 
2000				call clear_display 
2000				call update_display 
2000				call delay1s 
2000				ld hl, (cli_execword)     ; save for next check if no match on this word 
2000				ld a,h 
2000				ld hl, os_word_scratch 
2000				call hexout 
2000				ld hl, (cli_execword)     ; save for next check if no match on this word 
2000				ld a,l 
2000				ld hl, os_word_scratch+2 
2000				call hexout 
2000				ld hl, os_word_scratch+4 
2000				ld a,0 
2000				ld (hl),a 
2000				ld de,os_word_scratch 
2000				call str_at_display 
2000					ld a, display_row_2 
2000					call str_at_display 
2000				ld de, (cli_origtoken) 
2000				ld a, display_row_1+10 
2000					call str_at_display 
2000			 
2000				ld a,display_row_1 
2000				ld de, .foundword 
2000				ld a, display_row_3 
2000				call str_at_display 
2000				call update_display 
2000				call delay1s 
2000				call delay1s 
2000				call delay1s 
2000			endif 
2000			 
2000			if DEBUG_FORTH_PARSE_KEY 
2000						DMARK "KYj" 
2000			endif 
2000				; TODO save the word pointer in this exec 
2000			 
2000 2a 40 f8			ld hl,(cli_execword) 
2003 e9				jp (hl) 
2004			 
2004			 
2004			;    if not same 
2004			;	scan for zero term 
2004			;	get ptr for next word 
2004			;	goto word comp 
2004			 
2004			.execpnskipword:	; get pointer to next word 
2004 2a 3e f8			ld hl,(cli_nextword) 
2007			 
2007 7e				ld a,(hl) 
2008 fe 00			cp WORD_SYS_END 
200a			;	cp 0 
200a 28 09			jr z, .execendofdict			 ; at end of words 
200c			 
200c			if DEBUG_FORTH_PARSE_KEY 
200c						DMARK "KY4" 
200c			endif 
200c			if DEBUG_FORTH_PARSE_EXEC 
200c			 
200c				; see if disabled 
200c			 
200c				ld a, (os_view_disable) 
200c				cp '*' 
200c				jr z, .noskip 
200c			 
200c			 
200c				ld de, .nowordfound 
200c				ld a, display_row_3 
200c				call str_at_display 
200c				call update_display 
200c				ld a, 100 
200c				call aDelayInMS 
200c				 
200c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
200c					call delay250ms 
200c				endif 
200c			.noskip:  
200c			 
200c			endif	 
200c			 
200c 2a 3a f8			ld hl,(cli_origptr) 
200f 22 3c f8			ld (cli_ptr),hl 
2012			 
2012			if DEBUG_FORTH_PARSE_KEY 
2012						DMARK "KY5" 
2012			endif 
2012 c3 b8 1f			jp .execpnword			; else go to next word 
2015			 
2015			.execendofdict:  
2015			 
2015			if DEBUG_FORTH_PARSE_KEY 
2015						DMARK "KYe" 
2015			endif 
2015			if DEBUG_FORTH_PARSE_EXEC 
2015				; see if disabled 
2015			 
2015				ld a, (os_view_disable) 
2015				cp '*' 
2015				jr z, .ispskip 
2015			 
2015				call clear_display 
2015				call update_display 
2015				call delay1s 
2015				ld de, (cli_origptr) 
2015				ld a, display_row_1 
2015				call str_at_display 
2015				 
2015				ld de, .enddict 
2015				ld a, display_row_3 
2015				call str_at_display 
2015				call update_display 
2015				ld a, 100 
2015				call aDelayInMS 
2015				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2015				call delay1s 
2015				call delay1s 
2015				call delay1s 
2015				endif 
2015			.ispskip:  
2015				 
2015			endif	 
2015			 
2015			 
2015			 
2015				; if the word is not a keyword then must be a literal so push it to stack 
2015			 
2015			; push token to stack to end of word 
2015			 
2015				STACKFRAME ON $1efe $2f9f 
2015				if DEBUG_STACK_IMB 
2015					if ON 
2015						exx 
2015						ld de, $1efe 
2015						ld a, d 
2015						ld hl, curframe 
2015						call hexout 
2015						ld a, e 
2015						ld hl, curframe+2 
2015						call hexout 
2015						ld hl, $1efe 
2015						push hl 
2015						ld hl, $2f9f 
2015						push hl 
2015						exx 
2015					endif 
2015				endif 
2015			endm 
# End of macro STACKFRAME
2015			 
2015 2a 32 f1		ld hl,(os_tok_ptr) 
2018 cd 0d 1d		call forth_apush 
201b			 
201b				STACKFRAMECHK ON $1efe $2f9f 
201b				if DEBUG_STACK_IMB 
201b					if ON 
201b						exx 
201b						ld hl, $2f9f 
201b						pop de   ; $2f9f 
201b						call cmp16 
201b						jr nz, .spnosame 
201b						ld hl, $1efe 
201b						pop de   ; $1efe 
201b						call cmp16 
201b						jr z, .spfrsame 
201b						.spnosame: call showsperror 
201b						.spfrsame: nop 
201b						exx 
201b					endif 
201b				endif 
201b			endm 
# End of macro STACKFRAMECHK
201b			 
201b			execnext: 
201b			 
201b			if DEBUG_FORTH_PARSE_KEY 
201b						DMARK "KY>" 
201b			endif 
201b			; move past token to next word 
201b			 
201b 2a 32 f1		ld hl, (os_tok_ptr) 
201e 3e 00		ld a, 0 
2020 01 ff 00		ld bc, 255     ; input buffer size 
2023 ed b1		cpir 
2025			 
2025			if DEBUG_FORTH_PARSE_KEY 
2025						DMARK "KY!" 
2025				CALLMONITOR 
2025			endif	 
2025			; TODO this might place hl on the null, so will need to forward on??? 
2025			;inc hl   ; see if this gets onto the next item 
2025			 
2025			 
2025			; TODO pass a pointer to the buffer to push 
2025			; TODO call function to push 
2025			 
2025			; look for end of input 
2025			 
2025			;inc hl 
2025			;ld a,(hl) 
2025			;cp FORTH_END_BUFFER 
2025			;ret z 
2025			 
2025			 
2025 c3 9e 1f		jp exec1 
2028			 
2028			 
2028			 
2028			 
2028			 
2028			 
2028			 
2028			 
2028			 
2028			findnexttok: 
2028			 
2028				; hl is pointer to move 
2028				; de is the token to locate 
2028			 
2028					if DEBUG_FORTH 
2028						DMARK "NTK" 
2028						CALLMONITOR 
2028					endif 
2028 d5				push de 
2029			 
2029			.fnt1:	 
2029				; find first char of token to locate 
2029			 
2029 1a				ld a, (de) 
202a 4f				ld c,a 
202b 7e				ld a,(hl) 
202c cd 20 11			call toUpper 
202f					if DEBUG_FORTH 
202f						DMARK "NT1" 
202f						CALLMONITOR 
202f					endif 
202f b9				cp c 
2030			 
2030 28 03			jr z, .fnt2cmpmorefirst	 
2032			 
2032				; first char not found move to next char 
2032			 
2032 23				inc hl 
2033 18 f4			jr .fnt1 
2035			 
2035			.fnt2cmpmorefirst:	 
2035				; first char of token found.  
2035			 
2035 e5				push hl     ; save start of token just in case it is the right one 
2036 d9				exx 
2037 e1				pop hl        ; save it to hl' 
2038 d9				exx 
2039			 
2039			 
2039			.fnt2cmpmore:	 
2039				; compare the rest 
2039				 
2039 23				inc hl 
203a 13				inc de 
203b				 
203b 1a				ld a, (de) 
203c 4f				ld c,a 
203d 7e				ld a,(hl) 
203e cd 20 11			call toUpper 
2041			 
2041					if DEBUG_FORTH 
2041						DMARK "NT2" 
2041						CALLMONITOR 
2041					endif 
2041				; c has the token to find char 
2041				; a has the mem to scan char 
2041			 
2041 b9				cp c 
2042 28 04			jr z,.fntmatch1 
2044			 
2044				; they are not the same 
2044			 
2044					if DEBUG_FORTH 
2044						DMARK "NT3" 
2044						CALLMONITOR 
2044					endif 
2044 d1				pop de	; reset de token to look for 
2045 d5				push de 
2046 18 e1			jr .fnt1 
2048				 
2048			.fntmatch1: 
2048			 
2048				; is the same char a null which means we might have a full hit? 
2048					if DEBUG_FORTH 
2048						DMARK "NT4" 
2048						CALLMONITOR 
2048					endif 
2048			 
2048 fe 00			cp 0 
204a 28 0b			jr z, .fntmatchyes 
204c			 
204c				; are we at the end of the token to find? 
204c			 
204c					if DEBUG_FORTH 
204c						DMARK "NT5" 
204c						CALLMONITOR 
204c					endif 
204c 3e 00			ld a, 0 
204e b9				cp c 
204f			 
204f c2 39 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2052			 
2052					if DEBUG_FORTH 
2052						DMARK "NT6" 
2052						CALLMONITOR 
2052					endif 
2052				; token to find is exhusted but no match to stream 
2052			 
2052				; restore tok pointer and continue on 
2052 d1				pop de 
2053 d5				push de 
2054 c3 29 20			jp .fnt1 
2057			 
2057			 
2057			.fntmatchyes: 
2057			 
2057				; hl now contains the end of the found token 
2057			 
2057				; get rid of saved token pointer to find 
2057			 
2057 d1				pop de 
2058			 
2058					if DEBUG_FORTH 
2058						DMARK "NT9" 
2058						CALLMONITOR 
2058					endif 
2058			 
2058				; hl will be on the null term so forward on 
2058			 
2058				; get back the saved start of the token 
2058			 
2058 d9				exx 
2059 e5				push hl     ; save start of token just in case it is the right one 
205a d9				exx 
205b e1				pop hl        ; save it to hl 
205c			 
205c c9				ret 
205d			 
205d			 
205d			; LIST needs to find a specific token   
205d			; FORGET needs to find a spefici token 
205d			 
205d			; SAVE needs to find all tokens by flag 
205d			; WORDS just needs to scan through all  by flag 
205d			; UWORDS needs to scan through all by flag 
205d			 
205d			 
205d			; given hl as pointer to start of dict look up string 
205d			; return hl as pointer to start of word block 
205d			; or 0 if not found 
205d			 
205d			forth_find_tok: 
205d c9				ret 
205e			 
205e			; given hl as pointer to dict structure 
205e			; move to the next dict block structure 
205e			 
205e			forth_tok_next: 
205e				; hl now points to the address of the next word pointer  
205e				; TODO skip compiled symbol for now 
205e			;	push de 
205e 23				inc hl 
205f 5e				ld e, (hl) 
2060 23				inc hl 
2061 56				ld d, (hl) 
2062 23				inc hl 
2063			 
2063 eb				ex de,hl 
2064			if DEBUG_FORTH_PARSE_NEXTWORD 
2064				push bc 
2064				ld bc, (cli_nextword) 
2064						DMARK "NXW" 
2064				CALLMONITOR 
2064				pop bc 
2064			endif 
2064			;	pop de	 
2064 c9				ret 
2065			 
2065			 
2065			 
2065			; eof 
# End of file forth_parserv5.asm
2065				include "forth_wordsv4.asm" 
2065			 
2065			; the core word dictionary v4 
2065			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2065			 
2065			; this is a linked list for each of the system words used 
2065			; user defined words will follow the same format but will be in ram 
2065			 
2065			 
2065			; 
2065			; 
2065			; define linked list: 
2065			; 
2065			; 1. compiled byte op code 
2065			; 2. len of text word 
2065			; 3. text word 
2065			; 4. ptr to next dictionary word 
2065			; 5. asm, calls etc for the word 
2065			; 
2065			;  if 1 == 0 then last word in dict  
2065			;   
2065			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2065			;  
2065			;  
2065			; create basic standard set of words 
2065			; 
2065			;  
2065			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2065			; 2DUP 2DROP 2SWAP  
2065			; @ C@ - get byte  
2065			; ! C! - store byte 
2065			; 0< true if less than zero 
2065			; 0= true if zero 
2065			; < >  
2065			; = true if same 
2065			; variables 
2065			 
2065			 
2065			; Hardware specific words I may need 
2065			; 
2065			; IN OUT  
2065			; calls to key util functions 
2065			; calls to hardward abstraction stuff 
2065			; easy control of frame buffers and lcd i/o 
2065			; keyboard  
2065			 
2065			 
2065			;DICT: macro 
2065			; op_code, len, word, next 
2065			;    word: 
2065			;    db op_code 
2065			;    ds word zero term 
2065			;    dw next 
2065			;    endm 
2065			 
2065			 
2065			 
2065			 
2065			; op code 1 is a flag for user define words which are to be handled differently 
2065			 
2065			 
2065			; 
2065			; 
2065			;    TODO on entry to a word this should be the expected environment 
2065			;    hl - tos value if number then held, if string this is the ptr 
2065			;    de -  
2065			 
2065			 
2065			; opcode ranges 
2065			; 0 - end of word dict 
2065			; 255 - user define words 
2065			 
2065			sysdict: 
2065			include "forth_opcodes.asm" 
2065			; op codes for forth keywords 
2065			; free to use code 0  
2065				OPCODE_HEAP: equ  1 
2065				OPCODE_EXEC: equ 2 
2065				OPCODE_DUP: equ 3 
2065				OPCODE_SWAP: equ 4 
2065				OPCODE_COLN: equ 5 
2065				OPCODE_SCOLN: equ 6 
2065				OPCODE_DROP: equ 7 
2065				OPCODE_DUP2: equ 8 
2065				OPCODE_DROP2: equ 9 
2065				OPCODE_SWAP2: equ 10 
2065				OPCODE_AT: equ 11 
2065				OPCODE_CAT: equ 12 
2065				OPCODE_BANG: equ 13 
2065				OPCODE_CBANG: equ 14 
2065				OPCODE_SCALL: equ 15 
2065				OPCODE_DEPTH: equ 16 
2065				OPCODE_OVER: equ 17 
2065				OPCODE_PAUSE: equ 18 
2065				OPCODE_PAUSES: equ 19 
2065				OPCODE_ROT: equ 20 
2065			;free to reuse	OPCODE_WORDS: equ 21 
2065			        OPCODE_NOT: equ 21 
2065				OPCODE_UWORDS: equ 22 
2065				OPCODE_BP: equ 23 
2065				OPCODE_MONITOR: equ 24  
2065				OPCODE_MALLOC: equ 25 
2065				OPCODE_FREE: equ 26 
2065				OPCODE_LIST: equ 27 
2065				OPCODE_FORGET: equ 28 
2065				OPCODE_NOP: equ 29 
2065				OPCODE_COMO: equ 30 
2065				OPCODE_COMC: equ 31 
2065			;free to reuse	OPCODE_ENDCORE: equ 32 
2065				OPCODE_AFTERSOUND: equ 33 
2065				OPCODE_GP2: equ 34 
2065				OPCODE_GP3: equ 35 
2065				OPCODE_GP4: equ 36 
2065				OPCODE_SIN: equ 37 
2065				OPCODE_SOUT: equ 38 
2065				OPCODE_SPIO: equ 39 
2065				OPCODE_SPICEH: equ 40 
2065				OPCODE_SPIOb: equ 41 
2065				OPCODE_SPII: equ 42 
2065				OPCODE_SESEL: equ 43 
2065				OPCODE_CARTDEV: equ 44 
2065			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2065				OPCODE_FB: equ 46 
2065				OPCODE_EMIT: equ 47 
2065				OPCODE_DOTH: equ 48 
2065				OPCODE_DOTF: equ 49 
2065				OPCODE_DOT: equ 50 
2065				OPCODE_CLS: equ 51 
2065				OPCODE_DRAW: equ 52 
2065				OPCODE_DUMP: equ 53 
2065				OPCODE_CDUMP: equ 54 
2065				OPCODE_DAT: equ 55 
2065				OPCODE_HOME: equ 56 
2065				OPCODE_SPACE: equ 57 
2065				OPCODE_SPACES: equ 58 
2065				OPCODE_SCROLL: equ 59 
2065				OPCODE_ATQ: equ 60 
2065				OPCODE_AUTODSP: equ 61 
2065				OPCODE_MENU: equ 62 
2065			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2065				OPCODE_THEN: equ 64 
2065				OPCODE_ELSE: equ 65 
2065				OPCODE_DO: equ 66 
2065				OPCODE_LOOP: equ 67 
2065				OPCODE_I: equ 68 
2065				OPCODE_DLOOP: equ 69  
2065				OPCODE_REPEAT: equ 70  
2065				OPCODE_UNTIL: equ 71 
2065				OPCODE_ENDFLOW: equ 72 
2065				OPCODE_WAITK: equ 73 
2065				OPCODE_ACCEPT: equ 74 
2065				OPCODE_EDIT: equ 75 
2065			;free to reuse	OPCODE_ENDKEY: equ 76 
2065				OPCODE_LZERO: equ 77 
2065				OPCODE_TZERO: equ 78 
2065				OPCODE_LESS: equ 79 
2065				OPCODE_GT: equ 80 
2065				OPCODE_EQUAL: equ 81  
2065			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2065				OPCODE_NEG: equ 83 
2065				OPCODE_DIV: equ 84 
2065				OPCODE_MUL: equ 85 
2065				OPCODE_MIN: equ 86 
2065				OPCODE_MAX: equ 87 
2065				OPCODE_RND16: equ 88 
2065				OPCODE_RND8: equ 89 
2065				OPCODE_RND: equ 90 
2065			;free to reuse	OPCODE_ENDMATHS: equ 91  
2065				OPCODE_BYNAME: equ 92 
2065				OPCODE_DIR: equ 93 
2065				OPCODE_SAVE: equ 94 
2065				OPCODE_LOAD: equ 95 
2065				OPCODE_BSAVE: equ 96 
2065				OPCODE_BLOAD: equ 97 
2065				OPCODE_SEO: equ 98  
2065				OPCODE_SEI: equ 99 
2065				OPCODE_SFREE: equ 100 
2065				OPCODE_SIZE: equ 101 
2065				OPCODE_CREATE: equ 102 
2065				OPCODE_APPEND: equ 103 
2065				OPCODE_SDEL: equ 104 
2065				OPCODE_OPEN: equ 105 
2065				OPCODE_READ: equ 106 
2065				OPCODE_EOF: equ 106 
2065				OPCODE_FORMAT: equ 107 
2065				OPCODE_LABEL: equ 108 
2065				OPCODE_LABELS: equ 109 
2065			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2065				OPCODE_UPPER: equ 111 
2065				OPCODE_LOWER: equ 112 
2065				OPCODE_SUBSTR: equ 113 
2065				OPCODE_LEFT: equ 114 
2065				OPCODE_RIGHT: equ 115 
2065				OPCODE_STR2NUM: equ 116 
2065				OPCODE_NUM2STR: equ 117 
2065				OPCODE_CONCAT: equ 118 
2065				OPCODE_FIND: equ 119 
2065				OPCODE_LEN: equ 120 
2065				OPCODE_CHAR: equ 121 
2065			; free to reuse	OPCODE_STRLEN: equ 122 
2065			; free to reuse	OPCODE_ENDSTR: equ 123 
2065				OPCODE_V0S: equ 124 
2065				OPCODE_V0Q: equ 125 
2065				OPCODE_V1S: equ 126 
2065				OPCODE_V1Q: equ 127 
2065				OPCODE_V2S: equ 128 
2065				OPCODE_V2Q: equ 129 
2065				OPCODE_V3S: equ 130 
2065				OPCODE_V3Q: equ 131 
2065			;free to reuse	OPCODE_END: equ 132 
2065				OPCODE_ZDUP: equ 133 
2065			 
2065			; eof 
# End of file forth_opcodes.asm
2065			 
2065			include "forth_words_core.asm" 
2065			 
2065			; | ## Core Words 
2065			 
2065			;if MALLOC_4 
2065			 
2065			.HEAP: 
2065				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2065 15				db WORD_SYS_CORE+OPCODE_HEAP             
2066 a4 20			dw .EXEC            
2068 05				db 4 + 1 
2069 .. 00			db "HEAP",0              
206e				endm 
# End of macro CWHEAD
206e			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
206e			; | | u1 - Current number of bytes in the heap 
206e			; | | u2 - Remaining bytes left on the heap 
206e			; | |  
206e			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
206e			 
206e			 
206e					if DEBUG_FORTH_WORDS_KEY 
206e						DMARK "HEP" 
206e f5				push af  
206f 3a 83 20			ld a, (.dmark)  
2072 32 77 fb			ld (debug_mark),a  
2075 3a 84 20			ld a, (.dmark+1)  
2078 32 78 fb			ld (debug_mark+1),a  
207b 3a 85 20			ld a, (.dmark+2)  
207e 32 79 fb			ld (debug_mark+2),a  
2081 18 03			jr .pastdmark  
2083 ..			.dmark: db "HEP"  
2086 f1			.pastdmark: pop af  
2087			endm  
# End of macro DMARK
2087						CALLMONITOR 
2087 cd 17 16			call break_point_state  
208a				endm  
# End of macro CALLMONITOR
208a					endif 
208a 2a 0a 80				ld hl, (free_list )      
208d 11 0e 80				ld de, heap_start 
2090			 
2090 ed 52				sbc hl, de  
2092			 
2092 cd a4 1b				call forth_push_numhl 
2095			 
2095			 
2095 ed 5b 0a 80			ld de, (free_list )      
2099 21 25 ee				ld hl, heap_end 
209c			 
209c ed 52				sbc hl, de 
209e			 
209e cd a4 1b				call forth_push_numhl 
20a1					 
20a1			 
20a1					 
20a1			 
20a1			 
20a1			 
20a1					NEXTW 
20a1 c3 0d 1f			jp macro_next 
20a4				endm 
# End of macro NEXTW
20a4			;endif 
20a4			 
20a4			.EXEC: 
20a4				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20a4 16				db WORD_SYS_CORE+OPCODE_EXEC             
20a5 40 21			dw .STKEXEC            
20a7 05				db 4 + 1 
20a8 .. 00			db "EXEC",0              
20ad				endm 
# End of macro CWHEAD
20ad			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
20ad			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
20ad			; | | 
20ad			; | |   
20ad				STACKFRAME OFF $5efe $5f9f 
20ad				if DEBUG_STACK_IMB 
20ad					if OFF 
20ad						exx 
20ad						ld de, $5efe 
20ad						ld a, d 
20ad						ld hl, curframe 
20ad						call hexout 
20ad						ld a, e 
20ad						ld hl, curframe+2 
20ad						call hexout 
20ad						ld hl, $5efe 
20ad						push hl 
20ad						ld hl, $5f9f 
20ad						push hl 
20ad						exx 
20ad					endif 
20ad				endif 
20ad			endm 
# End of macro STACKFRAME
20ad			 
20ad					if DEBUG_FORTH_WORDS_KEY 
20ad						DMARK "EXE" 
20ad f5				push af  
20ae 3a c2 20			ld a, (.dmark)  
20b1 32 77 fb			ld (debug_mark),a  
20b4 3a c3 20			ld a, (.dmark+1)  
20b7 32 78 fb			ld (debug_mark+1),a  
20ba 3a c4 20			ld a, (.dmark+2)  
20bd 32 79 fb			ld (debug_mark+2),a  
20c0 18 03			jr .pastdmark  
20c2 ..			.dmark: db "EXE"  
20c5 f1			.pastdmark: pop af  
20c6			endm  
# End of macro DMARK
20c6						CALLMONITOR 
20c6 cd 17 16			call break_point_state  
20c9				endm  
# End of macro CALLMONITOR
20c9					endif 
20c9			 
20c9				FORTH_DSP_VALUEHL 
20c9 cd 9b 1d			call macro_dsp_valuehl 
20cc				endm 
# End of macro FORTH_DSP_VALUEHL
20cc			 
20cc				FORTH_DSP_POP 
20cc cd 53 1e			call macro_forth_dsp_pop 
20cf				endm 
# End of macro FORTH_DSP_POP
20cf			 
20cf					if DEBUG_FORTH_WORDS 
20cf						DMARK "EX1" 
20cf f5				push af  
20d0 3a e4 20			ld a, (.dmark)  
20d3 32 77 fb			ld (debug_mark),a  
20d6 3a e5 20			ld a, (.dmark+1)  
20d9 32 78 fb			ld (debug_mark+1),a  
20dc 3a e6 20			ld a, (.dmark+2)  
20df 32 79 fb			ld (debug_mark+2),a  
20e2 18 03			jr .pastdmark  
20e4 ..			.dmark: db "EX1"  
20e7 f1			.pastdmark: pop af  
20e8			endm  
# End of macro DMARK
20e8						CALLMONITOR 
20e8 cd 17 16			call break_point_state  
20eb				endm  
# End of macro CALLMONITOR
20eb					endif 
20eb			;	ld e,(hl) 
20eb			;	inc hl 
20eb			;	ld d,(hl) 
20eb			;	ex de,hl 
20eb			 
20eb			;		if DEBUG_FORTH_WORDS 
20eb			;			DMARK "EX2" 
20eb			;			CALLMONITOR 
20eb			;		endif 
20eb e5				push hl 
20ec			 
20ec				;ld a, 0 
20ec				;ld a, FORTH_END_BUFFER 
20ec cd 29 11			call strlenz 
20ef 23				inc hl   ; include zero term to copy 
20f0 23				inc hl   ; include term 
20f1 23				inc hl   ; include term 
20f2 06 00			ld b,0 
20f4 4d				ld c,l 
20f5 e1				pop hl 
20f6 11 30 ef			ld de, execscratch 
20f9					if DEBUG_FORTH_WORDS 
20f9						DMARK "EX3" 
20f9 f5				push af  
20fa 3a 0e 21			ld a, (.dmark)  
20fd 32 77 fb			ld (debug_mark),a  
2100 3a 0f 21			ld a, (.dmark+1)  
2103 32 78 fb			ld (debug_mark+1),a  
2106 3a 10 21			ld a, (.dmark+2)  
2109 32 79 fb			ld (debug_mark+2),a  
210c 18 03			jr .pastdmark  
210e ..			.dmark: db "EX3"  
2111 f1			.pastdmark: pop af  
2112			endm  
# End of macro DMARK
2112						CALLMONITOR 
2112 cd 17 16			call break_point_state  
2115				endm  
# End of macro CALLMONITOR
2115					endif 
2115 ed b0			ldir 
2117			 
2117			 
2117 21 30 ef			ld hl, execscratch 
211a			 
211a					if DEBUG_FORTH_WORDS 
211a						DMARK "EXe" 
211a f5				push af  
211b 3a 2f 21			ld a, (.dmark)  
211e 32 77 fb			ld (debug_mark),a  
2121 3a 30 21			ld a, (.dmark+1)  
2124 32 78 fb			ld (debug_mark+1),a  
2127 3a 31 21			ld a, (.dmark+2)  
212a 32 79 fb			ld (debug_mark+2),a  
212d 18 03			jr .pastdmark  
212f ..			.dmark: db "EXe"  
2132 f1			.pastdmark: pop af  
2133			endm  
# End of macro DMARK
2133						CALLMONITOR 
2133 cd 17 16			call break_point_state  
2136				endm  
# End of macro CALLMONITOR
2136					endif 
2136			 
2136 cd 5b 1f			call forthparse 
2139 cd 9b 1f			call forthexec 
213c			;	call forthexec_cleanup 
213c			;	call forthparse 
213c			;	call forthexec 
213c			 
213c				STACKFRAMECHK OFF $5efe $5f9f 
213c				if DEBUG_STACK_IMB 
213c					if OFF 
213c						exx 
213c						ld hl, $5f9f 
213c						pop de   ; $5f9f 
213c						call cmp16 
213c						jr nz, .spnosame 
213c						ld hl, $5efe 
213c						pop de   ; $5efe 
213c						call cmp16 
213c						jr z, .spfrsame 
213c						.spnosame: call showsperror 
213c						.spfrsame: nop 
213c						exx 
213c					endif 
213c				endif 
213c			endm 
# End of macro STACKFRAMECHK
213c			 
213c				; an immediate word so no need to process any more words 
213c c9				ret 
213d				NEXTW 
213d c3 0d 1f			jp macro_next 
2140				endm 
# End of macro NEXTW
2140			 
2140			; dead code - old version  
2140			;	FORTH_RSP_NEXT 
2140			 
2140			;  
2140			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2140			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2140			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2140			;	push hl 
2140			;	push de 
2140			;	push bc 
2140			; 
2140			; 
2140			;		if DEBUG_FORTH_WORDS_KEY 
2140			;			DMARK "EXR" 
2140			;			CALLMONITOR 
2140			;		endif 
2140			; 
2140			; 
2140			; 
2140			;	;v5 FORTH_DSP_VALUE 
2140			;	FORTH_DSP_VALUEHL 
2140			; 
2140			;	; TODO do string type checks 
2140			; 
2140			;;v5	inc hl   ; skip type 
2140			; 
2140			;	push hl  ; source code  
2140			;		if DEBUG_FORTH_WORDS 
2140			;			DMARK "EX1" 
2140			;			CALLMONITOR 
2140			;		endif 
2140			;	ld a, 0 
2140			;	call strlent 
2140			; 
2140			;	inc hl 
2140			;	inc hl 
2140			;	inc hl 
2140			;	inc hl 
2140			; 
2140			;	push hl    ; size 
2140			; 
2140			;		if DEBUG_FORTH_WORDS 
2140			;			DMARK "EX2" 
2140			;			CALLMONITOR 
2140			;		endif 
2140			;	call malloc 
2140			; 
2140			;	ex de, hl    ; de now contains malloc area 
2140			;	pop bc   	; get byte count 
2140			;	pop hl      ; get string to copy 
2140			; 
2140			;	push de     ; save malloc for free later 
2140			; 
2140			;		if DEBUG_FORTH_WORDS 
2140			;			DMARK "EX3" 
2140			;			CALLMONITOR 
2140			;		endif 
2140			;	ldir       ; duplicate string 
2140			; 
2140			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2140			;	 
2140			;	; TODO fix the parse would be better than this...  
2140			;	ex de, hl 
2140			;	dec hl 
2140			;	ld a, 0 
2140			;	ld (hl), a 
2140			;	dec hl 
2140			;	ld a, ' ' 
2140			;	ld (hl), a 
2140			;	dec hl 
2140			;	ld (hl), a 
2140			; 
2140			;	dec hl 
2140			;	ld (hl), a 
2140			; 
2140			; 
2140			;	FORTH_DSP_POP  
2140			; 
2140			;	pop hl     
2140			;	push hl    ; save malloc area 
2140			; 
2140			;		if DEBUG_FORTH_WORDS 
2140			;			DMARK "EX4" 
2140			;			CALLMONITOR 
2140			;		endif 
2140			; 
2140			;	call forthparse 
2140			;	call forthexec 
2140			;	 
2140			;	pop hl 
2140			;	if DEBUG_FORTH_WORDS 
2140			;		DMARK "EX5" 
2140			;		CALLMONITOR 
2140			;	endif 
2140			; 
2140			;	if FORTH_ENABLE_FREE 
2140			;	call free 
2140			;	endif 
2140			; 
2140			;	if DEBUG_FORTH_WORDS 
2140			;		DMARK "EX6" 
2140			;		CALLMONITOR 
2140			;	endif 
2140			; 
2140			;	pop bc 
2140			;	pop de 
2140			;	pop hl 
2140			;;	FORTH_RSP_POP	  
2140			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2140			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2140			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2140			; 
2140			;	if DEBUG_FORTH_WORDS 
2140			;		DMARK "EX7" 
2140			;		CALLMONITOR 
2140			;	endif 
2140			;	NEXTW 
2140			 
2140			.STKEXEC: 
2140				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2140 3f				db WORD_SYS_CORE+43             
2141 88 22			dw .ZDUP            
2143 08				db 7 + 1 
2144 .. 00			db "STKEXEC",0              
214c				endm 
# End of macro CWHEAD
214c			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
214c			 
214c			 
214c					if DEBUG_FORTH_WORDS_KEY 
214c						DMARK "STX" 
214c f5				push af  
214d 3a 61 21			ld a, (.dmark)  
2150 32 77 fb			ld (debug_mark),a  
2153 3a 62 21			ld a, (.dmark+1)  
2156 32 78 fb			ld (debug_mark+1),a  
2159 3a 63 21			ld a, (.dmark+2)  
215c 32 79 fb			ld (debug_mark+2),a  
215f 18 03			jr .pastdmark  
2161 ..			.dmark: db "STX"  
2164 f1			.pastdmark: pop af  
2165			endm  
# End of macro DMARK
2165						CALLMONITOR 
2165 cd 17 16			call break_point_state  
2168				endm  
# End of macro CALLMONITOR
2168					endif 
2168			 
2168				FORTH_DSP_VALUEHL 
2168 cd 9b 1d			call macro_dsp_valuehl 
216b				endm 
# End of macro FORTH_DSP_VALUEHL
216b			 
216b 22 60 f8			ld (store_tmp1), hl    ; count 
216e			 
216e				FORTH_DSP_POP 
216e cd 53 1e			call macro_forth_dsp_pop 
2171				endm 
# End of macro FORTH_DSP_POP
2171			.stkexec1: 
2171 2a 60 f8			ld hl, (store_tmp1)   ; count 
2174 3e 00			ld a, 0 
2176 bd				cp l 
2177 c8				ret z 
2178			 
2178 2b				dec hl 
2179 22 60 f8			ld (store_tmp1), hl    ; count 
217c				 
217c				FORTH_DSP_VALUEHL 
217c cd 9b 1d			call macro_dsp_valuehl 
217f				endm 
# End of macro FORTH_DSP_VALUEHL
217f e5				push hl 
2180				 
2180					if DEBUG_FORTH_WORDS 
2180						DMARK "EXp" 
2180 f5				push af  
2181 3a 95 21			ld a, (.dmark)  
2184 32 77 fb			ld (debug_mark),a  
2187 3a 96 21			ld a, (.dmark+1)  
218a 32 78 fb			ld (debug_mark+1),a  
218d 3a 97 21			ld a, (.dmark+2)  
2190 32 79 fb			ld (debug_mark+2),a  
2193 18 03			jr .pastdmark  
2195 ..			.dmark: db "EXp"  
2198 f1			.pastdmark: pop af  
2199			endm  
# End of macro DMARK
2199						CALLMONITOR 
2199 cd 17 16			call break_point_state  
219c				endm  
# End of macro CALLMONITOR
219c					endif 
219c				FORTH_DSP_POP 
219c cd 53 1e			call macro_forth_dsp_pop 
219f				endm 
# End of macro FORTH_DSP_POP
219f			 
219f cd 29 11			call strlenz 
21a2 23				inc hl   ; include zero term to copy 
21a3 23				inc hl   ; include zero term to copy 
21a4 23				inc hl   ; include zero term to copy 
21a5 06 00			ld b,0 
21a7 4d				ld c,l 
21a8 e1				pop hl 
21a9 11 30 ef			ld de, execscratch 
21ac					if DEBUG_FORTH_WORDS 
21ac						DMARK "EX3" 
21ac f5				push af  
21ad 3a c1 21			ld a, (.dmark)  
21b0 32 77 fb			ld (debug_mark),a  
21b3 3a c2 21			ld a, (.dmark+1)  
21b6 32 78 fb			ld (debug_mark+1),a  
21b9 3a c3 21			ld a, (.dmark+2)  
21bc 32 79 fb			ld (debug_mark+2),a  
21bf 18 03			jr .pastdmark  
21c1 ..			.dmark: db "EX3"  
21c4 f1			.pastdmark: pop af  
21c5			endm  
# End of macro DMARK
21c5						CALLMONITOR 
21c5 cd 17 16			call break_point_state  
21c8				endm  
# End of macro CALLMONITOR
21c8					endif 
21c8 ed b0			ldir 
21ca			 
21ca			 
21ca 21 30 ef			ld hl, execscratch 
21cd			 
21cd					if DEBUG_FORTH_WORDS 
21cd						DMARK "EXP" 
21cd f5				push af  
21ce 3a e2 21			ld a, (.dmark)  
21d1 32 77 fb			ld (debug_mark),a  
21d4 3a e3 21			ld a, (.dmark+1)  
21d7 32 78 fb			ld (debug_mark+1),a  
21da 3a e4 21			ld a, (.dmark+2)  
21dd 32 79 fb			ld (debug_mark+2),a  
21e0 18 03			jr .pastdmark  
21e2 ..			.dmark: db "EXP"  
21e5 f1			.pastdmark: pop af  
21e6			endm  
# End of macro DMARK
21e6						CALLMONITOR 
21e6 cd 17 16			call break_point_state  
21e9				endm  
# End of macro CALLMONITOR
21e9					endif 
21e9			 
21e9 cd 5b 1f			call forthparse 
21ec 21 30 ef			ld hl, execscratch 
21ef					if DEBUG_FORTH_WORDS 
21ef						DMARK "EXx" 
21ef f5				push af  
21f0 3a 04 22			ld a, (.dmark)  
21f3 32 77 fb			ld (debug_mark),a  
21f6 3a 05 22			ld a, (.dmark+1)  
21f9 32 78 fb			ld (debug_mark+1),a  
21fc 3a 06 22			ld a, (.dmark+2)  
21ff 32 79 fb			ld (debug_mark+2),a  
2202 18 03			jr .pastdmark  
2204 ..			.dmark: db "EXx"  
2207 f1			.pastdmark: pop af  
2208			endm  
# End of macro DMARK
2208						CALLMONITOR 
2208 cd 17 16			call break_point_state  
220b				endm  
# End of macro CALLMONITOR
220b					endif 
220b cd 9b 1f			call forthexec 
220e			 
220e c3 71 21			jp .stkexec1 
2211			 
2211 c9				ret 
2212			 
2212			 
2212			.DUP: 
2212				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2212 17				db WORD_SYS_CORE+OPCODE_DUP             
2213 88 22			dw .ZDUP            
2215 04				db 3 + 1 
2216 .. 00			db "DUP",0              
221a				endm 
# End of macro CWHEAD
221a			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
221a			 
221a					if DEBUG_FORTH_WORDS_KEY 
221a						DMARK "DUP" 
221a f5				push af  
221b 3a 2f 22			ld a, (.dmark)  
221e 32 77 fb			ld (debug_mark),a  
2221 3a 30 22			ld a, (.dmark+1)  
2224 32 78 fb			ld (debug_mark+1),a  
2227 3a 31 22			ld a, (.dmark+2)  
222a 32 79 fb			ld (debug_mark+2),a  
222d 18 03			jr .pastdmark  
222f ..			.dmark: db "DUP"  
2232 f1			.pastdmark: pop af  
2233			endm  
# End of macro DMARK
2233						CALLMONITOR 
2233 cd 17 16			call break_point_state  
2236				endm  
# End of macro CALLMONITOR
2236					endif 
2236			 
2236					FORTH_DSP 
2236 cd 61 1d			call macro_forth_dsp 
2239				endm 
# End of macro FORTH_DSP
2239			 
2239 7e					ld a, (HL) 
223a fe 01				cp DS_TYPE_STR 
223c 20 25				jr nz, .dupinum 
223e			 
223e					; push another string 
223e			 
223e					FORTH_DSP_VALUEHL     		 
223e cd 9b 1d			call macro_dsp_valuehl 
2241				endm 
# End of macro FORTH_DSP_VALUEHL
2241			 
2241				if DEBUG_FORTH_WORDS 
2241					DMARK "DUs" 
2241 f5				push af  
2242 3a 56 22			ld a, (.dmark)  
2245 32 77 fb			ld (debug_mark),a  
2248 3a 57 22			ld a, (.dmark+1)  
224b 32 78 fb			ld (debug_mark+1),a  
224e 3a 58 22			ld a, (.dmark+2)  
2251 32 79 fb			ld (debug_mark+2),a  
2254 18 03			jr .pastdmark  
2256 ..			.dmark: db "DUs"  
2259 f1			.pastdmark: pop af  
225a			endm  
# End of macro DMARK
225a					CALLMONITOR 
225a cd 17 16			call break_point_state  
225d				endm  
# End of macro CALLMONITOR
225d				endif 
225d cd 12 1c				call forth_push_str 
2260			 
2260					NEXTW 
2260 c3 0d 1f			jp macro_next 
2263				endm 
# End of macro NEXTW
2263			 
2263			 
2263			.dupinum: 
2263					 
2263			 
2263			 
2263					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2263 cd 9b 1d			call macro_dsp_valuehl 
2266				endm 
# End of macro FORTH_DSP_VALUEHL
2266			 
2266				; TODO add floating point number detection 
2266			 
2266				if DEBUG_FORTH_WORDS 
2266					DMARK "DUi" 
2266 f5				push af  
2267 3a 7b 22			ld a, (.dmark)  
226a 32 77 fb			ld (debug_mark),a  
226d 3a 7c 22			ld a, (.dmark+1)  
2270 32 78 fb			ld (debug_mark+1),a  
2273 3a 7d 22			ld a, (.dmark+2)  
2276 32 79 fb			ld (debug_mark+2),a  
2279 18 03			jr .pastdmark  
227b ..			.dmark: db "DUi"  
227e f1			.pastdmark: pop af  
227f			endm  
# End of macro DMARK
227f					CALLMONITOR 
227f cd 17 16			call break_point_state  
2282				endm  
# End of macro CALLMONITOR
2282				endif 
2282			 
2282 cd a4 1b				call forth_push_numhl 
2285					NEXTW 
2285 c3 0d 1f			jp macro_next 
2288				endm 
# End of macro NEXTW
2288			.ZDUP: 
2288				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2288 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2289 c0 22			dw .SWAP            
228b 05				db 4 + 1 
228c .. 00			db "?DUP",0              
2291				endm 
# End of macro CWHEAD
2291			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2291			 
2291					if DEBUG_FORTH_WORDS_KEY 
2291						DMARK "qDU" 
2291 f5				push af  
2292 3a a6 22			ld a, (.dmark)  
2295 32 77 fb			ld (debug_mark),a  
2298 3a a7 22			ld a, (.dmark+1)  
229b 32 78 fb			ld (debug_mark+1),a  
229e 3a a8 22			ld a, (.dmark+2)  
22a1 32 79 fb			ld (debug_mark+2),a  
22a4 18 03			jr .pastdmark  
22a6 ..			.dmark: db "qDU"  
22a9 f1			.pastdmark: pop af  
22aa			endm  
# End of macro DMARK
22aa						CALLMONITOR 
22aa cd 17 16			call break_point_state  
22ad				endm  
# End of macro CALLMONITOR
22ad					endif 
22ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22ad cd 9b 1d			call macro_dsp_valuehl 
22b0				endm 
# End of macro FORTH_DSP_VALUEHL
22b0			 
22b0 e5					push hl 
22b1			 
22b1					; is it a zero? 
22b1			 
22b1 3e 00				ld a, 0 
22b3 84					add h 
22b4 85					add l 
22b5			 
22b5 e1					pop hl 
22b6			 
22b6 fe 00				cp 0 
22b8 28 03				jr z, .dup2orig 
22ba			 
22ba			 
22ba cd a4 1b				call forth_push_numhl 
22bd			 
22bd			 
22bd				; TODO add floating point number detection 
22bd			 
22bd			.dup2orig: 
22bd			 
22bd					NEXTW 
22bd c3 0d 1f			jp macro_next 
22c0				endm 
# End of macro NEXTW
22c0			.SWAP: 
22c0				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
22c0 18				db WORD_SYS_CORE+OPCODE_SWAP             
22c1 ff 22			dw .COLN            
22c3 05				db 4 + 1 
22c4 .. 00			db "SWAP",0              
22c9				endm 
# End of macro CWHEAD
22c9			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
22c9					if DEBUG_FORTH_WORDS_KEY 
22c9						DMARK "SWP" 
22c9 f5				push af  
22ca 3a de 22			ld a, (.dmark)  
22cd 32 77 fb			ld (debug_mark),a  
22d0 3a df 22			ld a, (.dmark+1)  
22d3 32 78 fb			ld (debug_mark+1),a  
22d6 3a e0 22			ld a, (.dmark+2)  
22d9 32 79 fb			ld (debug_mark+2),a  
22dc 18 03			jr .pastdmark  
22de ..			.dmark: db "SWP"  
22e1 f1			.pastdmark: pop af  
22e2			endm  
# End of macro DMARK
22e2						CALLMONITOR 
22e2 cd 17 16			call break_point_state  
22e5				endm  
# End of macro CALLMONITOR
22e5					endif 
22e5			 
22e5					FORTH_DSP_VALUEHL 
22e5 cd 9b 1d			call macro_dsp_valuehl 
22e8				endm 
# End of macro FORTH_DSP_VALUEHL
22e8 e5					push hl     ; w2 
22e9			 
22e9					FORTH_DSP_POP 
22e9 cd 53 1e			call macro_forth_dsp_pop 
22ec				endm 
# End of macro FORTH_DSP_POP
22ec			 
22ec					FORTH_DSP_VALUEHL 
22ec cd 9b 1d			call macro_dsp_valuehl 
22ef				endm 
# End of macro FORTH_DSP_VALUEHL
22ef			 
22ef					FORTH_DSP_POP 
22ef cd 53 1e			call macro_forth_dsp_pop 
22f2				endm 
# End of macro FORTH_DSP_POP
22f2			 
22f2 d1					pop de     ; w2	, hl = w1 
22f3			 
22f3 eb					ex de, hl 
22f4 d5					push de 
22f5			 
22f5 cd a4 1b				call forth_push_numhl 
22f8			 
22f8 e1					pop hl 
22f9			 
22f9 cd a4 1b				call forth_push_numhl 
22fc					 
22fc			 
22fc					NEXTW 
22fc c3 0d 1f			jp macro_next 
22ff				endm 
# End of macro NEXTW
22ff			.COLN: 
22ff				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22ff 19				db WORD_SYS_CORE+OPCODE_COLN             
2300 8b 24			dw .SCOLN            
2302 02				db 1 + 1 
2303 .. 00			db ":",0              
2305				endm 
# End of macro CWHEAD
2305			; | : ( -- )         Create new word | DONE 
2305			 
2305					if DEBUG_FORTH_WORDS_KEY 
2305						DMARK "CLN" 
2305 f5				push af  
2306 3a 1a 23			ld a, (.dmark)  
2309 32 77 fb			ld (debug_mark),a  
230c 3a 1b 23			ld a, (.dmark+1)  
230f 32 78 fb			ld (debug_mark+1),a  
2312 3a 1c 23			ld a, (.dmark+2)  
2315 32 79 fb			ld (debug_mark+2),a  
2318 18 03			jr .pastdmark  
231a ..			.dmark: db "CLN"  
231d f1			.pastdmark: pop af  
231e			endm  
# End of macro DMARK
231e						CALLMONITOR 
231e cd 17 16			call break_point_state  
2321				endm  
# End of macro CALLMONITOR
2321					endif 
2321				STACKFRAME OFF $8efe $989f 
2321				if DEBUG_STACK_IMB 
2321					if OFF 
2321						exx 
2321						ld de, $8efe 
2321						ld a, d 
2321						ld hl, curframe 
2321						call hexout 
2321						ld a, e 
2321						ld hl, curframe+2 
2321						call hexout 
2321						ld hl, $8efe 
2321						push hl 
2321						ld hl, $989f 
2321						push hl 
2321						exx 
2321					endif 
2321				endif 
2321			endm 
# End of macro STACKFRAME
2321				; get parser buffer length  of new word 
2321			 
2321				 
2321			 
2321					; move tok past this to start of name defintition 
2321					; TODO get word to define 
2321					; TODO Move past word token 
2321					; TODO get length of string up to the ';' 
2321			 
2321 2a 32 f1			ld hl, (os_tok_ptr) 
2324 23				inc hl 
2325 23				inc hl 
2326			 
2326 3e 3b			ld a, ';' 
2328 cd 34 11			call strlent 
232b			 
232b 7d				ld a,l 
232c 32 31 f0			ld (os_new_parse_len), a 
232f			 
232f			 
232f			if DEBUG_FORTH_UWORD 
232f ed 5b 32 f1		ld de, (os_tok_ptr) 
2333						DMARK ":01" 
2333 f5				push af  
2334 3a 48 23			ld a, (.dmark)  
2337 32 77 fb			ld (debug_mark),a  
233a 3a 49 23			ld a, (.dmark+1)  
233d 32 78 fb			ld (debug_mark+1),a  
2340 3a 4a 23			ld a, (.dmark+2)  
2343 32 79 fb			ld (debug_mark+2),a  
2346 18 03			jr .pastdmark  
2348 ..			.dmark: db ":01"  
234b f1			.pastdmark: pop af  
234c			endm  
# End of macro DMARK
234c				CALLMONITOR 
234c cd 17 16			call break_point_state  
234f				endm  
# End of macro CALLMONITOR
234f			endif 
234f			 
234f			; 
234f			;  new word memory layout: 
234f			;  
234f			;    : adg 6666 ;  
234f			; 
234f			;    db   1     ; user defined word  
234f 23				inc hl    
2350			;    dw   sysdict 
2350 23				inc hl 
2351 23				inc hl 
2352			;    db <word len>+1 (for null) 
2352 23				inc hl 
2353			;    db .... <word> 
2353			; 
2353			 
2353 23				inc hl    ; some extras for the word preamble before the above 
2354 23				inc hl 
2355 23				inc hl 
2356 23				inc hl 
2357 23				inc hl 
2358 23				inc hl 
2359 23				inc hl  
235a 23				inc hl 
235b 23				inc hl 
235c 23				inc hl 
235d 23				inc hl 
235e 23				inc hl 
235f 23				inc hl 
2360 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2361			;       exec word buffer 
2361			;	<ptr word>   
2361 23				inc hl 
2362 23				inc hl 
2363			;       <word list><null term> 7F final term 
2363			 
2363			 
2363			if DEBUG_FORTH_UWORD 
2363						DMARK ":02" 
2363 f5				push af  
2364 3a 78 23			ld a, (.dmark)  
2367 32 77 fb			ld (debug_mark),a  
236a 3a 79 23			ld a, (.dmark+1)  
236d 32 78 fb			ld (debug_mark+1),a  
2370 3a 7a 23			ld a, (.dmark+2)  
2373 32 79 fb			ld (debug_mark+2),a  
2376 18 03			jr .pastdmark  
2378 ..			.dmark: db ":02"  
237b f1			.pastdmark: pop af  
237c			endm  
# End of macro DMARK
237c				CALLMONITOR 
237c cd 17 16			call break_point_state  
237f				endm  
# End of macro CALLMONITOR
237f			endif 
237f			 
237f				 
237f					; malloc the size 
237f			 
237f cd 92 11				call malloc 
2382 22 2f f0				ld (os_new_malloc), hl     ; save malloc start 
2385			 
2385			;    db   1     ; user defined word  
2385 3e 01				ld a, WORD_SYS_UWORD  
2387 77					ld (hl), a 
2388				 
2388 23				inc hl    
2389			;    dw   sysdict 
2389 11 65 20			ld de, sysdict       ; continue on with the scan to the system dict 
238c 73				ld (hl), e 
238d 23				inc hl 
238e 72				ld (hl), d 
238f 23				inc hl 
2390			 
2390			 
2390			;    Setup dict word 
2390			 
2390 23				inc hl 
2391 22 35 f0			ld (os_new_work_ptr), hl     ; save start of dict word  
2394			 
2394				; 1. get length of dict word 
2394			 
2394			 
2394 2a 32 f1			ld hl, (os_tok_ptr) 
2397 23				inc hl 
2398 23				inc hl    ; position to start of dict word 
2399 3e 00			ld a, 0 
239b cd 34 11			call strlent 
239e			 
239e			 
239e 23				inc hl    ; to include null??? 
239f			 
239f				; write length of dict word 
239f			 
239f ed 5b 35 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
23a3 1b				dec de 
23a4 eb				ex de, hl 
23a5 73				ld (hl), e 
23a6 eb				ex de, hl 
23a7			 
23a7				 
23a7			 
23a7				; copy  
23a7 4d				ld c, l 
23a8 06 00			ld b, 0 
23aa ed 5b 35 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
23ae 2a 32 f1			ld hl, (os_tok_ptr) 
23b1 23				inc hl 
23b2 23				inc hl    ; position to start of dict word 
23b3				 
23b3			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
23b3				 
23b3				; TODO need to convert word to upper case 
23b3			 
23b3			ucasetok:	 
23b3 7e				ld a,(hl) 
23b4 cd 20 11			call toUpper 
23b7 77				ld (hl),a 
23b8 ed a0			ldi 
23ba f2 b3 23		 	jp p, ucasetok 
23bd			 
23bd			 
23bd			 
23bd				; de now points to start of where the word body code should be placed 
23bd ed 53 35 f0		ld (os_new_work_ptr), de 
23c1				; hl now points to the words to throw at forthexec which needs to be copied 
23c1 22 37 f0			ld (os_new_src_ptr), hl 
23c4			 
23c4				; TODO add 'call to forthexec' 
23c4			 
23c4			if DEBUG_FORTH_UWORD 
23c4 c5				push bc 
23c5 ed 4b 2f f0		ld bc, (os_new_malloc) 
23c9						DMARK ":0x" 
23c9 f5				push af  
23ca 3a de 23			ld a, (.dmark)  
23cd 32 77 fb			ld (debug_mark),a  
23d0 3a df 23			ld a, (.dmark+1)  
23d3 32 78 fb			ld (debug_mark+1),a  
23d6 3a e0 23			ld a, (.dmark+2)  
23d9 32 79 fb			ld (debug_mark+2),a  
23dc 18 03			jr .pastdmark  
23de ..			.dmark: db ":0x"  
23e1 f1			.pastdmark: pop af  
23e2			endm  
# End of macro DMARK
23e2				CALLMONITOR 
23e2 cd 17 16			call break_point_state  
23e5				endm  
# End of macro CALLMONITOR
23e5 c1				pop bc 
23e6			endif 
23e6			 
23e6			 
23e6				; create word preamble which should be: 
23e6			 
23e6			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23e6			 
23e6				;    ld hl, <word code> 
23e6				;    jp user_exec 
23e6			        ;    <word code bytes> 
23e6			 
23e6			 
23e6			;	inc de     ; TODO ??? or are we already past the word's null 
23e6 eb				ex de, hl 
23e7			 
23e7 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23e9			 
23e9 23				inc hl 
23ea 22 3b f0			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23ed 23				inc hl 
23ee			 
23ee 23				inc hl 
23ef 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23f1			 
23f1 01 f6 50			ld bc, user_exec 
23f4 23				inc hl 
23f5 71				ld (hl), c     ; poke address of user_exec 
23f6 23				inc hl 
23f7 70				ld (hl), b     
23f8			 ; 
23f8			;	inc hl 
23f8			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23f8			; 
23f8			; 
23f8			;	ld bc, macro_forth_rsp_next 
23f8			;	inc hl 
23f8			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23f8			;	inc hl 
23f8			;	ld (hl), b     
23f8			 ; 
23f8			;	inc hl 
23f8			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23f8			; 
23f8			; 
23f8			;	inc hl 
23f8			;	ld bc, forthexec 
23f8			;	ld (hl), c     ; poke address of forthexec 
23f8			;	inc hl 
23f8			;	ld (hl), b      
23f8			; 
23f8			;	inc hl 
23f8			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23f8			; 
23f8			;	ld bc, user_dict_next 
23f8			;	inc hl 
23f8			;	ld (hl), c     ; poke address of forthexec 
23f8			;	inc hl 
23f8			;	ld (hl), b      
23f8			 
23f8				; hl is now where we need to copy the word byte data to save this 
23f8			 
23f8 23				inc hl 
23f9 22 39 f0			ld (os_new_exec), hl 
23fc				 
23fc				; copy definition 
23fc			 
23fc eb				ex de, hl 
23fd			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23fd			;	inc de    ; skip the PC for this parse 
23fd 3a 31 f0			ld a, (os_new_parse_len) 
2400 4f				ld c, a 
2401 06 00			ld b, 0 
2403 ed b0			ldir		 ; copy defintion 
2405			 
2405			 
2405				; poke the address of where the new word bytes live for forthexec 
2405			 
2405 2a 3b f0			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2408			 
2408 ed 5b 39 f0		ld de, (os_new_exec)      
240c				 
240c 73				ld (hl), e 
240d 23				inc hl 
240e 72				ld (hl), d 
240f			 
240f					; TODO copy last user dict word next link to this word 
240f					; TODO update last user dict word to point to this word 
240f			; 
240f			; hl f923 de 812a ; bc 811a 
240f			 
240f			if DEBUG_FORTH_UWORD 
240f c5				push bc 
2410 ed 4b 2f f0		ld bc, (os_new_malloc) 
2414						DMARK ":0A" 
2414 f5				push af  
2415 3a 29 24			ld a, (.dmark)  
2418 32 77 fb			ld (debug_mark),a  
241b 3a 2a 24			ld a, (.dmark+1)  
241e 32 78 fb			ld (debug_mark+1),a  
2421 3a 2b 24			ld a, (.dmark+2)  
2424 32 79 fb			ld (debug_mark+2),a  
2427 18 03			jr .pastdmark  
2429 ..			.dmark: db ":0A"  
242c f1			.pastdmark: pop af  
242d			endm  
# End of macro DMARK
242d				CALLMONITOR 
242d cd 17 16			call break_point_state  
2430				endm  
# End of macro CALLMONITOR
2430 c1				pop bc 
2431			endif 
2431			if DEBUG_FORTH_UWORD 
2431 c5				push bc 
2432 ed 4b 2f f0		ld bc, (os_new_malloc) 
2436 03				inc bc 
2437 03				inc bc 
2438 03				inc bc 
2439 03				inc bc 
243a 03				inc bc 
243b 03				inc bc 
243c 03				inc bc 
243d 03				inc bc 
243e			 
243e						DMARK ":0B" 
243e f5				push af  
243f 3a 53 24			ld a, (.dmark)  
2442 32 77 fb			ld (debug_mark),a  
2445 3a 54 24			ld a, (.dmark+1)  
2448 32 78 fb			ld (debug_mark+1),a  
244b 3a 55 24			ld a, (.dmark+2)  
244e 32 79 fb			ld (debug_mark+2),a  
2451 18 03			jr .pastdmark  
2453 ..			.dmark: db ":0B"  
2456 f1			.pastdmark: pop af  
2457			endm  
# End of macro DMARK
2457				CALLMONITOR 
2457 cd 17 16			call break_point_state  
245a				endm  
# End of macro CALLMONITOR
245a c1				pop bc 
245b			endif 
245b			 
245b			; update word dict linked list for new word 
245b			 
245b			 
245b 2a 2e f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
245e 23			inc hl     ; move to next work linked list ptr 
245f			 
245f ed 5b 2f f0	ld de, (os_new_malloc)		 ; new next word 
2463 73			ld (hl), e 
2464 23			inc hl 
2465 72			ld (hl), d 
2466			 
2466			if DEBUG_FORTH_UWORD 
2466 ed 4b 2e f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
246a			endif 
246a			 
246a ed 53 2e f1	ld (os_last_new_uword), de      ; update last new uword ptr 
246e			 
246e			 
246e			if DEBUG_FORTH_UWORD 
246e						DMARK ":0+" 
246e f5				push af  
246f 3a 83 24			ld a, (.dmark)  
2472 32 77 fb			ld (debug_mark),a  
2475 3a 84 24			ld a, (.dmark+1)  
2478 32 78 fb			ld (debug_mark+1),a  
247b 3a 85 24			ld a, (.dmark+2)  
247e 32 79 fb			ld (debug_mark+2),a  
2481 18 03			jr .pastdmark  
2483 ..			.dmark: db ":0+"  
2486 f1			.pastdmark: pop af  
2487			endm  
# End of macro DMARK
2487				CALLMONITOR 
2487 cd 17 16			call break_point_state  
248a				endm  
# End of macro CALLMONITOR
248a			endif 
248a			 
248a				STACKFRAMECHK OFF $8efe $989f 
248a				if DEBUG_STACK_IMB 
248a					if OFF 
248a						exx 
248a						ld hl, $989f 
248a						pop de   ; $989f 
248a						call cmp16 
248a						jr nz, .spnosame 
248a						ld hl, $8efe 
248a						pop de   ; $8efe 
248a						call cmp16 
248a						jr z, .spfrsame 
248a						.spnosame: call showsperror 
248a						.spfrsame: nop 
248a						exx 
248a					endif 
248a				endif 
248a			endm 
# End of macro STACKFRAMECHK
248a			 
248a c9			ret    ; dont process any remaining parser tokens as they form new word 
248b			 
248b			 
248b			 
248b			 
248b			;		NEXT 
248b			.SCOLN: 
248b			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
248b 06				db OPCODE_SCOLN 
248c d7 24			dw .DROP 
248e 02				db 2 
248f .. 00			db ";",0           
2491			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2491					if DEBUG_FORTH_WORDS_KEY 
2491						DMARK "SCN" 
2491 f5				push af  
2492 3a a6 24			ld a, (.dmark)  
2495 32 77 fb			ld (debug_mark),a  
2498 3a a7 24			ld a, (.dmark+1)  
249b 32 78 fb			ld (debug_mark+1),a  
249e 3a a8 24			ld a, (.dmark+2)  
24a1 32 79 fb			ld (debug_mark+2),a  
24a4 18 03			jr .pastdmark  
24a6 ..			.dmark: db "SCN"  
24a9 f1			.pastdmark: pop af  
24aa			endm  
# End of macro DMARK
24aa						CALLMONITOR 
24aa cd 17 16			call break_point_state  
24ad				endm  
# End of macro CALLMONITOR
24ad					endif 
24ad					FORTH_RSP_TOS 
24ad cd 62 1b			call macro_forth_rsp_tos 
24b0				endm 
# End of macro FORTH_RSP_TOS
24b0 e5					push hl 
24b1					FORTH_RSP_POP 
24b1 cd 6c 1b			call macro_forth_rsp_pop 
24b4				endm 
# End of macro FORTH_RSP_POP
24b4 e1					pop hl 
24b5			;		ex de,hl 
24b5 22 32 f1				ld (os_tok_ptr),hl 
24b8			 
24b8			if DEBUG_FORTH_UWORD 
24b8						DMARK "SCL" 
24b8 f5				push af  
24b9 3a cd 24			ld a, (.dmark)  
24bc 32 77 fb			ld (debug_mark),a  
24bf 3a ce 24			ld a, (.dmark+1)  
24c2 32 78 fb			ld (debug_mark+1),a  
24c5 3a cf 24			ld a, (.dmark+2)  
24c8 32 79 fb			ld (debug_mark+2),a  
24cb 18 03			jr .pastdmark  
24cd ..			.dmark: db "SCL"  
24d0 f1			.pastdmark: pop af  
24d1			endm  
# End of macro DMARK
24d1				CALLMONITOR 
24d1 cd 17 16			call break_point_state  
24d4				endm  
# End of macro CALLMONITOR
24d4			endif 
24d4					NEXTW 
24d4 c3 0d 1f			jp macro_next 
24d7				endm 
# End of macro NEXTW
24d7			 
24d7			.DROP: 
24d7				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
24d7 1b				db WORD_SYS_CORE+OPCODE_DROP             
24d8 02 25			dw .DUP2            
24da 05				db 4 + 1 
24db .. 00			db "DROP",0              
24e0				endm 
# End of macro CWHEAD
24e0			; | DROP ( w -- )   drop the TOS item   | DONE 
24e0					if DEBUG_FORTH_WORDS_KEY 
24e0						DMARK "DRP" 
24e0 f5				push af  
24e1 3a f5 24			ld a, (.dmark)  
24e4 32 77 fb			ld (debug_mark),a  
24e7 3a f6 24			ld a, (.dmark+1)  
24ea 32 78 fb			ld (debug_mark+1),a  
24ed 3a f7 24			ld a, (.dmark+2)  
24f0 32 79 fb			ld (debug_mark+2),a  
24f3 18 03			jr .pastdmark  
24f5 ..			.dmark: db "DRP"  
24f8 f1			.pastdmark: pop af  
24f9			endm  
# End of macro DMARK
24f9						CALLMONITOR 
24f9 cd 17 16			call break_point_state  
24fc				endm  
# End of macro CALLMONITOR
24fc					endif 
24fc					FORTH_DSP_POP 
24fc cd 53 1e			call macro_forth_dsp_pop 
24ff				endm 
# End of macro FORTH_DSP_POP
24ff					NEXTW 
24ff c3 0d 1f			jp macro_next 
2502				endm 
# End of macro NEXTW
2502			.DUP2: 
2502				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2502 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2503 47 25			dw .DROP2            
2505 05				db 4 + 1 
2506 .. 00			db "2DUP",0              
250b				endm 
# End of macro CWHEAD
250b			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
250b					if DEBUG_FORTH_WORDS_KEY 
250b						DMARK "2DU" 
250b f5				push af  
250c 3a 20 25			ld a, (.dmark)  
250f 32 77 fb			ld (debug_mark),a  
2512 3a 21 25			ld a, (.dmark+1)  
2515 32 78 fb			ld (debug_mark+1),a  
2518 3a 22 25			ld a, (.dmark+2)  
251b 32 79 fb			ld (debug_mark+2),a  
251e 18 03			jr .pastdmark  
2520 ..			.dmark: db "2DU"  
2523 f1			.pastdmark: pop af  
2524			endm  
# End of macro DMARK
2524						CALLMONITOR 
2524 cd 17 16			call break_point_state  
2527				endm  
# End of macro CALLMONITOR
2527					endif 
2527					FORTH_DSP_VALUEHL 
2527 cd 9b 1d			call macro_dsp_valuehl 
252a				endm 
# End of macro FORTH_DSP_VALUEHL
252a e5					push hl      ; 2 
252b			 
252b					FORTH_DSP_POP 
252b cd 53 1e			call macro_forth_dsp_pop 
252e				endm 
# End of macro FORTH_DSP_POP
252e					 
252e					FORTH_DSP_VALUEHL 
252e cd 9b 1d			call macro_dsp_valuehl 
2531				endm 
# End of macro FORTH_DSP_VALUEHL
2531			;		push hl      ; 1 
2531			 
2531					FORTH_DSP_POP 
2531 cd 53 1e			call macro_forth_dsp_pop 
2534				endm 
# End of macro FORTH_DSP_POP
2534			 
2534			;		pop hl       ; 1 
2534 d1					pop de       ; 2 
2535			 
2535 cd a4 1b				call forth_push_numhl 
2538 eb					ex de, hl 
2539 cd a4 1b				call forth_push_numhl 
253c			 
253c					 
253c eb					ex de, hl 
253d			 
253d cd a4 1b				call forth_push_numhl 
2540 eb					ex de, hl 
2541 cd a4 1b				call forth_push_numhl 
2544			 
2544			 
2544					NEXTW 
2544 c3 0d 1f			jp macro_next 
2547				endm 
# End of macro NEXTW
2547			.DROP2: 
2547				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2547 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2548 76 25			dw .SWAP2            
254a 06				db 5 + 1 
254b .. 00			db "2DROP",0              
2551				endm 
# End of macro CWHEAD
2551			; | 2DROP ( w w -- )    Double drop | DONE 
2551					if DEBUG_FORTH_WORDS_KEY 
2551						DMARK "2DR" 
2551 f5				push af  
2552 3a 66 25			ld a, (.dmark)  
2555 32 77 fb			ld (debug_mark),a  
2558 3a 67 25			ld a, (.dmark+1)  
255b 32 78 fb			ld (debug_mark+1),a  
255e 3a 68 25			ld a, (.dmark+2)  
2561 32 79 fb			ld (debug_mark+2),a  
2564 18 03			jr .pastdmark  
2566 ..			.dmark: db "2DR"  
2569 f1			.pastdmark: pop af  
256a			endm  
# End of macro DMARK
256a						CALLMONITOR 
256a cd 17 16			call break_point_state  
256d				endm  
# End of macro CALLMONITOR
256d					endif 
256d					FORTH_DSP_POP 
256d cd 53 1e			call macro_forth_dsp_pop 
2570				endm 
# End of macro FORTH_DSP_POP
2570					FORTH_DSP_POP 
2570 cd 53 1e			call macro_forth_dsp_pop 
2573				endm 
# End of macro FORTH_DSP_POP
2573					NEXTW 
2573 c3 0d 1f			jp macro_next 
2576				endm 
# End of macro NEXTW
2576			.SWAP2: 
2576				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2576 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2577 9f 25			dw .AT            
2579 06				db 5 + 1 
257a .. 00			db "2SWAP",0              
2580				endm 
# End of macro CWHEAD
2580			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2580					if DEBUG_FORTH_WORDS_KEY 
2580						DMARK "2SW" 
2580 f5				push af  
2581 3a 95 25			ld a, (.dmark)  
2584 32 77 fb			ld (debug_mark),a  
2587 3a 96 25			ld a, (.dmark+1)  
258a 32 78 fb			ld (debug_mark+1),a  
258d 3a 97 25			ld a, (.dmark+2)  
2590 32 79 fb			ld (debug_mark+2),a  
2593 18 03			jr .pastdmark  
2595 ..			.dmark: db "2SW"  
2598 f1			.pastdmark: pop af  
2599			endm  
# End of macro DMARK
2599						CALLMONITOR 
2599 cd 17 16			call break_point_state  
259c				endm  
# End of macro CALLMONITOR
259c					endif 
259c					NEXTW 
259c c3 0d 1f			jp macro_next 
259f				endm 
# End of macro NEXTW
259f			.AT: 
259f				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
259f 1f				db WORD_SYS_CORE+OPCODE_AT             
25a0 d1 25			dw .CAT            
25a2 02				db 1 + 1 
25a3 .. 00			db "@",0              
25a5				endm 
# End of macro CWHEAD
25a5			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
25a5			 
25a5					if DEBUG_FORTH_WORDS_KEY 
25a5						DMARK "AT." 
25a5 f5				push af  
25a6 3a ba 25			ld a, (.dmark)  
25a9 32 77 fb			ld (debug_mark),a  
25ac 3a bb 25			ld a, (.dmark+1)  
25af 32 78 fb			ld (debug_mark+1),a  
25b2 3a bc 25			ld a, (.dmark+2)  
25b5 32 79 fb			ld (debug_mark+2),a  
25b8 18 03			jr .pastdmark  
25ba ..			.dmark: db "AT."  
25bd f1			.pastdmark: pop af  
25be			endm  
# End of macro DMARK
25be						CALLMONITOR 
25be cd 17 16			call break_point_state  
25c1				endm  
# End of macro CALLMONITOR
25c1					endif 
25c1			.getbyteat:	 
25c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25c1 cd 9b 1d			call macro_dsp_valuehl 
25c4				endm 
# End of macro FORTH_DSP_VALUEHL
25c4					 
25c4			;		push hl 
25c4				 
25c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25c4 cd 53 1e			call macro_forth_dsp_pop 
25c7				endm 
# End of macro FORTH_DSP_POP
25c7			 
25c7			;		pop hl 
25c7			 
25c7 7e					ld a, (hl) 
25c8			 
25c8 6f					ld l, a 
25c9 26 00				ld h, 0 
25cb cd a4 1b				call forth_push_numhl 
25ce			 
25ce					NEXTW 
25ce c3 0d 1f			jp macro_next 
25d1				endm 
# End of macro NEXTW
25d1			.CAT: 
25d1				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
25d1 20				db WORD_SYS_CORE+OPCODE_CAT             
25d2 fa 25			dw .BANG            
25d4 03				db 2 + 1 
25d5 .. 00			db "C@",0              
25d8				endm 
# End of macro CWHEAD
25d8			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25d8					if DEBUG_FORTH_WORDS_KEY 
25d8						DMARK "CAA" 
25d8 f5				push af  
25d9 3a ed 25			ld a, (.dmark)  
25dc 32 77 fb			ld (debug_mark),a  
25df 3a ee 25			ld a, (.dmark+1)  
25e2 32 78 fb			ld (debug_mark+1),a  
25e5 3a ef 25			ld a, (.dmark+2)  
25e8 32 79 fb			ld (debug_mark+2),a  
25eb 18 03			jr .pastdmark  
25ed ..			.dmark: db "CAA"  
25f0 f1			.pastdmark: pop af  
25f1			endm  
# End of macro DMARK
25f1						CALLMONITOR 
25f1 cd 17 16			call break_point_state  
25f4				endm  
# End of macro CALLMONITOR
25f4					endif 
25f4 c3 c1 25				jp .getbyteat 
25f7					NEXTW 
25f7 c3 0d 1f			jp macro_next 
25fa				endm 
# End of macro NEXTW
25fa			.BANG: 
25fa				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25fa 21				db WORD_SYS_CORE+OPCODE_BANG             
25fb 30 26			dw .CBANG            
25fd 02				db 1 + 1 
25fe .. 00			db "!",0              
2600				endm 
# End of macro CWHEAD
2600			; | ! ( x w -- ) Store x at address w      | DONE 
2600					if DEBUG_FORTH_WORDS_KEY 
2600						DMARK "BNG" 
2600 f5				push af  
2601 3a 15 26			ld a, (.dmark)  
2604 32 77 fb			ld (debug_mark),a  
2607 3a 16 26			ld a, (.dmark+1)  
260a 32 78 fb			ld (debug_mark+1),a  
260d 3a 17 26			ld a, (.dmark+2)  
2610 32 79 fb			ld (debug_mark+2),a  
2613 18 03			jr .pastdmark  
2615 ..			.dmark: db "BNG"  
2618 f1			.pastdmark: pop af  
2619			endm  
# End of macro DMARK
2619						CALLMONITOR 
2619 cd 17 16			call break_point_state  
261c				endm  
# End of macro CALLMONITOR
261c					endif 
261c			 
261c			.storebyteat:		 
261c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
261c cd 9b 1d			call macro_dsp_valuehl 
261f				endm 
# End of macro FORTH_DSP_VALUEHL
261f					 
261f e5					push hl 
2620				 
2620					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2620 cd 53 1e			call macro_forth_dsp_pop 
2623				endm 
# End of macro FORTH_DSP_POP
2623			 
2623					; get byte to poke 
2623			 
2623					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2623 cd 9b 1d			call macro_dsp_valuehl 
2626				endm 
# End of macro FORTH_DSP_VALUEHL
2626 e5					push hl 
2627			 
2627			 
2627					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2627 cd 53 1e			call macro_forth_dsp_pop 
262a				endm 
# End of macro FORTH_DSP_POP
262a			 
262a			 
262a d1					pop de 
262b e1					pop hl 
262c			 
262c 73					ld (hl),e 
262d			 
262d			 
262d					NEXTW 
262d c3 0d 1f			jp macro_next 
2630				endm 
# End of macro NEXTW
2630			.CBANG: 
2630				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2630 22				db WORD_SYS_CORE+OPCODE_CBANG             
2631 59 26			dw .SCALL            
2633 03				db 2 + 1 
2634 .. 00			db "C!",0              
2637				endm 
# End of macro CWHEAD
2637			; | C!  ( x w -- ) Store x at address w  | DONE 
2637					if DEBUG_FORTH_WORDS_KEY 
2637						DMARK "CBA" 
2637 f5				push af  
2638 3a 4c 26			ld a, (.dmark)  
263b 32 77 fb			ld (debug_mark),a  
263e 3a 4d 26			ld a, (.dmark+1)  
2641 32 78 fb			ld (debug_mark+1),a  
2644 3a 4e 26			ld a, (.dmark+2)  
2647 32 79 fb			ld (debug_mark+2),a  
264a 18 03			jr .pastdmark  
264c ..			.dmark: db "CBA"  
264f f1			.pastdmark: pop af  
2650			endm  
# End of macro DMARK
2650						CALLMONITOR 
2650 cd 17 16			call break_point_state  
2653				endm  
# End of macro CALLMONITOR
2653					endif 
2653 c3 1c 26				jp .storebyteat 
2656					NEXTW 
2656 c3 0d 1f			jp macro_next 
2659				endm 
# End of macro NEXTW
2659			.SCALL: 
2659				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2659 23				db WORD_SYS_CORE+OPCODE_SCALL             
265a 8d 26			dw .DEPTH            
265c 05				db 4 + 1 
265d .. 00			db "CALL",0              
2662				endm 
# End of macro CWHEAD
2662			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2662					if DEBUG_FORTH_WORDS_KEY 
2662						DMARK "CLL" 
2662 f5				push af  
2663 3a 77 26			ld a, (.dmark)  
2666 32 77 fb			ld (debug_mark),a  
2669 3a 78 26			ld a, (.dmark+1)  
266c 32 78 fb			ld (debug_mark+1),a  
266f 3a 79 26			ld a, (.dmark+2)  
2672 32 79 fb			ld (debug_mark+2),a  
2675 18 03			jr .pastdmark  
2677 ..			.dmark: db "CLL"  
267a f1			.pastdmark: pop af  
267b			endm  
# End of macro DMARK
267b						CALLMONITOR 
267b cd 17 16			call break_point_state  
267e				endm  
# End of macro CALLMONITOR
267e					endif 
267e			 
267e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
267e cd 9b 1d			call macro_dsp_valuehl 
2681				endm 
# End of macro FORTH_DSP_VALUEHL
2681			 
2681			;		push hl 
2681			 
2681					; destroy value TOS 
2681			 
2681					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2681 cd 53 1e			call macro_forth_dsp_pop 
2684				endm 
# End of macro FORTH_DSP_POP
2684			 
2684						 
2684			;		pop hl 
2684			 
2684					; how to do a call with hl???? save SP? 
2684 cd b6 1e				call forth_call_hl 
2687			 
2687			 
2687					; TODO push value back onto stack for another op etc 
2687			 
2687 cd a4 1b				call forth_push_numhl 
268a					NEXTW 
268a c3 0d 1f			jp macro_next 
268d				endm 
# End of macro NEXTW
268d			.DEPTH: 
268d				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
268d 24				db WORD_SYS_CORE+OPCODE_DEPTH             
268e ca 26			dw .OVER            
2690 06				db 5 + 1 
2691 .. 00			db "DEPTH",0              
2697				endm 
# End of macro CWHEAD
2697			; | DEPTH ( -- u ) Push count of stack | DONE 
2697					; take current TOS and remove from base value div by two to get count 
2697					if DEBUG_FORTH_WORDS_KEY 
2697						DMARK "DEP" 
2697 f5				push af  
2698 3a ac 26			ld a, (.dmark)  
269b 32 77 fb			ld (debug_mark),a  
269e 3a ad 26			ld a, (.dmark+1)  
26a1 32 78 fb			ld (debug_mark+1),a  
26a4 3a ae 26			ld a, (.dmark+2)  
26a7 32 79 fb			ld (debug_mark+2),a  
26aa 18 03			jr .pastdmark  
26ac ..			.dmark: db "DEP"  
26af f1			.pastdmark: pop af  
26b0			endm  
# End of macro DMARK
26b0						CALLMONITOR 
26b0 cd 17 16			call break_point_state  
26b3				endm  
# End of macro CALLMONITOR
26b3					endif 
26b3			 
26b3			 
26b3 2a 1e f8			ld hl, (cli_data_sp) 
26b6 11 98 f3			ld de, cli_data_stack 
26b9 ed 52			sbc hl,de 
26bb				 
26bb				; div by size of stack item 
26bb			 
26bb 5d				ld e,l 
26bc 0e 03			ld c, 3 
26be cd 5b 0c			call Div8 
26c1			 
26c1 6f				ld l,a 
26c2 26 00			ld h,0 
26c4			 
26c4				;srl h 
26c4				;rr l 
26c4			 
26c4 cd a4 1b				call forth_push_numhl 
26c7					NEXTW 
26c7 c3 0d 1f			jp macro_next 
26ca				endm 
# End of macro NEXTW
26ca			.OVER: 
26ca				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
26ca 42				db WORD_SYS_CORE+46             
26cb 11 27			dw .PAUSE            
26cd 05				db 4 + 1 
26ce .. 00			db "OVER",0              
26d3				endm 
# End of macro CWHEAD
26d3			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
26d3					if DEBUG_FORTH_WORDS_KEY 
26d3						DMARK "OVR" 
26d3 f5				push af  
26d4 3a e8 26			ld a, (.dmark)  
26d7 32 77 fb			ld (debug_mark),a  
26da 3a e9 26			ld a, (.dmark+1)  
26dd 32 78 fb			ld (debug_mark+1),a  
26e0 3a ea 26			ld a, (.dmark+2)  
26e3 32 79 fb			ld (debug_mark+2),a  
26e6 18 03			jr .pastdmark  
26e8 ..			.dmark: db "OVR"  
26eb f1			.pastdmark: pop af  
26ec			endm  
# End of macro DMARK
26ec						CALLMONITOR 
26ec cd 17 16			call break_point_state  
26ef				endm  
# End of macro CALLMONITOR
26ef					endif 
26ef			 
26ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26ef cd 9b 1d			call macro_dsp_valuehl 
26f2				endm 
# End of macro FORTH_DSP_VALUEHL
26f2 e5					push hl    ; n2 
26f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f3 cd 53 1e			call macro_forth_dsp_pop 
26f6				endm 
# End of macro FORTH_DSP_POP
26f6			 
26f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f6 cd 9b 1d			call macro_dsp_valuehl 
26f9				endm 
# End of macro FORTH_DSP_VALUEHL
26f9 e5					push hl    ; n1 
26fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26fa cd 53 1e			call macro_forth_dsp_pop 
26fd				endm 
# End of macro FORTH_DSP_POP
26fd			 
26fd d1					pop de     ; n1 
26fe e1					pop hl     ; n2 
26ff			 
26ff d5					push de 
2700 e5					push hl 
2701 d5					push de 
2702			 
2702					; push back  
2702			 
2702 e1					pop hl 
2703 cd a4 1b				call forth_push_numhl 
2706 e1					pop hl 
2707 cd a4 1b				call forth_push_numhl 
270a e1					pop hl 
270b cd a4 1b				call forth_push_numhl 
270e					NEXTW 
270e c3 0d 1f			jp macro_next 
2711				endm 
# End of macro NEXTW
2711			 
2711			.PAUSE: 
2711				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2711 43				db WORD_SYS_CORE+47             
2712 46 27			dw .PAUSES            
2714 08				db 7 + 1 
2715 .. 00			db "PAUSEMS",0              
271d				endm 
# End of macro CWHEAD
271d			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
271d					if DEBUG_FORTH_WORDS_KEY 
271d						DMARK "PMS" 
271d f5				push af  
271e 3a 32 27			ld a, (.dmark)  
2721 32 77 fb			ld (debug_mark),a  
2724 3a 33 27			ld a, (.dmark+1)  
2727 32 78 fb			ld (debug_mark+1),a  
272a 3a 34 27			ld a, (.dmark+2)  
272d 32 79 fb			ld (debug_mark+2),a  
2730 18 03			jr .pastdmark  
2732 ..			.dmark: db "PMS"  
2735 f1			.pastdmark: pop af  
2736			endm  
# End of macro DMARK
2736						CALLMONITOR 
2736 cd 17 16			call break_point_state  
2739				endm  
# End of macro CALLMONITOR
2739					endif 
2739					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2739 cd 9b 1d			call macro_dsp_valuehl 
273c				endm 
# End of macro FORTH_DSP_VALUEHL
273c			;		push hl    ; n2 
273c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
273c cd 53 1e			call macro_forth_dsp_pop 
273f				endm 
# End of macro FORTH_DSP_POP
273f			;		pop hl 
273f			 
273f 7d					ld a, l 
2740 cd 2a 0a				call aDelayInMS 
2743				       NEXTW 
2743 c3 0d 1f			jp macro_next 
2746				endm 
# End of macro NEXTW
2746			.PAUSES:  
2746				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2746 44				db WORD_SYS_CORE+48             
2747 b5 27			dw .ROT            
2749 06				db 5 + 1 
274a .. 00			db "PAUSE",0              
2750				endm 
# End of macro CWHEAD
2750			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2750					if DEBUG_FORTH_WORDS_KEY 
2750						DMARK "PAU" 
2750 f5				push af  
2751 3a 65 27			ld a, (.dmark)  
2754 32 77 fb			ld (debug_mark),a  
2757 3a 66 27			ld a, (.dmark+1)  
275a 32 78 fb			ld (debug_mark+1),a  
275d 3a 67 27			ld a, (.dmark+2)  
2760 32 79 fb			ld (debug_mark+2),a  
2763 18 03			jr .pastdmark  
2765 ..			.dmark: db "PAU"  
2768 f1			.pastdmark: pop af  
2769			endm  
# End of macro DMARK
2769						CALLMONITOR 
2769 cd 17 16			call break_point_state  
276c				endm  
# End of macro CALLMONITOR
276c					endif 
276c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
276c cd 9b 1d			call macro_dsp_valuehl 
276f				endm 
# End of macro FORTH_DSP_VALUEHL
276f			;		push hl    ; n2 
276f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
276f cd 53 1e			call macro_forth_dsp_pop 
2772				endm 
# End of macro FORTH_DSP_POP
2772			;		pop hl 
2772 45					ld b, l 
2773					if DEBUG_FORTH_WORDS 
2773						DMARK "PAU" 
2773 f5				push af  
2774 3a 88 27			ld a, (.dmark)  
2777 32 77 fb			ld (debug_mark),a  
277a 3a 89 27			ld a, (.dmark+1)  
277d 32 78 fb			ld (debug_mark+1),a  
2780 3a 8a 27			ld a, (.dmark+2)  
2783 32 79 fb			ld (debug_mark+2),a  
2786 18 03			jr .pastdmark  
2788 ..			.dmark: db "PAU"  
278b f1			.pastdmark: pop af  
278c			endm  
# End of macro DMARK
278c						CALLMONITOR 
278c cd 17 16			call break_point_state  
278f				endm  
# End of macro CALLMONITOR
278f					endif 
278f c5			.pauses1:	push bc 
2790 cd 45 0a				call delay1s 
2793 c1					pop bc 
2794					if DEBUG_FORTH_WORDS 
2794						DMARK "PA1" 
2794 f5				push af  
2795 3a a9 27			ld a, (.dmark)  
2798 32 77 fb			ld (debug_mark),a  
279b 3a aa 27			ld a, (.dmark+1)  
279e 32 78 fb			ld (debug_mark+1),a  
27a1 3a ab 27			ld a, (.dmark+2)  
27a4 32 79 fb			ld (debug_mark+2),a  
27a7 18 03			jr .pastdmark  
27a9 ..			.dmark: db "PA1"  
27ac f1			.pastdmark: pop af  
27ad			endm  
# End of macro DMARK
27ad						CALLMONITOR 
27ad cd 17 16			call break_point_state  
27b0				endm  
# End of macro CALLMONITOR
27b0					endif 
27b0 10 dd				djnz .pauses1 
27b2			 
27b2				       NEXTW 
27b2 c3 0d 1f			jp macro_next 
27b5				endm 
# End of macro NEXTW
27b5			.ROT: 
27b5				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
27b5 45				db WORD_SYS_CORE+49             
27b6 03 28			dw .UWORDS            
27b8 04				db 3 + 1 
27b9 .. 00			db "ROT",0              
27bd				endm 
# End of macro CWHEAD
27bd			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
27bd					if DEBUG_FORTH_WORDS_KEY 
27bd						DMARK "ROT" 
27bd f5				push af  
27be 3a d2 27			ld a, (.dmark)  
27c1 32 77 fb			ld (debug_mark),a  
27c4 3a d3 27			ld a, (.dmark+1)  
27c7 32 78 fb			ld (debug_mark+1),a  
27ca 3a d4 27			ld a, (.dmark+2)  
27cd 32 79 fb			ld (debug_mark+2),a  
27d0 18 03			jr .pastdmark  
27d2 ..			.dmark: db "ROT"  
27d5 f1			.pastdmark: pop af  
27d6			endm  
# End of macro DMARK
27d6						CALLMONITOR 
27d6 cd 17 16			call break_point_state  
27d9				endm  
# End of macro CALLMONITOR
27d9					endif 
27d9			 
27d9					FORTH_DSP_VALUEHL 
27d9 cd 9b 1d			call macro_dsp_valuehl 
27dc				endm 
# End of macro FORTH_DSP_VALUEHL
27dc e5					push hl    ; u3  
27dd			 
27dd					FORTH_DSP_POP 
27dd cd 53 1e			call macro_forth_dsp_pop 
27e0				endm 
# End of macro FORTH_DSP_POP
27e0			   
27e0					FORTH_DSP_VALUEHL 
27e0 cd 9b 1d			call macro_dsp_valuehl 
27e3				endm 
# End of macro FORTH_DSP_VALUEHL
27e3 e5					push hl     ; u2 
27e4			 
27e4					FORTH_DSP_POP 
27e4 cd 53 1e			call macro_forth_dsp_pop 
27e7				endm 
# End of macro FORTH_DSP_POP
27e7			 
27e7					FORTH_DSP_VALUEHL 
27e7 cd 9b 1d			call macro_dsp_valuehl 
27ea				endm 
# End of macro FORTH_DSP_VALUEHL
27ea e5					push hl     ; u1 
27eb			 
27eb					FORTH_DSP_POP 
27eb cd 53 1e			call macro_forth_dsp_pop 
27ee				endm 
# End of macro FORTH_DSP_POP
27ee			 
27ee c1					pop bc      ; u1 
27ef e1					pop hl      ; u2 
27f0 d1					pop de      ; u3 
27f1			 
27f1			 
27f1 c5					push bc 
27f2 d5					push de 
27f3 e5					push hl 
27f4			 
27f4			 
27f4 e1					pop hl 
27f5 cd a4 1b				call forth_push_numhl 
27f8			 
27f8 e1					pop hl 
27f9 cd a4 1b				call forth_push_numhl 
27fc			 
27fc e1					pop hl 
27fd cd a4 1b				call forth_push_numhl 
2800					 
2800			 
2800			 
2800			 
2800			 
2800			 
2800				       NEXTW 
2800 c3 0d 1f			jp macro_next 
2803				endm 
# End of macro NEXTW
2803			 
2803			.UWORDS: 
2803				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2803 50				db WORD_SYS_CORE+60             
2804 c5 28			dw .BP            
2806 07				db 6 + 1 
2807 .. 00			db "UWORDS",0              
280e				endm 
# End of macro CWHEAD
280e			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
280e			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
280e			; | | Following the count are the individual words. 
280e			; | | 
280e			; | | e.g. UWORDS 
280e			; | | BOX DIRLIST 2 
280e			; | |  
280e			; | | Can be used to save the words to storage via: 
280e			; | | UWORDS $01 DO $01 APPEND LOOP 
280e				if DEBUG_FORTH_WORDS_KEY 
280e					DMARK "UWR" 
280e f5				push af  
280f 3a 23 28			ld a, (.dmark)  
2812 32 77 fb			ld (debug_mark),a  
2815 3a 24 28			ld a, (.dmark+1)  
2818 32 78 fb			ld (debug_mark+1),a  
281b 3a 25 28			ld a, (.dmark+2)  
281e 32 79 fb			ld (debug_mark+2),a  
2821 18 03			jr .pastdmark  
2823 ..			.dmark: db "UWR"  
2826 f1			.pastdmark: pop af  
2827			endm  
# End of macro DMARK
2827					CALLMONITOR 
2827 cd 17 16			call break_point_state  
282a				endm  
# End of macro CALLMONITOR
282a				endif 
282a 21 00 80				ld hl, baseram 
282d					;ld hl, baseusermem 
282d 01 00 00				ld bc, 0    ; start a counter 
2830			 
2830				; skip dict stub 
2830			 
2830 cd 5e 20				call forth_tok_next 
2833			 
2833			 
2833			; while we have words to look for 
2833			 
2833 7e			.douscan:	ld a, (hl)      
2834				if DEBUG_FORTH_WORDS 
2834					DMARK "UWs" 
2834 f5				push af  
2835 3a 49 28			ld a, (.dmark)  
2838 32 77 fb			ld (debug_mark),a  
283b 3a 4a 28			ld a, (.dmark+1)  
283e 32 78 fb			ld (debug_mark+1),a  
2841 3a 4b 28			ld a, (.dmark+2)  
2844 32 79 fb			ld (debug_mark+2),a  
2847 18 03			jr .pastdmark  
2849 ..			.dmark: db "UWs"  
284c f1			.pastdmark: pop af  
284d			endm  
# End of macro DMARK
284d					CALLMONITOR 
284d cd 17 16			call break_point_state  
2850				endm  
# End of macro CALLMONITOR
2850				endif 
2850 fe 00				cp WORD_SYS_END 
2852 28 4d				jr z, .udone 
2854 fe 01				cp WORD_SYS_UWORD 
2856 20 44				jr nz, .nuword 
2858			 
2858				if DEBUG_FORTH_WORDS 
2858					DMARK "UWu" 
2858 f5				push af  
2859 3a 6d 28			ld a, (.dmark)  
285c 32 77 fb			ld (debug_mark),a  
285f 3a 6e 28			ld a, (.dmark+1)  
2862 32 78 fb			ld (debug_mark+1),a  
2865 3a 6f 28			ld a, (.dmark+2)  
2868 32 79 fb			ld (debug_mark+2),a  
286b 18 03			jr .pastdmark  
286d ..			.dmark: db "UWu"  
2870 f1			.pastdmark: pop af  
2871			endm  
# End of macro DMARK
2871					CALLMONITOR 
2871 cd 17 16			call break_point_state  
2874				endm  
# End of macro CALLMONITOR
2874				endif 
2874					; we have a uword so push its name to the stack 
2874			 
2874 e5				   	push hl  ; save so we can move to next dict block 
2875			 
2875					; skip opcode 
2875 23					inc hl  
2876					; skip next ptr 
2876 23					inc hl  
2877 23					inc hl 
2878					; skip len 
2878 23					inc hl 
2879				if DEBUG_FORTH_WORDS 
2879					DMARK "UWt" 
2879 f5				push af  
287a 3a 8e 28			ld a, (.dmark)  
287d 32 77 fb			ld (debug_mark),a  
2880 3a 8f 28			ld a, (.dmark+1)  
2883 32 78 fb			ld (debug_mark+1),a  
2886 3a 90 28			ld a, (.dmark+2)  
2889 32 79 fb			ld (debug_mark+2),a  
288c 18 03			jr .pastdmark  
288e ..			.dmark: db "UWt"  
2891 f1			.pastdmark: pop af  
2892			endm  
# End of macro DMARK
2892					CALLMONITOR 
2892 cd 17 16			call break_point_state  
2895				endm  
# End of macro CALLMONITOR
2895				endif 
2895 03					inc bc 
2896			 
2896 c5					push bc 
2897 cd 12 1c				call forth_push_str 
289a c1					pop bc 
289b			 
289b e1					pop hl 	 
289c			 
289c cd 5e 20		.nuword:	call forth_tok_next 
289f 18 92				jr .douscan  
28a1			 
28a1			.udone:		 ; push count of uwords found 
28a1 c5					push bc 
28a2 e1					pop hl 
28a3			 
28a3				if DEBUG_FORTH_WORDS 
28a3					DMARK "UWc" 
28a3 f5				push af  
28a4 3a b8 28			ld a, (.dmark)  
28a7 32 77 fb			ld (debug_mark),a  
28aa 3a b9 28			ld a, (.dmark+1)  
28ad 32 78 fb			ld (debug_mark+1),a  
28b0 3a ba 28			ld a, (.dmark+2)  
28b3 32 79 fb			ld (debug_mark+2),a  
28b6 18 03			jr .pastdmark  
28b8 ..			.dmark: db "UWc"  
28bb f1			.pastdmark: pop af  
28bc			endm  
# End of macro DMARK
28bc					CALLMONITOR 
28bc cd 17 16			call break_point_state  
28bf				endm  
# End of macro CALLMONITOR
28bf				endif 
28bf cd a4 1b				call forth_push_numhl 
28c2			 
28c2			 
28c2				       NEXTW 
28c2 c3 0d 1f			jp macro_next 
28c5				endm 
# End of macro NEXTW
28c5			 
28c5			.BP: 
28c5				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
28c5 54				db WORD_SYS_CORE+64             
28c6 fb 28			dw .MONITOR            
28c8 03				db 2 + 1 
28c9 .. 00			db "BP",0              
28cc				endm 
# End of macro CWHEAD
28cc			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
28cc			; | | $00 Will enable the break points within specific code paths 
28cc			; | | $01 Will disable break points 
28cc			; | |  
28cc			; | | By default break points are off. Either the above can be used to enable them 
28cc			; | | or if a key is held down during start up the spashscreen will appear to freeze 
28cc			; | | and on release of the pressed key a message will be disaplayed to notify 
28cc			; | | that break points are enabled. Pressing any key will then continue boot process. 
28cc					; get byte count 
28cc					if DEBUG_FORTH_WORDS_KEY 
28cc						DMARK "BP." 
28cc f5				push af  
28cd 3a e1 28			ld a, (.dmark)  
28d0 32 77 fb			ld (debug_mark),a  
28d3 3a e2 28			ld a, (.dmark+1)  
28d6 32 78 fb			ld (debug_mark+1),a  
28d9 3a e3 28			ld a, (.dmark+2)  
28dc 32 79 fb			ld (debug_mark+2),a  
28df 18 03			jr .pastdmark  
28e1 ..			.dmark: db "BP."  
28e4 f1			.pastdmark: pop af  
28e5			endm  
# End of macro DMARK
28e5						CALLMONITOR 
28e5 cd 17 16			call break_point_state  
28e8				endm  
# End of macro CALLMONITOR
28e8					endif 
28e8			 
28e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28e8 cd 9b 1d			call macro_dsp_valuehl 
28eb				endm 
# End of macro FORTH_DSP_VALUEHL
28eb			 
28eb			;		push hl 
28eb			 
28eb					; destroy value TOS 
28eb			 
28eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28eb cd 53 1e			call macro_forth_dsp_pop 
28ee				endm 
# End of macro FORTH_DSP_POP
28ee			 
28ee			;		pop hl 
28ee			 
28ee 3e 00				ld a,0 
28f0 bd					cp l 
28f1 28 02				jr z, .bpset 
28f3 3e 2a				ld a, '*' 
28f5			 
28f5 32 30 ee		.bpset:		ld (os_view_disable), a 
28f8			 
28f8			 
28f8					NEXTW 
28f8 c3 0d 1f			jp macro_next 
28fb				endm 
# End of macro NEXTW
28fb			 
28fb			 
28fb			.MONITOR: 
28fb				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28fb 55				db WORD_SYS_CORE+65             
28fc 2e 29			dw .MALLOC            
28fe 08				db 7 + 1 
28ff .. 00			db "MONITOR",0              
2907				endm 
# End of macro CWHEAD
2907			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2907			; | | At start the current various registers will be displayed with contents. 
2907			; | | Top right corner will show the most recent debug marker seen. 
2907			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2907			; | | and the return stack pointer (RSP). 
2907			; | | Pressing: 
2907			; | |    1 - Initial screen 
2907			; | |    2 - Display a data dump of HL 
2907			; | |    3 - Display a data dump of DE 
2907			; | |    4 - Display a data dump of BC 
2907			; | |    5 - Display a data dump of HL 
2907			; | |    6 - Display a data dump of DSP 
2907			; | |    7 - Display a data dump of RSP 
2907			; | |    8 - Display a data dump of what is at DSP 
2907			; | |    9 - Display a data dump of what is at RSP 
2907			; | |    0 - Exit monitor and continue running. This will also enable break points 
2907			; | |    * - Disable break points 
2907			; | |    # - Enter traditional monitor mode 
2907			; | | 
2907			; | | Monitor Mode 
2907			; | | ------------ 
2907			; | | A prompt of '>' will be shown for various commands: 
2907			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2907			; | |    C - Continue display a data dump from the last set address 
2907			; | |    M xxxx - Set start of memory edit at address xx 
2907			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2907			; | |    Q - Return to previous 
2907					if DEBUG_FORTH_WORDS_KEY 
2907						DMARK "MON" 
2907 f5				push af  
2908 3a 1c 29			ld a, (.dmark)  
290b 32 77 fb			ld (debug_mark),a  
290e 3a 1d 29			ld a, (.dmark+1)  
2911 32 78 fb			ld (debug_mark+1),a  
2914 3a 1e 29			ld a, (.dmark+2)  
2917 32 79 fb			ld (debug_mark+2),a  
291a 18 03			jr .pastdmark  
291c ..			.dmark: db "MON"  
291f f1			.pastdmark: pop af  
2920			endm  
# End of macro DMARK
2920						CALLMONITOR 
2920 cd 17 16			call break_point_state  
2923				endm  
# End of macro CALLMONITOR
2923					endif 
2923 3e 00				ld a, 0 
2925 32 30 ee				ld (os_view_disable), a 
2928			 
2928					CALLMONITOR 
2928 cd 17 16			call break_point_state  
292b				endm  
# End of macro CALLMONITOR
292b			 
292b			;	call monitor 
292b			 
292b					NEXTW 
292b c3 0d 1f			jp macro_next 
292e				endm 
# End of macro NEXTW
292e			 
292e			 
292e			.MALLOC: 
292e				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
292e 56				db WORD_SYS_CORE+66             
292f 57 29			dw .MALLOC2            
2931 06				db 5 + 1 
2932 .. 00			db "ALLOT",0              
2938				endm 
# End of macro CWHEAD
2938			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2938					if DEBUG_FORTH_WORDS_KEY 
2938						DMARK "ALL" 
2938 f5				push af  
2939 3a 4d 29			ld a, (.dmark)  
293c 32 77 fb			ld (debug_mark),a  
293f 3a 4e 29			ld a, (.dmark+1)  
2942 32 78 fb			ld (debug_mark+1),a  
2945 3a 4f 29			ld a, (.dmark+2)  
2948 32 79 fb			ld (debug_mark+2),a  
294b 18 03			jr .pastdmark  
294d ..			.dmark: db "ALL"  
2950 f1			.pastdmark: pop af  
2951			endm  
# End of macro DMARK
2951						CALLMONITOR 
2951 cd 17 16			call break_point_state  
2954				endm  
# End of macro CALLMONITOR
2954					endif 
2954 c3 7e 29				jp .mallocc 
2957			.MALLOC2: 
2957				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2957 56				db WORD_SYS_CORE+66             
2958 95 29			dw .FREE            
295a 07				db 6 + 1 
295b .. 00			db "MALLOC",0              
2962				endm 
# End of macro CWHEAD
2962			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2962					; get byte count 
2962					if DEBUG_FORTH_WORDS_KEY 
2962						DMARK "MAL" 
2962 f5				push af  
2963 3a 77 29			ld a, (.dmark)  
2966 32 77 fb			ld (debug_mark),a  
2969 3a 78 29			ld a, (.dmark+1)  
296c 32 78 fb			ld (debug_mark+1),a  
296f 3a 79 29			ld a, (.dmark+2)  
2972 32 79 fb			ld (debug_mark+2),a  
2975 18 03			jr .pastdmark  
2977 ..			.dmark: db "MAL"  
297a f1			.pastdmark: pop af  
297b			endm  
# End of macro DMARK
297b						CALLMONITOR 
297b cd 17 16			call break_point_state  
297e				endm  
# End of macro CALLMONITOR
297e					endif 
297e			.mallocc: 
297e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
297e cd 9b 1d			call macro_dsp_valuehl 
2981				endm 
# End of macro FORTH_DSP_VALUEHL
2981			 
2981			;		push hl 
2981			 
2981					; destroy value TOS 
2981			 
2981					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2981 cd 53 1e			call macro_forth_dsp_pop 
2984				endm 
# End of macro FORTH_DSP_POP
2984			 
2984			;		pop hl 
2984 cd 92 11				call malloc 
2987				if DEBUG_FORTH_MALLOC_GUARD 
2987 f5					push af 
2988 cd f4 0c				call ishlzero 
298b			;		ld a, l 
298b			;		add h 
298b			;		cp 0 
298b f1					pop af 
298c					 
298c cc c8 51				call z,malloc_error 
298f				endif 
298f			 
298f cd a4 1b				call forth_push_numhl 
2992					NEXTW 
2992 c3 0d 1f			jp macro_next 
2995				endm 
# End of macro NEXTW
2995			 
2995			.FREE: 
2995				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2995 57				db WORD_SYS_CORE+67             
2996 c6 29			dw .LIST            
2998 05				db 4 + 1 
2999 .. 00			db "FREE",0              
299e				endm 
# End of macro CWHEAD
299e			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
299e					if DEBUG_FORTH_WORDS_KEY 
299e						DMARK "FRE" 
299e f5				push af  
299f 3a b3 29			ld a, (.dmark)  
29a2 32 77 fb			ld (debug_mark),a  
29a5 3a b4 29			ld a, (.dmark+1)  
29a8 32 78 fb			ld (debug_mark+1),a  
29ab 3a b5 29			ld a, (.dmark+2)  
29ae 32 79 fb			ld (debug_mark+2),a  
29b1 18 03			jr .pastdmark  
29b3 ..			.dmark: db "FRE"  
29b6 f1			.pastdmark: pop af  
29b7			endm  
# End of macro DMARK
29b7						CALLMONITOR 
29b7 cd 17 16			call break_point_state  
29ba				endm  
# End of macro CALLMONITOR
29ba					endif 
29ba					; get address 
29ba			 
29ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29ba cd 9b 1d			call macro_dsp_valuehl 
29bd				endm 
# End of macro FORTH_DSP_VALUEHL
29bd			 
29bd			;		push hl 
29bd			 
29bd					; destroy value TOS 
29bd			 
29bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29bd cd 53 1e			call macro_forth_dsp_pop 
29c0				endm 
# End of macro FORTH_DSP_POP
29c0			 
29c0			;		pop hl 
29c0			if FORTH_ENABLE_MALLOCFREE 
29c0 cd 5c 12				call free 
29c3			endif 
29c3					NEXTW 
29c3 c3 0d 1f			jp macro_next 
29c6				endm 
# End of macro NEXTW
29c6			.LIST: 
29c6				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
29c6 5c				db WORD_SYS_CORE+72             
29c7 89 2b			dw .FORGET            
29c9 05				db 4 + 1 
29ca .. 00			db "LIST",0              
29cf				endm 
# End of macro CWHEAD
29cf			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
29cf			; | | The quoted word must be in upper case. 
29cf				if DEBUG_FORTH_WORDS_KEY 
29cf					DMARK "LST" 
29cf f5				push af  
29d0 3a e4 29			ld a, (.dmark)  
29d3 32 77 fb			ld (debug_mark),a  
29d6 3a e5 29			ld a, (.dmark+1)  
29d9 32 78 fb			ld (debug_mark+1),a  
29dc 3a e6 29			ld a, (.dmark+2)  
29df 32 79 fb			ld (debug_mark+2),a  
29e2 18 03			jr .pastdmark  
29e4 ..			.dmark: db "LST"  
29e7 f1			.pastdmark: pop af  
29e8			endm  
# End of macro DMARK
29e8					CALLMONITOR 
29e8 cd 17 16			call break_point_state  
29eb				endm  
# End of macro CALLMONITOR
29eb				endif 
29eb			 
29eb					FORTH_DSP_VALUEHL 
29eb cd 9b 1d			call macro_dsp_valuehl 
29ee				endm 
# End of macro FORTH_DSP_VALUEHL
29ee			 
29ee e5					push hl 
29ef c1					pop bc 
29f0			 
29f0			; Start format of scratch string 
29f0			 
29f0 21 31 ee				ld hl, scratch 
29f3			 
29f3 3e 3a				ld a, ':' 
29f5 77					ld (hl),a 
29f6 23					inc hl 
29f7 3e 20				ld a, ' ' 
29f9 77					ld (hl), a 
29fa			 
29fa					; Get ptr to the word we need to look up 
29fa			 
29fa			;		FORTH_DSP_VALUEHL 
29fa					;v5 FORTH_DSP_VALUE 
29fa				; TODO type check 
29fa			;		inc hl    ; Skip type check  
29fa			;		push hl 
29fa			;		ex de, hl    ; put into DE 
29fa			 
29fa			 
29fa 21 00 80				ld hl, baseram 
29fd					;ld hl, baseusermem 
29fd			 
29fd e5			push hl   ; sacreifical push 
29fe			 
29fe			.ldouscanm: 
29fe e1				pop hl 
29ff			.ldouscan: 
29ff				if DEBUG_FORTH_WORDS 
29ff					DMARK "LSs" 
29ff f5				push af  
2a00 3a 14 2a			ld a, (.dmark)  
2a03 32 77 fb			ld (debug_mark),a  
2a06 3a 15 2a			ld a, (.dmark+1)  
2a09 32 78 fb			ld (debug_mark+1),a  
2a0c 3a 16 2a			ld a, (.dmark+2)  
2a0f 32 79 fb			ld (debug_mark+2),a  
2a12 18 03			jr .pastdmark  
2a14 ..			.dmark: db "LSs"  
2a17 f1			.pastdmark: pop af  
2a18			endm  
# End of macro DMARK
2a18					CALLMONITOR 
2a18 cd 17 16			call break_point_state  
2a1b				endm  
# End of macro CALLMONITOR
2a1b				endif 
2a1b				; skip dict stub 
2a1b cd 5e 20				call forth_tok_next 
2a1e			 
2a1e			 
2a1e			; while we have words to look for 
2a1e			 
2a1e 7e				ld a, (hl)      
2a1f				if DEBUG_FORTH_WORDS 
2a1f					DMARK "LSk" 
2a1f f5				push af  
2a20 3a 34 2a			ld a, (.dmark)  
2a23 32 77 fb			ld (debug_mark),a  
2a26 3a 35 2a			ld a, (.dmark+1)  
2a29 32 78 fb			ld (debug_mark+1),a  
2a2c 3a 36 2a			ld a, (.dmark+2)  
2a2f 32 79 fb			ld (debug_mark+2),a  
2a32 18 03			jr .pastdmark  
2a34 ..			.dmark: db "LSk"  
2a37 f1			.pastdmark: pop af  
2a38			endm  
# End of macro DMARK
2a38					CALLMONITOR 
2a38 cd 17 16			call break_point_state  
2a3b				endm  
# End of macro CALLMONITOR
2a3b				endif 
2a3b fe 00				cp WORD_SYS_END 
2a3d ca 70 2b				jp z, .lunotfound 
2a40 fe 01				cp WORD_SYS_UWORD 
2a42 c2 ff 29				jp nz, .ldouscan 
2a45			 
2a45				if DEBUG_FORTH_WORDS 
2a45					DMARK "LSu" 
2a45 f5				push af  
2a46 3a 5a 2a			ld a, (.dmark)  
2a49 32 77 fb			ld (debug_mark),a  
2a4c 3a 5b 2a			ld a, (.dmark+1)  
2a4f 32 78 fb			ld (debug_mark+1),a  
2a52 3a 5c 2a			ld a, (.dmark+2)  
2a55 32 79 fb			ld (debug_mark+2),a  
2a58 18 03			jr .pastdmark  
2a5a ..			.dmark: db "LSu"  
2a5d f1			.pastdmark: pop af  
2a5e			endm  
# End of macro DMARK
2a5e					CALLMONITOR 
2a5e cd 17 16			call break_point_state  
2a61				endm  
# End of macro CALLMONITOR
2a61				endif 
2a61			 
2a61					; found a uword but is it the one we want... 
2a61			 
2a61 c5					push bc     ; uword to find is on bc 
2a62 d1					pop de 
2a63			 
2a63 e5					push hl  ; to save the ptr 
2a64			 
2a64					; skip opcode 
2a64 23					inc hl  
2a65					; skip next ptr 
2a65 23					inc hl  
2a66 23					inc hl 
2a67					; skip len 
2a67 23					inc hl 
2a68			 
2a68				if DEBUG_FORTH_WORDS 
2a68					DMARK "LSc" 
2a68 f5				push af  
2a69 3a 7d 2a			ld a, (.dmark)  
2a6c 32 77 fb			ld (debug_mark),a  
2a6f 3a 7e 2a			ld a, (.dmark+1)  
2a72 32 78 fb			ld (debug_mark+1),a  
2a75 3a 7f 2a			ld a, (.dmark+2)  
2a78 32 79 fb			ld (debug_mark+2),a  
2a7b 18 03			jr .pastdmark  
2a7d ..			.dmark: db "LSc"  
2a80 f1			.pastdmark: pop af  
2a81			endm  
# End of macro DMARK
2a81					CALLMONITOR 
2a81 cd 17 16			call break_point_state  
2a84				endm  
# End of macro CALLMONITOR
2a84				endif 
2a84 cd 61 11				call strcmp 
2a87 c2 fe 29				jp nz, .ldouscanm 
2a8a				 
2a8a			 
2a8a			 
2a8a					; we have a uword so push its name to the stack 
2a8a			 
2a8a			;	   	push hl  ; save so we can move to next dict block 
2a8a e1			pop hl 
2a8b			 
2a8b				if DEBUG_FORTH_WORDS 
2a8b					DMARK "LSm" 
2a8b f5				push af  
2a8c 3a a0 2a			ld a, (.dmark)  
2a8f 32 77 fb			ld (debug_mark),a  
2a92 3a a1 2a			ld a, (.dmark+1)  
2a95 32 78 fb			ld (debug_mark+1),a  
2a98 3a a2 2a			ld a, (.dmark+2)  
2a9b 32 79 fb			ld (debug_mark+2),a  
2a9e 18 03			jr .pastdmark  
2aa0 ..			.dmark: db "LSm"  
2aa3 f1			.pastdmark: pop af  
2aa4			endm  
# End of macro DMARK
2aa4					CALLMONITOR 
2aa4 cd 17 16			call break_point_state  
2aa7				endm  
# End of macro CALLMONITOR
2aa7				endif 
2aa7			 
2aa7					; skip opcode 
2aa7 23					inc hl  
2aa8					; skip next ptr 
2aa8 23					inc hl  
2aa9 23					inc hl 
2aaa					; skip len 
2aaa 7e					ld a, (hl)   ; save length to add 
2aab				if DEBUG_FORTH_WORDS 
2aab					DMARK "LS2" 
2aab f5				push af  
2aac 3a c0 2a			ld a, (.dmark)  
2aaf 32 77 fb			ld (debug_mark),a  
2ab2 3a c1 2a			ld a, (.dmark+1)  
2ab5 32 78 fb			ld (debug_mark+1),a  
2ab8 3a c2 2a			ld a, (.dmark+2)  
2abb 32 79 fb			ld (debug_mark+2),a  
2abe 18 03			jr .pastdmark  
2ac0 ..			.dmark: db "LS2"  
2ac3 f1			.pastdmark: pop af  
2ac4			endm  
# End of macro DMARK
2ac4					CALLMONITOR 
2ac4 cd 17 16			call break_point_state  
2ac7				endm  
# End of macro CALLMONITOR
2ac7				endif 
2ac7			 
2ac7					; save this location 
2ac7				 
2ac7 e5					push hl 
2ac8			 
2ac8 23					inc hl 
2ac9 11 33 ee				ld de, scratch+2 
2acc 4f					ld c, a 
2acd 06 00				ld b, 0 
2acf			 
2acf				if DEBUG_FORTH_WORDS 
2acf					DMARK "LSn" 
2acf f5				push af  
2ad0 3a e4 2a			ld a, (.dmark)  
2ad3 32 77 fb			ld (debug_mark),a  
2ad6 3a e5 2a			ld a, (.dmark+1)  
2ad9 32 78 fb			ld (debug_mark+1),a  
2adc 3a e6 2a			ld a, (.dmark+2)  
2adf 32 79 fb			ld (debug_mark+2),a  
2ae2 18 03			jr .pastdmark  
2ae4 ..			.dmark: db "LSn"  
2ae7 f1			.pastdmark: pop af  
2ae8			endm  
# End of macro DMARK
2ae8					CALLMONITOR 
2ae8 cd 17 16			call break_point_state  
2aeb				endm  
# End of macro CALLMONITOR
2aeb				endif 
2aeb			 
2aeb					; copy uword name to scratch 
2aeb			 
2aeb ed b0				ldir 
2aed			 
2aed 1b					dec de 
2aee 3e 20				ld a, ' '    ; change null to space 
2af0 12					ld (de), a 
2af1			 
2af1 13					inc de 
2af2			 
2af2 d5					push de 
2af3 c1					pop bc     ; move scratch pointer to end of word name and save it 
2af4			 
2af4 e1					pop hl 
2af5 7e					ld a, (hl) 
2af6					;inc hl 
2af6					; skip word string 
2af6 cd cb 0c				call addatohl 
2af9			 
2af9 23					inc hl 
2afa			 
2afa				if DEBUG_FORTH_WORDS 
2afa					DMARK "LS3" 
2afa f5				push af  
2afb 3a 0f 2b			ld a, (.dmark)  
2afe 32 77 fb			ld (debug_mark),a  
2b01 3a 10 2b			ld a, (.dmark+1)  
2b04 32 78 fb			ld (debug_mark+1),a  
2b07 3a 11 2b			ld a, (.dmark+2)  
2b0a 32 79 fb			ld (debug_mark+2),a  
2b0d 18 03			jr .pastdmark  
2b0f ..			.dmark: db "LS3"  
2b12 f1			.pastdmark: pop af  
2b13			endm  
# End of macro DMARK
2b13					CALLMONITOR 
2b13 cd 17 16			call break_point_state  
2b16				endm  
# End of macro CALLMONITOR
2b16				endif 
2b16					; should now be at the start of the machine code to setup the eval of the uword 
2b16					; now locate the ptr to the string defintion 
2b16			 
2b16					; skip ld hl, 
2b16					; then load the ptr 
2b16			 
2b16 23					inc hl 
2b17 5e					ld e, (hl) 
2b18 23					inc hl 
2b19 56					ld d, (hl) 
2b1a eb					ex de, hl 
2b1b			 
2b1b			 
2b1b				if DEBUG_FORTH_WORDS 
2b1b					DMARK "LSt" 
2b1b f5				push af  
2b1c 3a 30 2b			ld a, (.dmark)  
2b1f 32 77 fb			ld (debug_mark),a  
2b22 3a 31 2b			ld a, (.dmark+1)  
2b25 32 78 fb			ld (debug_mark+1),a  
2b28 3a 32 2b			ld a, (.dmark+2)  
2b2b 32 79 fb			ld (debug_mark+2),a  
2b2e 18 03			jr .pastdmark  
2b30 ..			.dmark: db "LSt"  
2b33 f1			.pastdmark: pop af  
2b34			endm  
# End of macro DMARK
2b34					CALLMONITOR 
2b34 cd 17 16			call break_point_state  
2b37				endm  
# End of macro CALLMONITOR
2b37				endif 
2b37			 
2b37			; cant push right now due to tokenised strings  
2b37			 
2b37			; get the destination of where to copy this definition to. 
2b37			 
2b37 c5					push bc 
2b38 d1					pop de 
2b39			 
2b39 7e			.listl:         ld a,(hl) 
2b3a fe 00				cp 0 
2b3c 28 09				jr z, .lreplsp     ; replace zero with space 
2b3e fe 7f				cp FORTH_END_BUFFER 
2b40 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b42				 
2b42					; just copy this char as is then 
2b42			 
2b42 12					ld (de), a 
2b43			 
2b43 23			.listnxt:	inc hl 
2b44 13					inc de 
2b45 18 f2				jr .listl 
2b47			 
2b47 3e 20		.lreplsp:	ld a,' ' 
2b49 12					ld (de), a 
2b4a 18 f7				jr .listnxt 
2b4c			 
2b4c			; close up uword def 
2b4c			 
2b4c			.listdone: 
2b4c 3e 00				ld a, 0 
2b4e 12					ld (de), a 
2b4f			 
2b4f			; now have def so clean up and push to stack 
2b4f			 
2b4f 21 31 ee				ld hl, scratch 
2b52				if DEBUG_FORTH_WORDS 
2b52					DMARK "Ltp" 
2b52 f5				push af  
2b53 3a 67 2b			ld a, (.dmark)  
2b56 32 77 fb			ld (debug_mark),a  
2b59 3a 68 2b			ld a, (.dmark+1)  
2b5c 32 78 fb			ld (debug_mark+1),a  
2b5f 3a 69 2b			ld a, (.dmark+2)  
2b62 32 79 fb			ld (debug_mark+2),a  
2b65 18 03			jr .pastdmark  
2b67 ..			.dmark: db "Ltp"  
2b6a f1			.pastdmark: pop af  
2b6b			endm  
# End of macro DMARK
2b6b					CALLMONITOR 
2b6b cd 17 16			call break_point_state  
2b6e				endm  
# End of macro CALLMONITOR
2b6e				endif 
2b6e			 
2b6e 18 06			jr .listpush 
2b70			 
2b70			;.lnuword:	pop hl 
2b70			;		call forth_tok_next 
2b70			;		jp .ldouscan  
2b70			 
2b70			.lunotfound:		  
2b70			 
2b70			 
2b70					 
2b70					FORTH_DSP_POP 
2b70 cd 53 1e			call macro_forth_dsp_pop 
2b73				endm 
# End of macro FORTH_DSP_POP
2b73 21 7c 2b				ld hl, .luno 
2b76						 
2b76			 
2b76			.listpush: 
2b76 cd 12 1c				call forth_push_str 
2b79			 
2b79			 
2b79			 
2b79					NEXTW 
2b79 c3 0d 1f			jp macro_next 
2b7c				endm 
# End of macro NEXTW
2b7c			 
2b7c .. 00		.luno:    db "Not found",0 
2b86			 
2b86			 
2b86			 
2b86			 
2b86			 
2b86			;		push hl   ; save pointer to start of uword def string 
2b86			; 
2b86			;; look for FORTH_EOL_LINE 
2b86			;		ld a, FORTH_END_BUFFER 
2b86			;		call strlent 
2b86			; 
2b86			;		inc hl		 ; space for coln def 
2b86			;		inc hl 
2b86			;		inc hl          ; space for terms 
2b86			;		inc hl 
2b86			; 
2b86			;		ld a, 20   ; TODO get actual length 
2b86			;		call addatohl    ; include a random amount of room for the uword name 
2b86			; 
2b86			;		 
2b86			;	if DEBUG_FORTH_WORDS 
2b86			;		DMARK "Lt1" 
2b86			;		CALLMONITOR 
2b86			;	endif 
2b86			;		 
2b86			; 
2b86			;; malloc space for the string because we cant change it 
2b86			; 
2b86			;		call malloc 
2b86			;	if DEBUG_FORTH_MALLOC_GUARD 
2b86			;		push af 
2b86			;		call ishlzero 
2b86			;		pop af 
2b86			;		 
2b86			;		call z,malloc_error 
2b86			;	endif 
2b86			; 
2b86			;	if DEBUG_FORTH_WORDS 
2b86			;		DMARK "Lt2" 
2b86			;		CALLMONITOR 
2b86			;	endif 
2b86			;		pop de 
2b86			;		push hl    ; push the malloc to release later 
2b86			;		push hl   ;  push back a copy for the later stack push 
2b86			;		 
2b86			;; copy the string swapping out the zero terms for spaces 
2b86			; 
2b86			;		; de has our source 
2b86			;		; hl has our dest 
2b86			; 
2b86			;; add the coln def 
2b86			; 
2b86			;		ld a, ':' 
2b86			;		ld (hl), a 
2b86			;		inc hl 
2b86			;		ld a, ' ' 
2b86			;		ld (hl), a 
2b86			;		inc hl 
2b86			; 
2b86			;; add the uname word 
2b86			;		push de   ; save our string for now 
2b86			;		ex de, hl 
2b86			; 
2b86			;		FORTH_DSP_VALUE 
2b86			;		;v5 FORTH_DSP_VALUE 
2b86			; 
2b86			;		inc hl   ; skip type but we know by now this is OK 
2b86			; 
2b86			;.luword:	ld a,(hl) 
2b86			;		cp 0 
2b86			;		jr z, .luword2 
2b86			;		ld (de), a 
2b86			;		inc de 
2b86			;		inc hl 
2b86			;		jr .luword 
2b86			; 
2b86			;.luword2:	ld a, ' ' 
2b86			;		ld (de), a 
2b86			;;		inc hl 
2b86			;;		inc de 
2b86			;;		ld (de), a 
2b86			;;		inc hl 
2b86			;		inc de 
2b86			; 
2b86			;		ex de, hl 
2b86			;		pop de 
2b86			;		 
2b86			;		 
2b86			; 
2b86			;; detoken that string and copy it 
2b86			; 
2b86			;	if DEBUG_FORTH_WORDS 
2b86			;		DMARK "Lt2" 
2b86			;		CALLMONITOR 
2b86			;	endif 
2b86			;.ldetok:	ld a, (de) 
2b86			;		cp FORTH_END_BUFFER 
2b86			;		jr z, .ldetokend 
2b86			;		; swap out any zero term for space 
2b86			;		cp 0 
2b86			;		jr nz, .ldetoknext 
2b86			;		ld a, ' ' 
2b86			; 
2b86			;	if DEBUG_FORTH_WORDS 
2b86			;		DMARK "LtS" 
2b86			;		CALLMONITOR 
2b86			;	endif 
2b86			;.ldetoknext:	ld (hl), a 
2b86			;		inc de 
2b86			;		inc hl 
2b86			;		jr .ldetok 
2b86			; 
2b86			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b86			;		ld (hl), a  
2b86			; 
2b86			;; free that temp malloc 
2b86			; 
2b86			;		pop hl    
2b86			; 
2b86			;	if DEBUG_FORTH_WORDS 
2b86			;		DMARK "Lt4" 
2b86			;		CALLMONITOR 
2b86			;	endif 
2b86			;		call forth_apushstrhl 
2b86			; 
2b86			;		; get rid of temp malloc area 
2b86			; 
2b86			;		pop hl 
2b86			;		call free 
2b86			; 
2b86			;		jr .ludone 
2b86			; 
2b86			;.lnuword:	pop hl 
2b86			;		call forth_tok_next 
2b86			;		jp .ldouscan  
2b86			; 
2b86			;.ludone:		 pop hl 
2b86			; 
2b86					NEXTW 
2b86 c3 0d 1f			jp macro_next 
2b89				endm 
# End of macro NEXTW
2b89			 
2b89			.FORGET: 
2b89				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b89 5d				db WORD_SYS_CORE+73             
2b8a 02 2c			dw .NOP            
2b8c 07				db 6 + 1 
2b8d .. 00			db "FORGET",0              
2b94				endm 
# End of macro CWHEAD
2b94			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b94			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b94			; | |  
2b94			; | | e.g. "MORE" forget 
2b94					if DEBUG_FORTH_WORDS_KEY 
2b94						DMARK "FRG" 
2b94 f5				push af  
2b95 3a a9 2b			ld a, (.dmark)  
2b98 32 77 fb			ld (debug_mark),a  
2b9b 3a aa 2b			ld a, (.dmark+1)  
2b9e 32 78 fb			ld (debug_mark+1),a  
2ba1 3a ab 2b			ld a, (.dmark+2)  
2ba4 32 79 fb			ld (debug_mark+2),a  
2ba7 18 03			jr .pastdmark  
2ba9 ..			.dmark: db "FRG"  
2bac f1			.pastdmark: pop af  
2bad			endm  
# End of macro DMARK
2bad						CALLMONITOR 
2bad cd 17 16			call break_point_state  
2bb0				endm  
# End of macro CALLMONITOR
2bb0					endif 
2bb0			 
2bb0				; find uword 
2bb0			        ; update start of word with "_" 
2bb0				; replace uword with deleted flag 
2bb0			 
2bb0			 
2bb0			;	if DEBUG_FORTH_WORDS 
2bb0			;		DMARK "FOG" 
2bb0			;		CALLMONITOR 
2bb0			;	endif 
2bb0			 
2bb0			 
2bb0					; Get ptr to the word we need to look up 
2bb0			 
2bb0					FORTH_DSP_VALUEHL 
2bb0 cd 9b 1d			call macro_dsp_valuehl 
2bb3				endm 
# End of macro FORTH_DSP_VALUEHL
2bb3					;v5 FORTH_DSP_VALUE 
2bb3				; TODO type check 
2bb3			;		inc hl    ; Skip type check  
2bb3 e5					push hl 
2bb4 c1					pop bc 
2bb5			;		ex de, hl    ; put into DE 
2bb5			 
2bb5			 
2bb5 21 00 80				ld hl, baseram 
2bb8					;ld hl, baseusermem 
2bb8			 
2bb8				; skip dict stub 
2bb8			;	call forth_tok_next 
2bb8 e5			push hl   ; sacreifical push 
2bb9			 
2bb9			.fldouscanm: 
2bb9 e1				pop hl 
2bba			.fldouscan: 
2bba			;	if DEBUG_FORTH_WORDS 
2bba			;		DMARK "LSs" 
2bba			;		CALLMONITOR 
2bba			;	endif 
2bba				; skip dict stub 
2bba cd 5e 20				call forth_tok_next 
2bbd			 
2bbd			 
2bbd			; while we have words to look for 
2bbd			 
2bbd 7e				ld a, (hl)      
2bbe			;	if DEBUG_FORTH_WORDS 
2bbe			;		DMARK "LSk" 
2bbe			;		CALLMONITOR 
2bbe			;	endif 
2bbe fe 00				cp WORD_SYS_END 
2bc0 ca fc 2b				jp z, .flunotfound 
2bc3 fe 01				cp WORD_SYS_UWORD 
2bc5 c2 ba 2b				jp nz, .fldouscan 
2bc8			 
2bc8			;	if DEBUG_FORTH_WORDS 
2bc8			;		DMARK "LSu" 
2bc8			;		CALLMONITOR 
2bc8			;	endif 
2bc8			 
2bc8					; found a uword but is it the one we want... 
2bc8			 
2bc8 c5					push bc     ; uword to find is on bc 
2bc9 d1					pop de 
2bca			 
2bca e5					push hl  ; to save the ptr 
2bcb			 
2bcb					; skip opcode 
2bcb 23					inc hl  
2bcc					; skip next ptr 
2bcc 23					inc hl  
2bcd 23					inc hl 
2bce					; skip len 
2bce 23					inc hl 
2bcf			 
2bcf			;	if DEBUG_FORTH_WORDS 
2bcf			;		DMARK "LSc" 
2bcf			;		CALLMONITOR 
2bcf			;	endif 
2bcf cd 61 11				call strcmp 
2bd2 c2 b9 2b				jp nz, .fldouscanm 
2bd5			; 
2bd5			; 
2bd5			;; while we have words to look for 
2bd5			; 
2bd5			;.fdouscan:	ld a, (hl)      
2bd5			;	if DEBUG_FORTH_WORDS 
2bd5			;		DMARK "LSs" 
2bd5			;		CALLMONITOR 
2bd5			;	endif 
2bd5			;		cp WORD_SYS_END 
2bd5			;		jp z, .fudone 
2bd5			;		cp WORD_SYS_UWORD 
2bd5			;		jp nz, .fnuword 
2bd5			; 
2bd5			;	if DEBUG_FORTH_WORDS 
2bd5			;		DMARK "FGu" 
2bd5			;		CALLMONITOR 
2bd5			;	endif 
2bd5			; 
2bd5			;		; found a uword but is it the one we want... 
2bd5			; 
2bd5			; 
2bd5			;	        pop de   ; get back the dsp name 
2bd5			;		push de 
2bd5			; 
2bd5			;		push hl  ; to save the ptr 
2bd5			; 
2bd5			;		; skip opcode 
2bd5			;		inc hl  
2bd5			;		; skip next ptr 
2bd5			;		inc hl  
2bd5			;		inc hl 
2bd5			;		; skip len 
2bd5			;		inc hl 
2bd5			; 
2bd5			;	if DEBUG_FORTH_WORDS 
2bd5			;		DMARK "FGc" 
2bd5			;		CALLMONITOR 
2bd5			;	endif 
2bd5			;		call strcmp 
2bd5			;		jp nz, .fnuword 
2bd5			 
2bd5			 
2bd5 e1			pop hl 
2bd6			 
2bd6				 
2bd6				if DEBUG_FORTH_WORDS 
2bd6					DMARK "FGm" 
2bd6 f5				push af  
2bd7 3a eb 2b			ld a, (.dmark)  
2bda 32 77 fb			ld (debug_mark),a  
2bdd 3a ec 2b			ld a, (.dmark+1)  
2be0 32 78 fb			ld (debug_mark+1),a  
2be3 3a ed 2b			ld a, (.dmark+2)  
2be6 32 79 fb			ld (debug_mark+2),a  
2be9 18 03			jr .pastdmark  
2beb ..			.dmark: db "FGm"  
2bee f1			.pastdmark: pop af  
2bef			endm  
# End of macro DMARK
2bef					CALLMONITOR 
2bef cd 17 16			call break_point_state  
2bf2				endm  
# End of macro CALLMONITOR
2bf2				endif 
2bf2			 
2bf2			 
2bf2			 
2bf2					; we have a uword so push its name to the stack 
2bf2			 
2bf2			;	   	push hl  ; save so we can move to next dict block 
2bf2			;pop hl 
2bf2			 
2bf2					; update opcode to deleted 
2bf2 3e 03				ld a, WORD_SYS_DELETED 
2bf4 77					ld (hl), a 
2bf5			 
2bf5 23					inc hl  
2bf6					; skip next ptr 
2bf6 23					inc hl  
2bf7 23					inc hl 
2bf8					; skip len 
2bf8 23					inc hl 
2bf9			 
2bf9					; TODO change parser to skip deleted words but for now mark it out 
2bf9 3e 5f				ld a, "_" 
2bfb 77					ld  (hl),a 
2bfc			 
2bfc			;		jr .fudone 
2bfc			; 
2bfc			;.fnuword:	pop hl 
2bfc			;		call forth_tok_next 
2bfc			;		jp .fdouscan  
2bfc			 
2bfc			.flunotfound:		  
2bfc			 
2bfc			 
2bfc					 
2bfc					FORTH_DSP_POP 
2bfc cd 53 1e			call macro_forth_dsp_pop 
2bff				endm 
# End of macro FORTH_DSP_POP
2bff			;		ld hl, .luno 
2bff			;.fudone:		 pop hl 
2bff					NEXTW 
2bff c3 0d 1f			jp macro_next 
2c02				endm 
# End of macro NEXTW
2c02			.NOP: 
2c02				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2c02 61				db WORD_SYS_CORE+77             
2c03 29 2c			dw .COMO            
2c05 04				db 3 + 1 
2c06 .. 00			db "NOP",0              
2c0a				endm 
# End of macro CWHEAD
2c0a			; | NOP (  --  ) Do nothing | DONE 
2c0a					if DEBUG_FORTH_WORDS_KEY 
2c0a						DMARK "NOP" 
2c0a f5				push af  
2c0b 3a 1f 2c			ld a, (.dmark)  
2c0e 32 77 fb			ld (debug_mark),a  
2c11 3a 20 2c			ld a, (.dmark+1)  
2c14 32 78 fb			ld (debug_mark+1),a  
2c17 3a 21 2c			ld a, (.dmark+2)  
2c1a 32 79 fb			ld (debug_mark+2),a  
2c1d 18 03			jr .pastdmark  
2c1f ..			.dmark: db "NOP"  
2c22 f1			.pastdmark: pop af  
2c23			endm  
# End of macro DMARK
2c23						CALLMONITOR 
2c23 cd 17 16			call break_point_state  
2c26				endm  
# End of macro CALLMONITOR
2c26					endif 
2c26				       NEXTW 
2c26 c3 0d 1f			jp macro_next 
2c29				endm 
# End of macro NEXTW
2c29			.COMO: 
2c29				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c29 6e				db WORD_SYS_CORE+90             
2c2a 7b 2c			dw .COMC            
2c2c 02				db 1 + 1 
2c2d .. 00			db "(",0              
2c2f				endm 
# End of macro CWHEAD
2c2f			; | ( ( -- )  Start of comment | DONE 
2c2f			 
2c2f			 
2c2f 2a 32 f1				ld hl, ( os_tok_ptr) 
2c32 11 76 2c			ld de, .closepar 
2c35					 
2c35					if DEBUG_FORTH_WORDS 
2c35						DMARK ").." 
2c35 f5				push af  
2c36 3a 4a 2c			ld a, (.dmark)  
2c39 32 77 fb			ld (debug_mark),a  
2c3c 3a 4b 2c			ld a, (.dmark+1)  
2c3f 32 78 fb			ld (debug_mark+1),a  
2c42 3a 4c 2c			ld a, (.dmark+2)  
2c45 32 79 fb			ld (debug_mark+2),a  
2c48 18 03			jr .pastdmark  
2c4a ..			.dmark: db ").."  
2c4d f1			.pastdmark: pop af  
2c4e			endm  
# End of macro DMARK
2c4e						CALLMONITOR 
2c4e cd 17 16			call break_point_state  
2c51				endm  
# End of macro CALLMONITOR
2c51					endif 
2c51 cd 28 20			call findnexttok  
2c54			 
2c54					if DEBUG_FORTH_WORDS 
2c54						DMARK "IF5" 
2c54 f5				push af  
2c55 3a 69 2c			ld a, (.dmark)  
2c58 32 77 fb			ld (debug_mark),a  
2c5b 3a 6a 2c			ld a, (.dmark+1)  
2c5e 32 78 fb			ld (debug_mark+1),a  
2c61 3a 6b 2c			ld a, (.dmark+2)  
2c64 32 79 fb			ld (debug_mark+2),a  
2c67 18 03			jr .pastdmark  
2c69 ..			.dmark: db "IF5"  
2c6c f1			.pastdmark: pop af  
2c6d			endm  
# End of macro DMARK
2c6d						CALLMONITOR 
2c6d cd 17 16			call break_point_state  
2c70				endm  
# End of macro CALLMONITOR
2c70					endif 
2c70				; replace below with ) exec using tok_ptr 
2c70 22 32 f1			ld (os_tok_ptr), hl 
2c73 c3 9e 1f			jp exec1 
2c76			 
2c76 .. 00			.closepar:   db ")",0 
2c78			 
2c78				       NEXTW 
2c78 c3 0d 1f			jp macro_next 
2c7b				endm 
# End of macro NEXTW
2c7b			.COMC: 
2c7b				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c7b 6f				db WORD_SYS_CORE+91             
2c7c 84 2c			dw .SCRATCH            
2c7e 02				db 1 + 1 
2c7f .. 00			db ")",0              
2c81				endm 
# End of macro CWHEAD
2c81			; | ) ( -- )  End of comment |  DONE  
2c81				       NEXTW 
2c81 c3 0d 1f			jp macro_next 
2c84				endm 
# End of macro NEXTW
2c84			 
2c84			.SCRATCH: 
2c84				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c84 6f				db WORD_SYS_CORE+91             
2c85 bf 2c			dw .INC            
2c87 08				db 7 + 1 
2c88 .. 00			db "SCRATCH",0              
2c90				endm 
# End of macro CWHEAD
2c90			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c90			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c90			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c90			; | |  
2c90			; | | e.g.    : score $00 scratch ; 
2c90			; | |  
2c90			; | | $00 score ! 
2c90			; | | $01 score +! 
2c90			; | |  
2c90			; | | e.g.   : varword $0a scratch ;  
2c90			; | | 
2c90			; | | $8000 varword ! 
2c90					if DEBUG_FORTH_WORDS_KEY 
2c90						DMARK "SCR" 
2c90 f5				push af  
2c91 3a a5 2c			ld a, (.dmark)  
2c94 32 77 fb			ld (debug_mark),a  
2c97 3a a6 2c			ld a, (.dmark+1)  
2c9a 32 78 fb			ld (debug_mark+1),a  
2c9d 3a a7 2c			ld a, (.dmark+2)  
2ca0 32 79 fb			ld (debug_mark+2),a  
2ca3 18 03			jr .pastdmark  
2ca5 ..			.dmark: db "SCR"  
2ca8 f1			.pastdmark: pop af  
2ca9			endm  
# End of macro DMARK
2ca9						CALLMONITOR 
2ca9 cd 17 16			call break_point_state  
2cac				endm  
# End of macro CALLMONITOR
2cac					endif 
2cac			 
2cac					FORTH_DSP_VALUEHL 
2cac cd 9b 1d			call macro_dsp_valuehl 
2caf				endm 
# End of macro FORTH_DSP_VALUEHL
2caf				 
2caf					FORTH_DSP_POP 
2caf cd 53 1e			call macro_forth_dsp_pop 
2cb2				endm 
# End of macro FORTH_DSP_POP
2cb2			 
2cb2 7d					ld a, l 
2cb3 21 56 f3				ld hl, os_var_array 
2cb6 cd cb 0c				call addatohl 
2cb9			 
2cb9 cd a4 1b				call forth_push_numhl 
2cbc			 
2cbc				       NEXTW 
2cbc c3 0d 1f			jp macro_next 
2cbf				endm 
# End of macro NEXTW
2cbf			 
2cbf			.INC: 
2cbf				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2cbf 6f				db WORD_SYS_CORE+91             
2cc0 13 2d			dw .DEC            
2cc2 03				db 2 + 1 
2cc3 .. 00			db "+!",0              
2cc6				endm 
# End of macro CWHEAD
2cc6			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2cc6					if DEBUG_FORTH_WORDS_KEY 
2cc6						DMARK "+s_" 
2cc6 f5				push af  
2cc7 3a db 2c			ld a, (.dmark)  
2cca 32 77 fb			ld (debug_mark),a  
2ccd 3a dc 2c			ld a, (.dmark+1)  
2cd0 32 78 fb			ld (debug_mark+1),a  
2cd3 3a dd 2c			ld a, (.dmark+2)  
2cd6 32 79 fb			ld (debug_mark+2),a  
2cd9 18 03			jr .pastdmark  
2cdb ..			.dmark: db "+s_"  
2cde f1			.pastdmark: pop af  
2cdf			endm  
# End of macro DMARK
2cdf						CALLMONITOR 
2cdf cd 17 16			call break_point_state  
2ce2				endm  
# End of macro CALLMONITOR
2ce2					endif 
2ce2			 
2ce2					FORTH_DSP_VALUEHL 
2ce2 cd 9b 1d			call macro_dsp_valuehl 
2ce5				endm 
# End of macro FORTH_DSP_VALUEHL
2ce5			 
2ce5 e5					push hl   ; save address 
2ce6			 
2ce6					FORTH_DSP_POP 
2ce6 cd 53 1e			call macro_forth_dsp_pop 
2ce9				endm 
# End of macro FORTH_DSP_POP
2ce9			 
2ce9					FORTH_DSP_VALUEHL 
2ce9 cd 9b 1d			call macro_dsp_valuehl 
2cec				endm 
# End of macro FORTH_DSP_VALUEHL
2cec			 
2cec					FORTH_DSP_POP 
2cec cd 53 1e			call macro_forth_dsp_pop 
2cef				endm 
# End of macro FORTH_DSP_POP
2cef			 
2cef					; hl contains value to add to byte at a 
2cef				 
2cef eb					ex de, hl 
2cf0			 
2cf0 e1					pop hl 
2cf1			 
2cf1					if DEBUG_FORTH_WORDS 
2cf1						DMARK "INC" 
2cf1 f5				push af  
2cf2 3a 06 2d			ld a, (.dmark)  
2cf5 32 77 fb			ld (debug_mark),a  
2cf8 3a 07 2d			ld a, (.dmark+1)  
2cfb 32 78 fb			ld (debug_mark+1),a  
2cfe 3a 08 2d			ld a, (.dmark+2)  
2d01 32 79 fb			ld (debug_mark+2),a  
2d04 18 03			jr .pastdmark  
2d06 ..			.dmark: db "INC"  
2d09 f1			.pastdmark: pop af  
2d0a			endm  
# End of macro DMARK
2d0a						CALLMONITOR 
2d0a cd 17 16			call break_point_state  
2d0d				endm  
# End of macro CALLMONITOR
2d0d					endif 
2d0d			 
2d0d 7e					ld a,(hl) 
2d0e 83					add e 
2d0f 77					ld (hl),a 
2d10			 
2d10			 
2d10			 
2d10				       NEXTW 
2d10 c3 0d 1f			jp macro_next 
2d13				endm 
# End of macro NEXTW
2d13			 
2d13			.DEC: 
2d13				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d13 6f				db WORD_SYS_CORE+91             
2d14 64 2d			dw .INC2            
2d16 03				db 2 + 1 
2d17 .. 00			db "-!",0              
2d1a				endm 
# End of macro CWHEAD
2d1a			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d1a					if DEBUG_FORTH_WORDS_KEY 
2d1a						DMARK "-s_" 
2d1a f5				push af  
2d1b 3a 2f 2d			ld a, (.dmark)  
2d1e 32 77 fb			ld (debug_mark),a  
2d21 3a 30 2d			ld a, (.dmark+1)  
2d24 32 78 fb			ld (debug_mark+1),a  
2d27 3a 31 2d			ld a, (.dmark+2)  
2d2a 32 79 fb			ld (debug_mark+2),a  
2d2d 18 03			jr .pastdmark  
2d2f ..			.dmark: db "-s_"  
2d32 f1			.pastdmark: pop af  
2d33			endm  
# End of macro DMARK
2d33						CALLMONITOR 
2d33 cd 17 16			call break_point_state  
2d36				endm  
# End of macro CALLMONITOR
2d36					endif 
2d36			 
2d36					FORTH_DSP_VALUEHL 
2d36 cd 9b 1d			call macro_dsp_valuehl 
2d39				endm 
# End of macro FORTH_DSP_VALUEHL
2d39			 
2d39 e5					push hl   ; save address 
2d3a			 
2d3a					FORTH_DSP_POP 
2d3a cd 53 1e			call macro_forth_dsp_pop 
2d3d				endm 
# End of macro FORTH_DSP_POP
2d3d			 
2d3d					FORTH_DSP_VALUEHL 
2d3d cd 9b 1d			call macro_dsp_valuehl 
2d40				endm 
# End of macro FORTH_DSP_VALUEHL
2d40			 
2d40					; hl contains value to add to byte at a 
2d40				 
2d40 eb					ex de, hl 
2d41			 
2d41 e1					pop hl 
2d42			 
2d42					if DEBUG_FORTH_WORDS 
2d42						DMARK "DEC" 
2d42 f5				push af  
2d43 3a 57 2d			ld a, (.dmark)  
2d46 32 77 fb			ld (debug_mark),a  
2d49 3a 58 2d			ld a, (.dmark+1)  
2d4c 32 78 fb			ld (debug_mark+1),a  
2d4f 3a 59 2d			ld a, (.dmark+2)  
2d52 32 79 fb			ld (debug_mark+2),a  
2d55 18 03			jr .pastdmark  
2d57 ..			.dmark: db "DEC"  
2d5a f1			.pastdmark: pop af  
2d5b			endm  
# End of macro DMARK
2d5b						CALLMONITOR 
2d5b cd 17 16			call break_point_state  
2d5e				endm  
# End of macro CALLMONITOR
2d5e					endif 
2d5e			 
2d5e 7e					ld a,(hl) 
2d5f 93					sub e 
2d60 77					ld (hl),a 
2d61			 
2d61			 
2d61			 
2d61				       NEXTW 
2d61 c3 0d 1f			jp macro_next 
2d64				endm 
# End of macro NEXTW
2d64			 
2d64			.INC2: 
2d64				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d64 6f				db WORD_SYS_CORE+91             
2d65 0e 2e			dw .DEC2            
2d67 04				db 3 + 1 
2d68 .. 00			db "+2!",0              
2d6c				endm 
# End of macro CWHEAD
2d6c			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d6c			 
2d6c					if DEBUG_FORTH_WORDS_KEY 
2d6c						DMARK "+2s" 
2d6c f5				push af  
2d6d 3a 81 2d			ld a, (.dmark)  
2d70 32 77 fb			ld (debug_mark),a  
2d73 3a 82 2d			ld a, (.dmark+1)  
2d76 32 78 fb			ld (debug_mark+1),a  
2d79 3a 83 2d			ld a, (.dmark+2)  
2d7c 32 79 fb			ld (debug_mark+2),a  
2d7f 18 03			jr .pastdmark  
2d81 ..			.dmark: db "+2s"  
2d84 f1			.pastdmark: pop af  
2d85			endm  
# End of macro DMARK
2d85						CALLMONITOR 
2d85 cd 17 16			call break_point_state  
2d88				endm  
# End of macro CALLMONITOR
2d88					endif 
2d88			 
2d88					; Address 
2d88			 
2d88					FORTH_DSP_VALUEHL 
2d88 cd 9b 1d			call macro_dsp_valuehl 
2d8b				endm 
# End of macro FORTH_DSP_VALUEHL
2d8b			 
2d8b e5					push hl    ; save address 
2d8c			 
2d8c					; load content into de 
2d8c			 
2d8c 5e					ld e,(hl) 
2d8d 23					inc hl 
2d8e 56					ld d, (hl) 
2d8f			 
2d8f					if DEBUG_FORTH_WORDS 
2d8f						DMARK "+2a" 
2d8f f5				push af  
2d90 3a a4 2d			ld a, (.dmark)  
2d93 32 77 fb			ld (debug_mark),a  
2d96 3a a5 2d			ld a, (.dmark+1)  
2d99 32 78 fb			ld (debug_mark+1),a  
2d9c 3a a6 2d			ld a, (.dmark+2)  
2d9f 32 79 fb			ld (debug_mark+2),a  
2da2 18 03			jr .pastdmark  
2da4 ..			.dmark: db "+2a"  
2da7 f1			.pastdmark: pop af  
2da8			endm  
# End of macro DMARK
2da8						CALLMONITOR 
2da8 cd 17 16			call break_point_state  
2dab				endm  
# End of macro CALLMONITOR
2dab					endif 
2dab			 
2dab					FORTH_DSP_POP 
2dab cd 53 1e			call macro_forth_dsp_pop 
2dae				endm 
# End of macro FORTH_DSP_POP
2dae			 
2dae					; Get value to add 
2dae			 
2dae					FORTH_DSP_VALUE 
2dae cd 84 1d			call macro_forth_dsp_value 
2db1				endm 
# End of macro FORTH_DSP_VALUE
2db1			 
2db1					if DEBUG_FORTH_WORDS 
2db1						DMARK "+2v" 
2db1 f5				push af  
2db2 3a c6 2d			ld a, (.dmark)  
2db5 32 77 fb			ld (debug_mark),a  
2db8 3a c7 2d			ld a, (.dmark+1)  
2dbb 32 78 fb			ld (debug_mark+1),a  
2dbe 3a c8 2d			ld a, (.dmark+2)  
2dc1 32 79 fb			ld (debug_mark+2),a  
2dc4 18 03			jr .pastdmark  
2dc6 ..			.dmark: db "+2v"  
2dc9 f1			.pastdmark: pop af  
2dca			endm  
# End of macro DMARK
2dca						CALLMONITOR 
2dca cd 17 16			call break_point_state  
2dcd				endm  
# End of macro CALLMONITOR
2dcd					endif 
2dcd			 
2dcd 19					add hl, de 
2dce			 
2dce					if DEBUG_FORTH_WORDS 
2dce						DMARK "+2+" 
2dce f5				push af  
2dcf 3a e3 2d			ld a, (.dmark)  
2dd2 32 77 fb			ld (debug_mark),a  
2dd5 3a e4 2d			ld a, (.dmark+1)  
2dd8 32 78 fb			ld (debug_mark+1),a  
2ddb 3a e5 2d			ld a, (.dmark+2)  
2dde 32 79 fb			ld (debug_mark+2),a  
2de1 18 03			jr .pastdmark  
2de3 ..			.dmark: db "+2+"  
2de6 f1			.pastdmark: pop af  
2de7			endm  
# End of macro DMARK
2de7						CALLMONITOR 
2de7 cd 17 16			call break_point_state  
2dea				endm  
# End of macro CALLMONITOR
2dea					endif 
2dea			 
2dea					; move result to de 
2dea			 
2dea eb					ex de, hl 
2deb			 
2deb					; Address 
2deb			 
2deb e1					pop hl 
2dec			 
2dec					; save it back 
2dec			 
2dec 73					ld (hl), e 
2ded 23					inc hl 
2dee 72					ld (hl), d 
2def			 
2def					if DEBUG_FORTH_WORDS 
2def						DMARK "+2e" 
2def f5				push af  
2df0 3a 04 2e			ld a, (.dmark)  
2df3 32 77 fb			ld (debug_mark),a  
2df6 3a 05 2e			ld a, (.dmark+1)  
2df9 32 78 fb			ld (debug_mark+1),a  
2dfc 3a 06 2e			ld a, (.dmark+2)  
2dff 32 79 fb			ld (debug_mark+2),a  
2e02 18 03			jr .pastdmark  
2e04 ..			.dmark: db "+2e"  
2e07 f1			.pastdmark: pop af  
2e08			endm  
# End of macro DMARK
2e08						CALLMONITOR 
2e08 cd 17 16			call break_point_state  
2e0b				endm  
# End of macro CALLMONITOR
2e0b					endif 
2e0b			 
2e0b			 
2e0b			 
2e0b			 
2e0b			 
2e0b				       NEXTW 
2e0b c3 0d 1f			jp macro_next 
2e0e				endm 
# End of macro NEXTW
2e0e			 
2e0e			.DEC2: 
2e0e				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e0e 6f				db WORD_SYS_CORE+91             
2e0f ba 2e			dw .GET2            
2e11 04				db 3 + 1 
2e12 .. 00			db "-2!",0              
2e16				endm 
# End of macro CWHEAD
2e16			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e16			 
2e16			 
2e16					if DEBUG_FORTH_WORDS_KEY 
2e16						DMARK "-2s" 
2e16 f5				push af  
2e17 3a 2b 2e			ld a, (.dmark)  
2e1a 32 77 fb			ld (debug_mark),a  
2e1d 3a 2c 2e			ld a, (.dmark+1)  
2e20 32 78 fb			ld (debug_mark+1),a  
2e23 3a 2d 2e			ld a, (.dmark+2)  
2e26 32 79 fb			ld (debug_mark+2),a  
2e29 18 03			jr .pastdmark  
2e2b ..			.dmark: db "-2s"  
2e2e f1			.pastdmark: pop af  
2e2f			endm  
# End of macro DMARK
2e2f						CALLMONITOR 
2e2f cd 17 16			call break_point_state  
2e32				endm  
# End of macro CALLMONITOR
2e32					endif 
2e32			 
2e32					; Address 
2e32			 
2e32					FORTH_DSP_VALUEHL 
2e32 cd 9b 1d			call macro_dsp_valuehl 
2e35				endm 
# End of macro FORTH_DSP_VALUEHL
2e35			 
2e35 e5					push hl    ; save address 
2e36			 
2e36					; load content into de 
2e36			 
2e36 5e					ld e,(hl) 
2e37 23					inc hl 
2e38 56					ld d, (hl) 
2e39			 
2e39					if DEBUG_FORTH_WORDS 
2e39						DMARK "-2a" 
2e39 f5				push af  
2e3a 3a 4e 2e			ld a, (.dmark)  
2e3d 32 77 fb			ld (debug_mark),a  
2e40 3a 4f 2e			ld a, (.dmark+1)  
2e43 32 78 fb			ld (debug_mark+1),a  
2e46 3a 50 2e			ld a, (.dmark+2)  
2e49 32 79 fb			ld (debug_mark+2),a  
2e4c 18 03			jr .pastdmark  
2e4e ..			.dmark: db "-2a"  
2e51 f1			.pastdmark: pop af  
2e52			endm  
# End of macro DMARK
2e52						CALLMONITOR 
2e52 cd 17 16			call break_point_state  
2e55				endm  
# End of macro CALLMONITOR
2e55					endif 
2e55			 
2e55					FORTH_DSP_POP 
2e55 cd 53 1e			call macro_forth_dsp_pop 
2e58				endm 
# End of macro FORTH_DSP_POP
2e58			 
2e58					; Get value to remove 
2e58			 
2e58					FORTH_DSP_VALUE 
2e58 cd 84 1d			call macro_forth_dsp_value 
2e5b				endm 
# End of macro FORTH_DSP_VALUE
2e5b			 
2e5b					if DEBUG_FORTH_WORDS 
2e5b						DMARK "-2v" 
2e5b f5				push af  
2e5c 3a 70 2e			ld a, (.dmark)  
2e5f 32 77 fb			ld (debug_mark),a  
2e62 3a 71 2e			ld a, (.dmark+1)  
2e65 32 78 fb			ld (debug_mark+1),a  
2e68 3a 72 2e			ld a, (.dmark+2)  
2e6b 32 79 fb			ld (debug_mark+2),a  
2e6e 18 03			jr .pastdmark  
2e70 ..			.dmark: db "-2v"  
2e73 f1			.pastdmark: pop af  
2e74			endm  
# End of macro DMARK
2e74						CALLMONITOR 
2e74 cd 17 16			call break_point_state  
2e77				endm  
# End of macro CALLMONITOR
2e77					endif 
2e77			 
2e77 eb					ex de, hl 
2e78 ed 52				sbc hl, de 
2e7a			 
2e7a					if DEBUG_FORTH_WORDS 
2e7a						DMARK "-2d" 
2e7a f5				push af  
2e7b 3a 8f 2e			ld a, (.dmark)  
2e7e 32 77 fb			ld (debug_mark),a  
2e81 3a 90 2e			ld a, (.dmark+1)  
2e84 32 78 fb			ld (debug_mark+1),a  
2e87 3a 91 2e			ld a, (.dmark+2)  
2e8a 32 79 fb			ld (debug_mark+2),a  
2e8d 18 03			jr .pastdmark  
2e8f ..			.dmark: db "-2d"  
2e92 f1			.pastdmark: pop af  
2e93			endm  
# End of macro DMARK
2e93						CALLMONITOR 
2e93 cd 17 16			call break_point_state  
2e96				endm  
# End of macro CALLMONITOR
2e96					endif 
2e96			 
2e96					; move result to de 
2e96			 
2e96 eb					ex de, hl 
2e97			 
2e97					; Address 
2e97			 
2e97 e1					pop hl 
2e98			 
2e98					; save it back 
2e98			 
2e98 73					ld (hl), e 
2e99 23					inc hl 
2e9a 72					ld (hl), d 
2e9b			 
2e9b					if DEBUG_FORTH_WORDS 
2e9b						DMARK "-2e" 
2e9b f5				push af  
2e9c 3a b0 2e			ld a, (.dmark)  
2e9f 32 77 fb			ld (debug_mark),a  
2ea2 3a b1 2e			ld a, (.dmark+1)  
2ea5 32 78 fb			ld (debug_mark+1),a  
2ea8 3a b2 2e			ld a, (.dmark+2)  
2eab 32 79 fb			ld (debug_mark+2),a  
2eae 18 03			jr .pastdmark  
2eb0 ..			.dmark: db "-2e"  
2eb3 f1			.pastdmark: pop af  
2eb4			endm  
# End of macro DMARK
2eb4						CALLMONITOR 
2eb4 cd 17 16			call break_point_state  
2eb7				endm  
# End of macro CALLMONITOR
2eb7					endif 
2eb7			 
2eb7			 
2eb7			 
2eb7			 
2eb7			 
2eb7				       NEXTW 
2eb7 c3 0d 1f			jp macro_next 
2eba				endm 
# End of macro NEXTW
2eba			.GET2: 
2eba				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2eba 6f				db WORD_SYS_CORE+91             
2ebb ea 2e			dw .BANG2            
2ebd 03				db 2 + 1 
2ebe .. 00			db "2@",0              
2ec1				endm 
# End of macro CWHEAD
2ec1			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2ec1					if DEBUG_FORTH_WORDS_KEY 
2ec1						DMARK "2A_" 
2ec1 f5				push af  
2ec2 3a d6 2e			ld a, (.dmark)  
2ec5 32 77 fb			ld (debug_mark),a  
2ec8 3a d7 2e			ld a, (.dmark+1)  
2ecb 32 78 fb			ld (debug_mark+1),a  
2ece 3a d8 2e			ld a, (.dmark+2)  
2ed1 32 79 fb			ld (debug_mark+2),a  
2ed4 18 03			jr .pastdmark  
2ed6 ..			.dmark: db "2A_"  
2ed9 f1			.pastdmark: pop af  
2eda			endm  
# End of macro DMARK
2eda						CALLMONITOR 
2eda cd 17 16			call break_point_state  
2edd				endm  
# End of macro CALLMONITOR
2edd					endif 
2edd			 
2edd					FORTH_DSP_VALUEHL 
2edd cd 9b 1d			call macro_dsp_valuehl 
2ee0				endm 
# End of macro FORTH_DSP_VALUEHL
2ee0			 
2ee0 5e					ld e, (hl) 
2ee1 23					inc hl 
2ee2 56					ld d, (hl) 
2ee3			 
2ee3 eb					ex de, hl 
2ee4			 
2ee4 cd a4 1b				call forth_push_numhl 
2ee7			 
2ee7				       NEXTW 
2ee7 c3 0d 1f			jp macro_next 
2eea				endm 
# End of macro NEXTW
2eea			.BANG2: 
2eea				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2eea 6f				db WORD_SYS_CORE+91             
2eeb 22 2f			dw .CONFIG            
2eed 03				db 2 + 1 
2eee .. 00			db "2!",0              
2ef1				endm 
# End of macro CWHEAD
2ef1			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ef1					if DEBUG_FORTH_WORDS_KEY 
2ef1						DMARK "2S_" 
2ef1 f5				push af  
2ef2 3a 06 2f			ld a, (.dmark)  
2ef5 32 77 fb			ld (debug_mark),a  
2ef8 3a 07 2f			ld a, (.dmark+1)  
2efb 32 78 fb			ld (debug_mark+1),a  
2efe 3a 08 2f			ld a, (.dmark+2)  
2f01 32 79 fb			ld (debug_mark+2),a  
2f04 18 03			jr .pastdmark  
2f06 ..			.dmark: db "2S_"  
2f09 f1			.pastdmark: pop af  
2f0a			endm  
# End of macro DMARK
2f0a						CALLMONITOR 
2f0a cd 17 16			call break_point_state  
2f0d				endm  
# End of macro CALLMONITOR
2f0d					endif 
2f0d			 
2f0d					FORTH_DSP_VALUEHL 
2f0d cd 9b 1d			call macro_dsp_valuehl 
2f10				endm 
# End of macro FORTH_DSP_VALUEHL
2f10			 
2f10 e5					push hl   ; save address 
2f11			 
2f11			 
2f11					FORTH_DSP_POP 
2f11 cd 53 1e			call macro_forth_dsp_pop 
2f14				endm 
# End of macro FORTH_DSP_POP
2f14			 
2f14					 
2f14					FORTH_DSP_VALUEHL 
2f14 cd 9b 1d			call macro_dsp_valuehl 
2f17				endm 
# End of macro FORTH_DSP_VALUEHL
2f17			 
2f17					FORTH_DSP_POP 
2f17 cd 53 1e			call macro_forth_dsp_pop 
2f1a				endm 
# End of macro FORTH_DSP_POP
2f1a			 
2f1a eb					ex de, hl    ; value now in de 
2f1b			 
2f1b e1					pop hl 
2f1c			 
2f1c 73					ld (hl), e 
2f1d			 
2f1d 23					inc hl 
2f1e			 
2f1e 72					ld (hl), d 
2f1f			 
2f1f			 
2f1f				       NEXTW 
2f1f c3 0d 1f			jp macro_next 
2f22				endm 
# End of macro NEXTW
2f22			.CONFIG: 
2f22				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f22 6f				db WORD_SYS_CORE+91             
2f23 33 2f			dw .ENDCORE            
2f25 07				db 6 + 1 
2f26 .. 00			db "CONFIG",0              
2f2d				endm 
# End of macro CWHEAD
2f2d			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2f2d			 
2f2d cd 55 13				call config 
2f30					NEXTW 
2f30 c3 0d 1f			jp macro_next 
2f33				endm 
# End of macro NEXTW
2f33			.ENDCORE: 
2f33			 
2f33			; eof 
2f33			 
2f33			 
# End of file forth_words_core.asm
2f33			include "forth_words_flow.asm" 
2f33			 
2f33			; | ## Program Flow Words 
2f33			 
2f33			.IF: 
2f33				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f33 1e				db WORD_SYS_CORE+10             
2f34 28 30			dw .THEN            
2f36 03				db 2 + 1 
2f37 .. 00			db "IF",0              
2f3a				endm 
# End of macro CWHEAD
2f3a			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f3a			; 
2f3a					if DEBUG_FORTH_WORDS_KEY 
2f3a						DMARK "IF." 
2f3a f5				push af  
2f3b 3a 4f 2f			ld a, (.dmark)  
2f3e 32 77 fb			ld (debug_mark),a  
2f41 3a 50 2f			ld a, (.dmark+1)  
2f44 32 78 fb			ld (debug_mark+1),a  
2f47 3a 51 2f			ld a, (.dmark+2)  
2f4a 32 79 fb			ld (debug_mark+2),a  
2f4d 18 03			jr .pastdmark  
2f4f ..			.dmark: db "IF."  
2f52 f1			.pastdmark: pop af  
2f53			endm  
# End of macro DMARK
2f53						CALLMONITOR 
2f53 cd 17 16			call break_point_state  
2f56				endm  
# End of macro CALLMONITOR
2f56					endif 
2f56			; eval TOS 
2f56			 
2f56				FORTH_DSP_VALUEHL 
2f56 cd 9b 1d			call macro_dsp_valuehl 
2f59				endm 
# End of macro FORTH_DSP_VALUEHL
2f59			 
2f59			;	push hl 
2f59				FORTH_DSP_POP 
2f59 cd 53 1e			call macro_forth_dsp_pop 
2f5c				endm 
# End of macro FORTH_DSP_POP
2f5c			;	pop hl 
2f5c			 
2f5c					if DEBUG_FORTH_WORDS 
2f5c						DMARK "IF1" 
2f5c f5				push af  
2f5d 3a 71 2f			ld a, (.dmark)  
2f60 32 77 fb			ld (debug_mark),a  
2f63 3a 72 2f			ld a, (.dmark+1)  
2f66 32 78 fb			ld (debug_mark+1),a  
2f69 3a 73 2f			ld a, (.dmark+2)  
2f6c 32 79 fb			ld (debug_mark+2),a  
2f6f 18 03			jr .pastdmark  
2f71 ..			.dmark: db "IF1"  
2f74 f1			.pastdmark: pop af  
2f75			endm  
# End of macro DMARK
2f75						CALLMONITOR 
2f75 cd 17 16			call break_point_state  
2f78				endm  
# End of macro CALLMONITOR
2f78					endif 
2f78 b7				or a        ; clear carry flag 
2f79 11 00 00			ld de, 0 
2f7c eb				ex de,hl 
2f7d ed 52			sbc hl, de 
2f7f c2 09 30			jp nz, .iftrue 
2f82			 
2f82					if DEBUG_FORTH_WORDS 
2f82						DMARK "IF2" 
2f82 f5				push af  
2f83 3a 97 2f			ld a, (.dmark)  
2f86 32 77 fb			ld (debug_mark),a  
2f89 3a 98 2f			ld a, (.dmark+1)  
2f8c 32 78 fb			ld (debug_mark+1),a  
2f8f 3a 99 2f			ld a, (.dmark+2)  
2f92 32 79 fb			ld (debug_mark+2),a  
2f95 18 03			jr .pastdmark  
2f97 ..			.dmark: db "IF2"  
2f9a f1			.pastdmark: pop af  
2f9b			endm  
# End of macro DMARK
2f9b						CALLMONITOR 
2f9b cd 17 16			call break_point_state  
2f9e				endm  
# End of macro CALLMONITOR
2f9e					endif 
2f9e			 
2f9e			; if not true then skip to THEN 
2f9e			 
2f9e				; TODO get tok_ptr 
2f9e				; TODO consume toks until we get to THEN 
2f9e			 
2f9e 2a 32 f1			ld hl, (os_tok_ptr) 
2fa1					if DEBUG_FORTH_WORDS 
2fa1						DMARK "IF3" 
2fa1 f5				push af  
2fa2 3a b6 2f			ld a, (.dmark)  
2fa5 32 77 fb			ld (debug_mark),a  
2fa8 3a b7 2f			ld a, (.dmark+1)  
2fab 32 78 fb			ld (debug_mark+1),a  
2fae 3a b8 2f			ld a, (.dmark+2)  
2fb1 32 79 fb			ld (debug_mark+2),a  
2fb4 18 03			jr .pastdmark  
2fb6 ..			.dmark: db "IF3"  
2fb9 f1			.pastdmark: pop af  
2fba			endm  
# End of macro DMARK
2fba						CALLMONITOR 
2fba cd 17 16			call break_point_state  
2fbd				endm  
# End of macro CALLMONITOR
2fbd						 
2fbd					endif 
2fbd 11 04 30			ld de, .ifthen 
2fc0					if DEBUG_FORTH_WORDS 
2fc0						DMARK "IF4" 
2fc0 f5				push af  
2fc1 3a d5 2f			ld a, (.dmark)  
2fc4 32 77 fb			ld (debug_mark),a  
2fc7 3a d6 2f			ld a, (.dmark+1)  
2fca 32 78 fb			ld (debug_mark+1),a  
2fcd 3a d7 2f			ld a, (.dmark+2)  
2fd0 32 79 fb			ld (debug_mark+2),a  
2fd3 18 03			jr .pastdmark  
2fd5 ..			.dmark: db "IF4"  
2fd8 f1			.pastdmark: pop af  
2fd9			endm  
# End of macro DMARK
2fd9						CALLMONITOR 
2fd9 cd 17 16			call break_point_state  
2fdc				endm  
# End of macro CALLMONITOR
2fdc					endif 
2fdc cd 28 20			call findnexttok  
2fdf			 
2fdf					if DEBUG_FORTH_WORDS 
2fdf						DMARK "IF5" 
2fdf f5				push af  
2fe0 3a f4 2f			ld a, (.dmark)  
2fe3 32 77 fb			ld (debug_mark),a  
2fe6 3a f5 2f			ld a, (.dmark+1)  
2fe9 32 78 fb			ld (debug_mark+1),a  
2fec 3a f6 2f			ld a, (.dmark+2)  
2fef 32 79 fb			ld (debug_mark+2),a  
2ff2 18 03			jr .pastdmark  
2ff4 ..			.dmark: db "IF5"  
2ff7 f1			.pastdmark: pop af  
2ff8			endm  
# End of macro DMARK
2ff8						CALLMONITOR 
2ff8 cd 17 16			call break_point_state  
2ffb				endm  
# End of macro CALLMONITOR
2ffb					endif 
2ffb				; TODO replace below with ; exec using tok_ptr 
2ffb 22 32 f1			ld (os_tok_ptr), hl 
2ffe c3 9e 1f			jp exec1 
3001				NEXTW 
3001 c3 0d 1f			jp macro_next 
3004				endm 
# End of macro NEXTW
3004			 
3004 .. 00		.ifthen:  db "THEN",0 
3009			 
3009			.iftrue:		 
3009				; Exec next words normally 
3009			 
3009				; if true then exec following IF as normal 
3009					if DEBUG_FORTH_WORDS 
3009						DMARK "IFT" 
3009 f5				push af  
300a 3a 1e 30			ld a, (.dmark)  
300d 32 77 fb			ld (debug_mark),a  
3010 3a 1f 30			ld a, (.dmark+1)  
3013 32 78 fb			ld (debug_mark+1),a  
3016 3a 20 30			ld a, (.dmark+2)  
3019 32 79 fb			ld (debug_mark+2),a  
301c 18 03			jr .pastdmark  
301e ..			.dmark: db "IFT"  
3021 f1			.pastdmark: pop af  
3022			endm  
# End of macro DMARK
3022						CALLMONITOR 
3022 cd 17 16			call break_point_state  
3025				endm  
# End of macro CALLMONITOR
3025					endif 
3025			 
3025					NEXTW 
3025 c3 0d 1f			jp macro_next 
3028				endm 
# End of macro NEXTW
3028			.THEN: 
3028				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3028 1f				db WORD_SYS_CORE+11             
3029 50 30			dw .ELSE            
302b 05				db 4 + 1 
302c .. 00			db "THEN",0              
3031				endm 
# End of macro CWHEAD
3031			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3031					if DEBUG_FORTH_WORDS_KEY 
3031						DMARK "THN" 
3031 f5				push af  
3032 3a 46 30			ld a, (.dmark)  
3035 32 77 fb			ld (debug_mark),a  
3038 3a 47 30			ld a, (.dmark+1)  
303b 32 78 fb			ld (debug_mark+1),a  
303e 3a 48 30			ld a, (.dmark+2)  
3041 32 79 fb			ld (debug_mark+2),a  
3044 18 03			jr .pastdmark  
3046 ..			.dmark: db "THN"  
3049 f1			.pastdmark: pop af  
304a			endm  
# End of macro DMARK
304a						CALLMONITOR 
304a cd 17 16			call break_point_state  
304d				endm  
# End of macro CALLMONITOR
304d					endif 
304d					NEXTW 
304d c3 0d 1f			jp macro_next 
3050				endm 
# End of macro NEXTW
3050			.ELSE: 
3050				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3050 20				db WORD_SYS_CORE+12             
3051 78 30			dw .DO            
3053 03				db 2 + 1 
3054 .. 00			db "ELSE",0              
3059				endm 
# End of macro CWHEAD
3059			; | ELSE ( -- ) Not supported - does nothing | TODO 
3059			 
3059					if DEBUG_FORTH_WORDS_KEY 
3059						DMARK "ELS" 
3059 f5				push af  
305a 3a 6e 30			ld a, (.dmark)  
305d 32 77 fb			ld (debug_mark),a  
3060 3a 6f 30			ld a, (.dmark+1)  
3063 32 78 fb			ld (debug_mark+1),a  
3066 3a 70 30			ld a, (.dmark+2)  
3069 32 79 fb			ld (debug_mark+2),a  
306c 18 03			jr .pastdmark  
306e ..			.dmark: db "ELS"  
3071 f1			.pastdmark: pop af  
3072			endm  
# End of macro DMARK
3072						CALLMONITOR 
3072 cd 17 16			call break_point_state  
3075				endm  
# End of macro CALLMONITOR
3075					endif 
3075			 
3075			 
3075					NEXTW 
3075 c3 0d 1f			jp macro_next 
3078				endm 
# End of macro NEXTW
3078			.DO: 
3078				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3078 21				db WORD_SYS_CORE+13             
3079 9f 31			dw .LOOP            
307b 03				db 2 + 1 
307c .. 00			db "DO",0              
307f				endm 
# End of macro CWHEAD
307f			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
307f			 
307f					if DEBUG_FORTH_WORDS_KEY 
307f						DMARK "DO." 
307f f5				push af  
3080 3a 94 30			ld a, (.dmark)  
3083 32 77 fb			ld (debug_mark),a  
3086 3a 95 30			ld a, (.dmark+1)  
3089 32 78 fb			ld (debug_mark+1),a  
308c 3a 96 30			ld a, (.dmark+2)  
308f 32 79 fb			ld (debug_mark+2),a  
3092 18 03			jr .pastdmark  
3094 ..			.dmark: db "DO."  
3097 f1			.pastdmark: pop af  
3098			endm  
# End of macro DMARK
3098						CALLMONITOR 
3098 cd 17 16			call break_point_state  
309b				endm  
# End of macro CALLMONITOR
309b					endif 
309b			;  push pc to rsp stack past the DO 
309b			 
309b 2a 32 f1				ld hl, (os_tok_ptr) 
309e 23					inc hl   ; D 
309f 23					inc hl  ; O 
30a0 23					inc hl   ; null 
30a1					if DEBUG_FORTH_WORDS 
30a1						DMARK "DO2" 
30a1 f5				push af  
30a2 3a b6 30			ld a, (.dmark)  
30a5 32 77 fb			ld (debug_mark),a  
30a8 3a b7 30			ld a, (.dmark+1)  
30ab 32 78 fb			ld (debug_mark+1),a  
30ae 3a b8 30			ld a, (.dmark+2)  
30b1 32 79 fb			ld (debug_mark+2),a  
30b4 18 03			jr .pastdmark  
30b6 ..			.dmark: db "DO2"  
30b9 f1			.pastdmark: pop af  
30ba			endm  
# End of macro DMARK
30ba						CALLMONITOR 
30ba cd 17 16			call break_point_state  
30bd				endm  
# End of macro CALLMONITOR
30bd					endif 
30bd					FORTH_RSP_NEXT 
30bd cd 4b 1b			call macro_forth_rsp_next 
30c0				endm 
# End of macro FORTH_RSP_NEXT
30c0					if DEBUG_FORTH_WORDS 
30c0						DMARK "DO3" 
30c0 f5				push af  
30c1 3a d5 30			ld a, (.dmark)  
30c4 32 77 fb			ld (debug_mark),a  
30c7 3a d6 30			ld a, (.dmark+1)  
30ca 32 78 fb			ld (debug_mark+1),a  
30cd 3a d7 30			ld a, (.dmark+2)  
30d0 32 79 fb			ld (debug_mark+2),a  
30d3 18 03			jr .pastdmark  
30d5 ..			.dmark: db "DO3"  
30d8 f1			.pastdmark: pop af  
30d9			endm  
# End of macro DMARK
30d9						CALLMONITOR 
30d9 cd 17 16			call break_point_state  
30dc				endm  
# End of macro CALLMONITOR
30dc					endif 
30dc			 
30dc					;if DEBUG_FORTH_WORDS 
30dc				;		push hl 
30dc			;		endif  
30dc			 
30dc			; get counters from data stack 
30dc			 
30dc			 
30dc					FORTH_DSP_VALUEHL 
30dc cd 9b 1d			call macro_dsp_valuehl 
30df				endm 
# End of macro FORTH_DSP_VALUEHL
30df e5					push hl		 ; hl now has starting counter which needs to be tos 
30e0			 
30e0					if DEBUG_FORTH_WORDS 
30e0						DMARK "DO4" 
30e0 f5				push af  
30e1 3a f5 30			ld a, (.dmark)  
30e4 32 77 fb			ld (debug_mark),a  
30e7 3a f6 30			ld a, (.dmark+1)  
30ea 32 78 fb			ld (debug_mark+1),a  
30ed 3a f7 30			ld a, (.dmark+2)  
30f0 32 79 fb			ld (debug_mark+2),a  
30f3 18 03			jr .pastdmark  
30f5 ..			.dmark: db "DO4"  
30f8 f1			.pastdmark: pop af  
30f9			endm  
# End of macro DMARK
30f9						CALLMONITOR 
30f9 cd 17 16			call break_point_state  
30fc				endm  
# End of macro CALLMONITOR
30fc					endif 
30fc					FORTH_DSP_POP 
30fc cd 53 1e			call macro_forth_dsp_pop 
30ff				endm 
# End of macro FORTH_DSP_POP
30ff			 
30ff					if DEBUG_FORTH_WORDS 
30ff						DMARK "DO5" 
30ff f5				push af  
3100 3a 14 31			ld a, (.dmark)  
3103 32 77 fb			ld (debug_mark),a  
3106 3a 15 31			ld a, (.dmark+1)  
3109 32 78 fb			ld (debug_mark+1),a  
310c 3a 16 31			ld a, (.dmark+2)  
310f 32 79 fb			ld (debug_mark+2),a  
3112 18 03			jr .pastdmark  
3114 ..			.dmark: db "DO5"  
3117 f1			.pastdmark: pop af  
3118			endm  
# End of macro DMARK
3118						CALLMONITOR 
3118 cd 17 16			call break_point_state  
311b				endm  
# End of macro CALLMONITOR
311b					endif 
311b			 
311b					FORTH_DSP_VALUEHL 
311b cd 9b 1d			call macro_dsp_valuehl 
311e				endm 
# End of macro FORTH_DSP_VALUEHL
311e			;		push hl		 ; hl now has starting limit counter 
311e			 
311e					if DEBUG_FORTH_WORDS 
311e						DMARK "DO6" 
311e f5				push af  
311f 3a 33 31			ld a, (.dmark)  
3122 32 77 fb			ld (debug_mark),a  
3125 3a 34 31			ld a, (.dmark+1)  
3128 32 78 fb			ld (debug_mark+1),a  
312b 3a 35 31			ld a, (.dmark+2)  
312e 32 79 fb			ld (debug_mark+2),a  
3131 18 03			jr .pastdmark  
3133 ..			.dmark: db "DO6"  
3136 f1			.pastdmark: pop af  
3137			endm  
# End of macro DMARK
3137						CALLMONITOR 
3137 cd 17 16			call break_point_state  
313a				endm  
# End of macro CALLMONITOR
313a					endif 
313a					FORTH_DSP_POP 
313a cd 53 1e			call macro_forth_dsp_pop 
313d				endm 
# End of macro FORTH_DSP_POP
313d			 
313d			; put counters on the loop stack 
313d			 
313d			;		pop hl			 ; limit counter 
313d d1					pop de			; start counter 
313e			 
313e					; push limit counter 
313e			 
313e					if DEBUG_FORTH_WORDS 
313e						DMARK "DO7" 
313e f5				push af  
313f 3a 53 31			ld a, (.dmark)  
3142 32 77 fb			ld (debug_mark),a  
3145 3a 54 31			ld a, (.dmark+1)  
3148 32 78 fb			ld (debug_mark+1),a  
314b 3a 55 31			ld a, (.dmark+2)  
314e 32 79 fb			ld (debug_mark+2),a  
3151 18 03			jr .pastdmark  
3153 ..			.dmark: db "DO7"  
3156 f1			.pastdmark: pop af  
3157			endm  
# End of macro DMARK
3157						CALLMONITOR 
3157 cd 17 16			call break_point_state  
315a				endm  
# End of macro CALLMONITOR
315a					endif 
315a					FORTH_LOOP_NEXT 
315a cd cc 1d			call macro_forth_loop_next 
315d				endm 
# End of macro FORTH_LOOP_NEXT
315d			 
315d					; push start counter 
315d			 
315d eb					ex de, hl 
315e					if DEBUG_FORTH_WORDS 
315e						DMARK "DO7" 
315e f5				push af  
315f 3a 73 31			ld a, (.dmark)  
3162 32 77 fb			ld (debug_mark),a  
3165 3a 74 31			ld a, (.dmark+1)  
3168 32 78 fb			ld (debug_mark+1),a  
316b 3a 75 31			ld a, (.dmark+2)  
316e 32 79 fb			ld (debug_mark+2),a  
3171 18 03			jr .pastdmark  
3173 ..			.dmark: db "DO7"  
3176 f1			.pastdmark: pop af  
3177			endm  
# End of macro DMARK
3177						CALLMONITOR 
3177 cd 17 16			call break_point_state  
317a				endm  
# End of macro CALLMONITOR
317a					endif 
317a					FORTH_LOOP_NEXT 
317a cd cc 1d			call macro_forth_loop_next 
317d				endm 
# End of macro FORTH_LOOP_NEXT
317d			 
317d			 
317d					; init first round of I counter 
317d			 
317d 22 56 f1				ld (os_current_i), hl 
3180			 
3180					if DEBUG_FORTH_WORDS 
3180						DMARK "DO8" 
3180 f5				push af  
3181 3a 95 31			ld a, (.dmark)  
3184 32 77 fb			ld (debug_mark),a  
3187 3a 96 31			ld a, (.dmark+1)  
318a 32 78 fb			ld (debug_mark+1),a  
318d 3a 97 31			ld a, (.dmark+2)  
3190 32 79 fb			ld (debug_mark+2),a  
3193 18 03			jr .pastdmark  
3195 ..			.dmark: db "DO8"  
3198 f1			.pastdmark: pop af  
3199			endm  
# End of macro DMARK
3199						CALLMONITOR 
3199 cd 17 16			call break_point_state  
319c				endm  
# End of macro CALLMONITOR
319c					endif 
319c			 
319c					NEXTW 
319c c3 0d 1f			jp macro_next 
319f				endm 
# End of macro NEXTW
319f			.LOOP: 
319f				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
319f 22				db WORD_SYS_CORE+14             
31a0 b7 32			dw .I            
31a2 05				db 4 + 1 
31a3 .. 00			db "LOOP",0              
31a8				endm 
# End of macro CWHEAD
31a8			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31a8			 
31a8				; pop tos as current loop count to hl 
31a8			 
31a8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31a8			 
31a8				FORTH_LOOP_TOS 
31a8 cd ff 1d			call macro_forth_loop_tos 
31ab				endm 
# End of macro FORTH_LOOP_TOS
31ab e5				push hl 
31ac			 
31ac					if DEBUG_FORTH_WORDS_KEY 
31ac						DMARK "LOP" 
31ac f5				push af  
31ad 3a c1 31			ld a, (.dmark)  
31b0 32 77 fb			ld (debug_mark),a  
31b3 3a c2 31			ld a, (.dmark+1)  
31b6 32 78 fb			ld (debug_mark+1),a  
31b9 3a c3 31			ld a, (.dmark+2)  
31bc 32 79 fb			ld (debug_mark+2),a  
31bf 18 03			jr .pastdmark  
31c1 ..			.dmark: db "LOP"  
31c4 f1			.pastdmark: pop af  
31c5			endm  
# End of macro DMARK
31c5						CALLMONITOR 
31c5 cd 17 16			call break_point_state  
31c8				endm  
# End of macro CALLMONITOR
31c8					endif 
31c8				; next item on the stack is the limit. get it 
31c8			 
31c8			 
31c8				FORTH_LOOP_POP 
31c8 cd 09 1e			call macro_forth_loop_pop 
31cb				endm 
# End of macro FORTH_LOOP_POP
31cb			 
31cb				FORTH_LOOP_TOS 
31cb cd ff 1d			call macro_forth_loop_tos 
31ce				endm 
# End of macro FORTH_LOOP_TOS
31ce			 
31ce d1				pop de		 ; de = i, hl = limit 
31cf			 
31cf					if DEBUG_FORTH_WORDS 
31cf						DMARK "LP1" 
31cf f5				push af  
31d0 3a e4 31			ld a, (.dmark)  
31d3 32 77 fb			ld (debug_mark),a  
31d6 3a e5 31			ld a, (.dmark+1)  
31d9 32 78 fb			ld (debug_mark+1),a  
31dc 3a e6 31			ld a, (.dmark+2)  
31df 32 79 fb			ld (debug_mark+2),a  
31e2 18 03			jr .pastdmark  
31e4 ..			.dmark: db "LP1"  
31e7 f1			.pastdmark: pop af  
31e8			endm  
# End of macro DMARK
31e8						CALLMONITOR 
31e8 cd 17 16			call break_point_state  
31eb				endm  
# End of macro CALLMONITOR
31eb					endif 
31eb			 
31eb				; go back to previous word 
31eb			 
31eb d5				push de    ; save I for inc later 
31ec			 
31ec			 
31ec				; get limit 
31ec				;  is I at limit? 
31ec			 
31ec			 
31ec					if DEBUG_FORTH_WORDS 
31ec						DMARK "LP1" 
31ec f5				push af  
31ed 3a 01 32			ld a, (.dmark)  
31f0 32 77 fb			ld (debug_mark),a  
31f3 3a 02 32			ld a, (.dmark+1)  
31f6 32 78 fb			ld (debug_mark+1),a  
31f9 3a 03 32			ld a, (.dmark+2)  
31fc 32 79 fb			ld (debug_mark+2),a  
31ff 18 03			jr .pastdmark  
3201 ..			.dmark: db "LP1"  
3204 f1			.pastdmark: pop af  
3205			endm  
# End of macro DMARK
3205						CALLMONITOR 
3205 cd 17 16			call break_point_state  
3208				endm  
# End of macro CALLMONITOR
3208					endif 
3208			 
3208 ed 52			sbc hl, de 
320a			 
320a			 
320a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
320a			 
320a 20 26				jr nz, .loopnotdone 
320c			 
320c e1				pop hl   ; get rid of saved I 
320d				FORTH_LOOP_POP     ; get rid of limit 
320d cd 09 1e			call macro_forth_loop_pop 
3210				endm 
# End of macro FORTH_LOOP_POP
3210			 
3210				FORTH_RSP_POP     ; get rid of DO ptr 
3210 cd 6c 1b			call macro_forth_rsp_pop 
3213				endm 
# End of macro FORTH_RSP_POP
3213			 
3213			if DEBUG_FORTH_WORDS 
3213						DMARK "LP>" 
3213 f5				push af  
3214 3a 28 32			ld a, (.dmark)  
3217 32 77 fb			ld (debug_mark),a  
321a 3a 29 32			ld a, (.dmark+1)  
321d 32 78 fb			ld (debug_mark+1),a  
3220 3a 2a 32			ld a, (.dmark+2)  
3223 32 79 fb			ld (debug_mark+2),a  
3226 18 03			jr .pastdmark  
3228 ..			.dmark: db "LP>"  
322b f1			.pastdmark: pop af  
322c			endm  
# End of macro DMARK
322c				CALLMONITOR 
322c cd 17 16			call break_point_state  
322f				endm  
# End of macro CALLMONITOR
322f			endif 
322f			 
322f					NEXTW 
322f c3 0d 1f			jp macro_next 
3232				endm 
# End of macro NEXTW
3232				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3232			 
3232			.loopnotdone: 
3232			 
3232 e1				pop hl    ; get I 
3233 23				inc hl 
3234			 
3234			   	; save new I 
3234			 
3234			 
3234					; set I counter 
3234			 
3234 22 56 f1				ld (os_current_i), hl 
3237			 
3237					if DEBUG_FORTH_WORDS 
3237						DMARK "LPN" 
3237 f5				push af  
3238 3a 4c 32			ld a, (.dmark)  
323b 32 77 fb			ld (debug_mark),a  
323e 3a 4d 32			ld a, (.dmark+1)  
3241 32 78 fb			ld (debug_mark+1),a  
3244 3a 4e 32			ld a, (.dmark+2)  
3247 32 79 fb			ld (debug_mark+2),a  
324a 18 03			jr .pastdmark  
324c ..			.dmark: db "LPN"  
324f f1			.pastdmark: pop af  
3250			endm  
# End of macro DMARK
3250					CALLMONITOR 
3250 cd 17 16			call break_point_state  
3253				endm  
# End of macro CALLMONITOR
3253					endif 
3253					 
3253				FORTH_LOOP_NEXT 
3253 cd cc 1d			call macro_forth_loop_next 
3256				endm 
# End of macro FORTH_LOOP_NEXT
3256			 
3256			 
3256					if DEBUG_FORTH_WORDS 
3256 eb						ex de,hl 
3257					endif 
3257			 
3257			;	; get DO ptr 
3257			; 
3257					if DEBUG_FORTH_WORDS 
3257						DMARK "LP7" 
3257 f5				push af  
3258 3a 6c 32			ld a, (.dmark)  
325b 32 77 fb			ld (debug_mark),a  
325e 3a 6d 32			ld a, (.dmark+1)  
3261 32 78 fb			ld (debug_mark+1),a  
3264 3a 6e 32			ld a, (.dmark+2)  
3267 32 79 fb			ld (debug_mark+2),a  
326a 18 03			jr .pastdmark  
326c ..			.dmark: db "LP7"  
326f f1			.pastdmark: pop af  
3270			endm  
# End of macro DMARK
3270					CALLMONITOR 
3270 cd 17 16			call break_point_state  
3273				endm  
# End of macro CALLMONITOR
3273					endif 
3273				FORTH_RSP_TOS 
3273 cd 62 1b			call macro_forth_rsp_tos 
3276				endm 
# End of macro FORTH_RSP_TOS
3276			 
3276					if DEBUG_FORTH_WORDS 
3276						DMARK "LP8" 
3276 f5				push af  
3277 3a 8b 32			ld a, (.dmark)  
327a 32 77 fb			ld (debug_mark),a  
327d 3a 8c 32			ld a, (.dmark+1)  
3280 32 78 fb			ld (debug_mark+1),a  
3283 3a 8d 32			ld a, (.dmark+2)  
3286 32 79 fb			ld (debug_mark+2),a  
3289 18 03			jr .pastdmark  
328b ..			.dmark: db "LP8"  
328e f1			.pastdmark: pop af  
328f			endm  
# End of macro DMARK
328f					CALLMONITOR 
328f cd 17 16			call break_point_state  
3292				endm  
# End of macro CALLMONITOR
3292					endif 
3292				;push hl 
3292			 
3292				; not going to DO any more 
3292				; get rid of the RSP pointer as DO will add it back in 
3292				;FORTH_RSP_POP 
3292				;pop hl 
3292			 
3292				;ld hl,(cli_ret_sp) 
3292				;ld e, (hl) 
3292				;inc hl 
3292				;ld d, (hl) 
3292				;ex de,hl 
3292 22 32 f1			ld (os_tok_ptr), hl 
3295					if DEBUG_FORTH_WORDS 
3295						DMARK "LP<" 
3295 f5				push af  
3296 3a aa 32			ld a, (.dmark)  
3299 32 77 fb			ld (debug_mark),a  
329c 3a ab 32			ld a, (.dmark+1)  
329f 32 78 fb			ld (debug_mark+1),a  
32a2 3a ac 32			ld a, (.dmark+2)  
32a5 32 79 fb			ld (debug_mark+2),a  
32a8 18 03			jr .pastdmark  
32aa ..			.dmark: db "LP<"  
32ad f1			.pastdmark: pop af  
32ae			endm  
# End of macro DMARK
32ae					CALLMONITOR 
32ae cd 17 16			call break_point_state  
32b1				endm  
# End of macro CALLMONITOR
32b1				endif 
32b1 c3 9e 1f			jp exec1 
32b4			 
32b4					 
32b4			 
32b4			 
32b4					NEXTW 
32b4 c3 0d 1f			jp macro_next 
32b7				endm 
# End of macro NEXTW
32b7			.I:  
32b7			 
32b7				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32b7 5e				db WORD_SYS_CORE+74             
32b8 e2 32			dw .DLOOP            
32ba 02				db 1 + 1 
32bb .. 00			db "I",0              
32bd				endm 
# End of macro CWHEAD
32bd			; | I ( -- ) Current loop counter | DONE 
32bd					if DEBUG_FORTH_WORDS_KEY 
32bd						DMARK "I.." 
32bd f5				push af  
32be 3a d2 32			ld a, (.dmark)  
32c1 32 77 fb			ld (debug_mark),a  
32c4 3a d3 32			ld a, (.dmark+1)  
32c7 32 78 fb			ld (debug_mark+1),a  
32ca 3a d4 32			ld a, (.dmark+2)  
32cd 32 79 fb			ld (debug_mark+2),a  
32d0 18 03			jr .pastdmark  
32d2 ..			.dmark: db "I.."  
32d5 f1			.pastdmark: pop af  
32d6			endm  
# End of macro DMARK
32d6						CALLMONITOR 
32d6 cd 17 16			call break_point_state  
32d9				endm  
# End of macro CALLMONITOR
32d9					endif 
32d9			 
32d9 2a 56 f1				ld hl,(os_current_i) 
32dc cd a4 1b				call forth_push_numhl 
32df			 
32df					NEXTW 
32df c3 0d 1f			jp macro_next 
32e2				endm 
# End of macro NEXTW
32e2			.DLOOP: 
32e2				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32e2 5f				db WORD_SYS_CORE+75             
32e3 c3 33			dw .REPEAT            
32e5 06				db 5 + 1 
32e6 .. 00			db "-LOOP",0              
32ec				endm 
# End of macro CWHEAD
32ec			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
32ec				; pop tos as current loop count to hl 
32ec					if DEBUG_FORTH_WORDS_KEY 
32ec						DMARK "-LP" 
32ec f5				push af  
32ed 3a 01 33			ld a, (.dmark)  
32f0 32 77 fb			ld (debug_mark),a  
32f3 3a 02 33			ld a, (.dmark+1)  
32f6 32 78 fb			ld (debug_mark+1),a  
32f9 3a 03 33			ld a, (.dmark+2)  
32fc 32 79 fb			ld (debug_mark+2),a  
32ff 18 03			jr .pastdmark  
3301 ..			.dmark: db "-LP"  
3304 f1			.pastdmark: pop af  
3305			endm  
# End of macro DMARK
3305						CALLMONITOR 
3305 cd 17 16			call break_point_state  
3308				endm  
# End of macro CALLMONITOR
3308					endif 
3308			 
3308				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3308			 
3308				FORTH_LOOP_TOS 
3308 cd ff 1d			call macro_forth_loop_tos 
330b				endm 
# End of macro FORTH_LOOP_TOS
330b e5				push hl 
330c			 
330c					if DEBUG_FORTH_WORDS 
330c						DMARK "-LP" 
330c f5				push af  
330d 3a 21 33			ld a, (.dmark)  
3310 32 77 fb			ld (debug_mark),a  
3313 3a 22 33			ld a, (.dmark+1)  
3316 32 78 fb			ld (debug_mark+1),a  
3319 3a 23 33			ld a, (.dmark+2)  
331c 32 79 fb			ld (debug_mark+2),a  
331f 18 03			jr .pastdmark  
3321 ..			.dmark: db "-LP"  
3324 f1			.pastdmark: pop af  
3325			endm  
# End of macro DMARK
3325						CALLMONITOR 
3325 cd 17 16			call break_point_state  
3328				endm  
# End of macro CALLMONITOR
3328					endif 
3328				; next item on the stack is the limit. get it 
3328			 
3328			 
3328				FORTH_LOOP_POP 
3328 cd 09 1e			call macro_forth_loop_pop 
332b				endm 
# End of macro FORTH_LOOP_POP
332b			 
332b				FORTH_LOOP_TOS 
332b cd ff 1d			call macro_forth_loop_tos 
332e				endm 
# End of macro FORTH_LOOP_TOS
332e			 
332e d1				pop de		 ; de = i, hl = limit 
332f			 
332f					if DEBUG_FORTH_WORDS 
332f						DMARK "-L1" 
332f f5				push af  
3330 3a 44 33			ld a, (.dmark)  
3333 32 77 fb			ld (debug_mark),a  
3336 3a 45 33			ld a, (.dmark+1)  
3339 32 78 fb			ld (debug_mark+1),a  
333c 3a 46 33			ld a, (.dmark+2)  
333f 32 79 fb			ld (debug_mark+2),a  
3342 18 03			jr .pastdmark  
3344 ..			.dmark: db "-L1"  
3347 f1			.pastdmark: pop af  
3348			endm  
# End of macro DMARK
3348						CALLMONITOR 
3348 cd 17 16			call break_point_state  
334b				endm  
# End of macro CALLMONITOR
334b					endif 
334b			 
334b				; go back to previous word 
334b			 
334b d5				push de    ; save I for inc later 
334c			 
334c			 
334c				; get limit 
334c				;  is I at limit? 
334c			 
334c			 
334c					if DEBUG_FORTH_WORDS 
334c						DMARK "-L1" 
334c f5				push af  
334d 3a 61 33			ld a, (.dmark)  
3350 32 77 fb			ld (debug_mark),a  
3353 3a 62 33			ld a, (.dmark+1)  
3356 32 78 fb			ld (debug_mark+1),a  
3359 3a 63 33			ld a, (.dmark+2)  
335c 32 79 fb			ld (debug_mark+2),a  
335f 18 03			jr .pastdmark  
3361 ..			.dmark: db "-L1"  
3364 f1			.pastdmark: pop af  
3365			endm  
# End of macro DMARK
3365						CALLMONITOR 
3365 cd 17 16			call break_point_state  
3368				endm  
# End of macro CALLMONITOR
3368					endif 
3368			 
3368 ed 52			sbc hl, de 
336a			 
336a			 
336a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
336a			 
336a 20 26				jr nz, .mloopnotdone 
336c			 
336c e1				pop hl   ; get rid of saved I 
336d				FORTH_LOOP_POP     ; get rid of limit 
336d cd 09 1e			call macro_forth_loop_pop 
3370				endm 
# End of macro FORTH_LOOP_POP
3370			 
3370				FORTH_RSP_POP     ; get rid of DO ptr 
3370 cd 6c 1b			call macro_forth_rsp_pop 
3373				endm 
# End of macro FORTH_RSP_POP
3373			 
3373			if DEBUG_FORTH_WORDS 
3373						DMARK "-L>" 
3373 f5				push af  
3374 3a 88 33			ld a, (.dmark)  
3377 32 77 fb			ld (debug_mark),a  
337a 3a 89 33			ld a, (.dmark+1)  
337d 32 78 fb			ld (debug_mark+1),a  
3380 3a 8a 33			ld a, (.dmark+2)  
3383 32 79 fb			ld (debug_mark+2),a  
3386 18 03			jr .pastdmark  
3388 ..			.dmark: db "-L>"  
338b f1			.pastdmark: pop af  
338c			endm  
# End of macro DMARK
338c				CALLMONITOR 
338c cd 17 16			call break_point_state  
338f				endm  
# End of macro CALLMONITOR
338f			endif 
338f			 
338f					NEXTW 
338f c3 0d 1f			jp macro_next 
3392				endm 
# End of macro NEXTW
3392				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3392			 
3392			.mloopnotdone: 
3392			 
3392 e1				pop hl    ; get I 
3393 2b				dec hl 
3394			 
3394			   	; save new I 
3394			 
3394			 
3394					; set I counter 
3394			 
3394 22 56 f1				ld (os_current_i), hl 
3397			 
3397					 
3397				FORTH_LOOP_NEXT 
3397 cd cc 1d			call macro_forth_loop_next 
339a				endm 
# End of macro FORTH_LOOP_NEXT
339a			 
339a			 
339a					if DEBUG_FORTH_WORDS 
339a eb						ex de,hl 
339b					endif 
339b			 
339b			;	; get DO ptr 
339b			; 
339b				FORTH_RSP_TOS 
339b cd 62 1b			call macro_forth_rsp_tos 
339e				endm 
# End of macro FORTH_RSP_TOS
339e			 
339e				;push hl 
339e			 
339e				; not going to DO any more 
339e				; get rid of the RSP pointer as DO will add it back in 
339e				;FORTH_RSP_POP 
339e				;pop hl 
339e			 
339e			 
339e 22 32 f1			ld (os_tok_ptr), hl 
33a1					if DEBUG_FORTH_WORDS 
33a1						DMARK "-L<" 
33a1 f5				push af  
33a2 3a b6 33			ld a, (.dmark)  
33a5 32 77 fb			ld (debug_mark),a  
33a8 3a b7 33			ld a, (.dmark+1)  
33ab 32 78 fb			ld (debug_mark+1),a  
33ae 3a b8 33			ld a, (.dmark+2)  
33b1 32 79 fb			ld (debug_mark+2),a  
33b4 18 03			jr .pastdmark  
33b6 ..			.dmark: db "-L<"  
33b9 f1			.pastdmark: pop af  
33ba			endm  
# End of macro DMARK
33ba					CALLMONITOR 
33ba cd 17 16			call break_point_state  
33bd				endm  
# End of macro CALLMONITOR
33bd				endif 
33bd c3 9e 1f			jp exec1 
33c0			 
33c0					 
33c0			 
33c0			 
33c0			 
33c0				NEXTW 
33c0 c3 0d 1f			jp macro_next 
33c3				endm 
# End of macro NEXTW
33c3			 
33c3			 
33c3			 
33c3			 
33c3			.REPEAT: 
33c3				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33c3 71				db WORD_SYS_CORE+93             
33c4 16 34			dw .UNTIL            
33c6 06				db 5 + 1 
33c7 .. 00			db "REPEAT",0              
33ce				endm 
# End of macro CWHEAD
33ce			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33ce			;  push pc to rsp stack past the REPEAT 
33ce					if DEBUG_FORTH_WORDS_KEY 
33ce						DMARK "REP" 
33ce f5				push af  
33cf 3a e3 33			ld a, (.dmark)  
33d2 32 77 fb			ld (debug_mark),a  
33d5 3a e4 33			ld a, (.dmark+1)  
33d8 32 78 fb			ld (debug_mark+1),a  
33db 3a e5 33			ld a, (.dmark+2)  
33de 32 79 fb			ld (debug_mark+2),a  
33e1 18 03			jr .pastdmark  
33e3 ..			.dmark: db "REP"  
33e6 f1			.pastdmark: pop af  
33e7			endm  
# End of macro DMARK
33e7						CALLMONITOR 
33e7 cd 17 16			call break_point_state  
33ea				endm  
# End of macro CALLMONITOR
33ea					endif 
33ea			 
33ea 2a 32 f1				ld hl, (os_tok_ptr) 
33ed 23					inc hl   ; R 
33ee 23					inc hl  ; E 
33ef 23					inc hl   ; P 
33f0 23					inc hl   ; E 
33f1 23					inc hl   ; A 
33f2 23					inc hl   ; T 
33f3 23					inc hl   ; zero 
33f4					FORTH_RSP_NEXT 
33f4 cd 4b 1b			call macro_forth_rsp_next 
33f7				endm 
# End of macro FORTH_RSP_NEXT
33f7			 
33f7			 
33f7					if DEBUG_FORTH_WORDS 
33f7						DMARK "REP" 
33f7 f5				push af  
33f8 3a 0c 34			ld a, (.dmark)  
33fb 32 77 fb			ld (debug_mark),a  
33fe 3a 0d 34			ld a, (.dmark+1)  
3401 32 78 fb			ld (debug_mark+1),a  
3404 3a 0e 34			ld a, (.dmark+2)  
3407 32 79 fb			ld (debug_mark+2),a  
340a 18 03			jr .pastdmark  
340c ..			.dmark: db "REP"  
340f f1			.pastdmark: pop af  
3410			endm  
# End of macro DMARK
3410						;pop bc    ; TODO BUG ?????? what is this for???? 
3410						CALLMONITOR 
3410 cd 17 16			call break_point_state  
3413				endm  
# End of macro CALLMONITOR
3413					endif 
3413			 
3413					NEXTW 
3413 c3 0d 1f			jp macro_next 
3416				endm 
# End of macro NEXTW
3416			;	       NEXTW 
3416			 
3416			.UNTIL: 
3416				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3416 72				db WORD_SYS_CORE+94             
3417 ad 34			dw .ENDFLOW            
3419 06				db 5 + 1 
341a .. 00			db "UNTIL",0              
3420				endm 
# End of macro CWHEAD
3420			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3420			 
3420				; pop tos as check 
3420			 
3420				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3420			 
3420				FORTH_DSP_VALUEHL 
3420 cd 9b 1d			call macro_dsp_valuehl 
3423				endm 
# End of macro FORTH_DSP_VALUEHL
3423			 
3423					if DEBUG_FORTH_WORDS_KEY 
3423						DMARK "UNT" 
3423 f5				push af  
3424 3a 38 34			ld a, (.dmark)  
3427 32 77 fb			ld (debug_mark),a  
342a 3a 39 34			ld a, (.dmark+1)  
342d 32 78 fb			ld (debug_mark+1),a  
3430 3a 3a 34			ld a, (.dmark+2)  
3433 32 79 fb			ld (debug_mark+2),a  
3436 18 03			jr .pastdmark  
3438 ..			.dmark: db "UNT"  
343b f1			.pastdmark: pop af  
343c			endm  
# End of macro DMARK
343c						CALLMONITOR 
343c cd 17 16			call break_point_state  
343f				endm  
# End of macro CALLMONITOR
343f					endif 
343f			 
343f			;	push hl 
343f				FORTH_DSP_POP 
343f cd 53 1e			call macro_forth_dsp_pop 
3442				endm 
# End of macro FORTH_DSP_POP
3442			 
3442			;	pop hl 
3442			 
3442				; test if true 
3442			 
3442 cd f4 0c			call ishlzero 
3445			;	ld a,l 
3445			;	add h 
3445			; 
3445			;	cp 0 
3445			 
3445 20 3e			jr nz, .untilnotdone 
3447			 
3447					if DEBUG_FORTH_WORDS 
3447						DMARK "UNf" 
3447 f5				push af  
3448 3a 5c 34			ld a, (.dmark)  
344b 32 77 fb			ld (debug_mark),a  
344e 3a 5d 34			ld a, (.dmark+1)  
3451 32 78 fb			ld (debug_mark+1),a  
3454 3a 5e 34			ld a, (.dmark+2)  
3457 32 79 fb			ld (debug_mark+2),a  
345a 18 03			jr .pastdmark  
345c ..			.dmark: db "UNf"  
345f f1			.pastdmark: pop af  
3460			endm  
# End of macro DMARK
3460						CALLMONITOR 
3460 cd 17 16			call break_point_state  
3463				endm  
# End of macro CALLMONITOR
3463					endif 
3463			 
3463			 
3463			 
3463				FORTH_RSP_POP     ; get rid of DO ptr 
3463 cd 6c 1b			call macro_forth_rsp_pop 
3466				endm 
# End of macro FORTH_RSP_POP
3466			 
3466			if DEBUG_FORTH_WORDS 
3466						DMARK "UN>" 
3466 f5				push af  
3467 3a 7b 34			ld a, (.dmark)  
346a 32 77 fb			ld (debug_mark),a  
346d 3a 7c 34			ld a, (.dmark+1)  
3470 32 78 fb			ld (debug_mark+1),a  
3473 3a 7d 34			ld a, (.dmark+2)  
3476 32 79 fb			ld (debug_mark+2),a  
3479 18 03			jr .pastdmark  
347b ..			.dmark: db "UN>"  
347e f1			.pastdmark: pop af  
347f			endm  
# End of macro DMARK
347f				CALLMONITOR 
347f cd 17 16			call break_point_state  
3482				endm  
# End of macro CALLMONITOR
3482			endif 
3482			 
3482					NEXTW 
3482 c3 0d 1f			jp macro_next 
3485				endm 
# End of macro NEXTW
3485				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3485			 
3485			.untilnotdone: 
3485			 
3485			 
3485			;	; get DO ptr 
3485			; 
3485				FORTH_RSP_TOS 
3485 cd 62 1b			call macro_forth_rsp_tos 
3488				endm 
# End of macro FORTH_RSP_TOS
3488			 
3488				;push hl 
3488			 
3488				; not going to DO any more 
3488				; get rid of the RSP pointer as DO will add it back in 
3488				;FORTH_RSP_POP 
3488				;pop hl 
3488			 
3488			 
3488 22 32 f1			ld (os_tok_ptr), hl 
348b					if DEBUG_FORTH_WORDS 
348b						DMARK "UN<" 
348b f5				push af  
348c 3a a0 34			ld a, (.dmark)  
348f 32 77 fb			ld (debug_mark),a  
3492 3a a1 34			ld a, (.dmark+1)  
3495 32 78 fb			ld (debug_mark+1),a  
3498 3a a2 34			ld a, (.dmark+2)  
349b 32 79 fb			ld (debug_mark+2),a  
349e 18 03			jr .pastdmark  
34a0 ..			.dmark: db "UN<"  
34a3 f1			.pastdmark: pop af  
34a4			endm  
# End of macro DMARK
34a4					CALLMONITOR 
34a4 cd 17 16			call break_point_state  
34a7				endm  
# End of macro CALLMONITOR
34a7				endif 
34a7 c3 9e 1f			jp exec1 
34aa			 
34aa					 
34aa			 
34aa			 
34aa					NEXTW 
34aa c3 0d 1f			jp macro_next 
34ad				endm 
# End of macro NEXTW
34ad			 
34ad			 
34ad			.ENDFLOW: 
34ad			 
34ad			; eof 
34ad			 
# End of file forth_words_flow.asm
34ad			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34ad			include "forth_words_logic.asm" 
34ad			 
34ad			; | ## Logic Words 
34ad			 
34ad			.NOT: 
34ad				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34ad 2d				db WORD_SYS_CORE+25             
34ae f5 34			dw .IS            
34b0 04				db 3 + 1 
34b1 .. 00			db "NOT",0              
34b5				endm 
# End of macro CWHEAD
34b5			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34b5					if DEBUG_FORTH_WORDS_KEY 
34b5						DMARK "NOT" 
34b5 f5				push af  
34b6 3a ca 34			ld a, (.dmark)  
34b9 32 77 fb			ld (debug_mark),a  
34bc 3a cb 34			ld a, (.dmark+1)  
34bf 32 78 fb			ld (debug_mark+1),a  
34c2 3a cc 34			ld a, (.dmark+2)  
34c5 32 79 fb			ld (debug_mark+2),a  
34c8 18 03			jr .pastdmark  
34ca ..			.dmark: db "NOT"  
34cd f1			.pastdmark: pop af  
34ce			endm  
# End of macro DMARK
34ce						CALLMONITOR 
34ce cd 17 16			call break_point_state  
34d1				endm  
# End of macro CALLMONITOR
34d1					endif 
34d1					FORTH_DSP 
34d1 cd 61 1d			call macro_forth_dsp 
34d4				endm 
# End of macro FORTH_DSP
34d4 7e					ld a,(hl)	; get type of value on TOS 
34d5 fe 02				cp DS_TYPE_INUM  
34d7 28 03				jr z, .noti 
34d9					NEXTW 
34d9 c3 0d 1f			jp macro_next 
34dc				endm 
# End of macro NEXTW
34dc			.noti:          FORTH_DSP_VALUEHL 
34dc cd 9b 1d			call macro_dsp_valuehl 
34df				endm 
# End of macro FORTH_DSP_VALUEHL
34df			;		push hl 
34df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34df cd 53 1e			call macro_forth_dsp_pop 
34e2				endm 
# End of macro FORTH_DSP_POP
34e2			;		pop hl 
34e2 3e 00				ld a,0 
34e4 bd					cp l 
34e5 28 04				jr z, .not2t 
34e7 2e 00				ld l, 0 
34e9 18 02				jr .notip 
34eb			 
34eb 2e ff		.not2t:		ld l, 255 
34ed			 
34ed 26 00		.notip:		ld h, 0	 
34ef			 
34ef cd a4 1b				call forth_push_numhl 
34f2					NEXTW 
34f2 c3 0d 1f			jp macro_next 
34f5				endm 
# End of macro NEXTW
34f5			 
34f5			.IS: 
34f5				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
34f5 2d				db WORD_SYS_CORE+25             
34f6 1b 35			dw .LZERO            
34f8 03				db 2 + 1 
34f9 .. 00			db "IS",0              
34fc				endm 
# End of macro CWHEAD
34fc			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
34fc					if DEBUG_FORTH_WORDS_KEY 
34fc						DMARK "IS." 
34fc f5				push af  
34fd 3a 11 35			ld a, (.dmark)  
3500 32 77 fb			ld (debug_mark),a  
3503 3a 12 35			ld a, (.dmark+1)  
3506 32 78 fb			ld (debug_mark+1),a  
3509 3a 13 35			ld a, (.dmark+2)  
350c 32 79 fb			ld (debug_mark+2),a  
350f 18 03			jr .pastdmark  
3511 ..			.dmark: db "IS."  
3514 f1			.pastdmark: pop af  
3515			endm  
# End of macro DMARK
3515						CALLMONITOR 
3515 cd 17 16			call break_point_state  
3518				endm  
# End of macro CALLMONITOR
3518					endif 
3518					NEXTW 
3518 c3 0d 1f			jp macro_next 
351b				endm 
# End of macro NEXTW
351b			.LZERO: 
351b				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
351b 2d				db WORD_SYS_CORE+25             
351c 25 35			dw .TZERO            
351e 03				db 2 + 1 
351f .. 00			db "0<",0              
3522				endm 
# End of macro CWHEAD
3522			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3522					NEXTW 
3522 c3 0d 1f			jp macro_next 
3525				endm 
# End of macro NEXTW
3525			.TZERO: 
3525				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3525 2e				db WORD_SYS_CORE+26             
3526 6c 35			dw .LESS            
3528 03				db 2 + 1 
3529 .. 00			db "0=",0              
352c				endm 
# End of macro CWHEAD
352c			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
352c				; TODO add floating point number detection 
352c					;v5 FORTH_DSP_VALUE 
352c					if DEBUG_FORTH_WORDS_KEY 
352c						DMARK "0=." 
352c f5				push af  
352d 3a 41 35			ld a, (.dmark)  
3530 32 77 fb			ld (debug_mark),a  
3533 3a 42 35			ld a, (.dmark+1)  
3536 32 78 fb			ld (debug_mark+1),a  
3539 3a 43 35			ld a, (.dmark+2)  
353c 32 79 fb			ld (debug_mark+2),a  
353f 18 03			jr .pastdmark  
3541 ..			.dmark: db "0=."  
3544 f1			.pastdmark: pop af  
3545			endm  
# End of macro DMARK
3545						CALLMONITOR 
3545 cd 17 16			call break_point_state  
3548				endm  
# End of macro CALLMONITOR
3548					endif 
3548					FORTH_DSP 
3548 cd 61 1d			call macro_forth_dsp 
354b				endm 
# End of macro FORTH_DSP
354b 7e					ld a,(hl)	; get type of value on TOS 
354c fe 02				cp DS_TYPE_INUM  
354e 28 00				jr z, .tz_inum 
3550			 
3550				if FORTH_ENABLE_FLOATMATH 
3550					jr .tz_done 
3550			 
3550				endif 
3550					 
3550			 
3550			.tz_inum: 
3550					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3550 cd 9b 1d			call macro_dsp_valuehl 
3553				endm 
# End of macro FORTH_DSP_VALUEHL
3553			 
3553			;		push hl 
3553			 
3553					; destroy value TOS 
3553			 
3553					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3553 cd 53 1e			call macro_forth_dsp_pop 
3556				endm 
# End of macro FORTH_DSP_POP
3556			 
3556			;		pop hl 
3556			 
3556 3e 00				ld a,0 
3558			 
3558 bd					cp l 
3559 20 08				jr nz, .tz_notzero 
355b			 
355b bc					cp h 
355c			 
355c 20 05				jr nz, .tz_notzero 
355e			 
355e			 
355e 21 01 00				ld hl, FORTH_TRUE 
3561 18 03				jr .tz_done 
3563			 
3563 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3566			 
3566					; push value back onto stack for another op etc 
3566			 
3566			.tz_done: 
3566 cd a4 1b				call forth_push_numhl 
3569			 
3569					NEXTW 
3569 c3 0d 1f			jp macro_next 
356c				endm 
# End of macro NEXTW
356c			.LESS: 
356c				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
356c 2f				db WORD_SYS_CORE+27             
356d d5 35			dw .GT            
356f 02				db 1 + 1 
3570 .. 00			db "<",0              
3572				endm 
# End of macro CWHEAD
3572			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3572				; TODO add floating point number detection 
3572					if DEBUG_FORTH_WORDS_KEY 
3572						DMARK "LES" 
3572 f5				push af  
3573 3a 87 35			ld a, (.dmark)  
3576 32 77 fb			ld (debug_mark),a  
3579 3a 88 35			ld a, (.dmark+1)  
357c 32 78 fb			ld (debug_mark+1),a  
357f 3a 89 35			ld a, (.dmark+2)  
3582 32 79 fb			ld (debug_mark+2),a  
3585 18 03			jr .pastdmark  
3587 ..			.dmark: db "LES"  
358a f1			.pastdmark: pop af  
358b			endm  
# End of macro DMARK
358b						CALLMONITOR 
358b cd 17 16			call break_point_state  
358e				endm  
# End of macro CALLMONITOR
358e					endif 
358e					FORTH_DSP 
358e cd 61 1d			call macro_forth_dsp 
3591				endm 
# End of macro FORTH_DSP
3591					;v5 FORTH_DSP_VALUE 
3591 7e					ld a,(hl)	; get type of value on TOS 
3592 fe 02				cp DS_TYPE_INUM  
3594 28 00				jr z, .less_inum 
3596			 
3596				if FORTH_ENABLE_FLOATMATH 
3596					jr .less_done 
3596			 
3596				endif 
3596					 
3596			 
3596			.less_inum: 
3596					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3596 cd 9b 1d			call macro_dsp_valuehl 
3599				endm 
# End of macro FORTH_DSP_VALUEHL
3599			 
3599 e5					push hl  ; u2 
359a			 
359a					; destroy value TOS 
359a			 
359a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
359a cd 53 1e			call macro_forth_dsp_pop 
359d				endm 
# End of macro FORTH_DSP_POP
359d			 
359d			 
359d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
359d cd 9b 1d			call macro_dsp_valuehl 
35a0				endm 
# End of macro FORTH_DSP_VALUEHL
35a0			 
35a0 e5					push hl    ; u1 
35a1			 
35a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a1 cd 53 1e			call macro_forth_dsp_pop 
35a4				endm 
# End of macro FORTH_DSP_POP
35a4			 
35a4			 
35a4 b7			 or a      ;clear carry flag 
35a5 01 00 00		 ld bc, FORTH_FALSE 
35a8 e1			  pop hl    ; u1 
35a9 d1			  pop de    ; u2 
35aa ed 52		  sbc hl,de 
35ac 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35ae			 
35ae 01 01 00		 ld bc, FORTH_TRUE 
35b1			.lscont:  
35b1 c5					push bc 
35b2 e1					pop hl 
35b3			 
35b3					if DEBUG_FORTH_WORDS 
35b3						DMARK "LT1" 
35b3 f5				push af  
35b4 3a c8 35			ld a, (.dmark)  
35b7 32 77 fb			ld (debug_mark),a  
35ba 3a c9 35			ld a, (.dmark+1)  
35bd 32 78 fb			ld (debug_mark+1),a  
35c0 3a ca 35			ld a, (.dmark+2)  
35c3 32 79 fb			ld (debug_mark+2),a  
35c6 18 03			jr .pastdmark  
35c8 ..			.dmark: db "LT1"  
35cb f1			.pastdmark: pop af  
35cc			endm  
# End of macro DMARK
35cc						CALLMONITOR 
35cc cd 17 16			call break_point_state  
35cf				endm  
# End of macro CALLMONITOR
35cf					endif 
35cf cd a4 1b				call forth_push_numhl 
35d2			 
35d2					NEXTW 
35d2 c3 0d 1f			jp macro_next 
35d5				endm 
# End of macro NEXTW
35d5			.GT: 
35d5				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35d5 30				db WORD_SYS_CORE+28             
35d6 3e 36			dw .EQUAL            
35d8 02				db 1 + 1 
35d9 .. 00			db ">",0              
35db				endm 
# End of macro CWHEAD
35db			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35db				; TODO add floating point number detection 
35db					if DEBUG_FORTH_WORDS_KEY 
35db						DMARK "GRT" 
35db f5				push af  
35dc 3a f0 35			ld a, (.dmark)  
35df 32 77 fb			ld (debug_mark),a  
35e2 3a f1 35			ld a, (.dmark+1)  
35e5 32 78 fb			ld (debug_mark+1),a  
35e8 3a f2 35			ld a, (.dmark+2)  
35eb 32 79 fb			ld (debug_mark+2),a  
35ee 18 03			jr .pastdmark  
35f0 ..			.dmark: db "GRT"  
35f3 f1			.pastdmark: pop af  
35f4			endm  
# End of macro DMARK
35f4						CALLMONITOR 
35f4 cd 17 16			call break_point_state  
35f7				endm  
# End of macro CALLMONITOR
35f7					endif 
35f7					FORTH_DSP 
35f7 cd 61 1d			call macro_forth_dsp 
35fa				endm 
# End of macro FORTH_DSP
35fa					;FORTH_DSP_VALUE 
35fa 7e					ld a,(hl)	; get type of value on TOS 
35fb fe 02				cp DS_TYPE_INUM  
35fd 28 00				jr z, .gt_inum 
35ff			 
35ff				if FORTH_ENABLE_FLOATMATH 
35ff					jr .gt_done 
35ff			 
35ff				endif 
35ff					 
35ff			 
35ff			.gt_inum: 
35ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ff cd 9b 1d			call macro_dsp_valuehl 
3602				endm 
# End of macro FORTH_DSP_VALUEHL
3602			 
3602 e5					push hl  ; u2 
3603			 
3603					; destroy value TOS 
3603			 
3603					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3603 cd 53 1e			call macro_forth_dsp_pop 
3606				endm 
# End of macro FORTH_DSP_POP
3606			 
3606			 
3606					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3606 cd 9b 1d			call macro_dsp_valuehl 
3609				endm 
# End of macro FORTH_DSP_VALUEHL
3609			 
3609 e5					push hl    ; u1 
360a			 
360a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
360a cd 53 1e			call macro_forth_dsp_pop 
360d				endm 
# End of macro FORTH_DSP_POP
360d			 
360d			 
360d b7			 or a      ;clear carry flag 
360e 01 00 00		 ld bc, FORTH_FALSE 
3611 e1			  pop hl    ; u1 
3612 d1			  pop de    ; u2 
3613 ed 52		  sbc hl,de 
3615 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3617			 
3617 01 01 00		 ld bc, FORTH_TRUE 
361a			.gtcont:  
361a c5					push bc 
361b e1					pop hl 
361c			 
361c					if DEBUG_FORTH_WORDS 
361c						DMARK "GT1" 
361c f5				push af  
361d 3a 31 36			ld a, (.dmark)  
3620 32 77 fb			ld (debug_mark),a  
3623 3a 32 36			ld a, (.dmark+1)  
3626 32 78 fb			ld (debug_mark+1),a  
3629 3a 33 36			ld a, (.dmark+2)  
362c 32 79 fb			ld (debug_mark+2),a  
362f 18 03			jr .pastdmark  
3631 ..			.dmark: db "GT1"  
3634 f1			.pastdmark: pop af  
3635			endm  
# End of macro DMARK
3635						CALLMONITOR 
3635 cd 17 16			call break_point_state  
3638				endm  
# End of macro CALLMONITOR
3638					endif 
3638 cd a4 1b				call forth_push_numhl 
363b			 
363b					NEXTW 
363b c3 0d 1f			jp macro_next 
363e				endm 
# End of macro NEXTW
363e			.EQUAL: 
363e				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
363e 31				db WORD_SYS_CORE+29             
363f a9 36			dw .ENDLOGIC            
3641 02				db 1 + 1 
3642 .. 00			db "=",0              
3644				endm 
# End of macro CWHEAD
3644			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3644				; TODO add floating point number detection 
3644					if DEBUG_FORTH_WORDS_KEY 
3644						DMARK "EQ." 
3644 f5				push af  
3645 3a 59 36			ld a, (.dmark)  
3648 32 77 fb			ld (debug_mark),a  
364b 3a 5a 36			ld a, (.dmark+1)  
364e 32 78 fb			ld (debug_mark+1),a  
3651 3a 5b 36			ld a, (.dmark+2)  
3654 32 79 fb			ld (debug_mark+2),a  
3657 18 03			jr .pastdmark  
3659 ..			.dmark: db "EQ."  
365c f1			.pastdmark: pop af  
365d			endm  
# End of macro DMARK
365d						CALLMONITOR 
365d cd 17 16			call break_point_state  
3660				endm  
# End of macro CALLMONITOR
3660					endif 
3660					FORTH_DSP 
3660 cd 61 1d			call macro_forth_dsp 
3663				endm 
# End of macro FORTH_DSP
3663					;v5 FORTH_DSP_VALUE 
3663 7e					ld a,(hl)	; get type of value on TOS 
3664 fe 02				cp DS_TYPE_INUM  
3666 28 00				jr z, .eq_inum 
3668			 
3668				if FORTH_ENABLE_FLOATMATH 
3668					jr .eq_done 
3668			 
3668				endif 
3668					 
3668			 
3668			.eq_inum: 
3668					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3668 cd 9b 1d			call macro_dsp_valuehl 
366b				endm 
# End of macro FORTH_DSP_VALUEHL
366b			 
366b e5					push hl 
366c			 
366c					; destroy value TOS 
366c			 
366c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
366c cd 53 1e			call macro_forth_dsp_pop 
366f				endm 
# End of macro FORTH_DSP_POP
366f			 
366f			 
366f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
366f cd 9b 1d			call macro_dsp_valuehl 
3672				endm 
# End of macro FORTH_DSP_VALUEHL
3672			 
3672					; one value on hl get other one back 
3672			 
3672 e5					push hl 
3673			 
3673					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3673 cd 53 1e			call macro_forth_dsp_pop 
3676				endm 
# End of macro FORTH_DSP_POP
3676			 
3676 0e 00				ld c, FORTH_FALSE 
3678			 
3678 e1					pop hl 
3679 d1					pop de 
367a			 
367a 7b					ld a, e 
367b bd					cp l 
367c			 
367c 20 06				jr nz, .eq_done 
367e			 
367e 7a					ld a, d 
367f bc					cp h 
3680			 
3680 20 02				jr nz, .eq_done 
3682			 
3682 0e 01				ld c, FORTH_TRUE 
3684					 
3684			 
3684			 
3684			.eq_done: 
3684			 
3684					; TODO push value back onto stack for another op etc 
3684			 
3684 26 00				ld h, 0 
3686 69					ld l, c 
3687					if DEBUG_FORTH_WORDS 
3687						DMARK "EQ1" 
3687 f5				push af  
3688 3a 9c 36			ld a, (.dmark)  
368b 32 77 fb			ld (debug_mark),a  
368e 3a 9d 36			ld a, (.dmark+1)  
3691 32 78 fb			ld (debug_mark+1),a  
3694 3a 9e 36			ld a, (.dmark+2)  
3697 32 79 fb			ld (debug_mark+2),a  
369a 18 03			jr .pastdmark  
369c ..			.dmark: db "EQ1"  
369f f1			.pastdmark: pop af  
36a0			endm  
# End of macro DMARK
36a0						CALLMONITOR 
36a0 cd 17 16			call break_point_state  
36a3				endm  
# End of macro CALLMONITOR
36a3					endif 
36a3 cd a4 1b				call forth_push_numhl 
36a6			 
36a6					NEXTW 
36a6 c3 0d 1f			jp macro_next 
36a9				endm 
# End of macro NEXTW
36a9			 
36a9			 
36a9			.ENDLOGIC: 
36a9			; eof 
36a9			 
36a9			 
# End of file forth_words_logic.asm
36a9			include "forth_words_maths.asm" 
36a9			 
36a9			; | ## Maths Words 
36a9			 
36a9			.PLUS:	 
36a9				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36a9 15				db WORD_SYS_CORE+1             
36aa eb 36			dw .NEG            
36ac 02				db 1 + 1 
36ad .. 00			db "+",0              
36af				endm 
# End of macro CWHEAD
36af			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36af					if DEBUG_FORTH_WORDS_KEY 
36af						DMARK "PLU" 
36af f5				push af  
36b0 3a c4 36			ld a, (.dmark)  
36b3 32 77 fb			ld (debug_mark),a  
36b6 3a c5 36			ld a, (.dmark+1)  
36b9 32 78 fb			ld (debug_mark+1),a  
36bc 3a c6 36			ld a, (.dmark+2)  
36bf 32 79 fb			ld (debug_mark+2),a  
36c2 18 03			jr .pastdmark  
36c4 ..			.dmark: db "PLU"  
36c7 f1			.pastdmark: pop af  
36c8			endm  
# End of macro DMARK
36c8						CALLMONITOR 
36c8 cd 17 16			call break_point_state  
36cb				endm  
# End of macro CALLMONITOR
36cb					endif 
36cb					; add top two values and push back result 
36cb			 
36cb					;for v5 FORTH_DSP_VALUE 
36cb					FORTH_DSP 
36cb cd 61 1d			call macro_forth_dsp 
36ce				endm 
# End of macro FORTH_DSP
36ce 7e					ld a,(hl)	; get type of value on TOS 
36cf fe 02				cp DS_TYPE_INUM  
36d1 28 03				jr z, .dot_inum 
36d3			 
36d3					NEXTW 
36d3 c3 0d 1f			jp macro_next 
36d6				endm 
# End of macro NEXTW
36d6			 
36d6			; float maths 
36d6			 
36d6				if FORTH_ENABLE_FLOATMATH 
36d6						inc hl      ; now at start of numeric as string 
36d6			 
36d6					if DEBUG_FORTH_MATHS 
36d6						DMARK "ADD" 
36d6				CALLMONITOR 
36d6					endif 
36d6			 
36d6					;ld ix, hl 
36d6					call CON 
36d6			 
36d6			 
36d6					push hl 
36d6					 
36d6					 
36d6			 
36d6						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36d6			 
36d6					; get next number 
36d6			 
36d6						FORTH_DSP_VALUE 
36d6			 
36d6						inc hl      ; now at start of numeric as string 
36d6			 
36d6					;ld ix, hl 
36d6					call CON 
36d6			 
36d6					push hl 
36d6			 
36d6			 
36d6						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36d6			 
36d6						; TODO do add 
36d6			 
36d6						call IADD 
36d6			 
36d6						; TODO get result back as ascii 
36d6			 
36d6						; TODO push result  
36d6			 
36d6			 
36d6			 
36d6						jr .dot_done 
36d6				endif 
36d6			 
36d6			.dot_inum: 
36d6			 
36d6			 
36d6					if DEBUG_FORTH_DOT 
36d6						DMARK "+IT" 
36d6				CALLMONITOR 
36d6					endif 
36d6			 
36d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36d6 cd 9b 1d			call macro_dsp_valuehl 
36d9				endm 
# End of macro FORTH_DSP_VALUEHL
36d9			 
36d9				; TODO add floating point number detection 
36d9			 
36d9 e5					push hl 
36da			 
36da					; destroy value TOS 
36da			 
36da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36da cd 53 1e			call macro_forth_dsp_pop 
36dd				endm 
# End of macro FORTH_DSP_POP
36dd			 
36dd			 
36dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36dd cd 9b 1d			call macro_dsp_valuehl 
36e0				endm 
# End of macro FORTH_DSP_VALUEHL
36e0			 
36e0					; one value on hl get other one back 
36e0			 
36e0 d1					pop de 
36e1			 
36e1					; do the add 
36e1			 
36e1 19					add hl,de 
36e2			 
36e2					; save it 
36e2			 
36e2			;		push hl	 
36e2			 
36e2					; 
36e2			 
36e2					; destroy value TOS 
36e2			 
36e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e2 cd 53 1e			call macro_forth_dsp_pop 
36e5				endm 
# End of macro FORTH_DSP_POP
36e5			 
36e5					; TODO push value back onto stack for another op etc 
36e5			 
36e5			;		pop hl 
36e5			 
36e5			.dot_done: 
36e5 cd a4 1b				call forth_push_numhl 
36e8			 
36e8					NEXTW 
36e8 c3 0d 1f			jp macro_next 
36eb				endm 
# End of macro NEXTW
36eb			.NEG: 
36eb			 
36eb				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
36eb 17				db WORD_SYS_CORE+3             
36ec 2e 37			dw .DIV            
36ee 02				db 1 + 1 
36ef .. 00			db "-",0              
36f1				endm 
# End of macro CWHEAD
36f1			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
36f1					if DEBUG_FORTH_WORDS_KEY 
36f1						DMARK "SUB" 
36f1 f5				push af  
36f2 3a 06 37			ld a, (.dmark)  
36f5 32 77 fb			ld (debug_mark),a  
36f8 3a 07 37			ld a, (.dmark+1)  
36fb 32 78 fb			ld (debug_mark+1),a  
36fe 3a 08 37			ld a, (.dmark+2)  
3701 32 79 fb			ld (debug_mark+2),a  
3704 18 03			jr .pastdmark  
3706 ..			.dmark: db "SUB"  
3709 f1			.pastdmark: pop af  
370a			endm  
# End of macro DMARK
370a						CALLMONITOR 
370a cd 17 16			call break_point_state  
370d				endm  
# End of macro CALLMONITOR
370d					endif 
370d			 
370d			 
370d				; TODO add floating point number detection 
370d					; v5 FORTH_DSP_VALUE 
370d					FORTH_DSP 
370d cd 61 1d			call macro_forth_dsp 
3710				endm 
# End of macro FORTH_DSP
3710 7e					ld a,(hl)	; get type of value on TOS 
3711 fe 02				cp DS_TYPE_INUM  
3713 28 03				jr z, .neg_inum 
3715			 
3715					NEXTW 
3715 c3 0d 1f			jp macro_next 
3718				endm 
# End of macro NEXTW
3718			 
3718			; float maths 
3718			 
3718				if FORTH_ENABLE_FLOATMATH 
3718					jr .neg_done 
3718			 
3718				endif 
3718					 
3718			 
3718			.neg_inum: 
3718					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3718 cd 9b 1d			call macro_dsp_valuehl 
371b				endm 
# End of macro FORTH_DSP_VALUEHL
371b			 
371b e5					push hl 
371c			 
371c					; destroy value TOS 
371c			 
371c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
371c cd 53 1e			call macro_forth_dsp_pop 
371f				endm 
# End of macro FORTH_DSP_POP
371f			 
371f			 
371f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
371f cd 9b 1d			call macro_dsp_valuehl 
3722				endm 
# End of macro FORTH_DSP_VALUEHL
3722			 
3722					; one value on hl get other one back 
3722			 
3722 d1					pop de 
3723			 
3723					; do the sub 
3723			;		ex de, hl 
3723			 
3723 ed 52				sbc hl,de 
3725			 
3725					; save it 
3725			 
3725			;		push hl	 
3725			 
3725					; 
3725			 
3725					; destroy value TOS 
3725			 
3725					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3725 cd 53 1e			call macro_forth_dsp_pop 
3728				endm 
# End of macro FORTH_DSP_POP
3728			 
3728					; TODO push value back onto stack for another op etc 
3728			 
3728			;		pop hl 
3728			 
3728 cd a4 1b				call forth_push_numhl 
372b			.neg_done: 
372b			 
372b					NEXTW 
372b c3 0d 1f			jp macro_next 
372e				endm 
# End of macro NEXTW
372e			.DIV: 
372e				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
372e 18				db WORD_SYS_CORE+4             
372f 7b 37			dw .MUL            
3731 02				db 1 + 1 
3732 .. 00			db "/",0              
3734				endm 
# End of macro CWHEAD
3734			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3734					if DEBUG_FORTH_WORDS_KEY 
3734						DMARK "DIV" 
3734 f5				push af  
3735 3a 49 37			ld a, (.dmark)  
3738 32 77 fb			ld (debug_mark),a  
373b 3a 4a 37			ld a, (.dmark+1)  
373e 32 78 fb			ld (debug_mark+1),a  
3741 3a 4b 37			ld a, (.dmark+2)  
3744 32 79 fb			ld (debug_mark+2),a  
3747 18 03			jr .pastdmark  
3749 ..			.dmark: db "DIV"  
374c f1			.pastdmark: pop af  
374d			endm  
# End of macro DMARK
374d						CALLMONITOR 
374d cd 17 16			call break_point_state  
3750				endm  
# End of macro CALLMONITOR
3750					endif 
3750				; TODO add floating point number detection 
3750					; v5 FORTH_DSP_VALUE 
3750					FORTH_DSP 
3750 cd 61 1d			call macro_forth_dsp 
3753				endm 
# End of macro FORTH_DSP
3753 7e					ld a,(hl)	; get type of value on TOS 
3754 fe 02				cp DS_TYPE_INUM  
3756 28 03				jr z, .div_inum 
3758			 
3758				if FORTH_ENABLE_FLOATMATH 
3758					jr .div_done 
3758			 
3758				endif 
3758					NEXTW 
3758 c3 0d 1f			jp macro_next 
375b				endm 
# End of macro NEXTW
375b			.div_inum: 
375b			 
375b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
375b cd 9b 1d			call macro_dsp_valuehl 
375e				endm 
# End of macro FORTH_DSP_VALUEHL
375e			 
375e e5					push hl    ; to go to bc 
375f			 
375f					; destroy value TOS 
375f			 
375f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
375f cd 53 1e			call macro_forth_dsp_pop 
3762				endm 
# End of macro FORTH_DSP_POP
3762			 
3762			 
3762					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3762 cd 9b 1d			call macro_dsp_valuehl 
3765				endm 
# End of macro FORTH_DSP_VALUEHL
3765			 
3765					; hl to go to de 
3765			 
3765 e5					push hl 
3766			 
3766 c1					pop bc 
3767 d1					pop de		 
3768			 
3768			 
3768					if DEBUG_FORTH_MATHS 
3768						DMARK "DIV" 
3768				CALLMONITOR 
3768					endif 
3768					; one value on hl but move to a get other one back 
3768			 
3768			        
3768 cd 28 0c			call Div16 
376b			 
376b			;	push af	 
376b e5				push hl 
376c c5				push bc 
376d			 
376d					if DEBUG_FORTH_MATHS 
376d						DMARK "DI1" 
376d				CALLMONITOR 
376d					endif 
376d			 
376d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376d cd 53 1e			call macro_forth_dsp_pop 
3770				endm 
# End of macro FORTH_DSP_POP
3770			 
3770			 
3770			 
3770 e1					pop hl    ; result 
3771			 
3771 cd a4 1b				call forth_push_numhl 
3774			 
3774 e1					pop hl    ; reminder 
3775			;		ld h,0 
3775			;		ld l,d 
3775			 
3775 cd a4 1b				call forth_push_numhl 
3778			.div_done: 
3778					NEXTW 
3778 c3 0d 1f			jp macro_next 
377b				endm 
# End of macro NEXTW
377b			.MUL: 
377b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
377b 19				db WORD_SYS_CORE+5             
377c c0 37			dw .MIN            
377e 02				db 1 + 1 
377f .. 00			db "*",0              
3781				endm 
# End of macro CWHEAD
3781			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3781				; TODO add floating point number detection 
3781					if DEBUG_FORTH_WORDS_KEY 
3781						DMARK "MUL" 
3781 f5				push af  
3782 3a 96 37			ld a, (.dmark)  
3785 32 77 fb			ld (debug_mark),a  
3788 3a 97 37			ld a, (.dmark+1)  
378b 32 78 fb			ld (debug_mark+1),a  
378e 3a 98 37			ld a, (.dmark+2)  
3791 32 79 fb			ld (debug_mark+2),a  
3794 18 03			jr .pastdmark  
3796 ..			.dmark: db "MUL"  
3799 f1			.pastdmark: pop af  
379a			endm  
# End of macro DMARK
379a						CALLMONITOR 
379a cd 17 16			call break_point_state  
379d				endm  
# End of macro CALLMONITOR
379d					endif 
379d					FORTH_DSP 
379d cd 61 1d			call macro_forth_dsp 
37a0				endm 
# End of macro FORTH_DSP
37a0					; v5 FORTH_DSP_VALUE 
37a0 7e					ld a,(hl)	; get type of value on TOS 
37a1 fe 02				cp DS_TYPE_INUM  
37a3 28 03				jr z, .mul_inum 
37a5			 
37a5				if FORTH_ENABLE_FLOATMATH 
37a5					jr .mul_done 
37a5			 
37a5				endif 
37a5			 
37a5					NEXTW 
37a5 c3 0d 1f			jp macro_next 
37a8				endm 
# End of macro NEXTW
37a8			.mul_inum:	 
37a8			 
37a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a8 cd 9b 1d			call macro_dsp_valuehl 
37ab				endm 
# End of macro FORTH_DSP_VALUEHL
37ab			 
37ab e5					push hl 
37ac			 
37ac					; destroy value TOS 
37ac			 
37ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ac cd 53 1e			call macro_forth_dsp_pop 
37af				endm 
# End of macro FORTH_DSP_POP
37af			 
37af			 
37af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37af cd 9b 1d			call macro_dsp_valuehl 
37b2				endm 
# End of macro FORTH_DSP_VALUEHL
37b2			 
37b2					; one value on hl but move to a get other one back 
37b2			 
37b2 7d					ld a, l 
37b3			 
37b3 d1					pop de 
37b4			 
37b4					; do the mull 
37b4			;		ex de, hl 
37b4			 
37b4 cd 4e 0c				call Mult16 
37b7					; save it 
37b7			 
37b7			;		push hl	 
37b7			 
37b7					; 
37b7			 
37b7					; destroy value TOS 
37b7			 
37b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b7 cd 53 1e			call macro_forth_dsp_pop 
37ba				endm 
# End of macro FORTH_DSP_POP
37ba			 
37ba					; TODO push value back onto stack for another op etc 
37ba			 
37ba			;		pop hl 
37ba			 
37ba cd a4 1b				call forth_push_numhl 
37bd			 
37bd			.mul_done: 
37bd					NEXTW 
37bd c3 0d 1f			jp macro_next 
37c0				endm 
# End of macro NEXTW
37c0			 
37c0			 
37c0			 
37c0			 
37c0			.MIN: 
37c0				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37c0 49				db WORD_SYS_CORE+53             
37c1 41 38			dw .MAX            
37c3 04				db 3 + 1 
37c4 .. 00			db "MIN",0              
37c8				endm 
# End of macro CWHEAD
37c8			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37c8					if DEBUG_FORTH_WORDS_KEY 
37c8						DMARK "MIN" 
37c8 f5				push af  
37c9 3a dd 37			ld a, (.dmark)  
37cc 32 77 fb			ld (debug_mark),a  
37cf 3a de 37			ld a, (.dmark+1)  
37d2 32 78 fb			ld (debug_mark+1),a  
37d5 3a df 37			ld a, (.dmark+2)  
37d8 32 79 fb			ld (debug_mark+2),a  
37db 18 03			jr .pastdmark  
37dd ..			.dmark: db "MIN"  
37e0 f1			.pastdmark: pop af  
37e1			endm  
# End of macro DMARK
37e1						CALLMONITOR 
37e1 cd 17 16			call break_point_state  
37e4				endm  
# End of macro CALLMONITOR
37e4					endif 
37e4					; get u2 
37e4			 
37e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e4 cd 9b 1d			call macro_dsp_valuehl 
37e7				endm 
# End of macro FORTH_DSP_VALUEHL
37e7			 
37e7 e5					push hl   ; u2 
37e8			 
37e8					; destroy value TOS 
37e8			 
37e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e8 cd 53 1e			call macro_forth_dsp_pop 
37eb				endm 
# End of macro FORTH_DSP_POP
37eb			 
37eb					; get u1 
37eb			 
37eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37eb cd 9b 1d			call macro_dsp_valuehl 
37ee				endm 
# End of macro FORTH_DSP_VALUEHL
37ee			 
37ee e5					push hl  ; u1 
37ef			 
37ef					; destroy value TOS 
37ef			 
37ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ef cd 53 1e			call macro_forth_dsp_pop 
37f2				endm 
# End of macro FORTH_DSP_POP
37f2			 
37f2 b7			 or a      ;clear carry flag 
37f3 e1			  pop hl    ; u1 
37f4 d1			  pop de    ; u2 
37f5 e5				push hl   ; saved in case hl is lowest 
37f6 ed 52		  sbc hl,de 
37f8 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
37fa			 
37fa e1				pop hl 
37fb					if DEBUG_FORTH_WORDS 
37fb						DMARK "MIN" 
37fb f5				push af  
37fc 3a 10 38			ld a, (.dmark)  
37ff 32 77 fb			ld (debug_mark),a  
3802 3a 11 38			ld a, (.dmark+1)  
3805 32 78 fb			ld (debug_mark+1),a  
3808 3a 12 38			ld a, (.dmark+2)  
380b 32 79 fb			ld (debug_mark+2),a  
380e 18 03			jr .pastdmark  
3810 ..			.dmark: db "MIN"  
3813 f1			.pastdmark: pop af  
3814			endm  
# End of macro DMARK
3814						CALLMONITOR 
3814 cd 17 16			call break_point_state  
3817				endm  
# End of macro CALLMONITOR
3817					endif 
3817 cd a4 1b				call forth_push_numhl 
381a			 
381a				       NEXTW 
381a c3 0d 1f			jp macro_next 
381d				endm 
# End of macro NEXTW
381d			 
381d			.mincont:  
381d c1				pop bc   ; tidy up 
381e eb				ex de , hl  
381f					if DEBUG_FORTH_WORDS 
381f						DMARK "MI1" 
381f f5				push af  
3820 3a 34 38			ld a, (.dmark)  
3823 32 77 fb			ld (debug_mark),a  
3826 3a 35 38			ld a, (.dmark+1)  
3829 32 78 fb			ld (debug_mark+1),a  
382c 3a 36 38			ld a, (.dmark+2)  
382f 32 79 fb			ld (debug_mark+2),a  
3832 18 03			jr .pastdmark  
3834 ..			.dmark: db "MI1"  
3837 f1			.pastdmark: pop af  
3838			endm  
# End of macro DMARK
3838						CALLMONITOR 
3838 cd 17 16			call break_point_state  
383b				endm  
# End of macro CALLMONITOR
383b					endif 
383b cd a4 1b				call forth_push_numhl 
383e			 
383e				       NEXTW 
383e c3 0d 1f			jp macro_next 
3841				endm 
# End of macro NEXTW
3841			.MAX: 
3841				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3841 4a				db WORD_SYS_CORE+54             
3842 c2 38			dw .RND16            
3844 04				db 3 + 1 
3845 .. 00			db "MAX",0              
3849				endm 
# End of macro CWHEAD
3849			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3849					if DEBUG_FORTH_WORDS_KEY 
3849						DMARK "MAX" 
3849 f5				push af  
384a 3a 5e 38			ld a, (.dmark)  
384d 32 77 fb			ld (debug_mark),a  
3850 3a 5f 38			ld a, (.dmark+1)  
3853 32 78 fb			ld (debug_mark+1),a  
3856 3a 60 38			ld a, (.dmark+2)  
3859 32 79 fb			ld (debug_mark+2),a  
385c 18 03			jr .pastdmark  
385e ..			.dmark: db "MAX"  
3861 f1			.pastdmark: pop af  
3862			endm  
# End of macro DMARK
3862						CALLMONITOR 
3862 cd 17 16			call break_point_state  
3865				endm  
# End of macro CALLMONITOR
3865					endif 
3865					; get u2 
3865			 
3865					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3865 cd 9b 1d			call macro_dsp_valuehl 
3868				endm 
# End of macro FORTH_DSP_VALUEHL
3868			 
3868 e5					push hl   ; u2 
3869			 
3869					; destroy value TOS 
3869			 
3869					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3869 cd 53 1e			call macro_forth_dsp_pop 
386c				endm 
# End of macro FORTH_DSP_POP
386c			 
386c					; get u1 
386c			 
386c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
386c cd 9b 1d			call macro_dsp_valuehl 
386f				endm 
# End of macro FORTH_DSP_VALUEHL
386f			 
386f e5					push hl  ; u1 
3870			 
3870					; destroy value TOS 
3870			 
3870					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3870 cd 53 1e			call macro_forth_dsp_pop 
3873				endm 
# End of macro FORTH_DSP_POP
3873			 
3873 b7			 or a      ;clear carry flag 
3874 e1			  pop hl    ; u1 
3875 d1			  pop de    ; u2 
3876 e5				push hl   ; saved in case hl is lowest 
3877 ed 52		  sbc hl,de 
3879 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
387b			 
387b e1				pop hl 
387c					if DEBUG_FORTH_WORDS 
387c						DMARK "MAX" 
387c f5				push af  
387d 3a 91 38			ld a, (.dmark)  
3880 32 77 fb			ld (debug_mark),a  
3883 3a 92 38			ld a, (.dmark+1)  
3886 32 78 fb			ld (debug_mark+1),a  
3889 3a 93 38			ld a, (.dmark+2)  
388c 32 79 fb			ld (debug_mark+2),a  
388f 18 03			jr .pastdmark  
3891 ..			.dmark: db "MAX"  
3894 f1			.pastdmark: pop af  
3895			endm  
# End of macro DMARK
3895						CALLMONITOR 
3895 cd 17 16			call break_point_state  
3898				endm  
# End of macro CALLMONITOR
3898					endif 
3898 cd a4 1b				call forth_push_numhl 
389b			 
389b				       NEXTW 
389b c3 0d 1f			jp macro_next 
389e				endm 
# End of macro NEXTW
389e			 
389e			.maxcont:  
389e c1				pop bc   ; tidy up 
389f eb				ex de , hl  
38a0					if DEBUG_FORTH_WORDS 
38a0						DMARK "MA1" 
38a0 f5				push af  
38a1 3a b5 38			ld a, (.dmark)  
38a4 32 77 fb			ld (debug_mark),a  
38a7 3a b6 38			ld a, (.dmark+1)  
38aa 32 78 fb			ld (debug_mark+1),a  
38ad 3a b7 38			ld a, (.dmark+2)  
38b0 32 79 fb			ld (debug_mark+2),a  
38b3 18 03			jr .pastdmark  
38b5 ..			.dmark: db "MA1"  
38b8 f1			.pastdmark: pop af  
38b9			endm  
# End of macro DMARK
38b9						CALLMONITOR 
38b9 cd 17 16			call break_point_state  
38bc				endm  
# End of macro CALLMONITOR
38bc					endif 
38bc cd a4 1b				call forth_push_numhl 
38bf				       NEXTW 
38bf c3 0d 1f			jp macro_next 
38c2				endm 
# End of macro NEXTW
38c2			 
38c2			.RND16: 
38c2				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38c2 4e				db WORD_SYS_CORE+58             
38c3 f1 38			dw .RND8            
38c5 06				db 5 + 1 
38c6 .. 00			db "RND16",0              
38cc				endm 
# End of macro CWHEAD
38cc			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38cc					if DEBUG_FORTH_WORDS_KEY 
38cc						DMARK "R16" 
38cc f5				push af  
38cd 3a e1 38			ld a, (.dmark)  
38d0 32 77 fb			ld (debug_mark),a  
38d3 3a e2 38			ld a, (.dmark+1)  
38d6 32 78 fb			ld (debug_mark+1),a  
38d9 3a e3 38			ld a, (.dmark+2)  
38dc 32 79 fb			ld (debug_mark+2),a  
38df 18 03			jr .pastdmark  
38e1 ..			.dmark: db "R16"  
38e4 f1			.pastdmark: pop af  
38e5			endm  
# End of macro DMARK
38e5						CALLMONITOR 
38e5 cd 17 16			call break_point_state  
38e8				endm  
# End of macro CALLMONITOR
38e8					endif 
38e8 cd f2 0b				call prng16  
38eb cd a4 1b				call forth_push_numhl 
38ee				       NEXTW 
38ee c3 0d 1f			jp macro_next 
38f1				endm 
# End of macro NEXTW
38f1			.RND8: 
38f1				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
38f1 60				db WORD_SYS_CORE+76             
38f2 26 39			dw .RND            
38f4 05				db 4 + 1 
38f5 .. 00			db "RND8",0              
38fa				endm 
# End of macro CWHEAD
38fa			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
38fa					if DEBUG_FORTH_WORDS_KEY 
38fa						DMARK "RN8" 
38fa f5				push af  
38fb 3a 0f 39			ld a, (.dmark)  
38fe 32 77 fb			ld (debug_mark),a  
3901 3a 10 39			ld a, (.dmark+1)  
3904 32 78 fb			ld (debug_mark+1),a  
3907 3a 11 39			ld a, (.dmark+2)  
390a 32 79 fb			ld (debug_mark+2),a  
390d 18 03			jr .pastdmark  
390f ..			.dmark: db "RN8"  
3912 f1			.pastdmark: pop af  
3913			endm  
# End of macro DMARK
3913						CALLMONITOR 
3913 cd 17 16			call break_point_state  
3916				endm  
# End of macro CALLMONITOR
3916					endif 
3916 2a b8 f8				ld hl,(xrandc) 
3919 23					inc hl 
391a cd 0c 0c				call xrnd 
391d 6f					ld l,a	 
391e 26 00				ld h,0 
3920 cd a4 1b				call forth_push_numhl 
3923				       NEXTW 
3923 c3 0d 1f			jp macro_next 
3926				endm 
# End of macro NEXTW
3926			.RND: 
3926				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3926 60				db WORD_SYS_CORE+76             
3927 2c 3a			dw .ENDMATHS            
3929 04				db 3 + 1 
392a .. 00			db "RND",0              
392e				endm 
# End of macro CWHEAD
392e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
392e			 
392e					if DEBUG_FORTH_WORDS_KEY 
392e						DMARK "RND" 
392e f5				push af  
392f 3a 43 39			ld a, (.dmark)  
3932 32 77 fb			ld (debug_mark),a  
3935 3a 44 39			ld a, (.dmark+1)  
3938 32 78 fb			ld (debug_mark+1),a  
393b 3a 45 39			ld a, (.dmark+2)  
393e 32 79 fb			ld (debug_mark+2),a  
3941 18 03			jr .pastdmark  
3943 ..			.dmark: db "RND"  
3946 f1			.pastdmark: pop af  
3947			endm  
# End of macro DMARK
3947						CALLMONITOR 
3947 cd 17 16			call break_point_state  
394a				endm  
# End of macro CALLMONITOR
394a					endif 
394a					 
394a					FORTH_DSP_VALUEHL    ; upper range 
394a cd 9b 1d			call macro_dsp_valuehl 
394d				endm 
# End of macro FORTH_DSP_VALUEHL
394d			 
394d 22 bc f8				ld (LFSRSeed), hl	 
3950			 
3950					if DEBUG_FORTH_WORDS 
3950						DMARK "RN1" 
3950 f5				push af  
3951 3a 65 39			ld a, (.dmark)  
3954 32 77 fb			ld (debug_mark),a  
3957 3a 66 39			ld a, (.dmark+1)  
395a 32 78 fb			ld (debug_mark+1),a  
395d 3a 67 39			ld a, (.dmark+2)  
3960 32 79 fb			ld (debug_mark+2),a  
3963 18 03			jr .pastdmark  
3965 ..			.dmark: db "RN1"  
3968 f1			.pastdmark: pop af  
3969			endm  
# End of macro DMARK
3969						CALLMONITOR 
3969 cd 17 16			call break_point_state  
396c				endm  
# End of macro CALLMONITOR
396c					endif 
396c					FORTH_DSP_POP 
396c cd 53 1e			call macro_forth_dsp_pop 
396f				endm 
# End of macro FORTH_DSP_POP
396f			 
396f					FORTH_DSP_VALUEHL    ; low range 
396f cd 9b 1d			call macro_dsp_valuehl 
3972				endm 
# End of macro FORTH_DSP_VALUEHL
3972			 
3972					if DEBUG_FORTH_WORDS 
3972						DMARK "RN2" 
3972 f5				push af  
3973 3a 87 39			ld a, (.dmark)  
3976 32 77 fb			ld (debug_mark),a  
3979 3a 88 39			ld a, (.dmark+1)  
397c 32 78 fb			ld (debug_mark+1),a  
397f 3a 89 39			ld a, (.dmark+2)  
3982 32 79 fb			ld (debug_mark+2),a  
3985 18 03			jr .pastdmark  
3987 ..			.dmark: db "RN2"  
398a f1			.pastdmark: pop af  
398b			endm  
# End of macro DMARK
398b						CALLMONITOR 
398b cd 17 16			call break_point_state  
398e				endm  
# End of macro CALLMONITOR
398e					endif 
398e 22 be f8				ld (LFSRSeed+2), hl 
3991			 
3991					FORTH_DSP_POP 
3991 cd 53 1e			call macro_forth_dsp_pop 
3994				endm 
# End of macro FORTH_DSP_POP
3994			 
3994 e5					push hl 
3995			 
3995 e1			.inrange:	pop hl 
3996 cd f2 0b				call prng16  
3999					if DEBUG_FORTH_WORDS 
3999						DMARK "RN3" 
3999 f5				push af  
399a 3a ae 39			ld a, (.dmark)  
399d 32 77 fb			ld (debug_mark),a  
39a0 3a af 39			ld a, (.dmark+1)  
39a3 32 78 fb			ld (debug_mark+1),a  
39a6 3a b0 39			ld a, (.dmark+2)  
39a9 32 79 fb			ld (debug_mark+2),a  
39ac 18 03			jr .pastdmark  
39ae ..			.dmark: db "RN3"  
39b1 f1			.pastdmark: pop af  
39b2			endm  
# End of macro DMARK
39b2						CALLMONITOR 
39b2 cd 17 16			call break_point_state  
39b5				endm  
# End of macro CALLMONITOR
39b5					endif 
39b5					 
39b5					; if the range is 8bit knock out the high byte 
39b5			 
39b5 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
39b9			 
39b9 3e 00				ld a, 0 
39bb ba					cp d  
39bc 20 1e				jr nz, .hirange 
39be 26 00				ld h, 0   ; knock it down to 8bit 
39c0			 
39c0					if DEBUG_FORTH_WORDS 
39c0						DMARK "RNk" 
39c0 f5				push af  
39c1 3a d5 39			ld a, (.dmark)  
39c4 32 77 fb			ld (debug_mark),a  
39c7 3a d6 39			ld a, (.dmark+1)  
39ca 32 78 fb			ld (debug_mark+1),a  
39cd 3a d7 39			ld a, (.dmark+2)  
39d0 32 79 fb			ld (debug_mark+2),a  
39d3 18 03			jr .pastdmark  
39d5 ..			.dmark: db "RNk"  
39d8 f1			.pastdmark: pop af  
39d9			endm  
# End of macro DMARK
39d9						CALLMONITOR 
39d9 cd 17 16			call break_point_state  
39dc				endm  
# End of macro CALLMONITOR
39dc					endif 
39dc			.hirange:   
39dc e5					push hl  
39dd b7					or a  
39de ed 52		                sbc hl, de 
39e0			 
39e0					;call cmp16 
39e0			 
39e0 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
39e2 e1					pop hl 
39e3 e5					push hl 
39e4			 
39e4					if DEBUG_FORTH_WORDS 
39e4						DMARK "RN4" 
39e4 f5				push af  
39e5 3a f9 39			ld a, (.dmark)  
39e8 32 77 fb			ld (debug_mark),a  
39eb 3a fa 39			ld a, (.dmark+1)  
39ee 32 78 fb			ld (debug_mark+1),a  
39f1 3a fb 39			ld a, (.dmark+2)  
39f4 32 79 fb			ld (debug_mark+2),a  
39f7 18 03			jr .pastdmark  
39f9 ..			.dmark: db "RN4"  
39fc f1			.pastdmark: pop af  
39fd			endm  
# End of macro DMARK
39fd						CALLMONITOR 
39fd cd 17 16			call break_point_state  
3a00				endm  
# End of macro CALLMONITOR
3a00					endif 
3a00 ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
3a04					;call cmp16 
3a04				 
3a04 b7					or a  
3a05 ed 52		                sbc hl, de 
3a07 38 8c				jr c, .inrange 
3a09			 
3a09 e1					pop hl 
3a0a					 
3a0a					if DEBUG_FORTH_WORDS 
3a0a						DMARK "RNd" 
3a0a f5				push af  
3a0b 3a 1f 3a			ld a, (.dmark)  
3a0e 32 77 fb			ld (debug_mark),a  
3a11 3a 20 3a			ld a, (.dmark+1)  
3a14 32 78 fb			ld (debug_mark+1),a  
3a17 3a 21 3a			ld a, (.dmark+2)  
3a1a 32 79 fb			ld (debug_mark+2),a  
3a1d 18 03			jr .pastdmark  
3a1f ..			.dmark: db "RNd"  
3a22 f1			.pastdmark: pop af  
3a23			endm  
# End of macro DMARK
3a23						CALLMONITOR 
3a23 cd 17 16			call break_point_state  
3a26				endm  
# End of macro CALLMONITOR
3a26					endif 
3a26			 
3a26			 
3a26 cd a4 1b				call forth_push_numhl 
3a29				       NEXTW 
3a29 c3 0d 1f			jp macro_next 
3a2c				endm 
# End of macro NEXTW
3a2c			 
3a2c			.ENDMATHS: 
3a2c			 
3a2c			; eof 
3a2c			 
# End of file forth_words_maths.asm
3a2c			include "forth_words_display.asm" 
3a2c			 
3a2c			; | ## Display Words 
3a2c			 
3a2c			.ATP: 
3a2c				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a2c 62				db WORD_SYS_CORE+78             
3a2d a3 3a			dw .FB            
3a2f 04				db 3 + 1 
3a30 .. 00			db "AT?",0              
3a34				endm 
# End of macro CWHEAD
3a34			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a34					if DEBUG_FORTH_WORDS_KEY 
3a34						DMARK "AT?" 
3a34 f5				push af  
3a35 3a 49 3a			ld a, (.dmark)  
3a38 32 77 fb			ld (debug_mark),a  
3a3b 3a 4a 3a			ld a, (.dmark+1)  
3a3e 32 78 fb			ld (debug_mark+1),a  
3a41 3a 4b 3a			ld a, (.dmark+2)  
3a44 32 79 fb			ld (debug_mark+2),a  
3a47 18 03			jr .pastdmark  
3a49 ..			.dmark: db "AT?"  
3a4c f1			.pastdmark: pop af  
3a4d			endm  
# End of macro DMARK
3a4d						CALLMONITOR 
3a4d cd 17 16			call break_point_state  
3a50				endm  
# End of macro CALLMONITOR
3a50					endif 
3a50 3a 5a f8				ld a, (f_cursor_ptr) 
3a53			 
3a53			if DEBUG_FORTH_WORDS 
3a53				DMARK "AT?" 
3a53 f5				push af  
3a54 3a 68 3a			ld a, (.dmark)  
3a57 32 77 fb			ld (debug_mark),a  
3a5a 3a 69 3a			ld a, (.dmark+1)  
3a5d 32 78 fb			ld (debug_mark+1),a  
3a60 3a 6a 3a			ld a, (.dmark+2)  
3a63 32 79 fb			ld (debug_mark+2),a  
3a66 18 03			jr .pastdmark  
3a68 ..			.dmark: db "AT?"  
3a6b f1			.pastdmark: pop af  
3a6c			endm  
# End of macro DMARK
3a6c				CALLMONITOR 
3a6c cd 17 16			call break_point_state  
3a6f				endm  
# End of macro CALLMONITOR
3a6f			endif	 
3a6f					; count the number of rows 
3a6f			 
3a6f 06 00				ld b, 0 
3a71 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a72 d6 28				sub display_cols 
3a74 f2 7a 3a				jp p, .atprunder 
3a77 04					inc b 
3a78 18 f7				jr .atpr 
3a7a			.atprunder:	 
3a7a			if DEBUG_FORTH_WORDS 
3a7a				DMARK "A?2" 
3a7a f5				push af  
3a7b 3a 8f 3a			ld a, (.dmark)  
3a7e 32 77 fb			ld (debug_mark),a  
3a81 3a 90 3a			ld a, (.dmark+1)  
3a84 32 78 fb			ld (debug_mark+1),a  
3a87 3a 91 3a			ld a, (.dmark+2)  
3a8a 32 79 fb			ld (debug_mark+2),a  
3a8d 18 03			jr .pastdmark  
3a8f ..			.dmark: db "A?2"  
3a92 f1			.pastdmark: pop af  
3a93			endm  
# End of macro DMARK
3a93				CALLMONITOR 
3a93 cd 17 16			call break_point_state  
3a96				endm  
# End of macro CALLMONITOR
3a96			endif	 
3a96 26 00				ld h, 0 
3a98 69					ld l, c 
3a99 cd a4 1b				call forth_push_numhl 
3a9c 68					ld l, b  
3a9d cd a4 1b				call forth_push_numhl 
3aa0			 
3aa0			 
3aa0				NEXTW 
3aa0 c3 0d 1f			jp macro_next 
3aa3				endm 
# End of macro NEXTW
3aa3			 
3aa3			.FB: 
3aa3				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3aa3 1b				db WORD_SYS_CORE+7             
3aa4 f1 3a			dw .EMIT            
3aa6 03				db 2 + 1 
3aa7 .. 00			db "FB",0              
3aaa				endm 
# End of macro CWHEAD
3aaa			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3aaa			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3aaa			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3aaa			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3aaa					if DEBUG_FORTH_WORDS_KEY 
3aaa						DMARK "FB." 
3aaa f5				push af  
3aab 3a bf 3a			ld a, (.dmark)  
3aae 32 77 fb			ld (debug_mark),a  
3ab1 3a c0 3a			ld a, (.dmark+1)  
3ab4 32 78 fb			ld (debug_mark+1),a  
3ab7 3a c1 3a			ld a, (.dmark+2)  
3aba 32 79 fb			ld (debug_mark+2),a  
3abd 18 03			jr .pastdmark  
3abf ..			.dmark: db "FB."  
3ac2 f1			.pastdmark: pop af  
3ac3			endm  
# End of macro DMARK
3ac3						CALLMONITOR 
3ac3 cd 17 16			call break_point_state  
3ac6				endm  
# End of macro CALLMONITOR
3ac6					endif 
3ac6			 
3ac6					FORTH_DSP_VALUEHL 
3ac6 cd 9b 1d			call macro_dsp_valuehl 
3ac9				endm 
# End of macro FORTH_DSP_VALUEHL
3ac9			 
3ac9 7d					ld a, l 
3aca fe 01				cp 1 
3acc 20 05				jr nz, .fbn1 
3ace 21 1c fa				ld hl, display_fb1 
3ad1 18 15				jr .fbset 
3ad3 fe 02		.fbn1:		cp 2 
3ad5 20 05				jr nz, .fbn2 
3ad7 21 da f8				ld hl, display_fb2 
3ada 18 0c				jr .fbset 
3adc fe 03		.fbn2:		cp 3 
3ade 20 05				jr nz, .fbn3 
3ae0 21 7b f9				ld hl, display_fb3 
3ae3 18 03				jr .fbset 
3ae5			.fbn3:		 ; if invalid number select first 
3ae5 21 1c fa				ld hl, display_fb1 
3ae8 22 d8 f8		.fbset:		ld (display_fb_active), hl 
3aeb			 
3aeb					FORTH_DSP_POP 
3aeb cd 53 1e			call macro_forth_dsp_pop 
3aee				endm 
# End of macro FORTH_DSP_POP
3aee			 
3aee					NEXTW 
3aee c3 0d 1f			jp macro_next 
3af1				endm 
# End of macro NEXTW
3af1			 
3af1			 
3af1			.EMIT: 
3af1				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3af1 1b				db WORD_SYS_CORE+7             
3af2 42 3b			dw .DOTH            
3af4 05				db 4 + 1 
3af5 .. 00			db "EMIT",0              
3afa				endm 
# End of macro CWHEAD
3afa			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3afa					; get value off TOS and display it 
3afa			 
3afa					if DEBUG_FORTH_WORDS_KEY 
3afa						DMARK "EMT" 
3afa f5				push af  
3afb 3a 0f 3b			ld a, (.dmark)  
3afe 32 77 fb			ld (debug_mark),a  
3b01 3a 10 3b			ld a, (.dmark+1)  
3b04 32 78 fb			ld (debug_mark+1),a  
3b07 3a 11 3b			ld a, (.dmark+2)  
3b0a 32 79 fb			ld (debug_mark+2),a  
3b0d 18 03			jr .pastdmark  
3b0f ..			.dmark: db "EMT"  
3b12 f1			.pastdmark: pop af  
3b13			endm  
# End of macro DMARK
3b13						CALLMONITOR 
3b13 cd 17 16			call break_point_state  
3b16				endm  
# End of macro CALLMONITOR
3b16					endif 
3b16			 
3b16					FORTH_DSP_VALUEHL 
3b16 cd 9b 1d			call macro_dsp_valuehl 
3b19				endm 
# End of macro FORTH_DSP_VALUEHL
3b19			 
3b19 7d					ld a,l 
3b1a			 
3b1a					; TODO write to display 
3b1a			 
3b1a 32 2f f0				ld (os_input), a 
3b1d 3e 00				ld a, 0 
3b1f 32 30 f0				ld (os_input+1), a 
3b22					 
3b22 3a 5a f8				ld a, (f_cursor_ptr) 
3b25 11 2f f0				ld de, os_input 
3b28 cd aa 0a				call str_at_display 
3b2b			 
3b2b			 
3b2b 3a 38 f8				ld a,(cli_autodisplay) 
3b2e fe 00				cp 0 
3b30 28 03				jr z, .enoupdate 
3b32 cd ba 0a						call update_display 
3b35					.enoupdate: 
3b35			 
3b35 3a 5a f8				ld a, (f_cursor_ptr) 
3b38 3c					inc a 
3b39 32 5a f8				ld (f_cursor_ptr), a   ; save new pos 
3b3c			 
3b3c			 
3b3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b3c cd 53 1e			call macro_forth_dsp_pop 
3b3f				endm 
# End of macro FORTH_DSP_POP
3b3f			  
3b3f			 
3b3f					NEXTW 
3b3f c3 0d 1f			jp macro_next 
3b42				endm 
# End of macro NEXTW
3b42			.DOTH: 
3b42				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b42 1c				db WORD_SYS_CORE+8             
3b43 72 3b			dw .DOTF            
3b45 03				db 2 + 1 
3b46 .. 00			db ".-",0              
3b49				endm 
# End of macro CWHEAD
3b49			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b49					; get value off TOS and display it 
3b49					if DEBUG_FORTH_WORDS_KEY 
3b49						DMARK "DTD" 
3b49 f5				push af  
3b4a 3a 5e 3b			ld a, (.dmark)  
3b4d 32 77 fb			ld (debug_mark),a  
3b50 3a 5f 3b			ld a, (.dmark+1)  
3b53 32 78 fb			ld (debug_mark+1),a  
3b56 3a 60 3b			ld a, (.dmark+2)  
3b59 32 79 fb			ld (debug_mark+2),a  
3b5c 18 03			jr .pastdmark  
3b5e ..			.dmark: db "DTD"  
3b61 f1			.pastdmark: pop af  
3b62			endm  
# End of macro DMARK
3b62						CALLMONITOR 
3b62 cd 17 16			call break_point_state  
3b65				endm  
# End of macro CALLMONITOR
3b65					endif 
3b65 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b67 3e 00			ld a, 0 
3b69 32 39 f8			ld (cli_mvdot), a 
3b6c c3 c9 3b			jp .dotgo 
3b6f				NEXTW 
3b6f c3 0d 1f			jp macro_next 
3b72				endm 
# End of macro NEXTW
3b72			.DOTF: 
3b72				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b72 1c				db WORD_SYS_CORE+8             
3b73 a0 3b			dw .DOT            
3b75 03				db 2 + 1 
3b76 .. 00			db ".>",0              
3b79				endm 
# End of macro CWHEAD
3b79			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3b79					; get value off TOS and display it 
3b79			        ; TODO BUG adds extra spaces 
3b79			        ; TODO BUG handle numerics? 
3b79					if DEBUG_FORTH_WORDS_KEY 
3b79						DMARK "DTC" 
3b79 f5				push af  
3b7a 3a 8e 3b			ld a, (.dmark)  
3b7d 32 77 fb			ld (debug_mark),a  
3b80 3a 8f 3b			ld a, (.dmark+1)  
3b83 32 78 fb			ld (debug_mark+1),a  
3b86 3a 90 3b			ld a, (.dmark+2)  
3b89 32 79 fb			ld (debug_mark+2),a  
3b8c 18 03			jr .pastdmark  
3b8e ..			.dmark: db "DTC"  
3b91 f1			.pastdmark: pop af  
3b92			endm  
# End of macro DMARK
3b92						CALLMONITOR 
3b92 cd 17 16			call break_point_state  
3b95				endm  
# End of macro CALLMONITOR
3b95					endif 
3b95 3e 01			ld a, 1 
3b97 32 39 f8			ld (cli_mvdot), a 
3b9a c3 c9 3b			jp .dotgo 
3b9d				NEXTW 
3b9d c3 0d 1f			jp macro_next 
3ba0				endm 
# End of macro NEXTW
3ba0			 
3ba0			.DOT: 
3ba0				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3ba0 1c				db WORD_SYS_CORE+8             
3ba1 2c 3c			dw .CLS            
3ba3 02				db 1 + 1 
3ba4 .. 00			db ".",0              
3ba6				endm 
# End of macro CWHEAD
3ba6			        ; | . ( u -- ) Display TOS | DONE 
3ba6					; get value off TOS and display it 
3ba6			 
3ba6					if DEBUG_FORTH_WORDS_KEY 
3ba6						DMARK "DOT" 
3ba6 f5				push af  
3ba7 3a bb 3b			ld a, (.dmark)  
3baa 32 77 fb			ld (debug_mark),a  
3bad 3a bc 3b			ld a, (.dmark+1)  
3bb0 32 78 fb			ld (debug_mark+1),a  
3bb3 3a bd 3b			ld a, (.dmark+2)  
3bb6 32 79 fb			ld (debug_mark+2),a  
3bb9 18 03			jr .pastdmark  
3bbb ..			.dmark: db "DOT"  
3bbe f1			.pastdmark: pop af  
3bbf			endm  
# End of macro DMARK
3bbf						CALLMONITOR 
3bbf cd 17 16			call break_point_state  
3bc2				endm  
# End of macro CALLMONITOR
3bc2					endif 
3bc2 3e 00			ld a, 0 
3bc4 32 39 f8			ld (cli_mvdot), a 
3bc7 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bc9				 
3bc9			 
3bc9			.dotgo: 
3bc9			 
3bc9			; move up type to on stack for parserv5 
3bc9					FORTH_DSP 
3bc9 cd 61 1d			call macro_forth_dsp 
3bcc				endm 
# End of macro FORTH_DSP
3bcc				;FORTH_DSP_VALUE  
3bcc			 
3bcc			if DEBUG_FORTH_DOT 
3bcc				DMARK "DOT" 
3bcc				CALLMONITOR 
3bcc			endif	 
3bcc			;		.print: 
3bcc			 
3bcc 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3bcd 23				inc hl   ; position to the actual value 
3bce fe 01			cp DS_TYPE_STR 
3bd0 20 06			jr nz, .dotnum1  
3bd2			 
3bd2			; display string 
3bd2				FORTH_DSP_VALUE  
3bd2 cd 84 1d			call macro_forth_dsp_value 
3bd5				endm 
# End of macro FORTH_DSP_VALUE
3bd5 eb				ex de,hl 
3bd6 18 11			jr .dotwrite 
3bd8			 
3bd8			.dotnum1: 
3bd8 fe 02			cp DS_TYPE_INUM 
3bda 20 0c			jr nz, .dotflot 
3bdc			 
3bdc			 
3bdc			; display number 
3bdc			 
3bdc			;	push hl 
3bdc			;	call clear_display 
3bdc			;	pop hl 
3bdc			 
3bdc 5e				ld e, (hl) 
3bdd 23				inc hl 
3bde 56				ld d, (hl) 
3bdf 21 31 ee			ld hl, scratch 
3be2			if DEBUG_FORTH_DOT 
3be2				DMARK "DT1" 
3be2				CALLMONITOR 
3be2			endif	 
3be2			 
3be2 cd d8 10			call uitoa_16 
3be5 eb				ex de,hl 
3be6			 
3be6			if DEBUG_FORTH_DOT 
3be6				DMARK "DT2" 
3be6				CALLMONITOR 
3be6			endif	 
3be6			 
3be6			;	ld de, os_word_scratch 
3be6 18 01			jr .dotwrite 
3be8			 
3be8 00			.dotflot:   nop 
3be9			; TODO print floating point number 
3be9			 
3be9			.dotwrite:		 
3be9			 
3be9					; if c is set then set all '-' to spaces 
3be9					; need to also take into account .>  
3be9			 
3be9 3e 01				ld a, 1 
3beb b9					cp c 
3bec 20 13				jr nz, .nodashswap 
3bee			 
3bee					; DE has the string to write, working with HL 
3bee			 
3bee 06 ff				ld b, 255 
3bf0 d5					push de 
3bf1 e1					pop hl 
3bf2			 
3bf2			if DEBUG_FORTH_DOT 
3bf2				DMARK "DT-" 
3bf2				CALLMONITOR 
3bf2			endif	 
3bf2 7e			.dashscan:	ld a, (hl) 
3bf3 fe 00				cp 0 
3bf5 28 0a				jr z, .nodashswap 
3bf7 fe 2d				cp '-' 
3bf9 20 03				jr nz, .dashskip 
3bfb 3e 20				ld a, ' ' 
3bfd 77					ld (hl), a 
3bfe 23			.dashskip:	inc hl 
3bff			if DEBUG_FORTH_DOT 
3bff				DMARK "D-2" 
3bff				CALLMONITOR 
3bff			endif	 
3bff 10 f1				djnz .dashscan 
3c01			 
3c01			if DEBUG_FORTH_DOT 
3c01				DMARK "D-1" 
3c01				CALLMONITOR 
3c01			endif	 
3c01			 
3c01			.nodashswap: 
3c01			 
3c01 e5					push hl   ; save string start in case we need to advance print 
3c02			 
3c02 3a 5a f8				ld a, (f_cursor_ptr) 
3c05 cd aa 0a				call str_at_display 
3c08 3a 38 f8				ld a,(cli_autodisplay) 
3c0b fe 00				cp 0 
3c0d 28 03				jr z, .noupdate 
3c0f cd ba 0a						call update_display 
3c12					.noupdate: 
3c12			 
3c12			 
3c12					; see if we need to advance the print position 
3c12			 
3c12 e1					pop hl   ; get back string 
3c13			 
3c13 3a 39 f8				ld a, (cli_mvdot) 
3c16			if DEBUG_FORTH_DOT 
3c16					ld e,a 
3c16				DMARK "D>1" 
3c16				CALLMONITOR 
3c16			endif	 
3c16 fe 00				cp 0 
3c18 28 0c				jr z, .noadv 
3c1a					; yes, lets advance the print position 
3c1a 3e 00				ld a, 0 
3c1c cd 34 11				call strlent 
3c1f 3a 5a f8				ld a, (f_cursor_ptr) 
3c22 85					add a,l 
3c23					;call addatohl 
3c23					;ld a, l 
3c23 32 5a f8				ld (f_cursor_ptr), a   ; save new pos 
3c26			 
3c26			if DEBUG_FORTH_DOT 
3c26				DMARK "D->" 
3c26				CALLMONITOR 
3c26			endif	 
3c26			 
3c26			.noadv:	 
3c26			 
3c26					if DEBUG_FORTH_DOT_WAIT 
3c26							call next_page_prompt 
3c26					endif	 
3c26			; TODO this pop off the stack causes a crash. i dont know why 
3c26			 
3c26			 
3c26			if DEBUG_FORTH_DOT 
3c26				DMARK "DTh" 
3c26				CALLMONITOR 
3c26			endif	 
3c26			 
3c26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c26 cd 53 1e			call macro_forth_dsp_pop 
3c29				endm 
# End of macro FORTH_DSP_POP
3c29			 
3c29			if DEBUG_FORTH_DOT 
3c29				DMARK "DTi" 
3c29				CALLMONITOR 
3c29			endif	 
3c29			 
3c29			 
3c29					NEXTW 
3c29 c3 0d 1f			jp macro_next 
3c2c				endm 
# End of macro NEXTW
3c2c			 
3c2c			.CLS: 
3c2c				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c2c 35				db WORD_SYS_CORE+33             
3c2d 59 3c			dw .DRAW            
3c2f 04				db 3 + 1 
3c30 .. 00			db "CLS",0              
3c34				endm 
# End of macro CWHEAD
3c34			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c34					if DEBUG_FORTH_WORDS_KEY 
3c34						DMARK "CLS" 
3c34 f5				push af  
3c35 3a 49 3c			ld a, (.dmark)  
3c38 32 77 fb			ld (debug_mark),a  
3c3b 3a 4a 3c			ld a, (.dmark+1)  
3c3e 32 78 fb			ld (debug_mark+1),a  
3c41 3a 4b 3c			ld a, (.dmark+2)  
3c44 32 79 fb			ld (debug_mark+2),a  
3c47 18 03			jr .pastdmark  
3c49 ..			.dmark: db "CLS"  
3c4c f1			.pastdmark: pop af  
3c4d			endm  
# End of macro DMARK
3c4d						CALLMONITOR 
3c4d cd 17 16			call break_point_state  
3c50				endm  
# End of macro CALLMONITOR
3c50					endif 
3c50 cd 97 0a				call clear_display 
3c53 c3 67 3d				jp .home		; and home cursor 
3c56					NEXTW 
3c56 c3 0d 1f			jp macro_next 
3c59				endm 
# End of macro NEXTW
3c59			 
3c59			.DRAW: 
3c59				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c59 36				db WORD_SYS_CORE+34             
3c5a 84 3c			dw .DUMP            
3c5c 05				db 4 + 1 
3c5d .. 00			db "DRAW",0              
3c62				endm 
# End of macro CWHEAD
3c62			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3c62					if DEBUG_FORTH_WORDS_KEY 
3c62						DMARK "DRW" 
3c62 f5				push af  
3c63 3a 77 3c			ld a, (.dmark)  
3c66 32 77 fb			ld (debug_mark),a  
3c69 3a 78 3c			ld a, (.dmark+1)  
3c6c 32 78 fb			ld (debug_mark+1),a  
3c6f 3a 79 3c			ld a, (.dmark+2)  
3c72 32 79 fb			ld (debug_mark+2),a  
3c75 18 03			jr .pastdmark  
3c77 ..			.dmark: db "DRW"  
3c7a f1			.pastdmark: pop af  
3c7b			endm  
# End of macro DMARK
3c7b						CALLMONITOR 
3c7b cd 17 16			call break_point_state  
3c7e				endm  
# End of macro CALLMONITOR
3c7e					endif 
3c7e cd ba 0a				call update_display 
3c81					NEXTW 
3c81 c3 0d 1f			jp macro_next 
3c84				endm 
# End of macro NEXTW
3c84			 
3c84			.DUMP: 
3c84				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3c84 37				db WORD_SYS_CORE+35             
3c85 bc 3c			dw .CDUMP            
3c87 05				db 4 + 1 
3c88 .. 00			db "DUMP",0              
3c8d				endm 
# End of macro CWHEAD
3c8d			; | DUMP ( x -- ) With address x display dump   | DONE 
3c8d			; TODO pop address to use off of the stack 
3c8d					if DEBUG_FORTH_WORDS_KEY 
3c8d						DMARK "DUM" 
3c8d f5				push af  
3c8e 3a a2 3c			ld a, (.dmark)  
3c91 32 77 fb			ld (debug_mark),a  
3c94 3a a3 3c			ld a, (.dmark+1)  
3c97 32 78 fb			ld (debug_mark+1),a  
3c9a 3a a4 3c			ld a, (.dmark+2)  
3c9d 32 79 fb			ld (debug_mark+2),a  
3ca0 18 03			jr .pastdmark  
3ca2 ..			.dmark: db "DUM"  
3ca5 f1			.pastdmark: pop af  
3ca6			endm  
# End of macro DMARK
3ca6						CALLMONITOR 
3ca6 cd 17 16			call break_point_state  
3ca9				endm  
# End of macro CALLMONITOR
3ca9					endif 
3ca9 cd 97 0a				call clear_display 
3cac			 
3cac					; get address 
3cac			 
3cac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cac cd 9b 1d			call macro_dsp_valuehl 
3caf				endm 
# End of macro FORTH_DSP_VALUEHL
3caf				 
3caf					; save it for cdump 
3caf			 
3caf 22 54 f1				ld (os_cur_ptr),hl 
3cb2			 
3cb2					; destroy value TOS 
3cb2			 
3cb2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cb2 cd 53 1e			call macro_forth_dsp_pop 
3cb5				endm 
# End of macro FORTH_DSP_POP
3cb5			 
3cb5 cd 24 1a				call dumpcont	; skip old style of param parsing	 
3cb8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3cb9					NEXTW 
3cb9 c3 0d 1f			jp macro_next 
3cbc				endm 
# End of macro NEXTW
3cbc			.CDUMP: 
3cbc				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3cbc 38				db WORD_SYS_CORE+36             
3cbd ec 3c			dw .DAT            
3cbf 06				db 5 + 1 
3cc0 .. 00			db "CDUMP",0              
3cc6				endm 
# End of macro CWHEAD
3cc6			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3cc6					if DEBUG_FORTH_WORDS_KEY 
3cc6						DMARK "CDP" 
3cc6 f5				push af  
3cc7 3a db 3c			ld a, (.dmark)  
3cca 32 77 fb			ld (debug_mark),a  
3ccd 3a dc 3c			ld a, (.dmark+1)  
3cd0 32 78 fb			ld (debug_mark+1),a  
3cd3 3a dd 3c			ld a, (.dmark+2)  
3cd6 32 79 fb			ld (debug_mark+2),a  
3cd9 18 03			jr .pastdmark  
3cdb ..			.dmark: db "CDP"  
3cde f1			.pastdmark: pop af  
3cdf			endm  
# End of macro DMARK
3cdf						CALLMONITOR 
3cdf cd 17 16			call break_point_state  
3ce2				endm  
# End of macro CALLMONITOR
3ce2					endif 
3ce2 cd 97 0a				call clear_display 
3ce5 cd 24 1a				call dumpcont	 
3ce8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3ce9					NEXTW 
3ce9 c3 0d 1f			jp macro_next 
3cec				endm 
# End of macro NEXTW
3cec			 
3cec			 
3cec			 
3cec			 
3cec			.DAT: 
3cec				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3cec 3d				db WORD_SYS_CORE+41             
3ced 42 3d			dw .HOME            
3cef 03				db 2 + 1 
3cf0 .. 00			db "AT",0              
3cf3				endm 
# End of macro CWHEAD
3cf3			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3cf3					if DEBUG_FORTH_WORDS_KEY 
3cf3						DMARK "AT." 
3cf3 f5				push af  
3cf4 3a 08 3d			ld a, (.dmark)  
3cf7 32 77 fb			ld (debug_mark),a  
3cfa 3a 09 3d			ld a, (.dmark+1)  
3cfd 32 78 fb			ld (debug_mark+1),a  
3d00 3a 0a 3d			ld a, (.dmark+2)  
3d03 32 79 fb			ld (debug_mark+2),a  
3d06 18 03			jr .pastdmark  
3d08 ..			.dmark: db "AT."  
3d0b f1			.pastdmark: pop af  
3d0c			endm  
# End of macro DMARK
3d0c						CALLMONITOR 
3d0c cd 17 16			call break_point_state  
3d0f				endm  
# End of macro CALLMONITOR
3d0f					endif 
3d0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d0f cd 9b 1d			call macro_dsp_valuehl 
3d12				endm 
# End of macro FORTH_DSP_VALUEHL
3d12			 
3d12			 
3d12					; TODO save cursor row 
3d12 7d					ld a,l 
3d13 fe 02				cp 2 
3d15 20 04				jr nz, .crow3 
3d17 3e 28				ld a, display_row_2 
3d19 18 12				jr .ccol1 
3d1b fe 03		.crow3:		cp 3 
3d1d 20 04				jr nz, .crow4 
3d1f 3e 50				ld a, display_row_3 
3d21 18 0a				jr .ccol1 
3d23 fe 04		.crow4:		cp 4 
3d25 20 04				jr nz, .crow1 
3d27 3e 78				ld a, display_row_4 
3d29 18 02				jr .ccol1 
3d2b 3e 00		.crow1:		ld a,display_row_1 
3d2d f5			.ccol1:		push af			; got row offset 
3d2e 6f					ld l,a 
3d2f 26 00				ld h,0 
3d31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d31 cd 53 1e			call macro_forth_dsp_pop 
3d34				endm 
# End of macro FORTH_DSP_POP
3d34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d34 cd 9b 1d			call macro_dsp_valuehl 
3d37				endm 
# End of macro FORTH_DSP_VALUEHL
3d37					; TODO save cursor col 
3d37 f1					pop af 
3d38 85					add l		; add col offset 
3d39 32 5a f8				ld (f_cursor_ptr), a 
3d3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d3c cd 53 1e			call macro_forth_dsp_pop 
3d3f				endm 
# End of macro FORTH_DSP_POP
3d3f			 
3d3f					; calculate  
3d3f			 
3d3f					NEXTW 
3d3f c3 0d 1f			jp macro_next 
3d42				endm 
# End of macro NEXTW
3d42			 
3d42			 
3d42			.HOME: 
3d42				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d42 41				db WORD_SYS_CORE+45             
3d43 6f 3d			dw .SPACE            
3d45 05				db 4 + 1 
3d46 .. 00			db "HOME",0              
3d4b				endm 
# End of macro CWHEAD
3d4b			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d4b					if DEBUG_FORTH_WORDS_KEY 
3d4b						DMARK "HOM" 
3d4b f5				push af  
3d4c 3a 60 3d			ld a, (.dmark)  
3d4f 32 77 fb			ld (debug_mark),a  
3d52 3a 61 3d			ld a, (.dmark+1)  
3d55 32 78 fb			ld (debug_mark+1),a  
3d58 3a 62 3d			ld a, (.dmark+2)  
3d5b 32 79 fb			ld (debug_mark+2),a  
3d5e 18 03			jr .pastdmark  
3d60 ..			.dmark: db "HOM"  
3d63 f1			.pastdmark: pop af  
3d64			endm  
# End of macro DMARK
3d64						CALLMONITOR 
3d64 cd 17 16			call break_point_state  
3d67				endm  
# End of macro CALLMONITOR
3d67					endif 
3d67 3e 00		.home:		ld a, 0		; and home cursor 
3d69 32 5a f8				ld (f_cursor_ptr), a 
3d6c					NEXTW 
3d6c c3 0d 1f			jp macro_next 
3d6f				endm 
# End of macro NEXTW
3d6f			 
3d6f			 
3d6f			.SPACE: 
3d6f				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3d6f 46				db WORD_SYS_CORE+50             
3d70 9d 3d			dw .SPACES            
3d72 03				db 2 + 1 
3d73 .. 00			db "BL",0              
3d76				endm 
# End of macro CWHEAD
3d76			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3d76					if DEBUG_FORTH_WORDS_KEY 
3d76						DMARK "BL." 
3d76 f5				push af  
3d77 3a 8b 3d			ld a, (.dmark)  
3d7a 32 77 fb			ld (debug_mark),a  
3d7d 3a 8c 3d			ld a, (.dmark+1)  
3d80 32 78 fb			ld (debug_mark+1),a  
3d83 3a 8d 3d			ld a, (.dmark+2)  
3d86 32 79 fb			ld (debug_mark+2),a  
3d89 18 03			jr .pastdmark  
3d8b ..			.dmark: db "BL."  
3d8e f1			.pastdmark: pop af  
3d8f			endm  
# End of macro DMARK
3d8f						CALLMONITOR 
3d8f cd 17 16			call break_point_state  
3d92				endm  
# End of macro CALLMONITOR
3d92					endif 
3d92 21 9b 3d				ld hl, .blstr 
3d95 cd 12 1c				call forth_push_str 
3d98					 
3d98				       NEXTW 
3d98 c3 0d 1f			jp macro_next 
3d9b				endm 
# End of macro NEXTW
3d9b			 
3d9b .. 00		.blstr: db " ", 0 
3d9d			 
3d9d			.SPACES: 
3d9d				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3d9d 47				db WORD_SYS_CORE+51             
3d9e 38 3e			dw .SCROLL            
3da0 07				db 6 + 1 
3da1 .. 00			db "SPACES",0              
3da8				endm 
# End of macro CWHEAD
3da8			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3da8					if DEBUG_FORTH_WORDS_KEY 
3da8						DMARK "SPS" 
3da8 f5				push af  
3da9 3a bd 3d			ld a, (.dmark)  
3dac 32 77 fb			ld (debug_mark),a  
3daf 3a be 3d			ld a, (.dmark+1)  
3db2 32 78 fb			ld (debug_mark+1),a  
3db5 3a bf 3d			ld a, (.dmark+2)  
3db8 32 79 fb			ld (debug_mark+2),a  
3dbb 18 03			jr .pastdmark  
3dbd ..			.dmark: db "SPS"  
3dc0 f1			.pastdmark: pop af  
3dc1			endm  
# End of macro DMARK
3dc1						CALLMONITOR 
3dc1 cd 17 16			call break_point_state  
3dc4				endm  
# End of macro CALLMONITOR
3dc4					endif 
3dc4			 
3dc4			 
3dc4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dc4 cd 9b 1d			call macro_dsp_valuehl 
3dc7				endm 
# End of macro FORTH_DSP_VALUEHL
3dc7			 
3dc7			;		push hl    ; u 
3dc7					if DEBUG_FORTH_WORDS 
3dc7						DMARK "SPA" 
3dc7 f5				push af  
3dc8 3a dc 3d			ld a, (.dmark)  
3dcb 32 77 fb			ld (debug_mark),a  
3dce 3a dd 3d			ld a, (.dmark+1)  
3dd1 32 78 fb			ld (debug_mark+1),a  
3dd4 3a de 3d			ld a, (.dmark+2)  
3dd7 32 79 fb			ld (debug_mark+2),a  
3dda 18 03			jr .pastdmark  
3ddc ..			.dmark: db "SPA"  
3ddf f1			.pastdmark: pop af  
3de0			endm  
# End of macro DMARK
3de0						CALLMONITOR 
3de0 cd 17 16			call break_point_state  
3de3				endm  
# End of macro CALLMONITOR
3de3					endif 
3de3			 
3de3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de3 cd 53 1e			call macro_forth_dsp_pop 
3de6				endm 
# End of macro FORTH_DSP_POP
3de6			;		pop hl 
3de6 4d					ld c, l 
3de7 06 00				ld b, 0 
3de9 21 31 ee				ld hl, scratch  
3dec			 
3dec					if DEBUG_FORTH_WORDS 
3dec						DMARK "SP2" 
3dec f5				push af  
3ded 3a 01 3e			ld a, (.dmark)  
3df0 32 77 fb			ld (debug_mark),a  
3df3 3a 02 3e			ld a, (.dmark+1)  
3df6 32 78 fb			ld (debug_mark+1),a  
3df9 3a 03 3e			ld a, (.dmark+2)  
3dfc 32 79 fb			ld (debug_mark+2),a  
3dff 18 03			jr .pastdmark  
3e01 ..			.dmark: db "SP2"  
3e04 f1			.pastdmark: pop af  
3e05			endm  
# End of macro DMARK
3e05						CALLMONITOR 
3e05 cd 17 16			call break_point_state  
3e08				endm  
# End of macro CALLMONITOR
3e08					endif 
3e08 3e 20				ld a, ' ' 
3e0a c5			.spaces1:	push bc 
3e0b 77					ld (hl),a 
3e0c 23					inc hl 
3e0d c1					pop bc 
3e0e 10 fa				djnz .spaces1 
3e10 3e 00				ld a,0 
3e12 77					ld (hl),a 
3e13 21 31 ee				ld hl, scratch 
3e16					if DEBUG_FORTH_WORDS 
3e16						DMARK "SP3" 
3e16 f5				push af  
3e17 3a 2b 3e			ld a, (.dmark)  
3e1a 32 77 fb			ld (debug_mark),a  
3e1d 3a 2c 3e			ld a, (.dmark+1)  
3e20 32 78 fb			ld (debug_mark+1),a  
3e23 3a 2d 3e			ld a, (.dmark+2)  
3e26 32 79 fb			ld (debug_mark+2),a  
3e29 18 03			jr .pastdmark  
3e2b ..			.dmark: db "SP3"  
3e2e f1			.pastdmark: pop af  
3e2f			endm  
# End of macro DMARK
3e2f						CALLMONITOR 
3e2f cd 17 16			call break_point_state  
3e32				endm  
# End of macro CALLMONITOR
3e32					endif 
3e32 cd 0d 1d				call forth_apush 
3e35			 
3e35				       NEXTW 
3e35 c3 0d 1f			jp macro_next 
3e38				endm 
# End of macro NEXTW
3e38			 
3e38			 
3e38			 
3e38			.SCROLL: 
3e38				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e38 53				db WORD_SYS_CORE+63             
3e39 65 3e			dw .SCROLLD            
3e3b 07				db 6 + 1 
3e3c .. 00			db "SCROLL",0              
3e43				endm 
# End of macro CWHEAD
3e43			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e43					if DEBUG_FORTH_WORDS_KEY 
3e43						DMARK "SCR" 
3e43 f5				push af  
3e44 3a 58 3e			ld a, (.dmark)  
3e47 32 77 fb			ld (debug_mark),a  
3e4a 3a 59 3e			ld a, (.dmark+1)  
3e4d 32 78 fb			ld (debug_mark+1),a  
3e50 3a 5a 3e			ld a, (.dmark+2)  
3e53 32 79 fb			ld (debug_mark+2),a  
3e56 18 03			jr .pastdmark  
3e58 ..			.dmark: db "SCR"  
3e5b f1			.pastdmark: pop af  
3e5c			endm  
# End of macro DMARK
3e5c						CALLMONITOR 
3e5c cd 17 16			call break_point_state  
3e5f				endm  
# End of macro CALLMONITOR
3e5f					endif 
3e5f			 
3e5f cd 59 0a			call scroll_up 
3e62			;	call update_display 
3e62			 
3e62					NEXTW 
3e62 c3 0d 1f			jp macro_next 
3e65				endm 
# End of macro NEXTW
3e65			 
3e65			 
3e65			 
3e65			;		; get dir 
3e65			; 
3e65			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e65			; 
3e65			;		push hl 
3e65			; 
3e65			;		; destroy value TOS 
3e65			; 
3e65			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e65			; 
3e65			;		; get count 
3e65			; 
3e65			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e65			; 
3e65			;		push hl 
3e65			; 
3e65			;		; destroy value TOS 
3e65			; 
3e65			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e65			; 
3e65			;		; one value on hl get other one back 
3e65			; 
3e65			;		pop bc    ; count 
3e65			; 
3e65			;		pop de   ; dir 
3e65			; 
3e65			; 
3e65			;		ld b, c 
3e65			; 
3e65			;.scrolldir:     push bc 
3e65			;		push de 
3e65			; 
3e65			;		ld a, 0 
3e65			;		cp e 
3e65			;		jr z, .scrollup  
3e65			;		call scroll_down 
3e65			;		jr .scrollnext 
3e65			;.scrollup:	call scroll_up 
3e65			; 
3e65			;		 
3e65			;.scrollnext: 
3e65			;		pop de 
3e65			;		pop bc 
3e65			;		djnz .scrolldir 
3e65			; 
3e65			; 
3e65			; 
3e65			; 
3e65			; 
3e65			;		NEXTW 
3e65			 
3e65			.SCROLLD: 
3e65				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3e65 53				db WORD_SYS_CORE+63             
3e66 93 3e			dw .ATQ            
3e68 08				db 7 + 1 
3e69 .. 00			db "SCROLLD",0              
3e71				endm 
# End of macro CWHEAD
3e71			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3e71					if DEBUG_FORTH_WORDS_KEY 
3e71						DMARK "SCD" 
3e71 f5				push af  
3e72 3a 86 3e			ld a, (.dmark)  
3e75 32 77 fb			ld (debug_mark),a  
3e78 3a 87 3e			ld a, (.dmark+1)  
3e7b 32 78 fb			ld (debug_mark+1),a  
3e7e 3a 88 3e			ld a, (.dmark+2)  
3e81 32 79 fb			ld (debug_mark+2),a  
3e84 18 03			jr .pastdmark  
3e86 ..			.dmark: db "SCD"  
3e89 f1			.pastdmark: pop af  
3e8a			endm  
# End of macro DMARK
3e8a						CALLMONITOR 
3e8a cd 17 16			call break_point_state  
3e8d				endm  
# End of macro CALLMONITOR
3e8d					endif 
3e8d			 
3e8d cd 7d 0a			call scroll_down 
3e90			;	call update_display 
3e90			 
3e90					NEXTW 
3e90 c3 0d 1f			jp macro_next 
3e93				endm 
# End of macro NEXTW
3e93			 
3e93			 
3e93			.ATQ: 
3e93				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3e93 62				db WORD_SYS_CORE+78             
3e94 f1 3e			dw .AUTODSP            
3e96 04				db 3 + 1 
3e97 .. 00			db "AT@",0              
3e9b				endm 
# End of macro CWHEAD
3e9b			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3e9b					if DEBUG_FORTH_WORDS_KEY 
3e9b						DMARK "ATA" 
3e9b f5				push af  
3e9c 3a b0 3e			ld a, (.dmark)  
3e9f 32 77 fb			ld (debug_mark),a  
3ea2 3a b1 3e			ld a, (.dmark+1)  
3ea5 32 78 fb			ld (debug_mark+1),a  
3ea8 3a b2 3e			ld a, (.dmark+2)  
3eab 32 79 fb			ld (debug_mark+2),a  
3eae 18 03			jr .pastdmark  
3eb0 ..			.dmark: db "ATA"  
3eb3 f1			.pastdmark: pop af  
3eb4			endm  
# End of macro DMARK
3eb4						CALLMONITOR 
3eb4 cd 17 16			call break_point_state  
3eb7				endm  
# End of macro CALLMONITOR
3eb7					endif 
3eb7			 
3eb7			 
3eb7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eb7 cd 9b 1d			call macro_dsp_valuehl 
3eba				endm 
# End of macro FORTH_DSP_VALUEHL
3eba			 
3eba					; TODO save cursor row 
3eba 7d					ld a,l 
3ebb fe 02				cp 2 
3ebd 20 04				jr nz, .crow3aq 
3ebf 3e 28				ld a, display_row_2 
3ec1 18 12				jr .ccol1aq 
3ec3 fe 03		.crow3aq:		cp 3 
3ec5 20 04				jr nz, .crow4aq 
3ec7 3e 50				ld a, display_row_3 
3ec9 18 0a				jr .ccol1aq 
3ecb fe 04		.crow4aq:		cp 4 
3ecd 20 04				jr nz, .crow1aq 
3ecf 3e 78				ld a, display_row_4 
3ed1 18 02				jr .ccol1aq 
3ed3 3e 00		.crow1aq:		ld a,display_row_1 
3ed5 f5			.ccol1aq:		push af			; got row offset 
3ed6 6f					ld l,a 
3ed7 26 00				ld h,0 
3ed9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ed9 cd 53 1e			call macro_forth_dsp_pop 
3edc				endm 
# End of macro FORTH_DSP_POP
3edc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3edc cd 9b 1d			call macro_dsp_valuehl 
3edf				endm 
# End of macro FORTH_DSP_VALUEHL
3edf					; TODO save cursor col 
3edf f1					pop af 
3ee0 85					add l		; add col offset 
3ee1			 
3ee1					; add current frame buffer address 
3ee1 2a d8 f8				ld hl, (display_fb_active) 
3ee4 cd cb 0c				call addatohl 
3ee7			 
3ee7			 
3ee7			 
3ee7			 
3ee7					; get char frame buffer location offset in hl 
3ee7			 
3ee7 7e					ld a,(hl) 
3ee8 26 00				ld h, 0 
3eea 6f					ld l, a 
3eeb			 
3eeb cd a4 1b				call forth_push_numhl 
3eee			 
3eee			 
3eee					NEXTW 
3eee c3 0d 1f			jp macro_next 
3ef1				endm 
# End of macro NEXTW
3ef1			 
3ef1			.AUTODSP: 
3ef1				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3ef1 63				db WORD_SYS_CORE+79             
3ef2 07 3f			dw .MENU            
3ef4 05				db 4 + 1 
3ef5 .. 00			db "ADSP",0              
3efa				endm 
# End of macro CWHEAD
3efa			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3efa			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3efa			 
3efa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3efa cd 9b 1d			call macro_dsp_valuehl 
3efd				endm 
# End of macro FORTH_DSP_VALUEHL
3efd			 
3efd			;		push hl 
3efd			 
3efd					; destroy value TOS 
3efd			 
3efd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3efd cd 53 1e			call macro_forth_dsp_pop 
3f00				endm 
# End of macro FORTH_DSP_POP
3f00			 
3f00			;		pop hl 
3f00			 
3f00 7d					ld a,l 
3f01 32 38 f8				ld (cli_autodisplay), a 
3f04				       NEXTW 
3f04 c3 0d 1f			jp macro_next 
3f07				endm 
# End of macro NEXTW
3f07			 
3f07			.MENU: 
3f07				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f07 70				db WORD_SYS_CORE+92             
3f08 b0 3f			dw .ENDDISPLAY            
3f0a 05				db 4 + 1 
3f0b .. 00			db "MENU",0              
3f10				endm 
# End of macro CWHEAD
3f10			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f10			 
3f10			;		; get number of items on the stack 
3f10			; 
3f10				 
3f10					FORTH_DSP_VALUEHL 
3f10 cd 9b 1d			call macro_dsp_valuehl 
3f13				endm 
# End of macro FORTH_DSP_VALUEHL
3f13				 
3f13					if DEBUG_FORTH_WORDS_KEY 
3f13						DMARK "MNU" 
3f13 f5				push af  
3f14 3a 28 3f			ld a, (.dmark)  
3f17 32 77 fb			ld (debug_mark),a  
3f1a 3a 29 3f			ld a, (.dmark+1)  
3f1d 32 78 fb			ld (debug_mark+1),a  
3f20 3a 2a 3f			ld a, (.dmark+2)  
3f23 32 79 fb			ld (debug_mark+2),a  
3f26 18 03			jr .pastdmark  
3f28 ..			.dmark: db "MNU"  
3f2b f1			.pastdmark: pop af  
3f2c			endm  
# End of macro DMARK
3f2c						CALLMONITOR 
3f2c cd 17 16			call break_point_state  
3f2f				endm  
# End of macro CALLMONITOR
3f2f					endif 
3f2f			 
3f2f 45					ld b, l	 
3f30 05					dec b 
3f31			 
3f31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f31 cd 53 1e			call macro_forth_dsp_pop 
3f34				endm 
# End of macro FORTH_DSP_POP
3f34			 
3f34			 
3f34					; go directly through the stack to pluck out the string pointers and build an array 
3f34			 
3f34			;		FORTH_DSP 
3f34			 
3f34					; hl contains top most stack item 
3f34				 
3f34 11 31 ee				ld de, scratch 
3f37			 
3f37			.mbuild: 
3f37			 
3f37					FORTH_DSP_VALUEHL 
3f37 cd 9b 1d			call macro_dsp_valuehl 
3f3a				endm 
# End of macro FORTH_DSP_VALUEHL
3f3a			 
3f3a					if DEBUG_FORTH_WORDS 
3f3a						DMARK "MN3" 
3f3a f5				push af  
3f3b 3a 4f 3f			ld a, (.dmark)  
3f3e 32 77 fb			ld (debug_mark),a  
3f41 3a 50 3f			ld a, (.dmark+1)  
3f44 32 78 fb			ld (debug_mark+1),a  
3f47 3a 51 3f			ld a, (.dmark+2)  
3f4a 32 79 fb			ld (debug_mark+2),a  
3f4d 18 03			jr .pastdmark  
3f4f ..			.dmark: db "MN3"  
3f52 f1			.pastdmark: pop af  
3f53			endm  
# End of macro DMARK
3f53						CALLMONITOR 
3f53 cd 17 16			call break_point_state  
3f56				endm  
# End of macro CALLMONITOR
3f56					endif 
3f56 eb					ex de, hl 
3f57 73					ld (hl), e 
3f58 23					inc hl 
3f59 72					ld (hl), d 
3f5a 23					inc hl 
3f5b eb					ex de, hl 
3f5c			 
3f5c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f5c cd 53 1e			call macro_forth_dsp_pop 
3f5f				endm 
# End of macro FORTH_DSP_POP
3f5f			 
3f5f 10 d6				djnz .mbuild 
3f61			 
3f61					; done add term 
3f61			 
3f61 eb					ex de, hl 
3f62 36 00				ld (hl), 0 
3f64 23					inc hl 
3f65 36 00				ld (hl), 0 
3f67			 
3f67				 
3f67					 
3f67 21 31 ee				ld hl, scratch 
3f6a			 
3f6a					if DEBUG_FORTH_WORDS 
3f6a						DMARK "MNx" 
3f6a f5				push af  
3f6b 3a 7f 3f			ld a, (.dmark)  
3f6e 32 77 fb			ld (debug_mark),a  
3f71 3a 80 3f			ld a, (.dmark+1)  
3f74 32 78 fb			ld (debug_mark+1),a  
3f77 3a 81 3f			ld a, (.dmark+2)  
3f7a 32 79 fb			ld (debug_mark+2),a  
3f7d 18 03			jr .pastdmark  
3f7f ..			.dmark: db "MNx"  
3f82 f1			.pastdmark: pop af  
3f83			endm  
# End of macro DMARK
3f83						CALLMONITOR 
3f83 cd 17 16			call break_point_state  
3f86				endm  
# End of macro CALLMONITOR
3f86					endif 
3f86			 
3f86			 
3f86			 
3f86 3e 00				ld a, 0 
3f88 cd c8 0a				call menu 
3f8b			 
3f8b			 
3f8b 6f					ld l, a 
3f8c 26 00				ld h, 0 
3f8e			 
3f8e					if DEBUG_FORTH_WORDS 
3f8e						DMARK "MNr" 
3f8e f5				push af  
3f8f 3a a3 3f			ld a, (.dmark)  
3f92 32 77 fb			ld (debug_mark),a  
3f95 3a a4 3f			ld a, (.dmark+1)  
3f98 32 78 fb			ld (debug_mark+1),a  
3f9b 3a a5 3f			ld a, (.dmark+2)  
3f9e 32 79 fb			ld (debug_mark+2),a  
3fa1 18 03			jr .pastdmark  
3fa3 ..			.dmark: db "MNr"  
3fa6 f1			.pastdmark: pop af  
3fa7			endm  
# End of macro DMARK
3fa7						CALLMONITOR 
3fa7 cd 17 16			call break_point_state  
3faa				endm  
# End of macro CALLMONITOR
3faa					endif 
3faa			 
3faa cd a4 1b				call forth_push_numhl 
3fad			 
3fad			 
3fad			 
3fad			 
3fad				       NEXTW 
3fad c3 0d 1f			jp macro_next 
3fb0				endm 
# End of macro NEXTW
3fb0			 
3fb0			 
3fb0			.ENDDISPLAY: 
3fb0			 
3fb0			; eof 
# End of file forth_words_display.asm
3fb0			include "forth_words_str.asm" 
3fb0			 
3fb0			; | ## String Words 
3fb0			 
3fb0			.PTR:   
3fb0			 
3fb0				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3fb0 48				db WORD_SYS_CORE+52             
3fb1 dd 3f			dw .STYPE            
3fb3 04				db 3 + 1 
3fb4 .. 00			db "PTR",0              
3fb8				endm 
# End of macro CWHEAD
3fb8			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3fb8			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3fb8			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3fb8			 
3fb8					if DEBUG_FORTH_WORDS_KEY 
3fb8						DMARK "PTR" 
3fb8 f5				push af  
3fb9 3a cd 3f			ld a, (.dmark)  
3fbc 32 77 fb			ld (debug_mark),a  
3fbf 3a ce 3f			ld a, (.dmark+1)  
3fc2 32 78 fb			ld (debug_mark+1),a  
3fc5 3a cf 3f			ld a, (.dmark+2)  
3fc8 32 79 fb			ld (debug_mark+2),a  
3fcb 18 03			jr .pastdmark  
3fcd ..			.dmark: db "PTR"  
3fd0 f1			.pastdmark: pop af  
3fd1			endm  
# End of macro DMARK
3fd1						CALLMONITOR 
3fd1 cd 17 16			call break_point_state  
3fd4				endm  
# End of macro CALLMONITOR
3fd4					endif 
3fd4					FORTH_DSP_VALUEHL 
3fd4 cd 9b 1d			call macro_dsp_valuehl 
3fd7				endm 
# End of macro FORTH_DSP_VALUEHL
3fd7 cd a4 1b				call forth_push_numhl 
3fda			 
3fda			 
3fda					NEXTW 
3fda c3 0d 1f			jp macro_next 
3fdd				endm 
# End of macro NEXTW
3fdd			.STYPE: 
3fdd				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3fdd 48				db WORD_SYS_CORE+52             
3fde 2c 40			dw .UPPER            
3fe0 06				db 5 + 1 
3fe1 .. 00			db "STYPE",0              
3fe7				endm 
# End of macro CWHEAD
3fe7			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3fe7					if DEBUG_FORTH_WORDS_KEY 
3fe7						DMARK "STY" 
3fe7 f5				push af  
3fe8 3a fc 3f			ld a, (.dmark)  
3feb 32 77 fb			ld (debug_mark),a  
3fee 3a fd 3f			ld a, (.dmark+1)  
3ff1 32 78 fb			ld (debug_mark+1),a  
3ff4 3a fe 3f			ld a, (.dmark+2)  
3ff7 32 79 fb			ld (debug_mark+2),a  
3ffa 18 03			jr .pastdmark  
3ffc ..			.dmark: db "STY"  
3fff f1			.pastdmark: pop af  
4000			endm  
# End of macro DMARK
4000						CALLMONITOR 
4000 cd 17 16			call break_point_state  
4003				endm  
# End of macro CALLMONITOR
4003					endif 
4003					FORTH_DSP 
4003 cd 61 1d			call macro_forth_dsp 
4006				endm 
# End of macro FORTH_DSP
4006					;v5 FORTH_DSP_VALUE 
4006			 
4006 7e					ld a, (hl) 
4007			 
4007 f5					push af 
4008			 
4008			; Dont destroy TOS		FORTH_DSP_POP 
4008			 
4008 f1					pop af 
4009			 
4009 fe 01				cp DS_TYPE_STR 
400b 28 09				jr z, .typestr 
400d			 
400d fe 02				cp DS_TYPE_INUM 
400f 28 0a				jr z, .typeinum 
4011			 
4011 21 2a 40				ld hl, .tna 
4014 18 0a				jr .tpush 
4016			 
4016 21 26 40		.typestr:	ld hl, .tstr 
4019 18 05				jr .tpush 
401b 21 28 40		.typeinum:	ld hl, .tinum 
401e 18 00				jr .tpush 
4020			 
4020			.tpush: 
4020			 
4020 cd 12 1c				call forth_push_str 
4023			 
4023					NEXTW 
4023 c3 0d 1f			jp macro_next 
4026				endm 
# End of macro NEXTW
4026 .. 00		.tstr:	db "s",0 
4028 .. 00		.tinum:  db "i",0 
402a .. 00		.tna:   db "?", 0 
402c			 
402c			 
402c			.UPPER: 
402c				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
402c 48				db WORD_SYS_CORE+52             
402d 67 40			dw .LOWER            
402f 06				db 5 + 1 
4030 .. 00			db "UPPER",0              
4036				endm 
# End of macro CWHEAD
4036			; | UPPER ( s -- s ) Upper case string s  | DONE 
4036					if DEBUG_FORTH_WORDS_KEY 
4036						DMARK "UPR" 
4036 f5				push af  
4037 3a 4b 40			ld a, (.dmark)  
403a 32 77 fb			ld (debug_mark),a  
403d 3a 4c 40			ld a, (.dmark+1)  
4040 32 78 fb			ld (debug_mark+1),a  
4043 3a 4d 40			ld a, (.dmark+2)  
4046 32 79 fb			ld (debug_mark+2),a  
4049 18 03			jr .pastdmark  
404b ..			.dmark: db "UPR"  
404e f1			.pastdmark: pop af  
404f			endm  
# End of macro DMARK
404f						CALLMONITOR 
404f cd 17 16			call break_point_state  
4052				endm  
# End of macro CALLMONITOR
4052					endif 
4052			 
4052					FORTH_DSP 
4052 cd 61 1d			call macro_forth_dsp 
4055				endm 
# End of macro FORTH_DSP
4055					 
4055			; TODO check is string type 
4055			 
4055					FORTH_DSP_VALUEHL 
4055 cd 9b 1d			call macro_dsp_valuehl 
4058				endm 
# End of macro FORTH_DSP_VALUEHL
4058			; get pointer to string in hl 
4058			 
4058 7e			.toup:		ld a, (hl) 
4059 fe 00				cp 0 
405b 28 07				jr z, .toupdone 
405d			 
405d cd 38 10				call to_upper 
4060			 
4060 77					ld (hl), a 
4061 23					inc hl 
4062 18 f4				jr .toup 
4064			 
4064					 
4064			 
4064			 
4064			; for each char convert to upper 
4064					 
4064			.toupdone: 
4064			 
4064			 
4064					NEXTW 
4064 c3 0d 1f			jp macro_next 
4067				endm 
# End of macro NEXTW
4067			.LOWER: 
4067				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4067 48				db WORD_SYS_CORE+52             
4068 a2 40			dw .TCASE            
406a 06				db 5 + 1 
406b .. 00			db "LOWER",0              
4071				endm 
# End of macro CWHEAD
4071			; | LOWER ( s -- s ) Lower case string s  | DONE 
4071					if DEBUG_FORTH_WORDS_KEY 
4071						DMARK "LWR" 
4071 f5				push af  
4072 3a 86 40			ld a, (.dmark)  
4075 32 77 fb			ld (debug_mark),a  
4078 3a 87 40			ld a, (.dmark+1)  
407b 32 78 fb			ld (debug_mark+1),a  
407e 3a 88 40			ld a, (.dmark+2)  
4081 32 79 fb			ld (debug_mark+2),a  
4084 18 03			jr .pastdmark  
4086 ..			.dmark: db "LWR"  
4089 f1			.pastdmark: pop af  
408a			endm  
# End of macro DMARK
408a						CALLMONITOR 
408a cd 17 16			call break_point_state  
408d				endm  
# End of macro CALLMONITOR
408d					endif 
408d			 
408d					FORTH_DSP 
408d cd 61 1d			call macro_forth_dsp 
4090				endm 
# End of macro FORTH_DSP
4090					 
4090			; TODO check is string type 
4090			 
4090					FORTH_DSP_VALUEHL 
4090 cd 9b 1d			call macro_dsp_valuehl 
4093				endm 
# End of macro FORTH_DSP_VALUEHL
4093			; get pointer to string in hl 
4093			 
4093 7e			.tolow:		ld a, (hl) 
4094 fe 00				cp 0 
4096 28 07				jr z, .tolowdone 
4098			 
4098 cd 41 10				call to_lower 
409b			 
409b 77					ld (hl), a 
409c 23					inc hl 
409d 18 f4				jr .tolow 
409f			 
409f					 
409f			 
409f			 
409f			; for each char convert to low 
409f					 
409f			.tolowdone: 
409f					NEXTW 
409f c3 0d 1f			jp macro_next 
40a2				endm 
# End of macro NEXTW
40a2			.TCASE: 
40a2				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40a2 48				db WORD_SYS_CORE+52             
40a3 d8 41			dw .SUBSTR            
40a5 06				db 5 + 1 
40a6 .. 00			db "TCASE",0              
40ac				endm 
# End of macro CWHEAD
40ac			; | TCASE ( s -- s ) Title case string s  | DONE 
40ac					if DEBUG_FORTH_WORDS_KEY 
40ac						DMARK "TCS" 
40ac f5				push af  
40ad 3a c1 40			ld a, (.dmark)  
40b0 32 77 fb			ld (debug_mark),a  
40b3 3a c2 40			ld a, (.dmark+1)  
40b6 32 78 fb			ld (debug_mark+1),a  
40b9 3a c3 40			ld a, (.dmark+2)  
40bc 32 79 fb			ld (debug_mark+2),a  
40bf 18 03			jr .pastdmark  
40c1 ..			.dmark: db "TCS"  
40c4 f1			.pastdmark: pop af  
40c5			endm  
# End of macro DMARK
40c5						CALLMONITOR 
40c5 cd 17 16			call break_point_state  
40c8				endm  
# End of macro CALLMONITOR
40c8					endif 
40c8			 
40c8					FORTH_DSP 
40c8 cd 61 1d			call macro_forth_dsp 
40cb				endm 
# End of macro FORTH_DSP
40cb					 
40cb			; TODO check is string type 
40cb			 
40cb					FORTH_DSP_VALUEHL 
40cb cd 9b 1d			call macro_dsp_valuehl 
40ce				endm 
# End of macro FORTH_DSP_VALUEHL
40ce			; get pointer to string in hl 
40ce			 
40ce					if DEBUG_FORTH_WORDS 
40ce						DMARK "TC1" 
40ce f5				push af  
40cf 3a e3 40			ld a, (.dmark)  
40d2 32 77 fb			ld (debug_mark),a  
40d5 3a e4 40			ld a, (.dmark+1)  
40d8 32 78 fb			ld (debug_mark+1),a  
40db 3a e5 40			ld a, (.dmark+2)  
40de 32 79 fb			ld (debug_mark+2),a  
40e1 18 03			jr .pastdmark  
40e3 ..			.dmark: db "TC1"  
40e6 f1			.pastdmark: pop af  
40e7			endm  
# End of macro DMARK
40e7						CALLMONITOR 
40e7 cd 17 16			call break_point_state  
40ea				endm  
# End of macro CALLMONITOR
40ea					endif 
40ea			 
40ea					; first time in turn to upper case first char 
40ea			 
40ea 7e					ld a, (hl) 
40eb c3 75 41				jp .totsiptou 
40ee			 
40ee			 
40ee 7e			.tot:		ld a, (hl) 
40ef fe 00				cp 0 
40f1 ca b9 41				jp z, .totdone 
40f4			 
40f4					if DEBUG_FORTH_WORDS 
40f4						DMARK "TC2" 
40f4 f5				push af  
40f5 3a 09 41			ld a, (.dmark)  
40f8 32 77 fb			ld (debug_mark),a  
40fb 3a 0a 41			ld a, (.dmark+1)  
40fe 32 78 fb			ld (debug_mark+1),a  
4101 3a 0b 41			ld a, (.dmark+2)  
4104 32 79 fb			ld (debug_mark+2),a  
4107 18 03			jr .pastdmark  
4109 ..			.dmark: db "TC2"  
410c f1			.pastdmark: pop af  
410d			endm  
# End of macro DMARK
410d						CALLMONITOR 
410d cd 17 16			call break_point_state  
4110				endm  
# End of macro CALLMONITOR
4110					endif 
4110					; check to see if current char is a space 
4110			 
4110 fe 20				cp ' ' 
4112 28 21				jr z, .totsp 
4114 cd 41 10				call to_lower 
4117					if DEBUG_FORTH_WORDS 
4117						DMARK "TC3" 
4117 f5				push af  
4118 3a 2c 41			ld a, (.dmark)  
411b 32 77 fb			ld (debug_mark),a  
411e 3a 2d 41			ld a, (.dmark+1)  
4121 32 78 fb			ld (debug_mark+1),a  
4124 3a 2e 41			ld a, (.dmark+2)  
4127 32 79 fb			ld (debug_mark+2),a  
412a 18 03			jr .pastdmark  
412c ..			.dmark: db "TC3"  
412f f1			.pastdmark: pop af  
4130			endm  
# End of macro DMARK
4130						CALLMONITOR 
4130 cd 17 16			call break_point_state  
4133				endm  
# End of macro CALLMONITOR
4133					endif 
4133 18 63				jr .totnxt 
4135			 
4135			.totsp:         ; on a space, find next char which should be upper 
4135			 
4135					if DEBUG_FORTH_WORDS 
4135						DMARK "TC4" 
4135 f5				push af  
4136 3a 4a 41			ld a, (.dmark)  
4139 32 77 fb			ld (debug_mark),a  
413c 3a 4b 41			ld a, (.dmark+1)  
413f 32 78 fb			ld (debug_mark+1),a  
4142 3a 4c 41			ld a, (.dmark+2)  
4145 32 79 fb			ld (debug_mark+2),a  
4148 18 03			jr .pastdmark  
414a ..			.dmark: db "TC4"  
414d f1			.pastdmark: pop af  
414e			endm  
# End of macro DMARK
414e						CALLMONITOR 
414e cd 17 16			call break_point_state  
4151				endm  
# End of macro CALLMONITOR
4151					endif 
4151					;; 
4151			 
4151 fe 20				cp ' ' 
4153 20 20				jr nz, .totsiptou 
4155 23					inc hl 
4156 7e					ld a, (hl) 
4157					if DEBUG_FORTH_WORDS 
4157						DMARK "TC5" 
4157 f5				push af  
4158 3a 6c 41			ld a, (.dmark)  
415b 32 77 fb			ld (debug_mark),a  
415e 3a 6d 41			ld a, (.dmark+1)  
4161 32 78 fb			ld (debug_mark+1),a  
4164 3a 6e 41			ld a, (.dmark+2)  
4167 32 79 fb			ld (debug_mark+2),a  
416a 18 03			jr .pastdmark  
416c ..			.dmark: db "TC5"  
416f f1			.pastdmark: pop af  
4170			endm  
# End of macro DMARK
4170						CALLMONITOR 
4170 cd 17 16			call break_point_state  
4173				endm  
# End of macro CALLMONITOR
4173					endif 
4173 18 c0				jr .totsp 
4175 fe 00		.totsiptou:    cp 0 
4177 28 40				jr z, .totdone 
4179					; not space and not zero term so upper case it 
4179 cd 38 10				call to_upper 
417c			 
417c					if DEBUG_FORTH_WORDS 
417c						DMARK "TC6" 
417c f5				push af  
417d 3a 91 41			ld a, (.dmark)  
4180 32 77 fb			ld (debug_mark),a  
4183 3a 92 41			ld a, (.dmark+1)  
4186 32 78 fb			ld (debug_mark+1),a  
4189 3a 93 41			ld a, (.dmark+2)  
418c 32 79 fb			ld (debug_mark+2),a  
418f 18 03			jr .pastdmark  
4191 ..			.dmark: db "TC6"  
4194 f1			.pastdmark: pop af  
4195			endm  
# End of macro DMARK
4195						CALLMONITOR 
4195 cd 17 16			call break_point_state  
4198				endm  
# End of macro CALLMONITOR
4198					endif 
4198			 
4198			 
4198			.totnxt: 
4198			 
4198 77					ld (hl), a 
4199 23					inc hl 
419a					if DEBUG_FORTH_WORDS 
419a						DMARK "TC7" 
419a f5				push af  
419b 3a af 41			ld a, (.dmark)  
419e 32 77 fb			ld (debug_mark),a  
41a1 3a b0 41			ld a, (.dmark+1)  
41a4 32 78 fb			ld (debug_mark+1),a  
41a7 3a b1 41			ld a, (.dmark+2)  
41aa 32 79 fb			ld (debug_mark+2),a  
41ad 18 03			jr .pastdmark  
41af ..			.dmark: db "TC7"  
41b2 f1			.pastdmark: pop af  
41b3			endm  
# End of macro DMARK
41b3						CALLMONITOR 
41b3 cd 17 16			call break_point_state  
41b6				endm  
# End of macro CALLMONITOR
41b6					endif 
41b6 c3 ee 40				jp .tot 
41b9			 
41b9					 
41b9			 
41b9			 
41b9			; for each char convert to low 
41b9					 
41b9			.totdone: 
41b9					if DEBUG_FORTH_WORDS 
41b9						DMARK "TCd" 
41b9 f5				push af  
41ba 3a ce 41			ld a, (.dmark)  
41bd 32 77 fb			ld (debug_mark),a  
41c0 3a cf 41			ld a, (.dmark+1)  
41c3 32 78 fb			ld (debug_mark+1),a  
41c6 3a d0 41			ld a, (.dmark+2)  
41c9 32 79 fb			ld (debug_mark+2),a  
41cc 18 03			jr .pastdmark  
41ce ..			.dmark: db "TCd"  
41d1 f1			.pastdmark: pop af  
41d2			endm  
# End of macro DMARK
41d2						CALLMONITOR 
41d2 cd 17 16			call break_point_state  
41d5				endm  
# End of macro CALLMONITOR
41d5					endif 
41d5					NEXTW 
41d5 c3 0d 1f			jp macro_next 
41d8				endm 
# End of macro NEXTW
41d8			 
41d8			.SUBSTR: 
41d8				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
41d8 48				db WORD_SYS_CORE+52             
41d9 36 42			dw .LEFT            
41db 07				db 6 + 1 
41dc .. 00			db "SUBSTR",0              
41e3				endm 
# End of macro CWHEAD
41e3			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
41e3			 
41e3					if DEBUG_FORTH_WORDS_KEY 
41e3						DMARK "SST" 
41e3 f5				push af  
41e4 3a f8 41			ld a, (.dmark)  
41e7 32 77 fb			ld (debug_mark),a  
41ea 3a f9 41			ld a, (.dmark+1)  
41ed 32 78 fb			ld (debug_mark+1),a  
41f0 3a fa 41			ld a, (.dmark+2)  
41f3 32 79 fb			ld (debug_mark+2),a  
41f6 18 03			jr .pastdmark  
41f8 ..			.dmark: db "SST"  
41fb f1			.pastdmark: pop af  
41fc			endm  
# End of macro DMARK
41fc						CALLMONITOR 
41fc cd 17 16			call break_point_state  
41ff				endm  
# End of macro CALLMONITOR
41ff					endif 
41ff			; TODO check string type 
41ff					FORTH_DSP_VALUEHL 
41ff cd 9b 1d			call macro_dsp_valuehl 
4202				endm 
# End of macro FORTH_DSP_VALUEHL
4202			 
4202 e5					push hl      ; string length 
4203			 
4203					FORTH_DSP_POP 
4203 cd 53 1e			call macro_forth_dsp_pop 
4206				endm 
# End of macro FORTH_DSP_POP
4206			 
4206					FORTH_DSP_VALUEHL 
4206 cd 9b 1d			call macro_dsp_valuehl 
4209				endm 
# End of macro FORTH_DSP_VALUEHL
4209			 
4209 e5					push hl     ; start char 
420a			 
420a					FORTH_DSP_POP 
420a cd 53 1e			call macro_forth_dsp_pop 
420d				endm 
# End of macro FORTH_DSP_POP
420d			 
420d			 
420d					FORTH_DSP_VALUE 
420d cd 84 1d			call macro_forth_dsp_value 
4210				endm 
# End of macro FORTH_DSP_VALUE
4210			 
4210 d1					pop de    ; get start post offset 
4211			 
4211 19					add hl, de    ; starting offset 
4212			 
4212 c1					pop bc 
4213 c5					push bc      ; grab size of string 
4214			 
4214 e5					push hl    ; save string start  
4215			 
4215 26 00				ld h, 0 
4217 69					ld l, c 
4218 23					inc hl 
4219 23					inc hl 
421a			 
421a cd 92 11				call malloc 
421d				if DEBUG_FORTH_MALLOC_GUARD 
421d cc c8 51				call z,malloc_error 
4220				endif 
4220			 
4220 eb					ex de, hl      ; save malloc area for string copy 
4221 e1					pop hl    ; get back source 
4222 c1					pop bc    ; get length of string back 
4223			 
4223 d5					push de    ; save malloc area for after we push 
4224 ed b0				ldir     ; copy substr 
4226			 
4226			 
4226 eb					ex de, hl 
4227 3e 00				ld a, 0 
4229 77					ld (hl), a   ; term substr 
422a			 
422a					 
422a e1					pop hl    ; get malloc so we can push it 
422b e5					push hl   ; save so we can free it afterwards 
422c			 
422c cd 12 1c				call forth_push_str 
422f			 
422f e1					pop hl 
4230 cd 5c 12				call free 
4233			 
4233					 
4233					 
4233			 
4233			 
4233					NEXTW 
4233 c3 0d 1f			jp macro_next 
4236				endm 
# End of macro NEXTW
4236			 
4236			.LEFT: 
4236				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4236 48				db WORD_SYS_CORE+52             
4237 5e 42			dw .RIGHT            
4239 05				db 4 + 1 
423a .. 00			db "LEFT",0              
423f				endm 
# End of macro CWHEAD
423f			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
423f					if DEBUG_FORTH_WORDS_KEY 
423f						DMARK "LEF" 
423f f5				push af  
4240 3a 54 42			ld a, (.dmark)  
4243 32 77 fb			ld (debug_mark),a  
4246 3a 55 42			ld a, (.dmark+1)  
4249 32 78 fb			ld (debug_mark+1),a  
424c 3a 56 42			ld a, (.dmark+2)  
424f 32 79 fb			ld (debug_mark+2),a  
4252 18 03			jr .pastdmark  
4254 ..			.dmark: db "LEF"  
4257 f1			.pastdmark: pop af  
4258			endm  
# End of macro DMARK
4258						CALLMONITOR 
4258 cd 17 16			call break_point_state  
425b				endm  
# End of macro CALLMONITOR
425b					endif 
425b			 
425b					NEXTW 
425b c3 0d 1f			jp macro_next 
425e				endm 
# End of macro NEXTW
425e			.RIGHT: 
425e				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
425e 48				db WORD_SYS_CORE+52             
425f 87 42			dw .STR2NUM            
4261 06				db 5 + 1 
4262 .. 00			db "RIGHT",0              
4268				endm 
# End of macro CWHEAD
4268			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4268					if DEBUG_FORTH_WORDS_KEY 
4268						DMARK "RIG" 
4268 f5				push af  
4269 3a 7d 42			ld a, (.dmark)  
426c 32 77 fb			ld (debug_mark),a  
426f 3a 7e 42			ld a, (.dmark+1)  
4272 32 78 fb			ld (debug_mark+1),a  
4275 3a 7f 42			ld a, (.dmark+2)  
4278 32 79 fb			ld (debug_mark+2),a  
427b 18 03			jr .pastdmark  
427d ..			.dmark: db "RIG"  
4280 f1			.pastdmark: pop af  
4281			endm  
# End of macro DMARK
4281						CALLMONITOR 
4281 cd 17 16			call break_point_state  
4284				endm  
# End of macro CALLMONITOR
4284					endif 
4284			 
4284					NEXTW 
4284 c3 0d 1f			jp macro_next 
4287				endm 
# End of macro NEXTW
4287			 
4287			 
4287			.STR2NUM: 
4287				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4287 48				db WORD_SYS_CORE+52             
4288 13 43			dw .NUM2STR            
428a 08				db 7 + 1 
428b .. 00			db "STR2NUM",0              
4293				endm 
# End of macro CWHEAD
4293			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4293			 
4293			 
4293			; TODO STR type check to do 
4293					if DEBUG_FORTH_WORDS_KEY 
4293						DMARK "S2N" 
4293 f5				push af  
4294 3a a8 42			ld a, (.dmark)  
4297 32 77 fb			ld (debug_mark),a  
429a 3a a9 42			ld a, (.dmark+1)  
429d 32 78 fb			ld (debug_mark+1),a  
42a0 3a aa 42			ld a, (.dmark+2)  
42a3 32 79 fb			ld (debug_mark+2),a  
42a6 18 03			jr .pastdmark  
42a8 ..			.dmark: db "S2N"  
42ab f1			.pastdmark: pop af  
42ac			endm  
# End of macro DMARK
42ac						CALLMONITOR 
42ac cd 17 16			call break_point_state  
42af				endm  
# End of macro CALLMONITOR
42af					endif 
42af			 
42af					;FORTH_DSP 
42af					FORTH_DSP_VALUE 
42af cd 84 1d			call macro_forth_dsp_value 
42b2				endm 
# End of macro FORTH_DSP_VALUE
42b2					;inc hl 
42b2			 
42b2 eb					ex de, hl 
42b3					if DEBUG_FORTH_WORDS 
42b3						DMARK "S2a" 
42b3 f5				push af  
42b4 3a c8 42			ld a, (.dmark)  
42b7 32 77 fb			ld (debug_mark),a  
42ba 3a c9 42			ld a, (.dmark+1)  
42bd 32 78 fb			ld (debug_mark+1),a  
42c0 3a ca 42			ld a, (.dmark+2)  
42c3 32 79 fb			ld (debug_mark+2),a  
42c6 18 03			jr .pastdmark  
42c8 ..			.dmark: db "S2a"  
42cb f1			.pastdmark: pop af  
42cc			endm  
# End of macro DMARK
42cc						CALLMONITOR 
42cc cd 17 16			call break_point_state  
42cf				endm  
# End of macro CALLMONITOR
42cf					endif 
42cf cd c0 10				call string_to_uint16 
42d2			 
42d2					if DEBUG_FORTH_WORDS 
42d2						DMARK "S2b" 
42d2 f5				push af  
42d3 3a e7 42			ld a, (.dmark)  
42d6 32 77 fb			ld (debug_mark),a  
42d9 3a e8 42			ld a, (.dmark+1)  
42dc 32 78 fb			ld (debug_mark+1),a  
42df 3a e9 42			ld a, (.dmark+2)  
42e2 32 79 fb			ld (debug_mark+2),a  
42e5 18 03			jr .pastdmark  
42e7 ..			.dmark: db "S2b"  
42ea f1			.pastdmark: pop af  
42eb			endm  
# End of macro DMARK
42eb						CALLMONITOR 
42eb cd 17 16			call break_point_state  
42ee				endm  
# End of macro CALLMONITOR
42ee					endif 
42ee			;		push hl 
42ee					FORTH_DSP_POP 
42ee cd 53 1e			call macro_forth_dsp_pop 
42f1				endm 
# End of macro FORTH_DSP_POP
42f1			;		pop hl 
42f1					 
42f1					if DEBUG_FORTH_WORDS 
42f1						DMARK "S2b" 
42f1 f5				push af  
42f2 3a 06 43			ld a, (.dmark)  
42f5 32 77 fb			ld (debug_mark),a  
42f8 3a 07 43			ld a, (.dmark+1)  
42fb 32 78 fb			ld (debug_mark+1),a  
42fe 3a 08 43			ld a, (.dmark+2)  
4301 32 79 fb			ld (debug_mark+2),a  
4304 18 03			jr .pastdmark  
4306 ..			.dmark: db "S2b"  
4309 f1			.pastdmark: pop af  
430a			endm  
# End of macro DMARK
430a						CALLMONITOR 
430a cd 17 16			call break_point_state  
430d				endm  
# End of macro CALLMONITOR
430d					endif 
430d cd a4 1b				call forth_push_numhl	 
4310			 
4310				 
4310				       NEXTW 
4310 c3 0d 1f			jp macro_next 
4313				endm 
# End of macro NEXTW
4313			.NUM2STR: 
4313				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4313 48				db WORD_SYS_CORE+52             
4314 22 43			dw .CONCAT            
4316 08				db 7 + 1 
4317 .. 00			db "NUM2STR",0              
431f				endm 
# End of macro CWHEAD
431f			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
431f			 
431f			;		; malloc a string to target 
431f			;		ld hl, 10     ; TODO max string size should be fine 
431f			;		call malloc 
431f			;		push hl    ; save malloc location 
431f			; 
431f			; 
431f			;; TODO check int type 
431f			;		FORTH_DSP_VALUEHL 
431f			;		ld a, l 
431f			;		call DispAToASCII   
431f			;;TODO need to chage above call to dump into string 
431f			; 
431f			; 
431f			 
431f				       NEXTW 
431f c3 0d 1f			jp macro_next 
4322				endm 
# End of macro NEXTW
4322			 
4322			.CONCAT: 
4322				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4322 48				db WORD_SYS_CORE+52             
4323 d5 43			dw .FIND            
4325 07				db 6 + 1 
4326 .. 00			db "CONCAT",0              
432d				endm 
# End of macro CWHEAD
432d			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
432d			 
432d			; TODO check string type 
432d			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
432d			 
432d					if DEBUG_FORTH_WORDS_KEY 
432d						DMARK "CON" 
432d f5				push af  
432e 3a 42 43			ld a, (.dmark)  
4331 32 77 fb			ld (debug_mark),a  
4334 3a 43 43			ld a, (.dmark+1)  
4337 32 78 fb			ld (debug_mark+1),a  
433a 3a 44 43			ld a, (.dmark+2)  
433d 32 79 fb			ld (debug_mark+2),a  
4340 18 03			jr .pastdmark  
4342 ..			.dmark: db "CON"  
4345 f1			.pastdmark: pop af  
4346			endm  
# End of macro DMARK
4346						CALLMONITOR 
4346 cd 17 16			call break_point_state  
4349				endm  
# End of macro CALLMONITOR
4349					endif 
4349			 
4349			 
4349					FORTH_DSP_VALUE 
4349 cd 84 1d			call macro_forth_dsp_value 
434c				endm 
# End of macro FORTH_DSP_VALUE
434c e5					push hl   ; s2 
434d			 
434d					FORTH_DSP_POP 
434d cd 53 1e			call macro_forth_dsp_pop 
4350				endm 
# End of macro FORTH_DSP_POP
4350			 
4350					FORTH_DSP_VALUE 
4350 cd 84 1d			call macro_forth_dsp_value 
4353				endm 
# End of macro FORTH_DSP_VALUE
4353			 
4353 e5					push hl   ; s1 
4354			 
4354					FORTH_DSP_POP 
4354 cd 53 1e			call macro_forth_dsp_pop 
4357				endm 
# End of macro FORTH_DSP_POP
4357					 
4357			 
4357					; copy s1 
4357			 
4357				 
4357					; save ptr 
4357 e1					pop hl  
4358 e5					push hl 
4359 3e 00				ld a, 0 
435b cd 34 11				call strlent 
435e					;inc hl    ; zer0 
435e 06 00				ld b, 0 
4360 4d					ld c, l 
4361 e1					pop hl		 
4362 11 31 ee				ld de, scratch	 
4365					if DEBUG_FORTH_WORDS 
4365						DMARK "CO1" 
4365 f5				push af  
4366 3a 7a 43			ld a, (.dmark)  
4369 32 77 fb			ld (debug_mark),a  
436c 3a 7b 43			ld a, (.dmark+1)  
436f 32 78 fb			ld (debug_mark+1),a  
4372 3a 7c 43			ld a, (.dmark+2)  
4375 32 79 fb			ld (debug_mark+2),a  
4378 18 03			jr .pastdmark  
437a ..			.dmark: db "CO1"  
437d f1			.pastdmark: pop af  
437e			endm  
# End of macro DMARK
437e						CALLMONITOR 
437e cd 17 16			call break_point_state  
4381				endm  
# End of macro CALLMONITOR
4381					endif 
4381 ed b0				ldir 
4383			 
4383 e1					pop hl 
4384 e5					push hl 
4385 d5					push de 
4386			 
4386			 
4386 3e 00				ld a, 0 
4388 cd 34 11				call strlent 
438b 23					inc hl    ; zer0 
438c 23					inc hl 
438d 06 00				ld b, 0 
438f 4d					ld c, l 
4390 d1					pop de 
4391 e1					pop hl		 
4392					if DEBUG_FORTH_WORDS 
4392						DMARK "CO2" 
4392 f5				push af  
4393 3a a7 43			ld a, (.dmark)  
4396 32 77 fb			ld (debug_mark),a  
4399 3a a8 43			ld a, (.dmark+1)  
439c 32 78 fb			ld (debug_mark+1),a  
439f 3a a9 43			ld a, (.dmark+2)  
43a2 32 79 fb			ld (debug_mark+2),a  
43a5 18 03			jr .pastdmark  
43a7 ..			.dmark: db "CO2"  
43aa f1			.pastdmark: pop af  
43ab			endm  
# End of macro DMARK
43ab						CALLMONITOR 
43ab cd 17 16			call break_point_state  
43ae				endm  
# End of macro CALLMONITOR
43ae					endif 
43ae ed b0				ldir 
43b0			 
43b0			 
43b0			 
43b0 21 31 ee				ld hl, scratch 
43b3					if DEBUG_FORTH_WORDS 
43b3						DMARK "CO5" 
43b3 f5				push af  
43b4 3a c8 43			ld a, (.dmark)  
43b7 32 77 fb			ld (debug_mark),a  
43ba 3a c9 43			ld a, (.dmark+1)  
43bd 32 78 fb			ld (debug_mark+1),a  
43c0 3a ca 43			ld a, (.dmark+2)  
43c3 32 79 fb			ld (debug_mark+2),a  
43c6 18 03			jr .pastdmark  
43c8 ..			.dmark: db "CO5"  
43cb f1			.pastdmark: pop af  
43cc			endm  
# End of macro DMARK
43cc						CALLMONITOR 
43cc cd 17 16			call break_point_state  
43cf				endm  
# End of macro CALLMONITOR
43cf					endif 
43cf			 
43cf cd 12 1c				call forth_push_str 
43d2			 
43d2			 
43d2			 
43d2			 
43d2				       NEXTW 
43d2 c3 0d 1f			jp macro_next 
43d5				endm 
# End of macro NEXTW
43d5			 
43d5			 
43d5			.FIND: 
43d5				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
43d5 4b				db WORD_SYS_CORE+55             
43d6 93 44			dw .LEN            
43d8 05				db 4 + 1 
43d9 .. 00			db "FIND",0              
43de				endm 
# End of macro CWHEAD
43de			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
43de			 
43de					if DEBUG_FORTH_WORDS_KEY 
43de						DMARK "FND" 
43de f5				push af  
43df 3a f3 43			ld a, (.dmark)  
43e2 32 77 fb			ld (debug_mark),a  
43e5 3a f4 43			ld a, (.dmark+1)  
43e8 32 78 fb			ld (debug_mark+1),a  
43eb 3a f5 43			ld a, (.dmark+2)  
43ee 32 79 fb			ld (debug_mark+2),a  
43f1 18 03			jr .pastdmark  
43f3 ..			.dmark: db "FND"  
43f6 f1			.pastdmark: pop af  
43f7			endm  
# End of macro DMARK
43f7						CALLMONITOR 
43f7 cd 17 16			call break_point_state  
43fa				endm  
# End of macro CALLMONITOR
43fa					endif 
43fa			 
43fa			; TODO check string type 
43fa					FORTH_DSP_VALUE 
43fa cd 84 1d			call macro_forth_dsp_value 
43fd				endm 
# End of macro FORTH_DSP_VALUE
43fd			 
43fd e5					push hl    
43fe 7e					ld a,(hl)    ; char to find   
43ff			; TODO change char to substr 
43ff			 
43ff f5					push af 
4400					 
4400			 
4400			 
4400					if DEBUG_FORTH_WORDS 
4400						DMARK "FN1" 
4400 f5				push af  
4401 3a 15 44			ld a, (.dmark)  
4404 32 77 fb			ld (debug_mark),a  
4407 3a 16 44			ld a, (.dmark+1)  
440a 32 78 fb			ld (debug_mark+1),a  
440d 3a 17 44			ld a, (.dmark+2)  
4410 32 79 fb			ld (debug_mark+2),a  
4413 18 03			jr .pastdmark  
4415 ..			.dmark: db "FN1"  
4418 f1			.pastdmark: pop af  
4419			endm  
# End of macro DMARK
4419						CALLMONITOR 
4419 cd 17 16			call break_point_state  
441c				endm  
# End of macro CALLMONITOR
441c					endif 
441c			 
441c					FORTH_DSP_POP 
441c cd 53 1e			call macro_forth_dsp_pop 
441f				endm 
# End of macro FORTH_DSP_POP
441f			 
441f					; string to search 
441f			 
441f					FORTH_DSP_VALUE 
441f cd 84 1d			call macro_forth_dsp_value 
4422				endm 
# End of macro FORTH_DSP_VALUE
4422			 
4422 d1					pop de  ; d is char to find  
4423			 
4423					if DEBUG_FORTH_WORDS 
4423						DMARK "FN2" 
4423 f5				push af  
4424 3a 38 44			ld a, (.dmark)  
4427 32 77 fb			ld (debug_mark),a  
442a 3a 39 44			ld a, (.dmark+1)  
442d 32 78 fb			ld (debug_mark+1),a  
4430 3a 3a 44			ld a, (.dmark+2)  
4433 32 79 fb			ld (debug_mark+2),a  
4436 18 03			jr .pastdmark  
4438 ..			.dmark: db "FN2"  
443b f1			.pastdmark: pop af  
443c			endm  
# End of macro DMARK
443c						CALLMONITOR 
443c cd 17 16			call break_point_state  
443f				endm  
# End of macro CALLMONITOR
443f					endif 
443f					 
443f 01 00 00				ld bc, 0 
4442 7e			.findchar:      ld a,(hl) 
4443 fe 00				cp 0   		 
4445 28 27				jr z, .finddone     
4447 ba					cp d 
4448 28 20				jr z, .foundchar 
444a 03					inc bc 
444b 23					inc hl 
444c					if DEBUG_FORTH_WORDS 
444c						DMARK "FN3" 
444c f5				push af  
444d 3a 61 44			ld a, (.dmark)  
4450 32 77 fb			ld (debug_mark),a  
4453 3a 62 44			ld a, (.dmark+1)  
4456 32 78 fb			ld (debug_mark+1),a  
4459 3a 63 44			ld a, (.dmark+2)  
445c 32 79 fb			ld (debug_mark+2),a  
445f 18 03			jr .pastdmark  
4461 ..			.dmark: db "FN3"  
4464 f1			.pastdmark: pop af  
4465			endm  
# End of macro DMARK
4465						CALLMONITOR 
4465 cd 17 16			call break_point_state  
4468				endm  
# End of macro CALLMONITOR
4468					endif 
4468 18 d8				jr .findchar 
446a			 
446a			 
446a c5			.foundchar:	push bc 
446b e1					pop hl 
446c 18 03				jr .findexit 
446e			 
446e			 
446e							 
446e			 
446e			.finddone:     ; got to end of string with no find 
446e 21 00 00				ld hl, 0 
4471			.findexit: 
4471			 
4471					if DEBUG_FORTH_WORDS 
4471						DMARK "FNd" 
4471 f5				push af  
4472 3a 86 44			ld a, (.dmark)  
4475 32 77 fb			ld (debug_mark),a  
4478 3a 87 44			ld a, (.dmark+1)  
447b 32 78 fb			ld (debug_mark+1),a  
447e 3a 88 44			ld a, (.dmark+2)  
4481 32 79 fb			ld (debug_mark+2),a  
4484 18 03			jr .pastdmark  
4486 ..			.dmark: db "FNd"  
4489 f1			.pastdmark: pop af  
448a			endm  
# End of macro DMARK
448a						CALLMONITOR 
448a cd 17 16			call break_point_state  
448d				endm  
# End of macro CALLMONITOR
448d					endif 
448d cd a4 1b			call forth_push_numhl 
4490			 
4490				       NEXTW 
4490 c3 0d 1f			jp macro_next 
4493				endm 
# End of macro NEXTW
4493			 
4493			.LEN: 
4493				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4493 4c				db WORD_SYS_CORE+56             
4494 c8 44			dw .CHAR            
4496 06				db 5 + 1 
4497 .. 00			db "COUNT",0              
449d				endm 
# End of macro CWHEAD
449d			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
449d			 
449d					if DEBUG_FORTH_WORDS_KEY 
449d						DMARK "CNT" 
449d f5				push af  
449e 3a b2 44			ld a, (.dmark)  
44a1 32 77 fb			ld (debug_mark),a  
44a4 3a b3 44			ld a, (.dmark+1)  
44a7 32 78 fb			ld (debug_mark+1),a  
44aa 3a b4 44			ld a, (.dmark+2)  
44ad 32 79 fb			ld (debug_mark+2),a  
44b0 18 03			jr .pastdmark  
44b2 ..			.dmark: db "CNT"  
44b5 f1			.pastdmark: pop af  
44b6			endm  
# End of macro DMARK
44b6						CALLMONITOR 
44b6 cd 17 16			call break_point_state  
44b9				endm  
# End of macro CALLMONITOR
44b9					endif 
44b9			; TODO check string type 
44b9					FORTH_DSP 
44b9 cd 61 1d			call macro_forth_dsp 
44bc				endm 
# End of macro FORTH_DSP
44bc					;v5FORTH_DSP_VALUE 
44bc			 
44bc 23					inc hl 
44bd			 
44bd 3e 00				ld a, 0 
44bf cd 34 11				call strlent 
44c2			 
44c2 cd a4 1b				call forth_push_numhl 
44c5			 
44c5			 
44c5			 
44c5				       NEXTW 
44c5 c3 0d 1f			jp macro_next 
44c8				endm 
# End of macro NEXTW
44c8			.CHAR: 
44c8				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
44c8 4d				db WORD_SYS_CORE+57             
44c9 fe 44			dw .ENDSTR            
44cb 05				db 4 + 1 
44cc .. 00			db "CHAR",0              
44d1				endm 
# End of macro CWHEAD
44d1			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
44d1					if DEBUG_FORTH_WORDS_KEY 
44d1						DMARK "CHR" 
44d1 f5				push af  
44d2 3a e6 44			ld a, (.dmark)  
44d5 32 77 fb			ld (debug_mark),a  
44d8 3a e7 44			ld a, (.dmark+1)  
44db 32 78 fb			ld (debug_mark+1),a  
44de 3a e8 44			ld a, (.dmark+2)  
44e1 32 79 fb			ld (debug_mark+2),a  
44e4 18 03			jr .pastdmark  
44e6 ..			.dmark: db "CHR"  
44e9 f1			.pastdmark: pop af  
44ea			endm  
# End of macro DMARK
44ea						CALLMONITOR 
44ea cd 17 16			call break_point_state  
44ed				endm  
# End of macro CALLMONITOR
44ed					endif 
44ed					FORTH_DSP 
44ed cd 61 1d			call macro_forth_dsp 
44f0				endm 
# End of macro FORTH_DSP
44f0					;v5 FORTH_DSP_VALUE 
44f0 23					inc hl      ; now at start of numeric as string 
44f1			 
44f1			;		push hl 
44f1			 
44f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44f1 cd 53 1e			call macro_forth_dsp_pop 
44f4				endm 
# End of macro FORTH_DSP_POP
44f4			 
44f4			;		pop hl 
44f4			 
44f4					; push the content of a onto the stack as a value 
44f4			 
44f4 7e					ld a,(hl)   ; get char 
44f5 26 00				ld h,0 
44f7 6f					ld l,a 
44f8 cd a4 1b				call forth_push_numhl 
44fb			 
44fb				       NEXTW 
44fb c3 0d 1f			jp macro_next 
44fe				endm 
# End of macro NEXTW
44fe			 
44fe			 
44fe			 
44fe			 
44fe			.ENDSTR: 
44fe			; eof 
44fe			 
# End of file forth_words_str.asm
44fe			include "forth_words_key.asm" 
44fe			 
44fe			; | ## Keyboard Words 
44fe			 
44fe			.KEY: 
44fe				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
44fe 3e				db WORD_SYS_CORE+42             
44ff 2e 45			dw .WAITK            
4501 04				db 3 + 1 
4502 .. 00			db "KEY",0              
4506				endm 
# End of macro CWHEAD
4506			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4506			 
4506					if DEBUG_FORTH_WORDS_KEY 
4506						DMARK "KEY" 
4506 f5				push af  
4507 3a 1b 45			ld a, (.dmark)  
450a 32 77 fb			ld (debug_mark),a  
450d 3a 1c 45			ld a, (.dmark+1)  
4510 32 78 fb			ld (debug_mark+1),a  
4513 3a 1d 45			ld a, (.dmark+2)  
4516 32 79 fb			ld (debug_mark+2),a  
4519 18 03			jr .pastdmark  
451b ..			.dmark: db "KEY"  
451e f1			.pastdmark: pop af  
451f			endm  
# End of macro DMARK
451f						CALLMONITOR 
451f cd 17 16			call break_point_state  
4522				endm  
# End of macro CALLMONITOR
4522					endif 
4522			; TODO currently waits 
4522 cd d2 67				call cin 
4525					;call cin_wait 
4525 6f					ld l, a 
4526 26 00				ld h, 0 
4528 cd a4 1b				call forth_push_numhl 
452b					NEXTW 
452b c3 0d 1f			jp macro_next 
452e				endm 
# End of macro NEXTW
452e			.WAITK: 
452e				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
452e 3f				db WORD_SYS_CORE+43             
452f 60 45			dw .ACCEPT            
4531 06				db 5 + 1 
4532 .. 00			db "WAITK",0              
4538				endm 
# End of macro CWHEAD
4538			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4538					if DEBUG_FORTH_WORDS_KEY 
4538						DMARK "WAI" 
4538 f5				push af  
4539 3a 4d 45			ld a, (.dmark)  
453c 32 77 fb			ld (debug_mark),a  
453f 3a 4e 45			ld a, (.dmark+1)  
4542 32 78 fb			ld (debug_mark+1),a  
4545 3a 4f 45			ld a, (.dmark+2)  
4548 32 79 fb			ld (debug_mark+2),a  
454b 18 03			jr .pastdmark  
454d ..			.dmark: db "WAI"  
4550 f1			.pastdmark: pop af  
4551			endm  
# End of macro DMARK
4551						CALLMONITOR 
4551 cd 17 16			call break_point_state  
4554				endm  
# End of macro CALLMONITOR
4554					endif 
4554 cd c1 67				call cin_wait 
4557 6f					ld l, a 
4558 26 00				ld h, 0 
455a cd a4 1b				call forth_push_numhl 
455d					NEXTW 
455d c3 0d 1f			jp macro_next 
4560				endm 
# End of macro NEXTW
4560			.ACCEPT: 
4560				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4560 40				db WORD_SYS_CORE+44             
4561 be 45			dw .EDIT            
4563 07				db 6 + 1 
4564 .. 00			db "ACCEPT",0              
456b				endm 
# End of macro CWHEAD
456b			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
456b					; TODO crashes on push 
456b					if DEBUG_FORTH_WORDS_KEY 
456b						DMARK "ACC" 
456b f5				push af  
456c 3a 80 45			ld a, (.dmark)  
456f 32 77 fb			ld (debug_mark),a  
4572 3a 81 45			ld a, (.dmark+1)  
4575 32 78 fb			ld (debug_mark+1),a  
4578 3a 82 45			ld a, (.dmark+2)  
457b 32 79 fb			ld (debug_mark+2),a  
457e 18 03			jr .pastdmark  
4580 ..			.dmark: db "ACC"  
4583 f1			.pastdmark: pop af  
4584			endm  
# End of macro DMARK
4584						CALLMONITOR 
4584 cd 17 16			call break_point_state  
4587				endm  
# End of macro CALLMONITOR
4587					endif 
4587 21 2f f0				ld hl, os_input 
458a 3e 00				ld a, 0 
458c 77					ld (hl),a 
458d 3a 5a f8				ld a,(f_cursor_ptr) 
4590 16 64				ld d, 100 
4592 0e 00				ld c, 0 
4594 1e 28				ld e, 40 
4596 cd f8 0c				call input_str 
4599					; TODO perhaps do a type check and wrap in quotes if not a number 
4599 21 2f f0				ld hl, os_input 
459c					if DEBUG_FORTH_WORDS 
459c						DMARK "AC1" 
459c f5				push af  
459d 3a b1 45			ld a, (.dmark)  
45a0 32 77 fb			ld (debug_mark),a  
45a3 3a b2 45			ld a, (.dmark+1)  
45a6 32 78 fb			ld (debug_mark+1),a  
45a9 3a b3 45			ld a, (.dmark+2)  
45ac 32 79 fb			ld (debug_mark+2),a  
45af 18 03			jr .pastdmark  
45b1 ..			.dmark: db "AC1"  
45b4 f1			.pastdmark: pop af  
45b5			endm  
# End of macro DMARK
45b5						CALLMONITOR 
45b5 cd 17 16			call break_point_state  
45b8				endm  
# End of macro CALLMONITOR
45b8					endif 
45b8 cd 12 1c				call forth_push_str 
45bb					NEXTW 
45bb c3 0d 1f			jp macro_next 
45be				endm 
# End of macro NEXTW
45be			 
45be			.EDIT: 
45be				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
45be 40				db WORD_SYS_CORE+44             
45bf 47 46			dw .ENDKEY            
45c1 05				db 4 + 1 
45c2 .. 00			db "EDIT",0              
45c7				endm 
# End of macro CWHEAD
45c7			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
45c7			 
45c7					; TODO does not copy from stack 
45c7					if DEBUG_FORTH_WORDS_KEY 
45c7						DMARK "EDT" 
45c7 f5				push af  
45c8 3a dc 45			ld a, (.dmark)  
45cb 32 77 fb			ld (debug_mark),a  
45ce 3a dd 45			ld a, (.dmark+1)  
45d1 32 78 fb			ld (debug_mark+1),a  
45d4 3a de 45			ld a, (.dmark+2)  
45d7 32 79 fb			ld (debug_mark+2),a  
45da 18 03			jr .pastdmark  
45dc ..			.dmark: db "EDT"  
45df f1			.pastdmark: pop af  
45e0			endm  
# End of macro DMARK
45e0						CALLMONITOR 
45e0 cd 17 16			call break_point_state  
45e3				endm  
# End of macro CALLMONITOR
45e3					endif 
45e3			 
45e3					FORTH_DSP 
45e3 cd 61 1d			call macro_forth_dsp 
45e6				endm 
# End of macro FORTH_DSP
45e6					;v5 FORTH_DSP_VALUE 
45e6 23					inc hl    ; TODO do type check 
45e7			 
45e7 e5					push hl 
45e8 3e 00				ld a, 0 
45ea cd 34 11				call strlent 
45ed 23					inc hl 
45ee			 
45ee 06 00				ld b, 0 
45f0 4d					ld c, l 
45f1			 
45f1 e1					pop hl 
45f2 11 2f f0				ld de, os_input 
45f5					if DEBUG_FORTH_WORDS_KEY 
45f5						DMARK "EDc" 
45f5 f5				push af  
45f6 3a 0a 46			ld a, (.dmark)  
45f9 32 77 fb			ld (debug_mark),a  
45fc 3a 0b 46			ld a, (.dmark+1)  
45ff 32 78 fb			ld (debug_mark+1),a  
4602 3a 0c 46			ld a, (.dmark+2)  
4605 32 79 fb			ld (debug_mark+2),a  
4608 18 03			jr .pastdmark  
460a ..			.dmark: db "EDc"  
460d f1			.pastdmark: pop af  
460e			endm  
# End of macro DMARK
460e						CALLMONITOR 
460e cd 17 16			call break_point_state  
4611				endm  
# End of macro CALLMONITOR
4611					endif 
4611 ed b0				ldir 
4613			 
4613			 
4613 21 2f f0				ld hl, os_input 
4616					;ld a, 0 
4616					;ld (hl),a 
4616 3a 5a f8				ld a,(f_cursor_ptr) 
4619 16 64				ld d, 100 
461b 0e 00				ld c, 0 
461d 1e 28				ld e, 40 
461f cd f8 0c				call input_str 
4622					; TODO perhaps do a type check and wrap in quotes if not a number 
4622 21 2f f0				ld hl, os_input 
4625					if DEBUG_FORTH_WORDS 
4625						DMARK "ED1" 
4625 f5				push af  
4626 3a 3a 46			ld a, (.dmark)  
4629 32 77 fb			ld (debug_mark),a  
462c 3a 3b 46			ld a, (.dmark+1)  
462f 32 78 fb			ld (debug_mark+1),a  
4632 3a 3c 46			ld a, (.dmark+2)  
4635 32 79 fb			ld (debug_mark+2),a  
4638 18 03			jr .pastdmark  
463a ..			.dmark: db "ED1"  
463d f1			.pastdmark: pop af  
463e			endm  
# End of macro DMARK
463e						CALLMONITOR 
463e cd 17 16			call break_point_state  
4641				endm  
# End of macro CALLMONITOR
4641					endif 
4641 cd 12 1c				call forth_push_str 
4644					NEXTW 
4644 c3 0d 1f			jp macro_next 
4647				endm 
# End of macro NEXTW
4647			 
4647			 
4647			 
4647			.ENDKEY: 
4647			; eof 
4647			 
# End of file forth_words_key.asm
4647			 
4647			if STORAGE_SE 
4647			   	include "forth_words_storage.asm" 
4647			 
4647			; | ## Fixed Storage Words 
4647			 
4647			 
4647			.BREAD: 
4647			  
4647				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4647 3a				db WORD_SYS_CORE+38             
4648 c0 46			dw .BWRITE            
464a 06				db 5 + 1 
464b .. 00			db "BREAD",0              
4651				endm 
# End of macro CWHEAD
4651			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4651				 
4651					if DEBUG_FORTH_WORDS_KEY 
4651						DMARK "BRD" 
4651 f5				push af  
4652 3a 66 46			ld a, (.dmark)  
4655 32 77 fb			ld (debug_mark),a  
4658 3a 67 46			ld a, (.dmark+1)  
465b 32 78 fb			ld (debug_mark+1),a  
465e 3a 68 46			ld a, (.dmark+2)  
4661 32 79 fb			ld (debug_mark+2),a  
4664 18 03			jr .pastdmark  
4666 ..			.dmark: db "BRD"  
4669 f1			.pastdmark: pop af  
466a			endm  
# End of macro DMARK
466a						CALLMONITOR 
466a cd 17 16			call break_point_state  
466d				endm  
# End of macro CALLMONITOR
466d					endif 
466d			 
466d				FORTH_DSP_VALUEHL 
466d cd 9b 1d			call macro_dsp_valuehl 
4670				endm 
# End of macro FORTH_DSP_VALUEHL
4670			 
4670				FORTH_DSP_POP 
4670 cd 53 1e			call macro_forth_dsp_pop 
4673				endm 
# End of macro FORTH_DSP_POP
4673			 
4673				; calc block address 
4673			 
4673 eb				ex de, hl 
4674 3e 40			ld a, STORE_BLOCK_PHY 
4676 cd 4e 0c			call Mult16 
4679			 
4679			 
4679 11 62 f8			ld de, store_page 
467c			 
467c					if DEBUG_FORTH_WORDS 
467c						DMARK "BR1" 
467c f5				push af  
467d 3a 91 46			ld a, (.dmark)  
4680 32 77 fb			ld (debug_mark),a  
4683 3a 92 46			ld a, (.dmark+1)  
4686 32 78 fb			ld (debug_mark+1),a  
4689 3a 93 46			ld a, (.dmark+2)  
468c 32 79 fb			ld (debug_mark+2),a  
468f 18 03			jr .pastdmark  
4691 ..			.dmark: db "BR1"  
4694 f1			.pastdmark: pop af  
4695			endm  
# End of macro DMARK
4695						CALLMONITOR 
4695 cd 17 16			call break_point_state  
4698				endm  
# End of macro CALLMONITOR
4698					endif 
4698			 
4698 cd 0c 03			call storage_read_block 
469b			 
469b 21 64 f8		        ld hl, store_page+2 
469e					if DEBUG_FORTH_WORDS 
469e						DMARK "BR2" 
469e f5				push af  
469f 3a b3 46			ld a, (.dmark)  
46a2 32 77 fb			ld (debug_mark),a  
46a5 3a b4 46			ld a, (.dmark+1)  
46a8 32 78 fb			ld (debug_mark+1),a  
46ab 3a b5 46			ld a, (.dmark+2)  
46ae 32 79 fb			ld (debug_mark+2),a  
46b1 18 03			jr .pastdmark  
46b3 ..			.dmark: db "BR2"  
46b6 f1			.pastdmark: pop af  
46b7			endm  
# End of macro DMARK
46b7						CALLMONITOR 
46b7 cd 17 16			call break_point_state  
46ba				endm  
# End of macro CALLMONITOR
46ba					endif 
46ba cd 12 1c			call forth_push_str 
46bd			 
46bd			 
46bd					NEXTW 
46bd c3 0d 1f			jp macro_next 
46c0				endm 
# End of macro NEXTW
46c0			.BWRITE: 
46c0				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
46c0 3a				db WORD_SYS_CORE+38             
46c1 55 47			dw .BUPD            
46c3 07				db 6 + 1 
46c4 .. 00			db "BWRITE",0              
46cb				endm 
# End of macro CWHEAD
46cb			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
46cb			 
46cb					if DEBUG_FORTH_WORDS_KEY 
46cb						DMARK "BWR" 
46cb f5				push af  
46cc 3a e0 46			ld a, (.dmark)  
46cf 32 77 fb			ld (debug_mark),a  
46d2 3a e1 46			ld a, (.dmark+1)  
46d5 32 78 fb			ld (debug_mark+1),a  
46d8 3a e2 46			ld a, (.dmark+2)  
46db 32 79 fb			ld (debug_mark+2),a  
46de 18 03			jr .pastdmark  
46e0 ..			.dmark: db "BWR"  
46e3 f1			.pastdmark: pop af  
46e4			endm  
# End of macro DMARK
46e4						CALLMONITOR 
46e4 cd 17 16			call break_point_state  
46e7				endm  
# End of macro CALLMONITOR
46e7					endif 
46e7			 
46e7				FORTH_DSP_VALUEHL 
46e7 cd 9b 1d			call macro_dsp_valuehl 
46ea				endm 
# End of macro FORTH_DSP_VALUEHL
46ea			 
46ea				; calc block address 
46ea			 
46ea eb				ex de, hl 
46eb 3e 40			ld a, STORE_BLOCK_PHY 
46ed cd 4e 0c			call Mult16 
46f0			 
46f0 e5				push hl         ; address 
46f1			 
46f1				FORTH_DSP_POP 
46f1 cd 53 1e			call macro_forth_dsp_pop 
46f4				endm 
# End of macro FORTH_DSP_POP
46f4			 
46f4				FORTH_DSP_VALUEHL 
46f4 cd 9b 1d			call macro_dsp_valuehl 
46f7				endm 
# End of macro FORTH_DSP_VALUEHL
46f7			 
46f7				FORTH_DSP_POP 
46f7 cd 53 1e			call macro_forth_dsp_pop 
46fa				endm 
# End of macro FORTH_DSP_POP
46fa			 
46fa cd 15 0a			call storage_clear_page 
46fd			 
46fd				; copy string to store page 
46fd			 
46fd e5				push hl     ; save string address 
46fe			 
46fe 3e 00			ld a, 0 
4700 cd 34 11			call strlent 
4703			 
4703 23				inc hl 
4704			 
4704 4d				ld c, l 
4705 06 00			ld b, 0 
4707			 
4707 e1				pop hl 
4708 11 64 f8			ld de, store_page + 2 
470b					if DEBUG_FORTH_WORDS 
470b						DMARK "BW1" 
470b f5				push af  
470c 3a 20 47			ld a, (.dmark)  
470f 32 77 fb			ld (debug_mark),a  
4712 3a 21 47			ld a, (.dmark+1)  
4715 32 78 fb			ld (debug_mark+1),a  
4718 3a 22 47			ld a, (.dmark+2)  
471b 32 79 fb			ld (debug_mark+2),a  
471e 18 03			jr .pastdmark  
4720 ..			.dmark: db "BW1"  
4723 f1			.pastdmark: pop af  
4724			endm  
# End of macro DMARK
4724						CALLMONITOR 
4724 cd 17 16			call break_point_state  
4727				endm  
# End of macro CALLMONITOR
4727					endif 
4727 ed b0			ldir 
4729			 
4729			 
4729				; poke the start of the block with flags to prevent high level file ops hitting the block 
4729			 
4729 21 ff ff			ld hl, $ffff 
472c			 
472c 22 62 f8			ld (store_page), hl	 
472f				 
472f e1				pop hl    ; get address 
4730 11 62 f8			ld de, store_page 
4733			 
4733					if DEBUG_FORTH_WORDS 
4733						DMARK "BW2" 
4733 f5				push af  
4734 3a 48 47			ld a, (.dmark)  
4737 32 77 fb			ld (debug_mark),a  
473a 3a 49 47			ld a, (.dmark+1)  
473d 32 78 fb			ld (debug_mark+1),a  
4740 3a 4a 47			ld a, (.dmark+2)  
4743 32 79 fb			ld (debug_mark+2),a  
4746 18 03			jr .pastdmark  
4748 ..			.dmark: db "BW2"  
474b f1			.pastdmark: pop af  
474c			endm  
# End of macro DMARK
474c						CALLMONITOR 
474c cd 17 16			call break_point_state  
474f				endm  
# End of macro CALLMONITOR
474f					endif 
474f			 
474f cd 71 03			call storage_write_block 
4752			 
4752					NEXTW 
4752 c3 0d 1f			jp macro_next 
4755				endm 
# End of macro NEXTW
4755			 
4755			.BUPD: 
4755				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4755 3a				db WORD_SYS_CORE+38             
4756 ab 47			dw .BYID            
4758 05				db 4 + 1 
4759 .. 00			db "BUPD",0              
475e				endm 
# End of macro CWHEAD
475e			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
475e			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
475e			; | | or completely different file system structure. 
475e			 
475e					if DEBUG_FORTH_WORDS_KEY 
475e						DMARK "BUD" 
475e f5				push af  
475f 3a 73 47			ld a, (.dmark)  
4762 32 77 fb			ld (debug_mark),a  
4765 3a 74 47			ld a, (.dmark+1)  
4768 32 78 fb			ld (debug_mark+1),a  
476b 3a 75 47			ld a, (.dmark+2)  
476e 32 79 fb			ld (debug_mark+2),a  
4771 18 03			jr .pastdmark  
4773 ..			.dmark: db "BUD"  
4776 f1			.pastdmark: pop af  
4777			endm  
# End of macro DMARK
4777						CALLMONITOR 
4777 cd 17 16			call break_point_state  
477a				endm  
# End of macro CALLMONITOR
477a					endif 
477a			 
477a				FORTH_DSP_VALUEHL 
477a cd 9b 1d			call macro_dsp_valuehl 
477d				endm 
# End of macro FORTH_DSP_VALUEHL
477d			 
477d				; calc block address 
477d			 
477d eb				ex de, hl 
477e 3e 40			ld a, STORE_BLOCK_PHY 
4780 cd 4e 0c			call Mult16 
4783			 
4783				FORTH_DSP_POP 
4783 cd 53 1e			call macro_forth_dsp_pop 
4786				endm 
# End of macro FORTH_DSP_POP
4786			 
4786			 
4786 11 62 f8			ld de, store_page 
4789			 
4789					if DEBUG_FORTH_WORDS 
4789						DMARK "BUe" 
4789 f5				push af  
478a 3a 9e 47			ld a, (.dmark)  
478d 32 77 fb			ld (debug_mark),a  
4790 3a 9f 47			ld a, (.dmark+1)  
4793 32 78 fb			ld (debug_mark+1),a  
4796 3a a0 47			ld a, (.dmark+2)  
4799 32 79 fb			ld (debug_mark+2),a  
479c 18 03			jr .pastdmark  
479e ..			.dmark: db "BUe"  
47a1 f1			.pastdmark: pop af  
47a2			endm  
# End of macro DMARK
47a2						CALLMONITOR 
47a2 cd 17 16			call break_point_state  
47a5				endm  
# End of macro CALLMONITOR
47a5					endif 
47a5			 
47a5 cd 71 03			call storage_write_block 
47a8			 
47a8					NEXTW 
47a8 c3 0d 1f			jp macro_next 
47ab				endm 
# End of macro NEXTW
47ab			 
47ab			.BYID: 
47ab			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
47ab			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
47ab			; 
47ab			;		 
47ab			;		if DEBUG_FORTH_WORDS_KEY 
47ab			;			DMARK "BYID" 
47ab			;			CALLMONITOR 
47ab			;		endif 
47ab			; 
47ab			;		; get direct address 
47ab			; 
47ab			;		FORTH_DSP_VALUEHL 
47ab			; 
47ab			;		FORTH_DSP_POP 
47ab			; 
47ab			;	; calc block address 
47ab			; 
47ab			;	ex de, hl 
47ab			;	ld a, STORE_BLOCK_PHY 
47ab			;	call Mult16 
47ab			;	;	do BREAD with number as param 
47ab			;	; push the file name	 
47ab			;	ld de, store_page 
47ab			;	call storage_read_block 
47ab			 ;       ld hl, store_page+2 
47ab			; 
47ab			; 
47ab			;		NEXTW 
47ab			;.BYNAME: 
47ab			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
47ab			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
47ab			;		NEXTW 
47ab			; 
47ab			.DIR: 
47ab				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
47ab 3a				db WORD_SYS_CORE+38             
47ac af 48			dw .SAVE            
47ae 04				db 3 + 1 
47af .. 00			db "DIR",0              
47b3				endm 
# End of macro CWHEAD
47b3			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
47b3			 
47b3					if DEBUG_FORTH_WORDS_KEY 
47b3						DMARK "DIR" 
47b3 f5				push af  
47b4 3a c8 47			ld a, (.dmark)  
47b7 32 77 fb			ld (debug_mark),a  
47ba 3a c9 47			ld a, (.dmark+1)  
47bd 32 78 fb			ld (debug_mark+1),a  
47c0 3a ca 47			ld a, (.dmark+2)  
47c3 32 79 fb			ld (debug_mark+2),a  
47c6 18 03			jr .pastdmark  
47c8 ..			.dmark: db "DIR"  
47cb f1			.pastdmark: pop af  
47cc			endm  
# End of macro DMARK
47cc						CALLMONITOR 
47cc cd 17 16			call break_point_state  
47cf				endm  
# End of macro CALLMONITOR
47cf					endif 
47cf cd bd 03			call storage_get_block_0 
47d2			 
47d2 21 62 f8			ld hl, store_page     ; get current id count 
47d5 46				ld b, (hl) 
47d6 0e 00			ld c, 0    ; count of files   
47d8					if DEBUG_FORTH_WORDS 
47d8						DMARK "DI1" 
47d8 f5				push af  
47d9 3a ed 47			ld a, (.dmark)  
47dc 32 77 fb			ld (debug_mark),a  
47df 3a ee 47			ld a, (.dmark+1)  
47e2 32 78 fb			ld (debug_mark+1),a  
47e5 3a ef 47			ld a, (.dmark+2)  
47e8 32 79 fb			ld (debug_mark+2),a  
47eb 18 03			jr .pastdmark  
47ed ..			.dmark: db "DI1"  
47f0 f1			.pastdmark: pop af  
47f1			endm  
# End of macro DMARK
47f1						CALLMONITOR 
47f1 cd 17 16			call break_point_state  
47f4				endm  
# End of macro CALLMONITOR
47f4					endif 
47f4			 
47f4				; check for empty drive 
47f4			 
47f4 3e 00			ld a, 0 
47f6 b8				cp b 
47f7 ca 65 48			jp z, .dirdone 
47fa			 
47fa				; for each of the current ids do a search for them and if found push to stack 
47fa			 
47fa c5			.diritem:	push bc 
47fb 21 40 00				ld hl, STORE_BLOCK_PHY 
47fe 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4800 58					ld e,b 
4801			 
4801			;		if DEBUG_FORTH_WORDS 
4801			;			DMARK "DI2" 
4801			;			CALLMONITOR 
4801			;		endif 
4801			 
4801 cd 2a 06				call storage_findnextid 
4804			 
4804			;		if DEBUG_FORTH_WORDS 
4804			;			DMARK "DI3" 
4804			;			CALLMONITOR 
4804			;		endif 
4804			 
4804					; if found hl will be non zero 
4804			 
4804 cd f4 0c				call ishlzero 
4807			;		ld a, l 
4807			;		add h 
4807			; 
4807			;		cp 0 
4807 28 59				jr z, .dirnotfound 
4809			 
4809					; increase count 
4809			 
4809 c1					pop bc	 
480a 0c					inc c 
480b c5					push bc 
480c					 
480c			 
480c					; get file header and push the file name 
480c			 
480c 11 62 f8				ld de, store_page 
480f cd 0c 03				call storage_read_block 
4812			 
4812					; push file id to stack 
4812				 
4812 3a 62 f8				ld a, (store_page) 
4815 26 00				ld h, 0 
4817 6f					ld l, a 
4818 cd a4 1b				call forth_push_numhl 
481b			 
481b					; push extent count to stack  
481b				 
481b 3a 64 f8				ld a, (store_page+2) 
481e 26 00				ld h, 0 
4820 6f					ld l, a 
4821 cd a4 1b				call forth_push_numhl 
4824			 
4824					; push file name 
4824			 
4824 21 65 f8				ld hl, store_page+3 
4827					if DEBUG_FORTH_WORDS 
4827						DMARK "DI5" 
4827 f5				push af  
4828 3a 3c 48			ld a, (.dmark)  
482b 32 77 fb			ld (debug_mark),a  
482e 3a 3d 48			ld a, (.dmark+1)  
4831 32 78 fb			ld (debug_mark+1),a  
4834 3a 3e 48			ld a, (.dmark+2)  
4837 32 79 fb			ld (debug_mark+2),a  
483a 18 03			jr .pastdmark  
483c ..			.dmark: db "DI5"  
483f f1			.pastdmark: pop af  
4840			endm  
# End of macro DMARK
4840						CALLMONITOR 
4840 cd 17 16			call break_point_state  
4843				endm  
# End of macro CALLMONITOR
4843					endif 
4843 cd 12 1c				call forth_push_str 
4846					if DEBUG_FORTH_WORDS 
4846						DMARK "DI6" 
4846 f5				push af  
4847 3a 5b 48			ld a, (.dmark)  
484a 32 77 fb			ld (debug_mark),a  
484d 3a 5c 48			ld a, (.dmark+1)  
4850 32 78 fb			ld (debug_mark+1),a  
4853 3a 5d 48			ld a, (.dmark+2)  
4856 32 79 fb			ld (debug_mark+2),a  
4859 18 03			jr .pastdmark  
485b ..			.dmark: db "DI6"  
485e f1			.pastdmark: pop af  
485f			endm  
# End of macro DMARK
485f						CALLMONITOR 
485f cd 17 16			call break_point_state  
4862				endm  
# End of macro CALLMONITOR
4862					endif 
4862			.dirnotfound: 
4862 c1					pop bc     
4863 10 95				djnz .diritem 
4865				 
4865			.dirdone:	 
4865					if DEBUG_FORTH_WORDS 
4865						DMARK "DI7" 
4865 f5				push af  
4866 3a 7a 48			ld a, (.dmark)  
4869 32 77 fb			ld (debug_mark),a  
486c 3a 7b 48			ld a, (.dmark+1)  
486f 32 78 fb			ld (debug_mark+1),a  
4872 3a 7c 48			ld a, (.dmark+2)  
4875 32 79 fb			ld (debug_mark+2),a  
4878 18 03			jr .pastdmark  
487a ..			.dmark: db "DI7"  
487d f1			.pastdmark: pop af  
487e			endm  
# End of macro DMARK
487e						CALLMONITOR 
487e cd 17 16			call break_point_state  
4881				endm  
# End of macro CALLMONITOR
4881					endif 
4881			 
4881					; push a count of the dir items found 
4881			 
4881 26 00				ld h, 0 
4883 69					ld l, c 
4884 cd a4 1b				call forth_push_numhl 
4887			 
4887					; push the bank label 
4887			 
4887 cd bd 03				call storage_get_block_0 
488a			 
488a				 
488a 21 65 f8		 		ld hl, store_page+3 
488d			 
488d					if DEBUG_FORTH_WORDS 
488d						DMARK "DI8" 
488d f5				push af  
488e 3a a2 48			ld a, (.dmark)  
4891 32 77 fb			ld (debug_mark),a  
4894 3a a3 48			ld a, (.dmark+1)  
4897 32 78 fb			ld (debug_mark+1),a  
489a 3a a4 48			ld a, (.dmark+2)  
489d 32 79 fb			ld (debug_mark+2),a  
48a0 18 03			jr .pastdmark  
48a2 ..			.dmark: db "DI8"  
48a5 f1			.pastdmark: pop af  
48a6			endm  
# End of macro DMARK
48a6						CALLMONITOR 
48a6 cd 17 16			call break_point_state  
48a9				endm  
# End of macro CALLMONITOR
48a9					endif 
48a9 cd 12 1c				call forth_push_str 
48ac			 
48ac			 
48ac				 
48ac					NEXTW 
48ac c3 0d 1f			jp macro_next 
48af				endm 
# End of macro NEXTW
48af			.SAVE: 
48af			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
48af			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
48af			;		NEXTW 
48af			;.LOAD: 
48af			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
48af			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
48af			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
48af			;; > > The LOAD command can not be used in any user words or compound lines. 
48af			; 
48af			;		; store_openext use it. If zero it is EOF 
48af			; 
48af			;		; read block from current stream id 
48af			;		; if the block does not contain zero term keep reading blocks until zero found 
48af			;		; push the block to stack 
48af			;		; save the block id to stream 
48af			; 
48af			; 
48af			;		FORTH_DSP_VALUEHL 
48af			; 
48af			;;		push hl 
48af			; 
48af			;	if DEBUG_STORESE 
48af			;		DMARK "LOA" 
48af			;		CALLMONITOR 
48af			;	endif 
48af			;		FORTH_DSP_POP 
48af			; 
48af			;;		pop hl 
48af			; 
48af			;		ld h, l 
48af			;		ld l, 0 
48af			; 
48af			;		push hl     ; stack holds current file id and extent to work with 
48af			; 
48af			; 
48af			;		ld de, store_page      ; get block zero of file 
48af			;	if DEBUG_STORESE 
48af			;		DMARK "LO0" 
48af			;		CALLMONITOR 
48af			;	endif 
48af			;		call storage_read 
48af			; 
48af			;		ld a, (store_page+2)    ; max extents for this file 
48af			;		ld  (store_openmaxext),a   ; get our limit 
48af			; 
48af			;	if DEBUG_STORESE 
48af			;		DMARK "LOE" 
48af			;		CALLMONITOR 
48af			;	endif 
48af			; 
48af			;; TODO dont know why max extents are not present 
48af			;;		cp 0 
48af			;;		jp z, .loadeof     ; dont read past eof 
48af			; 
48af			;;		ld a, 1   ; start from the head of the file 
48af			; 
48af			;.loadline:	pop hl 
48af			;		inc hl 
48af			;		ld  a, (store_openmaxext)   ; get our limit 
48af			;	if DEBUG_STORESE 
48af			;		DMARK "LOx" 
48af			;		CALLMONITOR 
48af			;	endif 
48af			;		inc a 
48af			;		cp l 
48af			;		jp z, .loadeof 
48af			;		push hl    ; save current extent 
48af			; 
48af			;		ld de, store_page 
48af			; 
48af			;	if DEBUG_STORESE 
48af			;		DMARK "LO1" 
48af			;		CALLMONITOR 
48af			;	endif 
48af			;		call storage_read 
48af			; 
48af			;	if DEBUG_STORESE 
48af			;		DMARK "LO2" 
48af			;		CALLMONITOR 
48af			;	endif 
48af			;	call ishlzero 
48af			;	ld a, l 
48af			;	add h 
48af			;	cp 0 
48af			;	jr z, .loadeof 
48af			; 
48af			;	; not eof so hl should point to data to exec 
48af			; 
48af			;	; will need to add the FORTH_END_BUFFER flag 
48af			 ; 
48af			;	ld hl, store_page+2 
48af			;	ld bc, 255 
48af			;	ld a, 0 
48af			;	cpir 
48af			;	if DEBUG_STORESE 
48af			;		DMARK "LOt" 
48af			;		CALLMONITOR 
48af			;	endif 
48af			;	dec hl 
48af			;	ld a, ' ' 
48af			;	ld (hl), a 
48af			;	inc hl 
48af			;	ld (hl), a 
48af			;	inc hl 
48af			;	ld (hl), a 
48af			;	inc hl 
48af			;	ld a, FORTH_END_BUFFER 
48af			;	ld (hl), a 
48af			; 
48af			;	; TODO handle more than a single block read 
48af			; 
48af			; 
48af			;	ld hl, store_page+2 
48af			; 
48af			;	ld (os_tok_ptr), hl 
48af			; 
48af			;	if DEBUG_STORESE 
48af			;		DMARK "LO3" 
48af			;		CALLMONITOR 
48af			;	endif 
48af			; 
48af			;	call forthparse 
48af			;	call forthexec 
48af			;	call forthexec_cleanup 
48af			; 
48af			;	; go to next extent 
48af			; 
48af			;	; get next block  or mark as eof 
48af			;	jp .loadline 
48af			; 
48af			; 
48af			; 
48af			;	       NEXTW 
48af			;.loadeof:	ld a, 0 
48af			;		ld (store_openext), a 
48af			; 
48af			;	if DEBUG_STORESE 
48af			;		DMARK "LOF" 
48af			;		CALLMONITOR 
48af			;	endif 
48af			;		ret 
48af			;		;NEXTW 
48af			;.BSAVE:   
48af			; 
48af			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
48af			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
48af			;		NEXTW 
48af			;.BLOAD: 
48af			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
48af			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
48af			;		NEXTW 
48af			;;;; counter gap 
48af			 
48af			 
48af			.SEO: 
48af				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
48af 64				db WORD_SYS_CORE+80             
48b0 ce 48			dw .SEI            
48b2 04				db 3 + 1 
48b3 .. 00			db "SEO",0              
48b7				endm 
# End of macro CWHEAD
48b7			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
48b7			 
48b7					; get port 
48b7			 
48b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48b7 cd 9b 1d			call macro_dsp_valuehl 
48ba				endm 
# End of macro FORTH_DSP_VALUEHL
48ba			 
48ba e5					push hl    ; u2 - byte 
48bb			 
48bb					; destroy value TOS 
48bb			 
48bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48bb cd 53 1e			call macro_forth_dsp_pop 
48be				endm 
# End of macro FORTH_DSP_POP
48be			 
48be					; get byte to send 
48be			 
48be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48be cd 9b 1d			call macro_dsp_valuehl 
48c1				endm 
# End of macro FORTH_DSP_VALUEHL
48c1			 
48c1 e5					push hl    ; u1 - addr 
48c2			 
48c2					; destroy value TOS 
48c2			 
48c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48c2 cd 53 1e			call macro_forth_dsp_pop 
48c5				endm 
# End of macro FORTH_DSP_POP
48c5			 
48c5					; one value on hl get other one back 
48c5			 
48c5 d1					pop de   ; u1 - byte 
48c6			 
48c6 e1					pop hl   ; u2 - addr 
48c7			 
48c7					; TODO Send SPI byte 
48c7			 
48c7			 
48c7 7b					ld a, e 
48c8 cd ea 01				call se_writebyte 
48cb			 
48cb					 
48cb			 
48cb					NEXTW 
48cb c3 0d 1f			jp macro_next 
48ce				endm 
# End of macro NEXTW
48ce			 
48ce			.SEI: 
48ce				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
48ce 65				db WORD_SYS_CORE+81             
48cf e8 48			dw .SFREE            
48d1 04				db 3 + 1 
48d2 .. 00			db "SEI",0              
48d6				endm 
# End of macro CWHEAD
48d6			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
48d6			 
48d6					; get port 
48d6			 
48d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48d6 cd 9b 1d			call macro_dsp_valuehl 
48d9				endm 
# End of macro FORTH_DSP_VALUEHL
48d9			 
48d9			;		push hl 
48d9			 
48d9					; destroy value TOS 
48d9			 
48d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48d9 cd 53 1e			call macro_forth_dsp_pop 
48dc				endm 
# End of macro FORTH_DSP_POP
48dc			 
48dc					; one value on hl get other one back 
48dc			 
48dc			;		pop hl 
48dc			 
48dc			 
48dc					; TODO Get SPI byte 
48dc			 
48dc cd 8c 02				call se_readbyte 
48df			 
48df 26 00				ld h, 0 
48e1 6f					ld l, a 
48e2 cd a4 1b				call forth_push_numhl 
48e5			 
48e5					NEXTW 
48e5 c3 0d 1f			jp macro_next 
48e8				endm 
# End of macro NEXTW
48e8			 
48e8			.SFREE: 
48e8				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
48e8 67				db WORD_SYS_CORE+83             
48e9 17 49			dw .SIZE            
48eb 06				db 5 + 1 
48ec .. 00			db "FFREE",0              
48f2				endm 
# End of macro CWHEAD
48f2			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
48f2					if DEBUG_FORTH_WORDS_KEY 
48f2						DMARK "FFR" 
48f2 f5				push af  
48f3 3a 07 49			ld a, (.dmark)  
48f6 32 77 fb			ld (debug_mark),a  
48f9 3a 08 49			ld a, (.dmark+1)  
48fc 32 78 fb			ld (debug_mark+1),a  
48ff 3a 09 49			ld a, (.dmark+2)  
4902 32 79 fb			ld (debug_mark+2),a  
4905 18 03			jr .pastdmark  
4907 ..			.dmark: db "FFR"  
490a f1			.pastdmark: pop af  
490b			endm  
# End of macro DMARK
490b						CALLMONITOR 
490b cd 17 16			call break_point_state  
490e				endm  
# End of macro CALLMONITOR
490e					endif 
490e			 
490e cd c4 06				call storage_freeblocks 
4911			 
4911 cd a4 1b				call forth_push_numhl 
4914			 
4914				       NEXTW 
4914 c3 0d 1f			jp macro_next 
4917				endm 
# End of macro NEXTW
4917			.SIZE: 
4917				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4917 67				db WORD_SYS_CORE+83             
4918 4b 49			dw .CREATE            
491a 05				db 4 + 1 
491b .. 00			db "SIZE",0              
4920				endm 
# End of macro CWHEAD
4920			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4920					if DEBUG_FORTH_WORDS_KEY 
4920						DMARK "SIZ" 
4920 f5				push af  
4921 3a 35 49			ld a, (.dmark)  
4924 32 77 fb			ld (debug_mark),a  
4927 3a 36 49			ld a, (.dmark+1)  
492a 32 78 fb			ld (debug_mark+1),a  
492d 3a 37 49			ld a, (.dmark+2)  
4930 32 79 fb			ld (debug_mark+2),a  
4933 18 03			jr .pastdmark  
4935 ..			.dmark: db "SIZ"  
4938 f1			.pastdmark: pop af  
4939			endm  
# End of macro DMARK
4939						CALLMONITOR 
4939 cd 17 16			call break_point_state  
493c				endm  
# End of macro CALLMONITOR
493c					endif 
493c			 
493c					FORTH_DSP_VALUEHL 
493c cd 9b 1d			call macro_dsp_valuehl 
493f				endm 
# End of macro FORTH_DSP_VALUEHL
493f			;		push hl 
493f					FORTH_DSP_POP 
493f cd 53 1e			call macro_forth_dsp_pop 
4942				endm 
# End of macro FORTH_DSP_POP
4942			;		pop hl 
4942 cd 3b 03				call storage_file_size 
4945			 
4945 cd a4 1b				call forth_push_numhl 
4948			  
4948			 
4948				       NEXTW 
4948 c3 0d 1f			jp macro_next 
494b				endm 
# End of macro NEXTW
494b			 
494b			.CREATE: 
494b				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
494b 68				db WORD_SYS_CORE+84             
494c b9 49			dw .APPEND            
494e 07				db 6 + 1 
494f .. 00			db "CREATE",0              
4956				endm 
# End of macro CWHEAD
4956			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4956			; | | e.g.  
4956			; | | TestProgram CREATE 
4956			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4956			; | |  
4956			; | | Max file IDs are 255. 
4956			; | |  
4956					 
4956					if DEBUG_FORTH_WORDS_KEY 
4956						DMARK "CRT" 
4956 f5				push af  
4957 3a 6b 49			ld a, (.dmark)  
495a 32 77 fb			ld (debug_mark),a  
495d 3a 6c 49			ld a, (.dmark+1)  
4960 32 78 fb			ld (debug_mark+1),a  
4963 3a 6d 49			ld a, (.dmark+2)  
4966 32 79 fb			ld (debug_mark+2),a  
4969 18 03			jr .pastdmark  
496b ..			.dmark: db "CRT"  
496e f1			.pastdmark: pop af  
496f			endm  
# End of macro DMARK
496f						CALLMONITOR 
496f cd 17 16			call break_point_state  
4972				endm  
# End of macro CALLMONITOR
4972					endif 
4972			;		call storage_get_block_0 
4972			 
4972					; TODO pop hl 
4972			 
4972					;v5 FORTH_DSP_VALUE 
4972					FORTH_DSP_VALUE 
4972 cd 84 1d			call macro_forth_dsp_value 
4975				endm 
# End of macro FORTH_DSP_VALUE
4975			 
4975				if DEBUG_STORESE 
4975					DMARK "CR1" 
4975 f5				push af  
4976 3a 8a 49			ld a, (.dmark)  
4979 32 77 fb			ld (debug_mark),a  
497c 3a 8b 49			ld a, (.dmark+1)  
497f 32 78 fb			ld (debug_mark+1),a  
4982 3a 8c 49			ld a, (.dmark+2)  
4985 32 79 fb			ld (debug_mark+2),a  
4988 18 03			jr .pastdmark  
498a ..			.dmark: db "CR1"  
498d f1			.pastdmark: pop af  
498e			endm  
# End of macro DMARK
498e					CALLMONITOR 
498e cd 17 16			call break_point_state  
4991				endm  
# End of macro CALLMONITOR
4991				endif 
4991			;		push hl 
4991			;		FORTH_DSP_POP 
4991			;		pop hl 
4991			 
4991			;		inc hl   ; move past the type marker 
4991			 
4991 cd fa 06				call storage_create 
4994			 
4994				if DEBUG_STORESE 
4994					DMARK "CT1" 
4994 f5				push af  
4995 3a a9 49			ld a, (.dmark)  
4998 32 77 fb			ld (debug_mark),a  
499b 3a aa 49			ld a, (.dmark+1)  
499e 32 78 fb			ld (debug_mark+1),a  
49a1 3a ab 49			ld a, (.dmark+2)  
49a4 32 79 fb			ld (debug_mark+2),a  
49a7 18 03			jr .pastdmark  
49a9 ..			.dmark: db "CT1"  
49ac f1			.pastdmark: pop af  
49ad			endm  
# End of macro DMARK
49ad					CALLMONITOR 
49ad cd 17 16			call break_point_state  
49b0				endm  
# End of macro CALLMONITOR
49b0				endif 
49b0			;		push hl 
49b0					FORTH_DSP_POP 
49b0 cd 53 1e			call macro_forth_dsp_pop 
49b3				endm 
# End of macro FORTH_DSP_POP
49b3			;		pop hl 
49b3					; push file id to stack 
49b3 cd a4 1b				call forth_push_numhl 
49b6			 
49b6			 
49b6			 
49b6				       NEXTW 
49b6 c3 0d 1f			jp macro_next 
49b9				endm 
# End of macro NEXTW
49b9			 
49b9			.APPEND: 
49b9				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
49b9 69				db WORD_SYS_CORE+85             
49ba 4a 4a			dw .SDEL            
49bc 07				db 6 + 1 
49bd .. 00			db "APPEND",0              
49c4				endm 
# End of macro CWHEAD
49c4			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
49c4			; | | e.g. 
49c4			; | | Test CREATE      -> $01 
49c4			; | | "A string to add to file" $01 APPEND 
49c4			; | |  
49c4			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
49c4					if DEBUG_FORTH_WORDS_KEY 
49c4						DMARK "APP" 
49c4 f5				push af  
49c5 3a d9 49			ld a, (.dmark)  
49c8 32 77 fb			ld (debug_mark),a  
49cb 3a da 49			ld a, (.dmark+1)  
49ce 32 78 fb			ld (debug_mark+1),a  
49d1 3a db 49			ld a, (.dmark+2)  
49d4 32 79 fb			ld (debug_mark+2),a  
49d7 18 03			jr .pastdmark  
49d9 ..			.dmark: db "APP"  
49dc f1			.pastdmark: pop af  
49dd			endm  
# End of macro DMARK
49dd						CALLMONITOR 
49dd cd 17 16			call break_point_state  
49e0				endm  
# End of macro CALLMONITOR
49e0					endif 
49e0			 
49e0					FORTH_DSP_VALUEHL 
49e0 cd 9b 1d			call macro_dsp_valuehl 
49e3				endm 
# End of macro FORTH_DSP_VALUEHL
49e3 e5					push hl 	; save file id 
49e4			 
49e4				if DEBUG_STORESE 
49e4					DMARK "AP1" 
49e4 f5				push af  
49e5 3a f9 49			ld a, (.dmark)  
49e8 32 77 fb			ld (debug_mark),a  
49eb 3a fa 49			ld a, (.dmark+1)  
49ee 32 78 fb			ld (debug_mark+1),a  
49f1 3a fb 49			ld a, (.dmark+2)  
49f4 32 79 fb			ld (debug_mark+2),a  
49f7 18 03			jr .pastdmark  
49f9 ..			.dmark: db "AP1"  
49fc f1			.pastdmark: pop af  
49fd			endm  
# End of macro DMARK
49fd					CALLMONITOR 
49fd cd 17 16			call break_point_state  
4a00				endm  
# End of macro CALLMONITOR
4a00				endif 
4a00					FORTH_DSP_POP 
4a00 cd 53 1e			call macro_forth_dsp_pop 
4a03				endm 
# End of macro FORTH_DSP_POP
4a03			 
4a03					FORTH_DSP_VALUEHL 
4a03 cd 9b 1d			call macro_dsp_valuehl 
4a06				endm 
# End of macro FORTH_DSP_VALUEHL
4a06					;v5 FORTH_DSP_VALUE 
4a06 e5					push hl 	; save ptr to string to save 
4a07			 
4a07				if DEBUG_STORESE 
4a07					DMARK "AP1" 
4a07 f5				push af  
4a08 3a 1c 4a			ld a, (.dmark)  
4a0b 32 77 fb			ld (debug_mark),a  
4a0e 3a 1d 4a			ld a, (.dmark+1)  
4a11 32 78 fb			ld (debug_mark+1),a  
4a14 3a 1e 4a			ld a, (.dmark+2)  
4a17 32 79 fb			ld (debug_mark+2),a  
4a1a 18 03			jr .pastdmark  
4a1c ..			.dmark: db "AP1"  
4a1f f1			.pastdmark: pop af  
4a20			endm  
# End of macro DMARK
4a20					CALLMONITOR 
4a20 cd 17 16			call break_point_state  
4a23				endm  
# End of macro CALLMONITOR
4a23				endif 
4a23					FORTH_DSP_POP 
4a23 cd 53 1e			call macro_forth_dsp_pop 
4a26				endm 
# End of macro FORTH_DSP_POP
4a26			 
4a26 d1					pop de 
4a27 e1					pop hl 
4a28				if DEBUG_STORESE 
4a28					DMARK "AP2" 
4a28 f5				push af  
4a29 3a 3d 4a			ld a, (.dmark)  
4a2c 32 77 fb			ld (debug_mark),a  
4a2f 3a 3e 4a			ld a, (.dmark+1)  
4a32 32 78 fb			ld (debug_mark+1),a  
4a35 3a 3f 4a			ld a, (.dmark+2)  
4a38 32 79 fb			ld (debug_mark+2),a  
4a3b 18 03			jr .pastdmark  
4a3d ..			.dmark: db "AP2"  
4a40 f1			.pastdmark: pop af  
4a41			endm  
# End of macro DMARK
4a41					CALLMONITOR 
4a41 cd 17 16			call break_point_state  
4a44				endm  
# End of macro CALLMONITOR
4a44				endif 
4a44					;inc de ; skip var type indicator 
4a44			 
4a44					; TODO how to append numerics???? 
4a44			 
4a44 cd d4 08				call storage_append		 
4a47			 
4a47				       NEXTW 
4a47 c3 0d 1f			jp macro_next 
4a4a				endm 
# End of macro NEXTW
4a4a			.SDEL: 
4a4a				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a4a 6a				db WORD_SYS_CORE+86             
4a4b 96 4a			dw .OPEN            
4a4d 05				db 4 + 1 
4a4e .. 00			db "ERA",0              
4a52				endm 
# End of macro CWHEAD
4a52			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4a52					FORTH_DSP_VALUEHL 
4a52 cd 9b 1d			call macro_dsp_valuehl 
4a55				endm 
# End of macro FORTH_DSP_VALUEHL
4a55			;		push hl 	; save file id 
4a55			 
4a55					if DEBUG_FORTH_WORDS_KEY 
4a55						DMARK "ERA" 
4a55 f5				push af  
4a56 3a 6a 4a			ld a, (.dmark)  
4a59 32 77 fb			ld (debug_mark),a  
4a5c 3a 6b 4a			ld a, (.dmark+1)  
4a5f 32 78 fb			ld (debug_mark+1),a  
4a62 3a 6c 4a			ld a, (.dmark+2)  
4a65 32 79 fb			ld (debug_mark+2),a  
4a68 18 03			jr .pastdmark  
4a6a ..			.dmark: db "ERA"  
4a6d f1			.pastdmark: pop af  
4a6e			endm  
# End of macro DMARK
4a6e						CALLMONITOR 
4a6e cd 17 16			call break_point_state  
4a71				endm  
# End of macro CALLMONITOR
4a71					endif 
4a71				if DEBUG_STORESE 
4a71					DMARK "ER1" 
4a71 f5				push af  
4a72 3a 86 4a			ld a, (.dmark)  
4a75 32 77 fb			ld (debug_mark),a  
4a78 3a 87 4a			ld a, (.dmark+1)  
4a7b 32 78 fb			ld (debug_mark+1),a  
4a7e 3a 88 4a			ld a, (.dmark+2)  
4a81 32 79 fb			ld (debug_mark+2),a  
4a84 18 03			jr .pastdmark  
4a86 ..			.dmark: db "ER1"  
4a89 f1			.pastdmark: pop af  
4a8a			endm  
# End of macro DMARK
4a8a					CALLMONITOR 
4a8a cd 17 16			call break_point_state  
4a8d				endm  
# End of macro CALLMONITOR
4a8d				endif 
4a8d					FORTH_DSP_POP 
4a8d cd 53 1e			call macro_forth_dsp_pop 
4a90				endm 
# End of macro FORTH_DSP_POP
4a90			 
4a90			;		pop hl 
4a90			 
4a90 cd 49 05				call storage_erase 
4a93				       NEXTW 
4a93 c3 0d 1f			jp macro_next 
4a96				endm 
# End of macro NEXTW
4a96			 
4a96			.OPEN: 
4a96				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4a96 6b				db WORD_SYS_CORE+87             
4a97 1d 4b			dw .READ            
4a99 05				db 4 + 1 
4a9a .. 00			db "OPEN",0              
4a9f				endm 
# End of macro CWHEAD
4a9f			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4a9f			; | | e.g. 
4a9f			; | | $01 OPEN $01 DO $01 READ . LOOP 
4a9f			 
4a9f					if DEBUG_FORTH_WORDS_KEY 
4a9f						DMARK "OPN" 
4a9f f5				push af  
4aa0 3a b4 4a			ld a, (.dmark)  
4aa3 32 77 fb			ld (debug_mark),a  
4aa6 3a b5 4a			ld a, (.dmark+1)  
4aa9 32 78 fb			ld (debug_mark+1),a  
4aac 3a b6 4a			ld a, (.dmark+2)  
4aaf 32 79 fb			ld (debug_mark+2),a  
4ab2 18 03			jr .pastdmark  
4ab4 ..			.dmark: db "OPN"  
4ab7 f1			.pastdmark: pop af  
4ab8			endm  
# End of macro DMARK
4ab8						CALLMONITOR 
4ab8 cd 17 16			call break_point_state  
4abb				endm  
# End of macro CALLMONITOR
4abb					endif 
4abb					; TODO handle multiple file opens 
4abb			 
4abb 3e 01			       	ld a, 1 
4abd 32 59 f8				ld (store_openext), a 
4ac0			 
4ac0					; get max extents for this file 
4ac0				 
4ac0								 
4ac0					FORTH_DSP_VALUEHL 
4ac0 cd 9b 1d			call macro_dsp_valuehl 
4ac3				endm 
# End of macro FORTH_DSP_VALUEHL
4ac3			 
4ac3 65					ld h, l 
4ac4 2e 00				ld l, 0 
4ac6			 
4ac6				if DEBUG_STORESE 
4ac6					DMARK "OPN" 
4ac6 f5				push af  
4ac7 3a db 4a			ld a, (.dmark)  
4aca 32 77 fb			ld (debug_mark),a  
4acd 3a dc 4a			ld a, (.dmark+1)  
4ad0 32 78 fb			ld (debug_mark+1),a  
4ad3 3a dd 4a			ld a, (.dmark+2)  
4ad6 32 79 fb			ld (debug_mark+2),a  
4ad9 18 03			jr .pastdmark  
4adb ..			.dmark: db "OPN"  
4ade f1			.pastdmark: pop af  
4adf			endm  
# End of macro DMARK
4adf					CALLMONITOR 
4adf cd 17 16			call break_point_state  
4ae2				endm  
# End of macro CALLMONITOR
4ae2				endif 
4ae2			;		push hl 
4ae2					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4ae2 cd 53 1e			call macro_forth_dsp_pop 
4ae5				endm 
# End of macro FORTH_DSP_POP
4ae5			;		pop hl 
4ae5						 
4ae5 11 62 f8				ld de, store_page      ; get block zero of file 
4ae8 cd 4e 08				call storage_read 
4aeb			 
4aeb			 
4aeb 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4aee 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4af1					 
4af1				if DEBUG_STORESE 
4af1					DMARK "OPx" 
4af1 f5				push af  
4af2 3a 06 4b			ld a, (.dmark)  
4af5 32 77 fb			ld (debug_mark),a  
4af8 3a 07 4b			ld a, (.dmark+1)  
4afb 32 78 fb			ld (debug_mark+1),a  
4afe 3a 08 4b			ld a, (.dmark+2)  
4b01 32 79 fb			ld (debug_mark+2),a  
4b04 18 03			jr .pastdmark  
4b06 ..			.dmark: db "OPx"  
4b09 f1			.pastdmark: pop af  
4b0a			endm  
# End of macro DMARK
4b0a					CALLMONITOR 
4b0a cd 17 16			call break_point_state  
4b0d				endm  
# End of macro CALLMONITOR
4b0d				endif 
4b0d fe 00				cp 0 
4b0f 20 03				jr nz, .skipopeneof 
4b11					; have opened an empty file 
4b11					 
4b11 32 59 f8				ld (store_openext), a 
4b14			 
4b14			.skipopeneof: 
4b14			 
4b14 6f					ld l, a 
4b15 26 00				ld h, 0 
4b17 cd a4 1b				call forth_push_numhl 
4b1a			 
4b1a			 
4b1a				       NEXTW 
4b1a c3 0d 1f			jp macro_next 
4b1d				endm 
# End of macro NEXTW
4b1d			.READ: 
4b1d				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b1d 6c				db WORD_SYS_CORE+88             
4b1e 64 4c			dw .EOF            
4b20 05				db 4 + 1 
4b21 .. 00			db "READ",0              
4b26				endm 
# End of macro CWHEAD
4b26			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b26			; | | e.g. 
4b26			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b26			 
4b26					if DEBUG_FORTH_WORDS_KEY 
4b26						DMARK "REA" 
4b26 f5				push af  
4b27 3a 3b 4b			ld a, (.dmark)  
4b2a 32 77 fb			ld (debug_mark),a  
4b2d 3a 3c 4b			ld a, (.dmark+1)  
4b30 32 78 fb			ld (debug_mark+1),a  
4b33 3a 3d 4b			ld a, (.dmark+2)  
4b36 32 79 fb			ld (debug_mark+2),a  
4b39 18 03			jr .pastdmark  
4b3b ..			.dmark: db "REA"  
4b3e f1			.pastdmark: pop af  
4b3f			endm  
# End of macro DMARK
4b3f						CALLMONITOR 
4b3f cd 17 16			call break_point_state  
4b42				endm  
# End of macro CALLMONITOR
4b42					endif 
4b42					; store_openext use it. If zero it is EOF 
4b42			 
4b42					; read block from current stream id 
4b42					; if the block does not contain zero term keep reading blocks until zero found 
4b42					; push the block to stack 
4b42					; save the block id to stream 
4b42			 
4b42			 
4b42					FORTH_DSP_VALUEHL 
4b42 cd 9b 1d			call macro_dsp_valuehl 
4b45				endm 
# End of macro FORTH_DSP_VALUEHL
4b45			 
4b45			;		push hl 
4b45			 
4b45				if DEBUG_STORESE 
4b45					DMARK "REA" 
4b45 f5				push af  
4b46 3a 5a 4b			ld a, (.dmark)  
4b49 32 77 fb			ld (debug_mark),a  
4b4c 3a 5b 4b			ld a, (.dmark+1)  
4b4f 32 78 fb			ld (debug_mark+1),a  
4b52 3a 5c 4b			ld a, (.dmark+2)  
4b55 32 79 fb			ld (debug_mark+2),a  
4b58 18 03			jr .pastdmark  
4b5a ..			.dmark: db "REA"  
4b5d f1			.pastdmark: pop af  
4b5e			endm  
# End of macro DMARK
4b5e					CALLMONITOR 
4b5e cd 17 16			call break_point_state  
4b61				endm  
# End of macro CALLMONITOR
4b61				endif 
4b61					FORTH_DSP_POP 
4b61 cd 53 1e			call macro_forth_dsp_pop 
4b64				endm 
# End of macro FORTH_DSP_POP
4b64			 
4b64			;		pop hl 
4b64				 
4b64 65					ld h,l 
4b65			 
4b65 3a 59 f8				ld a, (store_openext) 
4b68 6f					ld l, a 
4b69					 
4b69 fe 00				cp 0 
4b6b ca 36 4c				jp z, .ateof     ; dont read past eof 
4b6e			 
4b6e			 
4b6e 11 62 f8				ld de, store_page 
4b71				if DEBUG_STORESE 
4b71					DMARK "RE1" 
4b71 f5				push af  
4b72 3a 86 4b			ld a, (.dmark)  
4b75 32 77 fb			ld (debug_mark),a  
4b78 3a 87 4b			ld a, (.dmark+1)  
4b7b 32 78 fb			ld (debug_mark+1),a  
4b7e 3a 88 4b			ld a, (.dmark+2)  
4b81 32 79 fb			ld (debug_mark+2),a  
4b84 18 03			jr .pastdmark  
4b86 ..			.dmark: db "RE1"  
4b89 f1			.pastdmark: pop af  
4b8a			endm  
# End of macro DMARK
4b8a					CALLMONITOR 
4b8a cd 17 16			call break_point_state  
4b8d				endm  
# End of macro CALLMONITOR
4b8d				endif 
4b8d cd 4e 08				call storage_read 
4b90			 
4b90				if DEBUG_STORESE 
4b90					DMARK "RE2" 
4b90 f5				push af  
4b91 3a a5 4b			ld a, (.dmark)  
4b94 32 77 fb			ld (debug_mark),a  
4b97 3a a6 4b			ld a, (.dmark+1)  
4b9a 32 78 fb			ld (debug_mark+1),a  
4b9d 3a a7 4b			ld a, (.dmark+2)  
4ba0 32 79 fb			ld (debug_mark+2),a  
4ba3 18 03			jr .pastdmark  
4ba5 ..			.dmark: db "RE2"  
4ba8 f1			.pastdmark: pop af  
4ba9			endm  
# End of macro DMARK
4ba9					CALLMONITOR 
4ba9 cd 17 16			call break_point_state  
4bac				endm  
# End of macro CALLMONITOR
4bac				endif 
4bac cd f4 0c			call ishlzero 
4baf			;	ld a, l 
4baf			;	add h 
4baf			;	cp 0 
4baf ca 3c 4c			jp z, .readeof 
4bb2			 
4bb2				; not eof so hl should point to data to push to stack 
4bb2			 
4bb2				if DEBUG_STORESE 
4bb2					DMARK "RE3" 
4bb2 f5				push af  
4bb3 3a c7 4b			ld a, (.dmark)  
4bb6 32 77 fb			ld (debug_mark),a  
4bb9 3a c8 4b			ld a, (.dmark+1)  
4bbc 32 78 fb			ld (debug_mark+1),a  
4bbf 3a c9 4b			ld a, (.dmark+2)  
4bc2 32 79 fb			ld (debug_mark+2),a  
4bc5 18 03			jr .pastdmark  
4bc7 ..			.dmark: db "RE3"  
4bca f1			.pastdmark: pop af  
4bcb			endm  
# End of macro DMARK
4bcb					CALLMONITOR 
4bcb cd 17 16			call break_point_state  
4bce				endm  
# End of macro CALLMONITOR
4bce				endif 
4bce cd 12 1c			call forth_push_str 
4bd1			 
4bd1				if DEBUG_STORESE 
4bd1					DMARK "RE4" 
4bd1 f5				push af  
4bd2 3a e6 4b			ld a, (.dmark)  
4bd5 32 77 fb			ld (debug_mark),a  
4bd8 3a e7 4b			ld a, (.dmark+1)  
4bdb 32 78 fb			ld (debug_mark+1),a  
4bde 3a e8 4b			ld a, (.dmark+2)  
4be1 32 79 fb			ld (debug_mark+2),a  
4be4 18 03			jr .pastdmark  
4be6 ..			.dmark: db "RE4"  
4be9 f1			.pastdmark: pop af  
4bea			endm  
# End of macro DMARK
4bea					CALLMONITOR 
4bea cd 17 16			call break_point_state  
4bed				endm  
# End of macro CALLMONITOR
4bed				endif 
4bed				; get next block  or mark as eof 
4bed			 
4bed 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4bf0 4f				ld c, a	 
4bf1 3a 59 f8			ld a, (store_openext) 
4bf4			 
4bf4				if DEBUG_STORESE 
4bf4					DMARK "RE5" 
4bf4 f5				push af  
4bf5 3a 09 4c			ld a, (.dmark)  
4bf8 32 77 fb			ld (debug_mark),a  
4bfb 3a 0a 4c			ld a, (.dmark+1)  
4bfe 32 78 fb			ld (debug_mark+1),a  
4c01 3a 0b 4c			ld a, (.dmark+2)  
4c04 32 79 fb			ld (debug_mark+2),a  
4c07 18 03			jr .pastdmark  
4c09 ..			.dmark: db "RE5"  
4c0c f1			.pastdmark: pop af  
4c0d			endm  
# End of macro DMARK
4c0d					CALLMONITOR 
4c0d cd 17 16			call break_point_state  
4c10				endm  
# End of macro CALLMONITOR
4c10				endif 
4c10 b9				cp c 
4c11 28 29			jr z, .readeof     ; at last extent 
4c13			 
4c13 3c					inc a 
4c14 32 59 f8				ld (store_openext), a 
4c17			 
4c17				if DEBUG_STORESE 
4c17					DMARK "RE6" 
4c17 f5				push af  
4c18 3a 2c 4c			ld a, (.dmark)  
4c1b 32 77 fb			ld (debug_mark),a  
4c1e 3a 2d 4c			ld a, (.dmark+1)  
4c21 32 78 fb			ld (debug_mark+1),a  
4c24 3a 2e 4c			ld a, (.dmark+2)  
4c27 32 79 fb			ld (debug_mark+2),a  
4c2a 18 03			jr .pastdmark  
4c2c ..			.dmark: db "RE6"  
4c2f f1			.pastdmark: pop af  
4c30			endm  
# End of macro DMARK
4c30					CALLMONITOR 
4c30 cd 17 16			call break_point_state  
4c33				endm  
# End of macro CALLMONITOR
4c33				endif 
4c33			 
4c33			 
4c33				       NEXTW 
4c33 c3 0d 1f			jp macro_next 
4c36				endm 
# End of macro NEXTW
4c36			.ateof: 
4c36 21 60 4c				ld hl, .showeof 
4c39 cd 12 1c				call forth_push_str 
4c3c 3e 00		.readeof:	ld a, 0 
4c3e 32 59 f8				ld (store_openext), a 
4c41			 
4c41					 
4c41				if DEBUG_STORESE 
4c41					DMARK "REF" 
4c41 f5				push af  
4c42 3a 56 4c			ld a, (.dmark)  
4c45 32 77 fb			ld (debug_mark),a  
4c48 3a 57 4c			ld a, (.dmark+1)  
4c4b 32 78 fb			ld (debug_mark+1),a  
4c4e 3a 58 4c			ld a, (.dmark+2)  
4c51 32 79 fb			ld (debug_mark+2),a  
4c54 18 03			jr .pastdmark  
4c56 ..			.dmark: db "REF"  
4c59 f1			.pastdmark: pop af  
4c5a			endm  
# End of macro DMARK
4c5a					CALLMONITOR 
4c5a cd 17 16			call break_point_state  
4c5d				endm  
# End of macro CALLMONITOR
4c5d				endif 
4c5d				       NEXTW 
4c5d c3 0d 1f			jp macro_next 
4c60				endm 
# End of macro NEXTW
4c60			 
4c60 .. 00		.showeof:   db "eof", 0 
4c64			 
4c64			 
4c64			.EOF: 
4c64				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4c64 6d				db WORD_SYS_CORE+89             
4c65 a5 4c			dw .FORMAT            
4c67 04				db 3 + 1 
4c68 .. 00			db "EOF",0              
4c6c				endm 
# End of macro CWHEAD
4c6c			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4c6c			; | | e.g. 
4c6c			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4c6c					; TODO if current block id for stream is zero then push true else false 
4c6c			 
4c6c					if DEBUG_FORTH_WORDS_KEY 
4c6c						DMARK "EOF" 
4c6c f5				push af  
4c6d 3a 81 4c			ld a, (.dmark)  
4c70 32 77 fb			ld (debug_mark),a  
4c73 3a 82 4c			ld a, (.dmark+1)  
4c76 32 78 fb			ld (debug_mark+1),a  
4c79 3a 83 4c			ld a, (.dmark+2)  
4c7c 32 79 fb			ld (debug_mark+2),a  
4c7f 18 03			jr .pastdmark  
4c81 ..			.dmark: db "EOF"  
4c84 f1			.pastdmark: pop af  
4c85			endm  
# End of macro DMARK
4c85						CALLMONITOR 
4c85 cd 17 16			call break_point_state  
4c88				endm  
# End of macro CALLMONITOR
4c88					endif 
4c88			 
4c88					; TODO handlue multiple file streams 
4c88			 
4c88					FORTH_DSP_POP     ; for now just get rid of stream id 
4c88 cd 53 1e			call macro_forth_dsp_pop 
4c8b				endm 
# End of macro FORTH_DSP_POP
4c8b			 
4c8b 2e 01				ld l, 1 
4c8d 3a 58 f8				ld a, (store_openmaxext) 
4c90 fe 00				cp 0 
4c92 28 09				jr  z, .eofdone   ; empty file 
4c94 3a 59 f8				ld a, (store_openext) 
4c97 fe 00				cp 0 
4c99 28 02				jr  z, .eofdone 
4c9b 2e 00				ld l, 0 
4c9d 26 00		.eofdone:	ld h, 0 
4c9f cd a4 1b				call forth_push_numhl 
4ca2			 
4ca2			 
4ca2				       NEXTW 
4ca2 c3 0d 1f			jp macro_next 
4ca5				endm 
# End of macro NEXTW
4ca5			 
4ca5			.FORMAT: 
4ca5				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4ca5 6d				db WORD_SYS_CORE+89             
4ca6 f6 4c			dw .LABEL            
4ca8 07				db 6 + 1 
4ca9 .. 00			db "FORMAT",0              
4cb0				endm 
# End of macro CWHEAD
4cb0			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4cb0					; TODO if current block id for stream is zero then push true else false 
4cb0				 
4cb0				if DEBUG_STORESE 
4cb0					DMARK "FOR" 
4cb0 f5				push af  
4cb1 3a c5 4c			ld a, (.dmark)  
4cb4 32 77 fb			ld (debug_mark),a  
4cb7 3a c6 4c			ld a, (.dmark+1)  
4cba 32 78 fb			ld (debug_mark+1),a  
4cbd 3a c7 4c			ld a, (.dmark+2)  
4cc0 32 79 fb			ld (debug_mark+2),a  
4cc3 18 03			jr .pastdmark  
4cc5 ..			.dmark: db "FOR"  
4cc8 f1			.pastdmark: pop af  
4cc9			endm  
# End of macro DMARK
4cc9					CALLMONITOR 
4cc9 cd 17 16			call break_point_state  
4ccc				endm  
# End of macro CALLMONITOR
4ccc				endif 
4ccc					; Wipes the bank check flags to cause a reformat on next block 0 read 
4ccc			 
4ccc 21 01 00				ld hl, 1 
4ccf 3e 00				ld a, 0 
4cd1 cd ea 01				call se_writebyte 
4cd4			 
4cd4				if DEBUG_STORESE 
4cd4					DMARK "FO0" 
4cd4 f5				push af  
4cd5 3a e9 4c			ld a, (.dmark)  
4cd8 32 77 fb			ld (debug_mark),a  
4cdb 3a ea 4c			ld a, (.dmark+1)  
4cde 32 78 fb			ld (debug_mark+1),a  
4ce1 3a eb 4c			ld a, (.dmark+2)  
4ce4 32 79 fb			ld (debug_mark+2),a  
4ce7 18 03			jr .pastdmark  
4ce9 ..			.dmark: db "FO0"  
4cec f1			.pastdmark: pop af  
4ced			endm  
# End of macro DMARK
4ced					CALLMONITOR 
4ced cd 17 16			call break_point_state  
4cf0				endm  
# End of macro CALLMONITOR
4cf0				endif 
4cf0					; force bank init 
4cf0			 
4cf0 cd bd 03				call storage_get_block_0 
4cf3					 
4cf3				       NEXTW 
4cf3 c3 0d 1f			jp macro_next 
4cf6				endm 
# End of macro NEXTW
4cf6			.LABEL: 
4cf6				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4cf6 6d				db WORD_SYS_CORE+89             
4cf7 44 4d			dw .STOREPAGE            
4cf9 06				db 5 + 1 
4cfa .. 00			db "LABEL",0              
4d00				endm 
# End of macro CWHEAD
4d00			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d00					; TODO test to see if bank is selected 
4d00				 
4d00					if DEBUG_FORTH_WORDS_KEY 
4d00						DMARK "LBL" 
4d00 f5				push af  
4d01 3a 15 4d			ld a, (.dmark)  
4d04 32 77 fb			ld (debug_mark),a  
4d07 3a 16 4d			ld a, (.dmark+1)  
4d0a 32 78 fb			ld (debug_mark+1),a  
4d0d 3a 17 4d			ld a, (.dmark+2)  
4d10 32 79 fb			ld (debug_mark+2),a  
4d13 18 03			jr .pastdmark  
4d15 ..			.dmark: db "LBL"  
4d18 f1			.pastdmark: pop af  
4d19			endm  
# End of macro DMARK
4d19						CALLMONITOR 
4d19 cd 17 16			call break_point_state  
4d1c				endm  
# End of macro CALLMONITOR
4d1c					endif 
4d1c			;	if DEBUG_STORESE 
4d1c			;		DMARK "LBL" 
4d1c			;		CALLMONITOR 
4d1c			;	endif 
4d1c					FORTH_DSP_VALUEHL 
4d1c cd 9b 1d			call macro_dsp_valuehl 
4d1f				endm 
# End of macro FORTH_DSP_VALUEHL
4d1f					;v5FORTH_DSP_VALUE 
4d1f					 
4d1f			;		push hl 
4d1f					FORTH_DSP_POP 
4d1f cd 53 1e			call macro_forth_dsp_pop 
4d22				endm 
# End of macro FORTH_DSP_POP
4d22			;		pop hl 
4d22			 
4d22			;v5		inc hl   ; move past the type marker 
4d22			 
4d22				if DEBUG_STORESE 
4d22					DMARK "LBl" 
4d22 f5				push af  
4d23 3a 37 4d			ld a, (.dmark)  
4d26 32 77 fb			ld (debug_mark),a  
4d29 3a 38 4d			ld a, (.dmark+1)  
4d2c 32 78 fb			ld (debug_mark+1),a  
4d2f 3a 39 4d			ld a, (.dmark+2)  
4d32 32 79 fb			ld (debug_mark+2),a  
4d35 18 03			jr .pastdmark  
4d37 ..			.dmark: db "LBl"  
4d3a f1			.pastdmark: pop af  
4d3b			endm  
# End of macro DMARK
4d3b					CALLMONITOR 
4d3b cd 17 16			call break_point_state  
4d3e				endm  
# End of macro CALLMONITOR
4d3e				endif 
4d3e cd de 04				call storage_label 
4d41			 
4d41				       NEXTW 
4d41 c3 0d 1f			jp macro_next 
4d44				endm 
# End of macro NEXTW
4d44			.STOREPAGE: 
4d44				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d44 6d				db WORD_SYS_CORE+89             
4d45 77 4d			dw .LABELS            
4d47 0a				db 9 + 1 
4d48 .. 00			db "STOREPAGE",0              
4d52				endm 
# End of macro CWHEAD
4d52			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4d52					; TODO test to see if bank is selected 
4d52				 
4d52					if DEBUG_FORTH_WORDS_KEY 
4d52						DMARK "STP" 
4d52 f5				push af  
4d53 3a 67 4d			ld a, (.dmark)  
4d56 32 77 fb			ld (debug_mark),a  
4d59 3a 68 4d			ld a, (.dmark+1)  
4d5c 32 78 fb			ld (debug_mark+1),a  
4d5f 3a 69 4d			ld a, (.dmark+2)  
4d62 32 79 fb			ld (debug_mark+2),a  
4d65 18 03			jr .pastdmark  
4d67 ..			.dmark: db "STP"  
4d6a f1			.pastdmark: pop af  
4d6b			endm  
# End of macro DMARK
4d6b						CALLMONITOR 
4d6b cd 17 16			call break_point_state  
4d6e				endm  
# End of macro CALLMONITOR
4d6e					endif 
4d6e			;	if DEBUG_STORESE 
4d6e			;		DMARK "STP" 
4d6e			;		CALLMONITOR 
4d6e			;	endif 
4d6e			 
4d6e 21 62 f8			ld hl, store_page 
4d71 cd a4 1b			call forth_push_numhl 
4d74			 
4d74			 
4d74				       NEXTW 
4d74 c3 0d 1f			jp macro_next 
4d77				endm 
# End of macro NEXTW
4d77			.LABELS: 
4d77				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4d77 6d				db WORD_SYS_CORE+89             
4d78 01 4e			dw .ENDSTORAGE            
4d7a 07				db 6 + 1 
4d7b .. 00			db "LABELS",0              
4d82				endm 
# End of macro CWHEAD
4d82			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4d82					;  
4d82			 
4d82					; save the current device selected to restore afterwards 
4d82				 
4d82 3a 5c f8				ld a, (spi_device) 
4d85 f5					push af 
4d86			 
4d86			 
4d86					; run through each of the banks 
4d86			 
4d86 21 01 00				ld hl, 1 
4d89 cd a4 1b				call forth_push_numhl 
4d8c 3e ff				ld a, SPI_CE_HIGH 
4d8e cb 87				res SPI_CE0, a 
4d90 32 5c f8				ld (spi_device), a 
4d93 cd bd 03				call storage_get_block_0 
4d96 21 65 f8				ld hl, store_page+3 
4d99 cd 12 1c				call forth_push_str 
4d9c			 
4d9c					 
4d9c 21 02 00				ld hl, 2 
4d9f cd a4 1b				call forth_push_numhl 
4da2 3e ff				ld a, SPI_CE_HIGH 
4da4 cb 8f				res SPI_CE1, a 
4da6 32 5c f8				ld (spi_device), a 
4da9 cd bd 03				call storage_get_block_0 
4dac 21 65 f8				ld hl, store_page+3 
4daf cd 12 1c				call forth_push_str 
4db2			 
4db2					 
4db2 21 03 00				ld hl, 3 
4db5 cd a4 1b				call forth_push_numhl 
4db8 3e ff				ld a, SPI_CE_HIGH 
4dba cb 97				res SPI_CE2, a 
4dbc 32 5c f8				ld (spi_device), a 
4dbf cd bd 03				call storage_get_block_0 
4dc2 21 65 f8				ld hl, store_page+3 
4dc5 cd 12 1c				call forth_push_str 
4dc8			 
4dc8			 
4dc8 21 04 00				ld hl, 4 
4dcb cd a4 1b				call forth_push_numhl 
4dce 3e ff				ld a, SPI_CE_HIGH 
4dd0 cb 9f				res SPI_CE3, a 
4dd2 32 5c f8				ld (spi_device), a 
4dd5 cd bd 03				call storage_get_block_0 
4dd8 21 65 f8				ld hl, store_page+3 
4ddb cd 12 1c				call forth_push_str 
4dde			 
4dde					 
4dde			 
4dde 21 05 00				ld hl, 5 
4de1 cd a4 1b				call forth_push_numhl 
4de4 3e ff				ld a, SPI_CE_HIGH 
4de6 cb a7				res SPI_CE4, a 
4de8 32 5c f8				ld (spi_device), a 
4deb cd bd 03				call storage_get_block_0 
4dee 21 65 f8				ld hl, store_page+3 
4df1 cd 12 1c				call forth_push_str 
4df4			 
4df4					 
4df4					; push fixed count of storage devices (on board) for now 
4df4			 
4df4 21 05 00				ld hl, 5 
4df7 cd a4 1b				call forth_push_numhl 
4dfa			 
4dfa					; restore selected device  
4dfa				 
4dfa f1					pop af 
4dfb 32 5c f8				ld (spi_device), a 
4dfe			 
4dfe				       NEXTW 
4dfe c3 0d 1f			jp macro_next 
4e01				endm 
# End of macro NEXTW
4e01			 
4e01			.ENDSTORAGE: 
4e01			; eof 
# End of file forth_words_storage.asm
4e01			endif 
4e01				include "forth_words_device.asm" 
4e01			; Device related words 
4e01			 
4e01			; | ## Device Words 
4e01			 
4e01			if SOUND_ENABLE 
4e01			.NOTE: 
4e01				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e01 33				db WORD_SYS_CORE+31             
4e02 29 4e			dw .AFTERSOUND            
4e04 05				db 4 + 1 
4e05 .. 00			db "NOTE",0              
4e0a				endm 
# End of macro CWHEAD
4e0a			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e0a					if DEBUG_FORTH_WORDS_KEY 
4e0a						DMARK "NTE" 
4e0a f5				push af  
4e0b 3a 1f 4e			ld a, (.dmark)  
4e0e 32 77 fb			ld (debug_mark),a  
4e11 3a 20 4e			ld a, (.dmark+1)  
4e14 32 78 fb			ld (debug_mark+1),a  
4e17 3a 21 4e			ld a, (.dmark+2)  
4e1a 32 79 fb			ld (debug_mark+2),a  
4e1d 18 03			jr .pastdmark  
4e1f ..			.dmark: db "NTE"  
4e22 f1			.pastdmark: pop af  
4e23			endm  
# End of macro DMARK
4e23						CALLMONITOR 
4e23 cd 17 16			call break_point_state  
4e26				endm  
# End of macro CALLMONITOR
4e26					endif 
4e26			 
4e26				 
4e26			 
4e26					NEXTW 
4e26 c3 0d 1f			jp macro_next 
4e29				endm 
# End of macro NEXTW
4e29			.AFTERSOUND: 
4e29			endif 
4e29			 
4e29			 
4e29			USE_GPIO: equ 0 
4e29			 
4e29			if USE_GPIO 
4e29			.GP1: 
4e29				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e29			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e29					NEXTW 
4e29			.GP2: 
4e29				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e29			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e29			 
4e29					NEXTW 
4e29			 
4e29			.GP3: 
4e29				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e29			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e29			 
4e29					NEXTW 
4e29			 
4e29			.GP4: 
4e29				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e29			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e29			 
4e29					NEXTW 
4e29			.SIN: 
4e29			 
4e29			 
4e29			endif 
4e29			 
4e29			 
4e29				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e29 33				db WORD_SYS_CORE+31             
4e2a 5e 4e			dw .SOUT            
4e2c 03				db 2 + 1 
4e2d .. 00			db "IN",0              
4e30				endm 
# End of macro CWHEAD
4e30			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e30					if DEBUG_FORTH_WORDS_KEY 
4e30						DMARK "IN." 
4e30 f5				push af  
4e31 3a 45 4e			ld a, (.dmark)  
4e34 32 77 fb			ld (debug_mark),a  
4e37 3a 46 4e			ld a, (.dmark+1)  
4e3a 32 78 fb			ld (debug_mark+1),a  
4e3d 3a 47 4e			ld a, (.dmark+2)  
4e40 32 79 fb			ld (debug_mark+2),a  
4e43 18 03			jr .pastdmark  
4e45 ..			.dmark: db "IN."  
4e48 f1			.pastdmark: pop af  
4e49			endm  
# End of macro DMARK
4e49						CALLMONITOR 
4e49 cd 17 16			call break_point_state  
4e4c				endm  
# End of macro CALLMONITOR
4e4c					endif 
4e4c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e4c cd 9b 1d			call macro_dsp_valuehl 
4e4f				endm 
# End of macro FORTH_DSP_VALUEHL
4e4f			 
4e4f e5					push hl 
4e50			 
4e50					; destroy value TOS 
4e50			 
4e50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e50 cd 53 1e			call macro_forth_dsp_pop 
4e53				endm 
# End of macro FORTH_DSP_POP
4e53			 
4e53					; one value on hl get other one back 
4e53			 
4e53 c1					pop bc 
4e54			 
4e54					; do the sub 
4e54			;		ex de, hl 
4e54			 
4e54 ed 68				in l,(c) 
4e56			 
4e56					; save it 
4e56			 
4e56 26 00				ld h,0 
4e58			 
4e58					; TODO push value back onto stack for another op etc 
4e58			 
4e58 cd a4 1b				call forth_push_numhl 
4e5b					NEXTW 
4e5b c3 0d 1f			jp macro_next 
4e5e				endm 
# End of macro NEXTW
4e5e			.SOUT: 
4e5e				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e5e 34				db WORD_SYS_CORE+32             
4e5f b1 4e			dw .SPIO            
4e61 04				db 3 + 1 
4e62 .. 00			db "OUT",0              
4e66				endm 
# End of macro CWHEAD
4e66			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e66					if DEBUG_FORTH_WORDS_KEY 
4e66						DMARK "OUT" 
4e66 f5				push af  
4e67 3a 7b 4e			ld a, (.dmark)  
4e6a 32 77 fb			ld (debug_mark),a  
4e6d 3a 7c 4e			ld a, (.dmark+1)  
4e70 32 78 fb			ld (debug_mark+1),a  
4e73 3a 7d 4e			ld a, (.dmark+2)  
4e76 32 79 fb			ld (debug_mark+2),a  
4e79 18 03			jr .pastdmark  
4e7b ..			.dmark: db "OUT"  
4e7e f1			.pastdmark: pop af  
4e7f			endm  
# End of macro DMARK
4e7f						CALLMONITOR 
4e7f cd 17 16			call break_point_state  
4e82				endm  
# End of macro CALLMONITOR
4e82					endif 
4e82			 
4e82					; get port 
4e82			 
4e82					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e82 cd 9b 1d			call macro_dsp_valuehl 
4e85				endm 
# End of macro FORTH_DSP_VALUEHL
4e85			 
4e85 e5					push hl 
4e86			 
4e86					; destroy value TOS 
4e86			 
4e86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e86 cd 53 1e			call macro_forth_dsp_pop 
4e89				endm 
# End of macro FORTH_DSP_POP
4e89			 
4e89					; get byte to send 
4e89			 
4e89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e89 cd 9b 1d			call macro_dsp_valuehl 
4e8c				endm 
# End of macro FORTH_DSP_VALUEHL
4e8c			 
4e8c			;		push hl 
4e8c			 
4e8c					; destroy value TOS 
4e8c			 
4e8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e8c cd 53 1e			call macro_forth_dsp_pop 
4e8f				endm 
# End of macro FORTH_DSP_POP
4e8f			 
4e8f					; one value on hl get other one back 
4e8f			 
4e8f			;		pop hl 
4e8f			 
4e8f c1					pop bc 
4e90			 
4e90					if DEBUG_FORTH_WORDS 
4e90						DMARK "OUT" 
4e90 f5				push af  
4e91 3a a5 4e			ld a, (.dmark)  
4e94 32 77 fb			ld (debug_mark),a  
4e97 3a a6 4e			ld a, (.dmark+1)  
4e9a 32 78 fb			ld (debug_mark+1),a  
4e9d 3a a7 4e			ld a, (.dmark+2)  
4ea0 32 79 fb			ld (debug_mark+2),a  
4ea3 18 03			jr .pastdmark  
4ea5 ..			.dmark: db "OUT"  
4ea8 f1			.pastdmark: pop af  
4ea9			endm  
# End of macro DMARK
4ea9						CALLMONITOR 
4ea9 cd 17 16			call break_point_state  
4eac				endm  
# End of macro CALLMONITOR
4eac					endif 
4eac			 
4eac ed 69				out (c), l 
4eae			 
4eae					NEXTW 
4eae c3 0d 1f			jp macro_next 
4eb1				endm 
# End of macro NEXTW
4eb1			 
4eb1			 
4eb1			.SPIO: 
4eb1			 
4eb1			if STORAGE_SE 
4eb1				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4eb1 51				db WORD_SYS_CORE+61             
4eb2 c2 4e			dw .SPICEH            
4eb4 07				db 6 + 1 
4eb5 .. 00			db "SPICEL",0              
4ebc				endm 
# End of macro CWHEAD
4ebc			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ebc			 
4ebc cd 98 01				call spi_ce_low 
4ebf			    NEXTW 
4ebf c3 0d 1f			jp macro_next 
4ec2				endm 
# End of macro NEXTW
4ec2			 
4ec2			.SPICEH: 
4ec2				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4ec2 51				db WORD_SYS_CORE+61             
4ec3 d3 4e			dw .SPIOb            
4ec5 07				db 6 + 1 
4ec6 .. 00			db "SPICEH",0              
4ecd				endm 
# End of macro CWHEAD
4ecd			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ecd			 
4ecd cd 87 01				call spi_ce_high 
4ed0			    NEXTW 
4ed0 c3 0d 1f			jp macro_next 
4ed3				endm 
# End of macro NEXTW
4ed3			 
4ed3			 
4ed3			.SPIOb: 
4ed3			 
4ed3				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4ed3 51				db WORD_SYS_CORE+61             
4ed4 e9 4e			dw .SPII            
4ed6 05				db 4 + 1 
4ed7 .. 00			db "SPIO",0              
4edc				endm 
# End of macro CWHEAD
4edc			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4edc			 
4edc					; get port 
4edc			 
4edc			 
4edc					; get byte to send 
4edc			 
4edc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4edc cd 9b 1d			call macro_dsp_valuehl 
4edf				endm 
# End of macro FORTH_DSP_VALUEHL
4edf			 
4edf			;		push hl    ; u1  
4edf			 
4edf					; destroy value TOS 
4edf			 
4edf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4edf cd 53 1e			call macro_forth_dsp_pop 
4ee2				endm 
# End of macro FORTH_DSP_POP
4ee2			 
4ee2					; one value on hl get other one back 
4ee2			 
4ee2			;		pop hl   ; u2 - addr 
4ee2			 
4ee2					; TODO Send SPI byte 
4ee2			 
4ee2 7d					ld a, l 
4ee3 cd bc 00				call spi_send_byte 
4ee6			 
4ee6					NEXTW 
4ee6 c3 0d 1f			jp macro_next 
4ee9				endm 
# End of macro NEXTW
4ee9			 
4ee9			.SPII: 
4ee9				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4ee9 52				db WORD_SYS_CORE+62             
4eea fe 4e			dw .SESEL            
4eec 06				db 5 + 1 
4eed .. 00			db "SPII",0              
4ef2				endm 
# End of macro CWHEAD
4ef2			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4ef2			 
4ef2					; TODO Get SPI byte 
4ef2			 
4ef2 cd dd 00				call spi_read_byte 
4ef5			 
4ef5 26 00				ld h, 0 
4ef7 6f					ld l, a 
4ef8 cd a4 1b				call forth_push_numhl 
4efb			 
4efb					NEXTW 
4efb c3 0d 1f			jp macro_next 
4efe				endm 
# End of macro NEXTW
4efe			 
4efe			 
4efe			 
4efe			.SESEL: 
4efe				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4efe 66				db WORD_SYS_CORE+82             
4eff a2 4f			dw .CARTDEV            
4f01 05				db 4 + 1 
4f02 .. 00			db "BANK",0              
4f07				endm 
# End of macro CWHEAD
4f07			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f07					if DEBUG_FORTH_WORDS_KEY 
4f07						DMARK "BNK" 
4f07 f5				push af  
4f08 3a 1c 4f			ld a, (.dmark)  
4f0b 32 77 fb			ld (debug_mark),a  
4f0e 3a 1d 4f			ld a, (.dmark+1)  
4f11 32 78 fb			ld (debug_mark+1),a  
4f14 3a 1e 4f			ld a, (.dmark+2)  
4f17 32 79 fb			ld (debug_mark+2),a  
4f1a 18 03			jr .pastdmark  
4f1c ..			.dmark: db "BNK"  
4f1f f1			.pastdmark: pop af  
4f20			endm  
# End of macro DMARK
4f20						CALLMONITOR 
4f20 cd 17 16			call break_point_state  
4f23				endm  
# End of macro CALLMONITOR
4f23					endif 
4f23			 
4f23 3e ff				ld a, 255 
4f25 32 5f f8				ld (spi_cartdev), a 
4f28			 
4f28					; get bank 
4f28			 
4f28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f28 cd 9b 1d			call macro_dsp_valuehl 
4f2b				endm 
# End of macro FORTH_DSP_VALUEHL
4f2b			 
4f2b			;		push hl 
4f2b			 
4f2b					; destroy value TOS 
4f2b			 
4f2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f2b cd 53 1e			call macro_forth_dsp_pop 
4f2e				endm 
# End of macro FORTH_DSP_POP
4f2e			 
4f2e					; one value on hl get other one back 
4f2e			 
4f2e			;		pop hl 
4f2e			 
4f2e			 
4f2e 0e ff				ld c, SPI_CE_HIGH 
4f30 06 30				ld b, '0'    ; human readable bank number 
4f32			 
4f32 7d					ld a, l 
4f33			 
4f33					if DEBUG_FORTH_WORDS 
4f33						DMARK "BNK" 
4f33 f5				push af  
4f34 3a 48 4f			ld a, (.dmark)  
4f37 32 77 fb			ld (debug_mark),a  
4f3a 3a 49 4f			ld a, (.dmark+1)  
4f3d 32 78 fb			ld (debug_mark+1),a  
4f40 3a 4a 4f			ld a, (.dmark+2)  
4f43 32 79 fb			ld (debug_mark+2),a  
4f46 18 03			jr .pastdmark  
4f48 ..			.dmark: db "BNK"  
4f4b f1			.pastdmark: pop af  
4f4c			endm  
# End of macro DMARK
4f4c						CALLMONITOR 
4f4c cd 17 16			call break_point_state  
4f4f				endm  
# End of macro CALLMONITOR
4f4f					endif 
4f4f			 
4f4f					; active low 
4f4f			 
4f4f fe 00				cp 0 
4f51 28 28				jr z, .bset 
4f53 fe 01				cp 1 
4f55 20 04				jr nz, .b2 
4f57 cb 81				res 0, c 
4f59 06 31				ld b, '1'    ; human readable bank number 
4f5b fe 02		.b2:		cp 2 
4f5d 20 04				jr nz, .b3 
4f5f cb 89				res 1, c 
4f61 06 32				ld b, '2'    ; human readable bank number 
4f63 fe 03		.b3:		cp 3 
4f65 20 04				jr nz, .b4 
4f67 cb 91				res 2, c 
4f69 06 33				ld b, '3'    ; human readable bank number 
4f6b fe 04		.b4:		cp 4 
4f6d 20 04				jr nz, .b5 
4f6f cb 99				res 3, c 
4f71 06 34				ld b, '4'    ; human readable bank number 
4f73 fe 05		.b5:		cp 5 
4f75 20 04				jr nz, .bset 
4f77 cb a1				res 4, c 
4f79 06 35				ld b, '5'    ; human readable bank number 
4f7b			 
4f7b			.bset: 
4f7b 79					ld a, c 
4f7c 32 5c f8				ld (spi_device),a 
4f7f 78					ld a, b 
4f80 32 5b f8				ld (spi_device_id),a 
4f83					if DEBUG_FORTH_WORDS 
4f83						DMARK "BN2" 
4f83 f5				push af  
4f84 3a 98 4f			ld a, (.dmark)  
4f87 32 77 fb			ld (debug_mark),a  
4f8a 3a 99 4f			ld a, (.dmark+1)  
4f8d 32 78 fb			ld (debug_mark+1),a  
4f90 3a 9a 4f			ld a, (.dmark+2)  
4f93 32 79 fb			ld (debug_mark+2),a  
4f96 18 03			jr .pastdmark  
4f98 ..			.dmark: db "BN2"  
4f9b f1			.pastdmark: pop af  
4f9c			endm  
# End of macro DMARK
4f9c						CALLMONITOR 
4f9c cd 17 16			call break_point_state  
4f9f				endm  
# End of macro CALLMONITOR
4f9f					endif 
4f9f			 
4f9f					NEXTW 
4f9f c3 0d 1f			jp macro_next 
4fa2				endm 
# End of macro NEXTW
4fa2			 
4fa2			.CARTDEV: 
4fa2				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4fa2 66				db WORD_SYS_CORE+82             
4fa3 4b 50			dw .ENDDEVICE            
4fa5 08				db 7 + 1 
4fa6 .. 00			db "CARTDEV",0              
4fae				endm 
# End of macro CWHEAD
4fae			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4fae					if DEBUG_FORTH_WORDS_KEY 
4fae						DMARK "CDV" 
4fae f5				push af  
4faf 3a c3 4f			ld a, (.dmark)  
4fb2 32 77 fb			ld (debug_mark),a  
4fb5 3a c4 4f			ld a, (.dmark+1)  
4fb8 32 78 fb			ld (debug_mark+1),a  
4fbb 3a c5 4f			ld a, (.dmark+2)  
4fbe 32 79 fb			ld (debug_mark+2),a  
4fc1 18 03			jr .pastdmark  
4fc3 ..			.dmark: db "CDV"  
4fc6 f1			.pastdmark: pop af  
4fc7			endm  
# End of macro DMARK
4fc7						CALLMONITOR 
4fc7 cd 17 16			call break_point_state  
4fca				endm  
# End of macro CALLMONITOR
4fca					endif 
4fca			 
4fca					; disable se storage bank selection 
4fca			 
4fca 3e ff				ld a, SPI_CE_HIGH		; ce high 
4fcc 32 5c f8				ld (spi_device), a 
4fcf			 
4fcf					; get bank 
4fcf			 
4fcf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4fcf cd 9b 1d			call macro_dsp_valuehl 
4fd2				endm 
# End of macro FORTH_DSP_VALUEHL
4fd2			 
4fd2			;		push hl 
4fd2			 
4fd2					; destroy value TOS 
4fd2			 
4fd2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4fd2 cd 53 1e			call macro_forth_dsp_pop 
4fd5				endm 
# End of macro FORTH_DSP_POP
4fd5			 
4fd5					; one value on hl get other one back 
4fd5			 
4fd5			;		pop hl 
4fd5			 
4fd5					; active low 
4fd5			 
4fd5 0e ff				ld c, 255 
4fd7			 
4fd7 7d					ld a, l 
4fd8					if DEBUG_FORTH_WORDS 
4fd8						DMARK "CDV" 
4fd8 f5				push af  
4fd9 3a ed 4f			ld a, (.dmark)  
4fdc 32 77 fb			ld (debug_mark),a  
4fdf 3a ee 4f			ld a, (.dmark+1)  
4fe2 32 78 fb			ld (debug_mark+1),a  
4fe5 3a ef 4f			ld a, (.dmark+2)  
4fe8 32 79 fb			ld (debug_mark+2),a  
4feb 18 03			jr .pastdmark  
4fed ..			.dmark: db "CDV"  
4ff0 f1			.pastdmark: pop af  
4ff1			endm  
# End of macro DMARK
4ff1						CALLMONITOR 
4ff1 cd 17 16			call break_point_state  
4ff4				endm  
# End of macro CALLMONITOR
4ff4					endif 
4ff4 fe 00				cp 0 
4ff6 28 30				jr z, .cset 
4ff8 fe 01				cp 1 
4ffa 20 02				jr nz, .c2 
4ffc cb 81				res 0, c 
4ffe fe 02		.c2:		cp 2 
5000 20 02				jr nz, .c3 
5002 cb 89				res 1, c 
5004 fe 03		.c3:		cp 3 
5006 20 02				jr nz, .c4 
5008 cb 91				res 2, c 
500a fe 04		.c4:		cp 4 
500c 20 02				jr nz, .c5 
500e cb 99				res 3, c 
5010 fe 05		.c5:		cp 5 
5012 20 02				jr nz, .c6 
5014 cb a1				res 4, c 
5016 fe 06		.c6:		cp 6 
5018 20 02				jr nz, .c7 
501a cb a9				res 5, c 
501c fe 07		.c7:		cp 7 
501e 20 02				jr nz, .c8 
5020 cb b1				res 6, c 
5022 fe 08		.c8:		cp 8 
5024 20 02				jr nz, .cset 
5026 cb b9				res 7, c 
5028 79			.cset:		ld a, c 
5029 32 5f f8				ld (spi_cartdev),a 
502c			 
502c					if DEBUG_FORTH_WORDS 
502c						DMARK "CD2" 
502c f5				push af  
502d 3a 41 50			ld a, (.dmark)  
5030 32 77 fb			ld (debug_mark),a  
5033 3a 42 50			ld a, (.dmark+1)  
5036 32 78 fb			ld (debug_mark+1),a  
5039 3a 43 50			ld a, (.dmark+2)  
503c 32 79 fb			ld (debug_mark+2),a  
503f 18 03			jr .pastdmark  
5041 ..			.dmark: db "CD2"  
5044 f1			.pastdmark: pop af  
5045			endm  
# End of macro DMARK
5045						CALLMONITOR 
5045 cd 17 16			call break_point_state  
5048				endm  
# End of macro CALLMONITOR
5048					endif 
5048					NEXTW 
5048 c3 0d 1f			jp macro_next 
504b				endm 
# End of macro NEXTW
504b			endif 
504b			 
504b			.ENDDEVICE: 
504b			; eof 
504b			 
# End of file forth_words_device.asm
504b			 
504b			; var handler 
504b			 
504b			 
504b			.VARS: 
504b				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
504b 78				db WORD_SYS_CORE+100             
504c 63 50			dw .V0Q            
504e 04				db 3 + 1 
504f .. 00			db "V0!",0              
5053				endm 
# End of macro CWHEAD
5053			;| V0! ( u1 -- )  Store value to v0  | DONE 
5053			 
5053					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5053 cd 9b 1d			call macro_dsp_valuehl 
5056				endm 
# End of macro FORTH_DSP_VALUEHL
5056			 
5056 11 24 f8				ld de, cli_var_array 
5059			 
5059 eb					ex de, hl 
505a 73					ld (hl), e 
505b 23					inc hl 
505c 72					ld (hl), d 
505d			 
505d					; destroy value TOS 
505d			 
505d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
505d cd 53 1e			call macro_forth_dsp_pop 
5060				endm 
# End of macro FORTH_DSP_POP
5060			 
5060				       NEXTW 
5060 c3 0d 1f			jp macro_next 
5063				endm 
# End of macro NEXTW
5063			.V0Q: 
5063				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5063 79				db WORD_SYS_CORE+101             
5064 74 50			dw .V1S            
5066 04				db 3 + 1 
5067 .. 00			db "V0@",0              
506b				endm 
# End of macro CWHEAD
506b			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
506b 2a 24 f8				ld hl, (cli_var_array) 
506e cd a4 1b				call forth_push_numhl 
5071			 
5071				       NEXTW 
5071 c3 0d 1f			jp macro_next 
5074				endm 
# End of macro NEXTW
5074			.V1S: 
5074				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5074 7a				db WORD_SYS_CORE+102             
5075 8c 50			dw .V1Q            
5077 04				db 3 + 1 
5078 .. 00			db "V1!",0              
507c				endm 
# End of macro CWHEAD
507c			;| V1! ( u1 -- )  Store value to v1 | DONE 
507c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
507c cd 9b 1d			call macro_dsp_valuehl 
507f				endm 
# End of macro FORTH_DSP_VALUEHL
507f			 
507f 11 26 f8				ld de, cli_var_array+2 
5082				 
5082 eb					ex de, hl 
5083 73					ld (hl), e 
5084 23					inc hl 
5085 72					ld (hl), d 
5086			 
5086					; destroy value TOS 
5086			 
5086					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5086 cd 53 1e			call macro_forth_dsp_pop 
5089				endm 
# End of macro FORTH_DSP_POP
5089				       NEXTW 
5089 c3 0d 1f			jp macro_next 
508c				endm 
# End of macro NEXTW
508c			.V1Q: 
508c				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
508c 7b				db WORD_SYS_CORE+103             
508d 9d 50			dw .V2S            
508f 04				db 3 + 1 
5090 .. 00			db "V1@",0              
5094				endm 
# End of macro CWHEAD
5094			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5094 2a 26 f8				ld hl, (cli_var_array+2) 
5097 cd a4 1b				call forth_push_numhl 
509a				       NEXTW 
509a c3 0d 1f			jp macro_next 
509d				endm 
# End of macro NEXTW
509d			.V2S: 
509d				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
509d 7c				db WORD_SYS_CORE+104             
509e b5 50			dw .V2Q            
50a0 04				db 3 + 1 
50a1 .. 00			db "V2!",0              
50a5				endm 
# End of macro CWHEAD
50a5			;| V2! ( u1 -- )  Store value to v2 | DONE 
50a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50a5 cd 9b 1d			call macro_dsp_valuehl 
50a8				endm 
# End of macro FORTH_DSP_VALUEHL
50a8			 
50a8 11 28 f8				ld de, cli_var_array+4 
50ab				 
50ab eb					ex de, hl 
50ac 73					ld (hl), e 
50ad 23					inc hl 
50ae 72					ld (hl), d 
50af			 
50af					; destroy value TOS 
50af			 
50af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50af cd 53 1e			call macro_forth_dsp_pop 
50b2				endm 
# End of macro FORTH_DSP_POP
50b2				       NEXTW 
50b2 c3 0d 1f			jp macro_next 
50b5				endm 
# End of macro NEXTW
50b5			.V2Q: 
50b5				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
50b5 7d				db WORD_SYS_CORE+105             
50b6 c6 50			dw .V3S            
50b8 04				db 3 + 1 
50b9 .. 00			db "V2@",0              
50bd				endm 
# End of macro CWHEAD
50bd			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
50bd 2a 28 f8				ld hl, (cli_var_array+4) 
50c0 cd a4 1b				call forth_push_numhl 
50c3				       NEXTW 
50c3 c3 0d 1f			jp macro_next 
50c6				endm 
# End of macro NEXTW
50c6			.V3S: 
50c6				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
50c6 7c				db WORD_SYS_CORE+104             
50c7 de 50			dw .V3Q            
50c9 04				db 3 + 1 
50ca .. 00			db "V3!",0              
50ce				endm 
# End of macro CWHEAD
50ce			;| V3! ( u1 -- )  Store value to v3 | DONE 
50ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50ce cd 9b 1d			call macro_dsp_valuehl 
50d1				endm 
# End of macro FORTH_DSP_VALUEHL
50d1			 
50d1 11 2a f8				ld de, cli_var_array+6 
50d4				 
50d4 eb					ex de, hl 
50d5 73					ld (hl), e 
50d6 23					inc hl 
50d7 72					ld (hl), d 
50d8			 
50d8					; destroy value TOS 
50d8			 
50d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50d8 cd 53 1e			call macro_forth_dsp_pop 
50db				endm 
# End of macro FORTH_DSP_POP
50db				       NEXTW 
50db c3 0d 1f			jp macro_next 
50de				endm 
# End of macro NEXTW
50de			.V3Q: 
50de				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
50de 7d				db WORD_SYS_CORE+105             
50df ef 50			dw .END            
50e1 04				db 3 + 1 
50e2 .. 00			db "V3@",0              
50e6				endm 
# End of macro CWHEAD
50e6			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
50e6 2a 2a f8				ld hl, (cli_var_array+6) 
50e9 cd a4 1b				call forth_push_numhl 
50ec				       NEXTW 
50ec c3 0d 1f			jp macro_next 
50ef				endm 
# End of macro NEXTW
50ef			 
50ef			 
50ef			 
50ef			 
50ef			 
50ef			; end of dict marker 
50ef			 
50ef 00			.END:    db WORD_SYS_END 
50f0 00 00			dw 0 
50f2 00				db 0 
50f3			 
50f3			; use to jp here for user dict words to save on macro expansion  
50f3			 
50f3			user_dict_next: 
50f3				NEXTW 
50f3 c3 0d 1f			jp macro_next 
50f6				endm 
# End of macro NEXTW
50f6			 
50f6			 
50f6			user_exec: 
50f6				;    ld hl, <word code> 
50f6				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
50f6				;    call forthexec 
50f6				;    jp user_dict_next   (NEXT) 
50f6			        ;    <word code bytes> 
50f6 eb				ex de, hl 
50f7 2a 32 f1			ld hl,(os_tok_ptr) 
50fa				 
50fa				FORTH_RSP_NEXT 
50fa cd 4b 1b			call macro_forth_rsp_next 
50fd				endm 
# End of macro FORTH_RSP_NEXT
50fd			 
50fd			if DEBUG_FORTH_UWORD 
50fd						DMARK "UEX" 
50fd f5				push af  
50fe 3a 12 51			ld a, (.dmark)  
5101 32 77 fb			ld (debug_mark),a  
5104 3a 13 51			ld a, (.dmark+1)  
5107 32 78 fb			ld (debug_mark+1),a  
510a 3a 14 51			ld a, (.dmark+2)  
510d 32 79 fb			ld (debug_mark+2),a  
5110 18 03			jr .pastdmark  
5112 ..			.dmark: db "UEX"  
5115 f1			.pastdmark: pop af  
5116			endm  
# End of macro DMARK
5116				CALLMONITOR 
5116 cd 17 16			call break_point_state  
5119				endm  
# End of macro CALLMONITOR
5119			endif 
5119			 
5119			 
5119			 
5119 eb				ex de, hl 
511a 22 32 f1			ld (os_tok_ptr), hl 
511d				 
511d				; Don't use next - Skips the first word in uword. 
511d			 
511d c3 9e 1f			jp exec1 
5120			;	NEXT 
5120			 
5120			 
5120			; eof 
# End of file forth_wordsv4.asm
5120			endif 
5120			;;;;;;;;;;;;;; Debug code 
5120			 
5120			 
5120			;if DEBUG_FORTH_PARSE 
5120 .. 00		.nowordfound: db "No match",0 
5129 .. 00		.compword:	db "Comparing word ",0 
5139 .. 00		.nextwordat:	db "Next word at",0 
5146 .. 00		.charmatch:	db "Char match",0 
5151			;endif 
5151			if DEBUG_FORTH_JP 
5151			.foundword:	db "Word match. Exec..",0 
5151			endif 
5151			;if DEBUG_FORTH_PUSH 
5151 .. 00		.enddict:	db "Dict end. Push.",0 
5161 .. 00		.push_str:	db "Pushing string",0 
5170 .. 00		.push_num:	db "Pushing number",0 
517f .. 00		.data_sp:	db "SP:",0 
5183 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5195 .. 00		.wordinde:	db "Word in DE (3/0):",0 
51a7 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
51b9			;endif 
51b9			;if DEBUG_FORTH_MALLOC 
51b9 .. 00		.push_malloc:	db "Malloc address",0 
51c8			;endif 
51c8			 
51c8			 
51c8			 
51c8			; display malloc address and current data stack pointer  
51c8			 
51c8			malloc_error: 
51c8 d5				push de 
51c9 f5				push af 
51ca e5				push hl 
51cb cd 97 0a			call clear_display 
51ce 11 f0 51			ld de, .mallocerr 
51d1 3e 00			ld a,0 
51d3			;	ld de,os_word_scratch 
51d3 cd aa 0a			call str_at_display 
51d6 3e 11			ld a, display_row_1+17 
51d8 11 77 fb			ld de, debug_mark 
51db cd aa 0a			call str_at_display 
51de cd ba 0a			call update_display 
51e1				;call break_point_state 
51e1 cd c1 67			call cin_wait 
51e4			 
51e4 3e 20			ld a, ' ' 
51e6 32 30 ee			ld (os_view_disable), a 
51e9 e1				pop hl 
51ea f1				pop af 
51eb d1				pop de	 
51ec				CALLMONITOR 
51ec cd 17 16			call break_point_state  
51ef				endm  
# End of macro CALLMONITOR
51ef c9				ret 
51f0			 
51f0 .. 00		.mallocerr: 	db "Malloc Error",0 
51fd			;if DEBUG_FORTH_PUSH 
51fd			display_data_sp: 
51fd f5				push af 
51fe			 
51fe				; see if disabled 
51fe			 
51fe 3a 30 ee			ld a, (os_view_disable) 
5201 fe 2a			cp '*' 
5203 28 67			jr z, .skipdsp 
5205			 
5205 e5				push hl 
5206 e5				push hl 
5207 e5			push hl 
5208 cd 97 0a			call clear_display 
520b e1			pop hl 
520c 7c				ld a,h 
520d 21 36 f1			ld hl, os_word_scratch 
5210 cd cc 0f			call hexout 
5213 e1				pop hl 
5214 7d				ld a,l 
5215 21 38 f1			ld hl, os_word_scratch+2 
5218 cd cc 0f			call hexout 
521b 21 3a f1			ld hl, os_word_scratch+4 
521e 3e 00			ld a,0 
5220 77				ld (hl),a 
5221 11 36 f1			ld de,os_word_scratch 
5224 3e 28				ld a, display_row_2 
5226 cd aa 0a				call str_at_display 
5229 11 83 51			ld de, .wordinhl 
522c 3e 00			ld a, display_row_1 
522e			 
522e cd aa 0a				call str_at_display 
5231 11 77 fb			ld de, debug_mark 
5234 3e 11			ld a, display_row_1+17 
5236			 
5236 cd aa 0a				call str_at_display 
5239			 
5239				; display current data stack pointer 
5239 11 7f 51			ld de,.data_sp 
523c 3e 30				ld a, display_row_2 + 8 
523e cd aa 0a				call str_at_display 
5241			 
5241 2a 1e f8			ld hl,(cli_data_sp) 
5244 e5				push hl 
5245 7c				ld a,h 
5246 21 36 f1			ld hl, os_word_scratch 
5249 cd cc 0f			call hexout 
524c e1				pop hl 
524d 7d				ld a,l 
524e 21 38 f1			ld hl, os_word_scratch+2 
5251 cd cc 0f			call hexout 
5254 21 3a f1			ld hl, os_word_scratch+4 
5257 3e 00			ld a,0 
5259 77				ld (hl),a 
525a 11 36 f1			ld de,os_word_scratch 
525d 3e 33				ld a, display_row_2 + 11 
525f cd aa 0a				call str_at_display 
5262			 
5262			 
5262 cd ba 0a			call update_display 
5265 cd 45 0a			call delay1s 
5268 cd 45 0a			call delay1s 
526b e1				pop hl 
526c			.skipdsp: 
526c f1				pop af 
526d c9				ret 
526e			 
526e			display_data_malloc: 
526e			 
526e f5				push af 
526f e5				push hl 
5270 e5				push hl 
5271 e5			push hl 
5272 cd 97 0a			call clear_display 
5275 e1			pop hl 
5276 7c				ld a,h 
5277 21 36 f1			ld hl, os_word_scratch 
527a cd cc 0f			call hexout 
527d e1				pop hl 
527e 7d				ld a,l 
527f 21 38 f1			ld hl, os_word_scratch+2 
5282 cd cc 0f			call hexout 
5285 21 3a f1			ld hl, os_word_scratch+4 
5288 3e 00			ld a,0 
528a 77				ld (hl),a 
528b 11 36 f1			ld de,os_word_scratch 
528e 3e 28				ld a, display_row_2 
5290 cd aa 0a				call str_at_display 
5293 11 b9 51			ld de, .push_malloc 
5296 3e 00			ld a, display_row_1 
5298			 
5298 cd aa 0a				call str_at_display 
529b			 
529b				; display current data stack pointer 
529b 11 7f 51			ld de,.data_sp 
529e 3e 30				ld a, display_row_2 + 8 
52a0 cd aa 0a				call str_at_display 
52a3			 
52a3 2a 1e f8			ld hl,(cli_data_sp) 
52a6 e5				push hl 
52a7 7c				ld a,h 
52a8 21 36 f1			ld hl, os_word_scratch 
52ab cd cc 0f			call hexout 
52ae e1				pop hl 
52af 7d				ld a,l 
52b0 21 38 f1			ld hl, os_word_scratch+2 
52b3 cd cc 0f			call hexout 
52b6 21 3a f1			ld hl, os_word_scratch+4 
52b9 3e 00			ld a,0 
52bb 77				ld (hl),a 
52bc 11 36 f1			ld de,os_word_scratch 
52bf 3e 33				ld a, display_row_2 + 11 
52c1 cd aa 0a				call str_at_display 
52c4			 
52c4 cd ba 0a			call update_display 
52c7 cd 45 0a			call delay1s 
52ca cd 45 0a			call delay1s 
52cd e1				pop hl 
52ce f1				pop af 
52cf c9				ret 
52d0			;endif 
52d0			 
52d0			include "forth_autostart.asm" 
52d0			; list of commands to perform at system start up 
52d0			 
52d0			startcmds: 
52d0			;	dw test11 
52d0			;	dw test12 
52d0			;	dw test13 
52d0			;	dw test14 
52d0			;	dw test15 
52d0			;	dw test16 
52d0			;	dw test17 
52d0			;	dw ifthtest1 
52d0			;	dw ifthtest2 
52d0			;	dw ifthtest3 
52d0			;	dw mmtest1 
52d0			;	dw mmtest2 
52d0			;	dw mmtest3 
52d0			;	dw mmtest4 
52d0			;	dw mmtest5 
52d0			;	dw mmtest6 
52d0			;	dw iftest1 
52d0			;	dw iftest2 
52d0			;	dw iftest3 
52d0			;	dw looptest1 
52d0			;	dw looptest2 
52d0			;	dw test1 
52d0			;	dw test2 
52d0			;	dw test3 
52d0			;	dw test4 
52d0			;	dw game2r 
52d0			;	dw game2b1 
52d0			;	dw game2b2 
52d0			 
52d0				; start up words that are actually useful 
52d0			 
52d0 2e 53			dw clrstack 
52d2 61 53			dw type 
52d4 22 55			dw stest 
52d6 85 53			dw strncpy 
52d8 c3 54			dw list 
52da e6 53			dw start1 
52dc f8 53			dw start2 
52de			;	dw start3 
52de 0b 54			dw start3b 
52e0 63 54			dw start3c 
52e2			 
52e2				; (unit) testing words 
52e2			 
52e2 99 55			dw mtesta 
52e4 4e 56			dw mtestb 
52e6 f1 56			dw mtestc 
52e8 a6 57			dw mtestd 
52ea 4a 58			dw mteste 
52ec			 
52ec				; demo/game words 
52ec			 
52ec 56 5f		        dw game3w 
52ee 84 5f		        dw game3p 
52f0 a2 5f		        dw game3sc 
52f2 d3 5f		        dw game3vsi 
52f4 ff 5f		        dw game3vs 
52f6				 
52f6 49 5d			dw game2b 
52f8 b7 5d			dw game2bf 
52fa 01 5e			dw game2mba 
52fc 97 5e			dw game2mbas 
52fe d9 5e			dw game2mb 
5300			 
5300 0a 5a			dw game1 
5302 1b 5a			dw game1a 
5304 7d 5a			dw game1b 
5306 b2 5a			dw game1c 
5308 e8 5a			dw game1d 
530a 19 5b			dw game1s 
530c 2d 5b			dw game1t 
530e 42 5b			dw game1f 
5310 76 5b			dw game1z 
5312 ba 5b			dw game1zz 
5314			 
5314 00 59			dw test5 
5316 38 59			dw test6 
5318 70 59			dw test7 
531a 84 59			dw test8 
531c b0 59			dw test9 
531e c6 59			dw test10 
5320				 
5320 91 5c		        dw ssv5 
5322 75 5c		        dw ssv4 
5324 59 5c		        dw ssv3 
5326 23 5c		        dw ssv2 
5328 aa 5c		        dw ssv1 
532a f2 5c		        dw ssv1cpm 
532c			;	dw keyup 
532c			;	dw keydown 
532c			;	dw keyleft 
532c			;	dw keyright 
532c			;	dw 	keyf1 
532c			;	dw keyf2 
532c			;	dw keyf3 
532c			;	dw keyf4 
532c			;	dw keyf5 
532c			;	dw keyf6 
532c			;	dw keyf7 
532c			;	dw keyf8 
532c			;	dw keyf9 
532c			;	dw keyf10 
532c			;	dw keyf11 
532c			;	dw keyf12 
532c			;	dw keytab 
532c			;	dw keycr 
532c			;	dw keyhome 
532c			;	dw keyend 
532c			;	dw keybs 
532c 00 00			db 0, 0	 
532e			 
532e			 
532e			; clear stack  
532e			 
532e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5361			 
5361			; type ( addr count - ) 
5361 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5385			 
5385			; some direct memory words 
5385			; strncpy ( len t f -- t ) 
5385			 
5385 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
53e6			 
53e6 .. 00		start1:     	db ": bpon $0000 bp ;",0 
53f8 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
540b			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
540b .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5463 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
54c3			 
54c3			 
54c3			; a handy word to list items on the stack 
54c3			 
54c3 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5522			 
5522			 
5522			; test stack  
5522			; rnd8 stest 
5522			 
5522 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5599			 
5599			; random malloc and free cycles 
5599			 
5599 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
564e			 
564e			; fixed malloc and free cycles 
564e			 
564e .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56f1			 
56f1			; fixed double string push and drop cycle  
56f1			 
56f1 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
57a6			 
57a6			; consistent fixed string push and drop cycle  
57a6			 
57a6 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
584a			 
584a .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5900			 
5900			;test1:		db ": aa 1 2 3 ;", 0 
5900			;test2:     	db "111 aa 888 999",0 
5900			;test3:     	db ": bb 77 ;",0 
5900			;test4:     	db "$02 $01 do i . loop bb",0 
5900			 
5900 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5938 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5970 .. 00		test7:     	db ": box hline vline ;",0 
5984 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
59b0 .. 00		test9:     	db ": sw $01 adsp world ;",0 
59c6 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
59eb .. 00		test11:     	db "hello create .",0 
59fa .. 00		test12:     	db "hello2 create .",0 
5a0a			 
5a0a			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a0a			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a0a			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a0a			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a0a			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a0a			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a0a			 
5a0a			;iftest1:     	db "$0001 IF cls .",0 
5a0a			;iftest2:     	db "$0000 IF cls .",0 
5a0a			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a0a			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a0a			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a0a			 
5a0a			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a0a			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a0a			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a0a			 
5a0a			 
5a0a			 
5a0a			; a small guess the number game 
5a0a			 
5a0a .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a1b .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a7d			 
5a7d .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ab2 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5ae8 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b19 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b2d .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b42 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b76 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5bba			 
5bba			; Using 'ga' save a high score across multiple runs using external storage 
5bba			 
5bba .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c23			 
5c23			 
5c23			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c23			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c23			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c23			 
5c23			; simple screen saver to test code memory reuse to destruction 
5c23			 
5c23 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c59 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c75 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5c91 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5caa .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5cf2 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d49			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d49			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d49			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d49			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d49			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d49			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d49			 
5d49			 
5d49			 
5d49			; minesweeper/battleship finding game 
5d49			; draws a game board of random ship/mine positions 
5d49			; user enters coords to see if it hits on 
5d49			; game ends when all are hit 
5d49			; when hit or miss says how many may be in the area 
5d49			 
5d49			; setup the game board and then hide it 
5d49 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5db7 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e01			; prompt for where to target 
5e01 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5e97 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ebc			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ebc .. 00		game2mbht:      db ": mbckht nop ;",0 
5ecb .. 00		game2mbms:      db ": mbcms nop ;",0 
5ed9			; TODO how many might be near by 
5ed9 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f56			 
5f56			; Game 3 
5f56			 
5f56			; Vert scroller ski game - avoid the trees! 
5f56			 
5f56			; v0 score (ie turns) 
5f56			; v1 player pos 
5f56			; v2 left wall 
5f56			; v3 right wall 
5f56			 
5f56			; Draw side walls randomly 
5f56			 
5f56 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5f84			 
5f84			; Draw player 
5f84 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fa2			 
5fa2			; TODO Get Key 
5fa2			 
5fa2			; TODO Move left right 
5fa2			 
5fa2			; scroll and move walls a bit 
5fa2			 
5fa2 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5fd3			 
5fd3			; main game loop 
5fd3			 
5fd3 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5fff .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
603e			 
603e			; key board defs 
603e			 
603e .. 00		keyup:       db ": keyup $05 ;",0 
604c .. 00		keydown:       db ": keydown $0a ;",0 
605c .. 00		keyleft:       db ": keyleft $0b ;",0 
606c .. 00		keyright:       db ": keyright $0c ;",0 
607d .. 00		keyf1:       db ": keyf1 $10 ;",0 
608b .. 00		keyf2:       db ": keyf2 $11 ;",0 
6099 .. 00		keyf3:       db ": keyf3 $12 ;",0 
60a7 .. 00		keyf4:       db ": keyf4 $13 ;",0 
60b5 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60c3 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60d1 .. 00		keyf7:       db ": keyf7 $16 ;",0 
60df .. 00		keyf8:       db ": keyf8 $17 ;",0 
60ed .. 00		keyf9:       db ": keyf9 $18 ;",0 
60fb .. 00		keyf10:       db ": keyf10 $19 ;",0 
610a .. 00		keyf11:       db ": keyf11 $1a ;",0 
6119 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6128			 
6128 .. 00		keytab:       db ": keytab $09 ;",0 
6137 .. 00		keycr:       db ": keycr $0d ;",0 
6145 .. 00		keyhome:       db ": keyhome $0e ;",0 
6155 .. 00		keyend:       db ": keyend $0f ;",0 
6164 .. 00		keybs:       db ": keybs $08 ;",0 
6172			 
6172			   
6172			 
6172			 
6172			 
6172			; eof 
# End of file forth_autostart.asm
6172			 
6172 .. 00		sprompt1: db "Startup load...",0 
6182 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6198			 
6198			forth_startup: 
6198 21 d0 52			ld hl, startcmds 
619b 3e 00			ld a, 0 
619d 32 57 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
61a0			 
61a0 e5			.start1:	push hl 
61a1 cd 97 0a			call clear_display 
61a4 11 72 61			ld de, sprompt1 
61a7 3e 00		        ld a, display_row_1 
61a9 cd aa 0a			call str_at_display 
61ac 11 82 61			ld de, sprompt2 
61af 3e 28		        ld a, display_row_2 
61b1 cd aa 0a			call str_at_display 
61b4 e1				pop hl 
61b5 e5				push hl 
61b6 5e				ld e,(hl) 
61b7 23				inc hl 
61b8 56				ld d,(hl) 
61b9 3e 50		        ld a, display_row_3 
61bb cd aa 0a			call str_at_display 
61be cd ba 0a			call update_display 
61c1			 
61c1			 
61c1 3a 57 f2			ld a, (os_last_cmd) 
61c4 fe 00			cp 0 
61c6 28 05			jr z, .startprompt 
61c8 cd 39 0a			call delay250ms 
61cb 18 24			jr .startdo 
61cd				 
61cd				 
61cd			 
61cd			.startprompt: 
61cd			 
61cd 3e 9f			ld a,display_row_4 + display_cols - 1 
61cf 11 1a 1b		        ld de, endprg 
61d2 cd aa 0a			call str_at_display 
61d5 cd ba 0a			call update_display 
61d8 cd 45 0a			call delay1s 
61db cd c1 67			call cin_wait 
61de						 
61de fe 2a			cp '*' 
61e0 28 5e			jr z, .startupend1 
61e2 fe 23			cp '#' 
61e4 20 07			jr nz, .startno 
61e6 3e 01			ld a, 1 
61e8 32 57 f2			ld (os_last_cmd),a 
61eb 18 04			jr .startdo 
61ed fe 31		.startno:	cp '1' 
61ef 28 3a			jr z,.startnxt  
61f1			 
61f1				; exec startup line 
61f1			.startdo:	 
61f1 e1				pop hl 
61f2 e5				push hl 
61f3				 
61f3 5e				ld e,(hl) 
61f4 23				inc hl 
61f5 56				ld d,(hl) 
61f6 eb				ex de,hl 
61f7			 
61f7 e5				push hl 
61f8			 
61f8 3e 00			ld a, 0 
61fa				;ld a, FORTH_END_BUFFER 
61fa cd 34 11			call strlent 
61fd 23				inc hl   ; include zero term to copy 
61fe 06 00			ld b,0 
6200 4d				ld c,l 
6201 e1				pop hl 
6202 11 31 ee			ld de, scratch 
6205 ed b0			ldir 
6207			 
6207			 
6207 21 31 ee			ld hl, scratch 
620a cd 5b 1f			call forthparse 
620d cd 9b 1f			call forthexec 
6210 cd b2 1e			call forthexec_cleanup 
6213			 
6213 3e 78			ld a, display_row_4 
6215 11 be 18			ld de, endprog 
6218			 
6218 cd ba 0a			call update_display		 
621b			 
621b 3a 57 f2			ld a, (os_last_cmd) 
621e fe 00			cp 0 
6220 20 09			jr nz, .startnxt 
6222 cd 1c 1b			call next_page_prompt 
6225 cd 97 0a		        call clear_display 
6228 cd ba 0a			call update_display		 
622b			 
622b				; move onto next startup line? 
622b			.startnxt: 
622b			 
622b cd 39 0a			call delay250ms 
622e e1				pop hl 
622f			 
622f 23				inc hl 
6230 23				inc hl 
6231			 
6231 e5				push hl 
6232 5e				ld e, (hl) 
6233 23				inc hl 
6234 56				ld d, (hl) 
6235 e1				pop hl 
6236				; TODO replace 0 test 
6236			 
6236 eb				ex de, hl 
6237 cd f4 0c			call ishlzero 
623a			;	ld a,e 
623a			;	add d 
623a			;	cp 0    ; any left to do? 
623a eb				ex de, hl 
623b c2 a0 61			jp nz, .start1 
623e 18 01			jr .startupend 
6240			 
6240 e1			.startupend1: pop hl 
6241			.startupend: 
6241			 
6241 cd 97 0a			call clear_display 
6244 cd ba 0a			call update_display 
6247 c9				ret 
6248			 
6248			 
6248			; stack over and underflow checks 
6248			 
6248			; init the words to detect the under/overflow 
6248			 
6248			chk_stk_init: 
6248				; a vague random number to check so we dont get any "lucky" hits 
6248 3e 2d			ld a, 45 
624a 6f				ld l, a 
624b 00				nop 
624c 3e 17			ld a, 23 
624e 67				ld h, a 
624f			 
624f 22 26 ee			ld (chk_word), hl     ; the word we need to check against 
6252			 
6252			;	ld (chk_stund), hl	; stack points.... 
6252 22 fd fb			ld (chk_stovr), hl 
6255 22 1c f8			ld (chk_ret_und), hl 
6258 22 9a f7			ld (chk_ret_ovr), hl 
625b 22 98 f5			ld (chk_loop_ovr), hl 
625e 22 96 f3			ld (chk_data_ovr), hl 
6261 c9				ret 
6262				 
6262			check_stacks: 
6262				; check all stack words 
6262			 
6262 e5				push hl 
6263 d5				push de 
6264			 
6264			;	ld de,(chk_word) 
6264			;	ld hl, (chk_stund)	; stack points.... 
6264			;	if DEBUG_STK_FAULT 
6264			;		DMARK "FAa" 
6264			;		CALLMONITOR 
6264			;	endif 
6264			;	call cmp16 
6264			;	jp z, .chk_faulta 
6264			; 
6264			;	ld de, sfaultsu 
6264			;	jp .chk_fault 
6264			 
6264 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6267 ed 5b 26 ee		ld de,(chk_word) 
626b				if DEBUG_STK_FAULT 
626b					DMARK "FAb" 
626b					CALLMONITOR 
626b				endif 
626b cd e9 0c			call cmp16 
626e 28 06			jr z, .chk_fault1 
6270 11 11 63			ld de, sfaultso 
6273 c3 c5 62			jp .chk_fault 
6276			.chk_fault1:  
6276 2a 1c f8			ld hl, (chk_ret_und) 
6279 ed 5b 26 ee		ld de,(chk_word) 
627d				if DEBUG_STK_FAULT 
627d					DMARK "FAU" 
627d					CALLMONITOR 
627d				endif 
627d cd e9 0c			call cmp16 
6280 ca 89 62			jp z, .chk_fault2 
6283 11 21 63			ld de, sfaultru 
6286 c3 c5 62			jp .chk_fault 
6289			.chk_fault2:  
6289 2a 9a f7			ld hl, (chk_ret_ovr) 
628c ed 5b 26 ee		ld de,(chk_word) 
6290				if DEBUG_STK_FAULT 
6290					DMARK "FA1" 
6290					CALLMONITOR 
6290				endif 
6290 cd e9 0c			call cmp16 
6293 ca 9c 62			jp z, .chk_fault3 
6296 11 2f 63			ld de, sfaultro 
6299 c3 c5 62			jp .chk_fault 
629c			.chk_fault3:  
629c 2a 98 f5			ld hl, (chk_loop_ovr) 
629f ed 5b 26 ee		ld de,(chk_word) 
62a3				if DEBUG_STK_FAULT 
62a3					DMARK "FA2" 
62a3					CALLMONITOR 
62a3				endif 
62a3 cd e9 0c			call cmp16 
62a6 ca af 62			jp z, .chk_fault4 
62a9 11 49 63			ld de, sfaultlo 
62ac c3 c5 62			jp .chk_fault 
62af			.chk_fault4:  
62af 2a 96 f3			ld hl, (chk_data_ovr) 
62b2 ed 5b 26 ee		ld de,(chk_word) 
62b6				if DEBUG_STK_FAULT 
62b6					DMARK "FA3" 
62b6					CALLMONITOR 
62b6				endif 
62b6 cd e9 0c			call cmp16 
62b9 ca c2 62			jp z, .chk_fault5 
62bc 11 63 63			ld de, sfaultdo 
62bf c3 c5 62			jp .chk_fault 
62c2			 
62c2			 
62c2			.chk_fault5:  
62c2 d1				pop de 
62c3 e1				pop hl 
62c4			 
62c4 c9				ret 
62c5			 
62c5 cd 97 0a		.chk_fault: 	call clear_display 
62c8 3e 28				ld a, display_row_2 
62ca cd aa 0a				call str_at_display 
62cd 11 f3 62				   ld de, .stackfault 
62d0 3e 00				ld a, display_row_1 
62d2 cd aa 0a				call str_at_display 
62d5 11 77 fb				    ld de, debug_mark 
62d8 3e 11				ld a, display_row_1+17 
62da cd aa 0a				call str_at_display 
62dd cd ba 0a				call update_display 
62e0			 
62e0				; prompt before entering montior for investigating issue 
62e0			 
62e0 3e 78			ld a, display_row_4 
62e2 11 be 18			ld de, endprog 
62e5			 
62e5 cd ba 0a			call update_display		 
62e8			 
62e8 cd 1c 1b			call next_page_prompt 
62eb			 
62eb d1				pop de 
62ec e1				pop hl 
62ed cd 12 19				call monitor 
62f0 c3 0c 18				jp warmstart 
62f3					;jp 0 
62f3					;halt 
62f3			 
62f3			 
62f3			 
62f3 .. 00		.stackfault: 	db "Stack fault:",0 
6300			 
6300 .. 00		sfaultsu: 	db	"Stack under flow",0 
6311 .. 00		sfaultso: 	db	"Stack over flow",0 
6321 .. 00		sfaultru:	db "RTS underflow",0 
632f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6349 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6363 .. 00		sfaultdo:	db "DTS overflow", 0 
6370			 
6370			 
6370			fault_dsp_under: 
6370 11 82 63			ld de, .dsp_under 
6373 c3 32 64			jp .show_fault 
6376			 
6376			fault_rsp_under: 
6376 11 90 63			ld de, .rsp_under 
6379 c3 32 64			jp .show_fault 
637c			fault_loop_under: 
637c 11 9e 63			ld de, .loop_under 
637f c3 32 64			jp .show_fault 
6382			 
6382 .. 00		.dsp_under: db "DSP Underflow",0 
6390 .. 00		.rsp_under: db "RSP Underflow",0 
639e .. 00		.loop_under: db "LOOP Underflow",0 
63ad			 
63ad			 
63ad d5			type_faultn: 	push de 
63ae e5					push hl 
63af cd 97 0a				call clear_display 
63b2 11 d9 63				   ld de, .typefaultn 
63b5 3e 00				ld a, display_row_1 
63b7 cd aa 0a				call str_at_display 
63ba 11 77 fb				    ld de, debug_mark 
63bd 3e 11				ld a, display_row_1+17 
63bf cd aa 0a				call str_at_display 
63c2 cd ba 0a				call update_display 
63c5			 
63c5				; prompt before entering montior for investigating issue 
63c5			 
63c5 3e 78			ld a, display_row_4 
63c7 11 be 18			ld de, endprog 
63ca			 
63ca cd ba 0a			call update_display		 
63cd			 
63cd cd 1c 1b			call next_page_prompt 
63d0			 
63d0 e5					push hl 
63d1 d5					push de 
63d2 cd 12 19				call monitor 
63d5 c3 0c 18				jp warmstart 
63d8 76					halt 
63d9			 
63d9			 
63d9 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
63f0			 
63f0 d5			type_faults: 	push de 
63f1 e5					push hl 
63f2 cd 97 0a				call clear_display 
63f5 11 1b 64				   ld de, .typefaults 
63f8 3e 00				ld a, display_row_1 
63fa cd aa 0a				call str_at_display 
63fd 11 77 fb				    ld de, debug_mark 
6400 3e 11				ld a, display_row_1+17 
6402 cd aa 0a				call str_at_display 
6405 cd ba 0a				call update_display 
6408			 
6408				; prompt before entering montior for investigating issue 
6408			 
6408 3e 78			ld a, display_row_4 
640a 11 be 18			ld de, endprog 
640d			 
640d cd ba 0a			call update_display		 
6410			 
6410 cd 1c 1b			call next_page_prompt 
6413			 
6413 e1					pop hl 
6414 d1					pop de 
6415 cd 12 19				call monitor 
6418 c3 0c 18				jp warmstart 
641b			 
641b			 
641b .. 00		.typefaults: db "STR Type Expected TOS!",0 
6432			 
6432			.show_fault: 	 
6432 d5					push de 
6433 cd 97 0a				call clear_display 
6436 d1					pop de 
6437 3e 00				ld a, display_row_1 
6439 cd aa 0a				call str_at_display 
643c 11 77 fb				    ld de, debug_mark 
643f 3e 11				ld a, display_row_1+17 
6441 cd aa 0a				call str_at_display 
6444 cd ba 0a				call update_display 
6447			 
6447				; prompt before entering montior for investigating issue 
6447			 
6447 3e 78			ld a, display_row_4 
6449 11 be 18			ld de, endprog 
644c			 
644c cd ba 0a			call update_display		 
644f			 
644f cd 1c 1b			call next_page_prompt 
6452			 
6452 e1					pop hl 
6453 d1					pop de 
6454 cd 12 19				call monitor 
6457			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6457			; TODO Make optional fault restart to cli or warm boot? 
6457					;jp warmstart 
6457 c3 64 18				jp cli 
645a 76					halt 
645b			; eof 
# End of file forth_kernel.asm
645b			;include "nascombasic.asm" 
645b			 
645b			 
645b			; find out where the code ends if loaded into RAM (for SC114) 
645b			;endofcode:  
645b			;	nop 
645b			 
645b			 
645b			; eof 
645b			 
# End of file main.asm
645b			include "firmware_lcd_4x40.asm" 
645b			; **********************************************************************  
645b			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
645b			; **********************************************************************  
645b			;  
645b			; **  Written as a Small Computer Monitor App  
645b			; **  www.scc.me.uk  
645b			;  
645b			; History  
645b			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
645b			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
645b			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
645b			;  
645b			; **********************************************************************  
645b			;  
645b			; This program is an example of one of the methods of interfacing an   
645b			; alphanumeric LCD module.   
645b			;  
645b			; In this example the display is connected to either a Z80 PIO or a   
645b			; simple 8-bit output port.   
645b			;  
645b			; This interfacing method uses 4-bit data mode and uses time delays  
645b			; rather than polling the display's ready status. As a result the   
645b			; interface only requires 6 simple output lines:  
645b			;   Output bit 0 = not used  
645b			;   Output bit 1 = not used  
645b			;   Output bit 2 = RS         High = data, Low = instruction  
645b			;   Output bit 3 = E          Active high  
645b			;   Output bit 4 = DB4  
645b			;   Output bit 5 = DB5  
645b			;   Output bit 6 = DB6  
645b			;   Output bit 7 = DB7  
645b			; Display's R/W is connected to 0v so it is always in write mode  
645b			;  
645b			; This set up should work with any system supporting the RC2014 bus  
645b			  
645b			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
645b			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
645b			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
645b			;  
645b			; **********************************************************************  
645b			  
645b			; Additonal for 4x40. E1 and E2 instead of just E   
645b			; TODO swipe vidout signal on port a to activate E2  
645b			  
645b			; **********************************************************************  
645b			; **  Constants  
645b			; **********************************************************************  
645b			; LCD constants required by LCD support module  
645b			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
645b			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
645b			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
645b			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
645b			; TODO Decide which E is being set  
645b			kLCDWidth:  EQU display_cols             ;Width in characters  
645b			  
645b			; **********************************************************************  
645b			; **  Code library usage  
645b			; **********************************************************************  
645b			  
645b			; send character to current cursor position  
645b			; wraps and/or scrolls screen automatically  
645b			  
645b			  
645b			  
645b			lcd_init:  
645b			  
645b			; SCMonAPI functions used  
645b			  
645b			; Alphanumeric LCD functions used  
645b			; no need to specify specific functions for this module  
645b			  
645b 3e cf		            LD   A, 11001111b  
645d d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
645f 3e 00		            LD   A, 00000000b  
6461 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6463			  
6463			; Initialise alphanumeric LCD module  
6463 3e 00				ld a, 0  
6465 32 d7 f8				ld (display_lcde1e2), a  
6468 cd e9 64		            CALL fLCD_Init      ;Initialise LCD module  
646b 3e 01				ld a, 1  
646d 32 d7 f8				ld (display_lcde1e2), a  
6470 cd e9 64		            CALL fLCD_Init      ;Initialise LCD module  
6473			  
6473 c9				ret  
6474			  
6474			;  
6474			;;  
6474			; lcd functions  
6474			;  
6474			;  
6474			  
6474			; what is at cursor position   
6474			  
6474			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6474			;		call curptr  
6474			;		ret  
6474			  
6474			  
6474			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6474			  
6474			curptr:  
6474 c5				push bc  
6475 21 bd fa			ld hl, display_fb0  
6478			cpr:	  
6478				; loop for cursor whole row  
6478 0e 28			ld c, display_cols  
647a 23			cpr1:	inc hl  
647b 0d				dec c  
647c 20 fc			jr nz, cpr1  
647e 05				dec b  
647f 20 f7			jr nz, cpr  
6481			  
6481				; add col	  
6481			  
6481 23			cpr2:	inc hl  
6482 1d				dec e  
6483 20 fc			jr nz, cpr2  
6485			  
6485 c1				pop bc  
6486 c9				ret  
6487				  
6487			  
6487			  
6487			  
6487			  
6487			; write the frame buffer given in hl to hardware   
6487 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
648a 3e 00			ld a, kLCD_Line1  
648c cd 96 65		            CALL fLCD_Pos       ;Position cursor to location in A  
648f 06 28			ld b, display_cols  
6491 ed 5b d5 f8		ld de, (display_write_tmp)  
6495 cd e1 64			call write_len_string  
6498				  
6498				  
6498 2a d5 f8			ld hl, (display_write_tmp)  
649b 11 28 00			ld de, display_cols  
649e 19				add hl,de  
649f 22 d5 f8			ld (display_write_tmp),hl  
64a2			  
64a2				  
64a2 3e 28			ld a, kLCD_Line2  
64a4 cd 96 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64a7 06 28			ld b, display_cols  
64a9 ed 5b d5 f8		ld de, (display_write_tmp)  
64ad cd e1 64			call write_len_string  
64b0				  
64b0 2a d5 f8			ld hl, (display_write_tmp)  
64b3 11 28 00			ld de, display_cols  
64b6 19				add hl,de  
64b7 22 d5 f8			ld (display_write_tmp),hl  
64ba			  
64ba				  
64ba 3e 50			ld a, kLCD_Line3  
64bc cd 96 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64bf 06 28			ld b, display_cols  
64c1 ed 5b d5 f8		ld de, (display_write_tmp)  
64c5 cd e1 64			call write_len_string  
64c8				  
64c8 2a d5 f8			ld hl, (display_write_tmp)  
64cb 11 28 00			ld de, display_cols  
64ce 19				add hl,de  
64cf 22 d5 f8			ld (display_write_tmp),hl  
64d2			  
64d2				  
64d2 3e 78			ld a, kLCD_Line4  
64d4 cd 96 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64d7 06 28			ld b, display_cols  
64d9 ed 5b d5 f8		ld de, (display_write_tmp)  
64dd cd e1 64			call write_len_string  
64e0 c9					ret  
64e1				  
64e1				; write out a fixed length string given in b from de  
64e1			  
64e1 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
64e2 cd 4e 65		            CALL fLCD_Data      ;Write character to display  
64e5 13				inc de  
64e6 10 f9			djnz write_len_string  
64e8 c9				ret  
64e9			  
64e9			; Some other things to do  
64e9			;            LD   A, kLCD_Clear ;Display clear  
64e9			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
64e9			;            LD   A, kLCD_Under ;Display on with underscore cursor  
64e9			;            LD   A, kLCD_On     ;Display on with no cursor  
64e9			;            ;LD   A, kLCD_Off   ;Display off  
64e9			;            CALL fLCD_Inst      ;Send instruction to display  
64e9			;  
64e9			;  
64e9			;            halt  
64e9			;  
64e9			;  
64e9			;MsgHello:   DB  "Hello World!",0  
64e9			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
64e9			  
64e9			; Custom characters 5 pixels wide by 8 pixels high  
64e9			; Up to 8 custom characters can be defined  
64e9			;BitMaps:      
64e9			;; Character 0x00 = Battery icon  
64e9			;            DB  01110b  
64e9			;            DB  11011b  
64e9			;            DB  10001b  
64e9			;            DB  10001b  
64e9			;            DB  11111b  
64e9			;            DB  11111b  
64e9			;            DB  11111b  
64e9			;            DB  11111b  
64e9			;; Character 0x01 = Bluetooth icon  
64e9			;            DB  01100b  
64e9			;            DB  01010b  
64e9			;            DB  11100b  
64e9			;            DB  01000b  
64e9			;            DB  11100b  
64e9			;            DB  01010b  
64e9			;            DB  01100b  
64e9			;            DB  00000b  
64e9			;  
64e9			  
64e9			  
64e9			; **********************************************************************  
64e9			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
64e9			; **********************************************************************  
64e9			;  
64e9			; **  Written as a Small Computer Monitor App   
64e9			; **  Version 0.1 SCC 2018-05-16  
64e9			; **  www.scc.me.uk  
64e9			;  
64e9			; **********************************************************************  
64e9			;  
64e9			; This module provides support for alphanumeric LCD modules using with  
64e9			; *  HD44780 (or compatible) controller  
64e9			; *  5 x 7 pixel fonts  
64e9			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
64e9			; *  Interface via six digital outputs to the display (see below)  
64e9			;  
64e9			; LCD module pinout:  
64e9			;   1  Vss   0v supply  
64e9			;   2  Vdd   5v supply  
64e9			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
64e9			;   4  RS    High = data, Low = instruction  
64e9			;   5  R/W   High = Read, Low = Write  
64e9			;   6  E     Enable signal (active high)  
64e9			;   7  DB0   Data bit 0  
64e9			;   8  DB1   Data bit 1  
64e9			;   9  DB2   Data bit 2  
64e9			;  10  DB3   Data bit 3  
64e9			;  11  DB4   Data bit 4  
64e9			;  12  DB5   Data bit 5  
64e9			;  13  DB6   Data bit 6  
64e9			;  14  DB7   Data bit 7  
64e9			;  15  A     Backlight anode (+)  
64e9			;  16  K     Backlight cathode (-)  
64e9			;  
64e9			; This interfacing method uses 4-bit data mode and uses time delays  
64e9			; rather than polling the display's ready status. As a result the   
64e9			; interface only requires 6 simple output lines:  
64e9			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
64e9			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
64e9			;   LCD DB4 = Microcomputer output port bit 4  
64e9			;   LCD DB5 = Microcomputer output port bit 5  
64e9			;   LCD DB6 = Microcomputer output port bit 6  
64e9			;   LCD DB7 = Microcomputer output port bit 7  
64e9			; Display's R/W is connected to 0v so it is always in write mode  
64e9			; All 6 connections must be on the same port address <kLCDPrt>  
64e9			; This method also allows a decent length of cable from micro to LCD  
64e9			;  
64e9			; **********************************************************************  
64e9			;  
64e9			; To include the code for any given function provided by this module,   
64e9			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
64e9			; the parent source file.  
64e9			; For example:  #REQUIRES   uHexPrefix  
64e9			;  
64e9			; Also #INCLUDE this file at some point after the #REQUIRES statements  
64e9			; in the parent source file.  
64e9			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
64e9			;  
64e9			; These are the function names provided by this module:  
64e9			; fLCD_Init                     ;Initialise LCD  
64e9			; fLCD_Inst                     ;Send instruction to LCD  
64e9			; fLCD_Data                     ;Send data byte to LCD  
64e9			; fLCD_Pos                      ;Position cursor  
64e9			; fLCD_Str                      ;Display string  
64e9			; fLCD_Def                      ;Define custom character  
64e9			;  
64e9			; **********************************************************************  
64e9			;  
64e9			; Requires SCMonAPI.asm to also be included in the project  
64e9			;  
64e9			  
64e9			  
64e9			; **********************************************************************  
64e9			; **  Constants  
64e9			; **********************************************************************  
64e9			  
64e9			; Constants that must be defined externally  
64e9			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
64e9			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
64e9			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
64e9			;kLCDWidth: EQU 20             ;Width in characters  
64e9			  
64e9			; general line offsets in any frame buffer  
64e9			  
64e9			  
64e9			display_row_1: equ 0  
64e9			display_row_2: equ display_row_1+display_cols  
64e9			display_row_3: equ display_row_2 + display_cols  
64e9			display_row_4: equ display_row_3 + display_cols  
64e9			;display_row_4_eol:   
64e9			  
64e9			  
64e9			; Cursor position values for the start of each line  
64e9			  
64e9			; E  
64e9			kLCD_Line1: EQU 0x00   
64e9			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
64e9			; E1  
64e9			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
64e9			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
64e9			  
64e9			; Instructions to send as A register to fLCD_Inst  
64e9			kLCD_Clear: EQU 00000001b     ;LCD clear  
64e9			kLCD_Off:   EQU 00001000b     ;LCD off  
64e9			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
64e9			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
64e9			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
64e9			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
64e9			  
64e9			; Constants used by this code module  
64e9			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
64e9			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
64e9			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
64e9			  
64e9			  
64e9			  
64e9			; **********************************************************************  
64e9			; **  LCD support functions  
64e9			; **********************************************************************  
64e9			  
64e9			; Initialise alphanumeric LCD module  
64e9			; LCD control register codes:  
64e9			;   DL   0 = 4-bit mode        1 = 8-bit mode  
64e9			;   N    0 = 1-line mode       1 = 2-line mode  
64e9			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
64e9			;   D    0 = Display off       1 = Display on  
64e9			;   C    0 = Cursor off        1 = Cursor on  
64e9			;   B    0 = Blinking off      1 = Blinking on  
64e9			;   ID   0 = Decrement mode    1 = Increment mode  
64e9			;   SH   0 = Entire shift off  1 = Entire shift on  
64e9 3e 28		fLCD_Init:  LD   A, 40  
64eb cd 10 66		            CALL LCDDelay       ;Delay 40ms after power up  
64ee			; For reliable reset set 8-bit mode - 3 times  
64ee cd e0 65		            CALL WrFn8bit       ;Function = 8-bit mode  
64f1 cd e0 65		            CALL WrFn8bit       ;Function = 8-bit mode  
64f4 cd e0 65		            CALL WrFn8bit       ;Function = 8-bit mode  
64f7			; Set 4-bit mode  
64f7 cd dc 65		            CALL WrFn4bit       ;Function = 4-bit mode  
64fa cd 0e 66		            CALL LCDDelay1      ;Delay 37 us or more  
64fd			; Function set  
64fd 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
64ff cd 12 65		            CALL fLCD_Inst      ;2 line, display on  
6502			; Display On/Off control  
6502 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6504 cd 12 65		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6507			; Display Clear  
6507 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6509 cd 12 65		            CALL fLCD_Inst      ;Clear display  
650c			; Entry mode  
650c 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
650e cd 12 65		            CALL fLCD_Inst      ;Increment mode, shift off  
6511			; Display module now initialised  
6511 c9			            RET  
6512			; ok to here  
6512			  
6512			; Write instruction to LCD  
6512			;   On entry: A = Instruction byte to be written  
6512			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6512 f5			fLCD_Inst:  PUSH AF  
6513 f5			            PUSH AF  
6514 cd 26 65		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6517 f1			            POP  AF  
6518 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6519 17			            RLA  
651a 17			            RLA  
651b 17			            RLA  
651c cd 26 65		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
651f 3e 02		            LD   A, 2  
6521 cd 10 66		            CALL LCDDelay       ;Delay 2 ms to complete   
6524 f1			            POP  AF  
6525 c9			            RET  
6526			Wr4bits:   
6526 f5					push af  
6527 3a d7 f8				ld a, (display_lcde1e2)  
652a fe 00				cp 0     ; e  
652c 20 10				jr nz, .wea2	  
652e f1					pop af  
652f e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6531 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6533 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
6535 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
6537 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6539 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
653b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
653d c9			            RET  
653e f1			.wea2:		pop af  
653f e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6541 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6543 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
6545 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
6547 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6549 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
654b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
654d c9			            RET  
654e			  
654e			  
654e			; Write data to LCD  
654e			;   On entry: A = Data byte to be written  
654e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
654e f5			fLCD_Data:  PUSH AF  
654f f5			            PUSH AF  
6550 cd 62 65		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6553 f1			            POP  AF  
6554 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6555 17			            RLA  
6556 17			            RLA  
6557 17			            RLA  
6558 cd 62 65		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
655b 3e 96		            LD   A, 150  
655d 3d			Wait:      DEC  A              ;Wait a while to allow data   
655e 20 fd		            JR   NZ, Wait      ;  write to complete  
6560 f1			            POP  AF  
6561 c9			            RET  
6562			Wr4bitsa:     
6562 f5					push af  
6563 3a d7 f8				ld a, (display_lcde1e2)  
6566 fe 00				cp 0     ; e1  
6568 20 16				jr nz, .we2	  
656a f1					pop af  
656b e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
656d cb d7		            SET  kLCDBitRS, A  
656f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6571 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
6573 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
6575 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6577 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
6579 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
657b cb 97		            RES  kLCDBitRS, A  
657d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
657f c9			            RET  
6580 f1			.we2:		pop af  
6581 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6583 cb d7		            SET  kLCDBitRS, A  
6585 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6587 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
6589 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
658b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
658d cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
658f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6591 cb 97		            RES  kLCDBitRS, A  
6593 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6595 c9			            RET  
6596			  
6596			  
6596			; Position cursor to specified location  
6596			;   On entry: A = Cursor position  
6596			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6596 f5			fLCD_Pos:   PUSH AF  
6597					; at this point set the E1 or E2 flag depending on position  
6597			  
6597 c5					push bc  
6598			;		push af  
6598 06 00				ld b, 0  
659a 4f					ld c, a  
659b 3e 4f				ld a, kLCD_Line3-1  
659d b7			 		or a      ;clear carry flag  
659e 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
659f 38 04				jr c, .pe1  
65a1			  
65a1					; E selection  
65a1 cb 80				res 0, b         ; bit 0 unset e  
65a3			;		pop af    ; before line 3 so recover orig pos  
65a3			;		ld c, a    ; save for poking back  
65a3 18 06				jr .peset	          
65a5			.pe1:          	; E2 selection  
65a5 cb c0				set 0, b         ; bit 0 set e1  
65a7 79					ld a, c  
65a8 de 4f				sbc a, kLCD_Line3-1  
65aa 4f					ld c, a	         ; save caculated offset  
65ab			;		pop af     ; bin this original value now we have calculated form  
65ab			  
65ab			.peset:		; set bit  
65ab 78					ld a, b  
65ac 32 d7 f8				ld (display_lcde1e2), a 	  
65af 79					ld a, c  
65b0 c1					pop bc  
65b1			  
65b1 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
65b3 cd 12 65		            CALL fLCD_Inst      ;Write instruction to LCD  
65b6 f1			            POP  AF  
65b7 c9			            RET  
65b8			  
65b8			  
65b8			; Output text string to LCD  
65b8			;   On entry: DE = Pointer to null terminated text string  
65b8			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
65b8 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
65b9 b7			            OR   A              ;Null terminator?  
65ba c8			            RET  Z              ;Yes, so finished  
65bb cd 4e 65		            CALL fLCD_Data      ;Write character to display  
65be 13			            INC  DE             ;Point to next character  
65bf 18 f7		            JR   fLCD_Str       ;Repeat  
65c1 c9					ret  
65c2			  
65c2			; Define custom character  
65c2			;   On entry: A = Character number (0 to 7)  
65c2			;             DE = Pointer to character bitmap data  
65c2			;   On exit:  A = Next character number  
65c2			;             DE = Next location following bitmap  
65c2			;             BC HL IX IY I AF' BC' DE' HL' preserved  
65c2			; Character is   
65c2 c5			fLCD_Def:   PUSH BC  
65c3 f5			            PUSH AF  
65c4 07			            RLCA                ;Calculate location  
65c5 07			            RLCA                ;  for bitmap data  
65c6 07			            RLCA                ;  = 8 x CharacterNumber  
65c7 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
65c9 cd 12 65		            CALL fLCD_Inst      ;Write instruction to LCD  
65cc 06 00		            LD   B, 0  
65ce 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
65cf cd 4e 65		            CALL fLCD_Data      ;Write byte to display  
65d2 13			            INC  DE             ;Point to next byte  
65d3 04			            INC  B              ;Count bytes  
65d4 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
65d6 28 f6		            JR   Z, Loop       ;No, so repeat  
65d8 f1			            POP  AF  
65d9 3c			            INC  A              ;Increment character number  
65da c1			            POP  BC  
65db c9			            RET  
65dc			  
65dc			  
65dc			; **********************************************************************  
65dc			; **  Private functions  
65dc			; **********************************************************************  
65dc			  
65dc			; Write function to LCD  
65dc			;   On entry: A = Function byte to be written  
65dc			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65dc 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
65de 18 02		            JR   WrFunc  
65e0 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
65e2 f5			WrFunc:     PUSH AF  
65e3 f5					push af  
65e4 3a d7 f8				ld a, (display_lcde1e2)  
65e7 fe 00				cp 0     ; e1  
65e9 20 0f				jr nz, .wfea2	  
65eb f1					pop af  
65ec d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65ee cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
65f0 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
65f2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
65f4 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
65f6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65f8 18 0d			jr .wfskip  
65fa f1			.wfea2:		pop af  
65fb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65fd cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
65ff cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6601 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6603 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6605 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6607 3e 05		.wfskip:            LD  A, 5  
6609 cd 10 66		            CALL LCDDelay       ;Delay 5 ms to complete  
660c f1			            POP  AF  
660d c9			            RET  
660e			  
660e			  
660e			; Delay in milliseconds  
660e			;   On entry: A = Number of milliseconds delay  
660e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
660e 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6610 d5			LCDDelay:   PUSH DE  
6611 5f			            LD   E, A           ;Delay by 'A' ms  
6612 16 00		            LD   D, 0  
6614 cd 2a 0a		            CALL aDelayInMS  
6617 d1			            POP  DE  
6618 c9			            RET  
6619			  
6619			  
6619			testlcd:  
6619 3e 00			ld a, kLCD_Line1  
661b cd 96 65			call fLCD_Pos  
661e 06 28			ld b, 40  
6620 11 4e 66			ld de, .ttext1  
6623 cd e1 64			call write_len_string  
6626			  
6626 3e 28			ld a, kLCD_Line2  
6628 cd 96 65			call fLCD_Pos  
662b 06 28			ld b, 40  
662d 11 77 66			ld de, .ttext2  
6630 cd e1 64			call write_len_string  
6633 3e 50			ld a, kLCD_Line3  
6635 cd 96 65			call fLCD_Pos  
6638 06 28			ld b, 40  
663a 11 a0 66			ld de, .ttext3  
663d cd e1 64			call write_len_string  
6640 3e 78			ld a, kLCD_Line4  
6642 cd 96 65			call fLCD_Pos  
6645 06 28			ld b, 40  
6647 11 c9 66			ld de, .ttext4  
664a cd e1 64			call write_len_string  
664d			  
664d 76				halt  
664e			  
664e			  
664e .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
6677 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
66a0 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
66c9 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
66f2			   
66f2			  
66f2			  
66f2			; eof  
66f2			  
# End of file firmware_lcd_4x40.asm
66f2			;include "firmware_lcd_4x20.asm" 
66f2			include "firmware_key_5x10.asm" 
66f2			; 5 x 10 decade counter scanner  
66f2			  
66f2			  
66f2			; TODO do cursor shape change for shift keys  
66f2			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
66f2			  
66f2			  
66f2			; bit mask for each scan column and row for teing the matrix  
66f2			  
66f2			  
66f2			key_init:  
66f2			  
66f2			; SCMonAPI functions used  
66f2			  
66f2			; Alphanumeric LCD functions used  
66f2			; no need to specify specific functions for this module  
66f2			  
66f2			  
66f2 3e cf		            LD   A, 11001111b  
66f4 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
66f6			;            LD   A, 00000000b  
66f6 3e 1f		            LD   A, 00011111b  
66f8 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
66fa			  
66fa			  
66fa				; TODO Configure cursor shapes  
66fa			  
66fa				; Load cursor shapes   
66fa 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
66fc 11 0c 67		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
66ff 06 02		            LD   B, 2           ;Number of characters to define  
6701 cd c2 65		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6704 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6706			  
6706 3e 01				ld a, 1  
6708 32 d0 f8			ld (cursor_shape),a  
670b c9				ret  
670c			  
670c			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
670c			; Up to 8 custom characters can be defined  
670c			.cursor_shapes:      
670c			;; Character 0x00 = Normal  
670c 1f			            DB  11111b  
670d 1f			            DB  11111b  
670e 1f			            DB  11111b  
670f 1f			            DB  11111b  
6710 1f			            DB  11111b  
6711 1f			            DB  11111b  
6712 1f			            DB  11111b  
6713 1f			            DB  11111b  
6714			;; Character 0x01 = Modifier  
6714 1f			            DB  11111b  
6715 1b			            DB  11011b  
6716 1b			            DB  11011b  
6717 1b			            DB  11011b  
6718 1b			            DB  11011b  
6719 1f			            DB  11111b  
671a 1b			            DB  11011b  
671b 1f			            DB  11111b  
671c			  
671c			  
671c			  
671c			  
671c			; Display custom character 0  
671c			;            LD   A, kLCD_Line1+14  
671c			;            CALL fLCD_Pos       ;Position cursor to location in A  
671c			;            LD   A, 0  
671c			;            CALL fLCD_Data      ;Write character in A at cursor  
671c			  
671c			; Display custom character 1  
671c			;            LD   A, kLCD_Line2+14  
671c			;            CALL fLCD_Pos      ;Position cursor to location in A  
671c			;            LD   A, 1  
671c			;            CALL fLCD_Data     ;Write character in A at cursor  
671c			  
671c			; keyboard scanning   
671c			  
671c			; character in from keyboard  
671c			  
671c			; mapping for the pcb layout  
671c			  
671c			.matrix_to_char:  
671c .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
6727 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
6732 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
673d 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
6748 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
6753			.matrix_to_shift:  
6753			  
6753 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
675e .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
6769 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6774 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
677f .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
678a			  
678a			.matrix_to_symbolshift:  
678a			  
678a fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6795 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
67a0 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
67ab			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
67ab 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
67b6 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
67c1			  
67c1			  
67c1			  
67c1			; mapping for a simple straight through breadboard layout  
67c1			  
67c1			;.matrix_to_char:  
67c1			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
67c1			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
67c1			;		db "asdfghjkl",KEY_CR,0  
67c1			;		db "qwertyuiop",0  
67c1			;		 db "1234567890",0  
67c1			;.matrix_to_shift:  
67c1			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
67c1			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
67c1			;		db "ASDFGHJKL",KEY_CR,0  
67c1			;		db "QWERTYUIOP",0  
67c1			;		 db "!",'"',"#$%^&*()",0  
67c1			;.matrix_to_symbolshift:  
67c1			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
67c1			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
67c1			;		db "_?*fghjk=",KEY_CR,0  
67c1			;		db "-/+*[]{}@#",0  
67c1			;		 db "1234567890",0  
67c1			  
67c1			;.matrix_to_char: db "D#0*C987B654A321"  
67c1			  
67c1			  
67c1				  
67c1			  
67c1			; add cin and cin_wait  
67c1			  
67c1 cd d2 67		cin_wait: 	call cin  
67c4						if DEBUG_KEYCINWAIT  
67c4							push af  
67c4							  
67c4							ld hl,key_repeat_ct  
67c4							ld (hl),a  
67c4							inc hl  
67c4							call hexout  
67c4							ld hl,key_repeat_ct+3  
67c4							ld a,0  
67c4							ld (hl),a  
67c4			  
67c4							    LD   A, kLCD_Line1+11  
67c4							    CALL fLCD_Pos       ;Position cursor to location in A  
67c4							    LD   DE, key_repeat_ct  
67c4							    ;LD   DE, MsgHello  
67c4							    CALL fLCD_Str       ;Display string pointed to by DE  
67c4			  
67c4			  
67c4			  
67c4							pop af  
67c4						endif  
67c4 fe 00			cp 0  
67c6 28 f9			jr z, cin_wait   ; block until key press  
67c8			  
67c8							if DEBUG_KEYCINWAIT  
67c8								push af  
67c8			  
67c8								ld a, 'A'	  
67c8								ld hl,key_repeat_ct  
67c8								ld (hl),a  
67c8								inc hl  
67c8								ld a,0  
67c8								ld (hl),a  
67c8			  
67c8								    LD   A, kLCD_Line2+11  
67c8								    CALL fLCD_Pos       ;Position cursor to location in A  
67c8								    LD   DE, key_repeat_ct  
67c8								    ;LD   DE, MsgHello  
67c8								    CALL fLCD_Str       ;Display string pointed to by DE  
67c8			  
67c8							call delay500ms  
67c8			  
67c8								pop af  
67c8							endif  
67c8 f5				push af   ; save key pressed  
67c9			  
67c9			.cin_wait1:	  
67c9							if DEBUG_KEYCINWAIT  
67c9								push af  
67c9			  
67c9								ld a, 'b'	  
67c9								ld hl,key_repeat_ct  
67c9								ld (hl),a  
67c9								inc hl  
67c9								ld a,0  
67c9								ld (hl),a  
67c9			  
67c9								    LD   A, kLCD_Line2+11  
67c9								    CALL fLCD_Pos       ;Position cursor to location in A  
67c9								    LD   DE, key_repeat_ct  
67c9								    ;LD   DE, MsgHello  
67c9								    CALL fLCD_Str       ;Display string pointed to by DE  
67c9			  
67c9			  
67c9							call delay500ms  
67c9			  
67c9								pop af  
67c9							endif  
67c9			  
67c9 cd d2 67		call cin  
67cc fe 00			cp 0  
67ce 20 f9			jr nz, .cin_wait1  	; wait for key release  
67d0			if DEBUG_KEYCINWAIT  
67d0				push af  
67d0			  
67d0				ld a, '3'	  
67d0				ld hl,key_repeat_ct  
67d0				ld (hl),a  
67d0				inc hl  
67d0				ld a,0  
67d0				ld (hl),a  
67d0			  
67d0			            LD   A, kLCD_Line2+11  
67d0			            CALL fLCD_Pos       ;Position cursor to location in A  
67d0			            LD   DE, key_repeat_ct  
67d0			            ;LD   DE, MsgHello  
67d0			            CALL fLCD_Str       ;Display string pointed to by DE  
67d0			  
67d0			  
67d0			call delay500ms  
67d0			  
67d0				pop af  
67d0			endif  
67d0			  
67d0 f1				pop af   ; get key  
67d1 c9				ret  
67d2			  
67d2			  
67d2 cd e6 67		cin: 	call .mtoc  
67d5			  
67d5			if DEBUG_KEYCIN  
67d5				push af  
67d5				  
67d5				ld hl,key_repeat_ct  
67d5				ld (hl),a  
67d5				inc hl  
67d5				call hexout  
67d5				ld hl,key_repeat_ct+3  
67d5				ld a,0  
67d5				ld (hl),a  
67d5			  
67d5			            LD   A, kLCD_Line3+15  
67d5			            CALL fLCD_Pos       ;Position cursor to location in A  
67d5			            LD   DE, key_repeat_ct  
67d5			            ;LD   DE, MsgHello  
67d5			            CALL fLCD_Str       ;Display string pointed to by DE  
67d5			  
67d5			  
67d5			call delay500ms  
67d5			  
67d5				pop af  
67d5			endif  
67d5			  
67d5			  
67d5				; no key held  
67d5 fe 00			cp 0  
67d7 c8				ret z  
67d8			  
67d8			if DEBUG_KEYCIN  
67d8				push af  
67d8			  
67d8				ld a, '1'	  
67d8				ld hl,key_repeat_ct  
67d8				ld (hl),a  
67d8				inc hl  
67d8				ld a,0  
67d8				ld (hl),a  
67d8			  
67d8			            LD   A, kLCD_Line4+15  
67d8			            CALL fLCD_Pos       ;Position cursor to location in A  
67d8			            LD   DE, key_repeat_ct  
67d8			            ;LD   DE, MsgHello  
67d8			            CALL fLCD_Str       ;Display string pointed to by DE  
67d8			  
67d8			  
67d8			call delay500ms  
67d8			  
67d8				pop af  
67d8			endif  
67d8			  
67d8				; stop key bounce  
67d8			  
67d8 32 88 fb			ld (key_held),a		 ; save it  
67db 47				ld b, a  
67dc			  
67dc c5			.cina1:	push bc  
67dd			if DEBUG_KEYCIN  
67dd				push af  
67dd			  
67dd				ld hl,key_repeat_ct  
67dd				inc hl  
67dd				call hexout  
67dd				ld hl,key_repeat_ct+3  
67dd				ld a,0  
67dd				ld (hl),a  
67dd				ld hl,key_repeat_ct  
67dd				ld a, '2'	  
67dd				ld (hl),a  
67dd			  
67dd			            LD   A, kLCD_Line4+15  
67dd			            CALL fLCD_Pos       ;Position cursor to location in A  
67dd			            LD   DE, key_repeat_ct  
67dd			            ;LD   DE, MsgHello  
67dd			            CALL fLCD_Str       ;Display string pointed to by DE  
67dd			  
67dd				pop af  
67dd			endif  
67dd cd e6 67			call .mtoc  
67e0 c1				pop bc  
67e1 b8				cp b  
67e2 28 f8			jr z, .cina1  
67e4 78				ld a,b		  
67e5			if DEBUG_KEYCIN  
67e5				push af  
67e5			  
67e5				ld hl,key_repeat_ct  
67e5				inc hl  
67e5				call hexout  
67e5				ld hl,key_repeat_ct+3  
67e5				ld a,0  
67e5				ld (hl),a  
67e5				ld hl,key_repeat_ct  
67e5				ld a, '3'	  
67e5				ld (hl),a  
67e5			  
67e5			            LD   A, kLCD_Line4+15  
67e5			            CALL fLCD_Pos       ;Position cursor to location in A  
67e5			            LD   DE, key_repeat_ct  
67e5			            ;LD   DE, MsgHello  
67e5			            CALL fLCD_Str       ;Display string pointed to by DE  
67e5			  
67e5				pop af  
67e5			endif  
67e5 c9				ret  
67e6			  
67e6			; detect keyboard modifier key press and apply new overlay to the face key held  
67e6			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
67e6			  
67e6			;.cin_map_modifier:   
67e6			;	ld a, (hl)  
67e6			;	and 255  
67e6			;	ret NZ		; modifier key not flagged  
67e6			;  
67e6			;	; get key face  
67e6			;  
67e6			;	ld b,(key_face_held)  
67e6			;  
67e6			;	ld b, key_cols * key_rows  
67e6			;  
67e6			;	push de  
67e6			;	pop hl  
67e6			;  
67e6			;.mmod1: ld a,(hl)   ; get map test  
67e6			;	cp b  
67e6			;	jr z, .mmod2  
67e6			;  
67e6			;  
67e6			;  
67e6			;.mmod2: inc hl    ;   
67e6			;  
67e6			;	  
67e6			;  
67e6			;	  
67e6			;  
67e6			;	ld hl,key_actual_pressed  
67e6			;	ld (hl),a,  
67e6			;	ret  
67e6			  
67e6			; map matrix key held to char on face of key  
67e6			  
67e6			.mtoc:  
67e6			  
67e6			; test decade counter strobes  
67e6			  
67e6			;.decadetest1:  
67e6			  
67e6			; reset counter  
67e6			;ld a, 128  
67e6			;out (portbdata),a  
67e6			  
67e6			  
67e6			;ld b, 5  
67e6			;.dec1:  
67e6			;ld a, 0  
67e6			;out (portbdata),a  
67e6			;call delay1s  
67e6			  
67e6			;ld a, 32  
67e6			;out (portbdata),a  
67e6			;call delay1s  
67e6			;call delay1s  
67e6			;call delay1s  
67e6			;  
67e6			;ld a, 64+32  
67e6			;out (portbdata),a  
67e6			;call delay1s  
67e6			;;djnz .dec1  
67e6			;  
67e6			;jp .decadetest1  
67e6			  
67e6			  
67e6			  
67e6			  
67e6			  
67e6			  
67e6			  
67e6			  
67e6			  
67e6			  
67e6				; scan keyboard matrix and generate raw scan map  
67e6 cd 79 68			call matrix  
67e9			  
67e9				; reuse c bit 0 left modifer button - ie shift  
67e9			        ; reuse c bit 1 for right modifer button - ie symbol shift  
67e9				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
67e9			  
67e9 0e 00			ld c, 0  
67eb			  
67eb				; TODO set flags for modifer key presses   
67eb				; TODO do a search for modifer key...  
67eb			  
67eb				;ld hl,keyscan_table_row4  
67eb 21 e7 fb			ld hl,keyscan_table_row2  
67ee			  
67ee 7e				ld a, (hl)  
67ef fe 23			cp '#'  
67f1 20 07			jr nz, .nextmodcheck  
67f3 cb c1			set 0, c  
67f5 21 53 67			ld hl, .matrix_to_shift  
67f8 18 21			jr .dokeymap  
67fa				; TODO for now igonre  
67fa			.nextmodcheck:  
67fa 21 dc fb			ld hl,keyscan_table_row3  
67fd			  
67fd 7e				ld a, (hl)  
67fe fe 23			cp '#'  
6800 20 07			jr nz, .nextmodcheck2  
6802 cb c9			set 1, c   
6804 21 8a 67			ld hl, .matrix_to_symbolshift  
6807 18 12			jr .dokeymap  
6809			.nextmodcheck2:  
6809 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
680c			  
680c 7e				ld a, (hl)  
680d fe 23			cp '#'  
680f 20 07			jr nz, .donemodcheck  
6811 cb c9			set 1, c   
6813 21 53 67			ld hl, .matrix_to_shift  
6816 18 03			jr .dokeymap  
6818			  
6818				; no modifer found so just map to normal keys  
6818				; get mtoc map matrix to respective keys  
6818			;	ld hl, .matrix_to_char  
6818			;	ld hl, .matrix_to_char  
6818			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6818			;	ld a, KEY_SHIFT  
6818			;	call findchar  
6818			;  
6818			;	; got offset to key modifer in b  
6818			;  
6818			;	ld hl,keyscan_table_row5  
6818			;  
6818			;	ld a,b  
6818			;	call addatohl  
6818			;	ld a,(hl)  
6818			;  
6818			;	cp '#'  
6818			;	jr nz, .nextmodcheck  
6818			;	set 0, c  
6818			;	ld hl, .matrix_to_char  
6818			;	jr .dokeymap  
6818			;	; TODO for now igonre  
6818			;.nextmodcheck:  
6818			;	ld hl, .matrix_to_symbolshift  
6818			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6818			;	ld a, KEY_SYMBOLSHIFT  
6818			;	call findchar  
6818			;  
6818			;  
6818			;	; got offset to key modifer in b  
6818			;  
6818			;	ld hl,keyscan_table_row5  
6818			;  
6818			;	ld a,b  
6818			;	call addatohl  
6818			;	ld a,(hl)  
6818			;  
6818			;	cp '#'  
6818			;	jr nz, .donemodcheck  
6818			;	set 1, c   
6818			;	ld hl, .matrix_to_symbolshift  
6818			;	jr .dokeymap  
6818			  
6818			  
6818			  
6818			.donemodcheck:  
6818				; no modifer found so just map to normal keys  
6818				; get mtoc map matrix to respective keys  
6818 21 1c 67			ld hl, .matrix_to_char  
681b			  
681b			.dokeymap:  
681b				;ld (key_fa), c   
681b cd 34 68			call .mapkeys  
681e			  
681e			  
681e			if DEBUG_KEY  
681e			  
681e			; Display text on first line  
681e			            LD   A, kLCD_Line1  
681e			            CALL fLCD_Pos       ;Position cursor to location in A  
681e			            LD   DE, keyscan_table_row1  
681e			            ;LD   DE, MsgHello  
681e			            CALL fLCD_Str       ;Display string pointed to by DE  
681e			  
681e			; Display text on second line  
681e			            LD   A, kLCD_Line2  
681e			            CALL fLCD_Pos       ;Position cursor to location in A  
681e			            LD   DE, keyscan_table_row2  
681e			            CALL fLCD_Str       ;Display string pointed to by DE  
681e			            LD   A, kLCD_Line3  
681e			            CALL fLCD_Pos       ;Position cursor to location in A  
681e			            LD   DE, keyscan_table_row3  
681e			            CALL fLCD_Str       ;Display string pointed to by DE  
681e			            LD   A, kLCD_Line4  
681e			            CALL fLCD_Pos       ;Position cursor to location in A  
681e			            LD   DE, keyscan_table_row4  
681e			            CALL fLCD_Str       ;Display string pointed to by DE  
681e			            LD   A, kLCD_Line1+10  
681e			            CALL fLCD_Pos       ;Position cursor to location in A  
681e			            LD   DE, keyscan_table_row5  
681e			            CALL fLCD_Str       ;Display string pointed to by DE  
681e			  
681e				;call delay250ms  
681e			endif  
681e			;	jp testkey  
681e			  
681e			; get first char reported  
681e			  
681e 21 c6 fb			ld hl,keyscan_table_row5  
6821			  
6821				;ld b, 46   ; 30 keys to remap + 8 nulls   
6821 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6823			.findkey:  
6823 7e				ld a,(hl)  
6824 fe 00			cp 0  
6826 28 04			jr z, .nextkey  
6828 fe 7e			cp KEY_MATRIX_NO_PRESS  
682a 20 06			jr nz, .foundkey  
682c			.nextkey:  
682c 23				inc hl  
682d 10 f4			djnz .findkey  
682f 3e 00			ld a,0  
6831 c9				ret  
6832			.foundkey:  
6832 7e				ld a,(hl)  
6833 c9				ret  
6834				  
6834			  
6834			; convert the raw key map given hl for destination key  
6834			.mapkeys:  
6834 11 c6 fb			ld de,keyscan_table_row5  
6837			  
6837 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6839			.remap:  
6839 1a				ld a,(de)  
683a fe 23			cp '#'  
683c 20 02			jr nz, .remapnext  
683e				;CALLMONITOR  
683e 7e				ld a,(hl)  
683f 12				ld (de),a  
6840			  
6840			  
6840			  
6840			.remapnext:  
6840 23				inc hl  
6841 13				inc de  
6842 10 f5			djnz .remap  
6844				  
6844 c9				ret  
6845			  
6845			  
6845			  
6845			.mtocold2:  
6845			  
6845			;	; flag if key D is held down and remove from reporting  
6845			;	ld bc, .key_map_fd    
6845			;	ld hl, keyscan_table  
6845			;	ld de, key_fd  
6845			;	call .key_shift_hold  
6845			;	cp 255  
6845			;	jr z, .cinmap  
6845			;	; flag if key C is held down and remove from reporting  
6845			;	ld bc, .key_map_fc    
6845			;	ld hl, keyscan_table+key_cols  
6845			;	ld de, key_fc  
6845			;	call .key_shift_hold  
6845			;	cp 255  
6845			;	jr z, .cinmap  
6845			;	; flag if key B is held down and remove from reporting  
6845			;	ld bc, .key_map_fb    
6845			;	ld hl, keyscan_table+(key_cols*2)  
6845			;	ld de, key_fb  
6845			;	call .key_shift_hold  
6845			;	cp 255  
6845			;	jr z, .cinmap  
6845			;	; flag if key A is held down and remove from reporting  
6845			;	ld bc, .key_map_fa    
6845			;	ld hl, keyscan_table+(key_cols*3)  
6845			;	ld de, key_fa  
6845			;	call .key_shift_hold  
6845			;	cp 255  
6845			;	jr z, .cinmap  
6845			  
6845 11 1c 67			ld de, .matrix_to_char  
6848			  
6848			  
6848			.cinmap1:   
6848				if DEBUG_KEY  
6848			            LD   A, kLCD_Line4  
6848			            CALL fLCD_Pos       ;Position cursor to location in A  
6848					push de  
6848			            LD   DE, keyscan_table  
6848			            CALL fLCD_Str       ;Display string pointed to by DE  
6848					pop de  
6848				endif  
6848			  
6848				; scan key matrix table for any held key  
6848			  
6848				; de holds either the default matrix or one selected above  
6848			  
6848 21 93 fb			ld hl, keyscan_table  
684b 06 32			ld b,key_cols*key_rows  
684d			  
684d 7e			.cin11:	ld a,(hl)  
684e fe 23			cp '#'  
6850 28 08			jr z, .cinhit1  
6852 23				inc hl  
6853 13				inc de  
6854 05				dec b  
6855 20 f6			jr nz, .cin11  
6857				; no key found held  
6857 3e 00			ld a,0  
6859 c9				ret  
685a d5			.cinhit1: push de  
685b e1				pop hl  
685c 7e				ld a,(hl)  
685d c9				ret  
685e			  
685e			; flag a control key is held   
685e			; hl is key pin, de is flag indicator  
685e			  
685e			.key_shift_hold1:  
685e c5				push bc  
685f 3e 01			ld a, 1  
6861 32 d0 f8			ld (cursor_shape),a  
6864 06 00			ld b, 0  
6866 7e				ld a, (hl)  
6867 fe 2e			cp '.'  
6869 28 0a			jr z, .key_shift11  
686b 06 ff			ld b, 255  
686d 3e 2b			ld a, '+'    ; hide key from later scans  
686f 77				ld (hl),a  
6870 3e 02			ld a, 2  
6872 32 d0 f8			ld (cursor_shape),a  
6875			.key_shift11:  
6875				; write flag indicator  
6875 78				ld a,b  
6876 12				ld (de),a  
6877			  
6877 d1				pop de    ; de now holds the key map ptr  
6878 c9				ret  
6879			  
6879				  
6879			  
6879			; scans keyboard matrix and flags key press in memory array	  
6879				  
6879			matrix:  
6879				;call matrix  
6879				; TODO optimise the code....  
6879			  
6879			  
6879			;ld hl, keyscan_table_row1  
6879			;ld de, keyscan_table_row1+1  
6879			;ld bc,46  
6879			;ld a,KEY_MATRIX_NO_PRESS  
6879			;ldir  
6879			  
6879			  
6879			  
6879			; reset counter  
6879 3e 80		ld a, 128  
687b d3 c1		out (portbdata),a  
687d			  
687d 06 0a		ld b, 10  
687f 0e 00		ld c, 0       ; current clock toggle  
6881			  
6881			.colscan:  
6881			  
6881			; set current column  
6881			; disable clock enable and set clock low  
6881			  
6881			;ld a, 0  
6881			;out (portbdata),a  
6881			  
6881			; For each column scan for switches  
6881			  
6881 c5			push bc  
6882 21 89 fb		ld hl, keyscan_scancol  
6885 cd 8e 69		call .rowscan  
6888 c1			pop bc  
6889			  
6889			  
6889			; get back current column  
6889			  
6889			; translate the row scan  
6889			  
6889			;   
6889			; row 1  
6889			  
6889 78			ld a,b  
688a			  
688a 21 fc fb		LD   hl, keyscan_table_row1+10  
688d			  
688d cd dd 0c		call subafromhl  
6890			;call addatohl  
6890			  
6890 11 89 fb		ld de, keyscan_scancol  
6893			  
6893 1a			ld a,(de)  
6894 77			ld (hl),a  
6895			  
6895			  
6895			  
6895			  
6895			; row 2  
6895			  
6895 78			ld a,b  
6896			  
6896 21 f1 fb		LD   hl, keyscan_table_row2+10  
6899			  
6899			;call addatohl  
6899 cd dd 0c		call subafromhl  
689c			  
689c			  
689c 11 8a fb		ld de, keyscan_scancol+1  
689f			  
689f 1a			ld a,(de)  
68a0 77			ld (hl),a  
68a1			  
68a1			  
68a1			; row 3  
68a1			  
68a1 78			ld a,b  
68a2			  
68a2 21 e6 fb		LD   hl, keyscan_table_row3+10  
68a5			  
68a5			;call addatohl  
68a5 cd dd 0c		call subafromhl  
68a8			  
68a8 11 8b fb		ld de, keyscan_scancol+2  
68ab			  
68ab 1a			ld a,(de)  
68ac 77			ld (hl),a  
68ad			  
68ad			  
68ad			  
68ad			; row 4  
68ad			  
68ad 78			ld a,b  
68ae			  
68ae 21 db fb		LD   hl, keyscan_table_row4+10  
68b1			  
68b1			;call addatohl  
68b1 cd dd 0c		call subafromhl  
68b4			  
68b4 11 8c fb		ld de, keyscan_scancol+3  
68b7			  
68b7 1a			ld a,(de)  
68b8 77			ld (hl),a  
68b9			  
68b9			; row 5  
68b9			  
68b9 78			ld a,b  
68ba			  
68ba 21 d0 fb		LD   hl, keyscan_table_row5+10  
68bd			  
68bd			;call addatohl  
68bd cd dd 0c		call subafromhl  
68c0			  
68c0 11 8d fb		ld de, keyscan_scancol+4  
68c3			  
68c3 1a			ld a,(de)  
68c4 77			ld (hl),a  
68c5			  
68c5			; handshake next column  
68c5			  
68c5			  
68c5 3e 40		ld a, 64  
68c7 d3 c1		out (portbdata),a  
68c9			  
68c9 3e 00		ld a, 0  
68cb d3 c1		out (portbdata),a  
68cd			  
68cd			; toggle clk and move to next column  
68cd			;ld a, 64  
68cd			;cp c  
68cd			;  
68cd			;jr z, .coltoglow  
68cd			;ld c, a  
68cd			;jr .coltog  
68cd			;.coltoglow:  
68cd			;ld c, 0  
68cd			;.coltog:  
68cd			;ld a, c  
68cd			;out (portbdata),a  
68cd			  
68cd 10 b2		djnz .colscan  
68cf			  
68cf 3e 0a		ld a,10  
68d1 21 f2 fb		LD   hl, keyscan_table_row1  
68d4 cd cb 0c		call addatohl  
68d7 3e 00		ld a, 0  
68d9 77			ld (hl), a  
68da			  
68da			  
68da 3e 0a		ld a,10  
68dc 21 e7 fb		LD   hl, keyscan_table_row2  
68df cd cb 0c		call addatohl  
68e2 3e 00		ld a, 0  
68e4 77			ld (hl), a  
68e5			  
68e5 3e 0a		ld a,10  
68e7 21 dc fb		LD   hl, keyscan_table_row3  
68ea cd cb 0c		call addatohl  
68ed 3e 00		ld a, 0  
68ef 77			ld (hl), a  
68f0			  
68f0 3e 0a		ld a,10  
68f2 21 d1 fb		LD   hl, keyscan_table_row4  
68f5 cd cb 0c		call addatohl  
68f8 3e 00		ld a, 0  
68fa 77			ld (hl), a  
68fb			  
68fb 3e 0a		ld a,10  
68fd 21 c6 fb		LD   hl, keyscan_table_row5  
6900 cd cb 0c		call addatohl  
6903 3e 00		ld a, 0  
6905 77			ld (hl), a  
6906			  
6906			if DEBUG_KEY_MATRIX  
6906			  
6906			; Display text on first line  
6906			            LD   A, kLCD_Line1  
6906			            CALL fLCD_Pos       ;Position cursor to location in A  
6906			            LD   DE, keyscan_table_row1  
6906			            ;LD   DE, MsgHello  
6906			            CALL fLCD_Str       ;Display string pointed to by DE  
6906			  
6906			; Display text on second line  
6906			            LD   A, kLCD_Line2  
6906			            CALL fLCD_Pos       ;Position cursor to location in A  
6906			            LD   DE, keyscan_table_row2  
6906			            CALL fLCD_Str       ;Display string pointed to by DE  
6906			            LD   A, kLCD_Line3  
6906			            CALL fLCD_Pos       ;Position cursor to location in A  
6906			            LD   DE, keyscan_table_row3  
6906			            CALL fLCD_Str       ;Display string pointed to by DE  
6906			            LD   A, kLCD_Line4  
6906			            CALL fLCD_Pos       ;Position cursor to location in A  
6906			            LD   DE, keyscan_table_row4  
6906			            CALL fLCD_Str       ;Display string pointed to by DE  
6906			            LD   A, kLCD_Line4+10  
6906			            CALL fLCD_Pos       ;Position cursor to location in A  
6906			            LD   DE, keyscan_table_row5  
6906			            CALL fLCD_Str       ;Display string pointed to by DE  
6906			  
6906			;call delay250ms  
6906				jp matrix  
6906			endif  
6906 c9			ret  
6907			  
6907			; using decade counter....  
6907			  
6907			  
6907			; TODO reset decade counter to start of scan  
6907			  
6907			; reset 15  
6907			; clock 14  
6907			; ce 13  
6907			  
6907			; 1 - q5  
6907			; 2 - q1  
6907			; 3 - q0  
6907			; 4 - q2  
6907			; 5 - q6  
6907			; 6 - q7  
6907			; 7 - q3  
6907			; 8 - vss  
6907			; 9 - q8  
6907			; 10 - q4  
6907			; 11 - q9  
6907			; 12 - cout  
6907			; 16 - vdd  
6907			  
6907			; clock      ce       reset     output  
6907			; 0          x        0         n  
6907			; x          1        0         n  
6907			; x          x        1         q0  
6907			; rising     0        0         n+1  
6907			; falling    x        0         n  
6907			; x          rising   0         n  
6907			; 1          falling  0         x+1  
6907			;  
6907			; x = dont care, if n < 5 carry = 1 otherwise 0  
6907			  
6907			;   
6907			; reset   
6907			; 13=0, 14=0, 15=1 .. 15=0  
6907			;  
6907			; handshake line  
6907			; 14=1.... read line 14=0  
6907			  
6907			  
6907			  
6907			  
6907			  
6907			; TODO hand shake clock for next column scan  
6907			; TODO detect each row  
6907			  
6907			  
6907			  
6907			  
6907			; reset 128  
6907			; clock 64  
6907			; ce 32  
6907			  
6907			  
6907			.cyclestart:  
6907			  
6907			; reset counter  
6907 3e 80		ld a, 128  
6909 d3 c1		out (portbdata),a  
690b			  
690b			; loop leds  
690b 06 0a		ld b,10  
690d			  
690d			.cycle1:  
690d c5			push bc  
690e 3e 00		ld a, 0  
6910 d3 c1		out (portbdata),a  
6912 cd 39 0a		call delay250ms  
6915			  
6915 3e 40		ld a, 64  
6917 d3 c1		out (portbdata),a  
6919 cd 39 0a		call delay250ms  
691c			  
691c 3e 00		ld a, 0  
691e d3 c1		out (portbdata),a  
6920 cd 39 0a		call delay250ms  
6923			  
6923 c1			pop bc  
6924 10 e7		djnz .cycle1  
6926			  
6926			  
6926 18 df		jr .cyclestart  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			; map matrix key held to char on face of key  
6928			  
6928			;.mtocold:  
6928			;  
6928			;  
6928			;; reset counter  
6928			;ld a, 128  
6928			;out (portbdata),a  
6928			;  
6928			;  
6928			;; scan keyboard row 1  
6928			;ld a, 0  
6928			;out (portbdata),a  
6928			;;ld a, 64  
6928			;;out (portbdata),a  
6928			;  
6928			;  
6928			;	ld a, 128  
6928			;	ld hl, keyscan_table  
6928			;	call .rowscan  
6928			;  
6928			;;ld a, 0  
6928			;;out (portbdata),a  
6928			;ld a, 64  
6928			;out (portbdata),a  
6928			;  
6928			;	ld a, 64  
6928			;	ld hl, keyscan_table+key_cols  
6928			;	call .rowscan  
6928			;  
6928			;ld a, 0  
6928			;out (portbdata),a  
6928			;;ld a, 64  
6928			;;out (portbdata),a  
6928			;	ld a, 32  
6928			;	ld hl, keyscan_table+(key_cols*2)  
6928			;	call .rowscan  
6928			;  
6928			;  
6928			;;ld a, 0  
6928			;;out (portbdata),a  
6928			;ld a, 64  
6928			;out (portbdata),a  
6928			;  
6928			;	ld a, 16  
6928			;	ld hl, keyscan_table+(key_cols*3)  
6928			;	call .rowscan  
6928			;  
6928			;  
6928			;	; flag if key D is held down and remove from reporting  
6928			;	ld bc, .key_map_fd    
6928			;	ld hl, keyscan_table  
6928			;	ld de, key_fd  
6928			;	call .key_shift_hold  
6928			;	cp 255  
6928			;	jr z, .cinmap  
6928			;	; flag if key C is held down and remove from reporting  
6928			;	ld bc, .key_map_fc    
6928			;	ld hl, keyscan_table+key_cols  
6928			;	ld de, key_fc  
6928			;	call .key_shift_hold  
6928			;	cp 255  
6928			;	jr z, .cinmap  
6928			;	; flag if key B is held down and remove from reporting  
6928			;	ld bc, .key_map_fb    
6928			;	ld hl, keyscan_table+(key_cols*2)  
6928			;	ld de, key_fb  
6928			;	call .key_shift_hold  
6928			;	cp 255  
6928			;	jr z, .cinmap  
6928			;	; flag if key A is held down and remove from reporting  
6928			;	ld bc, .key_map_fa    
6928			;	ld hl, keyscan_table+(key_cols*3)  
6928			;	ld de, key_fa  
6928			;	call .key_shift_hold  
6928			;	cp 255  
6928			;	jr z, .cinmap  
6928			;  
6928			;	ld de, .matrix_to_char  
6928			;  
6928			;  
6928			;.cinmap:   
6928			;	if DEBUG_KEY  
6928			;            LD   A, kLCD_Line4  
6928			;            CALL fLCD_Pos       ;Position cursor to location in A  
6928			;		push de  
6928			;            LD   DE, keyscan_table  
6928			;            CALL fLCD_Str       ;Display string pointed to by DE  
6928			;		pop de  
6928			;	endif  
6928			  
6928				; scan key matrix table for any held key  
6928			  
6928				; de holds either the default matrix or one selected above  
6928			  
6928			;	ld hl, keyscan_table  
6928			;	ld b,key_cols*key_rows  
6928			;  
6928			;.cin1:	ld a,(hl)  
6928			;	cp '#'  
6928			;	jr z, .cinhit  
6928			;	inc hl  
6928			;	inc de  
6928			;	dec b  
6928			;	jr nz, .cin1  
6928			;	; no key found held  
6928			;	ld a,0  
6928			;	ret  
6928			;.cinhit: push de  
6928			;	pop hl  
6928			;	ld a,(hl)  
6928			;	ret  
6928			  
6928			; flag a control key is held   
6928			; hl is key pin, de is flag indicator  
6928			  
6928			;.key_shift_hold:  
6928			;	push bc  
6928			;	ld a, 1  
6928			;	ld (cursor_shape),a  
6928			;	ld b, 0  
6928			;	ld a, (hl)  
6928			;	cp '.'  
6928			;	jr z, .key_shift1  
6928			;	ld b, 255  
6928			;	ld a, '+'    ; hide key from later scans  
6928			;	ld (hl),a  
6928			;	ld a, 2  
6928			;	ld (cursor_shape),a  
6928			;.key_shift1:  
6928			;	; write flag indicator  
6928			;	ld a,b  
6928			;	ld (de),a  
6928			;  
6928			;	pop de    ; de now holds the key map ptr  
6928			;	ret  
6928			  
6928				  
6928				  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			  
6928			;	push hl  
6928			;	push de  
6928			;	push bc  
6928			;	call keyscan  
6928			;	; map key matrix to ascii value of key face  
6928			;  
6928			;	ld hl, key_face_map  
6928			;	ld de, keyscan_table  
6928			;  
6928			;	; get how many keys to look at  
6928			;	ld b, keyscan_table_len  
6928			;	  
6928			;  
6928			;	; at this stage fall out on first key hit  
6928			;	; TODO handle multiple key press  
6928			;  
6928			;map1:	ld a,(hl)  
6928			;	cp '#'  
6928			;	jr z, keyhit  
6928			;	inc hl  
6928			;	inc de  
6928			;	dec b  
6928			;	jr nz, map1  
6928			;nohit:	ld a, 0  
6928			;	jr keydone  
6928			;keyhit: push de  
6928			;	pop hl  
6928			;	ld a,(hl)  
6928			;keydone:  
6928			;	push bc  
6928			;	push de  
6928			; 	push hl  
6928			;	ret   
6928			;  
6928			  
6928			  
6928			  
6928			  
6928			; scan physical key matrix  
6928			  
6928			  
6928			;keyscan:  
6928			;  
6928			;; for each key_row use keyscanr bit mask for out  
6928			;; then read in for keyscanc bitmask  
6928			;; save result of row scan to keyscantable  
6928			;  
6928			;; scan keyboard row 1  
6928			;  
6928			;	ld b, key_rows  
6928			;	ld hl, key_scanr  
6928			;	ld de, keyscan_table  
6928			;  
6928			;rowloop:  
6928			;  
6928			;	ld a,(hl)		; out bit mask to energise keyboard row  
6928			;	call rowscan  
6928			;	inc hl  
6928			;	dec b  
6928			;	jr nz, rowloop  
6928			;  
6928			;	ret  
6928			;  
6928			;  
6928			;; pass a out bitmask, b row number  
6928			;arowscan:   
6928			;	push bc  
6928			;  
6928			;	ld d, b  
6928			;  
6928			;	; calculate buffer location for this row  
6928			;  
6928			;	ld hl, keyscan_table	  
6928			;kbufr:  ld e, key_cols  
6928			;kbufc:	inc hl  
6928			;	dec e  
6928			;	jr nz, kbufc  
6928			;	dec d  
6928			;	jr nz, kbufr  
6928			;  
6928			;	; energise row and read columns  
6928			;  
6928			;	out (portbdata),a  
6928			;	in a,(portbdata)  
6928			;	ld c,a  
6928			;  
6928			;  
6928			;	; save buffer loc  
6928			;  
6928			;	ld (keybufptr), hl  
6928			;  
6928			;	ld hl, key_scanc  
6928			;	ld d, key_cols  
6928			;  
6928			;	; for each column check each bit mask  
6928			;  
6928			;colloop:  
6928			;	  
6928			;  
6928			;	; reset flags for the row   
6928			;  
6928			;	ld b,'.'  
6928			;	and (hl)  
6928			;	jr z, maskskip  
6928			;	ld b,'#'  
6928			;maskskip:  
6928			;	; save  key state  
6928			;	push hl  
6928			;	ld hl, (keybufptr)  
6928			;	ld (hl), b  
6928			;	inc hl  
6928			;	ld (keybufptr), hl  
6928			;  
6928			;	; move to next bit mask  
6928			;	pop hl  
6928			;	inc hl  
6928			;  
6928			;	dec d  
6928			;	jr nz, colloop  
6928			;  
6928			;	ret  
6928			;  
6928			;  
6928			;;  
6928			; lcd functions  
6928			;  
6928			;  
6928			  
6928			;if DEBUG_KEY_MATRIX  
6928			  
6928			; test function to display hardware view of matrix state  
6928			  
6928			matrixold:  
6928			  
6928			  
6928			  
6928			; reset counter  
6928 3e 80		ld a, 128  
692a d3 c1		out (portbdata),a  
692c			; scan keyboard row 1  
692c 3e 00		ld a, 0  
692e d3 c1		out (portbdata),a  
6930			;ld a, 64  
6930			;out (portbdata),a  
6930 3e 80			ld a, 128  
6932 21 f2 fb			ld hl, keyscan_table_row1  
6935 cd 8e 69			call .rowscan  
6938			  
6938			;ld a, 0  
6938			;out (portbdata),a  
6938 3e 40		ld a, 64  
693a d3 c1		out (portbdata),a  
693c 3e 40			ld a, 64  
693e 21 e7 fb			ld hl, keyscan_table_row2  
6941 cd 8e 69			call .rowscan  
6944			  
6944 3e 00		ld a, 0  
6946 d3 c1		out (portbdata),a  
6948			;ld a, 64  
6948			;out (portbdata),a  
6948 3e 20			ld a, 32  
694a 21 dc fb			ld hl, keyscan_table_row3  
694d cd 8e 69			call .rowscan  
6950			  
6950			;ld a, 0  
6950			;out (portbdata),a  
6950 3e 40		ld a, 64  
6952 d3 c1		out (portbdata),a  
6954 3e 10			ld a, 16  
6956 21 d1 fb			ld hl, keyscan_table_row4  
6959 cd 8e 69			call .rowscan  
695c			  
695c			; Display text on first line  
695c 3e 00		            LD   A, kLCD_Line1  
695e cd 96 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6961 11 f2 fb		            LD   DE, keyscan_table_row1  
6964			            ;LD   DE, MsgHello  
6964 cd b8 65		            CALL fLCD_Str       ;Display string pointed to by DE  
6967			  
6967			; Display text on second line  
6967 3e 28		            LD   A, kLCD_Line2  
6969 cd 96 65		            CALL fLCD_Pos       ;Position cursor to location in A  
696c 11 e7 fb		            LD   DE, keyscan_table_row2  
696f cd b8 65		            CALL fLCD_Str       ;Display string pointed to by DE  
6972 3e 50		            LD   A, kLCD_Line3  
6974 cd 96 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6977 11 dc fb		            LD   DE, keyscan_table_row3  
697a cd b8 65		            CALL fLCD_Str       ;Display string pointed to by DE  
697d 3e 78		            LD   A, kLCD_Line4  
697f cd 96 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6982 11 d1 fb		            LD   DE, keyscan_table_row4  
6985 cd b8 65		            CALL fLCD_Str       ;Display string pointed to by DE  
6988			  
6988 cd 39 0a			call delay250ms  
698b c3 79 68			jp matrix  
698e			  
698e			; pass de as row display flags  
698e			.rowscan:   
698e			;	out (portbdata),a  
698e db c1			in a,(portbdata)  
6990 4f				ld c,a  
6991				; reset flags for the row   
6991 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6993 e6 01			and 1  
6995 28 02			jr z, .p1on  
6997 06 23			ld b,'#'  
6999			.p1on:  
6999 70				ld (hl), b  
699a 23				inc hl  
699b			  
699b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
699d 79				ld a,c  
699e e6 02			and 2  
69a0			;	bit 0,a  
69a0 28 02			jr z, .p2on  
69a2 06 23			ld b,'#'  
69a4			.p2on:  
69a4 70				ld (hl), b  
69a5 23				inc hl  
69a6			;  
69a6 06 7e			ld b,KEY_MATRIX_NO_PRESS  
69a8 79				ld a,c  
69a9 e6 04			and 4  
69ab			;;	bit 0,a  
69ab 28 02			jr z, .p3on  
69ad 06 23			ld b,'#'  
69af			.p3on:  
69af 70				ld (hl), b  
69b0 23				inc hl  
69b1			;;  
69b1 06 7e			ld b,KEY_MATRIX_NO_PRESS  
69b3			;;	bit 0,a  
69b3 79				ld a,c  
69b4 e6 08			and 8  
69b6 28 02			jr z, .p4on  
69b8 06 23			ld b,'#'  
69ba			.p4on:  
69ba 70				ld (hl), b  
69bb 23				inc hl  
69bc			  
69bc 06 7e			ld b,KEY_MATRIX_NO_PRESS  
69be			;;	bit 0,a  
69be 79				ld a,c  
69bf e6 10			and 16  
69c1 28 02			jr z, .p5on  
69c3 06 23			ld b,'#'  
69c5			.p5on:  
69c5 70				ld (hl), b  
69c6 23				inc hl  
69c7			; zero term  
69c7 06 00			ld b,0  
69c9 70				ld (hl), b  
69ca			  
69ca c9			.rscandone: ret  
69cb			  
69cb			;addatohl:  
69cb			;  
69cb			 ;add   a, l    ; A = A+L  
69cb			  ;  ld    l, a    ; L = A+L  
69cb			   ; adc   a, h    ; A = A+L+H+carry  
69cb			   ; sub   l       ; A = H+carry  
69cb			   ; ld    h, a    ; H = H+carry  
69cb			  
69cb			;ret  
69cb			; eof  
# End of file firmware_key_5x10.asm
69cb			;include "firmware_key_4x10.asm" 
69cb			 
69cb			heap_size:    equ heap_end - heap_start 
69cb			;eof 
# End of file os_mega.asm
69cb
