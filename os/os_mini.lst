# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 69 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 f9 fd				ld hl, display_fb1  
001f 22 55 fd				ld (display_fb_active), hl  
0022			  
0022 cd 15 0d				call clear_display  
0025			  
0025 21 57 fd				ld hl, display_fb2  
0028 22 55 fd				ld (display_fb_active), hl  
002b			  
002b cd 15 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 4a fe				ld hl, display_fb0  
0031 22 55 fd				ld (display_fb_active), hl  
0034			  
0034 cd 15 0d				call clear_display  
0037			  
0037			  
0037 cd 98 72				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd e1 73			call key_init  
003d cd fb 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd ec 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043					call sound_init  
0043				endif  
0043			  
0043				; lcd test sequence  
0043					  
0043 cd 38 0d			call update_display  
0046 cd 92 0c			call delay1s  
0049 3e 2b			ld a,'+'  
004b cd 1a 0d			call fill_display  
004e cd 38 0d			call update_display  
0051 cd 92 0c			call delay1s  
0054 3e 2a			ld a,'*'  
0056 cd 1a 0d			call fill_display  
0059 cd 38 0d			call update_display  
005c cd 92 0c			call delay1s  
005f 3e 2d			ld a,'-'  
0061 cd 1a 0d			call fill_display  
0064 cd 38 0d			call update_display  
0067 cd 92 0c			call delay1s  
006a			  
006a			; boot splash screen  
006a			if display_cols == 20	  
006a 3e 00		        ld a, display_row_1    
006c			else  
006c			        ld a, display_row_1 +10   
006c			endif  
006c 11 9c 1a			ld de, prom_bootmsg  
006f cd 28 0d			call str_at_display  
0072 cd 38 0d			call update_display  
0075			  
0075			  
0075 cd 92 0c			call delay1s  
0078 cd 92 0c			call delay1s  
007b			if display_cols == 20	  
007b 3e 2a		            LD   A, display_row_3+2  
007d			else  
007d			            LD   A, display_row_3+12  
007d			endif  
007d 11 b1 1a			ld de, prom_bootmsg1  
0080 cd 28 0d			call str_at_display  
0083 cd 38 0d			call update_display  
0086 cd 92 0c			call delay1s  
0089 cd 92 0c			call delay1s  
008c			  
008c			;	ld a, display_row_4+3  
008c			;	ld de, bootmsg2  
008c			;	call str_at_display  
008c			;	call update_display  
008c			;	call delay1s  
008c			;	call delay1s  
008c			  
008c			; debug mark setup  
008c			  
008c 3e 5f		ld a, '_'  
008e 32 b4 fe		ld (debug_mark),a  
0091 32 b5 fe		ld (debug_mark+1),a  
0094 32 b6 fe		ld (debug_mark+2),a  
0097 3e 00		ld a,0  
0099 32 b7 fe		ld (debug_mark+3),a  
009c			  
009c c9					ret  
009d			  
009d			  
009d			;bootmsg2:	db "Firmware v0.1",0  
009d			  
009d			; a 4x20 lcd  
009d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
009d			  
009d			;if display_cols == 20  
009d			;	include "firmware_lcd_4x20.asm"  
009d			;endif  
009d			  
009d			;if display_cols == 40  
009d			;	include "firmware_lcd_4x40.asm"  
009d			;endif  
009d			  
009d			;  
009d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
009d			; TODO abstract the bit bang video out interface for dual display  
009d			; TODO wire video out to tx pin on rc2014 bus  
009d			  
009d			; must supply cin, and cin_wait for low level hardware abstraction   
009d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
009d			; test scancode  
009d			  
009d			;;;;;  
009d			;;;  
009d			; Moved out to mini and maxi versions  
009d			;  
009d			; include "firmware_key_4x4.asm"  
009d			; using existing 4 wire x 4 resistor array for input  
009d			;include "firmware_key_4x10.asm"  
009d			; need to mod the board for 5 rows due to resistor array  
009d			;include "firmware_key_5x10.asm"  
009d			  
009d			; storage hardware interface  
009d			  
009d			; use microchip serial eeprom for storage  
009d			  
009d			  
009d			if STORAGE_SE  
009d				include "firmware_spi.asm"  
009d			; my spi protocol (used by storage) 
009d			 
009d			; SPI pins 
009d			 
009d			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
009d			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
009d			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
009d			 
009d			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
009d			; chip pin 4 gnd 
009d			 
009d			 
009d			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
009d			SPI_CE1: equ 1      ;    port a1 pin 14  
009d			SPI_CE2: equ 2      ;    port a2 pin pin 13 
009d			SPI_CE3: equ 3      ; port    a3 pin pin 12 
009d			SPI_CE4: equ 4      ; port a4     pin 10 
009d			 
009d			; active low AND masks 
009d			 
009d			;SPI_CE0_MASK: equ    255-1 
009d			;SPI_CE1_MASK: equ   255-2 
009d			;SPI_CE2_MASK: equ   255-4 
009d			;SPI_CE3_MASK: equ   255-8 
009d			;SPI_CE4_MASK: equ   255-16 
009d			SPI_CE_HIGH:  equ 255 
009d			 
009d			 
009d			 
009d			;  Perform SCLK wait pulse 
009d			 
009d			spi_clk: 
009d f5				push af 
009e 3a f1 fb			ld a, (spi_clktime) 
00a1 fe 00			cp 0 
00a3 28 03			jr z, .scskip 
00a5 cd 77 0c			call aDelayInMS 
00a8			.scskip: 
00a8 f1				pop af 
00a9 c9				ret 
00aa			 
00aa			 
00aa			 
00aa			; TODO store port id for spi device ie dev c 
00aa			; TODO store pin for SO 
00aa			; TODO store pin for SI 
00aa			; TODO store pin for SCLK 
00aa			 
00aa			; 
00aa			 
00aa			; ensure that spi bus is in a stable state with default pins  
00aa			 
00aa			se_stable_spi:   
00aa			 
00aa				 ; set DI high, CE high , SCLK low 
00aa				;ld a, SPI_DI | SPI_CE0 
00aa 3e 07			ld a, SPI_DI  
00ac cd b6 01			call spi_ce_high 
00af d3 80			 out (storage_adata),a 
00b1 32 ee fb			ld (spi_portbyte),a 
00b4			 
00b4				if DEBUG_SPI 
00b4					push hl 
00b4					ld l, a 
00b4					DMARK "SPI" 
00b4					CALLMONITOR 
00b4					pop hl 
00b4				endif 
00b4 c9				ret 
00b5			 
00b5			; byte to send in a 
00b5			 
00b5			spi_send_byte: 
00b5				; save byte to send for bit mask shift out 
00b5 4f			        ld c,a 
00b6 3a ee fb			ld a,(spi_portbyte) 
00b9				  
00b9				; clock out	each bit of the byte msb first 
00b9			 
00b9 06 08			ld b, 8 
00bb			.ssb1: 
00bb				; clear so bit  
00bb cb bf			res SPI_DI, a 
00bd cb 11			rl c 
00bf				; if bit 7 is set then carry is set 
00bf 30 02			jr nc, .ssb2 
00c1 cb ff			set SPI_DI,a 
00c3			.ssb2:  ; output bit to ensure it is stable 
00c3 d3 80			out (storage_adata),a 
00c5 00				nop 
00c6				; clock bit high 
00c6 cb ef			set SPI_SCLK,a 
00c8 d3 80			out (storage_adata),a 
00ca 00				nop 
00cb cd 9d 00			call spi_clk 
00ce				; then low 
00ce cb af			res SPI_SCLK,a 
00d0 d3 80			out (storage_adata),a 
00d2 00				nop 
00d3 cd 9d 00			call spi_clk 
00d6 10 e3			djnz .ssb1 
00d8			 
00d8 32 ee fb			ld (spi_portbyte),a 
00db c9				ret 
00dc			 
00dc			; TODO low level get byte into A on spi 
00dc			 
00dc			spi_read_byte:  
00dc			 
00dc				; save byte to send for bit mask shift out 
00dc 0e 00		    ld c,0 
00de 3a ee fb			ld a,(spi_portbyte) 
00e1				  
00e1				; clock out	each bit of the byte msb first 
00e1			 
00e1			 
00e1				; clock bit high 
00e1 cb ef			set SPI_SCLK,a 
00e3 d3 80			out (storage_adata),a 
00e5 00				nop 
00e6 cd 9d 00			call spi_clk 
00e9			 
00e9			    ; read DO  
00e9			 
00e9 cb f9		    set 7,c 
00eb db 80			in a,(storage_adata) 
00ed cb 77		    bit SPI_DO,a 
00ef 20 02		    jr nz, .b7 
00f1 cb b9		    res 7,c 
00f3			.b7: 
00f3				; then low 
00f3 cb af			res SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8 cd 9d 00			call spi_clk 
00fb			     
00fb			 
00fb				; clock bit high 
00fb cb ef			set SPI_SCLK,a 
00fd d3 80			out (storage_adata),a 
00ff 00				nop 
0100 cd 9d 00			call spi_clk 
0103			 
0103			    ; read DO  
0103			 
0103 cb f1		    set 6,c 
0105 db 80			in a,(storage_adata) 
0107 cb 77		    bit SPI_DO,a 
0109 20 02		    jr nz, .b6 
010b cb b1		    res 6,c 
010d			.b6: 
010d				; then low 
010d cb af			res SPI_SCLK,a 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112 cd 9d 00			call spi_clk 
0115			 
0115				; clock bit high 
0115 cb ef			set SPI_SCLK,a 
0117 d3 80			out (storage_adata),a 
0119 00				nop 
011a cd 9d 00			call spi_clk 
011d			 
011d			 
011d			    ; read DO  
011d			 
011d cb e9		    set 5,c 
011f db 80			in a,(storage_adata) 
0121 cb 77		    bit SPI_DO,a 
0123 20 02		    jr nz, .b5 
0125 cb a9		    res 5,c 
0127			.b5: 
0127				; then low 
0127 cb af			res SPI_SCLK,a 
0129 d3 80			out (storage_adata),a 
012b 00				nop 
012c cd 9d 00			call spi_clk 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134 cd 9d 00			call spi_clk 
0137			 
0137			    ; read DO  
0137			 
0137 cb e1		    set 4,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b4 
013f cb a1		    res 4,c 
0141			.b4: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146 cd 9d 00			call spi_clk 
0149				; clock bit high 
0149 cb ef			set SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d 00				nop 
014e cd 9d 00			call spi_clk 
0151			 
0151			    ; read DO  
0151			 
0151 cb d9		    set 3,c 
0153 db 80			in a,(storage_adata) 
0155 cb 77		    bit SPI_DO,a 
0157 20 02		    jr nz, .b3 
0159 cb 99		    res 3,c 
015b			.b3: 
015b				; then low 
015b cb af			res SPI_SCLK,a 
015d d3 80			out (storage_adata),a 
015f 00				nop 
0160 cd 9d 00			call spi_clk 
0163				; clock bit high 
0163 cb ef			set SPI_SCLK,a 
0165 d3 80			out (storage_adata),a 
0167 00				nop 
0168 cd 9d 00			call spi_clk 
016b			 
016b			    ; read DO  
016b			 
016b cb d1		    set 2,c 
016d db 80			in a,(storage_adata) 
016f cb 77		    bit SPI_DO,a 
0171 20 02		    jr nz, .b2 
0173 cb 91		    res 2,c 
0175			.b2: 
0175				; then low 
0175 cb af			res SPI_SCLK,a 
0177 d3 80			out (storage_adata),a 
0179 00				nop 
017a cd 9d 00			call spi_clk 
017d				; clock bit high 
017d cb ef			set SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182 cd 9d 00			call spi_clk 
0185			 
0185			    ; read DO  
0185			 
0185 cb c9		    set 1,c 
0187 db 80			in a,(storage_adata) 
0189 cb 77		    bit SPI_DO,a 
018b 20 02		    jr nz, .b1 
018d cb 89		    res 1,c 
018f			.b1: 
018f				; then low 
018f cb af			res SPI_SCLK,a 
0191 d3 80			out (storage_adata),a 
0193 00				nop 
0194 cd 9d 00			call spi_clk 
0197				; clock bit high 
0197 cb ef			set SPI_SCLK,a 
0199 d3 80			out (storage_adata),a 
019b 00				nop 
019c cd 9d 00			call spi_clk 
019f			 
019f			    ; read DO  
019f			 
019f cb c1		    set 0,c 
01a1 db 80			in a,(storage_adata) 
01a3 cb 77		    bit SPI_DO,a 
01a5 20 02		    jr nz, .b0 
01a7 cb 81		    res 0,c 
01a9			.b0: 
01a9				; then low 
01a9 cb af			res SPI_SCLK,a 
01ab d3 80			out (storage_adata),a 
01ad 00				nop 
01ae cd 9d 00			call spi_clk 
01b1			 
01b1			 
01b1 32 ee fb			ld (spi_portbyte),a 
01b4			 
01b4			    ; return byte 
01b4 79			    ld a,c 
01b5			 
01b5			 
01b5 c9				ret 
01b6			 
01b6			 
01b6			 
01b6			spi_ce_high: 
01b6			 
01b6				if DEBUG_SPI_HARD_CE0 
01b6			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b6					ret 
01b6			 
01b6				endif 
01b6			 
01b6			 
01b6 f5				push af 
01b7			 
01b7				; send direct ce to port b 
01b7 3e ff			ld a, 255 
01b9 d3 81			out (storage_bdata), a 
01bb			 
01bb f1				pop af 
01bc			 
01bc				; for port a that shares with spi lines AND the mask 
01bc			  
01bc				if DEBUG_SPI 
01bc					push hl 
01bc					ld h, a 
01bc				endif 
01bc			;	ld c, SPI_CE_HIGH 
01bc			;	and c 
01bc cb c7			set SPI_CE0, a 
01be cb cf			set SPI_CE1, a 
01c0 cb d7			set SPI_CE2, a 
01c2 cb df			set SPI_CE3, a 
01c4 cb e7			set SPI_CE4, a 
01c6			 
01c6				if DEBUG_SPI 
01c6					ld l, a 
01c6					DMARK "CEh" 
01c6					CALLMONITOR 
01c6					pop hl 
01c6				endif 
01c6 c9				ret 
01c7			 
01c7			 
01c7			spi_ce_low: 
01c7			 
01c7				if DEBUG_SPI_HARD_CE0 
01c7			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01c7					ret 
01c7			 
01c7				endif 
01c7			 
01c7 c5				push bc 
01c8 f5				push af 
01c9			 
01c9				; send direct ce to port b 
01c9 3a f0 fb			ld a, (spi_cartdev) 
01cc d3 81			out (storage_bdata), a 
01ce			 
01ce			 
01ce			 
01ce				; for port a that shares with spi lines AND the mask 
01ce			 
01ce 3a ed fb			ld a, (spi_device)  
01d1 4f				ld c, a 
01d2			 
01d2 f1				pop af 
01d3			 
01d3				; detect CEx 
01d3			 
01d3				if DEBUG_SPI 
01d3					push hl 
01d3					ld h, a 
01d3				endif 
01d3			 
01d3 cb 41			bit SPI_CE0, c 
01d5 20 04			jr nz, .cel1 
01d7 cb 87			res SPI_CE0, a 
01d9 18 1e			jr .celn 
01db			.cel1: 
01db cb 49			bit SPI_CE1, c 
01dd 20 04			jr nz, .cel2 
01df cb 8f			res SPI_CE1, a 
01e1 18 16			jr .celn 
01e3			.cel2: 
01e3 cb 51			bit SPI_CE2, c 
01e5 20 04			jr nz, .cel3 
01e7 cb 97			res SPI_CE2, a 
01e9 18 0e			jr .celn 
01eb			.cel3: 
01eb cb 59			bit SPI_CE3, c 
01ed 20 04			jr nz, .cel4 
01ef cb 9f			res SPI_CE3, a 
01f1 18 06			jr .celn 
01f3			.cel4: 
01f3 cb 61			bit SPI_CE4, c 
01f5 20 02			jr nz, .celn 
01f7 cb a7			res SPI_CE4, a 
01f9			.celn: 
01f9			 
01f9			 
01f9			 
01f9			;	add c 
01f9			 
01f9				if DEBUG_SPI 
01f9					ld l, a 
01f9					DMARK "CEl" 
01f9					CALLMONITOR 
01f9					pop hl 
01f9				endif 
01f9 c1				pop bc 
01fa c9				ret 
01fb			 
01fb			 
01fb			 
01fb			; eof 
01fb			 
01fb			 
01fb			 
01fb			 
01fb			 
# End of file firmware_spi.asm
01fb				include "firmware_seeprom.asm"  
01fb			; 
01fb			; persisent storage interface via microchip serial eeprom 
01fb			 
01fb			; port a pio 2 
01fb			; pa 7 - si 
01fb			; pa 6 - sclk  
01fb			; pa 5 - so 
01fb			; pa 4 - cs 
01fb			; pa 3 - cs 
01fb			; pa 2 - cs 
01fb			; pa 1 - cs 
01fb			; pa 0 - cs 
01fb			; 
01fb			; TODO get block 
01fb			; TODO save block 
01fb			; TODO load file 
01fb			; TODO save file 
01fb			; TODO get dir  
01fb			 
01fb			;  
01fb			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fb			storage_actl: equ Device_C+2     ; device c port a 
01fb			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fb			storage_bctl: equ Device_C+3     ; device c port b 
01fb			 
01fb			 
01fb			; TODO move these to hardware driver file 
01fb			 
01fb			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fb			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fb			; storage bank file system format 
01fb			; 
01fb			; first page of bank: 
01fb			; 	addr 0 - status check 
01fb			;       addr 1 - write protect flag 
01fb			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fb			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fb			;         TODO see if scanning whole of for available next file id is fast enough 
01fb			;	addr 4 > zero term string of bank label 
01fb			; 
01fb			;        
01fb			;  
01fb			; first page of any file: 
01fb			;      byte 0 - file id  
01fb			;      byte 1-17 - fixed file name  
01fb			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fb			; 
01fb			; other pages of any file: 
01fb			;      byte 0 - file id 
01fb			;      byte 1> - file data 
01fb			; 
01fb			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fb			;  
01fb			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fb			 
01fb			 
01fb			;storage_so_bit: 5 
01fb			;storage_si_bit: 7 
01fb			;storage_sclk_bit: 6 
01fb			  
01fb			 
01fb			; init storage pio 
01fb			 
01fb			storage_init: 
01fb			 
01fb			 
01fb					; set default SPI clk pulse time as disabled 
01fb			 
01fb 3e 00				ld a, 0 
01fd 32 f1 fb				ld (spi_clktime), a 
0200			 
0200					; init hardware 
0200			 
0200 3e cf		            LD   A, 11001111b 
0202 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0204 3e 00		            LD   A, 00000000b 
0206 cb f7			set SPI_DO,a 
0208			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0208 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020a			 
020a 3e cf		            LD   A, 11001111b 
020c d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
020e 3e 00		            LD   A, 00000000b 
0210 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0212			 
0212				; set all external spi devices off  
0212 3e ff			ld a, 255 
0214 32 ed fb			ld (spi_device), a 
0217 32 f0 fb			ld (spi_cartdev), a 
021a			 
021a					; ensure the spi bus is in a default stable state 
021a cd aa 00				call se_stable_spi 
021d			 
021d			; TODO scan spi bus and gather which storage banks are present 
021d			 
021d			; populate store_bank_active  
021d			; for each ce line activate and attempt to write first byte of bank and read back 
021d			; if zero is returned then bank is empty 
021d			;   
021d			; 
021d			 
021d					; init file extent cache to save on slow reads 
021d			 
021d			;	ld hl, store_filecache 
021d			;	ld de, 0 
021d			;	ld hl,(de)	 
021d			 
021d			 
021d c9			    ret 
021e			 
021e			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
021e			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
021e			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
021e			 
021e			; INSTRUCTION SET 
021e			; READ 0000 0011 Read data from memory array beginning at selected address 
021e			; WRITE 0000 0010 Write data to memory array beginning at selected address 
021e			; WREN 0000 0110 Set the write enable latch (enable write operations) 
021e			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
021e			; RDSR 0000 0101 Read STATUS register 
021e			; WRSR 0000 0001 Write STATUS register 
021e			; PE 0100 0010 Page Erase – erase one page in memory array 
021e			; SE 1101 1000 Sector Erase – erase one sector in memory array 
021e			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
021e			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
021e			 
021e			; TODO send byte steam for page without setting the address for every single byte 
021e			; TODO read byte  
021e			 
021e			; byte in a 
021e			; address in hl  
021e			se_writebyte: 
021e			        
021e			    ;   ld c, a 
021e f5			        push af 
021f e5			        push hl 
0220			 
0220			    ; initi write mode 
0220			    ; 
0220			    ;CS low 
0220			 
0220 3a ee fb		       ld a,(spi_portbyte) 
0223 cd c7 01			call spi_ce_low 
0226			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0226 d3 80		       out (storage_adata),a 
0228 32 ee fb		       ld (spi_portbyte), a 
022b			 
022b			    ;clock out wren instruction 
022b			 
022b 3e 06		    ld a, store_wren_ins 
022d cd b5 00		    call spi_send_byte  
0230			 
0230			    ;cs high to enable write latch 
0230			 
0230 3a ee fb		       ld a,(spi_portbyte) 
0233 cd b6 01			call spi_ce_high 
0236			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0236 d3 80		       out (storage_adata),a 
0238 32 ee fb		       ld (spi_portbyte), a 
023b			 
023b 00				nop 
023c			    ; 
023c			    ; intial write data 
023c			    ; 
023c			    ; cs low 
023c			     
023c 3a ee fb		       ld a,(spi_portbyte) 
023f cd c7 01			call spi_ce_low 
0242			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0242 d3 80		       out (storage_adata),a 
0244 32 ee fb		       ld (spi_portbyte), a 
0247			 
0247			    ; clock out write instruction 
0247			     
0247 3e 02		    ld a, store_write_ins  
0249 cd b5 00		    call spi_send_byte  
024c			 
024c			    ; clock out address (depending on address size) 
024c			     
024c e1			    pop hl 
024d 7c			    ld a,h    ; address out msb first 
024e cd b5 00		    call spi_send_byte  
0251 7d			    ld a,l 
0252 cd b5 00		    call spi_send_byte  
0255			 
0255			    ; clock out byte(s) for page 
0255			 
0255 f1			    pop af 
0256 cd b5 00		    call spi_send_byte  
0259			 
0259			    ; end write with ce high 
0259 3a ee fb		       ld a,(spi_portbyte) 
025c			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025c cd b6 01			call spi_ce_high 
025f d3 80		       out (storage_adata),a 
0261 32 ee fb		       ld (spi_portbyte), a 
0264			 
0264				; pause for internal write cycle 
0264 3e 0a			ld a, 10 
0266 cd 77 0c			call aDelayInMS 
0269 c9			    ret 
026a			 
026a			; buffer to write in de 
026a			; address in hl  
026a			se_writepage: 
026a			        
026a			    ;   ld c, a 
026a d5				push de 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a ee fb		       ld a,(spi_portbyte) 
026f cd c7 01			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 ee fb		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd b5 00		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a ee fb		       ld a,(spi_portbyte) 
027f cd b6 01			call spi_ce_high 
0282			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 ee fb		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a ee fb		       ld a,(spi_portbyte) 
028b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028b cd c7 01			call spi_ce_low 
028e d3 80		       out (storage_adata),a 
0290 32 ee fb		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd b5 00		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd b5 00		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd b5 00		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 e1				pop hl 
02a2 06 40			ld b, STORE_BLOCK_PHY 
02a4			.bytewrite: 
02a4			 
02a4 7e				ld a,(hl) 
02a5 e5			    push hl 
02a6 c5				push bc 
02a7 cd b5 00		    call spi_send_byte  
02aa c1				pop bc 
02ab e1				pop hl 
02ac			 
02ac			    ; end write with ce high 
02ac 3a ee fb		       ld a,(spi_portbyte) 
02af cd b6 01			call spi_ce_high 
02b2			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b2 d3 80		       out (storage_adata),a 
02b4 32 ee fb		       ld (spi_portbyte), a 
02b7			 
02b7 23				inc hl 
02b8 10 ea			djnz .bytewrite 
02ba			 
02ba				; pause for internal write cycle 
02ba 3e 64			ld a, 100 
02bc cd 77 0c			call aDelayInMS 
02bf c9			    ret 
02c0			; returns byte in a 
02c0			; address in hl  
02c0			se_readbyte: 
02c0 d5				push de 
02c1 c5				push bc 
02c2			 
02c2			    ;   ld c, a 
02c2 e5			        push hl 
02c3			 
02c3			    ; initi write mode 
02c3			    ; 
02c3			    ;CS low 
02c3			 
02c3 3a ee fb		       ld a,(spi_portbyte) 
02c6 cd c7 01			call spi_ce_low 
02c9			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02c9 d3 80		       out (storage_adata),a 
02cb 32 ee fb		       ld (spi_portbyte), a 
02ce			 
02ce			    ;clock out wren instruction 
02ce			 
02ce 3e 03		    ld a, store_read_ins 
02d0 cd b5 00		    call spi_send_byte  
02d3			 
02d3			 
02d3			    ; clock out address (depending on address size) 
02d3			     
02d3 e1			    pop hl 
02d4 7c			    ld a,h    ; address out msb first 
02d5 cd b5 00		    call spi_send_byte  
02d8 7d			    ld a,l 
02d9 cd b5 00		    call spi_send_byte  
02dc			 
02dc			    ; clock in byte(s) for page 
02dc			 
02dc cd dc 00		    call spi_read_byte  
02df f5				push af 
02e0			 
02e0			    ; end write with ce high 
02e0 3a ee fb		       ld a,(spi_portbyte) 
02e3			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e3 cd b6 01			call spi_ce_high 
02e6 d3 80		       out (storage_adata),a 
02e8 32 ee fb		       ld (spi_portbyte), a 
02eb			 
02eb f1				pop af 
02ec			 
02ec c1				pop bc 
02ed d1				pop de 
02ee			 
02ee c9			    ret 
02ef			 
02ef			if DEBUG_STORESE 
02ef			 
02ef			storageput:  
02ef			 
02ef			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02ef			 
02ef 21 50 f3			ld hl,scratch+2 
02f2 cd 00 13			call get_word_hl 
02f5			 
02f5				; stuff it here for the moment as it will be overwritten later anyway 
02f5			 
02f5 22 71 f6			ld (os_cur_ptr),hl	 
02f8			 
02f8			 
02f8			; get pointer to start of string 
02f8			 
02f8 21 55 f3			ld hl, scratch+7 
02fb			 
02fb			; loop writing char of string to eeprom 
02fb			 
02fb 7e			.writestr:	ld a,(hl) 
02fc fe 00				cp 0 
02fe 28 12				jr z, .wsdone		; done writing 
0300 e5					push hl 
0301 2a 71 f6				ld hl,(os_cur_ptr) 
0304 cd 1e 02				call se_writebyte 
0307			 
0307 2a 71 f6				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030a 23					inc hl 
030b 22 71 f6				ld (os_cur_ptr),hl 
030e			 
030e					; restore string pointer and get next char 
030e			 
030e e1					pop hl 
030f 23					inc hl 
0310 18 e9				jr .writestr 
0312			 
0312			 
0312			 
0312			.wsdone: 
0312			 
0312			 
0312			; when done load first page into a buffer  
0312			 
0312 21 00 80				ld hl,08000h		; start in ram 
0315 22 71 f6				ld (os_cur_ptr),hl 
0318 21 00 00				ld hl, 0		 ; start of page 
031b 22 76 f3				ld (scratch+40),hl	; hang on to it 
031e			 
031e 06 80				ld b, 128		; actually get more then one page 
0320 c5			.wsload:	push bc 
0321 2a 76 f3				ld hl,(scratch+40) 
0324 e5					push hl 
0325 cd c0 02				call se_readbyte 
0328			 
0328					; a now as the byte 
0328			 
0328 2a 71 f6				ld hl,(os_cur_ptr) 
032b 77					ld (hl),a 
032c					; inc next buffer area 
032c 23					inc hl 
032d 22 71 f6				ld (os_cur_ptr),hl 
0330			 
0330					; get eeprom position, inc and save for next round 
0330 e1					pop hl		 
0331 23					inc hl 
0332 22 76 f3				ld (scratch+40),hl 
0335 c1					pop bc 
0336 10 e8				djnz .wsload 
0338			 
0338			; set 'd' pointer to start of buffer 
0338			 
0338 21 00 80				ld hl,08000h 
033b 22 71 f6				ld (os_cur_ptr),hl 
033e			 
033e			 
033e c9			ret 
033f			 
033f			 
033f c9			storageread: ret 
0340			 
0340			 
0340			 
0340			 
0340			 
0340			 
0340			endif 
0340			 
0340			 
0340			 
# End of file firmware_seeprom.asm
0340			else  
0340			   ; create some stubs for the labels  
0340			se_readbyte: ret  
0340			se_writebyte: ret  
0340			storage_init: ret  
0340			  
0340			endif  
0340			  
0340			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0340			;include "firmware_cf.asm"  
0340			  
0340			; load up high level storage hardward abstractions  
0340			include "firmware_storage.asm"  
0340			 
0340			; persisent storage hardware abstraction layer  
0340			 
0340			 
0340			 
0340			; Block 0 on storage is a config state 
0340			 
0340			 
0340			 
0340			; TODO add read phy block and write phy block functions 
0340			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0340			 
0340			; Abstraction layer  
0340			 
0340			; Logocial block size is same size as physical size - using tape concept 
0340			 
0340			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0340			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0340			 
0340			 
0340			 
0340			; Filesystem layout (Logical layout) 
0340			; 
0340			; Block 0 - Bank config  
0340			; 
0340			;      Byte - 0 file id counter 
0340			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0340			;      Byte - 3-20 zero terminated bank label 
0340			; 
0340			; Block 1 > File storage 
0340			; 
0340			;      Byte 0 file id    - block 0 file details 
0340			;      Byte 1 block id - block 0 is file  
0340			;            Byte 2-15 - File name 
0340			; 
0340			;       - to end of block data 
0340			; 
0340			 
0340			; Get ID for the file named in pointer held HL 
0340			; Returns ID in HL = 255 if no file found 
0340			 
0340			storage_getid: 
0340			 
0340 22 00 fc			ld (store_tmp1), hl 
0343			 
0343				if DEBUG_STORESE 
0343					DMARK "SGI" 
0343 f5				push af  
0344 3a 58 03			ld a, (.dmark)  
0347 32 b4 fe			ld (debug_mark),a  
034a 3a 59 03			ld a, (.dmark+1)  
034d 32 b5 fe			ld (debug_mark+1),a  
0350 3a 5a 03			ld a, (.dmark+2)  
0353 32 b6 fe			ld (debug_mark+2),a  
0356 18 03			jr .pastdmark  
0358 ..			.dmark: db "SGI"  
035b f1			.pastdmark: pop af  
035c			endm  
# End of macro DMARK
035c					CALLMONITOR 
035c cd c6 18			call break_point_state  
035f				endm  
# End of macro CALLMONITOR
035f				endif 
035f				; get block 0 and set counter for number of files to scan 
035f			 
035f cd ca 04			call storage_get_block_0 
0362			 
0362 3a 07 fc			ld a, (store_page) 
0365 47				ld b, a 
0366			 
0366				; get extent 0 of each file id 
0366			 
0366				if DEBUG_STORESE 
0366					DMARK "SGc" 
0366 f5				push af  
0367 3a 7b 03			ld a, (.dmark)  
036a 32 b4 fe			ld (debug_mark),a  
036d 3a 7c 03			ld a, (.dmark+1)  
0370 32 b5 fe			ld (debug_mark+1),a  
0373 3a 7d 03			ld a, (.dmark+2)  
0376 32 b6 fe			ld (debug_mark+2),a  
0379 18 03			jr .pastdmark  
037b ..			.dmark: db "SGc"  
037e f1			.pastdmark: pop af  
037f			endm  
# End of macro DMARK
037f					CALLMONITOR 
037f cd c6 18			call break_point_state  
0382				endm  
# End of macro CALLMONITOR
0382				endif 
0382 60			.getloop:	ld h, b 
0383 2e 00				ld l, 0 
0385 c5					push bc 
0386			 
0386 11 07 fc				ld de, store_page 
0389				if DEBUG_STORESE 
0389					DMARK "SGr" 
0389 f5				push af  
038a 3a 9e 03			ld a, (.dmark)  
038d 32 b4 fe			ld (debug_mark),a  
0390 3a 9f 03			ld a, (.dmark+1)  
0393 32 b5 fe			ld (debug_mark+1),a  
0396 3a a0 03			ld a, (.dmark+2)  
0399 32 b6 fe			ld (debug_mark+2),a  
039c 18 03			jr .pastdmark  
039e ..			.dmark: db "SGr"  
03a1 f1			.pastdmark: pop af  
03a2			endm  
# End of macro DMARK
03a2					CALLMONITOR 
03a2 cd c6 18			call break_point_state  
03a5				endm  
# End of macro CALLMONITOR
03a5				endif 
03a5 cd 72 09				call storage_read 
03a8 cd 72 0f				call ishlzero 
03ab 28 2d				jr z, .gap 
03ad					 
03ad					; have a file name read. Is it one we want. 
03ad			 
03ad 2a 00 fc				ld hl, (store_tmp1) 
03b0 11 0a fc				ld de, store_page+3   ; file name 
03b3			 
03b3				if DEBUG_STORESE 
03b3					DMARK "SGc" 
03b3 f5				push af  
03b4 3a c8 03			ld a, (.dmark)  
03b7 32 b4 fe			ld (debug_mark),a  
03ba 3a c9 03			ld a, (.dmark+1)  
03bd 32 b5 fe			ld (debug_mark+1),a  
03c0 3a ca 03			ld a, (.dmark+2)  
03c3 32 b6 fe			ld (debug_mark+2),a  
03c6 18 03			jr .pastdmark  
03c8 ..			.dmark: db "SGc"  
03cb f1			.pastdmark: pop af  
03cc			endm  
# End of macro DMARK
03cc					CALLMONITOR 
03cc cd c6 18			call break_point_state  
03cf				endm  
# End of macro CALLMONITOR
03cf				endif 
03cf cd df 13				call strcmp 
03d2 20 06				jr nz, .gap   ; not this one 
03d4			 
03d4 c1				        pop bc 
03d5			 
03d5 26 00				ld h, 0 
03d7 68					ld l, b 
03d8 18 22				jr .getdone 
03da						 
03da			 
03da			 
03da			 
03da			.gap: 
03da				if DEBUG_STORESE 
03da					DMARK "SGg" 
03da f5				push af  
03db 3a ef 03			ld a, (.dmark)  
03de 32 b4 fe			ld (debug_mark),a  
03e1 3a f0 03			ld a, (.dmark+1)  
03e4 32 b5 fe			ld (debug_mark+1),a  
03e7 3a f1 03			ld a, (.dmark+2)  
03ea 32 b6 fe			ld (debug_mark+2),a  
03ed 18 03			jr .pastdmark  
03ef ..			.dmark: db "SGg"  
03f2 f1			.pastdmark: pop af  
03f3			endm  
# End of macro DMARK
03f3					CALLMONITOR 
03f3 cd c6 18			call break_point_state  
03f6				endm  
# End of macro CALLMONITOR
03f6				endif 
03f6			 
03f6 c1					pop bc 
03f7 10 89				djnz .getloop 
03f9 21 ff 00				ld hl, 255 
03fc			.getdone: 
03fc			 
03fc				if DEBUG_STORESE 
03fc					DMARK "SGe" 
03fc f5				push af  
03fd 3a 11 04			ld a, (.dmark)  
0400 32 b4 fe			ld (debug_mark),a  
0403 3a 12 04			ld a, (.dmark+1)  
0406 32 b5 fe			ld (debug_mark+1),a  
0409 3a 13 04			ld a, (.dmark+2)  
040c 32 b6 fe			ld (debug_mark+2),a  
040f 18 03			jr .pastdmark  
0411 ..			.dmark: db "SGe"  
0414 f1			.pastdmark: pop af  
0415			endm  
# End of macro DMARK
0415					CALLMONITOR 
0415 cd c6 18			call break_point_state  
0418				endm  
# End of macro CALLMONITOR
0418				endif 
0418			 
0418 c9				ret 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			; Read Block 
0419			; ---------- 
0419			; 
0419			; With current bank 
0419			;  
0419			; Get block number to read 
0419			; Load physical blocks starting at start block into buffer 
0419			 
0419			; de points to buffer to use 
0419			; hl holds logical block number  
0419			 
0419			storage_read_block: 
0419			 
0419				; TODO bank selection 
0419			 
0419				; for each of the physical blocks read it into the buffer 
0419 06 40			ld b, STORE_BLOCK_PHY 
041b			 
041b				if DEBUG_STORESE 
041b d5					push de 
041c				endif 
041c				 
041c			.rl1:    
041c			 
041c				; read physical block at hl into de 
041c			        ; increment hl and de to next read position on exit 
041c			 
041c e5				push hl 
041d d5				push de	 
041e c5				push bc 
041f			;	if DEBUG_STORESE 
041f			;		push af 
041f			;		ld a, 'R' 
041f			;		ld (debug_mark),a 
041f			;		pop af 
041f			;		CALLMONITOR 
041f			;	endif 
041f cd c0 02			call se_readbyte 
0422			;	if DEBUG_STORESE 
0422			;		ld a,(spi_portbyte) 
0422			;		ld l, a 
0422			;		push af 
0422			;		ld a, '1' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 c1				pop bc 
0423 d1				pop de 
0424 e1				pop hl 
0425 12				ld (de),a 
0426 23				inc hl 
0427 13				inc de 
0428			 
0428			;	if DEBUG_STORESE 
0428			;		push af 
0428			;		ld a, 'r' 
0428			;		ld (debug_mark),a 
0428			;		pop af 
0428			;		CALLMONITOR 
0428			;	endif 
0428			 
0428 10 f2			djnz .rl1 
042a			 
042a				if DEBUG_STORESE 
042a					DMARK "SRB" 
042a f5				push af  
042b 3a 3f 04			ld a, (.dmark)  
042e 32 b4 fe			ld (debug_mark),a  
0431 3a 40 04			ld a, (.dmark+1)  
0434 32 b5 fe			ld (debug_mark+1),a  
0437 3a 41 04			ld a, (.dmark+2)  
043a 32 b6 fe			ld (debug_mark+2),a  
043d 18 03			jr .pastdmark  
043f ..			.dmark: db "SRB"  
0442 f1			.pastdmark: pop af  
0443			endm  
# End of macro DMARK
0443 d1					pop de 
0444			; 
0444			;		push af 
0444			;		ld a, 'R' 
0444			;		ld (debug_mark),a 
0444			;		pop af 
0444					CALLMONITOR 
0444 cd c6 18			call break_point_state  
0447				endm  
# End of macro CALLMONITOR
0447				endif 
0447 c9				ret	 
0448				 
0448			 
0448			; File Size 
0448			; --------- 
0448			; 
0448			;   hl file id 
0448			; 
0448			;  returns in hl the number of blocks 
0448			 
0448			storage_file_size: 
0448 5d				ld e, l 
0449 16 00			ld d, 0 
044b 21 40 00			ld hl, STORE_BLOCK_PHY 
044e					if DEBUG_FORTH_WORDS 
044e						DMARK "SIZ" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 b4 fe			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 b5 fe			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 b6 fe			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "SIZ"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467						CALLMONITOR 
0467 cd c6 18			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a					endif 
046a cd 4c 07			call storage_findnextid 
046d			 
046d cd 72 0f			call ishlzero 
0470			;	ld a, l 
0470			;	add h 
0470			;	cp 0 
0470 c8				ret z			; block not found so EOF 
0471			 
0471 11 07 fc			ld de, store_page 
0474 cd 19 04			call storage_read_block 
0477			 
0477 3a 09 fc			ld a, (store_page+2)	 ; get extent count 
047a 6f				ld l, a 
047b 26 00			ld h, 0 
047d c9			 	ret 
047e			 
047e			 
047e			; Write Block 
047e			; ----------- 
047e			; 
047e			; With current bank 
047e			;  
047e			; Get block number to write 
047e			; Write physical blocks starting at start block from buffer 
047e			  
047e			storage_write_block: 
047e				; TODO bank selection 
047e			 
047e				; for each of the physical blocks read it into the buffer 
047e 06 40			ld b, STORE_BLOCK_PHY 
0480			 
0480				if DEBUG_STORESE 
0480					DMARK "SWB" 
0480 f5				push af  
0481 3a 95 04			ld a, (.dmark)  
0484 32 b4 fe			ld (debug_mark),a  
0487 3a 96 04			ld a, (.dmark+1)  
048a 32 b5 fe			ld (debug_mark+1),a  
048d 3a 97 04			ld a, (.dmark+2)  
0490 32 b6 fe			ld (debug_mark+2),a  
0493 18 03			jr .pastdmark  
0495 ..			.dmark: db "SWB"  
0498 f1			.pastdmark: pop af  
0499			endm  
# End of macro DMARK
0499			 
0499					;push af 
0499					;ld a, 'W' 
0499					;ld (debug_mark),a 
0499					;pop af 
0499					CALLMONITOR 
0499 cd c6 18			call break_point_state  
049c				endm  
# End of macro CALLMONITOR
049c				endif 
049c			 
049c			; might not be working 
049c			;	call se_writepage 
049c			 
049c			;	ret 
049c			; 
049c			 
049c			 
049c			 
049c			.wl1:    
049c			 
049c				; read physical block at hl into de 
049c			        ; increment hl and de to next read position on exit 
049c			 
049c e5				push hl 
049d d5				push de	 
049e c5				push bc 
049f 1a				ld a,(de) 
04a0				;if DEBUG_STORESE 
04a0			;		push af 
04a0			;		ld a, 'W' 
04a0			;		ld (debug_mark),a 
04a0			;		pop af 
04a0			;		CALLMONITOR 
04a0			;	endif 
04a0 cd 1e 02			call se_writebyte 
04a3			;	call delay250ms 
04a3 00				nop 
04a4 00				nop 
04a5 00				nop 
04a6			;	if DEBUG_STORESE 
04a6			;		push af 
04a6			;		ld a, 'w' 
04a6			;		ld (debug_mark),a 
04a6			;		pop af 
04a6			;		CALLMONITOR 
04a6			;	endif 
04a6 c1				pop bc 
04a7 d1				pop de 
04a8 e1				pop hl 
04a9 23				inc hl 
04aa 13				inc de 
04ab			 
04ab			 
04ab 10 ef			djnz .wl1 
04ad			 
04ad				if DEBUG_STORESE 
04ad					DMARK "SW2" 
04ad f5				push af  
04ae 3a c2 04			ld a, (.dmark)  
04b1 32 b4 fe			ld (debug_mark),a  
04b4 3a c3 04			ld a, (.dmark+1)  
04b7 32 b5 fe			ld (debug_mark+1),a  
04ba 3a c4 04			ld a, (.dmark+2)  
04bd 32 b6 fe			ld (debug_mark+2),a  
04c0 18 03			jr .pastdmark  
04c2 ..			.dmark: db "SW2"  
04c5 f1			.pastdmark: pop af  
04c6			endm  
# End of macro DMARK
04c6			 
04c6					;push af 
04c6					;ld a, 'W' 
04c6					;ld (debug_mark),a 
04c6					;pop af 
04c6					CALLMONITOR 
04c6 cd c6 18			call break_point_state  
04c9				endm  
# End of macro CALLMONITOR
04c9				endif 
04c9 c9				ret	 
04ca			 
04ca			; Init bank 
04ca			; --------- 
04ca			; 
04ca			; With current bank 
04ca			; 
04ca			; Setup block 0 config 
04ca			;     Set 0 file id counter 
04ca			;     Set formatted byte pattern 
04ca			;     Zero out bank label 
04ca			;      
04ca			; For every logical block write 0-1 byte as null 
04ca			 
04ca			storage_get_block_0: 
04ca			 
04ca				; TODO check presence 
04ca			 
04ca				; get block 0 config 
04ca			 
04ca 21 00 00			ld hl, 0 
04cd 11 07 fc			ld de, store_page 
04d0 cd 19 04			call storage_read_block 
04d3			 
04d3				if DEBUG_STORESE 
04d3					DMARK "SB0" 
04d3 f5				push af  
04d4 3a e8 04			ld a, (.dmark)  
04d7 32 b4 fe			ld (debug_mark),a  
04da 3a e9 04			ld a, (.dmark+1)  
04dd 32 b5 fe			ld (debug_mark+1),a  
04e0 3a ea 04			ld a, (.dmark+2)  
04e3 32 b6 fe			ld (debug_mark+2),a  
04e6 18 03			jr .pastdmark  
04e8 ..			.dmark: db "SB0"  
04eb f1			.pastdmark: pop af  
04ec			endm  
# End of macro DMARK
04ec 11 07 fc				ld de, store_page 
04ef			;		push af 
04ef			;		ld a, 'i' 
04ef			;		ld (debug_mark),a 
04ef			;		pop af 
04ef					CALLMONITOR 
04ef cd c6 18			call break_point_state  
04f2				endm  
# End of macro CALLMONITOR
04f2				endif 
04f2			 
04f2				; is this area formatted? 
04f2			 
04f2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f2 2a 08 fc			ld hl, (store_page+1) 
04f5 3e 80			ld a,0x80 
04f7 bd				cp l 
04f8 20 22			jr nz, .ininotformatted 
04fa				; do a double check 
04fa 3e 27			ld a, 0x27 
04fc bc				cp h 
04fd 20 1d			jr nz, .ininotformatted 
04ff			 
04ff				; formatted then 
04ff			 
04ff				if DEBUG_STORESE 
04ff					DMARK "SB1" 
04ff f5				push af  
0500 3a 14 05			ld a, (.dmark)  
0503 32 b4 fe			ld (debug_mark),a  
0506 3a 15 05			ld a, (.dmark+1)  
0509 32 b5 fe			ld (debug_mark+1),a  
050c 3a 16 05			ld a, (.dmark+2)  
050f 32 b6 fe			ld (debug_mark+2),a  
0512 18 03			jr .pastdmark  
0514 ..			.dmark: db "SB1"  
0517 f1			.pastdmark: pop af  
0518			endm  
# End of macro DMARK
0518					;push af 
0518					;ld a, 'I' 
0518					;ld (debug_mark),a 
0518					;pop af 
0518					CALLMONITOR 
0518 cd c6 18			call break_point_state  
051b				endm  
# End of macro CALLMONITOR
051b				endif 
051b c9				ret 
051c			 
051c			.ininotformatted: 
051c				; bank not formatted so poke various bits to make sure 
051c			 
051c				if DEBUG_STORESE 
051c					DMARK "SB2" 
051c f5				push af  
051d 3a 31 05			ld a, (.dmark)  
0520 32 b4 fe			ld (debug_mark),a  
0523 3a 32 05			ld a, (.dmark+1)  
0526 32 b5 fe			ld (debug_mark+1),a  
0529 3a 33 05			ld a, (.dmark+2)  
052c 32 b6 fe			ld (debug_mark+2),a  
052f 18 03			jr .pastdmark  
0531 ..			.dmark: db "SB2"  
0534 f1			.pastdmark: pop af  
0535			endm  
# End of macro DMARK
0535					;push af 
0535					;ld a, 'f' 
0535					;ld (debug_mark),a 
0535					;pop af 
0535					CALLMONITOR 
0535 cd c6 18			call break_point_state  
0538				endm  
# End of macro CALLMONITOR
0538				endif 
0538			 
0538 cd 55 0c			call storage_clear_page 
053b			 
053b 21 07 fc			ld hl, store_page 
053e 3e 00			ld a, 0 
0540				 
0540 77				ld (hl),a   ; reset file counter 
0541			 
0541 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0544 22 08 fc		 	ld (store_page+1), hl	 
0547			 
0547				; set default label 
0547			 
0547 21 e3 05			ld hl, .defaultbanklabl 
054a 11 0a fc		 	ld de, store_page+3 
054d 01 0f 00			ld bc, 15 
0550 ed b0			ldir 
0552			 
0552				; Append the current bank id 
0552 21 13 fc			ld hl, store_page+3+9 
0555 3a ec fb			ld a, (spi_device_id) 
0558 77				ld (hl), a 
0559			 
0559				; save default page 0 
0559			 
0559 21 00 00			ld hl, 0 
055c 11 07 fc			ld de, store_page 
055f				if DEBUG_STORESE 
055f					DMARK "SB3" 
055f f5				push af  
0560 3a 74 05			ld a, (.dmark)  
0563 32 b4 fe			ld (debug_mark),a  
0566 3a 75 05			ld a, (.dmark+1)  
0569 32 b5 fe			ld (debug_mark+1),a  
056c 3a 76 05			ld a, (.dmark+2)  
056f 32 b6 fe			ld (debug_mark+2),a  
0572 18 03			jr .pastdmark  
0574 ..			.dmark: db "SB3"  
0577 f1			.pastdmark: pop af  
0578			endm  
# End of macro DMARK
0578			;		push af 
0578			;		ld a, 'F' 
0578			;		ld (debug_mark),a 
0578			;		pop af 
0578					CALLMONITOR 
0578 cd c6 18			call break_point_state  
057b				endm  
# End of macro CALLMONITOR
057b				endif 
057b cd 7e 04			call storage_write_block 
057e				if DEBUG_STORESE 
057e					DMARK "SB4" 
057e f5				push af  
057f 3a 93 05			ld a, (.dmark)  
0582 32 b4 fe			ld (debug_mark),a  
0585 3a 94 05			ld a, (.dmark+1)  
0588 32 b5 fe			ld (debug_mark+1),a  
058b 3a 95 05			ld a, (.dmark+2)  
058e 32 b6 fe			ld (debug_mark+2),a  
0591 18 03			jr .pastdmark  
0593 ..			.dmark: db "SB4"  
0596 f1			.pastdmark: pop af  
0597			endm  
# End of macro DMARK
0597			;		push af 
0597			;		ld a, '>' 
0597			;		ld (debug_mark),a 
0597			;		pop af 
0597					CALLMONITOR 
0597 cd c6 18			call break_point_state  
059a				endm  
# End of macro CALLMONITOR
059a				endif 
059a			 
059a 00				nop 
059b 00				nop 
059c 00				nop 
059d			 
059d				; now set 0 in every page to mark as a free block 
059d			 
059d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
059f 21 40 00			ld hl, STORE_BLOCK_PHY 
05a2			 
05a2 3e 00		.setmark1:   	ld a,0 
05a4 e5					push hl 
05a5 c5					push bc 
05a6 cd 1e 02				call se_writebyte 
05a9 3e 0a			ld a, 10 
05ab cd 77 0c			call aDelayInMS 
05ae 23				inc hl 
05af cd 1e 02				call se_writebyte 
05b2 3e 0a			ld a, 10 
05b4 cd 77 0c			call aDelayInMS 
05b7 2b				dec hl 
05b8 c1					pop bc 
05b9 e1					pop hl 
05ba 3e 40				ld a, STORE_BLOCK_PHY 
05bc cd 49 0f				call addatohl 
05bf 10 e1				djnz .setmark1 
05c1			 
05c1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c3 3e 00		.setmark2:   	ld a,0 
05c5 e5					push hl 
05c6 c5					push bc 
05c7 cd 1e 02				call se_writebyte 
05ca 3e 0a			ld a, 10 
05cc cd 77 0c			call aDelayInMS 
05cf 23				inc hl 
05d0 cd 1e 02				call se_writebyte 
05d3 3e 0a			ld a, 10 
05d5 cd 77 0c			call aDelayInMS 
05d8 2b				dec hl 
05d9 c1					pop bc 
05da e1					pop hl 
05db 3e 40				ld a, STORE_BLOCK_PHY 
05dd cd 49 0f				call addatohl 
05e0 10 e1				djnz .setmark2 
05e2			 
05e2					 
05e2			 
05e2			 
05e2 c9				ret 
05e3			 
05e3			 
05e3			 
05e3			 
05e3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05ee			 
05ee			 
05ee			 
05ee			; Label Bank 
05ee			; ---------- 
05ee			; 
05ee			; With current bank 
05ee			; Read block 0 
05ee			; Set label 
05ee			; Write block 0 
05ee			 
05ee			; label str pointer in hl 
05ee			 
05ee			storage_label:     
05ee			 
05ee				if DEBUG_STORESE 
05ee					DMARK "LBL" 
05ee f5				push af  
05ef 3a 03 06			ld a, (.dmark)  
05f2 32 b4 fe			ld (debug_mark),a  
05f5 3a 04 06			ld a, (.dmark+1)  
05f8 32 b5 fe			ld (debug_mark+1),a  
05fb 3a 05 06			ld a, (.dmark+2)  
05fe 32 b6 fe			ld (debug_mark+2),a  
0601 18 03			jr .pastdmark  
0603 ..			.dmark: db "LBL"  
0606 f1			.pastdmark: pop af  
0607			endm  
# End of macro DMARK
0607					CALLMONITOR 
0607 cd c6 18			call break_point_state  
060a				endm  
# End of macro CALLMONITOR
060a				endif 
060a			 
060a e5				push hl 
060b			 
060b cd ca 04			call storage_get_block_0 
060e			 
060e				; set default label 
060e			 
060e e1				pop hl 
060f			 
060f 11 0a fc		 	ld de, store_page+3 
0612 01 0f 00			ld bc, 15 
0615				if DEBUG_STORESE 
0615					DMARK "LB3" 
0615 f5				push af  
0616 3a 2a 06			ld a, (.dmark)  
0619 32 b4 fe			ld (debug_mark),a  
061c 3a 2b 06			ld a, (.dmark+1)  
061f 32 b5 fe			ld (debug_mark+1),a  
0622 3a 2c 06			ld a, (.dmark+2)  
0625 32 b6 fe			ld (debug_mark+2),a  
0628 18 03			jr .pastdmark  
062a ..			.dmark: db "LB3"  
062d f1			.pastdmark: pop af  
062e			endm  
# End of macro DMARK
062e					CALLMONITOR 
062e cd c6 18			call break_point_state  
0631				endm  
# End of macro CALLMONITOR
0631				endif 
0631 ed b0			ldir 
0633				; save default page 0 
0633			 
0633 21 00 00			ld hl, 0 
0636 11 07 fc			ld de, store_page 
0639				if DEBUG_STORESE 
0639					DMARK "LBW" 
0639 f5				push af  
063a 3a 4e 06			ld a, (.dmark)  
063d 32 b4 fe			ld (debug_mark),a  
0640 3a 4f 06			ld a, (.dmark+1)  
0643 32 b5 fe			ld (debug_mark+1),a  
0646 3a 50 06			ld a, (.dmark+2)  
0649 32 b6 fe			ld (debug_mark+2),a  
064c 18 03			jr .pastdmark  
064e ..			.dmark: db "LBW"  
0651 f1			.pastdmark: pop af  
0652			endm  
# End of macro DMARK
0652					CALLMONITOR 
0652 cd c6 18			call break_point_state  
0655				endm  
# End of macro CALLMONITOR
0655				endif 
0655 cd 7e 04			call storage_write_block 
0658			 
0658 c9				ret 
0659			 
0659			 
0659			 
0659			; Read Block 0 - Config 
0659			; --------------------- 
0659			; 
0659			; With current bank 
0659			; Call presence test 
0659			;    If not present format/init bank  
0659			; Read block 0  
0659			;  
0659			 
0659			 
0659			; Dir 
0659			; --- 
0659			; 
0659			; With current bank 
0659			; Load Block 0 Config 
0659			; Get max file id number 
0659			; For each logical block 
0659			;    Read block read byte 2 
0659			;      if first block of file 
0659			;         Display file name 
0659			;         Display type flags for file 
0659			;        
0659			 
0659			; moving to words as this requires stack control 
0659			 
0659			 
0659			; Delete File 
0659			; ----------- 
0659			; 
0659			; With current bank 
0659			; 
0659			; Load Block 0 Config 
0659			; Get max file id number 
0659			; For each logical block 
0659			;    Read block file id 
0659			;      If first block of file and dont have file id 
0659			;         if file to delete 
0659			;         Save file id 
0659			;         Null file id 
0659			;         Write this block back 
0659			;      If file id is one saved 
0659			;         Null file id 
0659			;         Write this block back 
0659			 
0659			 
0659			.se_done: 
0659 e1				pop hl 
065a c9				ret 
065b			 
065b			storage_erase: 
065b			 
065b				; hl contains the file id 
065b			 
065b 5d				ld e, l 
065c 16 00			ld d, 0 
065e 21 40 00			ld hl, STORE_BLOCK_PHY 
0661					if DEBUG_FORTH_WORDS 
0661						DMARK "ERA" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 b4 fe			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 b5 fe			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 b6 fe			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "ERA"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a						CALLMONITOR 
067a cd c6 18			call break_point_state  
067d				endm  
# End of macro CALLMONITOR
067d					endif 
067d cd 4c 07			call storage_findnextid 
0680 cd 72 0f			call ishlzero 
0683 c8				ret z 
0684			 
0684 e5				push hl 
0685			 
0685				; TODO check file not found 
0685			 
0685 11 07 fc			ld de, store_page 
0688 cd 19 04			call storage_read_block 
068b			 
068b cd 72 0f			call ishlzero 
068e ca 59 06			jp z,.se_done 
0691			 
0691					if DEBUG_FORTH_WORDS 
0691						DMARK "ER1" 
0691 f5				push af  
0692 3a a6 06			ld a, (.dmark)  
0695 32 b4 fe			ld (debug_mark),a  
0698 3a a7 06			ld a, (.dmark+1)  
069b 32 b5 fe			ld (debug_mark+1),a  
069e 3a a8 06			ld a, (.dmark+2)  
06a1 32 b6 fe			ld (debug_mark+2),a  
06a4 18 03			jr .pastdmark  
06a6 ..			.dmark: db "ER1"  
06a9 f1			.pastdmark: pop af  
06aa			endm  
# End of macro DMARK
06aa						CALLMONITOR 
06aa cd c6 18			call break_point_state  
06ad				endm  
# End of macro CALLMONITOR
06ad					endif 
06ad 3a 07 fc			ld a, (store_page)	; get file id 
06b0 32 fb fb			ld (store_tmpid), a 
06b3			 
06b3 3a 09 fc			ld a, (store_page+2)    ; get count of extends 
06b6 32 fa fb			ld (store_tmpext), a 
06b9			 
06b9				; wipe file header 
06b9			 
06b9 e1				pop hl 
06ba 3e 00			ld a, 0 
06bc 32 07 fc			ld (store_page), a 
06bf 32 08 fc			ld (store_page+1),a 
06c2 11 07 fc			ld de, store_page 
06c5					if DEBUG_FORTH_WORDS 
06c5						DMARK "ER2" 
06c5 f5				push af  
06c6 3a da 06			ld a, (.dmark)  
06c9 32 b4 fe			ld (debug_mark),a  
06cc 3a db 06			ld a, (.dmark+1)  
06cf 32 b5 fe			ld (debug_mark+1),a  
06d2 3a dc 06			ld a, (.dmark+2)  
06d5 32 b6 fe			ld (debug_mark+2),a  
06d8 18 03			jr .pastdmark  
06da ..			.dmark: db "ER2"  
06dd f1			.pastdmark: pop af  
06de			endm  
# End of macro DMARK
06de						CALLMONITOR 
06de cd c6 18			call break_point_state  
06e1				endm  
# End of macro CALLMONITOR
06e1					endif 
06e1 cd 7e 04			call storage_write_block 
06e4			 
06e4			 
06e4				; wipe file extents 
06e4			 
06e4 3a fa fb			ld a, (store_tmpext) 
06e7 47				ld b, a 
06e8			 
06e8			.eraext:	  
06e8 c5				push bc 
06e9			 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 3a fb fb			ld a,(store_tmpid) 
06ef 5f				ld e, a 
06f0 50				ld d, b	 
06f1					if DEBUG_FORTH_WORDS 
06f1						DMARK "ER3" 
06f1 f5				push af  
06f2 3a 06 07			ld a, (.dmark)  
06f5 32 b4 fe			ld (debug_mark),a  
06f8 3a 07 07			ld a, (.dmark+1)  
06fb 32 b5 fe			ld (debug_mark+1),a  
06fe 3a 08 07			ld a, (.dmark+2)  
0701 32 b6 fe			ld (debug_mark+2),a  
0704 18 03			jr .pastdmark  
0706 ..			.dmark: db "ER3"  
0709 f1			.pastdmark: pop af  
070a			endm  
# End of macro DMARK
070a						CALLMONITOR 
070a cd c6 18			call break_point_state  
070d				endm  
# End of macro CALLMONITOR
070d					endif 
070d cd 4c 07			call storage_findnextid 
0710 cd 72 0f			call ishlzero 
0713 ca 59 06			jp z,.se_done 
0716			 
0716 e5				push hl 
0717 11 07 fc			ld de, store_page 
071a cd 19 04			call storage_read_block 
071d			 
071d				; free block	 
071d			 
071d 3e 00			ld a, 0 
071f 32 07 fc			ld (store_page), a 
0722 32 08 fc			ld (store_page+1),a 
0725 11 07 fc			ld de, store_page 
0728 e1				pop hl 
0729					if DEBUG_FORTH_WORDS 
0729						DMARK "ER4" 
0729 f5				push af  
072a 3a 3e 07			ld a, (.dmark)  
072d 32 b4 fe			ld (debug_mark),a  
0730 3a 3f 07			ld a, (.dmark+1)  
0733 32 b5 fe			ld (debug_mark+1),a  
0736 3a 40 07			ld a, (.dmark+2)  
0739 32 b6 fe			ld (debug_mark+2),a  
073c 18 03			jr .pastdmark  
073e ..			.dmark: db "ER4"  
0741 f1			.pastdmark: pop af  
0742			endm  
# End of macro DMARK
0742						CALLMONITOR 
0742 cd c6 18			call break_point_state  
0745				endm  
# End of macro CALLMONITOR
0745					endif 
0745 cd 7e 04			call storage_write_block 
0748			 
0748 c1				pop bc 
0749 10 9d			djnz .eraext 
074b			 
074b c9				ret 
074c			 
074c			 
074c			; Find Free Block 
074c			; --------------- 
074c			; 
074c			; With current bank 
074c			;  
074c			; From given starting logical block 
074c			;    Read block  
074c			;    If no file id 
074c			;         Return block id 
074c			 
074c			 
074c			; hl starting page number 
074c			; hl contains free page number or zero if no pages free 
074c			; e contains the file id to locate 
074c			; d contains the block number 
074c			 
074c			; TODO change to find file id and use zero for free block 
074c			 
074c			storage_findnextid: 
074c			 
074c				; now locate first 0 page to mark as a free block 
074c			 
074c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
074e			;	ld hl, STORE_BLOCK_PHY 
074e			 
074e					if DEBUG_FORTH_WORDS 
074e					DMARK "FNI" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 b4 fe			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 b5 fe			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 b6 fe			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "FNI"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767						CALLMONITOR 
0767 cd c6 18			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a					endif 
076a			.ff1:   	 
076a e5					push hl 
076b c5					push bc 
076c d5					push de 
076d cd c0 02				call se_readbyte 
0770 5f					ld e,a 
0771 23					inc hl 
0772 cd c0 02				call se_readbyte 
0775 57					ld d, a 
0776 e1					pop hl 
0777 e5					push hl 
0778 cd 67 0f				call cmp16 
077b 28 49				jr z, .fffound 
077d			 
077d d1					pop de 
077e c1					pop bc 
077f e1					pop hl 
0780			 
0780					; is found? 
0780					;cp e 
0780					;ret z 
0780			 
0780 3e 40				ld a, STORE_BLOCK_PHY 
0782 cd 49 0f				call addatohl 
0785 10 e3				djnz .ff1 
0787			 
0787 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0789			.ff2:   	 
0789			 
0789 e5					push hl 
078a c5					push bc 
078b d5					push de 
078c cd c0 02				call se_readbyte 
078f 5f					ld e,a 
0790 23					inc hl 
0791 cd c0 02				call se_readbyte 
0794 57					ld d, a 
0795			 
0795 e1					pop hl 
0796 e5					push hl 
0797 cd 67 0f				call cmp16 
079a 28 2a				jr z, .fffound 
079c			 
079c d1					pop de 
079d c1					pop bc 
079e e1					pop hl 
079f					; is found? 
079f					;cp e 
079f					;ret z 
079f			 
079f 3e 40				ld a, STORE_BLOCK_PHY 
07a1 cd 49 0f				call addatohl 
07a4 10 e3				djnz .ff2 
07a6			 
07a6			 
07a6					if DEBUG_FORTH_WORDS 
07a6					DMARK "FN-" 
07a6 f5				push af  
07a7 3a bb 07			ld a, (.dmark)  
07aa 32 b4 fe			ld (debug_mark),a  
07ad 3a bc 07			ld a, (.dmark+1)  
07b0 32 b5 fe			ld (debug_mark+1),a  
07b3 3a bd 07			ld a, (.dmark+2)  
07b6 32 b6 fe			ld (debug_mark+2),a  
07b9 18 03			jr .pastdmark  
07bb ..			.dmark: db "FN-"  
07be f1			.pastdmark: pop af  
07bf			endm  
# End of macro DMARK
07bf					;	push af 
07bf					;	ld a, 'n' 
07bf					;	ld (debug_mark),a 
07bf					;	pop af 
07bf						CALLMONITOR 
07bf cd c6 18			call break_point_state  
07c2				endm  
# End of macro CALLMONITOR
07c2					endif 
07c2				; no free marks! 
07c2 21 00 00				ld hl, 0 
07c5 c9				ret 
07c6			.fffound: 
07c6				 
07c6			 
07c6 d1					pop de 
07c7 c1					pop bc 
07c8 e1					pop hl 
07c9					if DEBUG_FORTH_WORDS 
07c9					DMARK "FNF" 
07c9 f5				push af  
07ca 3a de 07			ld a, (.dmark)  
07cd 32 b4 fe			ld (debug_mark),a  
07d0 3a df 07			ld a, (.dmark+1)  
07d3 32 b5 fe			ld (debug_mark+1),a  
07d6 3a e0 07			ld a, (.dmark+2)  
07d9 32 b6 fe			ld (debug_mark+2),a  
07dc 18 03			jr .pastdmark  
07de ..			.dmark: db "FNF"  
07e1 f1			.pastdmark: pop af  
07e2			endm  
# End of macro DMARK
07e2					;	push af 
07e2					;	ld a, 'n' 
07e2					;	ld (debug_mark),a 
07e2					;	pop af 
07e2						CALLMONITOR 
07e2 cd c6 18			call break_point_state  
07e5				endm  
# End of macro CALLMONITOR
07e5					endif 
07e5 c9				ret 
07e6			 
07e6			 
07e6			 
07e6			; Free Space 
07e6			; ---------- 
07e6			; 
07e6			; With current bank 
07e6			; 
07e6			; Set block count to zero 
07e6			; Starting with first logical block 
07e6			;      Find free block  
07e6			;      If block id given, increment block count 
07e6			; 
07e6			;  
07e6			 
07e6			 
07e6			; hl contains count of free blocks 
07e6			 
07e6			storage_freeblocks: 
07e6			 
07e6				; now locate first 0 page to mark as a free block 
07e6			 
07e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e8 21 40 00			ld hl, STORE_BLOCK_PHY 
07eb 11 00 00			ld de, 0 
07ee			 
07ee			.fb1:   	 
07ee e5					push hl 
07ef c5					push bc 
07f0 d5					push de 
07f1 cd c0 02				call se_readbyte 
07f4 d1					pop de 
07f5 c1					pop bc 
07f6 e1					pop hl 
07f7			 
07f7					; is free? 
07f7 fe 00				cp 0 
07f9 20 01				jr nz, .ff1cont 
07fb 13					inc de 
07fc			 
07fc			.ff1cont: 
07fc			 
07fc			 
07fc 3e 40				ld a, STORE_BLOCK_PHY 
07fe cd 49 0f				call addatohl 
0801 10 eb				djnz .fb1 
0803			 
0803 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0805			.fb2:   	 
0805 e5					push hl 
0806 c5					push bc 
0807 d5					push de 
0808 cd c0 02				call se_readbyte 
080b d1					pop de 
080c c1					pop bc 
080d e1					pop hl 
080e			 
080e					; is free? 
080e fe 00				cp 0 
0810 20 01				jr nz, .ff2cont 
0812 13					inc de 
0813			 
0813			.ff2cont: 
0813			 
0813 3e 40				ld a, STORE_BLOCK_PHY 
0815 cd 49 0f				call addatohl 
0818 10 eb				djnz .fb2 
081a			 
081a eb				ex de, hl 
081b c9				ret 
081c			 
081c			; Get File ID 
081c			; ----------- 
081c			; 
081c			; With current bank 
081c			;  
081c			; Load Block 0 Config 
081c			; Get max file id number 
081c			; For each logical block 
081c			;    Read block file id 
081c			;      If first block of file and dont have file id 
081c			;         if file get id and exit 
081c			 
081c			 
081c			 
081c			 
081c			; Create File 
081c			; ----------- 
081c			; 
081c			; With current bank  
081c			; Load Block 0 Config 
081c			; Get max file id number 
081c			; Increment file id number 
081c			; Save Config 
081c			; Find free block 
081c			; Set buffer with file name and file id 
081c			; Write buffer to free block  
081c			 
081c			 
081c			; hl point to file name 
081c			; hl returns file id 
081c			 
081c			; file format: 
081c			; byte 0 - file id 
081c			; byte 1 - extent number 
081c			; byte 2-> data 
081c			 
081c			; format for extent number 0: 
081c			; 
081c			; byte 0 - file id 
081c			; byte 1 - extent 0 
081c			; byte 2 - extent count 
081c			; byte 3 -> file name and meta data 
081c			 
081c			 
081c			storage_create: 
081c				if DEBUG_STORESE 
081c					DMARK "SCR" 
081c f5				push af  
081d 3a 31 08			ld a, (.dmark)  
0820 32 b4 fe			ld (debug_mark),a  
0823 3a 32 08			ld a, (.dmark+1)  
0826 32 b5 fe			ld (debug_mark+1),a  
0829 3a 33 08			ld a, (.dmark+2)  
082c 32 b6 fe			ld (debug_mark+2),a  
082f 18 03			jr .pastdmark  
0831 ..			.dmark: db "SCR"  
0834 f1			.pastdmark: pop af  
0835			endm  
# End of macro DMARK
0835					CALLMONITOR 
0835 cd c6 18			call break_point_state  
0838				endm  
# End of macro CALLMONITOR
0838				endif 
0838			 
0838 e5				push hl		; save file name pointer 
0839			 
0839 cd ca 04			call storage_get_block_0 
083c			 
083c 3a 07 fc			ld a,(store_page)	; get current file id 
083f 3c				inc a 
0840 32 07 fc			ld (store_page),a 
0843				 
0843 32 fb fb			ld (store_tmpid),a			; save id 
0846			 
0846 21 00 00			ld hl, 0 
0849 11 07 fc			ld de, store_page 
084c				if DEBUG_STORESE 
084c					DMARK "SCw" 
084c f5				push af  
084d 3a 61 08			ld a, (.dmark)  
0850 32 b4 fe			ld (debug_mark),a  
0853 3a 62 08			ld a, (.dmark+1)  
0856 32 b5 fe			ld (debug_mark+1),a  
0859 3a 63 08			ld a, (.dmark+2)  
085c 32 b6 fe			ld (debug_mark+2),a  
085f 18 03			jr .pastdmark  
0861 ..			.dmark: db "SCw"  
0864 f1			.pastdmark: pop af  
0865			endm  
# End of macro DMARK
0865					CALLMONITOR 
0865 cd c6 18			call break_point_state  
0868				endm  
# End of macro CALLMONITOR
0868				endif 
0868 cd 7e 04			call storage_write_block	 ; save update 
086b			 
086b				if DEBUG_STORESE 
086b 11 07 fc				ld de, store_page 
086e					DMARK "SCC" 
086e f5				push af  
086f 3a 83 08			ld a, (.dmark)  
0872 32 b4 fe			ld (debug_mark),a  
0875 3a 84 08			ld a, (.dmark+1)  
0878 32 b5 fe			ld (debug_mark+1),a  
087b 3a 85 08			ld a, (.dmark+2)  
087e 32 b6 fe			ld (debug_mark+2),a  
0881 18 03			jr .pastdmark  
0883 ..			.dmark: db "SCC"  
0886 f1			.pastdmark: pop af  
0887			endm  
# End of macro DMARK
0887					CALLMONITOR 
0887 cd c6 18			call break_point_state  
088a				endm  
# End of macro CALLMONITOR
088a				endif 
088a				;  
088a				 
088a 21 40 00			ld hl, STORE_BLOCK_PHY 
088d 11 00 00			ld de, 0 
0890 cd 4c 07			call storage_findnextid 
0893			 
0893 22 f2 fb			ld (store_tmppageid), hl    ; save page to use  
0896			 
0896				; TODO detect 0 = no spare blocks 
0896			 
0896				; hl now contains the free page to use for the file header page 
0896			 
0896				if DEBUG_STORESE 
0896				DMARK "SCF" 
0896 f5				push af  
0897 3a ab 08			ld a, (.dmark)  
089a 32 b4 fe			ld (debug_mark),a  
089d 3a ac 08			ld a, (.dmark+1)  
08a0 32 b5 fe			ld (debug_mark+1),a  
08a3 3a ad 08			ld a, (.dmark+2)  
08a6 32 b6 fe			ld (debug_mark+2),a  
08a9 18 03			jr .pastdmark  
08ab ..			.dmark: db "SCF"  
08ae f1			.pastdmark: pop af  
08af			endm  
# End of macro DMARK
08af					CALLMONITOR 
08af cd c6 18			call break_point_state  
08b2				endm  
# End of macro CALLMONITOR
08b2				endif 
08b2			 
08b2 22 f2 fb			ld (store_tmppageid), hl 
08b5				 
08b5 3a fb fb			ld a,(store_tmpid)    ; get file id 
08b8			;	ld a, (store_filecache)			; save to cache 
08b8			 
08b8 32 07 fc			ld (store_page),a    ; set page id 
08bb 3e 00			ld a, 0			 ; extent 0 is file header 
08bd 32 08 fc			ld (store_page+1), a   ; set file extent 
08c0			 
08c0 32 09 fc			ld (store_page+2), a   ; extent count for the file 
08c3			 
08c3			;	inc hl 		; init block 0 of file 
08c3			;	inc hl   		; skip file and extent id 
08c3			 ;       ld a, 0 
08c3			;	ld (hl),a 
08c3			;	ld a, (store_filecache+1)  	; save to cache 
08c3			 
08c3			;	inc hl    ; file name 
08c3				 
08c3				 
08c3 11 0a fc			ld de, store_page+3    ; get buffer for term string to use as file name 
08c6				if DEBUG_STORESE 
08c6					DMARK "SCc" 
08c6 f5				push af  
08c7 3a db 08			ld a, (.dmark)  
08ca 32 b4 fe			ld (debug_mark),a  
08cd 3a dc 08			ld a, (.dmark+1)  
08d0 32 b5 fe			ld (debug_mark+1),a  
08d3 3a dd 08			ld a, (.dmark+2)  
08d6 32 b6 fe			ld (debug_mark+2),a  
08d9 18 03			jr .pastdmark  
08db ..			.dmark: db "SCc"  
08de f1			.pastdmark: pop af  
08df			endm  
# End of macro DMARK
08df					CALLMONITOR 
08df cd c6 18			call break_point_state  
08e2				endm  
# End of macro CALLMONITOR
08e2				endif 
08e2 e1				pop hl    ; get zero term string 
08e3 e5				push hl 
08e4 3e 00			ld a, 0 
08e6 cd b2 13			call strlent 
08e9 23				inc hl   ; cover zero term 
08ea 06 00			ld b,0 
08ec 4d				ld c,l 
08ed e1				pop hl 
08ee				;ex de, hl 
08ee				if DEBUG_STORESE 
08ee					DMARK "SCa" 
08ee f5				push af  
08ef 3a 03 09			ld a, (.dmark)  
08f2 32 b4 fe			ld (debug_mark),a  
08f5 3a 04 09			ld a, (.dmark+1)  
08f8 32 b5 fe			ld (debug_mark+1),a  
08fb 3a 05 09			ld a, (.dmark+2)  
08fe 32 b6 fe			ld (debug_mark+2),a  
0901 18 03			jr .pastdmark  
0903 ..			.dmark: db "SCa"  
0906 f1			.pastdmark: pop af  
0907			endm  
# End of macro DMARK
0907					;push af 
0907					;ld a, 'a' 
0907					;ld (debug_mark),a 
0907					;pop af 
0907					CALLMONITOR 
0907 cd c6 18			call break_point_state  
090a				endm  
# End of macro CALLMONITOR
090a				endif 
090a ed b0			ldir    ; copy zero term string 
090c				if DEBUG_STORESE 
090c					DMARK "SCA" 
090c f5				push af  
090d 3a 21 09			ld a, (.dmark)  
0910 32 b4 fe			ld (debug_mark),a  
0913 3a 22 09			ld a, (.dmark+1)  
0916 32 b5 fe			ld (debug_mark+1),a  
0919 3a 23 09			ld a, (.dmark+2)  
091c 32 b6 fe			ld (debug_mark+2),a  
091f 18 03			jr .pastdmark  
0921 ..			.dmark: db "SCA"  
0924 f1			.pastdmark: pop af  
0925			endm  
# End of macro DMARK
0925					CALLMONITOR 
0925 cd c6 18			call break_point_state  
0928				endm  
# End of macro CALLMONITOR
0928				endif 
0928			 
0928				; write file header page 
0928			 
0928 2a f2 fb			ld hl,(store_tmppageid) 
092b 11 07 fc			ld de, store_page 
092e				if DEBUG_STORESE 
092e					DMARK "SCb" 
092e f5				push af  
092f 3a 43 09			ld a, (.dmark)  
0932 32 b4 fe			ld (debug_mark),a  
0935 3a 44 09			ld a, (.dmark+1)  
0938 32 b5 fe			ld (debug_mark+1),a  
093b 3a 45 09			ld a, (.dmark+2)  
093e 32 b6 fe			ld (debug_mark+2),a  
0941 18 03			jr .pastdmark  
0943 ..			.dmark: db "SCb"  
0946 f1			.pastdmark: pop af  
0947			endm  
# End of macro DMARK
0947					;push af 
0947					;ld a, 'b' 
0947					;ld (debug_mark),a 
0947					;pop af 
0947					CALLMONITOR 
0947 cd c6 18			call break_point_state  
094a				endm  
# End of macro CALLMONITOR
094a				endif 
094a cd 7e 04			call storage_write_block 
094d			 
094d 3a fb fb			ld a, (store_tmpid) 
0950 6f				ld l, a 
0951 26 00			ld h,0 
0953				if DEBUG_STORESE 
0953					DMARK "SCz" 
0953 f5				push af  
0954 3a 68 09			ld a, (.dmark)  
0957 32 b4 fe			ld (debug_mark),a  
095a 3a 69 09			ld a, (.dmark+1)  
095d 32 b5 fe			ld (debug_mark+1),a  
0960 3a 6a 09			ld a, (.dmark+2)  
0963 32 b6 fe			ld (debug_mark+2),a  
0966 18 03			jr .pastdmark  
0968 ..			.dmark: db "SCz"  
096b f1			.pastdmark: pop af  
096c			endm  
# End of macro DMARK
096c					CALLMONITOR 
096c cd c6 18			call break_point_state  
096f				endm  
# End of macro CALLMONITOR
096f				endif 
096f c9				ret 
0970				 
0970			 
0970			 
0970			; 
0970			; Read File 
0970			; 
0970			; h - file id to locate 
0970			; l - extent to locate 
0970			; de - pointer to string to read into 
0970			; 
0970			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0970			 
0970			.sr_fail: 
0970 d1				pop de 
0971 c9				ret 
0972			 
0972			storage_read: 
0972			 
0972			 
0972 d5				push de 
0973			 
0973			; TODO BUG the above push is it popped before the RET Z? 
0973			 
0973			; TODO how to handle multiple part blocks 
0973			 
0973				; locate file extent to read 
0973			 
0973 5c				ld e, h 
0974 55				ld d, l 
0975			 
0975			.srext: 
0975 22 05 fc			ld (store_readptr), hl     ; save the current extent to load 
0978 ed 53 03 fc		ld (store_readbuf), de     ; save the current buffer to load in to 
097c			 
097c 21 40 00			ld hl, STORE_BLOCK_PHY 
097f				if DEBUG_STORESE 
097f					DMARK "sre" 
097f f5				push af  
0980 3a 94 09			ld a, (.dmark)  
0983 32 b4 fe			ld (debug_mark),a  
0986 3a 95 09			ld a, (.dmark+1)  
0989 32 b5 fe			ld (debug_mark+1),a  
098c 3a 96 09			ld a, (.dmark+2)  
098f 32 b6 fe			ld (debug_mark+2),a  
0992 18 03			jr .pastdmark  
0994 ..			.dmark: db "sre"  
0997 f1			.pastdmark: pop af  
0998			endm  
# End of macro DMARK
0998					CALLMONITOR 
0998 cd c6 18			call break_point_state  
099b				endm  
# End of macro CALLMONITOR
099b				endif 
099b cd 4c 07			call storage_findnextid 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "srf" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 b4 fe			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 b5 fe			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 b6 fe			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "srf"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd c6 18			call break_point_state  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba cd 72 0f			call ishlzero 
09bd			;	ld a, l 
09bd			;	add h 
09bd			;	cp 0 
09bd 28 b1			jr z,.sr_fail			; block not found so EOF 
09bf			 
09bf				; save current address for use by higher level words etc 
09bf			 
09bf 22 f8 fb			ld (store_openaddr),hl 
09c2			 
09c2			 
09c2				; hl contains page number to load 
09c2 d1				pop de   ; get storage 
09c3 ed 53 03 fc		ld (store_readbuf), de     ; current buffer to load in to 
09c7 d5				push de 
09c8				if DEBUG_STORESE 
09c8					DMARK "srg" 
09c8 f5				push af  
09c9 3a dd 09			ld a, (.dmark)  
09cc 32 b4 fe			ld (debug_mark),a  
09cf 3a de 09			ld a, (.dmark+1)  
09d2 32 b5 fe			ld (debug_mark+1),a  
09d5 3a df 09			ld a, (.dmark+2)  
09d8 32 b6 fe			ld (debug_mark+2),a  
09db 18 03			jr .pastdmark  
09dd ..			.dmark: db "srg"  
09e0 f1			.pastdmark: pop af  
09e1			endm  
# End of macro DMARK
09e1					CALLMONITOR 
09e1 cd c6 18			call break_point_state  
09e4				endm  
# End of macro CALLMONITOR
09e4				endif 
09e4 cd 19 04			call storage_read_block 
09e7			 
09e7				; if this a continuation read??? 
09e7			 
09e7 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
09ea			 
09ea 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ec cd 49 0f			call addatohl 
09ef 7e				ld a,(hl) 
09f0 fe 00			cp 0 
09f2 28 02			jr z, .markiscont 
09f4 3e ff			ld a, 255 
09f6			 
09f6			.markiscont: 
09f6 32 fa fb			ld (store_readcont), a 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srC" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 b4 fe			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 b5 fe			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 b6 fe			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srC"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd c6 18			call break_point_state  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15				; only short reads enabled 
0a15			 
0a15 3a 02 fc			ld a, (store_longread) 
0a18 fe 00			cp 0 
0a1a ca e7 0a			jp z, .readdone 
0a1d			 
0a1d			; TODO if block has no zeros then need to read next block  
0a1d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a1d			; check last byte of physical block. 
0a1d			; if not zero then the next block needs to be loaded 
0a1d			 
0a1d			 
0a1d 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
0a20			 
0a20 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a22 cd 49 0f			call addatohl 
0a25				;dec hl 
0a25 7e				ld a,(hl) 
0a26				if DEBUG_STORESE 
0a26					DMARK "sr?" 
0a26 f5				push af  
0a27 3a 3b 0a			ld a, (.dmark)  
0a2a 32 b4 fe			ld (debug_mark),a  
0a2d 3a 3c 0a			ld a, (.dmark+1)  
0a30 32 b5 fe			ld (debug_mark+1),a  
0a33 3a 3d 0a			ld a, (.dmark+2)  
0a36 32 b6 fe			ld (debug_mark+2),a  
0a39 18 03			jr .pastdmark  
0a3b ..			.dmark: db "sr?"  
0a3e f1			.pastdmark: pop af  
0a3f			endm  
# End of macro DMARK
0a3f					CALLMONITOR 
0a3f cd c6 18			call break_point_state  
0a42				endm  
# End of macro CALLMONITOR
0a42				endif 
0a42 fe 00			cp 0 
0a44 ca e7 0a			jp z, .readdone 
0a47			 
0a47				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a47			 
0a47 23				inc hl 
0a48			 
0a48 22 03 fc			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4b			 
0a4b ed 5b 05 fc		ld de, (store_readptr)     ; save the current extent to load 
0a4f			 
0a4f eb				ex de, hl 
0a50			 
0a50				; next ext 
0a50			 
0a50 23				inc hl 
0a51 22 05 fc			ld  (store_readptr), hl     ; save the current extent to load 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "sF2" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 b4 fe			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 b5 fe			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 b6 fe			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "sF2"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd c6 18			call break_point_state  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70			 
0a70				; get and load block 
0a70			 
0a70 cd 4c 07			call storage_findnextid 
0a73			 
0a73				if DEBUG_STORESE 
0a73					DMARK "sf2" 
0a73 f5				push af  
0a74 3a 88 0a			ld a, (.dmark)  
0a77 32 b4 fe			ld (debug_mark),a  
0a7a 3a 89 0a			ld a, (.dmark+1)  
0a7d 32 b5 fe			ld (debug_mark+1),a  
0a80 3a 8a 0a			ld a, (.dmark+2)  
0a83 32 b6 fe			ld (debug_mark+2),a  
0a86 18 03			jr .pastdmark  
0a88 ..			.dmark: db "sf2"  
0a8b f1			.pastdmark: pop af  
0a8c			endm  
# End of macro DMARK
0a8c					CALLMONITOR 
0a8c cd c6 18			call break_point_state  
0a8f				endm  
# End of macro CALLMONITOR
0a8f				endif 
0a8f cd 72 0f			call ishlzero 
0a92			;	ld a, l 
0a92			;	add h 
0a92			;	cp 0 
0a92 ca 70 09			jp z,.sr_fail			; block not found so EOF 
0a95				 
0a95				; save current address for use by higher level words etc 
0a95			 
0a95 22 f8 fb			ld (store_openaddr),hl 
0a98			 
0a98 cd 19 04			call storage_read_block 
0a9b			 
0a9b				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9b				; we need to pull everything back  
0a9b			 
0a9b ed 5b 03 fc		ld de, (store_readbuf)     ; current buffer to nudge into 
0a9f 2a 03 fc			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa2 23				inc hl 
0aa3 23				inc hl     ; skip id and ext 
0aa4 01 40 00			ld bc, STORE_BLOCK_PHY 
0aa7				if DEBUG_STORESE 
0aa7					DMARK "SR<" 
0aa7 f5				push af  
0aa8 3a bc 0a			ld a, (.dmark)  
0aab 32 b4 fe			ld (debug_mark),a  
0aae 3a bd 0a			ld a, (.dmark+1)  
0ab1 32 b5 fe			ld (debug_mark+1),a  
0ab4 3a be 0a			ld a, (.dmark+2)  
0ab7 32 b6 fe			ld (debug_mark+2),a  
0aba 18 03			jr .pastdmark  
0abc ..			.dmark: db "SR<"  
0abf f1			.pastdmark: pop af  
0ac0			endm  
# End of macro DMARK
0ac0					CALLMONITOR 
0ac0 cd c6 18			call break_point_state  
0ac3				endm  
# End of macro CALLMONITOR
0ac3				endif 
0ac3 ed b0			ldir     ; copy data 
0ac5			 
0ac5				; move the pointer back and pretend we have a full buffer for next recheck 
0ac5			 
0ac5 1b				dec de 
0ac6 1b				dec de 
0ac7			 
0ac7			; TODO do pop below now short circuit loop????? 
0ac7 c1				pop bc     ; get rid of spare de on stack 
0ac8				if DEBUG_STORESE 
0ac8					DMARK "SR>" 
0ac8 f5				push af  
0ac9 3a dd 0a			ld a, (.dmark)  
0acc 32 b4 fe			ld (debug_mark),a  
0acf 3a de 0a			ld a, (.dmark+1)  
0ad2 32 b5 fe			ld (debug_mark+1),a  
0ad5 3a df 0a			ld a, (.dmark+2)  
0ad8 32 b6 fe			ld (debug_mark+2),a  
0adb 18 03			jr .pastdmark  
0add ..			.dmark: db "SR>"  
0ae0 f1			.pastdmark: pop af  
0ae1			endm  
# End of macro DMARK
0ae1					CALLMONITOR 
0ae1 cd c6 18			call break_point_state  
0ae4				endm  
# End of macro CALLMONITOR
0ae4				endif 
0ae4 c3 75 09			jp .srext 
0ae7			 
0ae7			 
0ae7			 
0ae7			 
0ae7			 
0ae7			.readdone:		 
0ae7 e1				pop hl 		 ; return start of data to show as not EOF 
0ae8 23				inc hl   ; past file id 
0ae9 23				inc hl   ; past ext 
0aea				if DEBUG_STORESE 
0aea					DMARK "SRe" 
0aea f5				push af  
0aeb 3a ff 0a			ld a, (.dmark)  
0aee 32 b4 fe			ld (debug_mark),a  
0af1 3a 00 0b			ld a, (.dmark+1)  
0af4 32 b5 fe			ld (debug_mark+1),a  
0af7 3a 01 0b			ld a, (.dmark+2)  
0afa 32 b6 fe			ld (debug_mark+2),a  
0afd 18 03			jr .pastdmark  
0aff ..			.dmark: db "SRe"  
0b02 f1			.pastdmark: pop af  
0b03			endm  
# End of macro DMARK
0b03					CALLMONITOR 
0b03 cd c6 18			call break_point_state  
0b06				endm  
# End of macro CALLMONITOR
0b06				endif 
0b06 c9					ret 
0b07			 
0b07			 
0b07			 
0b07			; 
0b07			; Append File 
0b07			; 
0b07			; hl - file id to locate 
0b07			; de - pointer to (multi block) string to write 
0b07			 
0b07			.sa_notfound: 
0b07 d1				pop de 
0b08 c9				ret 
0b09			 
0b09			 
0b09			storage_append: 
0b09				; hl -  file id to append to 
0b09				; de - string to append 
0b09			 
0b09 d5				push de 
0b0a				 
0b0a				if DEBUG_STORESE 
0b0a					DMARK "AP1" 
0b0a f5				push af  
0b0b 3a 1f 0b			ld a, (.dmark)  
0b0e 32 b4 fe			ld (debug_mark),a  
0b11 3a 20 0b			ld a, (.dmark+1)  
0b14 32 b5 fe			ld (debug_mark+1),a  
0b17 3a 21 0b			ld a, (.dmark+2)  
0b1a 32 b6 fe			ld (debug_mark+2),a  
0b1d 18 03			jr .pastdmark  
0b1f ..			.dmark: db "AP1"  
0b22 f1			.pastdmark: pop af  
0b23			endm  
# End of macro DMARK
0b23					CALLMONITOR 
0b23 cd c6 18			call break_point_state  
0b26				endm  
# End of macro CALLMONITOR
0b26				endif 
0b26			 
0b26 7d				ld a, l 
0b27 32 fb fb			ld (store_tmpid), a 
0b2a			 
0b2a				; get file header  
0b2a			 
0b2a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2c 3a fb fb			ld a, (store_tmpid) 
0b2f 5f				ld e, a 
0b30			 
0b30 21 40 00				ld hl, STORE_BLOCK_PHY 
0b33 cd 4c 07				call storage_findnextid 
0b36			 
0b36 cd 72 0f			call ishlzero 
0b39 28 cc			jr z, .sa_notfound 
0b3b			 
0b3b 22 f2 fb			ld (store_tmppageid), hl 
0b3e			 
0b3e				; TODO handle file id not found 
0b3e			 
0b3e				if DEBUG_STORESE 
0b3e					DMARK "AP2" 
0b3e f5				push af  
0b3f 3a 53 0b			ld a, (.dmark)  
0b42 32 b4 fe			ld (debug_mark),a  
0b45 3a 54 0b			ld a, (.dmark+1)  
0b48 32 b5 fe			ld (debug_mark+1),a  
0b4b 3a 55 0b			ld a, (.dmark+2)  
0b4e 32 b6 fe			ld (debug_mark+2),a  
0b51 18 03			jr .pastdmark  
0b53 ..			.dmark: db "AP2"  
0b56 f1			.pastdmark: pop af  
0b57			endm  
# End of macro DMARK
0b57					CALLMONITOR 
0b57 cd c6 18			call break_point_state  
0b5a				endm  
# End of macro CALLMONITOR
0b5a				endif 
0b5a			 
0b5a				; update file extent count 
0b5a			 
0b5a 11 07 fc			ld de, store_page 
0b5d			 
0b5d cd 19 04			call storage_read_block 
0b60			 
0b60				if DEBUG_STORESE 
0b60					DMARK "AP3" 
0b60 f5				push af  
0b61 3a 75 0b			ld a, (.dmark)  
0b64 32 b4 fe			ld (debug_mark),a  
0b67 3a 76 0b			ld a, (.dmark+1)  
0b6a 32 b5 fe			ld (debug_mark+1),a  
0b6d 3a 77 0b			ld a, (.dmark+2)  
0b70 32 b6 fe			ld (debug_mark+2),a  
0b73 18 03			jr .pastdmark  
0b75 ..			.dmark: db "AP3"  
0b78 f1			.pastdmark: pop af  
0b79			endm  
# End of macro DMARK
0b79					CALLMONITOR 
0b79 cd c6 18			call break_point_state  
0b7c				endm  
# End of macro CALLMONITOR
0b7c				endif 
0b7c			;	ld (store_tmppageid), hl 
0b7c			 
0b7c 3a 09 fc			ld a, (store_page+2) 
0b7f 3c				inc a 
0b80 32 09 fc			ld (store_page+2), a 
0b83 32 fa fb			ld (store_tmpext), a 
0b86				 
0b86				if DEBUG_STORESE 
0b86					DMARK "AP3" 
0b86 f5				push af  
0b87 3a 9b 0b			ld a, (.dmark)  
0b8a 32 b4 fe			ld (debug_mark),a  
0b8d 3a 9c 0b			ld a, (.dmark+1)  
0b90 32 b5 fe			ld (debug_mark+1),a  
0b93 3a 9d 0b			ld a, (.dmark+2)  
0b96 32 b6 fe			ld (debug_mark+2),a  
0b99 18 03			jr .pastdmark  
0b9b ..			.dmark: db "AP3"  
0b9e f1			.pastdmark: pop af  
0b9f			endm  
# End of macro DMARK
0b9f					CALLMONITOR 
0b9f cd c6 18			call break_point_state  
0ba2				endm  
# End of macro CALLMONITOR
0ba2				endif 
0ba2 2a f2 fb			ld hl, (store_tmppageid) 
0ba5 11 07 fc			ld de, store_page 
0ba8 cd 7e 04			call storage_write_block 
0bab			 
0bab				; find free block 
0bab			 
0bab 11 00 00			ld de, 0			 ; file extent to locate 
0bae			 
0bae 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb1 cd 4c 07				call storage_findnextid 
0bb4 cd 72 0f			call ishlzero 
0bb7 ca 07 0b			jp z, .sa_notfound 
0bba			 
0bba					; TODO handle no space left 
0bba					 
0bba 22 f2 fb				ld (store_tmppageid), hl 
0bbd			 
0bbd				if DEBUG_STORESE 
0bbd					DMARK "AP4" 
0bbd f5				push af  
0bbe 3a d2 0b			ld a, (.dmark)  
0bc1 32 b4 fe			ld (debug_mark),a  
0bc4 3a d3 0b			ld a, (.dmark+1)  
0bc7 32 b5 fe			ld (debug_mark+1),a  
0bca 3a d4 0b			ld a, (.dmark+2)  
0bcd 32 b6 fe			ld (debug_mark+2),a  
0bd0 18 03			jr .pastdmark  
0bd2 ..			.dmark: db "AP4"  
0bd5 f1			.pastdmark: pop af  
0bd6			endm  
# End of macro DMARK
0bd6					CALLMONITOR 
0bd6 cd c6 18			call break_point_state  
0bd9				endm  
# End of macro CALLMONITOR
0bd9				endif 
0bd9					; init the buffer with zeros so we can id if the buffer is full or not 
0bd9			 
0bd9 e5					push hl 
0bda c5					push bc 
0bdb			 
0bdb 21 07 fc				ld hl, store_page 
0bde 06 40				ld b, STORE_BLOCK_PHY 
0be0 3e 00				ld a, 0 
0be2 77			.zeroblock:	ld (hl), a 
0be3 23					inc hl 
0be4 10 fc				djnz .zeroblock 
0be6			 
0be6 c1					pop bc 
0be7 e1					pop hl 
0be8			 
0be8					; construct block 
0be8			 
0be8 3a fb fb				ld a, (store_tmpid) 
0beb 32 07 fc				ld (store_page), a   ; file id 
0bee 3a fa fb				ld a, (store_tmpext)   ; extent for this block 
0bf1 32 08 fc				ld (store_page+1), a 
0bf4			 
0bf4 e1					pop hl    ; get string to write 
0bf5 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bf7 11 09 fc				ld de, store_page+2 
0bfa			 
0bfa				if DEBUG_STORESE 
0bfa					DMARK "AP5" 
0bfa f5				push af  
0bfb 3a 0f 0c			ld a, (.dmark)  
0bfe 32 b4 fe			ld (debug_mark),a  
0c01 3a 10 0c			ld a, (.dmark+1)  
0c04 32 b5 fe			ld (debug_mark+1),a  
0c07 3a 11 0c			ld a, (.dmark+2)  
0c0a 32 b6 fe			ld (debug_mark+2),a  
0c0d 18 03			jr .pastdmark  
0c0f ..			.dmark: db "AP5"  
0c12 f1			.pastdmark: pop af  
0c13			endm  
# End of macro DMARK
0c13					CALLMONITOR 
0c13 cd c6 18			call break_point_state  
0c16				endm  
# End of macro CALLMONITOR
0c16				endif 
0c16			 
0c16			 
0c16			 
0c16					; fill buffer with data until end of string or full block 
0c16			 
0c16 7e			.appd:		ld a, (hl) 
0c17 12					ld (de), a 
0c18 fe 00				cp 0 
0c1a 28 04				jr z, .appdone 
0c1c 23					inc hl 
0c1d 13					inc de 
0c1e 10 f6				djnz .appd 
0c20			 
0c20 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c21 f5					push af   		; save last byte dumped 
0c22			 
0c22			 
0c22 2a f2 fb			ld hl, (store_tmppageid) 
0c25 11 07 fc			ld de, store_page 
0c28				if DEBUG_STORESE 
0c28					DMARK "AP6" 
0c28 f5				push af  
0c29 3a 3d 0c			ld a, (.dmark)  
0c2c 32 b4 fe			ld (debug_mark),a  
0c2f 3a 3e 0c			ld a, (.dmark+1)  
0c32 32 b5 fe			ld (debug_mark+1),a  
0c35 3a 3f 0c			ld a, (.dmark+2)  
0c38 32 b6 fe			ld (debug_mark+2),a  
0c3b 18 03			jr .pastdmark  
0c3d ..			.dmark: db "AP6"  
0c40 f1			.pastdmark: pop af  
0c41			endm  
# End of macro DMARK
0c41					CALLMONITOR 
0c41 cd c6 18			call break_point_state  
0c44				endm  
# End of macro CALLMONITOR
0c44				endif 
0c44 cd 7e 04				call storage_write_block 
0c47			 
0c47			 
0c47				; was that a full block of data written? 
0c47				; any more to write out? 
0c47			 
0c47				; if yes then set vars and jump to start of function again 
0c47			 
0c47 f1					pop af 
0c48 d1					pop de 
0c49			 
0c49 fe 00				cp 0		 ; no, string was fully written 
0c4b c8					ret z 
0c4c			 
0c4c					; setup vars for next cycle 
0c4c			 
0c4c 3a fb fb				ld a, (store_tmpid) 
0c4f 6f					ld l, a 
0c50 26 00				ld h, 0 
0c52			 
0c52 c3 09 0b			 	jp storage_append	 ; yes, need to write out some more 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			if DEBUG_STORECF 
0c55			storageput:	 
0c55					ret 
0c55			storageread: 
0c55					ld hl, store_page 
0c55					ld b, 200 
0c55					ld a,0 
0c55			.src:		ld (hl),a 
0c55					inc hl 
0c55					djnz .src 
0c55					 
0c55			 
0c55					ld de, 0 
0c55					ld bc, 1 
0c55					ld hl, store_page 
0c55					call cfRead 
0c55			 
0c55				call cfGetError 
0c55				ld hl,scratch 
0c55				call hexout 
0c55				ld hl, scratch+2 
0c55				ld a, 0 
0c55				ld (hl),a 
0c55				ld de, scratch 
0c55				ld a,display_row_1 
0c55				call str_at_display 
0c55				call update_display 
0c55			 
0c55					ld hl, store_page 
0c55					ld (os_cur_ptr),hl 
0c55			 
0c55					ret 
0c55			endif 
0c55			 
0c55			 
0c55			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c55			 
0c55			storage_clear_page: 
0c55 e5				push hl 
0c56 d5				push de 
0c57 c5				push bc 
0c58 21 07 fc			ld hl, store_page 
0c5b 3e 00			ld a, 0 
0c5d 77				ld (hl), a 
0c5e			 
0c5e 11 08 fc			ld de, store_page+1 
0c61 01 18 01			ld bc, STORE_BLOCK_LOG 
0c64			 
0c64 ed b0			ldir 
0c66				 
0c66 c1				pop bc 
0c67 d1				pop de 
0c68 e1				pop hl 
0c69 c9				ret 
0c6a			 
0c6a			; eof 
# End of file firmware_storage.asm
0c6a			  
0c6a			; support routines for above hardware abstraction layer  
0c6a			  
0c6a			include "firmware_general.asm"        ; general support functions  
0c6a			 
0c6a			; word look up 
0c6a			 
0c6a			; in 
0c6a			; a is the index 
0c6a			; hl is pointer start of array 
0c6a			; 
0c6a			; returns 
0c6a			; hl to the word 
0c6a			; 
0c6a			 
0c6a			table_lookup:  
0c6a d5					push de 
0c6b eb					ex de, hl 
0c6c			 
0c6c 6f					ld l, a 
0c6d 26 00				ld h, 0 
0c6f 29					add hl, hl 
0c70 19					add hl, de 
0c71 7e					ld a, (hl) 
0c72 23					inc hl 
0c73 66					ld h,(hl) 
0c74 6f					ld l, a 
0c75			 
0c75 d1					pop de 
0c76 c9					ret 
0c77			 
0c77			; Delay loops 
0c77			 
0c77			 
0c77			 
0c77			aDelayInMS: 
0c77 c5				push bc 
0c78 47				ld b,a 
0c79			msdelay: 
0c79 c5				push bc 
0c7a				 
0c7a			 
0c7a 01 41 00			ld bc,041h 
0c7d cd 95 0c			call delayloop 
0c80 c1				pop bc 
0c81 05				dec b 
0c82 20 f5			jr nz,msdelay 
0c84			 
0c84			;if CPU_CLOCK_8MHZ 
0c84			;msdelay8: 
0c84			;	push bc 
0c84			;	 
0c84			; 
0c84			;	ld bc,041h 
0c84			;	call delayloop 
0c84			;	pop bc 
0c84			;	dec b 
0c84			;	jr nz,msdelay8 
0c84			;endif 
0c84			 
0c84			 
0c84 c1				pop bc 
0c85 c9				ret 
0c86			 
0c86			 
0c86			delay250ms: 
0c86				;push de 
0c86 01 00 40			ld bc, 04000h 
0c89 c3 95 0c			jp delayloop 
0c8c			delay500ms: 
0c8c				;push de 
0c8c 01 00 80			ld bc, 08000h 
0c8f c3 95 0c			jp delayloop 
0c92			delay1s: 
0c92				;push bc 
0c92			   ; Clobbers A, d and e 
0c92 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c95			delayloop: 
0c95 c5			    push bc 
0c96			 
0c96			if BASE_CPM 
0c96				ld bc, CPM_DELAY_TUNE 
0c96			.cpmloop: 
0c96				push bc 
0c96			 
0c96			endif 
0c96			 
0c96			 
0c96			 
0c96			delayloopi: 
0c96			;	push bc 
0c96			;.dl: 
0c96 cb 47		    bit     0,a    	; 8 
0c98 cb 47		    bit     0,a    	; 8 
0c9a cb 47		    bit     0,a    	; 8 
0c9c e6 ff		    and     255  	; 7 
0c9e 0b			    dec     bc      	; 6 
0c9f 79			    ld      a,c     	; 4 
0ca0 b0			    or      b     	; 4 
0ca1 c2 96 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca4			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca4				;pop de 
0ca4			;pop bc 
0ca4			 
0ca4			if BASE_CPM 
0ca4				pop bc 
0ca4				 
0ca4			    dec     bc      	; 6 
0ca4			    ld      a,c     	; 4 
0ca4			    or      b     	; 4 
0ca4			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca4				 
0ca4			 
0ca4			endif 
0ca4			;if CPU_CLOCK_8MHZ 
0ca4			;    pop bc 
0ca4			;    push bc 
0ca4			;.dl8: 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    and     255  	; 7 
0ca4			;    dec     bc      	; 6 
0ca4			;    ld      a,c     	; 4 
0ca4			;    or      b     	; 4 
0ca4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca4			;endif 
0ca4			 
0ca4			;if CPU_CLOCK_10MHZ 
0ca4			;    pop bc 
0ca4			;    push bc 
0ca4			;.dl8: 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    and     255  	; 7 
0ca4			;    dec     bc      	; 6 
0ca4			;    ld      a,c     	; 4 
0ca4			;    or      b     	; 4 
0ca4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca4			;endif 
0ca4 c1			    pop bc 
0ca5			 
0ca5 c9				ret 
0ca6			 
0ca6			 
0ca6			 
0ca6			; eof 
# End of file firmware_general.asm
0ca6			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca6			; display routines that use the physical hardware abstraction layer 
0ca6			 
0ca6			 
0ca6			; information window 
0ca6			 
0ca6			; pass hl with 1st string to display 
0ca6			; pass de with 2nd string to display 
0ca6			 
0ca6			info_panel: 
0ca6 e5				push hl 
0ca7			 
0ca7 2a 55 fd			ld hl, (display_fb_active) 
0caa e5				push hl    ; future de destination 
0cab 21 4a fe				ld hl, display_fb0 
0cae 22 55 fd				ld (display_fb_active), hl 
0cb1			 
0cb1			;	call clear_display 
0cb1			 
0cb1				if BASE_CPM 
0cb1				ld a, '.' 
0cb1				else 
0cb1 3e a5			ld a, 165 
0cb3				endif 
0cb3 cd 1a 0d			call fill_display 
0cb6			 
0cb6			 
0cb6 3e 2d			ld a, display_row_3 + 5 
0cb8 cd 28 0d			call str_at_display 
0cbb			 
0cbb e1				pop hl 
0cbc d1				pop de 
0cbd			 
0cbd e5				push hl 
0cbe			 
0cbe			 
0cbe 3e 19			ld a, display_row_2 + 5 
0cc0 cd 28 0d			call str_at_display 
0cc3			 
0cc3			 
0cc3 cd 38 0d			call update_display 
0cc6 cd b2 1e			call next_page_prompt 
0cc9 cd 15 0d			call clear_display 
0ccc			 
0ccc				 
0ccc 21 f9 fd				ld hl, display_fb1 
0ccf 22 55 fd				ld (display_fb_active), hl 
0cd2 cd 38 0d			call update_display 
0cd5			 
0cd5 e1				pop hl 
0cd6			 
0cd6 c9				ret 
0cd7			 
0cd7			 
0cd7			 
0cd7			 
0cd7			; TODO windowing? 
0cd7			 
0cd7			; TODO scroll line up 
0cd7			 
0cd7			scroll_up: 
0cd7			 
0cd7 e5				push hl 
0cd8 d5				push de 
0cd9 c5				push bc 
0cda			 
0cda				; get frame buffer  
0cda			 
0cda 2a 55 fd			ld hl, (display_fb_active) 
0cdd e5				push hl    ; future de destination 
0cde			 
0cde 11 14 00			ld  de, display_cols 
0ce1 19				add hl, de 
0ce2			 
0ce2 d1				pop de 
0ce3			 
0ce3				;ex de, hl 
0ce3 01 4f 00			ld bc, display_fb_len -1  
0ce6			;if DEBUG_FORTH_WORDS 
0ce6			;	DMARK "SCL" 
0ce6			;	CALLMONITOR 
0ce6			;endif	 
0ce6 ed b0			ldir 
0ce8			 
0ce8				; wipe bottom row 
0ce8			 
0ce8			 
0ce8 2a 55 fd			ld hl, (display_fb_active) 
0ceb 11 50 00			ld de, display_cols*display_rows 
0cee 19				add hl, de 
0cef 06 14			ld b, display_cols 
0cf1 3e 20			ld a, ' ' 
0cf3			.scwipe: 
0cf3 77				ld (hl), a 
0cf4 2b				dec hl 
0cf5 10 fc			djnz .scwipe 
0cf7			 
0cf7				;pop hl 
0cf7			 
0cf7 c1				pop bc 
0cf8 d1				pop de 
0cf9 e1				pop hl 
0cfa			 
0cfa c9				ret 
0cfb			 
0cfb			 
0cfb			;scroll_upo: 
0cfb			;	ld de, display_row_1 
0cfb			 ;	ld hl, display_row_2 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			;	ld de, display_row_2 
0cfb			 ;	ld hl, display_row_3 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			;	ld de, display_row_3 
0cfb			 ;	ld hl, display_row_4 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			 
0cfb			; TODO clear row 4 
0cfb			 
0cfb			;	ret 
0cfb			 
0cfb				 
0cfb			scroll_down: 
0cfb			 
0cfb e5				push hl 
0cfc d5				push de 
0cfd c5				push bc 
0cfe			 
0cfe				; get frame buffer  
0cfe			 
0cfe 2a 55 fd			ld hl, (display_fb_active) 
0d01			 
0d01 11 4f 00			ld de, display_fb_len - 1 
0d04 19				add hl, de 
0d05			 
0d05 e5			push hl    ; future de destination 
0d06			 
0d06 11 14 00			ld  de, display_cols 
0d09 ed 52			sbc hl, de 
0d0b			 
0d0b			 
0d0b d1				pop de 
0d0c			 
0d0c			;	ex de, hl 
0d0c 01 4f 00			ld bc, display_fb_len -1  
0d0f			 
0d0f			 
0d0f				 
0d0f			 
0d0f ed b0			ldir 
0d11			 
0d11				; wipe bottom row 
0d11			 
0d11			 
0d11			;	ld hl, (display_fb_active) 
0d11			;;	ld de, display_cols*display_rows 
0d11			;;	add hl, de 
0d11			;	ld b, display_cols 
0d11			;	ld a, ' ' 
0d11			;.scwiped: 
0d11			;	ld (hl), a 
0d11			;	dec hl 
0d11			;	djnz .scwiped 
0d11			 
0d11				;pop hl 
0d11			 
0d11 c1				pop bc 
0d12 d1				pop de 
0d13 e1				pop hl 
0d14			 
0d14 c9				ret 
0d15			;scroll_down: 
0d15			;	ld de, display_row_4 
0d15			;	ld hl, display_row_3 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;	ld de, display_row_3 
0d15			; 	ld hl, display_row_2 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;	ld de, display_row_2 
0d15			;	ld hl, display_row_1 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;;; TODO clear row 1 
0d15			;	ret 
0d15			 
0d15			 
0d15			 
0d15			 
0d15			 
0d15			; clear active frame buffer 
0d15			 
0d15			clear_display: 
0d15 3e 20			ld a, ' ' 
0d17 c3 1a 0d			jp fill_display 
0d1a			 
0d1a			; fill active frame buffer with a char in A 
0d1a			 
0d1a			fill_display: 
0d1a 06 50			ld b,display_fb_len 
0d1c 2a 55 fd			ld hl, (display_fb_active) 
0d1f 77			.fd1:	ld (hl),a 
0d20 23				inc hl 
0d21 10 fc			djnz .fd1 
0d23 23				inc hl 
0d24 3e 00			ld a,0 
0d26 77				ld (hl),a 
0d27			 
0d27			 
0d27 c9				ret 
0d28			; Write string (DE) at pos (A) to active frame buffer 
0d28			 
0d28 2a 55 fd		str_at_display:    ld hl,(display_fb_active) 
0d2b 06 00					ld b,0 
0d2d 4f					ld c,a 
0d2e 09					add hl,bc 
0d2f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d30 b7			            OR   A              ;Null terminator? 
0d31 c8			            RET  Z              ;Yes, so finished 
0d32 77					ld (hl),a 
0d33 23				inc hl 
0d34 13			            INC  DE             ;Point to next character 
0d35 18 f8		            JR   .sad1     ;Repeat 
0d37 c9					ret 
0d38			 
0d38			; using current frame buffer write to physical display 
0d38			 
0d38			update_display: 
0d38 e5				push hl 
0d39 2a 55 fd			ld hl, (display_fb_active) 
0d3c cd b7 72			call write_display 
0d3f e1				pop hl 
0d40 c9				ret 
0d41			 
0d41			; TODO scrolling 
0d41			 
0d41			 
0d41			; move cursor right one char 
0d41			cursor_right: 
0d41			 
0d41				; TODO shift right 
0d41				; TODO if beyond max col 
0d41				; TODO       cursor_next_line 
0d41			 
0d41 c9				ret 
0d42			 
0d42			 
0d42			cursor_next_line: 
0d42				; TODO first char 
0d42				; TODO line down 
0d42				; TODO if past last row 
0d42				; TODO    scroll up 
0d42			 
0d42 c9				ret 
0d43			 
0d43			cursor_left: 
0d43				; TODO shift left 
0d43				; TODO if beyond left  
0d43				; TODO     cursor prev line 
0d43				 
0d43 c9				ret 
0d44			 
0d44			cursor_prev_line: 
0d44				; TODO last char 
0d44				; TODO line up 
0d44				; TODO if past first row 
0d44				; TODO   scroll down 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			cout: 
0d45				; A - char 
0d45 c9				ret 
0d46			 
0d46			 
0d46			; Display a menu and allow item selection (optional toggle items) 
0d46			; 
0d46			; format: 
0d46			; hl pointer to word array with zero term for items 
0d46			; e.g.    db item1 
0d46			;         db .... 
0d46			;         db 0 
0d46			; 
0d46			; a = starting menu item  
0d46			; 
0d46			; de = pointer item toggle array   (todo) 
0d46			; 
0d46			; returns item selected in a 1-... 
0d46			; returns 0 if back button pressed 
0d46			; 
0d46			; NOTE: Uses system frame buffer to display 
0d46			; 
0d46			; LEFT, Q = go back 
0d46			; RIGHT, SPACE, CR = select 
0d46			; UP, A - Up 
0d46			; DOWN, Z - Down 
0d46			 
0d46			 
0d46			 
0d46			 
0d46			 
0d46			menu: 
0d46			 
0d46					; keep array pointer 
0d46			 
0d46 22 00 fc				ld (store_tmp1), hl 
0d49 32 fe fb				ld (store_tmp2), a 
0d4c			 
0d4c					; check for key bounce 
0d4c			 
0d4c			if BASE_KEV 
0d4c			 
0d4c cd 6c 74		.mbounce:	call cin 
0d4f fe 00				cp 0 
0d51 20 f9				jr nz, .mbounce 
0d53			endif 
0d53					; for ease use ex 
0d53			 
0d53					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d53 21 4a fe				ld hl, display_fb0 
0d56 22 55 fd				ld (display_fb_active), hl 
0d59			 
0d59 cd 15 0d		.mloop:		call clear_display 
0d5c cd 38 0d				call update_display 
0d5f			 
0d5f					; draw selection id '>' at 1 
0d5f			 
0d5f					; init start of list display 
0d5f			 
0d5f 3e 05				ld a, 5 
0d61 32 fc fb				ld (store_tmp3), a   ; display row count 
0d64 3a fe fb				ld a,( store_tmp2) 
0d67 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d6a			 
0d6a					 
0d6a			.mitem:	 
0d6a			 
0d6a			 
0d6a 3a ff fb				ld a,(store_tmp2+1) 
0d6d 6f					ld l, a 
0d6e 26 00				ld h, 0 
0d70 29					add hl, hl 
0d71 ed 5b 00 fc			ld de, (store_tmp1) 
0d75 19					add hl, de 
0d76 7e					ld a, (hl) 
0d77 23					inc hl 
0d78 66					ld h,(hl) 
0d79 6f					ld l, a 
0d7a			 
0d7a cd 72 0f				call ishlzero 
0d7d 28 1a				jr z, .mdone 
0d7f			 
0d7f eb					ex de, hl 
0d80 3a fc fb				ld a, (store_tmp3) 
0d83 cd 28 0d				call str_at_display 
0d86					 
0d86			 
0d86					; next item 
0d86 3a ff fb				ld a, (store_tmp2+1) 
0d89 3c					inc a 
0d8a 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d8d			 
0d8d			 		; next row 
0d8d			 
0d8d 3a fc fb				ld a, (store_tmp3) 
0d90 c6 14				add display_cols 
0d92 32 fc fb				ld (store_tmp3), a 
0d95			 
0d95					; at end of screen? 
0d95			 
0d95 fe 10				cp display_rows*4 
0d97 20 d1				jr nz, .mitem 
0d99			 
0d99			 
0d99			.mdone: 
0d99 cd 72 0f				call ishlzero 
0d9c 28 08				jr z, .nodn 
0d9e			 
0d9e 3e 3c				ld a, display_row_4 
0da0 11 1f 0e				ld de, .mdown 
0da3 cd 28 0d				call str_at_display 
0da6			 
0da6					; draw options to fill the screens with active item on line 1 
0da6					; if current option is 2 or more then display ^ in top 
0da6			 
0da6 3a fe fb		.nodn:		ld a, (store_tmp2) 
0da9 fe 00				cp 0 
0dab 28 08				jr z, .noup 
0dad			 
0dad 3e 00				ld a, 0 
0daf 11 1d 0e				ld de, .mup 
0db2 cd 28 0d				call str_at_display 
0db5			 
0db5 3e 02		.noup:		ld a, 2 
0db7 11 1b 0e				ld de, .msel 
0dba cd 28 0d				call str_at_display 
0dbd			 
0dbd					; if current option + 1 is not null then display V in bottom 
0dbd					; get key 
0dbd cd 38 0d				call update_display 
0dc0			 
0dc0			 
0dc0					; handle key 
0dc0			 
0dc0 cd 5b 74				call cin_wait 
0dc3			 
0dc3 fe 05				cp KEY_UP 
0dc5 28 2b				jr z, .mgoup 
0dc7 fe 61				cp 'a' 
0dc9 28 27				jr z, .mgoup 
0dcb fe 0a				cp KEY_DOWN 
0dcd 28 32				jr z, .mgod 
0dcf fe 7a				cp 'z' 
0dd1 28 2e				jr z, .mgod 
0dd3 fe 20				cp ' ' 
0dd5 28 34				jr z, .goend 
0dd7 fe 0c				cp KEY_RIGHT 
0dd9 28 30				jr z, .goend 
0ddb fe 0d				cp KEY_CR 
0ddd 28 2c				jr z, .goend 
0ddf fe 71				cp 'q' 
0de1 28 0b				jr z, .goback 
0de3			 
0de3 fe 0b				cp KEY_LEFT 
0de5 28 07				jr z, .goback 
0de7 fe 08				cp KEY_BS 
0de9 28 03				jr z, .goback 
0deb c3 59 0d				jp .mloop 
0dee			 
0dee			.goback: 
0dee 3e 00			ld a, 0 
0df0 18 1d			jr .goend2 
0df2			 
0df2				; move up one 
0df2			.mgoup: 
0df2 3a fe fb				ld a, (store_tmp2) 
0df5 fe 00				cp 0 
0df7 ca 59 0d				jp z, .mloop 
0dfa 3d					dec a 
0dfb 32 fe fb				ld (store_tmp2), a 
0dfe c3 59 0d				jp .mloop 
0e01			 
0e01				; move down one 
0e01			.mgod: 
0e01 3a fe fb				ld a, (store_tmp2) 
0e04 3c					inc a 
0e05 32 fe fb				ld (store_tmp2), a 
0e08 c3 59 0d				jp .mloop 
0e0b			 
0e0b			 
0e0b			.goend: 
0e0b					; get selected item number 
0e0b			 
0e0b 3a fe fb				ld a, (store_tmp2) 
0e0e 3c					inc a 
0e0f			 
0e0f			.goend2: 
0e0f f5					push af 
0e10			 
0e10					; restore active fb 
0e10					; TODO BUG assumes fb1 
0e10			 
0e10 21 f9 fd				ld hl, display_fb1 
0e13 22 55 fd				ld (display_fb_active), hl 
0e16			 
0e16					; restore main regs 
0e16			 
0e16			 
0e16 cd 38 0d				call update_display 
0e19			 
0e19 f1					pop af 
0e1a			 
0e1a c9				ret 
0e1b			 
0e1b .. 00		.msel:   db ">",0 
0e1d .. 00		.mup:   db "^",0 
0e1f .. 00		.mdown:   db "v",0 
0e21			 
0e21			 
0e21			; eof 
0e21			 
# End of file firmware_display.asm
0e21			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e21			; random number generators 
0e21			 
0e21			 
0e21			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e21			 
0e21			 
0e21			;-----> Generate a random number 
0e21			; output a=answer 0<=a<=255 
0e21			; all registers are preserved except: af 
0e21			random: 
0e21 e5			        push    hl 
0e22 d5			        push    de 
0e23 2a 37 fd		        ld      hl,(randData) 
0e26 ed 5f		        ld      a,r 
0e28 57			        ld      d,a 
0e29 5e			        ld      e,(hl) 
0e2a 19			        add     hl,de 
0e2b 85			        add     a,l 
0e2c ac			        xor     h 
0e2d 22 37 fd		        ld      (randData),hl 
0e30 d1			        pop     de 
0e31 e1			        pop     hl 
0e32 c9			        ret 
0e33			 
0e33			 
0e33			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e33			 
0e33			 
0e33			 
0e33			;------LFSR------ 
0e33			;James Montelongo 
0e33			;optimized by Spencer Putt 
0e33			;out: 
0e33			; a = 8 bit random number 
0e33			RandLFSR: 
0e33 21 3d fd		        ld hl,LFSRSeed+4 
0e36 5e			        ld e,(hl) 
0e37 23			        inc hl 
0e38 56			        ld d,(hl) 
0e39 23			        inc hl 
0e3a 4e			        ld c,(hl) 
0e3b 23			        inc hl 
0e3c 7e			        ld a,(hl) 
0e3d 47			        ld b,a 
0e3e cb 13		        rl e  
0e40 cb 12			rl d 
0e42 cb 11		        rl c  
0e44 17				rla 
0e45 cb 13		        rl e  
0e47 cb 12			rl d 
0e49 cb 11		        rl c  
0e4b 17				rla 
0e4c cb 13		        rl e  
0e4e cb 12			rl d 
0e50 cb 11		        rl c  
0e52 17				rla 
0e53 67			        ld h,a 
0e54 cb 13		        rl e  
0e56 cb 12			rl d 
0e58 cb 11		        rl c  
0e5a 17				rla 
0e5b a8			        xor b 
0e5c cb 13		        rl e  
0e5e cb 12			rl d 
0e60 ac			        xor h 
0e61 a9			        xor c 
0e62 aa			        xor d 
0e63 21 3f fd		        ld hl,LFSRSeed+6 
0e66 11 40 fd		        ld de,LFSRSeed+7 
0e69 01 07 00		        ld bc,7 
0e6c ed b8		        lddr 
0e6e 12			        ld (de),a 
0e6f c9			        ret 
0e70			 
0e70			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e70			 
0e70			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e70			 
0e70			 
0e70			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e70			 
0e70			prng16: 
0e70			;Inputs: 
0e70			;   (seed1) contains a 16-bit seed value 
0e70			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e70			;Outputs: 
0e70			;   HL is the result 
0e70			;   BC is the result of the LCG, so not that great of quality 
0e70			;   DE is preserved 
0e70			;Destroys: 
0e70			;   AF 
0e70			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e70			;160cc 
0e70			;26 bytes 
0e70 2a 31 fd		    ld hl,(seed1) 
0e73 44			    ld b,h 
0e74 4d			    ld c,l 
0e75 29			    add hl,hl 
0e76 29			    add hl,hl 
0e77 2c			    inc l 
0e78 09			    add hl,bc 
0e79 22 31 fd		    ld (seed1),hl 
0e7c 2a 2f fd		    ld hl,(seed2) 
0e7f 29			    add hl,hl 
0e80 9f			    sbc a,a 
0e81 e6 2d		    and %00101101 
0e83 ad			    xor l 
0e84 6f			    ld l,a 
0e85 22 2f fd		    ld (seed2),hl 
0e88 09			    add hl,bc 
0e89 c9			    ret 
0e8a			 
0e8a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e8a			 
0e8a			rand32: 
0e8a			;Inputs: 
0e8a			;   (seed1_0) holds the lower 16 bits of the first seed 
0e8a			;   (seed1_1) holds the upper 16 bits of the first seed 
0e8a			;   (seed2_0) holds the lower 16 bits of the second seed 
0e8a			;   (seed2_1) holds the upper 16 bits of the second seed 
0e8a			;   **NOTE: seed2 must be non-zero 
0e8a			;Outputs: 
0e8a			;   HL is the result 
0e8a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e8a			;Destroys: 
0e8a			;   AF 
0e8a			;Tested and passes all CAcert tests 
0e8a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e8a			;it has a period of 18,446,744,069,414,584,320 
0e8a			;roughly 18.4 quintillion. 
0e8a			;LFSR taps: 0,2,6,7  = 11000101 
0e8a			;291cc 
0e8a			;seed1_0=$+1 
0e8a			;    ld hl,12345 
0e8a			;seed1_1=$+1 
0e8a			;    ld de,6789 
0e8a			;    ld b,h 
0e8a			;    ld c,l 
0e8a			;    add hl,hl \ rl e \ rl d 
0e8a			;    add hl,hl \ rl e \ rl d 
0e8a			;    inc l 
0e8a			;    add hl,bc 
0e8a			;    ld (seed1_0),hl 
0e8a			;    ld hl,(seed1_1) 
0e8a			;    adc hl,de 
0e8a			;    ld (seed1_1),hl 
0e8a			;    ex de,hl 
0e8a			;seed2_0=$+1 
0e8a			;    ld hl,9876 
0e8a			;seed2_1=$+1 
0e8a			;    ld bc,54321 
0e8a			;    add hl,hl \ rl c \ rl b 
0e8a			;    ld (seed2_1),bc 
0e8a			;    sbc a,a 
0e8a			;    and %11000101 
0e8a			;    xor l 
0e8a			;    ld l,a 
0e8a			;    ld (seed2_0),hl 
0e8a			;    ex de,hl 
0e8a			;    add hl,bc 
0e8a			;    ret 
0e8a			; 
0e8a			 
0e8a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e8a			; 20 bytes, 86 cycles (excluding ret) 
0e8a			 
0e8a			; returns   hl = pseudorandom number 
0e8a			; corrupts   a 
0e8a			 
0e8a			; generates 16-bit pseudorandom numbers with a period of 65535 
0e8a			; using the xorshift method: 
0e8a			 
0e8a			; hl ^= hl << 7 
0e8a			; hl ^= hl >> 9 
0e8a			; hl ^= hl << 8 
0e8a			 
0e8a			; some alternative shift triplets which also perform well are: 
0e8a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e8a			 
0e8a			;  org 32768 
0e8a			 
0e8a			xrnd: 
0e8a 2a 35 fd		  ld hl,(xrandc)       ; seed must not be 0 
0e8d 3e 00		  ld a,0 
0e8f bd			  cp l 
0e90 20 02		  jr nz, .xrnd1 
0e92 2e 01		  ld l, 1 
0e94			.xrnd1: 
0e94			 
0e94 7c			  ld a,h 
0e95 1f			  rra 
0e96 7d			  ld a,l 
0e97 1f			  rra 
0e98 ac			  xor h 
0e99 67			  ld h,a 
0e9a 7d			  ld a,l 
0e9b 1f			  rra 
0e9c 7c			  ld a,h 
0e9d 1f			  rra 
0e9e ad			  xor l 
0e9f 6f			  ld l,a 
0ea0 ac			  xor h 
0ea1 67			  ld h,a 
0ea2			 
0ea2 22 35 fd		  ld (xrandc),hl 
0ea5			 
0ea5 c9			  ret 
0ea6			;  
0ea6			 
0ea6			 
0ea6			;;;; int maths 
0ea6			 
0ea6			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ea6			; Divide 16-bit values (with 16-bit result) 
0ea6			; In: Divide BC by divider DE 
0ea6			; Out: BC = result, HL = rest 
0ea6			; 
0ea6			Div16: 
0ea6 21 00 00		    ld hl,0 
0ea9 78			    ld a,b 
0eaa 06 08		    ld b,8 
0eac			Div16_Loop1: 
0eac 17			    rla 
0ead ed 6a		    adc hl,hl 
0eaf ed 52		    sbc hl,de 
0eb1 30 01		    jr nc,Div16_NoAdd1 
0eb3 19			    add hl,de 
0eb4			Div16_NoAdd1: 
0eb4 10 f6		    djnz Div16_Loop1 
0eb6 17			    rla 
0eb7 2f			    cpl 
0eb8 47			    ld b,a 
0eb9 79			    ld a,c 
0eba 48			    ld c,b 
0ebb 06 08		    ld b,8 
0ebd			Div16_Loop2: 
0ebd 17			    rla 
0ebe ed 6a		    adc hl,hl 
0ec0 ed 52		    sbc hl,de 
0ec2 30 01		    jr nc,Div16_NoAdd2 
0ec4 19			    add hl,de 
0ec5			Div16_NoAdd2: 
0ec5 10 f6		    djnz Div16_Loop2 
0ec7 17			    rla 
0ec8 2f			    cpl 
0ec9 41			    ld b,c 
0eca 4f			    ld c,a 
0ecb c9			ret 
0ecc			 
0ecc			 
0ecc			;http://z80-heaven.wikidot.com/math 
0ecc			; 
0ecc			;Inputs: 
0ecc			;     DE and A are factors 
0ecc			;Outputs: 
0ecc			;     A is not changed 
0ecc			;     B is 0 
0ecc			;     C is not changed 
0ecc			;     DE is not changed 
0ecc			;     HL is the product 
0ecc			;Time: 
0ecc			;     342+6x 
0ecc			; 
0ecc			Mult16: 
0ecc			 
0ecc 06 08		     ld b,8          ;7           7 
0ece 21 00 00		     ld hl,0         ;10         10 
0ed1 29			       add hl,hl     ;11*8       88 
0ed2 07			       rlca          ;4*8        32 
0ed3 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ed5 19			         add hl,de   ;--         -- 
0ed6 10 f9		       djnz $-5      ;13*7+8     99 
0ed8 c9			ret 
0ed9			 
0ed9			; 
0ed9			; Square root of 16-bit value 
0ed9			; In:  HL = value 
0ed9			; Out:  D = result (rounded down) 
0ed9			; 
0ed9			;Sqr16: 
0ed9			;    ld de,#0040 
0ed9			;    ld a,l 
0ed9			;    ld l,h 
0ed9			;    ld h,d 
0ed9			;    or a 
0ed9			;    ld b,8 
0ed9			;Sqr16_Loop: 
0ed9			;    sbc hl,de 
0ed9			;    jr nc,Sqr16_Skip 
0ed9			;    add hl,de 
0ed9			;Sqr16_Skip: 
0ed9			;    ccf 
0ed9			;    rl d 
0ed9			;    add a,a 
0ed9			;    adc hl,hl 
0ed9			;    add a,a 
0ed9			;    adc hl,hl 
0ed9			;    djnz Sqr16_Loop 
0ed9			;    ret 
0ed9			; 
0ed9			; 
0ed9			; Divide 8-bit values 
0ed9			; In: Divide E by divider C 
0ed9			; Out: A = result, B = rest 
0ed9			; 
0ed9			Div8: 
0ed9 af			    xor a 
0eda 06 08		    ld b,8 
0edc			Div8_Loop: 
0edc cb 13		    rl e 
0ede 17			    rla 
0edf 91			    sub c 
0ee0 30 01		    jr nc,Div8_NoAdd 
0ee2 81			    add a,c 
0ee3			Div8_NoAdd: 
0ee3 10 f7		    djnz Div8_Loop 
0ee5 47			    ld b,a 
0ee6 7b			    ld a,e 
0ee7 17			    rla 
0ee8 2f			    cpl 
0ee9 c9			    ret 
0eea			 
0eea			; 
0eea			; Multiply 8-bit value with a 16-bit value (unrolled) 
0eea			; In: Multiply A with DE 
0eea			; Out: HL = result 
0eea			; 
0eea			Mult12U: 
0eea 2e 00		    ld l,0 
0eec 87			    add a,a 
0eed 30 01		    jr nc,Mult12U_NoAdd0 
0eef 19			    add hl,de 
0ef0			Mult12U_NoAdd0: 
0ef0 29			    add hl,hl 
0ef1 87			    add a,a 
0ef2 30 01		    jr nc,Mult12U_NoAdd1 
0ef4 19			    add hl,de 
0ef5			Mult12U_NoAdd1: 
0ef5 29			    add hl,hl 
0ef6 87			    add a,a 
0ef7 30 01		    jr nc,Mult12U_NoAdd2 
0ef9 19			    add hl,de 
0efa			Mult12U_NoAdd2: 
0efa 29			    add hl,hl 
0efb 87			    add a,a 
0efc 30 01		    jr nc,Mult12U_NoAdd3 
0efe 19			    add hl,de 
0eff			Mult12U_NoAdd3: 
0eff 29			    add hl,hl 
0f00 87			    add a,a 
0f01 30 01		    jr nc,Mult12U_NoAdd4 
0f03 19			    add hl,de 
0f04			Mult12U_NoAdd4: 
0f04 29			    add hl,hl 
0f05 87			    add a,a 
0f06 30 01		    jr nc,Mult12U_NoAdd5 
0f08 19			    add hl,de 
0f09			Mult12U_NoAdd5: 
0f09 29			    add hl,hl 
0f0a 87			    add a,a 
0f0b 30 01		    jr nc,Mult12U_NoAdd6 
0f0d 19			    add hl,de 
0f0e			Mult12U_NoAdd6: 
0f0e 29			    add hl,hl 
0f0f 87			    add a,a 
0f10 d0			    ret nc 
0f11 19			    add hl,de 
0f12 c9			    ret 
0f13			 
0f13			; 
0f13			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f13			; In: Multiply A with DE 
0f13			;      Put lowest value in A for most efficient calculation 
0f13			; Out: HL = result 
0f13			; 
0f13			Mult12R: 
0f13 21 00 00		    ld hl,0 
0f16			Mult12R_Loop: 
0f16 cb 3f		    srl a 
0f18 30 01		    jr nc,Mult12R_NoAdd 
0f1a 19			    add hl,de 
0f1b			Mult12R_NoAdd: 
0f1b cb 23		    sla e 
0f1d cb 12		    rl d 
0f1f b7			    or a 
0f20 c2 16 0f		    jp nz,Mult12R_Loop 
0f23 c9			    ret 
0f24			 
0f24			; 
0f24			; Multiply 16-bit values (with 32-bit result) 
0f24			; In: Multiply BC with DE 
0f24			; Out: BCHL = result 
0f24			; 
0f24			Mult32: 
0f24 79			    ld a,c 
0f25 48			    ld c,b 
0f26 21 00 00		    ld hl,0 
0f29 06 10		    ld b,16 
0f2b			Mult32_Loop: 
0f2b 29			    add hl,hl 
0f2c 17			    rla 
0f2d cb 11		    rl c 
0f2f 30 07		    jr nc,Mult32_NoAdd 
0f31 19			    add hl,de 
0f32 ce 00		    adc a,0 
0f34 d2 38 0f		    jp nc,Mult32_NoAdd 
0f37 0c			    inc c 
0f38			Mult32_NoAdd: 
0f38 10 f1		    djnz Mult32_Loop 
0f3a 41			    ld b,c 
0f3b 4f			    ld c,a 
0f3c c9			    ret 
0f3d			 
0f3d			 
0f3d			 
0f3d			; 
0f3d			; Multiply 8-bit values 
0f3d			; In:  Multiply H with E 
0f3d			; Out: HL = result 
0f3d			; 
0f3d			Mult8: 
0f3d 16 00		    ld d,0 
0f3f 6a			    ld l,d 
0f40 06 08		    ld b,8 
0f42			Mult8_Loop: 
0f42 29			    add hl,hl 
0f43 30 01		    jr nc,Mult8_NoAdd 
0f45 19			    add hl,de 
0f46			Mult8_NoAdd: 
0f46 10 fa		    djnz Mult8_Loop 
0f48 c9			    ret 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			;;http://z80-heaven.wikidot.com/math 
0f49			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f49			; 
0f49			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f49			;     ld a,16        ;7 
0f49			;     ld hl,0        ;10 
0f49			;     jp $+5         ;10 
0f49			;.DivLoop: 
0f49			;       add hl,bc    ;-- 
0f49			;       dec a        ;64 
0f49			;       jr z,.DivLoopEnd        ;86 
0f49			; 
0f49			;       sla e        ;128 
0f49			;       rl d         ;128 
0f49			;       adc hl,hl    ;240 
0f49			;       sbc hl,bc    ;240 
0f49			;       jr nc,.DivLoop ;23|21 
0f49			;       inc e        ;-- 
0f49			;       jp .DivLoop+1 
0f49			; 
0f49			;.DivLoopEnd: 
0f49			 
0f49			;HL_Div_C: 
0f49			;Inputs: 
0f49			;     HL is the numerator 
0f49			;     C is the denominator 
0f49			;Outputs: 
0f49			;     A is the remainder 
0f49			;     B is 0 
0f49			;     C is not changed 
0f49			;     DE is not changed 
0f49			;     HL is the quotient 
0f49			; 
0f49			;       ld b,16 
0f49			;       xor a 
0f49			;         add hl,hl 
0f49			;         rla 
0f49			;         cp c 
0f49			;         jr c,$+4 
0f49			;           inc l 
0f49			;           sub c 
0f49			;         djnz $-7 
0f49			 
0f49			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f49			 
0f49			addatohl: 
0f49 85			    add   a, l    ; A = A+L 
0f4a 6f			    ld    l, a    ; L = A+L 
0f4b 8c			    adc   a, h    ; A = A+L+H+carry 
0f4c 95			    sub   l       ; A = H+carry 
0f4d 67			    ld    h, a    ; H = H+carry 
0f4e c9			ret 
0f4f			 
0f4f			addatode: 
0f4f 83			    add   a, e    ; A = A+L 
0f50 5f			    ld    e, a    ; L = A+L 
0f51 8a			    adc   a, d    ; A = A+L+H+carry 
0f52 93			    sub   e       ; A = H+carry 
0f53 57			    ld    d, a    ; H = H+carry 
0f54 c9			ret 
0f55			 
0f55			 
0f55			addatobc: 
0f55 81			    add   a, c    ; A = A+L 
0f56 4f			    ld    c, a    ; L = A+L 
0f57 88			    adc   a, b    ; A = A+L+H+carry 
0f58 91			    sub   c       ; A = H+carry 
0f59 47			    ld    b, a    ; H = H+carry 
0f5a c9			ret 
0f5b			 
0f5b			subafromhl: 
0f5b			   ; If A=0 do nothing 
0f5b			    ; Otherwise flip A's sign. Since 
0f5b			    ; the upper byte becomes -1, also 
0f5b			    ; substract 1 from H. 
0f5b ed 44		    neg 
0f5d ca 66 0f		    jp    z, Skip 
0f60 25			    dec   h 
0f61			     
0f61			    ; Now add the low byte as usual 
0f61			    ; Two's complement takes care of 
0f61			    ; ensuring the result is correct 
0f61 85			    add   a, l 
0f62 6f			    ld    l, a 
0f63 8c			    adc   a, h 
0f64 95			    sub   l 
0f65 67			    ld    h, a 
0f66			Skip: 
0f66 c9				ret 
0f67			 
0f67			 
0f67			; compare hl and de 
0f67			; returns:  
0f67			; if hl = de, z=1, s=0, c0=0 
0f67			; if hl > de, z=0, s=0, c=0 
0f67			; if hl < de, z=0, s=1, c=1 
0f67			cmp16:	 
0f67 b7				or a 
0f68 ed 52			sbc hl,de 
0f6a e0				ret po 
0f6b 7c				ld a,h 
0f6c 1f				rra 
0f6d ee 40			xor 01000000B 
0f6f 37				scf 
0f70 8f				adc a,a 
0f71 c9				ret 
0f72			 
0f72			 
0f72			; test if hl contains zero   - A is destroyed 
0f72			 
0f72			ishlzero:    
0f72 b7				or a     ; reset flags 
0f73 7c				ld a, h 
0f74 b5				or l        	 
0f75			 
0f75 c9				ret 
0f76			 
0f76			 
0f76			 
0f76			 
0f76			if FORTH_ENABLE_FLOATMATH 
0f76			;include "float/bbcmath.z80" 
0f76			include "float/lpfpcalc.asm" 
0f76			endif 
0f76			 
0f76			 
0f76			; eof 
0f76			 
# End of file firmware_maths.asm
0f76			include "firmware_strings.asm"   ; string handling  
0f76			 
0f76			 
0f76			; TODO string len 
0f76			; input text string, end on cr with zero term 
0f76			; a offset into frame buffer to start prompt 
0f76			; d is max length 
0f76			; e is display size TODO 
0f76			; c is current cursor position 
0f76			; hl is ptr to where string will be stored 
0f76			 
0f76			 
0f76			; TODO check limit of buffer for new inserts 
0f76			; TODO check insert does not push beyond buffer 
0f76			; TODO scroll in a limited display area 
0f76			; TODO scroll whole screen on page wrap 
0f76			 
0f76			 
0f76			; TODO handle KEY_PREVWORD 
0f76			; TODO handle KEY_NEXTWORD 
0f76			; TODO handle KEY_HOME 
0f76			; TODO handle KEY_END 
0f76			; TODO use LCD cursor? 
0f76			 
0f76 32 ad fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f79 81					add c 
0f7a 32 ab fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f7d 22 b0 fe				ld (input_start), hl     ; save ptr to buffer 
0f80 79					ld a, c 
0f81 cd 49 0f				call addatohl 
0f84 22 b2 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f87 7a					ld a,d 
0f88 32 af fe			        ld (input_size), a       ; save length of input area 
0f8b 79					ld a, c 
0f8c 32 9e fe				ld (input_cursor),a      ; init cursor start position  
0f8f 7b					ld a,e 
0f90 32 ae fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f93					 
0f93					 
0f93			 
0f93			;		ld a,(input_ptr) 
0f93			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f93			 
0f93			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f93					; init cursor shape if not set by the cin routines 
0f93 21 4d fd				ld hl, cursor_shape 
0f96 3e ff				ld a, 255 
0f98 77					ld (hl), a 
0f99 23					inc hl 
0f9a 3e 00				ld a, 0 
0f9c 77					ld (hl), a 
0f9d			 
0f9d 3e 0f				ld a, CUR_BLINK_RATE 
0f9f 32 a9 fe				ld (input_cur_flash), a 
0fa2 3e 01				ld a, 1 
0fa4 32 a8 fe				ld (input_cur_onoff),a 
0fa7			 
0fa7			;	if DEBUG_INPUT 
0fa7			;		push af 
0fa7			;		ld a, 'I' 
0fa7			;		ld (debug_mark),a 
0fa7			;		pop af 
0fa7			;		CALLMONITOR 
0fa7			;	endif 
0fa7			.is1:		; main entry loop 
0fa7			 
0fa7			 
0fa7			 
0fa7					; pause 1ms 
0fa7			 
0fa7 3e 01				ld a, 1 
0fa9 cd 77 0c				call aDelayInMS 
0fac			 
0fac					; dec flash counter 
0fac 3a a9 fe				ld a, (input_cur_flash) 
0faf 3d					dec a 
0fb0 32 a9 fe				ld (input_cur_flash), a 
0fb3 fe 00				cp 0 
0fb5 20 0d				jr nz, .nochgstate 
0fb7			 
0fb7			 
0fb7					; change state 
0fb7 3a a8 fe				ld a,(input_cur_onoff) 
0fba ed 44				neg 
0fbc 32 a8 fe				ld (input_cur_onoff),a 
0fbf			 
0fbf			 
0fbf					; reset on change of state 
0fbf 3e 0f				ld a, CUR_BLINK_RATE 
0fc1 32 a9 fe				ld (input_cur_flash), a 
0fc4			 
0fc4			.nochgstate: 
0fc4					 
0fc4					 
0fc4			 
0fc4					; display cursor  
0fc4			 
0fc4			;		ld hl, (input_start) 
0fc4			;		ld a, (input_cursor) 
0fc4			;		call addatohl 
0fc4			 
0fc4					; get char under cursor and replace with cursor 
0fc4 2a b2 fe		ld hl, (input_ptr) 
0fc7			;		ld a, (hl) 
0fc7			;		ld (input_under_cursor),a 
0fc7			;		ld a, '_' 
0fc7			;		ld (hl), a 
0fc7			 
0fc7					; display string 
0fc7			 
0fc7 ed 5b b0 fe			ld de, (input_start) 
0fcb 3a ad fe				ld a, (input_at_pos) 
0fce cd 28 0d				call str_at_display 
0fd1			;	        call update_display 
0fd1			 
0fd1					; find place to put the cursor 
0fd1			;		add h 
0fd1			;		ld l, display_row_1 
0fd1			;		sub l 
0fd1			; (input_at_pos) 
0fd1					;ld c, a 
0fd1			;		ld a, (input_cursor) 
0fd1			;		ld l, (input_at_pos) 
0fd1			;		;ld b, h 
0fd1			;		add l 
0fd1			;		ld (input_at_cursor),a 
0fd1					;ld l,h 
0fd1			 
0fd1			;		ld h, 0 
0fd1			;		ld l,(input_at_pos) 
0fd1			;		ld a, (input_cursor) 
0fd1			;		call addatohl 
0fd1			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd1			;		call subafromhl 
0fd1			;		ld a,l 
0fd1			;		ld (input_at_cursor), a 
0fd1			 
0fd1				if DEBUG_INPUT 
0fd1					ld a, (hardware_diag) 
0fd1					cp 0 
0fd1					jr z, .skip_input_diag 
0fd1			 
0fd1					ld a,(input_at_pos) 
0fd1					ld hl, LFSRSeed 
0fd1					call hexout 
0fd1					ld a, (input_cursor) 
0fd1					ld hl, LFSRSeed+2 
0fd1					call hexout 
0fd1					ld a,(input_at_cursor) 
0fd1					ld hl, LFSRSeed+4 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_cur_onoff) 
0fd1					ld hl, LFSRSeed+6 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_cur_flash) 
0fd1					ld hl, LFSRSeed+8 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_len) 
0fd1					ld hl, LFSRSeed+10 
0fd1					call hexout 
0fd1					ld hl, LFSRSeed+12 
0fd1					ld a, 0 
0fd1					ld (hl),a 
0fd1					ld a, display_row_4 
0fd1					ld de, LFSRSeed 
0fd1					call str_at_display 
0fd1					.skip_input_diag: 
0fd1				endif 
0fd1			 
0fd1					; decide on if we are showing the cursor this time round 
0fd1			 
0fd1 3a a8 fe				ld a, (input_cur_onoff) 
0fd4 fe ff				cp 255 
0fd6 28 13				jr z, .skipcur 
0fd8			 
0fd8			 
0fd8 3a ab fe				ld a,(input_at_cursor) 
0fdb 11 4d fd				ld de, cursor_shape 
0fde cd 28 0d				call str_at_display 
0fe1			 
0fe1					; save length of current input string 
0fe1 2a b0 fe				ld hl, (input_start) 
0fe4 cd a7 13				call strlenz 
0fe7 7d					ld a,l 
0fe8 32 a3 fe				ld (input_len),a 
0feb			 
0feb			.skipcur: 
0feb			 
0feb cd 38 0d			        call update_display 
0fee					 
0fee			 
0fee			 
0fee					; wait 
0fee				 
0fee					; TODO loop without wait to flash the cursor and char under cursor	 
0fee cd 6c 74				call cin    ; _wait 
0ff1			 
0ff1 fe 00				cp 0 
0ff3 ca a7 0f				jp z, .is1 
0ff6			 
0ff6					; get ptr to char to input into 
0ff6			 
0ff6 4f					ld c,a 
0ff7 2a b0 fe				ld hl, (input_start) 
0ffa 3a 9e fe				ld a, (input_cursor) 
0ffd cd 49 0f				call addatohl 
1000 22 b2 fe				ld (input_ptr), hl 
1003 79					ld a,c 
1004			 
1004					; replace char under cursor 
1004			 
1004			;		ld hl, (input_ptr) 
1004			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1004			;		ld (hl), a 
1004			 
1004			;	if DEBUG_INPUT 
1004			;		push af 
1004			;		ld a, 'i' 
1004			;		ld (debug_mark),a 
1004			;		pop af 
1004			;		CALLMONITOR 
1004			;	endif 
1004 fe 0e				cp KEY_HOME 
1006 20 0e				jr nz, .iske 
1008			 
1008 3a ad fe				ld a, (input_at_pos) 
100b 32 ab fe				ld (input_at_cursor),a 
100e 3e 00				ld a, 0 
1010 32 9e fe				ld (input_cursor), a 
1013 c3 a7 0f				jp .is1 
1016					 
1016 fe 0f		.iske:		cp KEY_END 
1018 20 03				jr nz, .isknw 
101a c3 a7 0f				jp .is1 
101d			 
101d fe 06		.isknw:		cp KEY_NEXTWORD 
101f 20 1b				jr nz, .iskpw 
1021			 
1021 2a b2 fe		.isknwm:	ld hl, (input_ptr) 
1024 7e					ld a,(hl)	 
1025 fe 00				cp 0 
1027 ca a7 0f				jp z, .is1    ; end of string 
102a fe 20				cp ' ' 
102c ca a7 0f				jp z, .is1    ; end of word 
102f 23					inc hl 
1030 22 b2 fe				ld (input_ptr), hl 
1033 3a ab fe				ld a, (input_at_cursor) 
1036 3c					inc a 
1037 32 ab fe				ld (input_at_cursor), a 
103a 18 e5				jr .isknwm 
103c			 
103c fe 07		.iskpw:		cp KEY_PREVWORD 
103e 20 1b				jr nz, .iskl 
1040			.iskpwm:	 
1040 2a b2 fe				ld hl, (input_ptr) 
1043 7e					ld a,(hl)	 
1044 fe 00				cp 0  
1046 ca a7 0f				jp z, .is1    ; end of string 
1049 fe 20				cp ' ' 
104b ca a7 0f				jp z, .is1    ; end of word 
104e 2b					dec hl 
104f 22 b2 fe				ld (input_ptr), hl 
1052 3a ab fe				ld a, (input_at_cursor) 
1055 3d					dec a 
1056 32 ab fe				ld (input_at_cursor), a 
1059 18 e5				jr .iskpwm 
105b			 
105b			 
105b fe 0b		.iskl:		cp KEY_LEFT 
105d 20 27				jr nz, .isk1 
105f			 
105f 3a 9e fe				ld a, (input_cursor) 
1062			 
1062 fe 00				cp 0 
1064 ca a7 0f				jp z, .is1 		; at start of line to ignore  
1067			 
1067 3d					dec  a 		; TODO check underflow 
1068 32 9e fe				ld (input_cursor), a 
106b			 
106b 2a b2 fe				ld hl, (input_ptr) 
106e 2b					dec hl 
106f 22 b2 fe				ld (input_ptr), hl 
1072					 
1072 3a ab fe				ld a, (input_at_cursor) 
1075 3d					dec a 
1076 32 ab fe				ld (input_at_cursor), a 
1079			 
1079 3e 01				ld a, 1		; show cursor moving 
107b 32 a8 fe				ld (input_cur_onoff),a 
107e 3e 0f				ld a, CUR_BLINK_RATE 
1080 32 a9 fe				ld (input_cur_flash), a 
1083			 
1083 c3 a7 0f				jp .is1 
1086			 
1086 fe 0c		.isk1:		cp KEY_RIGHT 
1088 20 2a				jr nz, .isk2 
108a			 
108a 3a a3 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
108d 5f					ld e,a 
108e 3a 9e fe				ld a, (input_cursor) 
1091 bb					cp e 
1092 ca a7 0f				jp z, .is1		; at the end of string so dont go right 
1095			 
1095 3c					inc  a 		; TODO check overflow 
1096 32 9e fe				ld (input_cursor), a 
1099			 
1099 3a ab fe				ld a, (input_at_cursor) 
109c 3c					inc a 
109d 32 ab fe				ld (input_at_cursor), a 
10a0			 
10a0 2a b2 fe				ld hl, (input_ptr) 
10a3 23					inc hl 
10a4 22 b2 fe				ld (input_ptr), hl 
10a7			 
10a7 3e 01				ld a, 1		; show cursor moving 
10a9 32 a8 fe				ld (input_cur_onoff),a 
10ac 3e 0f				ld a, CUR_BLINK_RATE 
10ae 32 a9 fe				ld (input_cur_flash), a 
10b1			 
10b1 c3 a7 0f				jp .is1 
10b4			 
10b4 fe 05		.isk2:		cp KEY_UP 
10b6			 
10b6 20 26				jr nz, .isk3 
10b8			 
10b8					; swap last command with the current on 
10b8			 
10b8					; move cursor to start of string 
10b8 2a b0 fe				ld hl, (input_start) 
10bb 22 b2 fe				ld (input_ptr), hl 
10be			 
10be 3a ad fe				ld a, (input_at_pos) 
10c1 32 ab fe				ld (input_at_cursor), a 
10c4			 
10c4 3e 00				ld a, 0 
10c6 32 9e fe				ld (input_cursor), a 
10c9					 
10c9					; swap input and last command buffers 
10c9			 
10c9 21 75 f6				ld hl, os_cli_cmd 
10cc 11 74 f7				ld de, os_last_cmd 
10cf 06 ff				ld b, 255 
10d1 7e			.swap1:		ld a, (hl) 
10d2 4f					ld c,a 
10d3 1a					ld a, (de) 
10d4 77					ld (hl), a 
10d5 79					ld a,c 
10d6 12					ld (de),a 
10d7 23					inc hl 
10d8 13					inc de 
10d9 10 f6				djnz .swap1 
10db			 
10db			 
10db			 
10db			 
10db			 
10db c3 a7 0f				jp .is1 
10de			 
10de fe 08		.isk3:		cp KEY_BS 
10e0 20 3c				jr nz, .isk4 
10e2			 
10e2 3a 9e fe				ld a, (input_cursor) 
10e5			 
10e5 fe 00				cp 0 
10e7 ca a7 0f				jp z, .is1 		; at start of line to ignore  
10ea			 
10ea 3d					dec  a 		; TODO check underflow 
10eb 32 9e fe				ld (input_cursor), a 
10ee			 
10ee					; hl is source 
10ee					; de needs to be source - 1 
10ee			 
10ee			;		ld a, 0 
10ee			;		dec hl 
10ee			;		ld (hl), a 
10ee			 
10ee 2a b2 fe				ld hl, (input_ptr) 
10f1 2b					dec hl 
10f2 22 b2 fe				ld (input_ptr), hl 
10f5			 
10f5					; shift all data 
10f5			 
10f5 e5					push hl 
10f6 23					inc hl 
10f7 d1					pop de 
10f8 3a a3 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10fb 4f					ld c,a 
10fc 06 00				ld b,0 
10fe ed b0				ldir  
1100			 
1100			 
1100			 
1100			 
1100 3a ab fe				ld a, (input_at_cursor) 
1103 3d					dec a 
1104 32 ab fe				ld (input_at_cursor), a 
1107			 
1107			 
1107 3e 01				ld a, 1		; show cursor moving 
1109 32 a8 fe				ld (input_cur_onoff),a 
110c 3e 0f				ld a, CUR_BLINK_RATE 
110e 32 a9 fe				ld (input_cur_flash), a 
1111			 
1111					; remove char 
1111 3a ab fe				ld a, (input_at_cursor) 
1114 3c					inc a 
1115 11 9f 11				ld de,.iblank 
1118 cd 28 0d				call str_at_display 
111b			 
111b c3 a7 0f				jp .is1 
111e			 
111e fe 0d		.isk4:		cp KEY_CR 
1120 28 6c				jr z, .endinput 
1122			 
1122					; else add the key press to the end 
1122			 
1122 4f					ld c, a			; save key pressed 
1123			 
1123 7e					ld a,(hl)		; get what is currently under char 
1124			 
1124 fe 00				cp 0			; we are at the end of the string 
1126 20 2f				jr nz, .onchar 
1128					 
1128					; add a char to the end of the string 
1128				 
1128 71					ld (hl),c 
1129 23					inc hl 
112a			;		ld a,' ' 
112a			;		ld (hl),a 
112a			;		inc hl 
112a 3e 00				ld a,0 
112c 77					ld (hl),a 
112d 2b					dec hl 
112e			 
112e 3a 9e fe				ld a, (input_cursor) 
1131 3c					inc a				; TODO check max string length and scroll  
1132 32 9e fe				ld (input_cursor), a		; inc cursor pos 
1135							 
1135 3a ab fe				ld a, (input_at_cursor) 
1138 3c					inc a 
1139 32 ab fe				ld (input_at_cursor), a 
113c			 
113c 2a b2 fe				ld hl, (input_ptr) 
113f 23					inc hl 
1140 22 b2 fe				ld (input_ptr), hl 
1143			 
1143 2a b2 fe				ld hl, (input_ptr) 
1146 23					inc hl 
1147 22 b2 fe				ld (input_ptr), hl 
114a			;	if DEBUG_INPUT 
114a			;		push af 
114a			;		ld a, '+' 
114a			;		ld (debug_mark),a 
114a			;		pop af 
114a			;		CALLMONITOR 
114a			;	endif 
114a 3e 01				ld a, 1		; show cursor moving 
114c 32 a8 fe				ld (input_cur_onoff),a 
114f 3e 0f				ld a, CUR_BLINK_RATE 
1151 32 a9 fe				ld (input_cur_flash), a 
1154 c3 a7 0f				jp .is1 
1157					 
1157			 
1157			 
1157					; if on a char then insert 
1157			.onchar: 
1157			 
1157					; TODO over flow check: make sure insert does not blow out buffer 
1157			 
1157					; need to do some maths to use lddr 
1157			 
1157 e5					push hl   ; save char pos 
1158 c5					push bc 
1159			 
1159 2a b0 fe				ld hl, (input_start) 
115c 3a a3 fe				ld a, (input_len) 
115f cd 49 0f				call addatohl  		; end of string 
1162 23					inc hl 
1163 23					inc hl		; past zero term 
1164 e5					push hl 
1165 23					inc hl 
1166 e5					push hl  
1167			 
1167								; start and end of lddr set, now how much to move? 
1167			 
1167							 
1167 3a 9e fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
116a 47					ld b,a 
116b 3a a3 fe				ld a,(input_len) 
116e 5f					ld e,a 
116f 90					sub b 
1170 3c					inc a		;?? 
1171 3c					inc a		;?? 
1172 3c					inc a		;?? 
1173			 
1173 06 00				ld b,0 
1175 4f					ld c,a 
1176			 
1176				if DEBUG_INPUT 
1176					push af 
1176					ld a, 'i' 
1176					ld (debug_mark),a 
1176					pop af 
1176			;		CALLMONITOR 
1176				endif 
1176 d1					pop de 
1177 e1					pop hl 
1178				if DEBUG_INPUT 
1178					push af 
1178					ld a, 'I' 
1178					ld (debug_mark),a 
1178					pop af 
1178			;		CALLMONITOR 
1178				endif 
1178 ed b8				lddr 
117a				 
117a			 
117a			 
117a					; TODO have a key for insert/overwrite mode???? 
117a c1					pop bc 
117b e1					pop hl 
117c 71					ld (hl), c		; otherwise overwrite current char 
117d					 
117d			 
117d			 
117d			 
117d 3a 9e fe				ld a, (input_cursor) 
1180 3c					inc  a 		; TODO check overflow 
1181 32 9e fe				ld (input_cursor), a 
1184			 
1184 3a ab fe				ld a, (input_at_cursor) 
1187 3c					inc a 
1188 32 ab fe				ld (input_at_cursor), a 
118b			 
118b c3 a7 0f				jp .is1 
118e			 
118e			.endinput:	; TODO look for end of string 
118e			 
118e					; add trailing space for end of token 
118e			 
118e 2a b0 fe				ld hl, (input_start) 
1191 3a a3 fe				ld a,(input_len) 
1194 cd 49 0f				call addatohl 
1197 3e 20				ld a, ' ' 
1199 77					ld (hl),a 
119a					; TODO eof of parse marker 
119a			 
119a 23					inc hl 
119b 3e 00				ld a, 0 
119d 77					ld (hl),a 
119e			 
119e			 
119e c9					ret 
119f			 
119f .. 00		.iblank: db " ",0 
11a1			 
11a1			 
11a1 32 ad fe		input_str_prev:	ld (input_at_pos), a 
11a4 22 b0 fe				ld (input_start), hl 
11a7 3e 01				ld a,1			; add cursor 
11a9 77					ld (hl),a 
11aa 23					inc hl 
11ab 3e 00				ld a,0 
11ad 77					ld (hl),a 
11ae 22 b2 fe				ld (input_ptr), hl 
11b1 7a					ld a,d 
11b2 32 af fe				ld (input_size), a 
11b5 3e 00				ld a,0 
11b7 32 9e fe				ld (input_cursor),a 
11ba			.instr1:	 
11ba			 
11ba					; TODO do block cursor 
11ba					; TODO switch cursor depending on the modifer key 
11ba			 
11ba					; update cursor shape change on key hold 
11ba			 
11ba 2a b2 fe				ld hl, (input_ptr) 
11bd 2b					dec hl 
11be 3a 4d fd				ld a,(cursor_shape) 
11c1 77					ld (hl), a 
11c2			 
11c2					; display entered text 
11c2 3a ad fe				ld a,(input_at_pos) 
11c5 cd 8a 73		            	CALL fLCD_Pos       ;Position cursor to location in A 
11c8 ed 5b b0 fe	            	LD   de, (input_start) 
11cc cd 92 73		            	CALL fLCD_Str       ;Display string pointed to by DE 
11cf			 
11cf cd 6c 74				call cin 
11d2 fe 00				cp 0 
11d4 28 e4				jr z, .instr1 
11d6			 
11d6					; proecess keyboard controls first 
11d6			 
11d6 2a b2 fe				ld hl,(input_ptr) 
11d9			 
11d9 fe 0d				cp KEY_CR	 ; pressing enter ends input 
11db 28 5a				jr z, .instrcr 
11dd			 
11dd fe 08				cp KEY_BS 	; back space 
11df 20 0f				jr nz, .instr2 
11e1					; process back space 
11e1			 
11e1					; TODO stop back space if at start of string 
11e1 2b					dec hl 
11e2 2b					dec hl ; to over write cursor 
11e3 3a 4d fd				ld a,(cursor_shape) 
11e6					;ld a,0 
11e6 77					ld (hl),a 
11e7 23					inc hl 
11e8 3e 20				ld a," " 
11ea 77					ld (hl),a 
11eb 22 b2 fe				ld (input_ptr),hl 
11ee					 
11ee			 
11ee 18 ca				jr .instr1 
11f0			 
11f0 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11f2 20 06				jr nz, .instr3 
11f4 2b					dec hl 
11f5 22 b2 fe				ld (input_ptr),hl 
11f8 18 c0				jr .instr1 
11fa				 
11fa fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11fc 20 06				jr nz, .instr4 
11fe 23					inc hl 
11ff 22 b2 fe				ld (input_ptr),hl 
1202 18 b6				jr .instr1 
1204			 
1204 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1206 20 06				jr nz, .instr5 
1208 2b					dec hl 
1209 22 b2 fe				ld (input_ptr),hl 
120c 18 ac				jr .instr1 
120e			 
120e fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1210 20 06				jr nz, .instr6 
1212 2b					dec hl 
1213 22 b2 fe				ld (input_ptr),hl 
1216 18 a2				jr .instr1 
1218 fe 05		.instr6:        cp KEY_UP      ; recall last command 
121a 20 0b				jr nz, .instrnew 
121c			 
121c 21 4e f3			ld hl, scratch 
121f 11 74 f7			ld de, os_last_cmd 
1222 cd 40 12			call strcpy 
1225 18 93				jr .instr1 
1227			 
1227			 
1227			.instrnew:	; no special key pressed to see if we have room to store it 
1227			 
1227					; TODO do string size test 
1227			 
1227 2b					dec hl ; to over write cursor 
1228 77					ld (hl),a 
1229 23					inc hl 
122a 3a 4d fd				ld a,(cursor_shape) 
122d 77					ld (hl),a 
122e 23					inc hl 
122f 3e 00				ld a,0 
1231 77					ld (hl),a 
1232			 
1232 22 b2 fe				ld (input_ptr),hl 
1235					 
1235 18 83				jr .instr1 
1237 2b			.instrcr:	dec hl		; remove cursor 
1238 3e 20				ld a,' '	; TODO add a trailing space for safety 
123a 77					ld (hl),a 
123b 23					inc hl 
123c 3e 00				ld a,0 
123e 77					ld (hl),a 
123f			 
123f			 
123f					; if at end of line scroll up    
123f					; TODO detecting only end of line 4 for scroll up  
123f			 
123f					;ld   
123f			 
123f c9					ret 
1240			 
1240			 
1240			; strcpy hl = dest, de source 
1240			 
1240 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1241 b7			            OR   A              ;Null terminator? 
1242 c8			            RET  Z              ;Yes, so finished 
1243 1a					ld a,(de) 
1244 77					ld (hl),a 
1245 13			            INC  DE             ;Point to next character 
1246 23					inc hl 
1247 18 f7		            JR   strcpy       ;Repeat 
1249 c9					ret 
124a			 
124a			 
124a			; TODO string_at  
124a			; pass string which starts with lcd offset address and then null term string 
124a			 
124a			; TODO string to dec 
124a			; TODO string to hex 
124a			; TODO byte to string hex 
124a			; TODO byte to string dec 
124a			 
124a			 
124a			 
124a			; from z80uartmonitor 
124a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124a			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
124a			; pass hl for where to put the text 
124a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124a c5			hexout:	PUSH BC 
124b f5					PUSH AF 
124c 47					LD B, A 
124d					; Upper nybble 
124d cb 3f				SRL A 
124f cb 3f				SRL A 
1251 cb 3f				SRL A 
1253 cb 3f				SRL A 
1255 cd 65 12				CALL tohex 
1258 77					ld (hl),a 
1259 23					inc hl	 
125a					 
125a					; Lower nybble 
125a 78					LD A, B 
125b e6 0f				AND 0FH 
125d cd 65 12				CALL tohex 
1260 77					ld (hl),a 
1261 23					inc hl	 
1262					 
1262 f1					POP AF 
1263 c1					POP BC 
1264 c9					RET 
1265					 
1265			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1265			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1265			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1265			tohex: 
1265 e5					PUSH HL 
1266 d5					PUSH DE 
1267 16 00				LD D, 0 
1269 5f					LD E, A 
126a 21 72 12				LD HL, .DATA 
126d 19					ADD HL, DE 
126e 7e					LD A, (HL) 
126f d1					POP DE 
1270 e1					POP HL 
1271 c9					RET 
1272			 
1272			.DATA: 
1272 30					DEFB	30h	; 0 
1273 31					DEFB	31h	; 1 
1274 32					DEFB	32h	; 2 
1275 33					DEFB	33h	; 3 
1276 34					DEFB	34h	; 4 
1277 35					DEFB	35h	; 5 
1278 36					DEFB	36h	; 6 
1279 37					DEFB	37h	; 7 
127a 38					DEFB	38h	; 8 
127b 39					DEFB	39h	; 9 
127c 41					DEFB	41h	; A 
127d 42					DEFB	42h	; B 
127e 43					DEFB	43h	; C 
127f 44					DEFB	44h	; D 
1280 45					DEFB	45h	; E 
1281 46					DEFB	46h	; F 
1282			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1282			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1282			;;    subtract $30, if result > 9 then subtract $7 more 
1282			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1282			atohex: 
1282 d6 30				SUB $30 
1284 fe 0a				CP 10 
1286 f8					RET M		; If result negative it was 0-9 so we're done 
1287 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1289 c9					RET		 
128a			 
128a			 
128a			 
128a			 
128a			; Get 2 ASCII characters as hex byte from pointer in hl 
128a			 
128a			BYTERD: 
128a 16 00			LD	D,00h		;Set up 
128c cd 94 12			CALL	HEXCON		;Get byte and convert to hex 
128f 87				ADD	A,A		;First nibble so 
1290 87				ADD	A,A		;multiply by 16 
1291 87				ADD	A,A		; 
1292 87				ADD	A,A		; 
1293 57				LD	D,A		;Save hi nibble in D 
1294			HEXCON: 
1294 7e				ld a, (hl)		;Get next chr 
1295 23				inc hl 
1296 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1298 fe 0a			CP	00Ah		;Is it 0-9 ? 
129a 38 02			JR	C,NALPHA	;If so miss next bit 
129c d6 07			SUB	007h		;Else convert alpha 
129e			NALPHA: 
129e b2				OR	D		;Add hi nibble back 
129f c9				RET			; 
12a0			 
12a0			 
12a0			; 
12a0			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12a0			; Since the routines get_byte and therefore get_nibble are called, only valid 
12a0			; characters (0-9a-f) are accepted. 
12a0			; 
12a0			;get_word        push    af 
12a0			;                call    get_byte        ; Get the upper byte 
12a0			;                ld      h, a 
12a0			;                call    get_byte        ; Get the lower byte 
12a0			;                ld      l, a 
12a0			;                pop     af 
12a0			;                ret 
12a0			; 
12a0			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12a0			; the routine get_nibble is used only valid characters are accepted - the  
12a0			; input routine only accepts characters 0-9a-f. 
12a0			; 
12a0 c5			get_byte:        push    bc              ; Save contents of B (and C) 
12a1 7e					ld a,(hl) 
12a2 23					inc hl 
12a3 cd c8 12		                call    nibble2val      ; Get upper nibble 
12a6 cb 07		                rlc     a 
12a8 cb 07		                rlc     a 
12aa cb 07		                rlc     a 
12ac cb 07		                rlc     a 
12ae 47			                ld      b, a            ; Save upper four bits 
12af 7e					ld a,(hl) 
12b0 cd c8 12		                call    nibble2val      ; Get lower nibble 
12b3 b0			                or      b               ; Combine both nibbles 
12b4 c1			                pop     bc              ; Restore B (and C) 
12b5 c9			                ret 
12b6			; 
12b6			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b6			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b6			; to the serial line interface. The lower 4 bits of A contain the value of  
12b6			; that particular digit. 
12b6			; 
12b6			;get_nibble      ld a,(hl)           ; Read a character 
12b6			;                call    to_upper        ; Convert to upper case 
12b6			;                call    is_hex          ; Was it a hex digit? 
12b6			;                jr      nc, get_nibble  ; No, get another character 
12b6			 ;               call    nibble2val      ; Convert nibble to value 
12b6			 ;               call    print_nibble 
12b6			 ;               ret 
12b6			; 
12b6			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b6			; A valid hexadecimal digit is denoted by a set C flag. 
12b6			; 
12b6			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b6			;                ret     nc              ; Yes 
12b6			;                cp      '0'             ; Less than '0'? 
12b6			;                jr      nc, is_hex_1    ; No, continue 
12b6			;                ccf                     ; Complement carry (i.e. clear it) 
12b6			;                ret 
12b6			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b6			;                ret     c               ; Yes 
12b6			;                cp      'A'             ; Less than 'A'? 
12b6			;                jr      nc, is_hex_2    ; No, continue 
12b6			;                ccf                     ; Yes - clear carry and return 
12b6			;                ret 
12b6			;is_hex_2        scf                     ; Set carry 
12b6			;                ret 
12b6			; 
12b6			; Convert a single character contained in A to upper case: 
12b6			; 
12b6 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12b8 d8			                ret     c 
12b9 fe 7b		                cp      'z' + 1         ; > 'z'? 
12bb d0			                ret     nc              ; Nothing to do, either 
12bc e6 5f		                and     $5f             ; Convert to upper case 
12be c9			                ret 
12bf			 
12bf			 
12bf			to_lower: 
12bf			 
12bf			   ; if char is in [A-Z] make it lower case 
12bf			 
12bf			   ; enter : a = char 
12bf			   ; exit  : a = lower case char 
12bf			   ; uses  : af 
12bf			 
12bf fe 41		   cp 'A' 
12c1 d8			   ret c 
12c2			    
12c2 fe 5b		   cp 'Z'+1 
12c4 d0			   ret nc 
12c5			    
12c5 f6 20		   or $20 
12c7 c9			   ret 
12c8			 
12c8			; 
12c8			; Expects a hexadecimal digit (upper case!) in A and returns the 
12c8			; corresponding value in A. 
12c8			; 
12c8 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12ca 38 02		                jr      c, nibble2val_1 ; Yes 
12cc d6 07		                sub     7               ; Adjust for A-F 
12ce d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12d0 e6 0f		                and     $f              ; Only return lower 4 bits 
12d2 c9			                ret 
12d3			; 
12d3			; Print_nibble prints a single hex nibble which is contained in the lower  
12d3			; four bits of A: 
12d3			; 
12d3			;print_nibble    push    af              ; We won't destroy the contents of A 
12d3			;                and     $f              ; Just in case... 
12d3			;                add     a, '0'             ; If we have a digit we are done here. 
12d3			;                cp      '9' + 1         ; Is the result > 9? 
12d3			;                jr      c, print_nibble_1 
12d3			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12d3			;print_nibble_1  call    putc            ; Print the nibble and 
12d3			;                pop     af              ; restore the original value of A 
12d3			;                ret 
12d3			;; 
12d3			;; Send a CR/LF pair: 
12d3			; 
12d3			;crlf            push    af 
12d3			;                ld      a, cr 
12d3			;                call    putc 
12d3			;                ld      a, lf 
12d3			;                call    putc 
12d3			;                pop     af 
12d3			;                ret 
12d3			; 
12d3			; Print_word prints the four hex digits of a word to the serial line. The  
12d3			; word is expected to be in HL. 
12d3			; 
12d3			;print_word      push    hl 
12d3			;                push    af 
12d3			;                ld      a, h 
12d3			;                call    print_byte 
12d3			;                ld      a, l 
12d3			;                call    print_byte 
12d3			;                pop     af 
12d3			;                pop     hl 
12d3			;                ret 
12d3			; 
12d3			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12d3			; The byte to be printed is expected to be in A. 
12d3			; 
12d3			;print_byte      push    af              ; Save the contents of the registers 
12d3			;                push    bc 
12d3			;                ld      b, a 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                call    print_nibble    ; Print high nibble 
12d3			;                ld      a, b 
12d3			;                call    print_nibble    ; Print low nibble 
12d3			;                pop     bc              ; Restore original register contents 
12d3			;                pop     af 
12d3			;                ret 
12d3			 
12d3			 
12d3			 
12d3			 
12d3			 
12d3			fourehexhl:  
12d3 7e				ld a,(hl) 
12d4 cd 82 12			call atohex 
12d7 cb 3f				SRL A 
12d9 cb 3f				SRL A 
12db cb 3f				SRL A 
12dd cb 3f				SRL A 
12df 47				ld b, a 
12e0 23				inc hl 
12e1 7e				ld a,(hl) 
12e2 23				inc hl 
12e3 cd 82 12			call atohex 
12e6 80				add b 
12e7 57				ld d,a 
12e8 7e				ld a,(hl) 
12e9 cd 82 12			call atohex 
12ec cb 3f				SRL A 
12ee cb 3f				SRL A 
12f0 cb 3f				SRL A 
12f2 cb 3f				SRL A 
12f4 47				ld b, a 
12f5 23				inc hl 
12f6 7e				ld a,(hl) 
12f7 23				inc hl 
12f8 cd 82 12			call atohex 
12fb 80				add b 
12fc 5f				ld e, a 
12fd d5				push de 
12fe e1				pop hl 
12ff c9				ret 
1300			 
1300			; pass hl. returns z set if the byte at hl is a digit 
1300			;isdigithl:  
1300			;	push bc 
1300			;	ld a,(hl) 
1300			;	cp ':' 
1300			;	jr nc, .isdf 		; > 
1300			;	cp '0' 
1300			;	jr c, .isdf		; < 
1300			; 
1300			;	; TODO find a better way to set z 
1300			; 
1300			;	ld b,a 
1300			;	cp b 
1300			;	pop bc 
1300			;	ret 
1300			; 
1300			;.isdf:	; not digit so clear z 
1300			; 
1300			;	; TODO find a better way to unset z 
1300			; 
1300			;	ld b,a 
1300			;	inc b 
1300			;	cp b 
1300			; 
1300			;	pop bc 
1300			;	ret 
1300				 
1300				 
1300			 
1300			 
1300			; pass hl as the four byte address to load 
1300			 
1300			get_word_hl:  
1300 e5				push hl 
1301 cd a0 12			call get_byte 
1304				 
1304 47				ld b, a 
1305			 
1305 e1				pop hl 
1306 23				inc hl 
1307 23				inc hl 
1308			 
1308			; TODO not able to handle a-f  
1308 7e				ld a,(hl) 
1309			;	;cp ':' 
1309			;	cp 'g' 
1309			;	jr nc, .single_byte_hl 		; > 
1309			;	cp 'G' 
1309			;	jr nc, .single_byte_hl 		; > 
1309			;	cp '0' 
1309			;	jr c, .single_byte_hl		; < 
1309			 
1309				;call isdigithl 
1309 fe 00			cp 0 
130b 28 06			jr z, .single_byte_hl 
130d			 
130d			.getwhln:   ; hex word so get next byte 
130d			 
130d cd a0 12			call get_byte 
1310 6f				ld l, a 
1311 60				ld h,b 
1312 c9				ret 
1313 68			.single_byte_hl:   ld l,b 
1314 26 00				ld h,0 
1316 c9					ret 
1317			 
1317			 
1317			 
1317			 
1317 21 51 1c			ld hl,asc+1 
131a			;	ld a, (hl) 
131a			;	call nibble2val 
131a cd a0 12			call get_byte 
131d			 
131d			;	call fourehexhl 
131d 32 82 f3			ld (scratch+52),a 
1320				 
1320 21 80 f3			ld hl,scratch+50 
1323 22 71 f6			ld (os_cur_ptr),hl 
1326			 
1326 c9				ret 
1327			 
1327			 
1327			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1327			 
1327			; Decimal Unsigned Version 
1327			 
1327			;Number in a to decimal ASCII 
1327			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1327			;Example: display a=56 as "056" 
1327			;input: a = number 
1327			;Output: a=0,value of a in the screen 
1327			;destroys af,bc (don't know about hl and de) 
1327			DispAToASCII: 
1327 0e 9c			ld	c,-100 
1329 cd 33 13			call	.Na1 
132c 0e f6			ld	c,-10 
132e cd 33 13			call	.Na1 
1331 0e ff			ld	c,-1 
1333 06 2f		.Na1:	ld	b,'0'-1 
1335 04			.Na2:	inc	b 
1336 81				add	a,c 
1337 38 fc			jr	c,.Na2 
1339 91				sub	c		;works as add 100/10/1 
133a f5				push af		;safer than ld c,a 
133b 78				ld	a,b		;char is in b 
133c			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
133c f1				pop af		;safer than ld a,c 
133d c9				ret 
133e			 
133e			; Decimal Signed Version 
133e			 
133e			; DispA 
133e			; -------------------------------------------------------------- 
133e			; Converts a signed integer value to a zero-terminated ASCII 
133e			; string representative of that value (using radix 10). 
133e			; -------------------------------------------------------------- 
133e			; INPUTS: 
133e			;     HL     Value to convert (two's complement integer). 
133e			;     DE     Base address of string destination. (pointer). 
133e			; -------------------------------------------------------------- 
133e			; OUTPUTS: 
133e			;     None 
133e			; -------------------------------------------------------------- 
133e			; REGISTERS/MEMORY DESTROYED 
133e			; AF HL 
133e			; -------------------------------------------------------------- 
133e			 
133e			;DispHLToASCII: 
133e			;   push    de 
133e			;   push    bc 
133e			; 
133e			;; Detect sign of HL. 
133e			;    bit    7, h 
133e			;    jr     z, ._DoConvert 
133e			; 
133e			;; HL is negative. Output '-' to string and negate HL. 
133e			;    ld     a, '-' 
133e			;    ld     (de), a 
133e			;    inc    de 
133e			; 
133e			;; Negate HL (using two's complement) 
133e			;    xor    a 
133e			;    sub    l 
133e			;    ld     l, a 
133e			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
133e			;    sbc    a, h 
133e			;    ld     h, a 
133e			; 
133e			;; Convert HL to digit characters 
133e			;._DoConvert: 
133e			;    ld     b, 0     ; B will count character length of number 
133e			;-   ld     a, 10 
133e			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
133e			;    push   af 
133e			;    inc    b 
133e			;    ld     a, h 
133e			;    or     l 
133e			;    jr     nz, - 
133e			; 
133e			;; Retrieve digits from stack 
133e			;-   pop    af 
133e			;    or     $30 
133e			;    ld     (de), a 
133e			;    inc    de 
133e			;    djnz   - 
133e			; 
133e			;; Terminate string with NULL 
133e			;    xor    a 
133e			;    ld     (de), a 
133e			; 
133e			;    pop    bc 
133e			;    pop    de 
133e			;    ret 
133e			 
133e			;Comments 
133e			; 
133e			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
133e			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
133e			;    Note that the output string will not be fixed-width. 
133e			; 
133e			;Example Usage 
133e			; 
133e			;    ld    hl, -1004 
133e			;    ld    de, OP1 
133e			;    call  DispA 
133e			;    ld    hl, OP1 
133e			;    syscall  PutS 
133e			 
133e			 
133e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
133e			 
133e			 
133e			;Converts an ASCII string to an unsigned 16-bit integer 
133e			;Quits when it reaches a non-decimal digit 
133e			 
133e			string_to_uint16: 
133e			atoui_16: 
133e			;Input: 
133e			;     DE points to the string 
133e			;Outputs: 
133e			;     HL is the result 
133e			;     A is the 8-bit value of the number 
133e			;     DE points to the byte after the number 
133e			;Destroys: 
133e			;     BC 
133e			;       if the string is non-empty, BC is HL/10 
133e			;Size:  24 bytes 
133e			;Speed: 42+d(104+{0,9}) 
133e			;       d is the number of digits in the number 
133e			;       max is 640 cycles for a 5 digit number 
133e			;Assuming no leading zeros: 
133e			;1 digit:  146cc 
133e			;2 digit:  250cc 
133e			;3 digit:  354cc or 363cc (avg: 354.126cc) 
133e			;4 digit:  458cc or 467cc (avg: 458.27cc) 
133e			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
133e			;avg: 544.81158447265625cc (544+13297/16384) 
133e			;=============================================================== 
133e 21 00 00		  ld hl,0 
1341			.u16a: 
1341 1a			  ld a,(de) 
1342 d6 30		  sub 30h 
1344 fe 0a		  cp 10 
1346 d0			  ret nc 
1347 13			  inc de 
1348 44			  ld b,h 
1349 4d			  ld c,l 
134a 29			  add hl,hl 
134b 29			  add hl,hl 
134c 09			  add hl,bc 
134d 29			  add hl,hl 
134e 85			  add a,l 
134f 6f			  ld l,a 
1350 30 ef		  jr nc,.u16a 
1352 24			  inc h 
1353 c3 41 13		  jp .u16a 
1356			 
1356			 
1356			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1356			 
1356			;written by Zeda 
1356			;Converts a 16-bit unsigned integer to an ASCII string. 
1356			 
1356			uitoa_16: 
1356			;Input: 
1356			;   DE is the number to convert 
1356			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1356			;Output: 
1356			;   HL points to the null-terminated ASCII string 
1356			;      NOTE: This isn't necessarily the same as the input HL. 
1356 d5			  push de 
1357 c5			  push bc 
1358 f5			  push af 
1359 eb			  ex de,hl 
135a			 
135a 01 f0 d8		  ld bc,-10000 
135d 3e 2f		  ld a,'0'-1 
135f 3c			  inc a 
1360 09			  add hl,bc  
1361 38 fc		   jr c,$-2 
1363 12			  ld (de),a 
1364 13			  inc de 
1365			 
1365 01 e8 03		  ld bc,1000 
1368 3e 3a		  ld a,'9'+1 
136a 3d			  dec a  
136b 09			  add hl,bc  
136c 30 fc		   jr nc,$-2 
136e 12			  ld (de),a 
136f 13			  inc de 
1370			 
1370 01 9c ff		  ld bc,-100 
1373 3e 2f		  ld a,'0'-1 
1375 3c			  inc a  
1376 09			  add hl,bc  
1377 38 fc		   jr c,$-2 
1379 12			  ld (de),a 
137a 13			  inc de 
137b			 
137b 7d			  ld a,l 
137c 26 3a		  ld h,'9'+1 
137e 25			  dec h  
137f c6 0a		  add a,10  
1381 30 fb		   jr nc,$-3 
1383 c6 30		  add a,'0' 
1385 eb			  ex de,hl 
1386 72			  ld (hl),d 
1387 23			  inc hl 
1388 77			  ld (hl),a 
1389 23			  inc hl 
138a 36 00		  ld (hl),0 
138c			 
138c			;Now strip the leading zeros 
138c 0e fa		  ld c,-6 
138e 09			  add hl,bc 
138f 3e 30		  ld a,'0' 
1391 23			  inc hl  
1392 be			  cp (hl)  
1393 28 fc		  jr z,$-2 
1395			 
1395			;Make sure that the string is non-empty! 
1395 7e			  ld a,(hl) 
1396 b7			  or a 
1397 20 01		  jr nz,.atoub 
1399 2b			  dec hl 
139a			.atoub: 
139a			 
139a f1			  pop af 
139b c1			  pop bc 
139c d1			  pop de 
139d c9			  ret 
139e			 
139e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
139e			 
139e			toUpper: 
139e			;A is the char. 
139e			;If A is a lowercase letter, this sets it to the matching uppercase 
139e			;18cc or 30cc or 41cc 
139e			;avg: 26.75cc 
139e fe 61		  cp 'a' 
13a0 d8			  ret c 
13a1 fe 7b		  cp 'z'+1 
13a3 d0			  ret nc 
13a4 d6 20		  sub 'a'-'A' 
13a6 c9			  ret 
13a7			 
13a7			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13a7			 
13a7			; String Length 
13a7			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13a7			 
13a7			; Get the length of the null-terminated string starting at $8000 hl 
13a7			;    LD     HL, $8000 
13a7			 
13a7			strlenz: 
13a7			 
13a7 af			    XOR    A               ; Zero is the value we are looking for. 
13a8 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13a9 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13aa			                           ; 65, 536 bytes (the entire addressable memory space). 
13aa ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13ac			 
13ac			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13ac 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13ad 6f			    LD     L, A             ; number of bytes 
13ae ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13b0 2b			    DEC    HL              ; Compensate for null. 
13b1 c9				ret 
13b2			 
13b2			; Get the length of the A terminated string starting at $8000 hl 
13b2			;    LD     HL, $8000 
13b2			 
13b2			strlent: 
13b2			 
13b2			                  ; A is the value we are looking for. 
13b2 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b4 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b6			                           ; 65, 536 bytes (the entire addressable memory space). 
13b6 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13b8			 
13b8			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13b8 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13ba 2e 00		    LD     L, 0             ; number of bytes 
13bc ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13be 2b			    DEC    HL              ; Compensate for null. 
13bf c9				ret 
13c0			 
13c0			 
13c0			;Comparing Strings 
13c0			 
13c0			;IN    HL     Address of string1. 
13c0			;      DE     Address of string2. 
13c0			 
13c0			; doc given but wrong??? 
13c0			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13c0			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13c0			; tested 
13c0			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13c0			 
13c0			strcmp_old: 
13c0 e5			    PUSH   HL 
13c1 d5			    PUSH   DE 
13c2			 
13c2 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13c3 be			    CP     (HL)            ; (want to minimize work). 
13c4 38 01		    JR     C, Str1IsBigger 
13c6 7e			    LD     A, (HL) 
13c7			 
13c7			Str1IsBigger: 
13c7 4f			    LD     C, A             ; Put length in BC 
13c8 06 00		    LD     B, 0 
13ca 13			    INC    DE              ; Increment pointers to meat of string. 
13cb 23			    INC    HL 
13cc			 
13cc			CmpLoop: 
13cc 1a			    LD     A, (DE)          ; Compare bytes. 
13cd ed a1		    CPI 
13cf 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13d1 13			    INC    DE              ; Update pointer. 
13d2 ea cc 13		    JP     PE, CmpLoop 
13d5			 
13d5 d1			    POP    DE 
13d6 e1			    POP    HL 
13d7 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13d8 be			    CP     (HL) 
13d9 c9			    RET 
13da			 
13da			NoMatch: 
13da 2b			    DEC    HL 
13db be			    CP     (HL)            ; Compare again to affect carry. 
13dc d1			    POP    DE 
13dd e1			    POP    HL 
13de c9			    RET 
13df			 
13df			;; test strmp 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str2 
13df			;call strcmp 
13df			;jr z, .z1 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "NZ1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.z1: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "ZZ1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str1 
13df			;call strcmp 
13df			;jr z, .z2 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "NZ2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.z2: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "ZZ2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str2 
13df			;call strcmp 
13df			;jr c, .c1 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "Nc1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.c1: 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "cc1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str1 
13df			;call strcmp 
13df			;jr c, .c2 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "Nc2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.c2: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "cc2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;	NEXTW 
13df			;.str1:   db "string1",0 
13df			;.str2:   db "string2",0 
13df			 
13df			; only care about direct match or not 
13df			; hl and de strings 
13df			; zero set if the same 
13df			 
13df			strcmp: 
13df 1a				ld a, (de) 
13e0 be				cp (hl) 
13e1 28 02			jr z, .ssame 
13e3 b7				or a 
13e4 c9				ret 
13e5			 
13e5			.ssame:  
13e5 fe 00			cp 0 
13e7 c8				ret z 
13e8			 
13e8 23				inc hl 
13e9 13				inc de 
13ea 18 f3			jr strcmp 
13ec				 
13ec				 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			; eof 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			 
# End of file firmware_strings.asm
13ec			include "firmware_memory.asm"   ; malloc and free  
13ec			 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			.mallocsize: db "Wants malloc >256",0 
13ec			.mallocasize: db "MALLOC gives >256",0 
13ec			.malloczero: db "MALLOC gives zero",0 
13ec			 
13ec			malloc_guard_zerolen: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec				ld de, 0 
13ec			        call cmp16 
13ec				jr nz, .lowalloz 
13ec			 
13ec				push hl 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .malloczero 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec			 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				 
13ec			 
13ec				CALLMONITOR 
13ec			.lowalloz: 
13ec			 
13ec			 
13ec				pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			 
13ec			malloc_guard_entry: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec			 	or a      ;clear carry flag 
13ec				push hl 
13ec				ld de, 255 
13ec				sbc hl, de 
13ec				jr c, .lowalloc 
13ec			 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .mallocsize 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec			 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				 
13ec			 
13ec				CALLMONITOR 
13ec				jr .lowdone 
13ec			.lowalloc: 
13ec			 
13ec			 
13ec				pop hl 
13ec			.lowdone:	pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			 
13ec			malloc_guard_exit: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec			 	or a      ;clear carry flag 
13ec				push hl 
13ec				ld de, 255 
13ec				sbc hl, de 
13ec				jr c, .lowallocx 
13ec			 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .mallocasize 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				CALLMONITOR 
13ec				jr .lowdonex 
13ec			.lowallocx: 
13ec			 
13ec				pop hl 
13ec			.lowdonex:	pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			endif 
13ec			 
13ec			if MALLOC_2 
13ec			; Z80 Malloc and Free Functions 
13ec			 
13ec			; Malloc Function: 
13ec			; Input: 
13ec			;   HL: Size of block to allocate 
13ec			; Output: 
13ec			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ec			 
13ec			malloc: 
13ec				 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			call malloc_guard_entry 
13ec			endif 
13ec			 
13ec			 
13ec			 
13ec			 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "mal" 
13ec						CALLMONITOR 
13ec					endif 
13ec			    push af            ; Save AF register 
13ec			    ld a, l            ; Load low byte of size into A 
13ec			    or h               ; Check if size is zero 
13ec			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13ec			 
13ec			    ; Allocate memory 
13ec			    ld hl, (heap_start) ; Load start of heap into HL 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma1" 
13ec						CALLMONITOR 
13ec					endif 
13ec			    call malloc_internal ; Call internal malloc function 
13ec			    pop af             ; Restore AF register 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret                ; Return 
13ec			 
13ec			; Free Function: 
13ec			; Input: 
13ec			;   HL: Pointer to memory block to free 
13ec			; Output: 
13ec			;   None 
13ec			 
13ec			free: 
13ec			    push af            ; Save AF register 
13ec			    ld a, l            ; Load low byte of pointer into A 
13ec			    or h               ; Check if pointer is NULL 
13ec			    jp z, free_exit    ; If pointer is NULL, exit 
13ec			 
13ec			    ; Free memory 
13ec			    ld hl, (heap_start) ; Load start of heap into HL 
13ec			    call free_internal  ; Call internal free function 
13ec			    pop af             ; Restore AF register 
13ec			    ret                ; Return 
13ec			 
13ec			; Internal Malloc Function: 
13ec			; Input: 
13ec			;   HL: Size of block to allocate 
13ec			; Output: 
13ec			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ec			 
13ec			malloc_internal: 
13ec			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13ec			    add hl, bc         ; Add management overhead to requested size 
13ec			    ex de, hl          ; Save total size in DE, and keep it in HL 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma2" 
13ec						CALLMONITOR 
13ec					endif 
13ec			 
13ec			    ; Search for free memory block 
13ec			    ld de, (heap_end)  ; Load end of heap into DE 
13ec			    ld bc, 0           ; Initialize counter 
13ec			 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma2" 
13ec						CALLMONITOR 
13ec					endif 
13ec			malloc_search_loop: 
13ec			    ; Check if current block is free 
13ec			    ld a, (hl)         ; Load current block's status (free or used) 
13ec			    cp 0               ; Compare with zero (free) 
13ec			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13ec			 
13ec			    ; Check if current block is large enough 
13ec			    ld a, (hl+1)       ; Load high byte of block size 
13ec			    cp l               ; Compare with low byte of requested size 
13ec			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13ec			 
13ec			    ld a, (hl+2)       ; Load low byte of block size 
13ec			    cp h               ; Compare with high byte of requested size 
13ec			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13ec			 
13ec			    ; Mark block as used 
13ec			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13ec			 
13ec			    ; Calculate remaining space in block 
13ec			    ld bc, 0           ; Clear BC 
13ec			    add hl, bc         ; Increment HL to point to start of data block 
13ec			    add hl, de         ; HL = HL + DE (total size) 
13ec			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13ec			    add hl, bc         ; Add management overhead to start of data block 
13ec			 
13ec			    ; Save pointer to allocated block in HL 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma5" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			 
13ec			malloc_skip_block_check: 
13ec			    ; Move to the next block 
13ec			    ld bc, 3           ; Size of management overhead 
13ec			    add hl, bc         ; Move to the next block 
13ec			    inc de             ; Increment counter 
13ec			 
13ec			    ; Check if we have reached the end of heap 
13ec			    ld a, e            ; Load low byte of heap end address 
13ec			    cp (hl)            ; Compare with low byte of current address 
13ec			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13ec			    ld a, d            ; Load high byte of heap end address 
13ec			    cp 0               ; Check if it's zero (end of memory) 
13ec			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13ec			 
13ec			    ; If we reached here, allocation failed 
13ec			    xor a              ; Set result to NULL 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma6" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			malloc_exit: 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma7" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			 
13ec			; Internal Free Function: 
13ec			; Input: 
13ec			;   HL: Pointer to memory block to free 
13ec			; Output: 
13ec			;   None 
13ec			 
13ec			free_internal: 
13ec			    ld de, (heap_start) ; Load start of heap into DE 
13ec			    ld bc, 0            ; Initialize counter 
13ec			 
13ec			free_search_loop: 
13ec			    ; Check if current block contains the pointer 
13ec			    ld a, l             ; Load low byte of pointer 
13ec			    cp (hl+1)           ; Compare with high byte of current block's address 
13ec			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ec			    ld a, h             ; Load high byte of pointer 
13ec			    cp (hl+2)           ; Compare with low byte of current block's address 
13ec			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ec			 
13ec			    ; Mark block as free 
13ec			    ld (hl), 0          ; Set status byte to indicate free block 
13ec			    ret                 ; Return 
13ec			 
13ec			free_skip_block_check: 
13ec			    ; Move to the next block 
13ec			    ld bc, 3            ; Size of management overhead 
13ec			    add hl, bc          ; Move to the next block 
13ec			    inc de              ; Increment counter 
13ec			 
13ec			    ; Check if we have reached the end of heap 
13ec			    ld a, e             ; Load low byte of heap end address 
13ec			    cp (hl)             ; Compare with low byte of current address 
13ec			    jr nz, free_search_loop  ; If not equal, continue searching 
13ec			    ld a, d             ; Load high byte of heap end address 
13ec			    cp 0                ; Check if it's zero (end of memory) 
13ec			    jr nz, free_search_loop  ; If not zero, continue searching 
13ec			 
13ec			    ; If we reached here, pointer is not found in heap 
13ec			    ret 
13ec			 
13ec			free_exit: 
13ec			    ret                 ; Return 
13ec			 
13ec			; Define heap start and end addresses 
13ec			;heap_start:    .dw 0xC000   ; Start of heap 
13ec			;heap_end:      .dw 0xE000   ; End of heap 
13ec			 
13ec			endif 
13ec			 
13ec			 
13ec			if MALLOC_1 
13ec			 
13ec			 
13ec			 
13ec			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13ec			 
13ec			;moved to firmware.asm 
13ec			;heap_start        .equ  0x9000      ; Starting address of heap 
13ec			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ec			 
13ec			;      .org 0 
13ec			;      jp    main 
13ec			 
13ec			 
13ec			;      .org  0x100 
13ec			;main: 
13ec			;      ld    HL, 0x8100 
13ec			;      ld    SP, HL 
13ec			; 
13ec			;      call  heap_init 
13ec			; 
13ec			;      ; Make some allocations 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9004 
13ec			; 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9014 
13ec			; 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9024 
13ec			; 
13ec			;      ; Free some allocations 
13ec			;      ld    HL, 0x9014 
13ec			;      call  free 
13ec			; 
13ec			;      ld    HL, 0x9004 
13ec			;      call  free 
13ec			; 
13ec			;      ld    HL, 0x9024 
13ec			;      call  free 
13ec			; 
13ec			; 
13ec			;      halt 
13ec			 
13ec			 
13ec			;------------------------------------------------------------------------------ 
13ec			;     heap_init                                                               : 
13ec			;                                                                             : 
13ec			; Description                                                                 : 
13ec			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ec			;                                                                             : 
13ec			;     The heap is maintained as a linked list, starting with an initial       : 
13ec			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ec			;     the first free block in the heap. Each block then points to the next    : 
13ec			;     free block within the heap, and the free list ends at the first block   : 
13ec			;     with a null pointer to the next free block.                             : 
13ec			;                                                                             : 
13ec			; Parameters                                                                  : 
13ec			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ec			;     address of the heap and its size are required, along with a memory      : 
13ec			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ec			;     principally stores a pointer to the first free block in the heap.       : 
13ec			;                                                                             : 
13ec			; Returns                                                                     : 
13ec			;     Nothing                                                                 : 
13ec			;------------------------------------------------------------------------------ 
13ec			heap_init: 
13ec e5			      push  HL 
13ed			 
13ed			      ; Initialise free list struct 
13ed 21 0e 80		      ld    HL, heap_start 
13f0 22 0a 80		      ld    (free_list), HL 
13f3 21 00 00		      ld    HL, 0 
13f6 22 0c 80		      ld    (free_list+2), HL 
13f9			 
13f9			      ; Insert first free block at bottom of heap, consumes entire heap 
13f9 21 0a 80		      ld    HL, heap_start+heap_size-4 
13fc 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13ff 21 fc ff		      ld    HL, heap_size-4 
1402 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1405			 
1405			      ; Insert end of free list block at top of heap - two null words will 
1405			      ; terminate the free list 
1405 21 00 00		      ld    HL, 0 
1408 22 0c 80		      ld    (heap_start+heap_size-2), HL 
140b 22 0a 80		      ld    (heap_start+heap_size-4), HL 
140e			 
140e e1			      pop   HL 
140f			 
140f c9			      ret 
1410			 
1410			 
1410			;------------------------------------------------------------------------------ 
1410			;     malloc                                                                  : 
1410			;                                                                             : 
1410			; Description                                                                 : 
1410			;     Allocates the wanted space from the heap and returns the address of the : 
1410			;     first useable byte of the allocation.                                   : 
1410			;                                                                             : 
1410			;     Allocations can happen in one of two ways:                              : 
1410			;                                                                             : 
1410			;     1. A free block may be found which is the exact size wanted. In this    : 
1410			;        case the block is removed from the free list and retuedn to the      : 
1410			;        caller.                                                              : 
1410			;     2. A free block may be found which is larger than the size wanted. In   : 
1410			;        this case, the larger block is split into two. The first portion of  : 
1410			;        this block will become the requested space by the malloc call and    : 
1410			;        is returned to the caller. The second portion becomes a new free     : 
1410			;        block, and the free list is adjusted to maintain continuity via this : 
1410			;        newly created block.                                                 : 
1410			;                                                                             : 
1410			;     malloc does not set any initial value in the allocated space, the       : 
1410			;     caller is required to do this as required.                              : 
1410			;                                                                             : 
1410			;     This implementation of malloc uses the stack exclusively, and is        : 
1410			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1410			;     advisable to disable interrupts before calling malloc, and recommended  : 
1410			;     to avoid the use of malloc inside ISRs in general.                      : 
1410			;                                                                             : 
1410			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1410			;                                                                             : 
1410			; Parameters                                                                  : 
1410			;     HL  Number of bytes wanted                                              : 
1410			;                                                                             : 
1410			; Returns                                                                     : 
1410			;     HL  Address of the first useable byte of the allocation                 : 
1410			;                                                                             : 
1410			; Flags                                                                       : 
1410			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1410			;                                                                             : 
1410			; Stack frame                                                                 : 
1410			;       |             |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     BC      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     DE      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     IX      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |  prev_free  |                                                       : 
1410			;   +4  +-------------+                                                       : 
1410			;       |  this_free  |                                                       : 
1410			;   +2  +-------------+                                                       : 
1410			;       |  next_free  |                                                       : 
1410			;   +0  +-------------+                                                       : 
1410			;       |             |                                                       : 
1410			;                                                                             : 
1410			;------------------------------------------------------------------------------ 
1410			 
1410			 
1410			;malloc: 
1410			; 
1410			;	SAVESP ON 1 
1410			; 
1410			;	call malloc_code 
1410			; 
1410			;	CHECKSP ON 1 
1410			;	ret 
1410			 
1410			 
1410			malloc: 
1410 c5			      push  BC 
1411 d5			      push  DE 
1412 dd e5		      push  IX 
1414			if DEBUG_FORTH_MALLOC_HIGH 
1414			call malloc_guard_entry 
1414			endif 
1414			 
1414					if DEBUG_FORTH_MALLOC 
1414						DMARK "mal" 
1414						CALLMONITOR 
1414					endif 
1414 7c			      ld    A, H                    ; Exit if no space requested 
1415 b5			      or    L 
1416 ca d5 14		      jp    Z, malloc_early_exit 
1419			 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			; 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			 
1419			 
1419			 
1419			 
1419					if DEBUG_FORTH_MALLOC 
1419						DMARK "maA" 
1419						CALLMONITOR 
1419					endif 
1419			      ; Set up stack frame 
1419 eb			      ex    DE, HL 
141a 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
141d 39			      add   HL, SP 
141e f9			      ld    SP, HL 
141f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1423 dd 39		      add   IX, SP 
1425			 
1425			      ; Setup initial state 
1425 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1428 19			      add   HL, DE 
1429			 
1429 44			      ld    B, H                    ; Move want to BC 
142a 4d			      ld    C, L 
142b			 
142b 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
142e dd 75 04		      ld    (IX+4), L 
1431 dd 74 05		      ld    (IX+5), H 
1434			 
1434 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1435 23			      inc   HL 
1436 56			      ld    D, (HL) 
1437 dd 73 02		      ld    (IX+2), E 
143a dd 72 03		      ld    (IX+3), D 
143d eb			      ex    DE, HL                  ; this_free ptr into HL 
143e			 
143e					if DEBUG_FORTH_MALLOC 
143e						DMARK "maB" 
143e						CALLMONITOR 
143e					endif 
143e			      ; Loop through free block list to find some space 
143e			malloc_find_space: 
143e 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
143f 23			      inc   HL 
1440 56			      ld    D, (HL) 
1441			 
1441 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1442 b3			      or    E 
1443 ca cf 14		      jp    Z, malloc_no_space 
1446			 
1446 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1449 dd 72 01		      ld    (IX+1), D 
144c			 
144c			      ; Does this block have enough space to make the allocation? 
144c 23			      inc   HL                      ; Load free block size into DE 
144d 5e			      ld    E, (HL) 
144e 23			      inc   HL 
144f 56			      ld    D, (HL) 
1450			 
1450 eb			      ex    DE, HL                  ; Check size of block against want 
1451 b7			      or    A                       ; Ensure carry flag clear 
1452 ed 42		      sbc   HL, BC 
1454 e5			      push  HL                      ; Store the result for later (new block size) 
1455			 
1455 ca a4 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1458 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
145a			 
145a			      ; this_free block is not big enough, setup ptrs to test next free block 
145a e1			      pop   HL                      ; Discard previous result 
145b			 
145b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
145e dd 66 03		      ld    H, (IX+3) 
1461 dd 75 04		      ld    (IX+4), L 
1464 dd 74 05		      ld    (IX+5), H 
1467			 
1467 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
146a dd 66 01		      ld    H, (IX+1) 
146d dd 75 02		      ld    (IX+2), L 
1470 dd 74 03		      ld    (IX+3), H 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "MA>" 
1473						CALLMONITOR 
1473					endif 
1473 18 c9		      jr    malloc_find_space 
1475			 
1475			      ; split a bigger block into two - requested size and remaining size 
1475			malloc_alloc_split: 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "MAs" 
1475						CALLMONITOR 
1475					endif 
1475 eb			      ex    DE, HL                  ; Calculate address of new free block 
1476 2b			      dec   HL 
1477 2b			      dec   HL 
1478 2b			      dec   HL 
1479 09			      add   HL, BC 
147a			 
147a			      ; Create a new block and point it at next_free 
147a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
147d dd 56 01		      ld    D, (IX+1) 
1480			 
1480 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1481 23			      inc   HL 
1482 72			      ld    (HL), D 
1483			 
1483 d1			      pop   DE                      ; Store size of new block into new block 
1484 23			      inc   HL 
1485 73			      ld    (HL), E 
1486 23			      inc   HL 
1487 72			      ld    (HL), D 
1488			 
1488			      ; Update this_free ptr to point to new block 
1488 2b			      dec   HL 
1489 2b			      dec   HL 
148a 2b			      dec   HL 
148b			 
148b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
148e dd 56 03		      ld    D, (IX+3) 
1491			 
1491 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1494 dd 74 03		      ld    (IX+3), H 
1497			 
1497			      ; Modify this_free block to be allocation 
1497 eb			      ex    DE, HL 
1498 af			      xor   A                       ; Null the next block ptr of allocated block 
1499 77			      ld    (HL), A 
149a 23			      inc   HL 
149b 77			      ld    (HL), A 
149c			 
149c 23			      inc   HL                      ; Store want size into allocated block 
149d 71			      ld    (HL), C 
149e 23			      inc   HL 
149f 70			      ld    (HL), B 
14a0 23			      inc   HL 
14a1 e5			      push  HL                      ; Address of allocation to return 
14a2			 
14a2 18 19		      jr    malloc_update_links 
14a4			 
14a4			malloc_alloc_fit: 
14a4 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14a5			 
14a5					if DEBUG_FORTH_MALLOC 
14a5						DMARK "MAf" 
14a5						CALLMONITOR 
14a5					endif 
14a5			      ; Modify this_free block to be allocation 
14a5 eb			      ex    DE, HL 
14a6 2b			      dec   HL 
14a7 2b			      dec   HL 
14a8 2b			      dec   HL 
14a9			 
14a9 af			      xor   A                       ; Null the next block ptr of allocated block 
14aa 77			      ld    (HL), A 
14ab 23			      inc   HL 
14ac 77			      ld    (HL), A 
14ad			 
14ad 23			      inc   HL                      ; Store address of allocation to return 
14ae 23			      inc   HL 
14af 23			      inc   HL 
14b0 e5			      push  HL 
14b1			 
14b1			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b1 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14b4 dd 66 01		      ld    H, (IX+1) 
14b7			 
14b7 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14ba dd 74 03		      ld    (IX+3), H 
14bd			 
14bd			 
14bd			malloc_update_links: 
14bd			      ; Update prev_free ptr to point to this_free 
14bd dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c0 dd 66 05		      ld    H, (IX+5) 
14c3			 
14c3 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14c6 dd 56 03		      ld    D, (IX+3) 
14c9			 
14c9 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14ca 23			      inc   HL 
14cb 72			      ld    (HL), D 
14cc			 
14cc					if DEBUG_FORTH_MALLOC 
14cc						DMARK "Mul" 
14cc						CALLMONITOR 
14cc					endif 
14cc			      ; Clear the Z flag to indicate successful allocation 
14cc 7a			      ld    A, D 
14cd b3			      or    E 
14ce			 
14ce d1			      pop   DE                      ; Address of allocation 
14cf					if DEBUG_FORTH_MALLOC 
14cf						DMARK "MAu" 
14cf						CALLMONITOR 
14cf					endif 
14cf			 
14cf			malloc_no_space: 
14cf 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14d2 39			      add   HL, SP 
14d3 f9			      ld    SP, HL 
14d4			 
14d4 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14d5					if DEBUG_FORTH_MALLOC 
14d5						DMARK "MAN" 
14d5						CALLMONITOR 
14d5					endif 
14d5			 
14d5			malloc_early_exit: 
14d5					if DEBUG_FORTH_MALLOC 
14d5						DMARK "MAx" 
14d5						CALLMONITOR 
14d5					endif 
14d5 dd e1		      pop   IX 
14d7 d1			      pop   DE 
14d8 c1			      pop   BC 
14d9			 
14d9			if DEBUG_FORTH_MALLOC_HIGH 
14d9			call malloc_guard_exit 
14d9			call malloc_guard_zerolen 
14d9			endif 
14d9 c9			      ret 
14da			 
14da			 
14da			;------------------------------------------------------------------------------ 
14da			;     free                                                                    : 
14da			;                                                                             : 
14da			; Description                                                                 : 
14da			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14da			;     returned by malloc, otherwise the behaviour is undefined.               : 
14da			;                                                                             : 
14da			;     Where possible, directly adjacent free blocks will be merged together   : 
14da			;     into larger blocks to help ensure that the heap does not become         : 
14da			;     excessively fragmented.                                                 : 
14da			;                                                                             : 
14da			;     free does not clear or set any other value into the freed space, and    : 
14da			;     therefore its contents may be visible through subsequent malloc's. The  : 
14da			;     caller should clear the freed space as required.                        : 
14da			;                                                                             : 
14da			;     This implementation of free uses the stack exclusively, and is          : 
14da			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14da			;     advisable to disable interrupts before calling free, and recommended    : 
14da			;     to avoid the use of free inside ISRs in general.                        : 
14da			;                                                                             : 
14da			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14da			;                                                                             : 
14da			; Parameters                                                                  : 
14da			;     HL  Pointer to address of first byte of allocation to be freed          : 
14da			;                                                                             : 
14da			; Returns                                                                     : 
14da			;     Nothing                                                                 : 
14da			;                                                                             : 
14da			; Stack frame                                                                 : 
14da			;       |             |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     BC      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     DE      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     IX      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |  prev_free  |                                                       : 
14da			;   +2  +-------------+                                                       : 
14da			;       |  next_free  |                                                       : 
14da			;   +0  +-------------+                                                       : 
14da			;       |             |                                                       : 
14da			;                                                                             : 
14da			;------------------------------------------------------------------------------ 
14da			free: 
14da c5			      push  BC 
14db d5			      push  DE 
14dc dd e5		      push  IX 
14de			 
14de 7c			      ld    A, H                    ; Exit if ptr is null 
14df b5			      or    L 
14e0 ca a4 15		      jp    Z, free_early_exit 
14e3			 
14e3			      ; Set up stack frame 
14e3 eb			      ex    DE, HL 
14e4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14e7 39			      add   HL, SP 
14e8 f9			      ld    SP, HL 
14e9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14ed dd 39		      add   IX, SP 
14ef			 
14ef			      ; The address in HL points to the start of the useable allocated space, 
14ef			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14ef			      ; address of the block itself. 
14ef eb			      ex    DE, HL 
14f0 11 fc ff		      ld    DE, -4 
14f3 19			      add   HL, DE 
14f4			 
14f4			      ; An allocated block must have a null next block pointer in it 
14f4 7e			      ld    A, (HL) 
14f5 23			      inc   HL 
14f6 b6			      or    (HL) 
14f7 c2 9f 15		      jp    NZ, free_done 
14fa			 
14fa 2b			      dec   HL 
14fb			 
14fb 44			      ld    B, H                    ; Copy HL to BC 
14fc 4d			      ld    C, L 
14fd			 
14fd			      ; Loop through the free list to find the first block with an address 
14fd			      ; higher than the block being freed 
14fd 21 0a 80		      ld    HL, free_list 
1500			 
1500			free_find_higher_block: 
1500 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1501 23			      inc   HL 
1502 56			      ld    D, (HL) 
1503 2b			      dec   HL 
1504			 
1504 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1507 dd 72 01		      ld    (IX+1), D 
150a dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
150d dd 74 03		      ld    (IX+3), H 
1510			 
1510 78			      ld    A, B                    ; Check if DE is greater than BC 
1511 ba			      cp    D                       ; Compare MSB first 
1512 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1514 30 04		      jr    NC, free_find_higher_block_skip 
1516 79			      ld    A, C 
1517 bb			      cp    E                       ; Then compare LSB 
1518 38 08		      jr    C, free_found_higher_block 
151a			 
151a			free_find_higher_block_skip: 
151a 7a			      ld    A, D                    ; Reached the end of the free list? 
151b b3			      or    E 
151c ca 9f 15		      jp    Z, free_done 
151f			 
151f eb			      ex    DE, HL 
1520			 
1520 18 de		      jr    free_find_higher_block 
1522			 
1522			free_found_higher_block: 
1522			      ; Insert freed block between prev and next free blocks 
1522 71			      ld    (HL), C                 ; Point prev free block to freed block 
1523 23			      inc   HL 
1524 70			      ld    (HL), B 
1525			 
1525 60			      ld    H, B                    ; Point freed block at next free block 
1526 69			      ld    L, C 
1527 73			      ld    (HL), E 
1528 23			      inc   HL 
1529 72			      ld    (HL), D 
152a			 
152a			      ; Check if the freed block is adjacent to the next free block 
152a 23			      inc   HL                      ; Load size of freed block into HL 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e eb			      ex    DE, HL 
152f			 
152f 09			      add   HL, BC                  ; Add addr of freed block and its size 
1530			 
1530 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1533 dd 56 01		      ld    D, (IX+1) 
1536			 
1536 b7			      or    A                       ; Clear the carry flag 
1537 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1539 20 22		      jr    NZ, free_check_adjacent_to_prev 
153b			 
153b			      ; Freed block is adjacent to next, merge into one bigger block 
153b eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
153c 5e			      ld    E, (HL) 
153d 23			      inc   HL 
153e 56			      ld    D, (HL) 
153f e5			      push  HL                      ; Save ptr to next block for later 
1540			 
1540 60			      ld    H, B                    ; Store ptr from next block into freed block 
1541 69			      ld    L, C 
1542 73			      ld    (HL), E 
1543 23			      inc   HL 
1544 72			      ld    (HL), D 
1545			 
1545 e1			      pop   HL                      ; Restore ptr to next block 
1546 23			      inc   HL                      ; Load size of next block into DE 
1547 5e			      ld    E, (HL) 
1548 23			      inc   HL 
1549 56			      ld    D, (HL) 
154a d5			      push  DE                      ; Save next block size for later 
154b			 
154b 60			      ld    H, B                    ; Load size of freed block into HL 
154c 69			      ld    L, C 
154d 23			      inc   HL 
154e 23			      inc   HL 
154f 5e			      ld    E, (HL) 
1550 23			      inc   HL 
1551 56			      ld    D, (HL) 
1552 eb			      ex    DE, HL 
1553			 
1553 d1			      pop   DE                      ; Restore size of next block 
1554 19			      add   HL, DE                  ; Add sizes of both blocks 
1555 eb			      ex    DE, HL 
1556			 
1556 60			      ld    H, B                    ; Store new bigger size into freed block 
1557 69			      ld    L, C 
1558 23			      inc   HL 
1559 23			      inc   HL 
155a 73			      ld    (HL), E 
155b 23			      inc   HL 
155c 72			      ld    (HL), D 
155d			 
155d			free_check_adjacent_to_prev: 
155d			      ; Check if the freed block is adjacent to the prev free block 
155d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1560 dd 66 03		      ld    H, (IX+3) 
1563			 
1563 23			      inc   HL                      ; Size of prev free block into DE 
1564 23			      inc   HL 
1565 5e			      ld    E, (HL) 
1566 23			      inc   HL 
1567 56			      ld    D, (HL) 
1568 2b			      dec   HL 
1569 2b			      dec   HL 
156a 2b			      dec   HL 
156b			 
156b 19			      add   HL, DE                  ; Add prev block addr and size 
156c			 
156c b7			      or    A                       ; Clear the carry flag 
156d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
156f 20 2e		      jr    NZ, free_done 
1571			 
1571			      ; Freed block is adjacent to prev, merge into one bigger block 
1571 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1572 69			      ld    L, C 
1573 5e			      ld    E, (HL) 
1574 23			      inc   HL 
1575 56			      ld    D, (HL) 
1576 e5			      push  HL                      ; Save freed block ptr for later 
1577			 
1577 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
157a dd 66 03		      ld    H, (IX+3) 
157d 73			      ld    (HL), E 
157e 23			      inc   HL 
157f 72			      ld    (HL), D 
1580			 
1580 e1			      pop   HL                      ; Restore freed block ptr 
1581 23			      inc   HL                      ; Load size of freed block into DE 
1582 5e			      ld    E, (HL) 
1583 23			      inc   HL 
1584 56			      ld    D, (HL) 
1585 d5			      push  DE                      ; Save freed block size for later 
1586			 
1586 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1589 dd 66 03		      ld    H, (IX+3) 
158c 23			      inc   HL 
158d 23			      inc   HL 
158e 5e			      ld    E, (HL) 
158f 23			      inc   HL 
1590 56			      ld    D, (HL) 
1591			 
1591 e1			      pop   HL                      ; Add sizes of both blocks 
1592 19			      add   HL, DE 
1593 eb			      ex    DE, HL 
1594			 
1594 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1597 dd 66 03		      ld    H, (IX+3) 
159a 23			      inc   HL 
159b 23			      inc   HL 
159c 73			      ld    (HL), E 
159d 23			      inc   HL 
159e 72			      ld    (HL), D 
159f			 
159f			free_done: 
159f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15a2 39			      add   HL, SP 
15a3 f9			      ld    SP, HL 
15a4			 
15a4			free_early_exit: 
15a4 dd e1		      pop   IX 
15a6 d1			      pop   DE 
15a7 c1			      pop   BC 
15a8			 
15a8 c9			      ret 
15a9			 
15a9			; moved to firmware.asm 
15a9			; 
15a9			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15a9			;                  .dw   0 
15a9			 
15a9			 
15a9			endif 
15a9			 
15a9			 
15a9			if MALLOC_3 
15a9			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15a9			;heap_start        .equ  0x9000      ; Starting address of heap 
15a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15a9			; 
15a9			 ;     .org 0 
15a9			  ;    jp    main 
15a9			; 
15a9			; 
15a9			 ;     .org  0x100 
15a9			;main: 
15a9			 ;     ld    HL, 0x8100 
15a9			  ;    ld    SP, HL 
15a9			; 
15a9			;      call  heap_init 
15a9			 
15a9			      ; Make some allocations 
15a9			;      ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9004 
15a9			; 
15a9			 ;     ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9014 
15a9			 
15a9			;      ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9024 
15a9			 
15a9			      ; Free some allocations 
15a9			;      ld    HL, 0x9014 
15a9			;      call  free 
15a9			 
15a9			;      ld    HL, 0x9004 
15a9			;      call  free 
15a9			; 
15a9			;      ld    HL, 0x9024 
15a9			;      call  free 
15a9			 
15a9			 
15a9			 ;     halt 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     heap_init                                                               : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
15a9			;                                                                             : 
15a9			;     The heap is maintained as a linked list, starting with an initial       : 
15a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15a9			;     the first free block in the heap. Each block then points to the next    : 
15a9			;     free block within the heap, and the free list ends at the first block   : 
15a9			;     with a null pointer to the next free block.                             : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
15a9			;     address of the heap and its size are required, along with a memory      : 
15a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15a9			;     principally stores a pointer to the first free block in the heap.       : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     Nothing                                                                 : 
15a9			;------------------------------------------------------------------------------ 
15a9			heap_init: 
15a9			      push  HL 
15a9			 
15a9			      ; Initialise free list struct 
15a9			      ld    HL, heap_start 
15a9			      ld    (free_list), HL 
15a9			      ld    HL, 0 
15a9			      ld    (free_list+2), HL 
15a9			 
15a9			      ; Insert first free block at bottom of heap, consumes entire heap 
15a9			      ld    HL, heap_start+heap_size-4 
15a9			      ld    (heap_start), HL        ; Next block (end of free list) 
15a9			      ld    HL, heap_size-4 
15a9			      ld    (heap_start+2), HL      ; Block size 
15a9			 
15a9			      ; Insert end of free list block at top of heap - two null words will 
15a9			      ; terminate the free list 
15a9			      ld    HL, 0 
15a9			      ld    (heap_start+heap_size-2), HL 
15a9			      ld    (heap_start+heap_size-4), HL 
15a9			 
15a9			      pop   HL 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     malloc                                                                  : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Allocates the wanted space from the heap and returns the address of the : 
15a9			;     first useable byte of the allocation.                                   : 
15a9			;                                                                             : 
15a9			;     Allocations can happen in one of two ways:                              : 
15a9			;                                                                             : 
15a9			;     1. A free block may be found which is the exact size wanted. In this    : 
15a9			;        case the block is removed from the free list and retuedn to the      : 
15a9			;        caller.                                                              : 
15a9			;     2. A free block may be found which is larger than the size wanted. In   : 
15a9			;        this case, the larger block is split into two. The first portion of  : 
15a9			;        this block will become the requested space by the malloc call and    : 
15a9			;        is returned to the caller. The second portion becomes a new free     : 
15a9			;        block, and the free list is adjusted to maintain continuity via this : 
15a9			;        newly created block.                                                 : 
15a9			;                                                                             : 
15a9			;     malloc does not set any initial value in the allocated space, the       : 
15a9			;     caller is required to do this as required.                              : 
15a9			;                                                                             : 
15a9			;     This implementation of malloc uses the stack exclusively, and is        : 
15a9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15a9			;     advisable to disable interrupts before calling malloc, and recommended  : 
15a9			;     to avoid the use of malloc inside ISRs in general.                      : 
15a9			;                                                                             : 
15a9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     HL  Number of bytes wanted                                              : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     HL  Address of the first useable byte of the allocation                 : 
15a9			;                                                                             : 
15a9			; Flags                                                                       : 
15a9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15a9			;                                                                             : 
15a9			; Stack frame                                                                 : 
15a9			;       |             |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     BC      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     DE      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     IX      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |  prev_free  |                                                       : 
15a9			;   +4  +-------------+                                                       : 
15a9			;       |  this_free  |                                                       : 
15a9			;   +2  +-------------+                                                       : 
15a9			;       |  next_free  |                                                       : 
15a9			;   +0  +-------------+                                                       : 
15a9			;       |             |                                                       : 
15a9			;                                                                             : 
15a9			;------------------------------------------------------------------------------ 
15a9			malloc: 
15a9			      push  BC 
15a9			      push  DE 
15a9			      push  IX 
15a9			 
15a9			      ld    A, H                    ; Exit if no space requested 
15a9			      or    L 
15a9			      jp    Z, malloc_early_exit 
15a9			 
15a9			      ; Set up stack frame 
15a9			      ex    DE, HL 
15a9			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			      ld    IX, 0                   ; Use IX as a frame pointer 
15a9			      add   IX, SP 
15a9			 
15a9			      ; Setup initial state 
15a9			      ld    HL, 4                   ; want must also include space used by block struct 
15a9			      add   HL, DE 
15a9			 
15a9			      ld    B, H                    ; Move want to BC 
15a9			      ld    C, L 
15a9			 
15a9			      ld    HL, free_list           ; Store prev_free ptr to stack 
15a9			      ld    (IX+4), L 
15a9			      ld    (IX+5), H 
15a9			 
15a9			      ld    E, (HL)                 ; Store this_free ptr to stack 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ld    (IX+2), E 
15a9			      ld    (IX+3), D 
15a9			      ex    DE, HL                  ; this_free ptr into HL 
15a9			 
15a9			      ; Loop through free block list to find some space 
15a9			malloc_find_space: 
15a9			      ld    E, (HL)                 ; Load next_free ptr into DE 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15a9			      or    E 
15a9			      jp    Z, malloc_no_space 
15a9			 
15a9			      ld    (IX+0), E               ; Store next_free ptr to stack 
15a9			      ld    (IX+1), D 
15a9			 
15a9			      ; Does this block have enough space to make the allocation? 
15a9			      inc   HL                      ; Load free block size into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      ex    DE, HL                  ; Check size of block against want 
15a9			      or    A                       ; Ensure carry flag clear 
15a9			      sbc   HL, BC 
15a9			      push  HL                      ; Store the result for later (new block size) 
15a9			 
15a9			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15a9			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15a9			 
15a9			      ; this_free block is not big enough, setup ptrs to test next free block 
15a9			      pop   HL                      ; Discard previous result 
15a9			 
15a9			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15a9			      ld    H, (IX+3) 
15a9			      ld    (IX+4), L 
15a9			      ld    (IX+5), H 
15a9			 
15a9			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15a9			      ld    H, (IX+1) 
15a9			      ld    (IX+2), L 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      jr    malloc_find_space 
15a9			 
15a9			      ; split a bigger block into two - requested size and remaining size 
15a9			malloc_alloc_split: 
15a9			      ex    DE, HL                  ; Calculate address of new free block 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      add   HL, BC 
15a9			 
15a9			      ; Create a new block and point it at next_free 
15a9			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15a9			      ld    D, (IX+1) 
15a9			 
15a9			      ld    (HL), E                 ; Store next_free ptr into new block 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   DE                      ; Store size of new block into new block 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Update this_free ptr to point to new block 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15a9			      ld    D, (IX+3) 
15a9			 
15a9			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      ; Modify this_free block to be allocation 
15a9			      ex    DE, HL 
15a9			      xor   A                       ; Null the next block ptr of allocated block 
15a9			      ld    (HL), A 
15a9			      inc   HL 
15a9			      ld    (HL), A 
15a9			 
15a9			      inc   HL                      ; Store want size into allocated block 
15a9			      ld    (HL), C 
15a9			      inc   HL 
15a9			      ld    (HL), B 
15a9			      inc   HL 
15a9			      push  HL                      ; Address of allocation to return 
15a9			 
15a9			      jr    malloc_update_links 
15a9			 
15a9			malloc_alloc_fit: 
15a9			      pop   HL                      ; Dont need new block size, want is exact fit 
15a9			 
15a9			      ; Modify this_free block to be allocation 
15a9			      ex    DE, HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      xor   A                       ; Null the next block ptr of allocated block 
15a9			      ld    (HL), A 
15a9			      inc   HL 
15a9			      ld    (HL), A 
15a9			 
15a9			      inc   HL                      ; Store address of allocation to return 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      push  HL 
15a9			 
15a9			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15a9			      ld    L, (IX+0)               ; next_free to HL 
15a9			      ld    H, (IX+1) 
15a9			 
15a9			      ld    (IX+2), L               ; HL to this_free 
15a9			      ld    (IX+3), H 
15a9			 
15a9			 
15a9			malloc_update_links: 
15a9			      ; Update prev_free ptr to point to this_free 
15a9			      ld    L, (IX+4)               ; prev_free ptr to HL 
15a9			      ld    H, (IX+5) 
15a9			 
15a9			      ld    E, (IX+2)               ; this_free ptr to DE 
15a9			      ld    D, (IX+3) 
15a9			 
15a9			      ld    (HL), E                 ; this_free ptr into prev_free 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Clear the Z flag to indicate successful allocation 
15a9			      ld    A, D 
15a9			      or    E 
15a9			 
15a9			      pop   DE                      ; Address of allocation 
15a9			 
15a9			malloc_no_space: 
15a9			      ld    HL, 6                   ; Clean up stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			 
15a9			      ex    DE, HL                  ; Alloc addr into HL for return 
15a9			 
15a9			malloc_early_exit: 
15a9			      pop   IX 
15a9			      pop   DE 
15a9			      pop   BC 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     free                                                                    : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15a9			;     returned by malloc, otherwise the behaviour is undefined.               : 
15a9			;                                                                             : 
15a9			;     Where possible, directly adjacent free blocks will be merged together   : 
15a9			;     into larger blocks to help ensure that the heap does not become         : 
15a9			;     excessively fragmented.                                                 : 
15a9			;                                                                             : 
15a9			;     free does not clear or set any other value into the freed space, and    : 
15a9			;     therefore its contents may be visible through subsequent malloc's. The  : 
15a9			;     caller should clear the freed space as required.                        : 
15a9			;                                                                             : 
15a9			;     This implementation of free uses the stack exclusively, and is          : 
15a9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15a9			;     advisable to disable interrupts before calling free, and recommended    : 
15a9			;     to avoid the use of free inside ISRs in general.                        : 
15a9			;                                                                             : 
15a9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     HL  Pointer to address of first byte of allocation to be freed          : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     Nothing                                                                 : 
15a9			;                                                                             : 
15a9			; Stack frame                                                                 : 
15a9			;       |             |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     BC      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     DE      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     IX      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |  prev_free  |                                                       : 
15a9			;   +2  +-------------+                                                       : 
15a9			;       |  next_free  |                                                       : 
15a9			;   +0  +-------------+                                                       : 
15a9			;       |             |                                                       : 
15a9			;                                                                             : 
15a9			;------------------------------------------------------------------------------ 
15a9			free: 
15a9			      push  BC 
15a9			      push  DE 
15a9			      push  IX 
15a9			 
15a9			      ld    A, H                    ; Exit if ptr is null 
15a9			      or    L 
15a9			      jp    Z, free_early_exit 
15a9			 
15a9			      ; Set up stack frame 
15a9			      ex    DE, HL 
15a9			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			      ld    IX, 0                   ; Use IX as a frame pointer 
15a9			      add   IX, SP 
15a9			 
15a9			      ; The address in HL points to the start of the useable allocated space, 
15a9			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15a9			      ; address of the block itself. 
15a9			      ex    DE, HL 
15a9			      ld    DE, -4 
15a9			      add   HL, DE 
15a9			 
15a9			      ; An allocated block must have a null next block pointer in it 
15a9			      ld    A, (HL) 
15a9			      inc   HL 
15a9			      or    (HL) 
15a9			      jp    NZ, free_done 
15a9			 
15a9			      dec   HL 
15a9			 
15a9			      ld    B, H                    ; Copy HL to BC 
15a9			      ld    C, L 
15a9			 
15a9			      ; Loop through the free list to find the first block with an address 
15a9			      ; higher than the block being freed 
15a9			      ld    HL, free_list 
15a9			 
15a9			free_find_higher_block: 
15a9			      ld    E, (HL)                 ; Load next ptr from free block 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      dec   HL 
15a9			 
15a9			      ld    (IX+0), E               ; Save ptr to next free block 
15a9			      ld    (IX+1), D 
15a9			      ld    (IX+2), L               ; Save ptr to prev free block 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      ld    A, B                    ; Check if DE is greater than BC 
15a9			      cp    D                       ; Compare MSB first 
15a9			      jr    Z, $+4                  ; MSB the same, compare LSB 
15a9			      jr    NC, free_find_higher_block_skip 
15a9			      ld    A, C 
15a9			      cp    E                       ; Then compare LSB 
15a9			      jr    C, free_found_higher_block 
15a9			 
15a9			free_find_higher_block_skip: 
15a9			      ld    A, D                    ; Reached the end of the free list? 
15a9			      or    E 
15a9			      jp    Z, free_done 
15a9			 
15a9			      ex    DE, HL 
15a9			 
15a9			      jr    free_find_higher_block 
15a9			 
15a9			free_found_higher_block: 
15a9			      ; Insert freed block between prev and next free blocks 
15a9			      ld    (HL), C                 ; Point prev free block to freed block 
15a9			      inc   HL 
15a9			      ld    (HL), B 
15a9			 
15a9			      ld    H, B                    ; Point freed block at next free block 
15a9			      ld    L, C 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Check if the freed block is adjacent to the next free block 
15a9			      inc   HL                      ; Load size of freed block into HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ex    DE, HL 
15a9			 
15a9			      add   HL, BC                  ; Add addr of freed block and its size 
15a9			 
15a9			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15a9			      ld    D, (IX+1) 
15a9			 
15a9			      or    A                       ; Clear the carry flag 
15a9			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15a9			      jr    NZ, free_check_adjacent_to_prev 
15a9			 
15a9			      ; Freed block is adjacent to next, merge into one bigger block 
15a9			      ex    DE, HL                  ; Load next ptr from next block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  HL                      ; Save ptr to next block for later 
15a9			 
15a9			      ld    H, B                    ; Store ptr from next block into freed block 
15a9			      ld    L, C 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   HL                      ; Restore ptr to next block 
15a9			      inc   HL                      ; Load size of next block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  DE                      ; Save next block size for later 
15a9			 
15a9			      ld    H, B                    ; Load size of freed block into HL 
15a9			      ld    L, C 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ex    DE, HL 
15a9			 
15a9			      pop   DE                      ; Restore size of next block 
15a9			      add   HL, DE                  ; Add sizes of both blocks 
15a9			      ex    DE, HL 
15a9			 
15a9			      ld    H, B                    ; Store new bigger size into freed block 
15a9			      ld    L, C 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			free_check_adjacent_to_prev: 
15a9			      ; Check if the freed block is adjacent to the prev free block 
15a9			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15a9			      ld    H, (IX+3) 
15a9			 
15a9			      inc   HL                      ; Size of prev free block into DE 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      add   HL, DE                  ; Add prev block addr and size 
15a9			 
15a9			      or    A                       ; Clear the carry flag 
15a9			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15a9			      jr    NZ, free_done 
15a9			 
15a9			      ; Freed block is adjacent to prev, merge into one bigger block 
15a9			      ld    H, B                    ; Load next ptr from freed block into DE 
15a9			      ld    L, C 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  HL                      ; Save freed block ptr for later 
15a9			 
15a9			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15a9			      ld    H, (IX+3) 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   HL                      ; Restore freed block ptr 
15a9			      inc   HL                      ; Load size of freed block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  DE                      ; Save freed block size for later 
15a9			 
15a9			      ld    L, (IX+2)               ; Load size of prev block into DE 
15a9			      ld    H, (IX+3) 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      pop   HL                      ; Add sizes of both blocks 
15a9			      add   HL, DE 
15a9			      ex    DE, HL 
15a9			 
15a9			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15a9			      ld    H, (IX+3) 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			free_done: 
15a9			      ld    HL, 4                   ; Clean up stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			 
15a9			free_early_exit: 
15a9			      pop   IX 
15a9			      pop   DE 
15a9			      pop   BC 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;      .org 0x8000 
15a9			; 
15a9			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15a9			 ;                 .dw   0 
15a9			 
15a9			endif 
15a9			 
15a9			 
15a9			if MALLOC_4 
15a9			 
15a9			; My memory allocation code. Very very simple.... 
15a9			; allocate space under 250 chars 
15a9			 
15a9			heap_init: 
15a9				; init start of heap as zero 
15a9				;  
15a9			 
15a9				ld hl, heap_start 
15a9				ld a, 0 
15a9				ld (hl), a      ; empty block 
15a9				inc hl 
15a9				ld a, 0 
15a9				ld (hl), a      ; length of block 
15a9				; write end of list 
15a9				inc hl 
15a9				ld a,(hl) 
15a9				inc hl 
15a9				ld a,(hl) 
15a9				 
15a9			 
15a9				; init some malloc vars 
15a9			 
15a9				ld hl, 0 
15a9				ld (free_list), hl       ; store last malloc location 
15a9			 
15a9				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15a9				ld a, 0 
15a9				ld (hl), a 
15a9			 
15a9			 
15a9				ld hl, heap_start 
15a9				;  
15a9				  
15a9				ret 
15a9			 
15a9			 
15a9			;    free block marker 
15a9			;    requested size  
15a9			;    pointer to next block 
15a9			;    .... 
15a9			;    next block marker 
15a9			 
15a9			 
15a9			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15a9			; 
15a9			 
15a9			 
15a9			malloc:  
15a9				push de 
15a9				push bc 
15a9				push af 
15a9			 
15a9				; hl space required 
15a9				 
15a9				ld c, l    ; hold space   (TODO only a max of 255) 
15a9			 
15a9			;	inc c     ; TODO BUG need to fix memory leak on push str 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			 
15a9			 
15a9			 
15a9				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15a9			 
15a9				ld a, (free_list+3) 
15a9				cp 0 
15a9				jr z, .contheap 
15a9			 
15a9				ld hl, (free_list)     ; get last alloc 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mrs" 
15a9						CALLMONITOR 
15a9					endif 
15a9				jr .startalloc 
15a9			 
15a9			.contheap: 
15a9				ld hl, heap_start 
15a9			 
15a9			.startalloc: 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mym" 
15a9						CALLMONITOR 
15a9					endif 
15a9			.findblock: 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mmf" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9				ld a,(hl)  
15a9				; if byte is zero then clear to use 
15a9			 
15a9				cp 0 
15a9				jr z, .foundemptyblock 
15a9			 
15a9				; if byte is not clear 
15a9				;     then byte is offset to next block 
15a9			 
15a9				inc hl 
15a9				ld a, (hl) ; get size 
15a9			.nextblock:	inc hl 
15a9					ld e, (hl) 
15a9					inc hl 
15a9					ld d, (hl) 
15a9					ex de, hl 
15a9			;	inc hl  ; move past the store space 
15a9			;	inc hl  ; move past zero index  
15a9			 
15a9				; TODO detect no more space 
15a9			 
15a9				push hl 
15a9				ld de, heap_end 
15a9				call cmp16 
15a9				pop hl 
15a9				jr nc, .nospace 
15a9			 
15a9				jr .findblock 
15a9			 
15a9			.nospace: ld hl, 0 
15a9				jp .exit 
15a9			 
15a9			 
15a9			.foundemptyblock:	 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mme" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			; TODO has block enough space if reusing??? 
15a9			 
15a9				;  
15a9			 
15a9			; see if this block has been previously used 
15a9				inc hl 
15a9				ld a, (hl) 
15a9				dec hl 
15a9				cp 0 
15a9				jr z, .newblock 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "meR" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			; no reusing previously allocated block 
15a9			 
15a9			; is it smaller than previously used? 
15a9				 
15a9				inc hl    ; move to size 
15a9				ld a, c 
15a9				sub (hl)        ; we want c < (hl) 
15a9				dec hl    ; move back to marker 
15a9			        jr z, .findblock 
15a9			 
15a9				; update with the new size which should be lower 
15a9			 
15a9			        ;inc  hl   ; negate next move. move back to size  
15a9			 
15a9			.newblock: 
15a9				; need to be at marker here 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "meN" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			 
15a9				ld a, c 
15a9			 
15a9				ld (free_list+3), a	 ; flag resume from last malloc  
15a9				ld (free_list), hl    ; save out last location 
15a9			 
15a9			 
15a9				;inc a     ; space for length byte 
15a9				ld (hl), a     ; save block in use marker 
15a9			 
15a9				inc hl   ; move to space marker 
15a9				ld (hl), a    ; save new space 
15a9			 
15a9				inc hl   ; move to start of allocated area 
15a9				 
15a9			;	push hl     ; save where we are - 1  
15a9			 
15a9			;	inc hl  ; move past zero index  
15a9				; skip space to set down new marker 
15a9			 
15a9				; provide some extra space for now 
15a9			 
15a9				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15a9				inc a 
15a9				inc a 
15a9			 
15a9				push hl   ; save where we are in the node block 
15a9			 
15a9				call addatohl 
15a9			 
15a9				; write linked list point 
15a9			 
15a9				pop de     ; get our node position 
15a9				ex de, hl 
15a9			 
15a9				ld (hl), e 
15a9				inc hl 
15a9				ld (hl), d 
15a9			 
15a9				inc hl 
15a9			 
15a9				; now at start of allocated data so save pointer 
15a9			 
15a9				push hl 
15a9			 
15a9				; jump to position of next node and setup empty header in DE 
15a9			 
15a9				ex de, hl 
15a9			 
15a9			;	inc hl ; move past end of block 
15a9			 
15a9				ld a, 0 
15a9				ld (hl), a   ; empty marker 
15a9				inc hl 
15a9				ld (hl), a   ; size 
15a9				inc hl  
15a9				ld (hl), a   ; ptr 
15a9				inc hl 
15a9				ld (hl), a   ; ptr 
15a9			 
15a9			 
15a9				pop hl 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mmr" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			.exit: 
15a9				pop af 
15a9				pop bc 
15a9				pop de  
15a9				ret 
15a9			 
15a9			 
15a9			 
15a9			 
15a9			free:  
15a9				push hl 
15a9				push af 
15a9				; get address in hl 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "fre" 
15a9						CALLMONITOR 
15a9					endif 
15a9				; data is at hl - move to block count 
15a9				dec hl 
15a9				dec hl    ; get past pointer 
15a9				dec hl 
15a9			 
15a9				ld a, (hl)    ; need this for a validation check 
15a9			 
15a9				dec hl    ; move to block marker 
15a9			 
15a9				; now check that the block count and block marker are the same  
15a9			        ; this checks that we are on a malloc node and not random memory 
15a9			        ; OK a faint chance this could be a problem but rare - famous last words! 
15a9			 
15a9				ld c, a 
15a9				ld a, (hl)    
15a9			 
15a9				cp c 
15a9				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15a9			 
15a9				; yes good chance we are on a malloc node 
15a9			 
15a9				ld a, 0      
15a9				ld (hl), a   ; mark as free 
15a9			 
15a9				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15a9			 
15a9			.freeignore:  
15a9			 
15a9				pop af 
15a9				pop hl 
15a9			 
15a9				ret 
15a9			 
15a9			 
15a9			 
15a9			endif 
15a9			 
15a9			; eof 
# End of file firmware_memory.asm
15a9			  
15a9			; device C  
15a9			if SOUND_ENABLE  
15a9				include "firmware_sound.asm"  
15a9			endif  
15a9			  
15a9			include "firmware_diags.asm"  
15a9			; Hardware diags menu 
15a9			 
15a9			 
15a9			config: 
15a9			 
15a9 3e 00			ld a, 0 
15ab 21 d9 15			ld hl, .configmn 
15ae cd 46 0d			call menu 
15b1			 
15b1 fe 00			cp 0 
15b3 c8				ret z 
15b4			 
15b4 fe 01			cp 1 
15b6 cc b2 16			call z, .savetostore 
15b9			 
15b9 fe 02			cp 2 
15bb cc 00 16			call z, .selautoload 
15be fe 03			cp 3 
15c0 cc e9 15			call z, .disautoload 
15c3 fe 04			cp 4 
15c5 cc b0 16			call z, .selbank 
15c8 fe 05			cp 5 
15ca cc 8d 17			call z, .debug_tog 
15cd fe 06			cp 6 
15cf cc d0 18			call z, .bpsgo 
15d2 fe 07			cp 7 
15d4 cc b3 17			call z, hardware_diags 
15d7			 
15d7 18 d0			jr config 
15d9			 
15d9			.configmn: 
15d9 c1 1a			dw prom_c3 
15db d8 1a			dw prom_c2 
15dd ed 1a			dw prom_c2a 
15df 03 1b			dw prom_c2b 
15e1			;	dw prom_c4 
15e1 20 1b			dw prom_m4 
15e3 3b 1b			dw prom_m4b 
15e5 43 1b			dw prom_c1 
15e7 00 00			dw 0 
15e9				 
15e9			 
15e9			 
15e9			 
15e9			.disautoload: 
15e9				if STORAGE_SE 
15e9 3e fe			ld a, $fe      ; bit 0 clear 
15eb 32 ed fb			ld (spi_device), a 
15ee			 
15ee cd ca 04			call storage_get_block_0 
15f1			 
15f1 3e 00			ld a, 0 
15f3 32 28 fc			ld (store_page+STORE_0_AUTOFILE), a 
15f6			 
15f6 21 00 00				ld hl, 0 
15f9 11 07 fc				ld de, store_page 
15fc cd 7e 04			call storage_write_block	 ; save update 
15ff				else 
15ff			 
15ff				ld hl, prom_notav 
15ff				ld de, prom_empty 
15ff				call info_panel 
15ff				endif 
15ff			 
15ff			 
15ff c9				ret 
1600			 
1600			 
1600			 
1600			; Select auto start 
1600			 
1600			.selautoload: 
1600			 
1600				 
1600				if STORAGE_SE 
1600			 
1600 cd d7 16				call config_dir 
1603 21 4e f3			        ld hl, scratch 
1606 3e 00				ld a, 0 
1608 cd 46 0d				call menu 
160b			 
160b fe 00				cp 0 
160d c8					ret z 
160e			 
160e 3d					dec a 
160f			 
160f			 
160f					; locate menu option 
160f			 
160f 21 4e f3				ld hl, scratch 
1612 cd 6a 0c				call table_lookup 
1615			 
1615					if DEBUG_FORTH_WORDS 
1615						DMARK "ALl" 
1615 f5				push af  
1616 3a 2a 16			ld a, (.dmark)  
1619 32 b4 fe			ld (debug_mark),a  
161c 3a 2b 16			ld a, (.dmark+1)  
161f 32 b5 fe			ld (debug_mark+1),a  
1622 3a 2c 16			ld a, (.dmark+2)  
1625 32 b6 fe			ld (debug_mark+2),a  
1628 18 03			jr .pastdmark  
162a ..			.dmark: db "ALl"  
162d f1			.pastdmark: pop af  
162e			endm  
# End of macro DMARK
162e						CALLMONITOR 
162e cd c6 18			call break_point_state  
1631				endm  
# End of macro CALLMONITOR
1631					endif 
1631					; with the pointer to the menu it, the byte following the zero term is the file id 
1631			 
1631 3e 00				ld a, 0 
1633 01 32 00				ld bc, 50   ; max of bytes to look at 
1636 ed b1				cpir  
1638			 
1638					if DEBUG_FORTH_WORDS 
1638						DMARK "ALb" 
1638 f5				push af  
1639 3a 4d 16			ld a, (.dmark)  
163c 32 b4 fe			ld (debug_mark),a  
163f 3a 4e 16			ld a, (.dmark+1)  
1642 32 b5 fe			ld (debug_mark+1),a  
1645 3a 4f 16			ld a, (.dmark+2)  
1648 32 b6 fe			ld (debug_mark+2),a  
164b 18 03			jr .pastdmark  
164d ..			.dmark: db "ALb"  
1650 f1			.pastdmark: pop af  
1651			endm  
# End of macro DMARK
1651						CALLMONITOR 
1651 cd c6 18			call break_point_state  
1654				endm  
# End of macro CALLMONITOR
1654					endif 
1654					;inc hl 
1654			 
1654 7e					ld a, (hl)   ; file id 
1655					 
1655				        ; save bank and file ids 
1655			 
1655 f5					push af 
1656			 
1656			; TODO need to save to block 0 on bank 1	 
1656			 
1656 cd ca 04				call storage_get_block_0 
1659			 
1659					if DEBUG_FORTH_WORDS 
1659						DMARK "AL0" 
1659 f5				push af  
165a 3a 6e 16			ld a, (.dmark)  
165d 32 b4 fe			ld (debug_mark),a  
1660 3a 6f 16			ld a, (.dmark+1)  
1663 32 b5 fe			ld (debug_mark+1),a  
1666 3a 70 16			ld a, (.dmark+2)  
1669 32 b6 fe			ld (debug_mark+2),a  
166c 18 03			jr .pastdmark  
166e ..			.dmark: db "AL0"  
1671 f1			.pastdmark: pop af  
1672			endm  
# End of macro DMARK
1672						CALLMONITOR 
1672 cd c6 18			call break_point_state  
1675				endm  
# End of macro CALLMONITOR
1675					endif 
1675 f1					pop af 
1676			 
1676 32 2b fc				ld (store_page+STORE_0_FILERUN),a 
1679					 
1679					; save bank id 
1679			 
1679 3a ed fb				ld a,(spi_device) 
167c 32 2a fc				ld (store_page+STORE_0_BANKRUN),a 
167f			 
167f					; enable auto run of store file 
167f			 
167f 3e 01				ld a, 1 
1681 32 28 fc				ld (store_page+STORE_0_AUTOFILE),a 
1684			 
1684					; save buffer 
1684			 
1684 21 00 00				ld hl, 0 
1687 11 07 fc				ld de, store_page 
168a					if DEBUG_FORTH_WORDS 
168a						DMARK "ALw" 
168a f5				push af  
168b 3a 9f 16			ld a, (.dmark)  
168e 32 b4 fe			ld (debug_mark),a  
1691 3a a0 16			ld a, (.dmark+1)  
1694 32 b5 fe			ld (debug_mark+1),a  
1697 3a a1 16			ld a, (.dmark+2)  
169a 32 b6 fe			ld (debug_mark+2),a  
169d 18 03			jr .pastdmark  
169f ..			.dmark: db "ALw"  
16a2 f1			.pastdmark: pop af  
16a3			endm  
# End of macro DMARK
16a3						CALLMONITOR 
16a3 cd c6 18			call break_point_state  
16a6				endm  
# End of macro CALLMONITOR
16a6					endif 
16a6 cd 7e 04			call storage_write_block	 ; save update 
16a9			  
16a9			 
16a9			 
16a9			 
16a9 21 4e f3				ld hl, scratch 
16ac cd c4 16				call config_fdir 
16af			 
16af				else 
16af			 
16af				ld hl, prom_notav 
16af				ld de, prom_empty 
16af				call info_panel 
16af			 
16af				endif 
16af c9				ret 
16b0			 
16b0			 
16b0			 
16b0			; Select storage bank 
16b0			 
16b0			.selbank: 
16b0			 
16b0				if STORAGE_SE 
16b0				else 
16b0			 
16b0				ld hl, prom_notav 
16b0				ld de, prom_empty 
16b0				call info_panel 
16b0				endif 
16b0				 
16b0 c9				ret 
16b1			 
16b1			if STORAGE_SE 
16b1			 
16b1			.config_ldir:   
16b1				; Load storage bank labels into menu array 
16b1			 
16b1				 
16b1			 
16b1			 
16b1 c9				ret 
16b2			 
16b2			 
16b2			endif 
16b2			 
16b2			 
16b2			; Save user words to storage 
16b2			 
16b2			.savetostore: 
16b2			 
16b2				if STORAGE_SE 
16b2			 
16b2 cd d7 16				call config_dir 
16b5 21 4e f3			        ld hl, scratch 
16b8 3e 00				ld a, 0 
16ba cd 46 0d				call menu 
16bd					 
16bd 21 4e f3				ld hl, scratch 
16c0 cd c4 16				call config_fdir 
16c3			 
16c3				else 
16c3			 
16c3				ld hl, prom_notav 
16c3				ld de, prom_empty 
16c3				call info_panel 
16c3			 
16c3				endif 
16c3			 
16c3 c9				ret 
16c4			 
16c4			 
16c4			 
16c4			if STORAGE_SE 
16c4			 
16c4			config_fdir: 
16c4				; using the scratch dir go through and release the memory allocated for each string 
16c4				 
16c4 21 4e f3			ld hl, scratch 
16c7 5e			.cfdir:	ld e,(hl) 
16c8 23				inc hl 
16c9 56				ld d,(hl) 
16ca 23				inc hl 
16cb			 
16cb eb				ex de, hl 
16cc cd 72 0f			call ishlzero 
16cf c8				ret z     ; return on null pointer 
16d0 cd da 14			call free 
16d3 eb				ex de, hl 
16d4 18 f1			jr .cfdir 
16d6			 
16d6			 
16d6 c9				ret 
16d7			 
16d7			 
16d7			config_dir: 
16d7			 
16d7				; for the config menus that need to build a directory of storage call this routine 
16d7				; it will construct a menu in scratch to pass to menu 
16d7			 
16d7				; open storage device 
16d7			 
16d7				; execute DIR to build a list of files and their ids into scratch in menu format 
16d7				; once the menu has finished then will need to call config_fdir to release the strings 
16d7				 
16d7				; c = number items 
16d7			 
16d7				 
16d7 cd ca 04			call storage_get_block_0 
16da			 
16da 21 07 fc			ld hl, store_page     ; get current id count 
16dd 46				ld b, (hl) 
16de 0e 00			ld c, 0    ; count of files   
16e0			 
16e0			 
16e0 21 4e f3			ld hl, scratch 
16e3 22 fe fb			ld (store_tmp2), hl    ; location to poke strings 
16e6			 
16e6				; check for empty drive 
16e6			 
16e6 3e 00			ld a, 0 
16e8 b8				cp b 
16e9 ca 83 17			jp z, .dirdone 
16ec			 
16ec				 
16ec					if DEBUG_FORTH_WORDS 
16ec						DMARK "Cdc" 
16ec f5				push af  
16ed 3a 01 17			ld a, (.dmark)  
16f0 32 b4 fe			ld (debug_mark),a  
16f3 3a 02 17			ld a, (.dmark+1)  
16f6 32 b5 fe			ld (debug_mark+1),a  
16f9 3a 03 17			ld a, (.dmark+2)  
16fc 32 b6 fe			ld (debug_mark+2),a  
16ff 18 03			jr .pastdmark  
1701 ..			.dmark: db "Cdc"  
1704 f1			.pastdmark: pop af  
1705			endm  
# End of macro DMARK
1705						CALLMONITOR 
1705 cd c6 18			call break_point_state  
1708				endm  
# End of macro CALLMONITOR
1708					endif 
1708			 
1708			 
1708			.diritem:	 
1708 c5				push bc 
1709				; for each of the current ids do a search for them and if found push to stack 
1709			 
1709 21 40 00				ld hl, STORE_BLOCK_PHY 
170c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
170e 58					ld e,b 
170f			 
170f cd 4c 07				call storage_findnextid 
1712			 
1712			 
1712					; if found hl will be non zero 
1712			 
1712 cd 72 0f				call ishlzero 
1715 28 69				jr z, .dirnotfound 
1717			 
1717					; increase count 
1717			 
1717 c1					pop bc	 
1718 0c					inc c 
1719 c5					push bc 
171a					 
171a			 
171a					; get file header and push the file name 
171a			 
171a 11 07 fc				ld de, store_page 
171d cd 19 04				call storage_read_block 
1720			 
1720					; push file id to stack 
1720				 
1720 3a 07 fc				ld a, (store_page) 
1723 26 00				ld h, 0 
1725 6f					ld l, a 
1726			 
1726					;call forth_push_numhl 
1726					; TODO store id 
1726			 
1726 e5					push hl 
1727			 
1727					; push extent count to stack  
1727				 
1727 21 0a fc				ld hl, store_page+3 
172a			 
172a					; get file name length 
172a			 
172a cd a7 13				call strlenz   
172d			 
172d 23					inc hl   ; cover zero term 
172e 23					inc hl  ; stick the id at the end of the area 
172f			 
172f e5					push hl 
1730 c1					pop bc    ; move length to bc 
1731			 
1731 cd 10 14				call malloc 
1734			 
1734					; TODO save malloc area to scratch 
1734			 
1734 eb					ex de, hl 
1735 2a fe fb				ld hl, (store_tmp2) 
1738 73					ld (hl), e 
1739 23					inc hl 
173a 72					ld (hl), d 
173b 23					inc hl 
173c 22 fe fb				ld (store_tmp2), hl 
173f			 
173f					 
173f			 
173f					;pop hl   ; get source 
173f			;		ex de, hl    ; swap aronund	 
173f			 
173f 21 0a fc				ld hl, store_page+3 
1742					if DEBUG_FORTH_WORDS 
1742						DMARK "CFd" 
1742 f5				push af  
1743 3a 57 17			ld a, (.dmark)  
1746 32 b4 fe			ld (debug_mark),a  
1749 3a 58 17			ld a, (.dmark+1)  
174c 32 b5 fe			ld (debug_mark+1),a  
174f 3a 59 17			ld a, (.dmark+2)  
1752 32 b6 fe			ld (debug_mark+2),a  
1755 18 03			jr .pastdmark  
1757 ..			.dmark: db "CFd"  
175a f1			.pastdmark: pop af  
175b			endm  
# End of macro DMARK
175b						CALLMONITOR 
175b cd c6 18			call break_point_state  
175e				endm  
# End of macro CALLMONITOR
175e					endif 
175e ed b0				ldir 
1760			 
1760					; de is past string, move back one and store id 
1760					 
1760 1b					dec de 
1761			 
1761					; store file id 
1761			 
1761 e1					pop hl 
1762 eb					ex de,hl 
1763 73					ld (hl), e 
1764			 
1764					if DEBUG_FORTH_WORDS 
1764						DMARK "Cdi" 
1764 f5				push af  
1765 3a 79 17			ld a, (.dmark)  
1768 32 b4 fe			ld (debug_mark),a  
176b 3a 7a 17			ld a, (.dmark+1)  
176e 32 b5 fe			ld (debug_mark+1),a  
1771 3a 7b 17			ld a, (.dmark+2)  
1774 32 b6 fe			ld (debug_mark+2),a  
1777 18 03			jr .pastdmark  
1779 ..			.dmark: db "Cdi"  
177c f1			.pastdmark: pop af  
177d			endm  
# End of macro DMARK
177d						CALLMONITOR 
177d cd c6 18			call break_point_state  
1780				endm  
# End of macro CALLMONITOR
1780					endif 
1780					 
1780			.dirnotfound: 
1780 c1					pop bc     
1781 10 85				djnz .diritem 
1783				 
1783			.dirdone:	 
1783			 
1783 3e 00				ld a, 0 
1785 2a fe fb				ld hl, (store_tmp2) 
1788 77					ld (hl), a 
1789 23					inc hl 
178a 77					ld (hl), a 
178b 23					inc hl 
178c					; push a count of the dir items found 
178c			 
178c			;		ld h, 0 
178c			;		ld l, c 
178c			 
178c c9				ret 
178d			 
178d			endif 
178d			 
178d			 
178d			; Settings 
178d			; Run  
178d			 
178d			 
178d			 
178d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
178d			;;hd_menu2:   db "        2: Editor",0   
178d			;hd_menu2:   db "        2: Editor       6: Menu",0   
178d			;hd_menu3:   db "        3: Storage",0 
178d			;hd_menu4:   db "0=quit  4: Debug",0 
178d			;hd_don:     db "ON",0 
178d			;hd_doff:     db "OFF",0 
178d			; 
178d			; 
178d			; 
178d			;hardware_diags_old:       
178d			; 
178d			;.diagmenu: 
178d			;	call clear_display 
178d			;	ld a, display_row_1 
178d			;	ld de, hd_menu1 
178d			;	call str_at_display 
178d			; 
178d			;	ld a, display_row_2 
178d			;	ld de, hd_menu2 
178d			;	call str_at_display 
178d			; 
178d			;	ld a, display_row_3 
178d			;	ld de, hd_menu3 
178d			;	call str_at_display 
178d			; 
178d			;	ld a,  display_row_4 
178d			;	ld de, hd_menu4 
178d			;	call str_at_display 
178d			; 
178d			;	; display debug state 
178d			; 
178d			;	ld de, hd_don 
178d			;	ld a, (os_view_disable) 
178d			;	cp 0 
178d			;	jr z, .distog 
178d			;	ld de, hd_doff 
178d			;.distog: ld a, display_row_4+17 
178d			;	call str_at_display 
178d			; 
178d			;	call update_display 
178d			; 
178d			;	call cin_wait 
178d			; 
178d			; 
178d			; 
178d			;	cp '4' 
178d			;	jr nz, .diagn1 
178d			; 
178d			;	; debug toggle 
178d			; 
178d			;	ld a, (os_view_disable) 
178d			;	ld b, '*' 
178d			;	cp 0 
178d			;	jr z, .debtog 
178d			;	ld b, 0 
178d			;.debtog:	 
178d			;	ld a,b 
178d			;	ld (os_view_disable),a 
178d			; 
178d			;.diagn1: cp '0' 
178d			;	 ret z 
178d			; 
178d			;;	cp '1' 
178d			;;       jp z, matrix	 
178d			;;   TODO keyboard matrix test 
178d			; 
178d			;	cp '2' 
178d			;	jp z, .diagedit 
178d			; 
178d			;;	cp '6' 
178d			;;	jp z, .menutest 
178d			;;if ENABLE_BASIC 
178d			;;	cp '6' 
178d			;;	jp z, basic 
178d			;;endif 
178d			 ; 
178d			;	jp .diagmenu 
178d			; 
178d			; 
178d			;	ret 
178d			 
178d			 
178d			.debug_tog: 
178d 21 d4 17			ld hl, .menudebug 
1790				 
1790 3a 3f f3			ld a, (os_view_disable) 
1793 fe 2a			cp '*' 
1795 20 04			jr nz,.tdon  
1797 3e 01			ld a, 1 
1799 18 02			jr .tog1 
179b 3e 00		.tdon: ld a, 0 
179d			 
179d			.tog1: 
179d cd 46 0d			call menu 
17a0 fe 00			cp 0 
17a2 c8				ret z 
17a3 fe 01			cp 1    ; disable debug 
17a5 28 04			jr z, .dtog0 
17a7 3e 2a			ld a, '*' 
17a9 18 02			jr .dtogset 
17ab 3e 00		.dtog0: ld a, 0 
17ad 32 3f f3		.dtogset:  ld (os_view_disable), a 
17b0 c3 8d 17			jp .debug_tog 
17b3			 
17b3			 
17b3			hardware_diags:       
17b3			 
17b3			.diagm: 
17b3 21 c6 17			ld hl, .menuitems 
17b6 3e 00			ld a, 0 
17b8 cd 46 0d			call menu 
17bb			 
17bb fe 00		         cp 0 
17bd c8				 ret z 
17be			 
17be fe 02			cp 2 
17c0 ca 1f 18			jp z, .diagedit 
17c3			 
17c3			;	cp '6' 
17c3			;	jp z, .menutest 
17c3			;if ENABLE_BASIC 
17c3			;	cp '6' 
17c3			;	jp z, basic 
17c3			;endif 
17c3			  
17c3 c3 b3 17			jp .diagm 
17c6			 
17c6				 
17c6 da 17		.menuitems:   	dw .m1 
17c8 e5 17				dw .m2 
17ca ec 17				dw .m3 
17cc f4 17				dw .m5 
17ce fa 17				dw .m5a 
17d0 03 18				dw .m5b 
17d2 00 00				dw 0 
17d4			 
17d4			.menudebug: 
17d4 0c 18				dw .m6 
17d6 15 18				dw .m7 
17d8 00 00				dw 0 
17da			 
17da .. 00		.m1:   db "Key Matrix",0 
17e5 .. 00		.m2:   db "Editor",0 
17ec .. 00		.m3:   db "Storage",0 
17f4 .. 00		.m5:   db "Sound",0 
17fa .. 00		.m5a:  db "RAM Test",0 
1803 .. 00		.m5b:  db "LCD Test",0 
180c			 
180c .. 00		.m6:   db "Debug ON",0 
1815 .. 00		.m7:   db "Debug OFF",0 
181f			 
181f			; debug editor 
181f			 
181f			.diagedit: 
181f			 
181f 21 4e f3			ld hl, scratch 
1822			;	ld bc, 250 
1822			;	ldir 
1822				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1822 3e 00			ld a, 0 
1824 77				ld (hl), a 
1825 23				inc hl 
1826 77				ld (hl), a 
1827 23				inc hl 
1828 77				ld (hl), a 
1829			 
1829 cd 15 0d		        call clear_display 
182c cd 38 0d			call update_display 
182f				;ld a, 1 
182f				;ld (hardware_diag), a 
182f			.diloop: 
182f 3e 00			ld a, display_row_1 
1831 0e 00			ld c, 0 
1833 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1835 1e 28			ld e, 40 
1837			 
1837 21 4e f3			ld hl, scratch	 
183a cd 76 0f			call input_str 
183d			 
183d 3e 14			ld a, display_row_2 
183f 11 4e f3			ld de, scratch 
1842 cd 28 0d			call str_at_display 
1845 cd 38 0d			call update_display 
1848			 
1848 c3 2f 18			jp .diloop 
184b			 
184b			 
184b			; pass word in hl 
184b			; a has display location 
184b			display_word_at: 
184b f5				push af 
184c e5				push hl 
184d 7c				ld a,h 
184e 21 53 f6			ld hl, os_word_scratch 
1851 cd 4a 12			call hexout 
1854 e1				pop hl 
1855 7d				ld a,l 
1856 21 55 f6			ld hl, os_word_scratch+2 
1859 cd 4a 12			call hexout 
185c 21 57 f6			ld hl, os_word_scratch+4 
185f 3e 00			ld a,0 
1861 77				ld (hl),a 
1862 11 53 f6			ld de,os_word_scratch 
1865 f1				pop af 
1866 cd 28 0d				call str_at_display 
1869 c9				ret 
186a			 
186a			display_ptr_state: 
186a			 
186a				; to restore afterwards 
186a			 
186a d5				push de 
186b c5				push bc 
186c e5				push hl 
186d f5				push af 
186e			 
186e				; for use in here 
186e			 
186e			;	push bc 
186e			;	push de 
186e			;	push hl 
186e			;	push af 
186e			 
186e cd 15 0d			call clear_display 
1871			 
1871 11 44 1a			ld de, .ptrstate 
1874 3e 00			ld a, display_row_1 
1876 cd 28 0d			call str_at_display 
1879			 
1879				; display debug step 
1879			 
1879			 
1879 11 b4 fe			ld de, debug_mark 
187c 3e 12			ld a, display_row_1+display_cols-2 
187e cd 28 0d			call str_at_display 
1881			 
1881				; display a 
1881 11 4e 1a			ld de, .ptrcliptr 
1884 3e 14			ld a, display_row_2 
1886 cd 28 0d			call str_at_display 
1889			 
1889 f1				pop af 
188a 2a cd fb			ld hl,(cli_ptr) 
188d 3e 1c			ld a, display_row_2+8 
188f cd 4b 18			call display_word_at 
1892			 
1892			 
1892				; display hl 
1892			 
1892			 
1892 11 56 1a			ld de, .ptrclioptr 
1895 3e 1e			ld a, display_row_2+10 
1897 cd 28 0d			call str_at_display 
189a			; 
189a			;	pop hl 
189a 3e 21			ld a, display_row_2+13 
189c 2a cb fb			ld hl,(cli_origptr) 
189f cd 4b 18			call display_word_at 
18a2			; 
18a2			;	 
18a2			;	; display de 
18a2			 
18a2			;	ld de, .regstatede 
18a2			;	ld a, display_row_3 
18a2			;	call str_at_display 
18a2			 
18a2			;	pop de 
18a2			;	ld h,d 
18a2			;	ld l, e 
18a2			;	ld a, display_row_3+3 
18a2			;	call display_word_at 
18a2			 
18a2			 
18a2				; display bc 
18a2			 
18a2			;	ld de, .regstatebc 
18a2			;	ld a, display_row_3+10 
18a2			;	call str_at_display 
18a2			 
18a2			;	pop bc 
18a2			;	ld h,b 
18a2			;	ld l, c 
18a2			;	ld a, display_row_3+13 
18a2			;	call display_word_at 
18a2			 
18a2			 
18a2				; display dsp 
18a2			 
18a2			;	ld de, .regstatedsp 
18a2			;	ld a, display_row_4 
18a2			;	call str_at_display 
18a2			 
18a2				 
18a2			;	ld hl,(cli_data_sp) 
18a2			;	ld a, display_row_4+4 
18a2			;	call display_word_at 
18a2			 
18a2				; display rsp 
18a2			 
18a2 11 85 1a			ld de, .regstatersp 
18a5 3e 46			ld a, display_row_4+10 
18a7 cd 28 0d			call str_at_display 
18aa			 
18aa				 
18aa 2a 7f fb			ld hl,(cli_ret_sp) 
18ad 3e 4a			ld a, display_row_4+14 
18af cd 4b 18			call display_word_at 
18b2			 
18b2 cd 38 0d			call update_display 
18b5			 
18b5 cd 92 0c			call delay1s 
18b8 cd 92 0c			call delay1s 
18bb cd 92 0c			call delay1s 
18be			 
18be			 
18be cd b2 1e			call next_page_prompt 
18c1			 
18c1				; restore  
18c1			 
18c1 f1				pop af 
18c2 e1				pop hl 
18c3 c1				pop bc 
18c4 d1				pop de 
18c5 c9				ret 
18c6			 
18c6			break_point_state: 
18c6 f5				push af 
18c7			 
18c7				; see if disabled 
18c7			 
18c7 3a 3f f3			ld a, (os_view_disable) 
18ca fe 2a			cp '*' 
18cc 20 02			jr nz, .bpsgo 
18ce f1				pop af 
18cf c9				ret 
18d0			 
18d0			.bpsgo: 
18d0 f1				pop af 
18d1 f5				push af 
18d2 22 3b f3			ld (os_view_hl), hl 
18d5 ed 53 39 f3		ld (os_view_de), de 
18d9 ed 43 37 f3		ld (os_view_bc), bc 
18dd e5				push hl 
18de 6f				ld l, a 
18df 26 00			ld h, 0 
18e1 22 3d f3			ld (os_view_af),hl 
18e4			 
18e4 21 4a fe				ld hl, display_fb0 
18e7 22 55 fd				ld (display_fb_active), hl 
18ea e1				pop hl	 
18eb			 
18eb 3e 31			ld a, '1' 
18ed fe 2a		.bps1:  cp '*' 
18ef 20 03			jr nz, .bps1b 
18f1 32 3f f3			ld (os_view_disable),a 
18f4 fe 31		.bps1b:  cp '1' 
18f6 20 14			jr nz, .bps2 
18f8			 
18f8				; display reg 
18f8			 
18f8				 
18f8			 
18f8 3a 3d f3			ld a, (os_view_af) 
18fb 2a 3b f3			ld hl, (os_view_hl) 
18fe ed 5b 39 f3		ld de, (os_view_de) 
1902 ed 4b 37 f3		ld bc, (os_view_bc) 
1906 cd a0 19			call display_reg_state 
1909 c3 8c 19			jp .bpschk 
190c			 
190c fe 32		.bps2:  cp '2' 
190e 20 08			jr nz, .bps3 
1910				 
1910				; display hl 
1910 2a 3b f3			ld hl, (os_view_hl) 
1913 cd 8a 1a			call display_dump_at_hl 
1916			 
1916 18 74			jr .bpschk 
1918			 
1918 fe 33		.bps3:  cp '3' 
191a 20 08			jr nz, .bps4 
191c			 
191c			        ; display de 
191c 2a 39 f3			ld hl, (os_view_de) 
191f cd 8a 1a			call display_dump_at_hl 
1922			 
1922 18 68			jr .bpschk 
1924 fe 34		.bps4:  cp '4' 
1926 20 08			jr nz, .bps5 
1928			 
1928			        ; display bc 
1928 2a 37 f3			ld hl, (os_view_bc) 
192b cd 8a 1a			call display_dump_at_hl 
192e			 
192e 18 5c			jr .bpschk 
1930 fe 35		.bps5:  cp '5' 
1932 20 08		        jr nz, .bps7 
1934			 
1934				; display cur ptr 
1934 2a cd fb			ld hl, (cli_ptr) 
1937 cd 8a 1a			call display_dump_at_hl 
193a			 
193a 18 50			jr .bpschk 
193c fe 36		.bps7:  cp '6' 
193e 20 08			jr nz, .bps8b 
1940				 
1940				; display cur orig ptr 
1940 2a cb fb			ld hl, (cli_origptr) 
1943 cd 8a 1a			call display_dump_at_hl 
1946 18 44			jr .bpschk 
1948 fe 37		.bps8b:  cp '7' 
194a 20 08			jr nz, .bps9 
194c				 
194c				; display dsp 
194c 2a 7b fb			ld hl, (cli_data_sp) 
194f cd 8a 1a			call display_dump_at_hl 
1952			 
1952 18 38			jr .bpschk 
1954 fe 39		.bps9:  cp '9' 
1956 20 05			jr nz, .bps8c 
1958				 
1958				; display SP 
1958			;	ld hl, sp 
1958 cd 8a 1a			call display_dump_at_hl 
195b			 
195b 18 2f			jr .bpschk 
195d fe 38		.bps8c:  cp '8' 
195f 20 08			jr nz, .bps8d 
1961				 
1961				; display rsp 
1961 2a 7f fb			ld hl, (cli_ret_sp) 
1964 cd 8a 1a			call display_dump_at_hl 
1967			 
1967 18 23			jr .bpschk 
1969 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
196b 20 05			jr nz, .bps8 
196d cd a8 1c			call monitor 
1970			 
1970 18 1a			jr .bpschk 
1972 fe 30		.bps8:  cp '0' 
1974 20 16			jr nz, .bpschk 
1976			 
1976 21 f9 fd				ld hl, display_fb1 
1979 22 55 fd				ld (display_fb_active), hl 
197c cd 38 0d				call update_display 
197f			 
197f				;ld a, (os_view_af) 
197f 2a 3b f3			ld hl, (os_view_hl) 
1982 ed 5b 39 f3		ld de, (os_view_de) 
1986 ed 4b 37 f3		ld bc, (os_view_bc) 
198a f1				pop af 
198b c9				ret 
198c			 
198c			.bpschk:   
198c cd 92 0c			call delay1s 
198f 3e 4f		ld a,display_row_4 + display_cols - 1 
1991 11 b0 1e		        ld de, endprg 
1994 cd 28 0d			call str_at_display 
1997 cd 38 0d			call update_display 
199a cd 5b 74			call cin_wait 
199d			 
199d c3 ed 18			jp .bps1 
19a0			 
19a0			 
19a0			display_reg_state: 
19a0			 
19a0				; to restore afterwards 
19a0			 
19a0 d5				push de 
19a1 c5				push bc 
19a2 e5				push hl 
19a3 f5				push af 
19a4			 
19a4				; for use in here 
19a4			 
19a4 c5				push bc 
19a5 d5				push de 
19a6 e5				push hl 
19a7 f5				push af 
19a8			 
19a8 cd 15 0d			call clear_display 
19ab			 
19ab 11 60 1a			ld de, .regstate 
19ae 3e 00			ld a, display_row_1 
19b0 cd 28 0d			call str_at_display 
19b3			 
19b3				; display debug step 
19b3			 
19b3			 
19b3 11 b4 fe			ld de, debug_mark 
19b6 3e 11			ld a, display_row_1+display_cols-3 
19b8 cd 28 0d			call str_at_display 
19bb			 
19bb				; display a 
19bb 11 7c 1a			ld de, .regstatea 
19be 3e 14			ld a, display_row_2 
19c0 cd 28 0d			call str_at_display 
19c3			 
19c3 e1				pop hl 
19c4			;	ld h,0 
19c4			;	ld l, a 
19c4 3e 17			ld a, display_row_2+3 
19c6 cd 4b 18			call display_word_at 
19c9			 
19c9			 
19c9				; display hl 
19c9			 
19c9			 
19c9 11 70 1a			ld de, .regstatehl 
19cc 3e 1e			ld a, display_row_2+10 
19ce cd 28 0d			call str_at_display 
19d1			 
19d1 e1				pop hl 
19d2 3e 21			ld a, display_row_2+13 
19d4 cd 4b 18			call display_word_at 
19d7			 
19d7				 
19d7				; display de 
19d7			 
19d7 11 74 1a			ld de, .regstatede 
19da 3e 28			ld a, display_row_3 
19dc cd 28 0d			call str_at_display 
19df			 
19df e1				pop hl 
19e0			;	ld h,d 
19e0			;	ld l, e 
19e0 3e 2b			ld a, display_row_3+3 
19e2 cd 4b 18			call display_word_at 
19e5			 
19e5			 
19e5				; display bc 
19e5			 
19e5 11 78 1a			ld de, .regstatebc 
19e8 3e 32			ld a, display_row_3+10 
19ea cd 28 0d			call str_at_display 
19ed			 
19ed e1				pop hl 
19ee			;	ld h,b 
19ee			;	ld l, c 
19ee 3e 35			ld a, display_row_3+13 
19f0 cd 4b 18			call display_word_at 
19f3			 
19f3			 
19f3				; display dsp 
19f3			 
19f3 11 80 1a			ld de, .regstatedsp 
19f6 3e 3c			ld a, display_row_4 
19f8 cd 28 0d			call str_at_display 
19fb			 
19fb				 
19fb 2a 7b fb			ld hl,(cli_data_sp) 
19fe 3e 40			ld a, display_row_4+4 
1a00 cd 4b 18			call display_word_at 
1a03			 
1a03				; display rsp 
1a03			 
1a03 11 85 1a			ld de, .regstatersp 
1a06 3e 46			ld a, display_row_4+10 
1a08 cd 28 0d			call str_at_display 
1a0b			 
1a0b				 
1a0b 2a 7f fb			ld hl,(cli_ret_sp) 
1a0e 3e 4a			ld a, display_row_4+14 
1a10 cd 4b 18			call display_word_at 
1a13			 
1a13 cd 38 0d			call update_display 
1a16			 
1a16			;	call delay1s 
1a16			;	call delay1s 
1a16			;	call delay1s 
1a16			 
1a16			 
1a16			;	call next_page_prompt 
1a16			 
1a16				; restore  
1a16			 
1a16 f1				pop af 
1a17 e1				pop hl 
1a18 c1				pop bc 
1a19 d1				pop de 
1a1a c9				ret 
1a1b			 
1a1b .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a2f .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a44 .. 00		.ptrstate:	db "Ptr State",0 
1a4e .. 00		.ptrcliptr:     db "cli_ptr",0 
1a56 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a60 .. 00		.regstate:	db "Reg State (1/0)",0 
1a70 .. 00		.regstatehl:	db "HL:",0 
1a74 .. 00		.regstatede:	db "DE:",0 
1a78 .. 00		.regstatebc:	db "BC:",0 
1a7c .. 00		.regstatea:	db "A :",0 
1a80 .. 00		.regstatedsp:	db "DSP:",0 
1a85 .. 00		.regstatersp:	db "RSP:",0 
1a8a			 
1a8a			display_dump_at_hl: 
1a8a e5				push hl 
1a8b d5				push de 
1a8c c5				push bc 
1a8d f5				push af 
1a8e			 
1a8e 22 71 f6			ld (os_cur_ptr),hl	 
1a91 cd 15 0d			call clear_display 
1a94 cd ba 1d			call dumpcont 
1a97			;	call delay1s 
1a97			;	call next_page_prompt 
1a97			 
1a97			 
1a97 f1				pop af 
1a98 c1				pop bc 
1a99 d1				pop de 
1a9a e1				pop hl 
1a9b c9				ret 
1a9c			 
1a9c			;if ENABLE_BASIC 
1a9c			;	include "nascombasic.asm" 
1a9c			;	basic: 
1a9c			;	include "forth/FORTH.ASM" 
1a9c			;endif 
1a9c			 
1a9c			; eof 
1a9c			 
1a9c			 
# End of file firmware_diags.asm
1a9c			  
1a9c			include "firmware_prompts.asm"  
1a9c			; Prompts  
1a9c			 
1a9c			; boot messages 
1a9c			 
1a9c .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1ab1 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1ac1			 
1ac1			 
1ac1			; config menus 
1ac1			 
1ac1 .. 00		prom_c3: db "Add Dictionary To File",0 
1ad8 .. 00		prom_c2: db "Select Autoload File",0 
1aed .. 00		prom_c2a: db "Disable Autoload File", 0 
1b03 .. 00		prom_c2b: db "Select Storage Bank",0 
1b17 .. 00		prom_c4: db "Settings",0 
1b20 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b3b .. 00		prom_m4b:   db "Monitor",0 
1b43 .. 00		prom_c1: db "Hardware Diags",0 
1b52			 
1b52			 
1b52 .. 00		prom_notav:    db "Feature not available",0 
1b68 .. 00		prom_empty:    db "",0 
1b69			 
1b69			; eof 
1b69			 
# End of file firmware_prompts.asm
1b69			  
1b69			  
1b69			; eof  
1b69			  
# End of file firmware.asm
1b69			 
1b69			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b69			;if BASE_KEV  
1b69			;baseram: equ 08000h 
1b69			;endif 
1b69			 
1b69			;if BASE_SC114 
1b69			;baseram:     equ    endofcode 
1b69			;endif 
1b69			 
1b69			 
1b69			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1b69			 
1b69			; start system 
1b69			 
1b69			coldstart: 
1b69				; set sp 
1b69				; di/ei 
1b69			 
1b69 f3				di 
1b6a 31 fd ff			ld sp, tos 
1b6d			;	ei 
1b6d			 
1b6d			 
1b6d				; disable breakpoint by default 
1b6d			 
1b6d 3e 2a			ld a,'*' 
1b6f 32 3f f3			ld (os_view_disable),a 
1b72			 
1b72				; init hardware 
1b72			 
1b72				; init keyboard and screen hardware 
1b72			 
1b72 cd 1c 00			call hardware_init 
1b75			 
1b75			 
1b75 cd 92 0c			call delay1s 
1b78 3e 30			ld a, display_row_3+8 
1b7a 11 03 00			ld de, buildtime 
1b7d cd 28 0d			call str_at_display 
1b80 cd 38 0d			call update_display 
1b83			 
1b83 cd 92 0c			call delay1s 
1b86 cd 92 0c			call delay1s 
1b89 cd 92 0c			call delay1s 
1b8c			 
1b8c				; detect if any keys are held down to enable breakpoints at start up 
1b8c			 
1b8c cd 6c 74			call cin  
1b8f fe 00			cp 0 
1b91 28 03			jr z, .nokeys 
1b93			 
1b93				;call hardware_diags 
1b93 cd a9 15			call config 
1b96			 
1b96			;	ld de, .bpen 
1b96			;	ld a, display_row_4 
1b96			;	call str_at_display 
1b96			;	call update_display 
1b96			; 
1b96			;	ld a,0 
1b96			;	ld (os_view_disable),a 
1b96			; 
1b96			;.bpwait: 
1b96			;	call cin 
1b96			;	cp 0 
1b96			;	jr z, .bpwait 
1b96			;	jr .nokeys 
1b96			; 
1b96			; 
1b96			;.bpen:  db "Break points enabled!",0 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			.nokeys: 
1b96			 
1b96			 
1b96				 
1b96			 
1b96			;jp  testkey 
1b96			 
1b96			;call storage_get_block_0 
1b96			; 
1b96			;ld hl, 0 
1b96			;ld de, store_page 
1b96			;call storage_read_block 
1b96			 
1b96				 
1b96			;ld hl, 10 
1b96			;ld de, store_page 
1b96			;call storage_read_block 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			;stop:	nop 
1b96			;	jp stop 
1b96			 
1b96			 
1b96			 
1b96			main: 
1b96 cd 15 0d			call clear_display 
1b99 cd 38 0d			call update_display 
1b9c			 
1b9c			 
1b9c			 
1b9c			;	call testlcd 
1b9c			 
1b9c			 
1b9c			 
1b9c cd b7 22			call forth_init 
1b9f			 
1b9f			 
1b9f			warmstart: 
1b9f cd 8d 22			call forth_warmstart 
1ba2			 
1ba2				; run startup word load 
1ba2			        ; TODO prevent this running at warmstart after crash  
1ba2			 
1ba2				if STARTUP_ENABLE 
1ba2					if STORAGE_SE 
1ba2 cd 9d 71					call forth_autoload 
1ba5					endif 
1ba5 cd ac 6e				call forth_startup 
1ba8			 
1ba8			 
1ba8				endif 
1ba8			 
1ba8				; show free memory after boot 
1ba8 11 42 1c			ld de, freeram 
1bab 3e 00			ld a, display_row_1 
1bad cd 28 0d			call str_at_display 
1bb0			 
1bb0			; Or use heap_size word???? 
1bb0 21 34 f3			ld hl, heap_end 
1bb3 11 0e 80			ld de, heap_start 
1bb6 ed 52			sbc hl, de 
1bb8 e5				push hl 
1bb9 7c				ld a,h	         	 
1bba 21 53 f6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bbd cd 4a 12			call hexout 
1bc0 e1			   	pop hl 
1bc1			 
1bc1 7d				ld a,l 
1bc2 21 55 f6			ld hl, os_word_scratch+2 
1bc5 cd 4a 12			call hexout 
1bc8 21 57 f6			ld hl, os_word_scratch+4 
1bcb 3e 00			ld a, 0 
1bcd 77				ld (hl),a 
1bce 11 53 f6			ld de, os_word_scratch 
1bd1 3e 0d			ld a, display_row_1 + 13 
1bd3 cd 28 0d			call str_at_display 
1bd6 cd 38 0d			call update_display 
1bd9			 
1bd9			 
1bd9				;call demo 
1bd9			 
1bd9			 
1bd9				; init scratch input area for cli commands 
1bd9			 
1bd9 21 75 f6			ld hl, os_cli_cmd 
1bdc 3e 00			ld a,0 
1bde 77				ld (hl),a 
1bdf 23				inc hl 
1be0 77				ld (hl),a 
1be1			 
1be1 3e 00			ld a,0 
1be3 32 74 f7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1be6			 
1be6 32 71 f6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1be9 32 72 f6			ld (os_cur_ptr+1),a	 
1bec			 
1bec 32 53 f6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1bef 32 54 f6			ld (os_word_scratch+1),a	 
1bf2				 
1bf2			 
1bf2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bf2 21 75 f6			ld hl, os_cli_cmd 
1bf5			 
1bf5 3e 00			ld a, 0		 ; init cli input 
1bf7 77				ld (hl), a 
1bf8 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bfa			cli: 
1bfa				; show cli prompt 
1bfa				;push af 
1bfa				;ld a, 0 
1bfa				;ld de, prompt 
1bfa				;call str_at_display 
1bfa			 
1bfa				;call update_display 
1bfa				;pop af 
1bfa				;inc a 
1bfa				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bfa 0e 00			ld c, 0 
1bfc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1bfe 1e 28			ld e, 40 
1c00			 
1c00 21 75 f6			ld hl, os_cli_cmd 
1c03			 
1c03				STACKFRAME OFF $fefe $9f9f 
1c03				if DEBUG_STACK_IMB 
1c03					if OFF 
1c03						exx 
1c03						ld de, $fefe 
1c03						ld a, d 
1c03						ld hl, curframe 
1c03						call hexout 
1c03						ld a, e 
1c03						ld hl, curframe+2 
1c03						call hexout 
1c03						ld hl, $fefe 
1c03						push hl 
1c03						ld hl, $9f9f 
1c03						push hl 
1c03						exx 
1c03					endif 
1c03				endif 
1c03			endm 
# End of macro STACKFRAME
1c03			 
1c03 cd 76 0f			call input_str 
1c06			 
1c06				STACKFRAMECHK OFF $fefe $9f9f 
1c06				if DEBUG_STACK_IMB 
1c06					if OFF 
1c06						exx 
1c06						ld hl, $9f9f 
1c06						pop de   ; $9f9f 
1c06						call cmp16 
1c06						jr nz, .spnosame 
1c06						ld hl, $fefe 
1c06						pop de   ; $fefe 
1c06						call cmp16 
1c06						jr z, .spfrsame 
1c06						.spnosame: call showsperror 
1c06						.spfrsame: nop 
1c06						exx 
1c06					endif 
1c06				endif 
1c06			endm 
# End of macro STACKFRAMECHK
1c06			 
1c06				; copy input to last command 
1c06			 
1c06 21 75 f6			ld hl, os_cli_cmd 
1c09 11 74 f7			ld de, os_last_cmd 
1c0c 01 ff 00			ld bc, 255 
1c0f ed b0			ldir 
1c11			 
1c11				; wipe current buffer 
1c11			 
1c11			;	ld a, 0 
1c11			;	ld hl, os_cli_cmd 
1c11			;	ld de, os_cli_cmd+1 
1c11			;	ld bc, 254 
1c11			;	ldir 
1c11				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1c11			;	call strcpy 
1c11			;	ld a, 0 
1c11			;	ld (hl), a 
1c11			;	inc hl 
1c11			;	ld (hl), a 
1c11			;	inc hl 
1c11			;	ld (hl), a 
1c11			 
1c11				; switch frame buffer to program  
1c11			 
1c11 21 f9 fd				ld hl, display_fb1 
1c14 22 55 fd				ld (display_fb_active), hl 
1c17			 
1c17			;	nop 
1c17				STACKFRAME ON $fbfe $8f9f 
1c17				if DEBUG_STACK_IMB 
1c17					if ON 
1c17						exx 
1c17						ld de, $fbfe 
1c17						ld a, d 
1c17						ld hl, curframe 
1c17						call hexout 
1c17						ld a, e 
1c17						ld hl, curframe+2 
1c17						call hexout 
1c17						ld hl, $fbfe 
1c17						push hl 
1c17						ld hl, $8f9f 
1c17						push hl 
1c17						exx 
1c17					endif 
1c17				endif 
1c17			endm 
# End of macro STACKFRAME
1c17				; first time into the parser so pass over the current scratch pad 
1c17 21 75 f6			ld hl,os_cli_cmd 
1c1a				; tokenise the entered statement(s) in HL 
1c1a cd 35 23			call forthparse 
1c1d			        ; exec forth statements in top of return stack 
1c1d cd 75 23			call forthexec 
1c20				;call forthexec_cleanup 
1c20			;	call parsenext 
1c20			 
1c20				STACKFRAMECHK ON $fbfe $8f9f 
1c20				if DEBUG_STACK_IMB 
1c20					if ON 
1c20						exx 
1c20						ld hl, $8f9f 
1c20						pop de   ; $8f9f 
1c20						call cmp16 
1c20						jr nz, .spnosame 
1c20						ld hl, $fbfe 
1c20						pop de   ; $fbfe 
1c20						call cmp16 
1c20						jr z, .spfrsame 
1c20						.spnosame: call showsperror 
1c20						.spfrsame: nop 
1c20						exx 
1c20					endif 
1c20				endif 
1c20			endm 
# End of macro STACKFRAMECHK
1c20				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c20			 
1c20 3e 3c			ld a, display_row_4 
1c22 11 54 1c			ld de, endprog 
1c25			 
1c25 cd 38 0d			call update_display		 
1c28			 
1c28 cd b2 1e			call next_page_prompt 
1c2b			 
1c2b				; switch frame buffer to cli 
1c2b			 
1c2b 21 4a fe				ld hl, display_fb0 
1c2e 22 55 fd				ld (display_fb_active), hl 
1c31			 
1c31			 
1c31 cd 15 0d		        call clear_display 
1c34 cd 38 0d			call update_display		 
1c37			 
1c37 21 75 f6			ld hl, os_cli_cmd 
1c3a			 
1c3a 3e 00			ld a, 0		 ; init cli input 
1c3c 77				ld (hl), a 
1c3d			 
1c3d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c3d			 
1c3d				; now on last line 
1c3d			 
1c3d				; TODO scroll screen up 
1c3d			 
1c3d				; TODO instead just clear screen and place at top of screen 
1c3d			 
1c3d			;	ld a, 0 
1c3d			;	ld (f_cursor_ptr),a 
1c3d			 
1c3d				;call clear_display 
1c3d				;call update_display 
1c3d			 
1c3d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c3d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c3f c3 fa 1b			jp cli 
1c42			 
1c42 .. 00		freeram: db "Free bytes: $",0 
1c50 ..			asc: db "1A2F" 
1c54 .. 00		endprog: db "End prog...",0 
1c60			 
1c60			testenter2:   
1c60 21 80 f3			ld hl,scratch+50 
1c63 22 71 f6			ld (os_cur_ptr),hl 
1c66 c3 fa 1b			jp cli 
1c69			 
1c69			testenter:  
1c69			 
1c69 21 50 1c			ld hl,asc 
1c6c			;	ld a,(hl) 
1c6c			;	call nibble2val 
1c6c cd a0 12			call get_byte 
1c6f			 
1c6f			 
1c6f			;	ld a,(hl) 
1c6f			;	call atohex 
1c6f			 
1c6f			;	call fourehexhl 
1c6f 32 80 f3			ld (scratch+50),a 
1c72			 
1c72			 
1c72			 
1c72 21 52 1c			ld hl,asc+2 
1c75			;	ld a, (hl) 
1c75			;	call nibble2val 
1c75 cd a0 12			call get_byte 
1c78			 
1c78			;	call fourehexhl 
1c78 32 82 f3			ld (scratch+52),a 
1c7b				 
1c7b 21 80 f3			ld hl,scratch+50 
1c7e 22 71 f6			ld (os_cur_ptr),hl 
1c81 c3 fa 1b			jp cli 
1c84			 
1c84			enter:	 
1c84 3a 52 f3			ld a,(scratch+4) 
1c87 fe 00			cp 0 
1c89 28 0c			jr z, .entercont 
1c8b				; no, not a null term line so has an address to work out.... 
1c8b			 
1c8b 21 50 f3			ld hl,scratch+2 
1c8e cd 00 13			call get_word_hl 
1c91			 
1c91 22 71 f6			ld (os_cur_ptr),hl	 
1c94 c3 fa 1b			jp cli 
1c97			 
1c97			 
1c97			.entercont:  
1c97			 
1c97 21 50 f3			ld hl, scratch+2 
1c9a cd a0 12			call get_byte 
1c9d			 
1c9d 2a 71 f6		   	ld hl,(os_cur_ptr) 
1ca0 77					ld (hl),a 
1ca1 23					inc hl 
1ca2 22 71 f6				ld (os_cur_ptr),hl 
1ca5				 
1ca5			; get byte  
1ca5			 
1ca5			 
1ca5 c3 fa 1b			jp cli 
1ca8			 
1ca8			 
1ca8			; basic monitor support 
1ca8			 
1ca8			monitor: 
1ca8				;  
1ca8 cd 15 0d			call clear_display 
1cab 3e 00			ld a, 0 
1cad 11 f5 1c			ld de, .monprompt 
1cb0 cd 28 0d			call str_at_display 
1cb3 cd 38 0d			call update_display 
1cb6			 
1cb6				; get a monitor command 
1cb6			 
1cb6 0e 00			ld c, 0     ; entry at top left 
1cb8 16 64			ld d, 100   ; max buffer size 
1cba 1e 0f			ld e, 15    ; input scroll area 
1cbc 3e 00			ld a, 0     ; init string 
1cbe 21 4c f5			ld hl, os_input 
1cc1 77				ld (hl), a 
1cc2 23				inc hl 
1cc3 77				ld (hl), a 
1cc4 21 4c f5			ld hl, os_input 
1cc7 3e 01			ld a, 1     ; init string 
1cc9 cd 76 0f			call input_str 
1ccc			 
1ccc cd 15 0d		        call clear_display 
1ccf cd 38 0d			call update_display		 
1cd2			 
1cd2 3a 4c f5			ld a, (os_input) 
1cd5 cd 9e 13			call toUpper 
1cd8 fe 48		        cp 'H' 
1cda 28 6f		        jr z, .monhelp 
1cdc fe 44			cp 'D'		; dump 
1cde ca 6c 1d			jp z, .mondump	 
1ce1 fe 43			cp 'C'		; dump 
1ce3 ca 86 1d			jp z, .moncdump	 
1ce6 fe 4d			cp 'M'		; dump 
1ce8 ca f7 1c			jp z, .moneditstart 
1ceb fe 55			cp 'U'		; dump 
1ced 28 14			jr z, .monedit	 
1cef fe 51			cp 'Q'		; dump 
1cf1 c8				ret z	 
1cf2			 
1cf2			 
1cf2				; TODO "S" to access symbol by name and not need the address 
1cf2				; TODO "F" to find a string in memory 
1cf2			 
1cf2 c3 a8 1c			jp monitor 
1cf5			 
1cf5 .. 00		.monprompt: db ">", 0 
1cf7			 
1cf7			.moneditstart: 
1cf7				; get starting address 
1cf7			 
1cf7 21 4e f5			ld hl,os_input+2 
1cfa cd 00 13			call get_word_hl 
1cfd			 
1cfd 22 71 f6			ld (os_cur_ptr),hl	 
1d00			 
1d00 c3 a8 1c			jp monitor 
1d03			 
1d03			.monedit: 
1d03				; get byte to load 
1d03			 
1d03 21 4e f5			ld hl,os_input+2 
1d06 cd a0 12			call get_byte 
1d09			 
1d09				; get address to update 
1d09 2a 71 f6			ld hl, (os_cur_ptr) 
1d0c			 
1d0c				; update byte 
1d0c			 
1d0c 77				ld (hl), a 
1d0d			 
1d0d				; move to next address and save it 
1d0d			 
1d0d 23				inc hl 
1d0e 22 71 f6			ld (os_cur_ptr),hl	 
1d11			 
1d11 c3 a8 1c			jp monitor 
1d14			 
1d14			 
1d14 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d28 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d44 .. 00		.monhelptext3:  db "Q-Quit",0 
1d4b			        
1d4b			.monhelp: 
1d4b 3e 00			ld a, display_row_1 
1d4d 11 14 1d		        ld de, .monhelptext1 
1d50			 
1d50 cd 28 0d			call str_at_display 
1d53 3e 14			ld a, display_row_2 
1d55 11 28 1d		        ld de, .monhelptext2 
1d58					 
1d58 cd 28 0d			call str_at_display 
1d5b 3e 28			ld a, display_row_3 
1d5d 11 44 1d		        ld de, .monhelptext3 
1d60					 
1d60 cd 28 0d			call str_at_display 
1d63 cd 38 0d			call update_display		 
1d66			 
1d66 cd b2 1e			call next_page_prompt 
1d69 c3 a8 1c			jp monitor 
1d6c			 
1d6c			.mondump:    
1d6c 21 4e f5			ld hl,os_input+2 
1d6f cd 00 13			call get_word_hl 
1d72			 
1d72 22 71 f6			ld (os_cur_ptr),hl	 
1d75 cd ba 1d			call dumpcont 
1d78 3e 3c			ld a, display_row_4 
1d7a 11 54 1c			ld de, endprog 
1d7d			 
1d7d cd 38 0d			call update_display		 
1d80			 
1d80 cd b2 1e			call next_page_prompt 
1d83 c3 a8 1c			jp monitor 
1d86			.moncdump: 
1d86 cd ba 1d			call dumpcont 
1d89 3e 3c			ld a, display_row_4 
1d8b 11 54 1c			ld de, endprog 
1d8e			 
1d8e cd 38 0d			call update_display		 
1d91			 
1d91 cd b2 1e			call next_page_prompt 
1d94 c3 a8 1c			jp monitor 
1d97			 
1d97			 
1d97			; TODO symbol access  
1d97			 
1d97			.symbols:     ;; A list of symbols that can be called up  
1d97 4a fe			dw display_fb0 
1d99 .. 00			db "fb0",0  
1d9d 07 fc		     	dw store_page 
1d9f .. 00			db "store_page",0 
1daa			 
1daa			 
1daa			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1daa			 
1daa 3a 4f f3			ld a,(scratch+1) 
1dad fe 00			cp 0 
1daf 28 09			jr z, dumpcont 
1db1			 
1db1				; no, not a null term line so has an address to work out.... 
1db1			 
1db1 21 50 f3			ld hl,scratch+2 
1db4 cd 00 13			call get_word_hl 
1db7			 
1db7 22 71 f6			ld (os_cur_ptr),hl	 
1dba			 
1dba			 
1dba			 
1dba			dumpcont: 
1dba			 
1dba				; dump bytes at ptr 
1dba			 
1dba			 
1dba 3e 00			ld a, display_row_1 
1dbc 2a 55 fd			ld hl, (display_fb_active) 
1dbf cd 49 0f			call addatohl 
1dc2 cd ea 1d			call .dumpbyterow 
1dc5			 
1dc5 3e 14			ld a, display_row_2 
1dc7 2a 55 fd			ld hl, (display_fb_active) 
1dca cd 49 0f			call addatohl 
1dcd cd ea 1d			call .dumpbyterow 
1dd0			 
1dd0			 
1dd0 3e 28			ld a, display_row_3 
1dd2 2a 55 fd			ld hl, (display_fb_active) 
1dd5 cd 49 0f			call addatohl 
1dd8 cd ea 1d			call .dumpbyterow 
1ddb			 
1ddb 3e 3c			ld a, display_row_4 
1ddd 2a 55 fd			ld hl, (display_fb_active) 
1de0 cd 49 0f			call addatohl 
1de3 cd ea 1d			call .dumpbyterow 
1de6			 
1de6 cd 38 0d			call update_display 
1de9			;		jp cli 
1de9 c9				ret 
1dea			 
1dea			.dumpbyterow: 
1dea			 
1dea				;push af 
1dea			 
1dea e5				push hl 
1deb			 
1deb				; calc where to poke the ascii 
1deb			if display_cols == 20 
1deb 3e 10			ld a, 16 
1ded			else 
1ded				ld a, 31 
1ded			endif 
1ded			 
1ded cd 49 0f			call addatohl 
1df0 22 53 f6			ld (os_word_scratch),hl  		; save pos for later 
1df3			 
1df3			 
1df3			; display decoding address 
1df3 2a 71 f6		   	ld hl,(os_cur_ptr) 
1df6			 
1df6 7c				ld a,h 
1df7 e1				pop hl 
1df8 e5				push hl 
1df9			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1df9 cd 4a 12			call hexout 
1dfc 2a 71 f6		   	ld hl,(os_cur_ptr) 
1dff			 
1dff 7d				ld a,l 
1e00 e1				pop hl 
1e01 23				inc hl 
1e02 23				inc hl 
1e03 e5				push hl 
1e04			;	ld hl, os_word_scratch+2 
1e04 cd 4a 12			call hexout 
1e07 e1				pop hl 
1e08 23				inc hl 
1e09 23				inc hl 
1e0a				;ld hl, os_word_scratch+4 
1e0a 3e 3a			ld a, ':' 
1e0c 77				ld (hl),a 
1e0d 23				inc hl 
1e0e				;ld a, 0 
1e0e				;ld (hl),a 
1e0e				;ld de, os_word_scratch 
1e0e				;pop af 
1e0e				;push af 
1e0e			;		ld a, display_row_2 
1e0e			;		call str_at_display 
1e0e			;		call update_display 
1e0e			 
1e0e			 
1e0e			;pop af 
1e0e			;	add 5 
1e0e			 
1e0e			if display_cols == 20 
1e0e 06 04			ld b, 4 
1e10			else 
1e10				ld b, 8 
1e10			endif	 
1e10			 
1e10			.dumpbyte: 
1e10 c5				push bc 
1e11 e5				push hl 
1e12			 
1e12			 
1e12 2a 71 f6		   	ld hl,(os_cur_ptr) 
1e15 7e					ld a,(hl) 
1e16			 
1e16					; poke the ascii to display 
1e16 2a 53 f6				ld hl,(os_word_scratch) 
1e19 77					ld (hl),a 
1e1a 23					inc hl 
1e1b 22 53 f6				ld (os_word_scratch),hl 
1e1e			 
1e1e					 
1e1e			 
1e1e			 
1e1e e1					pop hl 
1e1f e5					push hl 
1e20			 
1e20 cd 4a 12				call hexout 
1e23			 
1e23					 
1e23 2a 71 f6		   	ld hl,(os_cur_ptr) 
1e26 23				inc hl 
1e27 22 71 f6		   	ld (os_cur_ptr),hl 
1e2a			 
1e2a e1					pop hl 
1e2b 23					inc hl 
1e2c 23					inc hl 
1e2d 23					inc hl 
1e2e			 
1e2e			 
1e2e			 
1e2e					;ld a,0 
1e2e					;ld (os_word_scratch+2),a 
1e2e					;pop af 
1e2e					;push af 
1e2e			 
1e2e					;ld de, os_word_scratch 
1e2e					;call str_at_display 
1e2e			;		call update_display 
1e2e			;		pop af 
1e2e c1					pop bc 
1e2f c6 03				add 3 
1e31 10 dd			djnz .dumpbyte 
1e33			 
1e33				 
1e33			 
1e33 c9				ret 
1e34			 
1e34			jump:	 
1e34			 
1e34 21 50 f3			ld hl,scratch+2 
1e37 cd 00 13			call get_word_hl 
1e3a				;ld hl,(scratch+2) 
1e3a				;call fourehexhl 
1e3a			 
1e3a 22 71 f6			ld (os_cur_ptr),hl	 
1e3d			 
1e3d e9				jp (hl) 
1e3e			 
1e3e			 
1e3e			 
1e3e			; TODO implement a basic monitor mode to start with 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			; testing and demo code during development 
1e3e			 
1e3e			 
1e3e .. 00		str1: db "Enter some text...",0 
1e51 .. 00		clear: db "                    ",0 
1e66			 
1e66			demo: 
1e66			 
1e66			 
1e66			 
1e66			;	call update_display 
1e66			 
1e66				; init scratch input area for testing 
1e66 21 4e f3			ld hl, scratch	 
1e69 3e 00			ld a,0 
1e6b 77				ld (hl),a 
1e6c			 
1e6c			 
1e6c 3e 14		            LD   A, display_row_2 
1e6e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e6e 11 3e 1e		            LD   DE, str1 
1e71 cd 28 0d			call str_at_display 
1e74			 
1e74			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e74			cloop:	 
1e74 3e 28		            LD   A, display_row_3 
1e76			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e76 11 51 1e		            LD   DE, clear 
1e79			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1e79 cd 28 0d				call str_at_display 
1e7c 3e 3c			ld a, display_row_4 
1e7e 11 ae 1e			ld de, prompt 
1e81			 
1e81 cd 28 0d				call str_at_display 
1e84 cd 38 0d			call update_display 
1e87			 
1e87 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1e89 16 0a			ld d, 10 
1e8b 21 4e f3			ld hl, scratch	 
1e8e cd 76 0f			call input_str 
1e91			 
1e91			;	call clear_display 
1e91			;'	call update_display 
1e91			 
1e91 3e 00		            LD   A, display_row_1 
1e93			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e93 11 51 1e		            LD   DE, clear 
1e96 cd 28 0d				call str_at_display 
1e99			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e99 3e 00		            LD   A, display_row_1 
1e9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e9b 11 4e f3		            LD   DE, scratch 
1e9e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e9e cd 28 0d				call str_at_display 
1ea1 cd 38 0d			call update_display 
1ea4			 
1ea4 3e 00				ld a,0 
1ea6 21 4e f3			ld hl, scratch 
1ea9 77				ld (hl),a 
1eaa			 
1eaa 00				nop 
1eab c3 74 1e			jp cloop 
1eae			 
1eae			 
1eae			 
1eae			; OS Prompt 
1eae			 
1eae .. 00		prompt: db ">",0 
1eb0 .. 00		endprg: db "?",0 
1eb2			 
1eb2			 
1eb2			; handy next page prompt 
1eb2			next_page_prompt: 
1eb2 e5				push hl 
1eb3 d5				push de 
1eb4 f5				push af 
1eb5 c5				push bc 
1eb6			 
1eb6 3e 4f			ld a,display_row_4 + display_cols - 1 
1eb8 11 b0 1e		        ld de, endprg 
1ebb cd 28 0d			call str_at_display 
1ebe cd 38 0d			call update_display 
1ec1 cd 5b 74			call cin_wait 
1ec4 c1				pop bc 
1ec5 f1				pop af 
1ec6 d1				pop de 
1ec7 e1				pop hl 
1ec8			 
1ec8			 
1ec8 c9				ret 
1ec9			 
1ec9			 
1ec9			; forth parser 
1ec9			 
1ec9			; My forth kernel 
1ec9			include "forth_kernel.asm" 
1ec9			; 
1ec9			; kernel to the forth OS 
1ec9			 
1ec9			DS_TYPE_STR: equ 1     ; string type 
1ec9			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ec9			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ec9			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ec9			 
1ec9			FORTH_PARSEV1: equ 0 
1ec9			FORTH_PARSEV2: equ 0 
1ec9			FORTH_PARSEV3: equ 0 
1ec9			FORTH_PARSEV4: equ 0 
1ec9			FORTH_PARSEV5: equ 1 
1ec9			 
1ec9			;if FORTH_PARSEV5 
1ec9			;	FORTH_END_BUFFER: equ 0 
1ec9			;else 
1ec9			FORTH_END_BUFFER: equ 127 
1ec9			;endif 
1ec9			 
1ec9			FORTH_TRUE: equ 1 
1ec9			FORTH_FALSE: equ 0 
1ec9			 
1ec9			if FORTH_PARSEV4 
1ec9			include "forth_stackops.asm" 
1ec9			endif 
1ec9			 
1ec9			if FORTH_PARSEV5 
1ec9			include "forth_stackopsv5.asm" 
1ec9			 
1ec9			; Stack operations for v5 parser on wards 
1ec9			; * DATA stack 
1ec9			; * LOOP stack 
1ec9			; * RETURN stack 
1ec9			 
1ec9			 
1ec9			 
1ec9			FORTH_CHK_DSP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_data_sp) 
1ec9				ld de, cli_data_stack 
1ec9				call cmp16 
1ec9				jp c, fault_dsp_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			FORTH_CHK_RSP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_ret_sp) 
1ec9				ld de, cli_ret_stack 
1ec9				call cmp16 
1ec9				jp c, fault_rsp_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			FORTH_CHK_LOOP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_loop_sp) 
1ec9				ld de, cli_loop_stack 
1ec9				call cmp16 
1ec9				jp c, fault_loop_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			FORTH_ERR_TOS_NOTSTR: macro 
1ec9				; TOSO might need more for checks when used 
1ec9				push af 
1ec9				ld a,(hl) 
1ec9				cp DS_TYPE_STR 
1ec9				jp nz, type_faultn   
1ec9				pop af 
1ec9				endm 
1ec9			 
1ec9			FORTH_ERR_TOS_NOTNUM: macro 
1ec9				push af 
1ec9				ld a,(hl) 
1ec9				cp DS_TYPE_INUM 
1ec9				jp nz, type_faultn   
1ec9				pop af 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			; increase data stack pointer and save hl to it 
1ec9				 
1ec9			FORTH_DSP_NEXT: macro 
1ec9				call macro_forth_dsp_next 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			macro_forth_dsp_next: 
1ec9				if DEBUG_FORTH_STACK_GUARD 
1ec9 cd 76 6f				call check_stacks 
1ecc				endif 
1ecc e5				push hl 
1ecd d5				push de 
1ece eb				ex de,hl 
1ecf 2a 7b fb			ld hl,(cli_data_sp) 
1ed2 23				inc hl 
1ed3 23				inc hl 
1ed4			 
1ed4			; PARSEV5 
1ed4 23				inc hl 
1ed5 22 7b fb			ld (cli_data_sp),hl 
1ed8 73				ld (hl), e 
1ed9 23				inc hl 
1eda 72				ld (hl), d 
1edb d1				pop de 
1edc e1				pop hl 
1edd				if DEBUG_FORTH_STACK_GUARD 
1edd cd 76 6f				call check_stacks 
1ee0				endif 
1ee0 c9				ret 
1ee1			 
1ee1			 
1ee1			; increase ret stack pointer and save hl to it 
1ee1				 
1ee1			FORTH_RSP_NEXT: macro 
1ee1				call macro_forth_rsp_next 
1ee1				endm 
1ee1			 
1ee1			macro_forth_rsp_next: 
1ee1				if DEBUG_FORTH_STACK_GUARD 
1ee1 cd 76 6f				call check_stacks 
1ee4				endif 
1ee4 e5				push hl 
1ee5 d5				push de 
1ee6 eb				ex de,hl 
1ee7 2a 7f fb			ld hl,(cli_ret_sp) 
1eea 23				inc hl 
1eeb 23				inc hl 
1eec 22 7f fb			ld (cli_ret_sp),hl 
1eef 73				ld (hl), e 
1ef0 23				inc hl 
1ef1 72				ld (hl), d 
1ef2 d1				pop de 
1ef3 e1				pop hl 
1ef4				if DEBUG_FORTH_STACK_GUARD 
1ef4 cd 76 6f				call check_stacks 
1ef7				endif 
1ef7 c9				ret 
1ef8			 
1ef8			; get current ret stack pointer and save to hl  
1ef8				 
1ef8			FORTH_RSP_TOS: macro 
1ef8				call macro_forth_rsp_tos 
1ef8				endm 
1ef8			 
1ef8			macro_forth_rsp_tos: 
1ef8				;push de 
1ef8 2a 7f fb			ld hl,(cli_ret_sp) 
1efb cd 33 1f			call loadhlptrtohl 
1efe				;ld e, (hl) 
1efe				;inc hl 
1efe				;ld d, (hl) 
1efe				;ex de, hl 
1efe					if DEBUG_FORTH_WORDS 
1efe			;			DMARK "RST" 
1efe						CALLMONITOR 
1efe cd c6 18			call break_point_state  
1f01				endm  
# End of macro CALLMONITOR
1f01					endif 
1f01				;pop de 
1f01 c9				ret 
1f02			 
1f02			; pop ret stack pointer 
1f02				 
1f02			FORTH_RSP_POP: macro 
1f02				call macro_forth_rsp_pop 
1f02				endm 
1f02			 
1f02			 
1f02			macro_forth_rsp_pop: 
1f02				if DEBUG_FORTH_STACK_GUARD 
1f02			;		DMARK "RPP" 
1f02 cd 76 6f				call check_stacks 
1f05					FORTH_CHK_RSP_UNDER 
1f05 e5				push hl 
1f06 d5				push de 
1f07 2a 7f fb			ld hl,(cli_ret_sp) 
1f0a 11 39 fb			ld de, cli_ret_stack 
1f0d cd 67 0f			call cmp16 
1f10 da 8a 70			jp c, fault_rsp_under 
1f13 d1				pop de 
1f14 e1				pop hl 
1f15				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f15				endif 
1f15 e5				push hl 
1f16 2a 7f fb			ld hl,(cli_ret_sp) 
1f19			 
1f19			 
1f19				if FORTH_ENABLE_FREE 
1f19			 
1f19					; get pointer 
1f19			 
1f19					push de 
1f19					push hl 
1f19			 
1f19					ld e, (hl) 
1f19					inc hl 
1f19					ld d, (hl) 
1f19			 
1f19					ex de, hl 
1f19					call free 
1f19			 
1f19					pop hl 
1f19					pop de 
1f19			 
1f19			 
1f19				endif 
1f19			 
1f19			 
1f19 2b				dec hl 
1f1a 2b				dec hl 
1f1b 22 7f fb			ld (cli_ret_sp), hl 
1f1e				; do stack underflow checks 
1f1e e1				pop hl 
1f1f				if DEBUG_FORTH_STACK_GUARD 
1f1f cd 76 6f				call check_stacks 
1f22					FORTH_CHK_RSP_UNDER 
1f22 e5				push hl 
1f23 d5				push de 
1f24 2a 7f fb			ld hl,(cli_ret_sp) 
1f27 11 39 fb			ld de, cli_ret_stack 
1f2a cd 67 0f			call cmp16 
1f2d da 8a 70			jp c, fault_rsp_under 
1f30 d1				pop de 
1f31 e1				pop hl 
1f32				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f32				endif 
1f32 c9				ret 
1f33			 
1f33			 
1f33			 
1f33			; routine to load word pointed to by hl into hl 
1f33			 
1f33			loadhlptrtohl: 
1f33			 
1f33 d5				push de 
1f34 5e				ld e, (hl) 
1f35 23				inc hl 
1f36 56				ld d, (hl) 
1f37 eb				ex de, hl 
1f38 d1				pop de 
1f39			 
1f39 c9				ret 
1f3a			 
1f3a			 
1f3a			 
1f3a			 
1f3a			 
1f3a			; push a number held in HL onto the data stack 
1f3a			; entry point for pushing a value when already in hl used in function above 
1f3a			 
1f3a			forth_push_numhl: 
1f3a			 
1f3a e5				push hl    ; save value to push 
1f3b			 
1f3b			if DEBUG_FORTH_PUSH 
1f3b				; see if disabled 
1f3b			 
1f3b			 
1f3b f5				push af 
1f3c 3a 3f f3			ld a, (os_view_disable) 
1f3f fe 2a			cp '*' 
1f41 28 34			jr z, .pskip2 
1f43 e5				push hl 
1f44 e5			push hl 
1f45 cd 15 0d			call clear_display 
1f48 e1			pop hl 
1f49 7c				ld a,h 
1f4a 21 53 f6			ld hl, os_word_scratch 
1f4d cd 4a 12			call hexout 
1f50 e1				pop hl 
1f51 7d				ld a,l 
1f52 21 55 f6			ld hl, os_word_scratch+2 
1f55 cd 4a 12			call hexout 
1f58			 
1f58 21 57 f6			ld hl, os_word_scratch+4 
1f5b 3e 00			ld a,0 
1f5d 77				ld (hl),a 
1f5e 11 53 f6			ld de,os_word_scratch 
1f61 3e 14				ld a, display_row_2 
1f63 cd 28 0d				call str_at_display 
1f66 11 6b 5a			ld de, .push_num 
1f69 3e 00			ld a, display_row_1 
1f6b			 
1f6b cd 28 0d				call str_at_display 
1f6e			 
1f6e			 
1f6e cd 38 0d			call update_display 
1f71 cd 92 0c			call delay1s 
1f74 cd 92 0c			call delay1s 
1f77			.pskip2:  
1f77			 
1f77 f1				pop af 
1f78			endif	 
1f78			 
1f78			 
1f78				FORTH_DSP_NEXT 
1f78 cd c9 1e			call macro_forth_dsp_next 
1f7b				endm 
# End of macro FORTH_DSP_NEXT
1f7b			 
1f7b 2a 7b fb			ld hl, (cli_data_sp) 
1f7e			 
1f7e				; save item type 
1f7e 3e 02			ld a,  DS_TYPE_INUM 
1f80 77				ld (hl), a 
1f81 23				inc hl 
1f82			 
1f82				; get word off stack 
1f82 d1				pop de 
1f83 7b				ld a,e 
1f84 77				ld (hl), a 
1f85 23				inc hl 
1f86 7a				ld a,d 
1f87 77				ld (hl), a 
1f88			 
1f88			if DEBUG_FORTH_PUSH 
1f88 2b				dec hl 
1f89 2b				dec hl 
1f8a 2b				dec hl 
1f8b						DMARK "PH5" 
1f8b f5				push af  
1f8c 3a a0 1f			ld a, (.dmark)  
1f8f 32 b4 fe			ld (debug_mark),a  
1f92 3a a1 1f			ld a, (.dmark+1)  
1f95 32 b5 fe			ld (debug_mark+1),a  
1f98 3a a2 1f			ld a, (.dmark+2)  
1f9b 32 b6 fe			ld (debug_mark+2),a  
1f9e 18 03			jr .pastdmark  
1fa0 ..			.dmark: db "PH5"  
1fa3 f1			.pastdmark: pop af  
1fa4			endm  
# End of macro DMARK
1fa4				CALLMONITOR 
1fa4 cd c6 18			call break_point_state  
1fa7				endm  
# End of macro CALLMONITOR
1fa7			endif	 
1fa7			 
1fa7 c9				ret 
1fa8			 
1fa8			 
1fa8			; Push a string to stack pointed to by hl 
1fa8			 
1fa8			forth_push_str: 
1fa8			 
1fa8			if DEBUG_FORTH_PUSH 
1fa8						DMARK "PSQ" 
1fa8 f5				push af  
1fa9 3a bd 1f			ld a, (.dmark)  
1fac 32 b4 fe			ld (debug_mark),a  
1faf 3a be 1f			ld a, (.dmark+1)  
1fb2 32 b5 fe			ld (debug_mark+1),a  
1fb5 3a bf 1f			ld a, (.dmark+2)  
1fb8 32 b6 fe			ld (debug_mark+2),a  
1fbb 18 03			jr .pastdmark  
1fbd ..			.dmark: db "PSQ"  
1fc0 f1			.pastdmark: pop af  
1fc1			endm  
# End of macro DMARK
1fc1				CALLMONITOR 
1fc1 cd c6 18			call break_point_state  
1fc4				endm  
# End of macro CALLMONITOR
1fc4			endif	 
1fc4			    
1fc4 e5				push hl 
1fc5 e5				push hl 
1fc6			 
1fc6			;	ld a, 0   ; find end of string 
1fc6 cd a7 13			call strlenz 
1fc9			if DEBUG_FORTH_PUSH 
1fc9						DMARK "PQ2" 
1fc9 f5				push af  
1fca 3a de 1f			ld a, (.dmark)  
1fcd 32 b4 fe			ld (debug_mark),a  
1fd0 3a df 1f			ld a, (.dmark+1)  
1fd3 32 b5 fe			ld (debug_mark+1),a  
1fd6 3a e0 1f			ld a, (.dmark+2)  
1fd9 32 b6 fe			ld (debug_mark+2),a  
1fdc 18 03			jr .pastdmark  
1fde ..			.dmark: db "PQ2"  
1fe1 f1			.pastdmark: pop af  
1fe2			endm  
# End of macro DMARK
1fe2				CALLMONITOR 
1fe2 cd c6 18			call break_point_state  
1fe5				endm  
# End of macro CALLMONITOR
1fe5			endif	 
1fe5 eb				ex de, hl 
1fe6 e1				pop hl   ; get ptr to start of string 
1fe7			if DEBUG_FORTH_PUSH 
1fe7						DMARK "PQ3" 
1fe7 f5				push af  
1fe8 3a fc 1f			ld a, (.dmark)  
1feb 32 b4 fe			ld (debug_mark),a  
1fee 3a fd 1f			ld a, (.dmark+1)  
1ff1 32 b5 fe			ld (debug_mark+1),a  
1ff4 3a fe 1f			ld a, (.dmark+2)  
1ff7 32 b6 fe			ld (debug_mark+2),a  
1ffa 18 03			jr .pastdmark  
1ffc ..			.dmark: db "PQ3"  
1fff f1			.pastdmark: pop af  
2000			endm  
# End of macro DMARK
2000				CALLMONITOR 
2000 cd c6 18			call break_point_state  
2003				endm  
# End of macro CALLMONITOR
2003			endif	 
2003 19				add hl,de 
2004			if DEBUG_FORTH_PUSH 
2004						DMARK "PQE" 
2004 f5				push af  
2005 3a 19 20			ld a, (.dmark)  
2008 32 b4 fe			ld (debug_mark),a  
200b 3a 1a 20			ld a, (.dmark+1)  
200e 32 b5 fe			ld (debug_mark+1),a  
2011 3a 1b 20			ld a, (.dmark+2)  
2014 32 b6 fe			ld (debug_mark+2),a  
2017 18 03			jr .pastdmark  
2019 ..			.dmark: db "PQE"  
201c f1			.pastdmark: pop af  
201d			endm  
# End of macro DMARK
201d				CALLMONITOR 
201d cd c6 18			call break_point_state  
2020				endm  
# End of macro CALLMONITOR
2020			endif	 
2020			 
2020 2b				dec hl    ; see if there is an optional trailing double quote 
2021 7e				ld a,(hl) 
2022 fe 22			cp '"' 
2024 20 03			jr nz, .strnoq 
2026 3e 00			ld a, 0      ; get rid of double quote 
2028 77				ld (hl), a 
2029 23			.strnoq: inc hl 
202a			 
202a 3e 00			ld a, 0 
202c 77				ld (hl), a     ; add null term and get rid of trailing double quote 
202d			 
202d 13				inc de ; add one for the type string 
202e 13				inc de ; add one for null term??? 
202f			 
202f				; tos is get string pointer again 
202f				; de contains space to allocate 
202f				 
202f d5				push de 
2030			 
2030 eb				ex de, hl 
2031			 
2031				;push af 
2031			 
2031			if DEBUG_FORTH_PUSH 
2031						DMARK "PHm" 
2031 f5				push af  
2032 3a 46 20			ld a, (.dmark)  
2035 32 b4 fe			ld (debug_mark),a  
2038 3a 47 20			ld a, (.dmark+1)  
203b 32 b5 fe			ld (debug_mark+1),a  
203e 3a 48 20			ld a, (.dmark+2)  
2041 32 b6 fe			ld (debug_mark+2),a  
2044 18 03			jr .pastdmark  
2046 ..			.dmark: db "PHm"  
2049 f1			.pastdmark: pop af  
204a			endm  
# End of macro DMARK
204a				CALLMONITOR 
204a cd c6 18			call break_point_state  
204d				endm  
# End of macro CALLMONITOR
204d			endif	 
204d cd 10 14			call malloc	; on ret hl now contains allocated memory 
2050				if DEBUG_FORTH_MALLOC_GUARD 
2050 cc c3 5a				call z,malloc_error 
2053				endif 
2053			 
2053				 
2053 c1				pop bc    ; get length 
2054 d1				pop de   ;  get string start    
2055			 
2055				; hl has destination from malloc 
2055			 
2055 eb				ex de, hl    ; prep for ldir 
2056			 
2056 d5				push de   ; save malloc area for DSP later 
2057				;push hl   ; save malloc area for DSP later 
2057			 
2057			if DEBUG_FORTH_PUSH 
2057						DMARK "PHc" 
2057 f5				push af  
2058 3a 6c 20			ld a, (.dmark)  
205b 32 b4 fe			ld (debug_mark),a  
205e 3a 6d 20			ld a, (.dmark+1)  
2061 32 b5 fe			ld (debug_mark+1),a  
2064 3a 6e 20			ld a, (.dmark+2)  
2067 32 b6 fe			ld (debug_mark+2),a  
206a 18 03			jr .pastdmark  
206c ..			.dmark: db "PHc"  
206f f1			.pastdmark: pop af  
2070			endm  
# End of macro DMARK
2070				CALLMONITOR 
2070 cd c6 18			call break_point_state  
2073				endm  
# End of macro CALLMONITOR
2073			endif	 
2073			 
2073			 
2073 ed b0			ldir 
2075			 
2075			 
2075				; push malloc to data stack     macro?????  
2075			 
2075				FORTH_DSP_NEXT 
2075 cd c9 1e			call macro_forth_dsp_next 
2078				endm 
# End of macro FORTH_DSP_NEXT
2078			 
2078				; save value and type 
2078			 
2078 2a 7b fb			ld hl, (cli_data_sp) 
207b			 
207b				; save item type 
207b 3e 01			ld a,  DS_TYPE_STR 
207d 77				ld (hl), a 
207e 23				inc hl 
207f			 
207f				; get malloc word off stack 
207f d1				pop de 
2080 73				ld (hl), e 
2081 23				inc hl 
2082 72				ld (hl), d 
2083			 
2083			 
2083			 
2083			if DEBUG_FORTH_PUSH 
2083 2a 7b fb			ld hl, (cli_data_sp) 
2086						DMARK "PHS" 
2086 f5				push af  
2087 3a 9b 20			ld a, (.dmark)  
208a 32 b4 fe			ld (debug_mark),a  
208d 3a 9c 20			ld a, (.dmark+1)  
2090 32 b5 fe			ld (debug_mark+1),a  
2093 3a 9d 20			ld a, (.dmark+2)  
2096 32 b6 fe			ld (debug_mark+2),a  
2099 18 03			jr .pastdmark  
209b ..			.dmark: db "PHS"  
209e f1			.pastdmark: pop af  
209f			endm  
# End of macro DMARK
209f				CALLMONITOR 
209f cd c6 18			call break_point_state  
20a2				endm  
# End of macro CALLMONITOR
20a2			;	ex de,hl 
20a2			endif	 
20a2				; in case of spaces, skip the ptr past the copied string 
20a2				;pop af 
20a2				;ld (cli_origptr),hl 
20a2			 
20a2 c9				ret 
20a3			 
20a3			 
20a3			 
20a3			; TODO ascii push input onto stack given hl to start of input 
20a3			 
20a3			; identify type 
20a3			; if starts with a " then a string 
20a3			; otherwise it is a number 
20a3			;  
20a3			; if a string 
20a3			;     scan for ending " to get length of string to malloc for + 1 
20a3			;     malloc 
20a3			;     put pointer to string on stack first byte flags as string 
20a3			; 
20a3			; else a number 
20a3			;    look for number format identifier 
20a3			;    $xx hex 
20a3			;    %xxxxx bin 
20a3			;    xxxxx decimal 
20a3			;    convert number to 16bit word.  
20a3			;    malloc word + 1 with flag to identiy as num 
20a3			;    put pointer to number on stack 
20a3			;   
20a3			;  
20a3			  
20a3			forth_apush: 
20a3				; kernel push 
20a3			 
20a3			if DEBUG_FORTH_PUSH 
20a3						DMARK "PSH" 
20a3 f5				push af  
20a4 3a b8 20			ld a, (.dmark)  
20a7 32 b4 fe			ld (debug_mark),a  
20aa 3a b9 20			ld a, (.dmark+1)  
20ad 32 b5 fe			ld (debug_mark+1),a  
20b0 3a ba 20			ld a, (.dmark+2)  
20b3 32 b6 fe			ld (debug_mark+2),a  
20b6 18 03			jr .pastdmark  
20b8 ..			.dmark: db "PSH"  
20bb f1			.pastdmark: pop af  
20bc			endm  
# End of macro DMARK
20bc				CALLMONITOR 
20bc cd c6 18			call break_point_state  
20bf				endm  
# End of macro CALLMONITOR
20bf			endif	 
20bf				; identify input type 
20bf			 
20bf 7e				ld a,(hl) 
20c0 fe 22			cp '"' 
20c2 28 0a			jr z, .fapstr 
20c4 fe 24			cp '$' 
20c6 ca ee 20			jp z, .faphex 
20c9 fe 25			cp '%' 
20cb ca d6 20			jp z, .fapbin 
20ce			;	cp 'b' 
20ce			;	jp z, .fabin 
20ce				; else decimal 
20ce			 
20ce				; TODO do decimal conversion 
20ce				; decimal is stored as a 16bit word 
20ce			 
20ce				; by default everything is a string if type is not detected 
20ce			.fapstr: ; 
20ce fe 22			cp '"' 
20d0 20 01			jr nz, .strnoqu 
20d2 23				inc hl 
20d3			.strnoqu: 
20d3 c3 a8 1f			jp forth_push_str 
20d6			 
20d6			 
20d6			 
20d6			.fapbin:    ; push a binary string.  
20d6 11 00 00			ld de, 0   ; hold a 16bit value 
20d9			 
20d9 23			.fapbinshift:	inc hl  
20da 7e				ld a,(hl) 
20db fe 00			cp 0     ; done scanning  
20dd 28 0b			jr z, .fapbdone  	; got it in HL so push  
20df			 
20df				; left shift de 
20df eb				ex de, hl	 
20e0 29				add hl, hl 
20e1			 
20e1				; is 1 
20e1 fe 31			cp '1' 
20e3 20 02			jr nz, .binzero 
20e5 cb 4d			bit 1, l 
20e7			.binzero: 
20e7 eb				ex de, hl	 ; save current de 
20e8 18 ef			jr .fapbinshift 
20ea			 
20ea			.fapbdone: 
20ea eb				ex de, hl 
20eb c3 3a 1f			jp forth_push_numhl 
20ee			 
20ee			 
20ee			.faphex:   ; hex is always stored as a 16bit word 
20ee				; skip number prefix 
20ee 23				inc hl 
20ef				; turn ascii into number 
20ef cd 00 13			call get_word_hl	; ret 16bit word in hl 
20f2			 
20f2 c3 3a 1f			jp forth_push_numhl 
20f5			 
20f5 00				 nop 
20f6			 
20f6			.fabin:   ; TODO bin conversion 
20f6			 
20f6			 
20f6 c9				ret 
20f7			 
20f7			 
20f7			; get either a string ptr or a 16bit word from the data stack 
20f7			 
20f7			FORTH_DSP: macro 
20f7				call macro_forth_dsp 
20f7				endm 
20f7			 
20f7			macro_forth_dsp: 
20f7				; data stack pointer points to current word on tos 
20f7			 
20f7 2a 7b fb			ld hl,(cli_data_sp) 
20fa			 
20fa				if DEBUG_FORTH_PUSH 
20fa						DMARK "DSP" 
20fa f5				push af  
20fb 3a 0f 21			ld a, (.dmark)  
20fe 32 b4 fe			ld (debug_mark),a  
2101 3a 10 21			ld a, (.dmark+1)  
2104 32 b5 fe			ld (debug_mark+1),a  
2107 3a 11 21			ld a, (.dmark+2)  
210a 32 b6 fe			ld (debug_mark+2),a  
210d 18 03			jr .pastdmark  
210f ..			.dmark: db "DSP"  
2112 f1			.pastdmark: pop af  
2113			endm  
# End of macro DMARK
2113			 
2113 cd f8 5a				call display_data_sp 
2116				;call break_point_state 
2116				;rst 030h 
2116				CALLMONITOR 
2116 cd c6 18			call break_point_state  
2119				endm  
# End of macro CALLMONITOR
2119				endif 
2119			 
2119 c9				ret 
211a			 
211a			; return hl to start of value on stack 
211a			 
211a			FORTH_DSP_VALUE: macro 
211a				call macro_forth_dsp_value 
211a				endm 
211a			 
211a			macro_forth_dsp_value: 
211a			 
211a				FORTH_DSP 
211a cd f7 20			call macro_forth_dsp 
211d				endm 
# End of macro FORTH_DSP
211d			 
211d d5				push de 
211e			 
211e 23				inc hl ; skip type 
211f			 
211f 5e				ld e, (hl) 
2120 23				inc hl 
2121 56				ld d, (hl) 
2122 eb				ex de,hl  
2123			 
2123 d1				pop de 
2124			 
2124 c9				ret 
2125			 
2125			; return hl to start of value to second item on stack 
2125			 
2125			FORTH_DSP_VALUEM1: macro 
2125				call macro_forth_dsp_value_m1 
2125				endm 
2125			 
2125			macro_forth_dsp_value_m1: 
2125			 
2125				FORTH_DSP 
2125 cd f7 20			call macro_forth_dsp 
2128				endm 
# End of macro FORTH_DSP
2128			 
2128 2b				dec hl 
2129 2b				dec hl 
212a			;	dec hl 
212a			 
212a d5				push de 
212b			 
212b 5e				ld e, (hl) 
212c 23				inc hl 
212d 56				ld d, (hl) 
212e eb				ex de,hl  
212f			 
212f d1				pop de 
2130			 
2130 c9				ret 
2131			 
2131				 
2131			 
2131			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2131			 
2131			FORTH_DSP_POP: macro 
2131				call macro_forth_dsp_pop 
2131				endm 
2131			 
2131			 
2131			; get the tos data type 
2131			 
2131			FORTH_DSP_TYPE:   macro 
2131			 
2131				;FORTH_DSP_VALUE 
2131				FORTH_DSP 
2131				 
2131				; hl points to value 
2131				; check type 
2131			 
2131				ld a,(hl) 
2131			 
2131				endm 
2131			 
2131			; load the tos value into hl 
2131			 
2131			 
2131			FORTH_DSP_VALUEHL:  macro 
2131				call macro_dsp_valuehl 
2131				endm 
2131			 
2131			 
2131			 
2131			macro_dsp_valuehl: 
2131				FORTH_DSP_VALUE 
2131 cd 1a 21			call macro_forth_dsp_value 
2134				endm 
# End of macro FORTH_DSP_VALUE
2134			 
2134				;FORTH_ERR_TOS_NOTNUM 
2134			 
2134				;inc hl   ; skip type id 
2134			 
2134			;	push de 
2134			; 
2134			;	ld e, (hl) 
2134			;	inc hl 
2134			;	ld d, (hl) 
2134			;	ex de,hl  
2134			 
2134			;	pop de 
2134			 
2134				if DEBUG_FORTH_PUSH 
2134						DMARK "DVL" 
2134 f5				push af  
2135 3a 49 21			ld a, (.dmark)  
2138 32 b4 fe			ld (debug_mark),a  
213b 3a 4a 21			ld a, (.dmark+1)  
213e 32 b5 fe			ld (debug_mark+1),a  
2141 3a 4b 21			ld a, (.dmark+2)  
2144 32 b6 fe			ld (debug_mark+2),a  
2147 18 03			jr .pastdmark  
2149 ..			.dmark: db "DVL"  
214c f1			.pastdmark: pop af  
214d			endm  
# End of macro DMARK
214d				CALLMONITOR 
214d cd c6 18			call break_point_state  
2150				endm  
# End of macro CALLMONITOR
2150				endif 
2150 c9				ret 
2151			 
2151			forth_apushstrhl:      
2151				; push of string requires use of cli_origptr 
2151				; bodge use 
2151			 
2151				; get current cli_origptr, save, update with temp pointer  
2151 ed 5b cb fb		ld de, (cli_origptr) 
2155 22 cb fb			ld (cli_origptr), hl 
2158 d5				push de 
2159 cd a3 20			call forth_apush 
215c d1				pop de 
215d ed 53 cb fb		ld (cli_origptr), de 
2161 c9			        ret	 
2162			 
2162			 
2162			; increase loop stack pointer and save hl to it 
2162				 
2162			FORTH_LOOP_NEXT: macro 
2162				call macro_forth_loop_next 
2162				;nop 
2162				endm 
2162			 
2162			macro_forth_loop_next: 
2162				if DEBUG_FORTH_STACK_GUARD 
2162 cd 76 6f				call check_stacks 
2165				endif 
2165 e5				push hl 
2166 d5				push de 
2167 eb				ex de,hl 
2168 2a 7d fb			ld hl,(cli_loop_sp) 
216b 23				inc hl 
216c 23				inc hl 
216d					if DEBUG_FORTH_WORDS 
216d						DMARK "LNX" 
216d f5				push af  
216e 3a 82 21			ld a, (.dmark)  
2171 32 b4 fe			ld (debug_mark),a  
2174 3a 83 21			ld a, (.dmark+1)  
2177 32 b5 fe			ld (debug_mark+1),a  
217a 3a 84 21			ld a, (.dmark+2)  
217d 32 b6 fe			ld (debug_mark+2),a  
2180 18 03			jr .pastdmark  
2182 ..			.dmark: db "LNX"  
2185 f1			.pastdmark: pop af  
2186			endm  
# End of macro DMARK
2186						CALLMONITOR 
2186 cd c6 18			call break_point_state  
2189				endm  
# End of macro CALLMONITOR
2189					endif 
2189 22 7d fb			ld (cli_loop_sp),hl 
218c 73				ld (hl), e 
218d 23				inc hl 
218e 72				ld (hl), d 
218f d1				pop de    ; been reversed so save a swap on restore 
2190 e1				pop hl 
2191				if DEBUG_FORTH_STACK_GUARD 
2191 cd 76 6f				call check_stacks 
2194				endif 
2194 c9				ret 
2195			 
2195			; get current ret stack pointer and save to hl  
2195				 
2195			FORTH_LOOP_TOS: macro 
2195				call macro_forth_loop_tos 
2195				endm 
2195			 
2195			macro_forth_loop_tos: 
2195 d5				push de 
2196 2a 7d fb			ld hl,(cli_loop_sp) 
2199 5e				ld e, (hl) 
219a 23				inc hl 
219b 56				ld d, (hl) 
219c eb				ex de, hl 
219d d1				pop de 
219e c9				ret 
219f			 
219f			; pop loop stack pointer 
219f				 
219f			FORTH_LOOP_POP: macro 
219f				call macro_forth_loop_pop 
219f				endm 
219f			 
219f			 
219f			macro_forth_loop_pop: 
219f				if DEBUG_FORTH_STACK_GUARD 
219f					DMARK "LPP" 
219f f5				push af  
21a0 3a b4 21			ld a, (.dmark)  
21a3 32 b4 fe			ld (debug_mark),a  
21a6 3a b5 21			ld a, (.dmark+1)  
21a9 32 b5 fe			ld (debug_mark+1),a  
21ac 3a b6 21			ld a, (.dmark+2)  
21af 32 b6 fe			ld (debug_mark+2),a  
21b2 18 03			jr .pastdmark  
21b4 ..			.dmark: db "LPP"  
21b7 f1			.pastdmark: pop af  
21b8			endm  
# End of macro DMARK
21b8 cd 76 6f				call check_stacks 
21bb					FORTH_CHK_LOOP_UNDER 
21bb e5				push hl 
21bc d5				push de 
21bd 2a 7d fb			ld hl,(cli_loop_sp) 
21c0 11 b7 fa			ld de, cli_loop_stack 
21c3 cd 67 0f			call cmp16 
21c6 da 90 70			jp c, fault_loop_under 
21c9 d1				pop de 
21ca e1				pop hl 
21cb				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21cb				endif 
21cb e5				push hl 
21cc 2a 7d fb			ld hl,(cli_loop_sp) 
21cf 2b				dec hl 
21d0 2b				dec hl 
21d1 22 7d fb			ld (cli_loop_sp), hl 
21d4				; TODO do stack underflow checks 
21d4 e1				pop hl 
21d5				if DEBUG_FORTH_STACK_GUARD 
21d5 cd 76 6f				call check_stacks 
21d8					FORTH_CHK_LOOP_UNDER 
21d8 e5				push hl 
21d9 d5				push de 
21da 2a 7d fb			ld hl,(cli_loop_sp) 
21dd 11 b7 fa			ld de, cli_loop_stack 
21e0 cd 67 0f			call cmp16 
21e3 da 90 70			jp c, fault_loop_under 
21e6 d1				pop de 
21e7 e1				pop hl 
21e8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21e8				endif 
21e8 c9				ret 
21e9			 
21e9			macro_forth_dsp_pop: 
21e9			 
21e9 e5				push hl 
21ea			 
21ea				; release malloc data 
21ea			 
21ea				if DEBUG_FORTH_STACK_GUARD 
21ea cd 76 6f				call check_stacks 
21ed					FORTH_CHK_DSP_UNDER 
21ed e5				push hl 
21ee d5				push de 
21ef 2a 7b fb			ld hl,(cli_data_sp) 
21f2 11 b5 f8			ld de, cli_data_stack 
21f5 cd 67 0f			call cmp16 
21f8 da 84 70			jp c, fault_dsp_under 
21fb d1				pop de 
21fc e1				pop hl 
21fd				endm 
# End of macro FORTH_CHK_DSP_UNDER
21fd				endif 
21fd				;ld hl,(cli_data_sp) 
21fd			if DEBUG_FORTH_DOT 
21fd				DMARK "DPP" 
21fd f5				push af  
21fe 3a 12 22			ld a, (.dmark)  
2201 32 b4 fe			ld (debug_mark),a  
2204 3a 13 22			ld a, (.dmark+1)  
2207 32 b5 fe			ld (debug_mark+1),a  
220a 3a 14 22			ld a, (.dmark+2)  
220d 32 b6 fe			ld (debug_mark+2),a  
2210 18 03			jr .pastdmark  
2212 ..			.dmark: db "DPP"  
2215 f1			.pastdmark: pop af  
2216			endm  
# End of macro DMARK
2216				CALLMONITOR 
2216 cd c6 18			call break_point_state  
2219				endm  
# End of macro CALLMONITOR
2219			endif	 
2219			 
2219			 
2219			if FORTH_ENABLE_DSPPOPFREE 
2219			 
2219				FORTH_DSP 
2219 cd f7 20			call macro_forth_dsp 
221c				endm 
# End of macro FORTH_DSP
221c			 
221c 7e				ld a, (hl) 
221d fe 01			cp DS_TYPE_STR 
221f 20 23			jr nz, .skippopfree 
2221			 
2221				FORTH_DSP_VALUEHL 
2221 cd 31 21			call macro_dsp_valuehl 
2224				endm 
# End of macro FORTH_DSP_VALUEHL
2224 00				nop 
2225			if DEBUG_FORTH_DOT 
2225				DMARK "DPf" 
2225 f5				push af  
2226 3a 3a 22			ld a, (.dmark)  
2229 32 b4 fe			ld (debug_mark),a  
222c 3a 3b 22			ld a, (.dmark+1)  
222f 32 b5 fe			ld (debug_mark+1),a  
2232 3a 3c 22			ld a, (.dmark+2)  
2235 32 b6 fe			ld (debug_mark+2),a  
2238 18 03			jr .pastdmark  
223a ..			.dmark: db "DPf"  
223d f1			.pastdmark: pop af  
223e			endm  
# End of macro DMARK
223e				CALLMONITOR 
223e cd c6 18			call break_point_state  
2241				endm  
# End of macro CALLMONITOR
2241			endif	 
2241 cd da 14			call free 
2244			.skippopfree: 
2244				 
2244			 
2244			endif 
2244			 
2244			if DEBUG_FORTH_DOT_KEY 
2244				DMARK "DP2" 
2244				CALLMONITOR 
2244			endif	 
2244			 
2244				; move pointer down 
2244			 
2244 2a 7b fb			ld hl,(cli_data_sp) 
2247 2b				dec hl 
2248 2b				dec hl 
2249			; PARSEV5 
2249 2b				dec hl 
224a 22 7b fb			ld (cli_data_sp), hl 
224d			 
224d				if DEBUG_FORTH_STACK_GUARD 
224d cd 76 6f				call check_stacks 
2250					FORTH_CHK_DSP_UNDER 
2250 e5				push hl 
2251 d5				push de 
2252 2a 7b fb			ld hl,(cli_data_sp) 
2255 11 b5 f8			ld de, cli_data_stack 
2258 cd 67 0f			call cmp16 
225b da 84 70			jp c, fault_dsp_under 
225e d1				pop de 
225f e1				pop hl 
2260				endm 
# End of macro FORTH_CHK_DSP_UNDER
2260				endif 
2260			 
2260 e1				pop hl 
2261			 
2261 c9				ret 
2262			 
2262			getwordathl: 
2262				; hl points to an address 
2262				; load hl with the word at that address 
2262			 
2262 d5				push de 
2263			 
2263 5e				ld e, (hl) 
2264 23				inc hl 
2265 56				ld d, (hl) 
2266 eb				ex de, hl 
2267			 
2267 d1				pop de 
2268 c9				ret 
2269			 
2269			 
2269			 
2269			 
2269			 
2269			; eof 
2269			 
# End of file forth_stackopsv5.asm
2269			endif 
2269			 
2269			loadwordinhl:	 
2269			 
2269 d5				push de 
226a			 
226a 5e				ld e, (hl) 
226b 23				inc hl 
226c 56				ld d, (hl) 
226d eb				ex de,hl  
226e			 
226e d1				pop de 
226f			 
226f c9				ret 
2270			 
2270			user_word_eol:  
2270				; hl contains the pointer to where to create a linked list item from the end 
2270				; of the user dict to continue on at the system word dict 
2270				 
2270				; poke the stub of the word list linked list to repoint to rom words 
2270			 
2270				; stub format 
2270				; db   word id 
2270				; dw    link to next word 
2270			        ; db char length of token 
2270				; db string + 0 term 
2270				; db exec code....  
2270			 
2270 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2272 77				ld (hl), a		; word id 
2273 23				inc hl 
2274			 
2274 11 3f 24			ld de, sysdict 
2277 73				ld (hl), e		; next word link ie system dict 
2278 23				inc hl 
2279 72				ld (hl), d		; next word link ie system dict 
227a 23				inc hl	 
227b			 
227b			;	ld (hl), sysdict		; next word link ie system dict 
227b			;	inc hl 
227b			;	inc hl 
227b			 
227b			;	inc hl 
227b			;	inc hl 
227b			 
227b 3e 02			ld a, 2			; word length is 0 
227d 77				ld (hl), a	 
227e 23				inc hl 
227f			 
227f 3e 7e			ld a, '~'			; word length is 0 
2281 77				ld (hl), a	 
2282 23				inc hl 
2283 3e 00			ld a, 0			; save empty word 
2285 77				ld (hl), a 
2286			 
2286 c9				ret 
2287			 
2287				 
2287			 
2287			forthexec_cleanup: 
2287				FORTH_RSP_POP 
2287 cd 02 1f			call macro_forth_rsp_pop 
228a				endm 
# End of macro FORTH_RSP_POP
228a c9				ret 
228b			 
228b			forth_call_hl: 
228b				; taking hl 
228b e5				push hl 
228c c9				ret 
228d			 
228d			; this is called to reset Forth system but keep existing uwords etc 
228d			 
228d			forth_warmstart: 
228d				; setup stack over/under flow checks 
228d				if DEBUG_FORTH_STACK_GUARD 
228d cd 5c 6f				call chk_stk_init 
2290				endif 
2290			 
2290				; init stack pointers  - * these stacks go upwards *  
2290 21 39 fb			ld hl, cli_ret_stack 
2293 22 7f fb			ld (cli_ret_sp), hl	 
2296				; set bottom of stack 
2296 3e 00			ld a,0 
2298 77				ld (hl),a 
2299 23				inc hl 
229a 77				ld (hl),a 
229b			 
229b 21 b5 f8			ld hl, cli_data_stack 
229e 22 7b fb			ld (cli_data_sp), hl	 
22a1				; set bottom of stack 
22a1 3e 00			ld a,0 
22a3 77				ld (hl),a 
22a4 23				inc hl 
22a5 77				ld (hl),a 
22a6			 
22a6 21 b7 fa			ld hl, cli_loop_stack 
22a9 22 7d fb			ld (cli_loop_sp), hl	 
22ac				; set bottom of stack 
22ac 3e 00			ld a,0 
22ae 77				ld (hl),a 
22af 23				inc hl 
22b0 77				ld (hl),a 
22b1			 
22b1				; init extent of current open file 
22b1			 
22b1 3e 00			ld a, 0 
22b3 32 f7 fb			ld (store_openext), a 
22b6			 
22b6 c9				ret 
22b7			 
22b7			 
22b7			; Cold Start - this is called to setup the whole Forth system 
22b7			 
22b7			forth_init: 
22b7			 
22b7				; setup stack over/under flow checks 
22b7			 
22b7			;	if DEBUG_FORTH_STACK_GUARD 
22b7			;		call chk_stk_init 
22b7			;	endif 
22b7			 
22b7				; enable auto display updates (slow.....) 
22b7			 
22b7 3e 01			ld a, 1 
22b9 32 c9 fb			ld (cli_autodisplay), a 
22bc			 
22bc				; if storage is in use disable long reads for now 
22bc 3e 00			ld a, 0 
22be 32 02 fc			ld (store_longread), a 
22c1			 
22c1			 
22c1				; show start up screen 
22c1			 
22c1 cd 15 0d			call clear_display 
22c4			 
22c4 3e 00			ld a,0 
22c6 32 eb fb			ld (f_cursor_ptr), a 
22c9			 
22c9				; set start of word list in start of ram - for use when creating user words 
22c9			 
22c9 21 00 80			ld hl, baseram 
22cc 22 4b f6			ld (os_last_new_uword), hl 
22cf cd 70 22			call user_word_eol 
22d2				 
22d2			;		call display_data_sp 
22d2			;		call next_page_prompt 
22d2			 
22d2			 
22d2			 
22d2			 
22d2 c9				ret 
22d3			 
22d3 .. 00		.bootforth: db " Forth Kernel Init ",0 
22e7			 
22e7			; TODO push to stack 
22e7			 
22e7			;  
22e7			 
22e7			if FORTH_PARSEV2 
22e7			 
22e7			 
22e7				include "forth_parserv2.asm" 
22e7			 
22e7			endif 
22e7			 
22e7			 
22e7			; parse cli version 1 
22e7			 
22e7			if FORTH_PARSEV1 
22e7			 
22e7			 
22e7			 
22e7			      include "forth_parserv1.asm" 
22e7			endif 
22e7				 
22e7			if FORTH_PARSEV3 
22e7			 
22e7			 
22e7			 
22e7			      include "forth_parserv3.asm" 
22e7				include "forth_wordsv3.asm" 
22e7			endif 
22e7			 
22e7			if FORTH_PARSEV4 
22e7			 
22e7			 
22e7			 
22e7			      include "forth_parserv4.asm" 
22e7				include "forth_wordsv4.asm" 
22e7			endif 
22e7			 
22e7			if FORTH_PARSEV5 
22e7			 
22e7			 
22e7			 
22e7			      include "forth_parserv5.asm" 
22e7			 
22e7			 
22e7			; A better parser without using malloc and string copies all over the place.  
22e7			; Exec in situ should be faster 
22e7			 
22e7			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
22e7			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
22e7			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
22e7			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
22e7			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
22e7			WORD_SYS_END: equ 0   ; Opcode for all user words 
22e7			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
22e7			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
22e7			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
22e7			 
22e7			; Core word preamble macro 
22e7			 
22e7			CWHEAD:   macro nxtword opcode lit len opflags 
22e7				db WORD_SYS_CORE+opcode             
22e7				; internal op code number 
22e7				dw nxtword            
22e7				; link to next dict word block 
22e7				db len + 1 
22e7				; literal length of dict word inc zero term 
22e7				db lit,0              
22e7				; literal dict word 
22e7			        ; TODO db opflags        
22e7				endm 
22e7			 
22e7			 
22e7			NEXTW: macro  
22e7				jp macro_next 
22e7				endm 
22e7			 
22e7			macro_next: 
22e7			if DEBUG_FORTH_PARSE_KEY 
22e7				DMARK "NXT" 
22e7				CALLMONITOR 
22e7			endif	 
22e7			;	inc hl  ; skip token null term  
22e7 ed 4b cd fb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
22eb ed 5b cb fb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
22ef 2a 4f f6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
22f2			if DEBUG_FORTH_PARSE_KEY 
22f2				DMARK "}AA" 
22f2				CALLMONITOR 
22f2			endif	 
22f2 c3 f5 23			jp execnext 
22f5				;jp exec1 
22f5			       
22f5			 
22f5			 
22f5			; Another go at the parser to compile  
22f5			 
22f5			 
22f5			; TODO rework parser to change all of the string words to byte tokens 
22f5			; TODO do a search for  
22f5			 
22f5			; TODO first run normal parser to zero term sections 
22f5			; TODO for each word do a token look up to get the op code 
22f5			; TODO need some means to flag to the exec that this is a byte code form    
22f5			 
22f5			 
22f5			forthcompile: 
22f5			 
22f5			; 
22f5			; line parse: 
22f5			;       parse raw input buffer 
22f5			;       tokenise the words 
22f5			;       malloc new copy (for looping etc) 
22f5			;       copy to malloc + current pc in line to start of string and add line term 
22f5			;       save on new rsp 
22f5			; 
22f5			 
22f5			; hl to point to the line to tokenise 
22f5			 
22f5			;	push hl 
22f5 22 4f f6			ld (os_tok_ptr), hl  ; save ptr to string 
22f8			 
22f8			;	ld a,0		; string term on input 
22f8			;	call strlent 
22f8			 
22f8			;	ld (os_tok_len), hl	 ; save string length 
22f8			 
22f8			;if DEBUG_FORTH_TOK 
22f8			;	ex de,hl		 
22f8			;endif 
22f8			 
22f8			;	pop hl 		; get back string pointer 
22f8			 
22f8			if DEBUG_FORTH_TOK 
22f8						DMARK "TOc" 
22f8				CALLMONITOR 
22f8			endif 
22f8 7e			.cptoken2:    ld a,(hl) 
22f9 23				inc hl 
22fa fe 7f			cp FORTH_END_BUFFER 
22fc 28 29			jr z, .cptokendone2 
22fe fe 00			cp 0 
2300 28 25			jr z, .cptokendone2 
2302 fe 22			cp '"' 
2304 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2306 fe 20			cp ' ' 
2308 20 ee			jr nz,  .cptoken2 
230a			 
230a			; TODO consume comments held between ( and ) 
230a			 
230a				; we have a space so change to zero term for dict match later 
230a 2b				dec hl 
230b 3e 00			ld a,0 
230d 77				ld (hl), a 
230e 23				inc hl 
230f 18 e7			jr .cptoken2 
2311				 
2311			 
2311			.cptokenstr2: 
2311				; skip all white space until either eol (because forgot to term) or end double quote 
2311			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2311				;inc hl ; skip current double quote 
2311 7e				ld a,(hl) 
2312 23				inc hl 
2313 fe 22			cp '"' 
2315 28 e1			jr z, .cptoken2 
2317 fe 7f			cp FORTH_END_BUFFER 
2319 28 0c			jr z, .cptokendone2 
231b fe 00			cp 0 
231d 28 08			jr z, .cptokendone2 
231f fe 20			cp ' ' 
2321 28 02			jr z, .cptmp2 
2323 18 ec			jr .cptokenstr2 
2325			 
2325			.cptmp2:	; we have a space so change to zero term for dict match later 
2325				;dec hl 
2325				;ld a,"-"	; TODO remove this when working 
2325				;ld (hl), a 
2325				;inc hl 
2325 18 ea			jr .cptokenstr2 
2327			 
2327			.cptokendone2: 
2327				;inc hl 
2327 3e 7f			ld a, FORTH_END_BUFFER 
2329 77				ld (hl),a 
232a 23				inc hl 
232b 3e 21			ld a, '!' 
232d 77				ld (hl),a 
232e			 
232e 2a 4f f6			ld hl,(os_tok_ptr) 
2331			         
2331			if DEBUG_FORTH_TOK 
2331						DMARK "Tc1" 
2331				CALLMONITOR 
2331			endif 
2331			 
2331				; push exec string to top of return stack 
2331				FORTH_RSP_NEXT 
2331 cd e1 1e			call macro_forth_rsp_next 
2334				endm 
# End of macro FORTH_RSP_NEXT
2334 c9				ret 
2335			 
2335			; Another go at the parser need to simplify the process 
2335			 
2335			forthparse: 
2335			 
2335			; 
2335			; line parse: 
2335			;       parse raw input buffer 
2335			;       tokenise the words 
2335			;       malloc new copy (for looping etc) 
2335			;       copy to malloc + current pc in line to start of string and add line term 
2335			;       save on new rsp 
2335			; 
2335			 
2335			; hl to point to the line to tokenise 
2335			 
2335			;	push hl 
2335 22 4f f6			ld (os_tok_ptr), hl  ; save ptr to string 
2338			 
2338			;	ld a,0		; string term on input 
2338			;	call strlent 
2338			 
2338			;	ld (os_tok_len), hl	 ; save string length 
2338			 
2338			;if DEBUG_FORTH_TOK 
2338			;	ex de,hl		 
2338			;endif 
2338			 
2338			;	pop hl 		; get back string pointer 
2338			 
2338			if DEBUG_FORTH_TOK 
2338						DMARK "TOK" 
2338				CALLMONITOR 
2338			endif 
2338 7e			.ptoken2:    ld a,(hl) 
2339 23				inc hl 
233a fe 7f			cp FORTH_END_BUFFER 
233c 28 29			jr z, .ptokendone2 
233e fe 00			cp 0 
2340 28 25			jr z, .ptokendone2 
2342 fe 22			cp '"' 
2344 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2346 fe 20			cp ' ' 
2348 20 ee			jr nz,  .ptoken2 
234a			 
234a			; TODO consume comments held between ( and ) 
234a			 
234a				; we have a space so change to zero term for dict match later 
234a 2b				dec hl 
234b 3e 00			ld a,0 
234d 77				ld (hl), a 
234e 23				inc hl 
234f 18 e7			jr .ptoken2 
2351				 
2351			 
2351			.ptokenstr2: 
2351				; skip all white space until either eol (because forgot to term) or end double quote 
2351			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2351				;inc hl ; skip current double quote 
2351 7e				ld a,(hl) 
2352 23				inc hl 
2353 fe 22			cp '"' 
2355 28 e1			jr z, .ptoken2 
2357 fe 7f			cp FORTH_END_BUFFER 
2359 28 0c			jr z, .ptokendone2 
235b fe 00			cp 0 
235d 28 08			jr z, .ptokendone2 
235f fe 20			cp ' ' 
2361 28 02			jr z, .ptmp2 
2363 18 ec			jr .ptokenstr2 
2365			 
2365			.ptmp2:	; we have a space so change to zero term for dict match later 
2365				;dec hl 
2365				;ld a,"-"	; TODO remove this when working 
2365				;ld (hl), a 
2365				;inc hl 
2365 18 ea			jr .ptokenstr2 
2367			 
2367			.ptokendone2: 
2367				;inc hl 
2367 3e 7f			ld a, FORTH_END_BUFFER 
2369 77				ld (hl),a 
236a 23				inc hl 
236b 3e 21			ld a, '!' 
236d 77				ld (hl),a 
236e			 
236e 2a 4f f6			ld hl,(os_tok_ptr) 
2371			         
2371			if DEBUG_FORTH_TOK 
2371						DMARK "TK1" 
2371				CALLMONITOR 
2371			endif 
2371			 
2371				; push exec string to top of return stack 
2371				FORTH_RSP_NEXT 
2371 cd e1 1e			call macro_forth_rsp_next 
2374				endm 
# End of macro FORTH_RSP_NEXT
2374 c9				ret 
2375			 
2375			; 
2375			;	; malloc size + buffer pointer + if is loop flag 
2375			;	ld hl,(os_tok_len) 		 ; get string length 
2375			; 
2375			;	ld a,l 
2375			; 
2375			;	cp 0			; we dont want to use a null string 
2375			;	ret z 
2375			; 
2375			;;	add 3    ; prefix malloc with buffer for current word ptr 
2375			; 
2375			;	add 5     ; TODO when certain not over writing memory remove 
2375			; 
2375			;		 
2375			; 
2375			;if DEBUG_FORTH_TOK 
2375			;			DMARK "TKE" 
2375			;	CALLMONITOR 
2375			;endif 
2375			; 
2375			;	ld l,a 
2375			;	ld h,0 
2375			;;	push hl   ; save required space for the copy later 
2375			;	call malloc 
2375			;if DEBUG_FORTH_TOK 
2375			;			DMARK "TKM" 
2375			;	CALLMONITOR 
2375			;endif 
2375			;	if DEBUG_FORTH_MALLOC_GUARD 
2375			;		push af 
2375			;		call ishlzero 
2375			;;		ld a, l 
2375			;;		add h 
2375			;;		cp 0 
2375			;		pop af 
2375			;		 
2375			;		call z,malloc_error 
2375			;	endif 
2375			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2375			; 
2375			; 
2375			;if DEBUG_FORTH_TOK 
2375			;			DMARK "TKR" 
2375			;	CALLMONITOR 
2375			;endif 
2375			; 
2375			;	FORTH_RSP_NEXT 
2375			; 
2375			;	;inc hl	 ; go past current buffer pointer 
2375			;	;inc hl 
2375			;	;inc hl   ; and past if loop flag 
2375			;		; TODO Need to set flag  
2375			; 
2375			;	 
2375			;	 
2375			;	ex de,hl	; malloc is dest 
2375			;	ld hl, (os_tok_len) 
2375			;;	pop bc 
2375			;	ld c, l                
2375			;	ld b,0 
2375			;	ld hl, (os_tok_ptr) 
2375			; 
2375			;if DEBUG_FORTH_TOK 
2375			;			DMARK "TKT" 
2375			;	CALLMONITOR 
2375			;endif 
2375			; 
2375			;	; do str cpy 
2375			; 
2375			;	ldir      ; copy byte in hl to de 
2375			; 
2375			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2375			; 
2375			;if DEBUG_FORTH_TOK 
2375			; 
2375			;			DMARK "TKY" 
2375			;	CALLMONITOR 
2375			;endif 
2375			;	;ld a,0 
2375			;	;ld a,FORTH_END_BUFFER 
2375			;	ex de, hl 
2375			;	;dec hl			 ; go back over the space delim at the end of word 
2375			;	;ld (hl),a 
2375			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2375			;	ld a,FORTH_END_BUFFER 
2375			;	ld (hl),a 
2375			;	inc hl 
2375			;	ld a,FORTH_END_BUFFER 
2375			;	ld (hl),a 
2375			; 
2375			;	; init the malloc area data 
2375			;	; set pc for in current area 
2375			;	;ld hl, (os_tok_malloc) 
2375			;	;inc hl 
2375			;	;inc hl 
2375			;	;inc hl 
2375			;	;ex de,hl 
2375			;	;ld hl, (os_tok_malloc) 
2375			;	;ld (hl),e 
2375			;	;inc hl 
2375			;	;ld (hl),d 
2375			; 
2375			; 
2375			;	ld hl,(os_tok_malloc) 
2375			;if DEBUG_FORTH_PARSE_KEY 
2375			;			DMARK "TKU" 
2375			;	CALLMONITOR 
2375			;endif 
2375			; 
2375			;	ret 
2375			 
2375			forthexec: 
2375			 
2375			; line exec: 
2375			; forth parser 
2375			 
2375			; 
2375			;       get current exec line on rsp 
2375			 
2375				FORTH_RSP_TOS 
2375 cd f8 1e			call macro_forth_rsp_tos 
2378				endm 
# End of macro FORTH_RSP_TOS
2378			 
2378			;       restore current pc - hl points to malloc of data 
2378			 
2378				;ld e, (hl) 
2378				;inc hl 
2378				;ld d, (hl) 
2378				;ex de,hl 
2378			 
2378			 
2378			exec1: 
2378 22 4f f6			ld (os_tok_ptr), hl 
237b			 
237b				; copy our PC to working vars  
237b 22 cd fb			ld (cli_ptr), hl 
237e 22 cb fb			ld (cli_origptr), hl 
2381			 
2381 7e				ld a,(hl) 
2382 fe 7f			cp FORTH_END_BUFFER 
2384 c8				ret z 
2385			 
2385				; skip any nulls 
2385			 
2385 fe 00			cp 0 
2387 20 03			jr nz, .execword 
2389 23				inc hl 
238a 18 ec			jr exec1 
238c			 
238c			 
238c			.execword: 
238c			 
238c			 
238c			 
238c			if DEBUG_FORTH_PARSE_KEY 
238c						DMARK "KYQ" 
238c				CALLMONITOR 
238c			endif 
238c			;       while at start of word: 
238c			; get start of dict (in user area first) 
238c			 
238c 21 00 80		ld hl, baseram 
238f			;ld hl, sysdict 
238f 22 cf fb		ld (cli_nextword),hl 
2392			;           match word at pc 
2392			;           exec word 
2392			;           or push to dsp 
2392			;           forward to next token 
2392			;           if line term pop rsp and exit 
2392			;        
2392			 
2392			if DEBUG_FORTH_PARSE_KEY 
2392						DMARK "KYq" 
2392				CALLMONITOR 
2392			endif 
2392			 
2392			; 
2392			; word comp 
2392			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2392			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2392			;    move to start of word  
2392			;    compare word to cli_token 
2392			 
2392			.execpnword:	; HL at start of a word in the dictionary to check 
2392			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2392			;	ld (cli_ptr), hl 
2392			 
2392 2a cf fb			ld hl,(cli_nextword) 
2395			 
2395 cd 38 24			call forth_tok_next 
2398			; tok next start here 
2398			;	; TODO skip compiled symbol for now 
2398			;	inc hl 
2398			; 
2398			;	; save pointer to next word 
2398			; 
2398			;	; hl now points to the address of the next word pointer  
2398			;	ld e, (hl) 
2398			;	inc hl 
2398			;	ld d, (hl) 
2398			;	inc l 
2398			; 
2398			;	ex de,hl 
2398			;if DEBUG_FORTH_PARSE_NEXTWORD 
2398			;	push bc 
2398			;	ld bc, (cli_nextword) 
2398			;			DMARK "NXW" 
2398			;	CALLMONITOR 
2398			;	pop bc 
2398			;endif 
2398			; tok next end here 
2398 22 cf fb			ld (cli_nextword), hl     ; save for next check if no match on this word 
239b eb				ex de, hl 
239c			 
239c			 
239c				; save the pointer of the current token - 1 to check against 
239c				 
239c 22 d3 fb			ld (cli_token), hl   
239f				; TODO maybe remove below save if no debug 
239f				; save token string ptr for any debug later 
239f 23				inc hl  
23a0 22 d5 fb			ld (cli_origtoken), hl 
23a3 2b				dec hl 
23a4				; save pointer to the start of the next dictionay word 
23a4 7e				ld a,(hl)   ; get string length 
23a5 47				ld b,a 
23a6			.execpnwordinc:  
23a6 23				inc hl 
23a7 10 fd			djnz .execpnwordinc 
23a9 22 d1 fb			ld (cli_execword), hl      ; save start of this words code 
23ac			 
23ac				; now check the word token against the string being parsed 
23ac			 
23ac 2a d3 fb			ld hl,(cli_token) 
23af 23				inc hl     ; skip string length (use zero term instead to end) 
23b0 22 d3 fb			ld (cli_token), hl 
23b3			 
23b3			if DEBUG_FORTH_PARSE_KEY 
23b3						DMARK "KY2" 
23b3			endif 
23b3			if DEBUG_FORTH_PARSE_EXEC 
23b3				; see if disabled 
23b3			 
23b3				ld a, (os_view_disable) 
23b3				cp '*' 
23b3				jr z, .skip 
23b3			 
23b3				push hl 
23b3				push hl 
23b3				call clear_display 
23b3				ld de, .compword 
23b3				ld a, display_row_1 
23b3				call str_at_display 
23b3				pop de 
23b3				ld a, display_row_2 
23b3				call str_at_display 
23b3				ld hl,(cli_ptr) 
23b3				ld a,(hl) 
23b3			        ld hl, os_word_scratch 
23b3				ld (hl),a 
23b3				ld a,0 
23b3				inc hl 
23b3				ld (hl),a 	 
23b3				ld de, os_word_scratch 
23b3				ld a, display_row_2+10 
23b3				call str_at_display 
23b3				call update_display 
23b3				ld a, 100 
23b3				call aDelayInMS 
23b3				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23b3				call delay250ms 
23b3				endif 
23b3				pop hl 
23b3			.skip:  
23b3			endif	 
23b3			.execpnchar:    ; compare char between token and string to parse 
23b3			 
23b3			if DEBUG_FORTH_PARSE_KEY 
23b3						DMARK "Ky3" 
23b3			endif 
23b3			if DEBUG_FORTH_PARSE_EXEC 
23b3				; see if disabled 
23b3			 
23b3				ld a, (os_view_disable) 
23b3				cp '*' 
23b3				jr z, .skip2 
23b3			 
23b3			;	call clear_display 
23b3			ld hl,(cli_token) 
23b3			ld a,(hl) 
23b3			ld (os_word_scratch),a 
23b3				ld hl,(cli_ptr) 
23b3			ld a,(hl) 
23b3				ld (os_word_scratch+1),a 
23b3				ld a,0 
23b3				ld (os_word_scratch+2),a 
23b3				ld de,os_word_scratch 
23b3				ld a,display_row_4 
23b3				call str_at_display 
23b3				call update_display 
23b3			.skip2:  
23b3			endif 
23b3 2a d3 fb			ld hl,(cli_token) 
23b6 7e				ld a, (hl)	 ; char in word token 
23b7 23				inc hl 		; move to next char 
23b8 22 d3 fb			ld (cli_token), hl ; and save it 
23bb 47				ld b,a 
23bc			 
23bc 2a cd fb			ld hl,(cli_ptr) ;	get the char from the string to parse 
23bf 7e				ld a,(hl) 
23c0 23				inc hl 
23c1 22 cd fb			ld (cli_ptr), hl		; move to next char 
23c4 cd 9e 13			call toUpper 		; make sure the input string matches case 
23c7			 
23c7			if DEBUG_FORTH_PARSE 
23c7			endif 
23c7			 
23c7				; input stream end of token is a space so get rid of it 
23c7			 
23c7			;	cp ' ' 
23c7			;	jr nz, .pnskipspace 
23c7			; 
23c7			;	ld a, 0		; make same term as word token term 
23c7			; 
23c7			;.pnskipspace: 
23c7			 
23c7			if DEBUG_FORTH_PARSE_KEY 
23c7						DMARK "KY7" 
23c7			endif 
23c7 b8				cp b 
23c8 c2 de 23			jp nz, .execpnskipword	 ; no match so move to next word 
23cb				 
23cb			;    if same 
23cb			;       scan for string terms 0 for token and 32 for input 
23cb			 
23cb				 
23cb			if DEBUG_FORTH_PARSE_KEY 
23cb						DMARK "KY8" 
23cb			endif 
23cb			 
23cb 80				add b			 
23cc fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
23ce							; TODO need to make sure last word in zero term string is accounted for 
23ce 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
23d0			 
23d0			 
23d0				; at end of both strings so both are exact match 
23d0			 
23d0			;       skip ptr for next word 
23d0			 
23d0 2a cd fb			ld hl,(cli_ptr) 	; at input string term 
23d3 23				inc hl			 ; at next char 
23d4 22 cd fb			ld (cli_ptr), hl     ; save for next round of the parser 
23d7 22 cb fb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
23da				 
23da				 
23da			if DEBUG_FORTH_PARSE_KEY 
23da						DMARK "KY3" 
23da			endif 
23da			 
23da			 
23da			 
23da			;       exec code block 
23da			if DEBUG_FORTH_JP 
23da				call clear_display 
23da				call update_display 
23da				call delay1s 
23da				ld hl, (cli_execword)     ; save for next check if no match on this word 
23da				ld a,h 
23da				ld hl, os_word_scratch 
23da				call hexout 
23da				ld hl, (cli_execword)     ; save for next check if no match on this word 
23da				ld a,l 
23da				ld hl, os_word_scratch+2 
23da				call hexout 
23da				ld hl, os_word_scratch+4 
23da				ld a,0 
23da				ld (hl),a 
23da				ld de,os_word_scratch 
23da				call str_at_display 
23da					ld a, display_row_2 
23da					call str_at_display 
23da				ld de, (cli_origtoken) 
23da				ld a, display_row_1+10 
23da					call str_at_display 
23da			 
23da				ld a,display_row_1 
23da				ld de, .foundword 
23da				ld a, display_row_3 
23da				call str_at_display 
23da				call update_display 
23da				call delay1s 
23da				call delay1s 
23da				call delay1s 
23da			endif 
23da			 
23da			if DEBUG_FORTH_PARSE_KEY 
23da						DMARK "KYj" 
23da			endif 
23da				; TODO save the word pointer in this exec 
23da			 
23da 2a d1 fb			ld hl,(cli_execword) 
23dd e9				jp (hl) 
23de			 
23de			 
23de			;    if not same 
23de			;	scan for zero term 
23de			;	get ptr for next word 
23de			;	goto word comp 
23de			 
23de			.execpnskipword:	; get pointer to next word 
23de 2a cf fb			ld hl,(cli_nextword) 
23e1			 
23e1 7e				ld a,(hl) 
23e2 fe 00			cp WORD_SYS_END 
23e4			;	cp 0 
23e4 28 09			jr z, .execendofdict			 ; at end of words 
23e6			 
23e6			if DEBUG_FORTH_PARSE_KEY 
23e6						DMARK "KY4" 
23e6			endif 
23e6			if DEBUG_FORTH_PARSE_EXEC 
23e6			 
23e6				; see if disabled 
23e6			 
23e6				ld a, (os_view_disable) 
23e6				cp '*' 
23e6				jr z, .noskip 
23e6			 
23e6			 
23e6				ld de, .nowordfound 
23e6				ld a, display_row_3 
23e6				call str_at_display 
23e6				call update_display 
23e6				ld a, 100 
23e6				call aDelayInMS 
23e6				 
23e6				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23e6					call delay250ms 
23e6				endif 
23e6			.noskip:  
23e6			 
23e6			endif	 
23e6			 
23e6 2a cb fb			ld hl,(cli_origptr) 
23e9 22 cd fb			ld (cli_ptr),hl 
23ec			 
23ec			if DEBUG_FORTH_PARSE_KEY 
23ec						DMARK "KY5" 
23ec			endif 
23ec c3 92 23			jp .execpnword			; else go to next word 
23ef			 
23ef			.execendofdict:  
23ef			 
23ef			if DEBUG_FORTH_PARSE_KEY 
23ef						DMARK "KYe" 
23ef			endif 
23ef			if DEBUG_FORTH_PARSE_EXEC 
23ef				; see if disabled 
23ef			 
23ef				ld a, (os_view_disable) 
23ef				cp '*' 
23ef				jr z, .ispskip 
23ef			 
23ef				call clear_display 
23ef				call update_display 
23ef				call delay1s 
23ef				ld de, (cli_origptr) 
23ef				ld a, display_row_1 
23ef				call str_at_display 
23ef				 
23ef				ld de, .enddict 
23ef				ld a, display_row_3 
23ef				call str_at_display 
23ef				call update_display 
23ef				ld a, 100 
23ef				call aDelayInMS 
23ef				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23ef				call delay1s 
23ef				call delay1s 
23ef				call delay1s 
23ef				endif 
23ef			.ispskip:  
23ef				 
23ef			endif	 
23ef			 
23ef			 
23ef			 
23ef				; if the word is not a keyword then must be a literal so push it to stack 
23ef			 
23ef			; push token to stack to end of word 
23ef			 
23ef				STACKFRAME ON $1efe $2f9f 
23ef				if DEBUG_STACK_IMB 
23ef					if ON 
23ef						exx 
23ef						ld de, $1efe 
23ef						ld a, d 
23ef						ld hl, curframe 
23ef						call hexout 
23ef						ld a, e 
23ef						ld hl, curframe+2 
23ef						call hexout 
23ef						ld hl, $1efe 
23ef						push hl 
23ef						ld hl, $2f9f 
23ef						push hl 
23ef						exx 
23ef					endif 
23ef				endif 
23ef			endm 
# End of macro STACKFRAME
23ef			 
23ef 2a 4f f6		ld hl,(os_tok_ptr) 
23f2 cd a3 20		call forth_apush 
23f5			 
23f5				STACKFRAMECHK ON $1efe $2f9f 
23f5				if DEBUG_STACK_IMB 
23f5					if ON 
23f5						exx 
23f5						ld hl, $2f9f 
23f5						pop de   ; $2f9f 
23f5						call cmp16 
23f5						jr nz, .spnosame 
23f5						ld hl, $1efe 
23f5						pop de   ; $1efe 
23f5						call cmp16 
23f5						jr z, .spfrsame 
23f5						.spnosame: call showsperror 
23f5						.spfrsame: nop 
23f5						exx 
23f5					endif 
23f5				endif 
23f5			endm 
# End of macro STACKFRAMECHK
23f5			 
23f5			execnext: 
23f5			 
23f5			if DEBUG_FORTH_PARSE_KEY 
23f5						DMARK "KY>" 
23f5			endif 
23f5			; move past token to next word 
23f5			 
23f5 2a 4f f6		ld hl, (os_tok_ptr) 
23f8 3e 00		ld a, 0 
23fa 01 ff 00		ld bc, 255     ; input buffer size 
23fd ed b1		cpir 
23ff			 
23ff			if DEBUG_FORTH_PARSE_KEY 
23ff						DMARK "KY!" 
23ff				CALLMONITOR 
23ff			endif	 
23ff			; TODO this might place hl on the null, so will need to forward on??? 
23ff			;inc hl   ; see if this gets onto the next item 
23ff			 
23ff			 
23ff			; TODO pass a pointer to the buffer to push 
23ff			; TODO call function to push 
23ff			 
23ff			; look for end of input 
23ff			 
23ff			;inc hl 
23ff			;ld a,(hl) 
23ff			;cp FORTH_END_BUFFER 
23ff			;ret z 
23ff			 
23ff			 
23ff c3 78 23		jp exec1 
2402			 
2402			 
2402			 
2402			 
2402			 
2402			 
2402			 
2402			 
2402			 
2402			findnexttok: 
2402			 
2402				; hl is pointer to move 
2402				; de is the token to locate 
2402			 
2402					if DEBUG_FORTH 
2402						DMARK "NTK" 
2402						CALLMONITOR 
2402					endif 
2402 d5				push de 
2403			 
2403			.fnt1:	 
2403				; find first char of token to locate 
2403			 
2403 1a				ld a, (de) 
2404 4f				ld c,a 
2405 7e				ld a,(hl) 
2406 cd 9e 13			call toUpper 
2409					if DEBUG_FORTH 
2409						DMARK "NT1" 
2409						CALLMONITOR 
2409					endif 
2409 b9				cp c 
240a			 
240a 28 03			jr z, .fnt2cmpmorefirst	 
240c			 
240c				; first char not found move to next char 
240c			 
240c 23				inc hl 
240d 18 f4			jr .fnt1 
240f			 
240f			.fnt2cmpmorefirst:	 
240f				; first char of token found.  
240f			 
240f e5				push hl     ; save start of token just in case it is the right one 
2410 d9				exx 
2411 e1				pop hl        ; save it to hl' 
2412 d9				exx 
2413			 
2413			 
2413			.fnt2cmpmore:	 
2413				; compare the rest 
2413				 
2413 23				inc hl 
2414 13				inc de 
2415				 
2415 1a				ld a, (de) 
2416 4f				ld c,a 
2417 7e				ld a,(hl) 
2418 cd 9e 13			call toUpper 
241b			 
241b					if DEBUG_FORTH 
241b						DMARK "NT2" 
241b						CALLMONITOR 
241b					endif 
241b				; c has the token to find char 
241b				; a has the mem to scan char 
241b			 
241b b9				cp c 
241c 28 04			jr z,.fntmatch1 
241e			 
241e				; they are not the same 
241e			 
241e					if DEBUG_FORTH 
241e						DMARK "NT3" 
241e						CALLMONITOR 
241e					endif 
241e d1				pop de	; reset de token to look for 
241f d5				push de 
2420 18 e1			jr .fnt1 
2422				 
2422			.fntmatch1: 
2422			 
2422				; is the same char a null which means we might have a full hit? 
2422					if DEBUG_FORTH 
2422						DMARK "NT4" 
2422						CALLMONITOR 
2422					endif 
2422			 
2422 fe 00			cp 0 
2424 28 0b			jr z, .fntmatchyes 
2426			 
2426				; are we at the end of the token to find? 
2426			 
2426					if DEBUG_FORTH 
2426						DMARK "NT5" 
2426						CALLMONITOR 
2426					endif 
2426 3e 00			ld a, 0 
2428 b9				cp c 
2429			 
2429 c2 13 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
242c			 
242c					if DEBUG_FORTH 
242c						DMARK "NT6" 
242c						CALLMONITOR 
242c					endif 
242c				; token to find is exhusted but no match to stream 
242c			 
242c				; restore tok pointer and continue on 
242c d1				pop de 
242d d5				push de 
242e c3 03 24			jp .fnt1 
2431			 
2431			 
2431			.fntmatchyes: 
2431			 
2431				; hl now contains the end of the found token 
2431			 
2431				; get rid of saved token pointer to find 
2431			 
2431 d1				pop de 
2432			 
2432					if DEBUG_FORTH 
2432						DMARK "NT9" 
2432						CALLMONITOR 
2432					endif 
2432			 
2432				; hl will be on the null term so forward on 
2432			 
2432				; get back the saved start of the token 
2432			 
2432 d9				exx 
2433 e5				push hl     ; save start of token just in case it is the right one 
2434 d9				exx 
2435 e1				pop hl        ; save it to hl 
2436			 
2436 c9				ret 
2437			 
2437			 
2437			; LIST needs to find a specific token   
2437			; FORGET needs to find a spefici token 
2437			 
2437			; SAVE needs to find all tokens by flag 
2437			; WORDS just needs to scan through all  by flag 
2437			; UWORDS needs to scan through all by flag 
2437			 
2437			 
2437			; given hl as pointer to start of dict look up string 
2437			; return hl as pointer to start of word block 
2437			; or 0 if not found 
2437			 
2437			forth_find_tok: 
2437 c9				ret 
2438			 
2438			; given hl as pointer to dict structure 
2438			; move to the next dict block structure 
2438			 
2438			forth_tok_next: 
2438				; hl now points to the address of the next word pointer  
2438				; TODO skip compiled symbol for now 
2438			;	push de 
2438 23				inc hl 
2439 5e				ld e, (hl) 
243a 23				inc hl 
243b 56				ld d, (hl) 
243c 23				inc hl 
243d			 
243d eb				ex de,hl 
243e			if DEBUG_FORTH_PARSE_NEXTWORD 
243e				push bc 
243e				ld bc, (cli_nextword) 
243e						DMARK "NXW" 
243e				CALLMONITOR 
243e				pop bc 
243e			endif 
243e			;	pop de	 
243e c9				ret 
243f			 
243f			 
243f			 
243f			; eof 
# End of file forth_parserv5.asm
243f				include "forth_wordsv4.asm" 
243f			 
243f			; the core word dictionary v4 
243f			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
243f			 
243f			; this is a linked list for each of the system words used 
243f			; user defined words will follow the same format but will be in ram 
243f			 
243f			 
243f			; 
243f			; 
243f			; define linked list: 
243f			; 
243f			; 1. compiled byte op code 
243f			; 2. len of text word 
243f			; 3. text word 
243f			; 4. ptr to next dictionary word 
243f			; 5. asm, calls etc for the word 
243f			; 
243f			;  if 1 == 0 then last word in dict  
243f			;   
243f			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
243f			;  
243f			;  
243f			; create basic standard set of words 
243f			; 
243f			;  
243f			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
243f			; 2DUP 2DROP 2SWAP  
243f			; @ C@ - get byte  
243f			; ! C! - store byte 
243f			; 0< true if less than zero 
243f			; 0= true if zero 
243f			; < >  
243f			; = true if same 
243f			; variables 
243f			 
243f			 
243f			; Hardware specific words I may need 
243f			; 
243f			; IN OUT  
243f			; calls to key util functions 
243f			; calls to hardward abstraction stuff 
243f			; easy control of frame buffers and lcd i/o 
243f			; keyboard  
243f			 
243f			 
243f			;DICT: macro 
243f			; op_code, len, word, next 
243f			;    word: 
243f			;    db op_code 
243f			;    ds word zero term 
243f			;    dw next 
243f			;    endm 
243f			 
243f			 
243f			 
243f			 
243f			; op code 1 is a flag for user define words which are to be handled differently 
243f			 
243f			 
243f			; 
243f			; 
243f			;    TODO on entry to a word this should be the expected environment 
243f			;    hl - tos value if number then held, if string this is the ptr 
243f			;    de -  
243f			 
243f			 
243f			; opcode ranges 
243f			; 0 - end of word dict 
243f			; 255 - user define words 
243f			 
243f			sysdict: 
243f			include "forth_opcodes.asm" 
243f			; op codes for forth keywords 
243f			; free to use code 0  
243f				OPCODE_HEAP: equ  1 
243f				OPCODE_EXEC: equ 2 
243f				OPCODE_DUP: equ 3 
243f				OPCODE_SWAP: equ 4 
243f				OPCODE_COLN: equ 5 
243f				OPCODE_SCOLN: equ 6 
243f				OPCODE_DROP: equ 7 
243f				OPCODE_DUP2: equ 8 
243f				OPCODE_DROP2: equ 9 
243f				OPCODE_SWAP2: equ 10 
243f				OPCODE_AT: equ 11 
243f				OPCODE_CAT: equ 12 
243f				OPCODE_BANG: equ 13 
243f				OPCODE_CBANG: equ 14 
243f				OPCODE_SCALL: equ 15 
243f				OPCODE_DEPTH: equ 16 
243f				OPCODE_OVER: equ 17 
243f				OPCODE_PAUSE: equ 18 
243f				OPCODE_PAUSES: equ 19 
243f				OPCODE_ROT: equ 20 
243f			;free to reuse	OPCODE_WORDS: equ 21 
243f			        OPCODE_NOT: equ 21 
243f				OPCODE_UWORDS: equ 22 
243f				OPCODE_BP: equ 23 
243f				OPCODE_MONITOR: equ 24  
243f				OPCODE_MALLOC: equ 25 
243f				OPCODE_FREE: equ 26 
243f				OPCODE_LIST: equ 27 
243f				OPCODE_FORGET: equ 28 
243f				OPCODE_NOP: equ 29 
243f				OPCODE_COMO: equ 30 
243f				OPCODE_COMC: equ 31 
243f			;free to reuse	OPCODE_ENDCORE: equ 32 
243f				OPCODE_AFTERSOUND: equ 33 
243f				OPCODE_GP2: equ 34 
243f				OPCODE_GP3: equ 35 
243f				OPCODE_GP4: equ 36 
243f				OPCODE_SIN: equ 37 
243f				OPCODE_SOUT: equ 38 
243f				OPCODE_SPIO: equ 39 
243f				OPCODE_SPICEH: equ 40 
243f				OPCODE_SPIOb: equ 41 
243f				OPCODE_SPII: equ 42 
243f				OPCODE_SESEL: equ 43 
243f				OPCODE_CARTDEV: equ 44 
243f			; free to reuse	OPCODE_ENDDEVICE: equ 45 
243f				OPCODE_FB: equ 46 
243f				OPCODE_EMIT: equ 47 
243f				OPCODE_DOTH: equ 48 
243f				OPCODE_DOTF: equ 49 
243f				OPCODE_DOT: equ 50 
243f				OPCODE_CLS: equ 51 
243f				OPCODE_DRAW: equ 52 
243f				OPCODE_DUMP: equ 53 
243f				OPCODE_CDUMP: equ 54 
243f				OPCODE_DAT: equ 55 
243f				OPCODE_HOME: equ 56 
243f				OPCODE_SPACE: equ 57 
243f				OPCODE_SPACES: equ 58 
243f				OPCODE_SCROLL: equ 59 
243f				OPCODE_ATQ: equ 60 
243f				OPCODE_AUTODSP: equ 61 
243f				OPCODE_MENU: equ 62 
243f			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
243f				OPCODE_THEN: equ 64 
243f				OPCODE_ELSE: equ 65 
243f				OPCODE_DO: equ 66 
243f				OPCODE_LOOP: equ 67 
243f				OPCODE_I: equ 68 
243f				OPCODE_DLOOP: equ 69  
243f				OPCODE_REPEAT: equ 70  
243f				OPCODE_UNTIL: equ 71 
243f				OPCODE_ENDFLOW: equ 72 
243f				OPCODE_WAITK: equ 73 
243f				OPCODE_ACCEPT: equ 74 
243f				OPCODE_EDIT: equ 75 
243f			;free to reuse	OPCODE_ENDKEY: equ 76 
243f				OPCODE_LZERO: equ 77 
243f				OPCODE_TZERO: equ 78 
243f				OPCODE_LESS: equ 79 
243f				OPCODE_GT: equ 80 
243f				OPCODE_EQUAL: equ 81  
243f			;free to reuse	OPCODE_ENDLOGIC: equ 82 
243f				OPCODE_NEG: equ 83 
243f				OPCODE_DIV: equ 84 
243f				OPCODE_MUL: equ 85 
243f				OPCODE_MIN: equ 86 
243f				OPCODE_MAX: equ 87 
243f				OPCODE_RND16: equ 88 
243f				OPCODE_RND8: equ 89 
243f				OPCODE_RND: equ 90 
243f			;free to reuse	OPCODE_ENDMATHS: equ 91  
243f				OPCODE_BYNAME: equ 92 
243f				OPCODE_DIR: equ 93 
243f				OPCODE_SAVE: equ 94 
243f				OPCODE_LOAD: equ 95 
243f				OPCODE_BSAVE: equ 96 
243f				OPCODE_BLOAD: equ 97 
243f				OPCODE_SEO: equ 98  
243f				OPCODE_SEI: equ 99 
243f				OPCODE_SFREE: equ 100 
243f				OPCODE_SIZE: equ 101 
243f				OPCODE_CREATE: equ 102 
243f				OPCODE_APPEND: equ 103 
243f				OPCODE_SDEL: equ 104 
243f				OPCODE_OPEN: equ 105 
243f				OPCODE_READ: equ 106 
243f				OPCODE_EOF: equ 106 
243f				OPCODE_FORMAT: equ 107 
243f				OPCODE_LABEL: equ 108 
243f				OPCODE_LABELS: equ 109 
243f			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
243f				OPCODE_UPPER: equ 111 
243f				OPCODE_LOWER: equ 112 
243f				OPCODE_SUBSTR: equ 113 
243f				OPCODE_LEFT: equ 114 
243f				OPCODE_RIGHT: equ 115 
243f				OPCODE_STR2NUM: equ 116 
243f				OPCODE_NUM2STR: equ 117 
243f				OPCODE_CONCAT: equ 118 
243f				OPCODE_FIND: equ 119 
243f				OPCODE_LEN: equ 120 
243f				OPCODE_CHAR: equ 121 
243f			; free to reuse	OPCODE_STRLEN: equ 122 
243f			; free to reuse	OPCODE_ENDSTR: equ 123 
243f				OPCODE_V0S: equ 124 
243f				OPCODE_V0Q: equ 125 
243f				OPCODE_V1S: equ 126 
243f				OPCODE_V1Q: equ 127 
243f				OPCODE_V2S: equ 128 
243f				OPCODE_V2Q: equ 129 
243f				OPCODE_V3S: equ 130 
243f				OPCODE_V3Q: equ 131 
243f			;free to reuse	OPCODE_END: equ 132 
243f				OPCODE_ZDUP: equ 133 
243f			 
243f			; eof 
# End of file forth_opcodes.asm
243f			 
243f			include "forth_words_core.asm" 
243f			 
243f			; | ## Core Words 
243f			 
243f			;if MALLOC_4 
243f			 
243f			.HEAP: 
243f				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
243f 15				db WORD_SYS_CORE+OPCODE_HEAP             
2440 7e 24			dw .EXEC            
2442 05				db 4 + 1 
2443 .. 00			db "HEAP",0              
2448				endm 
# End of macro CWHEAD
2448			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2448			; | | u1 - Current number of bytes in the heap 
2448			; | | u2 - Remaining bytes left on the heap 
2448			; | |  
2448			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2448			 
2448			 
2448					if DEBUG_FORTH_WORDS_KEY 
2448						DMARK "HEP" 
2448 f5				push af  
2449 3a 5d 24			ld a, (.dmark)  
244c 32 b4 fe			ld (debug_mark),a  
244f 3a 5e 24			ld a, (.dmark+1)  
2452 32 b5 fe			ld (debug_mark+1),a  
2455 3a 5f 24			ld a, (.dmark+2)  
2458 32 b6 fe			ld (debug_mark+2),a  
245b 18 03			jr .pastdmark  
245d ..			.dmark: db "HEP"  
2460 f1			.pastdmark: pop af  
2461			endm  
# End of macro DMARK
2461						CALLMONITOR 
2461 cd c6 18			call break_point_state  
2464				endm  
# End of macro CALLMONITOR
2464					endif 
2464 2a 0a 80				ld hl, (free_list )      
2467 11 0e 80				ld de, heap_start 
246a			 
246a ed 52				sbc hl, de  
246c			 
246c cd 3a 1f				call forth_push_numhl 
246f			 
246f			 
246f ed 5b 0a 80			ld de, (free_list )      
2473 21 34 f3				ld hl, heap_end 
2476			 
2476 ed 52				sbc hl, de 
2478			 
2478 cd 3a 1f				call forth_push_numhl 
247b					 
247b			 
247b					 
247b			 
247b			 
247b			 
247b					NEXTW 
247b c3 e7 22			jp macro_next 
247e				endm 
# End of macro NEXTW
247e			;endif 
247e			 
247e			.EXEC: 
247e			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
247e			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
247e			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
247e			;; > > 
247e			;; > >   
247e			;	STACKFRAME OFF $5efe $5f9f 
247e			; 
247e			;		if DEBUG_FORTH_WORDS_KEY 
247e			;			DMARK "EXE" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			;	FORTH_DSP_VALUEHL 
247e			; 
247e			;	FORTH_DSP_POP 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX1" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;;	ld e,(hl) 
247e			;;	inc hl 
247e			;;	ld d,(hl) 
247e			;;	ex de,hl 
247e			; 
247e			;;		if DEBUG_FORTH_WORDS 
247e			;;			DMARK "EX2" 
247e			;;			CALLMONITOR 
247e			;;		endif 
247e			;	push hl 
247e			; 
247e			;	;ld a, 0 
247e			;	;ld a, FORTH_END_BUFFER 
247e			;	call strlenz 
247e			;	inc hl   ; include zero term to copy 
247e			;	inc hl   ; include term 
247e			;	inc hl   ; include term 
247e			;	ld b,0 
247e			;	ld c,l 
247e			;	pop hl 
247e			;	ld de, execscratch 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX3" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	ldir 
247e			; 
247e			; 
247e			;	ld hl, execscratch 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EXe" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			;	call forthparse 
247e			;	call forthexec 
247e			;;	call forthexec_cleanup 
247e			;;	call forthparse 
247e			;;	call forthexec 
247e			; 
247e			;	STACKFRAMECHK OFF $5efe $5f9f 
247e			; 
247e			;	; an immediate word so no need to process any more words 
247e			;	ret 
247e			;	NEXTW 
247e			 
247e			; dead code - old version  
247e			;	FORTH_RSP_NEXT 
247e			 
247e			;  
247e			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
247e			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
247e			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
247e			;	push hl 
247e			;	push de 
247e			;	push bc 
247e			; 
247e			; 
247e			;		if DEBUG_FORTH_WORDS_KEY 
247e			;			DMARK "EXR" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			; 
247e			; 
247e			;	;v5 FORTH_DSP_VALUE 
247e			;	FORTH_DSP_VALUEHL 
247e			; 
247e			;	; TODO do string type checks 
247e			; 
247e			;;v5	inc hl   ; skip type 
247e			; 
247e			;	push hl  ; source code  
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX1" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	ld a, 0 
247e			;	call strlent 
247e			; 
247e			;	inc hl 
247e			;	inc hl 
247e			;	inc hl 
247e			;	inc hl 
247e			; 
247e			;	push hl    ; size 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX2" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	call malloc 
247e			; 
247e			;	ex de, hl    ; de now contains malloc area 
247e			;	pop bc   	; get byte count 
247e			;	pop hl      ; get string to copy 
247e			; 
247e			;	push de     ; save malloc for free later 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX3" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	ldir       ; duplicate string 
247e			; 
247e			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
247e			;	 
247e			;	; TODO fix the parse would be better than this...  
247e			;	ex de, hl 
247e			;	dec hl 
247e			;	ld a, 0 
247e			;	ld (hl), a 
247e			;	dec hl 
247e			;	ld a, ' ' 
247e			;	ld (hl), a 
247e			;	dec hl 
247e			;	ld (hl), a 
247e			; 
247e			;	dec hl 
247e			;	ld (hl), a 
247e			; 
247e			; 
247e			;	FORTH_DSP_POP  
247e			; 
247e			;	pop hl     
247e			;	push hl    ; save malloc area 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX4" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			;	call forthparse 
247e			;	call forthexec 
247e			;	 
247e			;	pop hl 
247e			;	if DEBUG_FORTH_WORDS 
247e			;		DMARK "EX5" 
247e			;		CALLMONITOR 
247e			;	endif 
247e			; 
247e			;	if FORTH_ENABLE_FREE 
247e			;	call free 
247e			;	endif 
247e			; 
247e			;	if DEBUG_FORTH_WORDS 
247e			;		DMARK "EX6" 
247e			;		CALLMONITOR 
247e			;	endif 
247e			; 
247e			;	pop bc 
247e			;	pop de 
247e			;	pop hl 
247e			;;	FORTH_RSP_POP	  
247e			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
247e			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
247e			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
247e			; 
247e			;	if DEBUG_FORTH_WORDS 
247e			;		DMARK "EX7" 
247e			;		CALLMONITOR 
247e			;	endif 
247e			;	NEXTW 
247e			 
247e			;.STKEXEC: 
247e			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
247e			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
247e			; 
247e			; 
247e			;		if DEBUG_FORTH_WORDS_KEY 
247e			;			DMARK "STX" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			;	FORTH_DSP_VALUEHL 
247e			; 
247e			;	ld (store_tmp1), hl    ; count 
247e			; 
247e			;	FORTH_DSP_POP 
247e			;.stkexec1: 
247e			;	ld hl, (store_tmp1)   ; count 
247e			;	ld a, 0 
247e			;	cp l 
247e			;	ret z 
247e			; 
247e			;	dec hl 
247e			;	ld (store_tmp1), hl    ; count 
247e			;	 
247e			;	FORTH_DSP_VALUEHL 
247e			;	push hl 
247e			;	 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EXp" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	FORTH_DSP_POP 
247e			; 
247e			;	call strlenz 
247e			;	inc hl   ; include zero term to copy 
247e			;	inc hl   ; include zero term to copy 
247e			;	inc hl   ; include zero term to copy 
247e			;	ld b,0 
247e			;	ld c,l 
247e			;	pop hl 
247e			;	ld de, execscratch 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EX3" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	ldir 
247e			; 
247e			; 
247e			;	ld hl, execscratch 
247e			; 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EXP" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			; 
247e			;	call forthparse 
247e			;	ld hl, execscratch 
247e			;		if DEBUG_FORTH_WORDS 
247e			;			DMARK "EXx" 
247e			;			CALLMONITOR 
247e			;		endif 
247e			;	call forthexec 
247e			; 
247e			;	jp .stkexec1 
247e			; 
247e			;	ret 
247e			 
247e			 
247e			.DUP: 
247e				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
247e 17				db WORD_SYS_CORE+OPCODE_DUP             
247f f4 24			dw .ZDUP            
2481 04				db 3 + 1 
2482 .. 00			db "DUP",0              
2486				endm 
# End of macro CWHEAD
2486			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2486			 
2486					if DEBUG_FORTH_WORDS_KEY 
2486						DMARK "DUP" 
2486 f5				push af  
2487 3a 9b 24			ld a, (.dmark)  
248a 32 b4 fe			ld (debug_mark),a  
248d 3a 9c 24			ld a, (.dmark+1)  
2490 32 b5 fe			ld (debug_mark+1),a  
2493 3a 9d 24			ld a, (.dmark+2)  
2496 32 b6 fe			ld (debug_mark+2),a  
2499 18 03			jr .pastdmark  
249b ..			.dmark: db "DUP"  
249e f1			.pastdmark: pop af  
249f			endm  
# End of macro DMARK
249f						CALLMONITOR 
249f cd c6 18			call break_point_state  
24a2				endm  
# End of macro CALLMONITOR
24a2					endif 
24a2			 
24a2					FORTH_DSP 
24a2 cd f7 20			call macro_forth_dsp 
24a5				endm 
# End of macro FORTH_DSP
24a5			 
24a5 7e					ld a, (HL) 
24a6 fe 01				cp DS_TYPE_STR 
24a8 20 25				jr nz, .dupinum 
24aa			 
24aa					; push another string 
24aa			 
24aa					FORTH_DSP_VALUEHL     		 
24aa cd 31 21			call macro_dsp_valuehl 
24ad				endm 
# End of macro FORTH_DSP_VALUEHL
24ad			 
24ad				if DEBUG_FORTH_WORDS 
24ad					DMARK "DUs" 
24ad f5				push af  
24ae 3a c2 24			ld a, (.dmark)  
24b1 32 b4 fe			ld (debug_mark),a  
24b4 3a c3 24			ld a, (.dmark+1)  
24b7 32 b5 fe			ld (debug_mark+1),a  
24ba 3a c4 24			ld a, (.dmark+2)  
24bd 32 b6 fe			ld (debug_mark+2),a  
24c0 18 03			jr .pastdmark  
24c2 ..			.dmark: db "DUs"  
24c5 f1			.pastdmark: pop af  
24c6			endm  
# End of macro DMARK
24c6					CALLMONITOR 
24c6 cd c6 18			call break_point_state  
24c9				endm  
# End of macro CALLMONITOR
24c9				endif 
24c9 cd a8 1f				call forth_push_str 
24cc			 
24cc					NEXTW 
24cc c3 e7 22			jp macro_next 
24cf				endm 
# End of macro NEXTW
24cf			 
24cf			 
24cf			.dupinum: 
24cf					 
24cf			 
24cf			 
24cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24cf cd 31 21			call macro_dsp_valuehl 
24d2				endm 
# End of macro FORTH_DSP_VALUEHL
24d2			 
24d2				; TODO add floating point number detection 
24d2			 
24d2				if DEBUG_FORTH_WORDS 
24d2					DMARK "DUi" 
24d2 f5				push af  
24d3 3a e7 24			ld a, (.dmark)  
24d6 32 b4 fe			ld (debug_mark),a  
24d9 3a e8 24			ld a, (.dmark+1)  
24dc 32 b5 fe			ld (debug_mark+1),a  
24df 3a e9 24			ld a, (.dmark+2)  
24e2 32 b6 fe			ld (debug_mark+2),a  
24e5 18 03			jr .pastdmark  
24e7 ..			.dmark: db "DUi"  
24ea f1			.pastdmark: pop af  
24eb			endm  
# End of macro DMARK
24eb					CALLMONITOR 
24eb cd c6 18			call break_point_state  
24ee				endm  
# End of macro CALLMONITOR
24ee				endif 
24ee			 
24ee cd 3a 1f				call forth_push_numhl 
24f1					NEXTW 
24f1 c3 e7 22			jp macro_next 
24f4				endm 
# End of macro NEXTW
24f4			.ZDUP: 
24f4				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
24f4 99				db WORD_SYS_CORE+OPCODE_ZDUP             
24f5 2c 25			dw .SWAP            
24f7 05				db 4 + 1 
24f8 .. 00			db "?DUP",0              
24fd				endm 
# End of macro CWHEAD
24fd			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
24fd			 
24fd					if DEBUG_FORTH_WORDS_KEY 
24fd						DMARK "qDU" 
24fd f5				push af  
24fe 3a 12 25			ld a, (.dmark)  
2501 32 b4 fe			ld (debug_mark),a  
2504 3a 13 25			ld a, (.dmark+1)  
2507 32 b5 fe			ld (debug_mark+1),a  
250a 3a 14 25			ld a, (.dmark+2)  
250d 32 b6 fe			ld (debug_mark+2),a  
2510 18 03			jr .pastdmark  
2512 ..			.dmark: db "qDU"  
2515 f1			.pastdmark: pop af  
2516			endm  
# End of macro DMARK
2516						CALLMONITOR 
2516 cd c6 18			call break_point_state  
2519				endm  
# End of macro CALLMONITOR
2519					endif 
2519					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2519 cd 31 21			call macro_dsp_valuehl 
251c				endm 
# End of macro FORTH_DSP_VALUEHL
251c			 
251c e5					push hl 
251d			 
251d					; is it a zero? 
251d			 
251d 3e 00				ld a, 0 
251f 84					add h 
2520 85					add l 
2521			 
2521 e1					pop hl 
2522			 
2522 fe 00				cp 0 
2524 28 03				jr z, .dup2orig 
2526			 
2526			 
2526 cd 3a 1f				call forth_push_numhl 
2529			 
2529			 
2529				; TODO add floating point number detection 
2529			 
2529			.dup2orig: 
2529			 
2529					NEXTW 
2529 c3 e7 22			jp macro_next 
252c				endm 
# End of macro NEXTW
252c			.SWAP: 
252c				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
252c 18				db WORD_SYS_CORE+OPCODE_SWAP             
252d 6b 25			dw .COLN            
252f 05				db 4 + 1 
2530 .. 00			db "SWAP",0              
2535				endm 
# End of macro CWHEAD
2535			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2535					if DEBUG_FORTH_WORDS_KEY 
2535						DMARK "SWP" 
2535 f5				push af  
2536 3a 4a 25			ld a, (.dmark)  
2539 32 b4 fe			ld (debug_mark),a  
253c 3a 4b 25			ld a, (.dmark+1)  
253f 32 b5 fe			ld (debug_mark+1),a  
2542 3a 4c 25			ld a, (.dmark+2)  
2545 32 b6 fe			ld (debug_mark+2),a  
2548 18 03			jr .pastdmark  
254a ..			.dmark: db "SWP"  
254d f1			.pastdmark: pop af  
254e			endm  
# End of macro DMARK
254e						CALLMONITOR 
254e cd c6 18			call break_point_state  
2551				endm  
# End of macro CALLMONITOR
2551					endif 
2551			 
2551					FORTH_DSP_VALUEHL 
2551 cd 31 21			call macro_dsp_valuehl 
2554				endm 
# End of macro FORTH_DSP_VALUEHL
2554 e5					push hl     ; w2 
2555			 
2555					FORTH_DSP_POP 
2555 cd e9 21			call macro_forth_dsp_pop 
2558				endm 
# End of macro FORTH_DSP_POP
2558			 
2558					FORTH_DSP_VALUEHL 
2558 cd 31 21			call macro_dsp_valuehl 
255b				endm 
# End of macro FORTH_DSP_VALUEHL
255b			 
255b					FORTH_DSP_POP 
255b cd e9 21			call macro_forth_dsp_pop 
255e				endm 
# End of macro FORTH_DSP_POP
255e			 
255e d1					pop de     ; w2	, hl = w1 
255f			 
255f eb					ex de, hl 
2560 d5					push de 
2561			 
2561 cd 3a 1f				call forth_push_numhl 
2564			 
2564 e1					pop hl 
2565			 
2565 cd 3a 1f				call forth_push_numhl 
2568					 
2568			 
2568					NEXTW 
2568 c3 e7 22			jp macro_next 
256b				endm 
# End of macro NEXTW
256b			.COLN: 
256b				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
256b 19				db WORD_SYS_CORE+OPCODE_COLN             
256c f7 26			dw .SCOLN            
256e 02				db 1 + 1 
256f .. 00			db ":",0              
2571				endm 
# End of macro CWHEAD
2571			; | : ( -- )         Create new word | DONE 
2571			 
2571					if DEBUG_FORTH_WORDS_KEY 
2571						DMARK "CLN" 
2571 f5				push af  
2572 3a 86 25			ld a, (.dmark)  
2575 32 b4 fe			ld (debug_mark),a  
2578 3a 87 25			ld a, (.dmark+1)  
257b 32 b5 fe			ld (debug_mark+1),a  
257e 3a 88 25			ld a, (.dmark+2)  
2581 32 b6 fe			ld (debug_mark+2),a  
2584 18 03			jr .pastdmark  
2586 ..			.dmark: db "CLN"  
2589 f1			.pastdmark: pop af  
258a			endm  
# End of macro DMARK
258a						CALLMONITOR 
258a cd c6 18			call break_point_state  
258d				endm  
# End of macro CALLMONITOR
258d					endif 
258d				STACKFRAME OFF $8efe $989f 
258d				if DEBUG_STACK_IMB 
258d					if OFF 
258d						exx 
258d						ld de, $8efe 
258d						ld a, d 
258d						ld hl, curframe 
258d						call hexout 
258d						ld a, e 
258d						ld hl, curframe+2 
258d						call hexout 
258d						ld hl, $8efe 
258d						push hl 
258d						ld hl, $989f 
258d						push hl 
258d						exx 
258d					endif 
258d				endif 
258d			endm 
# End of macro STACKFRAME
258d				; get parser buffer length  of new word 
258d			 
258d				 
258d			 
258d					; move tok past this to start of name defintition 
258d					; TODO get word to define 
258d					; TODO Move past word token 
258d					; TODO get length of string up to the ';' 
258d			 
258d 2a 4f f6			ld hl, (os_tok_ptr) 
2590 23				inc hl 
2591 23				inc hl 
2592			 
2592 3e 3b			ld a, ';' 
2594 cd b2 13			call strlent 
2597			 
2597 7d				ld a,l 
2598 32 4a f3			ld (os_new_parse_len), a 
259b			 
259b			 
259b			if DEBUG_FORTH_UWORD 
259b ed 5b 4f f6		ld de, (os_tok_ptr) 
259f						DMARK ":01" 
259f f5				push af  
25a0 3a b4 25			ld a, (.dmark)  
25a3 32 b4 fe			ld (debug_mark),a  
25a6 3a b5 25			ld a, (.dmark+1)  
25a9 32 b5 fe			ld (debug_mark+1),a  
25ac 3a b6 25			ld a, (.dmark+2)  
25af 32 b6 fe			ld (debug_mark+2),a  
25b2 18 03			jr .pastdmark  
25b4 ..			.dmark: db ":01"  
25b7 f1			.pastdmark: pop af  
25b8			endm  
# End of macro DMARK
25b8				CALLMONITOR 
25b8 cd c6 18			call break_point_state  
25bb				endm  
# End of macro CALLMONITOR
25bb			endif 
25bb			 
25bb			; 
25bb			;  new word memory layout: 
25bb			;  
25bb			;    : adg 6666 ;  
25bb			; 
25bb			;    db   1     ; user defined word  
25bb 23				inc hl    
25bc			;    dw   sysdict 
25bc 23				inc hl 
25bd 23				inc hl 
25be			;    db <word len>+1 (for null) 
25be 23				inc hl 
25bf			;    db .... <word> 
25bf			; 
25bf			 
25bf 23				inc hl    ; some extras for the word preamble before the above 
25c0 23				inc hl 
25c1 23				inc hl 
25c2 23				inc hl 
25c3 23				inc hl 
25c4 23				inc hl 
25c5 23				inc hl  
25c6 23				inc hl 
25c7 23				inc hl 
25c8 23				inc hl 
25c9 23				inc hl 
25ca 23				inc hl 
25cb 23				inc hl 
25cc 23				inc hl     ; TODO how many do we really need?     maybe only 6 
25cd			;       exec word buffer 
25cd			;	<ptr word>   
25cd 23				inc hl 
25ce 23				inc hl 
25cf			;       <word list><null term> 7F final term 
25cf			 
25cf			 
25cf			if DEBUG_FORTH_UWORD 
25cf						DMARK ":02" 
25cf f5				push af  
25d0 3a e4 25			ld a, (.dmark)  
25d3 32 b4 fe			ld (debug_mark),a  
25d6 3a e5 25			ld a, (.dmark+1)  
25d9 32 b5 fe			ld (debug_mark+1),a  
25dc 3a e6 25			ld a, (.dmark+2)  
25df 32 b6 fe			ld (debug_mark+2),a  
25e2 18 03			jr .pastdmark  
25e4 ..			.dmark: db ":02"  
25e7 f1			.pastdmark: pop af  
25e8			endm  
# End of macro DMARK
25e8				CALLMONITOR 
25e8 cd c6 18			call break_point_state  
25eb				endm  
# End of macro CALLMONITOR
25eb			endif 
25eb			 
25eb				 
25eb					; malloc the size 
25eb			 
25eb cd 10 14				call malloc 
25ee 22 4c f3				ld (os_new_malloc), hl     ; save malloc start 
25f1			 
25f1			;    db   1     ; user defined word  
25f1 3e 01				ld a, WORD_SYS_UWORD  
25f3 77					ld (hl), a 
25f4				 
25f4 23				inc hl    
25f5			;    dw   sysdict 
25f5 11 3f 24			ld de, sysdict       ; continue on with the scan to the system dict 
25f8 73				ld (hl), e 
25f9 23				inc hl 
25fa 72				ld (hl), d 
25fb 23				inc hl 
25fc			 
25fc			 
25fc			;    Setup dict word 
25fc			 
25fc 23				inc hl 
25fd 22 46 f3			ld (os_new_work_ptr), hl     ; save start of dict word  
2600			 
2600				; 1. get length of dict word 
2600			 
2600			 
2600 2a 4f f6			ld hl, (os_tok_ptr) 
2603 23				inc hl 
2604 23				inc hl    ; position to start of dict word 
2605 3e 00			ld a, 0 
2607 cd b2 13			call strlent 
260a			 
260a			 
260a 23				inc hl    ; to include null??? 
260b			 
260b				; write length of dict word 
260b			 
260b ed 5b 46 f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
260f 1b				dec de 
2610 eb				ex de, hl 
2611 73				ld (hl), e 
2612 eb				ex de, hl 
2613			 
2613				 
2613			 
2613				; copy  
2613 4d				ld c, l 
2614 06 00			ld b, 0 
2616 ed 5b 46 f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
261a 2a 4f f6			ld hl, (os_tok_ptr) 
261d 23				inc hl 
261e 23				inc hl    ; position to start of dict word 
261f				 
261f			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
261f				 
261f				; TODO need to convert word to upper case 
261f			 
261f			ucasetok:	 
261f 7e				ld a,(hl) 
2620 cd 9e 13			call toUpper 
2623 77				ld (hl),a 
2624 ed a0			ldi 
2626 f2 1f 26		 	jp p, ucasetok 
2629			 
2629			 
2629			 
2629				; de now points to start of where the word body code should be placed 
2629 ed 53 46 f3		ld (os_new_work_ptr), de 
262d				; hl now points to the words to throw at forthexec which needs to be copied 
262d 22 44 f3			ld (os_new_src_ptr), hl 
2630			 
2630				; TODO add 'call to forthexec' 
2630			 
2630			if DEBUG_FORTH_UWORD 
2630 c5				push bc 
2631 ed 4b 4c f3		ld bc, (os_new_malloc) 
2635						DMARK ":0x" 
2635 f5				push af  
2636 3a 4a 26			ld a, (.dmark)  
2639 32 b4 fe			ld (debug_mark),a  
263c 3a 4b 26			ld a, (.dmark+1)  
263f 32 b5 fe			ld (debug_mark+1),a  
2642 3a 4c 26			ld a, (.dmark+2)  
2645 32 b6 fe			ld (debug_mark+2),a  
2648 18 03			jr .pastdmark  
264a ..			.dmark: db ":0x"  
264d f1			.pastdmark: pop af  
264e			endm  
# End of macro DMARK
264e				CALLMONITOR 
264e cd c6 18			call break_point_state  
2651				endm  
# End of macro CALLMONITOR
2651 c1				pop bc 
2652			endif 
2652			 
2652			 
2652				; create word preamble which should be: 
2652			 
2652			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2652			 
2652				;    ld hl, <word code> 
2652				;    jp user_exec 
2652			        ;    <word code bytes> 
2652			 
2652			 
2652			;	inc de     ; TODO ??? or are we already past the word's null 
2652 eb				ex de, hl 
2653			 
2653 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2655			 
2655 23				inc hl 
2656 22 40 f3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2659 23				inc hl 
265a			 
265a 23				inc hl 
265b 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
265d			 
265d 01 f1 59			ld bc, user_exec 
2660 23				inc hl 
2661 71				ld (hl), c     ; poke address of user_exec 
2662 23				inc hl 
2663 70				ld (hl), b     
2664			 ; 
2664			;	inc hl 
2664			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2664			; 
2664			; 
2664			;	ld bc, macro_forth_rsp_next 
2664			;	inc hl 
2664			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2664			;	inc hl 
2664			;	ld (hl), b     
2664			 ; 
2664			;	inc hl 
2664			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2664			; 
2664			; 
2664			;	inc hl 
2664			;	ld bc, forthexec 
2664			;	ld (hl), c     ; poke address of forthexec 
2664			;	inc hl 
2664			;	ld (hl), b      
2664			; 
2664			;	inc hl 
2664			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2664			; 
2664			;	ld bc, user_dict_next 
2664			;	inc hl 
2664			;	ld (hl), c     ; poke address of forthexec 
2664			;	inc hl 
2664			;	ld (hl), b      
2664			 
2664				; hl is now where we need to copy the word byte data to save this 
2664			 
2664 23				inc hl 
2665 22 42 f3			ld (os_new_exec), hl 
2668				 
2668				; copy definition 
2668			 
2668 eb				ex de, hl 
2669			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2669			;	inc de    ; skip the PC for this parse 
2669 3a 4a f3			ld a, (os_new_parse_len) 
266c 4f				ld c, a 
266d 06 00			ld b, 0 
266f ed b0			ldir		 ; copy defintion 
2671			 
2671			 
2671				; poke the address of where the new word bytes live for forthexec 
2671			 
2671 2a 40 f3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2674			 
2674 ed 5b 42 f3		ld de, (os_new_exec)      
2678				 
2678 73				ld (hl), e 
2679 23				inc hl 
267a 72				ld (hl), d 
267b			 
267b					; TODO copy last user dict word next link to this word 
267b					; TODO update last user dict word to point to this word 
267b			; 
267b			; hl f923 de 812a ; bc 811a 
267b			 
267b			if DEBUG_FORTH_UWORD 
267b c5				push bc 
267c ed 4b 4c f3		ld bc, (os_new_malloc) 
2680						DMARK ":0A" 
2680 f5				push af  
2681 3a 95 26			ld a, (.dmark)  
2684 32 b4 fe			ld (debug_mark),a  
2687 3a 96 26			ld a, (.dmark+1)  
268a 32 b5 fe			ld (debug_mark+1),a  
268d 3a 97 26			ld a, (.dmark+2)  
2690 32 b6 fe			ld (debug_mark+2),a  
2693 18 03			jr .pastdmark  
2695 ..			.dmark: db ":0A"  
2698 f1			.pastdmark: pop af  
2699			endm  
# End of macro DMARK
2699				CALLMONITOR 
2699 cd c6 18			call break_point_state  
269c				endm  
# End of macro CALLMONITOR
269c c1				pop bc 
269d			endif 
269d			if DEBUG_FORTH_UWORD 
269d c5				push bc 
269e ed 4b 4c f3		ld bc, (os_new_malloc) 
26a2 03				inc bc 
26a3 03				inc bc 
26a4 03				inc bc 
26a5 03				inc bc 
26a6 03				inc bc 
26a7 03				inc bc 
26a8 03				inc bc 
26a9 03				inc bc 
26aa			 
26aa						DMARK ":0B" 
26aa f5				push af  
26ab 3a bf 26			ld a, (.dmark)  
26ae 32 b4 fe			ld (debug_mark),a  
26b1 3a c0 26			ld a, (.dmark+1)  
26b4 32 b5 fe			ld (debug_mark+1),a  
26b7 3a c1 26			ld a, (.dmark+2)  
26ba 32 b6 fe			ld (debug_mark+2),a  
26bd 18 03			jr .pastdmark  
26bf ..			.dmark: db ":0B"  
26c2 f1			.pastdmark: pop af  
26c3			endm  
# End of macro DMARK
26c3				CALLMONITOR 
26c3 cd c6 18			call break_point_state  
26c6				endm  
# End of macro CALLMONITOR
26c6 c1				pop bc 
26c7			endif 
26c7			 
26c7			; update word dict linked list for new word 
26c7			 
26c7			 
26c7 2a 4b f6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
26ca 23			inc hl     ; move to next work linked list ptr 
26cb			 
26cb ed 5b 4c f3	ld de, (os_new_malloc)		 ; new next word 
26cf 73			ld (hl), e 
26d0 23			inc hl 
26d1 72			ld (hl), d 
26d2			 
26d2			if DEBUG_FORTH_UWORD 
26d2 ed 4b 4b f6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
26d6			endif 
26d6			 
26d6 ed 53 4b f6	ld (os_last_new_uword), de      ; update last new uword ptr 
26da			 
26da			 
26da			if DEBUG_FORTH_UWORD 
26da						DMARK ":0+" 
26da f5				push af  
26db 3a ef 26			ld a, (.dmark)  
26de 32 b4 fe			ld (debug_mark),a  
26e1 3a f0 26			ld a, (.dmark+1)  
26e4 32 b5 fe			ld (debug_mark+1),a  
26e7 3a f1 26			ld a, (.dmark+2)  
26ea 32 b6 fe			ld (debug_mark+2),a  
26ed 18 03			jr .pastdmark  
26ef ..			.dmark: db ":0+"  
26f2 f1			.pastdmark: pop af  
26f3			endm  
# End of macro DMARK
26f3				CALLMONITOR 
26f3 cd c6 18			call break_point_state  
26f6				endm  
# End of macro CALLMONITOR
26f6			endif 
26f6			 
26f6				STACKFRAMECHK OFF $8efe $989f 
26f6				if DEBUG_STACK_IMB 
26f6					if OFF 
26f6						exx 
26f6						ld hl, $989f 
26f6						pop de   ; $989f 
26f6						call cmp16 
26f6						jr nz, .spnosame 
26f6						ld hl, $8efe 
26f6						pop de   ; $8efe 
26f6						call cmp16 
26f6						jr z, .spfrsame 
26f6						.spnosame: call showsperror 
26f6						.spfrsame: nop 
26f6						exx 
26f6					endif 
26f6				endif 
26f6			endm 
# End of macro STACKFRAMECHK
26f6			 
26f6 c9			ret    ; dont process any remaining parser tokens as they form new word 
26f7			 
26f7			 
26f7			 
26f7			 
26f7			;		NEXT 
26f7			.SCOLN: 
26f7			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
26f7 06				db OPCODE_SCOLN 
26f8 43 27			dw .DROP 
26fa 02				db 2 
26fb .. 00			db ";",0           
26fd			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
26fd					if DEBUG_FORTH_WORDS_KEY 
26fd						DMARK "SCN" 
26fd f5				push af  
26fe 3a 12 27			ld a, (.dmark)  
2701 32 b4 fe			ld (debug_mark),a  
2704 3a 13 27			ld a, (.dmark+1)  
2707 32 b5 fe			ld (debug_mark+1),a  
270a 3a 14 27			ld a, (.dmark+2)  
270d 32 b6 fe			ld (debug_mark+2),a  
2710 18 03			jr .pastdmark  
2712 ..			.dmark: db "SCN"  
2715 f1			.pastdmark: pop af  
2716			endm  
# End of macro DMARK
2716						CALLMONITOR 
2716 cd c6 18			call break_point_state  
2719				endm  
# End of macro CALLMONITOR
2719					endif 
2719					FORTH_RSP_TOS 
2719 cd f8 1e			call macro_forth_rsp_tos 
271c				endm 
# End of macro FORTH_RSP_TOS
271c e5					push hl 
271d					FORTH_RSP_POP 
271d cd 02 1f			call macro_forth_rsp_pop 
2720				endm 
# End of macro FORTH_RSP_POP
2720 e1					pop hl 
2721			;		ex de,hl 
2721 22 4f f6				ld (os_tok_ptr),hl 
2724			 
2724			if DEBUG_FORTH_UWORD 
2724						DMARK "SCL" 
2724 f5				push af  
2725 3a 39 27			ld a, (.dmark)  
2728 32 b4 fe			ld (debug_mark),a  
272b 3a 3a 27			ld a, (.dmark+1)  
272e 32 b5 fe			ld (debug_mark+1),a  
2731 3a 3b 27			ld a, (.dmark+2)  
2734 32 b6 fe			ld (debug_mark+2),a  
2737 18 03			jr .pastdmark  
2739 ..			.dmark: db "SCL"  
273c f1			.pastdmark: pop af  
273d			endm  
# End of macro DMARK
273d				CALLMONITOR 
273d cd c6 18			call break_point_state  
2740				endm  
# End of macro CALLMONITOR
2740			endif 
2740					NEXTW 
2740 c3 e7 22			jp macro_next 
2743				endm 
# End of macro NEXTW
2743			 
2743			.DROP: 
2743				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2743 1b				db WORD_SYS_CORE+OPCODE_DROP             
2744 6e 27			dw .DUP2            
2746 05				db 4 + 1 
2747 .. 00			db "DROP",0              
274c				endm 
# End of macro CWHEAD
274c			; | DROP ( w -- )   drop the TOS item   | DONE 
274c					if DEBUG_FORTH_WORDS_KEY 
274c						DMARK "DRP" 
274c f5				push af  
274d 3a 61 27			ld a, (.dmark)  
2750 32 b4 fe			ld (debug_mark),a  
2753 3a 62 27			ld a, (.dmark+1)  
2756 32 b5 fe			ld (debug_mark+1),a  
2759 3a 63 27			ld a, (.dmark+2)  
275c 32 b6 fe			ld (debug_mark+2),a  
275f 18 03			jr .pastdmark  
2761 ..			.dmark: db "DRP"  
2764 f1			.pastdmark: pop af  
2765			endm  
# End of macro DMARK
2765						CALLMONITOR 
2765 cd c6 18			call break_point_state  
2768				endm  
# End of macro CALLMONITOR
2768					endif 
2768					FORTH_DSP_POP 
2768 cd e9 21			call macro_forth_dsp_pop 
276b				endm 
# End of macro FORTH_DSP_POP
276b					NEXTW 
276b c3 e7 22			jp macro_next 
276e				endm 
# End of macro NEXTW
276e			.DUP2: 
276e				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
276e 1c				db WORD_SYS_CORE+OPCODE_DUP2             
276f b3 27			dw .DROP2            
2771 05				db 4 + 1 
2772 .. 00			db "2DUP",0              
2777				endm 
# End of macro CWHEAD
2777			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2777					if DEBUG_FORTH_WORDS_KEY 
2777						DMARK "2DU" 
2777 f5				push af  
2778 3a 8c 27			ld a, (.dmark)  
277b 32 b4 fe			ld (debug_mark),a  
277e 3a 8d 27			ld a, (.dmark+1)  
2781 32 b5 fe			ld (debug_mark+1),a  
2784 3a 8e 27			ld a, (.dmark+2)  
2787 32 b6 fe			ld (debug_mark+2),a  
278a 18 03			jr .pastdmark  
278c ..			.dmark: db "2DU"  
278f f1			.pastdmark: pop af  
2790			endm  
# End of macro DMARK
2790						CALLMONITOR 
2790 cd c6 18			call break_point_state  
2793				endm  
# End of macro CALLMONITOR
2793					endif 
2793					FORTH_DSP_VALUEHL 
2793 cd 31 21			call macro_dsp_valuehl 
2796				endm 
# End of macro FORTH_DSP_VALUEHL
2796 e5					push hl      ; 2 
2797			 
2797					FORTH_DSP_POP 
2797 cd e9 21			call macro_forth_dsp_pop 
279a				endm 
# End of macro FORTH_DSP_POP
279a					 
279a					FORTH_DSP_VALUEHL 
279a cd 31 21			call macro_dsp_valuehl 
279d				endm 
# End of macro FORTH_DSP_VALUEHL
279d			;		push hl      ; 1 
279d			 
279d					FORTH_DSP_POP 
279d cd e9 21			call macro_forth_dsp_pop 
27a0				endm 
# End of macro FORTH_DSP_POP
27a0			 
27a0			;		pop hl       ; 1 
27a0 d1					pop de       ; 2 
27a1			 
27a1 cd 3a 1f				call forth_push_numhl 
27a4 eb					ex de, hl 
27a5 cd 3a 1f				call forth_push_numhl 
27a8			 
27a8					 
27a8 eb					ex de, hl 
27a9			 
27a9 cd 3a 1f				call forth_push_numhl 
27ac eb					ex de, hl 
27ad cd 3a 1f				call forth_push_numhl 
27b0			 
27b0			 
27b0					NEXTW 
27b0 c3 e7 22			jp macro_next 
27b3				endm 
# End of macro NEXTW
27b3			.DROP2: 
27b3				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
27b3 1d				db WORD_SYS_CORE+OPCODE_DROP2             
27b4 e2 27			dw .SWAP2            
27b6 06				db 5 + 1 
27b7 .. 00			db "2DROP",0              
27bd				endm 
# End of macro CWHEAD
27bd			; | 2DROP ( w w -- )    Double drop | DONE 
27bd					if DEBUG_FORTH_WORDS_KEY 
27bd						DMARK "2DR" 
27bd f5				push af  
27be 3a d2 27			ld a, (.dmark)  
27c1 32 b4 fe			ld (debug_mark),a  
27c4 3a d3 27			ld a, (.dmark+1)  
27c7 32 b5 fe			ld (debug_mark+1),a  
27ca 3a d4 27			ld a, (.dmark+2)  
27cd 32 b6 fe			ld (debug_mark+2),a  
27d0 18 03			jr .pastdmark  
27d2 ..			.dmark: db "2DR"  
27d5 f1			.pastdmark: pop af  
27d6			endm  
# End of macro DMARK
27d6						CALLMONITOR 
27d6 cd c6 18			call break_point_state  
27d9				endm  
# End of macro CALLMONITOR
27d9					endif 
27d9					FORTH_DSP_POP 
27d9 cd e9 21			call macro_forth_dsp_pop 
27dc				endm 
# End of macro FORTH_DSP_POP
27dc					FORTH_DSP_POP 
27dc cd e9 21			call macro_forth_dsp_pop 
27df				endm 
# End of macro FORTH_DSP_POP
27df					NEXTW 
27df c3 e7 22			jp macro_next 
27e2				endm 
# End of macro NEXTW
27e2			.SWAP2: 
27e2				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
27e2 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
27e3 0b 28			dw .AT            
27e5 06				db 5 + 1 
27e6 .. 00			db "2SWAP",0              
27ec				endm 
# End of macro CWHEAD
27ec			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
27ec					if DEBUG_FORTH_WORDS_KEY 
27ec						DMARK "2SW" 
27ec f5				push af  
27ed 3a 01 28			ld a, (.dmark)  
27f0 32 b4 fe			ld (debug_mark),a  
27f3 3a 02 28			ld a, (.dmark+1)  
27f6 32 b5 fe			ld (debug_mark+1),a  
27f9 3a 03 28			ld a, (.dmark+2)  
27fc 32 b6 fe			ld (debug_mark+2),a  
27ff 18 03			jr .pastdmark  
2801 ..			.dmark: db "2SW"  
2804 f1			.pastdmark: pop af  
2805			endm  
# End of macro DMARK
2805						CALLMONITOR 
2805 cd c6 18			call break_point_state  
2808				endm  
# End of macro CALLMONITOR
2808					endif 
2808					NEXTW 
2808 c3 e7 22			jp macro_next 
280b				endm 
# End of macro NEXTW
280b			.AT: 
280b				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
280b 1f				db WORD_SYS_CORE+OPCODE_AT             
280c 3d 28			dw .CAT            
280e 02				db 1 + 1 
280f .. 00			db "@",0              
2811				endm 
# End of macro CWHEAD
2811			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2811			 
2811					if DEBUG_FORTH_WORDS_KEY 
2811						DMARK "AT." 
2811 f5				push af  
2812 3a 26 28			ld a, (.dmark)  
2815 32 b4 fe			ld (debug_mark),a  
2818 3a 27 28			ld a, (.dmark+1)  
281b 32 b5 fe			ld (debug_mark+1),a  
281e 3a 28 28			ld a, (.dmark+2)  
2821 32 b6 fe			ld (debug_mark+2),a  
2824 18 03			jr .pastdmark  
2826 ..			.dmark: db "AT."  
2829 f1			.pastdmark: pop af  
282a			endm  
# End of macro DMARK
282a						CALLMONITOR 
282a cd c6 18			call break_point_state  
282d				endm  
# End of macro CALLMONITOR
282d					endif 
282d			.getbyteat:	 
282d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
282d cd 31 21			call macro_dsp_valuehl 
2830				endm 
# End of macro FORTH_DSP_VALUEHL
2830					 
2830			;		push hl 
2830				 
2830					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2830 cd e9 21			call macro_forth_dsp_pop 
2833				endm 
# End of macro FORTH_DSP_POP
2833			 
2833			;		pop hl 
2833			 
2833 7e					ld a, (hl) 
2834			 
2834 6f					ld l, a 
2835 26 00				ld h, 0 
2837 cd 3a 1f				call forth_push_numhl 
283a			 
283a					NEXTW 
283a c3 e7 22			jp macro_next 
283d				endm 
# End of macro NEXTW
283d			.CAT: 
283d				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
283d 20				db WORD_SYS_CORE+OPCODE_CAT             
283e 66 28			dw .BANG            
2840 03				db 2 + 1 
2841 .. 00			db "C@",0              
2844				endm 
# End of macro CWHEAD
2844			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2844					if DEBUG_FORTH_WORDS_KEY 
2844						DMARK "CAA" 
2844 f5				push af  
2845 3a 59 28			ld a, (.dmark)  
2848 32 b4 fe			ld (debug_mark),a  
284b 3a 5a 28			ld a, (.dmark+1)  
284e 32 b5 fe			ld (debug_mark+1),a  
2851 3a 5b 28			ld a, (.dmark+2)  
2854 32 b6 fe			ld (debug_mark+2),a  
2857 18 03			jr .pastdmark  
2859 ..			.dmark: db "CAA"  
285c f1			.pastdmark: pop af  
285d			endm  
# End of macro DMARK
285d						CALLMONITOR 
285d cd c6 18			call break_point_state  
2860				endm  
# End of macro CALLMONITOR
2860					endif 
2860 c3 2d 28				jp .getbyteat 
2863					NEXTW 
2863 c3 e7 22			jp macro_next 
2866				endm 
# End of macro NEXTW
2866			.BANG: 
2866				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2866 21				db WORD_SYS_CORE+OPCODE_BANG             
2867 9c 28			dw .CBANG            
2869 02				db 1 + 1 
286a .. 00			db "!",0              
286c				endm 
# End of macro CWHEAD
286c			; | ! ( x w -- ) Store x at address w      | DONE 
286c					if DEBUG_FORTH_WORDS_KEY 
286c						DMARK "BNG" 
286c f5				push af  
286d 3a 81 28			ld a, (.dmark)  
2870 32 b4 fe			ld (debug_mark),a  
2873 3a 82 28			ld a, (.dmark+1)  
2876 32 b5 fe			ld (debug_mark+1),a  
2879 3a 83 28			ld a, (.dmark+2)  
287c 32 b6 fe			ld (debug_mark+2),a  
287f 18 03			jr .pastdmark  
2881 ..			.dmark: db "BNG"  
2884 f1			.pastdmark: pop af  
2885			endm  
# End of macro DMARK
2885						CALLMONITOR 
2885 cd c6 18			call break_point_state  
2888				endm  
# End of macro CALLMONITOR
2888					endif 
2888			 
2888			.storebyteat:		 
2888					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2888 cd 31 21			call macro_dsp_valuehl 
288b				endm 
# End of macro FORTH_DSP_VALUEHL
288b					 
288b e5					push hl 
288c				 
288c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
288c cd e9 21			call macro_forth_dsp_pop 
288f				endm 
# End of macro FORTH_DSP_POP
288f			 
288f					; get byte to poke 
288f			 
288f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
288f cd 31 21			call macro_dsp_valuehl 
2892				endm 
# End of macro FORTH_DSP_VALUEHL
2892 e5					push hl 
2893			 
2893			 
2893					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2893 cd e9 21			call macro_forth_dsp_pop 
2896				endm 
# End of macro FORTH_DSP_POP
2896			 
2896			 
2896 d1					pop de 
2897 e1					pop hl 
2898			 
2898 73					ld (hl),e 
2899			 
2899			 
2899					NEXTW 
2899 c3 e7 22			jp macro_next 
289c				endm 
# End of macro NEXTW
289c			.CBANG: 
289c				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
289c 22				db WORD_SYS_CORE+OPCODE_CBANG             
289d c5 28			dw .SCALL            
289f 03				db 2 + 1 
28a0 .. 00			db "C!",0              
28a3				endm 
# End of macro CWHEAD
28a3			; | C!  ( x w -- ) Store x at address w  | DONE 
28a3					if DEBUG_FORTH_WORDS_KEY 
28a3						DMARK "CBA" 
28a3 f5				push af  
28a4 3a b8 28			ld a, (.dmark)  
28a7 32 b4 fe			ld (debug_mark),a  
28aa 3a b9 28			ld a, (.dmark+1)  
28ad 32 b5 fe			ld (debug_mark+1),a  
28b0 3a ba 28			ld a, (.dmark+2)  
28b3 32 b6 fe			ld (debug_mark+2),a  
28b6 18 03			jr .pastdmark  
28b8 ..			.dmark: db "CBA"  
28bb f1			.pastdmark: pop af  
28bc			endm  
# End of macro DMARK
28bc						CALLMONITOR 
28bc cd c6 18			call break_point_state  
28bf				endm  
# End of macro CALLMONITOR
28bf					endif 
28bf c3 88 28				jp .storebyteat 
28c2					NEXTW 
28c2 c3 e7 22			jp macro_next 
28c5				endm 
# End of macro NEXTW
28c5			.SCALL: 
28c5				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
28c5 23				db WORD_SYS_CORE+OPCODE_SCALL             
28c6 f9 28			dw .DEPTH            
28c8 05				db 4 + 1 
28c9 .. 00			db "CALL",0              
28ce				endm 
# End of macro CWHEAD
28ce			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
28ce					if DEBUG_FORTH_WORDS_KEY 
28ce						DMARK "CLL" 
28ce f5				push af  
28cf 3a e3 28			ld a, (.dmark)  
28d2 32 b4 fe			ld (debug_mark),a  
28d5 3a e4 28			ld a, (.dmark+1)  
28d8 32 b5 fe			ld (debug_mark+1),a  
28db 3a e5 28			ld a, (.dmark+2)  
28de 32 b6 fe			ld (debug_mark+2),a  
28e1 18 03			jr .pastdmark  
28e3 ..			.dmark: db "CLL"  
28e6 f1			.pastdmark: pop af  
28e7			endm  
# End of macro DMARK
28e7						CALLMONITOR 
28e7 cd c6 18			call break_point_state  
28ea				endm  
# End of macro CALLMONITOR
28ea					endif 
28ea			 
28ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28ea cd 31 21			call macro_dsp_valuehl 
28ed				endm 
# End of macro FORTH_DSP_VALUEHL
28ed			 
28ed			;		push hl 
28ed			 
28ed					; destroy value TOS 
28ed			 
28ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28ed cd e9 21			call macro_forth_dsp_pop 
28f0				endm 
# End of macro FORTH_DSP_POP
28f0			 
28f0						 
28f0			;		pop hl 
28f0			 
28f0					; how to do a call with hl???? save SP? 
28f0 cd 8b 22				call forth_call_hl 
28f3			 
28f3			 
28f3					; TODO push value back onto stack for another op etc 
28f3			 
28f3 cd 3a 1f				call forth_push_numhl 
28f6					NEXTW 
28f6 c3 e7 22			jp macro_next 
28f9				endm 
# End of macro NEXTW
28f9			.DEPTH: 
28f9				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
28f9 24				db WORD_SYS_CORE+OPCODE_DEPTH             
28fa 36 29			dw .OVER            
28fc 06				db 5 + 1 
28fd .. 00			db "DEPTH",0              
2903				endm 
# End of macro CWHEAD
2903			; | DEPTH ( -- u ) Push count of stack | DONE 
2903					; take current TOS and remove from base value div by two to get count 
2903					if DEBUG_FORTH_WORDS_KEY 
2903						DMARK "DEP" 
2903 f5				push af  
2904 3a 18 29			ld a, (.dmark)  
2907 32 b4 fe			ld (debug_mark),a  
290a 3a 19 29			ld a, (.dmark+1)  
290d 32 b5 fe			ld (debug_mark+1),a  
2910 3a 1a 29			ld a, (.dmark+2)  
2913 32 b6 fe			ld (debug_mark+2),a  
2916 18 03			jr .pastdmark  
2918 ..			.dmark: db "DEP"  
291b f1			.pastdmark: pop af  
291c			endm  
# End of macro DMARK
291c						CALLMONITOR 
291c cd c6 18			call break_point_state  
291f				endm  
# End of macro CALLMONITOR
291f					endif 
291f			 
291f			 
291f 2a 7b fb			ld hl, (cli_data_sp) 
2922 11 b5 f8			ld de, cli_data_stack 
2925 ed 52			sbc hl,de 
2927				 
2927				; div by size of stack item 
2927			 
2927 5d				ld e,l 
2928 0e 03			ld c, 3 
292a cd d9 0e			call Div8 
292d			 
292d 6f				ld l,a 
292e 26 00			ld h,0 
2930			 
2930				;srl h 
2930				;rr l 
2930			 
2930 cd 3a 1f				call forth_push_numhl 
2933					NEXTW 
2933 c3 e7 22			jp macro_next 
2936				endm 
# End of macro NEXTW
2936			.OVER: 
2936				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2936 42				db WORD_SYS_CORE+46             
2937 7d 29			dw .PAUSE            
2939 05				db 4 + 1 
293a .. 00			db "OVER",0              
293f				endm 
# End of macro CWHEAD
293f			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
293f					if DEBUG_FORTH_WORDS_KEY 
293f						DMARK "OVR" 
293f f5				push af  
2940 3a 54 29			ld a, (.dmark)  
2943 32 b4 fe			ld (debug_mark),a  
2946 3a 55 29			ld a, (.dmark+1)  
2949 32 b5 fe			ld (debug_mark+1),a  
294c 3a 56 29			ld a, (.dmark+2)  
294f 32 b6 fe			ld (debug_mark+2),a  
2952 18 03			jr .pastdmark  
2954 ..			.dmark: db "OVR"  
2957 f1			.pastdmark: pop af  
2958			endm  
# End of macro DMARK
2958						CALLMONITOR 
2958 cd c6 18			call break_point_state  
295b				endm  
# End of macro CALLMONITOR
295b					endif 
295b			 
295b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
295b cd 31 21			call macro_dsp_valuehl 
295e				endm 
# End of macro FORTH_DSP_VALUEHL
295e e5					push hl    ; n2 
295f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
295f cd e9 21			call macro_forth_dsp_pop 
2962				endm 
# End of macro FORTH_DSP_POP
2962			 
2962					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2962 cd 31 21			call macro_dsp_valuehl 
2965				endm 
# End of macro FORTH_DSP_VALUEHL
2965 e5					push hl    ; n1 
2966					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2966 cd e9 21			call macro_forth_dsp_pop 
2969				endm 
# End of macro FORTH_DSP_POP
2969			 
2969 d1					pop de     ; n1 
296a e1					pop hl     ; n2 
296b			 
296b d5					push de 
296c e5					push hl 
296d d5					push de 
296e			 
296e					; push back  
296e			 
296e e1					pop hl 
296f cd 3a 1f				call forth_push_numhl 
2972 e1					pop hl 
2973 cd 3a 1f				call forth_push_numhl 
2976 e1					pop hl 
2977 cd 3a 1f				call forth_push_numhl 
297a					NEXTW 
297a c3 e7 22			jp macro_next 
297d				endm 
# End of macro NEXTW
297d			 
297d			.PAUSE: 
297d				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
297d 43				db WORD_SYS_CORE+47             
297e b2 29			dw .PAUSES            
2980 08				db 7 + 1 
2981 .. 00			db "PAUSEMS",0              
2989				endm 
# End of macro CWHEAD
2989			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2989					if DEBUG_FORTH_WORDS_KEY 
2989						DMARK "PMS" 
2989 f5				push af  
298a 3a 9e 29			ld a, (.dmark)  
298d 32 b4 fe			ld (debug_mark),a  
2990 3a 9f 29			ld a, (.dmark+1)  
2993 32 b5 fe			ld (debug_mark+1),a  
2996 3a a0 29			ld a, (.dmark+2)  
2999 32 b6 fe			ld (debug_mark+2),a  
299c 18 03			jr .pastdmark  
299e ..			.dmark: db "PMS"  
29a1 f1			.pastdmark: pop af  
29a2			endm  
# End of macro DMARK
29a2						CALLMONITOR 
29a2 cd c6 18			call break_point_state  
29a5				endm  
# End of macro CALLMONITOR
29a5					endif 
29a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29a5 cd 31 21			call macro_dsp_valuehl 
29a8				endm 
# End of macro FORTH_DSP_VALUEHL
29a8			;		push hl    ; n2 
29a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29a8 cd e9 21			call macro_forth_dsp_pop 
29ab				endm 
# End of macro FORTH_DSP_POP
29ab			;		pop hl 
29ab			 
29ab 7d					ld a, l 
29ac cd 77 0c				call aDelayInMS 
29af				       NEXTW 
29af c3 e7 22			jp macro_next 
29b2				endm 
# End of macro NEXTW
29b2			.PAUSES:  
29b2				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
29b2 44				db WORD_SYS_CORE+48             
29b3 21 2a			dw .ROT            
29b5 06				db 5 + 1 
29b6 .. 00			db "PAUSE",0              
29bc				endm 
# End of macro CWHEAD
29bc			; | PAUSE ( n -- )  Pause for n seconds | DONE 
29bc					if DEBUG_FORTH_WORDS_KEY 
29bc						DMARK "PAU" 
29bc f5				push af  
29bd 3a d1 29			ld a, (.dmark)  
29c0 32 b4 fe			ld (debug_mark),a  
29c3 3a d2 29			ld a, (.dmark+1)  
29c6 32 b5 fe			ld (debug_mark+1),a  
29c9 3a d3 29			ld a, (.dmark+2)  
29cc 32 b6 fe			ld (debug_mark+2),a  
29cf 18 03			jr .pastdmark  
29d1 ..			.dmark: db "PAU"  
29d4 f1			.pastdmark: pop af  
29d5			endm  
# End of macro DMARK
29d5						CALLMONITOR 
29d5 cd c6 18			call break_point_state  
29d8				endm  
# End of macro CALLMONITOR
29d8					endif 
29d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d8 cd 31 21			call macro_dsp_valuehl 
29db				endm 
# End of macro FORTH_DSP_VALUEHL
29db			;		push hl    ; n2 
29db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29db cd e9 21			call macro_forth_dsp_pop 
29de				endm 
# End of macro FORTH_DSP_POP
29de			;		pop hl 
29de 45					ld b, l 
29df					if DEBUG_FORTH_WORDS 
29df						DMARK "PAU" 
29df f5				push af  
29e0 3a f4 29			ld a, (.dmark)  
29e3 32 b4 fe			ld (debug_mark),a  
29e6 3a f5 29			ld a, (.dmark+1)  
29e9 32 b5 fe			ld (debug_mark+1),a  
29ec 3a f6 29			ld a, (.dmark+2)  
29ef 32 b6 fe			ld (debug_mark+2),a  
29f2 18 03			jr .pastdmark  
29f4 ..			.dmark: db "PAU"  
29f7 f1			.pastdmark: pop af  
29f8			endm  
# End of macro DMARK
29f8						CALLMONITOR 
29f8 cd c6 18			call break_point_state  
29fb				endm  
# End of macro CALLMONITOR
29fb					endif 
29fb c5			.pauses1:	push bc 
29fc cd 92 0c				call delay1s 
29ff c1					pop bc 
2a00					if DEBUG_FORTH_WORDS 
2a00						DMARK "PA1" 
2a00 f5				push af  
2a01 3a 15 2a			ld a, (.dmark)  
2a04 32 b4 fe			ld (debug_mark),a  
2a07 3a 16 2a			ld a, (.dmark+1)  
2a0a 32 b5 fe			ld (debug_mark+1),a  
2a0d 3a 17 2a			ld a, (.dmark+2)  
2a10 32 b6 fe			ld (debug_mark+2),a  
2a13 18 03			jr .pastdmark  
2a15 ..			.dmark: db "PA1"  
2a18 f1			.pastdmark: pop af  
2a19			endm  
# End of macro DMARK
2a19						CALLMONITOR 
2a19 cd c6 18			call break_point_state  
2a1c				endm  
# End of macro CALLMONITOR
2a1c					endif 
2a1c 10 dd				djnz .pauses1 
2a1e			 
2a1e				       NEXTW 
2a1e c3 e7 22			jp macro_next 
2a21				endm 
# End of macro NEXTW
2a21			.ROT: 
2a21				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2a21 45				db WORD_SYS_CORE+49             
2a22 6f 2a			dw .UWORDS            
2a24 04				db 3 + 1 
2a25 .. 00			db "ROT",0              
2a29				endm 
# End of macro CWHEAD
2a29			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2a29					if DEBUG_FORTH_WORDS_KEY 
2a29						DMARK "ROT" 
2a29 f5				push af  
2a2a 3a 3e 2a			ld a, (.dmark)  
2a2d 32 b4 fe			ld (debug_mark),a  
2a30 3a 3f 2a			ld a, (.dmark+1)  
2a33 32 b5 fe			ld (debug_mark+1),a  
2a36 3a 40 2a			ld a, (.dmark+2)  
2a39 32 b6 fe			ld (debug_mark+2),a  
2a3c 18 03			jr .pastdmark  
2a3e ..			.dmark: db "ROT"  
2a41 f1			.pastdmark: pop af  
2a42			endm  
# End of macro DMARK
2a42						CALLMONITOR 
2a42 cd c6 18			call break_point_state  
2a45				endm  
# End of macro CALLMONITOR
2a45					endif 
2a45			 
2a45					FORTH_DSP_VALUEHL 
2a45 cd 31 21			call macro_dsp_valuehl 
2a48				endm 
# End of macro FORTH_DSP_VALUEHL
2a48 e5					push hl    ; u3  
2a49			 
2a49					FORTH_DSP_POP 
2a49 cd e9 21			call macro_forth_dsp_pop 
2a4c				endm 
# End of macro FORTH_DSP_POP
2a4c			   
2a4c					FORTH_DSP_VALUEHL 
2a4c cd 31 21			call macro_dsp_valuehl 
2a4f				endm 
# End of macro FORTH_DSP_VALUEHL
2a4f e5					push hl     ; u2 
2a50			 
2a50					FORTH_DSP_POP 
2a50 cd e9 21			call macro_forth_dsp_pop 
2a53				endm 
# End of macro FORTH_DSP_POP
2a53			 
2a53					FORTH_DSP_VALUEHL 
2a53 cd 31 21			call macro_dsp_valuehl 
2a56				endm 
# End of macro FORTH_DSP_VALUEHL
2a56 e5					push hl     ; u1 
2a57			 
2a57					FORTH_DSP_POP 
2a57 cd e9 21			call macro_forth_dsp_pop 
2a5a				endm 
# End of macro FORTH_DSP_POP
2a5a			 
2a5a c1					pop bc      ; u1 
2a5b e1					pop hl      ; u2 
2a5c d1					pop de      ; u3 
2a5d			 
2a5d			 
2a5d c5					push bc 
2a5e d5					push de 
2a5f e5					push hl 
2a60			 
2a60			 
2a60 e1					pop hl 
2a61 cd 3a 1f				call forth_push_numhl 
2a64			 
2a64 e1					pop hl 
2a65 cd 3a 1f				call forth_push_numhl 
2a68			 
2a68 e1					pop hl 
2a69 cd 3a 1f				call forth_push_numhl 
2a6c					 
2a6c			 
2a6c			 
2a6c			 
2a6c			 
2a6c			 
2a6c				       NEXTW 
2a6c c3 e7 22			jp macro_next 
2a6f				endm 
# End of macro NEXTW
2a6f			 
2a6f			.UWORDS: 
2a6f				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2a6f 50				db WORD_SYS_CORE+60             
2a70 31 2b			dw .BP            
2a72 07				db 6 + 1 
2a73 .. 00			db "UWORDS",0              
2a7a				endm 
# End of macro CWHEAD
2a7a			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2a7a			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2a7a			; | | Following the count are the individual words. 
2a7a			; | | 
2a7a			; | | e.g. UWORDS 
2a7a			; | | BOX DIRLIST 2 
2a7a			; | |  
2a7a			; | | Can be used to save the words to storage via: 
2a7a			; | | UWORDS $01 DO $01 APPEND LOOP 
2a7a				if DEBUG_FORTH_WORDS_KEY 
2a7a					DMARK "UWR" 
2a7a f5				push af  
2a7b 3a 8f 2a			ld a, (.dmark)  
2a7e 32 b4 fe			ld (debug_mark),a  
2a81 3a 90 2a			ld a, (.dmark+1)  
2a84 32 b5 fe			ld (debug_mark+1),a  
2a87 3a 91 2a			ld a, (.dmark+2)  
2a8a 32 b6 fe			ld (debug_mark+2),a  
2a8d 18 03			jr .pastdmark  
2a8f ..			.dmark: db "UWR"  
2a92 f1			.pastdmark: pop af  
2a93			endm  
# End of macro DMARK
2a93					CALLMONITOR 
2a93 cd c6 18			call break_point_state  
2a96				endm  
# End of macro CALLMONITOR
2a96				endif 
2a96 21 00 80				ld hl, baseram 
2a99					;ld hl, baseusermem 
2a99 01 00 00				ld bc, 0    ; start a counter 
2a9c			 
2a9c				; skip dict stub 
2a9c			 
2a9c cd 38 24				call forth_tok_next 
2a9f			 
2a9f			 
2a9f			; while we have words to look for 
2a9f			 
2a9f 7e			.douscan:	ld a, (hl)      
2aa0				if DEBUG_FORTH_WORDS 
2aa0					DMARK "UWs" 
2aa0 f5				push af  
2aa1 3a b5 2a			ld a, (.dmark)  
2aa4 32 b4 fe			ld (debug_mark),a  
2aa7 3a b6 2a			ld a, (.dmark+1)  
2aaa 32 b5 fe			ld (debug_mark+1),a  
2aad 3a b7 2a			ld a, (.dmark+2)  
2ab0 32 b6 fe			ld (debug_mark+2),a  
2ab3 18 03			jr .pastdmark  
2ab5 ..			.dmark: db "UWs"  
2ab8 f1			.pastdmark: pop af  
2ab9			endm  
# End of macro DMARK
2ab9					CALLMONITOR 
2ab9 cd c6 18			call break_point_state  
2abc				endm  
# End of macro CALLMONITOR
2abc				endif 
2abc fe 00				cp WORD_SYS_END 
2abe 28 4d				jr z, .udone 
2ac0 fe 01				cp WORD_SYS_UWORD 
2ac2 20 44				jr nz, .nuword 
2ac4			 
2ac4				if DEBUG_FORTH_WORDS 
2ac4					DMARK "UWu" 
2ac4 f5				push af  
2ac5 3a d9 2a			ld a, (.dmark)  
2ac8 32 b4 fe			ld (debug_mark),a  
2acb 3a da 2a			ld a, (.dmark+1)  
2ace 32 b5 fe			ld (debug_mark+1),a  
2ad1 3a db 2a			ld a, (.dmark+2)  
2ad4 32 b6 fe			ld (debug_mark+2),a  
2ad7 18 03			jr .pastdmark  
2ad9 ..			.dmark: db "UWu"  
2adc f1			.pastdmark: pop af  
2add			endm  
# End of macro DMARK
2add					CALLMONITOR 
2add cd c6 18			call break_point_state  
2ae0				endm  
# End of macro CALLMONITOR
2ae0				endif 
2ae0					; we have a uword so push its name to the stack 
2ae0			 
2ae0 e5				   	push hl  ; save so we can move to next dict block 
2ae1			 
2ae1					; skip opcode 
2ae1 23					inc hl  
2ae2					; skip next ptr 
2ae2 23					inc hl  
2ae3 23					inc hl 
2ae4					; skip len 
2ae4 23					inc hl 
2ae5				if DEBUG_FORTH_WORDS 
2ae5					DMARK "UWt" 
2ae5 f5				push af  
2ae6 3a fa 2a			ld a, (.dmark)  
2ae9 32 b4 fe			ld (debug_mark),a  
2aec 3a fb 2a			ld a, (.dmark+1)  
2aef 32 b5 fe			ld (debug_mark+1),a  
2af2 3a fc 2a			ld a, (.dmark+2)  
2af5 32 b6 fe			ld (debug_mark+2),a  
2af8 18 03			jr .pastdmark  
2afa ..			.dmark: db "UWt"  
2afd f1			.pastdmark: pop af  
2afe			endm  
# End of macro DMARK
2afe					CALLMONITOR 
2afe cd c6 18			call break_point_state  
2b01				endm  
# End of macro CALLMONITOR
2b01				endif 
2b01 03					inc bc 
2b02			 
2b02 c5					push bc 
2b03 cd a8 1f				call forth_push_str 
2b06 c1					pop bc 
2b07			 
2b07 e1					pop hl 	 
2b08			 
2b08 cd 38 24		.nuword:	call forth_tok_next 
2b0b 18 92				jr .douscan  
2b0d			 
2b0d			.udone:		 ; push count of uwords found 
2b0d c5					push bc 
2b0e e1					pop hl 
2b0f			 
2b0f				if DEBUG_FORTH_WORDS 
2b0f					DMARK "UWc" 
2b0f f5				push af  
2b10 3a 24 2b			ld a, (.dmark)  
2b13 32 b4 fe			ld (debug_mark),a  
2b16 3a 25 2b			ld a, (.dmark+1)  
2b19 32 b5 fe			ld (debug_mark+1),a  
2b1c 3a 26 2b			ld a, (.dmark+2)  
2b1f 32 b6 fe			ld (debug_mark+2),a  
2b22 18 03			jr .pastdmark  
2b24 ..			.dmark: db "UWc"  
2b27 f1			.pastdmark: pop af  
2b28			endm  
# End of macro DMARK
2b28					CALLMONITOR 
2b28 cd c6 18			call break_point_state  
2b2b				endm  
# End of macro CALLMONITOR
2b2b				endif 
2b2b cd 3a 1f				call forth_push_numhl 
2b2e			 
2b2e			 
2b2e				       NEXTW 
2b2e c3 e7 22			jp macro_next 
2b31				endm 
# End of macro NEXTW
2b31			 
2b31			.BP: 
2b31				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2b31 54				db WORD_SYS_CORE+64             
2b32 67 2b			dw .MONITOR            
2b34 03				db 2 + 1 
2b35 .. 00			db "BP",0              
2b38				endm 
# End of macro CWHEAD
2b38			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2b38			; | | $00 Will enable the break points within specific code paths 
2b38			; | | $01 Will disable break points 
2b38			; | |  
2b38			; | | By default break points are off. Either the above can be used to enable them 
2b38			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2b38			; | | and on release of the pressed key a message will be disaplayed to notify 
2b38			; | | that break points are enabled. Pressing any key will then continue boot process. 
2b38					; get byte count 
2b38					if DEBUG_FORTH_WORDS_KEY 
2b38						DMARK "BP." 
2b38 f5				push af  
2b39 3a 4d 2b			ld a, (.dmark)  
2b3c 32 b4 fe			ld (debug_mark),a  
2b3f 3a 4e 2b			ld a, (.dmark+1)  
2b42 32 b5 fe			ld (debug_mark+1),a  
2b45 3a 4f 2b			ld a, (.dmark+2)  
2b48 32 b6 fe			ld (debug_mark+2),a  
2b4b 18 03			jr .pastdmark  
2b4d ..			.dmark: db "BP."  
2b50 f1			.pastdmark: pop af  
2b51			endm  
# End of macro DMARK
2b51						CALLMONITOR 
2b51 cd c6 18			call break_point_state  
2b54				endm  
# End of macro CALLMONITOR
2b54					endif 
2b54			 
2b54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b54 cd 31 21			call macro_dsp_valuehl 
2b57				endm 
# End of macro FORTH_DSP_VALUEHL
2b57			 
2b57			;		push hl 
2b57			 
2b57					; destroy value TOS 
2b57			 
2b57					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b57 cd e9 21			call macro_forth_dsp_pop 
2b5a				endm 
# End of macro FORTH_DSP_POP
2b5a			 
2b5a			;		pop hl 
2b5a			 
2b5a 3e 00				ld a,0 
2b5c bd					cp l 
2b5d 28 02				jr z, .bpset 
2b5f 3e 2a				ld a, '*' 
2b61			 
2b61 32 3f f3		.bpset:		ld (os_view_disable), a 
2b64			 
2b64			 
2b64					NEXTW 
2b64 c3 e7 22			jp macro_next 
2b67				endm 
# End of macro NEXTW
2b67			 
2b67			 
2b67			.MONITOR: 
2b67				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2b67 55				db WORD_SYS_CORE+65             
2b68 9a 2b			dw .MALLOC            
2b6a 08				db 7 + 1 
2b6b .. 00			db "MONITOR",0              
2b73				endm 
# End of macro CWHEAD
2b73			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2b73			; | | At start the current various registers will be displayed with contents. 
2b73			; | | Top right corner will show the most recent debug marker seen. 
2b73			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2b73			; | | and the return stack pointer (RSP). 
2b73			; | | Pressing: 
2b73			; | |    1 - Initial screen 
2b73			; | |    2 - Display a data dump of HL 
2b73			; | |    3 - Display a data dump of DE 
2b73			; | |    4 - Display a data dump of BC 
2b73			; | |    5 - Display a data dump of HL 
2b73			; | |    6 - Display a data dump of DSP 
2b73			; | |    7 - Display a data dump of RSP 
2b73			; | |    8 - Display a data dump of what is at DSP 
2b73			; | |    9 - Display a data dump of what is at RSP 
2b73			; | |    0 - Exit monitor and continue running. This will also enable break points 
2b73			; | |    * - Disable break points 
2b73			; | |    # - Enter traditional monitor mode 
2b73			; | | 
2b73			; | | Monitor Mode 
2b73			; | | ------------ 
2b73			; | | A prompt of '>' will be shown for various commands: 
2b73			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2b73			; | |    C - Continue display a data dump from the last set address 
2b73			; | |    M xxxx - Set start of memory edit at address xx 
2b73			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2b73			; | |    Q - Return to previous 
2b73					if DEBUG_FORTH_WORDS_KEY 
2b73						DMARK "MON" 
2b73 f5				push af  
2b74 3a 88 2b			ld a, (.dmark)  
2b77 32 b4 fe			ld (debug_mark),a  
2b7a 3a 89 2b			ld a, (.dmark+1)  
2b7d 32 b5 fe			ld (debug_mark+1),a  
2b80 3a 8a 2b			ld a, (.dmark+2)  
2b83 32 b6 fe			ld (debug_mark+2),a  
2b86 18 03			jr .pastdmark  
2b88 ..			.dmark: db "MON"  
2b8b f1			.pastdmark: pop af  
2b8c			endm  
# End of macro DMARK
2b8c						CALLMONITOR 
2b8c cd c6 18			call break_point_state  
2b8f				endm  
# End of macro CALLMONITOR
2b8f					endif 
2b8f 3e 00				ld a, 0 
2b91 32 3f f3				ld (os_view_disable), a 
2b94			 
2b94					CALLMONITOR 
2b94 cd c6 18			call break_point_state  
2b97				endm  
# End of macro CALLMONITOR
2b97			 
2b97			;	call monitor 
2b97			 
2b97					NEXTW 
2b97 c3 e7 22			jp macro_next 
2b9a				endm 
# End of macro NEXTW
2b9a			 
2b9a			 
2b9a			.MALLOC: 
2b9a				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2b9a 56				db WORD_SYS_CORE+66             
2b9b c3 2b			dw .MALLOC2            
2b9d 06				db 5 + 1 
2b9e .. 00			db "ALLOT",0              
2ba4				endm 
# End of macro CWHEAD
2ba4			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ba4					if DEBUG_FORTH_WORDS_KEY 
2ba4						DMARK "ALL" 
2ba4 f5				push af  
2ba5 3a b9 2b			ld a, (.dmark)  
2ba8 32 b4 fe			ld (debug_mark),a  
2bab 3a ba 2b			ld a, (.dmark+1)  
2bae 32 b5 fe			ld (debug_mark+1),a  
2bb1 3a bb 2b			ld a, (.dmark+2)  
2bb4 32 b6 fe			ld (debug_mark+2),a  
2bb7 18 03			jr .pastdmark  
2bb9 ..			.dmark: db "ALL"  
2bbc f1			.pastdmark: pop af  
2bbd			endm  
# End of macro DMARK
2bbd						CALLMONITOR 
2bbd cd c6 18			call break_point_state  
2bc0				endm  
# End of macro CALLMONITOR
2bc0					endif 
2bc0 c3 ea 2b				jp .mallocc 
2bc3			.MALLOC2: 
2bc3				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2bc3 56				db WORD_SYS_CORE+66             
2bc4 01 2c			dw .FREE            
2bc6 07				db 6 + 1 
2bc7 .. 00			db "MALLOC",0              
2bce				endm 
# End of macro CWHEAD
2bce			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2bce					; get byte count 
2bce					if DEBUG_FORTH_WORDS_KEY 
2bce						DMARK "MAL" 
2bce f5				push af  
2bcf 3a e3 2b			ld a, (.dmark)  
2bd2 32 b4 fe			ld (debug_mark),a  
2bd5 3a e4 2b			ld a, (.dmark+1)  
2bd8 32 b5 fe			ld (debug_mark+1),a  
2bdb 3a e5 2b			ld a, (.dmark+2)  
2bde 32 b6 fe			ld (debug_mark+2),a  
2be1 18 03			jr .pastdmark  
2be3 ..			.dmark: db "MAL"  
2be6 f1			.pastdmark: pop af  
2be7			endm  
# End of macro DMARK
2be7						CALLMONITOR 
2be7 cd c6 18			call break_point_state  
2bea				endm  
# End of macro CALLMONITOR
2bea					endif 
2bea			.mallocc: 
2bea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2bea cd 31 21			call macro_dsp_valuehl 
2bed				endm 
# End of macro FORTH_DSP_VALUEHL
2bed			 
2bed			;		push hl 
2bed			 
2bed					; destroy value TOS 
2bed			 
2bed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bed cd e9 21			call macro_forth_dsp_pop 
2bf0				endm 
# End of macro FORTH_DSP_POP
2bf0			 
2bf0			;		pop hl 
2bf0 cd 10 14				call malloc 
2bf3				if DEBUG_FORTH_MALLOC_GUARD 
2bf3 f5					push af 
2bf4 cd 72 0f				call ishlzero 
2bf7			;		ld a, l 
2bf7			;		add h 
2bf7			;		cp 0 
2bf7 f1					pop af 
2bf8					 
2bf8 cc c3 5a				call z,malloc_error 
2bfb				endif 
2bfb			 
2bfb cd 3a 1f				call forth_push_numhl 
2bfe					NEXTW 
2bfe c3 e7 22			jp macro_next 
2c01				endm 
# End of macro NEXTW
2c01			 
2c01			.FREE: 
2c01				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2c01 57				db WORD_SYS_CORE+67             
2c02 32 2c			dw .LIST            
2c04 05				db 4 + 1 
2c05 .. 00			db "FREE",0              
2c0a				endm 
# End of macro CWHEAD
2c0a			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2c0a					if DEBUG_FORTH_WORDS_KEY 
2c0a						DMARK "FRE" 
2c0a f5				push af  
2c0b 3a 1f 2c			ld a, (.dmark)  
2c0e 32 b4 fe			ld (debug_mark),a  
2c11 3a 20 2c			ld a, (.dmark+1)  
2c14 32 b5 fe			ld (debug_mark+1),a  
2c17 3a 21 2c			ld a, (.dmark+2)  
2c1a 32 b6 fe			ld (debug_mark+2),a  
2c1d 18 03			jr .pastdmark  
2c1f ..			.dmark: db "FRE"  
2c22 f1			.pastdmark: pop af  
2c23			endm  
# End of macro DMARK
2c23						CALLMONITOR 
2c23 cd c6 18			call break_point_state  
2c26				endm  
# End of macro CALLMONITOR
2c26					endif 
2c26					; get address 
2c26			 
2c26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c26 cd 31 21			call macro_dsp_valuehl 
2c29				endm 
# End of macro FORTH_DSP_VALUEHL
2c29			 
2c29			;		push hl 
2c29			 
2c29					; destroy value TOS 
2c29			 
2c29					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c29 cd e9 21			call macro_forth_dsp_pop 
2c2c				endm 
# End of macro FORTH_DSP_POP
2c2c			 
2c2c			;		pop hl 
2c2c			if FORTH_ENABLE_MALLOCFREE 
2c2c cd da 14				call free 
2c2f			endif 
2c2f					NEXTW 
2c2f c3 e7 22			jp macro_next 
2c32				endm 
# End of macro NEXTW
2c32			.LIST: 
2c32				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2c32 5c				db WORD_SYS_CORE+72             
2c33 20 2e			dw .FORGET            
2c35 05				db 4 + 1 
2c36 .. 00			db "LIST",0              
2c3b				endm 
# End of macro CWHEAD
2c3b			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2c3b			; | | The quoted word must be in upper case. 
2c3b				if DEBUG_FORTH_WORDS_KEY 
2c3b					DMARK "LST" 
2c3b f5				push af  
2c3c 3a 50 2c			ld a, (.dmark)  
2c3f 32 b4 fe			ld (debug_mark),a  
2c42 3a 51 2c			ld a, (.dmark+1)  
2c45 32 b5 fe			ld (debug_mark+1),a  
2c48 3a 52 2c			ld a, (.dmark+2)  
2c4b 32 b6 fe			ld (debug_mark+2),a  
2c4e 18 03			jr .pastdmark  
2c50 ..			.dmark: db "LST"  
2c53 f1			.pastdmark: pop af  
2c54			endm  
# End of macro DMARK
2c54					CALLMONITOR 
2c54 cd c6 18			call break_point_state  
2c57				endm  
# End of macro CALLMONITOR
2c57				endif 
2c57			 
2c57					FORTH_DSP_VALUEHL 
2c57 cd 31 21			call macro_dsp_valuehl 
2c5a				endm 
# End of macro FORTH_DSP_VALUEHL
2c5a			 
2c5a e5					push hl 
2c5b					FORTH_DSP_POP 
2c5b cd e9 21			call macro_forth_dsp_pop 
2c5e				endm 
# End of macro FORTH_DSP_POP
2c5e c1					pop bc 
2c5f			 
2c5f			; Start format of scratch string 
2c5f			 
2c5f 21 4e f3				ld hl, scratch 
2c62			 
2c62 3e 3a				ld a, ':' 
2c64 77					ld (hl),a 
2c65 23					inc hl 
2c66 3e 20				ld a, ' ' 
2c68 77					ld (hl), a 
2c69			 
2c69					; Get ptr to the word we need to look up 
2c69			 
2c69			;		FORTH_DSP_VALUEHL 
2c69					;v5 FORTH_DSP_VALUE 
2c69				; TODO type check 
2c69			;		inc hl    ; Skip type check  
2c69			;		push hl 
2c69			;		ex de, hl    ; put into DE 
2c69			 
2c69			 
2c69 21 00 80				ld hl, baseram 
2c6c					;ld hl, baseusermem 
2c6c			 
2c6c e5			push hl   ; sacreifical push 
2c6d			 
2c6d			.ldouscanm: 
2c6d e1				pop hl 
2c6e			.ldouscan: 
2c6e				if DEBUG_FORTH_WORDS 
2c6e					DMARK "LSs" 
2c6e f5				push af  
2c6f 3a 83 2c			ld a, (.dmark)  
2c72 32 b4 fe			ld (debug_mark),a  
2c75 3a 84 2c			ld a, (.dmark+1)  
2c78 32 b5 fe			ld (debug_mark+1),a  
2c7b 3a 85 2c			ld a, (.dmark+2)  
2c7e 32 b6 fe			ld (debug_mark+2),a  
2c81 18 03			jr .pastdmark  
2c83 ..			.dmark: db "LSs"  
2c86 f1			.pastdmark: pop af  
2c87			endm  
# End of macro DMARK
2c87					CALLMONITOR 
2c87 cd c6 18			call break_point_state  
2c8a				endm  
# End of macro CALLMONITOR
2c8a				endif 
2c8a				; skip dict stub 
2c8a cd 38 24				call forth_tok_next 
2c8d			 
2c8d			 
2c8d			; while we have words to look for 
2c8d			 
2c8d 7e				ld a, (hl)      
2c8e				if DEBUG_FORTH_WORDS 
2c8e					DMARK "LSk" 
2c8e f5				push af  
2c8f 3a a3 2c			ld a, (.dmark)  
2c92 32 b4 fe			ld (debug_mark),a  
2c95 3a a4 2c			ld a, (.dmark+1)  
2c98 32 b5 fe			ld (debug_mark+1),a  
2c9b 3a a5 2c			ld a, (.dmark+2)  
2c9e 32 b6 fe			ld (debug_mark+2),a  
2ca1 18 03			jr .pastdmark  
2ca3 ..			.dmark: db "LSk"  
2ca6 f1			.pastdmark: pop af  
2ca7			endm  
# End of macro DMARK
2ca7					CALLMONITOR 
2ca7 cd c6 18			call break_point_state  
2caa				endm  
# End of macro CALLMONITOR
2caa				endif 
2caa					;cp WORD_SYS_END 
2caa					;jp z, .lunotfound 
2caa			 
2caa					; if we hit non uwords then gone too far 
2caa fe 01				cp WORD_SYS_UWORD 
2cac c2 dc 2d				jp nz, .lunotfound 
2caf			 
2caf				if DEBUG_FORTH_WORDS 
2caf					DMARK "LSu" 
2caf f5				push af  
2cb0 3a c4 2c			ld a, (.dmark)  
2cb3 32 b4 fe			ld (debug_mark),a  
2cb6 3a c5 2c			ld a, (.dmark+1)  
2cb9 32 b5 fe			ld (debug_mark+1),a  
2cbc 3a c6 2c			ld a, (.dmark+2)  
2cbf 32 b6 fe			ld (debug_mark+2),a  
2cc2 18 03			jr .pastdmark  
2cc4 ..			.dmark: db "LSu"  
2cc7 f1			.pastdmark: pop af  
2cc8			endm  
# End of macro DMARK
2cc8					CALLMONITOR 
2cc8 cd c6 18			call break_point_state  
2ccb				endm  
# End of macro CALLMONITOR
2ccb				endif 
2ccb			 
2ccb					; found a uword but is it the one we want... 
2ccb			 
2ccb c5					push bc     ; uword to find is on bc 
2ccc d1					pop de 
2ccd			 
2ccd e5					push hl  ; to save the ptr 
2cce			 
2cce					; skip opcode 
2cce 23					inc hl  
2ccf					; skip next ptr 
2ccf 23					inc hl  
2cd0 23					inc hl 
2cd1					; skip len 
2cd1 23					inc hl 
2cd2			 
2cd2				if DEBUG_FORTH_WORDS 
2cd2					DMARK "LSc" 
2cd2 f5				push af  
2cd3 3a e7 2c			ld a, (.dmark)  
2cd6 32 b4 fe			ld (debug_mark),a  
2cd9 3a e8 2c			ld a, (.dmark+1)  
2cdc 32 b5 fe			ld (debug_mark+1),a  
2cdf 3a e9 2c			ld a, (.dmark+2)  
2ce2 32 b6 fe			ld (debug_mark+2),a  
2ce5 18 03			jr .pastdmark  
2ce7 ..			.dmark: db "LSc"  
2cea f1			.pastdmark: pop af  
2ceb			endm  
# End of macro DMARK
2ceb					CALLMONITOR 
2ceb cd c6 18			call break_point_state  
2cee				endm  
# End of macro CALLMONITOR
2cee				endif 
2cee cd df 13				call strcmp 
2cf1 c2 6d 2c				jp nz, .ldouscanm 
2cf4				 
2cf4			 
2cf4			 
2cf4					; we have a uword so push its name to the stack 
2cf4			 
2cf4			;	   	push hl  ; save so we can move to next dict block 
2cf4 e1			pop hl 
2cf5			 
2cf5				if DEBUG_FORTH_WORDS 
2cf5					DMARK "LSm" 
2cf5 f5				push af  
2cf6 3a 0a 2d			ld a, (.dmark)  
2cf9 32 b4 fe			ld (debug_mark),a  
2cfc 3a 0b 2d			ld a, (.dmark+1)  
2cff 32 b5 fe			ld (debug_mark+1),a  
2d02 3a 0c 2d			ld a, (.dmark+2)  
2d05 32 b6 fe			ld (debug_mark+2),a  
2d08 18 03			jr .pastdmark  
2d0a ..			.dmark: db "LSm"  
2d0d f1			.pastdmark: pop af  
2d0e			endm  
# End of macro DMARK
2d0e					CALLMONITOR 
2d0e cd c6 18			call break_point_state  
2d11				endm  
# End of macro CALLMONITOR
2d11				endif 
2d11			 
2d11					; skip opcode 
2d11 23					inc hl  
2d12					; skip next ptr 
2d12 23					inc hl  
2d13 23					inc hl 
2d14					; skip len 
2d14 7e					ld a, (hl)   ; save length to add 
2d15				if DEBUG_FORTH_WORDS 
2d15					DMARK "LS2" 
2d15 f5				push af  
2d16 3a 2a 2d			ld a, (.dmark)  
2d19 32 b4 fe			ld (debug_mark),a  
2d1c 3a 2b 2d			ld a, (.dmark+1)  
2d1f 32 b5 fe			ld (debug_mark+1),a  
2d22 3a 2c 2d			ld a, (.dmark+2)  
2d25 32 b6 fe			ld (debug_mark+2),a  
2d28 18 03			jr .pastdmark  
2d2a ..			.dmark: db "LS2"  
2d2d f1			.pastdmark: pop af  
2d2e			endm  
# End of macro DMARK
2d2e					CALLMONITOR 
2d2e cd c6 18			call break_point_state  
2d31				endm  
# End of macro CALLMONITOR
2d31				endif 
2d31			 
2d31					; save this location 
2d31				 
2d31 e5					push hl 
2d32			 
2d32 23					inc hl 
2d33 11 50 f3				ld de, scratch+2 
2d36 4f					ld c, a 
2d37 06 00				ld b, 0 
2d39			 
2d39				if DEBUG_FORTH_WORDS 
2d39					DMARK "LSn" 
2d39 f5				push af  
2d3a 3a 4e 2d			ld a, (.dmark)  
2d3d 32 b4 fe			ld (debug_mark),a  
2d40 3a 4f 2d			ld a, (.dmark+1)  
2d43 32 b5 fe			ld (debug_mark+1),a  
2d46 3a 50 2d			ld a, (.dmark+2)  
2d49 32 b6 fe			ld (debug_mark+2),a  
2d4c 18 03			jr .pastdmark  
2d4e ..			.dmark: db "LSn"  
2d51 f1			.pastdmark: pop af  
2d52			endm  
# End of macro DMARK
2d52					CALLMONITOR 
2d52 cd c6 18			call break_point_state  
2d55				endm  
# End of macro CALLMONITOR
2d55				endif 
2d55			 
2d55					; copy uword name to scratch 
2d55			 
2d55 ed b0				ldir 
2d57			 
2d57 1b					dec de 
2d58 3e 20				ld a, ' '    ; change null to space 
2d5a 12					ld (de), a 
2d5b			 
2d5b 13					inc de 
2d5c			 
2d5c d5					push de 
2d5d c1					pop bc     ; move scratch pointer to end of word name and save it 
2d5e			 
2d5e e1					pop hl 
2d5f 7e					ld a, (hl) 
2d60					;inc hl 
2d60					; skip word string 
2d60 cd 49 0f				call addatohl 
2d63			 
2d63 23					inc hl 
2d64			 
2d64				if DEBUG_FORTH_WORDS 
2d64					DMARK "LS3" 
2d64 f5				push af  
2d65 3a 79 2d			ld a, (.dmark)  
2d68 32 b4 fe			ld (debug_mark),a  
2d6b 3a 7a 2d			ld a, (.dmark+1)  
2d6e 32 b5 fe			ld (debug_mark+1),a  
2d71 3a 7b 2d			ld a, (.dmark+2)  
2d74 32 b6 fe			ld (debug_mark+2),a  
2d77 18 03			jr .pastdmark  
2d79 ..			.dmark: db "LS3"  
2d7c f1			.pastdmark: pop af  
2d7d			endm  
# End of macro DMARK
2d7d					CALLMONITOR 
2d7d cd c6 18			call break_point_state  
2d80				endm  
# End of macro CALLMONITOR
2d80				endif 
2d80					; should now be at the start of the machine code to setup the eval of the uword 
2d80					; now locate the ptr to the string defintion 
2d80			 
2d80					; skip ld hl, 
2d80					; then load the ptr 
2d80			; TODO use get from hl ptr 
2d80 23					inc hl 
2d81 5e					ld e, (hl) 
2d82 23					inc hl 
2d83 56					ld d, (hl) 
2d84 eb					ex de, hl 
2d85			 
2d85			 
2d85				if DEBUG_FORTH_WORDS 
2d85					DMARK "LSt" 
2d85 f5				push af  
2d86 3a 9a 2d			ld a, (.dmark)  
2d89 32 b4 fe			ld (debug_mark),a  
2d8c 3a 9b 2d			ld a, (.dmark+1)  
2d8f 32 b5 fe			ld (debug_mark+1),a  
2d92 3a 9c 2d			ld a, (.dmark+2)  
2d95 32 b6 fe			ld (debug_mark+2),a  
2d98 18 03			jr .pastdmark  
2d9a ..			.dmark: db "LSt"  
2d9d f1			.pastdmark: pop af  
2d9e			endm  
# End of macro DMARK
2d9e					CALLMONITOR 
2d9e cd c6 18			call break_point_state  
2da1				endm  
# End of macro CALLMONITOR
2da1				endif 
2da1			 
2da1			; cant push right now due to tokenised strings  
2da1			 
2da1			; get the destination of where to copy this definition to. 
2da1			 
2da1 c5					push bc 
2da2 d1					pop de 
2da3			 
2da3 7e			.listl:         ld a,(hl) 
2da4 fe 00				cp 0 
2da6 28 09				jr z, .lreplsp     ; replace zero with space 
2da8					;cp FORTH_END_BUFFER 
2da8 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2daa 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2dac				 
2dac					; just copy this char as is then 
2dac			 
2dac 12					ld (de), a 
2dad			 
2dad 23			.listnxt:	inc hl 
2dae 13					inc de 
2daf 18 f2				jr .listl 
2db1			 
2db1 3e 20		.lreplsp:	ld a,' ' 
2db3 12					ld (de), a 
2db4 18 f7				jr .listnxt 
2db6			 
2db6			; close up uword def 
2db6			 
2db6			.listdone: 
2db6 12					ld (de), a 
2db7 13					inc de 
2db8 3e 00				ld a, 0 
2dba 12					ld (de), a 
2dbb			 
2dbb			; now have def so clean up and push to stack 
2dbb			 
2dbb 21 4e f3				ld hl, scratch 
2dbe				if DEBUG_FORTH_WORDS 
2dbe					DMARK "Ltp" 
2dbe f5				push af  
2dbf 3a d3 2d			ld a, (.dmark)  
2dc2 32 b4 fe			ld (debug_mark),a  
2dc5 3a d4 2d			ld a, (.dmark+1)  
2dc8 32 b5 fe			ld (debug_mark+1),a  
2dcb 3a d5 2d			ld a, (.dmark+2)  
2dce 32 b6 fe			ld (debug_mark+2),a  
2dd1 18 03			jr .pastdmark  
2dd3 ..			.dmark: db "Ltp"  
2dd6 f1			.pastdmark: pop af  
2dd7			endm  
# End of macro DMARK
2dd7					CALLMONITOR 
2dd7 cd c6 18			call break_point_state  
2dda				endm  
# End of macro CALLMONITOR
2dda				endif 
2dda			 
2dda 18 1f			jr .listpush 
2ddc			 
2ddc			;.lnuword:	pop hl 
2ddc			;		call forth_tok_next 
2ddc			;		jp .ldouscan  
2ddc			 
2ddc			.lunotfound:		  
2ddc			 
2ddc				if DEBUG_FORTH_WORDS 
2ddc					DMARK "LSn" 
2ddc f5				push af  
2ddd 3a f1 2d			ld a, (.dmark)  
2de0 32 b4 fe			ld (debug_mark),a  
2de3 3a f2 2d			ld a, (.dmark+1)  
2de6 32 b5 fe			ld (debug_mark+1),a  
2de9 3a f3 2d			ld a, (.dmark+2)  
2dec 32 b6 fe			ld (debug_mark+2),a  
2def 18 03			jr .pastdmark  
2df1 ..			.dmark: db "LSn"  
2df4 f1			.pastdmark: pop af  
2df5			endm  
# End of macro DMARK
2df5					CALLMONITOR 
2df5 cd c6 18			call break_point_state  
2df8				endm  
# End of macro CALLMONITOR
2df8				endif 
2df8			 
2df8					 
2df8			;		FORTH_DSP_POP 
2df8			;		ld hl, .luno 
2df8			 
2df8					NEXTW			 
2df8 c3 e7 22			jp macro_next 
2dfb				endm 
# End of macro NEXTW
2dfb			 
2dfb			.listpush: 
2dfb				if DEBUG_FORTH_WORDS 
2dfb					DMARK "LS>" 
2dfb f5				push af  
2dfc 3a 10 2e			ld a, (.dmark)  
2dff 32 b4 fe			ld (debug_mark),a  
2e02 3a 11 2e			ld a, (.dmark+1)  
2e05 32 b5 fe			ld (debug_mark+1),a  
2e08 3a 12 2e			ld a, (.dmark+2)  
2e0b 32 b6 fe			ld (debug_mark+2),a  
2e0e 18 03			jr .pastdmark  
2e10 ..			.dmark: db "LS>"  
2e13 f1			.pastdmark: pop af  
2e14			endm  
# End of macro DMARK
2e14					CALLMONITOR 
2e14 cd c6 18			call break_point_state  
2e17				endm  
# End of macro CALLMONITOR
2e17				endif 
2e17 cd a8 1f				call forth_push_str 
2e1a			 
2e1a			 
2e1a			 
2e1a					NEXTW 
2e1a c3 e7 22			jp macro_next 
2e1d				endm 
# End of macro NEXTW
2e1d			 
2e1d			;.luno:    db "Word not found",0 
2e1d			 
2e1d			 
2e1d			 
2e1d			 
2e1d			 
2e1d			;		push hl   ; save pointer to start of uword def string 
2e1d			; 
2e1d			;; look for FORTH_EOL_LINE 
2e1d			;		ld a, FORTH_END_BUFFER 
2e1d			;		call strlent 
2e1d			; 
2e1d			;		inc hl		 ; space for coln def 
2e1d			;		inc hl 
2e1d			;		inc hl          ; space for terms 
2e1d			;		inc hl 
2e1d			; 
2e1d			;		ld a, 20   ; TODO get actual length 
2e1d			;		call addatohl    ; include a random amount of room for the uword name 
2e1d			; 
2e1d			;		 
2e1d			;	if DEBUG_FORTH_WORDS 
2e1d			;		DMARK "Lt1" 
2e1d			;		CALLMONITOR 
2e1d			;	endif 
2e1d			;		 
2e1d			; 
2e1d			;; malloc space for the string because we cant change it 
2e1d			; 
2e1d			;		call malloc 
2e1d			;	if DEBUG_FORTH_MALLOC_GUARD 
2e1d			;		push af 
2e1d			;		call ishlzero 
2e1d			;		pop af 
2e1d			;		 
2e1d			;		call z,malloc_error 
2e1d			;	endif 
2e1d			; 
2e1d			;	if DEBUG_FORTH_WORDS 
2e1d			;		DMARK "Lt2" 
2e1d			;		CALLMONITOR 
2e1d			;	endif 
2e1d			;		pop de 
2e1d			;		push hl    ; push the malloc to release later 
2e1d			;		push hl   ;  push back a copy for the later stack push 
2e1d			;		 
2e1d			;; copy the string swapping out the zero terms for spaces 
2e1d			; 
2e1d			;		; de has our source 
2e1d			;		; hl has our dest 
2e1d			; 
2e1d			;; add the coln def 
2e1d			; 
2e1d			;		ld a, ':' 
2e1d			;		ld (hl), a 
2e1d			;		inc hl 
2e1d			;		ld a, ' ' 
2e1d			;		ld (hl), a 
2e1d			;		inc hl 
2e1d			; 
2e1d			;; add the uname word 
2e1d			;		push de   ; save our string for now 
2e1d			;		ex de, hl 
2e1d			; 
2e1d			;		FORTH_DSP_VALUE 
2e1d			;		;v5 FORTH_DSP_VALUE 
2e1d			; 
2e1d			;		inc hl   ; skip type but we know by now this is OK 
2e1d			; 
2e1d			;.luword:	ld a,(hl) 
2e1d			;		cp 0 
2e1d			;		jr z, .luword2 
2e1d			;		ld (de), a 
2e1d			;		inc de 
2e1d			;		inc hl 
2e1d			;		jr .luword 
2e1d			; 
2e1d			;.luword2:	ld a, ' ' 
2e1d			;		ld (de), a 
2e1d			;;		inc hl 
2e1d			;;		inc de 
2e1d			;;		ld (de), a 
2e1d			;;		inc hl 
2e1d			;		inc de 
2e1d			; 
2e1d			;		ex de, hl 
2e1d			;		pop de 
2e1d			;		 
2e1d			;		 
2e1d			; 
2e1d			;; detoken that string and copy it 
2e1d			; 
2e1d			;	if DEBUG_FORTH_WORDS 
2e1d			;		DMARK "Lt2" 
2e1d			;		CALLMONITOR 
2e1d			;	endif 
2e1d			;.ldetok:	ld a, (de) 
2e1d			;		cp FORTH_END_BUFFER 
2e1d			;		jr z, .ldetokend 
2e1d			;		; swap out any zero term for space 
2e1d			;		cp 0 
2e1d			;		jr nz, .ldetoknext 
2e1d			;		ld a, ' ' 
2e1d			; 
2e1d			;	if DEBUG_FORTH_WORDS 
2e1d			;		DMARK "LtS" 
2e1d			;		CALLMONITOR 
2e1d			;	endif 
2e1d			;.ldetoknext:	ld (hl), a 
2e1d			;		inc de 
2e1d			;		inc hl 
2e1d			;		jr .ldetok 
2e1d			; 
2e1d			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2e1d			;		ld (hl), a  
2e1d			; 
2e1d			;; free that temp malloc 
2e1d			; 
2e1d			;		pop hl    
2e1d			; 
2e1d			;	if DEBUG_FORTH_WORDS 
2e1d			;		DMARK "Lt4" 
2e1d			;		CALLMONITOR 
2e1d			;	endif 
2e1d			;		call forth_apushstrhl 
2e1d			; 
2e1d			;		; get rid of temp malloc area 
2e1d			; 
2e1d			;		pop hl 
2e1d			;		call free 
2e1d			; 
2e1d			;		jr .ludone 
2e1d			; 
2e1d			;.lnuword:	pop hl 
2e1d			;		call forth_tok_next 
2e1d			;		jp .ldouscan  
2e1d			; 
2e1d			;.ludone:		 pop hl 
2e1d			; 
2e1d					NEXTW 
2e1d c3 e7 22			jp macro_next 
2e20				endm 
# End of macro NEXTW
2e20			 
2e20			.FORGET: 
2e20				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2e20 5d				db WORD_SYS_CORE+73             
2e21 99 2e			dw .NOP            
2e23 07				db 6 + 1 
2e24 .. 00			db "FORGET",0              
2e2b				endm 
# End of macro CWHEAD
2e2b			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2e2b			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2e2b			; | |  
2e2b			; | | e.g. "MORE" forget 
2e2b					if DEBUG_FORTH_WORDS_KEY 
2e2b						DMARK "FRG" 
2e2b f5				push af  
2e2c 3a 40 2e			ld a, (.dmark)  
2e2f 32 b4 fe			ld (debug_mark),a  
2e32 3a 41 2e			ld a, (.dmark+1)  
2e35 32 b5 fe			ld (debug_mark+1),a  
2e38 3a 42 2e			ld a, (.dmark+2)  
2e3b 32 b6 fe			ld (debug_mark+2),a  
2e3e 18 03			jr .pastdmark  
2e40 ..			.dmark: db "FRG"  
2e43 f1			.pastdmark: pop af  
2e44			endm  
# End of macro DMARK
2e44						CALLMONITOR 
2e44 cd c6 18			call break_point_state  
2e47				endm  
# End of macro CALLMONITOR
2e47					endif 
2e47			 
2e47				; find uword 
2e47			        ; update start of word with "_" 
2e47				; replace uword with deleted flag 
2e47			 
2e47			 
2e47			;	if DEBUG_FORTH_WORDS 
2e47			;		DMARK "FOG" 
2e47			;		CALLMONITOR 
2e47			;	endif 
2e47			 
2e47			 
2e47					; Get ptr to the word we need to look up 
2e47			 
2e47					FORTH_DSP_VALUEHL 
2e47 cd 31 21			call macro_dsp_valuehl 
2e4a				endm 
# End of macro FORTH_DSP_VALUEHL
2e4a					;v5 FORTH_DSP_VALUE 
2e4a				; TODO type check 
2e4a			;		inc hl    ; Skip type check  
2e4a e5					push hl 
2e4b c1					pop bc 
2e4c			;		ex de, hl    ; put into DE 
2e4c			 
2e4c			 
2e4c 21 00 80				ld hl, baseram 
2e4f					;ld hl, baseusermem 
2e4f			 
2e4f				; skip dict stub 
2e4f			;	call forth_tok_next 
2e4f e5			push hl   ; sacreifical push 
2e50			 
2e50			.fldouscanm: 
2e50 e1				pop hl 
2e51			.fldouscan: 
2e51			;	if DEBUG_FORTH_WORDS 
2e51			;		DMARK "LSs" 
2e51			;		CALLMONITOR 
2e51			;	endif 
2e51				; skip dict stub 
2e51 cd 38 24				call forth_tok_next 
2e54			 
2e54			 
2e54			; while we have words to look for 
2e54			 
2e54 7e				ld a, (hl)      
2e55			;	if DEBUG_FORTH_WORDS 
2e55			;		DMARK "LSk" 
2e55			;		CALLMONITOR 
2e55			;	endif 
2e55 fe 00				cp WORD_SYS_END 
2e57 ca 93 2e				jp z, .flunotfound 
2e5a fe 01				cp WORD_SYS_UWORD 
2e5c c2 51 2e				jp nz, .fldouscan 
2e5f			 
2e5f			;	if DEBUG_FORTH_WORDS 
2e5f			;		DMARK "LSu" 
2e5f			;		CALLMONITOR 
2e5f			;	endif 
2e5f			 
2e5f					; found a uword but is it the one we want... 
2e5f			 
2e5f c5					push bc     ; uword to find is on bc 
2e60 d1					pop de 
2e61			 
2e61 e5					push hl  ; to save the ptr 
2e62			 
2e62					; skip opcode 
2e62 23					inc hl  
2e63					; skip next ptr 
2e63 23					inc hl  
2e64 23					inc hl 
2e65					; skip len 
2e65 23					inc hl 
2e66			 
2e66			;	if DEBUG_FORTH_WORDS 
2e66			;		DMARK "LSc" 
2e66			;		CALLMONITOR 
2e66			;	endif 
2e66 cd df 13				call strcmp 
2e69 c2 50 2e				jp nz, .fldouscanm 
2e6c			; 
2e6c			; 
2e6c			;; while we have words to look for 
2e6c			; 
2e6c			;.fdouscan:	ld a, (hl)      
2e6c			;	if DEBUG_FORTH_WORDS 
2e6c			;		DMARK "LSs" 
2e6c			;		CALLMONITOR 
2e6c			;	endif 
2e6c			;		cp WORD_SYS_END 
2e6c			;		jp z, .fudone 
2e6c			;		cp WORD_SYS_UWORD 
2e6c			;		jp nz, .fnuword 
2e6c			; 
2e6c			;	if DEBUG_FORTH_WORDS 
2e6c			;		DMARK "FGu" 
2e6c			;		CALLMONITOR 
2e6c			;	endif 
2e6c			; 
2e6c			;		; found a uword but is it the one we want... 
2e6c			; 
2e6c			; 
2e6c			;	        pop de   ; get back the dsp name 
2e6c			;		push de 
2e6c			; 
2e6c			;		push hl  ; to save the ptr 
2e6c			; 
2e6c			;		; skip opcode 
2e6c			;		inc hl  
2e6c			;		; skip next ptr 
2e6c			;		inc hl  
2e6c			;		inc hl 
2e6c			;		; skip len 
2e6c			;		inc hl 
2e6c			; 
2e6c			;	if DEBUG_FORTH_WORDS 
2e6c			;		DMARK "FGc" 
2e6c			;		CALLMONITOR 
2e6c			;	endif 
2e6c			;		call strcmp 
2e6c			;		jp nz, .fnuword 
2e6c			 
2e6c			 
2e6c e1			pop hl 
2e6d			 
2e6d				 
2e6d				if DEBUG_FORTH_WORDS 
2e6d					DMARK "FGm" 
2e6d f5				push af  
2e6e 3a 82 2e			ld a, (.dmark)  
2e71 32 b4 fe			ld (debug_mark),a  
2e74 3a 83 2e			ld a, (.dmark+1)  
2e77 32 b5 fe			ld (debug_mark+1),a  
2e7a 3a 84 2e			ld a, (.dmark+2)  
2e7d 32 b6 fe			ld (debug_mark+2),a  
2e80 18 03			jr .pastdmark  
2e82 ..			.dmark: db "FGm"  
2e85 f1			.pastdmark: pop af  
2e86			endm  
# End of macro DMARK
2e86					CALLMONITOR 
2e86 cd c6 18			call break_point_state  
2e89				endm  
# End of macro CALLMONITOR
2e89				endif 
2e89			 
2e89			 
2e89			 
2e89					; we have a uword so push its name to the stack 
2e89			 
2e89			;	   	push hl  ; save so we can move to next dict block 
2e89			;pop hl 
2e89			 
2e89					; update opcode to deleted 
2e89 3e 03				ld a, WORD_SYS_DELETED 
2e8b 77					ld (hl), a 
2e8c			 
2e8c 23					inc hl  
2e8d					; skip next ptr 
2e8d 23					inc hl  
2e8e 23					inc hl 
2e8f					; skip len 
2e8f 23					inc hl 
2e90			 
2e90					; TODO change parser to skip deleted words but for now mark it out 
2e90 3e 5f				ld a, "_" 
2e92 77					ld  (hl),a 
2e93			 
2e93			;		jr .fudone 
2e93			; 
2e93			;.fnuword:	pop hl 
2e93			;		call forth_tok_next 
2e93			;		jp .fdouscan  
2e93			 
2e93			.flunotfound:		  
2e93			 
2e93			 
2e93					 
2e93					FORTH_DSP_POP 
2e93 cd e9 21			call macro_forth_dsp_pop 
2e96				endm 
# End of macro FORTH_DSP_POP
2e96			;		ld hl, .luno 
2e96			;.fudone:		 pop hl 
2e96					NEXTW 
2e96 c3 e7 22			jp macro_next 
2e99				endm 
# End of macro NEXTW
2e99			.NOP: 
2e99				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2e99 61				db WORD_SYS_CORE+77             
2e9a c0 2e			dw .COMO            
2e9c 04				db 3 + 1 
2e9d .. 00			db "NOP",0              
2ea1				endm 
# End of macro CWHEAD
2ea1			; | NOP (  --  ) Do nothing | DONE 
2ea1					if DEBUG_FORTH_WORDS_KEY 
2ea1						DMARK "NOP" 
2ea1 f5				push af  
2ea2 3a b6 2e			ld a, (.dmark)  
2ea5 32 b4 fe			ld (debug_mark),a  
2ea8 3a b7 2e			ld a, (.dmark+1)  
2eab 32 b5 fe			ld (debug_mark+1),a  
2eae 3a b8 2e			ld a, (.dmark+2)  
2eb1 32 b6 fe			ld (debug_mark+2),a  
2eb4 18 03			jr .pastdmark  
2eb6 ..			.dmark: db "NOP"  
2eb9 f1			.pastdmark: pop af  
2eba			endm  
# End of macro DMARK
2eba						CALLMONITOR 
2eba cd c6 18			call break_point_state  
2ebd				endm  
# End of macro CALLMONITOR
2ebd					endif 
2ebd				       NEXTW 
2ebd c3 e7 22			jp macro_next 
2ec0				endm 
# End of macro NEXTW
2ec0			.COMO: 
2ec0				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2ec0 6e				db WORD_SYS_CORE+90             
2ec1 12 2f			dw .COMC            
2ec3 02				db 1 + 1 
2ec4 .. 00			db "(",0              
2ec6				endm 
# End of macro CWHEAD
2ec6			; | ( ( -- )  Start of comment | DONE 
2ec6			 
2ec6			 
2ec6 2a 4f f6				ld hl, ( os_tok_ptr) 
2ec9 11 0d 2f			ld de, .closepar 
2ecc					 
2ecc					if DEBUG_FORTH_WORDS 
2ecc						DMARK ").." 
2ecc f5				push af  
2ecd 3a e1 2e			ld a, (.dmark)  
2ed0 32 b4 fe			ld (debug_mark),a  
2ed3 3a e2 2e			ld a, (.dmark+1)  
2ed6 32 b5 fe			ld (debug_mark+1),a  
2ed9 3a e3 2e			ld a, (.dmark+2)  
2edc 32 b6 fe			ld (debug_mark+2),a  
2edf 18 03			jr .pastdmark  
2ee1 ..			.dmark: db ").."  
2ee4 f1			.pastdmark: pop af  
2ee5			endm  
# End of macro DMARK
2ee5						CALLMONITOR 
2ee5 cd c6 18			call break_point_state  
2ee8				endm  
# End of macro CALLMONITOR
2ee8					endif 
2ee8 cd 02 24			call findnexttok  
2eeb			 
2eeb					if DEBUG_FORTH_WORDS 
2eeb						DMARK "IF5" 
2eeb f5				push af  
2eec 3a 00 2f			ld a, (.dmark)  
2eef 32 b4 fe			ld (debug_mark),a  
2ef2 3a 01 2f			ld a, (.dmark+1)  
2ef5 32 b5 fe			ld (debug_mark+1),a  
2ef8 3a 02 2f			ld a, (.dmark+2)  
2efb 32 b6 fe			ld (debug_mark+2),a  
2efe 18 03			jr .pastdmark  
2f00 ..			.dmark: db "IF5"  
2f03 f1			.pastdmark: pop af  
2f04			endm  
# End of macro DMARK
2f04						CALLMONITOR 
2f04 cd c6 18			call break_point_state  
2f07				endm  
# End of macro CALLMONITOR
2f07					endif 
2f07				; replace below with ) exec using tok_ptr 
2f07 22 4f f6			ld (os_tok_ptr), hl 
2f0a c3 78 23			jp exec1 
2f0d			 
2f0d .. 00			.closepar:   db ")",0 
2f0f			 
2f0f				       NEXTW 
2f0f c3 e7 22			jp macro_next 
2f12				endm 
# End of macro NEXTW
2f12			.COMC: 
2f12				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2f12 6f				db WORD_SYS_CORE+91             
2f13 1b 2f			dw .SCRATCH            
2f15 02				db 1 + 1 
2f16 .. 00			db ")",0              
2f18				endm 
# End of macro CWHEAD
2f18			; | ) ( -- )  End of comment |  DONE  
2f18				       NEXTW 
2f18 c3 e7 22			jp macro_next 
2f1b				endm 
# End of macro NEXTW
2f1b			 
2f1b			.SCRATCH: 
2f1b				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2f1b 6f				db WORD_SYS_CORE+91             
2f1c 56 2f			dw .INC            
2f1e 08				db 7 + 1 
2f1f .. 00			db "SCRATCH",0              
2f27				endm 
# End of macro CWHEAD
2f27			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2f27			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2f27			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2f27			; | |  
2f27			; | | e.g.    : score $00 scratch ; 
2f27			; | |  
2f27			; | | $00 score ! 
2f27			; | | $01 score +! 
2f27			; | |  
2f27			; | | e.g.   : varword $0a scratch ;  
2f27			; | | 
2f27			; | | $8000 varword ! 
2f27					if DEBUG_FORTH_WORDS_KEY 
2f27						DMARK "SCR" 
2f27 f5				push af  
2f28 3a 3c 2f			ld a, (.dmark)  
2f2b 32 b4 fe			ld (debug_mark),a  
2f2e 3a 3d 2f			ld a, (.dmark+1)  
2f31 32 b5 fe			ld (debug_mark+1),a  
2f34 3a 3e 2f			ld a, (.dmark+2)  
2f37 32 b6 fe			ld (debug_mark+2),a  
2f3a 18 03			jr .pastdmark  
2f3c ..			.dmark: db "SCR"  
2f3f f1			.pastdmark: pop af  
2f40			endm  
# End of macro DMARK
2f40						CALLMONITOR 
2f40 cd c6 18			call break_point_state  
2f43				endm  
# End of macro CALLMONITOR
2f43					endif 
2f43			 
2f43					FORTH_DSP_VALUEHL 
2f43 cd 31 21			call macro_dsp_valuehl 
2f46				endm 
# End of macro FORTH_DSP_VALUEHL
2f46				 
2f46					FORTH_DSP_POP 
2f46 cd e9 21			call macro_forth_dsp_pop 
2f49				endm 
# End of macro FORTH_DSP_POP
2f49			 
2f49 7d					ld a, l 
2f4a 21 73 f8				ld hl, os_var_array 
2f4d cd 49 0f				call addatohl 
2f50			 
2f50 cd 3a 1f				call forth_push_numhl 
2f53			 
2f53				       NEXTW 
2f53 c3 e7 22			jp macro_next 
2f56				endm 
# End of macro NEXTW
2f56			 
2f56			.INC: 
2f56				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2f56 6f				db WORD_SYS_CORE+91             
2f57 aa 2f			dw .DEC            
2f59 03				db 2 + 1 
2f5a .. 00			db "+!",0              
2f5d				endm 
# End of macro CWHEAD
2f5d			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2f5d					if DEBUG_FORTH_WORDS_KEY 
2f5d						DMARK "+s_" 
2f5d f5				push af  
2f5e 3a 72 2f			ld a, (.dmark)  
2f61 32 b4 fe			ld (debug_mark),a  
2f64 3a 73 2f			ld a, (.dmark+1)  
2f67 32 b5 fe			ld (debug_mark+1),a  
2f6a 3a 74 2f			ld a, (.dmark+2)  
2f6d 32 b6 fe			ld (debug_mark+2),a  
2f70 18 03			jr .pastdmark  
2f72 ..			.dmark: db "+s_"  
2f75 f1			.pastdmark: pop af  
2f76			endm  
# End of macro DMARK
2f76						CALLMONITOR 
2f76 cd c6 18			call break_point_state  
2f79				endm  
# End of macro CALLMONITOR
2f79					endif 
2f79			 
2f79					FORTH_DSP_VALUEHL 
2f79 cd 31 21			call macro_dsp_valuehl 
2f7c				endm 
# End of macro FORTH_DSP_VALUEHL
2f7c			 
2f7c e5					push hl   ; save address 
2f7d			 
2f7d					FORTH_DSP_POP 
2f7d cd e9 21			call macro_forth_dsp_pop 
2f80				endm 
# End of macro FORTH_DSP_POP
2f80			 
2f80					FORTH_DSP_VALUEHL 
2f80 cd 31 21			call macro_dsp_valuehl 
2f83				endm 
# End of macro FORTH_DSP_VALUEHL
2f83			 
2f83					FORTH_DSP_POP 
2f83 cd e9 21			call macro_forth_dsp_pop 
2f86				endm 
# End of macro FORTH_DSP_POP
2f86			 
2f86					; hl contains value to add to byte at a 
2f86				 
2f86 eb					ex de, hl 
2f87			 
2f87 e1					pop hl 
2f88			 
2f88					if DEBUG_FORTH_WORDS 
2f88						DMARK "INC" 
2f88 f5				push af  
2f89 3a 9d 2f			ld a, (.dmark)  
2f8c 32 b4 fe			ld (debug_mark),a  
2f8f 3a 9e 2f			ld a, (.dmark+1)  
2f92 32 b5 fe			ld (debug_mark+1),a  
2f95 3a 9f 2f			ld a, (.dmark+2)  
2f98 32 b6 fe			ld (debug_mark+2),a  
2f9b 18 03			jr .pastdmark  
2f9d ..			.dmark: db "INC"  
2fa0 f1			.pastdmark: pop af  
2fa1			endm  
# End of macro DMARK
2fa1						CALLMONITOR 
2fa1 cd c6 18			call break_point_state  
2fa4				endm  
# End of macro CALLMONITOR
2fa4					endif 
2fa4			 
2fa4 7e					ld a,(hl) 
2fa5 83					add e 
2fa6 77					ld (hl),a 
2fa7			 
2fa7			 
2fa7			 
2fa7				       NEXTW 
2fa7 c3 e7 22			jp macro_next 
2faa				endm 
# End of macro NEXTW
2faa			 
2faa			.DEC: 
2faa				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2faa 6f				db WORD_SYS_CORE+91             
2fab fb 2f			dw .INC2            
2fad 03				db 2 + 1 
2fae .. 00			db "-!",0              
2fb1				endm 
# End of macro CWHEAD
2fb1			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2fb1					if DEBUG_FORTH_WORDS_KEY 
2fb1						DMARK "-s_" 
2fb1 f5				push af  
2fb2 3a c6 2f			ld a, (.dmark)  
2fb5 32 b4 fe			ld (debug_mark),a  
2fb8 3a c7 2f			ld a, (.dmark+1)  
2fbb 32 b5 fe			ld (debug_mark+1),a  
2fbe 3a c8 2f			ld a, (.dmark+2)  
2fc1 32 b6 fe			ld (debug_mark+2),a  
2fc4 18 03			jr .pastdmark  
2fc6 ..			.dmark: db "-s_"  
2fc9 f1			.pastdmark: pop af  
2fca			endm  
# End of macro DMARK
2fca						CALLMONITOR 
2fca cd c6 18			call break_point_state  
2fcd				endm  
# End of macro CALLMONITOR
2fcd					endif 
2fcd			 
2fcd					FORTH_DSP_VALUEHL 
2fcd cd 31 21			call macro_dsp_valuehl 
2fd0				endm 
# End of macro FORTH_DSP_VALUEHL
2fd0			 
2fd0 e5					push hl   ; save address 
2fd1			 
2fd1					FORTH_DSP_POP 
2fd1 cd e9 21			call macro_forth_dsp_pop 
2fd4				endm 
# End of macro FORTH_DSP_POP
2fd4			 
2fd4					FORTH_DSP_VALUEHL 
2fd4 cd 31 21			call macro_dsp_valuehl 
2fd7				endm 
# End of macro FORTH_DSP_VALUEHL
2fd7			 
2fd7					; hl contains value to add to byte at a 
2fd7				 
2fd7 eb					ex de, hl 
2fd8			 
2fd8 e1					pop hl 
2fd9			 
2fd9					if DEBUG_FORTH_WORDS 
2fd9						DMARK "DEC" 
2fd9 f5				push af  
2fda 3a ee 2f			ld a, (.dmark)  
2fdd 32 b4 fe			ld (debug_mark),a  
2fe0 3a ef 2f			ld a, (.dmark+1)  
2fe3 32 b5 fe			ld (debug_mark+1),a  
2fe6 3a f0 2f			ld a, (.dmark+2)  
2fe9 32 b6 fe			ld (debug_mark+2),a  
2fec 18 03			jr .pastdmark  
2fee ..			.dmark: db "DEC"  
2ff1 f1			.pastdmark: pop af  
2ff2			endm  
# End of macro DMARK
2ff2						CALLMONITOR 
2ff2 cd c6 18			call break_point_state  
2ff5				endm  
# End of macro CALLMONITOR
2ff5					endif 
2ff5			 
2ff5 7e					ld a,(hl) 
2ff6 93					sub e 
2ff7 77					ld (hl),a 
2ff8			 
2ff8			 
2ff8			 
2ff8				       NEXTW 
2ff8 c3 e7 22			jp macro_next 
2ffb				endm 
# End of macro NEXTW
2ffb			 
2ffb			.INC2: 
2ffb				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2ffb 6f				db WORD_SYS_CORE+91             
2ffc a5 30			dw .DEC2            
2ffe 04				db 3 + 1 
2fff .. 00			db "+2!",0              
3003				endm 
# End of macro CWHEAD
3003			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3003			 
3003					if DEBUG_FORTH_WORDS_KEY 
3003						DMARK "+2s" 
3003 f5				push af  
3004 3a 18 30			ld a, (.dmark)  
3007 32 b4 fe			ld (debug_mark),a  
300a 3a 19 30			ld a, (.dmark+1)  
300d 32 b5 fe			ld (debug_mark+1),a  
3010 3a 1a 30			ld a, (.dmark+2)  
3013 32 b6 fe			ld (debug_mark+2),a  
3016 18 03			jr .pastdmark  
3018 ..			.dmark: db "+2s"  
301b f1			.pastdmark: pop af  
301c			endm  
# End of macro DMARK
301c						CALLMONITOR 
301c cd c6 18			call break_point_state  
301f				endm  
# End of macro CALLMONITOR
301f					endif 
301f			 
301f					; Address 
301f			 
301f					FORTH_DSP_VALUEHL 
301f cd 31 21			call macro_dsp_valuehl 
3022				endm 
# End of macro FORTH_DSP_VALUEHL
3022			 
3022 e5					push hl    ; save address 
3023			 
3023					; load content into de 
3023			 
3023 5e					ld e,(hl) 
3024 23					inc hl 
3025 56					ld d, (hl) 
3026			 
3026					if DEBUG_FORTH_WORDS 
3026						DMARK "+2a" 
3026 f5				push af  
3027 3a 3b 30			ld a, (.dmark)  
302a 32 b4 fe			ld (debug_mark),a  
302d 3a 3c 30			ld a, (.dmark+1)  
3030 32 b5 fe			ld (debug_mark+1),a  
3033 3a 3d 30			ld a, (.dmark+2)  
3036 32 b6 fe			ld (debug_mark+2),a  
3039 18 03			jr .pastdmark  
303b ..			.dmark: db "+2a"  
303e f1			.pastdmark: pop af  
303f			endm  
# End of macro DMARK
303f						CALLMONITOR 
303f cd c6 18			call break_point_state  
3042				endm  
# End of macro CALLMONITOR
3042					endif 
3042			 
3042					FORTH_DSP_POP 
3042 cd e9 21			call macro_forth_dsp_pop 
3045				endm 
# End of macro FORTH_DSP_POP
3045			 
3045					; Get value to add 
3045			 
3045					FORTH_DSP_VALUE 
3045 cd 1a 21			call macro_forth_dsp_value 
3048				endm 
# End of macro FORTH_DSP_VALUE
3048			 
3048					if DEBUG_FORTH_WORDS 
3048						DMARK "+2v" 
3048 f5				push af  
3049 3a 5d 30			ld a, (.dmark)  
304c 32 b4 fe			ld (debug_mark),a  
304f 3a 5e 30			ld a, (.dmark+1)  
3052 32 b5 fe			ld (debug_mark+1),a  
3055 3a 5f 30			ld a, (.dmark+2)  
3058 32 b6 fe			ld (debug_mark+2),a  
305b 18 03			jr .pastdmark  
305d ..			.dmark: db "+2v"  
3060 f1			.pastdmark: pop af  
3061			endm  
# End of macro DMARK
3061						CALLMONITOR 
3061 cd c6 18			call break_point_state  
3064				endm  
# End of macro CALLMONITOR
3064					endif 
3064			 
3064 19					add hl, de 
3065			 
3065					if DEBUG_FORTH_WORDS 
3065						DMARK "+2+" 
3065 f5				push af  
3066 3a 7a 30			ld a, (.dmark)  
3069 32 b4 fe			ld (debug_mark),a  
306c 3a 7b 30			ld a, (.dmark+1)  
306f 32 b5 fe			ld (debug_mark+1),a  
3072 3a 7c 30			ld a, (.dmark+2)  
3075 32 b6 fe			ld (debug_mark+2),a  
3078 18 03			jr .pastdmark  
307a ..			.dmark: db "+2+"  
307d f1			.pastdmark: pop af  
307e			endm  
# End of macro DMARK
307e						CALLMONITOR 
307e cd c6 18			call break_point_state  
3081				endm  
# End of macro CALLMONITOR
3081					endif 
3081			 
3081					; move result to de 
3081			 
3081 eb					ex de, hl 
3082			 
3082					; Address 
3082			 
3082 e1					pop hl 
3083			 
3083					; save it back 
3083			 
3083 73					ld (hl), e 
3084 23					inc hl 
3085 72					ld (hl), d 
3086			 
3086					if DEBUG_FORTH_WORDS 
3086						DMARK "+2e" 
3086 f5				push af  
3087 3a 9b 30			ld a, (.dmark)  
308a 32 b4 fe			ld (debug_mark),a  
308d 3a 9c 30			ld a, (.dmark+1)  
3090 32 b5 fe			ld (debug_mark+1),a  
3093 3a 9d 30			ld a, (.dmark+2)  
3096 32 b6 fe			ld (debug_mark+2),a  
3099 18 03			jr .pastdmark  
309b ..			.dmark: db "+2e"  
309e f1			.pastdmark: pop af  
309f			endm  
# End of macro DMARK
309f						CALLMONITOR 
309f cd c6 18			call break_point_state  
30a2				endm  
# End of macro CALLMONITOR
30a2					endif 
30a2			 
30a2			 
30a2			 
30a2			 
30a2			 
30a2				       NEXTW 
30a2 c3 e7 22			jp macro_next 
30a5				endm 
# End of macro NEXTW
30a5			 
30a5			.DEC2: 
30a5				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
30a5 6f				db WORD_SYS_CORE+91             
30a6 51 31			dw .GET2            
30a8 04				db 3 + 1 
30a9 .. 00			db "-2!",0              
30ad				endm 
# End of macro CWHEAD
30ad			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
30ad			 
30ad			 
30ad					if DEBUG_FORTH_WORDS_KEY 
30ad						DMARK "-2s" 
30ad f5				push af  
30ae 3a c2 30			ld a, (.dmark)  
30b1 32 b4 fe			ld (debug_mark),a  
30b4 3a c3 30			ld a, (.dmark+1)  
30b7 32 b5 fe			ld (debug_mark+1),a  
30ba 3a c4 30			ld a, (.dmark+2)  
30bd 32 b6 fe			ld (debug_mark+2),a  
30c0 18 03			jr .pastdmark  
30c2 ..			.dmark: db "-2s"  
30c5 f1			.pastdmark: pop af  
30c6			endm  
# End of macro DMARK
30c6						CALLMONITOR 
30c6 cd c6 18			call break_point_state  
30c9				endm  
# End of macro CALLMONITOR
30c9					endif 
30c9			 
30c9					; Address 
30c9			 
30c9					FORTH_DSP_VALUEHL 
30c9 cd 31 21			call macro_dsp_valuehl 
30cc				endm 
# End of macro FORTH_DSP_VALUEHL
30cc			 
30cc e5					push hl    ; save address 
30cd			 
30cd					; load content into de 
30cd			 
30cd 5e					ld e,(hl) 
30ce 23					inc hl 
30cf 56					ld d, (hl) 
30d0			 
30d0					if DEBUG_FORTH_WORDS 
30d0						DMARK "-2a" 
30d0 f5				push af  
30d1 3a e5 30			ld a, (.dmark)  
30d4 32 b4 fe			ld (debug_mark),a  
30d7 3a e6 30			ld a, (.dmark+1)  
30da 32 b5 fe			ld (debug_mark+1),a  
30dd 3a e7 30			ld a, (.dmark+2)  
30e0 32 b6 fe			ld (debug_mark+2),a  
30e3 18 03			jr .pastdmark  
30e5 ..			.dmark: db "-2a"  
30e8 f1			.pastdmark: pop af  
30e9			endm  
# End of macro DMARK
30e9						CALLMONITOR 
30e9 cd c6 18			call break_point_state  
30ec				endm  
# End of macro CALLMONITOR
30ec					endif 
30ec			 
30ec					FORTH_DSP_POP 
30ec cd e9 21			call macro_forth_dsp_pop 
30ef				endm 
# End of macro FORTH_DSP_POP
30ef			 
30ef					; Get value to remove 
30ef			 
30ef					FORTH_DSP_VALUE 
30ef cd 1a 21			call macro_forth_dsp_value 
30f2				endm 
# End of macro FORTH_DSP_VALUE
30f2			 
30f2					if DEBUG_FORTH_WORDS 
30f2						DMARK "-2v" 
30f2 f5				push af  
30f3 3a 07 31			ld a, (.dmark)  
30f6 32 b4 fe			ld (debug_mark),a  
30f9 3a 08 31			ld a, (.dmark+1)  
30fc 32 b5 fe			ld (debug_mark+1),a  
30ff 3a 09 31			ld a, (.dmark+2)  
3102 32 b6 fe			ld (debug_mark+2),a  
3105 18 03			jr .pastdmark  
3107 ..			.dmark: db "-2v"  
310a f1			.pastdmark: pop af  
310b			endm  
# End of macro DMARK
310b						CALLMONITOR 
310b cd c6 18			call break_point_state  
310e				endm  
# End of macro CALLMONITOR
310e					endif 
310e			 
310e eb					ex de, hl 
310f ed 52				sbc hl, de 
3111			 
3111					if DEBUG_FORTH_WORDS 
3111						DMARK "-2d" 
3111 f5				push af  
3112 3a 26 31			ld a, (.dmark)  
3115 32 b4 fe			ld (debug_mark),a  
3118 3a 27 31			ld a, (.dmark+1)  
311b 32 b5 fe			ld (debug_mark+1),a  
311e 3a 28 31			ld a, (.dmark+2)  
3121 32 b6 fe			ld (debug_mark+2),a  
3124 18 03			jr .pastdmark  
3126 ..			.dmark: db "-2d"  
3129 f1			.pastdmark: pop af  
312a			endm  
# End of macro DMARK
312a						CALLMONITOR 
312a cd c6 18			call break_point_state  
312d				endm  
# End of macro CALLMONITOR
312d					endif 
312d			 
312d					; move result to de 
312d			 
312d eb					ex de, hl 
312e			 
312e					; Address 
312e			 
312e e1					pop hl 
312f			 
312f					; save it back 
312f			 
312f 73					ld (hl), e 
3130 23					inc hl 
3131 72					ld (hl), d 
3132			 
3132					if DEBUG_FORTH_WORDS 
3132						DMARK "-2e" 
3132 f5				push af  
3133 3a 47 31			ld a, (.dmark)  
3136 32 b4 fe			ld (debug_mark),a  
3139 3a 48 31			ld a, (.dmark+1)  
313c 32 b5 fe			ld (debug_mark+1),a  
313f 3a 49 31			ld a, (.dmark+2)  
3142 32 b6 fe			ld (debug_mark+2),a  
3145 18 03			jr .pastdmark  
3147 ..			.dmark: db "-2e"  
314a f1			.pastdmark: pop af  
314b			endm  
# End of macro DMARK
314b						CALLMONITOR 
314b cd c6 18			call break_point_state  
314e				endm  
# End of macro CALLMONITOR
314e					endif 
314e			 
314e			 
314e			 
314e			 
314e			 
314e				       NEXTW 
314e c3 e7 22			jp macro_next 
3151				endm 
# End of macro NEXTW
3151			.GET2: 
3151				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3151 6f				db WORD_SYS_CORE+91             
3152 81 31			dw .BANG2            
3154 03				db 2 + 1 
3155 .. 00			db "2@",0              
3158				endm 
# End of macro CWHEAD
3158			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3158					if DEBUG_FORTH_WORDS_KEY 
3158						DMARK "2A_" 
3158 f5				push af  
3159 3a 6d 31			ld a, (.dmark)  
315c 32 b4 fe			ld (debug_mark),a  
315f 3a 6e 31			ld a, (.dmark+1)  
3162 32 b5 fe			ld (debug_mark+1),a  
3165 3a 6f 31			ld a, (.dmark+2)  
3168 32 b6 fe			ld (debug_mark+2),a  
316b 18 03			jr .pastdmark  
316d ..			.dmark: db "2A_"  
3170 f1			.pastdmark: pop af  
3171			endm  
# End of macro DMARK
3171						CALLMONITOR 
3171 cd c6 18			call break_point_state  
3174				endm  
# End of macro CALLMONITOR
3174					endif 
3174			 
3174					FORTH_DSP_VALUEHL 
3174 cd 31 21			call macro_dsp_valuehl 
3177				endm 
# End of macro FORTH_DSP_VALUEHL
3177			 
3177 5e					ld e, (hl) 
3178 23					inc hl 
3179 56					ld d, (hl) 
317a			 
317a eb					ex de, hl 
317b			 
317b cd 3a 1f				call forth_push_numhl 
317e			 
317e				       NEXTW 
317e c3 e7 22			jp macro_next 
3181				endm 
# End of macro NEXTW
3181			.BANG2: 
3181				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3181 6f				db WORD_SYS_CORE+91             
3182 b9 31			dw .CONFIG            
3184 03				db 2 + 1 
3185 .. 00			db "2!",0              
3188				endm 
# End of macro CWHEAD
3188			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3188					if DEBUG_FORTH_WORDS_KEY 
3188						DMARK "2S_" 
3188 f5				push af  
3189 3a 9d 31			ld a, (.dmark)  
318c 32 b4 fe			ld (debug_mark),a  
318f 3a 9e 31			ld a, (.dmark+1)  
3192 32 b5 fe			ld (debug_mark+1),a  
3195 3a 9f 31			ld a, (.dmark+2)  
3198 32 b6 fe			ld (debug_mark+2),a  
319b 18 03			jr .pastdmark  
319d ..			.dmark: db "2S_"  
31a0 f1			.pastdmark: pop af  
31a1			endm  
# End of macro DMARK
31a1						CALLMONITOR 
31a1 cd c6 18			call break_point_state  
31a4				endm  
# End of macro CALLMONITOR
31a4					endif 
31a4			 
31a4					FORTH_DSP_VALUEHL 
31a4 cd 31 21			call macro_dsp_valuehl 
31a7				endm 
# End of macro FORTH_DSP_VALUEHL
31a7			 
31a7 e5					push hl   ; save address 
31a8			 
31a8			 
31a8					FORTH_DSP_POP 
31a8 cd e9 21			call macro_forth_dsp_pop 
31ab				endm 
# End of macro FORTH_DSP_POP
31ab			 
31ab					 
31ab					FORTH_DSP_VALUEHL 
31ab cd 31 21			call macro_dsp_valuehl 
31ae				endm 
# End of macro FORTH_DSP_VALUEHL
31ae			 
31ae					FORTH_DSP_POP 
31ae cd e9 21			call macro_forth_dsp_pop 
31b1				endm 
# End of macro FORTH_DSP_POP
31b1			 
31b1 eb					ex de, hl    ; value now in de 
31b2			 
31b2 e1					pop hl 
31b3			 
31b3 73					ld (hl), e 
31b4			 
31b4 23					inc hl 
31b5			 
31b5 72					ld (hl), d 
31b6			 
31b6			 
31b6				       NEXTW 
31b6 c3 e7 22			jp macro_next 
31b9				endm 
# End of macro NEXTW
31b9			.CONFIG: 
31b9				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
31b9 6f				db WORD_SYS_CORE+91             
31ba ca 31			dw .ENDCORE            
31bc 07				db 6 + 1 
31bd .. 00			db "CONFIG",0              
31c4				endm 
# End of macro CWHEAD
31c4			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
31c4			 
31c4 cd a9 15				call config 
31c7					NEXTW 
31c7 c3 e7 22			jp macro_next 
31ca				endm 
# End of macro NEXTW
31ca			.ENDCORE: 
31ca			 
31ca			; eof 
31ca			 
31ca			 
# End of file forth_words_core.asm
31ca			include "forth_words_flow.asm" 
31ca			 
31ca			; | ## Program Flow Words 
31ca			 
31ca			.IF: 
31ca				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
31ca 1e				db WORD_SYS_CORE+10             
31cb bf 32			dw .THEN            
31cd 03				db 2 + 1 
31ce .. 00			db "IF",0              
31d1				endm 
# End of macro CWHEAD
31d1			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
31d1			; 
31d1					if DEBUG_FORTH_WORDS_KEY 
31d1						DMARK "IF." 
31d1 f5				push af  
31d2 3a e6 31			ld a, (.dmark)  
31d5 32 b4 fe			ld (debug_mark),a  
31d8 3a e7 31			ld a, (.dmark+1)  
31db 32 b5 fe			ld (debug_mark+1),a  
31de 3a e8 31			ld a, (.dmark+2)  
31e1 32 b6 fe			ld (debug_mark+2),a  
31e4 18 03			jr .pastdmark  
31e6 ..			.dmark: db "IF."  
31e9 f1			.pastdmark: pop af  
31ea			endm  
# End of macro DMARK
31ea						CALLMONITOR 
31ea cd c6 18			call break_point_state  
31ed				endm  
# End of macro CALLMONITOR
31ed					endif 
31ed			; eval TOS 
31ed			 
31ed				FORTH_DSP_VALUEHL 
31ed cd 31 21			call macro_dsp_valuehl 
31f0				endm 
# End of macro FORTH_DSP_VALUEHL
31f0			 
31f0			;	push hl 
31f0				FORTH_DSP_POP 
31f0 cd e9 21			call macro_forth_dsp_pop 
31f3				endm 
# End of macro FORTH_DSP_POP
31f3			;	pop hl 
31f3			 
31f3					if DEBUG_FORTH_WORDS 
31f3						DMARK "IF1" 
31f3 f5				push af  
31f4 3a 08 32			ld a, (.dmark)  
31f7 32 b4 fe			ld (debug_mark),a  
31fa 3a 09 32			ld a, (.dmark+1)  
31fd 32 b5 fe			ld (debug_mark+1),a  
3200 3a 0a 32			ld a, (.dmark+2)  
3203 32 b6 fe			ld (debug_mark+2),a  
3206 18 03			jr .pastdmark  
3208 ..			.dmark: db "IF1"  
320b f1			.pastdmark: pop af  
320c			endm  
# End of macro DMARK
320c						CALLMONITOR 
320c cd c6 18			call break_point_state  
320f				endm  
# End of macro CALLMONITOR
320f					endif 
320f b7				or a        ; clear carry flag 
3210 11 00 00			ld de, 0 
3213 eb				ex de,hl 
3214 ed 52			sbc hl, de 
3216 c2 a0 32			jp nz, .iftrue 
3219			 
3219					if DEBUG_FORTH_WORDS 
3219						DMARK "IF2" 
3219 f5				push af  
321a 3a 2e 32			ld a, (.dmark)  
321d 32 b4 fe			ld (debug_mark),a  
3220 3a 2f 32			ld a, (.dmark+1)  
3223 32 b5 fe			ld (debug_mark+1),a  
3226 3a 30 32			ld a, (.dmark+2)  
3229 32 b6 fe			ld (debug_mark+2),a  
322c 18 03			jr .pastdmark  
322e ..			.dmark: db "IF2"  
3231 f1			.pastdmark: pop af  
3232			endm  
# End of macro DMARK
3232						CALLMONITOR 
3232 cd c6 18			call break_point_state  
3235				endm  
# End of macro CALLMONITOR
3235					endif 
3235			 
3235			; if not true then skip to THEN 
3235			 
3235				; TODO get tok_ptr 
3235				; TODO consume toks until we get to THEN 
3235			 
3235 2a 4f f6			ld hl, (os_tok_ptr) 
3238					if DEBUG_FORTH_WORDS 
3238						DMARK "IF3" 
3238 f5				push af  
3239 3a 4d 32			ld a, (.dmark)  
323c 32 b4 fe			ld (debug_mark),a  
323f 3a 4e 32			ld a, (.dmark+1)  
3242 32 b5 fe			ld (debug_mark+1),a  
3245 3a 4f 32			ld a, (.dmark+2)  
3248 32 b6 fe			ld (debug_mark+2),a  
324b 18 03			jr .pastdmark  
324d ..			.dmark: db "IF3"  
3250 f1			.pastdmark: pop af  
3251			endm  
# End of macro DMARK
3251						CALLMONITOR 
3251 cd c6 18			call break_point_state  
3254				endm  
# End of macro CALLMONITOR
3254						 
3254					endif 
3254 11 9b 32			ld de, .ifthen 
3257					if DEBUG_FORTH_WORDS 
3257						DMARK "IF4" 
3257 f5				push af  
3258 3a 6c 32			ld a, (.dmark)  
325b 32 b4 fe			ld (debug_mark),a  
325e 3a 6d 32			ld a, (.dmark+1)  
3261 32 b5 fe			ld (debug_mark+1),a  
3264 3a 6e 32			ld a, (.dmark+2)  
3267 32 b6 fe			ld (debug_mark+2),a  
326a 18 03			jr .pastdmark  
326c ..			.dmark: db "IF4"  
326f f1			.pastdmark: pop af  
3270			endm  
# End of macro DMARK
3270						CALLMONITOR 
3270 cd c6 18			call break_point_state  
3273				endm  
# End of macro CALLMONITOR
3273					endif 
3273 cd 02 24			call findnexttok  
3276			 
3276					if DEBUG_FORTH_WORDS 
3276						DMARK "IF5" 
3276 f5				push af  
3277 3a 8b 32			ld a, (.dmark)  
327a 32 b4 fe			ld (debug_mark),a  
327d 3a 8c 32			ld a, (.dmark+1)  
3280 32 b5 fe			ld (debug_mark+1),a  
3283 3a 8d 32			ld a, (.dmark+2)  
3286 32 b6 fe			ld (debug_mark+2),a  
3289 18 03			jr .pastdmark  
328b ..			.dmark: db "IF5"  
328e f1			.pastdmark: pop af  
328f			endm  
# End of macro DMARK
328f						CALLMONITOR 
328f cd c6 18			call break_point_state  
3292				endm  
# End of macro CALLMONITOR
3292					endif 
3292				; TODO replace below with ; exec using tok_ptr 
3292 22 4f f6			ld (os_tok_ptr), hl 
3295 c3 78 23			jp exec1 
3298				NEXTW 
3298 c3 e7 22			jp macro_next 
329b				endm 
# End of macro NEXTW
329b			 
329b .. 00		.ifthen:  db "THEN",0 
32a0			 
32a0			.iftrue:		 
32a0				; Exec next words normally 
32a0			 
32a0				; if true then exec following IF as normal 
32a0					if DEBUG_FORTH_WORDS 
32a0						DMARK "IFT" 
32a0 f5				push af  
32a1 3a b5 32			ld a, (.dmark)  
32a4 32 b4 fe			ld (debug_mark),a  
32a7 3a b6 32			ld a, (.dmark+1)  
32aa 32 b5 fe			ld (debug_mark+1),a  
32ad 3a b7 32			ld a, (.dmark+2)  
32b0 32 b6 fe			ld (debug_mark+2),a  
32b3 18 03			jr .pastdmark  
32b5 ..			.dmark: db "IFT"  
32b8 f1			.pastdmark: pop af  
32b9			endm  
# End of macro DMARK
32b9						CALLMONITOR 
32b9 cd c6 18			call break_point_state  
32bc				endm  
# End of macro CALLMONITOR
32bc					endif 
32bc			 
32bc					NEXTW 
32bc c3 e7 22			jp macro_next 
32bf				endm 
# End of macro NEXTW
32bf			.THEN: 
32bf				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
32bf 1f				db WORD_SYS_CORE+11             
32c0 e7 32			dw .ELSE            
32c2 05				db 4 + 1 
32c3 .. 00			db "THEN",0              
32c8				endm 
# End of macro CWHEAD
32c8			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
32c8					if DEBUG_FORTH_WORDS_KEY 
32c8						DMARK "THN" 
32c8 f5				push af  
32c9 3a dd 32			ld a, (.dmark)  
32cc 32 b4 fe			ld (debug_mark),a  
32cf 3a de 32			ld a, (.dmark+1)  
32d2 32 b5 fe			ld (debug_mark+1),a  
32d5 3a df 32			ld a, (.dmark+2)  
32d8 32 b6 fe			ld (debug_mark+2),a  
32db 18 03			jr .pastdmark  
32dd ..			.dmark: db "THN"  
32e0 f1			.pastdmark: pop af  
32e1			endm  
# End of macro DMARK
32e1						CALLMONITOR 
32e1 cd c6 18			call break_point_state  
32e4				endm  
# End of macro CALLMONITOR
32e4					endif 
32e4					NEXTW 
32e4 c3 e7 22			jp macro_next 
32e7				endm 
# End of macro NEXTW
32e7			.ELSE: 
32e7				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
32e7 20				db WORD_SYS_CORE+12             
32e8 0f 33			dw .DO            
32ea 03				db 2 + 1 
32eb .. 00			db "ELSE",0              
32f0				endm 
# End of macro CWHEAD
32f0			; | ELSE ( -- ) Not supported - does nothing | TODO 
32f0			 
32f0					if DEBUG_FORTH_WORDS_KEY 
32f0						DMARK "ELS" 
32f0 f5				push af  
32f1 3a 05 33			ld a, (.dmark)  
32f4 32 b4 fe			ld (debug_mark),a  
32f7 3a 06 33			ld a, (.dmark+1)  
32fa 32 b5 fe			ld (debug_mark+1),a  
32fd 3a 07 33			ld a, (.dmark+2)  
3300 32 b6 fe			ld (debug_mark+2),a  
3303 18 03			jr .pastdmark  
3305 ..			.dmark: db "ELS"  
3308 f1			.pastdmark: pop af  
3309			endm  
# End of macro DMARK
3309						CALLMONITOR 
3309 cd c6 18			call break_point_state  
330c				endm  
# End of macro CALLMONITOR
330c					endif 
330c			 
330c			 
330c					NEXTW 
330c c3 e7 22			jp macro_next 
330f				endm 
# End of macro NEXTW
330f			.DO: 
330f				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
330f 21				db WORD_SYS_CORE+13             
3310 36 34			dw .LOOP            
3312 03				db 2 + 1 
3313 .. 00			db "DO",0              
3316				endm 
# End of macro CWHEAD
3316			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3316			 
3316					if DEBUG_FORTH_WORDS_KEY 
3316						DMARK "DO." 
3316 f5				push af  
3317 3a 2b 33			ld a, (.dmark)  
331a 32 b4 fe			ld (debug_mark),a  
331d 3a 2c 33			ld a, (.dmark+1)  
3320 32 b5 fe			ld (debug_mark+1),a  
3323 3a 2d 33			ld a, (.dmark+2)  
3326 32 b6 fe			ld (debug_mark+2),a  
3329 18 03			jr .pastdmark  
332b ..			.dmark: db "DO."  
332e f1			.pastdmark: pop af  
332f			endm  
# End of macro DMARK
332f						CALLMONITOR 
332f cd c6 18			call break_point_state  
3332				endm  
# End of macro CALLMONITOR
3332					endif 
3332			;  push pc to rsp stack past the DO 
3332			 
3332 2a 4f f6				ld hl, (os_tok_ptr) 
3335 23					inc hl   ; D 
3336 23					inc hl  ; O 
3337 23					inc hl   ; null 
3338					if DEBUG_FORTH_WORDS 
3338						DMARK "DO2" 
3338 f5				push af  
3339 3a 4d 33			ld a, (.dmark)  
333c 32 b4 fe			ld (debug_mark),a  
333f 3a 4e 33			ld a, (.dmark+1)  
3342 32 b5 fe			ld (debug_mark+1),a  
3345 3a 4f 33			ld a, (.dmark+2)  
3348 32 b6 fe			ld (debug_mark+2),a  
334b 18 03			jr .pastdmark  
334d ..			.dmark: db "DO2"  
3350 f1			.pastdmark: pop af  
3351			endm  
# End of macro DMARK
3351						CALLMONITOR 
3351 cd c6 18			call break_point_state  
3354				endm  
# End of macro CALLMONITOR
3354					endif 
3354					FORTH_RSP_NEXT 
3354 cd e1 1e			call macro_forth_rsp_next 
3357				endm 
# End of macro FORTH_RSP_NEXT
3357					if DEBUG_FORTH_WORDS 
3357						DMARK "DO3" 
3357 f5				push af  
3358 3a 6c 33			ld a, (.dmark)  
335b 32 b4 fe			ld (debug_mark),a  
335e 3a 6d 33			ld a, (.dmark+1)  
3361 32 b5 fe			ld (debug_mark+1),a  
3364 3a 6e 33			ld a, (.dmark+2)  
3367 32 b6 fe			ld (debug_mark+2),a  
336a 18 03			jr .pastdmark  
336c ..			.dmark: db "DO3"  
336f f1			.pastdmark: pop af  
3370			endm  
# End of macro DMARK
3370						CALLMONITOR 
3370 cd c6 18			call break_point_state  
3373				endm  
# End of macro CALLMONITOR
3373					endif 
3373			 
3373					;if DEBUG_FORTH_WORDS 
3373				;		push hl 
3373			;		endif  
3373			 
3373			; get counters from data stack 
3373			 
3373			 
3373					FORTH_DSP_VALUEHL 
3373 cd 31 21			call macro_dsp_valuehl 
3376				endm 
# End of macro FORTH_DSP_VALUEHL
3376 e5					push hl		 ; hl now has starting counter which needs to be tos 
3377			 
3377					if DEBUG_FORTH_WORDS 
3377						DMARK "DO4" 
3377 f5				push af  
3378 3a 8c 33			ld a, (.dmark)  
337b 32 b4 fe			ld (debug_mark),a  
337e 3a 8d 33			ld a, (.dmark+1)  
3381 32 b5 fe			ld (debug_mark+1),a  
3384 3a 8e 33			ld a, (.dmark+2)  
3387 32 b6 fe			ld (debug_mark+2),a  
338a 18 03			jr .pastdmark  
338c ..			.dmark: db "DO4"  
338f f1			.pastdmark: pop af  
3390			endm  
# End of macro DMARK
3390						CALLMONITOR 
3390 cd c6 18			call break_point_state  
3393				endm  
# End of macro CALLMONITOR
3393					endif 
3393					FORTH_DSP_POP 
3393 cd e9 21			call macro_forth_dsp_pop 
3396				endm 
# End of macro FORTH_DSP_POP
3396			 
3396					if DEBUG_FORTH_WORDS 
3396						DMARK "DO5" 
3396 f5				push af  
3397 3a ab 33			ld a, (.dmark)  
339a 32 b4 fe			ld (debug_mark),a  
339d 3a ac 33			ld a, (.dmark+1)  
33a0 32 b5 fe			ld (debug_mark+1),a  
33a3 3a ad 33			ld a, (.dmark+2)  
33a6 32 b6 fe			ld (debug_mark+2),a  
33a9 18 03			jr .pastdmark  
33ab ..			.dmark: db "DO5"  
33ae f1			.pastdmark: pop af  
33af			endm  
# End of macro DMARK
33af						CALLMONITOR 
33af cd c6 18			call break_point_state  
33b2				endm  
# End of macro CALLMONITOR
33b2					endif 
33b2			 
33b2					FORTH_DSP_VALUEHL 
33b2 cd 31 21			call macro_dsp_valuehl 
33b5				endm 
# End of macro FORTH_DSP_VALUEHL
33b5			;		push hl		 ; hl now has starting limit counter 
33b5			 
33b5					if DEBUG_FORTH_WORDS 
33b5						DMARK "DO6" 
33b5 f5				push af  
33b6 3a ca 33			ld a, (.dmark)  
33b9 32 b4 fe			ld (debug_mark),a  
33bc 3a cb 33			ld a, (.dmark+1)  
33bf 32 b5 fe			ld (debug_mark+1),a  
33c2 3a cc 33			ld a, (.dmark+2)  
33c5 32 b6 fe			ld (debug_mark+2),a  
33c8 18 03			jr .pastdmark  
33ca ..			.dmark: db "DO6"  
33cd f1			.pastdmark: pop af  
33ce			endm  
# End of macro DMARK
33ce						CALLMONITOR 
33ce cd c6 18			call break_point_state  
33d1				endm  
# End of macro CALLMONITOR
33d1					endif 
33d1					FORTH_DSP_POP 
33d1 cd e9 21			call macro_forth_dsp_pop 
33d4				endm 
# End of macro FORTH_DSP_POP
33d4			 
33d4			; put counters on the loop stack 
33d4			 
33d4			;		pop hl			 ; limit counter 
33d4 d1					pop de			; start counter 
33d5			 
33d5					; push limit counter 
33d5			 
33d5					if DEBUG_FORTH_WORDS 
33d5						DMARK "DO7" 
33d5 f5				push af  
33d6 3a ea 33			ld a, (.dmark)  
33d9 32 b4 fe			ld (debug_mark),a  
33dc 3a eb 33			ld a, (.dmark+1)  
33df 32 b5 fe			ld (debug_mark+1),a  
33e2 3a ec 33			ld a, (.dmark+2)  
33e5 32 b6 fe			ld (debug_mark+2),a  
33e8 18 03			jr .pastdmark  
33ea ..			.dmark: db "DO7"  
33ed f1			.pastdmark: pop af  
33ee			endm  
# End of macro DMARK
33ee						CALLMONITOR 
33ee cd c6 18			call break_point_state  
33f1				endm  
# End of macro CALLMONITOR
33f1					endif 
33f1					FORTH_LOOP_NEXT 
33f1 cd 62 21			call macro_forth_loop_next 
33f4				endm 
# End of macro FORTH_LOOP_NEXT
33f4			 
33f4					; push start counter 
33f4			 
33f4 eb					ex de, hl 
33f5					if DEBUG_FORTH_WORDS 
33f5						DMARK "DO7" 
33f5 f5				push af  
33f6 3a 0a 34			ld a, (.dmark)  
33f9 32 b4 fe			ld (debug_mark),a  
33fc 3a 0b 34			ld a, (.dmark+1)  
33ff 32 b5 fe			ld (debug_mark+1),a  
3402 3a 0c 34			ld a, (.dmark+2)  
3405 32 b6 fe			ld (debug_mark+2),a  
3408 18 03			jr .pastdmark  
340a ..			.dmark: db "DO7"  
340d f1			.pastdmark: pop af  
340e			endm  
# End of macro DMARK
340e						CALLMONITOR 
340e cd c6 18			call break_point_state  
3411				endm  
# End of macro CALLMONITOR
3411					endif 
3411					FORTH_LOOP_NEXT 
3411 cd 62 21			call macro_forth_loop_next 
3414				endm 
# End of macro FORTH_LOOP_NEXT
3414			 
3414			 
3414					; init first round of I counter 
3414			 
3414 22 73 f6				ld (os_current_i), hl 
3417			 
3417					if DEBUG_FORTH_WORDS 
3417						DMARK "DO8" 
3417 f5				push af  
3418 3a 2c 34			ld a, (.dmark)  
341b 32 b4 fe			ld (debug_mark),a  
341e 3a 2d 34			ld a, (.dmark+1)  
3421 32 b5 fe			ld (debug_mark+1),a  
3424 3a 2e 34			ld a, (.dmark+2)  
3427 32 b6 fe			ld (debug_mark+2),a  
342a 18 03			jr .pastdmark  
342c ..			.dmark: db "DO8"  
342f f1			.pastdmark: pop af  
3430			endm  
# End of macro DMARK
3430						CALLMONITOR 
3430 cd c6 18			call break_point_state  
3433				endm  
# End of macro CALLMONITOR
3433					endif 
3433			 
3433					NEXTW 
3433 c3 e7 22			jp macro_next 
3436				endm 
# End of macro NEXTW
3436			.LOOP: 
3436				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3436 22				db WORD_SYS_CORE+14             
3437 4e 35			dw .I            
3439 05				db 4 + 1 
343a .. 00			db "LOOP",0              
343f				endm 
# End of macro CWHEAD
343f			; | LOOP ( -- ) Increment and test loop counter  | DONE 
343f			 
343f				; pop tos as current loop count to hl 
343f			 
343f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
343f			 
343f				FORTH_LOOP_TOS 
343f cd 95 21			call macro_forth_loop_tos 
3442				endm 
# End of macro FORTH_LOOP_TOS
3442 e5				push hl 
3443			 
3443					if DEBUG_FORTH_WORDS_KEY 
3443						DMARK "LOP" 
3443 f5				push af  
3444 3a 58 34			ld a, (.dmark)  
3447 32 b4 fe			ld (debug_mark),a  
344a 3a 59 34			ld a, (.dmark+1)  
344d 32 b5 fe			ld (debug_mark+1),a  
3450 3a 5a 34			ld a, (.dmark+2)  
3453 32 b6 fe			ld (debug_mark+2),a  
3456 18 03			jr .pastdmark  
3458 ..			.dmark: db "LOP"  
345b f1			.pastdmark: pop af  
345c			endm  
# End of macro DMARK
345c						CALLMONITOR 
345c cd c6 18			call break_point_state  
345f				endm  
# End of macro CALLMONITOR
345f					endif 
345f				; next item on the stack is the limit. get it 
345f			 
345f			 
345f				FORTH_LOOP_POP 
345f cd 9f 21			call macro_forth_loop_pop 
3462				endm 
# End of macro FORTH_LOOP_POP
3462			 
3462				FORTH_LOOP_TOS 
3462 cd 95 21			call macro_forth_loop_tos 
3465				endm 
# End of macro FORTH_LOOP_TOS
3465			 
3465 d1				pop de		 ; de = i, hl = limit 
3466			 
3466					if DEBUG_FORTH_WORDS 
3466						DMARK "LP1" 
3466 f5				push af  
3467 3a 7b 34			ld a, (.dmark)  
346a 32 b4 fe			ld (debug_mark),a  
346d 3a 7c 34			ld a, (.dmark+1)  
3470 32 b5 fe			ld (debug_mark+1),a  
3473 3a 7d 34			ld a, (.dmark+2)  
3476 32 b6 fe			ld (debug_mark+2),a  
3479 18 03			jr .pastdmark  
347b ..			.dmark: db "LP1"  
347e f1			.pastdmark: pop af  
347f			endm  
# End of macro DMARK
347f						CALLMONITOR 
347f cd c6 18			call break_point_state  
3482				endm  
# End of macro CALLMONITOR
3482					endif 
3482			 
3482				; go back to previous word 
3482			 
3482 d5				push de    ; save I for inc later 
3483			 
3483			 
3483				; get limit 
3483				;  is I at limit? 
3483			 
3483			 
3483					if DEBUG_FORTH_WORDS 
3483						DMARK "LP1" 
3483 f5				push af  
3484 3a 98 34			ld a, (.dmark)  
3487 32 b4 fe			ld (debug_mark),a  
348a 3a 99 34			ld a, (.dmark+1)  
348d 32 b5 fe			ld (debug_mark+1),a  
3490 3a 9a 34			ld a, (.dmark+2)  
3493 32 b6 fe			ld (debug_mark+2),a  
3496 18 03			jr .pastdmark  
3498 ..			.dmark: db "LP1"  
349b f1			.pastdmark: pop af  
349c			endm  
# End of macro DMARK
349c						CALLMONITOR 
349c cd c6 18			call break_point_state  
349f				endm  
# End of macro CALLMONITOR
349f					endif 
349f			 
349f ed 52			sbc hl, de 
34a1			 
34a1			 
34a1				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
34a1			 
34a1 20 26				jr nz, .loopnotdone 
34a3			 
34a3 e1				pop hl   ; get rid of saved I 
34a4				FORTH_LOOP_POP     ; get rid of limit 
34a4 cd 9f 21			call macro_forth_loop_pop 
34a7				endm 
# End of macro FORTH_LOOP_POP
34a7			 
34a7				FORTH_RSP_POP     ; get rid of DO ptr 
34a7 cd 02 1f			call macro_forth_rsp_pop 
34aa				endm 
# End of macro FORTH_RSP_POP
34aa			 
34aa			if DEBUG_FORTH_WORDS 
34aa						DMARK "LP>" 
34aa f5				push af  
34ab 3a bf 34			ld a, (.dmark)  
34ae 32 b4 fe			ld (debug_mark),a  
34b1 3a c0 34			ld a, (.dmark+1)  
34b4 32 b5 fe			ld (debug_mark+1),a  
34b7 3a c1 34			ld a, (.dmark+2)  
34ba 32 b6 fe			ld (debug_mark+2),a  
34bd 18 03			jr .pastdmark  
34bf ..			.dmark: db "LP>"  
34c2 f1			.pastdmark: pop af  
34c3			endm  
# End of macro DMARK
34c3				CALLMONITOR 
34c3 cd c6 18			call break_point_state  
34c6				endm  
# End of macro CALLMONITOR
34c6			endif 
34c6			 
34c6					NEXTW 
34c6 c3 e7 22			jp macro_next 
34c9				endm 
# End of macro NEXTW
34c9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34c9			 
34c9			.loopnotdone: 
34c9			 
34c9 e1				pop hl    ; get I 
34ca 23				inc hl 
34cb			 
34cb			   	; save new I 
34cb			 
34cb			 
34cb					; set I counter 
34cb			 
34cb 22 73 f6				ld (os_current_i), hl 
34ce			 
34ce					if DEBUG_FORTH_WORDS 
34ce						DMARK "LPN" 
34ce f5				push af  
34cf 3a e3 34			ld a, (.dmark)  
34d2 32 b4 fe			ld (debug_mark),a  
34d5 3a e4 34			ld a, (.dmark+1)  
34d8 32 b5 fe			ld (debug_mark+1),a  
34db 3a e5 34			ld a, (.dmark+2)  
34de 32 b6 fe			ld (debug_mark+2),a  
34e1 18 03			jr .pastdmark  
34e3 ..			.dmark: db "LPN"  
34e6 f1			.pastdmark: pop af  
34e7			endm  
# End of macro DMARK
34e7					CALLMONITOR 
34e7 cd c6 18			call break_point_state  
34ea				endm  
# End of macro CALLMONITOR
34ea					endif 
34ea					 
34ea				FORTH_LOOP_NEXT 
34ea cd 62 21			call macro_forth_loop_next 
34ed				endm 
# End of macro FORTH_LOOP_NEXT
34ed			 
34ed			 
34ed					if DEBUG_FORTH_WORDS 
34ed eb						ex de,hl 
34ee					endif 
34ee			 
34ee			;	; get DO ptr 
34ee			; 
34ee					if DEBUG_FORTH_WORDS 
34ee						DMARK "LP7" 
34ee f5				push af  
34ef 3a 03 35			ld a, (.dmark)  
34f2 32 b4 fe			ld (debug_mark),a  
34f5 3a 04 35			ld a, (.dmark+1)  
34f8 32 b5 fe			ld (debug_mark+1),a  
34fb 3a 05 35			ld a, (.dmark+2)  
34fe 32 b6 fe			ld (debug_mark+2),a  
3501 18 03			jr .pastdmark  
3503 ..			.dmark: db "LP7"  
3506 f1			.pastdmark: pop af  
3507			endm  
# End of macro DMARK
3507					CALLMONITOR 
3507 cd c6 18			call break_point_state  
350a				endm  
# End of macro CALLMONITOR
350a					endif 
350a				FORTH_RSP_TOS 
350a cd f8 1e			call macro_forth_rsp_tos 
350d				endm 
# End of macro FORTH_RSP_TOS
350d			 
350d					if DEBUG_FORTH_WORDS 
350d						DMARK "LP8" 
350d f5				push af  
350e 3a 22 35			ld a, (.dmark)  
3511 32 b4 fe			ld (debug_mark),a  
3514 3a 23 35			ld a, (.dmark+1)  
3517 32 b5 fe			ld (debug_mark+1),a  
351a 3a 24 35			ld a, (.dmark+2)  
351d 32 b6 fe			ld (debug_mark+2),a  
3520 18 03			jr .pastdmark  
3522 ..			.dmark: db "LP8"  
3525 f1			.pastdmark: pop af  
3526			endm  
# End of macro DMARK
3526					CALLMONITOR 
3526 cd c6 18			call break_point_state  
3529				endm  
# End of macro CALLMONITOR
3529					endif 
3529				;push hl 
3529			 
3529				; not going to DO any more 
3529				; get rid of the RSP pointer as DO will add it back in 
3529				;FORTH_RSP_POP 
3529				;pop hl 
3529			 
3529				;ld hl,(cli_ret_sp) 
3529				;ld e, (hl) 
3529				;inc hl 
3529				;ld d, (hl) 
3529				;ex de,hl 
3529 22 4f f6			ld (os_tok_ptr), hl 
352c					if DEBUG_FORTH_WORDS 
352c						DMARK "LP<" 
352c f5				push af  
352d 3a 41 35			ld a, (.dmark)  
3530 32 b4 fe			ld (debug_mark),a  
3533 3a 42 35			ld a, (.dmark+1)  
3536 32 b5 fe			ld (debug_mark+1),a  
3539 3a 43 35			ld a, (.dmark+2)  
353c 32 b6 fe			ld (debug_mark+2),a  
353f 18 03			jr .pastdmark  
3541 ..			.dmark: db "LP<"  
3544 f1			.pastdmark: pop af  
3545			endm  
# End of macro DMARK
3545					CALLMONITOR 
3545 cd c6 18			call break_point_state  
3548				endm  
# End of macro CALLMONITOR
3548				endif 
3548 c3 78 23			jp exec1 
354b			 
354b					 
354b			 
354b			 
354b					NEXTW 
354b c3 e7 22			jp macro_next 
354e				endm 
# End of macro NEXTW
354e			.I:  
354e			 
354e				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
354e 5e				db WORD_SYS_CORE+74             
354f 79 35			dw .DLOOP            
3551 02				db 1 + 1 
3552 .. 00			db "I",0              
3554				endm 
# End of macro CWHEAD
3554			; | I ( -- ) Current loop counter | DONE 
3554					if DEBUG_FORTH_WORDS_KEY 
3554						DMARK "I.." 
3554 f5				push af  
3555 3a 69 35			ld a, (.dmark)  
3558 32 b4 fe			ld (debug_mark),a  
355b 3a 6a 35			ld a, (.dmark+1)  
355e 32 b5 fe			ld (debug_mark+1),a  
3561 3a 6b 35			ld a, (.dmark+2)  
3564 32 b6 fe			ld (debug_mark+2),a  
3567 18 03			jr .pastdmark  
3569 ..			.dmark: db "I.."  
356c f1			.pastdmark: pop af  
356d			endm  
# End of macro DMARK
356d						CALLMONITOR 
356d cd c6 18			call break_point_state  
3570				endm  
# End of macro CALLMONITOR
3570					endif 
3570			 
3570 2a 73 f6				ld hl,(os_current_i) 
3573 cd 3a 1f				call forth_push_numhl 
3576			 
3576					NEXTW 
3576 c3 e7 22			jp macro_next 
3579				endm 
# End of macro NEXTW
3579			.DLOOP: 
3579				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3579 5f				db WORD_SYS_CORE+75             
357a 5a 36			dw .REPEAT            
357c 06				db 5 + 1 
357d .. 00			db "-LOOP",0              
3583				endm 
# End of macro CWHEAD
3583			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3583				; pop tos as current loop count to hl 
3583					if DEBUG_FORTH_WORDS_KEY 
3583						DMARK "-LP" 
3583 f5				push af  
3584 3a 98 35			ld a, (.dmark)  
3587 32 b4 fe			ld (debug_mark),a  
358a 3a 99 35			ld a, (.dmark+1)  
358d 32 b5 fe			ld (debug_mark+1),a  
3590 3a 9a 35			ld a, (.dmark+2)  
3593 32 b6 fe			ld (debug_mark+2),a  
3596 18 03			jr .pastdmark  
3598 ..			.dmark: db "-LP"  
359b f1			.pastdmark: pop af  
359c			endm  
# End of macro DMARK
359c						CALLMONITOR 
359c cd c6 18			call break_point_state  
359f				endm  
# End of macro CALLMONITOR
359f					endif 
359f			 
359f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
359f			 
359f				FORTH_LOOP_TOS 
359f cd 95 21			call macro_forth_loop_tos 
35a2				endm 
# End of macro FORTH_LOOP_TOS
35a2 e5				push hl 
35a3			 
35a3					if DEBUG_FORTH_WORDS 
35a3						DMARK "-LP" 
35a3 f5				push af  
35a4 3a b8 35			ld a, (.dmark)  
35a7 32 b4 fe			ld (debug_mark),a  
35aa 3a b9 35			ld a, (.dmark+1)  
35ad 32 b5 fe			ld (debug_mark+1),a  
35b0 3a ba 35			ld a, (.dmark+2)  
35b3 32 b6 fe			ld (debug_mark+2),a  
35b6 18 03			jr .pastdmark  
35b8 ..			.dmark: db "-LP"  
35bb f1			.pastdmark: pop af  
35bc			endm  
# End of macro DMARK
35bc						CALLMONITOR 
35bc cd c6 18			call break_point_state  
35bf				endm  
# End of macro CALLMONITOR
35bf					endif 
35bf				; next item on the stack is the limit. get it 
35bf			 
35bf			 
35bf				FORTH_LOOP_POP 
35bf cd 9f 21			call macro_forth_loop_pop 
35c2				endm 
# End of macro FORTH_LOOP_POP
35c2			 
35c2				FORTH_LOOP_TOS 
35c2 cd 95 21			call macro_forth_loop_tos 
35c5				endm 
# End of macro FORTH_LOOP_TOS
35c5			 
35c5 d1				pop de		 ; de = i, hl = limit 
35c6			 
35c6					if DEBUG_FORTH_WORDS 
35c6						DMARK "-L1" 
35c6 f5				push af  
35c7 3a db 35			ld a, (.dmark)  
35ca 32 b4 fe			ld (debug_mark),a  
35cd 3a dc 35			ld a, (.dmark+1)  
35d0 32 b5 fe			ld (debug_mark+1),a  
35d3 3a dd 35			ld a, (.dmark+2)  
35d6 32 b6 fe			ld (debug_mark+2),a  
35d9 18 03			jr .pastdmark  
35db ..			.dmark: db "-L1"  
35de f1			.pastdmark: pop af  
35df			endm  
# End of macro DMARK
35df						CALLMONITOR 
35df cd c6 18			call break_point_state  
35e2				endm  
# End of macro CALLMONITOR
35e2					endif 
35e2			 
35e2				; go back to previous word 
35e2			 
35e2 d5				push de    ; save I for inc later 
35e3			 
35e3			 
35e3				; get limit 
35e3				;  is I at limit? 
35e3			 
35e3			 
35e3					if DEBUG_FORTH_WORDS 
35e3						DMARK "-L1" 
35e3 f5				push af  
35e4 3a f8 35			ld a, (.dmark)  
35e7 32 b4 fe			ld (debug_mark),a  
35ea 3a f9 35			ld a, (.dmark+1)  
35ed 32 b5 fe			ld (debug_mark+1),a  
35f0 3a fa 35			ld a, (.dmark+2)  
35f3 32 b6 fe			ld (debug_mark+2),a  
35f6 18 03			jr .pastdmark  
35f8 ..			.dmark: db "-L1"  
35fb f1			.pastdmark: pop af  
35fc			endm  
# End of macro DMARK
35fc						CALLMONITOR 
35fc cd c6 18			call break_point_state  
35ff				endm  
# End of macro CALLMONITOR
35ff					endif 
35ff			 
35ff ed 52			sbc hl, de 
3601			 
3601			 
3601				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3601			 
3601 20 26				jr nz, .mloopnotdone 
3603			 
3603 e1				pop hl   ; get rid of saved I 
3604				FORTH_LOOP_POP     ; get rid of limit 
3604 cd 9f 21			call macro_forth_loop_pop 
3607				endm 
# End of macro FORTH_LOOP_POP
3607			 
3607				FORTH_RSP_POP     ; get rid of DO ptr 
3607 cd 02 1f			call macro_forth_rsp_pop 
360a				endm 
# End of macro FORTH_RSP_POP
360a			 
360a			if DEBUG_FORTH_WORDS 
360a						DMARK "-L>" 
360a f5				push af  
360b 3a 1f 36			ld a, (.dmark)  
360e 32 b4 fe			ld (debug_mark),a  
3611 3a 20 36			ld a, (.dmark+1)  
3614 32 b5 fe			ld (debug_mark+1),a  
3617 3a 21 36			ld a, (.dmark+2)  
361a 32 b6 fe			ld (debug_mark+2),a  
361d 18 03			jr .pastdmark  
361f ..			.dmark: db "-L>"  
3622 f1			.pastdmark: pop af  
3623			endm  
# End of macro DMARK
3623				CALLMONITOR 
3623 cd c6 18			call break_point_state  
3626				endm  
# End of macro CALLMONITOR
3626			endif 
3626			 
3626					NEXTW 
3626 c3 e7 22			jp macro_next 
3629				endm 
# End of macro NEXTW
3629				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3629			 
3629			.mloopnotdone: 
3629			 
3629 e1				pop hl    ; get I 
362a 2b				dec hl 
362b			 
362b			   	; save new I 
362b			 
362b			 
362b					; set I counter 
362b			 
362b 22 73 f6				ld (os_current_i), hl 
362e			 
362e					 
362e				FORTH_LOOP_NEXT 
362e cd 62 21			call macro_forth_loop_next 
3631				endm 
# End of macro FORTH_LOOP_NEXT
3631			 
3631			 
3631					if DEBUG_FORTH_WORDS 
3631 eb						ex de,hl 
3632					endif 
3632			 
3632			;	; get DO ptr 
3632			; 
3632				FORTH_RSP_TOS 
3632 cd f8 1e			call macro_forth_rsp_tos 
3635				endm 
# End of macro FORTH_RSP_TOS
3635			 
3635				;push hl 
3635			 
3635				; not going to DO any more 
3635				; get rid of the RSP pointer as DO will add it back in 
3635				;FORTH_RSP_POP 
3635				;pop hl 
3635			 
3635			 
3635 22 4f f6			ld (os_tok_ptr), hl 
3638					if DEBUG_FORTH_WORDS 
3638						DMARK "-L<" 
3638 f5				push af  
3639 3a 4d 36			ld a, (.dmark)  
363c 32 b4 fe			ld (debug_mark),a  
363f 3a 4e 36			ld a, (.dmark+1)  
3642 32 b5 fe			ld (debug_mark+1),a  
3645 3a 4f 36			ld a, (.dmark+2)  
3648 32 b6 fe			ld (debug_mark+2),a  
364b 18 03			jr .pastdmark  
364d ..			.dmark: db "-L<"  
3650 f1			.pastdmark: pop af  
3651			endm  
# End of macro DMARK
3651					CALLMONITOR 
3651 cd c6 18			call break_point_state  
3654				endm  
# End of macro CALLMONITOR
3654				endif 
3654 c3 78 23			jp exec1 
3657			 
3657					 
3657			 
3657			 
3657			 
3657				NEXTW 
3657 c3 e7 22			jp macro_next 
365a				endm 
# End of macro NEXTW
365a			 
365a			 
365a			 
365a			 
365a			.REPEAT: 
365a				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
365a 71				db WORD_SYS_CORE+93             
365b ad 36			dw .UNTIL            
365d 06				db 5 + 1 
365e .. 00			db "REPEAT",0              
3665				endm 
# End of macro CWHEAD
3665			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3665			;  push pc to rsp stack past the REPEAT 
3665					if DEBUG_FORTH_WORDS_KEY 
3665						DMARK "REP" 
3665 f5				push af  
3666 3a 7a 36			ld a, (.dmark)  
3669 32 b4 fe			ld (debug_mark),a  
366c 3a 7b 36			ld a, (.dmark+1)  
366f 32 b5 fe			ld (debug_mark+1),a  
3672 3a 7c 36			ld a, (.dmark+2)  
3675 32 b6 fe			ld (debug_mark+2),a  
3678 18 03			jr .pastdmark  
367a ..			.dmark: db "REP"  
367d f1			.pastdmark: pop af  
367e			endm  
# End of macro DMARK
367e						CALLMONITOR 
367e cd c6 18			call break_point_state  
3681				endm  
# End of macro CALLMONITOR
3681					endif 
3681			 
3681 2a 4f f6				ld hl, (os_tok_ptr) 
3684 23					inc hl   ; R 
3685 23					inc hl  ; E 
3686 23					inc hl   ; P 
3687 23					inc hl   ; E 
3688 23					inc hl   ; A 
3689 23					inc hl   ; T 
368a 23					inc hl   ; zero 
368b					FORTH_RSP_NEXT 
368b cd e1 1e			call macro_forth_rsp_next 
368e				endm 
# End of macro FORTH_RSP_NEXT
368e			 
368e			 
368e					if DEBUG_FORTH_WORDS 
368e						DMARK "REP" 
368e f5				push af  
368f 3a a3 36			ld a, (.dmark)  
3692 32 b4 fe			ld (debug_mark),a  
3695 3a a4 36			ld a, (.dmark+1)  
3698 32 b5 fe			ld (debug_mark+1),a  
369b 3a a5 36			ld a, (.dmark+2)  
369e 32 b6 fe			ld (debug_mark+2),a  
36a1 18 03			jr .pastdmark  
36a3 ..			.dmark: db "REP"  
36a6 f1			.pastdmark: pop af  
36a7			endm  
# End of macro DMARK
36a7						;pop bc    ; TODO BUG ?????? what is this for???? 
36a7						CALLMONITOR 
36a7 cd c6 18			call break_point_state  
36aa				endm  
# End of macro CALLMONITOR
36aa					endif 
36aa			 
36aa					NEXTW 
36aa c3 e7 22			jp macro_next 
36ad				endm 
# End of macro NEXTW
36ad			;	       NEXTW 
36ad			 
36ad			.UNTIL: 
36ad				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
36ad 72				db WORD_SYS_CORE+94             
36ae 44 37			dw .ENDFLOW            
36b0 06				db 5 + 1 
36b1 .. 00			db "UNTIL",0              
36b7				endm 
# End of macro CWHEAD
36b7			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36b7			 
36b7				; pop tos as check 
36b7			 
36b7				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36b7			 
36b7				FORTH_DSP_VALUEHL 
36b7 cd 31 21			call macro_dsp_valuehl 
36ba				endm 
# End of macro FORTH_DSP_VALUEHL
36ba			 
36ba					if DEBUG_FORTH_WORDS_KEY 
36ba						DMARK "UNT" 
36ba f5				push af  
36bb 3a cf 36			ld a, (.dmark)  
36be 32 b4 fe			ld (debug_mark),a  
36c1 3a d0 36			ld a, (.dmark+1)  
36c4 32 b5 fe			ld (debug_mark+1),a  
36c7 3a d1 36			ld a, (.dmark+2)  
36ca 32 b6 fe			ld (debug_mark+2),a  
36cd 18 03			jr .pastdmark  
36cf ..			.dmark: db "UNT"  
36d2 f1			.pastdmark: pop af  
36d3			endm  
# End of macro DMARK
36d3						CALLMONITOR 
36d3 cd c6 18			call break_point_state  
36d6				endm  
# End of macro CALLMONITOR
36d6					endif 
36d6			 
36d6			;	push hl 
36d6				FORTH_DSP_POP 
36d6 cd e9 21			call macro_forth_dsp_pop 
36d9				endm 
# End of macro FORTH_DSP_POP
36d9			 
36d9			;	pop hl 
36d9			 
36d9				; test if true 
36d9			 
36d9 cd 72 0f			call ishlzero 
36dc			;	ld a,l 
36dc			;	add h 
36dc			; 
36dc			;	cp 0 
36dc			 
36dc 20 3e			jr nz, .untilnotdone 
36de			 
36de					if DEBUG_FORTH_WORDS 
36de						DMARK "UNf" 
36de f5				push af  
36df 3a f3 36			ld a, (.dmark)  
36e2 32 b4 fe			ld (debug_mark),a  
36e5 3a f4 36			ld a, (.dmark+1)  
36e8 32 b5 fe			ld (debug_mark+1),a  
36eb 3a f5 36			ld a, (.dmark+2)  
36ee 32 b6 fe			ld (debug_mark+2),a  
36f1 18 03			jr .pastdmark  
36f3 ..			.dmark: db "UNf"  
36f6 f1			.pastdmark: pop af  
36f7			endm  
# End of macro DMARK
36f7						CALLMONITOR 
36f7 cd c6 18			call break_point_state  
36fa				endm  
# End of macro CALLMONITOR
36fa					endif 
36fa			 
36fa			 
36fa			 
36fa				FORTH_RSP_POP     ; get rid of DO ptr 
36fa cd 02 1f			call macro_forth_rsp_pop 
36fd				endm 
# End of macro FORTH_RSP_POP
36fd			 
36fd			if DEBUG_FORTH_WORDS 
36fd						DMARK "UN>" 
36fd f5				push af  
36fe 3a 12 37			ld a, (.dmark)  
3701 32 b4 fe			ld (debug_mark),a  
3704 3a 13 37			ld a, (.dmark+1)  
3707 32 b5 fe			ld (debug_mark+1),a  
370a 3a 14 37			ld a, (.dmark+2)  
370d 32 b6 fe			ld (debug_mark+2),a  
3710 18 03			jr .pastdmark  
3712 ..			.dmark: db "UN>"  
3715 f1			.pastdmark: pop af  
3716			endm  
# End of macro DMARK
3716				CALLMONITOR 
3716 cd c6 18			call break_point_state  
3719				endm  
# End of macro CALLMONITOR
3719			endif 
3719			 
3719					NEXTW 
3719 c3 e7 22			jp macro_next 
371c				endm 
# End of macro NEXTW
371c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
371c			 
371c			.untilnotdone: 
371c			 
371c			 
371c			;	; get DO ptr 
371c			; 
371c				FORTH_RSP_TOS 
371c cd f8 1e			call macro_forth_rsp_tos 
371f				endm 
# End of macro FORTH_RSP_TOS
371f			 
371f				;push hl 
371f			 
371f				; not going to DO any more 
371f				; get rid of the RSP pointer as DO will add it back in 
371f				;FORTH_RSP_POP 
371f				;pop hl 
371f			 
371f			 
371f 22 4f f6			ld (os_tok_ptr), hl 
3722					if DEBUG_FORTH_WORDS 
3722						DMARK "UN<" 
3722 f5				push af  
3723 3a 37 37			ld a, (.dmark)  
3726 32 b4 fe			ld (debug_mark),a  
3729 3a 38 37			ld a, (.dmark+1)  
372c 32 b5 fe			ld (debug_mark+1),a  
372f 3a 39 37			ld a, (.dmark+2)  
3732 32 b6 fe			ld (debug_mark+2),a  
3735 18 03			jr .pastdmark  
3737 ..			.dmark: db "UN<"  
373a f1			.pastdmark: pop af  
373b			endm  
# End of macro DMARK
373b					CALLMONITOR 
373b cd c6 18			call break_point_state  
373e				endm  
# End of macro CALLMONITOR
373e				endif 
373e c3 78 23			jp exec1 
3741			 
3741					 
3741			 
3741			 
3741					NEXTW 
3741 c3 e7 22			jp macro_next 
3744				endm 
# End of macro NEXTW
3744			 
3744			 
3744			.ENDFLOW: 
3744			 
3744			; eof 
3744			 
# End of file forth_words_flow.asm
3744			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3744			include "forth_words_logic.asm" 
3744			 
3744			; | ## Logic Words 
3744			 
3744			.NOT: 
3744				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3744 2d				db WORD_SYS_CORE+25             
3745 8c 37			dw .IS            
3747 04				db 3 + 1 
3748 .. 00			db "NOT",0              
374c				endm 
# End of macro CWHEAD
374c			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
374c					if DEBUG_FORTH_WORDS_KEY 
374c						DMARK "NOT" 
374c f5				push af  
374d 3a 61 37			ld a, (.dmark)  
3750 32 b4 fe			ld (debug_mark),a  
3753 3a 62 37			ld a, (.dmark+1)  
3756 32 b5 fe			ld (debug_mark+1),a  
3759 3a 63 37			ld a, (.dmark+2)  
375c 32 b6 fe			ld (debug_mark+2),a  
375f 18 03			jr .pastdmark  
3761 ..			.dmark: db "NOT"  
3764 f1			.pastdmark: pop af  
3765			endm  
# End of macro DMARK
3765						CALLMONITOR 
3765 cd c6 18			call break_point_state  
3768				endm  
# End of macro CALLMONITOR
3768					endif 
3768					FORTH_DSP 
3768 cd f7 20			call macro_forth_dsp 
376b				endm 
# End of macro FORTH_DSP
376b 7e					ld a,(hl)	; get type of value on TOS 
376c fe 02				cp DS_TYPE_INUM  
376e 28 03				jr z, .noti 
3770					NEXTW 
3770 c3 e7 22			jp macro_next 
3773				endm 
# End of macro NEXTW
3773			.noti:          FORTH_DSP_VALUEHL 
3773 cd 31 21			call macro_dsp_valuehl 
3776				endm 
# End of macro FORTH_DSP_VALUEHL
3776			;		push hl 
3776					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3776 cd e9 21			call macro_forth_dsp_pop 
3779				endm 
# End of macro FORTH_DSP_POP
3779			;		pop hl 
3779 3e 00				ld a,0 
377b bd					cp l 
377c 28 04				jr z, .not2t 
377e 2e 00				ld l, 0 
3780 18 02				jr .notip 
3782			 
3782 2e ff		.not2t:		ld l, 255 
3784			 
3784 26 00		.notip:		ld h, 0	 
3786			 
3786 cd 3a 1f				call forth_push_numhl 
3789					NEXTW 
3789 c3 e7 22			jp macro_next 
378c				endm 
# End of macro NEXTW
378c			 
378c			.IS: 
378c				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
378c 2d				db WORD_SYS_CORE+25             
378d b2 37			dw .LZERO            
378f 03				db 2 + 1 
3790 .. 00			db "IS",0              
3793				endm 
# End of macro CWHEAD
3793			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3793					if DEBUG_FORTH_WORDS_KEY 
3793						DMARK "IS." 
3793 f5				push af  
3794 3a a8 37			ld a, (.dmark)  
3797 32 b4 fe			ld (debug_mark),a  
379a 3a a9 37			ld a, (.dmark+1)  
379d 32 b5 fe			ld (debug_mark+1),a  
37a0 3a aa 37			ld a, (.dmark+2)  
37a3 32 b6 fe			ld (debug_mark+2),a  
37a6 18 03			jr .pastdmark  
37a8 ..			.dmark: db "IS."  
37ab f1			.pastdmark: pop af  
37ac			endm  
# End of macro DMARK
37ac						CALLMONITOR 
37ac cd c6 18			call break_point_state  
37af				endm  
# End of macro CALLMONITOR
37af					endif 
37af					NEXTW 
37af c3 e7 22			jp macro_next 
37b2				endm 
# End of macro NEXTW
37b2			.LZERO: 
37b2				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37b2 2d				db WORD_SYS_CORE+25             
37b3 bc 37			dw .TZERO            
37b5 03				db 2 + 1 
37b6 .. 00			db "0<",0              
37b9				endm 
# End of macro CWHEAD
37b9			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37b9					NEXTW 
37b9 c3 e7 22			jp macro_next 
37bc				endm 
# End of macro NEXTW
37bc			.TZERO: 
37bc				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37bc 2e				db WORD_SYS_CORE+26             
37bd 03 38			dw .LESS            
37bf 03				db 2 + 1 
37c0 .. 00			db "0=",0              
37c3				endm 
# End of macro CWHEAD
37c3			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
37c3				; TODO add floating point number detection 
37c3					;v5 FORTH_DSP_VALUE 
37c3					if DEBUG_FORTH_WORDS_KEY 
37c3						DMARK "0=." 
37c3 f5				push af  
37c4 3a d8 37			ld a, (.dmark)  
37c7 32 b4 fe			ld (debug_mark),a  
37ca 3a d9 37			ld a, (.dmark+1)  
37cd 32 b5 fe			ld (debug_mark+1),a  
37d0 3a da 37			ld a, (.dmark+2)  
37d3 32 b6 fe			ld (debug_mark+2),a  
37d6 18 03			jr .pastdmark  
37d8 ..			.dmark: db "0=."  
37db f1			.pastdmark: pop af  
37dc			endm  
# End of macro DMARK
37dc						CALLMONITOR 
37dc cd c6 18			call break_point_state  
37df				endm  
# End of macro CALLMONITOR
37df					endif 
37df					FORTH_DSP 
37df cd f7 20			call macro_forth_dsp 
37e2				endm 
# End of macro FORTH_DSP
37e2 7e					ld a,(hl)	; get type of value on TOS 
37e3 fe 02				cp DS_TYPE_INUM  
37e5 28 00				jr z, .tz_inum 
37e7			 
37e7				if FORTH_ENABLE_FLOATMATH 
37e7					jr .tz_done 
37e7			 
37e7				endif 
37e7					 
37e7			 
37e7			.tz_inum: 
37e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e7 cd 31 21			call macro_dsp_valuehl 
37ea				endm 
# End of macro FORTH_DSP_VALUEHL
37ea			 
37ea			;		push hl 
37ea			 
37ea					; destroy value TOS 
37ea			 
37ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ea cd e9 21			call macro_forth_dsp_pop 
37ed				endm 
# End of macro FORTH_DSP_POP
37ed			 
37ed			;		pop hl 
37ed			 
37ed 3e 00				ld a,0 
37ef			 
37ef bd					cp l 
37f0 20 08				jr nz, .tz_notzero 
37f2			 
37f2 bc					cp h 
37f3			 
37f3 20 05				jr nz, .tz_notzero 
37f5			 
37f5			 
37f5 21 01 00				ld hl, FORTH_TRUE 
37f8 18 03				jr .tz_done 
37fa			 
37fa 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
37fd			 
37fd					; push value back onto stack for another op etc 
37fd			 
37fd			.tz_done: 
37fd cd 3a 1f				call forth_push_numhl 
3800			 
3800					NEXTW 
3800 c3 e7 22			jp macro_next 
3803				endm 
# End of macro NEXTW
3803			.LESS: 
3803				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3803 2f				db WORD_SYS_CORE+27             
3804 6c 38			dw .GT            
3806 02				db 1 + 1 
3807 .. 00			db "<",0              
3809				endm 
# End of macro CWHEAD
3809			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3809				; TODO add floating point number detection 
3809					if DEBUG_FORTH_WORDS_KEY 
3809						DMARK "LES" 
3809 f5				push af  
380a 3a 1e 38			ld a, (.dmark)  
380d 32 b4 fe			ld (debug_mark),a  
3810 3a 1f 38			ld a, (.dmark+1)  
3813 32 b5 fe			ld (debug_mark+1),a  
3816 3a 20 38			ld a, (.dmark+2)  
3819 32 b6 fe			ld (debug_mark+2),a  
381c 18 03			jr .pastdmark  
381e ..			.dmark: db "LES"  
3821 f1			.pastdmark: pop af  
3822			endm  
# End of macro DMARK
3822						CALLMONITOR 
3822 cd c6 18			call break_point_state  
3825				endm  
# End of macro CALLMONITOR
3825					endif 
3825					FORTH_DSP 
3825 cd f7 20			call macro_forth_dsp 
3828				endm 
# End of macro FORTH_DSP
3828					;v5 FORTH_DSP_VALUE 
3828 7e					ld a,(hl)	; get type of value on TOS 
3829 fe 02				cp DS_TYPE_INUM  
382b 28 00				jr z, .less_inum 
382d			 
382d				if FORTH_ENABLE_FLOATMATH 
382d					jr .less_done 
382d			 
382d				endif 
382d					 
382d			 
382d			.less_inum: 
382d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
382d cd 31 21			call macro_dsp_valuehl 
3830				endm 
# End of macro FORTH_DSP_VALUEHL
3830			 
3830 e5					push hl  ; u2 
3831			 
3831					; destroy value TOS 
3831			 
3831					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3831 cd e9 21			call macro_forth_dsp_pop 
3834				endm 
# End of macro FORTH_DSP_POP
3834			 
3834			 
3834					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3834 cd 31 21			call macro_dsp_valuehl 
3837				endm 
# End of macro FORTH_DSP_VALUEHL
3837			 
3837 e5					push hl    ; u1 
3838			 
3838					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3838 cd e9 21			call macro_forth_dsp_pop 
383b				endm 
# End of macro FORTH_DSP_POP
383b			 
383b			 
383b b7			 or a      ;clear carry flag 
383c 01 00 00		 ld bc, FORTH_FALSE 
383f e1			  pop hl    ; u1 
3840 d1			  pop de    ; u2 
3841 ed 52		  sbc hl,de 
3843 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3845			 
3845 01 01 00		 ld bc, FORTH_TRUE 
3848			.lscont:  
3848 c5					push bc 
3849 e1					pop hl 
384a			 
384a					if DEBUG_FORTH_WORDS 
384a						DMARK "LT1" 
384a f5				push af  
384b 3a 5f 38			ld a, (.dmark)  
384e 32 b4 fe			ld (debug_mark),a  
3851 3a 60 38			ld a, (.dmark+1)  
3854 32 b5 fe			ld (debug_mark+1),a  
3857 3a 61 38			ld a, (.dmark+2)  
385a 32 b6 fe			ld (debug_mark+2),a  
385d 18 03			jr .pastdmark  
385f ..			.dmark: db "LT1"  
3862 f1			.pastdmark: pop af  
3863			endm  
# End of macro DMARK
3863						CALLMONITOR 
3863 cd c6 18			call break_point_state  
3866				endm  
# End of macro CALLMONITOR
3866					endif 
3866 cd 3a 1f				call forth_push_numhl 
3869			 
3869					NEXTW 
3869 c3 e7 22			jp macro_next 
386c				endm 
# End of macro NEXTW
386c			.GT: 
386c				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
386c 30				db WORD_SYS_CORE+28             
386d d5 38			dw .EQUAL            
386f 02				db 1 + 1 
3870 .. 00			db ">",0              
3872				endm 
# End of macro CWHEAD
3872			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3872				; TODO add floating point number detection 
3872					if DEBUG_FORTH_WORDS_KEY 
3872						DMARK "GRT" 
3872 f5				push af  
3873 3a 87 38			ld a, (.dmark)  
3876 32 b4 fe			ld (debug_mark),a  
3879 3a 88 38			ld a, (.dmark+1)  
387c 32 b5 fe			ld (debug_mark+1),a  
387f 3a 89 38			ld a, (.dmark+2)  
3882 32 b6 fe			ld (debug_mark+2),a  
3885 18 03			jr .pastdmark  
3887 ..			.dmark: db "GRT"  
388a f1			.pastdmark: pop af  
388b			endm  
# End of macro DMARK
388b						CALLMONITOR 
388b cd c6 18			call break_point_state  
388e				endm  
# End of macro CALLMONITOR
388e					endif 
388e					FORTH_DSP 
388e cd f7 20			call macro_forth_dsp 
3891				endm 
# End of macro FORTH_DSP
3891					;FORTH_DSP_VALUE 
3891 7e					ld a,(hl)	; get type of value on TOS 
3892 fe 02				cp DS_TYPE_INUM  
3894 28 00				jr z, .gt_inum 
3896			 
3896				if FORTH_ENABLE_FLOATMATH 
3896					jr .gt_done 
3896			 
3896				endif 
3896					 
3896			 
3896			.gt_inum: 
3896					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3896 cd 31 21			call macro_dsp_valuehl 
3899				endm 
# End of macro FORTH_DSP_VALUEHL
3899			 
3899 e5					push hl  ; u2 
389a			 
389a					; destroy value TOS 
389a			 
389a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
389a cd e9 21			call macro_forth_dsp_pop 
389d				endm 
# End of macro FORTH_DSP_POP
389d			 
389d			 
389d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
389d cd 31 21			call macro_dsp_valuehl 
38a0				endm 
# End of macro FORTH_DSP_VALUEHL
38a0			 
38a0 e5					push hl    ; u1 
38a1			 
38a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38a1 cd e9 21			call macro_forth_dsp_pop 
38a4				endm 
# End of macro FORTH_DSP_POP
38a4			 
38a4			 
38a4 b7			 or a      ;clear carry flag 
38a5 01 00 00		 ld bc, FORTH_FALSE 
38a8 e1			  pop hl    ; u1 
38a9 d1			  pop de    ; u2 
38aa ed 52		  sbc hl,de 
38ac 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
38ae			 
38ae 01 01 00		 ld bc, FORTH_TRUE 
38b1			.gtcont:  
38b1 c5					push bc 
38b2 e1					pop hl 
38b3			 
38b3					if DEBUG_FORTH_WORDS 
38b3						DMARK "GT1" 
38b3 f5				push af  
38b4 3a c8 38			ld a, (.dmark)  
38b7 32 b4 fe			ld (debug_mark),a  
38ba 3a c9 38			ld a, (.dmark+1)  
38bd 32 b5 fe			ld (debug_mark+1),a  
38c0 3a ca 38			ld a, (.dmark+2)  
38c3 32 b6 fe			ld (debug_mark+2),a  
38c6 18 03			jr .pastdmark  
38c8 ..			.dmark: db "GT1"  
38cb f1			.pastdmark: pop af  
38cc			endm  
# End of macro DMARK
38cc						CALLMONITOR 
38cc cd c6 18			call break_point_state  
38cf				endm  
# End of macro CALLMONITOR
38cf					endif 
38cf cd 3a 1f				call forth_push_numhl 
38d2			 
38d2					NEXTW 
38d2 c3 e7 22			jp macro_next 
38d5				endm 
# End of macro NEXTW
38d5			.EQUAL: 
38d5				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
38d5 31				db WORD_SYS_CORE+29             
38d6 40 39			dw .ENDLOGIC            
38d8 02				db 1 + 1 
38d9 .. 00			db "=",0              
38db				endm 
# End of macro CWHEAD
38db			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
38db				; TODO add floating point number detection 
38db					if DEBUG_FORTH_WORDS_KEY 
38db						DMARK "EQ." 
38db f5				push af  
38dc 3a f0 38			ld a, (.dmark)  
38df 32 b4 fe			ld (debug_mark),a  
38e2 3a f1 38			ld a, (.dmark+1)  
38e5 32 b5 fe			ld (debug_mark+1),a  
38e8 3a f2 38			ld a, (.dmark+2)  
38eb 32 b6 fe			ld (debug_mark+2),a  
38ee 18 03			jr .pastdmark  
38f0 ..			.dmark: db "EQ."  
38f3 f1			.pastdmark: pop af  
38f4			endm  
# End of macro DMARK
38f4						CALLMONITOR 
38f4 cd c6 18			call break_point_state  
38f7				endm  
# End of macro CALLMONITOR
38f7					endif 
38f7					FORTH_DSP 
38f7 cd f7 20			call macro_forth_dsp 
38fa				endm 
# End of macro FORTH_DSP
38fa					;v5 FORTH_DSP_VALUE 
38fa 7e					ld a,(hl)	; get type of value on TOS 
38fb fe 02				cp DS_TYPE_INUM  
38fd 28 00				jr z, .eq_inum 
38ff			 
38ff				if FORTH_ENABLE_FLOATMATH 
38ff					jr .eq_done 
38ff			 
38ff				endif 
38ff					 
38ff			 
38ff			.eq_inum: 
38ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ff cd 31 21			call macro_dsp_valuehl 
3902				endm 
# End of macro FORTH_DSP_VALUEHL
3902			 
3902 e5					push hl 
3903			 
3903					; destroy value TOS 
3903			 
3903					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3903 cd e9 21			call macro_forth_dsp_pop 
3906				endm 
# End of macro FORTH_DSP_POP
3906			 
3906			 
3906					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3906 cd 31 21			call macro_dsp_valuehl 
3909				endm 
# End of macro FORTH_DSP_VALUEHL
3909			 
3909					; one value on hl get other one back 
3909			 
3909 e5					push hl 
390a			 
390a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
390a cd e9 21			call macro_forth_dsp_pop 
390d				endm 
# End of macro FORTH_DSP_POP
390d			 
390d 0e 00				ld c, FORTH_FALSE 
390f			 
390f e1					pop hl 
3910 d1					pop de 
3911			 
3911 7b					ld a, e 
3912 bd					cp l 
3913			 
3913 20 06				jr nz, .eq_done 
3915			 
3915 7a					ld a, d 
3916 bc					cp h 
3917			 
3917 20 02				jr nz, .eq_done 
3919			 
3919 0e 01				ld c, FORTH_TRUE 
391b					 
391b			 
391b			 
391b			.eq_done: 
391b			 
391b					; TODO push value back onto stack for another op etc 
391b			 
391b 26 00				ld h, 0 
391d 69					ld l, c 
391e					if DEBUG_FORTH_WORDS 
391e						DMARK "EQ1" 
391e f5				push af  
391f 3a 33 39			ld a, (.dmark)  
3922 32 b4 fe			ld (debug_mark),a  
3925 3a 34 39			ld a, (.dmark+1)  
3928 32 b5 fe			ld (debug_mark+1),a  
392b 3a 35 39			ld a, (.dmark+2)  
392e 32 b6 fe			ld (debug_mark+2),a  
3931 18 03			jr .pastdmark  
3933 ..			.dmark: db "EQ1"  
3936 f1			.pastdmark: pop af  
3937			endm  
# End of macro DMARK
3937						CALLMONITOR 
3937 cd c6 18			call break_point_state  
393a				endm  
# End of macro CALLMONITOR
393a					endif 
393a cd 3a 1f				call forth_push_numhl 
393d			 
393d					NEXTW 
393d c3 e7 22			jp macro_next 
3940				endm 
# End of macro NEXTW
3940			 
3940			 
3940			.ENDLOGIC: 
3940			; eof 
3940			 
3940			 
# End of file forth_words_logic.asm
3940			include "forth_words_maths.asm" 
3940			 
3940			; | ## Maths Words 
3940			 
3940			.PLUS:	 
3940				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3940 15				db WORD_SYS_CORE+1             
3941 9e 39			dw .NEG            
3943 02				db 1 + 1 
3944 .. 00			db "+",0              
3946				endm 
# End of macro CWHEAD
3946			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3946					if DEBUG_FORTH_WORDS_KEY 
3946						DMARK "PLU" 
3946 f5				push af  
3947 3a 5b 39			ld a, (.dmark)  
394a 32 b4 fe			ld (debug_mark),a  
394d 3a 5c 39			ld a, (.dmark+1)  
3950 32 b5 fe			ld (debug_mark+1),a  
3953 3a 5d 39			ld a, (.dmark+2)  
3956 32 b6 fe			ld (debug_mark+2),a  
3959 18 03			jr .pastdmark  
395b ..			.dmark: db "PLU"  
395e f1			.pastdmark: pop af  
395f			endm  
# End of macro DMARK
395f						CALLMONITOR 
395f cd c6 18			call break_point_state  
3962				endm  
# End of macro CALLMONITOR
3962					endif 
3962					; add top two values and push back result 
3962			 
3962					;for v5 FORTH_DSP_VALUE 
3962					FORTH_DSP 
3962 cd f7 20			call macro_forth_dsp 
3965				endm 
# End of macro FORTH_DSP
3965 7e					ld a,(hl)	; get type of value on TOS 
3966 fe 02				cp DS_TYPE_INUM  
3968 28 03				jr z, .dot_inum 
396a			 
396a					NEXTW 
396a c3 e7 22			jp macro_next 
396d				endm 
# End of macro NEXTW
396d			 
396d			; float maths 
396d			 
396d				if FORTH_ENABLE_FLOATMATH 
396d						inc hl      ; now at start of numeric as string 
396d			 
396d					if DEBUG_FORTH_MATHS 
396d						DMARK "ADD" 
396d				CALLMONITOR 
396d					endif 
396d			 
396d					;ld ix, hl 
396d					call CON 
396d			 
396d			 
396d					push hl 
396d					 
396d					 
396d			 
396d						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
396d			 
396d					; get next number 
396d			 
396d						FORTH_DSP_VALUE 
396d			 
396d						inc hl      ; now at start of numeric as string 
396d			 
396d					;ld ix, hl 
396d					call CON 
396d			 
396d					push hl 
396d			 
396d			 
396d						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
396d			 
396d						; TODO do add 
396d			 
396d						call IADD 
396d			 
396d						; TODO get result back as ascii 
396d			 
396d						; TODO push result  
396d			 
396d			 
396d			 
396d						jr .dot_done 
396d				endif 
396d			 
396d			.dot_inum: 
396d			 
396d			 
396d					if DEBUG_FORTH_DOT 
396d						DMARK "+IT" 
396d f5				push af  
396e 3a 82 39			ld a, (.dmark)  
3971 32 b4 fe			ld (debug_mark),a  
3974 3a 83 39			ld a, (.dmark+1)  
3977 32 b5 fe			ld (debug_mark+1),a  
397a 3a 84 39			ld a, (.dmark+2)  
397d 32 b6 fe			ld (debug_mark+2),a  
3980 18 03			jr .pastdmark  
3982 ..			.dmark: db "+IT"  
3985 f1			.pastdmark: pop af  
3986			endm  
# End of macro DMARK
3986				CALLMONITOR 
3986 cd c6 18			call break_point_state  
3989				endm  
# End of macro CALLMONITOR
3989					endif 
3989			 
3989					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3989 cd 31 21			call macro_dsp_valuehl 
398c				endm 
# End of macro FORTH_DSP_VALUEHL
398c			 
398c				; TODO add floating point number detection 
398c			 
398c e5					push hl 
398d			 
398d					; destroy value TOS 
398d			 
398d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
398d cd e9 21			call macro_forth_dsp_pop 
3990				endm 
# End of macro FORTH_DSP_POP
3990			 
3990			 
3990					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3990 cd 31 21			call macro_dsp_valuehl 
3993				endm 
# End of macro FORTH_DSP_VALUEHL
3993			 
3993					; one value on hl get other one back 
3993			 
3993 d1					pop de 
3994			 
3994					; do the add 
3994			 
3994 19					add hl,de 
3995			 
3995					; save it 
3995			 
3995			;		push hl	 
3995			 
3995					; 
3995			 
3995					; destroy value TOS 
3995			 
3995					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3995 cd e9 21			call macro_forth_dsp_pop 
3998				endm 
# End of macro FORTH_DSP_POP
3998			 
3998					; TODO push value back onto stack for another op etc 
3998			 
3998			;		pop hl 
3998			 
3998			.dot_done: 
3998 cd 3a 1f				call forth_push_numhl 
399b			 
399b					NEXTW 
399b c3 e7 22			jp macro_next 
399e				endm 
# End of macro NEXTW
399e			.NEG: 
399e			 
399e				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
399e 17				db WORD_SYS_CORE+3             
399f e1 39			dw .DIV            
39a1 02				db 1 + 1 
39a2 .. 00			db "-",0              
39a4				endm 
# End of macro CWHEAD
39a4			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
39a4					if DEBUG_FORTH_WORDS_KEY 
39a4						DMARK "SUB" 
39a4 f5				push af  
39a5 3a b9 39			ld a, (.dmark)  
39a8 32 b4 fe			ld (debug_mark),a  
39ab 3a ba 39			ld a, (.dmark+1)  
39ae 32 b5 fe			ld (debug_mark+1),a  
39b1 3a bb 39			ld a, (.dmark+2)  
39b4 32 b6 fe			ld (debug_mark+2),a  
39b7 18 03			jr .pastdmark  
39b9 ..			.dmark: db "SUB"  
39bc f1			.pastdmark: pop af  
39bd			endm  
# End of macro DMARK
39bd						CALLMONITOR 
39bd cd c6 18			call break_point_state  
39c0				endm  
# End of macro CALLMONITOR
39c0					endif 
39c0			 
39c0			 
39c0				; TODO add floating point number detection 
39c0					; v5 FORTH_DSP_VALUE 
39c0					FORTH_DSP 
39c0 cd f7 20			call macro_forth_dsp 
39c3				endm 
# End of macro FORTH_DSP
39c3 7e					ld a,(hl)	; get type of value on TOS 
39c4 fe 02				cp DS_TYPE_INUM  
39c6 28 03				jr z, .neg_inum 
39c8			 
39c8					NEXTW 
39c8 c3 e7 22			jp macro_next 
39cb				endm 
# End of macro NEXTW
39cb			 
39cb			; float maths 
39cb			 
39cb				if FORTH_ENABLE_FLOATMATH 
39cb					jr .neg_done 
39cb			 
39cb				endif 
39cb					 
39cb			 
39cb			.neg_inum: 
39cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39cb cd 31 21			call macro_dsp_valuehl 
39ce				endm 
# End of macro FORTH_DSP_VALUEHL
39ce			 
39ce e5					push hl 
39cf			 
39cf					; destroy value TOS 
39cf			 
39cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39cf cd e9 21			call macro_forth_dsp_pop 
39d2				endm 
# End of macro FORTH_DSP_POP
39d2			 
39d2			 
39d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39d2 cd 31 21			call macro_dsp_valuehl 
39d5				endm 
# End of macro FORTH_DSP_VALUEHL
39d5			 
39d5					; one value on hl get other one back 
39d5			 
39d5 d1					pop de 
39d6			 
39d6					; do the sub 
39d6			;		ex de, hl 
39d6			 
39d6 ed 52				sbc hl,de 
39d8			 
39d8					; save it 
39d8			 
39d8			;		push hl	 
39d8			 
39d8					; 
39d8			 
39d8					; destroy value TOS 
39d8			 
39d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39d8 cd e9 21			call macro_forth_dsp_pop 
39db				endm 
# End of macro FORTH_DSP_POP
39db			 
39db					; TODO push value back onto stack for another op etc 
39db			 
39db			;		pop hl 
39db			 
39db cd 3a 1f				call forth_push_numhl 
39de			.neg_done: 
39de			 
39de					NEXTW 
39de c3 e7 22			jp macro_next 
39e1				endm 
# End of macro NEXTW
39e1			.DIV: 
39e1				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
39e1 18				db WORD_SYS_CORE+4             
39e2 2e 3a			dw .MUL            
39e4 02				db 1 + 1 
39e5 .. 00			db "/",0              
39e7				endm 
# End of macro CWHEAD
39e7			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
39e7					if DEBUG_FORTH_WORDS_KEY 
39e7						DMARK "DIV" 
39e7 f5				push af  
39e8 3a fc 39			ld a, (.dmark)  
39eb 32 b4 fe			ld (debug_mark),a  
39ee 3a fd 39			ld a, (.dmark+1)  
39f1 32 b5 fe			ld (debug_mark+1),a  
39f4 3a fe 39			ld a, (.dmark+2)  
39f7 32 b6 fe			ld (debug_mark+2),a  
39fa 18 03			jr .pastdmark  
39fc ..			.dmark: db "DIV"  
39ff f1			.pastdmark: pop af  
3a00			endm  
# End of macro DMARK
3a00						CALLMONITOR 
3a00 cd c6 18			call break_point_state  
3a03				endm  
# End of macro CALLMONITOR
3a03					endif 
3a03				; TODO add floating point number detection 
3a03					; v5 FORTH_DSP_VALUE 
3a03					FORTH_DSP 
3a03 cd f7 20			call macro_forth_dsp 
3a06				endm 
# End of macro FORTH_DSP
3a06 7e					ld a,(hl)	; get type of value on TOS 
3a07 fe 02				cp DS_TYPE_INUM  
3a09 28 03				jr z, .div_inum 
3a0b			 
3a0b				if FORTH_ENABLE_FLOATMATH 
3a0b					jr .div_done 
3a0b			 
3a0b				endif 
3a0b					NEXTW 
3a0b c3 e7 22			jp macro_next 
3a0e				endm 
# End of macro NEXTW
3a0e			.div_inum: 
3a0e			 
3a0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a0e cd 31 21			call macro_dsp_valuehl 
3a11				endm 
# End of macro FORTH_DSP_VALUEHL
3a11			 
3a11 e5					push hl    ; to go to bc 
3a12			 
3a12					; destroy value TOS 
3a12			 
3a12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a12 cd e9 21			call macro_forth_dsp_pop 
3a15				endm 
# End of macro FORTH_DSP_POP
3a15			 
3a15			 
3a15					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a15 cd 31 21			call macro_dsp_valuehl 
3a18				endm 
# End of macro FORTH_DSP_VALUEHL
3a18			 
3a18					; hl to go to de 
3a18			 
3a18 e5					push hl 
3a19			 
3a19 c1					pop bc 
3a1a d1					pop de		 
3a1b			 
3a1b			 
3a1b					if DEBUG_FORTH_MATHS 
3a1b						DMARK "DIV" 
3a1b				CALLMONITOR 
3a1b					endif 
3a1b					; one value on hl but move to a get other one back 
3a1b			 
3a1b			        
3a1b cd a6 0e			call Div16 
3a1e			 
3a1e			;	push af	 
3a1e e5				push hl 
3a1f c5				push bc 
3a20			 
3a20					if DEBUG_FORTH_MATHS 
3a20						DMARK "DI1" 
3a20				CALLMONITOR 
3a20					endif 
3a20			 
3a20					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a20 cd e9 21			call macro_forth_dsp_pop 
3a23				endm 
# End of macro FORTH_DSP_POP
3a23			 
3a23			 
3a23			 
3a23 e1					pop hl    ; result 
3a24			 
3a24 cd 3a 1f				call forth_push_numhl 
3a27			 
3a27 e1					pop hl    ; reminder 
3a28			;		ld h,0 
3a28			;		ld l,d 
3a28			 
3a28 cd 3a 1f				call forth_push_numhl 
3a2b			.div_done: 
3a2b					NEXTW 
3a2b c3 e7 22			jp macro_next 
3a2e				endm 
# End of macro NEXTW
3a2e			.MUL: 
3a2e				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a2e 19				db WORD_SYS_CORE+5             
3a2f 73 3a			dw .MIN            
3a31 02				db 1 + 1 
3a32 .. 00			db "*",0              
3a34				endm 
# End of macro CWHEAD
3a34			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a34				; TODO add floating point number detection 
3a34					if DEBUG_FORTH_WORDS_KEY 
3a34						DMARK "MUL" 
3a34 f5				push af  
3a35 3a 49 3a			ld a, (.dmark)  
3a38 32 b4 fe			ld (debug_mark),a  
3a3b 3a 4a 3a			ld a, (.dmark+1)  
3a3e 32 b5 fe			ld (debug_mark+1),a  
3a41 3a 4b 3a			ld a, (.dmark+2)  
3a44 32 b6 fe			ld (debug_mark+2),a  
3a47 18 03			jr .pastdmark  
3a49 ..			.dmark: db "MUL"  
3a4c f1			.pastdmark: pop af  
3a4d			endm  
# End of macro DMARK
3a4d						CALLMONITOR 
3a4d cd c6 18			call break_point_state  
3a50				endm  
# End of macro CALLMONITOR
3a50					endif 
3a50					FORTH_DSP 
3a50 cd f7 20			call macro_forth_dsp 
3a53				endm 
# End of macro FORTH_DSP
3a53					; v5 FORTH_DSP_VALUE 
3a53 7e					ld a,(hl)	; get type of value on TOS 
3a54 fe 02				cp DS_TYPE_INUM  
3a56 28 03				jr z, .mul_inum 
3a58			 
3a58				if FORTH_ENABLE_FLOATMATH 
3a58					jr .mul_done 
3a58			 
3a58				endif 
3a58			 
3a58					NEXTW 
3a58 c3 e7 22			jp macro_next 
3a5b				endm 
# End of macro NEXTW
3a5b			.mul_inum:	 
3a5b			 
3a5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a5b cd 31 21			call macro_dsp_valuehl 
3a5e				endm 
# End of macro FORTH_DSP_VALUEHL
3a5e			 
3a5e e5					push hl 
3a5f			 
3a5f					; destroy value TOS 
3a5f			 
3a5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5f cd e9 21			call macro_forth_dsp_pop 
3a62				endm 
# End of macro FORTH_DSP_POP
3a62			 
3a62			 
3a62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a62 cd 31 21			call macro_dsp_valuehl 
3a65				endm 
# End of macro FORTH_DSP_VALUEHL
3a65			 
3a65					; one value on hl but move to a get other one back 
3a65			 
3a65 7d					ld a, l 
3a66			 
3a66 d1					pop de 
3a67			 
3a67					; do the mull 
3a67			;		ex de, hl 
3a67			 
3a67 cd cc 0e				call Mult16 
3a6a					; save it 
3a6a			 
3a6a			;		push hl	 
3a6a			 
3a6a					; 
3a6a			 
3a6a					; destroy value TOS 
3a6a			 
3a6a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a6a cd e9 21			call macro_forth_dsp_pop 
3a6d				endm 
# End of macro FORTH_DSP_POP
3a6d			 
3a6d					; TODO push value back onto stack for another op etc 
3a6d			 
3a6d			;		pop hl 
3a6d			 
3a6d cd 3a 1f				call forth_push_numhl 
3a70			 
3a70			.mul_done: 
3a70					NEXTW 
3a70 c3 e7 22			jp macro_next 
3a73				endm 
# End of macro NEXTW
3a73			 
3a73			 
3a73			 
3a73			 
3a73			.MIN: 
3a73				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3a73 49				db WORD_SYS_CORE+53             
3a74 f4 3a			dw .MAX            
3a76 04				db 3 + 1 
3a77 .. 00			db "MIN",0              
3a7b				endm 
# End of macro CWHEAD
3a7b			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3a7b					if DEBUG_FORTH_WORDS_KEY 
3a7b						DMARK "MIN" 
3a7b f5				push af  
3a7c 3a 90 3a			ld a, (.dmark)  
3a7f 32 b4 fe			ld (debug_mark),a  
3a82 3a 91 3a			ld a, (.dmark+1)  
3a85 32 b5 fe			ld (debug_mark+1),a  
3a88 3a 92 3a			ld a, (.dmark+2)  
3a8b 32 b6 fe			ld (debug_mark+2),a  
3a8e 18 03			jr .pastdmark  
3a90 ..			.dmark: db "MIN"  
3a93 f1			.pastdmark: pop af  
3a94			endm  
# End of macro DMARK
3a94						CALLMONITOR 
3a94 cd c6 18			call break_point_state  
3a97				endm  
# End of macro CALLMONITOR
3a97					endif 
3a97					; get u2 
3a97			 
3a97					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a97 cd 31 21			call macro_dsp_valuehl 
3a9a				endm 
# End of macro FORTH_DSP_VALUEHL
3a9a			 
3a9a e5					push hl   ; u2 
3a9b			 
3a9b					; destroy value TOS 
3a9b			 
3a9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9b cd e9 21			call macro_forth_dsp_pop 
3a9e				endm 
# End of macro FORTH_DSP_POP
3a9e			 
3a9e					; get u1 
3a9e			 
3a9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a9e cd 31 21			call macro_dsp_valuehl 
3aa1				endm 
# End of macro FORTH_DSP_VALUEHL
3aa1			 
3aa1 e5					push hl  ; u1 
3aa2			 
3aa2					; destroy value TOS 
3aa2			 
3aa2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa2 cd e9 21			call macro_forth_dsp_pop 
3aa5				endm 
# End of macro FORTH_DSP_POP
3aa5			 
3aa5 b7			 or a      ;clear carry flag 
3aa6 e1			  pop hl    ; u1 
3aa7 d1			  pop de    ; u2 
3aa8 e5				push hl   ; saved in case hl is lowest 
3aa9 ed 52		  sbc hl,de 
3aab 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3aad			 
3aad e1				pop hl 
3aae					if DEBUG_FORTH_WORDS 
3aae						DMARK "MIN" 
3aae f5				push af  
3aaf 3a c3 3a			ld a, (.dmark)  
3ab2 32 b4 fe			ld (debug_mark),a  
3ab5 3a c4 3a			ld a, (.dmark+1)  
3ab8 32 b5 fe			ld (debug_mark+1),a  
3abb 3a c5 3a			ld a, (.dmark+2)  
3abe 32 b6 fe			ld (debug_mark+2),a  
3ac1 18 03			jr .pastdmark  
3ac3 ..			.dmark: db "MIN"  
3ac6 f1			.pastdmark: pop af  
3ac7			endm  
# End of macro DMARK
3ac7						CALLMONITOR 
3ac7 cd c6 18			call break_point_state  
3aca				endm  
# End of macro CALLMONITOR
3aca					endif 
3aca cd 3a 1f				call forth_push_numhl 
3acd			 
3acd				       NEXTW 
3acd c3 e7 22			jp macro_next 
3ad0				endm 
# End of macro NEXTW
3ad0			 
3ad0			.mincont:  
3ad0 c1				pop bc   ; tidy up 
3ad1 eb				ex de , hl  
3ad2					if DEBUG_FORTH_WORDS 
3ad2						DMARK "MI1" 
3ad2 f5				push af  
3ad3 3a e7 3a			ld a, (.dmark)  
3ad6 32 b4 fe			ld (debug_mark),a  
3ad9 3a e8 3a			ld a, (.dmark+1)  
3adc 32 b5 fe			ld (debug_mark+1),a  
3adf 3a e9 3a			ld a, (.dmark+2)  
3ae2 32 b6 fe			ld (debug_mark+2),a  
3ae5 18 03			jr .pastdmark  
3ae7 ..			.dmark: db "MI1"  
3aea f1			.pastdmark: pop af  
3aeb			endm  
# End of macro DMARK
3aeb						CALLMONITOR 
3aeb cd c6 18			call break_point_state  
3aee				endm  
# End of macro CALLMONITOR
3aee					endif 
3aee cd 3a 1f				call forth_push_numhl 
3af1			 
3af1				       NEXTW 
3af1 c3 e7 22			jp macro_next 
3af4				endm 
# End of macro NEXTW
3af4			.MAX: 
3af4				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3af4 4a				db WORD_SYS_CORE+54             
3af5 75 3b			dw .RND16            
3af7 04				db 3 + 1 
3af8 .. 00			db "MAX",0              
3afc				endm 
# End of macro CWHEAD
3afc			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3afc					if DEBUG_FORTH_WORDS_KEY 
3afc						DMARK "MAX" 
3afc f5				push af  
3afd 3a 11 3b			ld a, (.dmark)  
3b00 32 b4 fe			ld (debug_mark),a  
3b03 3a 12 3b			ld a, (.dmark+1)  
3b06 32 b5 fe			ld (debug_mark+1),a  
3b09 3a 13 3b			ld a, (.dmark+2)  
3b0c 32 b6 fe			ld (debug_mark+2),a  
3b0f 18 03			jr .pastdmark  
3b11 ..			.dmark: db "MAX"  
3b14 f1			.pastdmark: pop af  
3b15			endm  
# End of macro DMARK
3b15						CALLMONITOR 
3b15 cd c6 18			call break_point_state  
3b18				endm  
# End of macro CALLMONITOR
3b18					endif 
3b18					; get u2 
3b18			 
3b18					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b18 cd 31 21			call macro_dsp_valuehl 
3b1b				endm 
# End of macro FORTH_DSP_VALUEHL
3b1b			 
3b1b e5					push hl   ; u2 
3b1c			 
3b1c					; destroy value TOS 
3b1c			 
3b1c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b1c cd e9 21			call macro_forth_dsp_pop 
3b1f				endm 
# End of macro FORTH_DSP_POP
3b1f			 
3b1f					; get u1 
3b1f			 
3b1f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b1f cd 31 21			call macro_dsp_valuehl 
3b22				endm 
# End of macro FORTH_DSP_VALUEHL
3b22			 
3b22 e5					push hl  ; u1 
3b23			 
3b23					; destroy value TOS 
3b23			 
3b23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b23 cd e9 21			call macro_forth_dsp_pop 
3b26				endm 
# End of macro FORTH_DSP_POP
3b26			 
3b26 b7			 or a      ;clear carry flag 
3b27 e1			  pop hl    ; u1 
3b28 d1			  pop de    ; u2 
3b29 e5				push hl   ; saved in case hl is lowest 
3b2a ed 52		  sbc hl,de 
3b2c 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b2e			 
3b2e e1				pop hl 
3b2f					if DEBUG_FORTH_WORDS 
3b2f						DMARK "MAX" 
3b2f f5				push af  
3b30 3a 44 3b			ld a, (.dmark)  
3b33 32 b4 fe			ld (debug_mark),a  
3b36 3a 45 3b			ld a, (.dmark+1)  
3b39 32 b5 fe			ld (debug_mark+1),a  
3b3c 3a 46 3b			ld a, (.dmark+2)  
3b3f 32 b6 fe			ld (debug_mark+2),a  
3b42 18 03			jr .pastdmark  
3b44 ..			.dmark: db "MAX"  
3b47 f1			.pastdmark: pop af  
3b48			endm  
# End of macro DMARK
3b48						CALLMONITOR 
3b48 cd c6 18			call break_point_state  
3b4b				endm  
# End of macro CALLMONITOR
3b4b					endif 
3b4b cd 3a 1f				call forth_push_numhl 
3b4e			 
3b4e				       NEXTW 
3b4e c3 e7 22			jp macro_next 
3b51				endm 
# End of macro NEXTW
3b51			 
3b51			.maxcont:  
3b51 c1				pop bc   ; tidy up 
3b52 eb				ex de , hl  
3b53					if DEBUG_FORTH_WORDS 
3b53						DMARK "MA1" 
3b53 f5				push af  
3b54 3a 68 3b			ld a, (.dmark)  
3b57 32 b4 fe			ld (debug_mark),a  
3b5a 3a 69 3b			ld a, (.dmark+1)  
3b5d 32 b5 fe			ld (debug_mark+1),a  
3b60 3a 6a 3b			ld a, (.dmark+2)  
3b63 32 b6 fe			ld (debug_mark+2),a  
3b66 18 03			jr .pastdmark  
3b68 ..			.dmark: db "MA1"  
3b6b f1			.pastdmark: pop af  
3b6c			endm  
# End of macro DMARK
3b6c						CALLMONITOR 
3b6c cd c6 18			call break_point_state  
3b6f				endm  
# End of macro CALLMONITOR
3b6f					endif 
3b6f cd 3a 1f				call forth_push_numhl 
3b72				       NEXTW 
3b72 c3 e7 22			jp macro_next 
3b75				endm 
# End of macro NEXTW
3b75			 
3b75			.RND16: 
3b75				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3b75 4e				db WORD_SYS_CORE+58             
3b76 a4 3b			dw .RND8            
3b78 06				db 5 + 1 
3b79 .. 00			db "RND16",0              
3b7f				endm 
# End of macro CWHEAD
3b7f			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3b7f					if DEBUG_FORTH_WORDS_KEY 
3b7f						DMARK "R16" 
3b7f f5				push af  
3b80 3a 94 3b			ld a, (.dmark)  
3b83 32 b4 fe			ld (debug_mark),a  
3b86 3a 95 3b			ld a, (.dmark+1)  
3b89 32 b5 fe			ld (debug_mark+1),a  
3b8c 3a 96 3b			ld a, (.dmark+2)  
3b8f 32 b6 fe			ld (debug_mark+2),a  
3b92 18 03			jr .pastdmark  
3b94 ..			.dmark: db "R16"  
3b97 f1			.pastdmark: pop af  
3b98			endm  
# End of macro DMARK
3b98						CALLMONITOR 
3b98 cd c6 18			call break_point_state  
3b9b				endm  
# End of macro CALLMONITOR
3b9b					endif 
3b9b cd 70 0e				call prng16  
3b9e cd 3a 1f				call forth_push_numhl 
3ba1				       NEXTW 
3ba1 c3 e7 22			jp macro_next 
3ba4				endm 
# End of macro NEXTW
3ba4			.RND8: 
3ba4				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3ba4 60				db WORD_SYS_CORE+76             
3ba5 d9 3b			dw .RND            
3ba7 05				db 4 + 1 
3ba8 .. 00			db "RND8",0              
3bad				endm 
# End of macro CWHEAD
3bad			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3bad					if DEBUG_FORTH_WORDS_KEY 
3bad						DMARK "RN8" 
3bad f5				push af  
3bae 3a c2 3b			ld a, (.dmark)  
3bb1 32 b4 fe			ld (debug_mark),a  
3bb4 3a c3 3b			ld a, (.dmark+1)  
3bb7 32 b5 fe			ld (debug_mark+1),a  
3bba 3a c4 3b			ld a, (.dmark+2)  
3bbd 32 b6 fe			ld (debug_mark+2),a  
3bc0 18 03			jr .pastdmark  
3bc2 ..			.dmark: db "RN8"  
3bc5 f1			.pastdmark: pop af  
3bc6			endm  
# End of macro DMARK
3bc6						CALLMONITOR 
3bc6 cd c6 18			call break_point_state  
3bc9				endm  
# End of macro CALLMONITOR
3bc9					endif 
3bc9 2a 35 fd				ld hl,(xrandc) 
3bcc 23					inc hl 
3bcd cd 8a 0e				call xrnd 
3bd0 6f					ld l,a	 
3bd1 26 00				ld h,0 
3bd3 cd 3a 1f				call forth_push_numhl 
3bd6				       NEXTW 
3bd6 c3 e7 22			jp macro_next 
3bd9				endm 
# End of macro NEXTW
3bd9			.RND: 
3bd9				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3bd9 60				db WORD_SYS_CORE+76             
3bda df 3c			dw .ENDMATHS            
3bdc 04				db 3 + 1 
3bdd .. 00			db "RND",0              
3be1				endm 
# End of macro CWHEAD
3be1			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3be1			 
3be1					if DEBUG_FORTH_WORDS_KEY 
3be1						DMARK "RND" 
3be1 f5				push af  
3be2 3a f6 3b			ld a, (.dmark)  
3be5 32 b4 fe			ld (debug_mark),a  
3be8 3a f7 3b			ld a, (.dmark+1)  
3beb 32 b5 fe			ld (debug_mark+1),a  
3bee 3a f8 3b			ld a, (.dmark+2)  
3bf1 32 b6 fe			ld (debug_mark+2),a  
3bf4 18 03			jr .pastdmark  
3bf6 ..			.dmark: db "RND"  
3bf9 f1			.pastdmark: pop af  
3bfa			endm  
# End of macro DMARK
3bfa						CALLMONITOR 
3bfa cd c6 18			call break_point_state  
3bfd				endm  
# End of macro CALLMONITOR
3bfd					endif 
3bfd					 
3bfd					FORTH_DSP_VALUEHL    ; upper range 
3bfd cd 31 21			call macro_dsp_valuehl 
3c00				endm 
# End of macro FORTH_DSP_VALUEHL
3c00			 
3c00 22 39 fd				ld (LFSRSeed), hl	 
3c03			 
3c03					if DEBUG_FORTH_WORDS 
3c03						DMARK "RN1" 
3c03 f5				push af  
3c04 3a 18 3c			ld a, (.dmark)  
3c07 32 b4 fe			ld (debug_mark),a  
3c0a 3a 19 3c			ld a, (.dmark+1)  
3c0d 32 b5 fe			ld (debug_mark+1),a  
3c10 3a 1a 3c			ld a, (.dmark+2)  
3c13 32 b6 fe			ld (debug_mark+2),a  
3c16 18 03			jr .pastdmark  
3c18 ..			.dmark: db "RN1"  
3c1b f1			.pastdmark: pop af  
3c1c			endm  
# End of macro DMARK
3c1c						CALLMONITOR 
3c1c cd c6 18			call break_point_state  
3c1f				endm  
# End of macro CALLMONITOR
3c1f					endif 
3c1f					FORTH_DSP_POP 
3c1f cd e9 21			call macro_forth_dsp_pop 
3c22				endm 
# End of macro FORTH_DSP_POP
3c22			 
3c22					FORTH_DSP_VALUEHL    ; low range 
3c22 cd 31 21			call macro_dsp_valuehl 
3c25				endm 
# End of macro FORTH_DSP_VALUEHL
3c25			 
3c25					if DEBUG_FORTH_WORDS 
3c25						DMARK "RN2" 
3c25 f5				push af  
3c26 3a 3a 3c			ld a, (.dmark)  
3c29 32 b4 fe			ld (debug_mark),a  
3c2c 3a 3b 3c			ld a, (.dmark+1)  
3c2f 32 b5 fe			ld (debug_mark+1),a  
3c32 3a 3c 3c			ld a, (.dmark+2)  
3c35 32 b6 fe			ld (debug_mark+2),a  
3c38 18 03			jr .pastdmark  
3c3a ..			.dmark: db "RN2"  
3c3d f1			.pastdmark: pop af  
3c3e			endm  
# End of macro DMARK
3c3e						CALLMONITOR 
3c3e cd c6 18			call break_point_state  
3c41				endm  
# End of macro CALLMONITOR
3c41					endif 
3c41 22 3b fd				ld (LFSRSeed+2), hl 
3c44			 
3c44					FORTH_DSP_POP 
3c44 cd e9 21			call macro_forth_dsp_pop 
3c47				endm 
# End of macro FORTH_DSP_POP
3c47			 
3c47 e5					push hl 
3c48			 
3c48 e1			.inrange:	pop hl 
3c49 cd 70 0e				call prng16  
3c4c					if DEBUG_FORTH_WORDS 
3c4c						DMARK "RN3" 
3c4c f5				push af  
3c4d 3a 61 3c			ld a, (.dmark)  
3c50 32 b4 fe			ld (debug_mark),a  
3c53 3a 62 3c			ld a, (.dmark+1)  
3c56 32 b5 fe			ld (debug_mark+1),a  
3c59 3a 63 3c			ld a, (.dmark+2)  
3c5c 32 b6 fe			ld (debug_mark+2),a  
3c5f 18 03			jr .pastdmark  
3c61 ..			.dmark: db "RN3"  
3c64 f1			.pastdmark: pop af  
3c65			endm  
# End of macro DMARK
3c65						CALLMONITOR 
3c65 cd c6 18			call break_point_state  
3c68				endm  
# End of macro CALLMONITOR
3c68					endif 
3c68					 
3c68					; if the range is 8bit knock out the high byte 
3c68			 
3c68 ed 5b 39 fd			ld de, (LFSRSeed)     ; check high level 
3c6c			 
3c6c 3e 00				ld a, 0 
3c6e ba					cp d  
3c6f 20 1e				jr nz, .hirange 
3c71 26 00				ld h, 0   ; knock it down to 8bit 
3c73			 
3c73					if DEBUG_FORTH_WORDS 
3c73						DMARK "RNk" 
3c73 f5				push af  
3c74 3a 88 3c			ld a, (.dmark)  
3c77 32 b4 fe			ld (debug_mark),a  
3c7a 3a 89 3c			ld a, (.dmark+1)  
3c7d 32 b5 fe			ld (debug_mark+1),a  
3c80 3a 8a 3c			ld a, (.dmark+2)  
3c83 32 b6 fe			ld (debug_mark+2),a  
3c86 18 03			jr .pastdmark  
3c88 ..			.dmark: db "RNk"  
3c8b f1			.pastdmark: pop af  
3c8c			endm  
# End of macro DMARK
3c8c						CALLMONITOR 
3c8c cd c6 18			call break_point_state  
3c8f				endm  
# End of macro CALLMONITOR
3c8f					endif 
3c8f			.hirange:   
3c8f e5					push hl  
3c90 b7					or a  
3c91 ed 52		                sbc hl, de 
3c93			 
3c93					;call cmp16 
3c93			 
3c93 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3c95 e1					pop hl 
3c96 e5					push hl 
3c97			 
3c97					if DEBUG_FORTH_WORDS 
3c97						DMARK "RN4" 
3c97 f5				push af  
3c98 3a ac 3c			ld a, (.dmark)  
3c9b 32 b4 fe			ld (debug_mark),a  
3c9e 3a ad 3c			ld a, (.dmark+1)  
3ca1 32 b5 fe			ld (debug_mark+1),a  
3ca4 3a ae 3c			ld a, (.dmark+2)  
3ca7 32 b6 fe			ld (debug_mark+2),a  
3caa 18 03			jr .pastdmark  
3cac ..			.dmark: db "RN4"  
3caf f1			.pastdmark: pop af  
3cb0			endm  
# End of macro DMARK
3cb0						CALLMONITOR 
3cb0 cd c6 18			call break_point_state  
3cb3				endm  
# End of macro CALLMONITOR
3cb3					endif 
3cb3 ed 5b 3b fd			ld de, (LFSRSeed+2)   ; check low range 
3cb7					;call cmp16 
3cb7				 
3cb7 b7					or a  
3cb8 ed 52		                sbc hl, de 
3cba 38 8c				jr c, .inrange 
3cbc			 
3cbc e1					pop hl 
3cbd					 
3cbd					if DEBUG_FORTH_WORDS 
3cbd						DMARK "RNd" 
3cbd f5				push af  
3cbe 3a d2 3c			ld a, (.dmark)  
3cc1 32 b4 fe			ld (debug_mark),a  
3cc4 3a d3 3c			ld a, (.dmark+1)  
3cc7 32 b5 fe			ld (debug_mark+1),a  
3cca 3a d4 3c			ld a, (.dmark+2)  
3ccd 32 b6 fe			ld (debug_mark+2),a  
3cd0 18 03			jr .pastdmark  
3cd2 ..			.dmark: db "RNd"  
3cd5 f1			.pastdmark: pop af  
3cd6			endm  
# End of macro DMARK
3cd6						CALLMONITOR 
3cd6 cd c6 18			call break_point_state  
3cd9				endm  
# End of macro CALLMONITOR
3cd9					endif 
3cd9			 
3cd9			 
3cd9 cd 3a 1f				call forth_push_numhl 
3cdc				       NEXTW 
3cdc c3 e7 22			jp macro_next 
3cdf				endm 
# End of macro NEXTW
3cdf			 
3cdf			.ENDMATHS: 
3cdf			 
3cdf			; eof 
3cdf			 
# End of file forth_words_maths.asm
3cdf			include "forth_words_display.asm" 
3cdf			 
3cdf			; | ## Display Words 
3cdf			 
3cdf			.INFO: 
3cdf			 
3cdf				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3cdf 62				db WORD_SYS_CORE+78             
3ce0 fc 3c			dw .ATP            
3ce2 05				db 4 + 1 
3ce3 .. 00			db "INFO",0              
3ce8				endm 
# End of macro CWHEAD
3ce8			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3ce8					FORTH_DSP_VALUEHL 
3ce8 cd 31 21			call macro_dsp_valuehl 
3ceb				endm 
# End of macro FORTH_DSP_VALUEHL
3ceb			 
3ceb					FORTH_DSP_POP 
3ceb cd e9 21			call macro_forth_dsp_pop 
3cee				endm 
# End of macro FORTH_DSP_POP
3cee			 
3cee e5					push hl 
3cef			 
3cef					FORTH_DSP_VALUEHL 
3cef cd 31 21			call macro_dsp_valuehl 
3cf2				endm 
# End of macro FORTH_DSP_VALUEHL
3cf2			 
3cf2					FORTH_DSP_POP 
3cf2 cd e9 21			call macro_forth_dsp_pop 
3cf5				endm 
# End of macro FORTH_DSP_POP
3cf5			 
3cf5 d1					pop de 
3cf6			 
3cf6 cd a6 0c				call info_panel 
3cf9			 
3cf9			 
3cf9					NEXTW 
3cf9 c3 e7 22			jp macro_next 
3cfc				endm 
# End of macro NEXTW
3cfc			.ATP: 
3cfc				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3cfc 62				db WORD_SYS_CORE+78             
3cfd 73 3d			dw .FB            
3cff 04				db 3 + 1 
3d00 .. 00			db "AT?",0              
3d04				endm 
# End of macro CWHEAD
3d04			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3d04					if DEBUG_FORTH_WORDS_KEY 
3d04						DMARK "AT?" 
3d04 f5				push af  
3d05 3a 19 3d			ld a, (.dmark)  
3d08 32 b4 fe			ld (debug_mark),a  
3d0b 3a 1a 3d			ld a, (.dmark+1)  
3d0e 32 b5 fe			ld (debug_mark+1),a  
3d11 3a 1b 3d			ld a, (.dmark+2)  
3d14 32 b6 fe			ld (debug_mark+2),a  
3d17 18 03			jr .pastdmark  
3d19 ..			.dmark: db "AT?"  
3d1c f1			.pastdmark: pop af  
3d1d			endm  
# End of macro DMARK
3d1d						CALLMONITOR 
3d1d cd c6 18			call break_point_state  
3d20				endm  
# End of macro CALLMONITOR
3d20					endif 
3d20 3a eb fb				ld a, (f_cursor_ptr) 
3d23			 
3d23			if DEBUG_FORTH_WORDS 
3d23				DMARK "AT?" 
3d23 f5				push af  
3d24 3a 38 3d			ld a, (.dmark)  
3d27 32 b4 fe			ld (debug_mark),a  
3d2a 3a 39 3d			ld a, (.dmark+1)  
3d2d 32 b5 fe			ld (debug_mark+1),a  
3d30 3a 3a 3d			ld a, (.dmark+2)  
3d33 32 b6 fe			ld (debug_mark+2),a  
3d36 18 03			jr .pastdmark  
3d38 ..			.dmark: db "AT?"  
3d3b f1			.pastdmark: pop af  
3d3c			endm  
# End of macro DMARK
3d3c				CALLMONITOR 
3d3c cd c6 18			call break_point_state  
3d3f				endm  
# End of macro CALLMONITOR
3d3f			endif	 
3d3f					; count the number of rows 
3d3f			 
3d3f 06 00				ld b, 0 
3d41 4f			.atpr:		ld c, a    ; save in case we go below zero 
3d42 d6 14				sub display_cols 
3d44 f2 4a 3d				jp p, .atprunder 
3d47 04					inc b 
3d48 18 f7				jr .atpr 
3d4a			.atprunder:	 
3d4a			if DEBUG_FORTH_WORDS 
3d4a				DMARK "A?2" 
3d4a f5				push af  
3d4b 3a 5f 3d			ld a, (.dmark)  
3d4e 32 b4 fe			ld (debug_mark),a  
3d51 3a 60 3d			ld a, (.dmark+1)  
3d54 32 b5 fe			ld (debug_mark+1),a  
3d57 3a 61 3d			ld a, (.dmark+2)  
3d5a 32 b6 fe			ld (debug_mark+2),a  
3d5d 18 03			jr .pastdmark  
3d5f ..			.dmark: db "A?2"  
3d62 f1			.pastdmark: pop af  
3d63			endm  
# End of macro DMARK
3d63				CALLMONITOR 
3d63 cd c6 18			call break_point_state  
3d66				endm  
# End of macro CALLMONITOR
3d66			endif	 
3d66 26 00				ld h, 0 
3d68 69					ld l, c 
3d69 cd 3a 1f				call forth_push_numhl 
3d6c 68					ld l, b  
3d6d cd 3a 1f				call forth_push_numhl 
3d70			 
3d70			 
3d70				NEXTW 
3d70 c3 e7 22			jp macro_next 
3d73				endm 
# End of macro NEXTW
3d73			 
3d73			.FB: 
3d73				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3d73 1b				db WORD_SYS_CORE+7             
3d74 c1 3d			dw .EMIT            
3d76 03				db 2 + 1 
3d77 .. 00			db "FB",0              
3d7a				endm 
# End of macro CWHEAD
3d7a			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3d7a			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3d7a			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3d7a			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3d7a					if DEBUG_FORTH_WORDS_KEY 
3d7a						DMARK "FB." 
3d7a f5				push af  
3d7b 3a 8f 3d			ld a, (.dmark)  
3d7e 32 b4 fe			ld (debug_mark),a  
3d81 3a 90 3d			ld a, (.dmark+1)  
3d84 32 b5 fe			ld (debug_mark+1),a  
3d87 3a 91 3d			ld a, (.dmark+2)  
3d8a 32 b6 fe			ld (debug_mark+2),a  
3d8d 18 03			jr .pastdmark  
3d8f ..			.dmark: db "FB."  
3d92 f1			.pastdmark: pop af  
3d93			endm  
# End of macro DMARK
3d93						CALLMONITOR 
3d93 cd c6 18			call break_point_state  
3d96				endm  
# End of macro CALLMONITOR
3d96					endif 
3d96			 
3d96					FORTH_DSP_VALUEHL 
3d96 cd 31 21			call macro_dsp_valuehl 
3d99				endm 
# End of macro FORTH_DSP_VALUEHL
3d99			 
3d99 7d					ld a, l 
3d9a fe 01				cp 1 
3d9c 20 05				jr nz, .fbn1 
3d9e 21 f9 fd				ld hl, display_fb1 
3da1 18 15				jr .fbset 
3da3 fe 02		.fbn1:		cp 2 
3da5 20 05				jr nz, .fbn2 
3da7 21 57 fd				ld hl, display_fb2 
3daa 18 0c				jr .fbset 
3dac fe 03		.fbn2:		cp 3 
3dae 20 05				jr nz, .fbn3 
3db0 21 a8 fd				ld hl, display_fb3 
3db3 18 03				jr .fbset 
3db5			.fbn3:		 ; if invalid number select first 
3db5 21 f9 fd				ld hl, display_fb1 
3db8 22 55 fd		.fbset:		ld (display_fb_active), hl 
3dbb			 
3dbb					FORTH_DSP_POP 
3dbb cd e9 21			call macro_forth_dsp_pop 
3dbe				endm 
# End of macro FORTH_DSP_POP
3dbe			 
3dbe					NEXTW 
3dbe c3 e7 22			jp macro_next 
3dc1				endm 
# End of macro NEXTW
3dc1			 
3dc1			 
3dc1			.EMIT: 
3dc1				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3dc1 1b				db WORD_SYS_CORE+7             
3dc2 12 3e			dw .DOTH            
3dc4 05				db 4 + 1 
3dc5 .. 00			db "EMIT",0              
3dca				endm 
# End of macro CWHEAD
3dca			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3dca					; get value off TOS and display it 
3dca			 
3dca					if DEBUG_FORTH_WORDS_KEY 
3dca						DMARK "EMT" 
3dca f5				push af  
3dcb 3a df 3d			ld a, (.dmark)  
3dce 32 b4 fe			ld (debug_mark),a  
3dd1 3a e0 3d			ld a, (.dmark+1)  
3dd4 32 b5 fe			ld (debug_mark+1),a  
3dd7 3a e1 3d			ld a, (.dmark+2)  
3dda 32 b6 fe			ld (debug_mark+2),a  
3ddd 18 03			jr .pastdmark  
3ddf ..			.dmark: db "EMT"  
3de2 f1			.pastdmark: pop af  
3de3			endm  
# End of macro DMARK
3de3						CALLMONITOR 
3de3 cd c6 18			call break_point_state  
3de6				endm  
# End of macro CALLMONITOR
3de6					endif 
3de6			 
3de6					FORTH_DSP_VALUEHL 
3de6 cd 31 21			call macro_dsp_valuehl 
3de9				endm 
# End of macro FORTH_DSP_VALUEHL
3de9			 
3de9 7d					ld a,l 
3dea			 
3dea					; TODO write to display 
3dea			 
3dea 32 4c f5				ld (os_input), a 
3ded 3e 00				ld a, 0 
3def 32 4d f5				ld (os_input+1), a 
3df2					 
3df2 3a eb fb				ld a, (f_cursor_ptr) 
3df5 11 4c f5				ld de, os_input 
3df8 cd 28 0d				call str_at_display 
3dfb			 
3dfb			 
3dfb 3a c9 fb				ld a,(cli_autodisplay) 
3dfe fe 00				cp 0 
3e00 28 03				jr z, .enoupdate 
3e02 cd 38 0d						call update_display 
3e05					.enoupdate: 
3e05			 
3e05 3a eb fb				ld a, (f_cursor_ptr) 
3e08 3c					inc a 
3e09 32 eb fb				ld (f_cursor_ptr), a   ; save new pos 
3e0c			 
3e0c			 
3e0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e0c cd e9 21			call macro_forth_dsp_pop 
3e0f				endm 
# End of macro FORTH_DSP_POP
3e0f			  
3e0f			 
3e0f					NEXTW 
3e0f c3 e7 22			jp macro_next 
3e12				endm 
# End of macro NEXTW
3e12			.DOTH: 
3e12				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3e12 1c				db WORD_SYS_CORE+8             
3e13 42 3e			dw .DOTF            
3e15 03				db 2 + 1 
3e16 .. 00			db ".-",0              
3e19				endm 
# End of macro CWHEAD
3e19			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3e19					; get value off TOS and display it 
3e19					if DEBUG_FORTH_WORDS_KEY 
3e19						DMARK "DTD" 
3e19 f5				push af  
3e1a 3a 2e 3e			ld a, (.dmark)  
3e1d 32 b4 fe			ld (debug_mark),a  
3e20 3a 2f 3e			ld a, (.dmark+1)  
3e23 32 b5 fe			ld (debug_mark+1),a  
3e26 3a 30 3e			ld a, (.dmark+2)  
3e29 32 b6 fe			ld (debug_mark+2),a  
3e2c 18 03			jr .pastdmark  
3e2e ..			.dmark: db "DTD"  
3e31 f1			.pastdmark: pop af  
3e32			endm  
# End of macro DMARK
3e32						CALLMONITOR 
3e32 cd c6 18			call break_point_state  
3e35				endm  
# End of macro CALLMONITOR
3e35					endif 
3e35 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3e37 3e 00			ld a, 0 
3e39 32 ca fb			ld (cli_mvdot), a 
3e3c c3 99 3e			jp .dotgo 
3e3f				NEXTW 
3e3f c3 e7 22			jp macro_next 
3e42				endm 
# End of macro NEXTW
3e42			.DOTF: 
3e42				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3e42 1c				db WORD_SYS_CORE+8             
3e43 70 3e			dw .DOT            
3e45 03				db 2 + 1 
3e46 .. 00			db ".>",0              
3e49				endm 
# End of macro CWHEAD
3e49			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3e49					; get value off TOS and display it 
3e49			        ; TODO BUG adds extra spaces 
3e49			        ; TODO BUG handle numerics? 
3e49					if DEBUG_FORTH_WORDS_KEY 
3e49						DMARK "DTC" 
3e49 f5				push af  
3e4a 3a 5e 3e			ld a, (.dmark)  
3e4d 32 b4 fe			ld (debug_mark),a  
3e50 3a 5f 3e			ld a, (.dmark+1)  
3e53 32 b5 fe			ld (debug_mark+1),a  
3e56 3a 60 3e			ld a, (.dmark+2)  
3e59 32 b6 fe			ld (debug_mark+2),a  
3e5c 18 03			jr .pastdmark  
3e5e ..			.dmark: db "DTC"  
3e61 f1			.pastdmark: pop af  
3e62			endm  
# End of macro DMARK
3e62						CALLMONITOR 
3e62 cd c6 18			call break_point_state  
3e65				endm  
# End of macro CALLMONITOR
3e65					endif 
3e65 3e 01			ld a, 1 
3e67 32 ca fb			ld (cli_mvdot), a 
3e6a c3 99 3e			jp .dotgo 
3e6d				NEXTW 
3e6d c3 e7 22			jp macro_next 
3e70				endm 
# End of macro NEXTW
3e70			 
3e70			.DOT: 
3e70				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3e70 1c				db WORD_SYS_CORE+8             
3e71 4c 40			dw .CLS            
3e73 02				db 1 + 1 
3e74 .. 00			db ".",0              
3e76				endm 
# End of macro CWHEAD
3e76			        ; | . ( u -- ) Display TOS | DONE 
3e76					; get value off TOS and display it 
3e76			 
3e76					if DEBUG_FORTH_WORDS_KEY 
3e76						DMARK "DOT" 
3e76 f5				push af  
3e77 3a 8b 3e			ld a, (.dmark)  
3e7a 32 b4 fe			ld (debug_mark),a  
3e7d 3a 8c 3e			ld a, (.dmark+1)  
3e80 32 b5 fe			ld (debug_mark+1),a  
3e83 3a 8d 3e			ld a, (.dmark+2)  
3e86 32 b6 fe			ld (debug_mark+2),a  
3e89 18 03			jr .pastdmark  
3e8b ..			.dmark: db "DOT"  
3e8e f1			.pastdmark: pop af  
3e8f			endm  
# End of macro DMARK
3e8f						CALLMONITOR 
3e8f cd c6 18			call break_point_state  
3e92				endm  
# End of macro CALLMONITOR
3e92					endif 
3e92 3e 00			ld a, 0 
3e94 32 ca fb			ld (cli_mvdot), a 
3e97 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3e99				 
3e99			 
3e99			.dotgo: 
3e99			 
3e99			; move up type to on stack for parserv5 
3e99					FORTH_DSP 
3e99 cd f7 20			call macro_forth_dsp 
3e9c				endm 
# End of macro FORTH_DSP
3e9c				;FORTH_DSP_VALUE  
3e9c			 
3e9c			if DEBUG_FORTH_DOT 
3e9c				DMARK "DOT" 
3e9c f5				push af  
3e9d 3a b1 3e			ld a, (.dmark)  
3ea0 32 b4 fe			ld (debug_mark),a  
3ea3 3a b2 3e			ld a, (.dmark+1)  
3ea6 32 b5 fe			ld (debug_mark+1),a  
3ea9 3a b3 3e			ld a, (.dmark+2)  
3eac 32 b6 fe			ld (debug_mark+2),a  
3eaf 18 03			jr .pastdmark  
3eb1 ..			.dmark: db "DOT"  
3eb4 f1			.pastdmark: pop af  
3eb5			endm  
# End of macro DMARK
3eb5				CALLMONITOR 
3eb5 cd c6 18			call break_point_state  
3eb8				endm  
# End of macro CALLMONITOR
3eb8			endif	 
3eb8			;		.print: 
3eb8			 
3eb8 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3eb9 23				inc hl   ; position to the actual value 
3eba fe 01			cp DS_TYPE_STR 
3ebc 20 06			jr nz, .dotnum1  
3ebe			 
3ebe			; display string 
3ebe				FORTH_DSP_VALUE  
3ebe cd 1a 21			call macro_forth_dsp_value 
3ec1				endm 
# End of macro FORTH_DSP_VALUE
3ec1 eb				ex de,hl 
3ec2 18 49			jr .dotwrite 
3ec4			 
3ec4			.dotnum1: 
3ec4 fe 02			cp DS_TYPE_INUM 
3ec6 20 44			jr nz, .dotflot 
3ec8			 
3ec8			 
3ec8			; display number 
3ec8			 
3ec8			;	push hl 
3ec8			;	call clear_display 
3ec8			;	pop hl 
3ec8			 
3ec8 5e				ld e, (hl) 
3ec9 23				inc hl 
3eca 56				ld d, (hl) 
3ecb 21 4e f3			ld hl, scratch 
3ece			if DEBUG_FORTH_DOT 
3ece				DMARK "DT1" 
3ece f5				push af  
3ecf 3a e3 3e			ld a, (.dmark)  
3ed2 32 b4 fe			ld (debug_mark),a  
3ed5 3a e4 3e			ld a, (.dmark+1)  
3ed8 32 b5 fe			ld (debug_mark+1),a  
3edb 3a e5 3e			ld a, (.dmark+2)  
3ede 32 b6 fe			ld (debug_mark+2),a  
3ee1 18 03			jr .pastdmark  
3ee3 ..			.dmark: db "DT1"  
3ee6 f1			.pastdmark: pop af  
3ee7			endm  
# End of macro DMARK
3ee7				CALLMONITOR 
3ee7 cd c6 18			call break_point_state  
3eea				endm  
# End of macro CALLMONITOR
3eea			endif	 
3eea			 
3eea cd 56 13			call uitoa_16 
3eed eb				ex de,hl 
3eee			 
3eee			if DEBUG_FORTH_DOT 
3eee				DMARK "DT2" 
3eee f5				push af  
3eef 3a 03 3f			ld a, (.dmark)  
3ef2 32 b4 fe			ld (debug_mark),a  
3ef5 3a 04 3f			ld a, (.dmark+1)  
3ef8 32 b5 fe			ld (debug_mark+1),a  
3efb 3a 05 3f			ld a, (.dmark+2)  
3efe 32 b6 fe			ld (debug_mark+2),a  
3f01 18 03			jr .pastdmark  
3f03 ..			.dmark: db "DT2"  
3f06 f1			.pastdmark: pop af  
3f07			endm  
# End of macro DMARK
3f07				CALLMONITOR 
3f07 cd c6 18			call break_point_state  
3f0a				endm  
# End of macro CALLMONITOR
3f0a			endif	 
3f0a			 
3f0a			;	ld de, os_word_scratch 
3f0a 18 01			jr .dotwrite 
3f0c			 
3f0c 00			.dotflot:   nop 
3f0d			; TODO print floating point number 
3f0d			 
3f0d			.dotwrite:		 
3f0d			 
3f0d					; if c is set then set all '-' to spaces 
3f0d					; need to also take into account .>  
3f0d			 
3f0d 3e 01				ld a, 1 
3f0f b9					cp c 
3f10 20 67				jr nz, .nodashswap 
3f12			 
3f12					; DE has the string to write, working with HL 
3f12			 
3f12 06 ff				ld b, 255 
3f14 d5					push de 
3f15 e1					pop hl 
3f16			 
3f16			if DEBUG_FORTH_DOT 
3f16				DMARK "DT-" 
3f16 f5				push af  
3f17 3a 2b 3f			ld a, (.dmark)  
3f1a 32 b4 fe			ld (debug_mark),a  
3f1d 3a 2c 3f			ld a, (.dmark+1)  
3f20 32 b5 fe			ld (debug_mark+1),a  
3f23 3a 2d 3f			ld a, (.dmark+2)  
3f26 32 b6 fe			ld (debug_mark+2),a  
3f29 18 03			jr .pastdmark  
3f2b ..			.dmark: db "DT-"  
3f2e f1			.pastdmark: pop af  
3f2f			endm  
# End of macro DMARK
3f2f				CALLMONITOR 
3f2f cd c6 18			call break_point_state  
3f32				endm  
# End of macro CALLMONITOR
3f32			endif	 
3f32 7e			.dashscan:	ld a, (hl) 
3f33 fe 00				cp 0 
3f35 28 42				jr z, .nodashswap 
3f37 fe 2d				cp '-' 
3f39 20 03				jr nz, .dashskip 
3f3b 3e 20				ld a, ' ' 
3f3d 77					ld (hl), a 
3f3e 23			.dashskip:	inc hl 
3f3f			if DEBUG_FORTH_DOT 
3f3f				DMARK "D-2" 
3f3f f5				push af  
3f40 3a 54 3f			ld a, (.dmark)  
3f43 32 b4 fe			ld (debug_mark),a  
3f46 3a 55 3f			ld a, (.dmark+1)  
3f49 32 b5 fe			ld (debug_mark+1),a  
3f4c 3a 56 3f			ld a, (.dmark+2)  
3f4f 32 b6 fe			ld (debug_mark+2),a  
3f52 18 03			jr .pastdmark  
3f54 ..			.dmark: db "D-2"  
3f57 f1			.pastdmark: pop af  
3f58			endm  
# End of macro DMARK
3f58				CALLMONITOR 
3f58 cd c6 18			call break_point_state  
3f5b				endm  
# End of macro CALLMONITOR
3f5b			endif	 
3f5b 10 d5				djnz .dashscan 
3f5d			 
3f5d			if DEBUG_FORTH_DOT 
3f5d				DMARK "D-1" 
3f5d f5				push af  
3f5e 3a 72 3f			ld a, (.dmark)  
3f61 32 b4 fe			ld (debug_mark),a  
3f64 3a 73 3f			ld a, (.dmark+1)  
3f67 32 b5 fe			ld (debug_mark+1),a  
3f6a 3a 74 3f			ld a, (.dmark+2)  
3f6d 32 b6 fe			ld (debug_mark+2),a  
3f70 18 03			jr .pastdmark  
3f72 ..			.dmark: db "D-1"  
3f75 f1			.pastdmark: pop af  
3f76			endm  
# End of macro DMARK
3f76				CALLMONITOR 
3f76 cd c6 18			call break_point_state  
3f79				endm  
# End of macro CALLMONITOR
3f79			endif	 
3f79			 
3f79			.nodashswap: 
3f79			 
3f79			if DEBUG_FORTH_DOT 
3f79				DMARK "D-o" 
3f79 f5				push af  
3f7a 3a 8e 3f			ld a, (.dmark)  
3f7d 32 b4 fe			ld (debug_mark),a  
3f80 3a 8f 3f			ld a, (.dmark+1)  
3f83 32 b5 fe			ld (debug_mark+1),a  
3f86 3a 90 3f			ld a, (.dmark+2)  
3f89 32 b6 fe			ld (debug_mark+2),a  
3f8c 18 03			jr .pastdmark  
3f8e ..			.dmark: db "D-o"  
3f91 f1			.pastdmark: pop af  
3f92			endm  
# End of macro DMARK
3f92				CALLMONITOR 
3f92 cd c6 18			call break_point_state  
3f95				endm  
# End of macro CALLMONITOR
3f95			endif	 
3f95			 
3f95 d5					push de   ; save string start in case we need to advance print 
3f96			 
3f96 3a eb fb				ld a, (f_cursor_ptr) 
3f99 cd 28 0d				call str_at_display 
3f9c 3a c9 fb				ld a,(cli_autodisplay) 
3f9f fe 00				cp 0 
3fa1 28 03				jr z, .noupdate 
3fa3 cd 38 0d						call update_display 
3fa6					.noupdate: 
3fa6			 
3fa6			 
3fa6					; see if we need to advance the print position 
3fa6			 
3fa6 e1					pop hl   ; get back string 
3fa7			;		ex de,hl 
3fa7			 
3fa7 3a ca fb				ld a, (cli_mvdot) 
3faa			if DEBUG_FORTH_DOT 
3faa			;		ld e,a 
3faa				DMARK "D>1" 
3faa f5				push af  
3fab 3a bf 3f			ld a, (.dmark)  
3fae 32 b4 fe			ld (debug_mark),a  
3fb1 3a c0 3f			ld a, (.dmark+1)  
3fb4 32 b5 fe			ld (debug_mark+1),a  
3fb7 3a c1 3f			ld a, (.dmark+2)  
3fba 32 b6 fe			ld (debug_mark+2),a  
3fbd 18 03			jr .pastdmark  
3fbf ..			.dmark: db "D>1"  
3fc2 f1			.pastdmark: pop af  
3fc3			endm  
# End of macro DMARK
3fc3				CALLMONITOR 
3fc3 cd c6 18			call break_point_state  
3fc6				endm  
# End of macro CALLMONITOR
3fc6			endif	 
3fc6 fe 00				cp 0 
3fc8 28 44				jr z, .noadv 
3fca					; yes, lets advance the print position 
3fca 3e 00				ld a, 0 
3fcc cd b2 13				call strlent 
3fcf			if DEBUG_FORTH_DOT 
3fcf				DMARK "D-?" 
3fcf f5				push af  
3fd0 3a e4 3f			ld a, (.dmark)  
3fd3 32 b4 fe			ld (debug_mark),a  
3fd6 3a e5 3f			ld a, (.dmark+1)  
3fd9 32 b5 fe			ld (debug_mark+1),a  
3fdc 3a e6 3f			ld a, (.dmark+2)  
3fdf 32 b6 fe			ld (debug_mark+2),a  
3fe2 18 03			jr .pastdmark  
3fe4 ..			.dmark: db "D-?"  
3fe7 f1			.pastdmark: pop af  
3fe8			endm  
# End of macro DMARK
3fe8				CALLMONITOR 
3fe8 cd c6 18			call break_point_state  
3feb				endm  
# End of macro CALLMONITOR
3feb			endif	 
3feb 3a eb fb				ld a, (f_cursor_ptr) 
3fee 85					add a,l 
3fef					;call addatohl 
3fef					;ld a, l 
3fef 32 eb fb				ld (f_cursor_ptr), a   ; save new pos 
3ff2			 
3ff2			if DEBUG_FORTH_DOT 
3ff2				DMARK "D->" 
3ff2 f5				push af  
3ff3 3a 07 40			ld a, (.dmark)  
3ff6 32 b4 fe			ld (debug_mark),a  
3ff9 3a 08 40			ld a, (.dmark+1)  
3ffc 32 b5 fe			ld (debug_mark+1),a  
3fff 3a 09 40			ld a, (.dmark+2)  
4002 32 b6 fe			ld (debug_mark+2),a  
4005 18 03			jr .pastdmark  
4007 ..			.dmark: db "D->"  
400a f1			.pastdmark: pop af  
400b			endm  
# End of macro DMARK
400b				CALLMONITOR 
400b cd c6 18			call break_point_state  
400e				endm  
# End of macro CALLMONITOR
400e			endif	 
400e			 
400e			.noadv:	 
400e			 
400e					if DEBUG_FORTH_DOT_WAIT 
400e							call next_page_prompt 
400e					endif	 
400e			; TODO this pop off the stack causes a crash. i dont know why 
400e			 
400e			 
400e			if DEBUG_FORTH_DOT 
400e				DMARK "DTh" 
400e f5				push af  
400f 3a 23 40			ld a, (.dmark)  
4012 32 b4 fe			ld (debug_mark),a  
4015 3a 24 40			ld a, (.dmark+1)  
4018 32 b5 fe			ld (debug_mark+1),a  
401b 3a 25 40			ld a, (.dmark+2)  
401e 32 b6 fe			ld (debug_mark+2),a  
4021 18 03			jr .pastdmark  
4023 ..			.dmark: db "DTh"  
4026 f1			.pastdmark: pop af  
4027			endm  
# End of macro DMARK
4027				CALLMONITOR 
4027 cd c6 18			call break_point_state  
402a				endm  
# End of macro CALLMONITOR
402a			endif	 
402a			 
402a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
402a cd e9 21			call macro_forth_dsp_pop 
402d				endm 
# End of macro FORTH_DSP_POP
402d			 
402d			if DEBUG_FORTH_DOT 
402d				DMARK "DTi" 
402d f5				push af  
402e 3a 42 40			ld a, (.dmark)  
4031 32 b4 fe			ld (debug_mark),a  
4034 3a 43 40			ld a, (.dmark+1)  
4037 32 b5 fe			ld (debug_mark+1),a  
403a 3a 44 40			ld a, (.dmark+2)  
403d 32 b6 fe			ld (debug_mark+2),a  
4040 18 03			jr .pastdmark  
4042 ..			.dmark: db "DTi"  
4045 f1			.pastdmark: pop af  
4046			endm  
# End of macro DMARK
4046				CALLMONITOR 
4046 cd c6 18			call break_point_state  
4049				endm  
# End of macro CALLMONITOR
4049			endif	 
4049			 
4049			 
4049					NEXTW 
4049 c3 e7 22			jp macro_next 
404c				endm 
# End of macro NEXTW
404c			 
404c			.CLS: 
404c				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
404c 35				db WORD_SYS_CORE+33             
404d 79 40			dw .DRAW            
404f 04				db 3 + 1 
4050 .. 00			db "CLS",0              
4054				endm 
# End of macro CWHEAD
4054			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4054					if DEBUG_FORTH_WORDS_KEY 
4054						DMARK "CLS" 
4054 f5				push af  
4055 3a 69 40			ld a, (.dmark)  
4058 32 b4 fe			ld (debug_mark),a  
405b 3a 6a 40			ld a, (.dmark+1)  
405e 32 b5 fe			ld (debug_mark+1),a  
4061 3a 6b 40			ld a, (.dmark+2)  
4064 32 b6 fe			ld (debug_mark+2),a  
4067 18 03			jr .pastdmark  
4069 ..			.dmark: db "CLS"  
406c f1			.pastdmark: pop af  
406d			endm  
# End of macro DMARK
406d						CALLMONITOR 
406d cd c6 18			call break_point_state  
4070				endm  
# End of macro CALLMONITOR
4070					endif 
4070 cd 15 0d				call clear_display 
4073 c3 87 41				jp .home		; and home cursor 
4076					NEXTW 
4076 c3 e7 22			jp macro_next 
4079				endm 
# End of macro NEXTW
4079			 
4079			.DRAW: 
4079				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4079 36				db WORD_SYS_CORE+34             
407a a4 40			dw .DUMP            
407c 05				db 4 + 1 
407d .. 00			db "DRAW",0              
4082				endm 
# End of macro CWHEAD
4082			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4082					if DEBUG_FORTH_WORDS_KEY 
4082						DMARK "DRW" 
4082 f5				push af  
4083 3a 97 40			ld a, (.dmark)  
4086 32 b4 fe			ld (debug_mark),a  
4089 3a 98 40			ld a, (.dmark+1)  
408c 32 b5 fe			ld (debug_mark+1),a  
408f 3a 99 40			ld a, (.dmark+2)  
4092 32 b6 fe			ld (debug_mark+2),a  
4095 18 03			jr .pastdmark  
4097 ..			.dmark: db "DRW"  
409a f1			.pastdmark: pop af  
409b			endm  
# End of macro DMARK
409b						CALLMONITOR 
409b cd c6 18			call break_point_state  
409e				endm  
# End of macro CALLMONITOR
409e					endif 
409e cd 38 0d				call update_display 
40a1					NEXTW 
40a1 c3 e7 22			jp macro_next 
40a4				endm 
# End of macro NEXTW
40a4			 
40a4			.DUMP: 
40a4				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
40a4 37				db WORD_SYS_CORE+35             
40a5 dc 40			dw .CDUMP            
40a7 05				db 4 + 1 
40a8 .. 00			db "DUMP",0              
40ad				endm 
# End of macro CWHEAD
40ad			; | DUMP ( x -- ) With address x display dump   | DONE 
40ad			; TODO pop address to use off of the stack 
40ad					if DEBUG_FORTH_WORDS_KEY 
40ad						DMARK "DUM" 
40ad f5				push af  
40ae 3a c2 40			ld a, (.dmark)  
40b1 32 b4 fe			ld (debug_mark),a  
40b4 3a c3 40			ld a, (.dmark+1)  
40b7 32 b5 fe			ld (debug_mark+1),a  
40ba 3a c4 40			ld a, (.dmark+2)  
40bd 32 b6 fe			ld (debug_mark+2),a  
40c0 18 03			jr .pastdmark  
40c2 ..			.dmark: db "DUM"  
40c5 f1			.pastdmark: pop af  
40c6			endm  
# End of macro DMARK
40c6						CALLMONITOR 
40c6 cd c6 18			call break_point_state  
40c9				endm  
# End of macro CALLMONITOR
40c9					endif 
40c9 cd 15 0d				call clear_display 
40cc			 
40cc					; get address 
40cc			 
40cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40cc cd 31 21			call macro_dsp_valuehl 
40cf				endm 
# End of macro FORTH_DSP_VALUEHL
40cf				 
40cf					; save it for cdump 
40cf			 
40cf 22 71 f6				ld (os_cur_ptr),hl 
40d2			 
40d2					; destroy value TOS 
40d2			 
40d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40d2 cd e9 21			call macro_forth_dsp_pop 
40d5				endm 
# End of macro FORTH_DSP_POP
40d5			 
40d5 cd ba 1d				call dumpcont	; skip old style of param parsing	 
40d8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
40d9					NEXTW 
40d9 c3 e7 22			jp macro_next 
40dc				endm 
# End of macro NEXTW
40dc			.CDUMP: 
40dc				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
40dc 38				db WORD_SYS_CORE+36             
40dd 0c 41			dw .DAT            
40df 06				db 5 + 1 
40e0 .. 00			db "CDUMP",0              
40e6				endm 
# End of macro CWHEAD
40e6			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
40e6					if DEBUG_FORTH_WORDS_KEY 
40e6						DMARK "CDP" 
40e6 f5				push af  
40e7 3a fb 40			ld a, (.dmark)  
40ea 32 b4 fe			ld (debug_mark),a  
40ed 3a fc 40			ld a, (.dmark+1)  
40f0 32 b5 fe			ld (debug_mark+1),a  
40f3 3a fd 40			ld a, (.dmark+2)  
40f6 32 b6 fe			ld (debug_mark+2),a  
40f9 18 03			jr .pastdmark  
40fb ..			.dmark: db "CDP"  
40fe f1			.pastdmark: pop af  
40ff			endm  
# End of macro DMARK
40ff						CALLMONITOR 
40ff cd c6 18			call break_point_state  
4102				endm  
# End of macro CALLMONITOR
4102					endif 
4102 cd 15 0d				call clear_display 
4105 cd ba 1d				call dumpcont	 
4108 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4109					NEXTW 
4109 c3 e7 22			jp macro_next 
410c				endm 
# End of macro NEXTW
410c			 
410c			 
410c			 
410c			 
410c			.DAT: 
410c				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
410c 3d				db WORD_SYS_CORE+41             
410d 62 41			dw .HOME            
410f 03				db 2 + 1 
4110 .. 00			db "AT",0              
4113				endm 
# End of macro CWHEAD
4113			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4113					if DEBUG_FORTH_WORDS_KEY 
4113						DMARK "AT." 
4113 f5				push af  
4114 3a 28 41			ld a, (.dmark)  
4117 32 b4 fe			ld (debug_mark),a  
411a 3a 29 41			ld a, (.dmark+1)  
411d 32 b5 fe			ld (debug_mark+1),a  
4120 3a 2a 41			ld a, (.dmark+2)  
4123 32 b6 fe			ld (debug_mark+2),a  
4126 18 03			jr .pastdmark  
4128 ..			.dmark: db "AT."  
412b f1			.pastdmark: pop af  
412c			endm  
# End of macro DMARK
412c						CALLMONITOR 
412c cd c6 18			call break_point_state  
412f				endm  
# End of macro CALLMONITOR
412f					endif 
412f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
412f cd 31 21			call macro_dsp_valuehl 
4132				endm 
# End of macro FORTH_DSP_VALUEHL
4132			 
4132			 
4132					; TODO save cursor row 
4132 7d					ld a,l 
4133 fe 02				cp 2 
4135 20 04				jr nz, .crow3 
4137 3e 14				ld a, display_row_2 
4139 18 12				jr .ccol1 
413b fe 03		.crow3:		cp 3 
413d 20 04				jr nz, .crow4 
413f 3e 28				ld a, display_row_3 
4141 18 0a				jr .ccol1 
4143 fe 04		.crow4:		cp 4 
4145 20 04				jr nz, .crow1 
4147 3e 3c				ld a, display_row_4 
4149 18 02				jr .ccol1 
414b 3e 00		.crow1:		ld a,display_row_1 
414d f5			.ccol1:		push af			; got row offset 
414e 6f					ld l,a 
414f 26 00				ld h,0 
4151					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4151 cd e9 21			call macro_forth_dsp_pop 
4154				endm 
# End of macro FORTH_DSP_POP
4154					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4154 cd 31 21			call macro_dsp_valuehl 
4157				endm 
# End of macro FORTH_DSP_VALUEHL
4157					; TODO save cursor col 
4157 f1					pop af 
4158 85					add l		; add col offset 
4159 32 eb fb				ld (f_cursor_ptr), a 
415c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
415c cd e9 21			call macro_forth_dsp_pop 
415f				endm 
# End of macro FORTH_DSP_POP
415f			 
415f					; calculate  
415f			 
415f					NEXTW 
415f c3 e7 22			jp macro_next 
4162				endm 
# End of macro NEXTW
4162			 
4162			 
4162			.HOME: 
4162				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
4162 41				db WORD_SYS_CORE+45             
4163 8f 41			dw .SPACE            
4165 05				db 4 + 1 
4166 .. 00			db "HOME",0              
416b				endm 
# End of macro CWHEAD
416b			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
416b					if DEBUG_FORTH_WORDS_KEY 
416b						DMARK "HOM" 
416b f5				push af  
416c 3a 80 41			ld a, (.dmark)  
416f 32 b4 fe			ld (debug_mark),a  
4172 3a 81 41			ld a, (.dmark+1)  
4175 32 b5 fe			ld (debug_mark+1),a  
4178 3a 82 41			ld a, (.dmark+2)  
417b 32 b6 fe			ld (debug_mark+2),a  
417e 18 03			jr .pastdmark  
4180 ..			.dmark: db "HOM"  
4183 f1			.pastdmark: pop af  
4184			endm  
# End of macro DMARK
4184						CALLMONITOR 
4184 cd c6 18			call break_point_state  
4187				endm  
# End of macro CALLMONITOR
4187					endif 
4187 3e 00		.home:		ld a, 0		; and home cursor 
4189 32 eb fb				ld (f_cursor_ptr), a 
418c					NEXTW 
418c c3 e7 22			jp macro_next 
418f				endm 
# End of macro NEXTW
418f			 
418f			 
418f			.SPACE: 
418f				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
418f 46				db WORD_SYS_CORE+50             
4190 c5 41			dw .SPACES            
4192 03				db 2 + 1 
4193 .. 00			db "BL",0              
4196				endm 
# End of macro CWHEAD
4196			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4196					if DEBUG_FORTH_WORDS_KEY 
4196						DMARK "BL." 
4196 f5				push af  
4197 3a ab 41			ld a, (.dmark)  
419a 32 b4 fe			ld (debug_mark),a  
419d 3a ac 41			ld a, (.dmark+1)  
41a0 32 b5 fe			ld (debug_mark+1),a  
41a3 3a ad 41			ld a, (.dmark+2)  
41a6 32 b6 fe			ld (debug_mark+2),a  
41a9 18 03			jr .pastdmark  
41ab ..			.dmark: db "BL."  
41ae f1			.pastdmark: pop af  
41af			endm  
# End of macro DMARK
41af						CALLMONITOR 
41af cd c6 18			call break_point_state  
41b2				endm  
# End of macro CALLMONITOR
41b2					endif 
41b2 3e 20				ld a, " " 
41b4 32 4e f3				ld (scratch),a 
41b7 3e 00				ld a, 0 
41b9 32 4f f3				ld (scratch+1),a 
41bc 21 4e f3				ld hl, scratch 
41bf cd a8 1f				call forth_push_str 
41c2					 
41c2				       NEXTW 
41c2 c3 e7 22			jp macro_next 
41c5				endm 
# End of macro NEXTW
41c5			 
41c5			;.blstr: db " ", 0 
41c5			 
41c5			.SPACES: 
41c5				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
41c5 47				db WORD_SYS_CORE+51             
41c6 60 42			dw .SCROLL            
41c8 07				db 6 + 1 
41c9 .. 00			db "SPACES",0              
41d0				endm 
# End of macro CWHEAD
41d0			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
41d0					if DEBUG_FORTH_WORDS_KEY 
41d0						DMARK "SPS" 
41d0 f5				push af  
41d1 3a e5 41			ld a, (.dmark)  
41d4 32 b4 fe			ld (debug_mark),a  
41d7 3a e6 41			ld a, (.dmark+1)  
41da 32 b5 fe			ld (debug_mark+1),a  
41dd 3a e7 41			ld a, (.dmark+2)  
41e0 32 b6 fe			ld (debug_mark+2),a  
41e3 18 03			jr .pastdmark  
41e5 ..			.dmark: db "SPS"  
41e8 f1			.pastdmark: pop af  
41e9			endm  
# End of macro DMARK
41e9						CALLMONITOR 
41e9 cd c6 18			call break_point_state  
41ec				endm  
# End of macro CALLMONITOR
41ec					endif 
41ec			 
41ec			 
41ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
41ec cd 31 21			call macro_dsp_valuehl 
41ef				endm 
# End of macro FORTH_DSP_VALUEHL
41ef			 
41ef e5					push hl    ; u 
41f0					if DEBUG_FORTH_WORDS 
41f0						DMARK "SPA" 
41f0 f5				push af  
41f1 3a 05 42			ld a, (.dmark)  
41f4 32 b4 fe			ld (debug_mark),a  
41f7 3a 06 42			ld a, (.dmark+1)  
41fa 32 b5 fe			ld (debug_mark+1),a  
41fd 3a 07 42			ld a, (.dmark+2)  
4200 32 b6 fe			ld (debug_mark+2),a  
4203 18 03			jr .pastdmark  
4205 ..			.dmark: db "SPA"  
4208 f1			.pastdmark: pop af  
4209			endm  
# End of macro DMARK
4209						CALLMONITOR 
4209 cd c6 18			call break_point_state  
420c				endm  
# End of macro CALLMONITOR
420c					endif 
420c			 
420c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
420c cd e9 21			call macro_forth_dsp_pop 
420f				endm 
# End of macro FORTH_DSP_POP
420f e1					pop hl 
4210 0e 00				ld c, 0 
4212 45					ld b, l 
4213 21 4e f3				ld hl, scratch  
4216			 
4216					if DEBUG_FORTH_WORDS 
4216						DMARK "SP2" 
4216 f5				push af  
4217 3a 2b 42			ld a, (.dmark)  
421a 32 b4 fe			ld (debug_mark),a  
421d 3a 2c 42			ld a, (.dmark+1)  
4220 32 b5 fe			ld (debug_mark+1),a  
4223 3a 2d 42			ld a, (.dmark+2)  
4226 32 b6 fe			ld (debug_mark+2),a  
4229 18 03			jr .pastdmark  
422b ..			.dmark: db "SP2"  
422e f1			.pastdmark: pop af  
422f			endm  
# End of macro DMARK
422f						CALLMONITOR 
422f cd c6 18			call break_point_state  
4232				endm  
# End of macro CALLMONITOR
4232					endif 
4232 3e 20				ld a, ' ' 
4234			.spaces1:	 
4234 77					ld (hl),a 
4235 23					inc hl 
4236					 
4236 10 fc				djnz .spaces1 
4238 3e 00				ld a,0 
423a 77					ld (hl),a 
423b 21 4e f3				ld hl, scratch 
423e					if DEBUG_FORTH_WORDS 
423e						DMARK "SP3" 
423e f5				push af  
423f 3a 53 42			ld a, (.dmark)  
4242 32 b4 fe			ld (debug_mark),a  
4245 3a 54 42			ld a, (.dmark+1)  
4248 32 b5 fe			ld (debug_mark+1),a  
424b 3a 55 42			ld a, (.dmark+2)  
424e 32 b6 fe			ld (debug_mark+2),a  
4251 18 03			jr .pastdmark  
4253 ..			.dmark: db "SP3"  
4256 f1			.pastdmark: pop af  
4257			endm  
# End of macro DMARK
4257						CALLMONITOR 
4257 cd c6 18			call break_point_state  
425a				endm  
# End of macro CALLMONITOR
425a					endif 
425a cd a8 1f				call forth_push_str 
425d			 
425d				       NEXTW 
425d c3 e7 22			jp macro_next 
4260				endm 
# End of macro NEXTW
4260			 
4260			 
4260			 
4260			.SCROLL: 
4260				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4260 53				db WORD_SYS_CORE+63             
4261 8d 42			dw .SCROLLD            
4263 07				db 6 + 1 
4264 .. 00			db "SCROLL",0              
426b				endm 
# End of macro CWHEAD
426b			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
426b					if DEBUG_FORTH_WORDS_KEY 
426b						DMARK "SCR" 
426b f5				push af  
426c 3a 80 42			ld a, (.dmark)  
426f 32 b4 fe			ld (debug_mark),a  
4272 3a 81 42			ld a, (.dmark+1)  
4275 32 b5 fe			ld (debug_mark+1),a  
4278 3a 82 42			ld a, (.dmark+2)  
427b 32 b6 fe			ld (debug_mark+2),a  
427e 18 03			jr .pastdmark  
4280 ..			.dmark: db "SCR"  
4283 f1			.pastdmark: pop af  
4284			endm  
# End of macro DMARK
4284						CALLMONITOR 
4284 cd c6 18			call break_point_state  
4287				endm  
# End of macro CALLMONITOR
4287					endif 
4287			 
4287 cd d7 0c			call scroll_up 
428a			;	call update_display 
428a			 
428a					NEXTW 
428a c3 e7 22			jp macro_next 
428d				endm 
# End of macro NEXTW
428d			 
428d			 
428d			 
428d			;		; get dir 
428d			; 
428d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
428d			; 
428d			;		push hl 
428d			; 
428d			;		; destroy value TOS 
428d			; 
428d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
428d			; 
428d			;		; get count 
428d			; 
428d			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
428d			; 
428d			;		push hl 
428d			; 
428d			;		; destroy value TOS 
428d			; 
428d			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
428d			; 
428d			;		; one value on hl get other one back 
428d			; 
428d			;		pop bc    ; count 
428d			; 
428d			;		pop de   ; dir 
428d			; 
428d			; 
428d			;		ld b, c 
428d			; 
428d			;.scrolldir:     push bc 
428d			;		push de 
428d			; 
428d			;		ld a, 0 
428d			;		cp e 
428d			;		jr z, .scrollup  
428d			;		call scroll_down 
428d			;		jr .scrollnext 
428d			;.scrollup:	call scroll_up 
428d			; 
428d			;		 
428d			;.scrollnext: 
428d			;		pop de 
428d			;		pop bc 
428d			;		djnz .scrolldir 
428d			; 
428d			; 
428d			; 
428d			; 
428d			; 
428d			;		NEXTW 
428d			 
428d			.SCROLLD: 
428d				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
428d 53				db WORD_SYS_CORE+63             
428e bb 42			dw .ATQ            
4290 08				db 7 + 1 
4291 .. 00			db "SCROLLD",0              
4299				endm 
# End of macro CWHEAD
4299			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4299					if DEBUG_FORTH_WORDS_KEY 
4299						DMARK "SCD" 
4299 f5				push af  
429a 3a ae 42			ld a, (.dmark)  
429d 32 b4 fe			ld (debug_mark),a  
42a0 3a af 42			ld a, (.dmark+1)  
42a3 32 b5 fe			ld (debug_mark+1),a  
42a6 3a b0 42			ld a, (.dmark+2)  
42a9 32 b6 fe			ld (debug_mark+2),a  
42ac 18 03			jr .pastdmark  
42ae ..			.dmark: db "SCD"  
42b1 f1			.pastdmark: pop af  
42b2			endm  
# End of macro DMARK
42b2						CALLMONITOR 
42b2 cd c6 18			call break_point_state  
42b5				endm  
# End of macro CALLMONITOR
42b5					endif 
42b5			 
42b5 cd fb 0c			call scroll_down 
42b8			;	call update_display 
42b8			 
42b8					NEXTW 
42b8 c3 e7 22			jp macro_next 
42bb				endm 
# End of macro NEXTW
42bb			 
42bb			 
42bb			.ATQ: 
42bb				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
42bb 62				db WORD_SYS_CORE+78             
42bc 19 43			dw .AUTODSP            
42be 04				db 3 + 1 
42bf .. 00			db "AT@",0              
42c3				endm 
# End of macro CWHEAD
42c3			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
42c3					if DEBUG_FORTH_WORDS_KEY 
42c3						DMARK "ATA" 
42c3 f5				push af  
42c4 3a d8 42			ld a, (.dmark)  
42c7 32 b4 fe			ld (debug_mark),a  
42ca 3a d9 42			ld a, (.dmark+1)  
42cd 32 b5 fe			ld (debug_mark+1),a  
42d0 3a da 42			ld a, (.dmark+2)  
42d3 32 b6 fe			ld (debug_mark+2),a  
42d6 18 03			jr .pastdmark  
42d8 ..			.dmark: db "ATA"  
42db f1			.pastdmark: pop af  
42dc			endm  
# End of macro DMARK
42dc						CALLMONITOR 
42dc cd c6 18			call break_point_state  
42df				endm  
# End of macro CALLMONITOR
42df					endif 
42df			 
42df			 
42df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42df cd 31 21			call macro_dsp_valuehl 
42e2				endm 
# End of macro FORTH_DSP_VALUEHL
42e2			 
42e2					; TODO save cursor row 
42e2 7d					ld a,l 
42e3 fe 02				cp 2 
42e5 20 04				jr nz, .crow3aq 
42e7 3e 14				ld a, display_row_2 
42e9 18 12				jr .ccol1aq 
42eb fe 03		.crow3aq:		cp 3 
42ed 20 04				jr nz, .crow4aq 
42ef 3e 28				ld a, display_row_3 
42f1 18 0a				jr .ccol1aq 
42f3 fe 04		.crow4aq:		cp 4 
42f5 20 04				jr nz, .crow1aq 
42f7 3e 3c				ld a, display_row_4 
42f9 18 02				jr .ccol1aq 
42fb 3e 00		.crow1aq:		ld a,display_row_1 
42fd f5			.ccol1aq:		push af			; got row offset 
42fe 6f					ld l,a 
42ff 26 00				ld h,0 
4301					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4301 cd e9 21			call macro_forth_dsp_pop 
4304				endm 
# End of macro FORTH_DSP_POP
4304					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4304 cd 31 21			call macro_dsp_valuehl 
4307				endm 
# End of macro FORTH_DSP_VALUEHL
4307					; TODO save cursor col 
4307 f1					pop af 
4308 85					add l		; add col offset 
4309			 
4309					; add current frame buffer address 
4309 2a 55 fd				ld hl, (display_fb_active) 
430c cd 49 0f				call addatohl 
430f			 
430f			 
430f			 
430f			 
430f					; get char frame buffer location offset in hl 
430f			 
430f 7e					ld a,(hl) 
4310 26 00				ld h, 0 
4312 6f					ld l, a 
4313			 
4313 cd 3a 1f				call forth_push_numhl 
4316			 
4316			 
4316					NEXTW 
4316 c3 e7 22			jp macro_next 
4319				endm 
# End of macro NEXTW
4319			 
4319			.AUTODSP: 
4319				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4319 63				db WORD_SYS_CORE+79             
431a 2f 43			dw .MENU            
431c 05				db 4 + 1 
431d .. 00			db "ADSP",0              
4322				endm 
# End of macro CWHEAD
4322			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4322			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4322			 
4322					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4322 cd 31 21			call macro_dsp_valuehl 
4325				endm 
# End of macro FORTH_DSP_VALUEHL
4325			 
4325			;		push hl 
4325			 
4325					; destroy value TOS 
4325			 
4325					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4325 cd e9 21			call macro_forth_dsp_pop 
4328				endm 
# End of macro FORTH_DSP_POP
4328			 
4328			;		pop hl 
4328			 
4328 7d					ld a,l 
4329 32 c9 fb				ld (cli_autodisplay), a 
432c				       NEXTW 
432c c3 e7 22			jp macro_next 
432f				endm 
# End of macro NEXTW
432f			 
432f			.MENU: 
432f				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
432f 70				db WORD_SYS_CORE+92             
4330 d8 43			dw .ENDDISPLAY            
4332 05				db 4 + 1 
4333 .. 00			db "MENU",0              
4338				endm 
# End of macro CWHEAD
4338			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4338			 
4338			;		; get number of items on the stack 
4338			; 
4338				 
4338					FORTH_DSP_VALUEHL 
4338 cd 31 21			call macro_dsp_valuehl 
433b				endm 
# End of macro FORTH_DSP_VALUEHL
433b				 
433b					if DEBUG_FORTH_WORDS_KEY 
433b						DMARK "MNU" 
433b f5				push af  
433c 3a 50 43			ld a, (.dmark)  
433f 32 b4 fe			ld (debug_mark),a  
4342 3a 51 43			ld a, (.dmark+1)  
4345 32 b5 fe			ld (debug_mark+1),a  
4348 3a 52 43			ld a, (.dmark+2)  
434b 32 b6 fe			ld (debug_mark+2),a  
434e 18 03			jr .pastdmark  
4350 ..			.dmark: db "MNU"  
4353 f1			.pastdmark: pop af  
4354			endm  
# End of macro DMARK
4354						CALLMONITOR 
4354 cd c6 18			call break_point_state  
4357				endm  
# End of macro CALLMONITOR
4357					endif 
4357			 
4357 45					ld b, l	 
4358 05					dec b 
4359			 
4359					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4359 cd e9 21			call macro_forth_dsp_pop 
435c				endm 
# End of macro FORTH_DSP_POP
435c			 
435c			 
435c					; go directly through the stack to pluck out the string pointers and build an array 
435c			 
435c			;		FORTH_DSP 
435c			 
435c					; hl contains top most stack item 
435c				 
435c 11 4e f3				ld de, scratch 
435f			 
435f			.mbuild: 
435f			 
435f					FORTH_DSP_VALUEHL 
435f cd 31 21			call macro_dsp_valuehl 
4362				endm 
# End of macro FORTH_DSP_VALUEHL
4362			 
4362					if DEBUG_FORTH_WORDS 
4362						DMARK "MN3" 
4362 f5				push af  
4363 3a 77 43			ld a, (.dmark)  
4366 32 b4 fe			ld (debug_mark),a  
4369 3a 78 43			ld a, (.dmark+1)  
436c 32 b5 fe			ld (debug_mark+1),a  
436f 3a 79 43			ld a, (.dmark+2)  
4372 32 b6 fe			ld (debug_mark+2),a  
4375 18 03			jr .pastdmark  
4377 ..			.dmark: db "MN3"  
437a f1			.pastdmark: pop af  
437b			endm  
# End of macro DMARK
437b						CALLMONITOR 
437b cd c6 18			call break_point_state  
437e				endm  
# End of macro CALLMONITOR
437e					endif 
437e eb					ex de, hl 
437f 73					ld (hl), e 
4380 23					inc hl 
4381 72					ld (hl), d 
4382 23					inc hl 
4383 eb					ex de, hl 
4384			 
4384					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4384 cd e9 21			call macro_forth_dsp_pop 
4387				endm 
# End of macro FORTH_DSP_POP
4387			 
4387 10 d6				djnz .mbuild 
4389			 
4389					; done add term 
4389			 
4389 eb					ex de, hl 
438a 36 00				ld (hl), 0 
438c 23					inc hl 
438d 36 00				ld (hl), 0 
438f			 
438f				 
438f					 
438f 21 4e f3				ld hl, scratch 
4392			 
4392					if DEBUG_FORTH_WORDS 
4392						DMARK "MNx" 
4392 f5				push af  
4393 3a a7 43			ld a, (.dmark)  
4396 32 b4 fe			ld (debug_mark),a  
4399 3a a8 43			ld a, (.dmark+1)  
439c 32 b5 fe			ld (debug_mark+1),a  
439f 3a a9 43			ld a, (.dmark+2)  
43a2 32 b6 fe			ld (debug_mark+2),a  
43a5 18 03			jr .pastdmark  
43a7 ..			.dmark: db "MNx"  
43aa f1			.pastdmark: pop af  
43ab			endm  
# End of macro DMARK
43ab						CALLMONITOR 
43ab cd c6 18			call break_point_state  
43ae				endm  
# End of macro CALLMONITOR
43ae					endif 
43ae			 
43ae			 
43ae			 
43ae 3e 00				ld a, 0 
43b0 cd 46 0d				call menu 
43b3			 
43b3			 
43b3 6f					ld l, a 
43b4 26 00				ld h, 0 
43b6			 
43b6					if DEBUG_FORTH_WORDS 
43b6						DMARK "MNr" 
43b6 f5				push af  
43b7 3a cb 43			ld a, (.dmark)  
43ba 32 b4 fe			ld (debug_mark),a  
43bd 3a cc 43			ld a, (.dmark+1)  
43c0 32 b5 fe			ld (debug_mark+1),a  
43c3 3a cd 43			ld a, (.dmark+2)  
43c6 32 b6 fe			ld (debug_mark+2),a  
43c9 18 03			jr .pastdmark  
43cb ..			.dmark: db "MNr"  
43ce f1			.pastdmark: pop af  
43cf			endm  
# End of macro DMARK
43cf						CALLMONITOR 
43cf cd c6 18			call break_point_state  
43d2				endm  
# End of macro CALLMONITOR
43d2					endif 
43d2			 
43d2 cd 3a 1f				call forth_push_numhl 
43d5			 
43d5			 
43d5			 
43d5			 
43d5				       NEXTW 
43d5 c3 e7 22			jp macro_next 
43d8				endm 
# End of macro NEXTW
43d8			 
43d8			 
43d8			.ENDDISPLAY: 
43d8			 
43d8			; eof 
# End of file forth_words_display.asm
43d8			include "forth_words_str.asm" 
43d8			 
43d8			; | ## String Words 
43d8			 
43d8			.PTR:   
43d8			 
43d8				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
43d8 48				db WORD_SYS_CORE+52             
43d9 05 44			dw .STYPE            
43db 04				db 3 + 1 
43dc .. 00			db "PTR",0              
43e0				endm 
# End of macro CWHEAD
43e0			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
43e0			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
43e0			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
43e0			 
43e0					if DEBUG_FORTH_WORDS_KEY 
43e0						DMARK "PTR" 
43e0 f5				push af  
43e1 3a f5 43			ld a, (.dmark)  
43e4 32 b4 fe			ld (debug_mark),a  
43e7 3a f6 43			ld a, (.dmark+1)  
43ea 32 b5 fe			ld (debug_mark+1),a  
43ed 3a f7 43			ld a, (.dmark+2)  
43f0 32 b6 fe			ld (debug_mark+2),a  
43f3 18 03			jr .pastdmark  
43f5 ..			.dmark: db "PTR"  
43f8 f1			.pastdmark: pop af  
43f9			endm  
# End of macro DMARK
43f9						CALLMONITOR 
43f9 cd c6 18			call break_point_state  
43fc				endm  
# End of macro CALLMONITOR
43fc					endif 
43fc					FORTH_DSP_VALUEHL 
43fc cd 31 21			call macro_dsp_valuehl 
43ff				endm 
# End of macro FORTH_DSP_VALUEHL
43ff cd 3a 1f				call forth_push_numhl 
4402			 
4402			 
4402					NEXTW 
4402 c3 e7 22			jp macro_next 
4405				endm 
# End of macro NEXTW
4405			.STYPE: 
4405				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4405 48				db WORD_SYS_CORE+52             
4406 54 44			dw .UPPER            
4408 06				db 5 + 1 
4409 .. 00			db "STYPE",0              
440f				endm 
# End of macro CWHEAD
440f			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
440f					if DEBUG_FORTH_WORDS_KEY 
440f						DMARK "STY" 
440f f5				push af  
4410 3a 24 44			ld a, (.dmark)  
4413 32 b4 fe			ld (debug_mark),a  
4416 3a 25 44			ld a, (.dmark+1)  
4419 32 b5 fe			ld (debug_mark+1),a  
441c 3a 26 44			ld a, (.dmark+2)  
441f 32 b6 fe			ld (debug_mark+2),a  
4422 18 03			jr .pastdmark  
4424 ..			.dmark: db "STY"  
4427 f1			.pastdmark: pop af  
4428			endm  
# End of macro DMARK
4428						CALLMONITOR 
4428 cd c6 18			call break_point_state  
442b				endm  
# End of macro CALLMONITOR
442b					endif 
442b					FORTH_DSP 
442b cd f7 20			call macro_forth_dsp 
442e				endm 
# End of macro FORTH_DSP
442e					;v5 FORTH_DSP_VALUE 
442e			 
442e 7e					ld a, (hl) 
442f			 
442f f5					push af 
4430			 
4430			; Dont destroy TOS		FORTH_DSP_POP 
4430			 
4430 f1					pop af 
4431			 
4431 fe 01				cp DS_TYPE_STR 
4433 28 09				jr z, .typestr 
4435			 
4435 fe 02				cp DS_TYPE_INUM 
4437 28 0a				jr z, .typeinum 
4439			 
4439 21 52 44				ld hl, .tna 
443c 18 0a				jr .tpush 
443e			 
443e 21 4e 44		.typestr:	ld hl, .tstr 
4441 18 05				jr .tpush 
4443 21 50 44		.typeinum:	ld hl, .tinum 
4446 18 00				jr .tpush 
4448			 
4448			.tpush: 
4448			 
4448 cd a8 1f				call forth_push_str 
444b			 
444b					NEXTW 
444b c3 e7 22			jp macro_next 
444e				endm 
# End of macro NEXTW
444e .. 00		.tstr:	db "s",0 
4450 .. 00		.tinum:  db "i",0 
4452 .. 00		.tna:   db "?", 0 
4454			 
4454			 
4454			.UPPER: 
4454				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4454 48				db WORD_SYS_CORE+52             
4455 8f 44			dw .LOWER            
4457 06				db 5 + 1 
4458 .. 00			db "UPPER",0              
445e				endm 
# End of macro CWHEAD
445e			; | UPPER ( s -- s ) Upper case string s  | DONE 
445e					if DEBUG_FORTH_WORDS_KEY 
445e						DMARK "UPR" 
445e f5				push af  
445f 3a 73 44			ld a, (.dmark)  
4462 32 b4 fe			ld (debug_mark),a  
4465 3a 74 44			ld a, (.dmark+1)  
4468 32 b5 fe			ld (debug_mark+1),a  
446b 3a 75 44			ld a, (.dmark+2)  
446e 32 b6 fe			ld (debug_mark+2),a  
4471 18 03			jr .pastdmark  
4473 ..			.dmark: db "UPR"  
4476 f1			.pastdmark: pop af  
4477			endm  
# End of macro DMARK
4477						CALLMONITOR 
4477 cd c6 18			call break_point_state  
447a				endm  
# End of macro CALLMONITOR
447a					endif 
447a			 
447a					FORTH_DSP 
447a cd f7 20			call macro_forth_dsp 
447d				endm 
# End of macro FORTH_DSP
447d					 
447d			; TODO check is string type 
447d			 
447d					FORTH_DSP_VALUEHL 
447d cd 31 21			call macro_dsp_valuehl 
4480				endm 
# End of macro FORTH_DSP_VALUEHL
4480			; get pointer to string in hl 
4480			 
4480 7e			.toup:		ld a, (hl) 
4481 fe 00				cp 0 
4483 28 07				jr z, .toupdone 
4485			 
4485 cd b6 12				call to_upper 
4488			 
4488 77					ld (hl), a 
4489 23					inc hl 
448a 18 f4				jr .toup 
448c			 
448c					 
448c			 
448c			 
448c			; for each char convert to upper 
448c					 
448c			.toupdone: 
448c			 
448c			 
448c					NEXTW 
448c c3 e7 22			jp macro_next 
448f				endm 
# End of macro NEXTW
448f			.LOWER: 
448f				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
448f 48				db WORD_SYS_CORE+52             
4490 ca 44			dw .TCASE            
4492 06				db 5 + 1 
4493 .. 00			db "LOWER",0              
4499				endm 
# End of macro CWHEAD
4499			; | LOWER ( s -- s ) Lower case string s  | DONE 
4499					if DEBUG_FORTH_WORDS_KEY 
4499						DMARK "LWR" 
4499 f5				push af  
449a 3a ae 44			ld a, (.dmark)  
449d 32 b4 fe			ld (debug_mark),a  
44a0 3a af 44			ld a, (.dmark+1)  
44a3 32 b5 fe			ld (debug_mark+1),a  
44a6 3a b0 44			ld a, (.dmark+2)  
44a9 32 b6 fe			ld (debug_mark+2),a  
44ac 18 03			jr .pastdmark  
44ae ..			.dmark: db "LWR"  
44b1 f1			.pastdmark: pop af  
44b2			endm  
# End of macro DMARK
44b2						CALLMONITOR 
44b2 cd c6 18			call break_point_state  
44b5				endm  
# End of macro CALLMONITOR
44b5					endif 
44b5			 
44b5					FORTH_DSP 
44b5 cd f7 20			call macro_forth_dsp 
44b8				endm 
# End of macro FORTH_DSP
44b8					 
44b8			; TODO check is string type 
44b8			 
44b8					FORTH_DSP_VALUEHL 
44b8 cd 31 21			call macro_dsp_valuehl 
44bb				endm 
# End of macro FORTH_DSP_VALUEHL
44bb			; get pointer to string in hl 
44bb			 
44bb 7e			.tolow:		ld a, (hl) 
44bc fe 00				cp 0 
44be 28 07				jr z, .tolowdone 
44c0			 
44c0 cd bf 12				call to_lower 
44c3			 
44c3 77					ld (hl), a 
44c4 23					inc hl 
44c5 18 f4				jr .tolow 
44c7			 
44c7					 
44c7			 
44c7			 
44c7			; for each char convert to low 
44c7					 
44c7			.tolowdone: 
44c7					NEXTW 
44c7 c3 e7 22			jp macro_next 
44ca				endm 
# End of macro NEXTW
44ca			.TCASE: 
44ca				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
44ca 48				db WORD_SYS_CORE+52             
44cb 00 46			dw .SUBSTR            
44cd 06				db 5 + 1 
44ce .. 00			db "TCASE",0              
44d4				endm 
# End of macro CWHEAD
44d4			; | TCASE ( s -- s ) Title case string s  | DONE 
44d4					if DEBUG_FORTH_WORDS_KEY 
44d4						DMARK "TCS" 
44d4 f5				push af  
44d5 3a e9 44			ld a, (.dmark)  
44d8 32 b4 fe			ld (debug_mark),a  
44db 3a ea 44			ld a, (.dmark+1)  
44de 32 b5 fe			ld (debug_mark+1),a  
44e1 3a eb 44			ld a, (.dmark+2)  
44e4 32 b6 fe			ld (debug_mark+2),a  
44e7 18 03			jr .pastdmark  
44e9 ..			.dmark: db "TCS"  
44ec f1			.pastdmark: pop af  
44ed			endm  
# End of macro DMARK
44ed						CALLMONITOR 
44ed cd c6 18			call break_point_state  
44f0				endm  
# End of macro CALLMONITOR
44f0					endif 
44f0			 
44f0					FORTH_DSP 
44f0 cd f7 20			call macro_forth_dsp 
44f3				endm 
# End of macro FORTH_DSP
44f3					 
44f3			; TODO check is string type 
44f3			 
44f3					FORTH_DSP_VALUEHL 
44f3 cd 31 21			call macro_dsp_valuehl 
44f6				endm 
# End of macro FORTH_DSP_VALUEHL
44f6			; get pointer to string in hl 
44f6			 
44f6					if DEBUG_FORTH_WORDS 
44f6						DMARK "TC1" 
44f6 f5				push af  
44f7 3a 0b 45			ld a, (.dmark)  
44fa 32 b4 fe			ld (debug_mark),a  
44fd 3a 0c 45			ld a, (.dmark+1)  
4500 32 b5 fe			ld (debug_mark+1),a  
4503 3a 0d 45			ld a, (.dmark+2)  
4506 32 b6 fe			ld (debug_mark+2),a  
4509 18 03			jr .pastdmark  
450b ..			.dmark: db "TC1"  
450e f1			.pastdmark: pop af  
450f			endm  
# End of macro DMARK
450f						CALLMONITOR 
450f cd c6 18			call break_point_state  
4512				endm  
# End of macro CALLMONITOR
4512					endif 
4512			 
4512					; first time in turn to upper case first char 
4512			 
4512 7e					ld a, (hl) 
4513 c3 9d 45				jp .totsiptou 
4516			 
4516			 
4516 7e			.tot:		ld a, (hl) 
4517 fe 00				cp 0 
4519 ca e1 45				jp z, .totdone 
451c			 
451c					if DEBUG_FORTH_WORDS 
451c						DMARK "TC2" 
451c f5				push af  
451d 3a 31 45			ld a, (.dmark)  
4520 32 b4 fe			ld (debug_mark),a  
4523 3a 32 45			ld a, (.dmark+1)  
4526 32 b5 fe			ld (debug_mark+1),a  
4529 3a 33 45			ld a, (.dmark+2)  
452c 32 b6 fe			ld (debug_mark+2),a  
452f 18 03			jr .pastdmark  
4531 ..			.dmark: db "TC2"  
4534 f1			.pastdmark: pop af  
4535			endm  
# End of macro DMARK
4535						CALLMONITOR 
4535 cd c6 18			call break_point_state  
4538				endm  
# End of macro CALLMONITOR
4538					endif 
4538					; check to see if current char is a space 
4538			 
4538 fe 20				cp ' ' 
453a 28 21				jr z, .totsp 
453c cd bf 12				call to_lower 
453f					if DEBUG_FORTH_WORDS 
453f						DMARK "TC3" 
453f f5				push af  
4540 3a 54 45			ld a, (.dmark)  
4543 32 b4 fe			ld (debug_mark),a  
4546 3a 55 45			ld a, (.dmark+1)  
4549 32 b5 fe			ld (debug_mark+1),a  
454c 3a 56 45			ld a, (.dmark+2)  
454f 32 b6 fe			ld (debug_mark+2),a  
4552 18 03			jr .pastdmark  
4554 ..			.dmark: db "TC3"  
4557 f1			.pastdmark: pop af  
4558			endm  
# End of macro DMARK
4558						CALLMONITOR 
4558 cd c6 18			call break_point_state  
455b				endm  
# End of macro CALLMONITOR
455b					endif 
455b 18 63				jr .totnxt 
455d			 
455d			.totsp:         ; on a space, find next char which should be upper 
455d			 
455d					if DEBUG_FORTH_WORDS 
455d						DMARK "TC4" 
455d f5				push af  
455e 3a 72 45			ld a, (.dmark)  
4561 32 b4 fe			ld (debug_mark),a  
4564 3a 73 45			ld a, (.dmark+1)  
4567 32 b5 fe			ld (debug_mark+1),a  
456a 3a 74 45			ld a, (.dmark+2)  
456d 32 b6 fe			ld (debug_mark+2),a  
4570 18 03			jr .pastdmark  
4572 ..			.dmark: db "TC4"  
4575 f1			.pastdmark: pop af  
4576			endm  
# End of macro DMARK
4576						CALLMONITOR 
4576 cd c6 18			call break_point_state  
4579				endm  
# End of macro CALLMONITOR
4579					endif 
4579					;; 
4579			 
4579 fe 20				cp ' ' 
457b 20 20				jr nz, .totsiptou 
457d 23					inc hl 
457e 7e					ld a, (hl) 
457f					if DEBUG_FORTH_WORDS 
457f						DMARK "TC5" 
457f f5				push af  
4580 3a 94 45			ld a, (.dmark)  
4583 32 b4 fe			ld (debug_mark),a  
4586 3a 95 45			ld a, (.dmark+1)  
4589 32 b5 fe			ld (debug_mark+1),a  
458c 3a 96 45			ld a, (.dmark+2)  
458f 32 b6 fe			ld (debug_mark+2),a  
4592 18 03			jr .pastdmark  
4594 ..			.dmark: db "TC5"  
4597 f1			.pastdmark: pop af  
4598			endm  
# End of macro DMARK
4598						CALLMONITOR 
4598 cd c6 18			call break_point_state  
459b				endm  
# End of macro CALLMONITOR
459b					endif 
459b 18 c0				jr .totsp 
459d fe 00		.totsiptou:    cp 0 
459f 28 40				jr z, .totdone 
45a1					; not space and not zero term so upper case it 
45a1 cd b6 12				call to_upper 
45a4			 
45a4					if DEBUG_FORTH_WORDS 
45a4						DMARK "TC6" 
45a4 f5				push af  
45a5 3a b9 45			ld a, (.dmark)  
45a8 32 b4 fe			ld (debug_mark),a  
45ab 3a ba 45			ld a, (.dmark+1)  
45ae 32 b5 fe			ld (debug_mark+1),a  
45b1 3a bb 45			ld a, (.dmark+2)  
45b4 32 b6 fe			ld (debug_mark+2),a  
45b7 18 03			jr .pastdmark  
45b9 ..			.dmark: db "TC6"  
45bc f1			.pastdmark: pop af  
45bd			endm  
# End of macro DMARK
45bd						CALLMONITOR 
45bd cd c6 18			call break_point_state  
45c0				endm  
# End of macro CALLMONITOR
45c0					endif 
45c0			 
45c0			 
45c0			.totnxt: 
45c0			 
45c0 77					ld (hl), a 
45c1 23					inc hl 
45c2					if DEBUG_FORTH_WORDS 
45c2						DMARK "TC7" 
45c2 f5				push af  
45c3 3a d7 45			ld a, (.dmark)  
45c6 32 b4 fe			ld (debug_mark),a  
45c9 3a d8 45			ld a, (.dmark+1)  
45cc 32 b5 fe			ld (debug_mark+1),a  
45cf 3a d9 45			ld a, (.dmark+2)  
45d2 32 b6 fe			ld (debug_mark+2),a  
45d5 18 03			jr .pastdmark  
45d7 ..			.dmark: db "TC7"  
45da f1			.pastdmark: pop af  
45db			endm  
# End of macro DMARK
45db						CALLMONITOR 
45db cd c6 18			call break_point_state  
45de				endm  
# End of macro CALLMONITOR
45de					endif 
45de c3 16 45				jp .tot 
45e1			 
45e1					 
45e1			 
45e1			 
45e1			; for each char convert to low 
45e1					 
45e1			.totdone: 
45e1					if DEBUG_FORTH_WORDS 
45e1						DMARK "TCd" 
45e1 f5				push af  
45e2 3a f6 45			ld a, (.dmark)  
45e5 32 b4 fe			ld (debug_mark),a  
45e8 3a f7 45			ld a, (.dmark+1)  
45eb 32 b5 fe			ld (debug_mark+1),a  
45ee 3a f8 45			ld a, (.dmark+2)  
45f1 32 b6 fe			ld (debug_mark+2),a  
45f4 18 03			jr .pastdmark  
45f6 ..			.dmark: db "TCd"  
45f9 f1			.pastdmark: pop af  
45fa			endm  
# End of macro DMARK
45fa						CALLMONITOR 
45fa cd c6 18			call break_point_state  
45fd				endm  
# End of macro CALLMONITOR
45fd					endif 
45fd					NEXTW 
45fd c3 e7 22			jp macro_next 
4600				endm 
# End of macro NEXTW
4600			 
4600			.SUBSTR: 
4600				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4600 48				db WORD_SYS_CORE+52             
4601 5e 46			dw .LEFT            
4603 07				db 6 + 1 
4604 .. 00			db "SUBSTR",0              
460b				endm 
# End of macro CWHEAD
460b			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
460b			 
460b					if DEBUG_FORTH_WORDS_KEY 
460b						DMARK "SST" 
460b f5				push af  
460c 3a 20 46			ld a, (.dmark)  
460f 32 b4 fe			ld (debug_mark),a  
4612 3a 21 46			ld a, (.dmark+1)  
4615 32 b5 fe			ld (debug_mark+1),a  
4618 3a 22 46			ld a, (.dmark+2)  
461b 32 b6 fe			ld (debug_mark+2),a  
461e 18 03			jr .pastdmark  
4620 ..			.dmark: db "SST"  
4623 f1			.pastdmark: pop af  
4624			endm  
# End of macro DMARK
4624						CALLMONITOR 
4624 cd c6 18			call break_point_state  
4627				endm  
# End of macro CALLMONITOR
4627					endif 
4627			; TODO check string type 
4627					FORTH_DSP_VALUEHL 
4627 cd 31 21			call macro_dsp_valuehl 
462a				endm 
# End of macro FORTH_DSP_VALUEHL
462a			 
462a e5					push hl      ; string length 
462b			 
462b					FORTH_DSP_POP 
462b cd e9 21			call macro_forth_dsp_pop 
462e				endm 
# End of macro FORTH_DSP_POP
462e			 
462e					FORTH_DSP_VALUEHL 
462e cd 31 21			call macro_dsp_valuehl 
4631				endm 
# End of macro FORTH_DSP_VALUEHL
4631			 
4631 e5					push hl     ; start char 
4632			 
4632					FORTH_DSP_POP 
4632 cd e9 21			call macro_forth_dsp_pop 
4635				endm 
# End of macro FORTH_DSP_POP
4635			 
4635			 
4635					FORTH_DSP_VALUE 
4635 cd 1a 21			call macro_forth_dsp_value 
4638				endm 
# End of macro FORTH_DSP_VALUE
4638			 
4638 d1					pop de    ; get start post offset 
4639			 
4639 19					add hl, de    ; starting offset 
463a			 
463a c1					pop bc 
463b c5					push bc      ; grab size of string 
463c			 
463c e5					push hl    ; save string start  
463d			 
463d 26 00				ld h, 0 
463f 69					ld l, c 
4640 23					inc hl 
4641 23					inc hl 
4642			 
4642 cd 10 14				call malloc 
4645				if DEBUG_FORTH_MALLOC_GUARD 
4645 cc c3 5a				call z,malloc_error 
4648				endif 
4648			 
4648 eb					ex de, hl      ; save malloc area for string copy 
4649 e1					pop hl    ; get back source 
464a c1					pop bc    ; get length of string back 
464b			 
464b d5					push de    ; save malloc area for after we push 
464c ed b0				ldir     ; copy substr 
464e			 
464e			 
464e eb					ex de, hl 
464f 3e 00				ld a, 0 
4651 77					ld (hl), a   ; term substr 
4652			 
4652					 
4652 e1					pop hl    ; get malloc so we can push it 
4653 e5					push hl   ; save so we can free it afterwards 
4654			 
4654 cd a8 1f				call forth_push_str 
4657			 
4657 e1					pop hl 
4658 cd da 14				call free 
465b			 
465b					 
465b					 
465b			 
465b			 
465b					NEXTW 
465b c3 e7 22			jp macro_next 
465e				endm 
# End of macro NEXTW
465e			 
465e			.LEFT: 
465e				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
465e 48				db WORD_SYS_CORE+52             
465f 86 46			dw .RIGHT            
4661 05				db 4 + 1 
4662 .. 00			db "LEFT",0              
4667				endm 
# End of macro CWHEAD
4667			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4667					if DEBUG_FORTH_WORDS_KEY 
4667						DMARK "LEF" 
4667 f5				push af  
4668 3a 7c 46			ld a, (.dmark)  
466b 32 b4 fe			ld (debug_mark),a  
466e 3a 7d 46			ld a, (.dmark+1)  
4671 32 b5 fe			ld (debug_mark+1),a  
4674 3a 7e 46			ld a, (.dmark+2)  
4677 32 b6 fe			ld (debug_mark+2),a  
467a 18 03			jr .pastdmark  
467c ..			.dmark: db "LEF"  
467f f1			.pastdmark: pop af  
4680			endm  
# End of macro DMARK
4680						CALLMONITOR 
4680 cd c6 18			call break_point_state  
4683				endm  
# End of macro CALLMONITOR
4683					endif 
4683			 
4683					NEXTW 
4683 c3 e7 22			jp macro_next 
4686				endm 
# End of macro NEXTW
4686			.RIGHT: 
4686				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4686 48				db WORD_SYS_CORE+52             
4687 af 46			dw .STR2NUM            
4689 06				db 5 + 1 
468a .. 00			db "RIGHT",0              
4690				endm 
# End of macro CWHEAD
4690			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4690					if DEBUG_FORTH_WORDS_KEY 
4690						DMARK "RIG" 
4690 f5				push af  
4691 3a a5 46			ld a, (.dmark)  
4694 32 b4 fe			ld (debug_mark),a  
4697 3a a6 46			ld a, (.dmark+1)  
469a 32 b5 fe			ld (debug_mark+1),a  
469d 3a a7 46			ld a, (.dmark+2)  
46a0 32 b6 fe			ld (debug_mark+2),a  
46a3 18 03			jr .pastdmark  
46a5 ..			.dmark: db "RIG"  
46a8 f1			.pastdmark: pop af  
46a9			endm  
# End of macro DMARK
46a9						CALLMONITOR 
46a9 cd c6 18			call break_point_state  
46ac				endm  
# End of macro CALLMONITOR
46ac					endif 
46ac			 
46ac					NEXTW 
46ac c3 e7 22			jp macro_next 
46af				endm 
# End of macro NEXTW
46af			 
46af			 
46af			.STR2NUM: 
46af				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
46af 48				db WORD_SYS_CORE+52             
46b0 3b 47			dw .NUM2STR            
46b2 08				db 7 + 1 
46b3 .. 00			db "STR2NUM",0              
46bb				endm 
# End of macro CWHEAD
46bb			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
46bb			 
46bb			 
46bb			; TODO STR type check to do 
46bb					if DEBUG_FORTH_WORDS_KEY 
46bb						DMARK "S2N" 
46bb f5				push af  
46bc 3a d0 46			ld a, (.dmark)  
46bf 32 b4 fe			ld (debug_mark),a  
46c2 3a d1 46			ld a, (.dmark+1)  
46c5 32 b5 fe			ld (debug_mark+1),a  
46c8 3a d2 46			ld a, (.dmark+2)  
46cb 32 b6 fe			ld (debug_mark+2),a  
46ce 18 03			jr .pastdmark  
46d0 ..			.dmark: db "S2N"  
46d3 f1			.pastdmark: pop af  
46d4			endm  
# End of macro DMARK
46d4						CALLMONITOR 
46d4 cd c6 18			call break_point_state  
46d7				endm  
# End of macro CALLMONITOR
46d7					endif 
46d7			 
46d7					;FORTH_DSP 
46d7					FORTH_DSP_VALUE 
46d7 cd 1a 21			call macro_forth_dsp_value 
46da				endm 
# End of macro FORTH_DSP_VALUE
46da					;inc hl 
46da			 
46da eb					ex de, hl 
46db					if DEBUG_FORTH_WORDS 
46db						DMARK "S2a" 
46db f5				push af  
46dc 3a f0 46			ld a, (.dmark)  
46df 32 b4 fe			ld (debug_mark),a  
46e2 3a f1 46			ld a, (.dmark+1)  
46e5 32 b5 fe			ld (debug_mark+1),a  
46e8 3a f2 46			ld a, (.dmark+2)  
46eb 32 b6 fe			ld (debug_mark+2),a  
46ee 18 03			jr .pastdmark  
46f0 ..			.dmark: db "S2a"  
46f3 f1			.pastdmark: pop af  
46f4			endm  
# End of macro DMARK
46f4						CALLMONITOR 
46f4 cd c6 18			call break_point_state  
46f7				endm  
# End of macro CALLMONITOR
46f7					endif 
46f7 cd 3e 13				call string_to_uint16 
46fa			 
46fa					if DEBUG_FORTH_WORDS 
46fa						DMARK "S2b" 
46fa f5				push af  
46fb 3a 0f 47			ld a, (.dmark)  
46fe 32 b4 fe			ld (debug_mark),a  
4701 3a 10 47			ld a, (.dmark+1)  
4704 32 b5 fe			ld (debug_mark+1),a  
4707 3a 11 47			ld a, (.dmark+2)  
470a 32 b6 fe			ld (debug_mark+2),a  
470d 18 03			jr .pastdmark  
470f ..			.dmark: db "S2b"  
4712 f1			.pastdmark: pop af  
4713			endm  
# End of macro DMARK
4713						CALLMONITOR 
4713 cd c6 18			call break_point_state  
4716				endm  
# End of macro CALLMONITOR
4716					endif 
4716			;		push hl 
4716					FORTH_DSP_POP 
4716 cd e9 21			call macro_forth_dsp_pop 
4719				endm 
# End of macro FORTH_DSP_POP
4719			;		pop hl 
4719					 
4719					if DEBUG_FORTH_WORDS 
4719						DMARK "S2b" 
4719 f5				push af  
471a 3a 2e 47			ld a, (.dmark)  
471d 32 b4 fe			ld (debug_mark),a  
4720 3a 2f 47			ld a, (.dmark+1)  
4723 32 b5 fe			ld (debug_mark+1),a  
4726 3a 30 47			ld a, (.dmark+2)  
4729 32 b6 fe			ld (debug_mark+2),a  
472c 18 03			jr .pastdmark  
472e ..			.dmark: db "S2b"  
4731 f1			.pastdmark: pop af  
4732			endm  
# End of macro DMARK
4732						CALLMONITOR 
4732 cd c6 18			call break_point_state  
4735				endm  
# End of macro CALLMONITOR
4735					endif 
4735 cd 3a 1f				call forth_push_numhl	 
4738			 
4738				 
4738				       NEXTW 
4738 c3 e7 22			jp macro_next 
473b				endm 
# End of macro NEXTW
473b			.NUM2STR: 
473b				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
473b 48				db WORD_SYS_CORE+52             
473c 4a 47			dw .CONCAT            
473e 08				db 7 + 1 
473f .. 00			db "NUM2STR",0              
4747				endm 
# End of macro CWHEAD
4747			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4747			 
4747			;		; malloc a string to target 
4747			;		ld hl, 10     ; TODO max string size should be fine 
4747			;		call malloc 
4747			;		push hl    ; save malloc location 
4747			; 
4747			; 
4747			;; TODO check int type 
4747			;		FORTH_DSP_VALUEHL 
4747			;		ld a, l 
4747			;		call DispAToASCII   
4747			;;TODO need to chage above call to dump into string 
4747			; 
4747			; 
4747			 
4747				       NEXTW 
4747 c3 e7 22			jp macro_next 
474a				endm 
# End of macro NEXTW
474a			 
474a			.CONCAT: 
474a				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
474a 48				db WORD_SYS_CORE+52             
474b fd 47			dw .FIND            
474d 07				db 6 + 1 
474e .. 00			db "CONCAT",0              
4755				endm 
# End of macro CWHEAD
4755			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4755			 
4755			; TODO check string type 
4755			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4755			 
4755					if DEBUG_FORTH_WORDS_KEY 
4755						DMARK "CON" 
4755 f5				push af  
4756 3a 6a 47			ld a, (.dmark)  
4759 32 b4 fe			ld (debug_mark),a  
475c 3a 6b 47			ld a, (.dmark+1)  
475f 32 b5 fe			ld (debug_mark+1),a  
4762 3a 6c 47			ld a, (.dmark+2)  
4765 32 b6 fe			ld (debug_mark+2),a  
4768 18 03			jr .pastdmark  
476a ..			.dmark: db "CON"  
476d f1			.pastdmark: pop af  
476e			endm  
# End of macro DMARK
476e						CALLMONITOR 
476e cd c6 18			call break_point_state  
4771				endm  
# End of macro CALLMONITOR
4771					endif 
4771			 
4771			 
4771					FORTH_DSP_VALUE 
4771 cd 1a 21			call macro_forth_dsp_value 
4774				endm 
# End of macro FORTH_DSP_VALUE
4774 e5					push hl   ; s2 
4775			 
4775					FORTH_DSP_POP 
4775 cd e9 21			call macro_forth_dsp_pop 
4778				endm 
# End of macro FORTH_DSP_POP
4778			 
4778					FORTH_DSP_VALUE 
4778 cd 1a 21			call macro_forth_dsp_value 
477b				endm 
# End of macro FORTH_DSP_VALUE
477b			 
477b e5					push hl   ; s1 
477c			 
477c					FORTH_DSP_POP 
477c cd e9 21			call macro_forth_dsp_pop 
477f				endm 
# End of macro FORTH_DSP_POP
477f					 
477f			 
477f					; copy s1 
477f			 
477f				 
477f					; save ptr 
477f e1					pop hl  
4780 e5					push hl 
4781 3e 00				ld a, 0 
4783 cd b2 13				call strlent 
4786					;inc hl    ; zer0 
4786 06 00				ld b, 0 
4788 4d					ld c, l 
4789 e1					pop hl		 
478a 11 4e f3				ld de, scratch	 
478d					if DEBUG_FORTH_WORDS 
478d						DMARK "CO1" 
478d f5				push af  
478e 3a a2 47			ld a, (.dmark)  
4791 32 b4 fe			ld (debug_mark),a  
4794 3a a3 47			ld a, (.dmark+1)  
4797 32 b5 fe			ld (debug_mark+1),a  
479a 3a a4 47			ld a, (.dmark+2)  
479d 32 b6 fe			ld (debug_mark+2),a  
47a0 18 03			jr .pastdmark  
47a2 ..			.dmark: db "CO1"  
47a5 f1			.pastdmark: pop af  
47a6			endm  
# End of macro DMARK
47a6						CALLMONITOR 
47a6 cd c6 18			call break_point_state  
47a9				endm  
# End of macro CALLMONITOR
47a9					endif 
47a9 ed b0				ldir 
47ab			 
47ab e1					pop hl 
47ac e5					push hl 
47ad d5					push de 
47ae			 
47ae			 
47ae 3e 00				ld a, 0 
47b0 cd b2 13				call strlent 
47b3 23					inc hl    ; zer0 
47b4 23					inc hl 
47b5 06 00				ld b, 0 
47b7 4d					ld c, l 
47b8 d1					pop de 
47b9 e1					pop hl		 
47ba					if DEBUG_FORTH_WORDS 
47ba						DMARK "CO2" 
47ba f5				push af  
47bb 3a cf 47			ld a, (.dmark)  
47be 32 b4 fe			ld (debug_mark),a  
47c1 3a d0 47			ld a, (.dmark+1)  
47c4 32 b5 fe			ld (debug_mark+1),a  
47c7 3a d1 47			ld a, (.dmark+2)  
47ca 32 b6 fe			ld (debug_mark+2),a  
47cd 18 03			jr .pastdmark  
47cf ..			.dmark: db "CO2"  
47d2 f1			.pastdmark: pop af  
47d3			endm  
# End of macro DMARK
47d3						CALLMONITOR 
47d3 cd c6 18			call break_point_state  
47d6				endm  
# End of macro CALLMONITOR
47d6					endif 
47d6 ed b0				ldir 
47d8			 
47d8			 
47d8			 
47d8 21 4e f3				ld hl, scratch 
47db					if DEBUG_FORTH_WORDS 
47db						DMARK "CO5" 
47db f5				push af  
47dc 3a f0 47			ld a, (.dmark)  
47df 32 b4 fe			ld (debug_mark),a  
47e2 3a f1 47			ld a, (.dmark+1)  
47e5 32 b5 fe			ld (debug_mark+1),a  
47e8 3a f2 47			ld a, (.dmark+2)  
47eb 32 b6 fe			ld (debug_mark+2),a  
47ee 18 03			jr .pastdmark  
47f0 ..			.dmark: db "CO5"  
47f3 f1			.pastdmark: pop af  
47f4			endm  
# End of macro DMARK
47f4						CALLMONITOR 
47f4 cd c6 18			call break_point_state  
47f7				endm  
# End of macro CALLMONITOR
47f7					endif 
47f7			 
47f7 cd a8 1f				call forth_push_str 
47fa			 
47fa			 
47fa			 
47fa			 
47fa				       NEXTW 
47fa c3 e7 22			jp macro_next 
47fd				endm 
# End of macro NEXTW
47fd			 
47fd			 
47fd			.FIND: 
47fd				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
47fd 4b				db WORD_SYS_CORE+55             
47fe bb 48			dw .LEN            
4800 05				db 4 + 1 
4801 .. 00			db "FIND",0              
4806				endm 
# End of macro CWHEAD
4806			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4806			 
4806					if DEBUG_FORTH_WORDS_KEY 
4806						DMARK "FND" 
4806 f5				push af  
4807 3a 1b 48			ld a, (.dmark)  
480a 32 b4 fe			ld (debug_mark),a  
480d 3a 1c 48			ld a, (.dmark+1)  
4810 32 b5 fe			ld (debug_mark+1),a  
4813 3a 1d 48			ld a, (.dmark+2)  
4816 32 b6 fe			ld (debug_mark+2),a  
4819 18 03			jr .pastdmark  
481b ..			.dmark: db "FND"  
481e f1			.pastdmark: pop af  
481f			endm  
# End of macro DMARK
481f						CALLMONITOR 
481f cd c6 18			call break_point_state  
4822				endm  
# End of macro CALLMONITOR
4822					endif 
4822			 
4822			; TODO check string type 
4822					FORTH_DSP_VALUE 
4822 cd 1a 21			call macro_forth_dsp_value 
4825				endm 
# End of macro FORTH_DSP_VALUE
4825			 
4825 e5					push hl    
4826 7e					ld a,(hl)    ; char to find   
4827			; TODO change char to substr 
4827			 
4827 f5					push af 
4828					 
4828			 
4828			 
4828					if DEBUG_FORTH_WORDS 
4828						DMARK "FN1" 
4828 f5				push af  
4829 3a 3d 48			ld a, (.dmark)  
482c 32 b4 fe			ld (debug_mark),a  
482f 3a 3e 48			ld a, (.dmark+1)  
4832 32 b5 fe			ld (debug_mark+1),a  
4835 3a 3f 48			ld a, (.dmark+2)  
4838 32 b6 fe			ld (debug_mark+2),a  
483b 18 03			jr .pastdmark  
483d ..			.dmark: db "FN1"  
4840 f1			.pastdmark: pop af  
4841			endm  
# End of macro DMARK
4841						CALLMONITOR 
4841 cd c6 18			call break_point_state  
4844				endm  
# End of macro CALLMONITOR
4844					endif 
4844			 
4844					FORTH_DSP_POP 
4844 cd e9 21			call macro_forth_dsp_pop 
4847				endm 
# End of macro FORTH_DSP_POP
4847			 
4847					; string to search 
4847			 
4847					FORTH_DSP_VALUE 
4847 cd 1a 21			call macro_forth_dsp_value 
484a				endm 
# End of macro FORTH_DSP_VALUE
484a			 
484a d1					pop de  ; d is char to find  
484b			 
484b					if DEBUG_FORTH_WORDS 
484b						DMARK "FN2" 
484b f5				push af  
484c 3a 60 48			ld a, (.dmark)  
484f 32 b4 fe			ld (debug_mark),a  
4852 3a 61 48			ld a, (.dmark+1)  
4855 32 b5 fe			ld (debug_mark+1),a  
4858 3a 62 48			ld a, (.dmark+2)  
485b 32 b6 fe			ld (debug_mark+2),a  
485e 18 03			jr .pastdmark  
4860 ..			.dmark: db "FN2"  
4863 f1			.pastdmark: pop af  
4864			endm  
# End of macro DMARK
4864						CALLMONITOR 
4864 cd c6 18			call break_point_state  
4867				endm  
# End of macro CALLMONITOR
4867					endif 
4867					 
4867 01 00 00				ld bc, 0 
486a 7e			.findchar:      ld a,(hl) 
486b fe 00				cp 0   		 
486d 28 27				jr z, .finddone     
486f ba					cp d 
4870 28 20				jr z, .foundchar 
4872 03					inc bc 
4873 23					inc hl 
4874					if DEBUG_FORTH_WORDS 
4874						DMARK "FN3" 
4874 f5				push af  
4875 3a 89 48			ld a, (.dmark)  
4878 32 b4 fe			ld (debug_mark),a  
487b 3a 8a 48			ld a, (.dmark+1)  
487e 32 b5 fe			ld (debug_mark+1),a  
4881 3a 8b 48			ld a, (.dmark+2)  
4884 32 b6 fe			ld (debug_mark+2),a  
4887 18 03			jr .pastdmark  
4889 ..			.dmark: db "FN3"  
488c f1			.pastdmark: pop af  
488d			endm  
# End of macro DMARK
488d						CALLMONITOR 
488d cd c6 18			call break_point_state  
4890				endm  
# End of macro CALLMONITOR
4890					endif 
4890 18 d8				jr .findchar 
4892			 
4892			 
4892 c5			.foundchar:	push bc 
4893 e1					pop hl 
4894 18 03				jr .findexit 
4896			 
4896			 
4896							 
4896			 
4896			.finddone:     ; got to end of string with no find 
4896 21 00 00				ld hl, 0 
4899			.findexit: 
4899			 
4899					if DEBUG_FORTH_WORDS 
4899						DMARK "FNd" 
4899 f5				push af  
489a 3a ae 48			ld a, (.dmark)  
489d 32 b4 fe			ld (debug_mark),a  
48a0 3a af 48			ld a, (.dmark+1)  
48a3 32 b5 fe			ld (debug_mark+1),a  
48a6 3a b0 48			ld a, (.dmark+2)  
48a9 32 b6 fe			ld (debug_mark+2),a  
48ac 18 03			jr .pastdmark  
48ae ..			.dmark: db "FNd"  
48b1 f1			.pastdmark: pop af  
48b2			endm  
# End of macro DMARK
48b2						CALLMONITOR 
48b2 cd c6 18			call break_point_state  
48b5				endm  
# End of macro CALLMONITOR
48b5					endif 
48b5 cd 3a 1f			call forth_push_numhl 
48b8			 
48b8				       NEXTW 
48b8 c3 e7 22			jp macro_next 
48bb				endm 
# End of macro NEXTW
48bb			 
48bb			.LEN: 
48bb				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
48bb 4c				db WORD_SYS_CORE+56             
48bc 25 49			dw .ASC            
48be 06				db 5 + 1 
48bf .. 00			db "COUNT",0              
48c5				endm 
# End of macro CWHEAD
48c5			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
48c5			 
48c5					if DEBUG_FORTH_WORDS_KEY 
48c5						DMARK "CNT" 
48c5 f5				push af  
48c6 3a da 48			ld a, (.dmark)  
48c9 32 b4 fe			ld (debug_mark),a  
48cc 3a db 48			ld a, (.dmark+1)  
48cf 32 b5 fe			ld (debug_mark+1),a  
48d2 3a dc 48			ld a, (.dmark+2)  
48d5 32 b6 fe			ld (debug_mark+2),a  
48d8 18 03			jr .pastdmark  
48da ..			.dmark: db "CNT"  
48dd f1			.pastdmark: pop af  
48de			endm  
# End of macro DMARK
48de						CALLMONITOR 
48de cd c6 18			call break_point_state  
48e1				endm  
# End of macro CALLMONITOR
48e1					endif 
48e1			; TODO check string type 
48e1					FORTH_DSP_VALUE 
48e1 cd 1a 21			call macro_forth_dsp_value 
48e4				endm 
# End of macro FORTH_DSP_VALUE
48e4			 
48e4			 
48e4					if DEBUG_FORTH_WORDS 
48e4						DMARK "CN?" 
48e4 f5				push af  
48e5 3a f9 48			ld a, (.dmark)  
48e8 32 b4 fe			ld (debug_mark),a  
48eb 3a fa 48			ld a, (.dmark+1)  
48ee 32 b5 fe			ld (debug_mark+1),a  
48f1 3a fb 48			ld a, (.dmark+2)  
48f4 32 b6 fe			ld (debug_mark+2),a  
48f7 18 03			jr .pastdmark  
48f9 ..			.dmark: db "CN?"  
48fc f1			.pastdmark: pop af  
48fd			endm  
# End of macro DMARK
48fd						CALLMONITOR 
48fd cd c6 18			call break_point_state  
4900				endm  
# End of macro CALLMONITOR
4900					endif 
4900 cd a7 13				call strlenz 
4903					if DEBUG_FORTH_WORDS 
4903						DMARK "CNl" 
4903 f5				push af  
4904 3a 18 49			ld a, (.dmark)  
4907 32 b4 fe			ld (debug_mark),a  
490a 3a 19 49			ld a, (.dmark+1)  
490d 32 b5 fe			ld (debug_mark+1),a  
4910 3a 1a 49			ld a, (.dmark+2)  
4913 32 b6 fe			ld (debug_mark+2),a  
4916 18 03			jr .pastdmark  
4918 ..			.dmark: db "CNl"  
491b f1			.pastdmark: pop af  
491c			endm  
# End of macro DMARK
491c						CALLMONITOR 
491c cd c6 18			call break_point_state  
491f				endm  
# End of macro CALLMONITOR
491f					endif 
491f			 
491f cd 3a 1f				call forth_push_numhl 
4922			 
4922			 
4922			 
4922				       NEXTW 
4922 c3 e7 22			jp macro_next 
4925				endm 
# End of macro NEXTW
4925			.ASC: 
4925				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4925 4d				db WORD_SYS_CORE+57             
4926 93 49			dw .CHR            
4928 04				db 3 + 1 
4929 .. 00			db "ASC",0              
492d				endm 
# End of macro CWHEAD
492d			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
492d					if DEBUG_FORTH_WORDS_KEY 
492d						DMARK "ASC" 
492d f5				push af  
492e 3a 42 49			ld a, (.dmark)  
4931 32 b4 fe			ld (debug_mark),a  
4934 3a 43 49			ld a, (.dmark+1)  
4937 32 b5 fe			ld (debug_mark+1),a  
493a 3a 44 49			ld a, (.dmark+2)  
493d 32 b6 fe			ld (debug_mark+2),a  
4940 18 03			jr .pastdmark  
4942 ..			.dmark: db "ASC"  
4945 f1			.pastdmark: pop af  
4946			endm  
# End of macro DMARK
4946						CALLMONITOR 
4946 cd c6 18			call break_point_state  
4949				endm  
# End of macro CALLMONITOR
4949					endif 
4949					FORTH_DSP_VALUE 
4949 cd 1a 21			call macro_forth_dsp_value 
494c				endm 
# End of macro FORTH_DSP_VALUE
494c					;v5 FORTH_DSP_VALUE 
494c			;		inc hl      ; now at start of numeric as string 
494c			 
494c e5					push hl 
494d			 
494d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
494d cd e9 21			call macro_forth_dsp_pop 
4950				endm 
# End of macro FORTH_DSP_POP
4950			 
4950 e1					pop hl 
4951			 
4951					if DEBUG_FORTH_WORDS 
4951						DMARK "AS1" 
4951 f5				push af  
4952 3a 66 49			ld a, (.dmark)  
4955 32 b4 fe			ld (debug_mark),a  
4958 3a 67 49			ld a, (.dmark+1)  
495b 32 b5 fe			ld (debug_mark+1),a  
495e 3a 68 49			ld a, (.dmark+2)  
4961 32 b6 fe			ld (debug_mark+2),a  
4964 18 03			jr .pastdmark  
4966 ..			.dmark: db "AS1"  
4969 f1			.pastdmark: pop af  
496a			endm  
# End of macro DMARK
496a						CALLMONITOR 
496a cd c6 18			call break_point_state  
496d				endm  
# End of macro CALLMONITOR
496d					endif 
496d					; push the content of a onto the stack as a value 
496d			 
496d 7e					ld a,(hl)   ; get char 
496e 26 00				ld h,0 
4970 6f					ld l,a 
4971					if DEBUG_FORTH_WORDS 
4971						DMARK "AS2" 
4971 f5				push af  
4972 3a 86 49			ld a, (.dmark)  
4975 32 b4 fe			ld (debug_mark),a  
4978 3a 87 49			ld a, (.dmark+1)  
497b 32 b5 fe			ld (debug_mark+1),a  
497e 3a 88 49			ld a, (.dmark+2)  
4981 32 b6 fe			ld (debug_mark+2),a  
4984 18 03			jr .pastdmark  
4986 ..			.dmark: db "AS2"  
4989 f1			.pastdmark: pop af  
498a			endm  
# End of macro DMARK
498a						CALLMONITOR 
498a cd c6 18			call break_point_state  
498d				endm  
# End of macro CALLMONITOR
498d					endif 
498d cd 3a 1f				call forth_push_numhl 
4990			 
4990				       NEXTW 
4990 c3 e7 22			jp macro_next 
4993				endm 
# End of macro NEXTW
4993			 
4993			.CHR: 
4993				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4993 4d				db WORD_SYS_CORE+57             
4994 cf 49			dw .ENDSTR            
4996 04				db 3 + 1 
4997 .. 00			db "CHR",0              
499b				endm 
# End of macro CWHEAD
499b			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
499b					if DEBUG_FORTH_WORDS_KEY 
499b						DMARK "CHR" 
499b f5				push af  
499c 3a b0 49			ld a, (.dmark)  
499f 32 b4 fe			ld (debug_mark),a  
49a2 3a b1 49			ld a, (.dmark+1)  
49a5 32 b5 fe			ld (debug_mark+1),a  
49a8 3a b2 49			ld a, (.dmark+2)  
49ab 32 b6 fe			ld (debug_mark+2),a  
49ae 18 03			jr .pastdmark  
49b0 ..			.dmark: db "CHR"  
49b3 f1			.pastdmark: pop af  
49b4			endm  
# End of macro DMARK
49b4						CALLMONITOR 
49b4 cd c6 18			call break_point_state  
49b7				endm  
# End of macro CALLMONITOR
49b7					endif 
49b7					FORTH_DSP_VALUEHL 
49b7 cd 31 21			call macro_dsp_valuehl 
49ba				endm 
# End of macro FORTH_DSP_VALUEHL
49ba			 
49ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49ba cd e9 21			call macro_forth_dsp_pop 
49bd				endm 
# End of macro FORTH_DSP_POP
49bd			 
49bd					; save asci byte as a zero term string and push string 
49bd			 
49bd 7d					ld a,l 
49be 32 4e f3				ld (scratch), a 
49c1			 
49c1 3e 00				ld a, 0 
49c3 32 4f f3				ld (scratch+1), a 
49c6			 
49c6 21 4e f3				ld hl, scratch 
49c9 cd a8 1f				call forth_push_str 
49cc			 
49cc			 
49cc				       NEXTW 
49cc c3 e7 22			jp macro_next 
49cf				endm 
# End of macro NEXTW
49cf			 
49cf			 
49cf			 
49cf			 
49cf			.ENDSTR: 
49cf			; eof 
49cf			 
# End of file forth_words_str.asm
49cf			include "forth_words_key.asm" 
49cf			 
49cf			; | ## Keyboard Words 
49cf			 
49cf			.KEY: 
49cf				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
49cf 3e				db WORD_SYS_CORE+42             
49d0 ff 49			dw .WAITK            
49d2 04				db 3 + 1 
49d3 .. 00			db "KEY",0              
49d7				endm 
# End of macro CWHEAD
49d7			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
49d7			 
49d7					if DEBUG_FORTH_WORDS_KEY 
49d7						DMARK "KEY" 
49d7 f5				push af  
49d8 3a ec 49			ld a, (.dmark)  
49db 32 b4 fe			ld (debug_mark),a  
49de 3a ed 49			ld a, (.dmark+1)  
49e1 32 b5 fe			ld (debug_mark+1),a  
49e4 3a ee 49			ld a, (.dmark+2)  
49e7 32 b6 fe			ld (debug_mark+2),a  
49ea 18 03			jr .pastdmark  
49ec ..			.dmark: db "KEY"  
49ef f1			.pastdmark: pop af  
49f0			endm  
# End of macro DMARK
49f0						CALLMONITOR 
49f0 cd c6 18			call break_point_state  
49f3				endm  
# End of macro CALLMONITOR
49f3					endif 
49f3			; TODO currently waits 
49f3 cd 6c 74				call cin 
49f6					;call cin_wait 
49f6 6f					ld l, a 
49f7 26 00				ld h, 0 
49f9 cd 3a 1f				call forth_push_numhl 
49fc					NEXTW 
49fc c3 e7 22			jp macro_next 
49ff				endm 
# End of macro NEXTW
49ff			.WAITK: 
49ff				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
49ff 3f				db WORD_SYS_CORE+43             
4a00 31 4a			dw .ACCEPT            
4a02 06				db 5 + 1 
4a03 .. 00			db "WAITK",0              
4a09				endm 
# End of macro CWHEAD
4a09			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4a09					if DEBUG_FORTH_WORDS_KEY 
4a09						DMARK "WAI" 
4a09 f5				push af  
4a0a 3a 1e 4a			ld a, (.dmark)  
4a0d 32 b4 fe			ld (debug_mark),a  
4a10 3a 1f 4a			ld a, (.dmark+1)  
4a13 32 b5 fe			ld (debug_mark+1),a  
4a16 3a 20 4a			ld a, (.dmark+2)  
4a19 32 b6 fe			ld (debug_mark+2),a  
4a1c 18 03			jr .pastdmark  
4a1e ..			.dmark: db "WAI"  
4a21 f1			.pastdmark: pop af  
4a22			endm  
# End of macro DMARK
4a22						CALLMONITOR 
4a22 cd c6 18			call break_point_state  
4a25				endm  
# End of macro CALLMONITOR
4a25					endif 
4a25 cd 5b 74				call cin_wait 
4a28 6f					ld l, a 
4a29 26 00				ld h, 0 
4a2b cd 3a 1f				call forth_push_numhl 
4a2e					NEXTW 
4a2e c3 e7 22			jp macro_next 
4a31				endm 
# End of macro NEXTW
4a31			.ACCEPT: 
4a31				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4a31 40				db WORD_SYS_CORE+44             
4a32 8f 4a			dw .EDIT            
4a34 07				db 6 + 1 
4a35 .. 00			db "ACCEPT",0              
4a3c				endm 
# End of macro CWHEAD
4a3c			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4a3c					; TODO crashes on push 
4a3c					if DEBUG_FORTH_WORDS_KEY 
4a3c						DMARK "ACC" 
4a3c f5				push af  
4a3d 3a 51 4a			ld a, (.dmark)  
4a40 32 b4 fe			ld (debug_mark),a  
4a43 3a 52 4a			ld a, (.dmark+1)  
4a46 32 b5 fe			ld (debug_mark+1),a  
4a49 3a 53 4a			ld a, (.dmark+2)  
4a4c 32 b6 fe			ld (debug_mark+2),a  
4a4f 18 03			jr .pastdmark  
4a51 ..			.dmark: db "ACC"  
4a54 f1			.pastdmark: pop af  
4a55			endm  
# End of macro DMARK
4a55						CALLMONITOR 
4a55 cd c6 18			call break_point_state  
4a58				endm  
# End of macro CALLMONITOR
4a58					endif 
4a58 21 4c f5				ld hl, os_input 
4a5b 3e 00				ld a, 0 
4a5d 77					ld (hl),a 
4a5e 3a eb fb				ld a,(f_cursor_ptr) 
4a61 16 64				ld d, 100 
4a63 0e 00				ld c, 0 
4a65 1e 28				ld e, 40 
4a67 cd 76 0f				call input_str 
4a6a					; TODO perhaps do a type check and wrap in quotes if not a number 
4a6a 21 4c f5				ld hl, os_input 
4a6d					if DEBUG_FORTH_WORDS 
4a6d						DMARK "AC1" 
4a6d f5				push af  
4a6e 3a 82 4a			ld a, (.dmark)  
4a71 32 b4 fe			ld (debug_mark),a  
4a74 3a 83 4a			ld a, (.dmark+1)  
4a77 32 b5 fe			ld (debug_mark+1),a  
4a7a 3a 84 4a			ld a, (.dmark+2)  
4a7d 32 b6 fe			ld (debug_mark+2),a  
4a80 18 03			jr .pastdmark  
4a82 ..			.dmark: db "AC1"  
4a85 f1			.pastdmark: pop af  
4a86			endm  
# End of macro DMARK
4a86						CALLMONITOR 
4a86 cd c6 18			call break_point_state  
4a89				endm  
# End of macro CALLMONITOR
4a89					endif 
4a89 cd a8 1f				call forth_push_str 
4a8c					NEXTW 
4a8c c3 e7 22			jp macro_next 
4a8f				endm 
# End of macro NEXTW
4a8f			 
4a8f			.EDIT: 
4a8f				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4a8f 40				db WORD_SYS_CORE+44             
4a90 31 4b			dw .DEDIT            
4a92 05				db 4 + 1 
4a93 .. 00			db "EDIT",0              
4a98				endm 
# End of macro CWHEAD
4a98			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4a98			 
4a98					; TODO does not copy from stack 
4a98					if DEBUG_FORTH_WORDS_KEY 
4a98						DMARK "EDT" 
4a98 f5				push af  
4a99 3a ad 4a			ld a, (.dmark)  
4a9c 32 b4 fe			ld (debug_mark),a  
4a9f 3a ae 4a			ld a, (.dmark+1)  
4aa2 32 b5 fe			ld (debug_mark+1),a  
4aa5 3a af 4a			ld a, (.dmark+2)  
4aa8 32 b6 fe			ld (debug_mark+2),a  
4aab 18 03			jr .pastdmark  
4aad ..			.dmark: db "EDT"  
4ab0 f1			.pastdmark: pop af  
4ab1			endm  
# End of macro DMARK
4ab1						CALLMONITOR 
4ab1 cd c6 18			call break_point_state  
4ab4				endm  
# End of macro CALLMONITOR
4ab4					endif 
4ab4			 
4ab4					;FORTH_DSP 
4ab4					FORTH_DSP_VALUEHL 
4ab4 cd 31 21			call macro_dsp_valuehl 
4ab7				endm 
# End of macro FORTH_DSP_VALUEHL
4ab7			;		inc hl    ; TODO do type check 
4ab7			 
4ab7			;		call get_word_hl 
4ab7 e5					push hl 
4ab8					if DEBUG_FORTH_WORDS 
4ab8						DMARK "EDp" 
4ab8 f5				push af  
4ab9 3a cd 4a			ld a, (.dmark)  
4abc 32 b4 fe			ld (debug_mark),a  
4abf 3a ce 4a			ld a, (.dmark+1)  
4ac2 32 b5 fe			ld (debug_mark+1),a  
4ac5 3a cf 4a			ld a, (.dmark+2)  
4ac8 32 b6 fe			ld (debug_mark+2),a  
4acb 18 03			jr .pastdmark  
4acd ..			.dmark: db "EDp"  
4ad0 f1			.pastdmark: pop af  
4ad1			endm  
# End of macro DMARK
4ad1						CALLMONITOR 
4ad1 cd c6 18			call break_point_state  
4ad4				endm  
# End of macro CALLMONITOR
4ad4					endif 
4ad4				;	ld a, 0 
4ad4 cd a7 13				call strlenz 
4ad7 23					inc hl 
4ad8			 
4ad8 06 00				ld b, 0 
4ada 4d					ld c, l 
4adb			 
4adb e1					pop hl 
4adc 11 4c f5				ld de, os_input 
4adf					if DEBUG_FORTH_WORDS_KEY 
4adf						DMARK "EDc" 
4adf f5				push af  
4ae0 3a f4 4a			ld a, (.dmark)  
4ae3 32 b4 fe			ld (debug_mark),a  
4ae6 3a f5 4a			ld a, (.dmark+1)  
4ae9 32 b5 fe			ld (debug_mark+1),a  
4aec 3a f6 4a			ld a, (.dmark+2)  
4aef 32 b6 fe			ld (debug_mark+2),a  
4af2 18 03			jr .pastdmark  
4af4 ..			.dmark: db "EDc"  
4af7 f1			.pastdmark: pop af  
4af8			endm  
# End of macro DMARK
4af8						CALLMONITOR 
4af8 cd c6 18			call break_point_state  
4afb				endm  
# End of macro CALLMONITOR
4afb					endif 
4afb ed b0				ldir 
4afd			 
4afd			 
4afd 21 4c f5				ld hl, os_input 
4b00					;ld a, 0 
4b00					;ld (hl),a 
4b00 3a eb fb				ld a,(f_cursor_ptr) 
4b03 16 64				ld d, 100 
4b05 0e 00				ld c, 0 
4b07 1e 28				ld e, 40 
4b09 cd 76 0f				call input_str 
4b0c					; TODO perhaps do a type check and wrap in quotes if not a number 
4b0c 21 4c f5				ld hl, os_input 
4b0f					if DEBUG_FORTH_WORDS 
4b0f						DMARK "ED1" 
4b0f f5				push af  
4b10 3a 24 4b			ld a, (.dmark)  
4b13 32 b4 fe			ld (debug_mark),a  
4b16 3a 25 4b			ld a, (.dmark+1)  
4b19 32 b5 fe			ld (debug_mark+1),a  
4b1c 3a 26 4b			ld a, (.dmark+2)  
4b1f 32 b6 fe			ld (debug_mark+2),a  
4b22 18 03			jr .pastdmark  
4b24 ..			.dmark: db "ED1"  
4b27 f1			.pastdmark: pop af  
4b28			endm  
# End of macro DMARK
4b28						CALLMONITOR 
4b28 cd c6 18			call break_point_state  
4b2b				endm  
# End of macro CALLMONITOR
4b2b					endif 
4b2b cd a8 1f				call forth_push_str 
4b2e					NEXTW 
4b2e c3 e7 22			jp macro_next 
4b31				endm 
# End of macro NEXTW
4b31			 
4b31			.DEDIT: 
4b31				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4b31 40				db WORD_SYS_CORE+44             
4b32 93 4b			dw .ENDKEY            
4b34 06				db 5 + 1 
4b35 .. 00			db "DEDIT",0              
4b3b				endm 
# End of macro CWHEAD
4b3b			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4b3b			 
4b3b					; TODO does not copy from stack 
4b3b					if DEBUG_FORTH_WORDS_KEY 
4b3b						DMARK "DED" 
4b3b f5				push af  
4b3c 3a 50 4b			ld a, (.dmark)  
4b3f 32 b4 fe			ld (debug_mark),a  
4b42 3a 51 4b			ld a, (.dmark+1)  
4b45 32 b5 fe			ld (debug_mark+1),a  
4b48 3a 52 4b			ld a, (.dmark+2)  
4b4b 32 b6 fe			ld (debug_mark+2),a  
4b4e 18 03			jr .pastdmark  
4b50 ..			.dmark: db "DED"  
4b53 f1			.pastdmark: pop af  
4b54			endm  
# End of macro DMARK
4b54						CALLMONITOR 
4b54 cd c6 18			call break_point_state  
4b57				endm  
# End of macro CALLMONITOR
4b57					endif 
4b57			 
4b57					;FORTH_DSP 
4b57					FORTH_DSP_VALUEHL 
4b57 cd 31 21			call macro_dsp_valuehl 
4b5a				endm 
# End of macro FORTH_DSP_VALUEHL
4b5a			;		inc hl    ; TODO do type check 
4b5a			 
4b5a			;		call get_word_hl 
4b5a e5					push hl 
4b5b e5					push hl 
4b5c					FORTH_DSP_POP 
4b5c cd e9 21			call macro_forth_dsp_pop 
4b5f				endm 
# End of macro FORTH_DSP_POP
4b5f e1					pop hl 
4b60					if DEBUG_FORTH_WORDS 
4b60						DMARK "EDp" 
4b60 f5				push af  
4b61 3a 75 4b			ld a, (.dmark)  
4b64 32 b4 fe			ld (debug_mark),a  
4b67 3a 76 4b			ld a, (.dmark+1)  
4b6a 32 b5 fe			ld (debug_mark+1),a  
4b6d 3a 77 4b			ld a, (.dmark+2)  
4b70 32 b6 fe			ld (debug_mark+2),a  
4b73 18 03			jr .pastdmark  
4b75 ..			.dmark: db "EDp"  
4b78 f1			.pastdmark: pop af  
4b79			endm  
# End of macro DMARK
4b79						CALLMONITOR 
4b79 cd c6 18			call break_point_state  
4b7c				endm  
# End of macro CALLMONITOR
4b7c					endif 
4b7c				;	ld a, 0 
4b7c cd a7 13				call strlenz 
4b7f 23					inc hl 
4b80			 
4b80 06 00				ld b, 0 
4b82 4d					ld c, l 
4b83			 
4b83 e1					pop hl 
4b84			 
4b84					;ld a, 0 
4b84					;ld (hl),a 
4b84 3a eb fb				ld a,(f_cursor_ptr) 
4b87 16 64				ld d, 100 
4b89 0e 00				ld c, 0 
4b8b 1e 28				ld e, 40 
4b8d cd 76 0f				call input_str 
4b90					; TODO perhaps do a type check and wrap in quotes if not a number 
4b90					NEXTW 
4b90 c3 e7 22			jp macro_next 
4b93				endm 
# End of macro NEXTW
4b93			 
4b93			 
4b93			.ENDKEY: 
4b93			; eof 
4b93			 
# End of file forth_words_key.asm
4b93			include "forth_words_const.asm" 
4b93			 
4b93			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4b93			 
4b93			 
4b93			.SPITIME: 
4b93				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4b93 77				db WORD_SYS_CORE+99             
4b94 a8 4b			dw .VA            
4b96 08				db 7 + 1 
4b97 .. 00			db "SPITIME",0              
4b9f				endm 
# End of macro CWHEAD
4b9f			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4b9f			; 
4b9f			; | If using BANK devices then leave as is. 
4b9f			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4b9f			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4b9f			 
4b9f 21 f1 fb				ld hl, spi_clktime  
4ba2 cd 3a 1f				call forth_push_numhl 
4ba5			 
4ba5					NEXTW 
4ba5 c3 e7 22			jp macro_next 
4ba8				endm 
# End of macro NEXTW
4ba8			 
4ba8			 
4ba8			.VA: 
4ba8				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4ba8 77				db WORD_SYS_CORE+99             
4ba9 b8 4b			dw .SYMBOL            
4bab 03				db 2 + 1 
4bac .. 00			db "VA",0              
4baf				endm 
# End of macro CWHEAD
4baf			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4baf 21 b5 fb				ld hl, cli_var_array 
4bb2 cd 3a 1f				call forth_push_numhl 
4bb5			 
4bb5					NEXTW 
4bb5 c3 e7 22			jp macro_next 
4bb8				endm 
# End of macro NEXTW
4bb8			 
4bb8			.SYMBOL: 
4bb8				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4bb8 77				db WORD_SYS_CORE+99             
4bb9 f0 4c			dw .ENDCONST            
4bbb 07				db 6 + 1 
4bbc .. 00			db "SYMBOL",0              
4bc3				endm 
# End of macro CWHEAD
4bc3			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4bc3			; | 
4bc3			; | The value is the number reference and the final address is pushed to stack 
4bc3			 
4bc3					if DEBUG_FORTH_WORDS_KEY 
4bc3						DMARK "SYM" 
4bc3 f5				push af  
4bc4 3a d8 4b			ld a, (.dmark)  
4bc7 32 b4 fe			ld (debug_mark),a  
4bca 3a d9 4b			ld a, (.dmark+1)  
4bcd 32 b5 fe			ld (debug_mark+1),a  
4bd0 3a da 4b			ld a, (.dmark+2)  
4bd3 32 b6 fe			ld (debug_mark+2),a  
4bd6 18 03			jr .pastdmark  
4bd8 ..			.dmark: db "SYM"  
4bdb f1			.pastdmark: pop af  
4bdc			endm  
# End of macro DMARK
4bdc						CALLMONITOR 
4bdc cd c6 18			call break_point_state  
4bdf				endm  
# End of macro CALLMONITOR
4bdf					endif 
4bdf			 
4bdf					FORTH_DSP_VALUEHL 
4bdf cd 31 21			call macro_dsp_valuehl 
4be2				endm 
# End of macro FORTH_DSP_VALUEHL
4be2			 
4be2 7d					ld a, l     
4be3			 
4be3			 
4be3					if DEBUG_FORTH_WORDS 
4be3						DMARK "SY1" 
4be3 f5				push af  
4be4 3a f8 4b			ld a, (.dmark)  
4be7 32 b4 fe			ld (debug_mark),a  
4bea 3a f9 4b			ld a, (.dmark+1)  
4bed 32 b5 fe			ld (debug_mark+1),a  
4bf0 3a fa 4b			ld a, (.dmark+2)  
4bf3 32 b6 fe			ld (debug_mark+2),a  
4bf6 18 03			jr .pastdmark  
4bf8 ..			.dmark: db "SY1"  
4bfb f1			.pastdmark: pop af  
4bfc			endm  
# End of macro DMARK
4bfc						CALLMONITOR 
4bfc cd c6 18			call break_point_state  
4bff				endm  
# End of macro CALLMONITOR
4bff					endif 
4bff					 
4bff f5					push af	 
4c00					FORTH_DSP_POP 
4c00 cd e9 21			call macro_forth_dsp_pop 
4c03				endm 
# End of macro FORTH_DSP_POP
4c03 f1					pop af 
4c04			 
4c04 cb 27				sla a  
4c06				 
4c06					 
4c06					if DEBUG_FORTH_WORDS 
4c06						DMARK "SY" 
4c06 f5				push af  
4c07 3a 1b 4c			ld a, (.dmark)  
4c0a 32 b4 fe			ld (debug_mark),a  
4c0d 3a 1c 4c			ld a, (.dmark+1)  
4c10 32 b5 fe			ld (debug_mark+1),a  
4c13 3a 1d 4c			ld a, (.dmark+2)  
4c16 32 b6 fe			ld (debug_mark+2),a  
4c19 18 02			jr .pastdmark  
4c1b ..			.dmark: db "SY"  
4c1d f1			.pastdmark: pop af  
4c1e			endm  
# End of macro DMARK
4c1e						CALLMONITOR 
4c1e cd c6 18			call break_point_state  
4c21				endm  
# End of macro CALLMONITOR
4c21					endif 
4c21			 
4c21 21 30 4c				ld hl, sym_table 
4c24 cd 49 0f				call addatohl 
4c27 cd 69 22				call loadwordinhl 
4c2a cd 3a 1f				call forth_push_numhl 
4c2d			 
4c2d			 
4c2d				       NEXTW 
4c2d c3 e7 22			jp macro_next 
4c30				endm 
# End of macro NEXTW
4c30			 
4c30			sym_table: 
4c30			 
4c30			; 0 
4c30 c9 fb		dw cli_autodisplay 
4c32 d7 fb		dw cli_buffer 
4c34 7b fb		dw cli_data_sp 
4c36 b5 f8		dw cli_data_stack 
4c38 d1 fb		dw cli_execword 
4c3a 7d fb		dw cli_loop_sp 
4c3c b7 fa		dw cli_loop_stack 
4c3e ca fb		dw cli_mvdot 
4c40 cf fb		dw cli_nextword 
4c42 cb fb		dw cli_origptr 
4c44 d5 fb		dw cli_origtoken 
4c46			; 11 
4c46 cd fb		dw cli_ptr 
4c48 7f fb		dw cli_ret_sp 
4c4a 39 fb		dw cli_ret_stack 
4c4c d3 fb		dw cli_token 
4c4e b5 fb		dw cli_var_array 
4c50 51 fd		dw cursor_col 
4c52 4f fd		dw cursor_ptr 
4c54 50 fd		dw cursor_row 
4c56 4d fd		dw cursor_shape 
4c58 b4 fe		dw debug_mark 
4c5a			; 21 
4c5a 4a fe		dw display_fb0 
4c5c f9 fd		dw display_fb1 
4c5e 57 fd		dw display_fb2 
4c60 a8 fd		dw display_fb3 
4c62 55 fd		dw display_fb_active 
4c64 4d f4		dw execscratch 
4c66 eb fb		dw f_cursor_ptr 
4c68 b8 fe		dw hardware_word 
4c6a ab fe		dw input_at_cursor 
4c6c ad fe		dw input_at_pos 
4c6e			; 31 
4c6e a9 fe		dw input_cur_flash 
4c70 a8 fe		dw input_cur_onoff 
4c72 9e fe		dw input_cursor 
4c74 ae fe		dw input_display_size 
4c76 a3 fe		dw input_len 
4c78 b2 fe		dw input_ptr 
4c7a af fe		dw input_size 
4c7c b0 fe		dw input_start 
4c7e 76 0f		dw input_str 
4c80 ac fe		dw input_under_cursor 
4c82			; 41 
4c82 9d fe		dw key_actual_pressed 
4c84 c8 fe		dw key_fa 
4c86 c4 fe		dw key_face_held 
4c88 c7 fe		dw key_fb 
4c8a c6 fe		dw key_fc 
4c8c c5 fe		dw key_fd 
4c8e ce fe		dw key_held 
4c90 cd fe		dw key_held_prev 
4c92 e1 73		dw key_init 
4c94 c9 fe		dw key_repeat_ct 
4c96			; 51 
4c96 04 00		dw key_rows 
4c98 9b fe		dw key_shift 
4c9a 9c fe		dw key_symbol 
4c9c cf fe		dw keyscan_scancol 
4c9e d3 fe		dw keyscan_table 
4ca0 f8 fe		dw keyscan_table_row1 
4ca2 f3 fe		dw keyscan_table_row2 
4ca4 ee fe		dw keyscan_table_row3 
4ca6 e9 fe		dw keyscan_table_row4 
4ca8 e4 fe		dw keyscan_table_row5 
4caa			; 61 
4caa 75 f6		dw os_cli_cmd 
4cac 71 f6		dw os_cur_ptr 
4cae 73 f6		dw os_current_i 
4cb0 4c f5		dw os_input 
4cb2 74 f7		dw os_last_cmd 
4cb4 4b f6		dw os_last_new_uword 
4cb6 3f f3		dw os_view_disable 
4cb8 3b f3		dw os_view_hl 
4cba 53 f6		dw os_word_scratch 
4cbc c3 00		dw portbctl 
4cbe			; 71 
4cbe c1 00		dw portbdata 
4cc0 f0 fb		dw spi_cartdev 
4cc2 ef fb		dw spi_cartdev2 
4cc4 f1 fb		dw spi_clktime 
4cc6 ed fb		dw spi_device 
4cc8 ec fb		dw spi_device_id 
4cca ee fb		dw spi_portbyte 
4ccc 33 fd		dw stackstore 
4cce			if STORAGE_SE 
4cce 82 00		dw storage_actl 
4cd0 80 00		dw storage_adata 
4cd2			else 
4cd2			dw 0 
4cd2			dw 0 
4cd2			endif 
4cd2			; 81 
4cd2 09 0b		dw storage_append 
4cd4			if STORAGE_SE 
4cd4 83 00		dw storage_bctl 
4cd6			else 
4cd6			dw 0 
4cd6			endif 
4cd6 1f fd		dw store_bank_active 
4cd8 f4 fb		dw store_filecache 
4cda 02 fc		dw store_longread 
4cdc f8 fb		dw store_openaddr 
4cde f7 fb		dw store_openext 
4ce0 f6 fb		dw store_openmaxext 
4ce2 07 fc		dw store_page 
4ce4 03 fc		dw store_readbuf 
4ce6			; 91 
4ce6 fa fb		dw store_readcont 
4ce8 05 fc		dw store_readptr 
4cea fa fb		dw store_tmpext 
4cec fb fb		dw store_tmpid 
4cee f2 fb		dw store_tmppageid 
4cf0			 
4cf0			 
4cf0			.ENDCONST: 
4cf0			 
4cf0			; eof 
4cf0			 
4cf0			 
# End of file forth_words_const.asm
4cf0			 
4cf0			if STORAGE_SE 
4cf0			   	include "forth_words_storage.asm" 
4cf0			 
4cf0			; | ## Fixed Storage Words 
4cf0			 
4cf0			.RECORD: 
4cf0			  
4cf0				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4cf0 3a				db WORD_SYS_CORE+38             
4cf1 94 4d			dw .BREAD            
4cf3 07				db 6 + 1 
4cf4 .. 00			db "RECORD",0              
4cfb				endm 
# End of macro CWHEAD
4cfb			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4cfb			; | | Compatible with PicoSPINet  
4cfb			 
4cfb					if DEBUG_FORTH_WORDS_KEY 
4cfb						DMARK "REC" 
4cfb f5				push af  
4cfc 3a 10 4d			ld a, (.dmark)  
4cff 32 b4 fe			ld (debug_mark),a  
4d02 3a 11 4d			ld a, (.dmark+1)  
4d05 32 b5 fe			ld (debug_mark+1),a  
4d08 3a 12 4d			ld a, (.dmark+2)  
4d0b 32 b6 fe			ld (debug_mark+2),a  
4d0e 18 03			jr .pastdmark  
4d10 ..			.dmark: db "REC"  
4d13 f1			.pastdmark: pop af  
4d14			endm  
# End of macro DMARK
4d14						CALLMONITOR 
4d14 cd c6 18			call break_point_state  
4d17				endm  
# End of macro CALLMONITOR
4d17					endif 
4d17			 
4d17					FORTH_DSP_VALUEHL 
4d17 cd 31 21			call macro_dsp_valuehl 
4d1a				endm 
# End of macro FORTH_DSP_VALUEHL
4d1a			 
4d1a e5					push hl    ; id 
4d1b			 
4d1b					FORTH_DSP_POP 
4d1b cd e9 21			call macro_forth_dsp_pop 
4d1e				endm 
# End of macro FORTH_DSP_POP
4d1e			 
4d1e					FORTH_DSP_VALUEHL 
4d1e cd 31 21			call macro_dsp_valuehl 
4d21				endm 
# End of macro FORTH_DSP_VALUEHL
4d21			 
4d21					FORTH_DSP_POP 
4d21 cd e9 21			call macro_forth_dsp_pop 
4d24				endm 
# End of macro FORTH_DSP_POP
4d24			 
4d24 d1					pop de     ; get file id 
4d25			 
4d25					; e = file id 
4d25					; l = file extent 
4d25			 
4d25			 
4d25					; construct request to access file extent 
4d25			 
4d25			;		ld a, e 
4d25 63					ld h, e 
4d26					 
4d26					 
4d26					 
4d26			 
4d26					; e has id 
4d26			 
4d26 11 07 fc			ld de, store_page 
4d29					if DEBUG_FORTH_WORDS 
4d29						DMARK "REr" 
4d29 f5				push af  
4d2a 3a 3e 4d			ld a, (.dmark)  
4d2d 32 b4 fe			ld (debug_mark),a  
4d30 3a 3f 4d			ld a, (.dmark+1)  
4d33 32 b5 fe			ld (debug_mark+1),a  
4d36 3a 40 4d			ld a, (.dmark+2)  
4d39 32 b6 fe			ld (debug_mark+2),a  
4d3c 18 03			jr .pastdmark  
4d3e ..			.dmark: db "REr"  
4d41 f1			.pastdmark: pop af  
4d42			endm  
# End of macro DMARK
4d42						CALLMONITOR 
4d42 cd c6 18			call break_point_state  
4d45				endm  
# End of macro CALLMONITOR
4d45					endif 
4d45 cd 72 09				call storage_read 
4d48 cd 72 0f			call ishlzero 
4d4b 28 22			jr z, .recnotfound 
4d4d			 
4d4d			 
4d4d					if DEBUG_FORTH_WORDS 
4d4d						DMARK "REe" 
4d4d f5				push af  
4d4e 3a 62 4d			ld a, (.dmark)  
4d51 32 b4 fe			ld (debug_mark),a  
4d54 3a 63 4d			ld a, (.dmark+1)  
4d57 32 b5 fe			ld (debug_mark+1),a  
4d5a 3a 64 4d			ld a, (.dmark+2)  
4d5d 32 b6 fe			ld (debug_mark+2),a  
4d60 18 03			jr .pastdmark  
4d62 ..			.dmark: db "REe"  
4d65 f1			.pastdmark: pop af  
4d66			endm  
# End of macro DMARK
4d66						CALLMONITOR 
4d66 cd c6 18			call break_point_state  
4d69				endm  
# End of macro CALLMONITOR
4d69					endif 
4d69 cd a8 1f			call forth_push_str 
4d6c			 
4d6c					NEXTW 
4d6c c3 e7 22			jp macro_next 
4d6f				endm 
# End of macro NEXTW
4d6f			 
4d6f			.recnotfound: 
4d6f					if DEBUG_FORTH_WORDS 
4d6f						DMARK "REf" 
4d6f f5				push af  
4d70 3a 84 4d			ld a, (.dmark)  
4d73 32 b4 fe			ld (debug_mark),a  
4d76 3a 85 4d			ld a, (.dmark+1)  
4d79 32 b5 fe			ld (debug_mark+1),a  
4d7c 3a 86 4d			ld a, (.dmark+2)  
4d7f 32 b6 fe			ld (debug_mark+2),a  
4d82 18 03			jr .pastdmark  
4d84 ..			.dmark: db "REf"  
4d87 f1			.pastdmark: pop af  
4d88			endm  
# End of macro DMARK
4d88						CALLMONITOR 
4d88 cd c6 18			call break_point_state  
4d8b				endm  
# End of macro CALLMONITOR
4d8b					endif 
4d8b 21 ff 00			ld hl, 255 
4d8e cd 3a 1f			call forth_push_numhl 
4d91				NEXTW 
4d91 c3 e7 22			jp macro_next 
4d94				endm 
# End of macro NEXTW
4d94			 
4d94			 
4d94			.BREAD: 
4d94			  
4d94				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4d94 3a				db WORD_SYS_CORE+38             
4d95 17 4e			dw .BWRITE            
4d97 06				db 5 + 1 
4d98 .. 00			db "BREAD",0              
4d9e				endm 
# End of macro CWHEAD
4d9e			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
4d9e			; | | Compatible with PicoSPINet  
4d9e				 
4d9e					if DEBUG_FORTH_WORDS_KEY 
4d9e						DMARK "BRD" 
4d9e f5				push af  
4d9f 3a b3 4d			ld a, (.dmark)  
4da2 32 b4 fe			ld (debug_mark),a  
4da5 3a b4 4d			ld a, (.dmark+1)  
4da8 32 b5 fe			ld (debug_mark+1),a  
4dab 3a b5 4d			ld a, (.dmark+2)  
4dae 32 b6 fe			ld (debug_mark+2),a  
4db1 18 03			jr .pastdmark  
4db3 ..			.dmark: db "BRD"  
4db6 f1			.pastdmark: pop af  
4db7			endm  
# End of macro DMARK
4db7						CALLMONITOR 
4db7 cd c6 18			call break_point_state  
4dba				endm  
# End of macro CALLMONITOR
4dba					endif 
4dba			 
4dba				FORTH_DSP_VALUEHL 
4dba cd 31 21			call macro_dsp_valuehl 
4dbd				endm 
# End of macro FORTH_DSP_VALUEHL
4dbd			 
4dbd				FORTH_DSP_POP 
4dbd cd e9 21			call macro_forth_dsp_pop 
4dc0				endm 
# End of macro FORTH_DSP_POP
4dc0			 
4dc0				; calc block address 
4dc0			 
4dc0 eb				ex de, hl 
4dc1 3e 40			ld a, STORE_BLOCK_PHY 
4dc3 cd cc 0e			call Mult16 
4dc6			 
4dc6			 
4dc6 11 07 fc			ld de, store_page 
4dc9			 
4dc9					if DEBUG_FORTH_WORDS 
4dc9						DMARK "BR1" 
4dc9 f5				push af  
4dca 3a de 4d			ld a, (.dmark)  
4dcd 32 b4 fe			ld (debug_mark),a  
4dd0 3a df 4d			ld a, (.dmark+1)  
4dd3 32 b5 fe			ld (debug_mark+1),a  
4dd6 3a e0 4d			ld a, (.dmark+2)  
4dd9 32 b6 fe			ld (debug_mark+2),a  
4ddc 18 03			jr .pastdmark  
4dde ..			.dmark: db "BR1"  
4de1 f1			.pastdmark: pop af  
4de2			endm  
# End of macro DMARK
4de2						CALLMONITOR 
4de2 cd c6 18			call break_point_state  
4de5				endm  
# End of macro CALLMONITOR
4de5					endif 
4de5			 
4de5 cd 19 04			call storage_read_block 
4de8			 
4de8 cd 72 0f			call ishlzero 
4deb 20 05			jr nz, .brfound 
4ded			 
4ded cd 3a 1f			call forth_push_numhl 
4df0 18 22			jr .brdone 
4df2			 
4df2			 
4df2			.brfound: 
4df2 21 09 fc		        ld hl, store_page+2 
4df5			 
4df5					if DEBUG_FORTH_WORDS 
4df5						DMARK "BR2" 
4df5 f5				push af  
4df6 3a 0a 4e			ld a, (.dmark)  
4df9 32 b4 fe			ld (debug_mark),a  
4dfc 3a 0b 4e			ld a, (.dmark+1)  
4dff 32 b5 fe			ld (debug_mark+1),a  
4e02 3a 0c 4e			ld a, (.dmark+2)  
4e05 32 b6 fe			ld (debug_mark+2),a  
4e08 18 03			jr .pastdmark  
4e0a ..			.dmark: db "BR2"  
4e0d f1			.pastdmark: pop af  
4e0e			endm  
# End of macro DMARK
4e0e						CALLMONITOR 
4e0e cd c6 18			call break_point_state  
4e11				endm  
# End of macro CALLMONITOR
4e11					endif 
4e11			 
4e11 cd a8 1f			call forth_push_str 
4e14			 
4e14			 
4e14			.brdone: 
4e14			 
4e14					NEXTW 
4e14 c3 e7 22			jp macro_next 
4e17				endm 
# End of macro NEXTW
4e17			.BWRITE: 
4e17				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4e17 3a				db WORD_SYS_CORE+38             
4e18 ac 4e			dw .BUPD            
4e1a 07				db 6 + 1 
4e1b .. 00			db "BWRITE",0              
4e22				endm 
# End of macro CWHEAD
4e22			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
4e22			; | | Compatible with PicoSPINet  
4e22			 
4e22					if DEBUG_FORTH_WORDS_KEY 
4e22						DMARK "BWR" 
4e22 f5				push af  
4e23 3a 37 4e			ld a, (.dmark)  
4e26 32 b4 fe			ld (debug_mark),a  
4e29 3a 38 4e			ld a, (.dmark+1)  
4e2c 32 b5 fe			ld (debug_mark+1),a  
4e2f 3a 39 4e			ld a, (.dmark+2)  
4e32 32 b6 fe			ld (debug_mark+2),a  
4e35 18 03			jr .pastdmark  
4e37 ..			.dmark: db "BWR"  
4e3a f1			.pastdmark: pop af  
4e3b			endm  
# End of macro DMARK
4e3b						CALLMONITOR 
4e3b cd c6 18			call break_point_state  
4e3e				endm  
# End of macro CALLMONITOR
4e3e					endif 
4e3e			 
4e3e				FORTH_DSP_VALUEHL 
4e3e cd 31 21			call macro_dsp_valuehl 
4e41				endm 
# End of macro FORTH_DSP_VALUEHL
4e41			 
4e41				; calc block address 
4e41			 
4e41 eb				ex de, hl 
4e42 3e 40			ld a, STORE_BLOCK_PHY 
4e44 cd cc 0e			call Mult16 
4e47			 
4e47 e5				push hl         ; address 
4e48			 
4e48				FORTH_DSP_POP 
4e48 cd e9 21			call macro_forth_dsp_pop 
4e4b				endm 
# End of macro FORTH_DSP_POP
4e4b			 
4e4b				FORTH_DSP_VALUEHL 
4e4b cd 31 21			call macro_dsp_valuehl 
4e4e				endm 
# End of macro FORTH_DSP_VALUEHL
4e4e			 
4e4e				FORTH_DSP_POP 
4e4e cd e9 21			call macro_forth_dsp_pop 
4e51				endm 
# End of macro FORTH_DSP_POP
4e51			 
4e51 cd 55 0c			call storage_clear_page 
4e54			 
4e54				; copy string to store page 
4e54			 
4e54 e5				push hl     ; save string address 
4e55			 
4e55 3e 00			ld a, 0 
4e57 cd b2 13			call strlent 
4e5a			 
4e5a 23				inc hl 
4e5b			 
4e5b 4d				ld c, l 
4e5c 06 00			ld b, 0 
4e5e			 
4e5e e1				pop hl 
4e5f 11 09 fc			ld de, store_page + 2 
4e62					if DEBUG_FORTH_WORDS 
4e62						DMARK "BW1" 
4e62 f5				push af  
4e63 3a 77 4e			ld a, (.dmark)  
4e66 32 b4 fe			ld (debug_mark),a  
4e69 3a 78 4e			ld a, (.dmark+1)  
4e6c 32 b5 fe			ld (debug_mark+1),a  
4e6f 3a 79 4e			ld a, (.dmark+2)  
4e72 32 b6 fe			ld (debug_mark+2),a  
4e75 18 03			jr .pastdmark  
4e77 ..			.dmark: db "BW1"  
4e7a f1			.pastdmark: pop af  
4e7b			endm  
# End of macro DMARK
4e7b						CALLMONITOR 
4e7b cd c6 18			call break_point_state  
4e7e				endm  
# End of macro CALLMONITOR
4e7e					endif 
4e7e ed b0			ldir 
4e80			 
4e80			 
4e80				; poke the start of the block with flags to prevent high level file ops hitting the block 
4e80			 
4e80 21 ff ff			ld hl, $ffff 
4e83			 
4e83 22 07 fc			ld (store_page), hl	 
4e86				 
4e86 e1				pop hl    ; get address 
4e87 11 07 fc			ld de, store_page 
4e8a			 
4e8a					if DEBUG_FORTH_WORDS 
4e8a						DMARK "BW2" 
4e8a f5				push af  
4e8b 3a 9f 4e			ld a, (.dmark)  
4e8e 32 b4 fe			ld (debug_mark),a  
4e91 3a a0 4e			ld a, (.dmark+1)  
4e94 32 b5 fe			ld (debug_mark+1),a  
4e97 3a a1 4e			ld a, (.dmark+2)  
4e9a 32 b6 fe			ld (debug_mark+2),a  
4e9d 18 03			jr .pastdmark  
4e9f ..			.dmark: db "BW2"  
4ea2 f1			.pastdmark: pop af  
4ea3			endm  
# End of macro DMARK
4ea3						CALLMONITOR 
4ea3 cd c6 18			call break_point_state  
4ea6				endm  
# End of macro CALLMONITOR
4ea6					endif 
4ea6			 
4ea6 cd 7e 04			call storage_write_block 
4ea9			 
4ea9					NEXTW 
4ea9 c3 e7 22			jp macro_next 
4eac				endm 
# End of macro NEXTW
4eac			 
4eac			.BUPD: 
4eac				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4eac 3a				db WORD_SYS_CORE+38             
4ead 02 4f			dw .BYID            
4eaf 05				db 4 + 1 
4eb0 .. 00			db "BUPD",0              
4eb5				endm 
# End of macro CWHEAD
4eb5			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
4eb5			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4eb5			; | | or completely different file system structure. 
4eb5			; | | Compatible with PicoSPINet  
4eb5			 
4eb5					if DEBUG_FORTH_WORDS_KEY 
4eb5						DMARK "BUD" 
4eb5 f5				push af  
4eb6 3a ca 4e			ld a, (.dmark)  
4eb9 32 b4 fe			ld (debug_mark),a  
4ebc 3a cb 4e			ld a, (.dmark+1)  
4ebf 32 b5 fe			ld (debug_mark+1),a  
4ec2 3a cc 4e			ld a, (.dmark+2)  
4ec5 32 b6 fe			ld (debug_mark+2),a  
4ec8 18 03			jr .pastdmark  
4eca ..			.dmark: db "BUD"  
4ecd f1			.pastdmark: pop af  
4ece			endm  
# End of macro DMARK
4ece						CALLMONITOR 
4ece cd c6 18			call break_point_state  
4ed1				endm  
# End of macro CALLMONITOR
4ed1					endif 
4ed1			 
4ed1				FORTH_DSP_VALUEHL 
4ed1 cd 31 21			call macro_dsp_valuehl 
4ed4				endm 
# End of macro FORTH_DSP_VALUEHL
4ed4			 
4ed4				; calc block address 
4ed4			 
4ed4 eb				ex de, hl 
4ed5 3e 40			ld a, STORE_BLOCK_PHY 
4ed7 cd cc 0e			call Mult16 
4eda			 
4eda				FORTH_DSP_POP 
4eda cd e9 21			call macro_forth_dsp_pop 
4edd				endm 
# End of macro FORTH_DSP_POP
4edd			 
4edd			 
4edd 11 07 fc			ld de, store_page 
4ee0			 
4ee0					if DEBUG_FORTH_WORDS 
4ee0						DMARK "BUe" 
4ee0 f5				push af  
4ee1 3a f5 4e			ld a, (.dmark)  
4ee4 32 b4 fe			ld (debug_mark),a  
4ee7 3a f6 4e			ld a, (.dmark+1)  
4eea 32 b5 fe			ld (debug_mark+1),a  
4eed 3a f7 4e			ld a, (.dmark+2)  
4ef0 32 b6 fe			ld (debug_mark+2),a  
4ef3 18 03			jr .pastdmark  
4ef5 ..			.dmark: db "BUe"  
4ef8 f1			.pastdmark: pop af  
4ef9			endm  
# End of macro DMARK
4ef9						CALLMONITOR 
4ef9 cd c6 18			call break_point_state  
4efc				endm  
# End of macro CALLMONITOR
4efc					endif 
4efc			 
4efc cd 7e 04			call storage_write_block 
4eff			 
4eff					NEXTW 
4eff c3 e7 22			jp macro_next 
4f02				endm 
# End of macro NEXTW
4f02			 
4f02			.BYID: 
4f02			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4f02			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4f02			; 
4f02			;		 
4f02			;		if DEBUG_FORTH_WORDS_KEY 
4f02			;			DMARK "BYID" 
4f02			;			CALLMONITOR 
4f02			;		endif 
4f02			; 
4f02			;		; get direct address 
4f02			; 
4f02			;		FORTH_DSP_VALUEHL 
4f02			; 
4f02			;		FORTH_DSP_POP 
4f02			; 
4f02			;	; calc block address 
4f02			; 
4f02			;	ex de, hl 
4f02			;	ld a, STORE_BLOCK_PHY 
4f02			;	call Mult16 
4f02			;	;	do BREAD with number as param 
4f02			;	; push the file name	 
4f02			;	ld de, store_page 
4f02			;	call storage_read_block 
4f02			 ;       ld hl, store_page+2 
4f02			; 
4f02			; 
4f02			;		NEXTW 
4f02			;.BYNAME: 
4f02				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4f02 3a				db WORD_SYS_CORE+38             
4f03 1b 4f			dw .DIR            
4f05 06				db 5 + 1 
4f06 .. 00			db "GETID",0              
4f0c				endm 
# End of macro CWHEAD
4f0c			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4f0c			; | | Compatible with PicoSPINet  
4f0c			 
4f0c					; get pointer to file name to seek 
4f0c			 
4f0c					FORTH_DSP_VALUEHL 
4f0c cd 31 21			call macro_dsp_valuehl 
4f0f				endm 
# End of macro FORTH_DSP_VALUEHL
4f0f			 
4f0f			 
4f0f cd 40 03				call storage_getid  
4f12			 
4f12					FORTH_DSP_POP 
4f12 cd e9 21			call macro_forth_dsp_pop 
4f15				endm 
# End of macro FORTH_DSP_POP
4f15			 
4f15 cd 3a 1f				call forth_push_numhl 
4f18			 
4f18					NEXTW 
4f18 c3 e7 22			jp macro_next 
4f1b				endm 
# End of macro NEXTW
4f1b			; 
4f1b			.DIR: 
4f1b				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4f1b 3a				db WORD_SYS_CORE+38             
4f1c 1f 50			dw .SAVE            
4f1e 04				db 3 + 1 
4f1f .. 00			db "DIR",0              
4f23				endm 
# End of macro CWHEAD
4f23			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4f23			; | | Compatible with PicoSPINet  
4f23			 
4f23					if DEBUG_FORTH_WORDS_KEY 
4f23						DMARK "DIR" 
4f23 f5				push af  
4f24 3a 38 4f			ld a, (.dmark)  
4f27 32 b4 fe			ld (debug_mark),a  
4f2a 3a 39 4f			ld a, (.dmark+1)  
4f2d 32 b5 fe			ld (debug_mark+1),a  
4f30 3a 3a 4f			ld a, (.dmark+2)  
4f33 32 b6 fe			ld (debug_mark+2),a  
4f36 18 03			jr .pastdmark  
4f38 ..			.dmark: db "DIR"  
4f3b f1			.pastdmark: pop af  
4f3c			endm  
# End of macro DMARK
4f3c						CALLMONITOR 
4f3c cd c6 18			call break_point_state  
4f3f				endm  
# End of macro CALLMONITOR
4f3f					endif 
4f3f cd ca 04			call storage_get_block_0 
4f42			 
4f42 21 07 fc			ld hl, store_page     ; get current id count 
4f45 46				ld b, (hl) 
4f46 0e 00			ld c, 0    ; count of files   
4f48					if DEBUG_FORTH_WORDS 
4f48						DMARK "DI1" 
4f48 f5				push af  
4f49 3a 5d 4f			ld a, (.dmark)  
4f4c 32 b4 fe			ld (debug_mark),a  
4f4f 3a 5e 4f			ld a, (.dmark+1)  
4f52 32 b5 fe			ld (debug_mark+1),a  
4f55 3a 5f 4f			ld a, (.dmark+2)  
4f58 32 b6 fe			ld (debug_mark+2),a  
4f5b 18 03			jr .pastdmark  
4f5d ..			.dmark: db "DI1"  
4f60 f1			.pastdmark: pop af  
4f61			endm  
# End of macro DMARK
4f61						CALLMONITOR 
4f61 cd c6 18			call break_point_state  
4f64				endm  
# End of macro CALLMONITOR
4f64					endif 
4f64			 
4f64				; check for empty drive 
4f64			 
4f64 3e 00			ld a, 0 
4f66 b8				cp b 
4f67 ca d5 4f			jp z, .dirdone 
4f6a			 
4f6a				; for each of the current ids do a search for them and if found push to stack 
4f6a			 
4f6a c5			.diritem:	push bc 
4f6b 21 40 00				ld hl, STORE_BLOCK_PHY 
4f6e 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4f70 58					ld e,b 
4f71			 
4f71			;		if DEBUG_FORTH_WORDS 
4f71			;			DMARK "DI2" 
4f71			;			CALLMONITOR 
4f71			;		endif 
4f71			 
4f71 cd 4c 07				call storage_findnextid 
4f74			 
4f74			;		if DEBUG_FORTH_WORDS 
4f74			;			DMARK "DI3" 
4f74			;			CALLMONITOR 
4f74			;		endif 
4f74			 
4f74					; if found hl will be non zero 
4f74			 
4f74 cd 72 0f				call ishlzero 
4f77			;		ld a, l 
4f77			;		add h 
4f77			; 
4f77			;		cp 0 
4f77 28 59				jr z, .dirnotfound 
4f79			 
4f79					; increase count 
4f79			 
4f79 c1					pop bc	 
4f7a 0c					inc c 
4f7b c5					push bc 
4f7c					 
4f7c			 
4f7c					; get file header and push the file name 
4f7c			 
4f7c 11 07 fc				ld de, store_page 
4f7f cd 19 04				call storage_read_block 
4f82			 
4f82					; push file id to stack 
4f82				 
4f82 3a 07 fc				ld a, (store_page) 
4f85 26 00				ld h, 0 
4f87 6f					ld l, a 
4f88 cd 3a 1f				call forth_push_numhl 
4f8b			 
4f8b					; push extent count to stack  
4f8b				 
4f8b 3a 09 fc				ld a, (store_page+2) 
4f8e 26 00				ld h, 0 
4f90 6f					ld l, a 
4f91 cd 3a 1f				call forth_push_numhl 
4f94			 
4f94					; push file name 
4f94			 
4f94 21 0a fc				ld hl, store_page+3 
4f97					if DEBUG_FORTH_WORDS 
4f97						DMARK "DI5" 
4f97 f5				push af  
4f98 3a ac 4f			ld a, (.dmark)  
4f9b 32 b4 fe			ld (debug_mark),a  
4f9e 3a ad 4f			ld a, (.dmark+1)  
4fa1 32 b5 fe			ld (debug_mark+1),a  
4fa4 3a ae 4f			ld a, (.dmark+2)  
4fa7 32 b6 fe			ld (debug_mark+2),a  
4faa 18 03			jr .pastdmark  
4fac ..			.dmark: db "DI5"  
4faf f1			.pastdmark: pop af  
4fb0			endm  
# End of macro DMARK
4fb0						CALLMONITOR 
4fb0 cd c6 18			call break_point_state  
4fb3				endm  
# End of macro CALLMONITOR
4fb3					endif 
4fb3 cd a8 1f				call forth_push_str 
4fb6					if DEBUG_FORTH_WORDS 
4fb6						DMARK "DI6" 
4fb6 f5				push af  
4fb7 3a cb 4f			ld a, (.dmark)  
4fba 32 b4 fe			ld (debug_mark),a  
4fbd 3a cc 4f			ld a, (.dmark+1)  
4fc0 32 b5 fe			ld (debug_mark+1),a  
4fc3 3a cd 4f			ld a, (.dmark+2)  
4fc6 32 b6 fe			ld (debug_mark+2),a  
4fc9 18 03			jr .pastdmark  
4fcb ..			.dmark: db "DI6"  
4fce f1			.pastdmark: pop af  
4fcf			endm  
# End of macro DMARK
4fcf						CALLMONITOR 
4fcf cd c6 18			call break_point_state  
4fd2				endm  
# End of macro CALLMONITOR
4fd2					endif 
4fd2			.dirnotfound: 
4fd2 c1					pop bc     
4fd3 10 95				djnz .diritem 
4fd5				 
4fd5			.dirdone:	 
4fd5					if DEBUG_FORTH_WORDS 
4fd5						DMARK "DI7" 
4fd5 f5				push af  
4fd6 3a ea 4f			ld a, (.dmark)  
4fd9 32 b4 fe			ld (debug_mark),a  
4fdc 3a eb 4f			ld a, (.dmark+1)  
4fdf 32 b5 fe			ld (debug_mark+1),a  
4fe2 3a ec 4f			ld a, (.dmark+2)  
4fe5 32 b6 fe			ld (debug_mark+2),a  
4fe8 18 03			jr .pastdmark  
4fea ..			.dmark: db "DI7"  
4fed f1			.pastdmark: pop af  
4fee			endm  
# End of macro DMARK
4fee						CALLMONITOR 
4fee cd c6 18			call break_point_state  
4ff1				endm  
# End of macro CALLMONITOR
4ff1					endif 
4ff1			 
4ff1					; push a count of the dir items found 
4ff1			 
4ff1 26 00				ld h, 0 
4ff3 69					ld l, c 
4ff4 cd 3a 1f				call forth_push_numhl 
4ff7			 
4ff7					; push the bank label 
4ff7			 
4ff7 cd ca 04				call storage_get_block_0 
4ffa			 
4ffa				 
4ffa 21 0a fc		 		ld hl, store_page+3 
4ffd			 
4ffd					if DEBUG_FORTH_WORDS 
4ffd						DMARK "DI8" 
4ffd f5				push af  
4ffe 3a 12 50			ld a, (.dmark)  
5001 32 b4 fe			ld (debug_mark),a  
5004 3a 13 50			ld a, (.dmark+1)  
5007 32 b5 fe			ld (debug_mark+1),a  
500a 3a 14 50			ld a, (.dmark+2)  
500d 32 b6 fe			ld (debug_mark+2),a  
5010 18 03			jr .pastdmark  
5012 ..			.dmark: db "DI8"  
5015 f1			.pastdmark: pop af  
5016			endm  
# End of macro DMARK
5016						CALLMONITOR 
5016 cd c6 18			call break_point_state  
5019				endm  
# End of macro CALLMONITOR
5019					endif 
5019 cd a8 1f				call forth_push_str 
501c			 
501c			 
501c				 
501c					NEXTW 
501c c3 e7 22			jp macro_next 
501f				endm 
# End of macro NEXTW
501f			.SAVE: 
501f			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
501f			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
501f			;		NEXTW 
501f			;.LOAD: 
501f			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
501f			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
501f			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
501f			;; > > The LOAD command can not be used in any user words or compound lines. 
501f			; 
501f			;		; store_openext use it. If zero it is EOF 
501f			; 
501f			;		; read block from current stream id 
501f			;		; if the block does not contain zero term keep reading blocks until zero found 
501f			;		; push the block to stack 
501f			;		; save the block id to stream 
501f			; 
501f			; 
501f			;		FORTH_DSP_VALUEHL 
501f			; 
501f			;;		push hl 
501f			; 
501f			;	if DEBUG_STORESE 
501f			;		DMARK "LOA" 
501f			;		CALLMONITOR 
501f			;	endif 
501f			;		FORTH_DSP_POP 
501f			; 
501f			;;		pop hl 
501f			; 
501f			;		ld h, l 
501f			;		ld l, 0 
501f			; 
501f			;		push hl     ; stack holds current file id and extent to work with 
501f			; 
501f			; 
501f			;		ld de, store_page      ; get block zero of file 
501f			;	if DEBUG_STORESE 
501f			;		DMARK "LO0" 
501f			;		CALLMONITOR 
501f			;	endif 
501f			;		call storage_read 
501f			; 
501f			;		ld a, (store_page+2)    ; max extents for this file 
501f			;		ld  (store_openmaxext),a   ; get our limit 
501f			; 
501f			;	if DEBUG_STORESE 
501f			;		DMARK "LOE" 
501f			;		CALLMONITOR 
501f			;	endif 
501f			; 
501f			;; TODO dont know why max extents are not present 
501f			;;		cp 0 
501f			;;		jp z, .loadeof     ; dont read past eof 
501f			; 
501f			;;		ld a, 1   ; start from the head of the file 
501f			; 
501f			;.loadline:	pop hl 
501f			;		inc hl 
501f			;		ld  a, (store_openmaxext)   ; get our limit 
501f			;	if DEBUG_STORESE 
501f			;		DMARK "LOx" 
501f			;		CALLMONITOR 
501f			;	endif 
501f			;		inc a 
501f			;		cp l 
501f			;		jp z, .loadeof 
501f			;		push hl    ; save current extent 
501f			; 
501f			;		ld de, store_page 
501f			; 
501f			;	if DEBUG_STORESE 
501f			;		DMARK "LO1" 
501f			;		CALLMONITOR 
501f			;	endif 
501f			;		call storage_read 
501f			; 
501f			;	if DEBUG_STORESE 
501f			;		DMARK "LO2" 
501f			;		CALLMONITOR 
501f			;	endif 
501f			;	call ishlzero 
501f			;	ld a, l 
501f			;	add h 
501f			;	cp 0 
501f			;	jr z, .loadeof 
501f			; 
501f			;	; not eof so hl should point to data to exec 
501f			; 
501f			;	; will need to add the FORTH_END_BUFFER flag 
501f			 ; 
501f			;	ld hl, store_page+2 
501f			;	ld bc, 255 
501f			;	ld a, 0 
501f			;	cpir 
501f			;	if DEBUG_STORESE 
501f			;		DMARK "LOt" 
501f			;		CALLMONITOR 
501f			;	endif 
501f			;	dec hl 
501f			;	ld a, ' ' 
501f			;	ld (hl), a 
501f			;	inc hl 
501f			;	ld (hl), a 
501f			;	inc hl 
501f			;	ld (hl), a 
501f			;	inc hl 
501f			;	ld a, FORTH_END_BUFFER 
501f			;	ld (hl), a 
501f			; 
501f			;	; TODO handle more than a single block read 
501f			; 
501f			; 
501f			;	ld hl, store_page+2 
501f			; 
501f			;	ld (os_tok_ptr), hl 
501f			; 
501f			;	if DEBUG_STORESE 
501f			;		DMARK "LO3" 
501f			;		CALLMONITOR 
501f			;	endif 
501f			; 
501f			;	call forthparse 
501f			;	call forthexec 
501f			;	call forthexec_cleanup 
501f			; 
501f			;	; go to next extent 
501f			; 
501f			;	; get next block  or mark as eof 
501f			;	jp .loadline 
501f			; 
501f			; 
501f			; 
501f			;	       NEXTW 
501f			;.loadeof:	ld a, 0 
501f			;		ld (store_openext), a 
501f			; 
501f			;	if DEBUG_STORESE 
501f			;		DMARK "LOF" 
501f			;		CALLMONITOR 
501f			;	endif 
501f			;		ret 
501f			;		;NEXTW 
501f			;.BSAVE:   
501f			; 
501f			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
501f			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
501f			;		NEXTW 
501f			;.BLOAD: 
501f			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
501f			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
501f			;		NEXTW 
501f			;;;; counter gap 
501f			 
501f			 
501f			.SEO: 
501f				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
501f 64				db WORD_SYS_CORE+80             
5020 3e 50			dw .SEI            
5022 04				db 3 + 1 
5023 .. 00			db "SEO",0              
5027				endm 
# End of macro CWHEAD
5027			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5027			 
5027					; get port 
5027			 
5027					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5027 cd 31 21			call macro_dsp_valuehl 
502a				endm 
# End of macro FORTH_DSP_VALUEHL
502a			 
502a e5					push hl    ; u2 - byte 
502b			 
502b					; destroy value TOS 
502b			 
502b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
502b cd e9 21			call macro_forth_dsp_pop 
502e				endm 
# End of macro FORTH_DSP_POP
502e			 
502e					; get byte to send 
502e			 
502e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
502e cd 31 21			call macro_dsp_valuehl 
5031				endm 
# End of macro FORTH_DSP_VALUEHL
5031			 
5031 e5					push hl    ; u1 - addr 
5032			 
5032					; destroy value TOS 
5032			 
5032					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5032 cd e9 21			call macro_forth_dsp_pop 
5035				endm 
# End of macro FORTH_DSP_POP
5035			 
5035					; one value on hl get other one back 
5035			 
5035 d1					pop de   ; u1 - byte 
5036			 
5036 e1					pop hl   ; u2 - addr 
5037			 
5037					; TODO Send SPI byte 
5037			 
5037			 
5037 7b					ld a, e 
5038 cd 1e 02				call se_writebyte 
503b			 
503b					 
503b			 
503b					NEXTW 
503b c3 e7 22			jp macro_next 
503e				endm 
# End of macro NEXTW
503e			 
503e			.SEI: 
503e				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
503e 65				db WORD_SYS_CORE+81             
503f 58 50			dw .SFREE            
5041 04				db 3 + 1 
5042 .. 00			db "SEI",0              
5046				endm 
# End of macro CWHEAD
5046			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5046			 
5046					; get port 
5046			 
5046					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5046 cd 31 21			call macro_dsp_valuehl 
5049				endm 
# End of macro FORTH_DSP_VALUEHL
5049			 
5049			;		push hl 
5049			 
5049					; destroy value TOS 
5049			 
5049					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5049 cd e9 21			call macro_forth_dsp_pop 
504c				endm 
# End of macro FORTH_DSP_POP
504c			 
504c					; one value on hl get other one back 
504c			 
504c			;		pop hl 
504c			 
504c			 
504c					; TODO Get SPI byte 
504c			 
504c cd c0 02				call se_readbyte 
504f			 
504f 26 00				ld h, 0 
5051 6f					ld l, a 
5052 cd 3a 1f				call forth_push_numhl 
5055			 
5055					NEXTW 
5055 c3 e7 22			jp macro_next 
5058				endm 
# End of macro NEXTW
5058			 
5058			.SFREE: 
5058				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5058 67				db WORD_SYS_CORE+83             
5059 87 50			dw .SIZE            
505b 06				db 5 + 1 
505c .. 00			db "FFREE",0              
5062				endm 
# End of macro CWHEAD
5062			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5062			; | | Compatible with PicoSPINet  
5062					if DEBUG_FORTH_WORDS_KEY 
5062						DMARK "FFR" 
5062 f5				push af  
5063 3a 77 50			ld a, (.dmark)  
5066 32 b4 fe			ld (debug_mark),a  
5069 3a 78 50			ld a, (.dmark+1)  
506c 32 b5 fe			ld (debug_mark+1),a  
506f 3a 79 50			ld a, (.dmark+2)  
5072 32 b6 fe			ld (debug_mark+2),a  
5075 18 03			jr .pastdmark  
5077 ..			.dmark: db "FFR"  
507a f1			.pastdmark: pop af  
507b			endm  
# End of macro DMARK
507b						CALLMONITOR 
507b cd c6 18			call break_point_state  
507e				endm  
# End of macro CALLMONITOR
507e					endif 
507e			 
507e cd e6 07				call storage_freeblocks 
5081			 
5081 cd 3a 1f				call forth_push_numhl 
5084			 
5084				       NEXTW 
5084 c3 e7 22			jp macro_next 
5087				endm 
# End of macro NEXTW
5087			.SIZE: 
5087				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5087 67				db WORD_SYS_CORE+83             
5088 bb 50			dw .CREATE            
508a 05				db 4 + 1 
508b .. 00			db "SIZE",0              
5090				endm 
# End of macro CWHEAD
5090			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5090			; | | Compatible with PicoSPINet  
5090					if DEBUG_FORTH_WORDS_KEY 
5090						DMARK "SIZ" 
5090 f5				push af  
5091 3a a5 50			ld a, (.dmark)  
5094 32 b4 fe			ld (debug_mark),a  
5097 3a a6 50			ld a, (.dmark+1)  
509a 32 b5 fe			ld (debug_mark+1),a  
509d 3a a7 50			ld a, (.dmark+2)  
50a0 32 b6 fe			ld (debug_mark+2),a  
50a3 18 03			jr .pastdmark  
50a5 ..			.dmark: db "SIZ"  
50a8 f1			.pastdmark: pop af  
50a9			endm  
# End of macro DMARK
50a9						CALLMONITOR 
50a9 cd c6 18			call break_point_state  
50ac				endm  
# End of macro CALLMONITOR
50ac					endif 
50ac			 
50ac					FORTH_DSP_VALUEHL 
50ac cd 31 21			call macro_dsp_valuehl 
50af				endm 
# End of macro FORTH_DSP_VALUEHL
50af			;		push hl 
50af					FORTH_DSP_POP 
50af cd e9 21			call macro_forth_dsp_pop 
50b2				endm 
# End of macro FORTH_DSP_POP
50b2			;		pop hl 
50b2 cd 48 04				call storage_file_size 
50b5			 
50b5 cd 3a 1f				call forth_push_numhl 
50b8			  
50b8			 
50b8				       NEXTW 
50b8 c3 e7 22			jp macro_next 
50bb				endm 
# End of macro NEXTW
50bb			 
50bb			.CREATE: 
50bb				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
50bb 68				db WORD_SYS_CORE+84             
50bc 29 51			dw .APPEND            
50be 07				db 6 + 1 
50bf .. 00			db "CREATE",0              
50c6				endm 
# End of macro CWHEAD
50c6			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
50c6			; | | e.g.  
50c6			; | | TestProgram CREATE 
50c6			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
50c6			; | |  
50c6			; | | Max file IDs are 255. 
50c6			; | |  
50c6			; | | Compatible with PicoSPINet  
50c6					 
50c6					if DEBUG_FORTH_WORDS_KEY 
50c6						DMARK "CRT" 
50c6 f5				push af  
50c7 3a db 50			ld a, (.dmark)  
50ca 32 b4 fe			ld (debug_mark),a  
50cd 3a dc 50			ld a, (.dmark+1)  
50d0 32 b5 fe			ld (debug_mark+1),a  
50d3 3a dd 50			ld a, (.dmark+2)  
50d6 32 b6 fe			ld (debug_mark+2),a  
50d9 18 03			jr .pastdmark  
50db ..			.dmark: db "CRT"  
50de f1			.pastdmark: pop af  
50df			endm  
# End of macro DMARK
50df						CALLMONITOR 
50df cd c6 18			call break_point_state  
50e2				endm  
# End of macro CALLMONITOR
50e2					endif 
50e2			;		call storage_get_block_0 
50e2			 
50e2					; TODO pop hl 
50e2			 
50e2					;v5 FORTH_DSP_VALUE 
50e2					FORTH_DSP_VALUE 
50e2 cd 1a 21			call macro_forth_dsp_value 
50e5				endm 
# End of macro FORTH_DSP_VALUE
50e5			 
50e5				if DEBUG_STORESE 
50e5					DMARK "CR1" 
50e5 f5				push af  
50e6 3a fa 50			ld a, (.dmark)  
50e9 32 b4 fe			ld (debug_mark),a  
50ec 3a fb 50			ld a, (.dmark+1)  
50ef 32 b5 fe			ld (debug_mark+1),a  
50f2 3a fc 50			ld a, (.dmark+2)  
50f5 32 b6 fe			ld (debug_mark+2),a  
50f8 18 03			jr .pastdmark  
50fa ..			.dmark: db "CR1"  
50fd f1			.pastdmark: pop af  
50fe			endm  
# End of macro DMARK
50fe					CALLMONITOR 
50fe cd c6 18			call break_point_state  
5101				endm  
# End of macro CALLMONITOR
5101				endif 
5101			;		push hl 
5101			;		FORTH_DSP_POP 
5101			;		pop hl 
5101			 
5101			;		inc hl   ; move past the type marker 
5101			 
5101 cd 1c 08				call storage_create 
5104			 
5104				if DEBUG_STORESE 
5104					DMARK "CT1" 
5104 f5				push af  
5105 3a 19 51			ld a, (.dmark)  
5108 32 b4 fe			ld (debug_mark),a  
510b 3a 1a 51			ld a, (.dmark+1)  
510e 32 b5 fe			ld (debug_mark+1),a  
5111 3a 1b 51			ld a, (.dmark+2)  
5114 32 b6 fe			ld (debug_mark+2),a  
5117 18 03			jr .pastdmark  
5119 ..			.dmark: db "CT1"  
511c f1			.pastdmark: pop af  
511d			endm  
# End of macro DMARK
511d					CALLMONITOR 
511d cd c6 18			call break_point_state  
5120				endm  
# End of macro CALLMONITOR
5120				endif 
5120			;		push hl 
5120					FORTH_DSP_POP 
5120 cd e9 21			call macro_forth_dsp_pop 
5123				endm 
# End of macro FORTH_DSP_POP
5123			;		pop hl 
5123					; push file id to stack 
5123 cd 3a 1f				call forth_push_numhl 
5126			 
5126			 
5126			 
5126				       NEXTW 
5126 c3 e7 22			jp macro_next 
5129				endm 
# End of macro NEXTW
5129			 
5129			.APPEND: 
5129				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5129 69				db WORD_SYS_CORE+85             
512a ba 51			dw .SDEL            
512c 07				db 6 + 1 
512d .. 00			db "APPEND",0              
5134				endm 
# End of macro CWHEAD
5134			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5134			; | | e.g. 
5134			; | | Test CREATE      -> $01 
5134			; | | "A string to add to file" $01 APPEND 
5134			; | |  
5134			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5134			; | | Compatible with PicoSPINet  
5134					if DEBUG_FORTH_WORDS_KEY 
5134						DMARK "APP" 
5134 f5				push af  
5135 3a 49 51			ld a, (.dmark)  
5138 32 b4 fe			ld (debug_mark),a  
513b 3a 4a 51			ld a, (.dmark+1)  
513e 32 b5 fe			ld (debug_mark+1),a  
5141 3a 4b 51			ld a, (.dmark+2)  
5144 32 b6 fe			ld (debug_mark+2),a  
5147 18 03			jr .pastdmark  
5149 ..			.dmark: db "APP"  
514c f1			.pastdmark: pop af  
514d			endm  
# End of macro DMARK
514d						CALLMONITOR 
514d cd c6 18			call break_point_state  
5150				endm  
# End of macro CALLMONITOR
5150					endif 
5150			 
5150					FORTH_DSP_VALUEHL 
5150 cd 31 21			call macro_dsp_valuehl 
5153				endm 
# End of macro FORTH_DSP_VALUEHL
5153 e5					push hl 	; save file id 
5154			 
5154				if DEBUG_STORESE 
5154					DMARK "AP1" 
5154 f5				push af  
5155 3a 69 51			ld a, (.dmark)  
5158 32 b4 fe			ld (debug_mark),a  
515b 3a 6a 51			ld a, (.dmark+1)  
515e 32 b5 fe			ld (debug_mark+1),a  
5161 3a 6b 51			ld a, (.dmark+2)  
5164 32 b6 fe			ld (debug_mark+2),a  
5167 18 03			jr .pastdmark  
5169 ..			.dmark: db "AP1"  
516c f1			.pastdmark: pop af  
516d			endm  
# End of macro DMARK
516d					CALLMONITOR 
516d cd c6 18			call break_point_state  
5170				endm  
# End of macro CALLMONITOR
5170				endif 
5170					FORTH_DSP_POP 
5170 cd e9 21			call macro_forth_dsp_pop 
5173				endm 
# End of macro FORTH_DSP_POP
5173			 
5173					FORTH_DSP_VALUEHL 
5173 cd 31 21			call macro_dsp_valuehl 
5176				endm 
# End of macro FORTH_DSP_VALUEHL
5176					;v5 FORTH_DSP_VALUE 
5176 e5					push hl 	; save ptr to string to save 
5177			 
5177				if DEBUG_STORESE 
5177					DMARK "AP1" 
5177 f5				push af  
5178 3a 8c 51			ld a, (.dmark)  
517b 32 b4 fe			ld (debug_mark),a  
517e 3a 8d 51			ld a, (.dmark+1)  
5181 32 b5 fe			ld (debug_mark+1),a  
5184 3a 8e 51			ld a, (.dmark+2)  
5187 32 b6 fe			ld (debug_mark+2),a  
518a 18 03			jr .pastdmark  
518c ..			.dmark: db "AP1"  
518f f1			.pastdmark: pop af  
5190			endm  
# End of macro DMARK
5190					CALLMONITOR 
5190 cd c6 18			call break_point_state  
5193				endm  
# End of macro CALLMONITOR
5193				endif 
5193					FORTH_DSP_POP 
5193 cd e9 21			call macro_forth_dsp_pop 
5196				endm 
# End of macro FORTH_DSP_POP
5196			 
5196 d1					pop de 
5197 e1					pop hl 
5198				if DEBUG_STORESE 
5198					DMARK "AP2" 
5198 f5				push af  
5199 3a ad 51			ld a, (.dmark)  
519c 32 b4 fe			ld (debug_mark),a  
519f 3a ae 51			ld a, (.dmark+1)  
51a2 32 b5 fe			ld (debug_mark+1),a  
51a5 3a af 51			ld a, (.dmark+2)  
51a8 32 b6 fe			ld (debug_mark+2),a  
51ab 18 03			jr .pastdmark  
51ad ..			.dmark: db "AP2"  
51b0 f1			.pastdmark: pop af  
51b1			endm  
# End of macro DMARK
51b1					CALLMONITOR 
51b1 cd c6 18			call break_point_state  
51b4				endm  
# End of macro CALLMONITOR
51b4				endif 
51b4					;inc de ; skip var type indicator 
51b4			 
51b4					; TODO how to append numerics???? 
51b4			 
51b4 cd 09 0b				call storage_append		 
51b7			 
51b7				       NEXTW 
51b7 c3 e7 22			jp macro_next 
51ba				endm 
# End of macro NEXTW
51ba			.SDEL: 
51ba				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
51ba 6a				db WORD_SYS_CORE+86             
51bb 06 52			dw .OPEN            
51bd 05				db 4 + 1 
51be .. 00			db "ERA",0              
51c2				endm 
# End of macro CWHEAD
51c2			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
51c2			; | | Compatible with PicoSPINet  
51c2					FORTH_DSP_VALUEHL 
51c2 cd 31 21			call macro_dsp_valuehl 
51c5				endm 
# End of macro FORTH_DSP_VALUEHL
51c5			;		push hl 	; save file id 
51c5			 
51c5					if DEBUG_FORTH_WORDS_KEY 
51c5						DMARK "ERA" 
51c5 f5				push af  
51c6 3a da 51			ld a, (.dmark)  
51c9 32 b4 fe			ld (debug_mark),a  
51cc 3a db 51			ld a, (.dmark+1)  
51cf 32 b5 fe			ld (debug_mark+1),a  
51d2 3a dc 51			ld a, (.dmark+2)  
51d5 32 b6 fe			ld (debug_mark+2),a  
51d8 18 03			jr .pastdmark  
51da ..			.dmark: db "ERA"  
51dd f1			.pastdmark: pop af  
51de			endm  
# End of macro DMARK
51de						CALLMONITOR 
51de cd c6 18			call break_point_state  
51e1				endm  
# End of macro CALLMONITOR
51e1					endif 
51e1				if DEBUG_STORESE 
51e1					DMARK "ER1" 
51e1 f5				push af  
51e2 3a f6 51			ld a, (.dmark)  
51e5 32 b4 fe			ld (debug_mark),a  
51e8 3a f7 51			ld a, (.dmark+1)  
51eb 32 b5 fe			ld (debug_mark+1),a  
51ee 3a f8 51			ld a, (.dmark+2)  
51f1 32 b6 fe			ld (debug_mark+2),a  
51f4 18 03			jr .pastdmark  
51f6 ..			.dmark: db "ER1"  
51f9 f1			.pastdmark: pop af  
51fa			endm  
# End of macro DMARK
51fa					CALLMONITOR 
51fa cd c6 18			call break_point_state  
51fd				endm  
# End of macro CALLMONITOR
51fd				endif 
51fd					FORTH_DSP_POP 
51fd cd e9 21			call macro_forth_dsp_pop 
5200				endm 
# End of macro FORTH_DSP_POP
5200			 
5200			;		pop hl 
5200			 
5200 cd 5b 06				call storage_erase 
5203				       NEXTW 
5203 c3 e7 22			jp macro_next 
5206				endm 
# End of macro NEXTW
5206			 
5206			.OPEN: 
5206				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5206 6b				db WORD_SYS_CORE+87             
5207 9a 52			dw .READ            
5209 05				db 4 + 1 
520a .. 00			db "OPEN",0              
520f				endm 
# End of macro CWHEAD
520f			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
520f			; | | e.g. 
520f			; | | $01 OPEN $01 DO $01 READ . LOOP 
520f			; | | 
520f			; | | Will return with 255 blocks if the file does not exist 
520f			; | | Compatible with PicoSPINet  
520f			 
520f					if DEBUG_FORTH_WORDS_KEY 
520f						DMARK "OPN" 
520f f5				push af  
5210 3a 24 52			ld a, (.dmark)  
5213 32 b4 fe			ld (debug_mark),a  
5216 3a 25 52			ld a, (.dmark+1)  
5219 32 b5 fe			ld (debug_mark+1),a  
521c 3a 26 52			ld a, (.dmark+2)  
521f 32 b6 fe			ld (debug_mark+2),a  
5222 18 03			jr .pastdmark  
5224 ..			.dmark: db "OPN"  
5227 f1			.pastdmark: pop af  
5228			endm  
# End of macro DMARK
5228						CALLMONITOR 
5228 cd c6 18			call break_point_state  
522b				endm  
# End of macro CALLMONITOR
522b					endif 
522b					; TODO handle multiple file opens 
522b			 
522b 3e 01			       	ld a, 1 
522d 32 f7 fb				ld (store_openext), a 
5230			 
5230					; get max extents for this file 
5230				 
5230								 
5230					FORTH_DSP_VALUEHL 
5230 cd 31 21			call macro_dsp_valuehl 
5233				endm 
# End of macro FORTH_DSP_VALUEHL
5233			 
5233 65					ld h, l 
5234 2e 00				ld l, 0 
5236			 
5236					; store file id 
5236			 
5236 7c					ld a, h 
5237 32 f4 fb				ld (store_filecache), a 
523a			 
523a				if DEBUG_STORESE 
523a					DMARK "OPN" 
523a f5				push af  
523b 3a 4f 52			ld a, (.dmark)  
523e 32 b4 fe			ld (debug_mark),a  
5241 3a 50 52			ld a, (.dmark+1)  
5244 32 b5 fe			ld (debug_mark+1),a  
5247 3a 51 52			ld a, (.dmark+2)  
524a 32 b6 fe			ld (debug_mark+2),a  
524d 18 03			jr .pastdmark  
524f ..			.dmark: db "OPN"  
5252 f1			.pastdmark: pop af  
5253			endm  
# End of macro DMARK
5253					CALLMONITOR 
5253 cd c6 18			call break_point_state  
5256				endm  
# End of macro CALLMONITOR
5256				endif 
5256			;		push hl 
5256					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5256 cd e9 21			call macro_forth_dsp_pop 
5259				endm 
# End of macro FORTH_DSP_POP
5259			;		pop hl 
5259						 
5259 11 07 fc				ld de, store_page      ; get block zero of file 
525c cd 72 09				call storage_read 
525f cd 72 0f			call ishlzero 
5262 20 04			jr nz, .opfound 
5264			 
5264				; file does not exist so indicate with 255 extents in use 
5264			 
5264 3e ff			ld a, 255 
5266 18 29			jr .skipopeneof 
5268			 
5268			 
5268			.opfound: 
5268			 
5268			 
5268 3a 09 fc				ld a, (store_page+2)    ; max extents for this file 
526b 32 f6 fb				ld  (store_openmaxext), a   ; get our limit and push 
526e					 
526e				if DEBUG_STORESE 
526e					DMARK "OPx" 
526e f5				push af  
526f 3a 83 52			ld a, (.dmark)  
5272 32 b4 fe			ld (debug_mark),a  
5275 3a 84 52			ld a, (.dmark+1)  
5278 32 b5 fe			ld (debug_mark+1),a  
527b 3a 85 52			ld a, (.dmark+2)  
527e 32 b6 fe			ld (debug_mark+2),a  
5281 18 03			jr .pastdmark  
5283 ..			.dmark: db "OPx"  
5286 f1			.pastdmark: pop af  
5287			endm  
# End of macro DMARK
5287					CALLMONITOR 
5287 cd c6 18			call break_point_state  
528a				endm  
# End of macro CALLMONITOR
528a				endif 
528a fe 00				cp 0 
528c 20 03				jr nz, .skipopeneof 
528e					; have opened an empty file 
528e					 
528e 32 f7 fb				ld (store_openext), a 
5291			 
5291			.skipopeneof: 
5291			 
5291 6f					ld l, a 
5292 26 00				ld h, 0 
5294 cd 3a 1f				call forth_push_numhl 
5297			 
5297			 
5297				       NEXTW 
5297 c3 e7 22			jp macro_next 
529a				endm 
# End of macro NEXTW
529a			.READ: 
529a				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
529a 6c				db WORD_SYS_CORE+88             
529b c4 53			dw .EOF            
529d 05				db 4 + 1 
529e .. 00			db "READ",0              
52a3				endm 
# End of macro CWHEAD
52a3			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
52a3			; | | e.g. 
52a3			; | | $01 OPEN $01 DO READ . LOOP 
52a3			; | | 
52a3			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
52a3			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
52a3			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
52a3			; | | two bytes contain the file id and extent. 
52a3			; | |  
52a3			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
52a3			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
52a3			; | | Compatible with PicoSPINet  
52a3			 
52a3					if DEBUG_FORTH_WORDS_KEY 
52a3						DMARK "REA" 
52a3 f5				push af  
52a4 3a b8 52			ld a, (.dmark)  
52a7 32 b4 fe			ld (debug_mark),a  
52aa 3a b9 52			ld a, (.dmark+1)  
52ad 32 b5 fe			ld (debug_mark+1),a  
52b0 3a ba 52			ld a, (.dmark+2)  
52b3 32 b6 fe			ld (debug_mark+2),a  
52b6 18 03			jr .pastdmark  
52b8 ..			.dmark: db "REA"  
52bb f1			.pastdmark: pop af  
52bc			endm  
# End of macro DMARK
52bc						CALLMONITOR 
52bc cd c6 18			call break_point_state  
52bf				endm  
# End of macro CALLMONITOR
52bf					endif 
52bf					; store_openext use it. If zero it is EOF 
52bf			 
52bf					; read block from current stream id 
52bf					; if the block does not contain zero term keep reading blocks until zero found 
52bf					; push the block to stack 
52bf					; save the block id to stream 
52bf			 
52bf			 
52bf cd f1 53				call .testeof 
52c2 3e 01				ld a, 1 
52c4 bd					cp l 
52c5 ca a0 53				jp z, .ateof 
52c8			 
52c8			 
52c8			;		FORTH_DSP_VALUEHL 
52c8			 
52c8			;		push hl 
52c8			 
52c8			;	if DEBUG_STORESE 
52c8			;		DMARK "REA" 
52c8			;		CALLMONITOR 
52c8			;	endif 
52c8			;		FORTH_DSP_POP 
52c8			 
52c8			;		pop hl 
52c8				 
52c8 3a f4 fb				ld a, (store_filecache) 
52cb 67					ld h,a 
52cc			 
52cc 3a f7 fb				ld a, (store_openext) 
52cf 6f					ld l, a 
52d0					 
52d0 fe 00				cp 0 
52d2 ca a0 53				jp z, .ateof     ; dont read past eof 
52d5			 
52d5 cd 55 0c				call storage_clear_page 
52d8			 
52d8 11 07 fc				ld de, store_page 
52db				if DEBUG_STORESE 
52db					DMARK "RE1" 
52db f5				push af  
52dc 3a f0 52			ld a, (.dmark)  
52df 32 b4 fe			ld (debug_mark),a  
52e2 3a f1 52			ld a, (.dmark+1)  
52e5 32 b5 fe			ld (debug_mark+1),a  
52e8 3a f2 52			ld a, (.dmark+2)  
52eb 32 b6 fe			ld (debug_mark+2),a  
52ee 18 03			jr .pastdmark  
52f0 ..			.dmark: db "RE1"  
52f3 f1			.pastdmark: pop af  
52f4			endm  
# End of macro DMARK
52f4					CALLMONITOR 
52f4 cd c6 18			call break_point_state  
52f7				endm  
# End of macro CALLMONITOR
52f7				endif 
52f7 cd 72 09				call storage_read 
52fa			 
52fa				if DEBUG_STORESE 
52fa					DMARK "RE2" 
52fa f5				push af  
52fb 3a 0f 53			ld a, (.dmark)  
52fe 32 b4 fe			ld (debug_mark),a  
5301 3a 10 53			ld a, (.dmark+1)  
5304 32 b5 fe			ld (debug_mark+1),a  
5307 3a 11 53			ld a, (.dmark+2)  
530a 32 b6 fe			ld (debug_mark+2),a  
530d 18 03			jr .pastdmark  
530f ..			.dmark: db "RE2"  
5312 f1			.pastdmark: pop af  
5313			endm  
# End of macro DMARK
5313					CALLMONITOR 
5313 cd c6 18			call break_point_state  
5316				endm  
# End of macro CALLMONITOR
5316				endif 
5316 cd 72 0f			call ishlzero 
5319			;	ld a, l 
5319			;	add h 
5319			;	cp 0 
5319 ca a0 53			jp z, .readeof 
531c			 
531c				; not eof so hl should point to data to push to stack 
531c			 
531c				if DEBUG_STORESE 
531c					DMARK "RE3" 
531c f5				push af  
531d 3a 31 53			ld a, (.dmark)  
5320 32 b4 fe			ld (debug_mark),a  
5323 3a 32 53			ld a, (.dmark+1)  
5326 32 b5 fe			ld (debug_mark+1),a  
5329 3a 33 53			ld a, (.dmark+2)  
532c 32 b6 fe			ld (debug_mark+2),a  
532f 18 03			jr .pastdmark  
5331 ..			.dmark: db "RE3"  
5334 f1			.pastdmark: pop af  
5335			endm  
# End of macro DMARK
5335					CALLMONITOR 
5335 cd c6 18			call break_point_state  
5338				endm  
# End of macro CALLMONITOR
5338				endif 
5338 cd a8 1f			call forth_push_str 
533b			 
533b				if DEBUG_STORESE 
533b					DMARK "RE4" 
533b f5				push af  
533c 3a 50 53			ld a, (.dmark)  
533f 32 b4 fe			ld (debug_mark),a  
5342 3a 51 53			ld a, (.dmark+1)  
5345 32 b5 fe			ld (debug_mark+1),a  
5348 3a 52 53			ld a, (.dmark+2)  
534b 32 b6 fe			ld (debug_mark+2),a  
534e 18 03			jr .pastdmark  
5350 ..			.dmark: db "RE4"  
5353 f1			.pastdmark: pop af  
5354			endm  
# End of macro DMARK
5354					CALLMONITOR 
5354 cd c6 18			call break_point_state  
5357				endm  
# End of macro CALLMONITOR
5357				endif 
5357				; get next block  or mark as eof 
5357			 
5357 3a f6 fb			ld a, (store_openmaxext)   ; get our limit 
535a 4f				ld c, a	 
535b 3a f7 fb			ld a, (store_openext) 
535e			 
535e				if DEBUG_STORESE 
535e					DMARK "RE5" 
535e f5				push af  
535f 3a 73 53			ld a, (.dmark)  
5362 32 b4 fe			ld (debug_mark),a  
5365 3a 74 53			ld a, (.dmark+1)  
5368 32 b5 fe			ld (debug_mark+1),a  
536b 3a 75 53			ld a, (.dmark+2)  
536e 32 b6 fe			ld (debug_mark+2),a  
5371 18 03			jr .pastdmark  
5373 ..			.dmark: db "RE5"  
5376 f1			.pastdmark: pop af  
5377			endm  
# End of macro DMARK
5377					CALLMONITOR 
5377 cd c6 18			call break_point_state  
537a				endm  
# End of macro CALLMONITOR
537a				endif 
537a b9				cp c 
537b 28 23			jr z, .readeof     ; at last extent 
537d			 
537d 3c					inc a 
537e 32 f7 fb				ld (store_openext), a 
5381			 
5381				if DEBUG_STORESE 
5381					DMARK "RE6" 
5381 f5				push af  
5382 3a 96 53			ld a, (.dmark)  
5385 32 b4 fe			ld (debug_mark),a  
5388 3a 97 53			ld a, (.dmark+1)  
538b 32 b5 fe			ld (debug_mark+1),a  
538e 3a 98 53			ld a, (.dmark+2)  
5391 32 b6 fe			ld (debug_mark+2),a  
5394 18 03			jr .pastdmark  
5396 ..			.dmark: db "RE6"  
5399 f1			.pastdmark: pop af  
539a			endm  
# End of macro DMARK
539a					CALLMONITOR 
539a cd c6 18			call break_point_state  
539d				endm  
# End of macro CALLMONITOR
539d				endif 
539d			 
539d			 
539d				       NEXTW 
539d c3 e7 22			jp macro_next 
53a0				endm 
# End of macro NEXTW
53a0			.ateof: 
53a0				;	ld hl, .showeof 
53a0				;	call forth_push_str 
53a0 3e 00		.readeof:	ld a, 0 
53a2 32 f7 fb				ld (store_openext), a 
53a5			 
53a5					 
53a5				if DEBUG_STORESE 
53a5					DMARK "REF" 
53a5 f5				push af  
53a6 3a ba 53			ld a, (.dmark)  
53a9 32 b4 fe			ld (debug_mark),a  
53ac 3a bb 53			ld a, (.dmark+1)  
53af 32 b5 fe			ld (debug_mark+1),a  
53b2 3a bc 53			ld a, (.dmark+2)  
53b5 32 b6 fe			ld (debug_mark+2),a  
53b8 18 03			jr .pastdmark  
53ba ..			.dmark: db "REF"  
53bd f1			.pastdmark: pop af  
53be			endm  
# End of macro DMARK
53be					CALLMONITOR 
53be cd c6 18			call break_point_state  
53c1				endm  
# End of macro CALLMONITOR
53c1				endif 
53c1				       NEXTW 
53c1 c3 e7 22			jp macro_next 
53c4				endm 
# End of macro NEXTW
53c4			 
53c4			;.showeof:   db "eof", 0 
53c4			 
53c4			 
53c4			.EOF: 
53c4				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
53c4 6d				db WORD_SYS_CORE+89             
53c5 06 54			dw .FORMAT            
53c7 04				db 3 + 1 
53c8 .. 00			db "EOF",0              
53cc				endm 
# End of macro CWHEAD
53cc			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
53cc			; | | e.g. 
53cc			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
53cc			; | | Compatible with PicoSPINet  
53cc					; TODO if current block id for stream is zero then push true else false 
53cc			 
53cc					if DEBUG_FORTH_WORDS_KEY 
53cc						DMARK "EOF" 
53cc f5				push af  
53cd 3a e1 53			ld a, (.dmark)  
53d0 32 b4 fe			ld (debug_mark),a  
53d3 3a e2 53			ld a, (.dmark+1)  
53d6 32 b5 fe			ld (debug_mark+1),a  
53d9 3a e3 53			ld a, (.dmark+2)  
53dc 32 b6 fe			ld (debug_mark+2),a  
53df 18 03			jr .pastdmark  
53e1 ..			.dmark: db "EOF"  
53e4 f1			.pastdmark: pop af  
53e5			endm  
# End of macro DMARK
53e5						CALLMONITOR 
53e5 cd c6 18			call break_point_state  
53e8				endm  
# End of macro CALLMONITOR
53e8					endif 
53e8			 
53e8					; TODO handlue multiple file streams 
53e8			 
53e8			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
53e8 cd f1 53				call .testeof 
53eb cd 3a 1f				call forth_push_numhl 
53ee			 
53ee			 
53ee				       NEXTW 
53ee c3 e7 22			jp macro_next 
53f1				endm 
# End of macro NEXTW
53f1			 
53f1			.testeof: 
53f1 2e 01				ld l, 1 
53f3 3a f6 fb				ld a, (store_openmaxext) 
53f6 fe 00				cp 0 
53f8 28 09				jr  z, .eofdone   ; empty file 
53fa 3a f7 fb				ld a, (store_openext) 
53fd fe 00				cp 0 
53ff 28 02				jr  z, .eofdone 
5401 2e 00				ld l, 0 
5403 26 00		.eofdone:	ld h, 0 
5405 c9					ret 
5406			 
5406			 
5406			 
5406			 
5406			.FORMAT: 
5406				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5406 6d				db WORD_SYS_CORE+89             
5407 57 54			dw .LABEL            
5409 07				db 6 + 1 
540a .. 00			db "FORMAT",0              
5411				endm 
# End of macro CWHEAD
5411			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5411			; | | Compatible with PicoSPINet  
5411					; TODO if current block id for stream is zero then push true else false 
5411				 
5411				if DEBUG_STORESE 
5411					DMARK "FOR" 
5411 f5				push af  
5412 3a 26 54			ld a, (.dmark)  
5415 32 b4 fe			ld (debug_mark),a  
5418 3a 27 54			ld a, (.dmark+1)  
541b 32 b5 fe			ld (debug_mark+1),a  
541e 3a 28 54			ld a, (.dmark+2)  
5421 32 b6 fe			ld (debug_mark+2),a  
5424 18 03			jr .pastdmark  
5426 ..			.dmark: db "FOR"  
5429 f1			.pastdmark: pop af  
542a			endm  
# End of macro DMARK
542a					CALLMONITOR 
542a cd c6 18			call break_point_state  
542d				endm  
# End of macro CALLMONITOR
542d				endif 
542d					; Wipes the bank check flags to cause a reformat on next block 0 read 
542d			 
542d 21 01 00				ld hl, 1 
5430 3e 00				ld a, 0 
5432 cd 1e 02				call se_writebyte 
5435			 
5435				if DEBUG_STORESE 
5435					DMARK "FO0" 
5435 f5				push af  
5436 3a 4a 54			ld a, (.dmark)  
5439 32 b4 fe			ld (debug_mark),a  
543c 3a 4b 54			ld a, (.dmark+1)  
543f 32 b5 fe			ld (debug_mark+1),a  
5442 3a 4c 54			ld a, (.dmark+2)  
5445 32 b6 fe			ld (debug_mark+2),a  
5448 18 03			jr .pastdmark  
544a ..			.dmark: db "FO0"  
544d f1			.pastdmark: pop af  
544e			endm  
# End of macro DMARK
544e					CALLMONITOR 
544e cd c6 18			call break_point_state  
5451				endm  
# End of macro CALLMONITOR
5451				endif 
5451					; force bank init 
5451			 
5451 cd ca 04				call storage_get_block_0 
5454					 
5454				       NEXTW 
5454 c3 e7 22			jp macro_next 
5457				endm 
# End of macro NEXTW
5457			.LABEL: 
5457				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5457 6d				db WORD_SYS_CORE+89             
5458 a5 54			dw .STOREPAGE            
545a 06				db 5 + 1 
545b .. 00			db "LABEL",0              
5461				endm 
# End of macro CWHEAD
5461			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5461			; | | Compatible with PicoSPINet  
5461					; TODO test to see if bank is selected 
5461				 
5461					if DEBUG_FORTH_WORDS_KEY 
5461						DMARK "LBL" 
5461 f5				push af  
5462 3a 76 54			ld a, (.dmark)  
5465 32 b4 fe			ld (debug_mark),a  
5468 3a 77 54			ld a, (.dmark+1)  
546b 32 b5 fe			ld (debug_mark+1),a  
546e 3a 78 54			ld a, (.dmark+2)  
5471 32 b6 fe			ld (debug_mark+2),a  
5474 18 03			jr .pastdmark  
5476 ..			.dmark: db "LBL"  
5479 f1			.pastdmark: pop af  
547a			endm  
# End of macro DMARK
547a						CALLMONITOR 
547a cd c6 18			call break_point_state  
547d				endm  
# End of macro CALLMONITOR
547d					endif 
547d			;	if DEBUG_STORESE 
547d			;		DMARK "LBL" 
547d			;		CALLMONITOR 
547d			;	endif 
547d					FORTH_DSP_VALUEHL 
547d cd 31 21			call macro_dsp_valuehl 
5480				endm 
# End of macro FORTH_DSP_VALUEHL
5480					;v5FORTH_DSP_VALUE 
5480					 
5480			;		push hl 
5480					FORTH_DSP_POP 
5480 cd e9 21			call macro_forth_dsp_pop 
5483				endm 
# End of macro FORTH_DSP_POP
5483			;		pop hl 
5483			 
5483			;v5		inc hl   ; move past the type marker 
5483			 
5483				if DEBUG_STORESE 
5483					DMARK "LBl" 
5483 f5				push af  
5484 3a 98 54			ld a, (.dmark)  
5487 32 b4 fe			ld (debug_mark),a  
548a 3a 99 54			ld a, (.dmark+1)  
548d 32 b5 fe			ld (debug_mark+1),a  
5490 3a 9a 54			ld a, (.dmark+2)  
5493 32 b6 fe			ld (debug_mark+2),a  
5496 18 03			jr .pastdmark  
5498 ..			.dmark: db "LBl"  
549b f1			.pastdmark: pop af  
549c			endm  
# End of macro DMARK
549c					CALLMONITOR 
549c cd c6 18			call break_point_state  
549f				endm  
# End of macro CALLMONITOR
549f				endif 
549f cd ee 05				call storage_label 
54a2			 
54a2				       NEXTW 
54a2 c3 e7 22			jp macro_next 
54a5				endm 
# End of macro NEXTW
54a5			.STOREPAGE: 
54a5				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
54a5 6d				db WORD_SYS_CORE+89             
54a6 d8 54			dw .LABELS            
54a8 0a				db 9 + 1 
54a9 .. 00			db "STOREPAGE",0              
54b3				endm 
# End of macro CWHEAD
54b3			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
54b3			; | | Compatible with PicoSPINet  
54b3					; TODO test to see if bank is selected 
54b3				 
54b3					if DEBUG_FORTH_WORDS_KEY 
54b3						DMARK "STP" 
54b3 f5				push af  
54b4 3a c8 54			ld a, (.dmark)  
54b7 32 b4 fe			ld (debug_mark),a  
54ba 3a c9 54			ld a, (.dmark+1)  
54bd 32 b5 fe			ld (debug_mark+1),a  
54c0 3a ca 54			ld a, (.dmark+2)  
54c3 32 b6 fe			ld (debug_mark+2),a  
54c6 18 03			jr .pastdmark  
54c8 ..			.dmark: db "STP"  
54cb f1			.pastdmark: pop af  
54cc			endm  
# End of macro DMARK
54cc						CALLMONITOR 
54cc cd c6 18			call break_point_state  
54cf				endm  
# End of macro CALLMONITOR
54cf					endif 
54cf			;	if DEBUG_STORESE 
54cf			;		DMARK "STP" 
54cf			;		CALLMONITOR 
54cf			;	endif 
54cf			 
54cf 21 07 fc			ld hl, store_page 
54d2 cd 3a 1f			call forth_push_numhl 
54d5			 
54d5			 
54d5				       NEXTW 
54d5 c3 e7 22			jp macro_next 
54d8				endm 
# End of macro NEXTW
54d8			.LABELS: 
54d8				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
54d8 6d				db WORD_SYS_CORE+89             
54d9 62 55			dw .SCONST1            
54db 07				db 6 + 1 
54dc .. 00			db "LABELS",0              
54e3				endm 
# End of macro CWHEAD
54e3			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
54e3			; | | *NOT* Compatible with PicoSPINet  
54e3					;  
54e3			 
54e3					; save the current device selected to restore afterwards 
54e3				 
54e3 3a ed fb				ld a, (spi_device) 
54e6 f5					push af 
54e7			 
54e7			 
54e7					; run through each of the banks 
54e7			 
54e7 21 01 00				ld hl, 1 
54ea cd 3a 1f				call forth_push_numhl 
54ed 3e ff				ld a, SPI_CE_HIGH 
54ef cb 87				res SPI_CE0, a 
54f1 32 ed fb				ld (spi_device), a 
54f4 cd ca 04				call storage_get_block_0 
54f7 21 0a fc				ld hl, store_page+3 
54fa cd a8 1f				call forth_push_str 
54fd			 
54fd					 
54fd 21 02 00				ld hl, 2 
5500 cd 3a 1f				call forth_push_numhl 
5503 3e ff				ld a, SPI_CE_HIGH 
5505 cb 8f				res SPI_CE1, a 
5507 32 ed fb				ld (spi_device), a 
550a cd ca 04				call storage_get_block_0 
550d 21 0a fc				ld hl, store_page+3 
5510 cd a8 1f				call forth_push_str 
5513			 
5513					 
5513 21 03 00				ld hl, 3 
5516 cd 3a 1f				call forth_push_numhl 
5519 3e ff				ld a, SPI_CE_HIGH 
551b cb 97				res SPI_CE2, a 
551d 32 ed fb				ld (spi_device), a 
5520 cd ca 04				call storage_get_block_0 
5523 21 0a fc				ld hl, store_page+3 
5526 cd a8 1f				call forth_push_str 
5529			 
5529			 
5529 21 04 00				ld hl, 4 
552c cd 3a 1f				call forth_push_numhl 
552f 3e ff				ld a, SPI_CE_HIGH 
5531 cb 9f				res SPI_CE3, a 
5533 32 ed fb				ld (spi_device), a 
5536 cd ca 04				call storage_get_block_0 
5539 21 0a fc				ld hl, store_page+3 
553c cd a8 1f				call forth_push_str 
553f			 
553f					 
553f			 
553f 21 05 00				ld hl, 5 
5542 cd 3a 1f				call forth_push_numhl 
5545 3e ff				ld a, SPI_CE_HIGH 
5547 cb a7				res SPI_CE4, a 
5549 32 ed fb				ld (spi_device), a 
554c cd ca 04				call storage_get_block_0 
554f 21 0a fc				ld hl, store_page+3 
5552 cd a8 1f				call forth_push_str 
5555			 
5555					 
5555					; push fixed count of storage devices (on board) for now 
5555			 
5555 21 05 00				ld hl, 5 
5558 cd 3a 1f				call forth_push_numhl 
555b			 
555b					; restore selected device  
555b				 
555b f1					pop af 
555c 32 ed fb				ld (spi_device), a 
555f			 
555f				       NEXTW 
555f c3 e7 22			jp macro_next 
5562				endm 
# End of macro NEXTW
5562			 
5562			.SCONST1: 
5562				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5562 6d				db WORD_SYS_CORE+89             
5563 79 55			dw .SCONST2            
5565 07				db 6 + 1 
5566 .. 00			db "FILEID",0              
556d				endm 
# End of macro CWHEAD
556d			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
556d			; | | Compatible with PicoSPINet  
556d 3a f4 fb				ld a, (store_filecache) 
5570 26 00				ld h, 0 
5572 6f					ld l, a 
5573 cd 3a 1f				call forth_push_numhl 
5576					NEXTW 
5576 c3 e7 22			jp macro_next 
5579				endm 
# End of macro NEXTW
5579			.SCONST2: 
5579				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5579 6d				db WORD_SYS_CORE+89             
557a 91 55			dw .SCONST3            
557c 08				db 7 + 1 
557d .. 00			db "FILEEXT",0              
5585				endm 
# End of macro CWHEAD
5585			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5585			; | | Compatible with PicoSPINet  
5585 3a f7 fb				ld a, (store_openext) 
5588 26 00				ld h, 0 
558a 6f					ld l, a 
558b cd 3a 1f				call forth_push_numhl 
558e					NEXTW 
558e c3 e7 22			jp macro_next 
5591				endm 
# End of macro NEXTW
5591			.SCONST3: 
5591				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5591 6d				db WORD_SYS_CORE+89             
5592 a9 55			dw .SCONST4            
5594 08				db 7 + 1 
5595 .. 00			db "FILEMAX",0              
559d				endm 
# End of macro CWHEAD
559d			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
559d			; | | Compatible with PicoSPINet  
559d 3a f6 fb				ld a, (store_openmaxext) 
55a0 26 00				ld h, 0 
55a2 6f					ld l, a 
55a3 cd 3a 1f				call forth_push_numhl 
55a6					NEXTW 
55a6 c3 e7 22			jp macro_next 
55a9				endm 
# End of macro NEXTW
55a9			.SCONST4: 
55a9				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
55a9 6d				db WORD_SYS_CORE+89             
55aa bf 55			dw .SCONST5            
55ac 09				db 8 + 1 
55ad .. 00			db "FILEADDR",0              
55b6				endm 
# End of macro CWHEAD
55b6			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
55b6			; | | Compatible with PicoSPINet  
55b6 2a f8 fb				ld hl, (store_openaddr) 
55b9 cd 3a 1f				call forth_push_numhl 
55bc					NEXTW 
55bc c3 e7 22			jp macro_next 
55bf				endm 
# End of macro NEXTW
55bf			.SCONST5: 
55bf				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
55bf 6d				db WORD_SYS_CORE+89             
55c0 e0 55			dw .SCONST6            
55c2 09				db 8 + 1 
55c3 .. 00			db "FILEPAGE",0              
55cc				endm 
# End of macro CWHEAD
55cc			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
55cc			; | | Compatible with PicoSPINet  
55cc 2a f8 fb				ld hl, (store_openaddr) 
55cf e5					push hl 
55d0 c1					pop bc 
55d1 16 00				ld d, 0 
55d3 1e 40				ld e, STORE_BLOCK_PHY 
55d5 cd a6 0e				call Div16 
55d8 c5					push bc 
55d9 e1					pop hl 
55da cd 3a 1f				call forth_push_numhl 
55dd					NEXTW 
55dd c3 e7 22			jp macro_next 
55e0				endm 
# End of macro NEXTW
55e0			.SCONST6: 
55e0				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
55e0 6d				db WORD_SYS_CORE+89             
55e1 f9 55			dw .ENDSTORAGE            
55e3 09				db 8 + 1 
55e4 .. 00			db "READCONT",0              
55ed				endm 
# End of macro CWHEAD
55ed			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
55ed			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
55ed			; | | a further read should, if applicable, be CONCAT to the previous read. 
55ed			; | | Compatible with PicoSPINet  
55ed 3a fa fb				ld a, (store_readcont) 
55f0 26 00				ld h, 0 
55f2 6f					ld l, a 
55f3 cd 3a 1f				call forth_push_numhl 
55f6					NEXTW 
55f6 c3 e7 22			jp macro_next 
55f9				endm 
# End of macro NEXTW
55f9			.ENDSTORAGE: 
55f9			; eof 
# End of file forth_words_storage.asm
55f9			endif 
55f9				include "forth_words_device.asm" 
55f9			; Device related words 
55f9			 
55f9			; | ## Device Words 
55f9			 
55f9			;if SOUND_ENABLE 
55f9			;.NOTE: 
55f9			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
55f9			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
55f9			;		if DEBUG_FORTH_WORDS_KEY 
55f9			;			DMARK "NTE" 
55f9			;			CALLMONITOR 
55f9			;		endif 
55f9			; 
55f9			;	 
55f9			; 
55f9			;		NEXTW 
55f9			;.AFTERSOUND: 
55f9			;endif 
55f9			 
55f9			 
55f9			USE_GPIO: equ 0 
55f9			 
55f9			if USE_GPIO 
55f9			.GP1: 
55f9				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
55f9			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
55f9					NEXTW 
55f9			.GP2: 
55f9				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
55f9			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
55f9			 
55f9					NEXTW 
55f9			 
55f9			.GP3: 
55f9				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
55f9			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
55f9			 
55f9					NEXTW 
55f9			 
55f9			.GP4: 
55f9				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
55f9			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
55f9			 
55f9					NEXTW 
55f9			.SIN: 
55f9			 
55f9			 
55f9			endif 
55f9			 
55f9			 
55f9				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
55f9 33				db WORD_SYS_CORE+31             
55fa 2e 56			dw .SOUT            
55fc 03				db 2 + 1 
55fd .. 00			db "IN",0              
5600				endm 
# End of macro CWHEAD
5600			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5600					if DEBUG_FORTH_WORDS_KEY 
5600						DMARK "IN." 
5600 f5				push af  
5601 3a 15 56			ld a, (.dmark)  
5604 32 b4 fe			ld (debug_mark),a  
5607 3a 16 56			ld a, (.dmark+1)  
560a 32 b5 fe			ld (debug_mark+1),a  
560d 3a 17 56			ld a, (.dmark+2)  
5610 32 b6 fe			ld (debug_mark+2),a  
5613 18 03			jr .pastdmark  
5615 ..			.dmark: db "IN."  
5618 f1			.pastdmark: pop af  
5619			endm  
# End of macro DMARK
5619						CALLMONITOR 
5619 cd c6 18			call break_point_state  
561c				endm  
# End of macro CALLMONITOR
561c					endif 
561c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
561c cd 31 21			call macro_dsp_valuehl 
561f				endm 
# End of macro FORTH_DSP_VALUEHL
561f			 
561f e5					push hl 
5620			 
5620					; destroy value TOS 
5620			 
5620					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5620 cd e9 21			call macro_forth_dsp_pop 
5623				endm 
# End of macro FORTH_DSP_POP
5623			 
5623					; one value on hl get other one back 
5623			 
5623 c1					pop bc 
5624			 
5624					; do the sub 
5624			;		ex de, hl 
5624			 
5624 ed 68				in l,(c) 
5626			 
5626					; save it 
5626			 
5626 26 00				ld h,0 
5628			 
5628					; TODO push value back onto stack for another op etc 
5628			 
5628 cd 3a 1f				call forth_push_numhl 
562b					NEXTW 
562b c3 e7 22			jp macro_next 
562e				endm 
# End of macro NEXTW
562e			.SOUT: 
562e				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
562e 34				db WORD_SYS_CORE+32             
562f 81 56			dw .SPIO            
5631 04				db 3 + 1 
5632 .. 00			db "OUT",0              
5636				endm 
# End of macro CWHEAD
5636			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5636					if DEBUG_FORTH_WORDS_KEY 
5636						DMARK "OUT" 
5636 f5				push af  
5637 3a 4b 56			ld a, (.dmark)  
563a 32 b4 fe			ld (debug_mark),a  
563d 3a 4c 56			ld a, (.dmark+1)  
5640 32 b5 fe			ld (debug_mark+1),a  
5643 3a 4d 56			ld a, (.dmark+2)  
5646 32 b6 fe			ld (debug_mark+2),a  
5649 18 03			jr .pastdmark  
564b ..			.dmark: db "OUT"  
564e f1			.pastdmark: pop af  
564f			endm  
# End of macro DMARK
564f						CALLMONITOR 
564f cd c6 18			call break_point_state  
5652				endm  
# End of macro CALLMONITOR
5652					endif 
5652			 
5652					; get port 
5652			 
5652					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5652 cd 31 21			call macro_dsp_valuehl 
5655				endm 
# End of macro FORTH_DSP_VALUEHL
5655			 
5655 e5					push hl 
5656			 
5656					; destroy value TOS 
5656			 
5656					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5656 cd e9 21			call macro_forth_dsp_pop 
5659				endm 
# End of macro FORTH_DSP_POP
5659			 
5659					; get byte to send 
5659			 
5659					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5659 cd 31 21			call macro_dsp_valuehl 
565c				endm 
# End of macro FORTH_DSP_VALUEHL
565c			 
565c			;		push hl 
565c			 
565c					; destroy value TOS 
565c			 
565c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
565c cd e9 21			call macro_forth_dsp_pop 
565f				endm 
# End of macro FORTH_DSP_POP
565f			 
565f					; one value on hl get other one back 
565f			 
565f			;		pop hl 
565f			 
565f c1					pop bc 
5660			 
5660					if DEBUG_FORTH_WORDS 
5660						DMARK "OUT" 
5660 f5				push af  
5661 3a 75 56			ld a, (.dmark)  
5664 32 b4 fe			ld (debug_mark),a  
5667 3a 76 56			ld a, (.dmark+1)  
566a 32 b5 fe			ld (debug_mark+1),a  
566d 3a 77 56			ld a, (.dmark+2)  
5670 32 b6 fe			ld (debug_mark+2),a  
5673 18 03			jr .pastdmark  
5675 ..			.dmark: db "OUT"  
5678 f1			.pastdmark: pop af  
5679			endm  
# End of macro DMARK
5679						CALLMONITOR 
5679 cd c6 18			call break_point_state  
567c				endm  
# End of macro CALLMONITOR
567c					endif 
567c			 
567c ed 69				out (c), l 
567e			 
567e					NEXTW 
567e c3 e7 22			jp macro_next 
5681				endm 
# End of macro NEXTW
5681			 
5681			 
5681			.SPIO: 
5681			 
5681			if STORAGE_SE 
5681				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5681 51				db WORD_SYS_CORE+61             
5682 92 56			dw .SPICEH            
5684 07				db 6 + 1 
5685 .. 00			db "SPICEL",0              
568c				endm 
# End of macro CWHEAD
568c			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
568c			 
568c cd c7 01				call spi_ce_low 
568f			    NEXTW 
568f c3 e7 22			jp macro_next 
5692				endm 
# End of macro NEXTW
5692			 
5692			.SPICEH: 
5692				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5692 51				db WORD_SYS_CORE+61             
5693 a3 56			dw .SPIOb            
5695 07				db 6 + 1 
5696 .. 00			db "SPICEH",0              
569d				endm 
# End of macro CWHEAD
569d			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
569d			 
569d cd b6 01				call spi_ce_high 
56a0			    NEXTW 
56a0 c3 e7 22			jp macro_next 
56a3				endm 
# End of macro NEXTW
56a3			 
56a3			 
56a3			.SPIOb: 
56a3			 
56a3				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
56a3 51				db WORD_SYS_CORE+61             
56a4 d5 56			dw .SPII            
56a6 05				db 4 + 1 
56a7 .. 00			db "SPIO",0              
56ac				endm 
# End of macro CWHEAD
56ac			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
56ac			 
56ac					if DEBUG_FORTH_WORDS_KEY 
56ac						DMARK "SPo" 
56ac f5				push af  
56ad 3a c1 56			ld a, (.dmark)  
56b0 32 b4 fe			ld (debug_mark),a  
56b3 3a c2 56			ld a, (.dmark+1)  
56b6 32 b5 fe			ld (debug_mark+1),a  
56b9 3a c3 56			ld a, (.dmark+2)  
56bc 32 b6 fe			ld (debug_mark+2),a  
56bf 18 03			jr .pastdmark  
56c1 ..			.dmark: db "SPo"  
56c4 f1			.pastdmark: pop af  
56c5			endm  
# End of macro DMARK
56c5						CALLMONITOR 
56c5 cd c6 18			call break_point_state  
56c8				endm  
# End of macro CALLMONITOR
56c8					endif 
56c8					; get port 
56c8			 
56c8			 
56c8					; get byte to send 
56c8			 
56c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
56c8 cd 31 21			call macro_dsp_valuehl 
56cb				endm 
# End of macro FORTH_DSP_VALUEHL
56cb			 
56cb			;		push hl    ; u1  
56cb			 
56cb					; destroy value TOS 
56cb			 
56cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
56cb cd e9 21			call macro_forth_dsp_pop 
56ce				endm 
# End of macro FORTH_DSP_POP
56ce			 
56ce					; one value on hl get other one back 
56ce			 
56ce			;		pop hl   ; u2 - addr 
56ce			 
56ce					; TODO Send SPI byte 
56ce			 
56ce			;		push hl 
56ce			;		call spi_ce_low 
56ce			;		pop hl 
56ce 7d					ld a, l 
56cf cd b5 00				call spi_send_byte 
56d2			;		call spi_ce_high 
56d2			 
56d2					NEXTW 
56d2 c3 e7 22			jp macro_next 
56d5				endm 
# End of macro NEXTW
56d5			 
56d5			.SPII: 
56d5				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
56d5 52				db WORD_SYS_CORE+62             
56d6 3e 57			dw .SESEL            
56d8 06				db 5 + 1 
56d9 .. 00			db "SPII",0              
56de				endm 
# End of macro CWHEAD
56de			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
56de					if DEBUG_FORTH_WORDS_KEY 
56de						DMARK "SPi" 
56de f5				push af  
56df 3a f3 56			ld a, (.dmark)  
56e2 32 b4 fe			ld (debug_mark),a  
56e5 3a f4 56			ld a, (.dmark+1)  
56e8 32 b5 fe			ld (debug_mark+1),a  
56eb 3a f5 56			ld a, (.dmark+2)  
56ee 32 b6 fe			ld (debug_mark+2),a  
56f1 18 03			jr .pastdmark  
56f3 ..			.dmark: db "SPi"  
56f6 f1			.pastdmark: pop af  
56f7			endm  
# End of macro DMARK
56f7						CALLMONITOR 
56f7 cd c6 18			call break_point_state  
56fa				endm  
# End of macro CALLMONITOR
56fa					endif 
56fa			 
56fa					; TODO Get SPI byte 
56fa			 
56fa cd dc 00				call spi_read_byte 
56fd			 
56fd					if DEBUG_FORTH_WORDS 
56fd						DMARK "Si2" 
56fd f5				push af  
56fe 3a 12 57			ld a, (.dmark)  
5701 32 b4 fe			ld (debug_mark),a  
5704 3a 13 57			ld a, (.dmark+1)  
5707 32 b5 fe			ld (debug_mark+1),a  
570a 3a 14 57			ld a, (.dmark+2)  
570d 32 b6 fe			ld (debug_mark+2),a  
5710 18 03			jr .pastdmark  
5712 ..			.dmark: db "Si2"  
5715 f1			.pastdmark: pop af  
5716			endm  
# End of macro DMARK
5716						CALLMONITOR 
5716 cd c6 18			call break_point_state  
5719				endm  
# End of macro CALLMONITOR
5719					endif 
5719 26 00				ld h, 0 
571b 6f					ld l, a 
571c					if DEBUG_FORTH_WORDS 
571c						DMARK "Si3" 
571c f5				push af  
571d 3a 31 57			ld a, (.dmark)  
5720 32 b4 fe			ld (debug_mark),a  
5723 3a 32 57			ld a, (.dmark+1)  
5726 32 b5 fe			ld (debug_mark+1),a  
5729 3a 33 57			ld a, (.dmark+2)  
572c 32 b6 fe			ld (debug_mark+2),a  
572f 18 03			jr .pastdmark  
5731 ..			.dmark: db "Si3"  
5734 f1			.pastdmark: pop af  
5735			endm  
# End of macro DMARK
5735						CALLMONITOR 
5735 cd c6 18			call break_point_state  
5738				endm  
# End of macro CALLMONITOR
5738					endif 
5738 cd 3a 1f				call forth_push_numhl 
573b			 
573b					NEXTW 
573b c3 e7 22			jp macro_next 
573e				endm 
# End of macro NEXTW
573e			 
573e			 
573e			 
573e			.SESEL: 
573e				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
573e 66				db WORD_SYS_CORE+82             
573f e7 57			dw .CARTDEV            
5741 05				db 4 + 1 
5742 .. 00			db "BANK",0              
5747				endm 
# End of macro CWHEAD
5747			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5747					if DEBUG_FORTH_WORDS_KEY 
5747						DMARK "BNK" 
5747 f5				push af  
5748 3a 5c 57			ld a, (.dmark)  
574b 32 b4 fe			ld (debug_mark),a  
574e 3a 5d 57			ld a, (.dmark+1)  
5751 32 b5 fe			ld (debug_mark+1),a  
5754 3a 5e 57			ld a, (.dmark+2)  
5757 32 b6 fe			ld (debug_mark+2),a  
575a 18 03			jr .pastdmark  
575c ..			.dmark: db "BNK"  
575f f1			.pastdmark: pop af  
5760			endm  
# End of macro DMARK
5760						CALLMONITOR 
5760 cd c6 18			call break_point_state  
5763				endm  
# End of macro CALLMONITOR
5763					endif 
5763			 
5763 3e ff				ld a, 255 
5765 32 f0 fb				ld (spi_cartdev), a 
5768			 
5768					; get bank 
5768			 
5768					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5768 cd 31 21			call macro_dsp_valuehl 
576b				endm 
# End of macro FORTH_DSP_VALUEHL
576b			 
576b			;		push hl 
576b			 
576b					; destroy value TOS 
576b			 
576b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
576b cd e9 21			call macro_forth_dsp_pop 
576e				endm 
# End of macro FORTH_DSP_POP
576e			 
576e					; one value on hl get other one back 
576e			 
576e			;		pop hl 
576e			 
576e			 
576e 0e ff				ld c, SPI_CE_HIGH 
5770 06 30				ld b, '0'    ; human readable bank number 
5772			 
5772 7d					ld a, l 
5773			 
5773					if DEBUG_FORTH_WORDS 
5773						DMARK "BNK" 
5773 f5				push af  
5774 3a 88 57			ld a, (.dmark)  
5777 32 b4 fe			ld (debug_mark),a  
577a 3a 89 57			ld a, (.dmark+1)  
577d 32 b5 fe			ld (debug_mark+1),a  
5780 3a 8a 57			ld a, (.dmark+2)  
5783 32 b6 fe			ld (debug_mark+2),a  
5786 18 03			jr .pastdmark  
5788 ..			.dmark: db "BNK"  
578b f1			.pastdmark: pop af  
578c			endm  
# End of macro DMARK
578c						CALLMONITOR 
578c cd c6 18			call break_point_state  
578f				endm  
# End of macro CALLMONITOR
578f					endif 
578f			 
578f					; active low 
578f			 
578f fe 00				cp 0 
5791 28 28				jr z, .bset 
5793 fe 01				cp 1 
5795 20 04				jr nz, .b2 
5797 cb 81				res 0, c 
5799 06 31				ld b, '1'    ; human readable bank number 
579b fe 02		.b2:		cp 2 
579d 20 04				jr nz, .b3 
579f cb 89				res 1, c 
57a1 06 32				ld b, '2'    ; human readable bank number 
57a3 fe 03		.b3:		cp 3 
57a5 20 04				jr nz, .b4 
57a7 cb 91				res 2, c 
57a9 06 33				ld b, '3'    ; human readable bank number 
57ab fe 04		.b4:		cp 4 
57ad 20 04				jr nz, .b5 
57af cb 99				res 3, c 
57b1 06 34				ld b, '4'    ; human readable bank number 
57b3 fe 05		.b5:		cp 5 
57b5 20 04				jr nz, .bset 
57b7 cb a1				res 4, c 
57b9 06 35				ld b, '5'    ; human readable bank number 
57bb			 
57bb			.bset: 
57bb 79					ld a, c 
57bc 32 ed fb				ld (spi_device),a 
57bf 78					ld a, b 
57c0 32 ec fb				ld (spi_device_id),a 
57c3					if DEBUG_FORTH_WORDS 
57c3						DMARK "BN2" 
57c3 f5				push af  
57c4 3a d8 57			ld a, (.dmark)  
57c7 32 b4 fe			ld (debug_mark),a  
57ca 3a d9 57			ld a, (.dmark+1)  
57cd 32 b5 fe			ld (debug_mark+1),a  
57d0 3a da 57			ld a, (.dmark+2)  
57d3 32 b6 fe			ld (debug_mark+2),a  
57d6 18 03			jr .pastdmark  
57d8 ..			.dmark: db "BN2"  
57db f1			.pastdmark: pop af  
57dc			endm  
# End of macro DMARK
57dc						CALLMONITOR 
57dc cd c6 18			call break_point_state  
57df				endm  
# End of macro CALLMONITOR
57df					endif 
57df			 
57df					; set default SPI clk pulse time as disabled for BANK use 
57df			 
57df 3e 00				ld a, 0 
57e1 32 f1 fb				ld (spi_clktime), a 
57e4			 
57e4					NEXTW 
57e4 c3 e7 22			jp macro_next 
57e7				endm 
# End of macro NEXTW
57e7			 
57e7			.CARTDEV: 
57e7				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
57e7 66				db WORD_SYS_CORE+82             
57e8 95 58			dw .ENDDEVICE            
57ea 08				db 7 + 1 
57eb .. 00			db "CARTDEV",0              
57f3				endm 
# End of macro CWHEAD
57f3			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
57f3					if DEBUG_FORTH_WORDS_KEY 
57f3						DMARK "CDV" 
57f3 f5				push af  
57f4 3a 08 58			ld a, (.dmark)  
57f7 32 b4 fe			ld (debug_mark),a  
57fa 3a 09 58			ld a, (.dmark+1)  
57fd 32 b5 fe			ld (debug_mark+1),a  
5800 3a 0a 58			ld a, (.dmark+2)  
5803 32 b6 fe			ld (debug_mark+2),a  
5806 18 03			jr .pastdmark  
5808 ..			.dmark: db "CDV"  
580b f1			.pastdmark: pop af  
580c			endm  
# End of macro DMARK
580c						CALLMONITOR 
580c cd c6 18			call break_point_state  
580f				endm  
# End of macro CALLMONITOR
580f					endif 
580f			 
580f					; disable se storage bank selection 
580f			 
580f 3e ff				ld a, SPI_CE_HIGH		; ce high 
5811 32 ed fb				ld (spi_device), a 
5814			 
5814					; get bank 
5814			 
5814					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5814 cd 31 21			call macro_dsp_valuehl 
5817				endm 
# End of macro FORTH_DSP_VALUEHL
5817			 
5817			;		push hl 
5817			 
5817					; destroy value TOS 
5817			 
5817					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5817 cd e9 21			call macro_forth_dsp_pop 
581a				endm 
# End of macro FORTH_DSP_POP
581a			 
581a					; one value on hl get other one back 
581a			 
581a			;		pop hl 
581a			 
581a					; active low 
581a			 
581a 0e ff				ld c, 255 
581c			 
581c 7d					ld a, l 
581d					if DEBUG_FORTH_WORDS 
581d						DMARK "CDV" 
581d f5				push af  
581e 3a 32 58			ld a, (.dmark)  
5821 32 b4 fe			ld (debug_mark),a  
5824 3a 33 58			ld a, (.dmark+1)  
5827 32 b5 fe			ld (debug_mark+1),a  
582a 3a 34 58			ld a, (.dmark+2)  
582d 32 b6 fe			ld (debug_mark+2),a  
5830 18 03			jr .pastdmark  
5832 ..			.dmark: db "CDV"  
5835 f1			.pastdmark: pop af  
5836			endm  
# End of macro DMARK
5836						CALLMONITOR 
5836 cd c6 18			call break_point_state  
5839				endm  
# End of macro CALLMONITOR
5839					endif 
5839 fe 00				cp 0 
583b 28 30				jr z, .cset 
583d fe 01				cp 1 
583f 20 02				jr nz, .c2 
5841 cb 81				res 0, c 
5843 fe 02		.c2:		cp 2 
5845 20 02				jr nz, .c3 
5847 cb 89				res 1, c 
5849 fe 03		.c3:		cp 3 
584b 20 02				jr nz, .c4 
584d cb 91				res 2, c 
584f fe 04		.c4:		cp 4 
5851 20 02				jr nz, .c5 
5853 cb 99				res 3, c 
5855 fe 05		.c5:		cp 5 
5857 20 02				jr nz, .c6 
5859 cb a1				res 4, c 
585b fe 06		.c6:		cp 6 
585d 20 02				jr nz, .c7 
585f cb a9				res 5, c 
5861 fe 07		.c7:		cp 7 
5863 20 02				jr nz, .c8 
5865 cb b1				res 6, c 
5867 fe 08		.c8:		cp 8 
5869 20 02				jr nz, .cset 
586b cb b9				res 7, c 
586d 79			.cset:		ld a, c 
586e 32 f0 fb				ld (spi_cartdev),a 
5871			 
5871					if DEBUG_FORTH_WORDS 
5871						DMARK "CD2" 
5871 f5				push af  
5872 3a 86 58			ld a, (.dmark)  
5875 32 b4 fe			ld (debug_mark),a  
5878 3a 87 58			ld a, (.dmark+1)  
587b 32 b5 fe			ld (debug_mark+1),a  
587e 3a 88 58			ld a, (.dmark+2)  
5881 32 b6 fe			ld (debug_mark+2),a  
5884 18 03			jr .pastdmark  
5886 ..			.dmark: db "CD2"  
5889 f1			.pastdmark: pop af  
588a			endm  
# End of macro DMARK
588a						CALLMONITOR 
588a cd c6 18			call break_point_state  
588d				endm  
# End of macro CALLMONITOR
588d					endif 
588d			 
588d					; set default SPI clk pulse time as 10ms for CARTDEV use 
588d			 
588d 3e 0a				ld a, $0a 
588f 32 f1 fb				ld (spi_clktime), a 
5892					NEXTW 
5892 c3 e7 22			jp macro_next 
5895				endm 
# End of macro NEXTW
5895			endif 
5895			 
5895			.ENDDEVICE: 
5895			; eof 
5895			 
# End of file forth_words_device.asm
5895			 
5895			; var handler 
5895			 
5895			 
5895			.VARS: 
5895				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5895 77				db WORD_SYS_CORE+99             
5896 46 59			dw .V0            
5898 04				db 3 + 1 
5899 .. 00			db "VAR",0              
589d				endm 
# End of macro CWHEAD
589d			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
589d			;| 
589d			;| The variable name should consist of a single letter. e.g. "a" 
589d			;! If a full string is passed then only the first char is looked at 
589d			;| Any other char could exceed bounds checks!  
589d			 
589d					if DEBUG_FORTH_WORDS_KEY 
589d						DMARK "VAR" 
589d f5				push af  
589e 3a b2 58			ld a, (.dmark)  
58a1 32 b4 fe			ld (debug_mark),a  
58a4 3a b3 58			ld a, (.dmark+1)  
58a7 32 b5 fe			ld (debug_mark+1),a  
58aa 3a b4 58			ld a, (.dmark+2)  
58ad 32 b6 fe			ld (debug_mark+2),a  
58b0 18 03			jr .pastdmark  
58b2 ..			.dmark: db "VAR"  
58b5 f1			.pastdmark: pop af  
58b6			endm  
# End of macro DMARK
58b6						CALLMONITOR 
58b6 cd c6 18			call break_point_state  
58b9				endm  
# End of macro CALLMONITOR
58b9					endif 
58b9			 
58b9					FORTH_DSP_VALUEHL 
58b9 cd 31 21			call macro_dsp_valuehl 
58bc				endm 
# End of macro FORTH_DSP_VALUEHL
58bc			 
58bc 7e					ld a, (hl)    ; get first char on of the string 
58bd			 
58bd			 
58bd					if DEBUG_FORTH_WORDS 
58bd						DMARK "VR1" 
58bd f5				push af  
58be 3a d2 58			ld a, (.dmark)  
58c1 32 b4 fe			ld (debug_mark),a  
58c4 3a d3 58			ld a, (.dmark+1)  
58c7 32 b5 fe			ld (debug_mark+1),a  
58ca 3a d4 58			ld a, (.dmark+2)  
58cd 32 b6 fe			ld (debug_mark+2),a  
58d0 18 03			jr .pastdmark  
58d2 ..			.dmark: db "VR1"  
58d5 f1			.pastdmark: pop af  
58d6			endm  
# End of macro DMARK
58d6						CALLMONITOR 
58d6 cd c6 18			call break_point_state  
58d9				endm  
# End of macro CALLMONITOR
58d9					endif 
58d9					 
58d9 f5					push af	 
58da					FORTH_DSP_POP 
58da cd e9 21			call macro_forth_dsp_pop 
58dd				endm 
# End of macro FORTH_DSP_POP
58dd f1					pop af 
58de			 
58de					; convert to upper 
58de			 
58de cd b6 12				call to_upper 
58e1					if DEBUG_FORTH_WORDS 
58e1						DMARK "Vaa" 
58e1 f5				push af  
58e2 3a f6 58			ld a, (.dmark)  
58e5 32 b4 fe			ld (debug_mark),a  
58e8 3a f7 58			ld a, (.dmark+1)  
58eb 32 b5 fe			ld (debug_mark+1),a  
58ee 3a f8 58			ld a, (.dmark+2)  
58f1 32 b6 fe			ld (debug_mark+2),a  
58f4 18 03			jr .pastdmark  
58f6 ..			.dmark: db "Vaa"  
58f9 f1			.pastdmark: pop af  
58fa			endm  
# End of macro DMARK
58fa						CALLMONITOR 
58fa cd c6 18			call break_point_state  
58fd				endm  
# End of macro CALLMONITOR
58fd					endif 
58fd 06 41				ld b, 'A' 
58ff 90					sub b			; set offset 
5900					if DEBUG_FORTH_WORDS 
5900						DMARK "Vbb" 
5900 f5				push af  
5901 3a 15 59			ld a, (.dmark)  
5904 32 b4 fe			ld (debug_mark),a  
5907 3a 16 59			ld a, (.dmark+1)  
590a 32 b5 fe			ld (debug_mark+1),a  
590d 3a 17 59			ld a, (.dmark+2)  
5910 32 b6 fe			ld (debug_mark+2),a  
5913 18 03			jr .pastdmark  
5915 ..			.dmark: db "Vbb"  
5918 f1			.pastdmark: pop af  
5919			endm  
# End of macro DMARK
5919						CALLMONITOR 
5919 cd c6 18			call break_point_state  
591c				endm  
# End of macro CALLMONITOR
591c					endif 
591c cb 27				sla a  
591e				 
591e					 
591e					if DEBUG_FORTH_WORDS 
591e						DMARK "VR2" 
591e f5				push af  
591f 3a 33 59			ld a, (.dmark)  
5922 32 b4 fe			ld (debug_mark),a  
5925 3a 34 59			ld a, (.dmark+1)  
5928 32 b5 fe			ld (debug_mark+1),a  
592b 3a 35 59			ld a, (.dmark+2)  
592e 32 b6 fe			ld (debug_mark+2),a  
5931 18 03			jr .pastdmark  
5933 ..			.dmark: db "VR2"  
5936 f1			.pastdmark: pop af  
5937			endm  
# End of macro DMARK
5937						CALLMONITOR 
5937 cd c6 18			call break_point_state  
593a				endm  
# End of macro CALLMONITOR
593a					endif 
593a			 
593a 21 81 fb				ld hl, cli_var_array2 
593d cd 49 0f				call addatohl 
5940 cd 3a 1f				call forth_push_numhl 
5943			 
5943			 
5943				       NEXTW 
5943 c3 e7 22			jp macro_next 
5946				endm 
# End of macro NEXTW
5946			.V0: 
5946				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5946 78				db WORD_SYS_CORE+100             
5947 5e 59			dw .V0Q            
5949 04				db 3 + 1 
594a .. 00			db "V0!",0              
594e				endm 
# End of macro CWHEAD
594e			;| V0! ( u1 -- )  Store value to v0  | DONE 
594e			 
594e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
594e cd 31 21			call macro_dsp_valuehl 
5951				endm 
# End of macro FORTH_DSP_VALUEHL
5951			 
5951 11 b5 fb				ld de, cli_var_array 
5954			 
5954 eb					ex de, hl 
5955 73					ld (hl), e 
5956 23					inc hl 
5957 72					ld (hl), d 
5958			 
5958					; destroy value TOS 
5958			 
5958					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5958 cd e9 21			call macro_forth_dsp_pop 
595b				endm 
# End of macro FORTH_DSP_POP
595b			 
595b				       NEXTW 
595b c3 e7 22			jp macro_next 
595e				endm 
# End of macro NEXTW
595e			.V0Q: 
595e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
595e 79				db WORD_SYS_CORE+101             
595f 6f 59			dw .V1S            
5961 04				db 3 + 1 
5962 .. 00			db "V0@",0              
5966				endm 
# End of macro CWHEAD
5966			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5966 2a b5 fb				ld hl, (cli_var_array) 
5969 cd 3a 1f				call forth_push_numhl 
596c			 
596c				       NEXTW 
596c c3 e7 22			jp macro_next 
596f				endm 
# End of macro NEXTW
596f			.V1S: 
596f				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
596f 7a				db WORD_SYS_CORE+102             
5970 87 59			dw .V1Q            
5972 04				db 3 + 1 
5973 .. 00			db "V1!",0              
5977				endm 
# End of macro CWHEAD
5977			;| V1! ( u1 -- )  Store value to v1 | DONE 
5977					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5977 cd 31 21			call macro_dsp_valuehl 
597a				endm 
# End of macro FORTH_DSP_VALUEHL
597a			 
597a 11 b7 fb				ld de, cli_var_array+2 
597d				 
597d eb					ex de, hl 
597e 73					ld (hl), e 
597f 23					inc hl 
5980 72					ld (hl), d 
5981			 
5981					; destroy value TOS 
5981			 
5981					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5981 cd e9 21			call macro_forth_dsp_pop 
5984				endm 
# End of macro FORTH_DSP_POP
5984				       NEXTW 
5984 c3 e7 22			jp macro_next 
5987				endm 
# End of macro NEXTW
5987			.V1Q: 
5987				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5987 7b				db WORD_SYS_CORE+103             
5988 98 59			dw .V2S            
598a 04				db 3 + 1 
598b .. 00			db "V1@",0              
598f				endm 
# End of macro CWHEAD
598f			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
598f 2a b7 fb				ld hl, (cli_var_array+2) 
5992 cd 3a 1f				call forth_push_numhl 
5995				       NEXTW 
5995 c3 e7 22			jp macro_next 
5998				endm 
# End of macro NEXTW
5998			.V2S: 
5998				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5998 7c				db WORD_SYS_CORE+104             
5999 b0 59			dw .V2Q            
599b 04				db 3 + 1 
599c .. 00			db "V2!",0              
59a0				endm 
# End of macro CWHEAD
59a0			;| V2! ( u1 -- )  Store value to v2 | DONE 
59a0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59a0 cd 31 21			call macro_dsp_valuehl 
59a3				endm 
# End of macro FORTH_DSP_VALUEHL
59a3			 
59a3 11 b9 fb				ld de, cli_var_array+4 
59a6				 
59a6 eb					ex de, hl 
59a7 73					ld (hl), e 
59a8 23					inc hl 
59a9 72					ld (hl), d 
59aa			 
59aa					; destroy value TOS 
59aa			 
59aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59aa cd e9 21			call macro_forth_dsp_pop 
59ad				endm 
# End of macro FORTH_DSP_POP
59ad				       NEXTW 
59ad c3 e7 22			jp macro_next 
59b0				endm 
# End of macro NEXTW
59b0			.V2Q: 
59b0				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
59b0 7d				db WORD_SYS_CORE+105             
59b1 c1 59			dw .V3S            
59b3 04				db 3 + 1 
59b4 .. 00			db "V2@",0              
59b8				endm 
# End of macro CWHEAD
59b8			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
59b8 2a b9 fb				ld hl, (cli_var_array+4) 
59bb cd 3a 1f				call forth_push_numhl 
59be				       NEXTW 
59be c3 e7 22			jp macro_next 
59c1				endm 
# End of macro NEXTW
59c1			.V3S: 
59c1				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
59c1 7c				db WORD_SYS_CORE+104             
59c2 d9 59			dw .V3Q            
59c4 04				db 3 + 1 
59c5 .. 00			db "V3!",0              
59c9				endm 
# End of macro CWHEAD
59c9			;| V3! ( u1 -- )  Store value to v3 | DONE 
59c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59c9 cd 31 21			call macro_dsp_valuehl 
59cc				endm 
# End of macro FORTH_DSP_VALUEHL
59cc			 
59cc 11 bb fb				ld de, cli_var_array+6 
59cf				 
59cf eb					ex de, hl 
59d0 73					ld (hl), e 
59d1 23					inc hl 
59d2 72					ld (hl), d 
59d3			 
59d3					; destroy value TOS 
59d3			 
59d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59d3 cd e9 21			call macro_forth_dsp_pop 
59d6				endm 
# End of macro FORTH_DSP_POP
59d6				       NEXTW 
59d6 c3 e7 22			jp macro_next 
59d9				endm 
# End of macro NEXTW
59d9			.V3Q: 
59d9				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
59d9 7d				db WORD_SYS_CORE+105             
59da ea 59			dw .END            
59dc 04				db 3 + 1 
59dd .. 00			db "V3@",0              
59e1				endm 
# End of macro CWHEAD
59e1			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
59e1 2a bb fb				ld hl, (cli_var_array+6) 
59e4 cd 3a 1f				call forth_push_numhl 
59e7				       NEXTW 
59e7 c3 e7 22			jp macro_next 
59ea				endm 
# End of macro NEXTW
59ea			 
59ea			 
59ea			 
59ea			 
59ea			 
59ea			; end of dict marker 
59ea			 
59ea 00			.END:    db WORD_SYS_END 
59eb 00 00			dw 0 
59ed 00				db 0 
59ee			 
59ee			; use to jp here for user dict words to save on macro expansion  
59ee			 
59ee			user_dict_next: 
59ee				NEXTW 
59ee c3 e7 22			jp macro_next 
59f1				endm 
# End of macro NEXTW
59f1			 
59f1			 
59f1			user_exec: 
59f1				;    ld hl, <word code> 
59f1				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
59f1				;    call forthexec 
59f1				;    jp user_dict_next   (NEXT) 
59f1			        ;    <word code bytes> 
59f1 eb				ex de, hl 
59f2 2a 4f f6			ld hl,(os_tok_ptr) 
59f5				 
59f5				FORTH_RSP_NEXT 
59f5 cd e1 1e			call macro_forth_rsp_next 
59f8				endm 
# End of macro FORTH_RSP_NEXT
59f8			 
59f8			if DEBUG_FORTH_UWORD 
59f8						DMARK "UEX" 
59f8 f5				push af  
59f9 3a 0d 5a			ld a, (.dmark)  
59fc 32 b4 fe			ld (debug_mark),a  
59ff 3a 0e 5a			ld a, (.dmark+1)  
5a02 32 b5 fe			ld (debug_mark+1),a  
5a05 3a 0f 5a			ld a, (.dmark+2)  
5a08 32 b6 fe			ld (debug_mark+2),a  
5a0b 18 03			jr .pastdmark  
5a0d ..			.dmark: db "UEX"  
5a10 f1			.pastdmark: pop af  
5a11			endm  
# End of macro DMARK
5a11				CALLMONITOR 
5a11 cd c6 18			call break_point_state  
5a14				endm  
# End of macro CALLMONITOR
5a14			endif 
5a14			 
5a14			 
5a14			 
5a14 eb				ex de, hl 
5a15 22 4f f6			ld (os_tok_ptr), hl 
5a18				 
5a18				; Don't use next - Skips the first word in uword. 
5a18			 
5a18 c3 78 23			jp exec1 
5a1b			;	NEXT 
5a1b			 
5a1b			 
5a1b			; eof 
# End of file forth_wordsv4.asm
5a1b			endif 
5a1b			;;;;;;;;;;;;;; Debug code 
5a1b			 
5a1b			 
5a1b			;if DEBUG_FORTH_PARSE 
5a1b .. 00		.nowordfound: db "No match",0 
5a24 .. 00		.compword:	db "Comparing word ",0 
5a34 .. 00		.nextwordat:	db "Next word at",0 
5a41 .. 00		.charmatch:	db "Char match",0 
5a4c			;endif 
5a4c			if DEBUG_FORTH_JP 
5a4c			.foundword:	db "Word match. Exec..",0 
5a4c			endif 
5a4c			;if DEBUG_FORTH_PUSH 
5a4c .. 00		.enddict:	db "Dict end. Push.",0 
5a5c .. 00		.push_str:	db "Pushing string",0 
5a6b .. 00		.push_num:	db "Pushing number",0 
5a7a .. 00		.data_sp:	db "SP:",0 
5a7e .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5a90 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5aa2 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5ab4			;endif 
5ab4			;if DEBUG_FORTH_MALLOC 
5ab4 .. 00		.push_malloc:	db "Malloc address",0 
5ac3			;endif 
5ac3			 
5ac3			 
5ac3			 
5ac3			; display malloc address and current data stack pointer  
5ac3			 
5ac3			malloc_error: 
5ac3 d5				push de 
5ac4 f5				push af 
5ac5 e5				push hl 
5ac6 cd 15 0d			call clear_display 
5ac9 11 eb 5a			ld de, .mallocerr 
5acc 3e 00			ld a,0 
5ace			;	ld de,os_word_scratch 
5ace cd 28 0d			call str_at_display 
5ad1 3e 11			ld a, display_row_1+17 
5ad3 11 b4 fe			ld de, debug_mark 
5ad6 cd 28 0d			call str_at_display 
5ad9 cd 38 0d			call update_display 
5adc				;call break_point_state 
5adc cd 5b 74			call cin_wait 
5adf			 
5adf 3e 20			ld a, ' ' 
5ae1 32 3f f3			ld (os_view_disable), a 
5ae4 e1				pop hl 
5ae5 f1				pop af 
5ae6 d1				pop de	 
5ae7				CALLMONITOR 
5ae7 cd c6 18			call break_point_state  
5aea				endm  
# End of macro CALLMONITOR
5aea c9				ret 
5aeb			 
5aeb .. 00		.mallocerr: 	db "Malloc Error",0 
5af8			;if DEBUG_FORTH_PUSH 
5af8			display_data_sp: 
5af8 f5				push af 
5af9			 
5af9				; see if disabled 
5af9			 
5af9 3a 3f f3			ld a, (os_view_disable) 
5afc fe 2a			cp '*' 
5afe 28 67			jr z, .skipdsp 
5b00			 
5b00 e5				push hl 
5b01 e5				push hl 
5b02 e5			push hl 
5b03 cd 15 0d			call clear_display 
5b06 e1			pop hl 
5b07 7c				ld a,h 
5b08 21 53 f6			ld hl, os_word_scratch 
5b0b cd 4a 12			call hexout 
5b0e e1				pop hl 
5b0f 7d				ld a,l 
5b10 21 55 f6			ld hl, os_word_scratch+2 
5b13 cd 4a 12			call hexout 
5b16 21 57 f6			ld hl, os_word_scratch+4 
5b19 3e 00			ld a,0 
5b1b 77				ld (hl),a 
5b1c 11 53 f6			ld de,os_word_scratch 
5b1f 3e 14				ld a, display_row_2 
5b21 cd 28 0d				call str_at_display 
5b24 11 7e 5a			ld de, .wordinhl 
5b27 3e 00			ld a, display_row_1 
5b29			 
5b29 cd 28 0d				call str_at_display 
5b2c 11 b4 fe			ld de, debug_mark 
5b2f 3e 11			ld a, display_row_1+17 
5b31			 
5b31 cd 28 0d				call str_at_display 
5b34			 
5b34				; display current data stack pointer 
5b34 11 7a 5a			ld de,.data_sp 
5b37 3e 1c				ld a, display_row_2 + 8 
5b39 cd 28 0d				call str_at_display 
5b3c			 
5b3c 2a 7b fb			ld hl,(cli_data_sp) 
5b3f e5				push hl 
5b40 7c				ld a,h 
5b41 21 53 f6			ld hl, os_word_scratch 
5b44 cd 4a 12			call hexout 
5b47 e1				pop hl 
5b48 7d				ld a,l 
5b49 21 55 f6			ld hl, os_word_scratch+2 
5b4c cd 4a 12			call hexout 
5b4f 21 57 f6			ld hl, os_word_scratch+4 
5b52 3e 00			ld a,0 
5b54 77				ld (hl),a 
5b55 11 53 f6			ld de,os_word_scratch 
5b58 3e 1f				ld a, display_row_2 + 11 
5b5a cd 28 0d				call str_at_display 
5b5d			 
5b5d			 
5b5d cd 38 0d			call update_display 
5b60 cd 92 0c			call delay1s 
5b63 cd 92 0c			call delay1s 
5b66 e1				pop hl 
5b67			.skipdsp: 
5b67 f1				pop af 
5b68 c9				ret 
5b69			 
5b69			display_data_malloc: 
5b69			 
5b69 f5				push af 
5b6a e5				push hl 
5b6b e5				push hl 
5b6c e5			push hl 
5b6d cd 15 0d			call clear_display 
5b70 e1			pop hl 
5b71 7c				ld a,h 
5b72 21 53 f6			ld hl, os_word_scratch 
5b75 cd 4a 12			call hexout 
5b78 e1				pop hl 
5b79 7d				ld a,l 
5b7a 21 55 f6			ld hl, os_word_scratch+2 
5b7d cd 4a 12			call hexout 
5b80 21 57 f6			ld hl, os_word_scratch+4 
5b83 3e 00			ld a,0 
5b85 77				ld (hl),a 
5b86 11 53 f6			ld de,os_word_scratch 
5b89 3e 14				ld a, display_row_2 
5b8b cd 28 0d				call str_at_display 
5b8e 11 b4 5a			ld de, .push_malloc 
5b91 3e 00			ld a, display_row_1 
5b93			 
5b93 cd 28 0d				call str_at_display 
5b96			 
5b96				; display current data stack pointer 
5b96 11 7a 5a			ld de,.data_sp 
5b99 3e 1c				ld a, display_row_2 + 8 
5b9b cd 28 0d				call str_at_display 
5b9e			 
5b9e 2a 7b fb			ld hl,(cli_data_sp) 
5ba1 e5				push hl 
5ba2 7c				ld a,h 
5ba3 21 53 f6			ld hl, os_word_scratch 
5ba6 cd 4a 12			call hexout 
5ba9 e1				pop hl 
5baa 7d				ld a,l 
5bab 21 55 f6			ld hl, os_word_scratch+2 
5bae cd 4a 12			call hexout 
5bb1 21 57 f6			ld hl, os_word_scratch+4 
5bb4 3e 00			ld a,0 
5bb6 77				ld (hl),a 
5bb7 11 53 f6			ld de,os_word_scratch 
5bba 3e 1f				ld a, display_row_2 + 11 
5bbc cd 28 0d				call str_at_display 
5bbf			 
5bbf cd 38 0d			call update_display 
5bc2 cd 92 0c			call delay1s 
5bc5 cd 92 0c			call delay1s 
5bc8 e1				pop hl 
5bc9 f1				pop af 
5bca c9				ret 
5bcb			;endif 
5bcb			 
5bcb			include "forth_autostart.asm" 
5bcb			; list of commands to perform at system start up 
5bcb			 
5bcb			startcmds: 
5bcb			;	dw test11 
5bcb			;	dw test12 
5bcb			;	dw test13 
5bcb			;	dw test14 
5bcb			;	dw test15 
5bcb			;	dw test16 
5bcb			;	dw test17 
5bcb			;	dw ifthtest1 
5bcb			;	dw ifthtest2 
5bcb			;	dw ifthtest3 
5bcb			;	dw mmtest1 
5bcb			;	dw mmtest2 
5bcb			;	dw mmtest3 
5bcb			;	dw mmtest4 
5bcb			;	dw mmtest5 
5bcb			;	dw mmtest6 
5bcb			;	dw iftest1 
5bcb			;	dw iftest2 
5bcb			;	dw iftest3 
5bcb			;	dw looptest1 
5bcb			;	dw looptest2 
5bcb			;	dw test1 
5bcb			;	dw test2 
5bcb			;	dw test3 
5bcb			;	dw test4 
5bcb			;	dw game2r 
5bcb			;	dw game2b1 
5bcb			;	dw game2b2 
5bcb			 
5bcb				; start up words that are actually useful 
5bcb			 
5bcb e8 5c		    dw spi1 
5bcd 41 5d		    dw spi2 
5bcf cf 5d		    dw spi3 
5bd1 77 5d		    dw spi4 
5bd3 a2 5d		    dw spi5 
5bd5 35 5e		    dw spi6 
5bd7 8a 5e		    dw spi7 
5bd9			 
5bd9 e2 5e		    dw spi8 
5bdb 01 5f		    dw spi9 
5bdd 59 5f		    dw spi10 
5bdf			 
5bdf			; file editor 
5bdf 45 5c			dw edit1 
5be1 66 5c			dw edit2 
5be3 aa 5c			dw edit3 
5be5			 
5be5 cc 5f			dw longread 
5be7 13 60			dw clrstack 
5be9 46 60			dw type 
5beb 36 62			dw stest 
5bed 6a 60			dw strncpy 
5bef cc 61			dw list 
5bf1 cb 60			dw start1 
5bf3 dd 60			dw start2 
5bf5			;	dw start3 
5bf5 f0 60			dw start3b 
5bf7 6c 61			dw start3c 
5bf9			 
5bf9				; (unit) testing words 
5bf9			 
5bf9 ad 62			dw mtesta 
5bfb 62 63			dw mtestb 
5bfd 05 64			dw mtestc 
5bff ba 64			dw mtestd 
5c01 5e 65			dw mteste 
5c03			 
5c03				; demo/game words 
5c03			 
5c03 6a 6c		        dw game3w 
5c05 98 6c		        dw game3p 
5c07 b6 6c		        dw game3sc 
5c09 e7 6c		        dw game3vsi 
5c0b 13 6d		        dw game3vs 
5c0d				 
5c0d 5d 6a			dw game2b 
5c0f cb 6a			dw game2bf 
5c11 15 6b			dw game2mba 
5c13 ab 6b			dw game2mbas 
5c15 ed 6b			dw game2mb 
5c17			 
5c17 1e 67			dw game1 
5c19 2f 67			dw game1a 
5c1b 91 67			dw game1b 
5c1d c6 67			dw game1c 
5c1f fc 67			dw game1d 
5c21 2d 68			dw game1s 
5c23 41 68			dw game1t 
5c25 56 68			dw game1f 
5c27 8a 68			dw game1z 
5c29 ce 68			dw game1zz 
5c2b			 
5c2b 14 66			dw test5 
5c2d 4c 66			dw test6 
5c2f 84 66			dw test7 
5c31 98 66			dw test8 
5c33 c4 66			dw test9 
5c35 da 66			dw test10 
5c37				 
5c37 a5 69		        dw ssv5 
5c39 89 69		        dw ssv4 
5c3b 6d 69		        dw ssv3 
5c3d 37 69		        dw ssv2 
5c3f be 69		        dw ssv1 
5c41 06 6a		        dw ssv1cpm 
5c43			;	dw keyup 
5c43			;	dw keydown 
5c43			;	dw keyleft 
5c43			;	dw keyright 
5c43			;	dw 	keyf1 
5c43			;	dw keyf2 
5c43			;	dw keyf3 
5c43			;	dw keyf4 
5c43			;	dw keyf5 
5c43			;	dw keyf6 
5c43			;	dw keyf7 
5c43			;	dw keyf8 
5c43			;	dw keyf9 
5c43			;	dw keyf10 
5c43			;	dw keyf11 
5c43			;	dw keyf12 
5c43			;	dw keytab 
5c43			;	dw keycr 
5c43			;	dw keyhome 
5c43			;	dw keyend 
5c43			;	dw keybs 
5c43 00 00			db 0, 0	 
5c45			 
5c45			 
5c45			; File Editor 
5c45			 
5c45			; ( id - ) use 'e' to edit the displayed line 
5c45 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5c66 .. 00		edit2: db ": ede v1@ v0@ record storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5caa .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5ce8			 
5ce8			; SPI Net support words 
5ce8			 
5ce8			; v0! = node to send to 
5ce8			; ( str count - ) 
5ce8 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5d41			 
5d41			; spiputchr ( char node - ) 
5d41 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
5d77			 
5d77			; spigetchr ( - n ) 
5d77 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5da2			 
5da2			; getnode ( - n ) 
5da2 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5dcf			 
5dcf			; ( str node - )  
5dcf .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5e35			; store string ( str i - ) 
5e35			 
5e35			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5e35 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5e8a			 
5e8a			; get string ( addr i -  )    TO FIX 
5e8a			 
5e8a .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5ee2			 
5ee2			 
5ee2			; NETCHAT (TODO) 
5ee2			; Program to allow two nodes to chat with eachother 
5ee2			; 
5ee2			; v0 - target node 
5ee2			;  
5ee2			; accept input at 0,0 
5ee2			; if input is string send spitype to target node 
5ee2			; starting at row 2,0 , while spigetchr is not zero ->  
5ee2			; 
5ee2			; 
5ee2			; TODO add paging of get request 
5ee2			 
5ee2			; ( node - ) 
5ee2 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5f01 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5f59 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
5fcc			 
5fcc			 
5fcc			; Long read of currently open file 
5fcc .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6013			 
6013			; clear stack  
6013			 
6013 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
6046			 
6046			; type ( addr count - ) 
6046 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
606a			 
606a			; some direct memory words 
606a			; strncpy ( len t f -- t ) 
606a			 
606a .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
60cb			 
60cb .. 00		start1:     	db ": bpon $0000 bp ;",0 
60dd .. 00		start2:     	db ": bpoff $0001 bp ;",0 
60f0 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
616c .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
61cc			 
61cc			 
61cc			; a handy word to list items on the stack 
61cc			 
61cc .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6236			 
6236			 
6236			; test stack  
6236			; rnd8 stest 
6236			 
6236 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
62ad			 
62ad			; random malloc and free cycles 
62ad			 
62ad .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6362			 
6362			; fixed malloc and free cycles 
6362			 
6362 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6405			 
6405			; fixed double string push and drop cycle  
6405			 
6405 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
64ba			 
64ba			; consistent fixed string push and drop cycle  
64ba			 
64ba .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
655e			 
655e .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6614			 
6614			;test1:		db ": aa 1 2 3 ;", 0 
6614			;test2:     	db "111 aa 888 999",0 
6614			;test3:     	db ": bb 77 ;",0 
6614			;test4:     	db "$02 $01 do i . loop bb",0 
6614			 
6614 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
664c .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6684 .. 00		test7:     	db ": box hline vline ;",0 
6698 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
66c4 .. 00		test9:     	db ": sw $01 adsp world ;",0 
66da .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
66ff .. 00		test11:     	db "hello create .",0 
670e .. 00		test12:     	db "hello2 create .",0 
671e			 
671e			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
671e			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
671e			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
671e			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
671e			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
671e			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
671e			 
671e			;iftest1:     	db "$0001 IF cls .",0 
671e			;iftest2:     	db "$0000 IF cls .",0 
671e			;iftest3:     	db "$0002 $0003 - IF cls .",0 
671e			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
671e			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
671e			 
671e			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
671e			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
671e			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
671e			 
671e			 
671e			 
671e			; a small guess the number game 
671e			 
671e .. 00		game1:          db ": gsn rnd8 v1! ;",0 
672f .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6791			 
6791 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
67c6 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
67fc .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
682d .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6841 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6856 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
688a .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
68ce			 
68ce			; Using 'ga' save a high score across multiple runs using external storage 
68ce			 
68ce .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6937			 
6937			 
6937			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6937			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6937			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6937			 
6937			; simple screen saver to test code memory reuse to destruction 
6937			 
6937 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
696d .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6989 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
69a5 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
69be .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6a06 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6a5d			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6a5d			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6a5d			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6a5d			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6a5d			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6a5d			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6a5d			 
6a5d			 
6a5d			 
6a5d			; minesweeper/battleship finding game 
6a5d			; draws a game board of random ship/mine positions 
6a5d			; user enters coords to see if it hits on 
6a5d			; game ends when all are hit 
6a5d			; when hit or miss says how many may be in the area 
6a5d			 
6a5d			; setup the game board and then hide it 
6a5d .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6acb .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6b15			; prompt for where to target 
6b15 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6bab .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6bd0			; TODO see if the entered coords hits or misses pushes char hit of miss 
6bd0 .. 00		game2mbht:      db ": mbckht nop ;",0 
6bdf .. 00		game2mbms:      db ": mbcms nop ;",0 
6bed			; TODO how many might be near by 
6bed .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6c6a			 
6c6a			; Game 3 
6c6a			 
6c6a			; Vert scroller ski game - avoid the trees! 
6c6a			 
6c6a			; v0 score (ie turns) 
6c6a			; v1 player pos 
6c6a			; v2 left wall 
6c6a			; v3 right wall 
6c6a			 
6c6a			; Draw side walls randomly 
6c6a			 
6c6a .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6c98			 
6c98			; Draw player 
6c98 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6cb6			 
6cb6			; TODO Get Key 
6cb6			 
6cb6			; TODO Move left right 
6cb6			 
6cb6			; scroll and move walls a bit 
6cb6			 
6cb6 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6ce7			 
6ce7			; main game loop 
6ce7			 
6ce7 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6d13 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6d52			 
6d52			; key board defs 
6d52			 
6d52 .. 00		keyup:       db ": keyup $05 ;",0 
6d60 .. 00		keydown:       db ": keydown $0a ;",0 
6d70 .. 00		keyleft:       db ": keyleft $0b ;",0 
6d80 .. 00		keyright:       db ": keyright $0c ;",0 
6d91 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6d9f .. 00		keyf2:       db ": keyf2 $11 ;",0 
6dad .. 00		keyf3:       db ": keyf3 $12 ;",0 
6dbb .. 00		keyf4:       db ": keyf4 $13 ;",0 
6dc9 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6dd7 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6de5 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6df3 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6e01 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6e0f .. 00		keyf10:       db ": keyf10 $19 ;",0 
6e1e .. 00		keyf11:       db ": keyf11 $1a ;",0 
6e2d .. 00		keyf12:       db ": keyf12 $1b ;",0 
6e3c			 
6e3c .. 00		keytab:       db ": keytab $09 ;",0 
6e4b .. 00		keycr:       db ": keycr $0d ;",0 
6e59 .. 00		keyhome:       db ": keyhome $0e ;",0 
6e69 .. 00		keyend:       db ": keyend $0f ;",0 
6e78 .. 00		keybs:       db ": keybs $08 ;",0 
6e86			 
6e86			   
6e86			 
6e86			 
6e86			 
6e86			; eof 
# End of file forth_autostart.asm
6e86			 
6e86 .. 00		sprompt1: db "Startup load...",0 
6e96 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6eac			 
6eac			 
6eac			 
6eac			 
6eac			forth_startup: 
6eac 21 cb 5b			ld hl, startcmds 
6eaf 3e 00			ld a, 0 
6eb1 32 74 f7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6eb4			 
6eb4 e5			.start1:	push hl 
6eb5 cd 15 0d			call clear_display 
6eb8 11 86 6e			ld de, sprompt1 
6ebb 3e 00		        ld a, display_row_1 
6ebd cd 28 0d			call str_at_display 
6ec0 11 96 6e			ld de, sprompt2 
6ec3 3e 14		        ld a, display_row_2 
6ec5 cd 28 0d			call str_at_display 
6ec8 e1				pop hl 
6ec9 e5				push hl 
6eca 5e				ld e,(hl) 
6ecb 23				inc hl 
6ecc 56				ld d,(hl) 
6ecd 3e 28		        ld a, display_row_3 
6ecf cd 28 0d			call str_at_display 
6ed2 cd 38 0d			call update_display 
6ed5			 
6ed5			 
6ed5 3a 74 f7			ld a, (os_last_cmd) 
6ed8 fe 00			cp 0 
6eda 28 05			jr z, .startprompt 
6edc cd 86 0c			call delay250ms 
6edf 18 24			jr .startdo 
6ee1				 
6ee1				 
6ee1			 
6ee1			.startprompt: 
6ee1			 
6ee1 3e 4f			ld a,display_row_4 + display_cols - 1 
6ee3 11 b0 1e		        ld de, endprg 
6ee6 cd 28 0d			call str_at_display 
6ee9 cd 38 0d			call update_display 
6eec cd 92 0c			call delay1s 
6eef cd 5b 74			call cin_wait 
6ef2						 
6ef2 fe 2a			cp '*' 
6ef4 28 5e			jr z, .startupend1 
6ef6 fe 23			cp '#' 
6ef8 20 07			jr nz, .startno 
6efa 3e 01			ld a, 1 
6efc 32 74 f7			ld (os_last_cmd),a 
6eff 18 04			jr .startdo 
6f01 fe 31		.startno:	cp '1' 
6f03 28 3a			jr z,.startnxt  
6f05			 
6f05				; exec startup line 
6f05			.startdo:	 
6f05 e1				pop hl 
6f06 e5				push hl 
6f07				 
6f07 5e				ld e,(hl) 
6f08 23				inc hl 
6f09 56				ld d,(hl) 
6f0a eb				ex de,hl 
6f0b			 
6f0b e5				push hl 
6f0c			 
6f0c 3e 00			ld a, 0 
6f0e				;ld a, FORTH_END_BUFFER 
6f0e cd b2 13			call strlent 
6f11 23				inc hl   ; include zero term to copy 
6f12 06 00			ld b,0 
6f14 4d				ld c,l 
6f15 e1				pop hl 
6f16 11 4e f3			ld de, scratch 
6f19 ed b0			ldir 
6f1b			 
6f1b			 
6f1b 21 4e f3			ld hl, scratch 
6f1e cd 35 23			call forthparse 
6f21 cd 75 23			call forthexec 
6f24 cd 87 22			call forthexec_cleanup 
6f27			 
6f27 3e 3c			ld a, display_row_4 
6f29 11 54 1c			ld de, endprog 
6f2c			 
6f2c cd 38 0d			call update_display		 
6f2f			 
6f2f 3a 74 f7			ld a, (os_last_cmd) 
6f32 fe 00			cp 0 
6f34 20 09			jr nz, .startnxt 
6f36 cd b2 1e			call next_page_prompt 
6f39 cd 15 0d		        call clear_display 
6f3c cd 38 0d			call update_display		 
6f3f			 
6f3f				; move onto next startup line? 
6f3f			.startnxt: 
6f3f			 
6f3f cd 86 0c			call delay250ms 
6f42 e1				pop hl 
6f43			 
6f43 23				inc hl 
6f44 23				inc hl 
6f45			 
6f45 e5				push hl 
6f46 5e				ld e, (hl) 
6f47 23				inc hl 
6f48 56				ld d, (hl) 
6f49 e1				pop hl 
6f4a				; TODO replace 0 test 
6f4a			 
6f4a eb				ex de, hl 
6f4b cd 72 0f			call ishlzero 
6f4e			;	ld a,e 
6f4e			;	add d 
6f4e			;	cp 0    ; any left to do? 
6f4e eb				ex de, hl 
6f4f c2 b4 6e			jp nz, .start1 
6f52 18 01			jr .startupend 
6f54			 
6f54 e1			.startupend1: pop hl 
6f55			.startupend: 
6f55			 
6f55 cd 15 0d			call clear_display 
6f58 cd 38 0d			call update_display 
6f5b c9				ret 
6f5c			 
6f5c			 
6f5c			; stack over and underflow checks 
6f5c			 
6f5c			; init the words to detect the under/overflow 
6f5c			 
6f5c			chk_stk_init: 
6f5c				; a vague random number to check so we dont get any "lucky" hits 
6f5c 3e 2d			ld a, 45 
6f5e 6f				ld l, a 
6f5f 00				nop 
6f60 3e 17			ld a, 23 
6f62 67				ld h, a 
6f63			 
6f63 22 35 f3			ld (chk_word), hl     ; the word we need to check against 
6f66			 
6f66			;	ld (chk_stund), hl	; stack points.... 
6f66 22 fd fe			ld (chk_stovr), hl 
6f69 22 79 fb			ld (chk_ret_und), hl 
6f6c 22 37 fb			ld (chk_ret_ovr), hl 
6f6f 22 b5 fa			ld (chk_loop_ovr), hl 
6f72 22 b3 f8			ld (chk_data_ovr), hl 
6f75 c9				ret 
6f76				 
6f76			check_stacks: 
6f76				; check all stack words 
6f76			 
6f76 e5				push hl 
6f77 d5				push de 
6f78			 
6f78			;	ld de,(chk_word) 
6f78			;	ld hl, (chk_stund)	; stack points.... 
6f78			;	if DEBUG_STK_FAULT 
6f78			;		DMARK "FAa" 
6f78			;		CALLMONITOR 
6f78			;	endif 
6f78			;	call cmp16 
6f78			;	jp z, .chk_faulta 
6f78			; 
6f78			;	ld de, sfaultsu 
6f78			;	jp .chk_fault 
6f78			 
6f78 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6f7b ed 5b 35 f3		ld de,(chk_word) 
6f7f				if DEBUG_STK_FAULT 
6f7f					DMARK "FAb" 
6f7f					CALLMONITOR 
6f7f				endif 
6f7f cd 67 0f			call cmp16 
6f82 28 06			jr z, .chk_fault1 
6f84 11 25 70			ld de, sfaultso 
6f87 c3 d9 6f			jp .chk_fault 
6f8a			.chk_fault1:  
6f8a 2a 79 fb			ld hl, (chk_ret_und) 
6f8d ed 5b 35 f3		ld de,(chk_word) 
6f91				if DEBUG_STK_FAULT 
6f91					DMARK "FAU" 
6f91					CALLMONITOR 
6f91				endif 
6f91 cd 67 0f			call cmp16 
6f94 ca 9d 6f			jp z, .chk_fault2 
6f97 11 35 70			ld de, sfaultru 
6f9a c3 d9 6f			jp .chk_fault 
6f9d			.chk_fault2:  
6f9d 2a 37 fb			ld hl, (chk_ret_ovr) 
6fa0 ed 5b 35 f3		ld de,(chk_word) 
6fa4				if DEBUG_STK_FAULT 
6fa4					DMARK "FA1" 
6fa4					CALLMONITOR 
6fa4				endif 
6fa4 cd 67 0f			call cmp16 
6fa7 ca b0 6f			jp z, .chk_fault3 
6faa 11 43 70			ld de, sfaultro 
6fad c3 d9 6f			jp .chk_fault 
6fb0			.chk_fault3:  
6fb0 2a b5 fa			ld hl, (chk_loop_ovr) 
6fb3 ed 5b 35 f3		ld de,(chk_word) 
6fb7				if DEBUG_STK_FAULT 
6fb7					DMARK "FA2" 
6fb7					CALLMONITOR 
6fb7				endif 
6fb7 cd 67 0f			call cmp16 
6fba ca c3 6f			jp z, .chk_fault4 
6fbd 11 5d 70			ld de, sfaultlo 
6fc0 c3 d9 6f			jp .chk_fault 
6fc3			.chk_fault4:  
6fc3 2a b3 f8			ld hl, (chk_data_ovr) 
6fc6 ed 5b 35 f3		ld de,(chk_word) 
6fca				if DEBUG_STK_FAULT 
6fca					DMARK "FA3" 
6fca					CALLMONITOR 
6fca				endif 
6fca cd 67 0f			call cmp16 
6fcd ca d6 6f			jp z, .chk_fault5 
6fd0 11 77 70			ld de, sfaultdo 
6fd3 c3 d9 6f			jp .chk_fault 
6fd6			 
6fd6			 
6fd6			.chk_fault5:  
6fd6 d1				pop de 
6fd7 e1				pop hl 
6fd8			 
6fd8 c9				ret 
6fd9			 
6fd9 cd 15 0d		.chk_fault: 	call clear_display 
6fdc 3e 14				ld a, display_row_2 
6fde cd 28 0d				call str_at_display 
6fe1 11 07 70				   ld de, .stackfault 
6fe4 3e 00				ld a, display_row_1 
6fe6 cd 28 0d				call str_at_display 
6fe9 11 b4 fe				    ld de, debug_mark 
6fec 3e 11				ld a, display_row_1+17 
6fee cd 28 0d				call str_at_display 
6ff1 cd 38 0d				call update_display 
6ff4			 
6ff4				; prompt before entering montior for investigating issue 
6ff4			 
6ff4 3e 3c			ld a, display_row_4 
6ff6 11 54 1c			ld de, endprog 
6ff9			 
6ff9 cd 38 0d			call update_display		 
6ffc			 
6ffc cd b2 1e			call next_page_prompt 
6fff			 
6fff d1				pop de 
7000 e1				pop hl 
7001 cd a8 1c				call monitor 
7004 c3 9f 1b				jp warmstart 
7007					;jp 0 
7007					;halt 
7007			 
7007			 
7007			 
7007 .. 00		.stackfault: 	db "Stack fault:",0 
7014			 
7014 .. 00		sfaultsu: 	db	"Stack under flow",0 
7025 .. 00		sfaultso: 	db	"Stack over flow",0 
7035 .. 00		sfaultru:	db "RTS underflow",0 
7043 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
705d .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7077 .. 00		sfaultdo:	db "DTS overflow", 0 
7084			 
7084			 
7084			fault_dsp_under: 
7084 11 96 70			ld de, .dsp_under 
7087 c3 46 71			jp .show_fault 
708a			 
708a			fault_rsp_under: 
708a 11 a4 70			ld de, .rsp_under 
708d c3 46 71			jp .show_fault 
7090			fault_loop_under: 
7090 11 b2 70			ld de, .loop_under 
7093 c3 46 71			jp .show_fault 
7096			 
7096 .. 00		.dsp_under: db "DSP Underflow",0 
70a4 .. 00		.rsp_under: db "RSP Underflow",0 
70b2 .. 00		.loop_under: db "LOOP Underflow",0 
70c1			 
70c1			 
70c1 d5			type_faultn: 	push de 
70c2 e5					push hl 
70c3 cd 15 0d				call clear_display 
70c6 11 ed 70				   ld de, .typefaultn 
70c9 3e 00				ld a, display_row_1 
70cb cd 28 0d				call str_at_display 
70ce 11 b4 fe				    ld de, debug_mark 
70d1 3e 11				ld a, display_row_1+17 
70d3 cd 28 0d				call str_at_display 
70d6 cd 38 0d				call update_display 
70d9			 
70d9				; prompt before entering montior for investigating issue 
70d9			 
70d9 3e 3c			ld a, display_row_4 
70db 11 54 1c			ld de, endprog 
70de			 
70de cd 38 0d			call update_display		 
70e1			 
70e1 cd b2 1e			call next_page_prompt 
70e4			 
70e4 e5					push hl 
70e5 d5					push de 
70e6 cd a8 1c				call monitor 
70e9 c3 9f 1b				jp warmstart 
70ec 76					halt 
70ed			 
70ed			 
70ed .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
7104			 
7104 d5			type_faults: 	push de 
7105 e5					push hl 
7106 cd 15 0d				call clear_display 
7109 11 2f 71				   ld de, .typefaults 
710c 3e 00				ld a, display_row_1 
710e cd 28 0d				call str_at_display 
7111 11 b4 fe				    ld de, debug_mark 
7114 3e 11				ld a, display_row_1+17 
7116 cd 28 0d				call str_at_display 
7119 cd 38 0d				call update_display 
711c			 
711c				; prompt before entering montior for investigating issue 
711c			 
711c 3e 3c			ld a, display_row_4 
711e 11 54 1c			ld de, endprog 
7121			 
7121 cd 38 0d			call update_display		 
7124			 
7124 cd b2 1e			call next_page_prompt 
7127			 
7127 e1					pop hl 
7128 d1					pop de 
7129 cd a8 1c				call monitor 
712c c3 9f 1b				jp warmstart 
712f			 
712f			 
712f .. 00		.typefaults: db "STR Type Expected TOS!",0 
7146			 
7146			.show_fault: 	 
7146 d5					push de 
7147 cd 15 0d				call clear_display 
714a d1					pop de 
714b 3e 00				ld a, display_row_1 
714d cd 28 0d				call str_at_display 
7150 11 b4 fe				    ld de, debug_mark 
7153 3e 11				ld a, display_row_1+17 
7155 cd 28 0d				call str_at_display 
7158 cd 38 0d				call update_display 
715b			 
715b				; prompt before entering montior for investigating issue 
715b			 
715b 3e 3c			ld a, display_row_4 
715d 11 54 1c			ld de, endprog 
7160			 
7160 cd 38 0d			call update_display		 
7163			 
7163 cd b2 1e			call next_page_prompt 
7166			 
7166 e1					pop hl 
7167 d1					pop de 
7168 cd a8 1c				call monitor 
716b			; do a dump to cli and not warmstart so we preserve all of the uwords.  
716b			; TODO Make optional fault restart to cli or warm boot? 
716b					;jp warmstart 
716b c3 fa 1b				jp cli 
716e 76					halt 
716f			 
716f			; handle the auto run of code from files in storage 
716f			 
716f			 
716f			if STORAGE_SE 
716f			 
716f .. 00		sprompt3: db "Loading from start-up file?:",0 
718c .. 00		sprompt4: db "(Y=Any key/N=No)",0 
719d			 
719d			 
719d			forth_autoload: 
719d			 
719d				; load block 0 of store 1 
719d				 
719d 3e fe			ld a, $fe      ; bit 0 clear 
719f 32 ed fb			ld (spi_device), a 
71a2			 
71a2 cd ca 04			call storage_get_block_0 
71a5			 
71a5 3a 28 fc			ld a, (store_page+STORE_0_AUTOFILE) 
71a8			 
71a8 fe 00			cp 0 
71aa c8				ret z     ; auto start not enabled 
71ab			 
71ab cd 15 0d			call clear_display 
71ae			 
71ae				; set bank 
71ae			 
71ae 3a 2a fc				ld a, (store_page+STORE_0_BANKRUN) 
71b1 32 ed fb				ld (spi_device), a 
71b4			 
71b4				; get file id to load from and get the file name to display 
71b4			 
71b4 3a 2b fc				ld a, (store_page+STORE_0_FILERUN) 
71b7			 
71b7 2e 00				ld l, 0 
71b9 67					ld h, a 
71ba 11 07 fc				ld de, store_page 
71bd			 
71bd					if DEBUG_FORTH_WORDS 
71bd						DMARK "ASp" 
71bd f5				push af  
71be 3a d2 71			ld a, (.dmark)  
71c1 32 b4 fe			ld (debug_mark),a  
71c4 3a d3 71			ld a, (.dmark+1)  
71c7 32 b5 fe			ld (debug_mark+1),a  
71ca 3a d4 71			ld a, (.dmark+2)  
71cd 32 b6 fe			ld (debug_mark+2),a  
71d0 18 03			jr .pastdmark  
71d2 ..			.dmark: db "ASp"  
71d5 f1			.pastdmark: pop af  
71d6			endm  
# End of macro DMARK
71d6						CALLMONITOR 
71d6 cd c6 18			call break_point_state  
71d9				endm  
# End of macro CALLMONITOR
71d9					endif 
71d9 cd 72 09				call storage_read 
71dc			 
71dc					if DEBUG_FORTH_WORDS 
71dc						DMARK "ASr" 
71dc f5				push af  
71dd 3a f1 71			ld a, (.dmark)  
71e0 32 b4 fe			ld (debug_mark),a  
71e3 3a f2 71			ld a, (.dmark+1)  
71e6 32 b5 fe			ld (debug_mark+1),a  
71e9 3a f3 71			ld a, (.dmark+2)  
71ec 32 b6 fe			ld (debug_mark+2),a  
71ef 18 03			jr .pastdmark  
71f1 ..			.dmark: db "ASr"  
71f4 f1			.pastdmark: pop af  
71f5			endm  
# End of macro DMARK
71f5						CALLMONITOR 
71f5 cd c6 18			call break_point_state  
71f8				endm  
# End of macro CALLMONITOR
71f8					endif 
71f8			 
71f8 cd 72 0f				call ishlzero 
71fb c8					ret z             ; file not found 
71fc			 
71fc 3e 1e				ld a, display_row_2 + 10 
71fe 11 0a fc				ld de, store_page+3 
7201 cd 28 0d				call str_at_display 
7204				 
7204			; 
7204			 
7204 3e 05			ld a, display_row_1+5 
7206 11 6f 71			ld de, sprompt3 
7209 cd 28 0d			call str_at_display 
720c 3e 37			ld a, display_row_3+15 
720e 11 8c 71			ld de, sprompt4 
7211 cd 28 0d			call str_at_display 
7214			 
7214 cd 38 0d			call update_display 
7217			 
7217 cd 5b 74			call cin_wait 
721a fe 6e			cp 'n' 
721c c8				ret z 
721d fe 4e			cp 'N' 
721f c8				ret z 
7220			 
7220 cd 92 0c			call delay1s 
7223			 
7223 3a 09 fc			ld a, (store_page+2) 
7226 32 f6 fb			ld (store_openmaxext), a    ; save count of ext 
7229 3e 01			ld a, 1  
722b 32 f7 fb			ld (store_openext), a    ; save count of ext 
722e			 
722e			.autof:  
722e 6f				ld l , a 
722f				 
722f 3a 07 fc			ld a, (store_page) 
7232 67				ld h, a	 
7233 11 07 fc			ld de, store_page 
7236					if DEBUG_FORTH_WORDS 
7236						DMARK "ASl" 
7236 f5				push af  
7237 3a 4b 72			ld a, (.dmark)  
723a 32 b4 fe			ld (debug_mark),a  
723d 3a 4c 72			ld a, (.dmark+1)  
7240 32 b5 fe			ld (debug_mark+1),a  
7243 3a 4d 72			ld a, (.dmark+2)  
7246 32 b6 fe			ld (debug_mark+2),a  
7249 18 03			jr .pastdmark  
724b ..			.dmark: db "ASl"  
724e f1			.pastdmark: pop af  
724f			endm  
# End of macro DMARK
724f						CALLMONITOR 
724f cd c6 18			call break_point_state  
7252				endm  
# End of macro CALLMONITOR
7252					endif 
7252 cd 72 09				call storage_read 
7255 cd 72 0f			call ishlzero 
7258 c8				ret z 
7259			;	jr z, .autoend 
7259			 
7259					if DEBUG_FORTH_WORDS 
7259						DMARK "ASc" 
7259 f5				push af  
725a 3a 6e 72			ld a, (.dmark)  
725d 32 b4 fe			ld (debug_mark),a  
7260 3a 6f 72			ld a, (.dmark+1)  
7263 32 b5 fe			ld (debug_mark+1),a  
7266 3a 70 72			ld a, (.dmark+2)  
7269 32 b6 fe			ld (debug_mark+2),a  
726c 18 03			jr .pastdmark  
726e ..			.dmark: db "ASc"  
7271 f1			.pastdmark: pop af  
7272			endm  
# End of macro DMARK
7272						CALLMONITOR 
7272 cd c6 18			call break_point_state  
7275				endm  
# End of macro CALLMONITOR
7275					endif 
7275 11 09 fc			ld de, store_page+2 
7278 3e 3c			ld a, display_row_4 
727a cd 28 0d			call str_at_display 
727d			 
727d cd 38 0d			call update_display 
7280 cd 86 0c			call delay250ms 
7283			 
7283			 
7283			 
7283 21 09 fc			ld hl, store_page+2 
7286 cd 35 23			call forthparse 
7289 cd 75 23			call forthexec 
728c cd 87 22			call forthexec_cleanup 
728f			 
728f				 
728f 3a f7 fb			ld a, (store_openext) 
7292 3c				inc a 
7293 32 f7 fb			ld (store_openext), a    ; save count of ext 
7296			 
7296 18 96			jr .autof 
7298			;.autofdone: 
7298			; 
7298			;		if DEBUG_FORTH_WORDS 
7298			;			DMARK "ASx" 
7298			;			CALLMONITOR 
7298			;		endif 
7298			;;	call clear_display 
7298			;	ret 
7298			 
7298			 
7298			 
7298			endif 
7298			 
7298			 
7298			; eof 
# End of file forth_kernel.asm
7298			;include "nascombasic.asm" 
7298			 
7298			 
7298			; find out where the code ends if loaded into RAM (for SC114) 
7298			;endofcode:  
7298			;	nop 
7298			 
7298			 
7298			; eof 
7298			 
# End of file main.asm
7298			include "firmware_lcd_4x20.asm" 
7298			; **********************************************************************  
7298			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7298			; **********************************************************************  
7298			;  
7298			; **  Written as a Small Computer Monitor App  
7298			; **  www.scc.me.uk  
7298			;  
7298			; History  
7298			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7298			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7298			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7298			;  
7298			; **********************************************************************  
7298			;  
7298			; This program is an example of one of the methods of interfacing an   
7298			; alphanumeric LCD module.   
7298			;  
7298			; In this example the display is connected to either a Z80 PIO or a   
7298			; simple 8-bit output port.   
7298			;  
7298			; This interfacing method uses 4-bit data mode and uses time delays  
7298			; rather than polling the display's ready status. As a result the   
7298			; interface only requires 6 simple output lines:  
7298			;   Output bit 0 = not used  
7298			;   Output bit 1 = not used  
7298			;   Output bit 2 = RS         High = data, Low = instruction  
7298			;   Output bit 3 = E          Active high  
7298			;   Output bit 4 = DB4  
7298			;   Output bit 5 = DB5  
7298			;   Output bit 6 = DB6  
7298			;   Output bit 7 = DB7  
7298			; Display's R/W is connected to 0v so it is always in write mode  
7298			;  
7298			; This set up should work with any system supporting the RC2014 bus  
7298			  
7298			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7298			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7298			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7298			;  
7298			; **********************************************************************  
7298			  
7298			; **********************************************************************  
7298			; **  Constants  
7298			; **********************************************************************  
7298			; LCD constants required by LCD support module  
7298			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7298			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7298			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
7298			kLCDWidth:  EQU display_cols             ;Width in characters  
7298			  
7298			; **********************************************************************  
7298			; **  Code library usage  
7298			; **********************************************************************  
7298			  
7298			; send character to current cursor position  
7298			; wraps and/or scrolls screen automatically  
7298			  
7298			  
7298			lcd_init:  
7298			  
7298			; SCMonAPI functions used  
7298			  
7298			; Alphanumeric LCD functions used  
7298			; no need to specify specific functions for this module  
7298			  
7298 3e cf		            LD   A, 11001111b  
729a d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
729c 3e 00		            LD   A, 00000000b  
729e d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
72a0			  
72a0			; Initialise alphanumeric LCD module  
72a0 cd 19 73		            CALL fLCD_Init      ;Initialise LCD module  
72a3			  
72a3 c9				ret  
72a4			  
72a4			;  
72a4			;;  
72a4			; lcd functions  
72a4			;  
72a4			;  
72a4			  
72a4			; what is at cursor position   
72a4			  
72a4			;get_cursor:	ld de, (cursor_row)   ;  row + col  
72a4			;		call curptr  
72a4			;		ret  
72a4			  
72a4			  
72a4			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
72a4			  
72a4			curptr:  
72a4 c5				push bc  
72a5 21 4a fe			ld hl, display_fb0  
72a8			cpr:	  
72a8				; loop for cursor whole row  
72a8 0e 14			ld c, display_cols  
72aa 23			cpr1:	inc hl  
72ab 0d				dec c  
72ac 20 fc			jr nz, cpr1  
72ae 05				dec b  
72af 20 f7			jr nz, cpr  
72b1			  
72b1				; add col	  
72b1			  
72b1 23			cpr2:	inc hl  
72b2 1d				dec e  
72b3 20 fc			jr nz, cpr2  
72b5			  
72b5 c1				pop bc  
72b6 c9				ret  
72b7				  
72b7			  
72b7			  
72b7			  
72b7			  
72b7			; write the frame buffer given in hl to hardware   
72b7 22 52 fd		write_display: ld (display_write_tmp), hl 	   
72ba 3e 00			ld a, kLCD_Line1  
72bc cd 8a 73		            CALL fLCD_Pos       ;Position cursor to location in A  
72bf 06 14			ld b, display_cols  
72c1 ed 5b 52 fd		ld de, (display_write_tmp)  
72c5 cd 11 73			call write_len_string  
72c8				  
72c8				  
72c8 2a 52 fd			ld hl, (display_write_tmp)  
72cb 11 14 00			ld de, display_cols  
72ce 19				add hl,de  
72cf 22 52 fd			ld (display_write_tmp),hl  
72d2			  
72d2				  
72d2 3e 40			ld a, kLCD_Line2  
72d4 cd 8a 73		            CALL fLCD_Pos       ;Position cursor to location in A  
72d7 06 14			ld b, display_cols  
72d9 ed 5b 52 fd		ld de, (display_write_tmp)  
72dd cd 11 73			call write_len_string  
72e0				  
72e0 2a 52 fd			ld hl, (display_write_tmp)  
72e3 11 14 00			ld de, display_cols  
72e6 19				add hl,de  
72e7 22 52 fd			ld (display_write_tmp),hl  
72ea			  
72ea				  
72ea 3e 14			ld a, kLCD_Line3  
72ec cd 8a 73		            CALL fLCD_Pos       ;Position cursor to location in A  
72ef 06 14			ld b, display_cols  
72f1 ed 5b 52 fd		ld de, (display_write_tmp)  
72f5 cd 11 73			call write_len_string  
72f8				  
72f8 2a 52 fd			ld hl, (display_write_tmp)  
72fb 11 14 00			ld de, display_cols  
72fe 19				add hl,de  
72ff 22 52 fd			ld (display_write_tmp),hl  
7302			  
7302				  
7302 3e 54			ld a, kLCD_Line4  
7304 cd 8a 73		            CALL fLCD_Pos       ;Position cursor to location in A  
7307 06 14			ld b, display_cols  
7309 ed 5b 52 fd		ld de, (display_write_tmp)  
730d cd 11 73			call write_len_string  
7310 c9					ret  
7311				  
7311				; write out a fixed length string given in b from de  
7311			  
7311 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
7312 cd 63 73		            CALL fLCD_Data      ;Write character to display  
7315 13				inc de  
7316 10 f9			djnz write_len_string  
7318 c9				ret  
7319			  
7319			; Some other things to do  
7319			;            LD   A, kLCD_Clear ;Display clear  
7319			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7319			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7319			;            LD   A, kLCD_On     ;Display on with no cursor  
7319			;            ;LD   A, kLCD_Off   ;Display off  
7319			;            CALL fLCD_Inst      ;Send instruction to display  
7319			;  
7319			;  
7319			;            halt  
7319			;  
7319			;  
7319			;MsgHello:   DB  "Hello World!",0  
7319			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7319			  
7319			; Custom characters 5 pixels wide by 8 pixels high  
7319			; Up to 8 custom characters can be defined  
7319			;BitMaps:      
7319			;; Character 0x00 = Battery icon  
7319			;            DB  01110b  
7319			;            DB  11011b  
7319			;            DB  10001b  
7319			;            DB  10001b  
7319			;            DB  11111b  
7319			;            DB  11111b  
7319			;            DB  11111b  
7319			;            DB  11111b  
7319			;; Character 0x01 = Bluetooth icon  
7319			;            DB  01100b  
7319			;            DB  01010b  
7319			;            DB  11100b  
7319			;            DB  01000b  
7319			;            DB  11100b  
7319			;            DB  01010b  
7319			;            DB  01100b  
7319			;            DB  00000b  
7319			;  
7319			  
7319			  
7319			; **********************************************************************  
7319			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7319			; **********************************************************************  
7319			;  
7319			; **  Written as a Small Computer Monitor App   
7319			; **  Version 0.1 SCC 2018-05-16  
7319			; **  www.scc.me.uk  
7319			;  
7319			; **********************************************************************  
7319			;  
7319			; This module provides support for alphanumeric LCD modules using with  
7319			; *  HD44780 (or compatible) controller  
7319			; *  5 x 7 pixel fonts  
7319			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7319			; *  Interface via six digital outputs to the display (see below)  
7319			;  
7319			; LCD module pinout:  
7319			;   1  Vss   0v supply  
7319			;   2  Vdd   5v supply  
7319			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7319			;   4  RS    High = data, Low = instruction  
7319			;   5  R/W   High = Read, Low = Write  
7319			;   6  E     Enable signal (active high)  
7319			;   7  DB0   Data bit 0  
7319			;   8  DB1   Data bit 1  
7319			;   9  DB2   Data bit 2  
7319			;  10  DB3   Data bit 3  
7319			;  11  DB4   Data bit 4  
7319			;  12  DB5   Data bit 5  
7319			;  13  DB6   Data bit 6  
7319			;  14  DB7   Data bit 7  
7319			;  15  A     Backlight anode (+)  
7319			;  16  K     Backlight cathode (-)  
7319			;  
7319			; This interfacing method uses 4-bit data mode and uses time delays  
7319			; rather than polling the display's ready status. As a result the   
7319			; interface only requires 6 simple output lines:  
7319			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7319			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7319			;   LCD DB4 = Microcomputer output port bit 4  
7319			;   LCD DB5 = Microcomputer output port bit 5  
7319			;   LCD DB6 = Microcomputer output port bit 6  
7319			;   LCD DB7 = Microcomputer output port bit 7  
7319			; Display's R/W is connected to 0v so it is always in write mode  
7319			; All 6 connections must be on the same port address <kLCDPrt>  
7319			; This method also allows a decent length of cable from micro to LCD  
7319			;  
7319			; **********************************************************************  
7319			;  
7319			; To include the code for any given function provided by this module,   
7319			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7319			; the parent source file.  
7319			; For example:  #REQUIRES   uHexPrefix  
7319			;  
7319			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7319			; in the parent source file.  
7319			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7319			;  
7319			; These are the function names provided by this module:  
7319			; fLCD_Init                     ;Initialise LCD  
7319			; fLCD_Inst                     ;Send instruction to LCD  
7319			; fLCD_Data                     ;Send data byte to LCD  
7319			; fLCD_Pos                      ;Position cursor  
7319			; fLCD_Str                      ;Display string  
7319			; fLCD_Def                      ;Define custom character  
7319			;  
7319			; **********************************************************************  
7319			;  
7319			; Requires SCMonAPI.asm to also be included in the project  
7319			;  
7319			  
7319			  
7319			; **********************************************************************  
7319			; **  Constants  
7319			; **********************************************************************  
7319			  
7319			; Constants that must be defined externally  
7319			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7319			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7319			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7319			;kLCDWidth: EQU 20             ;Width in characters  
7319			  
7319			; general line offsets in any frame buffer  
7319			  
7319			  
7319			display_row_1: equ 0  
7319			display_row_2: equ display_row_1+display_cols  
7319			display_row_3: equ display_row_2 + display_cols  
7319			display_row_4: equ display_row_3 + display_cols  
7319			;display_row_4_eol:   
7319			  
7319			  
7319			; Cursor position values for the start of each line  
7319			kLCD_Line1: EQU 0x00   
7319			kLCD_Line2: EQU 0x40    
7319			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
7319			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
7319			  
7319			; Instructions to send as A register to fLCD_Inst  
7319			kLCD_Clear: EQU 00000001b     ;LCD clear  
7319			kLCD_Off:   EQU 00001000b     ;LCD off  
7319			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7319			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7319			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7319			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7319			  
7319			; Constants used by this code module  
7319			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7319			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7319			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7319			  
7319			  
7319			  
7319			; **********************************************************************  
7319			; **  LCD support functions  
7319			; **********************************************************************  
7319			  
7319			; Initialise alphanumeric LCD module  
7319			; LCD control register codes:  
7319			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7319			;   N    0 = 1-line mode       1 = 2-line mode  
7319			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7319			;   D    0 = Display off       1 = Display on  
7319			;   C    0 = Cursor off        1 = Cursor on  
7319			;   B    0 = Blinking off      1 = Blinking on  
7319			;   ID   0 = Decrement mode    1 = Increment mode  
7319			;   SH   0 = Entire shift off  1 = Entire shift on  
7319 3e 28		fLCD_Init:  LD   A, 40  
731b cd d0 73		            CALL LCDDelay       ;Delay 40ms after power up  
731e			; For reliable reset set 8-bit mode - 3 times  
731e cd ba 73		            CALL WrFn8bit       ;Function = 8-bit mode  
7321 cd ba 73		            CALL WrFn8bit       ;Function = 8-bit mode  
7324 cd ba 73		            CALL WrFn8bit       ;Function = 8-bit mode  
7327			; Set 4-bit mode  
7327 cd b6 73		            CALL WrFn4bit       ;Function = 4-bit mode  
732a cd ce 73		            CALL LCDDelay1      ;Delay 37 us or more  
732d			; Function set  
732d 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
732f cd 42 73		            CALL fLCD_Inst      ;2 line, display on  
7332			; Display On/Off control  
7332 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7334 cd 42 73		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7337			; Display Clear  
7337 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7339 cd 42 73		            CALL fLCD_Inst      ;Clear display  
733c			; Entry mode  
733c 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
733e cd 42 73		            CALL fLCD_Inst      ;Increment mode, shift off  
7341			; Display module now initialised  
7341 c9			            RET  
7342			; ok to here  
7342			  
7342			; Write instruction to LCD  
7342			;   On entry: A = Instruction byte to be written  
7342			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7342 f5			fLCD_Inst:  PUSH AF  
7343 f5			            PUSH AF  
7344 cd 56 73		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7347 f1			            POP  AF  
7348 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7349 17			            RLA  
734a 17			            RLA  
734b 17			            RLA  
734c cd 56 73		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
734f 3e 02		            LD   A, 2  
7351 cd d0 73		            CALL LCDDelay       ;Delay 2 ms to complete   
7354 f1			            POP  AF  
7355 c9			            RET  
7356 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
7358 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
735a cb df		            SET  kLCDBitE, A  
735c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
735e cb 9f		            RES  kLCDBitE, A  
7360 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7362 c9			            RET  
7363			  
7363			  
7363			; Write data to LCD  
7363			;   On entry: A = Data byte to be written  
7363			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7363 f5			fLCD_Data:  PUSH AF  
7364 f5			            PUSH AF  
7365 cd 77 73		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7368 f1			            POP  AF  
7369 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
736a 17			            RLA  
736b 17			            RLA  
736c 17			            RLA  
736d cd 77 73		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7370 3e 96		            LD   A, 150  
7372 3d			Wait:      DEC  A              ;Wait a while to allow data   
7373 20 fd		            JR   NZ, Wait      ;  write to complete  
7375 f1			            POP  AF  
7376 c9			            RET  
7377 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
7379 cb d7		            SET  kLCDBitRS, A  
737b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
737d cb df		            SET  kLCDBitE, A  
737f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7381 cb 9f		            RES  kLCDBitE, A  
7383 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7385 cb 97		            RES  kLCDBitRS, A  
7387 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7389 c9			            RET  
738a			  
738a			  
738a			; Position cursor to specified location  
738a			;   On entry: A = Cursor position  
738a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
738a f5			fLCD_Pos:   PUSH AF  
738b f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
738d cd 42 73		            CALL fLCD_Inst      ;Write instruction to LCD  
7390 f1			            POP  AF  
7391 c9			            RET  
7392			  
7392			  
7392			; Output text string to LCD  
7392			;   On entry: DE = Pointer to null terminated text string  
7392			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7392 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7393 b7			            OR   A              ;Null terminator?  
7394 c8			            RET  Z              ;Yes, so finished  
7395 cd 63 73		            CALL fLCD_Data      ;Write character to display  
7398 13			            INC  DE             ;Point to next character  
7399 18 f7		            JR   fLCD_Str       ;Repeat  
739b c9					ret  
739c			  
739c			; Define custom character  
739c			;   On entry: A = Character number (0 to 7)  
739c			;             DE = Pointer to character bitmap data  
739c			;   On exit:  A = Next character number  
739c			;             DE = Next location following bitmap  
739c			;             BC HL IX IY I AF' BC' DE' HL' preserved  
739c			; Character is   
739c c5			fLCD_Def:   PUSH BC  
739d f5			            PUSH AF  
739e 07			            RLCA                ;Calculate location  
739f 07			            RLCA                ;  for bitmap data  
73a0 07			            RLCA                ;  = 8 x CharacterNumber  
73a1 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
73a3 cd 42 73		            CALL fLCD_Inst      ;Write instruction to LCD  
73a6 06 00		            LD   B, 0  
73a8 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
73a9 cd 63 73		            CALL fLCD_Data      ;Write byte to display  
73ac 13			            INC  DE             ;Point to next byte  
73ad 04			            INC  B              ;Count bytes  
73ae cb 58		            BIT  3, B           ;Finish all 8 bytes?  
73b0 28 f6		            JR   Z, Loop       ;No, so repeat  
73b2 f1			            POP  AF  
73b3 3c			            INC  A              ;Increment character number  
73b4 c1			            POP  BC  
73b5 c9			            RET  
73b6			  
73b6			  
73b6			; **********************************************************************  
73b6			; **  Private functions  
73b6			; **********************************************************************  
73b6			  
73b6			; Write function to LCD  
73b6			;   On entry: A = Function byte to be written  
73b6			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
73b6 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
73b8 18 02		            JR   WrFunc  
73ba 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
73bc f5			WrFunc:     PUSH AF  
73bd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
73bf cb df		            SET  kLCDBitE, A  
73c1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
73c3 cb 9f		            RES  kLCDBitE, A  
73c5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
73c7 3e 05		            LD   A, 5  
73c9 cd d0 73		            CALL LCDDelay       ;Delay 5 ms to complete  
73cc f1			            POP  AF  
73cd c9			            RET  
73ce			  
73ce			  
73ce			; Delay in milliseconds  
73ce			;   On entry: A = Number of milliseconds delay  
73ce			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
73ce 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
73d0 d5			LCDDelay:   PUSH DE  
73d1 5f			            LD   E, A           ;Delay by 'A' ms  
73d2 16 00		            LD   D, 0  
73d4 cd 77 0c		            CALL aDelayInMS  
73d7 d1			            POP  DE  
73d8 c9			            RET  
73d9			  
73d9			  
73d9			  
73d9			  
73d9			; eof  
73d9			  
# End of file firmware_lcd_4x20.asm
73d9			include "firmware_key_4x4.asm" 
73d9			  
73d9			  
73d9			; bit mask for each scan column and row for teing the matrix  
73d9			  
73d9			; out   
73d9 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
73dd			; in  
73dd 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
73e1			  
73e1			; row/col to character map  
73e1			  
73e1			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
73e1			;    
73e1			  
73e1			; physical key matrix map to face of key  
73e1			  
73e1			  
73e1			;      	1	2	3	A  
73e1			;   	abc”	def&	ghi$	s1  
73e1			;			  
73e1			;	4	5	6	B  
73e1			; 	jkl,	mno.	pqr:	s2  
73e1			;			  
73e1			; 	7	8	9	C  
73e1			;	stu;	vwx@	yz?!	s3  
73e1			;			  
73e1			; 	*	0	#	D  
73e1			; 	shift lck '	Space < >	Enter ( )	s4  
73e1			;       tab bs 		  
73e1			  
73e1			  
73e1			  
73e1			  
73e1			key_init:  
73e1			  
73e1			; SCMonAPI functions used  
73e1			  
73e1			; Alphanumeric LCD functions used  
73e1			; no need to specify specific functions for this module  
73e1			  
73e1			  
73e1 3e cf		            LD   A, 11001111b  
73e3 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
73e5			;            LD   A, 00000000b  
73e5 3e 0f		            LD   A, 00001111b  
73e7 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
73e9			  
73e9			  
73e9				; TODO Configure cursor shapes  
73e9			  
73e9				; Load cursor shapes   
73e9 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
73eb 11 fb 73		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
73ee 06 02		            LD   B, 2           ;Number of characters to define  
73f0 cd 9c 73		.DefLoop:   CALL fLCD_Def       ;Define custom character  
73f3 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
73f5			  
73f5 3e 01				ld a, 1  
73f7 32 4d fd			ld (cursor_shape),a  
73fa c9				ret  
73fb			  
73fb			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
73fb			; Up to 8 custom characters can be defined  
73fb			.cursor_shapes:      
73fb			;; Character 0x00 = Normal  
73fb 1f			            DB  11111b  
73fc 1f			            DB  11111b  
73fd 1f			            DB  11111b  
73fe 1f			            DB  11111b  
73ff 1f			            DB  11111b  
7400 1f			            DB  11111b  
7401 1f			            DB  11111b  
7402 1f			            DB  11111b  
7403			;; Character 0x01 = Modifier  
7403 1f			            DB  11111b  
7404 1b			            DB  11011b  
7405 1b			            DB  11011b  
7406 1b			            DB  11011b  
7407 1b			            DB  11011b  
7408 1f			            DB  11111b  
7409 1b			            DB  11011b  
740a 1f			            DB  11111b  
740b			  
740b			  
740b			  
740b			  
740b			; Display custom character 0  
740b			;            LD   A, kLCD_Line1+14  
740b			;            CALL fLCD_Pos       ;Position cursor to location in A  
740b			;            LD   A, 0  
740b			;            CALL fLCD_Data      ;Write character in A at cursor  
740b			  
740b			; Display custom character 1  
740b			;            LD   A, kLCD_Line2+14  
740b			;            CALL fLCD_Pos      ;Position cursor to location in A  
740b			;            LD   A, 1  
740b			;            CALL fLCD_Data     ;Write character in A at cursor  
740b			  
740b			; keyboard scanning   
740b			  
740b			  
740b			; key_rows: equ 4  
740b			; key_cols: equ 4  
740b			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
740b			  
740b			; key_scanr: equ key_row_bitmask  
740b			; key_scanc: equ key_col_bitmask  
740b			  
740b			; key_char_map: equ key_map  
740b			  
740b			  
740b			  
740b			; character in from keyboard  
740b			  
740b ..			.matrix_to_char: db "D#0*C987B654A321"  
741b			  
741b			  
741b			; map the physical key to a char dependant on state  
741b			  
741b			.key_map_fa:   
741b			  
741b ..					db 'D'  
741c 0d					db KEY_CR    ; cr  
741d ..					db ' '  
741e 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
741f ..					db 'C'  
7420 ..					db 'y'  
7421 ..					db 'v'  
7422 ..					db 's'  
7423 ..					db 'B'  
7424 ..					db 'p'  
7425 ..					db 'm'  
7426 ..					db 'j'  
7427 ..					db 'A'  
7428 ..					db 'g'  
7429 ..					db 'd'  
742a ..					db 'a'  
742b			  
742b			.key_map_fb:  
742b			  
742b ..					db 'A'  
742c ..					db '+'   
742d ..					db '<'  
742e ..					db  "'"    
742f			  
742f ..					db 'A'  
7430 ..					db 'z'  
7431 ..					db 'w'  
7432 ..					db 't'  
7433 ..					db 'A'  
7434 ..					db 'q'  
7435 ..					db 'n'  
7436 ..					db 'k'  
7437 ..					db 'A'  
7438 ..					db 'h'  
7439 ..					db 'e'  
743a ..			 		db 'b'  
743b			  
743b			.key_map_fc:   
743b			  
743b			  
743b ..					db 'A'  
743c ..					db '-'   
743d ..					db '>'  
743e ..					db  '='   	  
743f ..					db 'A'  
7440 ..					db '?'  
7441 ..					db 'x'  
7442 ..					db 'u'  
7443 ..					db 'A'  
7444 ..					db 'r'  
7445 ..					db 'o'  
7446 ..					db 'l'  
7447 ..					db 'A'  
7448 ..					db 'i'  
7449 ..					db 'f'  
744a ..					db 'c'  
744b			  
744b				  
744b			.key_map_fd:  
744b			  
744b ..					db 'A'  
744c ..					db '/'   
744d ..					db '%'   
744e 08					db KEY_BS  ; back space  
744f ..					db 'A'  
7450 ..					db '!'  
7451 ..					db '@'  
7452 ..					db ';'  
7453 ..					db 'A'  
7454 ..					db ':'  
7455 ..					db '.'  
7456 ..					db ','  
7457 ..					db 'A'  
7458 ..					db '$'  
7459 ..					db '&'  
745a ..				 	db '"'  
745b			  
745b					  
745b				  
745b			  
745b			; add cin and cin_wait  
745b			  
745b cd 6c 74		cin_wait: 	call cin  
745e fe 00			cp 0  
7460 28 f9			jr z, cin_wait   ; block until key press  
7462			  
7462 f5				push af   ; save key pressed  
7463			  
7463 cd 6c 74		.cin_wait1:	call cin  
7466 fe 00			cp 0  
7468 20 f9			jr nz, .cin_wait1  	; wait for key release  
746a			  
746a f1				pop af   ; get key  
746b c9				ret  
746c			  
746c			  
746c cd 7d 74		cin: 	call .mtoc  
746f			  
746f				; no key held  
746f fe 00			cp 0  
7471 c8				ret z  
7472			  
7472				; stop key bounce  
7472			  
7472			;	ld (key_held),a		 ; save it  
7472 47				ld b, a  
7473			  
7473 c5			.cina1:	push bc  
7474 cd 7d 74			call .mtoc  
7477 c1				pop bc  
7478 b8				cp b  
7479 28 f8			jr z, .cina1  
747b 78				ld a,b		  
747c c9				ret  
747d			  
747d			; detect keyboard modifier key press and apply new overlay to the face key held  
747d			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
747d			  
747d			;.cin_map_modifier:   
747d			;	ld a, (hl)  
747d			;	and 255  
747d			;	ret NZ		; modifier key not flagged  
747d			;  
747d			;	; get key face  
747d			;  
747d			;	ld b,(key_face_held)  
747d			;  
747d			;	ld b, key_cols * key_rows  
747d			;  
747d			;	push de  
747d			;	pop hl  
747d			;  
747d			;.mmod1: ld a,(hl)   ; get map test  
747d			;	cp b  
747d			;	jr z, .mmod2  
747d			;  
747d			;  
747d			;  
747d			;.mmod2: inc hl    ;   
747d			;  
747d			;	  
747d			;  
747d			;	  
747d			;  
747d			;	ld hl,key_actual_pressed  
747d			;	ld (hl),a,  
747d			;	ret  
747d			  
747d				  
747d			  
747d			; map matrix key held to char on face of key  
747d			  
747d			.mtoc:  
747d			  
747d			  
747d				; TODO optimise the code....  
747d			  
747d			; scan keyboard row 1  
747d 3e 80			ld a, 128  
747f 21 d3 fe			ld hl, keyscan_table  
7482 cd 64 75			call .rowscan  
7485			  
7485				   
7485			  
7485 3e 40			ld a, 64  
7487 21 d7 fe			ld hl, keyscan_table+key_cols  
748a cd 64 75			call .rowscan  
748d			  
748d			  
748d			  
748d			  
748d 3e 20			ld a, 32  
748f 21 db fe			ld hl, keyscan_table+(key_cols*2)  
7492 cd 64 75			call .rowscan  
7495			  
7495			  
7495			  
7495 3e 10			ld a, 16  
7497 21 df fe			ld hl, keyscan_table+(key_cols*3)  
749a cd 64 75			call .rowscan  
749d			  
749d			  
749d				; flag if key D is held down and remove from reporting  
749d 01 4b 74			ld bc, .key_map_fd    
74a0 21 d3 fe			ld hl, keyscan_table  
74a3 11 c5 fe			ld de, key_fd  
74a6 cd f6 74			call .key_shift_hold  
74a9 fe ff			cp 255  
74ab 28 33			jr z, .cinmap  
74ad				; flag if key C is held down and remove from reporting  
74ad 01 3b 74			ld bc, .key_map_fc    
74b0 21 d7 fe			ld hl, keyscan_table+key_cols  
74b3 11 c6 fe			ld de, key_fc  
74b6 cd f6 74			call .key_shift_hold  
74b9 fe ff			cp 255  
74bb 28 23			jr z, .cinmap  
74bd				; flag if key B is held down and remove from reporting  
74bd 01 2b 74			ld bc, .key_map_fb    
74c0 21 db fe			ld hl, keyscan_table+(key_cols*2)  
74c3 11 c7 fe			ld de, key_fb  
74c6 cd f6 74			call .key_shift_hold  
74c9 fe ff			cp 255  
74cb 28 13			jr z, .cinmap  
74cd				; flag if key A is held down and remove from reporting  
74cd 01 1b 74			ld bc, .key_map_fa    
74d0 21 df fe			ld hl, keyscan_table+(key_cols*3)  
74d3 11 c8 fe			ld de, key_fa  
74d6 cd f6 74			call .key_shift_hold  
74d9 fe ff			cp 255  
74db 28 03			jr z, .cinmap  
74dd			  
74dd 11 0b 74			ld de, .matrix_to_char  
74e0			  
74e0			  
74e0			.cinmap:   
74e0				if DEBUG_KEY  
74e0			            LD   A, kLCD_Line4  
74e0			            CALL fLCD_Pos       ;Position cursor to location in A  
74e0					push de  
74e0			            LD   DE, keyscan_table  
74e0			            CALL fLCD_Str       ;Display string pointed to by DE  
74e0					pop de  
74e0				endif  
74e0			  
74e0				; scan key matrix table for any held key  
74e0			  
74e0				; de holds either the default matrix or one selected above  
74e0			  
74e0 21 d3 fe			ld hl, keyscan_table  
74e3 06 10			ld b,key_cols*key_rows  
74e5			  
74e5 7e			.cin1:	ld a,(hl)  
74e6 fe 23			cp '#'  
74e8 28 08			jr z, .cinhit  
74ea 23				inc hl  
74eb 13				inc de  
74ec 05				dec b  
74ed 20 f6			jr nz, .cin1  
74ef				; no key found held  
74ef 3e 00			ld a,0  
74f1 c9				ret  
74f2 d5			.cinhit: push de  
74f3 e1				pop hl  
74f4 7e				ld a,(hl)  
74f5 c9				ret  
74f6			  
74f6			; flag a control key is held   
74f6			; hl is key pin, de is flag indicator  
74f6			  
74f6			.key_shift_hold:  
74f6 c5				push bc  
74f7 3e 01			ld a, 1  
74f9 32 4d fd			ld (cursor_shape),a  
74fc 06 00			ld b, 0  
74fe 7e				ld a, (hl)  
74ff fe 2e			cp '.'  
7501 28 0a			jr z, .key_shift1  
7503 06 ff			ld b, 255  
7505 3e 2b			ld a, '+'    ; hide key from later scans  
7507 77				ld (hl),a  
7508 3e 02			ld a, 2  
750a 32 4d fd			ld (cursor_shape),a  
750d			.key_shift1:  
750d				; write flag indicator  
750d 78				ld a,b  
750e 12				ld (de),a  
750f			  
750f d1				pop de    ; de now holds the key map ptr  
7510 c9				ret  
7511			  
7511				  
7511				  
7511			  
7511			  
7511			  
7511			  
7511			  
7511			  
7511			  
7511			  
7511			  
7511			  
7511 c9				ret  
7512			  
7512			;	push hl  
7512			;	push de  
7512			;	push bc  
7512			;	call keyscan  
7512			;	; map key matrix to ascii value of key face  
7512			;  
7512			;	ld hl, key_face_map  
7512			;	ld de, keyscan_table  
7512			;  
7512			;	; get how many keys to look at  
7512			;	ld b, keyscan_table_len  
7512			;	  
7512			;  
7512			;	; at this stage fall out on first key hit  
7512			;	; TODO handle multiple key press  
7512			;  
7512			;map1:	ld a,(hl)  
7512			;	cp '#'  
7512			;	jr z, keyhit  
7512			;	inc hl  
7512			;	inc de  
7512			;	dec b  
7512			;	jr nz, map1  
7512			;nohit:	ld a, 0  
7512			;	jr keydone  
7512			;keyhit: push de  
7512			;	pop hl  
7512			;	ld a,(hl)  
7512			;keydone:  
7512			;	push bc  
7512			;	push de  
7512			; 	push hl  
7512			;	ret   
7512			;  
7512			  
7512			  
7512			  
7512			  
7512			; scan physical key matrix  
7512			  
7512			  
7512			;keyscan:  
7512			;  
7512			;; for each key_row use keyscanr bit mask for out  
7512			;; then read in for keyscanc bitmask  
7512			;; save result of row scan to keyscantable  
7512			;  
7512			;; scan keyboard row 1  
7512			;  
7512			;	ld b, key_rows  
7512			;	ld hl, key_scanr  
7512			;	ld de, keyscan_table  
7512			;  
7512			;rowloop:  
7512			;  
7512			;	ld a,(hl)		; out bit mask to energise keyboard row  
7512			;	call rowscan  
7512			;	inc hl  
7512			;	dec b  
7512			;	jr nz, rowloop  
7512			;  
7512			;	ret  
7512			;  
7512			;  
7512			;; pass a out bitmask, b row number  
7512			;arowscan:   
7512			;	push bc  
7512			;  
7512			;	ld d, b  
7512			;  
7512			;	; calculate buffer location for this row  
7512			;  
7512			;	ld hl, keyscan_table	  
7512			;kbufr:  ld e, key_cols  
7512			;kbufc:	inc hl  
7512			;	dec e  
7512			;	jr nz, kbufc  
7512			;	dec d  
7512			;	jr nz, kbufr  
7512			;  
7512			;	; energise row and read columns  
7512			;  
7512			;	out (portbdata),a  
7512			;	in a,(portbdata)  
7512			;	ld c,a  
7512			;  
7512			;  
7512			;	; save buffer loc  
7512			;  
7512			;	ld (keybufptr), hl  
7512			;  
7512			;	ld hl, key_scanc  
7512			;	ld d, key_cols  
7512			;  
7512			;	; for each column check each bit mask  
7512			;  
7512			;colloop:  
7512			;	  
7512			;  
7512			;	; reset flags for the row   
7512			;  
7512			;	ld b,'.'  
7512			;	and (hl)  
7512			;	jr z, maskskip  
7512			;	ld b,'#'  
7512			;maskskip:  
7512			;	; save  key state  
7512			;	push hl  
7512			;	ld hl, (keybufptr)  
7512			;	ld (hl), b  
7512			;	inc hl  
7512			;	ld (keybufptr), hl  
7512			;  
7512			;	; move to next bit mask  
7512			;	pop hl  
7512			;	inc hl  
7512			;  
7512			;	dec d  
7512			;	jr nz, colloop  
7512			;  
7512			;	ret  
7512			;  
7512			;  
7512			;;  
7512			; lcd functions  
7512			;  
7512			;  
7512			  
7512			;if DEBUG_KEY_MATRIX  
7512			  
7512			; test function to display hardware view of matrix state  
7512			  
7512			matrix:  
7512			  
7512			  
7512			  
7512			; scan keyboard row 1  
7512 3e 80			ld a, 128  
7514 21 f8 fe			ld hl, keyscan_table_row1  
7517 cd 64 75			call .rowscan  
751a			  
751a 3e 40			ld a, 64  
751c 21 f3 fe			ld hl, keyscan_table_row2  
751f cd 64 75			call .rowscan  
7522			  
7522 3e 20			ld a, 32  
7524 21 ee fe			ld hl, keyscan_table_row3  
7527 cd 64 75			call .rowscan  
752a			  
752a 3e 10			ld a, 16  
752c 21 e9 fe			ld hl, keyscan_table_row4  
752f cd 64 75			call .rowscan  
7532			  
7532			; Display text on first line  
7532 3e 00		            LD   A, kLCD_Line1  
7534 cd 8a 73		            CALL fLCD_Pos       ;Position cursor to location in A  
7537 11 f8 fe		            LD   DE, keyscan_table_row1  
753a			            ;LD   DE, MsgHello  
753a cd 92 73		            CALL fLCD_Str       ;Display string pointed to by DE  
753d			  
753d			; Display text on second line  
753d 3e 40		            LD   A, kLCD_Line2  
753f cd 8a 73		            CALL fLCD_Pos       ;Position cursor to location in A  
7542 11 f3 fe		            LD   DE, keyscan_table_row2  
7545 cd 92 73		            CALL fLCD_Str       ;Display string pointed to by DE  
7548 3e 14		            LD   A, kLCD_Line3  
754a cd 8a 73		            CALL fLCD_Pos       ;Position cursor to location in A  
754d 11 ee fe		            LD   DE, keyscan_table_row3  
7550 cd 92 73		            CALL fLCD_Str       ;Display string pointed to by DE  
7553 3e 54		            LD   A, kLCD_Line4  
7555 cd 8a 73		            CALL fLCD_Pos       ;Position cursor to location in A  
7558 11 e9 fe		            LD   DE, keyscan_table_row4  
755b cd 92 73		            CALL fLCD_Str       ;Display string pointed to by DE  
755e			  
755e cd 86 0c			call delay250ms  
7561 c3 12 75			jp matrix  
7564			  
7564			; pass de as row display flags  
7564			.rowscan:   
7564 d3 c1			out (portbdata),a  
7566 db c1			in a,(portbdata)  
7568 4f				ld c,a  
7569				; reset flags for the row   
7569 06 2e			ld b,'.'  
756b e6 01			and 1  
756d 28 02			jr z, .p1on  
756f 06 23			ld b,'#'  
7571			.p1on:  
7571 70				ld (hl), b  
7572 23				inc hl  
7573			  
7573 06 2e			ld b,'.'  
7575 79				ld a,c  
7576 e6 02			and 2  
7578			;	bit 0,a  
7578 28 02			jr z, .p2on  
757a 06 23			ld b,'#'  
757c			.p2on:  
757c 70				ld (hl), b  
757d 23				inc hl  
757e			;  
757e 06 2e			ld b,'.'  
7580 79				ld a,c  
7581 e6 04			and 4  
7583			;;	bit 0,a  
7583 28 02			jr z, .p3on  
7585 06 23			ld b,'#'  
7587			.p3on:  
7587 70				ld (hl), b  
7588 23				inc hl  
7589			;;  
7589 06 2e			ld b,'.'  
758b			;;	bit 0,a  
758b 79				ld a,c  
758c e6 08			and 8  
758e 28 02			jr z, .p4on  
7590 06 23			ld b,'#'  
7592			.p4on:  
7592 70				ld (hl), b  
7593 23				inc hl  
7594			  
7594			; zero term  
7594 06 00			ld b,0  
7596 70				ld (hl), b  
7597			  
7597 c9			.rscandone: ret  
7598			  
7598			  
7598			  
7598			;endif  
7598			  
7598			  
7598			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
7598
