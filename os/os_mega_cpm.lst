# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 fe 15			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_AUTOFILE: equ $21  
0103			STORE_0_BANKRUN: equ $23  
0103			STORE_0_FILERUN: equ $24  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $20  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diags   
0103			  
0103			hardware_diag: equ key_face_held - 1  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_diag - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103 3e 00				ld a, 0  
0105 32 80 ee				ld (hardware_diag), a  
0108			  
0108					; clear all the buffers  
0108			  
0108 21 1f ed				ld hl, display_fb1  
010b 22 db eb				ld (display_fb_active), hl  
010e			  
010e cd 88 09				call clear_display  
0111			  
0111 21 dd eb				ld hl, display_fb2  
0114 22 db eb				ld (display_fb_active), hl  
0117			  
0117 cd 88 09				call clear_display  
011a			  
011a					; init primary frame buffer area  
011a 21 c0 ed				ld hl, display_fb0  
011d 22 db eb				ld (display_fb_active), hl  
0120			  
0120 cd 88 09				call clear_display  
0123			  
0123			  
0123 cd 82 57				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0126			  
0126 cd 70 58			call key_init  
0129 cd b0 01			call storage_init  
012c			  
012c				; setup malloc functions  
012c			  
012c				if MALLOC_1  
012c cd 58 10				call  heap_init  
012f				endif  
012f				if MALLOC_4  
012f					call  heap_init  
012f				endif  
012f			  
012f				; init sound hardware if present  
012f			  
012f				if SOUND_ENABLE  
012f					call sound_init  
012f				endif  
012f			  
012f				; lcd test sequence  
012f					  
012f cd ab 09			call update_display  
0132 cd fd 08			call delay1s  
0135 3e 2b			ld a,'+'  
0137 cd 8d 09			call fill_display  
013a cd ab 09			call update_display  
013d cd fd 08			call delay1s  
0140 3e 2a			ld a,'*'  
0142 cd 8d 09			call fill_display  
0145 cd ab 09			call update_display  
0148 cd fd 08			call delay1s  
014b 3e 2d			ld a,'-'  
014d cd 8d 09			call fill_display  
0150 cd ab 09			call update_display  
0153 cd fd 08			call delay1s  
0156			  
0156			; boot splash screen  
0156			if display_cols == 20	  
0156			        ld a, display_row_1    
0156			else  
0156 3e 0a		        ld a, display_row_1 +10   
0158			endif  
0158 11 89 01			ld de, bootmsg  
015b cd 9b 09			call str_at_display  
015e cd ab 09			call update_display  
0161			  
0161			  
0161 cd fd 08			call delay1s  
0164 cd fd 08			call delay1s  
0167			if display_cols == 20	  
0167			            LD   A, display_row_3+2  
0167			else  
0167 3e 5c		            LD   A, display_row_3+12  
0169			endif  
0169 11 9e 01			ld de, bootmsg1  
016c cd 9b 09			call str_at_display  
016f cd ab 09			call update_display  
0172 cd fd 08			call delay1s  
0175 cd fd 08			call delay1s  
0178			  
0178			;	ld a, display_row_4+3  
0178			;	ld de, bootmsg2  
0178			;	call str_at_display  
0178			;	call update_display  
0178			;	call delay1s  
0178			;	call delay1s  
0178			  
0178			; debug mark setup  
0178			  
0178 3e 5f		ld a, '_'  
017a 32 7a ee		ld (debug_mark),a  
017d 32 7b ee		ld (debug_mark+1),a  
0180 32 7c ee		ld (debug_mark+2),a  
0183 3e 00		ld a,0  
0185 32 7d ee		ld (debug_mark+3),a  
0188			  
0188 c9					ret  
0189			  
0189			  
0189 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
019e .. 00		bootmsg1:	db "by Kevin Groves",0  
01ae			;bootmsg2:	db "Firmware v0.1",0  
01ae			  
01ae			; a 4x20 lcd  
01ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ae			  
01ae			;if display_cols == 20  
01ae			;	include "firmware_lcd_4x20.asm"  
01ae			;endif  
01ae			  
01ae			;if display_cols == 40  
01ae			;	include "firmware_lcd_4x40.asm"  
01ae			;endif  
01ae			  
01ae			;  
01ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ae			; TODO abstract the bit bang video out interface for dual display  
01ae			; TODO wire video out to tx pin on rc2014 bus  
01ae			  
01ae			; must supply cin, and cin_wait for low level hardware abstraction   
01ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ae			; test scancode  
01ae			  
01ae			;;;;;  
01ae			;;;  
01ae			; Moved out to mini and maxi versions  
01ae			;  
01ae			; include "firmware_key_4x4.asm"  
01ae			; using existing 4 wire x 4 resistor array for input  
01ae			;include "firmware_key_4x10.asm"  
01ae			; need to mod the board for 5 rows due to resistor array  
01ae			;include "firmware_key_5x10.asm"  
01ae			  
01ae			; storage hardware interface  
01ae			  
01ae			; use microchip serial eeprom for storage  
01ae			  
01ae			  
01ae			if STORAGE_SE  
01ae				include "firmware_spi.asm"  
01ae				include "firmware_seeprom.asm"  
01ae			else  
01ae			   ; create some stubs for the labels  
01ae c9			se_readbyte: ret  
01af c9			se_writebyte: ret  
01b0 c9			storage_init: ret  
01b1			  
01b1			endif  
01b1			  
01b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01b1			;include "firmware_cf.asm"  
01b1			  
01b1			; load up high level storage hardward abstractions  
01b1			include "firmware_storage.asm"  
01b1			 
01b1			; persisent storage hardware abstraction layer  
01b1			 
01b1			 
01b1			 
01b1			; Block 0 on storage is a config state 
01b1			 
01b1			 
01b1			 
01b1			; TODO add read phy block and write phy block functions 
01b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01b1			 
01b1			; Abstraction layer  
01b1			 
01b1			; Logocial block size is same size as physical size - using tape concept 
01b1			 
01b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01b1			 
01b1			 
01b1			 
01b1			; Filesystem layout (Logical layout) 
01b1			; 
01b1			; Block 0 - Bank config  
01b1			; 
01b1			;      Byte - 0 file id counter 
01b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01b1			;      Byte - 3-20 zero terminated bank label 
01b1			; 
01b1			; Block 1 > File storage 
01b1			; 
01b1			;      Byte 0 file id    - block 0 file details 
01b1			;      Byte 1 block id - block 0 is file  
01b1			;            Byte 2-15 - File name 
01b1			; 
01b1			;       - to end of block data 
01b1			; 
01b1			 
01b1			 
01b1			; Read Block 
01b1			; ---------- 
01b1			; 
01b1			; With current bank 
01b1			;  
01b1			; Get block number to read 
01b1			; Load physical blocks starting at start block into buffer 
01b1			 
01b1			; de points to buffer to use 
01b1			; hl holds logical block number  
01b1			 
01b1			storage_read_block: 
01b1			 
01b1				; TODO bank selection 
01b1			 
01b1				; for each of the physical blocks read it into the buffer 
01b1 06 40			ld b, STORE_BLOCK_PHY 
01b3			 
01b3				if DEBUG_STORESE 
01b3 d5					push de 
01b4				endif 
01b4				 
01b4			.rl1:    
01b4			 
01b4				; read physical block at hl into de 
01b4			        ; increment hl and de to next read position on exit 
01b4			 
01b4 e5				push hl 
01b5 d5				push de	 
01b6 c5				push bc 
01b7			;	if DEBUG_STORESE 
01b7			;		push af 
01b7			;		ld a, 'R' 
01b7			;		ld (debug_mark),a 
01b7			;		pop af 
01b7			;		CALLMONITOR 
01b7			;	endif 
01b7 cd ae 01			call se_readbyte 
01ba			;	if DEBUG_STORESE 
01ba			;		ld a,(spi_portbyte) 
01ba			;		ld l, a 
01ba			;		push af 
01ba			;		ld a, '1' 
01ba			;		ld (debug_mark),a 
01ba			;		pop af 
01ba			;		CALLMONITOR 
01ba			;	endif 
01ba c1				pop bc 
01bb d1				pop de 
01bc e1				pop hl 
01bd 12				ld (de),a 
01be 23				inc hl 
01bf 13				inc de 
01c0			 
01c0			;	if DEBUG_STORESE 
01c0			;		push af 
01c0			;		ld a, 'r' 
01c0			;		ld (debug_mark),a 
01c0			;		pop af 
01c0			;		CALLMONITOR 
01c0			;	endif 
01c0			 
01c0 10 f2			djnz .rl1 
01c2			 
01c2				if DEBUG_STORESE 
01c2					DMARK "SRB" 
01c2 f5				push af  
01c3 3a d7 01			ld a, (.dmark)  
01c6 32 7a ee			ld (debug_mark),a  
01c9 3a d8 01			ld a, (.dmark+1)  
01cc 32 7b ee			ld (debug_mark+1),a  
01cf 3a d9 01			ld a, (.dmark+2)  
01d2 32 7c ee			ld (debug_mark+2),a  
01d5 18 03			jr .pastdmark  
01d7 ..			.dmark: db "SRB"  
01da f1			.pastdmark: pop af  
01db			endm  
# End of macro DMARK
01db d1					pop de 
01dc			; 
01dc			;		push af 
01dc			;		ld a, 'R' 
01dc			;		ld (debug_mark),a 
01dc			;		pop af 
01dc					CALLMONITOR 
01dc cd 28 14			call break_point_state  
01df				endm  
# End of macro CALLMONITOR
01df				endif 
01df c9				ret	 
01e0				 
01e0			 
01e0			; File Size 
01e0			; --------- 
01e0			; 
01e0			;   hl file id 
01e0			; 
01e0			;  returns in hl the number of blocks 
01e0			 
01e0			storage_file_size: 
01e0 5d				ld e, l 
01e1 16 00			ld d, 0 
01e3 21 40 00			ld hl, STORE_BLOCK_PHY 
01e6					if DEBUG_FORTH_WORDS 
01e6						DMARK "SIZ" 
01e6 f5				push af  
01e7 3a fb 01			ld a, (.dmark)  
01ea 32 7a ee			ld (debug_mark),a  
01ed 3a fc 01			ld a, (.dmark+1)  
01f0 32 7b ee			ld (debug_mark+1),a  
01f3 3a fd 01			ld a, (.dmark+2)  
01f6 32 7c ee			ld (debug_mark+2),a  
01f9 18 03			jr .pastdmark  
01fb ..			.dmark: db "SIZ"  
01fe f1			.pastdmark: pop af  
01ff			endm  
# End of macro DMARK
01ff						CALLMONITOR 
01ff cd 28 14			call break_point_state  
0202				endm  
# End of macro CALLMONITOR
0202					endif 
0202 cd d2 04			call storage_findnextid 
0205			 
0205 cd de 0b			call ishlzero 
0208			;	ld a, l 
0208			;	add h 
0208			;	cp 0 
0208 c8				ret z			; block not found so EOF 
0209			 
0209 11 65 eb			ld de, store_page 
020c cd b1 01			call storage_read_block 
020f			 
020f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
0212 6f				ld l, a 
0213 26 00			ld h, 0 
0215 c9			 	ret 
0216			 
0216			 
0216			; Write Block 
0216			; ----------- 
0216			; 
0216			; With current bank 
0216			;  
0216			; Get block number to write 
0216			; Write physical blocks starting at start block from buffer 
0216			  
0216			storage_write_block: 
0216				; TODO bank selection 
0216			 
0216				; for each of the physical blocks read it into the buffer 
0216 06 40			ld b, STORE_BLOCK_PHY 
0218			 
0218				if DEBUG_STORESE 
0218					DMARK "SWB" 
0218 f5				push af  
0219 3a 2d 02			ld a, (.dmark)  
021c 32 7a ee			ld (debug_mark),a  
021f 3a 2e 02			ld a, (.dmark+1)  
0222 32 7b ee			ld (debug_mark+1),a  
0225 3a 2f 02			ld a, (.dmark+2)  
0228 32 7c ee			ld (debug_mark+2),a  
022b 18 03			jr .pastdmark  
022d ..			.dmark: db "SWB"  
0230 f1			.pastdmark: pop af  
0231			endm  
# End of macro DMARK
0231			 
0231					;push af 
0231					;ld a, 'W' 
0231					;ld (debug_mark),a 
0231					;pop af 
0231					CALLMONITOR 
0231 cd 28 14			call break_point_state  
0234				endm  
# End of macro CALLMONITOR
0234				endif 
0234			 
0234			; might not be working 
0234			;	call se_writepage 
0234			 
0234			;	ret 
0234			; 
0234			 
0234			 
0234			 
0234			.wl1:    
0234			 
0234				; read physical block at hl into de 
0234			        ; increment hl and de to next read position on exit 
0234			 
0234 e5				push hl 
0235 d5				push de	 
0236 c5				push bc 
0237 1a				ld a,(de) 
0238				;if DEBUG_STORESE 
0238			;		push af 
0238			;		ld a, 'W' 
0238			;		ld (debug_mark),a 
0238			;		pop af 
0238			;		CALLMONITOR 
0238			;	endif 
0238 cd af 01			call se_writebyte 
023b			;	call delay250ms 
023b 00				nop 
023c 00				nop 
023d 00				nop 
023e			;	if DEBUG_STORESE 
023e			;		push af 
023e			;		ld a, 'w' 
023e			;		ld (debug_mark),a 
023e			;		pop af 
023e			;		CALLMONITOR 
023e			;	endif 
023e c1				pop bc 
023f d1				pop de 
0240 e1				pop hl 
0241 23				inc hl 
0242 13				inc de 
0243			 
0243			 
0243 10 ef			djnz .wl1 
0245			 
0245				if DEBUG_STORESE 
0245					DMARK "SW2" 
0245 f5				push af  
0246 3a 5a 02			ld a, (.dmark)  
0249 32 7a ee			ld (debug_mark),a  
024c 3a 5b 02			ld a, (.dmark+1)  
024f 32 7b ee			ld (debug_mark+1),a  
0252 3a 5c 02			ld a, (.dmark+2)  
0255 32 7c ee			ld (debug_mark+2),a  
0258 18 03			jr .pastdmark  
025a ..			.dmark: db "SW2"  
025d f1			.pastdmark: pop af  
025e			endm  
# End of macro DMARK
025e			 
025e					;push af 
025e					;ld a, 'W' 
025e					;ld (debug_mark),a 
025e					;pop af 
025e					CALLMONITOR 
025e cd 28 14			call break_point_state  
0261				endm  
# End of macro CALLMONITOR
0261				endif 
0261 c9				ret	 
0262			 
0262			; Init bank 
0262			; --------- 
0262			; 
0262			; With current bank 
0262			; 
0262			; Setup block 0 config 
0262			;     Set 0 file id counter 
0262			;     Set formatted byte pattern 
0262			;     Zero out bank label 
0262			;      
0262			; For every logical block write 0-1 byte as null 
0262			 
0262			storage_get_block_0: 
0262			 
0262				; TODO check presence 
0262			 
0262				; get block 0 config 
0262			 
0262 21 00 00			ld hl, 0 
0265 11 65 eb			ld de, store_page 
0268 cd b1 01			call storage_read_block 
026b			 
026b				if DEBUG_STORESE 
026b					DMARK "SB0" 
026b f5				push af  
026c 3a 80 02			ld a, (.dmark)  
026f 32 7a ee			ld (debug_mark),a  
0272 3a 81 02			ld a, (.dmark+1)  
0275 32 7b ee			ld (debug_mark+1),a  
0278 3a 82 02			ld a, (.dmark+2)  
027b 32 7c ee			ld (debug_mark+2),a  
027e 18 03			jr .pastdmark  
0280 ..			.dmark: db "SB0"  
0283 f1			.pastdmark: pop af  
0284			endm  
# End of macro DMARK
0284 11 65 eb				ld de, store_page 
0287			;		push af 
0287			;		ld a, 'i' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287					CALLMONITOR 
0287 cd 28 14			call break_point_state  
028a				endm  
# End of macro CALLMONITOR
028a				endif 
028a			 
028a				; is this area formatted? 
028a			 
028a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
028a 2a 66 eb			ld hl, (store_page+1) 
028d 3e 80			ld a,0x80 
028f bd				cp l 
0290 20 22			jr nz, .ininotformatted 
0292				; do a double check 
0292 3e 27			ld a, 0x27 
0294 bc				cp h 
0295 20 1d			jr nz, .ininotformatted 
0297			 
0297				; formatted then 
0297			 
0297				if DEBUG_STORESE 
0297					DMARK "SB1" 
0297 f5				push af  
0298 3a ac 02			ld a, (.dmark)  
029b 32 7a ee			ld (debug_mark),a  
029e 3a ad 02			ld a, (.dmark+1)  
02a1 32 7b ee			ld (debug_mark+1),a  
02a4 3a ae 02			ld a, (.dmark+2)  
02a7 32 7c ee			ld (debug_mark+2),a  
02aa 18 03			jr .pastdmark  
02ac ..			.dmark: db "SB1"  
02af f1			.pastdmark: pop af  
02b0			endm  
# End of macro DMARK
02b0					;push af 
02b0					;ld a, 'I' 
02b0					;ld (debug_mark),a 
02b0					;pop af 
02b0					CALLMONITOR 
02b0 cd 28 14			call break_point_state  
02b3				endm  
# End of macro CALLMONITOR
02b3				endif 
02b3 c9				ret 
02b4			 
02b4			.ininotformatted: 
02b4				; bank not formatted so poke various bits to make sure 
02b4			 
02b4				if DEBUG_STORESE 
02b4					DMARK "SB2" 
02b4 f5				push af  
02b5 3a c9 02			ld a, (.dmark)  
02b8 32 7a ee			ld (debug_mark),a  
02bb 3a ca 02			ld a, (.dmark+1)  
02be 32 7b ee			ld (debug_mark+1),a  
02c1 3a cb 02			ld a, (.dmark+2)  
02c4 32 7c ee			ld (debug_mark+2),a  
02c7 18 03			jr .pastdmark  
02c9 ..			.dmark: db "SB2"  
02cc f1			.pastdmark: pop af  
02cd			endm  
# End of macro DMARK
02cd					;push af 
02cd					;ld a, 'f' 
02cd					;ld (debug_mark),a 
02cd					;pop af 
02cd					CALLMONITOR 
02cd cd 28 14			call break_point_state  
02d0				endm  
# End of macro CALLMONITOR
02d0				endif 
02d0			 
02d0 cd c0 08			call storage_clear_page 
02d3			 
02d3 21 65 eb			ld hl, store_page 
02d6 3e 00			ld a, 0 
02d8				 
02d8 77				ld (hl),a   ; reset file counter 
02d9			 
02d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02dc 22 66 eb		 	ld (store_page+1), hl	 
02df			 
02df				; set default label 
02df			 
02df 21 7b 03			ld hl, .defaultbanklabl 
02e2 11 68 eb		 	ld de, store_page+3 
02e5 01 0f 00			ld bc, 15 
02e8 ed b0			ldir 
02ea			 
02ea				; Append the current bank id 
02ea 21 71 eb			ld hl, store_page+3+9 
02ed 3a 4a eb			ld a, (spi_device_id) 
02f0 77				ld (hl), a 
02f1			 
02f1				; save default page 0 
02f1			 
02f1 21 00 00			ld hl, 0 
02f4 11 65 eb			ld de, store_page 
02f7				if DEBUG_STORESE 
02f7					DMARK "SB3" 
02f7 f5				push af  
02f8 3a 0c 03			ld a, (.dmark)  
02fb 32 7a ee			ld (debug_mark),a  
02fe 3a 0d 03			ld a, (.dmark+1)  
0301 32 7b ee			ld (debug_mark+1),a  
0304 3a 0e 03			ld a, (.dmark+2)  
0307 32 7c ee			ld (debug_mark+2),a  
030a 18 03			jr .pastdmark  
030c ..			.dmark: db "SB3"  
030f f1			.pastdmark: pop af  
0310			endm  
# End of macro DMARK
0310			;		push af 
0310			;		ld a, 'F' 
0310			;		ld (debug_mark),a 
0310			;		pop af 
0310					CALLMONITOR 
0310 cd 28 14			call break_point_state  
0313				endm  
# End of macro CALLMONITOR
0313				endif 
0313 cd 16 02			call storage_write_block 
0316				if DEBUG_STORESE 
0316					DMARK "SB4" 
0316 f5				push af  
0317 3a 2b 03			ld a, (.dmark)  
031a 32 7a ee			ld (debug_mark),a  
031d 3a 2c 03			ld a, (.dmark+1)  
0320 32 7b ee			ld (debug_mark+1),a  
0323 3a 2d 03			ld a, (.dmark+2)  
0326 32 7c ee			ld (debug_mark+2),a  
0329 18 03			jr .pastdmark  
032b ..			.dmark: db "SB4"  
032e f1			.pastdmark: pop af  
032f			endm  
# End of macro DMARK
032f			;		push af 
032f			;		ld a, '>' 
032f			;		ld (debug_mark),a 
032f			;		pop af 
032f					CALLMONITOR 
032f cd 28 14			call break_point_state  
0332				endm  
# End of macro CALLMONITOR
0332				endif 
0332			 
0332 00				nop 
0333 00				nop 
0334 00				nop 
0335			 
0335				; now set 0 in every page to mark as a free block 
0335			 
0335 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0337 21 40 00			ld hl, STORE_BLOCK_PHY 
033a			 
033a 3e 00		.setmark1:   	ld a,0 
033c e5					push hl 
033d c5					push bc 
033e cd af 01				call se_writebyte 
0341 3e 0a			ld a, 10 
0343 cd e2 08			call aDelayInMS 
0346 23				inc hl 
0347 cd af 01				call se_writebyte 
034a 3e 0a			ld a, 10 
034c cd e2 08			call aDelayInMS 
034f 2b				dec hl 
0350 c1					pop bc 
0351 e1					pop hl 
0352 3e 40				ld a, STORE_BLOCK_PHY 
0354 cd b5 0b				call addatohl 
0357 10 e1				djnz .setmark1 
0359			 
0359 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
035b 3e 00		.setmark2:   	ld a,0 
035d e5					push hl 
035e c5					push bc 
035f cd af 01				call se_writebyte 
0362 3e 0a			ld a, 10 
0364 cd e2 08			call aDelayInMS 
0367 23				inc hl 
0368 cd af 01				call se_writebyte 
036b 3e 0a			ld a, 10 
036d cd e2 08			call aDelayInMS 
0370 2b				dec hl 
0371 c1					pop bc 
0372 e1					pop hl 
0373 3e 40				ld a, STORE_BLOCK_PHY 
0375 cd b5 0b				call addatohl 
0378 10 e1				djnz .setmark2 
037a			 
037a					 
037a			 
037a			 
037a c9				ret 
037b			 
037b			 
037b			 
037b			 
037b .. 00		.defaultbanklabl:   db "BankLabel_",0 
0386			 
0386			 
0386			 
0386			; Label Bank 
0386			; ---------- 
0386			; 
0386			; With current bank 
0386			; Read block 0 
0386			; Set label 
0386			; Write block 0 
0386			 
0386			; label str pointer in hl 
0386			 
0386			storage_label:     
0386			 
0386				if DEBUG_STORESE 
0386					DMARK "LBL" 
0386 f5				push af  
0387 3a 9b 03			ld a, (.dmark)  
038a 32 7a ee			ld (debug_mark),a  
038d 3a 9c 03			ld a, (.dmark+1)  
0390 32 7b ee			ld (debug_mark+1),a  
0393 3a 9d 03			ld a, (.dmark+2)  
0396 32 7c ee			ld (debug_mark+2),a  
0399 18 03			jr .pastdmark  
039b ..			.dmark: db "LBL"  
039e f1			.pastdmark: pop af  
039f			endm  
# End of macro DMARK
039f					CALLMONITOR 
039f cd 28 14			call break_point_state  
03a2				endm  
# End of macro CALLMONITOR
03a2				endif 
03a2			 
03a2 e5				push hl 
03a3			 
03a3 cd 62 02			call storage_get_block_0 
03a6			 
03a6				; set default label 
03a6			 
03a6 e1				pop hl 
03a7			 
03a7 11 68 eb		 	ld de, store_page+3 
03aa 01 0f 00			ld bc, 15 
03ad				if DEBUG_STORESE 
03ad					DMARK "LB3" 
03ad f5				push af  
03ae 3a c2 03			ld a, (.dmark)  
03b1 32 7a ee			ld (debug_mark),a  
03b4 3a c3 03			ld a, (.dmark+1)  
03b7 32 7b ee			ld (debug_mark+1),a  
03ba 3a c4 03			ld a, (.dmark+2)  
03bd 32 7c ee			ld (debug_mark+2),a  
03c0 18 03			jr .pastdmark  
03c2 ..			.dmark: db "LB3"  
03c5 f1			.pastdmark: pop af  
03c6			endm  
# End of macro DMARK
03c6					CALLMONITOR 
03c6 cd 28 14			call break_point_state  
03c9				endm  
# End of macro CALLMONITOR
03c9				endif 
03c9 ed b0			ldir 
03cb				; save default page 0 
03cb			 
03cb 21 00 00			ld hl, 0 
03ce 11 65 eb			ld de, store_page 
03d1				if DEBUG_STORESE 
03d1					DMARK "LBW" 
03d1 f5				push af  
03d2 3a e6 03			ld a, (.dmark)  
03d5 32 7a ee			ld (debug_mark),a  
03d8 3a e7 03			ld a, (.dmark+1)  
03db 32 7b ee			ld (debug_mark+1),a  
03de 3a e8 03			ld a, (.dmark+2)  
03e1 32 7c ee			ld (debug_mark+2),a  
03e4 18 03			jr .pastdmark  
03e6 ..			.dmark: db "LBW"  
03e9 f1			.pastdmark: pop af  
03ea			endm  
# End of macro DMARK
03ea					CALLMONITOR 
03ea cd 28 14			call break_point_state  
03ed				endm  
# End of macro CALLMONITOR
03ed				endif 
03ed cd 16 02			call storage_write_block 
03f0			 
03f0 c9				ret 
03f1			 
03f1			 
03f1			 
03f1			; Read Block 0 - Config 
03f1			; --------------------- 
03f1			; 
03f1			; With current bank 
03f1			; Call presence test 
03f1			;    If not present format/init bank  
03f1			; Read block 0  
03f1			;  
03f1			 
03f1			 
03f1			; Dir 
03f1			; --- 
03f1			; 
03f1			; With current bank 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block read byte 2 
03f1			;      if first block of file 
03f1			;         Display file name 
03f1			;         Display type flags for file 
03f1			;        
03f1			 
03f1			; moving to words as this requires stack control 
03f1			 
03f1			 
03f1			; Delete File 
03f1			; ----------- 
03f1			; 
03f1			; With current bank 
03f1			; 
03f1			; Load Block 0 Config 
03f1			; Get max file id number 
03f1			; For each logical block 
03f1			;    Read block file id 
03f1			;      If first block of file and dont have file id 
03f1			;         if file to delete 
03f1			;         Save file id 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			;      If file id is one saved 
03f1			;         Null file id 
03f1			;         Write this block back 
03f1			 
03f1			storage_erase: 
03f1			 
03f1				; hl contains the file id 
03f1			 
03f1 5d				ld e, l 
03f2 16 00			ld d, 0 
03f4 21 40 00			ld hl, STORE_BLOCK_PHY 
03f7					if DEBUG_FORTH_WORDS 
03f7						DMARK "ERA" 
03f7 f5				push af  
03f8 3a 0c 04			ld a, (.dmark)  
03fb 32 7a ee			ld (debug_mark),a  
03fe 3a 0d 04			ld a, (.dmark+1)  
0401 32 7b ee			ld (debug_mark+1),a  
0404 3a 0e 04			ld a, (.dmark+2)  
0407 32 7c ee			ld (debug_mark+2),a  
040a 18 03			jr .pastdmark  
040c ..			.dmark: db "ERA"  
040f f1			.pastdmark: pop af  
0410			endm  
# End of macro DMARK
0410						CALLMONITOR 
0410 cd 28 14			call break_point_state  
0413				endm  
# End of macro CALLMONITOR
0413					endif 
0413 cd d2 04			call storage_findnextid 
0416			 
0416 e5				push hl 
0417			 
0417				; TODO check file not found 
0417			 
0417 11 65 eb			ld de, store_page 
041a cd b1 01			call storage_read_block 
041d			 
041d					if DEBUG_FORTH_WORDS 
041d						DMARK "ER1" 
041d f5				push af  
041e 3a 32 04			ld a, (.dmark)  
0421 32 7a ee			ld (debug_mark),a  
0424 3a 33 04			ld a, (.dmark+1)  
0427 32 7b ee			ld (debug_mark+1),a  
042a 3a 34 04			ld a, (.dmark+2)  
042d 32 7c ee			ld (debug_mark+2),a  
0430 18 03			jr .pastdmark  
0432 ..			.dmark: db "ER1"  
0435 f1			.pastdmark: pop af  
0436			endm  
# End of macro DMARK
0436						CALLMONITOR 
0436 cd 28 14			call break_point_state  
0439				endm  
# End of macro CALLMONITOR
0439					endif 
0439 3a 65 eb			ld a, (store_page)	; get file id 
043c 32 5e eb			ld (store_tmpid), a 
043f			 
043f 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
0442 32 5d eb			ld (store_tmpext), a 
0445			 
0445				; wipe file header 
0445			 
0445 e1				pop hl 
0446 3e 00			ld a, 0 
0448 32 65 eb			ld (store_page), a 
044b 32 66 eb			ld (store_page+1),a 
044e 11 65 eb			ld de, store_page 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "ER2" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 7a ee			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 7b ee			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 7c ee			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "ER2"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd 28 14			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 16 02			call storage_write_block 
0470			 
0470			 
0470				; wipe file extents 
0470			 
0470 3a 5d eb			ld a, (store_tmpext) 
0473 47				ld b, a 
0474			 
0474			.eraext:	  
0474 c5				push bc 
0475			 
0475 21 40 00			ld hl, STORE_BLOCK_PHY 
0478 3a 5e eb			ld a,(store_tmpid) 
047b 5f				ld e, a 
047c 50				ld d, b	 
047d					if DEBUG_FORTH_WORDS 
047d						DMARK "ER3" 
047d f5				push af  
047e 3a 92 04			ld a, (.dmark)  
0481 32 7a ee			ld (debug_mark),a  
0484 3a 93 04			ld a, (.dmark+1)  
0487 32 7b ee			ld (debug_mark+1),a  
048a 3a 94 04			ld a, (.dmark+2)  
048d 32 7c ee			ld (debug_mark+2),a  
0490 18 03			jr .pastdmark  
0492 ..			.dmark: db "ER3"  
0495 f1			.pastdmark: pop af  
0496			endm  
# End of macro DMARK
0496						CALLMONITOR 
0496 cd 28 14			call break_point_state  
0499				endm  
# End of macro CALLMONITOR
0499					endif 
0499 cd d2 04			call storage_findnextid 
049c			 
049c e5				push hl 
049d 11 65 eb			ld de, store_page 
04a0 cd b1 01			call storage_read_block 
04a3			 
04a3				; free block	 
04a3			 
04a3 3e 00			ld a, 0 
04a5 32 65 eb			ld (store_page), a 
04a8 32 66 eb			ld (store_page+1),a 
04ab 11 65 eb			ld de, store_page 
04ae e1				pop hl 
04af					if DEBUG_FORTH_WORDS 
04af						DMARK "ER4" 
04af f5				push af  
04b0 3a c4 04			ld a, (.dmark)  
04b3 32 7a ee			ld (debug_mark),a  
04b6 3a c5 04			ld a, (.dmark+1)  
04b9 32 7b ee			ld (debug_mark+1),a  
04bc 3a c6 04			ld a, (.dmark+2)  
04bf 32 7c ee			ld (debug_mark+2),a  
04c2 18 03			jr .pastdmark  
04c4 ..			.dmark: db "ER4"  
04c7 f1			.pastdmark: pop af  
04c8			endm  
# End of macro DMARK
04c8						CALLMONITOR 
04c8 cd 28 14			call break_point_state  
04cb				endm  
# End of macro CALLMONITOR
04cb					endif 
04cb cd 16 02			call storage_write_block 
04ce			 
04ce c1				pop bc 
04cf 10 a3			djnz .eraext 
04d1			 
04d1 c9				ret 
04d2			 
04d2			 
04d2			; Find Free Block 
04d2			; --------------- 
04d2			; 
04d2			; With current bank 
04d2			;  
04d2			; From given starting logical block 
04d2			;    Read block  
04d2			;    If no file id 
04d2			;         Return block id 
04d2			 
04d2			 
04d2			; hl starting page number 
04d2			; hl contains free page number or zero if no pages free 
04d2			; e contains the file id to locate 
04d2			; d contains the block number 
04d2			 
04d2			; TODO change to find file id and use zero for free block 
04d2			 
04d2			storage_findnextid: 
04d2			 
04d2				; now locate first 0 page to mark as a free block 
04d2			 
04d2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04d4			;	ld hl, STORE_BLOCK_PHY 
04d4			 
04d4					if DEBUG_FORTH_WORDS 
04d4					DMARK "FNI" 
04d4 f5				push af  
04d5 3a e9 04			ld a, (.dmark)  
04d8 32 7a ee			ld (debug_mark),a  
04db 3a ea 04			ld a, (.dmark+1)  
04de 32 7b ee			ld (debug_mark+1),a  
04e1 3a eb 04			ld a, (.dmark+2)  
04e4 32 7c ee			ld (debug_mark+2),a  
04e7 18 03			jr .pastdmark  
04e9 ..			.dmark: db "FNI"  
04ec f1			.pastdmark: pop af  
04ed			endm  
# End of macro DMARK
04ed						CALLMONITOR 
04ed cd 28 14			call break_point_state  
04f0				endm  
# End of macro CALLMONITOR
04f0					endif 
04f0			.ff1:   	 
04f0 e5					push hl 
04f1 c5					push bc 
04f2 d5					push de 
04f3 cd ae 01				call se_readbyte 
04f6 5f					ld e,a 
04f7 23					inc hl 
04f8 cd ae 01				call se_readbyte 
04fb 57					ld d, a 
04fc e1					pop hl 
04fd e5					push hl 
04fe cd d3 0b				call cmp16 
0501 28 49				jr z, .fffound 
0503			 
0503 d1					pop de 
0504 c1					pop bc 
0505 e1					pop hl 
0506			 
0506					; is found? 
0506					;cp e 
0506					;ret z 
0506			 
0506 3e 40				ld a, STORE_BLOCK_PHY 
0508 cd b5 0b				call addatohl 
050b 10 e3				djnz .ff1 
050d			 
050d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
050f			.ff2:   	 
050f			 
050f e5					push hl 
0510 c5					push bc 
0511 d5					push de 
0512 cd ae 01				call se_readbyte 
0515 5f					ld e,a 
0516 23					inc hl 
0517 cd ae 01				call se_readbyte 
051a 57					ld d, a 
051b			 
051b e1					pop hl 
051c e5					push hl 
051d cd d3 0b				call cmp16 
0520 28 2a				jr z, .fffound 
0522			 
0522 d1					pop de 
0523 c1					pop bc 
0524 e1					pop hl 
0525					; is found? 
0525					;cp e 
0525					;ret z 
0525			 
0525 3e 40				ld a, STORE_BLOCK_PHY 
0527 cd b5 0b				call addatohl 
052a 10 e3				djnz .ff2 
052c			 
052c			 
052c					if DEBUG_FORTH_WORDS 
052c					DMARK "FN-" 
052c f5				push af  
052d 3a 41 05			ld a, (.dmark)  
0530 32 7a ee			ld (debug_mark),a  
0533 3a 42 05			ld a, (.dmark+1)  
0536 32 7b ee			ld (debug_mark+1),a  
0539 3a 43 05			ld a, (.dmark+2)  
053c 32 7c ee			ld (debug_mark+2),a  
053f 18 03			jr .pastdmark  
0541 ..			.dmark: db "FN-"  
0544 f1			.pastdmark: pop af  
0545			endm  
# End of macro DMARK
0545					;	push af 
0545					;	ld a, 'n' 
0545					;	ld (debug_mark),a 
0545					;	pop af 
0545						CALLMONITOR 
0545 cd 28 14			call break_point_state  
0548				endm  
# End of macro CALLMONITOR
0548					endif 
0548				; no free marks! 
0548 21 00 00				ld hl, 0 
054b c9				ret 
054c			.fffound: 
054c				 
054c			 
054c d1					pop de 
054d c1					pop bc 
054e e1					pop hl 
054f					if DEBUG_FORTH_WORDS 
054f					DMARK "FNF" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 7a ee			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 7b ee			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 7c ee			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "FNF"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568					;	push af 
0568					;	ld a, 'n' 
0568					;	ld (debug_mark),a 
0568					;	pop af 
0568						CALLMONITOR 
0568 cd 28 14			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b c9				ret 
056c			 
056c			 
056c			 
056c			; Free Space 
056c			; ---------- 
056c			; 
056c			; With current bank 
056c			; 
056c			; Set block count to zero 
056c			; Starting with first logical block 
056c			;      Find free block  
056c			;      If block id given, increment block count 
056c			; 
056c			;  
056c			 
056c			 
056c			; hl contains count of free blocks 
056c			 
056c			storage_freeblocks: 
056c			 
056c				; now locate first 0 page to mark as a free block 
056c			 
056c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
056e 21 40 00			ld hl, STORE_BLOCK_PHY 
0571 11 00 00			ld de, 0 
0574			 
0574			.fb1:   	 
0574 e5					push hl 
0575 c5					push bc 
0576 d5					push de 
0577 cd ae 01				call se_readbyte 
057a d1					pop de 
057b c1					pop bc 
057c e1					pop hl 
057d			 
057d					; is free? 
057d fe 00				cp 0 
057f 20 01				jr nz, .ff1cont 
0581 13					inc de 
0582			 
0582			.ff1cont: 
0582			 
0582			 
0582 3e 40				ld a, STORE_BLOCK_PHY 
0584 cd b5 0b				call addatohl 
0587 10 eb				djnz .fb1 
0589			 
0589 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
058b			.fb2:   	 
058b e5					push hl 
058c c5					push bc 
058d d5					push de 
058e cd ae 01				call se_readbyte 
0591 d1					pop de 
0592 c1					pop bc 
0593 e1					pop hl 
0594			 
0594					; is free? 
0594 fe 00				cp 0 
0596 20 01				jr nz, .ff2cont 
0598 13					inc de 
0599			 
0599			.ff2cont: 
0599			 
0599 3e 40				ld a, STORE_BLOCK_PHY 
059b cd b5 0b				call addatohl 
059e 10 eb				djnz .fb2 
05a0			 
05a0 eb				ex de, hl 
05a1 c9				ret 
05a2			 
05a2			; Get File ID 
05a2			; ----------- 
05a2			; 
05a2			; With current bank 
05a2			;  
05a2			; Load Block 0 Config 
05a2			; Get max file id number 
05a2			; For each logical block 
05a2			;    Read block file id 
05a2			;      If first block of file and dont have file id 
05a2			;         if file get id and exit 
05a2			 
05a2			 
05a2			 
05a2			 
05a2			; Create File 
05a2			; ----------- 
05a2			; 
05a2			; With current bank  
05a2			; Load Block 0 Config 
05a2			; Get max file id number 
05a2			; Increment file id number 
05a2			; Save Config 
05a2			; Find free block 
05a2			; Set buffer with file name and file id 
05a2			; Write buffer to free block  
05a2			 
05a2			 
05a2			; hl point to file name 
05a2			; hl returns file id 
05a2			 
05a2			; file format: 
05a2			; byte 0 - file id 
05a2			; byte 1 - extent number 
05a2			; byte 2-> data 
05a2			 
05a2			; format for extent number 0: 
05a2			; 
05a2			; byte 0 - file id 
05a2			; byte 1 - extent 0 
05a2			; byte 2 - extent count 
05a2			; byte 3 -> file name and meta data 
05a2			 
05a2			 
05a2			storage_create: 
05a2				if DEBUG_STORESE 
05a2					DMARK "SCR" 
05a2 f5				push af  
05a3 3a b7 05			ld a, (.dmark)  
05a6 32 7a ee			ld (debug_mark),a  
05a9 3a b8 05			ld a, (.dmark+1)  
05ac 32 7b ee			ld (debug_mark+1),a  
05af 3a b9 05			ld a, (.dmark+2)  
05b2 32 7c ee			ld (debug_mark+2),a  
05b5 18 03			jr .pastdmark  
05b7 ..			.dmark: db "SCR"  
05ba f1			.pastdmark: pop af  
05bb			endm  
# End of macro DMARK
05bb					CALLMONITOR 
05bb cd 28 14			call break_point_state  
05be				endm  
# End of macro CALLMONITOR
05be				endif 
05be			 
05be e5				push hl		; save file name pointer 
05bf			 
05bf cd 62 02			call storage_get_block_0 
05c2			 
05c2 3a 65 eb			ld a,(store_page)	; get current file id 
05c5 3c				inc a 
05c6 32 65 eb			ld (store_page),a 
05c9				 
05c9 32 5e eb			ld (store_tmpid),a			; save id 
05cc			 
05cc 21 00 00			ld hl, 0 
05cf 11 65 eb			ld de, store_page 
05d2				if DEBUG_STORESE 
05d2					DMARK "SCw" 
05d2 f5				push af  
05d3 3a e7 05			ld a, (.dmark)  
05d6 32 7a ee			ld (debug_mark),a  
05d9 3a e8 05			ld a, (.dmark+1)  
05dc 32 7b ee			ld (debug_mark+1),a  
05df 3a e9 05			ld a, (.dmark+2)  
05e2 32 7c ee			ld (debug_mark+2),a  
05e5 18 03			jr .pastdmark  
05e7 ..			.dmark: db "SCw"  
05ea f1			.pastdmark: pop af  
05eb			endm  
# End of macro DMARK
05eb					CALLMONITOR 
05eb cd 28 14			call break_point_state  
05ee				endm  
# End of macro CALLMONITOR
05ee				endif 
05ee cd 16 02			call storage_write_block	 ; save update 
05f1			 
05f1				if DEBUG_STORESE 
05f1 11 65 eb				ld de, store_page 
05f4					DMARK "SCC" 
05f4 f5				push af  
05f5 3a 09 06			ld a, (.dmark)  
05f8 32 7a ee			ld (debug_mark),a  
05fb 3a 0a 06			ld a, (.dmark+1)  
05fe 32 7b ee			ld (debug_mark+1),a  
0601 3a 0b 06			ld a, (.dmark+2)  
0604 32 7c ee			ld (debug_mark+2),a  
0607 18 03			jr .pastdmark  
0609 ..			.dmark: db "SCC"  
060c f1			.pastdmark: pop af  
060d			endm  
# End of macro DMARK
060d					CALLMONITOR 
060d cd 28 14			call break_point_state  
0610				endm  
# End of macro CALLMONITOR
0610				endif 
0610				;  
0610				 
0610 21 40 00			ld hl, STORE_BLOCK_PHY 
0613 11 00 00			ld de, 0 
0616 cd d2 04			call storage_findnextid 
0619			 
0619 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
061c			 
061c				; TODO detect 0 = no spare blocks 
061c			 
061c				; hl now contains the free page to use for the file header page 
061c			 
061c				if DEBUG_STORESE 
061c				DMARK "SCF" 
061c f5				push af  
061d 3a 31 06			ld a, (.dmark)  
0620 32 7a ee			ld (debug_mark),a  
0623 3a 32 06			ld a, (.dmark+1)  
0626 32 7b ee			ld (debug_mark+1),a  
0629 3a 33 06			ld a, (.dmark+2)  
062c 32 7c ee			ld (debug_mark+2),a  
062f 18 03			jr .pastdmark  
0631 ..			.dmark: db "SCF"  
0634 f1			.pastdmark: pop af  
0635			endm  
# End of macro DMARK
0635					CALLMONITOR 
0635 cd 28 14			call break_point_state  
0638				endm  
# End of macro CALLMONITOR
0638				endif 
0638			 
0638 22 4f eb			ld (store_tmppageid), hl 
063b				 
063b 3a 5e eb			ld a,(store_tmpid)    ; get file id 
063e			;	ld a, (store_filecache)			; save to cache 
063e			 
063e 32 65 eb			ld (store_page),a    ; set page id 
0641 3e 00			ld a, 0			 ; extent 0 is file header 
0643 32 66 eb			ld (store_page+1), a   ; set file extent 
0646			 
0646 32 67 eb			ld (store_page+2), a   ; extent count for the file 
0649			 
0649			;	inc hl 		; init block 0 of file 
0649			;	inc hl   		; skip file and extent id 
0649			 ;       ld a, 0 
0649			;	ld (hl),a 
0649			;	ld a, (store_filecache+1)  	; save to cache 
0649			 
0649			;	inc hl    ; file name 
0649				 
0649				 
0649 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
064c				if DEBUG_STORESE 
064c					DMARK "SCc" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 7a ee			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 7b ee			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 7c ee			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "SCc"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665					CALLMONITOR 
0665 cd 28 14			call break_point_state  
0668				endm  
# End of macro CALLMONITOR
0668				endif 
0668 e1				pop hl    ; get zero term string 
0669 e5				push hl 
066a 3e 00			ld a, 0 
066c cd 1e 10			call strlent 
066f 23				inc hl   ; cover zero term 
0670 06 00			ld b,0 
0672 4d				ld c,l 
0673 e1				pop hl 
0674				;ex de, hl 
0674				if DEBUG_STORESE 
0674					DMARK "SCa" 
0674 f5				push af  
0675 3a 89 06			ld a, (.dmark)  
0678 32 7a ee			ld (debug_mark),a  
067b 3a 8a 06			ld a, (.dmark+1)  
067e 32 7b ee			ld (debug_mark+1),a  
0681 3a 8b 06			ld a, (.dmark+2)  
0684 32 7c ee			ld (debug_mark+2),a  
0687 18 03			jr .pastdmark  
0689 ..			.dmark: db "SCa"  
068c f1			.pastdmark: pop af  
068d			endm  
# End of macro DMARK
068d					;push af 
068d					;ld a, 'a' 
068d					;ld (debug_mark),a 
068d					;pop af 
068d					CALLMONITOR 
068d cd 28 14			call break_point_state  
0690				endm  
# End of macro CALLMONITOR
0690				endif 
0690 ed b0			ldir    ; copy zero term string 
0692				if DEBUG_STORESE 
0692					DMARK "SCA" 
0692 f5				push af  
0693 3a a7 06			ld a, (.dmark)  
0696 32 7a ee			ld (debug_mark),a  
0699 3a a8 06			ld a, (.dmark+1)  
069c 32 7b ee			ld (debug_mark+1),a  
069f 3a a9 06			ld a, (.dmark+2)  
06a2 32 7c ee			ld (debug_mark+2),a  
06a5 18 03			jr .pastdmark  
06a7 ..			.dmark: db "SCA"  
06aa f1			.pastdmark: pop af  
06ab			endm  
# End of macro DMARK
06ab					CALLMONITOR 
06ab cd 28 14			call break_point_state  
06ae				endm  
# End of macro CALLMONITOR
06ae				endif 
06ae			 
06ae				; write file header page 
06ae			 
06ae 2a 4f eb			ld hl,(store_tmppageid) 
06b1 11 65 eb			ld de, store_page 
06b4				if DEBUG_STORESE 
06b4					DMARK "SCb" 
06b4 f5				push af  
06b5 3a c9 06			ld a, (.dmark)  
06b8 32 7a ee			ld (debug_mark),a  
06bb 3a ca 06			ld a, (.dmark+1)  
06be 32 7b ee			ld (debug_mark+1),a  
06c1 3a cb 06			ld a, (.dmark+2)  
06c4 32 7c ee			ld (debug_mark+2),a  
06c7 18 03			jr .pastdmark  
06c9 ..			.dmark: db "SCb"  
06cc f1			.pastdmark: pop af  
06cd			endm  
# End of macro DMARK
06cd					;push af 
06cd					;ld a, 'b' 
06cd					;ld (debug_mark),a 
06cd					;pop af 
06cd					CALLMONITOR 
06cd cd 28 14			call break_point_state  
06d0				endm  
# End of macro CALLMONITOR
06d0				endif 
06d0 cd 16 02			call storage_write_block 
06d3			 
06d3 3a 5e eb			ld a, (store_tmpid) 
06d6 6f				ld l, a 
06d7 26 00			ld h,0 
06d9				if DEBUG_STORESE 
06d9					DMARK "SCz" 
06d9 f5				push af  
06da 3a ee 06			ld a, (.dmark)  
06dd 32 7a ee			ld (debug_mark),a  
06e0 3a ef 06			ld a, (.dmark+1)  
06e3 32 7b ee			ld (debug_mark+1),a  
06e6 3a f0 06			ld a, (.dmark+2)  
06e9 32 7c ee			ld (debug_mark+2),a  
06ec 18 03			jr .pastdmark  
06ee ..			.dmark: db "SCz"  
06f1 f1			.pastdmark: pop af  
06f2			endm  
# End of macro DMARK
06f2					CALLMONITOR 
06f2 cd 28 14			call break_point_state  
06f5				endm  
# End of macro CALLMONITOR
06f5				endif 
06f5 c9				ret 
06f6				 
06f6			 
06f6			 
06f6			; 
06f6			; Read File 
06f6			; 
06f6			; h - file id to locate 
06f6			; l - extent to locate 
06f6			; de - pointer to string to read into 
06f6			; 
06f6			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06f6			 
06f6			.sr_fail: 
06f6 d1				pop de 
06f7 c9				ret 
06f8			 
06f8			storage_read: 
06f8 d5				push de 
06f9			 
06f9			; TODO BUG the above push is it popped before the RET Z? 
06f9			 
06f9			; TODO how to handle multiple part blocks 
06f9			 
06f9				; locate file extent to read 
06f9			 
06f9 5c				ld e, h 
06fa 55				ld d, l 
06fb 21 40 00			ld hl, STORE_BLOCK_PHY 
06fe				if DEBUG_STORESE 
06fe					DMARK "SRE" 
06fe f5				push af  
06ff 3a 13 07			ld a, (.dmark)  
0702 32 7a ee			ld (debug_mark),a  
0705 3a 14 07			ld a, (.dmark+1)  
0708 32 7b ee			ld (debug_mark+1),a  
070b 3a 15 07			ld a, (.dmark+2)  
070e 32 7c ee			ld (debug_mark+2),a  
0711 18 03			jr .pastdmark  
0713 ..			.dmark: db "SRE"  
0716 f1			.pastdmark: pop af  
0717			endm  
# End of macro DMARK
0717					CALLMONITOR 
0717 cd 28 14			call break_point_state  
071a				endm  
# End of macro CALLMONITOR
071a				endif 
071a cd d2 04			call storage_findnextid 
071d			 
071d				if DEBUG_STORESE 
071d					DMARK "SRf" 
071d f5				push af  
071e 3a 32 07			ld a, (.dmark)  
0721 32 7a ee			ld (debug_mark),a  
0724 3a 33 07			ld a, (.dmark+1)  
0727 32 7b ee			ld (debug_mark+1),a  
072a 3a 34 07			ld a, (.dmark+2)  
072d 32 7c ee			ld (debug_mark+2),a  
0730 18 03			jr .pastdmark  
0732 ..			.dmark: db "SRf"  
0735 f1			.pastdmark: pop af  
0736			endm  
# End of macro DMARK
0736					CALLMONITOR 
0736 cd 28 14			call break_point_state  
0739				endm  
# End of macro CALLMONITOR
0739				endif 
0739 cd de 0b			call ishlzero 
073c			;	ld a, l 
073c			;	add h 
073c			;	cp 0 
073c 28 b8			jr z,.sr_fail			; block not found so EOF 
073e			 
073e				; hl contains page number to load 
073e d1				pop de   ; get storage 
073f d5				push de 
0740				if DEBUG_STORESE 
0740					DMARK "SRg" 
0740 f5				push af  
0741 3a 55 07			ld a, (.dmark)  
0744 32 7a ee			ld (debug_mark),a  
0747 3a 56 07			ld a, (.dmark+1)  
074a 32 7b ee			ld (debug_mark+1),a  
074d 3a 57 07			ld a, (.dmark+2)  
0750 32 7c ee			ld (debug_mark+2),a  
0753 18 03			jr .pastdmark  
0755 ..			.dmark: db "SRg"  
0758 f1			.pastdmark: pop af  
0759			endm  
# End of macro DMARK
0759					CALLMONITOR 
0759 cd 28 14			call break_point_state  
075c				endm  
# End of macro CALLMONITOR
075c				endif 
075c cd b1 01			call storage_read_block 
075f			 
075f			 
075f			; TODO if block has no zeros then need to read next block  
075f			 
075f			 
075f					 
075f e1				pop hl 		 ; return start of data to show as not EOF 
0760 23				inc hl   ; past file id 
0761 23				inc hl   ; past ext 
0762				if DEBUG_STORESE 
0762					DMARK "SRe" 
0762 f5				push af  
0763 3a 77 07			ld a, (.dmark)  
0766 32 7a ee			ld (debug_mark),a  
0769 3a 78 07			ld a, (.dmark+1)  
076c 32 7b ee			ld (debug_mark+1),a  
076f 3a 79 07			ld a, (.dmark+2)  
0772 32 7c ee			ld (debug_mark+2),a  
0775 18 03			jr .pastdmark  
0777 ..			.dmark: db "SRe"  
077a f1			.pastdmark: pop af  
077b			endm  
# End of macro DMARK
077b					CALLMONITOR 
077b cd 28 14			call break_point_state  
077e				endm  
# End of macro CALLMONITOR
077e				endif 
077e c9					ret 
077f			 
077f			 
077f			 
077f			; 
077f			; Append File 
077f			; 
077f			; hl - file id to locate 
077f			; de - pointer to (multi block) string to write 
077f			 
077f			 
077f			storage_append: 
077f				; hl -  file id to append to 
077f				; de - string to append 
077f			 
077f d5				push de 
0780				 
0780				if DEBUG_STORESE 
0780					DMARK "AP1" 
0780 f5				push af  
0781 3a 95 07			ld a, (.dmark)  
0784 32 7a ee			ld (debug_mark),a  
0787 3a 96 07			ld a, (.dmark+1)  
078a 32 7b ee			ld (debug_mark+1),a  
078d 3a 97 07			ld a, (.dmark+2)  
0790 32 7c ee			ld (debug_mark+2),a  
0793 18 03			jr .pastdmark  
0795 ..			.dmark: db "AP1"  
0798 f1			.pastdmark: pop af  
0799			endm  
# End of macro DMARK
0799					CALLMONITOR 
0799 cd 28 14			call break_point_state  
079c				endm  
# End of macro CALLMONITOR
079c				endif 
079c			 
079c 7d				ld a, l 
079d 32 5e eb			ld (store_tmpid), a 
07a0			 
07a0				; get file header  
07a0			 
07a0 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
07a2 3a 5e eb			ld a, (store_tmpid) 
07a5 5f				ld e, a 
07a6			 
07a6 21 40 00				ld hl, STORE_BLOCK_PHY 
07a9 cd d2 04				call storage_findnextid 
07ac			 
07ac 22 4f eb			ld (store_tmppageid), hl 
07af			 
07af				; TODO handle file id not found 
07af			 
07af				if DEBUG_STORESE 
07af					DMARK "AP2" 
07af f5				push af  
07b0 3a c4 07			ld a, (.dmark)  
07b3 32 7a ee			ld (debug_mark),a  
07b6 3a c5 07			ld a, (.dmark+1)  
07b9 32 7b ee			ld (debug_mark+1),a  
07bc 3a c6 07			ld a, (.dmark+2)  
07bf 32 7c ee			ld (debug_mark+2),a  
07c2 18 03			jr .pastdmark  
07c4 ..			.dmark: db "AP2"  
07c7 f1			.pastdmark: pop af  
07c8			endm  
# End of macro DMARK
07c8					CALLMONITOR 
07c8 cd 28 14			call break_point_state  
07cb				endm  
# End of macro CALLMONITOR
07cb				endif 
07cb			 
07cb				; update file extent count 
07cb			 
07cb 11 65 eb			ld de, store_page 
07ce			 
07ce cd b1 01			call storage_read_block 
07d1			 
07d1				if DEBUG_STORESE 
07d1					DMARK "AP3" 
07d1 f5				push af  
07d2 3a e6 07			ld a, (.dmark)  
07d5 32 7a ee			ld (debug_mark),a  
07d8 3a e7 07			ld a, (.dmark+1)  
07db 32 7b ee			ld (debug_mark+1),a  
07de 3a e8 07			ld a, (.dmark+2)  
07e1 32 7c ee			ld (debug_mark+2),a  
07e4 18 03			jr .pastdmark  
07e6 ..			.dmark: db "AP3"  
07e9 f1			.pastdmark: pop af  
07ea			endm  
# End of macro DMARK
07ea					CALLMONITOR 
07ea cd 28 14			call break_point_state  
07ed				endm  
# End of macro CALLMONITOR
07ed				endif 
07ed			;	ld (store_tmppageid), hl 
07ed			 
07ed 3a 67 eb			ld a, (store_page+2) 
07f0 3c				inc a 
07f1 32 67 eb			ld (store_page+2), a 
07f4 32 5d eb			ld (store_tmpext), a 
07f7				 
07f7				if DEBUG_STORESE 
07f7					DMARK "AP3" 
07f7 f5				push af  
07f8 3a 0c 08			ld a, (.dmark)  
07fb 32 7a ee			ld (debug_mark),a  
07fe 3a 0d 08			ld a, (.dmark+1)  
0801 32 7b ee			ld (debug_mark+1),a  
0804 3a 0e 08			ld a, (.dmark+2)  
0807 32 7c ee			ld (debug_mark+2),a  
080a 18 03			jr .pastdmark  
080c ..			.dmark: db "AP3"  
080f f1			.pastdmark: pop af  
0810			endm  
# End of macro DMARK
0810					CALLMONITOR 
0810 cd 28 14			call break_point_state  
0813				endm  
# End of macro CALLMONITOR
0813				endif 
0813 2a 4f eb			ld hl, (store_tmppageid) 
0816 11 65 eb			ld de, store_page 
0819 cd 16 02			call storage_write_block 
081c			 
081c				; find free block 
081c			 
081c 11 00 00			ld de, 0			 ; file extent to locate 
081f			 
081f 21 40 00				ld hl, STORE_BLOCK_PHY 
0822 cd d2 04				call storage_findnextid 
0825			 
0825					; TODO handle no space left 
0825					 
0825 22 4f eb				ld (store_tmppageid), hl 
0828			 
0828				if DEBUG_STORESE 
0828					DMARK "AP4" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 7a ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 7b ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 7c ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "AP4"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd 28 14			call break_point_state  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844					; init the buffer with zeros so we can id if the buffer is full or not 
0844			 
0844 e5					push hl 
0845 c5					push bc 
0846			 
0846 21 65 eb				ld hl, store_page 
0849 06 40				ld b, STORE_BLOCK_PHY 
084b 3e 00				ld a, 0 
084d 77			.zeroblock:	ld (hl), a 
084e 23					inc hl 
084f 10 fc				djnz .zeroblock 
0851			 
0851 c1					pop bc 
0852 e1					pop hl 
0853			 
0853					; construct block 
0853			 
0853 3a 5e eb				ld a, (store_tmpid) 
0856 32 65 eb				ld (store_page), a   ; file id 
0859 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
085c 32 66 eb				ld (store_page+1), a 
085f			 
085f e1					pop hl    ; get string to write 
0860 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0862 11 67 eb				ld de, store_page+2 
0865			 
0865				if DEBUG_STORESE 
0865					DMARK "AP5" 
0865 f5				push af  
0866 3a 7a 08			ld a, (.dmark)  
0869 32 7a ee			ld (debug_mark),a  
086c 3a 7b 08			ld a, (.dmark+1)  
086f 32 7b ee			ld (debug_mark+1),a  
0872 3a 7c 08			ld a, (.dmark+2)  
0875 32 7c ee			ld (debug_mark+2),a  
0878 18 03			jr .pastdmark  
087a ..			.dmark: db "AP5"  
087d f1			.pastdmark: pop af  
087e			endm  
# End of macro DMARK
087e					CALLMONITOR 
087e cd 28 14			call break_point_state  
0881				endm  
# End of macro CALLMONITOR
0881				endif 
0881			 
0881			 
0881			 
0881					; fill buffer with data until end of string or full block 
0881			 
0881 7e			.appd:		ld a, (hl) 
0882 12					ld (de), a 
0883 fe 00				cp 0 
0885 28 04				jr z, .appdone 
0887 23					inc hl 
0888 13					inc de 
0889 10 f6				djnz .appd 
088b			 
088b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
088c f5					push af   		; save last byte dumped 
088d			 
088d			 
088d 2a 4f eb			ld hl, (store_tmppageid) 
0890 11 65 eb			ld de, store_page 
0893				if DEBUG_STORESE 
0893					DMARK "AP6" 
0893 f5				push af  
0894 3a a8 08			ld a, (.dmark)  
0897 32 7a ee			ld (debug_mark),a  
089a 3a a9 08			ld a, (.dmark+1)  
089d 32 7b ee			ld (debug_mark+1),a  
08a0 3a aa 08			ld a, (.dmark+2)  
08a3 32 7c ee			ld (debug_mark+2),a  
08a6 18 03			jr .pastdmark  
08a8 ..			.dmark: db "AP6"  
08ab f1			.pastdmark: pop af  
08ac			endm  
# End of macro DMARK
08ac					CALLMONITOR 
08ac cd 28 14			call break_point_state  
08af				endm  
# End of macro CALLMONITOR
08af				endif 
08af cd 16 02				call storage_write_block 
08b2			 
08b2			 
08b2				; was that a full block of data written? 
08b2				; any more to write out? 
08b2			 
08b2				; if yes then set vars and jump to start of function again 
08b2			 
08b2 f1					pop af 
08b3 d1					pop de 
08b4			 
08b4 fe 00				cp 0		 ; no, string was fully written 
08b6 c8					ret z 
08b7			 
08b7					; setup vars for next cycle 
08b7			 
08b7 3a 5e eb				ld a, (store_tmpid) 
08ba 6f					ld l, a 
08bb 26 00				ld h, 0 
08bd			 
08bd c3 7f 07			 	jp storage_append	 ; yes, need to write out some more 
08c0			 
08c0			 
08c0			 
08c0			 
08c0			 
08c0			 
08c0			 
08c0			if DEBUG_STORECF 
08c0			storageput:	 
08c0					ret 
08c0			storageread: 
08c0					ld hl, store_page 
08c0					ld b, 200 
08c0					ld a,0 
08c0			.src:		ld (hl),a 
08c0					inc hl 
08c0					djnz .src 
08c0					 
08c0			 
08c0					ld de, 0 
08c0					ld bc, 1 
08c0					ld hl, store_page 
08c0					call cfRead 
08c0			 
08c0				call cfGetError 
08c0				ld hl,scratch 
08c0				call hexout 
08c0				ld hl, scratch+2 
08c0				ld a, 0 
08c0				ld (hl),a 
08c0				ld de, scratch 
08c0				ld a,display_row_1 
08c0				call str_at_display 
08c0				call update_display 
08c0			 
08c0					ld hl, store_page 
08c0					ld (os_cur_ptr),hl 
08c0			 
08c0					ret 
08c0			endif 
08c0			 
08c0			 
08c0			; Clear out the main buffer store (used to remove junk before writing a new block) 
08c0			 
08c0			storage_clear_page: 
08c0 e5				push hl 
08c1 d5				push de 
08c2 c5				push bc 
08c3 21 65 eb			ld hl, store_page 
08c6 3e 00			ld a, 0 
08c8 77				ld (hl), a 
08c9			 
08c9 11 66 eb			ld de, store_page+1 
08cc 01 40 00			ld bc, STORE_BLOCK_PHY 
08cf			 
08cf ed b0			ldir 
08d1				 
08d1 c1				pop bc 
08d2 d1				pop de 
08d3 e1				pop hl 
08d4 c9				ret 
08d5			 
08d5			; eof 
# End of file firmware_storage.asm
08d5			  
08d5			; support routines for above hardware abstraction layer  
08d5			  
08d5			include "firmware_general.asm"        ; general support functions  
08d5			 
08d5			; word look up 
08d5			 
08d5			; in 
08d5			; a is the index 
08d5			; hl is pointer start of array 
08d5			; 
08d5			; returns 
08d5			; hl to the word 
08d5			; 
08d5			 
08d5			table_lookup:  
08d5 d5					push de 
08d6 eb					ex de, hl 
08d7			 
08d7 6f					ld l, a 
08d8 26 00				ld h, 0 
08da 29					add hl, hl 
08db 19					add hl, de 
08dc 7e					ld a, (hl) 
08dd 23					inc hl 
08de 66					ld h,(hl) 
08df 6f					ld l, a 
08e0			 
08e0 d1					pop de 
08e1 c9					ret 
08e2			 
08e2			; Delay loops 
08e2			 
08e2			 
08e2			 
08e2			aDelayInMS: 
08e2 c5				push bc 
08e3 47				ld b,a 
08e4			msdelay: 
08e4 c5				push bc 
08e5				 
08e5			 
08e5 01 41 00			ld bc,041h 
08e8 cd 00 09			call delayloop 
08eb c1				pop bc 
08ec 05				dec b 
08ed 20 f5			jr nz,msdelay 
08ef			 
08ef			;if CPU_CLOCK_8MHZ 
08ef			;msdelay8: 
08ef			;	push bc 
08ef			;	 
08ef			; 
08ef			;	ld bc,041h 
08ef			;	call delayloop 
08ef			;	pop bc 
08ef			;	dec b 
08ef			;	jr nz,msdelay8 
08ef			;endif 
08ef			 
08ef			 
08ef c1				pop bc 
08f0 c9				ret 
08f1			 
08f1			 
08f1			delay250ms: 
08f1				;push de 
08f1 01 00 40			ld bc, 04000h 
08f4 c3 00 09			jp delayloop 
08f7			delay500ms: 
08f7				;push de 
08f7 01 00 80			ld bc, 08000h 
08fa c3 00 09			jp delayloop 
08fd			delay1s: 
08fd				;push bc 
08fd			   ; Clobbers A, d and e 
08fd 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0900			delayloop: 
0900 c5			    push bc 
0901			 
0901			if BASE_CPM 
0901 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0904			.cpmloop: 
0904 c5				push bc 
0905			 
0905			endif 
0905			 
0905			 
0905			 
0905			delayloopi: 
0905			;	push bc 
0905			;.dl: 
0905 cb 47		    bit     0,a    	; 8 
0907 cb 47		    bit     0,a    	; 8 
0909 cb 47		    bit     0,a    	; 8 
090b e6 ff		    and     255  	; 7 
090d 0b			    dec     bc      	; 6 
090e 79			    ld      a,c     	; 4 
090f b0			    or      b     	; 4 
0910 c2 05 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0913			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0913				;pop de 
0913			;pop bc 
0913			 
0913			if BASE_CPM 
0913 c1				pop bc 
0914				 
0914 0b			    dec     bc      	; 6 
0915 79			    ld      a,c     	; 4 
0916 b0			    or      b     	; 4 
0917 c2 04 09		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
091a				 
091a			 
091a			endif 
091a			;if CPU_CLOCK_8MHZ 
091a			;    pop bc 
091a			;    push bc 
091a			;.dl8: 
091a			;    bit     0,a    	; 8 
091a			;    bit     0,a    	; 8 
091a			;    bit     0,a    	; 8 
091a			;    and     255  	; 7 
091a			;    dec     bc      	; 6 
091a			;    ld      a,c     	; 4 
091a			;    or      b     	; 4 
091a			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
091a			;endif 
091a			 
091a			;if CPU_CLOCK_10MHZ 
091a			;    pop bc 
091a			;    push bc 
091a			;.dl8: 
091a			;    bit     0,a    	; 8 
091a			;    bit     0,a    	; 8 
091a			;    bit     0,a    	; 8 
091a			;    and     255  	; 7 
091a			;    dec     bc      	; 6 
091a			;    ld      a,c     	; 4 
091a			;    or      b     	; 4 
091a			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
091a			;endif 
091a c1			    pop bc 
091b			 
091b c9				ret 
091c			 
091c			 
091c			 
091c			; eof 
# End of file firmware_general.asm
091c			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
091c			; display routines that use the physical hardware abstraction layer 
091c			 
091c			 
091c			; information window 
091c			 
091c			; pass hl with 1st string to display 
091c			; pass de with 2nd string to display 
091c			 
091c			info_panel: 
091c e5				push hl 
091d			 
091d 2a db eb			ld hl, (display_fb_active) 
0920 e5				push hl    ; future de destination 
0921 21 c0 ed				ld hl, display_fb0 
0924 22 db eb				ld (display_fb_active), hl 
0927			 
0927 cd 88 09			call clear_display 
092a			 
092a			 
092a 3e 55			ld a, display_row_3 + 5 
092c cd 9b 09			call str_at_display 
092f			 
092f e1				pop hl 
0930 d1				pop de 
0931			 
0931 e5				push hl 
0932			 
0932			 
0932 3e 2d			ld a, display_row_2 + 5 
0934 cd 9b 09			call str_at_display 
0937			 
0937			 
0937 cd ab 09			call update_display 
093a cd 2d 19			call next_page_prompt 
093d cd 88 09			call clear_display 
0940			 
0940				 
0940 21 1f ed				ld hl, display_fb1 
0943 22 db eb				ld (display_fb_active), hl 
0946 cd ab 09			call update_display 
0949			 
0949			 
0949 c9				ret 
094a			 
094a			 
094a			 
094a			 
094a			; TODO windowing? 
094a			 
094a			; TODO scroll line up 
094a			 
094a			scroll_up: 
094a			 
094a e5				push hl 
094b d5				push de 
094c c5				push bc 
094d			 
094d				; get frame buffer  
094d			 
094d 2a db eb			ld hl, (display_fb_active) 
0950 e5				push hl    ; future de destination 
0951			 
0951 11 28 00			ld  de, display_cols 
0954 19				add hl, de 
0955			 
0955 d1				pop de 
0956			 
0956				;ex de, hl 
0956 01 9f 00			ld bc, display_fb_len -1  
0959			;if DEBUG_FORTH_WORDS 
0959			;	DMARK "SCL" 
0959			;	CALLMONITOR 
0959			;endif	 
0959 ed b0			ldir 
095b			 
095b				; wipe bottom row 
095b			 
095b			 
095b 2a db eb			ld hl, (display_fb_active) 
095e 11 a0 00			ld de, display_cols*display_rows 
0961 19				add hl, de 
0962 06 28			ld b, display_cols 
0964 3e 20			ld a, ' ' 
0966			.scwipe: 
0966 77				ld (hl), a 
0967 2b				dec hl 
0968 10 fc			djnz .scwipe 
096a			 
096a				;pop hl 
096a			 
096a c1				pop bc 
096b d1				pop de 
096c e1				pop hl 
096d			 
096d c9				ret 
096e			 
096e			 
096e			;scroll_upo: 
096e			;	ld de, display_row_1 
096e			 ;	ld hl, display_row_2 
096e			;	ld bc, display_cols 
096e			;	ldir 
096e			;	ld de, display_row_2 
096e			 ;	ld hl, display_row_3 
096e			;	ld bc, display_cols 
096e			;	ldir 
096e			;	ld de, display_row_3 
096e			 ;	ld hl, display_row_4 
096e			;	ld bc, display_cols 
096e			;	ldir 
096e			 
096e			; TODO clear row 4 
096e			 
096e			;	ret 
096e			 
096e				 
096e			scroll_down: 
096e			 
096e e5				push hl 
096f d5				push de 
0970 c5				push bc 
0971			 
0971				; get frame buffer  
0971			 
0971 2a db eb			ld hl, (display_fb_active) 
0974			 
0974 11 9f 00			ld de, display_fb_len - 1 
0977 19				add hl, de 
0978			 
0978 e5			push hl    ; future de destination 
0979			 
0979 11 28 00			ld  de, display_cols 
097c ed 52			sbc hl, de 
097e			 
097e			 
097e d1				pop de 
097f			 
097f			;	ex de, hl 
097f 01 9f 00			ld bc, display_fb_len -1  
0982			 
0982			 
0982				 
0982			 
0982 ed b0			ldir 
0984			 
0984				; wipe bottom row 
0984			 
0984			 
0984			;	ld hl, (display_fb_active) 
0984			;;	ld de, display_cols*display_rows 
0984			;;	add hl, de 
0984			;	ld b, display_cols 
0984			;	ld a, ' ' 
0984			;.scwiped: 
0984			;	ld (hl), a 
0984			;	dec hl 
0984			;	djnz .scwiped 
0984			 
0984				;pop hl 
0984			 
0984 c1				pop bc 
0985 d1				pop de 
0986 e1				pop hl 
0987			 
0987 c9				ret 
0988			;scroll_down: 
0988			;	ld de, display_row_4 
0988			;	ld hl, display_row_3 
0988			;	ld bc, display_cols 
0988			;	ldir 
0988			;	ld de, display_row_3 
0988			; 	ld hl, display_row_2 
0988			;	ld bc, display_cols 
0988			;	ldir 
0988			;	ld de, display_row_2 
0988			;	ld hl, display_row_1 
0988			;	ld bc, display_cols 
0988			;	ldir 
0988			;;; TODO clear row 1 
0988			;	ret 
0988			 
0988			 
0988			 
0988			 
0988			 
0988			; clear active frame buffer 
0988			 
0988			clear_display: 
0988 3e 20			ld a, ' ' 
098a c3 8d 09			jp fill_display 
098d			 
098d			; fill active frame buffer with a char in A 
098d			 
098d			fill_display: 
098d 06 a0			ld b,display_fb_len 
098f 2a db eb			ld hl, (display_fb_active) 
0992 77			.fd1:	ld (hl),a 
0993 23				inc hl 
0994 10 fc			djnz .fd1 
0996 23				inc hl 
0997 3e 00			ld a,0 
0999 77				ld (hl),a 
099a			 
099a			 
099a c9				ret 
099b			; Write string (DE) at pos (A) to active frame buffer 
099b			 
099b 2a db eb		str_at_display:    ld hl,(display_fb_active) 
099e 06 00					ld b,0 
09a0 4f					ld c,a 
09a1 09					add hl,bc 
09a2 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
09a3 b7			            OR   A              ;Null terminator? 
09a4 c8			            RET  Z              ;Yes, so finished 
09a5 77					ld (hl),a 
09a6 23				inc hl 
09a7 13			            INC  DE             ;Point to next character 
09a8 18 f8		            JR   .sad1     ;Repeat 
09aa c9					ret 
09ab			 
09ab			; using current frame buffer write to physical display 
09ab			 
09ab			update_display: 
09ab e5				push hl 
09ac 2a db eb			ld hl, (display_fb_active) 
09af cd bf 57			call write_display 
09b2 e1				pop hl 
09b3 c9				ret 
09b4			 
09b4			; TODO scrolling 
09b4			 
09b4			 
09b4			; move cursor right one char 
09b4			cursor_right: 
09b4			 
09b4				; TODO shift right 
09b4				; TODO if beyond max col 
09b4				; TODO       cursor_next_line 
09b4			 
09b4 c9				ret 
09b5			 
09b5			 
09b5			cursor_next_line: 
09b5				; TODO first char 
09b5				; TODO line down 
09b5				; TODO if past last row 
09b5				; TODO    scroll up 
09b5			 
09b5 c9				ret 
09b6			 
09b6			cursor_left: 
09b6				; TODO shift left 
09b6				; TODO if beyond left  
09b6				; TODO     cursor prev line 
09b6				 
09b6 c9				ret 
09b7			 
09b7			cursor_prev_line: 
09b7				; TODO last char 
09b7				; TODO line up 
09b7				; TODO if past first row 
09b7				; TODO   scroll down 
09b7			 
09b7 c9				ret 
09b8			 
09b8			 
09b8			cout: 
09b8				; A - char 
09b8 c9				ret 
09b9			 
09b9			 
09b9			; Display a menu and allow item selection (optional toggle items) 
09b9			; 
09b9			; format: 
09b9			; hl pointer to word array with zero term for items 
09b9			; e.g.    db item1 
09b9			;         db .... 
09b9			;         db 0 
09b9			; 
09b9			; a = starting menu item  
09b9			; 
09b9			; de = pointer item toggle array   (todo) 
09b9			; 
09b9			; returns item selected in a 1-... 
09b9			; returns 0 if back button pressed 
09b9			; 
09b9			; NOTE: Uses system frame buffer to display 
09b9			; 
09b9			; LEFT, Q = go back 
09b9			; RIGHT, SPACE, CR = select 
09b9			; UP, A - Up 
09b9			; DOWN, Z - Down 
09b9			 
09b9			 
09b9			 
09b9			 
09b9			 
09b9			menu: 
09b9			 
09b9					; keep array pointer 
09b9			 
09b9 22 63 eb				ld (store_tmp1), hl 
09bc 32 61 eb				ld (store_tmp2), a 
09bf			 
09bf					; check for key bounce 
09bf			 
09bf			if BASE_KEV 
09bf			 
09bf			.mbounce:	call cin 
09bf					cp 0 
09bf					jr nz, .mbounce 
09bf			endif 
09bf					; for ease use ex 
09bf			 
09bf					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
09bf 21 c0 ed				ld hl, display_fb0 
09c2 22 db eb				ld (display_fb_active), hl 
09c5			 
09c5 cd 88 09		.mloop:		call clear_display 
09c8 cd ab 09				call update_display 
09cb			 
09cb					; draw selection id '>' at 1 
09cb			 
09cb					; init start of list display 
09cb			 
09cb 3e 05				ld a, 5 
09cd 32 5f eb				ld (store_tmp3), a   ; display row count 
09d0 3a 61 eb				ld a,( store_tmp2) 
09d3 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09d6			 
09d6					 
09d6			.mitem:	 
09d6			 
09d6			 
09d6 3a 62 eb				ld a,(store_tmp2+1) 
09d9 6f					ld l, a 
09da 26 00				ld h, 0 
09dc 29					add hl, hl 
09dd ed 5b 63 eb			ld de, (store_tmp1) 
09e1 19					add hl, de 
09e2 7e					ld a, (hl) 
09e3 23					inc hl 
09e4 66					ld h,(hl) 
09e5 6f					ld l, a 
09e6			 
09e6 cd de 0b				call ishlzero 
09e9 28 1a				jr z, .mdone 
09eb			 
09eb eb					ex de, hl 
09ec 3a 5f eb				ld a, (store_tmp3) 
09ef cd 9b 09				call str_at_display 
09f2					 
09f2			 
09f2					; next item 
09f2 3a 62 eb				ld a, (store_tmp2+1) 
09f5 3c					inc a 
09f6 32 62 eb				ld (store_tmp2+1), a   ; display item count 
09f9			 
09f9			 		; next row 
09f9			 
09f9 3a 5f eb				ld a, (store_tmp3) 
09fc c6 28				add display_cols 
09fe 32 5f eb				ld (store_tmp3), a 
0a01			 
0a01					; at end of screen? 
0a01			 
0a01 fe 10				cp display_rows*4 
0a03 20 d1				jr nz, .mitem 
0a05			 
0a05			 
0a05			.mdone: 
0a05 cd de 0b				call ishlzero 
0a08 28 08				jr z, .nodn 
0a0a			 
0a0a 3e 78				ld a, display_row_4 
0a0c 11 8b 0a				ld de, .mdown 
0a0f cd 9b 09				call str_at_display 
0a12			 
0a12					; draw options to fill the screens with active item on line 1 
0a12					; if current option is 2 or more then display ^ in top 
0a12			 
0a12 3a 61 eb		.nodn:		ld a, (store_tmp2) 
0a15 fe 00				cp 0 
0a17 28 08				jr z, .noup 
0a19			 
0a19 3e 00				ld a, 0 
0a1b 11 89 0a				ld de, .mup 
0a1e cd 9b 09				call str_at_display 
0a21			 
0a21 3e 02		.noup:		ld a, 2 
0a23 11 87 0a				ld de, .msel 
0a26 cd 9b 09				call str_at_display 
0a29			 
0a29					; if current option + 1 is not null then display V in bottom 
0a29					; get key 
0a29 cd ab 09				call update_display 
0a2c			 
0a2c			 
0a2c					; handle key 
0a2c			 
0a2c cd 71 58				call cin_wait 
0a2f			 
0a2f fe 05				cp KEY_UP 
0a31 28 2b				jr z, .mgoup 
0a33 fe 61				cp 'a' 
0a35 28 27				jr z, .mgoup 
0a37 fe 0a				cp KEY_DOWN 
0a39 28 32				jr z, .mgod 
0a3b fe 7a				cp 'z' 
0a3d 28 2e				jr z, .mgod 
0a3f fe 20				cp ' ' 
0a41 28 34				jr z, .goend 
0a43 fe 0c				cp KEY_RIGHT 
0a45 28 30				jr z, .goend 
0a47 fe 0d				cp KEY_CR 
0a49 28 2c				jr z, .goend 
0a4b fe 71				cp 'q' 
0a4d 28 0b				jr z, .goback 
0a4f			 
0a4f fe 0b				cp KEY_LEFT 
0a51 28 07				jr z, .goback 
0a53 fe 08				cp KEY_BS 
0a55 28 03				jr z, .goback 
0a57 c3 c5 09				jp .mloop 
0a5a			 
0a5a			.goback: 
0a5a 3e 00			ld a, 0 
0a5c 18 1d			jr .goend2 
0a5e			 
0a5e				; move up one 
0a5e			.mgoup: 
0a5e 3a 61 eb				ld a, (store_tmp2) 
0a61 fe 00				cp 0 
0a63 ca c5 09				jp z, .mloop 
0a66 3d					dec a 
0a67 32 61 eb				ld (store_tmp2), a 
0a6a c3 c5 09				jp .mloop 
0a6d			 
0a6d				; move down one 
0a6d			.mgod: 
0a6d 3a 61 eb				ld a, (store_tmp2) 
0a70 3c					inc a 
0a71 32 61 eb				ld (store_tmp2), a 
0a74 c3 c5 09				jp .mloop 
0a77			 
0a77			 
0a77			.goend: 
0a77					; get selected item number 
0a77			 
0a77 3a 61 eb				ld a, (store_tmp2) 
0a7a 3c					inc a 
0a7b			 
0a7b			.goend2: 
0a7b f5					push af 
0a7c			 
0a7c					; restore active fb 
0a7c					; TODO BUG assumes fb1 
0a7c			 
0a7c 21 1f ed				ld hl, display_fb1 
0a7f 22 db eb				ld (display_fb_active), hl 
0a82			 
0a82					; restore main regs 
0a82			 
0a82			 
0a82 cd ab 09				call update_display 
0a85			 
0a85 f1					pop af 
0a86			 
0a86 c9				ret 
0a87			 
0a87 .. 00		.msel:   db ">",0 
0a89 .. 00		.mup:   db "^",0 
0a8b .. 00		.mdown:   db "v",0 
0a8d			 
0a8d			 
0a8d			; eof 
0a8d			 
# End of file firmware_display.asm
0a8d			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0a8d			; random number generators 
0a8d			 
0a8d			 
0a8d			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0a8d			 
0a8d			 
0a8d			;-----> Generate a random number 
0a8d			; output a=answer 0<=a<=255 
0a8d			; all registers are preserved except: af 
0a8d			random: 
0a8d e5			        push    hl 
0a8e d5			        push    de 
0a8f 2a bd eb		        ld      hl,(randData) 
0a92 ed 5f		        ld      a,r 
0a94 57			        ld      d,a 
0a95 5e			        ld      e,(hl) 
0a96 19			        add     hl,de 
0a97 85			        add     a,l 
0a98 ac			        xor     h 
0a99 22 bd eb		        ld      (randData),hl 
0a9c d1			        pop     de 
0a9d e1			        pop     hl 
0a9e c9			        ret 
0a9f			 
0a9f			 
0a9f			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0a9f			 
0a9f			 
0a9f			 
0a9f			;------LFSR------ 
0a9f			;James Montelongo 
0a9f			;optimized by Spencer Putt 
0a9f			;out: 
0a9f			; a = 8 bit random number 
0a9f			RandLFSR: 
0a9f 21 c3 eb		        ld hl,LFSRSeed+4 
0aa2 5e			        ld e,(hl) 
0aa3 23			        inc hl 
0aa4 56			        ld d,(hl) 
0aa5 23			        inc hl 
0aa6 4e			        ld c,(hl) 
0aa7 23			        inc hl 
0aa8 7e			        ld a,(hl) 
0aa9 47			        ld b,a 
0aaa cb 13		        rl e  
0aac cb 12			rl d 
0aae cb 11		        rl c  
0ab0 17				rla 
0ab1 cb 13		        rl e  
0ab3 cb 12			rl d 
0ab5 cb 11		        rl c  
0ab7 17				rla 
0ab8 cb 13		        rl e  
0aba cb 12			rl d 
0abc cb 11		        rl c  
0abe 17				rla 
0abf 67			        ld h,a 
0ac0 cb 13		        rl e  
0ac2 cb 12			rl d 
0ac4 cb 11		        rl c  
0ac6 17				rla 
0ac7 a8			        xor b 
0ac8 cb 13		        rl e  
0aca cb 12			rl d 
0acc ac			        xor h 
0acd a9			        xor c 
0ace aa			        xor d 
0acf 21 c5 eb		        ld hl,LFSRSeed+6 
0ad2 11 c6 eb		        ld de,LFSRSeed+7 
0ad5 01 07 00		        ld bc,7 
0ad8 ed b8		        lddr 
0ada 12			        ld (de),a 
0adb c9			        ret 
0adc			 
0adc			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0adc			 
0adc			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0adc			 
0adc			 
0adc			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0adc			 
0adc			prng16: 
0adc			;Inputs: 
0adc			;   (seed1) contains a 16-bit seed value 
0adc			;   (seed2) contains a NON-ZERO 16-bit seed value 
0adc			;Outputs: 
0adc			;   HL is the result 
0adc			;   BC is the result of the LCG, so not that great of quality 
0adc			;   DE is preserved 
0adc			;Destroys: 
0adc			;   AF 
0adc			;cycle: 4,294,901,760 (almost 4.3 billion) 
0adc			;160cc 
0adc			;26 bytes 
0adc 2a b7 eb		    ld hl,(seed1) 
0adf 44			    ld b,h 
0ae0 4d			    ld c,l 
0ae1 29			    add hl,hl 
0ae2 29			    add hl,hl 
0ae3 2c			    inc l 
0ae4 09			    add hl,bc 
0ae5 22 b7 eb		    ld (seed1),hl 
0ae8 2a b5 eb		    ld hl,(seed2) 
0aeb 29			    add hl,hl 
0aec 9f			    sbc a,a 
0aed e6 2d		    and %00101101 
0aef ad			    xor l 
0af0 6f			    ld l,a 
0af1 22 b5 eb		    ld (seed2),hl 
0af4 09			    add hl,bc 
0af5 c9			    ret 
0af6			 
0af6			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0af6			 
0af6			rand32: 
0af6			;Inputs: 
0af6			;   (seed1_0) holds the lower 16 bits of the first seed 
0af6			;   (seed1_1) holds the upper 16 bits of the first seed 
0af6			;   (seed2_0) holds the lower 16 bits of the second seed 
0af6			;   (seed2_1) holds the upper 16 bits of the second seed 
0af6			;   **NOTE: seed2 must be non-zero 
0af6			;Outputs: 
0af6			;   HL is the result 
0af6			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0af6			;Destroys: 
0af6			;   AF 
0af6			;Tested and passes all CAcert tests 
0af6			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0af6			;it has a period of 18,446,744,069,414,584,320 
0af6			;roughly 18.4 quintillion. 
0af6			;LFSR taps: 0,2,6,7  = 11000101 
0af6			;291cc 
0af6			;seed1_0=$+1 
0af6			;    ld hl,12345 
0af6			;seed1_1=$+1 
0af6			;    ld de,6789 
0af6			;    ld b,h 
0af6			;    ld c,l 
0af6			;    add hl,hl \ rl e \ rl d 
0af6			;    add hl,hl \ rl e \ rl d 
0af6			;    inc l 
0af6			;    add hl,bc 
0af6			;    ld (seed1_0),hl 
0af6			;    ld hl,(seed1_1) 
0af6			;    adc hl,de 
0af6			;    ld (seed1_1),hl 
0af6			;    ex de,hl 
0af6			;seed2_0=$+1 
0af6			;    ld hl,9876 
0af6			;seed2_1=$+1 
0af6			;    ld bc,54321 
0af6			;    add hl,hl \ rl c \ rl b 
0af6			;    ld (seed2_1),bc 
0af6			;    sbc a,a 
0af6			;    and %11000101 
0af6			;    xor l 
0af6			;    ld l,a 
0af6			;    ld (seed2_0),hl 
0af6			;    ex de,hl 
0af6			;    add hl,bc 
0af6			;    ret 
0af6			; 
0af6			 
0af6			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0af6			; 20 bytes, 86 cycles (excluding ret) 
0af6			 
0af6			; returns   hl = pseudorandom number 
0af6			; corrupts   a 
0af6			 
0af6			; generates 16-bit pseudorandom numbers with a period of 65535 
0af6			; using the xorshift method: 
0af6			 
0af6			; hl ^= hl << 7 
0af6			; hl ^= hl >> 9 
0af6			; hl ^= hl << 8 
0af6			 
0af6			; some alternative shift triplets which also perform well are: 
0af6			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0af6			 
0af6			;  org 32768 
0af6			 
0af6			xrnd: 
0af6 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
0af9 3e 00		  ld a,0 
0afb bd			  cp l 
0afc 20 02		  jr nz, .xrnd1 
0afe 2e 01		  ld l, 1 
0b00			.xrnd1: 
0b00			 
0b00 7c			  ld a,h 
0b01 1f			  rra 
0b02 7d			  ld a,l 
0b03 1f			  rra 
0b04 ac			  xor h 
0b05 67			  ld h,a 
0b06 7d			  ld a,l 
0b07 1f			  rra 
0b08 7c			  ld a,h 
0b09 1f			  rra 
0b0a ad			  xor l 
0b0b 6f			  ld l,a 
0b0c ac			  xor h 
0b0d 67			  ld h,a 
0b0e			 
0b0e 22 bb eb		  ld (xrandc),hl 
0b11			 
0b11 c9			  ret 
0b12			;  
0b12			 
0b12			 
0b12			;;;; int maths 
0b12			 
0b12			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b12			; Divide 16-bit values (with 16-bit result) 
0b12			; In: Divide BC by divider DE 
0b12			; Out: BC = result, HL = rest 
0b12			; 
0b12			Div16: 
0b12 21 00 00		    ld hl,0 
0b15 78			    ld a,b 
0b16 06 08		    ld b,8 
0b18			Div16_Loop1: 
0b18 17			    rla 
0b19 ed 6a		    adc hl,hl 
0b1b ed 52		    sbc hl,de 
0b1d 30 01		    jr nc,Div16_NoAdd1 
0b1f 19			    add hl,de 
0b20			Div16_NoAdd1: 
0b20 10 f6		    djnz Div16_Loop1 
0b22 17			    rla 
0b23 2f			    cpl 
0b24 47			    ld b,a 
0b25 79			    ld a,c 
0b26 48			    ld c,b 
0b27 06 08		    ld b,8 
0b29			Div16_Loop2: 
0b29 17			    rla 
0b2a ed 6a		    adc hl,hl 
0b2c ed 52		    sbc hl,de 
0b2e 30 01		    jr nc,Div16_NoAdd2 
0b30 19			    add hl,de 
0b31			Div16_NoAdd2: 
0b31 10 f6		    djnz Div16_Loop2 
0b33 17			    rla 
0b34 2f			    cpl 
0b35 41			    ld b,c 
0b36 4f			    ld c,a 
0b37 c9			ret 
0b38			 
0b38			 
0b38			;http://z80-heaven.wikidot.com/math 
0b38			; 
0b38			;Inputs: 
0b38			;     DE and A are factors 
0b38			;Outputs: 
0b38			;     A is not changed 
0b38			;     B is 0 
0b38			;     C is not changed 
0b38			;     DE is not changed 
0b38			;     HL is the product 
0b38			;Time: 
0b38			;     342+6x 
0b38			; 
0b38			Mult16: 
0b38			 
0b38 06 08		     ld b,8          ;7           7 
0b3a 21 00 00		     ld hl,0         ;10         10 
0b3d 29			       add hl,hl     ;11*8       88 
0b3e 07			       rlca          ;4*8        32 
0b3f 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b41 19			         add hl,de   ;--         -- 
0b42 10 f9		       djnz $-5      ;13*7+8     99 
0b44 c9			ret 
0b45			 
0b45			; 
0b45			; Square root of 16-bit value 
0b45			; In:  HL = value 
0b45			; Out:  D = result (rounded down) 
0b45			; 
0b45			;Sqr16: 
0b45			;    ld de,#0040 
0b45			;    ld a,l 
0b45			;    ld l,h 
0b45			;    ld h,d 
0b45			;    or a 
0b45			;    ld b,8 
0b45			;Sqr16_Loop: 
0b45			;    sbc hl,de 
0b45			;    jr nc,Sqr16_Skip 
0b45			;    add hl,de 
0b45			;Sqr16_Skip: 
0b45			;    ccf 
0b45			;    rl d 
0b45			;    add a,a 
0b45			;    adc hl,hl 
0b45			;    add a,a 
0b45			;    adc hl,hl 
0b45			;    djnz Sqr16_Loop 
0b45			;    ret 
0b45			; 
0b45			; 
0b45			; Divide 8-bit values 
0b45			; In: Divide E by divider C 
0b45			; Out: A = result, B = rest 
0b45			; 
0b45			Div8: 
0b45 af			    xor a 
0b46 06 08		    ld b,8 
0b48			Div8_Loop: 
0b48 cb 13		    rl e 
0b4a 17			    rla 
0b4b 91			    sub c 
0b4c 30 01		    jr nc,Div8_NoAdd 
0b4e 81			    add a,c 
0b4f			Div8_NoAdd: 
0b4f 10 f7		    djnz Div8_Loop 
0b51 47			    ld b,a 
0b52 7b			    ld a,e 
0b53 17			    rla 
0b54 2f			    cpl 
0b55 c9			    ret 
0b56			 
0b56			; 
0b56			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b56			; In: Multiply A with DE 
0b56			; Out: HL = result 
0b56			; 
0b56			Mult12U: 
0b56 2e 00		    ld l,0 
0b58 87			    add a,a 
0b59 30 01		    jr nc,Mult12U_NoAdd0 
0b5b 19			    add hl,de 
0b5c			Mult12U_NoAdd0: 
0b5c 29			    add hl,hl 
0b5d 87			    add a,a 
0b5e 30 01		    jr nc,Mult12U_NoAdd1 
0b60 19			    add hl,de 
0b61			Mult12U_NoAdd1: 
0b61 29			    add hl,hl 
0b62 87			    add a,a 
0b63 30 01		    jr nc,Mult12U_NoAdd2 
0b65 19			    add hl,de 
0b66			Mult12U_NoAdd2: 
0b66 29			    add hl,hl 
0b67 87			    add a,a 
0b68 30 01		    jr nc,Mult12U_NoAdd3 
0b6a 19			    add hl,de 
0b6b			Mult12U_NoAdd3: 
0b6b 29			    add hl,hl 
0b6c 87			    add a,a 
0b6d 30 01		    jr nc,Mult12U_NoAdd4 
0b6f 19			    add hl,de 
0b70			Mult12U_NoAdd4: 
0b70 29			    add hl,hl 
0b71 87			    add a,a 
0b72 30 01		    jr nc,Mult12U_NoAdd5 
0b74 19			    add hl,de 
0b75			Mult12U_NoAdd5: 
0b75 29			    add hl,hl 
0b76 87			    add a,a 
0b77 30 01		    jr nc,Mult12U_NoAdd6 
0b79 19			    add hl,de 
0b7a			Mult12U_NoAdd6: 
0b7a 29			    add hl,hl 
0b7b 87			    add a,a 
0b7c d0			    ret nc 
0b7d 19			    add hl,de 
0b7e c9			    ret 
0b7f			 
0b7f			; 
0b7f			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b7f			; In: Multiply A with DE 
0b7f			;      Put lowest value in A for most efficient calculation 
0b7f			; Out: HL = result 
0b7f			; 
0b7f			Mult12R: 
0b7f 21 00 00		    ld hl,0 
0b82			Mult12R_Loop: 
0b82 cb 3f		    srl a 
0b84 30 01		    jr nc,Mult12R_NoAdd 
0b86 19			    add hl,de 
0b87			Mult12R_NoAdd: 
0b87 cb 23		    sla e 
0b89 cb 12		    rl d 
0b8b b7			    or a 
0b8c c2 82 0b		    jp nz,Mult12R_Loop 
0b8f c9			    ret 
0b90			 
0b90			; 
0b90			; Multiply 16-bit values (with 32-bit result) 
0b90			; In: Multiply BC with DE 
0b90			; Out: BCHL = result 
0b90			; 
0b90			Mult32: 
0b90 79			    ld a,c 
0b91 48			    ld c,b 
0b92 21 00 00		    ld hl,0 
0b95 06 10		    ld b,16 
0b97			Mult32_Loop: 
0b97 29			    add hl,hl 
0b98 17			    rla 
0b99 cb 11		    rl c 
0b9b 30 07		    jr nc,Mult32_NoAdd 
0b9d 19			    add hl,de 
0b9e ce 00		    adc a,0 
0ba0 d2 a4 0b		    jp nc,Mult32_NoAdd 
0ba3 0c			    inc c 
0ba4			Mult32_NoAdd: 
0ba4 10 f1		    djnz Mult32_Loop 
0ba6 41			    ld b,c 
0ba7 4f			    ld c,a 
0ba8 c9			    ret 
0ba9			 
0ba9			 
0ba9			 
0ba9			; 
0ba9			; Multiply 8-bit values 
0ba9			; In:  Multiply H with E 
0ba9			; Out: HL = result 
0ba9			; 
0ba9			Mult8: 
0ba9 16 00		    ld d,0 
0bab 6a			    ld l,d 
0bac 06 08		    ld b,8 
0bae			Mult8_Loop: 
0bae 29			    add hl,hl 
0baf 30 01		    jr nc,Mult8_NoAdd 
0bb1 19			    add hl,de 
0bb2			Mult8_NoAdd: 
0bb2 10 fa		    djnz Mult8_Loop 
0bb4 c9			    ret 
0bb5			 
0bb5			 
0bb5			 
0bb5			 
0bb5			 
0bb5			 
0bb5			 
0bb5			 
0bb5			;;http://z80-heaven.wikidot.com/math 
0bb5			;;This divides DE by BC, storing the result in DE, remainder in HL 
0bb5			; 
0bb5			;DE_Div_BC:          ;1281-2x, x is at most 16 
0bb5			;     ld a,16        ;7 
0bb5			;     ld hl,0        ;10 
0bb5			;     jp $+5         ;10 
0bb5			;.DivLoop: 
0bb5			;       add hl,bc    ;-- 
0bb5			;       dec a        ;64 
0bb5			;       jr z,.DivLoopEnd        ;86 
0bb5			; 
0bb5			;       sla e        ;128 
0bb5			;       rl d         ;128 
0bb5			;       adc hl,hl    ;240 
0bb5			;       sbc hl,bc    ;240 
0bb5			;       jr nc,.DivLoop ;23|21 
0bb5			;       inc e        ;-- 
0bb5			;       jp .DivLoop+1 
0bb5			; 
0bb5			;.DivLoopEnd: 
0bb5			 
0bb5			;HL_Div_C: 
0bb5			;Inputs: 
0bb5			;     HL is the numerator 
0bb5			;     C is the denominator 
0bb5			;Outputs: 
0bb5			;     A is the remainder 
0bb5			;     B is 0 
0bb5			;     C is not changed 
0bb5			;     DE is not changed 
0bb5			;     HL is the quotient 
0bb5			; 
0bb5			;       ld b,16 
0bb5			;       xor a 
0bb5			;         add hl,hl 
0bb5			;         rla 
0bb5			;         cp c 
0bb5			;         jr c,$+4 
0bb5			;           inc l 
0bb5			;           sub c 
0bb5			;         djnz $-7 
0bb5			 
0bb5			; https://plutiedev.com/z80-add-8bit-to-16bit 
0bb5			 
0bb5			addatohl: 
0bb5 85			    add   a, l    ; A = A+L 
0bb6 6f			    ld    l, a    ; L = A+L 
0bb7 8c			    adc   a, h    ; A = A+L+H+carry 
0bb8 95			    sub   l       ; A = H+carry 
0bb9 67			    ld    h, a    ; H = H+carry 
0bba c9			ret 
0bbb			 
0bbb			addatode: 
0bbb 83			    add   a, e    ; A = A+L 
0bbc 5f			    ld    e, a    ; L = A+L 
0bbd 8a			    adc   a, d    ; A = A+L+H+carry 
0bbe 93			    sub   e       ; A = H+carry 
0bbf 57			    ld    d, a    ; H = H+carry 
0bc0 c9			ret 
0bc1			 
0bc1			 
0bc1			addatobc: 
0bc1 81			    add   a, c    ; A = A+L 
0bc2 4f			    ld    c, a    ; L = A+L 
0bc3 88			    adc   a, b    ; A = A+L+H+carry 
0bc4 91			    sub   c       ; A = H+carry 
0bc5 47			    ld    b, a    ; H = H+carry 
0bc6 c9			ret 
0bc7			 
0bc7			subafromhl: 
0bc7			   ; If A=0 do nothing 
0bc7			    ; Otherwise flip A's sign. Since 
0bc7			    ; the upper byte becomes -1, also 
0bc7			    ; substract 1 from H. 
0bc7 ed 44		    neg 
0bc9 ca d2 0b		    jp    z, Skip 
0bcc 25			    dec   h 
0bcd			     
0bcd			    ; Now add the low byte as usual 
0bcd			    ; Two's complement takes care of 
0bcd			    ; ensuring the result is correct 
0bcd 85			    add   a, l 
0bce 6f			    ld    l, a 
0bcf 8c			    adc   a, h 
0bd0 95			    sub   l 
0bd1 67			    ld    h, a 
0bd2			Skip: 
0bd2 c9				ret 
0bd3			 
0bd3			 
0bd3			; compare hl and de 
0bd3			; returns:  
0bd3			; if hl = de, z=1, s=0, c0=0 
0bd3			; if hl > de, z=0, s=0, c=0 
0bd3			; if hl < de, z=0, s=1, c=1 
0bd3			cmp16:	 
0bd3 b7				or a 
0bd4 ed 52			sbc hl,de 
0bd6 e0				ret po 
0bd7 7c				ld a,h 
0bd8 1f				rra 
0bd9 ee 40			xor 01000000B 
0bdb 37				scf 
0bdc 8f				adc a,a 
0bdd c9				ret 
0bde			 
0bde			 
0bde			; test if hl contains zero   - A is destroyed 
0bde			 
0bde			ishlzero:    
0bde b7				or a     ; reset flags 
0bdf 7c				ld a, h 
0be0 b5				or l        	 
0be1			 
0be1 c9				ret 
0be2			 
0be2			 
0be2			 
0be2			 
0be2			if FORTH_ENABLE_FLOATMATH 
0be2			;include "float/bbcmath.z80" 
0be2			include "float/lpfpcalc.asm" 
0be2			endif 
0be2			 
0be2			 
0be2			; eof 
0be2			 
# End of file firmware_maths.asm
0be2			include "firmware_strings.asm"   ; string handling  
0be2			 
0be2			 
0be2			; TODO string len 
0be2			; input text string, end on cr with zero term 
0be2			; a offset into frame buffer to start prompt 
0be2			; d is max length 
0be2			; e is display size TODO 
0be2			; c is current cursor position 
0be2			; hl is ptr to where string will be stored 
0be2			 
0be2			 
0be2			; TODO check limit of buffer for new inserts 
0be2			; TODO check insert does not push beyond buffer 
0be2			; TODO scroll in a limited display area 
0be2			; TODO scroll whole screen on page wrap 
0be2			 
0be2			 
0be2			; TODO handle KEY_PREVWORD 
0be2			; TODO handle KEY_NEXTWORD 
0be2			; TODO handle KEY_HOME 
0be2			; TODO handle KEY_END 
0be2			; TODO use LCD cursor? 
0be2			 
0be2 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0be5 81					add c 
0be6 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0be9 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
0bec 79					ld a, c 
0bed cd b5 0b				call addatohl 
0bf0 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0bf3 7a					ld a,d 
0bf4 32 75 ee			        ld (input_size), a       ; save length of input area 
0bf7 79					ld a, c 
0bf8 32 64 ee				ld (input_cursor),a      ; init cursor start position  
0bfb 7b					ld a,e 
0bfc 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0bff					 
0bff					 
0bff			 
0bff			;		ld a,(input_ptr) 
0bff			;		ld (input_under_cursor),a 	; save what is under the cursor 
0bff			 
0bff			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0bff					; init cursor shape if not set by the cin routines 
0bff 21 d3 eb				ld hl, cursor_shape 
0c02 3e ff				ld a, 255 
0c04 77					ld (hl), a 
0c05 23					inc hl 
0c06 3e 00				ld a, 0 
0c08 77					ld (hl), a 
0c09			 
0c09 3e 0f				ld a, CUR_BLINK_RATE 
0c0b 32 6f ee				ld (input_cur_flash), a 
0c0e 3e 01				ld a, 1 
0c10 32 6e ee				ld (input_cur_onoff),a 
0c13			 
0c13			;	if DEBUG_INPUT 
0c13			;		push af 
0c13			;		ld a, 'I' 
0c13			;		ld (debug_mark),a 
0c13			;		pop af 
0c13			;		CALLMONITOR 
0c13			;	endif 
0c13			.is1:		; main entry loop 
0c13			 
0c13			 
0c13			 
0c13					; pause 1ms 
0c13			 
0c13 3e 01				ld a, 1 
0c15 cd e2 08				call aDelayInMS 
0c18			 
0c18					; dec flash counter 
0c18 3a 6f ee				ld a, (input_cur_flash) 
0c1b 3d					dec a 
0c1c 32 6f ee				ld (input_cur_flash), a 
0c1f fe 00				cp 0 
0c21 20 0d				jr nz, .nochgstate 
0c23			 
0c23			 
0c23					; change state 
0c23 3a 6e ee				ld a,(input_cur_onoff) 
0c26 ed 44				neg 
0c28 32 6e ee				ld (input_cur_onoff),a 
0c2b			 
0c2b			 
0c2b					; reset on change of state 
0c2b 3e 0f				ld a, CUR_BLINK_RATE 
0c2d 32 6f ee				ld (input_cur_flash), a 
0c30			 
0c30			.nochgstate: 
0c30					 
0c30					 
0c30			 
0c30					; display cursor  
0c30			 
0c30			;		ld hl, (input_start) 
0c30			;		ld a, (input_cursor) 
0c30			;		call addatohl 
0c30			 
0c30					; get char under cursor and replace with cursor 
0c30 2a 78 ee		ld hl, (input_ptr) 
0c33			;		ld a, (hl) 
0c33			;		ld (input_under_cursor),a 
0c33			;		ld a, '_' 
0c33			;		ld (hl), a 
0c33			 
0c33					; display string 
0c33			 
0c33 ed 5b 76 ee			ld de, (input_start) 
0c37 3a 73 ee				ld a, (input_at_pos) 
0c3a cd 9b 09				call str_at_display 
0c3d			;	        call update_display 
0c3d			 
0c3d					; find place to put the cursor 
0c3d			;		add h 
0c3d			;		ld l, display_row_1 
0c3d			;		sub l 
0c3d			; (input_at_pos) 
0c3d					;ld c, a 
0c3d			;		ld a, (input_cursor) 
0c3d			;		ld l, (input_at_pos) 
0c3d			;		;ld b, h 
0c3d			;		add l 
0c3d			;		ld (input_at_cursor),a 
0c3d					;ld l,h 
0c3d			 
0c3d			;		ld h, 0 
0c3d			;		ld l,(input_at_pos) 
0c3d			;		ld a, (input_cursor) 
0c3d			;		call addatohl 
0c3d			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c3d			;		call subafromhl 
0c3d			;		ld a,l 
0c3d			;		ld (input_at_cursor), a 
0c3d			 
0c3d				if DEBUG_INPUT 
0c3d					ld a, (hardware_diag) 
0c3d					cp 0 
0c3d					jr z, .skip_input_diag 
0c3d			 
0c3d					ld a,(input_at_pos) 
0c3d					ld hl, LFSRSeed 
0c3d					call hexout 
0c3d					ld a, (input_cursor) 
0c3d					ld hl, LFSRSeed+2 
0c3d					call hexout 
0c3d					ld a,(input_at_cursor) 
0c3d					ld hl, LFSRSeed+4 
0c3d					call hexout 
0c3d			 
0c3d					ld a,(input_cur_onoff) 
0c3d					ld hl, LFSRSeed+6 
0c3d					call hexout 
0c3d			 
0c3d					ld a,(input_cur_flash) 
0c3d					ld hl, LFSRSeed+8 
0c3d					call hexout 
0c3d			 
0c3d					ld a,(input_len) 
0c3d					ld hl, LFSRSeed+10 
0c3d					call hexout 
0c3d					ld hl, LFSRSeed+12 
0c3d					ld a, 0 
0c3d					ld (hl),a 
0c3d					ld a, display_row_4 
0c3d					ld de, LFSRSeed 
0c3d					call str_at_display 
0c3d					.skip_input_diag: 
0c3d				endif 
0c3d			 
0c3d					; decide on if we are showing the cursor this time round 
0c3d			 
0c3d 3a 6e ee				ld a, (input_cur_onoff) 
0c40 fe ff				cp 255 
0c42 28 13				jr z, .skipcur 
0c44			 
0c44			 
0c44 3a 71 ee				ld a,(input_at_cursor) 
0c47 11 d3 eb				ld de, cursor_shape 
0c4a cd 9b 09				call str_at_display 
0c4d			 
0c4d					; save length of current input string 
0c4d 2a 76 ee				ld hl, (input_start) 
0c50 cd 13 10				call strlenz 
0c53 7d					ld a,l 
0c54 32 69 ee				ld (input_len),a 
0c57			 
0c57			.skipcur: 
0c57			 
0c57 cd ab 09			        call update_display 
0c5a					 
0c5a			 
0c5a			 
0c5a					; wait 
0c5a				 
0c5a					; TODO loop without wait to flash the cursor and char under cursor	 
0c5a cd 79 58				call cin    ; _wait 
0c5d			 
0c5d fe 00				cp 0 
0c5f ca 13 0c				jp z, .is1 
0c62			 
0c62					; get ptr to char to input into 
0c62			 
0c62 4f					ld c,a 
0c63 2a 76 ee				ld hl, (input_start) 
0c66 3a 64 ee				ld a, (input_cursor) 
0c69 cd b5 0b				call addatohl 
0c6c 22 78 ee				ld (input_ptr), hl 
0c6f 79					ld a,c 
0c70			 
0c70					; replace char under cursor 
0c70			 
0c70			;		ld hl, (input_ptr) 
0c70			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c70			;		ld (hl), a 
0c70			 
0c70			;	if DEBUG_INPUT 
0c70			;		push af 
0c70			;		ld a, 'i' 
0c70			;		ld (debug_mark),a 
0c70			;		pop af 
0c70			;		CALLMONITOR 
0c70			;	endif 
0c70 fe 0e				cp KEY_HOME 
0c72 20 0e				jr nz, .iske 
0c74			 
0c74 3a 73 ee				ld a, (input_at_pos) 
0c77 32 71 ee				ld (input_at_cursor),a 
0c7a 3e 00				ld a, 0 
0c7c 32 64 ee				ld (input_cursor), a 
0c7f c3 13 0c				jp .is1 
0c82					 
0c82 fe 0f		.iske:		cp KEY_END 
0c84 20 03				jr nz, .isknw 
0c86 c3 13 0c				jp .is1 
0c89			 
0c89 fe 06		.isknw:		cp KEY_NEXTWORD 
0c8b 20 1b				jr nz, .iskpw 
0c8d			 
0c8d 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
0c90 7e					ld a,(hl)	 
0c91 fe 00				cp 0 
0c93 ca 13 0c				jp z, .is1    ; end of string 
0c96 fe 20				cp ' ' 
0c98 ca 13 0c				jp z, .is1    ; end of word 
0c9b 23					inc hl 
0c9c 22 78 ee				ld (input_ptr), hl 
0c9f 3a 71 ee				ld a, (input_at_cursor) 
0ca2 3c					inc a 
0ca3 32 71 ee				ld (input_at_cursor), a 
0ca6 18 e5				jr .isknwm 
0ca8			 
0ca8 fe 07		.iskpw:		cp KEY_PREVWORD 
0caa 20 1b				jr nz, .iskl 
0cac			.iskpwm:	 
0cac 2a 78 ee				ld hl, (input_ptr) 
0caf 7e					ld a,(hl)	 
0cb0 fe 00				cp 0  
0cb2 ca 13 0c				jp z, .is1    ; end of string 
0cb5 fe 20				cp ' ' 
0cb7 ca 13 0c				jp z, .is1    ; end of word 
0cba 2b					dec hl 
0cbb 22 78 ee				ld (input_ptr), hl 
0cbe 3a 71 ee				ld a, (input_at_cursor) 
0cc1 3d					dec a 
0cc2 32 71 ee				ld (input_at_cursor), a 
0cc5 18 e5				jr .iskpwm 
0cc7			 
0cc7			 
0cc7 fe 0b		.iskl:		cp KEY_LEFT 
0cc9 20 27				jr nz, .isk1 
0ccb			 
0ccb 3a 64 ee				ld a, (input_cursor) 
0cce			 
0cce fe 00				cp 0 
0cd0 ca 13 0c				jp z, .is1 		; at start of line to ignore  
0cd3			 
0cd3 3d					dec  a 		; TODO check underflow 
0cd4 32 64 ee				ld (input_cursor), a 
0cd7			 
0cd7 2a 78 ee				ld hl, (input_ptr) 
0cda 2b					dec hl 
0cdb 22 78 ee				ld (input_ptr), hl 
0cde					 
0cde 3a 71 ee				ld a, (input_at_cursor) 
0ce1 3d					dec a 
0ce2 32 71 ee				ld (input_at_cursor), a 
0ce5			 
0ce5 3e 01				ld a, 1		; show cursor moving 
0ce7 32 6e ee				ld (input_cur_onoff),a 
0cea 3e 0f				ld a, CUR_BLINK_RATE 
0cec 32 6f ee				ld (input_cur_flash), a 
0cef			 
0cef c3 13 0c				jp .is1 
0cf2			 
0cf2 fe 0c		.isk1:		cp KEY_RIGHT 
0cf4 20 2a				jr nz, .isk2 
0cf6			 
0cf6 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0cf9 5f					ld e,a 
0cfa 3a 64 ee				ld a, (input_cursor) 
0cfd bb					cp e 
0cfe ca 13 0c				jp z, .is1		; at the end of string so dont go right 
0d01			 
0d01 3c					inc  a 		; TODO check overflow 
0d02 32 64 ee				ld (input_cursor), a 
0d05			 
0d05 3a 71 ee				ld a, (input_at_cursor) 
0d08 3c					inc a 
0d09 32 71 ee				ld (input_at_cursor), a 
0d0c			 
0d0c 2a 78 ee				ld hl, (input_ptr) 
0d0f 23					inc hl 
0d10 22 78 ee				ld (input_ptr), hl 
0d13			 
0d13 3e 01				ld a, 1		; show cursor moving 
0d15 32 6e ee				ld (input_cur_onoff),a 
0d18 3e 0f				ld a, CUR_BLINK_RATE 
0d1a 32 6f ee				ld (input_cur_flash), a 
0d1d			 
0d1d c3 13 0c				jp .is1 
0d20			 
0d20 fe 05		.isk2:		cp KEY_UP 
0d22			 
0d22 20 26				jr nz, .isk3 
0d24			 
0d24					; swap last command with the current on 
0d24			 
0d24					; move cursor to start of string 
0d24 2a 76 ee				ld hl, (input_start) 
0d27 22 78 ee				ld (input_ptr), hl 
0d2a			 
0d2a 3a 73 ee				ld a, (input_at_pos) 
0d2d 32 71 ee				ld (input_at_cursor), a 
0d30			 
0d30 3e 00				ld a, 0 
0d32 32 64 ee				ld (input_cursor), a 
0d35					 
0d35					; swap input and last command buffers 
0d35			 
0d35 21 87 e6				ld hl, os_cli_cmd 
0d38 11 86 e7				ld de, os_last_cmd 
0d3b 06 ff				ld b, 255 
0d3d 7e			.swap1:		ld a, (hl) 
0d3e 4f					ld c,a 
0d3f 1a					ld a, (de) 
0d40 77					ld (hl), a 
0d41 79					ld a,c 
0d42 12					ld (de),a 
0d43 23					inc hl 
0d44 13					inc de 
0d45 10 f6				djnz .swap1 
0d47			 
0d47			 
0d47			 
0d47			 
0d47			 
0d47 c3 13 0c				jp .is1 
0d4a			 
0d4a fe 08		.isk3:		cp KEY_BS 
0d4c 20 3c				jr nz, .isk4 
0d4e			 
0d4e 3a 64 ee				ld a, (input_cursor) 
0d51			 
0d51 fe 00				cp 0 
0d53 ca 13 0c				jp z, .is1 		; at start of line to ignore  
0d56			 
0d56 3d					dec  a 		; TODO check underflow 
0d57 32 64 ee				ld (input_cursor), a 
0d5a			 
0d5a					; hl is source 
0d5a					; de needs to be source - 1 
0d5a			 
0d5a			;		ld a, 0 
0d5a			;		dec hl 
0d5a			;		ld (hl), a 
0d5a			 
0d5a 2a 78 ee				ld hl, (input_ptr) 
0d5d 2b					dec hl 
0d5e 22 78 ee				ld (input_ptr), hl 
0d61			 
0d61					; shift all data 
0d61			 
0d61 e5					push hl 
0d62 23					inc hl 
0d63 d1					pop de 
0d64 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d67 4f					ld c,a 
0d68 06 00				ld b,0 
0d6a ed b0				ldir  
0d6c			 
0d6c			 
0d6c			 
0d6c			 
0d6c 3a 71 ee				ld a, (input_at_cursor) 
0d6f 3d					dec a 
0d70 32 71 ee				ld (input_at_cursor), a 
0d73			 
0d73			 
0d73 3e 01				ld a, 1		; show cursor moving 
0d75 32 6e ee				ld (input_cur_onoff),a 
0d78 3e 0f				ld a, CUR_BLINK_RATE 
0d7a 32 6f ee				ld (input_cur_flash), a 
0d7d			 
0d7d					; remove char 
0d7d 3a 71 ee				ld a, (input_at_cursor) 
0d80 3c					inc a 
0d81 11 0b 0e				ld de,.iblank 
0d84 cd 9b 09				call str_at_display 
0d87			 
0d87 c3 13 0c				jp .is1 
0d8a			 
0d8a fe 0d		.isk4:		cp KEY_CR 
0d8c 28 6c				jr z, .endinput 
0d8e			 
0d8e					; else add the key press to the end 
0d8e			 
0d8e 4f					ld c, a			; save key pressed 
0d8f			 
0d8f 7e					ld a,(hl)		; get what is currently under char 
0d90			 
0d90 fe 00				cp 0			; we are at the end of the string 
0d92 20 2f				jr nz, .onchar 
0d94					 
0d94					; add a char to the end of the string 
0d94				 
0d94 71					ld (hl),c 
0d95 23					inc hl 
0d96			;		ld a,' ' 
0d96			;		ld (hl),a 
0d96			;		inc hl 
0d96 3e 00				ld a,0 
0d98 77					ld (hl),a 
0d99 2b					dec hl 
0d9a			 
0d9a 3a 64 ee				ld a, (input_cursor) 
0d9d 3c					inc a				; TODO check max string length and scroll  
0d9e 32 64 ee				ld (input_cursor), a		; inc cursor pos 
0da1							 
0da1 3a 71 ee				ld a, (input_at_cursor) 
0da4 3c					inc a 
0da5 32 71 ee				ld (input_at_cursor), a 
0da8			 
0da8 2a 78 ee				ld hl, (input_ptr) 
0dab 23					inc hl 
0dac 22 78 ee				ld (input_ptr), hl 
0daf			 
0daf 2a 78 ee				ld hl, (input_ptr) 
0db2 23					inc hl 
0db3 22 78 ee				ld (input_ptr), hl 
0db6			;	if DEBUG_INPUT 
0db6			;		push af 
0db6			;		ld a, '+' 
0db6			;		ld (debug_mark),a 
0db6			;		pop af 
0db6			;		CALLMONITOR 
0db6			;	endif 
0db6 3e 01				ld a, 1		; show cursor moving 
0db8 32 6e ee				ld (input_cur_onoff),a 
0dbb 3e 0f				ld a, CUR_BLINK_RATE 
0dbd 32 6f ee				ld (input_cur_flash), a 
0dc0 c3 13 0c				jp .is1 
0dc3					 
0dc3			 
0dc3			 
0dc3					; if on a char then insert 
0dc3			.onchar: 
0dc3			 
0dc3					; TODO over flow check: make sure insert does not blow out buffer 
0dc3			 
0dc3					; need to do some maths to use lddr 
0dc3			 
0dc3 e5					push hl   ; save char pos 
0dc4 c5					push bc 
0dc5			 
0dc5 2a 76 ee				ld hl, (input_start) 
0dc8 3a 69 ee				ld a, (input_len) 
0dcb cd b5 0b				call addatohl  		; end of string 
0dce 23					inc hl 
0dcf 23					inc hl		; past zero term 
0dd0 e5					push hl 
0dd1 23					inc hl 
0dd2 e5					push hl  
0dd3			 
0dd3								; start and end of lddr set, now how much to move? 
0dd3			 
0dd3							 
0dd3 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0dd6 47					ld b,a 
0dd7 3a 69 ee				ld a,(input_len) 
0dda 5f					ld e,a 
0ddb 90					sub b 
0ddc 3c					inc a		;?? 
0ddd 3c					inc a		;?? 
0dde 3c					inc a		;?? 
0ddf			 
0ddf 06 00				ld b,0 
0de1 4f					ld c,a 
0de2			 
0de2				if DEBUG_INPUT 
0de2					push af 
0de2					ld a, 'i' 
0de2					ld (debug_mark),a 
0de2					pop af 
0de2			;		CALLMONITOR 
0de2				endif 
0de2 d1					pop de 
0de3 e1					pop hl 
0de4				if DEBUG_INPUT 
0de4					push af 
0de4					ld a, 'I' 
0de4					ld (debug_mark),a 
0de4					pop af 
0de4			;		CALLMONITOR 
0de4				endif 
0de4 ed b8				lddr 
0de6				 
0de6			 
0de6			 
0de6					; TODO have a key for insert/overwrite mode???? 
0de6 c1					pop bc 
0de7 e1					pop hl 
0de8 71					ld (hl), c		; otherwise overwrite current char 
0de9					 
0de9			 
0de9			 
0de9			 
0de9 3a 64 ee				ld a, (input_cursor) 
0dec 3c					inc  a 		; TODO check overflow 
0ded 32 64 ee				ld (input_cursor), a 
0df0			 
0df0 3a 71 ee				ld a, (input_at_cursor) 
0df3 3c					inc a 
0df4 32 71 ee				ld (input_at_cursor), a 
0df7			 
0df7 c3 13 0c				jp .is1 
0dfa			 
0dfa			.endinput:	; TODO look for end of string 
0dfa			 
0dfa					; add trailing space for end of token 
0dfa			 
0dfa 2a 76 ee				ld hl, (input_start) 
0dfd 3a 69 ee				ld a,(input_len) 
0e00 cd b5 0b				call addatohl 
0e03 3e 20				ld a, ' ' 
0e05 77					ld (hl),a 
0e06					; TODO eof of parse marker 
0e06			 
0e06 23					inc hl 
0e07 3e 00				ld a, 0 
0e09 77					ld (hl),a 
0e0a			 
0e0a			 
0e0a c9					ret 
0e0b			 
0e0b .. 00		.iblank: db " ",0 
0e0d			 
0e0d			 
0e0d 32 73 ee		input_str_prev:	ld (input_at_pos), a 
0e10 22 76 ee				ld (input_start), hl 
0e13 3e 01				ld a,1			; add cursor 
0e15 77					ld (hl),a 
0e16 23					inc hl 
0e17 3e 00				ld a,0 
0e19 77					ld (hl),a 
0e1a 22 78 ee				ld (input_ptr), hl 
0e1d 7a					ld a,d 
0e1e 32 75 ee				ld (input_size), a 
0e21 3e 00				ld a,0 
0e23 32 64 ee				ld (input_cursor),a 
0e26			.instr1:	 
0e26			 
0e26					; TODO do block cursor 
0e26					; TODO switch cursor depending on the modifer key 
0e26			 
0e26					; update cursor shape change on key hold 
0e26			 
0e26 2a 78 ee				ld hl, (input_ptr) 
0e29 2b					dec hl 
0e2a 3a d3 eb				ld a,(cursor_shape) 
0e2d 77					ld (hl), a 
0e2e			 
0e2e					; display entered text 
0e2e 3a 73 ee				ld a,(input_at_pos) 
0e31 cd 8e 57		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e34 ed 5b 76 ee	            	LD   de, (input_start) 
0e38 cd 83 57		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e3b			 
0e3b cd 79 58				call cin 
0e3e fe 00				cp 0 
0e40 28 e4				jr z, .instr1 
0e42			 
0e42					; proecess keyboard controls first 
0e42			 
0e42 2a 78 ee				ld hl,(input_ptr) 
0e45			 
0e45 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0e47 28 5a				jr z, .instrcr 
0e49			 
0e49 fe 08				cp KEY_BS 	; back space 
0e4b 20 0f				jr nz, .instr2 
0e4d					; process back space 
0e4d			 
0e4d					; TODO stop back space if at start of string 
0e4d 2b					dec hl 
0e4e 2b					dec hl ; to over write cursor 
0e4f 3a d3 eb				ld a,(cursor_shape) 
0e52					;ld a,0 
0e52 77					ld (hl),a 
0e53 23					inc hl 
0e54 3e 20				ld a," " 
0e56 77					ld (hl),a 
0e57 22 78 ee				ld (input_ptr),hl 
0e5a					 
0e5a			 
0e5a 18 ca				jr .instr1 
0e5c			 
0e5c fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e5e 20 06				jr nz, .instr3 
0e60 2b					dec hl 
0e61 22 78 ee				ld (input_ptr),hl 
0e64 18 c0				jr .instr1 
0e66				 
0e66 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e68 20 06				jr nz, .instr4 
0e6a 23					inc hl 
0e6b 22 78 ee				ld (input_ptr),hl 
0e6e 18 b6				jr .instr1 
0e70			 
0e70 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e72 20 06				jr nz, .instr5 
0e74 2b					dec hl 
0e75 22 78 ee				ld (input_ptr),hl 
0e78 18 ac				jr .instr1 
0e7a			 
0e7a fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e7c 20 06				jr nz, .instr6 
0e7e 2b					dec hl 
0e7f 22 78 ee				ld (input_ptr),hl 
0e82 18 a2				jr .instr1 
0e84 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e86 20 0b				jr nz, .instrnew 
0e88			 
0e88 21 60 e3			ld hl, scratch 
0e8b 11 86 e7			ld de, os_last_cmd 
0e8e cd ac 0e			call strcpy 
0e91 18 93				jr .instr1 
0e93			 
0e93			 
0e93			.instrnew:	; no special key pressed to see if we have room to store it 
0e93			 
0e93					; TODO do string size test 
0e93			 
0e93 2b					dec hl ; to over write cursor 
0e94 77					ld (hl),a 
0e95 23					inc hl 
0e96 3a d3 eb				ld a,(cursor_shape) 
0e99 77					ld (hl),a 
0e9a 23					inc hl 
0e9b 3e 00				ld a,0 
0e9d 77					ld (hl),a 
0e9e			 
0e9e 22 78 ee				ld (input_ptr),hl 
0ea1					 
0ea1 18 83				jr .instr1 
0ea3 2b			.instrcr:	dec hl		; remove cursor 
0ea4 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ea6 77					ld (hl),a 
0ea7 23					inc hl 
0ea8 3e 00				ld a,0 
0eaa 77					ld (hl),a 
0eab			 
0eab			 
0eab					; if at end of line scroll up    
0eab					; TODO detecting only end of line 4 for scroll up  
0eab			 
0eab					;ld   
0eab			 
0eab c9					ret 
0eac			 
0eac			 
0eac			; strcpy hl = dest, de source 
0eac			 
0eac 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ead b7			            OR   A              ;Null terminator? 
0eae c8			            RET  Z              ;Yes, so finished 
0eaf 1a					ld a,(de) 
0eb0 77					ld (hl),a 
0eb1 13			            INC  DE             ;Point to next character 
0eb2 23					inc hl 
0eb3 18 f7		            JR   strcpy       ;Repeat 
0eb5 c9					ret 
0eb6			 
0eb6			 
0eb6			; TODO string_at  
0eb6			; pass string which starts with lcd offset address and then null term string 
0eb6			 
0eb6			; TODO string to dec 
0eb6			; TODO string to hex 
0eb6			; TODO byte to string hex 
0eb6			; TODO byte to string dec 
0eb6			 
0eb6			 
0eb6			 
0eb6			; from z80uartmonitor 
0eb6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eb6			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0eb6			; pass hl for where to put the text 
0eb6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eb6 c5			hexout:	PUSH BC 
0eb7 f5					PUSH AF 
0eb8 47					LD B, A 
0eb9					; Upper nybble 
0eb9 cb 3f				SRL A 
0ebb cb 3f				SRL A 
0ebd cb 3f				SRL A 
0ebf cb 3f				SRL A 
0ec1 cd d1 0e				CALL tohex 
0ec4 77					ld (hl),a 
0ec5 23					inc hl	 
0ec6					 
0ec6					; Lower nybble 
0ec6 78					LD A, B 
0ec7 e6 0f				AND 0FH 
0ec9 cd d1 0e				CALL tohex 
0ecc 77					ld (hl),a 
0ecd 23					inc hl	 
0ece					 
0ece f1					POP AF 
0ecf c1					POP BC 
0ed0 c9					RET 
0ed1					 
0ed1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ed1			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ed1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ed1			tohex: 
0ed1 e5					PUSH HL 
0ed2 d5					PUSH DE 
0ed3 16 00				LD D, 0 
0ed5 5f					LD E, A 
0ed6 21 de 0e				LD HL, .DATA 
0ed9 19					ADD HL, DE 
0eda 7e					LD A, (HL) 
0edb d1					POP DE 
0edc e1					POP HL 
0edd c9					RET 
0ede			 
0ede			.DATA: 
0ede 30					DEFB	30h	; 0 
0edf 31					DEFB	31h	; 1 
0ee0 32					DEFB	32h	; 2 
0ee1 33					DEFB	33h	; 3 
0ee2 34					DEFB	34h	; 4 
0ee3 35					DEFB	35h	; 5 
0ee4 36					DEFB	36h	; 6 
0ee5 37					DEFB	37h	; 7 
0ee6 38					DEFB	38h	; 8 
0ee7 39					DEFB	39h	; 9 
0ee8 41					DEFB	41h	; A 
0ee9 42					DEFB	42h	; B 
0eea 43					DEFB	43h	; C 
0eeb 44					DEFB	44h	; D 
0eec 45					DEFB	45h	; E 
0eed 46					DEFB	46h	; F 
0eee			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eee			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0eee			;;    subtract $30, if result > 9 then subtract $7 more 
0eee			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0eee			atohex: 
0eee d6 30				SUB $30 
0ef0 fe 0a				CP 10 
0ef2 f8					RET M		; If result negative it was 0-9 so we're done 
0ef3 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0ef5 c9					RET		 
0ef6			 
0ef6			 
0ef6			 
0ef6			 
0ef6			; Get 2 ASCII characters as hex byte from pointer in hl 
0ef6			 
0ef6			BYTERD: 
0ef6 16 00			LD	D,00h		;Set up 
0ef8 cd 00 0f			CALL	HEXCON		;Get byte and convert to hex 
0efb 87				ADD	A,A		;First nibble so 
0efc 87				ADD	A,A		;multiply by 16 
0efd 87				ADD	A,A		; 
0efe 87				ADD	A,A		; 
0eff 57				LD	D,A		;Save hi nibble in D 
0f00			HEXCON: 
0f00 7e				ld a, (hl)		;Get next chr 
0f01 23				inc hl 
0f02 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f04 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f06 38 02			JR	C,NALPHA	;If so miss next bit 
0f08 d6 07			SUB	007h		;Else convert alpha 
0f0a			NALPHA: 
0f0a b2				OR	D		;Add hi nibble back 
0f0b c9				RET			; 
0f0c			 
0f0c			 
0f0c			; 
0f0c			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f0c			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f0c			; characters (0-9a-f) are accepted. 
0f0c			; 
0f0c			;get_word        push    af 
0f0c			;                call    get_byte        ; Get the upper byte 
0f0c			;                ld      h, a 
0f0c			;                call    get_byte        ; Get the lower byte 
0f0c			;                ld      l, a 
0f0c			;                pop     af 
0f0c			;                ret 
0f0c			; 
0f0c			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f0c			; the routine get_nibble is used only valid characters are accepted - the  
0f0c			; input routine only accepts characters 0-9a-f. 
0f0c			; 
0f0c c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f0d 7e					ld a,(hl) 
0f0e 23					inc hl 
0f0f cd 34 0f		                call    nibble2val      ; Get upper nibble 
0f12 cb 07		                rlc     a 
0f14 cb 07		                rlc     a 
0f16 cb 07		                rlc     a 
0f18 cb 07		                rlc     a 
0f1a 47			                ld      b, a            ; Save upper four bits 
0f1b 7e					ld a,(hl) 
0f1c cd 34 0f		                call    nibble2val      ; Get lower nibble 
0f1f b0			                or      b               ; Combine both nibbles 
0f20 c1			                pop     bc              ; Restore B (and C) 
0f21 c9			                ret 
0f22			; 
0f22			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f22			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f22			; to the serial line interface. The lower 4 bits of A contain the value of  
0f22			; that particular digit. 
0f22			; 
0f22			;get_nibble      ld a,(hl)           ; Read a character 
0f22			;                call    to_upper        ; Convert to upper case 
0f22			;                call    is_hex          ; Was it a hex digit? 
0f22			;                jr      nc, get_nibble  ; No, get another character 
0f22			 ;               call    nibble2val      ; Convert nibble to value 
0f22			 ;               call    print_nibble 
0f22			 ;               ret 
0f22			; 
0f22			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f22			; A valid hexadecimal digit is denoted by a set C flag. 
0f22			; 
0f22			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f22			;                ret     nc              ; Yes 
0f22			;                cp      '0'             ; Less than '0'? 
0f22			;                jr      nc, is_hex_1    ; No, continue 
0f22			;                ccf                     ; Complement carry (i.e. clear it) 
0f22			;                ret 
0f22			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f22			;                ret     c               ; Yes 
0f22			;                cp      'A'             ; Less than 'A'? 
0f22			;                jr      nc, is_hex_2    ; No, continue 
0f22			;                ccf                     ; Yes - clear carry and return 
0f22			;                ret 
0f22			;is_hex_2        scf                     ; Set carry 
0f22			;                ret 
0f22			; 
0f22			; Convert a single character contained in A to upper case: 
0f22			; 
0f22 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f24 d8			                ret     c 
0f25 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f27 d0			                ret     nc              ; Nothing to do, either 
0f28 e6 5f		                and     $5f             ; Convert to upper case 
0f2a c9			                ret 
0f2b			 
0f2b			 
0f2b			to_lower: 
0f2b			 
0f2b			   ; if char is in [A-Z] make it lower case 
0f2b			 
0f2b			   ; enter : a = char 
0f2b			   ; exit  : a = lower case char 
0f2b			   ; uses  : af 
0f2b			 
0f2b fe 41		   cp 'A' 
0f2d d8			   ret c 
0f2e			    
0f2e fe 5b		   cp 'Z'+1 
0f30 d0			   ret nc 
0f31			    
0f31 f6 20		   or $20 
0f33 c9			   ret 
0f34			 
0f34			; 
0f34			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f34			; corresponding value in A. 
0f34			; 
0f34 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f36 38 02		                jr      c, nibble2val_1 ; Yes 
0f38 d6 07		                sub     7               ; Adjust for A-F 
0f3a d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f3c e6 0f		                and     $f              ; Only return lower 4 bits 
0f3e c9			                ret 
0f3f			; 
0f3f			; Print_nibble prints a single hex nibble which is contained in the lower  
0f3f			; four bits of A: 
0f3f			; 
0f3f			;print_nibble    push    af              ; We won't destroy the contents of A 
0f3f			;                and     $f              ; Just in case... 
0f3f			;                add     a, '0'             ; If we have a digit we are done here. 
0f3f			;                cp      '9' + 1         ; Is the result > 9? 
0f3f			;                jr      c, print_nibble_1 
0f3f			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f3f			;print_nibble_1  call    putc            ; Print the nibble and 
0f3f			;                pop     af              ; restore the original value of A 
0f3f			;                ret 
0f3f			;; 
0f3f			;; Send a CR/LF pair: 
0f3f			; 
0f3f			;crlf            push    af 
0f3f			;                ld      a, cr 
0f3f			;                call    putc 
0f3f			;                ld      a, lf 
0f3f			;                call    putc 
0f3f			;                pop     af 
0f3f			;                ret 
0f3f			; 
0f3f			; Print_word prints the four hex digits of a word to the serial line. The  
0f3f			; word is expected to be in HL. 
0f3f			; 
0f3f			;print_word      push    hl 
0f3f			;                push    af 
0f3f			;                ld      a, h 
0f3f			;                call    print_byte 
0f3f			;                ld      a, l 
0f3f			;                call    print_byte 
0f3f			;                pop     af 
0f3f			;                pop     hl 
0f3f			;                ret 
0f3f			; 
0f3f			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f3f			; The byte to be printed is expected to be in A. 
0f3f			; 
0f3f			;print_byte      push    af              ; Save the contents of the registers 
0f3f			;                push    bc 
0f3f			;                ld      b, a 
0f3f			;                rrca 
0f3f			;                rrca 
0f3f			;                rrca 
0f3f			;                rrca 
0f3f			;                call    print_nibble    ; Print high nibble 
0f3f			;                ld      a, b 
0f3f			;                call    print_nibble    ; Print low nibble 
0f3f			;                pop     bc              ; Restore original register contents 
0f3f			;                pop     af 
0f3f			;                ret 
0f3f			 
0f3f			 
0f3f			 
0f3f			 
0f3f			 
0f3f			fourehexhl:  
0f3f 7e				ld a,(hl) 
0f40 cd ee 0e			call atohex 
0f43 cb 3f				SRL A 
0f45 cb 3f				SRL A 
0f47 cb 3f				SRL A 
0f49 cb 3f				SRL A 
0f4b 47				ld b, a 
0f4c 23				inc hl 
0f4d 7e				ld a,(hl) 
0f4e 23				inc hl 
0f4f cd ee 0e			call atohex 
0f52 80				add b 
0f53 57				ld d,a 
0f54 7e				ld a,(hl) 
0f55 cd ee 0e			call atohex 
0f58 cb 3f				SRL A 
0f5a cb 3f				SRL A 
0f5c cb 3f				SRL A 
0f5e cb 3f				SRL A 
0f60 47				ld b, a 
0f61 23				inc hl 
0f62 7e				ld a,(hl) 
0f63 23				inc hl 
0f64 cd ee 0e			call atohex 
0f67 80				add b 
0f68 5f				ld e, a 
0f69 d5				push de 
0f6a e1				pop hl 
0f6b c9				ret 
0f6c			 
0f6c			; pass hl. returns z set if the byte at hl is a digit 
0f6c			;isdigithl:  
0f6c			;	push bc 
0f6c			;	ld a,(hl) 
0f6c			;	cp ':' 
0f6c			;	jr nc, .isdf 		; > 
0f6c			;	cp '0' 
0f6c			;	jr c, .isdf		; < 
0f6c			; 
0f6c			;	; TODO find a better way to set z 
0f6c			; 
0f6c			;	ld b,a 
0f6c			;	cp b 
0f6c			;	pop bc 
0f6c			;	ret 
0f6c			; 
0f6c			;.isdf:	; not digit so clear z 
0f6c			; 
0f6c			;	; TODO find a better way to unset z 
0f6c			; 
0f6c			;	ld b,a 
0f6c			;	inc b 
0f6c			;	cp b 
0f6c			; 
0f6c			;	pop bc 
0f6c			;	ret 
0f6c				 
0f6c				 
0f6c			 
0f6c			 
0f6c			; pass hl as the four byte address to load 
0f6c			 
0f6c			get_word_hl:  
0f6c e5				push hl 
0f6d cd 0c 0f			call get_byte 
0f70				 
0f70 47				ld b, a 
0f71			 
0f71 e1				pop hl 
0f72 23				inc hl 
0f73 23				inc hl 
0f74			 
0f74			; TODO not able to handle a-f  
0f74 7e				ld a,(hl) 
0f75			;	;cp ':' 
0f75			;	cp 'g' 
0f75			;	jr nc, .single_byte_hl 		; > 
0f75			;	cp 'G' 
0f75			;	jr nc, .single_byte_hl 		; > 
0f75			;	cp '0' 
0f75			;	jr c, .single_byte_hl		; < 
0f75			 
0f75				;call isdigithl 
0f75 fe 00			cp 0 
0f77 28 06			jr z, .single_byte_hl 
0f79			 
0f79			.getwhln:   ; hex word so get next byte 
0f79			 
0f79 cd 0c 0f			call get_byte 
0f7c 6f				ld l, a 
0f7d 60				ld h,b 
0f7e c9				ret 
0f7f 68			.single_byte_hl:   ld l,b 
0f80 26 00				ld h,0 
0f82 c9					ret 
0f83			 
0f83			 
0f83			 
0f83			 
0f83 21 cc 16			ld hl,asc+1 
0f86			;	ld a, (hl) 
0f86			;	call nibble2val 
0f86 cd 0c 0f			call get_byte 
0f89			 
0f89			;	call fourehexhl 
0f89 32 94 e3			ld (scratch+52),a 
0f8c				 
0f8c 21 92 e3			ld hl,scratch+50 
0f8f 22 83 e6			ld (os_cur_ptr),hl 
0f92			 
0f92 c9				ret 
0f93			 
0f93			 
0f93			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0f93			 
0f93			; Decimal Unsigned Version 
0f93			 
0f93			;Number in a to decimal ASCII 
0f93			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0f93			;Example: display a=56 as "056" 
0f93			;input: a = number 
0f93			;Output: a=0,value of a in the screen 
0f93			;destroys af,bc (don't know about hl and de) 
0f93			DispAToASCII: 
0f93 0e 9c			ld	c,-100 
0f95 cd 9f 0f			call	.Na1 
0f98 0e f6			ld	c,-10 
0f9a cd 9f 0f			call	.Na1 
0f9d 0e ff			ld	c,-1 
0f9f 06 2f		.Na1:	ld	b,'0'-1 
0fa1 04			.Na2:	inc	b 
0fa2 81				add	a,c 
0fa3 38 fc			jr	c,.Na2 
0fa5 91				sub	c		;works as add 100/10/1 
0fa6 f5				push af		;safer than ld c,a 
0fa7 78				ld	a,b		;char is in b 
0fa8			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0fa8 f1				pop af		;safer than ld a,c 
0fa9 c9				ret 
0faa			 
0faa			; Decimal Signed Version 
0faa			 
0faa			; DispA 
0faa			; -------------------------------------------------------------- 
0faa			; Converts a signed integer value to a zero-terminated ASCII 
0faa			; string representative of that value (using radix 10). 
0faa			; -------------------------------------------------------------- 
0faa			; INPUTS: 
0faa			;     HL     Value to convert (two's complement integer). 
0faa			;     DE     Base address of string destination. (pointer). 
0faa			; -------------------------------------------------------------- 
0faa			; OUTPUTS: 
0faa			;     None 
0faa			; -------------------------------------------------------------- 
0faa			; REGISTERS/MEMORY DESTROYED 
0faa			; AF HL 
0faa			; -------------------------------------------------------------- 
0faa			 
0faa			;DispHLToASCII: 
0faa			;   push    de 
0faa			;   push    bc 
0faa			; 
0faa			;; Detect sign of HL. 
0faa			;    bit    7, h 
0faa			;    jr     z, ._DoConvert 
0faa			; 
0faa			;; HL is negative. Output '-' to string and negate HL. 
0faa			;    ld     a, '-' 
0faa			;    ld     (de), a 
0faa			;    inc    de 
0faa			; 
0faa			;; Negate HL (using two's complement) 
0faa			;    xor    a 
0faa			;    sub    l 
0faa			;    ld     l, a 
0faa			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0faa			;    sbc    a, h 
0faa			;    ld     h, a 
0faa			; 
0faa			;; Convert HL to digit characters 
0faa			;._DoConvert: 
0faa			;    ld     b, 0     ; B will count character length of number 
0faa			;-   ld     a, 10 
0faa			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0faa			;    push   af 
0faa			;    inc    b 
0faa			;    ld     a, h 
0faa			;    or     l 
0faa			;    jr     nz, - 
0faa			; 
0faa			;; Retrieve digits from stack 
0faa			;-   pop    af 
0faa			;    or     $30 
0faa			;    ld     (de), a 
0faa			;    inc    de 
0faa			;    djnz   - 
0faa			; 
0faa			;; Terminate string with NULL 
0faa			;    xor    a 
0faa			;    ld     (de), a 
0faa			; 
0faa			;    pop    bc 
0faa			;    pop    de 
0faa			;    ret 
0faa			 
0faa			;Comments 
0faa			; 
0faa			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0faa			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0faa			;    Note that the output string will not be fixed-width. 
0faa			; 
0faa			;Example Usage 
0faa			; 
0faa			;    ld    hl, -1004 
0faa			;    ld    de, OP1 
0faa			;    call  DispA 
0faa			;    ld    hl, OP1 
0faa			;    syscall  PutS 
0faa			 
0faa			 
0faa			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0faa			 
0faa			 
0faa			;Converts an ASCII string to an unsigned 16-bit integer 
0faa			;Quits when it reaches a non-decimal digit 
0faa			 
0faa			string_to_uint16: 
0faa			atoui_16: 
0faa			;Input: 
0faa			;     DE points to the string 
0faa			;Outputs: 
0faa			;     HL is the result 
0faa			;     A is the 8-bit value of the number 
0faa			;     DE points to the byte after the number 
0faa			;Destroys: 
0faa			;     BC 
0faa			;       if the string is non-empty, BC is HL/10 
0faa			;Size:  24 bytes 
0faa			;Speed: 42+d(104+{0,9}) 
0faa			;       d is the number of digits in the number 
0faa			;       max is 640 cycles for a 5 digit number 
0faa			;Assuming no leading zeros: 
0faa			;1 digit:  146cc 
0faa			;2 digit:  250cc 
0faa			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0faa			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0faa			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0faa			;avg: 544.81158447265625cc (544+13297/16384) 
0faa			;=============================================================== 
0faa 21 00 00		  ld hl,0 
0fad			.u16a: 
0fad 1a			  ld a,(de) 
0fae d6 30		  sub 30h 
0fb0 fe 0a		  cp 10 
0fb2 d0			  ret nc 
0fb3 13			  inc de 
0fb4 44			  ld b,h 
0fb5 4d			  ld c,l 
0fb6 29			  add hl,hl 
0fb7 29			  add hl,hl 
0fb8 09			  add hl,bc 
0fb9 29			  add hl,hl 
0fba 85			  add a,l 
0fbb 6f			  ld l,a 
0fbc 30 ef		  jr nc,.u16a 
0fbe 24			  inc h 
0fbf c3 ad 0f		  jp .u16a 
0fc2			 
0fc2			 
0fc2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fc2			 
0fc2			;written by Zeda 
0fc2			;Converts a 16-bit unsigned integer to an ASCII string. 
0fc2			 
0fc2			uitoa_16: 
0fc2			;Input: 
0fc2			;   DE is the number to convert 
0fc2			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0fc2			;Output: 
0fc2			;   HL points to the null-terminated ASCII string 
0fc2			;      NOTE: This isn't necessarily the same as the input HL. 
0fc2 d5			  push de 
0fc3 c5			  push bc 
0fc4 f5			  push af 
0fc5 eb			  ex de,hl 
0fc6			 
0fc6 01 f0 d8		  ld bc,-10000 
0fc9 3e 2f		  ld a,'0'-1 
0fcb 3c			  inc a 
0fcc 09			  add hl,bc  
0fcd 38 fc		   jr c,$-2 
0fcf 12			  ld (de),a 
0fd0 13			  inc de 
0fd1			 
0fd1 01 e8 03		  ld bc,1000 
0fd4 3e 3a		  ld a,'9'+1 
0fd6 3d			  dec a  
0fd7 09			  add hl,bc  
0fd8 30 fc		   jr nc,$-2 
0fda 12			  ld (de),a 
0fdb 13			  inc de 
0fdc			 
0fdc 01 9c ff		  ld bc,-100 
0fdf 3e 2f		  ld a,'0'-1 
0fe1 3c			  inc a  
0fe2 09			  add hl,bc  
0fe3 38 fc		   jr c,$-2 
0fe5 12			  ld (de),a 
0fe6 13			  inc de 
0fe7			 
0fe7 7d			  ld a,l 
0fe8 26 3a		  ld h,'9'+1 
0fea 25			  dec h  
0feb c6 0a		  add a,10  
0fed 30 fb		   jr nc,$-3 
0fef c6 30		  add a,'0' 
0ff1 eb			  ex de,hl 
0ff2 72			  ld (hl),d 
0ff3 23			  inc hl 
0ff4 77			  ld (hl),a 
0ff5 23			  inc hl 
0ff6 36 00		  ld (hl),0 
0ff8			 
0ff8			;Now strip the leading zeros 
0ff8 0e fa		  ld c,-6 
0ffa 09			  add hl,bc 
0ffb 3e 30		  ld a,'0' 
0ffd 23			  inc hl  
0ffe be			  cp (hl)  
0fff 28 fc		  jr z,$-2 
1001			 
1001			;Make sure that the string is non-empty! 
1001 7e			  ld a,(hl) 
1002 b7			  or a 
1003 20 01		  jr nz,.atoub 
1005 2b			  dec hl 
1006			.atoub: 
1006			 
1006 f1			  pop af 
1007 c1			  pop bc 
1008 d1			  pop de 
1009 c9			  ret 
100a			 
100a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
100a			 
100a			toUpper: 
100a			;A is the char. 
100a			;If A is a lowercase letter, this sets it to the matching uppercase 
100a			;18cc or 30cc or 41cc 
100a			;avg: 26.75cc 
100a fe 61		  cp 'a' 
100c d8			  ret c 
100d fe 7b		  cp 'z'+1 
100f d0			  ret nc 
1010 d6 20		  sub 'a'-'A' 
1012 c9			  ret 
1013			 
1013			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1013			 
1013			; String Length 
1013			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1013			 
1013			; Get the length of the null-terminated string starting at $8000 hl 
1013			;    LD     HL, $8000 
1013			 
1013			strlenz: 
1013			 
1013 af			    XOR    A               ; Zero is the value we are looking for. 
1014 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1015 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1016			                           ; 65, 536 bytes (the entire addressable memory space). 
1016 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1018			 
1018			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1018 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1019 6f			    LD     L, A             ; number of bytes 
101a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
101c 2b			    DEC    HL              ; Compensate for null. 
101d c9				ret 
101e			 
101e			; Get the length of the A terminated string starting at $8000 hl 
101e			;    LD     HL, $8000 
101e			 
101e			strlent: 
101e			 
101e			                  ; A is the value we are looking for. 
101e 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1020 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1022			                           ; 65, 536 bytes (the entire addressable memory space). 
1022 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1024			 
1024			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1024 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1026 2e 00		    LD     L, 0             ; number of bytes 
1028 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
102a 2b			    DEC    HL              ; Compensate for null. 
102b c9				ret 
102c			 
102c			 
102c			;Comparing Strings 
102c			 
102c			;IN    HL     Address of string1. 
102c			;      DE     Address of string2. 
102c			 
102c			; doc given but wrong??? 
102c			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
102c			;      carry  Set if string1 > string2, reset if string1 <= string2. 
102c			; tested 
102c			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
102c			 
102c			strcmp_old: 
102c e5			    PUSH   HL 
102d d5			    PUSH   DE 
102e			 
102e 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
102f be			    CP     (HL)            ; (want to minimize work). 
1030 38 01		    JR     C, Str1IsBigger 
1032 7e			    LD     A, (HL) 
1033			 
1033			Str1IsBigger: 
1033 4f			    LD     C, A             ; Put length in BC 
1034 06 00		    LD     B, 0 
1036 13			    INC    DE              ; Increment pointers to meat of string. 
1037 23			    INC    HL 
1038			 
1038			CmpLoop: 
1038 1a			    LD     A, (DE)          ; Compare bytes. 
1039 ed a1		    CPI 
103b 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
103d 13			    INC    DE              ; Update pointer. 
103e ea 38 10		    JP     PE, CmpLoop 
1041			 
1041 d1			    POP    DE 
1042 e1			    POP    HL 
1043 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1044 be			    CP     (HL) 
1045 c9			    RET 
1046			 
1046			NoMatch: 
1046 2b			    DEC    HL 
1047 be			    CP     (HL)            ; Compare again to affect carry. 
1048 d1			    POP    DE 
1049 e1			    POP    HL 
104a c9			    RET 
104b			 
104b			;; test strmp 
104b			; 
104b			;ld de, .str1 
104b			;ld hl, .str2 
104b			;call strcmp 
104b			;jr z, .z1 
104b			;;this 
104b			;	if DEBUG_FORTH_WORDS 
104b			;		DMARK "NZ1" 
104b			;		CALLMONITOR 
104b			;	endif 
104b			;.z1: 
104b			; 
104b			;	if DEBUG_FORTH_WORDS 
104b			;		DMARK "ZZ1" 
104b			;		CALLMONITOR 
104b			;	endif 
104b			; 
104b			;ld de, .str1 
104b			;ld hl, .str1 
104b			;call strcmp 
104b			;jr z, .z2 
104b			;;this 
104b			;	if DEBUG_FORTH_WORDS 
104b			;		DMARK "NZ2" 
104b			;		CALLMONITOR 
104b			;	endif 
104b			;.z2: 
104b			; 
104b			;	if DEBUG_FORTH_WORDS 
104b			;		DMARK "ZZ2" 
104b			;		CALLMONITOR 
104b			;	endif 
104b			; 
104b			;ld de, .str1 
104b			;ld hl, .str2 
104b			;call strcmp 
104b			;jr c, .c1 
104b			; 
104b			;	if DEBUG_FORTH_WORDS 
104b			;		DMARK "Nc1" 
104b			;		CALLMONITOR 
104b			;	endif 
104b			;.c1: 
104b			;;this 
104b			;	if DEBUG_FORTH_WORDS 
104b			;		DMARK "cc1" 
104b			;		CALLMONITOR 
104b			;	endif 
104b			; 
104b			;ld de, .str1 
104b			;ld hl, .str1 
104b			;call strcmp 
104b			;jr c, .c2 
104b			;;this 
104b			;	if DEBUG_FORTH_WORDS 
104b			;		DMARK "Nc2" 
104b			;		CALLMONITOR 
104b			;	endif 
104b			;.c2: 
104b			; 
104b			;	if DEBUG_FORTH_WORDS 
104b			;		DMARK "cc2" 
104b			;		CALLMONITOR 
104b			;	endif 
104b			;	NEXTW 
104b			;.str1:   db "string1",0 
104b			;.str2:   db "string2",0 
104b			 
104b			; only care about direct match or not 
104b			; hl and de strings 
104b			; zero set if the same 
104b			 
104b			strcmp: 
104b 1a				ld a, (de) 
104c be				cp (hl) 
104d 28 02			jr z, .ssame 
104f b7				or a 
1050 c9				ret 
1051			 
1051			.ssame:  
1051 fe 00			cp 0 
1053 c8				ret z 
1054			 
1054 23				inc hl 
1055 13				inc de 
1056 18 f3			jr strcmp 
1058				 
1058				 
1058			 
1058			 
1058			 
1058			 
1058			; eof 
1058			 
1058			 
1058			 
1058			 
1058			 
1058			 
# End of file firmware_strings.asm
1058			include "firmware_memory.asm"   ; malloc and free  
1058			 
1058			if DEBUG_FORTH_MALLOC_HIGH 
1058			.mallocsize: db "Wants malloc >256",0 
1058			.mallocasize: db "MALLOC gives >256",0 
1058			.malloczero: db "MALLOC gives zero",0 
1058			 
1058			malloc_guard_zerolen: 
1058				push hl 
1058				push de 
1058				push af 
1058			 
1058				ld de, 0 
1058			        call cmp16 
1058				jr nz, .lowalloz 
1058			 
1058				push hl 
1058				push de 
1058					ld hl, display_fb0 
1058					ld (display_fb_active), hl 
1058				call clear_display 
1058				ld a, 0 
1058				ld de, .malloczero 
1058				call str_at_display 
1058				call update_display 
1058				call delay1s 
1058				call delay1s 
1058				ld a, 0 
1058				ld (os_view_disable), a 
1058			 
1058				pop de 
1058				pop hl 
1058			 
1058				 
1058			 
1058				CALLMONITOR 
1058			.lowalloz: 
1058			 
1058			 
1058				pop af 
1058				pop de 
1058				pop hl 
1058			ret 
1058			 
1058			malloc_guard_entry: 
1058				push hl 
1058				push de 
1058				push af 
1058			 
1058			 	or a      ;clear carry flag 
1058				push hl 
1058				ld de, 255 
1058				sbc hl, de 
1058				jr c, .lowalloc 
1058			 
1058				push de 
1058					ld hl, display_fb0 
1058					ld (display_fb_active), hl 
1058				call clear_display 
1058				ld a, 0 
1058				ld de, .mallocsize 
1058				call str_at_display 
1058				call update_display 
1058				call delay1s 
1058				call delay1s 
1058				ld a, 0 
1058				ld (os_view_disable), a 
1058			 
1058				pop de 
1058				pop hl 
1058			 
1058				 
1058			 
1058				CALLMONITOR 
1058				jr .lowdone 
1058			.lowalloc: 
1058			 
1058			 
1058				pop hl 
1058			.lowdone:	pop af 
1058				pop de 
1058				pop hl 
1058			ret 
1058			 
1058			malloc_guard_exit: 
1058				push hl 
1058				push de 
1058				push af 
1058			 
1058			 	or a      ;clear carry flag 
1058				push hl 
1058				ld de, 255 
1058				sbc hl, de 
1058				jr c, .lowallocx 
1058			 
1058				push de 
1058					ld hl, display_fb0 
1058					ld (display_fb_active), hl 
1058				call clear_display 
1058				ld a, 0 
1058				ld de, .mallocasize 
1058				call str_at_display 
1058				call update_display 
1058				call delay1s 
1058				call delay1s 
1058				ld a, 0 
1058				ld (os_view_disable), a 
1058				pop de 
1058				pop hl 
1058			 
1058				CALLMONITOR 
1058				jr .lowdonex 
1058			.lowallocx: 
1058			 
1058				pop hl 
1058			.lowdonex:	pop af 
1058				pop de 
1058				pop hl 
1058			ret 
1058			endif 
1058			 
1058			if MALLOC_2 
1058			; Z80 Malloc and Free Functions 
1058			 
1058			; Malloc Function: 
1058			; Input: 
1058			;   HL: Size of block to allocate 
1058			; Output: 
1058			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1058			 
1058			malloc: 
1058				 
1058			if DEBUG_FORTH_MALLOC_HIGH 
1058			call malloc_guard_entry 
1058			endif 
1058			 
1058			 
1058			 
1058			 
1058					if DEBUG_FORTH_MALLOC 
1058						DMARK "mal" 
1058						CALLMONITOR 
1058					endif 
1058			    push af            ; Save AF register 
1058			    ld a, l            ; Load low byte of size into A 
1058			    or h               ; Check if size is zero 
1058			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1058			 
1058			    ; Allocate memory 
1058			    ld hl, (heap_start) ; Load start of heap into HL 
1058					if DEBUG_FORTH_MALLOC 
1058						DMARK "ma1" 
1058						CALLMONITOR 
1058					endif 
1058			    call malloc_internal ; Call internal malloc function 
1058			    pop af             ; Restore AF register 
1058			if DEBUG_FORTH_MALLOC_HIGH 
1058			call malloc_guard_exit 
1058			call malloc_guard_zerolen 
1058			endif 
1058			    ret                ; Return 
1058			 
1058			; Free Function: 
1058			; Input: 
1058			;   HL: Pointer to memory block to free 
1058			; Output: 
1058			;   None 
1058			 
1058			free: 
1058			    push af            ; Save AF register 
1058			    ld a, l            ; Load low byte of pointer into A 
1058			    or h               ; Check if pointer is NULL 
1058			    jp z, free_exit    ; If pointer is NULL, exit 
1058			 
1058			    ; Free memory 
1058			    ld hl, (heap_start) ; Load start of heap into HL 
1058			    call free_internal  ; Call internal free function 
1058			    pop af             ; Restore AF register 
1058			    ret                ; Return 
1058			 
1058			; Internal Malloc Function: 
1058			; Input: 
1058			;   HL: Size of block to allocate 
1058			; Output: 
1058			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1058			 
1058			malloc_internal: 
1058			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1058			    add hl, bc         ; Add management overhead to requested size 
1058			    ex de, hl          ; Save total size in DE, and keep it in HL 
1058					if DEBUG_FORTH_MALLOC 
1058						DMARK "ma2" 
1058						CALLMONITOR 
1058					endif 
1058			 
1058			    ; Search for free memory block 
1058			    ld de, (heap_end)  ; Load end of heap into DE 
1058			    ld bc, 0           ; Initialize counter 
1058			 
1058					if DEBUG_FORTH_MALLOC 
1058						DMARK "ma2" 
1058						CALLMONITOR 
1058					endif 
1058			malloc_search_loop: 
1058			    ; Check if current block is free 
1058			    ld a, (hl)         ; Load current block's status (free or used) 
1058			    cp 0               ; Compare with zero (free) 
1058			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1058			 
1058			    ; Check if current block is large enough 
1058			    ld a, (hl+1)       ; Load high byte of block size 
1058			    cp l               ; Compare with low byte of requested size 
1058			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1058			 
1058			    ld a, (hl+2)       ; Load low byte of block size 
1058			    cp h               ; Compare with high byte of requested size 
1058			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1058			 
1058			    ; Mark block as used 
1058			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1058			 
1058			    ; Calculate remaining space in block 
1058			    ld bc, 0           ; Clear BC 
1058			    add hl, bc         ; Increment HL to point to start of data block 
1058			    add hl, de         ; HL = HL + DE (total size) 
1058			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1058			    add hl, bc         ; Add management overhead to start of data block 
1058			 
1058			    ; Save pointer to allocated block in HL 
1058			if DEBUG_FORTH_MALLOC_HIGH 
1058						DMARK "ma5" 
1058			call malloc_guard_exit 
1058			call malloc_guard_zerolen 
1058			endif 
1058			    ret 
1058			 
1058			malloc_skip_block_check: 
1058			    ; Move to the next block 
1058			    ld bc, 3           ; Size of management overhead 
1058			    add hl, bc         ; Move to the next block 
1058			    inc de             ; Increment counter 
1058			 
1058			    ; Check if we have reached the end of heap 
1058			    ld a, e            ; Load low byte of heap end address 
1058			    cp (hl)            ; Compare with low byte of current address 
1058			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1058			    ld a, d            ; Load high byte of heap end address 
1058			    cp 0               ; Check if it's zero (end of memory) 
1058			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1058			 
1058			    ; If we reached here, allocation failed 
1058			    xor a              ; Set result to NULL 
1058			if DEBUG_FORTH_MALLOC_HIGH 
1058						DMARK "ma6" 
1058			call malloc_guard_exit 
1058			call malloc_guard_zerolen 
1058			endif 
1058			    ret 
1058			malloc_exit: 
1058			if DEBUG_FORTH_MALLOC_HIGH 
1058						DMARK "ma7" 
1058			call malloc_guard_exit 
1058			call malloc_guard_zerolen 
1058			endif 
1058			    ret 
1058			 
1058			; Internal Free Function: 
1058			; Input: 
1058			;   HL: Pointer to memory block to free 
1058			; Output: 
1058			;   None 
1058			 
1058			free_internal: 
1058			    ld de, (heap_start) ; Load start of heap into DE 
1058			    ld bc, 0            ; Initialize counter 
1058			 
1058			free_search_loop: 
1058			    ; Check if current block contains the pointer 
1058			    ld a, l             ; Load low byte of pointer 
1058			    cp (hl+1)           ; Compare with high byte of current block's address 
1058			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1058			    ld a, h             ; Load high byte of pointer 
1058			    cp (hl+2)           ; Compare with low byte of current block's address 
1058			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1058			 
1058			    ; Mark block as free 
1058			    ld (hl), 0          ; Set status byte to indicate free block 
1058			    ret                 ; Return 
1058			 
1058			free_skip_block_check: 
1058			    ; Move to the next block 
1058			    ld bc, 3            ; Size of management overhead 
1058			    add hl, bc          ; Move to the next block 
1058			    inc de              ; Increment counter 
1058			 
1058			    ; Check if we have reached the end of heap 
1058			    ld a, e             ; Load low byte of heap end address 
1058			    cp (hl)             ; Compare with low byte of current address 
1058			    jr nz, free_search_loop  ; If not equal, continue searching 
1058			    ld a, d             ; Load high byte of heap end address 
1058			    cp 0                ; Check if it's zero (end of memory) 
1058			    jr nz, free_search_loop  ; If not zero, continue searching 
1058			 
1058			    ; If we reached here, pointer is not found in heap 
1058			    ret 
1058			 
1058			free_exit: 
1058			    ret                 ; Return 
1058			 
1058			; Define heap start and end addresses 
1058			;heap_start:    .dw 0xC000   ; Start of heap 
1058			;heap_end:      .dw 0xE000   ; End of heap 
1058			 
1058			endif 
1058			 
1058			 
1058			if MALLOC_1 
1058			 
1058			 
1058			 
1058			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1058			 
1058			;moved to firmware.asm 
1058			;heap_start        .equ  0x9000      ; Starting address of heap 
1058			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1058			 
1058			;      .org 0 
1058			;      jp    main 
1058			 
1058			 
1058			;      .org  0x100 
1058			;main: 
1058			;      ld    HL, 0x8100 
1058			;      ld    SP, HL 
1058			; 
1058			;      call  heap_init 
1058			; 
1058			;      ; Make some allocations 
1058			;      ld    HL, 12 
1058			;      call  malloc            ; Allocates 0x9004 
1058			; 
1058			;      ld    HL, 12 
1058			;      call  malloc            ; Allocates 0x9014 
1058			; 
1058			;      ld    HL, 12 
1058			;      call  malloc            ; Allocates 0x9024 
1058			; 
1058			;      ; Free some allocations 
1058			;      ld    HL, 0x9014 
1058			;      call  free 
1058			; 
1058			;      ld    HL, 0x9004 
1058			;      call  free 
1058			; 
1058			;      ld    HL, 0x9024 
1058			;      call  free 
1058			; 
1058			; 
1058			;      halt 
1058			 
1058			 
1058			;------------------------------------------------------------------------------ 
1058			;     heap_init                                                               : 
1058			;                                                                             : 
1058			; Description                                                                 : 
1058			;     Initialise the heap and make it ready for malloc and free operations.   : 
1058			;                                                                             : 
1058			;     The heap is maintained as a linked list, starting with an initial       : 
1058			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1058			;     the first free block in the heap. Each block then points to the next    : 
1058			;     free block within the heap, and the free list ends at the first block   : 
1058			;     with a null pointer to the next free block.                             : 
1058			;                                                                             : 
1058			; Parameters                                                                  : 
1058			;     Inputs are compile-time only. Two defines which specify the starting    : 
1058			;     address of the heap and its size are required, along with a memory      : 
1058			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1058			;     principally stores a pointer to the first free block in the heap.       : 
1058			;                                                                             : 
1058			; Returns                                                                     : 
1058			;     Nothing                                                                 : 
1058			;------------------------------------------------------------------------------ 
1058			heap_init: 
1058 e5			      push  HL 
1059			 
1059			      ; Initialise free list struct 
1059 21 a1 58		      ld    HL, heap_start 
105c 22 9c 58		      ld    (free_list), HL 
105f 21 00 00		      ld    HL, 0 
1062 22 9e 58		      ld    (free_list+2), HL 
1065			 
1065			      ; Insert first free block at bottom of heap, consumes entire heap 
1065 21 42 e3		      ld    HL, heap_start+heap_size-4 
1068 22 a1 58		      ld    (heap_start), HL        ; Next block (end of free list) 
106b 21 a1 8a		      ld    HL, heap_size-4 
106e 22 a3 58		      ld    (heap_start+2), HL      ; Block size 
1071			 
1071			      ; Insert end of free list block at top of heap - two null words will 
1071			      ; terminate the free list 
1071 21 00 00		      ld    HL, 0 
1074 22 44 e3		      ld    (heap_start+heap_size-2), HL 
1077 22 42 e3		      ld    (heap_start+heap_size-4), HL 
107a			 
107a e1			      pop   HL 
107b			 
107b c9			      ret 
107c			 
107c			 
107c			;------------------------------------------------------------------------------ 
107c			;     malloc                                                                  : 
107c			;                                                                             : 
107c			; Description                                                                 : 
107c			;     Allocates the wanted space from the heap and returns the address of the : 
107c			;     first useable byte of the allocation.                                   : 
107c			;                                                                             : 
107c			;     Allocations can happen in one of two ways:                              : 
107c			;                                                                             : 
107c			;     1. A free block may be found which is the exact size wanted. In this    : 
107c			;        case the block is removed from the free list and retuedn to the      : 
107c			;        caller.                                                              : 
107c			;     2. A free block may be found which is larger than the size wanted. In   : 
107c			;        this case, the larger block is split into two. The first portion of  : 
107c			;        this block will become the requested space by the malloc call and    : 
107c			;        is returned to the caller. The second portion becomes a new free     : 
107c			;        block, and the free list is adjusted to maintain continuity via this : 
107c			;        newly created block.                                                 : 
107c			;                                                                             : 
107c			;     malloc does not set any initial value in the allocated space, the       : 
107c			;     caller is required to do this as required.                              : 
107c			;                                                                             : 
107c			;     This implementation of malloc uses the stack exclusively, and is        : 
107c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
107c			;     advisable to disable interrupts before calling malloc, and recommended  : 
107c			;     to avoid the use of malloc inside ISRs in general.                      : 
107c			;                                                                             : 
107c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
107c			;                                                                             : 
107c			; Parameters                                                                  : 
107c			;     HL  Number of bytes wanted                                              : 
107c			;                                                                             : 
107c			; Returns                                                                     : 
107c			;     HL  Address of the first useable byte of the allocation                 : 
107c			;                                                                             : 
107c			; Flags                                                                       : 
107c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
107c			;                                                                             : 
107c			; Stack frame                                                                 : 
107c			;       |             |                                                       : 
107c			;       +-------------+                                                       : 
107c			;       |     BC      |                                                       : 
107c			;       +-------------+                                                       : 
107c			;       |     DE      |                                                       : 
107c			;       +-------------+                                                       : 
107c			;       |     IX      |                                                       : 
107c			;       +-------------+                                                       : 
107c			;       |  prev_free  |                                                       : 
107c			;   +4  +-------------+                                                       : 
107c			;       |  this_free  |                                                       : 
107c			;   +2  +-------------+                                                       : 
107c			;       |  next_free  |                                                       : 
107c			;   +0  +-------------+                                                       : 
107c			;       |             |                                                       : 
107c			;                                                                             : 
107c			;------------------------------------------------------------------------------ 
107c			 
107c			 
107c			;malloc: 
107c			; 
107c			;	SAVESP ON 1 
107c			; 
107c			;	call malloc_code 
107c			; 
107c			;	CHECKSP ON 1 
107c			;	ret 
107c			 
107c			 
107c			malloc: 
107c c5			      push  BC 
107d d5			      push  DE 
107e dd e5		      push  IX 
1080			if DEBUG_FORTH_MALLOC_HIGH 
1080			call malloc_guard_entry 
1080			endif 
1080			 
1080					if DEBUG_FORTH_MALLOC 
1080						DMARK "mal" 
1080						CALLMONITOR 
1080					endif 
1080 7c			      ld    A, H                    ; Exit if no space requested 
1081 b5			      or    L 
1082 ca 41 11		      jp    Z, malloc_early_exit 
1085			 
1085			;inc hl 
1085			;inc hl 
1085			;inc hl 
1085			; 
1085			;inc hl 
1085			;inc hl 
1085			;inc hl 
1085			;inc hl 
1085			;inc hl 
1085			;inc hl 
1085			;inc hl 
1085			;inc hl 
1085			;inc hl 
1085			 
1085			 
1085			 
1085			 
1085					if DEBUG_FORTH_MALLOC 
1085						DMARK "maA" 
1085						CALLMONITOR 
1085					endif 
1085			      ; Set up stack frame 
1085 eb			      ex    DE, HL 
1086 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1089 39			      add   HL, SP 
108a f9			      ld    SP, HL 
108b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
108f dd 39		      add   IX, SP 
1091			 
1091			      ; Setup initial state 
1091 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1094 19			      add   HL, DE 
1095			 
1095 44			      ld    B, H                    ; Move want to BC 
1096 4d			      ld    C, L 
1097			 
1097 21 9c 58		      ld    HL, free_list           ; Store prev_free ptr to stack 
109a dd 75 04		      ld    (IX+4), L 
109d dd 74 05		      ld    (IX+5), H 
10a0			 
10a0 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
10a1 23			      inc   HL 
10a2 56			      ld    D, (HL) 
10a3 dd 73 02		      ld    (IX+2), E 
10a6 dd 72 03		      ld    (IX+3), D 
10a9 eb			      ex    DE, HL                  ; this_free ptr into HL 
10aa			 
10aa					if DEBUG_FORTH_MALLOC 
10aa						DMARK "maB" 
10aa						CALLMONITOR 
10aa					endif 
10aa			      ; Loop through free block list to find some space 
10aa			malloc_find_space: 
10aa 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
10ab 23			      inc   HL 
10ac 56			      ld    D, (HL) 
10ad			 
10ad 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
10ae b3			      or    E 
10af ca 3b 11		      jp    Z, malloc_no_space 
10b2			 
10b2 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
10b5 dd 72 01		      ld    (IX+1), D 
10b8			 
10b8			      ; Does this block have enough space to make the allocation? 
10b8 23			      inc   HL                      ; Load free block size into DE 
10b9 5e			      ld    E, (HL) 
10ba 23			      inc   HL 
10bb 56			      ld    D, (HL) 
10bc			 
10bc eb			      ex    DE, HL                  ; Check size of block against want 
10bd b7			      or    A                       ; Ensure carry flag clear 
10be ed 42		      sbc   HL, BC 
10c0 e5			      push  HL                      ; Store the result for later (new block size) 
10c1			 
10c1 ca 10 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
10c4 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
10c6			 
10c6			      ; this_free block is not big enough, setup ptrs to test next free block 
10c6 e1			      pop   HL                      ; Discard previous result 
10c7			 
10c7 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
10ca dd 66 03		      ld    H, (IX+3) 
10cd dd 75 04		      ld    (IX+4), L 
10d0 dd 74 05		      ld    (IX+5), H 
10d3			 
10d3 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
10d6 dd 66 01		      ld    H, (IX+1) 
10d9 dd 75 02		      ld    (IX+2), L 
10dc dd 74 03		      ld    (IX+3), H 
10df			 
10df					if DEBUG_FORTH_MALLOC 
10df						DMARK "MA>" 
10df						CALLMONITOR 
10df					endif 
10df 18 c9		      jr    malloc_find_space 
10e1			 
10e1			      ; split a bigger block into two - requested size and remaining size 
10e1			malloc_alloc_split: 
10e1					if DEBUG_FORTH_MALLOC 
10e1						DMARK "MAs" 
10e1						CALLMONITOR 
10e1					endif 
10e1 eb			      ex    DE, HL                  ; Calculate address of new free block 
10e2 2b			      dec   HL 
10e3 2b			      dec   HL 
10e4 2b			      dec   HL 
10e5 09			      add   HL, BC 
10e6			 
10e6			      ; Create a new block and point it at next_free 
10e6 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
10e9 dd 56 01		      ld    D, (IX+1) 
10ec			 
10ec 73			      ld    (HL), E                 ; Store next_free ptr into new block 
10ed 23			      inc   HL 
10ee 72			      ld    (HL), D 
10ef			 
10ef d1			      pop   DE                      ; Store size of new block into new block 
10f0 23			      inc   HL 
10f1 73			      ld    (HL), E 
10f2 23			      inc   HL 
10f3 72			      ld    (HL), D 
10f4			 
10f4			      ; Update this_free ptr to point to new block 
10f4 2b			      dec   HL 
10f5 2b			      dec   HL 
10f6 2b			      dec   HL 
10f7			 
10f7 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
10fa dd 56 03		      ld    D, (IX+3) 
10fd			 
10fd dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1100 dd 74 03		      ld    (IX+3), H 
1103			 
1103			      ; Modify this_free block to be allocation 
1103 eb			      ex    DE, HL 
1104 af			      xor   A                       ; Null the next block ptr of allocated block 
1105 77			      ld    (HL), A 
1106 23			      inc   HL 
1107 77			      ld    (HL), A 
1108			 
1108 23			      inc   HL                      ; Store want size into allocated block 
1109 71			      ld    (HL), C 
110a 23			      inc   HL 
110b 70			      ld    (HL), B 
110c 23			      inc   HL 
110d e5			      push  HL                      ; Address of allocation to return 
110e			 
110e 18 19		      jr    malloc_update_links 
1110			 
1110			malloc_alloc_fit: 
1110 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1111			 
1111					if DEBUG_FORTH_MALLOC 
1111						DMARK "MAf" 
1111						CALLMONITOR 
1111					endif 
1111			      ; Modify this_free block to be allocation 
1111 eb			      ex    DE, HL 
1112 2b			      dec   HL 
1113 2b			      dec   HL 
1114 2b			      dec   HL 
1115			 
1115 af			      xor   A                       ; Null the next block ptr of allocated block 
1116 77			      ld    (HL), A 
1117 23			      inc   HL 
1118 77			      ld    (HL), A 
1119			 
1119 23			      inc   HL                      ; Store address of allocation to return 
111a 23			      inc   HL 
111b 23			      inc   HL 
111c e5			      push  HL 
111d			 
111d			      ; Copy next_free ptr to this_free, remove allocated block from free list 
111d dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1120 dd 66 01		      ld    H, (IX+1) 
1123			 
1123 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1126 dd 74 03		      ld    (IX+3), H 
1129			 
1129			 
1129			malloc_update_links: 
1129			      ; Update prev_free ptr to point to this_free 
1129 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
112c dd 66 05		      ld    H, (IX+5) 
112f			 
112f dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1132 dd 56 03		      ld    D, (IX+3) 
1135			 
1135 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1136 23			      inc   HL 
1137 72			      ld    (HL), D 
1138			 
1138					if DEBUG_FORTH_MALLOC 
1138						DMARK "Mul" 
1138						CALLMONITOR 
1138					endif 
1138			      ; Clear the Z flag to indicate successful allocation 
1138 7a			      ld    A, D 
1139 b3			      or    E 
113a			 
113a d1			      pop   DE                      ; Address of allocation 
113b					if DEBUG_FORTH_MALLOC 
113b						DMARK "MAu" 
113b						CALLMONITOR 
113b					endif 
113b			 
113b			malloc_no_space: 
113b 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
113e 39			      add   HL, SP 
113f f9			      ld    SP, HL 
1140			 
1140 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1141					if DEBUG_FORTH_MALLOC 
1141						DMARK "MAN" 
1141						CALLMONITOR 
1141					endif 
1141			 
1141			malloc_early_exit: 
1141					if DEBUG_FORTH_MALLOC 
1141						DMARK "MAx" 
1141						CALLMONITOR 
1141					endif 
1141 dd e1		      pop   IX 
1143 d1			      pop   DE 
1144 c1			      pop   BC 
1145			 
1145			if DEBUG_FORTH_MALLOC_HIGH 
1145			call malloc_guard_exit 
1145			call malloc_guard_zerolen 
1145			endif 
1145 c9			      ret 
1146			 
1146			 
1146			;------------------------------------------------------------------------------ 
1146			;     free                                                                    : 
1146			;                                                                             : 
1146			; Description                                                                 : 
1146			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1146			;     returned by malloc, otherwise the behaviour is undefined.               : 
1146			;                                                                             : 
1146			;     Where possible, directly adjacent free blocks will be merged together   : 
1146			;     into larger blocks to help ensure that the heap does not become         : 
1146			;     excessively fragmented.                                                 : 
1146			;                                                                             : 
1146			;     free does not clear or set any other value into the freed space, and    : 
1146			;     therefore its contents may be visible through subsequent malloc's. The  : 
1146			;     caller should clear the freed space as required.                        : 
1146			;                                                                             : 
1146			;     This implementation of free uses the stack exclusively, and is          : 
1146			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1146			;     advisable to disable interrupts before calling free, and recommended    : 
1146			;     to avoid the use of free inside ISRs in general.                        : 
1146			;                                                                             : 
1146			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1146			;                                                                             : 
1146			; Parameters                                                                  : 
1146			;     HL  Pointer to address of first byte of allocation to be freed          : 
1146			;                                                                             : 
1146			; Returns                                                                     : 
1146			;     Nothing                                                                 : 
1146			;                                                                             : 
1146			; Stack frame                                                                 : 
1146			;       |             |                                                       : 
1146			;       +-------------+                                                       : 
1146			;       |     BC      |                                                       : 
1146			;       +-------------+                                                       : 
1146			;       |     DE      |                                                       : 
1146			;       +-------------+                                                       : 
1146			;       |     IX      |                                                       : 
1146			;       +-------------+                                                       : 
1146			;       |  prev_free  |                                                       : 
1146			;   +2  +-------------+                                                       : 
1146			;       |  next_free  |                                                       : 
1146			;   +0  +-------------+                                                       : 
1146			;       |             |                                                       : 
1146			;                                                                             : 
1146			;------------------------------------------------------------------------------ 
1146			free: 
1146 c5			      push  BC 
1147 d5			      push  DE 
1148 dd e5		      push  IX 
114a			 
114a 7c			      ld    A, H                    ; Exit if ptr is null 
114b b5			      or    L 
114c ca 10 12		      jp    Z, free_early_exit 
114f			 
114f			      ; Set up stack frame 
114f eb			      ex    DE, HL 
1150 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1153 39			      add   HL, SP 
1154 f9			      ld    SP, HL 
1155 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1159 dd 39		      add   IX, SP 
115b			 
115b			      ; The address in HL points to the start of the useable allocated space, 
115b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
115b			      ; address of the block itself. 
115b eb			      ex    DE, HL 
115c 11 fc ff		      ld    DE, -4 
115f 19			      add   HL, DE 
1160			 
1160			      ; An allocated block must have a null next block pointer in it 
1160 7e			      ld    A, (HL) 
1161 23			      inc   HL 
1162 b6			      or    (HL) 
1163 c2 0b 12		      jp    NZ, free_done 
1166			 
1166 2b			      dec   HL 
1167			 
1167 44			      ld    B, H                    ; Copy HL to BC 
1168 4d			      ld    C, L 
1169			 
1169			      ; Loop through the free list to find the first block with an address 
1169			      ; higher than the block being freed 
1169 21 9c 58		      ld    HL, free_list 
116c			 
116c			free_find_higher_block: 
116c 5e			      ld    E, (HL)                 ; Load next ptr from free block 
116d 23			      inc   HL 
116e 56			      ld    D, (HL) 
116f 2b			      dec   HL 
1170			 
1170 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1173 dd 72 01		      ld    (IX+1), D 
1176 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1179 dd 74 03		      ld    (IX+3), H 
117c			 
117c 78			      ld    A, B                    ; Check if DE is greater than BC 
117d ba			      cp    D                       ; Compare MSB first 
117e 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1180 30 04		      jr    NC, free_find_higher_block_skip 
1182 79			      ld    A, C 
1183 bb			      cp    E                       ; Then compare LSB 
1184 38 08		      jr    C, free_found_higher_block 
1186			 
1186			free_find_higher_block_skip: 
1186 7a			      ld    A, D                    ; Reached the end of the free list? 
1187 b3			      or    E 
1188 ca 0b 12		      jp    Z, free_done 
118b			 
118b eb			      ex    DE, HL 
118c			 
118c 18 de		      jr    free_find_higher_block 
118e			 
118e			free_found_higher_block: 
118e			      ; Insert freed block between prev and next free blocks 
118e 71			      ld    (HL), C                 ; Point prev free block to freed block 
118f 23			      inc   HL 
1190 70			      ld    (HL), B 
1191			 
1191 60			      ld    H, B                    ; Point freed block at next free block 
1192 69			      ld    L, C 
1193 73			      ld    (HL), E 
1194 23			      inc   HL 
1195 72			      ld    (HL), D 
1196			 
1196			      ; Check if the freed block is adjacent to the next free block 
1196 23			      inc   HL                      ; Load size of freed block into HL 
1197 5e			      ld    E, (HL) 
1198 23			      inc   HL 
1199 56			      ld    D, (HL) 
119a eb			      ex    DE, HL 
119b			 
119b 09			      add   HL, BC                  ; Add addr of freed block and its size 
119c			 
119c dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
119f dd 56 01		      ld    D, (IX+1) 
11a2			 
11a2 b7			      or    A                       ; Clear the carry flag 
11a3 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
11a5 20 22		      jr    NZ, free_check_adjacent_to_prev 
11a7			 
11a7			      ; Freed block is adjacent to next, merge into one bigger block 
11a7 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
11a8 5e			      ld    E, (HL) 
11a9 23			      inc   HL 
11aa 56			      ld    D, (HL) 
11ab e5			      push  HL                      ; Save ptr to next block for later 
11ac			 
11ac 60			      ld    H, B                    ; Store ptr from next block into freed block 
11ad 69			      ld    L, C 
11ae 73			      ld    (HL), E 
11af 23			      inc   HL 
11b0 72			      ld    (HL), D 
11b1			 
11b1 e1			      pop   HL                      ; Restore ptr to next block 
11b2 23			      inc   HL                      ; Load size of next block into DE 
11b3 5e			      ld    E, (HL) 
11b4 23			      inc   HL 
11b5 56			      ld    D, (HL) 
11b6 d5			      push  DE                      ; Save next block size for later 
11b7			 
11b7 60			      ld    H, B                    ; Load size of freed block into HL 
11b8 69			      ld    L, C 
11b9 23			      inc   HL 
11ba 23			      inc   HL 
11bb 5e			      ld    E, (HL) 
11bc 23			      inc   HL 
11bd 56			      ld    D, (HL) 
11be eb			      ex    DE, HL 
11bf			 
11bf d1			      pop   DE                      ; Restore size of next block 
11c0 19			      add   HL, DE                  ; Add sizes of both blocks 
11c1 eb			      ex    DE, HL 
11c2			 
11c2 60			      ld    H, B                    ; Store new bigger size into freed block 
11c3 69			      ld    L, C 
11c4 23			      inc   HL 
11c5 23			      inc   HL 
11c6 73			      ld    (HL), E 
11c7 23			      inc   HL 
11c8 72			      ld    (HL), D 
11c9			 
11c9			free_check_adjacent_to_prev: 
11c9			      ; Check if the freed block is adjacent to the prev free block 
11c9 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
11cc dd 66 03		      ld    H, (IX+3) 
11cf			 
11cf 23			      inc   HL                      ; Size of prev free block into DE 
11d0 23			      inc   HL 
11d1 5e			      ld    E, (HL) 
11d2 23			      inc   HL 
11d3 56			      ld    D, (HL) 
11d4 2b			      dec   HL 
11d5 2b			      dec   HL 
11d6 2b			      dec   HL 
11d7			 
11d7 19			      add   HL, DE                  ; Add prev block addr and size 
11d8			 
11d8 b7			      or    A                       ; Clear the carry flag 
11d9 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11db 20 2e		      jr    NZ, free_done 
11dd			 
11dd			      ; Freed block is adjacent to prev, merge into one bigger block 
11dd 60			      ld    H, B                    ; Load next ptr from freed block into DE 
11de 69			      ld    L, C 
11df 5e			      ld    E, (HL) 
11e0 23			      inc   HL 
11e1 56			      ld    D, (HL) 
11e2 e5			      push  HL                      ; Save freed block ptr for later 
11e3			 
11e3 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11e6 dd 66 03		      ld    H, (IX+3) 
11e9 73			      ld    (HL), E 
11ea 23			      inc   HL 
11eb 72			      ld    (HL), D 
11ec			 
11ec e1			      pop   HL                      ; Restore freed block ptr 
11ed 23			      inc   HL                      ; Load size of freed block into DE 
11ee 5e			      ld    E, (HL) 
11ef 23			      inc   HL 
11f0 56			      ld    D, (HL) 
11f1 d5			      push  DE                      ; Save freed block size for later 
11f2			 
11f2 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
11f5 dd 66 03		      ld    H, (IX+3) 
11f8 23			      inc   HL 
11f9 23			      inc   HL 
11fa 5e			      ld    E, (HL) 
11fb 23			      inc   HL 
11fc 56			      ld    D, (HL) 
11fd			 
11fd e1			      pop   HL                      ; Add sizes of both blocks 
11fe 19			      add   HL, DE 
11ff eb			      ex    DE, HL 
1200			 
1200 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1203 dd 66 03		      ld    H, (IX+3) 
1206 23			      inc   HL 
1207 23			      inc   HL 
1208 73			      ld    (HL), E 
1209 23			      inc   HL 
120a 72			      ld    (HL), D 
120b			 
120b			free_done: 
120b 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
120e 39			      add   HL, SP 
120f f9			      ld    SP, HL 
1210			 
1210			free_early_exit: 
1210 dd e1		      pop   IX 
1212 d1			      pop   DE 
1213 c1			      pop   BC 
1214			 
1214 c9			      ret 
1215			 
1215			; moved to firmware.asm 
1215			; 
1215			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1215			;                  .dw   0 
1215			 
1215			 
1215			endif 
1215			 
1215			 
1215			if MALLOC_3 
1215			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1215			;heap_start        .equ  0x9000      ; Starting address of heap 
1215			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1215			; 
1215			 ;     .org 0 
1215			  ;    jp    main 
1215			; 
1215			; 
1215			 ;     .org  0x100 
1215			;main: 
1215			 ;     ld    HL, 0x8100 
1215			  ;    ld    SP, HL 
1215			; 
1215			;      call  heap_init 
1215			 
1215			      ; Make some allocations 
1215			;      ld    HL, 12 
1215			;      call  malloc            ; Allocates 0x9004 
1215			; 
1215			 ;     ld    HL, 12 
1215			;      call  malloc            ; Allocates 0x9014 
1215			 
1215			;      ld    HL, 12 
1215			;      call  malloc            ; Allocates 0x9024 
1215			 
1215			      ; Free some allocations 
1215			;      ld    HL, 0x9014 
1215			;      call  free 
1215			 
1215			;      ld    HL, 0x9004 
1215			;      call  free 
1215			; 
1215			;      ld    HL, 0x9024 
1215			;      call  free 
1215			 
1215			 
1215			 ;     halt 
1215			 
1215			 
1215			;------------------------------------------------------------------------------ 
1215			;     heap_init                                                               : 
1215			;                                                                             : 
1215			; Description                                                                 : 
1215			;     Initialise the heap and make it ready for malloc and free operations.   : 
1215			;                                                                             : 
1215			;     The heap is maintained as a linked list, starting with an initial       : 
1215			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1215			;     the first free block in the heap. Each block then points to the next    : 
1215			;     free block within the heap, and the free list ends at the first block   : 
1215			;     with a null pointer to the next free block.                             : 
1215			;                                                                             : 
1215			; Parameters                                                                  : 
1215			;     Inputs are compile-time only. Two defines which specify the starting    : 
1215			;     address of the heap and its size are required, along with a memory      : 
1215			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1215			;     principally stores a pointer to the first free block in the heap.       : 
1215			;                                                                             : 
1215			; Returns                                                                     : 
1215			;     Nothing                                                                 : 
1215			;------------------------------------------------------------------------------ 
1215			heap_init: 
1215			      push  HL 
1215			 
1215			      ; Initialise free list struct 
1215			      ld    HL, heap_start 
1215			      ld    (free_list), HL 
1215			      ld    HL, 0 
1215			      ld    (free_list+2), HL 
1215			 
1215			      ; Insert first free block at bottom of heap, consumes entire heap 
1215			      ld    HL, heap_start+heap_size-4 
1215			      ld    (heap_start), HL        ; Next block (end of free list) 
1215			      ld    HL, heap_size-4 
1215			      ld    (heap_start+2), HL      ; Block size 
1215			 
1215			      ; Insert end of free list block at top of heap - two null words will 
1215			      ; terminate the free list 
1215			      ld    HL, 0 
1215			      ld    (heap_start+heap_size-2), HL 
1215			      ld    (heap_start+heap_size-4), HL 
1215			 
1215			      pop   HL 
1215			 
1215			      ret 
1215			 
1215			 
1215			;------------------------------------------------------------------------------ 
1215			;     malloc                                                                  : 
1215			;                                                                             : 
1215			; Description                                                                 : 
1215			;     Allocates the wanted space from the heap and returns the address of the : 
1215			;     first useable byte of the allocation.                                   : 
1215			;                                                                             : 
1215			;     Allocations can happen in one of two ways:                              : 
1215			;                                                                             : 
1215			;     1. A free block may be found which is the exact size wanted. In this    : 
1215			;        case the block is removed from the free list and retuedn to the      : 
1215			;        caller.                                                              : 
1215			;     2. A free block may be found which is larger than the size wanted. In   : 
1215			;        this case, the larger block is split into two. The first portion of  : 
1215			;        this block will become the requested space by the malloc call and    : 
1215			;        is returned to the caller. The second portion becomes a new free     : 
1215			;        block, and the free list is adjusted to maintain continuity via this : 
1215			;        newly created block.                                                 : 
1215			;                                                                             : 
1215			;     malloc does not set any initial value in the allocated space, the       : 
1215			;     caller is required to do this as required.                              : 
1215			;                                                                             : 
1215			;     This implementation of malloc uses the stack exclusively, and is        : 
1215			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1215			;     advisable to disable interrupts before calling malloc, and recommended  : 
1215			;     to avoid the use of malloc inside ISRs in general.                      : 
1215			;                                                                             : 
1215			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1215			;                                                                             : 
1215			; Parameters                                                                  : 
1215			;     HL  Number of bytes wanted                                              : 
1215			;                                                                             : 
1215			; Returns                                                                     : 
1215			;     HL  Address of the first useable byte of the allocation                 : 
1215			;                                                                             : 
1215			; Flags                                                                       : 
1215			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1215			;                                                                             : 
1215			; Stack frame                                                                 : 
1215			;       |             |                                                       : 
1215			;       +-------------+                                                       : 
1215			;       |     BC      |                                                       : 
1215			;       +-------------+                                                       : 
1215			;       |     DE      |                                                       : 
1215			;       +-------------+                                                       : 
1215			;       |     IX      |                                                       : 
1215			;       +-------------+                                                       : 
1215			;       |  prev_free  |                                                       : 
1215			;   +4  +-------------+                                                       : 
1215			;       |  this_free  |                                                       : 
1215			;   +2  +-------------+                                                       : 
1215			;       |  next_free  |                                                       : 
1215			;   +0  +-------------+                                                       : 
1215			;       |             |                                                       : 
1215			;                                                                             : 
1215			;------------------------------------------------------------------------------ 
1215			malloc: 
1215			      push  BC 
1215			      push  DE 
1215			      push  IX 
1215			 
1215			      ld    A, H                    ; Exit if no space requested 
1215			      or    L 
1215			      jp    Z, malloc_early_exit 
1215			 
1215			      ; Set up stack frame 
1215			      ex    DE, HL 
1215			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1215			      add   HL, SP 
1215			      ld    SP, HL 
1215			      ld    IX, 0                   ; Use IX as a frame pointer 
1215			      add   IX, SP 
1215			 
1215			      ; Setup initial state 
1215			      ld    HL, 4                   ; want must also include space used by block struct 
1215			      add   HL, DE 
1215			 
1215			      ld    B, H                    ; Move want to BC 
1215			      ld    C, L 
1215			 
1215			      ld    HL, free_list           ; Store prev_free ptr to stack 
1215			      ld    (IX+4), L 
1215			      ld    (IX+5), H 
1215			 
1215			      ld    E, (HL)                 ; Store this_free ptr to stack 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			      ld    (IX+2), E 
1215			      ld    (IX+3), D 
1215			      ex    DE, HL                  ; this_free ptr into HL 
1215			 
1215			      ; Loop through free block list to find some space 
1215			malloc_find_space: 
1215			      ld    E, (HL)                 ; Load next_free ptr into DE 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			 
1215			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1215			      or    E 
1215			      jp    Z, malloc_no_space 
1215			 
1215			      ld    (IX+0), E               ; Store next_free ptr to stack 
1215			      ld    (IX+1), D 
1215			 
1215			      ; Does this block have enough space to make the allocation? 
1215			      inc   HL                      ; Load free block size into DE 
1215			      ld    E, (HL) 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			 
1215			      ex    DE, HL                  ; Check size of block against want 
1215			      or    A                       ; Ensure carry flag clear 
1215			      sbc   HL, BC 
1215			      push  HL                      ; Store the result for later (new block size) 
1215			 
1215			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1215			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1215			 
1215			      ; this_free block is not big enough, setup ptrs to test next free block 
1215			      pop   HL                      ; Discard previous result 
1215			 
1215			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1215			      ld    H, (IX+3) 
1215			      ld    (IX+4), L 
1215			      ld    (IX+5), H 
1215			 
1215			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1215			      ld    H, (IX+1) 
1215			      ld    (IX+2), L 
1215			      ld    (IX+3), H 
1215			 
1215			      jr    malloc_find_space 
1215			 
1215			      ; split a bigger block into two - requested size and remaining size 
1215			malloc_alloc_split: 
1215			      ex    DE, HL                  ; Calculate address of new free block 
1215			      dec   HL 
1215			      dec   HL 
1215			      dec   HL 
1215			      add   HL, BC 
1215			 
1215			      ; Create a new block and point it at next_free 
1215			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1215			      ld    D, (IX+1) 
1215			 
1215			      ld    (HL), E                 ; Store next_free ptr into new block 
1215			      inc   HL 
1215			      ld    (HL), D 
1215			 
1215			      pop   DE                      ; Store size of new block into new block 
1215			      inc   HL 
1215			      ld    (HL), E 
1215			      inc   HL 
1215			      ld    (HL), D 
1215			 
1215			      ; Update this_free ptr to point to new block 
1215			      dec   HL 
1215			      dec   HL 
1215			      dec   HL 
1215			 
1215			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1215			      ld    D, (IX+3) 
1215			 
1215			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1215			      ld    (IX+3), H 
1215			 
1215			      ; Modify this_free block to be allocation 
1215			      ex    DE, HL 
1215			      xor   A                       ; Null the next block ptr of allocated block 
1215			      ld    (HL), A 
1215			      inc   HL 
1215			      ld    (HL), A 
1215			 
1215			      inc   HL                      ; Store want size into allocated block 
1215			      ld    (HL), C 
1215			      inc   HL 
1215			      ld    (HL), B 
1215			      inc   HL 
1215			      push  HL                      ; Address of allocation to return 
1215			 
1215			      jr    malloc_update_links 
1215			 
1215			malloc_alloc_fit: 
1215			      pop   HL                      ; Dont need new block size, want is exact fit 
1215			 
1215			      ; Modify this_free block to be allocation 
1215			      ex    DE, HL 
1215			      dec   HL 
1215			      dec   HL 
1215			      dec   HL 
1215			 
1215			      xor   A                       ; Null the next block ptr of allocated block 
1215			      ld    (HL), A 
1215			      inc   HL 
1215			      ld    (HL), A 
1215			 
1215			      inc   HL                      ; Store address of allocation to return 
1215			      inc   HL 
1215			      inc   HL 
1215			      push  HL 
1215			 
1215			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1215			      ld    L, (IX+0)               ; next_free to HL 
1215			      ld    H, (IX+1) 
1215			 
1215			      ld    (IX+2), L               ; HL to this_free 
1215			      ld    (IX+3), H 
1215			 
1215			 
1215			malloc_update_links: 
1215			      ; Update prev_free ptr to point to this_free 
1215			      ld    L, (IX+4)               ; prev_free ptr to HL 
1215			      ld    H, (IX+5) 
1215			 
1215			      ld    E, (IX+2)               ; this_free ptr to DE 
1215			      ld    D, (IX+3) 
1215			 
1215			      ld    (HL), E                 ; this_free ptr into prev_free 
1215			      inc   HL 
1215			      ld    (HL), D 
1215			 
1215			      ; Clear the Z flag to indicate successful allocation 
1215			      ld    A, D 
1215			      or    E 
1215			 
1215			      pop   DE                      ; Address of allocation 
1215			 
1215			malloc_no_space: 
1215			      ld    HL, 6                   ; Clean up stack frame 
1215			      add   HL, SP 
1215			      ld    SP, HL 
1215			 
1215			      ex    DE, HL                  ; Alloc addr into HL for return 
1215			 
1215			malloc_early_exit: 
1215			      pop   IX 
1215			      pop   DE 
1215			      pop   BC 
1215			 
1215			      ret 
1215			 
1215			 
1215			;------------------------------------------------------------------------------ 
1215			;     free                                                                    : 
1215			;                                                                             : 
1215			; Description                                                                 : 
1215			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1215			;     returned by malloc, otherwise the behaviour is undefined.               : 
1215			;                                                                             : 
1215			;     Where possible, directly adjacent free blocks will be merged together   : 
1215			;     into larger blocks to help ensure that the heap does not become         : 
1215			;     excessively fragmented.                                                 : 
1215			;                                                                             : 
1215			;     free does not clear or set any other value into the freed space, and    : 
1215			;     therefore its contents may be visible through subsequent malloc's. The  : 
1215			;     caller should clear the freed space as required.                        : 
1215			;                                                                             : 
1215			;     This implementation of free uses the stack exclusively, and is          : 
1215			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1215			;     advisable to disable interrupts before calling free, and recommended    : 
1215			;     to avoid the use of free inside ISRs in general.                        : 
1215			;                                                                             : 
1215			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1215			;                                                                             : 
1215			; Parameters                                                                  : 
1215			;     HL  Pointer to address of first byte of allocation to be freed          : 
1215			;                                                                             : 
1215			; Returns                                                                     : 
1215			;     Nothing                                                                 : 
1215			;                                                                             : 
1215			; Stack frame                                                                 : 
1215			;       |             |                                                       : 
1215			;       +-------------+                                                       : 
1215			;       |     BC      |                                                       : 
1215			;       +-------------+                                                       : 
1215			;       |     DE      |                                                       : 
1215			;       +-------------+                                                       : 
1215			;       |     IX      |                                                       : 
1215			;       +-------------+                                                       : 
1215			;       |  prev_free  |                                                       : 
1215			;   +2  +-------------+                                                       : 
1215			;       |  next_free  |                                                       : 
1215			;   +0  +-------------+                                                       : 
1215			;       |             |                                                       : 
1215			;                                                                             : 
1215			;------------------------------------------------------------------------------ 
1215			free: 
1215			      push  BC 
1215			      push  DE 
1215			      push  IX 
1215			 
1215			      ld    A, H                    ; Exit if ptr is null 
1215			      or    L 
1215			      jp    Z, free_early_exit 
1215			 
1215			      ; Set up stack frame 
1215			      ex    DE, HL 
1215			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1215			      add   HL, SP 
1215			      ld    SP, HL 
1215			      ld    IX, 0                   ; Use IX as a frame pointer 
1215			      add   IX, SP 
1215			 
1215			      ; The address in HL points to the start of the useable allocated space, 
1215			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1215			      ; address of the block itself. 
1215			      ex    DE, HL 
1215			      ld    DE, -4 
1215			      add   HL, DE 
1215			 
1215			      ; An allocated block must have a null next block pointer in it 
1215			      ld    A, (HL) 
1215			      inc   HL 
1215			      or    (HL) 
1215			      jp    NZ, free_done 
1215			 
1215			      dec   HL 
1215			 
1215			      ld    B, H                    ; Copy HL to BC 
1215			      ld    C, L 
1215			 
1215			      ; Loop through the free list to find the first block with an address 
1215			      ; higher than the block being freed 
1215			      ld    HL, free_list 
1215			 
1215			free_find_higher_block: 
1215			      ld    E, (HL)                 ; Load next ptr from free block 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			      dec   HL 
1215			 
1215			      ld    (IX+0), E               ; Save ptr to next free block 
1215			      ld    (IX+1), D 
1215			      ld    (IX+2), L               ; Save ptr to prev free block 
1215			      ld    (IX+3), H 
1215			 
1215			      ld    A, B                    ; Check if DE is greater than BC 
1215			      cp    D                       ; Compare MSB first 
1215			      jr    Z, $+4                  ; MSB the same, compare LSB 
1215			      jr    NC, free_find_higher_block_skip 
1215			      ld    A, C 
1215			      cp    E                       ; Then compare LSB 
1215			      jr    C, free_found_higher_block 
1215			 
1215			free_find_higher_block_skip: 
1215			      ld    A, D                    ; Reached the end of the free list? 
1215			      or    E 
1215			      jp    Z, free_done 
1215			 
1215			      ex    DE, HL 
1215			 
1215			      jr    free_find_higher_block 
1215			 
1215			free_found_higher_block: 
1215			      ; Insert freed block between prev and next free blocks 
1215			      ld    (HL), C                 ; Point prev free block to freed block 
1215			      inc   HL 
1215			      ld    (HL), B 
1215			 
1215			      ld    H, B                    ; Point freed block at next free block 
1215			      ld    L, C 
1215			      ld    (HL), E 
1215			      inc   HL 
1215			      ld    (HL), D 
1215			 
1215			      ; Check if the freed block is adjacent to the next free block 
1215			      inc   HL                      ; Load size of freed block into HL 
1215			      ld    E, (HL) 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			      ex    DE, HL 
1215			 
1215			      add   HL, BC                  ; Add addr of freed block and its size 
1215			 
1215			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1215			      ld    D, (IX+1) 
1215			 
1215			      or    A                       ; Clear the carry flag 
1215			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1215			      jr    NZ, free_check_adjacent_to_prev 
1215			 
1215			      ; Freed block is adjacent to next, merge into one bigger block 
1215			      ex    DE, HL                  ; Load next ptr from next block into DE 
1215			      ld    E, (HL) 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			      push  HL                      ; Save ptr to next block for later 
1215			 
1215			      ld    H, B                    ; Store ptr from next block into freed block 
1215			      ld    L, C 
1215			      ld    (HL), E 
1215			      inc   HL 
1215			      ld    (HL), D 
1215			 
1215			      pop   HL                      ; Restore ptr to next block 
1215			      inc   HL                      ; Load size of next block into DE 
1215			      ld    E, (HL) 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			      push  DE                      ; Save next block size for later 
1215			 
1215			      ld    H, B                    ; Load size of freed block into HL 
1215			      ld    L, C 
1215			      inc   HL 
1215			      inc   HL 
1215			      ld    E, (HL) 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			      ex    DE, HL 
1215			 
1215			      pop   DE                      ; Restore size of next block 
1215			      add   HL, DE                  ; Add sizes of both blocks 
1215			      ex    DE, HL 
1215			 
1215			      ld    H, B                    ; Store new bigger size into freed block 
1215			      ld    L, C 
1215			      inc   HL 
1215			      inc   HL 
1215			      ld    (HL), E 
1215			      inc   HL 
1215			      ld    (HL), D 
1215			 
1215			free_check_adjacent_to_prev: 
1215			      ; Check if the freed block is adjacent to the prev free block 
1215			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1215			      ld    H, (IX+3) 
1215			 
1215			      inc   HL                      ; Size of prev free block into DE 
1215			      inc   HL 
1215			      ld    E, (HL) 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			      dec   HL 
1215			      dec   HL 
1215			      dec   HL 
1215			 
1215			      add   HL, DE                  ; Add prev block addr and size 
1215			 
1215			      or    A                       ; Clear the carry flag 
1215			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1215			      jr    NZ, free_done 
1215			 
1215			      ; Freed block is adjacent to prev, merge into one bigger block 
1215			      ld    H, B                    ; Load next ptr from freed block into DE 
1215			      ld    L, C 
1215			      ld    E, (HL) 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			      push  HL                      ; Save freed block ptr for later 
1215			 
1215			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1215			      ld    H, (IX+3) 
1215			      ld    (HL), E 
1215			      inc   HL 
1215			      ld    (HL), D 
1215			 
1215			      pop   HL                      ; Restore freed block ptr 
1215			      inc   HL                      ; Load size of freed block into DE 
1215			      ld    E, (HL) 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			      push  DE                      ; Save freed block size for later 
1215			 
1215			      ld    L, (IX+2)               ; Load size of prev block into DE 
1215			      ld    H, (IX+3) 
1215			      inc   HL 
1215			      inc   HL 
1215			      ld    E, (HL) 
1215			      inc   HL 
1215			      ld    D, (HL) 
1215			 
1215			      pop   HL                      ; Add sizes of both blocks 
1215			      add   HL, DE 
1215			      ex    DE, HL 
1215			 
1215			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1215			      ld    H, (IX+3) 
1215			      inc   HL 
1215			      inc   HL 
1215			      ld    (HL), E 
1215			      inc   HL 
1215			      ld    (HL), D 
1215			 
1215			free_done: 
1215			      ld    HL, 4                   ; Clean up stack frame 
1215			      add   HL, SP 
1215			      ld    SP, HL 
1215			 
1215			free_early_exit: 
1215			      pop   IX 
1215			      pop   DE 
1215			      pop   BC 
1215			 
1215			      ret 
1215			 
1215			 
1215			;      .org 0x8000 
1215			; 
1215			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1215			 ;                 .dw   0 
1215			 
1215			endif 
1215			 
1215			 
1215			if MALLOC_4 
1215			 
1215			; My memory allocation code. Very very simple.... 
1215			; allocate space under 250 chars 
1215			 
1215			heap_init: 
1215				; init start of heap as zero 
1215				;  
1215			 
1215				ld hl, heap_start 
1215				ld a, 0 
1215				ld (hl), a      ; empty block 
1215				inc hl 
1215				ld a, 0 
1215				ld (hl), a      ; length of block 
1215				; write end of list 
1215				inc hl 
1215				ld a,(hl) 
1215				inc hl 
1215				ld a,(hl) 
1215				 
1215			 
1215				; init some malloc vars 
1215			 
1215				ld hl, 0 
1215				ld (free_list), hl       ; store last malloc location 
1215			 
1215				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1215				ld a, 0 
1215				ld (hl), a 
1215			 
1215			 
1215				ld hl, heap_start 
1215				;  
1215				  
1215				ret 
1215			 
1215			 
1215			;    free block marker 
1215			;    requested size  
1215			;    pointer to next block 
1215			;    .... 
1215			;    next block marker 
1215			 
1215			 
1215			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1215			; 
1215			 
1215			 
1215			malloc:  
1215				push de 
1215				push bc 
1215				push af 
1215			 
1215				; hl space required 
1215				 
1215				ld c, l    ; hold space   (TODO only a max of 255) 
1215			 
1215			;	inc c     ; TODO BUG need to fix memory leak on push str 
1215			;	inc c 
1215			;	inc c 
1215			;	inc c 
1215			;	inc c 
1215			;	inc c 
1215			;	inc c 
1215			 
1215			 
1215			 
1215				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1215			 
1215				ld a, (free_list+3) 
1215				cp 0 
1215				jr z, .contheap 
1215			 
1215				ld hl, (free_list)     ; get last alloc 
1215					if DEBUG_FORTH_MALLOC_INT 
1215						DMARK "mrs" 
1215						CALLMONITOR 
1215					endif 
1215				jr .startalloc 
1215			 
1215			.contheap: 
1215				ld hl, heap_start 
1215			 
1215			.startalloc: 
1215			 
1215					if DEBUG_FORTH_MALLOC_INT 
1215						DMARK "mym" 
1215						CALLMONITOR 
1215					endif 
1215			.findblock: 
1215					if DEBUG_FORTH_MALLOC_INT 
1215						DMARK "mmf" 
1215						CALLMONITOR 
1215					endif 
1215			 
1215				ld a,(hl)  
1215				; if byte is zero then clear to use 
1215			 
1215				cp 0 
1215				jr z, .foundemptyblock 
1215			 
1215				; if byte is not clear 
1215				;     then byte is offset to next block 
1215			 
1215				inc hl 
1215				ld a, (hl) ; get size 
1215			.nextblock:	inc hl 
1215					ld e, (hl) 
1215					inc hl 
1215					ld d, (hl) 
1215					ex de, hl 
1215			;	inc hl  ; move past the store space 
1215			;	inc hl  ; move past zero index  
1215			 
1215				; TODO detect no more space 
1215			 
1215				push hl 
1215				ld de, heap_end 
1215				call cmp16 
1215				pop hl 
1215				jr nc, .nospace 
1215			 
1215				jr .findblock 
1215			 
1215			.nospace: ld hl, 0 
1215				jp .exit 
1215			 
1215			 
1215			.foundemptyblock:	 
1215					if DEBUG_FORTH_MALLOC_INT 
1215						DMARK "mme" 
1215						CALLMONITOR 
1215					endif 
1215			 
1215			; TODO has block enough space if reusing??? 
1215			 
1215				;  
1215			 
1215			; see if this block has been previously used 
1215				inc hl 
1215				ld a, (hl) 
1215				dec hl 
1215				cp 0 
1215				jr z, .newblock 
1215			 
1215					if DEBUG_FORTH_MALLOC_INT 
1215						DMARK "meR" 
1215						CALLMONITOR 
1215					endif 
1215			 
1215			; no reusing previously allocated block 
1215			 
1215			; is it smaller than previously used? 
1215				 
1215				inc hl    ; move to size 
1215				ld a, c 
1215				sub (hl)        ; we want c < (hl) 
1215				dec hl    ; move back to marker 
1215			        jr z, .findblock 
1215			 
1215				; update with the new size which should be lower 
1215			 
1215			        ;inc  hl   ; negate next move. move back to size  
1215			 
1215			.newblock: 
1215				; need to be at marker here 
1215			 
1215					if DEBUG_FORTH_MALLOC_INT 
1215						DMARK "meN" 
1215						CALLMONITOR 
1215					endif 
1215			 
1215			 
1215				ld a, c 
1215			 
1215				ld (free_list+3), a	 ; flag resume from last malloc  
1215				ld (free_list), hl    ; save out last location 
1215			 
1215			 
1215				;inc a     ; space for length byte 
1215				ld (hl), a     ; save block in use marker 
1215			 
1215				inc hl   ; move to space marker 
1215				ld (hl), a    ; save new space 
1215			 
1215				inc hl   ; move to start of allocated area 
1215				 
1215			;	push hl     ; save where we are - 1  
1215			 
1215			;	inc hl  ; move past zero index  
1215				; skip space to set down new marker 
1215			 
1215				; provide some extra space for now 
1215			 
1215				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1215				inc a 
1215				inc a 
1215			 
1215				push hl   ; save where we are in the node block 
1215			 
1215				call addatohl 
1215			 
1215				; write linked list point 
1215			 
1215				pop de     ; get our node position 
1215				ex de, hl 
1215			 
1215				ld (hl), e 
1215				inc hl 
1215				ld (hl), d 
1215			 
1215				inc hl 
1215			 
1215				; now at start of allocated data so save pointer 
1215			 
1215				push hl 
1215			 
1215				; jump to position of next node and setup empty header in DE 
1215			 
1215				ex de, hl 
1215			 
1215			;	inc hl ; move past end of block 
1215			 
1215				ld a, 0 
1215				ld (hl), a   ; empty marker 
1215				inc hl 
1215				ld (hl), a   ; size 
1215				inc hl  
1215				ld (hl), a   ; ptr 
1215				inc hl 
1215				ld (hl), a   ; ptr 
1215			 
1215			 
1215				pop hl 
1215			 
1215					if DEBUG_FORTH_MALLOC_INT 
1215						DMARK "mmr" 
1215						CALLMONITOR 
1215					endif 
1215			 
1215			.exit: 
1215				pop af 
1215				pop bc 
1215				pop de  
1215				ret 
1215			 
1215			 
1215			 
1215			 
1215			free:  
1215				push hl 
1215				push af 
1215				; get address in hl 
1215			 
1215					if DEBUG_FORTH_MALLOC_INT 
1215						DMARK "fre" 
1215						CALLMONITOR 
1215					endif 
1215				; data is at hl - move to block count 
1215				dec hl 
1215				dec hl    ; get past pointer 
1215				dec hl 
1215			 
1215				ld a, (hl)    ; need this for a validation check 
1215			 
1215				dec hl    ; move to block marker 
1215			 
1215				; now check that the block count and block marker are the same  
1215			        ; this checks that we are on a malloc node and not random memory 
1215			        ; OK a faint chance this could be a problem but rare - famous last words! 
1215			 
1215				ld c, a 
1215				ld a, (hl)    
1215			 
1215				cp c 
1215				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1215			 
1215				; yes good chance we are on a malloc node 
1215			 
1215				ld a, 0      
1215				ld (hl), a   ; mark as free 
1215			 
1215				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1215			 
1215			.freeignore:  
1215			 
1215				pop af 
1215				pop hl 
1215			 
1215				ret 
1215			 
1215			 
1215			 
1215			endif 
1215			 
1215			; eof 
# End of file firmware_memory.asm
1215			  
1215			; device C  
1215			if SOUND_ENABLE  
1215				include "firmware_sound.asm"  
1215			endif  
1215			  
1215			include "firmware_diags.asm"  
1215			; Hardware diags menu 
1215			 
1215			 
1215			config: 
1215			 
1215 3e 00			ld a, 0 
1217 21 45 12			ld hl, .configmn 
121a cd b9 09			call menu 
121d			 
121d fe 00			cp 0 
121f c8				ret z 
1220			 
1220 fe 01			cp 1 
1222 cc e9 12			call z, .savetostore 
1225			 
1225 fe 02			cp 2 
1227 cc e7 12			call z, .selautoload 
122a fe 03			cp 3 
122c cc e6 12			call z, .disautoload 
122f fe 04			cp 4 
1231 cc e8 12			call z, .selbank 
1234 fe 05			cp 5 
1236 cc ea 12			call z, .debug_tog 
1239 fe 06			cp 6 
123b cc 32 14			call z, .bpsgo 
123e fe 07			cp 7 
1240 cc 10 13			call z, hardware_diags 
1243			 
1243 18 d0			jr config 
1245			 
1245			.configmn: 
1245 55 12			dw .c3 
1247 6c 12			dw .c2 
1249 81 12			dw .c2a 
124b 97 12			dw .c2b 
124d			;	dw .c4 
124d b4 12			dw .m4 
124f cf 12			dw .m4b 
1251 d7 12			dw .c1 
1253 00 00			dw 0 
1255				 
1255			 
1255 .. 00		.c3: db "Add Dictionary To File",0 
126c .. 00		.c2: db "Select Autoload File",0 
1281 .. 00		.c2a: db "Disable Autoload File", 0 
1297 .. 00		.c2b: db "Select Storage Bank",0 
12ab .. 00		.c4: db "Settings",0 
12b4 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
12cf .. 00		.m4b:   db "Monitor",0 
12d7 .. 00		.c1: db "Hardware Diags",0 
12e6			 
12e6			 
12e6			.disautoload: 
12e6				if STORAGE_SE 
12e6				ld a, $fe      ; bit 0 clear 
12e6				ld (spi_device), a 
12e6			 
12e6				call storage_get_block_0 
12e6			 
12e6				ld a, 0 
12e6				ld (store_page+STORE_0_AUTOFILE), a 
12e6			 
12e6					ld hl, 0 
12e6					ld de, store_page 
12e6				call storage_write_block	 ; save update 
12e6				endif 
12e6			 
12e6			 
12e6 c9				ret 
12e7			 
12e7			 
12e7			 
12e7			; Select auto start 
12e7			 
12e7			.selautoload: 
12e7			 
12e7				 
12e7				if STORAGE_SE 
12e7			 
12e7					call config_dir 
12e7				        ld hl, scratch 
12e7					ld a, 0 
12e7					call menu 
12e7			 
12e7					cp 0 
12e7					ret z 
12e7			 
12e7					dec a 
12e7			 
12e7			 
12e7					; locate menu option 
12e7			 
12e7					ld hl, scratch 
12e7					call table_lookup 
12e7			 
12e7					if DEBUG_FORTH_WORDS 
12e7						DMARK "ALl" 
12e7						CALLMONITOR 
12e7					endif 
12e7					; with the pointer to the menu it, the byte following the zero term is the file id 
12e7			 
12e7					ld a, 0 
12e7					ld bc, 50   ; max of bytes to look at 
12e7					cpir  
12e7			 
12e7					if DEBUG_FORTH_WORDS 
12e7						DMARK "ALb" 
12e7						CALLMONITOR 
12e7					endif 
12e7					;inc hl 
12e7			 
12e7					ld a, (hl)   ; file id 
12e7					 
12e7				        ; save bank and file ids 
12e7			 
12e7					push af 
12e7			 
12e7			; TODO need to save to block 0 on bank 1	 
12e7			 
12e7					call storage_get_block_0 
12e7			 
12e7					if DEBUG_FORTH_WORDS 
12e7						DMARK "AL0" 
12e7						CALLMONITOR 
12e7					endif 
12e7					pop af 
12e7			 
12e7					ld (store_page+STORE_0_FILERUN),a 
12e7					 
12e7					; save bank id 
12e7			 
12e7					ld a,(spi_device) 
12e7					ld (store_page+STORE_0_BANKRUN),a 
12e7			 
12e7					; enable auto run of store file 
12e7			 
12e7					ld a, 1 
12e7					ld (store_page+STORE_0_AUTOFILE),a 
12e7			 
12e7					; save buffer 
12e7			 
12e7					ld hl, 0 
12e7					ld de, store_page 
12e7					if DEBUG_FORTH_WORDS 
12e7						DMARK "ALw" 
12e7						CALLMONITOR 
12e7					endif 
12e7				call storage_write_block	 ; save update 
12e7			  
12e7			 
12e7			 
12e7			 
12e7					ld hl, scratch 
12e7					call config_fdir 
12e7			 
12e7			 
12e7				endif 
12e7 c9				ret 
12e8			 
12e8			 
12e8			 
12e8			; Select storage bank 
12e8			 
12e8			.selbank: 
12e8			 
12e8				if STORAGE_SE 
12e8				endif 
12e8				 
12e8 c9				ret 
12e9			 
12e9			if STORAGE_SE 
12e9			 
12e9			.config_ldir:   
12e9				; Load storage bank labels into menu array 
12e9			 
12e9				 
12e9			 
12e9			 
12e9				ret 
12e9			 
12e9			 
12e9			endif 
12e9			 
12e9			 
12e9			; Save user words to storage 
12e9			 
12e9			.savetostore: 
12e9			 
12e9				if STORAGE_SE 
12e9			 
12e9					call config_dir 
12e9				        ld hl, scratch 
12e9					ld a, 0 
12e9					call menu 
12e9					 
12e9					ld hl, scratch 
12e9					call config_fdir 
12e9			 
12e9			 
12e9				endif 
12e9			 
12e9 c9				ret 
12ea			 
12ea			 
12ea			 
12ea			if STORAGE_SE 
12ea			 
12ea			config_fdir: 
12ea				; using the scratch dir go through and release the memory allocated for each string 
12ea				 
12ea				ld hl, scratch 
12ea			.cfdir:	ld e,(hl) 
12ea				inc hl 
12ea				ld d,(hl) 
12ea				inc hl 
12ea			 
12ea				ex de, hl 
12ea				call ishlzero 
12ea				ret z     ; return on null pointer 
12ea				call free 
12ea				ex de, hl 
12ea				jr .cfdir 
12ea			 
12ea			 
12ea				ret 
12ea			 
12ea			 
12ea			config_dir: 
12ea			 
12ea				; for the config menus that need to build a directory of storage call this routine 
12ea				; it will construct a menu in scratch to pass to menu 
12ea			 
12ea				; open storage device 
12ea			 
12ea				; execute DIR to build a list of files and their ids into scratch in menu format 
12ea				; once the menu has finished then will need to call config_fdir to release the strings 
12ea				 
12ea				; c = number items 
12ea			 
12ea				 
12ea				call storage_get_block_0 
12ea			 
12ea				ld hl, store_page     ; get current id count 
12ea				ld b, (hl) 
12ea				ld c, 0    ; count of files   
12ea			 
12ea			 
12ea				ld hl, scratch 
12ea				ld (store_tmp2), hl    ; location to poke strings 
12ea			 
12ea				; check for empty drive 
12ea			 
12ea				ld a, 0 
12ea				cp b 
12ea				jp z, .dirdone 
12ea			 
12ea				 
12ea					if DEBUG_FORTH_WORDS 
12ea						DMARK "Cdc" 
12ea						CALLMONITOR 
12ea					endif 
12ea			 
12ea			 
12ea			.diritem:	 
12ea				push bc 
12ea				; for each of the current ids do a search for them and if found push to stack 
12ea			 
12ea					ld hl, STORE_BLOCK_PHY 
12ea					ld d, 0		 ; look for extent 0 of block id as this contains file name 
12ea					ld e,b 
12ea			 
12ea					call storage_findnextid 
12ea			 
12ea			 
12ea					; if found hl will be non zero 
12ea			 
12ea					call ishlzero 
12ea					jr z, .dirnotfound 
12ea			 
12ea					; increase count 
12ea			 
12ea					pop bc	 
12ea					inc c 
12ea					push bc 
12ea					 
12ea			 
12ea					; get file header and push the file name 
12ea			 
12ea					ld de, store_page 
12ea					call storage_read_block 
12ea			 
12ea					; push file id to stack 
12ea				 
12ea					ld a, (store_page) 
12ea					ld h, 0 
12ea					ld l, a 
12ea			 
12ea					;call forth_push_numhl 
12ea					; TODO store id 
12ea			 
12ea					push hl 
12ea			 
12ea					; push extent count to stack  
12ea				 
12ea					ld hl, store_page+3 
12ea			 
12ea					; get file name length 
12ea			 
12ea					call strlenz   
12ea			 
12ea					inc hl   ; cover zero term 
12ea					inc hl  ; stick the id at the end of the area 
12ea			 
12ea					push hl 
12ea					pop bc    ; move length to bc 
12ea			 
12ea					call malloc 
12ea			 
12ea					; TODO save malloc area to scratch 
12ea			 
12ea					ex de, hl 
12ea					ld hl, (store_tmp2) 
12ea					ld (hl), e 
12ea					inc hl 
12ea					ld (hl), d 
12ea					inc hl 
12ea					ld (store_tmp2), hl 
12ea			 
12ea					 
12ea			 
12ea					;pop hl   ; get source 
12ea			;		ex de, hl    ; swap aronund	 
12ea			 
12ea					ld hl, store_page+3 
12ea					if DEBUG_FORTH_WORDS 
12ea						DMARK "CFd" 
12ea						CALLMONITOR 
12ea					endif 
12ea					ldir 
12ea			 
12ea					; de is past string, move back one and store id 
12ea					 
12ea					dec de 
12ea			 
12ea					; store file id 
12ea			 
12ea					pop hl 
12ea					ex de,hl 
12ea					ld (hl), e 
12ea			 
12ea					if DEBUG_FORTH_WORDS 
12ea						DMARK "Cdi" 
12ea						CALLMONITOR 
12ea					endif 
12ea					 
12ea			.dirnotfound: 
12ea					pop bc     
12ea					djnz .diritem 
12ea				 
12ea			.dirdone:	 
12ea			 
12ea					ld a, 0 
12ea					ld hl, (store_tmp2) 
12ea					ld (hl), a 
12ea					inc hl 
12ea					ld (hl), a 
12ea					inc hl 
12ea					; push a count of the dir items found 
12ea			 
12ea			;		ld h, 0 
12ea			;		ld l, c 
12ea			 
12ea				ret 
12ea			 
12ea			endif 
12ea			 
12ea			 
12ea			; Settings 
12ea			; Run  
12ea			 
12ea			 
12ea			 
12ea			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
12ea			;;hd_menu2:   db "        2: Editor",0   
12ea			;hd_menu2:   db "        2: Editor       6: Menu",0   
12ea			;hd_menu3:   db "        3: Storage",0 
12ea			;hd_menu4:   db "0=quit  4: Debug",0 
12ea			;hd_don:     db "ON",0 
12ea			;hd_doff:     db "OFF",0 
12ea			; 
12ea			; 
12ea			; 
12ea			;hardware_diags_old:       
12ea			; 
12ea			;.diagmenu: 
12ea			;	call clear_display 
12ea			;	ld a, display_row_1 
12ea			;	ld de, hd_menu1 
12ea			;	call str_at_display 
12ea			; 
12ea			;	ld a, display_row_2 
12ea			;	ld de, hd_menu2 
12ea			;	call str_at_display 
12ea			; 
12ea			;	ld a, display_row_3 
12ea			;	ld de, hd_menu3 
12ea			;	call str_at_display 
12ea			; 
12ea			;	ld a,  display_row_4 
12ea			;	ld de, hd_menu4 
12ea			;	call str_at_display 
12ea			; 
12ea			;	; display debug state 
12ea			; 
12ea			;	ld de, hd_don 
12ea			;	ld a, (os_view_disable) 
12ea			;	cp 0 
12ea			;	jr z, .distog 
12ea			;	ld de, hd_doff 
12ea			;.distog: ld a, display_row_4+17 
12ea			;	call str_at_display 
12ea			; 
12ea			;	call update_display 
12ea			; 
12ea			;	call cin_wait 
12ea			; 
12ea			; 
12ea			; 
12ea			;	cp '4' 
12ea			;	jr nz, .diagn1 
12ea			; 
12ea			;	; debug toggle 
12ea			; 
12ea			;	ld a, (os_view_disable) 
12ea			;	ld b, '*' 
12ea			;	cp 0 
12ea			;	jr z, .debtog 
12ea			;	ld b, 0 
12ea			;.debtog:	 
12ea			;	ld a,b 
12ea			;	ld (os_view_disable),a 
12ea			; 
12ea			;.diagn1: cp '0' 
12ea			;	 ret z 
12ea			; 
12ea			;;	cp '1' 
12ea			;;       jp z, matrix	 
12ea			;;   TODO keyboard matrix test 
12ea			; 
12ea			;	cp '2' 
12ea			;	jp z, .diagedit 
12ea			; 
12ea			;;	cp '6' 
12ea			;;	jp z, .menutest 
12ea			;;if ENABLE_BASIC 
12ea			;;	cp '6' 
12ea			;;	jp z, basic 
12ea			;;endif 
12ea			 ; 
12ea			;	jp .diagmenu 
12ea			; 
12ea			; 
12ea			;	ret 
12ea			 
12ea			 
12ea			.debug_tog: 
12ea 21 31 13			ld hl, .menudebug 
12ed				 
12ed 3a 51 e3			ld a, (os_view_disable) 
12f0 fe 2a			cp '*' 
12f2 20 04			jr nz,.tdon  
12f4 3e 01			ld a, 1 
12f6 18 02			jr .tog1 
12f8 3e 00		.tdon: ld a, 0 
12fa			 
12fa			.tog1: 
12fa cd b9 09			call menu 
12fd fe 00			cp 0 
12ff c8				ret z 
1300 fe 01			cp 1    ; disable debug 
1302 28 04			jr z, .dtog0 
1304 3e 2a			ld a, '*' 
1306 18 02			jr .dtogset 
1308 3e 00		.dtog0: ld a, 0 
130a 32 51 e3		.dtogset:  ld (os_view_disable), a 
130d c3 ea 12			jp .debug_tog 
1310			 
1310			 
1310			hardware_diags:       
1310			 
1310			.diagm: 
1310 21 23 13			ld hl, .menuitems 
1313 3e 00			ld a, 0 
1315 cd b9 09			call menu 
1318			 
1318 fe 00		         cp 0 
131a c8				 ret z 
131b			 
131b fe 02			cp 2 
131d ca 7c 13			jp z, .diagedit 
1320			 
1320			;	cp '6' 
1320			;	jp z, .menutest 
1320			;if ENABLE_BASIC 
1320			;	cp '6' 
1320			;	jp z, basic 
1320			;endif 
1320			  
1320 c3 10 13			jp .diagm 
1323			 
1323				 
1323 37 13		.menuitems:   	dw .m1 
1325 42 13				dw .m2 
1327 49 13				dw .m3 
1329 51 13				dw .m5 
132b 57 13				dw .m5a 
132d 60 13				dw .m5b 
132f 00 00				dw 0 
1331			 
1331			.menudebug: 
1331 69 13				dw .m6 
1333 72 13				dw .m7 
1335 00 00				dw 0 
1337			 
1337 .. 00		.m1:   db "Key Matrix",0 
1342 .. 00		.m2:   db "Editor",0 
1349 .. 00		.m3:   db "Storage",0 
1351 .. 00		.m5:   db "Sound",0 
1357 .. 00		.m5a:  db "RAM Test",0 
1360 .. 00		.m5b:  db "LCD Test",0 
1369			 
1369 .. 00		.m6:   db "Debug ON",0 
1372 .. 00		.m7:   db "Debug OFF",0 
137c			 
137c			; debug editor 
137c			 
137c			.diagedit: 
137c			 
137c 21 60 e3			ld hl, scratch 
137f			;	ld bc, 250 
137f			;	ldir 
137f				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
137f 3e 00			ld a, 0 
1381 77				ld (hl), a 
1382 23				inc hl 
1383 77				ld (hl), a 
1384 23				inc hl 
1385 77				ld (hl), a 
1386			 
1386 cd 88 09		        call clear_display 
1389 cd ab 09			call update_display 
138c 3e 01			ld a, 1 
138e 32 80 ee			ld (hardware_diag), a 
1391			.diloop: 
1391 3e 00			ld a, display_row_1 
1393 0e 00			ld c, 0 
1395 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1397 1e 28			ld e, 40 
1399			 
1399 21 60 e3			ld hl, scratch	 
139c cd e2 0b			call input_str 
139f			 
139f 3e 28			ld a, display_row_2 
13a1 11 60 e3			ld de, scratch 
13a4 cd 9b 09			call str_at_display 
13a7 cd ab 09			call update_display 
13aa			 
13aa c3 91 13			jp .diloop 
13ad			 
13ad			 
13ad			; pass word in hl 
13ad			; a has display location 
13ad			display_word_at: 
13ad f5				push af 
13ae e5				push hl 
13af 7c				ld a,h 
13b0 21 65 e6			ld hl, os_word_scratch 
13b3 cd b6 0e			call hexout 
13b6 e1				pop hl 
13b7 7d				ld a,l 
13b8 21 67 e6			ld hl, os_word_scratch+2 
13bb cd b6 0e			call hexout 
13be 21 69 e6			ld hl, os_word_scratch+4 
13c1 3e 00			ld a,0 
13c3 77				ld (hl),a 
13c4 11 65 e6			ld de,os_word_scratch 
13c7 f1				pop af 
13c8 cd 9b 09				call str_at_display 
13cb c9				ret 
13cc			 
13cc			display_ptr_state: 
13cc			 
13cc				; to restore afterwards 
13cc			 
13cc d5				push de 
13cd c5				push bc 
13ce e5				push hl 
13cf f5				push af 
13d0			 
13d0				; for use in here 
13d0			 
13d0			;	push bc 
13d0			;	push de 
13d0			;	push hl 
13d0			;	push af 
13d0			 
13d0 cd 88 09			call clear_display 
13d3			 
13d3 11 a6 15			ld de, .ptrstate 
13d6 3e 00			ld a, display_row_1 
13d8 cd 9b 09			call str_at_display 
13db			 
13db				; display debug step 
13db			 
13db			 
13db 11 7a ee			ld de, debug_mark 
13de 3e 26			ld a, display_row_1+display_cols-2 
13e0 cd 9b 09			call str_at_display 
13e3			 
13e3				; display a 
13e3 11 b0 15			ld de, .ptrcliptr 
13e6 3e 28			ld a, display_row_2 
13e8 cd 9b 09			call str_at_display 
13eb			 
13eb f1				pop af 
13ec 2a 2b eb			ld hl,(cli_ptr) 
13ef 3e 30			ld a, display_row_2+8 
13f1 cd ad 13			call display_word_at 
13f4			 
13f4			 
13f4				; display hl 
13f4			 
13f4			 
13f4 11 b8 15			ld de, .ptrclioptr 
13f7 3e 32			ld a, display_row_2+10 
13f9 cd 9b 09			call str_at_display 
13fc			; 
13fc			;	pop hl 
13fc 3e 35			ld a, display_row_2+13 
13fe 2a 29 eb			ld hl,(cli_origptr) 
1401 cd ad 13			call display_word_at 
1404			; 
1404			;	 
1404			;	; display de 
1404			 
1404			;	ld de, .regstatede 
1404			;	ld a, display_row_3 
1404			;	call str_at_display 
1404			 
1404			;	pop de 
1404			;	ld h,d 
1404			;	ld l, e 
1404			;	ld a, display_row_3+3 
1404			;	call display_word_at 
1404			 
1404			 
1404				; display bc 
1404			 
1404			;	ld de, .regstatebc 
1404			;	ld a, display_row_3+10 
1404			;	call str_at_display 
1404			 
1404			;	pop bc 
1404			;	ld h,b 
1404			;	ld l, c 
1404			;	ld a, display_row_3+13 
1404			;	call display_word_at 
1404			 
1404			 
1404				; display dsp 
1404			 
1404			;	ld de, .regstatedsp 
1404			;	ld a, display_row_4 
1404			;	call str_at_display 
1404			 
1404				 
1404			;	ld hl,(cli_data_sp) 
1404			;	ld a, display_row_4+4 
1404			;	call display_word_at 
1404			 
1404				; display rsp 
1404			 
1404 11 e7 15			ld de, .regstatersp 
1407 3e 82			ld a, display_row_4+10 
1409 cd 9b 09			call str_at_display 
140c			 
140c				 
140c 2a 11 eb			ld hl,(cli_ret_sp) 
140f 3e 86			ld a, display_row_4+14 
1411 cd ad 13			call display_word_at 
1414			 
1414 cd ab 09			call update_display 
1417			 
1417 cd fd 08			call delay1s 
141a cd fd 08			call delay1s 
141d cd fd 08			call delay1s 
1420			 
1420			 
1420 cd 2d 19			call next_page_prompt 
1423			 
1423				; restore  
1423			 
1423 f1				pop af 
1424 e1				pop hl 
1425 c1				pop bc 
1426 d1				pop de 
1427 c9				ret 
1428			 
1428			break_point_state: 
1428 f5				push af 
1429			 
1429				; see if disabled 
1429			 
1429 3a 51 e3			ld a, (os_view_disable) 
142c fe 2a			cp '*' 
142e 20 02			jr nz, .bpsgo 
1430 f1				pop af 
1431 c9				ret 
1432			 
1432			.bpsgo: 
1432 f1				pop af 
1433 f5				push af 
1434 22 4d e3			ld (os_view_hl), hl 
1437 ed 53 4b e3		ld (os_view_de), de 
143b ed 43 49 e3		ld (os_view_bc), bc 
143f e5				push hl 
1440 6f				ld l, a 
1441 26 00			ld h, 0 
1443 22 4f e3			ld (os_view_af),hl 
1446			 
1446 21 c0 ed				ld hl, display_fb0 
1449 22 db eb				ld (display_fb_active), hl 
144c e1				pop hl	 
144d			 
144d 3e 31			ld a, '1' 
144f fe 2a		.bps1:  cp '*' 
1451 20 03			jr nz, .bps1b 
1453 32 51 e3			ld (os_view_disable),a 
1456 fe 31		.bps1b:  cp '1' 
1458 20 14			jr nz, .bps2 
145a			 
145a				; display reg 
145a			 
145a				 
145a			 
145a 3a 4f e3			ld a, (os_view_af) 
145d 2a 4d e3			ld hl, (os_view_hl) 
1460 ed 5b 4b e3		ld de, (os_view_de) 
1464 ed 4b 49 e3		ld bc, (os_view_bc) 
1468 cd 02 15			call display_reg_state 
146b c3 ee 14			jp .bpschk 
146e			 
146e fe 32		.bps2:  cp '2' 
1470 20 08			jr nz, .bps3 
1472				 
1472				; display hl 
1472 2a 4d e3			ld hl, (os_view_hl) 
1475 cd ec 15			call display_dump_at_hl 
1478			 
1478 18 74			jr .bpschk 
147a			 
147a fe 33		.bps3:  cp '3' 
147c 20 08			jr nz, .bps4 
147e			 
147e			        ; display de 
147e 2a 4b e3			ld hl, (os_view_de) 
1481 cd ec 15			call display_dump_at_hl 
1484			 
1484 18 68			jr .bpschk 
1486 fe 34		.bps4:  cp '4' 
1488 20 08			jr nz, .bps5 
148a			 
148a			        ; display bc 
148a 2a 49 e3			ld hl, (os_view_bc) 
148d cd ec 15			call display_dump_at_hl 
1490			 
1490 18 5c			jr .bpschk 
1492 fe 35		.bps5:  cp '5' 
1494 20 08		        jr nz, .bps7 
1496			 
1496				; display cur ptr 
1496 2a 2b eb			ld hl, (cli_ptr) 
1499 cd ec 15			call display_dump_at_hl 
149c			 
149c 18 50			jr .bpschk 
149e fe 36		.bps7:  cp '6' 
14a0 20 08			jr nz, .bps8b 
14a2				 
14a2				; display cur orig ptr 
14a2 2a 29 eb			ld hl, (cli_origptr) 
14a5 cd ec 15			call display_dump_at_hl 
14a8 18 44			jr .bpschk 
14aa fe 37		.bps8b:  cp '7' 
14ac 20 08			jr nz, .bps9 
14ae				 
14ae				; display dsp 
14ae 2a 0d eb			ld hl, (cli_data_sp) 
14b1 cd ec 15			call display_dump_at_hl 
14b4			 
14b4 18 38			jr .bpschk 
14b6 fe 39		.bps9:  cp '9' 
14b8 20 05			jr nz, .bps8c 
14ba				 
14ba				; display SP 
14ba			;	ld hl, sp 
14ba cd ec 15			call display_dump_at_hl 
14bd			 
14bd 18 2f			jr .bpschk 
14bf fe 38		.bps8c:  cp '8' 
14c1 20 08			jr nz, .bps8d 
14c3				 
14c3				; display rsp 
14c3 2a 11 eb			ld hl, (cli_ret_sp) 
14c6 cd ec 15			call display_dump_at_hl 
14c9			 
14c9 18 23			jr .bpschk 
14cb fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14cd 20 05			jr nz, .bps8 
14cf cd 23 17			call monitor 
14d2			 
14d2 18 1a			jr .bpschk 
14d4 fe 30		.bps8:  cp '0' 
14d6 20 16			jr nz, .bpschk 
14d8			 
14d8 21 1f ed				ld hl, display_fb1 
14db 22 db eb				ld (display_fb_active), hl 
14de cd ab 09				call update_display 
14e1			 
14e1				;ld a, (os_view_af) 
14e1 2a 4d e3			ld hl, (os_view_hl) 
14e4 ed 5b 4b e3		ld de, (os_view_de) 
14e8 ed 4b 49 e3		ld bc, (os_view_bc) 
14ec f1				pop af 
14ed c9				ret 
14ee			 
14ee			.bpschk:   
14ee cd fd 08			call delay1s 
14f1 3e 9f		ld a,display_row_4 + display_cols - 1 
14f3 11 2b 19		        ld de, endprg 
14f6 cd 9b 09			call str_at_display 
14f9 cd ab 09			call update_display 
14fc cd 71 58			call cin_wait 
14ff			 
14ff c3 4f 14			jp .bps1 
1502			 
1502			 
1502			display_reg_state: 
1502			 
1502				; to restore afterwards 
1502			 
1502 d5				push de 
1503 c5				push bc 
1504 e5				push hl 
1505 f5				push af 
1506			 
1506				; for use in here 
1506			 
1506 c5				push bc 
1507 d5				push de 
1508 e5				push hl 
1509 f5				push af 
150a			 
150a cd 88 09			call clear_display 
150d			 
150d 11 c2 15			ld de, .regstate 
1510 3e 00			ld a, display_row_1 
1512 cd 9b 09			call str_at_display 
1515			 
1515				; display debug step 
1515			 
1515			 
1515 11 7a ee			ld de, debug_mark 
1518 3e 25			ld a, display_row_1+display_cols-3 
151a cd 9b 09			call str_at_display 
151d			 
151d				; display a 
151d 11 de 15			ld de, .regstatea 
1520 3e 28			ld a, display_row_2 
1522 cd 9b 09			call str_at_display 
1525			 
1525 e1				pop hl 
1526			;	ld h,0 
1526			;	ld l, a 
1526 3e 2b			ld a, display_row_2+3 
1528 cd ad 13			call display_word_at 
152b			 
152b			 
152b				; display hl 
152b			 
152b			 
152b 11 d2 15			ld de, .regstatehl 
152e 3e 32			ld a, display_row_2+10 
1530 cd 9b 09			call str_at_display 
1533			 
1533 e1				pop hl 
1534 3e 35			ld a, display_row_2+13 
1536 cd ad 13			call display_word_at 
1539			 
1539				 
1539				; display de 
1539			 
1539 11 d6 15			ld de, .regstatede 
153c 3e 50			ld a, display_row_3 
153e cd 9b 09			call str_at_display 
1541			 
1541 e1				pop hl 
1542			;	ld h,d 
1542			;	ld l, e 
1542 3e 53			ld a, display_row_3+3 
1544 cd ad 13			call display_word_at 
1547			 
1547			 
1547				; display bc 
1547			 
1547 11 da 15			ld de, .regstatebc 
154a 3e 5a			ld a, display_row_3+10 
154c cd 9b 09			call str_at_display 
154f			 
154f e1				pop hl 
1550			;	ld h,b 
1550			;	ld l, c 
1550 3e 5d			ld a, display_row_3+13 
1552 cd ad 13			call display_word_at 
1555			 
1555			 
1555				; display dsp 
1555			 
1555 11 e2 15			ld de, .regstatedsp 
1558 3e 78			ld a, display_row_4 
155a cd 9b 09			call str_at_display 
155d			 
155d				 
155d 2a 0d eb			ld hl,(cli_data_sp) 
1560 3e 7c			ld a, display_row_4+4 
1562 cd ad 13			call display_word_at 
1565			 
1565				; display rsp 
1565			 
1565 11 e7 15			ld de, .regstatersp 
1568 3e 82			ld a, display_row_4+10 
156a cd 9b 09			call str_at_display 
156d			 
156d				 
156d 2a 11 eb			ld hl,(cli_ret_sp) 
1570 3e 86			ld a, display_row_4+14 
1572 cd ad 13			call display_word_at 
1575			 
1575 cd ab 09			call update_display 
1578			 
1578			;	call delay1s 
1578			;	call delay1s 
1578			;	call delay1s 
1578			 
1578			 
1578			;	call next_page_prompt 
1578			 
1578				; restore  
1578			 
1578 f1				pop af 
1579 e1				pop hl 
157a c1				pop bc 
157b d1				pop de 
157c c9				ret 
157d			 
157d .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1591 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
15a6 .. 00		.ptrstate:	db "Ptr State",0 
15b0 .. 00		.ptrcliptr:     db "cli_ptr",0 
15b8 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
15c2 .. 00		.regstate:	db "Reg State (1/0)",0 
15d2 .. 00		.regstatehl:	db "HL:",0 
15d6 .. 00		.regstatede:	db "DE:",0 
15da .. 00		.regstatebc:	db "BC:",0 
15de .. 00		.regstatea:	db "A :",0 
15e2 .. 00		.regstatedsp:	db "DSP:",0 
15e7 .. 00		.regstatersp:	db "RSP:",0 
15ec			 
15ec			display_dump_at_hl: 
15ec e5				push hl 
15ed d5				push de 
15ee c5				push bc 
15ef f5				push af 
15f0			 
15f0 22 83 e6			ld (os_cur_ptr),hl	 
15f3 cd 88 09			call clear_display 
15f6 cd 35 18			call dumpcont 
15f9			;	call delay1s 
15f9			;	call next_page_prompt 
15f9			 
15f9			 
15f9 f1				pop af 
15fa c1				pop bc 
15fb d1				pop de 
15fc e1				pop hl 
15fd c9				ret 
15fe			 
15fe			;if ENABLE_BASIC 
15fe			;	include "nascombasic.asm" 
15fe			;	basic: 
15fe			;	include "forth/FORTH.ASM" 
15fe			;endif 
15fe			 
15fe			; eof 
15fe			 
15fe			 
# End of file firmware_diags.asm
15fe			  
15fe			  
15fe			  
15fe			  
15fe			; eof  
15fe			  
# End of file firmware.asm
15fe			 
15fe			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
15fe			;if BASE_KEV  
15fe			;baseram: equ 08000h 
15fe			;endif 
15fe			 
15fe			;if BASE_SC114 
15fe			;baseram:     equ    endofcode 
15fe			;endif 
15fe			 
15fe			 
15fe			; start system 
15fe			 
15fe			coldstart: 
15fe				; set sp 
15fe				; di/ei 
15fe			 
15fe f3				di 
15ff 31 00 f0			ld sp, tos 
1602			;	ei 
1602			 
1602			 
1602				; disable breakpoint by default 
1602			 
1602 3e 2a			ld a,'*' 
1604 32 51 e3			ld (os_view_disable),a 
1607			 
1607				; init hardware 
1607			 
1607				; init keyboard and screen hardware 
1607			 
1607 cd 03 01			call hardware_init 
160a			 
160a			 
160a				; detect if any keys are held down to enable breakpoints at start up 
160a			 
160a cd 79 58			call cin  
160d fe 00			cp 0 
160f 28 03			jr z, .nokeys 
1611			 
1611				;call hardware_diags 
1611 cd 15 12			call config 
1614			 
1614			;	ld de, .bpen 
1614			;	ld a, display_row_4 
1614			;	call str_at_display 
1614			;	call update_display 
1614			; 
1614			;	ld a,0 
1614			;	ld (os_view_disable),a 
1614			; 
1614			;.bpwait: 
1614			;	call cin 
1614			;	cp 0 
1614			;	jr z, .bpwait 
1614			;	jr .nokeys 
1614			; 
1614			; 
1614			;.bpen:  db "Break points enabled!",0 
1614			 
1614			 
1614			 
1614			 
1614			 
1614			 
1614			.nokeys: 
1614			 
1614			 
1614				 
1614			 
1614			;jp  testkey 
1614			 
1614			;call storage_get_block_0 
1614			; 
1614			;ld hl, 0 
1614			;ld de, store_page 
1614			;call storage_read_block 
1614			 
1614				 
1614			;ld hl, 10 
1614			;ld de, store_page 
1614			;call storage_read_block 
1614			 
1614			 
1614			 
1614			 
1614			 
1614			;stop:	nop 
1614			;	jp stop 
1614			 
1614			 
1614			 
1614			main: 
1614 cd 88 09			call clear_display 
1617 cd ab 09			call update_display 
161a			 
161a			 
161a			 
161a			;	call testlcd 
161a			 
161a			 
161a			 
161a cd f3 1c			call forth_init 
161d			 
161d			 
161d			warmstart: 
161d cd c9 1c			call forth_warmstart 
1620			 
1620				; run startup word load 
1620			        ; TODO prevent this running at warmstart after crash  
1620			 
1620				if STARTUP_ENABLE 
1620					if STORAGE_SE 
1620						call forth_autoload 
1620					endif 
1620 cd bf 54				call forth_startup 
1623			 
1623			 
1623				endif 
1623			 
1623				; show free memory after boot 
1623 11 bd 16			ld de, freeram 
1626 3e 00			ld a, display_row_1 
1628 cd 9b 09			call str_at_display 
162b			 
162b			; Or use heap_size word???? 
162b 21 46 e3			ld hl, heap_end 
162e 11 a1 58			ld de, heap_start 
1631 ed 52			sbc hl, de 
1633 e5				push hl 
1634 7c				ld a,h	         	 
1635 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1638 cd b6 0e			call hexout 
163b e1			   	pop hl 
163c			 
163c 7d				ld a,l 
163d 21 67 e6			ld hl, os_word_scratch+2 
1640 cd b6 0e			call hexout 
1643 21 69 e6			ld hl, os_word_scratch+4 
1646 3e 00			ld a, 0 
1648 77				ld (hl),a 
1649 11 65 e6			ld de, os_word_scratch 
164c 3e 0d			ld a, display_row_1 + 13 
164e cd 9b 09			call str_at_display 
1651 cd ab 09			call update_display 
1654			 
1654			 
1654				;call demo 
1654			 
1654			 
1654				; init scratch input area for cli commands 
1654			 
1654 21 87 e6			ld hl, os_cli_cmd 
1657 3e 00			ld a,0 
1659 77				ld (hl),a 
165a 23				inc hl 
165b 77				ld (hl),a 
165c			 
165c 3e 00			ld a,0 
165e 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1661			 
1661 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1664 32 84 e6			ld (os_cur_ptr+1),a	 
1667			 
1667 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
166a 32 66 e6			ld (os_word_scratch+1),a	 
166d				 
166d			 
166d				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
166d 21 87 e6			ld hl, os_cli_cmd 
1670			 
1670 3e 00			ld a, 0		 ; init cli input 
1672 77				ld (hl), a 
1673 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1675			cli: 
1675				; show cli prompt 
1675				;push af 
1675				;ld a, 0 
1675				;ld de, prompt 
1675				;call str_at_display 
1675			 
1675				;call update_display 
1675				;pop af 
1675				;inc a 
1675				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1675 0e 00			ld c, 0 
1677 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1679 1e 28			ld e, 40 
167b			 
167b 21 87 e6			ld hl, os_cli_cmd 
167e			 
167e				STACKFRAME OFF $fefe $9f9f 
167e				if DEBUG_STACK_IMB 
167e					if OFF 
167e						exx 
167e						ld de, $fefe 
167e						ld a, d 
167e						ld hl, curframe 
167e						call hexout 
167e						ld a, e 
167e						ld hl, curframe+2 
167e						call hexout 
167e						ld hl, $fefe 
167e						push hl 
167e						ld hl, $9f9f 
167e						push hl 
167e						exx 
167e					endif 
167e				endif 
167e			endm 
# End of macro STACKFRAME
167e			 
167e cd e2 0b			call input_str 
1681			 
1681				STACKFRAMECHK OFF $fefe $9f9f 
1681				if DEBUG_STACK_IMB 
1681					if OFF 
1681						exx 
1681						ld hl, $9f9f 
1681						pop de   ; $9f9f 
1681						call cmp16 
1681						jr nz, .spnosame 
1681						ld hl, $fefe 
1681						pop de   ; $fefe 
1681						call cmp16 
1681						jr z, .spfrsame 
1681						.spnosame: call showsperror 
1681						.spfrsame: nop 
1681						exx 
1681					endif 
1681				endif 
1681			endm 
# End of macro STACKFRAMECHK
1681			 
1681				; copy input to last command 
1681			 
1681 21 87 e6			ld hl, os_cli_cmd 
1684 11 86 e7			ld de, os_last_cmd 
1687 01 ff 00			ld bc, 255 
168a ed b0			ldir 
168c			 
168c				; wipe current buffer 
168c			 
168c			;	ld a, 0 
168c			;	ld hl, os_cli_cmd 
168c			;	ld de, os_cli_cmd+1 
168c			;	ld bc, 254 
168c			;	ldir 
168c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
168c			;	call strcpy 
168c			;	ld a, 0 
168c			;	ld (hl), a 
168c			;	inc hl 
168c			;	ld (hl), a 
168c			;	inc hl 
168c			;	ld (hl), a 
168c			 
168c				; switch frame buffer to program  
168c			 
168c 21 1f ed				ld hl, display_fb1 
168f 22 db eb				ld (display_fb_active), hl 
1692			 
1692			;	nop 
1692				STACKFRAME ON $fbfe $8f9f 
1692				if DEBUG_STACK_IMB 
1692					if ON 
1692						exx 
1692						ld de, $fbfe 
1692						ld a, d 
1692						ld hl, curframe 
1692						call hexout 
1692						ld a, e 
1692						ld hl, curframe+2 
1692						call hexout 
1692						ld hl, $fbfe 
1692						push hl 
1692						ld hl, $8f9f 
1692						push hl 
1692						exx 
1692					endif 
1692				endif 
1692			endm 
# End of macro STACKFRAME
1692				; first time into the parser so pass over the current scratch pad 
1692 21 87 e6			ld hl,os_cli_cmd 
1695				; tokenise the entered statement(s) in HL 
1695 cd 6c 1d			call forthparse 
1698			        ; exec forth statements in top of return stack 
1698 cd ac 1d			call forthexec 
169b				;call forthexec_cleanup 
169b			;	call parsenext 
169b			 
169b				STACKFRAMECHK ON $fbfe $8f9f 
169b				if DEBUG_STACK_IMB 
169b					if ON 
169b						exx 
169b						ld hl, $8f9f 
169b						pop de   ; $8f9f 
169b						call cmp16 
169b						jr nz, .spnosame 
169b						ld hl, $fbfe 
169b						pop de   ; $fbfe 
169b						call cmp16 
169b						jr z, .spfrsame 
169b						.spnosame: call showsperror 
169b						.spfrsame: nop 
169b						exx 
169b					endif 
169b				endif 
169b			endm 
# End of macro STACKFRAMECHK
169b				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
169b			 
169b 3e 78			ld a, display_row_4 
169d 11 cf 16			ld de, endprog 
16a0			 
16a0 cd ab 09			call update_display		 
16a3			 
16a3 cd 2d 19			call next_page_prompt 
16a6			 
16a6				; switch frame buffer to cli 
16a6			 
16a6 21 c0 ed				ld hl, display_fb0 
16a9 22 db eb				ld (display_fb_active), hl 
16ac			 
16ac			 
16ac cd 88 09		        call clear_display 
16af cd ab 09			call update_display		 
16b2			 
16b2 21 87 e6			ld hl, os_cli_cmd 
16b5			 
16b5 3e 00			ld a, 0		 ; init cli input 
16b7 77				ld (hl), a 
16b8			 
16b8				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
16b8			 
16b8				; now on last line 
16b8			 
16b8				; TODO scroll screen up 
16b8			 
16b8				; TODO instead just clear screen and place at top of screen 
16b8			 
16b8			;	ld a, 0 
16b8			;	ld (f_cursor_ptr),a 
16b8			 
16b8				;call clear_display 
16b8				;call update_display 
16b8			 
16b8				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16b8 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16ba c3 75 16			jp cli 
16bd			 
16bd .. 00		freeram: db "Free bytes: $",0 
16cb ..			asc: db "1A2F" 
16cf .. 00		endprog: db "End prog...",0 
16db			 
16db			testenter2:   
16db 21 92 e3			ld hl,scratch+50 
16de 22 83 e6			ld (os_cur_ptr),hl 
16e1 c3 75 16			jp cli 
16e4			 
16e4			testenter:  
16e4			 
16e4 21 cb 16			ld hl,asc 
16e7			;	ld a,(hl) 
16e7			;	call nibble2val 
16e7 cd 0c 0f			call get_byte 
16ea			 
16ea			 
16ea			;	ld a,(hl) 
16ea			;	call atohex 
16ea			 
16ea			;	call fourehexhl 
16ea 32 92 e3			ld (scratch+50),a 
16ed			 
16ed			 
16ed			 
16ed 21 cd 16			ld hl,asc+2 
16f0			;	ld a, (hl) 
16f0			;	call nibble2val 
16f0 cd 0c 0f			call get_byte 
16f3			 
16f3			;	call fourehexhl 
16f3 32 94 e3			ld (scratch+52),a 
16f6				 
16f6 21 92 e3			ld hl,scratch+50 
16f9 22 83 e6			ld (os_cur_ptr),hl 
16fc c3 75 16			jp cli 
16ff			 
16ff			enter:	 
16ff 3a 64 e3			ld a,(scratch+4) 
1702 fe 00			cp 0 
1704 28 0c			jr z, .entercont 
1706				; no, not a null term line so has an address to work out.... 
1706			 
1706 21 62 e3			ld hl,scratch+2 
1709 cd 6c 0f			call get_word_hl 
170c			 
170c 22 83 e6			ld (os_cur_ptr),hl	 
170f c3 75 16			jp cli 
1712			 
1712			 
1712			.entercont:  
1712			 
1712 21 62 e3			ld hl, scratch+2 
1715 cd 0c 0f			call get_byte 
1718			 
1718 2a 83 e6		   	ld hl,(os_cur_ptr) 
171b 77					ld (hl),a 
171c 23					inc hl 
171d 22 83 e6				ld (os_cur_ptr),hl 
1720				 
1720			; get byte  
1720			 
1720			 
1720 c3 75 16			jp cli 
1723			 
1723			 
1723			; basic monitor support 
1723			 
1723			monitor: 
1723				;  
1723 cd 88 09			call clear_display 
1726 3e 00			ld a, 0 
1728 11 70 17			ld de, .monprompt 
172b cd 9b 09			call str_at_display 
172e cd ab 09			call update_display 
1731			 
1731				; get a monitor command 
1731			 
1731 0e 00			ld c, 0     ; entry at top left 
1733 16 64			ld d, 100   ; max buffer size 
1735 1e 0f			ld e, 15    ; input scroll area 
1737 3e 00			ld a, 0     ; init string 
1739 21 5e e5			ld hl, os_input 
173c 77				ld (hl), a 
173d 23				inc hl 
173e 77				ld (hl), a 
173f 21 5e e5			ld hl, os_input 
1742 3e 01			ld a, 1     ; init string 
1744 cd e2 0b			call input_str 
1747			 
1747 cd 88 09		        call clear_display 
174a cd ab 09			call update_display		 
174d			 
174d 3a 5e e5			ld a, (os_input) 
1750 cd 0a 10			call toUpper 
1753 fe 48		        cp 'H' 
1755 28 6f		        jr z, .monhelp 
1757 fe 44			cp 'D'		; dump 
1759 ca e7 17			jp z, .mondump	 
175c fe 43			cp 'C'		; dump 
175e ca 01 18			jp z, .moncdump	 
1761 fe 4d			cp 'M'		; dump 
1763 ca 72 17			jp z, .moneditstart 
1766 fe 55			cp 'U'		; dump 
1768 28 14			jr z, .monedit	 
176a fe 51			cp 'Q'		; dump 
176c c8				ret z	 
176d			 
176d			 
176d				; TODO "S" to access symbol by name and not need the address 
176d				; TODO "F" to find a string in memory 
176d			 
176d c3 23 17			jp monitor 
1770			 
1770 .. 00		.monprompt: db ">", 0 
1772			 
1772			.moneditstart: 
1772				; get starting address 
1772			 
1772 21 60 e5			ld hl,os_input+2 
1775 cd 6c 0f			call get_word_hl 
1778			 
1778 22 83 e6			ld (os_cur_ptr),hl	 
177b			 
177b c3 23 17			jp monitor 
177e			 
177e			.monedit: 
177e				; get byte to load 
177e			 
177e 21 60 e5			ld hl,os_input+2 
1781 cd 0c 0f			call get_byte 
1784			 
1784				; get address to update 
1784 2a 83 e6			ld hl, (os_cur_ptr) 
1787			 
1787				; update byte 
1787			 
1787 77				ld (hl), a 
1788			 
1788				; move to next address and save it 
1788			 
1788 23				inc hl 
1789 22 83 e6			ld (os_cur_ptr),hl	 
178c			 
178c c3 23 17			jp monitor 
178f			 
178f			 
178f .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
17a3 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
17bf .. 00		.monhelptext3:  db "Q-Quit",0 
17c6			        
17c6			.monhelp: 
17c6 3e 00			ld a, display_row_1 
17c8 11 8f 17		        ld de, .monhelptext1 
17cb			 
17cb cd 9b 09			call str_at_display 
17ce 3e 28			ld a, display_row_2 
17d0 11 a3 17		        ld de, .monhelptext2 
17d3					 
17d3 cd 9b 09			call str_at_display 
17d6 3e 50			ld a, display_row_3 
17d8 11 bf 17		        ld de, .monhelptext3 
17db					 
17db cd 9b 09			call str_at_display 
17de cd ab 09			call update_display		 
17e1			 
17e1 cd 2d 19			call next_page_prompt 
17e4 c3 23 17			jp monitor 
17e7			 
17e7			.mondump:    
17e7 21 60 e5			ld hl,os_input+2 
17ea cd 6c 0f			call get_word_hl 
17ed			 
17ed 22 83 e6			ld (os_cur_ptr),hl	 
17f0 cd 35 18			call dumpcont 
17f3 3e 78			ld a, display_row_4 
17f5 11 cf 16			ld de, endprog 
17f8			 
17f8 cd ab 09			call update_display		 
17fb			 
17fb cd 2d 19			call next_page_prompt 
17fe c3 23 17			jp monitor 
1801			.moncdump: 
1801 cd 35 18			call dumpcont 
1804 3e 78			ld a, display_row_4 
1806 11 cf 16			ld de, endprog 
1809			 
1809 cd ab 09			call update_display		 
180c			 
180c cd 2d 19			call next_page_prompt 
180f c3 23 17			jp monitor 
1812			 
1812			 
1812			; TODO symbol access  
1812			 
1812			.symbols:     ;; A list of symbols that can be called up  
1812 c0 ed			dw display_fb0 
1814 .. 00			db "fb0",0  
1818 65 eb		     	dw store_page 
181a .. 00			db "store_page",0 
1825			 
1825			 
1825			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1825			 
1825 3a 61 e3			ld a,(scratch+1) 
1828 fe 00			cp 0 
182a 28 09			jr z, dumpcont 
182c			 
182c				; no, not a null term line so has an address to work out.... 
182c			 
182c 21 62 e3			ld hl,scratch+2 
182f cd 6c 0f			call get_word_hl 
1832			 
1832 22 83 e6			ld (os_cur_ptr),hl	 
1835			 
1835			 
1835			 
1835			dumpcont: 
1835			 
1835				; dump bytes at ptr 
1835			 
1835			 
1835 3e 00			ld a, display_row_1 
1837 2a db eb			ld hl, (display_fb_active) 
183a cd b5 0b			call addatohl 
183d cd 65 18			call .dumpbyterow 
1840			 
1840 3e 28			ld a, display_row_2 
1842 2a db eb			ld hl, (display_fb_active) 
1845 cd b5 0b			call addatohl 
1848 cd 65 18			call .dumpbyterow 
184b			 
184b			 
184b 3e 50			ld a, display_row_3 
184d 2a db eb			ld hl, (display_fb_active) 
1850 cd b5 0b			call addatohl 
1853 cd 65 18			call .dumpbyterow 
1856			 
1856 3e 78			ld a, display_row_4 
1858 2a db eb			ld hl, (display_fb_active) 
185b cd b5 0b			call addatohl 
185e cd 65 18			call .dumpbyterow 
1861			 
1861 cd ab 09			call update_display 
1864			;		jp cli 
1864 c9				ret 
1865			 
1865			.dumpbyterow: 
1865			 
1865				;push af 
1865			 
1865 e5				push hl 
1866			 
1866				; calc where to poke the ascii 
1866			if display_cols == 20 
1866				ld a, 16 
1866			else 
1866 3e 1f			ld a, 31 
1868			endif 
1868			 
1868 cd b5 0b			call addatohl 
186b 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
186e			 
186e			 
186e			; display decoding address 
186e 2a 83 e6		   	ld hl,(os_cur_ptr) 
1871			 
1871 7c				ld a,h 
1872 e1				pop hl 
1873 e5				push hl 
1874			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1874 cd b6 0e			call hexout 
1877 2a 83 e6		   	ld hl,(os_cur_ptr) 
187a			 
187a 7d				ld a,l 
187b e1				pop hl 
187c 23				inc hl 
187d 23				inc hl 
187e e5				push hl 
187f			;	ld hl, os_word_scratch+2 
187f cd b6 0e			call hexout 
1882 e1				pop hl 
1883 23				inc hl 
1884 23				inc hl 
1885				;ld hl, os_word_scratch+4 
1885 3e 3a			ld a, ':' 
1887 77				ld (hl),a 
1888 23				inc hl 
1889				;ld a, 0 
1889				;ld (hl),a 
1889				;ld de, os_word_scratch 
1889				;pop af 
1889				;push af 
1889			;		ld a, display_row_2 
1889			;		call str_at_display 
1889			;		call update_display 
1889			 
1889			 
1889			;pop af 
1889			;	add 5 
1889			 
1889			if display_cols == 20 
1889				ld b, 4 
1889			else 
1889 06 08			ld b, 8 
188b			endif	 
188b			 
188b			.dumpbyte: 
188b c5				push bc 
188c e5				push hl 
188d			 
188d			 
188d 2a 83 e6		   	ld hl,(os_cur_ptr) 
1890 7e					ld a,(hl) 
1891			 
1891					; poke the ascii to display 
1891 2a 65 e6				ld hl,(os_word_scratch) 
1894 77					ld (hl),a 
1895 23					inc hl 
1896 22 65 e6				ld (os_word_scratch),hl 
1899			 
1899					 
1899			 
1899			 
1899 e1					pop hl 
189a e5					push hl 
189b			 
189b cd b6 0e				call hexout 
189e			 
189e					 
189e 2a 83 e6		   	ld hl,(os_cur_ptr) 
18a1 23				inc hl 
18a2 22 83 e6		   	ld (os_cur_ptr),hl 
18a5			 
18a5 e1					pop hl 
18a6 23					inc hl 
18a7 23					inc hl 
18a8 23					inc hl 
18a9			 
18a9			 
18a9			 
18a9					;ld a,0 
18a9					;ld (os_word_scratch+2),a 
18a9					;pop af 
18a9					;push af 
18a9			 
18a9					;ld de, os_word_scratch 
18a9					;call str_at_display 
18a9			;		call update_display 
18a9			;		pop af 
18a9 c1					pop bc 
18aa c6 03				add 3 
18ac 10 dd			djnz .dumpbyte 
18ae			 
18ae				 
18ae			 
18ae c9				ret 
18af			 
18af			jump:	 
18af			 
18af 21 62 e3			ld hl,scratch+2 
18b2 cd 6c 0f			call get_word_hl 
18b5				;ld hl,(scratch+2) 
18b5				;call fourehexhl 
18b5			 
18b5 22 83 e6			ld (os_cur_ptr),hl	 
18b8			 
18b8 e9				jp (hl) 
18b9			 
18b9			 
18b9			 
18b9			; TODO implement a basic monitor mode to start with 
18b9			 
18b9			 
18b9			 
18b9			 
18b9			 
18b9			 
18b9			 
18b9			 
18b9			 
18b9			; testing and demo code during development 
18b9			 
18b9			 
18b9 .. 00		str1: db "Enter some text...",0 
18cc .. 00		clear: db "                    ",0 
18e1			 
18e1			demo: 
18e1			 
18e1			 
18e1			 
18e1			;	call update_display 
18e1			 
18e1				; init scratch input area for testing 
18e1 21 60 e3			ld hl, scratch	 
18e4 3e 00			ld a,0 
18e6 77				ld (hl),a 
18e7			 
18e7			 
18e7 3e 28		            LD   A, display_row_2 
18e9			;            CALL fLCD_Pos       ;Position cursor to location in A 
18e9 11 b9 18		            LD   DE, str1 
18ec cd 9b 09			call str_at_display 
18ef			 
18ef			;            CALL fLCD_Str       ;Display string pointed to by DE 
18ef			cloop:	 
18ef 3e 50		            LD   A, display_row_3 
18f1			;            CALL fLCD_Pos       ;Position cursor to location in A 
18f1 11 cc 18		            LD   DE, clear 
18f4			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
18f4 cd 9b 09				call str_at_display 
18f7 3e 78			ld a, display_row_4 
18f9 11 29 19			ld de, prompt 
18fc			 
18fc cd 9b 09				call str_at_display 
18ff cd ab 09			call update_display 
1902			 
1902 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1904 16 0a			ld d, 10 
1906 21 60 e3			ld hl, scratch	 
1909 cd e2 0b			call input_str 
190c			 
190c			;	call clear_display 
190c			;'	call update_display 
190c			 
190c 3e 00		            LD   A, display_row_1 
190e			;            CALL fLCD_Pos       ;Position cursor to location in A 
190e 11 cc 18		            LD   DE, clear 
1911 cd 9b 09				call str_at_display 
1914			;            CALL fLCD_Str       ;Display string pointed to by DE 
1914 3e 00		            LD   A, display_row_1 
1916			;            CALL fLCD_Pos       ;Position cursor to location in A 
1916 11 60 e3		            LD   DE, scratch 
1919			;            CALL fLCD_Str       ;Display string pointed to by DE 
1919 cd 9b 09				call str_at_display 
191c cd ab 09			call update_display 
191f			 
191f 3e 00				ld a,0 
1921 21 60 e3			ld hl, scratch 
1924 77				ld (hl),a 
1925			 
1925 00				nop 
1926 c3 ef 18			jp cloop 
1929			 
1929			 
1929			 
1929			; OS Prompt 
1929			 
1929 .. 00		prompt: db ">",0 
192b .. 00		endprg: db "?",0 
192d			 
192d			 
192d			; handy next page prompt 
192d			next_page_prompt: 
192d e5				push hl 
192e d5				push de 
192f f5				push af 
1930 c5				push bc 
1931			 
1931 3e 9f			ld a,display_row_4 + display_cols - 1 
1933 11 2b 19		        ld de, endprg 
1936 cd 9b 09			call str_at_display 
1939 cd ab 09			call update_display 
193c cd 71 58			call cin_wait 
193f c1				pop bc 
1940 f1				pop af 
1941 d1				pop de 
1942 e1				pop hl 
1943			 
1943			 
1943 c9				ret 
1944			 
1944			 
1944			; forth parser 
1944			 
1944			; My forth kernel 
1944			include "forth_kernel.asm" 
1944			; 
1944			; kernel to the forth OS 
1944			 
1944			DS_TYPE_STR: equ 1     ; string type 
1944			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1944			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1944			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1944			 
1944			FORTH_PARSEV1: equ 0 
1944			FORTH_PARSEV2: equ 0 
1944			FORTH_PARSEV3: equ 0 
1944			FORTH_PARSEV4: equ 0 
1944			FORTH_PARSEV5: equ 1 
1944			 
1944			;if FORTH_PARSEV5 
1944			;	FORTH_END_BUFFER: equ 0 
1944			;else 
1944			FORTH_END_BUFFER: equ 127 
1944			;endif 
1944			 
1944			FORTH_TRUE: equ 1 
1944			FORTH_FALSE: equ 0 
1944			 
1944			if FORTH_PARSEV4 
1944			include "forth_stackops.asm" 
1944			endif 
1944			 
1944			if FORTH_PARSEV5 
1944			include "forth_stackopsv5.asm" 
1944			 
1944			; Stack operations for v5 parser on wards 
1944			; * DATA stack 
1944			; * LOOP stack 
1944			; * RETURN stack 
1944			 
1944			 
1944			 
1944			FORTH_CHK_DSP_UNDER: macro 
1944				push hl 
1944				push de 
1944				ld hl,(cli_data_sp) 
1944				ld de, cli_data_stack 
1944				call cmp16 
1944				jp c, fault_dsp_under 
1944				pop de 
1944				pop hl 
1944				endm 
1944			 
1944			 
1944			FORTH_CHK_RSP_UNDER: macro 
1944				push hl 
1944				push de 
1944				ld hl,(cli_ret_sp) 
1944				ld de, cli_ret_stack 
1944				call cmp16 
1944				jp c, fault_rsp_under 
1944				pop de 
1944				pop hl 
1944				endm 
1944			 
1944			FORTH_CHK_LOOP_UNDER: macro 
1944				push hl 
1944				push de 
1944				ld hl,(cli_loop_sp) 
1944				ld de, cli_loop_stack 
1944				call cmp16 
1944				jp c, fault_loop_under 
1944				pop de 
1944				pop hl 
1944				endm 
1944			 
1944			FORTH_ERR_TOS_NOTSTR: macro 
1944				; TOSO might need more for checks when used 
1944				push af 
1944				ld a,(hl) 
1944				cp DS_TYPE_STR 
1944				jp nz, type_faultn   
1944				pop af 
1944				endm 
1944			 
1944			FORTH_ERR_TOS_NOTNUM: macro 
1944				push af 
1944				ld a,(hl) 
1944				cp DS_TYPE_INUM 
1944				jp nz, type_faultn   
1944				pop af 
1944				endm 
1944			 
1944			 
1944			; increase data stack pointer and save hl to it 
1944				 
1944			FORTH_DSP_NEXT: macro 
1944				call macro_forth_dsp_next 
1944				endm 
1944			 
1944			 
1944			macro_forth_dsp_next: 
1944				if DEBUG_FORTH_STACK_GUARD 
1944 cd 89 55				call check_stacks 
1947				endif 
1947 e5				push hl 
1948 d5				push de 
1949 eb				ex de,hl 
194a 2a 0d eb			ld hl,(cli_data_sp) 
194d 23				inc hl 
194e 23				inc hl 
194f			 
194f			; PARSEV5 
194f 23				inc hl 
1950 22 0d eb			ld (cli_data_sp),hl 
1953 73				ld (hl), e 
1954 23				inc hl 
1955 72				ld (hl), d 
1956 d1				pop de 
1957 e1				pop hl 
1958				if DEBUG_FORTH_STACK_GUARD 
1958 cd 89 55				call check_stacks 
195b				endif 
195b c9				ret 
195c			 
195c			 
195c			; increase ret stack pointer and save hl to it 
195c				 
195c			FORTH_RSP_NEXT: macro 
195c				call macro_forth_rsp_next 
195c				endm 
195c			 
195c			macro_forth_rsp_next: 
195c				if DEBUG_FORTH_STACK_GUARD 
195c cd 89 55				call check_stacks 
195f				endif 
195f e5				push hl 
1960 d5				push de 
1961 eb				ex de,hl 
1962 2a 11 eb			ld hl,(cli_ret_sp) 
1965 23				inc hl 
1966 23				inc hl 
1967 22 11 eb			ld (cli_ret_sp),hl 
196a 73				ld (hl), e 
196b 23				inc hl 
196c 72				ld (hl), d 
196d d1				pop de 
196e e1				pop hl 
196f				if DEBUG_FORTH_STACK_GUARD 
196f cd 89 55				call check_stacks 
1972				endif 
1972 c9				ret 
1973			 
1973			; get current ret stack pointer and save to hl  
1973				 
1973			FORTH_RSP_TOS: macro 
1973				call macro_forth_rsp_tos 
1973				endm 
1973			 
1973			macro_forth_rsp_tos: 
1973				;push de 
1973 2a 11 eb			ld hl,(cli_ret_sp) 
1976 cd ae 19			call loadhlptrtohl 
1979				;ld e, (hl) 
1979				;inc hl 
1979				;ld d, (hl) 
1979				;ex de, hl 
1979					if DEBUG_FORTH_WORDS 
1979			;			DMARK "RST" 
1979						CALLMONITOR 
1979 cd 28 14			call break_point_state  
197c				endm  
# End of macro CALLMONITOR
197c					endif 
197c				;pop de 
197c c9				ret 
197d			 
197d			; pop ret stack pointer 
197d				 
197d			FORTH_RSP_POP: macro 
197d				call macro_forth_rsp_pop 
197d				endm 
197d			 
197d			 
197d			macro_forth_rsp_pop: 
197d				if DEBUG_FORTH_STACK_GUARD 
197d			;		DMARK "RPP" 
197d cd 89 55				call check_stacks 
1980					FORTH_CHK_RSP_UNDER 
1980 e5				push hl 
1981 d5				push de 
1982 2a 11 eb			ld hl,(cli_ret_sp) 
1985 11 cb ea			ld de, cli_ret_stack 
1988 cd d3 0b			call cmp16 
198b da 9d 56			jp c, fault_rsp_under 
198e d1				pop de 
198f e1				pop hl 
1990				endm 
# End of macro FORTH_CHK_RSP_UNDER
1990				endif 
1990 e5				push hl 
1991 2a 11 eb			ld hl,(cli_ret_sp) 
1994			 
1994			 
1994				if FORTH_ENABLE_FREE 
1994			 
1994					; get pointer 
1994			 
1994					push de 
1994					push hl 
1994			 
1994					ld e, (hl) 
1994					inc hl 
1994					ld d, (hl) 
1994			 
1994					ex de, hl 
1994					call free 
1994			 
1994					pop hl 
1994					pop de 
1994			 
1994			 
1994				endif 
1994			 
1994			 
1994 2b				dec hl 
1995 2b				dec hl 
1996 22 11 eb			ld (cli_ret_sp), hl 
1999				; do stack underflow checks 
1999 e1				pop hl 
199a				if DEBUG_FORTH_STACK_GUARD 
199a cd 89 55				call check_stacks 
199d					FORTH_CHK_RSP_UNDER 
199d e5				push hl 
199e d5				push de 
199f 2a 11 eb			ld hl,(cli_ret_sp) 
19a2 11 cb ea			ld de, cli_ret_stack 
19a5 cd d3 0b			call cmp16 
19a8 da 9d 56			jp c, fault_rsp_under 
19ab d1				pop de 
19ac e1				pop hl 
19ad				endm 
# End of macro FORTH_CHK_RSP_UNDER
19ad				endif 
19ad c9				ret 
19ae			 
19ae			 
19ae			 
19ae			; routine to load word pointed to by hl into hl 
19ae			 
19ae			loadhlptrtohl: 
19ae			 
19ae d5				push de 
19af 5e				ld e, (hl) 
19b0 23				inc hl 
19b1 56				ld d, (hl) 
19b2 eb				ex de, hl 
19b3 d1				pop de 
19b4			 
19b4 c9				ret 
19b5			 
19b5			 
19b5			 
19b5			 
19b5			 
19b5			; push a number held in HL onto the data stack 
19b5			; entry point for pushing a value when already in hl used in function above 
19b5			 
19b5			forth_push_numhl: 
19b5			 
19b5 e5				push hl    ; save value to push 
19b6			 
19b6			if DEBUG_FORTH_PUSH 
19b6				; see if disabled 
19b6			 
19b6			 
19b6 f5				push af 
19b7 3a 51 e3			ld a, (os_view_disable) 
19ba fe 2a			cp '*' 
19bc 28 34			jr z, .pskip2 
19be e5				push hl 
19bf e5			push hl 
19c0 cd 88 09			call clear_display 
19c3 e1			pop hl 
19c4 7c				ld a,h 
19c5 21 65 e6			ld hl, os_word_scratch 
19c8 cd b6 0e			call hexout 
19cb e1				pop hl 
19cc 7d				ld a,l 
19cd 21 67 e6			ld hl, os_word_scratch+2 
19d0 cd b6 0e			call hexout 
19d3			 
19d3 21 69 e6			ld hl, os_word_scratch+4 
19d6 3e 00			ld a,0 
19d8 77				ld (hl),a 
19d9 11 65 e6			ld de,os_word_scratch 
19dc 3e 28				ld a, display_row_2 
19de cd 9b 09				call str_at_display 
19e1 11 97 44			ld de, .push_num 
19e4 3e 00			ld a, display_row_1 
19e6			 
19e6 cd 9b 09				call str_at_display 
19e9			 
19e9			 
19e9 cd ab 09			call update_display 
19ec cd fd 08			call delay1s 
19ef cd fd 08			call delay1s 
19f2			.pskip2:  
19f2			 
19f2 f1				pop af 
19f3			endif	 
19f3			 
19f3			 
19f3				FORTH_DSP_NEXT 
19f3 cd 44 19			call macro_forth_dsp_next 
19f6				endm 
# End of macro FORTH_DSP_NEXT
19f6			 
19f6 2a 0d eb			ld hl, (cli_data_sp) 
19f9			 
19f9				; save item type 
19f9 3e 02			ld a,  DS_TYPE_INUM 
19fb 77				ld (hl), a 
19fc 23				inc hl 
19fd			 
19fd				; get word off stack 
19fd d1				pop de 
19fe 7b				ld a,e 
19ff 77				ld (hl), a 
1a00 23				inc hl 
1a01 7a				ld a,d 
1a02 77				ld (hl), a 
1a03			 
1a03			if DEBUG_FORTH_PUSH 
1a03 2b				dec hl 
1a04 2b				dec hl 
1a05 2b				dec hl 
1a06						DMARK "PH5" 
1a06 f5				push af  
1a07 3a 1b 1a			ld a, (.dmark)  
1a0a 32 7a ee			ld (debug_mark),a  
1a0d 3a 1c 1a			ld a, (.dmark+1)  
1a10 32 7b ee			ld (debug_mark+1),a  
1a13 3a 1d 1a			ld a, (.dmark+2)  
1a16 32 7c ee			ld (debug_mark+2),a  
1a19 18 03			jr .pastdmark  
1a1b ..			.dmark: db "PH5"  
1a1e f1			.pastdmark: pop af  
1a1f			endm  
# End of macro DMARK
1a1f				CALLMONITOR 
1a1f cd 28 14			call break_point_state  
1a22				endm  
# End of macro CALLMONITOR
1a22			endif	 
1a22			 
1a22 c9				ret 
1a23			 
1a23			 
1a23			; Push a string to stack pointed to by hl 
1a23			 
1a23			forth_push_str: 
1a23			 
1a23			if DEBUG_FORTH_PUSH 
1a23						DMARK "PSQ" 
1a23 f5				push af  
1a24 3a 38 1a			ld a, (.dmark)  
1a27 32 7a ee			ld (debug_mark),a  
1a2a 3a 39 1a			ld a, (.dmark+1)  
1a2d 32 7b ee			ld (debug_mark+1),a  
1a30 3a 3a 1a			ld a, (.dmark+2)  
1a33 32 7c ee			ld (debug_mark+2),a  
1a36 18 03			jr .pastdmark  
1a38 ..			.dmark: db "PSQ"  
1a3b f1			.pastdmark: pop af  
1a3c			endm  
# End of macro DMARK
1a3c				CALLMONITOR 
1a3c cd 28 14			call break_point_state  
1a3f				endm  
# End of macro CALLMONITOR
1a3f			endif	 
1a3f			    
1a3f e5				push hl 
1a40 e5				push hl 
1a41			 
1a41			;	ld a, 0   ; find end of string 
1a41 cd 13 10			call strlenz 
1a44			if DEBUG_FORTH_PUSH 
1a44						DMARK "PQ2" 
1a44 f5				push af  
1a45 3a 59 1a			ld a, (.dmark)  
1a48 32 7a ee			ld (debug_mark),a  
1a4b 3a 5a 1a			ld a, (.dmark+1)  
1a4e 32 7b ee			ld (debug_mark+1),a  
1a51 3a 5b 1a			ld a, (.dmark+2)  
1a54 32 7c ee			ld (debug_mark+2),a  
1a57 18 03			jr .pastdmark  
1a59 ..			.dmark: db "PQ2"  
1a5c f1			.pastdmark: pop af  
1a5d			endm  
# End of macro DMARK
1a5d				CALLMONITOR 
1a5d cd 28 14			call break_point_state  
1a60				endm  
# End of macro CALLMONITOR
1a60			endif	 
1a60 eb				ex de, hl 
1a61 e1				pop hl   ; get ptr to start of string 
1a62			if DEBUG_FORTH_PUSH 
1a62						DMARK "PQ3" 
1a62 f5				push af  
1a63 3a 77 1a			ld a, (.dmark)  
1a66 32 7a ee			ld (debug_mark),a  
1a69 3a 78 1a			ld a, (.dmark+1)  
1a6c 32 7b ee			ld (debug_mark+1),a  
1a6f 3a 79 1a			ld a, (.dmark+2)  
1a72 32 7c ee			ld (debug_mark+2),a  
1a75 18 03			jr .pastdmark  
1a77 ..			.dmark: db "PQ3"  
1a7a f1			.pastdmark: pop af  
1a7b			endm  
# End of macro DMARK
1a7b				CALLMONITOR 
1a7b cd 28 14			call break_point_state  
1a7e				endm  
# End of macro CALLMONITOR
1a7e			endif	 
1a7e 19				add hl,de 
1a7f			if DEBUG_FORTH_PUSH 
1a7f						DMARK "PQE" 
1a7f f5				push af  
1a80 3a 94 1a			ld a, (.dmark)  
1a83 32 7a ee			ld (debug_mark),a  
1a86 3a 95 1a			ld a, (.dmark+1)  
1a89 32 7b ee			ld (debug_mark+1),a  
1a8c 3a 96 1a			ld a, (.dmark+2)  
1a8f 32 7c ee			ld (debug_mark+2),a  
1a92 18 03			jr .pastdmark  
1a94 ..			.dmark: db "PQE"  
1a97 f1			.pastdmark: pop af  
1a98			endm  
# End of macro DMARK
1a98				CALLMONITOR 
1a98 cd 28 14			call break_point_state  
1a9b				endm  
# End of macro CALLMONITOR
1a9b			endif	 
1a9b			 
1a9b 2b				dec hl    ; see if there is an optional trailing double quote 
1a9c 7e				ld a,(hl) 
1a9d fe 22			cp '"' 
1a9f 20 03			jr nz, .strnoq 
1aa1 3e 00			ld a, 0      ; get rid of double quote 
1aa3 77				ld (hl), a 
1aa4 23			.strnoq: inc hl 
1aa5			 
1aa5 3e 00			ld a, 0 
1aa7 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1aa8			 
1aa8 13				inc de ; add one for the type string 
1aa9 13				inc de ; add one for null term??? 
1aaa			 
1aaa				; tos is get string pointer again 
1aaa				; de contains space to allocate 
1aaa				 
1aaa d5				push de 
1aab			 
1aab eb				ex de, hl 
1aac			 
1aac				;push af 
1aac			 
1aac			if DEBUG_FORTH_PUSH 
1aac						DMARK "PHm" 
1aac f5				push af  
1aad 3a c1 1a			ld a, (.dmark)  
1ab0 32 7a ee			ld (debug_mark),a  
1ab3 3a c2 1a			ld a, (.dmark+1)  
1ab6 32 7b ee			ld (debug_mark+1),a  
1ab9 3a c3 1a			ld a, (.dmark+2)  
1abc 32 7c ee			ld (debug_mark+2),a  
1abf 18 03			jr .pastdmark  
1ac1 ..			.dmark: db "PHm"  
1ac4 f1			.pastdmark: pop af  
1ac5			endm  
# End of macro DMARK
1ac5				CALLMONITOR 
1ac5 cd 28 14			call break_point_state  
1ac8				endm  
# End of macro CALLMONITOR
1ac8			endif	 
1ac8 cd 7c 10			call malloc	; on ret hl now contains allocated memory 
1acb				if DEBUG_FORTH_MALLOC_GUARD 
1acb cc ef 44				call z,malloc_error 
1ace				endif 
1ace			 
1ace				 
1ace c1				pop bc    ; get length 
1acf d1				pop de   ;  get string start    
1ad0			 
1ad0				; hl has destination from malloc 
1ad0			 
1ad0 eb				ex de, hl    ; prep for ldir 
1ad1			 
1ad1 d5				push de   ; save malloc area for DSP later 
1ad2				;push hl   ; save malloc area for DSP later 
1ad2			 
1ad2			if DEBUG_FORTH_PUSH 
1ad2						DMARK "PHc" 
1ad2 f5				push af  
1ad3 3a e7 1a			ld a, (.dmark)  
1ad6 32 7a ee			ld (debug_mark),a  
1ad9 3a e8 1a			ld a, (.dmark+1)  
1adc 32 7b ee			ld (debug_mark+1),a  
1adf 3a e9 1a			ld a, (.dmark+2)  
1ae2 32 7c ee			ld (debug_mark+2),a  
1ae5 18 03			jr .pastdmark  
1ae7 ..			.dmark: db "PHc"  
1aea f1			.pastdmark: pop af  
1aeb			endm  
# End of macro DMARK
1aeb				CALLMONITOR 
1aeb cd 28 14			call break_point_state  
1aee				endm  
# End of macro CALLMONITOR
1aee			endif	 
1aee			 
1aee			 
1aee ed b0			ldir 
1af0			 
1af0			 
1af0				; push malloc to data stack     macro?????  
1af0			 
1af0				FORTH_DSP_NEXT 
1af0 cd 44 19			call macro_forth_dsp_next 
1af3				endm 
# End of macro FORTH_DSP_NEXT
1af3			 
1af3				; save value and type 
1af3			 
1af3 2a 0d eb			ld hl, (cli_data_sp) 
1af6			 
1af6				; save item type 
1af6 3e 01			ld a,  DS_TYPE_STR 
1af8 77				ld (hl), a 
1af9 23				inc hl 
1afa			 
1afa				; get malloc word off stack 
1afa d1				pop de 
1afb 73				ld (hl), e 
1afc 23				inc hl 
1afd 72				ld (hl), d 
1afe			 
1afe			 
1afe			 
1afe			if DEBUG_FORTH_PUSH 
1afe 2a 0d eb			ld hl, (cli_data_sp) 
1b01						DMARK "PHS" 
1b01 f5				push af  
1b02 3a 16 1b			ld a, (.dmark)  
1b05 32 7a ee			ld (debug_mark),a  
1b08 3a 17 1b			ld a, (.dmark+1)  
1b0b 32 7b ee			ld (debug_mark+1),a  
1b0e 3a 18 1b			ld a, (.dmark+2)  
1b11 32 7c ee			ld (debug_mark+2),a  
1b14 18 03			jr .pastdmark  
1b16 ..			.dmark: db "PHS"  
1b19 f1			.pastdmark: pop af  
1b1a			endm  
# End of macro DMARK
1b1a				CALLMONITOR 
1b1a cd 28 14			call break_point_state  
1b1d				endm  
# End of macro CALLMONITOR
1b1d			;	ex de,hl 
1b1d			endif	 
1b1d				; in case of spaces, skip the ptr past the copied string 
1b1d				;pop af 
1b1d				;ld (cli_origptr),hl 
1b1d			 
1b1d c9				ret 
1b1e			 
1b1e			 
1b1e			 
1b1e			; TODO ascii push input onto stack given hl to start of input 
1b1e			 
1b1e			; identify type 
1b1e			; if starts with a " then a string 
1b1e			; otherwise it is a number 
1b1e			;  
1b1e			; if a string 
1b1e			;     scan for ending " to get length of string to malloc for + 1 
1b1e			;     malloc 
1b1e			;     put pointer to string on stack first byte flags as string 
1b1e			; 
1b1e			; else a number 
1b1e			;    look for number format identifier 
1b1e			;    $xx hex 
1b1e			;    %xxxxx bin 
1b1e			;    xxxxx decimal 
1b1e			;    convert number to 16bit word.  
1b1e			;    malloc word + 1 with flag to identiy as num 
1b1e			;    put pointer to number on stack 
1b1e			;   
1b1e			;  
1b1e			  
1b1e			forth_apush: 
1b1e				; kernel push 
1b1e			 
1b1e			if DEBUG_FORTH_PUSH 
1b1e						DMARK "PSH" 
1b1e f5				push af  
1b1f 3a 33 1b			ld a, (.dmark)  
1b22 32 7a ee			ld (debug_mark),a  
1b25 3a 34 1b			ld a, (.dmark+1)  
1b28 32 7b ee			ld (debug_mark+1),a  
1b2b 3a 35 1b			ld a, (.dmark+2)  
1b2e 32 7c ee			ld (debug_mark+2),a  
1b31 18 03			jr .pastdmark  
1b33 ..			.dmark: db "PSH"  
1b36 f1			.pastdmark: pop af  
1b37			endm  
# End of macro DMARK
1b37				CALLMONITOR 
1b37 cd 28 14			call break_point_state  
1b3a				endm  
# End of macro CALLMONITOR
1b3a			endif	 
1b3a				; identify input type 
1b3a			 
1b3a 7e				ld a,(hl) 
1b3b fe 22			cp '"' 
1b3d 28 0a			jr z, .fapstr 
1b3f fe 24			cp '$' 
1b41 ca 69 1b			jp z, .faphex 
1b44 fe 25			cp '%' 
1b46 ca 51 1b			jp z, .fapbin 
1b49			;	cp 'b' 
1b49			;	jp z, .fabin 
1b49				; else decimal 
1b49			 
1b49				; TODO do decimal conversion 
1b49				; decimal is stored as a 16bit word 
1b49			 
1b49				; by default everything is a string if type is not detected 
1b49			.fapstr: ; 
1b49 fe 22			cp '"' 
1b4b 20 01			jr nz, .strnoqu 
1b4d 23				inc hl 
1b4e			.strnoqu: 
1b4e c3 23 1a			jp forth_push_str 
1b51			 
1b51			 
1b51			 
1b51			.fapbin:    ; push a binary string.  
1b51 11 00 00			ld de, 0   ; hold a 16bit value 
1b54			 
1b54 23			.fapbinshift:	inc hl  
1b55 7e				ld a,(hl) 
1b56 fe 00			cp 0     ; done scanning  
1b58 28 0b			jr z, .fapbdone  	; got it in HL so push  
1b5a			 
1b5a				; left shift de 
1b5a eb				ex de, hl	 
1b5b 29				add hl, hl 
1b5c			 
1b5c				; is 1 
1b5c fe 31			cp '1' 
1b5e 20 02			jr nz, .binzero 
1b60 cb 4d			bit 1, l 
1b62			.binzero: 
1b62 eb				ex de, hl	 ; save current de 
1b63 18 ef			jr .fapbinshift 
1b65			 
1b65			.fapbdone: 
1b65 eb				ex de, hl 
1b66 c3 b5 19			jp forth_push_numhl 
1b69			 
1b69			 
1b69			.faphex:   ; hex is always stored as a 16bit word 
1b69				; skip number prefix 
1b69 23				inc hl 
1b6a				; turn ascii into number 
1b6a cd 6c 0f			call get_word_hl	; ret 16bit word in hl 
1b6d			 
1b6d c3 b5 19			jp forth_push_numhl 
1b70			 
1b70 00				 nop 
1b71			 
1b71			.fabin:   ; TODO bin conversion 
1b71			 
1b71			 
1b71 c9				ret 
1b72			 
1b72			 
1b72			; get either a string ptr or a 16bit word from the data stack 
1b72			 
1b72			FORTH_DSP: macro 
1b72				call macro_forth_dsp 
1b72				endm 
1b72			 
1b72			macro_forth_dsp: 
1b72				; data stack pointer points to current word on tos 
1b72			 
1b72 2a 0d eb			ld hl,(cli_data_sp) 
1b75			 
1b75				if DEBUG_FORTH_PUSH 
1b75						DMARK "DSP" 
1b75 f5				push af  
1b76 3a 8a 1b			ld a, (.dmark)  
1b79 32 7a ee			ld (debug_mark),a  
1b7c 3a 8b 1b			ld a, (.dmark+1)  
1b7f 32 7b ee			ld (debug_mark+1),a  
1b82 3a 8c 1b			ld a, (.dmark+2)  
1b85 32 7c ee			ld (debug_mark+2),a  
1b88 18 03			jr .pastdmark  
1b8a ..			.dmark: db "DSP"  
1b8d f1			.pastdmark: pop af  
1b8e			endm  
# End of macro DMARK
1b8e			 
1b8e cd 24 45				call display_data_sp 
1b91				;call break_point_state 
1b91				;rst 030h 
1b91				CALLMONITOR 
1b91 cd 28 14			call break_point_state  
1b94				endm  
# End of macro CALLMONITOR
1b94				endif 
1b94			 
1b94 c9				ret 
1b95			 
1b95			; return hl to start of value on stack 
1b95			 
1b95			FORTH_DSP_VALUE: macro 
1b95				call macro_forth_dsp_value 
1b95				endm 
1b95			 
1b95			macro_forth_dsp_value: 
1b95			 
1b95				FORTH_DSP 
1b95 cd 72 1b			call macro_forth_dsp 
1b98				endm 
# End of macro FORTH_DSP
1b98			 
1b98 d5				push de 
1b99			 
1b99 23				inc hl ; skip type 
1b9a			 
1b9a 5e				ld e, (hl) 
1b9b 23				inc hl 
1b9c 56				ld d, (hl) 
1b9d eb				ex de,hl  
1b9e			 
1b9e d1				pop de 
1b9f			 
1b9f c9				ret 
1ba0			 
1ba0			; return hl to start of value to second item on stack 
1ba0			 
1ba0			FORTH_DSP_VALUEM1: macro 
1ba0				call macro_forth_dsp_value_m1 
1ba0				endm 
1ba0			 
1ba0			macro_forth_dsp_value_m1: 
1ba0			 
1ba0				FORTH_DSP 
1ba0 cd 72 1b			call macro_forth_dsp 
1ba3				endm 
# End of macro FORTH_DSP
1ba3			 
1ba3 2b				dec hl 
1ba4 2b				dec hl 
1ba5			;	dec hl 
1ba5			 
1ba5 d5				push de 
1ba6			 
1ba6 5e				ld e, (hl) 
1ba7 23				inc hl 
1ba8 56				ld d, (hl) 
1ba9 eb				ex de,hl  
1baa			 
1baa d1				pop de 
1bab			 
1bab c9				ret 
1bac			 
1bac				 
1bac			 
1bac			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1bac			 
1bac			FORTH_DSP_POP: macro 
1bac				call macro_forth_dsp_pop 
1bac				endm 
1bac			 
1bac			 
1bac			; get the tos data type 
1bac			 
1bac			FORTH_DSP_TYPE:   macro 
1bac			 
1bac				;FORTH_DSP_VALUE 
1bac				FORTH_DSP 
1bac				 
1bac				; hl points to value 
1bac				; check type 
1bac			 
1bac				ld a,(hl) 
1bac			 
1bac				endm 
1bac			 
1bac			; load the tos value into hl 
1bac			 
1bac			 
1bac			FORTH_DSP_VALUEHL:  macro 
1bac				call macro_dsp_valuehl 
1bac				endm 
1bac			 
1bac			 
1bac			 
1bac			macro_dsp_valuehl: 
1bac				FORTH_DSP_VALUE 
1bac cd 95 1b			call macro_forth_dsp_value 
1baf				endm 
# End of macro FORTH_DSP_VALUE
1baf			 
1baf				;FORTH_ERR_TOS_NOTNUM 
1baf			 
1baf				;inc hl   ; skip type id 
1baf			 
1baf			;	push de 
1baf			; 
1baf			;	ld e, (hl) 
1baf			;	inc hl 
1baf			;	ld d, (hl) 
1baf			;	ex de,hl  
1baf			 
1baf			;	pop de 
1baf			 
1baf				if DEBUG_FORTH_PUSH 
1baf						DMARK "DVL" 
1baf f5				push af  
1bb0 3a c4 1b			ld a, (.dmark)  
1bb3 32 7a ee			ld (debug_mark),a  
1bb6 3a c5 1b			ld a, (.dmark+1)  
1bb9 32 7b ee			ld (debug_mark+1),a  
1bbc 3a c6 1b			ld a, (.dmark+2)  
1bbf 32 7c ee			ld (debug_mark+2),a  
1bc2 18 03			jr .pastdmark  
1bc4 ..			.dmark: db "DVL"  
1bc7 f1			.pastdmark: pop af  
1bc8			endm  
# End of macro DMARK
1bc8				CALLMONITOR 
1bc8 cd 28 14			call break_point_state  
1bcb				endm  
# End of macro CALLMONITOR
1bcb				endif 
1bcb c9				ret 
1bcc			 
1bcc			forth_apushstrhl:      
1bcc				; push of string requires use of cli_origptr 
1bcc				; bodge use 
1bcc			 
1bcc				; get current cli_origptr, save, update with temp pointer  
1bcc ed 5b 29 eb		ld de, (cli_origptr) 
1bd0 22 29 eb			ld (cli_origptr), hl 
1bd3 d5				push de 
1bd4 cd 1e 1b			call forth_apush 
1bd7 d1				pop de 
1bd8 ed 53 29 eb		ld (cli_origptr), de 
1bdc c9			        ret	 
1bdd			 
1bdd			 
1bdd			; increase loop stack pointer and save hl to it 
1bdd				 
1bdd			FORTH_LOOP_NEXT: macro 
1bdd				call macro_forth_loop_next 
1bdd				;nop 
1bdd				endm 
1bdd			 
1bdd			macro_forth_loop_next: 
1bdd				if DEBUG_FORTH_STACK_GUARD 
1bdd cd 89 55				call check_stacks 
1be0				endif 
1be0 e5				push hl 
1be1 d5				push de 
1be2 eb				ex de,hl 
1be3 2a 0f eb			ld hl,(cli_loop_sp) 
1be6 23				inc hl 
1be7 23				inc hl 
1be8					if DEBUG_FORTH_WORDS 
1be8						DMARK "LNX" 
1be8 f5				push af  
1be9 3a fd 1b			ld a, (.dmark)  
1bec 32 7a ee			ld (debug_mark),a  
1bef 3a fe 1b			ld a, (.dmark+1)  
1bf2 32 7b ee			ld (debug_mark+1),a  
1bf5 3a ff 1b			ld a, (.dmark+2)  
1bf8 32 7c ee			ld (debug_mark+2),a  
1bfb 18 03			jr .pastdmark  
1bfd ..			.dmark: db "LNX"  
1c00 f1			.pastdmark: pop af  
1c01			endm  
# End of macro DMARK
1c01						CALLMONITOR 
1c01 cd 28 14			call break_point_state  
1c04				endm  
# End of macro CALLMONITOR
1c04					endif 
1c04 22 0f eb			ld (cli_loop_sp),hl 
1c07 73				ld (hl), e 
1c08 23				inc hl 
1c09 72				ld (hl), d 
1c0a d1				pop de    ; been reversed so save a swap on restore 
1c0b e1				pop hl 
1c0c				if DEBUG_FORTH_STACK_GUARD 
1c0c cd 89 55				call check_stacks 
1c0f				endif 
1c0f c9				ret 
1c10			 
1c10			; get current ret stack pointer and save to hl  
1c10				 
1c10			FORTH_LOOP_TOS: macro 
1c10				call macro_forth_loop_tos 
1c10				endm 
1c10			 
1c10			macro_forth_loop_tos: 
1c10 d5				push de 
1c11 2a 0f eb			ld hl,(cli_loop_sp) 
1c14 5e				ld e, (hl) 
1c15 23				inc hl 
1c16 56				ld d, (hl) 
1c17 eb				ex de, hl 
1c18 d1				pop de 
1c19 c9				ret 
1c1a			 
1c1a			; pop loop stack pointer 
1c1a				 
1c1a			FORTH_LOOP_POP: macro 
1c1a				call macro_forth_loop_pop 
1c1a				endm 
1c1a			 
1c1a			 
1c1a			macro_forth_loop_pop: 
1c1a				if DEBUG_FORTH_STACK_GUARD 
1c1a					DMARK "LPP" 
1c1a f5				push af  
1c1b 3a 2f 1c			ld a, (.dmark)  
1c1e 32 7a ee			ld (debug_mark),a  
1c21 3a 30 1c			ld a, (.dmark+1)  
1c24 32 7b ee			ld (debug_mark+1),a  
1c27 3a 31 1c			ld a, (.dmark+2)  
1c2a 32 7c ee			ld (debug_mark+2),a  
1c2d 18 03			jr .pastdmark  
1c2f ..			.dmark: db "LPP"  
1c32 f1			.pastdmark: pop af  
1c33			endm  
# End of macro DMARK
1c33 cd 89 55				call check_stacks 
1c36					FORTH_CHK_LOOP_UNDER 
1c36 e5				push hl 
1c37 d5				push de 
1c38 2a 0f eb			ld hl,(cli_loop_sp) 
1c3b 11 c9 e9			ld de, cli_loop_stack 
1c3e cd d3 0b			call cmp16 
1c41 da a3 56			jp c, fault_loop_under 
1c44 d1				pop de 
1c45 e1				pop hl 
1c46				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c46				endif 
1c46 e5				push hl 
1c47 2a 0f eb			ld hl,(cli_loop_sp) 
1c4a 2b				dec hl 
1c4b 2b				dec hl 
1c4c 22 0f eb			ld (cli_loop_sp), hl 
1c4f				; TODO do stack underflow checks 
1c4f e1				pop hl 
1c50				if DEBUG_FORTH_STACK_GUARD 
1c50 cd 89 55				call check_stacks 
1c53					FORTH_CHK_LOOP_UNDER 
1c53 e5				push hl 
1c54 d5				push de 
1c55 2a 0f eb			ld hl,(cli_loop_sp) 
1c58 11 c9 e9			ld de, cli_loop_stack 
1c5b cd d3 0b			call cmp16 
1c5e da a3 56			jp c, fault_loop_under 
1c61 d1				pop de 
1c62 e1				pop hl 
1c63				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c63				endif 
1c63 c9				ret 
1c64			 
1c64			macro_forth_dsp_pop: 
1c64			 
1c64 e5				push hl 
1c65			 
1c65				; release malloc data 
1c65			 
1c65				if DEBUG_FORTH_STACK_GUARD 
1c65 cd 89 55				call check_stacks 
1c68					FORTH_CHK_DSP_UNDER 
1c68 e5				push hl 
1c69 d5				push de 
1c6a 2a 0d eb			ld hl,(cli_data_sp) 
1c6d 11 c7 e8			ld de, cli_data_stack 
1c70 cd d3 0b			call cmp16 
1c73 da 97 56			jp c, fault_dsp_under 
1c76 d1				pop de 
1c77 e1				pop hl 
1c78				endm 
# End of macro FORTH_CHK_DSP_UNDER
1c78				endif 
1c78				;ld hl,(cli_data_sp) 
1c78			if DEBUG_FORTH_DOT 
1c78				DMARK "DPP" 
1c78				CALLMONITOR 
1c78			endif	 
1c78			 
1c78			 
1c78			if FORTH_ENABLE_DSPPOPFREE 
1c78			 
1c78				FORTH_DSP 
1c78 cd 72 1b			call macro_forth_dsp 
1c7b				endm 
# End of macro FORTH_DSP
1c7b			 
1c7b 7e				ld a, (hl) 
1c7c fe 01			cp DS_TYPE_STR 
1c7e 20 07			jr nz, .skippopfree 
1c80			 
1c80				FORTH_DSP_VALUEHL 
1c80 cd ac 1b			call macro_dsp_valuehl 
1c83				endm 
# End of macro FORTH_DSP_VALUEHL
1c83 00				nop 
1c84			if DEBUG_FORTH_DOT 
1c84				DMARK "DPf" 
1c84				CALLMONITOR 
1c84			endif	 
1c84 cd 46 11			call free 
1c87			.skippopfree: 
1c87				 
1c87			 
1c87			endif 
1c87			 
1c87			if DEBUG_FORTH_DOT_KEY 
1c87				DMARK "DP2" 
1c87				CALLMONITOR 
1c87			endif	 
1c87			 
1c87				; move pointer down 
1c87			 
1c87 2a 0d eb			ld hl,(cli_data_sp) 
1c8a 2b				dec hl 
1c8b 2b				dec hl 
1c8c			; PARSEV5 
1c8c 2b				dec hl 
1c8d 22 0d eb			ld (cli_data_sp), hl 
1c90			 
1c90				if DEBUG_FORTH_STACK_GUARD 
1c90 cd 89 55				call check_stacks 
1c93					FORTH_CHK_DSP_UNDER 
1c93 e5				push hl 
1c94 d5				push de 
1c95 2a 0d eb			ld hl,(cli_data_sp) 
1c98 11 c7 e8			ld de, cli_data_stack 
1c9b cd d3 0b			call cmp16 
1c9e da 97 56			jp c, fault_dsp_under 
1ca1 d1				pop de 
1ca2 e1				pop hl 
1ca3				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ca3				endif 
1ca3			 
1ca3 e1				pop hl 
1ca4			 
1ca4 c9				ret 
1ca5			 
1ca5			getwordathl: 
1ca5				; hl points to an address 
1ca5				; load hl with the word at that address 
1ca5			 
1ca5 d5				push de 
1ca6			 
1ca6 5e				ld e, (hl) 
1ca7 23				inc hl 
1ca8 56				ld d, (hl) 
1ca9 eb				ex de, hl 
1caa			 
1caa d1				pop de 
1cab c9				ret 
1cac			 
1cac			 
1cac			 
1cac			 
1cac			 
1cac			; eof 
1cac			 
# End of file forth_stackopsv5.asm
1cac			endif 
1cac			 
1cac			user_word_eol:  
1cac				; hl contains the pointer to where to create a linked list item from the end 
1cac				; of the user dict to continue on at the system word dict 
1cac				 
1cac				; poke the stub of the word list linked list to repoint to rom words 
1cac			 
1cac				; stub format 
1cac				; db   word id 
1cac				; dw    link to next word 
1cac			        ; db char length of token 
1cac				; db string + 0 term 
1cac				; db exec code....  
1cac			 
1cac 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1cae 77				ld (hl), a		; word id 
1caf 23				inc hl 
1cb0			 
1cb0 11 76 1e			ld de, sysdict 
1cb3 73				ld (hl), e		; next word link ie system dict 
1cb4 23				inc hl 
1cb5 72				ld (hl), d		; next word link ie system dict 
1cb6 23				inc hl	 
1cb7			 
1cb7			;	ld (hl), sysdict		; next word link ie system dict 
1cb7			;	inc hl 
1cb7			;	inc hl 
1cb7			 
1cb7			;	inc hl 
1cb7			;	inc hl 
1cb7			 
1cb7 3e 02			ld a, 2			; word length is 0 
1cb9 77				ld (hl), a	 
1cba 23				inc hl 
1cbb			 
1cbb 3e 7e			ld a, '~'			; word length is 0 
1cbd 77				ld (hl), a	 
1cbe 23				inc hl 
1cbf 3e 00			ld a, 0			; save empty word 
1cc1 77				ld (hl), a 
1cc2			 
1cc2 c9				ret 
1cc3			 
1cc3				 
1cc3			 
1cc3			forthexec_cleanup: 
1cc3				FORTH_RSP_POP 
1cc3 cd 7d 19			call macro_forth_rsp_pop 
1cc6				endm 
# End of macro FORTH_RSP_POP
1cc6 c9				ret 
1cc7			 
1cc7			forth_call_hl: 
1cc7				; taking hl 
1cc7 e5				push hl 
1cc8 c9				ret 
1cc9			 
1cc9			; this is called to reset Forth system but keep existing uwords etc 
1cc9			 
1cc9			forth_warmstart: 
1cc9				; setup stack over/under flow checks 
1cc9				if DEBUG_FORTH_STACK_GUARD 
1cc9 cd 6f 55				call chk_stk_init 
1ccc				endif 
1ccc			 
1ccc				; init stack pointers  - * these stacks go upwards *  
1ccc 21 cb ea			ld hl, cli_ret_stack 
1ccf 22 11 eb			ld (cli_ret_sp), hl	 
1cd2				; set bottom of stack 
1cd2 3e 00			ld a,0 
1cd4 77				ld (hl),a 
1cd5 23				inc hl 
1cd6 77				ld (hl),a 
1cd7			 
1cd7 21 c7 e8			ld hl, cli_data_stack 
1cda 22 0d eb			ld (cli_data_sp), hl	 
1cdd				; set bottom of stack 
1cdd 3e 00			ld a,0 
1cdf 77				ld (hl),a 
1ce0 23				inc hl 
1ce1 77				ld (hl),a 
1ce2			 
1ce2 21 c9 e9			ld hl, cli_loop_stack 
1ce5 22 0f eb			ld (cli_loop_sp), hl	 
1ce8				; set bottom of stack 
1ce8 3e 00			ld a,0 
1cea 77				ld (hl),a 
1ceb 23				inc hl 
1cec 77				ld (hl),a 
1ced			 
1ced				; init extent of current open file 
1ced			 
1ced 3e 00			ld a, 0 
1cef 32 5c eb			ld (store_openext), a 
1cf2			 
1cf2 c9				ret 
1cf3			 
1cf3			 
1cf3			; Cold Start - this is called to setup the whole Forth system 
1cf3			 
1cf3			forth_init: 
1cf3			 
1cf3				; setup stack over/under flow checks 
1cf3			 
1cf3			;	if DEBUG_FORTH_STACK_GUARD 
1cf3			;		call chk_stk_init 
1cf3			;	endif 
1cf3			 
1cf3				; enable auto display updates (slow.....) 
1cf3			 
1cf3 3e 01			ld a, 1 
1cf5 32 27 eb			ld (cli_autodisplay), a 
1cf8			 
1cf8			 
1cf8			 
1cf8				; show start up screen 
1cf8			 
1cf8 cd 88 09			call clear_display 
1cfb			 
1cfb 3e 00			ld a,0 
1cfd 32 49 eb			ld (f_cursor_ptr), a 
1d00			 
1d00				; set start of word list in start of ram - for use when creating user words 
1d00			 
1d00 21 92 58			ld hl, baseram 
1d03 22 5d e6			ld (os_last_new_uword), hl 
1d06 cd ac 1c			call user_word_eol 
1d09				 
1d09			;		call display_data_sp 
1d09			;		call next_page_prompt 
1d09			 
1d09			 
1d09			 
1d09			 
1d09 c9				ret 
1d0a			 
1d0a .. 00		.bootforth: db " Forth Kernel Init ",0 
1d1e			 
1d1e			; TODO push to stack 
1d1e			 
1d1e			;  
1d1e			 
1d1e			if FORTH_PARSEV2 
1d1e			 
1d1e			 
1d1e				include "forth_parserv2.asm" 
1d1e			 
1d1e			endif 
1d1e			 
1d1e			 
1d1e			; parse cli version 1 
1d1e			 
1d1e			if FORTH_PARSEV1 
1d1e			 
1d1e			 
1d1e			 
1d1e			      include "forth_parserv1.asm" 
1d1e			endif 
1d1e				 
1d1e			if FORTH_PARSEV3 
1d1e			 
1d1e			 
1d1e			 
1d1e			      include "forth_parserv3.asm" 
1d1e				include "forth_wordsv3.asm" 
1d1e			endif 
1d1e			 
1d1e			if FORTH_PARSEV4 
1d1e			 
1d1e			 
1d1e			 
1d1e			      include "forth_parserv4.asm" 
1d1e				include "forth_wordsv4.asm" 
1d1e			endif 
1d1e			 
1d1e			if FORTH_PARSEV5 
1d1e			 
1d1e			 
1d1e			 
1d1e			      include "forth_parserv5.asm" 
1d1e			 
1d1e			 
1d1e			; A better parser without using malloc and string copies all over the place.  
1d1e			; Exec in situ should be faster 
1d1e			 
1d1e			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1d1e			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1d1e			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1d1e			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1d1e			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1d1e			WORD_SYS_END: equ 0   ; Opcode for all user words 
1d1e			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1d1e			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1d1e			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1d1e			 
1d1e			; Core word preamble macro 
1d1e			 
1d1e			CWHEAD:   macro nxtword opcode lit len opflags 
1d1e				db WORD_SYS_CORE+opcode             
1d1e				; internal op code number 
1d1e				dw nxtword            
1d1e				; link to next dict word block 
1d1e				db len + 1 
1d1e				; literal length of dict word inc zero term 
1d1e				db lit,0              
1d1e				; literal dict word 
1d1e			        ; TODO db opflags        
1d1e				endm 
1d1e			 
1d1e			 
1d1e			NEXTW: macro  
1d1e				jp macro_next 
1d1e				endm 
1d1e			 
1d1e			macro_next: 
1d1e			if DEBUG_FORTH_PARSE_KEY 
1d1e				DMARK "NXT" 
1d1e				CALLMONITOR 
1d1e			endif	 
1d1e			;	inc hl  ; skip token null term  
1d1e ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d22 ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d26 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d29			if DEBUG_FORTH_PARSE_KEY 
1d29				DMARK "}AA" 
1d29				CALLMONITOR 
1d29			endif	 
1d29 c3 2c 1e			jp execnext 
1d2c				;jp exec1 
1d2c			       
1d2c			 
1d2c			 
1d2c			; Another go at the parser to compile  
1d2c			 
1d2c			 
1d2c			; TODO rework parser to change all of the string words to byte tokens 
1d2c			; TODO do a search for  
1d2c			 
1d2c			; TODO first run normal parser to zero term sections 
1d2c			; TODO for each word do a token look up to get the op code 
1d2c			; TODO need some means to flag to the exec that this is a byte code form    
1d2c			 
1d2c			 
1d2c			forthcompile: 
1d2c			 
1d2c			; 
1d2c			; line parse: 
1d2c			;       parse raw input buffer 
1d2c			;       tokenise the words 
1d2c			;       malloc new copy (for looping etc) 
1d2c			;       copy to malloc + current pc in line to start of string and add line term 
1d2c			;       save on new rsp 
1d2c			; 
1d2c			 
1d2c			; hl to point to the line to tokenise 
1d2c			 
1d2c			;	push hl 
1d2c 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d2f			 
1d2f			;	ld a,0		; string term on input 
1d2f			;	call strlent 
1d2f			 
1d2f			;	ld (os_tok_len), hl	 ; save string length 
1d2f			 
1d2f			;if DEBUG_FORTH_TOK 
1d2f			;	ex de,hl		 
1d2f			;endif 
1d2f			 
1d2f			;	pop hl 		; get back string pointer 
1d2f			 
1d2f			if DEBUG_FORTH_TOK 
1d2f						DMARK "TOc" 
1d2f				CALLMONITOR 
1d2f			endif 
1d2f 7e			.cptoken2:    ld a,(hl) 
1d30 23				inc hl 
1d31 fe 7f			cp FORTH_END_BUFFER 
1d33 28 29			jr z, .cptokendone2 
1d35 fe 00			cp 0 
1d37 28 25			jr z, .cptokendone2 
1d39 fe 22			cp '"' 
1d3b 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1d3d fe 20			cp ' ' 
1d3f 20 ee			jr nz,  .cptoken2 
1d41			 
1d41			; TODO consume comments held between ( and ) 
1d41			 
1d41				; we have a space so change to zero term for dict match later 
1d41 2b				dec hl 
1d42 3e 00			ld a,0 
1d44 77				ld (hl), a 
1d45 23				inc hl 
1d46 18 e7			jr .cptoken2 
1d48				 
1d48			 
1d48			.cptokenstr2: 
1d48				; skip all white space until either eol (because forgot to term) or end double quote 
1d48			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d48				;inc hl ; skip current double quote 
1d48 7e				ld a,(hl) 
1d49 23				inc hl 
1d4a fe 22			cp '"' 
1d4c 28 e1			jr z, .cptoken2 
1d4e fe 7f			cp FORTH_END_BUFFER 
1d50 28 0c			jr z, .cptokendone2 
1d52 fe 00			cp 0 
1d54 28 08			jr z, .cptokendone2 
1d56 fe 20			cp ' ' 
1d58 28 02			jr z, .cptmp2 
1d5a 18 ec			jr .cptokenstr2 
1d5c			 
1d5c			.cptmp2:	; we have a space so change to zero term for dict match later 
1d5c				;dec hl 
1d5c				;ld a,"-"	; TODO remove this when working 
1d5c				;ld (hl), a 
1d5c				;inc hl 
1d5c 18 ea			jr .cptokenstr2 
1d5e			 
1d5e			.cptokendone2: 
1d5e				;inc hl 
1d5e 3e 7f			ld a, FORTH_END_BUFFER 
1d60 77				ld (hl),a 
1d61 23				inc hl 
1d62 3e 21			ld a, '!' 
1d64 77				ld (hl),a 
1d65			 
1d65 2a 61 e6			ld hl,(os_tok_ptr) 
1d68			         
1d68			if DEBUG_FORTH_TOK 
1d68						DMARK "Tc1" 
1d68				CALLMONITOR 
1d68			endif 
1d68			 
1d68				; push exec string to top of return stack 
1d68				FORTH_RSP_NEXT 
1d68 cd 5c 19			call macro_forth_rsp_next 
1d6b				endm 
# End of macro FORTH_RSP_NEXT
1d6b c9				ret 
1d6c			 
1d6c			; Another go at the parser need to simplify the process 
1d6c			 
1d6c			forthparse: 
1d6c			 
1d6c			; 
1d6c			; line parse: 
1d6c			;       parse raw input buffer 
1d6c			;       tokenise the words 
1d6c			;       malloc new copy (for looping etc) 
1d6c			;       copy to malloc + current pc in line to start of string and add line term 
1d6c			;       save on new rsp 
1d6c			; 
1d6c			 
1d6c			; hl to point to the line to tokenise 
1d6c			 
1d6c			;	push hl 
1d6c 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d6f			 
1d6f			;	ld a,0		; string term on input 
1d6f			;	call strlent 
1d6f			 
1d6f			;	ld (os_tok_len), hl	 ; save string length 
1d6f			 
1d6f			;if DEBUG_FORTH_TOK 
1d6f			;	ex de,hl		 
1d6f			;endif 
1d6f			 
1d6f			;	pop hl 		; get back string pointer 
1d6f			 
1d6f			if DEBUG_FORTH_TOK 
1d6f						DMARK "TOK" 
1d6f				CALLMONITOR 
1d6f			endif 
1d6f 7e			.ptoken2:    ld a,(hl) 
1d70 23				inc hl 
1d71 fe 7f			cp FORTH_END_BUFFER 
1d73 28 29			jr z, .ptokendone2 
1d75 fe 00			cp 0 
1d77 28 25			jr z, .ptokendone2 
1d79 fe 22			cp '"' 
1d7b 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1d7d fe 20			cp ' ' 
1d7f 20 ee			jr nz,  .ptoken2 
1d81			 
1d81			; TODO consume comments held between ( and ) 
1d81			 
1d81				; we have a space so change to zero term for dict match later 
1d81 2b				dec hl 
1d82 3e 00			ld a,0 
1d84 77				ld (hl), a 
1d85 23				inc hl 
1d86 18 e7			jr .ptoken2 
1d88				 
1d88			 
1d88			.ptokenstr2: 
1d88				; skip all white space until either eol (because forgot to term) or end double quote 
1d88			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d88				;inc hl ; skip current double quote 
1d88 7e				ld a,(hl) 
1d89 23				inc hl 
1d8a fe 22			cp '"' 
1d8c 28 e1			jr z, .ptoken2 
1d8e fe 7f			cp FORTH_END_BUFFER 
1d90 28 0c			jr z, .ptokendone2 
1d92 fe 00			cp 0 
1d94 28 08			jr z, .ptokendone2 
1d96 fe 20			cp ' ' 
1d98 28 02			jr z, .ptmp2 
1d9a 18 ec			jr .ptokenstr2 
1d9c			 
1d9c			.ptmp2:	; we have a space so change to zero term for dict match later 
1d9c				;dec hl 
1d9c				;ld a,"-"	; TODO remove this when working 
1d9c				;ld (hl), a 
1d9c				;inc hl 
1d9c 18 ea			jr .ptokenstr2 
1d9e			 
1d9e			.ptokendone2: 
1d9e				;inc hl 
1d9e 3e 7f			ld a, FORTH_END_BUFFER 
1da0 77				ld (hl),a 
1da1 23				inc hl 
1da2 3e 21			ld a, '!' 
1da4 77				ld (hl),a 
1da5			 
1da5 2a 61 e6			ld hl,(os_tok_ptr) 
1da8			         
1da8			if DEBUG_FORTH_TOK 
1da8						DMARK "TK1" 
1da8				CALLMONITOR 
1da8			endif 
1da8			 
1da8				; push exec string to top of return stack 
1da8				FORTH_RSP_NEXT 
1da8 cd 5c 19			call macro_forth_rsp_next 
1dab				endm 
# End of macro FORTH_RSP_NEXT
1dab c9				ret 
1dac			 
1dac			; 
1dac			;	; malloc size + buffer pointer + if is loop flag 
1dac			;	ld hl,(os_tok_len) 		 ; get string length 
1dac			; 
1dac			;	ld a,l 
1dac			; 
1dac			;	cp 0			; we dont want to use a null string 
1dac			;	ret z 
1dac			; 
1dac			;;	add 3    ; prefix malloc with buffer for current word ptr 
1dac			; 
1dac			;	add 5     ; TODO when certain not over writing memory remove 
1dac			; 
1dac			;		 
1dac			; 
1dac			;if DEBUG_FORTH_TOK 
1dac			;			DMARK "TKE" 
1dac			;	CALLMONITOR 
1dac			;endif 
1dac			; 
1dac			;	ld l,a 
1dac			;	ld h,0 
1dac			;;	push hl   ; save required space for the copy later 
1dac			;	call malloc 
1dac			;if DEBUG_FORTH_TOK 
1dac			;			DMARK "TKM" 
1dac			;	CALLMONITOR 
1dac			;endif 
1dac			;	if DEBUG_FORTH_MALLOC_GUARD 
1dac			;		push af 
1dac			;		call ishlzero 
1dac			;;		ld a, l 
1dac			;;		add h 
1dac			;;		cp 0 
1dac			;		pop af 
1dac			;		 
1dac			;		call z,malloc_error 
1dac			;	endif 
1dac			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1dac			; 
1dac			; 
1dac			;if DEBUG_FORTH_TOK 
1dac			;			DMARK "TKR" 
1dac			;	CALLMONITOR 
1dac			;endif 
1dac			; 
1dac			;	FORTH_RSP_NEXT 
1dac			; 
1dac			;	;inc hl	 ; go past current buffer pointer 
1dac			;	;inc hl 
1dac			;	;inc hl   ; and past if loop flag 
1dac			;		; TODO Need to set flag  
1dac			; 
1dac			;	 
1dac			;	 
1dac			;	ex de,hl	; malloc is dest 
1dac			;	ld hl, (os_tok_len) 
1dac			;;	pop bc 
1dac			;	ld c, l                
1dac			;	ld b,0 
1dac			;	ld hl, (os_tok_ptr) 
1dac			; 
1dac			;if DEBUG_FORTH_TOK 
1dac			;			DMARK "TKT" 
1dac			;	CALLMONITOR 
1dac			;endif 
1dac			; 
1dac			;	; do str cpy 
1dac			; 
1dac			;	ldir      ; copy byte in hl to de 
1dac			; 
1dac			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1dac			; 
1dac			;if DEBUG_FORTH_TOK 
1dac			; 
1dac			;			DMARK "TKY" 
1dac			;	CALLMONITOR 
1dac			;endif 
1dac			;	;ld a,0 
1dac			;	;ld a,FORTH_END_BUFFER 
1dac			;	ex de, hl 
1dac			;	;dec hl			 ; go back over the space delim at the end of word 
1dac			;	;ld (hl),a 
1dac			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1dac			;	ld a,FORTH_END_BUFFER 
1dac			;	ld (hl),a 
1dac			;	inc hl 
1dac			;	ld a,FORTH_END_BUFFER 
1dac			;	ld (hl),a 
1dac			; 
1dac			;	; init the malloc area data 
1dac			;	; set pc for in current area 
1dac			;	;ld hl, (os_tok_malloc) 
1dac			;	;inc hl 
1dac			;	;inc hl 
1dac			;	;inc hl 
1dac			;	;ex de,hl 
1dac			;	;ld hl, (os_tok_malloc) 
1dac			;	;ld (hl),e 
1dac			;	;inc hl 
1dac			;	;ld (hl),d 
1dac			; 
1dac			; 
1dac			;	ld hl,(os_tok_malloc) 
1dac			;if DEBUG_FORTH_PARSE_KEY 
1dac			;			DMARK "TKU" 
1dac			;	CALLMONITOR 
1dac			;endif 
1dac			; 
1dac			;	ret 
1dac			 
1dac			forthexec: 
1dac			 
1dac			; line exec: 
1dac			; forth parser 
1dac			 
1dac			; 
1dac			;       get current exec line on rsp 
1dac			 
1dac				FORTH_RSP_TOS 
1dac cd 73 19			call macro_forth_rsp_tos 
1daf				endm 
# End of macro FORTH_RSP_TOS
1daf			 
1daf			;       restore current pc - hl points to malloc of data 
1daf			 
1daf				;ld e, (hl) 
1daf				;inc hl 
1daf				;ld d, (hl) 
1daf				;ex de,hl 
1daf			 
1daf			 
1daf			exec1: 
1daf 22 61 e6			ld (os_tok_ptr), hl 
1db2			 
1db2				; copy our PC to working vars  
1db2 22 2b eb			ld (cli_ptr), hl 
1db5 22 29 eb			ld (cli_origptr), hl 
1db8			 
1db8 7e				ld a,(hl) 
1db9 fe 7f			cp FORTH_END_BUFFER 
1dbb c8				ret z 
1dbc			 
1dbc				; skip any nulls 
1dbc			 
1dbc fe 00			cp 0 
1dbe 20 03			jr nz, .execword 
1dc0 23				inc hl 
1dc1 18 ec			jr exec1 
1dc3			 
1dc3			 
1dc3			.execword: 
1dc3			 
1dc3			 
1dc3			 
1dc3			if DEBUG_FORTH_PARSE_KEY 
1dc3						DMARK "KYQ" 
1dc3				CALLMONITOR 
1dc3			endif 
1dc3			;       while at start of word: 
1dc3			; get start of dict (in user area first) 
1dc3			 
1dc3 21 92 58		ld hl, baseram 
1dc6			;ld hl, sysdict 
1dc6 22 2d eb		ld (cli_nextword),hl 
1dc9			;           match word at pc 
1dc9			;           exec word 
1dc9			;           or push to dsp 
1dc9			;           forward to next token 
1dc9			;           if line term pop rsp and exit 
1dc9			;        
1dc9			 
1dc9			if DEBUG_FORTH_PARSE_KEY 
1dc9						DMARK "KYq" 
1dc9				CALLMONITOR 
1dc9			endif 
1dc9			 
1dc9			; 
1dc9			; word comp 
1dc9			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1dc9			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1dc9			;    move to start of word  
1dc9			;    compare word to cli_token 
1dc9			 
1dc9			.execpnword:	; HL at start of a word in the dictionary to check 
1dc9			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1dc9			;	ld (cli_ptr), hl 
1dc9			 
1dc9 2a 2d eb			ld hl,(cli_nextword) 
1dcc			 
1dcc cd 6f 1e			call forth_tok_next 
1dcf			; tok next start here 
1dcf			;	; TODO skip compiled symbol for now 
1dcf			;	inc hl 
1dcf			; 
1dcf			;	; save pointer to next word 
1dcf			; 
1dcf			;	; hl now points to the address of the next word pointer  
1dcf			;	ld e, (hl) 
1dcf			;	inc hl 
1dcf			;	ld d, (hl) 
1dcf			;	inc l 
1dcf			; 
1dcf			;	ex de,hl 
1dcf			;if DEBUG_FORTH_PARSE_NEXTWORD 
1dcf			;	push bc 
1dcf			;	ld bc, (cli_nextword) 
1dcf			;			DMARK "NXW" 
1dcf			;	CALLMONITOR 
1dcf			;	pop bc 
1dcf			;endif 
1dcf			; tok next end here 
1dcf 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1dd2 eb				ex de, hl 
1dd3			 
1dd3			 
1dd3				; save the pointer of the current token - 1 to check against 
1dd3				 
1dd3 22 31 eb			ld (cli_token), hl   
1dd6				; TODO maybe remove below save if no debug 
1dd6				; save token string ptr for any debug later 
1dd6 23				inc hl  
1dd7 22 33 eb			ld (cli_origtoken), hl 
1dda 2b				dec hl 
1ddb				; save pointer to the start of the next dictionay word 
1ddb 7e				ld a,(hl)   ; get string length 
1ddc 47				ld b,a 
1ddd			.execpnwordinc:  
1ddd 23				inc hl 
1dde 10 fd			djnz .execpnwordinc 
1de0 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
1de3			 
1de3				; now check the word token against the string being parsed 
1de3			 
1de3 2a 31 eb			ld hl,(cli_token) 
1de6 23				inc hl     ; skip string length (use zero term instead to end) 
1de7 22 31 eb			ld (cli_token), hl 
1dea			 
1dea			if DEBUG_FORTH_PARSE_KEY 
1dea						DMARK "KY2" 
1dea			endif 
1dea			if DEBUG_FORTH_PARSE_EXEC 
1dea				; see if disabled 
1dea			 
1dea				ld a, (os_view_disable) 
1dea				cp '*' 
1dea				jr z, .skip 
1dea			 
1dea				push hl 
1dea				push hl 
1dea				call clear_display 
1dea				ld de, .compword 
1dea				ld a, display_row_1 
1dea				call str_at_display 
1dea				pop de 
1dea				ld a, display_row_2 
1dea				call str_at_display 
1dea				ld hl,(cli_ptr) 
1dea				ld a,(hl) 
1dea			        ld hl, os_word_scratch 
1dea				ld (hl),a 
1dea				ld a,0 
1dea				inc hl 
1dea				ld (hl),a 	 
1dea				ld de, os_word_scratch 
1dea				ld a, display_row_2+10 
1dea				call str_at_display 
1dea				call update_display 
1dea				ld a, 100 
1dea				call aDelayInMS 
1dea				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1dea				call delay250ms 
1dea				endif 
1dea				pop hl 
1dea			.skip:  
1dea			endif	 
1dea			.execpnchar:    ; compare char between token and string to parse 
1dea			 
1dea			if DEBUG_FORTH_PARSE_KEY 
1dea						DMARK "Ky3" 
1dea			endif 
1dea			if DEBUG_FORTH_PARSE_EXEC 
1dea				; see if disabled 
1dea			 
1dea				ld a, (os_view_disable) 
1dea				cp '*' 
1dea				jr z, .skip2 
1dea			 
1dea			;	call clear_display 
1dea			ld hl,(cli_token) 
1dea			ld a,(hl) 
1dea			ld (os_word_scratch),a 
1dea				ld hl,(cli_ptr) 
1dea			ld a,(hl) 
1dea				ld (os_word_scratch+1),a 
1dea				ld a,0 
1dea				ld (os_word_scratch+2),a 
1dea				ld de,os_word_scratch 
1dea				ld a,display_row_4 
1dea				call str_at_display 
1dea				call update_display 
1dea			.skip2:  
1dea			endif 
1dea 2a 31 eb			ld hl,(cli_token) 
1ded 7e				ld a, (hl)	 ; char in word token 
1dee 23				inc hl 		; move to next char 
1def 22 31 eb			ld (cli_token), hl ; and save it 
1df2 47				ld b,a 
1df3			 
1df3 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1df6 7e				ld a,(hl) 
1df7 23				inc hl 
1df8 22 2b eb			ld (cli_ptr), hl		; move to next char 
1dfb cd 0a 10			call toUpper 		; make sure the input string matches case 
1dfe			 
1dfe			if DEBUG_FORTH_PARSE 
1dfe			endif 
1dfe			 
1dfe				; input stream end of token is a space so get rid of it 
1dfe			 
1dfe			;	cp ' ' 
1dfe			;	jr nz, .pnskipspace 
1dfe			; 
1dfe			;	ld a, 0		; make same term as word token term 
1dfe			; 
1dfe			;.pnskipspace: 
1dfe			 
1dfe			if DEBUG_FORTH_PARSE_KEY 
1dfe						DMARK "KY7" 
1dfe			endif 
1dfe b8				cp b 
1dff c2 15 1e			jp nz, .execpnskipword	 ; no match so move to next word 
1e02				 
1e02			;    if same 
1e02			;       scan for string terms 0 for token and 32 for input 
1e02			 
1e02				 
1e02			if DEBUG_FORTH_PARSE_KEY 
1e02						DMARK "KY8" 
1e02			endif 
1e02			 
1e02 80				add b			 
1e03 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1e05							; TODO need to make sure last word in zero term string is accounted for 
1e05 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1e07			 
1e07			 
1e07				; at end of both strings so both are exact match 
1e07			 
1e07			;       skip ptr for next word 
1e07			 
1e07 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
1e0a 23				inc hl			 ; at next char 
1e0b 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
1e0e 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1e11				 
1e11				 
1e11			if DEBUG_FORTH_PARSE_KEY 
1e11						DMARK "KY3" 
1e11			endif 
1e11			 
1e11			 
1e11			 
1e11			;       exec code block 
1e11			if DEBUG_FORTH_JP 
1e11				call clear_display 
1e11				call update_display 
1e11				call delay1s 
1e11				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e11				ld a,h 
1e11				ld hl, os_word_scratch 
1e11				call hexout 
1e11				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e11				ld a,l 
1e11				ld hl, os_word_scratch+2 
1e11				call hexout 
1e11				ld hl, os_word_scratch+4 
1e11				ld a,0 
1e11				ld (hl),a 
1e11				ld de,os_word_scratch 
1e11				call str_at_display 
1e11					ld a, display_row_2 
1e11					call str_at_display 
1e11				ld de, (cli_origtoken) 
1e11				ld a, display_row_1+10 
1e11					call str_at_display 
1e11			 
1e11				ld a,display_row_1 
1e11				ld de, .foundword 
1e11				ld a, display_row_3 
1e11				call str_at_display 
1e11				call update_display 
1e11				call delay1s 
1e11				call delay1s 
1e11				call delay1s 
1e11			endif 
1e11			 
1e11			if DEBUG_FORTH_PARSE_KEY 
1e11						DMARK "KYj" 
1e11			endif 
1e11				; TODO save the word pointer in this exec 
1e11			 
1e11 2a 2f eb			ld hl,(cli_execword) 
1e14 e9				jp (hl) 
1e15			 
1e15			 
1e15			;    if not same 
1e15			;	scan for zero term 
1e15			;	get ptr for next word 
1e15			;	goto word comp 
1e15			 
1e15			.execpnskipword:	; get pointer to next word 
1e15 2a 2d eb			ld hl,(cli_nextword) 
1e18			 
1e18 7e				ld a,(hl) 
1e19 fe 00			cp WORD_SYS_END 
1e1b			;	cp 0 
1e1b 28 09			jr z, .execendofdict			 ; at end of words 
1e1d			 
1e1d			if DEBUG_FORTH_PARSE_KEY 
1e1d						DMARK "KY4" 
1e1d			endif 
1e1d			if DEBUG_FORTH_PARSE_EXEC 
1e1d			 
1e1d				; see if disabled 
1e1d			 
1e1d				ld a, (os_view_disable) 
1e1d				cp '*' 
1e1d				jr z, .noskip 
1e1d			 
1e1d			 
1e1d				ld de, .nowordfound 
1e1d				ld a, display_row_3 
1e1d				call str_at_display 
1e1d				call update_display 
1e1d				ld a, 100 
1e1d				call aDelayInMS 
1e1d				 
1e1d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e1d					call delay250ms 
1e1d				endif 
1e1d			.noskip:  
1e1d			 
1e1d			endif	 
1e1d			 
1e1d 2a 29 eb			ld hl,(cli_origptr) 
1e20 22 2b eb			ld (cli_ptr),hl 
1e23			 
1e23			if DEBUG_FORTH_PARSE_KEY 
1e23						DMARK "KY5" 
1e23			endif 
1e23 c3 c9 1d			jp .execpnword			; else go to next word 
1e26			 
1e26			.execendofdict:  
1e26			 
1e26			if DEBUG_FORTH_PARSE_KEY 
1e26						DMARK "KYe" 
1e26			endif 
1e26			if DEBUG_FORTH_PARSE_EXEC 
1e26				; see if disabled 
1e26			 
1e26				ld a, (os_view_disable) 
1e26				cp '*' 
1e26				jr z, .ispskip 
1e26			 
1e26				call clear_display 
1e26				call update_display 
1e26				call delay1s 
1e26				ld de, (cli_origptr) 
1e26				ld a, display_row_1 
1e26				call str_at_display 
1e26				 
1e26				ld de, .enddict 
1e26				ld a, display_row_3 
1e26				call str_at_display 
1e26				call update_display 
1e26				ld a, 100 
1e26				call aDelayInMS 
1e26				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e26				call delay1s 
1e26				call delay1s 
1e26				call delay1s 
1e26				endif 
1e26			.ispskip:  
1e26				 
1e26			endif	 
1e26			 
1e26			 
1e26			 
1e26				; if the word is not a keyword then must be a literal so push it to stack 
1e26			 
1e26			; push token to stack to end of word 
1e26			 
1e26				STACKFRAME ON $1efe $2f9f 
1e26				if DEBUG_STACK_IMB 
1e26					if ON 
1e26						exx 
1e26						ld de, $1efe 
1e26						ld a, d 
1e26						ld hl, curframe 
1e26						call hexout 
1e26						ld a, e 
1e26						ld hl, curframe+2 
1e26						call hexout 
1e26						ld hl, $1efe 
1e26						push hl 
1e26						ld hl, $2f9f 
1e26						push hl 
1e26						exx 
1e26					endif 
1e26				endif 
1e26			endm 
# End of macro STACKFRAME
1e26			 
1e26 2a 61 e6		ld hl,(os_tok_ptr) 
1e29 cd 1e 1b		call forth_apush 
1e2c			 
1e2c				STACKFRAMECHK ON $1efe $2f9f 
1e2c				if DEBUG_STACK_IMB 
1e2c					if ON 
1e2c						exx 
1e2c						ld hl, $2f9f 
1e2c						pop de   ; $2f9f 
1e2c						call cmp16 
1e2c						jr nz, .spnosame 
1e2c						ld hl, $1efe 
1e2c						pop de   ; $1efe 
1e2c						call cmp16 
1e2c						jr z, .spfrsame 
1e2c						.spnosame: call showsperror 
1e2c						.spfrsame: nop 
1e2c						exx 
1e2c					endif 
1e2c				endif 
1e2c			endm 
# End of macro STACKFRAMECHK
1e2c			 
1e2c			execnext: 
1e2c			 
1e2c			if DEBUG_FORTH_PARSE_KEY 
1e2c						DMARK "KY>" 
1e2c			endif 
1e2c			; move past token to next word 
1e2c			 
1e2c 2a 61 e6		ld hl, (os_tok_ptr) 
1e2f 3e 00		ld a, 0 
1e31 01 ff 00		ld bc, 255     ; input buffer size 
1e34 ed b1		cpir 
1e36			 
1e36			if DEBUG_FORTH_PARSE_KEY 
1e36						DMARK "KY!" 
1e36				CALLMONITOR 
1e36			endif	 
1e36			; TODO this might place hl on the null, so will need to forward on??? 
1e36			;inc hl   ; see if this gets onto the next item 
1e36			 
1e36			 
1e36			; TODO pass a pointer to the buffer to push 
1e36			; TODO call function to push 
1e36			 
1e36			; look for end of input 
1e36			 
1e36			;inc hl 
1e36			;ld a,(hl) 
1e36			;cp FORTH_END_BUFFER 
1e36			;ret z 
1e36			 
1e36			 
1e36 c3 af 1d		jp exec1 
1e39			 
1e39			 
1e39			 
1e39			 
1e39			 
1e39			 
1e39			 
1e39			 
1e39			 
1e39			findnexttok: 
1e39			 
1e39				; hl is pointer to move 
1e39				; de is the token to locate 
1e39			 
1e39					if DEBUG_FORTH 
1e39						DMARK "NTK" 
1e39						CALLMONITOR 
1e39					endif 
1e39 d5				push de 
1e3a			 
1e3a			.fnt1:	 
1e3a				; find first char of token to locate 
1e3a			 
1e3a 1a				ld a, (de) 
1e3b 4f				ld c,a 
1e3c 7e				ld a,(hl) 
1e3d cd 0a 10			call toUpper 
1e40					if DEBUG_FORTH 
1e40						DMARK "NT1" 
1e40						CALLMONITOR 
1e40					endif 
1e40 b9				cp c 
1e41			 
1e41 28 03			jr z, .fnt2cmpmorefirst	 
1e43			 
1e43				; first char not found move to next char 
1e43			 
1e43 23				inc hl 
1e44 18 f4			jr .fnt1 
1e46			 
1e46			.fnt2cmpmorefirst:	 
1e46				; first char of token found.  
1e46			 
1e46 e5				push hl     ; save start of token just in case it is the right one 
1e47 d9				exx 
1e48 e1				pop hl        ; save it to hl' 
1e49 d9				exx 
1e4a			 
1e4a			 
1e4a			.fnt2cmpmore:	 
1e4a				; compare the rest 
1e4a				 
1e4a 23				inc hl 
1e4b 13				inc de 
1e4c				 
1e4c 1a				ld a, (de) 
1e4d 4f				ld c,a 
1e4e 7e				ld a,(hl) 
1e4f cd 0a 10			call toUpper 
1e52			 
1e52					if DEBUG_FORTH 
1e52						DMARK "NT2" 
1e52						CALLMONITOR 
1e52					endif 
1e52				; c has the token to find char 
1e52				; a has the mem to scan char 
1e52			 
1e52 b9				cp c 
1e53 28 04			jr z,.fntmatch1 
1e55			 
1e55				; they are not the same 
1e55			 
1e55					if DEBUG_FORTH 
1e55						DMARK "NT3" 
1e55						CALLMONITOR 
1e55					endif 
1e55 d1				pop de	; reset de token to look for 
1e56 d5				push de 
1e57 18 e1			jr .fnt1 
1e59				 
1e59			.fntmatch1: 
1e59			 
1e59				; is the same char a null which means we might have a full hit? 
1e59					if DEBUG_FORTH 
1e59						DMARK "NT4" 
1e59						CALLMONITOR 
1e59					endif 
1e59			 
1e59 fe 00			cp 0 
1e5b 28 0b			jr z, .fntmatchyes 
1e5d			 
1e5d				; are we at the end of the token to find? 
1e5d			 
1e5d					if DEBUG_FORTH 
1e5d						DMARK "NT5" 
1e5d						CALLMONITOR 
1e5d					endif 
1e5d 3e 00			ld a, 0 
1e5f b9				cp c 
1e60			 
1e60 c2 4a 1e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1e63			 
1e63					if DEBUG_FORTH 
1e63						DMARK "NT6" 
1e63						CALLMONITOR 
1e63					endif 
1e63				; token to find is exhusted but no match to stream 
1e63			 
1e63				; restore tok pointer and continue on 
1e63 d1				pop de 
1e64 d5				push de 
1e65 c3 3a 1e			jp .fnt1 
1e68			 
1e68			 
1e68			.fntmatchyes: 
1e68			 
1e68				; hl now contains the end of the found token 
1e68			 
1e68				; get rid of saved token pointer to find 
1e68			 
1e68 d1				pop de 
1e69			 
1e69					if DEBUG_FORTH 
1e69						DMARK "NT9" 
1e69						CALLMONITOR 
1e69					endif 
1e69			 
1e69				; hl will be on the null term so forward on 
1e69			 
1e69				; get back the saved start of the token 
1e69			 
1e69 d9				exx 
1e6a e5				push hl     ; save start of token just in case it is the right one 
1e6b d9				exx 
1e6c e1				pop hl        ; save it to hl 
1e6d			 
1e6d c9				ret 
1e6e			 
1e6e			 
1e6e			; LIST needs to find a specific token   
1e6e			; FORGET needs to find a spefici token 
1e6e			 
1e6e			; SAVE needs to find all tokens by flag 
1e6e			; WORDS just needs to scan through all  by flag 
1e6e			; UWORDS needs to scan through all by flag 
1e6e			 
1e6e			 
1e6e			; given hl as pointer to start of dict look up string 
1e6e			; return hl as pointer to start of word block 
1e6e			; or 0 if not found 
1e6e			 
1e6e			forth_find_tok: 
1e6e c9				ret 
1e6f			 
1e6f			; given hl as pointer to dict structure 
1e6f			; move to the next dict block structure 
1e6f			 
1e6f			forth_tok_next: 
1e6f				; hl now points to the address of the next word pointer  
1e6f				; TODO skip compiled symbol for now 
1e6f			;	push de 
1e6f 23				inc hl 
1e70 5e				ld e, (hl) 
1e71 23				inc hl 
1e72 56				ld d, (hl) 
1e73 23				inc hl 
1e74			 
1e74 eb				ex de,hl 
1e75			if DEBUG_FORTH_PARSE_NEXTWORD 
1e75				push bc 
1e75				ld bc, (cli_nextword) 
1e75						DMARK "NXW" 
1e75				CALLMONITOR 
1e75				pop bc 
1e75			endif 
1e75			;	pop de	 
1e75 c9				ret 
1e76			 
1e76			 
1e76			 
1e76			; eof 
# End of file forth_parserv5.asm
1e76				include "forth_wordsv4.asm" 
1e76			 
1e76			; the core word dictionary v4 
1e76			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1e76			 
1e76			; this is a linked list for each of the system words used 
1e76			; user defined words will follow the same format but will be in ram 
1e76			 
1e76			 
1e76			; 
1e76			; 
1e76			; define linked list: 
1e76			; 
1e76			; 1. compiled byte op code 
1e76			; 2. len of text word 
1e76			; 3. text word 
1e76			; 4. ptr to next dictionary word 
1e76			; 5. asm, calls etc for the word 
1e76			; 
1e76			;  if 1 == 0 then last word in dict  
1e76			;   
1e76			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1e76			;  
1e76			;  
1e76			; create basic standard set of words 
1e76			; 
1e76			;  
1e76			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1e76			; 2DUP 2DROP 2SWAP  
1e76			; @ C@ - get byte  
1e76			; ! C! - store byte 
1e76			; 0< true if less than zero 
1e76			; 0= true if zero 
1e76			; < >  
1e76			; = true if same 
1e76			; variables 
1e76			 
1e76			 
1e76			; Hardware specific words I may need 
1e76			; 
1e76			; IN OUT  
1e76			; calls to key util functions 
1e76			; calls to hardward abstraction stuff 
1e76			; easy control of frame buffers and lcd i/o 
1e76			; keyboard  
1e76			 
1e76			 
1e76			;DICT: macro 
1e76			; op_code, len, word, next 
1e76			;    word: 
1e76			;    db op_code 
1e76			;    ds word zero term 
1e76			;    dw next 
1e76			;    endm 
1e76			 
1e76			 
1e76			 
1e76			 
1e76			; op code 1 is a flag for user define words which are to be handled differently 
1e76			 
1e76			 
1e76			; 
1e76			; 
1e76			;    TODO on entry to a word this should be the expected environment 
1e76			;    hl - tos value if number then held, if string this is the ptr 
1e76			;    de -  
1e76			 
1e76			 
1e76			; opcode ranges 
1e76			; 0 - end of word dict 
1e76			; 255 - user define words 
1e76			 
1e76			sysdict: 
1e76			include "forth_opcodes.asm" 
1e76			; op codes for forth keywords 
1e76			; free to use code 0  
1e76				OPCODE_HEAP: equ  1 
1e76				OPCODE_EXEC: equ 2 
1e76				OPCODE_DUP: equ 3 
1e76				OPCODE_SWAP: equ 4 
1e76				OPCODE_COLN: equ 5 
1e76				OPCODE_SCOLN: equ 6 
1e76				OPCODE_DROP: equ 7 
1e76				OPCODE_DUP2: equ 8 
1e76				OPCODE_DROP2: equ 9 
1e76				OPCODE_SWAP2: equ 10 
1e76				OPCODE_AT: equ 11 
1e76				OPCODE_CAT: equ 12 
1e76				OPCODE_BANG: equ 13 
1e76				OPCODE_CBANG: equ 14 
1e76				OPCODE_SCALL: equ 15 
1e76				OPCODE_DEPTH: equ 16 
1e76				OPCODE_OVER: equ 17 
1e76				OPCODE_PAUSE: equ 18 
1e76				OPCODE_PAUSES: equ 19 
1e76				OPCODE_ROT: equ 20 
1e76			;free to reuse	OPCODE_WORDS: equ 21 
1e76			        OPCODE_NOT: equ 21 
1e76				OPCODE_UWORDS: equ 22 
1e76				OPCODE_BP: equ 23 
1e76				OPCODE_MONITOR: equ 24  
1e76				OPCODE_MALLOC: equ 25 
1e76				OPCODE_FREE: equ 26 
1e76				OPCODE_LIST: equ 27 
1e76				OPCODE_FORGET: equ 28 
1e76				OPCODE_NOP: equ 29 
1e76				OPCODE_COMO: equ 30 
1e76				OPCODE_COMC: equ 31 
1e76			;free to reuse	OPCODE_ENDCORE: equ 32 
1e76				OPCODE_AFTERSOUND: equ 33 
1e76				OPCODE_GP2: equ 34 
1e76				OPCODE_GP3: equ 35 
1e76				OPCODE_GP4: equ 36 
1e76				OPCODE_SIN: equ 37 
1e76				OPCODE_SOUT: equ 38 
1e76				OPCODE_SPIO: equ 39 
1e76				OPCODE_SPICEH: equ 40 
1e76				OPCODE_SPIOb: equ 41 
1e76				OPCODE_SPII: equ 42 
1e76				OPCODE_SESEL: equ 43 
1e76				OPCODE_CARTDEV: equ 44 
1e76			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1e76				OPCODE_FB: equ 46 
1e76				OPCODE_EMIT: equ 47 
1e76				OPCODE_DOTH: equ 48 
1e76				OPCODE_DOTF: equ 49 
1e76				OPCODE_DOT: equ 50 
1e76				OPCODE_CLS: equ 51 
1e76				OPCODE_DRAW: equ 52 
1e76				OPCODE_DUMP: equ 53 
1e76				OPCODE_CDUMP: equ 54 
1e76				OPCODE_DAT: equ 55 
1e76				OPCODE_HOME: equ 56 
1e76				OPCODE_SPACE: equ 57 
1e76				OPCODE_SPACES: equ 58 
1e76				OPCODE_SCROLL: equ 59 
1e76				OPCODE_ATQ: equ 60 
1e76				OPCODE_AUTODSP: equ 61 
1e76				OPCODE_MENU: equ 62 
1e76			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1e76				OPCODE_THEN: equ 64 
1e76				OPCODE_ELSE: equ 65 
1e76				OPCODE_DO: equ 66 
1e76				OPCODE_LOOP: equ 67 
1e76				OPCODE_I: equ 68 
1e76				OPCODE_DLOOP: equ 69  
1e76				OPCODE_REPEAT: equ 70  
1e76				OPCODE_UNTIL: equ 71 
1e76				OPCODE_ENDFLOW: equ 72 
1e76				OPCODE_WAITK: equ 73 
1e76				OPCODE_ACCEPT: equ 74 
1e76				OPCODE_EDIT: equ 75 
1e76			;free to reuse	OPCODE_ENDKEY: equ 76 
1e76				OPCODE_LZERO: equ 77 
1e76				OPCODE_TZERO: equ 78 
1e76				OPCODE_LESS: equ 79 
1e76				OPCODE_GT: equ 80 
1e76				OPCODE_EQUAL: equ 81  
1e76			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1e76				OPCODE_NEG: equ 83 
1e76				OPCODE_DIV: equ 84 
1e76				OPCODE_MUL: equ 85 
1e76				OPCODE_MIN: equ 86 
1e76				OPCODE_MAX: equ 87 
1e76				OPCODE_RND16: equ 88 
1e76				OPCODE_RND8: equ 89 
1e76				OPCODE_RND: equ 90 
1e76			;free to reuse	OPCODE_ENDMATHS: equ 91  
1e76				OPCODE_BYNAME: equ 92 
1e76				OPCODE_DIR: equ 93 
1e76				OPCODE_SAVE: equ 94 
1e76				OPCODE_LOAD: equ 95 
1e76				OPCODE_BSAVE: equ 96 
1e76				OPCODE_BLOAD: equ 97 
1e76				OPCODE_SEO: equ 98  
1e76				OPCODE_SEI: equ 99 
1e76				OPCODE_SFREE: equ 100 
1e76				OPCODE_SIZE: equ 101 
1e76				OPCODE_CREATE: equ 102 
1e76				OPCODE_APPEND: equ 103 
1e76				OPCODE_SDEL: equ 104 
1e76				OPCODE_OPEN: equ 105 
1e76				OPCODE_READ: equ 106 
1e76				OPCODE_EOF: equ 106 
1e76				OPCODE_FORMAT: equ 107 
1e76				OPCODE_LABEL: equ 108 
1e76				OPCODE_LABELS: equ 109 
1e76			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1e76				OPCODE_UPPER: equ 111 
1e76				OPCODE_LOWER: equ 112 
1e76				OPCODE_SUBSTR: equ 113 
1e76				OPCODE_LEFT: equ 114 
1e76				OPCODE_RIGHT: equ 115 
1e76				OPCODE_STR2NUM: equ 116 
1e76				OPCODE_NUM2STR: equ 117 
1e76				OPCODE_CONCAT: equ 118 
1e76				OPCODE_FIND: equ 119 
1e76				OPCODE_LEN: equ 120 
1e76				OPCODE_CHAR: equ 121 
1e76			; free to reuse	OPCODE_STRLEN: equ 122 
1e76			; free to reuse	OPCODE_ENDSTR: equ 123 
1e76				OPCODE_V0S: equ 124 
1e76				OPCODE_V0Q: equ 125 
1e76				OPCODE_V1S: equ 126 
1e76				OPCODE_V1Q: equ 127 
1e76				OPCODE_V2S: equ 128 
1e76				OPCODE_V2Q: equ 129 
1e76				OPCODE_V3S: equ 130 
1e76				OPCODE_V3Q: equ 131 
1e76			;free to reuse	OPCODE_END: equ 132 
1e76				OPCODE_ZDUP: equ 133 
1e76			 
1e76			; eof 
# End of file forth_opcodes.asm
1e76			 
1e76			include "forth_words_core.asm" 
1e76			 
1e76			; | ## Core Words 
1e76			 
1e76			;if MALLOC_4 
1e76			 
1e76			.HEAP: 
1e76				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1e76 15				db WORD_SYS_CORE+OPCODE_HEAP             
1e77 b5 1e			dw .EXEC            
1e79 05				db 4 + 1 
1e7a .. 00			db "HEAP",0              
1e7f				endm 
# End of macro CWHEAD
1e7f			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1e7f			; | | u1 - Current number of bytes in the heap 
1e7f			; | | u2 - Remaining bytes left on the heap 
1e7f			; | |  
1e7f			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1e7f			 
1e7f			 
1e7f					if DEBUG_FORTH_WORDS_KEY 
1e7f						DMARK "HEP" 
1e7f f5				push af  
1e80 3a 94 1e			ld a, (.dmark)  
1e83 32 7a ee			ld (debug_mark),a  
1e86 3a 95 1e			ld a, (.dmark+1)  
1e89 32 7b ee			ld (debug_mark+1),a  
1e8c 3a 96 1e			ld a, (.dmark+2)  
1e8f 32 7c ee			ld (debug_mark+2),a  
1e92 18 03			jr .pastdmark  
1e94 ..			.dmark: db "HEP"  
1e97 f1			.pastdmark: pop af  
1e98			endm  
# End of macro DMARK
1e98						CALLMONITOR 
1e98 cd 28 14			call break_point_state  
1e9b				endm  
# End of macro CALLMONITOR
1e9b					endif 
1e9b 2a 9c 58				ld hl, (free_list )      
1e9e 11 a1 58				ld de, heap_start 
1ea1			 
1ea1 ed 52				sbc hl, de  
1ea3			 
1ea3 cd b5 19				call forth_push_numhl 
1ea6			 
1ea6			 
1ea6 ed 5b 9c 58			ld de, (free_list )      
1eaa 21 46 e3				ld hl, heap_end 
1ead			 
1ead ed 52				sbc hl, de 
1eaf			 
1eaf cd b5 19				call forth_push_numhl 
1eb2					 
1eb2			 
1eb2					 
1eb2			 
1eb2			 
1eb2			 
1eb2					NEXTW 
1eb2 c3 1e 1d			jp macro_next 
1eb5				endm 
# End of macro NEXTW
1eb5			;endif 
1eb5			 
1eb5			.EXEC: 
1eb5			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1eb5			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
1eb5			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1eb5			;; > > 
1eb5			;; > >   
1eb5			;	STACKFRAME OFF $5efe $5f9f 
1eb5			; 
1eb5			;		if DEBUG_FORTH_WORDS_KEY 
1eb5			;			DMARK "EXE" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			; 
1eb5			;	FORTH_DSP_VALUEHL 
1eb5			; 
1eb5			;	FORTH_DSP_POP 
1eb5			; 
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EX1" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			;;	ld e,(hl) 
1eb5			;;	inc hl 
1eb5			;;	ld d,(hl) 
1eb5			;;	ex de,hl 
1eb5			; 
1eb5			;;		if DEBUG_FORTH_WORDS 
1eb5			;;			DMARK "EX2" 
1eb5			;;			CALLMONITOR 
1eb5			;;		endif 
1eb5			;	push hl 
1eb5			; 
1eb5			;	;ld a, 0 
1eb5			;	;ld a, FORTH_END_BUFFER 
1eb5			;	call strlenz 
1eb5			;	inc hl   ; include zero term to copy 
1eb5			;	inc hl   ; include term 
1eb5			;	inc hl   ; include term 
1eb5			;	ld b,0 
1eb5			;	ld c,l 
1eb5			;	pop hl 
1eb5			;	ld de, execscratch 
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EX3" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			;	ldir 
1eb5			; 
1eb5			; 
1eb5			;	ld hl, execscratch 
1eb5			; 
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EXe" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			; 
1eb5			;	call forthparse 
1eb5			;	call forthexec 
1eb5			;;	call forthexec_cleanup 
1eb5			;;	call forthparse 
1eb5			;;	call forthexec 
1eb5			; 
1eb5			;	STACKFRAMECHK OFF $5efe $5f9f 
1eb5			; 
1eb5			;	; an immediate word so no need to process any more words 
1eb5			;	ret 
1eb5			;	NEXTW 
1eb5			 
1eb5			; dead code - old version  
1eb5			;	FORTH_RSP_NEXT 
1eb5			 
1eb5			;  
1eb5			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1eb5			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1eb5			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1eb5			;	push hl 
1eb5			;	push de 
1eb5			;	push bc 
1eb5			; 
1eb5			; 
1eb5			;		if DEBUG_FORTH_WORDS_KEY 
1eb5			;			DMARK "EXR" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			; 
1eb5			; 
1eb5			; 
1eb5			;	;v5 FORTH_DSP_VALUE 
1eb5			;	FORTH_DSP_VALUEHL 
1eb5			; 
1eb5			;	; TODO do string type checks 
1eb5			; 
1eb5			;;v5	inc hl   ; skip type 
1eb5			; 
1eb5			;	push hl  ; source code  
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EX1" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			;	ld a, 0 
1eb5			;	call strlent 
1eb5			; 
1eb5			;	inc hl 
1eb5			;	inc hl 
1eb5			;	inc hl 
1eb5			;	inc hl 
1eb5			; 
1eb5			;	push hl    ; size 
1eb5			; 
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EX2" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			;	call malloc 
1eb5			; 
1eb5			;	ex de, hl    ; de now contains malloc area 
1eb5			;	pop bc   	; get byte count 
1eb5			;	pop hl      ; get string to copy 
1eb5			; 
1eb5			;	push de     ; save malloc for free later 
1eb5			; 
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EX3" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			;	ldir       ; duplicate string 
1eb5			; 
1eb5			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1eb5			;	 
1eb5			;	; TODO fix the parse would be better than this...  
1eb5			;	ex de, hl 
1eb5			;	dec hl 
1eb5			;	ld a, 0 
1eb5			;	ld (hl), a 
1eb5			;	dec hl 
1eb5			;	ld a, ' ' 
1eb5			;	ld (hl), a 
1eb5			;	dec hl 
1eb5			;	ld (hl), a 
1eb5			; 
1eb5			;	dec hl 
1eb5			;	ld (hl), a 
1eb5			; 
1eb5			; 
1eb5			;	FORTH_DSP_POP  
1eb5			; 
1eb5			;	pop hl     
1eb5			;	push hl    ; save malloc area 
1eb5			; 
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EX4" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			; 
1eb5			;	call forthparse 
1eb5			;	call forthexec 
1eb5			;	 
1eb5			;	pop hl 
1eb5			;	if DEBUG_FORTH_WORDS 
1eb5			;		DMARK "EX5" 
1eb5			;		CALLMONITOR 
1eb5			;	endif 
1eb5			; 
1eb5			;	if FORTH_ENABLE_FREE 
1eb5			;	call free 
1eb5			;	endif 
1eb5			; 
1eb5			;	if DEBUG_FORTH_WORDS 
1eb5			;		DMARK "EX6" 
1eb5			;		CALLMONITOR 
1eb5			;	endif 
1eb5			; 
1eb5			;	pop bc 
1eb5			;	pop de 
1eb5			;	pop hl 
1eb5			;;	FORTH_RSP_POP	  
1eb5			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1eb5			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1eb5			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1eb5			; 
1eb5			;	if DEBUG_FORTH_WORDS 
1eb5			;		DMARK "EX7" 
1eb5			;		CALLMONITOR 
1eb5			;	endif 
1eb5			;	NEXTW 
1eb5			 
1eb5			;.STKEXEC: 
1eb5			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1eb5			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
1eb5			; 
1eb5			; 
1eb5			;		if DEBUG_FORTH_WORDS_KEY 
1eb5			;			DMARK "STX" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			; 
1eb5			;	FORTH_DSP_VALUEHL 
1eb5			; 
1eb5			;	ld (store_tmp1), hl    ; count 
1eb5			; 
1eb5			;	FORTH_DSP_POP 
1eb5			;.stkexec1: 
1eb5			;	ld hl, (store_tmp1)   ; count 
1eb5			;	ld a, 0 
1eb5			;	cp l 
1eb5			;	ret z 
1eb5			; 
1eb5			;	dec hl 
1eb5			;	ld (store_tmp1), hl    ; count 
1eb5			;	 
1eb5			;	FORTH_DSP_VALUEHL 
1eb5			;	push hl 
1eb5			;	 
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EXp" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			;	FORTH_DSP_POP 
1eb5			; 
1eb5			;	call strlenz 
1eb5			;	inc hl   ; include zero term to copy 
1eb5			;	inc hl   ; include zero term to copy 
1eb5			;	inc hl   ; include zero term to copy 
1eb5			;	ld b,0 
1eb5			;	ld c,l 
1eb5			;	pop hl 
1eb5			;	ld de, execscratch 
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EX3" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			;	ldir 
1eb5			; 
1eb5			; 
1eb5			;	ld hl, execscratch 
1eb5			; 
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EXP" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			; 
1eb5			;	call forthparse 
1eb5			;	ld hl, execscratch 
1eb5			;		if DEBUG_FORTH_WORDS 
1eb5			;			DMARK "EXx" 
1eb5			;			CALLMONITOR 
1eb5			;		endif 
1eb5			;	call forthexec 
1eb5			; 
1eb5			;	jp .stkexec1 
1eb5			; 
1eb5			;	ret 
1eb5			 
1eb5			 
1eb5			.DUP: 
1eb5				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1eb5 17				db WORD_SYS_CORE+OPCODE_DUP             
1eb6 2b 1f			dw .ZDUP            
1eb8 04				db 3 + 1 
1eb9 .. 00			db "DUP",0              
1ebd				endm 
# End of macro CWHEAD
1ebd			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1ebd			 
1ebd					if DEBUG_FORTH_WORDS_KEY 
1ebd						DMARK "DUP" 
1ebd f5				push af  
1ebe 3a d2 1e			ld a, (.dmark)  
1ec1 32 7a ee			ld (debug_mark),a  
1ec4 3a d3 1e			ld a, (.dmark+1)  
1ec7 32 7b ee			ld (debug_mark+1),a  
1eca 3a d4 1e			ld a, (.dmark+2)  
1ecd 32 7c ee			ld (debug_mark+2),a  
1ed0 18 03			jr .pastdmark  
1ed2 ..			.dmark: db "DUP"  
1ed5 f1			.pastdmark: pop af  
1ed6			endm  
# End of macro DMARK
1ed6						CALLMONITOR 
1ed6 cd 28 14			call break_point_state  
1ed9				endm  
# End of macro CALLMONITOR
1ed9					endif 
1ed9			 
1ed9					FORTH_DSP 
1ed9 cd 72 1b			call macro_forth_dsp 
1edc				endm 
# End of macro FORTH_DSP
1edc			 
1edc 7e					ld a, (HL) 
1edd fe 01				cp DS_TYPE_STR 
1edf 20 25				jr nz, .dupinum 
1ee1			 
1ee1					; push another string 
1ee1			 
1ee1					FORTH_DSP_VALUEHL     		 
1ee1 cd ac 1b			call macro_dsp_valuehl 
1ee4				endm 
# End of macro FORTH_DSP_VALUEHL
1ee4			 
1ee4				if DEBUG_FORTH_WORDS 
1ee4					DMARK "DUs" 
1ee4 f5				push af  
1ee5 3a f9 1e			ld a, (.dmark)  
1ee8 32 7a ee			ld (debug_mark),a  
1eeb 3a fa 1e			ld a, (.dmark+1)  
1eee 32 7b ee			ld (debug_mark+1),a  
1ef1 3a fb 1e			ld a, (.dmark+2)  
1ef4 32 7c ee			ld (debug_mark+2),a  
1ef7 18 03			jr .pastdmark  
1ef9 ..			.dmark: db "DUs"  
1efc f1			.pastdmark: pop af  
1efd			endm  
# End of macro DMARK
1efd					CALLMONITOR 
1efd cd 28 14			call break_point_state  
1f00				endm  
# End of macro CALLMONITOR
1f00				endif 
1f00 cd 23 1a				call forth_push_str 
1f03			 
1f03					NEXTW 
1f03 c3 1e 1d			jp macro_next 
1f06				endm 
# End of macro NEXTW
1f06			 
1f06			 
1f06			.dupinum: 
1f06					 
1f06			 
1f06			 
1f06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f06 cd ac 1b			call macro_dsp_valuehl 
1f09				endm 
# End of macro FORTH_DSP_VALUEHL
1f09			 
1f09				; TODO add floating point number detection 
1f09			 
1f09				if DEBUG_FORTH_WORDS 
1f09					DMARK "DUi" 
1f09 f5				push af  
1f0a 3a 1e 1f			ld a, (.dmark)  
1f0d 32 7a ee			ld (debug_mark),a  
1f10 3a 1f 1f			ld a, (.dmark+1)  
1f13 32 7b ee			ld (debug_mark+1),a  
1f16 3a 20 1f			ld a, (.dmark+2)  
1f19 32 7c ee			ld (debug_mark+2),a  
1f1c 18 03			jr .pastdmark  
1f1e ..			.dmark: db "DUi"  
1f21 f1			.pastdmark: pop af  
1f22			endm  
# End of macro DMARK
1f22					CALLMONITOR 
1f22 cd 28 14			call break_point_state  
1f25				endm  
# End of macro CALLMONITOR
1f25				endif 
1f25			 
1f25 cd b5 19				call forth_push_numhl 
1f28					NEXTW 
1f28 c3 1e 1d			jp macro_next 
1f2b				endm 
# End of macro NEXTW
1f2b			.ZDUP: 
1f2b				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1f2b 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1f2c 63 1f			dw .SWAP            
1f2e 05				db 4 + 1 
1f2f .. 00			db "?DUP",0              
1f34				endm 
# End of macro CWHEAD
1f34			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1f34			 
1f34					if DEBUG_FORTH_WORDS_KEY 
1f34						DMARK "qDU" 
1f34 f5				push af  
1f35 3a 49 1f			ld a, (.dmark)  
1f38 32 7a ee			ld (debug_mark),a  
1f3b 3a 4a 1f			ld a, (.dmark+1)  
1f3e 32 7b ee			ld (debug_mark+1),a  
1f41 3a 4b 1f			ld a, (.dmark+2)  
1f44 32 7c ee			ld (debug_mark+2),a  
1f47 18 03			jr .pastdmark  
1f49 ..			.dmark: db "qDU"  
1f4c f1			.pastdmark: pop af  
1f4d			endm  
# End of macro DMARK
1f4d						CALLMONITOR 
1f4d cd 28 14			call break_point_state  
1f50				endm  
# End of macro CALLMONITOR
1f50					endif 
1f50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f50 cd ac 1b			call macro_dsp_valuehl 
1f53				endm 
# End of macro FORTH_DSP_VALUEHL
1f53			 
1f53 e5					push hl 
1f54			 
1f54					; is it a zero? 
1f54			 
1f54 3e 00				ld a, 0 
1f56 84					add h 
1f57 85					add l 
1f58			 
1f58 e1					pop hl 
1f59			 
1f59 fe 00				cp 0 
1f5b 28 03				jr z, .dup2orig 
1f5d			 
1f5d			 
1f5d cd b5 19				call forth_push_numhl 
1f60			 
1f60			 
1f60				; TODO add floating point number detection 
1f60			 
1f60			.dup2orig: 
1f60			 
1f60					NEXTW 
1f60 c3 1e 1d			jp macro_next 
1f63				endm 
# End of macro NEXTW
1f63			.SWAP: 
1f63				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1f63 18				db WORD_SYS_CORE+OPCODE_SWAP             
1f64 a2 1f			dw .COLN            
1f66 05				db 4 + 1 
1f67 .. 00			db "SWAP",0              
1f6c				endm 
# End of macro CWHEAD
1f6c			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1f6c					if DEBUG_FORTH_WORDS_KEY 
1f6c						DMARK "SWP" 
1f6c f5				push af  
1f6d 3a 81 1f			ld a, (.dmark)  
1f70 32 7a ee			ld (debug_mark),a  
1f73 3a 82 1f			ld a, (.dmark+1)  
1f76 32 7b ee			ld (debug_mark+1),a  
1f79 3a 83 1f			ld a, (.dmark+2)  
1f7c 32 7c ee			ld (debug_mark+2),a  
1f7f 18 03			jr .pastdmark  
1f81 ..			.dmark: db "SWP"  
1f84 f1			.pastdmark: pop af  
1f85			endm  
# End of macro DMARK
1f85						CALLMONITOR 
1f85 cd 28 14			call break_point_state  
1f88				endm  
# End of macro CALLMONITOR
1f88					endif 
1f88			 
1f88					FORTH_DSP_VALUEHL 
1f88 cd ac 1b			call macro_dsp_valuehl 
1f8b				endm 
# End of macro FORTH_DSP_VALUEHL
1f8b e5					push hl     ; w2 
1f8c			 
1f8c					FORTH_DSP_POP 
1f8c cd 64 1c			call macro_forth_dsp_pop 
1f8f				endm 
# End of macro FORTH_DSP_POP
1f8f			 
1f8f					FORTH_DSP_VALUEHL 
1f8f cd ac 1b			call macro_dsp_valuehl 
1f92				endm 
# End of macro FORTH_DSP_VALUEHL
1f92			 
1f92					FORTH_DSP_POP 
1f92 cd 64 1c			call macro_forth_dsp_pop 
1f95				endm 
# End of macro FORTH_DSP_POP
1f95			 
1f95 d1					pop de     ; w2	, hl = w1 
1f96			 
1f96 eb					ex de, hl 
1f97 d5					push de 
1f98			 
1f98 cd b5 19				call forth_push_numhl 
1f9b			 
1f9b e1					pop hl 
1f9c			 
1f9c cd b5 19				call forth_push_numhl 
1f9f					 
1f9f			 
1f9f					NEXTW 
1f9f c3 1e 1d			jp macro_next 
1fa2				endm 
# End of macro NEXTW
1fa2			.COLN: 
1fa2				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1fa2 19				db WORD_SYS_CORE+OPCODE_COLN             
1fa3 2e 21			dw .SCOLN            
1fa5 02				db 1 + 1 
1fa6 .. 00			db ":",0              
1fa8				endm 
# End of macro CWHEAD
1fa8			; | : ( -- )         Create new word | DONE 
1fa8			 
1fa8					if DEBUG_FORTH_WORDS_KEY 
1fa8						DMARK "CLN" 
1fa8 f5				push af  
1fa9 3a bd 1f			ld a, (.dmark)  
1fac 32 7a ee			ld (debug_mark),a  
1faf 3a be 1f			ld a, (.dmark+1)  
1fb2 32 7b ee			ld (debug_mark+1),a  
1fb5 3a bf 1f			ld a, (.dmark+2)  
1fb8 32 7c ee			ld (debug_mark+2),a  
1fbb 18 03			jr .pastdmark  
1fbd ..			.dmark: db "CLN"  
1fc0 f1			.pastdmark: pop af  
1fc1			endm  
# End of macro DMARK
1fc1						CALLMONITOR 
1fc1 cd 28 14			call break_point_state  
1fc4				endm  
# End of macro CALLMONITOR
1fc4					endif 
1fc4				STACKFRAME OFF $8efe $989f 
1fc4				if DEBUG_STACK_IMB 
1fc4					if OFF 
1fc4						exx 
1fc4						ld de, $8efe 
1fc4						ld a, d 
1fc4						ld hl, curframe 
1fc4						call hexout 
1fc4						ld a, e 
1fc4						ld hl, curframe+2 
1fc4						call hexout 
1fc4						ld hl, $8efe 
1fc4						push hl 
1fc4						ld hl, $989f 
1fc4						push hl 
1fc4						exx 
1fc4					endif 
1fc4				endif 
1fc4			endm 
# End of macro STACKFRAME
1fc4				; get parser buffer length  of new word 
1fc4			 
1fc4				 
1fc4			 
1fc4					; move tok past this to start of name defintition 
1fc4					; TODO get word to define 
1fc4					; TODO Move past word token 
1fc4					; TODO get length of string up to the ';' 
1fc4			 
1fc4 2a 61 e6			ld hl, (os_tok_ptr) 
1fc7 23				inc hl 
1fc8 23				inc hl 
1fc9			 
1fc9 3e 3b			ld a, ';' 
1fcb cd 1e 10			call strlent 
1fce			 
1fce 7d				ld a,l 
1fcf 32 5c e3			ld (os_new_parse_len), a 
1fd2			 
1fd2			 
1fd2			if DEBUG_FORTH_UWORD 
1fd2 ed 5b 61 e6		ld de, (os_tok_ptr) 
1fd6						DMARK ":01" 
1fd6 f5				push af  
1fd7 3a eb 1f			ld a, (.dmark)  
1fda 32 7a ee			ld (debug_mark),a  
1fdd 3a ec 1f			ld a, (.dmark+1)  
1fe0 32 7b ee			ld (debug_mark+1),a  
1fe3 3a ed 1f			ld a, (.dmark+2)  
1fe6 32 7c ee			ld (debug_mark+2),a  
1fe9 18 03			jr .pastdmark  
1feb ..			.dmark: db ":01"  
1fee f1			.pastdmark: pop af  
1fef			endm  
# End of macro DMARK
1fef				CALLMONITOR 
1fef cd 28 14			call break_point_state  
1ff2				endm  
# End of macro CALLMONITOR
1ff2			endif 
1ff2			 
1ff2			; 
1ff2			;  new word memory layout: 
1ff2			;  
1ff2			;    : adg 6666 ;  
1ff2			; 
1ff2			;    db   1     ; user defined word  
1ff2 23				inc hl    
1ff3			;    dw   sysdict 
1ff3 23				inc hl 
1ff4 23				inc hl 
1ff5			;    db <word len>+1 (for null) 
1ff5 23				inc hl 
1ff6			;    db .... <word> 
1ff6			; 
1ff6			 
1ff6 23				inc hl    ; some extras for the word preamble before the above 
1ff7 23				inc hl 
1ff8 23				inc hl 
1ff9 23				inc hl 
1ffa 23				inc hl 
1ffb 23				inc hl 
1ffc 23				inc hl  
1ffd 23				inc hl 
1ffe 23				inc hl 
1fff 23				inc hl 
2000 23				inc hl 
2001 23				inc hl 
2002 23				inc hl 
2003 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2004			;       exec word buffer 
2004			;	<ptr word>   
2004 23				inc hl 
2005 23				inc hl 
2006			;       <word list><null term> 7F final term 
2006			 
2006			 
2006			if DEBUG_FORTH_UWORD 
2006						DMARK ":02" 
2006 f5				push af  
2007 3a 1b 20			ld a, (.dmark)  
200a 32 7a ee			ld (debug_mark),a  
200d 3a 1c 20			ld a, (.dmark+1)  
2010 32 7b ee			ld (debug_mark+1),a  
2013 3a 1d 20			ld a, (.dmark+2)  
2016 32 7c ee			ld (debug_mark+2),a  
2019 18 03			jr .pastdmark  
201b ..			.dmark: db ":02"  
201e f1			.pastdmark: pop af  
201f			endm  
# End of macro DMARK
201f				CALLMONITOR 
201f cd 28 14			call break_point_state  
2022				endm  
# End of macro CALLMONITOR
2022			endif 
2022			 
2022				 
2022					; malloc the size 
2022			 
2022 cd 7c 10				call malloc 
2025 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
2028			 
2028			;    db   1     ; user defined word  
2028 3e 01				ld a, WORD_SYS_UWORD  
202a 77					ld (hl), a 
202b				 
202b 23				inc hl    
202c			;    dw   sysdict 
202c 11 76 1e			ld de, sysdict       ; continue on with the scan to the system dict 
202f 73				ld (hl), e 
2030 23				inc hl 
2031 72				ld (hl), d 
2032 23				inc hl 
2033			 
2033			 
2033			;    Setup dict word 
2033			 
2033 23				inc hl 
2034 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
2037			 
2037				; 1. get length of dict word 
2037			 
2037			 
2037 2a 61 e6			ld hl, (os_tok_ptr) 
203a 23				inc hl 
203b 23				inc hl    ; position to start of dict word 
203c 3e 00			ld a, 0 
203e cd 1e 10			call strlent 
2041			 
2041			 
2041 23				inc hl    ; to include null??? 
2042			 
2042				; write length of dict word 
2042			 
2042 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2046 1b				dec de 
2047 eb				ex de, hl 
2048 73				ld (hl), e 
2049 eb				ex de, hl 
204a			 
204a				 
204a			 
204a				; copy  
204a 4d				ld c, l 
204b 06 00			ld b, 0 
204d ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2051 2a 61 e6			ld hl, (os_tok_ptr) 
2054 23				inc hl 
2055 23				inc hl    ; position to start of dict word 
2056				 
2056			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2056				 
2056				; TODO need to convert word to upper case 
2056			 
2056			ucasetok:	 
2056 7e				ld a,(hl) 
2057 cd 0a 10			call toUpper 
205a 77				ld (hl),a 
205b ed a0			ldi 
205d f2 56 20		 	jp p, ucasetok 
2060			 
2060			 
2060			 
2060				; de now points to start of where the word body code should be placed 
2060 ed 53 58 e3		ld (os_new_work_ptr), de 
2064				; hl now points to the words to throw at forthexec which needs to be copied 
2064 22 56 e3			ld (os_new_src_ptr), hl 
2067			 
2067				; TODO add 'call to forthexec' 
2067			 
2067			if DEBUG_FORTH_UWORD 
2067 c5				push bc 
2068 ed 4b 5e e3		ld bc, (os_new_malloc) 
206c						DMARK ":0x" 
206c f5				push af  
206d 3a 81 20			ld a, (.dmark)  
2070 32 7a ee			ld (debug_mark),a  
2073 3a 82 20			ld a, (.dmark+1)  
2076 32 7b ee			ld (debug_mark+1),a  
2079 3a 83 20			ld a, (.dmark+2)  
207c 32 7c ee			ld (debug_mark+2),a  
207f 18 03			jr .pastdmark  
2081 ..			.dmark: db ":0x"  
2084 f1			.pastdmark: pop af  
2085			endm  
# End of macro DMARK
2085				CALLMONITOR 
2085 cd 28 14			call break_point_state  
2088				endm  
# End of macro CALLMONITOR
2088 c1				pop bc 
2089			endif 
2089			 
2089			 
2089				; create word preamble which should be: 
2089			 
2089			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2089			 
2089				;    ld hl, <word code> 
2089				;    jp user_exec 
2089			        ;    <word code bytes> 
2089			 
2089			 
2089			;	inc de     ; TODO ??? or are we already past the word's null 
2089 eb				ex de, hl 
208a			 
208a 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
208c			 
208c 23				inc hl 
208d 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2090 23				inc hl 
2091			 
2091 23				inc hl 
2092 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2094			 
2094 01 1d 44			ld bc, user_exec 
2097 23				inc hl 
2098 71				ld (hl), c     ; poke address of user_exec 
2099 23				inc hl 
209a 70				ld (hl), b     
209b			 ; 
209b			;	inc hl 
209b			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
209b			; 
209b			; 
209b			;	ld bc, macro_forth_rsp_next 
209b			;	inc hl 
209b			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
209b			;	inc hl 
209b			;	ld (hl), b     
209b			 ; 
209b			;	inc hl 
209b			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
209b			; 
209b			; 
209b			;	inc hl 
209b			;	ld bc, forthexec 
209b			;	ld (hl), c     ; poke address of forthexec 
209b			;	inc hl 
209b			;	ld (hl), b      
209b			; 
209b			;	inc hl 
209b			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
209b			; 
209b			;	ld bc, user_dict_next 
209b			;	inc hl 
209b			;	ld (hl), c     ; poke address of forthexec 
209b			;	inc hl 
209b			;	ld (hl), b      
209b			 
209b				; hl is now where we need to copy the word byte data to save this 
209b			 
209b 23				inc hl 
209c 22 54 e3			ld (os_new_exec), hl 
209f				 
209f				; copy definition 
209f			 
209f eb				ex de, hl 
20a0			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
20a0			;	inc de    ; skip the PC for this parse 
20a0 3a 5c e3			ld a, (os_new_parse_len) 
20a3 4f				ld c, a 
20a4 06 00			ld b, 0 
20a6 ed b0			ldir		 ; copy defintion 
20a8			 
20a8			 
20a8				; poke the address of where the new word bytes live for forthexec 
20a8			 
20a8 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
20ab			 
20ab ed 5b 54 e3		ld de, (os_new_exec)      
20af				 
20af 73				ld (hl), e 
20b0 23				inc hl 
20b1 72				ld (hl), d 
20b2			 
20b2					; TODO copy last user dict word next link to this word 
20b2					; TODO update last user dict word to point to this word 
20b2			; 
20b2			; hl f923 de 812a ; bc 811a 
20b2			 
20b2			if DEBUG_FORTH_UWORD 
20b2 c5				push bc 
20b3 ed 4b 5e e3		ld bc, (os_new_malloc) 
20b7						DMARK ":0A" 
20b7 f5				push af  
20b8 3a cc 20			ld a, (.dmark)  
20bb 32 7a ee			ld (debug_mark),a  
20be 3a cd 20			ld a, (.dmark+1)  
20c1 32 7b ee			ld (debug_mark+1),a  
20c4 3a ce 20			ld a, (.dmark+2)  
20c7 32 7c ee			ld (debug_mark+2),a  
20ca 18 03			jr .pastdmark  
20cc ..			.dmark: db ":0A"  
20cf f1			.pastdmark: pop af  
20d0			endm  
# End of macro DMARK
20d0				CALLMONITOR 
20d0 cd 28 14			call break_point_state  
20d3				endm  
# End of macro CALLMONITOR
20d3 c1				pop bc 
20d4			endif 
20d4			if DEBUG_FORTH_UWORD 
20d4 c5				push bc 
20d5 ed 4b 5e e3		ld bc, (os_new_malloc) 
20d9 03				inc bc 
20da 03				inc bc 
20db 03				inc bc 
20dc 03				inc bc 
20dd 03				inc bc 
20de 03				inc bc 
20df 03				inc bc 
20e0 03				inc bc 
20e1			 
20e1						DMARK ":0B" 
20e1 f5				push af  
20e2 3a f6 20			ld a, (.dmark)  
20e5 32 7a ee			ld (debug_mark),a  
20e8 3a f7 20			ld a, (.dmark+1)  
20eb 32 7b ee			ld (debug_mark+1),a  
20ee 3a f8 20			ld a, (.dmark+2)  
20f1 32 7c ee			ld (debug_mark+2),a  
20f4 18 03			jr .pastdmark  
20f6 ..			.dmark: db ":0B"  
20f9 f1			.pastdmark: pop af  
20fa			endm  
# End of macro DMARK
20fa				CALLMONITOR 
20fa cd 28 14			call break_point_state  
20fd				endm  
# End of macro CALLMONITOR
20fd c1				pop bc 
20fe			endif 
20fe			 
20fe			; update word dict linked list for new word 
20fe			 
20fe			 
20fe 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2101 23			inc hl     ; move to next work linked list ptr 
2102			 
2102 ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
2106 73			ld (hl), e 
2107 23			inc hl 
2108 72			ld (hl), d 
2109			 
2109			if DEBUG_FORTH_UWORD 
2109 ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
210d			endif 
210d			 
210d ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2111			 
2111			 
2111			if DEBUG_FORTH_UWORD 
2111						DMARK ":0+" 
2111 f5				push af  
2112 3a 26 21			ld a, (.dmark)  
2115 32 7a ee			ld (debug_mark),a  
2118 3a 27 21			ld a, (.dmark+1)  
211b 32 7b ee			ld (debug_mark+1),a  
211e 3a 28 21			ld a, (.dmark+2)  
2121 32 7c ee			ld (debug_mark+2),a  
2124 18 03			jr .pastdmark  
2126 ..			.dmark: db ":0+"  
2129 f1			.pastdmark: pop af  
212a			endm  
# End of macro DMARK
212a				CALLMONITOR 
212a cd 28 14			call break_point_state  
212d				endm  
# End of macro CALLMONITOR
212d			endif 
212d			 
212d				STACKFRAMECHK OFF $8efe $989f 
212d				if DEBUG_STACK_IMB 
212d					if OFF 
212d						exx 
212d						ld hl, $989f 
212d						pop de   ; $989f 
212d						call cmp16 
212d						jr nz, .spnosame 
212d						ld hl, $8efe 
212d						pop de   ; $8efe 
212d						call cmp16 
212d						jr z, .spfrsame 
212d						.spnosame: call showsperror 
212d						.spfrsame: nop 
212d						exx 
212d					endif 
212d				endif 
212d			endm 
# End of macro STACKFRAMECHK
212d			 
212d c9			ret    ; dont process any remaining parser tokens as they form new word 
212e			 
212e			 
212e			 
212e			 
212e			;		NEXT 
212e			.SCOLN: 
212e			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
212e 06				db OPCODE_SCOLN 
212f 7a 21			dw .DROP 
2131 02				db 2 
2132 .. 00			db ";",0           
2134			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2134					if DEBUG_FORTH_WORDS_KEY 
2134						DMARK "SCN" 
2134 f5				push af  
2135 3a 49 21			ld a, (.dmark)  
2138 32 7a ee			ld (debug_mark),a  
213b 3a 4a 21			ld a, (.dmark+1)  
213e 32 7b ee			ld (debug_mark+1),a  
2141 3a 4b 21			ld a, (.dmark+2)  
2144 32 7c ee			ld (debug_mark+2),a  
2147 18 03			jr .pastdmark  
2149 ..			.dmark: db "SCN"  
214c f1			.pastdmark: pop af  
214d			endm  
# End of macro DMARK
214d						CALLMONITOR 
214d cd 28 14			call break_point_state  
2150				endm  
# End of macro CALLMONITOR
2150					endif 
2150					FORTH_RSP_TOS 
2150 cd 73 19			call macro_forth_rsp_tos 
2153				endm 
# End of macro FORTH_RSP_TOS
2153 e5					push hl 
2154					FORTH_RSP_POP 
2154 cd 7d 19			call macro_forth_rsp_pop 
2157				endm 
# End of macro FORTH_RSP_POP
2157 e1					pop hl 
2158			;		ex de,hl 
2158 22 61 e6				ld (os_tok_ptr),hl 
215b			 
215b			if DEBUG_FORTH_UWORD 
215b						DMARK "SCL" 
215b f5				push af  
215c 3a 70 21			ld a, (.dmark)  
215f 32 7a ee			ld (debug_mark),a  
2162 3a 71 21			ld a, (.dmark+1)  
2165 32 7b ee			ld (debug_mark+1),a  
2168 3a 72 21			ld a, (.dmark+2)  
216b 32 7c ee			ld (debug_mark+2),a  
216e 18 03			jr .pastdmark  
2170 ..			.dmark: db "SCL"  
2173 f1			.pastdmark: pop af  
2174			endm  
# End of macro DMARK
2174				CALLMONITOR 
2174 cd 28 14			call break_point_state  
2177				endm  
# End of macro CALLMONITOR
2177			endif 
2177					NEXTW 
2177 c3 1e 1d			jp macro_next 
217a				endm 
# End of macro NEXTW
217a			 
217a			.DROP: 
217a				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
217a 1b				db WORD_SYS_CORE+OPCODE_DROP             
217b a5 21			dw .DUP2            
217d 05				db 4 + 1 
217e .. 00			db "DROP",0              
2183				endm 
# End of macro CWHEAD
2183			; | DROP ( w -- )   drop the TOS item   | DONE 
2183					if DEBUG_FORTH_WORDS_KEY 
2183						DMARK "DRP" 
2183 f5				push af  
2184 3a 98 21			ld a, (.dmark)  
2187 32 7a ee			ld (debug_mark),a  
218a 3a 99 21			ld a, (.dmark+1)  
218d 32 7b ee			ld (debug_mark+1),a  
2190 3a 9a 21			ld a, (.dmark+2)  
2193 32 7c ee			ld (debug_mark+2),a  
2196 18 03			jr .pastdmark  
2198 ..			.dmark: db "DRP"  
219b f1			.pastdmark: pop af  
219c			endm  
# End of macro DMARK
219c						CALLMONITOR 
219c cd 28 14			call break_point_state  
219f				endm  
# End of macro CALLMONITOR
219f					endif 
219f					FORTH_DSP_POP 
219f cd 64 1c			call macro_forth_dsp_pop 
21a2				endm 
# End of macro FORTH_DSP_POP
21a2					NEXTW 
21a2 c3 1e 1d			jp macro_next 
21a5				endm 
# End of macro NEXTW
21a5			.DUP2: 
21a5				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
21a5 1c				db WORD_SYS_CORE+OPCODE_DUP2             
21a6 ea 21			dw .DROP2            
21a8 05				db 4 + 1 
21a9 .. 00			db "2DUP",0              
21ae				endm 
# End of macro CWHEAD
21ae			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
21ae					if DEBUG_FORTH_WORDS_KEY 
21ae						DMARK "2DU" 
21ae f5				push af  
21af 3a c3 21			ld a, (.dmark)  
21b2 32 7a ee			ld (debug_mark),a  
21b5 3a c4 21			ld a, (.dmark+1)  
21b8 32 7b ee			ld (debug_mark+1),a  
21bb 3a c5 21			ld a, (.dmark+2)  
21be 32 7c ee			ld (debug_mark+2),a  
21c1 18 03			jr .pastdmark  
21c3 ..			.dmark: db "2DU"  
21c6 f1			.pastdmark: pop af  
21c7			endm  
# End of macro DMARK
21c7						CALLMONITOR 
21c7 cd 28 14			call break_point_state  
21ca				endm  
# End of macro CALLMONITOR
21ca					endif 
21ca					FORTH_DSP_VALUEHL 
21ca cd ac 1b			call macro_dsp_valuehl 
21cd				endm 
# End of macro FORTH_DSP_VALUEHL
21cd e5					push hl      ; 2 
21ce			 
21ce					FORTH_DSP_POP 
21ce cd 64 1c			call macro_forth_dsp_pop 
21d1				endm 
# End of macro FORTH_DSP_POP
21d1					 
21d1					FORTH_DSP_VALUEHL 
21d1 cd ac 1b			call macro_dsp_valuehl 
21d4				endm 
# End of macro FORTH_DSP_VALUEHL
21d4			;		push hl      ; 1 
21d4			 
21d4					FORTH_DSP_POP 
21d4 cd 64 1c			call macro_forth_dsp_pop 
21d7				endm 
# End of macro FORTH_DSP_POP
21d7			 
21d7			;		pop hl       ; 1 
21d7 d1					pop de       ; 2 
21d8			 
21d8 cd b5 19				call forth_push_numhl 
21db eb					ex de, hl 
21dc cd b5 19				call forth_push_numhl 
21df			 
21df					 
21df eb					ex de, hl 
21e0			 
21e0 cd b5 19				call forth_push_numhl 
21e3 eb					ex de, hl 
21e4 cd b5 19				call forth_push_numhl 
21e7			 
21e7			 
21e7					NEXTW 
21e7 c3 1e 1d			jp macro_next 
21ea				endm 
# End of macro NEXTW
21ea			.DROP2: 
21ea				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
21ea 1d				db WORD_SYS_CORE+OPCODE_DROP2             
21eb 19 22			dw .SWAP2            
21ed 06				db 5 + 1 
21ee .. 00			db "2DROP",0              
21f4				endm 
# End of macro CWHEAD
21f4			; | 2DROP ( w w -- )    Double drop | DONE 
21f4					if DEBUG_FORTH_WORDS_KEY 
21f4						DMARK "2DR" 
21f4 f5				push af  
21f5 3a 09 22			ld a, (.dmark)  
21f8 32 7a ee			ld (debug_mark),a  
21fb 3a 0a 22			ld a, (.dmark+1)  
21fe 32 7b ee			ld (debug_mark+1),a  
2201 3a 0b 22			ld a, (.dmark+2)  
2204 32 7c ee			ld (debug_mark+2),a  
2207 18 03			jr .pastdmark  
2209 ..			.dmark: db "2DR"  
220c f1			.pastdmark: pop af  
220d			endm  
# End of macro DMARK
220d						CALLMONITOR 
220d cd 28 14			call break_point_state  
2210				endm  
# End of macro CALLMONITOR
2210					endif 
2210					FORTH_DSP_POP 
2210 cd 64 1c			call macro_forth_dsp_pop 
2213				endm 
# End of macro FORTH_DSP_POP
2213					FORTH_DSP_POP 
2213 cd 64 1c			call macro_forth_dsp_pop 
2216				endm 
# End of macro FORTH_DSP_POP
2216					NEXTW 
2216 c3 1e 1d			jp macro_next 
2219				endm 
# End of macro NEXTW
2219			.SWAP2: 
2219				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2219 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
221a 42 22			dw .AT            
221c 06				db 5 + 1 
221d .. 00			db "2SWAP",0              
2223				endm 
# End of macro CWHEAD
2223			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2223					if DEBUG_FORTH_WORDS_KEY 
2223						DMARK "2SW" 
2223 f5				push af  
2224 3a 38 22			ld a, (.dmark)  
2227 32 7a ee			ld (debug_mark),a  
222a 3a 39 22			ld a, (.dmark+1)  
222d 32 7b ee			ld (debug_mark+1),a  
2230 3a 3a 22			ld a, (.dmark+2)  
2233 32 7c ee			ld (debug_mark+2),a  
2236 18 03			jr .pastdmark  
2238 ..			.dmark: db "2SW"  
223b f1			.pastdmark: pop af  
223c			endm  
# End of macro DMARK
223c						CALLMONITOR 
223c cd 28 14			call break_point_state  
223f				endm  
# End of macro CALLMONITOR
223f					endif 
223f					NEXTW 
223f c3 1e 1d			jp macro_next 
2242				endm 
# End of macro NEXTW
2242			.AT: 
2242				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2242 1f				db WORD_SYS_CORE+OPCODE_AT             
2243 74 22			dw .CAT            
2245 02				db 1 + 1 
2246 .. 00			db "@",0              
2248				endm 
# End of macro CWHEAD
2248			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2248			 
2248					if DEBUG_FORTH_WORDS_KEY 
2248						DMARK "AT." 
2248 f5				push af  
2249 3a 5d 22			ld a, (.dmark)  
224c 32 7a ee			ld (debug_mark),a  
224f 3a 5e 22			ld a, (.dmark+1)  
2252 32 7b ee			ld (debug_mark+1),a  
2255 3a 5f 22			ld a, (.dmark+2)  
2258 32 7c ee			ld (debug_mark+2),a  
225b 18 03			jr .pastdmark  
225d ..			.dmark: db "AT."  
2260 f1			.pastdmark: pop af  
2261			endm  
# End of macro DMARK
2261						CALLMONITOR 
2261 cd 28 14			call break_point_state  
2264				endm  
# End of macro CALLMONITOR
2264					endif 
2264			.getbyteat:	 
2264					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2264 cd ac 1b			call macro_dsp_valuehl 
2267				endm 
# End of macro FORTH_DSP_VALUEHL
2267					 
2267			;		push hl 
2267				 
2267					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2267 cd 64 1c			call macro_forth_dsp_pop 
226a				endm 
# End of macro FORTH_DSP_POP
226a			 
226a			;		pop hl 
226a			 
226a 7e					ld a, (hl) 
226b			 
226b 6f					ld l, a 
226c 26 00				ld h, 0 
226e cd b5 19				call forth_push_numhl 
2271			 
2271					NEXTW 
2271 c3 1e 1d			jp macro_next 
2274				endm 
# End of macro NEXTW
2274			.CAT: 
2274				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2274 20				db WORD_SYS_CORE+OPCODE_CAT             
2275 9d 22			dw .BANG            
2277 03				db 2 + 1 
2278 .. 00			db "C@",0              
227b				endm 
# End of macro CWHEAD
227b			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
227b					if DEBUG_FORTH_WORDS_KEY 
227b						DMARK "CAA" 
227b f5				push af  
227c 3a 90 22			ld a, (.dmark)  
227f 32 7a ee			ld (debug_mark),a  
2282 3a 91 22			ld a, (.dmark+1)  
2285 32 7b ee			ld (debug_mark+1),a  
2288 3a 92 22			ld a, (.dmark+2)  
228b 32 7c ee			ld (debug_mark+2),a  
228e 18 03			jr .pastdmark  
2290 ..			.dmark: db "CAA"  
2293 f1			.pastdmark: pop af  
2294			endm  
# End of macro DMARK
2294						CALLMONITOR 
2294 cd 28 14			call break_point_state  
2297				endm  
# End of macro CALLMONITOR
2297					endif 
2297 c3 64 22				jp .getbyteat 
229a					NEXTW 
229a c3 1e 1d			jp macro_next 
229d				endm 
# End of macro NEXTW
229d			.BANG: 
229d				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
229d 21				db WORD_SYS_CORE+OPCODE_BANG             
229e d3 22			dw .CBANG            
22a0 02				db 1 + 1 
22a1 .. 00			db "!",0              
22a3				endm 
# End of macro CWHEAD
22a3			; | ! ( x w -- ) Store x at address w      | DONE 
22a3					if DEBUG_FORTH_WORDS_KEY 
22a3						DMARK "BNG" 
22a3 f5				push af  
22a4 3a b8 22			ld a, (.dmark)  
22a7 32 7a ee			ld (debug_mark),a  
22aa 3a b9 22			ld a, (.dmark+1)  
22ad 32 7b ee			ld (debug_mark+1),a  
22b0 3a ba 22			ld a, (.dmark+2)  
22b3 32 7c ee			ld (debug_mark+2),a  
22b6 18 03			jr .pastdmark  
22b8 ..			.dmark: db "BNG"  
22bb f1			.pastdmark: pop af  
22bc			endm  
# End of macro DMARK
22bc						CALLMONITOR 
22bc cd 28 14			call break_point_state  
22bf				endm  
# End of macro CALLMONITOR
22bf					endif 
22bf			 
22bf			.storebyteat:		 
22bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22bf cd ac 1b			call macro_dsp_valuehl 
22c2				endm 
# End of macro FORTH_DSP_VALUEHL
22c2					 
22c2 e5					push hl 
22c3				 
22c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22c3 cd 64 1c			call macro_forth_dsp_pop 
22c6				endm 
# End of macro FORTH_DSP_POP
22c6			 
22c6					; get byte to poke 
22c6			 
22c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22c6 cd ac 1b			call macro_dsp_valuehl 
22c9				endm 
# End of macro FORTH_DSP_VALUEHL
22c9 e5					push hl 
22ca			 
22ca			 
22ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22ca cd 64 1c			call macro_forth_dsp_pop 
22cd				endm 
# End of macro FORTH_DSP_POP
22cd			 
22cd			 
22cd d1					pop de 
22ce e1					pop hl 
22cf			 
22cf 73					ld (hl),e 
22d0			 
22d0			 
22d0					NEXTW 
22d0 c3 1e 1d			jp macro_next 
22d3				endm 
# End of macro NEXTW
22d3			.CBANG: 
22d3				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
22d3 22				db WORD_SYS_CORE+OPCODE_CBANG             
22d4 fc 22			dw .SCALL            
22d6 03				db 2 + 1 
22d7 .. 00			db "C!",0              
22da				endm 
# End of macro CWHEAD
22da			; | C!  ( x w -- ) Store x at address w  | DONE 
22da					if DEBUG_FORTH_WORDS_KEY 
22da						DMARK "CBA" 
22da f5				push af  
22db 3a ef 22			ld a, (.dmark)  
22de 32 7a ee			ld (debug_mark),a  
22e1 3a f0 22			ld a, (.dmark+1)  
22e4 32 7b ee			ld (debug_mark+1),a  
22e7 3a f1 22			ld a, (.dmark+2)  
22ea 32 7c ee			ld (debug_mark+2),a  
22ed 18 03			jr .pastdmark  
22ef ..			.dmark: db "CBA"  
22f2 f1			.pastdmark: pop af  
22f3			endm  
# End of macro DMARK
22f3						CALLMONITOR 
22f3 cd 28 14			call break_point_state  
22f6				endm  
# End of macro CALLMONITOR
22f6					endif 
22f6 c3 bf 22				jp .storebyteat 
22f9					NEXTW 
22f9 c3 1e 1d			jp macro_next 
22fc				endm 
# End of macro NEXTW
22fc			.SCALL: 
22fc				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
22fc 23				db WORD_SYS_CORE+OPCODE_SCALL             
22fd 30 23			dw .DEPTH            
22ff 05				db 4 + 1 
2300 .. 00			db "CALL",0              
2305				endm 
# End of macro CWHEAD
2305			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2305					if DEBUG_FORTH_WORDS_KEY 
2305						DMARK "CLL" 
2305 f5				push af  
2306 3a 1a 23			ld a, (.dmark)  
2309 32 7a ee			ld (debug_mark),a  
230c 3a 1b 23			ld a, (.dmark+1)  
230f 32 7b ee			ld (debug_mark+1),a  
2312 3a 1c 23			ld a, (.dmark+2)  
2315 32 7c ee			ld (debug_mark+2),a  
2318 18 03			jr .pastdmark  
231a ..			.dmark: db "CLL"  
231d f1			.pastdmark: pop af  
231e			endm  
# End of macro DMARK
231e						CALLMONITOR 
231e cd 28 14			call break_point_state  
2321				endm  
# End of macro CALLMONITOR
2321					endif 
2321			 
2321					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2321 cd ac 1b			call macro_dsp_valuehl 
2324				endm 
# End of macro FORTH_DSP_VALUEHL
2324			 
2324			;		push hl 
2324			 
2324					; destroy value TOS 
2324			 
2324					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2324 cd 64 1c			call macro_forth_dsp_pop 
2327				endm 
# End of macro FORTH_DSP_POP
2327			 
2327						 
2327			;		pop hl 
2327			 
2327					; how to do a call with hl???? save SP? 
2327 cd c7 1c				call forth_call_hl 
232a			 
232a			 
232a					; TODO push value back onto stack for another op etc 
232a			 
232a cd b5 19				call forth_push_numhl 
232d					NEXTW 
232d c3 1e 1d			jp macro_next 
2330				endm 
# End of macro NEXTW
2330			.DEPTH: 
2330				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2330 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2331 6d 23			dw .OVER            
2333 06				db 5 + 1 
2334 .. 00			db "DEPTH",0              
233a				endm 
# End of macro CWHEAD
233a			; | DEPTH ( -- u ) Push count of stack | DONE 
233a					; take current TOS and remove from base value div by two to get count 
233a					if DEBUG_FORTH_WORDS_KEY 
233a						DMARK "DEP" 
233a f5				push af  
233b 3a 4f 23			ld a, (.dmark)  
233e 32 7a ee			ld (debug_mark),a  
2341 3a 50 23			ld a, (.dmark+1)  
2344 32 7b ee			ld (debug_mark+1),a  
2347 3a 51 23			ld a, (.dmark+2)  
234a 32 7c ee			ld (debug_mark+2),a  
234d 18 03			jr .pastdmark  
234f ..			.dmark: db "DEP"  
2352 f1			.pastdmark: pop af  
2353			endm  
# End of macro DMARK
2353						CALLMONITOR 
2353 cd 28 14			call break_point_state  
2356				endm  
# End of macro CALLMONITOR
2356					endif 
2356			 
2356			 
2356 2a 0d eb			ld hl, (cli_data_sp) 
2359 11 c7 e8			ld de, cli_data_stack 
235c ed 52			sbc hl,de 
235e				 
235e				; div by size of stack item 
235e			 
235e 5d				ld e,l 
235f 0e 03			ld c, 3 
2361 cd 45 0b			call Div8 
2364			 
2364 6f				ld l,a 
2365 26 00			ld h,0 
2367			 
2367				;srl h 
2367				;rr l 
2367			 
2367 cd b5 19				call forth_push_numhl 
236a					NEXTW 
236a c3 1e 1d			jp macro_next 
236d				endm 
# End of macro NEXTW
236d			.OVER: 
236d				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
236d 42				db WORD_SYS_CORE+46             
236e b4 23			dw .PAUSE            
2370 05				db 4 + 1 
2371 .. 00			db "OVER",0              
2376				endm 
# End of macro CWHEAD
2376			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2376					if DEBUG_FORTH_WORDS_KEY 
2376						DMARK "OVR" 
2376 f5				push af  
2377 3a 8b 23			ld a, (.dmark)  
237a 32 7a ee			ld (debug_mark),a  
237d 3a 8c 23			ld a, (.dmark+1)  
2380 32 7b ee			ld (debug_mark+1),a  
2383 3a 8d 23			ld a, (.dmark+2)  
2386 32 7c ee			ld (debug_mark+2),a  
2389 18 03			jr .pastdmark  
238b ..			.dmark: db "OVR"  
238e f1			.pastdmark: pop af  
238f			endm  
# End of macro DMARK
238f						CALLMONITOR 
238f cd 28 14			call break_point_state  
2392				endm  
# End of macro CALLMONITOR
2392					endif 
2392			 
2392					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2392 cd ac 1b			call macro_dsp_valuehl 
2395				endm 
# End of macro FORTH_DSP_VALUEHL
2395 e5					push hl    ; n2 
2396					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2396 cd 64 1c			call macro_forth_dsp_pop 
2399				endm 
# End of macro FORTH_DSP_POP
2399			 
2399					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2399 cd ac 1b			call macro_dsp_valuehl 
239c				endm 
# End of macro FORTH_DSP_VALUEHL
239c e5					push hl    ; n1 
239d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
239d cd 64 1c			call macro_forth_dsp_pop 
23a0				endm 
# End of macro FORTH_DSP_POP
23a0			 
23a0 d1					pop de     ; n1 
23a1 e1					pop hl     ; n2 
23a2			 
23a2 d5					push de 
23a3 e5					push hl 
23a4 d5					push de 
23a5			 
23a5					; push back  
23a5			 
23a5 e1					pop hl 
23a6 cd b5 19				call forth_push_numhl 
23a9 e1					pop hl 
23aa cd b5 19				call forth_push_numhl 
23ad e1					pop hl 
23ae cd b5 19				call forth_push_numhl 
23b1					NEXTW 
23b1 c3 1e 1d			jp macro_next 
23b4				endm 
# End of macro NEXTW
23b4			 
23b4			.PAUSE: 
23b4				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
23b4 43				db WORD_SYS_CORE+47             
23b5 e9 23			dw .PAUSES            
23b7 08				db 7 + 1 
23b8 .. 00			db "PAUSEMS",0              
23c0				endm 
# End of macro CWHEAD
23c0			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
23c0					if DEBUG_FORTH_WORDS_KEY 
23c0						DMARK "PMS" 
23c0 f5				push af  
23c1 3a d5 23			ld a, (.dmark)  
23c4 32 7a ee			ld (debug_mark),a  
23c7 3a d6 23			ld a, (.dmark+1)  
23ca 32 7b ee			ld (debug_mark+1),a  
23cd 3a d7 23			ld a, (.dmark+2)  
23d0 32 7c ee			ld (debug_mark+2),a  
23d3 18 03			jr .pastdmark  
23d5 ..			.dmark: db "PMS"  
23d8 f1			.pastdmark: pop af  
23d9			endm  
# End of macro DMARK
23d9						CALLMONITOR 
23d9 cd 28 14			call break_point_state  
23dc				endm  
# End of macro CALLMONITOR
23dc					endif 
23dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23dc cd ac 1b			call macro_dsp_valuehl 
23df				endm 
# End of macro FORTH_DSP_VALUEHL
23df			;		push hl    ; n2 
23df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23df cd 64 1c			call macro_forth_dsp_pop 
23e2				endm 
# End of macro FORTH_DSP_POP
23e2			;		pop hl 
23e2			 
23e2 7d					ld a, l 
23e3 cd e2 08				call aDelayInMS 
23e6				       NEXTW 
23e6 c3 1e 1d			jp macro_next 
23e9				endm 
# End of macro NEXTW
23e9			.PAUSES:  
23e9				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
23e9 44				db WORD_SYS_CORE+48             
23ea 58 24			dw .ROT            
23ec 06				db 5 + 1 
23ed .. 00			db "PAUSE",0              
23f3				endm 
# End of macro CWHEAD
23f3			; | PAUSE ( n -- )  Pause for n seconds | DONE 
23f3					if DEBUG_FORTH_WORDS_KEY 
23f3						DMARK "PAU" 
23f3 f5				push af  
23f4 3a 08 24			ld a, (.dmark)  
23f7 32 7a ee			ld (debug_mark),a  
23fa 3a 09 24			ld a, (.dmark+1)  
23fd 32 7b ee			ld (debug_mark+1),a  
2400 3a 0a 24			ld a, (.dmark+2)  
2403 32 7c ee			ld (debug_mark+2),a  
2406 18 03			jr .pastdmark  
2408 ..			.dmark: db "PAU"  
240b f1			.pastdmark: pop af  
240c			endm  
# End of macro DMARK
240c						CALLMONITOR 
240c cd 28 14			call break_point_state  
240f				endm  
# End of macro CALLMONITOR
240f					endif 
240f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
240f cd ac 1b			call macro_dsp_valuehl 
2412				endm 
# End of macro FORTH_DSP_VALUEHL
2412			;		push hl    ; n2 
2412					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2412 cd 64 1c			call macro_forth_dsp_pop 
2415				endm 
# End of macro FORTH_DSP_POP
2415			;		pop hl 
2415 45					ld b, l 
2416					if DEBUG_FORTH_WORDS 
2416						DMARK "PAU" 
2416 f5				push af  
2417 3a 2b 24			ld a, (.dmark)  
241a 32 7a ee			ld (debug_mark),a  
241d 3a 2c 24			ld a, (.dmark+1)  
2420 32 7b ee			ld (debug_mark+1),a  
2423 3a 2d 24			ld a, (.dmark+2)  
2426 32 7c ee			ld (debug_mark+2),a  
2429 18 03			jr .pastdmark  
242b ..			.dmark: db "PAU"  
242e f1			.pastdmark: pop af  
242f			endm  
# End of macro DMARK
242f						CALLMONITOR 
242f cd 28 14			call break_point_state  
2432				endm  
# End of macro CALLMONITOR
2432					endif 
2432 c5			.pauses1:	push bc 
2433 cd fd 08				call delay1s 
2436 c1					pop bc 
2437					if DEBUG_FORTH_WORDS 
2437						DMARK "PA1" 
2437 f5				push af  
2438 3a 4c 24			ld a, (.dmark)  
243b 32 7a ee			ld (debug_mark),a  
243e 3a 4d 24			ld a, (.dmark+1)  
2441 32 7b ee			ld (debug_mark+1),a  
2444 3a 4e 24			ld a, (.dmark+2)  
2447 32 7c ee			ld (debug_mark+2),a  
244a 18 03			jr .pastdmark  
244c ..			.dmark: db "PA1"  
244f f1			.pastdmark: pop af  
2450			endm  
# End of macro DMARK
2450						CALLMONITOR 
2450 cd 28 14			call break_point_state  
2453				endm  
# End of macro CALLMONITOR
2453					endif 
2453 10 dd				djnz .pauses1 
2455			 
2455				       NEXTW 
2455 c3 1e 1d			jp macro_next 
2458				endm 
# End of macro NEXTW
2458			.ROT: 
2458				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2458 45				db WORD_SYS_CORE+49             
2459 a6 24			dw .UWORDS            
245b 04				db 3 + 1 
245c .. 00			db "ROT",0              
2460				endm 
# End of macro CWHEAD
2460			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2460					if DEBUG_FORTH_WORDS_KEY 
2460						DMARK "ROT" 
2460 f5				push af  
2461 3a 75 24			ld a, (.dmark)  
2464 32 7a ee			ld (debug_mark),a  
2467 3a 76 24			ld a, (.dmark+1)  
246a 32 7b ee			ld (debug_mark+1),a  
246d 3a 77 24			ld a, (.dmark+2)  
2470 32 7c ee			ld (debug_mark+2),a  
2473 18 03			jr .pastdmark  
2475 ..			.dmark: db "ROT"  
2478 f1			.pastdmark: pop af  
2479			endm  
# End of macro DMARK
2479						CALLMONITOR 
2479 cd 28 14			call break_point_state  
247c				endm  
# End of macro CALLMONITOR
247c					endif 
247c			 
247c					FORTH_DSP_VALUEHL 
247c cd ac 1b			call macro_dsp_valuehl 
247f				endm 
# End of macro FORTH_DSP_VALUEHL
247f e5					push hl    ; u3  
2480			 
2480					FORTH_DSP_POP 
2480 cd 64 1c			call macro_forth_dsp_pop 
2483				endm 
# End of macro FORTH_DSP_POP
2483			   
2483					FORTH_DSP_VALUEHL 
2483 cd ac 1b			call macro_dsp_valuehl 
2486				endm 
# End of macro FORTH_DSP_VALUEHL
2486 e5					push hl     ; u2 
2487			 
2487					FORTH_DSP_POP 
2487 cd 64 1c			call macro_forth_dsp_pop 
248a				endm 
# End of macro FORTH_DSP_POP
248a			 
248a					FORTH_DSP_VALUEHL 
248a cd ac 1b			call macro_dsp_valuehl 
248d				endm 
# End of macro FORTH_DSP_VALUEHL
248d e5					push hl     ; u1 
248e			 
248e					FORTH_DSP_POP 
248e cd 64 1c			call macro_forth_dsp_pop 
2491				endm 
# End of macro FORTH_DSP_POP
2491			 
2491 c1					pop bc      ; u1 
2492 e1					pop hl      ; u2 
2493 d1					pop de      ; u3 
2494			 
2494			 
2494 c5					push bc 
2495 d5					push de 
2496 e5					push hl 
2497			 
2497			 
2497 e1					pop hl 
2498 cd b5 19				call forth_push_numhl 
249b			 
249b e1					pop hl 
249c cd b5 19				call forth_push_numhl 
249f			 
249f e1					pop hl 
24a0 cd b5 19				call forth_push_numhl 
24a3					 
24a3			 
24a3			 
24a3			 
24a3			 
24a3			 
24a3				       NEXTW 
24a3 c3 1e 1d			jp macro_next 
24a6				endm 
# End of macro NEXTW
24a6			 
24a6			.UWORDS: 
24a6				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
24a6 50				db WORD_SYS_CORE+60             
24a7 68 25			dw .BP            
24a9 07				db 6 + 1 
24aa .. 00			db "UWORDS",0              
24b1				endm 
# End of macro CWHEAD
24b1			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
24b1			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
24b1			; | | Following the count are the individual words. 
24b1			; | | 
24b1			; | | e.g. UWORDS 
24b1			; | | BOX DIRLIST 2 
24b1			; | |  
24b1			; | | Can be used to save the words to storage via: 
24b1			; | | UWORDS $01 DO $01 APPEND LOOP 
24b1				if DEBUG_FORTH_WORDS_KEY 
24b1					DMARK "UWR" 
24b1 f5				push af  
24b2 3a c6 24			ld a, (.dmark)  
24b5 32 7a ee			ld (debug_mark),a  
24b8 3a c7 24			ld a, (.dmark+1)  
24bb 32 7b ee			ld (debug_mark+1),a  
24be 3a c8 24			ld a, (.dmark+2)  
24c1 32 7c ee			ld (debug_mark+2),a  
24c4 18 03			jr .pastdmark  
24c6 ..			.dmark: db "UWR"  
24c9 f1			.pastdmark: pop af  
24ca			endm  
# End of macro DMARK
24ca					CALLMONITOR 
24ca cd 28 14			call break_point_state  
24cd				endm  
# End of macro CALLMONITOR
24cd				endif 
24cd 21 92 58				ld hl, baseram 
24d0					;ld hl, baseusermem 
24d0 01 00 00				ld bc, 0    ; start a counter 
24d3			 
24d3				; skip dict stub 
24d3			 
24d3 cd 6f 1e				call forth_tok_next 
24d6			 
24d6			 
24d6			; while we have words to look for 
24d6			 
24d6 7e			.douscan:	ld a, (hl)      
24d7				if DEBUG_FORTH_WORDS 
24d7					DMARK "UWs" 
24d7 f5				push af  
24d8 3a ec 24			ld a, (.dmark)  
24db 32 7a ee			ld (debug_mark),a  
24de 3a ed 24			ld a, (.dmark+1)  
24e1 32 7b ee			ld (debug_mark+1),a  
24e4 3a ee 24			ld a, (.dmark+2)  
24e7 32 7c ee			ld (debug_mark+2),a  
24ea 18 03			jr .pastdmark  
24ec ..			.dmark: db "UWs"  
24ef f1			.pastdmark: pop af  
24f0			endm  
# End of macro DMARK
24f0					CALLMONITOR 
24f0 cd 28 14			call break_point_state  
24f3				endm  
# End of macro CALLMONITOR
24f3				endif 
24f3 fe 00				cp WORD_SYS_END 
24f5 28 4d				jr z, .udone 
24f7 fe 01				cp WORD_SYS_UWORD 
24f9 20 44				jr nz, .nuword 
24fb			 
24fb				if DEBUG_FORTH_WORDS 
24fb					DMARK "UWu" 
24fb f5				push af  
24fc 3a 10 25			ld a, (.dmark)  
24ff 32 7a ee			ld (debug_mark),a  
2502 3a 11 25			ld a, (.dmark+1)  
2505 32 7b ee			ld (debug_mark+1),a  
2508 3a 12 25			ld a, (.dmark+2)  
250b 32 7c ee			ld (debug_mark+2),a  
250e 18 03			jr .pastdmark  
2510 ..			.dmark: db "UWu"  
2513 f1			.pastdmark: pop af  
2514			endm  
# End of macro DMARK
2514					CALLMONITOR 
2514 cd 28 14			call break_point_state  
2517				endm  
# End of macro CALLMONITOR
2517				endif 
2517					; we have a uword so push its name to the stack 
2517			 
2517 e5				   	push hl  ; save so we can move to next dict block 
2518			 
2518					; skip opcode 
2518 23					inc hl  
2519					; skip next ptr 
2519 23					inc hl  
251a 23					inc hl 
251b					; skip len 
251b 23					inc hl 
251c				if DEBUG_FORTH_WORDS 
251c					DMARK "UWt" 
251c f5				push af  
251d 3a 31 25			ld a, (.dmark)  
2520 32 7a ee			ld (debug_mark),a  
2523 3a 32 25			ld a, (.dmark+1)  
2526 32 7b ee			ld (debug_mark+1),a  
2529 3a 33 25			ld a, (.dmark+2)  
252c 32 7c ee			ld (debug_mark+2),a  
252f 18 03			jr .pastdmark  
2531 ..			.dmark: db "UWt"  
2534 f1			.pastdmark: pop af  
2535			endm  
# End of macro DMARK
2535					CALLMONITOR 
2535 cd 28 14			call break_point_state  
2538				endm  
# End of macro CALLMONITOR
2538				endif 
2538 03					inc bc 
2539			 
2539 c5					push bc 
253a cd 23 1a				call forth_push_str 
253d c1					pop bc 
253e			 
253e e1					pop hl 	 
253f			 
253f cd 6f 1e		.nuword:	call forth_tok_next 
2542 18 92				jr .douscan  
2544			 
2544			.udone:		 ; push count of uwords found 
2544 c5					push bc 
2545 e1					pop hl 
2546			 
2546				if DEBUG_FORTH_WORDS 
2546					DMARK "UWc" 
2546 f5				push af  
2547 3a 5b 25			ld a, (.dmark)  
254a 32 7a ee			ld (debug_mark),a  
254d 3a 5c 25			ld a, (.dmark+1)  
2550 32 7b ee			ld (debug_mark+1),a  
2553 3a 5d 25			ld a, (.dmark+2)  
2556 32 7c ee			ld (debug_mark+2),a  
2559 18 03			jr .pastdmark  
255b ..			.dmark: db "UWc"  
255e f1			.pastdmark: pop af  
255f			endm  
# End of macro DMARK
255f					CALLMONITOR 
255f cd 28 14			call break_point_state  
2562				endm  
# End of macro CALLMONITOR
2562				endif 
2562 cd b5 19				call forth_push_numhl 
2565			 
2565			 
2565				       NEXTW 
2565 c3 1e 1d			jp macro_next 
2568				endm 
# End of macro NEXTW
2568			 
2568			.BP: 
2568				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2568 54				db WORD_SYS_CORE+64             
2569 9e 25			dw .MONITOR            
256b 03				db 2 + 1 
256c .. 00			db "BP",0              
256f				endm 
# End of macro CWHEAD
256f			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
256f			; | | $00 Will enable the break points within specific code paths 
256f			; | | $01 Will disable break points 
256f			; | |  
256f			; | | By default break points are off. Either the above can be used to enable them 
256f			; | | or if a key is held down during start up the spashscreen will appear to freeze 
256f			; | | and on release of the pressed key a message will be disaplayed to notify 
256f			; | | that break points are enabled. Pressing any key will then continue boot process. 
256f					; get byte count 
256f					if DEBUG_FORTH_WORDS_KEY 
256f						DMARK "BP." 
256f f5				push af  
2570 3a 84 25			ld a, (.dmark)  
2573 32 7a ee			ld (debug_mark),a  
2576 3a 85 25			ld a, (.dmark+1)  
2579 32 7b ee			ld (debug_mark+1),a  
257c 3a 86 25			ld a, (.dmark+2)  
257f 32 7c ee			ld (debug_mark+2),a  
2582 18 03			jr .pastdmark  
2584 ..			.dmark: db "BP."  
2587 f1			.pastdmark: pop af  
2588			endm  
# End of macro DMARK
2588						CALLMONITOR 
2588 cd 28 14			call break_point_state  
258b				endm  
# End of macro CALLMONITOR
258b					endif 
258b			 
258b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
258b cd ac 1b			call macro_dsp_valuehl 
258e				endm 
# End of macro FORTH_DSP_VALUEHL
258e			 
258e			;		push hl 
258e			 
258e					; destroy value TOS 
258e			 
258e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
258e cd 64 1c			call macro_forth_dsp_pop 
2591				endm 
# End of macro FORTH_DSP_POP
2591			 
2591			;		pop hl 
2591			 
2591 3e 00				ld a,0 
2593 bd					cp l 
2594 28 02				jr z, .bpset 
2596 3e 2a				ld a, '*' 
2598			 
2598 32 51 e3		.bpset:		ld (os_view_disable), a 
259b			 
259b			 
259b					NEXTW 
259b c3 1e 1d			jp macro_next 
259e				endm 
# End of macro NEXTW
259e			 
259e			 
259e			.MONITOR: 
259e				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
259e 55				db WORD_SYS_CORE+65             
259f d1 25			dw .MALLOC            
25a1 08				db 7 + 1 
25a2 .. 00			db "MONITOR",0              
25aa				endm 
# End of macro CWHEAD
25aa			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
25aa			; | | At start the current various registers will be displayed with contents. 
25aa			; | | Top right corner will show the most recent debug marker seen. 
25aa			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
25aa			; | | and the return stack pointer (RSP). 
25aa			; | | Pressing: 
25aa			; | |    1 - Initial screen 
25aa			; | |    2 - Display a data dump of HL 
25aa			; | |    3 - Display a data dump of DE 
25aa			; | |    4 - Display a data dump of BC 
25aa			; | |    5 - Display a data dump of HL 
25aa			; | |    6 - Display a data dump of DSP 
25aa			; | |    7 - Display a data dump of RSP 
25aa			; | |    8 - Display a data dump of what is at DSP 
25aa			; | |    9 - Display a data dump of what is at RSP 
25aa			; | |    0 - Exit monitor and continue running. This will also enable break points 
25aa			; | |    * - Disable break points 
25aa			; | |    # - Enter traditional monitor mode 
25aa			; | | 
25aa			; | | Monitor Mode 
25aa			; | | ------------ 
25aa			; | | A prompt of '>' will be shown for various commands: 
25aa			; | |    D xxxx - Display a data dump starting from hex address xxxx 
25aa			; | |    C - Continue display a data dump from the last set address 
25aa			; | |    M xxxx - Set start of memory edit at address xx 
25aa			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
25aa			; | |    Q - Return to previous 
25aa					if DEBUG_FORTH_WORDS_KEY 
25aa						DMARK "MON" 
25aa f5				push af  
25ab 3a bf 25			ld a, (.dmark)  
25ae 32 7a ee			ld (debug_mark),a  
25b1 3a c0 25			ld a, (.dmark+1)  
25b4 32 7b ee			ld (debug_mark+1),a  
25b7 3a c1 25			ld a, (.dmark+2)  
25ba 32 7c ee			ld (debug_mark+2),a  
25bd 18 03			jr .pastdmark  
25bf ..			.dmark: db "MON"  
25c2 f1			.pastdmark: pop af  
25c3			endm  
# End of macro DMARK
25c3						CALLMONITOR 
25c3 cd 28 14			call break_point_state  
25c6				endm  
# End of macro CALLMONITOR
25c6					endif 
25c6 3e 00				ld a, 0 
25c8 32 51 e3				ld (os_view_disable), a 
25cb			 
25cb					CALLMONITOR 
25cb cd 28 14			call break_point_state  
25ce				endm  
# End of macro CALLMONITOR
25ce			 
25ce			;	call monitor 
25ce			 
25ce					NEXTW 
25ce c3 1e 1d			jp macro_next 
25d1				endm 
# End of macro NEXTW
25d1			 
25d1			 
25d1			.MALLOC: 
25d1				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
25d1 56				db WORD_SYS_CORE+66             
25d2 fa 25			dw .MALLOC2            
25d4 06				db 5 + 1 
25d5 .. 00			db "ALLOT",0              
25db				endm 
# End of macro CWHEAD
25db			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25db					if DEBUG_FORTH_WORDS_KEY 
25db						DMARK "ALL" 
25db f5				push af  
25dc 3a f0 25			ld a, (.dmark)  
25df 32 7a ee			ld (debug_mark),a  
25e2 3a f1 25			ld a, (.dmark+1)  
25e5 32 7b ee			ld (debug_mark+1),a  
25e8 3a f2 25			ld a, (.dmark+2)  
25eb 32 7c ee			ld (debug_mark+2),a  
25ee 18 03			jr .pastdmark  
25f0 ..			.dmark: db "ALL"  
25f3 f1			.pastdmark: pop af  
25f4			endm  
# End of macro DMARK
25f4						CALLMONITOR 
25f4 cd 28 14			call break_point_state  
25f7				endm  
# End of macro CALLMONITOR
25f7					endif 
25f7 c3 21 26				jp .mallocc 
25fa			.MALLOC2: 
25fa				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
25fa 56				db WORD_SYS_CORE+66             
25fb 38 26			dw .FREE            
25fd 07				db 6 + 1 
25fe .. 00			db "MALLOC",0              
2605				endm 
# End of macro CWHEAD
2605			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2605					; get byte count 
2605					if DEBUG_FORTH_WORDS_KEY 
2605						DMARK "MAL" 
2605 f5				push af  
2606 3a 1a 26			ld a, (.dmark)  
2609 32 7a ee			ld (debug_mark),a  
260c 3a 1b 26			ld a, (.dmark+1)  
260f 32 7b ee			ld (debug_mark+1),a  
2612 3a 1c 26			ld a, (.dmark+2)  
2615 32 7c ee			ld (debug_mark+2),a  
2618 18 03			jr .pastdmark  
261a ..			.dmark: db "MAL"  
261d f1			.pastdmark: pop af  
261e			endm  
# End of macro DMARK
261e						CALLMONITOR 
261e cd 28 14			call break_point_state  
2621				endm  
# End of macro CALLMONITOR
2621					endif 
2621			.mallocc: 
2621					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2621 cd ac 1b			call macro_dsp_valuehl 
2624				endm 
# End of macro FORTH_DSP_VALUEHL
2624			 
2624			;		push hl 
2624			 
2624					; destroy value TOS 
2624			 
2624					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2624 cd 64 1c			call macro_forth_dsp_pop 
2627				endm 
# End of macro FORTH_DSP_POP
2627			 
2627			;		pop hl 
2627 cd 7c 10				call malloc 
262a				if DEBUG_FORTH_MALLOC_GUARD 
262a f5					push af 
262b cd de 0b				call ishlzero 
262e			;		ld a, l 
262e			;		add h 
262e			;		cp 0 
262e f1					pop af 
262f					 
262f cc ef 44				call z,malloc_error 
2632				endif 
2632			 
2632 cd b5 19				call forth_push_numhl 
2635					NEXTW 
2635 c3 1e 1d			jp macro_next 
2638				endm 
# End of macro NEXTW
2638			 
2638			.FREE: 
2638				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2638 57				db WORD_SYS_CORE+67             
2639 69 26			dw .LIST            
263b 05				db 4 + 1 
263c .. 00			db "FREE",0              
2641				endm 
# End of macro CWHEAD
2641			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2641					if DEBUG_FORTH_WORDS_KEY 
2641						DMARK "FRE" 
2641 f5				push af  
2642 3a 56 26			ld a, (.dmark)  
2645 32 7a ee			ld (debug_mark),a  
2648 3a 57 26			ld a, (.dmark+1)  
264b 32 7b ee			ld (debug_mark+1),a  
264e 3a 58 26			ld a, (.dmark+2)  
2651 32 7c ee			ld (debug_mark+2),a  
2654 18 03			jr .pastdmark  
2656 ..			.dmark: db "FRE"  
2659 f1			.pastdmark: pop af  
265a			endm  
# End of macro DMARK
265a						CALLMONITOR 
265a cd 28 14			call break_point_state  
265d				endm  
# End of macro CALLMONITOR
265d					endif 
265d					; get address 
265d			 
265d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
265d cd ac 1b			call macro_dsp_valuehl 
2660				endm 
# End of macro FORTH_DSP_VALUEHL
2660			 
2660			;		push hl 
2660			 
2660					; destroy value TOS 
2660			 
2660					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2660 cd 64 1c			call macro_forth_dsp_pop 
2663				endm 
# End of macro FORTH_DSP_POP
2663			 
2663			;		pop hl 
2663			if FORTH_ENABLE_MALLOCFREE 
2663 cd 46 11				call free 
2666			endif 
2666					NEXTW 
2666 c3 1e 1d			jp macro_next 
2669				endm 
# End of macro NEXTW
2669			.LIST: 
2669				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2669 5c				db WORD_SYS_CORE+72             
266a 2c 28			dw .FORGET            
266c 05				db 4 + 1 
266d .. 00			db "LIST",0              
2672				endm 
# End of macro CWHEAD
2672			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2672			; | | The quoted word must be in upper case. 
2672				if DEBUG_FORTH_WORDS_KEY 
2672					DMARK "LST" 
2672 f5				push af  
2673 3a 87 26			ld a, (.dmark)  
2676 32 7a ee			ld (debug_mark),a  
2679 3a 88 26			ld a, (.dmark+1)  
267c 32 7b ee			ld (debug_mark+1),a  
267f 3a 89 26			ld a, (.dmark+2)  
2682 32 7c ee			ld (debug_mark+2),a  
2685 18 03			jr .pastdmark  
2687 ..			.dmark: db "LST"  
268a f1			.pastdmark: pop af  
268b			endm  
# End of macro DMARK
268b					CALLMONITOR 
268b cd 28 14			call break_point_state  
268e				endm  
# End of macro CALLMONITOR
268e				endif 
268e			 
268e					FORTH_DSP_VALUEHL 
268e cd ac 1b			call macro_dsp_valuehl 
2691				endm 
# End of macro FORTH_DSP_VALUEHL
2691			 
2691 e5					push hl 
2692 c1					pop bc 
2693			 
2693			; Start format of scratch string 
2693			 
2693 21 60 e3				ld hl, scratch 
2696			 
2696 3e 3a				ld a, ':' 
2698 77					ld (hl),a 
2699 23					inc hl 
269a 3e 20				ld a, ' ' 
269c 77					ld (hl), a 
269d			 
269d					; Get ptr to the word we need to look up 
269d			 
269d			;		FORTH_DSP_VALUEHL 
269d					;v5 FORTH_DSP_VALUE 
269d				; TODO type check 
269d			;		inc hl    ; Skip type check  
269d			;		push hl 
269d			;		ex de, hl    ; put into DE 
269d			 
269d			 
269d 21 92 58				ld hl, baseram 
26a0					;ld hl, baseusermem 
26a0			 
26a0 e5			push hl   ; sacreifical push 
26a1			 
26a1			.ldouscanm: 
26a1 e1				pop hl 
26a2			.ldouscan: 
26a2				if DEBUG_FORTH_WORDS 
26a2					DMARK "LSs" 
26a2 f5				push af  
26a3 3a b7 26			ld a, (.dmark)  
26a6 32 7a ee			ld (debug_mark),a  
26a9 3a b8 26			ld a, (.dmark+1)  
26ac 32 7b ee			ld (debug_mark+1),a  
26af 3a b9 26			ld a, (.dmark+2)  
26b2 32 7c ee			ld (debug_mark+2),a  
26b5 18 03			jr .pastdmark  
26b7 ..			.dmark: db "LSs"  
26ba f1			.pastdmark: pop af  
26bb			endm  
# End of macro DMARK
26bb					CALLMONITOR 
26bb cd 28 14			call break_point_state  
26be				endm  
# End of macro CALLMONITOR
26be				endif 
26be				; skip dict stub 
26be cd 6f 1e				call forth_tok_next 
26c1			 
26c1			 
26c1			; while we have words to look for 
26c1			 
26c1 7e				ld a, (hl)      
26c2				if DEBUG_FORTH_WORDS 
26c2					DMARK "LSk" 
26c2 f5				push af  
26c3 3a d7 26			ld a, (.dmark)  
26c6 32 7a ee			ld (debug_mark),a  
26c9 3a d8 26			ld a, (.dmark+1)  
26cc 32 7b ee			ld (debug_mark+1),a  
26cf 3a d9 26			ld a, (.dmark+2)  
26d2 32 7c ee			ld (debug_mark+2),a  
26d5 18 03			jr .pastdmark  
26d7 ..			.dmark: db "LSk"  
26da f1			.pastdmark: pop af  
26db			endm  
# End of macro DMARK
26db					CALLMONITOR 
26db cd 28 14			call break_point_state  
26de				endm  
# End of macro CALLMONITOR
26de				endif 
26de fe 00				cp WORD_SYS_END 
26e0 ca 13 28				jp z, .lunotfound 
26e3 fe 01				cp WORD_SYS_UWORD 
26e5 c2 a2 26				jp nz, .ldouscan 
26e8			 
26e8				if DEBUG_FORTH_WORDS 
26e8					DMARK "LSu" 
26e8 f5				push af  
26e9 3a fd 26			ld a, (.dmark)  
26ec 32 7a ee			ld (debug_mark),a  
26ef 3a fe 26			ld a, (.dmark+1)  
26f2 32 7b ee			ld (debug_mark+1),a  
26f5 3a ff 26			ld a, (.dmark+2)  
26f8 32 7c ee			ld (debug_mark+2),a  
26fb 18 03			jr .pastdmark  
26fd ..			.dmark: db "LSu"  
2700 f1			.pastdmark: pop af  
2701			endm  
# End of macro DMARK
2701					CALLMONITOR 
2701 cd 28 14			call break_point_state  
2704				endm  
# End of macro CALLMONITOR
2704				endif 
2704			 
2704					; found a uword but is it the one we want... 
2704			 
2704 c5					push bc     ; uword to find is on bc 
2705 d1					pop de 
2706			 
2706 e5					push hl  ; to save the ptr 
2707			 
2707					; skip opcode 
2707 23					inc hl  
2708					; skip next ptr 
2708 23					inc hl  
2709 23					inc hl 
270a					; skip len 
270a 23					inc hl 
270b			 
270b				if DEBUG_FORTH_WORDS 
270b					DMARK "LSc" 
270b f5				push af  
270c 3a 20 27			ld a, (.dmark)  
270f 32 7a ee			ld (debug_mark),a  
2712 3a 21 27			ld a, (.dmark+1)  
2715 32 7b ee			ld (debug_mark+1),a  
2718 3a 22 27			ld a, (.dmark+2)  
271b 32 7c ee			ld (debug_mark+2),a  
271e 18 03			jr .pastdmark  
2720 ..			.dmark: db "LSc"  
2723 f1			.pastdmark: pop af  
2724			endm  
# End of macro DMARK
2724					CALLMONITOR 
2724 cd 28 14			call break_point_state  
2727				endm  
# End of macro CALLMONITOR
2727				endif 
2727 cd 4b 10				call strcmp 
272a c2 a1 26				jp nz, .ldouscanm 
272d				 
272d			 
272d			 
272d					; we have a uword so push its name to the stack 
272d			 
272d			;	   	push hl  ; save so we can move to next dict block 
272d e1			pop hl 
272e			 
272e				if DEBUG_FORTH_WORDS 
272e					DMARK "LSm" 
272e f5				push af  
272f 3a 43 27			ld a, (.dmark)  
2732 32 7a ee			ld (debug_mark),a  
2735 3a 44 27			ld a, (.dmark+1)  
2738 32 7b ee			ld (debug_mark+1),a  
273b 3a 45 27			ld a, (.dmark+2)  
273e 32 7c ee			ld (debug_mark+2),a  
2741 18 03			jr .pastdmark  
2743 ..			.dmark: db "LSm"  
2746 f1			.pastdmark: pop af  
2747			endm  
# End of macro DMARK
2747					CALLMONITOR 
2747 cd 28 14			call break_point_state  
274a				endm  
# End of macro CALLMONITOR
274a				endif 
274a			 
274a					; skip opcode 
274a 23					inc hl  
274b					; skip next ptr 
274b 23					inc hl  
274c 23					inc hl 
274d					; skip len 
274d 7e					ld a, (hl)   ; save length to add 
274e				if DEBUG_FORTH_WORDS 
274e					DMARK "LS2" 
274e f5				push af  
274f 3a 63 27			ld a, (.dmark)  
2752 32 7a ee			ld (debug_mark),a  
2755 3a 64 27			ld a, (.dmark+1)  
2758 32 7b ee			ld (debug_mark+1),a  
275b 3a 65 27			ld a, (.dmark+2)  
275e 32 7c ee			ld (debug_mark+2),a  
2761 18 03			jr .pastdmark  
2763 ..			.dmark: db "LS2"  
2766 f1			.pastdmark: pop af  
2767			endm  
# End of macro DMARK
2767					CALLMONITOR 
2767 cd 28 14			call break_point_state  
276a				endm  
# End of macro CALLMONITOR
276a				endif 
276a			 
276a					; save this location 
276a				 
276a e5					push hl 
276b			 
276b 23					inc hl 
276c 11 62 e3				ld de, scratch+2 
276f 4f					ld c, a 
2770 06 00				ld b, 0 
2772			 
2772				if DEBUG_FORTH_WORDS 
2772					DMARK "LSn" 
2772 f5				push af  
2773 3a 87 27			ld a, (.dmark)  
2776 32 7a ee			ld (debug_mark),a  
2779 3a 88 27			ld a, (.dmark+1)  
277c 32 7b ee			ld (debug_mark+1),a  
277f 3a 89 27			ld a, (.dmark+2)  
2782 32 7c ee			ld (debug_mark+2),a  
2785 18 03			jr .pastdmark  
2787 ..			.dmark: db "LSn"  
278a f1			.pastdmark: pop af  
278b			endm  
# End of macro DMARK
278b					CALLMONITOR 
278b cd 28 14			call break_point_state  
278e				endm  
# End of macro CALLMONITOR
278e				endif 
278e			 
278e					; copy uword name to scratch 
278e			 
278e ed b0				ldir 
2790			 
2790 1b					dec de 
2791 3e 20				ld a, ' '    ; change null to space 
2793 12					ld (de), a 
2794			 
2794 13					inc de 
2795			 
2795 d5					push de 
2796 c1					pop bc     ; move scratch pointer to end of word name and save it 
2797			 
2797 e1					pop hl 
2798 7e					ld a, (hl) 
2799					;inc hl 
2799					; skip word string 
2799 cd b5 0b				call addatohl 
279c			 
279c 23					inc hl 
279d			 
279d				if DEBUG_FORTH_WORDS 
279d					DMARK "LS3" 
279d f5				push af  
279e 3a b2 27			ld a, (.dmark)  
27a1 32 7a ee			ld (debug_mark),a  
27a4 3a b3 27			ld a, (.dmark+1)  
27a7 32 7b ee			ld (debug_mark+1),a  
27aa 3a b4 27			ld a, (.dmark+2)  
27ad 32 7c ee			ld (debug_mark+2),a  
27b0 18 03			jr .pastdmark  
27b2 ..			.dmark: db "LS3"  
27b5 f1			.pastdmark: pop af  
27b6			endm  
# End of macro DMARK
27b6					CALLMONITOR 
27b6 cd 28 14			call break_point_state  
27b9				endm  
# End of macro CALLMONITOR
27b9				endif 
27b9					; should now be at the start of the machine code to setup the eval of the uword 
27b9					; now locate the ptr to the string defintion 
27b9			 
27b9					; skip ld hl, 
27b9					; then load the ptr 
27b9			 
27b9 23					inc hl 
27ba 5e					ld e, (hl) 
27bb 23					inc hl 
27bc 56					ld d, (hl) 
27bd eb					ex de, hl 
27be			 
27be			 
27be				if DEBUG_FORTH_WORDS 
27be					DMARK "LSt" 
27be f5				push af  
27bf 3a d3 27			ld a, (.dmark)  
27c2 32 7a ee			ld (debug_mark),a  
27c5 3a d4 27			ld a, (.dmark+1)  
27c8 32 7b ee			ld (debug_mark+1),a  
27cb 3a d5 27			ld a, (.dmark+2)  
27ce 32 7c ee			ld (debug_mark+2),a  
27d1 18 03			jr .pastdmark  
27d3 ..			.dmark: db "LSt"  
27d6 f1			.pastdmark: pop af  
27d7			endm  
# End of macro DMARK
27d7					CALLMONITOR 
27d7 cd 28 14			call break_point_state  
27da				endm  
# End of macro CALLMONITOR
27da				endif 
27da			 
27da			; cant push right now due to tokenised strings  
27da			 
27da			; get the destination of where to copy this definition to. 
27da			 
27da c5					push bc 
27db d1					pop de 
27dc			 
27dc 7e			.listl:         ld a,(hl) 
27dd fe 00				cp 0 
27df 28 09				jr z, .lreplsp     ; replace zero with space 
27e1 fe 7f				cp FORTH_END_BUFFER 
27e3 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
27e5				 
27e5					; just copy this char as is then 
27e5			 
27e5 12					ld (de), a 
27e6			 
27e6 23			.listnxt:	inc hl 
27e7 13					inc de 
27e8 18 f2				jr .listl 
27ea			 
27ea 3e 20		.lreplsp:	ld a,' ' 
27ec 12					ld (de), a 
27ed 18 f7				jr .listnxt 
27ef			 
27ef			; close up uword def 
27ef			 
27ef			.listdone: 
27ef 3e 00				ld a, 0 
27f1 12					ld (de), a 
27f2			 
27f2			; now have def so clean up and push to stack 
27f2			 
27f2 21 60 e3				ld hl, scratch 
27f5				if DEBUG_FORTH_WORDS 
27f5					DMARK "Ltp" 
27f5 f5				push af  
27f6 3a 0a 28			ld a, (.dmark)  
27f9 32 7a ee			ld (debug_mark),a  
27fc 3a 0b 28			ld a, (.dmark+1)  
27ff 32 7b ee			ld (debug_mark+1),a  
2802 3a 0c 28			ld a, (.dmark+2)  
2805 32 7c ee			ld (debug_mark+2),a  
2808 18 03			jr .pastdmark  
280a ..			.dmark: db "Ltp"  
280d f1			.pastdmark: pop af  
280e			endm  
# End of macro DMARK
280e					CALLMONITOR 
280e cd 28 14			call break_point_state  
2811				endm  
# End of macro CALLMONITOR
2811				endif 
2811			 
2811 18 06			jr .listpush 
2813			 
2813			;.lnuword:	pop hl 
2813			;		call forth_tok_next 
2813			;		jp .ldouscan  
2813			 
2813			.lunotfound:		  
2813			 
2813			 
2813					 
2813					FORTH_DSP_POP 
2813 cd 64 1c			call macro_forth_dsp_pop 
2816				endm 
# End of macro FORTH_DSP_POP
2816 21 1f 28				ld hl, .luno 
2819						 
2819			 
2819			.listpush: 
2819 cd 23 1a				call forth_push_str 
281c			 
281c			 
281c			 
281c					NEXTW 
281c c3 1e 1d			jp macro_next 
281f				endm 
# End of macro NEXTW
281f			 
281f .. 00		.luno:    db "Not found",0 
2829			 
2829			 
2829			 
2829			 
2829			 
2829			;		push hl   ; save pointer to start of uword def string 
2829			; 
2829			;; look for FORTH_EOL_LINE 
2829			;		ld a, FORTH_END_BUFFER 
2829			;		call strlent 
2829			; 
2829			;		inc hl		 ; space for coln def 
2829			;		inc hl 
2829			;		inc hl          ; space for terms 
2829			;		inc hl 
2829			; 
2829			;		ld a, 20   ; TODO get actual length 
2829			;		call addatohl    ; include a random amount of room for the uword name 
2829			; 
2829			;		 
2829			;	if DEBUG_FORTH_WORDS 
2829			;		DMARK "Lt1" 
2829			;		CALLMONITOR 
2829			;	endif 
2829			;		 
2829			; 
2829			;; malloc space for the string because we cant change it 
2829			; 
2829			;		call malloc 
2829			;	if DEBUG_FORTH_MALLOC_GUARD 
2829			;		push af 
2829			;		call ishlzero 
2829			;		pop af 
2829			;		 
2829			;		call z,malloc_error 
2829			;	endif 
2829			; 
2829			;	if DEBUG_FORTH_WORDS 
2829			;		DMARK "Lt2" 
2829			;		CALLMONITOR 
2829			;	endif 
2829			;		pop de 
2829			;		push hl    ; push the malloc to release later 
2829			;		push hl   ;  push back a copy for the later stack push 
2829			;		 
2829			;; copy the string swapping out the zero terms for spaces 
2829			; 
2829			;		; de has our source 
2829			;		; hl has our dest 
2829			; 
2829			;; add the coln def 
2829			; 
2829			;		ld a, ':' 
2829			;		ld (hl), a 
2829			;		inc hl 
2829			;		ld a, ' ' 
2829			;		ld (hl), a 
2829			;		inc hl 
2829			; 
2829			;; add the uname word 
2829			;		push de   ; save our string for now 
2829			;		ex de, hl 
2829			; 
2829			;		FORTH_DSP_VALUE 
2829			;		;v5 FORTH_DSP_VALUE 
2829			; 
2829			;		inc hl   ; skip type but we know by now this is OK 
2829			; 
2829			;.luword:	ld a,(hl) 
2829			;		cp 0 
2829			;		jr z, .luword2 
2829			;		ld (de), a 
2829			;		inc de 
2829			;		inc hl 
2829			;		jr .luword 
2829			; 
2829			;.luword2:	ld a, ' ' 
2829			;		ld (de), a 
2829			;;		inc hl 
2829			;;		inc de 
2829			;;		ld (de), a 
2829			;;		inc hl 
2829			;		inc de 
2829			; 
2829			;		ex de, hl 
2829			;		pop de 
2829			;		 
2829			;		 
2829			; 
2829			;; detoken that string and copy it 
2829			; 
2829			;	if DEBUG_FORTH_WORDS 
2829			;		DMARK "Lt2" 
2829			;		CALLMONITOR 
2829			;	endif 
2829			;.ldetok:	ld a, (de) 
2829			;		cp FORTH_END_BUFFER 
2829			;		jr z, .ldetokend 
2829			;		; swap out any zero term for space 
2829			;		cp 0 
2829			;		jr nz, .ldetoknext 
2829			;		ld a, ' ' 
2829			; 
2829			;	if DEBUG_FORTH_WORDS 
2829			;		DMARK "LtS" 
2829			;		CALLMONITOR 
2829			;	endif 
2829			;.ldetoknext:	ld (hl), a 
2829			;		inc de 
2829			;		inc hl 
2829			;		jr .ldetok 
2829			; 
2829			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2829			;		ld (hl), a  
2829			; 
2829			;; free that temp malloc 
2829			; 
2829			;		pop hl    
2829			; 
2829			;	if DEBUG_FORTH_WORDS 
2829			;		DMARK "Lt4" 
2829			;		CALLMONITOR 
2829			;	endif 
2829			;		call forth_apushstrhl 
2829			; 
2829			;		; get rid of temp malloc area 
2829			; 
2829			;		pop hl 
2829			;		call free 
2829			; 
2829			;		jr .ludone 
2829			; 
2829			;.lnuword:	pop hl 
2829			;		call forth_tok_next 
2829			;		jp .ldouscan  
2829			; 
2829			;.ludone:		 pop hl 
2829			; 
2829					NEXTW 
2829 c3 1e 1d			jp macro_next 
282c				endm 
# End of macro NEXTW
282c			 
282c			.FORGET: 
282c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
282c 5d				db WORD_SYS_CORE+73             
282d a5 28			dw .NOP            
282f 07				db 6 + 1 
2830 .. 00			db "FORGET",0              
2837				endm 
# End of macro CWHEAD
2837			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2837			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2837			; | |  
2837			; | | e.g. "MORE" forget 
2837					if DEBUG_FORTH_WORDS_KEY 
2837						DMARK "FRG" 
2837 f5				push af  
2838 3a 4c 28			ld a, (.dmark)  
283b 32 7a ee			ld (debug_mark),a  
283e 3a 4d 28			ld a, (.dmark+1)  
2841 32 7b ee			ld (debug_mark+1),a  
2844 3a 4e 28			ld a, (.dmark+2)  
2847 32 7c ee			ld (debug_mark+2),a  
284a 18 03			jr .pastdmark  
284c ..			.dmark: db "FRG"  
284f f1			.pastdmark: pop af  
2850			endm  
# End of macro DMARK
2850						CALLMONITOR 
2850 cd 28 14			call break_point_state  
2853				endm  
# End of macro CALLMONITOR
2853					endif 
2853			 
2853				; find uword 
2853			        ; update start of word with "_" 
2853				; replace uword with deleted flag 
2853			 
2853			 
2853			;	if DEBUG_FORTH_WORDS 
2853			;		DMARK "FOG" 
2853			;		CALLMONITOR 
2853			;	endif 
2853			 
2853			 
2853					; Get ptr to the word we need to look up 
2853			 
2853					FORTH_DSP_VALUEHL 
2853 cd ac 1b			call macro_dsp_valuehl 
2856				endm 
# End of macro FORTH_DSP_VALUEHL
2856					;v5 FORTH_DSP_VALUE 
2856				; TODO type check 
2856			;		inc hl    ; Skip type check  
2856 e5					push hl 
2857 c1					pop bc 
2858			;		ex de, hl    ; put into DE 
2858			 
2858			 
2858 21 92 58				ld hl, baseram 
285b					;ld hl, baseusermem 
285b			 
285b				; skip dict stub 
285b			;	call forth_tok_next 
285b e5			push hl   ; sacreifical push 
285c			 
285c			.fldouscanm: 
285c e1				pop hl 
285d			.fldouscan: 
285d			;	if DEBUG_FORTH_WORDS 
285d			;		DMARK "LSs" 
285d			;		CALLMONITOR 
285d			;	endif 
285d				; skip dict stub 
285d cd 6f 1e				call forth_tok_next 
2860			 
2860			 
2860			; while we have words to look for 
2860			 
2860 7e				ld a, (hl)      
2861			;	if DEBUG_FORTH_WORDS 
2861			;		DMARK "LSk" 
2861			;		CALLMONITOR 
2861			;	endif 
2861 fe 00				cp WORD_SYS_END 
2863 ca 9f 28				jp z, .flunotfound 
2866 fe 01				cp WORD_SYS_UWORD 
2868 c2 5d 28				jp nz, .fldouscan 
286b			 
286b			;	if DEBUG_FORTH_WORDS 
286b			;		DMARK "LSu" 
286b			;		CALLMONITOR 
286b			;	endif 
286b			 
286b					; found a uword but is it the one we want... 
286b			 
286b c5					push bc     ; uword to find is on bc 
286c d1					pop de 
286d			 
286d e5					push hl  ; to save the ptr 
286e			 
286e					; skip opcode 
286e 23					inc hl  
286f					; skip next ptr 
286f 23					inc hl  
2870 23					inc hl 
2871					; skip len 
2871 23					inc hl 
2872			 
2872			;	if DEBUG_FORTH_WORDS 
2872			;		DMARK "LSc" 
2872			;		CALLMONITOR 
2872			;	endif 
2872 cd 4b 10				call strcmp 
2875 c2 5c 28				jp nz, .fldouscanm 
2878			; 
2878			; 
2878			;; while we have words to look for 
2878			; 
2878			;.fdouscan:	ld a, (hl)      
2878			;	if DEBUG_FORTH_WORDS 
2878			;		DMARK "LSs" 
2878			;		CALLMONITOR 
2878			;	endif 
2878			;		cp WORD_SYS_END 
2878			;		jp z, .fudone 
2878			;		cp WORD_SYS_UWORD 
2878			;		jp nz, .fnuword 
2878			; 
2878			;	if DEBUG_FORTH_WORDS 
2878			;		DMARK "FGu" 
2878			;		CALLMONITOR 
2878			;	endif 
2878			; 
2878			;		; found a uword but is it the one we want... 
2878			; 
2878			; 
2878			;	        pop de   ; get back the dsp name 
2878			;		push de 
2878			; 
2878			;		push hl  ; to save the ptr 
2878			; 
2878			;		; skip opcode 
2878			;		inc hl  
2878			;		; skip next ptr 
2878			;		inc hl  
2878			;		inc hl 
2878			;		; skip len 
2878			;		inc hl 
2878			; 
2878			;	if DEBUG_FORTH_WORDS 
2878			;		DMARK "FGc" 
2878			;		CALLMONITOR 
2878			;	endif 
2878			;		call strcmp 
2878			;		jp nz, .fnuword 
2878			 
2878			 
2878 e1			pop hl 
2879			 
2879				 
2879				if DEBUG_FORTH_WORDS 
2879					DMARK "FGm" 
2879 f5				push af  
287a 3a 8e 28			ld a, (.dmark)  
287d 32 7a ee			ld (debug_mark),a  
2880 3a 8f 28			ld a, (.dmark+1)  
2883 32 7b ee			ld (debug_mark+1),a  
2886 3a 90 28			ld a, (.dmark+2)  
2889 32 7c ee			ld (debug_mark+2),a  
288c 18 03			jr .pastdmark  
288e ..			.dmark: db "FGm"  
2891 f1			.pastdmark: pop af  
2892			endm  
# End of macro DMARK
2892					CALLMONITOR 
2892 cd 28 14			call break_point_state  
2895				endm  
# End of macro CALLMONITOR
2895				endif 
2895			 
2895			 
2895			 
2895					; we have a uword so push its name to the stack 
2895			 
2895			;	   	push hl  ; save so we can move to next dict block 
2895			;pop hl 
2895			 
2895					; update opcode to deleted 
2895 3e 03				ld a, WORD_SYS_DELETED 
2897 77					ld (hl), a 
2898			 
2898 23					inc hl  
2899					; skip next ptr 
2899 23					inc hl  
289a 23					inc hl 
289b					; skip len 
289b 23					inc hl 
289c			 
289c					; TODO change parser to skip deleted words but for now mark it out 
289c 3e 5f				ld a, "_" 
289e 77					ld  (hl),a 
289f			 
289f			;		jr .fudone 
289f			; 
289f			;.fnuword:	pop hl 
289f			;		call forth_tok_next 
289f			;		jp .fdouscan  
289f			 
289f			.flunotfound:		  
289f			 
289f			 
289f					 
289f					FORTH_DSP_POP 
289f cd 64 1c			call macro_forth_dsp_pop 
28a2				endm 
# End of macro FORTH_DSP_POP
28a2			;		ld hl, .luno 
28a2			;.fudone:		 pop hl 
28a2					NEXTW 
28a2 c3 1e 1d			jp macro_next 
28a5				endm 
# End of macro NEXTW
28a5			.NOP: 
28a5				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
28a5 61				db WORD_SYS_CORE+77             
28a6 cc 28			dw .COMO            
28a8 04				db 3 + 1 
28a9 .. 00			db "NOP",0              
28ad				endm 
# End of macro CWHEAD
28ad			; | NOP (  --  ) Do nothing | DONE 
28ad					if DEBUG_FORTH_WORDS_KEY 
28ad						DMARK "NOP" 
28ad f5				push af  
28ae 3a c2 28			ld a, (.dmark)  
28b1 32 7a ee			ld (debug_mark),a  
28b4 3a c3 28			ld a, (.dmark+1)  
28b7 32 7b ee			ld (debug_mark+1),a  
28ba 3a c4 28			ld a, (.dmark+2)  
28bd 32 7c ee			ld (debug_mark+2),a  
28c0 18 03			jr .pastdmark  
28c2 ..			.dmark: db "NOP"  
28c5 f1			.pastdmark: pop af  
28c6			endm  
# End of macro DMARK
28c6						CALLMONITOR 
28c6 cd 28 14			call break_point_state  
28c9				endm  
# End of macro CALLMONITOR
28c9					endif 
28c9				       NEXTW 
28c9 c3 1e 1d			jp macro_next 
28cc				endm 
# End of macro NEXTW
28cc			.COMO: 
28cc				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
28cc 6e				db WORD_SYS_CORE+90             
28cd 1e 29			dw .COMC            
28cf 02				db 1 + 1 
28d0 .. 00			db "(",0              
28d2				endm 
# End of macro CWHEAD
28d2			; | ( ( -- )  Start of comment | DONE 
28d2			 
28d2			 
28d2 2a 61 e6				ld hl, ( os_tok_ptr) 
28d5 11 19 29			ld de, .closepar 
28d8					 
28d8					if DEBUG_FORTH_WORDS 
28d8						DMARK ").." 
28d8 f5				push af  
28d9 3a ed 28			ld a, (.dmark)  
28dc 32 7a ee			ld (debug_mark),a  
28df 3a ee 28			ld a, (.dmark+1)  
28e2 32 7b ee			ld (debug_mark+1),a  
28e5 3a ef 28			ld a, (.dmark+2)  
28e8 32 7c ee			ld (debug_mark+2),a  
28eb 18 03			jr .pastdmark  
28ed ..			.dmark: db ").."  
28f0 f1			.pastdmark: pop af  
28f1			endm  
# End of macro DMARK
28f1						CALLMONITOR 
28f1 cd 28 14			call break_point_state  
28f4				endm  
# End of macro CALLMONITOR
28f4					endif 
28f4 cd 39 1e			call findnexttok  
28f7			 
28f7					if DEBUG_FORTH_WORDS 
28f7						DMARK "IF5" 
28f7 f5				push af  
28f8 3a 0c 29			ld a, (.dmark)  
28fb 32 7a ee			ld (debug_mark),a  
28fe 3a 0d 29			ld a, (.dmark+1)  
2901 32 7b ee			ld (debug_mark+1),a  
2904 3a 0e 29			ld a, (.dmark+2)  
2907 32 7c ee			ld (debug_mark+2),a  
290a 18 03			jr .pastdmark  
290c ..			.dmark: db "IF5"  
290f f1			.pastdmark: pop af  
2910			endm  
# End of macro DMARK
2910						CALLMONITOR 
2910 cd 28 14			call break_point_state  
2913				endm  
# End of macro CALLMONITOR
2913					endif 
2913				; replace below with ) exec using tok_ptr 
2913 22 61 e6			ld (os_tok_ptr), hl 
2916 c3 af 1d			jp exec1 
2919			 
2919 .. 00			.closepar:   db ")",0 
291b			 
291b				       NEXTW 
291b c3 1e 1d			jp macro_next 
291e				endm 
# End of macro NEXTW
291e			.COMC: 
291e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
291e 6f				db WORD_SYS_CORE+91             
291f 27 29			dw .SCRATCH            
2921 02				db 1 + 1 
2922 .. 00			db ")",0              
2924				endm 
# End of macro CWHEAD
2924			; | ) ( -- )  End of comment |  DONE  
2924				       NEXTW 
2924 c3 1e 1d			jp macro_next 
2927				endm 
# End of macro NEXTW
2927			 
2927			.SCRATCH: 
2927				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2927 6f				db WORD_SYS_CORE+91             
2928 62 29			dw .INC            
292a 08				db 7 + 1 
292b .. 00			db "SCRATCH",0              
2933				endm 
# End of macro CWHEAD
2933			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2933			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2933			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2933			; | |  
2933			; | | e.g.    : score $00 scratch ; 
2933			; | |  
2933			; | | $00 score ! 
2933			; | | $01 score +! 
2933			; | |  
2933			; | | e.g.   : varword $0a scratch ;  
2933			; | | 
2933			; | | $8000 varword ! 
2933					if DEBUG_FORTH_WORDS_KEY 
2933						DMARK "SCR" 
2933 f5				push af  
2934 3a 48 29			ld a, (.dmark)  
2937 32 7a ee			ld (debug_mark),a  
293a 3a 49 29			ld a, (.dmark+1)  
293d 32 7b ee			ld (debug_mark+1),a  
2940 3a 4a 29			ld a, (.dmark+2)  
2943 32 7c ee			ld (debug_mark+2),a  
2946 18 03			jr .pastdmark  
2948 ..			.dmark: db "SCR"  
294b f1			.pastdmark: pop af  
294c			endm  
# End of macro DMARK
294c						CALLMONITOR 
294c cd 28 14			call break_point_state  
294f				endm  
# End of macro CALLMONITOR
294f					endif 
294f			 
294f					FORTH_DSP_VALUEHL 
294f cd ac 1b			call macro_dsp_valuehl 
2952				endm 
# End of macro FORTH_DSP_VALUEHL
2952				 
2952					FORTH_DSP_POP 
2952 cd 64 1c			call macro_forth_dsp_pop 
2955				endm 
# End of macro FORTH_DSP_POP
2955			 
2955 7d					ld a, l 
2956 21 85 e8				ld hl, os_var_array 
2959 cd b5 0b				call addatohl 
295c			 
295c cd b5 19				call forth_push_numhl 
295f			 
295f				       NEXTW 
295f c3 1e 1d			jp macro_next 
2962				endm 
# End of macro NEXTW
2962			 
2962			.INC: 
2962				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2962 6f				db WORD_SYS_CORE+91             
2963 b6 29			dw .DEC            
2965 03				db 2 + 1 
2966 .. 00			db "+!",0              
2969				endm 
# End of macro CWHEAD
2969			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2969					if DEBUG_FORTH_WORDS_KEY 
2969						DMARK "+s_" 
2969 f5				push af  
296a 3a 7e 29			ld a, (.dmark)  
296d 32 7a ee			ld (debug_mark),a  
2970 3a 7f 29			ld a, (.dmark+1)  
2973 32 7b ee			ld (debug_mark+1),a  
2976 3a 80 29			ld a, (.dmark+2)  
2979 32 7c ee			ld (debug_mark+2),a  
297c 18 03			jr .pastdmark  
297e ..			.dmark: db "+s_"  
2981 f1			.pastdmark: pop af  
2982			endm  
# End of macro DMARK
2982						CALLMONITOR 
2982 cd 28 14			call break_point_state  
2985				endm  
# End of macro CALLMONITOR
2985					endif 
2985			 
2985					FORTH_DSP_VALUEHL 
2985 cd ac 1b			call macro_dsp_valuehl 
2988				endm 
# End of macro FORTH_DSP_VALUEHL
2988			 
2988 e5					push hl   ; save address 
2989			 
2989					FORTH_DSP_POP 
2989 cd 64 1c			call macro_forth_dsp_pop 
298c				endm 
# End of macro FORTH_DSP_POP
298c			 
298c					FORTH_DSP_VALUEHL 
298c cd ac 1b			call macro_dsp_valuehl 
298f				endm 
# End of macro FORTH_DSP_VALUEHL
298f			 
298f					FORTH_DSP_POP 
298f cd 64 1c			call macro_forth_dsp_pop 
2992				endm 
# End of macro FORTH_DSP_POP
2992			 
2992					; hl contains value to add to byte at a 
2992				 
2992 eb					ex de, hl 
2993			 
2993 e1					pop hl 
2994			 
2994					if DEBUG_FORTH_WORDS 
2994						DMARK "INC" 
2994 f5				push af  
2995 3a a9 29			ld a, (.dmark)  
2998 32 7a ee			ld (debug_mark),a  
299b 3a aa 29			ld a, (.dmark+1)  
299e 32 7b ee			ld (debug_mark+1),a  
29a1 3a ab 29			ld a, (.dmark+2)  
29a4 32 7c ee			ld (debug_mark+2),a  
29a7 18 03			jr .pastdmark  
29a9 ..			.dmark: db "INC"  
29ac f1			.pastdmark: pop af  
29ad			endm  
# End of macro DMARK
29ad						CALLMONITOR 
29ad cd 28 14			call break_point_state  
29b0				endm  
# End of macro CALLMONITOR
29b0					endif 
29b0			 
29b0 7e					ld a,(hl) 
29b1 83					add e 
29b2 77					ld (hl),a 
29b3			 
29b3			 
29b3			 
29b3				       NEXTW 
29b3 c3 1e 1d			jp macro_next 
29b6				endm 
# End of macro NEXTW
29b6			 
29b6			.DEC: 
29b6				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
29b6 6f				db WORD_SYS_CORE+91             
29b7 07 2a			dw .INC2            
29b9 03				db 2 + 1 
29ba .. 00			db "-!",0              
29bd				endm 
# End of macro CWHEAD
29bd			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
29bd					if DEBUG_FORTH_WORDS_KEY 
29bd						DMARK "-s_" 
29bd f5				push af  
29be 3a d2 29			ld a, (.dmark)  
29c1 32 7a ee			ld (debug_mark),a  
29c4 3a d3 29			ld a, (.dmark+1)  
29c7 32 7b ee			ld (debug_mark+1),a  
29ca 3a d4 29			ld a, (.dmark+2)  
29cd 32 7c ee			ld (debug_mark+2),a  
29d0 18 03			jr .pastdmark  
29d2 ..			.dmark: db "-s_"  
29d5 f1			.pastdmark: pop af  
29d6			endm  
# End of macro DMARK
29d6						CALLMONITOR 
29d6 cd 28 14			call break_point_state  
29d9				endm  
# End of macro CALLMONITOR
29d9					endif 
29d9			 
29d9					FORTH_DSP_VALUEHL 
29d9 cd ac 1b			call macro_dsp_valuehl 
29dc				endm 
# End of macro FORTH_DSP_VALUEHL
29dc			 
29dc e5					push hl   ; save address 
29dd			 
29dd					FORTH_DSP_POP 
29dd cd 64 1c			call macro_forth_dsp_pop 
29e0				endm 
# End of macro FORTH_DSP_POP
29e0			 
29e0					FORTH_DSP_VALUEHL 
29e0 cd ac 1b			call macro_dsp_valuehl 
29e3				endm 
# End of macro FORTH_DSP_VALUEHL
29e3			 
29e3					; hl contains value to add to byte at a 
29e3				 
29e3 eb					ex de, hl 
29e4			 
29e4 e1					pop hl 
29e5			 
29e5					if DEBUG_FORTH_WORDS 
29e5						DMARK "DEC" 
29e5 f5				push af  
29e6 3a fa 29			ld a, (.dmark)  
29e9 32 7a ee			ld (debug_mark),a  
29ec 3a fb 29			ld a, (.dmark+1)  
29ef 32 7b ee			ld (debug_mark+1),a  
29f2 3a fc 29			ld a, (.dmark+2)  
29f5 32 7c ee			ld (debug_mark+2),a  
29f8 18 03			jr .pastdmark  
29fa ..			.dmark: db "DEC"  
29fd f1			.pastdmark: pop af  
29fe			endm  
# End of macro DMARK
29fe						CALLMONITOR 
29fe cd 28 14			call break_point_state  
2a01				endm  
# End of macro CALLMONITOR
2a01					endif 
2a01			 
2a01 7e					ld a,(hl) 
2a02 93					sub e 
2a03 77					ld (hl),a 
2a04			 
2a04			 
2a04			 
2a04				       NEXTW 
2a04 c3 1e 1d			jp macro_next 
2a07				endm 
# End of macro NEXTW
2a07			 
2a07			.INC2: 
2a07				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2a07 6f				db WORD_SYS_CORE+91             
2a08 b1 2a			dw .DEC2            
2a0a 04				db 3 + 1 
2a0b .. 00			db "+2!",0              
2a0f				endm 
# End of macro CWHEAD
2a0f			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2a0f			 
2a0f					if DEBUG_FORTH_WORDS_KEY 
2a0f						DMARK "+2s" 
2a0f f5				push af  
2a10 3a 24 2a			ld a, (.dmark)  
2a13 32 7a ee			ld (debug_mark),a  
2a16 3a 25 2a			ld a, (.dmark+1)  
2a19 32 7b ee			ld (debug_mark+1),a  
2a1c 3a 26 2a			ld a, (.dmark+2)  
2a1f 32 7c ee			ld (debug_mark+2),a  
2a22 18 03			jr .pastdmark  
2a24 ..			.dmark: db "+2s"  
2a27 f1			.pastdmark: pop af  
2a28			endm  
# End of macro DMARK
2a28						CALLMONITOR 
2a28 cd 28 14			call break_point_state  
2a2b				endm  
# End of macro CALLMONITOR
2a2b					endif 
2a2b			 
2a2b					; Address 
2a2b			 
2a2b					FORTH_DSP_VALUEHL 
2a2b cd ac 1b			call macro_dsp_valuehl 
2a2e				endm 
# End of macro FORTH_DSP_VALUEHL
2a2e			 
2a2e e5					push hl    ; save address 
2a2f			 
2a2f					; load content into de 
2a2f			 
2a2f 5e					ld e,(hl) 
2a30 23					inc hl 
2a31 56					ld d, (hl) 
2a32			 
2a32					if DEBUG_FORTH_WORDS 
2a32						DMARK "+2a" 
2a32 f5				push af  
2a33 3a 47 2a			ld a, (.dmark)  
2a36 32 7a ee			ld (debug_mark),a  
2a39 3a 48 2a			ld a, (.dmark+1)  
2a3c 32 7b ee			ld (debug_mark+1),a  
2a3f 3a 49 2a			ld a, (.dmark+2)  
2a42 32 7c ee			ld (debug_mark+2),a  
2a45 18 03			jr .pastdmark  
2a47 ..			.dmark: db "+2a"  
2a4a f1			.pastdmark: pop af  
2a4b			endm  
# End of macro DMARK
2a4b						CALLMONITOR 
2a4b cd 28 14			call break_point_state  
2a4e				endm  
# End of macro CALLMONITOR
2a4e					endif 
2a4e			 
2a4e					FORTH_DSP_POP 
2a4e cd 64 1c			call macro_forth_dsp_pop 
2a51				endm 
# End of macro FORTH_DSP_POP
2a51			 
2a51					; Get value to add 
2a51			 
2a51					FORTH_DSP_VALUE 
2a51 cd 95 1b			call macro_forth_dsp_value 
2a54				endm 
# End of macro FORTH_DSP_VALUE
2a54			 
2a54					if DEBUG_FORTH_WORDS 
2a54						DMARK "+2v" 
2a54 f5				push af  
2a55 3a 69 2a			ld a, (.dmark)  
2a58 32 7a ee			ld (debug_mark),a  
2a5b 3a 6a 2a			ld a, (.dmark+1)  
2a5e 32 7b ee			ld (debug_mark+1),a  
2a61 3a 6b 2a			ld a, (.dmark+2)  
2a64 32 7c ee			ld (debug_mark+2),a  
2a67 18 03			jr .pastdmark  
2a69 ..			.dmark: db "+2v"  
2a6c f1			.pastdmark: pop af  
2a6d			endm  
# End of macro DMARK
2a6d						CALLMONITOR 
2a6d cd 28 14			call break_point_state  
2a70				endm  
# End of macro CALLMONITOR
2a70					endif 
2a70			 
2a70 19					add hl, de 
2a71			 
2a71					if DEBUG_FORTH_WORDS 
2a71						DMARK "+2+" 
2a71 f5				push af  
2a72 3a 86 2a			ld a, (.dmark)  
2a75 32 7a ee			ld (debug_mark),a  
2a78 3a 87 2a			ld a, (.dmark+1)  
2a7b 32 7b ee			ld (debug_mark+1),a  
2a7e 3a 88 2a			ld a, (.dmark+2)  
2a81 32 7c ee			ld (debug_mark+2),a  
2a84 18 03			jr .pastdmark  
2a86 ..			.dmark: db "+2+"  
2a89 f1			.pastdmark: pop af  
2a8a			endm  
# End of macro DMARK
2a8a						CALLMONITOR 
2a8a cd 28 14			call break_point_state  
2a8d				endm  
# End of macro CALLMONITOR
2a8d					endif 
2a8d			 
2a8d					; move result to de 
2a8d			 
2a8d eb					ex de, hl 
2a8e			 
2a8e					; Address 
2a8e			 
2a8e e1					pop hl 
2a8f			 
2a8f					; save it back 
2a8f			 
2a8f 73					ld (hl), e 
2a90 23					inc hl 
2a91 72					ld (hl), d 
2a92			 
2a92					if DEBUG_FORTH_WORDS 
2a92						DMARK "+2e" 
2a92 f5				push af  
2a93 3a a7 2a			ld a, (.dmark)  
2a96 32 7a ee			ld (debug_mark),a  
2a99 3a a8 2a			ld a, (.dmark+1)  
2a9c 32 7b ee			ld (debug_mark+1),a  
2a9f 3a a9 2a			ld a, (.dmark+2)  
2aa2 32 7c ee			ld (debug_mark+2),a  
2aa5 18 03			jr .pastdmark  
2aa7 ..			.dmark: db "+2e"  
2aaa f1			.pastdmark: pop af  
2aab			endm  
# End of macro DMARK
2aab						CALLMONITOR 
2aab cd 28 14			call break_point_state  
2aae				endm  
# End of macro CALLMONITOR
2aae					endif 
2aae			 
2aae			 
2aae			 
2aae			 
2aae			 
2aae				       NEXTW 
2aae c3 1e 1d			jp macro_next 
2ab1				endm 
# End of macro NEXTW
2ab1			 
2ab1			.DEC2: 
2ab1				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2ab1 6f				db WORD_SYS_CORE+91             
2ab2 5d 2b			dw .GET2            
2ab4 04				db 3 + 1 
2ab5 .. 00			db "-2!",0              
2ab9				endm 
# End of macro CWHEAD
2ab9			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2ab9			 
2ab9			 
2ab9					if DEBUG_FORTH_WORDS_KEY 
2ab9						DMARK "-2s" 
2ab9 f5				push af  
2aba 3a ce 2a			ld a, (.dmark)  
2abd 32 7a ee			ld (debug_mark),a  
2ac0 3a cf 2a			ld a, (.dmark+1)  
2ac3 32 7b ee			ld (debug_mark+1),a  
2ac6 3a d0 2a			ld a, (.dmark+2)  
2ac9 32 7c ee			ld (debug_mark+2),a  
2acc 18 03			jr .pastdmark  
2ace ..			.dmark: db "-2s"  
2ad1 f1			.pastdmark: pop af  
2ad2			endm  
# End of macro DMARK
2ad2						CALLMONITOR 
2ad2 cd 28 14			call break_point_state  
2ad5				endm  
# End of macro CALLMONITOR
2ad5					endif 
2ad5			 
2ad5					; Address 
2ad5			 
2ad5					FORTH_DSP_VALUEHL 
2ad5 cd ac 1b			call macro_dsp_valuehl 
2ad8				endm 
# End of macro FORTH_DSP_VALUEHL
2ad8			 
2ad8 e5					push hl    ; save address 
2ad9			 
2ad9					; load content into de 
2ad9			 
2ad9 5e					ld e,(hl) 
2ada 23					inc hl 
2adb 56					ld d, (hl) 
2adc			 
2adc					if DEBUG_FORTH_WORDS 
2adc						DMARK "-2a" 
2adc f5				push af  
2add 3a f1 2a			ld a, (.dmark)  
2ae0 32 7a ee			ld (debug_mark),a  
2ae3 3a f2 2a			ld a, (.dmark+1)  
2ae6 32 7b ee			ld (debug_mark+1),a  
2ae9 3a f3 2a			ld a, (.dmark+2)  
2aec 32 7c ee			ld (debug_mark+2),a  
2aef 18 03			jr .pastdmark  
2af1 ..			.dmark: db "-2a"  
2af4 f1			.pastdmark: pop af  
2af5			endm  
# End of macro DMARK
2af5						CALLMONITOR 
2af5 cd 28 14			call break_point_state  
2af8				endm  
# End of macro CALLMONITOR
2af8					endif 
2af8			 
2af8					FORTH_DSP_POP 
2af8 cd 64 1c			call macro_forth_dsp_pop 
2afb				endm 
# End of macro FORTH_DSP_POP
2afb			 
2afb					; Get value to remove 
2afb			 
2afb					FORTH_DSP_VALUE 
2afb cd 95 1b			call macro_forth_dsp_value 
2afe				endm 
# End of macro FORTH_DSP_VALUE
2afe			 
2afe					if DEBUG_FORTH_WORDS 
2afe						DMARK "-2v" 
2afe f5				push af  
2aff 3a 13 2b			ld a, (.dmark)  
2b02 32 7a ee			ld (debug_mark),a  
2b05 3a 14 2b			ld a, (.dmark+1)  
2b08 32 7b ee			ld (debug_mark+1),a  
2b0b 3a 15 2b			ld a, (.dmark+2)  
2b0e 32 7c ee			ld (debug_mark+2),a  
2b11 18 03			jr .pastdmark  
2b13 ..			.dmark: db "-2v"  
2b16 f1			.pastdmark: pop af  
2b17			endm  
# End of macro DMARK
2b17						CALLMONITOR 
2b17 cd 28 14			call break_point_state  
2b1a				endm  
# End of macro CALLMONITOR
2b1a					endif 
2b1a			 
2b1a eb					ex de, hl 
2b1b ed 52				sbc hl, de 
2b1d			 
2b1d					if DEBUG_FORTH_WORDS 
2b1d						DMARK "-2d" 
2b1d f5				push af  
2b1e 3a 32 2b			ld a, (.dmark)  
2b21 32 7a ee			ld (debug_mark),a  
2b24 3a 33 2b			ld a, (.dmark+1)  
2b27 32 7b ee			ld (debug_mark+1),a  
2b2a 3a 34 2b			ld a, (.dmark+2)  
2b2d 32 7c ee			ld (debug_mark+2),a  
2b30 18 03			jr .pastdmark  
2b32 ..			.dmark: db "-2d"  
2b35 f1			.pastdmark: pop af  
2b36			endm  
# End of macro DMARK
2b36						CALLMONITOR 
2b36 cd 28 14			call break_point_state  
2b39				endm  
# End of macro CALLMONITOR
2b39					endif 
2b39			 
2b39					; move result to de 
2b39			 
2b39 eb					ex de, hl 
2b3a			 
2b3a					; Address 
2b3a			 
2b3a e1					pop hl 
2b3b			 
2b3b					; save it back 
2b3b			 
2b3b 73					ld (hl), e 
2b3c 23					inc hl 
2b3d 72					ld (hl), d 
2b3e			 
2b3e					if DEBUG_FORTH_WORDS 
2b3e						DMARK "-2e" 
2b3e f5				push af  
2b3f 3a 53 2b			ld a, (.dmark)  
2b42 32 7a ee			ld (debug_mark),a  
2b45 3a 54 2b			ld a, (.dmark+1)  
2b48 32 7b ee			ld (debug_mark+1),a  
2b4b 3a 55 2b			ld a, (.dmark+2)  
2b4e 32 7c ee			ld (debug_mark+2),a  
2b51 18 03			jr .pastdmark  
2b53 ..			.dmark: db "-2e"  
2b56 f1			.pastdmark: pop af  
2b57			endm  
# End of macro DMARK
2b57						CALLMONITOR 
2b57 cd 28 14			call break_point_state  
2b5a				endm  
# End of macro CALLMONITOR
2b5a					endif 
2b5a			 
2b5a			 
2b5a			 
2b5a			 
2b5a			 
2b5a				       NEXTW 
2b5a c3 1e 1d			jp macro_next 
2b5d				endm 
# End of macro NEXTW
2b5d			.GET2: 
2b5d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2b5d 6f				db WORD_SYS_CORE+91             
2b5e 8d 2b			dw .BANG2            
2b60 03				db 2 + 1 
2b61 .. 00			db "2@",0              
2b64				endm 
# End of macro CWHEAD
2b64			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2b64					if DEBUG_FORTH_WORDS_KEY 
2b64						DMARK "2A_" 
2b64 f5				push af  
2b65 3a 79 2b			ld a, (.dmark)  
2b68 32 7a ee			ld (debug_mark),a  
2b6b 3a 7a 2b			ld a, (.dmark+1)  
2b6e 32 7b ee			ld (debug_mark+1),a  
2b71 3a 7b 2b			ld a, (.dmark+2)  
2b74 32 7c ee			ld (debug_mark+2),a  
2b77 18 03			jr .pastdmark  
2b79 ..			.dmark: db "2A_"  
2b7c f1			.pastdmark: pop af  
2b7d			endm  
# End of macro DMARK
2b7d						CALLMONITOR 
2b7d cd 28 14			call break_point_state  
2b80				endm  
# End of macro CALLMONITOR
2b80					endif 
2b80			 
2b80					FORTH_DSP_VALUEHL 
2b80 cd ac 1b			call macro_dsp_valuehl 
2b83				endm 
# End of macro FORTH_DSP_VALUEHL
2b83			 
2b83 5e					ld e, (hl) 
2b84 23					inc hl 
2b85 56					ld d, (hl) 
2b86			 
2b86 eb					ex de, hl 
2b87			 
2b87 cd b5 19				call forth_push_numhl 
2b8a			 
2b8a				       NEXTW 
2b8a c3 1e 1d			jp macro_next 
2b8d				endm 
# End of macro NEXTW
2b8d			.BANG2: 
2b8d				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2b8d 6f				db WORD_SYS_CORE+91             
2b8e c5 2b			dw .CONFIG            
2b90 03				db 2 + 1 
2b91 .. 00			db "2!",0              
2b94				endm 
# End of macro CWHEAD
2b94			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2b94					if DEBUG_FORTH_WORDS_KEY 
2b94						DMARK "2S_" 
2b94 f5				push af  
2b95 3a a9 2b			ld a, (.dmark)  
2b98 32 7a ee			ld (debug_mark),a  
2b9b 3a aa 2b			ld a, (.dmark+1)  
2b9e 32 7b ee			ld (debug_mark+1),a  
2ba1 3a ab 2b			ld a, (.dmark+2)  
2ba4 32 7c ee			ld (debug_mark+2),a  
2ba7 18 03			jr .pastdmark  
2ba9 ..			.dmark: db "2S_"  
2bac f1			.pastdmark: pop af  
2bad			endm  
# End of macro DMARK
2bad						CALLMONITOR 
2bad cd 28 14			call break_point_state  
2bb0				endm  
# End of macro CALLMONITOR
2bb0					endif 
2bb0			 
2bb0					FORTH_DSP_VALUEHL 
2bb0 cd ac 1b			call macro_dsp_valuehl 
2bb3				endm 
# End of macro FORTH_DSP_VALUEHL
2bb3			 
2bb3 e5					push hl   ; save address 
2bb4			 
2bb4			 
2bb4					FORTH_DSP_POP 
2bb4 cd 64 1c			call macro_forth_dsp_pop 
2bb7				endm 
# End of macro FORTH_DSP_POP
2bb7			 
2bb7					 
2bb7					FORTH_DSP_VALUEHL 
2bb7 cd ac 1b			call macro_dsp_valuehl 
2bba				endm 
# End of macro FORTH_DSP_VALUEHL
2bba			 
2bba					FORTH_DSP_POP 
2bba cd 64 1c			call macro_forth_dsp_pop 
2bbd				endm 
# End of macro FORTH_DSP_POP
2bbd			 
2bbd eb					ex de, hl    ; value now in de 
2bbe			 
2bbe e1					pop hl 
2bbf			 
2bbf 73					ld (hl), e 
2bc0			 
2bc0 23					inc hl 
2bc1			 
2bc1 72					ld (hl), d 
2bc2			 
2bc2			 
2bc2				       NEXTW 
2bc2 c3 1e 1d			jp macro_next 
2bc5				endm 
# End of macro NEXTW
2bc5			.CONFIG: 
2bc5				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2bc5 6f				db WORD_SYS_CORE+91             
2bc6 d6 2b			dw .ENDCORE            
2bc8 07				db 6 + 1 
2bc9 .. 00			db "CONFIG",0              
2bd0				endm 
# End of macro CWHEAD
2bd0			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2bd0			 
2bd0 cd 15 12				call config 
2bd3					NEXTW 
2bd3 c3 1e 1d			jp macro_next 
2bd6				endm 
# End of macro NEXTW
2bd6			.ENDCORE: 
2bd6			 
2bd6			; eof 
2bd6			 
2bd6			 
# End of file forth_words_core.asm
2bd6			include "forth_words_flow.asm" 
2bd6			 
2bd6			; | ## Program Flow Words 
2bd6			 
2bd6			.IF: 
2bd6				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2bd6 1e				db WORD_SYS_CORE+10             
2bd7 cb 2c			dw .THEN            
2bd9 03				db 2 + 1 
2bda .. 00			db "IF",0              
2bdd				endm 
# End of macro CWHEAD
2bdd			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2bdd			; 
2bdd					if DEBUG_FORTH_WORDS_KEY 
2bdd						DMARK "IF." 
2bdd f5				push af  
2bde 3a f2 2b			ld a, (.dmark)  
2be1 32 7a ee			ld (debug_mark),a  
2be4 3a f3 2b			ld a, (.dmark+1)  
2be7 32 7b ee			ld (debug_mark+1),a  
2bea 3a f4 2b			ld a, (.dmark+2)  
2bed 32 7c ee			ld (debug_mark+2),a  
2bf0 18 03			jr .pastdmark  
2bf2 ..			.dmark: db "IF."  
2bf5 f1			.pastdmark: pop af  
2bf6			endm  
# End of macro DMARK
2bf6						CALLMONITOR 
2bf6 cd 28 14			call break_point_state  
2bf9				endm  
# End of macro CALLMONITOR
2bf9					endif 
2bf9			; eval TOS 
2bf9			 
2bf9				FORTH_DSP_VALUEHL 
2bf9 cd ac 1b			call macro_dsp_valuehl 
2bfc				endm 
# End of macro FORTH_DSP_VALUEHL
2bfc			 
2bfc			;	push hl 
2bfc				FORTH_DSP_POP 
2bfc cd 64 1c			call macro_forth_dsp_pop 
2bff				endm 
# End of macro FORTH_DSP_POP
2bff			;	pop hl 
2bff			 
2bff					if DEBUG_FORTH_WORDS 
2bff						DMARK "IF1" 
2bff f5				push af  
2c00 3a 14 2c			ld a, (.dmark)  
2c03 32 7a ee			ld (debug_mark),a  
2c06 3a 15 2c			ld a, (.dmark+1)  
2c09 32 7b ee			ld (debug_mark+1),a  
2c0c 3a 16 2c			ld a, (.dmark+2)  
2c0f 32 7c ee			ld (debug_mark+2),a  
2c12 18 03			jr .pastdmark  
2c14 ..			.dmark: db "IF1"  
2c17 f1			.pastdmark: pop af  
2c18			endm  
# End of macro DMARK
2c18						CALLMONITOR 
2c18 cd 28 14			call break_point_state  
2c1b				endm  
# End of macro CALLMONITOR
2c1b					endif 
2c1b b7				or a        ; clear carry flag 
2c1c 11 00 00			ld de, 0 
2c1f eb				ex de,hl 
2c20 ed 52			sbc hl, de 
2c22 c2 ac 2c			jp nz, .iftrue 
2c25			 
2c25					if DEBUG_FORTH_WORDS 
2c25						DMARK "IF2" 
2c25 f5				push af  
2c26 3a 3a 2c			ld a, (.dmark)  
2c29 32 7a ee			ld (debug_mark),a  
2c2c 3a 3b 2c			ld a, (.dmark+1)  
2c2f 32 7b ee			ld (debug_mark+1),a  
2c32 3a 3c 2c			ld a, (.dmark+2)  
2c35 32 7c ee			ld (debug_mark+2),a  
2c38 18 03			jr .pastdmark  
2c3a ..			.dmark: db "IF2"  
2c3d f1			.pastdmark: pop af  
2c3e			endm  
# End of macro DMARK
2c3e						CALLMONITOR 
2c3e cd 28 14			call break_point_state  
2c41				endm  
# End of macro CALLMONITOR
2c41					endif 
2c41			 
2c41			; if not true then skip to THEN 
2c41			 
2c41				; TODO get tok_ptr 
2c41				; TODO consume toks until we get to THEN 
2c41			 
2c41 2a 61 e6			ld hl, (os_tok_ptr) 
2c44					if DEBUG_FORTH_WORDS 
2c44						DMARK "IF3" 
2c44 f5				push af  
2c45 3a 59 2c			ld a, (.dmark)  
2c48 32 7a ee			ld (debug_mark),a  
2c4b 3a 5a 2c			ld a, (.dmark+1)  
2c4e 32 7b ee			ld (debug_mark+1),a  
2c51 3a 5b 2c			ld a, (.dmark+2)  
2c54 32 7c ee			ld (debug_mark+2),a  
2c57 18 03			jr .pastdmark  
2c59 ..			.dmark: db "IF3"  
2c5c f1			.pastdmark: pop af  
2c5d			endm  
# End of macro DMARK
2c5d						CALLMONITOR 
2c5d cd 28 14			call break_point_state  
2c60				endm  
# End of macro CALLMONITOR
2c60						 
2c60					endif 
2c60 11 a7 2c			ld de, .ifthen 
2c63					if DEBUG_FORTH_WORDS 
2c63						DMARK "IF4" 
2c63 f5				push af  
2c64 3a 78 2c			ld a, (.dmark)  
2c67 32 7a ee			ld (debug_mark),a  
2c6a 3a 79 2c			ld a, (.dmark+1)  
2c6d 32 7b ee			ld (debug_mark+1),a  
2c70 3a 7a 2c			ld a, (.dmark+2)  
2c73 32 7c ee			ld (debug_mark+2),a  
2c76 18 03			jr .pastdmark  
2c78 ..			.dmark: db "IF4"  
2c7b f1			.pastdmark: pop af  
2c7c			endm  
# End of macro DMARK
2c7c						CALLMONITOR 
2c7c cd 28 14			call break_point_state  
2c7f				endm  
# End of macro CALLMONITOR
2c7f					endif 
2c7f cd 39 1e			call findnexttok  
2c82			 
2c82					if DEBUG_FORTH_WORDS 
2c82						DMARK "IF5" 
2c82 f5				push af  
2c83 3a 97 2c			ld a, (.dmark)  
2c86 32 7a ee			ld (debug_mark),a  
2c89 3a 98 2c			ld a, (.dmark+1)  
2c8c 32 7b ee			ld (debug_mark+1),a  
2c8f 3a 99 2c			ld a, (.dmark+2)  
2c92 32 7c ee			ld (debug_mark+2),a  
2c95 18 03			jr .pastdmark  
2c97 ..			.dmark: db "IF5"  
2c9a f1			.pastdmark: pop af  
2c9b			endm  
# End of macro DMARK
2c9b						CALLMONITOR 
2c9b cd 28 14			call break_point_state  
2c9e				endm  
# End of macro CALLMONITOR
2c9e					endif 
2c9e				; TODO replace below with ; exec using tok_ptr 
2c9e 22 61 e6			ld (os_tok_ptr), hl 
2ca1 c3 af 1d			jp exec1 
2ca4				NEXTW 
2ca4 c3 1e 1d			jp macro_next 
2ca7				endm 
# End of macro NEXTW
2ca7			 
2ca7 .. 00		.ifthen:  db "THEN",0 
2cac			 
2cac			.iftrue:		 
2cac				; Exec next words normally 
2cac			 
2cac				; if true then exec following IF as normal 
2cac					if DEBUG_FORTH_WORDS 
2cac						DMARK "IFT" 
2cac f5				push af  
2cad 3a c1 2c			ld a, (.dmark)  
2cb0 32 7a ee			ld (debug_mark),a  
2cb3 3a c2 2c			ld a, (.dmark+1)  
2cb6 32 7b ee			ld (debug_mark+1),a  
2cb9 3a c3 2c			ld a, (.dmark+2)  
2cbc 32 7c ee			ld (debug_mark+2),a  
2cbf 18 03			jr .pastdmark  
2cc1 ..			.dmark: db "IFT"  
2cc4 f1			.pastdmark: pop af  
2cc5			endm  
# End of macro DMARK
2cc5						CALLMONITOR 
2cc5 cd 28 14			call break_point_state  
2cc8				endm  
# End of macro CALLMONITOR
2cc8					endif 
2cc8			 
2cc8					NEXTW 
2cc8 c3 1e 1d			jp macro_next 
2ccb				endm 
# End of macro NEXTW
2ccb			.THEN: 
2ccb				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2ccb 1f				db WORD_SYS_CORE+11             
2ccc f3 2c			dw .ELSE            
2cce 05				db 4 + 1 
2ccf .. 00			db "THEN",0              
2cd4				endm 
# End of macro CWHEAD
2cd4			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2cd4					if DEBUG_FORTH_WORDS_KEY 
2cd4						DMARK "THN" 
2cd4 f5				push af  
2cd5 3a e9 2c			ld a, (.dmark)  
2cd8 32 7a ee			ld (debug_mark),a  
2cdb 3a ea 2c			ld a, (.dmark+1)  
2cde 32 7b ee			ld (debug_mark+1),a  
2ce1 3a eb 2c			ld a, (.dmark+2)  
2ce4 32 7c ee			ld (debug_mark+2),a  
2ce7 18 03			jr .pastdmark  
2ce9 ..			.dmark: db "THN"  
2cec f1			.pastdmark: pop af  
2ced			endm  
# End of macro DMARK
2ced						CALLMONITOR 
2ced cd 28 14			call break_point_state  
2cf0				endm  
# End of macro CALLMONITOR
2cf0					endif 
2cf0					NEXTW 
2cf0 c3 1e 1d			jp macro_next 
2cf3				endm 
# End of macro NEXTW
2cf3			.ELSE: 
2cf3				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2cf3 20				db WORD_SYS_CORE+12             
2cf4 1b 2d			dw .DO            
2cf6 03				db 2 + 1 
2cf7 .. 00			db "ELSE",0              
2cfc				endm 
# End of macro CWHEAD
2cfc			; | ELSE ( -- ) Not supported - does nothing | TODO 
2cfc			 
2cfc					if DEBUG_FORTH_WORDS_KEY 
2cfc						DMARK "ELS" 
2cfc f5				push af  
2cfd 3a 11 2d			ld a, (.dmark)  
2d00 32 7a ee			ld (debug_mark),a  
2d03 3a 12 2d			ld a, (.dmark+1)  
2d06 32 7b ee			ld (debug_mark+1),a  
2d09 3a 13 2d			ld a, (.dmark+2)  
2d0c 32 7c ee			ld (debug_mark+2),a  
2d0f 18 03			jr .pastdmark  
2d11 ..			.dmark: db "ELS"  
2d14 f1			.pastdmark: pop af  
2d15			endm  
# End of macro DMARK
2d15						CALLMONITOR 
2d15 cd 28 14			call break_point_state  
2d18				endm  
# End of macro CALLMONITOR
2d18					endif 
2d18			 
2d18			 
2d18					NEXTW 
2d18 c3 1e 1d			jp macro_next 
2d1b				endm 
# End of macro NEXTW
2d1b			.DO: 
2d1b				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2d1b 21				db WORD_SYS_CORE+13             
2d1c 42 2e			dw .LOOP            
2d1e 03				db 2 + 1 
2d1f .. 00			db "DO",0              
2d22				endm 
# End of macro CWHEAD
2d22			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2d22			 
2d22					if DEBUG_FORTH_WORDS_KEY 
2d22						DMARK "DO." 
2d22 f5				push af  
2d23 3a 37 2d			ld a, (.dmark)  
2d26 32 7a ee			ld (debug_mark),a  
2d29 3a 38 2d			ld a, (.dmark+1)  
2d2c 32 7b ee			ld (debug_mark+1),a  
2d2f 3a 39 2d			ld a, (.dmark+2)  
2d32 32 7c ee			ld (debug_mark+2),a  
2d35 18 03			jr .pastdmark  
2d37 ..			.dmark: db "DO."  
2d3a f1			.pastdmark: pop af  
2d3b			endm  
# End of macro DMARK
2d3b						CALLMONITOR 
2d3b cd 28 14			call break_point_state  
2d3e				endm  
# End of macro CALLMONITOR
2d3e					endif 
2d3e			;  push pc to rsp stack past the DO 
2d3e			 
2d3e 2a 61 e6				ld hl, (os_tok_ptr) 
2d41 23					inc hl   ; D 
2d42 23					inc hl  ; O 
2d43 23					inc hl   ; null 
2d44					if DEBUG_FORTH_WORDS 
2d44						DMARK "DO2" 
2d44 f5				push af  
2d45 3a 59 2d			ld a, (.dmark)  
2d48 32 7a ee			ld (debug_mark),a  
2d4b 3a 5a 2d			ld a, (.dmark+1)  
2d4e 32 7b ee			ld (debug_mark+1),a  
2d51 3a 5b 2d			ld a, (.dmark+2)  
2d54 32 7c ee			ld (debug_mark+2),a  
2d57 18 03			jr .pastdmark  
2d59 ..			.dmark: db "DO2"  
2d5c f1			.pastdmark: pop af  
2d5d			endm  
# End of macro DMARK
2d5d						CALLMONITOR 
2d5d cd 28 14			call break_point_state  
2d60				endm  
# End of macro CALLMONITOR
2d60					endif 
2d60					FORTH_RSP_NEXT 
2d60 cd 5c 19			call macro_forth_rsp_next 
2d63				endm 
# End of macro FORTH_RSP_NEXT
2d63					if DEBUG_FORTH_WORDS 
2d63						DMARK "DO3" 
2d63 f5				push af  
2d64 3a 78 2d			ld a, (.dmark)  
2d67 32 7a ee			ld (debug_mark),a  
2d6a 3a 79 2d			ld a, (.dmark+1)  
2d6d 32 7b ee			ld (debug_mark+1),a  
2d70 3a 7a 2d			ld a, (.dmark+2)  
2d73 32 7c ee			ld (debug_mark+2),a  
2d76 18 03			jr .pastdmark  
2d78 ..			.dmark: db "DO3"  
2d7b f1			.pastdmark: pop af  
2d7c			endm  
# End of macro DMARK
2d7c						CALLMONITOR 
2d7c cd 28 14			call break_point_state  
2d7f				endm  
# End of macro CALLMONITOR
2d7f					endif 
2d7f			 
2d7f					;if DEBUG_FORTH_WORDS 
2d7f				;		push hl 
2d7f			;		endif  
2d7f			 
2d7f			; get counters from data stack 
2d7f			 
2d7f			 
2d7f					FORTH_DSP_VALUEHL 
2d7f cd ac 1b			call macro_dsp_valuehl 
2d82				endm 
# End of macro FORTH_DSP_VALUEHL
2d82 e5					push hl		 ; hl now has starting counter which needs to be tos 
2d83			 
2d83					if DEBUG_FORTH_WORDS 
2d83						DMARK "DO4" 
2d83 f5				push af  
2d84 3a 98 2d			ld a, (.dmark)  
2d87 32 7a ee			ld (debug_mark),a  
2d8a 3a 99 2d			ld a, (.dmark+1)  
2d8d 32 7b ee			ld (debug_mark+1),a  
2d90 3a 9a 2d			ld a, (.dmark+2)  
2d93 32 7c ee			ld (debug_mark+2),a  
2d96 18 03			jr .pastdmark  
2d98 ..			.dmark: db "DO4"  
2d9b f1			.pastdmark: pop af  
2d9c			endm  
# End of macro DMARK
2d9c						CALLMONITOR 
2d9c cd 28 14			call break_point_state  
2d9f				endm  
# End of macro CALLMONITOR
2d9f					endif 
2d9f					FORTH_DSP_POP 
2d9f cd 64 1c			call macro_forth_dsp_pop 
2da2				endm 
# End of macro FORTH_DSP_POP
2da2			 
2da2					if DEBUG_FORTH_WORDS 
2da2						DMARK "DO5" 
2da2 f5				push af  
2da3 3a b7 2d			ld a, (.dmark)  
2da6 32 7a ee			ld (debug_mark),a  
2da9 3a b8 2d			ld a, (.dmark+1)  
2dac 32 7b ee			ld (debug_mark+1),a  
2daf 3a b9 2d			ld a, (.dmark+2)  
2db2 32 7c ee			ld (debug_mark+2),a  
2db5 18 03			jr .pastdmark  
2db7 ..			.dmark: db "DO5"  
2dba f1			.pastdmark: pop af  
2dbb			endm  
# End of macro DMARK
2dbb						CALLMONITOR 
2dbb cd 28 14			call break_point_state  
2dbe				endm  
# End of macro CALLMONITOR
2dbe					endif 
2dbe			 
2dbe					FORTH_DSP_VALUEHL 
2dbe cd ac 1b			call macro_dsp_valuehl 
2dc1				endm 
# End of macro FORTH_DSP_VALUEHL
2dc1			;		push hl		 ; hl now has starting limit counter 
2dc1			 
2dc1					if DEBUG_FORTH_WORDS 
2dc1						DMARK "DO6" 
2dc1 f5				push af  
2dc2 3a d6 2d			ld a, (.dmark)  
2dc5 32 7a ee			ld (debug_mark),a  
2dc8 3a d7 2d			ld a, (.dmark+1)  
2dcb 32 7b ee			ld (debug_mark+1),a  
2dce 3a d8 2d			ld a, (.dmark+2)  
2dd1 32 7c ee			ld (debug_mark+2),a  
2dd4 18 03			jr .pastdmark  
2dd6 ..			.dmark: db "DO6"  
2dd9 f1			.pastdmark: pop af  
2dda			endm  
# End of macro DMARK
2dda						CALLMONITOR 
2dda cd 28 14			call break_point_state  
2ddd				endm  
# End of macro CALLMONITOR
2ddd					endif 
2ddd					FORTH_DSP_POP 
2ddd cd 64 1c			call macro_forth_dsp_pop 
2de0				endm 
# End of macro FORTH_DSP_POP
2de0			 
2de0			; put counters on the loop stack 
2de0			 
2de0			;		pop hl			 ; limit counter 
2de0 d1					pop de			; start counter 
2de1			 
2de1					; push limit counter 
2de1			 
2de1					if DEBUG_FORTH_WORDS 
2de1						DMARK "DO7" 
2de1 f5				push af  
2de2 3a f6 2d			ld a, (.dmark)  
2de5 32 7a ee			ld (debug_mark),a  
2de8 3a f7 2d			ld a, (.dmark+1)  
2deb 32 7b ee			ld (debug_mark+1),a  
2dee 3a f8 2d			ld a, (.dmark+2)  
2df1 32 7c ee			ld (debug_mark+2),a  
2df4 18 03			jr .pastdmark  
2df6 ..			.dmark: db "DO7"  
2df9 f1			.pastdmark: pop af  
2dfa			endm  
# End of macro DMARK
2dfa						CALLMONITOR 
2dfa cd 28 14			call break_point_state  
2dfd				endm  
# End of macro CALLMONITOR
2dfd					endif 
2dfd					FORTH_LOOP_NEXT 
2dfd cd dd 1b			call macro_forth_loop_next 
2e00				endm 
# End of macro FORTH_LOOP_NEXT
2e00			 
2e00					; push start counter 
2e00			 
2e00 eb					ex de, hl 
2e01					if DEBUG_FORTH_WORDS 
2e01						DMARK "DO7" 
2e01 f5				push af  
2e02 3a 16 2e			ld a, (.dmark)  
2e05 32 7a ee			ld (debug_mark),a  
2e08 3a 17 2e			ld a, (.dmark+1)  
2e0b 32 7b ee			ld (debug_mark+1),a  
2e0e 3a 18 2e			ld a, (.dmark+2)  
2e11 32 7c ee			ld (debug_mark+2),a  
2e14 18 03			jr .pastdmark  
2e16 ..			.dmark: db "DO7"  
2e19 f1			.pastdmark: pop af  
2e1a			endm  
# End of macro DMARK
2e1a						CALLMONITOR 
2e1a cd 28 14			call break_point_state  
2e1d				endm  
# End of macro CALLMONITOR
2e1d					endif 
2e1d					FORTH_LOOP_NEXT 
2e1d cd dd 1b			call macro_forth_loop_next 
2e20				endm 
# End of macro FORTH_LOOP_NEXT
2e20			 
2e20			 
2e20					; init first round of I counter 
2e20			 
2e20 22 85 e6				ld (os_current_i), hl 
2e23			 
2e23					if DEBUG_FORTH_WORDS 
2e23						DMARK "DO8" 
2e23 f5				push af  
2e24 3a 38 2e			ld a, (.dmark)  
2e27 32 7a ee			ld (debug_mark),a  
2e2a 3a 39 2e			ld a, (.dmark+1)  
2e2d 32 7b ee			ld (debug_mark+1),a  
2e30 3a 3a 2e			ld a, (.dmark+2)  
2e33 32 7c ee			ld (debug_mark+2),a  
2e36 18 03			jr .pastdmark  
2e38 ..			.dmark: db "DO8"  
2e3b f1			.pastdmark: pop af  
2e3c			endm  
# End of macro DMARK
2e3c						CALLMONITOR 
2e3c cd 28 14			call break_point_state  
2e3f				endm  
# End of macro CALLMONITOR
2e3f					endif 
2e3f			 
2e3f					NEXTW 
2e3f c3 1e 1d			jp macro_next 
2e42				endm 
# End of macro NEXTW
2e42			.LOOP: 
2e42				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2e42 22				db WORD_SYS_CORE+14             
2e43 5a 2f			dw .I            
2e45 05				db 4 + 1 
2e46 .. 00			db "LOOP",0              
2e4b				endm 
# End of macro CWHEAD
2e4b			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2e4b			 
2e4b				; pop tos as current loop count to hl 
2e4b			 
2e4b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2e4b			 
2e4b				FORTH_LOOP_TOS 
2e4b cd 10 1c			call macro_forth_loop_tos 
2e4e				endm 
# End of macro FORTH_LOOP_TOS
2e4e e5				push hl 
2e4f			 
2e4f					if DEBUG_FORTH_WORDS_KEY 
2e4f						DMARK "LOP" 
2e4f f5				push af  
2e50 3a 64 2e			ld a, (.dmark)  
2e53 32 7a ee			ld (debug_mark),a  
2e56 3a 65 2e			ld a, (.dmark+1)  
2e59 32 7b ee			ld (debug_mark+1),a  
2e5c 3a 66 2e			ld a, (.dmark+2)  
2e5f 32 7c ee			ld (debug_mark+2),a  
2e62 18 03			jr .pastdmark  
2e64 ..			.dmark: db "LOP"  
2e67 f1			.pastdmark: pop af  
2e68			endm  
# End of macro DMARK
2e68						CALLMONITOR 
2e68 cd 28 14			call break_point_state  
2e6b				endm  
# End of macro CALLMONITOR
2e6b					endif 
2e6b				; next item on the stack is the limit. get it 
2e6b			 
2e6b			 
2e6b				FORTH_LOOP_POP 
2e6b cd 1a 1c			call macro_forth_loop_pop 
2e6e				endm 
# End of macro FORTH_LOOP_POP
2e6e			 
2e6e				FORTH_LOOP_TOS 
2e6e cd 10 1c			call macro_forth_loop_tos 
2e71				endm 
# End of macro FORTH_LOOP_TOS
2e71			 
2e71 d1				pop de		 ; de = i, hl = limit 
2e72			 
2e72					if DEBUG_FORTH_WORDS 
2e72						DMARK "LP1" 
2e72 f5				push af  
2e73 3a 87 2e			ld a, (.dmark)  
2e76 32 7a ee			ld (debug_mark),a  
2e79 3a 88 2e			ld a, (.dmark+1)  
2e7c 32 7b ee			ld (debug_mark+1),a  
2e7f 3a 89 2e			ld a, (.dmark+2)  
2e82 32 7c ee			ld (debug_mark+2),a  
2e85 18 03			jr .pastdmark  
2e87 ..			.dmark: db "LP1"  
2e8a f1			.pastdmark: pop af  
2e8b			endm  
# End of macro DMARK
2e8b						CALLMONITOR 
2e8b cd 28 14			call break_point_state  
2e8e				endm  
# End of macro CALLMONITOR
2e8e					endif 
2e8e			 
2e8e				; go back to previous word 
2e8e			 
2e8e d5				push de    ; save I for inc later 
2e8f			 
2e8f			 
2e8f				; get limit 
2e8f				;  is I at limit? 
2e8f			 
2e8f			 
2e8f					if DEBUG_FORTH_WORDS 
2e8f						DMARK "LP1" 
2e8f f5				push af  
2e90 3a a4 2e			ld a, (.dmark)  
2e93 32 7a ee			ld (debug_mark),a  
2e96 3a a5 2e			ld a, (.dmark+1)  
2e99 32 7b ee			ld (debug_mark+1),a  
2e9c 3a a6 2e			ld a, (.dmark+2)  
2e9f 32 7c ee			ld (debug_mark+2),a  
2ea2 18 03			jr .pastdmark  
2ea4 ..			.dmark: db "LP1"  
2ea7 f1			.pastdmark: pop af  
2ea8			endm  
# End of macro DMARK
2ea8						CALLMONITOR 
2ea8 cd 28 14			call break_point_state  
2eab				endm  
# End of macro CALLMONITOR
2eab					endif 
2eab			 
2eab ed 52			sbc hl, de 
2ead			 
2ead			 
2ead				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2ead			 
2ead 20 26				jr nz, .loopnotdone 
2eaf			 
2eaf e1				pop hl   ; get rid of saved I 
2eb0				FORTH_LOOP_POP     ; get rid of limit 
2eb0 cd 1a 1c			call macro_forth_loop_pop 
2eb3				endm 
# End of macro FORTH_LOOP_POP
2eb3			 
2eb3				FORTH_RSP_POP     ; get rid of DO ptr 
2eb3 cd 7d 19			call macro_forth_rsp_pop 
2eb6				endm 
# End of macro FORTH_RSP_POP
2eb6			 
2eb6			if DEBUG_FORTH_WORDS 
2eb6						DMARK "LP>" 
2eb6 f5				push af  
2eb7 3a cb 2e			ld a, (.dmark)  
2eba 32 7a ee			ld (debug_mark),a  
2ebd 3a cc 2e			ld a, (.dmark+1)  
2ec0 32 7b ee			ld (debug_mark+1),a  
2ec3 3a cd 2e			ld a, (.dmark+2)  
2ec6 32 7c ee			ld (debug_mark+2),a  
2ec9 18 03			jr .pastdmark  
2ecb ..			.dmark: db "LP>"  
2ece f1			.pastdmark: pop af  
2ecf			endm  
# End of macro DMARK
2ecf				CALLMONITOR 
2ecf cd 28 14			call break_point_state  
2ed2				endm  
# End of macro CALLMONITOR
2ed2			endif 
2ed2			 
2ed2					NEXTW 
2ed2 c3 1e 1d			jp macro_next 
2ed5				endm 
# End of macro NEXTW
2ed5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2ed5			 
2ed5			.loopnotdone: 
2ed5			 
2ed5 e1				pop hl    ; get I 
2ed6 23				inc hl 
2ed7			 
2ed7			   	; save new I 
2ed7			 
2ed7			 
2ed7					; set I counter 
2ed7			 
2ed7 22 85 e6				ld (os_current_i), hl 
2eda			 
2eda					if DEBUG_FORTH_WORDS 
2eda						DMARK "LPN" 
2eda f5				push af  
2edb 3a ef 2e			ld a, (.dmark)  
2ede 32 7a ee			ld (debug_mark),a  
2ee1 3a f0 2e			ld a, (.dmark+1)  
2ee4 32 7b ee			ld (debug_mark+1),a  
2ee7 3a f1 2e			ld a, (.dmark+2)  
2eea 32 7c ee			ld (debug_mark+2),a  
2eed 18 03			jr .pastdmark  
2eef ..			.dmark: db "LPN"  
2ef2 f1			.pastdmark: pop af  
2ef3			endm  
# End of macro DMARK
2ef3					CALLMONITOR 
2ef3 cd 28 14			call break_point_state  
2ef6				endm  
# End of macro CALLMONITOR
2ef6					endif 
2ef6					 
2ef6				FORTH_LOOP_NEXT 
2ef6 cd dd 1b			call macro_forth_loop_next 
2ef9				endm 
# End of macro FORTH_LOOP_NEXT
2ef9			 
2ef9			 
2ef9					if DEBUG_FORTH_WORDS 
2ef9 eb						ex de,hl 
2efa					endif 
2efa			 
2efa			;	; get DO ptr 
2efa			; 
2efa					if DEBUG_FORTH_WORDS 
2efa						DMARK "LP7" 
2efa f5				push af  
2efb 3a 0f 2f			ld a, (.dmark)  
2efe 32 7a ee			ld (debug_mark),a  
2f01 3a 10 2f			ld a, (.dmark+1)  
2f04 32 7b ee			ld (debug_mark+1),a  
2f07 3a 11 2f			ld a, (.dmark+2)  
2f0a 32 7c ee			ld (debug_mark+2),a  
2f0d 18 03			jr .pastdmark  
2f0f ..			.dmark: db "LP7"  
2f12 f1			.pastdmark: pop af  
2f13			endm  
# End of macro DMARK
2f13					CALLMONITOR 
2f13 cd 28 14			call break_point_state  
2f16				endm  
# End of macro CALLMONITOR
2f16					endif 
2f16				FORTH_RSP_TOS 
2f16 cd 73 19			call macro_forth_rsp_tos 
2f19				endm 
# End of macro FORTH_RSP_TOS
2f19			 
2f19					if DEBUG_FORTH_WORDS 
2f19						DMARK "LP8" 
2f19 f5				push af  
2f1a 3a 2e 2f			ld a, (.dmark)  
2f1d 32 7a ee			ld (debug_mark),a  
2f20 3a 2f 2f			ld a, (.dmark+1)  
2f23 32 7b ee			ld (debug_mark+1),a  
2f26 3a 30 2f			ld a, (.dmark+2)  
2f29 32 7c ee			ld (debug_mark+2),a  
2f2c 18 03			jr .pastdmark  
2f2e ..			.dmark: db "LP8"  
2f31 f1			.pastdmark: pop af  
2f32			endm  
# End of macro DMARK
2f32					CALLMONITOR 
2f32 cd 28 14			call break_point_state  
2f35				endm  
# End of macro CALLMONITOR
2f35					endif 
2f35				;push hl 
2f35			 
2f35				; not going to DO any more 
2f35				; get rid of the RSP pointer as DO will add it back in 
2f35				;FORTH_RSP_POP 
2f35				;pop hl 
2f35			 
2f35				;ld hl,(cli_ret_sp) 
2f35				;ld e, (hl) 
2f35				;inc hl 
2f35				;ld d, (hl) 
2f35				;ex de,hl 
2f35 22 61 e6			ld (os_tok_ptr), hl 
2f38					if DEBUG_FORTH_WORDS 
2f38						DMARK "LP<" 
2f38 f5				push af  
2f39 3a 4d 2f			ld a, (.dmark)  
2f3c 32 7a ee			ld (debug_mark),a  
2f3f 3a 4e 2f			ld a, (.dmark+1)  
2f42 32 7b ee			ld (debug_mark+1),a  
2f45 3a 4f 2f			ld a, (.dmark+2)  
2f48 32 7c ee			ld (debug_mark+2),a  
2f4b 18 03			jr .pastdmark  
2f4d ..			.dmark: db "LP<"  
2f50 f1			.pastdmark: pop af  
2f51			endm  
# End of macro DMARK
2f51					CALLMONITOR 
2f51 cd 28 14			call break_point_state  
2f54				endm  
# End of macro CALLMONITOR
2f54				endif 
2f54 c3 af 1d			jp exec1 
2f57			 
2f57					 
2f57			 
2f57			 
2f57					NEXTW 
2f57 c3 1e 1d			jp macro_next 
2f5a				endm 
# End of macro NEXTW
2f5a			.I:  
2f5a			 
2f5a				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2f5a 5e				db WORD_SYS_CORE+74             
2f5b 85 2f			dw .DLOOP            
2f5d 02				db 1 + 1 
2f5e .. 00			db "I",0              
2f60				endm 
# End of macro CWHEAD
2f60			; | I ( -- ) Current loop counter | DONE 
2f60					if DEBUG_FORTH_WORDS_KEY 
2f60						DMARK "I.." 
2f60 f5				push af  
2f61 3a 75 2f			ld a, (.dmark)  
2f64 32 7a ee			ld (debug_mark),a  
2f67 3a 76 2f			ld a, (.dmark+1)  
2f6a 32 7b ee			ld (debug_mark+1),a  
2f6d 3a 77 2f			ld a, (.dmark+2)  
2f70 32 7c ee			ld (debug_mark+2),a  
2f73 18 03			jr .pastdmark  
2f75 ..			.dmark: db "I.."  
2f78 f1			.pastdmark: pop af  
2f79			endm  
# End of macro DMARK
2f79						CALLMONITOR 
2f79 cd 28 14			call break_point_state  
2f7c				endm  
# End of macro CALLMONITOR
2f7c					endif 
2f7c			 
2f7c 2a 85 e6				ld hl,(os_current_i) 
2f7f cd b5 19				call forth_push_numhl 
2f82			 
2f82					NEXTW 
2f82 c3 1e 1d			jp macro_next 
2f85				endm 
# End of macro NEXTW
2f85			.DLOOP: 
2f85				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2f85 5f				db WORD_SYS_CORE+75             
2f86 66 30			dw .REPEAT            
2f88 06				db 5 + 1 
2f89 .. 00			db "-LOOP",0              
2f8f				endm 
# End of macro CWHEAD
2f8f			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2f8f				; pop tos as current loop count to hl 
2f8f					if DEBUG_FORTH_WORDS_KEY 
2f8f						DMARK "-LP" 
2f8f f5				push af  
2f90 3a a4 2f			ld a, (.dmark)  
2f93 32 7a ee			ld (debug_mark),a  
2f96 3a a5 2f			ld a, (.dmark+1)  
2f99 32 7b ee			ld (debug_mark+1),a  
2f9c 3a a6 2f			ld a, (.dmark+2)  
2f9f 32 7c ee			ld (debug_mark+2),a  
2fa2 18 03			jr .pastdmark  
2fa4 ..			.dmark: db "-LP"  
2fa7 f1			.pastdmark: pop af  
2fa8			endm  
# End of macro DMARK
2fa8						CALLMONITOR 
2fa8 cd 28 14			call break_point_state  
2fab				endm  
# End of macro CALLMONITOR
2fab					endif 
2fab			 
2fab				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2fab			 
2fab				FORTH_LOOP_TOS 
2fab cd 10 1c			call macro_forth_loop_tos 
2fae				endm 
# End of macro FORTH_LOOP_TOS
2fae e5				push hl 
2faf			 
2faf					if DEBUG_FORTH_WORDS 
2faf						DMARK "-LP" 
2faf f5				push af  
2fb0 3a c4 2f			ld a, (.dmark)  
2fb3 32 7a ee			ld (debug_mark),a  
2fb6 3a c5 2f			ld a, (.dmark+1)  
2fb9 32 7b ee			ld (debug_mark+1),a  
2fbc 3a c6 2f			ld a, (.dmark+2)  
2fbf 32 7c ee			ld (debug_mark+2),a  
2fc2 18 03			jr .pastdmark  
2fc4 ..			.dmark: db "-LP"  
2fc7 f1			.pastdmark: pop af  
2fc8			endm  
# End of macro DMARK
2fc8						CALLMONITOR 
2fc8 cd 28 14			call break_point_state  
2fcb				endm  
# End of macro CALLMONITOR
2fcb					endif 
2fcb				; next item on the stack is the limit. get it 
2fcb			 
2fcb			 
2fcb				FORTH_LOOP_POP 
2fcb cd 1a 1c			call macro_forth_loop_pop 
2fce				endm 
# End of macro FORTH_LOOP_POP
2fce			 
2fce				FORTH_LOOP_TOS 
2fce cd 10 1c			call macro_forth_loop_tos 
2fd1				endm 
# End of macro FORTH_LOOP_TOS
2fd1			 
2fd1 d1				pop de		 ; de = i, hl = limit 
2fd2			 
2fd2					if DEBUG_FORTH_WORDS 
2fd2						DMARK "-L1" 
2fd2 f5				push af  
2fd3 3a e7 2f			ld a, (.dmark)  
2fd6 32 7a ee			ld (debug_mark),a  
2fd9 3a e8 2f			ld a, (.dmark+1)  
2fdc 32 7b ee			ld (debug_mark+1),a  
2fdf 3a e9 2f			ld a, (.dmark+2)  
2fe2 32 7c ee			ld (debug_mark+2),a  
2fe5 18 03			jr .pastdmark  
2fe7 ..			.dmark: db "-L1"  
2fea f1			.pastdmark: pop af  
2feb			endm  
# End of macro DMARK
2feb						CALLMONITOR 
2feb cd 28 14			call break_point_state  
2fee				endm  
# End of macro CALLMONITOR
2fee					endif 
2fee			 
2fee				; go back to previous word 
2fee			 
2fee d5				push de    ; save I for inc later 
2fef			 
2fef			 
2fef				; get limit 
2fef				;  is I at limit? 
2fef			 
2fef			 
2fef					if DEBUG_FORTH_WORDS 
2fef						DMARK "-L1" 
2fef f5				push af  
2ff0 3a 04 30			ld a, (.dmark)  
2ff3 32 7a ee			ld (debug_mark),a  
2ff6 3a 05 30			ld a, (.dmark+1)  
2ff9 32 7b ee			ld (debug_mark+1),a  
2ffc 3a 06 30			ld a, (.dmark+2)  
2fff 32 7c ee			ld (debug_mark+2),a  
3002 18 03			jr .pastdmark  
3004 ..			.dmark: db "-L1"  
3007 f1			.pastdmark: pop af  
3008			endm  
# End of macro DMARK
3008						CALLMONITOR 
3008 cd 28 14			call break_point_state  
300b				endm  
# End of macro CALLMONITOR
300b					endif 
300b			 
300b ed 52			sbc hl, de 
300d			 
300d			 
300d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
300d			 
300d 20 26				jr nz, .mloopnotdone 
300f			 
300f e1				pop hl   ; get rid of saved I 
3010				FORTH_LOOP_POP     ; get rid of limit 
3010 cd 1a 1c			call macro_forth_loop_pop 
3013				endm 
# End of macro FORTH_LOOP_POP
3013			 
3013				FORTH_RSP_POP     ; get rid of DO ptr 
3013 cd 7d 19			call macro_forth_rsp_pop 
3016				endm 
# End of macro FORTH_RSP_POP
3016			 
3016			if DEBUG_FORTH_WORDS 
3016						DMARK "-L>" 
3016 f5				push af  
3017 3a 2b 30			ld a, (.dmark)  
301a 32 7a ee			ld (debug_mark),a  
301d 3a 2c 30			ld a, (.dmark+1)  
3020 32 7b ee			ld (debug_mark+1),a  
3023 3a 2d 30			ld a, (.dmark+2)  
3026 32 7c ee			ld (debug_mark+2),a  
3029 18 03			jr .pastdmark  
302b ..			.dmark: db "-L>"  
302e f1			.pastdmark: pop af  
302f			endm  
# End of macro DMARK
302f				CALLMONITOR 
302f cd 28 14			call break_point_state  
3032				endm  
# End of macro CALLMONITOR
3032			endif 
3032			 
3032					NEXTW 
3032 c3 1e 1d			jp macro_next 
3035				endm 
# End of macro NEXTW
3035				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3035			 
3035			.mloopnotdone: 
3035			 
3035 e1				pop hl    ; get I 
3036 2b				dec hl 
3037			 
3037			   	; save new I 
3037			 
3037			 
3037					; set I counter 
3037			 
3037 22 85 e6				ld (os_current_i), hl 
303a			 
303a					 
303a				FORTH_LOOP_NEXT 
303a cd dd 1b			call macro_forth_loop_next 
303d				endm 
# End of macro FORTH_LOOP_NEXT
303d			 
303d			 
303d					if DEBUG_FORTH_WORDS 
303d eb						ex de,hl 
303e					endif 
303e			 
303e			;	; get DO ptr 
303e			; 
303e				FORTH_RSP_TOS 
303e cd 73 19			call macro_forth_rsp_tos 
3041				endm 
# End of macro FORTH_RSP_TOS
3041			 
3041				;push hl 
3041			 
3041				; not going to DO any more 
3041				; get rid of the RSP pointer as DO will add it back in 
3041				;FORTH_RSP_POP 
3041				;pop hl 
3041			 
3041			 
3041 22 61 e6			ld (os_tok_ptr), hl 
3044					if DEBUG_FORTH_WORDS 
3044						DMARK "-L<" 
3044 f5				push af  
3045 3a 59 30			ld a, (.dmark)  
3048 32 7a ee			ld (debug_mark),a  
304b 3a 5a 30			ld a, (.dmark+1)  
304e 32 7b ee			ld (debug_mark+1),a  
3051 3a 5b 30			ld a, (.dmark+2)  
3054 32 7c ee			ld (debug_mark+2),a  
3057 18 03			jr .pastdmark  
3059 ..			.dmark: db "-L<"  
305c f1			.pastdmark: pop af  
305d			endm  
# End of macro DMARK
305d					CALLMONITOR 
305d cd 28 14			call break_point_state  
3060				endm  
# End of macro CALLMONITOR
3060				endif 
3060 c3 af 1d			jp exec1 
3063			 
3063					 
3063			 
3063			 
3063			 
3063				NEXTW 
3063 c3 1e 1d			jp macro_next 
3066				endm 
# End of macro NEXTW
3066			 
3066			 
3066			 
3066			 
3066			.REPEAT: 
3066				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3066 71				db WORD_SYS_CORE+93             
3067 b9 30			dw .UNTIL            
3069 06				db 5 + 1 
306a .. 00			db "REPEAT",0              
3071				endm 
# End of macro CWHEAD
3071			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3071			;  push pc to rsp stack past the REPEAT 
3071					if DEBUG_FORTH_WORDS_KEY 
3071						DMARK "REP" 
3071 f5				push af  
3072 3a 86 30			ld a, (.dmark)  
3075 32 7a ee			ld (debug_mark),a  
3078 3a 87 30			ld a, (.dmark+1)  
307b 32 7b ee			ld (debug_mark+1),a  
307e 3a 88 30			ld a, (.dmark+2)  
3081 32 7c ee			ld (debug_mark+2),a  
3084 18 03			jr .pastdmark  
3086 ..			.dmark: db "REP"  
3089 f1			.pastdmark: pop af  
308a			endm  
# End of macro DMARK
308a						CALLMONITOR 
308a cd 28 14			call break_point_state  
308d				endm  
# End of macro CALLMONITOR
308d					endif 
308d			 
308d 2a 61 e6				ld hl, (os_tok_ptr) 
3090 23					inc hl   ; R 
3091 23					inc hl  ; E 
3092 23					inc hl   ; P 
3093 23					inc hl   ; E 
3094 23					inc hl   ; A 
3095 23					inc hl   ; T 
3096 23					inc hl   ; zero 
3097					FORTH_RSP_NEXT 
3097 cd 5c 19			call macro_forth_rsp_next 
309a				endm 
# End of macro FORTH_RSP_NEXT
309a			 
309a			 
309a					if DEBUG_FORTH_WORDS 
309a						DMARK "REP" 
309a f5				push af  
309b 3a af 30			ld a, (.dmark)  
309e 32 7a ee			ld (debug_mark),a  
30a1 3a b0 30			ld a, (.dmark+1)  
30a4 32 7b ee			ld (debug_mark+1),a  
30a7 3a b1 30			ld a, (.dmark+2)  
30aa 32 7c ee			ld (debug_mark+2),a  
30ad 18 03			jr .pastdmark  
30af ..			.dmark: db "REP"  
30b2 f1			.pastdmark: pop af  
30b3			endm  
# End of macro DMARK
30b3						;pop bc    ; TODO BUG ?????? what is this for???? 
30b3						CALLMONITOR 
30b3 cd 28 14			call break_point_state  
30b6				endm  
# End of macro CALLMONITOR
30b6					endif 
30b6			 
30b6					NEXTW 
30b6 c3 1e 1d			jp macro_next 
30b9				endm 
# End of macro NEXTW
30b9			;	       NEXTW 
30b9			 
30b9			.UNTIL: 
30b9				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
30b9 72				db WORD_SYS_CORE+94             
30ba 50 31			dw .ENDFLOW            
30bc 06				db 5 + 1 
30bd .. 00			db "UNTIL",0              
30c3				endm 
# End of macro CWHEAD
30c3			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
30c3			 
30c3				; pop tos as check 
30c3			 
30c3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
30c3			 
30c3				FORTH_DSP_VALUEHL 
30c3 cd ac 1b			call macro_dsp_valuehl 
30c6				endm 
# End of macro FORTH_DSP_VALUEHL
30c6			 
30c6					if DEBUG_FORTH_WORDS_KEY 
30c6						DMARK "UNT" 
30c6 f5				push af  
30c7 3a db 30			ld a, (.dmark)  
30ca 32 7a ee			ld (debug_mark),a  
30cd 3a dc 30			ld a, (.dmark+1)  
30d0 32 7b ee			ld (debug_mark+1),a  
30d3 3a dd 30			ld a, (.dmark+2)  
30d6 32 7c ee			ld (debug_mark+2),a  
30d9 18 03			jr .pastdmark  
30db ..			.dmark: db "UNT"  
30de f1			.pastdmark: pop af  
30df			endm  
# End of macro DMARK
30df						CALLMONITOR 
30df cd 28 14			call break_point_state  
30e2				endm  
# End of macro CALLMONITOR
30e2					endif 
30e2			 
30e2			;	push hl 
30e2				FORTH_DSP_POP 
30e2 cd 64 1c			call macro_forth_dsp_pop 
30e5				endm 
# End of macro FORTH_DSP_POP
30e5			 
30e5			;	pop hl 
30e5			 
30e5				; test if true 
30e5			 
30e5 cd de 0b			call ishlzero 
30e8			;	ld a,l 
30e8			;	add h 
30e8			; 
30e8			;	cp 0 
30e8			 
30e8 20 3e			jr nz, .untilnotdone 
30ea			 
30ea					if DEBUG_FORTH_WORDS 
30ea						DMARK "UNf" 
30ea f5				push af  
30eb 3a ff 30			ld a, (.dmark)  
30ee 32 7a ee			ld (debug_mark),a  
30f1 3a 00 31			ld a, (.dmark+1)  
30f4 32 7b ee			ld (debug_mark+1),a  
30f7 3a 01 31			ld a, (.dmark+2)  
30fa 32 7c ee			ld (debug_mark+2),a  
30fd 18 03			jr .pastdmark  
30ff ..			.dmark: db "UNf"  
3102 f1			.pastdmark: pop af  
3103			endm  
# End of macro DMARK
3103						CALLMONITOR 
3103 cd 28 14			call break_point_state  
3106				endm  
# End of macro CALLMONITOR
3106					endif 
3106			 
3106			 
3106			 
3106				FORTH_RSP_POP     ; get rid of DO ptr 
3106 cd 7d 19			call macro_forth_rsp_pop 
3109				endm 
# End of macro FORTH_RSP_POP
3109			 
3109			if DEBUG_FORTH_WORDS 
3109						DMARK "UN>" 
3109 f5				push af  
310a 3a 1e 31			ld a, (.dmark)  
310d 32 7a ee			ld (debug_mark),a  
3110 3a 1f 31			ld a, (.dmark+1)  
3113 32 7b ee			ld (debug_mark+1),a  
3116 3a 20 31			ld a, (.dmark+2)  
3119 32 7c ee			ld (debug_mark+2),a  
311c 18 03			jr .pastdmark  
311e ..			.dmark: db "UN>"  
3121 f1			.pastdmark: pop af  
3122			endm  
# End of macro DMARK
3122				CALLMONITOR 
3122 cd 28 14			call break_point_state  
3125				endm  
# End of macro CALLMONITOR
3125			endif 
3125			 
3125					NEXTW 
3125 c3 1e 1d			jp macro_next 
3128				endm 
# End of macro NEXTW
3128				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3128			 
3128			.untilnotdone: 
3128			 
3128			 
3128			;	; get DO ptr 
3128			; 
3128				FORTH_RSP_TOS 
3128 cd 73 19			call macro_forth_rsp_tos 
312b				endm 
# End of macro FORTH_RSP_TOS
312b			 
312b				;push hl 
312b			 
312b				; not going to DO any more 
312b				; get rid of the RSP pointer as DO will add it back in 
312b				;FORTH_RSP_POP 
312b				;pop hl 
312b			 
312b			 
312b 22 61 e6			ld (os_tok_ptr), hl 
312e					if DEBUG_FORTH_WORDS 
312e						DMARK "UN<" 
312e f5				push af  
312f 3a 43 31			ld a, (.dmark)  
3132 32 7a ee			ld (debug_mark),a  
3135 3a 44 31			ld a, (.dmark+1)  
3138 32 7b ee			ld (debug_mark+1),a  
313b 3a 45 31			ld a, (.dmark+2)  
313e 32 7c ee			ld (debug_mark+2),a  
3141 18 03			jr .pastdmark  
3143 ..			.dmark: db "UN<"  
3146 f1			.pastdmark: pop af  
3147			endm  
# End of macro DMARK
3147					CALLMONITOR 
3147 cd 28 14			call break_point_state  
314a				endm  
# End of macro CALLMONITOR
314a				endif 
314a c3 af 1d			jp exec1 
314d			 
314d					 
314d			 
314d			 
314d					NEXTW 
314d c3 1e 1d			jp macro_next 
3150				endm 
# End of macro NEXTW
3150			 
3150			 
3150			.ENDFLOW: 
3150			 
3150			; eof 
3150			 
# End of file forth_words_flow.asm
3150			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3150			include "forth_words_logic.asm" 
3150			 
3150			; | ## Logic Words 
3150			 
3150			.NOT: 
3150				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3150 2d				db WORD_SYS_CORE+25             
3151 98 31			dw .IS            
3153 04				db 3 + 1 
3154 .. 00			db "NOT",0              
3158				endm 
# End of macro CWHEAD
3158			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3158					if DEBUG_FORTH_WORDS_KEY 
3158						DMARK "NOT" 
3158 f5				push af  
3159 3a 6d 31			ld a, (.dmark)  
315c 32 7a ee			ld (debug_mark),a  
315f 3a 6e 31			ld a, (.dmark+1)  
3162 32 7b ee			ld (debug_mark+1),a  
3165 3a 6f 31			ld a, (.dmark+2)  
3168 32 7c ee			ld (debug_mark+2),a  
316b 18 03			jr .pastdmark  
316d ..			.dmark: db "NOT"  
3170 f1			.pastdmark: pop af  
3171			endm  
# End of macro DMARK
3171						CALLMONITOR 
3171 cd 28 14			call break_point_state  
3174				endm  
# End of macro CALLMONITOR
3174					endif 
3174					FORTH_DSP 
3174 cd 72 1b			call macro_forth_dsp 
3177				endm 
# End of macro FORTH_DSP
3177 7e					ld a,(hl)	; get type of value on TOS 
3178 fe 02				cp DS_TYPE_INUM  
317a 28 03				jr z, .noti 
317c					NEXTW 
317c c3 1e 1d			jp macro_next 
317f				endm 
# End of macro NEXTW
317f			.noti:          FORTH_DSP_VALUEHL 
317f cd ac 1b			call macro_dsp_valuehl 
3182				endm 
# End of macro FORTH_DSP_VALUEHL
3182			;		push hl 
3182					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3182 cd 64 1c			call macro_forth_dsp_pop 
3185				endm 
# End of macro FORTH_DSP_POP
3185			;		pop hl 
3185 3e 00				ld a,0 
3187 bd					cp l 
3188 28 04				jr z, .not2t 
318a 2e 00				ld l, 0 
318c 18 02				jr .notip 
318e			 
318e 2e ff		.not2t:		ld l, 255 
3190			 
3190 26 00		.notip:		ld h, 0	 
3192			 
3192 cd b5 19				call forth_push_numhl 
3195					NEXTW 
3195 c3 1e 1d			jp macro_next 
3198				endm 
# End of macro NEXTW
3198			 
3198			.IS: 
3198				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3198 2d				db WORD_SYS_CORE+25             
3199 be 31			dw .LZERO            
319b 03				db 2 + 1 
319c .. 00			db "IS",0              
319f				endm 
# End of macro CWHEAD
319f			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
319f					if DEBUG_FORTH_WORDS_KEY 
319f						DMARK "IS." 
319f f5				push af  
31a0 3a b4 31			ld a, (.dmark)  
31a3 32 7a ee			ld (debug_mark),a  
31a6 3a b5 31			ld a, (.dmark+1)  
31a9 32 7b ee			ld (debug_mark+1),a  
31ac 3a b6 31			ld a, (.dmark+2)  
31af 32 7c ee			ld (debug_mark+2),a  
31b2 18 03			jr .pastdmark  
31b4 ..			.dmark: db "IS."  
31b7 f1			.pastdmark: pop af  
31b8			endm  
# End of macro DMARK
31b8						CALLMONITOR 
31b8 cd 28 14			call break_point_state  
31bb				endm  
# End of macro CALLMONITOR
31bb					endif 
31bb					NEXTW 
31bb c3 1e 1d			jp macro_next 
31be				endm 
# End of macro NEXTW
31be			.LZERO: 
31be				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
31be 2d				db WORD_SYS_CORE+25             
31bf c8 31			dw .TZERO            
31c1 03				db 2 + 1 
31c2 .. 00			db "0<",0              
31c5				endm 
# End of macro CWHEAD
31c5			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
31c5					NEXTW 
31c5 c3 1e 1d			jp macro_next 
31c8				endm 
# End of macro NEXTW
31c8			.TZERO: 
31c8				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
31c8 2e				db WORD_SYS_CORE+26             
31c9 0f 32			dw .LESS            
31cb 03				db 2 + 1 
31cc .. 00			db "0=",0              
31cf				endm 
# End of macro CWHEAD
31cf			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
31cf				; TODO add floating point number detection 
31cf					;v5 FORTH_DSP_VALUE 
31cf					if DEBUG_FORTH_WORDS_KEY 
31cf						DMARK "0=." 
31cf f5				push af  
31d0 3a e4 31			ld a, (.dmark)  
31d3 32 7a ee			ld (debug_mark),a  
31d6 3a e5 31			ld a, (.dmark+1)  
31d9 32 7b ee			ld (debug_mark+1),a  
31dc 3a e6 31			ld a, (.dmark+2)  
31df 32 7c ee			ld (debug_mark+2),a  
31e2 18 03			jr .pastdmark  
31e4 ..			.dmark: db "0=."  
31e7 f1			.pastdmark: pop af  
31e8			endm  
# End of macro DMARK
31e8						CALLMONITOR 
31e8 cd 28 14			call break_point_state  
31eb				endm  
# End of macro CALLMONITOR
31eb					endif 
31eb					FORTH_DSP 
31eb cd 72 1b			call macro_forth_dsp 
31ee				endm 
# End of macro FORTH_DSP
31ee 7e					ld a,(hl)	; get type of value on TOS 
31ef fe 02				cp DS_TYPE_INUM  
31f1 28 00				jr z, .tz_inum 
31f3			 
31f3				if FORTH_ENABLE_FLOATMATH 
31f3					jr .tz_done 
31f3			 
31f3				endif 
31f3					 
31f3			 
31f3			.tz_inum: 
31f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31f3 cd ac 1b			call macro_dsp_valuehl 
31f6				endm 
# End of macro FORTH_DSP_VALUEHL
31f6			 
31f6			;		push hl 
31f6			 
31f6					; destroy value TOS 
31f6			 
31f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31f6 cd 64 1c			call macro_forth_dsp_pop 
31f9				endm 
# End of macro FORTH_DSP_POP
31f9			 
31f9			;		pop hl 
31f9			 
31f9 3e 00				ld a,0 
31fb			 
31fb bd					cp l 
31fc 20 08				jr nz, .tz_notzero 
31fe			 
31fe bc					cp h 
31ff			 
31ff 20 05				jr nz, .tz_notzero 
3201			 
3201			 
3201 21 01 00				ld hl, FORTH_TRUE 
3204 18 03				jr .tz_done 
3206			 
3206 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3209			 
3209					; push value back onto stack for another op etc 
3209			 
3209			.tz_done: 
3209 cd b5 19				call forth_push_numhl 
320c			 
320c					NEXTW 
320c c3 1e 1d			jp macro_next 
320f				endm 
# End of macro NEXTW
320f			.LESS: 
320f				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
320f 2f				db WORD_SYS_CORE+27             
3210 78 32			dw .GT            
3212 02				db 1 + 1 
3213 .. 00			db "<",0              
3215				endm 
# End of macro CWHEAD
3215			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3215				; TODO add floating point number detection 
3215					if DEBUG_FORTH_WORDS_KEY 
3215						DMARK "LES" 
3215 f5				push af  
3216 3a 2a 32			ld a, (.dmark)  
3219 32 7a ee			ld (debug_mark),a  
321c 3a 2b 32			ld a, (.dmark+1)  
321f 32 7b ee			ld (debug_mark+1),a  
3222 3a 2c 32			ld a, (.dmark+2)  
3225 32 7c ee			ld (debug_mark+2),a  
3228 18 03			jr .pastdmark  
322a ..			.dmark: db "LES"  
322d f1			.pastdmark: pop af  
322e			endm  
# End of macro DMARK
322e						CALLMONITOR 
322e cd 28 14			call break_point_state  
3231				endm  
# End of macro CALLMONITOR
3231					endif 
3231					FORTH_DSP 
3231 cd 72 1b			call macro_forth_dsp 
3234				endm 
# End of macro FORTH_DSP
3234					;v5 FORTH_DSP_VALUE 
3234 7e					ld a,(hl)	; get type of value on TOS 
3235 fe 02				cp DS_TYPE_INUM  
3237 28 00				jr z, .less_inum 
3239			 
3239				if FORTH_ENABLE_FLOATMATH 
3239					jr .less_done 
3239			 
3239				endif 
3239					 
3239			 
3239			.less_inum: 
3239					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3239 cd ac 1b			call macro_dsp_valuehl 
323c				endm 
# End of macro FORTH_DSP_VALUEHL
323c			 
323c e5					push hl  ; u2 
323d			 
323d					; destroy value TOS 
323d			 
323d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
323d cd 64 1c			call macro_forth_dsp_pop 
3240				endm 
# End of macro FORTH_DSP_POP
3240			 
3240			 
3240					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3240 cd ac 1b			call macro_dsp_valuehl 
3243				endm 
# End of macro FORTH_DSP_VALUEHL
3243			 
3243 e5					push hl    ; u1 
3244			 
3244					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3244 cd 64 1c			call macro_forth_dsp_pop 
3247				endm 
# End of macro FORTH_DSP_POP
3247			 
3247			 
3247 b7			 or a      ;clear carry flag 
3248 01 00 00		 ld bc, FORTH_FALSE 
324b e1			  pop hl    ; u1 
324c d1			  pop de    ; u2 
324d ed 52		  sbc hl,de 
324f 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3251			 
3251 01 01 00		 ld bc, FORTH_TRUE 
3254			.lscont:  
3254 c5					push bc 
3255 e1					pop hl 
3256			 
3256					if DEBUG_FORTH_WORDS 
3256						DMARK "LT1" 
3256 f5				push af  
3257 3a 6b 32			ld a, (.dmark)  
325a 32 7a ee			ld (debug_mark),a  
325d 3a 6c 32			ld a, (.dmark+1)  
3260 32 7b ee			ld (debug_mark+1),a  
3263 3a 6d 32			ld a, (.dmark+2)  
3266 32 7c ee			ld (debug_mark+2),a  
3269 18 03			jr .pastdmark  
326b ..			.dmark: db "LT1"  
326e f1			.pastdmark: pop af  
326f			endm  
# End of macro DMARK
326f						CALLMONITOR 
326f cd 28 14			call break_point_state  
3272				endm  
# End of macro CALLMONITOR
3272					endif 
3272 cd b5 19				call forth_push_numhl 
3275			 
3275					NEXTW 
3275 c3 1e 1d			jp macro_next 
3278				endm 
# End of macro NEXTW
3278			.GT: 
3278				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3278 30				db WORD_SYS_CORE+28             
3279 e1 32			dw .EQUAL            
327b 02				db 1 + 1 
327c .. 00			db ">",0              
327e				endm 
# End of macro CWHEAD
327e			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
327e				; TODO add floating point number detection 
327e					if DEBUG_FORTH_WORDS_KEY 
327e						DMARK "GRT" 
327e f5				push af  
327f 3a 93 32			ld a, (.dmark)  
3282 32 7a ee			ld (debug_mark),a  
3285 3a 94 32			ld a, (.dmark+1)  
3288 32 7b ee			ld (debug_mark+1),a  
328b 3a 95 32			ld a, (.dmark+2)  
328e 32 7c ee			ld (debug_mark+2),a  
3291 18 03			jr .pastdmark  
3293 ..			.dmark: db "GRT"  
3296 f1			.pastdmark: pop af  
3297			endm  
# End of macro DMARK
3297						CALLMONITOR 
3297 cd 28 14			call break_point_state  
329a				endm  
# End of macro CALLMONITOR
329a					endif 
329a					FORTH_DSP 
329a cd 72 1b			call macro_forth_dsp 
329d				endm 
# End of macro FORTH_DSP
329d					;FORTH_DSP_VALUE 
329d 7e					ld a,(hl)	; get type of value on TOS 
329e fe 02				cp DS_TYPE_INUM  
32a0 28 00				jr z, .gt_inum 
32a2			 
32a2				if FORTH_ENABLE_FLOATMATH 
32a2					jr .gt_done 
32a2			 
32a2				endif 
32a2					 
32a2			 
32a2			.gt_inum: 
32a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32a2 cd ac 1b			call macro_dsp_valuehl 
32a5				endm 
# End of macro FORTH_DSP_VALUEHL
32a5			 
32a5 e5					push hl  ; u2 
32a6			 
32a6					; destroy value TOS 
32a6			 
32a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32a6 cd 64 1c			call macro_forth_dsp_pop 
32a9				endm 
# End of macro FORTH_DSP_POP
32a9			 
32a9			 
32a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32a9 cd ac 1b			call macro_dsp_valuehl 
32ac				endm 
# End of macro FORTH_DSP_VALUEHL
32ac			 
32ac e5					push hl    ; u1 
32ad			 
32ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32ad cd 64 1c			call macro_forth_dsp_pop 
32b0				endm 
# End of macro FORTH_DSP_POP
32b0			 
32b0			 
32b0 b7			 or a      ;clear carry flag 
32b1 01 00 00		 ld bc, FORTH_FALSE 
32b4 e1			  pop hl    ; u1 
32b5 d1			  pop de    ; u2 
32b6 ed 52		  sbc hl,de 
32b8 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
32ba			 
32ba 01 01 00		 ld bc, FORTH_TRUE 
32bd			.gtcont:  
32bd c5					push bc 
32be e1					pop hl 
32bf			 
32bf					if DEBUG_FORTH_WORDS 
32bf						DMARK "GT1" 
32bf f5				push af  
32c0 3a d4 32			ld a, (.dmark)  
32c3 32 7a ee			ld (debug_mark),a  
32c6 3a d5 32			ld a, (.dmark+1)  
32c9 32 7b ee			ld (debug_mark+1),a  
32cc 3a d6 32			ld a, (.dmark+2)  
32cf 32 7c ee			ld (debug_mark+2),a  
32d2 18 03			jr .pastdmark  
32d4 ..			.dmark: db "GT1"  
32d7 f1			.pastdmark: pop af  
32d8			endm  
# End of macro DMARK
32d8						CALLMONITOR 
32d8 cd 28 14			call break_point_state  
32db				endm  
# End of macro CALLMONITOR
32db					endif 
32db cd b5 19				call forth_push_numhl 
32de			 
32de					NEXTW 
32de c3 1e 1d			jp macro_next 
32e1				endm 
# End of macro NEXTW
32e1			.EQUAL: 
32e1				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
32e1 31				db WORD_SYS_CORE+29             
32e2 4c 33			dw .ENDLOGIC            
32e4 02				db 1 + 1 
32e5 .. 00			db "=",0              
32e7				endm 
# End of macro CWHEAD
32e7			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
32e7				; TODO add floating point number detection 
32e7					if DEBUG_FORTH_WORDS_KEY 
32e7						DMARK "EQ." 
32e7 f5				push af  
32e8 3a fc 32			ld a, (.dmark)  
32eb 32 7a ee			ld (debug_mark),a  
32ee 3a fd 32			ld a, (.dmark+1)  
32f1 32 7b ee			ld (debug_mark+1),a  
32f4 3a fe 32			ld a, (.dmark+2)  
32f7 32 7c ee			ld (debug_mark+2),a  
32fa 18 03			jr .pastdmark  
32fc ..			.dmark: db "EQ."  
32ff f1			.pastdmark: pop af  
3300			endm  
# End of macro DMARK
3300						CALLMONITOR 
3300 cd 28 14			call break_point_state  
3303				endm  
# End of macro CALLMONITOR
3303					endif 
3303					FORTH_DSP 
3303 cd 72 1b			call macro_forth_dsp 
3306				endm 
# End of macro FORTH_DSP
3306					;v5 FORTH_DSP_VALUE 
3306 7e					ld a,(hl)	; get type of value on TOS 
3307 fe 02				cp DS_TYPE_INUM  
3309 28 00				jr z, .eq_inum 
330b			 
330b				if FORTH_ENABLE_FLOATMATH 
330b					jr .eq_done 
330b			 
330b				endif 
330b					 
330b			 
330b			.eq_inum: 
330b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
330b cd ac 1b			call macro_dsp_valuehl 
330e				endm 
# End of macro FORTH_DSP_VALUEHL
330e			 
330e e5					push hl 
330f			 
330f					; destroy value TOS 
330f			 
330f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
330f cd 64 1c			call macro_forth_dsp_pop 
3312				endm 
# End of macro FORTH_DSP_POP
3312			 
3312			 
3312					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3312 cd ac 1b			call macro_dsp_valuehl 
3315				endm 
# End of macro FORTH_DSP_VALUEHL
3315			 
3315					; one value on hl get other one back 
3315			 
3315 e5					push hl 
3316			 
3316					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3316 cd 64 1c			call macro_forth_dsp_pop 
3319				endm 
# End of macro FORTH_DSP_POP
3319			 
3319 0e 00				ld c, FORTH_FALSE 
331b			 
331b e1					pop hl 
331c d1					pop de 
331d			 
331d 7b					ld a, e 
331e bd					cp l 
331f			 
331f 20 06				jr nz, .eq_done 
3321			 
3321 7a					ld a, d 
3322 bc					cp h 
3323			 
3323 20 02				jr nz, .eq_done 
3325			 
3325 0e 01				ld c, FORTH_TRUE 
3327					 
3327			 
3327			 
3327			.eq_done: 
3327			 
3327					; TODO push value back onto stack for another op etc 
3327			 
3327 26 00				ld h, 0 
3329 69					ld l, c 
332a					if DEBUG_FORTH_WORDS 
332a						DMARK "EQ1" 
332a f5				push af  
332b 3a 3f 33			ld a, (.dmark)  
332e 32 7a ee			ld (debug_mark),a  
3331 3a 40 33			ld a, (.dmark+1)  
3334 32 7b ee			ld (debug_mark+1),a  
3337 3a 41 33			ld a, (.dmark+2)  
333a 32 7c ee			ld (debug_mark+2),a  
333d 18 03			jr .pastdmark  
333f ..			.dmark: db "EQ1"  
3342 f1			.pastdmark: pop af  
3343			endm  
# End of macro DMARK
3343						CALLMONITOR 
3343 cd 28 14			call break_point_state  
3346				endm  
# End of macro CALLMONITOR
3346					endif 
3346 cd b5 19				call forth_push_numhl 
3349			 
3349					NEXTW 
3349 c3 1e 1d			jp macro_next 
334c				endm 
# End of macro NEXTW
334c			 
334c			 
334c			.ENDLOGIC: 
334c			; eof 
334c			 
334c			 
# End of file forth_words_logic.asm
334c			include "forth_words_maths.asm" 
334c			 
334c			; | ## Maths Words 
334c			 
334c			.PLUS:	 
334c				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
334c 15				db WORD_SYS_CORE+1             
334d 8e 33			dw .NEG            
334f 02				db 1 + 1 
3350 .. 00			db "+",0              
3352				endm 
# End of macro CWHEAD
3352			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3352					if DEBUG_FORTH_WORDS_KEY 
3352						DMARK "PLU" 
3352 f5				push af  
3353 3a 67 33			ld a, (.dmark)  
3356 32 7a ee			ld (debug_mark),a  
3359 3a 68 33			ld a, (.dmark+1)  
335c 32 7b ee			ld (debug_mark+1),a  
335f 3a 69 33			ld a, (.dmark+2)  
3362 32 7c ee			ld (debug_mark+2),a  
3365 18 03			jr .pastdmark  
3367 ..			.dmark: db "PLU"  
336a f1			.pastdmark: pop af  
336b			endm  
# End of macro DMARK
336b						CALLMONITOR 
336b cd 28 14			call break_point_state  
336e				endm  
# End of macro CALLMONITOR
336e					endif 
336e					; add top two values and push back result 
336e			 
336e					;for v5 FORTH_DSP_VALUE 
336e					FORTH_DSP 
336e cd 72 1b			call macro_forth_dsp 
3371				endm 
# End of macro FORTH_DSP
3371 7e					ld a,(hl)	; get type of value on TOS 
3372 fe 02				cp DS_TYPE_INUM  
3374 28 03				jr z, .dot_inum 
3376			 
3376					NEXTW 
3376 c3 1e 1d			jp macro_next 
3379				endm 
# End of macro NEXTW
3379			 
3379			; float maths 
3379			 
3379				if FORTH_ENABLE_FLOATMATH 
3379						inc hl      ; now at start of numeric as string 
3379			 
3379					if DEBUG_FORTH_MATHS 
3379						DMARK "ADD" 
3379				CALLMONITOR 
3379					endif 
3379			 
3379					;ld ix, hl 
3379					call CON 
3379			 
3379			 
3379					push hl 
3379					 
3379					 
3379			 
3379						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3379			 
3379					; get next number 
3379			 
3379						FORTH_DSP_VALUE 
3379			 
3379						inc hl      ; now at start of numeric as string 
3379			 
3379					;ld ix, hl 
3379					call CON 
3379			 
3379					push hl 
3379			 
3379			 
3379						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3379			 
3379						; TODO do add 
3379			 
3379						call IADD 
3379			 
3379						; TODO get result back as ascii 
3379			 
3379						; TODO push result  
3379			 
3379			 
3379			 
3379						jr .dot_done 
3379				endif 
3379			 
3379			.dot_inum: 
3379			 
3379			 
3379					if DEBUG_FORTH_DOT 
3379						DMARK "+IT" 
3379				CALLMONITOR 
3379					endif 
3379			 
3379					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3379 cd ac 1b			call macro_dsp_valuehl 
337c				endm 
# End of macro FORTH_DSP_VALUEHL
337c			 
337c				; TODO add floating point number detection 
337c			 
337c e5					push hl 
337d			 
337d					; destroy value TOS 
337d			 
337d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
337d cd 64 1c			call macro_forth_dsp_pop 
3380				endm 
# End of macro FORTH_DSP_POP
3380			 
3380			 
3380					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3380 cd ac 1b			call macro_dsp_valuehl 
3383				endm 
# End of macro FORTH_DSP_VALUEHL
3383			 
3383					; one value on hl get other one back 
3383			 
3383 d1					pop de 
3384			 
3384					; do the add 
3384			 
3384 19					add hl,de 
3385			 
3385					; save it 
3385			 
3385			;		push hl	 
3385			 
3385					; 
3385			 
3385					; destroy value TOS 
3385			 
3385					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3385 cd 64 1c			call macro_forth_dsp_pop 
3388				endm 
# End of macro FORTH_DSP_POP
3388			 
3388					; TODO push value back onto stack for another op etc 
3388			 
3388			;		pop hl 
3388			 
3388			.dot_done: 
3388 cd b5 19				call forth_push_numhl 
338b			 
338b					NEXTW 
338b c3 1e 1d			jp macro_next 
338e				endm 
# End of macro NEXTW
338e			.NEG: 
338e			 
338e				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
338e 17				db WORD_SYS_CORE+3             
338f d1 33			dw .DIV            
3391 02				db 1 + 1 
3392 .. 00			db "-",0              
3394				endm 
# End of macro CWHEAD
3394			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3394					if DEBUG_FORTH_WORDS_KEY 
3394						DMARK "SUB" 
3394 f5				push af  
3395 3a a9 33			ld a, (.dmark)  
3398 32 7a ee			ld (debug_mark),a  
339b 3a aa 33			ld a, (.dmark+1)  
339e 32 7b ee			ld (debug_mark+1),a  
33a1 3a ab 33			ld a, (.dmark+2)  
33a4 32 7c ee			ld (debug_mark+2),a  
33a7 18 03			jr .pastdmark  
33a9 ..			.dmark: db "SUB"  
33ac f1			.pastdmark: pop af  
33ad			endm  
# End of macro DMARK
33ad						CALLMONITOR 
33ad cd 28 14			call break_point_state  
33b0				endm  
# End of macro CALLMONITOR
33b0					endif 
33b0			 
33b0			 
33b0				; TODO add floating point number detection 
33b0					; v5 FORTH_DSP_VALUE 
33b0					FORTH_DSP 
33b0 cd 72 1b			call macro_forth_dsp 
33b3				endm 
# End of macro FORTH_DSP
33b3 7e					ld a,(hl)	; get type of value on TOS 
33b4 fe 02				cp DS_TYPE_INUM  
33b6 28 03				jr z, .neg_inum 
33b8			 
33b8					NEXTW 
33b8 c3 1e 1d			jp macro_next 
33bb				endm 
# End of macro NEXTW
33bb			 
33bb			; float maths 
33bb			 
33bb				if FORTH_ENABLE_FLOATMATH 
33bb					jr .neg_done 
33bb			 
33bb				endif 
33bb					 
33bb			 
33bb			.neg_inum: 
33bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33bb cd ac 1b			call macro_dsp_valuehl 
33be				endm 
# End of macro FORTH_DSP_VALUEHL
33be			 
33be e5					push hl 
33bf			 
33bf					; destroy value TOS 
33bf			 
33bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33bf cd 64 1c			call macro_forth_dsp_pop 
33c2				endm 
# End of macro FORTH_DSP_POP
33c2			 
33c2			 
33c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33c2 cd ac 1b			call macro_dsp_valuehl 
33c5				endm 
# End of macro FORTH_DSP_VALUEHL
33c5			 
33c5					; one value on hl get other one back 
33c5			 
33c5 d1					pop de 
33c6			 
33c6					; do the sub 
33c6			;		ex de, hl 
33c6			 
33c6 ed 52				sbc hl,de 
33c8			 
33c8					; save it 
33c8			 
33c8			;		push hl	 
33c8			 
33c8					; 
33c8			 
33c8					; destroy value TOS 
33c8			 
33c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33c8 cd 64 1c			call macro_forth_dsp_pop 
33cb				endm 
# End of macro FORTH_DSP_POP
33cb			 
33cb					; TODO push value back onto stack for another op etc 
33cb			 
33cb			;		pop hl 
33cb			 
33cb cd b5 19				call forth_push_numhl 
33ce			.neg_done: 
33ce			 
33ce					NEXTW 
33ce c3 1e 1d			jp macro_next 
33d1				endm 
# End of macro NEXTW
33d1			.DIV: 
33d1				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
33d1 18				db WORD_SYS_CORE+4             
33d2 1e 34			dw .MUL            
33d4 02				db 1 + 1 
33d5 .. 00			db "/",0              
33d7				endm 
# End of macro CWHEAD
33d7			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
33d7					if DEBUG_FORTH_WORDS_KEY 
33d7						DMARK "DIV" 
33d7 f5				push af  
33d8 3a ec 33			ld a, (.dmark)  
33db 32 7a ee			ld (debug_mark),a  
33de 3a ed 33			ld a, (.dmark+1)  
33e1 32 7b ee			ld (debug_mark+1),a  
33e4 3a ee 33			ld a, (.dmark+2)  
33e7 32 7c ee			ld (debug_mark+2),a  
33ea 18 03			jr .pastdmark  
33ec ..			.dmark: db "DIV"  
33ef f1			.pastdmark: pop af  
33f0			endm  
# End of macro DMARK
33f0						CALLMONITOR 
33f0 cd 28 14			call break_point_state  
33f3				endm  
# End of macro CALLMONITOR
33f3					endif 
33f3				; TODO add floating point number detection 
33f3					; v5 FORTH_DSP_VALUE 
33f3					FORTH_DSP 
33f3 cd 72 1b			call macro_forth_dsp 
33f6				endm 
# End of macro FORTH_DSP
33f6 7e					ld a,(hl)	; get type of value on TOS 
33f7 fe 02				cp DS_TYPE_INUM  
33f9 28 03				jr z, .div_inum 
33fb			 
33fb				if FORTH_ENABLE_FLOATMATH 
33fb					jr .div_done 
33fb			 
33fb				endif 
33fb					NEXTW 
33fb c3 1e 1d			jp macro_next 
33fe				endm 
# End of macro NEXTW
33fe			.div_inum: 
33fe			 
33fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33fe cd ac 1b			call macro_dsp_valuehl 
3401				endm 
# End of macro FORTH_DSP_VALUEHL
3401			 
3401 e5					push hl    ; to go to bc 
3402			 
3402					; destroy value TOS 
3402			 
3402					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3402 cd 64 1c			call macro_forth_dsp_pop 
3405				endm 
# End of macro FORTH_DSP_POP
3405			 
3405			 
3405					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3405 cd ac 1b			call macro_dsp_valuehl 
3408				endm 
# End of macro FORTH_DSP_VALUEHL
3408			 
3408					; hl to go to de 
3408			 
3408 e5					push hl 
3409			 
3409 c1					pop bc 
340a d1					pop de		 
340b			 
340b			 
340b					if DEBUG_FORTH_MATHS 
340b						DMARK "DIV" 
340b				CALLMONITOR 
340b					endif 
340b					; one value on hl but move to a get other one back 
340b			 
340b			        
340b cd 12 0b			call Div16 
340e			 
340e			;	push af	 
340e e5				push hl 
340f c5				push bc 
3410			 
3410					if DEBUG_FORTH_MATHS 
3410						DMARK "DI1" 
3410				CALLMONITOR 
3410					endif 
3410			 
3410					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3410 cd 64 1c			call macro_forth_dsp_pop 
3413				endm 
# End of macro FORTH_DSP_POP
3413			 
3413			 
3413			 
3413 e1					pop hl    ; result 
3414			 
3414 cd b5 19				call forth_push_numhl 
3417			 
3417 e1					pop hl    ; reminder 
3418			;		ld h,0 
3418			;		ld l,d 
3418			 
3418 cd b5 19				call forth_push_numhl 
341b			.div_done: 
341b					NEXTW 
341b c3 1e 1d			jp macro_next 
341e				endm 
# End of macro NEXTW
341e			.MUL: 
341e				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
341e 19				db WORD_SYS_CORE+5             
341f 63 34			dw .MIN            
3421 02				db 1 + 1 
3422 .. 00			db "*",0              
3424				endm 
# End of macro CWHEAD
3424			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3424				; TODO add floating point number detection 
3424					if DEBUG_FORTH_WORDS_KEY 
3424						DMARK "MUL" 
3424 f5				push af  
3425 3a 39 34			ld a, (.dmark)  
3428 32 7a ee			ld (debug_mark),a  
342b 3a 3a 34			ld a, (.dmark+1)  
342e 32 7b ee			ld (debug_mark+1),a  
3431 3a 3b 34			ld a, (.dmark+2)  
3434 32 7c ee			ld (debug_mark+2),a  
3437 18 03			jr .pastdmark  
3439 ..			.dmark: db "MUL"  
343c f1			.pastdmark: pop af  
343d			endm  
# End of macro DMARK
343d						CALLMONITOR 
343d cd 28 14			call break_point_state  
3440				endm  
# End of macro CALLMONITOR
3440					endif 
3440					FORTH_DSP 
3440 cd 72 1b			call macro_forth_dsp 
3443				endm 
# End of macro FORTH_DSP
3443					; v5 FORTH_DSP_VALUE 
3443 7e					ld a,(hl)	; get type of value on TOS 
3444 fe 02				cp DS_TYPE_INUM  
3446 28 03				jr z, .mul_inum 
3448			 
3448				if FORTH_ENABLE_FLOATMATH 
3448					jr .mul_done 
3448			 
3448				endif 
3448			 
3448					NEXTW 
3448 c3 1e 1d			jp macro_next 
344b				endm 
# End of macro NEXTW
344b			.mul_inum:	 
344b			 
344b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
344b cd ac 1b			call macro_dsp_valuehl 
344e				endm 
# End of macro FORTH_DSP_VALUEHL
344e			 
344e e5					push hl 
344f			 
344f					; destroy value TOS 
344f			 
344f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
344f cd 64 1c			call macro_forth_dsp_pop 
3452				endm 
# End of macro FORTH_DSP_POP
3452			 
3452			 
3452					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3452 cd ac 1b			call macro_dsp_valuehl 
3455				endm 
# End of macro FORTH_DSP_VALUEHL
3455			 
3455					; one value on hl but move to a get other one back 
3455			 
3455 7d					ld a, l 
3456			 
3456 d1					pop de 
3457			 
3457					; do the mull 
3457			;		ex de, hl 
3457			 
3457 cd 38 0b				call Mult16 
345a					; save it 
345a			 
345a			;		push hl	 
345a			 
345a					; 
345a			 
345a					; destroy value TOS 
345a			 
345a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
345a cd 64 1c			call macro_forth_dsp_pop 
345d				endm 
# End of macro FORTH_DSP_POP
345d			 
345d					; TODO push value back onto stack for another op etc 
345d			 
345d			;		pop hl 
345d			 
345d cd b5 19				call forth_push_numhl 
3460			 
3460			.mul_done: 
3460					NEXTW 
3460 c3 1e 1d			jp macro_next 
3463				endm 
# End of macro NEXTW
3463			 
3463			 
3463			 
3463			 
3463			.MIN: 
3463				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3463 49				db WORD_SYS_CORE+53             
3464 e4 34			dw .MAX            
3466 04				db 3 + 1 
3467 .. 00			db "MIN",0              
346b				endm 
# End of macro CWHEAD
346b			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
346b					if DEBUG_FORTH_WORDS_KEY 
346b						DMARK "MIN" 
346b f5				push af  
346c 3a 80 34			ld a, (.dmark)  
346f 32 7a ee			ld (debug_mark),a  
3472 3a 81 34			ld a, (.dmark+1)  
3475 32 7b ee			ld (debug_mark+1),a  
3478 3a 82 34			ld a, (.dmark+2)  
347b 32 7c ee			ld (debug_mark+2),a  
347e 18 03			jr .pastdmark  
3480 ..			.dmark: db "MIN"  
3483 f1			.pastdmark: pop af  
3484			endm  
# End of macro DMARK
3484						CALLMONITOR 
3484 cd 28 14			call break_point_state  
3487				endm  
# End of macro CALLMONITOR
3487					endif 
3487					; get u2 
3487			 
3487					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3487 cd ac 1b			call macro_dsp_valuehl 
348a				endm 
# End of macro FORTH_DSP_VALUEHL
348a			 
348a e5					push hl   ; u2 
348b			 
348b					; destroy value TOS 
348b			 
348b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
348b cd 64 1c			call macro_forth_dsp_pop 
348e				endm 
# End of macro FORTH_DSP_POP
348e			 
348e					; get u1 
348e			 
348e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
348e cd ac 1b			call macro_dsp_valuehl 
3491				endm 
# End of macro FORTH_DSP_VALUEHL
3491			 
3491 e5					push hl  ; u1 
3492			 
3492					; destroy value TOS 
3492			 
3492					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3492 cd 64 1c			call macro_forth_dsp_pop 
3495				endm 
# End of macro FORTH_DSP_POP
3495			 
3495 b7			 or a      ;clear carry flag 
3496 e1			  pop hl    ; u1 
3497 d1			  pop de    ; u2 
3498 e5				push hl   ; saved in case hl is lowest 
3499 ed 52		  sbc hl,de 
349b 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
349d			 
349d e1				pop hl 
349e					if DEBUG_FORTH_WORDS 
349e						DMARK "MIN" 
349e f5				push af  
349f 3a b3 34			ld a, (.dmark)  
34a2 32 7a ee			ld (debug_mark),a  
34a5 3a b4 34			ld a, (.dmark+1)  
34a8 32 7b ee			ld (debug_mark+1),a  
34ab 3a b5 34			ld a, (.dmark+2)  
34ae 32 7c ee			ld (debug_mark+2),a  
34b1 18 03			jr .pastdmark  
34b3 ..			.dmark: db "MIN"  
34b6 f1			.pastdmark: pop af  
34b7			endm  
# End of macro DMARK
34b7						CALLMONITOR 
34b7 cd 28 14			call break_point_state  
34ba				endm  
# End of macro CALLMONITOR
34ba					endif 
34ba cd b5 19				call forth_push_numhl 
34bd			 
34bd				       NEXTW 
34bd c3 1e 1d			jp macro_next 
34c0				endm 
# End of macro NEXTW
34c0			 
34c0			.mincont:  
34c0 c1				pop bc   ; tidy up 
34c1 eb				ex de , hl  
34c2					if DEBUG_FORTH_WORDS 
34c2						DMARK "MI1" 
34c2 f5				push af  
34c3 3a d7 34			ld a, (.dmark)  
34c6 32 7a ee			ld (debug_mark),a  
34c9 3a d8 34			ld a, (.dmark+1)  
34cc 32 7b ee			ld (debug_mark+1),a  
34cf 3a d9 34			ld a, (.dmark+2)  
34d2 32 7c ee			ld (debug_mark+2),a  
34d5 18 03			jr .pastdmark  
34d7 ..			.dmark: db "MI1"  
34da f1			.pastdmark: pop af  
34db			endm  
# End of macro DMARK
34db						CALLMONITOR 
34db cd 28 14			call break_point_state  
34de				endm  
# End of macro CALLMONITOR
34de					endif 
34de cd b5 19				call forth_push_numhl 
34e1			 
34e1				       NEXTW 
34e1 c3 1e 1d			jp macro_next 
34e4				endm 
# End of macro NEXTW
34e4			.MAX: 
34e4				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
34e4 4a				db WORD_SYS_CORE+54             
34e5 65 35			dw .RND16            
34e7 04				db 3 + 1 
34e8 .. 00			db "MAX",0              
34ec				endm 
# End of macro CWHEAD
34ec			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
34ec					if DEBUG_FORTH_WORDS_KEY 
34ec						DMARK "MAX" 
34ec f5				push af  
34ed 3a 01 35			ld a, (.dmark)  
34f0 32 7a ee			ld (debug_mark),a  
34f3 3a 02 35			ld a, (.dmark+1)  
34f6 32 7b ee			ld (debug_mark+1),a  
34f9 3a 03 35			ld a, (.dmark+2)  
34fc 32 7c ee			ld (debug_mark+2),a  
34ff 18 03			jr .pastdmark  
3501 ..			.dmark: db "MAX"  
3504 f1			.pastdmark: pop af  
3505			endm  
# End of macro DMARK
3505						CALLMONITOR 
3505 cd 28 14			call break_point_state  
3508				endm  
# End of macro CALLMONITOR
3508					endif 
3508					; get u2 
3508			 
3508					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3508 cd ac 1b			call macro_dsp_valuehl 
350b				endm 
# End of macro FORTH_DSP_VALUEHL
350b			 
350b e5					push hl   ; u2 
350c			 
350c					; destroy value TOS 
350c			 
350c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
350c cd 64 1c			call macro_forth_dsp_pop 
350f				endm 
# End of macro FORTH_DSP_POP
350f			 
350f					; get u1 
350f			 
350f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
350f cd ac 1b			call macro_dsp_valuehl 
3512				endm 
# End of macro FORTH_DSP_VALUEHL
3512			 
3512 e5					push hl  ; u1 
3513			 
3513					; destroy value TOS 
3513			 
3513					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3513 cd 64 1c			call macro_forth_dsp_pop 
3516				endm 
# End of macro FORTH_DSP_POP
3516			 
3516 b7			 or a      ;clear carry flag 
3517 e1			  pop hl    ; u1 
3518 d1			  pop de    ; u2 
3519 e5				push hl   ; saved in case hl is lowest 
351a ed 52		  sbc hl,de 
351c 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
351e			 
351e e1				pop hl 
351f					if DEBUG_FORTH_WORDS 
351f						DMARK "MAX" 
351f f5				push af  
3520 3a 34 35			ld a, (.dmark)  
3523 32 7a ee			ld (debug_mark),a  
3526 3a 35 35			ld a, (.dmark+1)  
3529 32 7b ee			ld (debug_mark+1),a  
352c 3a 36 35			ld a, (.dmark+2)  
352f 32 7c ee			ld (debug_mark+2),a  
3532 18 03			jr .pastdmark  
3534 ..			.dmark: db "MAX"  
3537 f1			.pastdmark: pop af  
3538			endm  
# End of macro DMARK
3538						CALLMONITOR 
3538 cd 28 14			call break_point_state  
353b				endm  
# End of macro CALLMONITOR
353b					endif 
353b cd b5 19				call forth_push_numhl 
353e			 
353e				       NEXTW 
353e c3 1e 1d			jp macro_next 
3541				endm 
# End of macro NEXTW
3541			 
3541			.maxcont:  
3541 c1				pop bc   ; tidy up 
3542 eb				ex de , hl  
3543					if DEBUG_FORTH_WORDS 
3543						DMARK "MA1" 
3543 f5				push af  
3544 3a 58 35			ld a, (.dmark)  
3547 32 7a ee			ld (debug_mark),a  
354a 3a 59 35			ld a, (.dmark+1)  
354d 32 7b ee			ld (debug_mark+1),a  
3550 3a 5a 35			ld a, (.dmark+2)  
3553 32 7c ee			ld (debug_mark+2),a  
3556 18 03			jr .pastdmark  
3558 ..			.dmark: db "MA1"  
355b f1			.pastdmark: pop af  
355c			endm  
# End of macro DMARK
355c						CALLMONITOR 
355c cd 28 14			call break_point_state  
355f				endm  
# End of macro CALLMONITOR
355f					endif 
355f cd b5 19				call forth_push_numhl 
3562				       NEXTW 
3562 c3 1e 1d			jp macro_next 
3565				endm 
# End of macro NEXTW
3565			 
3565			.RND16: 
3565				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3565 4e				db WORD_SYS_CORE+58             
3566 94 35			dw .RND8            
3568 06				db 5 + 1 
3569 .. 00			db "RND16",0              
356f				endm 
# End of macro CWHEAD
356f			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
356f					if DEBUG_FORTH_WORDS_KEY 
356f						DMARK "R16" 
356f f5				push af  
3570 3a 84 35			ld a, (.dmark)  
3573 32 7a ee			ld (debug_mark),a  
3576 3a 85 35			ld a, (.dmark+1)  
3579 32 7b ee			ld (debug_mark+1),a  
357c 3a 86 35			ld a, (.dmark+2)  
357f 32 7c ee			ld (debug_mark+2),a  
3582 18 03			jr .pastdmark  
3584 ..			.dmark: db "R16"  
3587 f1			.pastdmark: pop af  
3588			endm  
# End of macro DMARK
3588						CALLMONITOR 
3588 cd 28 14			call break_point_state  
358b				endm  
# End of macro CALLMONITOR
358b					endif 
358b cd dc 0a				call prng16  
358e cd b5 19				call forth_push_numhl 
3591				       NEXTW 
3591 c3 1e 1d			jp macro_next 
3594				endm 
# End of macro NEXTW
3594			.RND8: 
3594				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3594 60				db WORD_SYS_CORE+76             
3595 c9 35			dw .RND            
3597 05				db 4 + 1 
3598 .. 00			db "RND8",0              
359d				endm 
# End of macro CWHEAD
359d			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
359d					if DEBUG_FORTH_WORDS_KEY 
359d						DMARK "RN8" 
359d f5				push af  
359e 3a b2 35			ld a, (.dmark)  
35a1 32 7a ee			ld (debug_mark),a  
35a4 3a b3 35			ld a, (.dmark+1)  
35a7 32 7b ee			ld (debug_mark+1),a  
35aa 3a b4 35			ld a, (.dmark+2)  
35ad 32 7c ee			ld (debug_mark+2),a  
35b0 18 03			jr .pastdmark  
35b2 ..			.dmark: db "RN8"  
35b5 f1			.pastdmark: pop af  
35b6			endm  
# End of macro DMARK
35b6						CALLMONITOR 
35b6 cd 28 14			call break_point_state  
35b9				endm  
# End of macro CALLMONITOR
35b9					endif 
35b9 2a bb eb				ld hl,(xrandc) 
35bc 23					inc hl 
35bd cd f6 0a				call xrnd 
35c0 6f					ld l,a	 
35c1 26 00				ld h,0 
35c3 cd b5 19				call forth_push_numhl 
35c6				       NEXTW 
35c6 c3 1e 1d			jp macro_next 
35c9				endm 
# End of macro NEXTW
35c9			.RND: 
35c9				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
35c9 60				db WORD_SYS_CORE+76             
35ca cf 36			dw .ENDMATHS            
35cc 04				db 3 + 1 
35cd .. 00			db "RND",0              
35d1				endm 
# End of macro CWHEAD
35d1			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
35d1			 
35d1					if DEBUG_FORTH_WORDS_KEY 
35d1						DMARK "RND" 
35d1 f5				push af  
35d2 3a e6 35			ld a, (.dmark)  
35d5 32 7a ee			ld (debug_mark),a  
35d8 3a e7 35			ld a, (.dmark+1)  
35db 32 7b ee			ld (debug_mark+1),a  
35de 3a e8 35			ld a, (.dmark+2)  
35e1 32 7c ee			ld (debug_mark+2),a  
35e4 18 03			jr .pastdmark  
35e6 ..			.dmark: db "RND"  
35e9 f1			.pastdmark: pop af  
35ea			endm  
# End of macro DMARK
35ea						CALLMONITOR 
35ea cd 28 14			call break_point_state  
35ed				endm  
# End of macro CALLMONITOR
35ed					endif 
35ed					 
35ed					FORTH_DSP_VALUEHL    ; upper range 
35ed cd ac 1b			call macro_dsp_valuehl 
35f0				endm 
# End of macro FORTH_DSP_VALUEHL
35f0			 
35f0 22 bf eb				ld (LFSRSeed), hl	 
35f3			 
35f3					if DEBUG_FORTH_WORDS 
35f3						DMARK "RN1" 
35f3 f5				push af  
35f4 3a 08 36			ld a, (.dmark)  
35f7 32 7a ee			ld (debug_mark),a  
35fa 3a 09 36			ld a, (.dmark+1)  
35fd 32 7b ee			ld (debug_mark+1),a  
3600 3a 0a 36			ld a, (.dmark+2)  
3603 32 7c ee			ld (debug_mark+2),a  
3606 18 03			jr .pastdmark  
3608 ..			.dmark: db "RN1"  
360b f1			.pastdmark: pop af  
360c			endm  
# End of macro DMARK
360c						CALLMONITOR 
360c cd 28 14			call break_point_state  
360f				endm  
# End of macro CALLMONITOR
360f					endif 
360f					FORTH_DSP_POP 
360f cd 64 1c			call macro_forth_dsp_pop 
3612				endm 
# End of macro FORTH_DSP_POP
3612			 
3612					FORTH_DSP_VALUEHL    ; low range 
3612 cd ac 1b			call macro_dsp_valuehl 
3615				endm 
# End of macro FORTH_DSP_VALUEHL
3615			 
3615					if DEBUG_FORTH_WORDS 
3615						DMARK "RN2" 
3615 f5				push af  
3616 3a 2a 36			ld a, (.dmark)  
3619 32 7a ee			ld (debug_mark),a  
361c 3a 2b 36			ld a, (.dmark+1)  
361f 32 7b ee			ld (debug_mark+1),a  
3622 3a 2c 36			ld a, (.dmark+2)  
3625 32 7c ee			ld (debug_mark+2),a  
3628 18 03			jr .pastdmark  
362a ..			.dmark: db "RN2"  
362d f1			.pastdmark: pop af  
362e			endm  
# End of macro DMARK
362e						CALLMONITOR 
362e cd 28 14			call break_point_state  
3631				endm  
# End of macro CALLMONITOR
3631					endif 
3631 22 c1 eb				ld (LFSRSeed+2), hl 
3634			 
3634					FORTH_DSP_POP 
3634 cd 64 1c			call macro_forth_dsp_pop 
3637				endm 
# End of macro FORTH_DSP_POP
3637			 
3637 e5					push hl 
3638			 
3638 e1			.inrange:	pop hl 
3639 cd dc 0a				call prng16  
363c					if DEBUG_FORTH_WORDS 
363c						DMARK "RN3" 
363c f5				push af  
363d 3a 51 36			ld a, (.dmark)  
3640 32 7a ee			ld (debug_mark),a  
3643 3a 52 36			ld a, (.dmark+1)  
3646 32 7b ee			ld (debug_mark+1),a  
3649 3a 53 36			ld a, (.dmark+2)  
364c 32 7c ee			ld (debug_mark+2),a  
364f 18 03			jr .pastdmark  
3651 ..			.dmark: db "RN3"  
3654 f1			.pastdmark: pop af  
3655			endm  
# End of macro DMARK
3655						CALLMONITOR 
3655 cd 28 14			call break_point_state  
3658				endm  
# End of macro CALLMONITOR
3658					endif 
3658					 
3658					; if the range is 8bit knock out the high byte 
3658			 
3658 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
365c			 
365c 3e 00				ld a, 0 
365e ba					cp d  
365f 20 1e				jr nz, .hirange 
3661 26 00				ld h, 0   ; knock it down to 8bit 
3663			 
3663					if DEBUG_FORTH_WORDS 
3663						DMARK "RNk" 
3663 f5				push af  
3664 3a 78 36			ld a, (.dmark)  
3667 32 7a ee			ld (debug_mark),a  
366a 3a 79 36			ld a, (.dmark+1)  
366d 32 7b ee			ld (debug_mark+1),a  
3670 3a 7a 36			ld a, (.dmark+2)  
3673 32 7c ee			ld (debug_mark+2),a  
3676 18 03			jr .pastdmark  
3678 ..			.dmark: db "RNk"  
367b f1			.pastdmark: pop af  
367c			endm  
# End of macro DMARK
367c						CALLMONITOR 
367c cd 28 14			call break_point_state  
367f				endm  
# End of macro CALLMONITOR
367f					endif 
367f			.hirange:   
367f e5					push hl  
3680 b7					or a  
3681 ed 52		                sbc hl, de 
3683			 
3683					;call cmp16 
3683			 
3683 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3685 e1					pop hl 
3686 e5					push hl 
3687			 
3687					if DEBUG_FORTH_WORDS 
3687						DMARK "RN4" 
3687 f5				push af  
3688 3a 9c 36			ld a, (.dmark)  
368b 32 7a ee			ld (debug_mark),a  
368e 3a 9d 36			ld a, (.dmark+1)  
3691 32 7b ee			ld (debug_mark+1),a  
3694 3a 9e 36			ld a, (.dmark+2)  
3697 32 7c ee			ld (debug_mark+2),a  
369a 18 03			jr .pastdmark  
369c ..			.dmark: db "RN4"  
369f f1			.pastdmark: pop af  
36a0			endm  
# End of macro DMARK
36a0						CALLMONITOR 
36a0 cd 28 14			call break_point_state  
36a3				endm  
# End of macro CALLMONITOR
36a3					endif 
36a3 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
36a7					;call cmp16 
36a7				 
36a7 b7					or a  
36a8 ed 52		                sbc hl, de 
36aa 38 8c				jr c, .inrange 
36ac			 
36ac e1					pop hl 
36ad					 
36ad					if DEBUG_FORTH_WORDS 
36ad						DMARK "RNd" 
36ad f5				push af  
36ae 3a c2 36			ld a, (.dmark)  
36b1 32 7a ee			ld (debug_mark),a  
36b4 3a c3 36			ld a, (.dmark+1)  
36b7 32 7b ee			ld (debug_mark+1),a  
36ba 3a c4 36			ld a, (.dmark+2)  
36bd 32 7c ee			ld (debug_mark+2),a  
36c0 18 03			jr .pastdmark  
36c2 ..			.dmark: db "RNd"  
36c5 f1			.pastdmark: pop af  
36c6			endm  
# End of macro DMARK
36c6						CALLMONITOR 
36c6 cd 28 14			call break_point_state  
36c9				endm  
# End of macro CALLMONITOR
36c9					endif 
36c9			 
36c9			 
36c9 cd b5 19				call forth_push_numhl 
36cc				       NEXTW 
36cc c3 1e 1d			jp macro_next 
36cf				endm 
# End of macro NEXTW
36cf			 
36cf			.ENDMATHS: 
36cf			 
36cf			; eof 
36cf			 
# End of file forth_words_maths.asm
36cf			include "forth_words_display.asm" 
36cf			 
36cf			; | ## Display Words 
36cf			 
36cf			.ATP: 
36cf				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
36cf 62				db WORD_SYS_CORE+78             
36d0 46 37			dw .FB            
36d2 04				db 3 + 1 
36d3 .. 00			db "AT?",0              
36d7				endm 
# End of macro CWHEAD
36d7			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
36d7					if DEBUG_FORTH_WORDS_KEY 
36d7						DMARK "AT?" 
36d7 f5				push af  
36d8 3a ec 36			ld a, (.dmark)  
36db 32 7a ee			ld (debug_mark),a  
36de 3a ed 36			ld a, (.dmark+1)  
36e1 32 7b ee			ld (debug_mark+1),a  
36e4 3a ee 36			ld a, (.dmark+2)  
36e7 32 7c ee			ld (debug_mark+2),a  
36ea 18 03			jr .pastdmark  
36ec ..			.dmark: db "AT?"  
36ef f1			.pastdmark: pop af  
36f0			endm  
# End of macro DMARK
36f0						CALLMONITOR 
36f0 cd 28 14			call break_point_state  
36f3				endm  
# End of macro CALLMONITOR
36f3					endif 
36f3 3a 49 eb				ld a, (f_cursor_ptr) 
36f6			 
36f6			if DEBUG_FORTH_WORDS 
36f6				DMARK "AT?" 
36f6 f5				push af  
36f7 3a 0b 37			ld a, (.dmark)  
36fa 32 7a ee			ld (debug_mark),a  
36fd 3a 0c 37			ld a, (.dmark+1)  
3700 32 7b ee			ld (debug_mark+1),a  
3703 3a 0d 37			ld a, (.dmark+2)  
3706 32 7c ee			ld (debug_mark+2),a  
3709 18 03			jr .pastdmark  
370b ..			.dmark: db "AT?"  
370e f1			.pastdmark: pop af  
370f			endm  
# End of macro DMARK
370f				CALLMONITOR 
370f cd 28 14			call break_point_state  
3712				endm  
# End of macro CALLMONITOR
3712			endif	 
3712					; count the number of rows 
3712			 
3712 06 00				ld b, 0 
3714 4f			.atpr:		ld c, a    ; save in case we go below zero 
3715 d6 28				sub display_cols 
3717 f2 1d 37				jp p, .atprunder 
371a 04					inc b 
371b 18 f7				jr .atpr 
371d			.atprunder:	 
371d			if DEBUG_FORTH_WORDS 
371d				DMARK "A?2" 
371d f5				push af  
371e 3a 32 37			ld a, (.dmark)  
3721 32 7a ee			ld (debug_mark),a  
3724 3a 33 37			ld a, (.dmark+1)  
3727 32 7b ee			ld (debug_mark+1),a  
372a 3a 34 37			ld a, (.dmark+2)  
372d 32 7c ee			ld (debug_mark+2),a  
3730 18 03			jr .pastdmark  
3732 ..			.dmark: db "A?2"  
3735 f1			.pastdmark: pop af  
3736			endm  
# End of macro DMARK
3736				CALLMONITOR 
3736 cd 28 14			call break_point_state  
3739				endm  
# End of macro CALLMONITOR
3739			endif	 
3739 26 00				ld h, 0 
373b 69					ld l, c 
373c cd b5 19				call forth_push_numhl 
373f 68					ld l, b  
3740 cd b5 19				call forth_push_numhl 
3743			 
3743			 
3743				NEXTW 
3743 c3 1e 1d			jp macro_next 
3746				endm 
# End of macro NEXTW
3746			 
3746			.FB: 
3746				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3746 1b				db WORD_SYS_CORE+7             
3747 94 37			dw .EMIT            
3749 03				db 2 + 1 
374a .. 00			db "FB",0              
374d				endm 
# End of macro CWHEAD
374d			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
374d			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
374d			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
374d			; | | If automatic display is off then updates will not be shown until DRAW is used. 
374d					if DEBUG_FORTH_WORDS_KEY 
374d						DMARK "FB." 
374d f5				push af  
374e 3a 62 37			ld a, (.dmark)  
3751 32 7a ee			ld (debug_mark),a  
3754 3a 63 37			ld a, (.dmark+1)  
3757 32 7b ee			ld (debug_mark+1),a  
375a 3a 64 37			ld a, (.dmark+2)  
375d 32 7c ee			ld (debug_mark+2),a  
3760 18 03			jr .pastdmark  
3762 ..			.dmark: db "FB."  
3765 f1			.pastdmark: pop af  
3766			endm  
# End of macro DMARK
3766						CALLMONITOR 
3766 cd 28 14			call break_point_state  
3769				endm  
# End of macro CALLMONITOR
3769					endif 
3769			 
3769					FORTH_DSP_VALUEHL 
3769 cd ac 1b			call macro_dsp_valuehl 
376c				endm 
# End of macro FORTH_DSP_VALUEHL
376c			 
376c 7d					ld a, l 
376d fe 01				cp 1 
376f 20 05				jr nz, .fbn1 
3771 21 1f ed				ld hl, display_fb1 
3774 18 15				jr .fbset 
3776 fe 02		.fbn1:		cp 2 
3778 20 05				jr nz, .fbn2 
377a 21 dd eb				ld hl, display_fb2 
377d 18 0c				jr .fbset 
377f fe 03		.fbn2:		cp 3 
3781 20 05				jr nz, .fbn3 
3783 21 7e ec				ld hl, display_fb3 
3786 18 03				jr .fbset 
3788			.fbn3:		 ; if invalid number select first 
3788 21 1f ed				ld hl, display_fb1 
378b 22 db eb		.fbset:		ld (display_fb_active), hl 
378e			 
378e					FORTH_DSP_POP 
378e cd 64 1c			call macro_forth_dsp_pop 
3791				endm 
# End of macro FORTH_DSP_POP
3791			 
3791					NEXTW 
3791 c3 1e 1d			jp macro_next 
3794				endm 
# End of macro NEXTW
3794			 
3794			 
3794			.EMIT: 
3794				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3794 1b				db WORD_SYS_CORE+7             
3795 e5 37			dw .DOTH            
3797 05				db 4 + 1 
3798 .. 00			db "EMIT",0              
379d				endm 
# End of macro CWHEAD
379d			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
379d					; get value off TOS and display it 
379d			 
379d					if DEBUG_FORTH_WORDS_KEY 
379d						DMARK "EMT" 
379d f5				push af  
379e 3a b2 37			ld a, (.dmark)  
37a1 32 7a ee			ld (debug_mark),a  
37a4 3a b3 37			ld a, (.dmark+1)  
37a7 32 7b ee			ld (debug_mark+1),a  
37aa 3a b4 37			ld a, (.dmark+2)  
37ad 32 7c ee			ld (debug_mark+2),a  
37b0 18 03			jr .pastdmark  
37b2 ..			.dmark: db "EMT"  
37b5 f1			.pastdmark: pop af  
37b6			endm  
# End of macro DMARK
37b6						CALLMONITOR 
37b6 cd 28 14			call break_point_state  
37b9				endm  
# End of macro CALLMONITOR
37b9					endif 
37b9			 
37b9					FORTH_DSP_VALUEHL 
37b9 cd ac 1b			call macro_dsp_valuehl 
37bc				endm 
# End of macro FORTH_DSP_VALUEHL
37bc			 
37bc 7d					ld a,l 
37bd			 
37bd					; TODO write to display 
37bd			 
37bd 32 5e e5				ld (os_input), a 
37c0 3e 00				ld a, 0 
37c2 32 5f e5				ld (os_input+1), a 
37c5					 
37c5 3a 49 eb				ld a, (f_cursor_ptr) 
37c8 11 5e e5				ld de, os_input 
37cb cd 9b 09				call str_at_display 
37ce			 
37ce			 
37ce 3a 27 eb				ld a,(cli_autodisplay) 
37d1 fe 00				cp 0 
37d3 28 03				jr z, .enoupdate 
37d5 cd ab 09						call update_display 
37d8					.enoupdate: 
37d8			 
37d8 3a 49 eb				ld a, (f_cursor_ptr) 
37db 3c					inc a 
37dc 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
37df			 
37df			 
37df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37df cd 64 1c			call macro_forth_dsp_pop 
37e2				endm 
# End of macro FORTH_DSP_POP
37e2			  
37e2			 
37e2					NEXTW 
37e2 c3 1e 1d			jp macro_next 
37e5				endm 
# End of macro NEXTW
37e5			.DOTH: 
37e5				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
37e5 1c				db WORD_SYS_CORE+8             
37e6 15 38			dw .DOTF            
37e8 03				db 2 + 1 
37e9 .. 00			db ".-",0              
37ec				endm 
# End of macro CWHEAD
37ec			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
37ec					; get value off TOS and display it 
37ec					if DEBUG_FORTH_WORDS_KEY 
37ec						DMARK "DTD" 
37ec f5				push af  
37ed 3a 01 38			ld a, (.dmark)  
37f0 32 7a ee			ld (debug_mark),a  
37f3 3a 02 38			ld a, (.dmark+1)  
37f6 32 7b ee			ld (debug_mark+1),a  
37f9 3a 03 38			ld a, (.dmark+2)  
37fc 32 7c ee			ld (debug_mark+2),a  
37ff 18 03			jr .pastdmark  
3801 ..			.dmark: db "DTD"  
3804 f1			.pastdmark: pop af  
3805			endm  
# End of macro DMARK
3805						CALLMONITOR 
3805 cd 28 14			call break_point_state  
3808				endm  
# End of macro CALLMONITOR
3808					endif 
3808 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
380a 3e 00			ld a, 0 
380c 32 28 eb			ld (cli_mvdot), a 
380f c3 6c 38			jp .dotgo 
3812				NEXTW 
3812 c3 1e 1d			jp macro_next 
3815				endm 
# End of macro NEXTW
3815			.DOTF: 
3815				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3815 1c				db WORD_SYS_CORE+8             
3816 43 38			dw .DOT            
3818 03				db 2 + 1 
3819 .. 00			db ".>",0              
381c				endm 
# End of macro CWHEAD
381c			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
381c					; get value off TOS and display it 
381c			        ; TODO BUG adds extra spaces 
381c			        ; TODO BUG handle numerics? 
381c					if DEBUG_FORTH_WORDS_KEY 
381c						DMARK "DTC" 
381c f5				push af  
381d 3a 31 38			ld a, (.dmark)  
3820 32 7a ee			ld (debug_mark),a  
3823 3a 32 38			ld a, (.dmark+1)  
3826 32 7b ee			ld (debug_mark+1),a  
3829 3a 33 38			ld a, (.dmark+2)  
382c 32 7c ee			ld (debug_mark+2),a  
382f 18 03			jr .pastdmark  
3831 ..			.dmark: db "DTC"  
3834 f1			.pastdmark: pop af  
3835			endm  
# End of macro DMARK
3835						CALLMONITOR 
3835 cd 28 14			call break_point_state  
3838				endm  
# End of macro CALLMONITOR
3838					endif 
3838 3e 01			ld a, 1 
383a 32 28 eb			ld (cli_mvdot), a 
383d c3 6c 38			jp .dotgo 
3840				NEXTW 
3840 c3 1e 1d			jp macro_next 
3843				endm 
# End of macro NEXTW
3843			 
3843			.DOT: 
3843				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3843 1c				db WORD_SYS_CORE+8             
3844 cf 38			dw .CLS            
3846 02				db 1 + 1 
3847 .. 00			db ".",0              
3849				endm 
# End of macro CWHEAD
3849			        ; | . ( u -- ) Display TOS | DONE 
3849					; get value off TOS and display it 
3849			 
3849					if DEBUG_FORTH_WORDS_KEY 
3849						DMARK "DOT" 
3849 f5				push af  
384a 3a 5e 38			ld a, (.dmark)  
384d 32 7a ee			ld (debug_mark),a  
3850 3a 5f 38			ld a, (.dmark+1)  
3853 32 7b ee			ld (debug_mark+1),a  
3856 3a 60 38			ld a, (.dmark+2)  
3859 32 7c ee			ld (debug_mark+2),a  
385c 18 03			jr .pastdmark  
385e ..			.dmark: db "DOT"  
3861 f1			.pastdmark: pop af  
3862			endm  
# End of macro DMARK
3862						CALLMONITOR 
3862 cd 28 14			call break_point_state  
3865				endm  
# End of macro CALLMONITOR
3865					endif 
3865 3e 00			ld a, 0 
3867 32 28 eb			ld (cli_mvdot), a 
386a 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
386c				 
386c			 
386c			.dotgo: 
386c			 
386c			; move up type to on stack for parserv5 
386c					FORTH_DSP 
386c cd 72 1b			call macro_forth_dsp 
386f				endm 
# End of macro FORTH_DSP
386f				;FORTH_DSP_VALUE  
386f			 
386f			if DEBUG_FORTH_DOT 
386f				DMARK "DOT" 
386f				CALLMONITOR 
386f			endif	 
386f			;		.print: 
386f			 
386f 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3870 23				inc hl   ; position to the actual value 
3871 fe 01			cp DS_TYPE_STR 
3873 20 06			jr nz, .dotnum1  
3875			 
3875			; display string 
3875				FORTH_DSP_VALUE  
3875 cd 95 1b			call macro_forth_dsp_value 
3878				endm 
# End of macro FORTH_DSP_VALUE
3878 eb				ex de,hl 
3879 18 11			jr .dotwrite 
387b			 
387b			.dotnum1: 
387b fe 02			cp DS_TYPE_INUM 
387d 20 0c			jr nz, .dotflot 
387f			 
387f			 
387f			; display number 
387f			 
387f			;	push hl 
387f			;	call clear_display 
387f			;	pop hl 
387f			 
387f 5e				ld e, (hl) 
3880 23				inc hl 
3881 56				ld d, (hl) 
3882 21 60 e3			ld hl, scratch 
3885			if DEBUG_FORTH_DOT 
3885				DMARK "DT1" 
3885				CALLMONITOR 
3885			endif	 
3885			 
3885 cd c2 0f			call uitoa_16 
3888 eb				ex de,hl 
3889			 
3889			if DEBUG_FORTH_DOT 
3889				DMARK "DT2" 
3889				CALLMONITOR 
3889			endif	 
3889			 
3889			;	ld de, os_word_scratch 
3889 18 01			jr .dotwrite 
388b			 
388b 00			.dotflot:   nop 
388c			; TODO print floating point number 
388c			 
388c			.dotwrite:		 
388c			 
388c					; if c is set then set all '-' to spaces 
388c					; need to also take into account .>  
388c			 
388c 3e 01				ld a, 1 
388e b9					cp c 
388f 20 13				jr nz, .nodashswap 
3891			 
3891					; DE has the string to write, working with HL 
3891			 
3891 06 ff				ld b, 255 
3893 d5					push de 
3894 e1					pop hl 
3895			 
3895			if DEBUG_FORTH_DOT 
3895				DMARK "DT-" 
3895				CALLMONITOR 
3895			endif	 
3895 7e			.dashscan:	ld a, (hl) 
3896 fe 00				cp 0 
3898 28 0a				jr z, .nodashswap 
389a fe 2d				cp '-' 
389c 20 03				jr nz, .dashskip 
389e 3e 20				ld a, ' ' 
38a0 77					ld (hl), a 
38a1 23			.dashskip:	inc hl 
38a2			if DEBUG_FORTH_DOT 
38a2				DMARK "D-2" 
38a2				CALLMONITOR 
38a2			endif	 
38a2 10 f1				djnz .dashscan 
38a4			 
38a4			if DEBUG_FORTH_DOT 
38a4				DMARK "D-1" 
38a4				CALLMONITOR 
38a4			endif	 
38a4			 
38a4			.nodashswap: 
38a4			 
38a4 e5					push hl   ; save string start in case we need to advance print 
38a5			 
38a5 3a 49 eb				ld a, (f_cursor_ptr) 
38a8 cd 9b 09				call str_at_display 
38ab 3a 27 eb				ld a,(cli_autodisplay) 
38ae fe 00				cp 0 
38b0 28 03				jr z, .noupdate 
38b2 cd ab 09						call update_display 
38b5					.noupdate: 
38b5			 
38b5			 
38b5					; see if we need to advance the print position 
38b5			 
38b5 e1					pop hl   ; get back string 
38b6			 
38b6 3a 28 eb				ld a, (cli_mvdot) 
38b9			if DEBUG_FORTH_DOT 
38b9					ld e,a 
38b9				DMARK "D>1" 
38b9				CALLMONITOR 
38b9			endif	 
38b9 fe 00				cp 0 
38bb 28 0c				jr z, .noadv 
38bd					; yes, lets advance the print position 
38bd 3e 00				ld a, 0 
38bf cd 1e 10				call strlent 
38c2 3a 49 eb				ld a, (f_cursor_ptr) 
38c5 85					add a,l 
38c6					;call addatohl 
38c6					;ld a, l 
38c6 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
38c9			 
38c9			if DEBUG_FORTH_DOT 
38c9				DMARK "D->" 
38c9				CALLMONITOR 
38c9			endif	 
38c9			 
38c9			.noadv:	 
38c9			 
38c9					if DEBUG_FORTH_DOT_WAIT 
38c9							call next_page_prompt 
38c9					endif	 
38c9			; TODO this pop off the stack causes a crash. i dont know why 
38c9			 
38c9			 
38c9			if DEBUG_FORTH_DOT 
38c9				DMARK "DTh" 
38c9				CALLMONITOR 
38c9			endif	 
38c9			 
38c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c9 cd 64 1c			call macro_forth_dsp_pop 
38cc				endm 
# End of macro FORTH_DSP_POP
38cc			 
38cc			if DEBUG_FORTH_DOT 
38cc				DMARK "DTi" 
38cc				CALLMONITOR 
38cc			endif	 
38cc			 
38cc			 
38cc					NEXTW 
38cc c3 1e 1d			jp macro_next 
38cf				endm 
# End of macro NEXTW
38cf			 
38cf			.CLS: 
38cf				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
38cf 35				db WORD_SYS_CORE+33             
38d0 fc 38			dw .DRAW            
38d2 04				db 3 + 1 
38d3 .. 00			db "CLS",0              
38d7				endm 
# End of macro CWHEAD
38d7			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
38d7					if DEBUG_FORTH_WORDS_KEY 
38d7						DMARK "CLS" 
38d7 f5				push af  
38d8 3a ec 38			ld a, (.dmark)  
38db 32 7a ee			ld (debug_mark),a  
38de 3a ed 38			ld a, (.dmark+1)  
38e1 32 7b ee			ld (debug_mark+1),a  
38e4 3a ee 38			ld a, (.dmark+2)  
38e7 32 7c ee			ld (debug_mark+2),a  
38ea 18 03			jr .pastdmark  
38ec ..			.dmark: db "CLS"  
38ef f1			.pastdmark: pop af  
38f0			endm  
# End of macro DMARK
38f0						CALLMONITOR 
38f0 cd 28 14			call break_point_state  
38f3				endm  
# End of macro CALLMONITOR
38f3					endif 
38f3 cd 88 09				call clear_display 
38f6 c3 0a 3a				jp .home		; and home cursor 
38f9					NEXTW 
38f9 c3 1e 1d			jp macro_next 
38fc				endm 
# End of macro NEXTW
38fc			 
38fc			.DRAW: 
38fc				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
38fc 36				db WORD_SYS_CORE+34             
38fd 27 39			dw .DUMP            
38ff 05				db 4 + 1 
3900 .. 00			db "DRAW",0              
3905				endm 
# End of macro CWHEAD
3905			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3905					if DEBUG_FORTH_WORDS_KEY 
3905						DMARK "DRW" 
3905 f5				push af  
3906 3a 1a 39			ld a, (.dmark)  
3909 32 7a ee			ld (debug_mark),a  
390c 3a 1b 39			ld a, (.dmark+1)  
390f 32 7b ee			ld (debug_mark+1),a  
3912 3a 1c 39			ld a, (.dmark+2)  
3915 32 7c ee			ld (debug_mark+2),a  
3918 18 03			jr .pastdmark  
391a ..			.dmark: db "DRW"  
391d f1			.pastdmark: pop af  
391e			endm  
# End of macro DMARK
391e						CALLMONITOR 
391e cd 28 14			call break_point_state  
3921				endm  
# End of macro CALLMONITOR
3921					endif 
3921 cd ab 09				call update_display 
3924					NEXTW 
3924 c3 1e 1d			jp macro_next 
3927				endm 
# End of macro NEXTW
3927			 
3927			.DUMP: 
3927				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3927 37				db WORD_SYS_CORE+35             
3928 5f 39			dw .CDUMP            
392a 05				db 4 + 1 
392b .. 00			db "DUMP",0              
3930				endm 
# End of macro CWHEAD
3930			; | DUMP ( x -- ) With address x display dump   | DONE 
3930			; TODO pop address to use off of the stack 
3930					if DEBUG_FORTH_WORDS_KEY 
3930						DMARK "DUM" 
3930 f5				push af  
3931 3a 45 39			ld a, (.dmark)  
3934 32 7a ee			ld (debug_mark),a  
3937 3a 46 39			ld a, (.dmark+1)  
393a 32 7b ee			ld (debug_mark+1),a  
393d 3a 47 39			ld a, (.dmark+2)  
3940 32 7c ee			ld (debug_mark+2),a  
3943 18 03			jr .pastdmark  
3945 ..			.dmark: db "DUM"  
3948 f1			.pastdmark: pop af  
3949			endm  
# End of macro DMARK
3949						CALLMONITOR 
3949 cd 28 14			call break_point_state  
394c				endm  
# End of macro CALLMONITOR
394c					endif 
394c cd 88 09				call clear_display 
394f			 
394f					; get address 
394f			 
394f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
394f cd ac 1b			call macro_dsp_valuehl 
3952				endm 
# End of macro FORTH_DSP_VALUEHL
3952				 
3952					; save it for cdump 
3952			 
3952 22 83 e6				ld (os_cur_ptr),hl 
3955			 
3955					; destroy value TOS 
3955			 
3955					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3955 cd 64 1c			call macro_forth_dsp_pop 
3958				endm 
# End of macro FORTH_DSP_POP
3958			 
3958 cd 35 18				call dumpcont	; skip old style of param parsing	 
395b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
395c					NEXTW 
395c c3 1e 1d			jp macro_next 
395f				endm 
# End of macro NEXTW
395f			.CDUMP: 
395f				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
395f 38				db WORD_SYS_CORE+36             
3960 8f 39			dw .DAT            
3962 06				db 5 + 1 
3963 .. 00			db "CDUMP",0              
3969				endm 
# End of macro CWHEAD
3969			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3969					if DEBUG_FORTH_WORDS_KEY 
3969						DMARK "CDP" 
3969 f5				push af  
396a 3a 7e 39			ld a, (.dmark)  
396d 32 7a ee			ld (debug_mark),a  
3970 3a 7f 39			ld a, (.dmark+1)  
3973 32 7b ee			ld (debug_mark+1),a  
3976 3a 80 39			ld a, (.dmark+2)  
3979 32 7c ee			ld (debug_mark+2),a  
397c 18 03			jr .pastdmark  
397e ..			.dmark: db "CDP"  
3981 f1			.pastdmark: pop af  
3982			endm  
# End of macro DMARK
3982						CALLMONITOR 
3982 cd 28 14			call break_point_state  
3985				endm  
# End of macro CALLMONITOR
3985					endif 
3985 cd 88 09				call clear_display 
3988 cd 35 18				call dumpcont	 
398b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
398c					NEXTW 
398c c3 1e 1d			jp macro_next 
398f				endm 
# End of macro NEXTW
398f			 
398f			 
398f			 
398f			 
398f			.DAT: 
398f				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
398f 3d				db WORD_SYS_CORE+41             
3990 e5 39			dw .HOME            
3992 03				db 2 + 1 
3993 .. 00			db "AT",0              
3996				endm 
# End of macro CWHEAD
3996			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3996					if DEBUG_FORTH_WORDS_KEY 
3996						DMARK "AT." 
3996 f5				push af  
3997 3a ab 39			ld a, (.dmark)  
399a 32 7a ee			ld (debug_mark),a  
399d 3a ac 39			ld a, (.dmark+1)  
39a0 32 7b ee			ld (debug_mark+1),a  
39a3 3a ad 39			ld a, (.dmark+2)  
39a6 32 7c ee			ld (debug_mark+2),a  
39a9 18 03			jr .pastdmark  
39ab ..			.dmark: db "AT."  
39ae f1			.pastdmark: pop af  
39af			endm  
# End of macro DMARK
39af						CALLMONITOR 
39af cd 28 14			call break_point_state  
39b2				endm  
# End of macro CALLMONITOR
39b2					endif 
39b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b2 cd ac 1b			call macro_dsp_valuehl 
39b5				endm 
# End of macro FORTH_DSP_VALUEHL
39b5			 
39b5			 
39b5					; TODO save cursor row 
39b5 7d					ld a,l 
39b6 fe 02				cp 2 
39b8 20 04				jr nz, .crow3 
39ba 3e 28				ld a, display_row_2 
39bc 18 12				jr .ccol1 
39be fe 03		.crow3:		cp 3 
39c0 20 04				jr nz, .crow4 
39c2 3e 50				ld a, display_row_3 
39c4 18 0a				jr .ccol1 
39c6 fe 04		.crow4:		cp 4 
39c8 20 04				jr nz, .crow1 
39ca 3e 78				ld a, display_row_4 
39cc 18 02				jr .ccol1 
39ce 3e 00		.crow1:		ld a,display_row_1 
39d0 f5			.ccol1:		push af			; got row offset 
39d1 6f					ld l,a 
39d2 26 00				ld h,0 
39d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39d4 cd 64 1c			call macro_forth_dsp_pop 
39d7				endm 
# End of macro FORTH_DSP_POP
39d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39d7 cd ac 1b			call macro_dsp_valuehl 
39da				endm 
# End of macro FORTH_DSP_VALUEHL
39da					; TODO save cursor col 
39da f1					pop af 
39db 85					add l		; add col offset 
39dc 32 49 eb				ld (f_cursor_ptr), a 
39df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39df cd 64 1c			call macro_forth_dsp_pop 
39e2				endm 
# End of macro FORTH_DSP_POP
39e2			 
39e2					; calculate  
39e2			 
39e2					NEXTW 
39e2 c3 1e 1d			jp macro_next 
39e5				endm 
# End of macro NEXTW
39e5			 
39e5			 
39e5			.HOME: 
39e5				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
39e5 41				db WORD_SYS_CORE+45             
39e6 12 3a			dw .SPACE            
39e8 05				db 4 + 1 
39e9 .. 00			db "HOME",0              
39ee				endm 
# End of macro CWHEAD
39ee			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
39ee					if DEBUG_FORTH_WORDS_KEY 
39ee						DMARK "HOM" 
39ee f5				push af  
39ef 3a 03 3a			ld a, (.dmark)  
39f2 32 7a ee			ld (debug_mark),a  
39f5 3a 04 3a			ld a, (.dmark+1)  
39f8 32 7b ee			ld (debug_mark+1),a  
39fb 3a 05 3a			ld a, (.dmark+2)  
39fe 32 7c ee			ld (debug_mark+2),a  
3a01 18 03			jr .pastdmark  
3a03 ..			.dmark: db "HOM"  
3a06 f1			.pastdmark: pop af  
3a07			endm  
# End of macro DMARK
3a07						CALLMONITOR 
3a07 cd 28 14			call break_point_state  
3a0a				endm  
# End of macro CALLMONITOR
3a0a					endif 
3a0a 3e 00		.home:		ld a, 0		; and home cursor 
3a0c 32 49 eb				ld (f_cursor_ptr), a 
3a0f					NEXTW 
3a0f c3 1e 1d			jp macro_next 
3a12				endm 
# End of macro NEXTW
3a12			 
3a12			 
3a12			.SPACE: 
3a12				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3a12 46				db WORD_SYS_CORE+50             
3a13 40 3a			dw .SPACES            
3a15 03				db 2 + 1 
3a16 .. 00			db "BL",0              
3a19				endm 
# End of macro CWHEAD
3a19			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3a19					if DEBUG_FORTH_WORDS_KEY 
3a19						DMARK "BL." 
3a19 f5				push af  
3a1a 3a 2e 3a			ld a, (.dmark)  
3a1d 32 7a ee			ld (debug_mark),a  
3a20 3a 2f 3a			ld a, (.dmark+1)  
3a23 32 7b ee			ld (debug_mark+1),a  
3a26 3a 30 3a			ld a, (.dmark+2)  
3a29 32 7c ee			ld (debug_mark+2),a  
3a2c 18 03			jr .pastdmark  
3a2e ..			.dmark: db "BL."  
3a31 f1			.pastdmark: pop af  
3a32			endm  
# End of macro DMARK
3a32						CALLMONITOR 
3a32 cd 28 14			call break_point_state  
3a35				endm  
# End of macro CALLMONITOR
3a35					endif 
3a35 21 3e 3a				ld hl, .blstr 
3a38 cd 23 1a				call forth_push_str 
3a3b					 
3a3b				       NEXTW 
3a3b c3 1e 1d			jp macro_next 
3a3e				endm 
# End of macro NEXTW
3a3e			 
3a3e .. 00		.blstr: db " ", 0 
3a40			 
3a40			.SPACES: 
3a40				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3a40 47				db WORD_SYS_CORE+51             
3a41 db 3a			dw .SCROLL            
3a43 07				db 6 + 1 
3a44 .. 00			db "SPACES",0              
3a4b				endm 
# End of macro CWHEAD
3a4b			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3a4b					if DEBUG_FORTH_WORDS_KEY 
3a4b						DMARK "SPS" 
3a4b f5				push af  
3a4c 3a 60 3a			ld a, (.dmark)  
3a4f 32 7a ee			ld (debug_mark),a  
3a52 3a 61 3a			ld a, (.dmark+1)  
3a55 32 7b ee			ld (debug_mark+1),a  
3a58 3a 62 3a			ld a, (.dmark+2)  
3a5b 32 7c ee			ld (debug_mark+2),a  
3a5e 18 03			jr .pastdmark  
3a60 ..			.dmark: db "SPS"  
3a63 f1			.pastdmark: pop af  
3a64			endm  
# End of macro DMARK
3a64						CALLMONITOR 
3a64 cd 28 14			call break_point_state  
3a67				endm  
# End of macro CALLMONITOR
3a67					endif 
3a67			 
3a67			 
3a67					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a67 cd ac 1b			call macro_dsp_valuehl 
3a6a				endm 
# End of macro FORTH_DSP_VALUEHL
3a6a			 
3a6a			;		push hl    ; u 
3a6a					if DEBUG_FORTH_WORDS 
3a6a						DMARK "SPA" 
3a6a f5				push af  
3a6b 3a 7f 3a			ld a, (.dmark)  
3a6e 32 7a ee			ld (debug_mark),a  
3a71 3a 80 3a			ld a, (.dmark+1)  
3a74 32 7b ee			ld (debug_mark+1),a  
3a77 3a 81 3a			ld a, (.dmark+2)  
3a7a 32 7c ee			ld (debug_mark+2),a  
3a7d 18 03			jr .pastdmark  
3a7f ..			.dmark: db "SPA"  
3a82 f1			.pastdmark: pop af  
3a83			endm  
# End of macro DMARK
3a83						CALLMONITOR 
3a83 cd 28 14			call break_point_state  
3a86				endm  
# End of macro CALLMONITOR
3a86					endif 
3a86			 
3a86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a86 cd 64 1c			call macro_forth_dsp_pop 
3a89				endm 
# End of macro FORTH_DSP_POP
3a89			;		pop hl 
3a89 4d					ld c, l 
3a8a 06 00				ld b, 0 
3a8c 21 60 e3				ld hl, scratch  
3a8f			 
3a8f					if DEBUG_FORTH_WORDS 
3a8f						DMARK "SP2" 
3a8f f5				push af  
3a90 3a a4 3a			ld a, (.dmark)  
3a93 32 7a ee			ld (debug_mark),a  
3a96 3a a5 3a			ld a, (.dmark+1)  
3a99 32 7b ee			ld (debug_mark+1),a  
3a9c 3a a6 3a			ld a, (.dmark+2)  
3a9f 32 7c ee			ld (debug_mark+2),a  
3aa2 18 03			jr .pastdmark  
3aa4 ..			.dmark: db "SP2"  
3aa7 f1			.pastdmark: pop af  
3aa8			endm  
# End of macro DMARK
3aa8						CALLMONITOR 
3aa8 cd 28 14			call break_point_state  
3aab				endm  
# End of macro CALLMONITOR
3aab					endif 
3aab 3e 20				ld a, ' ' 
3aad c5			.spaces1:	push bc 
3aae 77					ld (hl),a 
3aaf 23					inc hl 
3ab0 c1					pop bc 
3ab1 10 fa				djnz .spaces1 
3ab3 3e 00				ld a,0 
3ab5 77					ld (hl),a 
3ab6 21 60 e3				ld hl, scratch 
3ab9					if DEBUG_FORTH_WORDS 
3ab9						DMARK "SP3" 
3ab9 f5				push af  
3aba 3a ce 3a			ld a, (.dmark)  
3abd 32 7a ee			ld (debug_mark),a  
3ac0 3a cf 3a			ld a, (.dmark+1)  
3ac3 32 7b ee			ld (debug_mark+1),a  
3ac6 3a d0 3a			ld a, (.dmark+2)  
3ac9 32 7c ee			ld (debug_mark+2),a  
3acc 18 03			jr .pastdmark  
3ace ..			.dmark: db "SP3"  
3ad1 f1			.pastdmark: pop af  
3ad2			endm  
# End of macro DMARK
3ad2						CALLMONITOR 
3ad2 cd 28 14			call break_point_state  
3ad5				endm  
# End of macro CALLMONITOR
3ad5					endif 
3ad5 cd 1e 1b				call forth_apush 
3ad8			 
3ad8				       NEXTW 
3ad8 c3 1e 1d			jp macro_next 
3adb				endm 
# End of macro NEXTW
3adb			 
3adb			 
3adb			 
3adb			.SCROLL: 
3adb				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3adb 53				db WORD_SYS_CORE+63             
3adc 08 3b			dw .SCROLLD            
3ade 07				db 6 + 1 
3adf .. 00			db "SCROLL",0              
3ae6				endm 
# End of macro CWHEAD
3ae6			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3ae6					if DEBUG_FORTH_WORDS_KEY 
3ae6						DMARK "SCR" 
3ae6 f5				push af  
3ae7 3a fb 3a			ld a, (.dmark)  
3aea 32 7a ee			ld (debug_mark),a  
3aed 3a fc 3a			ld a, (.dmark+1)  
3af0 32 7b ee			ld (debug_mark+1),a  
3af3 3a fd 3a			ld a, (.dmark+2)  
3af6 32 7c ee			ld (debug_mark+2),a  
3af9 18 03			jr .pastdmark  
3afb ..			.dmark: db "SCR"  
3afe f1			.pastdmark: pop af  
3aff			endm  
# End of macro DMARK
3aff						CALLMONITOR 
3aff cd 28 14			call break_point_state  
3b02				endm  
# End of macro CALLMONITOR
3b02					endif 
3b02			 
3b02 cd 4a 09			call scroll_up 
3b05			;	call update_display 
3b05			 
3b05					NEXTW 
3b05 c3 1e 1d			jp macro_next 
3b08				endm 
# End of macro NEXTW
3b08			 
3b08			 
3b08			 
3b08			;		; get dir 
3b08			; 
3b08			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b08			; 
3b08			;		push hl 
3b08			; 
3b08			;		; destroy value TOS 
3b08			; 
3b08			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b08			; 
3b08			;		; get count 
3b08			; 
3b08			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b08			; 
3b08			;		push hl 
3b08			; 
3b08			;		; destroy value TOS 
3b08			; 
3b08			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b08			; 
3b08			;		; one value on hl get other one back 
3b08			; 
3b08			;		pop bc    ; count 
3b08			; 
3b08			;		pop de   ; dir 
3b08			; 
3b08			; 
3b08			;		ld b, c 
3b08			; 
3b08			;.scrolldir:     push bc 
3b08			;		push de 
3b08			; 
3b08			;		ld a, 0 
3b08			;		cp e 
3b08			;		jr z, .scrollup  
3b08			;		call scroll_down 
3b08			;		jr .scrollnext 
3b08			;.scrollup:	call scroll_up 
3b08			; 
3b08			;		 
3b08			;.scrollnext: 
3b08			;		pop de 
3b08			;		pop bc 
3b08			;		djnz .scrolldir 
3b08			; 
3b08			; 
3b08			; 
3b08			; 
3b08			; 
3b08			;		NEXTW 
3b08			 
3b08			.SCROLLD: 
3b08				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3b08 53				db WORD_SYS_CORE+63             
3b09 36 3b			dw .ATQ            
3b0b 08				db 7 + 1 
3b0c .. 00			db "SCROLLD",0              
3b14				endm 
# End of macro CWHEAD
3b14			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3b14					if DEBUG_FORTH_WORDS_KEY 
3b14						DMARK "SCD" 
3b14 f5				push af  
3b15 3a 29 3b			ld a, (.dmark)  
3b18 32 7a ee			ld (debug_mark),a  
3b1b 3a 2a 3b			ld a, (.dmark+1)  
3b1e 32 7b ee			ld (debug_mark+1),a  
3b21 3a 2b 3b			ld a, (.dmark+2)  
3b24 32 7c ee			ld (debug_mark+2),a  
3b27 18 03			jr .pastdmark  
3b29 ..			.dmark: db "SCD"  
3b2c f1			.pastdmark: pop af  
3b2d			endm  
# End of macro DMARK
3b2d						CALLMONITOR 
3b2d cd 28 14			call break_point_state  
3b30				endm  
# End of macro CALLMONITOR
3b30					endif 
3b30			 
3b30 cd 6e 09			call scroll_down 
3b33			;	call update_display 
3b33			 
3b33					NEXTW 
3b33 c3 1e 1d			jp macro_next 
3b36				endm 
# End of macro NEXTW
3b36			 
3b36			 
3b36			.ATQ: 
3b36				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3b36 62				db WORD_SYS_CORE+78             
3b37 94 3b			dw .AUTODSP            
3b39 04				db 3 + 1 
3b3a .. 00			db "AT@",0              
3b3e				endm 
# End of macro CWHEAD
3b3e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3b3e					if DEBUG_FORTH_WORDS_KEY 
3b3e						DMARK "ATA" 
3b3e f5				push af  
3b3f 3a 53 3b			ld a, (.dmark)  
3b42 32 7a ee			ld (debug_mark),a  
3b45 3a 54 3b			ld a, (.dmark+1)  
3b48 32 7b ee			ld (debug_mark+1),a  
3b4b 3a 55 3b			ld a, (.dmark+2)  
3b4e 32 7c ee			ld (debug_mark+2),a  
3b51 18 03			jr .pastdmark  
3b53 ..			.dmark: db "ATA"  
3b56 f1			.pastdmark: pop af  
3b57			endm  
# End of macro DMARK
3b57						CALLMONITOR 
3b57 cd 28 14			call break_point_state  
3b5a				endm  
# End of macro CALLMONITOR
3b5a					endif 
3b5a			 
3b5a			 
3b5a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b5a cd ac 1b			call macro_dsp_valuehl 
3b5d				endm 
# End of macro FORTH_DSP_VALUEHL
3b5d			 
3b5d					; TODO save cursor row 
3b5d 7d					ld a,l 
3b5e fe 02				cp 2 
3b60 20 04				jr nz, .crow3aq 
3b62 3e 28				ld a, display_row_2 
3b64 18 12				jr .ccol1aq 
3b66 fe 03		.crow3aq:		cp 3 
3b68 20 04				jr nz, .crow4aq 
3b6a 3e 50				ld a, display_row_3 
3b6c 18 0a				jr .ccol1aq 
3b6e fe 04		.crow4aq:		cp 4 
3b70 20 04				jr nz, .crow1aq 
3b72 3e 78				ld a, display_row_4 
3b74 18 02				jr .ccol1aq 
3b76 3e 00		.crow1aq:		ld a,display_row_1 
3b78 f5			.ccol1aq:		push af			; got row offset 
3b79 6f					ld l,a 
3b7a 26 00				ld h,0 
3b7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b7c cd 64 1c			call macro_forth_dsp_pop 
3b7f				endm 
# End of macro FORTH_DSP_POP
3b7f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b7f cd ac 1b			call macro_dsp_valuehl 
3b82				endm 
# End of macro FORTH_DSP_VALUEHL
3b82					; TODO save cursor col 
3b82 f1					pop af 
3b83 85					add l		; add col offset 
3b84			 
3b84					; add current frame buffer address 
3b84 2a db eb				ld hl, (display_fb_active) 
3b87 cd b5 0b				call addatohl 
3b8a			 
3b8a			 
3b8a			 
3b8a			 
3b8a					; get char frame buffer location offset in hl 
3b8a			 
3b8a 7e					ld a,(hl) 
3b8b 26 00				ld h, 0 
3b8d 6f					ld l, a 
3b8e			 
3b8e cd b5 19				call forth_push_numhl 
3b91			 
3b91			 
3b91					NEXTW 
3b91 c3 1e 1d			jp macro_next 
3b94				endm 
# End of macro NEXTW
3b94			 
3b94			.AUTODSP: 
3b94				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3b94 63				db WORD_SYS_CORE+79             
3b95 aa 3b			dw .MENU            
3b97 05				db 4 + 1 
3b98 .. 00			db "ADSP",0              
3b9d				endm 
# End of macro CWHEAD
3b9d			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3b9d			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3b9d			 
3b9d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b9d cd ac 1b			call macro_dsp_valuehl 
3ba0				endm 
# End of macro FORTH_DSP_VALUEHL
3ba0			 
3ba0			;		push hl 
3ba0			 
3ba0					; destroy value TOS 
3ba0			 
3ba0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ba0 cd 64 1c			call macro_forth_dsp_pop 
3ba3				endm 
# End of macro FORTH_DSP_POP
3ba3			 
3ba3			;		pop hl 
3ba3			 
3ba3 7d					ld a,l 
3ba4 32 27 eb				ld (cli_autodisplay), a 
3ba7				       NEXTW 
3ba7 c3 1e 1d			jp macro_next 
3baa				endm 
# End of macro NEXTW
3baa			 
3baa			.MENU: 
3baa				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3baa 70				db WORD_SYS_CORE+92             
3bab 53 3c			dw .ENDDISPLAY            
3bad 05				db 4 + 1 
3bae .. 00			db "MENU",0              
3bb3				endm 
# End of macro CWHEAD
3bb3			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3bb3			 
3bb3			;		; get number of items on the stack 
3bb3			; 
3bb3				 
3bb3					FORTH_DSP_VALUEHL 
3bb3 cd ac 1b			call macro_dsp_valuehl 
3bb6				endm 
# End of macro FORTH_DSP_VALUEHL
3bb6				 
3bb6					if DEBUG_FORTH_WORDS_KEY 
3bb6						DMARK "MNU" 
3bb6 f5				push af  
3bb7 3a cb 3b			ld a, (.dmark)  
3bba 32 7a ee			ld (debug_mark),a  
3bbd 3a cc 3b			ld a, (.dmark+1)  
3bc0 32 7b ee			ld (debug_mark+1),a  
3bc3 3a cd 3b			ld a, (.dmark+2)  
3bc6 32 7c ee			ld (debug_mark+2),a  
3bc9 18 03			jr .pastdmark  
3bcb ..			.dmark: db "MNU"  
3bce f1			.pastdmark: pop af  
3bcf			endm  
# End of macro DMARK
3bcf						CALLMONITOR 
3bcf cd 28 14			call break_point_state  
3bd2				endm  
# End of macro CALLMONITOR
3bd2					endif 
3bd2			 
3bd2 45					ld b, l	 
3bd3 05					dec b 
3bd4			 
3bd4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd4 cd 64 1c			call macro_forth_dsp_pop 
3bd7				endm 
# End of macro FORTH_DSP_POP
3bd7			 
3bd7			 
3bd7					; go directly through the stack to pluck out the string pointers and build an array 
3bd7			 
3bd7			;		FORTH_DSP 
3bd7			 
3bd7					; hl contains top most stack item 
3bd7				 
3bd7 11 60 e3				ld de, scratch 
3bda			 
3bda			.mbuild: 
3bda			 
3bda					FORTH_DSP_VALUEHL 
3bda cd ac 1b			call macro_dsp_valuehl 
3bdd				endm 
# End of macro FORTH_DSP_VALUEHL
3bdd			 
3bdd					if DEBUG_FORTH_WORDS 
3bdd						DMARK "MN3" 
3bdd f5				push af  
3bde 3a f2 3b			ld a, (.dmark)  
3be1 32 7a ee			ld (debug_mark),a  
3be4 3a f3 3b			ld a, (.dmark+1)  
3be7 32 7b ee			ld (debug_mark+1),a  
3bea 3a f4 3b			ld a, (.dmark+2)  
3bed 32 7c ee			ld (debug_mark+2),a  
3bf0 18 03			jr .pastdmark  
3bf2 ..			.dmark: db "MN3"  
3bf5 f1			.pastdmark: pop af  
3bf6			endm  
# End of macro DMARK
3bf6						CALLMONITOR 
3bf6 cd 28 14			call break_point_state  
3bf9				endm  
# End of macro CALLMONITOR
3bf9					endif 
3bf9 eb					ex de, hl 
3bfa 73					ld (hl), e 
3bfb 23					inc hl 
3bfc 72					ld (hl), d 
3bfd 23					inc hl 
3bfe eb					ex de, hl 
3bff			 
3bff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bff cd 64 1c			call macro_forth_dsp_pop 
3c02				endm 
# End of macro FORTH_DSP_POP
3c02			 
3c02 10 d6				djnz .mbuild 
3c04			 
3c04					; done add term 
3c04			 
3c04 eb					ex de, hl 
3c05 36 00				ld (hl), 0 
3c07 23					inc hl 
3c08 36 00				ld (hl), 0 
3c0a			 
3c0a				 
3c0a					 
3c0a 21 60 e3				ld hl, scratch 
3c0d			 
3c0d					if DEBUG_FORTH_WORDS 
3c0d						DMARK "MNx" 
3c0d f5				push af  
3c0e 3a 22 3c			ld a, (.dmark)  
3c11 32 7a ee			ld (debug_mark),a  
3c14 3a 23 3c			ld a, (.dmark+1)  
3c17 32 7b ee			ld (debug_mark+1),a  
3c1a 3a 24 3c			ld a, (.dmark+2)  
3c1d 32 7c ee			ld (debug_mark+2),a  
3c20 18 03			jr .pastdmark  
3c22 ..			.dmark: db "MNx"  
3c25 f1			.pastdmark: pop af  
3c26			endm  
# End of macro DMARK
3c26						CALLMONITOR 
3c26 cd 28 14			call break_point_state  
3c29				endm  
# End of macro CALLMONITOR
3c29					endif 
3c29			 
3c29			 
3c29			 
3c29 3e 00				ld a, 0 
3c2b cd b9 09				call menu 
3c2e			 
3c2e			 
3c2e 6f					ld l, a 
3c2f 26 00				ld h, 0 
3c31			 
3c31					if DEBUG_FORTH_WORDS 
3c31						DMARK "MNr" 
3c31 f5				push af  
3c32 3a 46 3c			ld a, (.dmark)  
3c35 32 7a ee			ld (debug_mark),a  
3c38 3a 47 3c			ld a, (.dmark+1)  
3c3b 32 7b ee			ld (debug_mark+1),a  
3c3e 3a 48 3c			ld a, (.dmark+2)  
3c41 32 7c ee			ld (debug_mark+2),a  
3c44 18 03			jr .pastdmark  
3c46 ..			.dmark: db "MNr"  
3c49 f1			.pastdmark: pop af  
3c4a			endm  
# End of macro DMARK
3c4a						CALLMONITOR 
3c4a cd 28 14			call break_point_state  
3c4d				endm  
# End of macro CALLMONITOR
3c4d					endif 
3c4d			 
3c4d cd b5 19				call forth_push_numhl 
3c50			 
3c50			 
3c50			 
3c50			 
3c50				       NEXTW 
3c50 c3 1e 1d			jp macro_next 
3c53				endm 
# End of macro NEXTW
3c53			 
3c53			 
3c53			.ENDDISPLAY: 
3c53			 
3c53			; eof 
# End of file forth_words_display.asm
3c53			include "forth_words_str.asm" 
3c53			 
3c53			; | ## String Words 
3c53			 
3c53			.PTR:   
3c53			 
3c53				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3c53 48				db WORD_SYS_CORE+52             
3c54 80 3c			dw .STYPE            
3c56 04				db 3 + 1 
3c57 .. 00			db "PTR",0              
3c5b				endm 
# End of macro CWHEAD
3c5b			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3c5b			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3c5b			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3c5b			 
3c5b					if DEBUG_FORTH_WORDS_KEY 
3c5b						DMARK "PTR" 
3c5b f5				push af  
3c5c 3a 70 3c			ld a, (.dmark)  
3c5f 32 7a ee			ld (debug_mark),a  
3c62 3a 71 3c			ld a, (.dmark+1)  
3c65 32 7b ee			ld (debug_mark+1),a  
3c68 3a 72 3c			ld a, (.dmark+2)  
3c6b 32 7c ee			ld (debug_mark+2),a  
3c6e 18 03			jr .pastdmark  
3c70 ..			.dmark: db "PTR"  
3c73 f1			.pastdmark: pop af  
3c74			endm  
# End of macro DMARK
3c74						CALLMONITOR 
3c74 cd 28 14			call break_point_state  
3c77				endm  
# End of macro CALLMONITOR
3c77					endif 
3c77					FORTH_DSP_VALUEHL 
3c77 cd ac 1b			call macro_dsp_valuehl 
3c7a				endm 
# End of macro FORTH_DSP_VALUEHL
3c7a cd b5 19				call forth_push_numhl 
3c7d			 
3c7d			 
3c7d					NEXTW 
3c7d c3 1e 1d			jp macro_next 
3c80				endm 
# End of macro NEXTW
3c80			.STYPE: 
3c80				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3c80 48				db WORD_SYS_CORE+52             
3c81 cf 3c			dw .UPPER            
3c83 06				db 5 + 1 
3c84 .. 00			db "STYPE",0              
3c8a				endm 
# End of macro CWHEAD
3c8a			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3c8a					if DEBUG_FORTH_WORDS_KEY 
3c8a						DMARK "STY" 
3c8a f5				push af  
3c8b 3a 9f 3c			ld a, (.dmark)  
3c8e 32 7a ee			ld (debug_mark),a  
3c91 3a a0 3c			ld a, (.dmark+1)  
3c94 32 7b ee			ld (debug_mark+1),a  
3c97 3a a1 3c			ld a, (.dmark+2)  
3c9a 32 7c ee			ld (debug_mark+2),a  
3c9d 18 03			jr .pastdmark  
3c9f ..			.dmark: db "STY"  
3ca2 f1			.pastdmark: pop af  
3ca3			endm  
# End of macro DMARK
3ca3						CALLMONITOR 
3ca3 cd 28 14			call break_point_state  
3ca6				endm  
# End of macro CALLMONITOR
3ca6					endif 
3ca6					FORTH_DSP 
3ca6 cd 72 1b			call macro_forth_dsp 
3ca9				endm 
# End of macro FORTH_DSP
3ca9					;v5 FORTH_DSP_VALUE 
3ca9			 
3ca9 7e					ld a, (hl) 
3caa			 
3caa f5					push af 
3cab			 
3cab			; Dont destroy TOS		FORTH_DSP_POP 
3cab			 
3cab f1					pop af 
3cac			 
3cac fe 01				cp DS_TYPE_STR 
3cae 28 09				jr z, .typestr 
3cb0			 
3cb0 fe 02				cp DS_TYPE_INUM 
3cb2 28 0a				jr z, .typeinum 
3cb4			 
3cb4 21 cd 3c				ld hl, .tna 
3cb7 18 0a				jr .tpush 
3cb9			 
3cb9 21 c9 3c		.typestr:	ld hl, .tstr 
3cbc 18 05				jr .tpush 
3cbe 21 cb 3c		.typeinum:	ld hl, .tinum 
3cc1 18 00				jr .tpush 
3cc3			 
3cc3			.tpush: 
3cc3			 
3cc3 cd 23 1a				call forth_push_str 
3cc6			 
3cc6					NEXTW 
3cc6 c3 1e 1d			jp macro_next 
3cc9				endm 
# End of macro NEXTW
3cc9 .. 00		.tstr:	db "s",0 
3ccb .. 00		.tinum:  db "i",0 
3ccd .. 00		.tna:   db "?", 0 
3ccf			 
3ccf			 
3ccf			.UPPER: 
3ccf				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3ccf 48				db WORD_SYS_CORE+52             
3cd0 0a 3d			dw .LOWER            
3cd2 06				db 5 + 1 
3cd3 .. 00			db "UPPER",0              
3cd9				endm 
# End of macro CWHEAD
3cd9			; | UPPER ( s -- s ) Upper case string s  | DONE 
3cd9					if DEBUG_FORTH_WORDS_KEY 
3cd9						DMARK "UPR" 
3cd9 f5				push af  
3cda 3a ee 3c			ld a, (.dmark)  
3cdd 32 7a ee			ld (debug_mark),a  
3ce0 3a ef 3c			ld a, (.dmark+1)  
3ce3 32 7b ee			ld (debug_mark+1),a  
3ce6 3a f0 3c			ld a, (.dmark+2)  
3ce9 32 7c ee			ld (debug_mark+2),a  
3cec 18 03			jr .pastdmark  
3cee ..			.dmark: db "UPR"  
3cf1 f1			.pastdmark: pop af  
3cf2			endm  
# End of macro DMARK
3cf2						CALLMONITOR 
3cf2 cd 28 14			call break_point_state  
3cf5				endm  
# End of macro CALLMONITOR
3cf5					endif 
3cf5			 
3cf5					FORTH_DSP 
3cf5 cd 72 1b			call macro_forth_dsp 
3cf8				endm 
# End of macro FORTH_DSP
3cf8					 
3cf8			; TODO check is string type 
3cf8			 
3cf8					FORTH_DSP_VALUEHL 
3cf8 cd ac 1b			call macro_dsp_valuehl 
3cfb				endm 
# End of macro FORTH_DSP_VALUEHL
3cfb			; get pointer to string in hl 
3cfb			 
3cfb 7e			.toup:		ld a, (hl) 
3cfc fe 00				cp 0 
3cfe 28 07				jr z, .toupdone 
3d00			 
3d00 cd 22 0f				call to_upper 
3d03			 
3d03 77					ld (hl), a 
3d04 23					inc hl 
3d05 18 f4				jr .toup 
3d07			 
3d07					 
3d07			 
3d07			 
3d07			; for each char convert to upper 
3d07					 
3d07			.toupdone: 
3d07			 
3d07			 
3d07					NEXTW 
3d07 c3 1e 1d			jp macro_next 
3d0a				endm 
# End of macro NEXTW
3d0a			.LOWER: 
3d0a				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3d0a 48				db WORD_SYS_CORE+52             
3d0b 45 3d			dw .TCASE            
3d0d 06				db 5 + 1 
3d0e .. 00			db "LOWER",0              
3d14				endm 
# End of macro CWHEAD
3d14			; | LOWER ( s -- s ) Lower case string s  | DONE 
3d14					if DEBUG_FORTH_WORDS_KEY 
3d14						DMARK "LWR" 
3d14 f5				push af  
3d15 3a 29 3d			ld a, (.dmark)  
3d18 32 7a ee			ld (debug_mark),a  
3d1b 3a 2a 3d			ld a, (.dmark+1)  
3d1e 32 7b ee			ld (debug_mark+1),a  
3d21 3a 2b 3d			ld a, (.dmark+2)  
3d24 32 7c ee			ld (debug_mark+2),a  
3d27 18 03			jr .pastdmark  
3d29 ..			.dmark: db "LWR"  
3d2c f1			.pastdmark: pop af  
3d2d			endm  
# End of macro DMARK
3d2d						CALLMONITOR 
3d2d cd 28 14			call break_point_state  
3d30				endm  
# End of macro CALLMONITOR
3d30					endif 
3d30			 
3d30					FORTH_DSP 
3d30 cd 72 1b			call macro_forth_dsp 
3d33				endm 
# End of macro FORTH_DSP
3d33					 
3d33			; TODO check is string type 
3d33			 
3d33					FORTH_DSP_VALUEHL 
3d33 cd ac 1b			call macro_dsp_valuehl 
3d36				endm 
# End of macro FORTH_DSP_VALUEHL
3d36			; get pointer to string in hl 
3d36			 
3d36 7e			.tolow:		ld a, (hl) 
3d37 fe 00				cp 0 
3d39 28 07				jr z, .tolowdone 
3d3b			 
3d3b cd 2b 0f				call to_lower 
3d3e			 
3d3e 77					ld (hl), a 
3d3f 23					inc hl 
3d40 18 f4				jr .tolow 
3d42			 
3d42					 
3d42			 
3d42			 
3d42			; for each char convert to low 
3d42					 
3d42			.tolowdone: 
3d42					NEXTW 
3d42 c3 1e 1d			jp macro_next 
3d45				endm 
# End of macro NEXTW
3d45			.TCASE: 
3d45				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3d45 48				db WORD_SYS_CORE+52             
3d46 7b 3e			dw .SUBSTR            
3d48 06				db 5 + 1 
3d49 .. 00			db "TCASE",0              
3d4f				endm 
# End of macro CWHEAD
3d4f			; | TCASE ( s -- s ) Title case string s  | DONE 
3d4f					if DEBUG_FORTH_WORDS_KEY 
3d4f						DMARK "TCS" 
3d4f f5				push af  
3d50 3a 64 3d			ld a, (.dmark)  
3d53 32 7a ee			ld (debug_mark),a  
3d56 3a 65 3d			ld a, (.dmark+1)  
3d59 32 7b ee			ld (debug_mark+1),a  
3d5c 3a 66 3d			ld a, (.dmark+2)  
3d5f 32 7c ee			ld (debug_mark+2),a  
3d62 18 03			jr .pastdmark  
3d64 ..			.dmark: db "TCS"  
3d67 f1			.pastdmark: pop af  
3d68			endm  
# End of macro DMARK
3d68						CALLMONITOR 
3d68 cd 28 14			call break_point_state  
3d6b				endm  
# End of macro CALLMONITOR
3d6b					endif 
3d6b			 
3d6b					FORTH_DSP 
3d6b cd 72 1b			call macro_forth_dsp 
3d6e				endm 
# End of macro FORTH_DSP
3d6e					 
3d6e			; TODO check is string type 
3d6e			 
3d6e					FORTH_DSP_VALUEHL 
3d6e cd ac 1b			call macro_dsp_valuehl 
3d71				endm 
# End of macro FORTH_DSP_VALUEHL
3d71			; get pointer to string in hl 
3d71			 
3d71					if DEBUG_FORTH_WORDS 
3d71						DMARK "TC1" 
3d71 f5				push af  
3d72 3a 86 3d			ld a, (.dmark)  
3d75 32 7a ee			ld (debug_mark),a  
3d78 3a 87 3d			ld a, (.dmark+1)  
3d7b 32 7b ee			ld (debug_mark+1),a  
3d7e 3a 88 3d			ld a, (.dmark+2)  
3d81 32 7c ee			ld (debug_mark+2),a  
3d84 18 03			jr .pastdmark  
3d86 ..			.dmark: db "TC1"  
3d89 f1			.pastdmark: pop af  
3d8a			endm  
# End of macro DMARK
3d8a						CALLMONITOR 
3d8a cd 28 14			call break_point_state  
3d8d				endm  
# End of macro CALLMONITOR
3d8d					endif 
3d8d			 
3d8d					; first time in turn to upper case first char 
3d8d			 
3d8d 7e					ld a, (hl) 
3d8e c3 18 3e				jp .totsiptou 
3d91			 
3d91			 
3d91 7e			.tot:		ld a, (hl) 
3d92 fe 00				cp 0 
3d94 ca 5c 3e				jp z, .totdone 
3d97			 
3d97					if DEBUG_FORTH_WORDS 
3d97						DMARK "TC2" 
3d97 f5				push af  
3d98 3a ac 3d			ld a, (.dmark)  
3d9b 32 7a ee			ld (debug_mark),a  
3d9e 3a ad 3d			ld a, (.dmark+1)  
3da1 32 7b ee			ld (debug_mark+1),a  
3da4 3a ae 3d			ld a, (.dmark+2)  
3da7 32 7c ee			ld (debug_mark+2),a  
3daa 18 03			jr .pastdmark  
3dac ..			.dmark: db "TC2"  
3daf f1			.pastdmark: pop af  
3db0			endm  
# End of macro DMARK
3db0						CALLMONITOR 
3db0 cd 28 14			call break_point_state  
3db3				endm  
# End of macro CALLMONITOR
3db3					endif 
3db3					; check to see if current char is a space 
3db3			 
3db3 fe 20				cp ' ' 
3db5 28 21				jr z, .totsp 
3db7 cd 2b 0f				call to_lower 
3dba					if DEBUG_FORTH_WORDS 
3dba						DMARK "TC3" 
3dba f5				push af  
3dbb 3a cf 3d			ld a, (.dmark)  
3dbe 32 7a ee			ld (debug_mark),a  
3dc1 3a d0 3d			ld a, (.dmark+1)  
3dc4 32 7b ee			ld (debug_mark+1),a  
3dc7 3a d1 3d			ld a, (.dmark+2)  
3dca 32 7c ee			ld (debug_mark+2),a  
3dcd 18 03			jr .pastdmark  
3dcf ..			.dmark: db "TC3"  
3dd2 f1			.pastdmark: pop af  
3dd3			endm  
# End of macro DMARK
3dd3						CALLMONITOR 
3dd3 cd 28 14			call break_point_state  
3dd6				endm  
# End of macro CALLMONITOR
3dd6					endif 
3dd6 18 63				jr .totnxt 
3dd8			 
3dd8			.totsp:         ; on a space, find next char which should be upper 
3dd8			 
3dd8					if DEBUG_FORTH_WORDS 
3dd8						DMARK "TC4" 
3dd8 f5				push af  
3dd9 3a ed 3d			ld a, (.dmark)  
3ddc 32 7a ee			ld (debug_mark),a  
3ddf 3a ee 3d			ld a, (.dmark+1)  
3de2 32 7b ee			ld (debug_mark+1),a  
3de5 3a ef 3d			ld a, (.dmark+2)  
3de8 32 7c ee			ld (debug_mark+2),a  
3deb 18 03			jr .pastdmark  
3ded ..			.dmark: db "TC4"  
3df0 f1			.pastdmark: pop af  
3df1			endm  
# End of macro DMARK
3df1						CALLMONITOR 
3df1 cd 28 14			call break_point_state  
3df4				endm  
# End of macro CALLMONITOR
3df4					endif 
3df4					;; 
3df4			 
3df4 fe 20				cp ' ' 
3df6 20 20				jr nz, .totsiptou 
3df8 23					inc hl 
3df9 7e					ld a, (hl) 
3dfa					if DEBUG_FORTH_WORDS 
3dfa						DMARK "TC5" 
3dfa f5				push af  
3dfb 3a 0f 3e			ld a, (.dmark)  
3dfe 32 7a ee			ld (debug_mark),a  
3e01 3a 10 3e			ld a, (.dmark+1)  
3e04 32 7b ee			ld (debug_mark+1),a  
3e07 3a 11 3e			ld a, (.dmark+2)  
3e0a 32 7c ee			ld (debug_mark+2),a  
3e0d 18 03			jr .pastdmark  
3e0f ..			.dmark: db "TC5"  
3e12 f1			.pastdmark: pop af  
3e13			endm  
# End of macro DMARK
3e13						CALLMONITOR 
3e13 cd 28 14			call break_point_state  
3e16				endm  
# End of macro CALLMONITOR
3e16					endif 
3e16 18 c0				jr .totsp 
3e18 fe 00		.totsiptou:    cp 0 
3e1a 28 40				jr z, .totdone 
3e1c					; not space and not zero term so upper case it 
3e1c cd 22 0f				call to_upper 
3e1f			 
3e1f					if DEBUG_FORTH_WORDS 
3e1f						DMARK "TC6" 
3e1f f5				push af  
3e20 3a 34 3e			ld a, (.dmark)  
3e23 32 7a ee			ld (debug_mark),a  
3e26 3a 35 3e			ld a, (.dmark+1)  
3e29 32 7b ee			ld (debug_mark+1),a  
3e2c 3a 36 3e			ld a, (.dmark+2)  
3e2f 32 7c ee			ld (debug_mark+2),a  
3e32 18 03			jr .pastdmark  
3e34 ..			.dmark: db "TC6"  
3e37 f1			.pastdmark: pop af  
3e38			endm  
# End of macro DMARK
3e38						CALLMONITOR 
3e38 cd 28 14			call break_point_state  
3e3b				endm  
# End of macro CALLMONITOR
3e3b					endif 
3e3b			 
3e3b			 
3e3b			.totnxt: 
3e3b			 
3e3b 77					ld (hl), a 
3e3c 23					inc hl 
3e3d					if DEBUG_FORTH_WORDS 
3e3d						DMARK "TC7" 
3e3d f5				push af  
3e3e 3a 52 3e			ld a, (.dmark)  
3e41 32 7a ee			ld (debug_mark),a  
3e44 3a 53 3e			ld a, (.dmark+1)  
3e47 32 7b ee			ld (debug_mark+1),a  
3e4a 3a 54 3e			ld a, (.dmark+2)  
3e4d 32 7c ee			ld (debug_mark+2),a  
3e50 18 03			jr .pastdmark  
3e52 ..			.dmark: db "TC7"  
3e55 f1			.pastdmark: pop af  
3e56			endm  
# End of macro DMARK
3e56						CALLMONITOR 
3e56 cd 28 14			call break_point_state  
3e59				endm  
# End of macro CALLMONITOR
3e59					endif 
3e59 c3 91 3d				jp .tot 
3e5c			 
3e5c					 
3e5c			 
3e5c			 
3e5c			; for each char convert to low 
3e5c					 
3e5c			.totdone: 
3e5c					if DEBUG_FORTH_WORDS 
3e5c						DMARK "TCd" 
3e5c f5				push af  
3e5d 3a 71 3e			ld a, (.dmark)  
3e60 32 7a ee			ld (debug_mark),a  
3e63 3a 72 3e			ld a, (.dmark+1)  
3e66 32 7b ee			ld (debug_mark+1),a  
3e69 3a 73 3e			ld a, (.dmark+2)  
3e6c 32 7c ee			ld (debug_mark+2),a  
3e6f 18 03			jr .pastdmark  
3e71 ..			.dmark: db "TCd"  
3e74 f1			.pastdmark: pop af  
3e75			endm  
# End of macro DMARK
3e75						CALLMONITOR 
3e75 cd 28 14			call break_point_state  
3e78				endm  
# End of macro CALLMONITOR
3e78					endif 
3e78					NEXTW 
3e78 c3 1e 1d			jp macro_next 
3e7b				endm 
# End of macro NEXTW
3e7b			 
3e7b			.SUBSTR: 
3e7b				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3e7b 48				db WORD_SYS_CORE+52             
3e7c d9 3e			dw .LEFT            
3e7e 07				db 6 + 1 
3e7f .. 00			db "SUBSTR",0              
3e86				endm 
# End of macro CWHEAD
3e86			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3e86			 
3e86					if DEBUG_FORTH_WORDS_KEY 
3e86						DMARK "SST" 
3e86 f5				push af  
3e87 3a 9b 3e			ld a, (.dmark)  
3e8a 32 7a ee			ld (debug_mark),a  
3e8d 3a 9c 3e			ld a, (.dmark+1)  
3e90 32 7b ee			ld (debug_mark+1),a  
3e93 3a 9d 3e			ld a, (.dmark+2)  
3e96 32 7c ee			ld (debug_mark+2),a  
3e99 18 03			jr .pastdmark  
3e9b ..			.dmark: db "SST"  
3e9e f1			.pastdmark: pop af  
3e9f			endm  
# End of macro DMARK
3e9f						CALLMONITOR 
3e9f cd 28 14			call break_point_state  
3ea2				endm  
# End of macro CALLMONITOR
3ea2					endif 
3ea2			; TODO check string type 
3ea2					FORTH_DSP_VALUEHL 
3ea2 cd ac 1b			call macro_dsp_valuehl 
3ea5				endm 
# End of macro FORTH_DSP_VALUEHL
3ea5			 
3ea5 e5					push hl      ; string length 
3ea6			 
3ea6					FORTH_DSP_POP 
3ea6 cd 64 1c			call macro_forth_dsp_pop 
3ea9				endm 
# End of macro FORTH_DSP_POP
3ea9			 
3ea9					FORTH_DSP_VALUEHL 
3ea9 cd ac 1b			call macro_dsp_valuehl 
3eac				endm 
# End of macro FORTH_DSP_VALUEHL
3eac			 
3eac e5					push hl     ; start char 
3ead			 
3ead					FORTH_DSP_POP 
3ead cd 64 1c			call macro_forth_dsp_pop 
3eb0				endm 
# End of macro FORTH_DSP_POP
3eb0			 
3eb0			 
3eb0					FORTH_DSP_VALUE 
3eb0 cd 95 1b			call macro_forth_dsp_value 
3eb3				endm 
# End of macro FORTH_DSP_VALUE
3eb3			 
3eb3 d1					pop de    ; get start post offset 
3eb4			 
3eb4 19					add hl, de    ; starting offset 
3eb5			 
3eb5 c1					pop bc 
3eb6 c5					push bc      ; grab size of string 
3eb7			 
3eb7 e5					push hl    ; save string start  
3eb8			 
3eb8 26 00				ld h, 0 
3eba 69					ld l, c 
3ebb 23					inc hl 
3ebc 23					inc hl 
3ebd			 
3ebd cd 7c 10				call malloc 
3ec0				if DEBUG_FORTH_MALLOC_GUARD 
3ec0 cc ef 44				call z,malloc_error 
3ec3				endif 
3ec3			 
3ec3 eb					ex de, hl      ; save malloc area for string copy 
3ec4 e1					pop hl    ; get back source 
3ec5 c1					pop bc    ; get length of string back 
3ec6			 
3ec6 d5					push de    ; save malloc area for after we push 
3ec7 ed b0				ldir     ; copy substr 
3ec9			 
3ec9			 
3ec9 eb					ex de, hl 
3eca 3e 00				ld a, 0 
3ecc 77					ld (hl), a   ; term substr 
3ecd			 
3ecd					 
3ecd e1					pop hl    ; get malloc so we can push it 
3ece e5					push hl   ; save so we can free it afterwards 
3ecf			 
3ecf cd 23 1a				call forth_push_str 
3ed2			 
3ed2 e1					pop hl 
3ed3 cd 46 11				call free 
3ed6			 
3ed6					 
3ed6					 
3ed6			 
3ed6			 
3ed6					NEXTW 
3ed6 c3 1e 1d			jp macro_next 
3ed9				endm 
# End of macro NEXTW
3ed9			 
3ed9			.LEFT: 
3ed9				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3ed9 48				db WORD_SYS_CORE+52             
3eda 01 3f			dw .RIGHT            
3edc 05				db 4 + 1 
3edd .. 00			db "LEFT",0              
3ee2				endm 
# End of macro CWHEAD
3ee2			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3ee2					if DEBUG_FORTH_WORDS_KEY 
3ee2						DMARK "LEF" 
3ee2 f5				push af  
3ee3 3a f7 3e			ld a, (.dmark)  
3ee6 32 7a ee			ld (debug_mark),a  
3ee9 3a f8 3e			ld a, (.dmark+1)  
3eec 32 7b ee			ld (debug_mark+1),a  
3eef 3a f9 3e			ld a, (.dmark+2)  
3ef2 32 7c ee			ld (debug_mark+2),a  
3ef5 18 03			jr .pastdmark  
3ef7 ..			.dmark: db "LEF"  
3efa f1			.pastdmark: pop af  
3efb			endm  
# End of macro DMARK
3efb						CALLMONITOR 
3efb cd 28 14			call break_point_state  
3efe				endm  
# End of macro CALLMONITOR
3efe					endif 
3efe			 
3efe					NEXTW 
3efe c3 1e 1d			jp macro_next 
3f01				endm 
# End of macro NEXTW
3f01			.RIGHT: 
3f01				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3f01 48				db WORD_SYS_CORE+52             
3f02 2a 3f			dw .STR2NUM            
3f04 06				db 5 + 1 
3f05 .. 00			db "RIGHT",0              
3f0b				endm 
# End of macro CWHEAD
3f0b			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3f0b					if DEBUG_FORTH_WORDS_KEY 
3f0b						DMARK "RIG" 
3f0b f5				push af  
3f0c 3a 20 3f			ld a, (.dmark)  
3f0f 32 7a ee			ld (debug_mark),a  
3f12 3a 21 3f			ld a, (.dmark+1)  
3f15 32 7b ee			ld (debug_mark+1),a  
3f18 3a 22 3f			ld a, (.dmark+2)  
3f1b 32 7c ee			ld (debug_mark+2),a  
3f1e 18 03			jr .pastdmark  
3f20 ..			.dmark: db "RIG"  
3f23 f1			.pastdmark: pop af  
3f24			endm  
# End of macro DMARK
3f24						CALLMONITOR 
3f24 cd 28 14			call break_point_state  
3f27				endm  
# End of macro CALLMONITOR
3f27					endif 
3f27			 
3f27					NEXTW 
3f27 c3 1e 1d			jp macro_next 
3f2a				endm 
# End of macro NEXTW
3f2a			 
3f2a			 
3f2a			.STR2NUM: 
3f2a				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3f2a 48				db WORD_SYS_CORE+52             
3f2b b6 3f			dw .NUM2STR            
3f2d 08				db 7 + 1 
3f2e .. 00			db "STR2NUM",0              
3f36				endm 
# End of macro CWHEAD
3f36			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3f36			 
3f36			 
3f36			; TODO STR type check to do 
3f36					if DEBUG_FORTH_WORDS_KEY 
3f36						DMARK "S2N" 
3f36 f5				push af  
3f37 3a 4b 3f			ld a, (.dmark)  
3f3a 32 7a ee			ld (debug_mark),a  
3f3d 3a 4c 3f			ld a, (.dmark+1)  
3f40 32 7b ee			ld (debug_mark+1),a  
3f43 3a 4d 3f			ld a, (.dmark+2)  
3f46 32 7c ee			ld (debug_mark+2),a  
3f49 18 03			jr .pastdmark  
3f4b ..			.dmark: db "S2N"  
3f4e f1			.pastdmark: pop af  
3f4f			endm  
# End of macro DMARK
3f4f						CALLMONITOR 
3f4f cd 28 14			call break_point_state  
3f52				endm  
# End of macro CALLMONITOR
3f52					endif 
3f52			 
3f52					;FORTH_DSP 
3f52					FORTH_DSP_VALUE 
3f52 cd 95 1b			call macro_forth_dsp_value 
3f55				endm 
# End of macro FORTH_DSP_VALUE
3f55					;inc hl 
3f55			 
3f55 eb					ex de, hl 
3f56					if DEBUG_FORTH_WORDS 
3f56						DMARK "S2a" 
3f56 f5				push af  
3f57 3a 6b 3f			ld a, (.dmark)  
3f5a 32 7a ee			ld (debug_mark),a  
3f5d 3a 6c 3f			ld a, (.dmark+1)  
3f60 32 7b ee			ld (debug_mark+1),a  
3f63 3a 6d 3f			ld a, (.dmark+2)  
3f66 32 7c ee			ld (debug_mark+2),a  
3f69 18 03			jr .pastdmark  
3f6b ..			.dmark: db "S2a"  
3f6e f1			.pastdmark: pop af  
3f6f			endm  
# End of macro DMARK
3f6f						CALLMONITOR 
3f6f cd 28 14			call break_point_state  
3f72				endm  
# End of macro CALLMONITOR
3f72					endif 
3f72 cd aa 0f				call string_to_uint16 
3f75			 
3f75					if DEBUG_FORTH_WORDS 
3f75						DMARK "S2b" 
3f75 f5				push af  
3f76 3a 8a 3f			ld a, (.dmark)  
3f79 32 7a ee			ld (debug_mark),a  
3f7c 3a 8b 3f			ld a, (.dmark+1)  
3f7f 32 7b ee			ld (debug_mark+1),a  
3f82 3a 8c 3f			ld a, (.dmark+2)  
3f85 32 7c ee			ld (debug_mark+2),a  
3f88 18 03			jr .pastdmark  
3f8a ..			.dmark: db "S2b"  
3f8d f1			.pastdmark: pop af  
3f8e			endm  
# End of macro DMARK
3f8e						CALLMONITOR 
3f8e cd 28 14			call break_point_state  
3f91				endm  
# End of macro CALLMONITOR
3f91					endif 
3f91			;		push hl 
3f91					FORTH_DSP_POP 
3f91 cd 64 1c			call macro_forth_dsp_pop 
3f94				endm 
# End of macro FORTH_DSP_POP
3f94			;		pop hl 
3f94					 
3f94					if DEBUG_FORTH_WORDS 
3f94						DMARK "S2b" 
3f94 f5				push af  
3f95 3a a9 3f			ld a, (.dmark)  
3f98 32 7a ee			ld (debug_mark),a  
3f9b 3a aa 3f			ld a, (.dmark+1)  
3f9e 32 7b ee			ld (debug_mark+1),a  
3fa1 3a ab 3f			ld a, (.dmark+2)  
3fa4 32 7c ee			ld (debug_mark+2),a  
3fa7 18 03			jr .pastdmark  
3fa9 ..			.dmark: db "S2b"  
3fac f1			.pastdmark: pop af  
3fad			endm  
# End of macro DMARK
3fad						CALLMONITOR 
3fad cd 28 14			call break_point_state  
3fb0				endm  
# End of macro CALLMONITOR
3fb0					endif 
3fb0 cd b5 19				call forth_push_numhl	 
3fb3			 
3fb3				 
3fb3				       NEXTW 
3fb3 c3 1e 1d			jp macro_next 
3fb6				endm 
# End of macro NEXTW
3fb6			.NUM2STR: 
3fb6				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3fb6 48				db WORD_SYS_CORE+52             
3fb7 c5 3f			dw .CONCAT            
3fb9 08				db 7 + 1 
3fba .. 00			db "NUM2STR",0              
3fc2				endm 
# End of macro CWHEAD
3fc2			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3fc2			 
3fc2			;		; malloc a string to target 
3fc2			;		ld hl, 10     ; TODO max string size should be fine 
3fc2			;		call malloc 
3fc2			;		push hl    ; save malloc location 
3fc2			; 
3fc2			; 
3fc2			;; TODO check int type 
3fc2			;		FORTH_DSP_VALUEHL 
3fc2			;		ld a, l 
3fc2			;		call DispAToASCII   
3fc2			;;TODO need to chage above call to dump into string 
3fc2			; 
3fc2			; 
3fc2			 
3fc2				       NEXTW 
3fc2 c3 1e 1d			jp macro_next 
3fc5				endm 
# End of macro NEXTW
3fc5			 
3fc5			.CONCAT: 
3fc5				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3fc5 48				db WORD_SYS_CORE+52             
3fc6 78 40			dw .FIND            
3fc8 07				db 6 + 1 
3fc9 .. 00			db "CONCAT",0              
3fd0				endm 
# End of macro CWHEAD
3fd0			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3fd0			 
3fd0			; TODO check string type 
3fd0			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3fd0			 
3fd0					if DEBUG_FORTH_WORDS_KEY 
3fd0						DMARK "CON" 
3fd0 f5				push af  
3fd1 3a e5 3f			ld a, (.dmark)  
3fd4 32 7a ee			ld (debug_mark),a  
3fd7 3a e6 3f			ld a, (.dmark+1)  
3fda 32 7b ee			ld (debug_mark+1),a  
3fdd 3a e7 3f			ld a, (.dmark+2)  
3fe0 32 7c ee			ld (debug_mark+2),a  
3fe3 18 03			jr .pastdmark  
3fe5 ..			.dmark: db "CON"  
3fe8 f1			.pastdmark: pop af  
3fe9			endm  
# End of macro DMARK
3fe9						CALLMONITOR 
3fe9 cd 28 14			call break_point_state  
3fec				endm  
# End of macro CALLMONITOR
3fec					endif 
3fec			 
3fec			 
3fec					FORTH_DSP_VALUE 
3fec cd 95 1b			call macro_forth_dsp_value 
3fef				endm 
# End of macro FORTH_DSP_VALUE
3fef e5					push hl   ; s2 
3ff0			 
3ff0					FORTH_DSP_POP 
3ff0 cd 64 1c			call macro_forth_dsp_pop 
3ff3				endm 
# End of macro FORTH_DSP_POP
3ff3			 
3ff3					FORTH_DSP_VALUE 
3ff3 cd 95 1b			call macro_forth_dsp_value 
3ff6				endm 
# End of macro FORTH_DSP_VALUE
3ff6			 
3ff6 e5					push hl   ; s1 
3ff7			 
3ff7					FORTH_DSP_POP 
3ff7 cd 64 1c			call macro_forth_dsp_pop 
3ffa				endm 
# End of macro FORTH_DSP_POP
3ffa					 
3ffa			 
3ffa					; copy s1 
3ffa			 
3ffa				 
3ffa					; save ptr 
3ffa e1					pop hl  
3ffb e5					push hl 
3ffc 3e 00				ld a, 0 
3ffe cd 1e 10				call strlent 
4001					;inc hl    ; zer0 
4001 06 00				ld b, 0 
4003 4d					ld c, l 
4004 e1					pop hl		 
4005 11 60 e3				ld de, scratch	 
4008					if DEBUG_FORTH_WORDS 
4008						DMARK "CO1" 
4008 f5				push af  
4009 3a 1d 40			ld a, (.dmark)  
400c 32 7a ee			ld (debug_mark),a  
400f 3a 1e 40			ld a, (.dmark+1)  
4012 32 7b ee			ld (debug_mark+1),a  
4015 3a 1f 40			ld a, (.dmark+2)  
4018 32 7c ee			ld (debug_mark+2),a  
401b 18 03			jr .pastdmark  
401d ..			.dmark: db "CO1"  
4020 f1			.pastdmark: pop af  
4021			endm  
# End of macro DMARK
4021						CALLMONITOR 
4021 cd 28 14			call break_point_state  
4024				endm  
# End of macro CALLMONITOR
4024					endif 
4024 ed b0				ldir 
4026			 
4026 e1					pop hl 
4027 e5					push hl 
4028 d5					push de 
4029			 
4029			 
4029 3e 00				ld a, 0 
402b cd 1e 10				call strlent 
402e 23					inc hl    ; zer0 
402f 23					inc hl 
4030 06 00				ld b, 0 
4032 4d					ld c, l 
4033 d1					pop de 
4034 e1					pop hl		 
4035					if DEBUG_FORTH_WORDS 
4035						DMARK "CO2" 
4035 f5				push af  
4036 3a 4a 40			ld a, (.dmark)  
4039 32 7a ee			ld (debug_mark),a  
403c 3a 4b 40			ld a, (.dmark+1)  
403f 32 7b ee			ld (debug_mark+1),a  
4042 3a 4c 40			ld a, (.dmark+2)  
4045 32 7c ee			ld (debug_mark+2),a  
4048 18 03			jr .pastdmark  
404a ..			.dmark: db "CO2"  
404d f1			.pastdmark: pop af  
404e			endm  
# End of macro DMARK
404e						CALLMONITOR 
404e cd 28 14			call break_point_state  
4051				endm  
# End of macro CALLMONITOR
4051					endif 
4051 ed b0				ldir 
4053			 
4053			 
4053			 
4053 21 60 e3				ld hl, scratch 
4056					if DEBUG_FORTH_WORDS 
4056						DMARK "CO5" 
4056 f5				push af  
4057 3a 6b 40			ld a, (.dmark)  
405a 32 7a ee			ld (debug_mark),a  
405d 3a 6c 40			ld a, (.dmark+1)  
4060 32 7b ee			ld (debug_mark+1),a  
4063 3a 6d 40			ld a, (.dmark+2)  
4066 32 7c ee			ld (debug_mark+2),a  
4069 18 03			jr .pastdmark  
406b ..			.dmark: db "CO5"  
406e f1			.pastdmark: pop af  
406f			endm  
# End of macro DMARK
406f						CALLMONITOR 
406f cd 28 14			call break_point_state  
4072				endm  
# End of macro CALLMONITOR
4072					endif 
4072			 
4072 cd 23 1a				call forth_push_str 
4075			 
4075			 
4075			 
4075			 
4075				       NEXTW 
4075 c3 1e 1d			jp macro_next 
4078				endm 
# End of macro NEXTW
4078			 
4078			 
4078			.FIND: 
4078				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4078 4b				db WORD_SYS_CORE+55             
4079 36 41			dw .LEN            
407b 05				db 4 + 1 
407c .. 00			db "FIND",0              
4081				endm 
# End of macro CWHEAD
4081			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4081			 
4081					if DEBUG_FORTH_WORDS_KEY 
4081						DMARK "FND" 
4081 f5				push af  
4082 3a 96 40			ld a, (.dmark)  
4085 32 7a ee			ld (debug_mark),a  
4088 3a 97 40			ld a, (.dmark+1)  
408b 32 7b ee			ld (debug_mark+1),a  
408e 3a 98 40			ld a, (.dmark+2)  
4091 32 7c ee			ld (debug_mark+2),a  
4094 18 03			jr .pastdmark  
4096 ..			.dmark: db "FND"  
4099 f1			.pastdmark: pop af  
409a			endm  
# End of macro DMARK
409a						CALLMONITOR 
409a cd 28 14			call break_point_state  
409d				endm  
# End of macro CALLMONITOR
409d					endif 
409d			 
409d			; TODO check string type 
409d					FORTH_DSP_VALUE 
409d cd 95 1b			call macro_forth_dsp_value 
40a0				endm 
# End of macro FORTH_DSP_VALUE
40a0			 
40a0 e5					push hl    
40a1 7e					ld a,(hl)    ; char to find   
40a2			; TODO change char to substr 
40a2			 
40a2 f5					push af 
40a3					 
40a3			 
40a3			 
40a3					if DEBUG_FORTH_WORDS 
40a3						DMARK "FN1" 
40a3 f5				push af  
40a4 3a b8 40			ld a, (.dmark)  
40a7 32 7a ee			ld (debug_mark),a  
40aa 3a b9 40			ld a, (.dmark+1)  
40ad 32 7b ee			ld (debug_mark+1),a  
40b0 3a ba 40			ld a, (.dmark+2)  
40b3 32 7c ee			ld (debug_mark+2),a  
40b6 18 03			jr .pastdmark  
40b8 ..			.dmark: db "FN1"  
40bb f1			.pastdmark: pop af  
40bc			endm  
# End of macro DMARK
40bc						CALLMONITOR 
40bc cd 28 14			call break_point_state  
40bf				endm  
# End of macro CALLMONITOR
40bf					endif 
40bf			 
40bf					FORTH_DSP_POP 
40bf cd 64 1c			call macro_forth_dsp_pop 
40c2				endm 
# End of macro FORTH_DSP_POP
40c2			 
40c2					; string to search 
40c2			 
40c2					FORTH_DSP_VALUE 
40c2 cd 95 1b			call macro_forth_dsp_value 
40c5				endm 
# End of macro FORTH_DSP_VALUE
40c5			 
40c5 d1					pop de  ; d is char to find  
40c6			 
40c6					if DEBUG_FORTH_WORDS 
40c6						DMARK "FN2" 
40c6 f5				push af  
40c7 3a db 40			ld a, (.dmark)  
40ca 32 7a ee			ld (debug_mark),a  
40cd 3a dc 40			ld a, (.dmark+1)  
40d0 32 7b ee			ld (debug_mark+1),a  
40d3 3a dd 40			ld a, (.dmark+2)  
40d6 32 7c ee			ld (debug_mark+2),a  
40d9 18 03			jr .pastdmark  
40db ..			.dmark: db "FN2"  
40de f1			.pastdmark: pop af  
40df			endm  
# End of macro DMARK
40df						CALLMONITOR 
40df cd 28 14			call break_point_state  
40e2				endm  
# End of macro CALLMONITOR
40e2					endif 
40e2					 
40e2 01 00 00				ld bc, 0 
40e5 7e			.findchar:      ld a,(hl) 
40e6 fe 00				cp 0   		 
40e8 28 27				jr z, .finddone     
40ea ba					cp d 
40eb 28 20				jr z, .foundchar 
40ed 03					inc bc 
40ee 23					inc hl 
40ef					if DEBUG_FORTH_WORDS 
40ef						DMARK "FN3" 
40ef f5				push af  
40f0 3a 04 41			ld a, (.dmark)  
40f3 32 7a ee			ld (debug_mark),a  
40f6 3a 05 41			ld a, (.dmark+1)  
40f9 32 7b ee			ld (debug_mark+1),a  
40fc 3a 06 41			ld a, (.dmark+2)  
40ff 32 7c ee			ld (debug_mark+2),a  
4102 18 03			jr .pastdmark  
4104 ..			.dmark: db "FN3"  
4107 f1			.pastdmark: pop af  
4108			endm  
# End of macro DMARK
4108						CALLMONITOR 
4108 cd 28 14			call break_point_state  
410b				endm  
# End of macro CALLMONITOR
410b					endif 
410b 18 d8				jr .findchar 
410d			 
410d			 
410d c5			.foundchar:	push bc 
410e e1					pop hl 
410f 18 03				jr .findexit 
4111			 
4111			 
4111							 
4111			 
4111			.finddone:     ; got to end of string with no find 
4111 21 00 00				ld hl, 0 
4114			.findexit: 
4114			 
4114					if DEBUG_FORTH_WORDS 
4114						DMARK "FNd" 
4114 f5				push af  
4115 3a 29 41			ld a, (.dmark)  
4118 32 7a ee			ld (debug_mark),a  
411b 3a 2a 41			ld a, (.dmark+1)  
411e 32 7b ee			ld (debug_mark+1),a  
4121 3a 2b 41			ld a, (.dmark+2)  
4124 32 7c ee			ld (debug_mark+2),a  
4127 18 03			jr .pastdmark  
4129 ..			.dmark: db "FNd"  
412c f1			.pastdmark: pop af  
412d			endm  
# End of macro DMARK
412d						CALLMONITOR 
412d cd 28 14			call break_point_state  
4130				endm  
# End of macro CALLMONITOR
4130					endif 
4130 cd b5 19			call forth_push_numhl 
4133			 
4133				       NEXTW 
4133 c3 1e 1d			jp macro_next 
4136				endm 
# End of macro NEXTW
4136			 
4136			.LEN: 
4136				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4136 4c				db WORD_SYS_CORE+56             
4137 6b 41			dw .CHAR            
4139 06				db 5 + 1 
413a .. 00			db "COUNT",0              
4140				endm 
# End of macro CWHEAD
4140			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
4140			 
4140					if DEBUG_FORTH_WORDS_KEY 
4140						DMARK "CNT" 
4140 f5				push af  
4141 3a 55 41			ld a, (.dmark)  
4144 32 7a ee			ld (debug_mark),a  
4147 3a 56 41			ld a, (.dmark+1)  
414a 32 7b ee			ld (debug_mark+1),a  
414d 3a 57 41			ld a, (.dmark+2)  
4150 32 7c ee			ld (debug_mark+2),a  
4153 18 03			jr .pastdmark  
4155 ..			.dmark: db "CNT"  
4158 f1			.pastdmark: pop af  
4159			endm  
# End of macro DMARK
4159						CALLMONITOR 
4159 cd 28 14			call break_point_state  
415c				endm  
# End of macro CALLMONITOR
415c					endif 
415c			; TODO check string type 
415c					FORTH_DSP 
415c cd 72 1b			call macro_forth_dsp 
415f				endm 
# End of macro FORTH_DSP
415f					;v5FORTH_DSP_VALUE 
415f			 
415f 23					inc hl 
4160			 
4160 3e 00				ld a, 0 
4162 cd 1e 10				call strlent 
4165			 
4165 cd b5 19				call forth_push_numhl 
4168			 
4168			 
4168			 
4168				       NEXTW 
4168 c3 1e 1d			jp macro_next 
416b				endm 
# End of macro NEXTW
416b			.CHAR: 
416b				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
416b 4d				db WORD_SYS_CORE+57             
416c a1 41			dw .ENDSTR            
416e 05				db 4 + 1 
416f .. 00			db "CHAR",0              
4174				endm 
# End of macro CWHEAD
4174			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4174					if DEBUG_FORTH_WORDS_KEY 
4174						DMARK "CHR" 
4174 f5				push af  
4175 3a 89 41			ld a, (.dmark)  
4178 32 7a ee			ld (debug_mark),a  
417b 3a 8a 41			ld a, (.dmark+1)  
417e 32 7b ee			ld (debug_mark+1),a  
4181 3a 8b 41			ld a, (.dmark+2)  
4184 32 7c ee			ld (debug_mark+2),a  
4187 18 03			jr .pastdmark  
4189 ..			.dmark: db "CHR"  
418c f1			.pastdmark: pop af  
418d			endm  
# End of macro DMARK
418d						CALLMONITOR 
418d cd 28 14			call break_point_state  
4190				endm  
# End of macro CALLMONITOR
4190					endif 
4190					FORTH_DSP 
4190 cd 72 1b			call macro_forth_dsp 
4193				endm 
# End of macro FORTH_DSP
4193					;v5 FORTH_DSP_VALUE 
4193 23					inc hl      ; now at start of numeric as string 
4194			 
4194			;		push hl 
4194			 
4194					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4194 cd 64 1c			call macro_forth_dsp_pop 
4197				endm 
# End of macro FORTH_DSP_POP
4197			 
4197			;		pop hl 
4197			 
4197					; push the content of a onto the stack as a value 
4197			 
4197 7e					ld a,(hl)   ; get char 
4198 26 00				ld h,0 
419a 6f					ld l,a 
419b cd b5 19				call forth_push_numhl 
419e			 
419e				       NEXTW 
419e c3 1e 1d			jp macro_next 
41a1				endm 
# End of macro NEXTW
41a1			 
41a1			 
41a1			 
41a1			 
41a1			.ENDSTR: 
41a1			; eof 
41a1			 
# End of file forth_words_str.asm
41a1			include "forth_words_key.asm" 
41a1			 
41a1			; | ## Keyboard Words 
41a1			 
41a1			.KEY: 
41a1				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
41a1 3e				db WORD_SYS_CORE+42             
41a2 d1 41			dw .WAITK            
41a4 04				db 3 + 1 
41a5 .. 00			db "KEY",0              
41a9				endm 
# End of macro CWHEAD
41a9			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
41a9			 
41a9					if DEBUG_FORTH_WORDS_KEY 
41a9						DMARK "KEY" 
41a9 f5				push af  
41aa 3a be 41			ld a, (.dmark)  
41ad 32 7a ee			ld (debug_mark),a  
41b0 3a bf 41			ld a, (.dmark+1)  
41b3 32 7b ee			ld (debug_mark+1),a  
41b6 3a c0 41			ld a, (.dmark+2)  
41b9 32 7c ee			ld (debug_mark+2),a  
41bc 18 03			jr .pastdmark  
41be ..			.dmark: db "KEY"  
41c1 f1			.pastdmark: pop af  
41c2			endm  
# End of macro DMARK
41c2						CALLMONITOR 
41c2 cd 28 14			call break_point_state  
41c5				endm  
# End of macro CALLMONITOR
41c5					endif 
41c5			; TODO currently waits 
41c5 cd 79 58				call cin 
41c8					;call cin_wait 
41c8 6f					ld l, a 
41c9 26 00				ld h, 0 
41cb cd b5 19				call forth_push_numhl 
41ce					NEXTW 
41ce c3 1e 1d			jp macro_next 
41d1				endm 
# End of macro NEXTW
41d1			.WAITK: 
41d1				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
41d1 3f				db WORD_SYS_CORE+43             
41d2 03 42			dw .ACCEPT            
41d4 06				db 5 + 1 
41d5 .. 00			db "WAITK",0              
41db				endm 
# End of macro CWHEAD
41db			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
41db					if DEBUG_FORTH_WORDS_KEY 
41db						DMARK "WAI" 
41db f5				push af  
41dc 3a f0 41			ld a, (.dmark)  
41df 32 7a ee			ld (debug_mark),a  
41e2 3a f1 41			ld a, (.dmark+1)  
41e5 32 7b ee			ld (debug_mark+1),a  
41e8 3a f2 41			ld a, (.dmark+2)  
41eb 32 7c ee			ld (debug_mark+2),a  
41ee 18 03			jr .pastdmark  
41f0 ..			.dmark: db "WAI"  
41f3 f1			.pastdmark: pop af  
41f4			endm  
# End of macro DMARK
41f4						CALLMONITOR 
41f4 cd 28 14			call break_point_state  
41f7				endm  
# End of macro CALLMONITOR
41f7					endif 
41f7 cd 71 58				call cin_wait 
41fa 6f					ld l, a 
41fb 26 00				ld h, 0 
41fd cd b5 19				call forth_push_numhl 
4200					NEXTW 
4200 c3 1e 1d			jp macro_next 
4203				endm 
# End of macro NEXTW
4203			.ACCEPT: 
4203				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4203 40				db WORD_SYS_CORE+44             
4204 61 42			dw .EDIT            
4206 07				db 6 + 1 
4207 .. 00			db "ACCEPT",0              
420e				endm 
# End of macro CWHEAD
420e			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
420e					; TODO crashes on push 
420e					if DEBUG_FORTH_WORDS_KEY 
420e						DMARK "ACC" 
420e f5				push af  
420f 3a 23 42			ld a, (.dmark)  
4212 32 7a ee			ld (debug_mark),a  
4215 3a 24 42			ld a, (.dmark+1)  
4218 32 7b ee			ld (debug_mark+1),a  
421b 3a 25 42			ld a, (.dmark+2)  
421e 32 7c ee			ld (debug_mark+2),a  
4221 18 03			jr .pastdmark  
4223 ..			.dmark: db "ACC"  
4226 f1			.pastdmark: pop af  
4227			endm  
# End of macro DMARK
4227						CALLMONITOR 
4227 cd 28 14			call break_point_state  
422a				endm  
# End of macro CALLMONITOR
422a					endif 
422a 21 5e e5				ld hl, os_input 
422d 3e 00				ld a, 0 
422f 77					ld (hl),a 
4230 3a 49 eb				ld a,(f_cursor_ptr) 
4233 16 64				ld d, 100 
4235 0e 00				ld c, 0 
4237 1e 28				ld e, 40 
4239 cd e2 0b				call input_str 
423c					; TODO perhaps do a type check and wrap in quotes if not a number 
423c 21 5e e5				ld hl, os_input 
423f					if DEBUG_FORTH_WORDS 
423f						DMARK "AC1" 
423f f5				push af  
4240 3a 54 42			ld a, (.dmark)  
4243 32 7a ee			ld (debug_mark),a  
4246 3a 55 42			ld a, (.dmark+1)  
4249 32 7b ee			ld (debug_mark+1),a  
424c 3a 56 42			ld a, (.dmark+2)  
424f 32 7c ee			ld (debug_mark+2),a  
4252 18 03			jr .pastdmark  
4254 ..			.dmark: db "AC1"  
4257 f1			.pastdmark: pop af  
4258			endm  
# End of macro DMARK
4258						CALLMONITOR 
4258 cd 28 14			call break_point_state  
425b				endm  
# End of macro CALLMONITOR
425b					endif 
425b cd 23 1a				call forth_push_str 
425e					NEXTW 
425e c3 1e 1d			jp macro_next 
4261				endm 
# End of macro NEXTW
4261			 
4261			.EDIT: 
4261				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4261 40				db WORD_SYS_CORE+44             
4262 ea 42			dw .ENDKEY            
4264 05				db 4 + 1 
4265 .. 00			db "EDIT",0              
426a				endm 
# End of macro CWHEAD
426a			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
426a			 
426a					; TODO does not copy from stack 
426a					if DEBUG_FORTH_WORDS_KEY 
426a						DMARK "EDT" 
426a f5				push af  
426b 3a 7f 42			ld a, (.dmark)  
426e 32 7a ee			ld (debug_mark),a  
4271 3a 80 42			ld a, (.dmark+1)  
4274 32 7b ee			ld (debug_mark+1),a  
4277 3a 81 42			ld a, (.dmark+2)  
427a 32 7c ee			ld (debug_mark+2),a  
427d 18 03			jr .pastdmark  
427f ..			.dmark: db "EDT"  
4282 f1			.pastdmark: pop af  
4283			endm  
# End of macro DMARK
4283						CALLMONITOR 
4283 cd 28 14			call break_point_state  
4286				endm  
# End of macro CALLMONITOR
4286					endif 
4286			 
4286					FORTH_DSP 
4286 cd 72 1b			call macro_forth_dsp 
4289				endm 
# End of macro FORTH_DSP
4289					;v5 FORTH_DSP_VALUE 
4289 23					inc hl    ; TODO do type check 
428a			 
428a e5					push hl 
428b 3e 00				ld a, 0 
428d cd 1e 10				call strlent 
4290 23					inc hl 
4291			 
4291 06 00				ld b, 0 
4293 4d					ld c, l 
4294			 
4294 e1					pop hl 
4295 11 5e e5				ld de, os_input 
4298					if DEBUG_FORTH_WORDS_KEY 
4298						DMARK "EDc" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 7a ee			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 7b ee			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 7c ee			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "EDc"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd 28 14			call break_point_state  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4 ed b0				ldir 
42b6			 
42b6			 
42b6 21 5e e5				ld hl, os_input 
42b9					;ld a, 0 
42b9					;ld (hl),a 
42b9 3a 49 eb				ld a,(f_cursor_ptr) 
42bc 16 64				ld d, 100 
42be 0e 00				ld c, 0 
42c0 1e 28				ld e, 40 
42c2 cd e2 0b				call input_str 
42c5					; TODO perhaps do a type check and wrap in quotes if not a number 
42c5 21 5e e5				ld hl, os_input 
42c8					if DEBUG_FORTH_WORDS 
42c8						DMARK "ED1" 
42c8 f5				push af  
42c9 3a dd 42			ld a, (.dmark)  
42cc 32 7a ee			ld (debug_mark),a  
42cf 3a de 42			ld a, (.dmark+1)  
42d2 32 7b ee			ld (debug_mark+1),a  
42d5 3a df 42			ld a, (.dmark+2)  
42d8 32 7c ee			ld (debug_mark+2),a  
42db 18 03			jr .pastdmark  
42dd ..			.dmark: db "ED1"  
42e0 f1			.pastdmark: pop af  
42e1			endm  
# End of macro DMARK
42e1						CALLMONITOR 
42e1 cd 28 14			call break_point_state  
42e4				endm  
# End of macro CALLMONITOR
42e4					endif 
42e4 cd 23 1a				call forth_push_str 
42e7					NEXTW 
42e7 c3 1e 1d			jp macro_next 
42ea				endm 
# End of macro NEXTW
42ea			 
42ea			 
42ea			 
42ea			.ENDKEY: 
42ea			; eof 
42ea			 
# End of file forth_words_key.asm
42ea			 
42ea			if STORAGE_SE 
42ea			   	include "forth_words_storage.asm" 
42ea			endif 
42ea				include "forth_words_device.asm" 
42ea			; Device related words 
42ea			 
42ea			; | ## Device Words 
42ea			 
42ea			if SOUND_ENABLE 
42ea			.NOTE: 
42ea				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
42ea			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
42ea					if DEBUG_FORTH_WORDS_KEY 
42ea						DMARK "NTE" 
42ea						CALLMONITOR 
42ea					endif 
42ea			 
42ea				 
42ea			 
42ea					NEXTW 
42ea			.AFTERSOUND: 
42ea			endif 
42ea			 
42ea			 
42ea			USE_GPIO: equ 0 
42ea			 
42ea			if USE_GPIO 
42ea			.GP1: 
42ea				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
42ea			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
42ea					NEXTW 
42ea			.GP2: 
42ea				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
42ea			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
42ea			 
42ea					NEXTW 
42ea			 
42ea			.GP3: 
42ea				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
42ea			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
42ea			 
42ea					NEXTW 
42ea			 
42ea			.GP4: 
42ea				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
42ea			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
42ea			 
42ea					NEXTW 
42ea			.SIN: 
42ea			 
42ea			 
42ea			endif 
42ea			 
42ea			 
42ea				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
42ea 33				db WORD_SYS_CORE+31             
42eb 1f 43			dw .SOUT            
42ed 03				db 2 + 1 
42ee .. 00			db "IN",0              
42f1				endm 
# End of macro CWHEAD
42f1			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
42f1					if DEBUG_FORTH_WORDS_KEY 
42f1						DMARK "IN." 
42f1 f5				push af  
42f2 3a 06 43			ld a, (.dmark)  
42f5 32 7a ee			ld (debug_mark),a  
42f8 3a 07 43			ld a, (.dmark+1)  
42fb 32 7b ee			ld (debug_mark+1),a  
42fe 3a 08 43			ld a, (.dmark+2)  
4301 32 7c ee			ld (debug_mark+2),a  
4304 18 03			jr .pastdmark  
4306 ..			.dmark: db "IN."  
4309 f1			.pastdmark: pop af  
430a			endm  
# End of macro DMARK
430a						CALLMONITOR 
430a cd 28 14			call break_point_state  
430d				endm  
# End of macro CALLMONITOR
430d					endif 
430d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
430d cd ac 1b			call macro_dsp_valuehl 
4310				endm 
# End of macro FORTH_DSP_VALUEHL
4310			 
4310 e5					push hl 
4311			 
4311					; destroy value TOS 
4311			 
4311					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4311 cd 64 1c			call macro_forth_dsp_pop 
4314				endm 
# End of macro FORTH_DSP_POP
4314			 
4314					; one value on hl get other one back 
4314			 
4314 c1					pop bc 
4315			 
4315					; do the sub 
4315			;		ex de, hl 
4315			 
4315 ed 68				in l,(c) 
4317			 
4317					; save it 
4317			 
4317 26 00				ld h,0 
4319			 
4319					; TODO push value back onto stack for another op etc 
4319			 
4319 cd b5 19				call forth_push_numhl 
431c					NEXTW 
431c c3 1e 1d			jp macro_next 
431f				endm 
# End of macro NEXTW
431f			.SOUT: 
431f				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
431f 34				db WORD_SYS_CORE+32             
4320 72 43			dw .SPIO            
4322 04				db 3 + 1 
4323 .. 00			db "OUT",0              
4327				endm 
# End of macro CWHEAD
4327			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4327					if DEBUG_FORTH_WORDS_KEY 
4327						DMARK "OUT" 
4327 f5				push af  
4328 3a 3c 43			ld a, (.dmark)  
432b 32 7a ee			ld (debug_mark),a  
432e 3a 3d 43			ld a, (.dmark+1)  
4331 32 7b ee			ld (debug_mark+1),a  
4334 3a 3e 43			ld a, (.dmark+2)  
4337 32 7c ee			ld (debug_mark+2),a  
433a 18 03			jr .pastdmark  
433c ..			.dmark: db "OUT"  
433f f1			.pastdmark: pop af  
4340			endm  
# End of macro DMARK
4340						CALLMONITOR 
4340 cd 28 14			call break_point_state  
4343				endm  
# End of macro CALLMONITOR
4343					endif 
4343			 
4343					; get port 
4343			 
4343					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4343 cd ac 1b			call macro_dsp_valuehl 
4346				endm 
# End of macro FORTH_DSP_VALUEHL
4346			 
4346 e5					push hl 
4347			 
4347					; destroy value TOS 
4347			 
4347					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4347 cd 64 1c			call macro_forth_dsp_pop 
434a				endm 
# End of macro FORTH_DSP_POP
434a			 
434a					; get byte to send 
434a			 
434a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
434a cd ac 1b			call macro_dsp_valuehl 
434d				endm 
# End of macro FORTH_DSP_VALUEHL
434d			 
434d			;		push hl 
434d			 
434d					; destroy value TOS 
434d			 
434d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
434d cd 64 1c			call macro_forth_dsp_pop 
4350				endm 
# End of macro FORTH_DSP_POP
4350			 
4350					; one value on hl get other one back 
4350			 
4350			;		pop hl 
4350			 
4350 c1					pop bc 
4351			 
4351					if DEBUG_FORTH_WORDS 
4351						DMARK "OUT" 
4351 f5				push af  
4352 3a 66 43			ld a, (.dmark)  
4355 32 7a ee			ld (debug_mark),a  
4358 3a 67 43			ld a, (.dmark+1)  
435b 32 7b ee			ld (debug_mark+1),a  
435e 3a 68 43			ld a, (.dmark+2)  
4361 32 7c ee			ld (debug_mark+2),a  
4364 18 03			jr .pastdmark  
4366 ..			.dmark: db "OUT"  
4369 f1			.pastdmark: pop af  
436a			endm  
# End of macro DMARK
436a						CALLMONITOR 
436a cd 28 14			call break_point_state  
436d				endm  
# End of macro CALLMONITOR
436d					endif 
436d			 
436d ed 69				out (c), l 
436f			 
436f					NEXTW 
436f c3 1e 1d			jp macro_next 
4372				endm 
# End of macro NEXTW
4372			 
4372			 
4372			.SPIO: 
4372			 
4372			if STORAGE_SE 
4372				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4372			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4372			 
4372					call spi_ce_low 
4372			    NEXTW 
4372			 
4372			.SPICEH: 
4372				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4372			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4372			 
4372					call spi_ce_high 
4372			    NEXTW 
4372			 
4372			 
4372			.SPIOb: 
4372			 
4372				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4372			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4372			 
4372					; get port 
4372			 
4372			 
4372					; get byte to send 
4372			 
4372					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4372			 
4372			;		push hl    ; u1  
4372			 
4372					; destroy value TOS 
4372			 
4372					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4372			 
4372					; one value on hl get other one back 
4372			 
4372			;		pop hl   ; u2 - addr 
4372			 
4372					; TODO Send SPI byte 
4372			 
4372					ld a, l 
4372					call spi_send_byte 
4372			 
4372					NEXTW 
4372			 
4372			.SPII: 
4372				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4372			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4372			 
4372					; TODO Get SPI byte 
4372			 
4372					call spi_read_byte 
4372			 
4372					ld h, 0 
4372					ld l, a 
4372					call forth_push_numhl 
4372			 
4372					NEXTW 
4372			 
4372			 
4372			 
4372			.SESEL: 
4372				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4372			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4372					if DEBUG_FORTH_WORDS_KEY 
4372						DMARK "BNK" 
4372						CALLMONITOR 
4372					endif 
4372			 
4372					ld a, 255 
4372					ld (spi_cartdev), a 
4372			 
4372					; get bank 
4372			 
4372					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4372			 
4372			;		push hl 
4372			 
4372					; destroy value TOS 
4372			 
4372					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4372			 
4372					; one value on hl get other one back 
4372			 
4372			;		pop hl 
4372			 
4372			 
4372					ld c, SPI_CE_HIGH 
4372					ld b, '0'    ; human readable bank number 
4372			 
4372					ld a, l 
4372			 
4372					if DEBUG_FORTH_WORDS 
4372						DMARK "BNK" 
4372						CALLMONITOR 
4372					endif 
4372			 
4372					; active low 
4372			 
4372					cp 0 
4372					jr z, .bset 
4372					cp 1 
4372					jr nz, .b2 
4372					res 0, c 
4372					ld b, '1'    ; human readable bank number 
4372			.b2:		cp 2 
4372					jr nz, .b3 
4372					res 1, c 
4372					ld b, '2'    ; human readable bank number 
4372			.b3:		cp 3 
4372					jr nz, .b4 
4372					res 2, c 
4372					ld b, '3'    ; human readable bank number 
4372			.b4:		cp 4 
4372					jr nz, .b5 
4372					res 3, c 
4372					ld b, '4'    ; human readable bank number 
4372			.b5:		cp 5 
4372					jr nz, .bset 
4372					res 4, c 
4372					ld b, '5'    ; human readable bank number 
4372			 
4372			.bset: 
4372					ld a, c 
4372					ld (spi_device),a 
4372					ld a, b 
4372					ld (spi_device_id),a 
4372					if DEBUG_FORTH_WORDS 
4372						DMARK "BN2" 
4372						CALLMONITOR 
4372					endif 
4372			 
4372					NEXTW 
4372			 
4372			.CARTDEV: 
4372				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4372			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4372					if DEBUG_FORTH_WORDS_KEY 
4372						DMARK "CDV" 
4372						CALLMONITOR 
4372					endif 
4372			 
4372					; disable se storage bank selection 
4372			 
4372					ld a, SPI_CE_HIGH		; ce high 
4372					ld (spi_device), a 
4372			 
4372					; get bank 
4372			 
4372					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4372			 
4372			;		push hl 
4372			 
4372					; destroy value TOS 
4372			 
4372					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4372			 
4372					; one value on hl get other one back 
4372			 
4372			;		pop hl 
4372			 
4372					; active low 
4372			 
4372					ld c, 255 
4372			 
4372					ld a, l 
4372					if DEBUG_FORTH_WORDS 
4372						DMARK "CDV" 
4372						CALLMONITOR 
4372					endif 
4372					cp 0 
4372					jr z, .cset 
4372					cp 1 
4372					jr nz, .c2 
4372					res 0, c 
4372			.c2:		cp 2 
4372					jr nz, .c3 
4372					res 1, c 
4372			.c3:		cp 3 
4372					jr nz, .c4 
4372					res 2, c 
4372			.c4:		cp 4 
4372					jr nz, .c5 
4372					res 3, c 
4372			.c5:		cp 5 
4372					jr nz, .c6 
4372					res 4, c 
4372			.c6:		cp 6 
4372					jr nz, .c7 
4372					res 5, c 
4372			.c7:		cp 7 
4372					jr nz, .c8 
4372					res 6, c 
4372			.c8:		cp 8 
4372					jr nz, .cset 
4372					res 7, c 
4372			.cset:		ld a, c 
4372					ld (spi_cartdev),a 
4372			 
4372					if DEBUG_FORTH_WORDS 
4372						DMARK "CD2" 
4372						CALLMONITOR 
4372					endif 
4372					NEXTW 
4372			endif 
4372			 
4372			.ENDDEVICE: 
4372			; eof 
4372			 
# End of file forth_words_device.asm
4372			 
4372			; var handler 
4372			 
4372			 
4372			.VARS: 
4372				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4372 78				db WORD_SYS_CORE+100             
4373 8a 43			dw .V0Q            
4375 04				db 3 + 1 
4376 .. 00			db "V0!",0              
437a				endm 
# End of macro CWHEAD
437a			;| V0! ( u1 -- )  Store value to v0  | DONE 
437a			 
437a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
437a cd ac 1b			call macro_dsp_valuehl 
437d				endm 
# End of macro FORTH_DSP_VALUEHL
437d			 
437d 11 13 eb				ld de, cli_var_array 
4380			 
4380 eb					ex de, hl 
4381 73					ld (hl), e 
4382 23					inc hl 
4383 72					ld (hl), d 
4384			 
4384					; destroy value TOS 
4384			 
4384					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4384 cd 64 1c			call macro_forth_dsp_pop 
4387				endm 
# End of macro FORTH_DSP_POP
4387			 
4387				       NEXTW 
4387 c3 1e 1d			jp macro_next 
438a				endm 
# End of macro NEXTW
438a			.V0Q: 
438a				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
438a 79				db WORD_SYS_CORE+101             
438b 9b 43			dw .V1S            
438d 04				db 3 + 1 
438e .. 00			db "V0@",0              
4392				endm 
# End of macro CWHEAD
4392			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4392 2a 13 eb				ld hl, (cli_var_array) 
4395 cd b5 19				call forth_push_numhl 
4398			 
4398				       NEXTW 
4398 c3 1e 1d			jp macro_next 
439b				endm 
# End of macro NEXTW
439b			.V1S: 
439b				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
439b 7a				db WORD_SYS_CORE+102             
439c b3 43			dw .V1Q            
439e 04				db 3 + 1 
439f .. 00			db "V1!",0              
43a3				endm 
# End of macro CWHEAD
43a3			;| V1! ( u1 -- )  Store value to v1 | DONE 
43a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43a3 cd ac 1b			call macro_dsp_valuehl 
43a6				endm 
# End of macro FORTH_DSP_VALUEHL
43a6			 
43a6 11 15 eb				ld de, cli_var_array+2 
43a9				 
43a9 eb					ex de, hl 
43aa 73					ld (hl), e 
43ab 23					inc hl 
43ac 72					ld (hl), d 
43ad			 
43ad					; destroy value TOS 
43ad			 
43ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43ad cd 64 1c			call macro_forth_dsp_pop 
43b0				endm 
# End of macro FORTH_DSP_POP
43b0				       NEXTW 
43b0 c3 1e 1d			jp macro_next 
43b3				endm 
# End of macro NEXTW
43b3			.V1Q: 
43b3				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
43b3 7b				db WORD_SYS_CORE+103             
43b4 c4 43			dw .V2S            
43b6 04				db 3 + 1 
43b7 .. 00			db "V1@",0              
43bb				endm 
# End of macro CWHEAD
43bb			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
43bb 2a 15 eb				ld hl, (cli_var_array+2) 
43be cd b5 19				call forth_push_numhl 
43c1				       NEXTW 
43c1 c3 1e 1d			jp macro_next 
43c4				endm 
# End of macro NEXTW
43c4			.V2S: 
43c4				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
43c4 7c				db WORD_SYS_CORE+104             
43c5 dc 43			dw .V2Q            
43c7 04				db 3 + 1 
43c8 .. 00			db "V2!",0              
43cc				endm 
# End of macro CWHEAD
43cc			;| V2! ( u1 -- )  Store value to v2 | DONE 
43cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43cc cd ac 1b			call macro_dsp_valuehl 
43cf				endm 
# End of macro FORTH_DSP_VALUEHL
43cf			 
43cf 11 17 eb				ld de, cli_var_array+4 
43d2				 
43d2 eb					ex de, hl 
43d3 73					ld (hl), e 
43d4 23					inc hl 
43d5 72					ld (hl), d 
43d6			 
43d6					; destroy value TOS 
43d6			 
43d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43d6 cd 64 1c			call macro_forth_dsp_pop 
43d9				endm 
# End of macro FORTH_DSP_POP
43d9				       NEXTW 
43d9 c3 1e 1d			jp macro_next 
43dc				endm 
# End of macro NEXTW
43dc			.V2Q: 
43dc				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
43dc 7d				db WORD_SYS_CORE+105             
43dd ed 43			dw .V3S            
43df 04				db 3 + 1 
43e0 .. 00			db "V2@",0              
43e4				endm 
# End of macro CWHEAD
43e4			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
43e4 2a 17 eb				ld hl, (cli_var_array+4) 
43e7 cd b5 19				call forth_push_numhl 
43ea				       NEXTW 
43ea c3 1e 1d			jp macro_next 
43ed				endm 
# End of macro NEXTW
43ed			.V3S: 
43ed				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
43ed 7c				db WORD_SYS_CORE+104             
43ee 05 44			dw .V3Q            
43f0 04				db 3 + 1 
43f1 .. 00			db "V3!",0              
43f5				endm 
# End of macro CWHEAD
43f5			;| V3! ( u1 -- )  Store value to v3 | DONE 
43f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43f5 cd ac 1b			call macro_dsp_valuehl 
43f8				endm 
# End of macro FORTH_DSP_VALUEHL
43f8			 
43f8 11 19 eb				ld de, cli_var_array+6 
43fb				 
43fb eb					ex de, hl 
43fc 73					ld (hl), e 
43fd 23					inc hl 
43fe 72					ld (hl), d 
43ff			 
43ff					; destroy value TOS 
43ff			 
43ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43ff cd 64 1c			call macro_forth_dsp_pop 
4402				endm 
# End of macro FORTH_DSP_POP
4402				       NEXTW 
4402 c3 1e 1d			jp macro_next 
4405				endm 
# End of macro NEXTW
4405			.V3Q: 
4405				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4405 7d				db WORD_SYS_CORE+105             
4406 16 44			dw .END            
4408 04				db 3 + 1 
4409 .. 00			db "V3@",0              
440d				endm 
# End of macro CWHEAD
440d			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
440d 2a 19 eb				ld hl, (cli_var_array+6) 
4410 cd b5 19				call forth_push_numhl 
4413				       NEXTW 
4413 c3 1e 1d			jp macro_next 
4416				endm 
# End of macro NEXTW
4416			 
4416			 
4416			 
4416			 
4416			 
4416			; end of dict marker 
4416			 
4416 00			.END:    db WORD_SYS_END 
4417 00 00			dw 0 
4419 00				db 0 
441a			 
441a			; use to jp here for user dict words to save on macro expansion  
441a			 
441a			user_dict_next: 
441a				NEXTW 
441a c3 1e 1d			jp macro_next 
441d				endm 
# End of macro NEXTW
441d			 
441d			 
441d			user_exec: 
441d				;    ld hl, <word code> 
441d				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
441d				;    call forthexec 
441d				;    jp user_dict_next   (NEXT) 
441d			        ;    <word code bytes> 
441d eb				ex de, hl 
441e 2a 61 e6			ld hl,(os_tok_ptr) 
4421				 
4421				FORTH_RSP_NEXT 
4421 cd 5c 19			call macro_forth_rsp_next 
4424				endm 
# End of macro FORTH_RSP_NEXT
4424			 
4424			if DEBUG_FORTH_UWORD 
4424						DMARK "UEX" 
4424 f5				push af  
4425 3a 39 44			ld a, (.dmark)  
4428 32 7a ee			ld (debug_mark),a  
442b 3a 3a 44			ld a, (.dmark+1)  
442e 32 7b ee			ld (debug_mark+1),a  
4431 3a 3b 44			ld a, (.dmark+2)  
4434 32 7c ee			ld (debug_mark+2),a  
4437 18 03			jr .pastdmark  
4439 ..			.dmark: db "UEX"  
443c f1			.pastdmark: pop af  
443d			endm  
# End of macro DMARK
443d				CALLMONITOR 
443d cd 28 14			call break_point_state  
4440				endm  
# End of macro CALLMONITOR
4440			endif 
4440			 
4440			 
4440			 
4440 eb				ex de, hl 
4441 22 61 e6			ld (os_tok_ptr), hl 
4444				 
4444				; Don't use next - Skips the first word in uword. 
4444			 
4444 c3 af 1d			jp exec1 
4447			;	NEXT 
4447			 
4447			 
4447			; eof 
# End of file forth_wordsv4.asm
4447			endif 
4447			;;;;;;;;;;;;;; Debug code 
4447			 
4447			 
4447			;if DEBUG_FORTH_PARSE 
4447 .. 00		.nowordfound: db "No match",0 
4450 .. 00		.compword:	db "Comparing word ",0 
4460 .. 00		.nextwordat:	db "Next word at",0 
446d .. 00		.charmatch:	db "Char match",0 
4478			;endif 
4478			if DEBUG_FORTH_JP 
4478			.foundword:	db "Word match. Exec..",0 
4478			endif 
4478			;if DEBUG_FORTH_PUSH 
4478 .. 00		.enddict:	db "Dict end. Push.",0 
4488 .. 00		.push_str:	db "Pushing string",0 
4497 .. 00		.push_num:	db "Pushing number",0 
44a6 .. 00		.data_sp:	db "SP:",0 
44aa .. 00		.wordinhl:	db "Word in HL (2/0):",0 
44bc .. 00		.wordinde:	db "Word in DE (3/0):",0 
44ce .. 00		.wordinbc:	db "Word in BC (4/0):",0 
44e0			;endif 
44e0			;if DEBUG_FORTH_MALLOC 
44e0 .. 00		.push_malloc:	db "Malloc address",0 
44ef			;endif 
44ef			 
44ef			 
44ef			 
44ef			; display malloc address and current data stack pointer  
44ef			 
44ef			malloc_error: 
44ef d5				push de 
44f0 f5				push af 
44f1 e5				push hl 
44f2 cd 88 09			call clear_display 
44f5 11 17 45			ld de, .mallocerr 
44f8 3e 00			ld a,0 
44fa			;	ld de,os_word_scratch 
44fa cd 9b 09			call str_at_display 
44fd 3e 11			ld a, display_row_1+17 
44ff 11 7a ee			ld de, debug_mark 
4502 cd 9b 09			call str_at_display 
4505 cd ab 09			call update_display 
4508				;call break_point_state 
4508 cd 71 58			call cin_wait 
450b			 
450b 3e 20			ld a, ' ' 
450d 32 51 e3			ld (os_view_disable), a 
4510 e1				pop hl 
4511 f1				pop af 
4512 d1				pop de	 
4513				CALLMONITOR 
4513 cd 28 14			call break_point_state  
4516				endm  
# End of macro CALLMONITOR
4516 c9				ret 
4517			 
4517 .. 00		.mallocerr: 	db "Malloc Error",0 
4524			;if DEBUG_FORTH_PUSH 
4524			display_data_sp: 
4524 f5				push af 
4525			 
4525				; see if disabled 
4525			 
4525 3a 51 e3			ld a, (os_view_disable) 
4528 fe 2a			cp '*' 
452a 28 67			jr z, .skipdsp 
452c			 
452c e5				push hl 
452d e5				push hl 
452e e5			push hl 
452f cd 88 09			call clear_display 
4532 e1			pop hl 
4533 7c				ld a,h 
4534 21 65 e6			ld hl, os_word_scratch 
4537 cd b6 0e			call hexout 
453a e1				pop hl 
453b 7d				ld a,l 
453c 21 67 e6			ld hl, os_word_scratch+2 
453f cd b6 0e			call hexout 
4542 21 69 e6			ld hl, os_word_scratch+4 
4545 3e 00			ld a,0 
4547 77				ld (hl),a 
4548 11 65 e6			ld de,os_word_scratch 
454b 3e 28				ld a, display_row_2 
454d cd 9b 09				call str_at_display 
4550 11 aa 44			ld de, .wordinhl 
4553 3e 00			ld a, display_row_1 
4555			 
4555 cd 9b 09				call str_at_display 
4558 11 7a ee			ld de, debug_mark 
455b 3e 11			ld a, display_row_1+17 
455d			 
455d cd 9b 09				call str_at_display 
4560			 
4560				; display current data stack pointer 
4560 11 a6 44			ld de,.data_sp 
4563 3e 30				ld a, display_row_2 + 8 
4565 cd 9b 09				call str_at_display 
4568			 
4568 2a 0d eb			ld hl,(cli_data_sp) 
456b e5				push hl 
456c 7c				ld a,h 
456d 21 65 e6			ld hl, os_word_scratch 
4570 cd b6 0e			call hexout 
4573 e1				pop hl 
4574 7d				ld a,l 
4575 21 67 e6			ld hl, os_word_scratch+2 
4578 cd b6 0e			call hexout 
457b 21 69 e6			ld hl, os_word_scratch+4 
457e 3e 00			ld a,0 
4580 77				ld (hl),a 
4581 11 65 e6			ld de,os_word_scratch 
4584 3e 33				ld a, display_row_2 + 11 
4586 cd 9b 09				call str_at_display 
4589			 
4589			 
4589 cd ab 09			call update_display 
458c cd fd 08			call delay1s 
458f cd fd 08			call delay1s 
4592 e1				pop hl 
4593			.skipdsp: 
4593 f1				pop af 
4594 c9				ret 
4595			 
4595			display_data_malloc: 
4595			 
4595 f5				push af 
4596 e5				push hl 
4597 e5				push hl 
4598 e5			push hl 
4599 cd 88 09			call clear_display 
459c e1			pop hl 
459d 7c				ld a,h 
459e 21 65 e6			ld hl, os_word_scratch 
45a1 cd b6 0e			call hexout 
45a4 e1				pop hl 
45a5 7d				ld a,l 
45a6 21 67 e6			ld hl, os_word_scratch+2 
45a9 cd b6 0e			call hexout 
45ac 21 69 e6			ld hl, os_word_scratch+4 
45af 3e 00			ld a,0 
45b1 77				ld (hl),a 
45b2 11 65 e6			ld de,os_word_scratch 
45b5 3e 28				ld a, display_row_2 
45b7 cd 9b 09				call str_at_display 
45ba 11 e0 44			ld de, .push_malloc 
45bd 3e 00			ld a, display_row_1 
45bf			 
45bf cd 9b 09				call str_at_display 
45c2			 
45c2				; display current data stack pointer 
45c2 11 a6 44			ld de,.data_sp 
45c5 3e 30				ld a, display_row_2 + 8 
45c7 cd 9b 09				call str_at_display 
45ca			 
45ca 2a 0d eb			ld hl,(cli_data_sp) 
45cd e5				push hl 
45ce 7c				ld a,h 
45cf 21 65 e6			ld hl, os_word_scratch 
45d2 cd b6 0e			call hexout 
45d5 e1				pop hl 
45d6 7d				ld a,l 
45d7 21 67 e6			ld hl, os_word_scratch+2 
45da cd b6 0e			call hexout 
45dd 21 69 e6			ld hl, os_word_scratch+4 
45e0 3e 00			ld a,0 
45e2 77				ld (hl),a 
45e3 11 65 e6			ld de,os_word_scratch 
45e6 3e 33				ld a, display_row_2 + 11 
45e8 cd 9b 09				call str_at_display 
45eb			 
45eb cd ab 09			call update_display 
45ee cd fd 08			call delay1s 
45f1 cd fd 08			call delay1s 
45f4 e1				pop hl 
45f5 f1				pop af 
45f6 c9				ret 
45f7			;endif 
45f7			 
45f7			include "forth_autostart.asm" 
45f7			; list of commands to perform at system start up 
45f7			 
45f7			startcmds: 
45f7			;	dw test11 
45f7			;	dw test12 
45f7			;	dw test13 
45f7			;	dw test14 
45f7			;	dw test15 
45f7			;	dw test16 
45f7			;	dw test17 
45f7			;	dw ifthtest1 
45f7			;	dw ifthtest2 
45f7			;	dw ifthtest3 
45f7			;	dw mmtest1 
45f7			;	dw mmtest2 
45f7			;	dw mmtest3 
45f7			;	dw mmtest4 
45f7			;	dw mmtest5 
45f7			;	dw mmtest6 
45f7			;	dw iftest1 
45f7			;	dw iftest2 
45f7			;	dw iftest3 
45f7			;	dw looptest1 
45f7			;	dw looptest2 
45f7			;	dw test1 
45f7			;	dw test2 
45f7			;	dw test3 
45f7			;	dw test4 
45f7			;	dw game2r 
45f7			;	dw game2b1 
45f7			;	dw game2b2 
45f7			 
45f7				; start up words that are actually useful 
45f7			 
45f7 55 46			dw clrstack 
45f9 88 46			dw type 
45fb 49 48			dw stest 
45fd ac 46			dw strncpy 
45ff ea 47			dw list 
4601 0d 47			dw start1 
4603 1f 47			dw start2 
4605			;	dw start3 
4605 32 47			dw start3b 
4607 8a 47			dw start3c 
4609			 
4609				; (unit) testing words 
4609			 
4609 c0 48			dw mtesta 
460b 75 49			dw mtestb 
460d 18 4a			dw mtestc 
460f cd 4a			dw mtestd 
4611 71 4b			dw mteste 
4613			 
4613				; demo/game words 
4613			 
4613 7d 52		        dw game3w 
4615 ab 52		        dw game3p 
4617 c9 52		        dw game3sc 
4619 fa 52		        dw game3vsi 
461b 26 53		        dw game3vs 
461d				 
461d 70 50			dw game2b 
461f de 50			dw game2bf 
4621 28 51			dw game2mba 
4623 be 51			dw game2mbas 
4625 00 52			dw game2mb 
4627			 
4627 31 4d			dw game1 
4629 42 4d			dw game1a 
462b a4 4d			dw game1b 
462d d9 4d			dw game1c 
462f 0f 4e			dw game1d 
4631 40 4e			dw game1s 
4633 54 4e			dw game1t 
4635 69 4e			dw game1f 
4637 9d 4e			dw game1z 
4639 e1 4e			dw game1zz 
463b			 
463b 27 4c			dw test5 
463d 5f 4c			dw test6 
463f 97 4c			dw test7 
4641 ab 4c			dw test8 
4643 d7 4c			dw test9 
4645 ed 4c			dw test10 
4647				 
4647 b8 4f		        dw ssv5 
4649 9c 4f		        dw ssv4 
464b 80 4f		        dw ssv3 
464d 4a 4f		        dw ssv2 
464f d1 4f		        dw ssv1 
4651 19 50		        dw ssv1cpm 
4653			;	dw keyup 
4653			;	dw keydown 
4653			;	dw keyleft 
4653			;	dw keyright 
4653			;	dw 	keyf1 
4653			;	dw keyf2 
4653			;	dw keyf3 
4653			;	dw keyf4 
4653			;	dw keyf5 
4653			;	dw keyf6 
4653			;	dw keyf7 
4653			;	dw keyf8 
4653			;	dw keyf9 
4653			;	dw keyf10 
4653			;	dw keyf11 
4653			;	dw keyf12 
4653			;	dw keytab 
4653			;	dw keycr 
4653			;	dw keyhome 
4653			;	dw keyend 
4653			;	dw keybs 
4653 00 00			db 0, 0	 
4655			 
4655			 
4655			; clear stack  
4655			 
4655 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
4688			 
4688			; type ( addr count - ) 
4688 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
46ac			 
46ac			; some direct memory words 
46ac			; strncpy ( len t f -- t ) 
46ac			 
46ac .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
470d			 
470d .. 00		start1:     	db ": bpon $0000 bp ;",0 
471f .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4732			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
4732 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
478a .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
47ea			 
47ea			 
47ea			; a handy word to list items on the stack 
47ea			 
47ea .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
4849			 
4849			 
4849			; test stack  
4849			; rnd8 stest 
4849			 
4849 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
48c0			 
48c0			; random malloc and free cycles 
48c0			 
48c0 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4975			 
4975			; fixed malloc and free cycles 
4975			 
4975 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4a18			 
4a18			; fixed double string push and drop cycle  
4a18			 
4a18 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4acd			 
4acd			; consistent fixed string push and drop cycle  
4acd			 
4acd .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4b71			 
4b71 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4c27			 
4c27			;test1:		db ": aa 1 2 3 ;", 0 
4c27			;test2:     	db "111 aa 888 999",0 
4c27			;test3:     	db ": bb 77 ;",0 
4c27			;test4:     	db "$02 $01 do i . loop bb",0 
4c27			 
4c27 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4c5f .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4c97 .. 00		test7:     	db ": box hline vline ;",0 
4cab .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4cd7 .. 00		test9:     	db ": sw $01 adsp world ;",0 
4ced .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4d12 .. 00		test11:     	db "hello create .",0 
4d21 .. 00		test12:     	db "hello2 create .",0 
4d31			 
4d31			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4d31			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4d31			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4d31			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4d31			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4d31			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4d31			 
4d31			;iftest1:     	db "$0001 IF cls .",0 
4d31			;iftest2:     	db "$0000 IF cls .",0 
4d31			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4d31			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4d31			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4d31			 
4d31			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d31			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d31			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4d31			 
4d31			 
4d31			 
4d31			; a small guess the number game 
4d31			 
4d31 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4d42 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4da4			 
4da4 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4dd9 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4e0f .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4e40 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4e54 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4e69 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4e9d .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4ee1			 
4ee1			; Using 'ga' save a high score across multiple runs using external storage 
4ee1			 
4ee1 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
4f4a			 
4f4a			 
4f4a			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4f4a			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4f4a			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4f4a			 
4f4a			; simple screen saver to test code memory reuse to destruction 
4f4a			 
4f4a .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
4f80 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
4f9c .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
4fb8 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
4fd1 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5019 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5070			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5070			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5070			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5070			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5070			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5070			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5070			 
5070			 
5070			 
5070			; minesweeper/battleship finding game 
5070			; draws a game board of random ship/mine positions 
5070			; user enters coords to see if it hits on 
5070			; game ends when all are hit 
5070			; when hit or miss says how many may be in the area 
5070			 
5070			; setup the game board and then hide it 
5070 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
50de .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5128			; prompt for where to target 
5128 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
51be .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
51e3			; TODO see if the entered coords hits or misses pushes char hit of miss 
51e3 .. 00		game2mbht:      db ": mbckht nop ;",0 
51f2 .. 00		game2mbms:      db ": mbcms nop ;",0 
5200			; TODO how many might be near by 
5200 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
527d			 
527d			; Game 3 
527d			 
527d			; Vert scroller ski game - avoid the trees! 
527d			 
527d			; v0 score (ie turns) 
527d			; v1 player pos 
527d			; v2 left wall 
527d			; v3 right wall 
527d			 
527d			; Draw side walls randomly 
527d			 
527d .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
52ab			 
52ab			; Draw player 
52ab .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
52c9			 
52c9			; TODO Get Key 
52c9			 
52c9			; TODO Move left right 
52c9			 
52c9			; scroll and move walls a bit 
52c9			 
52c9 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
52fa			 
52fa			; main game loop 
52fa			 
52fa .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5326 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5365			 
5365			; key board defs 
5365			 
5365 .. 00		keyup:       db ": keyup $05 ;",0 
5373 .. 00		keydown:       db ": keydown $0a ;",0 
5383 .. 00		keyleft:       db ": keyleft $0b ;",0 
5393 .. 00		keyright:       db ": keyright $0c ;",0 
53a4 .. 00		keyf1:       db ": keyf1 $10 ;",0 
53b2 .. 00		keyf2:       db ": keyf2 $11 ;",0 
53c0 .. 00		keyf3:       db ": keyf3 $12 ;",0 
53ce .. 00		keyf4:       db ": keyf4 $13 ;",0 
53dc .. 00		keyf5:       db ": keyf5 $14 ;",0 
53ea .. 00		keyf6:       db ": keyf6 $15 ;",0 
53f8 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5406 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5414 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5422 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5431 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5440 .. 00		keyf12:       db ": keyf12 $1b ;",0 
544f			 
544f .. 00		keytab:       db ": keytab $09 ;",0 
545e .. 00		keycr:       db ": keycr $0d ;",0 
546c .. 00		keyhome:       db ": keyhome $0e ;",0 
547c .. 00		keyend:       db ": keyend $0f ;",0 
548b .. 00		keybs:       db ": keybs $08 ;",0 
5499			 
5499			   
5499			 
5499			 
5499			 
5499			; eof 
# End of file forth_autostart.asm
5499			 
5499 .. 00		sprompt1: db "Startup load...",0 
54a9 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
54bf			 
54bf			 
54bf			 
54bf			 
54bf			forth_startup: 
54bf 21 f7 45			ld hl, startcmds 
54c2 3e 00			ld a, 0 
54c4 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
54c7			 
54c7 e5			.start1:	push hl 
54c8 cd 88 09			call clear_display 
54cb 11 99 54			ld de, sprompt1 
54ce 3e 00		        ld a, display_row_1 
54d0 cd 9b 09			call str_at_display 
54d3 11 a9 54			ld de, sprompt2 
54d6 3e 28		        ld a, display_row_2 
54d8 cd 9b 09			call str_at_display 
54db e1				pop hl 
54dc e5				push hl 
54dd 5e				ld e,(hl) 
54de 23				inc hl 
54df 56				ld d,(hl) 
54e0 3e 50		        ld a, display_row_3 
54e2 cd 9b 09			call str_at_display 
54e5 cd ab 09			call update_display 
54e8			 
54e8			 
54e8 3a 86 e7			ld a, (os_last_cmd) 
54eb fe 00			cp 0 
54ed 28 05			jr z, .startprompt 
54ef cd f1 08			call delay250ms 
54f2 18 24			jr .startdo 
54f4				 
54f4				 
54f4			 
54f4			.startprompt: 
54f4			 
54f4 3e 9f			ld a,display_row_4 + display_cols - 1 
54f6 11 2b 19		        ld de, endprg 
54f9 cd 9b 09			call str_at_display 
54fc cd ab 09			call update_display 
54ff cd fd 08			call delay1s 
5502 cd 71 58			call cin_wait 
5505						 
5505 fe 2a			cp '*' 
5507 28 5e			jr z, .startupend1 
5509 fe 23			cp '#' 
550b 20 07			jr nz, .startno 
550d 3e 01			ld a, 1 
550f 32 86 e7			ld (os_last_cmd),a 
5512 18 04			jr .startdo 
5514 fe 31		.startno:	cp '1' 
5516 28 3a			jr z,.startnxt  
5518			 
5518				; exec startup line 
5518			.startdo:	 
5518 e1				pop hl 
5519 e5				push hl 
551a				 
551a 5e				ld e,(hl) 
551b 23				inc hl 
551c 56				ld d,(hl) 
551d eb				ex de,hl 
551e			 
551e e5				push hl 
551f			 
551f 3e 00			ld a, 0 
5521				;ld a, FORTH_END_BUFFER 
5521 cd 1e 10			call strlent 
5524 23				inc hl   ; include zero term to copy 
5525 06 00			ld b,0 
5527 4d				ld c,l 
5528 e1				pop hl 
5529 11 60 e3			ld de, scratch 
552c ed b0			ldir 
552e			 
552e			 
552e 21 60 e3			ld hl, scratch 
5531 cd 6c 1d			call forthparse 
5534 cd ac 1d			call forthexec 
5537 cd c3 1c			call forthexec_cleanup 
553a			 
553a 3e 78			ld a, display_row_4 
553c 11 cf 16			ld de, endprog 
553f			 
553f cd ab 09			call update_display		 
5542			 
5542 3a 86 e7			ld a, (os_last_cmd) 
5545 fe 00			cp 0 
5547 20 09			jr nz, .startnxt 
5549 cd 2d 19			call next_page_prompt 
554c cd 88 09		        call clear_display 
554f cd ab 09			call update_display		 
5552			 
5552				; move onto next startup line? 
5552			.startnxt: 
5552			 
5552 cd f1 08			call delay250ms 
5555 e1				pop hl 
5556			 
5556 23				inc hl 
5557 23				inc hl 
5558			 
5558 e5				push hl 
5559 5e				ld e, (hl) 
555a 23				inc hl 
555b 56				ld d, (hl) 
555c e1				pop hl 
555d				; TODO replace 0 test 
555d			 
555d eb				ex de, hl 
555e cd de 0b			call ishlzero 
5561			;	ld a,e 
5561			;	add d 
5561			;	cp 0    ; any left to do? 
5561 eb				ex de, hl 
5562 c2 c7 54			jp nz, .start1 
5565 18 01			jr .startupend 
5567			 
5567 e1			.startupend1: pop hl 
5568			.startupend: 
5568			 
5568 cd 88 09			call clear_display 
556b cd ab 09			call update_display 
556e c9				ret 
556f			 
556f			 
556f			; stack over and underflow checks 
556f			 
556f			; init the words to detect the under/overflow 
556f			 
556f			chk_stk_init: 
556f				; a vague random number to check so we dont get any "lucky" hits 
556f 3e 2d			ld a, 45 
5571 6f				ld l, a 
5572 00				nop 
5573 3e 17			ld a, 23 
5575 67				ld h, a 
5576			 
5576 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
5579			 
5579			;	ld (chk_stund), hl	; stack points.... 
5579 22 00 ef			ld (chk_stovr), hl 
557c 22 0b eb			ld (chk_ret_und), hl 
557f 22 c9 ea			ld (chk_ret_ovr), hl 
5582 22 c7 e9			ld (chk_loop_ovr), hl 
5585 22 c5 e8			ld (chk_data_ovr), hl 
5588 c9				ret 
5589				 
5589			check_stacks: 
5589				; check all stack words 
5589			 
5589 e5				push hl 
558a d5				push de 
558b			 
558b			;	ld de,(chk_word) 
558b			;	ld hl, (chk_stund)	; stack points.... 
558b			;	if DEBUG_STK_FAULT 
558b			;		DMARK "FAa" 
558b			;		CALLMONITOR 
558b			;	endif 
558b			;	call cmp16 
558b			;	jp z, .chk_faulta 
558b			; 
558b			;	ld de, sfaultsu 
558b			;	jp .chk_fault 
558b			 
558b 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
558e ed 5b 47 e3		ld de,(chk_word) 
5592				if DEBUG_STK_FAULT 
5592					DMARK "FAb" 
5592					CALLMONITOR 
5592				endif 
5592 cd d3 0b			call cmp16 
5595 28 06			jr z, .chk_fault1 
5597 11 38 56			ld de, sfaultso 
559a c3 ec 55			jp .chk_fault 
559d			.chk_fault1:  
559d 2a 0b eb			ld hl, (chk_ret_und) 
55a0 ed 5b 47 e3		ld de,(chk_word) 
55a4				if DEBUG_STK_FAULT 
55a4					DMARK "FAU" 
55a4					CALLMONITOR 
55a4				endif 
55a4 cd d3 0b			call cmp16 
55a7 ca b0 55			jp z, .chk_fault2 
55aa 11 48 56			ld de, sfaultru 
55ad c3 ec 55			jp .chk_fault 
55b0			.chk_fault2:  
55b0 2a c9 ea			ld hl, (chk_ret_ovr) 
55b3 ed 5b 47 e3		ld de,(chk_word) 
55b7				if DEBUG_STK_FAULT 
55b7					DMARK "FA1" 
55b7					CALLMONITOR 
55b7				endif 
55b7 cd d3 0b			call cmp16 
55ba ca c3 55			jp z, .chk_fault3 
55bd 11 56 56			ld de, sfaultro 
55c0 c3 ec 55			jp .chk_fault 
55c3			.chk_fault3:  
55c3 2a c7 e9			ld hl, (chk_loop_ovr) 
55c6 ed 5b 47 e3		ld de,(chk_word) 
55ca				if DEBUG_STK_FAULT 
55ca					DMARK "FA2" 
55ca					CALLMONITOR 
55ca				endif 
55ca cd d3 0b			call cmp16 
55cd ca d6 55			jp z, .chk_fault4 
55d0 11 70 56			ld de, sfaultlo 
55d3 c3 ec 55			jp .chk_fault 
55d6			.chk_fault4:  
55d6 2a c5 e8			ld hl, (chk_data_ovr) 
55d9 ed 5b 47 e3		ld de,(chk_word) 
55dd				if DEBUG_STK_FAULT 
55dd					DMARK "FA3" 
55dd					CALLMONITOR 
55dd				endif 
55dd cd d3 0b			call cmp16 
55e0 ca e9 55			jp z, .chk_fault5 
55e3 11 8a 56			ld de, sfaultdo 
55e6 c3 ec 55			jp .chk_fault 
55e9			 
55e9			 
55e9			.chk_fault5:  
55e9 d1				pop de 
55ea e1				pop hl 
55eb			 
55eb c9				ret 
55ec			 
55ec cd 88 09		.chk_fault: 	call clear_display 
55ef 3e 28				ld a, display_row_2 
55f1 cd 9b 09				call str_at_display 
55f4 11 1a 56				   ld de, .stackfault 
55f7 3e 00				ld a, display_row_1 
55f9 cd 9b 09				call str_at_display 
55fc 11 7a ee				    ld de, debug_mark 
55ff 3e 11				ld a, display_row_1+17 
5601 cd 9b 09				call str_at_display 
5604 cd ab 09				call update_display 
5607			 
5607				; prompt before entering montior for investigating issue 
5607			 
5607 3e 78			ld a, display_row_4 
5609 11 cf 16			ld de, endprog 
560c			 
560c cd ab 09			call update_display		 
560f			 
560f cd 2d 19			call next_page_prompt 
5612			 
5612 d1				pop de 
5613 e1				pop hl 
5614 cd 23 17				call monitor 
5617 c3 1d 16				jp warmstart 
561a					;jp 0 
561a					;halt 
561a			 
561a			 
561a			 
561a .. 00		.stackfault: 	db "Stack fault:",0 
5627			 
5627 .. 00		sfaultsu: 	db	"Stack under flow",0 
5638 .. 00		sfaultso: 	db	"Stack over flow",0 
5648 .. 00		sfaultru:	db "RTS underflow",0 
5656 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5670 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
568a .. 00		sfaultdo:	db "DTS overflow", 0 
5697			 
5697			 
5697			fault_dsp_under: 
5697 11 a9 56			ld de, .dsp_under 
569a c3 59 57			jp .show_fault 
569d			 
569d			fault_rsp_under: 
569d 11 b7 56			ld de, .rsp_under 
56a0 c3 59 57			jp .show_fault 
56a3			fault_loop_under: 
56a3 11 c5 56			ld de, .loop_under 
56a6 c3 59 57			jp .show_fault 
56a9			 
56a9 .. 00		.dsp_under: db "DSP Underflow",0 
56b7 .. 00		.rsp_under: db "RSP Underflow",0 
56c5 .. 00		.loop_under: db "LOOP Underflow",0 
56d4			 
56d4			 
56d4 d5			type_faultn: 	push de 
56d5 e5					push hl 
56d6 cd 88 09				call clear_display 
56d9 11 00 57				   ld de, .typefaultn 
56dc 3e 00				ld a, display_row_1 
56de cd 9b 09				call str_at_display 
56e1 11 7a ee				    ld de, debug_mark 
56e4 3e 11				ld a, display_row_1+17 
56e6 cd 9b 09				call str_at_display 
56e9 cd ab 09				call update_display 
56ec			 
56ec				; prompt before entering montior for investigating issue 
56ec			 
56ec 3e 78			ld a, display_row_4 
56ee 11 cf 16			ld de, endprog 
56f1			 
56f1 cd ab 09			call update_display		 
56f4			 
56f4 cd 2d 19			call next_page_prompt 
56f7			 
56f7 e5					push hl 
56f8 d5					push de 
56f9 cd 23 17				call monitor 
56fc c3 1d 16				jp warmstart 
56ff 76					halt 
5700			 
5700			 
5700 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5717			 
5717 d5			type_faults: 	push de 
5718 e5					push hl 
5719 cd 88 09				call clear_display 
571c 11 42 57				   ld de, .typefaults 
571f 3e 00				ld a, display_row_1 
5721 cd 9b 09				call str_at_display 
5724 11 7a ee				    ld de, debug_mark 
5727 3e 11				ld a, display_row_1+17 
5729 cd 9b 09				call str_at_display 
572c cd ab 09				call update_display 
572f			 
572f				; prompt before entering montior for investigating issue 
572f			 
572f 3e 78			ld a, display_row_4 
5731 11 cf 16			ld de, endprog 
5734			 
5734 cd ab 09			call update_display		 
5737			 
5737 cd 2d 19			call next_page_prompt 
573a			 
573a e1					pop hl 
573b d1					pop de 
573c cd 23 17				call monitor 
573f c3 1d 16				jp warmstart 
5742			 
5742			 
5742 .. 00		.typefaults: db "STR Type Expected TOS!",0 
5759			 
5759			.show_fault: 	 
5759 d5					push de 
575a cd 88 09				call clear_display 
575d d1					pop de 
575e 3e 00				ld a, display_row_1 
5760 cd 9b 09				call str_at_display 
5763 11 7a ee				    ld de, debug_mark 
5766 3e 11				ld a, display_row_1+17 
5768 cd 9b 09				call str_at_display 
576b cd ab 09				call update_display 
576e			 
576e				; prompt before entering montior for investigating issue 
576e			 
576e 3e 78			ld a, display_row_4 
5770 11 cf 16			ld de, endprog 
5773			 
5773 cd ab 09			call update_display		 
5776			 
5776 cd 2d 19			call next_page_prompt 
5779			 
5779 e1					pop hl 
577a d1					pop de 
577b cd 23 17				call monitor 
577e			; do a dump to cli and not warmstart so we preserve all of the uwords.  
577e			; TODO Make optional fault restart to cli or warm boot? 
577e					;jp warmstart 
577e c3 75 16				jp cli 
5781 76					halt 
5782			 
5782			; handle the auto run of code from files in storage 
5782			 
5782			 
5782			if STORAGE_SE 
5782			 
5782			sprompt3: db "Loading from start-up file?:",0 
5782			sprompt4: db "(Y=Any key/N=No)",0 
5782			 
5782			 
5782			forth_autoload: 
5782			 
5782				; load block 0 of store 1 
5782				 
5782				ld a, $fe      ; bit 0 clear 
5782				ld (spi_device), a 
5782			 
5782				call storage_get_block_0 
5782			 
5782				ld a, (store_page+STORE_0_AUTOFILE) 
5782			 
5782				cp 0 
5782				ret z     ; auto start not enabled 
5782			 
5782				call clear_display 
5782			 
5782				; set bank 
5782			 
5782					ld a, (store_page+STORE_0_BANKRUN) 
5782					ld (spi_device), a 
5782			 
5782				; get file id to load from and get the file name to display 
5782			 
5782					ld a, (store_page+STORE_0_FILERUN) 
5782			 
5782					ld l, 0 
5782					ld h, a 
5782					ld de, store_page 
5782			 
5782					if DEBUG_FORTH_WORDS 
5782						DMARK "ASp" 
5782						CALLMONITOR 
5782					endif 
5782					call storage_read 
5782			 
5782					if DEBUG_FORTH_WORDS 
5782						DMARK "ASr" 
5782						CALLMONITOR 
5782					endif 
5782			 
5782					call ishlzero 
5782					ret z             ; file not found 
5782			 
5782					ld a, display_row_2 + 10 
5782					ld de, store_page+3 
5782					call str_at_display 
5782				 
5782			; 
5782			 
5782				ld a, display_row_1+5 
5782				ld de, sprompt3 
5782				call str_at_display 
5782				ld a, display_row_3+15 
5782				ld de, sprompt4 
5782				call str_at_display 
5782			 
5782				call update_display 
5782			 
5782				call cin_wait 
5782				cp 'n' 
5782				ret z 
5782				cp 'N' 
5782				ret z 
5782			 
5782				call delay1s 
5782			 
5782				ld a, (store_page+2) 
5782				ld (store_openmaxext), a    ; save count of ext 
5782				ld a, 1  
5782				ld (store_openext), a    ; save count of ext 
5782			 
5782			.autof:  
5782				ld l , a 
5782				 
5782				ld a, (store_page) 
5782				ld h, a	 
5782				ld de, store_page 
5782					if DEBUG_FORTH_WORDS 
5782						DMARK "ASl" 
5782						CALLMONITOR 
5782					endif 
5782					call storage_read 
5782				call ishlzero 
5782				ret z 
5782			;	jr z, .autoend 
5782			 
5782					if DEBUG_FORTH_WORDS 
5782						DMARK "ASc" 
5782						CALLMONITOR 
5782					endif 
5782				ld de, store_page+2 
5782				ld a, display_row_4 
5782				call str_at_display 
5782			 
5782				call update_display 
5782				call delay250ms 
5782			 
5782			 
5782			 
5782				ld hl, store_page+2 
5782				call forthparse 
5782				call forthexec 
5782				call forthexec_cleanup 
5782			 
5782				 
5782				ld a, (store_openext) 
5782				inc a 
5782				ld (store_openext), a    ; save count of ext 
5782			 
5782				jr .autof 
5782			;.autofdone: 
5782			; 
5782			;		if DEBUG_FORTH_WORDS 
5782			;			DMARK "ASx" 
5782			;			CALLMONITOR 
5782			;		endif 
5782			;;	call clear_display 
5782			;	ret 
5782			 
5782			 
5782			 
5782			endif 
5782			 
5782			 
5782			; eof 
# End of file forth_kernel.asm
5782			;include "nascombasic.asm" 
5782			 
5782			 
5782			; find out where the code ends if loaded into RAM (for SC114) 
5782			;endofcode:  
5782			;	nop 
5782			 
5782			 
5782			; eof 
5782			 
# End of file main.asm
5782			;include "firmware_lcd_4x40.asm" 
5782			;;include "firmware_lcd_4x20.asm" 
5782			include "firmware_cpm_display.asm" 
5782			 
5782			; Serial display interface for SC114 
5782			 
5782			 
5782			display_row_1: equ 0 
5782			display_row_2: equ display_row_1+display_cols 
5782			display_row_3: equ display_row_2 + display_cols 
5782			display_row_4: equ display_row_3 + display_cols 
5782			 
5782			kLCDWidth:  EQU display_cols             ;Width in characters 
5782			kLCD_Line1: EQU 0x00  
5782			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5782			; E1 
5782			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5782			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5782			 
5782			lcd_init: 
5782				; no init as handled by the SCM bios 
5782 c9				ret 
5783			 
5783			 
5783			; low level functions for direct screen writes 
5783			 
5783			; output char at pos? 
5783			fLCD_Str: 
5783			        ;out (SC114_SIO_1_OUT),a 
5783 c5				push bc 
5784 d5				push de 
5785 5f				ld e, a 
5786			; TODO Replace with CP/M BIOS call 
5786 0e 02			ld c, $02 
5788 cd 05 00			call 5 
578b d1				pop de 
578c c1				pop bc 
578d c9				ret 
578e			 
578e			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
578e			fLCD_Pos: 
578e				; use ASCII escape to position 
578e			        ;out (SC114_SIO_1_OUT),a 
578e c5				push bc 
578f d5				push de 
5790 5f				ld e, a 
5791 0e 02			ld c, $02 
5793			; TODO Replace with CP/M BIOS call 
5793 cd 05 00			call 5 
5796 d1				pop de 
5797 c1				pop bc 
5798			 
5798 c9				ret 
5799			 
5799			; output char at pos 
5799			fLCD_Data: 
5799			      ;  out (SC114_SIO_1_OUT),a 
5799 c5				push bc 
579a d5				push de 
579b 0e 02			ld c, $02 
579d 5f				ld e, a 
579e			; TODO Replace with CP/M BIOS call 
579e cd 05 00			call 5 
57a1 d1				pop de 
57a2 c1				pop bc 
57a3			 
57a3 c9				ret 
57a4			 
57a4			; ascii cls  
57a4			 
57a4 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
57a8			 
57a8 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
57bf			;.clscpm: db 3, $3c,"$" 
57bf			 
57bf			; write the frame buffer given in hl to hardware  
57bf			write_display: 
57bf			 
57bf			API: equ 0 
57bf			 
57bf			if API 
57bf				push bc 
57bf				ld b, 4 
57bf			 
57bf			        ld (display_write_tmp), hl 	  
57bf			 
57bf				; clear and home cursor 
57bf			 
57bf				ld c, 9 
57bf				ld de, .cls 
57bf			; TODO Replace with CP/M BIOS call 
57bf				call 5 
57bf			 
57bf			 
57bf			.writeln: 
57bf			 
57bf				ld de, (display_write_tmp) 
57bf				ld c, 6 
57bf			; TODO Replace with CP/M BIOS call 
57bf				rst $30 
57bf				ld c, 7 
57bf				rst $30 
57bf			 
57bf				ld hl, (display_write_tmp) 
57bf				ld de, display_cols 
57bf				add hl,de 
57bf				ld (display_write_tmp),hl 
57bf			 
57bf				djnz  .writeln 
57bf			 
57bf				pop bc 
57bf			 
57bf			 
57bf				ret 
57bf			endif 
57bf e5				push hl 
57c0 c5				push bc 
57c1 d5				push de 
57c2			 
57c2			;	ld c, 2 
57c2			;	;ld de, .cls 
57c2			;	ld a, 27 
57c2			;	rst $30 
57c2			;	ld c, 2 
57c2			;	;ld de, .cls 
57c2			;	ld a, '[' 
57c2			;	rst $30 
57c2			; 
57c2			;	ld c, 2 
57c2			;	;ld de, .cls 
57c2			;	ld a, 'H' 
57c2			;	rst $30 
57c2			; 
57c2			 
57c2			 
57c2			; lots of CR/LF 
57c2			;	ld c, 9 
57c2			;	ld de, .clscpm 
57c2			;	call 5 
57c2			 
57c2			; xterm cls 
57c2 0e 02			ld c, 2 
57c4 1e 1b			ld e, 27 
57c6 cd 05 00			call 5 
57c9			; cls causes too much flicker 
57c9			;	ld c, 2 
57c9			;	ld e, 'c' 
57c9			;	call 5 
57c9			 
57c9			; use xterm home instead 
57c9 0e 02			ld c, 2 
57cb 1e 5b			ld e, '[' 
57cd cd 05 00			call 5 
57d0 0e 02			ld c, 2 
57d2 1e 48			ld e, 'H' 
57d4 cd 05 00			call 5 
57d7			LLL: equ 0 
57d7			 
57d7			if LLL 
57d7			 
57d7				ld c, 2 
57d7				;ld de, .cls 
57d7				ld e, 27 
57d7			; TODO Replace with CP/M BIOS call 
57d7				call 5 
57d7			 
57d7			 
57d7				ld c, 2 
57d7				;ld de, .cls 
57d7				ld e, '[' 
57d7			; TODO Replace with CP/M BIOS call 
57d7				call 5 
57d7				ld c, 2 
57d7				;ld de, .cls 
57d7				ld e, '2' 
57d7			; TODO Replace with CP/M BIOS call 
57d7				call 5 
57d7				ld c, 2 
57d7				;ld de, .cls 
57d7				ld e, 'J' 
57d7			; TODO Replace with CP/M BIOS call 
57d7				call 5 
57d7			 
57d7			endif 
57d7			 
57d7 d1				pop de 
57d8 c1				pop bc 
57d9 e1				pop hl 
57da			 
57da			 
57da 22 d8 eb		        ld (display_write_tmp), hl 	  
57dd 3e 00			ld a, kLCD_Line1 
57df			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
57df 06 28			ld b, display_cols 
57e1 ed 5b d8 eb		ld de, (display_write_tmp) 
57e5 cd 68 58			call write_len_string 
57e8				 
57e8			 
57e8 e5			push hl 
57e9 d5			push de 
57ea c5			push bc 
57eb 0e 02			ld c, 2 
57ed 1e 0a			ld e, 10 
57ef cd 05 00			call 5 
57f2 0e 02			ld c, 2 
57f4 1e 0d			ld e, 13 
57f6 cd 05 00			call 5 
57f9			; TODO Replace with CP/M BIOS call 
57f9				;rst $30 
57f9 c1			pop bc 
57fa d1			pop de 
57fb e1			pop hl 
57fc			 
57fc				 
57fc 2a d8 eb			ld hl, (display_write_tmp) 
57ff 11 28 00			ld de, display_cols 
5802 19				add hl,de 
5803 22 d8 eb			ld (display_write_tmp),hl 
5806			 
5806				 
5806 3e 28			ld a, kLCD_Line2 
5808			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5808 06 28			ld b, display_cols 
580a ed 5b d8 eb		ld de, (display_write_tmp) 
580e cd 68 58			call write_len_string 
5811				 
5811 2a d8 eb			ld hl, (display_write_tmp) 
5814 11 28 00			ld de, display_cols 
5817 19				add hl,de 
5818 22 d8 eb			ld (display_write_tmp),hl 
581b			 
581b e5			push hl 
581c d5			push de 
581d c5			push bc 
581e 0e 07			ld c, 7 
5820			; TODO Replace with CP/M BIOS call 
5820				;rst $30 
5820 0e 02			ld c, 2 
5822 1e 0a			ld e, 10 
5824 cd 05 00			call 5 
5827 0e 02			ld c, 2 
5829 1e 0d			ld e, 13 
582b cd 05 00			call 5 
582e c1			pop bc 
582f d1			pop de 
5830 e1			pop hl 
5831			 
5831				 
5831 3e 50			ld a, kLCD_Line3 
5833			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5833 06 28			ld b, display_cols 
5835 ed 5b d8 eb		ld de, (display_write_tmp) 
5839 cd 68 58			call write_len_string 
583c				 
583c 2a d8 eb			ld hl, (display_write_tmp) 
583f 11 28 00			ld de, display_cols 
5842 19				add hl,de 
5843 22 d8 eb			ld (display_write_tmp),hl 
5846			 
5846 e5			push hl 
5847 d5			push de 
5848 c5			push bc 
5849 0e 07			ld c, 7 
584b			; TODO Replace with CP/M BIOS call 
584b				;rst $30 
584b 0e 02			ld c, 2 
584d 1e 0a			ld e, 10 
584f cd 05 00			call 5 
5852 0e 02			ld c, 2 
5854 1e 0d			ld e, 13 
5856 cd 05 00			call 5 
5859 c1			pop bc 
585a d1			pop de 
585b e1			pop hl 
585c			 
585c				 
585c 3e 78			ld a, kLCD_Line4 
585e			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
585e 06 28			ld b, display_cols 
5860 ed 5b d8 eb		ld de, (display_write_tmp) 
5864 cd 68 58			call write_len_string 
5867 c9					ret 
5868			 
5868			 
5868				; write out a fixed length string given in b from de 
5868			 
5868 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5869 cd 99 57		            CALL fLCD_Data      ;Write character to display 
586c 13				inc de 
586d 10 f9			djnz write_len_string 
586f c9				ret 
5870			 
5870			 
5870			; eof 
# End of file firmware_cpm_display.asm
5870			;include "firmware_key_5x10.asm" 
5870			;;include "firmware_key_4x10.asm" 
5870			include "firmware_key_cpm.asm" 
5870			; Serial keyboard interface for SC114 
5870			 
5870			 
5870			key_init: 
5870				; no init as handled by the SCM bios 
5870 c9				ret 
5871			 
5871			 
5871			cin_wait: 
5871			;	ld a, 0 
5871			;	ret 
5871			 
5871				;in a,(SC114_SIO_1_IN) 
5871			        ; Use SCM API to get from whatever console device we are using 
5871			 
5871			; TODO Replace with CP/M BIOS call 
5871 c5				push bc 
5872 0e 01			ld c, $01 
5874 cd 05 00			call 5 
5877 c1				pop bc 
5878 c9				ret 
5879			 
5879			cin: 
5879			 
5879			 
5879 c5				push bc 
587a			 
587a				; any key waiting to process? 
587a			; TODO Replace with CP/M BIOS call 
587a 0e 06			ld c, $06 
587c cd 05 00			call 5 
587f 28 0d			jr z, .cin_skip 
5881			 
5881				; yep, get it 
5881			 
5881 0e 01			ld c, $01 
5883			; TODO Replace with CP/M BIOS call 
5883 cd 05 00			call 5 
5886			 
5886 fe 7f			cp $7f     ; back space 
5888 20 02			jr nz, .skipbs 
588a 3e 08			ld a, KEY_BS 
588c			.skipbs: 
588c			 
588c c1				pop bc 
588d c9				ret 
588e			.cin_skip: 
588e 3e 00			ld a, 0 
5890 c1				pop bc 
5891 c9				ret 
5892			 
5892			 
5892			 
5892			 
# End of file firmware_key_cpm.asm
5892			endofcode:  
5892			baseram:  
5892 00				nop 
5893			 
5893			heap_start: equ baseram+15  ; Starting address of heap 
5893			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5893			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5893			;VDU:  EQU     endofcode           ; BASIC Work space 
5893			; eof 
5893			 
# End of file os_mega_cpm.asm
5893
