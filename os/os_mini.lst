# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 ad 14			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 0   ; 1  
0003			DEBUG_FORTH_PUSH: equ 0   ; 1  
0003			DEBUG_FORTH_UWORD: equ 0   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ os_input  
0003			os_new_parse_len: equ os_new_malloc + 2  
0003			os_new_word_len: equ os_new_parse_len + 2  
0003			os_new_work_ptr: equ os_new_word_len + 2  
0003			os_new_src_ptr: equ os_new_work_ptr + 2  
0003			os_new_exec: equ os_new_src_ptr + 2  
0003			os_new_exec_ptr: equ os_new_exec + 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ scratch - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd ba 09				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd ba 09				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd ba 09				call clear_display  
0023			  
0023			  
0023 cd 60 51				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd a9 52			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd b6 0f				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd dd 09			call update_display  
0032 cd 3e 09			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd bf 09			call fill_display  
003a cd dd 09			call update_display  
003d cd 3e 09			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd bf 09			call fill_display  
0045 cd dd 09			call update_display  
0048 cd 3e 09			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd bf 09			call fill_display  
0050 cd dd 09			call update_display  
0053 cd 3e 09			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd cd 09			call str_at_display  
005e cd dd 09			call update_display  
0061			  
0061			  
0061 cd 3e 09			call delay1s  
0064 cd 3e 09			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd cd 09			call str_at_display  
006f cd dd 09			call update_display  
0072 cd 3e 09			call delay1s  
0075 cd 3e 09			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 e3 f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a e3 f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 e3 f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a e3 f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 e3 f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a e5 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a e2 f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 e2 f9			ld (spi_device), a 
01e0 32 e5 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a e3 f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 e3 f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a e3 f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 e3 f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a e3 f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 e3 f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a e3 f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 e3 f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 23 09			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a e3 f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 e3 f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a e3 f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 e3 f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a e3 f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 e3 f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a e3 f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 e3 f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 23 09			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a e3 f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 e3 f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a e3 f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 e3 f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 ba ef			ld hl,scratch+2 
02bb cd ca 0e			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 db f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 bf ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a db f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a db f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 db f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 db f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 e0 ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a e0 ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a db f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 db f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 e0 ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 db f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd d7 12			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e						CALLMONITOR 
033e					endif 
033e cd 77 05			call storage_findnextid 
0341			 
0341 cd 3c 0b			call ishlzero 
0344			;	ld a, l 
0344			;	add h 
0344			;	cp 0 
0344 c8				ret z			; block not found so EOF 
0345			 
0345 11 e8 f9			ld de, store_page 
0348 cd 09 03			call storage_read_block 
034b			 
034b 3a ea f9			ld a, (store_page+2)	 ; get extent count 
034e 6f				ld l, a 
034f 26 00			ld h, 0 
0351 c9			 	ret 
0352			 
0352			 
0352			; Write Block 
0352			; ----------- 
0352			; 
0352			; With current bank 
0352			;  
0352			; Get block number to write 
0352			; Write physical blocks starting at start block from buffer 
0352			  
0352			storage_write_block: 
0352				; TODO bank selection 
0352			 
0352				; for each of the physical blocks read it into the buffer 
0352 06 40			ld b, STORE_BLOCK_PHY 
0354			 
0354				if DEBUG_STORESE 
0354					DMARK "SWB" 
0354 f5				push af  
0355 3a 69 03			ld a, (.dmark)  
0358 32 bd fb			ld (debug_mark),a  
035b 3a 6a 03			ld a, (.dmark+1)  
035e 32 be fb			ld (debug_mark+1),a  
0361 3a 6b 03			ld a, (.dmark+2)  
0364 32 bf fb			ld (debug_mark+2),a  
0367 18 03			jr .pastdmark  
0369 ..			.dmark: db "SWB"  
036c f1			.pastdmark: pop af  
036d			endm  
# End of macro DMARK
036d			 
036d					;push af 
036d					;ld a, 'W' 
036d					;ld (debug_mark),a 
036d					;pop af 
036d					CALLMONITOR 
036d cd d7 12			call break_point_state  
0370				endm  
# End of macro CALLMONITOR
0370				endif 
0370			 
0370			; might not be working 
0370			;	call se_writepage 
0370			 
0370			;	ret 
0370			; 
0370			 
0370			 
0370			 
0370			.wl1:    
0370			 
0370				; read physical block at hl into de 
0370			        ; increment hl and de to next read position on exit 
0370			 
0370 e5				push hl 
0371 d5				push de	 
0372 c5				push bc 
0373 1a				ld a,(de) 
0374				;if DEBUG_STORESE 
0374			;		push af 
0374			;		ld a, 'W' 
0374			;		ld (debug_mark),a 
0374			;		pop af 
0374			;		CALLMONITOR 
0374			;	endif 
0374 cd e7 01			call se_writebyte 
0377			;	call delay250ms 
0377 00				nop 
0378 00				nop 
0379 00				nop 
037a			;	if DEBUG_STORESE 
037a			;		push af 
037a			;		ld a, 'w' 
037a			;		ld (debug_mark),a 
037a			;		pop af 
037a			;		CALLMONITOR 
037a			;	endif 
037a c1				pop bc 
037b d1				pop de 
037c e1				pop hl 
037d 23				inc hl 
037e 13				inc de 
037f			 
037f			 
037f 10 ef			djnz .wl1 
0381			 
0381				if DEBUG_STORESE 
0381					DMARK "SW2" 
0381 f5				push af  
0382 3a 96 03			ld a, (.dmark)  
0385 32 bd fb			ld (debug_mark),a  
0388 3a 97 03			ld a, (.dmark+1)  
038b 32 be fb			ld (debug_mark+1),a  
038e 3a 98 03			ld a, (.dmark+2)  
0391 32 bf fb			ld (debug_mark+2),a  
0394 18 03			jr .pastdmark  
0396 ..			.dmark: db "SW2"  
0399 f1			.pastdmark: pop af  
039a			endm  
# End of macro DMARK
039a			 
039a					;push af 
039a					;ld a, 'W' 
039a					;ld (debug_mark),a 
039a					;pop af 
039a					CALLMONITOR 
039a cd d7 12			call break_point_state  
039d				endm  
# End of macro CALLMONITOR
039d				endif 
039d c9				ret	 
039e			 
039e			; Init bank 
039e			; --------- 
039e			; 
039e			; With current bank 
039e			; 
039e			; Setup block 0 config 
039e			;     Set 0 file id counter 
039e			;     Set formatted byte pattern 
039e			;     Zero out bank label 
039e			;      
039e			; For every logical block write 0-1 byte as null 
039e			 
039e			storage_get_block_0: 
039e			 
039e				; TODO check presence 
039e			 
039e				; get block 0 config 
039e			 
039e 21 00 00			ld hl, 0 
03a1 11 e8 f9			ld de, store_page 
03a4 cd 09 03			call storage_read_block 
03a7			 
03a7				if DEBUG_STORESE 
03a7					DMARK "SB0" 
03a7 f5				push af  
03a8 3a bc 03			ld a, (.dmark)  
03ab 32 bd fb			ld (debug_mark),a  
03ae 3a bd 03			ld a, (.dmark+1)  
03b1 32 be fb			ld (debug_mark+1),a  
03b4 3a be 03			ld a, (.dmark+2)  
03b7 32 bf fb			ld (debug_mark+2),a  
03ba 18 03			jr .pastdmark  
03bc ..			.dmark: db "SB0"  
03bf f1			.pastdmark: pop af  
03c0			endm  
# End of macro DMARK
03c0 11 e8 f9				ld de, store_page 
03c3			;		push af 
03c3			;		ld a, 'i' 
03c3			;		ld (debug_mark),a 
03c3			;		pop af 
03c3					CALLMONITOR 
03c3 cd d7 12			call break_point_state  
03c6				endm  
# End of macro CALLMONITOR
03c6				endif 
03c6			 
03c6				; is this area formatted? 
03c6			 
03c6			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03c6 2a e9 f9			ld hl, (store_page+1) 
03c9 3e 80			ld a,0x80 
03cb bd				cp l 
03cc 20 22			jr nz, .ininotformatted 
03ce				; do a double check 
03ce 3e 27			ld a, 0x27 
03d0 bc				cp h 
03d1 20 1d			jr nz, .ininotformatted 
03d3			 
03d3				; formatted then 
03d3			 
03d3				if DEBUG_STORESE 
03d3					DMARK "SB1" 
03d3 f5				push af  
03d4 3a e8 03			ld a, (.dmark)  
03d7 32 bd fb			ld (debug_mark),a  
03da 3a e9 03			ld a, (.dmark+1)  
03dd 32 be fb			ld (debug_mark+1),a  
03e0 3a ea 03			ld a, (.dmark+2)  
03e3 32 bf fb			ld (debug_mark+2),a  
03e6 18 03			jr .pastdmark  
03e8 ..			.dmark: db "SB1"  
03eb f1			.pastdmark: pop af  
03ec			endm  
# End of macro DMARK
03ec					;push af 
03ec					;ld a, 'I' 
03ec					;ld (debug_mark),a 
03ec					;pop af 
03ec					CALLMONITOR 
03ec cd d7 12			call break_point_state  
03ef				endm  
# End of macro CALLMONITOR
03ef				endif 
03ef c9				ret 
03f0			 
03f0			.ininotformatted: 
03f0				; bank not formatted so poke various bits to make sure 
03f0			 
03f0				if DEBUG_STORESE 
03f0					DMARK "SB2" 
03f0 f5				push af  
03f1 3a 05 04			ld a, (.dmark)  
03f4 32 bd fb			ld (debug_mark),a  
03f7 3a 06 04			ld a, (.dmark+1)  
03fa 32 be fb			ld (debug_mark+1),a  
03fd 3a 07 04			ld a, (.dmark+2)  
0400 32 bf fb			ld (debug_mark+2),a  
0403 18 03			jr .pastdmark  
0405 ..			.dmark: db "SB2"  
0408 f1			.pastdmark: pop af  
0409			endm  
# End of macro DMARK
0409					;push af 
0409					;ld a, 'f' 
0409					;ld (debug_mark),a 
0409					;pop af 
0409					CALLMONITOR 
0409 cd d7 12			call break_point_state  
040c				endm  
# End of macro CALLMONITOR
040c				endif 
040c			 
040c 21 e8 f9			ld hl, store_page 
040f 3e 00			ld a, 0 
0411				 
0411 77				ld (hl),a   ; reset file counter 
0412			 
0412 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0415 22 e9 f9		 	ld (store_page+1), hl	 
0418			 
0418				; set default label 
0418			 
0418 21 ad 04			ld hl, .defaultbanklabl 
041b 11 eb f9		 	ld de, store_page+3 
041e 01 0f 00			ld bc, 15 
0421 ed b0			ldir 
0423			 
0423				; save default page 0 
0423			 
0423 21 00 00			ld hl, 0 
0426 11 e8 f9			ld de, store_page 
0429				if DEBUG_STORESE 
0429					DMARK "SB3" 
0429 f5				push af  
042a 3a 3e 04			ld a, (.dmark)  
042d 32 bd fb			ld (debug_mark),a  
0430 3a 3f 04			ld a, (.dmark+1)  
0433 32 be fb			ld (debug_mark+1),a  
0436 3a 40 04			ld a, (.dmark+2)  
0439 32 bf fb			ld (debug_mark+2),a  
043c 18 03			jr .pastdmark  
043e ..			.dmark: db "SB3"  
0441 f1			.pastdmark: pop af  
0442			endm  
# End of macro DMARK
0442			;		push af 
0442			;		ld a, 'F' 
0442			;		ld (debug_mark),a 
0442			;		pop af 
0442					CALLMONITOR 
0442 cd d7 12			call break_point_state  
0445				endm  
# End of macro CALLMONITOR
0445				endif 
0445 cd 52 03			call storage_write_block 
0448				if DEBUG_STORESE 
0448					DMARK "SB4" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 bd fb			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 be fb			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 bf fb			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SB4"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461			;		push af 
0461			;		ld a, '>' 
0461			;		ld (debug_mark),a 
0461			;		pop af 
0461					CALLMONITOR 
0461 cd d7 12			call break_point_state  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464			 
0464 00				nop 
0465 00				nop 
0466 00				nop 
0467			 
0467				; now set 0 in every page to mark as a free block 
0467			 
0467 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0469 21 40 00			ld hl, STORE_BLOCK_PHY 
046c			 
046c 3e 00		.setmark1:   	ld a,0 
046e e5					push hl 
046f c5					push bc 
0470 cd e7 01				call se_writebyte 
0473 3e 0a			ld a, 10 
0475 cd 23 09			call aDelayInMS 
0478 23				inc hl 
0479 cd e7 01				call se_writebyte 
047c 3e 0a			ld a, 10 
047e cd 23 09			call aDelayInMS 
0481 2b				dec hl 
0482 c1					pop bc 
0483 e1					pop hl 
0484 3e 40				ld a, STORE_BLOCK_PHY 
0486 cd 13 0b				call addatohl 
0489 10 e1				djnz .setmark1 
048b			 
048b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048d 3e 00		.setmark2:   	ld a,0 
048f e5					push hl 
0490 c5					push bc 
0491 cd e7 01				call se_writebyte 
0494 3e 0a			ld a, 10 
0496 cd 23 09			call aDelayInMS 
0499 23				inc hl 
049a cd e7 01				call se_writebyte 
049d 3e 0a			ld a, 10 
049f cd 23 09			call aDelayInMS 
04a2 2b				dec hl 
04a3 c1					pop bc 
04a4 e1					pop hl 
04a5 3e 40				ld a, STORE_BLOCK_PHY 
04a7 cd 13 0b				call addatohl 
04aa 10 e1				djnz .setmark2 
04ac			 
04ac					 
04ac			 
04ac			 
04ac c9				ret 
04ad			 
04ad			 
04ad			 
04ad			 
04ad .. 00		.defaultbanklabl:   db "BankLabel",0 
04b7			 
04b7			 
04b7			 
04b7			; Label Bank 
04b7			; ---------- 
04b7			; 
04b7			; With current bank 
04b7			; Read block 0 
04b7			; Set label 
04b7			; Write block 0 
04b7			 
04b7			; label str pointer in hl 
04b7			 
04b7			storage_label:     
04b7			 
04b7				if DEBUG_STORESE 
04b7					DMARK "LBL" 
04b7 f5				push af  
04b8 3a cc 04			ld a, (.dmark)  
04bb 32 bd fb			ld (debug_mark),a  
04be 3a cd 04			ld a, (.dmark+1)  
04c1 32 be fb			ld (debug_mark+1),a  
04c4 3a ce 04			ld a, (.dmark+2)  
04c7 32 bf fb			ld (debug_mark+2),a  
04ca 18 03			jr .pastdmark  
04cc ..			.dmark: db "LBL"  
04cf f1			.pastdmark: pop af  
04d0			endm  
# End of macro DMARK
04d0					CALLMONITOR 
04d0 cd d7 12			call break_point_state  
04d3				endm  
# End of macro CALLMONITOR
04d3				endif 
04d3			 
04d3 e5				push hl 
04d4			 
04d4 cd 9e 03			call storage_get_block_0 
04d7			 
04d7				; set default label 
04d7			 
04d7 e1				pop hl 
04d8			 
04d8 11 eb f9		 	ld de, store_page+3 
04db 01 0f 00			ld bc, 15 
04de				if DEBUG_STORESE 
04de					DMARK "LB3" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 bd fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 be fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 bf fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LB3"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd d7 12			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa ed b0			ldir 
04fc				; save default page 0 
04fc			 
04fc 21 00 00			ld hl, 0 
04ff 11 e8 f9			ld de, store_page 
0502				if DEBUG_STORESE 
0502					DMARK "LBW" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 bd fb			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 be fb			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 bf fb			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "LBW"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					CALLMONITOR 
051b cd d7 12			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e cd 52 03			call storage_write_block 
0521			 
0521 c9				ret 
0522			 
0522			 
0522			 
0522			; Read Block 0 - Config 
0522			; --------------------- 
0522			; 
0522			; With current bank 
0522			; Call presence test 
0522			;    If not present format/init bank  
0522			; Read block 0  
0522			;  
0522			 
0522			 
0522			; Dir 
0522			; --- 
0522			; 
0522			; With current bank 
0522			; Load Block 0 Config 
0522			; Get max file id number 
0522			; For each logical block 
0522			;    Read block read byte 2 
0522			;      if first block of file 
0522			;         Display file name 
0522			;         Display type flags for file 
0522			;        
0522			 
0522			; moving to words as this requires stack control 
0522			 
0522			 
0522			; Delete File 
0522			; ----------- 
0522			; 
0522			; With current bank 
0522			; 
0522			; Load Block 0 Config 
0522			; Get max file id number 
0522			; For each logical block 
0522			;    Read block file id 
0522			;      If first block of file and dont have file id 
0522			;         if file to delete 
0522			;         Save file id 
0522			;         Null file id 
0522			;         Write this block back 
0522			;      If file id is one saved 
0522			;         Null file id 
0522			;         Write this block back 
0522			 
0522			storage_erase: 
0522			 
0522				; hl contains the file id 
0522			 
0522 5d				ld e, l 
0523 16 00			ld d, 0 
0525 21 40 00			ld hl, STORE_BLOCK_PHY 
0528					if DEBUG_FORTH_WORDS 
0528						DMARK "ERA" 
0528						CALLMONITOR 
0528					endif 
0528 cd 77 05			call storage_findnextid 
052b			 
052b e5				push hl 
052c			 
052c				; TODO check file not found 
052c			 
052c 11 e8 f9			ld de, store_page 
052f cd 09 03			call storage_read_block 
0532			 
0532					if DEBUG_FORTH_WORDS 
0532						DMARK "ER1" 
0532						CALLMONITOR 
0532					endif 
0532 3a e8 f9			ld a, (store_page)	; get file id 
0535 32 e1 f9			ld (store_tmpid), a 
0538			 
0538 3a ea f9			ld a, (store_page+2)    ; get count of extends 
053b 32 e0 f9			ld (store_tmpext), a 
053e			 
053e				; wipe file header 
053e			 
053e e1				pop hl 
053f 3e 00			ld a, 0 
0541 32 e8 f9			ld (store_page), a 
0544 32 e9 f9			ld (store_page+1),a 
0547 11 e8 f9			ld de, store_page 
054a					if DEBUG_FORTH_WORDS 
054a						DMARK "ER2" 
054a						CALLMONITOR 
054a					endif 
054a cd 52 03			call storage_write_block 
054d			 
054d			 
054d				; wipe file extents 
054d			 
054d 3a e0 f9			ld a, (store_tmpext) 
0550 47				ld b, a 
0551			 
0551			.eraext:	  
0551 c5				push bc 
0552			 
0552 21 40 00			ld hl, STORE_BLOCK_PHY 
0555 3a e1 f9			ld a,(store_tmpid) 
0558 5f				ld e, a 
0559 50				ld d, b	 
055a					if DEBUG_FORTH_WORDS 
055a						DMARK "ER3" 
055a						CALLMONITOR 
055a					endif 
055a cd 77 05			call storage_findnextid 
055d			 
055d e5				push hl 
055e 11 e8 f9			ld de, store_page 
0561 cd 09 03			call storage_read_block 
0564			 
0564				; free block	 
0564			 
0564 3e 00			ld a, 0 
0566 32 e8 f9			ld (store_page), a 
0569 32 e9 f9			ld (store_page+1),a 
056c 11 e8 f9			ld de, store_page 
056f e1				pop hl 
0570					if DEBUG_FORTH_WORDS 
0570						DMARK "ER4" 
0570						CALLMONITOR 
0570					endif 
0570 cd 52 03			call storage_write_block 
0573			 
0573 c1				pop bc 
0574 10 db			djnz .eraext 
0576			 
0576 c9				ret 
0577			 
0577			 
0577			; Find Free Block 
0577			; --------------- 
0577			; 
0577			; With current bank 
0577			;  
0577			; From given starting logical block 
0577			;    Read block  
0577			;    If no file id 
0577			;         Return block id 
0577			 
0577			 
0577			; hl starting page number 
0577			; hl contains free page number or zero if no pages free 
0577			; e contains the file id to locate 
0577			; d contains the block number 
0577			 
0577			; TODO change to find file id and use zero for free block 
0577			 
0577			storage_findnextid: 
0577			 
0577				; now locate first 0 page to mark as a free block 
0577			 
0577 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0579			;	ld hl, STORE_BLOCK_PHY 
0579			 
0579					if DEBUG_FORTH_WORDS 
0579					DMARK "FNI" 
0579						CALLMONITOR 
0579					endif 
0579			.ff1:   	 
0579 e5					push hl 
057a c5					push bc 
057b d5					push de 
057c cd 89 02				call se_readbyte 
057f 5f					ld e,a 
0580 23					inc hl 
0581 cd 89 02				call se_readbyte 
0584 57					ld d, a 
0585 e1					pop hl 
0586 e5					push hl 
0587 cd 31 0b				call cmp16 
058a 28 2d				jr z, .fffound 
058c			 
058c d1					pop de 
058d c1					pop bc 
058e e1					pop hl 
058f			 
058f					; is found? 
058f					;cp e 
058f					;ret z 
058f			 
058f 3e 40				ld a, STORE_BLOCK_PHY 
0591 cd 13 0b				call addatohl 
0594 10 e3				djnz .ff1 
0596			 
0596 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0598			.ff2:   	 
0598			 
0598 e5					push hl 
0599 c5					push bc 
059a d5					push de 
059b cd 89 02				call se_readbyte 
059e 5f					ld e,a 
059f 23					inc hl 
05a0 cd 89 02				call se_readbyte 
05a3 57					ld d, a 
05a4			 
05a4 e1					pop hl 
05a5 e5					push hl 
05a6 cd 31 0b				call cmp16 
05a9 28 0e				jr z, .fffound 
05ab			 
05ab d1					pop de 
05ac c1					pop bc 
05ad e1					pop hl 
05ae					; is found? 
05ae					;cp e 
05ae					;ret z 
05ae			 
05ae 3e 40				ld a, STORE_BLOCK_PHY 
05b0 cd 13 0b				call addatohl 
05b3 10 e3				djnz .ff2 
05b5			 
05b5			 
05b5					if DEBUG_FORTH_WORDS 
05b5					DMARK "FN-" 
05b5					;	push af 
05b5					;	ld a, 'n' 
05b5					;	ld (debug_mark),a 
05b5					;	pop af 
05b5						CALLMONITOR 
05b5					endif 
05b5				; no free marks! 
05b5 21 00 00				ld hl, 0 
05b8 c9				ret 
05b9			.fffound: 
05b9				 
05b9			 
05b9 d1					pop de 
05ba c1					pop bc 
05bb e1					pop hl 
05bc					if DEBUG_FORTH_WORDS 
05bc					DMARK "FNF" 
05bc					;	push af 
05bc					;	ld a, 'n' 
05bc					;	ld (debug_mark),a 
05bc					;	pop af 
05bc						CALLMONITOR 
05bc					endif 
05bc c9				ret 
05bd			 
05bd			 
05bd			 
05bd			; Free Space 
05bd			; ---------- 
05bd			; 
05bd			; With current bank 
05bd			; 
05bd			; Set block count to zero 
05bd			; Starting with first logical block 
05bd			;      Find free block  
05bd			;      If block id given, increment block count 
05bd			; 
05bd			;  
05bd			 
05bd			 
05bd			; hl contains count of free blocks 
05bd			 
05bd			storage_freeblocks: 
05bd			 
05bd				; now locate first 0 page to mark as a free block 
05bd			 
05bd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05bf 21 40 00			ld hl, STORE_BLOCK_PHY 
05c2 11 00 00			ld de, 0 
05c5			 
05c5			.fb1:   	 
05c5 e5					push hl 
05c6 c5					push bc 
05c7 d5					push de 
05c8 cd 89 02				call se_readbyte 
05cb d1					pop de 
05cc c1					pop bc 
05cd e1					pop hl 
05ce			 
05ce					; is free? 
05ce fe 00				cp 0 
05d0 20 01				jr nz, .ff1cont 
05d2 13					inc de 
05d3			 
05d3			.ff1cont: 
05d3			 
05d3			 
05d3 3e 40				ld a, STORE_BLOCK_PHY 
05d5 cd 13 0b				call addatohl 
05d8 10 eb				djnz .fb1 
05da			 
05da 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05dc			.fb2:   	 
05dc e5					push hl 
05dd c5					push bc 
05de d5					push de 
05df cd 89 02				call se_readbyte 
05e2 d1					pop de 
05e3 c1					pop bc 
05e4 e1					pop hl 
05e5			 
05e5					; is free? 
05e5 fe 00				cp 0 
05e7 20 01				jr nz, .ff2cont 
05e9 13					inc de 
05ea			 
05ea			.ff2cont: 
05ea			 
05ea 3e 40				ld a, STORE_BLOCK_PHY 
05ec cd 13 0b				call addatohl 
05ef 10 eb				djnz .fb2 
05f1			 
05f1 eb				ex de, hl 
05f2 c9				ret 
05f3			 
05f3			; Get File ID 
05f3			; ----------- 
05f3			; 
05f3			; With current bank 
05f3			;  
05f3			; Load Block 0 Config 
05f3			; Get max file id number 
05f3			; For each logical block 
05f3			;    Read block file id 
05f3			;      If first block of file and dont have file id 
05f3			;         if file get id and exit 
05f3			 
05f3			 
05f3			 
05f3			 
05f3			; Create File 
05f3			; ----------- 
05f3			; 
05f3			; With current bank  
05f3			; Load Block 0 Config 
05f3			; Get max file id number 
05f3			; Increment file id number 
05f3			; Save Config 
05f3			; Find free block 
05f3			; Set buffer with file name and file id 
05f3			; Write buffer to free block  
05f3			 
05f3			 
05f3			; hl point to file name 
05f3			; hl returns file id 
05f3			 
05f3			; file format: 
05f3			; byte 0 - file id 
05f3			; byte 1 - extent number 
05f3			; byte 2-> data 
05f3			 
05f3			; format for extent number 0: 
05f3			; 
05f3			; byte 0 - file id 
05f3			; byte 1 - extent 0 
05f3			; byte 2 - extent count 
05f3			; byte 3 -> file name and meta data 
05f3			 
05f3			 
05f3			storage_create: 
05f3				if DEBUG_STORESE 
05f3					DMARK "SCR" 
05f3 f5				push af  
05f4 3a 08 06			ld a, (.dmark)  
05f7 32 bd fb			ld (debug_mark),a  
05fa 3a 09 06			ld a, (.dmark+1)  
05fd 32 be fb			ld (debug_mark+1),a  
0600 3a 0a 06			ld a, (.dmark+2)  
0603 32 bf fb			ld (debug_mark+2),a  
0606 18 03			jr .pastdmark  
0608 ..			.dmark: db "SCR"  
060b f1			.pastdmark: pop af  
060c			endm  
# End of macro DMARK
060c					CALLMONITOR 
060c cd d7 12			call break_point_state  
060f				endm  
# End of macro CALLMONITOR
060f				endif 
060f			 
060f e5				push hl		; save file name pointer 
0610			 
0610 cd 9e 03			call storage_get_block_0 
0613			 
0613 3a e8 f9			ld a,(store_page)	; get current file id 
0616 3c				inc a 
0617 32 e8 f9			ld (store_page),a 
061a				 
061a 32 e1 f9			ld (store_tmpid),a			; save id 
061d			 
061d 21 00 00			ld hl, 0 
0620 11 e8 f9			ld de, store_page 
0623				if DEBUG_STORESE 
0623					DMARK "SCw" 
0623 f5				push af  
0624 3a 38 06			ld a, (.dmark)  
0627 32 bd fb			ld (debug_mark),a  
062a 3a 39 06			ld a, (.dmark+1)  
062d 32 be fb			ld (debug_mark+1),a  
0630 3a 3a 06			ld a, (.dmark+2)  
0633 32 bf fb			ld (debug_mark+2),a  
0636 18 03			jr .pastdmark  
0638 ..			.dmark: db "SCw"  
063b f1			.pastdmark: pop af  
063c			endm  
# End of macro DMARK
063c					CALLMONITOR 
063c cd d7 12			call break_point_state  
063f				endm  
# End of macro CALLMONITOR
063f				endif 
063f cd 52 03			call storage_write_block	 ; save update 
0642			 
0642				if DEBUG_STORESE 
0642 11 e8 f9				ld de, store_page 
0645					DMARK "SCC" 
0645 f5				push af  
0646 3a 5a 06			ld a, (.dmark)  
0649 32 bd fb			ld (debug_mark),a  
064c 3a 5b 06			ld a, (.dmark+1)  
064f 32 be fb			ld (debug_mark+1),a  
0652 3a 5c 06			ld a, (.dmark+2)  
0655 32 bf fb			ld (debug_mark+2),a  
0658 18 03			jr .pastdmark  
065a ..			.dmark: db "SCC"  
065d f1			.pastdmark: pop af  
065e			endm  
# End of macro DMARK
065e					CALLMONITOR 
065e cd d7 12			call break_point_state  
0661				endm  
# End of macro CALLMONITOR
0661				endif 
0661				;  
0661				 
0661 21 40 00			ld hl, STORE_BLOCK_PHY 
0664 11 00 00			ld de, 0 
0667 cd 77 05			call storage_findnextid 
066a			 
066a 22 e6 f9			ld (store_tmppageid), hl    ; save page to use  
066d			 
066d				; TODO detect 0 = no spare blocks 
066d			 
066d				; hl now contains the free page to use for the file header page 
066d			 
066d				if DEBUG_STORESE 
066d				DMARK "SCF" 
066d f5				push af  
066e 3a 82 06			ld a, (.dmark)  
0671 32 bd fb			ld (debug_mark),a  
0674 3a 83 06			ld a, (.dmark+1)  
0677 32 be fb			ld (debug_mark+1),a  
067a 3a 84 06			ld a, (.dmark+2)  
067d 32 bf fb			ld (debug_mark+2),a  
0680 18 03			jr .pastdmark  
0682 ..			.dmark: db "SCF"  
0685 f1			.pastdmark: pop af  
0686			endm  
# End of macro DMARK
0686					CALLMONITOR 
0686 cd d7 12			call break_point_state  
0689				endm  
# End of macro CALLMONITOR
0689				endif 
0689			 
0689 22 e6 f9			ld (store_tmppageid), hl 
068c				 
068c 3a e1 f9			ld a,(store_tmpid)    ; get file id 
068f			;	ld a, (store_filecache)			; save to cache 
068f			 
068f 32 e8 f9			ld (store_page),a    ; set page id 
0692 3e 00			ld a, 0			 ; extent 0 is file header 
0694 32 e9 f9			ld (store_page+1), a   ; set file extent 
0697			 
0697 32 ea f9			ld (store_page+2), a   ; extent count for the file 
069a			 
069a			;	inc hl 		; init block 0 of file 
069a			;	inc hl   		; skip file and extent id 
069a			 ;       ld a, 0 
069a			;	ld (hl),a 
069a			;	ld a, (store_filecache+1)  	; save to cache 
069a			 
069a			;	inc hl    ; file name 
069a				 
069a				 
069a 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
069d				if DEBUG_STORESE 
069d					DMARK "SCc" 
069d f5				push af  
069e 3a b2 06			ld a, (.dmark)  
06a1 32 bd fb			ld (debug_mark),a  
06a4 3a b3 06			ld a, (.dmark+1)  
06a7 32 be fb			ld (debug_mark+1),a  
06aa 3a b4 06			ld a, (.dmark+2)  
06ad 32 bf fb			ld (debug_mark+2),a  
06b0 18 03			jr .pastdmark  
06b2 ..			.dmark: db "SCc"  
06b5 f1			.pastdmark: pop af  
06b6			endm  
# End of macro DMARK
06b6					CALLMONITOR 
06b6 cd d7 12			call break_point_state  
06b9				endm  
# End of macro CALLMONITOR
06b9				endif 
06b9 e1				pop hl    ; get zero term string 
06ba e5				push hl 
06bb 3e 00			ld a, 0 
06bd cd 7c 0f			call strlent 
06c0 23				inc hl   ; cover zero term 
06c1 06 00			ld b,0 
06c3 4d				ld c,l 
06c4 e1				pop hl 
06c5				;ex de, hl 
06c5				if DEBUG_STORESE 
06c5					DMARK "SCa" 
06c5 f5				push af  
06c6 3a da 06			ld a, (.dmark)  
06c9 32 bd fb			ld (debug_mark),a  
06cc 3a db 06			ld a, (.dmark+1)  
06cf 32 be fb			ld (debug_mark+1),a  
06d2 3a dc 06			ld a, (.dmark+2)  
06d5 32 bf fb			ld (debug_mark+2),a  
06d8 18 03			jr .pastdmark  
06da ..			.dmark: db "SCa"  
06dd f1			.pastdmark: pop af  
06de			endm  
# End of macro DMARK
06de					;push af 
06de					;ld a, 'a' 
06de					;ld (debug_mark),a 
06de					;pop af 
06de					CALLMONITOR 
06de cd d7 12			call break_point_state  
06e1				endm  
# End of macro CALLMONITOR
06e1				endif 
06e1 ed b0			ldir    ; copy zero term string 
06e3				if DEBUG_STORESE 
06e3					DMARK "SCA" 
06e3 f5				push af  
06e4 3a f8 06			ld a, (.dmark)  
06e7 32 bd fb			ld (debug_mark),a  
06ea 3a f9 06			ld a, (.dmark+1)  
06ed 32 be fb			ld (debug_mark+1),a  
06f0 3a fa 06			ld a, (.dmark+2)  
06f3 32 bf fb			ld (debug_mark+2),a  
06f6 18 03			jr .pastdmark  
06f8 ..			.dmark: db "SCA"  
06fb f1			.pastdmark: pop af  
06fc			endm  
# End of macro DMARK
06fc					CALLMONITOR 
06fc cd d7 12			call break_point_state  
06ff				endm  
# End of macro CALLMONITOR
06ff				endif 
06ff			 
06ff				; write file header page 
06ff			 
06ff 2a e6 f9			ld hl,(store_tmppageid) 
0702 11 e8 f9			ld de, store_page 
0705				if DEBUG_STORESE 
0705					DMARK "SCb" 
0705 f5				push af  
0706 3a 1a 07			ld a, (.dmark)  
0709 32 bd fb			ld (debug_mark),a  
070c 3a 1b 07			ld a, (.dmark+1)  
070f 32 be fb			ld (debug_mark+1),a  
0712 3a 1c 07			ld a, (.dmark+2)  
0715 32 bf fb			ld (debug_mark+2),a  
0718 18 03			jr .pastdmark  
071a ..			.dmark: db "SCb"  
071d f1			.pastdmark: pop af  
071e			endm  
# End of macro DMARK
071e					;push af 
071e					;ld a, 'b' 
071e					;ld (debug_mark),a 
071e					;pop af 
071e					CALLMONITOR 
071e cd d7 12			call break_point_state  
0721				endm  
# End of macro CALLMONITOR
0721				endif 
0721 cd 52 03			call storage_write_block 
0724			 
0724 3a e1 f9			ld a, (store_tmpid) 
0727 6f				ld l, a 
0728 26 00			ld h,0 
072a				if DEBUG_STORESE 
072a					DMARK "SCz" 
072a f5				push af  
072b 3a 3f 07			ld a, (.dmark)  
072e 32 bd fb			ld (debug_mark),a  
0731 3a 40 07			ld a, (.dmark+1)  
0734 32 be fb			ld (debug_mark+1),a  
0737 3a 41 07			ld a, (.dmark+2)  
073a 32 bf fb			ld (debug_mark+2),a  
073d 18 03			jr .pastdmark  
073f ..			.dmark: db "SCz"  
0742 f1			.pastdmark: pop af  
0743			endm  
# End of macro DMARK
0743					CALLMONITOR 
0743 cd d7 12			call break_point_state  
0746				endm  
# End of macro CALLMONITOR
0746				endif 
0746 c9				ret 
0747				 
0747			 
0747			 
0747			; 
0747			; Read File 
0747			; 
0747			; h - file id to locate 
0747			; l - extent to locate 
0747			; de - pointer to string to read into 
0747			; 
0747			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0747			storage_read: 
0747 d5				push de 
0748			 
0748			; TODO BUG the above push is it popped before the RET Z? 
0748			 
0748			; TODO how to handle multiple part blocks 
0748			 
0748				; locate file extent to read 
0748			 
0748 5c				ld e, h 
0749 55				ld d, l 
074a 21 40 00			ld hl, STORE_BLOCK_PHY 
074d				if DEBUG_STORESE 
074d					DMARK "SRE" 
074d f5				push af  
074e 3a 62 07			ld a, (.dmark)  
0751 32 bd fb			ld (debug_mark),a  
0754 3a 63 07			ld a, (.dmark+1)  
0757 32 be fb			ld (debug_mark+1),a  
075a 3a 64 07			ld a, (.dmark+2)  
075d 32 bf fb			ld (debug_mark+2),a  
0760 18 03			jr .pastdmark  
0762 ..			.dmark: db "SRE"  
0765 f1			.pastdmark: pop af  
0766			endm  
# End of macro DMARK
0766					CALLMONITOR 
0766 cd d7 12			call break_point_state  
0769				endm  
# End of macro CALLMONITOR
0769				endif 
0769 cd 77 05			call storage_findnextid 
076c			 
076c				if DEBUG_STORESE 
076c					DMARK "SRf" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 bd fb			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 be fb			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 bf fb			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SRf"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd d7 12			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788 cd 3c 0b			call ishlzero 
078b			;	ld a, l 
078b			;	add h 
078b			;	cp 0 
078b c8				ret z			; block not found so EOF 
078c			 
078c				; hl contains page number to load 
078c d1				pop de   ; get storage 
078d d5				push de 
078e				if DEBUG_STORESE 
078e					DMARK "SRg" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 bd fb			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 be fb			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 bf fb			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SRg"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					CALLMONITOR 
07a7 cd d7 12			call break_point_state  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd 09 03			call storage_read_block 
07ad			 
07ad			 
07ad			; TODO if block has no zeros then need to read next block  
07ad			 
07ad			 
07ad					 
07ad e1				pop hl 		 ; return start of data to show as not EOF 
07ae 23				inc hl   ; past file id 
07af 23				inc hl   ; past ext 
07b0				if DEBUG_STORESE 
07b0					DMARK "SRe" 
07b0 f5				push af  
07b1 3a c5 07			ld a, (.dmark)  
07b4 32 bd fb			ld (debug_mark),a  
07b7 3a c6 07			ld a, (.dmark+1)  
07ba 32 be fb			ld (debug_mark+1),a  
07bd 3a c7 07			ld a, (.dmark+2)  
07c0 32 bf fb			ld (debug_mark+2),a  
07c3 18 03			jr .pastdmark  
07c5 ..			.dmark: db "SRe"  
07c8 f1			.pastdmark: pop af  
07c9			endm  
# End of macro DMARK
07c9					CALLMONITOR 
07c9 cd d7 12			call break_point_state  
07cc				endm  
# End of macro CALLMONITOR
07cc				endif 
07cc c9					ret 
07cd			 
07cd			 
07cd			 
07cd			; 
07cd			; Append File 
07cd			; 
07cd			; hl - file id to locate 
07cd			; de - pointer to (multi block) string to write 
07cd			 
07cd			 
07cd			storage_append: 
07cd				; hl -  file id to append to 
07cd				; de - string to append 
07cd			 
07cd d5				push de 
07ce				 
07ce				if DEBUG_STORESE 
07ce					DMARK "AP1" 
07ce f5				push af  
07cf 3a e3 07			ld a, (.dmark)  
07d2 32 bd fb			ld (debug_mark),a  
07d5 3a e4 07			ld a, (.dmark+1)  
07d8 32 be fb			ld (debug_mark+1),a  
07db 3a e5 07			ld a, (.dmark+2)  
07de 32 bf fb			ld (debug_mark+2),a  
07e1 18 03			jr .pastdmark  
07e3 ..			.dmark: db "AP1"  
07e6 f1			.pastdmark: pop af  
07e7			endm  
# End of macro DMARK
07e7					CALLMONITOR 
07e7 cd d7 12			call break_point_state  
07ea				endm  
# End of macro CALLMONITOR
07ea				endif 
07ea			 
07ea 7d				ld a, l 
07eb 32 e1 f9			ld (store_tmpid), a 
07ee			 
07ee				; get file header  
07ee			 
07ee 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
07f0 3a e1 f9			ld a, (store_tmpid) 
07f3 5f				ld e, a 
07f4			 
07f4 21 40 00				ld hl, STORE_BLOCK_PHY 
07f7 cd 77 05				call storage_findnextid 
07fa			 
07fa 22 e6 f9			ld (store_tmppageid), hl 
07fd			 
07fd				; TODO handle file id not found 
07fd			 
07fd				if DEBUG_STORESE 
07fd					DMARK "AP2" 
07fd f5				push af  
07fe 3a 12 08			ld a, (.dmark)  
0801 32 bd fb			ld (debug_mark),a  
0804 3a 13 08			ld a, (.dmark+1)  
0807 32 be fb			ld (debug_mark+1),a  
080a 3a 14 08			ld a, (.dmark+2)  
080d 32 bf fb			ld (debug_mark+2),a  
0810 18 03			jr .pastdmark  
0812 ..			.dmark: db "AP2"  
0815 f1			.pastdmark: pop af  
0816			endm  
# End of macro DMARK
0816					CALLMONITOR 
0816 cd d7 12			call break_point_state  
0819				endm  
# End of macro CALLMONITOR
0819				endif 
0819			 
0819				; update file extent count 
0819			 
0819 11 e8 f9			ld de, store_page 
081c			 
081c cd 09 03			call storage_read_block 
081f			 
081f				if DEBUG_STORESE 
081f					DMARK "AP3" 
081f f5				push af  
0820 3a 34 08			ld a, (.dmark)  
0823 32 bd fb			ld (debug_mark),a  
0826 3a 35 08			ld a, (.dmark+1)  
0829 32 be fb			ld (debug_mark+1),a  
082c 3a 36 08			ld a, (.dmark+2)  
082f 32 bf fb			ld (debug_mark+2),a  
0832 18 03			jr .pastdmark  
0834 ..			.dmark: db "AP3"  
0837 f1			.pastdmark: pop af  
0838			endm  
# End of macro DMARK
0838					CALLMONITOR 
0838 cd d7 12			call break_point_state  
083b				endm  
# End of macro CALLMONITOR
083b				endif 
083b			;	ld (store_tmppageid), hl 
083b			 
083b 3a ea f9			ld a, (store_page+2) 
083e 3c				inc a 
083f 32 ea f9			ld (store_page+2), a 
0842 32 e0 f9			ld (store_tmpext), a 
0845				 
0845				if DEBUG_STORESE 
0845					DMARK "AP3" 
0845 f5				push af  
0846 3a 5a 08			ld a, (.dmark)  
0849 32 bd fb			ld (debug_mark),a  
084c 3a 5b 08			ld a, (.dmark+1)  
084f 32 be fb			ld (debug_mark+1),a  
0852 3a 5c 08			ld a, (.dmark+2)  
0855 32 bf fb			ld (debug_mark+2),a  
0858 18 03			jr .pastdmark  
085a ..			.dmark: db "AP3"  
085d f1			.pastdmark: pop af  
085e			endm  
# End of macro DMARK
085e					CALLMONITOR 
085e cd d7 12			call break_point_state  
0861				endm  
# End of macro CALLMONITOR
0861				endif 
0861 2a e6 f9			ld hl, (store_tmppageid) 
0864 11 e8 f9			ld de, store_page 
0867 cd 52 03			call storage_write_block 
086a			 
086a				; find free block 
086a			 
086a 11 00 00			ld de, 0			 ; file extent to locate 
086d			 
086d 21 40 00				ld hl, STORE_BLOCK_PHY 
0870 cd 77 05				call storage_findnextid 
0873			 
0873					; TODO handle no space left 
0873					 
0873 22 e6 f9				ld (store_tmppageid), hl 
0876			 
0876				if DEBUG_STORESE 
0876					DMARK "AP4" 
0876 f5				push af  
0877 3a 8b 08			ld a, (.dmark)  
087a 32 bd fb			ld (debug_mark),a  
087d 3a 8c 08			ld a, (.dmark+1)  
0880 32 be fb			ld (debug_mark+1),a  
0883 3a 8d 08			ld a, (.dmark+2)  
0886 32 bf fb			ld (debug_mark+2),a  
0889 18 03			jr .pastdmark  
088b ..			.dmark: db "AP4"  
088e f1			.pastdmark: pop af  
088f			endm  
# End of macro DMARK
088f					CALLMONITOR 
088f cd d7 12			call break_point_state  
0892				endm  
# End of macro CALLMONITOR
0892				endif 
0892					; init the buffer with zeros so we can id if the buffer is full or not 
0892			 
0892 e5					push hl 
0893 c5					push bc 
0894			 
0894 21 e8 f9				ld hl, store_page 
0897 06 40				ld b, STORE_BLOCK_PHY 
0899 3e 00				ld a, 0 
089b 77			.zeroblock:	ld (hl), a 
089c 23					inc hl 
089d 10 fc				djnz .zeroblock 
089f			 
089f c1					pop bc 
08a0 e1					pop hl 
08a1			 
08a1					; construct block 
08a1			 
08a1 3a e1 f9				ld a, (store_tmpid) 
08a4 32 e8 f9				ld (store_page), a   ; file id 
08a7 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
08aa 32 e9 f9				ld (store_page+1), a 
08ad			 
08ad e1					pop hl    ; get string to write 
08ae 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
08b0 11 ea f9				ld de, store_page+2 
08b3			 
08b3				if DEBUG_STORESE 
08b3					DMARK "AP5" 
08b3 f5				push af  
08b4 3a c8 08			ld a, (.dmark)  
08b7 32 bd fb			ld (debug_mark),a  
08ba 3a c9 08			ld a, (.dmark+1)  
08bd 32 be fb			ld (debug_mark+1),a  
08c0 3a ca 08			ld a, (.dmark+2)  
08c3 32 bf fb			ld (debug_mark+2),a  
08c6 18 03			jr .pastdmark  
08c8 ..			.dmark: db "AP5"  
08cb f1			.pastdmark: pop af  
08cc			endm  
# End of macro DMARK
08cc					CALLMONITOR 
08cc cd d7 12			call break_point_state  
08cf				endm  
# End of macro CALLMONITOR
08cf				endif 
08cf			 
08cf			 
08cf			 
08cf					; fill buffer with data until end of string or full block 
08cf			 
08cf 7e			.appd:		ld a, (hl) 
08d0 12					ld (de), a 
08d1 fe 00				cp 0 
08d3 28 04				jr z, .appdone 
08d5 23					inc hl 
08d6 13					inc de 
08d7 10 f6				djnz .appd 
08d9			 
08d9 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
08da f5					push af   		; save last byte dumped 
08db			 
08db			 
08db 2a e6 f9			ld hl, (store_tmppageid) 
08de 11 e8 f9			ld de, store_page 
08e1				if DEBUG_STORESE 
08e1					DMARK "AP6" 
08e1 f5				push af  
08e2 3a f6 08			ld a, (.dmark)  
08e5 32 bd fb			ld (debug_mark),a  
08e8 3a f7 08			ld a, (.dmark+1)  
08eb 32 be fb			ld (debug_mark+1),a  
08ee 3a f8 08			ld a, (.dmark+2)  
08f1 32 bf fb			ld (debug_mark+2),a  
08f4 18 03			jr .pastdmark  
08f6 ..			.dmark: db "AP6"  
08f9 f1			.pastdmark: pop af  
08fa			endm  
# End of macro DMARK
08fa					CALLMONITOR 
08fa cd d7 12			call break_point_state  
08fd				endm  
# End of macro CALLMONITOR
08fd				endif 
08fd cd 52 03				call storage_write_block 
0900			 
0900			 
0900				; was that a full block of data written? 
0900				; any more to write out? 
0900			 
0900				; if yes then set vars and jump to start of function again 
0900			 
0900 f1					pop af 
0901 d1					pop de 
0902			 
0902 fe 00				cp 0		 ; no, string was fully written 
0904 c8					ret z 
0905			 
0905					; setup vars for next cycle 
0905			 
0905 3a e1 f9				ld a, (store_tmpid) 
0908 6f					ld l, a 
0909 26 00				ld h, 0 
090b			 
090b c3 cd 07			 	jp storage_append	 ; yes, need to write out some more 
090e			 
090e			 
090e			 
090e			 
090e			 
090e			 
090e			 
090e			if DEBUG_STORECF 
090e			storageput:	 
090e					ret 
090e			storageread: 
090e					ld hl, store_page 
090e					ld b, 200 
090e					ld a,0 
090e			.src:		ld (hl),a 
090e					inc hl 
090e					djnz .src 
090e					 
090e			 
090e					ld de, 0 
090e					ld bc, 1 
090e					ld hl, store_page 
090e					call cfRead 
090e			 
090e				call cfGetError 
090e				ld hl,scratch 
090e				call hexout 
090e				ld hl, scratch+2 
090e				ld a, 0 
090e				ld (hl),a 
090e				ld de, scratch 
090e				ld a,display_row_1 
090e				call str_at_display 
090e				call update_display 
090e			 
090e					ld hl, store_page 
090e					ld (os_cur_ptr),hl 
090e			 
090e					ret 
090e			endif 
090e			 
090e			 
090e			; Clear out the main buffer store (used to remove junk before writing a new block) 
090e			 
090e			storage_clear_page: 
090e e5				push hl 
090f d5				push de 
0910 c5				push bc 
0911 21 e8 f9			ld hl, store_page 
0914 3e 00			ld a, 0 
0916 77				ld (hl), a 
0917			 
0917 11 e9 f9			ld de, store_page+1 
091a 01 40 00			ld bc, STORE_BLOCK_PHY 
091d			 
091d ed b0			ldir 
091f				 
091f c1				pop bc 
0920 d1				pop de 
0921 e1				pop hl 
0922 c9				ret 
0923			 
0923			; eof 
# End of file firmware_storage.asm
0923			  
0923			; support routines for above hardware abstraction layer  
0923			  
0923			include "firmware_general.asm"        ; general support functions  
0923			 
0923			 
0923			 
0923			; Delay loops 
0923			 
0923			 
0923			 
0923			aDelayInMS: 
0923 c5				push bc 
0924 47				ld b,a 
0925			msdelay: 
0925 c5				push bc 
0926				 
0926			 
0926 01 41 00			ld bc,041h 
0929 cd 41 09			call delayloop 
092c c1				pop bc 
092d 05				dec b 
092e 20 f5			jr nz,msdelay 
0930			 
0930			;if CPU_CLOCK_8MHZ 
0930			;msdelay8: 
0930			;	push bc 
0930			;	 
0930			; 
0930			;	ld bc,041h 
0930			;	call delayloop 
0930			;	pop bc 
0930			;	dec b 
0930			;	jr nz,msdelay8 
0930			;endif 
0930			 
0930			 
0930 c1				pop bc 
0931 c9				ret 
0932			 
0932			 
0932			delay250ms: 
0932				;push de 
0932 01 00 40			ld bc, 04000h 
0935 c3 41 09			jp delayloop 
0938			delay500ms: 
0938				;push de 
0938 01 00 80			ld bc, 08000h 
093b c3 41 09			jp delayloop 
093e			delay1s: 
093e				;push bc 
093e			   ; Clobbers A, d and e 
093e 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0941			delayloop: 
0941 c5			    push bc 
0942			 
0942			if BASE_CPM 
0942				ld bc, CPM_DELAY_TUNE 
0942			.cpmloop: 
0942				push bc 
0942			 
0942			endif 
0942			 
0942			 
0942			 
0942			delayloopi: 
0942			;	push bc 
0942			;.dl: 
0942 cb 47		    bit     0,a    	; 8 
0944 cb 47		    bit     0,a    	; 8 
0946 cb 47		    bit     0,a    	; 8 
0948 e6 ff		    and     255  	; 7 
094a 0b			    dec     bc      	; 6 
094b 79			    ld      a,c     	; 4 
094c b0			    or      b     	; 4 
094d c2 42 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0950			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0950				;pop de 
0950			;pop bc 
0950			 
0950			if BASE_CPM 
0950				pop bc 
0950				 
0950			    dec     bc      	; 6 
0950			    ld      a,c     	; 4 
0950			    or      b     	; 4 
0950			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0950				 
0950			 
0950			endif 
0950			;if CPU_CLOCK_8MHZ 
0950			;    pop bc 
0950			;    push bc 
0950			;.dl8: 
0950			;    bit     0,a    	; 8 
0950			;    bit     0,a    	; 8 
0950			;    bit     0,a    	; 8 
0950			;    and     255  	; 7 
0950			;    dec     bc      	; 6 
0950			;    ld      a,c     	; 4 
0950			;    or      b     	; 4 
0950			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0950			;endif 
0950			 
0950			;if CPU_CLOCK_10MHZ 
0950			;    pop bc 
0950			;    push bc 
0950			;.dl8: 
0950			;    bit     0,a    	; 8 
0950			;    bit     0,a    	; 8 
0950			;    bit     0,a    	; 8 
0950			;    and     255  	; 7 
0950			;    dec     bc      	; 6 
0950			;    ld      a,c     	; 4 
0950			;    or      b     	; 4 
0950			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0950			;endif 
0950 c1			    pop bc 
0951			 
0951 c9				ret 
0952			 
0952			 
0952			 
0952			; eof 
# End of file firmware_general.asm
0952			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0952			; display routines that use the physical hardware abstraction layer 
0952			 
0952			 
0952			; TODO windowing? 
0952			 
0952			; TODO scroll line up 
0952			 
0952			scroll_up: 
0952			 
0952 e5				push hl 
0953 d5				push de 
0954 c5				push bc 
0955			 
0955				; get frame buffer  
0955			 
0955 2a 5e fa			ld hl, (display_fb_active) 
0958 e5				push hl    ; future de destination 
0959			 
0959 11 14 00			ld  de, display_cols 
095c 19				add hl, de 
095d			 
095d d1				pop de 
095e			 
095e				;ex de, hl 
095e 01 4f 00			ld bc, display_fb_len -1  
0961			;if DEBUG_FORTH_WORDS 
0961			;	DMARK "SCL" 
0961			;	CALLMONITOR 
0961			;endif	 
0961 ed b0			ldir 
0963			 
0963				; wipe bottom row 
0963			 
0963			 
0963 2a 5e fa			ld hl, (display_fb_active) 
0966 11 50 00			ld de, display_cols*display_rows 
0969 19				add hl, de 
096a 06 14			ld b, display_cols 
096c 3e 20			ld a, ' ' 
096e			.scwipe: 
096e 77				ld (hl), a 
096f 2b				dec hl 
0970 10 fc			djnz .scwipe 
0972			 
0972				;pop hl 
0972			 
0972 c1				pop bc 
0973 d1				pop de 
0974 e1				pop hl 
0975			 
0975 c9				ret 
0976			 
0976			 
0976			scroll_upo: 
0976 11 00 00			ld de, display_row_1 
0979 21 14 00		 	ld hl, display_row_2 
097c 01 14 00			ld bc, display_cols 
097f ed b0			ldir 
0981 11 14 00			ld de, display_row_2 
0984 21 28 00		 	ld hl, display_row_3 
0987 01 14 00			ld bc, display_cols 
098a ed b0			ldir 
098c 11 28 00			ld de, display_row_3 
098f 21 3c 00		 	ld hl, display_row_4 
0992 01 14 00			ld bc, display_cols 
0995 ed b0			ldir 
0997			 
0997			; TODO clear row 4 
0997			 
0997 c9				ret 
0998				 
0998			scroll_down: 
0998 11 3c 00			ld de, display_row_4 
099b 21 28 00		 	ld hl, display_row_3 
099e 01 14 00			ld bc, display_cols 
09a1 ed b0			ldir 
09a3 11 28 00			ld de, display_row_3 
09a6 21 14 00		 	ld hl, display_row_2 
09a9 01 14 00			ld bc, display_cols 
09ac ed b0			ldir 
09ae 11 14 00			ld de, display_row_2 
09b1 21 00 00		 	ld hl, display_row_1 
09b4 01 14 00			ld bc, display_cols 
09b7 ed b0			ldir 
09b9			; TODO clear row 1 
09b9 c9				ret 
09ba			 
09ba			 
09ba			 
09ba			 
09ba			 
09ba			; clear active frame buffer 
09ba			 
09ba			clear_display: 
09ba 3e 20			ld a, ' ' 
09bc c3 bf 09			jp fill_display 
09bf			 
09bf			; fill active frame buffer with a char in A 
09bf			 
09bf			fill_display: 
09bf 06 50			ld b,display_fb_len 
09c1 2a 5e fa			ld hl, (display_fb_active) 
09c4 77			.fd1:	ld (hl),a 
09c5 23				inc hl 
09c6 10 fc			djnz .fd1 
09c8 23				inc hl 
09c9 3e 00			ld a,0 
09cb 77				ld (hl),a 
09cc			 
09cc			 
09cc c9				ret 
09cd			; Write string (DE) at pos (A) to active frame buffer 
09cd			 
09cd 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
09d0 06 00					ld b,0 
09d2 4f					ld c,a 
09d3 09					add hl,bc 
09d4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
09d5 b7			            OR   A              ;Null terminator? 
09d6 c8			            RET  Z              ;Yes, so finished 
09d7 77					ld (hl),a 
09d8 23				inc hl 
09d9 13			            INC  DE             ;Point to next character 
09da 18 f8		            JR   .sad1     ;Repeat 
09dc c9					ret 
09dd			 
09dd			; using current frame buffer write to physical display 
09dd			 
09dd			update_display: 
09dd e5				push hl 
09de 2a 5e fa			ld hl, (display_fb_active) 
09e1 cd 7f 51			call write_display 
09e4 e1				pop hl 
09e5 c9				ret 
09e6			 
09e6			; TODO scrolling 
09e6			 
09e6			 
09e6			; move cursor right one char 
09e6			cursor_right: 
09e6			 
09e6				; TODO shift right 
09e6				; TODO if beyond max col 
09e6				; TODO       cursor_next_line 
09e6			 
09e6 c9				ret 
09e7			 
09e7			 
09e7			cursor_next_line: 
09e7				; TODO first char 
09e7				; TODO line down 
09e7				; TODO if past last row 
09e7				; TODO    scroll up 
09e7			 
09e7 c9				ret 
09e8			 
09e8			cursor_left: 
09e8				; TODO shift left 
09e8				; TODO if beyond left  
09e8				; TODO     cursor prev line 
09e8				 
09e8 c9				ret 
09e9			 
09e9			cursor_prev_line: 
09e9				; TODO last char 
09e9				; TODO line up 
09e9				; TODO if past first row 
09e9				; TODO   scroll down 
09e9			 
09e9 c9				ret 
09ea			 
09ea			 
09ea			cout: 
09ea				; A - char 
09ea c9				ret 
09eb			 
09eb			; eof 
09eb			 
# End of file firmware_display.asm
09eb			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
09eb			; random number generators 
09eb			 
09eb			 
09eb			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
09eb			 
09eb			 
09eb			;-----> Generate a random number 
09eb			; output a=answer 0<=a<=255 
09eb			; all registers are preserved except: af 
09eb			random: 
09eb e5			        push    hl 
09ec d5			        push    de 
09ed 2a 40 fa		        ld      hl,(randData) 
09f0 ed 5f		        ld      a,r 
09f2 57			        ld      d,a 
09f3 5e			        ld      e,(hl) 
09f4 19			        add     hl,de 
09f5 85			        add     a,l 
09f6 ac			        xor     h 
09f7 22 40 fa		        ld      (randData),hl 
09fa d1			        pop     de 
09fb e1			        pop     hl 
09fc c9			        ret 
09fd			 
09fd			 
09fd			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
09fd			 
09fd			 
09fd			 
09fd			;------LFSR------ 
09fd			;James Montelongo 
09fd			;optimized by Spencer Putt 
09fd			;out: 
09fd			; a = 8 bit random number 
09fd			RandLFSR: 
09fd 21 46 fa		        ld hl,LFSRSeed+4 
0a00 5e			        ld e,(hl) 
0a01 23			        inc hl 
0a02 56			        ld d,(hl) 
0a03 23			        inc hl 
0a04 4e			        ld c,(hl) 
0a05 23			        inc hl 
0a06 7e			        ld a,(hl) 
0a07 47			        ld b,a 
0a08 cb 13		        rl e  
0a0a cb 12			rl d 
0a0c cb 11		        rl c  
0a0e 17				rla 
0a0f cb 13		        rl e  
0a11 cb 12			rl d 
0a13 cb 11		        rl c  
0a15 17				rla 
0a16 cb 13		        rl e  
0a18 cb 12			rl d 
0a1a cb 11		        rl c  
0a1c 17				rla 
0a1d 67			        ld h,a 
0a1e cb 13		        rl e  
0a20 cb 12			rl d 
0a22 cb 11		        rl c  
0a24 17				rla 
0a25 a8			        xor b 
0a26 cb 13		        rl e  
0a28 cb 12			rl d 
0a2a ac			        xor h 
0a2b a9			        xor c 
0a2c aa			        xor d 
0a2d 21 48 fa		        ld hl,LFSRSeed+6 
0a30 11 49 fa		        ld de,LFSRSeed+7 
0a33 01 07 00		        ld bc,7 
0a36 ed b8		        lddr 
0a38 12			        ld (de),a 
0a39 c9			        ret 
0a3a			 
0a3a			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0a3a			 
0a3a			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0a3a			 
0a3a			 
0a3a			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0a3a			 
0a3a			prng16: 
0a3a			;Inputs: 
0a3a			;   (seed1) contains a 16-bit seed value 
0a3a			;   (seed2) contains a NON-ZERO 16-bit seed value 
0a3a			;Outputs: 
0a3a			;   HL is the result 
0a3a			;   BC is the result of the LCG, so not that great of quality 
0a3a			;   DE is preserved 
0a3a			;Destroys: 
0a3a			;   AF 
0a3a			;cycle: 4,294,901,760 (almost 4.3 billion) 
0a3a			;160cc 
0a3a			;26 bytes 
0a3a 2a 3a fa		    ld hl,(seed1) 
0a3d 44			    ld b,h 
0a3e 4d			    ld c,l 
0a3f 29			    add hl,hl 
0a40 29			    add hl,hl 
0a41 2c			    inc l 
0a42 09			    add hl,bc 
0a43 22 3a fa		    ld (seed1),hl 
0a46 2a 38 fa		    ld hl,(seed2) 
0a49 29			    add hl,hl 
0a4a 9f			    sbc a,a 
0a4b e6 2d		    and %00101101 
0a4d ad			    xor l 
0a4e 6f			    ld l,a 
0a4f 22 38 fa		    ld (seed2),hl 
0a52 09			    add hl,bc 
0a53 c9			    ret 
0a54			 
0a54			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0a54			 
0a54			rand32: 
0a54			;Inputs: 
0a54			;   (seed1_0) holds the lower 16 bits of the first seed 
0a54			;   (seed1_1) holds the upper 16 bits of the first seed 
0a54			;   (seed2_0) holds the lower 16 bits of the second seed 
0a54			;   (seed2_1) holds the upper 16 bits of the second seed 
0a54			;   **NOTE: seed2 must be non-zero 
0a54			;Outputs: 
0a54			;   HL is the result 
0a54			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0a54			;Destroys: 
0a54			;   AF 
0a54			;Tested and passes all CAcert tests 
0a54			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0a54			;it has a period of 18,446,744,069,414,584,320 
0a54			;roughly 18.4 quintillion. 
0a54			;LFSR taps: 0,2,6,7  = 11000101 
0a54			;291cc 
0a54			;seed1_0=$+1 
0a54			;    ld hl,12345 
0a54			;seed1_1=$+1 
0a54			;    ld de,6789 
0a54			;    ld b,h 
0a54			;    ld c,l 
0a54			;    add hl,hl \ rl e \ rl d 
0a54			;    add hl,hl \ rl e \ rl d 
0a54			;    inc l 
0a54			;    add hl,bc 
0a54			;    ld (seed1_0),hl 
0a54			;    ld hl,(seed1_1) 
0a54			;    adc hl,de 
0a54			;    ld (seed1_1),hl 
0a54			;    ex de,hl 
0a54			;seed2_0=$+1 
0a54			;    ld hl,9876 
0a54			;seed2_1=$+1 
0a54			;    ld bc,54321 
0a54			;    add hl,hl \ rl c \ rl b 
0a54			;    ld (seed2_1),bc 
0a54			;    sbc a,a 
0a54			;    and %11000101 
0a54			;    xor l 
0a54			;    ld l,a 
0a54			;    ld (seed2_0),hl 
0a54			;    ex de,hl 
0a54			;    add hl,bc 
0a54			;    ret 
0a54			; 
0a54			 
0a54			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0a54			; 20 bytes, 86 cycles (excluding ret) 
0a54			 
0a54			; returns   hl = pseudorandom number 
0a54			; corrupts   a 
0a54			 
0a54			; generates 16-bit pseudorandom numbers with a period of 65535 
0a54			; using the xorshift method: 
0a54			 
0a54			; hl ^= hl << 7 
0a54			; hl ^= hl >> 9 
0a54			; hl ^= hl << 8 
0a54			 
0a54			; some alternative shift triplets which also perform well are: 
0a54			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0a54			 
0a54			;  org 32768 
0a54			 
0a54			xrnd: 
0a54 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0a57 3e 00		  ld a,0 
0a59 bd			  cp l 
0a5a 20 02		  jr nz, .xrnd1 
0a5c 2e 01		  ld l, 1 
0a5e			.xrnd1: 
0a5e			 
0a5e 7c			  ld a,h 
0a5f 1f			  rra 
0a60 7d			  ld a,l 
0a61 1f			  rra 
0a62 ac			  xor h 
0a63 67			  ld h,a 
0a64 7d			  ld a,l 
0a65 1f			  rra 
0a66 7c			  ld a,h 
0a67 1f			  rra 
0a68 ad			  xor l 
0a69 6f			  ld l,a 
0a6a ac			  xor h 
0a6b 67			  ld h,a 
0a6c			 
0a6c 22 3e fa		  ld (xrandc),hl 
0a6f			 
0a6f c9			  ret 
0a70			;  
0a70			 
0a70			 
0a70			;;;; int maths 
0a70			 
0a70			; https://map.grauw.nl/articles/mult_div_shifts.php 
0a70			; Divide 16-bit values (with 16-bit result) 
0a70			; In: Divide BC by divider DE 
0a70			; Out: BC = result, HL = rest 
0a70			; 
0a70			Div16: 
0a70 21 00 00		    ld hl,0 
0a73 78			    ld a,b 
0a74 06 08		    ld b,8 
0a76			Div16_Loop1: 
0a76 17			    rla 
0a77 ed 6a		    adc hl,hl 
0a79 ed 52		    sbc hl,de 
0a7b 30 01		    jr nc,Div16_NoAdd1 
0a7d 19			    add hl,de 
0a7e			Div16_NoAdd1: 
0a7e 10 f6		    djnz Div16_Loop1 
0a80 17			    rla 
0a81 2f			    cpl 
0a82 47			    ld b,a 
0a83 79			    ld a,c 
0a84 48			    ld c,b 
0a85 06 08		    ld b,8 
0a87			Div16_Loop2: 
0a87 17			    rla 
0a88 ed 6a		    adc hl,hl 
0a8a ed 52		    sbc hl,de 
0a8c 30 01		    jr nc,Div16_NoAdd2 
0a8e 19			    add hl,de 
0a8f			Div16_NoAdd2: 
0a8f 10 f6		    djnz Div16_Loop2 
0a91 17			    rla 
0a92 2f			    cpl 
0a93 41			    ld b,c 
0a94 4f			    ld c,a 
0a95 c9			ret 
0a96			 
0a96			 
0a96			;http://z80-heaven.wikidot.com/math 
0a96			; 
0a96			;Inputs: 
0a96			;     DE and A are factors 
0a96			;Outputs: 
0a96			;     A is not changed 
0a96			;     B is 0 
0a96			;     C is not changed 
0a96			;     DE is not changed 
0a96			;     HL is the product 
0a96			;Time: 
0a96			;     342+6x 
0a96			; 
0a96			Mult16: 
0a96			 
0a96 06 08		     ld b,8          ;7           7 
0a98 21 00 00		     ld hl,0         ;10         10 
0a9b 29			       add hl,hl     ;11*8       88 
0a9c 07			       rlca          ;4*8        32 
0a9d 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0a9f 19			         add hl,de   ;--         -- 
0aa0 10 f9		       djnz $-5      ;13*7+8     99 
0aa2 c9			ret 
0aa3			 
0aa3			; 
0aa3			; Square root of 16-bit value 
0aa3			; In:  HL = value 
0aa3			; Out:  D = result (rounded down) 
0aa3			; 
0aa3			;Sqr16: 
0aa3			;    ld de,#0040 
0aa3			;    ld a,l 
0aa3			;    ld l,h 
0aa3			;    ld h,d 
0aa3			;    or a 
0aa3			;    ld b,8 
0aa3			;Sqr16_Loop: 
0aa3			;    sbc hl,de 
0aa3			;    jr nc,Sqr16_Skip 
0aa3			;    add hl,de 
0aa3			;Sqr16_Skip: 
0aa3			;    ccf 
0aa3			;    rl d 
0aa3			;    add a,a 
0aa3			;    adc hl,hl 
0aa3			;    add a,a 
0aa3			;    adc hl,hl 
0aa3			;    djnz Sqr16_Loop 
0aa3			;    ret 
0aa3			; 
0aa3			; 
0aa3			; Divide 8-bit values 
0aa3			; In: Divide E by divider C 
0aa3			; Out: A = result, B = rest 
0aa3			; 
0aa3			Div8: 
0aa3 af			    xor a 
0aa4 06 08		    ld b,8 
0aa6			Div8_Loop: 
0aa6 cb 13		    rl e 
0aa8 17			    rla 
0aa9 91			    sub c 
0aaa 30 01		    jr nc,Div8_NoAdd 
0aac 81			    add a,c 
0aad			Div8_NoAdd: 
0aad 10 f7		    djnz Div8_Loop 
0aaf 47			    ld b,a 
0ab0 7b			    ld a,e 
0ab1 17			    rla 
0ab2 2f			    cpl 
0ab3 c9			    ret 
0ab4			 
0ab4			; 
0ab4			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ab4			; In: Multiply A with DE 
0ab4			; Out: HL = result 
0ab4			; 
0ab4			Mult12U: 
0ab4 2e 00		    ld l,0 
0ab6 87			    add a,a 
0ab7 30 01		    jr nc,Mult12U_NoAdd0 
0ab9 19			    add hl,de 
0aba			Mult12U_NoAdd0: 
0aba 29			    add hl,hl 
0abb 87			    add a,a 
0abc 30 01		    jr nc,Mult12U_NoAdd1 
0abe 19			    add hl,de 
0abf			Mult12U_NoAdd1: 
0abf 29			    add hl,hl 
0ac0 87			    add a,a 
0ac1 30 01		    jr nc,Mult12U_NoAdd2 
0ac3 19			    add hl,de 
0ac4			Mult12U_NoAdd2: 
0ac4 29			    add hl,hl 
0ac5 87			    add a,a 
0ac6 30 01		    jr nc,Mult12U_NoAdd3 
0ac8 19			    add hl,de 
0ac9			Mult12U_NoAdd3: 
0ac9 29			    add hl,hl 
0aca 87			    add a,a 
0acb 30 01		    jr nc,Mult12U_NoAdd4 
0acd 19			    add hl,de 
0ace			Mult12U_NoAdd4: 
0ace 29			    add hl,hl 
0acf 87			    add a,a 
0ad0 30 01		    jr nc,Mult12U_NoAdd5 
0ad2 19			    add hl,de 
0ad3			Mult12U_NoAdd5: 
0ad3 29			    add hl,hl 
0ad4 87			    add a,a 
0ad5 30 01		    jr nc,Mult12U_NoAdd6 
0ad7 19			    add hl,de 
0ad8			Mult12U_NoAdd6: 
0ad8 29			    add hl,hl 
0ad9 87			    add a,a 
0ada d0			    ret nc 
0adb 19			    add hl,de 
0adc c9			    ret 
0add			 
0add			; 
0add			; Multiply 8-bit value with a 16-bit value (right rotating) 
0add			; In: Multiply A with DE 
0add			;      Put lowest value in A for most efficient calculation 
0add			; Out: HL = result 
0add			; 
0add			Mult12R: 
0add 21 00 00		    ld hl,0 
0ae0			Mult12R_Loop: 
0ae0 cb 3f		    srl a 
0ae2 30 01		    jr nc,Mult12R_NoAdd 
0ae4 19			    add hl,de 
0ae5			Mult12R_NoAdd: 
0ae5 cb 23		    sla e 
0ae7 cb 12		    rl d 
0ae9 b7			    or a 
0aea c2 e0 0a		    jp nz,Mult12R_Loop 
0aed c9			    ret 
0aee			 
0aee			; 
0aee			; Multiply 16-bit values (with 32-bit result) 
0aee			; In: Multiply BC with DE 
0aee			; Out: BCHL = result 
0aee			; 
0aee			Mult32: 
0aee 79			    ld a,c 
0aef 48			    ld c,b 
0af0 21 00 00		    ld hl,0 
0af3 06 10		    ld b,16 
0af5			Mult32_Loop: 
0af5 29			    add hl,hl 
0af6 17			    rla 
0af7 cb 11		    rl c 
0af9 30 07		    jr nc,Mult32_NoAdd 
0afb 19			    add hl,de 
0afc ce 00		    adc a,0 
0afe d2 02 0b		    jp nc,Mult32_NoAdd 
0b01 0c			    inc c 
0b02			Mult32_NoAdd: 
0b02 10 f1		    djnz Mult32_Loop 
0b04 41			    ld b,c 
0b05 4f			    ld c,a 
0b06 c9			    ret 
0b07			 
0b07			 
0b07			 
0b07			; 
0b07			; Multiply 8-bit values 
0b07			; In:  Multiply H with E 
0b07			; Out: HL = result 
0b07			; 
0b07			Mult8: 
0b07 16 00		    ld d,0 
0b09 6a			    ld l,d 
0b0a 06 08		    ld b,8 
0b0c			Mult8_Loop: 
0b0c 29			    add hl,hl 
0b0d 30 01		    jr nc,Mult8_NoAdd 
0b0f 19			    add hl,de 
0b10			Mult8_NoAdd: 
0b10 10 fa		    djnz Mult8_Loop 
0b12 c9			    ret 
0b13			 
0b13			 
0b13			 
0b13			 
0b13			 
0b13			 
0b13			 
0b13			 
0b13			;;http://z80-heaven.wikidot.com/math 
0b13			;;This divides DE by BC, storing the result in DE, remainder in HL 
0b13			; 
0b13			;DE_Div_BC:          ;1281-2x, x is at most 16 
0b13			;     ld a,16        ;7 
0b13			;     ld hl,0        ;10 
0b13			;     jp $+5         ;10 
0b13			;.DivLoop: 
0b13			;       add hl,bc    ;-- 
0b13			;       dec a        ;64 
0b13			;       jr z,.DivLoopEnd        ;86 
0b13			; 
0b13			;       sla e        ;128 
0b13			;       rl d         ;128 
0b13			;       adc hl,hl    ;240 
0b13			;       sbc hl,bc    ;240 
0b13			;       jr nc,.DivLoop ;23|21 
0b13			;       inc e        ;-- 
0b13			;       jp .DivLoop+1 
0b13			; 
0b13			;.DivLoopEnd: 
0b13			 
0b13			;HL_Div_C: 
0b13			;Inputs: 
0b13			;     HL is the numerator 
0b13			;     C is the denominator 
0b13			;Outputs: 
0b13			;     A is the remainder 
0b13			;     B is 0 
0b13			;     C is not changed 
0b13			;     DE is not changed 
0b13			;     HL is the quotient 
0b13			; 
0b13			;       ld b,16 
0b13			;       xor a 
0b13			;         add hl,hl 
0b13			;         rla 
0b13			;         cp c 
0b13			;         jr c,$+4 
0b13			;           inc l 
0b13			;           sub c 
0b13			;         djnz $-7 
0b13			 
0b13			; https://plutiedev.com/z80-add-8bit-to-16bit 
0b13			 
0b13			addatohl: 
0b13 85			    add   a, l    ; A = A+L 
0b14 6f			    ld    l, a    ; L = A+L 
0b15 8c			    adc   a, h    ; A = A+L+H+carry 
0b16 95			    sub   l       ; A = H+carry 
0b17 67			    ld    h, a    ; H = H+carry 
0b18 c9			ret 
0b19			 
0b19			addatode: 
0b19 83			    add   a, e    ; A = A+L 
0b1a 5f			    ld    e, a    ; L = A+L 
0b1b 8a			    adc   a, d    ; A = A+L+H+carry 
0b1c 93			    sub   e       ; A = H+carry 
0b1d 57			    ld    d, a    ; H = H+carry 
0b1e c9			ret 
0b1f			 
0b1f			 
0b1f			addatobc: 
0b1f 81			    add   a, c    ; A = A+L 
0b20 4f			    ld    c, a    ; L = A+L 
0b21 88			    adc   a, b    ; A = A+L+H+carry 
0b22 91			    sub   c       ; A = H+carry 
0b23 47			    ld    b, a    ; H = H+carry 
0b24 c9			ret 
0b25			 
0b25			subafromhl: 
0b25			   ; If A=0 do nothing 
0b25			    ; Otherwise flip A's sign. Since 
0b25			    ; the upper byte becomes -1, also 
0b25			    ; substract 1 from H. 
0b25 ed 44		    neg 
0b27 ca 30 0b		    jp    z, Skip 
0b2a 25			    dec   h 
0b2b			     
0b2b			    ; Now add the low byte as usual 
0b2b			    ; Two's complement takes care of 
0b2b			    ; ensuring the result is correct 
0b2b 85			    add   a, l 
0b2c 6f			    ld    l, a 
0b2d 8c			    adc   a, h 
0b2e 95			    sub   l 
0b2f 67			    ld    h, a 
0b30			Skip: 
0b30 c9				ret 
0b31			 
0b31			 
0b31			; compare hl and de 
0b31			; returns:  
0b31			; if hl = de, z=1, s=0, c0=0 
0b31			; if hl > de, z=0, s=0, c=0 
0b31			; if hl < de, z=0, s=1, c=1 
0b31			cmp16:	 
0b31 b7				or a 
0b32 ed 52			sbc hl,de 
0b34 e0				ret po 
0b35 7c				ld a,h 
0b36 1f				rra 
0b37 ee 40			xor 01000000B 
0b39 37				scf 
0b3a 8f				adc a,a 
0b3b c9				ret 
0b3c			 
0b3c			 
0b3c			; test if hl contains zero   - A is destroyed 
0b3c			 
0b3c			ishlzero:    
0b3c b7				or a     ; reset flags 
0b3d 7c				ld a, h 
0b3e b5				or l        	 
0b3f			 
0b3f c9				ret 
0b40			 
0b40			 
0b40			 
0b40			 
0b40			if FORTH_ENABLE_FLOATMATH 
0b40			include "float/bbcmath.z80" 
0b40			endif 
0b40			 
0b40			 
0b40			; eof 
0b40			 
# End of file firmware_maths.asm
0b40			include "firmware_strings.asm"   ; string handling  
0b40			 
0b40			 
0b40			; TODO string len 
0b40			; input text string, end on cr with zero term 
0b40			; a offset into frame buffer to start prompt 
0b40			; d is max length 
0b40			; e is display size TODO 
0b40			; c is current cursor position 
0b40			; hl is ptr to where string will be stored 
0b40			 
0b40			 
0b40			; TODO check limit of buffer for new inserts 
0b40			; TODO check insert does not push beyond buffer 
0b40			; TODO scroll in a limited display area 
0b40			; TODO scroll whole screen on page wrap 
0b40			 
0b40			 
0b40			; TODO handle KEY_PREVWORD 
0b40			; TODO handle KEY_NEXTWORD 
0b40			; TODO handle KEY_HOME 
0b40			; TODO handle KEY_END 
0b40			; TODO use LCD cursor? 
0b40			 
0b40 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0b43 81					add c 
0b44 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0b47 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0b4a 79					ld a, c 
0b4b cd 13 0b				call addatohl 
0b4e 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0b51 7a					ld a,d 
0b52 32 b8 fb			        ld (input_size), a       ; save length of input area 
0b55 79					ld a, c 
0b56 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0b59 7b					ld a,e 
0b5a 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0b5d					 
0b5d					 
0b5d			 
0b5d			;		ld a,(input_ptr) 
0b5d			;		ld (input_under_cursor),a 	; save what is under the cursor 
0b5d			 
0b5d			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0b5d					; init cursor shape if not set by the cin routines 
0b5d 21 56 fa				ld hl, cursor_shape 
0b60 3e ff				ld a, 255 
0b62 77					ld (hl), a 
0b63 23					inc hl 
0b64 3e 00				ld a, 0 
0b66 77					ld (hl), a 
0b67			 
0b67 3e 0f				ld a, CUR_BLINK_RATE 
0b69 32 b2 fb				ld (input_cur_flash), a 
0b6c 3e 01				ld a, 1 
0b6e 32 b1 fb				ld (input_cur_onoff),a 
0b71			 
0b71			;	if DEBUG_INPUT 
0b71			;		push af 
0b71			;		ld a, 'I' 
0b71			;		ld (debug_mark),a 
0b71			;		pop af 
0b71			;		CALLMONITOR 
0b71			;	endif 
0b71			.is1:		; main entry loop 
0b71			 
0b71			 
0b71			 
0b71					; pause 1ms 
0b71			 
0b71 3e 01				ld a, 1 
0b73 cd 23 09				call aDelayInMS 
0b76			 
0b76					; dec flash counter 
0b76 3a b2 fb				ld a, (input_cur_flash) 
0b79 3d					dec a 
0b7a 32 b2 fb				ld (input_cur_flash), a 
0b7d fe 00				cp 0 
0b7f 20 0d				jr nz, .nochgstate 
0b81			 
0b81			 
0b81					; change state 
0b81 3a b1 fb				ld a,(input_cur_onoff) 
0b84 ed 44				neg 
0b86 32 b1 fb				ld (input_cur_onoff),a 
0b89			 
0b89			 
0b89					; reset on change of state 
0b89 3e 0f				ld a, CUR_BLINK_RATE 
0b8b 32 b2 fb				ld (input_cur_flash), a 
0b8e			 
0b8e			.nochgstate: 
0b8e					 
0b8e					 
0b8e			 
0b8e					; display cursor  
0b8e			 
0b8e			;		ld hl, (input_start) 
0b8e			;		ld a, (input_cursor) 
0b8e			;		call addatohl 
0b8e			 
0b8e					; get char under cursor and replace with cursor 
0b8e 2a bb fb		ld hl, (input_ptr) 
0b91			;		ld a, (hl) 
0b91			;		ld (input_under_cursor),a 
0b91			;		ld a, '_' 
0b91			;		ld (hl), a 
0b91			 
0b91					; display string 
0b91			 
0b91 ed 5b b9 fb			ld de, (input_start) 
0b95 3a b6 fb				ld a, (input_at_pos) 
0b98 cd cd 09				call str_at_display 
0b9b			;	        call update_display 
0b9b			 
0b9b					; find place to put the cursor 
0b9b			;		add h 
0b9b			;		ld l, display_row_1 
0b9b			;		sub l 
0b9b			; (input_at_pos) 
0b9b					;ld c, a 
0b9b			;		ld a, (input_cursor) 
0b9b			;		ld l, (input_at_pos) 
0b9b			;		;ld b, h 
0b9b			;		add l 
0b9b			;		ld (input_at_cursor),a 
0b9b					;ld l,h 
0b9b			 
0b9b			;		ld h, 0 
0b9b			;		ld l,(input_at_pos) 
0b9b			;		ld a, (input_cursor) 
0b9b			;		call addatohl 
0b9b			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0b9b			;		call subafromhl 
0b9b			;		ld a,l 
0b9b			;		ld (input_at_cursor), a 
0b9b			 
0b9b				if DEBUG_INPUT 
0b9b					ld a, (hardware_diag) 
0b9b					cp 0 
0b9b					jr z, .skip_input_diag 
0b9b			 
0b9b					ld a,(input_at_pos) 
0b9b					ld hl, LFSRSeed 
0b9b					call hexout 
0b9b					ld a, (input_cursor) 
0b9b					ld hl, LFSRSeed+2 
0b9b					call hexout 
0b9b					ld a,(input_at_cursor) 
0b9b					ld hl, LFSRSeed+4 
0b9b					call hexout 
0b9b			 
0b9b					ld a,(input_cur_onoff) 
0b9b					ld hl, LFSRSeed+6 
0b9b					call hexout 
0b9b			 
0b9b					ld a,(input_cur_flash) 
0b9b					ld hl, LFSRSeed+8 
0b9b					call hexout 
0b9b			 
0b9b					ld a,(input_len) 
0b9b					ld hl, LFSRSeed+10 
0b9b					call hexout 
0b9b					ld hl, LFSRSeed+12 
0b9b					ld a, 0 
0b9b					ld (hl),a 
0b9b					ld a, display_row_4 
0b9b					ld de, LFSRSeed 
0b9b					call str_at_display 
0b9b					.skip_input_diag: 
0b9b				endif 
0b9b			 
0b9b					; decide on if we are showing the cursor this time round 
0b9b			 
0b9b 3a b1 fb				ld a, (input_cur_onoff) 
0b9e fe ff				cp 255 
0ba0 28 13				jr z, .skipcur 
0ba2			 
0ba2			 
0ba2 3a b4 fb				ld a,(input_at_cursor) 
0ba5 11 56 fa				ld de, cursor_shape 
0ba8 cd cd 09				call str_at_display 
0bab			 
0bab					; save length of current input string 
0bab 2a b9 fb				ld hl, (input_start) 
0bae cd 71 0f				call strlenz 
0bb1 7d					ld a,l 
0bb2 32 ac fb				ld (input_len),a 
0bb5			 
0bb5			.skipcur: 
0bb5			 
0bb5 cd dd 09			        call update_display 
0bb8					 
0bb8			 
0bb8			 
0bb8					; wait 
0bb8				 
0bb8					; TODO loop without wait to flash the cursor and char under cursor	 
0bb8 cd 34 53				call cin    ; _wait 
0bbb			 
0bbb fe 00				cp 0 
0bbd ca 71 0b				jp z, .is1 
0bc0			 
0bc0					; get ptr to char to input into 
0bc0			 
0bc0 4f					ld c,a 
0bc1 2a b9 fb				ld hl, (input_start) 
0bc4 3a a7 fb				ld a, (input_cursor) 
0bc7 cd 13 0b				call addatohl 
0bca 22 bb fb				ld (input_ptr), hl 
0bcd 79					ld a,c 
0bce			 
0bce					; replace char under cursor 
0bce			 
0bce			;		ld hl, (input_ptr) 
0bce			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0bce			;		ld (hl), a 
0bce			 
0bce			;	if DEBUG_INPUT 
0bce			;		push af 
0bce			;		ld a, 'i' 
0bce			;		ld (debug_mark),a 
0bce			;		pop af 
0bce			;		CALLMONITOR 
0bce			;	endif 
0bce fe 0e				cp KEY_HOME 
0bd0 20 0e				jr nz, .iske 
0bd2			 
0bd2 3a b6 fb				ld a, (input_at_pos) 
0bd5 32 b4 fb				ld (input_at_cursor),a 
0bd8 3e 00				ld a, 0 
0bda 32 a7 fb				ld (input_cursor), a 
0bdd c3 71 0b				jp .is1 
0be0					 
0be0 fe 0f		.iske:		cp KEY_END 
0be2 20 03				jr nz, .isknw 
0be4 c3 71 0b				jp .is1 
0be7			 
0be7 fe 06		.isknw:		cp KEY_NEXTWORD 
0be9 20 1b				jr nz, .iskpw 
0beb			 
0beb 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0bee 7e					ld a,(hl)	 
0bef fe 00				cp 0 
0bf1 ca 71 0b				jp z, .is1    ; end of string 
0bf4 fe 20				cp ' ' 
0bf6 ca 71 0b				jp z, .is1    ; end of word 
0bf9 23					inc hl 
0bfa 22 bb fb				ld (input_ptr), hl 
0bfd 3a b4 fb				ld a, (input_at_cursor) 
0c00 3c					inc a 
0c01 32 b4 fb				ld (input_at_cursor), a 
0c04 18 e5				jr .isknwm 
0c06			 
0c06 fe 07		.iskpw:		cp KEY_PREVWORD 
0c08 20 1b				jr nz, .iskl 
0c0a			.iskpwm:	 
0c0a 2a bb fb				ld hl, (input_ptr) 
0c0d 7e					ld a,(hl)	 
0c0e fe 00				cp 0  
0c10 ca 71 0b				jp z, .is1    ; end of string 
0c13 fe 20				cp ' ' 
0c15 ca 71 0b				jp z, .is1    ; end of word 
0c18 2b					dec hl 
0c19 22 bb fb				ld (input_ptr), hl 
0c1c 3a b4 fb				ld a, (input_at_cursor) 
0c1f 3d					dec a 
0c20 32 b4 fb				ld (input_at_cursor), a 
0c23 18 e5				jr .iskpwm 
0c25			 
0c25			 
0c25 fe 0b		.iskl:		cp KEY_LEFT 
0c27 20 27				jr nz, .isk1 
0c29			 
0c29 3a a7 fb				ld a, (input_cursor) 
0c2c			 
0c2c fe 00				cp 0 
0c2e ca 71 0b				jp z, .is1 		; at start of line to ignore  
0c31			 
0c31 3d					dec  a 		; TODO check underflow 
0c32 32 a7 fb				ld (input_cursor), a 
0c35			 
0c35 2a bb fb				ld hl, (input_ptr) 
0c38 2b					dec hl 
0c39 22 bb fb				ld (input_ptr), hl 
0c3c					 
0c3c 3a b4 fb				ld a, (input_at_cursor) 
0c3f 3d					dec a 
0c40 32 b4 fb				ld (input_at_cursor), a 
0c43			 
0c43 3e 01				ld a, 1		; show cursor moving 
0c45 32 b1 fb				ld (input_cur_onoff),a 
0c48 3e 0f				ld a, CUR_BLINK_RATE 
0c4a 32 b2 fb				ld (input_cur_flash), a 
0c4d			 
0c4d c3 71 0b				jp .is1 
0c50			 
0c50 fe 0c		.isk1:		cp KEY_RIGHT 
0c52 20 2a				jr nz, .isk2 
0c54			 
0c54 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0c57 5f					ld e,a 
0c58 3a a7 fb				ld a, (input_cursor) 
0c5b bb					cp e 
0c5c ca 71 0b				jp z, .is1		; at the end of string so dont go right 
0c5f			 
0c5f 3c					inc  a 		; TODO check overflow 
0c60 32 a7 fb				ld (input_cursor), a 
0c63			 
0c63 3a b4 fb				ld a, (input_at_cursor) 
0c66 3c					inc a 
0c67 32 b4 fb				ld (input_at_cursor), a 
0c6a			 
0c6a 2a bb fb				ld hl, (input_ptr) 
0c6d 23					inc hl 
0c6e 22 bb fb				ld (input_ptr), hl 
0c71			 
0c71 3e 01				ld a, 1		; show cursor moving 
0c73 32 b1 fb				ld (input_cur_onoff),a 
0c76 3e 0f				ld a, CUR_BLINK_RATE 
0c78 32 b2 fb				ld (input_cur_flash), a 
0c7b			 
0c7b c3 71 0b				jp .is1 
0c7e			 
0c7e fe 05		.isk2:		cp KEY_UP 
0c80			 
0c80 20 26				jr nz, .isk3 
0c82			 
0c82					; swap last command with the current on 
0c82			 
0c82					; move cursor to start of string 
0c82 2a b9 fb				ld hl, (input_start) 
0c85 22 bb fb				ld (input_ptr), hl 
0c88			 
0c88 3a b6 fb				ld a, (input_at_pos) 
0c8b 32 b4 fb				ld (input_at_cursor), a 
0c8e			 
0c8e 3e 00				ld a, 0 
0c90 32 a7 fb				ld (input_cursor), a 
0c93					 
0c93					; swap input and last command buffers 
0c93			 
0c93 21 df f2				ld hl, os_cli_cmd 
0c96 11 de f3				ld de, os_last_cmd 
0c99 06 ff				ld b, 255 
0c9b 7e			.swap1:		ld a, (hl) 
0c9c 4f					ld c,a 
0c9d 1a					ld a, (de) 
0c9e 77					ld (hl), a 
0c9f 79					ld a,c 
0ca0 12					ld (de),a 
0ca1 23					inc hl 
0ca2 13					inc de 
0ca3 10 f6				djnz .swap1 
0ca5			 
0ca5			 
0ca5			 
0ca5			 
0ca5			 
0ca5 c3 71 0b				jp .is1 
0ca8			 
0ca8 fe 08		.isk3:		cp KEY_BS 
0caa 20 3c				jr nz, .isk4 
0cac			 
0cac 3a a7 fb				ld a, (input_cursor) 
0caf			 
0caf fe 00				cp 0 
0cb1 ca 71 0b				jp z, .is1 		; at start of line to ignore  
0cb4			 
0cb4 3d					dec  a 		; TODO check underflow 
0cb5 32 a7 fb				ld (input_cursor), a 
0cb8			 
0cb8					; hl is source 
0cb8					; de needs to be source - 1 
0cb8			 
0cb8			;		ld a, 0 
0cb8			;		dec hl 
0cb8			;		ld (hl), a 
0cb8			 
0cb8 2a bb fb				ld hl, (input_ptr) 
0cbb 2b					dec hl 
0cbc 22 bb fb				ld (input_ptr), hl 
0cbf			 
0cbf					; shift all data 
0cbf			 
0cbf e5					push hl 
0cc0 23					inc hl 
0cc1 d1					pop de 
0cc2 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0cc5 4f					ld c,a 
0cc6 06 00				ld b,0 
0cc8 ed b0				ldir  
0cca			 
0cca			 
0cca			 
0cca			 
0cca 3a b4 fb				ld a, (input_at_cursor) 
0ccd 3d					dec a 
0cce 32 b4 fb				ld (input_at_cursor), a 
0cd1			 
0cd1			 
0cd1 3e 01				ld a, 1		; show cursor moving 
0cd3 32 b1 fb				ld (input_cur_onoff),a 
0cd6 3e 0f				ld a, CUR_BLINK_RATE 
0cd8 32 b2 fb				ld (input_cur_flash), a 
0cdb			 
0cdb					; remove char 
0cdb 3a b4 fb				ld a, (input_at_cursor) 
0cde 3c					inc a 
0cdf 11 69 0d				ld de,.iblank 
0ce2 cd cd 09				call str_at_display 
0ce5			 
0ce5 c3 71 0b				jp .is1 
0ce8			 
0ce8 fe 0d		.isk4:		cp KEY_CR 
0cea 28 6c				jr z, .endinput 
0cec			 
0cec					; else add the key press to the end 
0cec			 
0cec 4f					ld c, a			; save key pressed 
0ced			 
0ced 7e					ld a,(hl)		; get what is currently under char 
0cee			 
0cee fe 00				cp 0			; we are at the end of the string 
0cf0 20 2f				jr nz, .onchar 
0cf2					 
0cf2					; add a char to the end of the string 
0cf2				 
0cf2 71					ld (hl),c 
0cf3 23					inc hl 
0cf4			;		ld a,' ' 
0cf4			;		ld (hl),a 
0cf4			;		inc hl 
0cf4 3e 00				ld a,0 
0cf6 77					ld (hl),a 
0cf7 2b					dec hl 
0cf8			 
0cf8 3a a7 fb				ld a, (input_cursor) 
0cfb 3c					inc a				; TODO check max string length and scroll  
0cfc 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0cff							 
0cff 3a b4 fb				ld a, (input_at_cursor) 
0d02 3c					inc a 
0d03 32 b4 fb				ld (input_at_cursor), a 
0d06			 
0d06 2a bb fb				ld hl, (input_ptr) 
0d09 23					inc hl 
0d0a 22 bb fb				ld (input_ptr), hl 
0d0d			 
0d0d 2a bb fb				ld hl, (input_ptr) 
0d10 23					inc hl 
0d11 22 bb fb				ld (input_ptr), hl 
0d14			;	if DEBUG_INPUT 
0d14			;		push af 
0d14			;		ld a, '+' 
0d14			;		ld (debug_mark),a 
0d14			;		pop af 
0d14			;		CALLMONITOR 
0d14			;	endif 
0d14 3e 01				ld a, 1		; show cursor moving 
0d16 32 b1 fb				ld (input_cur_onoff),a 
0d19 3e 0f				ld a, CUR_BLINK_RATE 
0d1b 32 b2 fb				ld (input_cur_flash), a 
0d1e c3 71 0b				jp .is1 
0d21					 
0d21			 
0d21			 
0d21					; if on a char then insert 
0d21			.onchar: 
0d21			 
0d21					; TODO over flow check: make sure insert does not blow out buffer 
0d21			 
0d21					; need to do some maths to use lddr 
0d21			 
0d21 e5					push hl   ; save char pos 
0d22 c5					push bc 
0d23			 
0d23 2a b9 fb				ld hl, (input_start) 
0d26 3a ac fb				ld a, (input_len) 
0d29 cd 13 0b				call addatohl  		; end of string 
0d2c 23					inc hl 
0d2d 23					inc hl		; past zero term 
0d2e e5					push hl 
0d2f 23					inc hl 
0d30 e5					push hl  
0d31			 
0d31								; start and end of lddr set, now how much to move? 
0d31			 
0d31							 
0d31 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0d34 47					ld b,a 
0d35 3a ac fb				ld a,(input_len) 
0d38 5f					ld e,a 
0d39 90					sub b 
0d3a 3c					inc a		;?? 
0d3b 3c					inc a		;?? 
0d3c 3c					inc a		;?? 
0d3d			 
0d3d 06 00				ld b,0 
0d3f 4f					ld c,a 
0d40			 
0d40				if DEBUG_INPUT 
0d40					push af 
0d40					ld a, 'i' 
0d40					ld (debug_mark),a 
0d40					pop af 
0d40			;		CALLMONITOR 
0d40				endif 
0d40 d1					pop de 
0d41 e1					pop hl 
0d42				if DEBUG_INPUT 
0d42					push af 
0d42					ld a, 'I' 
0d42					ld (debug_mark),a 
0d42					pop af 
0d42			;		CALLMONITOR 
0d42				endif 
0d42 ed b8				lddr 
0d44				 
0d44			 
0d44			 
0d44					; TODO have a key for insert/overwrite mode???? 
0d44 c1					pop bc 
0d45 e1					pop hl 
0d46 71					ld (hl), c		; otherwise overwrite current char 
0d47					 
0d47			 
0d47			 
0d47			 
0d47 3a a7 fb				ld a, (input_cursor) 
0d4a 3c					inc  a 		; TODO check overflow 
0d4b 32 a7 fb				ld (input_cursor), a 
0d4e			 
0d4e 3a b4 fb				ld a, (input_at_cursor) 
0d51 3c					inc a 
0d52 32 b4 fb				ld (input_at_cursor), a 
0d55			 
0d55 c3 71 0b				jp .is1 
0d58			 
0d58			.endinput:	; TODO look for end of string 
0d58			 
0d58					; add trailing space for end of token 
0d58			 
0d58 2a b9 fb				ld hl, (input_start) 
0d5b 3a ac fb				ld a,(input_len) 
0d5e cd 13 0b				call addatohl 
0d61 3e 20				ld a, ' ' 
0d63 77					ld (hl),a 
0d64					; TODO eof of parse marker 
0d64			 
0d64 23					inc hl 
0d65 3e 00				ld a, 0 
0d67 77					ld (hl),a 
0d68			 
0d68			 
0d68 c9					ret 
0d69			 
0d69 .. 00		.iblank: db " ",0 
0d6b			 
0d6b			 
0d6b 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0d6e 22 b9 fb				ld (input_start), hl 
0d71 3e 01				ld a,1			; add cursor 
0d73 77					ld (hl),a 
0d74 23					inc hl 
0d75 3e 00				ld a,0 
0d77 77					ld (hl),a 
0d78 22 bb fb				ld (input_ptr), hl 
0d7b 7a					ld a,d 
0d7c 32 b8 fb				ld (input_size), a 
0d7f 3e 00				ld a,0 
0d81 32 a7 fb				ld (input_cursor),a 
0d84			.instr1:	 
0d84			 
0d84					; TODO do block cursor 
0d84					; TODO switch cursor depending on the modifer key 
0d84			 
0d84					; update cursor shape change on key hold 
0d84			 
0d84 2a bb fb				ld hl, (input_ptr) 
0d87 2b					dec hl 
0d88 3a 56 fa				ld a,(cursor_shape) 
0d8b 77					ld (hl), a 
0d8c			 
0d8c					; display entered text 
0d8c 3a b6 fb				ld a,(input_at_pos) 
0d8f cd 52 52		            	CALL fLCD_Pos       ;Position cursor to location in A 
0d92 ed 5b b9 fb	            	LD   de, (input_start) 
0d96 cd 5a 52		            	CALL fLCD_Str       ;Display string pointed to by DE 
0d99			 
0d99 cd 34 53				call cin 
0d9c fe 00				cp 0 
0d9e 28 e4				jr z, .instr1 
0da0			 
0da0					; proecess keyboard controls first 
0da0			 
0da0 2a bb fb				ld hl,(input_ptr) 
0da3			 
0da3 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0da5 28 5a				jr z, .instrcr 
0da7			 
0da7 fe 08				cp KEY_BS 	; back space 
0da9 20 0f				jr nz, .instr2 
0dab					; process back space 
0dab			 
0dab					; TODO stop back space if at start of string 
0dab 2b					dec hl 
0dac 2b					dec hl ; to over write cursor 
0dad 3a 56 fa				ld a,(cursor_shape) 
0db0					;ld a,0 
0db0 77					ld (hl),a 
0db1 23					inc hl 
0db2 3e 20				ld a," " 
0db4 77					ld (hl),a 
0db5 22 bb fb				ld (input_ptr),hl 
0db8					 
0db8			 
0db8 18 ca				jr .instr1 
0dba			 
0dba fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0dbc 20 06				jr nz, .instr3 
0dbe 2b					dec hl 
0dbf 22 bb fb				ld (input_ptr),hl 
0dc2 18 c0				jr .instr1 
0dc4				 
0dc4 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0dc6 20 06				jr nz, .instr4 
0dc8 23					inc hl 
0dc9 22 bb fb				ld (input_ptr),hl 
0dcc 18 b6				jr .instr1 
0dce			 
0dce fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0dd0 20 06				jr nz, .instr5 
0dd2 2b					dec hl 
0dd3 22 bb fb				ld (input_ptr),hl 
0dd6 18 ac				jr .instr1 
0dd8			 
0dd8 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0dda 20 06				jr nz, .instr6 
0ddc 2b					dec hl 
0ddd 22 bb fb				ld (input_ptr),hl 
0de0 18 a2				jr .instr1 
0de2 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0de4 20 0b				jr nz, .instrnew 
0de6			 
0de6 21 b8 ef			ld hl, scratch 
0de9 11 de f3			ld de, os_last_cmd 
0dec cd 0a 0e			call strcpy 
0def 18 93				jr .instr1 
0df1			 
0df1			 
0df1			.instrnew:	; no special key pressed to see if we have room to store it 
0df1			 
0df1					; TODO do string size test 
0df1			 
0df1 2b					dec hl ; to over write cursor 
0df2 77					ld (hl),a 
0df3 23					inc hl 
0df4 3a 56 fa				ld a,(cursor_shape) 
0df7 77					ld (hl),a 
0df8 23					inc hl 
0df9 3e 00				ld a,0 
0dfb 77					ld (hl),a 
0dfc			 
0dfc 22 bb fb				ld (input_ptr),hl 
0dff					 
0dff 18 83				jr .instr1 
0e01 2b			.instrcr:	dec hl		; remove cursor 
0e02 3e 20				ld a,' '	; TODO add a trailing space for safety 
0e04 77					ld (hl),a 
0e05 23					inc hl 
0e06 3e 00				ld a,0 
0e08 77					ld (hl),a 
0e09			 
0e09			 
0e09					; if at end of line scroll up    
0e09					; TODO detecting only end of line 4 for scroll up  
0e09			 
0e09					;ld   
0e09			 
0e09 c9					ret 
0e0a			 
0e0a			 
0e0a			; strcpy hl = dest, de source 
0e0a			 
0e0a 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0e0b b7			            OR   A              ;Null terminator? 
0e0c c8			            RET  Z              ;Yes, so finished 
0e0d 1a					ld a,(de) 
0e0e 77					ld (hl),a 
0e0f 13			            INC  DE             ;Point to next character 
0e10 23					inc hl 
0e11 18 f7		            JR   strcpy       ;Repeat 
0e13 c9					ret 
0e14			 
0e14			 
0e14			; TODO string_at  
0e14			; pass string which starts with lcd offset address and then null term string 
0e14			 
0e14			; TODO string to dec 
0e14			; TODO string to hex 
0e14			; TODO byte to string hex 
0e14			; TODO byte to string dec 
0e14			 
0e14			 
0e14			 
0e14			; from z80uartmonitor 
0e14			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e14			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0e14			; pass hl for where to put the text 
0e14			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e14 c5			hexout:	PUSH BC 
0e15 f5					PUSH AF 
0e16 47					LD B, A 
0e17					; Upper nybble 
0e17 cb 3f				SRL A 
0e19 cb 3f				SRL A 
0e1b cb 3f				SRL A 
0e1d cb 3f				SRL A 
0e1f cd 2f 0e				CALL tohex 
0e22 77					ld (hl),a 
0e23 23					inc hl	 
0e24					 
0e24					; Lower nybble 
0e24 78					LD A, B 
0e25 e6 0f				AND 0FH 
0e27 cd 2f 0e				CALL tohex 
0e2a 77					ld (hl),a 
0e2b 23					inc hl	 
0e2c					 
0e2c f1					POP AF 
0e2d c1					POP BC 
0e2e c9					RET 
0e2f					 
0e2f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e2f			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0e2f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0e2f			tohex: 
0e2f e5					PUSH HL 
0e30 d5					PUSH DE 
0e31 16 00				LD D, 0 
0e33 5f					LD E, A 
0e34 21 3c 0e				LD HL, .DATA 
0e37 19					ADD HL, DE 
0e38 7e					LD A, (HL) 
0e39 d1					POP DE 
0e3a e1					POP HL 
0e3b c9					RET 
0e3c			 
0e3c			.DATA: 
0e3c 30					DEFB	30h	; 0 
0e3d 31					DEFB	31h	; 1 
0e3e 32					DEFB	32h	; 2 
0e3f 33					DEFB	33h	; 3 
0e40 34					DEFB	34h	; 4 
0e41 35					DEFB	35h	; 5 
0e42 36					DEFB	36h	; 6 
0e43 37					DEFB	37h	; 7 
0e44 38					DEFB	38h	; 8 
0e45 39					DEFB	39h	; 9 
0e46 41					DEFB	41h	; A 
0e47 42					DEFB	42h	; B 
0e48 43					DEFB	43h	; C 
0e49 44					DEFB	44h	; D 
0e4a 45					DEFB	45h	; E 
0e4b 46					DEFB	46h	; F 
0e4c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0e4c			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0e4c			;;    subtract $30, if result > 9 then subtract $7 more 
0e4c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0e4c			atohex: 
0e4c d6 30				SUB $30 
0e4e fe 0a				CP 10 
0e50 f8					RET M		; If result negative it was 0-9 so we're done 
0e51 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0e53 c9					RET		 
0e54			 
0e54			 
0e54			 
0e54			 
0e54			; Get 2 ASCII characters as hex byte from pointer in hl 
0e54			 
0e54			BYTERD: 
0e54 16 00			LD	D,00h		;Set up 
0e56 cd 5e 0e			CALL	HEXCON		;Get byte and convert to hex 
0e59 87				ADD	A,A		;First nibble so 
0e5a 87				ADD	A,A		;multiply by 16 
0e5b 87				ADD	A,A		; 
0e5c 87				ADD	A,A		; 
0e5d 57				LD	D,A		;Save hi nibble in D 
0e5e			HEXCON: 
0e5e 7e				ld a, (hl)		;Get next chr 
0e5f 23				inc hl 
0e60 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0e62 fe 0a			CP	00Ah		;Is it 0-9 ? 
0e64 38 02			JR	C,NALPHA	;If so miss next bit 
0e66 d6 07			SUB	007h		;Else convert alpha 
0e68			NALPHA: 
0e68 b2				OR	D		;Add hi nibble back 
0e69 c9				RET			; 
0e6a			 
0e6a			 
0e6a			; 
0e6a			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0e6a			; Since the routines get_byte and therefore get_nibble are called, only valid 
0e6a			; characters (0-9a-f) are accepted. 
0e6a			; 
0e6a			;get_word        push    af 
0e6a			;                call    get_byte        ; Get the upper byte 
0e6a			;                ld      h, a 
0e6a			;                call    get_byte        ; Get the lower byte 
0e6a			;                ld      l, a 
0e6a			;                pop     af 
0e6a			;                ret 
0e6a			; 
0e6a			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0e6a			; the routine get_nibble is used only valid characters are accepted - the  
0e6a			; input routine only accepts characters 0-9a-f. 
0e6a			; 
0e6a c5			get_byte:        push    bc              ; Save contents of B (and C) 
0e6b 7e					ld a,(hl) 
0e6c 23					inc hl 
0e6d cd 92 0e		                call    nibble2val      ; Get upper nibble 
0e70 cb 07		                rlc     a 
0e72 cb 07		                rlc     a 
0e74 cb 07		                rlc     a 
0e76 cb 07		                rlc     a 
0e78 47			                ld      b, a            ; Save upper four bits 
0e79 7e					ld a,(hl) 
0e7a cd 92 0e		                call    nibble2val      ; Get lower nibble 
0e7d b0			                or      b               ; Combine both nibbles 
0e7e c1			                pop     bc              ; Restore B (and C) 
0e7f c9			                ret 
0e80			; 
0e80			; Get a hexadecimal digit from the serial line. This routine blocks until 
0e80			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0e80			; to the serial line interface. The lower 4 bits of A contain the value of  
0e80			; that particular digit. 
0e80			; 
0e80			;get_nibble      ld a,(hl)           ; Read a character 
0e80			;                call    to_upper        ; Convert to upper case 
0e80			;                call    is_hex          ; Was it a hex digit? 
0e80			;                jr      nc, get_nibble  ; No, get another character 
0e80			 ;               call    nibble2val      ; Convert nibble to value 
0e80			 ;               call    print_nibble 
0e80			 ;               ret 
0e80			; 
0e80			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0e80			; A valid hexadecimal digit is denoted by a set C flag. 
0e80			; 
0e80			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0e80			;                ret     nc              ; Yes 
0e80			;                cp      '0'             ; Less than '0'? 
0e80			;                jr      nc, is_hex_1    ; No, continue 
0e80			;                ccf                     ; Complement carry (i.e. clear it) 
0e80			;                ret 
0e80			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0e80			;                ret     c               ; Yes 
0e80			;                cp      'A'             ; Less than 'A'? 
0e80			;                jr      nc, is_hex_2    ; No, continue 
0e80			;                ccf                     ; Yes - clear carry and return 
0e80			;                ret 
0e80			;is_hex_2        scf                     ; Set carry 
0e80			;                ret 
0e80			; 
0e80			; Convert a single character contained in A to upper case: 
0e80			; 
0e80 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0e82 d8			                ret     c 
0e83 fe 7b		                cp      'z' + 1         ; > 'z'? 
0e85 d0			                ret     nc              ; Nothing to do, either 
0e86 e6 5f		                and     $5f             ; Convert to upper case 
0e88 c9			                ret 
0e89			 
0e89			 
0e89			to_lower: 
0e89			 
0e89			   ; if char is in [A-Z] make it lower case 
0e89			 
0e89			   ; enter : a = char 
0e89			   ; exit  : a = lower case char 
0e89			   ; uses  : af 
0e89			 
0e89 fe 41		   cp 'A' 
0e8b d8			   ret c 
0e8c			    
0e8c fe 5b		   cp 'Z'+1 
0e8e d0			   ret nc 
0e8f			    
0e8f f6 20		   or $20 
0e91 c9			   ret 
0e92			 
0e92			; 
0e92			; Expects a hexadecimal digit (upper case!) in A and returns the 
0e92			; corresponding value in A. 
0e92			; 
0e92 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0e94 38 02		                jr      c, nibble2val_1 ; Yes 
0e96 d6 07		                sub     7               ; Adjust for A-F 
0e98 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0e9a e6 0f		                and     $f              ; Only return lower 4 bits 
0e9c c9			                ret 
0e9d			; 
0e9d			; Print_nibble prints a single hex nibble which is contained in the lower  
0e9d			; four bits of A: 
0e9d			; 
0e9d			;print_nibble    push    af              ; We won't destroy the contents of A 
0e9d			;                and     $f              ; Just in case... 
0e9d			;                add     a, '0'             ; If we have a digit we are done here. 
0e9d			;                cp      '9' + 1         ; Is the result > 9? 
0e9d			;                jr      c, print_nibble_1 
0e9d			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0e9d			;print_nibble_1  call    putc            ; Print the nibble and 
0e9d			;                pop     af              ; restore the original value of A 
0e9d			;                ret 
0e9d			;; 
0e9d			;; Send a CR/LF pair: 
0e9d			; 
0e9d			;crlf            push    af 
0e9d			;                ld      a, cr 
0e9d			;                call    putc 
0e9d			;                ld      a, lf 
0e9d			;                call    putc 
0e9d			;                pop     af 
0e9d			;                ret 
0e9d			; 
0e9d			; Print_word prints the four hex digits of a word to the serial line. The  
0e9d			; word is expected to be in HL. 
0e9d			; 
0e9d			;print_word      push    hl 
0e9d			;                push    af 
0e9d			;                ld      a, h 
0e9d			;                call    print_byte 
0e9d			;                ld      a, l 
0e9d			;                call    print_byte 
0e9d			;                pop     af 
0e9d			;                pop     hl 
0e9d			;                ret 
0e9d			; 
0e9d			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0e9d			; The byte to be printed is expected to be in A. 
0e9d			; 
0e9d			;print_byte      push    af              ; Save the contents of the registers 
0e9d			;                push    bc 
0e9d			;                ld      b, a 
0e9d			;                rrca 
0e9d			;                rrca 
0e9d			;                rrca 
0e9d			;                rrca 
0e9d			;                call    print_nibble    ; Print high nibble 
0e9d			;                ld      a, b 
0e9d			;                call    print_nibble    ; Print low nibble 
0e9d			;                pop     bc              ; Restore original register contents 
0e9d			;                pop     af 
0e9d			;                ret 
0e9d			 
0e9d			 
0e9d			 
0e9d			 
0e9d			 
0e9d			fourehexhl:  
0e9d 7e				ld a,(hl) 
0e9e cd 4c 0e			call atohex 
0ea1 cb 3f				SRL A 
0ea3 cb 3f				SRL A 
0ea5 cb 3f				SRL A 
0ea7 cb 3f				SRL A 
0ea9 47				ld b, a 
0eaa 23				inc hl 
0eab 7e				ld a,(hl) 
0eac 23				inc hl 
0ead cd 4c 0e			call atohex 
0eb0 80				add b 
0eb1 57				ld d,a 
0eb2 7e				ld a,(hl) 
0eb3 cd 4c 0e			call atohex 
0eb6 cb 3f				SRL A 
0eb8 cb 3f				SRL A 
0eba cb 3f				SRL A 
0ebc cb 3f				SRL A 
0ebe 47				ld b, a 
0ebf 23				inc hl 
0ec0 7e				ld a,(hl) 
0ec1 23				inc hl 
0ec2 cd 4c 0e			call atohex 
0ec5 80				add b 
0ec6 5f				ld e, a 
0ec7 d5				push de 
0ec8 e1				pop hl 
0ec9 c9				ret 
0eca			 
0eca			; pass hl. returns z set if the byte at hl is a digit 
0eca			;isdigithl:  
0eca			;	push bc 
0eca			;	ld a,(hl) 
0eca			;	cp ':' 
0eca			;	jr nc, .isdf 		; > 
0eca			;	cp '0' 
0eca			;	jr c, .isdf		; < 
0eca			; 
0eca			;	; TODO find a better way to set z 
0eca			; 
0eca			;	ld b,a 
0eca			;	cp b 
0eca			;	pop bc 
0eca			;	ret 
0eca			; 
0eca			;.isdf:	; not digit so clear z 
0eca			; 
0eca			;	; TODO find a better way to unset z 
0eca			; 
0eca			;	ld b,a 
0eca			;	inc b 
0eca			;	cp b 
0eca			; 
0eca			;	pop bc 
0eca			;	ret 
0eca				 
0eca				 
0eca			 
0eca			 
0eca			; pass hl as the four byte address to load 
0eca			 
0eca			get_word_hl:  
0eca e5				push hl 
0ecb cd 6a 0e			call get_byte 
0ece				 
0ece 47				ld b, a 
0ecf			 
0ecf e1				pop hl 
0ed0 23				inc hl 
0ed1 23				inc hl 
0ed2			 
0ed2			; TODO not able to handle a-f  
0ed2 7e				ld a,(hl) 
0ed3			;	;cp ':' 
0ed3			;	cp 'g' 
0ed3			;	jr nc, .single_byte_hl 		; > 
0ed3			;	cp 'G' 
0ed3			;	jr nc, .single_byte_hl 		; > 
0ed3			;	cp '0' 
0ed3			;	jr c, .single_byte_hl		; < 
0ed3			 
0ed3				;call isdigithl 
0ed3 fe 00			cp 0 
0ed5 28 06			jr z, .single_byte_hl 
0ed7			 
0ed7			.getwhln:   ; hex word so get next byte 
0ed7			 
0ed7 cd 6a 0e			call get_byte 
0eda 6f				ld l, a 
0edb 60				ld h,b 
0edc c9				ret 
0edd 68			.single_byte_hl:   ld l,b 
0ede 26 00				ld h,0 
0ee0 c9					ret 
0ee1			 
0ee1			 
0ee1			 
0ee1			 
0ee1 21 7b 15			ld hl,asc+1 
0ee4			;	ld a, (hl) 
0ee4			;	call nibble2val 
0ee4 cd 6a 0e			call get_byte 
0ee7			 
0ee7			;	call fourehexhl 
0ee7 32 ec ef			ld (scratch+52),a 
0eea				 
0eea 21 ea ef			ld hl,scratch+50 
0eed 22 db f2			ld (os_cur_ptr),hl 
0ef0			 
0ef0 c9				ret 
0ef1			 
0ef1			 
0ef1			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0ef1			 
0ef1			; Decimal Unsigned Version 
0ef1			 
0ef1			;Number in a to decimal ASCII 
0ef1			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0ef1			;Example: display a=56 as "056" 
0ef1			;input: a = number 
0ef1			;Output: a=0,value of a in the screen 
0ef1			;destroys af,bc (don't know about hl and de) 
0ef1			DispAToASCII: 
0ef1 0e 9c			ld	c,-100 
0ef3 cd fd 0e			call	.Na1 
0ef6 0e f6			ld	c,-10 
0ef8 cd fd 0e			call	.Na1 
0efb 0e ff			ld	c,-1 
0efd 06 2f		.Na1:	ld	b,'0'-1 
0eff 04			.Na2:	inc	b 
0f00 81				add	a,c 
0f01 38 fc			jr	c,.Na2 
0f03 91				sub	c		;works as add 100/10/1 
0f04 f5				push af		;safer than ld c,a 
0f05 78				ld	a,b		;char is in b 
0f06			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0f06 f1				pop af		;safer than ld a,c 
0f07 c9				ret 
0f08			 
0f08			; Decimal Signed Version 
0f08			 
0f08			; DispA 
0f08			; -------------------------------------------------------------- 
0f08			; Converts a signed integer value to a zero-terminated ASCII 
0f08			; string representative of that value (using radix 10). 
0f08			; -------------------------------------------------------------- 
0f08			; INPUTS: 
0f08			;     HL     Value to convert (two's complement integer). 
0f08			;     DE     Base address of string destination. (pointer). 
0f08			; -------------------------------------------------------------- 
0f08			; OUTPUTS: 
0f08			;     None 
0f08			; -------------------------------------------------------------- 
0f08			; REGISTERS/MEMORY DESTROYED 
0f08			; AF HL 
0f08			; -------------------------------------------------------------- 
0f08			 
0f08			;DispHLToASCII: 
0f08			;   push    de 
0f08			;   push    bc 
0f08			; 
0f08			;; Detect sign of HL. 
0f08			;    bit    7, h 
0f08			;    jr     z, ._DoConvert 
0f08			; 
0f08			;; HL is negative. Output '-' to string and negate HL. 
0f08			;    ld     a, '-' 
0f08			;    ld     (de), a 
0f08			;    inc    de 
0f08			; 
0f08			;; Negate HL (using two's complement) 
0f08			;    xor    a 
0f08			;    sub    l 
0f08			;    ld     l, a 
0f08			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0f08			;    sbc    a, h 
0f08			;    ld     h, a 
0f08			; 
0f08			;; Convert HL to digit characters 
0f08			;._DoConvert: 
0f08			;    ld     b, 0     ; B will count character length of number 
0f08			;-   ld     a, 10 
0f08			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0f08			;    push   af 
0f08			;    inc    b 
0f08			;    ld     a, h 
0f08			;    or     l 
0f08			;    jr     nz, - 
0f08			; 
0f08			;; Retrieve digits from stack 
0f08			;-   pop    af 
0f08			;    or     $30 
0f08			;    ld     (de), a 
0f08			;    inc    de 
0f08			;    djnz   - 
0f08			; 
0f08			;; Terminate string with NULL 
0f08			;    xor    a 
0f08			;    ld     (de), a 
0f08			; 
0f08			;    pop    bc 
0f08			;    pop    de 
0f08			;    ret 
0f08			 
0f08			;Comments 
0f08			; 
0f08			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0f08			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0f08			;    Note that the output string will not be fixed-width. 
0f08			; 
0f08			;Example Usage 
0f08			; 
0f08			;    ld    hl, -1004 
0f08			;    ld    de, OP1 
0f08			;    call  DispA 
0f08			;    ld    hl, OP1 
0f08			;    syscall  PutS 
0f08			 
0f08			 
0f08			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0f08			 
0f08			 
0f08			;Converts an ASCII string to an unsigned 16-bit integer 
0f08			;Quits when it reaches a non-decimal digit 
0f08			 
0f08			string_to_uint16: 
0f08			atoui_16: 
0f08			;Input: 
0f08			;     DE points to the string 
0f08			;Outputs: 
0f08			;     HL is the result 
0f08			;     A is the 8-bit value of the number 
0f08			;     DE points to the byte after the number 
0f08			;Destroys: 
0f08			;     BC 
0f08			;       if the string is non-empty, BC is HL/10 
0f08			;Size:  24 bytes 
0f08			;Speed: 42+d(104+{0,9}) 
0f08			;       d is the number of digits in the number 
0f08			;       max is 640 cycles for a 5 digit number 
0f08			;Assuming no leading zeros: 
0f08			;1 digit:  146cc 
0f08			;2 digit:  250cc 
0f08			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0f08			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0f08			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0f08			;avg: 544.81158447265625cc (544+13297/16384) 
0f08			;=============================================================== 
0f08 21 00 00		  ld hl,0 
0f0b			.u16a: 
0f0b 1a			  ld a,(de) 
0f0c d6 30		  sub 30h 
0f0e fe 0a		  cp 10 
0f10 d0			  ret nc 
0f11 13			  inc de 
0f12 44			  ld b,h 
0f13 4d			  ld c,l 
0f14 29			  add hl,hl 
0f15 29			  add hl,hl 
0f16 09			  add hl,bc 
0f17 29			  add hl,hl 
0f18 85			  add a,l 
0f19 6f			  ld l,a 
0f1a 30 ef		  jr nc,.u16a 
0f1c 24			  inc h 
0f1d c3 0b 0f		  jp .u16a 
0f20			 
0f20			 
0f20			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0f20			 
0f20			;written by Zeda 
0f20			;Converts a 16-bit unsigned integer to an ASCII string. 
0f20			 
0f20			uitoa_16: 
0f20			;Input: 
0f20			;   DE is the number to convert 
0f20			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0f20			;Output: 
0f20			;   HL points to the null-terminated ASCII string 
0f20			;      NOTE: This isn't necessarily the same as the input HL. 
0f20 d5			  push de 
0f21 c5			  push bc 
0f22 f5			  push af 
0f23 eb			  ex de,hl 
0f24			 
0f24 01 f0 d8		  ld bc,-10000 
0f27 3e 2f		  ld a,'0'-1 
0f29 3c			  inc a 
0f2a 09			  add hl,bc  
0f2b 38 fc		   jr c,$-2 
0f2d 12			  ld (de),a 
0f2e 13			  inc de 
0f2f			 
0f2f 01 e8 03		  ld bc,1000 
0f32 3e 3a		  ld a,'9'+1 
0f34 3d			  dec a  
0f35 09			  add hl,bc  
0f36 30 fc		   jr nc,$-2 
0f38 12			  ld (de),a 
0f39 13			  inc de 
0f3a			 
0f3a 01 9c ff		  ld bc,-100 
0f3d 3e 2f		  ld a,'0'-1 
0f3f 3c			  inc a  
0f40 09			  add hl,bc  
0f41 38 fc		   jr c,$-2 
0f43 12			  ld (de),a 
0f44 13			  inc de 
0f45			 
0f45 7d			  ld a,l 
0f46 26 3a		  ld h,'9'+1 
0f48 25			  dec h  
0f49 c6 0a		  add a,10  
0f4b 30 fb		   jr nc,$-3 
0f4d c6 30		  add a,'0' 
0f4f eb			  ex de,hl 
0f50 72			  ld (hl),d 
0f51 23			  inc hl 
0f52 77			  ld (hl),a 
0f53 23			  inc hl 
0f54 36 00		  ld (hl),0 
0f56			 
0f56			;Now strip the leading zeros 
0f56 0e fa		  ld c,-6 
0f58 09			  add hl,bc 
0f59 3e 30		  ld a,'0' 
0f5b 23			  inc hl  
0f5c be			  cp (hl)  
0f5d 28 fc		  jr z,$-2 
0f5f			 
0f5f			;Make sure that the string is non-empty! 
0f5f 7e			  ld a,(hl) 
0f60 b7			  or a 
0f61 20 01		  jr nz,.atoub 
0f63 2b			  dec hl 
0f64			.atoub: 
0f64			 
0f64 f1			  pop af 
0f65 c1			  pop bc 
0f66 d1			  pop de 
0f67 c9			  ret 
0f68			 
0f68			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
0f68			 
0f68			toUpper: 
0f68			;A is the char. 
0f68			;If A is a lowercase letter, this sets it to the matching uppercase 
0f68			;18cc or 30cc or 41cc 
0f68			;avg: 26.75cc 
0f68 fe 61		  cp 'a' 
0f6a d8			  ret c 
0f6b fe 7b		  cp 'z'+1 
0f6d d0			  ret nc 
0f6e d6 20		  sub 'a'-'A' 
0f70 c9			  ret 
0f71			 
0f71			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
0f71			 
0f71			; String Length 
0f71			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
0f71			 
0f71			; Get the length of the null-terminated string starting at $8000 hl 
0f71			;    LD     HL, $8000 
0f71			 
0f71			strlenz: 
0f71			 
0f71 af			    XOR    A               ; Zero is the value we are looking for. 
0f72 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
0f73 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
0f74			                           ; 65, 536 bytes (the entire addressable memory space). 
0f74 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0f76			 
0f76			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0f76 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
0f77 6f			    LD     L, A             ; number of bytes 
0f78 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0f7a 2b			    DEC    HL              ; Compensate for null. 
0f7b c9				ret 
0f7c			 
0f7c			; Get the length of the A terminated string starting at $8000 hl 
0f7c			;    LD     HL, $8000 
0f7c			 
0f7c			strlent: 
0f7c			 
0f7c			                  ; A is the value we are looking for. 
0f7c 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
0f7e 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
0f80			                           ; 65, 536 bytes (the entire addressable memory space). 
0f80 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
0f82			 
0f82			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
0f82 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
0f84 2e 00		    LD     L, 0             ; number of bytes 
0f86 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
0f88 2b			    DEC    HL              ; Compensate for null. 
0f89 c9				ret 
0f8a			 
0f8a			 
0f8a			;Comparing Strings 
0f8a			 
0f8a			;IN    HL     Address of string1. 
0f8a			;      DE     Address of string2. 
0f8a			 
0f8a			; doc given but wrong??? 
0f8a			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
0f8a			;      carry  Set if string1 > string2, reset if string1 <= string2. 
0f8a			; tested 
0f8a			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
0f8a			 
0f8a			strcmp_old: 
0f8a e5			    PUSH   HL 
0f8b d5			    PUSH   DE 
0f8c			 
0f8c 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
0f8d be			    CP     (HL)            ; (want to minimize work). 
0f8e 38 01		    JR     C, Str1IsBigger 
0f90 7e			    LD     A, (HL) 
0f91			 
0f91			Str1IsBigger: 
0f91 4f			    LD     C, A             ; Put length in BC 
0f92 06 00		    LD     B, 0 
0f94 13			    INC    DE              ; Increment pointers to meat of string. 
0f95 23			    INC    HL 
0f96			 
0f96			CmpLoop: 
0f96 1a			    LD     A, (DE)          ; Compare bytes. 
0f97 ed a1		    CPI 
0f99 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
0f9b 13			    INC    DE              ; Update pointer. 
0f9c ea 96 0f		    JP     PE, CmpLoop 
0f9f			 
0f9f d1			    POP    DE 
0fa0 e1			    POP    HL 
0fa1 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
0fa2 be			    CP     (HL) 
0fa3 c9			    RET 
0fa4			 
0fa4			NoMatch: 
0fa4 2b			    DEC    HL 
0fa5 be			    CP     (HL)            ; Compare again to affect carry. 
0fa6 d1			    POP    DE 
0fa7 e1			    POP    HL 
0fa8 c9			    RET 
0fa9			 
0fa9			;; test strmp 
0fa9			; 
0fa9			;ld de, .str1 
0fa9			;ld hl, .str2 
0fa9			;call strcmp 
0fa9			;jr z, .z1 
0fa9			;;this 
0fa9			;	if DEBUG_FORTH_WORDS 
0fa9			;		DMARK "NZ1" 
0fa9			;		CALLMONITOR 
0fa9			;	endif 
0fa9			;.z1: 
0fa9			; 
0fa9			;	if DEBUG_FORTH_WORDS 
0fa9			;		DMARK "ZZ1" 
0fa9			;		CALLMONITOR 
0fa9			;	endif 
0fa9			; 
0fa9			;ld de, .str1 
0fa9			;ld hl, .str1 
0fa9			;call strcmp 
0fa9			;jr z, .z2 
0fa9			;;this 
0fa9			;	if DEBUG_FORTH_WORDS 
0fa9			;		DMARK "NZ2" 
0fa9			;		CALLMONITOR 
0fa9			;	endif 
0fa9			;.z2: 
0fa9			; 
0fa9			;	if DEBUG_FORTH_WORDS 
0fa9			;		DMARK "ZZ2" 
0fa9			;		CALLMONITOR 
0fa9			;	endif 
0fa9			; 
0fa9			;ld de, .str1 
0fa9			;ld hl, .str2 
0fa9			;call strcmp 
0fa9			;jr c, .c1 
0fa9			; 
0fa9			;	if DEBUG_FORTH_WORDS 
0fa9			;		DMARK "Nc1" 
0fa9			;		CALLMONITOR 
0fa9			;	endif 
0fa9			;.c1: 
0fa9			;;this 
0fa9			;	if DEBUG_FORTH_WORDS 
0fa9			;		DMARK "cc1" 
0fa9			;		CALLMONITOR 
0fa9			;	endif 
0fa9			; 
0fa9			;ld de, .str1 
0fa9			;ld hl, .str1 
0fa9			;call strcmp 
0fa9			;jr c, .c2 
0fa9			;;this 
0fa9			;	if DEBUG_FORTH_WORDS 
0fa9			;		DMARK "Nc2" 
0fa9			;		CALLMONITOR 
0fa9			;	endif 
0fa9			;.c2: 
0fa9			; 
0fa9			;	if DEBUG_FORTH_WORDS 
0fa9			;		DMARK "cc2" 
0fa9			;		CALLMONITOR 
0fa9			;	endif 
0fa9			;	NEXTW 
0fa9			;.str1:   db "string1",0 
0fa9			;.str2:   db "string2",0 
0fa9			 
0fa9			; only care about direct match or not 
0fa9			; hl and de strings 
0fa9			; zero set if the same 
0fa9			 
0fa9			strcmp: 
0fa9 1a				ld a, (de) 
0faa be				cp (hl) 
0fab 28 02			jr z, .ssame 
0fad b7				or a 
0fae c9				ret 
0faf			 
0faf			.ssame:  
0faf fe 00			cp 0 
0fb1 c8				ret z 
0fb2			 
0fb2 23				inc hl 
0fb3 13				inc de 
0fb4 18 f3			jr strcmp 
0fb6				 
0fb6				 
0fb6			 
0fb6			 
0fb6			 
0fb6			 
0fb6			; eof 
0fb6			 
0fb6			 
0fb6			 
0fb6			 
0fb6			 
0fb6			 
# End of file firmware_strings.asm
0fb6			include "firmware_memory.asm"   ; malloc and free  
0fb6			 
0fb6			if DEBUG_FORTH_MALLOC_HIGH 
0fb6			.mallocsize: db "Wants malloc >256",0 
0fb6			.mallocasize: db "MALLOC gives >256",0 
0fb6			.malloczero: db "MALLOC gives zero",0 
0fb6			 
0fb6			malloc_guard_zerolen: 
0fb6				push hl 
0fb6				push de 
0fb6				push af 
0fb6			 
0fb6				ld de, 0 
0fb6			        call cmp16 
0fb6				jr nz, .lowalloz 
0fb6			 
0fb6				push hl 
0fb6				push de 
0fb6					ld hl, display_fb0 
0fb6					ld (display_fb_active), hl 
0fb6				call clear_display 
0fb6				ld a, 0 
0fb6				ld de, .malloczero 
0fb6				call str_at_display 
0fb6				call update_display 
0fb6				call delay1s 
0fb6				call delay1s 
0fb6				ld a, 0 
0fb6				ld (os_view_disable), a 
0fb6			 
0fb6				pop de 
0fb6				pop hl 
0fb6			 
0fb6				 
0fb6			 
0fb6				CALLMONITOR 
0fb6			.lowalloz: 
0fb6			 
0fb6			 
0fb6				pop af 
0fb6				pop de 
0fb6				pop hl 
0fb6			ret 
0fb6			 
0fb6			malloc_guard_entry: 
0fb6				push hl 
0fb6				push de 
0fb6				push af 
0fb6			 
0fb6			 	or a      ;clear carry flag 
0fb6				push hl 
0fb6				ld de, 255 
0fb6				sbc hl, de 
0fb6				jr c, .lowalloc 
0fb6			 
0fb6				push de 
0fb6					ld hl, display_fb0 
0fb6					ld (display_fb_active), hl 
0fb6				call clear_display 
0fb6				ld a, 0 
0fb6				ld de, .mallocsize 
0fb6				call str_at_display 
0fb6				call update_display 
0fb6				call delay1s 
0fb6				call delay1s 
0fb6				ld a, 0 
0fb6				ld (os_view_disable), a 
0fb6			 
0fb6				pop de 
0fb6				pop hl 
0fb6			 
0fb6				 
0fb6			 
0fb6				CALLMONITOR 
0fb6				jr .lowdone 
0fb6			.lowalloc: 
0fb6			 
0fb6			 
0fb6				pop hl 
0fb6			.lowdone:	pop af 
0fb6				pop de 
0fb6				pop hl 
0fb6			ret 
0fb6			 
0fb6			malloc_guard_exit: 
0fb6				push hl 
0fb6				push de 
0fb6				push af 
0fb6			 
0fb6			 	or a      ;clear carry flag 
0fb6				push hl 
0fb6				ld de, 255 
0fb6				sbc hl, de 
0fb6				jr c, .lowallocx 
0fb6			 
0fb6				push de 
0fb6					ld hl, display_fb0 
0fb6					ld (display_fb_active), hl 
0fb6				call clear_display 
0fb6				ld a, 0 
0fb6				ld de, .mallocasize 
0fb6				call str_at_display 
0fb6				call update_display 
0fb6				call delay1s 
0fb6				call delay1s 
0fb6				ld a, 0 
0fb6				ld (os_view_disable), a 
0fb6				pop de 
0fb6				pop hl 
0fb6			 
0fb6				CALLMONITOR 
0fb6				jr .lowdonex 
0fb6			.lowallocx: 
0fb6			 
0fb6				pop hl 
0fb6			.lowdonex:	pop af 
0fb6				pop de 
0fb6				pop hl 
0fb6			ret 
0fb6			endif 
0fb6			 
0fb6			if MALLOC_2 
0fb6			; Z80 Malloc and Free Functions 
0fb6			 
0fb6			; Malloc Function: 
0fb6			; Input: 
0fb6			;   HL: Size of block to allocate 
0fb6			; Output: 
0fb6			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
0fb6			 
0fb6			malloc: 
0fb6				 
0fb6			if DEBUG_FORTH_MALLOC_HIGH 
0fb6			call malloc_guard_entry 
0fb6			endif 
0fb6			 
0fb6			 
0fb6			 
0fb6			 
0fb6					if DEBUG_FORTH_MALLOC 
0fb6						DMARK "mal" 
0fb6						CALLMONITOR 
0fb6					endif 
0fb6			    push af            ; Save AF register 
0fb6			    ld a, l            ; Load low byte of size into A 
0fb6			    or h               ; Check if size is zero 
0fb6			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
0fb6			 
0fb6			    ; Allocate memory 
0fb6			    ld hl, (heap_start) ; Load start of heap into HL 
0fb6					if DEBUG_FORTH_MALLOC 
0fb6						DMARK "ma1" 
0fb6						CALLMONITOR 
0fb6					endif 
0fb6			    call malloc_internal ; Call internal malloc function 
0fb6			    pop af             ; Restore AF register 
0fb6			if DEBUG_FORTH_MALLOC_HIGH 
0fb6			call malloc_guard_exit 
0fb6			call malloc_guard_zerolen 
0fb6			endif 
0fb6			    ret                ; Return 
0fb6			 
0fb6			; Free Function: 
0fb6			; Input: 
0fb6			;   HL: Pointer to memory block to free 
0fb6			; Output: 
0fb6			;   None 
0fb6			 
0fb6			free: 
0fb6			    push af            ; Save AF register 
0fb6			    ld a, l            ; Load low byte of pointer into A 
0fb6			    or h               ; Check if pointer is NULL 
0fb6			    jp z, free_exit    ; If pointer is NULL, exit 
0fb6			 
0fb6			    ; Free memory 
0fb6			    ld hl, (heap_start) ; Load start of heap into HL 
0fb6			    call free_internal  ; Call internal free function 
0fb6			    pop af             ; Restore AF register 
0fb6			    ret                ; Return 
0fb6			 
0fb6			; Internal Malloc Function: 
0fb6			; Input: 
0fb6			;   HL: Size of block to allocate 
0fb6			; Output: 
0fb6			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
0fb6			 
0fb6			malloc_internal: 
0fb6			    ld bc, 2           ; Number of bytes to allocate for management overhead 
0fb6			    add hl, bc         ; Add management overhead to requested size 
0fb6			    ex de, hl          ; Save total size in DE, and keep it in HL 
0fb6					if DEBUG_FORTH_MALLOC 
0fb6						DMARK "ma2" 
0fb6						CALLMONITOR 
0fb6					endif 
0fb6			 
0fb6			    ; Search for free memory block 
0fb6			    ld de, (heap_end)  ; Load end of heap into DE 
0fb6			    ld bc, 0           ; Initialize counter 
0fb6			 
0fb6					if DEBUG_FORTH_MALLOC 
0fb6						DMARK "ma2" 
0fb6						CALLMONITOR 
0fb6					endif 
0fb6			malloc_search_loop: 
0fb6			    ; Check if current block is free 
0fb6			    ld a, (hl)         ; Load current block's status (free or used) 
0fb6			    cp 0               ; Compare with zero (free) 
0fb6			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
0fb6			 
0fb6			    ; Check if current block is large enough 
0fb6			    ld a, (hl+1)       ; Load high byte of block size 
0fb6			    cp l               ; Compare with low byte of requested size 
0fb6			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
0fb6			 
0fb6			    ld a, (hl+2)       ; Load low byte of block size 
0fb6			    cp h               ; Compare with high byte of requested size 
0fb6			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
0fb6			 
0fb6			    ; Mark block as used 
0fb6			    ld (hl), 0xFF      ; Set status byte to indicate used block 
0fb6			 
0fb6			    ; Calculate remaining space in block 
0fb6			    ld bc, 0           ; Clear BC 
0fb6			    add hl, bc         ; Increment HL to point to start of data block 
0fb6			    add hl, de         ; HL = HL + DE (total size) 
0fb6			    ld bc, 1           ; Number of bytes to allocate for management overhead 
0fb6			    add hl, bc         ; Add management overhead to start of data block 
0fb6			 
0fb6			    ; Save pointer to allocated block in HL 
0fb6			if DEBUG_FORTH_MALLOC_HIGH 
0fb6						DMARK "ma5" 
0fb6			call malloc_guard_exit 
0fb6			call malloc_guard_zerolen 
0fb6			endif 
0fb6			    ret 
0fb6			 
0fb6			malloc_skip_block_check: 
0fb6			    ; Move to the next block 
0fb6			    ld bc, 3           ; Size of management overhead 
0fb6			    add hl, bc         ; Move to the next block 
0fb6			    inc de             ; Increment counter 
0fb6			 
0fb6			    ; Check if we have reached the end of heap 
0fb6			    ld a, e            ; Load low byte of heap end address 
0fb6			    cp (hl)            ; Compare with low byte of current address 
0fb6			    jr nz, malloc_search_loop  ; If not equal, continue searching 
0fb6			    ld a, d            ; Load high byte of heap end address 
0fb6			    cp 0               ; Check if it's zero (end of memory) 
0fb6			    jr nz, malloc_search_loop  ; If not zero, continue searching 
0fb6			 
0fb6			    ; If we reached here, allocation failed 
0fb6			    xor a              ; Set result to NULL 
0fb6			if DEBUG_FORTH_MALLOC_HIGH 
0fb6						DMARK "ma6" 
0fb6			call malloc_guard_exit 
0fb6			call malloc_guard_zerolen 
0fb6			endif 
0fb6			    ret 
0fb6			malloc_exit: 
0fb6			if DEBUG_FORTH_MALLOC_HIGH 
0fb6						DMARK "ma7" 
0fb6			call malloc_guard_exit 
0fb6			call malloc_guard_zerolen 
0fb6			endif 
0fb6			    ret 
0fb6			 
0fb6			; Internal Free Function: 
0fb6			; Input: 
0fb6			;   HL: Pointer to memory block to free 
0fb6			; Output: 
0fb6			;   None 
0fb6			 
0fb6			free_internal: 
0fb6			    ld de, (heap_start) ; Load start of heap into DE 
0fb6			    ld bc, 0            ; Initialize counter 
0fb6			 
0fb6			free_search_loop: 
0fb6			    ; Check if current block contains the pointer 
0fb6			    ld a, l             ; Load low byte of pointer 
0fb6			    cp (hl+1)           ; Compare with high byte of current block's address 
0fb6			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
0fb6			    ld a, h             ; Load high byte of pointer 
0fb6			    cp (hl+2)           ; Compare with low byte of current block's address 
0fb6			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
0fb6			 
0fb6			    ; Mark block as free 
0fb6			    ld (hl), 0          ; Set status byte to indicate free block 
0fb6			    ret                 ; Return 
0fb6			 
0fb6			free_skip_block_check: 
0fb6			    ; Move to the next block 
0fb6			    ld bc, 3            ; Size of management overhead 
0fb6			    add hl, bc          ; Move to the next block 
0fb6			    inc de              ; Increment counter 
0fb6			 
0fb6			    ; Check if we have reached the end of heap 
0fb6			    ld a, e             ; Load low byte of heap end address 
0fb6			    cp (hl)             ; Compare with low byte of current address 
0fb6			    jr nz, free_search_loop  ; If not equal, continue searching 
0fb6			    ld a, d             ; Load high byte of heap end address 
0fb6			    cp 0                ; Check if it's zero (end of memory) 
0fb6			    jr nz, free_search_loop  ; If not zero, continue searching 
0fb6			 
0fb6			    ; If we reached here, pointer is not found in heap 
0fb6			    ret 
0fb6			 
0fb6			free_exit: 
0fb6			    ret                 ; Return 
0fb6			 
0fb6			; Define heap start and end addresses 
0fb6			;heap_start:    .dw 0xC000   ; Start of heap 
0fb6			;heap_end:      .dw 0xE000   ; End of heap 
0fb6			 
0fb6			endif 
0fb6			 
0fb6			 
0fb6			if MALLOC_1 
0fb6			 
0fb6			 
0fb6			 
0fb6			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
0fb6			 
0fb6			;moved to firmware.asm 
0fb6			;heap_start        .equ  0x9000      ; Starting address of heap 
0fb6			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
0fb6			 
0fb6			;      .org 0 
0fb6			;      jp    main 
0fb6			 
0fb6			 
0fb6			;      .org  0x100 
0fb6			;main: 
0fb6			;      ld    HL, 0x8100 
0fb6			;      ld    SP, HL 
0fb6			; 
0fb6			;      call  heap_init 
0fb6			; 
0fb6			;      ; Make some allocations 
0fb6			;      ld    HL, 12 
0fb6			;      call  malloc            ; Allocates 0x9004 
0fb6			; 
0fb6			;      ld    HL, 12 
0fb6			;      call  malloc            ; Allocates 0x9014 
0fb6			; 
0fb6			;      ld    HL, 12 
0fb6			;      call  malloc            ; Allocates 0x9024 
0fb6			; 
0fb6			;      ; Free some allocations 
0fb6			;      ld    HL, 0x9014 
0fb6			;      call  free 
0fb6			; 
0fb6			;      ld    HL, 0x9004 
0fb6			;      call  free 
0fb6			; 
0fb6			;      ld    HL, 0x9024 
0fb6			;      call  free 
0fb6			; 
0fb6			; 
0fb6			;      halt 
0fb6			 
0fb6			 
0fb6			;------------------------------------------------------------------------------ 
0fb6			;     heap_init                                                               : 
0fb6			;                                                                             : 
0fb6			; Description                                                                 : 
0fb6			;     Initialise the heap and make it ready for malloc and free operations.   : 
0fb6			;                                                                             : 
0fb6			;     The heap is maintained as a linked list, starting with an initial       : 
0fb6			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
0fb6			;     the first free block in the heap. Each block then points to the next    : 
0fb6			;     free block within the heap, and the free list ends at the first block   : 
0fb6			;     with a null pointer to the next free block.                             : 
0fb6			;                                                                             : 
0fb6			; Parameters                                                                  : 
0fb6			;     Inputs are compile-time only. Two defines which specify the starting    : 
0fb6			;     address of the heap and its size are required, along with a memory      : 
0fb6			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
0fb6			;     principally stores a pointer to the first free block in the heap.       : 
0fb6			;                                                                             : 
0fb6			; Returns                                                                     : 
0fb6			;     Nothing                                                                 : 
0fb6			;------------------------------------------------------------------------------ 
0fb6			heap_init: 
0fb6 e5			      push  HL 
0fb7			 
0fb7			      ; Initialise free list struct 
0fb7 21 0e 80		      ld    HL, heap_start 
0fba 22 0a 80		      ld    (free_list), HL 
0fbd 21 00 00		      ld    HL, 0 
0fc0 22 0c 80		      ld    (free_list+2), HL 
0fc3			 
0fc3			      ; Insert first free block at bottom of heap, consumes entire heap 
0fc3 21 0a 80		      ld    HL, heap_start+heap_size-4 
0fc6 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
0fc9 21 fc ff		      ld    HL, heap_size-4 
0fcc 22 10 80		      ld    (heap_start+2), HL      ; Block size 
0fcf			 
0fcf			      ; Insert end of free list block at top of heap - two null words will 
0fcf			      ; terminate the free list 
0fcf 21 00 00		      ld    HL, 0 
0fd2 22 0c 80		      ld    (heap_start+heap_size-2), HL 
0fd5 22 0a 80		      ld    (heap_start+heap_size-4), HL 
0fd8			 
0fd8 e1			      pop   HL 
0fd9			 
0fd9 c9			      ret 
0fda			 
0fda			 
0fda			;------------------------------------------------------------------------------ 
0fda			;     malloc                                                                  : 
0fda			;                                                                             : 
0fda			; Description                                                                 : 
0fda			;     Allocates the wanted space from the heap and returns the address of the : 
0fda			;     first useable byte of the allocation.                                   : 
0fda			;                                                                             : 
0fda			;     Allocations can happen in one of two ways:                              : 
0fda			;                                                                             : 
0fda			;     1. A free block may be found which is the exact size wanted. In this    : 
0fda			;        case the block is removed from the free list and retuedn to the      : 
0fda			;        caller.                                                              : 
0fda			;     2. A free block may be found which is larger than the size wanted. In   : 
0fda			;        this case, the larger block is split into two. The first portion of  : 
0fda			;        this block will become the requested space by the malloc call and    : 
0fda			;        is returned to the caller. The second portion becomes a new free     : 
0fda			;        block, and the free list is adjusted to maintain continuity via this : 
0fda			;        newly created block.                                                 : 
0fda			;                                                                             : 
0fda			;     malloc does not set any initial value in the allocated space, the       : 
0fda			;     caller is required to do this as required.                              : 
0fda			;                                                                             : 
0fda			;     This implementation of malloc uses the stack exclusively, and is        : 
0fda			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
0fda			;     advisable to disable interrupts before calling malloc, and recommended  : 
0fda			;     to avoid the use of malloc inside ISRs in general.                      : 
0fda			;                                                                             : 
0fda			;     NOTE: heap_init must be called before malloc and free can be used.      : 
0fda			;                                                                             : 
0fda			; Parameters                                                                  : 
0fda			;     HL  Number of bytes wanted                                              : 
0fda			;                                                                             : 
0fda			; Returns                                                                     : 
0fda			;     HL  Address of the first useable byte of the allocation                 : 
0fda			;                                                                             : 
0fda			; Flags                                                                       : 
0fda			;     Z   Set if the allocation did not succeed, clear otherwise              : 
0fda			;                                                                             : 
0fda			; Stack frame                                                                 : 
0fda			;       |             |                                                       : 
0fda			;       +-------------+                                                       : 
0fda			;       |     BC      |                                                       : 
0fda			;       +-------------+                                                       : 
0fda			;       |     DE      |                                                       : 
0fda			;       +-------------+                                                       : 
0fda			;       |     IX      |                                                       : 
0fda			;       +-------------+                                                       : 
0fda			;       |  prev_free  |                                                       : 
0fda			;   +4  +-------------+                                                       : 
0fda			;       |  this_free  |                                                       : 
0fda			;   +2  +-------------+                                                       : 
0fda			;       |  next_free  |                                                       : 
0fda			;   +0  +-------------+                                                       : 
0fda			;       |             |                                                       : 
0fda			;                                                                             : 
0fda			;------------------------------------------------------------------------------ 
0fda			 
0fda			 
0fda			;malloc: 
0fda			; 
0fda			;	SAVESP ON 1 
0fda			; 
0fda			;	call malloc_code 
0fda			; 
0fda			;	CHECKSP ON 1 
0fda			;	ret 
0fda			 
0fda			 
0fda			malloc: 
0fda c5			      push  BC 
0fdb d5			      push  DE 
0fdc dd e5		      push  IX 
0fde			if DEBUG_FORTH_MALLOC_HIGH 
0fde			call malloc_guard_entry 
0fde			endif 
0fde			 
0fde					if DEBUG_FORTH_MALLOC 
0fde						DMARK "mal" 
0fde						CALLMONITOR 
0fde					endif 
0fde 7c			      ld    A, H                    ; Exit if no space requested 
0fdf b5			      or    L 
0fe0 ca 9f 10		      jp    Z, malloc_early_exit 
0fe3			 
0fe3			;inc hl 
0fe3			;inc hl 
0fe3			;inc hl 
0fe3			; 
0fe3			;inc hl 
0fe3			;inc hl 
0fe3			;inc hl 
0fe3			;inc hl 
0fe3			;inc hl 
0fe3			;inc hl 
0fe3			;inc hl 
0fe3			;inc hl 
0fe3			;inc hl 
0fe3			 
0fe3			 
0fe3			 
0fe3			 
0fe3					if DEBUG_FORTH_MALLOC 
0fe3						DMARK "maA" 
0fe3						CALLMONITOR 
0fe3					endif 
0fe3			      ; Set up stack frame 
0fe3 eb			      ex    DE, HL 
0fe4 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
0fe7 39			      add   HL, SP 
0fe8 f9			      ld    SP, HL 
0fe9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
0fed dd 39		      add   IX, SP 
0fef			 
0fef			      ; Setup initial state 
0fef 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
0ff2 19			      add   HL, DE 
0ff3			 
0ff3 44			      ld    B, H                    ; Move want to BC 
0ff4 4d			      ld    C, L 
0ff5			 
0ff5 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
0ff8 dd 75 04		      ld    (IX+4), L 
0ffb dd 74 05		      ld    (IX+5), H 
0ffe			 
0ffe 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
0fff 23			      inc   HL 
1000 56			      ld    D, (HL) 
1001 dd 73 02		      ld    (IX+2), E 
1004 dd 72 03		      ld    (IX+3), D 
1007 eb			      ex    DE, HL                  ; this_free ptr into HL 
1008			 
1008					if DEBUG_FORTH_MALLOC 
1008						DMARK "maB" 
1008						CALLMONITOR 
1008					endif 
1008			      ; Loop through free block list to find some space 
1008			malloc_find_space: 
1008 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1009 23			      inc   HL 
100a 56			      ld    D, (HL) 
100b			 
100b 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
100c b3			      or    E 
100d ca 99 10		      jp    Z, malloc_no_space 
1010			 
1010 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1013 dd 72 01		      ld    (IX+1), D 
1016			 
1016			      ; Does this block have enough space to make the allocation? 
1016 23			      inc   HL                      ; Load free block size into DE 
1017 5e			      ld    E, (HL) 
1018 23			      inc   HL 
1019 56			      ld    D, (HL) 
101a			 
101a eb			      ex    DE, HL                  ; Check size of block against want 
101b b7			      or    A                       ; Ensure carry flag clear 
101c ed 42		      sbc   HL, BC 
101e e5			      push  HL                      ; Store the result for later (new block size) 
101f			 
101f ca 6e 10		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1022 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1024			 
1024			      ; this_free block is not big enough, setup ptrs to test next free block 
1024 e1			      pop   HL                      ; Discard previous result 
1025			 
1025 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1028 dd 66 03		      ld    H, (IX+3) 
102b dd 75 04		      ld    (IX+4), L 
102e dd 74 05		      ld    (IX+5), H 
1031			 
1031 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1034 dd 66 01		      ld    H, (IX+1) 
1037 dd 75 02		      ld    (IX+2), L 
103a dd 74 03		      ld    (IX+3), H 
103d			 
103d					if DEBUG_FORTH_MALLOC 
103d						DMARK "MA>" 
103d						CALLMONITOR 
103d					endif 
103d 18 c9		      jr    malloc_find_space 
103f			 
103f			      ; split a bigger block into two - requested size and remaining size 
103f			malloc_alloc_split: 
103f					if DEBUG_FORTH_MALLOC 
103f						DMARK "MAs" 
103f						CALLMONITOR 
103f					endif 
103f eb			      ex    DE, HL                  ; Calculate address of new free block 
1040 2b			      dec   HL 
1041 2b			      dec   HL 
1042 2b			      dec   HL 
1043 09			      add   HL, BC 
1044			 
1044			      ; Create a new block and point it at next_free 
1044 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1047 dd 56 01		      ld    D, (IX+1) 
104a			 
104a 73			      ld    (HL), E                 ; Store next_free ptr into new block 
104b 23			      inc   HL 
104c 72			      ld    (HL), D 
104d			 
104d d1			      pop   DE                      ; Store size of new block into new block 
104e 23			      inc   HL 
104f 73			      ld    (HL), E 
1050 23			      inc   HL 
1051 72			      ld    (HL), D 
1052			 
1052			      ; Update this_free ptr to point to new block 
1052 2b			      dec   HL 
1053 2b			      dec   HL 
1054 2b			      dec   HL 
1055			 
1055 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1058 dd 56 03		      ld    D, (IX+3) 
105b			 
105b dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
105e dd 74 03		      ld    (IX+3), H 
1061			 
1061			      ; Modify this_free block to be allocation 
1061 eb			      ex    DE, HL 
1062 af			      xor   A                       ; Null the next block ptr of allocated block 
1063 77			      ld    (HL), A 
1064 23			      inc   HL 
1065 77			      ld    (HL), A 
1066			 
1066 23			      inc   HL                      ; Store want size into allocated block 
1067 71			      ld    (HL), C 
1068 23			      inc   HL 
1069 70			      ld    (HL), B 
106a 23			      inc   HL 
106b e5			      push  HL                      ; Address of allocation to return 
106c			 
106c 18 19		      jr    malloc_update_links 
106e			 
106e			malloc_alloc_fit: 
106e e1			      pop   HL                      ; Dont need new block size, want is exact fit 
106f			 
106f					if DEBUG_FORTH_MALLOC 
106f						DMARK "MAf" 
106f						CALLMONITOR 
106f					endif 
106f			      ; Modify this_free block to be allocation 
106f eb			      ex    DE, HL 
1070 2b			      dec   HL 
1071 2b			      dec   HL 
1072 2b			      dec   HL 
1073			 
1073 af			      xor   A                       ; Null the next block ptr of allocated block 
1074 77			      ld    (HL), A 
1075 23			      inc   HL 
1076 77			      ld    (HL), A 
1077			 
1077 23			      inc   HL                      ; Store address of allocation to return 
1078 23			      inc   HL 
1079 23			      inc   HL 
107a e5			      push  HL 
107b			 
107b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
107b dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
107e dd 66 01		      ld    H, (IX+1) 
1081			 
1081 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1084 dd 74 03		      ld    (IX+3), H 
1087			 
1087			 
1087			malloc_update_links: 
1087			      ; Update prev_free ptr to point to this_free 
1087 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
108a dd 66 05		      ld    H, (IX+5) 
108d			 
108d dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1090 dd 56 03		      ld    D, (IX+3) 
1093			 
1093 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1094 23			      inc   HL 
1095 72			      ld    (HL), D 
1096			 
1096					if DEBUG_FORTH_MALLOC 
1096						DMARK "Mul" 
1096						CALLMONITOR 
1096					endif 
1096			      ; Clear the Z flag to indicate successful allocation 
1096 7a			      ld    A, D 
1097 b3			      or    E 
1098			 
1098 d1			      pop   DE                      ; Address of allocation 
1099					if DEBUG_FORTH_MALLOC 
1099						DMARK "MAu" 
1099						CALLMONITOR 
1099					endif 
1099			 
1099			malloc_no_space: 
1099 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
109c 39			      add   HL, SP 
109d f9			      ld    SP, HL 
109e			 
109e eb			      ex    DE, HL                  ; Alloc addr into HL for return 
109f					if DEBUG_FORTH_MALLOC 
109f						DMARK "MAN" 
109f						CALLMONITOR 
109f					endif 
109f			 
109f			malloc_early_exit: 
109f					if DEBUG_FORTH_MALLOC 
109f						DMARK "MAx" 
109f						CALLMONITOR 
109f					endif 
109f dd e1		      pop   IX 
10a1 d1			      pop   DE 
10a2 c1			      pop   BC 
10a3			 
10a3			if DEBUG_FORTH_MALLOC_HIGH 
10a3			call malloc_guard_exit 
10a3			call malloc_guard_zerolen 
10a3			endif 
10a3 c9			      ret 
10a4			 
10a4			 
10a4			;------------------------------------------------------------------------------ 
10a4			;     free                                                                    : 
10a4			;                                                                             : 
10a4			; Description                                                                 : 
10a4			;     Return the space pointed to by HL to the heap. HL must be an address as : 
10a4			;     returned by malloc, otherwise the behaviour is undefined.               : 
10a4			;                                                                             : 
10a4			;     Where possible, directly adjacent free blocks will be merged together   : 
10a4			;     into larger blocks to help ensure that the heap does not become         : 
10a4			;     excessively fragmented.                                                 : 
10a4			;                                                                             : 
10a4			;     free does not clear or set any other value into the freed space, and    : 
10a4			;     therefore its contents may be visible through subsequent malloc's. The  : 
10a4			;     caller should clear the freed space as required.                        : 
10a4			;                                                                             : 
10a4			;     This implementation of free uses the stack exclusively, and is          : 
10a4			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
10a4			;     advisable to disable interrupts before calling free, and recommended    : 
10a4			;     to avoid the use of free inside ISRs in general.                        : 
10a4			;                                                                             : 
10a4			;     NOTE: heap_init must be called before malloc and free can be used.      : 
10a4			;                                                                             : 
10a4			; Parameters                                                                  : 
10a4			;     HL  Pointer to address of first byte of allocation to be freed          : 
10a4			;                                                                             : 
10a4			; Returns                                                                     : 
10a4			;     Nothing                                                                 : 
10a4			;                                                                             : 
10a4			; Stack frame                                                                 : 
10a4			;       |             |                                                       : 
10a4			;       +-------------+                                                       : 
10a4			;       |     BC      |                                                       : 
10a4			;       +-------------+                                                       : 
10a4			;       |     DE      |                                                       : 
10a4			;       +-------------+                                                       : 
10a4			;       |     IX      |                                                       : 
10a4			;       +-------------+                                                       : 
10a4			;       |  prev_free  |                                                       : 
10a4			;   +2  +-------------+                                                       : 
10a4			;       |  next_free  |                                                       : 
10a4			;   +0  +-------------+                                                       : 
10a4			;       |             |                                                       : 
10a4			;                                                                             : 
10a4			;------------------------------------------------------------------------------ 
10a4			free: 
10a4 c5			      push  BC 
10a5 d5			      push  DE 
10a6 dd e5		      push  IX 
10a8			 
10a8 7c			      ld    A, H                    ; Exit if ptr is null 
10a9 b5			      or    L 
10aa ca 6e 11		      jp    Z, free_early_exit 
10ad			 
10ad			      ; Set up stack frame 
10ad eb			      ex    DE, HL 
10ae 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
10b1 39			      add   HL, SP 
10b2 f9			      ld    SP, HL 
10b3 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
10b7 dd 39		      add   IX, SP 
10b9			 
10b9			      ; The address in HL points to the start of the useable allocated space, 
10b9			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
10b9			      ; address of the block itself. 
10b9 eb			      ex    DE, HL 
10ba 11 fc ff		      ld    DE, -4 
10bd 19			      add   HL, DE 
10be			 
10be			      ; An allocated block must have a null next block pointer in it 
10be 7e			      ld    A, (HL) 
10bf 23			      inc   HL 
10c0 b6			      or    (HL) 
10c1 c2 69 11		      jp    NZ, free_done 
10c4			 
10c4 2b			      dec   HL 
10c5			 
10c5 44			      ld    B, H                    ; Copy HL to BC 
10c6 4d			      ld    C, L 
10c7			 
10c7			      ; Loop through the free list to find the first block with an address 
10c7			      ; higher than the block being freed 
10c7 21 0a 80		      ld    HL, free_list 
10ca			 
10ca			free_find_higher_block: 
10ca 5e			      ld    E, (HL)                 ; Load next ptr from free block 
10cb 23			      inc   HL 
10cc 56			      ld    D, (HL) 
10cd 2b			      dec   HL 
10ce			 
10ce dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
10d1 dd 72 01		      ld    (IX+1), D 
10d4 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
10d7 dd 74 03		      ld    (IX+3), H 
10da			 
10da 78			      ld    A, B                    ; Check if DE is greater than BC 
10db ba			      cp    D                       ; Compare MSB first 
10dc 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
10de 30 04		      jr    NC, free_find_higher_block_skip 
10e0 79			      ld    A, C 
10e1 bb			      cp    E                       ; Then compare LSB 
10e2 38 08		      jr    C, free_found_higher_block 
10e4			 
10e4			free_find_higher_block_skip: 
10e4 7a			      ld    A, D                    ; Reached the end of the free list? 
10e5 b3			      or    E 
10e6 ca 69 11		      jp    Z, free_done 
10e9			 
10e9 eb			      ex    DE, HL 
10ea			 
10ea 18 de		      jr    free_find_higher_block 
10ec			 
10ec			free_found_higher_block: 
10ec			      ; Insert freed block between prev and next free blocks 
10ec 71			      ld    (HL), C                 ; Point prev free block to freed block 
10ed 23			      inc   HL 
10ee 70			      ld    (HL), B 
10ef			 
10ef 60			      ld    H, B                    ; Point freed block at next free block 
10f0 69			      ld    L, C 
10f1 73			      ld    (HL), E 
10f2 23			      inc   HL 
10f3 72			      ld    (HL), D 
10f4			 
10f4			      ; Check if the freed block is adjacent to the next free block 
10f4 23			      inc   HL                      ; Load size of freed block into HL 
10f5 5e			      ld    E, (HL) 
10f6 23			      inc   HL 
10f7 56			      ld    D, (HL) 
10f8 eb			      ex    DE, HL 
10f9			 
10f9 09			      add   HL, BC                  ; Add addr of freed block and its size 
10fa			 
10fa dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
10fd dd 56 01		      ld    D, (IX+1) 
1100			 
1100 b7			      or    A                       ; Clear the carry flag 
1101 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1103 20 22		      jr    NZ, free_check_adjacent_to_prev 
1105			 
1105			      ; Freed block is adjacent to next, merge into one bigger block 
1105 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1106 5e			      ld    E, (HL) 
1107 23			      inc   HL 
1108 56			      ld    D, (HL) 
1109 e5			      push  HL                      ; Save ptr to next block for later 
110a			 
110a 60			      ld    H, B                    ; Store ptr from next block into freed block 
110b 69			      ld    L, C 
110c 73			      ld    (HL), E 
110d 23			      inc   HL 
110e 72			      ld    (HL), D 
110f			 
110f e1			      pop   HL                      ; Restore ptr to next block 
1110 23			      inc   HL                      ; Load size of next block into DE 
1111 5e			      ld    E, (HL) 
1112 23			      inc   HL 
1113 56			      ld    D, (HL) 
1114 d5			      push  DE                      ; Save next block size for later 
1115			 
1115 60			      ld    H, B                    ; Load size of freed block into HL 
1116 69			      ld    L, C 
1117 23			      inc   HL 
1118 23			      inc   HL 
1119 5e			      ld    E, (HL) 
111a 23			      inc   HL 
111b 56			      ld    D, (HL) 
111c eb			      ex    DE, HL 
111d			 
111d d1			      pop   DE                      ; Restore size of next block 
111e 19			      add   HL, DE                  ; Add sizes of both blocks 
111f eb			      ex    DE, HL 
1120			 
1120 60			      ld    H, B                    ; Store new bigger size into freed block 
1121 69			      ld    L, C 
1122 23			      inc   HL 
1123 23			      inc   HL 
1124 73			      ld    (HL), E 
1125 23			      inc   HL 
1126 72			      ld    (HL), D 
1127			 
1127			free_check_adjacent_to_prev: 
1127			      ; Check if the freed block is adjacent to the prev free block 
1127 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
112a dd 66 03		      ld    H, (IX+3) 
112d			 
112d 23			      inc   HL                      ; Size of prev free block into DE 
112e 23			      inc   HL 
112f 5e			      ld    E, (HL) 
1130 23			      inc   HL 
1131 56			      ld    D, (HL) 
1132 2b			      dec   HL 
1133 2b			      dec   HL 
1134 2b			      dec   HL 
1135			 
1135 19			      add   HL, DE                  ; Add prev block addr and size 
1136			 
1136 b7			      or    A                       ; Clear the carry flag 
1137 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1139 20 2e		      jr    NZ, free_done 
113b			 
113b			      ; Freed block is adjacent to prev, merge into one bigger block 
113b 60			      ld    H, B                    ; Load next ptr from freed block into DE 
113c 69			      ld    L, C 
113d 5e			      ld    E, (HL) 
113e 23			      inc   HL 
113f 56			      ld    D, (HL) 
1140 e5			      push  HL                      ; Save freed block ptr for later 
1141			 
1141 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1144 dd 66 03		      ld    H, (IX+3) 
1147 73			      ld    (HL), E 
1148 23			      inc   HL 
1149 72			      ld    (HL), D 
114a			 
114a e1			      pop   HL                      ; Restore freed block ptr 
114b 23			      inc   HL                      ; Load size of freed block into DE 
114c 5e			      ld    E, (HL) 
114d 23			      inc   HL 
114e 56			      ld    D, (HL) 
114f d5			      push  DE                      ; Save freed block size for later 
1150			 
1150 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1153 dd 66 03		      ld    H, (IX+3) 
1156 23			      inc   HL 
1157 23			      inc   HL 
1158 5e			      ld    E, (HL) 
1159 23			      inc   HL 
115a 56			      ld    D, (HL) 
115b			 
115b e1			      pop   HL                      ; Add sizes of both blocks 
115c 19			      add   HL, DE 
115d eb			      ex    DE, HL 
115e			 
115e dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1161 dd 66 03		      ld    H, (IX+3) 
1164 23			      inc   HL 
1165 23			      inc   HL 
1166 73			      ld    (HL), E 
1167 23			      inc   HL 
1168 72			      ld    (HL), D 
1169			 
1169			free_done: 
1169 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
116c 39			      add   HL, SP 
116d f9			      ld    SP, HL 
116e			 
116e			free_early_exit: 
116e dd e1		      pop   IX 
1170 d1			      pop   DE 
1171 c1			      pop   BC 
1172			 
1172 c9			      ret 
1173			 
1173			; moved to firmware.asm 
1173			; 
1173			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1173			;                  .dw   0 
1173			 
1173			 
1173			endif 
1173			 
1173			 
1173			if MALLOC_3 
1173			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1173			;heap_start        .equ  0x9000      ; Starting address of heap 
1173			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1173			; 
1173			 ;     .org 0 
1173			  ;    jp    main 
1173			; 
1173			; 
1173			 ;     .org  0x100 
1173			;main: 
1173			 ;     ld    HL, 0x8100 
1173			  ;    ld    SP, HL 
1173			; 
1173			;      call  heap_init 
1173			 
1173			      ; Make some allocations 
1173			;      ld    HL, 12 
1173			;      call  malloc            ; Allocates 0x9004 
1173			; 
1173			 ;     ld    HL, 12 
1173			;      call  malloc            ; Allocates 0x9014 
1173			 
1173			;      ld    HL, 12 
1173			;      call  malloc            ; Allocates 0x9024 
1173			 
1173			      ; Free some allocations 
1173			;      ld    HL, 0x9014 
1173			;      call  free 
1173			 
1173			;      ld    HL, 0x9004 
1173			;      call  free 
1173			; 
1173			;      ld    HL, 0x9024 
1173			;      call  free 
1173			 
1173			 
1173			 ;     halt 
1173			 
1173			 
1173			;------------------------------------------------------------------------------ 
1173			;     heap_init                                                               : 
1173			;                                                                             : 
1173			; Description                                                                 : 
1173			;     Initialise the heap and make it ready for malloc and free operations.   : 
1173			;                                                                             : 
1173			;     The heap is maintained as a linked list, starting with an initial       : 
1173			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1173			;     the first free block in the heap. Each block then points to the next    : 
1173			;     free block within the heap, and the free list ends at the first block   : 
1173			;     with a null pointer to the next free block.                             : 
1173			;                                                                             : 
1173			; Parameters                                                                  : 
1173			;     Inputs are compile-time only. Two defines which specify the starting    : 
1173			;     address of the heap and its size are required, along with a memory      : 
1173			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1173			;     principally stores a pointer to the first free block in the heap.       : 
1173			;                                                                             : 
1173			; Returns                                                                     : 
1173			;     Nothing                                                                 : 
1173			;------------------------------------------------------------------------------ 
1173			heap_init: 
1173			      push  HL 
1173			 
1173			      ; Initialise free list struct 
1173			      ld    HL, heap_start 
1173			      ld    (free_list), HL 
1173			      ld    HL, 0 
1173			      ld    (free_list+2), HL 
1173			 
1173			      ; Insert first free block at bottom of heap, consumes entire heap 
1173			      ld    HL, heap_start+heap_size-4 
1173			      ld    (heap_start), HL        ; Next block (end of free list) 
1173			      ld    HL, heap_size-4 
1173			      ld    (heap_start+2), HL      ; Block size 
1173			 
1173			      ; Insert end of free list block at top of heap - two null words will 
1173			      ; terminate the free list 
1173			      ld    HL, 0 
1173			      ld    (heap_start+heap_size-2), HL 
1173			      ld    (heap_start+heap_size-4), HL 
1173			 
1173			      pop   HL 
1173			 
1173			      ret 
1173			 
1173			 
1173			;------------------------------------------------------------------------------ 
1173			;     malloc                                                                  : 
1173			;                                                                             : 
1173			; Description                                                                 : 
1173			;     Allocates the wanted space from the heap and returns the address of the : 
1173			;     first useable byte of the allocation.                                   : 
1173			;                                                                             : 
1173			;     Allocations can happen in one of two ways:                              : 
1173			;                                                                             : 
1173			;     1. A free block may be found which is the exact size wanted. In this    : 
1173			;        case the block is removed from the free list and retuedn to the      : 
1173			;        caller.                                                              : 
1173			;     2. A free block may be found which is larger than the size wanted. In   : 
1173			;        this case, the larger block is split into two. The first portion of  : 
1173			;        this block will become the requested space by the malloc call and    : 
1173			;        is returned to the caller. The second portion becomes a new free     : 
1173			;        block, and the free list is adjusted to maintain continuity via this : 
1173			;        newly created block.                                                 : 
1173			;                                                                             : 
1173			;     malloc does not set any initial value in the allocated space, the       : 
1173			;     caller is required to do this as required.                              : 
1173			;                                                                             : 
1173			;     This implementation of malloc uses the stack exclusively, and is        : 
1173			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1173			;     advisable to disable interrupts before calling malloc, and recommended  : 
1173			;     to avoid the use of malloc inside ISRs in general.                      : 
1173			;                                                                             : 
1173			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1173			;                                                                             : 
1173			; Parameters                                                                  : 
1173			;     HL  Number of bytes wanted                                              : 
1173			;                                                                             : 
1173			; Returns                                                                     : 
1173			;     HL  Address of the first useable byte of the allocation                 : 
1173			;                                                                             : 
1173			; Flags                                                                       : 
1173			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1173			;                                                                             : 
1173			; Stack frame                                                                 : 
1173			;       |             |                                                       : 
1173			;       +-------------+                                                       : 
1173			;       |     BC      |                                                       : 
1173			;       +-------------+                                                       : 
1173			;       |     DE      |                                                       : 
1173			;       +-------------+                                                       : 
1173			;       |     IX      |                                                       : 
1173			;       +-------------+                                                       : 
1173			;       |  prev_free  |                                                       : 
1173			;   +4  +-------------+                                                       : 
1173			;       |  this_free  |                                                       : 
1173			;   +2  +-------------+                                                       : 
1173			;       |  next_free  |                                                       : 
1173			;   +0  +-------------+                                                       : 
1173			;       |             |                                                       : 
1173			;                                                                             : 
1173			;------------------------------------------------------------------------------ 
1173			malloc: 
1173			      push  BC 
1173			      push  DE 
1173			      push  IX 
1173			 
1173			      ld    A, H                    ; Exit if no space requested 
1173			      or    L 
1173			      jp    Z, malloc_early_exit 
1173			 
1173			      ; Set up stack frame 
1173			      ex    DE, HL 
1173			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1173			      add   HL, SP 
1173			      ld    SP, HL 
1173			      ld    IX, 0                   ; Use IX as a frame pointer 
1173			      add   IX, SP 
1173			 
1173			      ; Setup initial state 
1173			      ld    HL, 4                   ; want must also include space used by block struct 
1173			      add   HL, DE 
1173			 
1173			      ld    B, H                    ; Move want to BC 
1173			      ld    C, L 
1173			 
1173			      ld    HL, free_list           ; Store prev_free ptr to stack 
1173			      ld    (IX+4), L 
1173			      ld    (IX+5), H 
1173			 
1173			      ld    E, (HL)                 ; Store this_free ptr to stack 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			      ld    (IX+2), E 
1173			      ld    (IX+3), D 
1173			      ex    DE, HL                  ; this_free ptr into HL 
1173			 
1173			      ; Loop through free block list to find some space 
1173			malloc_find_space: 
1173			      ld    E, (HL)                 ; Load next_free ptr into DE 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			 
1173			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1173			      or    E 
1173			      jp    Z, malloc_no_space 
1173			 
1173			      ld    (IX+0), E               ; Store next_free ptr to stack 
1173			      ld    (IX+1), D 
1173			 
1173			      ; Does this block have enough space to make the allocation? 
1173			      inc   HL                      ; Load free block size into DE 
1173			      ld    E, (HL) 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			 
1173			      ex    DE, HL                  ; Check size of block against want 
1173			      or    A                       ; Ensure carry flag clear 
1173			      sbc   HL, BC 
1173			      push  HL                      ; Store the result for later (new block size) 
1173			 
1173			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1173			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1173			 
1173			      ; this_free block is not big enough, setup ptrs to test next free block 
1173			      pop   HL                      ; Discard previous result 
1173			 
1173			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1173			      ld    H, (IX+3) 
1173			      ld    (IX+4), L 
1173			      ld    (IX+5), H 
1173			 
1173			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1173			      ld    H, (IX+1) 
1173			      ld    (IX+2), L 
1173			      ld    (IX+3), H 
1173			 
1173			      jr    malloc_find_space 
1173			 
1173			      ; split a bigger block into two - requested size and remaining size 
1173			malloc_alloc_split: 
1173			      ex    DE, HL                  ; Calculate address of new free block 
1173			      dec   HL 
1173			      dec   HL 
1173			      dec   HL 
1173			      add   HL, BC 
1173			 
1173			      ; Create a new block and point it at next_free 
1173			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1173			      ld    D, (IX+1) 
1173			 
1173			      ld    (HL), E                 ; Store next_free ptr into new block 
1173			      inc   HL 
1173			      ld    (HL), D 
1173			 
1173			      pop   DE                      ; Store size of new block into new block 
1173			      inc   HL 
1173			      ld    (HL), E 
1173			      inc   HL 
1173			      ld    (HL), D 
1173			 
1173			      ; Update this_free ptr to point to new block 
1173			      dec   HL 
1173			      dec   HL 
1173			      dec   HL 
1173			 
1173			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1173			      ld    D, (IX+3) 
1173			 
1173			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1173			      ld    (IX+3), H 
1173			 
1173			      ; Modify this_free block to be allocation 
1173			      ex    DE, HL 
1173			      xor   A                       ; Null the next block ptr of allocated block 
1173			      ld    (HL), A 
1173			      inc   HL 
1173			      ld    (HL), A 
1173			 
1173			      inc   HL                      ; Store want size into allocated block 
1173			      ld    (HL), C 
1173			      inc   HL 
1173			      ld    (HL), B 
1173			      inc   HL 
1173			      push  HL                      ; Address of allocation to return 
1173			 
1173			      jr    malloc_update_links 
1173			 
1173			malloc_alloc_fit: 
1173			      pop   HL                      ; Dont need new block size, want is exact fit 
1173			 
1173			      ; Modify this_free block to be allocation 
1173			      ex    DE, HL 
1173			      dec   HL 
1173			      dec   HL 
1173			      dec   HL 
1173			 
1173			      xor   A                       ; Null the next block ptr of allocated block 
1173			      ld    (HL), A 
1173			      inc   HL 
1173			      ld    (HL), A 
1173			 
1173			      inc   HL                      ; Store address of allocation to return 
1173			      inc   HL 
1173			      inc   HL 
1173			      push  HL 
1173			 
1173			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1173			      ld    L, (IX+0)               ; next_free to HL 
1173			      ld    H, (IX+1) 
1173			 
1173			      ld    (IX+2), L               ; HL to this_free 
1173			      ld    (IX+3), H 
1173			 
1173			 
1173			malloc_update_links: 
1173			      ; Update prev_free ptr to point to this_free 
1173			      ld    L, (IX+4)               ; prev_free ptr to HL 
1173			      ld    H, (IX+5) 
1173			 
1173			      ld    E, (IX+2)               ; this_free ptr to DE 
1173			      ld    D, (IX+3) 
1173			 
1173			      ld    (HL), E                 ; this_free ptr into prev_free 
1173			      inc   HL 
1173			      ld    (HL), D 
1173			 
1173			      ; Clear the Z flag to indicate successful allocation 
1173			      ld    A, D 
1173			      or    E 
1173			 
1173			      pop   DE                      ; Address of allocation 
1173			 
1173			malloc_no_space: 
1173			      ld    HL, 6                   ; Clean up stack frame 
1173			      add   HL, SP 
1173			      ld    SP, HL 
1173			 
1173			      ex    DE, HL                  ; Alloc addr into HL for return 
1173			 
1173			malloc_early_exit: 
1173			      pop   IX 
1173			      pop   DE 
1173			      pop   BC 
1173			 
1173			      ret 
1173			 
1173			 
1173			;------------------------------------------------------------------------------ 
1173			;     free                                                                    : 
1173			;                                                                             : 
1173			; Description                                                                 : 
1173			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1173			;     returned by malloc, otherwise the behaviour is undefined.               : 
1173			;                                                                             : 
1173			;     Where possible, directly adjacent free blocks will be merged together   : 
1173			;     into larger blocks to help ensure that the heap does not become         : 
1173			;     excessively fragmented.                                                 : 
1173			;                                                                             : 
1173			;     free does not clear or set any other value into the freed space, and    : 
1173			;     therefore its contents may be visible through subsequent malloc's. The  : 
1173			;     caller should clear the freed space as required.                        : 
1173			;                                                                             : 
1173			;     This implementation of free uses the stack exclusively, and is          : 
1173			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1173			;     advisable to disable interrupts before calling free, and recommended    : 
1173			;     to avoid the use of free inside ISRs in general.                        : 
1173			;                                                                             : 
1173			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1173			;                                                                             : 
1173			; Parameters                                                                  : 
1173			;     HL  Pointer to address of first byte of allocation to be freed          : 
1173			;                                                                             : 
1173			; Returns                                                                     : 
1173			;     Nothing                                                                 : 
1173			;                                                                             : 
1173			; Stack frame                                                                 : 
1173			;       |             |                                                       : 
1173			;       +-------------+                                                       : 
1173			;       |     BC      |                                                       : 
1173			;       +-------------+                                                       : 
1173			;       |     DE      |                                                       : 
1173			;       +-------------+                                                       : 
1173			;       |     IX      |                                                       : 
1173			;       +-------------+                                                       : 
1173			;       |  prev_free  |                                                       : 
1173			;   +2  +-------------+                                                       : 
1173			;       |  next_free  |                                                       : 
1173			;   +0  +-------------+                                                       : 
1173			;       |             |                                                       : 
1173			;                                                                             : 
1173			;------------------------------------------------------------------------------ 
1173			free: 
1173			      push  BC 
1173			      push  DE 
1173			      push  IX 
1173			 
1173			      ld    A, H                    ; Exit if ptr is null 
1173			      or    L 
1173			      jp    Z, free_early_exit 
1173			 
1173			      ; Set up stack frame 
1173			      ex    DE, HL 
1173			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1173			      add   HL, SP 
1173			      ld    SP, HL 
1173			      ld    IX, 0                   ; Use IX as a frame pointer 
1173			      add   IX, SP 
1173			 
1173			      ; The address in HL points to the start of the useable allocated space, 
1173			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1173			      ; address of the block itself. 
1173			      ex    DE, HL 
1173			      ld    DE, -4 
1173			      add   HL, DE 
1173			 
1173			      ; An allocated block must have a null next block pointer in it 
1173			      ld    A, (HL) 
1173			      inc   HL 
1173			      or    (HL) 
1173			      jp    NZ, free_done 
1173			 
1173			      dec   HL 
1173			 
1173			      ld    B, H                    ; Copy HL to BC 
1173			      ld    C, L 
1173			 
1173			      ; Loop through the free list to find the first block with an address 
1173			      ; higher than the block being freed 
1173			      ld    HL, free_list 
1173			 
1173			free_find_higher_block: 
1173			      ld    E, (HL)                 ; Load next ptr from free block 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			      dec   HL 
1173			 
1173			      ld    (IX+0), E               ; Save ptr to next free block 
1173			      ld    (IX+1), D 
1173			      ld    (IX+2), L               ; Save ptr to prev free block 
1173			      ld    (IX+3), H 
1173			 
1173			      ld    A, B                    ; Check if DE is greater than BC 
1173			      cp    D                       ; Compare MSB first 
1173			      jr    Z, $+4                  ; MSB the same, compare LSB 
1173			      jr    NC, free_find_higher_block_skip 
1173			      ld    A, C 
1173			      cp    E                       ; Then compare LSB 
1173			      jr    C, free_found_higher_block 
1173			 
1173			free_find_higher_block_skip: 
1173			      ld    A, D                    ; Reached the end of the free list? 
1173			      or    E 
1173			      jp    Z, free_done 
1173			 
1173			      ex    DE, HL 
1173			 
1173			      jr    free_find_higher_block 
1173			 
1173			free_found_higher_block: 
1173			      ; Insert freed block between prev and next free blocks 
1173			      ld    (HL), C                 ; Point prev free block to freed block 
1173			      inc   HL 
1173			      ld    (HL), B 
1173			 
1173			      ld    H, B                    ; Point freed block at next free block 
1173			      ld    L, C 
1173			      ld    (HL), E 
1173			      inc   HL 
1173			      ld    (HL), D 
1173			 
1173			      ; Check if the freed block is adjacent to the next free block 
1173			      inc   HL                      ; Load size of freed block into HL 
1173			      ld    E, (HL) 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			      ex    DE, HL 
1173			 
1173			      add   HL, BC                  ; Add addr of freed block and its size 
1173			 
1173			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1173			      ld    D, (IX+1) 
1173			 
1173			      or    A                       ; Clear the carry flag 
1173			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1173			      jr    NZ, free_check_adjacent_to_prev 
1173			 
1173			      ; Freed block is adjacent to next, merge into one bigger block 
1173			      ex    DE, HL                  ; Load next ptr from next block into DE 
1173			      ld    E, (HL) 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			      push  HL                      ; Save ptr to next block for later 
1173			 
1173			      ld    H, B                    ; Store ptr from next block into freed block 
1173			      ld    L, C 
1173			      ld    (HL), E 
1173			      inc   HL 
1173			      ld    (HL), D 
1173			 
1173			      pop   HL                      ; Restore ptr to next block 
1173			      inc   HL                      ; Load size of next block into DE 
1173			      ld    E, (HL) 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			      push  DE                      ; Save next block size for later 
1173			 
1173			      ld    H, B                    ; Load size of freed block into HL 
1173			      ld    L, C 
1173			      inc   HL 
1173			      inc   HL 
1173			      ld    E, (HL) 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			      ex    DE, HL 
1173			 
1173			      pop   DE                      ; Restore size of next block 
1173			      add   HL, DE                  ; Add sizes of both blocks 
1173			      ex    DE, HL 
1173			 
1173			      ld    H, B                    ; Store new bigger size into freed block 
1173			      ld    L, C 
1173			      inc   HL 
1173			      inc   HL 
1173			      ld    (HL), E 
1173			      inc   HL 
1173			      ld    (HL), D 
1173			 
1173			free_check_adjacent_to_prev: 
1173			      ; Check if the freed block is adjacent to the prev free block 
1173			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1173			      ld    H, (IX+3) 
1173			 
1173			      inc   HL                      ; Size of prev free block into DE 
1173			      inc   HL 
1173			      ld    E, (HL) 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			      dec   HL 
1173			      dec   HL 
1173			      dec   HL 
1173			 
1173			      add   HL, DE                  ; Add prev block addr and size 
1173			 
1173			      or    A                       ; Clear the carry flag 
1173			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1173			      jr    NZ, free_done 
1173			 
1173			      ; Freed block is adjacent to prev, merge into one bigger block 
1173			      ld    H, B                    ; Load next ptr from freed block into DE 
1173			      ld    L, C 
1173			      ld    E, (HL) 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			      push  HL                      ; Save freed block ptr for later 
1173			 
1173			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1173			      ld    H, (IX+3) 
1173			      ld    (HL), E 
1173			      inc   HL 
1173			      ld    (HL), D 
1173			 
1173			      pop   HL                      ; Restore freed block ptr 
1173			      inc   HL                      ; Load size of freed block into DE 
1173			      ld    E, (HL) 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			      push  DE                      ; Save freed block size for later 
1173			 
1173			      ld    L, (IX+2)               ; Load size of prev block into DE 
1173			      ld    H, (IX+3) 
1173			      inc   HL 
1173			      inc   HL 
1173			      ld    E, (HL) 
1173			      inc   HL 
1173			      ld    D, (HL) 
1173			 
1173			      pop   HL                      ; Add sizes of both blocks 
1173			      add   HL, DE 
1173			      ex    DE, HL 
1173			 
1173			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1173			      ld    H, (IX+3) 
1173			      inc   HL 
1173			      inc   HL 
1173			      ld    (HL), E 
1173			      inc   HL 
1173			      ld    (HL), D 
1173			 
1173			free_done: 
1173			      ld    HL, 4                   ; Clean up stack frame 
1173			      add   HL, SP 
1173			      ld    SP, HL 
1173			 
1173			free_early_exit: 
1173			      pop   IX 
1173			      pop   DE 
1173			      pop   BC 
1173			 
1173			      ret 
1173			 
1173			 
1173			;      .org 0x8000 
1173			; 
1173			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1173			 ;                 .dw   0 
1173			 
1173			endif 
1173			 
1173			 
1173			if MALLOC_4 
1173			 
1173			; My memory allocation code. Very very simple.... 
1173			; allocate space under 250 chars 
1173			 
1173			heap_init: 
1173				; init start of heap as zero 
1173				;  
1173			 
1173				ld hl, heap_start 
1173				ld a, 0 
1173				ld (hl), a      ; empty block 
1173				inc hl 
1173				ld a, 0 
1173				ld (hl), a      ; length of block 
1173				; write end of list 
1173				inc hl 
1173				ld a,(hl) 
1173				inc hl 
1173				ld a,(hl) 
1173				 
1173			 
1173				; init some malloc vars 
1173			 
1173				ld hl, 0 
1173				ld (free_list), hl       ; store last malloc location 
1173			 
1173				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1173				ld a, 0 
1173				ld (hl), a 
1173			 
1173			 
1173				ld hl, heap_start 
1173				;  
1173				  
1173				ret 
1173			 
1173			 
1173			;    free block marker 
1173			;    requested size  
1173			;    pointer to next block 
1173			;    .... 
1173			;    next block marker 
1173			 
1173			 
1173			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1173			; 
1173			 
1173			 
1173			malloc:  
1173				push de 
1173				push bc 
1173				push af 
1173			 
1173				; hl space required 
1173				 
1173				ld c, l    ; hold space   (TODO only a max of 255) 
1173			 
1173			;	inc c     ; TODO BUG need to fix memory leak on push str 
1173			;	inc c 
1173			;	inc c 
1173			;	inc c 
1173			;	inc c 
1173			;	inc c 
1173			;	inc c 
1173			 
1173			 
1173			 
1173				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1173			 
1173				ld a, (free_list+3) 
1173				cp 0 
1173				jr z, .contheap 
1173			 
1173				ld hl, (free_list)     ; get last alloc 
1173					if DEBUG_FORTH_MALLOC_INT 
1173						DMARK "mrs" 
1173						CALLMONITOR 
1173					endif 
1173				jr .startalloc 
1173			 
1173			.contheap: 
1173				ld hl, heap_start 
1173			 
1173			.startalloc: 
1173			 
1173					if DEBUG_FORTH_MALLOC_INT 
1173						DMARK "mym" 
1173						CALLMONITOR 
1173					endif 
1173			.findblock: 
1173					if DEBUG_FORTH_MALLOC_INT 
1173						DMARK "mmf" 
1173						CALLMONITOR 
1173					endif 
1173			 
1173				ld a,(hl)  
1173				; if byte is zero then clear to use 
1173			 
1173				cp 0 
1173				jr z, .foundemptyblock 
1173			 
1173				; if byte is not clear 
1173				;     then byte is offset to next block 
1173			 
1173				inc hl 
1173				ld a, (hl) ; get size 
1173			.nextblock:	inc hl 
1173					ld e, (hl) 
1173					inc hl 
1173					ld d, (hl) 
1173					ex de, hl 
1173			;	inc hl  ; move past the store space 
1173			;	inc hl  ; move past zero index  
1173			 
1173				; TODO detect no more space 
1173			 
1173				push hl 
1173				ld de, heap_end 
1173				call cmp16 
1173				pop hl 
1173				jr nc, .nospace 
1173			 
1173				jr .findblock 
1173			 
1173			.nospace: ld hl, 0 
1173				jp .exit 
1173			 
1173			 
1173			.foundemptyblock:	 
1173					if DEBUG_FORTH_MALLOC_INT 
1173						DMARK "mme" 
1173						CALLMONITOR 
1173					endif 
1173			 
1173			; TODO has block enough space if reusing??? 
1173			 
1173				;  
1173			 
1173			; see if this block has been previously used 
1173				inc hl 
1173				ld a, (hl) 
1173				dec hl 
1173				cp 0 
1173				jr z, .newblock 
1173			 
1173					if DEBUG_FORTH_MALLOC_INT 
1173						DMARK "meR" 
1173						CALLMONITOR 
1173					endif 
1173			 
1173			; no reusing previously allocated block 
1173			 
1173			; is it smaller than previously used? 
1173				 
1173				inc hl    ; move to size 
1173				ld a, c 
1173				sub (hl)        ; we want c < (hl) 
1173				dec hl    ; move back to marker 
1173			        jr z, .findblock 
1173			 
1173				; update with the new size which should be lower 
1173			 
1173			        ;inc  hl   ; negate next move. move back to size  
1173			 
1173			.newblock: 
1173				; need to be at marker here 
1173			 
1173					if DEBUG_FORTH_MALLOC_INT 
1173						DMARK "meN" 
1173						CALLMONITOR 
1173					endif 
1173			 
1173			 
1173				ld a, c 
1173			 
1173				ld (free_list+3), a	 ; flag resume from last malloc  
1173				ld (free_list), hl    ; save out last location 
1173			 
1173			 
1173				;inc a     ; space for length byte 
1173				ld (hl), a     ; save block in use marker 
1173			 
1173				inc hl   ; move to space marker 
1173				ld (hl), a    ; save new space 
1173			 
1173				inc hl   ; move to start of allocated area 
1173				 
1173			;	push hl     ; save where we are - 1  
1173			 
1173			;	inc hl  ; move past zero index  
1173				; skip space to set down new marker 
1173			 
1173				; provide some extra space for now 
1173			 
1173				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1173				inc a 
1173				inc a 
1173			 
1173				push hl   ; save where we are in the node block 
1173			 
1173				call addatohl 
1173			 
1173				; write linked list point 
1173			 
1173				pop de     ; get our node position 
1173				ex de, hl 
1173			 
1173				ld (hl), e 
1173				inc hl 
1173				ld (hl), d 
1173			 
1173				inc hl 
1173			 
1173				; now at start of allocated data so save pointer 
1173			 
1173				push hl 
1173			 
1173				; jump to position of next node and setup empty header in DE 
1173			 
1173				ex de, hl 
1173			 
1173			;	inc hl ; move past end of block 
1173			 
1173				ld a, 0 
1173				ld (hl), a   ; empty marker 
1173				inc hl 
1173				ld (hl), a   ; size 
1173				inc hl  
1173				ld (hl), a   ; ptr 
1173				inc hl 
1173				ld (hl), a   ; ptr 
1173			 
1173			 
1173				pop hl 
1173			 
1173					if DEBUG_FORTH_MALLOC_INT 
1173						DMARK "mmr" 
1173						CALLMONITOR 
1173					endif 
1173			 
1173			.exit: 
1173				pop af 
1173				pop bc 
1173				pop de  
1173				ret 
1173			 
1173			 
1173			 
1173			 
1173			free:  
1173				push hl 
1173				push af 
1173				; get address in hl 
1173			 
1173					if DEBUG_FORTH_MALLOC_INT 
1173						DMARK "fre" 
1173						CALLMONITOR 
1173					endif 
1173				; data is at hl - move to block count 
1173				dec hl 
1173				dec hl    ; get past pointer 
1173				dec hl 
1173			 
1173				ld a, (hl)    ; need this for a validation check 
1173			 
1173				dec hl    ; move to block marker 
1173			 
1173				; now check that the block count and block marker are the same  
1173			        ; this checks that we are on a malloc node and not random memory 
1173			        ; OK a faint chance this could be a problem but rare - famous last words! 
1173			 
1173				ld c, a 
1173				ld a, (hl)    
1173			 
1173				cp c 
1173				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1173			 
1173				; yes good chance we are on a malloc node 
1173			 
1173				ld a, 0      
1173				ld (hl), a   ; mark as free 
1173			 
1173				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1173			 
1173			.freeignore:  
1173			 
1173				pop af 
1173				pop hl 
1173			 
1173				ret 
1173			 
1173			 
1173			 
1173			endif 
1173			 
1173			; eof 
# End of file firmware_memory.asm
1173			  
1173			; device C  
1173			if SOUND_ENABLE  
1173				include "firmware_sound.asm"  
1173			endif  
1173			  
1173			include "firmware_diags.asm"  
1173			; Hardware diags menu 
1173			 
1173			 
1173 .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1194 .. 00		hd_menu2:   db "        2: Editor",0   
11a6			;hd_menu2:   db "        2: Editor       6: BASIC",0   
11a6 .. 00		hd_menu3:   db "        3: Storage",0 
11b9 .. 00		hd_menu4:   db "0=quit  4: Debug",0 
11ca .. 00		hd_don:     db "ON",0 
11cd .. 00		hd_doff:     db "OFF",0 
11d1			 
11d1			 
11d1			 
11d1			hardware_diags:       
11d1			 
11d1			.diagmenu: 
11d1 cd ba 09			call clear_display 
11d4 3e 00			ld a, display_row_1 
11d6 11 73 11			ld de, hd_menu1 
11d9 cd cd 09			call str_at_display 
11dc			 
11dc 3e 14			ld a, display_row_2 
11de 11 94 11			ld de, hd_menu2 
11e1 cd cd 09			call str_at_display 
11e4			 
11e4 3e 28			ld a, display_row_3 
11e6 11 a6 11			ld de, hd_menu3 
11e9 cd cd 09			call str_at_display 
11ec			 
11ec 3e 3c			ld a,  display_row_4 
11ee 11 b9 11			ld de, hd_menu4 
11f1 cd cd 09			call str_at_display 
11f4			 
11f4				; display debug state 
11f4			 
11f4 11 ca 11			ld de, hd_don 
11f7 3a b7 ef			ld a, (os_view_disable) 
11fa fe 00			cp 0 
11fc 28 03			jr z, .distog 
11fe 11 cd 11			ld de, hd_doff 
1201 3e 4d		.distog: ld a, display_row_4+17 
1203 cd cd 09			call str_at_display 
1206			 
1206 cd dd 09			call update_display 
1209			 
1209 cd 23 53			call cin_wait 
120c			 
120c			 
120c			 
120c fe 34			cp '4' 
120e 20 0f			jr nz, .diagn1 
1210			 
1210				; debug toggle 
1210			 
1210 3a b7 ef			ld a, (os_view_disable) 
1213 06 2a			ld b, '*' 
1215 fe 00			cp 0 
1217 28 02			jr z, .debtog 
1219 06 00			ld b, 0 
121b			.debtog:	 
121b 78				ld a,b 
121c 32 b7 ef			ld (os_view_disable),a 
121f			 
121f fe 30		.diagn1: cp '0' 
1221 c8				 ret z 
1222			 
1222			;	cp '1' 
1222			;       jp z, matrix	 
1222			;   TODO keyboard matrix test 
1222			 
1222 fe 32			cp '2' 
1224 ca 2b 12			jp z, .diagedit 
1227			 
1227			;if ENABLE_BASIC 
1227			;	cp '6' 
1227			;	jp z, basic 
1227			;endif 
1227			  
1227 c3 d1 11			jp .diagmenu 
122a			 
122a			 
122a c9				ret 
122b			 
122b			; debug editor 
122b			 
122b			.diagedit: 
122b			 
122b 21 b8 ef			ld hl, scratch 
122e			;	ld bc, 250 
122e			;	ldir 
122e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
122e 3e 00			ld a, 0 
1230 77				ld (hl), a 
1231 23				inc hl 
1232 77				ld (hl), a 
1233 23				inc hl 
1234 77				ld (hl), a 
1235			 
1235 cd ba 09		        call clear_display 
1238 cd dd 09			call update_display 
123b 3e 01			ld a, 1 
123d 32 c3 fb			ld (hardware_diag), a 
1240			.diloop: 
1240 3e 00			ld a, display_row_1 
1242 0e 00			ld c, 0 
1244 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1246 1e 28			ld e, 40 
1248			 
1248 21 b8 ef			ld hl, scratch	 
124b cd 40 0b			call input_str 
124e			 
124e 3e 14			ld a, display_row_2 
1250 11 b8 ef			ld de, scratch 
1253 cd cd 09			call str_at_display 
1256 cd dd 09			call update_display 
1259			 
1259 c3 40 12			jp .diloop 
125c			 
125c			 
125c			; pass word in hl 
125c			; a has display location 
125c			display_word_at: 
125c f5				push af 
125d e5				push hl 
125e 7c				ld a,h 
125f 21 bd f2			ld hl, os_word_scratch 
1262 cd 14 0e			call hexout 
1265 e1				pop hl 
1266 7d				ld a,l 
1267 21 bf f2			ld hl, os_word_scratch+2 
126a cd 14 0e			call hexout 
126d 21 c1 f2			ld hl, os_word_scratch+4 
1270 3e 00			ld a,0 
1272 77				ld (hl),a 
1273 11 bd f2			ld de,os_word_scratch 
1276 f1				pop af 
1277 cd cd 09				call str_at_display 
127a c9				ret 
127b			 
127b			display_ptr_state: 
127b			 
127b				; to restore afterwards 
127b			 
127b d5				push de 
127c c5				push bc 
127d e5				push hl 
127e f5				push af 
127f			 
127f				; for use in here 
127f			 
127f			;	push bc 
127f			;	push de 
127f			;	push hl 
127f			;	push af 
127f			 
127f cd ba 09			call clear_display 
1282			 
1282 11 55 14			ld de, .ptrstate 
1285 3e 00			ld a, display_row_1 
1287 cd cd 09			call str_at_display 
128a			 
128a				; display debug step 
128a			 
128a			 
128a 11 bd fb			ld de, debug_mark 
128d 3e 12			ld a, display_row_1+display_cols-2 
128f cd cd 09			call str_at_display 
1292			 
1292				; display a 
1292 11 5f 14			ld de, .ptrcliptr 
1295 3e 14			ld a, display_row_2 
1297 cd cd 09			call str_at_display 
129a			 
129a f1				pop af 
129b 2a c3 f9			ld hl,(cli_ptr) 
129e 3e 1c			ld a, display_row_2+8 
12a0 cd 5c 12			call display_word_at 
12a3			 
12a3			 
12a3				; display hl 
12a3			 
12a3			 
12a3 11 67 14			ld de, .ptrclioptr 
12a6 3e 1e			ld a, display_row_2+10 
12a8 cd cd 09			call str_at_display 
12ab			; 
12ab			;	pop hl 
12ab 3e 21			ld a, display_row_2+13 
12ad 2a c1 f9			ld hl,(cli_origptr) 
12b0 cd 5c 12			call display_word_at 
12b3			; 
12b3			;	 
12b3			;	; display de 
12b3			 
12b3			;	ld de, .regstatede 
12b3			;	ld a, display_row_3 
12b3			;	call str_at_display 
12b3			 
12b3			;	pop de 
12b3			;	ld h,d 
12b3			;	ld l, e 
12b3			;	ld a, display_row_3+3 
12b3			;	call display_word_at 
12b3			 
12b3			 
12b3				; display bc 
12b3			 
12b3			;	ld de, .regstatebc 
12b3			;	ld a, display_row_3+10 
12b3			;	call str_at_display 
12b3			 
12b3			;	pop bc 
12b3			;	ld h,b 
12b3			;	ld l, c 
12b3			;	ld a, display_row_3+13 
12b3			;	call display_word_at 
12b3			 
12b3			 
12b3				; display dsp 
12b3			 
12b3			;	ld de, .regstatedsp 
12b3			;	ld a, display_row_4 
12b3			;	call str_at_display 
12b3			 
12b3				 
12b3			;	ld hl,(cli_data_sp) 
12b3			;	ld a, display_row_4+4 
12b3			;	call display_word_at 
12b3			 
12b3				; display rsp 
12b3			 
12b3 11 96 14			ld de, .regstatersp 
12b6 3e 46			ld a, display_row_4+10 
12b8 cd cd 09			call str_at_display 
12bb			 
12bb				 
12bb 2a a9 f9			ld hl,(cli_ret_sp) 
12be 3e 4a			ld a, display_row_4+14 
12c0 cd 5c 12			call display_word_at 
12c3			 
12c3 cd dd 09			call update_display 
12c6			 
12c6 cd 3e 09			call delay1s 
12c9 cd 3e 09			call delay1s 
12cc cd 3e 09			call delay1s 
12cf			 
12cf			 
12cf cd dc 17			call next_page_prompt 
12d2			 
12d2				; restore  
12d2			 
12d2 f1				pop af 
12d3 e1				pop hl 
12d4 c1				pop bc 
12d5 d1				pop de 
12d6 c9				ret 
12d7			 
12d7			break_point_state: 
12d7 f5				push af 
12d8			 
12d8				; see if disabled 
12d8			 
12d8 3a b7 ef			ld a, (os_view_disable) 
12db fe 2a			cp '*' 
12dd 20 02			jr nz, .bpsgo 
12df f1				pop af 
12e0 c9				ret 
12e1			 
12e1			.bpsgo: 
12e1 f1				pop af 
12e2 f5				push af 
12e3 22 b3 ef			ld (os_view_hl), hl 
12e6 ed 53 b1 ef		ld (os_view_de), de 
12ea ed 43 af ef		ld (os_view_bc), bc 
12ee e5				push hl 
12ef 6f				ld l, a 
12f0 26 00			ld h, 0 
12f2 22 b5 ef			ld (os_view_af),hl 
12f5			 
12f5 21 53 fb				ld hl, display_fb0 
12f8 22 5e fa				ld (display_fb_active), hl 
12fb e1				pop hl	 
12fc			 
12fc 3e 31			ld a, '1' 
12fe fe 2a		.bps1:  cp '*' 
1300 20 03			jr nz, .bps1b 
1302 32 b7 ef			ld (os_view_disable),a 
1305 fe 31		.bps1b:  cp '1' 
1307 20 14			jr nz, .bps2 
1309			 
1309				; display reg 
1309			 
1309				 
1309			 
1309 3a b5 ef			ld a, (os_view_af) 
130c 2a b3 ef			ld hl, (os_view_hl) 
130f ed 5b b1 ef		ld de, (os_view_de) 
1313 ed 4b af ef		ld bc, (os_view_bc) 
1317 cd b1 13			call display_reg_state 
131a c3 9d 13			jp .bpschk 
131d			 
131d fe 32		.bps2:  cp '2' 
131f 20 08			jr nz, .bps3 
1321				 
1321				; display hl 
1321 2a b3 ef			ld hl, (os_view_hl) 
1324 cd 9b 14			call display_dump_at_hl 
1327			 
1327 18 74			jr .bpschk 
1329			 
1329 fe 33		.bps3:  cp '3' 
132b 20 08			jr nz, .bps4 
132d			 
132d			        ; display de 
132d 2a b1 ef			ld hl, (os_view_de) 
1330 cd 9b 14			call display_dump_at_hl 
1333			 
1333 18 68			jr .bpschk 
1335 fe 34		.bps4:  cp '4' 
1337 20 08			jr nz, .bps5 
1339			 
1339			        ; display bc 
1339 2a af ef			ld hl, (os_view_bc) 
133c cd 9b 14			call display_dump_at_hl 
133f			 
133f 18 5c			jr .bpschk 
1341 fe 35		.bps5:  cp '5' 
1343 20 08		        jr nz, .bps7 
1345			 
1345				; display cur ptr 
1345 2a c3 f9			ld hl, (cli_ptr) 
1348 cd 9b 14			call display_dump_at_hl 
134b			 
134b 18 50			jr .bpschk 
134d fe 36		.bps7:  cp '6' 
134f 20 08			jr nz, .bps8b 
1351				 
1351				; display cur orig ptr 
1351 2a c1 f9			ld hl, (cli_origptr) 
1354 cd 9b 14			call display_dump_at_hl 
1357 18 44			jr .bpschk 
1359 fe 37		.bps8b:  cp '7' 
135b 20 08			jr nz, .bps9 
135d				 
135d				; display dsp 
135d 2a a5 f9			ld hl, (cli_data_sp) 
1360 cd 9b 14			call display_dump_at_hl 
1363			 
1363 18 38			jr .bpschk 
1365 fe 39		.bps9:  cp '9' 
1367 20 05			jr nz, .bps8c 
1369				 
1369				; display SP 
1369			;	ld hl, sp 
1369 cd 9b 14			call display_dump_at_hl 
136c			 
136c 18 2f			jr .bpschk 
136e fe 38		.bps8c:  cp '8' 
1370 20 08			jr nz, .bps8d 
1372				 
1372				; display rsp 
1372 2a a9 f9			ld hl, (cli_ret_sp) 
1375 cd 9b 14			call display_dump_at_hl 
1378			 
1378 18 23			jr .bpschk 
137a fe 23		.bps8d:  cp '#'     ; access monitor sub system 
137c 20 05			jr nz, .bps8 
137e cd d2 15			call monitor 
1381			 
1381 18 1a			jr .bpschk 
1383 fe 30		.bps8:  cp '0' 
1385 20 16			jr nz, .bpschk 
1387			 
1387 21 02 fb				ld hl, display_fb1 
138a 22 5e fa				ld (display_fb_active), hl 
138d cd dd 09				call update_display 
1390			 
1390				;ld a, (os_view_af) 
1390 2a b3 ef			ld hl, (os_view_hl) 
1393 ed 5b b1 ef		ld de, (os_view_de) 
1397 ed 4b af ef		ld bc, (os_view_bc) 
139b f1				pop af 
139c c9				ret 
139d			 
139d			.bpschk:   
139d cd 3e 09			call delay1s 
13a0 3e 4f		ld a,display_row_4 + display_cols - 1 
13a2 11 da 17		        ld de, endprg 
13a5 cd cd 09			call str_at_display 
13a8 cd dd 09			call update_display 
13ab cd 23 53			call cin_wait 
13ae			 
13ae c3 fe 12			jp .bps1 
13b1			 
13b1			 
13b1			display_reg_state: 
13b1			 
13b1				; to restore afterwards 
13b1			 
13b1 d5				push de 
13b2 c5				push bc 
13b3 e5				push hl 
13b4 f5				push af 
13b5			 
13b5				; for use in here 
13b5			 
13b5 c5				push bc 
13b6 d5				push de 
13b7 e5				push hl 
13b8 f5				push af 
13b9			 
13b9 cd ba 09			call clear_display 
13bc			 
13bc 11 71 14			ld de, .regstate 
13bf 3e 00			ld a, display_row_1 
13c1 cd cd 09			call str_at_display 
13c4			 
13c4				; display debug step 
13c4			 
13c4			 
13c4 11 bd fb			ld de, debug_mark 
13c7 3e 11			ld a, display_row_1+display_cols-3 
13c9 cd cd 09			call str_at_display 
13cc			 
13cc				; display a 
13cc 11 8d 14			ld de, .regstatea 
13cf 3e 14			ld a, display_row_2 
13d1 cd cd 09			call str_at_display 
13d4			 
13d4 e1				pop hl 
13d5			;	ld h,0 
13d5			;	ld l, a 
13d5 3e 17			ld a, display_row_2+3 
13d7 cd 5c 12			call display_word_at 
13da			 
13da			 
13da				; display hl 
13da			 
13da			 
13da 11 81 14			ld de, .regstatehl 
13dd 3e 1e			ld a, display_row_2+10 
13df cd cd 09			call str_at_display 
13e2			 
13e2 e1				pop hl 
13e3 3e 21			ld a, display_row_2+13 
13e5 cd 5c 12			call display_word_at 
13e8			 
13e8				 
13e8				; display de 
13e8			 
13e8 11 85 14			ld de, .regstatede 
13eb 3e 28			ld a, display_row_3 
13ed cd cd 09			call str_at_display 
13f0			 
13f0 e1				pop hl 
13f1			;	ld h,d 
13f1			;	ld l, e 
13f1 3e 2b			ld a, display_row_3+3 
13f3 cd 5c 12			call display_word_at 
13f6			 
13f6			 
13f6				; display bc 
13f6			 
13f6 11 89 14			ld de, .regstatebc 
13f9 3e 32			ld a, display_row_3+10 
13fb cd cd 09			call str_at_display 
13fe			 
13fe e1				pop hl 
13ff			;	ld h,b 
13ff			;	ld l, c 
13ff 3e 35			ld a, display_row_3+13 
1401 cd 5c 12			call display_word_at 
1404			 
1404			 
1404				; display dsp 
1404			 
1404 11 91 14			ld de, .regstatedsp 
1407 3e 3c			ld a, display_row_4 
1409 cd cd 09			call str_at_display 
140c			 
140c				 
140c 2a a5 f9			ld hl,(cli_data_sp) 
140f 3e 40			ld a, display_row_4+4 
1411 cd 5c 12			call display_word_at 
1414			 
1414				; display rsp 
1414			 
1414 11 96 14			ld de, .regstatersp 
1417 3e 46			ld a, display_row_4+10 
1419 cd cd 09			call str_at_display 
141c			 
141c				 
141c 2a a9 f9			ld hl,(cli_ret_sp) 
141f 3e 4a			ld a, display_row_4+14 
1421 cd 5c 12			call display_word_at 
1424			 
1424 cd dd 09			call update_display 
1427			 
1427			;	call delay1s 
1427			;	call delay1s 
1427			;	call delay1s 
1427			 
1427			 
1427			;	call next_page_prompt 
1427			 
1427				; restore  
1427			 
1427 f1				pop af 
1428 e1				pop hl 
1429 c1				pop bc 
142a d1				pop de 
142b c9				ret 
142c			 
142c .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1440 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1455 .. 00		.ptrstate:	db "Ptr State",0 
145f .. 00		.ptrcliptr:     db "cli_ptr",0 
1467 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1471 .. 00		.regstate:	db "Reg State (1/0)",0 
1481 .. 00		.regstatehl:	db "HL:",0 
1485 .. 00		.regstatede:	db "DE:",0 
1489 .. 00		.regstatebc:	db "BC:",0 
148d .. 00		.regstatea:	db "A :",0 
1491 .. 00		.regstatedsp:	db "DSP:",0 
1496 .. 00		.regstatersp:	db "RSP:",0 
149b			 
149b			display_dump_at_hl: 
149b e5				push hl 
149c d5				push de 
149d c5				push bc 
149e f5				push af 
149f			 
149f 22 db f2			ld (os_cur_ptr),hl	 
14a2 cd ba 09			call clear_display 
14a5 cd e4 16			call dumpcont 
14a8			;	call delay1s 
14a8			;	call next_page_prompt 
14a8			 
14a8			 
14a8 f1				pop af 
14a9 c1				pop bc 
14aa d1				pop de 
14ab e1				pop hl 
14ac c9				ret 
14ad			 
14ad			;if ENABLE_BASIC 
14ad			;	include "nascombasic.asm" 
14ad			;	basic: 
14ad			;	include "forth/FORTH.ASM" 
14ad			;endif 
14ad			 
14ad			; eof 
14ad			 
14ad			 
# End of file firmware_diags.asm
14ad			  
14ad			  
14ad			  
14ad			  
14ad			; eof  
14ad			  
# End of file firmware.asm
14ad			 
14ad			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
14ad			;if BASE_KEV  
14ad			;baseram: equ 08000h 
14ad			;endif 
14ad			 
14ad			;if BASE_SC114 
14ad			;baseram:     equ    endofcode 
14ad			;endif 
14ad			 
14ad			 
14ad			; start system 
14ad			 
14ad			coldstart: 
14ad				; set sp 
14ad				; di/ei 
14ad			 
14ad f3				di 
14ae 31 fd ff			ld sp, tos 
14b1			;	ei 
14b1			 
14b1			 
14b1				; disable breakpoint by default 
14b1			 
14b1 3e 2a			ld a,'*' 
14b3 32 b7 ef			ld (os_view_disable),a 
14b6			 
14b6				; init hardware 
14b6			 
14b6				; init keyboard and screen hardware 
14b6			 
14b6 cd 03 00			call hardware_init 
14b9			 
14b9			 
14b9				; detect if any keys are held down to enable breakpoints at start up 
14b9			 
14b9 cd 34 53			call cin  
14bc fe 00			cp 0 
14be 28 03			jr z, .nokeys 
14c0			 
14c0 cd d1 11			call hardware_diags 
14c3			 
14c3			;	ld de, .bpen 
14c3			;	ld a, display_row_4 
14c3			;	call str_at_display 
14c3			;	call update_display 
14c3			; 
14c3			;	ld a,0 
14c3			;	ld (os_view_disable),a 
14c3			; 
14c3			;.bpwait: 
14c3			;	call cin 
14c3			;	cp 0 
14c3			;	jr z, .bpwait 
14c3			;	jr .nokeys 
14c3			; 
14c3			; 
14c3			;.bpen:  db "Break points enabled!",0 
14c3			 
14c3			 
14c3			 
14c3			 
14c3			 
14c3			 
14c3			.nokeys: 
14c3			 
14c3			 
14c3				 
14c3			 
14c3			;jp  testkey 
14c3			 
14c3			;call storage_get_block_0 
14c3			; 
14c3			;ld hl, 0 
14c3			;ld de, store_page 
14c3			;call storage_read_block 
14c3			 
14c3				 
14c3			;ld hl, 10 
14c3			;ld de, store_page 
14c3			;call storage_read_block 
14c3			 
14c3			 
14c3			 
14c3			 
14c3			 
14c3			;stop:	nop 
14c3			;	jp stop 
14c3			 
14c3			 
14c3			 
14c3			main: 
14c3 cd ba 09			call clear_display 
14c6 cd dd 09			call update_display 
14c9			 
14c9			 
14c9			 
14c9			;	call testlcd 
14c9			 
14c9			 
14c9			 
14c9 cd 0b 1a			call forth_init 
14cc			 
14cc			 
14cc			warmstart: 
14cc cd e1 19			call forth_warmstart 
14cf			 
14cf				; run startup word load 
14cf			        ; TODO prevent this running at warmstart after crash  
14cf			 
14cf				if STARTUP_ENABLE 
14cf cd 9d 4e				call forth_startup 
14d2				endif 
14d2			 
14d2				; show free memory after boot 
14d2 11 6c 15			ld de, freeram 
14d5 3e 00			ld a, display_row_1 
14d7 cd cd 09			call str_at_display 
14da			 
14da			; Or use heap_size word???? 
14da 21 ac ef			ld hl, heap_end 
14dd 11 0e 80			ld de, heap_start 
14e0 ed 52			sbc hl, de 
14e2 e5				push hl 
14e3 7c				ld a,h	         	 
14e4 21 bd f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
14e7 cd 14 0e			call hexout 
14ea e1			   	pop hl 
14eb			 
14eb 7d				ld a,l 
14ec 21 bf f2			ld hl, os_word_scratch+2 
14ef cd 14 0e			call hexout 
14f2 21 c1 f2			ld hl, os_word_scratch+4 
14f5 3e 00			ld a, 0 
14f7 77				ld (hl),a 
14f8 11 bd f2			ld de, os_word_scratch 
14fb 3e 0d			ld a, display_row_1 + 13 
14fd cd cd 09			call str_at_display 
1500 cd dd 09			call update_display 
1503			 
1503			 
1503				;call demo 
1503			 
1503			 
1503				; init scratch input area for cli commands 
1503			 
1503 21 df f2			ld hl, os_cli_cmd 
1506 3e 00			ld a,0 
1508 77				ld (hl),a 
1509 23				inc hl 
150a 77				ld (hl),a 
150b			 
150b 3e 00			ld a,0 
150d 32 de f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1510			 
1510 32 db f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1513 32 dc f2			ld (os_cur_ptr+1),a	 
1516			 
1516 32 bd f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1519 32 be f2			ld (os_word_scratch+1),a	 
151c				 
151c			 
151c				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
151c 21 df f2			ld hl, os_cli_cmd 
151f			 
151f 3e 00			ld a, 0		 ; init cli input 
1521 77				ld (hl), a 
1522 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1524			cli: 
1524				; show cli prompt 
1524				;push af 
1524				;ld a, 0 
1524				;ld de, prompt 
1524				;call str_at_display 
1524			 
1524				;call update_display 
1524				;pop af 
1524				;inc a 
1524				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1524 0e 00			ld c, 0 
1526 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1528 1e 28			ld e, 40 
152a			 
152a 21 df f2			ld hl, os_cli_cmd 
152d			 
152d				STACKFRAME OFF $fefe $9f9f 
152d				if DEBUG_STACK_IMB 
152d					if OFF 
152d						exx 
152d						ld de, $fefe 
152d						ld a, d 
152d						ld hl, curframe 
152d						call hexout 
152d						ld a, e 
152d						ld hl, curframe+2 
152d						call hexout 
152d						ld hl, $fefe 
152d						push hl 
152d						ld hl, $9f9f 
152d						push hl 
152d						exx 
152d					endif 
152d				endif 
152d			endm 
# End of macro STACKFRAME
152d			 
152d cd 40 0b			call input_str 
1530			 
1530				STACKFRAMECHK OFF $fefe $9f9f 
1530				if DEBUG_STACK_IMB 
1530					if OFF 
1530						exx 
1530						ld hl, $9f9f 
1530						pop de   ; $9f9f 
1530						call cmp16 
1530						jr nz, .spnosame 
1530						ld hl, $fefe 
1530						pop de   ; $fefe 
1530						call cmp16 
1530						jr z, .spfrsame 
1530						.spnosame: call showsperror 
1530						.spfrsame: nop 
1530						exx 
1530					endif 
1530				endif 
1530			endm 
# End of macro STACKFRAMECHK
1530			 
1530				; copy input to last command 
1530			 
1530 21 df f2			ld hl, os_cli_cmd 
1533 11 de f3			ld de, os_last_cmd 
1536 01 ff 00			ld bc, 255 
1539 ed b0			ldir 
153b				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
153b			;	call strcpy 
153b			;	ld a, 0 
153b			;	ld (hl), a 
153b			;	inc hl 
153b			;	ld (hl), a 
153b			;	inc hl 
153b			;	ld (hl), a 
153b			 
153b				; switch frame buffer to program  
153b			 
153b 21 02 fb				ld hl, display_fb1 
153e 22 5e fa				ld (display_fb_active), hl 
1541			 
1541			;	nop 
1541				STACKFRAME ON $fbfe $8f9f 
1541				if DEBUG_STACK_IMB 
1541					if ON 
1541						exx 
1541						ld de, $fbfe 
1541						ld a, d 
1541						ld hl, curframe 
1541						call hexout 
1541						ld a, e 
1541						ld hl, curframe+2 
1541						call hexout 
1541						ld hl, $fbfe 
1541						push hl 
1541						ld hl, $8f9f 
1541						push hl 
1541						exx 
1541					endif 
1541				endif 
1541			endm 
# End of macro STACKFRAME
1541				; first time into the parser so pass over the current scratch pad 
1541 21 df f2			ld hl,os_cli_cmd 
1544				; tokenise the entered statement(s) in HL 
1544 cd 84 1a			call forthparse 
1547			        ; exec forth statements in top of return stack 
1547 cd c4 1a			call forthexec 
154a				;call forthexec_cleanup 
154a			;	call parsenext 
154a			 
154a				STACKFRAMECHK ON $fbfe $8f9f 
154a				if DEBUG_STACK_IMB 
154a					if ON 
154a						exx 
154a						ld hl, $8f9f 
154a						pop de   ; $8f9f 
154a						call cmp16 
154a						jr nz, .spnosame 
154a						ld hl, $fbfe 
154a						pop de   ; $fbfe 
154a						call cmp16 
154a						jr z, .spfrsame 
154a						.spnosame: call showsperror 
154a						.spfrsame: nop 
154a						exx 
154a					endif 
154a				endif 
154a			endm 
# End of macro STACKFRAMECHK
154a				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
154a			 
154a 3e 3c			ld a, display_row_4 
154c 11 7e 15			ld de, endprog 
154f			 
154f cd dd 09			call update_display		 
1552			 
1552 cd dc 17			call next_page_prompt 
1555			 
1555				; switch frame buffer to cli 
1555			 
1555 21 53 fb				ld hl, display_fb0 
1558 22 5e fa				ld (display_fb_active), hl 
155b			 
155b			 
155b cd ba 09		        call clear_display 
155e cd dd 09			call update_display		 
1561			 
1561 21 df f2			ld hl, os_cli_cmd 
1564			 
1564 3e 00			ld a, 0		 ; init cli input 
1566 77				ld (hl), a 
1567			 
1567				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1567			 
1567				; now on last line 
1567			 
1567				; TODO scroll screen up 
1567			 
1567				; TODO instead just clear screen and place at top of screen 
1567			 
1567			;	ld a, 0 
1567			;	ld (f_cursor_ptr),a 
1567			 
1567				;call clear_display 
1567				;call update_display 
1567			 
1567				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1567 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1569 c3 24 15			jp cli 
156c			 
156c .. 00		freeram: db "Free bytes: $",0 
157a ..			asc: db "1A2F" 
157e .. 00		endprog: db "End prog...",0 
158a			 
158a			testenter2:   
158a 21 ea ef			ld hl,scratch+50 
158d 22 db f2			ld (os_cur_ptr),hl 
1590 c3 24 15			jp cli 
1593			 
1593			testenter:  
1593			 
1593 21 7a 15			ld hl,asc 
1596			;	ld a,(hl) 
1596			;	call nibble2val 
1596 cd 6a 0e			call get_byte 
1599			 
1599			 
1599			;	ld a,(hl) 
1599			;	call atohex 
1599			 
1599			;	call fourehexhl 
1599 32 ea ef			ld (scratch+50),a 
159c			 
159c			 
159c			 
159c 21 7c 15			ld hl,asc+2 
159f			;	ld a, (hl) 
159f			;	call nibble2val 
159f cd 6a 0e			call get_byte 
15a2			 
15a2			;	call fourehexhl 
15a2 32 ec ef			ld (scratch+52),a 
15a5				 
15a5 21 ea ef			ld hl,scratch+50 
15a8 22 db f2			ld (os_cur_ptr),hl 
15ab c3 24 15			jp cli 
15ae			 
15ae			enter:	 
15ae 3a bc ef			ld a,(scratch+4) 
15b1 fe 00			cp 0 
15b3 28 0c			jr z, .entercont 
15b5				; no, not a null term line so has an address to work out.... 
15b5			 
15b5 21 ba ef			ld hl,scratch+2 
15b8 cd ca 0e			call get_word_hl 
15bb			 
15bb 22 db f2			ld (os_cur_ptr),hl	 
15be c3 24 15			jp cli 
15c1			 
15c1			 
15c1			.entercont:  
15c1			 
15c1 21 ba ef			ld hl, scratch+2 
15c4 cd 6a 0e			call get_byte 
15c7			 
15c7 2a db f2		   	ld hl,(os_cur_ptr) 
15ca 77					ld (hl),a 
15cb 23					inc hl 
15cc 22 db f2				ld (os_cur_ptr),hl 
15cf				 
15cf			; get byte  
15cf			 
15cf			 
15cf c3 24 15			jp cli 
15d2			 
15d2			 
15d2			; basic monitor support 
15d2			 
15d2			monitor: 
15d2				;  
15d2 cd ba 09			call clear_display 
15d5 3e 00			ld a, 0 
15d7 11 1f 16			ld de, .monprompt 
15da cd cd 09			call str_at_display 
15dd cd dd 09			call update_display 
15e0			 
15e0				; get a monitor command 
15e0			 
15e0 0e 00			ld c, 0     ; entry at top left 
15e2 16 64			ld d, 100   ; max buffer size 
15e4 1e 0f			ld e, 15    ; input scroll area 
15e6 3e 00			ld a, 0     ; init string 
15e8 21 b6 f1			ld hl, os_input 
15eb 77				ld (hl), a 
15ec 23				inc hl 
15ed 77				ld (hl), a 
15ee 21 b6 f1			ld hl, os_input 
15f1 3e 01			ld a, 1     ; init string 
15f3 cd 40 0b			call input_str 
15f6			 
15f6 cd ba 09		        call clear_display 
15f9 cd dd 09			call update_display		 
15fc			 
15fc 3a b6 f1			ld a, (os_input) 
15ff cd 68 0f			call toUpper 
1602 fe 48		        cp 'H' 
1604 28 6f		        jr z, .monhelp 
1606 fe 44			cp 'D'		; dump 
1608 ca 96 16			jp z, .mondump	 
160b fe 43			cp 'C'		; dump 
160d ca b0 16			jp z, .moncdump	 
1610 fe 4d			cp 'M'		; dump 
1612 ca 21 16			jp z, .moneditstart 
1615 fe 55			cp 'U'		; dump 
1617 28 14			jr z, .monedit	 
1619 fe 51			cp 'Q'		; dump 
161b c8				ret z	 
161c			 
161c			 
161c				; TODO "S" to access symbol by name and not need the address 
161c				; TODO "F" to find a string in memory 
161c			 
161c c3 d2 15			jp monitor 
161f			 
161f .. 00		.monprompt: db ">", 0 
1621			 
1621			.moneditstart: 
1621				; get starting address 
1621			 
1621 21 b8 f1			ld hl,os_input+2 
1624 cd ca 0e			call get_word_hl 
1627			 
1627 22 db f2			ld (os_cur_ptr),hl	 
162a			 
162a c3 d2 15			jp monitor 
162d			 
162d			.monedit: 
162d				; get byte to load 
162d			 
162d 21 b8 f1			ld hl,os_input+2 
1630 cd 6a 0e			call get_byte 
1633			 
1633				; get address to update 
1633 2a db f2			ld hl, (os_cur_ptr) 
1636			 
1636				; update byte 
1636			 
1636 77				ld (hl), a 
1637			 
1637				; move to next address and save it 
1637			 
1637 23				inc hl 
1638 22 db f2			ld (os_cur_ptr),hl	 
163b			 
163b c3 d2 15			jp monitor 
163e			 
163e			 
163e .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1652 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
166e .. 00		.monhelptext3:  db "Q-Quit",0 
1675			        
1675			.monhelp: 
1675 3e 00			ld a, display_row_1 
1677 11 3e 16		        ld de, .monhelptext1 
167a			 
167a cd cd 09			call str_at_display 
167d 3e 14			ld a, display_row_2 
167f 11 52 16		        ld de, .monhelptext2 
1682					 
1682 cd cd 09			call str_at_display 
1685 3e 28			ld a, display_row_3 
1687 11 6e 16		        ld de, .monhelptext3 
168a					 
168a cd cd 09			call str_at_display 
168d cd dd 09			call update_display		 
1690			 
1690 cd dc 17			call next_page_prompt 
1693 c3 d2 15			jp monitor 
1696			 
1696			.mondump:    
1696 21 b8 f1			ld hl,os_input+2 
1699 cd ca 0e			call get_word_hl 
169c			 
169c 22 db f2			ld (os_cur_ptr),hl	 
169f cd e4 16			call dumpcont 
16a2 3e 3c			ld a, display_row_4 
16a4 11 7e 15			ld de, endprog 
16a7			 
16a7 cd dd 09			call update_display		 
16aa			 
16aa cd dc 17			call next_page_prompt 
16ad c3 d2 15			jp monitor 
16b0			.moncdump: 
16b0 cd e4 16			call dumpcont 
16b3 3e 3c			ld a, display_row_4 
16b5 11 7e 15			ld de, endprog 
16b8			 
16b8 cd dd 09			call update_display		 
16bb			 
16bb cd dc 17			call next_page_prompt 
16be c3 d2 15			jp monitor 
16c1			 
16c1			 
16c1			; TODO symbol access  
16c1			 
16c1			.symbols:     ;; A list of symbols that can be called up  
16c1 53 fb			dw display_fb0 
16c3 .. 00			db "fb0",0  
16c7 e8 f9		     	dw store_page 
16c9 .. 00			db "store_page",0 
16d4			 
16d4			 
16d4			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
16d4			 
16d4 3a b9 ef			ld a,(scratch+1) 
16d7 fe 00			cp 0 
16d9 28 09			jr z, dumpcont 
16db			 
16db				; no, not a null term line so has an address to work out.... 
16db			 
16db 21 ba ef			ld hl,scratch+2 
16de cd ca 0e			call get_word_hl 
16e1			 
16e1 22 db f2			ld (os_cur_ptr),hl	 
16e4			 
16e4			 
16e4			 
16e4			dumpcont: 
16e4			 
16e4				; dump bytes at ptr 
16e4			 
16e4			 
16e4 3e 00			ld a, display_row_1 
16e6 2a 5e fa			ld hl, (display_fb_active) 
16e9 cd 13 0b			call addatohl 
16ec cd 14 17			call .dumpbyterow 
16ef			 
16ef 3e 14			ld a, display_row_2 
16f1 2a 5e fa			ld hl, (display_fb_active) 
16f4 cd 13 0b			call addatohl 
16f7 cd 14 17			call .dumpbyterow 
16fa			 
16fa			 
16fa 3e 28			ld a, display_row_3 
16fc 2a 5e fa			ld hl, (display_fb_active) 
16ff cd 13 0b			call addatohl 
1702 cd 14 17			call .dumpbyterow 
1705			 
1705 3e 3c			ld a, display_row_4 
1707 2a 5e fa			ld hl, (display_fb_active) 
170a cd 13 0b			call addatohl 
170d cd 14 17			call .dumpbyterow 
1710			 
1710 cd dd 09			call update_display 
1713			;		jp cli 
1713 c9				ret 
1714			 
1714			.dumpbyterow: 
1714			 
1714				;push af 
1714			 
1714 e5				push hl 
1715			 
1715				; calc where to poke the ascii 
1715			if display_cols == 20 
1715 3e 10			ld a, 16 
1717			else 
1717				ld a, 31 
1717			endif 
1717			 
1717 cd 13 0b			call addatohl 
171a 22 bd f2			ld (os_word_scratch),hl  		; save pos for later 
171d			 
171d			 
171d			; display decoding address 
171d 2a db f2		   	ld hl,(os_cur_ptr) 
1720			 
1720 7c				ld a,h 
1721 e1				pop hl 
1722 e5				push hl 
1723			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1723 cd 14 0e			call hexout 
1726 2a db f2		   	ld hl,(os_cur_ptr) 
1729			 
1729 7d				ld a,l 
172a e1				pop hl 
172b 23				inc hl 
172c 23				inc hl 
172d e5				push hl 
172e			;	ld hl, os_word_scratch+2 
172e cd 14 0e			call hexout 
1731 e1				pop hl 
1732 23				inc hl 
1733 23				inc hl 
1734				;ld hl, os_word_scratch+4 
1734 3e 3a			ld a, ':' 
1736 77				ld (hl),a 
1737 23				inc hl 
1738				;ld a, 0 
1738				;ld (hl),a 
1738				;ld de, os_word_scratch 
1738				;pop af 
1738				;push af 
1738			;		ld a, display_row_2 
1738			;		call str_at_display 
1738			;		call update_display 
1738			 
1738			 
1738			;pop af 
1738			;	add 5 
1738			 
1738			if display_cols == 20 
1738 06 04			ld b, 4 
173a			else 
173a				ld b, 8 
173a			endif	 
173a			 
173a			.dumpbyte: 
173a c5				push bc 
173b e5				push hl 
173c			 
173c			 
173c 2a db f2		   	ld hl,(os_cur_ptr) 
173f 7e					ld a,(hl) 
1740			 
1740					; poke the ascii to display 
1740 2a bd f2				ld hl,(os_word_scratch) 
1743 77					ld (hl),a 
1744 23					inc hl 
1745 22 bd f2				ld (os_word_scratch),hl 
1748			 
1748					 
1748			 
1748			 
1748 e1					pop hl 
1749 e5					push hl 
174a			 
174a cd 14 0e				call hexout 
174d			 
174d					 
174d 2a db f2		   	ld hl,(os_cur_ptr) 
1750 23				inc hl 
1751 22 db f2		   	ld (os_cur_ptr),hl 
1754			 
1754 e1					pop hl 
1755 23					inc hl 
1756 23					inc hl 
1757 23					inc hl 
1758			 
1758			 
1758			 
1758					;ld a,0 
1758					;ld (os_word_scratch+2),a 
1758					;pop af 
1758					;push af 
1758			 
1758					;ld de, os_word_scratch 
1758					;call str_at_display 
1758			;		call update_display 
1758			;		pop af 
1758 c1					pop bc 
1759 c6 03				add 3 
175b 10 dd			djnz .dumpbyte 
175d			 
175d				 
175d			 
175d c9				ret 
175e			 
175e			jump:	 
175e			 
175e 21 ba ef			ld hl,scratch+2 
1761 cd ca 0e			call get_word_hl 
1764				;ld hl,(scratch+2) 
1764				;call fourehexhl 
1764			 
1764 22 db f2			ld (os_cur_ptr),hl	 
1767			 
1767 e9				jp (hl) 
1768			 
1768			 
1768			 
1768			; TODO implement a basic monitor mode to start with 
1768			 
1768			 
1768			 
1768			 
1768			 
1768			 
1768			 
1768			 
1768			 
1768			; testing and demo code during development 
1768			 
1768			 
1768 .. 00		str1: db "Enter some text...",0 
177b .. 00		clear: db "                    ",0 
1790			 
1790			demo: 
1790			 
1790			 
1790			 
1790			;	call update_display 
1790			 
1790				; init scratch input area for testing 
1790 21 b8 ef			ld hl, scratch	 
1793 3e 00			ld a,0 
1795 77				ld (hl),a 
1796			 
1796			 
1796 3e 14		            LD   A, display_row_2 
1798			;            CALL fLCD_Pos       ;Position cursor to location in A 
1798 11 68 17		            LD   DE, str1 
179b cd cd 09			call str_at_display 
179e			 
179e			;            CALL fLCD_Str       ;Display string pointed to by DE 
179e			cloop:	 
179e 3e 28		            LD   A, display_row_3 
17a0			;            CALL fLCD_Pos       ;Position cursor to location in A 
17a0 11 7b 17		            LD   DE, clear 
17a3			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
17a3 cd cd 09				call str_at_display 
17a6 3e 3c			ld a, display_row_4 
17a8 11 d8 17			ld de, prompt 
17ab			 
17ab cd cd 09				call str_at_display 
17ae cd dd 09			call update_display 
17b1			 
17b1 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
17b3 16 0a			ld d, 10 
17b5 21 b8 ef			ld hl, scratch	 
17b8 cd 40 0b			call input_str 
17bb			 
17bb			;	call clear_display 
17bb			;'	call update_display 
17bb			 
17bb 3e 00		            LD   A, display_row_1 
17bd			;            CALL fLCD_Pos       ;Position cursor to location in A 
17bd 11 7b 17		            LD   DE, clear 
17c0 cd cd 09				call str_at_display 
17c3			;            CALL fLCD_Str       ;Display string pointed to by DE 
17c3 3e 00		            LD   A, display_row_1 
17c5			;            CALL fLCD_Pos       ;Position cursor to location in A 
17c5 11 b8 ef		            LD   DE, scratch 
17c8			;            CALL fLCD_Str       ;Display string pointed to by DE 
17c8 cd cd 09				call str_at_display 
17cb cd dd 09			call update_display 
17ce			 
17ce 3e 00				ld a,0 
17d0 21 b8 ef			ld hl, scratch 
17d3 77				ld (hl),a 
17d4			 
17d4 00				nop 
17d5 c3 9e 17			jp cloop 
17d8			 
17d8			 
17d8			 
17d8			; OS Prompt 
17d8			 
17d8 .. 00		prompt: db ">",0 
17da .. 00		endprg: db "?",0 
17dc			 
17dc			 
17dc			; handy next page prompt 
17dc			next_page_prompt: 
17dc e5				push hl 
17dd d5				push de 
17de f5				push af 
17df c5				push bc 
17e0			 
17e0 3e 4f			ld a,display_row_4 + display_cols - 1 
17e2 11 da 17		        ld de, endprg 
17e5 cd cd 09			call str_at_display 
17e8 cd dd 09			call update_display 
17eb cd 23 53			call cin_wait 
17ee c1				pop bc 
17ef f1				pop af 
17f0 d1				pop de 
17f1 e1				pop hl 
17f2			 
17f2			 
17f2 c9				ret 
17f3			 
17f3			 
17f3			; forth parser 
17f3			 
17f3			; My forth kernel 
17f3			include "forth_kernel.asm" 
17f3			; 
17f3			; kernel to the forth OS 
17f3			 
17f3			DS_TYPE_STR: equ 1     ; string type 
17f3			DS_TYPE_INUM: equ 2     ; $ 16 bit int usually a hex address 
17f3			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
17f3			 
17f3			FORTH_PARSEV1: equ 0 
17f3			FORTH_PARSEV2: equ 0 
17f3			FORTH_PARSEV3: equ 0 
17f3			FORTH_PARSEV4: equ 0 
17f3			FORTH_PARSEV5: equ 1 
17f3			 
17f3			;if FORTH_PARSEV5 
17f3			;	FORTH_END_BUFFER: equ 0 
17f3			;else 
17f3			FORTH_END_BUFFER: equ 127 
17f3			;endif 
17f3			 
17f3			FORTH_TRUE: equ 1 
17f3			FORTH_FALSE: equ 0 
17f3			 
17f3			if FORTH_PARSEV4 
17f3			include "forth_stackops.asm" 
17f3			endif 
17f3			 
17f3			if FORTH_PARSEV5 
17f3			include "forth_stackopsv5.asm" 
17f3			 
17f3			; Stack operations for v5 parser on wards 
17f3			; * DATA stack 
17f3			; * LOOP stack 
17f3			; * RETURN stack 
17f3			 
17f3			 
17f3			 
17f3			FORTH_CHK_DSP_UNDER: macro 
17f3				push hl 
17f3				push de 
17f3				ld hl,(cli_data_sp) 
17f3				ld de, cli_data_stack 
17f3				call cmp16 
17f3				jp c, fault_dsp_under 
17f3				pop de 
17f3				pop hl 
17f3				endm 
17f3			 
17f3			 
17f3			FORTH_CHK_RSP_UNDER: macro 
17f3				push hl 
17f3				push de 
17f3				ld hl,(cli_ret_sp) 
17f3				ld de, cli_ret_stack 
17f3				call cmp16 
17f3				jp c, fault_rsp_under 
17f3				pop de 
17f3				pop hl 
17f3				endm 
17f3			 
17f3			FORTH_CHK_LOOP_UNDER: macro 
17f3				push hl 
17f3				push de 
17f3				ld hl,(cli_loop_sp) 
17f3				ld de, cli_loop_stack 
17f3				call cmp16 
17f3				jp c, fault_loop_under 
17f3				pop de 
17f3				pop hl 
17f3				endm 
17f3			 
17f3			FORTH_ERR_TOS_NOTSTR: macro 
17f3				; TOSO might need more for checks when used 
17f3				push af 
17f3				ld a,(hl) 
17f3				cp DS_TYPE_STR 
17f3				jp nz, type_faultn   
17f3				pop af 
17f3				endm 
17f3			 
17f3			FORTH_ERR_TOS_NOTNUM: macro 
17f3				push af 
17f3				ld a,(hl) 
17f3				cp DS_TYPE_INUM 
17f3				jp nz, type_faultn   
17f3				pop af 
17f3				endm 
17f3			 
17f3			 
17f3			; increase data stack pointer and save hl to it 
17f3				 
17f3			FORTH_DSP_NEXT: macro 
17f3				call macro_forth_dsp_next 
17f3				endm 
17f3			 
17f3			 
17f3			macro_forth_dsp_next: 
17f3				if DEBUG_FORTH_STACK_GUARD 
17f3 cd 67 4f				call check_stacks 
17f6				endif 
17f6 e5				push hl 
17f7 d5				push de 
17f8 eb				ex de,hl 
17f9 2a a5 f9			ld hl,(cli_data_sp) 
17fc 23				inc hl 
17fd 23				inc hl 
17fe			 
17fe			; PARSEV5 
17fe 23				inc hl 
17ff 22 a5 f9			ld (cli_data_sp),hl 
1802 73				ld (hl), e 
1803 23				inc hl 
1804 72				ld (hl), d 
1805 d1				pop de 
1806 e1				pop hl 
1807				if DEBUG_FORTH_STACK_GUARD 
1807 cd 67 4f				call check_stacks 
180a				endif 
180a c9				ret 
180b			 
180b			 
180b			; increase ret stack pointer and save hl to it 
180b				 
180b			FORTH_RSP_NEXT: macro 
180b				call macro_forth_rsp_next 
180b				endm 
180b			 
180b			macro_forth_rsp_next: 
180b				if DEBUG_FORTH_STACK_GUARD 
180b cd 67 4f				call check_stacks 
180e				endif 
180e e5				push hl 
180f d5				push de 
1810 eb				ex de,hl 
1811 2a a9 f9			ld hl,(cli_ret_sp) 
1814 23				inc hl 
1815 23				inc hl 
1816 22 a9 f9			ld (cli_ret_sp),hl 
1819 73				ld (hl), e 
181a 23				inc hl 
181b 72				ld (hl), d 
181c d1				pop de 
181d e1				pop hl 
181e				if DEBUG_FORTH_STACK_GUARD 
181e cd 67 4f				call check_stacks 
1821				endif 
1821 c9				ret 
1822			 
1822			; get current ret stack pointer and save to hl  
1822				 
1822			FORTH_RSP_TOS: macro 
1822				call macro_forth_rsp_tos 
1822				endm 
1822			 
1822			macro_forth_rsp_tos: 
1822				;push de 
1822 2a a9 f9			ld hl,(cli_ret_sp) 
1825 cd 5a 18			call loadhlptrtohl 
1828				;ld e, (hl) 
1828				;inc hl 
1828				;ld d, (hl) 
1828				;ex de, hl 
1828					if DEBUG_FORTH_WORDS 
1828			;			DMARK "RST" 
1828						CALLMONITOR 
1828					endif 
1828				;pop de 
1828 c9				ret 
1829			 
1829			; pop ret stack pointer 
1829				 
1829			FORTH_RSP_POP: macro 
1829				call macro_forth_rsp_pop 
1829				endm 
1829			 
1829			 
1829			macro_forth_rsp_pop: 
1829				if DEBUG_FORTH_STACK_GUARD 
1829			;		DMARK "RPP" 
1829 cd 67 4f				call check_stacks 
182c					FORTH_CHK_RSP_UNDER 
182c e5				push hl 
182d d5				push de 
182e 2a a9 f9			ld hl,(cli_ret_sp) 
1831 11 23 f9			ld de, cli_ret_stack 
1834 cd 31 0b			call cmp16 
1837 da 7b 50			jp c, fault_rsp_under 
183a d1				pop de 
183b e1				pop hl 
183c				endm 
# End of macro FORTH_CHK_RSP_UNDER
183c				endif 
183c e5				push hl 
183d 2a a9 f9			ld hl,(cli_ret_sp) 
1840			 
1840			 
1840				if FORTH_ENABLE_FREE 
1840			 
1840					; get pointer 
1840			 
1840					push de 
1840					push hl 
1840			 
1840					ld e, (hl) 
1840					inc hl 
1840					ld d, (hl) 
1840			 
1840					ex de, hl 
1840					call free 
1840			 
1840					pop hl 
1840					pop de 
1840			 
1840			 
1840				endif 
1840			 
1840			 
1840 2b				dec hl 
1841 2b				dec hl 
1842 22 a9 f9			ld (cli_ret_sp), hl 
1845				; do stack underflow checks 
1845 e1				pop hl 
1846				if DEBUG_FORTH_STACK_GUARD 
1846 cd 67 4f				call check_stacks 
1849					FORTH_CHK_RSP_UNDER 
1849 e5				push hl 
184a d5				push de 
184b 2a a9 f9			ld hl,(cli_ret_sp) 
184e 11 23 f9			ld de, cli_ret_stack 
1851 cd 31 0b			call cmp16 
1854 da 7b 50			jp c, fault_rsp_under 
1857 d1				pop de 
1858 e1				pop hl 
1859				endm 
# End of macro FORTH_CHK_RSP_UNDER
1859				endif 
1859 c9				ret 
185a			 
185a			 
185a			 
185a			; routine to load word pointed to by hl into hl 
185a			 
185a			loadhlptrtohl: 
185a			 
185a d5				push de 
185b 5e				ld e, (hl) 
185c 23				inc hl 
185d 56				ld d, (hl) 
185e eb				ex de, hl 
185f d1				pop de 
1860			 
1860 c9				ret 
1861			 
1861			 
1861			 
1861			 
1861			 
1861			; push a number held in HL onto the data stack 
1861			; entry point for pushing a value when already in hl used in function above 
1861			 
1861			forth_push_numhl: 
1861			 
1861 e5				push hl    ; save value to push 
1862			 
1862			if DEBUG_FORTH_PUSH 
1862				; see if disabled 
1862			 
1862			 
1862				push af 
1862				ld a, (os_view_disable) 
1862				cp '*' 
1862				jr z, .pskip2 
1862				push hl 
1862			push hl 
1862				call clear_display 
1862			pop hl 
1862				ld a,h 
1862				ld hl, os_word_scratch 
1862				call hexout 
1862				pop hl 
1862				ld a,l 
1862				ld hl, os_word_scratch+2 
1862				call hexout 
1862			 
1862				ld hl, os_word_scratch+4 
1862				ld a,0 
1862				ld (hl),a 
1862				ld de,os_word_scratch 
1862					ld a, display_row_2 
1862					call str_at_display 
1862				ld de, .push_num 
1862				ld a, display_row_1 
1862			 
1862					call str_at_display 
1862			 
1862			 
1862				call update_display 
1862				call delay1s 
1862				call delay1s 
1862			.pskip2:  
1862			 
1862				pop af 
1862			endif	 
1862			 
1862			 
1862				FORTH_DSP_NEXT 
1862 cd f3 17			call macro_forth_dsp_next 
1865				endm 
# End of macro FORTH_DSP_NEXT
1865			 
1865 2a a5 f9			ld hl, (cli_data_sp) 
1868			 
1868				; save item type 
1868 3e 02			ld a,  DS_TYPE_INUM 
186a 77				ld (hl), a 
186b 23				inc hl 
186c			 
186c				; get word off stack 
186c d1				pop de 
186d 7b				ld a,e 
186e 77				ld (hl), a 
186f 23				inc hl 
1870 7a				ld a,d 
1871 77				ld (hl), a 
1872			 
1872			if DEBUG_FORTH_PUSH 
1872				dec hl 
1872				dec hl 
1872				dec hl 
1872						DMARK "PH5" 
1872				CALLMONITOR 
1872			endif	 
1872			 
1872 c9				ret 
1873			 
1873			 
1873			; Push a string to stack pointed to by hl 
1873			 
1873			forth_push_str: 
1873			 
1873			if DEBUG_FORTH_PUSH 
1873						DMARK "PSQ" 
1873				CALLMONITOR 
1873			endif	 
1873			    
1873 e5				push hl 
1874 e5				push hl 
1875			 
1875 3e 00			ld a, 0   ; find end of string 
1877 cd 7c 0f			call strlent       
187a			if DEBUG_FORTH_PUSH 
187a						DMARK "PQ2" 
187a				CALLMONITOR 
187a			endif	 
187a eb				ex de, hl 
187b e1				pop hl   ; get ptr to start of string 
187c			if DEBUG_FORTH_PUSH 
187c						DMARK "PQ3" 
187c				CALLMONITOR 
187c			endif	 
187c 19				add hl,de 
187d			if DEBUG_FORTH_PUSH 
187d						DMARK "PQE" 
187d				CALLMONITOR 
187d			endif	 
187d			 
187d 2b				dec hl    ; see if there is an optional trailing double quote 
187e 7e				ld a,(hl) 
187f fe 22			cp '"' 
1881 20 03			jr nz, .strnoq 
1883 3e 00			ld a, 0      ; get rid of double quote 
1885 77				ld (hl), a 
1886 23			.strnoq: inc hl 
1887			 
1887 3e 00			ld a, 0 
1889 77				ld (hl), a     ; add null term and get rid of trailing double quote 
188a			 
188a 13				inc de ; add one for the type string 
188b 13				inc de ; add one for null term??? 
188c			 
188c				; tos is get string pointer again 
188c				; de contains space to allocate 
188c				 
188c d5				push de 
188d			 
188d eb				ex de, hl 
188e			 
188e				;push af 
188e			 
188e			if DEBUG_FORTH_PUSH 
188e						DMARK "PHm" 
188e				CALLMONITOR 
188e			endif	 
188e cd da 0f			call malloc	; on ret hl now contains allocated memory 
1891				if DEBUG_FORTH_MALLOC_GUARD 
1891 cc 38 3f				call z,malloc_error 
1894				endif 
1894			 
1894				 
1894 c1				pop bc    ; get length 
1895 d1				pop de   ;  get string start    
1896			 
1896				; hl has destination from malloc 
1896			 
1896 eb				ex de, hl    ; prep for ldir 
1897			 
1897 e5				push hl   ; save malloc area for DSP later 
1898			 
1898			if DEBUG_FORTH_PUSH 
1898						DMARK "PHc" 
1898				CALLMONITOR 
1898			endif	 
1898			 
1898			 
1898 ed b0			ldir 
189a			 
189a			 
189a				; push malloc to data stack     macro?????  
189a			 
189a				FORTH_DSP_NEXT 
189a cd f3 17			call macro_forth_dsp_next 
189d				endm 
# End of macro FORTH_DSP_NEXT
189d			 
189d				; save value and type 
189d			 
189d 2a a5 f9			ld hl, (cli_data_sp) 
18a0			 
18a0				; save item type 
18a0 3e 01			ld a,  DS_TYPE_STR 
18a2 77				ld (hl), a 
18a3 23				inc hl 
18a4			 
18a4				; get malloc word off stack 
18a4 d1				pop de 
18a5 73				ld (hl), e 
18a6 23				inc hl 
18a7 72				ld (hl), d 
18a8			 
18a8			 
18a8			 
18a8			if DEBUG_FORTH_PUSH 
18a8				ld hl, (cli_data_sp) 
18a8						DMARK "PHS" 
18a8				CALLMONITOR 
18a8			;	ex de,hl 
18a8			endif	 
18a8				; in case of spaces, skip the ptr past the copied string 
18a8				;pop af 
18a8				;ld (cli_origptr),hl 
18a8			 
18a8 c9				ret 
18a9			 
18a9			 
18a9			 
18a9			; TODO ascii push input onto stack given hl to start of input 
18a9			 
18a9			; identify type 
18a9			; if starts with a " then a string 
18a9			; otherwise it is a number 
18a9			;  
18a9			; if a string 
18a9			;     scan for ending " to get length of string to malloc for + 1 
18a9			;     malloc 
18a9			;     put pointer to string on stack first byte flags as string 
18a9			; 
18a9			; else a number 
18a9			;    look for number format identifier 
18a9			;    $xx hex 
18a9			;    %xxxxx bin 
18a9			;    xxxxx decimal 
18a9			;    convert number to 16bit word.  
18a9			;    malloc word + 1 with flag to identiy as num 
18a9			;    put pointer to number on stack 
18a9			;   
18a9			;  
18a9			  
18a9			forth_apush: 
18a9				; kernel push 
18a9			 
18a9			if DEBUG_FORTH_PUSH 
18a9						DMARK "PSH" 
18a9				CALLMONITOR 
18a9			endif	 
18a9				; identify input type 
18a9			 
18a9 7e				ld a,(hl) 
18aa fe 22			cp '"' 
18ac 28 0a			jr z, .fapstr 
18ae fe 24			cp '$' 
18b0 ca d8 18			jp z, .faphex 
18b3 fe 25			cp '%' 
18b5 ca c0 18			jp z, .fapbin 
18b8			;	cp 'b' 
18b8			;	jp z, .fabin 
18b8				; else decimal 
18b8			 
18b8				; TODO do decimal conversion 
18b8				; decimal is stored as a 16bit word 
18b8			 
18b8				; by default everything is a string if type is not detected 
18b8			.fapstr: ; 
18b8 fe 22			cp '"' 
18ba 20 01			jr nz, .strnoqu 
18bc 23				inc hl 
18bd			.strnoqu: 
18bd c3 73 18			jp forth_push_str 
18c0			 
18c0			 
18c0			 
18c0			.fapbin:    ; push a binary string.  
18c0 11 00 00			ld de, 0   ; hold a 16bit value 
18c3			 
18c3 23			.fapbinshift:	inc hl  
18c4 7e				ld a,(hl) 
18c5 fe 00			cp 0     ; done scanning  
18c7 28 0b			jr z, .fapbdone  	; got it in HL so push  
18c9			 
18c9				; left shift de 
18c9 eb				ex de, hl	 
18ca 29				add hl, hl 
18cb			 
18cb				; is 1 
18cb fe 31			cp '1' 
18cd 20 02			jr nz, .binzero 
18cf cb 4d			bit 1, l 
18d1			.binzero: 
18d1 eb				ex de, hl	 ; save current de 
18d2 18 ef			jr .fapbinshift 
18d4			 
18d4			.fapbdone: 
18d4 eb				ex de, hl 
18d5 c3 61 18			jp forth_push_numhl 
18d8			 
18d8			 
18d8			.faphex:   ; hex is always stored as a 16bit word 
18d8				; skip number prefix 
18d8 23				inc hl 
18d9				; turn ascii into number 
18d9 cd ca 0e			call get_word_hl	; ret 16bit word in hl 
18dc			 
18dc c3 61 18			jp forth_push_numhl 
18df			 
18df 00				 nop 
18e0			 
18e0			.fabin:   ; TODO bin conversion 
18e0			 
18e0			 
18e0 c9				ret 
18e1			 
18e1			 
18e1			; get either a string ptr or a 16bit word from the data stack 
18e1			 
18e1			FORTH_DSP: macro 
18e1				call macro_forth_dsp 
18e1				endm 
18e1			 
18e1			macro_forth_dsp: 
18e1				; data stack pointer points to current word on tos 
18e1			 
18e1 2a a5 f9			ld hl,(cli_data_sp) 
18e4			 
18e4				if DEBUG_FORTH_PUSH 
18e4						DMARK "DSP" 
18e4			 
18e4					call display_data_sp 
18e4				;call break_point_state 
18e4				;rst 030h 
18e4				CALLMONITOR 
18e4				endif 
18e4			 
18e4 c9				ret 
18e5			 
18e5			; return hl to start of value on stack 
18e5			 
18e5			FORTH_DSP_VALUE: macro 
18e5				call macro_forth_dsp_value 
18e5				endm 
18e5			 
18e5			macro_forth_dsp_value: 
18e5			 
18e5				FORTH_DSP 
18e5 cd e1 18			call macro_forth_dsp 
18e8				endm 
# End of macro FORTH_DSP
18e8			 
18e8 d5				push de 
18e9			 
18e9 23				inc hl ; skip type 
18ea			 
18ea 5e				ld e, (hl) 
18eb 23				inc hl 
18ec 56				ld d, (hl) 
18ed eb				ex de,hl  
18ee			 
18ee d1				pop de 
18ef			 
18ef c9				ret 
18f0			 
18f0			; return hl to start of value to second item on stack 
18f0			 
18f0			FORTH_DSP_VALUEM1: macro 
18f0				call macro_forth_dsp_value_m1 
18f0				endm 
18f0			 
18f0			macro_forth_dsp_value_m1: 
18f0			 
18f0				FORTH_DSP 
18f0 cd e1 18			call macro_forth_dsp 
18f3				endm 
# End of macro FORTH_DSP
18f3			 
18f3 2b				dec hl 
18f4 2b				dec hl 
18f5			;	dec hl 
18f5			 
18f5 d5				push de 
18f6			 
18f6 5e				ld e, (hl) 
18f7 23				inc hl 
18f8 56				ld d, (hl) 
18f9 eb				ex de,hl  
18fa			 
18fa d1				pop de 
18fb			 
18fb c9				ret 
18fc			 
18fc				 
18fc			 
18fc			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
18fc			 
18fc			FORTH_DSP_POP: macro 
18fc				call macro_forth_dsp_pop 
18fc				endm 
18fc			 
18fc			 
18fc			; get the tos data type 
18fc			 
18fc			FORTH_DSP_TYPE:   macro 
18fc			 
18fc				;FORTH_DSP_VALUE 
18fc				FORTH_DSP 
18fc				 
18fc				; hl points to value 
18fc				; check type 
18fc			 
18fc				ld a,(hl) 
18fc			 
18fc				endm 
18fc			 
18fc			; load the tos value into hl 
18fc			 
18fc			 
18fc			FORTH_DSP_VALUEHL:  macro 
18fc				call macro_dsp_valuehl 
18fc				endm 
18fc			 
18fc			 
18fc			 
18fc			macro_dsp_valuehl: 
18fc				FORTH_DSP_VALUE 
18fc cd e5 18			call macro_forth_dsp_value 
18ff				endm 
# End of macro FORTH_DSP_VALUE
18ff			 
18ff				;FORTH_ERR_TOS_NOTNUM 
18ff			 
18ff				;inc hl   ; skip type id 
18ff			 
18ff			;	push de 
18ff			; 
18ff			;	ld e, (hl) 
18ff			;	inc hl 
18ff			;	ld d, (hl) 
18ff			;	ex de,hl  
18ff			 
18ff			;	pop de 
18ff			 
18ff				if DEBUG_FORTH_PUSH 
18ff						DMARK "DVL" 
18ff				CALLMONITOR 
18ff				endif 
18ff c9				ret 
1900			 
1900			forth_apushstrhl:      
1900				; push of string requires use of cli_origptr 
1900				; bodge use 
1900			 
1900				; get current cli_origptr, save, update with temp pointer  
1900 ed 5b c1 f9		ld de, (cli_origptr) 
1904 22 c1 f9			ld (cli_origptr), hl 
1907 d5				push de 
1908 cd a9 18			call forth_apush 
190b d1				pop de 
190c ed 53 c1 f9		ld (cli_origptr), de 
1910 c9			        ret	 
1911			 
1911			 
1911			; increase loop stack pointer and save hl to it 
1911				 
1911			FORTH_LOOP_NEXT: macro 
1911				call macro_forth_loop_next 
1911				;nop 
1911				endm 
1911			 
1911			macro_forth_loop_next: 
1911				if DEBUG_FORTH_STACK_GUARD 
1911 cd 67 4f				call check_stacks 
1914				endif 
1914 e5				push hl 
1915 d5				push de 
1916 eb				ex de,hl 
1917 2a a7 f9			ld hl,(cli_loop_sp) 
191a 23				inc hl 
191b 23				inc hl 
191c					if DEBUG_FORTH_WORDS 
191c						DMARK "LNX" 
191c						CALLMONITOR 
191c					endif 
191c 22 a7 f9			ld (cli_loop_sp),hl 
191f 73				ld (hl), e 
1920 23				inc hl 
1921 72				ld (hl), d 
1922 d1				pop de    ; been reversed so save a swap on restore 
1923 e1				pop hl 
1924				if DEBUG_FORTH_STACK_GUARD 
1924 cd 67 4f				call check_stacks 
1927				endif 
1927 c9				ret 
1928			 
1928			; get current ret stack pointer and save to hl  
1928				 
1928			FORTH_LOOP_TOS: macro 
1928				call macro_forth_loop_tos 
1928				endm 
1928			 
1928			macro_forth_loop_tos: 
1928 d5				push de 
1929 2a a7 f9			ld hl,(cli_loop_sp) 
192c 5e				ld e, (hl) 
192d 23				inc hl 
192e 56				ld d, (hl) 
192f eb				ex de, hl 
1930 d1				pop de 
1931 c9				ret 
1932			 
1932			; pop loop stack pointer 
1932				 
1932			FORTH_LOOP_POP: macro 
1932				call macro_forth_loop_pop 
1932				endm 
1932			 
1932			 
1932			macro_forth_loop_pop: 
1932				if DEBUG_FORTH_STACK_GUARD 
1932					DMARK "LPP" 
1932 f5				push af  
1933 3a 47 19			ld a, (.dmark)  
1936 32 bd fb			ld (debug_mark),a  
1939 3a 48 19			ld a, (.dmark+1)  
193c 32 be fb			ld (debug_mark+1),a  
193f 3a 49 19			ld a, (.dmark+2)  
1942 32 bf fb			ld (debug_mark+2),a  
1945 18 03			jr .pastdmark  
1947 ..			.dmark: db "LPP"  
194a f1			.pastdmark: pop af  
194b			endm  
# End of macro DMARK
194b cd 67 4f				call check_stacks 
194e					FORTH_CHK_LOOP_UNDER 
194e e5				push hl 
194f d5				push de 
1950 2a a7 f9			ld hl,(cli_loop_sp) 
1953 11 21 f7			ld de, cli_loop_stack 
1956 cd 31 0b			call cmp16 
1959 da 81 50			jp c, fault_loop_under 
195c d1				pop de 
195d e1				pop hl 
195e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
195e				endif 
195e e5				push hl 
195f 2a a7 f9			ld hl,(cli_loop_sp) 
1962 2b				dec hl 
1963 2b				dec hl 
1964 22 a7 f9			ld (cli_loop_sp), hl 
1967				; TODO do stack underflow checks 
1967 e1				pop hl 
1968				if DEBUG_FORTH_STACK_GUARD 
1968 cd 67 4f				call check_stacks 
196b					FORTH_CHK_LOOP_UNDER 
196b e5				push hl 
196c d5				push de 
196d 2a a7 f9			ld hl,(cli_loop_sp) 
1970 11 21 f7			ld de, cli_loop_stack 
1973 cd 31 0b			call cmp16 
1976 da 81 50			jp c, fault_loop_under 
1979 d1				pop de 
197a e1				pop hl 
197b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
197b				endif 
197b c9				ret 
197c			 
197c			macro_forth_dsp_pop: 
197c			 
197c e5				push hl 
197d			 
197d				; release malloc data 
197d			 
197d				if DEBUG_FORTH_STACK_GUARD 
197d cd 67 4f				call check_stacks 
1980					FORTH_CHK_DSP_UNDER 
1980 e5				push hl 
1981 d5				push de 
1982 2a a5 f9			ld hl,(cli_data_sp) 
1985 11 1f f5			ld de, cli_data_stack 
1988 cd 31 0b			call cmp16 
198b da 75 50			jp c, fault_dsp_under 
198e d1				pop de 
198f e1				pop hl 
1990				endm 
# End of macro FORTH_CHK_DSP_UNDER
1990				endif 
1990				;ld hl,(cli_data_sp) 
1990			if DEBUG_FORTH_DOT 
1990				DMARK "DPP" 
1990				CALLMONITOR 
1990			endif	 
1990			 
1990			 
1990			if FORTH_ENABLE_DSPPOPFREE 
1990			 
1990				FORTH_DSP 
1990 cd e1 18			call macro_forth_dsp 
1993				endm 
# End of macro FORTH_DSP
1993			 
1993 7e				ld a, (hl) 
1994 fe 01			cp DS_TYPE_STR 
1996 20 07			jr nz, .skippopfree 
1998			 
1998				FORTH_DSP_VALUEHL 
1998 cd fc 18			call macro_dsp_valuehl 
199b				endm 
# End of macro FORTH_DSP_VALUEHL
199b 00				nop 
199c			if DEBUG_FORTH_DOT 
199c				DMARK "DPf" 
199c				CALLMONITOR 
199c			endif	 
199c cd a4 10			call free 
199f			.skippopfree: 
199f				 
199f			 
199f			endif 
199f			 
199f			if DEBUG_FORTH_DOT_KEY 
199f				DMARK "DP2" 
199f				CALLMONITOR 
199f			endif	 
199f			 
199f				; move pointer down 
199f			 
199f 2a a5 f9			ld hl,(cli_data_sp) 
19a2 2b				dec hl 
19a3 2b				dec hl 
19a4			; PARSEV5 
19a4 2b				dec hl 
19a5 22 a5 f9			ld (cli_data_sp), hl 
19a8			 
19a8				if DEBUG_FORTH_STACK_GUARD 
19a8 cd 67 4f				call check_stacks 
19ab					FORTH_CHK_DSP_UNDER 
19ab e5				push hl 
19ac d5				push de 
19ad 2a a5 f9			ld hl,(cli_data_sp) 
19b0 11 1f f5			ld de, cli_data_stack 
19b3 cd 31 0b			call cmp16 
19b6 da 75 50			jp c, fault_dsp_under 
19b9 d1				pop de 
19ba e1				pop hl 
19bb				endm 
# End of macro FORTH_CHK_DSP_UNDER
19bb				endif 
19bb			 
19bb e1				pop hl 
19bc			 
19bc c9				ret 
19bd			 
19bd			getwordathl: 
19bd				; hl points to an address 
19bd				; load hl with the word at that address 
19bd			 
19bd d5				push de 
19be			 
19be 5e				ld e, (hl) 
19bf 23				inc hl 
19c0 56				ld d, (hl) 
19c1 eb				ex de, hl 
19c2			 
19c2 d1				pop de 
19c3 c9				ret 
19c4			 
19c4			 
19c4			 
19c4			 
19c4			 
19c4			; eof 
19c4			 
# End of file forth_stackopsv5.asm
19c4			endif 
19c4			 
19c4			user_word_eol:  
19c4				; hl contains the pointer to where to create a linked list item from the end 
19c4				; of the user dict to continue on at the system word dict 
19c4				 
19c4				; poke the stub of the word list linked list to repoint to rom words 
19c4			 
19c4				; stub format 
19c4				; db   word id 
19c4				; dw    link to next word 
19c4			        ; db char length of token 
19c4				; db string + 0 term 
19c4				; db exec code....  
19c4			 
19c4 3e 00			ld a, WORD_SYS_ROOT     ; root word 
19c6 77				ld (hl), a		; word id 
19c7 23				inc hl 
19c8			 
19c8 11 8e 1b			ld de, sysdict 
19cb 73				ld (hl), e		; next word link ie system dict 
19cc 23				inc hl 
19cd 72				ld (hl), d		; next word link ie system dict 
19ce 23				inc hl	 
19cf			 
19cf			;	ld (hl), sysdict		; next word link ie system dict 
19cf			;	inc hl 
19cf			;	inc hl 
19cf			 
19cf			;	inc hl 
19cf			;	inc hl 
19cf			 
19cf 3e 02			ld a, 2			; word length is 0 
19d1 77				ld (hl), a	 
19d2 23				inc hl 
19d3			 
19d3 3e 7e			ld a, '~'			; word length is 0 
19d5 77				ld (hl), a	 
19d6 23				inc hl 
19d7 3e 00			ld a, 0			; save empty word 
19d9 77				ld (hl), a 
19da			 
19da c9				ret 
19db			 
19db				 
19db			 
19db			forthexec_cleanup: 
19db				FORTH_RSP_POP 
19db cd 29 18			call macro_forth_rsp_pop 
19de				endm 
# End of macro FORTH_RSP_POP
19de c9				ret 
19df			 
19df			forth_call_hl: 
19df				; taking hl 
19df e5				push hl 
19e0 c9				ret 
19e1			 
19e1			; this is called to reset Forth system but keep existing uwords etc 
19e1			 
19e1			forth_warmstart: 
19e1				; setup stack over/under flow checks 
19e1				if DEBUG_FORTH_STACK_GUARD 
19e1 cd 4d 4f				call chk_stk_init 
19e4				endif 
19e4			 
19e4				; init stack pointers  - * these stacks go upwards *  
19e4 21 23 f9			ld hl, cli_ret_stack 
19e7 22 a9 f9			ld (cli_ret_sp), hl	 
19ea				; set bottom of stack 
19ea 3e 00			ld a,0 
19ec 77				ld (hl),a 
19ed 23				inc hl 
19ee 77				ld (hl),a 
19ef			 
19ef 21 1f f5			ld hl, cli_data_stack 
19f2 22 a5 f9			ld (cli_data_sp), hl	 
19f5				; set bottom of stack 
19f5 3e 00			ld a,0 
19f7 77				ld (hl),a 
19f8 23				inc hl 
19f9 77				ld (hl),a 
19fa			 
19fa 21 21 f7			ld hl, cli_loop_stack 
19fd 22 a7 f9			ld (cli_loop_sp), hl	 
1a00				; set bottom of stack 
1a00 3e 00			ld a,0 
1a02 77				ld (hl),a 
1a03 23				inc hl 
1a04 77				ld (hl),a 
1a05			 
1a05				; init extent of current open file 
1a05			 
1a05 3e 00			ld a, 0 
1a07 32 df f9			ld (store_openext), a 
1a0a			 
1a0a c9				ret 
1a0b			 
1a0b			 
1a0b			; Cold Start - this is called to setup the whole Forth system 
1a0b			 
1a0b			forth_init: 
1a0b			 
1a0b				; setup stack over/under flow checks 
1a0b			 
1a0b			;	if DEBUG_FORTH_STACK_GUARD 
1a0b			;		call chk_stk_init 
1a0b			;	endif 
1a0b			 
1a0b				; enable auto display updates (slow.....) 
1a0b			 
1a0b 3e 01			ld a, 1 
1a0d 32 bf f9			ld (cli_autodisplay), a 
1a10			 
1a10			 
1a10			 
1a10				; show start up screen 
1a10			 
1a10 cd ba 09			call clear_display 
1a13			 
1a13 3e 00			ld a,0 
1a15 32 e1 f9			ld (f_cursor_ptr), a 
1a18			 
1a18				; set start of word list in start of ram - for use when creating user words 
1a18			 
1a18 21 00 80			ld hl, baseram 
1a1b 22 b5 f2			ld (os_last_new_uword), hl 
1a1e cd c4 19			call user_word_eol 
1a21				 
1a21			;		call display_data_sp 
1a21			;		call next_page_prompt 
1a21			 
1a21			 
1a21			 
1a21			 
1a21 c9				ret 
1a22			 
1a22 .. 00		.bootforth: db " Forth Kernel Init ",0 
1a36			 
1a36			; TODO push to stack 
1a36			 
1a36			;  
1a36			 
1a36			if FORTH_PARSEV2 
1a36			 
1a36			 
1a36				include "forth_parserv2.asm" 
1a36			 
1a36			endif 
1a36			 
1a36			 
1a36			; parse cli version 1 
1a36			 
1a36			if FORTH_PARSEV1 
1a36			 
1a36			 
1a36			 
1a36			      include "forth_parserv1.asm" 
1a36			endif 
1a36				 
1a36			if FORTH_PARSEV3 
1a36			 
1a36			 
1a36			 
1a36			      include "forth_parserv3.asm" 
1a36				include "forth_wordsv3.asm" 
1a36			endif 
1a36			 
1a36			if FORTH_PARSEV4 
1a36			 
1a36			 
1a36			 
1a36			      include "forth_parserv4.asm" 
1a36				include "forth_wordsv4.asm" 
1a36			endif 
1a36			 
1a36			if FORTH_PARSEV5 
1a36			 
1a36			 
1a36			 
1a36			      include "forth_parserv5.asm" 
1a36			 
1a36			 
1a36			; A better parser without using malloc and string copies all over the place.  
1a36			; Exec in situ should be faster 
1a36			 
1a36			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1a36			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1a36			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1a36			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1a36			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1a36			WORD_SYS_END: equ 0   ; Opcode for all user words 
1a36			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1a36			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1a36			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1a36			 
1a36			; Core word preamble macro 
1a36			 
1a36			CWHEAD:   macro nxtword opcode lit len opflags 
1a36				db WORD_SYS_CORE+opcode             
1a36				; internal op code number 
1a36				dw nxtword            
1a36				; link to next dict word block 
1a36				db len + 1 
1a36				; literal length of dict word inc zero term 
1a36				db lit,0              
1a36				; literal dict word 
1a36			        ; TODO db opflags        
1a36				endm 
1a36			 
1a36			 
1a36			NEXTW: macro  
1a36				jp macro_next 
1a36				endm 
1a36			 
1a36			macro_next: 
1a36			if DEBUG_FORTH_PARSE_KEY 
1a36				DMARK "NXT" 
1a36				CALLMONITOR 
1a36			endif	 
1a36			;	inc hl  ; skip token null term  
1a36 ed 4b c3 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1a3a ed 5b c1 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1a3e 2a b9 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1a41			if DEBUG_FORTH_PARSE_KEY 
1a41				DMARK "}AA" 
1a41				CALLMONITOR 
1a41			endif	 
1a41 c3 44 1b			jp execnext 
1a44				;jp exec1 
1a44			       
1a44			 
1a44			 
1a44			; Another go at the parser to compile  
1a44			 
1a44			 
1a44			; TODO rework parser to change all of the string words to byte tokens 
1a44			; TODO do a search for  
1a44			 
1a44			; TODO first run normal parser to zero term sections 
1a44			; TODO for each word do a token look up to get the op code 
1a44			; TODO need some means to flag to the exec that this is a byte code form    
1a44			 
1a44			 
1a44			forthcompile: 
1a44			 
1a44			; 
1a44			; line parse: 
1a44			;       parse raw input buffer 
1a44			;       tokenise the words 
1a44			;       malloc new copy (for looping etc) 
1a44			;       copy to malloc + current pc in line to start of string and add line term 
1a44			;       save on new rsp 
1a44			; 
1a44			 
1a44			; hl to point to the line to tokenise 
1a44			 
1a44			;	push hl 
1a44 22 b9 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1a47			 
1a47			;	ld a,0		; string term on input 
1a47			;	call strlent 
1a47			 
1a47			;	ld (os_tok_len), hl	 ; save string length 
1a47			 
1a47			;if DEBUG_FORTH_TOK 
1a47			;	ex de,hl		 
1a47			;endif 
1a47			 
1a47			;	pop hl 		; get back string pointer 
1a47			 
1a47			if DEBUG_FORTH_TOK 
1a47						DMARK "TOc" 
1a47				CALLMONITOR 
1a47			endif 
1a47 7e			.cptoken2:    ld a,(hl) 
1a48 23				inc hl 
1a49 fe 7f			cp FORTH_END_BUFFER 
1a4b 28 29			jr z, .cptokendone2 
1a4d fe 00			cp 0 
1a4f 28 25			jr z, .cptokendone2 
1a51 fe 22			cp '"' 
1a53 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1a55 fe 20			cp ' ' 
1a57 20 ee			jr nz,  .cptoken2 
1a59			 
1a59			; TODO consume comments held between ( and ) 
1a59			 
1a59				; we have a space so change to zero term for dict match later 
1a59 2b				dec hl 
1a5a 3e 00			ld a,0 
1a5c 77				ld (hl), a 
1a5d 23				inc hl 
1a5e 18 e7			jr .cptoken2 
1a60				 
1a60			 
1a60			.cptokenstr2: 
1a60				; skip all white space until either eol (because forgot to term) or end double quote 
1a60			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1a60				;inc hl ; skip current double quote 
1a60 7e				ld a,(hl) 
1a61 23				inc hl 
1a62 fe 22			cp '"' 
1a64 28 e1			jr z, .cptoken2 
1a66 fe 7f			cp FORTH_END_BUFFER 
1a68 28 0c			jr z, .cptokendone2 
1a6a fe 00			cp 0 
1a6c 28 08			jr z, .cptokendone2 
1a6e fe 20			cp ' ' 
1a70 28 02			jr z, .cptmp2 
1a72 18 ec			jr .cptokenstr2 
1a74			 
1a74			.cptmp2:	; we have a space so change to zero term for dict match later 
1a74				;dec hl 
1a74				;ld a,"-"	; TODO remove this when working 
1a74				;ld (hl), a 
1a74				;inc hl 
1a74 18 ea			jr .cptokenstr2 
1a76			 
1a76			.cptokendone2: 
1a76				;inc hl 
1a76 3e 7f			ld a, FORTH_END_BUFFER 
1a78 77				ld (hl),a 
1a79 23				inc hl 
1a7a 3e 21			ld a, '!' 
1a7c 77				ld (hl),a 
1a7d			 
1a7d 2a b9 f2			ld hl,(os_tok_ptr) 
1a80			         
1a80			if DEBUG_FORTH_TOK 
1a80						DMARK "Tc1" 
1a80				CALLMONITOR 
1a80			endif 
1a80			 
1a80				; push exec string to top of return stack 
1a80				FORTH_RSP_NEXT 
1a80 cd 0b 18			call macro_forth_rsp_next 
1a83				endm 
# End of macro FORTH_RSP_NEXT
1a83 c9				ret 
1a84			 
1a84			; Another go at the parser need to simplify the process 
1a84			 
1a84			forthparse: 
1a84			 
1a84			; 
1a84			; line parse: 
1a84			;       parse raw input buffer 
1a84			;       tokenise the words 
1a84			;       malloc new copy (for looping etc) 
1a84			;       copy to malloc + current pc in line to start of string and add line term 
1a84			;       save on new rsp 
1a84			; 
1a84			 
1a84			; hl to point to the line to tokenise 
1a84			 
1a84			;	push hl 
1a84 22 b9 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1a87			 
1a87			;	ld a,0		; string term on input 
1a87			;	call strlent 
1a87			 
1a87			;	ld (os_tok_len), hl	 ; save string length 
1a87			 
1a87			;if DEBUG_FORTH_TOK 
1a87			;	ex de,hl		 
1a87			;endif 
1a87			 
1a87			;	pop hl 		; get back string pointer 
1a87			 
1a87			if DEBUG_FORTH_TOK 
1a87						DMARK "TOK" 
1a87				CALLMONITOR 
1a87			endif 
1a87 7e			.ptoken2:    ld a,(hl) 
1a88 23				inc hl 
1a89 fe 7f			cp FORTH_END_BUFFER 
1a8b 28 29			jr z, .ptokendone2 
1a8d fe 00			cp 0 
1a8f 28 25			jr z, .ptokendone2 
1a91 fe 22			cp '"' 
1a93 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1a95 fe 20			cp ' ' 
1a97 20 ee			jr nz,  .ptoken2 
1a99			 
1a99			; TODO consume comments held between ( and ) 
1a99			 
1a99				; we have a space so change to zero term for dict match later 
1a99 2b				dec hl 
1a9a 3e 00			ld a,0 
1a9c 77				ld (hl), a 
1a9d 23				inc hl 
1a9e 18 e7			jr .ptoken2 
1aa0				 
1aa0			 
1aa0			.ptokenstr2: 
1aa0				; skip all white space until either eol (because forgot to term) or end double quote 
1aa0			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1aa0				;inc hl ; skip current double quote 
1aa0 7e				ld a,(hl) 
1aa1 23				inc hl 
1aa2 fe 22			cp '"' 
1aa4 28 e1			jr z, .ptoken2 
1aa6 fe 7f			cp FORTH_END_BUFFER 
1aa8 28 0c			jr z, .ptokendone2 
1aaa fe 00			cp 0 
1aac 28 08			jr z, .ptokendone2 
1aae fe 20			cp ' ' 
1ab0 28 02			jr z, .ptmp2 
1ab2 18 ec			jr .ptokenstr2 
1ab4			 
1ab4			.ptmp2:	; we have a space so change to zero term for dict match later 
1ab4				;dec hl 
1ab4				;ld a,"-"	; TODO remove this when working 
1ab4				;ld (hl), a 
1ab4				;inc hl 
1ab4 18 ea			jr .ptokenstr2 
1ab6			 
1ab6			.ptokendone2: 
1ab6				;inc hl 
1ab6 3e 7f			ld a, FORTH_END_BUFFER 
1ab8 77				ld (hl),a 
1ab9 23				inc hl 
1aba 3e 21			ld a, '!' 
1abc 77				ld (hl),a 
1abd			 
1abd 2a b9 f2			ld hl,(os_tok_ptr) 
1ac0			         
1ac0			if DEBUG_FORTH_TOK 
1ac0						DMARK "TK1" 
1ac0				CALLMONITOR 
1ac0			endif 
1ac0			 
1ac0				; push exec string to top of return stack 
1ac0				FORTH_RSP_NEXT 
1ac0 cd 0b 18			call macro_forth_rsp_next 
1ac3				endm 
# End of macro FORTH_RSP_NEXT
1ac3 c9				ret 
1ac4			 
1ac4			; 
1ac4			;	; malloc size + buffer pointer + if is loop flag 
1ac4			;	ld hl,(os_tok_len) 		 ; get string length 
1ac4			; 
1ac4			;	ld a,l 
1ac4			; 
1ac4			;	cp 0			; we dont want to use a null string 
1ac4			;	ret z 
1ac4			; 
1ac4			;;	add 3    ; prefix malloc with buffer for current word ptr 
1ac4			; 
1ac4			;	add 5     ; TODO when certain not over writing memory remove 
1ac4			; 
1ac4			;		 
1ac4			; 
1ac4			;if DEBUG_FORTH_TOK 
1ac4			;			DMARK "TKE" 
1ac4			;	CALLMONITOR 
1ac4			;endif 
1ac4			; 
1ac4			;	ld l,a 
1ac4			;	ld h,0 
1ac4			;;	push hl   ; save required space for the copy later 
1ac4			;	call malloc 
1ac4			;if DEBUG_FORTH_TOK 
1ac4			;			DMARK "TKM" 
1ac4			;	CALLMONITOR 
1ac4			;endif 
1ac4			;	if DEBUG_FORTH_MALLOC_GUARD 
1ac4			;		push af 
1ac4			;		call ishlzero 
1ac4			;;		ld a, l 
1ac4			;;		add h 
1ac4			;;		cp 0 
1ac4			;		pop af 
1ac4			;		 
1ac4			;		call z,malloc_error 
1ac4			;	endif 
1ac4			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1ac4			; 
1ac4			; 
1ac4			;if DEBUG_FORTH_TOK 
1ac4			;			DMARK "TKR" 
1ac4			;	CALLMONITOR 
1ac4			;endif 
1ac4			; 
1ac4			;	FORTH_RSP_NEXT 
1ac4			; 
1ac4			;	;inc hl	 ; go past current buffer pointer 
1ac4			;	;inc hl 
1ac4			;	;inc hl   ; and past if loop flag 
1ac4			;		; TODO Need to set flag  
1ac4			; 
1ac4			;	 
1ac4			;	 
1ac4			;	ex de,hl	; malloc is dest 
1ac4			;	ld hl, (os_tok_len) 
1ac4			;;	pop bc 
1ac4			;	ld c, l                
1ac4			;	ld b,0 
1ac4			;	ld hl, (os_tok_ptr) 
1ac4			; 
1ac4			;if DEBUG_FORTH_TOK 
1ac4			;			DMARK "TKT" 
1ac4			;	CALLMONITOR 
1ac4			;endif 
1ac4			; 
1ac4			;	; do str cpy 
1ac4			; 
1ac4			;	ldir      ; copy byte in hl to de 
1ac4			; 
1ac4			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1ac4			; 
1ac4			;if DEBUG_FORTH_TOK 
1ac4			; 
1ac4			;			DMARK "TKY" 
1ac4			;	CALLMONITOR 
1ac4			;endif 
1ac4			;	;ld a,0 
1ac4			;	;ld a,FORTH_END_BUFFER 
1ac4			;	ex de, hl 
1ac4			;	;dec hl			 ; go back over the space delim at the end of word 
1ac4			;	;ld (hl),a 
1ac4			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1ac4			;	ld a,FORTH_END_BUFFER 
1ac4			;	ld (hl),a 
1ac4			;	inc hl 
1ac4			;	ld a,FORTH_END_BUFFER 
1ac4			;	ld (hl),a 
1ac4			; 
1ac4			;	; init the malloc area data 
1ac4			;	; set pc for in current area 
1ac4			;	;ld hl, (os_tok_malloc) 
1ac4			;	;inc hl 
1ac4			;	;inc hl 
1ac4			;	;inc hl 
1ac4			;	;ex de,hl 
1ac4			;	;ld hl, (os_tok_malloc) 
1ac4			;	;ld (hl),e 
1ac4			;	;inc hl 
1ac4			;	;ld (hl),d 
1ac4			; 
1ac4			; 
1ac4			;	ld hl,(os_tok_malloc) 
1ac4			;if DEBUG_FORTH_PARSE_KEY 
1ac4			;			DMARK "TKU" 
1ac4			;	CALLMONITOR 
1ac4			;endif 
1ac4			; 
1ac4			;	ret 
1ac4			 
1ac4			forthexec: 
1ac4			 
1ac4			; line exec: 
1ac4			; forth parser 
1ac4			 
1ac4			; 
1ac4			;       get current exec line on rsp 
1ac4			 
1ac4				FORTH_RSP_TOS 
1ac4 cd 22 18			call macro_forth_rsp_tos 
1ac7				endm 
# End of macro FORTH_RSP_TOS
1ac7			 
1ac7			;       restore current pc - hl points to malloc of data 
1ac7			 
1ac7				;ld e, (hl) 
1ac7				;inc hl 
1ac7				;ld d, (hl) 
1ac7				;ex de,hl 
1ac7			 
1ac7			 
1ac7			exec1: 
1ac7 22 b9 f2			ld (os_tok_ptr), hl 
1aca			 
1aca				; copy our PC to working vars  
1aca 22 c3 f9			ld (cli_ptr), hl 
1acd 22 c1 f9			ld (cli_origptr), hl 
1ad0			 
1ad0 7e				ld a,(hl) 
1ad1 fe 7f			cp FORTH_END_BUFFER 
1ad3 c8				ret z 
1ad4			 
1ad4				; skip any nulls 
1ad4			 
1ad4 fe 00			cp 0 
1ad6 20 03			jr nz, .execword 
1ad8 23				inc hl 
1ad9 18 ec			jr exec1 
1adb			 
1adb			 
1adb			.execword: 
1adb			 
1adb			 
1adb			 
1adb			if DEBUG_FORTH_PARSE_KEY 
1adb						DMARK "KYQ" 
1adb				CALLMONITOR 
1adb			endif 
1adb			;       while at start of word: 
1adb			; get start of dict (in user area first) 
1adb			 
1adb 21 00 80		ld hl, baseram 
1ade			;ld hl, sysdict 
1ade 22 c5 f9		ld (cli_nextword),hl 
1ae1			;           match word at pc 
1ae1			;           exec word 
1ae1			;           or push to dsp 
1ae1			;           forward to next token 
1ae1			;           if line term pop rsp and exit 
1ae1			;        
1ae1			 
1ae1			if DEBUG_FORTH_PARSE_KEY 
1ae1						DMARK "KYq" 
1ae1				CALLMONITOR 
1ae1			endif 
1ae1			 
1ae1			; 
1ae1			; word comp 
1ae1			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1ae1			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1ae1			;    move to start of word  
1ae1			;    compare word to cli_token 
1ae1			 
1ae1			.execpnword:	; HL at start of a word in the dictionary to check 
1ae1			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1ae1			;	ld (cli_ptr), hl 
1ae1			 
1ae1 2a c5 f9			ld hl,(cli_nextword) 
1ae4			 
1ae4 cd 87 1b			call forth_tok_next 
1ae7			; tok next start here 
1ae7			;	; TODO skip compiled symbol for now 
1ae7			;	inc hl 
1ae7			; 
1ae7			;	; save pointer to next word 
1ae7			; 
1ae7			;	; hl now points to the address of the next word pointer  
1ae7			;	ld e, (hl) 
1ae7			;	inc hl 
1ae7			;	ld d, (hl) 
1ae7			;	inc l 
1ae7			; 
1ae7			;	ex de,hl 
1ae7			;if DEBUG_FORTH_PARSE_NEXTWORD 
1ae7			;	push bc 
1ae7			;	ld bc, (cli_nextword) 
1ae7			;			DMARK "NXW" 
1ae7			;	CALLMONITOR 
1ae7			;	pop bc 
1ae7			;endif 
1ae7			; tok next end here 
1ae7 22 c5 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
1aea eb				ex de, hl 
1aeb			 
1aeb			 
1aeb				; save the pointer of the current token - 1 to check against 
1aeb				 
1aeb 22 c9 f9			ld (cli_token), hl   
1aee				; TODO maybe remove below save if no debug 
1aee				; save token string ptr for any debug later 
1aee 23				inc hl  
1aef 22 cb f9			ld (cli_origtoken), hl 
1af2 2b				dec hl 
1af3				; save pointer to the start of the next dictionay word 
1af3 7e				ld a,(hl)   ; get string length 
1af4 47				ld b,a 
1af5			.execpnwordinc:  
1af5 23				inc hl 
1af6 10 fd			djnz .execpnwordinc 
1af8 22 c7 f9			ld (cli_execword), hl      ; save start of this words code 
1afb			 
1afb				; now check the word token against the string being parsed 
1afb			 
1afb 2a c9 f9			ld hl,(cli_token) 
1afe 23				inc hl     ; skip string length (use zero term instead to end) 
1aff 22 c9 f9			ld (cli_token), hl 
1b02			 
1b02			if DEBUG_FORTH_PARSE_KEY 
1b02						DMARK "KY2" 
1b02			endif 
1b02			if DEBUG_FORTH_PARSE_EXEC 
1b02				; see if disabled 
1b02			 
1b02				ld a, (os_view_disable) 
1b02				cp '*' 
1b02				jr z, .skip 
1b02			 
1b02				push hl 
1b02				push hl 
1b02				call clear_display 
1b02				ld de, .compword 
1b02				ld a, display_row_1 
1b02				call str_at_display 
1b02				pop de 
1b02				ld a, display_row_2 
1b02				call str_at_display 
1b02				ld hl,(cli_ptr) 
1b02				ld a,(hl) 
1b02			        ld hl, os_word_scratch 
1b02				ld (hl),a 
1b02				ld a,0 
1b02				inc hl 
1b02				ld (hl),a 	 
1b02				ld de, os_word_scratch 
1b02				ld a, display_row_2+10 
1b02				call str_at_display 
1b02				call update_display 
1b02				ld a, 100 
1b02				call aDelayInMS 
1b02				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1b02				call delay250ms 
1b02				endif 
1b02				pop hl 
1b02			.skip:  
1b02			endif	 
1b02			.execpnchar:    ; compare char between token and string to parse 
1b02			 
1b02			if DEBUG_FORTH_PARSE_KEY 
1b02						DMARK "Ky3" 
1b02			endif 
1b02			if DEBUG_FORTH_PARSE_EXEC 
1b02				; see if disabled 
1b02			 
1b02				ld a, (os_view_disable) 
1b02				cp '*' 
1b02				jr z, .skip2 
1b02			 
1b02			;	call clear_display 
1b02			ld hl,(cli_token) 
1b02			ld a,(hl) 
1b02			ld (os_word_scratch),a 
1b02				ld hl,(cli_ptr) 
1b02			ld a,(hl) 
1b02				ld (os_word_scratch+1),a 
1b02				ld a,0 
1b02				ld (os_word_scratch+2),a 
1b02				ld de,os_word_scratch 
1b02				ld a,display_row_4 
1b02				call str_at_display 
1b02				call update_display 
1b02			.skip2:  
1b02			endif 
1b02 2a c9 f9			ld hl,(cli_token) 
1b05 7e				ld a, (hl)	 ; char in word token 
1b06 23				inc hl 		; move to next char 
1b07 22 c9 f9			ld (cli_token), hl ; and save it 
1b0a 47				ld b,a 
1b0b			 
1b0b 2a c3 f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
1b0e 7e				ld a,(hl) 
1b0f 23				inc hl 
1b10 22 c3 f9			ld (cli_ptr), hl		; move to next char 
1b13 cd 68 0f			call toUpper 		; make sure the input string matches case 
1b16			 
1b16			if DEBUG_FORTH_PARSE 
1b16			endif 
1b16			 
1b16				; input stream end of token is a space so get rid of it 
1b16			 
1b16			;	cp ' ' 
1b16			;	jr nz, .pnskipspace 
1b16			; 
1b16			;	ld a, 0		; make same term as word token term 
1b16			; 
1b16			;.pnskipspace: 
1b16			 
1b16			if DEBUG_FORTH_PARSE_KEY 
1b16						DMARK "KY7" 
1b16			endif 
1b16 b8				cp b 
1b17 c2 2d 1b			jp nz, .execpnskipword	 ; no match so move to next word 
1b1a				 
1b1a			;    if same 
1b1a			;       scan for string terms 0 for token and 32 for input 
1b1a			 
1b1a				 
1b1a			if DEBUG_FORTH_PARSE_KEY 
1b1a						DMARK "KY8" 
1b1a			endif 
1b1a			 
1b1a 80				add b			 
1b1b fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1b1d							; TODO need to make sure last word in zero term string is accounted for 
1b1d 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1b1f			 
1b1f			 
1b1f				; at end of both strings so both are exact match 
1b1f			 
1b1f			;       skip ptr for next word 
1b1f			 
1b1f 2a c3 f9			ld hl,(cli_ptr) 	; at input string term 
1b22 23				inc hl			 ; at next char 
1b23 22 c3 f9			ld (cli_ptr), hl     ; save for next round of the parser 
1b26 22 c1 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1b29				 
1b29				 
1b29			if DEBUG_FORTH_PARSE_KEY 
1b29						DMARK "KY3" 
1b29			endif 
1b29			 
1b29			 
1b29			 
1b29			;       exec code block 
1b29			if DEBUG_FORTH_JP 
1b29				call clear_display 
1b29				call update_display 
1b29				call delay1s 
1b29				ld hl, (cli_execword)     ; save for next check if no match on this word 
1b29				ld a,h 
1b29				ld hl, os_word_scratch 
1b29				call hexout 
1b29				ld hl, (cli_execword)     ; save for next check if no match on this word 
1b29				ld a,l 
1b29				ld hl, os_word_scratch+2 
1b29				call hexout 
1b29				ld hl, os_word_scratch+4 
1b29				ld a,0 
1b29				ld (hl),a 
1b29				ld de,os_word_scratch 
1b29				call str_at_display 
1b29					ld a, display_row_2 
1b29					call str_at_display 
1b29				ld de, (cli_origtoken) 
1b29				ld a, display_row_1+10 
1b29					call str_at_display 
1b29			 
1b29				ld a,display_row_1 
1b29				ld de, .foundword 
1b29				ld a, display_row_3 
1b29				call str_at_display 
1b29				call update_display 
1b29				call delay1s 
1b29				call delay1s 
1b29				call delay1s 
1b29			endif 
1b29			 
1b29			if DEBUG_FORTH_PARSE_KEY 
1b29						DMARK "KYj" 
1b29			endif 
1b29				; TODO save the word pointer in this exec 
1b29			 
1b29 2a c7 f9			ld hl,(cli_execword) 
1b2c e9				jp (hl) 
1b2d			 
1b2d			 
1b2d			;    if not same 
1b2d			;	scan for zero term 
1b2d			;	get ptr for next word 
1b2d			;	goto word comp 
1b2d			 
1b2d			.execpnskipword:	; get pointer to next word 
1b2d 2a c5 f9			ld hl,(cli_nextword) 
1b30			 
1b30 7e				ld a,(hl) 
1b31 fe 00			cp WORD_SYS_END 
1b33			;	cp 0 
1b33 28 09			jr z, .execendofdict			 ; at end of words 
1b35			 
1b35			if DEBUG_FORTH_PARSE_KEY 
1b35						DMARK "KY4" 
1b35			endif 
1b35			if DEBUG_FORTH_PARSE_EXEC 
1b35			 
1b35				; see if disabled 
1b35			 
1b35				ld a, (os_view_disable) 
1b35				cp '*' 
1b35				jr z, .noskip 
1b35			 
1b35			 
1b35				ld de, .nowordfound 
1b35				ld a, display_row_3 
1b35				call str_at_display 
1b35				call update_display 
1b35				ld a, 100 
1b35				call aDelayInMS 
1b35				 
1b35				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1b35					call delay250ms 
1b35				endif 
1b35			.noskip:  
1b35			 
1b35			endif	 
1b35			 
1b35 2a c1 f9			ld hl,(cli_origptr) 
1b38 22 c3 f9			ld (cli_ptr),hl 
1b3b			 
1b3b			if DEBUG_FORTH_PARSE_KEY 
1b3b						DMARK "KY5" 
1b3b			endif 
1b3b c3 e1 1a			jp .execpnword			; else go to next word 
1b3e			 
1b3e			.execendofdict:  
1b3e			 
1b3e			if DEBUG_FORTH_PARSE_KEY 
1b3e						DMARK "KYe" 
1b3e			endif 
1b3e			if DEBUG_FORTH_PARSE_EXEC 
1b3e				; see if disabled 
1b3e			 
1b3e				ld a, (os_view_disable) 
1b3e				cp '*' 
1b3e				jr z, .ispskip 
1b3e			 
1b3e				call clear_display 
1b3e				call update_display 
1b3e				call delay1s 
1b3e				ld de, (cli_origptr) 
1b3e				ld a, display_row_1 
1b3e				call str_at_display 
1b3e				 
1b3e				ld de, .enddict 
1b3e				ld a, display_row_3 
1b3e				call str_at_display 
1b3e				call update_display 
1b3e				ld a, 100 
1b3e				call aDelayInMS 
1b3e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1b3e				call delay1s 
1b3e				call delay1s 
1b3e				call delay1s 
1b3e				endif 
1b3e			.ispskip:  
1b3e				 
1b3e			endif	 
1b3e			 
1b3e			 
1b3e			 
1b3e				; if the word is not a keyword then must be a literal so push it to stack 
1b3e			 
1b3e			; push token to stack to end of word 
1b3e			 
1b3e				STACKFRAME ON $1efe $2f9f 
1b3e				if DEBUG_STACK_IMB 
1b3e					if ON 
1b3e						exx 
1b3e						ld de, $1efe 
1b3e						ld a, d 
1b3e						ld hl, curframe 
1b3e						call hexout 
1b3e						ld a, e 
1b3e						ld hl, curframe+2 
1b3e						call hexout 
1b3e						ld hl, $1efe 
1b3e						push hl 
1b3e						ld hl, $2f9f 
1b3e						push hl 
1b3e						exx 
1b3e					endif 
1b3e				endif 
1b3e			endm 
# End of macro STACKFRAME
1b3e			 
1b3e 2a b9 f2		ld hl,(os_tok_ptr) 
1b41 cd a9 18		call forth_apush 
1b44			 
1b44				STACKFRAMECHK ON $1efe $2f9f 
1b44				if DEBUG_STACK_IMB 
1b44					if ON 
1b44						exx 
1b44						ld hl, $2f9f 
1b44						pop de   ; $2f9f 
1b44						call cmp16 
1b44						jr nz, .spnosame 
1b44						ld hl, $1efe 
1b44						pop de   ; $1efe 
1b44						call cmp16 
1b44						jr z, .spfrsame 
1b44						.spnosame: call showsperror 
1b44						.spfrsame: nop 
1b44						exx 
1b44					endif 
1b44				endif 
1b44			endm 
# End of macro STACKFRAMECHK
1b44			 
1b44			execnext: 
1b44			 
1b44			if DEBUG_FORTH_PARSE_KEY 
1b44						DMARK "KY>" 
1b44			endif 
1b44			; move past token to next word 
1b44			 
1b44 2a b9 f2		ld hl, (os_tok_ptr) 
1b47 3e 00		ld a, 0 
1b49 01 ff 00		ld bc, 255     ; input buffer size 
1b4c ed b1		cpir 
1b4e			 
1b4e			if DEBUG_FORTH_PARSE_KEY 
1b4e						DMARK "KY!" 
1b4e				CALLMONITOR 
1b4e			endif	 
1b4e			; TODO this might place hl on the null, so will need to forward on??? 
1b4e			;inc hl   ; see if this gets onto the next item 
1b4e			 
1b4e			 
1b4e			; TODO pass a pointer to the buffer to push 
1b4e			; TODO call function to push 
1b4e			 
1b4e			; look for end of input 
1b4e			 
1b4e			;inc hl 
1b4e			;ld a,(hl) 
1b4e			;cp FORTH_END_BUFFER 
1b4e			;ret z 
1b4e			 
1b4e			 
1b4e c3 c7 1a		jp exec1 
1b51			 
1b51			 
1b51			 
1b51			 
1b51			 
1b51			 
1b51			 
1b51			 
1b51			 
1b51			findnexttok: 
1b51			 
1b51				; hl is pointer to move 
1b51				; de is the token to locate 
1b51			 
1b51					if DEBUG_FORTH 
1b51						DMARK "NTK" 
1b51						CALLMONITOR 
1b51					endif 
1b51 d5				push de 
1b52			 
1b52			.fnt1:	 
1b52				; find first char of token to locate 
1b52			 
1b52 1a				ld a, (de) 
1b53 4f				ld c,a 
1b54 7e				ld a,(hl) 
1b55 cd 68 0f			call toUpper 
1b58					if DEBUG_FORTH 
1b58						DMARK "NT1" 
1b58						CALLMONITOR 
1b58					endif 
1b58 b9				cp c 
1b59			 
1b59 28 03			jr z, .fnt2cmpmorefirst	 
1b5b			 
1b5b				; first char not found move to next char 
1b5b			 
1b5b 23				inc hl 
1b5c 18 f4			jr .fnt1 
1b5e			 
1b5e			.fnt2cmpmorefirst:	 
1b5e				; first char of token found.  
1b5e			 
1b5e e5				push hl     ; save start of token just in case it is the right one 
1b5f d9				exx 
1b60 e1				pop hl        ; save it to hl' 
1b61 d9				exx 
1b62			 
1b62			 
1b62			.fnt2cmpmore:	 
1b62				; compare the rest 
1b62				 
1b62 23				inc hl 
1b63 13				inc de 
1b64				 
1b64 1a				ld a, (de) 
1b65 4f				ld c,a 
1b66 7e				ld a,(hl) 
1b67 cd 68 0f			call toUpper 
1b6a			 
1b6a					if DEBUG_FORTH 
1b6a						DMARK "NT2" 
1b6a						CALLMONITOR 
1b6a					endif 
1b6a				; c has the token to find char 
1b6a				; a has the mem to scan char 
1b6a			 
1b6a b9				cp c 
1b6b 28 04			jr z,.fntmatch1 
1b6d			 
1b6d				; they are not the same 
1b6d			 
1b6d					if DEBUG_FORTH 
1b6d						DMARK "NT3" 
1b6d						CALLMONITOR 
1b6d					endif 
1b6d d1				pop de	; reset de token to look for 
1b6e d5				push de 
1b6f 18 e1			jr .fnt1 
1b71				 
1b71			.fntmatch1: 
1b71			 
1b71				; is the same char a null which means we might have a full hit? 
1b71					if DEBUG_FORTH 
1b71						DMARK "NT4" 
1b71						CALLMONITOR 
1b71					endif 
1b71			 
1b71 fe 00			cp 0 
1b73 28 0b			jr z, .fntmatchyes 
1b75			 
1b75				; are we at the end of the token to find? 
1b75			 
1b75					if DEBUG_FORTH 
1b75						DMARK "NT5" 
1b75						CALLMONITOR 
1b75					endif 
1b75 3e 00			ld a, 0 
1b77 b9				cp c 
1b78			 
1b78 c2 62 1b			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1b7b			 
1b7b					if DEBUG_FORTH 
1b7b						DMARK "NT6" 
1b7b						CALLMONITOR 
1b7b					endif 
1b7b				; token to find is exhusted but no match to stream 
1b7b			 
1b7b				; restore tok pointer and continue on 
1b7b d1				pop de 
1b7c d5				push de 
1b7d c3 52 1b			jp .fnt1 
1b80			 
1b80			 
1b80			.fntmatchyes: 
1b80			 
1b80				; hl now contains the end of the found token 
1b80			 
1b80				; get rid of saved token pointer to find 
1b80			 
1b80 d1				pop de 
1b81			 
1b81					if DEBUG_FORTH 
1b81						DMARK "NT9" 
1b81						CALLMONITOR 
1b81					endif 
1b81			 
1b81				; hl will be on the null term so forward on 
1b81			 
1b81				; get back the saved start of the token 
1b81			 
1b81 d9				exx 
1b82 e5				push hl     ; save start of token just in case it is the right one 
1b83 d9				exx 
1b84 e1				pop hl        ; save it to hl 
1b85			 
1b85 c9				ret 
1b86			 
1b86			 
1b86			; LIST needs to find a specific token   
1b86			; FORGET needs to find a spefici token 
1b86			 
1b86			; SAVE needs to find all tokens by flag 
1b86			; WORDS just needs to scan through all  by flag 
1b86			; UWORDS needs to scan through all by flag 
1b86			 
1b86			 
1b86			; given hl as pointer to start of dict look up string 
1b86			; return hl as pointer to start of word block 
1b86			; or 0 if not found 
1b86			 
1b86			forth_find_tok: 
1b86 c9				ret 
1b87			 
1b87			; given hl as pointer to dict structure 
1b87			; move to the next dict block structure 
1b87			 
1b87			forth_tok_next: 
1b87				; hl now points to the address of the next word pointer  
1b87				; TODO skip compiled symbol for now 
1b87			;	push de 
1b87 23				inc hl 
1b88 5e				ld e, (hl) 
1b89 23				inc hl 
1b8a 56				ld d, (hl) 
1b8b 23				inc hl 
1b8c			 
1b8c eb				ex de,hl 
1b8d			if DEBUG_FORTH_PARSE_NEXTWORD 
1b8d				push bc 
1b8d				ld bc, (cli_nextword) 
1b8d						DMARK "NXW" 
1b8d				CALLMONITOR 
1b8d				pop bc 
1b8d			endif 
1b8d			;	pop de	 
1b8d c9				ret 
1b8e			 
1b8e			 
1b8e			 
1b8e			; eof 
# End of file forth_parserv5.asm
1b8e				include "forth_wordsv4.asm" 
1b8e			 
1b8e			; the core word dictionary v4 
1b8e			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1b8e			 
1b8e			; this is a linked list for each of the system words used 
1b8e			; user defined words will follow the same format but will be in ram 
1b8e			 
1b8e			 
1b8e			; 
1b8e			; 
1b8e			; define linked list: 
1b8e			; 
1b8e			; 1. compiled byte op code 
1b8e			; 2. len of text word 
1b8e			; 3. text word 
1b8e			; 4. ptr to next dictionary word 
1b8e			; 5. asm, calls etc for the word 
1b8e			; 
1b8e			;  if 1 == 0 then last word in dict  
1b8e			;   
1b8e			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1b8e			;  
1b8e			;  
1b8e			; create basic standard set of words 
1b8e			; 
1b8e			;  
1b8e			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1b8e			; 2DUP 2DROP 2SWAP  
1b8e			; @ C@ - get byte  
1b8e			; ! C! - store byte 
1b8e			; 0< true if less than zero 
1b8e			; 0= true if zero 
1b8e			; < >  
1b8e			; = true if same 
1b8e			; variables 
1b8e			 
1b8e			 
1b8e			; Hardware specific words I may need 
1b8e			; 
1b8e			; IN OUT  
1b8e			; calls to key util functions 
1b8e			; calls to hardward abstraction stuff 
1b8e			; easy control of frame buffers and lcd i/o 
1b8e			; keyboard  
1b8e			 
1b8e			 
1b8e			;DICT: macro 
1b8e			; op_code, len, word, next 
1b8e			;    word: 
1b8e			;    db op_code 
1b8e			;    ds word zero term 
1b8e			;    dw next 
1b8e			;    endm 
1b8e			 
1b8e			 
1b8e			 
1b8e			 
1b8e			; op code 1 is a flag for user define words which are to be handled differently 
1b8e			 
1b8e			 
1b8e			; 
1b8e			; 
1b8e			;    TODO on entry to a word this should be the expected environment 
1b8e			;    hl - tos value if number then held, if string this is the ptr 
1b8e			;    de -  
1b8e			 
1b8e			 
1b8e			; opcode ranges 
1b8e			; 0 - end of word dict 
1b8e			; 255 - user define words 
1b8e			 
1b8e			sysdict: 
1b8e			include "forth_opcodes.asm" 
1b8e			; op codes for forth keywords 
1b8e			; free to use code 0  
1b8e				OPCODE_HEAP: equ  1 
1b8e				OPCODE_EXEC: equ 2 
1b8e				OPCODE_DUP: equ 3 
1b8e				OPCODE_SWAP: equ 4 
1b8e				OPCODE_COLN: equ 5 
1b8e				OPCODE_SCOLN: equ 6 
1b8e				OPCODE_DROP: equ 7 
1b8e				OPCODE_DUP2: equ 8 
1b8e				OPCODE_DROP2: equ 9 
1b8e				OPCODE_SWAP2: equ 10 
1b8e				OPCODE_AT: equ 11 
1b8e				OPCODE_CAT: equ 12 
1b8e				OPCODE_BANG: equ 13 
1b8e				OPCODE_CBANG: equ 14 
1b8e				OPCODE_SCALL: equ 15 
1b8e				OPCODE_DEPTH: equ 16 
1b8e				OPCODE_OVER: equ 17 
1b8e				OPCODE_PAUSE: equ 18 
1b8e				OPCODE_PAUSES: equ 19 
1b8e				OPCODE_ROT: equ 20 
1b8e			;free to reuse	OPCODE_WORDS: equ 21 
1b8e			        OPCODE_NOT: equ 21 
1b8e				OPCODE_UWORDS: equ 22 
1b8e				OPCODE_BP: equ 23 
1b8e				OPCODE_MONITOR: equ 24  
1b8e				OPCODE_MALLOC: equ 25 
1b8e				OPCODE_FREE: equ 26 
1b8e				OPCODE_LIST: equ 27 
1b8e				OPCODE_FORGET: equ 28 
1b8e				OPCODE_NOP: equ 29 
1b8e				OPCODE_COMO: equ 30 
1b8e				OPCODE_COMC: equ 31 
1b8e			;free to reuse	OPCODE_ENDCORE: equ 32 
1b8e				OPCODE_AFTERSOUND: equ 33 
1b8e				OPCODE_GP2: equ 34 
1b8e				OPCODE_GP3: equ 35 
1b8e				OPCODE_GP4: equ 36 
1b8e				OPCODE_SIN: equ 37 
1b8e				OPCODE_SOUT: equ 38 
1b8e				OPCODE_SPIO: equ 39 
1b8e				OPCODE_SPICEH: equ 40 
1b8e				OPCODE_SPIOb: equ 41 
1b8e				OPCODE_SPII: equ 42 
1b8e				OPCODE_SESEL: equ 43 
1b8e				OPCODE_CARTDEV: equ 44 
1b8e			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1b8e				OPCODE_FB: equ 46 
1b8e				OPCODE_EMIT: equ 47 
1b8e				OPCODE_DOTH: equ 48 
1b8e				OPCODE_DOTF: equ 49 
1b8e				OPCODE_DOT: equ 50 
1b8e				OPCODE_CLS: equ 51 
1b8e				OPCODE_DRAW: equ 52 
1b8e				OPCODE_DUMP: equ 53 
1b8e				OPCODE_CDUMP: equ 54 
1b8e				OPCODE_DAT: equ 55 
1b8e				OPCODE_HOME: equ 56 
1b8e				OPCODE_SPACE: equ 57 
1b8e				OPCODE_SPACES: equ 58 
1b8e				OPCODE_SCROLL: equ 59 
1b8e				OPCODE_ATQ: equ 60 
1b8e				OPCODE_AUTODSP: equ 61 
1b8e				OPCODE_MENU: equ 62 
1b8e			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1b8e				OPCODE_THEN: equ 64 
1b8e				OPCODE_ELSE: equ 65 
1b8e				OPCODE_DO: equ 66 
1b8e				OPCODE_LOOP: equ 67 
1b8e				OPCODE_I: equ 68 
1b8e				OPCODE_DLOOP: equ 69  
1b8e				OPCODE_REPEAT: equ 70  
1b8e				OPCODE_UNTIL: equ 71 
1b8e				OPCODE_ENDFLOW: equ 72 
1b8e				OPCODE_WAITK: equ 73 
1b8e				OPCODE_ACCEPT: equ 74 
1b8e				OPCODE_EDIT: equ 75 
1b8e			;free to reuse	OPCODE_ENDKEY: equ 76 
1b8e				OPCODE_LZERO: equ 77 
1b8e				OPCODE_TZERO: equ 78 
1b8e				OPCODE_LESS: equ 79 
1b8e				OPCODE_GT: equ 80 
1b8e				OPCODE_EQUAL: equ 81  
1b8e			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1b8e				OPCODE_NEG: equ 83 
1b8e				OPCODE_DIV: equ 84 
1b8e				OPCODE_MUL: equ 85 
1b8e				OPCODE_MIN: equ 86 
1b8e				OPCODE_MAX: equ 87 
1b8e				OPCODE_RND16: equ 88 
1b8e				OPCODE_RND8: equ 89 
1b8e				OPCODE_RND: equ 90 
1b8e			;free to reuse	OPCODE_ENDMATHS: equ 91  
1b8e				OPCODE_BYNAME: equ 92 
1b8e				OPCODE_DIR: equ 93 
1b8e				OPCODE_SAVE: equ 94 
1b8e				OPCODE_LOAD: equ 95 
1b8e				OPCODE_BSAVE: equ 96 
1b8e				OPCODE_BLOAD: equ 97 
1b8e				OPCODE_SEO: equ 98  
1b8e				OPCODE_SEI: equ 99 
1b8e				OPCODE_SFREE: equ 100 
1b8e				OPCODE_SIZE: equ 101 
1b8e				OPCODE_CREATE: equ 102 
1b8e				OPCODE_APPEND: equ 103 
1b8e				OPCODE_SDEL: equ 104 
1b8e				OPCODE_OPEN: equ 105 
1b8e				OPCODE_READ: equ 106 
1b8e				OPCODE_EOF: equ 106 
1b8e				OPCODE_FORMAT: equ 107 
1b8e				OPCODE_LABEL: equ 108 
1b8e				OPCODE_LABELS: equ 109 
1b8e			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1b8e				OPCODE_UPPER: equ 111 
1b8e				OPCODE_LOWER: equ 112 
1b8e				OPCODE_SUBSTR: equ 113 
1b8e				OPCODE_LEFT: equ 114 
1b8e				OPCODE_RIGHT: equ 115 
1b8e				OPCODE_STR2NUM: equ 116 
1b8e				OPCODE_NUM2STR: equ 117 
1b8e				OPCODE_CONCAT: equ 118 
1b8e				OPCODE_FIND: equ 119 
1b8e				OPCODE_LEN: equ 120 
1b8e				OPCODE_CHAR: equ 121 
1b8e			; free to reuse	OPCODE_STRLEN: equ 122 
1b8e			; free to reuse	OPCODE_ENDSTR: equ 123 
1b8e				OPCODE_V0S: equ 124 
1b8e				OPCODE_V0Q: equ 125 
1b8e				OPCODE_V1S: equ 126 
1b8e				OPCODE_V1Q: equ 127 
1b8e				OPCODE_V2S: equ 128 
1b8e				OPCODE_V2Q: equ 129 
1b8e				OPCODE_V3S: equ 130 
1b8e				OPCODE_V3Q: equ 131 
1b8e			;free to reuse	OPCODE_END: equ 132 
1b8e				OPCODE_ZDUP: equ 133 
1b8e			 
1b8e			; eof 
# End of file forth_opcodes.asm
1b8e			 
1b8e			include "forth_words_core.asm" 
1b8e			 
1b8e			; | ## Core Words 
1b8e			 
1b8e			;if MALLOC_4 
1b8e			 
1b8e			.HEAP: 
1b8e				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1b8e 15				db WORD_SYS_CORE+OPCODE_HEAP             
1b8f cd 1b			dw .EXEC            
1b91 05				db 4 + 1 
1b92 .. 00			db "HEAP",0              
1b97				endm 
# End of macro CWHEAD
1b97			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1b97			; | | u1 - Current number of bytes in the heap 
1b97			; | | u2 - Remaining bytes left on the heap 
1b97			; | |  
1b97			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1b97			 
1b97			 
1b97					if DEBUG_FORTH_WORDS_KEY 
1b97						DMARK "HEP" 
1b97 f5				push af  
1b98 3a ac 1b			ld a, (.dmark)  
1b9b 32 bd fb			ld (debug_mark),a  
1b9e 3a ad 1b			ld a, (.dmark+1)  
1ba1 32 be fb			ld (debug_mark+1),a  
1ba4 3a ae 1b			ld a, (.dmark+2)  
1ba7 32 bf fb			ld (debug_mark+2),a  
1baa 18 03			jr .pastdmark  
1bac ..			.dmark: db "HEP"  
1baf f1			.pastdmark: pop af  
1bb0			endm  
# End of macro DMARK
1bb0						CALLMONITOR 
1bb0 cd d7 12			call break_point_state  
1bb3				endm  
# End of macro CALLMONITOR
1bb3					endif 
1bb3 2a 0a 80				ld hl, (free_list )      
1bb6 11 0e 80				ld de, heap_start 
1bb9			 
1bb9 ed 52				sbc hl, de  
1bbb			 
1bbb cd 61 18				call forth_push_numhl 
1bbe			 
1bbe			 
1bbe ed 5b 0a 80			ld de, (free_list )      
1bc2 21 ac ef				ld hl, heap_end 
1bc5			 
1bc5 ed 52				sbc hl, de 
1bc7			 
1bc7 cd 61 18				call forth_push_numhl 
1bca					 
1bca			 
1bca					 
1bca			 
1bca			 
1bca			 
1bca					NEXTW 
1bca c3 36 1a			jp macro_next 
1bcd				endm 
# End of macro NEXTW
1bcd			;endif 
1bcd			 
1bcd			.EXEC: 
1bcd				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1bcd 16				db WORD_SYS_CORE+OPCODE_EXEC             
1bce 13 1c			dw .STKEXEC            
1bd0 05				db 4 + 1 
1bd1 .. 00			db "EXEC",0              
1bd6				endm 
# End of macro CWHEAD
1bd6			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1bd6			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1bd6			; | | 
1bd6			; | |   
1bd6				STACKFRAME OFF $5efe $5f9f 
1bd6				if DEBUG_STACK_IMB 
1bd6					if OFF 
1bd6						exx 
1bd6						ld de, $5efe 
1bd6						ld a, d 
1bd6						ld hl, curframe 
1bd6						call hexout 
1bd6						ld a, e 
1bd6						ld hl, curframe+2 
1bd6						call hexout 
1bd6						ld hl, $5efe 
1bd6						push hl 
1bd6						ld hl, $5f9f 
1bd6						push hl 
1bd6						exx 
1bd6					endif 
1bd6				endif 
1bd6			endm 
# End of macro STACKFRAME
1bd6			 
1bd6					if DEBUG_FORTH_WORDS_KEY 
1bd6						DMARK "EXE" 
1bd6 f5				push af  
1bd7 3a eb 1b			ld a, (.dmark)  
1bda 32 bd fb			ld (debug_mark),a  
1bdd 3a ec 1b			ld a, (.dmark+1)  
1be0 32 be fb			ld (debug_mark+1),a  
1be3 3a ed 1b			ld a, (.dmark+2)  
1be6 32 bf fb			ld (debug_mark+2),a  
1be9 18 03			jr .pastdmark  
1beb ..			.dmark: db "EXE"  
1bee f1			.pastdmark: pop af  
1bef			endm  
# End of macro DMARK
1bef						CALLMONITOR 
1bef cd d7 12			call break_point_state  
1bf2				endm  
# End of macro CALLMONITOR
1bf2					endif 
1bf2			 
1bf2				FORTH_DSP_VALUEHL 
1bf2 cd fc 18			call macro_dsp_valuehl 
1bf5				endm 
# End of macro FORTH_DSP_VALUEHL
1bf5			 
1bf5				FORTH_DSP_POP 
1bf5 cd 7c 19			call macro_forth_dsp_pop 
1bf8				endm 
# End of macro FORTH_DSP_POP
1bf8			 
1bf8					if DEBUG_FORTH_WORDS 
1bf8						DMARK "EX1" 
1bf8						CALLMONITOR 
1bf8					endif 
1bf8			;	ld e,(hl) 
1bf8			;	inc hl 
1bf8			;	ld d,(hl) 
1bf8			;	ex de,hl 
1bf8			 
1bf8					if DEBUG_FORTH_WORDS 
1bf8						DMARK "EX2" 
1bf8						CALLMONITOR 
1bf8					endif 
1bf8 e5				push hl 
1bf9			 
1bf9				;ld a, 0 
1bf9				;ld a, FORTH_END_BUFFER 
1bf9 cd 71 0f			call strlenz 
1bfc 23				inc hl   ; include zero term to copy 
1bfd 06 00			ld b,0 
1bff 4d				ld c,l 
1c00 e1				pop hl 
1c01 11 b7 f0			ld de, execscratch 
1c04					if DEBUG_FORTH_WORDS 
1c04						DMARK "EX3" 
1c04						CALLMONITOR 
1c04					endif 
1c04 ed b0			ldir 
1c06			 
1c06			 
1c06 21 b7 f0			ld hl, execscratch 
1c09			 
1c09					if DEBUG_FORTH_WORDS 
1c09						DMARK "EXe" 
1c09						CALLMONITOR 
1c09					endif 
1c09			 
1c09 cd 84 1a			call forthparse 
1c0c cd c4 1a			call forthexec 
1c0f			;	call forthexec_cleanup 
1c0f			;	call forthparse 
1c0f			;	call forthexec 
1c0f			 
1c0f				STACKFRAMECHK OFF $5efe $5f9f 
1c0f				if DEBUG_STACK_IMB 
1c0f					if OFF 
1c0f						exx 
1c0f						ld hl, $5f9f 
1c0f						pop de   ; $5f9f 
1c0f						call cmp16 
1c0f						jr nz, .spnosame 
1c0f						ld hl, $5efe 
1c0f						pop de   ; $5efe 
1c0f						call cmp16 
1c0f						jr z, .spfrsame 
1c0f						.spnosame: call showsperror 
1c0f						.spfrsame: nop 
1c0f						exx 
1c0f					endif 
1c0f				endif 
1c0f			endm 
# End of macro STACKFRAMECHK
1c0f			 
1c0f				; an immediate word so no need to process any more words 
1c0f c9				ret 
1c10				NEXTW 
1c10 c3 36 1a			jp macro_next 
1c13				endm 
# End of macro NEXTW
1c13			 
1c13			; dead code - old version  
1c13			;	FORTH_RSP_NEXT 
1c13			 
1c13			;  
1c13			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1c13			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1c13			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1c13			;	push hl 
1c13			;	push de 
1c13			;	push bc 
1c13			; 
1c13			; 
1c13			;		if DEBUG_FORTH_WORDS_KEY 
1c13			;			DMARK "EXR" 
1c13			;			CALLMONITOR 
1c13			;		endif 
1c13			; 
1c13			; 
1c13			; 
1c13			;	;v5 FORTH_DSP_VALUE 
1c13			;	FORTH_DSP_VALUEHL 
1c13			; 
1c13			;	; TODO do string type checks 
1c13			; 
1c13			;;v5	inc hl   ; skip type 
1c13			; 
1c13			;	push hl  ; source code  
1c13			;		if DEBUG_FORTH_WORDS 
1c13			;			DMARK "EX1" 
1c13			;			CALLMONITOR 
1c13			;		endif 
1c13			;	ld a, 0 
1c13			;	call strlent 
1c13			; 
1c13			;	inc hl 
1c13			;	inc hl 
1c13			;	inc hl 
1c13			;	inc hl 
1c13			; 
1c13			;	push hl    ; size 
1c13			; 
1c13			;		if DEBUG_FORTH_WORDS 
1c13			;			DMARK "EX2" 
1c13			;			CALLMONITOR 
1c13			;		endif 
1c13			;	call malloc 
1c13			; 
1c13			;	ex de, hl    ; de now contains malloc area 
1c13			;	pop bc   	; get byte count 
1c13			;	pop hl      ; get string to copy 
1c13			; 
1c13			;	push de     ; save malloc for free later 
1c13			; 
1c13			;		if DEBUG_FORTH_WORDS 
1c13			;			DMARK "EX3" 
1c13			;			CALLMONITOR 
1c13			;		endif 
1c13			;	ldir       ; duplicate string 
1c13			; 
1c13			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1c13			;	 
1c13			;	; TODO fix the parse would be better than this...  
1c13			;	ex de, hl 
1c13			;	dec hl 
1c13			;	ld a, 0 
1c13			;	ld (hl), a 
1c13			;	dec hl 
1c13			;	ld a, ' ' 
1c13			;	ld (hl), a 
1c13			;	dec hl 
1c13			;	ld (hl), a 
1c13			; 
1c13			;	dec hl 
1c13			;	ld (hl), a 
1c13			; 
1c13			; 
1c13			;	FORTH_DSP_POP  
1c13			; 
1c13			;	pop hl     
1c13			;	push hl    ; save malloc area 
1c13			; 
1c13			;		if DEBUG_FORTH_WORDS 
1c13			;			DMARK "EX4" 
1c13			;			CALLMONITOR 
1c13			;		endif 
1c13			; 
1c13			;	call forthparse 
1c13			;	call forthexec 
1c13			;	 
1c13			;	pop hl 
1c13			;	if DEBUG_FORTH_WORDS 
1c13			;		DMARK "EX5" 
1c13			;		CALLMONITOR 
1c13			;	endif 
1c13			; 
1c13			;	if FORTH_ENABLE_FREE 
1c13			;	call free 
1c13			;	endif 
1c13			; 
1c13			;	if DEBUG_FORTH_WORDS 
1c13			;		DMARK "EX6" 
1c13			;		CALLMONITOR 
1c13			;	endif 
1c13			; 
1c13			;	pop bc 
1c13			;	pop de 
1c13			;	pop hl 
1c13			;;	FORTH_RSP_POP	  
1c13			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1c13			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1c13			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1c13			; 
1c13			;	if DEBUG_FORTH_WORDS 
1c13			;		DMARK "EX7" 
1c13			;		CALLMONITOR 
1c13			;	endif 
1c13			;	NEXTW 
1c13			 
1c13			.STKEXEC: 
1c13				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1c13 3f				db WORD_SYS_CORE+43             
1c14 ae 1c			dw .ZDUP            
1c16 08				db 7 + 1 
1c17 .. 00			db "STKEXEC",0              
1c1f				endm 
# End of macro CWHEAD
1c1f			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1c1f			 
1c1f			 
1c1f					if DEBUG_FORTH_WORDS_KEY 
1c1f						DMARK "STX" 
1c1f f5				push af  
1c20 3a 34 1c			ld a, (.dmark)  
1c23 32 bd fb			ld (debug_mark),a  
1c26 3a 35 1c			ld a, (.dmark+1)  
1c29 32 be fb			ld (debug_mark+1),a  
1c2c 3a 36 1c			ld a, (.dmark+2)  
1c2f 32 bf fb			ld (debug_mark+2),a  
1c32 18 03			jr .pastdmark  
1c34 ..			.dmark: db "STX"  
1c37 f1			.pastdmark: pop af  
1c38			endm  
# End of macro DMARK
1c38						CALLMONITOR 
1c38 cd d7 12			call break_point_state  
1c3b				endm  
# End of macro CALLMONITOR
1c3b					endif 
1c3b			 
1c3b				FORTH_DSP_VALUEHL 
1c3b cd fc 18			call macro_dsp_valuehl 
1c3e				endm 
# End of macro FORTH_DSP_VALUEHL
1c3e			 
1c3e 22 e6 f9			ld (store_tmp1), hl    ; count 
1c41			 
1c41				FORTH_DSP_POP 
1c41 cd 7c 19			call macro_forth_dsp_pop 
1c44				endm 
# End of macro FORTH_DSP_POP
1c44			.stkexec1: 
1c44 2a e6 f9			ld hl, (store_tmp1)   ; count 
1c47 3e 00			ld a, 0 
1c49 bd				cp l 
1c4a c8				ret z 
1c4b			 
1c4b 2b				dec hl 
1c4c 22 e6 f9			ld (store_tmp1), hl    ; count 
1c4f				 
1c4f				FORTH_DSP_VALUEHL 
1c4f cd fc 18			call macro_dsp_valuehl 
1c52				endm 
# End of macro FORTH_DSP_VALUEHL
1c52 e5				push hl 
1c53				 
1c53				FORTH_DSP_POP 
1c53 cd 7c 19			call macro_forth_dsp_pop 
1c56				endm 
# End of macro FORTH_DSP_POP
1c56			 
1c56 cd 71 0f			call strlenz 
1c59 23				inc hl   ; include zero term to copy 
1c5a 06 00			ld b,0 
1c5c 4d				ld c,l 
1c5d e1				pop hl 
1c5e 11 b7 f0			ld de, execscratch 
1c61					if DEBUG_FORTH_WORDS 
1c61						DMARK "EX3" 
1c61						CALLMONITOR 
1c61					endif 
1c61 ed b0			ldir 
1c63			 
1c63			 
1c63 21 b7 f0			ld hl, execscratch 
1c66			 
1c66					if DEBUG_FORTH_WORDS 
1c66						DMARK "EXe" 
1c66						CALLMONITOR 
1c66					endif 
1c66			 
1c66 cd 84 1a			call forthparse 
1c69 cd c4 1a			call forthexec 
1c6c			 
1c6c c3 44 1c			jp .stkexec1 
1c6f			 
1c6f c9				ret 
1c70			 
1c70			 
1c70			.DUP: 
1c70				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1c70 17				db WORD_SYS_CORE+OPCODE_DUP             
1c71 ae 1c			dw .ZDUP            
1c73 04				db 3 + 1 
1c74 .. 00			db "DUP",0              
1c78				endm 
# End of macro CWHEAD
1c78			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1c78			 
1c78					if DEBUG_FORTH_WORDS_KEY 
1c78						DMARK "DUP" 
1c78 f5				push af  
1c79 3a 8d 1c			ld a, (.dmark)  
1c7c 32 bd fb			ld (debug_mark),a  
1c7f 3a 8e 1c			ld a, (.dmark+1)  
1c82 32 be fb			ld (debug_mark+1),a  
1c85 3a 8f 1c			ld a, (.dmark+2)  
1c88 32 bf fb			ld (debug_mark+2),a  
1c8b 18 03			jr .pastdmark  
1c8d ..			.dmark: db "DUP"  
1c90 f1			.pastdmark: pop af  
1c91			endm  
# End of macro DMARK
1c91						CALLMONITOR 
1c91 cd d7 12			call break_point_state  
1c94				endm  
# End of macro CALLMONITOR
1c94					endif 
1c94			 
1c94					FORTH_DSP 
1c94 cd e1 18			call macro_forth_dsp 
1c97				endm 
# End of macro FORTH_DSP
1c97			 
1c97 7e					ld a, (HL) 
1c98 fe 01				cp DS_TYPE_STR 
1c9a 20 09				jr nz, .dupinum 
1c9c			 
1c9c					; push another string 
1c9c			 
1c9c					FORTH_DSP_VALUEHL     		 
1c9c cd fc 18			call macro_dsp_valuehl 
1c9f				endm 
# End of macro FORTH_DSP_VALUEHL
1c9f			 
1c9f				if DEBUG_FORTH_WORDS 
1c9f					DMARK "DUs" 
1c9f					CALLMONITOR 
1c9f				endif 
1c9f cd 73 18				call forth_push_str 
1ca2			 
1ca2					NEXTW 
1ca2 c3 36 1a			jp macro_next 
1ca5				endm 
# End of macro NEXTW
1ca5			 
1ca5			 
1ca5			.dupinum: 
1ca5					 
1ca5			 
1ca5			 
1ca5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1ca5 cd fc 18			call macro_dsp_valuehl 
1ca8				endm 
# End of macro FORTH_DSP_VALUEHL
1ca8			 
1ca8				; TODO add floating point number detection 
1ca8			 
1ca8				if DEBUG_FORTH_WORDS 
1ca8					DMARK "DUi" 
1ca8					CALLMONITOR 
1ca8				endif 
1ca8			 
1ca8 cd 61 18				call forth_push_numhl 
1cab					NEXTW 
1cab c3 36 1a			jp macro_next 
1cae				endm 
# End of macro NEXTW
1cae			.ZDUP: 
1cae				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1cae 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1caf e6 1c			dw .SWAP            
1cb1 05				db 4 + 1 
1cb2 .. 00			db "?DUP",0              
1cb7				endm 
# End of macro CWHEAD
1cb7			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1cb7			 
1cb7					if DEBUG_FORTH_WORDS_KEY 
1cb7						DMARK "qDU" 
1cb7 f5				push af  
1cb8 3a cc 1c			ld a, (.dmark)  
1cbb 32 bd fb			ld (debug_mark),a  
1cbe 3a cd 1c			ld a, (.dmark+1)  
1cc1 32 be fb			ld (debug_mark+1),a  
1cc4 3a ce 1c			ld a, (.dmark+2)  
1cc7 32 bf fb			ld (debug_mark+2),a  
1cca 18 03			jr .pastdmark  
1ccc ..			.dmark: db "qDU"  
1ccf f1			.pastdmark: pop af  
1cd0			endm  
# End of macro DMARK
1cd0						CALLMONITOR 
1cd0 cd d7 12			call break_point_state  
1cd3				endm  
# End of macro CALLMONITOR
1cd3					endif 
1cd3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1cd3 cd fc 18			call macro_dsp_valuehl 
1cd6				endm 
# End of macro FORTH_DSP_VALUEHL
1cd6			 
1cd6 e5					push hl 
1cd7			 
1cd7					; is it a zero? 
1cd7			 
1cd7 3e 00				ld a, 0 
1cd9 84					add h 
1cda 85					add l 
1cdb			 
1cdb e1					pop hl 
1cdc			 
1cdc fe 00				cp 0 
1cde 28 03				jr z, .dup2orig 
1ce0			 
1ce0			 
1ce0 cd 61 18				call forth_push_numhl 
1ce3			 
1ce3			 
1ce3				; TODO add floating point number detection 
1ce3			 
1ce3			.dup2orig: 
1ce3			 
1ce3					NEXTW 
1ce3 c3 36 1a			jp macro_next 
1ce6				endm 
# End of macro NEXTW
1ce6			.SWAP: 
1ce6				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1ce6 18				db WORD_SYS_CORE+OPCODE_SWAP             
1ce7 25 1d			dw .COLN            
1ce9 05				db 4 + 1 
1cea .. 00			db "SWAP",0              
1cef				endm 
# End of macro CWHEAD
1cef			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1cef					if DEBUG_FORTH_WORDS_KEY 
1cef						DMARK "SWP" 
1cef f5				push af  
1cf0 3a 04 1d			ld a, (.dmark)  
1cf3 32 bd fb			ld (debug_mark),a  
1cf6 3a 05 1d			ld a, (.dmark+1)  
1cf9 32 be fb			ld (debug_mark+1),a  
1cfc 3a 06 1d			ld a, (.dmark+2)  
1cff 32 bf fb			ld (debug_mark+2),a  
1d02 18 03			jr .pastdmark  
1d04 ..			.dmark: db "SWP"  
1d07 f1			.pastdmark: pop af  
1d08			endm  
# End of macro DMARK
1d08						CALLMONITOR 
1d08 cd d7 12			call break_point_state  
1d0b				endm  
# End of macro CALLMONITOR
1d0b					endif 
1d0b			 
1d0b					FORTH_DSP_VALUEHL 
1d0b cd fc 18			call macro_dsp_valuehl 
1d0e				endm 
# End of macro FORTH_DSP_VALUEHL
1d0e e5					push hl     ; w2 
1d0f			 
1d0f					FORTH_DSP_POP 
1d0f cd 7c 19			call macro_forth_dsp_pop 
1d12				endm 
# End of macro FORTH_DSP_POP
1d12			 
1d12					FORTH_DSP_VALUEHL 
1d12 cd fc 18			call macro_dsp_valuehl 
1d15				endm 
# End of macro FORTH_DSP_VALUEHL
1d15			 
1d15					FORTH_DSP_POP 
1d15 cd 7c 19			call macro_forth_dsp_pop 
1d18				endm 
# End of macro FORTH_DSP_POP
1d18			 
1d18 d1					pop de     ; w2	, hl = w1 
1d19			 
1d19 eb					ex de, hl 
1d1a d5					push de 
1d1b			 
1d1b cd 61 18				call forth_push_numhl 
1d1e			 
1d1e e1					pop hl 
1d1f			 
1d1f cd 61 18				call forth_push_numhl 
1d22					 
1d22			 
1d22					NEXTW 
1d22 c3 36 1a			jp macro_next 
1d25				endm 
# End of macro NEXTW
1d25			.COLN: 
1d25				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1d25 19				db WORD_SYS_CORE+OPCODE_COLN             
1d26 e7 1d			dw .SCOLN            
1d28 02				db 1 + 1 
1d29 .. 00			db ":",0              
1d2b				endm 
# End of macro CWHEAD
1d2b			; | : ( -- )         Create new word | DONE 
1d2b			 
1d2b					if DEBUG_FORTH_WORDS_KEY 
1d2b						DMARK "CLN" 
1d2b f5				push af  
1d2c 3a 40 1d			ld a, (.dmark)  
1d2f 32 bd fb			ld (debug_mark),a  
1d32 3a 41 1d			ld a, (.dmark+1)  
1d35 32 be fb			ld (debug_mark+1),a  
1d38 3a 42 1d			ld a, (.dmark+2)  
1d3b 32 bf fb			ld (debug_mark+2),a  
1d3e 18 03			jr .pastdmark  
1d40 ..			.dmark: db "CLN"  
1d43 f1			.pastdmark: pop af  
1d44			endm  
# End of macro DMARK
1d44						CALLMONITOR 
1d44 cd d7 12			call break_point_state  
1d47				endm  
# End of macro CALLMONITOR
1d47					endif 
1d47				STACKFRAME OFF $8efe $989f 
1d47				if DEBUG_STACK_IMB 
1d47					if OFF 
1d47						exx 
1d47						ld de, $8efe 
1d47						ld a, d 
1d47						ld hl, curframe 
1d47						call hexout 
1d47						ld a, e 
1d47						ld hl, curframe+2 
1d47						call hexout 
1d47						ld hl, $8efe 
1d47						push hl 
1d47						ld hl, $989f 
1d47						push hl 
1d47						exx 
1d47					endif 
1d47				endif 
1d47			endm 
# End of macro STACKFRAME
1d47				; get parser buffer length  of new word 
1d47			 
1d47				 
1d47			 
1d47					; move tok past this to start of name defintition 
1d47					; TODO get word to define 
1d47					; TODO Move past word token 
1d47					; TODO get length of string up to the ';' 
1d47			 
1d47 2a b9 f2			ld hl, (os_tok_ptr) 
1d4a 23				inc hl 
1d4b 23				inc hl 
1d4c			 
1d4c 3e 3b			ld a, ';' 
1d4e cd 7c 0f			call strlent 
1d51			 
1d51 7d				ld a,l 
1d52 32 b8 f1			ld (os_new_parse_len), a 
1d55			 
1d55			 
1d55			if DEBUG_FORTH_UWORD 
1d55				ld de, (os_tok_ptr) 
1d55						DMARK ":01" 
1d55				CALLMONITOR 
1d55			endif 
1d55			 
1d55			; 
1d55			;  new word memory layout: 
1d55			;  
1d55			;    : adg 6666 ;  
1d55			; 
1d55			;    db   1     ; user defined word  
1d55 23				inc hl    
1d56			;    dw   sysdict 
1d56 23				inc hl 
1d57 23				inc hl 
1d58			;    db <word len>+1 (for null) 
1d58 23				inc hl 
1d59			;    db .... <word> 
1d59			; 
1d59			 
1d59 23				inc hl    ; some extras for the word preamble before the above 
1d5a 23				inc hl 
1d5b 23				inc hl 
1d5c 23				inc hl 
1d5d 23				inc hl 
1d5e 23				inc hl 
1d5f 23				inc hl  
1d60 23				inc hl 
1d61 23				inc hl 
1d62 23				inc hl 
1d63 23				inc hl 
1d64 23				inc hl 
1d65 23				inc hl 
1d66 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1d67			;       exec word buffer 
1d67			;	<ptr word>   
1d67 23				inc hl 
1d68 23				inc hl 
1d69			;       <word list><null term> 7F final term 
1d69			 
1d69			 
1d69			if DEBUG_FORTH_UWORD 
1d69						DMARK ":02" 
1d69				CALLMONITOR 
1d69			endif 
1d69			 
1d69				 
1d69					; malloc the size 
1d69			 
1d69 cd da 0f				call malloc 
1d6c 22 b6 f1				ld (os_new_malloc), hl     ; save malloc start 
1d6f			 
1d6f			;    db   1     ; user defined word  
1d6f 3e 01				ld a, WORD_SYS_UWORD  
1d71 77					ld (hl), a 
1d72				 
1d72 23				inc hl    
1d73			;    dw   sysdict 
1d73 11 8e 1b			ld de, sysdict       ; continue on with the scan to the system dict 
1d76 73				ld (hl), e 
1d77 23				inc hl 
1d78 72				ld (hl), d 
1d79 23				inc hl 
1d7a			 
1d7a			 
1d7a			;    Setup dict word 
1d7a			 
1d7a 23				inc hl 
1d7b 22 bc f1			ld (os_new_work_ptr), hl     ; save start of dict word  
1d7e			 
1d7e				; 1. get length of dict word 
1d7e			 
1d7e			 
1d7e 2a b9 f2			ld hl, (os_tok_ptr) 
1d81 23				inc hl 
1d82 23				inc hl    ; position to start of dict word 
1d83 3e 00			ld a, 0 
1d85 cd 7c 0f			call strlent 
1d88			 
1d88			 
1d88 23				inc hl    ; to include null??? 
1d89			 
1d89				; write length of dict word 
1d89			 
1d89 ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1d8d 1b				dec de 
1d8e eb				ex de, hl 
1d8f 73				ld (hl), e 
1d90 eb				ex de, hl 
1d91			 
1d91				 
1d91			 
1d91				; copy  
1d91 4d				ld c, l 
1d92 06 00			ld b, 0 
1d94 ed 5b bc f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
1d98 2a b9 f2			ld hl, (os_tok_ptr) 
1d9b 23				inc hl 
1d9c 23				inc hl    ; position to start of dict word 
1d9d				 
1d9d			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
1d9d				 
1d9d				; TODO need to convert word to upper case 
1d9d			 
1d9d			ucasetok:	 
1d9d 7e				ld a,(hl) 
1d9e cd 68 0f			call toUpper 
1da1 77				ld (hl),a 
1da2 ed a0			ldi 
1da4 f2 9d 1d		 	jp p, ucasetok 
1da7			 
1da7			 
1da7			 
1da7				; de now points to start of where the word body code should be placed 
1da7 ed 53 bc f1		ld (os_new_work_ptr), de 
1dab				; hl now points to the words to throw at forthexec which needs to be copied 
1dab 22 be f1			ld (os_new_src_ptr), hl 
1dae			 
1dae				; TODO add 'call to forthexec' 
1dae			 
1dae			if DEBUG_FORTH_UWORD 
1dae				push bc 
1dae				ld bc, (os_new_malloc) 
1dae						DMARK ":0x" 
1dae				CALLMONITOR 
1dae				pop bc 
1dae			endif 
1dae			 
1dae			 
1dae				; create word preamble which should be: 
1dae			 
1dae			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
1dae			 
1dae				;    ld hl, <word code> 
1dae				;    jp user_exec 
1dae			        ;    <word code bytes> 
1dae			 
1dae			 
1dae			;	inc de     ; TODO ??? or are we already past the word's null 
1dae eb				ex de, hl 
1daf			 
1daf 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
1db1			 
1db1 23				inc hl 
1db2 22 c2 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
1db5 23				inc hl 
1db6			 
1db6 23				inc hl 
1db7 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
1db9			 
1db9 01 82 3e			ld bc, user_exec 
1dbc 23				inc hl 
1dbd 71				ld (hl), c     ; poke address of user_exec 
1dbe 23				inc hl 
1dbf 70				ld (hl), b     
1dc0			 ; 
1dc0			;	inc hl 
1dc0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1dc0			; 
1dc0			; 
1dc0			;	ld bc, macro_forth_rsp_next 
1dc0			;	inc hl 
1dc0			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
1dc0			;	inc hl 
1dc0			;	ld (hl), b     
1dc0			 ; 
1dc0			;	inc hl 
1dc0			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
1dc0			; 
1dc0			; 
1dc0			;	inc hl 
1dc0			;	ld bc, forthexec 
1dc0			;	ld (hl), c     ; poke address of forthexec 
1dc0			;	inc hl 
1dc0			;	ld (hl), b      
1dc0			; 
1dc0			;	inc hl 
1dc0			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
1dc0			; 
1dc0			;	ld bc, user_dict_next 
1dc0			;	inc hl 
1dc0			;	ld (hl), c     ; poke address of forthexec 
1dc0			;	inc hl 
1dc0			;	ld (hl), b      
1dc0			 
1dc0				; hl is now where we need to copy the word byte data to save this 
1dc0			 
1dc0 23				inc hl 
1dc1 22 c0 f1			ld (os_new_exec), hl 
1dc4				 
1dc4				; copy definition 
1dc4			 
1dc4 eb				ex de, hl 
1dc5			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
1dc5			;	inc de    ; skip the PC for this parse 
1dc5 3a b8 f1			ld a, (os_new_parse_len) 
1dc8 4f				ld c, a 
1dc9 06 00			ld b, 0 
1dcb ed b0			ldir		 ; copy defintion 
1dcd			 
1dcd			 
1dcd				; poke the address of where the new word bytes live for forthexec 
1dcd			 
1dcd 2a c2 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
1dd0			 
1dd0 ed 5b c0 f1		ld de, (os_new_exec)      
1dd4				 
1dd4 73				ld (hl), e 
1dd5 23				inc hl 
1dd6 72				ld (hl), d 
1dd7			 
1dd7					; TODO copy last user dict word next link to this word 
1dd7					; TODO update last user dict word to point to this word 
1dd7			; 
1dd7			; hl f923 de 812a ; bc 811a 
1dd7			 
1dd7			if DEBUG_FORTH_UWORD 
1dd7				push bc 
1dd7				ld bc, (os_new_malloc) 
1dd7						DMARK ":0A" 
1dd7				CALLMONITOR 
1dd7				pop bc 
1dd7			endif 
1dd7			if DEBUG_FORTH_UWORD 
1dd7				push bc 
1dd7				ld bc, (os_new_malloc) 
1dd7				inc bc 
1dd7				inc bc 
1dd7				inc bc 
1dd7				inc bc 
1dd7				inc bc 
1dd7				inc bc 
1dd7				inc bc 
1dd7				inc bc 
1dd7			 
1dd7						DMARK ":0B" 
1dd7				CALLMONITOR 
1dd7				pop bc 
1dd7			endif 
1dd7			 
1dd7			; update word dict linked list for new word 
1dd7			 
1dd7			 
1dd7 2a b5 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
1dda 23			inc hl     ; move to next work linked list ptr 
1ddb			 
1ddb ed 5b b6 f1	ld de, (os_new_malloc)		 ; new next word 
1ddf 73			ld (hl), e 
1de0 23			inc hl 
1de1 72			ld (hl), d 
1de2			 
1de2			if DEBUG_FORTH_UWORD 
1de2				ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
1de2			endif 
1de2			 
1de2 ed 53 b5 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
1de6			 
1de6			 
1de6			if DEBUG_FORTH_UWORD 
1de6						DMARK ":0+" 
1de6				CALLMONITOR 
1de6			endif 
1de6			 
1de6				STACKFRAMECHK OFF $8efe $989f 
1de6				if DEBUG_STACK_IMB 
1de6					if OFF 
1de6						exx 
1de6						ld hl, $989f 
1de6						pop de   ; $989f 
1de6						call cmp16 
1de6						jr nz, .spnosame 
1de6						ld hl, $8efe 
1de6						pop de   ; $8efe 
1de6						call cmp16 
1de6						jr z, .spfrsame 
1de6						.spnosame: call showsperror 
1de6						.spfrsame: nop 
1de6						exx 
1de6					endif 
1de6				endif 
1de6			endm 
# End of macro STACKFRAMECHK
1de6			 
1de6 c9			ret    ; dont process any remaining parser tokens as they form new word 
1de7			 
1de7			 
1de7			 
1de7			 
1de7			;		NEXT 
1de7			.SCOLN: 
1de7			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
1de7 06				db OPCODE_SCOLN 
1de8 17 1e			dw .DROP 
1dea 02				db 2 
1deb .. 00			db ";",0           
1ded			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
1ded					if DEBUG_FORTH_WORDS_KEY 
1ded						DMARK "SCN" 
1ded f5				push af  
1dee 3a 02 1e			ld a, (.dmark)  
1df1 32 bd fb			ld (debug_mark),a  
1df4 3a 03 1e			ld a, (.dmark+1)  
1df7 32 be fb			ld (debug_mark+1),a  
1dfa 3a 04 1e			ld a, (.dmark+2)  
1dfd 32 bf fb			ld (debug_mark+2),a  
1e00 18 03			jr .pastdmark  
1e02 ..			.dmark: db "SCN"  
1e05 f1			.pastdmark: pop af  
1e06			endm  
# End of macro DMARK
1e06						CALLMONITOR 
1e06 cd d7 12			call break_point_state  
1e09				endm  
# End of macro CALLMONITOR
1e09					endif 
1e09					FORTH_RSP_TOS 
1e09 cd 22 18			call macro_forth_rsp_tos 
1e0c				endm 
# End of macro FORTH_RSP_TOS
1e0c e5					push hl 
1e0d					FORTH_RSP_POP 
1e0d cd 29 18			call macro_forth_rsp_pop 
1e10				endm 
# End of macro FORTH_RSP_POP
1e10 e1					pop hl 
1e11			;		ex de,hl 
1e11 22 b9 f2				ld (os_tok_ptr),hl 
1e14			 
1e14			if DEBUG_FORTH_UWORD 
1e14						DMARK "SCL" 
1e14				CALLMONITOR 
1e14			endif 
1e14					NEXTW 
1e14 c3 36 1a			jp macro_next 
1e17				endm 
# End of macro NEXTW
1e17			 
1e17			.DROP: 
1e17				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
1e17 1b				db WORD_SYS_CORE+OPCODE_DROP             
1e18 42 1e			dw .DUP2            
1e1a 05				db 4 + 1 
1e1b .. 00			db "DROP",0              
1e20				endm 
# End of macro CWHEAD
1e20			; | DROP ( w -- )   drop the TOS item   | DONE 
1e20					if DEBUG_FORTH_WORDS_KEY 
1e20						DMARK "DRP" 
1e20 f5				push af  
1e21 3a 35 1e			ld a, (.dmark)  
1e24 32 bd fb			ld (debug_mark),a  
1e27 3a 36 1e			ld a, (.dmark+1)  
1e2a 32 be fb			ld (debug_mark+1),a  
1e2d 3a 37 1e			ld a, (.dmark+2)  
1e30 32 bf fb			ld (debug_mark+2),a  
1e33 18 03			jr .pastdmark  
1e35 ..			.dmark: db "DRP"  
1e38 f1			.pastdmark: pop af  
1e39			endm  
# End of macro DMARK
1e39						CALLMONITOR 
1e39 cd d7 12			call break_point_state  
1e3c				endm  
# End of macro CALLMONITOR
1e3c					endif 
1e3c					FORTH_DSP_POP 
1e3c cd 7c 19			call macro_forth_dsp_pop 
1e3f				endm 
# End of macro FORTH_DSP_POP
1e3f					NEXTW 
1e3f c3 36 1a			jp macro_next 
1e42				endm 
# End of macro NEXTW
1e42			.DUP2: 
1e42				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
1e42 1c				db WORD_SYS_CORE+OPCODE_DUP2             
1e43 87 1e			dw .DROP2            
1e45 05				db 4 + 1 
1e46 .. 00			db "2DUP",0              
1e4b				endm 
# End of macro CWHEAD
1e4b			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
1e4b					if DEBUG_FORTH_WORDS_KEY 
1e4b						DMARK "2DU" 
1e4b f5				push af  
1e4c 3a 60 1e			ld a, (.dmark)  
1e4f 32 bd fb			ld (debug_mark),a  
1e52 3a 61 1e			ld a, (.dmark+1)  
1e55 32 be fb			ld (debug_mark+1),a  
1e58 3a 62 1e			ld a, (.dmark+2)  
1e5b 32 bf fb			ld (debug_mark+2),a  
1e5e 18 03			jr .pastdmark  
1e60 ..			.dmark: db "2DU"  
1e63 f1			.pastdmark: pop af  
1e64			endm  
# End of macro DMARK
1e64						CALLMONITOR 
1e64 cd d7 12			call break_point_state  
1e67				endm  
# End of macro CALLMONITOR
1e67					endif 
1e67					FORTH_DSP_VALUEHL 
1e67 cd fc 18			call macro_dsp_valuehl 
1e6a				endm 
# End of macro FORTH_DSP_VALUEHL
1e6a e5					push hl      ; 2 
1e6b			 
1e6b					FORTH_DSP_POP 
1e6b cd 7c 19			call macro_forth_dsp_pop 
1e6e				endm 
# End of macro FORTH_DSP_POP
1e6e					 
1e6e					FORTH_DSP_VALUEHL 
1e6e cd fc 18			call macro_dsp_valuehl 
1e71				endm 
# End of macro FORTH_DSP_VALUEHL
1e71			;		push hl      ; 1 
1e71			 
1e71					FORTH_DSP_POP 
1e71 cd 7c 19			call macro_forth_dsp_pop 
1e74				endm 
# End of macro FORTH_DSP_POP
1e74			 
1e74			;		pop hl       ; 1 
1e74 d1					pop de       ; 2 
1e75			 
1e75 cd 61 18				call forth_push_numhl 
1e78 eb					ex de, hl 
1e79 cd 61 18				call forth_push_numhl 
1e7c			 
1e7c					 
1e7c eb					ex de, hl 
1e7d			 
1e7d cd 61 18				call forth_push_numhl 
1e80 eb					ex de, hl 
1e81 cd 61 18				call forth_push_numhl 
1e84			 
1e84			 
1e84					NEXTW 
1e84 c3 36 1a			jp macro_next 
1e87				endm 
# End of macro NEXTW
1e87			.DROP2: 
1e87				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
1e87 1d				db WORD_SYS_CORE+OPCODE_DROP2             
1e88 b6 1e			dw .SWAP2            
1e8a 06				db 5 + 1 
1e8b .. 00			db "2DROP",0              
1e91				endm 
# End of macro CWHEAD
1e91			; | 2DROP ( w w -- )    Double drop | DONE 
1e91					if DEBUG_FORTH_WORDS_KEY 
1e91						DMARK "2DR" 
1e91 f5				push af  
1e92 3a a6 1e			ld a, (.dmark)  
1e95 32 bd fb			ld (debug_mark),a  
1e98 3a a7 1e			ld a, (.dmark+1)  
1e9b 32 be fb			ld (debug_mark+1),a  
1e9e 3a a8 1e			ld a, (.dmark+2)  
1ea1 32 bf fb			ld (debug_mark+2),a  
1ea4 18 03			jr .pastdmark  
1ea6 ..			.dmark: db "2DR"  
1ea9 f1			.pastdmark: pop af  
1eaa			endm  
# End of macro DMARK
1eaa						CALLMONITOR 
1eaa cd d7 12			call break_point_state  
1ead				endm  
# End of macro CALLMONITOR
1ead					endif 
1ead					FORTH_DSP_POP 
1ead cd 7c 19			call macro_forth_dsp_pop 
1eb0				endm 
# End of macro FORTH_DSP_POP
1eb0					FORTH_DSP_POP 
1eb0 cd 7c 19			call macro_forth_dsp_pop 
1eb3				endm 
# End of macro FORTH_DSP_POP
1eb3					NEXTW 
1eb3 c3 36 1a			jp macro_next 
1eb6				endm 
# End of macro NEXTW
1eb6			.SWAP2: 
1eb6				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
1eb6 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
1eb7 df 1e			dw .AT            
1eb9 06				db 5 + 1 
1eba .. 00			db "2SWAP",0              
1ec0				endm 
# End of macro CWHEAD
1ec0			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
1ec0					if DEBUG_FORTH_WORDS_KEY 
1ec0						DMARK "2SW" 
1ec0 f5				push af  
1ec1 3a d5 1e			ld a, (.dmark)  
1ec4 32 bd fb			ld (debug_mark),a  
1ec7 3a d6 1e			ld a, (.dmark+1)  
1eca 32 be fb			ld (debug_mark+1),a  
1ecd 3a d7 1e			ld a, (.dmark+2)  
1ed0 32 bf fb			ld (debug_mark+2),a  
1ed3 18 03			jr .pastdmark  
1ed5 ..			.dmark: db "2SW"  
1ed8 f1			.pastdmark: pop af  
1ed9			endm  
# End of macro DMARK
1ed9						CALLMONITOR 
1ed9 cd d7 12			call break_point_state  
1edc				endm  
# End of macro CALLMONITOR
1edc					endif 
1edc					NEXTW 
1edc c3 36 1a			jp macro_next 
1edf				endm 
# End of macro NEXTW
1edf			.AT: 
1edf				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
1edf 1f				db WORD_SYS_CORE+OPCODE_AT             
1ee0 11 1f			dw .CAT            
1ee2 02				db 1 + 1 
1ee3 .. 00			db "@",0              
1ee5				endm 
# End of macro CWHEAD
1ee5			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
1ee5			 
1ee5					if DEBUG_FORTH_WORDS_KEY 
1ee5						DMARK "AT." 
1ee5 f5				push af  
1ee6 3a fa 1e			ld a, (.dmark)  
1ee9 32 bd fb			ld (debug_mark),a  
1eec 3a fb 1e			ld a, (.dmark+1)  
1eef 32 be fb			ld (debug_mark+1),a  
1ef2 3a fc 1e			ld a, (.dmark+2)  
1ef5 32 bf fb			ld (debug_mark+2),a  
1ef8 18 03			jr .pastdmark  
1efa ..			.dmark: db "AT."  
1efd f1			.pastdmark: pop af  
1efe			endm  
# End of macro DMARK
1efe						CALLMONITOR 
1efe cd d7 12			call break_point_state  
1f01				endm  
# End of macro CALLMONITOR
1f01					endif 
1f01			.getbyteat:	 
1f01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f01 cd fc 18			call macro_dsp_valuehl 
1f04				endm 
# End of macro FORTH_DSP_VALUEHL
1f04					 
1f04			;		push hl 
1f04				 
1f04					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1f04 cd 7c 19			call macro_forth_dsp_pop 
1f07				endm 
# End of macro FORTH_DSP_POP
1f07			 
1f07			;		pop hl 
1f07			 
1f07 7e					ld a, (hl) 
1f08			 
1f08 6f					ld l, a 
1f09 26 00				ld h, 0 
1f0b cd 61 18				call forth_push_numhl 
1f0e			 
1f0e					NEXTW 
1f0e c3 36 1a			jp macro_next 
1f11				endm 
# End of macro NEXTW
1f11			.CAT: 
1f11				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
1f11 20				db WORD_SYS_CORE+OPCODE_CAT             
1f12 3a 1f			dw .BANG            
1f14 03				db 2 + 1 
1f15 .. 00			db "C@",0              
1f18				endm 
# End of macro CWHEAD
1f18			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
1f18					if DEBUG_FORTH_WORDS_KEY 
1f18						DMARK "CAA" 
1f18 f5				push af  
1f19 3a 2d 1f			ld a, (.dmark)  
1f1c 32 bd fb			ld (debug_mark),a  
1f1f 3a 2e 1f			ld a, (.dmark+1)  
1f22 32 be fb			ld (debug_mark+1),a  
1f25 3a 2f 1f			ld a, (.dmark+2)  
1f28 32 bf fb			ld (debug_mark+2),a  
1f2b 18 03			jr .pastdmark  
1f2d ..			.dmark: db "CAA"  
1f30 f1			.pastdmark: pop af  
1f31			endm  
# End of macro DMARK
1f31						CALLMONITOR 
1f31 cd d7 12			call break_point_state  
1f34				endm  
# End of macro CALLMONITOR
1f34					endif 
1f34 c3 01 1f				jp .getbyteat 
1f37					NEXTW 
1f37 c3 36 1a			jp macro_next 
1f3a				endm 
# End of macro NEXTW
1f3a			.BANG: 
1f3a				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
1f3a 21				db WORD_SYS_CORE+OPCODE_BANG             
1f3b 70 1f			dw .CBANG            
1f3d 02				db 1 + 1 
1f3e .. 00			db "!",0              
1f40				endm 
# End of macro CWHEAD
1f40			; | ! ( x w -- ) Store x at address w      | DONE 
1f40					if DEBUG_FORTH_WORDS_KEY 
1f40						DMARK "BNG" 
1f40 f5				push af  
1f41 3a 55 1f			ld a, (.dmark)  
1f44 32 bd fb			ld (debug_mark),a  
1f47 3a 56 1f			ld a, (.dmark+1)  
1f4a 32 be fb			ld (debug_mark+1),a  
1f4d 3a 57 1f			ld a, (.dmark+2)  
1f50 32 bf fb			ld (debug_mark+2),a  
1f53 18 03			jr .pastdmark  
1f55 ..			.dmark: db "BNG"  
1f58 f1			.pastdmark: pop af  
1f59			endm  
# End of macro DMARK
1f59						CALLMONITOR 
1f59 cd d7 12			call break_point_state  
1f5c				endm  
# End of macro CALLMONITOR
1f5c					endif 
1f5c			 
1f5c			.storebyteat:		 
1f5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f5c cd fc 18			call macro_dsp_valuehl 
1f5f				endm 
# End of macro FORTH_DSP_VALUEHL
1f5f					 
1f5f e5					push hl 
1f60				 
1f60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1f60 cd 7c 19			call macro_forth_dsp_pop 
1f63				endm 
# End of macro FORTH_DSP_POP
1f63			 
1f63					; get byte to poke 
1f63			 
1f63					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f63 cd fc 18			call macro_dsp_valuehl 
1f66				endm 
# End of macro FORTH_DSP_VALUEHL
1f66 e5					push hl 
1f67			 
1f67			 
1f67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1f67 cd 7c 19			call macro_forth_dsp_pop 
1f6a				endm 
# End of macro FORTH_DSP_POP
1f6a			 
1f6a			 
1f6a d1					pop de 
1f6b e1					pop hl 
1f6c			 
1f6c 73					ld (hl),e 
1f6d			 
1f6d			 
1f6d					NEXTW 
1f6d c3 36 1a			jp macro_next 
1f70				endm 
# End of macro NEXTW
1f70			.CBANG: 
1f70				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
1f70 22				db WORD_SYS_CORE+OPCODE_CBANG             
1f71 99 1f			dw .SCALL            
1f73 03				db 2 + 1 
1f74 .. 00			db "C!",0              
1f77				endm 
# End of macro CWHEAD
1f77			; | C!  ( x w -- ) Store x at address w  | DONE 
1f77					if DEBUG_FORTH_WORDS_KEY 
1f77						DMARK "CBA" 
1f77 f5				push af  
1f78 3a 8c 1f			ld a, (.dmark)  
1f7b 32 bd fb			ld (debug_mark),a  
1f7e 3a 8d 1f			ld a, (.dmark+1)  
1f81 32 be fb			ld (debug_mark+1),a  
1f84 3a 8e 1f			ld a, (.dmark+2)  
1f87 32 bf fb			ld (debug_mark+2),a  
1f8a 18 03			jr .pastdmark  
1f8c ..			.dmark: db "CBA"  
1f8f f1			.pastdmark: pop af  
1f90			endm  
# End of macro DMARK
1f90						CALLMONITOR 
1f90 cd d7 12			call break_point_state  
1f93				endm  
# End of macro CALLMONITOR
1f93					endif 
1f93 c3 5c 1f				jp .storebyteat 
1f96					NEXTW 
1f96 c3 36 1a			jp macro_next 
1f99				endm 
# End of macro NEXTW
1f99			.SCALL: 
1f99				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
1f99 23				db WORD_SYS_CORE+OPCODE_SCALL             
1f9a cd 1f			dw .DEPTH            
1f9c 05				db 4 + 1 
1f9d .. 00			db "CALL",0              
1fa2				endm 
# End of macro CWHEAD
1fa2			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
1fa2					if DEBUG_FORTH_WORDS_KEY 
1fa2						DMARK "CLL" 
1fa2 f5				push af  
1fa3 3a b7 1f			ld a, (.dmark)  
1fa6 32 bd fb			ld (debug_mark),a  
1fa9 3a b8 1f			ld a, (.dmark+1)  
1fac 32 be fb			ld (debug_mark+1),a  
1faf 3a b9 1f			ld a, (.dmark+2)  
1fb2 32 bf fb			ld (debug_mark+2),a  
1fb5 18 03			jr .pastdmark  
1fb7 ..			.dmark: db "CLL"  
1fba f1			.pastdmark: pop af  
1fbb			endm  
# End of macro DMARK
1fbb						CALLMONITOR 
1fbb cd d7 12			call break_point_state  
1fbe				endm  
# End of macro CALLMONITOR
1fbe					endif 
1fbe			 
1fbe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1fbe cd fc 18			call macro_dsp_valuehl 
1fc1				endm 
# End of macro FORTH_DSP_VALUEHL
1fc1			 
1fc1			;		push hl 
1fc1			 
1fc1					; destroy value TOS 
1fc1			 
1fc1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
1fc1 cd 7c 19			call macro_forth_dsp_pop 
1fc4				endm 
# End of macro FORTH_DSP_POP
1fc4			 
1fc4						 
1fc4			;		pop hl 
1fc4			 
1fc4					; how to do a call with hl???? save SP? 
1fc4 cd df 19				call forth_call_hl 
1fc7			 
1fc7			 
1fc7					; TODO push value back onto stack for another op etc 
1fc7			 
1fc7 cd 61 18				call forth_push_numhl 
1fca					NEXTW 
1fca c3 36 1a			jp macro_next 
1fcd				endm 
# End of macro NEXTW
1fcd			.DEPTH: 
1fcd				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
1fcd 24				db WORD_SYS_CORE+OPCODE_DEPTH             
1fce 0a 20			dw .OVER            
1fd0 06				db 5 + 1 
1fd1 .. 00			db "DEPTH",0              
1fd7				endm 
# End of macro CWHEAD
1fd7			; | DEPTH ( -- u ) Push count of stack | DONE 
1fd7					; take current TOS and remove from base value div by two to get count 
1fd7					if DEBUG_FORTH_WORDS_KEY 
1fd7						DMARK "DEP" 
1fd7 f5				push af  
1fd8 3a ec 1f			ld a, (.dmark)  
1fdb 32 bd fb			ld (debug_mark),a  
1fde 3a ed 1f			ld a, (.dmark+1)  
1fe1 32 be fb			ld (debug_mark+1),a  
1fe4 3a ee 1f			ld a, (.dmark+2)  
1fe7 32 bf fb			ld (debug_mark+2),a  
1fea 18 03			jr .pastdmark  
1fec ..			.dmark: db "DEP"  
1fef f1			.pastdmark: pop af  
1ff0			endm  
# End of macro DMARK
1ff0						CALLMONITOR 
1ff0 cd d7 12			call break_point_state  
1ff3				endm  
# End of macro CALLMONITOR
1ff3					endif 
1ff3			 
1ff3			 
1ff3 2a a5 f9			ld hl, (cli_data_sp) 
1ff6 11 1f f5			ld de, cli_data_stack 
1ff9 ed 52			sbc hl,de 
1ffb				 
1ffb				; div by size of stack item 
1ffb			 
1ffb 5d				ld e,l 
1ffc 0e 03			ld c, 3 
1ffe cd a3 0a			call Div8 
2001			 
2001 6f				ld l,a 
2002 26 00			ld h,0 
2004			 
2004				;srl h 
2004				;rr l 
2004			 
2004 cd 61 18				call forth_push_numhl 
2007					NEXTW 
2007 c3 36 1a			jp macro_next 
200a				endm 
# End of macro NEXTW
200a			.OVER: 
200a				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
200a 42				db WORD_SYS_CORE+46             
200b 51 20			dw .PAUSE            
200d 05				db 4 + 1 
200e .. 00			db "OVER",0              
2013				endm 
# End of macro CWHEAD
2013			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2013					if DEBUG_FORTH_WORDS_KEY 
2013						DMARK "OVR" 
2013 f5				push af  
2014 3a 28 20			ld a, (.dmark)  
2017 32 bd fb			ld (debug_mark),a  
201a 3a 29 20			ld a, (.dmark+1)  
201d 32 be fb			ld (debug_mark+1),a  
2020 3a 2a 20			ld a, (.dmark+2)  
2023 32 bf fb			ld (debug_mark+2),a  
2026 18 03			jr .pastdmark  
2028 ..			.dmark: db "OVR"  
202b f1			.pastdmark: pop af  
202c			endm  
# End of macro DMARK
202c						CALLMONITOR 
202c cd d7 12			call break_point_state  
202f				endm  
# End of macro CALLMONITOR
202f					endif 
202f			 
202f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
202f cd fc 18			call macro_dsp_valuehl 
2032				endm 
# End of macro FORTH_DSP_VALUEHL
2032 e5					push hl    ; n2 
2033					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2033 cd 7c 19			call macro_forth_dsp_pop 
2036				endm 
# End of macro FORTH_DSP_POP
2036			 
2036					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2036 cd fc 18			call macro_dsp_valuehl 
2039				endm 
# End of macro FORTH_DSP_VALUEHL
2039 e5					push hl    ; n1 
203a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
203a cd 7c 19			call macro_forth_dsp_pop 
203d				endm 
# End of macro FORTH_DSP_POP
203d			 
203d d1					pop de     ; n1 
203e e1					pop hl     ; n2 
203f			 
203f d5					push de 
2040 e5					push hl 
2041 d5					push de 
2042			 
2042					; push back  
2042			 
2042 e1					pop hl 
2043 cd 61 18				call forth_push_numhl 
2046 e1					pop hl 
2047 cd 61 18				call forth_push_numhl 
204a e1					pop hl 
204b cd 61 18				call forth_push_numhl 
204e					NEXTW 
204e c3 36 1a			jp macro_next 
2051				endm 
# End of macro NEXTW
2051			 
2051			.PAUSE: 
2051				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2051 43				db WORD_SYS_CORE+47             
2052 86 20			dw .PAUSES            
2054 08				db 7 + 1 
2055 .. 00			db "PAUSEMS",0              
205d				endm 
# End of macro CWHEAD
205d			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
205d					if DEBUG_FORTH_WORDS_KEY 
205d						DMARK "PMS" 
205d f5				push af  
205e 3a 72 20			ld a, (.dmark)  
2061 32 bd fb			ld (debug_mark),a  
2064 3a 73 20			ld a, (.dmark+1)  
2067 32 be fb			ld (debug_mark+1),a  
206a 3a 74 20			ld a, (.dmark+2)  
206d 32 bf fb			ld (debug_mark+2),a  
2070 18 03			jr .pastdmark  
2072 ..			.dmark: db "PMS"  
2075 f1			.pastdmark: pop af  
2076			endm  
# End of macro DMARK
2076						CALLMONITOR 
2076 cd d7 12			call break_point_state  
2079				endm  
# End of macro CALLMONITOR
2079					endif 
2079					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2079 cd fc 18			call macro_dsp_valuehl 
207c				endm 
# End of macro FORTH_DSP_VALUEHL
207c			;		push hl    ; n2 
207c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
207c cd 7c 19			call macro_forth_dsp_pop 
207f				endm 
# End of macro FORTH_DSP_POP
207f			;		pop hl 
207f			 
207f 7d					ld a, l 
2080 cd 23 09				call aDelayInMS 
2083				       NEXTW 
2083 c3 36 1a			jp macro_next 
2086				endm 
# End of macro NEXTW
2086			.PAUSES:  
2086				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2086 44				db WORD_SYS_CORE+48             
2087 bd 20			dw .ROT            
2089 06				db 5 + 1 
208a .. 00			db "PAUSE",0              
2090				endm 
# End of macro CWHEAD
2090			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2090					if DEBUG_FORTH_WORDS_KEY 
2090						DMARK "PAU" 
2090 f5				push af  
2091 3a a5 20			ld a, (.dmark)  
2094 32 bd fb			ld (debug_mark),a  
2097 3a a6 20			ld a, (.dmark+1)  
209a 32 be fb			ld (debug_mark+1),a  
209d 3a a7 20			ld a, (.dmark+2)  
20a0 32 bf fb			ld (debug_mark+2),a  
20a3 18 03			jr .pastdmark  
20a5 ..			.dmark: db "PAU"  
20a8 f1			.pastdmark: pop af  
20a9			endm  
# End of macro DMARK
20a9						CALLMONITOR 
20a9 cd d7 12			call break_point_state  
20ac				endm  
# End of macro CALLMONITOR
20ac					endif 
20ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20ac cd fc 18			call macro_dsp_valuehl 
20af				endm 
# End of macro FORTH_DSP_VALUEHL
20af			;		push hl    ; n2 
20af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
20af cd 7c 19			call macro_forth_dsp_pop 
20b2				endm 
# End of macro FORTH_DSP_POP
20b2			;		pop hl 
20b2 45					ld b, l 
20b3					if DEBUG_FORTH_WORDS 
20b3						DMARK "PAU" 
20b3						CALLMONITOR 
20b3					endif 
20b3 c5			.pauses1:	push bc 
20b4 cd 3e 09				call delay1s 
20b7 c1					pop bc 
20b8					if DEBUG_FORTH_WORDS 
20b8						DMARK "PA1" 
20b8						CALLMONITOR 
20b8					endif 
20b8 10 f9				djnz .pauses1 
20ba			 
20ba				       NEXTW 
20ba c3 36 1a			jp macro_next 
20bd				endm 
# End of macro NEXTW
20bd			.ROT: 
20bd				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
20bd 45				db WORD_SYS_CORE+49             
20be 0b 21			dw .UWORDS            
20c0 04				db 3 + 1 
20c1 .. 00			db "ROT",0              
20c5				endm 
# End of macro CWHEAD
20c5			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
20c5					if DEBUG_FORTH_WORDS_KEY 
20c5						DMARK "ROT" 
20c5 f5				push af  
20c6 3a da 20			ld a, (.dmark)  
20c9 32 bd fb			ld (debug_mark),a  
20cc 3a db 20			ld a, (.dmark+1)  
20cf 32 be fb			ld (debug_mark+1),a  
20d2 3a dc 20			ld a, (.dmark+2)  
20d5 32 bf fb			ld (debug_mark+2),a  
20d8 18 03			jr .pastdmark  
20da ..			.dmark: db "ROT"  
20dd f1			.pastdmark: pop af  
20de			endm  
# End of macro DMARK
20de						CALLMONITOR 
20de cd d7 12			call break_point_state  
20e1				endm  
# End of macro CALLMONITOR
20e1					endif 
20e1			 
20e1					FORTH_DSP_VALUEHL 
20e1 cd fc 18			call macro_dsp_valuehl 
20e4				endm 
# End of macro FORTH_DSP_VALUEHL
20e4 e5					push hl    ; u3  
20e5			 
20e5					FORTH_DSP_POP 
20e5 cd 7c 19			call macro_forth_dsp_pop 
20e8				endm 
# End of macro FORTH_DSP_POP
20e8			   
20e8					FORTH_DSP_VALUEHL 
20e8 cd fc 18			call macro_dsp_valuehl 
20eb				endm 
# End of macro FORTH_DSP_VALUEHL
20eb e5					push hl     ; u2 
20ec			 
20ec					FORTH_DSP_POP 
20ec cd 7c 19			call macro_forth_dsp_pop 
20ef				endm 
# End of macro FORTH_DSP_POP
20ef			 
20ef					FORTH_DSP_VALUEHL 
20ef cd fc 18			call macro_dsp_valuehl 
20f2				endm 
# End of macro FORTH_DSP_VALUEHL
20f2 e5					push hl     ; u1 
20f3			 
20f3					FORTH_DSP_POP 
20f3 cd 7c 19			call macro_forth_dsp_pop 
20f6				endm 
# End of macro FORTH_DSP_POP
20f6			 
20f6 c1					pop bc      ; u1 
20f7 e1					pop hl      ; u2 
20f8 d1					pop de      ; u3 
20f9			 
20f9			 
20f9 c5					push bc 
20fa d5					push de 
20fb e5					push hl 
20fc			 
20fc			 
20fc e1					pop hl 
20fd cd 61 18				call forth_push_numhl 
2100			 
2100 e1					pop hl 
2101 cd 61 18				call forth_push_numhl 
2104			 
2104 e1					pop hl 
2105 cd 61 18				call forth_push_numhl 
2108					 
2108			 
2108			 
2108			 
2108			 
2108			 
2108				       NEXTW 
2108 c3 36 1a			jp macro_next 
210b				endm 
# End of macro NEXTW
210b			 
210b			.UWORDS: 
210b				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
210b 50				db WORD_SYS_CORE+60             
210c 5d 21			dw .BP            
210e 07				db 6 + 1 
210f .. 00			db "UWORDS",0              
2116				endm 
# End of macro CWHEAD
2116			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2116			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2116			; | | Following the count are the individual words. 
2116			; | | 
2116			; | | e.g. UWORDS 
2116			; | | BOX DIRLIST 2 
2116			; | |  
2116			; | | Can be used to save the words to storage via: 
2116			; | | UWORDS $01 DO $01 APPEND LOOP 
2116				if DEBUG_FORTH_WORDS_KEY 
2116					DMARK "UWR" 
2116 f5				push af  
2117 3a 2b 21			ld a, (.dmark)  
211a 32 bd fb			ld (debug_mark),a  
211d 3a 2c 21			ld a, (.dmark+1)  
2120 32 be fb			ld (debug_mark+1),a  
2123 3a 2d 21			ld a, (.dmark+2)  
2126 32 bf fb			ld (debug_mark+2),a  
2129 18 03			jr .pastdmark  
212b ..			.dmark: db "UWR"  
212e f1			.pastdmark: pop af  
212f			endm  
# End of macro DMARK
212f					CALLMONITOR 
212f cd d7 12			call break_point_state  
2132				endm  
# End of macro CALLMONITOR
2132				endif 
2132 21 00 80				ld hl, baseram 
2135					;ld hl, baseusermem 
2135 01 00 00				ld bc, 0    ; start a counter 
2138			 
2138				; skip dict stub 
2138			 
2138 cd 87 1b				call forth_tok_next 
213b			 
213b			 
213b			; while we have words to look for 
213b			 
213b 7e			.douscan:	ld a, (hl)      
213c				if DEBUG_FORTH_WORDS 
213c					DMARK "UWs" 
213c					CALLMONITOR 
213c				endif 
213c fe 00				cp WORD_SYS_END 
213e 28 15				jr z, .udone 
2140 fe 01				cp WORD_SYS_UWORD 
2142 20 0c				jr nz, .nuword 
2144			 
2144				if DEBUG_FORTH_WORDS 
2144					DMARK "UWu" 
2144					CALLMONITOR 
2144				endif 
2144					; we have a uword so push its name to the stack 
2144			 
2144 e5				   	push hl  ; save so we can move to next dict block 
2145			 
2145					; skip opcode 
2145 23					inc hl  
2146					; skip next ptr 
2146 23					inc hl  
2147 23					inc hl 
2148					; skip len 
2148 23					inc hl 
2149				if DEBUG_FORTH_WORDS 
2149					DMARK "UWt" 
2149					CALLMONITOR 
2149				endif 
2149 03					inc bc 
214a			 
214a c5					push bc 
214b cd 73 18				call forth_push_str 
214e c1					pop bc 
214f			 
214f e1					pop hl 	 
2150			 
2150 cd 87 1b		.nuword:	call forth_tok_next 
2153 18 e6				jr .douscan  
2155			 
2155			.udone:		 ; push count of uwords found 
2155 c5					push bc 
2156 e1					pop hl 
2157			 
2157				if DEBUG_FORTH_WORDS 
2157					DMARK "UWc" 
2157					CALLMONITOR 
2157				endif 
2157 cd 61 18				call forth_push_numhl 
215a			 
215a			 
215a				       NEXTW 
215a c3 36 1a			jp macro_next 
215d				endm 
# End of macro NEXTW
215d			 
215d			.BP: 
215d				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
215d 54				db WORD_SYS_CORE+64             
215e 93 21			dw .MONITOR            
2160 03				db 2 + 1 
2161 .. 00			db "BP",0              
2164				endm 
# End of macro CWHEAD
2164			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2164			; | | $00 Will enable the break points within specific code paths 
2164			; | | $01 Will disable break points 
2164			; | |  
2164			; | | By default break points are off. Either the above can be used to enable them 
2164			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2164			; | | and on release of the pressed key a message will be disaplayed to notify 
2164			; | | that break points are enabled. Pressing any key will then continue boot process. 
2164					; get byte count 
2164					if DEBUG_FORTH_WORDS_KEY 
2164						DMARK "BP." 
2164 f5				push af  
2165 3a 79 21			ld a, (.dmark)  
2168 32 bd fb			ld (debug_mark),a  
216b 3a 7a 21			ld a, (.dmark+1)  
216e 32 be fb			ld (debug_mark+1),a  
2171 3a 7b 21			ld a, (.dmark+2)  
2174 32 bf fb			ld (debug_mark+2),a  
2177 18 03			jr .pastdmark  
2179 ..			.dmark: db "BP."  
217c f1			.pastdmark: pop af  
217d			endm  
# End of macro DMARK
217d						CALLMONITOR 
217d cd d7 12			call break_point_state  
2180				endm  
# End of macro CALLMONITOR
2180					endif 
2180			 
2180					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2180 cd fc 18			call macro_dsp_valuehl 
2183				endm 
# End of macro FORTH_DSP_VALUEHL
2183			 
2183			;		push hl 
2183			 
2183					; destroy value TOS 
2183			 
2183					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2183 cd 7c 19			call macro_forth_dsp_pop 
2186				endm 
# End of macro FORTH_DSP_POP
2186			 
2186			;		pop hl 
2186			 
2186 3e 00				ld a,0 
2188 bd					cp l 
2189 28 02				jr z, .bpset 
218b 3e 2a				ld a, '*' 
218d			 
218d 32 b7 ef		.bpset:		ld (os_view_disable), a 
2190			 
2190			 
2190					NEXTW 
2190 c3 36 1a			jp macro_next 
2193				endm 
# End of macro NEXTW
2193			 
2193			 
2193			.MONITOR: 
2193				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2193 55				db WORD_SYS_CORE+65             
2194 c6 21			dw .MALLOC            
2196 08				db 7 + 1 
2197 .. 00			db "MONITOR",0              
219f				endm 
# End of macro CWHEAD
219f			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
219f			; | | At start the current various registers will be displayed with contents. 
219f			; | | Top right corner will show the most recent debug marker seen. 
219f			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
219f			; | | and the return stack pointer (RSP). 
219f			; | | Pressing: 
219f			; | |    1 - Initial screen 
219f			; | |    2 - Display a data dump of HL 
219f			; | |    3 - Display a data dump of DE 
219f			; | |    4 - Display a data dump of BC 
219f			; | |    5 - Display a data dump of HL 
219f			; | |    6 - Display a data dump of DSP 
219f			; | |    7 - Display a data dump of RSP 
219f			; | |    8 - Display a data dump of what is at DSP 
219f			; | |    9 - Display a data dump of what is at RSP 
219f			; | |    0 - Exit monitor and continue running. This will also enable break points 
219f			; | |    * - Disable break points 
219f			; | |    # - Enter traditional monitor mode 
219f			; | | 
219f			; | | Monitor Mode 
219f			; | | ------------ 
219f			; | | A prompt of '>' will be shown for various commands: 
219f			; | |    D xxxx - Display a data dump starting from hex address xxxx 
219f			; | |    C - Continue display a data dump from the last set address 
219f			; | |    M xxxx - Set start of memory edit at address xx 
219f			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
219f			; | |    Q - Return to previous 
219f					if DEBUG_FORTH_WORDS_KEY 
219f						DMARK "MON" 
219f f5				push af  
21a0 3a b4 21			ld a, (.dmark)  
21a3 32 bd fb			ld (debug_mark),a  
21a6 3a b5 21			ld a, (.dmark+1)  
21a9 32 be fb			ld (debug_mark+1),a  
21ac 3a b6 21			ld a, (.dmark+2)  
21af 32 bf fb			ld (debug_mark+2),a  
21b2 18 03			jr .pastdmark  
21b4 ..			.dmark: db "MON"  
21b7 f1			.pastdmark: pop af  
21b8			endm  
# End of macro DMARK
21b8						CALLMONITOR 
21b8 cd d7 12			call break_point_state  
21bb				endm  
# End of macro CALLMONITOR
21bb					endif 
21bb 3e 00				ld a, 0 
21bd 32 b7 ef				ld (os_view_disable), a 
21c0			 
21c0					CALLMONITOR 
21c0 cd d7 12			call break_point_state  
21c3				endm  
# End of macro CALLMONITOR
21c3			 
21c3			;	call monitor 
21c3			 
21c3					NEXTW 
21c3 c3 36 1a			jp macro_next 
21c6				endm 
# End of macro NEXTW
21c6			 
21c6			 
21c6			.MALLOC: 
21c6				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
21c6 56				db WORD_SYS_CORE+66             
21c7 ef 21			dw .MALLOC2            
21c9 06				db 5 + 1 
21ca .. 00			db "ALLOT",0              
21d0				endm 
# End of macro CWHEAD
21d0			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
21d0					if DEBUG_FORTH_WORDS_KEY 
21d0						DMARK "ALL" 
21d0 f5				push af  
21d1 3a e5 21			ld a, (.dmark)  
21d4 32 bd fb			ld (debug_mark),a  
21d7 3a e6 21			ld a, (.dmark+1)  
21da 32 be fb			ld (debug_mark+1),a  
21dd 3a e7 21			ld a, (.dmark+2)  
21e0 32 bf fb			ld (debug_mark+2),a  
21e3 18 03			jr .pastdmark  
21e5 ..			.dmark: db "ALL"  
21e8 f1			.pastdmark: pop af  
21e9			endm  
# End of macro DMARK
21e9						CALLMONITOR 
21e9 cd d7 12			call break_point_state  
21ec				endm  
# End of macro CALLMONITOR
21ec					endif 
21ec c3 16 22				jp .mallocc 
21ef			.MALLOC2: 
21ef				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
21ef 56				db WORD_SYS_CORE+66             
21f0 2d 22			dw .FREE            
21f2 07				db 6 + 1 
21f3 .. 00			db "MALLOC",0              
21fa				endm 
# End of macro CWHEAD
21fa			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
21fa					; get byte count 
21fa					if DEBUG_FORTH_WORDS_KEY 
21fa						DMARK "MAL" 
21fa f5				push af  
21fb 3a 0f 22			ld a, (.dmark)  
21fe 32 bd fb			ld (debug_mark),a  
2201 3a 10 22			ld a, (.dmark+1)  
2204 32 be fb			ld (debug_mark+1),a  
2207 3a 11 22			ld a, (.dmark+2)  
220a 32 bf fb			ld (debug_mark+2),a  
220d 18 03			jr .pastdmark  
220f ..			.dmark: db "MAL"  
2212 f1			.pastdmark: pop af  
2213			endm  
# End of macro DMARK
2213						CALLMONITOR 
2213 cd d7 12			call break_point_state  
2216				endm  
# End of macro CALLMONITOR
2216					endif 
2216			.mallocc: 
2216					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2216 cd fc 18			call macro_dsp_valuehl 
2219				endm 
# End of macro FORTH_DSP_VALUEHL
2219			 
2219			;		push hl 
2219			 
2219					; destroy value TOS 
2219			 
2219					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2219 cd 7c 19			call macro_forth_dsp_pop 
221c				endm 
# End of macro FORTH_DSP_POP
221c			 
221c			;		pop hl 
221c cd da 0f				call malloc 
221f				if DEBUG_FORTH_MALLOC_GUARD 
221f f5					push af 
2220 cd 3c 0b				call ishlzero 
2223			;		ld a, l 
2223			;		add h 
2223			;		cp 0 
2223 f1					pop af 
2224					 
2224 cc 38 3f				call z,malloc_error 
2227				endif 
2227			 
2227 cd 61 18				call forth_push_numhl 
222a					NEXTW 
222a c3 36 1a			jp macro_next 
222d				endm 
# End of macro NEXTW
222d			 
222d			.FREE: 
222d				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
222d 57				db WORD_SYS_CORE+67             
222e 5e 22			dw .LIST            
2230 05				db 4 + 1 
2231 .. 00			db "FREE",0              
2236				endm 
# End of macro CWHEAD
2236			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2236					if DEBUG_FORTH_WORDS_KEY 
2236						DMARK "FRE" 
2236 f5				push af  
2237 3a 4b 22			ld a, (.dmark)  
223a 32 bd fb			ld (debug_mark),a  
223d 3a 4c 22			ld a, (.dmark+1)  
2240 32 be fb			ld (debug_mark+1),a  
2243 3a 4d 22			ld a, (.dmark+2)  
2246 32 bf fb			ld (debug_mark+2),a  
2249 18 03			jr .pastdmark  
224b ..			.dmark: db "FRE"  
224e f1			.pastdmark: pop af  
224f			endm  
# End of macro DMARK
224f						CALLMONITOR 
224f cd d7 12			call break_point_state  
2252				endm  
# End of macro CALLMONITOR
2252					endif 
2252					; get address 
2252			 
2252					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2252 cd fc 18			call macro_dsp_valuehl 
2255				endm 
# End of macro FORTH_DSP_VALUEHL
2255			 
2255			;		push hl 
2255			 
2255					; destroy value TOS 
2255			 
2255					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2255 cd 7c 19			call macro_forth_dsp_pop 
2258				endm 
# End of macro FORTH_DSP_POP
2258			 
2258			;		pop hl 
2258			if FORTH_ENABLE_MALLOCFREE 
2258 cd a4 10				call free 
225b			endif 
225b					NEXTW 
225b c3 36 1a			jp macro_next 
225e				endm 
# End of macro NEXTW
225e			.LIST: 
225e				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
225e 5c				db WORD_SYS_CORE+72             
225f 09 23			dw .FORGET            
2261 05				db 4 + 1 
2262 .. 00			db "LIST",0              
2267				endm 
# End of macro CWHEAD
2267			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2267			; | | The quoted word must be in upper case. 
2267				if DEBUG_FORTH_WORDS_KEY 
2267					DMARK "LST" 
2267 f5				push af  
2268 3a 7c 22			ld a, (.dmark)  
226b 32 bd fb			ld (debug_mark),a  
226e 3a 7d 22			ld a, (.dmark+1)  
2271 32 be fb			ld (debug_mark+1),a  
2274 3a 7e 22			ld a, (.dmark+2)  
2277 32 bf fb			ld (debug_mark+2),a  
227a 18 03			jr .pastdmark  
227c ..			.dmark: db "LST"  
227f f1			.pastdmark: pop af  
2280			endm  
# End of macro DMARK
2280					CALLMONITOR 
2280 cd d7 12			call break_point_state  
2283				endm  
# End of macro CALLMONITOR
2283				endif 
2283			 
2283					FORTH_DSP_VALUEHL 
2283 cd fc 18			call macro_dsp_valuehl 
2286				endm 
# End of macro FORTH_DSP_VALUEHL
2286			 
2286 e5					push hl 
2287 c1					pop bc 
2288			 
2288			; Start format of scratch string 
2288			 
2288 21 b8 ef				ld hl, scratch 
228b			 
228b 3e 3a				ld a, ':' 
228d 77					ld (hl),a 
228e 23					inc hl 
228f 3e 20				ld a, ' ' 
2291 77					ld (hl), a 
2292			 
2292					; Get ptr to the word we need to look up 
2292			 
2292			;		FORTH_DSP_VALUEHL 
2292					;v5 FORTH_DSP_VALUE 
2292				; TODO type check 
2292			;		inc hl    ; Skip type check  
2292			;		push hl 
2292			;		ex de, hl    ; put into DE 
2292			 
2292			 
2292 21 00 80				ld hl, baseram 
2295					;ld hl, baseusermem 
2295			 
2295 e5			push hl   ; sacreifical push 
2296			 
2296			.ldouscanm: 
2296 e1				pop hl 
2297			.ldouscan: 
2297				if DEBUG_FORTH_WORDS 
2297					DMARK "LSs" 
2297					CALLMONITOR 
2297				endif 
2297				; skip dict stub 
2297 cd 87 1b				call forth_tok_next 
229a			 
229a			 
229a			; while we have words to look for 
229a			 
229a 7e				ld a, (hl)      
229b				if DEBUG_FORTH_WORDS 
229b					DMARK "LSk" 
229b					CALLMONITOR 
229b				endif 
229b fe 00				cp WORD_SYS_END 
229d ca f0 22				jp z, .lunotfound 
22a0 fe 01				cp WORD_SYS_UWORD 
22a2 c2 97 22				jp nz, .ldouscan 
22a5			 
22a5				if DEBUG_FORTH_WORDS 
22a5					DMARK "LSu" 
22a5					CALLMONITOR 
22a5				endif 
22a5			 
22a5					; found a uword but is it the one we want... 
22a5			 
22a5 c5					push bc     ; uword to find is on bc 
22a6 d1					pop de 
22a7			 
22a7 e5					push hl  ; to save the ptr 
22a8			 
22a8					; skip opcode 
22a8 23					inc hl  
22a9					; skip next ptr 
22a9 23					inc hl  
22aa 23					inc hl 
22ab					; skip len 
22ab 23					inc hl 
22ac			 
22ac				if DEBUG_FORTH_WORDS 
22ac					DMARK "LSc" 
22ac					CALLMONITOR 
22ac				endif 
22ac cd a9 0f				call strcmp 
22af c2 96 22				jp nz, .ldouscanm 
22b2				 
22b2			 
22b2			 
22b2					; we have a uword so push its name to the stack 
22b2			 
22b2			;	   	push hl  ; save so we can move to next dict block 
22b2 e1			pop hl 
22b3			 
22b3				if DEBUG_FORTH_WORDS 
22b3					DMARK "LSm" 
22b3					CALLMONITOR 
22b3				endif 
22b3			 
22b3					; skip opcode 
22b3 23					inc hl  
22b4					; skip next ptr 
22b4 23					inc hl  
22b5 23					inc hl 
22b6					; skip len 
22b6 7e					ld a, (hl)   ; save length to add 
22b7				if DEBUG_FORTH_WORDS 
22b7					DMARK "LS2" 
22b7					CALLMONITOR 
22b7				endif 
22b7			 
22b7					; save this location 
22b7				 
22b7 e5					push hl 
22b8			 
22b8 23					inc hl 
22b9 11 ba ef				ld de, scratch+2 
22bc 4f					ld c, a 
22bd 06 00				ld b, 0 
22bf			 
22bf				if DEBUG_FORTH_WORDS 
22bf					DMARK "LSn" 
22bf					CALLMONITOR 
22bf				endif 
22bf			 
22bf					; copy uword name to scratch 
22bf			 
22bf ed b0				ldir 
22c1			 
22c1 1b					dec de 
22c2 3e 20				ld a, ' '    ; change null to space 
22c4 12					ld (de), a 
22c5			 
22c5 13					inc de 
22c6			 
22c6 d5					push de 
22c7 c1					pop bc     ; move scratch pointer to end of word name and save it 
22c8			 
22c8 e1					pop hl 
22c9 7e					ld a, (hl) 
22ca					;inc hl 
22ca					; skip word string 
22ca cd 13 0b				call addatohl 
22cd			 
22cd 23					inc hl 
22ce			 
22ce				if DEBUG_FORTH_WORDS 
22ce					DMARK "LS3" 
22ce					CALLMONITOR 
22ce				endif 
22ce					; should now be at the start of the machine code to setup the eval of the uword 
22ce					; now locate the ptr to the string defintion 
22ce			 
22ce					; skip ld hl, 
22ce					; then load the ptr 
22ce			 
22ce 23					inc hl 
22cf 5e					ld e, (hl) 
22d0 23					inc hl 
22d1 56					ld d, (hl) 
22d2 eb					ex de, hl 
22d3			 
22d3			 
22d3				if DEBUG_FORTH_WORDS 
22d3					DMARK "LSt" 
22d3					CALLMONITOR 
22d3				endif 
22d3			 
22d3			; cant push right now due to tokenised strings  
22d3			 
22d3			; get the destination of where to copy this definition to. 
22d3			 
22d3 c5					push bc 
22d4 d1					pop de 
22d5			 
22d5 7e			.listl:         ld a,(hl) 
22d6 fe 00				cp 0 
22d8 28 09				jr z, .lreplsp     ; replace zero with space 
22da fe 7f				cp FORTH_END_BUFFER 
22dc 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
22de				 
22de					; just copy this char as is then 
22de			 
22de 12					ld (de), a 
22df			 
22df 23			.listnxt:	inc hl 
22e0 13					inc de 
22e1 18 f2				jr .listl 
22e3			 
22e3 3e 20		.lreplsp:	ld a,' ' 
22e5 12					ld (de), a 
22e6 18 f7				jr .listnxt 
22e8			 
22e8			; close up uword def 
22e8			 
22e8			.listdone: 
22e8 3e 00				ld a, 0 
22ea 12					ld (de), a 
22eb			 
22eb			; now have def so clean up and push to stack 
22eb			 
22eb 21 b8 ef				ld hl, scratch 
22ee				if DEBUG_FORTH_WORDS 
22ee					DMARK "Ltp" 
22ee					CALLMONITOR 
22ee				endif 
22ee			 
22ee 18 06			jr .listpush 
22f0			 
22f0			;.lnuword:	pop hl 
22f0			;		call forth_tok_next 
22f0			;		jp .ldouscan  
22f0			 
22f0			.lunotfound:		  
22f0			 
22f0			 
22f0					 
22f0					FORTH_DSP_POP 
22f0 cd 7c 19			call macro_forth_dsp_pop 
22f3				endm 
# End of macro FORTH_DSP_POP
22f3 21 fc 22				ld hl, .luno 
22f6						 
22f6			 
22f6			.listpush: 
22f6 cd 73 18				call forth_push_str 
22f9			 
22f9			 
22f9			 
22f9					NEXTW 
22f9 c3 36 1a			jp macro_next 
22fc				endm 
# End of macro NEXTW
22fc			 
22fc .. 00		.luno:    db "Not found",0 
2306			 
2306			 
2306			 
2306			 
2306			 
2306			;		push hl   ; save pointer to start of uword def string 
2306			; 
2306			;; look for FORTH_EOL_LINE 
2306			;		ld a, FORTH_END_BUFFER 
2306			;		call strlent 
2306			; 
2306			;		inc hl		 ; space for coln def 
2306			;		inc hl 
2306			;		inc hl          ; space for terms 
2306			;		inc hl 
2306			; 
2306			;		ld a, 20   ; TODO get actual length 
2306			;		call addatohl    ; include a random amount of room for the uword name 
2306			; 
2306			;		 
2306			;	if DEBUG_FORTH_WORDS 
2306			;		DMARK "Lt1" 
2306			;		CALLMONITOR 
2306			;	endif 
2306			;		 
2306			; 
2306			;; malloc space for the string because we cant change it 
2306			; 
2306			;		call malloc 
2306			;	if DEBUG_FORTH_MALLOC_GUARD 
2306			;		push af 
2306			;		call ishlzero 
2306			;		pop af 
2306			;		 
2306			;		call z,malloc_error 
2306			;	endif 
2306			; 
2306			;	if DEBUG_FORTH_WORDS 
2306			;		DMARK "Lt2" 
2306			;		CALLMONITOR 
2306			;	endif 
2306			;		pop de 
2306			;		push hl    ; push the malloc to release later 
2306			;		push hl   ;  push back a copy for the later stack push 
2306			;		 
2306			;; copy the string swapping out the zero terms for spaces 
2306			; 
2306			;		; de has our source 
2306			;		; hl has our dest 
2306			; 
2306			;; add the coln def 
2306			; 
2306			;		ld a, ':' 
2306			;		ld (hl), a 
2306			;		inc hl 
2306			;		ld a, ' ' 
2306			;		ld (hl), a 
2306			;		inc hl 
2306			; 
2306			;; add the uname word 
2306			;		push de   ; save our string for now 
2306			;		ex de, hl 
2306			; 
2306			;		FORTH_DSP_VALUE 
2306			;		;v5 FORTH_DSP_VALUE 
2306			; 
2306			;		inc hl   ; skip type but we know by now this is OK 
2306			; 
2306			;.luword:	ld a,(hl) 
2306			;		cp 0 
2306			;		jr z, .luword2 
2306			;		ld (de), a 
2306			;		inc de 
2306			;		inc hl 
2306			;		jr .luword 
2306			; 
2306			;.luword2:	ld a, ' ' 
2306			;		ld (de), a 
2306			;;		inc hl 
2306			;;		inc de 
2306			;;		ld (de), a 
2306			;;		inc hl 
2306			;		inc de 
2306			; 
2306			;		ex de, hl 
2306			;		pop de 
2306			;		 
2306			;		 
2306			; 
2306			;; detoken that string and copy it 
2306			; 
2306			;	if DEBUG_FORTH_WORDS 
2306			;		DMARK "Lt2" 
2306			;		CALLMONITOR 
2306			;	endif 
2306			;.ldetok:	ld a, (de) 
2306			;		cp FORTH_END_BUFFER 
2306			;		jr z, .ldetokend 
2306			;		; swap out any zero term for space 
2306			;		cp 0 
2306			;		jr nz, .ldetoknext 
2306			;		ld a, ' ' 
2306			; 
2306			;	if DEBUG_FORTH_WORDS 
2306			;		DMARK "LtS" 
2306			;		CALLMONITOR 
2306			;	endif 
2306			;.ldetoknext:	ld (hl), a 
2306			;		inc de 
2306			;		inc hl 
2306			;		jr .ldetok 
2306			; 
2306			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2306			;		ld (hl), a  
2306			; 
2306			;; free that temp malloc 
2306			; 
2306			;		pop hl    
2306			; 
2306			;	if DEBUG_FORTH_WORDS 
2306			;		DMARK "Lt4" 
2306			;		CALLMONITOR 
2306			;	endif 
2306			;		call forth_apushstrhl 
2306			; 
2306			;		; get rid of temp malloc area 
2306			; 
2306			;		pop hl 
2306			;		call free 
2306			; 
2306			;		jr .ludone 
2306			; 
2306			;.lnuword:	pop hl 
2306			;		call forth_tok_next 
2306			;		jp .ldouscan  
2306			; 
2306			;.ludone:		 pop hl 
2306			; 
2306					NEXTW 
2306 c3 36 1a			jp macro_next 
2309				endm 
# End of macro NEXTW
2309			 
2309			.FORGET: 
2309				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2309 5d				db WORD_SYS_CORE+73             
230a 66 23			dw .NOP            
230c 07				db 6 + 1 
230d .. 00			db "FORGET",0              
2314				endm 
# End of macro CWHEAD
2314			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2314			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2314			; | |  
2314			; | | e.g. "MORE" forget 
2314					if DEBUG_FORTH_WORDS_KEY 
2314						DMARK "FRG" 
2314 f5				push af  
2315 3a 29 23			ld a, (.dmark)  
2318 32 bd fb			ld (debug_mark),a  
231b 3a 2a 23			ld a, (.dmark+1)  
231e 32 be fb			ld (debug_mark+1),a  
2321 3a 2b 23			ld a, (.dmark+2)  
2324 32 bf fb			ld (debug_mark+2),a  
2327 18 03			jr .pastdmark  
2329 ..			.dmark: db "FRG"  
232c f1			.pastdmark: pop af  
232d			endm  
# End of macro DMARK
232d						CALLMONITOR 
232d cd d7 12			call break_point_state  
2330				endm  
# End of macro CALLMONITOR
2330					endif 
2330			 
2330				; find uword 
2330			        ; update start of word with "_" 
2330				; replace uword with deleted flag 
2330			 
2330			 
2330			;	if DEBUG_FORTH_WORDS 
2330			;		DMARK "FOG" 
2330			;		CALLMONITOR 
2330			;	endif 
2330			 
2330			 
2330					; Get ptr to the word we need to look up 
2330			 
2330					FORTH_DSP_VALUEHL 
2330 cd fc 18			call macro_dsp_valuehl 
2333				endm 
# End of macro FORTH_DSP_VALUEHL
2333					;v5 FORTH_DSP_VALUE 
2333				; TODO type check 
2333			;		inc hl    ; Skip type check  
2333 e5					push hl 
2334 c1					pop bc 
2335			;		ex de, hl    ; put into DE 
2335			 
2335			 
2335 21 00 80				ld hl, baseram 
2338					;ld hl, baseusermem 
2338			 
2338				; skip dict stub 
2338			;	call forth_tok_next 
2338 e5			push hl   ; sacreifical push 
2339			 
2339			.fldouscanm: 
2339 e1				pop hl 
233a			.fldouscan: 
233a			;	if DEBUG_FORTH_WORDS 
233a			;		DMARK "LSs" 
233a			;		CALLMONITOR 
233a			;	endif 
233a				; skip dict stub 
233a cd 87 1b				call forth_tok_next 
233d			 
233d			 
233d			; while we have words to look for 
233d			 
233d 7e				ld a, (hl)      
233e			;	if DEBUG_FORTH_WORDS 
233e			;		DMARK "LSk" 
233e			;		CALLMONITOR 
233e			;	endif 
233e fe 00				cp WORD_SYS_END 
2340 ca 60 23				jp z, .flunotfound 
2343 fe 01				cp WORD_SYS_UWORD 
2345 c2 3a 23				jp nz, .fldouscan 
2348			 
2348			;	if DEBUG_FORTH_WORDS 
2348			;		DMARK "LSu" 
2348			;		CALLMONITOR 
2348			;	endif 
2348			 
2348					; found a uword but is it the one we want... 
2348			 
2348 c5					push bc     ; uword to find is on bc 
2349 d1					pop de 
234a			 
234a e5					push hl  ; to save the ptr 
234b			 
234b					; skip opcode 
234b 23					inc hl  
234c					; skip next ptr 
234c 23					inc hl  
234d 23					inc hl 
234e					; skip len 
234e 23					inc hl 
234f			 
234f			;	if DEBUG_FORTH_WORDS 
234f			;		DMARK "LSc" 
234f			;		CALLMONITOR 
234f			;	endif 
234f cd a9 0f				call strcmp 
2352 c2 39 23				jp nz, .fldouscanm 
2355			; 
2355			; 
2355			;; while we have words to look for 
2355			; 
2355			;.fdouscan:	ld a, (hl)      
2355			;	if DEBUG_FORTH_WORDS 
2355			;		DMARK "LSs" 
2355			;		CALLMONITOR 
2355			;	endif 
2355			;		cp WORD_SYS_END 
2355			;		jp z, .fudone 
2355			;		cp WORD_SYS_UWORD 
2355			;		jp nz, .fnuword 
2355			; 
2355			;	if DEBUG_FORTH_WORDS 
2355			;		DMARK "FGu" 
2355			;		CALLMONITOR 
2355			;	endif 
2355			; 
2355			;		; found a uword but is it the one we want... 
2355			; 
2355			; 
2355			;	        pop de   ; get back the dsp name 
2355			;		push de 
2355			; 
2355			;		push hl  ; to save the ptr 
2355			; 
2355			;		; skip opcode 
2355			;		inc hl  
2355			;		; skip next ptr 
2355			;		inc hl  
2355			;		inc hl 
2355			;		; skip len 
2355			;		inc hl 
2355			; 
2355			;	if DEBUG_FORTH_WORDS 
2355			;		DMARK "FGc" 
2355			;		CALLMONITOR 
2355			;	endif 
2355			;		call strcmp 
2355			;		jp nz, .fnuword 
2355			 
2355			 
2355 e1			pop hl 
2356			 
2356				 
2356				if DEBUG_FORTH_WORDS 
2356					DMARK "FGm" 
2356					CALLMONITOR 
2356				endif 
2356			 
2356			 
2356			 
2356					; we have a uword so push its name to the stack 
2356			 
2356			;	   	push hl  ; save so we can move to next dict block 
2356			;pop hl 
2356			 
2356					; update opcode to deleted 
2356 3e 03				ld a, WORD_SYS_DELETED 
2358 77					ld (hl), a 
2359			 
2359 23					inc hl  
235a					; skip next ptr 
235a 23					inc hl  
235b 23					inc hl 
235c					; skip len 
235c 23					inc hl 
235d			 
235d					; TODO change parser to skip deleted words but for now mark it out 
235d 3e 5f				ld a, "_" 
235f 77					ld  (hl),a 
2360			 
2360			;		jr .fudone 
2360			; 
2360			;.fnuword:	pop hl 
2360			;		call forth_tok_next 
2360			;		jp .fdouscan  
2360			 
2360			.flunotfound:		  
2360			 
2360			 
2360					 
2360					FORTH_DSP_POP 
2360 cd 7c 19			call macro_forth_dsp_pop 
2363				endm 
# End of macro FORTH_DSP_POP
2363			;		ld hl, .luno 
2363			;.fudone:		 pop hl 
2363					NEXTW 
2363 c3 36 1a			jp macro_next 
2366				endm 
# End of macro NEXTW
2366			.NOP: 
2366				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2366 61				db WORD_SYS_CORE+77             
2367 8d 23			dw .COMO            
2369 04				db 3 + 1 
236a .. 00			db "NOP",0              
236e				endm 
# End of macro CWHEAD
236e			; | NOP (  --  ) Do nothing | DONE 
236e					if DEBUG_FORTH_WORDS_KEY 
236e						DMARK "NOP" 
236e f5				push af  
236f 3a 83 23			ld a, (.dmark)  
2372 32 bd fb			ld (debug_mark),a  
2375 3a 84 23			ld a, (.dmark+1)  
2378 32 be fb			ld (debug_mark+1),a  
237b 3a 85 23			ld a, (.dmark+2)  
237e 32 bf fb			ld (debug_mark+2),a  
2381 18 03			jr .pastdmark  
2383 ..			.dmark: db "NOP"  
2386 f1			.pastdmark: pop af  
2387			endm  
# End of macro DMARK
2387						CALLMONITOR 
2387 cd d7 12			call break_point_state  
238a				endm  
# End of macro CALLMONITOR
238a					endif 
238a				       NEXTW 
238a c3 36 1a			jp macro_next 
238d				endm 
# End of macro NEXTW
238d			.COMO: 
238d				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
238d 6e				db WORD_SYS_CORE+90             
238e a7 23			dw .COMC            
2390 02				db 1 + 1 
2391 .. 00			db "(",0              
2393				endm 
# End of macro CWHEAD
2393			; | ( ( -- )  Start of comment | DONE 
2393			 
2393			 
2393 2a b9 f2				ld hl, ( os_tok_ptr) 
2396 11 a2 23			ld de, .closepar 
2399					 
2399					if DEBUG_FORTH_WORDS 
2399						DMARK ").." 
2399						CALLMONITOR 
2399					endif 
2399 cd 51 1b			call findnexttok  
239c			 
239c					if DEBUG_FORTH_WORDS 
239c						DMARK "IF5" 
239c						CALLMONITOR 
239c					endif 
239c				; replace below with ) exec using tok_ptr 
239c 22 b9 f2			ld (os_tok_ptr), hl 
239f c3 c7 1a			jp exec1 
23a2			 
23a2 .. 00			.closepar:   db ")",0 
23a4			 
23a4				       NEXTW 
23a4 c3 36 1a			jp macro_next 
23a7				endm 
# End of macro NEXTW
23a7			.COMC: 
23a7				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
23a7 6f				db WORD_SYS_CORE+91             
23a8 b0 23			dw .SCRATCH            
23aa 02				db 1 + 1 
23ab .. 00			db ")",0              
23ad				endm 
# End of macro CWHEAD
23ad			; | ) ( -- )  End of comment |  DONE  
23ad				       NEXTW 
23ad c3 36 1a			jp macro_next 
23b0				endm 
# End of macro NEXTW
23b0			 
23b0			.SCRATCH: 
23b0				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
23b0 6f				db WORD_SYS_CORE+91             
23b1 eb 23			dw .INC            
23b3 08				db 7 + 1 
23b4 .. 00			db "SCRATCH",0              
23bc				endm 
# End of macro CWHEAD
23bc			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
23bc			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
23bc			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
23bc			; | |  
23bc			; | | e.g.    : score $00 scratch ; 
23bc			; | |  
23bc			; | | $00 score ! 
23bc			; | | $01 score +! 
23bc			; | |  
23bc			; | | e.g.   : varword $0a scratch ;  
23bc			; | | 
23bc			; | | $8000 varword ! 
23bc					if DEBUG_FORTH_WORDS_KEY 
23bc						DMARK "SCR" 
23bc f5				push af  
23bd 3a d1 23			ld a, (.dmark)  
23c0 32 bd fb			ld (debug_mark),a  
23c3 3a d2 23			ld a, (.dmark+1)  
23c6 32 be fb			ld (debug_mark+1),a  
23c9 3a d3 23			ld a, (.dmark+2)  
23cc 32 bf fb			ld (debug_mark+2),a  
23cf 18 03			jr .pastdmark  
23d1 ..			.dmark: db "SCR"  
23d4 f1			.pastdmark: pop af  
23d5			endm  
# End of macro DMARK
23d5						CALLMONITOR 
23d5 cd d7 12			call break_point_state  
23d8				endm  
# End of macro CALLMONITOR
23d8					endif 
23d8			 
23d8					FORTH_DSP_VALUEHL 
23d8 cd fc 18			call macro_dsp_valuehl 
23db				endm 
# End of macro FORTH_DSP_VALUEHL
23db				 
23db					FORTH_DSP_POP 
23db cd 7c 19			call macro_forth_dsp_pop 
23de				endm 
# End of macro FORTH_DSP_POP
23de			 
23de 7d					ld a, l 
23df 21 dd f4				ld hl, os_var_array 
23e2 cd 13 0b				call addatohl 
23e5			 
23e5 cd 61 18				call forth_push_numhl 
23e8			 
23e8				       NEXTW 
23e8 c3 36 1a			jp macro_next 
23eb				endm 
# End of macro NEXTW
23eb			 
23eb			.INC: 
23eb				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
23eb 6f				db WORD_SYS_CORE+91             
23ec 23 24			dw .DEC            
23ee 03				db 2 + 1 
23ef .. 00			db "+!",0              
23f2				endm 
# End of macro CWHEAD
23f2			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
23f2					if DEBUG_FORTH_WORDS_KEY 
23f2						DMARK "+s_" 
23f2 f5				push af  
23f3 3a 07 24			ld a, (.dmark)  
23f6 32 bd fb			ld (debug_mark),a  
23f9 3a 08 24			ld a, (.dmark+1)  
23fc 32 be fb			ld (debug_mark+1),a  
23ff 3a 09 24			ld a, (.dmark+2)  
2402 32 bf fb			ld (debug_mark+2),a  
2405 18 03			jr .pastdmark  
2407 ..			.dmark: db "+s_"  
240a f1			.pastdmark: pop af  
240b			endm  
# End of macro DMARK
240b						CALLMONITOR 
240b cd d7 12			call break_point_state  
240e				endm  
# End of macro CALLMONITOR
240e					endif 
240e			 
240e					FORTH_DSP_VALUEHL 
240e cd fc 18			call macro_dsp_valuehl 
2411				endm 
# End of macro FORTH_DSP_VALUEHL
2411			 
2411 e5					push hl   ; save address 
2412			 
2412					FORTH_DSP_POP 
2412 cd 7c 19			call macro_forth_dsp_pop 
2415				endm 
# End of macro FORTH_DSP_POP
2415			 
2415					FORTH_DSP_VALUEHL 
2415 cd fc 18			call macro_dsp_valuehl 
2418				endm 
# End of macro FORTH_DSP_VALUEHL
2418			 
2418					FORTH_DSP_POP 
2418 cd 7c 19			call macro_forth_dsp_pop 
241b				endm 
# End of macro FORTH_DSP_POP
241b			 
241b					; hl contains value to add to byte at a 
241b				 
241b eb					ex de, hl 
241c			 
241c e1					pop hl 
241d			 
241d					if DEBUG_FORTH_WORDS 
241d						DMARK "INC" 
241d						CALLMONITOR 
241d					endif 
241d			 
241d 7e					ld a,(hl) 
241e 83					add e 
241f 77					ld (hl),a 
2420			 
2420			 
2420			 
2420				       NEXTW 
2420 c3 36 1a			jp macro_next 
2423				endm 
# End of macro NEXTW
2423			 
2423			.DEC: 
2423				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2423 6f				db WORD_SYS_CORE+91             
2424 58 24			dw .INC2            
2426 03				db 2 + 1 
2427 .. 00			db "-!",0              
242a				endm 
# End of macro CWHEAD
242a			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
242a					if DEBUG_FORTH_WORDS_KEY 
242a						DMARK "-s_" 
242a f5				push af  
242b 3a 3f 24			ld a, (.dmark)  
242e 32 bd fb			ld (debug_mark),a  
2431 3a 40 24			ld a, (.dmark+1)  
2434 32 be fb			ld (debug_mark+1),a  
2437 3a 41 24			ld a, (.dmark+2)  
243a 32 bf fb			ld (debug_mark+2),a  
243d 18 03			jr .pastdmark  
243f ..			.dmark: db "-s_"  
2442 f1			.pastdmark: pop af  
2443			endm  
# End of macro DMARK
2443						CALLMONITOR 
2443 cd d7 12			call break_point_state  
2446				endm  
# End of macro CALLMONITOR
2446					endif 
2446			 
2446					FORTH_DSP_VALUEHL 
2446 cd fc 18			call macro_dsp_valuehl 
2449				endm 
# End of macro FORTH_DSP_VALUEHL
2449			 
2449 e5					push hl   ; save address 
244a			 
244a					FORTH_DSP_POP 
244a cd 7c 19			call macro_forth_dsp_pop 
244d				endm 
# End of macro FORTH_DSP_POP
244d			 
244d					FORTH_DSP_VALUEHL 
244d cd fc 18			call macro_dsp_valuehl 
2450				endm 
# End of macro FORTH_DSP_VALUEHL
2450			 
2450					; hl contains value to add to byte at a 
2450				 
2450 eb					ex de, hl 
2451			 
2451 e1					pop hl 
2452			 
2452					if DEBUG_FORTH_WORDS 
2452						DMARK "DEC" 
2452						CALLMONITOR 
2452					endif 
2452			 
2452 7e					ld a,(hl) 
2453 93					sub e 
2454 77					ld (hl),a 
2455			 
2455			 
2455			 
2455				       NEXTW 
2455 c3 36 1a			jp macro_next 
2458				endm 
# End of macro NEXTW
2458			 
2458			.INC2: 
2458				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2458 6f				db WORD_SYS_CORE+91             
2459 92 24			dw .DEC2            
245b 04				db 3 + 1 
245c .. 00			db "+2!",0              
2460				endm 
# End of macro CWHEAD
2460			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2460			 
2460					if DEBUG_FORTH_WORDS_KEY 
2460						DMARK "+2s" 
2460 f5				push af  
2461 3a 75 24			ld a, (.dmark)  
2464 32 bd fb			ld (debug_mark),a  
2467 3a 76 24			ld a, (.dmark+1)  
246a 32 be fb			ld (debug_mark+1),a  
246d 3a 77 24			ld a, (.dmark+2)  
2470 32 bf fb			ld (debug_mark+2),a  
2473 18 03			jr .pastdmark  
2475 ..			.dmark: db "+2s"  
2478 f1			.pastdmark: pop af  
2479			endm  
# End of macro DMARK
2479						CALLMONITOR 
2479 cd d7 12			call break_point_state  
247c				endm  
# End of macro CALLMONITOR
247c					endif 
247c			 
247c					; Address 
247c			 
247c					FORTH_DSP_VALUEHL 
247c cd fc 18			call macro_dsp_valuehl 
247f				endm 
# End of macro FORTH_DSP_VALUEHL
247f			 
247f e5					push hl    ; save address 
2480			 
2480					; load content into de 
2480			 
2480 5e					ld e,(hl) 
2481 23					inc hl 
2482 56					ld d, (hl) 
2483			 
2483					if DEBUG_FORTH_WORDS 
2483						DMARK "+2a" 
2483						CALLMONITOR 
2483					endif 
2483			 
2483					FORTH_DSP_POP 
2483 cd 7c 19			call macro_forth_dsp_pop 
2486				endm 
# End of macro FORTH_DSP_POP
2486			 
2486					; Get value to add 
2486			 
2486					FORTH_DSP_VALUE 
2486 cd e5 18			call macro_forth_dsp_value 
2489				endm 
# End of macro FORTH_DSP_VALUE
2489			 
2489					if DEBUG_FORTH_WORDS 
2489						DMARK "+2v" 
2489						CALLMONITOR 
2489					endif 
2489			 
2489 19					add hl, de 
248a			 
248a					if DEBUG_FORTH_WORDS 
248a						DMARK "+2+" 
248a						CALLMONITOR 
248a					endif 
248a			 
248a					; move result to de 
248a			 
248a eb					ex de, hl 
248b			 
248b					; Address 
248b			 
248b e1					pop hl 
248c			 
248c					; save it back 
248c			 
248c 73					ld (hl), e 
248d 23					inc hl 
248e 72					ld (hl), d 
248f			 
248f					if DEBUG_FORTH_WORDS 
248f						DMARK "+2e" 
248f						CALLMONITOR 
248f					endif 
248f			 
248f			 
248f			 
248f			 
248f			 
248f				       NEXTW 
248f c3 36 1a			jp macro_next 
2492				endm 
# End of macro NEXTW
2492			 
2492			.DEC2: 
2492				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2492 6f				db WORD_SYS_CORE+91             
2493 ce 24			dw .GET2            
2495 04				db 3 + 1 
2496 .. 00			db "-2!",0              
249a				endm 
# End of macro CWHEAD
249a			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
249a			 
249a			 
249a					if DEBUG_FORTH_WORDS_KEY 
249a						DMARK "-2s" 
249a f5				push af  
249b 3a af 24			ld a, (.dmark)  
249e 32 bd fb			ld (debug_mark),a  
24a1 3a b0 24			ld a, (.dmark+1)  
24a4 32 be fb			ld (debug_mark+1),a  
24a7 3a b1 24			ld a, (.dmark+2)  
24aa 32 bf fb			ld (debug_mark+2),a  
24ad 18 03			jr .pastdmark  
24af ..			.dmark: db "-2s"  
24b2 f1			.pastdmark: pop af  
24b3			endm  
# End of macro DMARK
24b3						CALLMONITOR 
24b3 cd d7 12			call break_point_state  
24b6				endm  
# End of macro CALLMONITOR
24b6					endif 
24b6			 
24b6					; Address 
24b6			 
24b6					FORTH_DSP_VALUEHL 
24b6 cd fc 18			call macro_dsp_valuehl 
24b9				endm 
# End of macro FORTH_DSP_VALUEHL
24b9			 
24b9 e5					push hl    ; save address 
24ba			 
24ba					; load content into de 
24ba			 
24ba 5e					ld e,(hl) 
24bb 23					inc hl 
24bc 56					ld d, (hl) 
24bd			 
24bd					if DEBUG_FORTH_WORDS 
24bd						DMARK "-2a" 
24bd						CALLMONITOR 
24bd					endif 
24bd			 
24bd					FORTH_DSP_POP 
24bd cd 7c 19			call macro_forth_dsp_pop 
24c0				endm 
# End of macro FORTH_DSP_POP
24c0			 
24c0					; Get value to remove 
24c0			 
24c0					FORTH_DSP_VALUE 
24c0 cd e5 18			call macro_forth_dsp_value 
24c3				endm 
# End of macro FORTH_DSP_VALUE
24c3			 
24c3					if DEBUG_FORTH_WORDS 
24c3						DMARK "-2v" 
24c3						CALLMONITOR 
24c3					endif 
24c3			 
24c3 eb					ex de, hl 
24c4 ed 52				sbc hl, de 
24c6			 
24c6					if DEBUG_FORTH_WORDS 
24c6						DMARK "-2d" 
24c6						CALLMONITOR 
24c6					endif 
24c6			 
24c6					; move result to de 
24c6			 
24c6 eb					ex de, hl 
24c7			 
24c7					; Address 
24c7			 
24c7 e1					pop hl 
24c8			 
24c8					; save it back 
24c8			 
24c8 73					ld (hl), e 
24c9 23					inc hl 
24ca 72					ld (hl), d 
24cb			 
24cb					if DEBUG_FORTH_WORDS 
24cb						DMARK "-2e" 
24cb						CALLMONITOR 
24cb					endif 
24cb			 
24cb			 
24cb			 
24cb			 
24cb			 
24cb				       NEXTW 
24cb c3 36 1a			jp macro_next 
24ce				endm 
# End of macro NEXTW
24ce			.GET2: 
24ce				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
24ce 6f				db WORD_SYS_CORE+91             
24cf fe 24			dw .BANG2            
24d1 03				db 2 + 1 
24d2 .. 00			db "2@",0              
24d5				endm 
# End of macro CWHEAD
24d5			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
24d5					if DEBUG_FORTH_WORDS_KEY 
24d5						DMARK "2A_" 
24d5 f5				push af  
24d6 3a ea 24			ld a, (.dmark)  
24d9 32 bd fb			ld (debug_mark),a  
24dc 3a eb 24			ld a, (.dmark+1)  
24df 32 be fb			ld (debug_mark+1),a  
24e2 3a ec 24			ld a, (.dmark+2)  
24e5 32 bf fb			ld (debug_mark+2),a  
24e8 18 03			jr .pastdmark  
24ea ..			.dmark: db "2A_"  
24ed f1			.pastdmark: pop af  
24ee			endm  
# End of macro DMARK
24ee						CALLMONITOR 
24ee cd d7 12			call break_point_state  
24f1				endm  
# End of macro CALLMONITOR
24f1					endif 
24f1			 
24f1					FORTH_DSP_VALUEHL 
24f1 cd fc 18			call macro_dsp_valuehl 
24f4				endm 
# End of macro FORTH_DSP_VALUEHL
24f4			 
24f4 5e					ld e, (hl) 
24f5 23					inc hl 
24f6 56					ld d, (hl) 
24f7			 
24f7 eb					ex de, hl 
24f8			 
24f8 cd 61 18				call forth_push_numhl 
24fb			 
24fb				       NEXTW 
24fb c3 36 1a			jp macro_next 
24fe				endm 
# End of macro NEXTW
24fe			.BANG2: 
24fe				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
24fe 6f				db WORD_SYS_CORE+91             
24ff 36 25			dw .ENDCORE            
2501 03				db 2 + 1 
2502 .. 00			db "2!",0              
2505				endm 
# End of macro CWHEAD
2505			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2505					if DEBUG_FORTH_WORDS_KEY 
2505						DMARK "2S_" 
2505 f5				push af  
2506 3a 1a 25			ld a, (.dmark)  
2509 32 bd fb			ld (debug_mark),a  
250c 3a 1b 25			ld a, (.dmark+1)  
250f 32 be fb			ld (debug_mark+1),a  
2512 3a 1c 25			ld a, (.dmark+2)  
2515 32 bf fb			ld (debug_mark+2),a  
2518 18 03			jr .pastdmark  
251a ..			.dmark: db "2S_"  
251d f1			.pastdmark: pop af  
251e			endm  
# End of macro DMARK
251e						CALLMONITOR 
251e cd d7 12			call break_point_state  
2521				endm  
# End of macro CALLMONITOR
2521					endif 
2521			 
2521					FORTH_DSP_VALUEHL 
2521 cd fc 18			call macro_dsp_valuehl 
2524				endm 
# End of macro FORTH_DSP_VALUEHL
2524			 
2524 e5					push hl   ; save address 
2525			 
2525			 
2525					FORTH_DSP_POP 
2525 cd 7c 19			call macro_forth_dsp_pop 
2528				endm 
# End of macro FORTH_DSP_POP
2528			 
2528					 
2528					FORTH_DSP_VALUEHL 
2528 cd fc 18			call macro_dsp_valuehl 
252b				endm 
# End of macro FORTH_DSP_VALUEHL
252b			 
252b					FORTH_DSP_POP 
252b cd 7c 19			call macro_forth_dsp_pop 
252e				endm 
# End of macro FORTH_DSP_POP
252e			 
252e eb					ex de, hl    ; value now in de 
252f			 
252f e1					pop hl 
2530			 
2530 73					ld (hl), e 
2531			 
2531 23					inc hl 
2532			 
2532 72					ld (hl), d 
2533			 
2533			 
2533				       NEXTW 
2533 c3 36 1a			jp macro_next 
2536				endm 
# End of macro NEXTW
2536			.ENDCORE: 
2536			 
2536			; eof 
2536			 
2536			 
# End of file forth_words_core.asm
2536			include "forth_words_flow.asm" 
2536			 
2536			; | ## Program Flow Words 
2536			 
2536			.IF: 
2536				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2536 1e				db WORD_SYS_CORE+10             
2537 83 25			dw .THEN            
2539 03				db 2 + 1 
253a .. 00			db "IF",0              
253d				endm 
# End of macro CWHEAD
253d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
253d			; 
253d					if DEBUG_FORTH_WORDS_KEY 
253d						DMARK "IF." 
253d f5				push af  
253e 3a 52 25			ld a, (.dmark)  
2541 32 bd fb			ld (debug_mark),a  
2544 3a 53 25			ld a, (.dmark+1)  
2547 32 be fb			ld (debug_mark+1),a  
254a 3a 54 25			ld a, (.dmark+2)  
254d 32 bf fb			ld (debug_mark+2),a  
2550 18 03			jr .pastdmark  
2552 ..			.dmark: db "IF."  
2555 f1			.pastdmark: pop af  
2556			endm  
# End of macro DMARK
2556						CALLMONITOR 
2556 cd d7 12			call break_point_state  
2559				endm  
# End of macro CALLMONITOR
2559					endif 
2559			; eval TOS 
2559			 
2559				FORTH_DSP_VALUEHL 
2559 cd fc 18			call macro_dsp_valuehl 
255c				endm 
# End of macro FORTH_DSP_VALUEHL
255c			 
255c			;	push hl 
255c				FORTH_DSP_POP 
255c cd 7c 19			call macro_forth_dsp_pop 
255f				endm 
# End of macro FORTH_DSP_POP
255f			;	pop hl 
255f			 
255f					if DEBUG_FORTH_WORDS 
255f						DMARK "IF1" 
255f						CALLMONITOR 
255f					endif 
255f b7				or a        ; clear carry flag 
2560 11 00 00			ld de, 0 
2563 eb				ex de,hl 
2564 ed 52			sbc hl, de 
2566 c2 80 25			jp nz, .iftrue 
2569			 
2569					if DEBUG_FORTH_WORDS 
2569						DMARK "IF2" 
2569						CALLMONITOR 
2569					endif 
2569			 
2569			; if not true then skip to THEN 
2569			 
2569				; TODO get tok_ptr 
2569				; TODO consume toks until we get to THEN 
2569			 
2569 2a b9 f2			ld hl, (os_tok_ptr) 
256c					if DEBUG_FORTH_WORDS 
256c						DMARK "IF3" 
256c						CALLMONITOR 
256c						 
256c					endif 
256c 11 7b 25			ld de, .ifthen 
256f					if DEBUG_FORTH_WORDS 
256f						DMARK "IF4" 
256f						CALLMONITOR 
256f					endif 
256f cd 51 1b			call findnexttok  
2572			 
2572					if DEBUG_FORTH_WORDS 
2572						DMARK "IF5" 
2572						CALLMONITOR 
2572					endif 
2572				; TODO replace below with ; exec using tok_ptr 
2572 22 b9 f2			ld (os_tok_ptr), hl 
2575 c3 c7 1a			jp exec1 
2578				NEXTW 
2578 c3 36 1a			jp macro_next 
257b				endm 
# End of macro NEXTW
257b			 
257b .. 00		.ifthen:  db "THEN",0 
2580			 
2580			.iftrue:		 
2580				; Exec next words normally 
2580			 
2580				; if true then exec following IF as normal 
2580					if DEBUG_FORTH_WORDS 
2580						DMARK "IFT" 
2580						CALLMONITOR 
2580					endif 
2580			 
2580					NEXTW 
2580 c3 36 1a			jp macro_next 
2583				endm 
# End of macro NEXTW
2583			.THEN: 
2583				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2583 1f				db WORD_SYS_CORE+11             
2584 ab 25			dw .ELSE            
2586 05				db 4 + 1 
2587 .. 00			db "THEN",0              
258c				endm 
# End of macro CWHEAD
258c			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
258c					if DEBUG_FORTH_WORDS_KEY 
258c						DMARK "THN" 
258c f5				push af  
258d 3a a1 25			ld a, (.dmark)  
2590 32 bd fb			ld (debug_mark),a  
2593 3a a2 25			ld a, (.dmark+1)  
2596 32 be fb			ld (debug_mark+1),a  
2599 3a a3 25			ld a, (.dmark+2)  
259c 32 bf fb			ld (debug_mark+2),a  
259f 18 03			jr .pastdmark  
25a1 ..			.dmark: db "THN"  
25a4 f1			.pastdmark: pop af  
25a5			endm  
# End of macro DMARK
25a5						CALLMONITOR 
25a5 cd d7 12			call break_point_state  
25a8				endm  
# End of macro CALLMONITOR
25a8					endif 
25a8					NEXTW 
25a8 c3 36 1a			jp macro_next 
25ab				endm 
# End of macro NEXTW
25ab			.ELSE: 
25ab				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
25ab 20				db WORD_SYS_CORE+12             
25ac d3 25			dw .DO            
25ae 03				db 2 + 1 
25af .. 00			db "ELSE",0              
25b4				endm 
# End of macro CWHEAD
25b4			; | ELSE ( -- ) Not supported - does nothing | TODO 
25b4			 
25b4					if DEBUG_FORTH_WORDS_KEY 
25b4						DMARK "ELS" 
25b4 f5				push af  
25b5 3a c9 25			ld a, (.dmark)  
25b8 32 bd fb			ld (debug_mark),a  
25bb 3a ca 25			ld a, (.dmark+1)  
25be 32 be fb			ld (debug_mark+1),a  
25c1 3a cb 25			ld a, (.dmark+2)  
25c4 32 bf fb			ld (debug_mark+2),a  
25c7 18 03			jr .pastdmark  
25c9 ..			.dmark: db "ELS"  
25cc f1			.pastdmark: pop af  
25cd			endm  
# End of macro DMARK
25cd						CALLMONITOR 
25cd cd d7 12			call break_point_state  
25d0				endm  
# End of macro CALLMONITOR
25d0					endif 
25d0			 
25d0			 
25d0					NEXTW 
25d0 c3 36 1a			jp macro_next 
25d3				endm 
# End of macro NEXTW
25d3			.DO: 
25d3				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
25d3 21				db WORD_SYS_CORE+13             
25d4 1a 26			dw .LOOP            
25d6 03				db 2 + 1 
25d7 .. 00			db "DO",0              
25da				endm 
# End of macro CWHEAD
25da			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
25da			 
25da					if DEBUG_FORTH_WORDS_KEY 
25da						DMARK "DO." 
25da f5				push af  
25db 3a ef 25			ld a, (.dmark)  
25de 32 bd fb			ld (debug_mark),a  
25e1 3a f0 25			ld a, (.dmark+1)  
25e4 32 be fb			ld (debug_mark+1),a  
25e7 3a f1 25			ld a, (.dmark+2)  
25ea 32 bf fb			ld (debug_mark+2),a  
25ed 18 03			jr .pastdmark  
25ef ..			.dmark: db "DO."  
25f2 f1			.pastdmark: pop af  
25f3			endm  
# End of macro DMARK
25f3						CALLMONITOR 
25f3 cd d7 12			call break_point_state  
25f6				endm  
# End of macro CALLMONITOR
25f6					endif 
25f6			;  push pc to rsp stack past the DO 
25f6			 
25f6 2a b9 f2				ld hl, (os_tok_ptr) 
25f9 23					inc hl   ; D 
25fa 23					inc hl  ; O 
25fb 23					inc hl   ; null 
25fc					if DEBUG_FORTH_WORDS 
25fc						DMARK "DO2" 
25fc						CALLMONITOR 
25fc					endif 
25fc					FORTH_RSP_NEXT 
25fc cd 0b 18			call macro_forth_rsp_next 
25ff				endm 
# End of macro FORTH_RSP_NEXT
25ff					if DEBUG_FORTH_WORDS 
25ff						DMARK "DO3" 
25ff						CALLMONITOR 
25ff					endif 
25ff			 
25ff					;if DEBUG_FORTH_WORDS 
25ff				;		push hl 
25ff			;		endif  
25ff			 
25ff			; get counters from data stack 
25ff			 
25ff			 
25ff					FORTH_DSP_VALUEHL 
25ff cd fc 18			call macro_dsp_valuehl 
2602				endm 
# End of macro FORTH_DSP_VALUEHL
2602 e5					push hl		 ; hl now has starting counter which needs to be tos 
2603			 
2603					if DEBUG_FORTH_WORDS 
2603						DMARK "DO4" 
2603						CALLMONITOR 
2603					endif 
2603					FORTH_DSP_POP 
2603 cd 7c 19			call macro_forth_dsp_pop 
2606				endm 
# End of macro FORTH_DSP_POP
2606			 
2606					if DEBUG_FORTH_WORDS 
2606						DMARK "DO5" 
2606						CALLMONITOR 
2606					endif 
2606			 
2606					FORTH_DSP_VALUEHL 
2606 cd fc 18			call macro_dsp_valuehl 
2609				endm 
# End of macro FORTH_DSP_VALUEHL
2609			;		push hl		 ; hl now has starting limit counter 
2609			 
2609					if DEBUG_FORTH_WORDS 
2609						DMARK "DO6" 
2609						CALLMONITOR 
2609					endif 
2609					FORTH_DSP_POP 
2609 cd 7c 19			call macro_forth_dsp_pop 
260c				endm 
# End of macro FORTH_DSP_POP
260c			 
260c			; put counters on the loop stack 
260c			 
260c			;		pop hl			 ; limit counter 
260c d1					pop de			; start counter 
260d			 
260d					; push limit counter 
260d			 
260d					if DEBUG_FORTH_WORDS 
260d						DMARK "DO7" 
260d						CALLMONITOR 
260d					endif 
260d					FORTH_LOOP_NEXT 
260d cd 11 19			call macro_forth_loop_next 
2610				endm 
# End of macro FORTH_LOOP_NEXT
2610			 
2610					; push start counter 
2610			 
2610 eb					ex de, hl 
2611					if DEBUG_FORTH_WORDS 
2611						DMARK "DO7" 
2611						CALLMONITOR 
2611					endif 
2611					FORTH_LOOP_NEXT 
2611 cd 11 19			call macro_forth_loop_next 
2614				endm 
# End of macro FORTH_LOOP_NEXT
2614			 
2614			 
2614					; init first round of I counter 
2614			 
2614 22 dd f2				ld (os_current_i), hl 
2617			 
2617					if DEBUG_FORTH_WORDS 
2617						DMARK "DO8" 
2617						CALLMONITOR 
2617					endif 
2617			 
2617					NEXTW 
2617 c3 36 1a			jp macro_next 
261a				endm 
# End of macro NEXTW
261a			.LOOP: 
261a				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
261a 22				db WORD_SYS_CORE+14             
261b 6d 26			dw .I            
261d 05				db 4 + 1 
261e .. 00			db "LOOP",0              
2623				endm 
# End of macro CWHEAD
2623			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2623			 
2623				; pop tos as current loop count to hl 
2623			 
2623				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2623			 
2623				FORTH_LOOP_TOS 
2623 cd 28 19			call macro_forth_loop_tos 
2626				endm 
# End of macro FORTH_LOOP_TOS
2626 e5				push hl 
2627			 
2627					if DEBUG_FORTH_WORDS_KEY 
2627						DMARK "LOP" 
2627 f5				push af  
2628 3a 3c 26			ld a, (.dmark)  
262b 32 bd fb			ld (debug_mark),a  
262e 3a 3d 26			ld a, (.dmark+1)  
2631 32 be fb			ld (debug_mark+1),a  
2634 3a 3e 26			ld a, (.dmark+2)  
2637 32 bf fb			ld (debug_mark+2),a  
263a 18 03			jr .pastdmark  
263c ..			.dmark: db "LOP"  
263f f1			.pastdmark: pop af  
2640			endm  
# End of macro DMARK
2640						CALLMONITOR 
2640 cd d7 12			call break_point_state  
2643				endm  
# End of macro CALLMONITOR
2643					endif 
2643				; next item on the stack is the limit. get it 
2643			 
2643			 
2643				FORTH_LOOP_POP 
2643 cd 32 19			call macro_forth_loop_pop 
2646				endm 
# End of macro FORTH_LOOP_POP
2646			 
2646				FORTH_LOOP_TOS 
2646 cd 28 19			call macro_forth_loop_tos 
2649				endm 
# End of macro FORTH_LOOP_TOS
2649			 
2649 d1				pop de		 ; de = i, hl = limit 
264a			 
264a					if DEBUG_FORTH_WORDS 
264a						DMARK "LP1" 
264a						CALLMONITOR 
264a					endif 
264a			 
264a				; go back to previous word 
264a			 
264a d5				push de    ; save I for inc later 
264b			 
264b			 
264b				; get limit 
264b				;  is I at limit? 
264b			 
264b			 
264b					if DEBUG_FORTH_WORDS 
264b						DMARK "LP1" 
264b						CALLMONITOR 
264b					endif 
264b			 
264b ed 52			sbc hl, de 
264d			 
264d			 
264d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
264d			 
264d 20 0a				jr nz, .loopnotdone 
264f			 
264f e1				pop hl   ; get rid of saved I 
2650				FORTH_LOOP_POP     ; get rid of limit 
2650 cd 32 19			call macro_forth_loop_pop 
2653				endm 
# End of macro FORTH_LOOP_POP
2653			 
2653				FORTH_RSP_POP     ; get rid of DO ptr 
2653 cd 29 18			call macro_forth_rsp_pop 
2656				endm 
# End of macro FORTH_RSP_POP
2656			 
2656			if DEBUG_FORTH_WORDS 
2656						DMARK "LP>" 
2656				CALLMONITOR 
2656			endif 
2656			 
2656					NEXTW 
2656 c3 36 1a			jp macro_next 
2659				endm 
# End of macro NEXTW
2659				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2659			 
2659			.loopnotdone: 
2659			 
2659 e1				pop hl    ; get I 
265a 23				inc hl 
265b			 
265b			   	; save new I 
265b			 
265b			 
265b					; set I counter 
265b			 
265b 22 dd f2				ld (os_current_i), hl 
265e			 
265e					if DEBUG_FORTH_WORDS 
265e						DMARK "LPN" 
265e					CALLMONITOR 
265e					endif 
265e					 
265e				FORTH_LOOP_NEXT 
265e cd 11 19			call macro_forth_loop_next 
2661				endm 
# End of macro FORTH_LOOP_NEXT
2661			 
2661			 
2661					if DEBUG_FORTH_WORDS 
2661						ex de,hl 
2661					endif 
2661			 
2661			;	; get DO ptr 
2661			; 
2661					if DEBUG_FORTH_WORDS 
2661						DMARK "LP7" 
2661					CALLMONITOR 
2661					endif 
2661				FORTH_RSP_TOS 
2661 cd 22 18			call macro_forth_rsp_tos 
2664				endm 
# End of macro FORTH_RSP_TOS
2664			 
2664					if DEBUG_FORTH_WORDS 
2664						DMARK "LP8" 
2664					CALLMONITOR 
2664					endif 
2664				;push hl 
2664			 
2664				; not going to DO any more 
2664				; get rid of the RSP pointer as DO will add it back in 
2664				;FORTH_RSP_POP 
2664				;pop hl 
2664			 
2664				;ld hl,(cli_ret_sp) 
2664				;ld e, (hl) 
2664				;inc hl 
2664				;ld d, (hl) 
2664				;ex de,hl 
2664 22 b9 f2			ld (os_tok_ptr), hl 
2667					if DEBUG_FORTH_WORDS 
2667						DMARK "LP<" 
2667					CALLMONITOR 
2667				endif 
2667 c3 c7 1a			jp exec1 
266a			 
266a					 
266a			 
266a			 
266a					NEXTW 
266a c3 36 1a			jp macro_next 
266d				endm 
# End of macro NEXTW
266d			.I:  
266d			 
266d				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
266d 5e				db WORD_SYS_CORE+74             
266e 98 26			dw .DLOOP            
2670 02				db 1 + 1 
2671 .. 00			db "I",0              
2673				endm 
# End of macro CWHEAD
2673			; | I ( -- ) Current loop counter | DONE 
2673					if DEBUG_FORTH_WORDS_KEY 
2673						DMARK "I.." 
2673 f5				push af  
2674 3a 88 26			ld a, (.dmark)  
2677 32 bd fb			ld (debug_mark),a  
267a 3a 89 26			ld a, (.dmark+1)  
267d 32 be fb			ld (debug_mark+1),a  
2680 3a 8a 26			ld a, (.dmark+2)  
2683 32 bf fb			ld (debug_mark+2),a  
2686 18 03			jr .pastdmark  
2688 ..			.dmark: db "I.."  
268b f1			.pastdmark: pop af  
268c			endm  
# End of macro DMARK
268c						CALLMONITOR 
268c cd d7 12			call break_point_state  
268f				endm  
# End of macro CALLMONITOR
268f					endif 
268f			 
268f 2a dd f2				ld hl,(os_current_i) 
2692 cd 61 18				call forth_push_numhl 
2695			 
2695					NEXTW 
2695 c3 36 1a			jp macro_next 
2698				endm 
# End of macro NEXTW
2698			.DLOOP: 
2698				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2698 5f				db WORD_SYS_CORE+75             
2699 ec 26			dw .REPEAT            
269b 06				db 5 + 1 
269c .. 00			db "-LOOP",0              
26a2				endm 
# End of macro CWHEAD
26a2			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
26a2				; pop tos as current loop count to hl 
26a2					if DEBUG_FORTH_WORDS_KEY 
26a2						DMARK "-LP" 
26a2 f5				push af  
26a3 3a b7 26			ld a, (.dmark)  
26a6 32 bd fb			ld (debug_mark),a  
26a9 3a b8 26			ld a, (.dmark+1)  
26ac 32 be fb			ld (debug_mark+1),a  
26af 3a b9 26			ld a, (.dmark+2)  
26b2 32 bf fb			ld (debug_mark+2),a  
26b5 18 03			jr .pastdmark  
26b7 ..			.dmark: db "-LP"  
26ba f1			.pastdmark: pop af  
26bb			endm  
# End of macro DMARK
26bb						CALLMONITOR 
26bb cd d7 12			call break_point_state  
26be				endm  
# End of macro CALLMONITOR
26be					endif 
26be			 
26be				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
26be			 
26be				FORTH_LOOP_TOS 
26be cd 28 19			call macro_forth_loop_tos 
26c1				endm 
# End of macro FORTH_LOOP_TOS
26c1 e5				push hl 
26c2			 
26c2					if DEBUG_FORTH_WORDS 
26c2						DMARK "-LP" 
26c2						CALLMONITOR 
26c2					endif 
26c2				; next item on the stack is the limit. get it 
26c2			 
26c2			 
26c2				FORTH_LOOP_POP 
26c2 cd 32 19			call macro_forth_loop_pop 
26c5				endm 
# End of macro FORTH_LOOP_POP
26c5			 
26c5				FORTH_LOOP_TOS 
26c5 cd 28 19			call macro_forth_loop_tos 
26c8				endm 
# End of macro FORTH_LOOP_TOS
26c8			 
26c8 d1				pop de		 ; de = i, hl = limit 
26c9			 
26c9					if DEBUG_FORTH_WORDS 
26c9						DMARK "-L1" 
26c9						CALLMONITOR 
26c9					endif 
26c9			 
26c9				; go back to previous word 
26c9			 
26c9 d5				push de    ; save I for inc later 
26ca			 
26ca			 
26ca				; get limit 
26ca				;  is I at limit? 
26ca			 
26ca			 
26ca					if DEBUG_FORTH_WORDS 
26ca						DMARK "-L1" 
26ca						CALLMONITOR 
26ca					endif 
26ca			 
26ca ed 52			sbc hl, de 
26cc			 
26cc			 
26cc				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
26cc			 
26cc 20 0a				jr nz, .mloopnotdone 
26ce			 
26ce e1				pop hl   ; get rid of saved I 
26cf				FORTH_LOOP_POP     ; get rid of limit 
26cf cd 32 19			call macro_forth_loop_pop 
26d2				endm 
# End of macro FORTH_LOOP_POP
26d2			 
26d2				FORTH_RSP_POP     ; get rid of DO ptr 
26d2 cd 29 18			call macro_forth_rsp_pop 
26d5				endm 
# End of macro FORTH_RSP_POP
26d5			 
26d5			if DEBUG_FORTH_WORDS 
26d5						DMARK "-L>" 
26d5				CALLMONITOR 
26d5			endif 
26d5			 
26d5					NEXTW 
26d5 c3 36 1a			jp macro_next 
26d8				endm 
# End of macro NEXTW
26d8				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
26d8			 
26d8			.mloopnotdone: 
26d8			 
26d8 e1				pop hl    ; get I 
26d9 2b				dec hl 
26da			 
26da			   	; save new I 
26da			 
26da			 
26da					; set I counter 
26da			 
26da 22 dd f2				ld (os_current_i), hl 
26dd			 
26dd					 
26dd				FORTH_LOOP_NEXT 
26dd cd 11 19			call macro_forth_loop_next 
26e0				endm 
# End of macro FORTH_LOOP_NEXT
26e0			 
26e0			 
26e0					if DEBUG_FORTH_WORDS 
26e0						ex de,hl 
26e0					endif 
26e0			 
26e0			;	; get DO ptr 
26e0			; 
26e0				FORTH_RSP_TOS 
26e0 cd 22 18			call macro_forth_rsp_tos 
26e3				endm 
# End of macro FORTH_RSP_TOS
26e3			 
26e3				;push hl 
26e3			 
26e3				; not going to DO any more 
26e3				; get rid of the RSP pointer as DO will add it back in 
26e3				;FORTH_RSP_POP 
26e3				;pop hl 
26e3			 
26e3			 
26e3 22 b9 f2			ld (os_tok_ptr), hl 
26e6					if DEBUG_FORTH_WORDS 
26e6						DMARK "-L<" 
26e6					CALLMONITOR 
26e6				endif 
26e6 c3 c7 1a			jp exec1 
26e9			 
26e9					 
26e9			 
26e9			 
26e9			 
26e9				NEXTW 
26e9 c3 36 1a			jp macro_next 
26ec				endm 
# End of macro NEXTW
26ec			 
26ec			 
26ec			 
26ec			 
26ec			.REPEAT: 
26ec				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
26ec 71				db WORD_SYS_CORE+93             
26ed 23 27			dw .UNTIL            
26ef 06				db 5 + 1 
26f0 .. 00			db "REPEAT",0              
26f7				endm 
# End of macro CWHEAD
26f7			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
26f7			;  push pc to rsp stack past the REPEAT 
26f7					if DEBUG_FORTH_WORDS_KEY 
26f7						DMARK "REP" 
26f7 f5				push af  
26f8 3a 0c 27			ld a, (.dmark)  
26fb 32 bd fb			ld (debug_mark),a  
26fe 3a 0d 27			ld a, (.dmark+1)  
2701 32 be fb			ld (debug_mark+1),a  
2704 3a 0e 27			ld a, (.dmark+2)  
2707 32 bf fb			ld (debug_mark+2),a  
270a 18 03			jr .pastdmark  
270c ..			.dmark: db "REP"  
270f f1			.pastdmark: pop af  
2710			endm  
# End of macro DMARK
2710						CALLMONITOR 
2710 cd d7 12			call break_point_state  
2713				endm  
# End of macro CALLMONITOR
2713					endif 
2713			 
2713 2a b9 f2				ld hl, (os_tok_ptr) 
2716 23					inc hl   ; R 
2717 23					inc hl  ; E 
2718 23					inc hl   ; P 
2719 23					inc hl   ; E 
271a 23					inc hl   ; A 
271b 23					inc hl   ; T 
271c 23					inc hl   ; zero 
271d					FORTH_RSP_NEXT 
271d cd 0b 18			call macro_forth_rsp_next 
2720				endm 
# End of macro FORTH_RSP_NEXT
2720			 
2720			 
2720					if DEBUG_FORTH_WORDS 
2720						DMARK "REP" 
2720						;pop bc    ; TODO BUG ?????? what is this for???? 
2720						CALLMONITOR 
2720					endif 
2720			 
2720					NEXTW 
2720 c3 36 1a			jp macro_next 
2723				endm 
# End of macro NEXTW
2723			;	       NEXTW 
2723			 
2723			.UNTIL: 
2723				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
2723 72				db WORD_SYS_CORE+94             
2724 66 27			dw .ENDFLOW            
2726 06				db 5 + 1 
2727 .. 00			db "UNTIL",0              
272d				endm 
# End of macro CWHEAD
272d			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
272d			 
272d				; pop tos as check 
272d			 
272d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
272d			 
272d				FORTH_DSP_VALUEHL 
272d cd fc 18			call macro_dsp_valuehl 
2730				endm 
# End of macro FORTH_DSP_VALUEHL
2730			 
2730					if DEBUG_FORTH_WORDS_KEY 
2730						DMARK "UNT" 
2730 f5				push af  
2731 3a 45 27			ld a, (.dmark)  
2734 32 bd fb			ld (debug_mark),a  
2737 3a 46 27			ld a, (.dmark+1)  
273a 32 be fb			ld (debug_mark+1),a  
273d 3a 47 27			ld a, (.dmark+2)  
2740 32 bf fb			ld (debug_mark+2),a  
2743 18 03			jr .pastdmark  
2745 ..			.dmark: db "UNT"  
2748 f1			.pastdmark: pop af  
2749			endm  
# End of macro DMARK
2749						CALLMONITOR 
2749 cd d7 12			call break_point_state  
274c				endm  
# End of macro CALLMONITOR
274c					endif 
274c			 
274c			;	push hl 
274c				FORTH_DSP_POP 
274c cd 7c 19			call macro_forth_dsp_pop 
274f				endm 
# End of macro FORTH_DSP_POP
274f			 
274f			;	pop hl 
274f			 
274f				; test if true 
274f			 
274f cd 3c 0b			call ishlzero 
2752			;	ld a,l 
2752			;	add h 
2752			; 
2752			;	cp 0 
2752			 
2752 20 06			jr nz, .untilnotdone 
2754			 
2754					if DEBUG_FORTH_WORDS 
2754						DMARK "UNf" 
2754						CALLMONITOR 
2754					endif 
2754			 
2754			 
2754			 
2754				FORTH_RSP_POP     ; get rid of DO ptr 
2754 cd 29 18			call macro_forth_rsp_pop 
2757				endm 
# End of macro FORTH_RSP_POP
2757			 
2757			if DEBUG_FORTH_WORDS 
2757						DMARK "UN>" 
2757				CALLMONITOR 
2757			endif 
2757			 
2757					NEXTW 
2757 c3 36 1a			jp macro_next 
275a				endm 
# End of macro NEXTW
275a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
275a			 
275a			.untilnotdone: 
275a			 
275a			 
275a			;	; get DO ptr 
275a			; 
275a				FORTH_RSP_TOS 
275a cd 22 18			call macro_forth_rsp_tos 
275d				endm 
# End of macro FORTH_RSP_TOS
275d			 
275d				;push hl 
275d			 
275d				; not going to DO any more 
275d				; get rid of the RSP pointer as DO will add it back in 
275d				;FORTH_RSP_POP 
275d				;pop hl 
275d			 
275d			 
275d 22 b9 f2			ld (os_tok_ptr), hl 
2760					if DEBUG_FORTH_WORDS 
2760						DMARK "UN<" 
2760					CALLMONITOR 
2760				endif 
2760 c3 c7 1a			jp exec1 
2763			 
2763					 
2763			 
2763			 
2763					NEXTW 
2763 c3 36 1a			jp macro_next 
2766				endm 
# End of macro NEXTW
2766			 
2766			 
2766			.ENDFLOW: 
2766			 
2766			; eof 
2766			 
# End of file forth_words_flow.asm
2766			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
2766			include "forth_words_logic.asm" 
2766			 
2766			; | ## Logic Words 
2766			 
2766			.NOT: 
2766				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
2766 2d				db WORD_SYS_CORE+25             
2767 ae 27			dw .IS            
2769 04				db 3 + 1 
276a .. 00			db "NOT",0              
276e				endm 
# End of macro CWHEAD
276e			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
276e					if DEBUG_FORTH_WORDS_KEY 
276e						DMARK "NOT" 
276e f5				push af  
276f 3a 83 27			ld a, (.dmark)  
2772 32 bd fb			ld (debug_mark),a  
2775 3a 84 27			ld a, (.dmark+1)  
2778 32 be fb			ld (debug_mark+1),a  
277b 3a 85 27			ld a, (.dmark+2)  
277e 32 bf fb			ld (debug_mark+2),a  
2781 18 03			jr .pastdmark  
2783 ..			.dmark: db "NOT"  
2786 f1			.pastdmark: pop af  
2787			endm  
# End of macro DMARK
2787						CALLMONITOR 
2787 cd d7 12			call break_point_state  
278a				endm  
# End of macro CALLMONITOR
278a					endif 
278a					FORTH_DSP 
278a cd e1 18			call macro_forth_dsp 
278d				endm 
# End of macro FORTH_DSP
278d 7e					ld a,(hl)	; get type of value on TOS 
278e fe 02				cp DS_TYPE_INUM  
2790 28 03				jr z, .noti 
2792					NEXTW 
2792 c3 36 1a			jp macro_next 
2795				endm 
# End of macro NEXTW
2795			.noti:          FORTH_DSP_VALUEHL 
2795 cd fc 18			call macro_dsp_valuehl 
2798				endm 
# End of macro FORTH_DSP_VALUEHL
2798			;		push hl 
2798					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2798 cd 7c 19			call macro_forth_dsp_pop 
279b				endm 
# End of macro FORTH_DSP_POP
279b			;		pop hl 
279b 3e 00				ld a,0 
279d bd					cp l 
279e 28 04				jr z, .not2t 
27a0 2e 00				ld l, 0 
27a2 18 02				jr .notip 
27a4			 
27a4 2e ff		.not2t:		ld l, 255 
27a6			 
27a6 26 00		.notip:		ld h, 0	 
27a8			 
27a8 cd 61 18				call forth_push_numhl 
27ab					NEXTW 
27ab c3 36 1a			jp macro_next 
27ae				endm 
# End of macro NEXTW
27ae			 
27ae			.IS: 
27ae				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
27ae 2d				db WORD_SYS_CORE+25             
27af d4 27			dw .LZERO            
27b1 03				db 2 + 1 
27b2 .. 00			db "IS",0              
27b5				endm 
# End of macro CWHEAD
27b5			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
27b5					if DEBUG_FORTH_WORDS_KEY 
27b5						DMARK "IS." 
27b5 f5				push af  
27b6 3a ca 27			ld a, (.dmark)  
27b9 32 bd fb			ld (debug_mark),a  
27bc 3a cb 27			ld a, (.dmark+1)  
27bf 32 be fb			ld (debug_mark+1),a  
27c2 3a cc 27			ld a, (.dmark+2)  
27c5 32 bf fb			ld (debug_mark+2),a  
27c8 18 03			jr .pastdmark  
27ca ..			.dmark: db "IS."  
27cd f1			.pastdmark: pop af  
27ce			endm  
# End of macro DMARK
27ce						CALLMONITOR 
27ce cd d7 12			call break_point_state  
27d1				endm  
# End of macro CALLMONITOR
27d1					endif 
27d1					NEXTW 
27d1 c3 36 1a			jp macro_next 
27d4				endm 
# End of macro NEXTW
27d4			.LZERO: 
27d4				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
27d4 2d				db WORD_SYS_CORE+25             
27d5 de 27			dw .TZERO            
27d7 03				db 2 + 1 
27d8 .. 00			db "0<",0              
27db				endm 
# End of macro CWHEAD
27db			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
27db					NEXTW 
27db c3 36 1a			jp macro_next 
27de				endm 
# End of macro NEXTW
27de			.TZERO: 
27de				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
27de 2e				db WORD_SYS_CORE+26             
27df 25 28			dw .LESS            
27e1 03				db 2 + 1 
27e2 .. 00			db "0=",0              
27e5				endm 
# End of macro CWHEAD
27e5			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
27e5				; TODO add floating point number detection 
27e5					;v5 FORTH_DSP_VALUE 
27e5					if DEBUG_FORTH_WORDS_KEY 
27e5						DMARK "0=." 
27e5 f5				push af  
27e6 3a fa 27			ld a, (.dmark)  
27e9 32 bd fb			ld (debug_mark),a  
27ec 3a fb 27			ld a, (.dmark+1)  
27ef 32 be fb			ld (debug_mark+1),a  
27f2 3a fc 27			ld a, (.dmark+2)  
27f5 32 bf fb			ld (debug_mark+2),a  
27f8 18 03			jr .pastdmark  
27fa ..			.dmark: db "0=."  
27fd f1			.pastdmark: pop af  
27fe			endm  
# End of macro DMARK
27fe						CALLMONITOR 
27fe cd d7 12			call break_point_state  
2801				endm  
# End of macro CALLMONITOR
2801					endif 
2801					FORTH_DSP 
2801 cd e1 18			call macro_forth_dsp 
2804				endm 
# End of macro FORTH_DSP
2804 7e					ld a,(hl)	; get type of value on TOS 
2805 fe 02				cp DS_TYPE_INUM  
2807 28 00				jr z, .tz_inum 
2809			 
2809				if FORTH_ENABLE_FLOATMATH 
2809					jr .tz_done 
2809			 
2809				endif 
2809					 
2809			 
2809			.tz_inum: 
2809					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2809 cd fc 18			call macro_dsp_valuehl 
280c				endm 
# End of macro FORTH_DSP_VALUEHL
280c			 
280c			;		push hl 
280c			 
280c					; destroy value TOS 
280c			 
280c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
280c cd 7c 19			call macro_forth_dsp_pop 
280f				endm 
# End of macro FORTH_DSP_POP
280f			 
280f			;		pop hl 
280f			 
280f 3e 00				ld a,0 
2811			 
2811 bd					cp l 
2812 20 08				jr nz, .tz_notzero 
2814			 
2814 bc					cp h 
2815			 
2815 20 05				jr nz, .tz_notzero 
2817			 
2817			 
2817 21 01 00				ld hl, FORTH_TRUE 
281a 18 03				jr .tz_done 
281c			 
281c 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
281f			 
281f					; push value back onto stack for another op etc 
281f			 
281f			.tz_done: 
281f cd 61 18				call forth_push_numhl 
2822			 
2822					NEXTW 
2822 c3 36 1a			jp macro_next 
2825				endm 
# End of macro NEXTW
2825			.LESS: 
2825				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
2825 2f				db WORD_SYS_CORE+27             
2826 72 28			dw .GT            
2828 02				db 1 + 1 
2829 .. 00			db "<",0              
282b				endm 
# End of macro CWHEAD
282b			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
282b				; TODO add floating point number detection 
282b					if DEBUG_FORTH_WORDS_KEY 
282b						DMARK "LES" 
282b f5				push af  
282c 3a 40 28			ld a, (.dmark)  
282f 32 bd fb			ld (debug_mark),a  
2832 3a 41 28			ld a, (.dmark+1)  
2835 32 be fb			ld (debug_mark+1),a  
2838 3a 42 28			ld a, (.dmark+2)  
283b 32 bf fb			ld (debug_mark+2),a  
283e 18 03			jr .pastdmark  
2840 ..			.dmark: db "LES"  
2843 f1			.pastdmark: pop af  
2844			endm  
# End of macro DMARK
2844						CALLMONITOR 
2844 cd d7 12			call break_point_state  
2847				endm  
# End of macro CALLMONITOR
2847					endif 
2847					FORTH_DSP 
2847 cd e1 18			call macro_forth_dsp 
284a				endm 
# End of macro FORTH_DSP
284a					;v5 FORTH_DSP_VALUE 
284a 7e					ld a,(hl)	; get type of value on TOS 
284b fe 02				cp DS_TYPE_INUM  
284d 28 00				jr z, .less_inum 
284f			 
284f				if FORTH_ENABLE_FLOATMATH 
284f					jr .less_done 
284f			 
284f				endif 
284f					 
284f			 
284f			.less_inum: 
284f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
284f cd fc 18			call macro_dsp_valuehl 
2852				endm 
# End of macro FORTH_DSP_VALUEHL
2852			 
2852 e5					push hl  ; u2 
2853			 
2853					; destroy value TOS 
2853			 
2853					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2853 cd 7c 19			call macro_forth_dsp_pop 
2856				endm 
# End of macro FORTH_DSP_POP
2856			 
2856			 
2856					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2856 cd fc 18			call macro_dsp_valuehl 
2859				endm 
# End of macro FORTH_DSP_VALUEHL
2859			 
2859 e5					push hl    ; u1 
285a			 
285a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
285a cd 7c 19			call macro_forth_dsp_pop 
285d				endm 
# End of macro FORTH_DSP_POP
285d			 
285d			 
285d b7			 or a      ;clear carry flag 
285e 01 00 00		 ld bc, FORTH_FALSE 
2861 e1			  pop hl    ; u1 
2862 d1			  pop de    ; u2 
2863 ed 52		  sbc hl,de 
2865 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
2867			 
2867 01 01 00		 ld bc, FORTH_TRUE 
286a			.lscont:  
286a c5					push bc 
286b e1					pop hl 
286c			 
286c					if DEBUG_FORTH_WORDS 
286c						DMARK "LT1" 
286c						CALLMONITOR 
286c					endif 
286c cd 61 18				call forth_push_numhl 
286f			 
286f					NEXTW 
286f c3 36 1a			jp macro_next 
2872				endm 
# End of macro NEXTW
2872			.GT: 
2872				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
2872 30				db WORD_SYS_CORE+28             
2873 bf 28			dw .EQUAL            
2875 02				db 1 + 1 
2876 .. 00			db ">",0              
2878				endm 
# End of macro CWHEAD
2878			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
2878				; TODO add floating point number detection 
2878					if DEBUG_FORTH_WORDS_KEY 
2878						DMARK "GRT" 
2878 f5				push af  
2879 3a 8d 28			ld a, (.dmark)  
287c 32 bd fb			ld (debug_mark),a  
287f 3a 8e 28			ld a, (.dmark+1)  
2882 32 be fb			ld (debug_mark+1),a  
2885 3a 8f 28			ld a, (.dmark+2)  
2888 32 bf fb			ld (debug_mark+2),a  
288b 18 03			jr .pastdmark  
288d ..			.dmark: db "GRT"  
2890 f1			.pastdmark: pop af  
2891			endm  
# End of macro DMARK
2891						CALLMONITOR 
2891 cd d7 12			call break_point_state  
2894				endm  
# End of macro CALLMONITOR
2894					endif 
2894					FORTH_DSP 
2894 cd e1 18			call macro_forth_dsp 
2897				endm 
# End of macro FORTH_DSP
2897					;FORTH_DSP_VALUE 
2897 7e					ld a,(hl)	; get type of value on TOS 
2898 fe 02				cp DS_TYPE_INUM  
289a 28 00				jr z, .gt_inum 
289c			 
289c				if FORTH_ENABLE_FLOATMATH 
289c					jr .gt_done 
289c			 
289c				endif 
289c					 
289c			 
289c			.gt_inum: 
289c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
289c cd fc 18			call macro_dsp_valuehl 
289f				endm 
# End of macro FORTH_DSP_VALUEHL
289f			 
289f e5					push hl  ; u2 
28a0			 
28a0					; destroy value TOS 
28a0			 
28a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28a0 cd 7c 19			call macro_forth_dsp_pop 
28a3				endm 
# End of macro FORTH_DSP_POP
28a3			 
28a3			 
28a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28a3 cd fc 18			call macro_dsp_valuehl 
28a6				endm 
# End of macro FORTH_DSP_VALUEHL
28a6			 
28a6 e5					push hl    ; u1 
28a7			 
28a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28a7 cd 7c 19			call macro_forth_dsp_pop 
28aa				endm 
# End of macro FORTH_DSP_POP
28aa			 
28aa			 
28aa b7			 or a      ;clear carry flag 
28ab 01 00 00		 ld bc, FORTH_FALSE 
28ae e1			  pop hl    ; u1 
28af d1			  pop de    ; u2 
28b0 ed 52		  sbc hl,de 
28b2 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
28b4			 
28b4 01 01 00		 ld bc, FORTH_TRUE 
28b7			.gtcont:  
28b7 c5					push bc 
28b8 e1					pop hl 
28b9			 
28b9					if DEBUG_FORTH_WORDS 
28b9						DMARK "GT1" 
28b9						CALLMONITOR 
28b9					endif 
28b9 cd 61 18				call forth_push_numhl 
28bc			 
28bc					NEXTW 
28bc c3 36 1a			jp macro_next 
28bf				endm 
# End of macro NEXTW
28bf			.EQUAL: 
28bf				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
28bf 31				db WORD_SYS_CORE+29             
28c0 0e 29			dw .ENDLOGIC            
28c2 02				db 1 + 1 
28c3 .. 00			db "=",0              
28c5				endm 
# End of macro CWHEAD
28c5			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
28c5				; TODO add floating point number detection 
28c5					if DEBUG_FORTH_WORDS_KEY 
28c5						DMARK "EQ." 
28c5 f5				push af  
28c6 3a da 28			ld a, (.dmark)  
28c9 32 bd fb			ld (debug_mark),a  
28cc 3a db 28			ld a, (.dmark+1)  
28cf 32 be fb			ld (debug_mark+1),a  
28d2 3a dc 28			ld a, (.dmark+2)  
28d5 32 bf fb			ld (debug_mark+2),a  
28d8 18 03			jr .pastdmark  
28da ..			.dmark: db "EQ."  
28dd f1			.pastdmark: pop af  
28de			endm  
# End of macro DMARK
28de						CALLMONITOR 
28de cd d7 12			call break_point_state  
28e1				endm  
# End of macro CALLMONITOR
28e1					endif 
28e1					FORTH_DSP 
28e1 cd e1 18			call macro_forth_dsp 
28e4				endm 
# End of macro FORTH_DSP
28e4					;v5 FORTH_DSP_VALUE 
28e4 7e					ld a,(hl)	; get type of value on TOS 
28e5 fe 02				cp DS_TYPE_INUM  
28e7 28 00				jr z, .eq_inum 
28e9			 
28e9				if FORTH_ENABLE_FLOATMATH 
28e9					jr .eq_done 
28e9			 
28e9				endif 
28e9					 
28e9			 
28e9			.eq_inum: 
28e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28e9 cd fc 18			call macro_dsp_valuehl 
28ec				endm 
# End of macro FORTH_DSP_VALUEHL
28ec			 
28ec e5					push hl 
28ed			 
28ed					; destroy value TOS 
28ed			 
28ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28ed cd 7c 19			call macro_forth_dsp_pop 
28f0				endm 
# End of macro FORTH_DSP_POP
28f0			 
28f0			 
28f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28f0 cd fc 18			call macro_dsp_valuehl 
28f3				endm 
# End of macro FORTH_DSP_VALUEHL
28f3			 
28f3					; one value on hl get other one back 
28f3			 
28f3 e5					push hl 
28f4			 
28f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28f4 cd 7c 19			call macro_forth_dsp_pop 
28f7				endm 
# End of macro FORTH_DSP_POP
28f7			 
28f7 0e 00				ld c, FORTH_FALSE 
28f9			 
28f9 e1					pop hl 
28fa d1					pop de 
28fb			 
28fb 7b					ld a, e 
28fc bd					cp l 
28fd			 
28fd 20 06				jr nz, .eq_done 
28ff			 
28ff 7a					ld a, d 
2900 bc					cp h 
2901			 
2901 20 02				jr nz, .eq_done 
2903			 
2903 0e 01				ld c, FORTH_TRUE 
2905					 
2905			 
2905			 
2905			.eq_done: 
2905			 
2905					; TODO push value back onto stack for another op etc 
2905			 
2905 26 00				ld h, 0 
2907 69					ld l, c 
2908					if DEBUG_FORTH_WORDS 
2908						DMARK "EQ1" 
2908						CALLMONITOR 
2908					endif 
2908 cd 61 18				call forth_push_numhl 
290b			 
290b					NEXTW 
290b c3 36 1a			jp macro_next 
290e				endm 
# End of macro NEXTW
290e			 
290e			 
290e			.ENDLOGIC: 
290e			; eof 
290e			 
290e			 
# End of file forth_words_logic.asm
290e			include "forth_words_maths.asm" 
290e			 
290e			; | ## Maths Words 
290e			 
290e			.PLUS:	 
290e				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
290e 15				db WORD_SYS_CORE+1             
290f 50 29			dw .NEG            
2911 02				db 1 + 1 
2912 .. 00			db "+",0              
2914				endm 
# End of macro CWHEAD
2914			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
2914					if DEBUG_FORTH_WORDS_KEY 
2914						DMARK "PLU" 
2914 f5				push af  
2915 3a 29 29			ld a, (.dmark)  
2918 32 bd fb			ld (debug_mark),a  
291b 3a 2a 29			ld a, (.dmark+1)  
291e 32 be fb			ld (debug_mark+1),a  
2921 3a 2b 29			ld a, (.dmark+2)  
2924 32 bf fb			ld (debug_mark+2),a  
2927 18 03			jr .pastdmark  
2929 ..			.dmark: db "PLU"  
292c f1			.pastdmark: pop af  
292d			endm  
# End of macro DMARK
292d						CALLMONITOR 
292d cd d7 12			call break_point_state  
2930				endm  
# End of macro CALLMONITOR
2930					endif 
2930					; add top two values and push back result 
2930			 
2930					;for v5 FORTH_DSP_VALUE 
2930					FORTH_DSP 
2930 cd e1 18			call macro_forth_dsp 
2933				endm 
# End of macro FORTH_DSP
2933 7e					ld a,(hl)	; get type of value on TOS 
2934 fe 02				cp DS_TYPE_INUM  
2936 28 03				jr z, .dot_inum 
2938			 
2938					NEXTW 
2938 c3 36 1a			jp macro_next 
293b				endm 
# End of macro NEXTW
293b			 
293b			; float maths 
293b			 
293b				if FORTH_ENABLE_FLOATMATH 
293b						inc hl      ; now at start of numeric as string 
293b			 
293b					if DEBUG_FORTH_MATHS 
293b						DMARK "ADD" 
293b				CALLMONITOR 
293b					endif 
293b			 
293b					;ld ix, hl 
293b					call CON 
293b			 
293b			 
293b					push hl 
293b					 
293b					 
293b			 
293b						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
293b			 
293b					; get next number 
293b			 
293b						FORTH_DSP_VALUE 
293b			 
293b						inc hl      ; now at start of numeric as string 
293b			 
293b					;ld ix, hl 
293b					call CON 
293b			 
293b					push hl 
293b			 
293b			 
293b						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
293b			 
293b						; TODO do add 
293b			 
293b						call IADD 
293b			 
293b						; TODO get result back as ascii 
293b			 
293b						; TODO push result  
293b			 
293b			 
293b			 
293b						jr .dot_done 
293b				endif 
293b			 
293b			.dot_inum: 
293b			 
293b			 
293b					if DEBUG_FORTH_DOT 
293b						DMARK "+IT" 
293b				CALLMONITOR 
293b					endif 
293b			 
293b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
293b cd fc 18			call macro_dsp_valuehl 
293e				endm 
# End of macro FORTH_DSP_VALUEHL
293e			 
293e				; TODO add floating point number detection 
293e			 
293e e5					push hl 
293f			 
293f					; destroy value TOS 
293f			 
293f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
293f cd 7c 19			call macro_forth_dsp_pop 
2942				endm 
# End of macro FORTH_DSP_POP
2942			 
2942			 
2942					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2942 cd fc 18			call macro_dsp_valuehl 
2945				endm 
# End of macro FORTH_DSP_VALUEHL
2945			 
2945					; one value on hl get other one back 
2945			 
2945 d1					pop de 
2946			 
2946					; do the add 
2946			 
2946 19					add hl,de 
2947			 
2947					; save it 
2947			 
2947			;		push hl	 
2947			 
2947					; 
2947			 
2947					; destroy value TOS 
2947			 
2947					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2947 cd 7c 19			call macro_forth_dsp_pop 
294a				endm 
# End of macro FORTH_DSP_POP
294a			 
294a					; TODO push value back onto stack for another op etc 
294a			 
294a			;		pop hl 
294a			 
294a			.dot_done: 
294a cd 61 18				call forth_push_numhl 
294d			 
294d					NEXTW 
294d c3 36 1a			jp macro_next 
2950				endm 
# End of macro NEXTW
2950			.NEG: 
2950			 
2950				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
2950 17				db WORD_SYS_CORE+3             
2951 93 29			dw .DIV            
2953 02				db 1 + 1 
2954 .. 00			db "-",0              
2956				endm 
# End of macro CWHEAD
2956			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
2956					if DEBUG_FORTH_WORDS_KEY 
2956						DMARK "SUB" 
2956 f5				push af  
2957 3a 6b 29			ld a, (.dmark)  
295a 32 bd fb			ld (debug_mark),a  
295d 3a 6c 29			ld a, (.dmark+1)  
2960 32 be fb			ld (debug_mark+1),a  
2963 3a 6d 29			ld a, (.dmark+2)  
2966 32 bf fb			ld (debug_mark+2),a  
2969 18 03			jr .pastdmark  
296b ..			.dmark: db "SUB"  
296e f1			.pastdmark: pop af  
296f			endm  
# End of macro DMARK
296f						CALLMONITOR 
296f cd d7 12			call break_point_state  
2972				endm  
# End of macro CALLMONITOR
2972					endif 
2972			 
2972			 
2972				; TODO add floating point number detection 
2972					; v5 FORTH_DSP_VALUE 
2972					FORTH_DSP 
2972 cd e1 18			call macro_forth_dsp 
2975				endm 
# End of macro FORTH_DSP
2975 7e					ld a,(hl)	; get type of value on TOS 
2976 fe 02				cp DS_TYPE_INUM  
2978 28 03				jr z, .neg_inum 
297a			 
297a					NEXTW 
297a c3 36 1a			jp macro_next 
297d				endm 
# End of macro NEXTW
297d			 
297d			; float maths 
297d			 
297d				if FORTH_ENABLE_FLOATMATH 
297d					jr .neg_done 
297d			 
297d				endif 
297d					 
297d			 
297d			.neg_inum: 
297d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
297d cd fc 18			call macro_dsp_valuehl 
2980				endm 
# End of macro FORTH_DSP_VALUEHL
2980			 
2980 e5					push hl 
2981			 
2981					; destroy value TOS 
2981			 
2981					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2981 cd 7c 19			call macro_forth_dsp_pop 
2984				endm 
# End of macro FORTH_DSP_POP
2984			 
2984			 
2984					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2984 cd fc 18			call macro_dsp_valuehl 
2987				endm 
# End of macro FORTH_DSP_VALUEHL
2987			 
2987					; one value on hl get other one back 
2987			 
2987 d1					pop de 
2988			 
2988					; do the sub 
2988			;		ex de, hl 
2988			 
2988 ed 52				sbc hl,de 
298a			 
298a					; save it 
298a			 
298a			;		push hl	 
298a			 
298a					; 
298a			 
298a					; destroy value TOS 
298a			 
298a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
298a cd 7c 19			call macro_forth_dsp_pop 
298d				endm 
# End of macro FORTH_DSP_POP
298d			 
298d					; TODO push value back onto stack for another op etc 
298d			 
298d			;		pop hl 
298d			 
298d cd 61 18				call forth_push_numhl 
2990			.neg_done: 
2990			 
2990					NEXTW 
2990 c3 36 1a			jp macro_next 
2993				endm 
# End of macro NEXTW
2993			.DIV: 
2993				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
2993 18				db WORD_SYS_CORE+4             
2994 e0 29			dw .MUL            
2996 02				db 1 + 1 
2997 .. 00			db "/",0              
2999				endm 
# End of macro CWHEAD
2999			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
2999					if DEBUG_FORTH_WORDS_KEY 
2999						DMARK "DIV" 
2999 f5				push af  
299a 3a ae 29			ld a, (.dmark)  
299d 32 bd fb			ld (debug_mark),a  
29a0 3a af 29			ld a, (.dmark+1)  
29a3 32 be fb			ld (debug_mark+1),a  
29a6 3a b0 29			ld a, (.dmark+2)  
29a9 32 bf fb			ld (debug_mark+2),a  
29ac 18 03			jr .pastdmark  
29ae ..			.dmark: db "DIV"  
29b1 f1			.pastdmark: pop af  
29b2			endm  
# End of macro DMARK
29b2						CALLMONITOR 
29b2 cd d7 12			call break_point_state  
29b5				endm  
# End of macro CALLMONITOR
29b5					endif 
29b5				; TODO add floating point number detection 
29b5					; v5 FORTH_DSP_VALUE 
29b5					FORTH_DSP 
29b5 cd e1 18			call macro_forth_dsp 
29b8				endm 
# End of macro FORTH_DSP
29b8 7e					ld a,(hl)	; get type of value on TOS 
29b9 fe 02				cp DS_TYPE_INUM  
29bb 28 03				jr z, .div_inum 
29bd			 
29bd				if FORTH_ENABLE_FLOATMATH 
29bd					jr .div_done 
29bd			 
29bd				endif 
29bd					NEXTW 
29bd c3 36 1a			jp macro_next 
29c0				endm 
# End of macro NEXTW
29c0			.div_inum: 
29c0			 
29c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29c0 cd fc 18			call macro_dsp_valuehl 
29c3				endm 
# End of macro FORTH_DSP_VALUEHL
29c3			 
29c3 e5					push hl    ; to go to bc 
29c4			 
29c4					; destroy value TOS 
29c4			 
29c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c4 cd 7c 19			call macro_forth_dsp_pop 
29c7				endm 
# End of macro FORTH_DSP_POP
29c7			 
29c7			 
29c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29c7 cd fc 18			call macro_dsp_valuehl 
29ca				endm 
# End of macro FORTH_DSP_VALUEHL
29ca			 
29ca					; hl to go to de 
29ca			 
29ca e5					push hl 
29cb			 
29cb c1					pop bc 
29cc d1					pop de		 
29cd			 
29cd			 
29cd					if DEBUG_FORTH_MATHS 
29cd						DMARK "DIV" 
29cd				CALLMONITOR 
29cd					endif 
29cd					; one value on hl but move to a get other one back 
29cd			 
29cd			        
29cd cd 70 0a			call Div16 
29d0			 
29d0			;	push af	 
29d0 e5				push hl 
29d1 c5				push bc 
29d2			 
29d2					if DEBUG_FORTH_MATHS 
29d2						DMARK "DI1" 
29d2				CALLMONITOR 
29d2					endif 
29d2			 
29d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29d2 cd 7c 19			call macro_forth_dsp_pop 
29d5				endm 
# End of macro FORTH_DSP_POP
29d5			 
29d5			 
29d5			 
29d5 e1					pop hl    ; result 
29d6			 
29d6 cd 61 18				call forth_push_numhl 
29d9			 
29d9 e1					pop hl    ; reminder 
29da			;		ld h,0 
29da			;		ld l,d 
29da			 
29da cd 61 18				call forth_push_numhl 
29dd			.div_done: 
29dd					NEXTW 
29dd c3 36 1a			jp macro_next 
29e0				endm 
# End of macro NEXTW
29e0			.MUL: 
29e0				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
29e0 19				db WORD_SYS_CORE+5             
29e1 25 2a			dw .MIN            
29e3 02				db 1 + 1 
29e4 .. 00			db "*",0              
29e6				endm 
# End of macro CWHEAD
29e6			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
29e6				; TODO add floating point number detection 
29e6					if DEBUG_FORTH_WORDS_KEY 
29e6						DMARK "MUL" 
29e6 f5				push af  
29e7 3a fb 29			ld a, (.dmark)  
29ea 32 bd fb			ld (debug_mark),a  
29ed 3a fc 29			ld a, (.dmark+1)  
29f0 32 be fb			ld (debug_mark+1),a  
29f3 3a fd 29			ld a, (.dmark+2)  
29f6 32 bf fb			ld (debug_mark+2),a  
29f9 18 03			jr .pastdmark  
29fb ..			.dmark: db "MUL"  
29fe f1			.pastdmark: pop af  
29ff			endm  
# End of macro DMARK
29ff						CALLMONITOR 
29ff cd d7 12			call break_point_state  
2a02				endm  
# End of macro CALLMONITOR
2a02					endif 
2a02					FORTH_DSP 
2a02 cd e1 18			call macro_forth_dsp 
2a05				endm 
# End of macro FORTH_DSP
2a05					; v5 FORTH_DSP_VALUE 
2a05 7e					ld a,(hl)	; get type of value on TOS 
2a06 fe 02				cp DS_TYPE_INUM  
2a08 28 03				jr z, .mul_inum 
2a0a			 
2a0a				if FORTH_ENABLE_FLOATMATH 
2a0a					jr .mul_done 
2a0a			 
2a0a				endif 
2a0a			 
2a0a					NEXTW 
2a0a c3 36 1a			jp macro_next 
2a0d				endm 
# End of macro NEXTW
2a0d			.mul_inum:	 
2a0d			 
2a0d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a0d cd fc 18			call macro_dsp_valuehl 
2a10				endm 
# End of macro FORTH_DSP_VALUEHL
2a10			 
2a10 e5					push hl 
2a11			 
2a11					; destroy value TOS 
2a11			 
2a11					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a11 cd 7c 19			call macro_forth_dsp_pop 
2a14				endm 
# End of macro FORTH_DSP_POP
2a14			 
2a14			 
2a14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a14 cd fc 18			call macro_dsp_valuehl 
2a17				endm 
# End of macro FORTH_DSP_VALUEHL
2a17			 
2a17					; one value on hl but move to a get other one back 
2a17			 
2a17 7d					ld a, l 
2a18			 
2a18 d1					pop de 
2a19			 
2a19					; do the mull 
2a19			;		ex de, hl 
2a19			 
2a19 cd 96 0a				call Mult16 
2a1c					; save it 
2a1c			 
2a1c			;		push hl	 
2a1c			 
2a1c					; 
2a1c			 
2a1c					; destroy value TOS 
2a1c			 
2a1c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a1c cd 7c 19			call macro_forth_dsp_pop 
2a1f				endm 
# End of macro FORTH_DSP_POP
2a1f			 
2a1f					; TODO push value back onto stack for another op etc 
2a1f			 
2a1f			;		pop hl 
2a1f			 
2a1f cd 61 18				call forth_push_numhl 
2a22			 
2a22			.mul_done: 
2a22					NEXTW 
2a22 c3 36 1a			jp macro_next 
2a25				endm 
# End of macro NEXTW
2a25			 
2a25			 
2a25			 
2a25			 
2a25			.MIN: 
2a25				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
2a25 49				db WORD_SYS_CORE+53             
2a26 6e 2a			dw .MAX            
2a28 04				db 3 + 1 
2a29 .. 00			db "MIN",0              
2a2d				endm 
# End of macro CWHEAD
2a2d			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
2a2d					if DEBUG_FORTH_WORDS_KEY 
2a2d						DMARK "MIN" 
2a2d f5				push af  
2a2e 3a 42 2a			ld a, (.dmark)  
2a31 32 bd fb			ld (debug_mark),a  
2a34 3a 43 2a			ld a, (.dmark+1)  
2a37 32 be fb			ld (debug_mark+1),a  
2a3a 3a 44 2a			ld a, (.dmark+2)  
2a3d 32 bf fb			ld (debug_mark+2),a  
2a40 18 03			jr .pastdmark  
2a42 ..			.dmark: db "MIN"  
2a45 f1			.pastdmark: pop af  
2a46			endm  
# End of macro DMARK
2a46						CALLMONITOR 
2a46 cd d7 12			call break_point_state  
2a49				endm  
# End of macro CALLMONITOR
2a49					endif 
2a49					; get u2 
2a49			 
2a49					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a49 cd fc 18			call macro_dsp_valuehl 
2a4c				endm 
# End of macro FORTH_DSP_VALUEHL
2a4c			 
2a4c e5					push hl   ; u2 
2a4d			 
2a4d					; destroy value TOS 
2a4d			 
2a4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a4d cd 7c 19			call macro_forth_dsp_pop 
2a50				endm 
# End of macro FORTH_DSP_POP
2a50			 
2a50					; get u1 
2a50			 
2a50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a50 cd fc 18			call macro_dsp_valuehl 
2a53				endm 
# End of macro FORTH_DSP_VALUEHL
2a53			 
2a53 e5					push hl  ; u1 
2a54			 
2a54					; destroy value TOS 
2a54			 
2a54					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a54 cd 7c 19			call macro_forth_dsp_pop 
2a57				endm 
# End of macro FORTH_DSP_POP
2a57			 
2a57 b7			 or a      ;clear carry flag 
2a58 e1			  pop hl    ; u1 
2a59 d1			  pop de    ; u2 
2a5a e5				push hl   ; saved in case hl is lowest 
2a5b ed 52		  sbc hl,de 
2a5d 30 07		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
2a5f			 
2a5f e1				pop hl 
2a60					if DEBUG_FORTH_WORDS 
2a60						DMARK "MIN" 
2a60						CALLMONITOR 
2a60					endif 
2a60 cd 61 18				call forth_push_numhl 
2a63			 
2a63				       NEXTW 
2a63 c3 36 1a			jp macro_next 
2a66				endm 
# End of macro NEXTW
2a66			 
2a66			.mincont:  
2a66 c1				pop bc   ; tidy up 
2a67 eb				ex de , hl  
2a68					if DEBUG_FORTH_WORDS 
2a68						DMARK "MI1" 
2a68						CALLMONITOR 
2a68					endif 
2a68 cd 61 18				call forth_push_numhl 
2a6b			 
2a6b				       NEXTW 
2a6b c3 36 1a			jp macro_next 
2a6e				endm 
# End of macro NEXTW
2a6e			.MAX: 
2a6e				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
2a6e 4a				db WORD_SYS_CORE+54             
2a6f b7 2a			dw .RND16            
2a71 04				db 3 + 1 
2a72 .. 00			db "MAX",0              
2a76				endm 
# End of macro CWHEAD
2a76			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
2a76					if DEBUG_FORTH_WORDS_KEY 
2a76						DMARK "MAX" 
2a76 f5				push af  
2a77 3a 8b 2a			ld a, (.dmark)  
2a7a 32 bd fb			ld (debug_mark),a  
2a7d 3a 8c 2a			ld a, (.dmark+1)  
2a80 32 be fb			ld (debug_mark+1),a  
2a83 3a 8d 2a			ld a, (.dmark+2)  
2a86 32 bf fb			ld (debug_mark+2),a  
2a89 18 03			jr .pastdmark  
2a8b ..			.dmark: db "MAX"  
2a8e f1			.pastdmark: pop af  
2a8f			endm  
# End of macro DMARK
2a8f						CALLMONITOR 
2a8f cd d7 12			call break_point_state  
2a92				endm  
# End of macro CALLMONITOR
2a92					endif 
2a92					; get u2 
2a92			 
2a92					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a92 cd fc 18			call macro_dsp_valuehl 
2a95				endm 
# End of macro FORTH_DSP_VALUEHL
2a95			 
2a95 e5					push hl   ; u2 
2a96			 
2a96					; destroy value TOS 
2a96			 
2a96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a96 cd 7c 19			call macro_forth_dsp_pop 
2a99				endm 
# End of macro FORTH_DSP_POP
2a99			 
2a99					; get u1 
2a99			 
2a99					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a99 cd fc 18			call macro_dsp_valuehl 
2a9c				endm 
# End of macro FORTH_DSP_VALUEHL
2a9c			 
2a9c e5					push hl  ; u1 
2a9d			 
2a9d					; destroy value TOS 
2a9d			 
2a9d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a9d cd 7c 19			call macro_forth_dsp_pop 
2aa0				endm 
# End of macro FORTH_DSP_POP
2aa0			 
2aa0 b7			 or a      ;clear carry flag 
2aa1 e1			  pop hl    ; u1 
2aa2 d1			  pop de    ; u2 
2aa3 e5				push hl   ; saved in case hl is lowest 
2aa4 ed 52		  sbc hl,de 
2aa6 38 07		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
2aa8			 
2aa8 e1				pop hl 
2aa9					if DEBUG_FORTH_WORDS 
2aa9						DMARK "MAX" 
2aa9						CALLMONITOR 
2aa9					endif 
2aa9 cd 61 18				call forth_push_numhl 
2aac			 
2aac				       NEXTW 
2aac c3 36 1a			jp macro_next 
2aaf				endm 
# End of macro NEXTW
2aaf			 
2aaf			.maxcont:  
2aaf c1				pop bc   ; tidy up 
2ab0 eb				ex de , hl  
2ab1					if DEBUG_FORTH_WORDS 
2ab1						DMARK "MA1" 
2ab1						CALLMONITOR 
2ab1					endif 
2ab1 cd 61 18				call forth_push_numhl 
2ab4				       NEXTW 
2ab4 c3 36 1a			jp macro_next 
2ab7				endm 
# End of macro NEXTW
2ab7			 
2ab7			.RND16: 
2ab7				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
2ab7 4e				db WORD_SYS_CORE+58             
2ab8 e6 2a			dw .RND8            
2aba 06				db 5 + 1 
2abb .. 00			db "RND16",0              
2ac1				endm 
# End of macro CWHEAD
2ac1			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
2ac1					if DEBUG_FORTH_WORDS_KEY 
2ac1						DMARK "R16" 
2ac1 f5				push af  
2ac2 3a d6 2a			ld a, (.dmark)  
2ac5 32 bd fb			ld (debug_mark),a  
2ac8 3a d7 2a			ld a, (.dmark+1)  
2acb 32 be fb			ld (debug_mark+1),a  
2ace 3a d8 2a			ld a, (.dmark+2)  
2ad1 32 bf fb			ld (debug_mark+2),a  
2ad4 18 03			jr .pastdmark  
2ad6 ..			.dmark: db "R16"  
2ad9 f1			.pastdmark: pop af  
2ada			endm  
# End of macro DMARK
2ada						CALLMONITOR 
2ada cd d7 12			call break_point_state  
2add				endm  
# End of macro CALLMONITOR
2add					endif 
2add cd 3a 0a				call prng16  
2ae0 cd 61 18				call forth_push_numhl 
2ae3				       NEXTW 
2ae3 c3 36 1a			jp macro_next 
2ae6				endm 
# End of macro NEXTW
2ae6			.RND8: 
2ae6				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
2ae6 60				db WORD_SYS_CORE+76             
2ae7 1b 2b			dw .RND            
2ae9 05				db 4 + 1 
2aea .. 00			db "RND8",0              
2aef				endm 
# End of macro CWHEAD
2aef			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
2aef					if DEBUG_FORTH_WORDS_KEY 
2aef						DMARK "RN8" 
2aef f5				push af  
2af0 3a 04 2b			ld a, (.dmark)  
2af3 32 bd fb			ld (debug_mark),a  
2af6 3a 05 2b			ld a, (.dmark+1)  
2af9 32 be fb			ld (debug_mark+1),a  
2afc 3a 06 2b			ld a, (.dmark+2)  
2aff 32 bf fb			ld (debug_mark+2),a  
2b02 18 03			jr .pastdmark  
2b04 ..			.dmark: db "RN8"  
2b07 f1			.pastdmark: pop af  
2b08			endm  
# End of macro DMARK
2b08						CALLMONITOR 
2b08 cd d7 12			call break_point_state  
2b0b				endm  
# End of macro CALLMONITOR
2b0b					endif 
2b0b 2a 3e fa				ld hl,(xrandc) 
2b0e 23					inc hl 
2b0f cd 54 0a				call xrnd 
2b12 6f					ld l,a	 
2b13 26 00				ld h,0 
2b15 cd 61 18				call forth_push_numhl 
2b18				       NEXTW 
2b18 c3 36 1a			jp macro_next 
2b1b				endm 
# End of macro NEXTW
2b1b			.RND: 
2b1b				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
2b1b 60				db WORD_SYS_CORE+76             
2b1c 79 2b			dw .ENDMATHS            
2b1e 04				db 3 + 1 
2b1f .. 00			db "RND",0              
2b23				endm 
# End of macro CWHEAD
2b23			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
2b23			 
2b23					if DEBUG_FORTH_WORDS_KEY 
2b23						DMARK "RND" 
2b23 f5				push af  
2b24 3a 38 2b			ld a, (.dmark)  
2b27 32 bd fb			ld (debug_mark),a  
2b2a 3a 39 2b			ld a, (.dmark+1)  
2b2d 32 be fb			ld (debug_mark+1),a  
2b30 3a 3a 2b			ld a, (.dmark+2)  
2b33 32 bf fb			ld (debug_mark+2),a  
2b36 18 03			jr .pastdmark  
2b38 ..			.dmark: db "RND"  
2b3b f1			.pastdmark: pop af  
2b3c			endm  
# End of macro DMARK
2b3c						CALLMONITOR 
2b3c cd d7 12			call break_point_state  
2b3f				endm  
# End of macro CALLMONITOR
2b3f					endif 
2b3f					 
2b3f					FORTH_DSP_VALUEHL    ; upper range 
2b3f cd fc 18			call macro_dsp_valuehl 
2b42				endm 
# End of macro FORTH_DSP_VALUEHL
2b42			 
2b42 22 42 fa				ld (LFSRSeed), hl	 
2b45			 
2b45					if DEBUG_FORTH_WORDS 
2b45						DMARK "RN1" 
2b45						CALLMONITOR 
2b45					endif 
2b45					FORTH_DSP_POP 
2b45 cd 7c 19			call macro_forth_dsp_pop 
2b48				endm 
# End of macro FORTH_DSP_POP
2b48			 
2b48					FORTH_DSP_VALUEHL    ; low range 
2b48 cd fc 18			call macro_dsp_valuehl 
2b4b				endm 
# End of macro FORTH_DSP_VALUEHL
2b4b			 
2b4b					if DEBUG_FORTH_WORDS 
2b4b						DMARK "RN2" 
2b4b						CALLMONITOR 
2b4b					endif 
2b4b 22 44 fa				ld (LFSRSeed+2), hl 
2b4e			 
2b4e					FORTH_DSP_POP 
2b4e cd 7c 19			call macro_forth_dsp_pop 
2b51				endm 
# End of macro FORTH_DSP_POP
2b51			 
2b51 e5					push hl 
2b52			 
2b52 e1			.inrange:	pop hl 
2b53 cd 3a 0a				call prng16  
2b56					if DEBUG_FORTH_WORDS 
2b56						DMARK "RN3" 
2b56						CALLMONITOR 
2b56					endif 
2b56					 
2b56					; if the range is 8bit knock out the high byte 
2b56			 
2b56 ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
2b5a			 
2b5a 3e 00				ld a, 0 
2b5c ba					cp d  
2b5d 20 02				jr nz, .hirange 
2b5f 26 00				ld h, 0   ; knock it down to 8bit 
2b61			 
2b61					if DEBUG_FORTH_WORDS 
2b61						DMARK "RNk" 
2b61						CALLMONITOR 
2b61					endif 
2b61			.hirange:   
2b61 e5					push hl  
2b62 b7					or a  
2b63 ed 52		                sbc hl, de 
2b65			 
2b65					;call cmp16 
2b65			 
2b65 30 eb				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
2b67 e1					pop hl 
2b68 e5					push hl 
2b69			 
2b69					if DEBUG_FORTH_WORDS 
2b69						DMARK "RN4" 
2b69						CALLMONITOR 
2b69					endif 
2b69 ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
2b6d					;call cmp16 
2b6d				 
2b6d b7					or a  
2b6e ed 52		                sbc hl, de 
2b70 38 e0				jr c, .inrange 
2b72			 
2b72 e1					pop hl 
2b73					 
2b73					if DEBUG_FORTH_WORDS 
2b73						DMARK "RNd" 
2b73						CALLMONITOR 
2b73					endif 
2b73			 
2b73			 
2b73 cd 61 18				call forth_push_numhl 
2b76				       NEXTW 
2b76 c3 36 1a			jp macro_next 
2b79				endm 
# End of macro NEXTW
2b79			 
2b79			.ENDMATHS: 
2b79			 
2b79			; eof 
2b79			 
# End of file forth_words_maths.asm
2b79			include "forth_words_display.asm" 
2b79			 
2b79			; | ## Display Words 
2b79			 
2b79			.ATP: 
2b79				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
2b79 62				db WORD_SYS_CORE+78             
2b7a b8 2b			dw .FB            
2b7c 04				db 3 + 1 
2b7d .. 00			db "AT?",0              
2b81				endm 
# End of macro CWHEAD
2b81			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
2b81					if DEBUG_FORTH_WORDS_KEY 
2b81						DMARK "AT?" 
2b81 f5				push af  
2b82 3a 96 2b			ld a, (.dmark)  
2b85 32 bd fb			ld (debug_mark),a  
2b88 3a 97 2b			ld a, (.dmark+1)  
2b8b 32 be fb			ld (debug_mark+1),a  
2b8e 3a 98 2b			ld a, (.dmark+2)  
2b91 32 bf fb			ld (debug_mark+2),a  
2b94 18 03			jr .pastdmark  
2b96 ..			.dmark: db "AT?"  
2b99 f1			.pastdmark: pop af  
2b9a			endm  
# End of macro DMARK
2b9a						CALLMONITOR 
2b9a cd d7 12			call break_point_state  
2b9d				endm  
# End of macro CALLMONITOR
2b9d					endif 
2b9d 3a e1 f9				ld a, (f_cursor_ptr) 
2ba0			 
2ba0			if DEBUG_FORTH_WORDS 
2ba0				DMARK "AT?" 
2ba0				CALLMONITOR 
2ba0			endif	 
2ba0					; count the number of rows 
2ba0			 
2ba0 06 00				ld b, 0 
2ba2 4f			.atpr:		ld c, a    ; save in case we go below zero 
2ba3 d6 14				sub display_cols 
2ba5 f2 ab 2b				jp p, .atprunder 
2ba8 04					inc b 
2ba9 18 f7				jr .atpr 
2bab			.atprunder:	 
2bab			if DEBUG_FORTH_WORDS 
2bab				DMARK "A?2" 
2bab				CALLMONITOR 
2bab			endif	 
2bab 26 00				ld h, 0 
2bad 69					ld l, c 
2bae cd 61 18				call forth_push_numhl 
2bb1 68					ld l, b  
2bb2 cd 61 18				call forth_push_numhl 
2bb5			 
2bb5			 
2bb5				NEXTW 
2bb5 c3 36 1a			jp macro_next 
2bb8				endm 
# End of macro NEXTW
2bb8			 
2bb8			.FB: 
2bb8				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
2bb8 1b				db WORD_SYS_CORE+7             
2bb9 06 2c			dw .EMIT            
2bbb 03				db 2 + 1 
2bbc .. 00			db "FB",0              
2bbf				endm 
# End of macro CWHEAD
2bbf			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
2bbf			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
2bbf			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
2bbf			; | | If automatic display is off then updates will not be shown until DRAW is used. 
2bbf					if DEBUG_FORTH_WORDS_KEY 
2bbf						DMARK "FB." 
2bbf f5				push af  
2bc0 3a d4 2b			ld a, (.dmark)  
2bc3 32 bd fb			ld (debug_mark),a  
2bc6 3a d5 2b			ld a, (.dmark+1)  
2bc9 32 be fb			ld (debug_mark+1),a  
2bcc 3a d6 2b			ld a, (.dmark+2)  
2bcf 32 bf fb			ld (debug_mark+2),a  
2bd2 18 03			jr .pastdmark  
2bd4 ..			.dmark: db "FB."  
2bd7 f1			.pastdmark: pop af  
2bd8			endm  
# End of macro DMARK
2bd8						CALLMONITOR 
2bd8 cd d7 12			call break_point_state  
2bdb				endm  
# End of macro CALLMONITOR
2bdb					endif 
2bdb			 
2bdb					FORTH_DSP_VALUEHL 
2bdb cd fc 18			call macro_dsp_valuehl 
2bde				endm 
# End of macro FORTH_DSP_VALUEHL
2bde			 
2bde 7d					ld a, l 
2bdf fe 01				cp 1 
2be1 20 05				jr nz, .fbn1 
2be3 21 02 fb				ld hl, display_fb1 
2be6 18 15				jr .fbset 
2be8 fe 02		.fbn1:		cp 2 
2bea 20 05				jr nz, .fbn2 
2bec 21 60 fa				ld hl, display_fb2 
2bef 18 0c				jr .fbset 
2bf1 fe 03		.fbn2:		cp 3 
2bf3 20 05				jr nz, .fbn3 
2bf5 21 b1 fa				ld hl, display_fb3 
2bf8 18 03				jr .fbset 
2bfa			.fbn3:		 ; if invalid number select first 
2bfa 21 02 fb				ld hl, display_fb1 
2bfd 22 5e fa		.fbset:		ld (display_fb_active), hl 
2c00			 
2c00					FORTH_DSP_POP 
2c00 cd 7c 19			call macro_forth_dsp_pop 
2c03				endm 
# End of macro FORTH_DSP_POP
2c03			 
2c03					NEXTW 
2c03 c3 36 1a			jp macro_next 
2c06				endm 
# End of macro NEXTW
2c06			 
2c06			 
2c06			.EMIT: 
2c06				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
2c06 1b				db WORD_SYS_CORE+7             
2c07 57 2c			dw .DOTH            
2c09 05				db 4 + 1 
2c0a .. 00			db "EMIT",0              
2c0f				endm 
# End of macro CWHEAD
2c0f			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
2c0f					; get value off TOS and display it 
2c0f			 
2c0f					if DEBUG_FORTH_WORDS_KEY 
2c0f						DMARK "EMT" 
2c0f f5				push af  
2c10 3a 24 2c			ld a, (.dmark)  
2c13 32 bd fb			ld (debug_mark),a  
2c16 3a 25 2c			ld a, (.dmark+1)  
2c19 32 be fb			ld (debug_mark+1),a  
2c1c 3a 26 2c			ld a, (.dmark+2)  
2c1f 32 bf fb			ld (debug_mark+2),a  
2c22 18 03			jr .pastdmark  
2c24 ..			.dmark: db "EMT"  
2c27 f1			.pastdmark: pop af  
2c28			endm  
# End of macro DMARK
2c28						CALLMONITOR 
2c28 cd d7 12			call break_point_state  
2c2b				endm  
# End of macro CALLMONITOR
2c2b					endif 
2c2b			 
2c2b					FORTH_DSP_VALUEHL 
2c2b cd fc 18			call macro_dsp_valuehl 
2c2e				endm 
# End of macro FORTH_DSP_VALUEHL
2c2e			 
2c2e 7d					ld a,l 
2c2f			 
2c2f					; TODO write to display 
2c2f			 
2c2f 32 b6 f1				ld (os_input), a 
2c32 3e 00				ld a, 0 
2c34 32 b7 f1				ld (os_input+1), a 
2c37					 
2c37 3a e1 f9				ld a, (f_cursor_ptr) 
2c3a 11 b6 f1				ld de, os_input 
2c3d cd cd 09				call str_at_display 
2c40			 
2c40			 
2c40 3a bf f9				ld a,(cli_autodisplay) 
2c43 fe 00				cp 0 
2c45 28 03				jr z, .enoupdate 
2c47 cd dd 09						call update_display 
2c4a					.enoupdate: 
2c4a			 
2c4a 3a e1 f9				ld a, (f_cursor_ptr) 
2c4d 3c					inc a 
2c4e 32 e1 f9				ld (f_cursor_ptr), a   ; save new pos 
2c51			 
2c51			 
2c51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c51 cd 7c 19			call macro_forth_dsp_pop 
2c54				endm 
# End of macro FORTH_DSP_POP
2c54			  
2c54			 
2c54					NEXTW 
2c54 c3 36 1a			jp macro_next 
2c57				endm 
# End of macro NEXTW
2c57			.DOTH: 
2c57				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
2c57 1c				db WORD_SYS_CORE+8             
2c58 87 2c			dw .DOTF            
2c5a 03				db 2 + 1 
2c5b .. 00			db ".-",0              
2c5e				endm 
# End of macro CWHEAD
2c5e			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
2c5e					; get value off TOS and display it 
2c5e					if DEBUG_FORTH_WORDS_KEY 
2c5e						DMARK "DTD" 
2c5e f5				push af  
2c5f 3a 73 2c			ld a, (.dmark)  
2c62 32 bd fb			ld (debug_mark),a  
2c65 3a 74 2c			ld a, (.dmark+1)  
2c68 32 be fb			ld (debug_mark+1),a  
2c6b 3a 75 2c			ld a, (.dmark+2)  
2c6e 32 bf fb			ld (debug_mark+2),a  
2c71 18 03			jr .pastdmark  
2c73 ..			.dmark: db "DTD"  
2c76 f1			.pastdmark: pop af  
2c77			endm  
# End of macro DMARK
2c77						CALLMONITOR 
2c77 cd d7 12			call break_point_state  
2c7a				endm  
# End of macro CALLMONITOR
2c7a					endif 
2c7a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
2c7c 3e 00			ld a, 0 
2c7e 32 c0 f9			ld (cli_mvdot), a 
2c81 c3 de 2c			jp .dotgo 
2c84				NEXTW 
2c84 c3 36 1a			jp macro_next 
2c87				endm 
# End of macro NEXTW
2c87			.DOTF: 
2c87				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
2c87 1c				db WORD_SYS_CORE+8             
2c88 b5 2c			dw .DOT            
2c8a 03				db 2 + 1 
2c8b .. 00			db ".>",0              
2c8e				endm 
# End of macro CWHEAD
2c8e			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
2c8e					; get value off TOS and display it 
2c8e			        ; TODO BUG adds extra spaces 
2c8e			        ; TODO BUG handle numerics? 
2c8e					if DEBUG_FORTH_WORDS_KEY 
2c8e						DMARK "DTC" 
2c8e f5				push af  
2c8f 3a a3 2c			ld a, (.dmark)  
2c92 32 bd fb			ld (debug_mark),a  
2c95 3a a4 2c			ld a, (.dmark+1)  
2c98 32 be fb			ld (debug_mark+1),a  
2c9b 3a a5 2c			ld a, (.dmark+2)  
2c9e 32 bf fb			ld (debug_mark+2),a  
2ca1 18 03			jr .pastdmark  
2ca3 ..			.dmark: db "DTC"  
2ca6 f1			.pastdmark: pop af  
2ca7			endm  
# End of macro DMARK
2ca7						CALLMONITOR 
2ca7 cd d7 12			call break_point_state  
2caa				endm  
# End of macro CALLMONITOR
2caa					endif 
2caa 3e 01			ld a, 1 
2cac 32 c0 f9			ld (cli_mvdot), a 
2caf c3 de 2c			jp .dotgo 
2cb2				NEXTW 
2cb2 c3 36 1a			jp macro_next 
2cb5				endm 
# End of macro NEXTW
2cb5			 
2cb5			.DOT: 
2cb5				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
2cb5 1c				db WORD_SYS_CORE+8             
2cb6 41 2d			dw .CLS            
2cb8 02				db 1 + 1 
2cb9 .. 00			db ".",0              
2cbb				endm 
# End of macro CWHEAD
2cbb			        ; | . ( u -- ) Display TOS | DONE 
2cbb					; get value off TOS and display it 
2cbb			 
2cbb					if DEBUG_FORTH_WORDS_KEY 
2cbb						DMARK "DOT" 
2cbb f5				push af  
2cbc 3a d0 2c			ld a, (.dmark)  
2cbf 32 bd fb			ld (debug_mark),a  
2cc2 3a d1 2c			ld a, (.dmark+1)  
2cc5 32 be fb			ld (debug_mark+1),a  
2cc8 3a d2 2c			ld a, (.dmark+2)  
2ccb 32 bf fb			ld (debug_mark+2),a  
2cce 18 03			jr .pastdmark  
2cd0 ..			.dmark: db "DOT"  
2cd3 f1			.pastdmark: pop af  
2cd4			endm  
# End of macro DMARK
2cd4						CALLMONITOR 
2cd4 cd d7 12			call break_point_state  
2cd7				endm  
# End of macro CALLMONITOR
2cd7					endif 
2cd7 3e 00			ld a, 0 
2cd9 32 c0 f9			ld (cli_mvdot), a 
2cdc 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
2cde				 
2cde			 
2cde			.dotgo: 
2cde			 
2cde			; move up type to on stack for parserv5 
2cde					FORTH_DSP 
2cde cd e1 18			call macro_forth_dsp 
2ce1				endm 
# End of macro FORTH_DSP
2ce1				;FORTH_DSP_VALUE  
2ce1			 
2ce1			if DEBUG_FORTH_DOT 
2ce1				DMARK "DOT" 
2ce1				CALLMONITOR 
2ce1			endif	 
2ce1			;		.print: 
2ce1			 
2ce1 7e				ld a,(hl)  ; work out what type of value is on the TOS 
2ce2 23				inc hl   ; position to the actual value 
2ce3 fe 01			cp DS_TYPE_STR 
2ce5 20 06			jr nz, .dotnum1  
2ce7			 
2ce7			; display string 
2ce7				FORTH_DSP_VALUE  
2ce7 cd e5 18			call macro_forth_dsp_value 
2cea				endm 
# End of macro FORTH_DSP_VALUE
2cea eb				ex de,hl 
2ceb 18 11			jr .dotwrite 
2ced			 
2ced			.dotnum1: 
2ced fe 02			cp DS_TYPE_INUM 
2cef 20 0c			jr nz, .dotflot 
2cf1			 
2cf1			 
2cf1			; display number 
2cf1			 
2cf1			;	push hl 
2cf1			;	call clear_display 
2cf1			;	pop hl 
2cf1			 
2cf1 5e				ld e, (hl) 
2cf2 23				inc hl 
2cf3 56				ld d, (hl) 
2cf4 21 b8 ef			ld hl, scratch 
2cf7			if DEBUG_FORTH_DOT 
2cf7				DMARK "DT1" 
2cf7				CALLMONITOR 
2cf7			endif	 
2cf7			 
2cf7 cd 20 0f			call uitoa_16 
2cfa eb				ex de,hl 
2cfb			 
2cfb			if DEBUG_FORTH_DOT 
2cfb				DMARK "DT2" 
2cfb				CALLMONITOR 
2cfb			endif	 
2cfb			 
2cfb			;	ld de, os_word_scratch 
2cfb 18 01			jr .dotwrite 
2cfd			 
2cfd 00			.dotflot:   nop 
2cfe			; TODO print floating point number 
2cfe			 
2cfe			.dotwrite:		 
2cfe			 
2cfe					; if c is set then set all '-' to spaces 
2cfe					; need to also take into account .>  
2cfe			 
2cfe 3e 01				ld a, 1 
2d00 b9					cp c 
2d01 20 13				jr nz, .nodashswap 
2d03			 
2d03					; DE has the string to write, working with HL 
2d03			 
2d03 06 ff				ld b, 255 
2d05 d5					push de 
2d06 e1					pop hl 
2d07			 
2d07			if DEBUG_FORTH_DOT 
2d07				DMARK "DT-" 
2d07				CALLMONITOR 
2d07			endif	 
2d07 7e			.dashscan:	ld a, (hl) 
2d08 fe 00				cp 0 
2d0a 28 0a				jr z, .nodashswap 
2d0c fe 2d				cp '-' 
2d0e 20 03				jr nz, .dashskip 
2d10 3e 20				ld a, ' ' 
2d12 77					ld (hl), a 
2d13 23			.dashskip:	inc hl 
2d14			if DEBUG_FORTH_DOT 
2d14				DMARK "D-2" 
2d14				CALLMONITOR 
2d14			endif	 
2d14 10 f1				djnz .dashscan 
2d16			 
2d16			if DEBUG_FORTH_DOT 
2d16				DMARK "D-1" 
2d16				CALLMONITOR 
2d16			endif	 
2d16			 
2d16			.nodashswap: 
2d16			 
2d16 e5					push hl   ; save string start in case we need to advance print 
2d17			 
2d17 3a e1 f9				ld a, (f_cursor_ptr) 
2d1a cd cd 09				call str_at_display 
2d1d 3a bf f9				ld a,(cli_autodisplay) 
2d20 fe 00				cp 0 
2d22 28 03				jr z, .noupdate 
2d24 cd dd 09						call update_display 
2d27					.noupdate: 
2d27			 
2d27			 
2d27					; see if we need to advance the print position 
2d27			 
2d27 e1					pop hl   ; get back string 
2d28			 
2d28 3a c0 f9				ld a, (cli_mvdot) 
2d2b			if DEBUG_FORTH_DOT 
2d2b					ld e,a 
2d2b				DMARK "D>1" 
2d2b				CALLMONITOR 
2d2b			endif	 
2d2b fe 00				cp 0 
2d2d 28 0c				jr z, .noadv 
2d2f					; yes, lets advance the print position 
2d2f 3e 00				ld a, 0 
2d31 cd 7c 0f				call strlent 
2d34 3a e1 f9				ld a, (f_cursor_ptr) 
2d37 85					add a,l 
2d38					;call addatohl 
2d38					;ld a, l 
2d38 32 e1 f9				ld (f_cursor_ptr), a   ; save new pos 
2d3b			 
2d3b			if DEBUG_FORTH_DOT 
2d3b				DMARK "D->" 
2d3b				CALLMONITOR 
2d3b			endif	 
2d3b			 
2d3b			.noadv:	 
2d3b			 
2d3b					if DEBUG_FORTH_DOT_WAIT 
2d3b							call next_page_prompt 
2d3b					endif	 
2d3b			; TODO this pop off the stack causes a crash. i dont know why 
2d3b			 
2d3b			 
2d3b			if DEBUG_FORTH_DOT 
2d3b				DMARK "DTh" 
2d3b				CALLMONITOR 
2d3b			endif	 
2d3b			 
2d3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d3b cd 7c 19			call macro_forth_dsp_pop 
2d3e				endm 
# End of macro FORTH_DSP_POP
2d3e			 
2d3e			if DEBUG_FORTH_DOT 
2d3e				DMARK "DTi" 
2d3e				CALLMONITOR 
2d3e			endif	 
2d3e			 
2d3e			 
2d3e					NEXTW 
2d3e c3 36 1a			jp macro_next 
2d41				endm 
# End of macro NEXTW
2d41			 
2d41			.CLS: 
2d41				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
2d41 35				db WORD_SYS_CORE+33             
2d42 6e 2d			dw .DRAW            
2d44 04				db 3 + 1 
2d45 .. 00			db "CLS",0              
2d49				endm 
# End of macro CWHEAD
2d49			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
2d49					if DEBUG_FORTH_WORDS_KEY 
2d49						DMARK "CLS" 
2d49 f5				push af  
2d4a 3a 5e 2d			ld a, (.dmark)  
2d4d 32 bd fb			ld (debug_mark),a  
2d50 3a 5f 2d			ld a, (.dmark+1)  
2d53 32 be fb			ld (debug_mark+1),a  
2d56 3a 60 2d			ld a, (.dmark+2)  
2d59 32 bf fb			ld (debug_mark+2),a  
2d5c 18 03			jr .pastdmark  
2d5e ..			.dmark: db "CLS"  
2d61 f1			.pastdmark: pop af  
2d62			endm  
# End of macro DMARK
2d62						CALLMONITOR 
2d62 cd d7 12			call break_point_state  
2d65				endm  
# End of macro CALLMONITOR
2d65					endif 
2d65 cd ba 09				call clear_display 
2d68 c3 7c 2e				jp .home		; and home cursor 
2d6b					NEXTW 
2d6b c3 36 1a			jp macro_next 
2d6e				endm 
# End of macro NEXTW
2d6e			 
2d6e			.DRAW: 
2d6e				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
2d6e 36				db WORD_SYS_CORE+34             
2d6f 99 2d			dw .DUMP            
2d71 05				db 4 + 1 
2d72 .. 00			db "DRAW",0              
2d77				endm 
# End of macro CWHEAD
2d77			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
2d77					if DEBUG_FORTH_WORDS_KEY 
2d77						DMARK "DRW" 
2d77 f5				push af  
2d78 3a 8c 2d			ld a, (.dmark)  
2d7b 32 bd fb			ld (debug_mark),a  
2d7e 3a 8d 2d			ld a, (.dmark+1)  
2d81 32 be fb			ld (debug_mark+1),a  
2d84 3a 8e 2d			ld a, (.dmark+2)  
2d87 32 bf fb			ld (debug_mark+2),a  
2d8a 18 03			jr .pastdmark  
2d8c ..			.dmark: db "DRW"  
2d8f f1			.pastdmark: pop af  
2d90			endm  
# End of macro DMARK
2d90						CALLMONITOR 
2d90 cd d7 12			call break_point_state  
2d93				endm  
# End of macro CALLMONITOR
2d93					endif 
2d93 cd dd 09				call update_display 
2d96					NEXTW 
2d96 c3 36 1a			jp macro_next 
2d99				endm 
# End of macro NEXTW
2d99			 
2d99			.DUMP: 
2d99				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
2d99 37				db WORD_SYS_CORE+35             
2d9a d1 2d			dw .CDUMP            
2d9c 05				db 4 + 1 
2d9d .. 00			db "DUMP",0              
2da2				endm 
# End of macro CWHEAD
2da2			; | DUMP ( x -- ) With address x display dump   | DONE 
2da2			; TODO pop address to use off of the stack 
2da2					if DEBUG_FORTH_WORDS_KEY 
2da2						DMARK "DUM" 
2da2 f5				push af  
2da3 3a b7 2d			ld a, (.dmark)  
2da6 32 bd fb			ld (debug_mark),a  
2da9 3a b8 2d			ld a, (.dmark+1)  
2dac 32 be fb			ld (debug_mark+1),a  
2daf 3a b9 2d			ld a, (.dmark+2)  
2db2 32 bf fb			ld (debug_mark+2),a  
2db5 18 03			jr .pastdmark  
2db7 ..			.dmark: db "DUM"  
2dba f1			.pastdmark: pop af  
2dbb			endm  
# End of macro DMARK
2dbb						CALLMONITOR 
2dbb cd d7 12			call break_point_state  
2dbe				endm  
# End of macro CALLMONITOR
2dbe					endif 
2dbe cd ba 09				call clear_display 
2dc1			 
2dc1					; get address 
2dc1			 
2dc1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dc1 cd fc 18			call macro_dsp_valuehl 
2dc4				endm 
# End of macro FORTH_DSP_VALUEHL
2dc4				 
2dc4					; save it for cdump 
2dc4			 
2dc4 22 db f2				ld (os_cur_ptr),hl 
2dc7			 
2dc7					; destroy value TOS 
2dc7			 
2dc7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dc7 cd 7c 19			call macro_forth_dsp_pop 
2dca				endm 
# End of macro FORTH_DSP_POP
2dca			 
2dca cd e4 16				call dumpcont	; skip old style of param parsing	 
2dcd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
2dce					NEXTW 
2dce c3 36 1a			jp macro_next 
2dd1				endm 
# End of macro NEXTW
2dd1			.CDUMP: 
2dd1				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
2dd1 38				db WORD_SYS_CORE+36             
2dd2 01 2e			dw .DAT            
2dd4 06				db 5 + 1 
2dd5 .. 00			db "CDUMP",0              
2ddb				endm 
# End of macro CWHEAD
2ddb			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
2ddb					if DEBUG_FORTH_WORDS_KEY 
2ddb						DMARK "CDP" 
2ddb f5				push af  
2ddc 3a f0 2d			ld a, (.dmark)  
2ddf 32 bd fb			ld (debug_mark),a  
2de2 3a f1 2d			ld a, (.dmark+1)  
2de5 32 be fb			ld (debug_mark+1),a  
2de8 3a f2 2d			ld a, (.dmark+2)  
2deb 32 bf fb			ld (debug_mark+2),a  
2dee 18 03			jr .pastdmark  
2df0 ..			.dmark: db "CDP"  
2df3 f1			.pastdmark: pop af  
2df4			endm  
# End of macro DMARK
2df4						CALLMONITOR 
2df4 cd d7 12			call break_point_state  
2df7				endm  
# End of macro CALLMONITOR
2df7					endif 
2df7 cd ba 09				call clear_display 
2dfa cd e4 16				call dumpcont	 
2dfd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
2dfe					NEXTW 
2dfe c3 36 1a			jp macro_next 
2e01				endm 
# End of macro NEXTW
2e01			 
2e01			 
2e01			 
2e01			 
2e01			.DAT: 
2e01				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
2e01 3d				db WORD_SYS_CORE+41             
2e02 57 2e			dw .HOME            
2e04 03				db 2 + 1 
2e05 .. 00			db "AT",0              
2e08				endm 
# End of macro CWHEAD
2e08			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
2e08					if DEBUG_FORTH_WORDS_KEY 
2e08						DMARK "AT." 
2e08 f5				push af  
2e09 3a 1d 2e			ld a, (.dmark)  
2e0c 32 bd fb			ld (debug_mark),a  
2e0f 3a 1e 2e			ld a, (.dmark+1)  
2e12 32 be fb			ld (debug_mark+1),a  
2e15 3a 1f 2e			ld a, (.dmark+2)  
2e18 32 bf fb			ld (debug_mark+2),a  
2e1b 18 03			jr .pastdmark  
2e1d ..			.dmark: db "AT."  
2e20 f1			.pastdmark: pop af  
2e21			endm  
# End of macro DMARK
2e21						CALLMONITOR 
2e21 cd d7 12			call break_point_state  
2e24				endm  
# End of macro CALLMONITOR
2e24					endif 
2e24					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e24 cd fc 18			call macro_dsp_valuehl 
2e27				endm 
# End of macro FORTH_DSP_VALUEHL
2e27			 
2e27			 
2e27					; TODO save cursor row 
2e27 7d					ld a,l 
2e28 fe 02				cp 2 
2e2a 20 04				jr nz, .crow3 
2e2c 3e 14				ld a, display_row_2 
2e2e 18 12				jr .ccol1 
2e30 fe 03		.crow3:		cp 3 
2e32 20 04				jr nz, .crow4 
2e34 3e 28				ld a, display_row_3 
2e36 18 0a				jr .ccol1 
2e38 fe 04		.crow4:		cp 4 
2e3a 20 04				jr nz, .crow1 
2e3c 3e 3c				ld a, display_row_4 
2e3e 18 02				jr .ccol1 
2e40 3e 00		.crow1:		ld a,display_row_1 
2e42 f5			.ccol1:		push af			; got row offset 
2e43 6f					ld l,a 
2e44 26 00				ld h,0 
2e46					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e46 cd 7c 19			call macro_forth_dsp_pop 
2e49				endm 
# End of macro FORTH_DSP_POP
2e49					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e49 cd fc 18			call macro_dsp_valuehl 
2e4c				endm 
# End of macro FORTH_DSP_VALUEHL
2e4c					; TODO save cursor col 
2e4c f1					pop af 
2e4d 85					add l		; add col offset 
2e4e 32 e1 f9				ld (f_cursor_ptr), a 
2e51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e51 cd 7c 19			call macro_forth_dsp_pop 
2e54				endm 
# End of macro FORTH_DSP_POP
2e54			 
2e54					; calculate  
2e54			 
2e54					NEXTW 
2e54 c3 36 1a			jp macro_next 
2e57				endm 
# End of macro NEXTW
2e57			 
2e57			 
2e57			.HOME: 
2e57				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
2e57 41				db WORD_SYS_CORE+45             
2e58 84 2e			dw .SPACE            
2e5a 05				db 4 + 1 
2e5b .. 00			db "HOME",0              
2e60				endm 
# End of macro CWHEAD
2e60			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
2e60					if DEBUG_FORTH_WORDS_KEY 
2e60						DMARK "HOM" 
2e60 f5				push af  
2e61 3a 75 2e			ld a, (.dmark)  
2e64 32 bd fb			ld (debug_mark),a  
2e67 3a 76 2e			ld a, (.dmark+1)  
2e6a 32 be fb			ld (debug_mark+1),a  
2e6d 3a 77 2e			ld a, (.dmark+2)  
2e70 32 bf fb			ld (debug_mark+2),a  
2e73 18 03			jr .pastdmark  
2e75 ..			.dmark: db "HOM"  
2e78 f1			.pastdmark: pop af  
2e79			endm  
# End of macro DMARK
2e79						CALLMONITOR 
2e79 cd d7 12			call break_point_state  
2e7c				endm  
# End of macro CALLMONITOR
2e7c					endif 
2e7c 3e 00		.home:		ld a, 0		; and home cursor 
2e7e 32 e1 f9				ld (f_cursor_ptr), a 
2e81					NEXTW 
2e81 c3 36 1a			jp macro_next 
2e84				endm 
# End of macro NEXTW
2e84			 
2e84			 
2e84			.SPACE: 
2e84				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
2e84 46				db WORD_SYS_CORE+50             
2e85 b2 2e			dw .SPACES            
2e87 03				db 2 + 1 
2e88 .. 00			db "BL",0              
2e8b				endm 
# End of macro CWHEAD
2e8b			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
2e8b					if DEBUG_FORTH_WORDS_KEY 
2e8b						DMARK "BL." 
2e8b f5				push af  
2e8c 3a a0 2e			ld a, (.dmark)  
2e8f 32 bd fb			ld (debug_mark),a  
2e92 3a a1 2e			ld a, (.dmark+1)  
2e95 32 be fb			ld (debug_mark+1),a  
2e98 3a a2 2e			ld a, (.dmark+2)  
2e9b 32 bf fb			ld (debug_mark+2),a  
2e9e 18 03			jr .pastdmark  
2ea0 ..			.dmark: db "BL."  
2ea3 f1			.pastdmark: pop af  
2ea4			endm  
# End of macro DMARK
2ea4						CALLMONITOR 
2ea4 cd d7 12			call break_point_state  
2ea7				endm  
# End of macro CALLMONITOR
2ea7					endif 
2ea7 21 b0 2e				ld hl, .blstr 
2eaa cd 73 18				call forth_push_str 
2ead					 
2ead				       NEXTW 
2ead c3 36 1a			jp macro_next 
2eb0				endm 
# End of macro NEXTW
2eb0			 
2eb0 .. 00		.blstr: db " ", 0 
2eb2			 
2eb2			.SPACES: 
2eb2				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
2eb2 47				db WORD_SYS_CORE+51             
2eb3 f9 2e			dw .SCROLL            
2eb5 07				db 6 + 1 
2eb6 .. 00			db "SPACES",0              
2ebd				endm 
# End of macro CWHEAD
2ebd			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
2ebd					if DEBUG_FORTH_WORDS_KEY 
2ebd						DMARK "SPS" 
2ebd f5				push af  
2ebe 3a d2 2e			ld a, (.dmark)  
2ec1 32 bd fb			ld (debug_mark),a  
2ec4 3a d3 2e			ld a, (.dmark+1)  
2ec7 32 be fb			ld (debug_mark+1),a  
2eca 3a d4 2e			ld a, (.dmark+2)  
2ecd 32 bf fb			ld (debug_mark+2),a  
2ed0 18 03			jr .pastdmark  
2ed2 ..			.dmark: db "SPS"  
2ed5 f1			.pastdmark: pop af  
2ed6			endm  
# End of macro DMARK
2ed6						CALLMONITOR 
2ed6 cd d7 12			call break_point_state  
2ed9				endm  
# End of macro CALLMONITOR
2ed9					endif 
2ed9			 
2ed9			 
2ed9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ed9 cd fc 18			call macro_dsp_valuehl 
2edc				endm 
# End of macro FORTH_DSP_VALUEHL
2edc			 
2edc			;		push hl    ; u 
2edc					if DEBUG_FORTH_WORDS 
2edc						DMARK "SPA" 
2edc						CALLMONITOR 
2edc					endif 
2edc			 
2edc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2edc cd 7c 19			call macro_forth_dsp_pop 
2edf				endm 
# End of macro FORTH_DSP_POP
2edf			;		pop hl 
2edf 4d					ld c, l 
2ee0 06 00				ld b, 0 
2ee2 21 b8 ef				ld hl, scratch  
2ee5			 
2ee5					if DEBUG_FORTH_WORDS 
2ee5						DMARK "SP2" 
2ee5						CALLMONITOR 
2ee5					endif 
2ee5 3e 20				ld a, ' ' 
2ee7 c5			.spaces1:	push bc 
2ee8 77					ld (hl),a 
2ee9 23					inc hl 
2eea c1					pop bc 
2eeb 10 fa				djnz .spaces1 
2eed 3e 00				ld a,0 
2eef 77					ld (hl),a 
2ef0 21 b8 ef				ld hl, scratch 
2ef3					if DEBUG_FORTH_WORDS 
2ef3						DMARK "SP3" 
2ef3						CALLMONITOR 
2ef3					endif 
2ef3 cd a9 18				call forth_apush 
2ef6			 
2ef6				       NEXTW 
2ef6 c3 36 1a			jp macro_next 
2ef9				endm 
# End of macro NEXTW
2ef9			 
2ef9			 
2ef9			 
2ef9			.SCROLL: 
2ef9				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
2ef9 53				db WORD_SYS_CORE+63             
2efa 26 2f			dw .ATQ            
2efc 07				db 6 + 1 
2efd .. 00			db "SCROLL",0              
2f04				endm 
# End of macro CWHEAD
2f04			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
2f04					if DEBUG_FORTH_WORDS_KEY 
2f04						DMARK "SCR" 
2f04 f5				push af  
2f05 3a 19 2f			ld a, (.dmark)  
2f08 32 bd fb			ld (debug_mark),a  
2f0b 3a 1a 2f			ld a, (.dmark+1)  
2f0e 32 be fb			ld (debug_mark+1),a  
2f11 3a 1b 2f			ld a, (.dmark+2)  
2f14 32 bf fb			ld (debug_mark+2),a  
2f17 18 03			jr .pastdmark  
2f19 ..			.dmark: db "SCR"  
2f1c f1			.pastdmark: pop af  
2f1d			endm  
# End of macro DMARK
2f1d						CALLMONITOR 
2f1d cd d7 12			call break_point_state  
2f20				endm  
# End of macro CALLMONITOR
2f20					endif 
2f20			 
2f20 cd 52 09			call scroll_up 
2f23			;	call update_display 
2f23			 
2f23					NEXTW 
2f23 c3 36 1a			jp macro_next 
2f26				endm 
# End of macro NEXTW
2f26			 
2f26			 
2f26			 
2f26			;		; get dir 
2f26			; 
2f26			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f26			; 
2f26			;		push hl 
2f26			; 
2f26			;		; destroy value TOS 
2f26			; 
2f26			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f26			; 
2f26			;		; get count 
2f26			; 
2f26			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f26			; 
2f26			;		push hl 
2f26			; 
2f26			;		; destroy value TOS 
2f26			; 
2f26			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f26			; 
2f26			;		; one value on hl get other one back 
2f26			; 
2f26			;		pop bc    ; count 
2f26			; 
2f26			;		pop de   ; dir 
2f26			; 
2f26			; 
2f26			;		ld b, c 
2f26			; 
2f26			;.scrolldir:     push bc 
2f26			;		push de 
2f26			; 
2f26			;		ld a, 0 
2f26			;		cp e 
2f26			;		jr z, .scrollup  
2f26			;		call scroll_down 
2f26			;		jr .scrollnext 
2f26			;.scrollup:	call scroll_up 
2f26			; 
2f26			;		 
2f26			;.scrollnext: 
2f26			;		pop de 
2f26			;		pop bc 
2f26			;		djnz .scrolldir 
2f26			; 
2f26			; 
2f26			; 
2f26			; 
2f26			; 
2f26			;		NEXTW 
2f26			 
2f26			 
2f26			 
2f26			 
2f26			.ATQ: 
2f26				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
2f26 62				db WORD_SYS_CORE+78             
2f27 84 2f			dw .AUTODSP            
2f29 04				db 3 + 1 
2f2a .. 00			db "AT@",0              
2f2e				endm 
# End of macro CWHEAD
2f2e			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
2f2e					if DEBUG_FORTH_WORDS_KEY 
2f2e						DMARK "ATA" 
2f2e f5				push af  
2f2f 3a 43 2f			ld a, (.dmark)  
2f32 32 bd fb			ld (debug_mark),a  
2f35 3a 44 2f			ld a, (.dmark+1)  
2f38 32 be fb			ld (debug_mark+1),a  
2f3b 3a 45 2f			ld a, (.dmark+2)  
2f3e 32 bf fb			ld (debug_mark+2),a  
2f41 18 03			jr .pastdmark  
2f43 ..			.dmark: db "ATA"  
2f46 f1			.pastdmark: pop af  
2f47			endm  
# End of macro DMARK
2f47						CALLMONITOR 
2f47 cd d7 12			call break_point_state  
2f4a				endm  
# End of macro CALLMONITOR
2f4a					endif 
2f4a			 
2f4a			 
2f4a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f4a cd fc 18			call macro_dsp_valuehl 
2f4d				endm 
# End of macro FORTH_DSP_VALUEHL
2f4d			 
2f4d					; TODO save cursor row 
2f4d 7d					ld a,l 
2f4e fe 02				cp 2 
2f50 20 04				jr nz, .crow3aq 
2f52 3e 14				ld a, display_row_2 
2f54 18 12				jr .ccol1aq 
2f56 fe 03		.crow3aq:		cp 3 
2f58 20 04				jr nz, .crow4aq 
2f5a 3e 28				ld a, display_row_3 
2f5c 18 0a				jr .ccol1aq 
2f5e fe 04		.crow4aq:		cp 4 
2f60 20 04				jr nz, .crow1aq 
2f62 3e 3c				ld a, display_row_4 
2f64 18 02				jr .ccol1aq 
2f66 3e 00		.crow1aq:		ld a,display_row_1 
2f68 f5			.ccol1aq:		push af			; got row offset 
2f69 6f					ld l,a 
2f6a 26 00				ld h,0 
2f6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f6c cd 7c 19			call macro_forth_dsp_pop 
2f6f				endm 
# End of macro FORTH_DSP_POP
2f6f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f6f cd fc 18			call macro_dsp_valuehl 
2f72				endm 
# End of macro FORTH_DSP_VALUEHL
2f72					; TODO save cursor col 
2f72 f1					pop af 
2f73 85					add l		; add col offset 
2f74			 
2f74					; add current frame buffer address 
2f74 2a 5e fa				ld hl, (display_fb_active) 
2f77 cd 13 0b				call addatohl 
2f7a			 
2f7a			 
2f7a			 
2f7a			 
2f7a					; get char frame buffer location offset in hl 
2f7a			 
2f7a 7e					ld a,(hl) 
2f7b 26 00				ld h, 0 
2f7d 6f					ld l, a 
2f7e			 
2f7e cd 61 18				call forth_push_numhl 
2f81			 
2f81			 
2f81					NEXTW 
2f81 c3 36 1a			jp macro_next 
2f84				endm 
# End of macro NEXTW
2f84			 
2f84			.AUTODSP: 
2f84				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
2f84 63				db WORD_SYS_CORE+79             
2f85 9a 2f			dw .MENU            
2f87 05				db 4 + 1 
2f88 .. 00			db "ADSP",0              
2f8d				endm 
# End of macro CWHEAD
2f8d			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
2f8d			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
2f8d			 
2f8d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f8d cd fc 18			call macro_dsp_valuehl 
2f90				endm 
# End of macro FORTH_DSP_VALUEHL
2f90			 
2f90			;		push hl 
2f90			 
2f90					; destroy value TOS 
2f90			 
2f90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f90 cd 7c 19			call macro_forth_dsp_pop 
2f93				endm 
# End of macro FORTH_DSP_POP
2f93			 
2f93			;		pop hl 
2f93			 
2f93 7d					ld a,l 
2f94 32 bf f9				ld (cli_autodisplay), a 
2f97				       NEXTW 
2f97 c3 36 1a			jp macro_next 
2f9a				endm 
# End of macro NEXTW
2f9a			 
2f9a			.MENU: 
2f9a				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
2f9a 70				db WORD_SYS_CORE+92             
2f9b a6 2f			dw .ENDDISPLAY            
2f9d 05				db 4 + 1 
2f9e .. 00			db "MENU",0              
2fa3				endm 
# End of macro CWHEAD
2fa3			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
2fa3			 
2fa3					; get the title address and save it 
2fa3			 
2fa3			;		FORTH_DSP_VALUEHL 
2fa3			;		push hl 
2fa3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2fa3			; 
2fa3			;		; get number of items on the stack 
2fa3			; 
2fa3			;	 
2fa3			;		FORTH_DSP_VALUEHL 
2fa3			;		push hl 
2fa3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2fa3			 
2fa3			 
2fa3			 
2fa3			 
2fa3				       NEXTW 
2fa3 c3 36 1a			jp macro_next 
2fa6				endm 
# End of macro NEXTW
2fa6			 
2fa6			 
2fa6			.ENDDISPLAY: 
2fa6			 
2fa6			; eof 
# End of file forth_words_display.asm
2fa6			include "forth_words_str.asm" 
2fa6			 
2fa6			; | ## String Words 
2fa6			 
2fa6			.PTR:   
2fa6			 
2fa6				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
2fa6 48				db WORD_SYS_CORE+52             
2fa7 d3 2f			dw .STYPE            
2fa9 04				db 3 + 1 
2faa .. 00			db "PTR",0              
2fae				endm 
# End of macro CWHEAD
2fae			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
2fae			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
2fae			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
2fae			 
2fae					if DEBUG_FORTH_WORDS_KEY 
2fae						DMARK "PTR" 
2fae f5				push af  
2faf 3a c3 2f			ld a, (.dmark)  
2fb2 32 bd fb			ld (debug_mark),a  
2fb5 3a c4 2f			ld a, (.dmark+1)  
2fb8 32 be fb			ld (debug_mark+1),a  
2fbb 3a c5 2f			ld a, (.dmark+2)  
2fbe 32 bf fb			ld (debug_mark+2),a  
2fc1 18 03			jr .pastdmark  
2fc3 ..			.dmark: db "PTR"  
2fc6 f1			.pastdmark: pop af  
2fc7			endm  
# End of macro DMARK
2fc7						CALLMONITOR 
2fc7 cd d7 12			call break_point_state  
2fca				endm  
# End of macro CALLMONITOR
2fca					endif 
2fca					FORTH_DSP_VALUEHL 
2fca cd fc 18			call macro_dsp_valuehl 
2fcd				endm 
# End of macro FORTH_DSP_VALUEHL
2fcd cd 61 18				call forth_push_numhl 
2fd0			 
2fd0			 
2fd0					NEXTW 
2fd0 c3 36 1a			jp macro_next 
2fd3				endm 
# End of macro NEXTW
2fd3			.STYPE: 
2fd3				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
2fd3 48				db WORD_SYS_CORE+52             
2fd4 22 30			dw .UPPER            
2fd6 06				db 5 + 1 
2fd7 .. 00			db "STYPE",0              
2fdd				endm 
# End of macro CWHEAD
2fdd			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
2fdd					if DEBUG_FORTH_WORDS_KEY 
2fdd						DMARK "STY" 
2fdd f5				push af  
2fde 3a f2 2f			ld a, (.dmark)  
2fe1 32 bd fb			ld (debug_mark),a  
2fe4 3a f3 2f			ld a, (.dmark+1)  
2fe7 32 be fb			ld (debug_mark+1),a  
2fea 3a f4 2f			ld a, (.dmark+2)  
2fed 32 bf fb			ld (debug_mark+2),a  
2ff0 18 03			jr .pastdmark  
2ff2 ..			.dmark: db "STY"  
2ff5 f1			.pastdmark: pop af  
2ff6			endm  
# End of macro DMARK
2ff6						CALLMONITOR 
2ff6 cd d7 12			call break_point_state  
2ff9				endm  
# End of macro CALLMONITOR
2ff9					endif 
2ff9					FORTH_DSP 
2ff9 cd e1 18			call macro_forth_dsp 
2ffc				endm 
# End of macro FORTH_DSP
2ffc					;v5 FORTH_DSP_VALUE 
2ffc			 
2ffc 7e					ld a, (hl) 
2ffd			 
2ffd f5					push af 
2ffe			 
2ffe			; Dont destroy TOS		FORTH_DSP_POP 
2ffe			 
2ffe f1					pop af 
2fff			 
2fff fe 01				cp DS_TYPE_STR 
3001 28 09				jr z, .typestr 
3003			 
3003 fe 02				cp DS_TYPE_INUM 
3005 28 0a				jr z, .typeinum 
3007			 
3007 21 20 30				ld hl, .tna 
300a 18 0a				jr .tpush 
300c			 
300c 21 1c 30		.typestr:	ld hl, .tstr 
300f 18 05				jr .tpush 
3011 21 1e 30		.typeinum:	ld hl, .tinum 
3014 18 00				jr .tpush 
3016			 
3016			.tpush: 
3016			 
3016 cd 73 18				call forth_push_str 
3019			 
3019					NEXTW 
3019 c3 36 1a			jp macro_next 
301c				endm 
# End of macro NEXTW
301c .. 00		.tstr:	db "s",0 
301e .. 00		.tinum:  db "i",0 
3020 .. 00		.tna:   db "?", 0 
3022			 
3022			 
3022			.UPPER: 
3022				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3022 48				db WORD_SYS_CORE+52             
3023 5d 30			dw .LOWER            
3025 06				db 5 + 1 
3026 .. 00			db "UPPER",0              
302c				endm 
# End of macro CWHEAD
302c			; | UPPER ( s -- s ) Upper case string s  | DONE 
302c					if DEBUG_FORTH_WORDS_KEY 
302c						DMARK "UPR" 
302c f5				push af  
302d 3a 41 30			ld a, (.dmark)  
3030 32 bd fb			ld (debug_mark),a  
3033 3a 42 30			ld a, (.dmark+1)  
3036 32 be fb			ld (debug_mark+1),a  
3039 3a 43 30			ld a, (.dmark+2)  
303c 32 bf fb			ld (debug_mark+2),a  
303f 18 03			jr .pastdmark  
3041 ..			.dmark: db "UPR"  
3044 f1			.pastdmark: pop af  
3045			endm  
# End of macro DMARK
3045						CALLMONITOR 
3045 cd d7 12			call break_point_state  
3048				endm  
# End of macro CALLMONITOR
3048					endif 
3048			 
3048					FORTH_DSP 
3048 cd e1 18			call macro_forth_dsp 
304b				endm 
# End of macro FORTH_DSP
304b					 
304b			; TODO check is string type 
304b			 
304b					FORTH_DSP_VALUEHL 
304b cd fc 18			call macro_dsp_valuehl 
304e				endm 
# End of macro FORTH_DSP_VALUEHL
304e			; get pointer to string in hl 
304e			 
304e 7e			.toup:		ld a, (hl) 
304f fe 00				cp 0 
3051 28 07				jr z, .toupdone 
3053			 
3053 cd 80 0e				call to_upper 
3056			 
3056 77					ld (hl), a 
3057 23					inc hl 
3058 18 f4				jr .toup 
305a			 
305a					 
305a			 
305a			 
305a			; for each char convert to upper 
305a					 
305a			.toupdone: 
305a			 
305a			 
305a					NEXTW 
305a c3 36 1a			jp macro_next 
305d				endm 
# End of macro NEXTW
305d			.LOWER: 
305d				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
305d 48				db WORD_SYS_CORE+52             
305e 98 30			dw .TCASE            
3060 06				db 5 + 1 
3061 .. 00			db "LOWER",0              
3067				endm 
# End of macro CWHEAD
3067			; | LOWER ( s -- s ) Lower case string s  | DONE 
3067					if DEBUG_FORTH_WORDS_KEY 
3067						DMARK "LWR" 
3067 f5				push af  
3068 3a 7c 30			ld a, (.dmark)  
306b 32 bd fb			ld (debug_mark),a  
306e 3a 7d 30			ld a, (.dmark+1)  
3071 32 be fb			ld (debug_mark+1),a  
3074 3a 7e 30			ld a, (.dmark+2)  
3077 32 bf fb			ld (debug_mark+2),a  
307a 18 03			jr .pastdmark  
307c ..			.dmark: db "LWR"  
307f f1			.pastdmark: pop af  
3080			endm  
# End of macro DMARK
3080						CALLMONITOR 
3080 cd d7 12			call break_point_state  
3083				endm  
# End of macro CALLMONITOR
3083					endif 
3083			 
3083					FORTH_DSP 
3083 cd e1 18			call macro_forth_dsp 
3086				endm 
# End of macro FORTH_DSP
3086					 
3086			; TODO check is string type 
3086			 
3086					FORTH_DSP_VALUEHL 
3086 cd fc 18			call macro_dsp_valuehl 
3089				endm 
# End of macro FORTH_DSP_VALUEHL
3089			; get pointer to string in hl 
3089			 
3089 7e			.tolow:		ld a, (hl) 
308a fe 00				cp 0 
308c 28 07				jr z, .tolowdone 
308e			 
308e cd 89 0e				call to_lower 
3091			 
3091 77					ld (hl), a 
3092 23					inc hl 
3093 18 f4				jr .tolow 
3095			 
3095					 
3095			 
3095			 
3095			; for each char convert to low 
3095					 
3095			.tolowdone: 
3095					NEXTW 
3095 c3 36 1a			jp macro_next 
3098				endm 
# End of macro NEXTW
3098			.TCASE: 
3098				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3098 48				db WORD_SYS_CORE+52             
3099 ee 30			dw .SUBSTR            
309b 06				db 5 + 1 
309c .. 00			db "TCASE",0              
30a2				endm 
# End of macro CWHEAD
30a2			; | TCASE ( s -- s ) Title case string s  | DONE 
30a2					if DEBUG_FORTH_WORDS_KEY 
30a2						DMARK "TCS" 
30a2 f5				push af  
30a3 3a b7 30			ld a, (.dmark)  
30a6 32 bd fb			ld (debug_mark),a  
30a9 3a b8 30			ld a, (.dmark+1)  
30ac 32 be fb			ld (debug_mark+1),a  
30af 3a b9 30			ld a, (.dmark+2)  
30b2 32 bf fb			ld (debug_mark+2),a  
30b5 18 03			jr .pastdmark  
30b7 ..			.dmark: db "TCS"  
30ba f1			.pastdmark: pop af  
30bb			endm  
# End of macro DMARK
30bb						CALLMONITOR 
30bb cd d7 12			call break_point_state  
30be				endm  
# End of macro CALLMONITOR
30be					endif 
30be			 
30be					FORTH_DSP 
30be cd e1 18			call macro_forth_dsp 
30c1				endm 
# End of macro FORTH_DSP
30c1					 
30c1			; TODO check is string type 
30c1			 
30c1					FORTH_DSP_VALUEHL 
30c1 cd fc 18			call macro_dsp_valuehl 
30c4				endm 
# End of macro FORTH_DSP_VALUEHL
30c4			; get pointer to string in hl 
30c4			 
30c4					if DEBUG_FORTH_WORDS 
30c4						DMARK "TC1" 
30c4						CALLMONITOR 
30c4					endif 
30c4			 
30c4					; first time in turn to upper case first char 
30c4			 
30c4 7e					ld a, (hl) 
30c5 c3 df 30				jp .totsiptou 
30c8			 
30c8			 
30c8 7e			.tot:		ld a, (hl) 
30c9 fe 00				cp 0 
30cb ca eb 30				jp z, .totdone 
30ce			 
30ce					if DEBUG_FORTH_WORDS 
30ce						DMARK "TC2" 
30ce						CALLMONITOR 
30ce					endif 
30ce					; check to see if current char is a space 
30ce			 
30ce fe 20				cp ' ' 
30d0 28 05				jr z, .totsp 
30d2 cd 89 0e				call to_lower 
30d5					if DEBUG_FORTH_WORDS 
30d5						DMARK "TC3" 
30d5						CALLMONITOR 
30d5					endif 
30d5 18 0f				jr .totnxt 
30d7			 
30d7			.totsp:         ; on a space, find next char which should be upper 
30d7			 
30d7					if DEBUG_FORTH_WORDS 
30d7						DMARK "TC4" 
30d7						CALLMONITOR 
30d7					endif 
30d7					;; 
30d7			 
30d7 fe 20				cp ' ' 
30d9 20 04				jr nz, .totsiptou 
30db 23					inc hl 
30dc 7e					ld a, (hl) 
30dd					if DEBUG_FORTH_WORDS 
30dd						DMARK "TC5" 
30dd						CALLMONITOR 
30dd					endif 
30dd 18 f8				jr .totsp 
30df fe 00		.totsiptou:    cp 0 
30e1 28 08				jr z, .totdone 
30e3					; not space and not zero term so upper case it 
30e3 cd 80 0e				call to_upper 
30e6			 
30e6					if DEBUG_FORTH_WORDS 
30e6						DMARK "TC6" 
30e6						CALLMONITOR 
30e6					endif 
30e6			 
30e6			 
30e6			.totnxt: 
30e6			 
30e6 77					ld (hl), a 
30e7 23					inc hl 
30e8					if DEBUG_FORTH_WORDS 
30e8						DMARK "TC7" 
30e8						CALLMONITOR 
30e8					endif 
30e8 c3 c8 30				jp .tot 
30eb			 
30eb					 
30eb			 
30eb			 
30eb			; for each char convert to low 
30eb					 
30eb			.totdone: 
30eb					if DEBUG_FORTH_WORDS 
30eb						DMARK "TCd" 
30eb						CALLMONITOR 
30eb					endif 
30eb					NEXTW 
30eb c3 36 1a			jp macro_next 
30ee				endm 
# End of macro NEXTW
30ee			 
30ee			.SUBSTR: 
30ee				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
30ee 48				db WORD_SYS_CORE+52             
30ef 4c 31			dw .LEFT            
30f1 07				db 6 + 1 
30f2 .. 00			db "SUBSTR",0              
30f9				endm 
# End of macro CWHEAD
30f9			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
30f9			 
30f9					if DEBUG_FORTH_WORDS_KEY 
30f9						DMARK "SST" 
30f9 f5				push af  
30fa 3a 0e 31			ld a, (.dmark)  
30fd 32 bd fb			ld (debug_mark),a  
3100 3a 0f 31			ld a, (.dmark+1)  
3103 32 be fb			ld (debug_mark+1),a  
3106 3a 10 31			ld a, (.dmark+2)  
3109 32 bf fb			ld (debug_mark+2),a  
310c 18 03			jr .pastdmark  
310e ..			.dmark: db "SST"  
3111 f1			.pastdmark: pop af  
3112			endm  
# End of macro DMARK
3112						CALLMONITOR 
3112 cd d7 12			call break_point_state  
3115				endm  
# End of macro CALLMONITOR
3115					endif 
3115			; TODO check string type 
3115					FORTH_DSP_VALUEHL 
3115 cd fc 18			call macro_dsp_valuehl 
3118				endm 
# End of macro FORTH_DSP_VALUEHL
3118			 
3118 e5					push hl      ; string length 
3119			 
3119					FORTH_DSP_POP 
3119 cd 7c 19			call macro_forth_dsp_pop 
311c				endm 
# End of macro FORTH_DSP_POP
311c			 
311c					FORTH_DSP_VALUEHL 
311c cd fc 18			call macro_dsp_valuehl 
311f				endm 
# End of macro FORTH_DSP_VALUEHL
311f			 
311f e5					push hl     ; start char 
3120			 
3120					FORTH_DSP_POP 
3120 cd 7c 19			call macro_forth_dsp_pop 
3123				endm 
# End of macro FORTH_DSP_POP
3123			 
3123			 
3123					FORTH_DSP_VALUE 
3123 cd e5 18			call macro_forth_dsp_value 
3126				endm 
# End of macro FORTH_DSP_VALUE
3126			 
3126 d1					pop de    ; get start post offset 
3127			 
3127 19					add hl, de    ; starting offset 
3128			 
3128 c1					pop bc 
3129 c5					push bc      ; grab size of string 
312a			 
312a e5					push hl    ; save string start  
312b			 
312b 26 00				ld h, 0 
312d 69					ld l, c 
312e 23					inc hl 
312f 23					inc hl 
3130			 
3130 cd da 0f				call malloc 
3133				if DEBUG_FORTH_MALLOC_GUARD 
3133 cc 38 3f				call z,malloc_error 
3136				endif 
3136			 
3136 eb					ex de, hl      ; save malloc area for string copy 
3137 e1					pop hl    ; get back source 
3138 c1					pop bc    ; get length of string back 
3139			 
3139 d5					push de    ; save malloc area for after we push 
313a ed b0				ldir     ; copy substr 
313c			 
313c			 
313c eb					ex de, hl 
313d 3e 00				ld a, 0 
313f 77					ld (hl), a   ; term substr 
3140			 
3140					 
3140 e1					pop hl    ; get malloc so we can push it 
3141 e5					push hl   ; save so we can free it afterwards 
3142			 
3142 cd 73 18				call forth_push_str 
3145			 
3145 e1					pop hl 
3146 cd a4 10				call free 
3149			 
3149					 
3149					 
3149			 
3149			 
3149					NEXTW 
3149 c3 36 1a			jp macro_next 
314c				endm 
# End of macro NEXTW
314c			 
314c			.LEFT: 
314c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
314c 48				db WORD_SYS_CORE+52             
314d 74 31			dw .RIGHT            
314f 05				db 4 + 1 
3150 .. 00			db "LEFT",0              
3155				endm 
# End of macro CWHEAD
3155			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3155					if DEBUG_FORTH_WORDS_KEY 
3155						DMARK "LEF" 
3155 f5				push af  
3156 3a 6a 31			ld a, (.dmark)  
3159 32 bd fb			ld (debug_mark),a  
315c 3a 6b 31			ld a, (.dmark+1)  
315f 32 be fb			ld (debug_mark+1),a  
3162 3a 6c 31			ld a, (.dmark+2)  
3165 32 bf fb			ld (debug_mark+2),a  
3168 18 03			jr .pastdmark  
316a ..			.dmark: db "LEF"  
316d f1			.pastdmark: pop af  
316e			endm  
# End of macro DMARK
316e						CALLMONITOR 
316e cd d7 12			call break_point_state  
3171				endm  
# End of macro CALLMONITOR
3171					endif 
3171			 
3171					NEXTW 
3171 c3 36 1a			jp macro_next 
3174				endm 
# End of macro NEXTW
3174			.RIGHT: 
3174				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3174 48				db WORD_SYS_CORE+52             
3175 9d 31			dw .STR2NUM            
3177 06				db 5 + 1 
3178 .. 00			db "RIGHT",0              
317e				endm 
# End of macro CWHEAD
317e			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
317e					if DEBUG_FORTH_WORDS_KEY 
317e						DMARK "RIG" 
317e f5				push af  
317f 3a 93 31			ld a, (.dmark)  
3182 32 bd fb			ld (debug_mark),a  
3185 3a 94 31			ld a, (.dmark+1)  
3188 32 be fb			ld (debug_mark+1),a  
318b 3a 95 31			ld a, (.dmark+2)  
318e 32 bf fb			ld (debug_mark+2),a  
3191 18 03			jr .pastdmark  
3193 ..			.dmark: db "RIG"  
3196 f1			.pastdmark: pop af  
3197			endm  
# End of macro DMARK
3197						CALLMONITOR 
3197 cd d7 12			call break_point_state  
319a				endm  
# End of macro CALLMONITOR
319a					endif 
319a			 
319a					NEXTW 
319a c3 36 1a			jp macro_next 
319d				endm 
# End of macro NEXTW
319d			 
319d			 
319d			.STR2NUM: 
319d				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
319d 48				db WORD_SYS_CORE+52             
319e d5 31			dw .NUM2STR            
31a0 08				db 7 + 1 
31a1 .. 00			db "STR2NUM",0              
31a9				endm 
# End of macro CWHEAD
31a9			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
31a9			 
31a9			 
31a9			; TODO STR type check to do 
31a9					if DEBUG_FORTH_WORDS_KEY 
31a9						DMARK "S2N" 
31a9 f5				push af  
31aa 3a be 31			ld a, (.dmark)  
31ad 32 bd fb			ld (debug_mark),a  
31b0 3a bf 31			ld a, (.dmark+1)  
31b3 32 be fb			ld (debug_mark+1),a  
31b6 3a c0 31			ld a, (.dmark+2)  
31b9 32 bf fb			ld (debug_mark+2),a  
31bc 18 03			jr .pastdmark  
31be ..			.dmark: db "S2N"  
31c1 f1			.pastdmark: pop af  
31c2			endm  
# End of macro DMARK
31c2						CALLMONITOR 
31c2 cd d7 12			call break_point_state  
31c5				endm  
# End of macro CALLMONITOR
31c5					endif 
31c5			 
31c5					;FORTH_DSP 
31c5					FORTH_DSP_VALUE 
31c5 cd e5 18			call macro_forth_dsp_value 
31c8				endm 
# End of macro FORTH_DSP_VALUE
31c8					;inc hl 
31c8			 
31c8 eb					ex de, hl 
31c9					if DEBUG_FORTH_WORDS 
31c9						DMARK "S2a" 
31c9						CALLMONITOR 
31c9					endif 
31c9 cd 08 0f				call string_to_uint16 
31cc			 
31cc					if DEBUG_FORTH_WORDS 
31cc						DMARK "S2b" 
31cc						CALLMONITOR 
31cc					endif 
31cc			;		push hl 
31cc					FORTH_DSP_POP 
31cc cd 7c 19			call macro_forth_dsp_pop 
31cf				endm 
# End of macro FORTH_DSP_POP
31cf			;		pop hl 
31cf					 
31cf					if DEBUG_FORTH_WORDS 
31cf						DMARK "S2b" 
31cf						CALLMONITOR 
31cf					endif 
31cf cd 61 18				call forth_push_numhl	 
31d2			 
31d2				 
31d2				       NEXTW 
31d2 c3 36 1a			jp macro_next 
31d5				endm 
# End of macro NEXTW
31d5			.NUM2STR: 
31d5				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
31d5 48				db WORD_SYS_CORE+52             
31d6 e4 31			dw .CONCAT            
31d8 08				db 7 + 1 
31d9 .. 00			db "NUM2STR",0              
31e1				endm 
# End of macro CWHEAD
31e1			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
31e1			 
31e1			;		; malloc a string to target 
31e1			;		ld hl, 10     ; TODO max string size should be fine 
31e1			;		call malloc 
31e1			;		push hl    ; save malloc location 
31e1			; 
31e1			; 
31e1			;; TODO check int type 
31e1			;		FORTH_DSP_VALUEHL 
31e1			;		ld a, l 
31e1			;		call DispAToASCII   
31e1			;;TODO need to chage above call to dump into string 
31e1			; 
31e1			; 
31e1			 
31e1				       NEXTW 
31e1 c3 36 1a			jp macro_next 
31e4				endm 
# End of macro NEXTW
31e4			 
31e4			.CONCAT: 
31e4				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
31e4 48				db WORD_SYS_CORE+52             
31e5 43 32			dw .FIND            
31e7 07				db 6 + 1 
31e8 .. 00			db "CONCAT",0              
31ef				endm 
# End of macro CWHEAD
31ef			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
31ef			 
31ef			; TODO check string type 
31ef			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
31ef			 
31ef					if DEBUG_FORTH_WORDS_KEY 
31ef						DMARK "CON" 
31ef f5				push af  
31f0 3a 04 32			ld a, (.dmark)  
31f3 32 bd fb			ld (debug_mark),a  
31f6 3a 05 32			ld a, (.dmark+1)  
31f9 32 be fb			ld (debug_mark+1),a  
31fc 3a 06 32			ld a, (.dmark+2)  
31ff 32 bf fb			ld (debug_mark+2),a  
3202 18 03			jr .pastdmark  
3204 ..			.dmark: db "CON"  
3207 f1			.pastdmark: pop af  
3208			endm  
# End of macro DMARK
3208						CALLMONITOR 
3208 cd d7 12			call break_point_state  
320b				endm  
# End of macro CALLMONITOR
320b					endif 
320b			 
320b			 
320b					FORTH_DSP_VALUE 
320b cd e5 18			call macro_forth_dsp_value 
320e				endm 
# End of macro FORTH_DSP_VALUE
320e e5					push hl   ; s2 
320f			 
320f					FORTH_DSP_POP 
320f cd 7c 19			call macro_forth_dsp_pop 
3212				endm 
# End of macro FORTH_DSP_POP
3212			 
3212					FORTH_DSP_VALUE 
3212 cd e5 18			call macro_forth_dsp_value 
3215				endm 
# End of macro FORTH_DSP_VALUE
3215			 
3215 e5					push hl   ; s1 
3216			 
3216					FORTH_DSP_POP 
3216 cd 7c 19			call macro_forth_dsp_pop 
3219				endm 
# End of macro FORTH_DSP_POP
3219					 
3219			 
3219					; copy s1 
3219			 
3219				 
3219					; save ptr 
3219 e1					pop hl  
321a e5					push hl 
321b 3e 00				ld a, 0 
321d cd 7c 0f				call strlent 
3220					;inc hl    ; zer0 
3220 06 00				ld b, 0 
3222 4d					ld c, l 
3223 e1					pop hl		 
3224 11 b8 ef				ld de, scratch	 
3227					if DEBUG_FORTH_WORDS 
3227						DMARK "CO1" 
3227						CALLMONITOR 
3227					endif 
3227 ed b0				ldir 
3229			 
3229 e1					pop hl 
322a e5					push hl 
322b d5					push de 
322c			 
322c			 
322c 3e 00				ld a, 0 
322e cd 7c 0f				call strlent 
3231 23					inc hl    ; zer0 
3232 23					inc hl 
3233 06 00				ld b, 0 
3235 4d					ld c, l 
3236 d1					pop de 
3237 e1					pop hl		 
3238					if DEBUG_FORTH_WORDS 
3238						DMARK "CO2" 
3238						CALLMONITOR 
3238					endif 
3238 ed b0				ldir 
323a			 
323a			 
323a			 
323a 21 b8 ef				ld hl, scratch 
323d					if DEBUG_FORTH_WORDS 
323d						DMARK "CO5" 
323d						CALLMONITOR 
323d					endif 
323d			 
323d cd 73 18				call forth_push_str 
3240			 
3240			 
3240			 
3240			 
3240				       NEXTW 
3240 c3 36 1a			jp macro_next 
3243				endm 
# End of macro NEXTW
3243			 
3243			 
3243			.FIND: 
3243				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
3243 4b				db WORD_SYS_CORE+55             
3244 91 32			dw .LEN            
3246 05				db 4 + 1 
3247 .. 00			db "FIND",0              
324c				endm 
# End of macro CWHEAD
324c			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
324c			 
324c					if DEBUG_FORTH_WORDS_KEY 
324c						DMARK "FND" 
324c f5				push af  
324d 3a 61 32			ld a, (.dmark)  
3250 32 bd fb			ld (debug_mark),a  
3253 3a 62 32			ld a, (.dmark+1)  
3256 32 be fb			ld (debug_mark+1),a  
3259 3a 63 32			ld a, (.dmark+2)  
325c 32 bf fb			ld (debug_mark+2),a  
325f 18 03			jr .pastdmark  
3261 ..			.dmark: db "FND"  
3264 f1			.pastdmark: pop af  
3265			endm  
# End of macro DMARK
3265						CALLMONITOR 
3265 cd d7 12			call break_point_state  
3268				endm  
# End of macro CALLMONITOR
3268					endif 
3268			 
3268			; TODO check string type 
3268					FORTH_DSP_VALUE 
3268 cd e5 18			call macro_forth_dsp_value 
326b				endm 
# End of macro FORTH_DSP_VALUE
326b			 
326b e5					push hl    
326c 7e					ld a,(hl)    ; char to find   
326d			; TODO change char to substr 
326d			 
326d f5					push af 
326e					 
326e			 
326e			 
326e					if DEBUG_FORTH_WORDS 
326e						DMARK "FN1" 
326e						CALLMONITOR 
326e					endif 
326e			 
326e					FORTH_DSP_POP 
326e cd 7c 19			call macro_forth_dsp_pop 
3271				endm 
# End of macro FORTH_DSP_POP
3271			 
3271					; string to search 
3271			 
3271					FORTH_DSP_VALUE 
3271 cd e5 18			call macro_forth_dsp_value 
3274				endm 
# End of macro FORTH_DSP_VALUE
3274			 
3274 d1					pop de  ; d is char to find  
3275			 
3275					if DEBUG_FORTH_WORDS 
3275						DMARK "FN2" 
3275						CALLMONITOR 
3275					endif 
3275					 
3275 01 00 00				ld bc, 0 
3278 7e			.findchar:      ld a,(hl) 
3279 fe 00				cp 0   		 
327b 28 0b				jr z, .finddone     
327d ba					cp d 
327e 28 04				jr z, .foundchar 
3280 03					inc bc 
3281 23					inc hl 
3282					if DEBUG_FORTH_WORDS 
3282						DMARK "FN3" 
3282						CALLMONITOR 
3282					endif 
3282 18 f4				jr .findchar 
3284			 
3284			 
3284 c5			.foundchar:	push bc 
3285 e1					pop hl 
3286 18 03				jr .findexit 
3288			 
3288			 
3288							 
3288			 
3288			.finddone:     ; got to end of string with no find 
3288 21 00 00				ld hl, 0 
328b			.findexit: 
328b			 
328b					if DEBUG_FORTH_WORDS 
328b						DMARK "FNd" 
328b						CALLMONITOR 
328b					endif 
328b cd 61 18			call forth_push_numhl 
328e			 
328e				       NEXTW 
328e c3 36 1a			jp macro_next 
3291				endm 
# End of macro NEXTW
3291			 
3291			.LEN: 
3291				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
3291 4c				db WORD_SYS_CORE+56             
3292 c6 32			dw .CHAR            
3294 06				db 5 + 1 
3295 .. 00			db "COUNT",0              
329b				endm 
# End of macro CWHEAD
329b			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
329b			 
329b					if DEBUG_FORTH_WORDS_KEY 
329b						DMARK "CNT" 
329b f5				push af  
329c 3a b0 32			ld a, (.dmark)  
329f 32 bd fb			ld (debug_mark),a  
32a2 3a b1 32			ld a, (.dmark+1)  
32a5 32 be fb			ld (debug_mark+1),a  
32a8 3a b2 32			ld a, (.dmark+2)  
32ab 32 bf fb			ld (debug_mark+2),a  
32ae 18 03			jr .pastdmark  
32b0 ..			.dmark: db "CNT"  
32b3 f1			.pastdmark: pop af  
32b4			endm  
# End of macro DMARK
32b4						CALLMONITOR 
32b4 cd d7 12			call break_point_state  
32b7				endm  
# End of macro CALLMONITOR
32b7					endif 
32b7			; TODO check string type 
32b7					FORTH_DSP 
32b7 cd e1 18			call macro_forth_dsp 
32ba				endm 
# End of macro FORTH_DSP
32ba					;v5FORTH_DSP_VALUE 
32ba			 
32ba 23					inc hl 
32bb			 
32bb 3e 00				ld a, 0 
32bd cd 7c 0f				call strlent 
32c0			 
32c0 cd 61 18				call forth_push_numhl 
32c3			 
32c3			 
32c3			 
32c3				       NEXTW 
32c3 c3 36 1a			jp macro_next 
32c6				endm 
# End of macro NEXTW
32c6			.CHAR: 
32c6				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
32c6 4d				db WORD_SYS_CORE+57             
32c7 fc 32			dw .ENDSTR            
32c9 05				db 4 + 1 
32ca .. 00			db "CHAR",0              
32cf				endm 
# End of macro CWHEAD
32cf			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
32cf					if DEBUG_FORTH_WORDS_KEY 
32cf						DMARK "CHR" 
32cf f5				push af  
32d0 3a e4 32			ld a, (.dmark)  
32d3 32 bd fb			ld (debug_mark),a  
32d6 3a e5 32			ld a, (.dmark+1)  
32d9 32 be fb			ld (debug_mark+1),a  
32dc 3a e6 32			ld a, (.dmark+2)  
32df 32 bf fb			ld (debug_mark+2),a  
32e2 18 03			jr .pastdmark  
32e4 ..			.dmark: db "CHR"  
32e7 f1			.pastdmark: pop af  
32e8			endm  
# End of macro DMARK
32e8						CALLMONITOR 
32e8 cd d7 12			call break_point_state  
32eb				endm  
# End of macro CALLMONITOR
32eb					endif 
32eb					FORTH_DSP 
32eb cd e1 18			call macro_forth_dsp 
32ee				endm 
# End of macro FORTH_DSP
32ee					;v5 FORTH_DSP_VALUE 
32ee 23					inc hl      ; now at start of numeric as string 
32ef			 
32ef			;		push hl 
32ef			 
32ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32ef cd 7c 19			call macro_forth_dsp_pop 
32f2				endm 
# End of macro FORTH_DSP_POP
32f2			 
32f2			;		pop hl 
32f2			 
32f2					; push the content of a onto the stack as a value 
32f2			 
32f2 7e					ld a,(hl)   ; get char 
32f3 26 00				ld h,0 
32f5 6f					ld l,a 
32f6 cd 61 18				call forth_push_numhl 
32f9			 
32f9				       NEXTW 
32f9 c3 36 1a			jp macro_next 
32fc				endm 
# End of macro NEXTW
32fc			 
32fc			 
32fc			 
32fc			 
32fc			.ENDSTR: 
32fc			; eof 
32fc			 
# End of file forth_words_str.asm
32fc			include "forth_words_key.asm" 
32fc			 
32fc			; | ## Keyboard Words 
32fc			 
32fc			.KEY: 
32fc				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
32fc 3e				db WORD_SYS_CORE+42             
32fd 2c 33			dw .WAITK            
32ff 04				db 3 + 1 
3300 .. 00			db "KEY",0              
3304				endm 
# End of macro CWHEAD
3304			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
3304			 
3304					if DEBUG_FORTH_WORDS_KEY 
3304						DMARK "KEY" 
3304 f5				push af  
3305 3a 19 33			ld a, (.dmark)  
3308 32 bd fb			ld (debug_mark),a  
330b 3a 1a 33			ld a, (.dmark+1)  
330e 32 be fb			ld (debug_mark+1),a  
3311 3a 1b 33			ld a, (.dmark+2)  
3314 32 bf fb			ld (debug_mark+2),a  
3317 18 03			jr .pastdmark  
3319 ..			.dmark: db "KEY"  
331c f1			.pastdmark: pop af  
331d			endm  
# End of macro DMARK
331d						CALLMONITOR 
331d cd d7 12			call break_point_state  
3320				endm  
# End of macro CALLMONITOR
3320					endif 
3320			; TODO currently waits 
3320 cd 23 53				call cin_wait 
3323 6f					ld l, a 
3324 26 00				ld h, 0 
3326 cd 61 18				call forth_push_numhl 
3329					NEXTW 
3329 c3 36 1a			jp macro_next 
332c				endm 
# End of macro NEXTW
332c			.WAITK: 
332c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
332c 3f				db WORD_SYS_CORE+43             
332d 5e 33			dw .ACCEPT            
332f 06				db 5 + 1 
3330 .. 00			db "WAITK",0              
3336				endm 
# End of macro CWHEAD
3336			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
3336					if DEBUG_FORTH_WORDS_KEY 
3336						DMARK "WAI" 
3336 f5				push af  
3337 3a 4b 33			ld a, (.dmark)  
333a 32 bd fb			ld (debug_mark),a  
333d 3a 4c 33			ld a, (.dmark+1)  
3340 32 be fb			ld (debug_mark+1),a  
3343 3a 4d 33			ld a, (.dmark+2)  
3346 32 bf fb			ld (debug_mark+2),a  
3349 18 03			jr .pastdmark  
334b ..			.dmark: db "WAI"  
334e f1			.pastdmark: pop af  
334f			endm  
# End of macro DMARK
334f						CALLMONITOR 
334f cd d7 12			call break_point_state  
3352				endm  
# End of macro CALLMONITOR
3352					endif 
3352 cd 23 53				call cin_wait 
3355 6f					ld l, a 
3356 26 00				ld h, 0 
3358 cd 61 18				call forth_push_numhl 
335b					NEXTW 
335b c3 36 1a			jp macro_next 
335e				endm 
# End of macro NEXTW
335e			.ACCEPT: 
335e				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
335e 40				db WORD_SYS_CORE+44             
335f a0 33			dw .EDIT            
3361 07				db 6 + 1 
3362 .. 00			db "ACCEPT",0              
3369				endm 
# End of macro CWHEAD
3369			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
3369					; TODO crashes on push 
3369					if DEBUG_FORTH_WORDS_KEY 
3369						DMARK "ACC" 
3369 f5				push af  
336a 3a 7e 33			ld a, (.dmark)  
336d 32 bd fb			ld (debug_mark),a  
3370 3a 7f 33			ld a, (.dmark+1)  
3373 32 be fb			ld (debug_mark+1),a  
3376 3a 80 33			ld a, (.dmark+2)  
3379 32 bf fb			ld (debug_mark+2),a  
337c 18 03			jr .pastdmark  
337e ..			.dmark: db "ACC"  
3381 f1			.pastdmark: pop af  
3382			endm  
# End of macro DMARK
3382						CALLMONITOR 
3382 cd d7 12			call break_point_state  
3385				endm  
# End of macro CALLMONITOR
3385					endif 
3385 21 b6 f1				ld hl, os_input 
3388 3e 00				ld a, 0 
338a 77					ld (hl),a 
338b 3a e1 f9				ld a,(f_cursor_ptr) 
338e 16 64				ld d, 100 
3390 0e 00				ld c, 0 
3392 1e 28				ld e, 40 
3394 cd 40 0b				call input_str 
3397					; TODO perhaps do a type check and wrap in quotes if not a number 
3397 21 b6 f1				ld hl, os_input 
339a					if DEBUG_FORTH_WORDS 
339a						DMARK "AC1" 
339a						CALLMONITOR 
339a					endif 
339a cd 73 18				call forth_push_str 
339d					NEXTW 
339d c3 36 1a			jp macro_next 
33a0				endm 
# End of macro NEXTW
33a0			 
33a0			.EDIT: 
33a0				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
33a0 40				db WORD_SYS_CORE+44             
33a1 0d 34			dw .ENDKEY            
33a3 05				db 4 + 1 
33a4 .. 00			db "EDIT",0              
33a9				endm 
# End of macro CWHEAD
33a9			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
33a9			 
33a9					; TODO does not copy from stack 
33a9					if DEBUG_FORTH_WORDS_KEY 
33a9						DMARK "EDT" 
33a9 f5				push af  
33aa 3a be 33			ld a, (.dmark)  
33ad 32 bd fb			ld (debug_mark),a  
33b0 3a bf 33			ld a, (.dmark+1)  
33b3 32 be fb			ld (debug_mark+1),a  
33b6 3a c0 33			ld a, (.dmark+2)  
33b9 32 bf fb			ld (debug_mark+2),a  
33bc 18 03			jr .pastdmark  
33be ..			.dmark: db "EDT"  
33c1 f1			.pastdmark: pop af  
33c2			endm  
# End of macro DMARK
33c2						CALLMONITOR 
33c2 cd d7 12			call break_point_state  
33c5				endm  
# End of macro CALLMONITOR
33c5					endif 
33c5			 
33c5					FORTH_DSP 
33c5 cd e1 18			call macro_forth_dsp 
33c8				endm 
# End of macro FORTH_DSP
33c8					;v5 FORTH_DSP_VALUE 
33c8 23					inc hl    ; TODO do type check 
33c9			 
33c9 e5					push hl 
33ca 3e 00				ld a, 0 
33cc cd 7c 0f				call strlent 
33cf 23					inc hl 
33d0			 
33d0 06 00				ld b, 0 
33d2 4d					ld c, l 
33d3			 
33d3 e1					pop hl 
33d4 11 b6 f1				ld de, os_input 
33d7					if DEBUG_FORTH_WORDS_KEY 
33d7						DMARK "EDc" 
33d7 f5				push af  
33d8 3a ec 33			ld a, (.dmark)  
33db 32 bd fb			ld (debug_mark),a  
33de 3a ed 33			ld a, (.dmark+1)  
33e1 32 be fb			ld (debug_mark+1),a  
33e4 3a ee 33			ld a, (.dmark+2)  
33e7 32 bf fb			ld (debug_mark+2),a  
33ea 18 03			jr .pastdmark  
33ec ..			.dmark: db "EDc"  
33ef f1			.pastdmark: pop af  
33f0			endm  
# End of macro DMARK
33f0						CALLMONITOR 
33f0 cd d7 12			call break_point_state  
33f3				endm  
# End of macro CALLMONITOR
33f3					endif 
33f3 ed b0				ldir 
33f5			 
33f5			 
33f5 21 b6 f1				ld hl, os_input 
33f8					;ld a, 0 
33f8					;ld (hl),a 
33f8 3a e1 f9				ld a,(f_cursor_ptr) 
33fb 16 64				ld d, 100 
33fd 0e 00				ld c, 0 
33ff 1e 28				ld e, 40 
3401 cd 40 0b				call input_str 
3404					; TODO perhaps do a type check and wrap in quotes if not a number 
3404 21 b6 f1				ld hl, os_input 
3407					if DEBUG_FORTH_WORDS 
3407						DMARK "ED1" 
3407						CALLMONITOR 
3407					endif 
3407 cd 73 18				call forth_push_str 
340a					NEXTW 
340a c3 36 1a			jp macro_next 
340d				endm 
# End of macro NEXTW
340d			 
340d			 
340d			 
340d			.ENDKEY: 
340d			; eof 
340d			 
# End of file forth_words_key.asm
340d			 
340d			if STORAGE_SE 
340d			   	include "forth_words_storage.asm" 
340d			 
340d			; | ## Fixed Storage Words 
340d			 
340d			 
340d			.BREAD: 
340d			  
340d				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
340d 3a				db WORD_SYS_CORE+38             
340e 4e 34			dw .BWRITE            
3410 06				db 5 + 1 
3411 .. 00			db "BREAD",0              
3417				endm 
# End of macro CWHEAD
3417			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | TO TEST 
3417				 
3417					if DEBUG_FORTH_WORDS_KEY 
3417						DMARK "BRD" 
3417 f5				push af  
3418 3a 2c 34			ld a, (.dmark)  
341b 32 bd fb			ld (debug_mark),a  
341e 3a 2d 34			ld a, (.dmark+1)  
3421 32 be fb			ld (debug_mark+1),a  
3424 3a 2e 34			ld a, (.dmark+2)  
3427 32 bf fb			ld (debug_mark+2),a  
342a 18 03			jr .pastdmark  
342c ..			.dmark: db "BRD"  
342f f1			.pastdmark: pop af  
3430			endm  
# End of macro DMARK
3430						CALLMONITOR 
3430 cd d7 12			call break_point_state  
3433				endm  
# End of macro CALLMONITOR
3433					endif 
3433			 
3433				FORTH_DSP_VALUEHL 
3433 cd fc 18			call macro_dsp_valuehl 
3436				endm 
# End of macro FORTH_DSP_VALUEHL
3436			 
3436				FORTH_DSP_POP 
3436 cd 7c 19			call macro_forth_dsp_pop 
3439				endm 
# End of macro FORTH_DSP_POP
3439			 
3439				; calc block address 
3439			 
3439 eb				ex de, hl 
343a 3e 40			ld a, STORE_BLOCK_PHY 
343c cd 96 0a			call Mult16 
343f			 
343f			 
343f 11 e8 f9			ld de, store_page 
3442			 
3442					if DEBUG_FORTH_WORDS 
3442						DMARK "BR1" 
3442						CALLMONITOR 
3442					endif 
3442			 
3442 cd 09 03			call storage_read_block 
3445			 
3445 21 ea f9		        ld hl, store_page+2 
3448					if DEBUG_FORTH_WORDS 
3448						DMARK "BR2" 
3448						CALLMONITOR 
3448					endif 
3448 cd 73 18			call forth_push_str 
344b			 
344b			 
344b					NEXTW 
344b c3 36 1a			jp macro_next 
344e				endm 
# End of macro NEXTW
344e			.BWRITE: 
344e				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
344e 3a				db WORD_SYS_CORE+38             
344f ab 34			dw .BUPD            
3451 07				db 6 + 1 
3452 .. 00			db "BWRITE",0              
3459				endm 
# End of macro CWHEAD
3459			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | TO TEST 
3459			 
3459					if DEBUG_FORTH_WORDS_KEY 
3459						DMARK "BWR" 
3459 f5				push af  
345a 3a 6e 34			ld a, (.dmark)  
345d 32 bd fb			ld (debug_mark),a  
3460 3a 6f 34			ld a, (.dmark+1)  
3463 32 be fb			ld (debug_mark+1),a  
3466 3a 70 34			ld a, (.dmark+2)  
3469 32 bf fb			ld (debug_mark+2),a  
346c 18 03			jr .pastdmark  
346e ..			.dmark: db "BWR"  
3471 f1			.pastdmark: pop af  
3472			endm  
# End of macro DMARK
3472						CALLMONITOR 
3472 cd d7 12			call break_point_state  
3475				endm  
# End of macro CALLMONITOR
3475					endif 
3475			 
3475				FORTH_DSP_VALUEHL 
3475 cd fc 18			call macro_dsp_valuehl 
3478				endm 
# End of macro FORTH_DSP_VALUEHL
3478			 
3478				; calc block address 
3478			 
3478 eb				ex de, hl 
3479 3e 40			ld a, STORE_BLOCK_PHY 
347b cd 96 0a			call Mult16 
347e			 
347e e5				push hl         ; address 
347f			 
347f				FORTH_DSP_POP 
347f cd 7c 19			call macro_forth_dsp_pop 
3482				endm 
# End of macro FORTH_DSP_POP
3482			 
3482				FORTH_DSP_VALUEHL 
3482 cd fc 18			call macro_dsp_valuehl 
3485				endm 
# End of macro FORTH_DSP_VALUEHL
3485			 
3485				FORTH_DSP_POP 
3485 cd 7c 19			call macro_forth_dsp_pop 
3488				endm 
# End of macro FORTH_DSP_POP
3488			 
3488 cd 0e 09			call storage_clear_page 
348b			 
348b				; copy string to store page 
348b			 
348b e5				push hl     ; save string address 
348c			 
348c 3e 00			ld a, 0 
348e cd 7c 0f			call strlent 
3491			 
3491 23				inc hl 
3492			 
3492 4d				ld c, l 
3493 06 00			ld b, 0 
3495			 
3495 e1				pop hl 
3496 11 ea f9			ld de, store_page + 2 
3499					if DEBUG_FORTH_WORDS 
3499						DMARK "BW1" 
3499						CALLMONITOR 
3499					endif 
3499 ed b0			ldir 
349b			 
349b			 
349b				; poke the start of the block with flags to prevent high level file ops hitting the block 
349b			 
349b 21 ff ff			ld hl, $ffff 
349e			 
349e 22 e8 f9			ld (store_page), hl	 
34a1				 
34a1 e1				pop hl    ; get address 
34a2 11 e8 f9			ld de, store_page 
34a5			 
34a5					if DEBUG_FORTH_WORDS 
34a5						DMARK "BW2" 
34a5						CALLMONITOR 
34a5					endif 
34a5			 
34a5 cd 52 03			call storage_write_block 
34a8			 
34a8					NEXTW 
34a8 c3 36 1a			jp macro_next 
34ab				endm 
# End of macro NEXTW
34ab			 
34ab			.BUPD: 
34ab				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
34ab 3a				db WORD_SYS_CORE+38             
34ac e5 34			dw .BYID            
34ae 05				db 4 + 1 
34af .. 00			db "BUPD",0              
34b4				endm 
# End of macro CWHEAD
34b4			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | TO TEST 
34b4			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
34b4			; | | or completely different file system structure. 
34b4			 
34b4					if DEBUG_FORTH_WORDS_KEY 
34b4						DMARK "BUD" 
34b4 f5				push af  
34b5 3a c9 34			ld a, (.dmark)  
34b8 32 bd fb			ld (debug_mark),a  
34bb 3a ca 34			ld a, (.dmark+1)  
34be 32 be fb			ld (debug_mark+1),a  
34c1 3a cb 34			ld a, (.dmark+2)  
34c4 32 bf fb			ld (debug_mark+2),a  
34c7 18 03			jr .pastdmark  
34c9 ..			.dmark: db "BUD"  
34cc f1			.pastdmark: pop af  
34cd			endm  
# End of macro DMARK
34cd						CALLMONITOR 
34cd cd d7 12			call break_point_state  
34d0				endm  
# End of macro CALLMONITOR
34d0					endif 
34d0			 
34d0				FORTH_DSP_VALUEHL 
34d0 cd fc 18			call macro_dsp_valuehl 
34d3				endm 
# End of macro FORTH_DSP_VALUEHL
34d3			 
34d3				; calc block address 
34d3			 
34d3 eb				ex de, hl 
34d4 3e 40			ld a, STORE_BLOCK_PHY 
34d6 cd 96 0a			call Mult16 
34d9			 
34d9				FORTH_DSP_POP 
34d9 cd 7c 19			call macro_forth_dsp_pop 
34dc				endm 
# End of macro FORTH_DSP_POP
34dc			 
34dc			 
34dc 11 e8 f9			ld de, store_page 
34df			 
34df					if DEBUG_FORTH_WORDS 
34df						DMARK "BUe" 
34df						CALLMONITOR 
34df					endif 
34df			 
34df cd 52 03			call storage_write_block 
34e2			 
34e2					NEXTW 
34e2 c3 36 1a			jp macro_next 
34e5				endm 
# End of macro NEXTW
34e5			 
34e5			.BYID: 
34e5				CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
34e5 3a				db WORD_SYS_CORE+38             
34e6 f1 34			dw .BYNAME            
34e8 05				db 4 + 1 
34e9 .. 00			db "BYID",0              
34ee				endm 
# End of macro CWHEAD
34ee			; | BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u | TODO 
34ee					NEXTW 
34ee c3 36 1a			jp macro_next 
34f1				endm 
# End of macro NEXTW
34f1			.BYNAME: 
34f1				CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
34f1 3a				db WORD_SYS_CORE+38             
34f2 ff 34			dw .DIR            
34f4 07				db 6 + 1 
34f5 .. 00			db "BYNAME",0              
34fc				endm 
# End of macro CWHEAD
34fc			; | BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s | TODO 
34fc					NEXTW 
34fc c3 36 1a			jp macro_next 
34ff				endm 
# End of macro NEXTW
34ff			 
34ff			.DIR: 
34ff				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
34ff 3a				db WORD_SYS_CORE+38             
3500 77 35			dw .SAVE            
3502 04				db 3 + 1 
3503 .. 00			db "DIR",0              
3507				endm 
# End of macro CWHEAD
3507			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
3507			 
3507					if DEBUG_FORTH_WORDS_KEY 
3507						DMARK "DIR" 
3507 f5				push af  
3508 3a 1c 35			ld a, (.dmark)  
350b 32 bd fb			ld (debug_mark),a  
350e 3a 1d 35			ld a, (.dmark+1)  
3511 32 be fb			ld (debug_mark+1),a  
3514 3a 1e 35			ld a, (.dmark+2)  
3517 32 bf fb			ld (debug_mark+2),a  
351a 18 03			jr .pastdmark  
351c ..			.dmark: db "DIR"  
351f f1			.pastdmark: pop af  
3520			endm  
# End of macro DMARK
3520						CALLMONITOR 
3520 cd d7 12			call break_point_state  
3523				endm  
# End of macro CALLMONITOR
3523					endif 
3523 cd 9e 03			call storage_get_block_0 
3526			 
3526 21 e8 f9			ld hl, store_page     ; get current id count 
3529 46				ld b, (hl) 
352a 0e 00			ld c, 0    ; count of files   
352c					if DEBUG_FORTH_WORDS 
352c						DMARK "DI1" 
352c						CALLMONITOR 
352c					endif 
352c			 
352c				; check for empty drive 
352c			 
352c 3e 00			ld a, 0 
352e b8				cp b 
352f ca 65 35			jp z, .dirdone 
3532			 
3532				; for each of the current ids do a search for them and if found push to stack 
3532			 
3532 c5			.diritem:	push bc 
3533 21 40 00				ld hl, STORE_BLOCK_PHY 
3536 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
3538 58					ld e,b 
3539			 
3539			;		if DEBUG_FORTH_WORDS 
3539			;			DMARK "DI2" 
3539			;			CALLMONITOR 
3539			;		endif 
3539			 
3539 cd 77 05				call storage_findnextid 
353c			 
353c			;		if DEBUG_FORTH_WORDS 
353c			;			DMARK "DI3" 
353c			;			CALLMONITOR 
353c			;		endif 
353c			 
353c					; if found hl will be non zero 
353c			 
353c cd 3c 0b				call ishlzero 
353f			;		ld a, l 
353f			;		add h 
353f			; 
353f			;		cp 0 
353f 28 21				jr z, .dirnotfound 
3541			 
3541					; increase count 
3541			 
3541 c1					pop bc	 
3542 0c					inc c 
3543 c5					push bc 
3544					 
3544			 
3544					; get file header and push the file name 
3544			 
3544 11 e8 f9				ld de, store_page 
3547 cd 09 03				call storage_read_block 
354a			 
354a					; push file id to stack 
354a				 
354a 3a e8 f9				ld a, (store_page) 
354d 26 00				ld h, 0 
354f 6f					ld l, a 
3550 cd 61 18				call forth_push_numhl 
3553			 
3553					; push extent count to stack  
3553				 
3553 3a ea f9				ld a, (store_page+2) 
3556 26 00				ld h, 0 
3558 6f					ld l, a 
3559 cd 61 18				call forth_push_numhl 
355c			 
355c					; push file name 
355c			 
355c 21 eb f9				ld hl, store_page+3 
355f					if DEBUG_FORTH_WORDS 
355f						DMARK "DI5" 
355f						CALLMONITOR 
355f					endif 
355f cd 73 18				call forth_push_str 
3562					if DEBUG_FORTH_WORDS 
3562						DMARK "DI6" 
3562						CALLMONITOR 
3562					endif 
3562			.dirnotfound: 
3562 c1					pop bc     
3563 10 cd				djnz .diritem 
3565				 
3565			.dirdone:	 
3565					if DEBUG_FORTH_WORDS 
3565						DMARK "DI7" 
3565						CALLMONITOR 
3565					endif 
3565			 
3565					; push a count of the dir items found 
3565			 
3565 26 00				ld h, 0 
3567 69					ld l, c 
3568 cd 61 18				call forth_push_numhl 
356b			 
356b					; push the bank label 
356b			 
356b cd 9e 03				call storage_get_block_0 
356e			 
356e				 
356e 21 eb f9		 		ld hl, store_page+3 
3571			 
3571					if DEBUG_FORTH_WORDS 
3571						DMARK "DI8" 
3571						CALLMONITOR 
3571					endif 
3571 cd 73 18				call forth_push_str 
3574			 
3574			 
3574				 
3574					NEXTW 
3574 c3 36 1a			jp macro_next 
3577				endm 
# End of macro NEXTW
3577			.SAVE: 
3577				CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
3577 3b				db WORD_SYS_CORE+39             
3578 83 35			dw .LOAD            
357a 05				db 4 + 1 
357b .. 00			db "SAVE",0              
3580				endm 
# End of macro CWHEAD
3580			; | SAVE  ( w u -- )    Save user word memory to file name w on bank u | TODO 
3580					NEXTW 
3580 c3 36 1a			jp macro_next 
3583				endm 
# End of macro NEXTW
3583			.LOAD: 
3583				CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
3583 3c				db WORD_SYS_CORE+40             
3584 e5 36			dw .BSAVE            
3586 05				db 4 + 1 
3587 .. 00			db "LOAD",0              
358c				endm 
# End of macro CWHEAD
358c			; | LOAD ( u -- )    Load user word memory from file id on current bank | TODO 
358c			; | | The indivdual records being loaded can be both uword word difintions or interactive commands. 
358c			; | | The LOAD command can not be used in any user words or compound lines. 
358c			 
358c					; store_openext use it. If zero it is EOF 
358c			 
358c					; read block from current stream id 
358c					; if the block does not contain zero term keep reading blocks until zero found 
358c					; push the block to stack 
358c					; save the block id to stream 
358c			 
358c			 
358c					FORTH_DSP_VALUEHL 
358c cd fc 18			call macro_dsp_valuehl 
358f				endm 
# End of macro FORTH_DSP_VALUEHL
358f			 
358f			;		push hl 
358f			 
358f				if DEBUG_STORESE 
358f					DMARK "LOA" 
358f f5				push af  
3590 3a a4 35			ld a, (.dmark)  
3593 32 bd fb			ld (debug_mark),a  
3596 3a a5 35			ld a, (.dmark+1)  
3599 32 be fb			ld (debug_mark+1),a  
359c 3a a6 35			ld a, (.dmark+2)  
359f 32 bf fb			ld (debug_mark+2),a  
35a2 18 03			jr .pastdmark  
35a4 ..			.dmark: db "LOA"  
35a7 f1			.pastdmark: pop af  
35a8			endm  
# End of macro DMARK
35a8					CALLMONITOR 
35a8 cd d7 12			call break_point_state  
35ab				endm  
# End of macro CALLMONITOR
35ab				endif 
35ab					FORTH_DSP_POP 
35ab cd 7c 19			call macro_forth_dsp_pop 
35ae				endm 
# End of macro FORTH_DSP_POP
35ae			 
35ae			;		pop hl 
35ae			 
35ae 65					ld h, l 
35af 2e 00				ld l, 0 
35b1			 
35b1 e5					push hl     ; stack holds current file id and extent to work with 
35b2			 
35b2			 
35b2 11 e8 f9				ld de, store_page      ; get block zero of file 
35b5				if DEBUG_STORESE 
35b5					DMARK "LO0" 
35b5 f5				push af  
35b6 3a ca 35			ld a, (.dmark)  
35b9 32 bd fb			ld (debug_mark),a  
35bc 3a cb 35			ld a, (.dmark+1)  
35bf 32 be fb			ld (debug_mark+1),a  
35c2 3a cc 35			ld a, (.dmark+2)  
35c5 32 bf fb			ld (debug_mark+2),a  
35c8 18 03			jr .pastdmark  
35ca ..			.dmark: db "LO0"  
35cd f1			.pastdmark: pop af  
35ce			endm  
# End of macro DMARK
35ce					CALLMONITOR 
35ce cd d7 12			call break_point_state  
35d1				endm  
# End of macro CALLMONITOR
35d1				endif 
35d1 cd 47 07				call storage_read 
35d4			 
35d4 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
35d7 32 de f9				ld  (store_openmaxext),a   ; get our limit 
35da			 
35da				if DEBUG_STORESE 
35da					DMARK "LOE" 
35da f5				push af  
35db 3a ef 35			ld a, (.dmark)  
35de 32 bd fb			ld (debug_mark),a  
35e1 3a f0 35			ld a, (.dmark+1)  
35e4 32 be fb			ld (debug_mark+1),a  
35e7 3a f1 35			ld a, (.dmark+2)  
35ea 32 bf fb			ld (debug_mark+2),a  
35ed 18 03			jr .pastdmark  
35ef ..			.dmark: db "LOE"  
35f2 f1			.pastdmark: pop af  
35f3			endm  
# End of macro DMARK
35f3					CALLMONITOR 
35f3 cd d7 12			call break_point_state  
35f6				endm  
# End of macro CALLMONITOR
35f6				endif 
35f6			 
35f6			; TODO dont know why max extents are not present 
35f6			;		cp 0 
35f6			;		jp z, .loadeof     ; dont read past eof 
35f6			 
35f6			;		ld a, 1   ; start from the head of the file 
35f6			 
35f6 e1			.loadline:	pop hl 
35f7 23					inc hl 
35f8 3a de f9				ld  a, (store_openmaxext)   ; get our limit 
35fb				if DEBUG_STORESE 
35fb					DMARK "LOx" 
35fb f5				push af  
35fc 3a 10 36			ld a, (.dmark)  
35ff 32 bd fb			ld (debug_mark),a  
3602 3a 11 36			ld a, (.dmark+1)  
3605 32 be fb			ld (debug_mark+1),a  
3608 3a 12 36			ld a, (.dmark+2)  
360b 32 bf fb			ld (debug_mark+2),a  
360e 18 03			jr .pastdmark  
3610 ..			.dmark: db "LOx"  
3613 f1			.pastdmark: pop af  
3614			endm  
# End of macro DMARK
3614					CALLMONITOR 
3614 cd d7 12			call break_point_state  
3617				endm  
# End of macro CALLMONITOR
3617				endif 
3617 3c					inc a 
3618 bd					cp l 
3619 ca c3 36				jp z, .loadeof 
361c e5					push hl    ; save current extent 
361d			 
361d 11 e8 f9				ld de, store_page 
3620			 
3620				if DEBUG_STORESE 
3620					DMARK "LO1" 
3620 f5				push af  
3621 3a 35 36			ld a, (.dmark)  
3624 32 bd fb			ld (debug_mark),a  
3627 3a 36 36			ld a, (.dmark+1)  
362a 32 be fb			ld (debug_mark+1),a  
362d 3a 37 36			ld a, (.dmark+2)  
3630 32 bf fb			ld (debug_mark+2),a  
3633 18 03			jr .pastdmark  
3635 ..			.dmark: db "LO1"  
3638 f1			.pastdmark: pop af  
3639			endm  
# End of macro DMARK
3639					CALLMONITOR 
3639 cd d7 12			call break_point_state  
363c				endm  
# End of macro CALLMONITOR
363c				endif 
363c cd 47 07				call storage_read 
363f			 
363f				if DEBUG_STORESE 
363f					DMARK "LO2" 
363f f5				push af  
3640 3a 54 36			ld a, (.dmark)  
3643 32 bd fb			ld (debug_mark),a  
3646 3a 55 36			ld a, (.dmark+1)  
3649 32 be fb			ld (debug_mark+1),a  
364c 3a 56 36			ld a, (.dmark+2)  
364f 32 bf fb			ld (debug_mark+2),a  
3652 18 03			jr .pastdmark  
3654 ..			.dmark: db "LO2"  
3657 f1			.pastdmark: pop af  
3658			endm  
# End of macro DMARK
3658					CALLMONITOR 
3658 cd d7 12			call break_point_state  
365b				endm  
# End of macro CALLMONITOR
365b				endif 
365b cd 3c 0b			call ishlzero 
365e			;	ld a, l 
365e			;	add h 
365e			;	cp 0 
365e 28 63			jr z, .loadeof 
3660			 
3660				; not eof so hl should point to data to exec 
3660			 
3660				; will need to add the FORTH_END_BUFFER flag 
3660			  
3660 21 ea f9			ld hl, store_page+2 
3663 01 ff 00			ld bc, 255 
3666 3e 00			ld a, 0 
3668 ed b1			cpir 
366a				if DEBUG_STORESE 
366a					DMARK "LOt" 
366a f5				push af  
366b 3a 7f 36			ld a, (.dmark)  
366e 32 bd fb			ld (debug_mark),a  
3671 3a 80 36			ld a, (.dmark+1)  
3674 32 be fb			ld (debug_mark+1),a  
3677 3a 81 36			ld a, (.dmark+2)  
367a 32 bf fb			ld (debug_mark+2),a  
367d 18 03			jr .pastdmark  
367f ..			.dmark: db "LOt"  
3682 f1			.pastdmark: pop af  
3683			endm  
# End of macro DMARK
3683					CALLMONITOR 
3683 cd d7 12			call break_point_state  
3686				endm  
# End of macro CALLMONITOR
3686				endif 
3686 2b				dec hl 
3687 3e 20			ld a, ' ' 
3689 77				ld (hl), a 
368a 23				inc hl 
368b 77				ld (hl), a 
368c 23				inc hl 
368d 77				ld (hl), a 
368e 23				inc hl 
368f 3e 7f			ld a, FORTH_END_BUFFER 
3691 77				ld (hl), a 
3692			 
3692				; TODO handle more than a single block read 
3692			 
3692			 
3692 21 ea f9			ld hl, store_page+2 
3695			 
3695 22 b9 f2			ld (os_tok_ptr), hl 
3698			 
3698				if DEBUG_STORESE 
3698					DMARK "LO3" 
3698 f5				push af  
3699 3a ad 36			ld a, (.dmark)  
369c 32 bd fb			ld (debug_mark),a  
369f 3a ae 36			ld a, (.dmark+1)  
36a2 32 be fb			ld (debug_mark+1),a  
36a5 3a af 36			ld a, (.dmark+2)  
36a8 32 bf fb			ld (debug_mark+2),a  
36ab 18 03			jr .pastdmark  
36ad ..			.dmark: db "LO3"  
36b0 f1			.pastdmark: pop af  
36b1			endm  
# End of macro DMARK
36b1					CALLMONITOR 
36b1 cd d7 12			call break_point_state  
36b4				endm  
# End of macro CALLMONITOR
36b4				endif 
36b4			 
36b4 cd 84 1a			call forthparse 
36b7 cd c4 1a			call forthexec 
36ba cd db 19			call forthexec_cleanup 
36bd			 
36bd				; go to next extent 
36bd			 
36bd				; get next block  or mark as eof 
36bd c3 f6 35			jp .loadline 
36c0			 
36c0			 
36c0			 
36c0				       NEXTW 
36c0 c3 36 1a			jp macro_next 
36c3				endm 
# End of macro NEXTW
36c3 3e 00		.loadeof:	ld a, 0 
36c5 32 df f9				ld (store_openext), a 
36c8			 
36c8				if DEBUG_STORESE 
36c8					DMARK "LOF" 
36c8 f5				push af  
36c9 3a dd 36			ld a, (.dmark)  
36cc 32 bd fb			ld (debug_mark),a  
36cf 3a de 36			ld a, (.dmark+1)  
36d2 32 be fb			ld (debug_mark+1),a  
36d5 3a df 36			ld a, (.dmark+2)  
36d8 32 bf fb			ld (debug_mark+2),a  
36db 18 03			jr .pastdmark  
36dd ..			.dmark: db "LOF"  
36e0 f1			.pastdmark: pop af  
36e1			endm  
# End of macro DMARK
36e1					CALLMONITOR 
36e1 cd d7 12			call break_point_state  
36e4				endm  
# End of macro CALLMONITOR
36e4				endif 
36e4 c9					ret 
36e5					;NEXTW 
36e5			.BSAVE:   
36e5			 
36e5				CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
36e5 5a				db WORD_SYS_CORE+70             
36e6 f2 36			dw .BLOAD            
36e8 06				db 5 + 1 
36e9 .. 00			db "BSAVE",0              
36ef				endm 
# End of macro CWHEAD
36ef			; | BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes | TODO 
36ef					NEXTW 
36ef c3 36 1a			jp macro_next 
36f2				endm 
# End of macro NEXTW
36f2			.BLOAD: 
36f2				CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
36f2 5b				db WORD_SYS_CORE+71             
36f3 ff 36			dw .SEO            
36f5 06				db 5 + 1 
36f6 .. 00			db "BLOAD",0              
36fc				endm 
# End of macro CWHEAD
36fc			; | BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u | TODO 
36fc					NEXTW 
36fc c3 36 1a			jp macro_next 
36ff				endm 
# End of macro NEXTW
36ff			;;;; counter gap 
36ff			 
36ff			 
36ff			.SEO: 
36ff				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
36ff 64				db WORD_SYS_CORE+80             
3700 1e 37			dw .SEI            
3702 04				db 3 + 1 
3703 .. 00			db "SEO",0              
3707				endm 
# End of macro CWHEAD
3707			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
3707			 
3707					; get port 
3707			 
3707					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3707 cd fc 18			call macro_dsp_valuehl 
370a				endm 
# End of macro FORTH_DSP_VALUEHL
370a			 
370a e5					push hl    ; u2 - byte 
370b			 
370b					; destroy value TOS 
370b			 
370b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
370b cd 7c 19			call macro_forth_dsp_pop 
370e				endm 
# End of macro FORTH_DSP_POP
370e			 
370e					; get byte to send 
370e			 
370e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
370e cd fc 18			call macro_dsp_valuehl 
3711				endm 
# End of macro FORTH_DSP_VALUEHL
3711			 
3711 e5					push hl    ; u1 - addr 
3712			 
3712					; destroy value TOS 
3712			 
3712					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3712 cd 7c 19			call macro_forth_dsp_pop 
3715				endm 
# End of macro FORTH_DSP_POP
3715			 
3715					; one value on hl get other one back 
3715			 
3715 d1					pop de   ; u1 - byte 
3716			 
3716 e1					pop hl   ; u2 - addr 
3717			 
3717					; TODO Send SPI byte 
3717			 
3717			 
3717 7b					ld a, e 
3718 cd e7 01				call se_writebyte 
371b			 
371b					 
371b			 
371b					NEXTW 
371b c3 36 1a			jp macro_next 
371e				endm 
# End of macro NEXTW
371e			 
371e			.SEI: 
371e				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
371e 65				db WORD_SYS_CORE+81             
371f 38 37			dw .SFREE            
3721 04				db 3 + 1 
3722 .. 00			db "SEI",0              
3726				endm 
# End of macro CWHEAD
3726			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
3726			 
3726					; get port 
3726			 
3726					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3726 cd fc 18			call macro_dsp_valuehl 
3729				endm 
# End of macro FORTH_DSP_VALUEHL
3729			 
3729			;		push hl 
3729			 
3729					; destroy value TOS 
3729			 
3729					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3729 cd 7c 19			call macro_forth_dsp_pop 
372c				endm 
# End of macro FORTH_DSP_POP
372c			 
372c					; one value on hl get other one back 
372c			 
372c			;		pop hl 
372c			 
372c			 
372c					; TODO Get SPI byte 
372c			 
372c cd 89 02				call se_readbyte 
372f			 
372f 26 00				ld h, 0 
3731 6f					ld l, a 
3732 cd 61 18				call forth_push_numhl 
3735			 
3735					NEXTW 
3735 c3 36 1a			jp macro_next 
3738				endm 
# End of macro NEXTW
3738			 
3738			.SFREE: 
3738				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
3738 67				db WORD_SYS_CORE+83             
3739 67 37			dw .SIZE            
373b 06				db 5 + 1 
373c .. 00			db "FFREE",0              
3742				endm 
# End of macro CWHEAD
3742			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
3742					if DEBUG_FORTH_WORDS_KEY 
3742						DMARK "FFR" 
3742 f5				push af  
3743 3a 57 37			ld a, (.dmark)  
3746 32 bd fb			ld (debug_mark),a  
3749 3a 58 37			ld a, (.dmark+1)  
374c 32 be fb			ld (debug_mark+1),a  
374f 3a 59 37			ld a, (.dmark+2)  
3752 32 bf fb			ld (debug_mark+2),a  
3755 18 03			jr .pastdmark  
3757 ..			.dmark: db "FFR"  
375a f1			.pastdmark: pop af  
375b			endm  
# End of macro DMARK
375b						CALLMONITOR 
375b cd d7 12			call break_point_state  
375e				endm  
# End of macro CALLMONITOR
375e					endif 
375e			 
375e cd bd 05				call storage_freeblocks 
3761			 
3761 cd 61 18				call forth_push_numhl 
3764			 
3764				       NEXTW 
3764 c3 36 1a			jp macro_next 
3767				endm 
# End of macro NEXTW
3767			.SIZE: 
3767				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
3767 67				db WORD_SYS_CORE+83             
3768 9b 37			dw .CREATE            
376a 05				db 4 + 1 
376b .. 00			db "SIZE",0              
3770				endm 
# End of macro CWHEAD
3770			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
3770					if DEBUG_FORTH_WORDS_KEY 
3770						DMARK "SIZ" 
3770 f5				push af  
3771 3a 85 37			ld a, (.dmark)  
3774 32 bd fb			ld (debug_mark),a  
3777 3a 86 37			ld a, (.dmark+1)  
377a 32 be fb			ld (debug_mark+1),a  
377d 3a 87 37			ld a, (.dmark+2)  
3780 32 bf fb			ld (debug_mark+2),a  
3783 18 03			jr .pastdmark  
3785 ..			.dmark: db "SIZ"  
3788 f1			.pastdmark: pop af  
3789			endm  
# End of macro DMARK
3789						CALLMONITOR 
3789 cd d7 12			call break_point_state  
378c				endm  
# End of macro CALLMONITOR
378c					endif 
378c			 
378c					FORTH_DSP_VALUEHL 
378c cd fc 18			call macro_dsp_valuehl 
378f				endm 
# End of macro FORTH_DSP_VALUEHL
378f			;		push hl 
378f					FORTH_DSP_POP 
378f cd 7c 19			call macro_forth_dsp_pop 
3792				endm 
# End of macro FORTH_DSP_POP
3792			;		pop hl 
3792 cd 38 03				call storage_file_size 
3795			 
3795 cd 61 18				call forth_push_numhl 
3798			  
3798			 
3798				       NEXTW 
3798 c3 36 1a			jp macro_next 
379b				endm 
# End of macro NEXTW
379b			 
379b			.CREATE: 
379b				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
379b 68				db WORD_SYS_CORE+84             
379c 09 38			dw .APPEND            
379e 07				db 6 + 1 
379f .. 00			db "CREATE",0              
37a6				endm 
# End of macro CWHEAD
37a6			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | TO TEST 
37a6			; | | e.g.  
37a6			; | | TestProgram CREATE 
37a6			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
37a6			; | |  
37a6			; | | Max file IDs are 255. 
37a6			; | |  
37a6					 
37a6					if DEBUG_FORTH_WORDS_KEY 
37a6						DMARK "CRT" 
37a6 f5				push af  
37a7 3a bb 37			ld a, (.dmark)  
37aa 32 bd fb			ld (debug_mark),a  
37ad 3a bc 37			ld a, (.dmark+1)  
37b0 32 be fb			ld (debug_mark+1),a  
37b3 3a bd 37			ld a, (.dmark+2)  
37b6 32 bf fb			ld (debug_mark+2),a  
37b9 18 03			jr .pastdmark  
37bb ..			.dmark: db "CRT"  
37be f1			.pastdmark: pop af  
37bf			endm  
# End of macro DMARK
37bf						CALLMONITOR 
37bf cd d7 12			call break_point_state  
37c2				endm  
# End of macro CALLMONITOR
37c2					endif 
37c2			;		call storage_get_block_0 
37c2			 
37c2					; TODO pop hl 
37c2			 
37c2					;v5 FORTH_DSP_VALUE 
37c2					FORTH_DSP_VALUE 
37c2 cd e5 18			call macro_forth_dsp_value 
37c5				endm 
# End of macro FORTH_DSP_VALUE
37c5			 
37c5				if DEBUG_STORESE 
37c5					DMARK "CR1" 
37c5 f5				push af  
37c6 3a da 37			ld a, (.dmark)  
37c9 32 bd fb			ld (debug_mark),a  
37cc 3a db 37			ld a, (.dmark+1)  
37cf 32 be fb			ld (debug_mark+1),a  
37d2 3a dc 37			ld a, (.dmark+2)  
37d5 32 bf fb			ld (debug_mark+2),a  
37d8 18 03			jr .pastdmark  
37da ..			.dmark: db "CR1"  
37dd f1			.pastdmark: pop af  
37de			endm  
# End of macro DMARK
37de					CALLMONITOR 
37de cd d7 12			call break_point_state  
37e1				endm  
# End of macro CALLMONITOR
37e1				endif 
37e1			;		push hl 
37e1			;		FORTH_DSP_POP 
37e1			;		pop hl 
37e1			 
37e1			;		inc hl   ; move past the type marker 
37e1			 
37e1 cd f3 05				call storage_create 
37e4			 
37e4				if DEBUG_STORESE 
37e4					DMARK "CT1" 
37e4 f5				push af  
37e5 3a f9 37			ld a, (.dmark)  
37e8 32 bd fb			ld (debug_mark),a  
37eb 3a fa 37			ld a, (.dmark+1)  
37ee 32 be fb			ld (debug_mark+1),a  
37f1 3a fb 37			ld a, (.dmark+2)  
37f4 32 bf fb			ld (debug_mark+2),a  
37f7 18 03			jr .pastdmark  
37f9 ..			.dmark: db "CT1"  
37fc f1			.pastdmark: pop af  
37fd			endm  
# End of macro DMARK
37fd					CALLMONITOR 
37fd cd d7 12			call break_point_state  
3800				endm  
# End of macro CALLMONITOR
3800				endif 
3800			;		push hl 
3800					FORTH_DSP_POP 
3800 cd 7c 19			call macro_forth_dsp_pop 
3803				endm 
# End of macro FORTH_DSP_POP
3803			;		pop hl 
3803					; push file id to stack 
3803 cd 61 18				call forth_push_numhl 
3806			 
3806			 
3806			 
3806				       NEXTW 
3806 c3 36 1a			jp macro_next 
3809				endm 
# End of macro NEXTW
3809			 
3809			.APPEND: 
3809				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
3809 69				db WORD_SYS_CORE+85             
380a 9a 38			dw .SDEL            
380c 07				db 6 + 1 
380d .. 00			db "APPEND",0              
3814				endm 
# End of macro CWHEAD
3814			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | TO TEST 
3814			; | | e.g. 
3814			; | | Test CREATE      -> $01 
3814			; | | "A string to add to file" $01 APPEND 
3814			; | |  
3814			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
3814					if DEBUG_FORTH_WORDS_KEY 
3814						DMARK "APP" 
3814 f5				push af  
3815 3a 29 38			ld a, (.dmark)  
3818 32 bd fb			ld (debug_mark),a  
381b 3a 2a 38			ld a, (.dmark+1)  
381e 32 be fb			ld (debug_mark+1),a  
3821 3a 2b 38			ld a, (.dmark+2)  
3824 32 bf fb			ld (debug_mark+2),a  
3827 18 03			jr .pastdmark  
3829 ..			.dmark: db "APP"  
382c f1			.pastdmark: pop af  
382d			endm  
# End of macro DMARK
382d						CALLMONITOR 
382d cd d7 12			call break_point_state  
3830				endm  
# End of macro CALLMONITOR
3830					endif 
3830			 
3830					FORTH_DSP_VALUEHL 
3830 cd fc 18			call macro_dsp_valuehl 
3833				endm 
# End of macro FORTH_DSP_VALUEHL
3833 e5					push hl 	; save file id 
3834			 
3834				if DEBUG_STORESE 
3834					DMARK "AP1" 
3834 f5				push af  
3835 3a 49 38			ld a, (.dmark)  
3838 32 bd fb			ld (debug_mark),a  
383b 3a 4a 38			ld a, (.dmark+1)  
383e 32 be fb			ld (debug_mark+1),a  
3841 3a 4b 38			ld a, (.dmark+2)  
3844 32 bf fb			ld (debug_mark+2),a  
3847 18 03			jr .pastdmark  
3849 ..			.dmark: db "AP1"  
384c f1			.pastdmark: pop af  
384d			endm  
# End of macro DMARK
384d					CALLMONITOR 
384d cd d7 12			call break_point_state  
3850				endm  
# End of macro CALLMONITOR
3850				endif 
3850					FORTH_DSP_POP 
3850 cd 7c 19			call macro_forth_dsp_pop 
3853				endm 
# End of macro FORTH_DSP_POP
3853			 
3853					FORTH_DSP_VALUEHL 
3853 cd fc 18			call macro_dsp_valuehl 
3856				endm 
# End of macro FORTH_DSP_VALUEHL
3856					;v5 FORTH_DSP_VALUE 
3856 e5					push hl 	; save ptr to string to save 
3857			 
3857				if DEBUG_STORESE 
3857					DMARK "AP1" 
3857 f5				push af  
3858 3a 6c 38			ld a, (.dmark)  
385b 32 bd fb			ld (debug_mark),a  
385e 3a 6d 38			ld a, (.dmark+1)  
3861 32 be fb			ld (debug_mark+1),a  
3864 3a 6e 38			ld a, (.dmark+2)  
3867 32 bf fb			ld (debug_mark+2),a  
386a 18 03			jr .pastdmark  
386c ..			.dmark: db "AP1"  
386f f1			.pastdmark: pop af  
3870			endm  
# End of macro DMARK
3870					CALLMONITOR 
3870 cd d7 12			call break_point_state  
3873				endm  
# End of macro CALLMONITOR
3873				endif 
3873					FORTH_DSP_POP 
3873 cd 7c 19			call macro_forth_dsp_pop 
3876				endm 
# End of macro FORTH_DSP_POP
3876			 
3876 d1					pop de 
3877 e1					pop hl 
3878				if DEBUG_STORESE 
3878					DMARK "AP2" 
3878 f5				push af  
3879 3a 8d 38			ld a, (.dmark)  
387c 32 bd fb			ld (debug_mark),a  
387f 3a 8e 38			ld a, (.dmark+1)  
3882 32 be fb			ld (debug_mark+1),a  
3885 3a 8f 38			ld a, (.dmark+2)  
3888 32 bf fb			ld (debug_mark+2),a  
388b 18 03			jr .pastdmark  
388d ..			.dmark: db "AP2"  
3890 f1			.pastdmark: pop af  
3891			endm  
# End of macro DMARK
3891					CALLMONITOR 
3891 cd d7 12			call break_point_state  
3894				endm  
# End of macro CALLMONITOR
3894				endif 
3894					;inc de ; skip var type indicator 
3894			 
3894					; TODO how to append numerics???? 
3894			 
3894 cd cd 07				call storage_append		 
3897			 
3897				       NEXTW 
3897 c3 36 1a			jp macro_next 
389a				endm 
# End of macro NEXTW
389a			.SDEL: 
389a				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
389a 6a				db WORD_SYS_CORE+86             
389b e6 38			dw .OPEN            
389d 05				db 4 + 1 
389e .. 00			db "ERA",0              
38a2				endm 
# End of macro CWHEAD
38a2			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
38a2					FORTH_DSP_VALUEHL 
38a2 cd fc 18			call macro_dsp_valuehl 
38a5				endm 
# End of macro FORTH_DSP_VALUEHL
38a5			;		push hl 	; save file id 
38a5			 
38a5					if DEBUG_FORTH_WORDS_KEY 
38a5						DMARK "ERA" 
38a5 f5				push af  
38a6 3a ba 38			ld a, (.dmark)  
38a9 32 bd fb			ld (debug_mark),a  
38ac 3a bb 38			ld a, (.dmark+1)  
38af 32 be fb			ld (debug_mark+1),a  
38b2 3a bc 38			ld a, (.dmark+2)  
38b5 32 bf fb			ld (debug_mark+2),a  
38b8 18 03			jr .pastdmark  
38ba ..			.dmark: db "ERA"  
38bd f1			.pastdmark: pop af  
38be			endm  
# End of macro DMARK
38be						CALLMONITOR 
38be cd d7 12			call break_point_state  
38c1				endm  
# End of macro CALLMONITOR
38c1					endif 
38c1				if DEBUG_STORESE 
38c1					DMARK "ER1" 
38c1 f5				push af  
38c2 3a d6 38			ld a, (.dmark)  
38c5 32 bd fb			ld (debug_mark),a  
38c8 3a d7 38			ld a, (.dmark+1)  
38cb 32 be fb			ld (debug_mark+1),a  
38ce 3a d8 38			ld a, (.dmark+2)  
38d1 32 bf fb			ld (debug_mark+2),a  
38d4 18 03			jr .pastdmark  
38d6 ..			.dmark: db "ER1"  
38d9 f1			.pastdmark: pop af  
38da			endm  
# End of macro DMARK
38da					CALLMONITOR 
38da cd d7 12			call break_point_state  
38dd				endm  
# End of macro CALLMONITOR
38dd				endif 
38dd					FORTH_DSP_POP 
38dd cd 7c 19			call macro_forth_dsp_pop 
38e0				endm 
# End of macro FORTH_DSP_POP
38e0			 
38e0			;		pop hl 
38e0			 
38e0 cd 22 05				call storage_erase 
38e3				       NEXTW 
38e3 c3 36 1a			jp macro_next 
38e6				endm 
# End of macro NEXTW
38e6			 
38e6			.OPEN: 
38e6				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
38e6 6b				db WORD_SYS_CORE+87             
38e7 6d 39			dw .READ            
38e9 05				db 4 + 1 
38ea .. 00			db "OPEN",0              
38ef				endm 
# End of macro CWHEAD
38ef			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
38ef			; | | e.g. 
38ef			; | | $01 OPEN $01 DO $01 READ . LOOP 
38ef			 
38ef					if DEBUG_FORTH_WORDS_KEY 
38ef						DMARK "OPN" 
38ef f5				push af  
38f0 3a 04 39			ld a, (.dmark)  
38f3 32 bd fb			ld (debug_mark),a  
38f6 3a 05 39			ld a, (.dmark+1)  
38f9 32 be fb			ld (debug_mark+1),a  
38fc 3a 06 39			ld a, (.dmark+2)  
38ff 32 bf fb			ld (debug_mark+2),a  
3902 18 03			jr .pastdmark  
3904 ..			.dmark: db "OPN"  
3907 f1			.pastdmark: pop af  
3908			endm  
# End of macro DMARK
3908						CALLMONITOR 
3908 cd d7 12			call break_point_state  
390b				endm  
# End of macro CALLMONITOR
390b					endif 
390b					; TODO handle multiple file opens 
390b			 
390b 3e 01			       	ld a, 1 
390d 32 df f9				ld (store_openext), a 
3910			 
3910					; get max extents for this file 
3910				 
3910								 
3910					FORTH_DSP_VALUEHL 
3910 cd fc 18			call macro_dsp_valuehl 
3913				endm 
# End of macro FORTH_DSP_VALUEHL
3913			 
3913 65					ld h, l 
3914 2e 00				ld l, 0 
3916			 
3916				if DEBUG_STORESE 
3916					DMARK "OPN" 
3916 f5				push af  
3917 3a 2b 39			ld a, (.dmark)  
391a 32 bd fb			ld (debug_mark),a  
391d 3a 2c 39			ld a, (.dmark+1)  
3920 32 be fb			ld (debug_mark+1),a  
3923 3a 2d 39			ld a, (.dmark+2)  
3926 32 bf fb			ld (debug_mark+2),a  
3929 18 03			jr .pastdmark  
392b ..			.dmark: db "OPN"  
392e f1			.pastdmark: pop af  
392f			endm  
# End of macro DMARK
392f					CALLMONITOR 
392f cd d7 12			call break_point_state  
3932				endm  
# End of macro CALLMONITOR
3932				endif 
3932			;		push hl 
3932					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
3932 cd 7c 19			call macro_forth_dsp_pop 
3935				endm 
# End of macro FORTH_DSP_POP
3935			;		pop hl 
3935						 
3935 11 e8 f9				ld de, store_page      ; get block zero of file 
3938 cd 47 07				call storage_read 
393b			 
393b			 
393b 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
393e 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
3941					 
3941				if DEBUG_STORESE 
3941					DMARK "OPx" 
3941 f5				push af  
3942 3a 56 39			ld a, (.dmark)  
3945 32 bd fb			ld (debug_mark),a  
3948 3a 57 39			ld a, (.dmark+1)  
394b 32 be fb			ld (debug_mark+1),a  
394e 3a 58 39			ld a, (.dmark+2)  
3951 32 bf fb			ld (debug_mark+2),a  
3954 18 03			jr .pastdmark  
3956 ..			.dmark: db "OPx"  
3959 f1			.pastdmark: pop af  
395a			endm  
# End of macro DMARK
395a					CALLMONITOR 
395a cd d7 12			call break_point_state  
395d				endm  
# End of macro CALLMONITOR
395d				endif 
395d fe 00				cp 0 
395f 20 03				jr nz, .skipopeneof 
3961					; have opened an empty file 
3961					 
3961 32 df f9				ld (store_openext), a 
3964			 
3964			.skipopeneof: 
3964			 
3964 6f					ld l, a 
3965 26 00				ld h, 0 
3967 cd 61 18				call forth_push_numhl 
396a			 
396a			 
396a				       NEXTW 
396a c3 36 1a			jp macro_next 
396d				endm 
# End of macro NEXTW
396d			.READ: 
396d				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
396d 6c				db WORD_SYS_CORE+88             
396e b4 3a			dw .EOF            
3970 05				db 4 + 1 
3971 .. 00			db "READ",0              
3976				endm 
# End of macro CWHEAD
3976			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
3976			; | | e.g. 
3976			; | | $01 OPEN $01 DO $01 READ . LOOP 
3976			 
3976					if DEBUG_FORTH_WORDS_KEY 
3976						DMARK "REA" 
3976 f5				push af  
3977 3a 8b 39			ld a, (.dmark)  
397a 32 bd fb			ld (debug_mark),a  
397d 3a 8c 39			ld a, (.dmark+1)  
3980 32 be fb			ld (debug_mark+1),a  
3983 3a 8d 39			ld a, (.dmark+2)  
3986 32 bf fb			ld (debug_mark+2),a  
3989 18 03			jr .pastdmark  
398b ..			.dmark: db "REA"  
398e f1			.pastdmark: pop af  
398f			endm  
# End of macro DMARK
398f						CALLMONITOR 
398f cd d7 12			call break_point_state  
3992				endm  
# End of macro CALLMONITOR
3992					endif 
3992					; store_openext use it. If zero it is EOF 
3992			 
3992					; read block from current stream id 
3992					; if the block does not contain zero term keep reading blocks until zero found 
3992					; push the block to stack 
3992					; save the block id to stream 
3992			 
3992			 
3992					FORTH_DSP_VALUEHL 
3992 cd fc 18			call macro_dsp_valuehl 
3995				endm 
# End of macro FORTH_DSP_VALUEHL
3995			 
3995			;		push hl 
3995			 
3995				if DEBUG_STORESE 
3995					DMARK "REA" 
3995 f5				push af  
3996 3a aa 39			ld a, (.dmark)  
3999 32 bd fb			ld (debug_mark),a  
399c 3a ab 39			ld a, (.dmark+1)  
399f 32 be fb			ld (debug_mark+1),a  
39a2 3a ac 39			ld a, (.dmark+2)  
39a5 32 bf fb			ld (debug_mark+2),a  
39a8 18 03			jr .pastdmark  
39aa ..			.dmark: db "REA"  
39ad f1			.pastdmark: pop af  
39ae			endm  
# End of macro DMARK
39ae					CALLMONITOR 
39ae cd d7 12			call break_point_state  
39b1				endm  
# End of macro CALLMONITOR
39b1				endif 
39b1					FORTH_DSP_POP 
39b1 cd 7c 19			call macro_forth_dsp_pop 
39b4				endm 
# End of macro FORTH_DSP_POP
39b4			 
39b4			;		pop hl 
39b4				 
39b4 65					ld h,l 
39b5			 
39b5 3a df f9				ld a, (store_openext) 
39b8 6f					ld l, a 
39b9					 
39b9 fe 00				cp 0 
39bb ca 86 3a				jp z, .ateof     ; dont read past eof 
39be			 
39be			 
39be 11 e8 f9				ld de, store_page 
39c1				if DEBUG_STORESE 
39c1					DMARK "RE1" 
39c1 f5				push af  
39c2 3a d6 39			ld a, (.dmark)  
39c5 32 bd fb			ld (debug_mark),a  
39c8 3a d7 39			ld a, (.dmark+1)  
39cb 32 be fb			ld (debug_mark+1),a  
39ce 3a d8 39			ld a, (.dmark+2)  
39d1 32 bf fb			ld (debug_mark+2),a  
39d4 18 03			jr .pastdmark  
39d6 ..			.dmark: db "RE1"  
39d9 f1			.pastdmark: pop af  
39da			endm  
# End of macro DMARK
39da					CALLMONITOR 
39da cd d7 12			call break_point_state  
39dd				endm  
# End of macro CALLMONITOR
39dd				endif 
39dd cd 47 07				call storage_read 
39e0			 
39e0				if DEBUG_STORESE 
39e0					DMARK "RE2" 
39e0 f5				push af  
39e1 3a f5 39			ld a, (.dmark)  
39e4 32 bd fb			ld (debug_mark),a  
39e7 3a f6 39			ld a, (.dmark+1)  
39ea 32 be fb			ld (debug_mark+1),a  
39ed 3a f7 39			ld a, (.dmark+2)  
39f0 32 bf fb			ld (debug_mark+2),a  
39f3 18 03			jr .pastdmark  
39f5 ..			.dmark: db "RE2"  
39f8 f1			.pastdmark: pop af  
39f9			endm  
# End of macro DMARK
39f9					CALLMONITOR 
39f9 cd d7 12			call break_point_state  
39fc				endm  
# End of macro CALLMONITOR
39fc				endif 
39fc cd 3c 0b			call ishlzero 
39ff			;	ld a, l 
39ff			;	add h 
39ff			;	cp 0 
39ff ca 8c 3a			jp z, .readeof 
3a02			 
3a02				; not eof so hl should point to data to push to stack 
3a02			 
3a02				if DEBUG_STORESE 
3a02					DMARK "RE3" 
3a02 f5				push af  
3a03 3a 17 3a			ld a, (.dmark)  
3a06 32 bd fb			ld (debug_mark),a  
3a09 3a 18 3a			ld a, (.dmark+1)  
3a0c 32 be fb			ld (debug_mark+1),a  
3a0f 3a 19 3a			ld a, (.dmark+2)  
3a12 32 bf fb			ld (debug_mark+2),a  
3a15 18 03			jr .pastdmark  
3a17 ..			.dmark: db "RE3"  
3a1a f1			.pastdmark: pop af  
3a1b			endm  
# End of macro DMARK
3a1b					CALLMONITOR 
3a1b cd d7 12			call break_point_state  
3a1e				endm  
# End of macro CALLMONITOR
3a1e				endif 
3a1e cd 73 18			call forth_push_str 
3a21			 
3a21				if DEBUG_STORESE 
3a21					DMARK "RE4" 
3a21 f5				push af  
3a22 3a 36 3a			ld a, (.dmark)  
3a25 32 bd fb			ld (debug_mark),a  
3a28 3a 37 3a			ld a, (.dmark+1)  
3a2b 32 be fb			ld (debug_mark+1),a  
3a2e 3a 38 3a			ld a, (.dmark+2)  
3a31 32 bf fb			ld (debug_mark+2),a  
3a34 18 03			jr .pastdmark  
3a36 ..			.dmark: db "RE4"  
3a39 f1			.pastdmark: pop af  
3a3a			endm  
# End of macro DMARK
3a3a					CALLMONITOR 
3a3a cd d7 12			call break_point_state  
3a3d				endm  
# End of macro CALLMONITOR
3a3d				endif 
3a3d				; get next block  or mark as eof 
3a3d			 
3a3d 3a de f9			ld a, (store_openmaxext)   ; get our limit 
3a40 4f				ld c, a	 
3a41 3a df f9			ld a, (store_openext) 
3a44			 
3a44				if DEBUG_STORESE 
3a44					DMARK "RE5" 
3a44 f5				push af  
3a45 3a 59 3a			ld a, (.dmark)  
3a48 32 bd fb			ld (debug_mark),a  
3a4b 3a 5a 3a			ld a, (.dmark+1)  
3a4e 32 be fb			ld (debug_mark+1),a  
3a51 3a 5b 3a			ld a, (.dmark+2)  
3a54 32 bf fb			ld (debug_mark+2),a  
3a57 18 03			jr .pastdmark  
3a59 ..			.dmark: db "RE5"  
3a5c f1			.pastdmark: pop af  
3a5d			endm  
# End of macro DMARK
3a5d					CALLMONITOR 
3a5d cd d7 12			call break_point_state  
3a60				endm  
# End of macro CALLMONITOR
3a60				endif 
3a60 b9				cp c 
3a61 28 29			jr z, .readeof     ; at last extent 
3a63			 
3a63 3c					inc a 
3a64 32 df f9				ld (store_openext), a 
3a67			 
3a67				if DEBUG_STORESE 
3a67					DMARK "RE6" 
3a67 f5				push af  
3a68 3a 7c 3a			ld a, (.dmark)  
3a6b 32 bd fb			ld (debug_mark),a  
3a6e 3a 7d 3a			ld a, (.dmark+1)  
3a71 32 be fb			ld (debug_mark+1),a  
3a74 3a 7e 3a			ld a, (.dmark+2)  
3a77 32 bf fb			ld (debug_mark+2),a  
3a7a 18 03			jr .pastdmark  
3a7c ..			.dmark: db "RE6"  
3a7f f1			.pastdmark: pop af  
3a80			endm  
# End of macro DMARK
3a80					CALLMONITOR 
3a80 cd d7 12			call break_point_state  
3a83				endm  
# End of macro CALLMONITOR
3a83				endif 
3a83			 
3a83			 
3a83				       NEXTW 
3a83 c3 36 1a			jp macro_next 
3a86				endm 
# End of macro NEXTW
3a86			.ateof: 
3a86 21 b0 3a				ld hl, .showeof 
3a89 cd 73 18				call forth_push_str 
3a8c 3e 00		.readeof:	ld a, 0 
3a8e 32 df f9				ld (store_openext), a 
3a91			 
3a91					 
3a91				if DEBUG_STORESE 
3a91					DMARK "REF" 
3a91 f5				push af  
3a92 3a a6 3a			ld a, (.dmark)  
3a95 32 bd fb			ld (debug_mark),a  
3a98 3a a7 3a			ld a, (.dmark+1)  
3a9b 32 be fb			ld (debug_mark+1),a  
3a9e 3a a8 3a			ld a, (.dmark+2)  
3aa1 32 bf fb			ld (debug_mark+2),a  
3aa4 18 03			jr .pastdmark  
3aa6 ..			.dmark: db "REF"  
3aa9 f1			.pastdmark: pop af  
3aaa			endm  
# End of macro DMARK
3aaa					CALLMONITOR 
3aaa cd d7 12			call break_point_state  
3aad				endm  
# End of macro CALLMONITOR
3aad				endif 
3aad				       NEXTW 
3aad c3 36 1a			jp macro_next 
3ab0				endm 
# End of macro NEXTW
3ab0			 
3ab0 .. 00		.showeof:   db "eof", 0 
3ab4			 
3ab4			 
3ab4			.EOF: 
3ab4				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
3ab4 6d				db WORD_SYS_CORE+89             
3ab5 f5 3a			dw .FORMAT            
3ab7 04				db 3 + 1 
3ab8 .. 00			db "EOF",0              
3abc				endm 
# End of macro CWHEAD
3abc			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
3abc			; | | e.g. 
3abc			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
3abc					; TODO if current block id for stream is zero then push true else false 
3abc			 
3abc					if DEBUG_FORTH_WORDS_KEY 
3abc						DMARK "EOF" 
3abc f5				push af  
3abd 3a d1 3a			ld a, (.dmark)  
3ac0 32 bd fb			ld (debug_mark),a  
3ac3 3a d2 3a			ld a, (.dmark+1)  
3ac6 32 be fb			ld (debug_mark+1),a  
3ac9 3a d3 3a			ld a, (.dmark+2)  
3acc 32 bf fb			ld (debug_mark+2),a  
3acf 18 03			jr .pastdmark  
3ad1 ..			.dmark: db "EOF"  
3ad4 f1			.pastdmark: pop af  
3ad5			endm  
# End of macro DMARK
3ad5						CALLMONITOR 
3ad5 cd d7 12			call break_point_state  
3ad8				endm  
# End of macro CALLMONITOR
3ad8					endif 
3ad8			 
3ad8					; TODO handlue multiple file streams 
3ad8			 
3ad8					FORTH_DSP_POP     ; for now just get rid of stream id 
3ad8 cd 7c 19			call macro_forth_dsp_pop 
3adb				endm 
# End of macro FORTH_DSP_POP
3adb			 
3adb 2e 01				ld l, 1 
3add 3a de f9				ld a, (store_openmaxext) 
3ae0 fe 00				cp 0 
3ae2 28 09				jr  z, .eofdone   ; empty file 
3ae4 3a df f9				ld a, (store_openext) 
3ae7 fe 00				cp 0 
3ae9 28 02				jr  z, .eofdone 
3aeb 2e 00				ld l, 0 
3aed 26 00		.eofdone:	ld h, 0 
3aef cd 61 18				call forth_push_numhl 
3af2			 
3af2			 
3af2				       NEXTW 
3af2 c3 36 1a			jp macro_next 
3af5				endm 
# End of macro NEXTW
3af5			 
3af5			.FORMAT: 
3af5				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
3af5 6d				db WORD_SYS_CORE+89             
3af6 46 3b			dw .LABEL            
3af8 07				db 6 + 1 
3af9 .. 00			db "FORMAT",0              
3b00				endm 
# End of macro CWHEAD
3b00			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
3b00					; TODO if current block id for stream is zero then push true else false 
3b00				 
3b00				if DEBUG_STORESE 
3b00					DMARK "FOR" 
3b00 f5				push af  
3b01 3a 15 3b			ld a, (.dmark)  
3b04 32 bd fb			ld (debug_mark),a  
3b07 3a 16 3b			ld a, (.dmark+1)  
3b0a 32 be fb			ld (debug_mark+1),a  
3b0d 3a 17 3b			ld a, (.dmark+2)  
3b10 32 bf fb			ld (debug_mark+2),a  
3b13 18 03			jr .pastdmark  
3b15 ..			.dmark: db "FOR"  
3b18 f1			.pastdmark: pop af  
3b19			endm  
# End of macro DMARK
3b19					CALLMONITOR 
3b19 cd d7 12			call break_point_state  
3b1c				endm  
# End of macro CALLMONITOR
3b1c				endif 
3b1c					; Wipes the bank check flags to cause a reformat on next block 0 read 
3b1c			 
3b1c 21 01 00				ld hl, 1 
3b1f 3e 00				ld a, 0 
3b21 cd e7 01				call se_writebyte 
3b24			 
3b24				if DEBUG_STORESE 
3b24					DMARK "FO0" 
3b24 f5				push af  
3b25 3a 39 3b			ld a, (.dmark)  
3b28 32 bd fb			ld (debug_mark),a  
3b2b 3a 3a 3b			ld a, (.dmark+1)  
3b2e 32 be fb			ld (debug_mark+1),a  
3b31 3a 3b 3b			ld a, (.dmark+2)  
3b34 32 bf fb			ld (debug_mark+2),a  
3b37 18 03			jr .pastdmark  
3b39 ..			.dmark: db "FO0"  
3b3c f1			.pastdmark: pop af  
3b3d			endm  
# End of macro DMARK
3b3d					CALLMONITOR 
3b3d cd d7 12			call break_point_state  
3b40				endm  
# End of macro CALLMONITOR
3b40				endif 
3b40					; force bank init 
3b40			 
3b40 cd 9e 03				call storage_get_block_0 
3b43					 
3b43				       NEXTW 
3b43 c3 36 1a			jp macro_next 
3b46				endm 
# End of macro NEXTW
3b46			.LABEL: 
3b46				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
3b46 6d				db WORD_SYS_CORE+89             
3b47 94 3b			dw .STOREPAGE            
3b49 06				db 5 + 1 
3b4a .. 00			db "LABEL",0              
3b50				endm 
# End of macro CWHEAD
3b50			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
3b50					; TODO test to see if bank is selected 
3b50				 
3b50					if DEBUG_FORTH_WORDS_KEY 
3b50						DMARK "LBL" 
3b50 f5				push af  
3b51 3a 65 3b			ld a, (.dmark)  
3b54 32 bd fb			ld (debug_mark),a  
3b57 3a 66 3b			ld a, (.dmark+1)  
3b5a 32 be fb			ld (debug_mark+1),a  
3b5d 3a 67 3b			ld a, (.dmark+2)  
3b60 32 bf fb			ld (debug_mark+2),a  
3b63 18 03			jr .pastdmark  
3b65 ..			.dmark: db "LBL"  
3b68 f1			.pastdmark: pop af  
3b69			endm  
# End of macro DMARK
3b69						CALLMONITOR 
3b69 cd d7 12			call break_point_state  
3b6c				endm  
# End of macro CALLMONITOR
3b6c					endif 
3b6c			;	if DEBUG_STORESE 
3b6c			;		DMARK "LBL" 
3b6c			;		CALLMONITOR 
3b6c			;	endif 
3b6c					FORTH_DSP_VALUEHL 
3b6c cd fc 18			call macro_dsp_valuehl 
3b6f				endm 
# End of macro FORTH_DSP_VALUEHL
3b6f					;v5FORTH_DSP_VALUE 
3b6f					 
3b6f			;		push hl 
3b6f					FORTH_DSP_POP 
3b6f cd 7c 19			call macro_forth_dsp_pop 
3b72				endm 
# End of macro FORTH_DSP_POP
3b72			;		pop hl 
3b72			 
3b72			;v5		inc hl   ; move past the type marker 
3b72			 
3b72				if DEBUG_STORESE 
3b72					DMARK "LBl" 
3b72 f5				push af  
3b73 3a 87 3b			ld a, (.dmark)  
3b76 32 bd fb			ld (debug_mark),a  
3b79 3a 88 3b			ld a, (.dmark+1)  
3b7c 32 be fb			ld (debug_mark+1),a  
3b7f 3a 89 3b			ld a, (.dmark+2)  
3b82 32 bf fb			ld (debug_mark+2),a  
3b85 18 03			jr .pastdmark  
3b87 ..			.dmark: db "LBl"  
3b8a f1			.pastdmark: pop af  
3b8b			endm  
# End of macro DMARK
3b8b					CALLMONITOR 
3b8b cd d7 12			call break_point_state  
3b8e				endm  
# End of macro CALLMONITOR
3b8e				endif 
3b8e cd b7 04				call storage_label 
3b91			 
3b91				       NEXTW 
3b91 c3 36 1a			jp macro_next 
3b94				endm 
# End of macro NEXTW
3b94			.STOREPAGE: 
3b94				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
3b94 6d				db WORD_SYS_CORE+89             
3b95 c7 3b			dw .LABELS            
3b97 0a				db 9 + 1 
3b98 .. 00			db "STOREPAGE",0              
3ba2				endm 
# End of macro CWHEAD
3ba2			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
3ba2					; TODO test to see if bank is selected 
3ba2				 
3ba2					if DEBUG_FORTH_WORDS_KEY 
3ba2						DMARK "STP" 
3ba2 f5				push af  
3ba3 3a b7 3b			ld a, (.dmark)  
3ba6 32 bd fb			ld (debug_mark),a  
3ba9 3a b8 3b			ld a, (.dmark+1)  
3bac 32 be fb			ld (debug_mark+1),a  
3baf 3a b9 3b			ld a, (.dmark+2)  
3bb2 32 bf fb			ld (debug_mark+2),a  
3bb5 18 03			jr .pastdmark  
3bb7 ..			.dmark: db "STP"  
3bba f1			.pastdmark: pop af  
3bbb			endm  
# End of macro DMARK
3bbb						CALLMONITOR 
3bbb cd d7 12			call break_point_state  
3bbe				endm  
# End of macro CALLMONITOR
3bbe					endif 
3bbe			;	if DEBUG_STORESE 
3bbe			;		DMARK "STP" 
3bbe			;		CALLMONITOR 
3bbe			;	endif 
3bbe			 
3bbe 21 e8 f9			ld hl, store_page 
3bc1 cd 61 18			call forth_push_numhl 
3bc4			 
3bc4			 
3bc4				       NEXTW 
3bc4 c3 36 1a			jp macro_next 
3bc7				endm 
# End of macro NEXTW
3bc7			.LABELS: 
3bc7				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
3bc7 6d				db WORD_SYS_CORE+89             
3bc8 51 3c			dw .ENDSTORAGE            
3bca 07				db 6 + 1 
3bcb .. 00			db "LABELS",0              
3bd2				endm 
# End of macro CWHEAD
3bd2			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
3bd2					;  
3bd2			 
3bd2					; save the current device selected to restore afterwards 
3bd2				 
3bd2 3a e2 f9				ld a, (spi_device) 
3bd5 f5					push af 
3bd6			 
3bd6			 
3bd6					; run through each of the banks 
3bd6			 
3bd6 21 01 00				ld hl, 1 
3bd9 cd 61 18				call forth_push_numhl 
3bdc 3e ff				ld a, SPI_CE_HIGH 
3bde cb 87				res SPI_CE0, a 
3be0 32 e2 f9				ld (spi_device), a 
3be3 cd 9e 03				call storage_get_block_0 
3be6 21 eb f9				ld hl, store_page+3 
3be9 cd 73 18				call forth_push_str 
3bec			 
3bec					 
3bec 21 02 00				ld hl, 2 
3bef cd 61 18				call forth_push_numhl 
3bf2 3e ff				ld a, SPI_CE_HIGH 
3bf4 cb 8f				res SPI_CE1, a 
3bf6 32 e2 f9				ld (spi_device), a 
3bf9 cd 9e 03				call storage_get_block_0 
3bfc 21 eb f9				ld hl, store_page+3 
3bff cd 73 18				call forth_push_str 
3c02			 
3c02					 
3c02 21 03 00				ld hl, 3 
3c05 cd 61 18				call forth_push_numhl 
3c08 3e ff				ld a, SPI_CE_HIGH 
3c0a cb 97				res SPI_CE2, a 
3c0c 32 e2 f9				ld (spi_device), a 
3c0f cd 9e 03				call storage_get_block_0 
3c12 21 eb f9				ld hl, store_page+3 
3c15 cd 73 18				call forth_push_str 
3c18			 
3c18			 
3c18 21 04 00				ld hl, 4 
3c1b cd 61 18				call forth_push_numhl 
3c1e 3e ff				ld a, SPI_CE_HIGH 
3c20 cb 9f				res SPI_CE3, a 
3c22 32 e2 f9				ld (spi_device), a 
3c25 cd 9e 03				call storage_get_block_0 
3c28 21 eb f9				ld hl, store_page+3 
3c2b cd 73 18				call forth_push_str 
3c2e			 
3c2e					 
3c2e			 
3c2e 21 05 00				ld hl, 5 
3c31 cd 61 18				call forth_push_numhl 
3c34 3e ff				ld a, SPI_CE_HIGH 
3c36 cb a7				res SPI_CE4, a 
3c38 32 e2 f9				ld (spi_device), a 
3c3b cd 9e 03				call storage_get_block_0 
3c3e 21 eb f9				ld hl, store_page+3 
3c41 cd 73 18				call forth_push_str 
3c44			 
3c44					 
3c44					; push fixed count of storage devices (on board) for now 
3c44			 
3c44 21 05 00				ld hl, 5 
3c47 cd 61 18				call forth_push_numhl 
3c4a			 
3c4a					; restore selected device  
3c4a				 
3c4a f1					pop af 
3c4b 32 e2 f9				ld (spi_device), a 
3c4e			 
3c4e				       NEXTW 
3c4e c3 36 1a			jp macro_next 
3c51				endm 
# End of macro NEXTW
3c51			 
3c51			.ENDSTORAGE: 
3c51			; eof 
# End of file forth_words_storage.asm
3c51			endif 
3c51				include "forth_words_device.asm" 
3c51			; Device related words 
3c51			 
3c51			; | ## Device Words 
3c51			 
3c51			if SOUND_ENABLE 
3c51			.NOTE: 
3c51				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
3c51			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
3c51					if DEBUG_FORTH_WORDS_KEY 
3c51						DMARK "NTE" 
3c51						CALLMONITOR 
3c51					endif 
3c51			 
3c51				 
3c51			 
3c51					NEXTW 
3c51			.AFTERSOUND: 
3c51			endif 
3c51			 
3c51			 
3c51			USE_GPIO: equ 0 
3c51			 
3c51			if USE_GPIO 
3c51			.GP1: 
3c51				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
3c51			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
3c51					NEXTW 
3c51			.GP2: 
3c51				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
3c51			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
3c51			 
3c51					NEXTW 
3c51			 
3c51			.GP3: 
3c51				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
3c51			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
3c51			 
3c51					NEXTW 
3c51			 
3c51			.GP4: 
3c51				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
3c51			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
3c51			 
3c51					NEXTW 
3c51			.SIN: 
3c51			 
3c51			 
3c51			endif 
3c51			 
3c51			 
3c51				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
3c51 33				db WORD_SYS_CORE+31             
3c52 86 3c			dw .SOUT            
3c54 03				db 2 + 1 
3c55 .. 00			db "IN",0              
3c58				endm 
# End of macro CWHEAD
3c58			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
3c58					if DEBUG_FORTH_WORDS_KEY 
3c58						DMARK "IN." 
3c58 f5				push af  
3c59 3a 6d 3c			ld a, (.dmark)  
3c5c 32 bd fb			ld (debug_mark),a  
3c5f 3a 6e 3c			ld a, (.dmark+1)  
3c62 32 be fb			ld (debug_mark+1),a  
3c65 3a 6f 3c			ld a, (.dmark+2)  
3c68 32 bf fb			ld (debug_mark+2),a  
3c6b 18 03			jr .pastdmark  
3c6d ..			.dmark: db "IN."  
3c70 f1			.pastdmark: pop af  
3c71			endm  
# End of macro DMARK
3c71						CALLMONITOR 
3c71 cd d7 12			call break_point_state  
3c74				endm  
# End of macro CALLMONITOR
3c74					endif 
3c74					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c74 cd fc 18			call macro_dsp_valuehl 
3c77				endm 
# End of macro FORTH_DSP_VALUEHL
3c77			 
3c77 e5					push hl 
3c78			 
3c78					; destroy value TOS 
3c78			 
3c78					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c78 cd 7c 19			call macro_forth_dsp_pop 
3c7b				endm 
# End of macro FORTH_DSP_POP
3c7b			 
3c7b					; one value on hl get other one back 
3c7b			 
3c7b c1					pop bc 
3c7c			 
3c7c					; do the sub 
3c7c			;		ex de, hl 
3c7c			 
3c7c ed 68				in l,(c) 
3c7e			 
3c7e					; save it 
3c7e			 
3c7e 26 00				ld h,0 
3c80			 
3c80					; TODO push value back onto stack for another op etc 
3c80			 
3c80 cd 61 18				call forth_push_numhl 
3c83					NEXTW 
3c83 c3 36 1a			jp macro_next 
3c86				endm 
# End of macro NEXTW
3c86			.SOUT: 
3c86				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
3c86 34				db WORD_SYS_CORE+32             
3c87 bd 3c			dw .SPIO            
3c89 04				db 3 + 1 
3c8a .. 00			db "OUT",0              
3c8e				endm 
# End of macro CWHEAD
3c8e			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
3c8e					if DEBUG_FORTH_WORDS_KEY 
3c8e						DMARK "OUT" 
3c8e f5				push af  
3c8f 3a a3 3c			ld a, (.dmark)  
3c92 32 bd fb			ld (debug_mark),a  
3c95 3a a4 3c			ld a, (.dmark+1)  
3c98 32 be fb			ld (debug_mark+1),a  
3c9b 3a a5 3c			ld a, (.dmark+2)  
3c9e 32 bf fb			ld (debug_mark+2),a  
3ca1 18 03			jr .pastdmark  
3ca3 ..			.dmark: db "OUT"  
3ca6 f1			.pastdmark: pop af  
3ca7			endm  
# End of macro DMARK
3ca7						CALLMONITOR 
3ca7 cd d7 12			call break_point_state  
3caa				endm  
# End of macro CALLMONITOR
3caa					endif 
3caa			 
3caa					; get port 
3caa			 
3caa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3caa cd fc 18			call macro_dsp_valuehl 
3cad				endm 
# End of macro FORTH_DSP_VALUEHL
3cad			 
3cad e5					push hl 
3cae			 
3cae					; destroy value TOS 
3cae			 
3cae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cae cd 7c 19			call macro_forth_dsp_pop 
3cb1				endm 
# End of macro FORTH_DSP_POP
3cb1			 
3cb1					; get byte to send 
3cb1			 
3cb1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cb1 cd fc 18			call macro_dsp_valuehl 
3cb4				endm 
# End of macro FORTH_DSP_VALUEHL
3cb4			 
3cb4			;		push hl 
3cb4			 
3cb4					; destroy value TOS 
3cb4			 
3cb4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cb4 cd 7c 19			call macro_forth_dsp_pop 
3cb7				endm 
# End of macro FORTH_DSP_POP
3cb7			 
3cb7					; one value on hl get other one back 
3cb7			 
3cb7			;		pop hl 
3cb7			 
3cb7 c1					pop bc 
3cb8			 
3cb8					if DEBUG_FORTH_WORDS 
3cb8						DMARK "OUT" 
3cb8						CALLMONITOR 
3cb8					endif 
3cb8			 
3cb8 ed 69				out (c), l 
3cba			 
3cba					NEXTW 
3cba c3 36 1a			jp macro_next 
3cbd				endm 
# End of macro NEXTW
3cbd			 
3cbd			 
3cbd			.SPIO: 
3cbd			 
3cbd			if STORAGE_SE 
3cbd				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
3cbd 51				db WORD_SYS_CORE+61             
3cbe ce 3c			dw .SPICEH            
3cc0 07				db 6 + 1 
3cc1 .. 00			db "SPICEL",0              
3cc8				endm 
# End of macro CWHEAD
3cc8			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
3cc8			 
3cc8 cd 95 01				call spi_ce_low 
3ccb			    NEXTW 
3ccb c3 36 1a			jp macro_next 
3cce				endm 
# End of macro NEXTW
3cce			 
3cce			.SPICEH: 
3cce				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
3cce 51				db WORD_SYS_CORE+61             
3ccf df 3c			dw .SPIOb            
3cd1 07				db 6 + 1 
3cd2 .. 00			db "SPICEH",0              
3cd9				endm 
# End of macro CWHEAD
3cd9			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
3cd9			 
3cd9 cd 84 01				call spi_ce_high 
3cdc			    NEXTW 
3cdc c3 36 1a			jp macro_next 
3cdf				endm 
# End of macro NEXTW
3cdf			 
3cdf			 
3cdf			.SPIOb: 
3cdf			 
3cdf				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
3cdf 51				db WORD_SYS_CORE+61             
3ce0 f5 3c			dw .SPII            
3ce2 05				db 4 + 1 
3ce3 .. 00			db "SPIO",0              
3ce8				endm 
# End of macro CWHEAD
3ce8			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
3ce8			 
3ce8					; get port 
3ce8			 
3ce8			 
3ce8					; get byte to send 
3ce8			 
3ce8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ce8 cd fc 18			call macro_dsp_valuehl 
3ceb				endm 
# End of macro FORTH_DSP_VALUEHL
3ceb			 
3ceb			;		push hl    ; u1  
3ceb			 
3ceb					; destroy value TOS 
3ceb			 
3ceb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ceb cd 7c 19			call macro_forth_dsp_pop 
3cee				endm 
# End of macro FORTH_DSP_POP
3cee			 
3cee					; one value on hl get other one back 
3cee			 
3cee			;		pop hl   ; u2 - addr 
3cee			 
3cee					; TODO Send SPI byte 
3cee			 
3cee 7d					ld a, l 
3cef cd b9 00				call spi_send_byte 
3cf2			 
3cf2					NEXTW 
3cf2 c3 36 1a			jp macro_next 
3cf5				endm 
# End of macro NEXTW
3cf5			 
3cf5			.SPII: 
3cf5				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
3cf5 52				db WORD_SYS_CORE+62             
3cf6 0a 3d			dw .SESEL            
3cf8 06				db 5 + 1 
3cf9 .. 00			db "SPII",0              
3cfe				endm 
# End of macro CWHEAD
3cfe			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
3cfe			 
3cfe					; TODO Get SPI byte 
3cfe			 
3cfe cd da 00				call spi_read_byte 
3d01			 
3d01 26 00				ld h, 0 
3d03 6f					ld l, a 
3d04 cd 61 18				call forth_push_numhl 
3d07			 
3d07					NEXTW 
3d07 c3 36 1a			jp macro_next 
3d0a				endm 
# End of macro NEXTW
3d0a			 
3d0a			 
3d0a			 
3d0a			.SESEL: 
3d0a				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
3d0a 66				db WORD_SYS_CORE+82             
3d0b 66 3d			dw .CARTDEV            
3d0d 05				db 4 + 1 
3d0e .. 00			db "BANK",0              
3d13				endm 
# End of macro CWHEAD
3d13			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
3d13					if DEBUG_FORTH_WORDS_KEY 
3d13						DMARK "BNK" 
3d13 f5				push af  
3d14 3a 28 3d			ld a, (.dmark)  
3d17 32 bd fb			ld (debug_mark),a  
3d1a 3a 29 3d			ld a, (.dmark+1)  
3d1d 32 be fb			ld (debug_mark+1),a  
3d20 3a 2a 3d			ld a, (.dmark+2)  
3d23 32 bf fb			ld (debug_mark+2),a  
3d26 18 03			jr .pastdmark  
3d28 ..			.dmark: db "BNK"  
3d2b f1			.pastdmark: pop af  
3d2c			endm  
# End of macro DMARK
3d2c						CALLMONITOR 
3d2c cd d7 12			call break_point_state  
3d2f				endm  
# End of macro CALLMONITOR
3d2f					endif 
3d2f			 
3d2f 3e ff				ld a, 255 
3d31 32 e5 f9				ld (spi_cartdev), a 
3d34			 
3d34					; get bank 
3d34			 
3d34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d34 cd fc 18			call macro_dsp_valuehl 
3d37				endm 
# End of macro FORTH_DSP_VALUEHL
3d37			 
3d37			;		push hl 
3d37			 
3d37					; destroy value TOS 
3d37			 
3d37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d37 cd 7c 19			call macro_forth_dsp_pop 
3d3a				endm 
# End of macro FORTH_DSP_POP
3d3a			 
3d3a					; one value on hl get other one back 
3d3a			 
3d3a			;		pop hl 
3d3a			 
3d3a			 
3d3a 0e ff				ld c, SPI_CE_HIGH 
3d3c			 
3d3c 7d					ld a, l 
3d3d			 
3d3d					if DEBUG_FORTH_WORDS 
3d3d						DMARK "BNK" 
3d3d						CALLMONITOR 
3d3d					endif 
3d3d			 
3d3d					; active low 
3d3d			 
3d3d fe 00				cp 0 
3d3f 28 1e				jr z, .bset 
3d41 fe 01				cp 1 
3d43 20 02				jr nz, .b2 
3d45 cb 81				res 0, c 
3d47 fe 02		.b2:		cp 2 
3d49 20 02				jr nz, .b3 
3d4b cb 89				res 1, c 
3d4d fe 03		.b3:		cp 3 
3d4f 20 02				jr nz, .b4 
3d51 cb 91				res 2, c 
3d53 fe 04		.b4:		cp 4 
3d55 20 02				jr nz, .b5 
3d57 cb 99				res 3, c 
3d59 fe 05		.b5:		cp 5 
3d5b 20 02				jr nz, .bset 
3d5d cb a1				res 4, c 
3d5f			 
3d5f			.bset: 
3d5f 79					ld a, c 
3d60 32 e2 f9				ld (spi_device),a 
3d63					if DEBUG_FORTH_WORDS 
3d63						DMARK "BN2" 
3d63						CALLMONITOR 
3d63					endif 
3d63			 
3d63					NEXTW 
3d63 c3 36 1a			jp macro_next 
3d66				endm 
# End of macro NEXTW
3d66			 
3d66			.CARTDEV: 
3d66				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
3d66 66				db WORD_SYS_CORE+82             
3d67 d7 3d			dw .ENDDEVICE            
3d69 08				db 7 + 1 
3d6a .. 00			db "CARTDEV",0              
3d72				endm 
# End of macro CWHEAD
3d72			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
3d72					if DEBUG_FORTH_WORDS_KEY 
3d72						DMARK "CDV" 
3d72 f5				push af  
3d73 3a 87 3d			ld a, (.dmark)  
3d76 32 bd fb			ld (debug_mark),a  
3d79 3a 88 3d			ld a, (.dmark+1)  
3d7c 32 be fb			ld (debug_mark+1),a  
3d7f 3a 89 3d			ld a, (.dmark+2)  
3d82 32 bf fb			ld (debug_mark+2),a  
3d85 18 03			jr .pastdmark  
3d87 ..			.dmark: db "CDV"  
3d8a f1			.pastdmark: pop af  
3d8b			endm  
# End of macro DMARK
3d8b						CALLMONITOR 
3d8b cd d7 12			call break_point_state  
3d8e				endm  
# End of macro CALLMONITOR
3d8e					endif 
3d8e			 
3d8e					; disable se storage bank selection 
3d8e			 
3d8e 3e ff				ld a, SPI_CE_HIGH		; ce high 
3d90 32 e2 f9				ld (spi_device), a 
3d93			 
3d93					; get bank 
3d93			 
3d93					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d93 cd fc 18			call macro_dsp_valuehl 
3d96				endm 
# End of macro FORTH_DSP_VALUEHL
3d96			 
3d96			;		push hl 
3d96			 
3d96					; destroy value TOS 
3d96			 
3d96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d96 cd 7c 19			call macro_forth_dsp_pop 
3d99				endm 
# End of macro FORTH_DSP_POP
3d99			 
3d99					; one value on hl get other one back 
3d99			 
3d99			;		pop hl 
3d99			 
3d99					; active low 
3d99			 
3d99 0e ff				ld c, 255 
3d9b			 
3d9b 7d					ld a, l 
3d9c					if DEBUG_FORTH_WORDS 
3d9c						DMARK "CDV" 
3d9c						CALLMONITOR 
3d9c					endif 
3d9c fe 00				cp 0 
3d9e 28 30				jr z, .cset 
3da0 fe 01				cp 1 
3da2 20 02				jr nz, .c2 
3da4 cb 81				res 0, c 
3da6 fe 02		.c2:		cp 2 
3da8 20 02				jr nz, .c3 
3daa cb 89				res 1, c 
3dac fe 03		.c3:		cp 3 
3dae 20 02				jr nz, .c4 
3db0 cb 91				res 2, c 
3db2 fe 04		.c4:		cp 4 
3db4 20 02				jr nz, .c5 
3db6 cb 99				res 3, c 
3db8 fe 05		.c5:		cp 5 
3dba 20 02				jr nz, .c6 
3dbc cb a1				res 4, c 
3dbe fe 06		.c6:		cp 6 
3dc0 20 02				jr nz, .c7 
3dc2 cb a9				res 5, c 
3dc4 fe 07		.c7:		cp 7 
3dc6 20 02				jr nz, .c8 
3dc8 cb b1				res 6, c 
3dca fe 08		.c8:		cp 8 
3dcc 20 02				jr nz, .cset 
3dce cb b9				res 7, c 
3dd0 79			.cset:		ld a, c 
3dd1 32 e5 f9				ld (spi_cartdev),a 
3dd4			 
3dd4					if DEBUG_FORTH_WORDS 
3dd4						DMARK "CD2" 
3dd4						CALLMONITOR 
3dd4					endif 
3dd4					NEXTW 
3dd4 c3 36 1a			jp macro_next 
3dd7				endm 
# End of macro NEXTW
3dd7			endif 
3dd7			 
3dd7			.ENDDEVICE: 
3dd7			; eof 
3dd7			 
# End of file forth_words_device.asm
3dd7			 
3dd7			; var handler 
3dd7			 
3dd7			 
3dd7			.VARS: 
3dd7				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
3dd7 78				db WORD_SYS_CORE+100             
3dd8 ef 3d			dw .V0Q            
3dda 04				db 3 + 1 
3ddb .. 00			db "V0!",0              
3ddf				endm 
# End of macro CWHEAD
3ddf			;| V0! ( u1 -- )  Store value to v0  | DONE 
3ddf			 
3ddf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ddf cd fc 18			call macro_dsp_valuehl 
3de2				endm 
# End of macro FORTH_DSP_VALUEHL
3de2			 
3de2 11 ab f9				ld de, cli_var_array 
3de5			 
3de5 eb					ex de, hl 
3de6 73					ld (hl), e 
3de7 23					inc hl 
3de8 72					ld (hl), d 
3de9			 
3de9					; destroy value TOS 
3de9			 
3de9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de9 cd 7c 19			call macro_forth_dsp_pop 
3dec				endm 
# End of macro FORTH_DSP_POP
3dec			 
3dec				       NEXTW 
3dec c3 36 1a			jp macro_next 
3def				endm 
# End of macro NEXTW
3def			.V0Q: 
3def				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
3def 79				db WORD_SYS_CORE+101             
3df0 00 3e			dw .V1S            
3df2 04				db 3 + 1 
3df3 .. 00			db "V0@",0              
3df7				endm 
# End of macro CWHEAD
3df7			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
3df7 2a ab f9				ld hl, (cli_var_array) 
3dfa cd 61 18				call forth_push_numhl 
3dfd			 
3dfd				       NEXTW 
3dfd c3 36 1a			jp macro_next 
3e00				endm 
# End of macro NEXTW
3e00			.V1S: 
3e00				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
3e00 7a				db WORD_SYS_CORE+102             
3e01 18 3e			dw .V1Q            
3e03 04				db 3 + 1 
3e04 .. 00			db "V1!",0              
3e08				endm 
# End of macro CWHEAD
3e08			;| V1! ( u1 -- )  Store value to v1 | DONE 
3e08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e08 cd fc 18			call macro_dsp_valuehl 
3e0b				endm 
# End of macro FORTH_DSP_VALUEHL
3e0b			 
3e0b 11 ad f9				ld de, cli_var_array+2 
3e0e				 
3e0e eb					ex de, hl 
3e0f 73					ld (hl), e 
3e10 23					inc hl 
3e11 72					ld (hl), d 
3e12			 
3e12					; destroy value TOS 
3e12			 
3e12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e12 cd 7c 19			call macro_forth_dsp_pop 
3e15				endm 
# End of macro FORTH_DSP_POP
3e15				       NEXTW 
3e15 c3 36 1a			jp macro_next 
3e18				endm 
# End of macro NEXTW
3e18			.V1Q: 
3e18				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
3e18 7b				db WORD_SYS_CORE+103             
3e19 29 3e			dw .V2S            
3e1b 04				db 3 + 1 
3e1c .. 00			db "V1@",0              
3e20				endm 
# End of macro CWHEAD
3e20			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
3e20 2a ad f9				ld hl, (cli_var_array+2) 
3e23 cd 61 18				call forth_push_numhl 
3e26				       NEXTW 
3e26 c3 36 1a			jp macro_next 
3e29				endm 
# End of macro NEXTW
3e29			.V2S: 
3e29				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
3e29 7c				db WORD_SYS_CORE+104             
3e2a 41 3e			dw .V2Q            
3e2c 04				db 3 + 1 
3e2d .. 00			db "V2!",0              
3e31				endm 
# End of macro CWHEAD
3e31			;| V2! ( u1 -- )  Store value to v2 | DONE 
3e31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e31 cd fc 18			call macro_dsp_valuehl 
3e34				endm 
# End of macro FORTH_DSP_VALUEHL
3e34			 
3e34 11 af f9				ld de, cli_var_array+4 
3e37				 
3e37 eb					ex de, hl 
3e38 73					ld (hl), e 
3e39 23					inc hl 
3e3a 72					ld (hl), d 
3e3b			 
3e3b					; destroy value TOS 
3e3b			 
3e3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e3b cd 7c 19			call macro_forth_dsp_pop 
3e3e				endm 
# End of macro FORTH_DSP_POP
3e3e				       NEXTW 
3e3e c3 36 1a			jp macro_next 
3e41				endm 
# End of macro NEXTW
3e41			.V2Q: 
3e41				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
3e41 7d				db WORD_SYS_CORE+105             
3e42 52 3e			dw .V3S            
3e44 04				db 3 + 1 
3e45 .. 00			db "V2@",0              
3e49				endm 
# End of macro CWHEAD
3e49			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
3e49 2a af f9				ld hl, (cli_var_array+4) 
3e4c cd 61 18				call forth_push_numhl 
3e4f				       NEXTW 
3e4f c3 36 1a			jp macro_next 
3e52				endm 
# End of macro NEXTW
3e52			.V3S: 
3e52				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
3e52 7c				db WORD_SYS_CORE+104             
3e53 6a 3e			dw .V3Q            
3e55 04				db 3 + 1 
3e56 .. 00			db "V3!",0              
3e5a				endm 
# End of macro CWHEAD
3e5a			;| V3! ( u1 -- )  Store value to v3 | DONE 
3e5a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e5a cd fc 18			call macro_dsp_valuehl 
3e5d				endm 
# End of macro FORTH_DSP_VALUEHL
3e5d			 
3e5d 11 b1 f9				ld de, cli_var_array+6 
3e60				 
3e60 eb					ex de, hl 
3e61 73					ld (hl), e 
3e62 23					inc hl 
3e63 72					ld (hl), d 
3e64			 
3e64					; destroy value TOS 
3e64			 
3e64					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e64 cd 7c 19			call macro_forth_dsp_pop 
3e67				endm 
# End of macro FORTH_DSP_POP
3e67				       NEXTW 
3e67 c3 36 1a			jp macro_next 
3e6a				endm 
# End of macro NEXTW
3e6a			.V3Q: 
3e6a				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
3e6a 7d				db WORD_SYS_CORE+105             
3e6b 7b 3e			dw .END            
3e6d 04				db 3 + 1 
3e6e .. 00			db "V3@",0              
3e72				endm 
# End of macro CWHEAD
3e72			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
3e72 2a b1 f9				ld hl, (cli_var_array+6) 
3e75 cd 61 18				call forth_push_numhl 
3e78				       NEXTW 
3e78 c3 36 1a			jp macro_next 
3e7b				endm 
# End of macro NEXTW
3e7b			 
3e7b			 
3e7b			 
3e7b			 
3e7b			 
3e7b			; end of dict marker 
3e7b			 
3e7b 00			.END:    db WORD_SYS_END 
3e7c 00 00			dw 0 
3e7e 00				db 0 
3e7f			 
3e7f			; use to jp here for user dict words to save on macro expansion  
3e7f			 
3e7f			user_dict_next: 
3e7f				NEXTW 
3e7f c3 36 1a			jp macro_next 
3e82				endm 
# End of macro NEXTW
3e82			 
3e82			 
3e82			user_exec: 
3e82				;    ld hl, <word code> 
3e82				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
3e82				;    call forthexec 
3e82				;    jp user_dict_next   (NEXT) 
3e82			        ;    <word code bytes> 
3e82 eb				ex de, hl 
3e83 2a b9 f2			ld hl,(os_tok_ptr) 
3e86				 
3e86				FORTH_RSP_NEXT 
3e86 cd 0b 18			call macro_forth_rsp_next 
3e89				endm 
# End of macro FORTH_RSP_NEXT
3e89			 
3e89			if DEBUG_FORTH_UWORD 
3e89						DMARK "UEX" 
3e89				CALLMONITOR 
3e89			endif 
3e89			 
3e89			 
3e89			 
3e89 eb				ex de, hl 
3e8a 22 b9 f2			ld (os_tok_ptr), hl 
3e8d				 
3e8d				; Don't use next - Skips the first word in uword. 
3e8d			 
3e8d c3 c7 1a			jp exec1 
3e90			;	NEXT 
3e90			 
3e90			 
3e90			; eof 
# End of file forth_wordsv4.asm
3e90			endif 
3e90			;;;;;;;;;;;;;; Debug code 
3e90			 
3e90			 
3e90			;if DEBUG_FORTH_PARSE 
3e90 .. 00		.nowordfound: db "No match",0 
3e99 .. 00		.compword:	db "Comparing word ",0 
3ea9 .. 00		.nextwordat:	db "Next word at",0 
3eb6 .. 00		.charmatch:	db "Char match",0 
3ec1			;endif 
3ec1			if DEBUG_FORTH_JP 
3ec1			.foundword:	db "Word match. Exec..",0 
3ec1			endif 
3ec1			;if DEBUG_FORTH_PUSH 
3ec1 .. 00		.enddict:	db "Dict end. Push.",0 
3ed1 .. 00		.push_str:	db "Pushing string",0 
3ee0 .. 00		.push_num:	db "Pushing number",0 
3eef .. 00		.data_sp:	db "SP:",0 
3ef3 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
3f05 .. 00		.wordinde:	db "Word in DE (3/0):",0 
3f17 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
3f29			;endif 
3f29			;if DEBUG_FORTH_MALLOC 
3f29 .. 00		.push_malloc:	db "Malloc address",0 
3f38			;endif 
3f38			 
3f38			 
3f38			 
3f38			; display malloc address and current data stack pointer  
3f38			 
3f38			malloc_error: 
3f38 d5				push de 
3f39 f5				push af 
3f3a e5				push hl 
3f3b cd ba 09			call clear_display 
3f3e 11 60 3f			ld de, .mallocerr 
3f41 3e 00			ld a,0 
3f43			;	ld de,os_word_scratch 
3f43 cd cd 09			call str_at_display 
3f46 3e 11			ld a, display_row_1+17 
3f48 11 bd fb			ld de, debug_mark 
3f4b cd cd 09			call str_at_display 
3f4e cd dd 09			call update_display 
3f51				;call break_point_state 
3f51 cd 23 53			call cin_wait 
3f54			 
3f54 3e 20			ld a, ' ' 
3f56 32 b7 ef			ld (os_view_disable), a 
3f59 e1				pop hl 
3f5a f1				pop af 
3f5b d1				pop de	 
3f5c				CALLMONITOR 
3f5c cd d7 12			call break_point_state  
3f5f				endm  
# End of macro CALLMONITOR
3f5f c9				ret 
3f60			 
3f60 .. 00		.mallocerr: 	db "Malloc Error",0 
3f6d			;if DEBUG_FORTH_PUSH 
3f6d			display_data_sp: 
3f6d f5				push af 
3f6e			 
3f6e				; see if disabled 
3f6e			 
3f6e 3a b7 ef			ld a, (os_view_disable) 
3f71 fe 2a			cp '*' 
3f73 28 67			jr z, .skipdsp 
3f75			 
3f75 e5				push hl 
3f76 e5				push hl 
3f77 e5			push hl 
3f78 cd ba 09			call clear_display 
3f7b e1			pop hl 
3f7c 7c				ld a,h 
3f7d 21 bd f2			ld hl, os_word_scratch 
3f80 cd 14 0e			call hexout 
3f83 e1				pop hl 
3f84 7d				ld a,l 
3f85 21 bf f2			ld hl, os_word_scratch+2 
3f88 cd 14 0e			call hexout 
3f8b 21 c1 f2			ld hl, os_word_scratch+4 
3f8e 3e 00			ld a,0 
3f90 77				ld (hl),a 
3f91 11 bd f2			ld de,os_word_scratch 
3f94 3e 14				ld a, display_row_2 
3f96 cd cd 09				call str_at_display 
3f99 11 f3 3e			ld de, .wordinhl 
3f9c 3e 00			ld a, display_row_1 
3f9e			 
3f9e cd cd 09				call str_at_display 
3fa1 11 bd fb			ld de, debug_mark 
3fa4 3e 11			ld a, display_row_1+17 
3fa6			 
3fa6 cd cd 09				call str_at_display 
3fa9			 
3fa9				; display current data stack pointer 
3fa9 11 ef 3e			ld de,.data_sp 
3fac 3e 1c				ld a, display_row_2 + 8 
3fae cd cd 09				call str_at_display 
3fb1			 
3fb1 2a a5 f9			ld hl,(cli_data_sp) 
3fb4 e5				push hl 
3fb5 7c				ld a,h 
3fb6 21 bd f2			ld hl, os_word_scratch 
3fb9 cd 14 0e			call hexout 
3fbc e1				pop hl 
3fbd 7d				ld a,l 
3fbe 21 bf f2			ld hl, os_word_scratch+2 
3fc1 cd 14 0e			call hexout 
3fc4 21 c1 f2			ld hl, os_word_scratch+4 
3fc7 3e 00			ld a,0 
3fc9 77				ld (hl),a 
3fca 11 bd f2			ld de,os_word_scratch 
3fcd 3e 1f				ld a, display_row_2 + 11 
3fcf cd cd 09				call str_at_display 
3fd2			 
3fd2			 
3fd2 cd dd 09			call update_display 
3fd5 cd 3e 09			call delay1s 
3fd8 cd 3e 09			call delay1s 
3fdb e1				pop hl 
3fdc			.skipdsp: 
3fdc f1				pop af 
3fdd c9				ret 
3fde			 
3fde			display_data_malloc: 
3fde			 
3fde f5				push af 
3fdf e5				push hl 
3fe0 e5				push hl 
3fe1 e5			push hl 
3fe2 cd ba 09			call clear_display 
3fe5 e1			pop hl 
3fe6 7c				ld a,h 
3fe7 21 bd f2			ld hl, os_word_scratch 
3fea cd 14 0e			call hexout 
3fed e1				pop hl 
3fee 7d				ld a,l 
3fef 21 bf f2			ld hl, os_word_scratch+2 
3ff2 cd 14 0e			call hexout 
3ff5 21 c1 f2			ld hl, os_word_scratch+4 
3ff8 3e 00			ld a,0 
3ffa 77				ld (hl),a 
3ffb 11 bd f2			ld de,os_word_scratch 
3ffe 3e 14				ld a, display_row_2 
4000 cd cd 09				call str_at_display 
4003 11 29 3f			ld de, .push_malloc 
4006 3e 00			ld a, display_row_1 
4008			 
4008 cd cd 09				call str_at_display 
400b			 
400b				; display current data stack pointer 
400b 11 ef 3e			ld de,.data_sp 
400e 3e 1c				ld a, display_row_2 + 8 
4010 cd cd 09				call str_at_display 
4013			 
4013 2a a5 f9			ld hl,(cli_data_sp) 
4016 e5				push hl 
4017 7c				ld a,h 
4018 21 bd f2			ld hl, os_word_scratch 
401b cd 14 0e			call hexout 
401e e1				pop hl 
401f 7d				ld a,l 
4020 21 bf f2			ld hl, os_word_scratch+2 
4023 cd 14 0e			call hexout 
4026 21 c1 f2			ld hl, os_word_scratch+4 
4029 3e 00			ld a,0 
402b 77				ld (hl),a 
402c 11 bd f2			ld de,os_word_scratch 
402f 3e 1f				ld a, display_row_2 + 11 
4031 cd cd 09				call str_at_display 
4034			 
4034 cd dd 09			call update_display 
4037 cd 3e 09			call delay1s 
403a cd 3e 09			call delay1s 
403d e1				pop hl 
403e f1				pop af 
403f c9				ret 
4040			;endif 
4040			 
4040			include "forth_autostart.asm" 
4040			; list of commands to perform at system start up 
4040			 
4040			startcmds: 
4040			;	dw test11 
4040			;	dw test12 
4040			;	dw test13 
4040			;	dw test14 
4040			;	dw test15 
4040			;	dw test16 
4040			;	dw test17 
4040			;	dw ifthtest1 
4040			;	dw ifthtest2 
4040			;	dw ifthtest3 
4040			;	dw mmtest1 
4040			;	dw mmtest2 
4040			;	dw mmtest3 
4040			;	dw mmtest4 
4040			;	dw mmtest5 
4040			;	dw mmtest6 
4040			;	dw iftest1 
4040			;	dw iftest2 
4040			;	dw iftest3 
4040			;	dw looptest1 
4040			;	dw looptest2 
4040			;	dw test1 
4040			;	dw test2 
4040			;	dw test3 
4040			;	dw test4 
4040			;	dw game2r 
4040			;	dw game2b1 
4040			;	dw game2b2 
4040			 
4040				; start up words that are actually useful 
4040			 
4040 9c 40			dw clrstack 
4042 cf 40			dw type 
4044 90 42			dw stest 
4046 f3 40			dw strncpy 
4048 31 42			dw list 
404a 54 41			dw start1 
404c 66 41			dw start2 
404e			;	dw start3 
404e 79 41			dw start3b 
4050 d1 41			dw start3c 
4052			 
4052				; (unit) testing words 
4052			 
4052 07 43			dw mtesta 
4054 bc 43			dw mtestb 
4056 5f 44			dw mtestc 
4058 14 45			dw mtestd 
405a b8 45			dw mteste 
405c			 
405c				; demo/game words 
405c			 
405c 5b 4c		        dw game3w 
405e 89 4c		        dw game3p 
4060 a7 4c		        dw game3sc 
4062 d8 4c		        dw game3vsi 
4064 04 4d		        dw game3vs 
4066				 
4066 4e 4a			dw game2b 
4068 bc 4a			dw game2bf 
406a 06 4b			dw game2mba 
406c 9c 4b			dw game2mbas 
406e de 4b			dw game2mb 
4070			 
4070 78 47			dw game1 
4072 89 47			dw game1a 
4074 eb 47			dw game1b 
4076 20 48			dw game1c 
4078 56 48			dw game1d 
407a 87 48			dw game1s 
407c 9b 48			dw game1t 
407e b0 48			dw game1f 
4080 e4 48			dw game1z 
4082			 
4082 6e 46			dw test5 
4084 a6 46			dw test6 
4086 de 46			dw test7 
4088 f2 46			dw test8 
408a 1e 47			dw test9 
408c 34 47			dw test10 
408e				 
408e 96 49		        dw ssv5 
4090 7a 49		        dw ssv4 
4092 5e 49		        dw ssv3 
4094 28 49		        dw ssv2 
4096 af 49		        dw ssv1 
4098 f7 49		        dw ssv1cpm 
409a			;	dw keyup 
409a			;	dw keydown 
409a			;	dw keyleft 
409a			;	dw keyright 
409a			;	dw 	keyf1 
409a			;	dw keyf2 
409a			;	dw keyf3 
409a			;	dw keyf4 
409a			;	dw keyf5 
409a			;	dw keyf6 
409a			;	dw keyf7 
409a			;	dw keyf8 
409a			;	dw keyf9 
409a			;	dw keyf10 
409a			;	dw keyf11 
409a			;	dw keyf12 
409a			;	dw keytab 
409a			;	dw keycr 
409a			;	dw keyhome 
409a			;	dw keyend 
409a			;	dw keybs 
409a 00 00			db 0, 0	 
409c			 
409c			 
409c			; clear stack  
409c			 
409c .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
40cf			 
40cf			; type ( addr count - ) 
40cf .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
40f3			 
40f3			; some direct memory words 
40f3			; strncpy ( len t f -- t ) 
40f3			 
40f3 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4154			 
4154 .. 00		start1:     	db ": bpon $0000 bp ;",0 
4166 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4179			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
4179 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
41d1 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
4231			 
4231			 
4231			; a handy word to list items on the stack 
4231			 
4231 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
4290			 
4290			 
4290			; test stack  
4290			; rnd8 stest 
4290			 
4290 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4307			 
4307			; random malloc and free cycles 
4307			 
4307 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
43bc			 
43bc			; fixed malloc and free cycles 
43bc			 
43bc .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
445f			 
445f			; fixed double string push and drop cycle  
445f			 
445f .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4514			 
4514			; consistent fixed string push and drop cycle  
4514			 
4514 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
45b8			 
45b8 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
466e			 
466e			;test1:		db ": aa 1 2 3 ;", 0 
466e			;test2:     	db "111 aa 888 999",0 
466e			;test3:     	db ": bb 77 ;",0 
466e			;test4:     	db "$02 $01 do i . loop bb",0 
466e			 
466e .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
46a6 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
46de .. 00		test7:     	db ": box hline vline ;",0 
46f2 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
471e .. 00		test9:     	db ": sw $01 adsp world ;",0 
4734 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4759 .. 00		test11:     	db "hello create .",0 
4768 .. 00		test12:     	db "hello2 create .",0 
4778			 
4778			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4778			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4778			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4778			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4778			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4778			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4778			 
4778			;iftest1:     	db "$0001 IF cls .",0 
4778			;iftest2:     	db "$0000 IF cls .",0 
4778			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4778			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4778			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4778			 
4778			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4778			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4778			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4778			 
4778			 
4778			 
4778			; a small guess the number game 
4778			 
4778 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4789 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
47eb			 
47eb .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4820 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4856 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4887 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
489b .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
48b0 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
48e4 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4928			 
4928			 
4928			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4928			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4928			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4928			 
4928			; simple screen saver to test code memory reuse to destruction 
4928			 
4928 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
495e .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
497a .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
4996 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
49af .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
49f7 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
4a4e			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
4a4e			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
4a4e			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
4a4e			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
4a4e			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
4a4e			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
4a4e			 
4a4e			 
4a4e			 
4a4e			; minesweeper/battleship finding game 
4a4e			; draws a game board of random ship/mine positions 
4a4e			; user enters coords to see if it hits on 
4a4e			; game ends when all are hit 
4a4e			; when hit or miss says how many may be in the area 
4a4e			 
4a4e			; setup the game board and then hide it 
4a4e .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
4abc .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
4b06			; prompt for where to target 
4b06 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
4b9c .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
4bc1			; TODO see if the entered coords hits or misses pushes char hit of miss 
4bc1 .. 00		game2mbht:      db ": mbckht nop ;",0 
4bd0 .. 00		game2mbms:      db ": mbcms nop ;",0 
4bde			; TODO how many might be near by 
4bde .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
4c5b			 
4c5b			; Game 3 
4c5b			 
4c5b			; Vert scroller ski game - avoid the trees! 
4c5b			 
4c5b			; v0 score (ie turns) 
4c5b			; v1 player pos 
4c5b			; v2 left wall 
4c5b			; v3 right wall 
4c5b			 
4c5b			; Draw side walls randomly 
4c5b			 
4c5b .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
4c89			 
4c89			; Draw player 
4c89 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
4ca7			 
4ca7			; TODO Get Key 
4ca7			 
4ca7			; TODO Move left right 
4ca7			 
4ca7			; scroll and move walls a bit 
4ca7			 
4ca7 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
4cd8			 
4cd8			; main game loop 
4cd8			 
4cd8 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
4d04 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
4d43			 
4d43			; key board defs 
4d43			 
4d43 .. 00		keyup:       db ": keyup $05 ;",0 
4d51 .. 00		keydown:       db ": keydown $0a ;",0 
4d61 .. 00		keyleft:       db ": keyleft $0b ;",0 
4d71 .. 00		keyright:       db ": keyright $0c ;",0 
4d82 .. 00		keyf1:       db ": keyf1 $10 ;",0 
4d90 .. 00		keyf2:       db ": keyf2 $11 ;",0 
4d9e .. 00		keyf3:       db ": keyf3 $12 ;",0 
4dac .. 00		keyf4:       db ": keyf4 $13 ;",0 
4dba .. 00		keyf5:       db ": keyf5 $14 ;",0 
4dc8 .. 00		keyf6:       db ": keyf6 $15 ;",0 
4dd6 .. 00		keyf7:       db ": keyf7 $16 ;",0 
4de4 .. 00		keyf8:       db ": keyf8 $17 ;",0 
4df2 .. 00		keyf9:       db ": keyf9 $18 ;",0 
4e00 .. 00		keyf10:       db ": keyf10 $19 ;",0 
4e0f .. 00		keyf11:       db ": keyf11 $1a ;",0 
4e1e .. 00		keyf12:       db ": keyf12 $1b ;",0 
4e2d			 
4e2d .. 00		keytab:       db ": keytab $09 ;",0 
4e3c .. 00		keycr:       db ": keycr $0d ;",0 
4e4a .. 00		keyhome:       db ": keyhome $0e ;",0 
4e5a .. 00		keyend:       db ": keyend $0f ;",0 
4e69 .. 00		keybs:       db ": keybs $08 ;",0 
4e77			 
4e77			   
4e77			 
4e77			 
4e77			 
4e77			; eof 
# End of file forth_autostart.asm
4e77			 
4e77 .. 00		sprompt1: db "Startup load...",0 
4e87 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
4e9d			 
4e9d			forth_startup: 
4e9d 21 40 40			ld hl, startcmds 
4ea0 3e 00			ld a, 0 
4ea2 32 de f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
4ea5			 
4ea5 e5			.start1:	push hl 
4ea6 cd ba 09			call clear_display 
4ea9 11 77 4e			ld de, sprompt1 
4eac 3e 00		        ld a, display_row_1 
4eae cd cd 09			call str_at_display 
4eb1 11 87 4e			ld de, sprompt2 
4eb4 3e 14		        ld a, display_row_2 
4eb6 cd cd 09			call str_at_display 
4eb9 e1				pop hl 
4eba e5				push hl 
4ebb 5e				ld e,(hl) 
4ebc 23				inc hl 
4ebd 56				ld d,(hl) 
4ebe 3e 28		        ld a, display_row_3 
4ec0 cd cd 09			call str_at_display 
4ec3 cd dd 09			call update_display 
4ec6			 
4ec6			 
4ec6 3a de f3			ld a, (os_last_cmd) 
4ec9 fe 00			cp 0 
4ecb 28 05			jr z, .startprompt 
4ecd cd 32 09			call delay250ms 
4ed0 18 24			jr .startdo 
4ed2				 
4ed2				 
4ed2			 
4ed2			.startprompt: 
4ed2			 
4ed2 3e 4f			ld a,display_row_4 + display_cols - 1 
4ed4 11 da 17		        ld de, endprg 
4ed7 cd cd 09			call str_at_display 
4eda cd dd 09			call update_display 
4edd cd 3e 09			call delay1s 
4ee0 cd 23 53			call cin_wait 
4ee3						 
4ee3 fe 2a			cp '*' 
4ee5 28 5e			jr z, .startupend1 
4ee7 fe 23			cp '#' 
4ee9 20 07			jr nz, .startno 
4eeb 3e 01			ld a, 1 
4eed 32 de f3			ld (os_last_cmd),a 
4ef0 18 04			jr .startdo 
4ef2 fe 31		.startno:	cp '1' 
4ef4 28 3a			jr z,.startnxt  
4ef6			 
4ef6				; exec startup line 
4ef6			.startdo:	 
4ef6 e1				pop hl 
4ef7 e5				push hl 
4ef8				 
4ef8 5e				ld e,(hl) 
4ef9 23				inc hl 
4efa 56				ld d,(hl) 
4efb eb				ex de,hl 
4efc			 
4efc e5				push hl 
4efd			 
4efd 3e 00			ld a, 0 
4eff				;ld a, FORTH_END_BUFFER 
4eff cd 7c 0f			call strlent 
4f02 23				inc hl   ; include zero term to copy 
4f03 06 00			ld b,0 
4f05 4d				ld c,l 
4f06 e1				pop hl 
4f07 11 b8 ef			ld de, scratch 
4f0a ed b0			ldir 
4f0c			 
4f0c			 
4f0c 21 b8 ef			ld hl, scratch 
4f0f cd 84 1a			call forthparse 
4f12 cd c4 1a			call forthexec 
4f15 cd db 19			call forthexec_cleanup 
4f18			 
4f18 3e 3c			ld a, display_row_4 
4f1a 11 7e 15			ld de, endprog 
4f1d			 
4f1d cd dd 09			call update_display		 
4f20			 
4f20 3a de f3			ld a, (os_last_cmd) 
4f23 fe 00			cp 0 
4f25 20 09			jr nz, .startnxt 
4f27 cd dc 17			call next_page_prompt 
4f2a cd ba 09		        call clear_display 
4f2d cd dd 09			call update_display		 
4f30			 
4f30				; move onto next startup line? 
4f30			.startnxt: 
4f30			 
4f30 cd 32 09			call delay250ms 
4f33 e1				pop hl 
4f34			 
4f34 23				inc hl 
4f35 23				inc hl 
4f36			 
4f36 e5				push hl 
4f37 5e				ld e, (hl) 
4f38 23				inc hl 
4f39 56				ld d, (hl) 
4f3a e1				pop hl 
4f3b				; TODO replace 0 test 
4f3b			 
4f3b eb				ex de, hl 
4f3c cd 3c 0b			call ishlzero 
4f3f			;	ld a,e 
4f3f			;	add d 
4f3f			;	cp 0    ; any left to do? 
4f3f eb				ex de, hl 
4f40 c2 a5 4e			jp nz, .start1 
4f43 18 01			jr .startupend 
4f45			 
4f45 e1			.startupend1: pop hl 
4f46			.startupend: 
4f46			 
4f46 cd ba 09			call clear_display 
4f49 cd dd 09			call update_display 
4f4c c9				ret 
4f4d			 
4f4d			 
4f4d			; stack over and underflow checks 
4f4d			 
4f4d			; init the words to detect the under/overflow 
4f4d			 
4f4d			chk_stk_init: 
4f4d				; a vague random number to check so we dont get any "lucky" hits 
4f4d 3e 2d			ld a, 45 
4f4f 6f				ld l, a 
4f50 00				nop 
4f51 3e 17			ld a, 23 
4f53 67				ld h, a 
4f54			 
4f54 22 ad ef			ld (chk_word), hl     ; the word we need to check against 
4f57			 
4f57			;	ld (chk_stund), hl	; stack points.... 
4f57 22 fd fb			ld (chk_stovr), hl 
4f5a 22 a3 f9			ld (chk_ret_und), hl 
4f5d 22 21 f9			ld (chk_ret_ovr), hl 
4f60 22 1f f7			ld (chk_loop_ovr), hl 
4f63 22 1d f5			ld (chk_data_ovr), hl 
4f66 c9				ret 
4f67				 
4f67			check_stacks: 
4f67				; check all stack words 
4f67			 
4f67 e5				push hl 
4f68 d5				push de 
4f69			 
4f69			;	ld de,(chk_word) 
4f69			;	ld hl, (chk_stund)	; stack points.... 
4f69			;	if DEBUG_STK_FAULT 
4f69			;		DMARK "FAa" 
4f69			;		CALLMONITOR 
4f69			;	endif 
4f69			;	call cmp16 
4f69			;	jp z, .chk_faulta 
4f69			; 
4f69			;	ld de, sfaultsu 
4f69			;	jp .chk_fault 
4f69			 
4f69 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
4f6c ed 5b ad ef		ld de,(chk_word) 
4f70				if DEBUG_STK_FAULT 
4f70					DMARK "FAb" 
4f70					CALLMONITOR 
4f70				endif 
4f70 cd 31 0b			call cmp16 
4f73 28 06			jr z, .chk_fault1 
4f75 11 16 50			ld de, sfaultso 
4f78 c3 ca 4f			jp .chk_fault 
4f7b			.chk_fault1:  
4f7b 2a a3 f9			ld hl, (chk_ret_und) 
4f7e ed 5b ad ef		ld de,(chk_word) 
4f82				if DEBUG_STK_FAULT 
4f82					DMARK "FAU" 
4f82					CALLMONITOR 
4f82				endif 
4f82 cd 31 0b			call cmp16 
4f85 ca 8e 4f			jp z, .chk_fault2 
4f88 11 26 50			ld de, sfaultru 
4f8b c3 ca 4f			jp .chk_fault 
4f8e			.chk_fault2:  
4f8e 2a 21 f9			ld hl, (chk_ret_ovr) 
4f91 ed 5b ad ef		ld de,(chk_word) 
4f95				if DEBUG_STK_FAULT 
4f95					DMARK "FA1" 
4f95					CALLMONITOR 
4f95				endif 
4f95 cd 31 0b			call cmp16 
4f98 ca a1 4f			jp z, .chk_fault3 
4f9b 11 34 50			ld de, sfaultro 
4f9e c3 ca 4f			jp .chk_fault 
4fa1			.chk_fault3:  
4fa1 2a 1f f7			ld hl, (chk_loop_ovr) 
4fa4 ed 5b ad ef		ld de,(chk_word) 
4fa8				if DEBUG_STK_FAULT 
4fa8					DMARK "FA2" 
4fa8					CALLMONITOR 
4fa8				endif 
4fa8 cd 31 0b			call cmp16 
4fab ca b4 4f			jp z, .chk_fault4 
4fae 11 4e 50			ld de, sfaultlo 
4fb1 c3 ca 4f			jp .chk_fault 
4fb4			.chk_fault4:  
4fb4 2a 1d f5			ld hl, (chk_data_ovr) 
4fb7 ed 5b ad ef		ld de,(chk_word) 
4fbb				if DEBUG_STK_FAULT 
4fbb					DMARK "FA3" 
4fbb					CALLMONITOR 
4fbb				endif 
4fbb cd 31 0b			call cmp16 
4fbe ca c7 4f			jp z, .chk_fault5 
4fc1 11 68 50			ld de, sfaultdo 
4fc4 c3 ca 4f			jp .chk_fault 
4fc7			 
4fc7			 
4fc7			.chk_fault5:  
4fc7 d1				pop de 
4fc8 e1				pop hl 
4fc9			 
4fc9 c9				ret 
4fca			 
4fca cd ba 09		.chk_fault: 	call clear_display 
4fcd 3e 14				ld a, display_row_2 
4fcf cd cd 09				call str_at_display 
4fd2 11 f8 4f				   ld de, .stackfault 
4fd5 3e 00				ld a, display_row_1 
4fd7 cd cd 09				call str_at_display 
4fda 11 bd fb				    ld de, debug_mark 
4fdd 3e 11				ld a, display_row_1+17 
4fdf cd cd 09				call str_at_display 
4fe2 cd dd 09				call update_display 
4fe5			 
4fe5				; prompt before entering montior for investigating issue 
4fe5			 
4fe5 3e 3c			ld a, display_row_4 
4fe7 11 7e 15			ld de, endprog 
4fea			 
4fea cd dd 09			call update_display		 
4fed			 
4fed cd dc 17			call next_page_prompt 
4ff0			 
4ff0 d1				pop de 
4ff1 e1				pop hl 
4ff2 cd d2 15				call monitor 
4ff5 c3 cc 14				jp warmstart 
4ff8					;jp 0 
4ff8					;halt 
4ff8			 
4ff8			 
4ff8			 
4ff8 .. 00		.stackfault: 	db "Stack fault:",0 
5005			 
5005 .. 00		sfaultsu: 	db	"Stack under flow",0 
5016 .. 00		sfaultso: 	db	"Stack over flow",0 
5026 .. 00		sfaultru:	db "RTS underflow",0 
5034 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
504e .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5068 .. 00		sfaultdo:	db "DTS overflow", 0 
5075			 
5075			 
5075			fault_dsp_under: 
5075 11 87 50			ld de, .dsp_under 
5078 c3 37 51			jp .show_fault 
507b			 
507b			fault_rsp_under: 
507b 11 95 50			ld de, .rsp_under 
507e c3 37 51			jp .show_fault 
5081			fault_loop_under: 
5081 11 a3 50			ld de, .loop_under 
5084 c3 37 51			jp .show_fault 
5087			 
5087 .. 00		.dsp_under: db "DSP Underflow",0 
5095 .. 00		.rsp_under: db "RSP Underflow",0 
50a3 .. 00		.loop_under: db "LOOP Underflow",0 
50b2			 
50b2			 
50b2 d5			type_faultn: 	push de 
50b3 e5					push hl 
50b4 cd ba 09				call clear_display 
50b7 11 de 50				   ld de, .typefaultn 
50ba 3e 00				ld a, display_row_1 
50bc cd cd 09				call str_at_display 
50bf 11 bd fb				    ld de, debug_mark 
50c2 3e 11				ld a, display_row_1+17 
50c4 cd cd 09				call str_at_display 
50c7 cd dd 09				call update_display 
50ca			 
50ca				; prompt before entering montior for investigating issue 
50ca			 
50ca 3e 3c			ld a, display_row_4 
50cc 11 7e 15			ld de, endprog 
50cf			 
50cf cd dd 09			call update_display		 
50d2			 
50d2 cd dc 17			call next_page_prompt 
50d5			 
50d5 e5					push hl 
50d6 d5					push de 
50d7 cd d2 15				call monitor 
50da c3 cc 14				jp warmstart 
50dd 76					halt 
50de			 
50de			 
50de .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
50f5			 
50f5 d5			type_faults: 	push de 
50f6 e5					push hl 
50f7 cd ba 09				call clear_display 
50fa 11 20 51				   ld de, .typefaults 
50fd 3e 00				ld a, display_row_1 
50ff cd cd 09				call str_at_display 
5102 11 bd fb				    ld de, debug_mark 
5105 3e 11				ld a, display_row_1+17 
5107 cd cd 09				call str_at_display 
510a cd dd 09				call update_display 
510d			 
510d				; prompt before entering montior for investigating issue 
510d			 
510d 3e 3c			ld a, display_row_4 
510f 11 7e 15			ld de, endprog 
5112			 
5112 cd dd 09			call update_display		 
5115			 
5115 cd dc 17			call next_page_prompt 
5118			 
5118 e1					pop hl 
5119 d1					pop de 
511a cd d2 15				call monitor 
511d c3 cc 14				jp warmstart 
5120			 
5120			 
5120 .. 00		.typefaults: db "STR Type Expected TOS!",0 
5137			 
5137			.show_fault: 	 
5137 d5					push de 
5138 cd ba 09				call clear_display 
513b d1					pop de 
513c 3e 00				ld a, display_row_1 
513e cd cd 09				call str_at_display 
5141 11 bd fb				    ld de, debug_mark 
5144 3e 11				ld a, display_row_1+17 
5146 cd cd 09				call str_at_display 
5149 cd dd 09				call update_display 
514c			 
514c				; prompt before entering montior for investigating issue 
514c			 
514c 3e 3c			ld a, display_row_4 
514e 11 7e 15			ld de, endprog 
5151			 
5151 cd dd 09			call update_display		 
5154			 
5154 cd dc 17			call next_page_prompt 
5157			 
5157 e1					pop hl 
5158 d1					pop de 
5159 cd d2 15				call monitor 
515c			; do a dump to cli and not warmstart so we preserve all of the uwords.  
515c			; TODO Make optional fault restart to cli or warm boot? 
515c					;jp warmstart 
515c c3 24 15				jp cli 
515f 76					halt 
5160			; eof 
# End of file forth_kernel.asm
5160			;include "nascombasic.asm" 
5160			 
5160			 
5160			; find out where the code ends if loaded into RAM (for SC114) 
5160			;endofcode:  
5160			;	nop 
5160			 
5160			 
5160			; eof 
5160			 
# End of file main.asm
5160			include "firmware_lcd_4x20.asm" 
5160			; **********************************************************************  
5160			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
5160			; **********************************************************************  
5160			;  
5160			; **  Written as a Small Computer Monitor App  
5160			; **  www.scc.me.uk  
5160			;  
5160			; History  
5160			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
5160			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
5160			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
5160			;  
5160			; **********************************************************************  
5160			;  
5160			; This program is an example of one of the methods of interfacing an   
5160			; alphanumeric LCD module.   
5160			;  
5160			; In this example the display is connected to either a Z80 PIO or a   
5160			; simple 8-bit output port.   
5160			;  
5160			; This interfacing method uses 4-bit data mode and uses time delays  
5160			; rather than polling the display's ready status. As a result the   
5160			; interface only requires 6 simple output lines:  
5160			;   Output bit 0 = not used  
5160			;   Output bit 1 = not used  
5160			;   Output bit 2 = RS         High = data, Low = instruction  
5160			;   Output bit 3 = E          Active high  
5160			;   Output bit 4 = DB4  
5160			;   Output bit 5 = DB5  
5160			;   Output bit 6 = DB6  
5160			;   Output bit 7 = DB7  
5160			; Display's R/W is connected to 0v so it is always in write mode  
5160			;  
5160			; This set up should work with any system supporting the RC2014 bus  
5160			  
5160			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
5160			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
5160			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
5160			;  
5160			; **********************************************************************  
5160			  
5160			; **********************************************************************  
5160			; **  Constants  
5160			; **********************************************************************  
5160			; LCD constants required by LCD support module  
5160			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
5160			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
5160			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
5160			kLCDWidth:  EQU display_cols             ;Width in characters  
5160			  
5160			; **********************************************************************  
5160			; **  Code library usage  
5160			; **********************************************************************  
5160			  
5160			; send character to current cursor position  
5160			; wraps and/or scrolls screen automatically  
5160			  
5160			  
5160			lcd_init:  
5160			  
5160			; SCMonAPI functions used  
5160			  
5160			; Alphanumeric LCD functions used  
5160			; no need to specify specific functions for this module  
5160			  
5160 3e cf		            LD   A, 11001111b  
5162 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
5164 3e 00		            LD   A, 00000000b  
5166 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
5168			  
5168			; Initialise alphanumeric LCD module  
5168 cd e1 51		            CALL fLCD_Init      ;Initialise LCD module  
516b			  
516b c9				ret  
516c			  
516c			;  
516c			;;  
516c			; lcd functions  
516c			;  
516c			;  
516c			  
516c			; what is at cursor position   
516c			  
516c			;get_cursor:	ld de, (cursor_row)   ;  row + col  
516c			;		call curptr  
516c			;		ret  
516c			  
516c			  
516c			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
516c			  
516c			curptr:  
516c c5				push bc  
516d 21 53 fb			ld hl, display_fb0  
5170			cpr:	  
5170				; loop for cursor whole row  
5170 0e 14			ld c, display_cols  
5172 23			cpr1:	inc hl  
5173 0d				dec c  
5174 20 fc			jr nz, cpr1  
5176 05				dec b  
5177 20 f7			jr nz, cpr  
5179			  
5179				; add col	  
5179			  
5179 23			cpr2:	inc hl  
517a 1d				dec e  
517b 20 fc			jr nz, cpr2  
517d			  
517d c1				pop bc  
517e c9				ret  
517f				  
517f			  
517f			  
517f			  
517f			  
517f			; write the frame buffer given in hl to hardware   
517f 22 5b fa		write_display: ld (display_write_tmp), hl 	   
5182 3e 00			ld a, kLCD_Line1  
5184 cd 52 52		            CALL fLCD_Pos       ;Position cursor to location in A  
5187 06 14			ld b, display_cols  
5189 ed 5b 5b fa		ld de, (display_write_tmp)  
518d cd d9 51			call write_len_string  
5190				  
5190				  
5190 2a 5b fa			ld hl, (display_write_tmp)  
5193 11 14 00			ld de, display_cols  
5196 19				add hl,de  
5197 22 5b fa			ld (display_write_tmp),hl  
519a			  
519a				  
519a 3e 40			ld a, kLCD_Line2  
519c cd 52 52		            CALL fLCD_Pos       ;Position cursor to location in A  
519f 06 14			ld b, display_cols  
51a1 ed 5b 5b fa		ld de, (display_write_tmp)  
51a5 cd d9 51			call write_len_string  
51a8				  
51a8 2a 5b fa			ld hl, (display_write_tmp)  
51ab 11 14 00			ld de, display_cols  
51ae 19				add hl,de  
51af 22 5b fa			ld (display_write_tmp),hl  
51b2			  
51b2				  
51b2 3e 14			ld a, kLCD_Line3  
51b4 cd 52 52		            CALL fLCD_Pos       ;Position cursor to location in A  
51b7 06 14			ld b, display_cols  
51b9 ed 5b 5b fa		ld de, (display_write_tmp)  
51bd cd d9 51			call write_len_string  
51c0				  
51c0 2a 5b fa			ld hl, (display_write_tmp)  
51c3 11 14 00			ld de, display_cols  
51c6 19				add hl,de  
51c7 22 5b fa			ld (display_write_tmp),hl  
51ca			  
51ca				  
51ca 3e 54			ld a, kLCD_Line4  
51cc cd 52 52		            CALL fLCD_Pos       ;Position cursor to location in A  
51cf 06 14			ld b, display_cols  
51d1 ed 5b 5b fa		ld de, (display_write_tmp)  
51d5 cd d9 51			call write_len_string  
51d8 c9					ret  
51d9				  
51d9				; write out a fixed length string given in b from de  
51d9			  
51d9 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
51da cd 2b 52		            CALL fLCD_Data      ;Write character to display  
51dd 13				inc de  
51de 10 f9			djnz write_len_string  
51e0 c9				ret  
51e1			  
51e1			; Some other things to do  
51e1			;            LD   A, kLCD_Clear ;Display clear  
51e1			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
51e1			;            LD   A, kLCD_Under ;Display on with underscore cursor  
51e1			;            LD   A, kLCD_On     ;Display on with no cursor  
51e1			;            ;LD   A, kLCD_Off   ;Display off  
51e1			;            CALL fLCD_Inst      ;Send instruction to display  
51e1			;  
51e1			;  
51e1			;            halt  
51e1			;  
51e1			;  
51e1			;MsgHello:   DB  "Hello World!",0  
51e1			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
51e1			  
51e1			; Custom characters 5 pixels wide by 8 pixels high  
51e1			; Up to 8 custom characters can be defined  
51e1			;BitMaps:      
51e1			;; Character 0x00 = Battery icon  
51e1			;            DB  01110b  
51e1			;            DB  11011b  
51e1			;            DB  10001b  
51e1			;            DB  10001b  
51e1			;            DB  11111b  
51e1			;            DB  11111b  
51e1			;            DB  11111b  
51e1			;            DB  11111b  
51e1			;; Character 0x01 = Bluetooth icon  
51e1			;            DB  01100b  
51e1			;            DB  01010b  
51e1			;            DB  11100b  
51e1			;            DB  01000b  
51e1			;            DB  11100b  
51e1			;            DB  01010b  
51e1			;            DB  01100b  
51e1			;            DB  00000b  
51e1			;  
51e1			  
51e1			  
51e1			; **********************************************************************  
51e1			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
51e1			; **********************************************************************  
51e1			;  
51e1			; **  Written as a Small Computer Monitor App   
51e1			; **  Version 0.1 SCC 2018-05-16  
51e1			; **  www.scc.me.uk  
51e1			;  
51e1			; **********************************************************************  
51e1			;  
51e1			; This module provides support for alphanumeric LCD modules using with  
51e1			; *  HD44780 (or compatible) controller  
51e1			; *  5 x 7 pixel fonts  
51e1			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
51e1			; *  Interface via six digital outputs to the display (see below)  
51e1			;  
51e1			; LCD module pinout:  
51e1			;   1  Vss   0v supply  
51e1			;   2  Vdd   5v supply  
51e1			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
51e1			;   4  RS    High = data, Low = instruction  
51e1			;   5  R/W   High = Read, Low = Write  
51e1			;   6  E     Enable signal (active high)  
51e1			;   7  DB0   Data bit 0  
51e1			;   8  DB1   Data bit 1  
51e1			;   9  DB2   Data bit 2  
51e1			;  10  DB3   Data bit 3  
51e1			;  11  DB4   Data bit 4  
51e1			;  12  DB5   Data bit 5  
51e1			;  13  DB6   Data bit 6  
51e1			;  14  DB7   Data bit 7  
51e1			;  15  A     Backlight anode (+)  
51e1			;  16  K     Backlight cathode (-)  
51e1			;  
51e1			; This interfacing method uses 4-bit data mode and uses time delays  
51e1			; rather than polling the display's ready status. As a result the   
51e1			; interface only requires 6 simple output lines:  
51e1			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
51e1			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
51e1			;   LCD DB4 = Microcomputer output port bit 4  
51e1			;   LCD DB5 = Microcomputer output port bit 5  
51e1			;   LCD DB6 = Microcomputer output port bit 6  
51e1			;   LCD DB7 = Microcomputer output port bit 7  
51e1			; Display's R/W is connected to 0v so it is always in write mode  
51e1			; All 6 connections must be on the same port address <kLCDPrt>  
51e1			; This method also allows a decent length of cable from micro to LCD  
51e1			;  
51e1			; **********************************************************************  
51e1			;  
51e1			; To include the code for any given function provided by this module,   
51e1			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
51e1			; the parent source file.  
51e1			; For example:  #REQUIRES   uHexPrefix  
51e1			;  
51e1			; Also #INCLUDE this file at some point after the #REQUIRES statements  
51e1			; in the parent source file.  
51e1			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
51e1			;  
51e1			; These are the function names provided by this module:  
51e1			; fLCD_Init                     ;Initialise LCD  
51e1			; fLCD_Inst                     ;Send instruction to LCD  
51e1			; fLCD_Data                     ;Send data byte to LCD  
51e1			; fLCD_Pos                      ;Position cursor  
51e1			; fLCD_Str                      ;Display string  
51e1			; fLCD_Def                      ;Define custom character  
51e1			;  
51e1			; **********************************************************************  
51e1			;  
51e1			; Requires SCMonAPI.asm to also be included in the project  
51e1			;  
51e1			  
51e1			  
51e1			; **********************************************************************  
51e1			; **  Constants  
51e1			; **********************************************************************  
51e1			  
51e1			; Constants that must be defined externally  
51e1			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
51e1			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
51e1			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
51e1			;kLCDWidth: EQU 20             ;Width in characters  
51e1			  
51e1			; general line offsets in any frame buffer  
51e1			  
51e1			  
51e1			display_row_1: equ 0  
51e1			display_row_2: equ display_row_1+display_cols  
51e1			display_row_3: equ display_row_2 + display_cols  
51e1			display_row_4: equ display_row_3 + display_cols  
51e1			;display_row_4_eol:   
51e1			  
51e1			  
51e1			; Cursor position values for the start of each line  
51e1			kLCD_Line1: EQU 0x00   
51e1			kLCD_Line2: EQU 0x40    
51e1			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
51e1			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
51e1			  
51e1			; Instructions to send as A register to fLCD_Inst  
51e1			kLCD_Clear: EQU 00000001b     ;LCD clear  
51e1			kLCD_Off:   EQU 00001000b     ;LCD off  
51e1			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
51e1			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
51e1			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
51e1			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
51e1			  
51e1			; Constants used by this code module  
51e1			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
51e1			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
51e1			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
51e1			  
51e1			  
51e1			  
51e1			; **********************************************************************  
51e1			; **  LCD support functions  
51e1			; **********************************************************************  
51e1			  
51e1			; Initialise alphanumeric LCD module  
51e1			; LCD control register codes:  
51e1			;   DL   0 = 4-bit mode        1 = 8-bit mode  
51e1			;   N    0 = 1-line mode       1 = 2-line mode  
51e1			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
51e1			;   D    0 = Display off       1 = Display on  
51e1			;   C    0 = Cursor off        1 = Cursor on  
51e1			;   B    0 = Blinking off      1 = Blinking on  
51e1			;   ID   0 = Decrement mode    1 = Increment mode  
51e1			;   SH   0 = Entire shift off  1 = Entire shift on  
51e1 3e 28		fLCD_Init:  LD   A, 40  
51e3 cd 98 52		            CALL LCDDelay       ;Delay 40ms after power up  
51e6			; For reliable reset set 8-bit mode - 3 times  
51e6 cd 82 52		            CALL WrFn8bit       ;Function = 8-bit mode  
51e9 cd 82 52		            CALL WrFn8bit       ;Function = 8-bit mode  
51ec cd 82 52		            CALL WrFn8bit       ;Function = 8-bit mode  
51ef			; Set 4-bit mode  
51ef cd 7e 52		            CALL WrFn4bit       ;Function = 4-bit mode  
51f2 cd 96 52		            CALL LCDDelay1      ;Delay 37 us or more  
51f5			; Function set  
51f5 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
51f7 cd 0a 52		            CALL fLCD_Inst      ;2 line, display on  
51fa			; Display On/Off control  
51fa 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
51fc cd 0a 52		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
51ff			; Display Clear  
51ff 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
5201 cd 0a 52		            CALL fLCD_Inst      ;Clear display  
5204			; Entry mode  
5204 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
5206 cd 0a 52		            CALL fLCD_Inst      ;Increment mode, shift off  
5209			; Display module now initialised  
5209 c9			            RET  
520a			; ok to here  
520a			  
520a			; Write instruction to LCD  
520a			;   On entry: A = Instruction byte to be written  
520a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
520a f5			fLCD_Inst:  PUSH AF  
520b f5			            PUSH AF  
520c cd 1e 52		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
520f f1			            POP  AF  
5210 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
5211 17			            RLA  
5212 17			            RLA  
5213 17			            RLA  
5214 cd 1e 52		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
5217 3e 02		            LD   A, 2  
5219 cd 98 52		            CALL LCDDelay       ;Delay 2 ms to complete   
521c f1			            POP  AF  
521d c9			            RET  
521e e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
5220 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
5222 cb df		            SET  kLCDBitE, A  
5224 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
5226 cb 9f		            RES  kLCDBitE, A  
5228 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
522a c9			            RET  
522b			  
522b			  
522b			; Write data to LCD  
522b			;   On entry: A = Data byte to be written  
522b			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
522b f5			fLCD_Data:  PUSH AF  
522c f5			            PUSH AF  
522d cd 3f 52		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
5230 f1			            POP  AF  
5231 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
5232 17			            RLA  
5233 17			            RLA  
5234 17			            RLA  
5235 cd 3f 52		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
5238 3e 96		            LD   A, 150  
523a 3d			Wait:      DEC  A              ;Wait a while to allow data   
523b 20 fd		            JR   NZ, Wait      ;  write to complete  
523d f1			            POP  AF  
523e c9			            RET  
523f e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
5241 cb d7		            SET  kLCDBitRS, A  
5243 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
5245 cb df		            SET  kLCDBitE, A  
5247 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
5249 cb 9f		            RES  kLCDBitE, A  
524b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
524d cb 97		            RES  kLCDBitRS, A  
524f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
5251 c9			            RET  
5252			  
5252			  
5252			; Position cursor to specified location  
5252			;   On entry: A = Cursor position  
5252			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
5252 f5			fLCD_Pos:   PUSH AF  
5253 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
5255 cd 0a 52		            CALL fLCD_Inst      ;Write instruction to LCD  
5258 f1			            POP  AF  
5259 c9			            RET  
525a			  
525a			  
525a			; Output text string to LCD  
525a			;   On entry: DE = Pointer to null terminated text string  
525a			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
525a 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
525b b7			            OR   A              ;Null terminator?  
525c c8			            RET  Z              ;Yes, so finished  
525d cd 2b 52		            CALL fLCD_Data      ;Write character to display  
5260 13			            INC  DE             ;Point to next character  
5261 18 f7		            JR   fLCD_Str       ;Repeat  
5263 c9					ret  
5264			  
5264			; Define custom character  
5264			;   On entry: A = Character number (0 to 7)  
5264			;             DE = Pointer to character bitmap data  
5264			;   On exit:  A = Next character number  
5264			;             DE = Next location following bitmap  
5264			;             BC HL IX IY I AF' BC' DE' HL' preserved  
5264			; Character is   
5264 c5			fLCD_Def:   PUSH BC  
5265 f5			            PUSH AF  
5266 07			            RLCA                ;Calculate location  
5267 07			            RLCA                ;  for bitmap data  
5268 07			            RLCA                ;  = 8 x CharacterNumber  
5269 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
526b cd 0a 52		            CALL fLCD_Inst      ;Write instruction to LCD  
526e 06 00		            LD   B, 0  
5270 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
5271 cd 2b 52		            CALL fLCD_Data      ;Write byte to display  
5274 13			            INC  DE             ;Point to next byte  
5275 04			            INC  B              ;Count bytes  
5276 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
5278 28 f6		            JR   Z, Loop       ;No, so repeat  
527a f1			            POP  AF  
527b 3c			            INC  A              ;Increment character number  
527c c1			            POP  BC  
527d c9			            RET  
527e			  
527e			  
527e			; **********************************************************************  
527e			; **  Private functions  
527e			; **********************************************************************  
527e			  
527e			; Write function to LCD  
527e			;   On entry: A = Function byte to be written  
527e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
527e 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
5280 18 02		            JR   WrFunc  
5282 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
5284 f5			WrFunc:     PUSH AF  
5285 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
5287 cb df		            SET  kLCDBitE, A  
5289 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
528b cb 9f		            RES  kLCDBitE, A  
528d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
528f 3e 05		            LD   A, 5  
5291 cd 98 52		            CALL LCDDelay       ;Delay 5 ms to complete  
5294 f1			            POP  AF  
5295 c9			            RET  
5296			  
5296			  
5296			; Delay in milliseconds  
5296			;   On entry: A = Number of milliseconds delay  
5296			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
5296 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
5298 d5			LCDDelay:   PUSH DE  
5299 5f			            LD   E, A           ;Delay by 'A' ms  
529a 16 00		            LD   D, 0  
529c cd 23 09		            CALL aDelayInMS  
529f d1			            POP  DE  
52a0 c9			            RET  
52a1			  
52a1			  
52a1			  
52a1			  
52a1			; eof  
52a1			  
# End of file firmware_lcd_4x20.asm
52a1			include "firmware_key_4x4.asm" 
52a1			  
52a1			  
52a1			; bit mask for each scan column and row for teing the matrix  
52a1			  
52a1			; out   
52a1 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
52a5			; in  
52a5 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
52a9			  
52a9			; row/col to character map  
52a9			  
52a9			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
52a9			;    
52a9			  
52a9			; physical key matrix map to face of key  
52a9			  
52a9			  
52a9			;      	1	2	3	A  
52a9			;   	abc”	def&	ghi$	s1  
52a9			;			  
52a9			;	4	5	6	B  
52a9			; 	jkl,	mno.	pqr:	s2  
52a9			;			  
52a9			; 	7	8	9	C  
52a9			;	stu;	vwx@	yz?!	s3  
52a9			;			  
52a9			; 	*	0	#	D  
52a9			; 	shift lck '	Space < >	Enter ( )	s4  
52a9			;       tab bs 		  
52a9			  
52a9			  
52a9			  
52a9			  
52a9			key_init:  
52a9			  
52a9			; SCMonAPI functions used  
52a9			  
52a9			; Alphanumeric LCD functions used  
52a9			; no need to specify specific functions for this module  
52a9			  
52a9			  
52a9 3e cf		            LD   A, 11001111b  
52ab d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
52ad			;            LD   A, 00000000b  
52ad 3e 0f		            LD   A, 00001111b  
52af d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
52b1			  
52b1			  
52b1				; TODO Configure cursor shapes  
52b1			  
52b1				; Load cursor shapes   
52b1 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
52b3 11 c3 52		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
52b6 06 02		            LD   B, 2           ;Number of characters to define  
52b8 cd 64 52		.DefLoop:   CALL fLCD_Def       ;Define custom character  
52bb 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
52bd			  
52bd 3e 01				ld a, 1  
52bf 32 56 fa			ld (cursor_shape),a  
52c2 c9				ret  
52c3			  
52c3			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
52c3			; Up to 8 custom characters can be defined  
52c3			.cursor_shapes:      
52c3			;; Character 0x00 = Normal  
52c3 1f			            DB  11111b  
52c4 1f			            DB  11111b  
52c5 1f			            DB  11111b  
52c6 1f			            DB  11111b  
52c7 1f			            DB  11111b  
52c8 1f			            DB  11111b  
52c9 1f			            DB  11111b  
52ca 1f			            DB  11111b  
52cb			;; Character 0x01 = Modifier  
52cb 1f			            DB  11111b  
52cc 1b			            DB  11011b  
52cd 1b			            DB  11011b  
52ce 1b			            DB  11011b  
52cf 1b			            DB  11011b  
52d0 1f			            DB  11111b  
52d1 1b			            DB  11011b  
52d2 1f			            DB  11111b  
52d3			  
52d3			  
52d3			  
52d3			  
52d3			; Display custom character 0  
52d3			;            LD   A, kLCD_Line1+14  
52d3			;            CALL fLCD_Pos       ;Position cursor to location in A  
52d3			;            LD   A, 0  
52d3			;            CALL fLCD_Data      ;Write character in A at cursor  
52d3			  
52d3			; Display custom character 1  
52d3			;            LD   A, kLCD_Line2+14  
52d3			;            CALL fLCD_Pos      ;Position cursor to location in A  
52d3			;            LD   A, 1  
52d3			;            CALL fLCD_Data     ;Write character in A at cursor  
52d3			  
52d3			; keyboard scanning   
52d3			  
52d3			  
52d3			; key_rows: equ 4  
52d3			; key_cols: equ 4  
52d3			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
52d3			  
52d3			; key_scanr: equ key_row_bitmask  
52d3			; key_scanc: equ key_col_bitmask  
52d3			  
52d3			; key_char_map: equ key_map  
52d3			  
52d3			  
52d3			  
52d3			; character in from keyboard  
52d3			  
52d3 ..			.matrix_to_char: db "D#0*C987B654A321"  
52e3			  
52e3			  
52e3			; map the physical key to a char dependant on state  
52e3			  
52e3			.key_map_fa:   
52e3			  
52e3 ..					db 'D'  
52e4 0d					db KEY_CR    ; cr  
52e5 ..					db ' '  
52e6 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
52e7 ..					db 'C'  
52e8 ..					db 'y'  
52e9 ..					db 'v'  
52ea ..					db 's'  
52eb ..					db 'B'  
52ec ..					db 'p'  
52ed ..					db 'm'  
52ee ..					db 'j'  
52ef ..					db 'A'  
52f0 ..					db 'g'  
52f1 ..					db 'd'  
52f2 ..					db 'a'  
52f3			  
52f3			.key_map_fb:  
52f3			  
52f3 ..					db 'A'  
52f4 ..					db '+'   
52f5 ..					db '<'  
52f6 ..					db  "'"    
52f7			  
52f7 ..					db 'A'  
52f8 ..					db 'z'  
52f9 ..					db 'w'  
52fa ..					db 't'  
52fb ..					db 'A'  
52fc ..					db 'q'  
52fd ..					db 'n'  
52fe ..					db 'k'  
52ff ..					db 'A'  
5300 ..					db 'h'  
5301 ..					db 'e'  
5302 ..			 		db 'b'  
5303			  
5303			.key_map_fc:   
5303			  
5303			  
5303 ..					db 'A'  
5304 ..					db '-'   
5305 ..					db '>'  
5306 ..					db  '='   	  
5307 ..					db 'A'  
5308 ..					db '?'  
5309 ..					db 'x'  
530a ..					db 'u'  
530b ..					db 'A'  
530c ..					db 'r'  
530d ..					db 'o'  
530e ..					db 'l'  
530f ..					db 'A'  
5310 ..					db 'i'  
5311 ..					db 'f'  
5312 ..					db 'c'  
5313			  
5313				  
5313			.key_map_fd:  
5313			  
5313 ..					db 'A'  
5314 ..					db '/'   
5315 ..					db '%'   
5316 08					db KEY_BS  ; back space  
5317 ..					db 'A'  
5318 ..					db '!'  
5319 ..					db '@'  
531a ..					db ';'  
531b ..					db 'A'  
531c ..					db ':'  
531d ..					db '.'  
531e ..					db ','  
531f ..					db 'A'  
5320 ..					db '$'  
5321 ..					db '&'  
5322 ..				 	db '"'  
5323			  
5323					  
5323				  
5323			  
5323			; add cin and cin_wait  
5323			  
5323 cd 34 53		cin_wait: 	call cin  
5326 fe 00			cp 0  
5328 28 f9			jr z, cin_wait   ; block until key press  
532a			  
532a f5				push af   ; save key pressed  
532b			  
532b cd 34 53		.cin_wait1:	call cin  
532e fe 00			cp 0  
5330 20 f9			jr nz, .cin_wait1  	; wait for key release  
5332			  
5332 f1				pop af   ; get key  
5333 c9				ret  
5334			  
5334			  
5334 cd 45 53		cin: 	call .mtoc  
5337			  
5337				; no key held  
5337 fe 00			cp 0  
5339 c8				ret z  
533a			  
533a				; stop key bounce  
533a			  
533a			;	ld (key_held),a		 ; save it  
533a 47				ld b, a  
533b			  
533b c5			.cina1:	push bc  
533c cd 45 53			call .mtoc  
533f c1				pop bc  
5340 b8				cp b  
5341 28 f8			jr z, .cina1  
5343 78				ld a,b		  
5344 c9				ret  
5345			  
5345			; detect keyboard modifier key press and apply new overlay to the face key held  
5345			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
5345			  
5345			;.cin_map_modifier:   
5345			;	ld a, (hl)  
5345			;	and 255  
5345			;	ret NZ		; modifier key not flagged  
5345			;  
5345			;	; get key face  
5345			;  
5345			;	ld b,(key_face_held)  
5345			;  
5345			;	ld b, key_cols * key_rows  
5345			;  
5345			;	push de  
5345			;	pop hl  
5345			;  
5345			;.mmod1: ld a,(hl)   ; get map test  
5345			;	cp b  
5345			;	jr z, .mmod2  
5345			;  
5345			;  
5345			;  
5345			;.mmod2: inc hl    ;   
5345			;  
5345			;	  
5345			;  
5345			;	  
5345			;  
5345			;	ld hl,key_actual_pressed  
5345			;	ld (hl),a,  
5345			;	ret  
5345			  
5345				  
5345			  
5345			; map matrix key held to char on face of key  
5345			  
5345			.mtoc:  
5345			  
5345			  
5345				; TODO optimise the code....  
5345			  
5345			; scan keyboard row 1  
5345 3e 80			ld a, 128  
5347 21 d3 fb			ld hl, keyscan_table  
534a cd 2c 54			call .rowscan  
534d			  
534d				   
534d			  
534d 3e 40			ld a, 64  
534f 21 d7 fb			ld hl, keyscan_table+key_cols  
5352 cd 2c 54			call .rowscan  
5355			  
5355			  
5355			  
5355			  
5355 3e 20			ld a, 32  
5357 21 db fb			ld hl, keyscan_table+(key_cols*2)  
535a cd 2c 54			call .rowscan  
535d			  
535d			  
535d			  
535d 3e 10			ld a, 16  
535f 21 df fb			ld hl, keyscan_table+(key_cols*3)  
5362 cd 2c 54			call .rowscan  
5365			  
5365			  
5365				; flag if key D is held down and remove from reporting  
5365 01 13 53			ld bc, .key_map_fd    
5368 21 d3 fb			ld hl, keyscan_table  
536b 11 c5 fb			ld de, key_fd  
536e cd be 53			call .key_shift_hold  
5371 fe ff			cp 255  
5373 28 33			jr z, .cinmap  
5375				; flag if key C is held down and remove from reporting  
5375 01 03 53			ld bc, .key_map_fc    
5378 21 d7 fb			ld hl, keyscan_table+key_cols  
537b 11 c6 fb			ld de, key_fc  
537e cd be 53			call .key_shift_hold  
5381 fe ff			cp 255  
5383 28 23			jr z, .cinmap  
5385				; flag if key B is held down and remove from reporting  
5385 01 f3 52			ld bc, .key_map_fb    
5388 21 db fb			ld hl, keyscan_table+(key_cols*2)  
538b 11 c7 fb			ld de, key_fb  
538e cd be 53			call .key_shift_hold  
5391 fe ff			cp 255  
5393 28 13			jr z, .cinmap  
5395				; flag if key A is held down and remove from reporting  
5395 01 e3 52			ld bc, .key_map_fa    
5398 21 df fb			ld hl, keyscan_table+(key_cols*3)  
539b 11 c8 fb			ld de, key_fa  
539e cd be 53			call .key_shift_hold  
53a1 fe ff			cp 255  
53a3 28 03			jr z, .cinmap  
53a5			  
53a5 11 d3 52			ld de, .matrix_to_char  
53a8			  
53a8			  
53a8			.cinmap:   
53a8				if DEBUG_KEY  
53a8			            LD   A, kLCD_Line4  
53a8			            CALL fLCD_Pos       ;Position cursor to location in A  
53a8					push de  
53a8			            LD   DE, keyscan_table  
53a8			            CALL fLCD_Str       ;Display string pointed to by DE  
53a8					pop de  
53a8				endif  
53a8			  
53a8				; scan key matrix table for any held key  
53a8			  
53a8				; de holds either the default matrix or one selected above  
53a8			  
53a8 21 d3 fb			ld hl, keyscan_table  
53ab 06 10			ld b,key_cols*key_rows  
53ad			  
53ad 7e			.cin1:	ld a,(hl)  
53ae fe 23			cp '#'  
53b0 28 08			jr z, .cinhit  
53b2 23				inc hl  
53b3 13				inc de  
53b4 05				dec b  
53b5 20 f6			jr nz, .cin1  
53b7				; no key found held  
53b7 3e 00			ld a,0  
53b9 c9				ret  
53ba d5			.cinhit: push de  
53bb e1				pop hl  
53bc 7e				ld a,(hl)  
53bd c9				ret  
53be			  
53be			; flag a control key is held   
53be			; hl is key pin, de is flag indicator  
53be			  
53be			.key_shift_hold:  
53be c5				push bc  
53bf 3e 01			ld a, 1  
53c1 32 56 fa			ld (cursor_shape),a  
53c4 06 00			ld b, 0  
53c6 7e				ld a, (hl)  
53c7 fe 2e			cp '.'  
53c9 28 0a			jr z, .key_shift1  
53cb 06 ff			ld b, 255  
53cd 3e 2b			ld a, '+'    ; hide key from later scans  
53cf 77				ld (hl),a  
53d0 3e 02			ld a, 2  
53d2 32 56 fa			ld (cursor_shape),a  
53d5			.key_shift1:  
53d5				; write flag indicator  
53d5 78				ld a,b  
53d6 12				ld (de),a  
53d7			  
53d7 d1				pop de    ; de now holds the key map ptr  
53d8 c9				ret  
53d9			  
53d9				  
53d9				  
53d9			  
53d9			  
53d9			  
53d9			  
53d9			  
53d9			  
53d9			  
53d9			  
53d9			  
53d9			  
53d9 c9				ret  
53da			  
53da			;	push hl  
53da			;	push de  
53da			;	push bc  
53da			;	call keyscan  
53da			;	; map key matrix to ascii value of key face  
53da			;  
53da			;	ld hl, key_face_map  
53da			;	ld de, keyscan_table  
53da			;  
53da			;	; get how many keys to look at  
53da			;	ld b, keyscan_table_len  
53da			;	  
53da			;  
53da			;	; at this stage fall out on first key hit  
53da			;	; TODO handle multiple key press  
53da			;  
53da			;map1:	ld a,(hl)  
53da			;	cp '#'  
53da			;	jr z, keyhit  
53da			;	inc hl  
53da			;	inc de  
53da			;	dec b  
53da			;	jr nz, map1  
53da			;nohit:	ld a, 0  
53da			;	jr keydone  
53da			;keyhit: push de  
53da			;	pop hl  
53da			;	ld a,(hl)  
53da			;keydone:  
53da			;	push bc  
53da			;	push de  
53da			; 	push hl  
53da			;	ret   
53da			;  
53da			  
53da			  
53da			  
53da			  
53da			; scan physical key matrix  
53da			  
53da			  
53da			;keyscan:  
53da			;  
53da			;; for each key_row use keyscanr bit mask for out  
53da			;; then read in for keyscanc bitmask  
53da			;; save result of row scan to keyscantable  
53da			;  
53da			;; scan keyboard row 1  
53da			;  
53da			;	ld b, key_rows  
53da			;	ld hl, key_scanr  
53da			;	ld de, keyscan_table  
53da			;  
53da			;rowloop:  
53da			;  
53da			;	ld a,(hl)		; out bit mask to energise keyboard row  
53da			;	call rowscan  
53da			;	inc hl  
53da			;	dec b  
53da			;	jr nz, rowloop  
53da			;  
53da			;	ret  
53da			;  
53da			;  
53da			;; pass a out bitmask, b row number  
53da			;arowscan:   
53da			;	push bc  
53da			;  
53da			;	ld d, b  
53da			;  
53da			;	; calculate buffer location for this row  
53da			;  
53da			;	ld hl, keyscan_table	  
53da			;kbufr:  ld e, key_cols  
53da			;kbufc:	inc hl  
53da			;	dec e  
53da			;	jr nz, kbufc  
53da			;	dec d  
53da			;	jr nz, kbufr  
53da			;  
53da			;	; energise row and read columns  
53da			;  
53da			;	out (portbdata),a  
53da			;	in a,(portbdata)  
53da			;	ld c,a  
53da			;  
53da			;  
53da			;	; save buffer loc  
53da			;  
53da			;	ld (keybufptr), hl  
53da			;  
53da			;	ld hl, key_scanc  
53da			;	ld d, key_cols  
53da			;  
53da			;	; for each column check each bit mask  
53da			;  
53da			;colloop:  
53da			;	  
53da			;  
53da			;	; reset flags for the row   
53da			;  
53da			;	ld b,'.'  
53da			;	and (hl)  
53da			;	jr z, maskskip  
53da			;	ld b,'#'  
53da			;maskskip:  
53da			;	; save  key state  
53da			;	push hl  
53da			;	ld hl, (keybufptr)  
53da			;	ld (hl), b  
53da			;	inc hl  
53da			;	ld (keybufptr), hl  
53da			;  
53da			;	; move to next bit mask  
53da			;	pop hl  
53da			;	inc hl  
53da			;  
53da			;	dec d  
53da			;	jr nz, colloop  
53da			;  
53da			;	ret  
53da			;  
53da			;  
53da			;;  
53da			; lcd functions  
53da			;  
53da			;  
53da			  
53da			;if DEBUG_KEY_MATRIX  
53da			  
53da			; test function to display hardware view of matrix state  
53da			  
53da			matrix:  
53da			  
53da			  
53da			  
53da			; scan keyboard row 1  
53da 3e 80			ld a, 128  
53dc 21 f8 fb			ld hl, keyscan_table_row1  
53df cd 2c 54			call .rowscan  
53e2			  
53e2 3e 40			ld a, 64  
53e4 21 f3 fb			ld hl, keyscan_table_row2  
53e7 cd 2c 54			call .rowscan  
53ea			  
53ea 3e 20			ld a, 32  
53ec 21 ee fb			ld hl, keyscan_table_row3  
53ef cd 2c 54			call .rowscan  
53f2			  
53f2 3e 10			ld a, 16  
53f4 21 e9 fb			ld hl, keyscan_table_row4  
53f7 cd 2c 54			call .rowscan  
53fa			  
53fa			; Display text on first line  
53fa 3e 00		            LD   A, kLCD_Line1  
53fc cd 52 52		            CALL fLCD_Pos       ;Position cursor to location in A  
53ff 11 f8 fb		            LD   DE, keyscan_table_row1  
5402			            ;LD   DE, MsgHello  
5402 cd 5a 52		            CALL fLCD_Str       ;Display string pointed to by DE  
5405			  
5405			; Display text on second line  
5405 3e 40		            LD   A, kLCD_Line2  
5407 cd 52 52		            CALL fLCD_Pos       ;Position cursor to location in A  
540a 11 f3 fb		            LD   DE, keyscan_table_row2  
540d cd 5a 52		            CALL fLCD_Str       ;Display string pointed to by DE  
5410 3e 14		            LD   A, kLCD_Line3  
5412 cd 52 52		            CALL fLCD_Pos       ;Position cursor to location in A  
5415 11 ee fb		            LD   DE, keyscan_table_row3  
5418 cd 5a 52		            CALL fLCD_Str       ;Display string pointed to by DE  
541b 3e 54		            LD   A, kLCD_Line4  
541d cd 52 52		            CALL fLCD_Pos       ;Position cursor to location in A  
5420 11 e9 fb		            LD   DE, keyscan_table_row4  
5423 cd 5a 52		            CALL fLCD_Str       ;Display string pointed to by DE  
5426			  
5426 cd 32 09			call delay250ms  
5429 c3 da 53			jp matrix  
542c			  
542c			; pass de as row display flags  
542c			.rowscan:   
542c d3 c1			out (portbdata),a  
542e db c1			in a,(portbdata)  
5430 4f				ld c,a  
5431				; reset flags for the row   
5431 06 2e			ld b,'.'  
5433 e6 01			and 1  
5435 28 02			jr z, .p1on  
5437 06 23			ld b,'#'  
5439			.p1on:  
5439 70				ld (hl), b  
543a 23				inc hl  
543b			  
543b 06 2e			ld b,'.'  
543d 79				ld a,c  
543e e6 02			and 2  
5440			;	bit 0,a  
5440 28 02			jr z, .p2on  
5442 06 23			ld b,'#'  
5444			.p2on:  
5444 70				ld (hl), b  
5445 23				inc hl  
5446			;  
5446 06 2e			ld b,'.'  
5448 79				ld a,c  
5449 e6 04			and 4  
544b			;;	bit 0,a  
544b 28 02			jr z, .p3on  
544d 06 23			ld b,'#'  
544f			.p3on:  
544f 70				ld (hl), b  
5450 23				inc hl  
5451			;;  
5451 06 2e			ld b,'.'  
5453			;;	bit 0,a  
5453 79				ld a,c  
5454 e6 08			and 8  
5456 28 02			jr z, .p4on  
5458 06 23			ld b,'#'  
545a			.p4on:  
545a 70				ld (hl), b  
545b 23				inc hl  
545c			  
545c			; zero term  
545c 06 00			ld b,0  
545e 70				ld (hl), b  
545f			  
545f c9			.rscandone: ret  
5460			  
5460			  
5460			  
5460			;endif  
5460			  
5460			  
5460			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
5460
