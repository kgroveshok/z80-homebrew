# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 4e 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-08-06 12:30' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b			 
801b			 
801b			 
801b			;        nop  
801b			;        nop 
801b			;;	org 05h		; null out bdos call 
801b			; 
801b			;        nop  
801b			;        nop  
801b			;        nop 
801b			;;	org 08h 
801b			;;; 
801b			;;	jp cin		; rst 8 - char in 
801b			;;; 
801b			; 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;        nop 
801b			;	org 010h 
801b			;; 
801b			;	jp cout		; rest 010h  - char out 
801b			;; 
801b			;	org 01bh   
801b			; 
801b			;	;jp  		; rst 01bh   - write string to display 
801b			;	jp str_at_display 
801b			; 
801b			; 
801b			;	org 020h 
801b			; 
801b			;	; jp		 ; rst 020h - read char at screen location 
801b			; 
801b			;	org 028h 
801b			 
801b				; jp		 ; rst 028h  - storage i/o 
801b			 
801b			; 	org 030h 
801b			;	jp break_point_state 
801b			  
801b			; $30  
801b			; org 038h 
801b			; $38 
801b			 
801b			; TODO any more important entry points to add to jump table for easier coding use? 
801b			 
801b			if BASE_KEV = 1  
801b			 
801b				; need to be at $66 for nmi support 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255,0,255,0,255 
801b				db 0,255 
801b				jp nmi 
801b			endif 
801b			 
801b			include "firmware.asm" 
801b			  
801b			; main constants (used here and in firmware)  
801b			  
801b			; TODO have page 0 of storage as bios  
801b			  
801b			Device_A: equ 0h  
801b			Device_B: equ 040h          ; Sound  
801b			  
801b			if BASE_KEV  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_SC114  
801b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			; TODO fixup for CPM  
801b			Device_C: equ 080h          ; Storage and ext cart devices  
801b			endif  
801b			  
801b			Device_D: equ 0c0h             ; Keyboard and LCD  
801b			  
801b			; Odd specific debug points for testing hardware dev  
801b			  
801b			DEBUG_SOUND: equ 0       
801b			DEBUG_STK_FAULT: equ 0  
801b			DEBUG_INPUT: equ 0     ; Debug input entry code  
801b			DEBUG_KEYCINWAIT: equ 0  
801b			DEBUG_KEYCIN: equ 0  
801b			DEBUG_KEY: equ 0  
801b			DEBUG_KEY_MATRIX: equ 0  
801b			DEBUG_STORECF: equ 0  
801b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801b			DEBUG_SPI: equ 0    ; low level spi tests  
801b			  
801b			; Enable many break points  
801b			  
801b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801b			DEBUG_FORTH_JP: equ 0    ; 4  
801b			DEBUG_FORTH_MALLOC: equ 0  
801b			DEBUG_FORTH_MALLOC_INT: equ 0  
801b			DEBUG_FORTH_DOT: equ 1  
801b			DEBUG_FORTH_DOT_WAIT: equ 0  
801b			DEBUG_FORTH_MATHS: equ 0  
801b			DEBUG_FORTH_TOK: equ 0    ; 4  
801b			DEBUG_FORTH_PARSE: equ 0    ; 3  
801b			DEBUG_FORTH: equ 0  ;2  
801b			DEBUG_FORTH_WORDS: equ 1   ; 1  
801b			DEBUG_FORTH_PUSH: equ 1   ; 1  
801b			DEBUG_FORTH_UWORD: equ 1   ; 1  
801b			  
801b			; Enable key point breakpoints  
801b			  
801b			DEBUG_FORTH_DOT_KEY: equ 0  
801b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801b			  
801b			; Debug stack imbalances  
801b			  
801b			ON: equ 1  
801b			OFF: equ 0  
801b			  
801b			DEBUG_STACK_IMB: equ 0  
801b			STACK_IMB_STORE: equ 20  
801b			  
801b			; House keeping and protections  
801b			  
801b			DEBUG_FORTH_STACK_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801b			FORTH_ENABLE_FREE: equ 0  
801b			FORTH_ENABLE_MALLOCFREE: equ 1  
801b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801b			FORTH_ENABLE_FLOATMATH: equ 0  
801b			  
801b			  
801b			CALLMONITOR: macro  
801b			;	call break_point_state  
801b			; now use the break point debug vector  
801b				call debug_vector  
801b				endm  
801b			  
801b			MALLOC_1: equ 1        ; from dk88   
801b			MALLOC_2: equ 0           ; broke  
801b			MALLOC_3: equ 0           ; really broke  
801b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801b			  
801b			if BASE_KEV   
801b			stacksize: equ 256  
801b			  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 512  
801b			endif  
801b			if BASE_SC114  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			if BASE_CPM  
801b			;tos:	equ 0f000h  
801b			stacksize: equ 256  
801b			STACK_RET_SIZE: equ 64  
801b			STACK_LOOP_SIZE: equ 128  
801b			STACK_DATA_SIZE: equ 256  
801b			endif  
801b			  
801b			;if STORAGE_SE == 0  
801b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801b			;endif  
801b			  
801b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801b			  
801b			STORE_0_AUTORUN: equ $20  
801b			  
801b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801b			  
801b			STORE_0_AUTOFILE: equ $21  
801b			STORE_0_BANKRUN: equ $23  
801b			STORE_0_FILERUN: equ $24  
801b			  
801b			; Block 0 offsets for settings  
801b			  
801b			; if set then skip prompt for start up and accept all  
801b			  
801b			STORE_0_QUICKSTART: equ $25  
801b			  
801b			; Blocks where directory table is held  
801b			  
801b			; Reducing the number of entries increases the max file size  
801b			  
801b			;STORE_DIR_START: equ 1  
801b			;STORE_DIR_END: equ 33  
801b			  
801b			; Blocks from where file data is stored  
801b			  
801b			;STORE_DATA_START: equ STORE_DIR_END + 1  
801b			  
801b			; Block indicators (<32 are data files)  
801b			  
801b			;STORE_BLOCK_CFG: equ $8f       ; config block  
801b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801b			;STORE_BLOCK_FREE: equ $85       ; data block free  
801b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801b			  
801b			  
801b			  
801b			; Directory entry flags  
801b			  
801b			;STORE_DIR_FREE: equ 0  
801b			;STORE_DIR_FILE:  equ 1  
801b			  
801b			; Structure offsets to directory entries  
801b			;STORE_DE_FLAG: equ 0  
801b			;STORE_DE_MAXEXT: equ 1  
801b			;STORE_DE_FILENAME: equ 2  
801b			  
801b			; Structure offsets to block 0  
801b			  
801b			;STORE_BK0_ISFOR: equ 1  
801b			;STORE_BK0_LABEL: equ 3  
801b			  
801b			; memory allocation   
801b			  
801b			chk_stund: equ tos+2           ; underflow check word  
801b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801b			  
801b			; keyscan table needs rows x cols buffer  
801b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801b			  
801b			keyscan_table_row1: equ chk_stovr -key_cols-1  
801b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801b			keyscan_scancol: equ keyscan_table-key_cols  
801b			;keyscan_table_len: equ key_rows*key_cols  
801b			;keybufptr: equ keyscan_table - 2  
801b			;keysymbol: equ keybufptr - 1  
801b			key_held: equ keyscan_scancol-1	; currently held  
801b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801b			key_fa: equ key_repeat_ct -1 ;  
801b			key_fb: equ key_fa -1 ;  
801b			key_fc: equ key_fb -1 ;  
801b			key_fd: equ key_fc -1 ;  
801b			key_face_held: equ key_fd - 1   
801b			  
801b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801b			  
801b			hardware_config: equ key_face_held - 10  
801b			  
801b			; hardware config switches  
801b			; TODO add bitmasks on includes for hardware  
801b			; high byte for expansion ids  
801b			;     0000 0000  no card inserted  
801b			;     0000 0001  storage card inserted  
801b			;     0000 0010  spi sd card active  
801b			  
801b			;       
801b			; low byte:  
801b			;     0000 0001   4x4 keypad  
801b			;     0000 0010   full keyboard  
801b			;     0000 0011   spi/ext keyboard  
801b			;     0000 0100   20x4 lcd  
801b			;     0000 1000   40x4 lcd  
801b			;     0000 1100   spi/ext display  
801b			;     0001 0000   ide interface available  
801b			  
801b			hardware_word: equ hardware_config - 2  
801b			  
801b			; debug marker - optional display of debug point on the debug screens  
801b			  
801b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801b			  
801b			debug_mark: equ debug_vector - 4  
801b			  
801b			; input_str vars  
801b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801b			input_size: equ input_start -1  ; number of chars  
801b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801b			input_len: equ input_cur_onoff - 5 ; length of current input  
801b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801b			  
801b			CUR_BLINK_RATE: equ 15  
801b			  
801b			key_actual_pressed: equ input_cursor - 1   
801b			key_symbol: equ key_actual_pressed - 1   
801b			key_shift: equ key_symbol - 1   
801b			  
801b			; Display allocation  
801b			  
801b			;display_rows: equ 4     ; move out to mini and mega files  
801b			;display_cols: equ 20  
801b			  
801b			display_fb_len: equ display_rows*display_cols  
801b			  
801b			; primary frame buffer     
801b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801b			; working frame buffers  
801b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801b			display_fb3: equ  display_fb1-display_fb_len - 1  
801b			display_fb2: equ  display_fb3-display_fb_len - 1  
801b			;  
801b			; pointer to active frame buffer  
801b			display_fb_active: equ display_fb2 - 2  
801b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801b			display_write_tmp: equ display_lcde1e2 - 2  
801b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801b			  
801b			;  
801b			  
801b			;; can load into de directory  
801b			cursor_col: equ display_active-1  
801b			cursor_row: equ cursor_col-1  
801b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801b			  
801b			; maths vars  
801b			  
801b			LFSRSeed: equ cursor_shape -20   
801b			randData: equ LFSRSeed - 2  
801b			xrandc: equ randData - 2  
801b			stackstore: equ xrandc - 2  
801b			seed1: equ  stackstore -2   
801b			seed2: equ seed1 - 2  
801b			  
801b			; cf storage vars  
801b			  
801b			iErrorNum:  equ seed2-1         ;Error number  
801b			iErrorReg:  equ iErrorNum -1              ;Error register  
801b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801b			  
801b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801b			  
801b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801b			  
801b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801b			store_tmpid: equ store_tmp3 - 1		; page temp id  
801b			store_tmpext: equ store_tmpid - 1		; file extent temp  
801b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801b			;  
801b			; spi vars  
801b			  
801b			  
801b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801b			spi_device_id: equ spi_device - 1    ; human readable bank number  
801b			  
801b			;;;;; forth cli params  
801b			  
801b			; TODO use a different frame buffer for forth???  
801b			  
801b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801b			  
801b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801b			  
801b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801b			  
801b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801b			  
801b			; os/forth token vars  
801b			  
801b			os_last_cmd: equ os_var_array-255  
801b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801b			os_current_i: equ os_cli_cmd-2  
801b			os_cur_ptr: equ os_current_i-2  
801b			os_word_scratch: equ os_cur_ptr-30  
801b			os_tok_len: equ os_word_scratch - 2  
801b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801b			os_tok_malloc: equ os_tok_ptr - 2  
801b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801b			execscratch: equ os_input-255        ; exec cmd eval buffer  
801b			scratch: equ execscratch-255  
801b			  
801b			os_stack_1: equ scratch - 3       ; stack holding area 1  
801b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801b			  
801b			  
801b			; temp locations for new word processing to save on adding more   
801b			  
801b			os_new_malloc: equ os_stack_4-2  
801b			os_new_parse_len: equ os_new_malloc - 2  
801b			os_new_word_len: equ os_new_parse_len - 2  
801b			os_new_work_ptr: equ os_new_word_len - 2  
801b			os_new_src_ptr: equ os_new_work_ptr - 2  
801b			os_new_exec: equ os_new_src_ptr - 2  
801b			os_new_exec_ptr: equ os_new_exec - 2  
801b			  
801b			; resume memory alloocations....  
801b			  
801b			;os_view_disable: equ os_new_exec_ptr - 1  
801b			os_view_af: equ os_new_exec_ptr - 2  
801b			os_view_hl: equ os_view_af -2  
801b			os_view_de: equ os_view_hl - 2  
801b			os_view_bc: equ os_view_de - 2  
801b			  
801b			; stack checksum word  
801b			if DEBUG_STACK_IMB  
801b				curframe: equ  os_view_de - 5  
801b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			else  
801b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801b			endif  
801b			  
801b			; with data stack could see memory filled with junk. need some memory management   
801b			; malloc and free entry points added  
801b			  
801b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			;heap_end: equ free_list-1  ; Starting address of heap  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			  
801b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801b			heap_end: equ chk_word-1  ; Starting address of heap  
801b			  
801b			  
801b			;if BASE_KEV   
801b			;heap_start: equ 0800eh  ; Starting address of heap  
801b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;heap_start: equ baseram+15  ; Starting address of heap  
801b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801b			;endif  
801b			  
801b			  
801b			;;;;  
801b			  
801b			  
801b			; change below to point to last memory alloc above  
801b			topusermem:  equ   heap_start  
801b			  
801b			;if BASE_KEV   
801b			;baseusermem: equ 08000h  
801b			;endif  
801b			  
801b			;if BASE_SC114  
801b			;;aseusermem:     equ    12  
801b			;baseusermem:     equ    prompt  
801b			;;baseusermem:     equ    endofcode  
801b			;endif  
801b			  
801b			  
801b			; **********************************************************************  
801b			; **  Constants  
801b			; **********************************************************************  
801b			  
801b			; Constants used by this code module  
801b			kDataReg:   EQU Device_D           ;PIO port A data register  
801b			kContReg:   EQU Device_D+2           ;PIO port A control register  
801b			  
801b			  
801b			portbdata:  equ Device_D+1    ; port b data  
801b			portbctl:   equ Device_D+3    ; port b control  
801b			  
801b			  
801b			;KEY_SHIFT:   equ 5  
801b			;KEY_SYMBOLSHIFT:  equ 6  
801b			  
801b			KEY_SHIFTLOCK: equ 4  
801b			  
801b			  
801b			KEY_UP: equ 5  
801b			KEY_NEXTWORD: equ 6  
801b			KEY_PREVWORD: equ 7  
801b			KEY_BS: equ 8  
801b			KEY_TAB:  equ 9  
801b			KEY_DOWN: equ 10  
801b			KEY_LEFT: equ 11  
801b			KEY_RIGHT: equ 12  
801b			KEY_CR:   equ 13  
801b			KEY_HOME: equ 14  
801b			KEY_END: equ 15  
801b			  
801b			KEY_F1: equ 16  
801b			KEY_F2: equ 17  
801b			KEY_F3: equ 18  
801b			KEY_F4: equ 19  
801b			  
801b			KEY_F5: equ 20  
801b			KEY_F6: equ 21  
801b			KEY_F7: equ 22  
801b			KEY_F8: equ 23  
801b			  
801b			KEY_F9: equ 24  
801b			KEY_F10: equ 25  
801b			KEY_F11: equ 26  
801b			KEY_F12: equ 27  
801b			  
801b			;if DEBUG_KEY  
801b			;	KEY_MATRIX_NO_PRESS: equ '.'  
801b			;	KEY_SHIFT:   equ '.'  
801b			;	KEY_SYMBOLSHIFT:  equ '.'  
801b			;else  
801b				KEY_SHIFT:   equ '~'  
801b				KEY_SYMBOLSHIFT:  equ '~'  
801b				KEY_MATRIX_NO_PRESS: equ '~'  
801b			;endi  
801b			  
801b			  
801b			  
801b			  
801b			; Macro to make adding debug marks easier  
801b			  
801b			DMARK: macro str  
801b				push af  
801b				ld a, (.dmark)  
801b				ld (debug_mark),a  
801b				ld a, (.dmark+1)  
801b				ld (debug_mark+1),a  
801b				ld a, (.dmark+2)  
801b				ld (debug_mark+2),a  
801b				jr .pastdmark  
801b			.dmark: db str  
801b			.pastdmark: pop af  
801b			  
801b			endm  
801b			  
801b			  
801b			; macro to detect for stack imbalances  
801b			  
801b			include "stackimbal.asm"  
801b			; Macro and code to detect stock imbalances 
801b			 
801b			SPPUSH: equ 0 
801b			 
801b			; Add a stack frame which can be checked before return 
801b			 
801b			STACKFRAME: macro onoff frame1 frame2 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b						exx 
801b			 
801b						ld de, frame1 
801b						ld a, d 
801b						ld hl, curframe 
801b						call hexout 
801b						ld a, e 
801b						ld hl, curframe+2 
801b						call hexout 
801b			  
801b						ld hl, frame1 
801b						push hl 
801b						ld hl, frame2 
801b						push hl 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			endm 
801b			 
801b			STACKFRAMECHK: macro onoff frame1 frame2 
801b			 
801b					 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						exx 
801b						; check stack frame SP 
801b			 
801b						ld hl, frame2 
801b						pop de   ; frame2 
801b			 
801b						call cmp16 
801b						jr nz, .spnosame 
801b						 
801b			 
801b						ld hl, frame1 
801b						pop de   ; frame1 
801b			 
801b						call cmp16 
801b						jr z, .spfrsame 
801b			 
801b						.spnosame: call showsperror 
801b			 
801b						.spfrsame: nop 
801b			 
801b						exx 
801b					endif 
801b					 
801b				endif 
801b			 
801b			 
801b			endm 
801b			 
801b			 
801b			; for a sub routine, wrap SP collection and comparisons 
801b			 
801b			; Usage: 
801b			; 
801b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801b			 
801b			SAVESP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b						; save current SP 
801b			 
801b						ld (store_sp+(storeword*4)), sp 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			CHECKSP: macro onoff storeword 
801b			 
801b				if DEBUG_STACK_IMB 
801b					if onoff 
801b			 
801b						; save SP after last save 
801b				 
801b						ld (store_sp+(storeword*4)+2), sp 
801b			 
801b						push hl 
801b						ld hl, store_sp+(storeword*4) 
801b						call check_stack_sp  
801b						pop hl 
801b			 
801b			 
801b					endif 
801b					 
801b				endif 
801b			 
801b			endm 
801b			 
801b			if DEBUG_STACK_IMB 
801b			 
801b			check_stack_sp: 
801b					push de 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					push de 
801b			 
801b			 
801b					ld e, (hl) 
801b					inc hl 
801b					ld d, (hl) 
801b					inc hl 
801b			 
801b					pop hl 
801b			 
801b			 
801b					; check to see if the same 
801b			 
801b					call cmp16 
801b					jr z, .spsame 
801b			 
801b					; not same 
801b			 
801b					call showsperror 
801b			.spsame: 
801b			 
801b					pop de 
801b			 
801b					ret 
801b			 
801b			.sperr:  db "Stack imbalance",0 
801b			 
801b			 
801b			showsperror: 
801b			 
801b			 
801b				push hl 
801b				push af 
801b				push de 
801b				call clear_display 
801b				ld de, .sperr 
801b				ld a,0 
801b			;	ld de,os_word_scratch 
801b				call str_at_display 
801b				ld a, display_row_1+17 
801b				ld de, debug_mark 
801b				call str_at_display 
801b				ld a, 0 
801b				ld (curframe+4),a 
801b				ld hl, curframe 
801b				ld de, os_word_scratch 
801b				ld a, display_row_4 
801b				call str_at_display 
801b				call update_display 
801b				;call break_point_state 
801b				call cin_wait 
801b			 
801b			;	ld a, ' ' 
801b			;	ld (os_view_disable), a 
801b				call bp_on 
801b				pop de	 
801b				pop af 
801b				pop hl 
801b				CALLMONITOR 
801b				ret 
801b			 
801b			endif 
801b			 
801b			 
801b			 
801b			; eof 
# End of file stackimbal.asm
801b			  
801b			;TODO macro to calc col and row offset into screen  
801b			  
801b			  
801b			  
801b			hardware_init:  
801b			  
801b				  
801b			  
801b					;ld a, 0  
801b					;ld (hardware_diag), a  
801b			  
801b					; clear all the buffers  
801b			  
801b 21 10 ed				ld hl, display_fb1  
801e 22 cc eb				ld (display_fb_active), hl  
8021			  
8021 cd ae 8a				call clear_display  
8024			  
8024 21 ce eb				ld hl, display_fb2  
8027 22 cc eb				ld (display_fb_active), hl  
802a			  
802a cd ae 8a				call clear_display  
802d			  
802d					; init primary frame buffer area  
802d 21 b1 ed				ld hl, display_fb0  
8030 22 cc eb				ld (display_fb_active), hl  
8033			  
8033 cd ae 8a				call clear_display  
8036			  
8036			  
8036 cd b9 e3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8039			  
8039 cd 5b e4			call key_init  
803c cd 9e 80			call storage_init  
803f			  
803f				; setup malloc functions  
803f			  
803f				if MALLOC_1  
803f cd 7e 91				call  heap_init  
8042				endif  
8042				if MALLOC_4  
8042					call  heap_init  
8042				endif  
8042			  
8042				; init sound hardware if present  
8042			  
8042				if SOUND_ENABLE  
8042					call sound_init  
8042				endif  
8042			  
8042				; lcd test sequence  
8042					  
8042 cd d1 8a			call update_display  
8045 cd f1 89			call delay1s  
8048 3e 2b			ld a,'+'  
804a cd b3 8a			call fill_display  
804d cd d1 8a			call update_display  
8050 cd f1 89			call delay1s  
8053 3e 2a			ld a,'*'  
8055 cd b3 8a			call fill_display  
8058 cd d1 8a			call update_display  
805b cd f1 89			call delay1s  
805e 3e 2d			ld a,'-'  
8060 cd b3 8a			call fill_display  
8063 cd d1 8a			call update_display  
8066 cd f1 89			call delay1s  
8069			  
8069			; boot splash screen  
8069			if display_cols == 20	  
8069			        ld a, display_row_1    
8069			else  
8069 3e 0a		        ld a, display_row_1 +10   
806b			endif  
806b 11 ac 96			ld de, prom_bootmsg  
806e cd c1 8a			call str_at_display  
8071 cd d1 8a			call update_display  
8074			  
8074			  
8074 cd f1 89			call delay1s  
8077 cd f1 89			call delay1s  
807a			if display_cols == 20	  
807a			            LD   A, display_row_3+2  
807a			else  
807a 3e 5c		            LD   A, display_row_3+12  
807c			endif  
807c 11 c1 96			ld de, prom_bootmsg1  
807f cd c1 8a			call str_at_display  
8082 cd d1 8a			call update_display  
8085 cd f1 89			call delay1s  
8088 cd f1 89			call delay1s  
808b			  
808b			;	ld a, display_row_4+3  
808b			;	ld de, bootmsg2  
808b			;	call str_at_display  
808b			;	call update_display  
808b			;	call delay1s  
808b			;	call delay1s  
808b			  
808b			; debug mark setup  
808b			  
808b 3e 5f		ld a, '_'  
808d 32 6b ee		ld (debug_mark),a  
8090 32 6c ee		ld (debug_mark+1),a  
8093 32 6d ee		ld (debug_mark+2),a  
8096 3e 00		ld a,0  
8098 32 6e ee		ld (debug_mark+3),a  
809b			  
809b c9					ret  
809c			  
809c			  
809c			;bootmsg2:	db "Firmware v0.1",0  
809c			  
809c			; a 4x20 lcd  
809c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809c			  
809c			;if display_cols == 20  
809c			;	include "firmware_lcd_4x20.asm"  
809c			;endif  
809c			  
809c			;if display_cols == 40  
809c			;	include "firmware_lcd_4x40.asm"  
809c			;endif  
809c			  
809c			;  
809c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809c			; TODO abstract the bit bang video out interface for dual display  
809c			; TODO wire video out to tx pin on rc2014 bus  
809c			  
809c			; must supply cin, and cin_wait for low level hardware abstraction   
809c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809c			; test scancode  
809c			  
809c			;;;;;  
809c			;;;  
809c			; Moved out to mini and maxi versions  
809c			;  
809c			; include "firmware_key_4x4.asm"  
809c			; using existing 4 wire x 4 resistor array for input  
809c			;include "firmware_key_4x10.asm"  
809c			; need to mod the board for 5 rows due to resistor array  
809c			;include "firmware_key_5x10.asm"  
809c			  
809c			; storage hardware interface  
809c			  
809c			; use microchip serial eeprom for storage  
809c			  
809c			  
809c			if STORAGE_SE  
809c				include "firmware_spi.asm"  
809c				include "firmware_seeprom.asm"  
809c			else  
809c			   ; create some stubs for the labels  
809c c9			se_readbyte: ret  
809d c9			se_writebyte: ret  
809e c9			storage_init: ret  
809f			  
809f			endif  
809f			  
809f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
809f			;include "firmware_cf.asm"  
809f			  
809f			; load up high level storage hardward abstractions  
809f			include "firmware_storage.asm"  
809f			 
809f			; persisent storage hardware abstraction layer  
809f			 
809f			 
809f			 
809f			; Block 0 on storage is a config state 
809f			 
809f			 
809f			 
809f			; TODO add read phy block and write phy block functions 
809f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
809f			 
809f			; Abstraction layer  
809f			 
809f			; Logocial block size is same size as physical size - using tape concept 
809f			 
809f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
809f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
809f			 
809f			 
809f			 
809f			; Filesystem layout (Logical layout) 
809f			; 
809f			; Block 0 - Bank config  
809f			; 
809f			;      Byte - 0 file id counter 
809f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
809f			;      Byte - 3-20 zero terminated bank label 
809f			; 
809f			; Block 1 > File storage 
809f			; 
809f			;      Byte 0 file id    - block 0 file details 
809f			;      Byte 1 block id - block 0 is file  
809f			;            Byte 2-15 - File name 
809f			; 
809f			;       - to end of block data 
809f			; 
809f			 
809f			; Get ID for the file named in pointer held HL 
809f			; Returns ID in HL = 255 if no file found 
809f			 
809f			storage_getid: 
809f			 
809f 22 73 ea			ld (store_tmp1), hl 
80a2			 
80a2				if DEBUG_STORESE 
80a2					DMARK "SGI" 
80a2 f5				push af  
80a3 3a b7 80			ld a, (.dmark)  
80a6 32 6b ee			ld (debug_mark),a  
80a9 3a b8 80			ld a, (.dmark+1)  
80ac 32 6c ee			ld (debug_mark+1),a  
80af 3a b9 80			ld a, (.dmark+2)  
80b2 32 6d ee			ld (debug_mark+2),a  
80b5 18 03			jr .pastdmark  
80b7 ..			.dmark: db "SGI"  
80ba f1			.pastdmark: pop af  
80bb			endm  
# End of macro DMARK
80bb					CALLMONITOR 
80bb cd 6f ee			call debug_vector  
80be				endm  
# End of macro CALLMONITOR
80be				endif 
80be				; get block 0 and set counter for number of files to scan 
80be			 
80be cd 29 82			call storage_get_block_0 
80c1			 
80c1 3a 7a ea			ld a, (store_page) 
80c4 47				ld b, a 
80c5			 
80c5				; get extent 0 of each file id 
80c5			 
80c5				if DEBUG_STORESE 
80c5					DMARK "SGc" 
80c5 f5				push af  
80c6 3a da 80			ld a, (.dmark)  
80c9 32 6b ee			ld (debug_mark),a  
80cc 3a db 80			ld a, (.dmark+1)  
80cf 32 6c ee			ld (debug_mark+1),a  
80d2 3a dc 80			ld a, (.dmark+2)  
80d5 32 6d ee			ld (debug_mark+2),a  
80d8 18 03			jr .pastdmark  
80da ..			.dmark: db "SGc"  
80dd f1			.pastdmark: pop af  
80de			endm  
# End of macro DMARK
80de					CALLMONITOR 
80de cd 6f ee			call debug_vector  
80e1				endm  
# End of macro CALLMONITOR
80e1				endif 
80e1 60			.getloop:	ld h, b 
80e2 2e 00				ld l, 0 
80e4 c5					push bc 
80e5			 
80e5 11 7a ea				ld de, store_page 
80e8				if DEBUG_STORESE 
80e8					DMARK "SGr" 
80e8 f5				push af  
80e9 3a fd 80			ld a, (.dmark)  
80ec 32 6b ee			ld (debug_mark),a  
80ef 3a fe 80			ld a, (.dmark+1)  
80f2 32 6c ee			ld (debug_mark+1),a  
80f5 3a ff 80			ld a, (.dmark+2)  
80f8 32 6d ee			ld (debug_mark+2),a  
80fb 18 03			jr .pastdmark  
80fd ..			.dmark: db "SGr"  
8100 f1			.pastdmark: pop af  
8101			endm  
# End of macro DMARK
8101					CALLMONITOR 
8101 cd 6f ee			call debug_vector  
8104				endm  
# End of macro CALLMONITOR
8104				endif 
8104 cd d1 86				call storage_read 
8107 cd 04 8d				call ishlzero 
810a 28 2d				jr z, .gap 
810c					 
810c					; have a file name read. Is it one we want. 
810c			 
810c 2a 73 ea				ld hl, (store_tmp1) 
810f 11 7d ea				ld de, store_page+3   ; file name 
8112			 
8112				if DEBUG_STORESE 
8112					DMARK "SGc" 
8112 f5				push af  
8113 3a 27 81			ld a, (.dmark)  
8116 32 6b ee			ld (debug_mark),a  
8119 3a 28 81			ld a, (.dmark+1)  
811c 32 6c ee			ld (debug_mark+1),a  
811f 3a 29 81			ld a, (.dmark+2)  
8122 32 6d ee			ld (debug_mark+2),a  
8125 18 03			jr .pastdmark  
8127 ..			.dmark: db "SGc"  
812a f1			.pastdmark: pop af  
812b			endm  
# End of macro DMARK
812b					CALLMONITOR 
812b cd 6f ee			call debug_vector  
812e				endm  
# End of macro CALLMONITOR
812e				endif 
812e cd 71 91				call strcmp 
8131 20 06				jr nz, .gap   ; not this one 
8133			 
8133 c1				        pop bc 
8134			 
8134 26 00				ld h, 0 
8136 68					ld l, b 
8137 18 22				jr .getdone 
8139						 
8139			 
8139			 
8139			 
8139			.gap: 
8139				if DEBUG_STORESE 
8139					DMARK "SGg" 
8139 f5				push af  
813a 3a 4e 81			ld a, (.dmark)  
813d 32 6b ee			ld (debug_mark),a  
8140 3a 4f 81			ld a, (.dmark+1)  
8143 32 6c ee			ld (debug_mark+1),a  
8146 3a 50 81			ld a, (.dmark+2)  
8149 32 6d ee			ld (debug_mark+2),a  
814c 18 03			jr .pastdmark  
814e ..			.dmark: db "SGg"  
8151 f1			.pastdmark: pop af  
8152			endm  
# End of macro DMARK
8152					CALLMONITOR 
8152 cd 6f ee			call debug_vector  
8155				endm  
# End of macro CALLMONITOR
8155				endif 
8155			 
8155 c1					pop bc 
8156 10 89				djnz .getloop 
8158 21 ff 00				ld hl, 255 
815b			.getdone: 
815b			 
815b				if DEBUG_STORESE 
815b					DMARK "SGe" 
815b f5				push af  
815c 3a 70 81			ld a, (.dmark)  
815f 32 6b ee			ld (debug_mark),a  
8162 3a 71 81			ld a, (.dmark+1)  
8165 32 6c ee			ld (debug_mark+1),a  
8168 3a 72 81			ld a, (.dmark+2)  
816b 32 6d ee			ld (debug_mark+2),a  
816e 18 03			jr .pastdmark  
8170 ..			.dmark: db "SGe"  
8173 f1			.pastdmark: pop af  
8174			endm  
# End of macro DMARK
8174					CALLMONITOR 
8174 cd 6f ee			call debug_vector  
8177				endm  
# End of macro CALLMONITOR
8177				endif 
8177			 
8177 c9				ret 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			 
8178			; Read Block 
8178			; ---------- 
8178			; 
8178			; With current bank 
8178			;  
8178			; Get block number to read 
8178			; Load physical blocks starting at start block into buffer 
8178			 
8178			; de points to buffer to use 
8178			; hl holds logical block number  
8178			 
8178			storage_read_block: 
8178			 
8178				; TODO bank selection 
8178			 
8178				; for each of the physical blocks read it into the buffer 
8178 06 40			ld b, STORE_BLOCK_PHY 
817a			 
817a				if DEBUG_STORESE 
817a d5					push de 
817b				endif 
817b				 
817b			.rl1:    
817b			 
817b				; read physical block at hl into de 
817b			        ; increment hl and de to next read position on exit 
817b			 
817b e5				push hl 
817c d5				push de	 
817d c5				push bc 
817e			;	if DEBUG_STORESE 
817e			;		push af 
817e			;		ld a, 'R' 
817e			;		ld (debug_mark),a 
817e			;		pop af 
817e			;		CALLMONITOR 
817e			;	endif 
817e cd 9c 80			call se_readbyte 
8181			;	if DEBUG_STORESE 
8181			;		ld a,(spi_portbyte) 
8181			;		ld l, a 
8181			;		push af 
8181			;		ld a, '1' 
8181			;		ld (debug_mark),a 
8181			;		pop af 
8181			;		CALLMONITOR 
8181			;	endif 
8181 c1				pop bc 
8182 d1				pop de 
8183 e1				pop hl 
8184 12				ld (de),a 
8185 23				inc hl 
8186 13				inc de 
8187			 
8187			;	if DEBUG_STORESE 
8187			;		push af 
8187			;		ld a, 'r' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187			;		CALLMONITOR 
8187			;	endif 
8187			 
8187 10 f2			djnz .rl1 
8189			 
8189				if DEBUG_STORESE 
8189					DMARK "SRB" 
8189 f5				push af  
818a 3a 9e 81			ld a, (.dmark)  
818d 32 6b ee			ld (debug_mark),a  
8190 3a 9f 81			ld a, (.dmark+1)  
8193 32 6c ee			ld (debug_mark+1),a  
8196 3a a0 81			ld a, (.dmark+2)  
8199 32 6d ee			ld (debug_mark+2),a  
819c 18 03			jr .pastdmark  
819e ..			.dmark: db "SRB"  
81a1 f1			.pastdmark: pop af  
81a2			endm  
# End of macro DMARK
81a2 d1					pop de 
81a3			; 
81a3			;		push af 
81a3			;		ld a, 'R' 
81a3			;		ld (debug_mark),a 
81a3			;		pop af 
81a3					CALLMONITOR 
81a3 cd 6f ee			call debug_vector  
81a6				endm  
# End of macro CALLMONITOR
81a6				endif 
81a6 c9				ret	 
81a7				 
81a7			 
81a7			; File Size 
81a7			; --------- 
81a7			; 
81a7			;   hl file id 
81a7			; 
81a7			;  returns in hl the number of blocks 
81a7			 
81a7			storage_file_size: 
81a7 5d				ld e, l 
81a8 16 00			ld d, 0 
81aa 21 40 00			ld hl, STORE_BLOCK_PHY 
81ad					if DEBUG_FORTH_WORDS 
81ad						DMARK "SIZ" 
81ad f5				push af  
81ae 3a c2 81			ld a, (.dmark)  
81b1 32 6b ee			ld (debug_mark),a  
81b4 3a c3 81			ld a, (.dmark+1)  
81b7 32 6c ee			ld (debug_mark+1),a  
81ba 3a c4 81			ld a, (.dmark+2)  
81bd 32 6d ee			ld (debug_mark+2),a  
81c0 18 03			jr .pastdmark  
81c2 ..			.dmark: db "SIZ"  
81c5 f1			.pastdmark: pop af  
81c6			endm  
# End of macro DMARK
81c6						CALLMONITOR 
81c6 cd 6f ee			call debug_vector  
81c9				endm  
# End of macro CALLMONITOR
81c9					endif 
81c9 cd ab 84			call storage_findnextid 
81cc			 
81cc cd 04 8d			call ishlzero 
81cf			;	ld a, l 
81cf			;	add h 
81cf			;	cp 0 
81cf c8				ret z			; block not found so EOF 
81d0			 
81d0 11 7a ea			ld de, store_page 
81d3 cd 78 81			call storage_read_block 
81d6			 
81d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81d9 6f				ld l, a 
81da 26 00			ld h, 0 
81dc c9			 	ret 
81dd			 
81dd			 
81dd			; Write Block 
81dd			; ----------- 
81dd			; 
81dd			; With current bank 
81dd			;  
81dd			; Get block number to write 
81dd			; Write physical blocks starting at start block from buffer 
81dd			  
81dd			storage_write_block: 
81dd				; TODO bank selection 
81dd			 
81dd				; for each of the physical blocks read it into the buffer 
81dd 06 40			ld b, STORE_BLOCK_PHY 
81df			 
81df				if DEBUG_STORESE 
81df					DMARK "SWB" 
81df f5				push af  
81e0 3a f4 81			ld a, (.dmark)  
81e3 32 6b ee			ld (debug_mark),a  
81e6 3a f5 81			ld a, (.dmark+1)  
81e9 32 6c ee			ld (debug_mark+1),a  
81ec 3a f6 81			ld a, (.dmark+2)  
81ef 32 6d ee			ld (debug_mark+2),a  
81f2 18 03			jr .pastdmark  
81f4 ..			.dmark: db "SWB"  
81f7 f1			.pastdmark: pop af  
81f8			endm  
# End of macro DMARK
81f8			 
81f8					;push af 
81f8					;ld a, 'W' 
81f8					;ld (debug_mark),a 
81f8					;pop af 
81f8					CALLMONITOR 
81f8 cd 6f ee			call debug_vector  
81fb				endm  
# End of macro CALLMONITOR
81fb				endif 
81fb			 
81fb			; might not be working 
81fb			;	call se_writepage 
81fb			 
81fb			;	ret 
81fb			; 
81fb			 
81fb			 
81fb			 
81fb			.wl1:    
81fb			 
81fb				; read physical block at hl into de 
81fb			        ; increment hl and de to next read position on exit 
81fb			 
81fb e5				push hl 
81fc d5				push de	 
81fd c5				push bc 
81fe 1a				ld a,(de) 
81ff				;if DEBUG_STORESE 
81ff			;		push af 
81ff			;		ld a, 'W' 
81ff			;		ld (debug_mark),a 
81ff			;		pop af 
81ff			;		CALLMONITOR 
81ff			;	endif 
81ff cd 9d 80			call se_writebyte 
8202			;	call delay250ms 
8202 00				nop 
8203 00				nop 
8204 00				nop 
8205			;	if DEBUG_STORESE 
8205			;		push af 
8205			;		ld a, 'w' 
8205			;		ld (debug_mark),a 
8205			;		pop af 
8205			;		CALLMONITOR 
8205			;	endif 
8205 c1				pop bc 
8206 d1				pop de 
8207 e1				pop hl 
8208 23				inc hl 
8209 13				inc de 
820a			 
820a			 
820a 10 ef			djnz .wl1 
820c			 
820c				if DEBUG_STORESE 
820c					DMARK "SW2" 
820c f5				push af  
820d 3a 21 82			ld a, (.dmark)  
8210 32 6b ee			ld (debug_mark),a  
8213 3a 22 82			ld a, (.dmark+1)  
8216 32 6c ee			ld (debug_mark+1),a  
8219 3a 23 82			ld a, (.dmark+2)  
821c 32 6d ee			ld (debug_mark+2),a  
821f 18 03			jr .pastdmark  
8221 ..			.dmark: db "SW2"  
8224 f1			.pastdmark: pop af  
8225			endm  
# End of macro DMARK
8225			 
8225					;push af 
8225					;ld a, 'W' 
8225					;ld (debug_mark),a 
8225					;pop af 
8225					CALLMONITOR 
8225 cd 6f ee			call debug_vector  
8228				endm  
# End of macro CALLMONITOR
8228				endif 
8228 c9				ret	 
8229			 
8229			; Init bank 
8229			; --------- 
8229			; 
8229			; With current bank 
8229			; 
8229			; Setup block 0 config 
8229			;     Set 0 file id counter 
8229			;     Set formatted byte pattern 
8229			;     Zero out bank label 
8229			;      
8229			; For every logical block write 0-1 byte as null 
8229			 
8229			storage_get_block_0: 
8229			 
8229				; TODO check presence 
8229			 
8229				; get block 0 config 
8229			 
8229 21 00 00			ld hl, 0 
822c 11 7a ea			ld de, store_page 
822f cd 78 81			call storage_read_block 
8232			 
8232				if DEBUG_STORESE 
8232					DMARK "SB0" 
8232 f5				push af  
8233 3a 47 82			ld a, (.dmark)  
8236 32 6b ee			ld (debug_mark),a  
8239 3a 48 82			ld a, (.dmark+1)  
823c 32 6c ee			ld (debug_mark+1),a  
823f 3a 49 82			ld a, (.dmark+2)  
8242 32 6d ee			ld (debug_mark+2),a  
8245 18 03			jr .pastdmark  
8247 ..			.dmark: db "SB0"  
824a f1			.pastdmark: pop af  
824b			endm  
# End of macro DMARK
824b 11 7a ea				ld de, store_page 
824e			;		push af 
824e			;		ld a, 'i' 
824e			;		ld (debug_mark),a 
824e			;		pop af 
824e					CALLMONITOR 
824e cd 6f ee			call debug_vector  
8251				endm  
# End of macro CALLMONITOR
8251				endif 
8251			 
8251				; is this area formatted? 
8251			 
8251			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8251 2a 7b ea			ld hl, (store_page+1) 
8254 3e 80			ld a,0x80 
8256 bd				cp l 
8257 20 22			jr nz, .ininotformatted 
8259				; do a double check 
8259 3e 27			ld a, 0x27 
825b bc				cp h 
825c 20 1d			jr nz, .ininotformatted 
825e			 
825e				; formatted then 
825e			 
825e				if DEBUG_STORESE 
825e					DMARK "SB1" 
825e f5				push af  
825f 3a 73 82			ld a, (.dmark)  
8262 32 6b ee			ld (debug_mark),a  
8265 3a 74 82			ld a, (.dmark+1)  
8268 32 6c ee			ld (debug_mark+1),a  
826b 3a 75 82			ld a, (.dmark+2)  
826e 32 6d ee			ld (debug_mark+2),a  
8271 18 03			jr .pastdmark  
8273 ..			.dmark: db "SB1"  
8276 f1			.pastdmark: pop af  
8277			endm  
# End of macro DMARK
8277					;push af 
8277					;ld a, 'I' 
8277					;ld (debug_mark),a 
8277					;pop af 
8277					CALLMONITOR 
8277 cd 6f ee			call debug_vector  
827a				endm  
# End of macro CALLMONITOR
827a				endif 
827a c9				ret 
827b			 
827b			.ininotformatted: 
827b				; bank not formatted so poke various bits to make sure 
827b			 
827b				if DEBUG_STORESE 
827b					DMARK "SB2" 
827b f5				push af  
827c 3a 90 82			ld a, (.dmark)  
827f 32 6b ee			ld (debug_mark),a  
8282 3a 91 82			ld a, (.dmark+1)  
8285 32 6c ee			ld (debug_mark+1),a  
8288 3a 92 82			ld a, (.dmark+2)  
828b 32 6d ee			ld (debug_mark+2),a  
828e 18 03			jr .pastdmark  
8290 ..			.dmark: db "SB2"  
8293 f1			.pastdmark: pop af  
8294			endm  
# End of macro DMARK
8294					;push af 
8294					;ld a, 'f' 
8294					;ld (debug_mark),a 
8294					;pop af 
8294					CALLMONITOR 
8294 cd 6f ee			call debug_vector  
8297				endm  
# End of macro CALLMONITOR
8297				endif 
8297			 
8297 cd b4 89			call storage_clear_page 
829a			 
829a 21 7a ea			ld hl, store_page 
829d 3e 00			ld a, 0 
829f				 
829f 77				ld (hl),a   ; reset file counter 
82a0			 
82a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a3 22 7b ea		 	ld (store_page+1), hl	 
82a6			 
82a6				; set default label 
82a6			 
82a6 21 42 83			ld hl, .defaultbanklabl 
82a9 11 7d ea		 	ld de, store_page+3 
82ac 01 0f 00			ld bc, 15 
82af ed b0			ldir 
82b1			 
82b1				; Append the current bank id 
82b1 21 86 ea			ld hl, store_page+3+9 
82b4 3a 5f ea			ld a, (spi_device_id) 
82b7 77				ld (hl), a 
82b8			 
82b8				; save default page 0 
82b8			 
82b8 21 00 00			ld hl, 0 
82bb 11 7a ea			ld de, store_page 
82be				if DEBUG_STORESE 
82be					DMARK "SB3" 
82be f5				push af  
82bf 3a d3 82			ld a, (.dmark)  
82c2 32 6b ee			ld (debug_mark),a  
82c5 3a d4 82			ld a, (.dmark+1)  
82c8 32 6c ee			ld (debug_mark+1),a  
82cb 3a d5 82			ld a, (.dmark+2)  
82ce 32 6d ee			ld (debug_mark+2),a  
82d1 18 03			jr .pastdmark  
82d3 ..			.dmark: db "SB3"  
82d6 f1			.pastdmark: pop af  
82d7			endm  
# End of macro DMARK
82d7			;		push af 
82d7			;		ld a, 'F' 
82d7			;		ld (debug_mark),a 
82d7			;		pop af 
82d7					CALLMONITOR 
82d7 cd 6f ee			call debug_vector  
82da				endm  
# End of macro CALLMONITOR
82da				endif 
82da cd dd 81			call storage_write_block 
82dd				if DEBUG_STORESE 
82dd					DMARK "SB4" 
82dd f5				push af  
82de 3a f2 82			ld a, (.dmark)  
82e1 32 6b ee			ld (debug_mark),a  
82e4 3a f3 82			ld a, (.dmark+1)  
82e7 32 6c ee			ld (debug_mark+1),a  
82ea 3a f4 82			ld a, (.dmark+2)  
82ed 32 6d ee			ld (debug_mark+2),a  
82f0 18 03			jr .pastdmark  
82f2 ..			.dmark: db "SB4"  
82f5 f1			.pastdmark: pop af  
82f6			endm  
# End of macro DMARK
82f6			;		push af 
82f6			;		ld a, '>' 
82f6			;		ld (debug_mark),a 
82f6			;		pop af 
82f6					CALLMONITOR 
82f6 cd 6f ee			call debug_vector  
82f9				endm  
# End of macro CALLMONITOR
82f9				endif 
82f9			 
82f9 00				nop 
82fa 00				nop 
82fb 00				nop 
82fc			 
82fc				; now set 0 in every page to mark as a free block 
82fc			 
82fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82fe 21 40 00			ld hl, STORE_BLOCK_PHY 
8301			 
8301 3e 00		.setmark1:   	ld a,0 
8303 e5					push hl 
8304 c5					push bc 
8305 cd 9d 80				call se_writebyte 
8308 3e 0a			ld a, 10 
830a cd d6 89			call aDelayInMS 
830d 23				inc hl 
830e cd 9d 80				call se_writebyte 
8311 3e 0a			ld a, 10 
8313 cd d6 89			call aDelayInMS 
8316 2b				dec hl 
8317 c1					pop bc 
8318 e1					pop hl 
8319 3e 40				ld a, STORE_BLOCK_PHY 
831b cd db 8c				call addatohl 
831e 10 e1				djnz .setmark1 
8320			 
8320 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8322 3e 00		.setmark2:   	ld a,0 
8324 e5					push hl 
8325 c5					push bc 
8326 cd 9d 80				call se_writebyte 
8329 3e 0a			ld a, 10 
832b cd d6 89			call aDelayInMS 
832e 23				inc hl 
832f cd 9d 80				call se_writebyte 
8332 3e 0a			ld a, 10 
8334 cd d6 89			call aDelayInMS 
8337 2b				dec hl 
8338 c1					pop bc 
8339 e1					pop hl 
833a 3e 40				ld a, STORE_BLOCK_PHY 
833c cd db 8c				call addatohl 
833f 10 e1				djnz .setmark2 
8341			 
8341					 
8341			 
8341			 
8341 c9				ret 
8342			 
8342			 
8342			 
8342			 
8342 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834d			 
834d			 
834d			 
834d			; Label Bank 
834d			; ---------- 
834d			; 
834d			; With current bank 
834d			; Read block 0 
834d			; Set label 
834d			; Write block 0 
834d			 
834d			; label str pointer in hl 
834d			 
834d			storage_label:     
834d			 
834d				if DEBUG_STORESE 
834d					DMARK "LBL" 
834d f5				push af  
834e 3a 62 83			ld a, (.dmark)  
8351 32 6b ee			ld (debug_mark),a  
8354 3a 63 83			ld a, (.dmark+1)  
8357 32 6c ee			ld (debug_mark+1),a  
835a 3a 64 83			ld a, (.dmark+2)  
835d 32 6d ee			ld (debug_mark+2),a  
8360 18 03			jr .pastdmark  
8362 ..			.dmark: db "LBL"  
8365 f1			.pastdmark: pop af  
8366			endm  
# End of macro DMARK
8366					CALLMONITOR 
8366 cd 6f ee			call debug_vector  
8369				endm  
# End of macro CALLMONITOR
8369				endif 
8369			 
8369 e5				push hl 
836a			 
836a cd 29 82			call storage_get_block_0 
836d			 
836d				; set default label 
836d			 
836d e1				pop hl 
836e			 
836e 11 7d ea		 	ld de, store_page+3 
8371 01 0f 00			ld bc, 15 
8374				if DEBUG_STORESE 
8374					DMARK "LB3" 
8374 f5				push af  
8375 3a 89 83			ld a, (.dmark)  
8378 32 6b ee			ld (debug_mark),a  
837b 3a 8a 83			ld a, (.dmark+1)  
837e 32 6c ee			ld (debug_mark+1),a  
8381 3a 8b 83			ld a, (.dmark+2)  
8384 32 6d ee			ld (debug_mark+2),a  
8387 18 03			jr .pastdmark  
8389 ..			.dmark: db "LB3"  
838c f1			.pastdmark: pop af  
838d			endm  
# End of macro DMARK
838d					CALLMONITOR 
838d cd 6f ee			call debug_vector  
8390				endm  
# End of macro CALLMONITOR
8390				endif 
8390 ed b0			ldir 
8392				; save default page 0 
8392			 
8392 21 00 00			ld hl, 0 
8395 11 7a ea			ld de, store_page 
8398				if DEBUG_STORESE 
8398					DMARK "LBW" 
8398 f5				push af  
8399 3a ad 83			ld a, (.dmark)  
839c 32 6b ee			ld (debug_mark),a  
839f 3a ae 83			ld a, (.dmark+1)  
83a2 32 6c ee			ld (debug_mark+1),a  
83a5 3a af 83			ld a, (.dmark+2)  
83a8 32 6d ee			ld (debug_mark+2),a  
83ab 18 03			jr .pastdmark  
83ad ..			.dmark: db "LBW"  
83b0 f1			.pastdmark: pop af  
83b1			endm  
# End of macro DMARK
83b1					CALLMONITOR 
83b1 cd 6f ee			call debug_vector  
83b4				endm  
# End of macro CALLMONITOR
83b4				endif 
83b4 cd dd 81			call storage_write_block 
83b7			 
83b7 c9				ret 
83b8			 
83b8			 
83b8			 
83b8			; Read Block 0 - Config 
83b8			; --------------------- 
83b8			; 
83b8			; With current bank 
83b8			; Call presence test 
83b8			;    If not present format/init bank  
83b8			; Read block 0  
83b8			;  
83b8			 
83b8			 
83b8			; Dir 
83b8			; --- 
83b8			; 
83b8			; With current bank 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block read byte 2 
83b8			;      if first block of file 
83b8			;         Display file name 
83b8			;         Display type flags for file 
83b8			;        
83b8			 
83b8			; moving to words as this requires stack control 
83b8			 
83b8			 
83b8			; Delete File 
83b8			; ----------- 
83b8			; 
83b8			; With current bank 
83b8			; 
83b8			; Load Block 0 Config 
83b8			; Get max file id number 
83b8			; For each logical block 
83b8			;    Read block file id 
83b8			;      If first block of file and dont have file id 
83b8			;         if file to delete 
83b8			;         Save file id 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			;      If file id is one saved 
83b8			;         Null file id 
83b8			;         Write this block back 
83b8			 
83b8			 
83b8			.se_done: 
83b8 e1				pop hl 
83b9 c9				ret 
83ba			 
83ba			storage_erase: 
83ba			 
83ba				; hl contains the file id 
83ba			 
83ba 5d				ld e, l 
83bb 16 00			ld d, 0 
83bd 21 40 00			ld hl, STORE_BLOCK_PHY 
83c0					if DEBUG_FORTH_WORDS 
83c0						DMARK "ERA" 
83c0 f5				push af  
83c1 3a d5 83			ld a, (.dmark)  
83c4 32 6b ee			ld (debug_mark),a  
83c7 3a d6 83			ld a, (.dmark+1)  
83ca 32 6c ee			ld (debug_mark+1),a  
83cd 3a d7 83			ld a, (.dmark+2)  
83d0 32 6d ee			ld (debug_mark+2),a  
83d3 18 03			jr .pastdmark  
83d5 ..			.dmark: db "ERA"  
83d8 f1			.pastdmark: pop af  
83d9			endm  
# End of macro DMARK
83d9						CALLMONITOR 
83d9 cd 6f ee			call debug_vector  
83dc				endm  
# End of macro CALLMONITOR
83dc					endif 
83dc cd ab 84			call storage_findnextid 
83df cd 04 8d			call ishlzero 
83e2 c8				ret z 
83e3			 
83e3 e5				push hl 
83e4			 
83e4				; TODO check file not found 
83e4			 
83e4 11 7a ea			ld de, store_page 
83e7 cd 78 81			call storage_read_block 
83ea			 
83ea cd 04 8d			call ishlzero 
83ed ca b8 83			jp z,.se_done 
83f0			 
83f0					if DEBUG_FORTH_WORDS 
83f0						DMARK "ER1" 
83f0 f5				push af  
83f1 3a 05 84			ld a, (.dmark)  
83f4 32 6b ee			ld (debug_mark),a  
83f7 3a 06 84			ld a, (.dmark+1)  
83fa 32 6c ee			ld (debug_mark+1),a  
83fd 3a 07 84			ld a, (.dmark+2)  
8400 32 6d ee			ld (debug_mark+2),a  
8403 18 03			jr .pastdmark  
8405 ..			.dmark: db "ER1"  
8408 f1			.pastdmark: pop af  
8409			endm  
# End of macro DMARK
8409						CALLMONITOR 
8409 cd 6f ee			call debug_vector  
840c				endm  
# End of macro CALLMONITOR
840c					endif 
840c 3a 7a ea			ld a, (store_page)	; get file id 
840f 32 6e ea			ld (store_tmpid), a 
8412			 
8412 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8415 32 6d ea			ld (store_tmpext), a 
8418			 
8418				; wipe file header 
8418			 
8418 e1				pop hl 
8419 3e 00			ld a, 0 
841b 32 7a ea			ld (store_page), a 
841e 32 7b ea			ld (store_page+1),a 
8421 11 7a ea			ld de, store_page 
8424					if DEBUG_FORTH_WORDS 
8424						DMARK "ER2" 
8424 f5				push af  
8425 3a 39 84			ld a, (.dmark)  
8428 32 6b ee			ld (debug_mark),a  
842b 3a 3a 84			ld a, (.dmark+1)  
842e 32 6c ee			ld (debug_mark+1),a  
8431 3a 3b 84			ld a, (.dmark+2)  
8434 32 6d ee			ld (debug_mark+2),a  
8437 18 03			jr .pastdmark  
8439 ..			.dmark: db "ER2"  
843c f1			.pastdmark: pop af  
843d			endm  
# End of macro DMARK
843d						CALLMONITOR 
843d cd 6f ee			call debug_vector  
8440				endm  
# End of macro CALLMONITOR
8440					endif 
8440 cd dd 81			call storage_write_block 
8443			 
8443			 
8443				; wipe file extents 
8443			 
8443 3a 6d ea			ld a, (store_tmpext) 
8446 47				ld b, a 
8447			 
8447			.eraext:	  
8447 c5				push bc 
8448			 
8448 21 40 00			ld hl, STORE_BLOCK_PHY 
844b 3a 6e ea			ld a,(store_tmpid) 
844e 5f				ld e, a 
844f 50				ld d, b	 
8450					if DEBUG_FORTH_WORDS 
8450						DMARK "ER3" 
8450 f5				push af  
8451 3a 65 84			ld a, (.dmark)  
8454 32 6b ee			ld (debug_mark),a  
8457 3a 66 84			ld a, (.dmark+1)  
845a 32 6c ee			ld (debug_mark+1),a  
845d 3a 67 84			ld a, (.dmark+2)  
8460 32 6d ee			ld (debug_mark+2),a  
8463 18 03			jr .pastdmark  
8465 ..			.dmark: db "ER3"  
8468 f1			.pastdmark: pop af  
8469			endm  
# End of macro DMARK
8469						CALLMONITOR 
8469 cd 6f ee			call debug_vector  
846c				endm  
# End of macro CALLMONITOR
846c					endif 
846c cd ab 84			call storage_findnextid 
846f cd 04 8d			call ishlzero 
8472 ca b8 83			jp z,.se_done 
8475			 
8475 e5				push hl 
8476 11 7a ea			ld de, store_page 
8479 cd 78 81			call storage_read_block 
847c			 
847c				; free block	 
847c			 
847c 3e 00			ld a, 0 
847e 32 7a ea			ld (store_page), a 
8481 32 7b ea			ld (store_page+1),a 
8484 11 7a ea			ld de, store_page 
8487 e1				pop hl 
8488					if DEBUG_FORTH_WORDS 
8488						DMARK "ER4" 
8488 f5				push af  
8489 3a 9d 84			ld a, (.dmark)  
848c 32 6b ee			ld (debug_mark),a  
848f 3a 9e 84			ld a, (.dmark+1)  
8492 32 6c ee			ld (debug_mark+1),a  
8495 3a 9f 84			ld a, (.dmark+2)  
8498 32 6d ee			ld (debug_mark+2),a  
849b 18 03			jr .pastdmark  
849d ..			.dmark: db "ER4"  
84a0 f1			.pastdmark: pop af  
84a1			endm  
# End of macro DMARK
84a1						CALLMONITOR 
84a1 cd 6f ee			call debug_vector  
84a4				endm  
# End of macro CALLMONITOR
84a4					endif 
84a4 cd dd 81			call storage_write_block 
84a7			 
84a7 c1				pop bc 
84a8 10 9d			djnz .eraext 
84aa			 
84aa c9				ret 
84ab			 
84ab			 
84ab			; Find Free Block 
84ab			; --------------- 
84ab			; 
84ab			; With current bank 
84ab			;  
84ab			; From given starting logical block 
84ab			;    Read block  
84ab			;    If no file id 
84ab			;         Return block id 
84ab			 
84ab			 
84ab			; hl starting page number 
84ab			; hl contains free page number or zero if no pages free 
84ab			; e contains the file id to locate 
84ab			; d contains the block number 
84ab			 
84ab			; TODO change to find file id and use zero for free block 
84ab			 
84ab			storage_findnextid: 
84ab			 
84ab				; now locate first 0 page to mark as a free block 
84ab			 
84ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ad			;	ld hl, STORE_BLOCK_PHY 
84ad			 
84ad					if DEBUG_FORTH_WORDS 
84ad					DMARK "FNI" 
84ad f5				push af  
84ae 3a c2 84			ld a, (.dmark)  
84b1 32 6b ee			ld (debug_mark),a  
84b4 3a c3 84			ld a, (.dmark+1)  
84b7 32 6c ee			ld (debug_mark+1),a  
84ba 3a c4 84			ld a, (.dmark+2)  
84bd 32 6d ee			ld (debug_mark+2),a  
84c0 18 03			jr .pastdmark  
84c2 ..			.dmark: db "FNI"  
84c5 f1			.pastdmark: pop af  
84c6			endm  
# End of macro DMARK
84c6						CALLMONITOR 
84c6 cd 6f ee			call debug_vector  
84c9				endm  
# End of macro CALLMONITOR
84c9					endif 
84c9			.ff1:   	 
84c9 e5					push hl 
84ca c5					push bc 
84cb d5					push de 
84cc cd 9c 80				call se_readbyte 
84cf 5f					ld e,a 
84d0 23					inc hl 
84d1 cd 9c 80				call se_readbyte 
84d4 57					ld d, a 
84d5 e1					pop hl 
84d6 e5					push hl 
84d7 cd f9 8c				call cmp16 
84da 28 49				jr z, .fffound 
84dc			 
84dc d1					pop de 
84dd c1					pop bc 
84de e1					pop hl 
84df			 
84df					; is found? 
84df					;cp e 
84df					;ret z 
84df			 
84df 3e 40				ld a, STORE_BLOCK_PHY 
84e1 cd db 8c				call addatohl 
84e4 10 e3				djnz .ff1 
84e6			 
84e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e8			.ff2:   	 
84e8			 
84e8 e5					push hl 
84e9 c5					push bc 
84ea d5					push de 
84eb cd 9c 80				call se_readbyte 
84ee 5f					ld e,a 
84ef 23					inc hl 
84f0 cd 9c 80				call se_readbyte 
84f3 57					ld d, a 
84f4			 
84f4 e1					pop hl 
84f5 e5					push hl 
84f6 cd f9 8c				call cmp16 
84f9 28 2a				jr z, .fffound 
84fb			 
84fb d1					pop de 
84fc c1					pop bc 
84fd e1					pop hl 
84fe					; is found? 
84fe					;cp e 
84fe					;ret z 
84fe			 
84fe 3e 40				ld a, STORE_BLOCK_PHY 
8500 cd db 8c				call addatohl 
8503 10 e3				djnz .ff2 
8505			 
8505			 
8505					if DEBUG_FORTH_WORDS 
8505					DMARK "FN-" 
8505 f5				push af  
8506 3a 1a 85			ld a, (.dmark)  
8509 32 6b ee			ld (debug_mark),a  
850c 3a 1b 85			ld a, (.dmark+1)  
850f 32 6c ee			ld (debug_mark+1),a  
8512 3a 1c 85			ld a, (.dmark+2)  
8515 32 6d ee			ld (debug_mark+2),a  
8518 18 03			jr .pastdmark  
851a ..			.dmark: db "FN-"  
851d f1			.pastdmark: pop af  
851e			endm  
# End of macro DMARK
851e					;	push af 
851e					;	ld a, 'n' 
851e					;	ld (debug_mark),a 
851e					;	pop af 
851e						CALLMONITOR 
851e cd 6f ee			call debug_vector  
8521				endm  
# End of macro CALLMONITOR
8521					endif 
8521				; no free marks! 
8521 21 00 00				ld hl, 0 
8524 c9				ret 
8525			.fffound: 
8525				 
8525			 
8525 d1					pop de 
8526 c1					pop bc 
8527 e1					pop hl 
8528					if DEBUG_FORTH_WORDS 
8528					DMARK "FNF" 
8528 f5				push af  
8529 3a 3d 85			ld a, (.dmark)  
852c 32 6b ee			ld (debug_mark),a  
852f 3a 3e 85			ld a, (.dmark+1)  
8532 32 6c ee			ld (debug_mark+1),a  
8535 3a 3f 85			ld a, (.dmark+2)  
8538 32 6d ee			ld (debug_mark+2),a  
853b 18 03			jr .pastdmark  
853d ..			.dmark: db "FNF"  
8540 f1			.pastdmark: pop af  
8541			endm  
# End of macro DMARK
8541					;	push af 
8541					;	ld a, 'n' 
8541					;	ld (debug_mark),a 
8541					;	pop af 
8541						CALLMONITOR 
8541 cd 6f ee			call debug_vector  
8544				endm  
# End of macro CALLMONITOR
8544					endif 
8544 c9				ret 
8545			 
8545			 
8545			 
8545			; Free Space 
8545			; ---------- 
8545			; 
8545			; With current bank 
8545			; 
8545			; Set block count to zero 
8545			; Starting with first logical block 
8545			;      Find free block  
8545			;      If block id given, increment block count 
8545			; 
8545			;  
8545			 
8545			 
8545			; hl contains count of free blocks 
8545			 
8545			storage_freeblocks: 
8545			 
8545				; now locate first 0 page to mark as a free block 
8545			 
8545 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8547 21 40 00			ld hl, STORE_BLOCK_PHY 
854a 11 00 00			ld de, 0 
854d			 
854d			.fb1:   	 
854d e5					push hl 
854e c5					push bc 
854f d5					push de 
8550 cd 9c 80				call se_readbyte 
8553 d1					pop de 
8554 c1					pop bc 
8555 e1					pop hl 
8556			 
8556					; is free? 
8556 fe 00				cp 0 
8558 20 01				jr nz, .ff1cont 
855a 13					inc de 
855b			 
855b			.ff1cont: 
855b			 
855b			 
855b 3e 40				ld a, STORE_BLOCK_PHY 
855d cd db 8c				call addatohl 
8560 10 eb				djnz .fb1 
8562			 
8562 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8564			.fb2:   	 
8564 e5					push hl 
8565 c5					push bc 
8566 d5					push de 
8567 cd 9c 80				call se_readbyte 
856a d1					pop de 
856b c1					pop bc 
856c e1					pop hl 
856d			 
856d					; is free? 
856d fe 00				cp 0 
856f 20 01				jr nz, .ff2cont 
8571 13					inc de 
8572			 
8572			.ff2cont: 
8572			 
8572 3e 40				ld a, STORE_BLOCK_PHY 
8574 cd db 8c				call addatohl 
8577 10 eb				djnz .fb2 
8579			 
8579 eb				ex de, hl 
857a c9				ret 
857b			 
857b			; Get File ID 
857b			; ----------- 
857b			; 
857b			; With current bank 
857b			;  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; For each logical block 
857b			;    Read block file id 
857b			;      If first block of file and dont have file id 
857b			;         if file get id and exit 
857b			 
857b			 
857b			 
857b			 
857b			; Create File 
857b			; ----------- 
857b			; 
857b			; With current bank  
857b			; Load Block 0 Config 
857b			; Get max file id number 
857b			; Increment file id number 
857b			; Save Config 
857b			; Find free block 
857b			; Set buffer with file name and file id 
857b			; Write buffer to free block  
857b			 
857b			 
857b			; hl point to file name 
857b			; hl returns file id 
857b			 
857b			; file format: 
857b			; byte 0 - file id 
857b			; byte 1 - extent number 
857b			; byte 2-> data 
857b			 
857b			; format for extent number 0: 
857b			; 
857b			; byte 0 - file id 
857b			; byte 1 - extent 0 
857b			; byte 2 - extent count 
857b			; byte 3 -> file name and meta data 
857b			 
857b			 
857b			storage_create: 
857b				if DEBUG_STORESE 
857b					DMARK "SCR" 
857b f5				push af  
857c 3a 90 85			ld a, (.dmark)  
857f 32 6b ee			ld (debug_mark),a  
8582 3a 91 85			ld a, (.dmark+1)  
8585 32 6c ee			ld (debug_mark+1),a  
8588 3a 92 85			ld a, (.dmark+2)  
858b 32 6d ee			ld (debug_mark+2),a  
858e 18 03			jr .pastdmark  
8590 ..			.dmark: db "SCR"  
8593 f1			.pastdmark: pop af  
8594			endm  
# End of macro DMARK
8594					CALLMONITOR 
8594 cd 6f ee			call debug_vector  
8597				endm  
# End of macro CALLMONITOR
8597				endif 
8597			 
8597 e5				push hl		; save file name pointer 
8598			 
8598 cd 29 82			call storage_get_block_0 
859b			 
859b 3a 7a ea			ld a,(store_page)	; get current file id 
859e 3c				inc a 
859f 32 7a ea			ld (store_page),a 
85a2				 
85a2 32 6e ea			ld (store_tmpid),a			; save id 
85a5			 
85a5 21 00 00			ld hl, 0 
85a8 11 7a ea			ld de, store_page 
85ab				if DEBUG_STORESE 
85ab					DMARK "SCw" 
85ab f5				push af  
85ac 3a c0 85			ld a, (.dmark)  
85af 32 6b ee			ld (debug_mark),a  
85b2 3a c1 85			ld a, (.dmark+1)  
85b5 32 6c ee			ld (debug_mark+1),a  
85b8 3a c2 85			ld a, (.dmark+2)  
85bb 32 6d ee			ld (debug_mark+2),a  
85be 18 03			jr .pastdmark  
85c0 ..			.dmark: db "SCw"  
85c3 f1			.pastdmark: pop af  
85c4			endm  
# End of macro DMARK
85c4					CALLMONITOR 
85c4 cd 6f ee			call debug_vector  
85c7				endm  
# End of macro CALLMONITOR
85c7				endif 
85c7 cd dd 81			call storage_write_block	 ; save update 
85ca			 
85ca				if DEBUG_STORESE 
85ca 11 7a ea				ld de, store_page 
85cd					DMARK "SCC" 
85cd f5				push af  
85ce 3a e2 85			ld a, (.dmark)  
85d1 32 6b ee			ld (debug_mark),a  
85d4 3a e3 85			ld a, (.dmark+1)  
85d7 32 6c ee			ld (debug_mark+1),a  
85da 3a e4 85			ld a, (.dmark+2)  
85dd 32 6d ee			ld (debug_mark+2),a  
85e0 18 03			jr .pastdmark  
85e2 ..			.dmark: db "SCC"  
85e5 f1			.pastdmark: pop af  
85e6			endm  
# End of macro DMARK
85e6					CALLMONITOR 
85e6 cd 6f ee			call debug_vector  
85e9				endm  
# End of macro CALLMONITOR
85e9				endif 
85e9				;  
85e9				 
85e9 21 40 00			ld hl, STORE_BLOCK_PHY 
85ec 11 00 00			ld de, 0 
85ef cd ab 84			call storage_findnextid 
85f2			 
85f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f5			 
85f5				; TODO detect 0 = no spare blocks 
85f5			 
85f5				; hl now contains the free page to use for the file header page 
85f5			 
85f5				if DEBUG_STORESE 
85f5				DMARK "SCF" 
85f5 f5				push af  
85f6 3a 0a 86			ld a, (.dmark)  
85f9 32 6b ee			ld (debug_mark),a  
85fc 3a 0b 86			ld a, (.dmark+1)  
85ff 32 6c ee			ld (debug_mark+1),a  
8602 3a 0c 86			ld a, (.dmark+2)  
8605 32 6d ee			ld (debug_mark+2),a  
8608 18 03			jr .pastdmark  
860a ..			.dmark: db "SCF"  
860d f1			.pastdmark: pop af  
860e			endm  
# End of macro DMARK
860e					CALLMONITOR 
860e cd 6f ee			call debug_vector  
8611				endm  
# End of macro CALLMONITOR
8611				endif 
8611			 
8611 22 65 ea			ld (store_tmppageid), hl 
8614				 
8614 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8617			;	ld a, (store_filecache)			; save to cache 
8617			 
8617 32 7a ea			ld (store_page),a    ; set page id 
861a 3e 00			ld a, 0			 ; extent 0 is file header 
861c 32 7b ea			ld (store_page+1), a   ; set file extent 
861f			 
861f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8622			 
8622			;	inc hl 		; init block 0 of file 
8622			;	inc hl   		; skip file and extent id 
8622			 ;       ld a, 0 
8622			;	ld (hl),a 
8622			;	ld a, (store_filecache+1)  	; save to cache 
8622			 
8622			;	inc hl    ; file name 
8622				 
8622				 
8622 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8625				if DEBUG_STORESE 
8625					DMARK "SCc" 
8625 f5				push af  
8626 3a 3a 86			ld a, (.dmark)  
8629 32 6b ee			ld (debug_mark),a  
862c 3a 3b 86			ld a, (.dmark+1)  
862f 32 6c ee			ld (debug_mark+1),a  
8632 3a 3c 86			ld a, (.dmark+2)  
8635 32 6d ee			ld (debug_mark+2),a  
8638 18 03			jr .pastdmark  
863a ..			.dmark: db "SCc"  
863d f1			.pastdmark: pop af  
863e			endm  
# End of macro DMARK
863e					CALLMONITOR 
863e cd 6f ee			call debug_vector  
8641				endm  
# End of macro CALLMONITOR
8641				endif 
8641 e1				pop hl    ; get zero term string 
8642 e5				push hl 
8643 3e 00			ld a, 0 
8645 cd 44 91			call strlent 
8648 23				inc hl   ; cover zero term 
8649 06 00			ld b,0 
864b 4d				ld c,l 
864c e1				pop hl 
864d				;ex de, hl 
864d				if DEBUG_STORESE 
864d					DMARK "SCa" 
864d f5				push af  
864e 3a 62 86			ld a, (.dmark)  
8651 32 6b ee			ld (debug_mark),a  
8654 3a 63 86			ld a, (.dmark+1)  
8657 32 6c ee			ld (debug_mark+1),a  
865a 3a 64 86			ld a, (.dmark+2)  
865d 32 6d ee			ld (debug_mark+2),a  
8660 18 03			jr .pastdmark  
8662 ..			.dmark: db "SCa"  
8665 f1			.pastdmark: pop af  
8666			endm  
# End of macro DMARK
8666					;push af 
8666					;ld a, 'a' 
8666					;ld (debug_mark),a 
8666					;pop af 
8666					CALLMONITOR 
8666 cd 6f ee			call debug_vector  
8669				endm  
# End of macro CALLMONITOR
8669				endif 
8669 ed b0			ldir    ; copy zero term string 
866b				if DEBUG_STORESE 
866b					DMARK "SCA" 
866b f5				push af  
866c 3a 80 86			ld a, (.dmark)  
866f 32 6b ee			ld (debug_mark),a  
8672 3a 81 86			ld a, (.dmark+1)  
8675 32 6c ee			ld (debug_mark+1),a  
8678 3a 82 86			ld a, (.dmark+2)  
867b 32 6d ee			ld (debug_mark+2),a  
867e 18 03			jr .pastdmark  
8680 ..			.dmark: db "SCA"  
8683 f1			.pastdmark: pop af  
8684			endm  
# End of macro DMARK
8684					CALLMONITOR 
8684 cd 6f ee			call debug_vector  
8687				endm  
# End of macro CALLMONITOR
8687				endif 
8687			 
8687				; write file header page 
8687			 
8687 2a 65 ea			ld hl,(store_tmppageid) 
868a 11 7a ea			ld de, store_page 
868d				if DEBUG_STORESE 
868d					DMARK "SCb" 
868d f5				push af  
868e 3a a2 86			ld a, (.dmark)  
8691 32 6b ee			ld (debug_mark),a  
8694 3a a3 86			ld a, (.dmark+1)  
8697 32 6c ee			ld (debug_mark+1),a  
869a 3a a4 86			ld a, (.dmark+2)  
869d 32 6d ee			ld (debug_mark+2),a  
86a0 18 03			jr .pastdmark  
86a2 ..			.dmark: db "SCb"  
86a5 f1			.pastdmark: pop af  
86a6			endm  
# End of macro DMARK
86a6					;push af 
86a6					;ld a, 'b' 
86a6					;ld (debug_mark),a 
86a6					;pop af 
86a6					CALLMONITOR 
86a6 cd 6f ee			call debug_vector  
86a9				endm  
# End of macro CALLMONITOR
86a9				endif 
86a9 cd dd 81			call storage_write_block 
86ac			 
86ac 3a 6e ea			ld a, (store_tmpid) 
86af 6f				ld l, a 
86b0 26 00			ld h,0 
86b2				if DEBUG_STORESE 
86b2					DMARK "SCz" 
86b2 f5				push af  
86b3 3a c7 86			ld a, (.dmark)  
86b6 32 6b ee			ld (debug_mark),a  
86b9 3a c8 86			ld a, (.dmark+1)  
86bc 32 6c ee			ld (debug_mark+1),a  
86bf 3a c9 86			ld a, (.dmark+2)  
86c2 32 6d ee			ld (debug_mark+2),a  
86c5 18 03			jr .pastdmark  
86c7 ..			.dmark: db "SCz"  
86ca f1			.pastdmark: pop af  
86cb			endm  
# End of macro DMARK
86cb					CALLMONITOR 
86cb cd 6f ee			call debug_vector  
86ce				endm  
# End of macro CALLMONITOR
86ce				endif 
86ce c9				ret 
86cf				 
86cf			 
86cf			 
86cf			; 
86cf			; Read File 
86cf			; 
86cf			; h - file id to locate 
86cf			; l - extent to locate 
86cf			; de - pointer to string to read into 
86cf			; 
86cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86cf			 
86cf			.sr_fail: 
86cf d1				pop de 
86d0 c9				ret 
86d1			 
86d1			storage_read: 
86d1			 
86d1			 
86d1 d5				push de 
86d2			 
86d2			; TODO BUG the above push is it popped before the RET Z? 
86d2			 
86d2			; TODO how to handle multiple part blocks 
86d2			 
86d2				; locate file extent to read 
86d2			 
86d2 5c				ld e, h 
86d3 55				ld d, l 
86d4			 
86d4			.srext: 
86d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86db			 
86db 21 40 00			ld hl, STORE_BLOCK_PHY 
86de				if DEBUG_STORESE 
86de					DMARK "sre" 
86de f5				push af  
86df 3a f3 86			ld a, (.dmark)  
86e2 32 6b ee			ld (debug_mark),a  
86e5 3a f4 86			ld a, (.dmark+1)  
86e8 32 6c ee			ld (debug_mark+1),a  
86eb 3a f5 86			ld a, (.dmark+2)  
86ee 32 6d ee			ld (debug_mark+2),a  
86f1 18 03			jr .pastdmark  
86f3 ..			.dmark: db "sre"  
86f6 f1			.pastdmark: pop af  
86f7			endm  
# End of macro DMARK
86f7					CALLMONITOR 
86f7 cd 6f ee			call debug_vector  
86fa				endm  
# End of macro CALLMONITOR
86fa				endif 
86fa cd ab 84			call storage_findnextid 
86fd			 
86fd				if DEBUG_STORESE 
86fd					DMARK "srf" 
86fd f5				push af  
86fe 3a 12 87			ld a, (.dmark)  
8701 32 6b ee			ld (debug_mark),a  
8704 3a 13 87			ld a, (.dmark+1)  
8707 32 6c ee			ld (debug_mark+1),a  
870a 3a 14 87			ld a, (.dmark+2)  
870d 32 6d ee			ld (debug_mark+2),a  
8710 18 03			jr .pastdmark  
8712 ..			.dmark: db "srf"  
8715 f1			.pastdmark: pop af  
8716			endm  
# End of macro DMARK
8716					CALLMONITOR 
8716 cd 6f ee			call debug_vector  
8719				endm  
# End of macro CALLMONITOR
8719				endif 
8719 cd 04 8d			call ishlzero 
871c			;	ld a, l 
871c			;	add h 
871c			;	cp 0 
871c 28 b1			jr z,.sr_fail			; block not found so EOF 
871e			 
871e				; save current address for use by higher level words etc 
871e			 
871e 22 6b ea			ld (store_openaddr),hl 
8721			 
8721			 
8721				; hl contains page number to load 
8721 d1				pop de   ; get storage 
8722 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8726 d5				push de 
8727				if DEBUG_STORESE 
8727					DMARK "srg" 
8727 f5				push af  
8728 3a 3c 87			ld a, (.dmark)  
872b 32 6b ee			ld (debug_mark),a  
872e 3a 3d 87			ld a, (.dmark+1)  
8731 32 6c ee			ld (debug_mark+1),a  
8734 3a 3e 87			ld a, (.dmark+2)  
8737 32 6d ee			ld (debug_mark+2),a  
873a 18 03			jr .pastdmark  
873c ..			.dmark: db "srg"  
873f f1			.pastdmark: pop af  
8740			endm  
# End of macro DMARK
8740					CALLMONITOR 
8740 cd 6f ee			call debug_vector  
8743				endm  
# End of macro CALLMONITOR
8743				endif 
8743 cd 78 81			call storage_read_block 
8746			 
8746				; if this a continuation read??? 
8746			 
8746 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8749			 
8749 3e 3f			ld a, STORE_BLOCK_PHY-1 
874b cd db 8c			call addatohl 
874e 7e				ld a,(hl) 
874f fe 00			cp 0 
8751 28 02			jr z, .markiscont 
8753 3e ff			ld a, 255 
8755			 
8755			.markiscont: 
8755 32 6d ea			ld (store_readcont), a 
8758			 
8758				if DEBUG_STORESE 
8758					DMARK "srC" 
8758 f5				push af  
8759 3a 6d 87			ld a, (.dmark)  
875c 32 6b ee			ld (debug_mark),a  
875f 3a 6e 87			ld a, (.dmark+1)  
8762 32 6c ee			ld (debug_mark+1),a  
8765 3a 6f 87			ld a, (.dmark+2)  
8768 32 6d ee			ld (debug_mark+2),a  
876b 18 03			jr .pastdmark  
876d ..			.dmark: db "srC"  
8770 f1			.pastdmark: pop af  
8771			endm  
# End of macro DMARK
8771					CALLMONITOR 
8771 cd 6f ee			call debug_vector  
8774				endm  
# End of macro CALLMONITOR
8774				endif 
8774				; only short reads enabled 
8774			 
8774 3a 75 ea			ld a, (store_longread) 
8777 fe 00			cp 0 
8779 ca 46 88			jp z, .readdone 
877c			 
877c			; TODO if block has no zeros then need to read next block  
877c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877c			; check last byte of physical block. 
877c			; if not zero then the next block needs to be loaded 
877c			 
877c			 
877c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
877f			 
877f 3e 3f			ld a, STORE_BLOCK_PHY-1 
8781 cd db 8c			call addatohl 
8784				;dec hl 
8784 7e				ld a,(hl) 
8785				if DEBUG_STORESE 
8785					DMARK "sr?" 
8785 f5				push af  
8786 3a 9a 87			ld a, (.dmark)  
8789 32 6b ee			ld (debug_mark),a  
878c 3a 9b 87			ld a, (.dmark+1)  
878f 32 6c ee			ld (debug_mark+1),a  
8792 3a 9c 87			ld a, (.dmark+2)  
8795 32 6d ee			ld (debug_mark+2),a  
8798 18 03			jr .pastdmark  
879a ..			.dmark: db "sr?"  
879d f1			.pastdmark: pop af  
879e			endm  
# End of macro DMARK
879e					CALLMONITOR 
879e cd 6f ee			call debug_vector  
87a1				endm  
# End of macro CALLMONITOR
87a1				endif 
87a1 fe 00			cp 0 
87a3 ca 46 88			jp z, .readdone 
87a6			 
87a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a6			 
87a6 23				inc hl 
87a7			 
87a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87aa			 
87aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87ae			 
87ae eb				ex de, hl 
87af			 
87af				; next ext 
87af			 
87af 23				inc hl 
87b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b3			 
87b3				if DEBUG_STORESE 
87b3					DMARK "sF2" 
87b3 f5				push af  
87b4 3a c8 87			ld a, (.dmark)  
87b7 32 6b ee			ld (debug_mark),a  
87ba 3a c9 87			ld a, (.dmark+1)  
87bd 32 6c ee			ld (debug_mark+1),a  
87c0 3a ca 87			ld a, (.dmark+2)  
87c3 32 6d ee			ld (debug_mark+2),a  
87c6 18 03			jr .pastdmark  
87c8 ..			.dmark: db "sF2"  
87cb f1			.pastdmark: pop af  
87cc			endm  
# End of macro DMARK
87cc					CALLMONITOR 
87cc cd 6f ee			call debug_vector  
87cf				endm  
# End of macro CALLMONITOR
87cf				endif 
87cf			 
87cf				; get and load block 
87cf			 
87cf cd ab 84			call storage_findnextid 
87d2			 
87d2				if DEBUG_STORESE 
87d2					DMARK "sf2" 
87d2 f5				push af  
87d3 3a e7 87			ld a, (.dmark)  
87d6 32 6b ee			ld (debug_mark),a  
87d9 3a e8 87			ld a, (.dmark+1)  
87dc 32 6c ee			ld (debug_mark+1),a  
87df 3a e9 87			ld a, (.dmark+2)  
87e2 32 6d ee			ld (debug_mark+2),a  
87e5 18 03			jr .pastdmark  
87e7 ..			.dmark: db "sf2"  
87ea f1			.pastdmark: pop af  
87eb			endm  
# End of macro DMARK
87eb					CALLMONITOR 
87eb cd 6f ee			call debug_vector  
87ee				endm  
# End of macro CALLMONITOR
87ee				endif 
87ee cd 04 8d			call ishlzero 
87f1			;	ld a, l 
87f1			;	add h 
87f1			;	cp 0 
87f1 ca cf 86			jp z,.sr_fail			; block not found so EOF 
87f4				 
87f4				; save current address for use by higher level words etc 
87f4			 
87f4 22 6b ea			ld (store_openaddr),hl 
87f7			 
87f7 cd 78 81			call storage_read_block 
87fa			 
87fa				; on a continuation block, we now have the file id and ext in the middle of the block 
87fa				; we need to pull everything back  
87fa			 
87fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8801 23				inc hl 
8802 23				inc hl     ; skip id and ext 
8803 01 40 00			ld bc, STORE_BLOCK_PHY 
8806				if DEBUG_STORESE 
8806					DMARK "SR<" 
8806 f5				push af  
8807 3a 1b 88			ld a, (.dmark)  
880a 32 6b ee			ld (debug_mark),a  
880d 3a 1c 88			ld a, (.dmark+1)  
8810 32 6c ee			ld (debug_mark+1),a  
8813 3a 1d 88			ld a, (.dmark+2)  
8816 32 6d ee			ld (debug_mark+2),a  
8819 18 03			jr .pastdmark  
881b ..			.dmark: db "SR<"  
881e f1			.pastdmark: pop af  
881f			endm  
# End of macro DMARK
881f					CALLMONITOR 
881f cd 6f ee			call debug_vector  
8822				endm  
# End of macro CALLMONITOR
8822				endif 
8822 ed b0			ldir     ; copy data 
8824			 
8824				; move the pointer back and pretend we have a full buffer for next recheck 
8824			 
8824 1b				dec de 
8825 1b				dec de 
8826			 
8826			; TODO do pop below now short circuit loop????? 
8826 c1				pop bc     ; get rid of spare de on stack 
8827				if DEBUG_STORESE 
8827					DMARK "SR>" 
8827 f5				push af  
8828 3a 3c 88			ld a, (.dmark)  
882b 32 6b ee			ld (debug_mark),a  
882e 3a 3d 88			ld a, (.dmark+1)  
8831 32 6c ee			ld (debug_mark+1),a  
8834 3a 3e 88			ld a, (.dmark+2)  
8837 32 6d ee			ld (debug_mark+2),a  
883a 18 03			jr .pastdmark  
883c ..			.dmark: db "SR>"  
883f f1			.pastdmark: pop af  
8840			endm  
# End of macro DMARK
8840					CALLMONITOR 
8840 cd 6f ee			call debug_vector  
8843				endm  
# End of macro CALLMONITOR
8843				endif 
8843 c3 d4 86			jp .srext 
8846			 
8846			 
8846			 
8846			 
8846			 
8846			.readdone:		 
8846 e1				pop hl 		 ; return start of data to show as not EOF 
8847 23				inc hl   ; past file id 
8848 23				inc hl   ; past ext 
8849				if DEBUG_STORESE 
8849					DMARK "SRe" 
8849 f5				push af  
884a 3a 5e 88			ld a, (.dmark)  
884d 32 6b ee			ld (debug_mark),a  
8850 3a 5f 88			ld a, (.dmark+1)  
8853 32 6c ee			ld (debug_mark+1),a  
8856 3a 60 88			ld a, (.dmark+2)  
8859 32 6d ee			ld (debug_mark+2),a  
885c 18 03			jr .pastdmark  
885e ..			.dmark: db "SRe"  
8861 f1			.pastdmark: pop af  
8862			endm  
# End of macro DMARK
8862					CALLMONITOR 
8862 cd 6f ee			call debug_vector  
8865				endm  
# End of macro CALLMONITOR
8865				endif 
8865 c9					ret 
8866			 
8866			 
8866			 
8866			; 
8866			; Append File 
8866			; 
8866			; hl - file id to locate 
8866			; de - pointer to (multi block) string to write 
8866			 
8866			.sa_notfound: 
8866 d1				pop de 
8867 c9				ret 
8868			 
8868			 
8868			storage_append: 
8868				; hl -  file id to append to 
8868				; de - string to append 
8868			 
8868 d5				push de 
8869				 
8869				if DEBUG_STORESE 
8869					DMARK "AP1" 
8869 f5				push af  
886a 3a 7e 88			ld a, (.dmark)  
886d 32 6b ee			ld (debug_mark),a  
8870 3a 7f 88			ld a, (.dmark+1)  
8873 32 6c ee			ld (debug_mark+1),a  
8876 3a 80 88			ld a, (.dmark+2)  
8879 32 6d ee			ld (debug_mark+2),a  
887c 18 03			jr .pastdmark  
887e ..			.dmark: db "AP1"  
8881 f1			.pastdmark: pop af  
8882			endm  
# End of macro DMARK
8882					CALLMONITOR 
8882 cd 6f ee			call debug_vector  
8885				endm  
# End of macro CALLMONITOR
8885				endif 
8885			 
8885 7d				ld a, l 
8886 32 6e ea			ld (store_tmpid), a 
8889			 
8889				; get file header  
8889			 
8889 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888b 3a 6e ea			ld a, (store_tmpid) 
888e 5f				ld e, a 
888f			 
888f 21 40 00				ld hl, STORE_BLOCK_PHY 
8892 cd ab 84				call storage_findnextid 
8895			 
8895 cd 04 8d			call ishlzero 
8898 28 cc			jr z, .sa_notfound 
889a			 
889a 22 65 ea			ld (store_tmppageid), hl 
889d			 
889d				; TODO handle file id not found 
889d			 
889d				if DEBUG_STORESE 
889d					DMARK "AP2" 
889d f5				push af  
889e 3a b2 88			ld a, (.dmark)  
88a1 32 6b ee			ld (debug_mark),a  
88a4 3a b3 88			ld a, (.dmark+1)  
88a7 32 6c ee			ld (debug_mark+1),a  
88aa 3a b4 88			ld a, (.dmark+2)  
88ad 32 6d ee			ld (debug_mark+2),a  
88b0 18 03			jr .pastdmark  
88b2 ..			.dmark: db "AP2"  
88b5 f1			.pastdmark: pop af  
88b6			endm  
# End of macro DMARK
88b6					CALLMONITOR 
88b6 cd 6f ee			call debug_vector  
88b9				endm  
# End of macro CALLMONITOR
88b9				endif 
88b9			 
88b9				; update file extent count 
88b9			 
88b9 11 7a ea			ld de, store_page 
88bc			 
88bc cd 78 81			call storage_read_block 
88bf			 
88bf				if DEBUG_STORESE 
88bf					DMARK "AP3" 
88bf f5				push af  
88c0 3a d4 88			ld a, (.dmark)  
88c3 32 6b ee			ld (debug_mark),a  
88c6 3a d5 88			ld a, (.dmark+1)  
88c9 32 6c ee			ld (debug_mark+1),a  
88cc 3a d6 88			ld a, (.dmark+2)  
88cf 32 6d ee			ld (debug_mark+2),a  
88d2 18 03			jr .pastdmark  
88d4 ..			.dmark: db "AP3"  
88d7 f1			.pastdmark: pop af  
88d8			endm  
# End of macro DMARK
88d8					CALLMONITOR 
88d8 cd 6f ee			call debug_vector  
88db				endm  
# End of macro CALLMONITOR
88db				endif 
88db			;	ld (store_tmppageid), hl 
88db			 
88db 3a 7c ea			ld a, (store_page+2) 
88de 3c				inc a 
88df 32 7c ea			ld (store_page+2), a 
88e2 32 6d ea			ld (store_tmpext), a 
88e5				 
88e5				if DEBUG_STORESE 
88e5					DMARK "AP3" 
88e5 f5				push af  
88e6 3a fa 88			ld a, (.dmark)  
88e9 32 6b ee			ld (debug_mark),a  
88ec 3a fb 88			ld a, (.dmark+1)  
88ef 32 6c ee			ld (debug_mark+1),a  
88f2 3a fc 88			ld a, (.dmark+2)  
88f5 32 6d ee			ld (debug_mark+2),a  
88f8 18 03			jr .pastdmark  
88fa ..			.dmark: db "AP3"  
88fd f1			.pastdmark: pop af  
88fe			endm  
# End of macro DMARK
88fe					CALLMONITOR 
88fe cd 6f ee			call debug_vector  
8901				endm  
# End of macro CALLMONITOR
8901				endif 
8901 2a 65 ea			ld hl, (store_tmppageid) 
8904 11 7a ea			ld de, store_page 
8907 cd dd 81			call storage_write_block 
890a			 
890a				; find free block 
890a			 
890a 11 00 00			ld de, 0			 ; file extent to locate 
890d			 
890d 21 40 00				ld hl, STORE_BLOCK_PHY 
8910 cd ab 84				call storage_findnextid 
8913 cd 04 8d			call ishlzero 
8916 ca 66 88			jp z, .sa_notfound 
8919			 
8919					; TODO handle no space left 
8919					 
8919 22 65 ea				ld (store_tmppageid), hl 
891c			 
891c				if DEBUG_STORESE 
891c					DMARK "AP4" 
891c f5				push af  
891d 3a 31 89			ld a, (.dmark)  
8920 32 6b ee			ld (debug_mark),a  
8923 3a 32 89			ld a, (.dmark+1)  
8926 32 6c ee			ld (debug_mark+1),a  
8929 3a 33 89			ld a, (.dmark+2)  
892c 32 6d ee			ld (debug_mark+2),a  
892f 18 03			jr .pastdmark  
8931 ..			.dmark: db "AP4"  
8934 f1			.pastdmark: pop af  
8935			endm  
# End of macro DMARK
8935					CALLMONITOR 
8935 cd 6f ee			call debug_vector  
8938				endm  
# End of macro CALLMONITOR
8938				endif 
8938					; init the buffer with zeros so we can id if the buffer is full or not 
8938			 
8938 e5					push hl 
8939 c5					push bc 
893a			 
893a 21 7a ea				ld hl, store_page 
893d 06 40				ld b, STORE_BLOCK_PHY 
893f 3e 00				ld a, 0 
8941 77			.zeroblock:	ld (hl), a 
8942 23					inc hl 
8943 10 fc				djnz .zeroblock 
8945			 
8945 c1					pop bc 
8946 e1					pop hl 
8947			 
8947					; construct block 
8947			 
8947 3a 6e ea				ld a, (store_tmpid) 
894a 32 7a ea				ld (store_page), a   ; file id 
894d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8950 32 7b ea				ld (store_page+1), a 
8953			 
8953 e1					pop hl    ; get string to write 
8954 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8956 11 7c ea				ld de, store_page+2 
8959			 
8959				if DEBUG_STORESE 
8959					DMARK "AP5" 
8959 f5				push af  
895a 3a 6e 89			ld a, (.dmark)  
895d 32 6b ee			ld (debug_mark),a  
8960 3a 6f 89			ld a, (.dmark+1)  
8963 32 6c ee			ld (debug_mark+1),a  
8966 3a 70 89			ld a, (.dmark+2)  
8969 32 6d ee			ld (debug_mark+2),a  
896c 18 03			jr .pastdmark  
896e ..			.dmark: db "AP5"  
8971 f1			.pastdmark: pop af  
8972			endm  
# End of macro DMARK
8972					CALLMONITOR 
8972 cd 6f ee			call debug_vector  
8975				endm  
# End of macro CALLMONITOR
8975				endif 
8975			 
8975			 
8975			 
8975					; fill buffer with data until end of string or full block 
8975			 
8975 7e			.appd:		ld a, (hl) 
8976 12					ld (de), a 
8977 fe 00				cp 0 
8979 28 04				jr z, .appdone 
897b 23					inc hl 
897c 13					inc de 
897d 10 f6				djnz .appd 
897f			 
897f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8980 f5					push af   		; save last byte dumped 
8981			 
8981			 
8981 2a 65 ea			ld hl, (store_tmppageid) 
8984 11 7a ea			ld de, store_page 
8987				if DEBUG_STORESE 
8987					DMARK "AP6" 
8987 f5				push af  
8988 3a 9c 89			ld a, (.dmark)  
898b 32 6b ee			ld (debug_mark),a  
898e 3a 9d 89			ld a, (.dmark+1)  
8991 32 6c ee			ld (debug_mark+1),a  
8994 3a 9e 89			ld a, (.dmark+2)  
8997 32 6d ee			ld (debug_mark+2),a  
899a 18 03			jr .pastdmark  
899c ..			.dmark: db "AP6"  
899f f1			.pastdmark: pop af  
89a0			endm  
# End of macro DMARK
89a0					CALLMONITOR 
89a0 cd 6f ee			call debug_vector  
89a3				endm  
# End of macro CALLMONITOR
89a3				endif 
89a3 cd dd 81				call storage_write_block 
89a6			 
89a6			 
89a6				; was that a full block of data written? 
89a6				; any more to write out? 
89a6			 
89a6				; if yes then set vars and jump to start of function again 
89a6			 
89a6 f1					pop af 
89a7 d1					pop de 
89a8			 
89a8 fe 00				cp 0		 ; no, string was fully written 
89aa c8					ret z 
89ab			 
89ab					; setup vars for next cycle 
89ab			 
89ab 3a 6e ea				ld a, (store_tmpid) 
89ae 6f					ld l, a 
89af 26 00				ld h, 0 
89b1			 
89b1 c3 68 88			 	jp storage_append	 ; yes, need to write out some more 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			if DEBUG_STORECF 
89b4			storageput:	 
89b4					ret 
89b4			storageread: 
89b4					ld hl, store_page 
89b4					ld b, 200 
89b4					ld a,0 
89b4			.src:		ld (hl),a 
89b4					inc hl 
89b4					djnz .src 
89b4					 
89b4			 
89b4					ld de, 0 
89b4					ld bc, 1 
89b4					ld hl, store_page 
89b4					call cfRead 
89b4			 
89b4				call cfGetError 
89b4				ld hl,scratch 
89b4				call hexout 
89b4				ld hl, scratch+2 
89b4				ld a, 0 
89b4				ld (hl),a 
89b4				ld de, scratch 
89b4				ld a,display_row_1 
89b4				call str_at_display 
89b4				call update_display 
89b4			 
89b4					ld hl, store_page 
89b4					ld (os_cur_ptr),hl 
89b4			 
89b4					ret 
89b4			endif 
89b4			 
89b4			 
89b4			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b4			 
89b4			storage_clear_page: 
89b4 e5				push hl 
89b5 d5				push de 
89b6 c5				push bc 
89b7 21 7a ea			ld hl, store_page 
89ba 3e 00			ld a, 0 
89bc 77				ld (hl), a 
89bd			 
89bd 11 7b ea			ld de, store_page+1 
89c0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c3			 
89c3 ed b0			ldir 
89c5				 
89c5 c1				pop bc 
89c6 d1				pop de 
89c7 e1				pop hl 
89c8 c9				ret 
89c9			 
89c9			; eof 
# End of file firmware_storage.asm
89c9			  
89c9			; support routines for above hardware abstraction layer  
89c9			  
89c9			include "firmware_general.asm"        ; general support functions  
89c9			 
89c9			; word look up 
89c9			 
89c9			; in 
89c9			; a is the index 
89c9			; hl is pointer start of array 
89c9			; 
89c9			; returns 
89c9			; hl to the word 
89c9			; 
89c9			 
89c9			table_lookup:  
89c9 d5					push de 
89ca eb					ex de, hl 
89cb			 
89cb 6f					ld l, a 
89cc 26 00				ld h, 0 
89ce 29					add hl, hl 
89cf 19					add hl, de 
89d0 7e					ld a, (hl) 
89d1 23					inc hl 
89d2 66					ld h,(hl) 
89d3 6f					ld l, a 
89d4			 
89d4 d1					pop de 
89d5 c9					ret 
89d6			 
89d6			; Delay loops 
89d6			 
89d6			 
89d6			 
89d6			aDelayInMS: 
89d6 c5				push bc 
89d7 47				ld b,a 
89d8			msdelay: 
89d8 c5				push bc 
89d9				 
89d9			 
89d9 01 41 00			ld bc,041h 
89dc cd f4 89			call delayloop 
89df c1				pop bc 
89e0 05				dec b 
89e1 20 f5			jr nz,msdelay 
89e3			 
89e3			;if CPU_CLOCK_8MHZ 
89e3			;msdelay8: 
89e3			;	push bc 
89e3			;	 
89e3			; 
89e3			;	ld bc,041h 
89e3			;	call delayloop 
89e3			;	pop bc 
89e3			;	dec b 
89e3			;	jr nz,msdelay8 
89e3			;endif 
89e3			 
89e3			 
89e3 c1				pop bc 
89e4 c9				ret 
89e5			 
89e5			 
89e5			delay250ms: 
89e5				;push de 
89e5 01 00 40			ld bc, 04000h 
89e8 c3 f4 89			jp delayloop 
89eb			delay500ms: 
89eb				;push de 
89eb 01 00 80			ld bc, 08000h 
89ee c3 f4 89			jp delayloop 
89f1			delay1s: 
89f1				;push bc 
89f1			   ; Clobbers A, d and e 
89f1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f4			delayloop: 
89f4 c5			    push bc 
89f5			 
89f5			if BASE_CPM 
89f5				ld bc, CPM_DELAY_TUNE 
89f5			.cpmloop: 
89f5				push bc 
89f5			 
89f5			endif 
89f5			 
89f5			 
89f5			 
89f5			delayloopi: 
89f5			;	push bc 
89f5			;.dl: 
89f5 cb 47		    bit     0,a    	; 8 
89f7 cb 47		    bit     0,a    	; 8 
89f9 cb 47		    bit     0,a    	; 8 
89fb e6 ff		    and     255  	; 7 
89fd 0b			    dec     bc      	; 6 
89fe 79			    ld      a,c     	; 4 
89ff b0			    or      b     	; 4 
8a00 c2 f5 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a03			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a03				;pop de 
8a03			;pop bc 
8a03			 
8a03			if BASE_CPM 
8a03				pop bc 
8a03				 
8a03			    dec     bc      	; 6 
8a03			    ld      a,c     	; 4 
8a03			    or      b     	; 4 
8a03			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a03				 
8a03			 
8a03			endif 
8a03			;if CPU_CLOCK_8MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03			 
8a03			;if CPU_CLOCK_10MHZ 
8a03			;    pop bc 
8a03			;    push bc 
8a03			;.dl8: 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    bit     0,a    	; 8 
8a03			;    and     255  	; 7 
8a03			;    dec     bc      	; 6 
8a03			;    ld      a,c     	; 4 
8a03			;    or      b     	; 4 
8a03			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a03			;endif 
8a03 c1			    pop bc 
8a04			 
8a04 c9				ret 
8a05			 
8a05			 
8a05			 
8a05			; eof 
# End of file firmware_general.asm
8a05			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a05			; display routines that use the physical hardware abstraction layer 
8a05			 
8a05			 
8a05			; Display an activity indicator 
8a05			; Each call returns the new char pointed to in hl 
8a05			 
8a05			active: 
8a05 3a c6 eb			ld a, (display_active) 
8a08 fe 06			cp 6 
8a0a			 
8a0a 20 02			jr nz, .sne 
8a0c				; gone past the last one reset sequence 
8a0c 3e ff			ld a, 255 
8a0e			 
8a0e			.sne:   
8a0e				; get the next char in seq 
8a0e 3c				inc a 
8a0f 32 c6 eb			ld (display_active), a 
8a12			 
8a12				; look up the string in the table 
8a12 21 29 8a			ld hl, actseq 
8a15 cb 27			sla a 
8a17 cd db 8c			call addatohl 
8a1a cd 6a 9e			call loadwordinhl 
8a1d			 
8a1d				; forth will write the to string when pushing so move from rom to ram 
8a1d			 
8a1d 11 c7 eb			ld de, display_active+1 
8a20 01 02 00			ld bc, 2 
8a23 ed b0			ldir 
8a25			 
8a25 21 c7 eb			ld hl, display_active+1 
8a28 c9				ret 
8a29				 
8a29				 
8a29			 
8a29			 
8a29			;db "|/-\|-\" 
8a29			 
8a29			actseq: 
8a29			 
8a29 37 8a		dw spin0 
8a2b 39 8a		dw spin1 
8a2d 3b 8a		dw spin2 
8a2f 3d 8a		dw spin3 
8a31 3b 8a		dw spin2 
8a33 39 8a		dw spin1 
8a35 37 8a		dw spin0 
8a37			 
8a37 .. 00		spin0: db " ", 0 
8a39 .. 00		spin1: db "-", 0 
8a3b .. 00		spin2: db "+", 0 
8a3d .. 00		spin3: db "#", 0 
8a3f			 
8a3f			 
8a3f			; information window 
8a3f			 
8a3f			; pass hl with 1st string to display 
8a3f			; pass de with 2nd string to display 
8a3f			 
8a3f			info_panel: 
8a3f e5				push hl 
8a40			 
8a40 2a cc eb			ld hl, (display_fb_active) 
8a43 e5				push hl    ; future de destination 
8a44 21 b1 ed				ld hl, display_fb0 
8a47 22 cc eb				ld (display_fb_active), hl 
8a4a			 
8a4a			;	call clear_display 
8a4a			 
8a4a				if BASE_CPM 
8a4a				ld a, '.' 
8a4a				else 
8a4a 3e a5			ld a, 165 
8a4c				endif 
8a4c cd b3 8a			call fill_display 
8a4f			 
8a4f			 
8a4f 3e 55			ld a, display_row_3 + 5 
8a51 cd c1 8a			call str_at_display 
8a54			 
8a54 e1				pop hl 
8a55 d1				pop de 
8a56			 
8a56 e5				push hl 
8a57			 
8a57			 
8a57 3e 2d			ld a, display_row_2 + 5 
8a59 cd c1 8a			call str_at_display 
8a5c			 
8a5c			 
8a5c cd d1 8a			call update_display 
8a5f cd b3 9a			call next_page_prompt 
8a62 cd ae 8a			call clear_display 
8a65			 
8a65				 
8a65 21 10 ed				ld hl, display_fb1 
8a68 22 cc eb				ld (display_fb_active), hl 
8a6b cd d1 8a			call update_display 
8a6e			 
8a6e e1				pop hl 
8a6f			 
8a6f c9				ret 
8a70			 
8a70			 
8a70			 
8a70			 
8a70			; TODO windowing? 
8a70			 
8a70			; TODO scroll line up 
8a70			 
8a70			scroll_up: 
8a70			 
8a70 e5				push hl 
8a71 d5				push de 
8a72 c5				push bc 
8a73			 
8a73				; get frame buffer  
8a73			 
8a73 2a cc eb			ld hl, (display_fb_active) 
8a76 e5				push hl    ; future de destination 
8a77			 
8a77 11 28 00			ld  de, display_cols 
8a7a 19				add hl, de 
8a7b			 
8a7b d1				pop de 
8a7c			 
8a7c				;ex de, hl 
8a7c 01 9f 00			ld bc, display_fb_len -1  
8a7f			;if DEBUG_FORTH_WORDS 
8a7f			;	DMARK "SCL" 
8a7f			;	CALLMONITOR 
8a7f			;endif	 
8a7f ed b0			ldir 
8a81			 
8a81				; wipe bottom row 
8a81			 
8a81			 
8a81 2a cc eb			ld hl, (display_fb_active) 
8a84 11 a0 00			ld de, display_cols*display_rows 
8a87 19				add hl, de 
8a88 06 28			ld b, display_cols 
8a8a 3e 20			ld a, ' ' 
8a8c			.scwipe: 
8a8c 77				ld (hl), a 
8a8d 2b				dec hl 
8a8e 10 fc			djnz .scwipe 
8a90			 
8a90				;pop hl 
8a90			 
8a90 c1				pop bc 
8a91 d1				pop de 
8a92 e1				pop hl 
8a93			 
8a93 c9				ret 
8a94			 
8a94			 
8a94			;scroll_upo: 
8a94			;	ld de, display_row_1 
8a94			 ;	ld hl, display_row_2 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_2 
8a94			 ;	ld hl, display_row_3 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			;	ld de, display_row_3 
8a94			 ;	ld hl, display_row_4 
8a94			;	ld bc, display_cols 
8a94			;	ldir 
8a94			 
8a94			; TODO clear row 4 
8a94			 
8a94			;	ret 
8a94			 
8a94				 
8a94			scroll_down: 
8a94			 
8a94 e5				push hl 
8a95 d5				push de 
8a96 c5				push bc 
8a97			 
8a97				; get frame buffer  
8a97			 
8a97 2a cc eb			ld hl, (display_fb_active) 
8a9a			 
8a9a 11 9f 00			ld de, display_fb_len - 1 
8a9d 19				add hl, de 
8a9e			 
8a9e e5			push hl    ; future de destination 
8a9f			 
8a9f 11 28 00			ld  de, display_cols 
8aa2 ed 52			sbc hl, de 
8aa4			 
8aa4			 
8aa4 d1				pop de 
8aa5			 
8aa5			;	ex de, hl 
8aa5 01 9f 00			ld bc, display_fb_len -1  
8aa8			 
8aa8			 
8aa8				 
8aa8			 
8aa8 ed b0			ldir 
8aaa			 
8aaa				; wipe bottom row 
8aaa			 
8aaa			 
8aaa			;	ld hl, (display_fb_active) 
8aaa			;;	ld de, display_cols*display_rows 
8aaa			;;	add hl, de 
8aaa			;	ld b, display_cols 
8aaa			;	ld a, ' ' 
8aaa			;.scwiped: 
8aaa			;	ld (hl), a 
8aaa			;	dec hl 
8aaa			;	djnz .scwiped 
8aaa			 
8aaa				;pop hl 
8aaa			 
8aaa c1				pop bc 
8aab d1				pop de 
8aac e1				pop hl 
8aad			 
8aad c9				ret 
8aae			;scroll_down: 
8aae			;	ld de, display_row_4 
8aae			;	ld hl, display_row_3 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_3 
8aae			; 	ld hl, display_row_2 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;	ld de, display_row_2 
8aae			;	ld hl, display_row_1 
8aae			;	ld bc, display_cols 
8aae			;	ldir 
8aae			;;; TODO clear row 1 
8aae			;	ret 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			 
8aae			; clear active frame buffer 
8aae			 
8aae			clear_display: 
8aae 3e 20			ld a, ' ' 
8ab0 c3 b3 8a			jp fill_display 
8ab3			 
8ab3			; fill active frame buffer with a char in A 
8ab3			 
8ab3			fill_display: 
8ab3 06 a0			ld b,display_fb_len 
8ab5 2a cc eb			ld hl, (display_fb_active) 
8ab8 77			.fd1:	ld (hl),a 
8ab9 23				inc hl 
8aba 10 fc			djnz .fd1 
8abc 23				inc hl 
8abd 3e 00			ld a,0 
8abf 77				ld (hl),a 
8ac0			 
8ac0			 
8ac0 c9				ret 
8ac1			; Write string (DE) at pos (A) to active frame buffer 
8ac1			 
8ac1 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac4 06 00					ld b,0 
8ac6 4f					ld c,a 
8ac7 09					add hl,bc 
8ac8 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ac9 b7			            OR   A              ;Null terminator? 
8aca c8			            RET  Z              ;Yes, so finished 
8acb 77					ld (hl),a 
8acc 23				inc hl 
8acd 13			            INC  DE             ;Point to next character 
8ace 18 f8		            JR   .sad1     ;Repeat 
8ad0 c9					ret 
8ad1			 
8ad1			; using current frame buffer write to physical display 
8ad1			 
8ad1			update_display: 
8ad1 e5				push hl 
8ad2 2a cc eb			ld hl, (display_fb_active) 
8ad5 cd d0 e3			call write_display 
8ad8 e1				pop hl 
8ad9 c9				ret 
8ada			 
8ada			; TODO scrolling 
8ada			 
8ada			 
8ada			; move cursor right one char 
8ada			cursor_right: 
8ada			 
8ada				; TODO shift right 
8ada				; TODO if beyond max col 
8ada				; TODO       cursor_next_line 
8ada			 
8ada c9				ret 
8adb			 
8adb			 
8adb			cursor_next_line: 
8adb				; TODO first char 
8adb				; TODO line down 
8adb				; TODO if past last row 
8adb				; TODO    scroll up 
8adb			 
8adb c9				ret 
8adc			 
8adc			cursor_left: 
8adc				; TODO shift left 
8adc				; TODO if beyond left  
8adc				; TODO     cursor prev line 
8adc				 
8adc c9				ret 
8add			 
8add			cursor_prev_line: 
8add				; TODO last char 
8add				; TODO line up 
8add				; TODO if past first row 
8add				; TODO   scroll down 
8add			 
8add c9				ret 
8ade			 
8ade			 
8ade			cout: 
8ade				; A - char 
8ade c9				ret 
8adf			 
8adf			 
8adf			; Display a menu and allow item selection (optional toggle items) 
8adf			; 
8adf			; format: 
8adf			; hl pointer to word array with zero term for items 
8adf			; e.g.    db item1 
8adf			;         db .... 
8adf			;         db 0 
8adf			; 
8adf			; a = starting menu item  
8adf			; 
8adf			; de = pointer item toggle array   (todo) 
8adf			; 
8adf			; returns item selected in a 1-... 
8adf			; returns 0 if back button pressed 
8adf			; 
8adf			; NOTE: Uses system frame buffer to display 
8adf			; 
8adf			; LEFT, Q = go back 
8adf			; RIGHT, SPACE, CR = select 
8adf			; UP, A - Up 
8adf			; DOWN, Z - Down 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			 
8adf			menu: 
8adf			 
8adf					; keep array pointer 
8adf			 
8adf 22 73 ea				ld (store_tmp1), hl 
8ae2 32 71 ea				ld (store_tmp2), a 
8ae5			 
8ae5					; check for key bounce 
8ae5			 
8ae5			if BASE_KEV 
8ae5			 
8ae5			.mbounce:	call cin 
8ae5					cp 0 
8ae5					jr nz, .mbounce 
8ae5			endif 
8ae5					; for ease use ex 
8ae5			 
8ae5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae5 21 b1 ed				ld hl, display_fb0 
8ae8 22 cc eb				ld (display_fb_active), hl 
8aeb			 
8aeb cd ae 8a		.mloop:		call clear_display 
8aee cd d1 8a				call update_display 
8af1			 
8af1					; draw selection id '>' at 1 
8af1			 
8af1					; init start of list display 
8af1			 
8af1 3e 05				ld a, 5 
8af3 32 6f ea				ld (store_tmp3), a   ; display row count 
8af6 3a 71 ea				ld a,( store_tmp2) 
8af9 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afc			 
8afc					 
8afc			.mitem:	 
8afc			 
8afc			 
8afc 3a 72 ea				ld a,(store_tmp2+1) 
8aff 6f					ld l, a 
8b00 26 00				ld h, 0 
8b02 29					add hl, hl 
8b03 ed 5b 73 ea			ld de, (store_tmp1) 
8b07 19					add hl, de 
8b08 7e					ld a, (hl) 
8b09 23					inc hl 
8b0a 66					ld h,(hl) 
8b0b 6f					ld l, a 
8b0c			 
8b0c cd 04 8d				call ishlzero 
8b0f 28 1a				jr z, .mdone 
8b11			 
8b11 eb					ex de, hl 
8b12 3a 6f ea				ld a, (store_tmp3) 
8b15 cd c1 8a				call str_at_display 
8b18					 
8b18			 
8b18					; next item 
8b18 3a 72 ea				ld a, (store_tmp2+1) 
8b1b 3c					inc a 
8b1c 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b1f			 
8b1f			 		; next row 
8b1f			 
8b1f 3a 6f ea				ld a, (store_tmp3) 
8b22 c6 28				add display_cols 
8b24 32 6f ea				ld (store_tmp3), a 
8b27			 
8b27					; at end of screen? 
8b27			 
8b27 fe 10				cp display_rows*4 
8b29 20 d1				jr nz, .mitem 
8b2b			 
8b2b			 
8b2b			.mdone: 
8b2b cd 04 8d				call ishlzero 
8b2e 28 08				jr z, .nodn 
8b30			 
8b30 3e 78				ld a, display_row_4 
8b32 11 b1 8b				ld de, .mdown 
8b35 cd c1 8a				call str_at_display 
8b38			 
8b38					; draw options to fill the screens with active item on line 1 
8b38					; if current option is 2 or more then display ^ in top 
8b38			 
8b38 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3b fe 00				cp 0 
8b3d 28 08				jr z, .noup 
8b3f			 
8b3f 3e 00				ld a, 0 
8b41 11 af 8b				ld de, .mup 
8b44 cd c1 8a				call str_at_display 
8b47			 
8b47 3e 02		.noup:		ld a, 2 
8b49 11 ad 8b				ld de, .msel 
8b4c cd c1 8a				call str_at_display 
8b4f			 
8b4f					; if current option + 1 is not null then display V in bottom 
8b4f					; get key 
8b4f cd d1 8a				call update_display 
8b52			 
8b52			 
8b52					; handle key 
8b52			 
8b52 cd 5c e4				call cin_wait 
8b55			 
8b55 fe 05				cp KEY_UP 
8b57 28 2b				jr z, .mgoup 
8b59 fe 61				cp 'a' 
8b5b 28 27				jr z, .mgoup 
8b5d fe 0a				cp KEY_DOWN 
8b5f 28 32				jr z, .mgod 
8b61 fe 7a				cp 'z' 
8b63 28 2e				jr z, .mgod 
8b65 fe 20				cp ' ' 
8b67 28 34				jr z, .goend 
8b69 fe 0c				cp KEY_RIGHT 
8b6b 28 30				jr z, .goend 
8b6d fe 0d				cp KEY_CR 
8b6f 28 2c				jr z, .goend 
8b71 fe 71				cp 'q' 
8b73 28 0b				jr z, .goback 
8b75			 
8b75 fe 0b				cp KEY_LEFT 
8b77 28 07				jr z, .goback 
8b79 fe 08				cp KEY_BS 
8b7b 28 03				jr z, .goback 
8b7d c3 eb 8a				jp .mloop 
8b80			 
8b80			.goback: 
8b80 3e 00			ld a, 0 
8b82 18 1d			jr .goend2 
8b84			 
8b84				; move up one 
8b84			.mgoup: 
8b84 3a 71 ea				ld a, (store_tmp2) 
8b87 fe 00				cp 0 
8b89 ca eb 8a				jp z, .mloop 
8b8c 3d					dec a 
8b8d 32 71 ea				ld (store_tmp2), a 
8b90 c3 eb 8a				jp .mloop 
8b93			 
8b93				; move down one 
8b93			.mgod: 
8b93 3a 71 ea				ld a, (store_tmp2) 
8b96 3c					inc a 
8b97 32 71 ea				ld (store_tmp2), a 
8b9a c3 eb 8a				jp .mloop 
8b9d			 
8b9d			 
8b9d			.goend: 
8b9d					; get selected item number 
8b9d			 
8b9d 3a 71 ea				ld a, (store_tmp2) 
8ba0 3c					inc a 
8ba1			 
8ba1			.goend2: 
8ba1 f5					push af 
8ba2			 
8ba2					; restore active fb 
8ba2					; TODO BUG assumes fb1 
8ba2			 
8ba2 21 10 ed				ld hl, display_fb1 
8ba5 22 cc eb				ld (display_fb_active), hl 
8ba8			 
8ba8					; restore main regs 
8ba8			 
8ba8			 
8ba8 cd d1 8a				call update_display 
8bab			 
8bab f1					pop af 
8bac			 
8bac c9				ret 
8bad			 
8bad .. 00		.msel:   db ">",0 
8baf .. 00		.mup:   db "^",0 
8bb1 .. 00		.mdown:   db "v",0 
8bb3			 
8bb3			 
8bb3			; eof 
8bb3			 
# End of file firmware_display.asm
8bb3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb3			; random number generators 
8bb3			 
8bb3			 
8bb3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb3			 
8bb3			 
8bb3			;-----> Generate a random number 
8bb3			; output a=answer 0<=a<=255 
8bb3			; all registers are preserved except: af 
8bb3			random: 
8bb3 e5			        push    hl 
8bb4 d5			        push    de 
8bb5 2a ab eb		        ld      hl,(randData) 
8bb8 ed 5f		        ld      a,r 
8bba 57			        ld      d,a 
8bbb 5e			        ld      e,(hl) 
8bbc 19			        add     hl,de 
8bbd 85			        add     a,l 
8bbe ac			        xor     h 
8bbf 22 ab eb		        ld      (randData),hl 
8bc2 d1			        pop     de 
8bc3 e1			        pop     hl 
8bc4 c9			        ret 
8bc5			 
8bc5			 
8bc5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc5			 
8bc5			 
8bc5			 
8bc5			;------LFSR------ 
8bc5			;James Montelongo 
8bc5			;optimized by Spencer Putt 
8bc5			;out: 
8bc5			; a = 8 bit random number 
8bc5			RandLFSR: 
8bc5 21 b1 eb		        ld hl,LFSRSeed+4 
8bc8 5e			        ld e,(hl) 
8bc9 23			        inc hl 
8bca 56			        ld d,(hl) 
8bcb 23			        inc hl 
8bcc 4e			        ld c,(hl) 
8bcd 23			        inc hl 
8bce 7e			        ld a,(hl) 
8bcf 47			        ld b,a 
8bd0 cb 13		        rl e  
8bd2 cb 12			rl d 
8bd4 cb 11		        rl c  
8bd6 17				rla 
8bd7 cb 13		        rl e  
8bd9 cb 12			rl d 
8bdb cb 11		        rl c  
8bdd 17				rla 
8bde cb 13		        rl e  
8be0 cb 12			rl d 
8be2 cb 11		        rl c  
8be4 17				rla 
8be5 67			        ld h,a 
8be6 cb 13		        rl e  
8be8 cb 12			rl d 
8bea cb 11		        rl c  
8bec 17				rla 
8bed a8			        xor b 
8bee cb 13		        rl e  
8bf0 cb 12			rl d 
8bf2 ac			        xor h 
8bf3 a9			        xor c 
8bf4 aa			        xor d 
8bf5 21 b3 eb		        ld hl,LFSRSeed+6 
8bf8 11 b4 eb		        ld de,LFSRSeed+7 
8bfb 01 07 00		        ld bc,7 
8bfe ed b8		        lddr 
8c00 12			        ld (de),a 
8c01 c9			        ret 
8c02			 
8c02			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c02			 
8c02			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c02			 
8c02			 
8c02			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c02			 
8c02			prng16: 
8c02			;Inputs: 
8c02			;   (seed1) contains a 16-bit seed value 
8c02			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c02			;Outputs: 
8c02			;   HL is the result 
8c02			;   BC is the result of the LCG, so not that great of quality 
8c02			;   DE is preserved 
8c02			;Destroys: 
8c02			;   AF 
8c02			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c02			;160cc 
8c02			;26 bytes 
8c02 2a a5 eb		    ld hl,(seed1) 
8c05 44			    ld b,h 
8c06 4d			    ld c,l 
8c07 29			    add hl,hl 
8c08 29			    add hl,hl 
8c09 2c			    inc l 
8c0a 09			    add hl,bc 
8c0b 22 a5 eb		    ld (seed1),hl 
8c0e 2a a3 eb		    ld hl,(seed2) 
8c11 29			    add hl,hl 
8c12 9f			    sbc a,a 
8c13 e6 2d		    and %00101101 
8c15 ad			    xor l 
8c16 6f			    ld l,a 
8c17 22 a3 eb		    ld (seed2),hl 
8c1a 09			    add hl,bc 
8c1b c9			    ret 
8c1c			 
8c1c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1c			 
8c1c			rand32: 
8c1c			;Inputs: 
8c1c			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1c			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1c			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1c			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1c			;   **NOTE: seed2 must be non-zero 
8c1c			;Outputs: 
8c1c			;   HL is the result 
8c1c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1c			;Destroys: 
8c1c			;   AF 
8c1c			;Tested and passes all CAcert tests 
8c1c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1c			;it has a period of 18,446,744,069,414,584,320 
8c1c			;roughly 18.4 quintillion. 
8c1c			;LFSR taps: 0,2,6,7  = 11000101 
8c1c			;291cc 
8c1c			;seed1_0=$+1 
8c1c			;    ld hl,12345 
8c1c			;seed1_1=$+1 
8c1c			;    ld de,6789 
8c1c			;    ld b,h 
8c1c			;    ld c,l 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    add hl,hl \ rl e \ rl d 
8c1c			;    inc l 
8c1c			;    add hl,bc 
8c1c			;    ld (seed1_0),hl 
8c1c			;    ld hl,(seed1_1) 
8c1c			;    adc hl,de 
8c1c			;    ld (seed1_1),hl 
8c1c			;    ex de,hl 
8c1c			;seed2_0=$+1 
8c1c			;    ld hl,9876 
8c1c			;seed2_1=$+1 
8c1c			;    ld bc,54321 
8c1c			;    add hl,hl \ rl c \ rl b 
8c1c			;    ld (seed2_1),bc 
8c1c			;    sbc a,a 
8c1c			;    and %11000101 
8c1c			;    xor l 
8c1c			;    ld l,a 
8c1c			;    ld (seed2_0),hl 
8c1c			;    ex de,hl 
8c1c			;    add hl,bc 
8c1c			;    ret 
8c1c			; 
8c1c			 
8c1c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1c			; 20 bytes, 86 cycles (excluding ret) 
8c1c			 
8c1c			; returns   hl = pseudorandom number 
8c1c			; corrupts   a 
8c1c			 
8c1c			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1c			; using the xorshift method: 
8c1c			 
8c1c			; hl ^= hl << 7 
8c1c			; hl ^= hl >> 9 
8c1c			; hl ^= hl << 8 
8c1c			 
8c1c			; some alternative shift triplets which also perform well are: 
8c1c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1c			 
8c1c			;  org 32768 
8c1c			 
8c1c			xrnd: 
8c1c 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c1f 3e 00		  ld a,0 
8c21 bd			  cp l 
8c22 20 02		  jr nz, .xrnd1 
8c24 2e 01		  ld l, 1 
8c26			.xrnd1: 
8c26			 
8c26 7c			  ld a,h 
8c27 1f			  rra 
8c28 7d			  ld a,l 
8c29 1f			  rra 
8c2a ac			  xor h 
8c2b 67			  ld h,a 
8c2c 7d			  ld a,l 
8c2d 1f			  rra 
8c2e 7c			  ld a,h 
8c2f 1f			  rra 
8c30 ad			  xor l 
8c31 6f			  ld l,a 
8c32 ac			  xor h 
8c33 67			  ld h,a 
8c34			 
8c34 22 a9 eb		  ld (xrandc),hl 
8c37			 
8c37 c9			  ret 
8c38			;  
8c38			 
8c38			 
8c38			;;;; int maths 
8c38			 
8c38			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c38			; Divide 16-bit values (with 16-bit result) 
8c38			; In: Divide BC by divider DE 
8c38			; Out: BC = result, HL = rest 
8c38			; 
8c38			Div16: 
8c38 21 00 00		    ld hl,0 
8c3b 78			    ld a,b 
8c3c 06 08		    ld b,8 
8c3e			Div16_Loop1: 
8c3e 17			    rla 
8c3f ed 6a		    adc hl,hl 
8c41 ed 52		    sbc hl,de 
8c43 30 01		    jr nc,Div16_NoAdd1 
8c45 19			    add hl,de 
8c46			Div16_NoAdd1: 
8c46 10 f6		    djnz Div16_Loop1 
8c48 17			    rla 
8c49 2f			    cpl 
8c4a 47			    ld b,a 
8c4b 79			    ld a,c 
8c4c 48			    ld c,b 
8c4d 06 08		    ld b,8 
8c4f			Div16_Loop2: 
8c4f 17			    rla 
8c50 ed 6a		    adc hl,hl 
8c52 ed 52		    sbc hl,de 
8c54 30 01		    jr nc,Div16_NoAdd2 
8c56 19			    add hl,de 
8c57			Div16_NoAdd2: 
8c57 10 f6		    djnz Div16_Loop2 
8c59 17			    rla 
8c5a 2f			    cpl 
8c5b 41			    ld b,c 
8c5c 4f			    ld c,a 
8c5d c9			ret 
8c5e			 
8c5e			 
8c5e			;http://z80-heaven.wikidot.com/math 
8c5e			; 
8c5e			;Inputs: 
8c5e			;     DE and A are factors 
8c5e			;Outputs: 
8c5e			;     A is not changed 
8c5e			;     B is 0 
8c5e			;     C is not changed 
8c5e			;     DE is not changed 
8c5e			;     HL is the product 
8c5e			;Time: 
8c5e			;     342+6x 
8c5e			; 
8c5e			Mult16: 
8c5e			 
8c5e 06 08		     ld b,8          ;7           7 
8c60 21 00 00		     ld hl,0         ;10         10 
8c63 29			       add hl,hl     ;11*8       88 
8c64 07			       rlca          ;4*8        32 
8c65 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c67 19			         add hl,de   ;--         -- 
8c68 10 f9		       djnz $-5      ;13*7+8     99 
8c6a c9			ret 
8c6b			 
8c6b			; 
8c6b			; Square root of 16-bit value 
8c6b			; In:  HL = value 
8c6b			; Out:  D = result (rounded down) 
8c6b			; 
8c6b			;Sqr16: 
8c6b			;    ld de,#0040 
8c6b			;    ld a,l 
8c6b			;    ld l,h 
8c6b			;    ld h,d 
8c6b			;    or a 
8c6b			;    ld b,8 
8c6b			;Sqr16_Loop: 
8c6b			;    sbc hl,de 
8c6b			;    jr nc,Sqr16_Skip 
8c6b			;    add hl,de 
8c6b			;Sqr16_Skip: 
8c6b			;    ccf 
8c6b			;    rl d 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    add a,a 
8c6b			;    adc hl,hl 
8c6b			;    djnz Sqr16_Loop 
8c6b			;    ret 
8c6b			; 
8c6b			; 
8c6b			; Divide 8-bit values 
8c6b			; In: Divide E by divider C 
8c6b			; Out: A = result, B = rest 
8c6b			; 
8c6b			Div8: 
8c6b af			    xor a 
8c6c 06 08		    ld b,8 
8c6e			Div8_Loop: 
8c6e cb 13		    rl e 
8c70 17			    rla 
8c71 91			    sub c 
8c72 30 01		    jr nc,Div8_NoAdd 
8c74 81			    add a,c 
8c75			Div8_NoAdd: 
8c75 10 f7		    djnz Div8_Loop 
8c77 47			    ld b,a 
8c78 7b			    ld a,e 
8c79 17			    rla 
8c7a 2f			    cpl 
8c7b c9			    ret 
8c7c			 
8c7c			; 
8c7c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7c			; In: Multiply A with DE 
8c7c			; Out: HL = result 
8c7c			; 
8c7c			Mult12U: 
8c7c 2e 00		    ld l,0 
8c7e 87			    add a,a 
8c7f 30 01		    jr nc,Mult12U_NoAdd0 
8c81 19			    add hl,de 
8c82			Mult12U_NoAdd0: 
8c82 29			    add hl,hl 
8c83 87			    add a,a 
8c84 30 01		    jr nc,Mult12U_NoAdd1 
8c86 19			    add hl,de 
8c87			Mult12U_NoAdd1: 
8c87 29			    add hl,hl 
8c88 87			    add a,a 
8c89 30 01		    jr nc,Mult12U_NoAdd2 
8c8b 19			    add hl,de 
8c8c			Mult12U_NoAdd2: 
8c8c 29			    add hl,hl 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd3 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd3: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd4 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd4: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd5 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd5: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d 30 01		    jr nc,Mult12U_NoAdd6 
8c9f 19			    add hl,de 
8ca0			Mult12U_NoAdd6: 
8ca0 29			    add hl,hl 
8ca1 87			    add a,a 
8ca2 d0			    ret nc 
8ca3 19			    add hl,de 
8ca4 c9			    ret 
8ca5			 
8ca5			; 
8ca5			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca5			; In: Multiply A with DE 
8ca5			;      Put lowest value in A for most efficient calculation 
8ca5			; Out: HL = result 
8ca5			; 
8ca5			Mult12R: 
8ca5 21 00 00		    ld hl,0 
8ca8			Mult12R_Loop: 
8ca8 cb 3f		    srl a 
8caa 30 01		    jr nc,Mult12R_NoAdd 
8cac 19			    add hl,de 
8cad			Mult12R_NoAdd: 
8cad cb 23		    sla e 
8caf cb 12		    rl d 
8cb1 b7			    or a 
8cb2 c2 a8 8c		    jp nz,Mult12R_Loop 
8cb5 c9			    ret 
8cb6			 
8cb6			; 
8cb6			; Multiply 16-bit values (with 32-bit result) 
8cb6			; In: Multiply BC with DE 
8cb6			; Out: BCHL = result 
8cb6			; 
8cb6			Mult32: 
8cb6 79			    ld a,c 
8cb7 48			    ld c,b 
8cb8 21 00 00		    ld hl,0 
8cbb 06 10		    ld b,16 
8cbd			Mult32_Loop: 
8cbd 29			    add hl,hl 
8cbe 17			    rla 
8cbf cb 11		    rl c 
8cc1 30 07		    jr nc,Mult32_NoAdd 
8cc3 19			    add hl,de 
8cc4 ce 00		    adc a,0 
8cc6 d2 ca 8c		    jp nc,Mult32_NoAdd 
8cc9 0c			    inc c 
8cca			Mult32_NoAdd: 
8cca 10 f1		    djnz Mult32_Loop 
8ccc 41			    ld b,c 
8ccd 4f			    ld c,a 
8cce c9			    ret 
8ccf			 
8ccf			 
8ccf			 
8ccf			; 
8ccf			; Multiply 8-bit values 
8ccf			; In:  Multiply H with E 
8ccf			; Out: HL = result 
8ccf			; 
8ccf			Mult8: 
8ccf 16 00		    ld d,0 
8cd1 6a			    ld l,d 
8cd2 06 08		    ld b,8 
8cd4			Mult8_Loop: 
8cd4 29			    add hl,hl 
8cd5 30 01		    jr nc,Mult8_NoAdd 
8cd7 19			    add hl,de 
8cd8			Mult8_NoAdd: 
8cd8 10 fa		    djnz Mult8_Loop 
8cda c9			    ret 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			 
8cdb			;;http://z80-heaven.wikidot.com/math 
8cdb			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdb			; 
8cdb			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdb			;     ld a,16        ;7 
8cdb			;     ld hl,0        ;10 
8cdb			;     jp $+5         ;10 
8cdb			;.DivLoop: 
8cdb			;       add hl,bc    ;-- 
8cdb			;       dec a        ;64 
8cdb			;       jr z,.DivLoopEnd        ;86 
8cdb			; 
8cdb			;       sla e        ;128 
8cdb			;       rl d         ;128 
8cdb			;       adc hl,hl    ;240 
8cdb			;       sbc hl,bc    ;240 
8cdb			;       jr nc,.DivLoop ;23|21 
8cdb			;       inc e        ;-- 
8cdb			;       jp .DivLoop+1 
8cdb			; 
8cdb			;.DivLoopEnd: 
8cdb			 
8cdb			;HL_Div_C: 
8cdb			;Inputs: 
8cdb			;     HL is the numerator 
8cdb			;     C is the denominator 
8cdb			;Outputs: 
8cdb			;     A is the remainder 
8cdb			;     B is 0 
8cdb			;     C is not changed 
8cdb			;     DE is not changed 
8cdb			;     HL is the quotient 
8cdb			; 
8cdb			;       ld b,16 
8cdb			;       xor a 
8cdb			;         add hl,hl 
8cdb			;         rla 
8cdb			;         cp c 
8cdb			;         jr c,$+4 
8cdb			;           inc l 
8cdb			;           sub c 
8cdb			;         djnz $-7 
8cdb			 
8cdb			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdb			 
8cdb			addatohl: 
8cdb 85			    add   a, l    ; A = A+L 
8cdc 6f			    ld    l, a    ; L = A+L 
8cdd 8c			    adc   a, h    ; A = A+L+H+carry 
8cde 95			    sub   l       ; A = H+carry 
8cdf 67			    ld    h, a    ; H = H+carry 
8ce0 c9			ret 
8ce1			 
8ce1			addatode: 
8ce1 83			    add   a, e    ; A = A+L 
8ce2 5f			    ld    e, a    ; L = A+L 
8ce3 8a			    adc   a, d    ; A = A+L+H+carry 
8ce4 93			    sub   e       ; A = H+carry 
8ce5 57			    ld    d, a    ; H = H+carry 
8ce6 c9			ret 
8ce7			 
8ce7			 
8ce7			addatobc: 
8ce7 81			    add   a, c    ; A = A+L 
8ce8 4f			    ld    c, a    ; L = A+L 
8ce9 88			    adc   a, b    ; A = A+L+H+carry 
8cea 91			    sub   c       ; A = H+carry 
8ceb 47			    ld    b, a    ; H = H+carry 
8cec c9			ret 
8ced			 
8ced			subafromhl: 
8ced			   ; If A=0 do nothing 
8ced			    ; Otherwise flip A's sign. Since 
8ced			    ; the upper byte becomes -1, also 
8ced			    ; substract 1 from H. 
8ced ed 44		    neg 
8cef ca f8 8c		    jp    z, Skip 
8cf2 25			    dec   h 
8cf3			     
8cf3			    ; Now add the low byte as usual 
8cf3			    ; Two's complement takes care of 
8cf3			    ; ensuring the result is correct 
8cf3 85			    add   a, l 
8cf4 6f			    ld    l, a 
8cf5 8c			    adc   a, h 
8cf6 95			    sub   l 
8cf7 67			    ld    h, a 
8cf8			Skip: 
8cf8 c9				ret 
8cf9			 
8cf9			 
8cf9			; compare hl and de 
8cf9			; returns:  
8cf9			; if hl = de, z=1, s=0, c0=0 
8cf9			; if hl > de, z=0, s=0, c=0 
8cf9			; if hl < de, z=0, s=1, c=1 
8cf9			cmp16:	 
8cf9 b7				or a 
8cfa ed 52			sbc hl,de 
8cfc e0				ret po 
8cfd 7c				ld a,h 
8cfe 1f				rra 
8cff ee 40			xor 01000000B 
8d01 37				scf 
8d02 8f				adc a,a 
8d03 c9				ret 
8d04			 
8d04			 
8d04			; test if hl contains zero   - A is destroyed 
8d04			 
8d04			ishlzero:    
8d04 b7				or a     ; reset flags 
8d05 7c				ld a, h 
8d06 b5				or l        	 
8d07			 
8d07 c9				ret 
8d08			 
8d08			 
8d08			 
8d08			 
8d08			if FORTH_ENABLE_FLOATMATH 
8d08			;include "float/bbcmath.z80" 
8d08			include "float/lpfpcalc.asm" 
8d08			endif 
8d08			 
8d08			 
8d08			; eof 
8d08			 
# End of file firmware_maths.asm
8d08			include "firmware_strings.asm"   ; string handling  
8d08			 
8d08			 
8d08			; TODO string len 
8d08			; input text string, end on cr with zero term 
8d08			; a offset into frame buffer to start prompt 
8d08			; d is max length 
8d08			; e is display size TODO 
8d08			; c is current cursor position 
8d08			; hl is ptr to where string will be stored 
8d08			 
8d08			 
8d08			; TODO check limit of buffer for new inserts 
8d08			; TODO check insert does not push beyond buffer 
8d08			; TODO scroll in a limited display area 
8d08			; TODO scroll whole screen on page wrap 
8d08			 
8d08			 
8d08			; TODO handle KEY_PREVWORD 
8d08			; TODO handle KEY_NEXTWORD 
8d08			; TODO handle KEY_HOME 
8d08			; TODO handle KEY_END 
8d08			; TODO use LCD cursor? 
8d08			 
8d08 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8d0b 81					add c 
8d0c 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8d0f 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d12 79					ld a, c 
8d13 cd db 8c				call addatohl 
8d16 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8d19 7a					ld a,d 
8d1a 32 66 ee			        ld (input_size), a       ; save length of input area 
8d1d 79					ld a, c 
8d1e 32 55 ee				ld (input_cursor),a      ; init cursor start position  
8d21 7b					ld a,e 
8d22 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d25					 
8d25					 
8d25			 
8d25			;		ld a,(input_ptr) 
8d25			;		ld (input_under_cursor),a 	; save what is under the cursor 
8d25			 
8d25			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d25					; init cursor shape if not set by the cin routines 
8d25 21 c1 eb				ld hl, cursor_shape 
8d28 3e ff				ld a, 255 
8d2a 77					ld (hl), a 
8d2b 23					inc hl 
8d2c 3e 00				ld a, 0 
8d2e 77					ld (hl), a 
8d2f			 
8d2f 3e 0f				ld a, CUR_BLINK_RATE 
8d31 32 60 ee				ld (input_cur_flash), a 
8d34 3e 01				ld a, 1 
8d36 32 5f ee				ld (input_cur_onoff),a 
8d39			 
8d39			;	if DEBUG_INPUT 
8d39			;		push af 
8d39			;		ld a, 'I' 
8d39			;		ld (debug_mark),a 
8d39			;		pop af 
8d39			;		CALLMONITOR 
8d39			;	endif 
8d39			.is1:		; main entry loop 
8d39			 
8d39			 
8d39			 
8d39					; pause 1ms 
8d39			 
8d39 3e 01				ld a, 1 
8d3b cd d6 89				call aDelayInMS 
8d3e			 
8d3e					; dec flash counter 
8d3e 3a 60 ee				ld a, (input_cur_flash) 
8d41 3d					dec a 
8d42 32 60 ee				ld (input_cur_flash), a 
8d45 fe 00				cp 0 
8d47 20 0d				jr nz, .nochgstate 
8d49			 
8d49			 
8d49					; change state 
8d49 3a 5f ee				ld a,(input_cur_onoff) 
8d4c ed 44				neg 
8d4e 32 5f ee				ld (input_cur_onoff),a 
8d51			 
8d51			 
8d51					; reset on change of state 
8d51 3e 0f				ld a, CUR_BLINK_RATE 
8d53 32 60 ee				ld (input_cur_flash), a 
8d56			 
8d56			.nochgstate: 
8d56					 
8d56					 
8d56			 
8d56					; display cursor  
8d56			 
8d56			;		ld hl, (input_start) 
8d56			;		ld a, (input_cursor) 
8d56			;		call addatohl 
8d56			 
8d56					; get char under cursor and replace with cursor 
8d56 2a 69 ee		ld hl, (input_ptr) 
8d59			;		ld a, (hl) 
8d59			;		ld (input_under_cursor),a 
8d59			;		ld a, '_' 
8d59			;		ld (hl), a 
8d59			 
8d59					; display string 
8d59			 
8d59 ed 5b 67 ee			ld de, (input_start) 
8d5d 3a 64 ee				ld a, (input_at_pos) 
8d60 cd c1 8a				call str_at_display 
8d63			;	        call update_display 
8d63			 
8d63					; find place to put the cursor 
8d63			;		add h 
8d63			;		ld l, display_row_1 
8d63			;		sub l 
8d63			; (input_at_pos) 
8d63					;ld c, a 
8d63			;		ld a, (input_cursor) 
8d63			;		ld l, (input_at_pos) 
8d63			;		;ld b, h 
8d63			;		add l 
8d63			;		ld (input_at_cursor),a 
8d63					;ld l,h 
8d63			 
8d63			;		ld h, 0 
8d63			;		ld l,(input_at_pos) 
8d63			;		ld a, (input_cursor) 
8d63			;		call addatohl 
8d63			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d63			;		call subafromhl 
8d63			;		ld a,l 
8d63			;		ld (input_at_cursor), a 
8d63			 
8d63				if DEBUG_INPUT 
8d63					ld a, (hardware_diag) 
8d63					cp 0 
8d63					jr z, .skip_input_diag 
8d63			 
8d63					ld a,(input_at_pos) 
8d63					ld hl, LFSRSeed 
8d63					call hexout 
8d63					ld a, (input_cursor) 
8d63					ld hl, LFSRSeed+2 
8d63					call hexout 
8d63					ld a,(input_at_cursor) 
8d63					ld hl, LFSRSeed+4 
8d63					call hexout 
8d63			 
8d63					ld a,(input_cur_onoff) 
8d63					ld hl, LFSRSeed+6 
8d63					call hexout 
8d63			 
8d63					ld a,(input_cur_flash) 
8d63					ld hl, LFSRSeed+8 
8d63					call hexout 
8d63			 
8d63					ld a,(input_len) 
8d63					ld hl, LFSRSeed+10 
8d63					call hexout 
8d63					ld hl, LFSRSeed+12 
8d63					ld a, 0 
8d63					ld (hl),a 
8d63					ld a, display_row_4 
8d63					ld de, LFSRSeed 
8d63					call str_at_display 
8d63					.skip_input_diag: 
8d63				endif 
8d63			 
8d63					; decide on if we are showing the cursor this time round 
8d63			 
8d63 3a 5f ee				ld a, (input_cur_onoff) 
8d66 fe ff				cp 255 
8d68 28 13				jr z, .skipcur 
8d6a			 
8d6a			 
8d6a 3a 62 ee				ld a,(input_at_cursor) 
8d6d 11 c1 eb				ld de, cursor_shape 
8d70 cd c1 8a				call str_at_display 
8d73			 
8d73					; save length of current input string 
8d73 2a 67 ee				ld hl, (input_start) 
8d76 cd 39 91				call strlenz 
8d79 7d					ld a,l 
8d7a 32 5a ee				ld (input_len),a 
8d7d			 
8d7d			.skipcur: 
8d7d			 
8d7d cd d1 8a			        call update_display 
8d80					 
8d80			 
8d80			 
8d80					; wait 
8d80				 
8d80					; TODO loop without wait to flash the cursor and char under cursor	 
8d80 cd 62 e4				call cin    ; _wait 
8d83			 
8d83 fe 00				cp 0 
8d85 ca 39 8d				jp z, .is1 
8d88			 
8d88					; get ptr to char to input into 
8d88			 
8d88 4f					ld c,a 
8d89 2a 67 ee				ld hl, (input_start) 
8d8c 3a 55 ee				ld a, (input_cursor) 
8d8f cd db 8c				call addatohl 
8d92 22 69 ee				ld (input_ptr), hl 
8d95 79					ld a,c 
8d96			 
8d96					; replace char under cursor 
8d96			 
8d96			;		ld hl, (input_ptr) 
8d96			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d96			;		ld (hl), a 
8d96			 
8d96			;	if DEBUG_INPUT 
8d96			;		push af 
8d96			;		ld a, 'i' 
8d96			;		ld (debug_mark),a 
8d96			;		pop af 
8d96			;		CALLMONITOR 
8d96			;	endif 
8d96 fe 0e				cp KEY_HOME 
8d98 20 0e				jr nz, .iske 
8d9a			 
8d9a 3a 64 ee				ld a, (input_at_pos) 
8d9d 32 62 ee				ld (input_at_cursor),a 
8da0 3e 00				ld a, 0 
8da2 32 55 ee				ld (input_cursor), a 
8da5 c3 39 8d				jp .is1 
8da8					 
8da8 fe 0f		.iske:		cp KEY_END 
8daa 20 03				jr nz, .isknw 
8dac c3 39 8d				jp .is1 
8daf			 
8daf fe 06		.isknw:		cp KEY_NEXTWORD 
8db1 20 1b				jr nz, .iskpw 
8db3			 
8db3 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
8db6 7e					ld a,(hl)	 
8db7 fe 00				cp 0 
8db9 ca 39 8d				jp z, .is1    ; end of string 
8dbc fe 20				cp ' ' 
8dbe ca 39 8d				jp z, .is1    ; end of word 
8dc1 23					inc hl 
8dc2 22 69 ee				ld (input_ptr), hl 
8dc5 3a 62 ee				ld a, (input_at_cursor) 
8dc8 3c					inc a 
8dc9 32 62 ee				ld (input_at_cursor), a 
8dcc 18 e5				jr .isknwm 
8dce			 
8dce fe 07		.iskpw:		cp KEY_PREVWORD 
8dd0 20 1b				jr nz, .iskl 
8dd2			.iskpwm:	 
8dd2 2a 69 ee				ld hl, (input_ptr) 
8dd5 7e					ld a,(hl)	 
8dd6 fe 00				cp 0  
8dd8 ca 39 8d				jp z, .is1    ; end of string 
8ddb fe 20				cp ' ' 
8ddd ca 39 8d				jp z, .is1    ; end of word 
8de0 2b					dec hl 
8de1 22 69 ee				ld (input_ptr), hl 
8de4 3a 62 ee				ld a, (input_at_cursor) 
8de7 3d					dec a 
8de8 32 62 ee				ld (input_at_cursor), a 
8deb 18 e5				jr .iskpwm 
8ded			 
8ded			 
8ded fe 0b		.iskl:		cp KEY_LEFT 
8def 20 27				jr nz, .isk1 
8df1			 
8df1 3a 55 ee				ld a, (input_cursor) 
8df4			 
8df4 fe 00				cp 0 
8df6 ca 39 8d				jp z, .is1 		; at start of line to ignore  
8df9			 
8df9 3d					dec  a 		; TODO check underflow 
8dfa 32 55 ee				ld (input_cursor), a 
8dfd			 
8dfd 2a 69 ee				ld hl, (input_ptr) 
8e00 2b					dec hl 
8e01 22 69 ee				ld (input_ptr), hl 
8e04					 
8e04 3a 62 ee				ld a, (input_at_cursor) 
8e07 3d					dec a 
8e08 32 62 ee				ld (input_at_cursor), a 
8e0b			 
8e0b 3e 01				ld a, 1		; show cursor moving 
8e0d 32 5f ee				ld (input_cur_onoff),a 
8e10 3e 0f				ld a, CUR_BLINK_RATE 
8e12 32 60 ee				ld (input_cur_flash), a 
8e15			 
8e15 c3 39 8d				jp .is1 
8e18			 
8e18 fe 0c		.isk1:		cp KEY_RIGHT 
8e1a 20 2a				jr nz, .isk2 
8e1c			 
8e1c 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8e1f 5f					ld e,a 
8e20 3a 55 ee				ld a, (input_cursor) 
8e23 bb					cp e 
8e24 ca 39 8d				jp z, .is1		; at the end of string so dont go right 
8e27			 
8e27 3c					inc  a 		; TODO check overflow 
8e28 32 55 ee				ld (input_cursor), a 
8e2b			 
8e2b 3a 62 ee				ld a, (input_at_cursor) 
8e2e 3c					inc a 
8e2f 32 62 ee				ld (input_at_cursor), a 
8e32			 
8e32 2a 69 ee				ld hl, (input_ptr) 
8e35 23					inc hl 
8e36 22 69 ee				ld (input_ptr), hl 
8e39			 
8e39 3e 01				ld a, 1		; show cursor moving 
8e3b 32 5f ee				ld (input_cur_onoff),a 
8e3e 3e 0f				ld a, CUR_BLINK_RATE 
8e40 32 60 ee				ld (input_cur_flash), a 
8e43			 
8e43 c3 39 8d				jp .is1 
8e46			 
8e46 fe 05		.isk2:		cp KEY_UP 
8e48			 
8e48 20 26				jr nz, .isk3 
8e4a			 
8e4a					; swap last command with the current on 
8e4a			 
8e4a					; move cursor to start of string 
8e4a 2a 67 ee				ld hl, (input_start) 
8e4d 22 69 ee				ld (input_ptr), hl 
8e50			 
8e50 3a 64 ee				ld a, (input_at_pos) 
8e53 32 62 ee				ld (input_at_cursor), a 
8e56			 
8e56 3e 00				ld a, 0 
8e58 32 55 ee				ld (input_cursor), a 
8e5b					 
8e5b					; swap input and last command buffers 
8e5b			 
8e5b 21 e8 e5				ld hl, os_cli_cmd 
8e5e 11 e7 e6				ld de, os_last_cmd 
8e61 06 ff				ld b, 255 
8e63 7e			.swap1:		ld a, (hl) 
8e64 4f					ld c,a 
8e65 1a					ld a, (de) 
8e66 77					ld (hl), a 
8e67 79					ld a,c 
8e68 12					ld (de),a 
8e69 23					inc hl 
8e6a 13					inc de 
8e6b 10 f6				djnz .swap1 
8e6d			 
8e6d			 
8e6d			 
8e6d			 
8e6d			 
8e6d c3 39 8d				jp .is1 
8e70			 
8e70 fe 08		.isk3:		cp KEY_BS 
8e72 20 3c				jr nz, .isk4 
8e74			 
8e74 3a 55 ee				ld a, (input_cursor) 
8e77			 
8e77 fe 00				cp 0 
8e79 ca 39 8d				jp z, .is1 		; at start of line to ignore  
8e7c			 
8e7c 3d					dec  a 		; TODO check underflow 
8e7d 32 55 ee				ld (input_cursor), a 
8e80			 
8e80					; hl is source 
8e80					; de needs to be source - 1 
8e80			 
8e80			;		ld a, 0 
8e80			;		dec hl 
8e80			;		ld (hl), a 
8e80			 
8e80 2a 69 ee				ld hl, (input_ptr) 
8e83 2b					dec hl 
8e84 22 69 ee				ld (input_ptr), hl 
8e87			 
8e87					; shift all data 
8e87			 
8e87 e5					push hl 
8e88 23					inc hl 
8e89 d1					pop de 
8e8a 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e8d 4f					ld c,a 
8e8e 06 00				ld b,0 
8e90 ed b0				ldir  
8e92			 
8e92			 
8e92			 
8e92			 
8e92 3a 62 ee				ld a, (input_at_cursor) 
8e95 3d					dec a 
8e96 32 62 ee				ld (input_at_cursor), a 
8e99			 
8e99			 
8e99 3e 01				ld a, 1		; show cursor moving 
8e9b 32 5f ee				ld (input_cur_onoff),a 
8e9e 3e 0f				ld a, CUR_BLINK_RATE 
8ea0 32 60 ee				ld (input_cur_flash), a 
8ea3			 
8ea3					; remove char 
8ea3 3a 62 ee				ld a, (input_at_cursor) 
8ea6 3c					inc a 
8ea7 11 31 8f				ld de,.iblank 
8eaa cd c1 8a				call str_at_display 
8ead			 
8ead c3 39 8d				jp .is1 
8eb0			 
8eb0 fe 0d		.isk4:		cp KEY_CR 
8eb2 28 6c				jr z, .endinput 
8eb4			 
8eb4					; else add the key press to the end 
8eb4			 
8eb4 4f					ld c, a			; save key pressed 
8eb5			 
8eb5 7e					ld a,(hl)		; get what is currently under char 
8eb6			 
8eb6 fe 00				cp 0			; we are at the end of the string 
8eb8 20 2f				jr nz, .onchar 
8eba					 
8eba					; add a char to the end of the string 
8eba				 
8eba 71					ld (hl),c 
8ebb 23					inc hl 
8ebc			;		ld a,' ' 
8ebc			;		ld (hl),a 
8ebc			;		inc hl 
8ebc 3e 00				ld a,0 
8ebe 77					ld (hl),a 
8ebf 2b					dec hl 
8ec0			 
8ec0 3a 55 ee				ld a, (input_cursor) 
8ec3 3c					inc a				; TODO check max string length and scroll  
8ec4 32 55 ee				ld (input_cursor), a		; inc cursor pos 
8ec7							 
8ec7 3a 62 ee				ld a, (input_at_cursor) 
8eca 3c					inc a 
8ecb 32 62 ee				ld (input_at_cursor), a 
8ece			 
8ece 2a 69 ee				ld hl, (input_ptr) 
8ed1 23					inc hl 
8ed2 22 69 ee				ld (input_ptr), hl 
8ed5			 
8ed5 2a 69 ee				ld hl, (input_ptr) 
8ed8 23					inc hl 
8ed9 22 69 ee				ld (input_ptr), hl 
8edc			;	if DEBUG_INPUT 
8edc			;		push af 
8edc			;		ld a, '+' 
8edc			;		ld (debug_mark),a 
8edc			;		pop af 
8edc			;		CALLMONITOR 
8edc			;	endif 
8edc 3e 01				ld a, 1		; show cursor moving 
8ede 32 5f ee				ld (input_cur_onoff),a 
8ee1 3e 0f				ld a, CUR_BLINK_RATE 
8ee3 32 60 ee				ld (input_cur_flash), a 
8ee6 c3 39 8d				jp .is1 
8ee9					 
8ee9			 
8ee9			 
8ee9					; if on a char then insert 
8ee9			.onchar: 
8ee9			 
8ee9					; TODO over flow check: make sure insert does not blow out buffer 
8ee9			 
8ee9					; need to do some maths to use lddr 
8ee9			 
8ee9 e5					push hl   ; save char pos 
8eea c5					push bc 
8eeb			 
8eeb 2a 67 ee				ld hl, (input_start) 
8eee 3a 5a ee				ld a, (input_len) 
8ef1 cd db 8c				call addatohl  		; end of string 
8ef4 23					inc hl 
8ef5 23					inc hl		; past zero term 
8ef6 e5					push hl 
8ef7 23					inc hl 
8ef8 e5					push hl  
8ef9			 
8ef9								; start and end of lddr set, now how much to move? 
8ef9			 
8ef9							 
8ef9 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8efc 47					ld b,a 
8efd 3a 5a ee				ld a,(input_len) 
8f00 5f					ld e,a 
8f01 90					sub b 
8f02 3c					inc a		;?? 
8f03 3c					inc a		;?? 
8f04 3c					inc a		;?? 
8f05			 
8f05 06 00				ld b,0 
8f07 4f					ld c,a 
8f08			 
8f08				if DEBUG_INPUT 
8f08					push af 
8f08					ld a, 'i' 
8f08					ld (debug_mark),a 
8f08					pop af 
8f08			;		CALLMONITOR 
8f08				endif 
8f08 d1					pop de 
8f09 e1					pop hl 
8f0a				if DEBUG_INPUT 
8f0a					push af 
8f0a					ld a, 'I' 
8f0a					ld (debug_mark),a 
8f0a					pop af 
8f0a			;		CALLMONITOR 
8f0a				endif 
8f0a ed b8				lddr 
8f0c				 
8f0c			 
8f0c			 
8f0c					; TODO have a key for insert/overwrite mode???? 
8f0c c1					pop bc 
8f0d e1					pop hl 
8f0e 71					ld (hl), c		; otherwise overwrite current char 
8f0f					 
8f0f			 
8f0f			 
8f0f			 
8f0f 3a 55 ee				ld a, (input_cursor) 
8f12 3c					inc  a 		; TODO check overflow 
8f13 32 55 ee				ld (input_cursor), a 
8f16			 
8f16 3a 62 ee				ld a, (input_at_cursor) 
8f19 3c					inc a 
8f1a 32 62 ee				ld (input_at_cursor), a 
8f1d			 
8f1d c3 39 8d				jp .is1 
8f20			 
8f20			.endinput:	; TODO look for end of string 
8f20			 
8f20					; add trailing space for end of token 
8f20			 
8f20 2a 67 ee				ld hl, (input_start) 
8f23 3a 5a ee				ld a,(input_len) 
8f26 cd db 8c				call addatohl 
8f29 3e 20				ld a, ' ' 
8f2b 77					ld (hl),a 
8f2c					; TODO eof of parse marker 
8f2c			 
8f2c 23					inc hl 
8f2d 3e 00				ld a, 0 
8f2f 77					ld (hl),a 
8f30			 
8f30			 
8f30 c9					ret 
8f31			 
8f31 .. 00		.iblank: db " ",0 
8f33			 
8f33			 
8f33 32 64 ee		input_str_prev:	ld (input_at_pos), a 
8f36 22 67 ee				ld (input_start), hl 
8f39 3e 01				ld a,1			; add cursor 
8f3b 77					ld (hl),a 
8f3c 23					inc hl 
8f3d 3e 00				ld a,0 
8f3f 77					ld (hl),a 
8f40 22 69 ee				ld (input_ptr), hl 
8f43 7a					ld a,d 
8f44 32 66 ee				ld (input_size), a 
8f47 3e 00				ld a,0 
8f49 32 55 ee				ld (input_cursor),a 
8f4c			.instr1:	 
8f4c			 
8f4c					; TODO do block cursor 
8f4c					; TODO switch cursor depending on the modifer key 
8f4c			 
8f4c					; update cursor shape change on key hold 
8f4c			 
8f4c 2a 69 ee				ld hl, (input_ptr) 
8f4f 2b					dec hl 
8f50 3a c1 eb				ld a,(cursor_shape) 
8f53 77					ld (hl), a 
8f54			 
8f54					; display entered text 
8f54 3a 64 ee				ld a,(input_at_pos) 
8f57 cd c0 e3		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f5a ed 5b 67 ee	            	LD   de, (input_start) 
8f5e cd ba e3		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f61			 
8f61 cd 62 e4				call cin 
8f64 fe 00				cp 0 
8f66 28 e4				jr z, .instr1 
8f68			 
8f68					; proecess keyboard controls first 
8f68			 
8f68 2a 69 ee				ld hl,(input_ptr) 
8f6b			 
8f6b fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f6d 28 5a				jr z, .instrcr 
8f6f			 
8f6f fe 08				cp KEY_BS 	; back space 
8f71 20 0f				jr nz, .instr2 
8f73					; process back space 
8f73			 
8f73					; TODO stop back space if at start of string 
8f73 2b					dec hl 
8f74 2b					dec hl ; to over write cursor 
8f75 3a c1 eb				ld a,(cursor_shape) 
8f78					;ld a,0 
8f78 77					ld (hl),a 
8f79 23					inc hl 
8f7a 3e 20				ld a," " 
8f7c 77					ld (hl),a 
8f7d 22 69 ee				ld (input_ptr),hl 
8f80					 
8f80			 
8f80 18 ca				jr .instr1 
8f82			 
8f82 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f84 20 06				jr nz, .instr3 
8f86 2b					dec hl 
8f87 22 69 ee				ld (input_ptr),hl 
8f8a 18 c0				jr .instr1 
8f8c				 
8f8c fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f8e 20 06				jr nz, .instr4 
8f90 23					inc hl 
8f91 22 69 ee				ld (input_ptr),hl 
8f94 18 b6				jr .instr1 
8f96			 
8f96 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f98 20 06				jr nz, .instr5 
8f9a 2b					dec hl 
8f9b 22 69 ee				ld (input_ptr),hl 
8f9e 18 ac				jr .instr1 
8fa0			 
8fa0 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8fa2 20 06				jr nz, .instr6 
8fa4 2b					dec hl 
8fa5 22 69 ee				ld (input_ptr),hl 
8fa8 18 a2				jr .instr1 
8faa fe 05		.instr6:        cp KEY_UP      ; recall last command 
8fac 20 0b				jr nz, .instrnew 
8fae			 
8fae 21 c1 e2			ld hl, scratch 
8fb1 11 e7 e6			ld de, os_last_cmd 
8fb4 cd d2 8f			call strcpy 
8fb7 18 93				jr .instr1 
8fb9			 
8fb9			 
8fb9			.instrnew:	; no special key pressed to see if we have room to store it 
8fb9			 
8fb9					; TODO do string size test 
8fb9			 
8fb9 2b					dec hl ; to over write cursor 
8fba 77					ld (hl),a 
8fbb 23					inc hl 
8fbc 3a c1 eb				ld a,(cursor_shape) 
8fbf 77					ld (hl),a 
8fc0 23					inc hl 
8fc1 3e 00				ld a,0 
8fc3 77					ld (hl),a 
8fc4			 
8fc4 22 69 ee				ld (input_ptr),hl 
8fc7					 
8fc7 18 83				jr .instr1 
8fc9 2b			.instrcr:	dec hl		; remove cursor 
8fca 3e 20				ld a,' '	; TODO add a trailing space for safety 
8fcc 77					ld (hl),a 
8fcd 23					inc hl 
8fce 3e 00				ld a,0 
8fd0 77					ld (hl),a 
8fd1			 
8fd1			 
8fd1					; if at end of line scroll up    
8fd1					; TODO detecting only end of line 4 for scroll up  
8fd1			 
8fd1					;ld   
8fd1			 
8fd1 c9					ret 
8fd2			 
8fd2			 
8fd2			; strcpy hl = dest, de source 
8fd2			 
8fd2 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8fd3 b7			            OR   A              ;Null terminator? 
8fd4 c8			            RET  Z              ;Yes, so finished 
8fd5 1a					ld a,(de) 
8fd6 77					ld (hl),a 
8fd7 13			            INC  DE             ;Point to next character 
8fd8 23					inc hl 
8fd9 18 f7		            JR   strcpy       ;Repeat 
8fdb c9					ret 
8fdc			 
8fdc			 
8fdc			; TODO string_at  
8fdc			; pass string which starts with lcd offset address and then null term string 
8fdc			 
8fdc			; TODO string to dec 
8fdc			; TODO string to hex 
8fdc			; TODO byte to string hex 
8fdc			; TODO byte to string dec 
8fdc			 
8fdc			 
8fdc			 
8fdc			; from z80uartmonitor 
8fdc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdc			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fdc			; pass hl for where to put the text 
8fdc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdc c5			hexout:	PUSH BC 
8fdd f5					PUSH AF 
8fde 47					LD B, A 
8fdf					; Upper nybble 
8fdf cb 3f				SRL A 
8fe1 cb 3f				SRL A 
8fe3 cb 3f				SRL A 
8fe5 cb 3f				SRL A 
8fe7 cd f7 8f				CALL tohex 
8fea 77					ld (hl),a 
8feb 23					inc hl	 
8fec					 
8fec					; Lower nybble 
8fec 78					LD A, B 
8fed e6 0f				AND 0FH 
8fef cd f7 8f				CALL tohex 
8ff2 77					ld (hl),a 
8ff3 23					inc hl	 
8ff4					 
8ff4 f1					POP AF 
8ff5 c1					POP BC 
8ff6 c9					RET 
8ff7					 
8ff7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff7			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8ff7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff7			tohex: 
8ff7 e5					PUSH HL 
8ff8 d5					PUSH DE 
8ff9 16 00				LD D, 0 
8ffb 5f					LD E, A 
8ffc 21 04 90				LD HL, .DATA 
8fff 19					ADD HL, DE 
9000 7e					LD A, (HL) 
9001 d1					POP DE 
9002 e1					POP HL 
9003 c9					RET 
9004			 
9004			.DATA: 
9004 30					DEFB	30h	; 0 
9005 31					DEFB	31h	; 1 
9006 32					DEFB	32h	; 2 
9007 33					DEFB	33h	; 3 
9008 34					DEFB	34h	; 4 
9009 35					DEFB	35h	; 5 
900a 36					DEFB	36h	; 6 
900b 37					DEFB	37h	; 7 
900c 38					DEFB	38h	; 8 
900d 39					DEFB	39h	; 9 
900e 41					DEFB	41h	; A 
900f 42					DEFB	42h	; B 
9010 43					DEFB	43h	; C 
9011 44					DEFB	44h	; D 
9012 45					DEFB	45h	; E 
9013 46					DEFB	46h	; F 
9014			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9014			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
9014			;;    subtract $30, if result > 9 then subtract $7 more 
9014			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9014			atohex: 
9014 d6 30				SUB $30 
9016 fe 0a				CP 10 
9018 f8					RET M		; If result negative it was 0-9 so we're done 
9019 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
901b c9					RET		 
901c			 
901c			 
901c			 
901c			 
901c			; Get 2 ASCII characters as hex byte from pointer in hl 
901c			 
901c			BYTERD: 
901c 16 00			LD	D,00h		;Set up 
901e cd 26 90			CALL	HEXCON		;Get byte and convert to hex 
9021 87				ADD	A,A		;First nibble so 
9022 87				ADD	A,A		;multiply by 16 
9023 87				ADD	A,A		; 
9024 87				ADD	A,A		; 
9025 57				LD	D,A		;Save hi nibble in D 
9026			HEXCON: 
9026 7e				ld a, (hl)		;Get next chr 
9027 23				inc hl 
9028 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
902a fe 0a			CP	00Ah		;Is it 0-9 ? 
902c 38 02			JR	C,NALPHA	;If so miss next bit 
902e d6 07			SUB	007h		;Else convert alpha 
9030			NALPHA: 
9030 b2				OR	D		;Add hi nibble back 
9031 c9				RET			; 
9032			 
9032			 
9032			; 
9032			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
9032			; Since the routines get_byte and therefore get_nibble are called, only valid 
9032			; characters (0-9a-f) are accepted. 
9032			; 
9032			;get_word        push    af 
9032			;                call    get_byte        ; Get the upper byte 
9032			;                ld      h, a 
9032			;                call    get_byte        ; Get the lower byte 
9032			;                ld      l, a 
9032			;                pop     af 
9032			;                ret 
9032			; 
9032			; Get a byte in hexadecimal notation. The result is returned in A. Since 
9032			; the routine get_nibble is used only valid characters are accepted - the  
9032			; input routine only accepts characters 0-9a-f. 
9032			; 
9032 c5			get_byte:        push    bc              ; Save contents of B (and C) 
9033 7e					ld a,(hl) 
9034 23					inc hl 
9035 cd 5a 90		                call    nibble2val      ; Get upper nibble 
9038 cb 07		                rlc     a 
903a cb 07		                rlc     a 
903c cb 07		                rlc     a 
903e cb 07		                rlc     a 
9040 47			                ld      b, a            ; Save upper four bits 
9041 7e					ld a,(hl) 
9042 cd 5a 90		                call    nibble2val      ; Get lower nibble 
9045 b0			                or      b               ; Combine both nibbles 
9046 c1			                pop     bc              ; Restore B (and C) 
9047 c9			                ret 
9048			; 
9048			; Get a hexadecimal digit from the serial line. This routine blocks until 
9048			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9048			; to the serial line interface. The lower 4 bits of A contain the value of  
9048			; that particular digit. 
9048			; 
9048			;get_nibble      ld a,(hl)           ; Read a character 
9048			;                call    to_upper        ; Convert to upper case 
9048			;                call    is_hex          ; Was it a hex digit? 
9048			;                jr      nc, get_nibble  ; No, get another character 
9048			 ;               call    nibble2val      ; Convert nibble to value 
9048			 ;               call    print_nibble 
9048			 ;               ret 
9048			; 
9048			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9048			; A valid hexadecimal digit is denoted by a set C flag. 
9048			; 
9048			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9048			;                ret     nc              ; Yes 
9048			;                cp      '0'             ; Less than '0'? 
9048			;                jr      nc, is_hex_1    ; No, continue 
9048			;                ccf                     ; Complement carry (i.e. clear it) 
9048			;                ret 
9048			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9048			;                ret     c               ; Yes 
9048			;                cp      'A'             ; Less than 'A'? 
9048			;                jr      nc, is_hex_2    ; No, continue 
9048			;                ccf                     ; Yes - clear carry and return 
9048			;                ret 
9048			;is_hex_2        scf                     ; Set carry 
9048			;                ret 
9048			; 
9048			; Convert a single character contained in A to upper case: 
9048			; 
9048 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
904a d8			                ret     c 
904b fe 7b		                cp      'z' + 1         ; > 'z'? 
904d d0			                ret     nc              ; Nothing to do, either 
904e e6 5f		                and     $5f             ; Convert to upper case 
9050 c9			                ret 
9051			 
9051			 
9051			to_lower: 
9051			 
9051			   ; if char is in [A-Z] make it lower case 
9051			 
9051			   ; enter : a = char 
9051			   ; exit  : a = lower case char 
9051			   ; uses  : af 
9051			 
9051 fe 41		   cp 'A' 
9053 d8			   ret c 
9054			    
9054 fe 5b		   cp 'Z'+1 
9056 d0			   ret nc 
9057			    
9057 f6 20		   or $20 
9059 c9			   ret 
905a			 
905a			; 
905a			; Expects a hexadecimal digit (upper case!) in A and returns the 
905a			; corresponding value in A. 
905a			; 
905a fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
905c 38 02		                jr      c, nibble2val_1 ; Yes 
905e d6 07		                sub     7               ; Adjust for A-F 
9060 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9062 e6 0f		                and     $f              ; Only return lower 4 bits 
9064 c9			                ret 
9065			; 
9065			; Print_nibble prints a single hex nibble which is contained in the lower  
9065			; four bits of A: 
9065			; 
9065			;print_nibble    push    af              ; We won't destroy the contents of A 
9065			;                and     $f              ; Just in case... 
9065			;                add     a, '0'             ; If we have a digit we are done here. 
9065			;                cp      '9' + 1         ; Is the result > 9? 
9065			;                jr      c, print_nibble_1 
9065			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
9065			;print_nibble_1  call    putc            ; Print the nibble and 
9065			;                pop     af              ; restore the original value of A 
9065			;                ret 
9065			;; 
9065			;; Send a CR/LF pair: 
9065			; 
9065			;crlf            push    af 
9065			;                ld      a, cr 
9065			;                call    putc 
9065			;                ld      a, lf 
9065			;                call    putc 
9065			;                pop     af 
9065			;                ret 
9065			; 
9065			; Print_word prints the four hex digits of a word to the serial line. The  
9065			; word is expected to be in HL. 
9065			; 
9065			;print_word      push    hl 
9065			;                push    af 
9065			;                ld      a, h 
9065			;                call    print_byte 
9065			;                ld      a, l 
9065			;                call    print_byte 
9065			;                pop     af 
9065			;                pop     hl 
9065			;                ret 
9065			; 
9065			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
9065			; The byte to be printed is expected to be in A. 
9065			; 
9065			;print_byte      push    af              ; Save the contents of the registers 
9065			;                push    bc 
9065			;                ld      b, a 
9065			;                rrca 
9065			;                rrca 
9065			;                rrca 
9065			;                rrca 
9065			;                call    print_nibble    ; Print high nibble 
9065			;                ld      a, b 
9065			;                call    print_nibble    ; Print low nibble 
9065			;                pop     bc              ; Restore original register contents 
9065			;                pop     af 
9065			;                ret 
9065			 
9065			 
9065			 
9065			 
9065			 
9065			fourehexhl:  
9065 7e				ld a,(hl) 
9066 cd 14 90			call atohex 
9069 cb 3f				SRL A 
906b cb 3f				SRL A 
906d cb 3f				SRL A 
906f cb 3f				SRL A 
9071 47				ld b, a 
9072 23				inc hl 
9073 7e				ld a,(hl) 
9074 23				inc hl 
9075 cd 14 90			call atohex 
9078 80				add b 
9079 57				ld d,a 
907a 7e				ld a,(hl) 
907b cd 14 90			call atohex 
907e cb 3f				SRL A 
9080 cb 3f				SRL A 
9082 cb 3f				SRL A 
9084 cb 3f				SRL A 
9086 47				ld b, a 
9087 23				inc hl 
9088 7e				ld a,(hl) 
9089 23				inc hl 
908a cd 14 90			call atohex 
908d 80				add b 
908e 5f				ld e, a 
908f d5				push de 
9090 e1				pop hl 
9091 c9				ret 
9092			 
9092			; pass hl. returns z set if the byte at hl is a digit 
9092			;isdigithl:  
9092			;	push bc 
9092			;	ld a,(hl) 
9092			;	cp ':' 
9092			;	jr nc, .isdf 		; > 
9092			;	cp '0' 
9092			;	jr c, .isdf		; < 
9092			; 
9092			;	; TODO find a better way to set z 
9092			; 
9092			;	ld b,a 
9092			;	cp b 
9092			;	pop bc 
9092			;	ret 
9092			; 
9092			;.isdf:	; not digit so clear z 
9092			; 
9092			;	; TODO find a better way to unset z 
9092			; 
9092			;	ld b,a 
9092			;	inc b 
9092			;	cp b 
9092			; 
9092			;	pop bc 
9092			;	ret 
9092				 
9092				 
9092			 
9092			 
9092			; pass hl as the four byte address to load 
9092			 
9092			get_word_hl:  
9092 e5				push hl 
9093 cd 32 90			call get_byte 
9096				 
9096 47				ld b, a 
9097			 
9097 e1				pop hl 
9098 23				inc hl 
9099 23				inc hl 
909a			 
909a			; TODO not able to handle a-f  
909a 7e				ld a,(hl) 
909b			;	;cp ':' 
909b			;	cp 'g' 
909b			;	jr nc, .single_byte_hl 		; > 
909b			;	cp 'G' 
909b			;	jr nc, .single_byte_hl 		; > 
909b			;	cp '0' 
909b			;	jr c, .single_byte_hl		; < 
909b			 
909b				;call isdigithl 
909b fe 00			cp 0 
909d 28 06			jr z, .single_byte_hl 
909f			 
909f			.getwhln:   ; hex word so get next byte 
909f			 
909f cd 32 90			call get_byte 
90a2 6f				ld l, a 
90a3 60				ld h,b 
90a4 c9				ret 
90a5 68			.single_byte_hl:   ld l,b 
90a6 26 00				ld h,0 
90a8 c9					ret 
90a9			 
90a9			 
90a9			 
90a9			 
90a9 21 2a 98			ld hl,asc+1 
90ac			;	ld a, (hl) 
90ac			;	call nibble2val 
90ac cd 32 90			call get_byte 
90af			 
90af			;	call fourehexhl 
90af 32 f5 e2			ld (scratch+52),a 
90b2				 
90b2 21 f3 e2			ld hl,scratch+50 
90b5 22 e4 e5			ld (os_cur_ptr),hl 
90b8			 
90b8 c9				ret 
90b9			 
90b9			 
90b9			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
90b9			 
90b9			; Decimal Unsigned Version 
90b9			 
90b9			;Number in a to decimal ASCII 
90b9			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
90b9			;Example: display a=56 as "056" 
90b9			;input: a = number 
90b9			;Output: a=0,value of a in the screen 
90b9			;destroys af,bc (don't know about hl and de) 
90b9			DispAToASCII: 
90b9 0e 9c			ld	c,-100 
90bb cd c5 90			call	.Na1 
90be 0e f6			ld	c,-10 
90c0 cd c5 90			call	.Na1 
90c3 0e ff			ld	c,-1 
90c5 06 2f		.Na1:	ld	b,'0'-1 
90c7 04			.Na2:	inc	b 
90c8 81				add	a,c 
90c9 38 fc			jr	c,.Na2 
90cb 91				sub	c		;works as add 100/10/1 
90cc f5				push af		;safer than ld c,a 
90cd 78				ld	a,b		;char is in b 
90ce			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
90ce f1				pop af		;safer than ld a,c 
90cf c9				ret 
90d0			 
90d0			; Decimal Signed Version 
90d0			 
90d0			; DispA 
90d0			; -------------------------------------------------------------- 
90d0			; Converts a signed integer value to a zero-terminated ASCII 
90d0			; string representative of that value (using radix 10). 
90d0			; -------------------------------------------------------------- 
90d0			; INPUTS: 
90d0			;     HL     Value to convert (two's complement integer). 
90d0			;     DE     Base address of string destination. (pointer). 
90d0			; -------------------------------------------------------------- 
90d0			; OUTPUTS: 
90d0			;     None 
90d0			; -------------------------------------------------------------- 
90d0			; REGISTERS/MEMORY DESTROYED 
90d0			; AF HL 
90d0			; -------------------------------------------------------------- 
90d0			 
90d0			;DispHLToASCII: 
90d0			;   push    de 
90d0			;   push    bc 
90d0			; 
90d0			;; Detect sign of HL. 
90d0			;    bit    7, h 
90d0			;    jr     z, ._DoConvert 
90d0			; 
90d0			;; HL is negative. Output '-' to string and negate HL. 
90d0			;    ld     a, '-' 
90d0			;    ld     (de), a 
90d0			;    inc    de 
90d0			; 
90d0			;; Negate HL (using two's complement) 
90d0			;    xor    a 
90d0			;    sub    l 
90d0			;    ld     l, a 
90d0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
90d0			;    sbc    a, h 
90d0			;    ld     h, a 
90d0			; 
90d0			;; Convert HL to digit characters 
90d0			;._DoConvert: 
90d0			;    ld     b, 0     ; B will count character length of number 
90d0			;-   ld     a, 10 
90d0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
90d0			;    push   af 
90d0			;    inc    b 
90d0			;    ld     a, h 
90d0			;    or     l 
90d0			;    jr     nz, - 
90d0			; 
90d0			;; Retrieve digits from stack 
90d0			;-   pop    af 
90d0			;    or     $30 
90d0			;    ld     (de), a 
90d0			;    inc    de 
90d0			;    djnz   - 
90d0			; 
90d0			;; Terminate string with NULL 
90d0			;    xor    a 
90d0			;    ld     (de), a 
90d0			; 
90d0			;    pop    bc 
90d0			;    pop    de 
90d0			;    ret 
90d0			 
90d0			;Comments 
90d0			; 
90d0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
90d0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
90d0			;    Note that the output string will not be fixed-width. 
90d0			; 
90d0			;Example Usage 
90d0			; 
90d0			;    ld    hl, -1004 
90d0			;    ld    de, OP1 
90d0			;    call  DispA 
90d0			;    ld    hl, OP1 
90d0			;    syscall  PutS 
90d0			 
90d0			 
90d0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90d0			 
90d0			 
90d0			;Converts an ASCII string to an unsigned 16-bit integer 
90d0			;Quits when it reaches a non-decimal digit 
90d0			 
90d0			string_to_uint16: 
90d0			atoui_16: 
90d0			;Input: 
90d0			;     DE points to the string 
90d0			;Outputs: 
90d0			;     HL is the result 
90d0			;     A is the 8-bit value of the number 
90d0			;     DE points to the byte after the number 
90d0			;Destroys: 
90d0			;     BC 
90d0			;       if the string is non-empty, BC is HL/10 
90d0			;Size:  24 bytes 
90d0			;Speed: 42+d(104+{0,9}) 
90d0			;       d is the number of digits in the number 
90d0			;       max is 640 cycles for a 5 digit number 
90d0			;Assuming no leading zeros: 
90d0			;1 digit:  146cc 
90d0			;2 digit:  250cc 
90d0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
90d0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
90d0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
90d0			;avg: 544.81158447265625cc (544+13297/16384) 
90d0			;=============================================================== 
90d0 21 00 00		  ld hl,0 
90d3			.u16a: 
90d3 1a			  ld a,(de) 
90d4 d6 30		  sub 30h 
90d6 fe 0a		  cp 10 
90d8 d0			  ret nc 
90d9 13			  inc de 
90da 44			  ld b,h 
90db 4d			  ld c,l 
90dc 29			  add hl,hl 
90dd 29			  add hl,hl 
90de 09			  add hl,bc 
90df 29			  add hl,hl 
90e0 85			  add a,l 
90e1 6f			  ld l,a 
90e2 30 ef		  jr nc,.u16a 
90e4 24			  inc h 
90e5 c3 d3 90		  jp .u16a 
90e8			 
90e8			 
90e8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90e8			 
90e8			;written by Zeda 
90e8			;Converts a 16-bit unsigned integer to an ASCII string. 
90e8			 
90e8			uitoa_16: 
90e8			;Input: 
90e8			;   DE is the number to convert 
90e8			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90e8			;Output: 
90e8			;   HL points to the null-terminated ASCII string 
90e8			;      NOTE: This isn't necessarily the same as the input HL. 
90e8 d5			  push de 
90e9 c5			  push bc 
90ea f5			  push af 
90eb eb			  ex de,hl 
90ec			 
90ec 01 f0 d8		  ld bc,-10000 
90ef 3e 2f		  ld a,'0'-1 
90f1 3c			  inc a 
90f2 09			  add hl,bc  
90f3 38 fc		   jr c,$-2 
90f5 12			  ld (de),a 
90f6 13			  inc de 
90f7			 
90f7 01 e8 03		  ld bc,1000 
90fa 3e 3a		  ld a,'9'+1 
90fc 3d			  dec a  
90fd 09			  add hl,bc  
90fe 30 fc		   jr nc,$-2 
9100 12			  ld (de),a 
9101 13			  inc de 
9102			 
9102 01 9c ff		  ld bc,-100 
9105 3e 2f		  ld a,'0'-1 
9107 3c			  inc a  
9108 09			  add hl,bc  
9109 38 fc		   jr c,$-2 
910b 12			  ld (de),a 
910c 13			  inc de 
910d			 
910d 7d			  ld a,l 
910e 26 3a		  ld h,'9'+1 
9110 25			  dec h  
9111 c6 0a		  add a,10  
9113 30 fb		   jr nc,$-3 
9115 c6 30		  add a,'0' 
9117 eb			  ex de,hl 
9118 72			  ld (hl),d 
9119 23			  inc hl 
911a 77			  ld (hl),a 
911b 23			  inc hl 
911c 36 00		  ld (hl),0 
911e			 
911e			;Now strip the leading zeros 
911e 0e fa		  ld c,-6 
9120 09			  add hl,bc 
9121 3e 30		  ld a,'0' 
9123 23			  inc hl  
9124 be			  cp (hl)  
9125 28 fc		  jr z,$-2 
9127			 
9127			;Make sure that the string is non-empty! 
9127 7e			  ld a,(hl) 
9128 b7			  or a 
9129 20 01		  jr nz,.atoub 
912b 2b			  dec hl 
912c			.atoub: 
912c			 
912c f1			  pop af 
912d c1			  pop bc 
912e d1			  pop de 
912f c9			  ret 
9130			 
9130			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9130			 
9130			toUpper: 
9130			;A is the char. 
9130			;If A is a lowercase letter, this sets it to the matching uppercase 
9130			;18cc or 30cc or 41cc 
9130			;avg: 26.75cc 
9130 fe 61		  cp 'a' 
9132 d8			  ret c 
9133 fe 7b		  cp 'z'+1 
9135 d0			  ret nc 
9136 d6 20		  sub 'a'-'A' 
9138 c9			  ret 
9139			 
9139			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
9139			 
9139			; String Length 
9139			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
9139			 
9139			; Get the length of the null-terminated string starting at $8000 hl 
9139			;    LD     HL, $8000 
9139			 
9139			strlenz: 
9139			 
9139 af			    XOR    A               ; Zero is the value we are looking for. 
913a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
913b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
913c			                           ; 65, 536 bytes (the entire addressable memory space). 
913c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
913e			 
913e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
913e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
913f 6f			    LD     L, A             ; number of bytes 
9140 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9142 2b			    DEC    HL              ; Compensate for null. 
9143 c9				ret 
9144			 
9144			; Get the length of the A terminated string starting at $8000 hl 
9144			;    LD     HL, $8000 
9144			 
9144			strlent: 
9144			 
9144			                  ; A is the value we are looking for. 
9144 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9146 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9148			                           ; 65, 536 bytes (the entire addressable memory space). 
9148 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
914a			 
914a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
914a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
914c 2e 00		    LD     L, 0             ; number of bytes 
914e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9150 2b			    DEC    HL              ; Compensate for null. 
9151 c9				ret 
9152			 
9152			 
9152			;Comparing Strings 
9152			 
9152			;IN    HL     Address of string1. 
9152			;      DE     Address of string2. 
9152			 
9152			; doc given but wrong??? 
9152			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9152			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9152			; tested 
9152			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9152			 
9152			strcmp_old: 
9152 e5			    PUSH   HL 
9153 d5			    PUSH   DE 
9154			 
9154 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9155 be			    CP     (HL)            ; (want to minimize work). 
9156 38 01		    JR     C, Str1IsBigger 
9158 7e			    LD     A, (HL) 
9159			 
9159			Str1IsBigger: 
9159 4f			    LD     C, A             ; Put length in BC 
915a 06 00		    LD     B, 0 
915c 13			    INC    DE              ; Increment pointers to meat of string. 
915d 23			    INC    HL 
915e			 
915e			CmpLoop: 
915e 1a			    LD     A, (DE)          ; Compare bytes. 
915f ed a1		    CPI 
9161 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9163 13			    INC    DE              ; Update pointer. 
9164 ea 5e 91		    JP     PE, CmpLoop 
9167			 
9167 d1			    POP    DE 
9168 e1			    POP    HL 
9169 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
916a be			    CP     (HL) 
916b c9			    RET 
916c			 
916c			NoMatch: 
916c 2b			    DEC    HL 
916d be			    CP     (HL)            ; Compare again to affect carry. 
916e d1			    POP    DE 
916f e1			    POP    HL 
9170 c9			    RET 
9171			 
9171			;; test strmp 
9171			; 
9171			;ld de, .str1 
9171			;ld hl, .str2 
9171			;call strcmp 
9171			;jr z, .z1 
9171			;;this 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "NZ1" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			;.z1: 
9171			; 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "ZZ1" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			; 
9171			;ld de, .str1 
9171			;ld hl, .str1 
9171			;call strcmp 
9171			;jr z, .z2 
9171			;;this 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "NZ2" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			;.z2: 
9171			; 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "ZZ2" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			; 
9171			;ld de, .str1 
9171			;ld hl, .str2 
9171			;call strcmp 
9171			;jr c, .c1 
9171			; 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "Nc1" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			;.c1: 
9171			;;this 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "cc1" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			; 
9171			;ld de, .str1 
9171			;ld hl, .str1 
9171			;call strcmp 
9171			;jr c, .c2 
9171			;;this 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "Nc2" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			;.c2: 
9171			; 
9171			;	if DEBUG_FORTH_WORDS 
9171			;		DMARK "cc2" 
9171			;		CALLMONITOR 
9171			;	endif 
9171			;	NEXTW 
9171			;.str1:   db "string1",0 
9171			;.str2:   db "string2",0 
9171			 
9171			; only care about direct match or not 
9171			; hl and de strings 
9171			; zero set if the same 
9171			 
9171			strcmp: 
9171 1a				ld a, (de) 
9172 be				cp (hl) 
9173 28 02			jr z, .ssame 
9175 b7				or a 
9176 c9				ret 
9177			 
9177			.ssame:  
9177 fe 00			cp 0 
9179 c8				ret z 
917a			 
917a 23				inc hl 
917b 13				inc de 
917c 18 f3			jr strcmp 
917e				 
917e				 
917e			 
917e			 
917e			 
917e			 
917e			; eof 
917e			 
917e			 
917e			 
917e			 
917e			 
917e			 
# End of file firmware_strings.asm
917e			include "firmware_memory.asm"   ; malloc and free  
917e			 
917e			if DEBUG_FORTH_MALLOC_HIGH 
917e			.mallocsize: db "Wants malloc >256",0 
917e			.mallocasize: db "MALLOC gives >256",0 
917e			.malloczero: db "MALLOC gives zero",0 
917e			 
917e			malloc_guard_zerolen: 
917e				push hl 
917e				push de 
917e				push af 
917e			 
917e				ld de, 0 
917e			        call cmp16 
917e				jr nz, .lowalloz 
917e			 
917e				push hl 
917e				push de 
917e					ld hl, display_fb0 
917e					ld (display_fb_active), hl 
917e				call clear_display 
917e				ld a, 0 
917e				ld de, .malloczero 
917e				call str_at_display 
917e				call update_display 
917e				call delay1s 
917e				call delay1s 
917e				call bp_on 
917e			;	ld a, 0 
917e			;	ld (os_view_disable), a 
917e			 
917e				pop de 
917e				pop hl 
917e			 
917e				 
917e			 
917e				CALLMONITOR 
917e			.lowalloz: 
917e			 
917e			 
917e				pop af 
917e				pop de 
917e				pop hl 
917e			ret 
917e			 
917e			malloc_guard_entry: 
917e				push hl 
917e				push de 
917e				push af 
917e			 
917e			 	or a      ;clear carry flag 
917e				push hl 
917e				ld de, 255 
917e				sbc hl, de 
917e				jr c, .lowalloc 
917e			 
917e				push de 
917e					ld hl, display_fb0 
917e					ld (display_fb_active), hl 
917e				call clear_display 
917e				ld a, 0 
917e				ld de, .mallocsize 
917e				call str_at_display 
917e				call update_display 
917e				call delay1s 
917e				call delay1s 
917e			;	ld a, 0 
917e			;	ld (os_view_disable), a 
917e				call bp_on 
917e			 
917e				pop de 
917e				pop hl 
917e			 
917e				 
917e			 
917e				CALLMONITOR 
917e				jr .lowdone 
917e			.lowalloc: 
917e			 
917e			 
917e				pop hl 
917e			.lowdone:	pop af 
917e				pop de 
917e				pop hl 
917e			ret 
917e			 
917e			malloc_guard_exit: 
917e				push hl 
917e				push de 
917e				push af 
917e			 
917e			 	or a      ;clear carry flag 
917e				push hl 
917e				ld de, 255 
917e				sbc hl, de 
917e				jr c, .lowallocx 
917e			 
917e				push de 
917e					ld hl, display_fb0 
917e					ld (display_fb_active), hl 
917e				call clear_display 
917e				ld a, 0 
917e				ld de, .mallocasize 
917e				call str_at_display 
917e				call update_display 
917e				call delay1s 
917e				call delay1s 
917e			;	ld a, 0 
917e			;	ld (os_view_disable), a 
917e				call bp_on 
917e				pop de 
917e				pop hl 
917e			 
917e				CALLMONITOR 
917e				jr .lowdonex 
917e			.lowallocx: 
917e			 
917e				pop hl 
917e			.lowdonex:	pop af 
917e				pop de 
917e				pop hl 
917e			ret 
917e			endif 
917e			 
917e			if MALLOC_2 
917e			; Z80 Malloc and Free Functions 
917e			 
917e			; Malloc Function: 
917e			; Input: 
917e			;   HL: Size of block to allocate 
917e			; Output: 
917e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917e			 
917e			malloc: 
917e				 
917e			if DEBUG_FORTH_MALLOC_HIGH 
917e			call malloc_guard_entry 
917e			endif 
917e			 
917e			 
917e			 
917e			 
917e					if DEBUG_FORTH_MALLOC 
917e						DMARK "mal" 
917e						CALLMONITOR 
917e					endif 
917e			    push af            ; Save AF register 
917e			    ld a, l            ; Load low byte of size into A 
917e			    or h               ; Check if size is zero 
917e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
917e			 
917e			    ; Allocate memory 
917e			    ld hl, (heap_start) ; Load start of heap into HL 
917e					if DEBUG_FORTH_MALLOC 
917e						DMARK "ma1" 
917e						CALLMONITOR 
917e					endif 
917e			    call malloc_internal ; Call internal malloc function 
917e			    pop af             ; Restore AF register 
917e			if DEBUG_FORTH_MALLOC_HIGH 
917e			call malloc_guard_exit 
917e			call malloc_guard_zerolen 
917e			endif 
917e			    ret                ; Return 
917e			 
917e			; Free Function: 
917e			; Input: 
917e			;   HL: Pointer to memory block to free 
917e			; Output: 
917e			;   None 
917e			 
917e			free: 
917e			    push af            ; Save AF register 
917e			    ld a, l            ; Load low byte of pointer into A 
917e			    or h               ; Check if pointer is NULL 
917e			    jp z, free_exit    ; If pointer is NULL, exit 
917e			 
917e			    ; Free memory 
917e			    ld hl, (heap_start) ; Load start of heap into HL 
917e			    call free_internal  ; Call internal free function 
917e			    pop af             ; Restore AF register 
917e			    ret                ; Return 
917e			 
917e			; Internal Malloc Function: 
917e			; Input: 
917e			;   HL: Size of block to allocate 
917e			; Output: 
917e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917e			 
917e			malloc_internal: 
917e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
917e			    add hl, bc         ; Add management overhead to requested size 
917e			    ex de, hl          ; Save total size in DE, and keep it in HL 
917e					if DEBUG_FORTH_MALLOC 
917e						DMARK "ma2" 
917e						CALLMONITOR 
917e					endif 
917e			 
917e			    ; Search for free memory block 
917e			    ld de, (heap_end)  ; Load end of heap into DE 
917e			    ld bc, 0           ; Initialize counter 
917e			 
917e					if DEBUG_FORTH_MALLOC 
917e						DMARK "ma2" 
917e						CALLMONITOR 
917e					endif 
917e			malloc_search_loop: 
917e			    ; Check if current block is free 
917e			    ld a, (hl)         ; Load current block's status (free or used) 
917e			    cp 0               ; Compare with zero (free) 
917e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
917e			 
917e			    ; Check if current block is large enough 
917e			    ld a, (hl+1)       ; Load high byte of block size 
917e			    cp l               ; Compare with low byte of requested size 
917e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
917e			 
917e			    ld a, (hl+2)       ; Load low byte of block size 
917e			    cp h               ; Compare with high byte of requested size 
917e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
917e			 
917e			    ; Mark block as used 
917e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
917e			 
917e			    ; Calculate remaining space in block 
917e			    ld bc, 0           ; Clear BC 
917e			    add hl, bc         ; Increment HL to point to start of data block 
917e			    add hl, de         ; HL = HL + DE (total size) 
917e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
917e			    add hl, bc         ; Add management overhead to start of data block 
917e			 
917e			    ; Save pointer to allocated block in HL 
917e			if DEBUG_FORTH_MALLOC_HIGH 
917e						DMARK "ma5" 
917e			call malloc_guard_exit 
917e			call malloc_guard_zerolen 
917e			endif 
917e			    ret 
917e			 
917e			malloc_skip_block_check: 
917e			    ; Move to the next block 
917e			    ld bc, 3           ; Size of management overhead 
917e			    add hl, bc         ; Move to the next block 
917e			    inc de             ; Increment counter 
917e			 
917e			    ; Check if we have reached the end of heap 
917e			    ld a, e            ; Load low byte of heap end address 
917e			    cp (hl)            ; Compare with low byte of current address 
917e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
917e			    ld a, d            ; Load high byte of heap end address 
917e			    cp 0               ; Check if it's zero (end of memory) 
917e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
917e			 
917e			    ; If we reached here, allocation failed 
917e			    xor a              ; Set result to NULL 
917e			if DEBUG_FORTH_MALLOC_HIGH 
917e						DMARK "ma6" 
917e			call malloc_guard_exit 
917e			call malloc_guard_zerolen 
917e			endif 
917e			    ret 
917e			malloc_exit: 
917e			if DEBUG_FORTH_MALLOC_HIGH 
917e						DMARK "ma7" 
917e			call malloc_guard_exit 
917e			call malloc_guard_zerolen 
917e			endif 
917e			    ret 
917e			 
917e			; Internal Free Function: 
917e			; Input: 
917e			;   HL: Pointer to memory block to free 
917e			; Output: 
917e			;   None 
917e			 
917e			free_internal: 
917e			    ld de, (heap_start) ; Load start of heap into DE 
917e			    ld bc, 0            ; Initialize counter 
917e			 
917e			free_search_loop: 
917e			    ; Check if current block contains the pointer 
917e			    ld a, l             ; Load low byte of pointer 
917e			    cp (hl+1)           ; Compare with high byte of current block's address 
917e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917e			    ld a, h             ; Load high byte of pointer 
917e			    cp (hl+2)           ; Compare with low byte of current block's address 
917e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917e			 
917e			    ; Mark block as free 
917e			    ld (hl), 0          ; Set status byte to indicate free block 
917e			    ret                 ; Return 
917e			 
917e			free_skip_block_check: 
917e			    ; Move to the next block 
917e			    ld bc, 3            ; Size of management overhead 
917e			    add hl, bc          ; Move to the next block 
917e			    inc de              ; Increment counter 
917e			 
917e			    ; Check if we have reached the end of heap 
917e			    ld a, e             ; Load low byte of heap end address 
917e			    cp (hl)             ; Compare with low byte of current address 
917e			    jr nz, free_search_loop  ; If not equal, continue searching 
917e			    ld a, d             ; Load high byte of heap end address 
917e			    cp 0                ; Check if it's zero (end of memory) 
917e			    jr nz, free_search_loop  ; If not zero, continue searching 
917e			 
917e			    ; If we reached here, pointer is not found in heap 
917e			    ret 
917e			 
917e			free_exit: 
917e			    ret                 ; Return 
917e			 
917e			; Define heap start and end addresses 
917e			;heap_start:    .dw 0xC000   ; Start of heap 
917e			;heap_end:      .dw 0xE000   ; End of heap 
917e			 
917e			endif 
917e			 
917e			 
917e			if MALLOC_1 
917e			 
917e			 
917e			 
917e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
917e			 
917e			;moved to firmware.asm 
917e			;heap_start        .equ  0x9000      ; Starting address of heap 
917e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
917e			 
917e			;      .org 0 
917e			;      jp    main 
917e			 
917e			 
917e			;      .org  0x100 
917e			;main: 
917e			;      ld    HL, 0x8100 
917e			;      ld    SP, HL 
917e			; 
917e			;      call  heap_init 
917e			; 
917e			;      ; Make some allocations 
917e			;      ld    HL, 12 
917e			;      call  malloc            ; Allocates 0x9004 
917e			; 
917e			;      ld    HL, 12 
917e			;      call  malloc            ; Allocates 0x9014 
917e			; 
917e			;      ld    HL, 12 
917e			;      call  malloc            ; Allocates 0x9024 
917e			; 
917e			;      ; Free some allocations 
917e			;      ld    HL, 0x9014 
917e			;      call  free 
917e			; 
917e			;      ld    HL, 0x9004 
917e			;      call  free 
917e			; 
917e			;      ld    HL, 0x9024 
917e			;      call  free 
917e			; 
917e			; 
917e			;      halt 
917e			 
917e			 
917e			;------------------------------------------------------------------------------ 
917e			;     heap_init                                                               : 
917e			;                                                                             : 
917e			; Description                                                                 : 
917e			;     Initialise the heap and make it ready for malloc and free operations.   : 
917e			;                                                                             : 
917e			;     The heap is maintained as a linked list, starting with an initial       : 
917e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
917e			;     the first free block in the heap. Each block then points to the next    : 
917e			;     free block within the heap, and the free list ends at the first block   : 
917e			;     with a null pointer to the next free block.                             : 
917e			;                                                                             : 
917e			; Parameters                                                                  : 
917e			;     Inputs are compile-time only. Two defines which specify the starting    : 
917e			;     address of the heap and its size are required, along with a memory      : 
917e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
917e			;     principally stores a pointer to the first free block in the heap.       : 
917e			;                                                                             : 
917e			; Returns                                                                     : 
917e			;     Nothing                                                                 : 
917e			;------------------------------------------------------------------------------ 
917e			heap_init: 
917e e5			      push  HL 
917f			 
917f			      ; Initialise free list struct 
917f 21 80 e4		      ld    HL, heap_start 
9182 22 7b e4		      ld    (free_list), HL 
9185 21 00 00		      ld    HL, 0 
9188 22 7d e4		      ld    (free_list+2), HL 
918b			 
918b			      ; Insert first free block at bottom of heap, consumes entire heap 
918b 21 98 e2		      ld    HL, heap_start+heap_size-4 
918e 22 80 e4		      ld    (heap_start), HL        ; Next block (end of free list) 
9191 21 18 fe		      ld    HL, heap_size-4 
9194 22 82 e4		      ld    (heap_start+2), HL      ; Block size 
9197			 
9197			      ; Insert end of free list block at top of heap - two null words will 
9197			      ; terminate the free list 
9197 21 00 00		      ld    HL, 0 
919a 22 9a e2		      ld    (heap_start+heap_size-2), HL 
919d 22 98 e2		      ld    (heap_start+heap_size-4), HL 
91a0			 
91a0 e1			      pop   HL 
91a1			 
91a1 c9			      ret 
91a2			 
91a2			 
91a2			;------------------------------------------------------------------------------ 
91a2			;     malloc                                                                  : 
91a2			;                                                                             : 
91a2			; Description                                                                 : 
91a2			;     Allocates the wanted space from the heap and returns the address of the : 
91a2			;     first useable byte of the allocation.                                   : 
91a2			;                                                                             : 
91a2			;     Allocations can happen in one of two ways:                              : 
91a2			;                                                                             : 
91a2			;     1. A free block may be found which is the exact size wanted. In this    : 
91a2			;        case the block is removed from the free list and retuedn to the      : 
91a2			;        caller.                                                              : 
91a2			;     2. A free block may be found which is larger than the size wanted. In   : 
91a2			;        this case, the larger block is split into two. The first portion of  : 
91a2			;        this block will become the requested space by the malloc call and    : 
91a2			;        is returned to the caller. The second portion becomes a new free     : 
91a2			;        block, and the free list is adjusted to maintain continuity via this : 
91a2			;        newly created block.                                                 : 
91a2			;                                                                             : 
91a2			;     malloc does not set any initial value in the allocated space, the       : 
91a2			;     caller is required to do this as required.                              : 
91a2			;                                                                             : 
91a2			;     This implementation of malloc uses the stack exclusively, and is        : 
91a2			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91a2			;     advisable to disable interrupts before calling malloc, and recommended  : 
91a2			;     to avoid the use of malloc inside ISRs in general.                      : 
91a2			;                                                                             : 
91a2			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91a2			;                                                                             : 
91a2			; Parameters                                                                  : 
91a2			;     HL  Number of bytes wanted                                              : 
91a2			;                                                                             : 
91a2			; Returns                                                                     : 
91a2			;     HL  Address of the first useable byte of the allocation                 : 
91a2			;                                                                             : 
91a2			; Flags                                                                       : 
91a2			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91a2			;                                                                             : 
91a2			; Stack frame                                                                 : 
91a2			;       |             |                                                       : 
91a2			;       +-------------+                                                       : 
91a2			;       |     BC      |                                                       : 
91a2			;       +-------------+                                                       : 
91a2			;       |     DE      |                                                       : 
91a2			;       +-------------+                                                       : 
91a2			;       |     IX      |                                                       : 
91a2			;       +-------------+                                                       : 
91a2			;       |  prev_free  |                                                       : 
91a2			;   +4  +-------------+                                                       : 
91a2			;       |  this_free  |                                                       : 
91a2			;   +2  +-------------+                                                       : 
91a2			;       |  next_free  |                                                       : 
91a2			;   +0  +-------------+                                                       : 
91a2			;       |             |                                                       : 
91a2			;                                                                             : 
91a2			;------------------------------------------------------------------------------ 
91a2			 
91a2			 
91a2			;malloc: 
91a2			; 
91a2			;	SAVESP ON 1 
91a2			; 
91a2			;	call malloc_code 
91a2			; 
91a2			;	CHECKSP ON 1 
91a2			;	ret 
91a2			 
91a2			 
91a2			malloc: 
91a2 c5			      push  BC 
91a3 d5			      push  DE 
91a4 dd e5		      push  IX 
91a6			if DEBUG_FORTH_MALLOC_HIGH 
91a6			call malloc_guard_entry 
91a6			endif 
91a6			 
91a6					if DEBUG_FORTH_MALLOC 
91a6						DMARK "mal" 
91a6						CALLMONITOR 
91a6					endif 
91a6 7c			      ld    A, H                    ; Exit if no space requested 
91a7 b5			      or    L 
91a8 ca 67 92		      jp    Z, malloc_early_exit 
91ab			 
91ab			;inc hl 
91ab			;inc hl 
91ab			;inc hl 
91ab			; 
91ab			;inc hl 
91ab			;inc hl 
91ab			;inc hl 
91ab			;inc hl 
91ab			;inc hl 
91ab			;inc hl 
91ab			;inc hl 
91ab			;inc hl 
91ab			;inc hl 
91ab			 
91ab			 
91ab			 
91ab			 
91ab					if DEBUG_FORTH_MALLOC 
91ab						DMARK "maA" 
91ab						CALLMONITOR 
91ab					endif 
91ab			      ; Set up stack frame 
91ab eb			      ex    DE, HL 
91ac 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91af 39			      add   HL, SP 
91b0 f9			      ld    SP, HL 
91b1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91b5 dd 39		      add   IX, SP 
91b7			 
91b7			      ; Setup initial state 
91b7 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
91ba 19			      add   HL, DE 
91bb			 
91bb 44			      ld    B, H                    ; Move want to BC 
91bc 4d			      ld    C, L 
91bd			 
91bd 21 7b e4		      ld    HL, free_list           ; Store prev_free ptr to stack 
91c0 dd 75 04		      ld    (IX+4), L 
91c3 dd 74 05		      ld    (IX+5), H 
91c6			 
91c6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
91c7 23			      inc   HL 
91c8 56			      ld    D, (HL) 
91c9 dd 73 02		      ld    (IX+2), E 
91cc dd 72 03		      ld    (IX+3), D 
91cf eb			      ex    DE, HL                  ; this_free ptr into HL 
91d0			 
91d0					if DEBUG_FORTH_MALLOC 
91d0						DMARK "maB" 
91d0						CALLMONITOR 
91d0					endif 
91d0			      ; Loop through free block list to find some space 
91d0			malloc_find_space: 
91d0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
91d1 23			      inc   HL 
91d2 56			      ld    D, (HL) 
91d3			 
91d3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91d4 b3			      or    E 
91d5 ca 61 92		      jp    Z, malloc_no_space 
91d8			 
91d8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91db dd 72 01		      ld    (IX+1), D 
91de			 
91de			      ; Does this block have enough space to make the allocation? 
91de 23			      inc   HL                      ; Load free block size into DE 
91df 5e			      ld    E, (HL) 
91e0 23			      inc   HL 
91e1 56			      ld    D, (HL) 
91e2			 
91e2 eb			      ex    DE, HL                  ; Check size of block against want 
91e3 b7			      or    A                       ; Ensure carry flag clear 
91e4 ed 42		      sbc   HL, BC 
91e6 e5			      push  HL                      ; Store the result for later (new block size) 
91e7			 
91e7 ca 36 92		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91ea 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91ec			 
91ec			      ; this_free block is not big enough, setup ptrs to test next free block 
91ec e1			      pop   HL                      ; Discard previous result 
91ed			 
91ed dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91f0 dd 66 03		      ld    H, (IX+3) 
91f3 dd 75 04		      ld    (IX+4), L 
91f6 dd 74 05		      ld    (IX+5), H 
91f9			 
91f9 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91fc dd 66 01		      ld    H, (IX+1) 
91ff dd 75 02		      ld    (IX+2), L 
9202 dd 74 03		      ld    (IX+3), H 
9205			 
9205					if DEBUG_FORTH_MALLOC 
9205						DMARK "MA>" 
9205						CALLMONITOR 
9205					endif 
9205 18 c9		      jr    malloc_find_space 
9207			 
9207			      ; split a bigger block into two - requested size and remaining size 
9207			malloc_alloc_split: 
9207					if DEBUG_FORTH_MALLOC 
9207						DMARK "MAs" 
9207						CALLMONITOR 
9207					endif 
9207 eb			      ex    DE, HL                  ; Calculate address of new free block 
9208 2b			      dec   HL 
9209 2b			      dec   HL 
920a 2b			      dec   HL 
920b 09			      add   HL, BC 
920c			 
920c			      ; Create a new block and point it at next_free 
920c dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
920f dd 56 01		      ld    D, (IX+1) 
9212			 
9212 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9213 23			      inc   HL 
9214 72			      ld    (HL), D 
9215			 
9215 d1			      pop   DE                      ; Store size of new block into new block 
9216 23			      inc   HL 
9217 73			      ld    (HL), E 
9218 23			      inc   HL 
9219 72			      ld    (HL), D 
921a			 
921a			      ; Update this_free ptr to point to new block 
921a 2b			      dec   HL 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d			 
921d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9220 dd 56 03		      ld    D, (IX+3) 
9223			 
9223 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9226 dd 74 03		      ld    (IX+3), H 
9229			 
9229			      ; Modify this_free block to be allocation 
9229 eb			      ex    DE, HL 
922a af			      xor   A                       ; Null the next block ptr of allocated block 
922b 77			      ld    (HL), A 
922c 23			      inc   HL 
922d 77			      ld    (HL), A 
922e			 
922e 23			      inc   HL                      ; Store want size into allocated block 
922f 71			      ld    (HL), C 
9230 23			      inc   HL 
9231 70			      ld    (HL), B 
9232 23			      inc   HL 
9233 e5			      push  HL                      ; Address of allocation to return 
9234			 
9234 18 19		      jr    malloc_update_links 
9236			 
9236			malloc_alloc_fit: 
9236 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9237			 
9237					if DEBUG_FORTH_MALLOC 
9237						DMARK "MAf" 
9237						CALLMONITOR 
9237					endif 
9237			      ; Modify this_free block to be allocation 
9237 eb			      ex    DE, HL 
9238 2b			      dec   HL 
9239 2b			      dec   HL 
923a 2b			      dec   HL 
923b			 
923b af			      xor   A                       ; Null the next block ptr of allocated block 
923c 77			      ld    (HL), A 
923d 23			      inc   HL 
923e 77			      ld    (HL), A 
923f			 
923f 23			      inc   HL                      ; Store address of allocation to return 
9240 23			      inc   HL 
9241 23			      inc   HL 
9242 e5			      push  HL 
9243			 
9243			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9243 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9246 dd 66 01		      ld    H, (IX+1) 
9249			 
9249 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
924c dd 74 03		      ld    (IX+3), H 
924f			 
924f			 
924f			malloc_update_links: 
924f			      ; Update prev_free ptr to point to this_free 
924f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9252 dd 66 05		      ld    H, (IX+5) 
9255			 
9255 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9258 dd 56 03		      ld    D, (IX+3) 
925b			 
925b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
925c 23			      inc   HL 
925d 72			      ld    (HL), D 
925e			 
925e					if DEBUG_FORTH_MALLOC 
925e						DMARK "Mul" 
925e						CALLMONITOR 
925e					endif 
925e			      ; Clear the Z flag to indicate successful allocation 
925e 7a			      ld    A, D 
925f b3			      or    E 
9260			 
9260 d1			      pop   DE                      ; Address of allocation 
9261					if DEBUG_FORTH_MALLOC 
9261						DMARK "MAu" 
9261						CALLMONITOR 
9261					endif 
9261			 
9261			malloc_no_space: 
9261 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9264 39			      add   HL, SP 
9265 f9			      ld    SP, HL 
9266			 
9266 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9267					if DEBUG_FORTH_MALLOC 
9267						DMARK "MAN" 
9267						CALLMONITOR 
9267					endif 
9267			 
9267			malloc_early_exit: 
9267					if DEBUG_FORTH_MALLOC 
9267						DMARK "MAx" 
9267						CALLMONITOR 
9267					endif 
9267 dd e1		      pop   IX 
9269 d1			      pop   DE 
926a c1			      pop   BC 
926b			 
926b			if DEBUG_FORTH_MALLOC_HIGH 
926b			call malloc_guard_exit 
926b			call malloc_guard_zerolen 
926b			endif 
926b c9			      ret 
926c			 
926c			 
926c			;------------------------------------------------------------------------------ 
926c			;     free                                                                    : 
926c			;                                                                             : 
926c			; Description                                                                 : 
926c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
926c			;     returned by malloc, otherwise the behaviour is undefined.               : 
926c			;                                                                             : 
926c			;     Where possible, directly adjacent free blocks will be merged together   : 
926c			;     into larger blocks to help ensure that the heap does not become         : 
926c			;     excessively fragmented.                                                 : 
926c			;                                                                             : 
926c			;     free does not clear or set any other value into the freed space, and    : 
926c			;     therefore its contents may be visible through subsequent malloc's. The  : 
926c			;     caller should clear the freed space as required.                        : 
926c			;                                                                             : 
926c			;     This implementation of free uses the stack exclusively, and is          : 
926c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
926c			;     advisable to disable interrupts before calling free, and recommended    : 
926c			;     to avoid the use of free inside ISRs in general.                        : 
926c			;                                                                             : 
926c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
926c			;                                                                             : 
926c			; Parameters                                                                  : 
926c			;     HL  Pointer to address of first byte of allocation to be freed          : 
926c			;                                                                             : 
926c			; Returns                                                                     : 
926c			;     Nothing                                                                 : 
926c			;                                                                             : 
926c			; Stack frame                                                                 : 
926c			;       |             |                                                       : 
926c			;       +-------------+                                                       : 
926c			;       |     BC      |                                                       : 
926c			;       +-------------+                                                       : 
926c			;       |     DE      |                                                       : 
926c			;       +-------------+                                                       : 
926c			;       |     IX      |                                                       : 
926c			;       +-------------+                                                       : 
926c			;       |  prev_free  |                                                       : 
926c			;   +2  +-------------+                                                       : 
926c			;       |  next_free  |                                                       : 
926c			;   +0  +-------------+                                                       : 
926c			;       |             |                                                       : 
926c			;                                                                             : 
926c			;------------------------------------------------------------------------------ 
926c			free: 
926c c5			      push  BC 
926d d5			      push  DE 
926e dd e5		      push  IX 
9270			 
9270 7c			      ld    A, H                    ; Exit if ptr is null 
9271 b5			      or    L 
9272 ca 36 93		      jp    Z, free_early_exit 
9275			 
9275			      ; Set up stack frame 
9275 eb			      ex    DE, HL 
9276 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9279 39			      add   HL, SP 
927a f9			      ld    SP, HL 
927b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
927f dd 39		      add   IX, SP 
9281			 
9281			      ; The address in HL points to the start of the useable allocated space, 
9281			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9281			      ; address of the block itself. 
9281 eb			      ex    DE, HL 
9282 11 fc ff		      ld    DE, -4 
9285 19			      add   HL, DE 
9286			 
9286			      ; An allocated block must have a null next block pointer in it 
9286 7e			      ld    A, (HL) 
9287 23			      inc   HL 
9288 b6			      or    (HL) 
9289 c2 31 93		      jp    NZ, free_done 
928c			 
928c 2b			      dec   HL 
928d			 
928d 44			      ld    B, H                    ; Copy HL to BC 
928e 4d			      ld    C, L 
928f			 
928f			      ; Loop through the free list to find the first block with an address 
928f			      ; higher than the block being freed 
928f 21 7b e4		      ld    HL, free_list 
9292			 
9292			free_find_higher_block: 
9292 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9293 23			      inc   HL 
9294 56			      ld    D, (HL) 
9295 2b			      dec   HL 
9296			 
9296 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9299 dd 72 01		      ld    (IX+1), D 
929c dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
929f dd 74 03		      ld    (IX+3), H 
92a2			 
92a2 78			      ld    A, B                    ; Check if DE is greater than BC 
92a3 ba			      cp    D                       ; Compare MSB first 
92a4 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
92a6 30 04		      jr    NC, free_find_higher_block_skip 
92a8 79			      ld    A, C 
92a9 bb			      cp    E                       ; Then compare LSB 
92aa 38 08		      jr    C, free_found_higher_block 
92ac			 
92ac			free_find_higher_block_skip: 
92ac 7a			      ld    A, D                    ; Reached the end of the free list? 
92ad b3			      or    E 
92ae ca 31 93		      jp    Z, free_done 
92b1			 
92b1 eb			      ex    DE, HL 
92b2			 
92b2 18 de		      jr    free_find_higher_block 
92b4			 
92b4			free_found_higher_block: 
92b4			      ; Insert freed block between prev and next free blocks 
92b4 71			      ld    (HL), C                 ; Point prev free block to freed block 
92b5 23			      inc   HL 
92b6 70			      ld    (HL), B 
92b7			 
92b7 60			      ld    H, B                    ; Point freed block at next free block 
92b8 69			      ld    L, C 
92b9 73			      ld    (HL), E 
92ba 23			      inc   HL 
92bb 72			      ld    (HL), D 
92bc			 
92bc			      ; Check if the freed block is adjacent to the next free block 
92bc 23			      inc   HL                      ; Load size of freed block into HL 
92bd 5e			      ld    E, (HL) 
92be 23			      inc   HL 
92bf 56			      ld    D, (HL) 
92c0 eb			      ex    DE, HL 
92c1			 
92c1 09			      add   HL, BC                  ; Add addr of freed block and its size 
92c2			 
92c2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
92c5 dd 56 01		      ld    D, (IX+1) 
92c8			 
92c8 b7			      or    A                       ; Clear the carry flag 
92c9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92cb 20 22		      jr    NZ, free_check_adjacent_to_prev 
92cd			 
92cd			      ; Freed block is adjacent to next, merge into one bigger block 
92cd eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
92ce 5e			      ld    E, (HL) 
92cf 23			      inc   HL 
92d0 56			      ld    D, (HL) 
92d1 e5			      push  HL                      ; Save ptr to next block for later 
92d2			 
92d2 60			      ld    H, B                    ; Store ptr from next block into freed block 
92d3 69			      ld    L, C 
92d4 73			      ld    (HL), E 
92d5 23			      inc   HL 
92d6 72			      ld    (HL), D 
92d7			 
92d7 e1			      pop   HL                      ; Restore ptr to next block 
92d8 23			      inc   HL                      ; Load size of next block into DE 
92d9 5e			      ld    E, (HL) 
92da 23			      inc   HL 
92db 56			      ld    D, (HL) 
92dc d5			      push  DE                      ; Save next block size for later 
92dd			 
92dd 60			      ld    H, B                    ; Load size of freed block into HL 
92de 69			      ld    L, C 
92df 23			      inc   HL 
92e0 23			      inc   HL 
92e1 5e			      ld    E, (HL) 
92e2 23			      inc   HL 
92e3 56			      ld    D, (HL) 
92e4 eb			      ex    DE, HL 
92e5			 
92e5 d1			      pop   DE                      ; Restore size of next block 
92e6 19			      add   HL, DE                  ; Add sizes of both blocks 
92e7 eb			      ex    DE, HL 
92e8			 
92e8 60			      ld    H, B                    ; Store new bigger size into freed block 
92e9 69			      ld    L, C 
92ea 23			      inc   HL 
92eb 23			      inc   HL 
92ec 73			      ld    (HL), E 
92ed 23			      inc   HL 
92ee 72			      ld    (HL), D 
92ef			 
92ef			free_check_adjacent_to_prev: 
92ef			      ; Check if the freed block is adjacent to the prev free block 
92ef dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92f2 dd 66 03		      ld    H, (IX+3) 
92f5			 
92f5 23			      inc   HL                      ; Size of prev free block into DE 
92f6 23			      inc   HL 
92f7 5e			      ld    E, (HL) 
92f8 23			      inc   HL 
92f9 56			      ld    D, (HL) 
92fa 2b			      dec   HL 
92fb 2b			      dec   HL 
92fc 2b			      dec   HL 
92fd			 
92fd 19			      add   HL, DE                  ; Add prev block addr and size 
92fe			 
92fe b7			      or    A                       ; Clear the carry flag 
92ff ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9301 20 2e		      jr    NZ, free_done 
9303			 
9303			      ; Freed block is adjacent to prev, merge into one bigger block 
9303 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9304 69			      ld    L, C 
9305 5e			      ld    E, (HL) 
9306 23			      inc   HL 
9307 56			      ld    D, (HL) 
9308 e5			      push  HL                      ; Save freed block ptr for later 
9309			 
9309 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
930c dd 66 03		      ld    H, (IX+3) 
930f 73			      ld    (HL), E 
9310 23			      inc   HL 
9311 72			      ld    (HL), D 
9312			 
9312 e1			      pop   HL                      ; Restore freed block ptr 
9313 23			      inc   HL                      ; Load size of freed block into DE 
9314 5e			      ld    E, (HL) 
9315 23			      inc   HL 
9316 56			      ld    D, (HL) 
9317 d5			      push  DE                      ; Save freed block size for later 
9318			 
9318 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
931b dd 66 03		      ld    H, (IX+3) 
931e 23			      inc   HL 
931f 23			      inc   HL 
9320 5e			      ld    E, (HL) 
9321 23			      inc   HL 
9322 56			      ld    D, (HL) 
9323			 
9323 e1			      pop   HL                      ; Add sizes of both blocks 
9324 19			      add   HL, DE 
9325 eb			      ex    DE, HL 
9326			 
9326 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9329 dd 66 03		      ld    H, (IX+3) 
932c 23			      inc   HL 
932d 23			      inc   HL 
932e 73			      ld    (HL), E 
932f 23			      inc   HL 
9330 72			      ld    (HL), D 
9331			 
9331			free_done: 
9331 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9334 39			      add   HL, SP 
9335 f9			      ld    SP, HL 
9336			 
9336			free_early_exit: 
9336 dd e1		      pop   IX 
9338 d1			      pop   DE 
9339 c1			      pop   BC 
933a			 
933a c9			      ret 
933b			 
933b			; moved to firmware.asm 
933b			; 
933b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933b			;                  .dw   0 
933b			 
933b			 
933b			endif 
933b			 
933b			 
933b			if MALLOC_3 
933b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
933b			;heap_start        .equ  0x9000      ; Starting address of heap 
933b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
933b			; 
933b			 ;     .org 0 
933b			  ;    jp    main 
933b			; 
933b			; 
933b			 ;     .org  0x100 
933b			;main: 
933b			 ;     ld    HL, 0x8100 
933b			  ;    ld    SP, HL 
933b			; 
933b			;      call  heap_init 
933b			 
933b			      ; Make some allocations 
933b			;      ld    HL, 12 
933b			;      call  malloc            ; Allocates 0x9004 
933b			; 
933b			 ;     ld    HL, 12 
933b			;      call  malloc            ; Allocates 0x9014 
933b			 
933b			;      ld    HL, 12 
933b			;      call  malloc            ; Allocates 0x9024 
933b			 
933b			      ; Free some allocations 
933b			;      ld    HL, 0x9014 
933b			;      call  free 
933b			 
933b			;      ld    HL, 0x9004 
933b			;      call  free 
933b			; 
933b			;      ld    HL, 0x9024 
933b			;      call  free 
933b			 
933b			 
933b			 ;     halt 
933b			 
933b			 
933b			;------------------------------------------------------------------------------ 
933b			;     heap_init                                                               : 
933b			;                                                                             : 
933b			; Description                                                                 : 
933b			;     Initialise the heap and make it ready for malloc and free operations.   : 
933b			;                                                                             : 
933b			;     The heap is maintained as a linked list, starting with an initial       : 
933b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
933b			;     the first free block in the heap. Each block then points to the next    : 
933b			;     free block within the heap, and the free list ends at the first block   : 
933b			;     with a null pointer to the next free block.                             : 
933b			;                                                                             : 
933b			; Parameters                                                                  : 
933b			;     Inputs are compile-time only. Two defines which specify the starting    : 
933b			;     address of the heap and its size are required, along with a memory      : 
933b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
933b			;     principally stores a pointer to the first free block in the heap.       : 
933b			;                                                                             : 
933b			; Returns                                                                     : 
933b			;     Nothing                                                                 : 
933b			;------------------------------------------------------------------------------ 
933b			heap_init: 
933b			      push  HL 
933b			 
933b			      ; Initialise free list struct 
933b			      ld    HL, heap_start 
933b			      ld    (free_list), HL 
933b			      ld    HL, 0 
933b			      ld    (free_list+2), HL 
933b			 
933b			      ; Insert first free block at bottom of heap, consumes entire heap 
933b			      ld    HL, heap_start+heap_size-4 
933b			      ld    (heap_start), HL        ; Next block (end of free list) 
933b			      ld    HL, heap_size-4 
933b			      ld    (heap_start+2), HL      ; Block size 
933b			 
933b			      ; Insert end of free list block at top of heap - two null words will 
933b			      ; terminate the free list 
933b			      ld    HL, 0 
933b			      ld    (heap_start+heap_size-2), HL 
933b			      ld    (heap_start+heap_size-4), HL 
933b			 
933b			      pop   HL 
933b			 
933b			      ret 
933b			 
933b			 
933b			;------------------------------------------------------------------------------ 
933b			;     malloc                                                                  : 
933b			;                                                                             : 
933b			; Description                                                                 : 
933b			;     Allocates the wanted space from the heap and returns the address of the : 
933b			;     first useable byte of the allocation.                                   : 
933b			;                                                                             : 
933b			;     Allocations can happen in one of two ways:                              : 
933b			;                                                                             : 
933b			;     1. A free block may be found which is the exact size wanted. In this    : 
933b			;        case the block is removed from the free list and retuedn to the      : 
933b			;        caller.                                                              : 
933b			;     2. A free block may be found which is larger than the size wanted. In   : 
933b			;        this case, the larger block is split into two. The first portion of  : 
933b			;        this block will become the requested space by the malloc call and    : 
933b			;        is returned to the caller. The second portion becomes a new free     : 
933b			;        block, and the free list is adjusted to maintain continuity via this : 
933b			;        newly created block.                                                 : 
933b			;                                                                             : 
933b			;     malloc does not set any initial value in the allocated space, the       : 
933b			;     caller is required to do this as required.                              : 
933b			;                                                                             : 
933b			;     This implementation of malloc uses the stack exclusively, and is        : 
933b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933b			;     advisable to disable interrupts before calling malloc, and recommended  : 
933b			;     to avoid the use of malloc inside ISRs in general.                      : 
933b			;                                                                             : 
933b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933b			;                                                                             : 
933b			; Parameters                                                                  : 
933b			;     HL  Number of bytes wanted                                              : 
933b			;                                                                             : 
933b			; Returns                                                                     : 
933b			;     HL  Address of the first useable byte of the allocation                 : 
933b			;                                                                             : 
933b			; Flags                                                                       : 
933b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
933b			;                                                                             : 
933b			; Stack frame                                                                 : 
933b			;       |             |                                                       : 
933b			;       +-------------+                                                       : 
933b			;       |     BC      |                                                       : 
933b			;       +-------------+                                                       : 
933b			;       |     DE      |                                                       : 
933b			;       +-------------+                                                       : 
933b			;       |     IX      |                                                       : 
933b			;       +-------------+                                                       : 
933b			;       |  prev_free  |                                                       : 
933b			;   +4  +-------------+                                                       : 
933b			;       |  this_free  |                                                       : 
933b			;   +2  +-------------+                                                       : 
933b			;       |  next_free  |                                                       : 
933b			;   +0  +-------------+                                                       : 
933b			;       |             |                                                       : 
933b			;                                                                             : 
933b			;------------------------------------------------------------------------------ 
933b			malloc: 
933b			      push  BC 
933b			      push  DE 
933b			      push  IX 
933b			 
933b			      ld    A, H                    ; Exit if no space requested 
933b			      or    L 
933b			      jp    Z, malloc_early_exit 
933b			 
933b			      ; Set up stack frame 
933b			      ex    DE, HL 
933b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
933b			      add   HL, SP 
933b			      ld    SP, HL 
933b			      ld    IX, 0                   ; Use IX as a frame pointer 
933b			      add   IX, SP 
933b			 
933b			      ; Setup initial state 
933b			      ld    HL, 4                   ; want must also include space used by block struct 
933b			      add   HL, DE 
933b			 
933b			      ld    B, H                    ; Move want to BC 
933b			      ld    C, L 
933b			 
933b			      ld    HL, free_list           ; Store prev_free ptr to stack 
933b			      ld    (IX+4), L 
933b			      ld    (IX+5), H 
933b			 
933b			      ld    E, (HL)                 ; Store this_free ptr to stack 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			      ld    (IX+2), E 
933b			      ld    (IX+3), D 
933b			      ex    DE, HL                  ; this_free ptr into HL 
933b			 
933b			      ; Loop through free block list to find some space 
933b			malloc_find_space: 
933b			      ld    E, (HL)                 ; Load next_free ptr into DE 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			 
933b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
933b			      or    E 
933b			      jp    Z, malloc_no_space 
933b			 
933b			      ld    (IX+0), E               ; Store next_free ptr to stack 
933b			      ld    (IX+1), D 
933b			 
933b			      ; Does this block have enough space to make the allocation? 
933b			      inc   HL                      ; Load free block size into DE 
933b			      ld    E, (HL) 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			 
933b			      ex    DE, HL                  ; Check size of block against want 
933b			      or    A                       ; Ensure carry flag clear 
933b			      sbc   HL, BC 
933b			      push  HL                      ; Store the result for later (new block size) 
933b			 
933b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
933b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
933b			 
933b			      ; this_free block is not big enough, setup ptrs to test next free block 
933b			      pop   HL                      ; Discard previous result 
933b			 
933b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
933b			      ld    H, (IX+3) 
933b			      ld    (IX+4), L 
933b			      ld    (IX+5), H 
933b			 
933b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
933b			      ld    H, (IX+1) 
933b			      ld    (IX+2), L 
933b			      ld    (IX+3), H 
933b			 
933b			      jr    malloc_find_space 
933b			 
933b			      ; split a bigger block into two - requested size and remaining size 
933b			malloc_alloc_split: 
933b			      ex    DE, HL                  ; Calculate address of new free block 
933b			      dec   HL 
933b			      dec   HL 
933b			      dec   HL 
933b			      add   HL, BC 
933b			 
933b			      ; Create a new block and point it at next_free 
933b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
933b			      ld    D, (IX+1) 
933b			 
933b			      ld    (HL), E                 ; Store next_free ptr into new block 
933b			      inc   HL 
933b			      ld    (HL), D 
933b			 
933b			      pop   DE                      ; Store size of new block into new block 
933b			      inc   HL 
933b			      ld    (HL), E 
933b			      inc   HL 
933b			      ld    (HL), D 
933b			 
933b			      ; Update this_free ptr to point to new block 
933b			      dec   HL 
933b			      dec   HL 
933b			      dec   HL 
933b			 
933b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
933b			      ld    D, (IX+3) 
933b			 
933b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
933b			      ld    (IX+3), H 
933b			 
933b			      ; Modify this_free block to be allocation 
933b			      ex    DE, HL 
933b			      xor   A                       ; Null the next block ptr of allocated block 
933b			      ld    (HL), A 
933b			      inc   HL 
933b			      ld    (HL), A 
933b			 
933b			      inc   HL                      ; Store want size into allocated block 
933b			      ld    (HL), C 
933b			      inc   HL 
933b			      ld    (HL), B 
933b			      inc   HL 
933b			      push  HL                      ; Address of allocation to return 
933b			 
933b			      jr    malloc_update_links 
933b			 
933b			malloc_alloc_fit: 
933b			      pop   HL                      ; Dont need new block size, want is exact fit 
933b			 
933b			      ; Modify this_free block to be allocation 
933b			      ex    DE, HL 
933b			      dec   HL 
933b			      dec   HL 
933b			      dec   HL 
933b			 
933b			      xor   A                       ; Null the next block ptr of allocated block 
933b			      ld    (HL), A 
933b			      inc   HL 
933b			      ld    (HL), A 
933b			 
933b			      inc   HL                      ; Store address of allocation to return 
933b			      inc   HL 
933b			      inc   HL 
933b			      push  HL 
933b			 
933b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
933b			      ld    L, (IX+0)               ; next_free to HL 
933b			      ld    H, (IX+1) 
933b			 
933b			      ld    (IX+2), L               ; HL to this_free 
933b			      ld    (IX+3), H 
933b			 
933b			 
933b			malloc_update_links: 
933b			      ; Update prev_free ptr to point to this_free 
933b			      ld    L, (IX+4)               ; prev_free ptr to HL 
933b			      ld    H, (IX+5) 
933b			 
933b			      ld    E, (IX+2)               ; this_free ptr to DE 
933b			      ld    D, (IX+3) 
933b			 
933b			      ld    (HL), E                 ; this_free ptr into prev_free 
933b			      inc   HL 
933b			      ld    (HL), D 
933b			 
933b			      ; Clear the Z flag to indicate successful allocation 
933b			      ld    A, D 
933b			      or    E 
933b			 
933b			      pop   DE                      ; Address of allocation 
933b			 
933b			malloc_no_space: 
933b			      ld    HL, 6                   ; Clean up stack frame 
933b			      add   HL, SP 
933b			      ld    SP, HL 
933b			 
933b			      ex    DE, HL                  ; Alloc addr into HL for return 
933b			 
933b			malloc_early_exit: 
933b			      pop   IX 
933b			      pop   DE 
933b			      pop   BC 
933b			 
933b			      ret 
933b			 
933b			 
933b			;------------------------------------------------------------------------------ 
933b			;     free                                                                    : 
933b			;                                                                             : 
933b			; Description                                                                 : 
933b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
933b			;     returned by malloc, otherwise the behaviour is undefined.               : 
933b			;                                                                             : 
933b			;     Where possible, directly adjacent free blocks will be merged together   : 
933b			;     into larger blocks to help ensure that the heap does not become         : 
933b			;     excessively fragmented.                                                 : 
933b			;                                                                             : 
933b			;     free does not clear or set any other value into the freed space, and    : 
933b			;     therefore its contents may be visible through subsequent malloc's. The  : 
933b			;     caller should clear the freed space as required.                        : 
933b			;                                                                             : 
933b			;     This implementation of free uses the stack exclusively, and is          : 
933b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933b			;     advisable to disable interrupts before calling free, and recommended    : 
933b			;     to avoid the use of free inside ISRs in general.                        : 
933b			;                                                                             : 
933b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933b			;                                                                             : 
933b			; Parameters                                                                  : 
933b			;     HL  Pointer to address of first byte of allocation to be freed          : 
933b			;                                                                             : 
933b			; Returns                                                                     : 
933b			;     Nothing                                                                 : 
933b			;                                                                             : 
933b			; Stack frame                                                                 : 
933b			;       |             |                                                       : 
933b			;       +-------------+                                                       : 
933b			;       |     BC      |                                                       : 
933b			;       +-------------+                                                       : 
933b			;       |     DE      |                                                       : 
933b			;       +-------------+                                                       : 
933b			;       |     IX      |                                                       : 
933b			;       +-------------+                                                       : 
933b			;       |  prev_free  |                                                       : 
933b			;   +2  +-------------+                                                       : 
933b			;       |  next_free  |                                                       : 
933b			;   +0  +-------------+                                                       : 
933b			;       |             |                                                       : 
933b			;                                                                             : 
933b			;------------------------------------------------------------------------------ 
933b			free: 
933b			      push  BC 
933b			      push  DE 
933b			      push  IX 
933b			 
933b			      ld    A, H                    ; Exit if ptr is null 
933b			      or    L 
933b			      jp    Z, free_early_exit 
933b			 
933b			      ; Set up stack frame 
933b			      ex    DE, HL 
933b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
933b			      add   HL, SP 
933b			      ld    SP, HL 
933b			      ld    IX, 0                   ; Use IX as a frame pointer 
933b			      add   IX, SP 
933b			 
933b			      ; The address in HL points to the start of the useable allocated space, 
933b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
933b			      ; address of the block itself. 
933b			      ex    DE, HL 
933b			      ld    DE, -4 
933b			      add   HL, DE 
933b			 
933b			      ; An allocated block must have a null next block pointer in it 
933b			      ld    A, (HL) 
933b			      inc   HL 
933b			      or    (HL) 
933b			      jp    NZ, free_done 
933b			 
933b			      dec   HL 
933b			 
933b			      ld    B, H                    ; Copy HL to BC 
933b			      ld    C, L 
933b			 
933b			      ; Loop through the free list to find the first block with an address 
933b			      ; higher than the block being freed 
933b			      ld    HL, free_list 
933b			 
933b			free_find_higher_block: 
933b			      ld    E, (HL)                 ; Load next ptr from free block 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			      dec   HL 
933b			 
933b			      ld    (IX+0), E               ; Save ptr to next free block 
933b			      ld    (IX+1), D 
933b			      ld    (IX+2), L               ; Save ptr to prev free block 
933b			      ld    (IX+3), H 
933b			 
933b			      ld    A, B                    ; Check if DE is greater than BC 
933b			      cp    D                       ; Compare MSB first 
933b			      jr    Z, $+4                  ; MSB the same, compare LSB 
933b			      jr    NC, free_find_higher_block_skip 
933b			      ld    A, C 
933b			      cp    E                       ; Then compare LSB 
933b			      jr    C, free_found_higher_block 
933b			 
933b			free_find_higher_block_skip: 
933b			      ld    A, D                    ; Reached the end of the free list? 
933b			      or    E 
933b			      jp    Z, free_done 
933b			 
933b			      ex    DE, HL 
933b			 
933b			      jr    free_find_higher_block 
933b			 
933b			free_found_higher_block: 
933b			      ; Insert freed block between prev and next free blocks 
933b			      ld    (HL), C                 ; Point prev free block to freed block 
933b			      inc   HL 
933b			      ld    (HL), B 
933b			 
933b			      ld    H, B                    ; Point freed block at next free block 
933b			      ld    L, C 
933b			      ld    (HL), E 
933b			      inc   HL 
933b			      ld    (HL), D 
933b			 
933b			      ; Check if the freed block is adjacent to the next free block 
933b			      inc   HL                      ; Load size of freed block into HL 
933b			      ld    E, (HL) 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			      ex    DE, HL 
933b			 
933b			      add   HL, BC                  ; Add addr of freed block and its size 
933b			 
933b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
933b			      ld    D, (IX+1) 
933b			 
933b			      or    A                       ; Clear the carry flag 
933b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
933b			      jr    NZ, free_check_adjacent_to_prev 
933b			 
933b			      ; Freed block is adjacent to next, merge into one bigger block 
933b			      ex    DE, HL                  ; Load next ptr from next block into DE 
933b			      ld    E, (HL) 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			      push  HL                      ; Save ptr to next block for later 
933b			 
933b			      ld    H, B                    ; Store ptr from next block into freed block 
933b			      ld    L, C 
933b			      ld    (HL), E 
933b			      inc   HL 
933b			      ld    (HL), D 
933b			 
933b			      pop   HL                      ; Restore ptr to next block 
933b			      inc   HL                      ; Load size of next block into DE 
933b			      ld    E, (HL) 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			      push  DE                      ; Save next block size for later 
933b			 
933b			      ld    H, B                    ; Load size of freed block into HL 
933b			      ld    L, C 
933b			      inc   HL 
933b			      inc   HL 
933b			      ld    E, (HL) 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			      ex    DE, HL 
933b			 
933b			      pop   DE                      ; Restore size of next block 
933b			      add   HL, DE                  ; Add sizes of both blocks 
933b			      ex    DE, HL 
933b			 
933b			      ld    H, B                    ; Store new bigger size into freed block 
933b			      ld    L, C 
933b			      inc   HL 
933b			      inc   HL 
933b			      ld    (HL), E 
933b			      inc   HL 
933b			      ld    (HL), D 
933b			 
933b			free_check_adjacent_to_prev: 
933b			      ; Check if the freed block is adjacent to the prev free block 
933b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
933b			      ld    H, (IX+3) 
933b			 
933b			      inc   HL                      ; Size of prev free block into DE 
933b			      inc   HL 
933b			      ld    E, (HL) 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			      dec   HL 
933b			      dec   HL 
933b			      dec   HL 
933b			 
933b			      add   HL, DE                  ; Add prev block addr and size 
933b			 
933b			      or    A                       ; Clear the carry flag 
933b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
933b			      jr    NZ, free_done 
933b			 
933b			      ; Freed block is adjacent to prev, merge into one bigger block 
933b			      ld    H, B                    ; Load next ptr from freed block into DE 
933b			      ld    L, C 
933b			      ld    E, (HL) 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			      push  HL                      ; Save freed block ptr for later 
933b			 
933b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
933b			      ld    H, (IX+3) 
933b			      ld    (HL), E 
933b			      inc   HL 
933b			      ld    (HL), D 
933b			 
933b			      pop   HL                      ; Restore freed block ptr 
933b			      inc   HL                      ; Load size of freed block into DE 
933b			      ld    E, (HL) 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			      push  DE                      ; Save freed block size for later 
933b			 
933b			      ld    L, (IX+2)               ; Load size of prev block into DE 
933b			      ld    H, (IX+3) 
933b			      inc   HL 
933b			      inc   HL 
933b			      ld    E, (HL) 
933b			      inc   HL 
933b			      ld    D, (HL) 
933b			 
933b			      pop   HL                      ; Add sizes of both blocks 
933b			      add   HL, DE 
933b			      ex    DE, HL 
933b			 
933b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
933b			      ld    H, (IX+3) 
933b			      inc   HL 
933b			      inc   HL 
933b			      ld    (HL), E 
933b			      inc   HL 
933b			      ld    (HL), D 
933b			 
933b			free_done: 
933b			      ld    HL, 4                   ; Clean up stack frame 
933b			      add   HL, SP 
933b			      ld    SP, HL 
933b			 
933b			free_early_exit: 
933b			      pop   IX 
933b			      pop   DE 
933b			      pop   BC 
933b			 
933b			      ret 
933b			 
933b			 
933b			;      .org 0x8000 
933b			; 
933b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933b			 ;                 .dw   0 
933b			 
933b			endif 
933b			 
933b			 
933b			if MALLOC_4 
933b			 
933b			; My memory allocation code. Very very simple.... 
933b			; allocate space under 250 chars 
933b			 
933b			heap_init: 
933b				; init start of heap as zero 
933b				;  
933b			 
933b				ld hl, heap_start 
933b				ld a, 0 
933b				ld (hl), a      ; empty block 
933b				inc hl 
933b				ld a, 0 
933b				ld (hl), a      ; length of block 
933b				; write end of list 
933b				inc hl 
933b				ld a,(hl) 
933b				inc hl 
933b				ld a,(hl) 
933b				 
933b			 
933b				; init some malloc vars 
933b			 
933b				ld hl, 0 
933b				ld (free_list), hl       ; store last malloc location 
933b			 
933b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
933b				ld a, 0 
933b				ld (hl), a 
933b			 
933b			 
933b				ld hl, heap_start 
933b				;  
933b				  
933b				ret 
933b			 
933b			 
933b			;    free block marker 
933b			;    requested size  
933b			;    pointer to next block 
933b			;    .... 
933b			;    next block marker 
933b			 
933b			 
933b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
933b			; 
933b			 
933b			 
933b			malloc:  
933b				push de 
933b				push bc 
933b				push af 
933b			 
933b				; hl space required 
933b				 
933b				ld c, l    ; hold space   (TODO only a max of 255) 
933b			 
933b			;	inc c     ; TODO BUG need to fix memory leak on push str 
933b			;	inc c 
933b			;	inc c 
933b			;	inc c 
933b			;	inc c 
933b			;	inc c 
933b			;	inc c 
933b			 
933b			 
933b			 
933b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
933b			 
933b				ld a, (free_list+3) 
933b				cp 0 
933b				jr z, .contheap 
933b			 
933b				ld hl, (free_list)     ; get last alloc 
933b					if DEBUG_FORTH_MALLOC_INT 
933b						DMARK "mrs" 
933b						CALLMONITOR 
933b					endif 
933b				jr .startalloc 
933b			 
933b			.contheap: 
933b				ld hl, heap_start 
933b			 
933b			.startalloc: 
933b			 
933b					if DEBUG_FORTH_MALLOC_INT 
933b						DMARK "mym" 
933b						CALLMONITOR 
933b					endif 
933b			.findblock: 
933b					if DEBUG_FORTH_MALLOC_INT 
933b						DMARK "mmf" 
933b						CALLMONITOR 
933b					endif 
933b			 
933b				ld a,(hl)  
933b				; if byte is zero then clear to use 
933b			 
933b				cp 0 
933b				jr z, .foundemptyblock 
933b			 
933b				; if byte is not clear 
933b				;     then byte is offset to next block 
933b			 
933b				inc hl 
933b				ld a, (hl) ; get size 
933b			.nextblock:	inc hl 
933b					ld e, (hl) 
933b					inc hl 
933b					ld d, (hl) 
933b					ex de, hl 
933b			;	inc hl  ; move past the store space 
933b			;	inc hl  ; move past zero index  
933b			 
933b				; TODO detect no more space 
933b			 
933b				push hl 
933b				ld de, heap_end 
933b				call cmp16 
933b				pop hl 
933b				jr nc, .nospace 
933b			 
933b				jr .findblock 
933b			 
933b			.nospace: ld hl, 0 
933b				jp .exit 
933b			 
933b			 
933b			.foundemptyblock:	 
933b					if DEBUG_FORTH_MALLOC_INT 
933b						DMARK "mme" 
933b						CALLMONITOR 
933b					endif 
933b			 
933b			; TODO has block enough space if reusing??? 
933b			 
933b				;  
933b			 
933b			; see if this block has been previously used 
933b				inc hl 
933b				ld a, (hl) 
933b				dec hl 
933b				cp 0 
933b				jr z, .newblock 
933b			 
933b					if DEBUG_FORTH_MALLOC_INT 
933b						DMARK "meR" 
933b						CALLMONITOR 
933b					endif 
933b			 
933b			; no reusing previously allocated block 
933b			 
933b			; is it smaller than previously used? 
933b				 
933b				inc hl    ; move to size 
933b				ld a, c 
933b				sub (hl)        ; we want c < (hl) 
933b				dec hl    ; move back to marker 
933b			        jr z, .findblock 
933b			 
933b				; update with the new size which should be lower 
933b			 
933b			        ;inc  hl   ; negate next move. move back to size  
933b			 
933b			.newblock: 
933b				; need to be at marker here 
933b			 
933b					if DEBUG_FORTH_MALLOC_INT 
933b						DMARK "meN" 
933b						CALLMONITOR 
933b					endif 
933b			 
933b			 
933b				ld a, c 
933b			 
933b				ld (free_list+3), a	 ; flag resume from last malloc  
933b				ld (free_list), hl    ; save out last location 
933b			 
933b			 
933b				;inc a     ; space for length byte 
933b				ld (hl), a     ; save block in use marker 
933b			 
933b				inc hl   ; move to space marker 
933b				ld (hl), a    ; save new space 
933b			 
933b				inc hl   ; move to start of allocated area 
933b				 
933b			;	push hl     ; save where we are - 1  
933b			 
933b			;	inc hl  ; move past zero index  
933b				; skip space to set down new marker 
933b			 
933b				; provide some extra space for now 
933b			 
933b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
933b				inc a 
933b				inc a 
933b			 
933b				push hl   ; save where we are in the node block 
933b			 
933b				call addatohl 
933b			 
933b				; write linked list point 
933b			 
933b				pop de     ; get our node position 
933b				ex de, hl 
933b			 
933b				ld (hl), e 
933b				inc hl 
933b				ld (hl), d 
933b			 
933b				inc hl 
933b			 
933b				; now at start of allocated data so save pointer 
933b			 
933b				push hl 
933b			 
933b				; jump to position of next node and setup empty header in DE 
933b			 
933b				ex de, hl 
933b			 
933b			;	inc hl ; move past end of block 
933b			 
933b				ld a, 0 
933b				ld (hl), a   ; empty marker 
933b				inc hl 
933b				ld (hl), a   ; size 
933b				inc hl  
933b				ld (hl), a   ; ptr 
933b				inc hl 
933b				ld (hl), a   ; ptr 
933b			 
933b			 
933b				pop hl 
933b			 
933b					if DEBUG_FORTH_MALLOC_INT 
933b						DMARK "mmr" 
933b						CALLMONITOR 
933b					endif 
933b			 
933b			.exit: 
933b				pop af 
933b				pop bc 
933b				pop de  
933b				ret 
933b			 
933b			 
933b			 
933b			 
933b			free:  
933b				push hl 
933b				push af 
933b				; get address in hl 
933b			 
933b					if DEBUG_FORTH_MALLOC_INT 
933b						DMARK "fre" 
933b						CALLMONITOR 
933b					endif 
933b				; data is at hl - move to block count 
933b				dec hl 
933b				dec hl    ; get past pointer 
933b				dec hl 
933b			 
933b				ld a, (hl)    ; need this for a validation check 
933b			 
933b				dec hl    ; move to block marker 
933b			 
933b				; now check that the block count and block marker are the same  
933b			        ; this checks that we are on a malloc node and not random memory 
933b			        ; OK a faint chance this could be a problem but rare - famous last words! 
933b			 
933b				ld c, a 
933b				ld a, (hl)    
933b			 
933b				cp c 
933b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
933b			 
933b				; yes good chance we are on a malloc node 
933b			 
933b				ld a, 0      
933b				ld (hl), a   ; mark as free 
933b			 
933b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
933b			 
933b			.freeignore:  
933b			 
933b				pop af 
933b				pop hl 
933b			 
933b				ret 
933b			 
933b			 
933b			 
933b			endif 
933b			 
933b			; eof 
# End of file firmware_memory.asm
933b			  
933b			; device C  
933b			; Now handled by SPI  
933b			;if SOUND_ENABLE  
933b			;	include "firmware_sound.asm"  
933b			;endif  
933b			  
933b			include "firmware_diags.asm"  
933b			; Hardware diags menu 
933b			 
933b			 
933b			config: 
933b			 
933b 3e 00			ld a, 0 
933d 21 61 93			ld hl, .configmn 
9340 cd df 8a			call menu 
9343			 
9343 fe 00			cp 0 
9345 c8				ret z 
9346			 
9346			;	cp 1 
9346			;	call z, .savetostore 
9346			 
9346 fe 01			cp 1 
9348			if STARTUP_V1 
9348 cc 77 93			call z, .selautoload 
934b			endif 
934b			 
934b			if STARTUP_V2 
934b				call z, .enautoload 
934b			endif 
934b fe 02			cp 2 
934d cc 6d 93			call z, .disautoload 
9350			;	cp 3 
9350			;	call z, .selbank 
9350 fe 03			cp 3 
9352 cc 95 93			call z, .debug_tog 
9355 fe 04			cp 4 
9357 cc e3 94			call z, .bpsgo 
935a fe 05			cp 5 
935c cc be 93			call z, hardware_diags 
935f			if STARTUP_V2 
935f				cp 6 
935f				call z, create_startup 
935f			endif 
935f 18 da			jr config 
9361			 
9361			.configmn: 
9361			;	dw prom_c3 
9361 d1 96			dw prom_c2 
9363 e6 96			dw prom_c2a 
9365			;	dw prom_c2b 
9365			;	dw prom_c4 
9365 05 97			dw prom_m4 
9367 20 97			dw prom_m4b 
9369 28 97			dw prom_c1 
936b			if STARTUP_V2 
936b				dw prom_c9 
936b			endif 
936b 00 00			dw 0 
936d				 
936d			 
936d			if STARTUP_V2 
936d			.enautoload: 
936d				if STORAGE_SE 
936d				ld a, $fe      ; bit 0 clear 
936d				ld (spi_device), a 
936d			 
936d				call storage_get_block_0 
936d			 
936d				ld a, 1 
936d				ld (store_page+STORE_0_AUTOFILE), a 
936d			 
936d					ld hl, 0 
936d					ld de, store_page 
936d				call storage_write_block	 ; save update 
936d				else 
936d			 
936d				ld hl, prom_notav 
936d				ld de, prom_empty 
936d				call info_panel 
936d				endif 
936d			 
936d			 
936d				ret 
936d			endif 
936d			 
936d			.disautoload: 
936d				if STORAGE_SE 
936d				ld a, $fe      ; bit 0 clear 
936d				ld (spi_device), a 
936d			 
936d				call storage_get_block_0 
936d			 
936d				ld a, 0 
936d				ld (store_page+STORE_0_AUTOFILE), a 
936d			 
936d					ld hl, 0 
936d					ld de, store_page 
936d				call storage_write_block	 ; save update 
936d				else 
936d			 
936d 21 37 97			ld hl, prom_notav 
9370 11 4d 97			ld de, prom_empty 
9373 cd 3f 8a			call info_panel 
9376				endif 
9376			 
9376			 
9376 c9				ret 
9377			 
9377			if STARTUP_V1 
9377			 
9377			; Select auto start 
9377			 
9377			.selautoload: 
9377			 
9377				 
9377				if STORAGE_SE 
9377			 
9377					call config_dir 
9377				        ld hl, scratch 
9377					ld a, 0 
9377					call menu 
9377			 
9377					cp 0 
9377					ret z 
9377			 
9377					dec a 
9377			 
9377			 
9377					; locate menu option 
9377			 
9377					ld hl, scratch 
9377					call table_lookup 
9377			 
9377					if DEBUG_FORTH_WORDS 
9377						DMARK "ALl" 
9377						CALLMONITOR 
9377					endif 
9377					; with the pointer to the menu it, the byte following the zero term is the file id 
9377			 
9377					ld a, 0 
9377					ld bc, 50   ; max of bytes to look at 
9377					cpir  
9377			 
9377					if DEBUG_FORTH_WORDS 
9377						DMARK "ALb" 
9377						CALLMONITOR 
9377					endif 
9377					;inc hl 
9377			 
9377					ld a, (hl)   ; file id 
9377					 
9377				        ; save bank and file ids 
9377			 
9377					push af 
9377			 
9377			; TODO need to save to block 0 on bank 1	 
9377			 
9377					call storage_get_block_0 
9377			 
9377					if DEBUG_FORTH_WORDS 
9377						DMARK "AL0" 
9377						CALLMONITOR 
9377					endif 
9377					pop af 
9377			 
9377					ld (store_page+STORE_0_FILERUN),a 
9377					 
9377					; save bank id 
9377			 
9377					ld a,(spi_device) 
9377					ld (store_page+STORE_0_BANKRUN),a 
9377			 
9377					; enable auto run of store file 
9377			 
9377					ld a, 1 
9377					ld (store_page+STORE_0_AUTOFILE),a 
9377			 
9377					; save buffer 
9377			 
9377					ld hl, 0 
9377					ld de, store_page 
9377					if DEBUG_FORTH_WORDS 
9377						DMARK "ALw" 
9377						CALLMONITOR 
9377					endif 
9377				call storage_write_block	 ; save update 
9377			  
9377			 
9377			 
9377			 
9377					ld hl, scratch 
9377					call config_fdir 
9377			 
9377				else 
9377			 
9377 21 37 97			ld hl, prom_notav 
937a 11 4d 97			ld de, prom_empty 
937d cd 3f 8a			call info_panel 
9380			 
9380				endif 
9380 c9				ret 
9381			endif 
9381			 
9381			 
9381			; Select storage bank 
9381			 
9381			.selbank: 
9381			 
9381			;	if STORAGE_SE 
9381			;	else 
9381			 
9381 21 37 97			ld hl, prom_notav 
9384 11 4d 97			ld de, prom_empty 
9387 cd 3f 8a			call info_panel 
938a			;	endif 
938a				 
938a c9				ret 
938b			 
938b			if STORAGE_SE 
938b			 
938b			.config_ldir:   
938b				; Load storage bank labels into menu array 
938b			 
938b				 
938b			 
938b			 
938b				ret 
938b			 
938b			 
938b			endif 
938b			 
938b			 
938b			; Save user words to storage 
938b			 
938b			.savetostore: 
938b			 
938b			;	if STORAGE_SE 
938b			; 
938b			;		call config_dir 
938b			;	        ld hl, scratch 
938b			;		ld a, 0 
938b			;		call menu 
938b			;		 
938b			;		ld hl, scratch 
938b			;		call config_fdir 
938b			; 
938b			;	else 
938b			 
938b 21 37 97			ld hl, prom_notav 
938e 11 4d 97			ld de, prom_empty 
9391 cd 3f 8a			call info_panel 
9394			 
9394			;	endif 
9394			 
9394 c9				ret 
9395			 
9395			if STARTUP_V2 
9395			 
9395			create_startup: 
9395			 
9395				ld a, 0 
9395				ld hl, .crstart 
9395				call menu 
9395			 
9395				cp 0 
9395				ret z 
9395			 
9395				cp 1 
9395				call z, .genlsword 
9395				cp 2 
9395				call z, .genedword 
9395			 
9395				cp 3 
9395				call z, .gendemword 
9395			 
9395				cp 4 
9395				call z, .genutlword 
9395				cp 5 
9395				call z, .genspiword 
9395				cp 6 
9395				call z, .genkeyword 
9395				cp 7 
9395				call z, .gensoundword 
9395				jr create_startup 
9395			 
9395			.gensoundword: 
9395				ld hl, crs_sound 
9395				ld de, .soundworddef 
9395				call .genfile 
9395				ret 
9395			.genlsword: 
9395				ld hl, crs_s1 
9395				ld de, .lsworddef 
9395				call .genfile 
9395				ret 
9395			 
9395			.genedword: 
9395				ld de, .edworddef 
9395				ld hl, crs_s2 
9395				call .genfile 
9395				ret 
9395			 
9395			.gendemword: 
9395				ld de, .demoworddef 
9395				ld hl, crs_s3 
9395				call .genfile 
9395				ret 
9395			 
9395			.genutlword: 
9395				ld hl, crs_s4 
9395				ld de, .utilwordef 
9395				call .genfile 
9395				ret 
9395			.genspiword: 
9395				ld hl, crs_s5 
9395				ld de, .spiworddef 
9395				call .genfile 
9395				ret 
9395			.genkeyword: 
9395				ld hl, crs_s6 
9395				ld de, .keyworddef 
9395				call .genfile 
9395				ret 
9395			 
9395			; hl - points to file name 
9395			; de - points to strings to add to file 
9395			 
9395			.genfile: 
9395				push hl 
9395				push de 
9395			 
9395				call clear_display 
9395				ld a, display_row_1 
9395				ld de, .genfiletxt 
9395				call str_at_display 
9395				call update_display 
9395			 
9395				pop de 
9395				pop hl 
9395			 
9395			 
9395				push de 
9395				call storage_create 
9395				; id in hl 
9395				pop de   ; table of strings to add 
9395			 
9395			.genloop: 
9395			 
9395				push hl ; save id for next time around 
9395				push de ; save de for next time around 
9395			 
9395				ex de, hl 
9395				call loadwordinhl 
9395				ex de, hl 
9395			 
9395				; need hl to be the id 
9395				; need de to be the string ptr 
9395				 
9395				call storage_append 
9395			 
9395				pop de 
9395				pop hl 
9395			 
9395				inc de 
9395				inc de 
9395			 
9395				ld a,(de) 
9395				cp 0 
9395				jr nz, .genloop 
9395				inc de 
9395				ld a, (de) 
9395				dec de 
9395				cp 0 
9395				jr nz, .genloop	 
9395			 
9395				ret 
9395			 
9395			.genfiletxt:  db "Creating file...",0 
9395			 
9395			.soundworddef: 
9395				dw sound1 
9395				dw sound2 
9395				dw sound3 
9395				dw sound4 
9395				dw sound5 
9395				dw sound6 
9395				dw sound7 
9395				dw sound8 
9395				dw sound9 
9395				dw 0 
9395			 
9395			.utilwordef: 
9395				dw strncpy 
9395				dw type 
9395				dw clrstack 
9395				dw longread 
9395				dw start1 
9395				dw start2 
9395				dw start3b 
9395				dw start3c 
9395				dw list 
9395				dw 0 
9395			 
9395			.lsworddef: 
9395				dw start3b 
9395				dw 0 
9395			 
9395			.edworddef: 
9395				dw edit1 
9395				dw edit2 
9395				dw edit3 
9395				dw 0 
9395			 
9395			.demoworddef: 
9395				dw test5 
9395				dw test6 
9395				dw test7 
9395				dw test8 
9395				dw test9 
9395				dw test10 
9395				dw game1 
9395				dw game1a 
9395				dw game1b 
9395				dw game1c 
9395				dw game1d 
9395				dw game1s 
9395				dw game1t 
9395				dw game1f 
9395				dw game1z 
9395				dw game1zz 
9395				dw ssv2 
9395				dw ssv3 
9395				dw ssv4 
9395				dw ssv5 
9395				dw ssv1 
9395				dw ssv1cpm	 
9395				dw game2b 
9395				dw game2bf 
9395				dw game2mba 
9395				dw game2mbas	 
9395				dw game2mbht 
9395				dw game2mbms 
9395				dw game2mb 
9395				dw game3w 
9395				dw game3p 
9395				dw game3sc 
9395				dw game3vsi 
9395				dw game3vs 
9395				dw 0 
9395			 
9395			 
9395			.spiworddef: 
9395			 
9395			    dw spi1 
9395			    dw spi2 
9395			    dw spi3 
9395			    dw spi4 
9395			    dw spi5 
9395			    dw spi6 
9395			    dw spi7 
9395			 
9395			    dw spi8 
9395			    dw spi9 
9395			    dw spi10 
9395			    dw 0 
9395			 
9395			.keyworddef: 
9395			 
9395				dw keyup 
9395				dw keydown 
9395				dw keyleft 
9395				dw keyright 
9395				dw 	keyf1 
9395				dw keyf2 
9395				dw keyf3 
9395				dw keyf4 
9395				dw keyf5 
9395				dw keyf6 
9395				dw keyf7 
9395				dw keyf8 
9395				dw keyf9 
9395				dw keyf10 
9395				dw keyf11 
9395				dw keyf12 
9395				dw keytab 
9395				dw keycr 
9395				dw keyhome 
9395				dw keyend 
9395				dw keybs 
9395				dw 0 
9395			 
9395			.crstart: 
9395				dw crs_s1 
9395				dw crs_s2 
9395				dw crs_s3 
9395				dw crs_s4 
9395				dw crs_s5 
9395				dw crs_s6 
9395				dw crs_sound 
9395				dw 0 
9395			 
9395			endif 
9395			 
9395			 
9395			if STORAGE_SE 
9395			 
9395			config_fdir: 
9395				; using the scratch dir go through and release the memory allocated for each string 
9395				 
9395				ld hl, scratch 
9395			.cfdir:	ld e,(hl) 
9395				inc hl 
9395				ld d,(hl) 
9395				inc hl 
9395			 
9395				ex de, hl 
9395				call ishlzero 
9395				ret z     ; return on null pointer 
9395				call free 
9395				ex de, hl 
9395				jr .cfdir 
9395			 
9395			 
9395				ret 
9395			 
9395			 
9395			config_dir: 
9395			 
9395				; for the config menus that need to build a directory of storage call this routine 
9395				; it will construct a menu in scratch to pass to menu 
9395			 
9395				; open storage device 
9395			 
9395				; execute DIR to build a list of files and their ids into scratch in menu format 
9395				; once the menu has finished then will need to call config_fdir to release the strings 
9395				 
9395				; c = number items 
9395			 
9395				 
9395				call storage_get_block_0 
9395			 
9395				ld hl, store_page     ; get current id count 
9395				ld b, (hl) 
9395				ld c, 0    ; count of files   
9395			 
9395			 
9395				ld hl, scratch 
9395				ld (store_tmp2), hl    ; location to poke strings 
9395			 
9395				; check for empty drive 
9395			 
9395				ld a, 0 
9395				cp b 
9395				jp z, .dirdone 
9395			 
9395				 
9395					if DEBUG_FORTH_WORDS 
9395						DMARK "Cdc" 
9395						CALLMONITOR 
9395					endif 
9395			 
9395			 
9395			.diritem:	 
9395				push bc 
9395				; for each of the current ids do a search for them and if found push to stack 
9395			 
9395					ld hl, STORE_BLOCK_PHY 
9395					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9395					ld e,b 
9395			 
9395					call storage_findnextid 
9395			 
9395			 
9395					; if found hl will be non zero 
9395			 
9395					call ishlzero 
9395					jr z, .dirnotfound 
9395			 
9395					; increase count 
9395			 
9395					pop bc	 
9395					inc c 
9395					push bc 
9395					 
9395			 
9395					; get file header and push the file name 
9395			 
9395					ld de, store_page 
9395					call storage_read_block 
9395			 
9395					; push file id to stack 
9395				 
9395					ld a, (store_page) 
9395					ld h, 0 
9395					ld l, a 
9395			 
9395					;call forth_push_numhl 
9395					; TODO store id 
9395			 
9395					push hl 
9395			 
9395					; push extent count to stack  
9395				 
9395					ld hl, store_page+3 
9395			 
9395					; get file name length 
9395			 
9395					call strlenz   
9395			 
9395					inc hl   ; cover zero term 
9395					inc hl  ; stick the id at the end of the area 
9395			 
9395					push hl 
9395					pop bc    ; move length to bc 
9395			 
9395					call malloc 
9395			 
9395					; TODO save malloc area to scratch 
9395			 
9395					ex de, hl 
9395					ld hl, (store_tmp2) 
9395					ld (hl), e 
9395					inc hl 
9395					ld (hl), d 
9395					inc hl 
9395					ld (store_tmp2), hl 
9395			 
9395					 
9395			 
9395					;pop hl   ; get source 
9395			;		ex de, hl    ; swap aronund	 
9395			 
9395					ld hl, store_page+3 
9395					if DEBUG_FORTH_WORDS 
9395						DMARK "CFd" 
9395						CALLMONITOR 
9395					endif 
9395					ldir 
9395			 
9395					; de is past string, move back one and store id 
9395					 
9395					dec de 
9395			 
9395					; store file id 
9395			 
9395					pop hl 
9395					ex de,hl 
9395					ld (hl), e 
9395			 
9395					if DEBUG_FORTH_WORDS 
9395						DMARK "Cdi" 
9395						CALLMONITOR 
9395					endif 
9395					 
9395			.dirnotfound: 
9395					pop bc     
9395					djnz .diritem 
9395				 
9395			.dirdone:	 
9395			 
9395					ld a, 0 
9395					ld hl, (store_tmp2) 
9395					ld (hl), a 
9395					inc hl 
9395					ld (hl), a 
9395					inc hl 
9395					; push a count of the dir items found 
9395			 
9395			;		ld h, 0 
9395			;		ld l, c 
9395			 
9395				ret 
9395			 
9395			endif 
9395			 
9395			 
9395			; Settings 
9395			; Run  
9395			 
9395			 
9395			 
9395			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9395			;;hd_menu2:   db "        2: Editor",0   
9395			;hd_menu2:   db "        2: Editor       6: Menu",0   
9395			;hd_menu3:   db "        3: Storage",0 
9395			;hd_menu4:   db "0=quit  4: Debug",0 
9395			;hd_don:     db "ON",0 
9395			;hd_doff:     db "OFF",0 
9395			; 
9395			; 
9395			; 
9395			;hardware_diags_old:       
9395			; 
9395			;.diagmenu: 
9395			;	call clear_display 
9395			;	ld a, display_row_1 
9395			;	ld de, hd_menu1 
9395			;	call str_at_display 
9395			; 
9395			;	ld a, display_row_2 
9395			;	ld de, hd_menu2 
9395			;	call str_at_display 
9395			; 
9395			;	ld a, display_row_3 
9395			;	ld de, hd_menu3 
9395			;	call str_at_display 
9395			; 
9395			;	ld a,  display_row_4 
9395			;	ld de, hd_menu4 
9395			;	call str_at_display 
9395			; 
9395			;	; display debug state 
9395			; 
9395			;	ld de, hd_don 
9395			;	ld a, (os_view_disable) 
9395			;	cp 0 
9395			;	jr z, .distog 
9395			;	ld de, hd_doff 
9395			;.distog: ld a, display_row_4+17 
9395			;	call str_at_display 
9395			; 
9395			;	call update_display 
9395			; 
9395			;	call cin_wait 
9395			; 
9395			; 
9395			; 
9395			;	cp '4' 
9395			;	jr nz, .diagn1 
9395			; 
9395			;	; debug toggle 
9395			; 
9395			;	ld a, (os_view_disable) 
9395			;	ld b, '*' 
9395			;	cp 0 
9395			;	jr z, .debtog 
9395			;	ld b, 0 
9395			;.debtog:	 
9395			;	ld a,b 
9395			;	ld (os_view_disable),a 
9395			; 
9395			;.diagn1: cp '0' 
9395			;	 ret z 
9395			; 
9395			;;	cp '1' 
9395			;;       jp z, matrix	 
9395			;;   TODO keyboard matrix test 
9395			; 
9395			;	cp '2' 
9395			;	jp z, .diagedit 
9395			; 
9395			;;	cp '6' 
9395			;;	jp z, .menutest 
9395			;;if ENABLE_BASIC 
9395			;;	cp '6' 
9395			;;	jp z, basic 
9395			;;endif 
9395			 ; 
9395			;	jp .diagmenu 
9395			; 
9395			; 
9395			;	ret 
9395			 
9395			 
9395			.debug_tog: 
9395 21 df 93			ld hl, .menudebug 
9398				 
9398			;	ld a, (os_view_disable) 
9398			;	cp '*' 
9398 3a 6f ee			ld a,(debug_vector) 
939b fe c9			cp $C9   ; RET 
939d 20 04			jr nz,.tdon  
939f 3e 01			ld a, 1 
93a1 18 02			jr .tog1 
93a3 3e 00		.tdon: ld a, 0 
93a5			 
93a5			.tog1: 
93a5 cd df 8a			call menu 
93a8 fe 00			cp 0 
93aa c8				ret z 
93ab fe 01			cp 1    ; disable debug 
93ad 28 04			jr z, .dtog0 
93af 3e 2a			ld a, '*' 
93b1 18 05			jr .dtogset 
93b3			.dtog0:  
93b3				;ld a, 0 
93b3 cd d1 94			call bp_on 
93b6 18 dd			jr .debug_tog 
93b8			.dtogset:  
93b8				; ld (os_view_disable), a 
93b8 cd dd 94			call bp_off 
93bb c3 95 93			jp .debug_tog 
93be			 
93be			 
93be			hardware_diags:       
93be			 
93be			.diagm: 
93be 21 d1 93			ld hl, .menuitems 
93c1 3e 00			ld a, 0 
93c3 cd df 8a			call menu 
93c6			 
93c6 fe 00		         cp 0 
93c8 c8				 ret z 
93c9			 
93c9 fe 02			cp 2 
93cb ca 2a 94			jp z, .diagedit 
93ce			 
93ce			;	cp '6' 
93ce			;	jp z, .menutest 
93ce			;if ENABLE_BASIC 
93ce			;	cp '6' 
93ce			;	jp z, basic 
93ce			;endif 
93ce			  
93ce c3 be 93			jp .diagm 
93d1			 
93d1				 
93d1 e5 93		.menuitems:   	dw .m1 
93d3 f0 93				dw .m2 
93d5 f7 93				dw .m3 
93d7 ff 93				dw .m5 
93d9 05 94				dw .m5a 
93db 0e 94				dw .m5b 
93dd 00 00				dw 0 
93df			 
93df			.menudebug: 
93df 17 94				dw .m6 
93e1 20 94				dw .m7 
93e3 00 00				dw 0 
93e5			 
93e5 .. 00		.m1:   db "Key Matrix",0 
93f0 .. 00		.m2:   db "Editor",0 
93f7 .. 00		.m3:   db "Storage",0 
93ff .. 00		.m5:   db "Sound",0 
9405 .. 00		.m5a:  db "RAM Test",0 
940e .. 00		.m5b:  db "LCD Test",0 
9417			 
9417 .. 00		.m6:   db "Debug ON",0 
9420 .. 00		.m7:   db "Debug OFF",0 
942a			 
942a			; debug editor 
942a			 
942a			.diagedit: 
942a			 
942a 21 c1 e2			ld hl, scratch 
942d			;	ld bc, 250 
942d			;	ldir 
942d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
942d 3e 00			ld a, 0 
942f 77				ld (hl), a 
9430 23				inc hl 
9431 77				ld (hl), a 
9432 23				inc hl 
9433 77				ld (hl), a 
9434			 
9434 cd ae 8a		        call clear_display 
9437 cd d1 8a			call update_display 
943a				;ld a, 1 
943a				;ld (hardware_diag), a 
943a			.diloop: 
943a 3e 00			ld a, display_row_1 
943c 0e 00			ld c, 0 
943e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9440 1e 28			ld e, 40 
9442			 
9442 21 c1 e2			ld hl, scratch	 
9445 cd 08 8d			call input_str 
9448			 
9448 3e 28			ld a, display_row_2 
944a 11 c1 e2			ld de, scratch 
944d cd c1 8a			call str_at_display 
9450 cd d1 8a			call update_display 
9453			 
9453 c3 3a 94			jp .diloop 
9456			 
9456			 
9456			; pass word in hl 
9456			; a has display location 
9456			display_word_at: 
9456 f5				push af 
9457 e5				push hl 
9458 7c				ld a,h 
9459 21 c6 e5			ld hl, os_word_scratch 
945c cd dc 8f			call hexout 
945f e1				pop hl 
9460 7d				ld a,l 
9461 21 c8 e5			ld hl, os_word_scratch+2 
9464 cd dc 8f			call hexout 
9467 21 ca e5			ld hl, os_word_scratch+4 
946a 3e 00			ld a,0 
946c 77				ld (hl),a 
946d 11 c6 e5			ld de,os_word_scratch 
9470 f1				pop af 
9471 cd c1 8a				call str_at_display 
9474 c9				ret 
9475			 
9475			display_ptr_state: 
9475			 
9475				; to restore afterwards 
9475			 
9475 d5				push de 
9476 c5				push bc 
9477 e5				push hl 
9478 f5				push af 
9479			 
9479				; for use in here 
9479			 
9479			;	push bc 
9479			;	push de 
9479			;	push hl 
9479			;	push af 
9479			 
9479 cd ae 8a			call clear_display 
947c			 
947c 11 54 96			ld de, .ptrstate 
947f 3e 00			ld a, display_row_1 
9481 cd c1 8a			call str_at_display 
9484			 
9484				; display debug step 
9484			 
9484			 
9484 11 6b ee			ld de, debug_mark 
9487 3e 26			ld a, display_row_1+display_cols-2 
9489 cd c1 8a			call str_at_display 
948c			 
948c				; display a 
948c 11 5e 96			ld de, .ptrcliptr 
948f 3e 28			ld a, display_row_2 
9491 cd c1 8a			call str_at_display 
9494			 
9494 f1				pop af 
9495 2a 40 ea			ld hl,(cli_ptr) 
9498 3e 30			ld a, display_row_2+8 
949a cd 56 94			call display_word_at 
949d			 
949d			 
949d				; display hl 
949d			 
949d			 
949d 11 66 96			ld de, .ptrclioptr 
94a0 3e 32			ld a, display_row_2+10 
94a2 cd c1 8a			call str_at_display 
94a5			; 
94a5			;	pop hl 
94a5 3e 35			ld a, display_row_2+13 
94a7 2a 3e ea			ld hl,(cli_origptr) 
94aa cd 56 94			call display_word_at 
94ad			; 
94ad			;	 
94ad			;	; display de 
94ad			 
94ad			;	ld de, .regstatede 
94ad			;	ld a, display_row_3 
94ad			;	call str_at_display 
94ad			 
94ad			;	pop de 
94ad			;	ld h,d 
94ad			;	ld l, e 
94ad			;	ld a, display_row_3+3 
94ad			;	call display_word_at 
94ad			 
94ad			 
94ad				; display bc 
94ad			 
94ad			;	ld de, .regstatebc 
94ad			;	ld a, display_row_3+10 
94ad			;	call str_at_display 
94ad			 
94ad			;	pop bc 
94ad			;	ld h,b 
94ad			;	ld l, c 
94ad			;	ld a, display_row_3+13 
94ad			;	call display_word_at 
94ad			 
94ad			 
94ad				; display dsp 
94ad			 
94ad			;	ld de, .regstatedsp 
94ad			;	ld a, display_row_4 
94ad			;	call str_at_display 
94ad			 
94ad				 
94ad			;	ld hl,(cli_data_sp) 
94ad			;	ld a, display_row_4+4 
94ad			;	call display_word_at 
94ad			 
94ad				; display rsp 
94ad			 
94ad 11 95 96			ld de, .regstatersp 
94b0 3e 82			ld a, display_row_4+10 
94b2 cd c1 8a			call str_at_display 
94b5			 
94b5				 
94b5 2a f2 e9			ld hl,(cli_ret_sp) 
94b8 3e 86			ld a, display_row_4+14 
94ba cd 56 94			call display_word_at 
94bd			 
94bd cd d1 8a			call update_display 
94c0			 
94c0 cd f1 89			call delay1s 
94c3 cd f1 89			call delay1s 
94c6 cd f1 89			call delay1s 
94c9			 
94c9			 
94c9 cd b3 9a			call next_page_prompt 
94cc			 
94cc				; restore  
94cc			 
94cc f1				pop af 
94cd e1				pop hl 
94ce c1				pop bc 
94cf d1				pop de 
94d0 c9				ret 
94d1			 
94d1			; Update the break point vector so that the user can hook a new routine 
94d1			 
94d1			bp_on: 
94d1 3e c3			ld a, $c3    ; JP 
94d3 32 6f ee			ld (debug_vector), a 
94d6 21 e3 94			ld hl, break_point_state 
94d9 22 70 ee			ld (debug_vector+1), hl 
94dc c9				ret 
94dd			 
94dd			bp_off: 
94dd 3e c9			ld a, $c9    ; RET 
94df 32 6f ee			ld (debug_vector), a 
94e2 c9				ret 
94e3			 
94e3			 
94e3			break_point_state: 
94e3			;	push af 
94e3			; 
94e3			;	; see if disabled 
94e3			; 
94e3			;	ld a, (os_view_disable) 
94e3			;	cp '*' 
94e3			;	jr nz, .bpsgo 
94e3			;	pop af 
94e3			;	ret 
94e3			 
94e3			.bpsgo: 
94e3			;	pop af 
94e3 f5				push af 
94e4 22 a3 e2			ld (os_view_hl), hl 
94e7 ed 53 a1 e2		ld (os_view_de), de 
94eb ed 43 9f e2		ld (os_view_bc), bc 
94ef e5				push hl 
94f0 6f				ld l, a 
94f1 26 00			ld h, 0 
94f3 22 a5 e2			ld (os_view_af),hl 
94f6			 
94f6 21 b1 ed				ld hl, display_fb0 
94f9 22 cc eb				ld (display_fb_active), hl 
94fc e1				pop hl	 
94fd			 
94fd 3e 31			ld a, '1' 
94ff fe 2a		.bps1:  cp '*' 
9501 cc dd 94			call z, bp_off 
9504			;	jr nz, .bps1b 
9504			;	ld (os_view_disable),a 
9504 fe 31		.bps1b:  cp '1' 
9506 20 14			jr nz, .bps2 
9508			 
9508				; display reg 
9508			 
9508				 
9508			 
9508 3a a5 e2			ld a, (os_view_af) 
950b 2a a3 e2			ld hl, (os_view_hl) 
950e ed 5b a1 e2		ld de, (os_view_de) 
9512 ed 4b 9f e2		ld bc, (os_view_bc) 
9516 cd b0 95			call display_reg_state 
9519 c3 9c 95			jp .bpschk 
951c			 
951c fe 32		.bps2:  cp '2' 
951e 20 08			jr nz, .bps3 
9520				 
9520				; display hl 
9520 2a a3 e2			ld hl, (os_view_hl) 
9523 cd 9a 96			call display_dump_at_hl 
9526			 
9526 18 74			jr .bpschk 
9528			 
9528 fe 33		.bps3:  cp '3' 
952a 20 08			jr nz, .bps4 
952c			 
952c			        ; display de 
952c 2a a1 e2			ld hl, (os_view_de) 
952f cd 9a 96			call display_dump_at_hl 
9532			 
9532 18 68			jr .bpschk 
9534 fe 34		.bps4:  cp '4' 
9536 20 08			jr nz, .bps5 
9538			 
9538			        ; display bc 
9538 2a 9f e2			ld hl, (os_view_bc) 
953b cd 9a 96			call display_dump_at_hl 
953e			 
953e 18 5c			jr .bpschk 
9540 fe 35		.bps5:  cp '5' 
9542 20 08		        jr nz, .bps7 
9544			 
9544				; display cur ptr 
9544 2a 40 ea			ld hl, (cli_ptr) 
9547 cd 9a 96			call display_dump_at_hl 
954a			 
954a 18 50			jr .bpschk 
954c fe 36		.bps7:  cp '6' 
954e 20 08			jr nz, .bps8b 
9550				 
9550				; display cur orig ptr 
9550 2a 3e ea			ld hl, (cli_origptr) 
9553 cd 9a 96			call display_dump_at_hl 
9556 18 44			jr .bpschk 
9558 fe 37		.bps8b:  cp '7' 
955a 20 08			jr nz, .bps9 
955c				 
955c				; display dsp 
955c 2a ee e9			ld hl, (cli_data_sp) 
955f cd 9a 96			call display_dump_at_hl 
9562			 
9562 18 38			jr .bpschk 
9564 fe 39		.bps9:  cp '9' 
9566 20 05			jr nz, .bps8c 
9568				 
9568				; display SP 
9568			;	ld hl, sp 
9568 cd 9a 96			call display_dump_at_hl 
956b			 
956b 18 2f			jr .bpschk 
956d fe 38		.bps8c:  cp '8' 
956f 20 08			jr nz, .bps8d 
9571				 
9571				; display rsp 
9571 2a f2 e9			ld hl, (cli_ret_sp) 
9574 cd 9a 96			call display_dump_at_hl 
9577			 
9577 18 23			jr .bpschk 
9579 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
957b 20 05			jr nz, .bps8 
957d cd 81 98			call monitor 
9580			 
9580 18 1a			jr .bpschk 
9582 fe 30		.bps8:  cp '0' 
9584 20 16			jr nz, .bpschk 
9586			 
9586 21 10 ed				ld hl, display_fb1 
9589 22 cc eb				ld (display_fb_active), hl 
958c cd d1 8a				call update_display 
958f			 
958f				;ld a, (os_view_af) 
958f 2a a3 e2			ld hl, (os_view_hl) 
9592 ed 5b a1 e2		ld de, (os_view_de) 
9596 ed 4b 9f e2		ld bc, (os_view_bc) 
959a f1				pop af 
959b c9				ret 
959c			 
959c			.bpschk:   
959c cd f1 89			call delay1s 
959f 3e 9f		ld a,display_row_4 + display_cols - 1 
95a1 11 b1 9a		        ld de, endprg 
95a4 cd c1 8a			call str_at_display 
95a7 cd d1 8a			call update_display 
95aa cd 5c e4			call cin_wait 
95ad			 
95ad c3 ff 94			jp .bps1 
95b0			 
95b0			 
95b0			display_reg_state: 
95b0			 
95b0				; to restore afterwards 
95b0			 
95b0 d5				push de 
95b1 c5				push bc 
95b2 e5				push hl 
95b3 f5				push af 
95b4			 
95b4				; for use in here 
95b4			 
95b4 c5				push bc 
95b5 d5				push de 
95b6 e5				push hl 
95b7 f5				push af 
95b8			 
95b8 cd ae 8a			call clear_display 
95bb			 
95bb 11 70 96			ld de, .regstate 
95be 3e 00			ld a, display_row_1 
95c0 cd c1 8a			call str_at_display 
95c3			 
95c3				; display debug step 
95c3			 
95c3			 
95c3 11 6b ee			ld de, debug_mark 
95c6 3e 25			ld a, display_row_1+display_cols-3 
95c8 cd c1 8a			call str_at_display 
95cb			 
95cb				; display a 
95cb 11 8c 96			ld de, .regstatea 
95ce 3e 28			ld a, display_row_2 
95d0 cd c1 8a			call str_at_display 
95d3			 
95d3 e1				pop hl 
95d4			;	ld h,0 
95d4			;	ld l, a 
95d4 3e 2b			ld a, display_row_2+3 
95d6 cd 56 94			call display_word_at 
95d9			 
95d9			 
95d9				; display hl 
95d9			 
95d9			 
95d9 11 80 96			ld de, .regstatehl 
95dc 3e 32			ld a, display_row_2+10 
95de cd c1 8a			call str_at_display 
95e1			 
95e1 e1				pop hl 
95e2 3e 35			ld a, display_row_2+13 
95e4 cd 56 94			call display_word_at 
95e7			 
95e7				 
95e7				; display de 
95e7			 
95e7 11 84 96			ld de, .regstatede 
95ea 3e 50			ld a, display_row_3 
95ec cd c1 8a			call str_at_display 
95ef			 
95ef e1				pop hl 
95f0			;	ld h,d 
95f0			;	ld l, e 
95f0 3e 53			ld a, display_row_3+3 
95f2 cd 56 94			call display_word_at 
95f5			 
95f5			 
95f5				; display bc 
95f5			 
95f5 11 88 96			ld de, .regstatebc 
95f8 3e 5a			ld a, display_row_3+10 
95fa cd c1 8a			call str_at_display 
95fd			 
95fd e1				pop hl 
95fe			;	ld h,b 
95fe			;	ld l, c 
95fe 3e 5d			ld a, display_row_3+13 
9600 cd 56 94			call display_word_at 
9603			 
9603			 
9603				; display dsp 
9603			 
9603 11 90 96			ld de, .regstatedsp 
9606 3e 78			ld a, display_row_4 
9608 cd c1 8a			call str_at_display 
960b			 
960b				 
960b 2a ee e9			ld hl,(cli_data_sp) 
960e 3e 7c			ld a, display_row_4+4 
9610 cd 56 94			call display_word_at 
9613			 
9613				; display rsp 
9613			 
9613 11 95 96			ld de, .regstatersp 
9616 3e 82			ld a, display_row_4+10 
9618 cd c1 8a			call str_at_display 
961b			 
961b				 
961b 2a f2 e9			ld hl,(cli_ret_sp) 
961e 3e 86			ld a, display_row_4+14 
9620 cd 56 94			call display_word_at 
9623			 
9623 cd d1 8a			call update_display 
9626			 
9626			;	call delay1s 
9626			;	call delay1s 
9626			;	call delay1s 
9626			 
9626			 
9626			;	call next_page_prompt 
9626			 
9626				; restore  
9626			 
9626 f1				pop af 
9627 e1				pop hl 
9628 c1				pop bc 
9629 d1				pop de 
962a c9				ret 
962b			 
962b .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
963f .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9654 .. 00		.ptrstate:	db "Ptr State",0 
965e .. 00		.ptrcliptr:     db "cli_ptr",0 
9666 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9670 .. 00		.regstate:	db "Reg State (1/0)",0 
9680 .. 00		.regstatehl:	db "HL:",0 
9684 .. 00		.regstatede:	db "DE:",0 
9688 .. 00		.regstatebc:	db "BC:",0 
968c .. 00		.regstatea:	db "A :",0 
9690 .. 00		.regstatedsp:	db "DSP:",0 
9695 .. 00		.regstatersp:	db "RSP:",0 
969a			 
969a			display_dump_at_hl: 
969a e5				push hl 
969b d5				push de 
969c c5				push bc 
969d f5				push af 
969e			 
969e 22 e4 e5			ld (os_cur_ptr),hl	 
96a1 cd ae 8a			call clear_display 
96a4 cd bb 99			call dumpcont 
96a7			;	call delay1s 
96a7			;	call next_page_prompt 
96a7			 
96a7			 
96a7 f1				pop af 
96a8 c1				pop bc 
96a9 d1				pop de 
96aa e1				pop hl 
96ab c9				ret 
96ac			 
96ac			;if ENABLE_BASIC 
96ac			;	include "nascombasic.asm" 
96ac			;	basic: 
96ac			;	include "forth/FORTH.ASM" 
96ac			;endif 
96ac			 
96ac			; eof 
96ac			 
96ac			 
# End of file firmware_diags.asm
96ac			  
96ac			include "firmware_prompts.asm"  
96ac			; Prompts  
96ac			 
96ac			; boot messages 
96ac			 
96ac .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
96c1 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
96d1			 
96d1			 
96d1			; config menus 
96d1			 
96d1			;prom_c3: db "Add Dictionary To File",0 
96d1			 
96d1			if STARTUP_V1 
96d1 .. 00		prom_c2: db "Select Autoload File",0 
96e6 .. 00		prom_c2a: db "Disable Autoload File", 0 
96fc			endif 
96fc			 
96fc			if STARTUP_V2 
96fc			prom_c2: db "Enable Autoload Files",0 
96fc			prom_c2a: db "Disable Autoload Files", 0 
96fc			 
96fc			crs_s1: db "*ls-word", 0 
96fc			crs_s2: db "*ed-word", 0 
96fc			crs_s3: db "*Demo-Programs", 0 
96fc			crs_s4: db "*Utils", 0 
96fc			crs_s5: db "*SPI-Addons", 0 
96fc			crs_s6: db "*Key-constants", 0 
96fc			crs_sound: db "*Sound-Util", 0 
96fc			 
96fc			 
96fc			 
96fc			endif 
96fc			;prom_c2b: db "Select Storage Bank",0 
96fc .. 00		prom_c4: db "Settings",0 
9705 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9720 .. 00		prom_m4b:   db "Monitor",0 
9728 .. 00		prom_c1: db "Hardware Diags",0 
9737			 
9737			 
9737			if STARTUP_V2 
9737			prom_c9: db "Create Startup Files",0 
9737			endif 
9737			 
9737 .. 00		prom_notav:    db "Feature not available",0 
974d .. 00		prom_empty:    db "",0 
974e			 
974e			; eof 
974e			 
# End of file firmware_prompts.asm
974e			  
974e			  
974e			; eof  
974e			  
# End of file firmware.asm
974e			 
974e			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
974e			;if BASE_KEV  
974e			;baseram: equ 08000h 
974e			;endif 
974e			 
974e			;if BASE_SC114 
974e			;baseram:     equ    endofcode 
974e			;endif 
974e			 
974e			 
974e			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
974e			 
974e			; start system 
974e			 
974e			coldstart: 
974e				; set sp 
974e				; di/ei 
974e			 
974e f3				di 
974f 31 00 f0			ld sp, tos 
9752 cd a6 e3			call init_nmi 
9755			;	ei 
9755			 
9755				; init spinner 
9755 3e 00			ld a,0 
9757 32 c6 eb			ld (display_active), a 
975a			 
975a				; disable breakpoint by default 
975a			 
975a				;ld a,'*' 
975a			;	ld a,' ' 
975a			;	ld (os_view_disable),a 
975a			 
975a				; set break point vector as new break point on or off 
975a cd dd 94			call bp_off 
975d			 
975d				; init hardware 
975d			 
975d				; init keyboard and screen hardware 
975d			 
975d cd 1b 80			call hardware_init 
9760			 
9760			 
9760 cd f1 89			call delay1s 
9763 3e 58			ld a, display_row_3+8 
9765 11 03 80			ld de, buildtime 
9768 cd c1 8a			call str_at_display 
976b cd d1 8a			call update_display 
976e			 
976e cd f1 89			call delay1s 
9771 cd f1 89			call delay1s 
9774 cd f1 89			call delay1s 
9777			 
9777				; detect if any keys are held down to enable breakpoints at start up 
9777			 
9777 cd 62 e4			call cin  
977a fe 00			cp 0 
977c 28 03			jr z, .nokeys 
977e			 
977e				;call hardware_diags 
977e cd 3b 93			call config 
9781			 
9781			;	ld de, .bpen 
9781			;	ld a, display_row_4 
9781			;	call str_at_display 
9781			;	call update_display 
9781			; 
9781			;	ld a,0 
9781			;	ld (os_view_disable),a 
9781			; 
9781			;.bpwait: 
9781			;	call cin 
9781			;	cp 0 
9781			;	jr z, .bpwait 
9781			;	jr .nokeys 
9781			; 
9781			; 
9781			;.bpen:  db "Break points enabled!",0 
9781			 
9781			 
9781			 
9781			 
9781			 
9781			 
9781			.nokeys: 
9781			 
9781			 
9781				 
9781			 
9781			;jp  testkey 
9781			 
9781			;call storage_get_block_0 
9781			; 
9781			;ld hl, 0 
9781			;ld de, store_page 
9781			;call storage_read_block 
9781			 
9781				 
9781			;ld hl, 10 
9781			;ld de, store_page 
9781			;call storage_read_block 
9781			 
9781			 
9781			 
9781			 
9781			 
9781			;stop:	nop 
9781			;	jp stop 
9781			 
9781			 
9781			 
9781			main: 
9781 cd ae 8a			call clear_display 
9784 cd d1 8a			call update_display 
9787			 
9787			 
9787			 
9787			;	call testlcd 
9787			 
9787			 
9787			 
9787 cd b8 9e			call forth_init 
978a			 
978a			 
978a			warmstart: 
978a cd 8e 9e			call forth_warmstart 
978d			 
978d				; run startup word load 
978d			        ; TODO prevent this running at warmstart after crash  
978d			 
978d				if STARTUP_ENABLE 
978d			 
978d					if STARTUP_V1 
978d			 
978d						if STORAGE_SE 
978d							call forth_autoload 
978d						endif 
978d cd f6 e2					call forth_startup 
9790					endif 
9790			 
9790					if STARTUP_V2 
9790			 
9790						if STORAGE_SE 
9790							call forth_autoload 
9790						else 
9790							call forth_startup 
9790						endif 
9790			 
9790			 
9790					endif 
9790			 
9790				endif 
9790			 
9790				; show free memory after boot 
9790 11 1c 98			ld de, freeram 
9793 3e 00			ld a, display_row_1 
9795 cd c1 8a			call str_at_display 
9798			 
9798				; get current heap start after loading any uwords 
9798			 
9798				;ld de, (os_last_new_uword) 
9798				;ex de, hl 
9798			 
9798			; Or use heap_size word???? 
9798				;ld hl, heap_end 
9798				;ld hl, heap_size 
9798				;ld de, topusermem 
9798				;ld de, heap_start 
9798 ed 5b 7b e4			ld de, (free_list )      
979c 21 9c e2				ld hl, heap_end 
979f ed 52			sbc hl, de 
97a1				;push hl 
97a1				;ld a,h	         	 
97a1				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97a1				;call hexout 
97a1			   	;pop hl 
97a1			; 
97a1			;	ld a,l 
97a1			;	ld hl, os_word_scratch+2 
97a1			;	call hexout 
97a1			;	ld hl, os_word_scratch+4 
97a1			;	ld a, 0 
97a1			;	ld (hl),a 
97a1 eb				ex de, hl 
97a2 21 c6 e5			ld hl, os_word_scratch 
97a5 cd e8 90			call uitoa_16 
97a8			 
97a8			 
97a8 11 c6 e5			ld de, os_word_scratch 
97ab 3e 0d			ld a, display_row_1 + 13 
97ad cd c1 8a			call str_at_display 
97b0 cd d1 8a			call update_display 
97b3			 
97b3			 
97b3				;call demo 
97b3			 
97b3			 
97b3				; init scratch input area for cli commands 
97b3			 
97b3 21 e8 e5			ld hl, os_cli_cmd 
97b6 3e 00			ld a,0 
97b8 77				ld (hl),a 
97b9 23				inc hl 
97ba 77				ld (hl),a 
97bb			 
97bb 3e 00			ld a,0 
97bd 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97c0			 
97c0 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97c3 32 e5 e5			ld (os_cur_ptr+1),a	 
97c6			 
97c6 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97c9 32 c7 e5			ld (os_word_scratch+1),a	 
97cc				 
97cc			 
97cc				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97cc 21 e8 e5			ld hl, os_cli_cmd 
97cf			 
97cf 3e 00			ld a, 0		 ; init cli input 
97d1 77				ld (hl), a 
97d2 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97d4			cli: 
97d4				; show cli prompt 
97d4				;push af 
97d4				;ld a, 0 
97d4				;ld de, prompt 
97d4				;call str_at_display 
97d4			 
97d4				;call update_display 
97d4				;pop af 
97d4				;inc a 
97d4				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97d4 0e 00			ld c, 0 
97d6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97d8 1e 28			ld e, 40 
97da			 
97da 21 e8 e5			ld hl, os_cli_cmd 
97dd			 
97dd				STACKFRAME OFF $fefe $9f9f 
97dd				if DEBUG_STACK_IMB 
97dd					if OFF 
97dd						exx 
97dd						ld de, $fefe 
97dd						ld a, d 
97dd						ld hl, curframe 
97dd						call hexout 
97dd						ld a, e 
97dd						ld hl, curframe+2 
97dd						call hexout 
97dd						ld hl, $fefe 
97dd						push hl 
97dd						ld hl, $9f9f 
97dd						push hl 
97dd						exx 
97dd					endif 
97dd				endif 
97dd			endm 
# End of macro STACKFRAME
97dd			 
97dd cd 08 8d			call input_str 
97e0			 
97e0				STACKFRAMECHK OFF $fefe $9f9f 
97e0				if DEBUG_STACK_IMB 
97e0					if OFF 
97e0						exx 
97e0						ld hl, $9f9f 
97e0						pop de   ; $9f9f 
97e0						call cmp16 
97e0						jr nz, .spnosame 
97e0						ld hl, $fefe 
97e0						pop de   ; $fefe 
97e0						call cmp16 
97e0						jr z, .spfrsame 
97e0						.spnosame: call showsperror 
97e0						.spfrsame: nop 
97e0						exx 
97e0					endif 
97e0				endif 
97e0			endm 
# End of macro STACKFRAMECHK
97e0			 
97e0				; copy input to last command 
97e0			 
97e0 21 e8 e5			ld hl, os_cli_cmd 
97e3 11 e7 e6			ld de, os_last_cmd 
97e6 01 ff 00			ld bc, 255 
97e9 ed b0			ldir 
97eb			 
97eb				; wipe current buffer 
97eb			 
97eb			;	ld a, 0 
97eb			;	ld hl, os_cli_cmd 
97eb			;	ld de, os_cli_cmd+1 
97eb			;	ld bc, 254 
97eb			;	ldir 
97eb				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97eb			;	call strcpy 
97eb			;	ld a, 0 
97eb			;	ld (hl), a 
97eb			;	inc hl 
97eb			;	ld (hl), a 
97eb			;	inc hl 
97eb			;	ld (hl), a 
97eb			 
97eb				; switch frame buffer to program  
97eb			 
97eb 21 10 ed				ld hl, display_fb1 
97ee 22 cc eb				ld (display_fb_active), hl 
97f1			 
97f1			;	nop 
97f1				STACKFRAME ON $fbfe $8f9f 
97f1				if DEBUG_STACK_IMB 
97f1					if ON 
97f1						exx 
97f1						ld de, $fbfe 
97f1						ld a, d 
97f1						ld hl, curframe 
97f1						call hexout 
97f1						ld a, e 
97f1						ld hl, curframe+2 
97f1						call hexout 
97f1						ld hl, $fbfe 
97f1						push hl 
97f1						ld hl, $8f9f 
97f1						push hl 
97f1						exx 
97f1					endif 
97f1				endif 
97f1			endm 
# End of macro STACKFRAME
97f1				; first time into the parser so pass over the current scratch pad 
97f1 21 e8 e5			ld hl,os_cli_cmd 
97f4				; tokenise the entered statement(s) in HL 
97f4 cd 36 9f			call forthparse 
97f7			        ; exec forth statements in top of return stack 
97f7 cd 76 9f			call forthexec 
97fa				;call forthexec_cleanup 
97fa			;	call parsenext 
97fa			 
97fa				STACKFRAMECHK ON $fbfe $8f9f 
97fa				if DEBUG_STACK_IMB 
97fa					if ON 
97fa						exx 
97fa						ld hl, $8f9f 
97fa						pop de   ; $8f9f 
97fa						call cmp16 
97fa						jr nz, .spnosame 
97fa						ld hl, $fbfe 
97fa						pop de   ; $fbfe 
97fa						call cmp16 
97fa						jr z, .spfrsame 
97fa						.spnosame: call showsperror 
97fa						.spfrsame: nop 
97fa						exx 
97fa					endif 
97fa				endif 
97fa			endm 
# End of macro STACKFRAMECHK
97fa				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
97fa			 
97fa 3e 78			ld a, display_row_4 
97fc 11 2d 98			ld de, endprog 
97ff			 
97ff cd d1 8a			call update_display		 
9802			 
9802 cd b3 9a			call next_page_prompt 
9805			 
9805				; switch frame buffer to cli 
9805			 
9805 21 b1 ed				ld hl, display_fb0 
9808 22 cc eb				ld (display_fb_active), hl 
980b			 
980b			 
980b cd ae 8a		        call clear_display 
980e cd d1 8a			call update_display		 
9811			 
9811 21 e8 e5			ld hl, os_cli_cmd 
9814			 
9814 3e 00			ld a, 0		 ; init cli input 
9816 77				ld (hl), a 
9817			 
9817				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9817			 
9817				; now on last line 
9817			 
9817				; TODO scroll screen up 
9817			 
9817				; TODO instead just clear screen and place at top of screen 
9817			 
9817			;	ld a, 0 
9817			;	ld (f_cursor_ptr),a 
9817			 
9817				;call clear_display 
9817				;call update_display 
9817			 
9817				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9817 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9819 c3 d4 97			jp cli 
981c			 
981c .. 00		freeram: db "Free bytes: ",0 
9829 ..			asc: db "1A2F" 
982d .. 00		endprog: db "End prog...",0 
9839			 
9839			testenter2:   
9839 21 f3 e2			ld hl,scratch+50 
983c 22 e4 e5			ld (os_cur_ptr),hl 
983f c3 d4 97			jp cli 
9842			 
9842			testenter:  
9842			 
9842 21 29 98			ld hl,asc 
9845			;	ld a,(hl) 
9845			;	call nibble2val 
9845 cd 32 90			call get_byte 
9848			 
9848			 
9848			;	ld a,(hl) 
9848			;	call atohex 
9848			 
9848			;	call fourehexhl 
9848 32 f3 e2			ld (scratch+50),a 
984b			 
984b			 
984b			 
984b 21 2b 98			ld hl,asc+2 
984e			;	ld a, (hl) 
984e			;	call nibble2val 
984e cd 32 90			call get_byte 
9851			 
9851			;	call fourehexhl 
9851 32 f5 e2			ld (scratch+52),a 
9854				 
9854 21 f3 e2			ld hl,scratch+50 
9857 22 e4 e5			ld (os_cur_ptr),hl 
985a c3 d4 97			jp cli 
985d			 
985d			enter:	 
985d 3a c5 e2			ld a,(scratch+4) 
9860 fe 00			cp 0 
9862 28 0c			jr z, .entercont 
9864				; no, not a null term line so has an address to work out.... 
9864			 
9864 21 c3 e2			ld hl,scratch+2 
9867 cd 92 90			call get_word_hl 
986a			 
986a 22 e4 e5			ld (os_cur_ptr),hl	 
986d c3 d4 97			jp cli 
9870			 
9870			 
9870			.entercont:  
9870			 
9870 21 c3 e2			ld hl, scratch+2 
9873 cd 32 90			call get_byte 
9876			 
9876 2a e4 e5		   	ld hl,(os_cur_ptr) 
9879 77					ld (hl),a 
987a 23					inc hl 
987b 22 e4 e5				ld (os_cur_ptr),hl 
987e				 
987e			; get byte  
987e			 
987e			 
987e c3 d4 97			jp cli 
9881			 
9881			 
9881			; basic monitor support 
9881			 
9881			monitor: 
9881				;  
9881 cd ae 8a			call clear_display 
9884 3e 00			ld a, 0 
9886 11 d5 98			ld de, .monprompt 
9889 cd c1 8a			call str_at_display 
988c cd d1 8a			call update_display 
988f			 
988f				; get a monitor command 
988f			 
988f 0e 00			ld c, 0     ; entry at top left 
9891 16 64			ld d, 100   ; max buffer size 
9893 1e 0f			ld e, 15    ; input scroll area 
9895 3e 00			ld a, 0     ; init string 
9897 21 bf e4			ld hl, os_input 
989a 77				ld (hl), a 
989b 23				inc hl 
989c 77				ld (hl), a 
989d 21 bf e4			ld hl, os_input 
98a0 3e 01			ld a, 1     ; init string 
98a2 cd 08 8d			call input_str 
98a5			 
98a5 cd ae 8a		        call clear_display 
98a8 cd d1 8a			call update_display		 
98ab			 
98ab 3a bf e4			ld a, (os_input) 
98ae cd 30 91			call toUpper 
98b1 fe 48		        cp 'H' 
98b3 ca 3a 99		        jp z, .monhelp 
98b6 fe 44			cp 'D'		; dump 
98b8 ca 6d 99			jp z, .mondump	 
98bb fe 43			cp 'C'		; dump 
98bd ca 87 99			jp z, .moncdump	 
98c0 fe 4d			cp 'M'		; dump 
98c2 ca d7 98			jp z, .moneditstart 
98c5 fe 55			cp 'U'		; dump 
98c7 ca e3 98			jp z, .monedit	 
98ca fe 47			cp 'G'		; dump 
98cc ca 63 99			jp z, .monjump 
98cf fe 51			cp 'Q'		; dump 
98d1 c8				ret z	 
98d2			 
98d2			 
98d2				; TODO "S" to access symbol by name and not need the address 
98d2				; TODO "F" to find a string in memory 
98d2			 
98d2 c3 81 98			jp monitor 
98d5			 
98d5 .. 00		.monprompt: db ">", 0 
98d7			 
98d7			.moneditstart: 
98d7				; get starting address 
98d7			 
98d7 21 c1 e4			ld hl,os_input+2 
98da cd 92 90			call get_word_hl 
98dd			 
98dd 22 e4 e5			ld (os_cur_ptr),hl	 
98e0			 
98e0 c3 81 98			jp monitor 
98e3			 
98e3			.monedit: 
98e3				; get byte to load 
98e3			 
98e3 21 c1 e4			ld hl,os_input+2 
98e6 cd 32 90			call get_byte 
98e9			 
98e9				; get address to update 
98e9 2a e4 e5			ld hl, (os_cur_ptr) 
98ec			 
98ec				; update byte 
98ec			 
98ec 77				ld (hl), a 
98ed			 
98ed				; move to next address and save it 
98ed			 
98ed 23				inc hl 
98ee 22 e4 e5			ld (os_cur_ptr),hl	 
98f1			 
98f1 c3 81 98			jp monitor 
98f4			 
98f4			 
98f4 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9908 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9924 .. 00		.monhelptext3:  db "G-Call address",0 
9933 .. 00		.monhelptext4:  db "Q-Quit",0 
993a			        
993a			.monhelp: 
993a 3e 00			ld a, display_row_1 
993c 11 f4 98		        ld de, .monhelptext1 
993f			 
993f cd c1 8a			call str_at_display 
9942 3e 28			ld a, display_row_2 
9944 11 08 99		        ld de, .monhelptext2 
9947					 
9947 cd c1 8a			call str_at_display 
994a 3e 50			ld a, display_row_3 
994c 11 24 99		        ld de, .monhelptext3 
994f					 
994f cd c1 8a			call str_at_display 
9952 3e 78			ld a, display_row_4 
9954 11 33 99		        ld de, .monhelptext4 
9957 cd c1 8a			call str_at_display 
995a			 
995a cd d1 8a			call update_display		 
995d			 
995d cd b3 9a			call next_page_prompt 
9960 c3 81 98			jp monitor 
9963			 
9963			.monjump:    
9963 21 c1 e4			ld hl,os_input+2 
9966 cd 92 90			call get_word_hl 
9969			 
9969 e9				jp (hl) 
996a c3 81 98			jp monitor 
996d			 
996d			.mondump:    
996d 21 c1 e4			ld hl,os_input+2 
9970 cd 92 90			call get_word_hl 
9973			 
9973 22 e4 e5			ld (os_cur_ptr),hl	 
9976 cd bb 99			call dumpcont 
9979 3e 78			ld a, display_row_4 
997b 11 2d 98			ld de, endprog 
997e			 
997e cd d1 8a			call update_display		 
9981			 
9981 cd b3 9a			call next_page_prompt 
9984 c3 81 98			jp monitor 
9987			.moncdump: 
9987 cd bb 99			call dumpcont 
998a 3e 78			ld a, display_row_4 
998c 11 2d 98			ld de, endprog 
998f			 
998f cd d1 8a			call update_display		 
9992			 
9992 cd b3 9a			call next_page_prompt 
9995 c3 81 98			jp monitor 
9998			 
9998			 
9998			; TODO symbol access  
9998			 
9998			.symbols:     ;; A list of symbols that can be called up  
9998 b1 ed			dw display_fb0 
999a .. 00			db "fb0",0  
999e 7a ea		     	dw store_page 
99a0 .. 00			db "store_page",0 
99ab			 
99ab			 
99ab			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
99ab			 
99ab 3a c2 e2			ld a,(scratch+1) 
99ae fe 00			cp 0 
99b0 28 09			jr z, dumpcont 
99b2			 
99b2				; no, not a null term line so has an address to work out.... 
99b2			 
99b2 21 c3 e2			ld hl,scratch+2 
99b5 cd 92 90			call get_word_hl 
99b8			 
99b8 22 e4 e5			ld (os_cur_ptr),hl	 
99bb			 
99bb			 
99bb			 
99bb			dumpcont: 
99bb			 
99bb				; dump bytes at ptr 
99bb			 
99bb			 
99bb 3e 00			ld a, display_row_1 
99bd 2a cc eb			ld hl, (display_fb_active) 
99c0 cd db 8c			call addatohl 
99c3 cd eb 99			call .dumpbyterow 
99c6			 
99c6 3e 28			ld a, display_row_2 
99c8 2a cc eb			ld hl, (display_fb_active) 
99cb cd db 8c			call addatohl 
99ce cd eb 99			call .dumpbyterow 
99d1			 
99d1			 
99d1 3e 50			ld a, display_row_3 
99d3 2a cc eb			ld hl, (display_fb_active) 
99d6 cd db 8c			call addatohl 
99d9 cd eb 99			call .dumpbyterow 
99dc			 
99dc 3e 78			ld a, display_row_4 
99de 2a cc eb			ld hl, (display_fb_active) 
99e1 cd db 8c			call addatohl 
99e4 cd eb 99			call .dumpbyterow 
99e7			 
99e7 cd d1 8a			call update_display 
99ea			;		jp cli 
99ea c9				ret 
99eb			 
99eb			.dumpbyterow: 
99eb			 
99eb				;push af 
99eb			 
99eb e5				push hl 
99ec			 
99ec				; calc where to poke the ascii 
99ec			if display_cols == 20 
99ec				ld a, 16 
99ec			else 
99ec 3e 1f			ld a, 31 
99ee			endif 
99ee			 
99ee cd db 8c			call addatohl 
99f1 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
99f4			 
99f4			 
99f4			; display decoding address 
99f4 2a e4 e5		   	ld hl,(os_cur_ptr) 
99f7			 
99f7 7c				ld a,h 
99f8 e1				pop hl 
99f9 e5				push hl 
99fa			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
99fa cd dc 8f			call hexout 
99fd 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a00			 
9a00 7d				ld a,l 
9a01 e1				pop hl 
9a02 23				inc hl 
9a03 23				inc hl 
9a04 e5				push hl 
9a05			;	ld hl, os_word_scratch+2 
9a05 cd dc 8f			call hexout 
9a08 e1				pop hl 
9a09 23				inc hl 
9a0a 23				inc hl 
9a0b				;ld hl, os_word_scratch+4 
9a0b 3e 3a			ld a, ':' 
9a0d 77				ld (hl),a 
9a0e 23				inc hl 
9a0f				;ld a, 0 
9a0f				;ld (hl),a 
9a0f				;ld de, os_word_scratch 
9a0f				;pop af 
9a0f				;push af 
9a0f			;		ld a, display_row_2 
9a0f			;		call str_at_display 
9a0f			;		call update_display 
9a0f			 
9a0f			 
9a0f			;pop af 
9a0f			;	add 5 
9a0f			 
9a0f			if display_cols == 20 
9a0f				ld b, 4 
9a0f			else 
9a0f 06 08			ld b, 8 
9a11			endif	 
9a11			 
9a11			.dumpbyte: 
9a11 c5				push bc 
9a12 e5				push hl 
9a13			 
9a13			 
9a13 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a16 7e					ld a,(hl) 
9a17			 
9a17					; poke the ascii to display 
9a17 2a c6 e5				ld hl,(os_word_scratch) 
9a1a 77					ld (hl),a 
9a1b 23					inc hl 
9a1c 22 c6 e5				ld (os_word_scratch),hl 
9a1f			 
9a1f					 
9a1f			 
9a1f			 
9a1f e1					pop hl 
9a20 e5					push hl 
9a21			 
9a21 cd dc 8f				call hexout 
9a24			 
9a24					 
9a24 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a27 23				inc hl 
9a28 22 e4 e5		   	ld (os_cur_ptr),hl 
9a2b			 
9a2b e1					pop hl 
9a2c 23					inc hl 
9a2d 23					inc hl 
9a2e 23					inc hl 
9a2f			 
9a2f			 
9a2f			 
9a2f					;ld a,0 
9a2f					;ld (os_word_scratch+2),a 
9a2f					;pop af 
9a2f					;push af 
9a2f			 
9a2f					;ld de, os_word_scratch 
9a2f					;call str_at_display 
9a2f			;		call update_display 
9a2f			;		pop af 
9a2f c1					pop bc 
9a30 c6 03				add 3 
9a32 10 dd			djnz .dumpbyte 
9a34			 
9a34				 
9a34			 
9a34 c9				ret 
9a35			 
9a35			jump:	 
9a35			 
9a35 21 c3 e2			ld hl,scratch+2 
9a38 cd 92 90			call get_word_hl 
9a3b				;ld hl,(scratch+2) 
9a3b				;call fourehexhl 
9a3b			 
9a3b 22 e4 e5			ld (os_cur_ptr),hl	 
9a3e			 
9a3e e9				jp (hl) 
9a3f			 
9a3f			 
9a3f			 
9a3f			; TODO implement a basic monitor mode to start with 
9a3f			 
9a3f			 
9a3f			 
9a3f			 
9a3f			 
9a3f			 
9a3f			 
9a3f			 
9a3f			 
9a3f			; testing and demo code during development 
9a3f			 
9a3f			 
9a3f .. 00		str1: db "Enter some text...",0 
9a52 .. 00		clear: db "                    ",0 
9a67			 
9a67			demo: 
9a67			 
9a67			 
9a67			 
9a67			;	call update_display 
9a67			 
9a67				; init scratch input area for testing 
9a67 21 c1 e2			ld hl, scratch	 
9a6a 3e 00			ld a,0 
9a6c 77				ld (hl),a 
9a6d			 
9a6d			 
9a6d 3e 28		            LD   A, display_row_2 
9a6f			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a6f 11 3f 9a		            LD   DE, str1 
9a72 cd c1 8a			call str_at_display 
9a75			 
9a75			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a75			cloop:	 
9a75 3e 50		            LD   A, display_row_3 
9a77			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a77 11 52 9a		            LD   DE, clear 
9a7a			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a7a cd c1 8a				call str_at_display 
9a7d 3e 78			ld a, display_row_4 
9a7f 11 af 9a			ld de, prompt 
9a82			 
9a82 cd c1 8a				call str_at_display 
9a85 cd d1 8a			call update_display 
9a88			 
9a88 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a8a 16 0a			ld d, 10 
9a8c 21 c1 e2			ld hl, scratch	 
9a8f cd 08 8d			call input_str 
9a92			 
9a92			;	call clear_display 
9a92			;'	call update_display 
9a92			 
9a92 3e 00		            LD   A, display_row_1 
9a94			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a94 11 52 9a		            LD   DE, clear 
9a97 cd c1 8a				call str_at_display 
9a9a			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a9a 3e 00		            LD   A, display_row_1 
9a9c			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a9c 11 c1 e2		            LD   DE, scratch 
9a9f			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a9f cd c1 8a				call str_at_display 
9aa2 cd d1 8a			call update_display 
9aa5			 
9aa5 3e 00				ld a,0 
9aa7 21 c1 e2			ld hl, scratch 
9aaa 77				ld (hl),a 
9aab			 
9aab 00				nop 
9aac c3 75 9a			jp cloop 
9aaf			 
9aaf			 
9aaf			 
9aaf			; OS Prompt 
9aaf			 
9aaf .. 00		prompt: db ">",0 
9ab1 .. 00		endprg: db "?",0 
9ab3			 
9ab3			 
9ab3			; handy next page prompt 
9ab3			next_page_prompt: 
9ab3 e5				push hl 
9ab4 d5				push de 
9ab5 f5				push af 
9ab6 c5				push bc 
9ab7			 
9ab7 3e 9f			ld a,display_row_4 + display_cols - 1 
9ab9 11 b1 9a		        ld de, endprg 
9abc cd c1 8a			call str_at_display 
9abf cd d1 8a			call update_display 
9ac2 cd 5c e4			call cin_wait 
9ac5 c1				pop bc 
9ac6 f1				pop af 
9ac7 d1				pop de 
9ac8 e1				pop hl 
9ac9			 
9ac9			 
9ac9 c9				ret 
9aca			 
9aca			 
9aca			; forth parser 
9aca			 
9aca			; My forth kernel 
9aca			include "forth_kernel.asm" 
9aca			; 
9aca			; kernel to the forth OS 
9aca			 
9aca			DS_TYPE_STR: equ 1     ; string type 
9aca			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9aca			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9aca			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9aca			 
9aca			FORTH_PARSEV1: equ 0 
9aca			FORTH_PARSEV2: equ 0 
9aca			FORTH_PARSEV3: equ 0 
9aca			FORTH_PARSEV4: equ 0 
9aca			FORTH_PARSEV5: equ 1 
9aca			 
9aca			;if FORTH_PARSEV5 
9aca			;	FORTH_END_BUFFER: equ 0 
9aca			;else 
9aca			FORTH_END_BUFFER: equ 127 
9aca			;endif 
9aca			 
9aca			FORTH_TRUE: equ 1 
9aca			FORTH_FALSE: equ 0 
9aca			 
9aca			if FORTH_PARSEV4 
9aca			include "forth_stackops.asm" 
9aca			endif 
9aca			 
9aca			if FORTH_PARSEV5 
9aca			include "forth_stackopsv5.asm" 
9aca			 
9aca			; Stack operations for v5 parser on wards 
9aca			; * DATA stack 
9aca			; * LOOP stack 
9aca			; * RETURN stack 
9aca			 
9aca			 
9aca			 
9aca			FORTH_CHK_DSP_UNDER: macro 
9aca				push hl 
9aca				push de 
9aca				ld hl,(cli_data_sp) 
9aca				ld de, cli_data_stack 
9aca				call cmp16 
9aca				jp c, fault_dsp_under 
9aca				pop de 
9aca				pop hl 
9aca				endm 
9aca			 
9aca			 
9aca			FORTH_CHK_RSP_UNDER: macro 
9aca				push hl 
9aca				push de 
9aca				ld hl,(cli_ret_sp) 
9aca				ld de, cli_ret_stack 
9aca				call cmp16 
9aca				jp c, fault_rsp_under 
9aca				pop de 
9aca				pop hl 
9aca				endm 
9aca			 
9aca			FORTH_CHK_LOOP_UNDER: macro 
9aca				push hl 
9aca				push de 
9aca				ld hl,(cli_loop_sp) 
9aca				ld de, cli_loop_stack 
9aca				call cmp16 
9aca				jp c, fault_loop_under 
9aca				pop de 
9aca				pop hl 
9aca				endm 
9aca			 
9aca			FORTH_ERR_TOS_NOTSTR: macro 
9aca				; TOSO might need more for checks when used 
9aca				push af 
9aca				ld a,(hl) 
9aca				cp DS_TYPE_STR 
9aca				jp nz, type_faultn   
9aca				pop af 
9aca				endm 
9aca			 
9aca			FORTH_ERR_TOS_NOTNUM: macro 
9aca				push af 
9aca				ld a,(hl) 
9aca				cp DS_TYPE_INUM 
9aca				jp nz, type_faultn   
9aca				pop af 
9aca				endm 
9aca			 
9aca			 
9aca			; increase data stack pointer and save hl to it 
9aca				 
9aca			FORTH_DSP_NEXT: macro 
9aca				call macro_forth_dsp_next 
9aca				endm 
9aca			 
9aca			 
9aca			macro_forth_dsp_next: 
9aca				if DEBUG_FORTH_STACK_GUARD 
9aca cd d7 e0				call check_stacks 
9acd				endif 
9acd e5				push hl 
9ace d5				push de 
9acf eb				ex de,hl 
9ad0 2a ee e9			ld hl,(cli_data_sp) 
9ad3 23				inc hl 
9ad4 23				inc hl 
9ad5			 
9ad5			; PARSEV5 
9ad5 23				inc hl 
9ad6 22 ee e9			ld (cli_data_sp),hl 
9ad9 73				ld (hl), e 
9ada 23				inc hl 
9adb 72				ld (hl), d 
9adc d1				pop de 
9add e1				pop hl 
9ade				if DEBUG_FORTH_STACK_GUARD 
9ade cd d7 e0				call check_stacks 
9ae1				endif 
9ae1 c9				ret 
9ae2			 
9ae2			 
9ae2			; increase ret stack pointer and save hl to it 
9ae2				 
9ae2			FORTH_RSP_NEXT: macro 
9ae2				call macro_forth_rsp_next 
9ae2				endm 
9ae2			 
9ae2			macro_forth_rsp_next: 
9ae2				if DEBUG_FORTH_STACK_GUARD 
9ae2 cd d7 e0				call check_stacks 
9ae5				endif 
9ae5 e5				push hl 
9ae6 d5				push de 
9ae7 eb				ex de,hl 
9ae8 2a f2 e9			ld hl,(cli_ret_sp) 
9aeb 23				inc hl 
9aec 23				inc hl 
9aed 22 f2 e9			ld (cli_ret_sp),hl 
9af0 73				ld (hl), e 
9af1 23				inc hl 
9af2 72				ld (hl), d 
9af3 d1				pop de 
9af4 e1				pop hl 
9af5				if DEBUG_FORTH_STACK_GUARD 
9af5 cd d7 e0				call check_stacks 
9af8				endif 
9af8 c9				ret 
9af9			 
9af9			; get current ret stack pointer and save to hl  
9af9				 
9af9			FORTH_RSP_TOS: macro 
9af9				call macro_forth_rsp_tos 
9af9				endm 
9af9			 
9af9			macro_forth_rsp_tos: 
9af9				;push de 
9af9 2a f2 e9			ld hl,(cli_ret_sp) 
9afc cd 34 9b			call loadhlptrtohl 
9aff				;ld e, (hl) 
9aff				;inc hl 
9aff				;ld d, (hl) 
9aff				;ex de, hl 
9aff					if DEBUG_FORTH_WORDS 
9aff			;			DMARK "RST" 
9aff						CALLMONITOR 
9aff cd 6f ee			call debug_vector  
9b02				endm  
# End of macro CALLMONITOR
9b02					endif 
9b02				;pop de 
9b02 c9				ret 
9b03			 
9b03			; pop ret stack pointer 
9b03				 
9b03			FORTH_RSP_POP: macro 
9b03				call macro_forth_rsp_pop 
9b03				endm 
9b03			 
9b03			 
9b03			macro_forth_rsp_pop: 
9b03				if DEBUG_FORTH_STACK_GUARD 
9b03			;		DMARK "RPP" 
9b03 cd d7 e0				call check_stacks 
9b06					FORTH_CHK_RSP_UNDER 
9b06 e5				push hl 
9b07 d5				push de 
9b08 2a f2 e9			ld hl,(cli_ret_sp) 
9b0b 11 ac e9			ld de, cli_ret_stack 
9b0e cd f9 8c			call cmp16 
9b11 da eb e1			jp c, fault_rsp_under 
9b14 d1				pop de 
9b15 e1				pop hl 
9b16				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b16				endif 
9b16 e5				push hl 
9b17 2a f2 e9			ld hl,(cli_ret_sp) 
9b1a			 
9b1a			 
9b1a				if FORTH_ENABLE_FREE 
9b1a			 
9b1a					; get pointer 
9b1a			 
9b1a					push de 
9b1a					push hl 
9b1a			 
9b1a					ld e, (hl) 
9b1a					inc hl 
9b1a					ld d, (hl) 
9b1a			 
9b1a					ex de, hl 
9b1a					call free 
9b1a			 
9b1a					pop hl 
9b1a					pop de 
9b1a			 
9b1a			 
9b1a				endif 
9b1a			 
9b1a			 
9b1a 2b				dec hl 
9b1b 2b				dec hl 
9b1c 22 f2 e9			ld (cli_ret_sp), hl 
9b1f				; do stack underflow checks 
9b1f e1				pop hl 
9b20				if DEBUG_FORTH_STACK_GUARD 
9b20 cd d7 e0				call check_stacks 
9b23					FORTH_CHK_RSP_UNDER 
9b23 e5				push hl 
9b24 d5				push de 
9b25 2a f2 e9			ld hl,(cli_ret_sp) 
9b28 11 ac e9			ld de, cli_ret_stack 
9b2b cd f9 8c			call cmp16 
9b2e da eb e1			jp c, fault_rsp_under 
9b31 d1				pop de 
9b32 e1				pop hl 
9b33				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b33				endif 
9b33 c9				ret 
9b34			 
9b34			 
9b34			 
9b34			; routine to load word pointed to by hl into hl 
9b34			 
9b34			loadhlptrtohl: 
9b34			 
9b34 d5				push de 
9b35 5e				ld e, (hl) 
9b36 23				inc hl 
9b37 56				ld d, (hl) 
9b38 eb				ex de, hl 
9b39 d1				pop de 
9b3a			 
9b3a c9				ret 
9b3b			 
9b3b			 
9b3b			 
9b3b			 
9b3b			 
9b3b			; push a number held in HL onto the data stack 
9b3b			; entry point for pushing a value when already in hl used in function above 
9b3b			 
9b3b			forth_push_numhl: 
9b3b			 
9b3b e5				push hl    ; save value to push 
9b3c			 
9b3c			if DEBUG_FORTH_PUSH 
9b3c				; see if disabled 
9b3c			 
9b3c			 
9b3c f5				push af 
9b3d 3a 6f ee			ld a,(debug_vector) 
9b40 fe c9			cp $c9   ; ret 
9b42			;	ld a, (os_view_disable) 
9b42			;	cp '*' 
9b42 28 34			jr z, .pskip2 
9b44 e5				push hl 
9b45 e5			push hl 
9b46 cd ae 8a			call clear_display 
9b49 e1			pop hl 
9b4a 7c				ld a,h 
9b4b 21 c6 e5			ld hl, os_word_scratch 
9b4e cd dc 8f			call hexout 
9b51 e1				pop hl 
9b52 7d				ld a,l 
9b53 21 c8 e5			ld hl, os_word_scratch+2 
9b56 cd dc 8f			call hexout 
9b59			 
9b59 21 ca e5			ld hl, os_word_scratch+4 
9b5c 3e 00			ld a,0 
9b5e 77				ld (hl),a 
9b5f 11 c6 e5			ld de,os_word_scratch 
9b62 3e 28				ld a, display_row_2 
9b64 cd c1 8a				call str_at_display 
9b67 11 13 cc			ld de, .push_num 
9b6a 3e 00			ld a, display_row_1 
9b6c			 
9b6c cd c1 8a				call str_at_display 
9b6f			 
9b6f			 
9b6f cd d1 8a			call update_display 
9b72 cd f1 89			call delay1s 
9b75 cd f1 89			call delay1s 
9b78			.pskip2:  
9b78			 
9b78 f1				pop af 
9b79			endif	 
9b79			 
9b79			 
9b79				FORTH_DSP_NEXT 
9b79 cd ca 9a			call macro_forth_dsp_next 
9b7c				endm 
# End of macro FORTH_DSP_NEXT
9b7c			 
9b7c 2a ee e9			ld hl, (cli_data_sp) 
9b7f			 
9b7f				; save item type 
9b7f 3e 02			ld a,  DS_TYPE_INUM 
9b81 77				ld (hl), a 
9b82 23				inc hl 
9b83			 
9b83				; get word off stack 
9b83 d1				pop de 
9b84 7b				ld a,e 
9b85 77				ld (hl), a 
9b86 23				inc hl 
9b87 7a				ld a,d 
9b88 77				ld (hl), a 
9b89			 
9b89			if DEBUG_FORTH_PUSH 
9b89 2b				dec hl 
9b8a 2b				dec hl 
9b8b 2b				dec hl 
9b8c						DMARK "PH5" 
9b8c f5				push af  
9b8d 3a a1 9b			ld a, (.dmark)  
9b90 32 6b ee			ld (debug_mark),a  
9b93 3a a2 9b			ld a, (.dmark+1)  
9b96 32 6c ee			ld (debug_mark+1),a  
9b99 3a a3 9b			ld a, (.dmark+2)  
9b9c 32 6d ee			ld (debug_mark+2),a  
9b9f 18 03			jr .pastdmark  
9ba1 ..			.dmark: db "PH5"  
9ba4 f1			.pastdmark: pop af  
9ba5			endm  
# End of macro DMARK
9ba5				CALLMONITOR 
9ba5 cd 6f ee			call debug_vector  
9ba8				endm  
# End of macro CALLMONITOR
9ba8			endif	 
9ba8			 
9ba8 c9				ret 
9ba9			 
9ba9			 
9ba9			; Push a string to stack pointed to by hl 
9ba9			 
9ba9			forth_push_str: 
9ba9			 
9ba9			if DEBUG_FORTH_PUSH 
9ba9						DMARK "PSQ" 
9ba9 f5				push af  
9baa 3a be 9b			ld a, (.dmark)  
9bad 32 6b ee			ld (debug_mark),a  
9bb0 3a bf 9b			ld a, (.dmark+1)  
9bb3 32 6c ee			ld (debug_mark+1),a  
9bb6 3a c0 9b			ld a, (.dmark+2)  
9bb9 32 6d ee			ld (debug_mark+2),a  
9bbc 18 03			jr .pastdmark  
9bbe ..			.dmark: db "PSQ"  
9bc1 f1			.pastdmark: pop af  
9bc2			endm  
# End of macro DMARK
9bc2				CALLMONITOR 
9bc2 cd 6f ee			call debug_vector  
9bc5				endm  
# End of macro CALLMONITOR
9bc5			endif	 
9bc5			    
9bc5 e5				push hl 
9bc6 e5				push hl 
9bc7			 
9bc7			;	ld a, 0   ; find end of string 
9bc7 cd 39 91			call strlenz 
9bca			if DEBUG_FORTH_PUSH 
9bca						DMARK "PQ2" 
9bca f5				push af  
9bcb 3a df 9b			ld a, (.dmark)  
9bce 32 6b ee			ld (debug_mark),a  
9bd1 3a e0 9b			ld a, (.dmark+1)  
9bd4 32 6c ee			ld (debug_mark+1),a  
9bd7 3a e1 9b			ld a, (.dmark+2)  
9bda 32 6d ee			ld (debug_mark+2),a  
9bdd 18 03			jr .pastdmark  
9bdf ..			.dmark: db "PQ2"  
9be2 f1			.pastdmark: pop af  
9be3			endm  
# End of macro DMARK
9be3				CALLMONITOR 
9be3 cd 6f ee			call debug_vector  
9be6				endm  
# End of macro CALLMONITOR
9be6			endif	 
9be6 eb				ex de, hl 
9be7 e1				pop hl   ; get ptr to start of string 
9be8			if DEBUG_FORTH_PUSH 
9be8						DMARK "PQ3" 
9be8 f5				push af  
9be9 3a fd 9b			ld a, (.dmark)  
9bec 32 6b ee			ld (debug_mark),a  
9bef 3a fe 9b			ld a, (.dmark+1)  
9bf2 32 6c ee			ld (debug_mark+1),a  
9bf5 3a ff 9b			ld a, (.dmark+2)  
9bf8 32 6d ee			ld (debug_mark+2),a  
9bfb 18 03			jr .pastdmark  
9bfd ..			.dmark: db "PQ3"  
9c00 f1			.pastdmark: pop af  
9c01			endm  
# End of macro DMARK
9c01				CALLMONITOR 
9c01 cd 6f ee			call debug_vector  
9c04				endm  
# End of macro CALLMONITOR
9c04			endif	 
9c04 19				add hl,de 
9c05			if DEBUG_FORTH_PUSH 
9c05						DMARK "PQE" 
9c05 f5				push af  
9c06 3a 1a 9c			ld a, (.dmark)  
9c09 32 6b ee			ld (debug_mark),a  
9c0c 3a 1b 9c			ld a, (.dmark+1)  
9c0f 32 6c ee			ld (debug_mark+1),a  
9c12 3a 1c 9c			ld a, (.dmark+2)  
9c15 32 6d ee			ld (debug_mark+2),a  
9c18 18 03			jr .pastdmark  
9c1a ..			.dmark: db "PQE"  
9c1d f1			.pastdmark: pop af  
9c1e			endm  
# End of macro DMARK
9c1e				CALLMONITOR 
9c1e cd 6f ee			call debug_vector  
9c21				endm  
# End of macro CALLMONITOR
9c21			endif	 
9c21			 
9c21 2b				dec hl    ; see if there is an optional trailing double quote 
9c22 7e				ld a,(hl) 
9c23 fe 22			cp '"' 
9c25 20 03			jr nz, .strnoq 
9c27 3e 00			ld a, 0      ; get rid of double quote 
9c29 77				ld (hl), a 
9c2a 23			.strnoq: inc hl 
9c2b			 
9c2b 3e 00			ld a, 0 
9c2d 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c2e			 
9c2e 13				inc de ; add one for the type string 
9c2f 13				inc de ; add one for null term??? 
9c30			 
9c30				; tos is get string pointer again 
9c30				; de contains space to allocate 
9c30				 
9c30 d5				push de 
9c31			 
9c31 eb				ex de, hl 
9c32			 
9c32				;push af 
9c32			 
9c32			if DEBUG_FORTH_PUSH 
9c32						DMARK "PHm" 
9c32 f5				push af  
9c33 3a 47 9c			ld a, (.dmark)  
9c36 32 6b ee			ld (debug_mark),a  
9c39 3a 48 9c			ld a, (.dmark+1)  
9c3c 32 6c ee			ld (debug_mark+1),a  
9c3f 3a 49 9c			ld a, (.dmark+2)  
9c42 32 6d ee			ld (debug_mark+2),a  
9c45 18 03			jr .pastdmark  
9c47 ..			.dmark: db "PHm"  
9c4a f1			.pastdmark: pop af  
9c4b			endm  
# End of macro DMARK
9c4b				CALLMONITOR 
9c4b cd 6f ee			call debug_vector  
9c4e				endm  
# End of macro CALLMONITOR
9c4e			endif	 
9c4e cd a2 91			call malloc	; on ret hl now contains allocated memory 
9c51				if DEBUG_FORTH_MALLOC_GUARD 
9c51 cc 6b cc				call z,malloc_error 
9c54				endif 
9c54			 
9c54				 
9c54 c1				pop bc    ; get length 
9c55 d1				pop de   ;  get string start    
9c56			 
9c56				; hl has destination from malloc 
9c56			 
9c56 eb				ex de, hl    ; prep for ldir 
9c57			 
9c57 d5				push de   ; save malloc area for DSP later 
9c58				;push hl   ; save malloc area for DSP later 
9c58			 
9c58			if DEBUG_FORTH_PUSH 
9c58						DMARK "PHc" 
9c58 f5				push af  
9c59 3a 6d 9c			ld a, (.dmark)  
9c5c 32 6b ee			ld (debug_mark),a  
9c5f 3a 6e 9c			ld a, (.dmark+1)  
9c62 32 6c ee			ld (debug_mark+1),a  
9c65 3a 6f 9c			ld a, (.dmark+2)  
9c68 32 6d ee			ld (debug_mark+2),a  
9c6b 18 03			jr .pastdmark  
9c6d ..			.dmark: db "PHc"  
9c70 f1			.pastdmark: pop af  
9c71			endm  
# End of macro DMARK
9c71				CALLMONITOR 
9c71 cd 6f ee			call debug_vector  
9c74				endm  
# End of macro CALLMONITOR
9c74			endif	 
9c74			 
9c74			 
9c74 ed b0			ldir 
9c76			 
9c76			 
9c76				; push malloc to data stack     macro?????  
9c76			 
9c76				FORTH_DSP_NEXT 
9c76 cd ca 9a			call macro_forth_dsp_next 
9c79				endm 
# End of macro FORTH_DSP_NEXT
9c79			 
9c79				; save value and type 
9c79			 
9c79 2a ee e9			ld hl, (cli_data_sp) 
9c7c			 
9c7c				; save item type 
9c7c 3e 01			ld a,  DS_TYPE_STR 
9c7e 77				ld (hl), a 
9c7f 23				inc hl 
9c80			 
9c80				; get malloc word off stack 
9c80 d1				pop de 
9c81 73				ld (hl), e 
9c82 23				inc hl 
9c83 72				ld (hl), d 
9c84			 
9c84			 
9c84			 
9c84			if DEBUG_FORTH_PUSH 
9c84 2a ee e9			ld hl, (cli_data_sp) 
9c87						DMARK "PHS" 
9c87 f5				push af  
9c88 3a 9c 9c			ld a, (.dmark)  
9c8b 32 6b ee			ld (debug_mark),a  
9c8e 3a 9d 9c			ld a, (.dmark+1)  
9c91 32 6c ee			ld (debug_mark+1),a  
9c94 3a 9e 9c			ld a, (.dmark+2)  
9c97 32 6d ee			ld (debug_mark+2),a  
9c9a 18 03			jr .pastdmark  
9c9c ..			.dmark: db "PHS"  
9c9f f1			.pastdmark: pop af  
9ca0			endm  
# End of macro DMARK
9ca0				CALLMONITOR 
9ca0 cd 6f ee			call debug_vector  
9ca3				endm  
# End of macro CALLMONITOR
9ca3			;	ex de,hl 
9ca3			endif	 
9ca3				; in case of spaces, skip the ptr past the copied string 
9ca3				;pop af 
9ca3				;ld (cli_origptr),hl 
9ca3			 
9ca3 c9				ret 
9ca4			 
9ca4			 
9ca4			 
9ca4			; TODO ascii push input onto stack given hl to start of input 
9ca4			 
9ca4			; identify type 
9ca4			; if starts with a " then a string 
9ca4			; otherwise it is a number 
9ca4			;  
9ca4			; if a string 
9ca4			;     scan for ending " to get length of string to malloc for + 1 
9ca4			;     malloc 
9ca4			;     put pointer to string on stack first byte flags as string 
9ca4			; 
9ca4			; else a number 
9ca4			;    look for number format identifier 
9ca4			;    $xx hex 
9ca4			;    %xxxxx bin 
9ca4			;    xxxxx decimal 
9ca4			;    convert number to 16bit word.  
9ca4			;    malloc word + 1 with flag to identiy as num 
9ca4			;    put pointer to number on stack 
9ca4			;   
9ca4			;  
9ca4			  
9ca4			forth_apush: 
9ca4				; kernel push 
9ca4			 
9ca4			if DEBUG_FORTH_PUSH 
9ca4						DMARK "PSH" 
9ca4 f5				push af  
9ca5 3a b9 9c			ld a, (.dmark)  
9ca8 32 6b ee			ld (debug_mark),a  
9cab 3a ba 9c			ld a, (.dmark+1)  
9cae 32 6c ee			ld (debug_mark+1),a  
9cb1 3a bb 9c			ld a, (.dmark+2)  
9cb4 32 6d ee			ld (debug_mark+2),a  
9cb7 18 03			jr .pastdmark  
9cb9 ..			.dmark: db "PSH"  
9cbc f1			.pastdmark: pop af  
9cbd			endm  
# End of macro DMARK
9cbd				CALLMONITOR 
9cbd cd 6f ee			call debug_vector  
9cc0				endm  
# End of macro CALLMONITOR
9cc0			endif	 
9cc0				; identify input type 
9cc0			 
9cc0 7e				ld a,(hl) 
9cc1 fe 22			cp '"' 
9cc3 28 0a			jr z, .fapstr 
9cc5 fe 24			cp '$' 
9cc7 ca ef 9c			jp z, .faphex 
9cca fe 25			cp '%' 
9ccc ca d7 9c			jp z, .fapbin 
9ccf			;	cp 'b' 
9ccf			;	jp z, .fabin 
9ccf				; else decimal 
9ccf			 
9ccf				; TODO do decimal conversion 
9ccf				; decimal is stored as a 16bit word 
9ccf			 
9ccf				; by default everything is a string if type is not detected 
9ccf			.fapstr: ; 
9ccf fe 22			cp '"' 
9cd1 20 01			jr nz, .strnoqu 
9cd3 23				inc hl 
9cd4			.strnoqu: 
9cd4 c3 a9 9b			jp forth_push_str 
9cd7			 
9cd7			 
9cd7			 
9cd7			.fapbin:    ; push a binary string.  
9cd7 11 00 00			ld de, 0   ; hold a 16bit value 
9cda			 
9cda 23			.fapbinshift:	inc hl  
9cdb 7e				ld a,(hl) 
9cdc fe 00			cp 0     ; done scanning  
9cde 28 0b			jr z, .fapbdone  	; got it in HL so push  
9ce0			 
9ce0				; left shift de 
9ce0 eb				ex de, hl	 
9ce1 29				add hl, hl 
9ce2			 
9ce2				; is 1 
9ce2 fe 31			cp '1' 
9ce4 20 02			jr nz, .binzero 
9ce6 cb 4d			bit 1, l 
9ce8			.binzero: 
9ce8 eb				ex de, hl	 ; save current de 
9ce9 18 ef			jr .fapbinshift 
9ceb			 
9ceb			.fapbdone: 
9ceb eb				ex de, hl 
9cec c3 3b 9b			jp forth_push_numhl 
9cef			 
9cef			 
9cef			.faphex:   ; hex is always stored as a 16bit word 
9cef				; skip number prefix 
9cef 23				inc hl 
9cf0				; turn ascii into number 
9cf0 cd 92 90			call get_word_hl	; ret 16bit word in hl 
9cf3			 
9cf3 c3 3b 9b			jp forth_push_numhl 
9cf6			 
9cf6 00				 nop 
9cf7			 
9cf7			.fabin:   ; TODO bin conversion 
9cf7			 
9cf7			 
9cf7 c9				ret 
9cf8			 
9cf8			 
9cf8			; get either a string ptr or a 16bit word from the data stack 
9cf8			 
9cf8			FORTH_DSP: macro 
9cf8				call macro_forth_dsp 
9cf8				endm 
9cf8			 
9cf8			macro_forth_dsp: 
9cf8				; data stack pointer points to current word on tos 
9cf8			 
9cf8 2a ee e9			ld hl,(cli_data_sp) 
9cfb			 
9cfb				if DEBUG_FORTH_PUSH 
9cfb						DMARK "DSP" 
9cfb f5				push af  
9cfc 3a 10 9d			ld a, (.dmark)  
9cff 32 6b ee			ld (debug_mark),a  
9d02 3a 11 9d			ld a, (.dmark+1)  
9d05 32 6c ee			ld (debug_mark+1),a  
9d08 3a 12 9d			ld a, (.dmark+2)  
9d0b 32 6d ee			ld (debug_mark+2),a  
9d0e 18 03			jr .pastdmark  
9d10 ..			.dmark: db "DSP"  
9d13 f1			.pastdmark: pop af  
9d14			endm  
# End of macro DMARK
9d14			 
9d14 cd 9e cc				call display_data_sp 
9d17				;call break_point_state 
9d17				;rst 030h 
9d17				CALLMONITOR 
9d17 cd 6f ee			call debug_vector  
9d1a				endm  
# End of macro CALLMONITOR
9d1a				endif 
9d1a			 
9d1a c9				ret 
9d1b			 
9d1b			; return hl to start of value on stack 
9d1b			 
9d1b			FORTH_DSP_VALUE: macro 
9d1b				call macro_forth_dsp_value 
9d1b				endm 
9d1b			 
9d1b			macro_forth_dsp_value: 
9d1b			 
9d1b				FORTH_DSP 
9d1b cd f8 9c			call macro_forth_dsp 
9d1e				endm 
# End of macro FORTH_DSP
9d1e			 
9d1e d5				push de 
9d1f			 
9d1f 23				inc hl ; skip type 
9d20			 
9d20 5e				ld e, (hl) 
9d21 23				inc hl 
9d22 56				ld d, (hl) 
9d23 eb				ex de,hl  
9d24			 
9d24 d1				pop de 
9d25			 
9d25 c9				ret 
9d26			 
9d26			; return hl to start of value to second item on stack 
9d26			 
9d26			FORTH_DSP_VALUEM1: macro 
9d26				call macro_forth_dsp_value_m1 
9d26				endm 
9d26			 
9d26			macro_forth_dsp_value_m1: 
9d26			 
9d26				FORTH_DSP 
9d26 cd f8 9c			call macro_forth_dsp 
9d29				endm 
# End of macro FORTH_DSP
9d29			 
9d29 2b				dec hl 
9d2a 2b				dec hl 
9d2b			;	dec hl 
9d2b			 
9d2b d5				push de 
9d2c			 
9d2c 5e				ld e, (hl) 
9d2d 23				inc hl 
9d2e 56				ld d, (hl) 
9d2f eb				ex de,hl  
9d30			 
9d30 d1				pop de 
9d31			 
9d31 c9				ret 
9d32			 
9d32				 
9d32			 
9d32			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d32			 
9d32			FORTH_DSP_POP: macro 
9d32				call macro_forth_dsp_pop 
9d32				endm 
9d32			 
9d32			 
9d32			; get the tos data type 
9d32			 
9d32			FORTH_DSP_TYPE:   macro 
9d32			 
9d32				;FORTH_DSP_VALUE 
9d32				FORTH_DSP 
9d32				 
9d32				; hl points to value 
9d32				; check type 
9d32			 
9d32				ld a,(hl) 
9d32			 
9d32				endm 
9d32			 
9d32			; load the tos value into hl 
9d32			 
9d32			 
9d32			FORTH_DSP_VALUEHL:  macro 
9d32				call macro_dsp_valuehl 
9d32				endm 
9d32			 
9d32			 
9d32			 
9d32			macro_dsp_valuehl: 
9d32				FORTH_DSP_VALUE 
9d32 cd 1b 9d			call macro_forth_dsp_value 
9d35				endm 
# End of macro FORTH_DSP_VALUE
9d35			 
9d35				;FORTH_ERR_TOS_NOTNUM 
9d35			 
9d35				;inc hl   ; skip type id 
9d35			 
9d35			;	push de 
9d35			; 
9d35			;	ld e, (hl) 
9d35			;	inc hl 
9d35			;	ld d, (hl) 
9d35			;	ex de,hl  
9d35			 
9d35			;	pop de 
9d35			 
9d35				if DEBUG_FORTH_PUSH 
9d35						DMARK "DVL" 
9d35 f5				push af  
9d36 3a 4a 9d			ld a, (.dmark)  
9d39 32 6b ee			ld (debug_mark),a  
9d3c 3a 4b 9d			ld a, (.dmark+1)  
9d3f 32 6c ee			ld (debug_mark+1),a  
9d42 3a 4c 9d			ld a, (.dmark+2)  
9d45 32 6d ee			ld (debug_mark+2),a  
9d48 18 03			jr .pastdmark  
9d4a ..			.dmark: db "DVL"  
9d4d f1			.pastdmark: pop af  
9d4e			endm  
# End of macro DMARK
9d4e				CALLMONITOR 
9d4e cd 6f ee			call debug_vector  
9d51				endm  
# End of macro CALLMONITOR
9d51				endif 
9d51 c9				ret 
9d52			 
9d52			forth_apushstrhl:      
9d52				; push of string requires use of cli_origptr 
9d52				; bodge use 
9d52			 
9d52				; get current cli_origptr, save, update with temp pointer  
9d52 ed 5b 3e ea		ld de, (cli_origptr) 
9d56 22 3e ea			ld (cli_origptr), hl 
9d59 d5				push de 
9d5a cd a4 9c			call forth_apush 
9d5d d1				pop de 
9d5e ed 53 3e ea		ld (cli_origptr), de 
9d62 c9			        ret	 
9d63			 
9d63			 
9d63			; increase loop stack pointer and save hl to it 
9d63				 
9d63			FORTH_LOOP_NEXT: macro 
9d63				call macro_forth_loop_next 
9d63				;nop 
9d63				endm 
9d63			 
9d63			macro_forth_loop_next: 
9d63				if DEBUG_FORTH_STACK_GUARD 
9d63 cd d7 e0				call check_stacks 
9d66				endif 
9d66 e5				push hl 
9d67 d5				push de 
9d68 eb				ex de,hl 
9d69 2a f0 e9			ld hl,(cli_loop_sp) 
9d6c 23				inc hl 
9d6d 23				inc hl 
9d6e					if DEBUG_FORTH_WORDS 
9d6e						DMARK "LNX" 
9d6e f5				push af  
9d6f 3a 83 9d			ld a, (.dmark)  
9d72 32 6b ee			ld (debug_mark),a  
9d75 3a 84 9d			ld a, (.dmark+1)  
9d78 32 6c ee			ld (debug_mark+1),a  
9d7b 3a 85 9d			ld a, (.dmark+2)  
9d7e 32 6d ee			ld (debug_mark+2),a  
9d81 18 03			jr .pastdmark  
9d83 ..			.dmark: db "LNX"  
9d86 f1			.pastdmark: pop af  
9d87			endm  
# End of macro DMARK
9d87						CALLMONITOR 
9d87 cd 6f ee			call debug_vector  
9d8a				endm  
# End of macro CALLMONITOR
9d8a					endif 
9d8a 22 f0 e9			ld (cli_loop_sp),hl 
9d8d 73				ld (hl), e 
9d8e 23				inc hl 
9d8f 72				ld (hl), d 
9d90 d1				pop de    ; been reversed so save a swap on restore 
9d91 e1				pop hl 
9d92				if DEBUG_FORTH_STACK_GUARD 
9d92 cd d7 e0				call check_stacks 
9d95				endif 
9d95 c9				ret 
9d96			 
9d96			; get current ret stack pointer and save to hl  
9d96				 
9d96			FORTH_LOOP_TOS: macro 
9d96				call macro_forth_loop_tos 
9d96				endm 
9d96			 
9d96			macro_forth_loop_tos: 
9d96 d5				push de 
9d97 2a f0 e9			ld hl,(cli_loop_sp) 
9d9a 5e				ld e, (hl) 
9d9b 23				inc hl 
9d9c 56				ld d, (hl) 
9d9d eb				ex de, hl 
9d9e d1				pop de 
9d9f c9				ret 
9da0			 
9da0			; pop loop stack pointer 
9da0				 
9da0			FORTH_LOOP_POP: macro 
9da0				call macro_forth_loop_pop 
9da0				endm 
9da0			 
9da0			 
9da0			macro_forth_loop_pop: 
9da0				if DEBUG_FORTH_STACK_GUARD 
9da0					DMARK "LPP" 
9da0 f5				push af  
9da1 3a b5 9d			ld a, (.dmark)  
9da4 32 6b ee			ld (debug_mark),a  
9da7 3a b6 9d			ld a, (.dmark+1)  
9daa 32 6c ee			ld (debug_mark+1),a  
9dad 3a b7 9d			ld a, (.dmark+2)  
9db0 32 6d ee			ld (debug_mark+2),a  
9db3 18 03			jr .pastdmark  
9db5 ..			.dmark: db "LPP"  
9db8 f1			.pastdmark: pop af  
9db9			endm  
# End of macro DMARK
9db9 cd d7 e0				call check_stacks 
9dbc					FORTH_CHK_LOOP_UNDER 
9dbc e5				push hl 
9dbd d5				push de 
9dbe 2a f0 e9			ld hl,(cli_loop_sp) 
9dc1 11 2a e9			ld de, cli_loop_stack 
9dc4 cd f9 8c			call cmp16 
9dc7 da f1 e1			jp c, fault_loop_under 
9dca d1				pop de 
9dcb e1				pop hl 
9dcc				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dcc				endif 
9dcc e5				push hl 
9dcd 2a f0 e9			ld hl,(cli_loop_sp) 
9dd0 2b				dec hl 
9dd1 2b				dec hl 
9dd2 22 f0 e9			ld (cli_loop_sp), hl 
9dd5				; TODO do stack underflow checks 
9dd5 e1				pop hl 
9dd6				if DEBUG_FORTH_STACK_GUARD 
9dd6 cd d7 e0				call check_stacks 
9dd9					FORTH_CHK_LOOP_UNDER 
9dd9 e5				push hl 
9dda d5				push de 
9ddb 2a f0 e9			ld hl,(cli_loop_sp) 
9dde 11 2a e9			ld de, cli_loop_stack 
9de1 cd f9 8c			call cmp16 
9de4 da f1 e1			jp c, fault_loop_under 
9de7 d1				pop de 
9de8 e1				pop hl 
9de9				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9de9				endif 
9de9 c9				ret 
9dea			 
9dea			macro_forth_dsp_pop: 
9dea			 
9dea e5				push hl 
9deb			 
9deb				; release malloc data 
9deb			 
9deb				if DEBUG_FORTH_STACK_GUARD 
9deb cd d7 e0				call check_stacks 
9dee					FORTH_CHK_DSP_UNDER 
9dee e5				push hl 
9def d5				push de 
9df0 2a ee e9			ld hl,(cli_data_sp) 
9df3 11 28 e8			ld de, cli_data_stack 
9df6 cd f9 8c			call cmp16 
9df9 da e5 e1			jp c, fault_dsp_under 
9dfc d1				pop de 
9dfd e1				pop hl 
9dfe				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dfe				endif 
9dfe				;ld hl,(cli_data_sp) 
9dfe			if DEBUG_FORTH_DOT 
9dfe				DMARK "DPP" 
9dfe f5				push af  
9dff 3a 13 9e			ld a, (.dmark)  
9e02 32 6b ee			ld (debug_mark),a  
9e05 3a 14 9e			ld a, (.dmark+1)  
9e08 32 6c ee			ld (debug_mark+1),a  
9e0b 3a 15 9e			ld a, (.dmark+2)  
9e0e 32 6d ee			ld (debug_mark+2),a  
9e11 18 03			jr .pastdmark  
9e13 ..			.dmark: db "DPP"  
9e16 f1			.pastdmark: pop af  
9e17			endm  
# End of macro DMARK
9e17				CALLMONITOR 
9e17 cd 6f ee			call debug_vector  
9e1a				endm  
# End of macro CALLMONITOR
9e1a			endif	 
9e1a			 
9e1a			 
9e1a			if FORTH_ENABLE_DSPPOPFREE 
9e1a			 
9e1a				FORTH_DSP 
9e1a cd f8 9c			call macro_forth_dsp 
9e1d				endm 
# End of macro FORTH_DSP
9e1d			 
9e1d 7e				ld a, (hl) 
9e1e fe 01			cp DS_TYPE_STR 
9e20 20 23			jr nz, .skippopfree 
9e22			 
9e22				FORTH_DSP_VALUEHL 
9e22 cd 32 9d			call macro_dsp_valuehl 
9e25				endm 
# End of macro FORTH_DSP_VALUEHL
9e25 00				nop 
9e26			if DEBUG_FORTH_DOT 
9e26				DMARK "DPf" 
9e26 f5				push af  
9e27 3a 3b 9e			ld a, (.dmark)  
9e2a 32 6b ee			ld (debug_mark),a  
9e2d 3a 3c 9e			ld a, (.dmark+1)  
9e30 32 6c ee			ld (debug_mark+1),a  
9e33 3a 3d 9e			ld a, (.dmark+2)  
9e36 32 6d ee			ld (debug_mark+2),a  
9e39 18 03			jr .pastdmark  
9e3b ..			.dmark: db "DPf"  
9e3e f1			.pastdmark: pop af  
9e3f			endm  
# End of macro DMARK
9e3f				CALLMONITOR 
9e3f cd 6f ee			call debug_vector  
9e42				endm  
# End of macro CALLMONITOR
9e42			endif	 
9e42 cd 6c 92			call free 
9e45			.skippopfree: 
9e45				 
9e45			 
9e45			endif 
9e45			 
9e45			if DEBUG_FORTH_DOT_KEY 
9e45				DMARK "DP2" 
9e45				CALLMONITOR 
9e45			endif	 
9e45			 
9e45				; move pointer down 
9e45			 
9e45 2a ee e9			ld hl,(cli_data_sp) 
9e48 2b				dec hl 
9e49 2b				dec hl 
9e4a			; PARSEV5 
9e4a 2b				dec hl 
9e4b 22 ee e9			ld (cli_data_sp), hl 
9e4e			 
9e4e				if DEBUG_FORTH_STACK_GUARD 
9e4e cd d7 e0				call check_stacks 
9e51					FORTH_CHK_DSP_UNDER 
9e51 e5				push hl 
9e52 d5				push de 
9e53 2a ee e9			ld hl,(cli_data_sp) 
9e56 11 28 e8			ld de, cli_data_stack 
9e59 cd f9 8c			call cmp16 
9e5c da e5 e1			jp c, fault_dsp_under 
9e5f d1				pop de 
9e60 e1				pop hl 
9e61				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e61				endif 
9e61			 
9e61 e1				pop hl 
9e62			 
9e62 c9				ret 
9e63			 
9e63			getwordathl: 
9e63				; hl points to an address 
9e63				; load hl with the word at that address 
9e63			 
9e63 d5				push de 
9e64			 
9e64 5e				ld e, (hl) 
9e65 23				inc hl 
9e66 56				ld d, (hl) 
9e67 eb				ex de, hl 
9e68			 
9e68 d1				pop de 
9e69 c9				ret 
9e6a			 
9e6a			 
9e6a			 
9e6a			 
9e6a			 
9e6a			; eof 
9e6a			 
# End of file forth_stackopsv5.asm
9e6a			endif 
9e6a			 
9e6a			loadwordinhl:	 
9e6a			 
9e6a d5				push de 
9e6b			 
9e6b 5e				ld e, (hl) 
9e6c 23				inc hl 
9e6d 56				ld d, (hl) 
9e6e eb				ex de,hl  
9e6f			 
9e6f d1				pop de 
9e70			 
9e70 c9				ret 
9e71			 
9e71			user_word_eol:  
9e71				; hl contains the pointer to where to create a linked list item from the end 
9e71				; of the user dict to continue on at the system word dict 
9e71				 
9e71				; poke the stub of the word list linked list to repoint to rom words 
9e71			 
9e71				; stub format 
9e71				; db   word id 
9e71				; dw    link to next word 
9e71			        ; db char length of token 
9e71				; db string + 0 term 
9e71				; db exec code....  
9e71			 
9e71 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e73 77				ld (hl), a		; word id 
9e74 23				inc hl 
9e75			 
9e75 11 40 a0			ld de, sysdict 
9e78 73				ld (hl), e		; next word link ie system dict 
9e79 23				inc hl 
9e7a 72				ld (hl), d		; next word link ie system dict 
9e7b 23				inc hl	 
9e7c			 
9e7c			;	ld (hl), sysdict		; next word link ie system dict 
9e7c			;	inc hl 
9e7c			;	inc hl 
9e7c			 
9e7c			;	inc hl 
9e7c			;	inc hl 
9e7c			 
9e7c 3e 02			ld a, 2			; word length is 0 
9e7e 77				ld (hl), a	 
9e7f 23				inc hl 
9e80			 
9e80 3e 7e			ld a, '~'			; word length is 0 
9e82 77				ld (hl), a	 
9e83 23				inc hl 
9e84 3e 00			ld a, 0			; save empty word 
9e86 77				ld (hl), a 
9e87			 
9e87 c9				ret 
9e88			 
9e88				 
9e88			 
9e88			forthexec_cleanup: 
9e88				FORTH_RSP_POP 
9e88 cd 03 9b			call macro_forth_rsp_pop 
9e8b				endm 
# End of macro FORTH_RSP_POP
9e8b c9				ret 
9e8c			 
9e8c			forth_call_hl: 
9e8c				; taking hl 
9e8c e5				push hl 
9e8d c9				ret 
9e8e			 
9e8e			; this is called to reset Forth system but keep existing uwords etc 
9e8e			 
9e8e			forth_warmstart: 
9e8e				; setup stack over/under flow checks 
9e8e				if DEBUG_FORTH_STACK_GUARD 
9e8e cd bd e0				call chk_stk_init 
9e91				endif 
9e91			 
9e91				; init stack pointers  - * these stacks go upwards *  
9e91 21 ac e9			ld hl, cli_ret_stack 
9e94 22 f2 e9			ld (cli_ret_sp), hl	 
9e97				; set bottom of stack 
9e97 3e 00			ld a,0 
9e99 77				ld (hl),a 
9e9a 23				inc hl 
9e9b 77				ld (hl),a 
9e9c			 
9e9c 21 28 e8			ld hl, cli_data_stack 
9e9f 22 ee e9			ld (cli_data_sp), hl	 
9ea2				; set bottom of stack 
9ea2 3e 00			ld a,0 
9ea4 77				ld (hl),a 
9ea5 23				inc hl 
9ea6 77				ld (hl),a 
9ea7			 
9ea7 21 2a e9			ld hl, cli_loop_stack 
9eaa 22 f0 e9			ld (cli_loop_sp), hl	 
9ead				; set bottom of stack 
9ead 3e 00			ld a,0 
9eaf 77				ld (hl),a 
9eb0 23				inc hl 
9eb1 77				ld (hl),a 
9eb2			 
9eb2				; init extent of current open file 
9eb2			 
9eb2 3e 00			ld a, 0 
9eb4 32 6a ea			ld (store_openext), a 
9eb7			 
9eb7 c9				ret 
9eb8			 
9eb8			 
9eb8			 
9eb8			; Cold Start - this is called to setup the whole Forth system 
9eb8			 
9eb8			forth_init: 
9eb8			 
9eb8				; setup stack over/under flow checks 
9eb8			 
9eb8			;	if DEBUG_FORTH_STACK_GUARD 
9eb8			;		call chk_stk_init 
9eb8			;	endif 
9eb8			 
9eb8				; enable auto display updates (slow.....) 
9eb8			 
9eb8 3e 01			ld a, 1 
9eba 32 3c ea			ld (cli_autodisplay), a 
9ebd			 
9ebd				; if storage is in use disable long reads for now 
9ebd 3e 00			ld a, 0 
9ebf 32 75 ea			ld (store_longread), a 
9ec2			 
9ec2			 
9ec2				; show start up screen 
9ec2			 
9ec2 cd ae 8a			call clear_display 
9ec5			 
9ec5 3e 00			ld a,0 
9ec7 32 5e ea			ld (f_cursor_ptr), a 
9eca			 
9eca				; set start of word list in start of ram - for use when creating user words 
9eca			 
9eca 21 71 e4			ld hl, baseram 
9ecd 22 be e5			ld (os_last_new_uword), hl 
9ed0 cd 71 9e			call user_word_eol 
9ed3				 
9ed3			;		call display_data_sp 
9ed3			;		call next_page_prompt 
9ed3			 
9ed3			 
9ed3			 
9ed3			 
9ed3 c9				ret 
9ed4			 
9ed4 .. 00		.bootforth: db " Forth Kernel Init ",0 
9ee8			 
9ee8			; TODO push to stack 
9ee8			 
9ee8			;  
9ee8			 
9ee8			if FORTH_PARSEV2 
9ee8			 
9ee8			 
9ee8				include "forth_parserv2.asm" 
9ee8			 
9ee8			endif 
9ee8			 
9ee8			 
9ee8			; parse cli version 1 
9ee8			 
9ee8			if FORTH_PARSEV1 
9ee8			 
9ee8			 
9ee8			 
9ee8			      include "forth_parserv1.asm" 
9ee8			endif 
9ee8				 
9ee8			if FORTH_PARSEV3 
9ee8			 
9ee8			 
9ee8			 
9ee8			      include "forth_parserv3.asm" 
9ee8				include "forth_wordsv3.asm" 
9ee8			endif 
9ee8			 
9ee8			if FORTH_PARSEV4 
9ee8			 
9ee8			 
9ee8			 
9ee8			      include "forth_parserv4.asm" 
9ee8				include "forth_wordsv4.asm" 
9ee8			endif 
9ee8			 
9ee8			if FORTH_PARSEV5 
9ee8			 
9ee8			 
9ee8			 
9ee8			      include "forth_parserv5.asm" 
9ee8			 
9ee8			 
9ee8			; A better parser without using malloc and string copies all over the place.  
9ee8			; Exec in situ should be faster 
9ee8			 
9ee8			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9ee8			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9ee8			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9ee8			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9ee8			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9ee8			WORD_SYS_END: equ 0   ; Opcode for all user words 
9ee8			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9ee8			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9ee8			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9ee8			 
9ee8			; Core word preamble macro 
9ee8			 
9ee8			CWHEAD:   macro nxtword opcode lit len opflags 
9ee8				db WORD_SYS_CORE+opcode             
9ee8				; internal op code number 
9ee8				dw nxtword            
9ee8				; link to next dict word block 
9ee8				db len + 1 
9ee8				; literal length of dict word inc zero term 
9ee8				db lit,0              
9ee8				; literal dict word 
9ee8			        ; TODO db opflags        
9ee8				endm 
9ee8			 
9ee8			 
9ee8			NEXTW: macro  
9ee8				jp macro_next 
9ee8				endm 
9ee8			 
9ee8			macro_next: 
9ee8			if DEBUG_FORTH_PARSE_KEY 
9ee8				DMARK "NXT" 
9ee8				CALLMONITOR 
9ee8			endif	 
9ee8			;	inc hl  ; skip token null term  
9ee8 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9eec ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9ef0 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9ef3			if DEBUG_FORTH_PARSE_KEY 
9ef3				DMARK "}AA" 
9ef3				CALLMONITOR 
9ef3			endif	 
9ef3 c3 f6 9f			jp execnext 
9ef6				;jp exec1 
9ef6			       
9ef6			 
9ef6			 
9ef6			; Another go at the parser to compile  
9ef6			 
9ef6			 
9ef6			; TODO rework parser to change all of the string words to byte tokens 
9ef6			; TODO do a search for  
9ef6			 
9ef6			; TODO first run normal parser to zero term sections 
9ef6			; TODO for each word do a token look up to get the op code 
9ef6			; TODO need some means to flag to the exec that this is a byte code form    
9ef6			 
9ef6			 
9ef6			forthcompile: 
9ef6			 
9ef6			; 
9ef6			; line parse: 
9ef6			;       parse raw input buffer 
9ef6			;       tokenise the words 
9ef6			;       malloc new copy (for looping etc) 
9ef6			;       copy to malloc + current pc in line to start of string and add line term 
9ef6			;       save on new rsp 
9ef6			; 
9ef6			 
9ef6			; hl to point to the line to tokenise 
9ef6			 
9ef6			;	push hl 
9ef6 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9ef9			 
9ef9			;	ld a,0		; string term on input 
9ef9			;	call strlent 
9ef9			 
9ef9			;	ld (os_tok_len), hl	 ; save string length 
9ef9			 
9ef9			;if DEBUG_FORTH_TOK 
9ef9			;	ex de,hl		 
9ef9			;endif 
9ef9			 
9ef9			;	pop hl 		; get back string pointer 
9ef9			 
9ef9			if DEBUG_FORTH_TOK 
9ef9						DMARK "TOc" 
9ef9				CALLMONITOR 
9ef9			endif 
9ef9 7e			.cptoken2:    ld a,(hl) 
9efa 23				inc hl 
9efb fe 7f			cp FORTH_END_BUFFER 
9efd 28 29			jr z, .cptokendone2 
9eff fe 00			cp 0 
9f01 28 25			jr z, .cptokendone2 
9f03 fe 22			cp '"' 
9f05 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9f07 fe 20			cp ' ' 
9f09 20 ee			jr nz,  .cptoken2 
9f0b			 
9f0b			; TODO consume comments held between ( and ) 
9f0b			 
9f0b				; we have a space so change to zero term for dict match later 
9f0b 2b				dec hl 
9f0c 3e 00			ld a,0 
9f0e 77				ld (hl), a 
9f0f 23				inc hl 
9f10 18 e7			jr .cptoken2 
9f12				 
9f12			 
9f12			.cptokenstr2: 
9f12				; skip all white space until either eol (because forgot to term) or end double quote 
9f12			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f12				;inc hl ; skip current double quote 
9f12 7e				ld a,(hl) 
9f13 23				inc hl 
9f14 fe 22			cp '"' 
9f16 28 e1			jr z, .cptoken2 
9f18 fe 7f			cp FORTH_END_BUFFER 
9f1a 28 0c			jr z, .cptokendone2 
9f1c fe 00			cp 0 
9f1e 28 08			jr z, .cptokendone2 
9f20 fe 20			cp ' ' 
9f22 28 02			jr z, .cptmp2 
9f24 18 ec			jr .cptokenstr2 
9f26			 
9f26			.cptmp2:	; we have a space so change to zero term for dict match later 
9f26				;dec hl 
9f26				;ld a,"-"	; TODO remove this when working 
9f26				;ld (hl), a 
9f26				;inc hl 
9f26 18 ea			jr .cptokenstr2 
9f28			 
9f28			.cptokendone2: 
9f28				;inc hl 
9f28 3e 7f			ld a, FORTH_END_BUFFER 
9f2a 77				ld (hl),a 
9f2b 23				inc hl 
9f2c 3e 21			ld a, '!' 
9f2e 77				ld (hl),a 
9f2f			 
9f2f 2a c2 e5			ld hl,(os_tok_ptr) 
9f32			         
9f32			if DEBUG_FORTH_TOK 
9f32						DMARK "Tc1" 
9f32				CALLMONITOR 
9f32			endif 
9f32			 
9f32				; push exec string to top of return stack 
9f32				FORTH_RSP_NEXT 
9f32 cd e2 9a			call macro_forth_rsp_next 
9f35				endm 
# End of macro FORTH_RSP_NEXT
9f35 c9				ret 
9f36			 
9f36			; Another go at the parser need to simplify the process 
9f36			 
9f36			forthparse: 
9f36			 
9f36			; 
9f36			; line parse: 
9f36			;       parse raw input buffer 
9f36			;       tokenise the words 
9f36			;       malloc new copy (for looping etc) 
9f36			;       copy to malloc + current pc in line to start of string and add line term 
9f36			;       save on new rsp 
9f36			; 
9f36			 
9f36			; hl to point to the line to tokenise 
9f36			 
9f36			;	push hl 
9f36 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f39			 
9f39			;	ld a,0		; string term on input 
9f39			;	call strlent 
9f39			 
9f39			;	ld (os_tok_len), hl	 ; save string length 
9f39			 
9f39			;if DEBUG_FORTH_TOK 
9f39			;	ex de,hl		 
9f39			;endif 
9f39			 
9f39			;	pop hl 		; get back string pointer 
9f39			 
9f39			if DEBUG_FORTH_TOK 
9f39						DMARK "TOK" 
9f39				CALLMONITOR 
9f39			endif 
9f39 7e			.ptoken2:    ld a,(hl) 
9f3a 23				inc hl 
9f3b fe 7f			cp FORTH_END_BUFFER 
9f3d 28 29			jr z, .ptokendone2 
9f3f fe 00			cp 0 
9f41 28 25			jr z, .ptokendone2 
9f43 fe 22			cp '"' 
9f45 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f47 fe 20			cp ' ' 
9f49 20 ee			jr nz,  .ptoken2 
9f4b			 
9f4b			; TODO consume comments held between ( and ) 
9f4b			 
9f4b				; we have a space so change to zero term for dict match later 
9f4b 2b				dec hl 
9f4c 3e 00			ld a,0 
9f4e 77				ld (hl), a 
9f4f 23				inc hl 
9f50 18 e7			jr .ptoken2 
9f52				 
9f52			 
9f52			.ptokenstr2: 
9f52				; skip all white space until either eol (because forgot to term) or end double quote 
9f52			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f52				;inc hl ; skip current double quote 
9f52 7e				ld a,(hl) 
9f53 23				inc hl 
9f54 fe 22			cp '"' 
9f56 28 e1			jr z, .ptoken2 
9f58 fe 7f			cp FORTH_END_BUFFER 
9f5a 28 0c			jr z, .ptokendone2 
9f5c fe 00			cp 0 
9f5e 28 08			jr z, .ptokendone2 
9f60 fe 20			cp ' ' 
9f62 28 02			jr z, .ptmp2 
9f64 18 ec			jr .ptokenstr2 
9f66			 
9f66			.ptmp2:	; we have a space so change to zero term for dict match later 
9f66				;dec hl 
9f66				;ld a,"-"	; TODO remove this when working 
9f66				;ld (hl), a 
9f66				;inc hl 
9f66 18 ea			jr .ptokenstr2 
9f68			 
9f68			.ptokendone2: 
9f68				;inc hl 
9f68 3e 7f			ld a, FORTH_END_BUFFER 
9f6a 77				ld (hl),a 
9f6b 23				inc hl 
9f6c 3e 21			ld a, '!' 
9f6e 77				ld (hl),a 
9f6f			 
9f6f 2a c2 e5			ld hl,(os_tok_ptr) 
9f72			         
9f72			if DEBUG_FORTH_TOK 
9f72						DMARK "TK1" 
9f72				CALLMONITOR 
9f72			endif 
9f72			 
9f72				; push exec string to top of return stack 
9f72				FORTH_RSP_NEXT 
9f72 cd e2 9a			call macro_forth_rsp_next 
9f75				endm 
# End of macro FORTH_RSP_NEXT
9f75 c9				ret 
9f76			 
9f76			; 
9f76			;	; malloc size + buffer pointer + if is loop flag 
9f76			;	ld hl,(os_tok_len) 		 ; get string length 
9f76			; 
9f76			;	ld a,l 
9f76			; 
9f76			;	cp 0			; we dont want to use a null string 
9f76			;	ret z 
9f76			; 
9f76			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f76			; 
9f76			;	add 5     ; TODO when certain not over writing memory remove 
9f76			; 
9f76			;		 
9f76			; 
9f76			;if DEBUG_FORTH_TOK 
9f76			;			DMARK "TKE" 
9f76			;	CALLMONITOR 
9f76			;endif 
9f76			; 
9f76			;	ld l,a 
9f76			;	ld h,0 
9f76			;;	push hl   ; save required space for the copy later 
9f76			;	call malloc 
9f76			;if DEBUG_FORTH_TOK 
9f76			;			DMARK "TKM" 
9f76			;	CALLMONITOR 
9f76			;endif 
9f76			;	if DEBUG_FORTH_MALLOC_GUARD 
9f76			;		push af 
9f76			;		call ishlzero 
9f76			;;		ld a, l 
9f76			;;		add h 
9f76			;;		cp 0 
9f76			;		pop af 
9f76			;		 
9f76			;		call z,malloc_error 
9f76			;	endif 
9f76			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f76			; 
9f76			; 
9f76			;if DEBUG_FORTH_TOK 
9f76			;			DMARK "TKR" 
9f76			;	CALLMONITOR 
9f76			;endif 
9f76			; 
9f76			;	FORTH_RSP_NEXT 
9f76			; 
9f76			;	;inc hl	 ; go past current buffer pointer 
9f76			;	;inc hl 
9f76			;	;inc hl   ; and past if loop flag 
9f76			;		; TODO Need to set flag  
9f76			; 
9f76			;	 
9f76			;	 
9f76			;	ex de,hl	; malloc is dest 
9f76			;	ld hl, (os_tok_len) 
9f76			;;	pop bc 
9f76			;	ld c, l                
9f76			;	ld b,0 
9f76			;	ld hl, (os_tok_ptr) 
9f76			; 
9f76			;if DEBUG_FORTH_TOK 
9f76			;			DMARK "TKT" 
9f76			;	CALLMONITOR 
9f76			;endif 
9f76			; 
9f76			;	; do str cpy 
9f76			; 
9f76			;	ldir      ; copy byte in hl to de 
9f76			; 
9f76			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f76			; 
9f76			;if DEBUG_FORTH_TOK 
9f76			; 
9f76			;			DMARK "TKY" 
9f76			;	CALLMONITOR 
9f76			;endif 
9f76			;	;ld a,0 
9f76			;	;ld a,FORTH_END_BUFFER 
9f76			;	ex de, hl 
9f76			;	;dec hl			 ; go back over the space delim at the end of word 
9f76			;	;ld (hl),a 
9f76			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f76			;	ld a,FORTH_END_BUFFER 
9f76			;	ld (hl),a 
9f76			;	inc hl 
9f76			;	ld a,FORTH_END_BUFFER 
9f76			;	ld (hl),a 
9f76			; 
9f76			;	; init the malloc area data 
9f76			;	; set pc for in current area 
9f76			;	;ld hl, (os_tok_malloc) 
9f76			;	;inc hl 
9f76			;	;inc hl 
9f76			;	;inc hl 
9f76			;	;ex de,hl 
9f76			;	;ld hl, (os_tok_malloc) 
9f76			;	;ld (hl),e 
9f76			;	;inc hl 
9f76			;	;ld (hl),d 
9f76			; 
9f76			; 
9f76			;	ld hl,(os_tok_malloc) 
9f76			;if DEBUG_FORTH_PARSE_KEY 
9f76			;			DMARK "TKU" 
9f76			;	CALLMONITOR 
9f76			;endif 
9f76			; 
9f76			;	ret 
9f76			 
9f76			forthexec: 
9f76			 
9f76			; line exec: 
9f76			; forth parser 
9f76			 
9f76			; 
9f76			;       get current exec line on rsp 
9f76			 
9f76				FORTH_RSP_TOS 
9f76 cd f9 9a			call macro_forth_rsp_tos 
9f79				endm 
# End of macro FORTH_RSP_TOS
9f79			 
9f79			;       restore current pc - hl points to malloc of data 
9f79			 
9f79				;ld e, (hl) 
9f79				;inc hl 
9f79				;ld d, (hl) 
9f79				;ex de,hl 
9f79			 
9f79			 
9f79			exec1: 
9f79 22 c2 e5			ld (os_tok_ptr), hl 
9f7c			 
9f7c				; copy our PC to working vars  
9f7c 22 40 ea			ld (cli_ptr), hl 
9f7f 22 3e ea			ld (cli_origptr), hl 
9f82			 
9f82 7e				ld a,(hl) 
9f83 fe 7f			cp FORTH_END_BUFFER 
9f85 c8				ret z 
9f86			 
9f86				; skip any nulls 
9f86			 
9f86 fe 00			cp 0 
9f88 20 03			jr nz, .execword 
9f8a 23				inc hl 
9f8b 18 ec			jr exec1 
9f8d			 
9f8d			 
9f8d			.execword: 
9f8d			 
9f8d			 
9f8d			 
9f8d			if DEBUG_FORTH_PARSE_KEY 
9f8d						DMARK "KYQ" 
9f8d				CALLMONITOR 
9f8d			endif 
9f8d			;       while at start of word: 
9f8d			; get start of dict (in user area first) 
9f8d			 
9f8d 21 71 e4		ld hl, baseram 
9f90			;ld hl, sysdict 
9f90 22 42 ea		ld (cli_nextword),hl 
9f93			;           match word at pc 
9f93			;           exec word 
9f93			;           or push to dsp 
9f93			;           forward to next token 
9f93			;           if line term pop rsp and exit 
9f93			;        
9f93			 
9f93			if DEBUG_FORTH_PARSE_KEY 
9f93						DMARK "KYq" 
9f93				CALLMONITOR 
9f93			endif 
9f93			 
9f93			; 
9f93			; word comp 
9f93			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f93			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f93			;    move to start of word  
9f93			;    compare word to cli_token 
9f93			 
9f93			.execpnword:	; HL at start of a word in the dictionary to check 
9f93			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9f93			;	ld (cli_ptr), hl 
9f93			 
9f93 2a 42 ea			ld hl,(cli_nextword) 
9f96			 
9f96 cd 39 a0			call forth_tok_next 
9f99			; tok next start here 
9f99			;	; TODO skip compiled symbol for now 
9f99			;	inc hl 
9f99			; 
9f99			;	; save pointer to next word 
9f99			; 
9f99			;	; hl now points to the address of the next word pointer  
9f99			;	ld e, (hl) 
9f99			;	inc hl 
9f99			;	ld d, (hl) 
9f99			;	inc l 
9f99			; 
9f99			;	ex de,hl 
9f99			;if DEBUG_FORTH_PARSE_NEXTWORD 
9f99			;	push bc 
9f99			;	ld bc, (cli_nextword) 
9f99			;			DMARK "NXW" 
9f99			;	CALLMONITOR 
9f99			;	pop bc 
9f99			;endif 
9f99			; tok next end here 
9f99 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f9c eb				ex de, hl 
9f9d			 
9f9d			 
9f9d				; save the pointer of the current token - 1 to check against 
9f9d				 
9f9d 22 46 ea			ld (cli_token), hl   
9fa0				; TODO maybe remove below save if no debug 
9fa0				; save token string ptr for any debug later 
9fa0 23				inc hl  
9fa1 22 48 ea			ld (cli_origtoken), hl 
9fa4 2b				dec hl 
9fa5				; save pointer to the start of the next dictionay word 
9fa5 7e				ld a,(hl)   ; get string length 
9fa6 47				ld b,a 
9fa7			.execpnwordinc:  
9fa7 23				inc hl 
9fa8 10 fd			djnz .execpnwordinc 
9faa 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9fad			 
9fad				; now check the word token against the string being parsed 
9fad			 
9fad 2a 46 ea			ld hl,(cli_token) 
9fb0 23				inc hl     ; skip string length (use zero term instead to end) 
9fb1 22 46 ea			ld (cli_token), hl 
9fb4			 
9fb4			if DEBUG_FORTH_PARSE_KEY 
9fb4						DMARK "KY2" 
9fb4			endif 
9fb4			if DEBUG_FORTH_PARSE_EXEC 
9fb4				; see if disabled 
9fb4			 
9fb4			;	ld a, (os_view_disable) 
9fb4			;	cp '*' 
9fb4				ld a, (debug_vector) 
9fb4				cp $c9   ; RET  
9fb4				jr z, .skip 
9fb4			 
9fb4				push hl 
9fb4				push hl 
9fb4				call clear_display 
9fb4				ld de, .compword 
9fb4				ld a, display_row_1 
9fb4				call str_at_display 
9fb4				pop de 
9fb4				ld a, display_row_2 
9fb4				call str_at_display 
9fb4				ld hl,(cli_ptr) 
9fb4				ld a,(hl) 
9fb4			        ld hl, os_word_scratch 
9fb4				ld (hl),a 
9fb4				ld a,0 
9fb4				inc hl 
9fb4				ld (hl),a 	 
9fb4				ld de, os_word_scratch 
9fb4				ld a, display_row_2+10 
9fb4				call str_at_display 
9fb4				call update_display 
9fb4				ld a, 100 
9fb4				call aDelayInMS 
9fb4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fb4				call delay250ms 
9fb4				endif 
9fb4				pop hl 
9fb4			.skip:  
9fb4			endif	 
9fb4			.execpnchar:    ; compare char between token and string to parse 
9fb4			 
9fb4			if DEBUG_FORTH_PARSE_KEY 
9fb4						DMARK "Ky3" 
9fb4			endif 
9fb4			if DEBUG_FORTH_PARSE_EXEC 
9fb4				; see if disabled 
9fb4			 
9fb4			;	ld a, (os_view_disable) 
9fb4			;	cp '*' 
9fb4				ld a, (debug_vector) 
9fb4				cp $C9  ; RET 
9fb4				jr z, .skip2 
9fb4			 
9fb4			;	call clear_display 
9fb4			ld hl,(cli_token) 
9fb4			ld a,(hl) 
9fb4			ld (os_word_scratch),a 
9fb4				ld hl,(cli_ptr) 
9fb4			ld a,(hl) 
9fb4				ld (os_word_scratch+1),a 
9fb4				ld a,0 
9fb4				ld (os_word_scratch+2),a 
9fb4				ld de,os_word_scratch 
9fb4				ld a,display_row_4 
9fb4				call str_at_display 
9fb4				call update_display 
9fb4			.skip2:  
9fb4			endif 
9fb4 2a 46 ea			ld hl,(cli_token) 
9fb7 7e				ld a, (hl)	 ; char in word token 
9fb8 23				inc hl 		; move to next char 
9fb9 22 46 ea			ld (cli_token), hl ; and save it 
9fbc 47				ld b,a 
9fbd			 
9fbd 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9fc0 7e				ld a,(hl) 
9fc1 23				inc hl 
9fc2 22 40 ea			ld (cli_ptr), hl		; move to next char 
9fc5 cd 30 91			call toUpper 		; make sure the input string matches case 
9fc8			 
9fc8			if DEBUG_FORTH_PARSE 
9fc8			endif 
9fc8			 
9fc8				; input stream end of token is a space so get rid of it 
9fc8			 
9fc8			;	cp ' ' 
9fc8			;	jr nz, .pnskipspace 
9fc8			; 
9fc8			;	ld a, 0		; make same term as word token term 
9fc8			; 
9fc8			;.pnskipspace: 
9fc8			 
9fc8			if DEBUG_FORTH_PARSE_KEY 
9fc8						DMARK "KY7" 
9fc8			endif 
9fc8 b8				cp b 
9fc9 c2 df 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9fcc				 
9fcc			;    if same 
9fcc			;       scan for string terms 0 for token and 32 for input 
9fcc			 
9fcc				 
9fcc			if DEBUG_FORTH_PARSE_KEY 
9fcc						DMARK "KY8" 
9fcc			endif 
9fcc			 
9fcc 80				add b			 
9fcd fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fcf							; TODO need to make sure last word in zero term string is accounted for 
9fcf 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9fd1			 
9fd1			 
9fd1				; at end of both strings so both are exact match 
9fd1			 
9fd1			;       skip ptr for next word 
9fd1			 
9fd1 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9fd4 23				inc hl			 ; at next char 
9fd5 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9fd8 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9fdb				 
9fdb				 
9fdb			if DEBUG_FORTH_PARSE_KEY 
9fdb						DMARK "KY3" 
9fdb			endif 
9fdb			 
9fdb			 
9fdb			 
9fdb			;       exec code block 
9fdb			if DEBUG_FORTH_JP 
9fdb				call clear_display 
9fdb				call update_display 
9fdb				call delay1s 
9fdb				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fdb				ld a,h 
9fdb				ld hl, os_word_scratch 
9fdb				call hexout 
9fdb				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fdb				ld a,l 
9fdb				ld hl, os_word_scratch+2 
9fdb				call hexout 
9fdb				ld hl, os_word_scratch+4 
9fdb				ld a,0 
9fdb				ld (hl),a 
9fdb				ld de,os_word_scratch 
9fdb				call str_at_display 
9fdb					ld a, display_row_2 
9fdb					call str_at_display 
9fdb				ld de, (cli_origtoken) 
9fdb				ld a, display_row_1+10 
9fdb					call str_at_display 
9fdb			 
9fdb				ld a,display_row_1 
9fdb				ld de, .foundword 
9fdb				ld a, display_row_3 
9fdb				call str_at_display 
9fdb				call update_display 
9fdb				call delay1s 
9fdb				call delay1s 
9fdb				call delay1s 
9fdb			endif 
9fdb			 
9fdb			if DEBUG_FORTH_PARSE_KEY 
9fdb						DMARK "KYj" 
9fdb			endif 
9fdb				; TODO save the word pointer in this exec 
9fdb			 
9fdb 2a 44 ea			ld hl,(cli_execword) 
9fde e9				jp (hl) 
9fdf			 
9fdf			 
9fdf			;    if not same 
9fdf			;	scan for zero term 
9fdf			;	get ptr for next word 
9fdf			;	goto word comp 
9fdf			 
9fdf			.execpnskipword:	; get pointer to next word 
9fdf 2a 42 ea			ld hl,(cli_nextword) 
9fe2			 
9fe2 7e				ld a,(hl) 
9fe3 fe 00			cp WORD_SYS_END 
9fe5			;	cp 0 
9fe5 28 09			jr z, .execendofdict			 ; at end of words 
9fe7			 
9fe7			if DEBUG_FORTH_PARSE_KEY 
9fe7						DMARK "KY4" 
9fe7			endif 
9fe7			if DEBUG_FORTH_PARSE_EXEC 
9fe7			 
9fe7				; see if disabled 
9fe7			 
9fe7			;	ld a, (os_view_disable) 
9fe7			;	cp '*' 
9fe7				ld a,(debug_vector) 
9fe7				cp $c9   ; RET 
9fe7				jr z, .noskip 
9fe7			 
9fe7			 
9fe7				ld de, .nowordfound 
9fe7				ld a, display_row_3 
9fe7				call str_at_display 
9fe7				call update_display 
9fe7				ld a, 100 
9fe7				call aDelayInMS 
9fe7				 
9fe7				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fe7					call delay250ms 
9fe7				endif 
9fe7			.noskip:  
9fe7			 
9fe7			endif	 
9fe7			 
9fe7 2a 3e ea			ld hl,(cli_origptr) 
9fea 22 40 ea			ld (cli_ptr),hl 
9fed			 
9fed			if DEBUG_FORTH_PARSE_KEY 
9fed						DMARK "KY5" 
9fed			endif 
9fed c3 93 9f			jp .execpnword			; else go to next word 
9ff0			 
9ff0			.execendofdict:  
9ff0			 
9ff0			if DEBUG_FORTH_PARSE_KEY 
9ff0						DMARK "KYe" 
9ff0			endif 
9ff0			if DEBUG_FORTH_PARSE_EXEC 
9ff0				; see if disabled 
9ff0			 
9ff0			;	ld a, (os_view_disable) 
9ff0			;	cp '*' 
9ff0				ld a,(debug_vector) 
9ff0				cp $c9   ; ret 
9ff0				jr z, .ispskip 
9ff0			 
9ff0				call clear_display 
9ff0				call update_display 
9ff0				call delay1s 
9ff0				ld de, (cli_origptr) 
9ff0				ld a, display_row_1 
9ff0				call str_at_display 
9ff0				 
9ff0				ld de, .enddict 
9ff0				ld a, display_row_3 
9ff0				call str_at_display 
9ff0				call update_display 
9ff0				ld a, 100 
9ff0				call aDelayInMS 
9ff0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ff0				call delay1s 
9ff0				call delay1s 
9ff0				call delay1s 
9ff0				endif 
9ff0			.ispskip:  
9ff0				 
9ff0			endif	 
9ff0			 
9ff0			 
9ff0			 
9ff0				; if the word is not a keyword then must be a literal so push it to stack 
9ff0			 
9ff0			; push token to stack to end of word 
9ff0			 
9ff0				STACKFRAME ON $1efe $2f9f 
9ff0				if DEBUG_STACK_IMB 
9ff0					if ON 
9ff0						exx 
9ff0						ld de, $1efe 
9ff0						ld a, d 
9ff0						ld hl, curframe 
9ff0						call hexout 
9ff0						ld a, e 
9ff0						ld hl, curframe+2 
9ff0						call hexout 
9ff0						ld hl, $1efe 
9ff0						push hl 
9ff0						ld hl, $2f9f 
9ff0						push hl 
9ff0						exx 
9ff0					endif 
9ff0				endif 
9ff0			endm 
# End of macro STACKFRAME
9ff0			 
9ff0 2a c2 e5		ld hl,(os_tok_ptr) 
9ff3 cd a4 9c		call forth_apush 
9ff6			 
9ff6				STACKFRAMECHK ON $1efe $2f9f 
9ff6				if DEBUG_STACK_IMB 
9ff6					if ON 
9ff6						exx 
9ff6						ld hl, $2f9f 
9ff6						pop de   ; $2f9f 
9ff6						call cmp16 
9ff6						jr nz, .spnosame 
9ff6						ld hl, $1efe 
9ff6						pop de   ; $1efe 
9ff6						call cmp16 
9ff6						jr z, .spfrsame 
9ff6						.spnosame: call showsperror 
9ff6						.spfrsame: nop 
9ff6						exx 
9ff6					endif 
9ff6				endif 
9ff6			endm 
# End of macro STACKFRAMECHK
9ff6			 
9ff6			execnext: 
9ff6			 
9ff6			if DEBUG_FORTH_PARSE_KEY 
9ff6						DMARK "KY>" 
9ff6			endif 
9ff6			; move past token to next word 
9ff6			 
9ff6 2a c2 e5		ld hl, (os_tok_ptr) 
9ff9 3e 00		ld a, 0 
9ffb 01 ff 00		ld bc, 255     ; input buffer size 
9ffe ed b1		cpir 
a000			 
a000			if DEBUG_FORTH_PARSE_KEY 
a000						DMARK "KY!" 
a000				CALLMONITOR 
a000			endif	 
a000			; TODO this might place hl on the null, so will need to forward on??? 
a000			;inc hl   ; see if this gets onto the next item 
a000			 
a000			 
a000			; TODO pass a pointer to the buffer to push 
a000			; TODO call function to push 
a000			 
a000			; look for end of input 
a000			 
a000			;inc hl 
a000			;ld a,(hl) 
a000			;cp FORTH_END_BUFFER 
a000			;ret z 
a000			 
a000			 
a000 c3 79 9f		jp exec1 
a003			 
a003			 
a003			 
a003			 
a003			 
a003			 
a003			 
a003			 
a003			 
a003			findnexttok: 
a003			 
a003				; hl is pointer to move 
a003				; de is the token to locate 
a003			 
a003					if DEBUG_FORTH 
a003						DMARK "NTK" 
a003						CALLMONITOR 
a003					endif 
a003 d5				push de 
a004			 
a004			.fnt1:	 
a004				; find first char of token to locate 
a004			 
a004 1a				ld a, (de) 
a005 4f				ld c,a 
a006 7e				ld a,(hl) 
a007 cd 30 91			call toUpper 
a00a					if DEBUG_FORTH 
a00a						DMARK "NT1" 
a00a						CALLMONITOR 
a00a					endif 
a00a b9				cp c 
a00b			 
a00b 28 03			jr z, .fnt2cmpmorefirst	 
a00d			 
a00d				; first char not found move to next char 
a00d			 
a00d 23				inc hl 
a00e 18 f4			jr .fnt1 
a010			 
a010			.fnt2cmpmorefirst:	 
a010				; first char of token found.  
a010			 
a010 e5				push hl     ; save start of token just in case it is the right one 
a011 d9				exx 
a012 e1				pop hl        ; save it to hl' 
a013 d9				exx 
a014			 
a014			 
a014			.fnt2cmpmore:	 
a014				; compare the rest 
a014				 
a014 23				inc hl 
a015 13				inc de 
a016				 
a016 1a				ld a, (de) 
a017 4f				ld c,a 
a018 7e				ld a,(hl) 
a019 cd 30 91			call toUpper 
a01c			 
a01c					if DEBUG_FORTH 
a01c						DMARK "NT2" 
a01c						CALLMONITOR 
a01c					endif 
a01c				; c has the token to find char 
a01c				; a has the mem to scan char 
a01c			 
a01c b9				cp c 
a01d 28 04			jr z,.fntmatch1 
a01f			 
a01f				; they are not the same 
a01f			 
a01f					if DEBUG_FORTH 
a01f						DMARK "NT3" 
a01f						CALLMONITOR 
a01f					endif 
a01f d1				pop de	; reset de token to look for 
a020 d5				push de 
a021 18 e1			jr .fnt1 
a023				 
a023			.fntmatch1: 
a023			 
a023				; is the same char a null which means we might have a full hit? 
a023					if DEBUG_FORTH 
a023						DMARK "NT4" 
a023						CALLMONITOR 
a023					endif 
a023			 
a023 fe 00			cp 0 
a025 28 0b			jr z, .fntmatchyes 
a027			 
a027				; are we at the end of the token to find? 
a027			 
a027					if DEBUG_FORTH 
a027						DMARK "NT5" 
a027						CALLMONITOR 
a027					endif 
a027 3e 00			ld a, 0 
a029 b9				cp c 
a02a			 
a02a c2 14 a0			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a02d			 
a02d					if DEBUG_FORTH 
a02d						DMARK "NT6" 
a02d						CALLMONITOR 
a02d					endif 
a02d				; token to find is exhusted but no match to stream 
a02d			 
a02d				; restore tok pointer and continue on 
a02d d1				pop de 
a02e d5				push de 
a02f c3 04 a0			jp .fnt1 
a032			 
a032			 
a032			.fntmatchyes: 
a032			 
a032				; hl now contains the end of the found token 
a032			 
a032				; get rid of saved token pointer to find 
a032			 
a032 d1				pop de 
a033			 
a033					if DEBUG_FORTH 
a033						DMARK "NT9" 
a033						CALLMONITOR 
a033					endif 
a033			 
a033				; hl will be on the null term so forward on 
a033			 
a033				; get back the saved start of the token 
a033			 
a033 d9				exx 
a034 e5				push hl     ; save start of token just in case it is the right one 
a035 d9				exx 
a036 e1				pop hl        ; save it to hl 
a037			 
a037 c9				ret 
a038			 
a038			 
a038			; LIST needs to find a specific token   
a038			; FORGET needs to find a spefici token 
a038			 
a038			; SAVE needs to find all tokens by flag 
a038			; WORDS just needs to scan through all  by flag 
a038			; UWORDS needs to scan through all by flag 
a038			 
a038			 
a038			; given hl as pointer to start of dict look up string 
a038			; return hl as pointer to start of word block 
a038			; or 0 if not found 
a038			 
a038			forth_find_tok: 
a038 c9				ret 
a039			 
a039			; given hl as pointer to dict structure 
a039			; move to the next dict block structure 
a039			 
a039			forth_tok_next: 
a039				; hl now points to the address of the next word pointer  
a039				; TODO skip compiled symbol for now 
a039			;	push de 
a039 23				inc hl 
a03a 5e				ld e, (hl) 
a03b 23				inc hl 
a03c 56				ld d, (hl) 
a03d 23				inc hl 
a03e			 
a03e eb				ex de,hl 
a03f			if DEBUG_FORTH_PARSE_NEXTWORD 
a03f				push bc 
a03f				ld bc, (cli_nextword) 
a03f						DMARK "NXW" 
a03f				CALLMONITOR 
a03f				pop bc 
a03f			endif 
a03f			;	pop de	 
a03f c9				ret 
a040			 
a040			 
a040			 
a040			; eof 
# End of file forth_parserv5.asm
a040				include "forth_wordsv4.asm" 
a040			 
a040			; the core word dictionary v4 
a040			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a040			 
a040			; this is a linked list for each of the system words used 
a040			; user defined words will follow the same format but will be in ram 
a040			 
a040			 
a040			; 
a040			; 
a040			; define linked list: 
a040			; 
a040			; 1. compiled byte op code 
a040			; 2. len of text word 
a040			; 3. text word 
a040			; 4. ptr to next dictionary word 
a040			; 5. asm, calls etc for the word 
a040			; 
a040			;  if 1 == 0 then last word in dict  
a040			;   
a040			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a040			;  
a040			;  
a040			; create basic standard set of words 
a040			; 
a040			;  
a040			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a040			; 2DUP 2DROP 2SWAP  
a040			; @ C@ - get byte  
a040			; ! C! - store byte 
a040			; 0< true if less than zero 
a040			; 0= true if zero 
a040			; < >  
a040			; = true if same 
a040			; variables 
a040			 
a040			 
a040			; Hardware specific words I may need 
a040			; 
a040			; IN OUT  
a040			; calls to key util functions 
a040			; calls to hardward abstraction stuff 
a040			; easy control of frame buffers and lcd i/o 
a040			; keyboard  
a040			 
a040			 
a040			;DICT: macro 
a040			; op_code, len, word, next 
a040			;    word: 
a040			;    db op_code 
a040			;    ds word zero term 
a040			;    dw next 
a040			;    endm 
a040			 
a040			 
a040			 
a040			 
a040			; op code 1 is a flag for user define words which are to be handled differently 
a040			 
a040			 
a040			; 
a040			; 
a040			;    TODO on entry to a word this should be the expected environment 
a040			;    hl - tos value if number then held, if string this is the ptr 
a040			;    de -  
a040			 
a040			 
a040			; opcode ranges 
a040			; 0 - end of word dict 
a040			; 255 - user define words 
a040			 
a040			sysdict: 
a040			include "forth_opcodes.asm" 
a040			; op codes for forth keywords 
a040			; free to use code 0  
a040				OPCODE_HEAP: equ  1 
a040				OPCODE_EXEC: equ 2 
a040				OPCODE_DUP: equ 3 
a040				OPCODE_SWAP: equ 4 
a040				OPCODE_COLN: equ 5 
a040				OPCODE_SCOLN: equ 6 
a040				OPCODE_DROP: equ 7 
a040				OPCODE_DUP2: equ 8 
a040				OPCODE_DROP2: equ 9 
a040				OPCODE_SWAP2: equ 10 
a040				OPCODE_AT: equ 11 
a040				OPCODE_CAT: equ 12 
a040				OPCODE_BANG: equ 13 
a040				OPCODE_CBANG: equ 14 
a040				OPCODE_SCALL: equ 15 
a040				OPCODE_DEPTH: equ 16 
a040				OPCODE_OVER: equ 17 
a040				OPCODE_PAUSE: equ 18 
a040				OPCODE_PAUSES: equ 19 
a040				OPCODE_ROT: equ 20 
a040			;free to reuse	OPCODE_WORDS: equ 21 
a040			        OPCODE_NOT: equ 21 
a040				OPCODE_UWORDS: equ 22 
a040				OPCODE_BP: equ 23 
a040				OPCODE_MONITOR: equ 24  
a040				OPCODE_MALLOC: equ 25 
a040				OPCODE_FREE: equ 26 
a040				OPCODE_LIST: equ 27 
a040				OPCODE_FORGET: equ 28 
a040				OPCODE_NOP: equ 29 
a040				OPCODE_COMO: equ 30 
a040				OPCODE_COMC: equ 31 
a040			;free to reuse	OPCODE_ENDCORE: equ 32 
a040				OPCODE_AFTERSOUND: equ 33 
a040				OPCODE_GP2: equ 34 
a040				OPCODE_GP3: equ 35 
a040				OPCODE_GP4: equ 36 
a040				OPCODE_SIN: equ 37 
a040				OPCODE_SOUT: equ 38 
a040				OPCODE_SPIO: equ 39 
a040				OPCODE_SPICEH: equ 40 
a040				OPCODE_SPIOb: equ 41 
a040				OPCODE_SPII: equ 42 
a040				OPCODE_SESEL: equ 43 
a040				OPCODE_CARTDEV: equ 44 
a040			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a040				OPCODE_FB: equ 46 
a040				OPCODE_EMIT: equ 47 
a040				OPCODE_DOTH: equ 48 
a040				OPCODE_DOTF: equ 49 
a040				OPCODE_DOT: equ 50 
a040				OPCODE_CLS: equ 51 
a040				OPCODE_DRAW: equ 52 
a040				OPCODE_DUMP: equ 53 
a040				OPCODE_CDUMP: equ 54 
a040				OPCODE_DAT: equ 55 
a040				OPCODE_HOME: equ 56 
a040				OPCODE_SPACE: equ 57 
a040				OPCODE_SPACES: equ 58 
a040				OPCODE_SCROLL: equ 59 
a040				OPCODE_ATQ: equ 60 
a040				OPCODE_AUTODSP: equ 61 
a040				OPCODE_MENU: equ 62 
a040			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a040				OPCODE_THEN: equ 64 
a040				OPCODE_ELSE: equ 65 
a040				OPCODE_DO: equ 66 
a040				OPCODE_LOOP: equ 67 
a040				OPCODE_I: equ 68 
a040				OPCODE_DLOOP: equ 69  
a040				OPCODE_REPEAT: equ 70  
a040				OPCODE_UNTIL: equ 71 
a040				OPCODE_ENDFLOW: equ 72 
a040				OPCODE_WAITK: equ 73 
a040				OPCODE_ACCEPT: equ 74 
a040				OPCODE_EDIT: equ 75 
a040			;free to reuse	OPCODE_ENDKEY: equ 76 
a040				OPCODE_LZERO: equ 77 
a040				OPCODE_TZERO: equ 78 
a040				OPCODE_LESS: equ 79 
a040				OPCODE_GT: equ 80 
a040				OPCODE_EQUAL: equ 81  
a040			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a040				OPCODE_NEG: equ 83 
a040				OPCODE_DIV: equ 84 
a040				OPCODE_MUL: equ 85 
a040				OPCODE_MIN: equ 86 
a040				OPCODE_MAX: equ 87 
a040				OPCODE_RND16: equ 88 
a040				OPCODE_RND8: equ 89 
a040				OPCODE_RND: equ 90 
a040			;free to reuse	OPCODE_ENDMATHS: equ 91  
a040				OPCODE_BYNAME: equ 92 
a040				OPCODE_DIR: equ 93 
a040				OPCODE_SAVE: equ 94 
a040				OPCODE_LOAD: equ 95 
a040				OPCODE_BSAVE: equ 96 
a040				OPCODE_BLOAD: equ 97 
a040				OPCODE_SEO: equ 98  
a040				OPCODE_SEI: equ 99 
a040				OPCODE_SFREE: equ 100 
a040				OPCODE_SIZE: equ 101 
a040				OPCODE_CREATE: equ 102 
a040				OPCODE_APPEND: equ 103 
a040				OPCODE_SDEL: equ 104 
a040				OPCODE_OPEN: equ 105 
a040				OPCODE_READ: equ 106 
a040				OPCODE_EOF: equ 106 
a040				OPCODE_FORMAT: equ 107 
a040				OPCODE_LABEL: equ 108 
a040				OPCODE_LABELS: equ 109 
a040			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a040				OPCODE_UPPER: equ 111 
a040				OPCODE_LOWER: equ 112 
a040				OPCODE_SUBSTR: equ 113 
a040				OPCODE_LEFT: equ 114 
a040				OPCODE_RIGHT: equ 115 
a040				OPCODE_STR2NUM: equ 116 
a040				OPCODE_NUM2STR: equ 117 
a040				OPCODE_CONCAT: equ 118 
a040				OPCODE_FIND: equ 119 
a040				OPCODE_LEN: equ 120 
a040				OPCODE_CHAR: equ 121 
a040			; free to reuse	OPCODE_STRLEN: equ 122 
a040			; free to reuse	OPCODE_ENDSTR: equ 123 
a040				OPCODE_V0S: equ 124 
a040				OPCODE_V0Q: equ 125 
a040				OPCODE_V1S: equ 126 
a040				OPCODE_V1Q: equ 127 
a040				OPCODE_V2S: equ 128 
a040				OPCODE_V2Q: equ 129 
a040				OPCODE_V3S: equ 130 
a040				OPCODE_V3Q: equ 131 
a040			;free to reuse	OPCODE_END: equ 132 
a040				OPCODE_ZDUP: equ 133 
a040			 
a040			; eof 
# End of file forth_opcodes.asm
a040			 
a040			include "forth_words_core.asm" 
a040			 
a040			; | ## Core Words 
a040			 
a040			;if MALLOC_4 
a040			 
a040			.HEAP: 
a040			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a040 15				db WORD_SYS_CORE+OPCODE_HEAP             
a041 7f a0			dw .EXEC            
a043 05				db 4 + 1 
a044 .. 00			db "HEAP",0              
a049				endm 
# End of macro CWHEAD
a049			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a049			; | | u1 - Current number of bytes in the heap 
a049			; | | u2 - Remaining bytes left on the heap 
a049			; | |  
a049			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a049			 
a049			 
a049				if DEBUG_FORTH_WORDS_KEY 
a049					DMARK "HEP" 
a049 f5				push af  
a04a 3a 5e a0			ld a, (.dmark)  
a04d 32 6b ee			ld (debug_mark),a  
a050 3a 5f a0			ld a, (.dmark+1)  
a053 32 6c ee			ld (debug_mark+1),a  
a056 3a 60 a0			ld a, (.dmark+2)  
a059 32 6d ee			ld (debug_mark+2),a  
a05c 18 03			jr .pastdmark  
a05e ..			.dmark: db "HEP"  
a061 f1			.pastdmark: pop af  
a062			endm  
# End of macro DMARK
a062					CALLMONITOR 
a062 cd 6f ee			call debug_vector  
a065				endm  
# End of macro CALLMONITOR
a065				endif 
a065 2a 7b e4			ld hl, (free_list )      
a068 11 80 e4			ld de, heap_start 
a06b			 
a06b ed 52			sbc hl, de  
a06d			 
a06d cd 3b 9b			call forth_push_numhl 
a070			 
a070			 
a070 ed 5b 7b e4		ld de, (free_list )      
a074 21 9c e2			ld hl, heap_end 
a077			 
a077 ed 52			sbc hl, de 
a079			 
a079 cd 3b 9b			call forth_push_numhl 
a07c				 
a07c			 
a07c				 
a07c			 
a07c			 
a07c			 
a07c				NEXTW 
a07c c3 e8 9e			jp macro_next 
a07f				endm 
# End of macro NEXTW
a07f			;endif 
a07f			 
a07f			.EXEC: 
a07f			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a07f			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a07f			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a07f			;; > > 
a07f			;; > >   
a07f			;	STACKFRAME OFF $5efe $5f9f 
a07f			; 
a07f			;		if DEBUG_FORTH_WORDS_KEY 
a07f			;			DMARK "EXE" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			; 
a07f			;	FORTH_DSP_VALUEHL 
a07f			; 
a07f			;	FORTH_DSP_POP 
a07f			; 
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EX1" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			;;	ld e,(hl) 
a07f			;;	inc hl 
a07f			;;	ld d,(hl) 
a07f			;;	ex de,hl 
a07f			; 
a07f			;;		if DEBUG_FORTH_WORDS 
a07f			;;			DMARK "EX2" 
a07f			;;			CALLMONITOR 
a07f			;;		endif 
a07f			;	push hl 
a07f			; 
a07f			;	;ld a, 0 
a07f			;	;ld a, FORTH_END_BUFFER 
a07f			;	call strlenz 
a07f			;	inc hl   ; include zero term to copy 
a07f			;	inc hl   ; include term 
a07f			;	inc hl   ; include term 
a07f			;	ld b,0 
a07f			;	ld c,l 
a07f			;	pop hl 
a07f			;	ld de, execscratch 
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EX3" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			;	ldir 
a07f			; 
a07f			; 
a07f			;	ld hl, execscratch 
a07f			; 
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EXe" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			; 
a07f			;	call forthparse 
a07f			;	call forthexec 
a07f			;;	call forthexec_cleanup 
a07f			;;	call forthparse 
a07f			;;	call forthexec 
a07f			; 
a07f			;	STACKFRAMECHK OFF $5efe $5f9f 
a07f			; 
a07f			;	; an immediate word so no need to process any more words 
a07f			;	ret 
a07f			;	NEXTW 
a07f			 
a07f			; dead code - old version  
a07f			;	FORTH_RSP_NEXT 
a07f			 
a07f			;  
a07f			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a07f			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a07f			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a07f			;	push hl 
a07f			;	push de 
a07f			;	push bc 
a07f			; 
a07f			; 
a07f			;		if DEBUG_FORTH_WORDS_KEY 
a07f			;			DMARK "EXR" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			; 
a07f			; 
a07f			; 
a07f			;	;v5 FORTH_DSP_VALUE 
a07f			;	FORTH_DSP_VALUEHL 
a07f			; 
a07f			;	; TODO do string type checks 
a07f			; 
a07f			;;v5	inc hl   ; skip type 
a07f			; 
a07f			;	push hl  ; source code  
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EX1" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			;	ld a, 0 
a07f			;	call strlent 
a07f			; 
a07f			;	inc hl 
a07f			;	inc hl 
a07f			;	inc hl 
a07f			;	inc hl 
a07f			; 
a07f			;	push hl    ; size 
a07f			; 
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EX2" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			;	call malloc 
a07f			; 
a07f			;	ex de, hl    ; de now contains malloc area 
a07f			;	pop bc   	; get byte count 
a07f			;	pop hl      ; get string to copy 
a07f			; 
a07f			;	push de     ; save malloc for free later 
a07f			; 
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EX3" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			;	ldir       ; duplicate string 
a07f			; 
a07f			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a07f			;	 
a07f			;	; TODO fix the parse would be better than this...  
a07f			;	ex de, hl 
a07f			;	dec hl 
a07f			;	ld a, 0 
a07f			;	ld (hl), a 
a07f			;	dec hl 
a07f			;	ld a, ' ' 
a07f			;	ld (hl), a 
a07f			;	dec hl 
a07f			;	ld (hl), a 
a07f			; 
a07f			;	dec hl 
a07f			;	ld (hl), a 
a07f			; 
a07f			; 
a07f			;	FORTH_DSP_POP  
a07f			; 
a07f			;	pop hl     
a07f			;	push hl    ; save malloc area 
a07f			; 
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EX4" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			; 
a07f			;	call forthparse 
a07f			;	call forthexec 
a07f			;	 
a07f			;	pop hl 
a07f			;	if DEBUG_FORTH_WORDS 
a07f			;		DMARK "EX5" 
a07f			;		CALLMONITOR 
a07f			;	endif 
a07f			; 
a07f			;	if FORTH_ENABLE_FREE 
a07f			;	call free 
a07f			;	endif 
a07f			; 
a07f			;	if DEBUG_FORTH_WORDS 
a07f			;		DMARK "EX6" 
a07f			;		CALLMONITOR 
a07f			;	endif 
a07f			; 
a07f			;	pop bc 
a07f			;	pop de 
a07f			;	pop hl 
a07f			;;	FORTH_RSP_POP	  
a07f			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a07f			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a07f			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a07f			; 
a07f			;	if DEBUG_FORTH_WORDS 
a07f			;		DMARK "EX7" 
a07f			;		CALLMONITOR 
a07f			;	endif 
a07f			;	NEXTW 
a07f			 
a07f			;.STKEXEC: 
a07f			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a07f			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a07f			; 
a07f			; 
a07f			;		if DEBUG_FORTH_WORDS_KEY 
a07f			;			DMARK "STX" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			; 
a07f			;	FORTH_DSP_VALUEHL 
a07f			; 
a07f			;	ld (store_tmp1), hl    ; count 
a07f			; 
a07f			;	FORTH_DSP_POP 
a07f			;.stkexec1: 
a07f			;	ld hl, (store_tmp1)   ; count 
a07f			;	ld a, 0 
a07f			;	cp l 
a07f			;	ret z 
a07f			; 
a07f			;	dec hl 
a07f			;	ld (store_tmp1), hl    ; count 
a07f			;	 
a07f			;	FORTH_DSP_VALUEHL 
a07f			;	push hl 
a07f			;	 
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EXp" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			;	FORTH_DSP_POP 
a07f			; 
a07f			;	call strlenz 
a07f			;	inc hl   ; include zero term to copy 
a07f			;	inc hl   ; include zero term to copy 
a07f			;	inc hl   ; include zero term to copy 
a07f			;	ld b,0 
a07f			;	ld c,l 
a07f			;	pop hl 
a07f			;	ld de, execscratch 
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EX3" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			;	ldir 
a07f			; 
a07f			; 
a07f			;	ld hl, execscratch 
a07f			; 
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EXP" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			; 
a07f			;	call forthparse 
a07f			;	ld hl, execscratch 
a07f			;		if DEBUG_FORTH_WORDS 
a07f			;			DMARK "EXx" 
a07f			;			CALLMONITOR 
a07f			;		endif 
a07f			;	call forthexec 
a07f			; 
a07f			;	jp .stkexec1 
a07f			; 
a07f			;	ret 
a07f			 
a07f			 
a07f			.DUP: 
a07f			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a07f 17				db WORD_SYS_CORE+OPCODE_DUP             
a080 f5 a0			dw .ZDUP            
a082 04				db 3 + 1 
a083 .. 00			db "DUP",0              
a087				endm 
# End of macro CWHEAD
a087			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a087			 
a087				if DEBUG_FORTH_WORDS_KEY 
a087					DMARK "DUP" 
a087 f5				push af  
a088 3a 9c a0			ld a, (.dmark)  
a08b 32 6b ee			ld (debug_mark),a  
a08e 3a 9d a0			ld a, (.dmark+1)  
a091 32 6c ee			ld (debug_mark+1),a  
a094 3a 9e a0			ld a, (.dmark+2)  
a097 32 6d ee			ld (debug_mark+2),a  
a09a 18 03			jr .pastdmark  
a09c ..			.dmark: db "DUP"  
a09f f1			.pastdmark: pop af  
a0a0			endm  
# End of macro DMARK
a0a0					CALLMONITOR 
a0a0 cd 6f ee			call debug_vector  
a0a3				endm  
# End of macro CALLMONITOR
a0a3				endif 
a0a3			 
a0a3				FORTH_DSP 
a0a3 cd f8 9c			call macro_forth_dsp 
a0a6				endm 
# End of macro FORTH_DSP
a0a6			 
a0a6 7e				ld a, (HL) 
a0a7 fe 01			cp DS_TYPE_STR 
a0a9 20 25			jr nz, .dupinum 
a0ab			 
a0ab				; push another string 
a0ab			 
a0ab				FORTH_DSP_VALUEHL     		 
a0ab cd 32 9d			call macro_dsp_valuehl 
a0ae				endm 
# End of macro FORTH_DSP_VALUEHL
a0ae			 
a0ae			if DEBUG_FORTH_WORDS 
a0ae				DMARK "DUs" 
a0ae f5				push af  
a0af 3a c3 a0			ld a, (.dmark)  
a0b2 32 6b ee			ld (debug_mark),a  
a0b5 3a c4 a0			ld a, (.dmark+1)  
a0b8 32 6c ee			ld (debug_mark+1),a  
a0bb 3a c5 a0			ld a, (.dmark+2)  
a0be 32 6d ee			ld (debug_mark+2),a  
a0c1 18 03			jr .pastdmark  
a0c3 ..			.dmark: db "DUs"  
a0c6 f1			.pastdmark: pop af  
a0c7			endm  
# End of macro DMARK
a0c7				CALLMONITOR 
a0c7 cd 6f ee			call debug_vector  
a0ca				endm  
# End of macro CALLMONITOR
a0ca			endif 
a0ca cd a9 9b			call forth_push_str 
a0cd			 
a0cd				NEXTW 
a0cd c3 e8 9e			jp macro_next 
a0d0				endm 
# End of macro NEXTW
a0d0			 
a0d0			 
a0d0			.dupinum: 
a0d0				 
a0d0			 
a0d0			 
a0d0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0d0 cd 32 9d			call macro_dsp_valuehl 
a0d3				endm 
# End of macro FORTH_DSP_VALUEHL
a0d3			 
a0d3			; TODO add floating point number detection 
a0d3			 
a0d3			if DEBUG_FORTH_WORDS 
a0d3				DMARK "DUi" 
a0d3 f5				push af  
a0d4 3a e8 a0			ld a, (.dmark)  
a0d7 32 6b ee			ld (debug_mark),a  
a0da 3a e9 a0			ld a, (.dmark+1)  
a0dd 32 6c ee			ld (debug_mark+1),a  
a0e0 3a ea a0			ld a, (.dmark+2)  
a0e3 32 6d ee			ld (debug_mark+2),a  
a0e6 18 03			jr .pastdmark  
a0e8 ..			.dmark: db "DUi"  
a0eb f1			.pastdmark: pop af  
a0ec			endm  
# End of macro DMARK
a0ec				CALLMONITOR 
a0ec cd 6f ee			call debug_vector  
a0ef				endm  
# End of macro CALLMONITOR
a0ef			endif 
a0ef			 
a0ef cd 3b 9b			call forth_push_numhl 
a0f2				NEXTW 
a0f2 c3 e8 9e			jp macro_next 
a0f5				endm 
# End of macro NEXTW
a0f5			.ZDUP: 
a0f5			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a0f5 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a0f6 2d a1			dw .SWAP            
a0f8 05				db 4 + 1 
a0f9 .. 00			db "?DUP",0              
a0fe				endm 
# End of macro CWHEAD
a0fe			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a0fe			 
a0fe				if DEBUG_FORTH_WORDS_KEY 
a0fe					DMARK "qDU" 
a0fe f5				push af  
a0ff 3a 13 a1			ld a, (.dmark)  
a102 32 6b ee			ld (debug_mark),a  
a105 3a 14 a1			ld a, (.dmark+1)  
a108 32 6c ee			ld (debug_mark+1),a  
a10b 3a 15 a1			ld a, (.dmark+2)  
a10e 32 6d ee			ld (debug_mark+2),a  
a111 18 03			jr .pastdmark  
a113 ..			.dmark: db "qDU"  
a116 f1			.pastdmark: pop af  
a117			endm  
# End of macro DMARK
a117					CALLMONITOR 
a117 cd 6f ee			call debug_vector  
a11a				endm  
# End of macro CALLMONITOR
a11a				endif 
a11a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a11a cd 32 9d			call macro_dsp_valuehl 
a11d				endm 
# End of macro FORTH_DSP_VALUEHL
a11d			 
a11d e5				push hl 
a11e			 
a11e				; is it a zero? 
a11e			 
a11e 3e 00			ld a, 0 
a120 84				add h 
a121 85				add l 
a122			 
a122 e1				pop hl 
a123			 
a123 fe 00			cp 0 
a125 28 03			jr z, .dup2orig 
a127			 
a127			 
a127 cd 3b 9b			call forth_push_numhl 
a12a			 
a12a			 
a12a			; TODO add floating point number detection 
a12a			 
a12a			.dup2orig: 
a12a			 
a12a				NEXTW 
a12a c3 e8 9e			jp macro_next 
a12d				endm 
# End of macro NEXTW
a12d			.SWAP: 
a12d			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a12d 18				db WORD_SYS_CORE+OPCODE_SWAP             
a12e 6c a1			dw .COLN            
a130 05				db 4 + 1 
a131 .. 00			db "SWAP",0              
a136				endm 
# End of macro CWHEAD
a136			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a136				if DEBUG_FORTH_WORDS_KEY 
a136					DMARK "SWP" 
a136 f5				push af  
a137 3a 4b a1			ld a, (.dmark)  
a13a 32 6b ee			ld (debug_mark),a  
a13d 3a 4c a1			ld a, (.dmark+1)  
a140 32 6c ee			ld (debug_mark+1),a  
a143 3a 4d a1			ld a, (.dmark+2)  
a146 32 6d ee			ld (debug_mark+2),a  
a149 18 03			jr .pastdmark  
a14b ..			.dmark: db "SWP"  
a14e f1			.pastdmark: pop af  
a14f			endm  
# End of macro DMARK
a14f					CALLMONITOR 
a14f cd 6f ee			call debug_vector  
a152				endm  
# End of macro CALLMONITOR
a152				endif 
a152			 
a152			; TODO Use os stack swap memory 
a152				FORTH_DSP_VALUEHL 
a152 cd 32 9d			call macro_dsp_valuehl 
a155				endm 
# End of macro FORTH_DSP_VALUEHL
a155 e5				push hl     ; w2 
a156			 
a156				FORTH_DSP_POP 
a156 cd ea 9d			call macro_forth_dsp_pop 
a159				endm 
# End of macro FORTH_DSP_POP
a159			 
a159				FORTH_DSP_VALUEHL 
a159 cd 32 9d			call macro_dsp_valuehl 
a15c				endm 
# End of macro FORTH_DSP_VALUEHL
a15c			 
a15c				FORTH_DSP_POP 
a15c cd ea 9d			call macro_forth_dsp_pop 
a15f				endm 
# End of macro FORTH_DSP_POP
a15f			 
a15f d1				pop de     ; w2	, hl = w1 
a160			 
a160 eb				ex de, hl 
a161 d5				push de 
a162			 
a162 cd 3b 9b			call forth_push_numhl 
a165			 
a165 e1				pop hl 
a166			 
a166 cd 3b 9b			call forth_push_numhl 
a169				 
a169			 
a169				NEXTW 
a169 c3 e8 9e			jp macro_next 
a16c				endm 
# End of macro NEXTW
a16c			.COLN: 
a16c			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a16c 19				db WORD_SYS_CORE+OPCODE_COLN             
a16d f8 a2			dw .SCOLN            
a16f 02				db 1 + 1 
a170 .. 00			db ":",0              
a172				endm 
# End of macro CWHEAD
a172			; | : ( -- )         Create new word | DONE 
a172			 
a172				if DEBUG_FORTH_WORDS_KEY 
a172					DMARK "CLN" 
a172 f5				push af  
a173 3a 87 a1			ld a, (.dmark)  
a176 32 6b ee			ld (debug_mark),a  
a179 3a 88 a1			ld a, (.dmark+1)  
a17c 32 6c ee			ld (debug_mark+1),a  
a17f 3a 89 a1			ld a, (.dmark+2)  
a182 32 6d ee			ld (debug_mark+2),a  
a185 18 03			jr .pastdmark  
a187 ..			.dmark: db "CLN"  
a18a f1			.pastdmark: pop af  
a18b			endm  
# End of macro DMARK
a18b					CALLMONITOR 
a18b cd 6f ee			call debug_vector  
a18e				endm  
# End of macro CALLMONITOR
a18e				endif 
a18e			STACKFRAME OFF $8efe $989f 
a18e				if DEBUG_STACK_IMB 
a18e					if OFF 
a18e						exx 
a18e						ld de, $8efe 
a18e						ld a, d 
a18e						ld hl, curframe 
a18e						call hexout 
a18e						ld a, e 
a18e						ld hl, curframe+2 
a18e						call hexout 
a18e						ld hl, $8efe 
a18e						push hl 
a18e						ld hl, $989f 
a18e						push hl 
a18e						exx 
a18e					endif 
a18e				endif 
a18e			endm 
# End of macro STACKFRAME
a18e			; get parser buffer length  of new word 
a18e			 
a18e			 
a18e			 
a18e				; move tok past this to start of name defintition 
a18e				; TODO get word to define 
a18e				; TODO Move past word token 
a18e				; TODO get length of string up to the ';' 
a18e			 
a18e 2a c2 e5		ld hl, (os_tok_ptr) 
a191 23			inc hl 
a192 23			inc hl 
a193			 
a193 3e 3b		ld a, ';' 
a195 cd 44 91		call strlent 
a198			 
a198 7d			ld a,l 
a199 32 b1 e2		ld (os_new_parse_len), a 
a19c			 
a19c			 
a19c			if DEBUG_FORTH_UWORD 
a19c ed 5b c2 e5	ld de, (os_tok_ptr) 
a1a0					DMARK ":01" 
a1a0 f5				push af  
a1a1 3a b5 a1			ld a, (.dmark)  
a1a4 32 6b ee			ld (debug_mark),a  
a1a7 3a b6 a1			ld a, (.dmark+1)  
a1aa 32 6c ee			ld (debug_mark+1),a  
a1ad 3a b7 a1			ld a, (.dmark+2)  
a1b0 32 6d ee			ld (debug_mark+2),a  
a1b3 18 03			jr .pastdmark  
a1b5 ..			.dmark: db ":01"  
a1b8 f1			.pastdmark: pop af  
a1b9			endm  
# End of macro DMARK
a1b9			CALLMONITOR 
a1b9 cd 6f ee			call debug_vector  
a1bc				endm  
# End of macro CALLMONITOR
a1bc			endif 
a1bc			 
a1bc			; 
a1bc			;  new word memory layout: 
a1bc			;  
a1bc			;    : adg 6666 ;  
a1bc			; 
a1bc			;    db   1     ; user defined word  
a1bc 23			inc hl    
a1bd			;    dw   sysdict 
a1bd 23			inc hl 
a1be 23			inc hl 
a1bf			;    db <word len>+1 (for null) 
a1bf 23			inc hl 
a1c0			;    db .... <word> 
a1c0			; 
a1c0			 
a1c0 23			inc hl    ; some extras for the word preamble before the above 
a1c1 23			inc hl 
a1c2 23			inc hl 
a1c3 23			inc hl 
a1c4 23			inc hl 
a1c5 23			inc hl 
a1c6 23			inc hl  
a1c7 23			inc hl 
a1c8 23			inc hl 
a1c9 23			inc hl 
a1ca 23			inc hl 
a1cb 23			inc hl 
a1cc 23			inc hl 
a1cd 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a1ce			;       exec word buffer 
a1ce			;	<ptr word>   
a1ce 23			inc hl 
a1cf 23			inc hl 
a1d0			;       <word list><null term> 7F final term 
a1d0			 
a1d0			 
a1d0			if DEBUG_FORTH_UWORD 
a1d0					DMARK ":02" 
a1d0 f5				push af  
a1d1 3a e5 a1			ld a, (.dmark)  
a1d4 32 6b ee			ld (debug_mark),a  
a1d7 3a e6 a1			ld a, (.dmark+1)  
a1da 32 6c ee			ld (debug_mark+1),a  
a1dd 3a e7 a1			ld a, (.dmark+2)  
a1e0 32 6d ee			ld (debug_mark+2),a  
a1e3 18 03			jr .pastdmark  
a1e5 ..			.dmark: db ":02"  
a1e8 f1			.pastdmark: pop af  
a1e9			endm  
# End of macro DMARK
a1e9			CALLMONITOR 
a1e9 cd 6f ee			call debug_vector  
a1ec				endm  
# End of macro CALLMONITOR
a1ec			endif 
a1ec			 
a1ec			 
a1ec				; malloc the size 
a1ec			 
a1ec cd a2 91			call malloc 
a1ef 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
a1f2			 
a1f2			;    db   1     ; user defined word  
a1f2 3e 01			ld a, WORD_SYS_UWORD  
a1f4 77				ld (hl), a 
a1f5			 
a1f5 23			inc hl    
a1f6			;    dw   sysdict 
a1f6 11 40 a0		ld de, sysdict       ; continue on with the scan to the system dict 
a1f9 73			ld (hl), e 
a1fa 23			inc hl 
a1fb 72			ld (hl), d 
a1fc 23			inc hl 
a1fd			 
a1fd			 
a1fd			;    Setup dict word 
a1fd			 
a1fd 23			inc hl 
a1fe 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a201			 
a201			; 1. get length of dict word 
a201			 
a201			 
a201 2a c2 e5		ld hl, (os_tok_ptr) 
a204 23			inc hl 
a205 23			inc hl    ; position to start of dict word 
a206 3e 00		ld a, 0 
a208 cd 44 91		call strlent 
a20b			 
a20b			 
a20b 23			inc hl    ; to include null??? 
a20c			 
a20c			; write length of dict word 
a20c			 
a20c ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a210 1b			dec de 
a211 eb			ex de, hl 
a212 73			ld (hl), e 
a213 eb			ex de, hl 
a214			 
a214			 
a214			 
a214			; copy  
a214 4d			ld c, l 
a215 06 00		ld b, 0 
a217 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a21b 2a c2 e5		ld hl, (os_tok_ptr) 
a21e 23			inc hl 
a21f 23			inc hl    ; position to start of dict word 
a220			 
a220			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a220			 
a220			; TODO need to convert word to upper case 
a220			 
a220			ucasetok:	 
a220 7e			ld a,(hl) 
a221 cd 30 91		call toUpper 
a224 77			ld (hl),a 
a225 ed a0		ldi 
a227 f2 20 a2		jp p, ucasetok 
a22a			 
a22a			 
a22a			 
a22a			; de now points to start of where the word body code should be placed 
a22a ed 53 ad e2	ld (os_new_work_ptr), de 
a22e			; hl now points to the words to throw at forthexec which needs to be copied 
a22e 22 ab e2		ld (os_new_src_ptr), hl 
a231			 
a231			; TODO add 'call to forthexec' 
a231			 
a231			if DEBUG_FORTH_UWORD 
a231 c5			push bc 
a232 ed 4b b3 e2	ld bc, (os_new_malloc) 
a236					DMARK ":0x" 
a236 f5				push af  
a237 3a 4b a2			ld a, (.dmark)  
a23a 32 6b ee			ld (debug_mark),a  
a23d 3a 4c a2			ld a, (.dmark+1)  
a240 32 6c ee			ld (debug_mark+1),a  
a243 3a 4d a2			ld a, (.dmark+2)  
a246 32 6d ee			ld (debug_mark+2),a  
a249 18 03			jr .pastdmark  
a24b ..			.dmark: db ":0x"  
a24e f1			.pastdmark: pop af  
a24f			endm  
# End of macro DMARK
a24f			CALLMONITOR 
a24f cd 6f ee			call debug_vector  
a252				endm  
# End of macro CALLMONITOR
a252 c1			pop bc 
a253			endif 
a253			 
a253			 
a253			; create word preamble which should be: 
a253			 
a253			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a253			 
a253			;    ld hl, <word code> 
a253			;    jp user_exec 
a253			;    <word code bytes> 
a253			 
a253			 
a253			;	inc de     ; TODO ??? or are we already past the word's null 
a253 eb			ex de, hl 
a254			 
a254 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a256			 
a256 23			inc hl 
a257 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a25a 23			inc hl 
a25b			 
a25b 23			inc hl 
a25c 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a25e			 
a25e 01 99 cb		ld bc, user_exec 
a261 23			inc hl 
a262 71			ld (hl), c     ; poke address of user_exec 
a263 23			inc hl 
a264 70			ld (hl), b     
a265			; 
a265			;	inc hl 
a265			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a265			; 
a265			; 
a265			;	ld bc, macro_forth_rsp_next 
a265			;	inc hl 
a265			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a265			;	inc hl 
a265			;	ld (hl), b     
a265			; 
a265			;	inc hl 
a265			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a265			; 
a265			; 
a265			;	inc hl 
a265			;	ld bc, forthexec 
a265			;	ld (hl), c     ; poke address of forthexec 
a265			;	inc hl 
a265			;	ld (hl), b      
a265			; 
a265			;	inc hl 
a265			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a265			; 
a265			;	ld bc, user_dict_next 
a265			;	inc hl 
a265			;	ld (hl), c     ; poke address of forthexec 
a265			;	inc hl 
a265			;	ld (hl), b      
a265			 
a265			; hl is now where we need to copy the word byte data to save this 
a265			 
a265 23			inc hl 
a266 22 a9 e2		ld (os_new_exec), hl 
a269			 
a269			; copy definition 
a269			 
a269 eb			ex de, hl 
a26a			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a26a			;	inc de    ; skip the PC for this parse 
a26a 3a b1 e2		ld a, (os_new_parse_len) 
a26d 4f			ld c, a 
a26e 06 00		ld b, 0 
a270 ed b0		ldir		 ; copy defintion 
a272			 
a272			 
a272			; poke the address of where the new word bytes live for forthexec 
a272			 
a272 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a275			 
a275 ed 5b a9 e2	ld de, (os_new_exec)      
a279			 
a279 73			ld (hl), e 
a27a 23			inc hl 
a27b 72			ld (hl), d 
a27c			 
a27c				; TODO copy last user dict word next link to this word 
a27c				; TODO update last user dict word to point to this word 
a27c			; 
a27c			; hl f923 de 812a ; bc 811a 
a27c			 
a27c			if DEBUG_FORTH_UWORD 
a27c c5			push bc 
a27d ed 4b b3 e2	ld bc, (os_new_malloc) 
a281					DMARK ":0A" 
a281 f5				push af  
a282 3a 96 a2			ld a, (.dmark)  
a285 32 6b ee			ld (debug_mark),a  
a288 3a 97 a2			ld a, (.dmark+1)  
a28b 32 6c ee			ld (debug_mark+1),a  
a28e 3a 98 a2			ld a, (.dmark+2)  
a291 32 6d ee			ld (debug_mark+2),a  
a294 18 03			jr .pastdmark  
a296 ..			.dmark: db ":0A"  
a299 f1			.pastdmark: pop af  
a29a			endm  
# End of macro DMARK
a29a			CALLMONITOR 
a29a cd 6f ee			call debug_vector  
a29d				endm  
# End of macro CALLMONITOR
a29d c1			pop bc 
a29e			endif 
a29e			if DEBUG_FORTH_UWORD 
a29e c5			push bc 
a29f ed 4b b3 e2	ld bc, (os_new_malloc) 
a2a3 03			inc bc 
a2a4 03			inc bc 
a2a5 03			inc bc 
a2a6 03			inc bc 
a2a7 03			inc bc 
a2a8 03			inc bc 
a2a9 03			inc bc 
a2aa 03			inc bc 
a2ab			 
a2ab					DMARK ":0B" 
a2ab f5				push af  
a2ac 3a c0 a2			ld a, (.dmark)  
a2af 32 6b ee			ld (debug_mark),a  
a2b2 3a c1 a2			ld a, (.dmark+1)  
a2b5 32 6c ee			ld (debug_mark+1),a  
a2b8 3a c2 a2			ld a, (.dmark+2)  
a2bb 32 6d ee			ld (debug_mark+2),a  
a2be 18 03			jr .pastdmark  
a2c0 ..			.dmark: db ":0B"  
a2c3 f1			.pastdmark: pop af  
a2c4			endm  
# End of macro DMARK
a2c4			CALLMONITOR 
a2c4 cd 6f ee			call debug_vector  
a2c7				endm  
# End of macro CALLMONITOR
a2c7 c1			pop bc 
a2c8			endif 
a2c8			 
a2c8			; update word dict linked list for new word 
a2c8			 
a2c8			 
a2c8 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a2cb 23			inc hl     ; move to next work linked list ptr 
a2cc			 
a2cc ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
a2d0 73			ld (hl), e 
a2d1 23			inc hl 
a2d2 72			ld (hl), d 
a2d3			 
a2d3			if DEBUG_FORTH_UWORD 
a2d3 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2d7			endif 
a2d7			 
a2d7 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a2db			 
a2db			 
a2db			if DEBUG_FORTH_UWORD 
a2db					DMARK ":0+" 
a2db f5				push af  
a2dc 3a f0 a2			ld a, (.dmark)  
a2df 32 6b ee			ld (debug_mark),a  
a2e2 3a f1 a2			ld a, (.dmark+1)  
a2e5 32 6c ee			ld (debug_mark+1),a  
a2e8 3a f2 a2			ld a, (.dmark+2)  
a2eb 32 6d ee			ld (debug_mark+2),a  
a2ee 18 03			jr .pastdmark  
a2f0 ..			.dmark: db ":0+"  
a2f3 f1			.pastdmark: pop af  
a2f4			endm  
# End of macro DMARK
a2f4			CALLMONITOR 
a2f4 cd 6f ee			call debug_vector  
a2f7				endm  
# End of macro CALLMONITOR
a2f7			endif 
a2f7			 
a2f7			STACKFRAMECHK OFF $8efe $989f 
a2f7				if DEBUG_STACK_IMB 
a2f7					if OFF 
a2f7						exx 
a2f7						ld hl, $989f 
a2f7						pop de   ; $989f 
a2f7						call cmp16 
a2f7						jr nz, .spnosame 
a2f7						ld hl, $8efe 
a2f7						pop de   ; $8efe 
a2f7						call cmp16 
a2f7						jr z, .spfrsame 
a2f7						.spnosame: call showsperror 
a2f7						.spfrsame: nop 
a2f7						exx 
a2f7					endif 
a2f7				endif 
a2f7			endm 
# End of macro STACKFRAMECHK
a2f7			 
a2f7 c9			ret    ; dont process any remaining parser tokens as they form new word 
a2f8			 
a2f8			 
a2f8			 
a2f8			 
a2f8			;		NEXT 
a2f8			.SCOLN: 
a2f8			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a2f8 06			db OPCODE_SCOLN 
a2f9 44 a3		dw .DROP 
a2fb 02			db 2 
a2fc .. 00		db ";",0           
a2fe			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a2fe				if DEBUG_FORTH_WORDS_KEY 
a2fe					DMARK "SCN" 
a2fe f5				push af  
a2ff 3a 13 a3			ld a, (.dmark)  
a302 32 6b ee			ld (debug_mark),a  
a305 3a 14 a3			ld a, (.dmark+1)  
a308 32 6c ee			ld (debug_mark+1),a  
a30b 3a 15 a3			ld a, (.dmark+2)  
a30e 32 6d ee			ld (debug_mark+2),a  
a311 18 03			jr .pastdmark  
a313 ..			.dmark: db "SCN"  
a316 f1			.pastdmark: pop af  
a317			endm  
# End of macro DMARK
a317					CALLMONITOR 
a317 cd 6f ee			call debug_vector  
a31a				endm  
# End of macro CALLMONITOR
a31a				endif 
a31a				FORTH_RSP_TOS 
a31a cd f9 9a			call macro_forth_rsp_tos 
a31d				endm 
# End of macro FORTH_RSP_TOS
a31d e5				push hl 
a31e				FORTH_RSP_POP 
a31e cd 03 9b			call macro_forth_rsp_pop 
a321				endm 
# End of macro FORTH_RSP_POP
a321 e1				pop hl 
a322			;		ex de,hl 
a322 22 c2 e5			ld (os_tok_ptr),hl 
a325			 
a325			if DEBUG_FORTH_UWORD 
a325					DMARK "SCL" 
a325 f5				push af  
a326 3a 3a a3			ld a, (.dmark)  
a329 32 6b ee			ld (debug_mark),a  
a32c 3a 3b a3			ld a, (.dmark+1)  
a32f 32 6c ee			ld (debug_mark+1),a  
a332 3a 3c a3			ld a, (.dmark+2)  
a335 32 6d ee			ld (debug_mark+2),a  
a338 18 03			jr .pastdmark  
a33a ..			.dmark: db "SCL"  
a33d f1			.pastdmark: pop af  
a33e			endm  
# End of macro DMARK
a33e			CALLMONITOR 
a33e cd 6f ee			call debug_vector  
a341				endm  
# End of macro CALLMONITOR
a341			endif 
a341				NEXTW 
a341 c3 e8 9e			jp macro_next 
a344				endm 
# End of macro NEXTW
a344			 
a344			.DROP: 
a344			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a344 1b				db WORD_SYS_CORE+OPCODE_DROP             
a345 6f a3			dw .DUP2            
a347 05				db 4 + 1 
a348 .. 00			db "DROP",0              
a34d				endm 
# End of macro CWHEAD
a34d			; | DROP ( w -- )   drop the TOS item   | DONE 
a34d				if DEBUG_FORTH_WORDS_KEY 
a34d					DMARK "DRP" 
a34d f5				push af  
a34e 3a 62 a3			ld a, (.dmark)  
a351 32 6b ee			ld (debug_mark),a  
a354 3a 63 a3			ld a, (.dmark+1)  
a357 32 6c ee			ld (debug_mark+1),a  
a35a 3a 64 a3			ld a, (.dmark+2)  
a35d 32 6d ee			ld (debug_mark+2),a  
a360 18 03			jr .pastdmark  
a362 ..			.dmark: db "DRP"  
a365 f1			.pastdmark: pop af  
a366			endm  
# End of macro DMARK
a366					CALLMONITOR 
a366 cd 6f ee			call debug_vector  
a369				endm  
# End of macro CALLMONITOR
a369				endif 
a369				FORTH_DSP_POP 
a369 cd ea 9d			call macro_forth_dsp_pop 
a36c				endm 
# End of macro FORTH_DSP_POP
a36c				NEXTW 
a36c c3 e8 9e			jp macro_next 
a36f				endm 
# End of macro NEXTW
a36f			.DUP2: 
a36f			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a36f 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a370 b4 a3			dw .DROP2            
a372 05				db 4 + 1 
a373 .. 00			db "2DUP",0              
a378				endm 
# End of macro CWHEAD
a378			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a378				if DEBUG_FORTH_WORDS_KEY 
a378					DMARK "2DU" 
a378 f5				push af  
a379 3a 8d a3			ld a, (.dmark)  
a37c 32 6b ee			ld (debug_mark),a  
a37f 3a 8e a3			ld a, (.dmark+1)  
a382 32 6c ee			ld (debug_mark+1),a  
a385 3a 8f a3			ld a, (.dmark+2)  
a388 32 6d ee			ld (debug_mark+2),a  
a38b 18 03			jr .pastdmark  
a38d ..			.dmark: db "2DU"  
a390 f1			.pastdmark: pop af  
a391			endm  
# End of macro DMARK
a391					CALLMONITOR 
a391 cd 6f ee			call debug_vector  
a394				endm  
# End of macro CALLMONITOR
a394				endif 
a394				FORTH_DSP_VALUEHL 
a394 cd 32 9d			call macro_dsp_valuehl 
a397				endm 
# End of macro FORTH_DSP_VALUEHL
a397 e5				push hl      ; 2 
a398			 
a398				FORTH_DSP_POP 
a398 cd ea 9d			call macro_forth_dsp_pop 
a39b				endm 
# End of macro FORTH_DSP_POP
a39b				 
a39b				FORTH_DSP_VALUEHL 
a39b cd 32 9d			call macro_dsp_valuehl 
a39e				endm 
# End of macro FORTH_DSP_VALUEHL
a39e			;		push hl      ; 1 
a39e			 
a39e				FORTH_DSP_POP 
a39e cd ea 9d			call macro_forth_dsp_pop 
a3a1				endm 
# End of macro FORTH_DSP_POP
a3a1			 
a3a1			;		pop hl       ; 1 
a3a1 d1				pop de       ; 2 
a3a2			 
a3a2 cd 3b 9b			call forth_push_numhl 
a3a5 eb				ex de, hl 
a3a6 cd 3b 9b			call forth_push_numhl 
a3a9			 
a3a9				 
a3a9 eb				ex de, hl 
a3aa			 
a3aa cd 3b 9b			call forth_push_numhl 
a3ad eb				ex de, hl 
a3ae cd 3b 9b			call forth_push_numhl 
a3b1			 
a3b1			 
a3b1				NEXTW 
a3b1 c3 e8 9e			jp macro_next 
a3b4				endm 
# End of macro NEXTW
a3b4			.DROP2: 
a3b4			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a3b4 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a3b5 e3 a3			dw .SWAP2            
a3b7 06				db 5 + 1 
a3b8 .. 00			db "2DROP",0              
a3be				endm 
# End of macro CWHEAD
a3be			; | 2DROP ( w w -- )    Double drop | DONE 
a3be				if DEBUG_FORTH_WORDS_KEY 
a3be					DMARK "2DR" 
a3be f5				push af  
a3bf 3a d3 a3			ld a, (.dmark)  
a3c2 32 6b ee			ld (debug_mark),a  
a3c5 3a d4 a3			ld a, (.dmark+1)  
a3c8 32 6c ee			ld (debug_mark+1),a  
a3cb 3a d5 a3			ld a, (.dmark+2)  
a3ce 32 6d ee			ld (debug_mark+2),a  
a3d1 18 03			jr .pastdmark  
a3d3 ..			.dmark: db "2DR"  
a3d6 f1			.pastdmark: pop af  
a3d7			endm  
# End of macro DMARK
a3d7					CALLMONITOR 
a3d7 cd 6f ee			call debug_vector  
a3da				endm  
# End of macro CALLMONITOR
a3da				endif 
a3da				FORTH_DSP_POP 
a3da cd ea 9d			call macro_forth_dsp_pop 
a3dd				endm 
# End of macro FORTH_DSP_POP
a3dd				FORTH_DSP_POP 
a3dd cd ea 9d			call macro_forth_dsp_pop 
a3e0				endm 
# End of macro FORTH_DSP_POP
a3e0				NEXTW 
a3e0 c3 e8 9e			jp macro_next 
a3e3				endm 
# End of macro NEXTW
a3e3			.SWAP2: 
a3e3			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3e3 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3e4 0c a4			dw .AT            
a3e6 06				db 5 + 1 
a3e7 .. 00			db "2SWAP",0              
a3ed				endm 
# End of macro CWHEAD
a3ed			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3ed				if DEBUG_FORTH_WORDS_KEY 
a3ed					DMARK "2SW" 
a3ed f5				push af  
a3ee 3a 02 a4			ld a, (.dmark)  
a3f1 32 6b ee			ld (debug_mark),a  
a3f4 3a 03 a4			ld a, (.dmark+1)  
a3f7 32 6c ee			ld (debug_mark+1),a  
a3fa 3a 04 a4			ld a, (.dmark+2)  
a3fd 32 6d ee			ld (debug_mark+2),a  
a400 18 03			jr .pastdmark  
a402 ..			.dmark: db "2SW"  
a405 f1			.pastdmark: pop af  
a406			endm  
# End of macro DMARK
a406					CALLMONITOR 
a406 cd 6f ee			call debug_vector  
a409				endm  
# End of macro CALLMONITOR
a409				endif 
a409			; TODO Use os stack swap memory 
a409				NEXTW 
a409 c3 e8 9e			jp macro_next 
a40c				endm 
# End of macro NEXTW
a40c			.AT: 
a40c			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a40c 1f				db WORD_SYS_CORE+OPCODE_AT             
a40d 3e a4			dw .CAT            
a40f 02				db 1 + 1 
a410 .. 00			db "@",0              
a412				endm 
# End of macro CWHEAD
a412			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a412			 
a412				if DEBUG_FORTH_WORDS_KEY 
a412					DMARK "AT." 
a412 f5				push af  
a413 3a 27 a4			ld a, (.dmark)  
a416 32 6b ee			ld (debug_mark),a  
a419 3a 28 a4			ld a, (.dmark+1)  
a41c 32 6c ee			ld (debug_mark+1),a  
a41f 3a 29 a4			ld a, (.dmark+2)  
a422 32 6d ee			ld (debug_mark+2),a  
a425 18 03			jr .pastdmark  
a427 ..			.dmark: db "AT."  
a42a f1			.pastdmark: pop af  
a42b			endm  
# End of macro DMARK
a42b					CALLMONITOR 
a42b cd 6f ee			call debug_vector  
a42e				endm  
# End of macro CALLMONITOR
a42e				endif 
a42e			.getbyteat:	 
a42e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a42e cd 32 9d			call macro_dsp_valuehl 
a431				endm 
# End of macro FORTH_DSP_VALUEHL
a431				 
a431			;		push hl 
a431			 
a431				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a431 cd ea 9d			call macro_forth_dsp_pop 
a434				endm 
# End of macro FORTH_DSP_POP
a434			 
a434			;		pop hl 
a434			 
a434 7e				ld a, (hl) 
a435			 
a435 6f				ld l, a 
a436 26 00			ld h, 0 
a438 cd 3b 9b			call forth_push_numhl 
a43b			 
a43b				NEXTW 
a43b c3 e8 9e			jp macro_next 
a43e				endm 
# End of macro NEXTW
a43e			.CAT: 
a43e			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a43e 20				db WORD_SYS_CORE+OPCODE_CAT             
a43f 67 a4			dw .BANG            
a441 03				db 2 + 1 
a442 .. 00			db "C@",0              
a445				endm 
# End of macro CWHEAD
a445			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a445				if DEBUG_FORTH_WORDS_KEY 
a445					DMARK "CAA" 
a445 f5				push af  
a446 3a 5a a4			ld a, (.dmark)  
a449 32 6b ee			ld (debug_mark),a  
a44c 3a 5b a4			ld a, (.dmark+1)  
a44f 32 6c ee			ld (debug_mark+1),a  
a452 3a 5c a4			ld a, (.dmark+2)  
a455 32 6d ee			ld (debug_mark+2),a  
a458 18 03			jr .pastdmark  
a45a ..			.dmark: db "CAA"  
a45d f1			.pastdmark: pop af  
a45e			endm  
# End of macro DMARK
a45e					CALLMONITOR 
a45e cd 6f ee			call debug_vector  
a461				endm  
# End of macro CALLMONITOR
a461				endif 
a461 c3 2e a4			jp .getbyteat 
a464				NEXTW 
a464 c3 e8 9e			jp macro_next 
a467				endm 
# End of macro NEXTW
a467			.BANG: 
a467			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a467 21				db WORD_SYS_CORE+OPCODE_BANG             
a468 9d a4			dw .CBANG            
a46a 02				db 1 + 1 
a46b .. 00			db "!",0              
a46d				endm 
# End of macro CWHEAD
a46d			; | ! ( x w -- ) Store x at address w      | DONE 
a46d				if DEBUG_FORTH_WORDS_KEY 
a46d					DMARK "BNG" 
a46d f5				push af  
a46e 3a 82 a4			ld a, (.dmark)  
a471 32 6b ee			ld (debug_mark),a  
a474 3a 83 a4			ld a, (.dmark+1)  
a477 32 6c ee			ld (debug_mark+1),a  
a47a 3a 84 a4			ld a, (.dmark+2)  
a47d 32 6d ee			ld (debug_mark+2),a  
a480 18 03			jr .pastdmark  
a482 ..			.dmark: db "BNG"  
a485 f1			.pastdmark: pop af  
a486			endm  
# End of macro DMARK
a486					CALLMONITOR 
a486 cd 6f ee			call debug_vector  
a489				endm  
# End of macro CALLMONITOR
a489				endif 
a489			 
a489			.storebyteat:		 
a489				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a489 cd 32 9d			call macro_dsp_valuehl 
a48c				endm 
# End of macro FORTH_DSP_VALUEHL
a48c				 
a48c e5				push hl 
a48d			 
a48d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a48d cd ea 9d			call macro_forth_dsp_pop 
a490				endm 
# End of macro FORTH_DSP_POP
a490			 
a490				; get byte to poke 
a490			 
a490				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a490 cd 32 9d			call macro_dsp_valuehl 
a493				endm 
# End of macro FORTH_DSP_VALUEHL
a493 e5				push hl 
a494			 
a494			 
a494				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a494 cd ea 9d			call macro_forth_dsp_pop 
a497				endm 
# End of macro FORTH_DSP_POP
a497			 
a497			 
a497 d1				pop de 
a498 e1				pop hl 
a499			 
a499 73				ld (hl),e 
a49a			 
a49a			 
a49a				NEXTW 
a49a c3 e8 9e			jp macro_next 
a49d				endm 
# End of macro NEXTW
a49d			.CBANG: 
a49d			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a49d 22				db WORD_SYS_CORE+OPCODE_CBANG             
a49e c6 a4			dw .SCALL            
a4a0 03				db 2 + 1 
a4a1 .. 00			db "C!",0              
a4a4				endm 
# End of macro CWHEAD
a4a4			; | C!  ( x w -- ) Store x at address w  | DONE 
a4a4				if DEBUG_FORTH_WORDS_KEY 
a4a4					DMARK "CBA" 
a4a4 f5				push af  
a4a5 3a b9 a4			ld a, (.dmark)  
a4a8 32 6b ee			ld (debug_mark),a  
a4ab 3a ba a4			ld a, (.dmark+1)  
a4ae 32 6c ee			ld (debug_mark+1),a  
a4b1 3a bb a4			ld a, (.dmark+2)  
a4b4 32 6d ee			ld (debug_mark+2),a  
a4b7 18 03			jr .pastdmark  
a4b9 ..			.dmark: db "CBA"  
a4bc f1			.pastdmark: pop af  
a4bd			endm  
# End of macro DMARK
a4bd					CALLMONITOR 
a4bd cd 6f ee			call debug_vector  
a4c0				endm  
# End of macro CALLMONITOR
a4c0				endif 
a4c0 c3 89 a4			jp .storebyteat 
a4c3				NEXTW 
a4c3 c3 e8 9e			jp macro_next 
a4c6				endm 
# End of macro NEXTW
a4c6			.SCALL: 
a4c6			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a4c6 23				db WORD_SYS_CORE+OPCODE_SCALL             
a4c7 fa a4			dw .DEPTH            
a4c9 05				db 4 + 1 
a4ca .. 00			db "CALL",0              
a4cf				endm 
# End of macro CWHEAD
a4cf			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4cf				if DEBUG_FORTH_WORDS_KEY 
a4cf					DMARK "CLL" 
a4cf f5				push af  
a4d0 3a e4 a4			ld a, (.dmark)  
a4d3 32 6b ee			ld (debug_mark),a  
a4d6 3a e5 a4			ld a, (.dmark+1)  
a4d9 32 6c ee			ld (debug_mark+1),a  
a4dc 3a e6 a4			ld a, (.dmark+2)  
a4df 32 6d ee			ld (debug_mark+2),a  
a4e2 18 03			jr .pastdmark  
a4e4 ..			.dmark: db "CLL"  
a4e7 f1			.pastdmark: pop af  
a4e8			endm  
# End of macro DMARK
a4e8					CALLMONITOR 
a4e8 cd 6f ee			call debug_vector  
a4eb				endm  
# End of macro CALLMONITOR
a4eb				endif 
a4eb			 
a4eb				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4eb cd 32 9d			call macro_dsp_valuehl 
a4ee				endm 
# End of macro FORTH_DSP_VALUEHL
a4ee			 
a4ee			;		push hl 
a4ee			 
a4ee				; destroy value TOS 
a4ee			 
a4ee				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4ee cd ea 9d			call macro_forth_dsp_pop 
a4f1				endm 
# End of macro FORTH_DSP_POP
a4f1			 
a4f1					 
a4f1			;		pop hl 
a4f1			 
a4f1				; how to do a call with hl???? save SP? 
a4f1 cd 8c 9e			call forth_call_hl 
a4f4			 
a4f4			 
a4f4				; TODO push value back onto stack for another op etc 
a4f4			 
a4f4 cd 3b 9b			call forth_push_numhl 
a4f7				NEXTW 
a4f7 c3 e8 9e			jp macro_next 
a4fa				endm 
# End of macro NEXTW
a4fa			.DEPTH: 
a4fa			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a4fa 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a4fb 37 a5			dw .OVER            
a4fd 06				db 5 + 1 
a4fe .. 00			db "DEPTH",0              
a504				endm 
# End of macro CWHEAD
a504			; | DEPTH ( -- u ) Push count of stack | DONE 
a504				; take current TOS and remove from base value div by two to get count 
a504				if DEBUG_FORTH_WORDS_KEY 
a504					DMARK "DEP" 
a504 f5				push af  
a505 3a 19 a5			ld a, (.dmark)  
a508 32 6b ee			ld (debug_mark),a  
a50b 3a 1a a5			ld a, (.dmark+1)  
a50e 32 6c ee			ld (debug_mark+1),a  
a511 3a 1b a5			ld a, (.dmark+2)  
a514 32 6d ee			ld (debug_mark+2),a  
a517 18 03			jr .pastdmark  
a519 ..			.dmark: db "DEP"  
a51c f1			.pastdmark: pop af  
a51d			endm  
# End of macro DMARK
a51d					CALLMONITOR 
a51d cd 6f ee			call debug_vector  
a520				endm  
# End of macro CALLMONITOR
a520				endif 
a520			 
a520			 
a520 2a ee e9		ld hl, (cli_data_sp) 
a523 11 28 e8		ld de, cli_data_stack 
a526 ed 52		sbc hl,de 
a528			 
a528			; div by size of stack item 
a528			 
a528 5d			ld e,l 
a529 0e 03		ld c, 3 
a52b cd 6b 8c		call Div8 
a52e			 
a52e 6f			ld l,a 
a52f 26 00		ld h,0 
a531			 
a531			;srl h 
a531			;rr l 
a531			 
a531 cd 3b 9b			call forth_push_numhl 
a534				NEXTW 
a534 c3 e8 9e			jp macro_next 
a537				endm 
# End of macro NEXTW
a537			.OVER: 
a537			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a537 42				db WORD_SYS_CORE+46             
a538 7e a5			dw .PAUSE            
a53a 05				db 4 + 1 
a53b .. 00			db "OVER",0              
a540				endm 
# End of macro CWHEAD
a540			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a540				if DEBUG_FORTH_WORDS_KEY 
a540					DMARK "OVR" 
a540 f5				push af  
a541 3a 55 a5			ld a, (.dmark)  
a544 32 6b ee			ld (debug_mark),a  
a547 3a 56 a5			ld a, (.dmark+1)  
a54a 32 6c ee			ld (debug_mark+1),a  
a54d 3a 57 a5			ld a, (.dmark+2)  
a550 32 6d ee			ld (debug_mark+2),a  
a553 18 03			jr .pastdmark  
a555 ..			.dmark: db "OVR"  
a558 f1			.pastdmark: pop af  
a559			endm  
# End of macro DMARK
a559					CALLMONITOR 
a559 cd 6f ee			call debug_vector  
a55c				endm  
# End of macro CALLMONITOR
a55c				endif 
a55c			 
a55c			; TODO Use os stack swap memory 
a55c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a55c cd 32 9d			call macro_dsp_valuehl 
a55f				endm 
# End of macro FORTH_DSP_VALUEHL
a55f e5				push hl    ; n2 
a560				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a560 cd ea 9d			call macro_forth_dsp_pop 
a563				endm 
# End of macro FORTH_DSP_POP
a563			 
a563				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a563 cd 32 9d			call macro_dsp_valuehl 
a566				endm 
# End of macro FORTH_DSP_VALUEHL
a566 e5				push hl    ; n1 
a567				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a567 cd ea 9d			call macro_forth_dsp_pop 
a56a				endm 
# End of macro FORTH_DSP_POP
a56a			 
a56a d1				pop de     ; n1 
a56b e1				pop hl     ; n2 
a56c			 
a56c d5				push de 
a56d e5				push hl 
a56e d5				push de 
a56f			 
a56f				; push back  
a56f			 
a56f e1				pop hl 
a570 cd 3b 9b			call forth_push_numhl 
a573 e1				pop hl 
a574 cd 3b 9b			call forth_push_numhl 
a577 e1				pop hl 
a578 cd 3b 9b			call forth_push_numhl 
a57b				NEXTW 
a57b c3 e8 9e			jp macro_next 
a57e				endm 
# End of macro NEXTW
a57e			 
a57e			.PAUSE: 
a57e			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a57e 43				db WORD_SYS_CORE+47             
a57f b3 a5			dw .PAUSES            
a581 08				db 7 + 1 
a582 .. 00			db "PAUSEMS",0              
a58a				endm 
# End of macro CWHEAD
a58a			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a58a				if DEBUG_FORTH_WORDS_KEY 
a58a					DMARK "PMS" 
a58a f5				push af  
a58b 3a 9f a5			ld a, (.dmark)  
a58e 32 6b ee			ld (debug_mark),a  
a591 3a a0 a5			ld a, (.dmark+1)  
a594 32 6c ee			ld (debug_mark+1),a  
a597 3a a1 a5			ld a, (.dmark+2)  
a59a 32 6d ee			ld (debug_mark+2),a  
a59d 18 03			jr .pastdmark  
a59f ..			.dmark: db "PMS"  
a5a2 f1			.pastdmark: pop af  
a5a3			endm  
# End of macro DMARK
a5a3					CALLMONITOR 
a5a3 cd 6f ee			call debug_vector  
a5a6				endm  
# End of macro CALLMONITOR
a5a6				endif 
a5a6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5a6 cd 32 9d			call macro_dsp_valuehl 
a5a9				endm 
# End of macro FORTH_DSP_VALUEHL
a5a9			;		push hl    ; n2 
a5a9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5a9 cd ea 9d			call macro_forth_dsp_pop 
a5ac				endm 
# End of macro FORTH_DSP_POP
a5ac			;		pop hl 
a5ac			 
a5ac 7d				ld a, l 
a5ad cd d6 89			call aDelayInMS 
a5b0			       NEXTW 
a5b0 c3 e8 9e			jp macro_next 
a5b3				endm 
# End of macro NEXTW
a5b3			.PAUSES:  
a5b3			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a5b3 44				db WORD_SYS_CORE+48             
a5b4 22 a6			dw .ROT            
a5b6 06				db 5 + 1 
a5b7 .. 00			db "PAUSE",0              
a5bd				endm 
# End of macro CWHEAD
a5bd			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a5bd				if DEBUG_FORTH_WORDS_KEY 
a5bd					DMARK "PAU" 
a5bd f5				push af  
a5be 3a d2 a5			ld a, (.dmark)  
a5c1 32 6b ee			ld (debug_mark),a  
a5c4 3a d3 a5			ld a, (.dmark+1)  
a5c7 32 6c ee			ld (debug_mark+1),a  
a5ca 3a d4 a5			ld a, (.dmark+2)  
a5cd 32 6d ee			ld (debug_mark+2),a  
a5d0 18 03			jr .pastdmark  
a5d2 ..			.dmark: db "PAU"  
a5d5 f1			.pastdmark: pop af  
a5d6			endm  
# End of macro DMARK
a5d6					CALLMONITOR 
a5d6 cd 6f ee			call debug_vector  
a5d9				endm  
# End of macro CALLMONITOR
a5d9				endif 
a5d9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5d9 cd 32 9d			call macro_dsp_valuehl 
a5dc				endm 
# End of macro FORTH_DSP_VALUEHL
a5dc			;		push hl    ; n2 
a5dc				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5dc cd ea 9d			call macro_forth_dsp_pop 
a5df				endm 
# End of macro FORTH_DSP_POP
a5df			;		pop hl 
a5df 45				ld b, l 
a5e0				if DEBUG_FORTH_WORDS 
a5e0					DMARK "PAU" 
a5e0 f5				push af  
a5e1 3a f5 a5			ld a, (.dmark)  
a5e4 32 6b ee			ld (debug_mark),a  
a5e7 3a f6 a5			ld a, (.dmark+1)  
a5ea 32 6c ee			ld (debug_mark+1),a  
a5ed 3a f7 a5			ld a, (.dmark+2)  
a5f0 32 6d ee			ld (debug_mark+2),a  
a5f3 18 03			jr .pastdmark  
a5f5 ..			.dmark: db "PAU"  
a5f8 f1			.pastdmark: pop af  
a5f9			endm  
# End of macro DMARK
a5f9					CALLMONITOR 
a5f9 cd 6f ee			call debug_vector  
a5fc				endm  
# End of macro CALLMONITOR
a5fc				endif 
a5fc c5			.pauses1:	push bc 
a5fd cd f1 89			call delay1s 
a600 c1				pop bc 
a601				if DEBUG_FORTH_WORDS 
a601					DMARK "PA1" 
a601 f5				push af  
a602 3a 16 a6			ld a, (.dmark)  
a605 32 6b ee			ld (debug_mark),a  
a608 3a 17 a6			ld a, (.dmark+1)  
a60b 32 6c ee			ld (debug_mark+1),a  
a60e 3a 18 a6			ld a, (.dmark+2)  
a611 32 6d ee			ld (debug_mark+2),a  
a614 18 03			jr .pastdmark  
a616 ..			.dmark: db "PA1"  
a619 f1			.pastdmark: pop af  
a61a			endm  
# End of macro DMARK
a61a					CALLMONITOR 
a61a cd 6f ee			call debug_vector  
a61d				endm  
# End of macro CALLMONITOR
a61d				endif 
a61d 10 dd			djnz .pauses1 
a61f			 
a61f			       NEXTW 
a61f c3 e8 9e			jp macro_next 
a622				endm 
# End of macro NEXTW
a622			.ROT: 
a622			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a622 45				db WORD_SYS_CORE+49             
a623 70 a6			dw .UWORDS            
a625 04				db 3 + 1 
a626 .. 00			db "ROT",0              
a62a				endm 
# End of macro CWHEAD
a62a			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a62a				if DEBUG_FORTH_WORDS_KEY 
a62a					DMARK "ROT" 
a62a f5				push af  
a62b 3a 3f a6			ld a, (.dmark)  
a62e 32 6b ee			ld (debug_mark),a  
a631 3a 40 a6			ld a, (.dmark+1)  
a634 32 6c ee			ld (debug_mark+1),a  
a637 3a 41 a6			ld a, (.dmark+2)  
a63a 32 6d ee			ld (debug_mark+2),a  
a63d 18 03			jr .pastdmark  
a63f ..			.dmark: db "ROT"  
a642 f1			.pastdmark: pop af  
a643			endm  
# End of macro DMARK
a643					CALLMONITOR 
a643 cd 6f ee			call debug_vector  
a646				endm  
# End of macro CALLMONITOR
a646				endif 
a646			 
a646			; TODO Use os stack swap memory 
a646				FORTH_DSP_VALUEHL 
a646 cd 32 9d			call macro_dsp_valuehl 
a649				endm 
# End of macro FORTH_DSP_VALUEHL
a649 e5				push hl    ; u3  
a64a			 
a64a				FORTH_DSP_POP 
a64a cd ea 9d			call macro_forth_dsp_pop 
a64d				endm 
# End of macro FORTH_DSP_POP
a64d			 
a64d				FORTH_DSP_VALUEHL 
a64d cd 32 9d			call macro_dsp_valuehl 
a650				endm 
# End of macro FORTH_DSP_VALUEHL
a650 e5				push hl     ; u2 
a651			 
a651				FORTH_DSP_POP 
a651 cd ea 9d			call macro_forth_dsp_pop 
a654				endm 
# End of macro FORTH_DSP_POP
a654			 
a654				FORTH_DSP_VALUEHL 
a654 cd 32 9d			call macro_dsp_valuehl 
a657				endm 
# End of macro FORTH_DSP_VALUEHL
a657 e5				push hl     ; u1 
a658			 
a658				FORTH_DSP_POP 
a658 cd ea 9d			call macro_forth_dsp_pop 
a65b				endm 
# End of macro FORTH_DSP_POP
a65b			 
a65b c1				pop bc      ; u1 
a65c e1				pop hl      ; u2 
a65d d1				pop de      ; u3 
a65e			 
a65e			 
a65e c5				push bc 
a65f d5				push de 
a660 e5				push hl 
a661			 
a661			 
a661 e1				pop hl 
a662 cd 3b 9b			call forth_push_numhl 
a665			 
a665 e1				pop hl 
a666 cd 3b 9b			call forth_push_numhl 
a669			 
a669 e1				pop hl 
a66a cd 3b 9b			call forth_push_numhl 
a66d				 
a66d			 
a66d			 
a66d			 
a66d			 
a66d			 
a66d			       NEXTW 
a66d c3 e8 9e			jp macro_next 
a670				endm 
# End of macro NEXTW
a670			 
a670			.UWORDS: 
a670			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a670 50				db WORD_SYS_CORE+60             
a671 32 a7			dw .BP            
a673 07				db 6 + 1 
a674 .. 00			db "UWORDS",0              
a67b				endm 
# End of macro CWHEAD
a67b			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a67b			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a67b			; | | Following the count are the individual words. 
a67b			; | | 
a67b			; | | e.g. UWORDS 
a67b			; | | BOX DIRLIST 2 
a67b			; | |  
a67b			; | | Can be used to save the words to storage via: 
a67b			; | | UWORDS $01 DO $01 APPEND LOOP 
a67b			if DEBUG_FORTH_WORDS_KEY 
a67b				DMARK "UWR" 
a67b f5				push af  
a67c 3a 90 a6			ld a, (.dmark)  
a67f 32 6b ee			ld (debug_mark),a  
a682 3a 91 a6			ld a, (.dmark+1)  
a685 32 6c ee			ld (debug_mark+1),a  
a688 3a 92 a6			ld a, (.dmark+2)  
a68b 32 6d ee			ld (debug_mark+2),a  
a68e 18 03			jr .pastdmark  
a690 ..			.dmark: db "UWR"  
a693 f1			.pastdmark: pop af  
a694			endm  
# End of macro DMARK
a694				CALLMONITOR 
a694 cd 6f ee			call debug_vector  
a697				endm  
# End of macro CALLMONITOR
a697			endif 
a697 21 71 e4			ld hl, baseram 
a69a				;ld hl, baseusermem 
a69a 01 00 00			ld bc, 0    ; start a counter 
a69d			 
a69d			; skip dict stub 
a69d			 
a69d cd 39 a0			call forth_tok_next 
a6a0			 
a6a0			 
a6a0			; while we have words to look for 
a6a0			 
a6a0 7e			.douscan:	ld a, (hl)      
a6a1			if DEBUG_FORTH_WORDS 
a6a1				DMARK "UWs" 
a6a1 f5				push af  
a6a2 3a b6 a6			ld a, (.dmark)  
a6a5 32 6b ee			ld (debug_mark),a  
a6a8 3a b7 a6			ld a, (.dmark+1)  
a6ab 32 6c ee			ld (debug_mark+1),a  
a6ae 3a b8 a6			ld a, (.dmark+2)  
a6b1 32 6d ee			ld (debug_mark+2),a  
a6b4 18 03			jr .pastdmark  
a6b6 ..			.dmark: db "UWs"  
a6b9 f1			.pastdmark: pop af  
a6ba			endm  
# End of macro DMARK
a6ba				CALLMONITOR 
a6ba cd 6f ee			call debug_vector  
a6bd				endm  
# End of macro CALLMONITOR
a6bd			endif 
a6bd fe 00			cp WORD_SYS_END 
a6bf 28 4d			jr z, .udone 
a6c1 fe 01			cp WORD_SYS_UWORD 
a6c3 20 44			jr nz, .nuword 
a6c5			 
a6c5			if DEBUG_FORTH_WORDS 
a6c5				DMARK "UWu" 
a6c5 f5				push af  
a6c6 3a da a6			ld a, (.dmark)  
a6c9 32 6b ee			ld (debug_mark),a  
a6cc 3a db a6			ld a, (.dmark+1)  
a6cf 32 6c ee			ld (debug_mark+1),a  
a6d2 3a dc a6			ld a, (.dmark+2)  
a6d5 32 6d ee			ld (debug_mark+2),a  
a6d8 18 03			jr .pastdmark  
a6da ..			.dmark: db "UWu"  
a6dd f1			.pastdmark: pop af  
a6de			endm  
# End of macro DMARK
a6de				CALLMONITOR 
a6de cd 6f ee			call debug_vector  
a6e1				endm  
# End of macro CALLMONITOR
a6e1			endif 
a6e1				; we have a uword so push its name to the stack 
a6e1			 
a6e1 e5				push hl  ; save so we can move to next dict block 
a6e2			 
a6e2				; skip opcode 
a6e2 23				inc hl  
a6e3				; skip next ptr 
a6e3 23				inc hl  
a6e4 23				inc hl 
a6e5				; skip len 
a6e5 23				inc hl 
a6e6			if DEBUG_FORTH_WORDS 
a6e6				DMARK "UWt" 
a6e6 f5				push af  
a6e7 3a fb a6			ld a, (.dmark)  
a6ea 32 6b ee			ld (debug_mark),a  
a6ed 3a fc a6			ld a, (.dmark+1)  
a6f0 32 6c ee			ld (debug_mark+1),a  
a6f3 3a fd a6			ld a, (.dmark+2)  
a6f6 32 6d ee			ld (debug_mark+2),a  
a6f9 18 03			jr .pastdmark  
a6fb ..			.dmark: db "UWt"  
a6fe f1			.pastdmark: pop af  
a6ff			endm  
# End of macro DMARK
a6ff				CALLMONITOR 
a6ff cd 6f ee			call debug_vector  
a702				endm  
# End of macro CALLMONITOR
a702			endif 
a702 03				inc bc 
a703			 
a703 c5				push bc 
a704 cd a9 9b			call forth_push_str 
a707 c1				pop bc 
a708			 
a708 e1				pop hl 	 
a709			 
a709 cd 39 a0		.nuword:	call forth_tok_next 
a70c 18 92			jr .douscan  
a70e			 
a70e			.udone:		 ; push count of uwords found 
a70e c5				push bc 
a70f e1				pop hl 
a710			 
a710			if DEBUG_FORTH_WORDS 
a710				DMARK "UWc" 
a710 f5				push af  
a711 3a 25 a7			ld a, (.dmark)  
a714 32 6b ee			ld (debug_mark),a  
a717 3a 26 a7			ld a, (.dmark+1)  
a71a 32 6c ee			ld (debug_mark+1),a  
a71d 3a 27 a7			ld a, (.dmark+2)  
a720 32 6d ee			ld (debug_mark+2),a  
a723 18 03			jr .pastdmark  
a725 ..			.dmark: db "UWc"  
a728 f1			.pastdmark: pop af  
a729			endm  
# End of macro DMARK
a729				CALLMONITOR 
a729 cd 6f ee			call debug_vector  
a72c				endm  
# End of macro CALLMONITOR
a72c			endif 
a72c cd 3b 9b			call forth_push_numhl 
a72f			 
a72f			 
a72f			       NEXTW 
a72f c3 e8 9e			jp macro_next 
a732				endm 
# End of macro NEXTW
a732			 
a732			.BP: 
a732			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a732 54				db WORD_SYS_CORE+64             
a733 6c a7			dw .MONITOR            
a735 03				db 2 + 1 
a736 .. 00			db "BP",0              
a739				endm 
# End of macro CWHEAD
a739			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a739			; | | $00 Will enable the break points within specific code paths 
a739			; | | $01 Will disable break points 
a739			; | |  
a739			; | | By default break points are off. Either the above can be used to enable them 
a739			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a739			; | | and on release of the pressed key a message will be disaplayed to notify 
a739			; | | that break points are enabled. Pressing any key will then continue boot process. 
a739				; get byte count 
a739				if DEBUG_FORTH_WORDS_KEY 
a739					DMARK "BP." 
a739 f5				push af  
a73a 3a 4e a7			ld a, (.dmark)  
a73d 32 6b ee			ld (debug_mark),a  
a740 3a 4f a7			ld a, (.dmark+1)  
a743 32 6c ee			ld (debug_mark+1),a  
a746 3a 50 a7			ld a, (.dmark+2)  
a749 32 6d ee			ld (debug_mark+2),a  
a74c 18 03			jr .pastdmark  
a74e ..			.dmark: db "BP."  
a751 f1			.pastdmark: pop af  
a752			endm  
# End of macro DMARK
a752					CALLMONITOR 
a752 cd 6f ee			call debug_vector  
a755				endm  
# End of macro CALLMONITOR
a755				endif 
a755			 
a755				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a755 cd 32 9d			call macro_dsp_valuehl 
a758				endm 
# End of macro FORTH_DSP_VALUEHL
a758			 
a758			;		push hl 
a758			 
a758				; destroy value TOS 
a758			 
a758				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a758 cd ea 9d			call macro_forth_dsp_pop 
a75b				endm 
# End of macro FORTH_DSP_POP
a75b			 
a75b			;		pop hl 
a75b			 
a75b 3e 00			ld a,0 
a75d bd				cp l 
a75e 28 06			jr z, .bpset 
a760			;		ld a, '*' 
a760 cd dd 94			call bp_off 
a763				NEXTW 
a763 c3 e8 9e			jp macro_next 
a766				endm 
# End of macro NEXTW
a766			 
a766			.bpset:	 
a766				;	ld (os_view_disable), a 
a766 cd d1 94			call bp_on 
a769			 
a769			 
a769				NEXTW 
a769 c3 e8 9e			jp macro_next 
a76c				endm 
# End of macro NEXTW
a76c			 
a76c			 
a76c			.MONITOR: 
a76c			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a76c 55				db WORD_SYS_CORE+65             
a76d 9d a7			dw .MALLOC            
a76f 08				db 7 + 1 
a770 .. 00			db "MONITOR",0              
a778				endm 
# End of macro CWHEAD
a778			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a778			; | | At start the current various registers will be displayed with contents. 
a778			; | | Top right corner will show the most recent debug marker seen. 
a778			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a778			; | | and the return stack pointer (RSP). 
a778			; | | Pressing: 
a778			; | |    1 - Initial screen 
a778			; | |    2 - Display a data dump of HL 
a778			; | |    3 - Display a data dump of DE 
a778			; | |    4 - Display a data dump of BC 
a778			; | |    5 - Display a data dump of HL 
a778			; | |    6 - Display a data dump of DSP 
a778			; | |    7 - Display a data dump of RSP 
a778			; | |    8 - Display a data dump of what is at DSP 
a778			; | |    9 - Display a data dump of what is at RSP 
a778			; | |    0 - Exit monitor and continue running. This will also enable break points 
a778			; | |    * - Disable break points 
a778			; | |    # - Enter traditional monitor mode 
a778			; | | 
a778			; | | Monitor Mode 
a778			; | | ------------ 
a778			; | | A prompt of '>' will be shown for various commands: 
a778			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a778			; | |    C - Continue display a data dump from the last set address 
a778			; | |    M xxxx - Set start of memory edit at address xx 
a778			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a778			; | |    Q - Return to previous 
a778				if DEBUG_FORTH_WORDS_KEY 
a778					DMARK "MON" 
a778 f5				push af  
a779 3a 8d a7			ld a, (.dmark)  
a77c 32 6b ee			ld (debug_mark),a  
a77f 3a 8e a7			ld a, (.dmark+1)  
a782 32 6c ee			ld (debug_mark+1),a  
a785 3a 8f a7			ld a, (.dmark+2)  
a788 32 6d ee			ld (debug_mark+2),a  
a78b 18 03			jr .pastdmark  
a78d ..			.dmark: db "MON"  
a790 f1			.pastdmark: pop af  
a791			endm  
# End of macro DMARK
a791					CALLMONITOR 
a791 cd 6f ee			call debug_vector  
a794				endm  
# End of macro CALLMONITOR
a794				endif 
a794			;		ld a, 0 
a794			;		ld (os_view_disable), a 
a794 cd d1 94			call bp_on 
a797			 
a797				CALLMONITOR 
a797 cd 6f ee			call debug_vector  
a79a				endm  
# End of macro CALLMONITOR
a79a			 
a79a			;	call monitor 
a79a			 
a79a				NEXTW 
a79a c3 e8 9e			jp macro_next 
a79d				endm 
# End of macro NEXTW
a79d			 
a79d			 
a79d			.MALLOC: 
a79d			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a79d 56				db WORD_SYS_CORE+66             
a79e c6 a7			dw .MALLOC2            
a7a0 06				db 5 + 1 
a7a1 .. 00			db "ALLOT",0              
a7a7				endm 
# End of macro CWHEAD
a7a7			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7a7				if DEBUG_FORTH_WORDS_KEY 
a7a7					DMARK "ALL" 
a7a7 f5				push af  
a7a8 3a bc a7			ld a, (.dmark)  
a7ab 32 6b ee			ld (debug_mark),a  
a7ae 3a bd a7			ld a, (.dmark+1)  
a7b1 32 6c ee			ld (debug_mark+1),a  
a7b4 3a be a7			ld a, (.dmark+2)  
a7b7 32 6d ee			ld (debug_mark+2),a  
a7ba 18 03			jr .pastdmark  
a7bc ..			.dmark: db "ALL"  
a7bf f1			.pastdmark: pop af  
a7c0			endm  
# End of macro DMARK
a7c0					CALLMONITOR 
a7c0 cd 6f ee			call debug_vector  
a7c3				endm  
# End of macro CALLMONITOR
a7c3				endif 
a7c3 c3 ed a7			jp .mallocc 
a7c6			.MALLOC2: 
a7c6			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a7c6 56				db WORD_SYS_CORE+66             
a7c7 04 a8			dw .FREE            
a7c9 07				db 6 + 1 
a7ca .. 00			db "MALLOC",0              
a7d1				endm 
# End of macro CWHEAD
a7d1			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7d1				; get byte count 
a7d1				if DEBUG_FORTH_WORDS_KEY 
a7d1					DMARK "MAL" 
a7d1 f5				push af  
a7d2 3a e6 a7			ld a, (.dmark)  
a7d5 32 6b ee			ld (debug_mark),a  
a7d8 3a e7 a7			ld a, (.dmark+1)  
a7db 32 6c ee			ld (debug_mark+1),a  
a7de 3a e8 a7			ld a, (.dmark+2)  
a7e1 32 6d ee			ld (debug_mark+2),a  
a7e4 18 03			jr .pastdmark  
a7e6 ..			.dmark: db "MAL"  
a7e9 f1			.pastdmark: pop af  
a7ea			endm  
# End of macro DMARK
a7ea					CALLMONITOR 
a7ea cd 6f ee			call debug_vector  
a7ed				endm  
# End of macro CALLMONITOR
a7ed				endif 
a7ed			.mallocc: 
a7ed				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7ed cd 32 9d			call macro_dsp_valuehl 
a7f0				endm 
# End of macro FORTH_DSP_VALUEHL
a7f0			 
a7f0			;		push hl 
a7f0			 
a7f0				; destroy value TOS 
a7f0			 
a7f0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7f0 cd ea 9d			call macro_forth_dsp_pop 
a7f3				endm 
# End of macro FORTH_DSP_POP
a7f3			 
a7f3			;		pop hl 
a7f3 cd a2 91			call malloc 
a7f6			if DEBUG_FORTH_MALLOC_GUARD 
a7f6 f5				push af 
a7f7 cd 04 8d			call ishlzero 
a7fa			;		ld a, l 
a7fa			;		add h 
a7fa			;		cp 0 
a7fa f1				pop af 
a7fb				 
a7fb cc 6b cc			call z,malloc_error 
a7fe			endif 
a7fe			 
a7fe cd 3b 9b			call forth_push_numhl 
a801				NEXTW 
a801 c3 e8 9e			jp macro_next 
a804				endm 
# End of macro NEXTW
a804			 
a804			.FREE: 
a804			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a804 57				db WORD_SYS_CORE+67             
a805 35 a8			dw .LIST            
a807 05				db 4 + 1 
a808 .. 00			db "FREE",0              
a80d				endm 
# End of macro CWHEAD
a80d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a80d				if DEBUG_FORTH_WORDS_KEY 
a80d					DMARK "FRE" 
a80d f5				push af  
a80e 3a 22 a8			ld a, (.dmark)  
a811 32 6b ee			ld (debug_mark),a  
a814 3a 23 a8			ld a, (.dmark+1)  
a817 32 6c ee			ld (debug_mark+1),a  
a81a 3a 24 a8			ld a, (.dmark+2)  
a81d 32 6d ee			ld (debug_mark+2),a  
a820 18 03			jr .pastdmark  
a822 ..			.dmark: db "FRE"  
a825 f1			.pastdmark: pop af  
a826			endm  
# End of macro DMARK
a826					CALLMONITOR 
a826 cd 6f ee			call debug_vector  
a829				endm  
# End of macro CALLMONITOR
a829				endif 
a829				; get address 
a829			 
a829				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a829 cd 32 9d			call macro_dsp_valuehl 
a82c				endm 
# End of macro FORTH_DSP_VALUEHL
a82c			 
a82c			;		push hl 
a82c			 
a82c				; destroy value TOS 
a82c			 
a82c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a82c cd ea 9d			call macro_forth_dsp_pop 
a82f				endm 
# End of macro FORTH_DSP_POP
a82f			 
a82f			;		pop hl 
a82f			if FORTH_ENABLE_MALLOCFREE 
a82f cd 6c 92			call free 
a832			endif 
a832				NEXTW 
a832 c3 e8 9e			jp macro_next 
a835				endm 
# End of macro NEXTW
a835			.LIST: 
a835			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a835 5c				db WORD_SYS_CORE+72             
a836 23 aa			dw .FORGET            
a838 05				db 4 + 1 
a839 .. 00			db "LIST",0              
a83e				endm 
# End of macro CWHEAD
a83e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a83e			; | | The quoted word must be in upper case. 
a83e			if DEBUG_FORTH_WORDS_KEY 
a83e				DMARK "LST" 
a83e f5				push af  
a83f 3a 53 a8			ld a, (.dmark)  
a842 32 6b ee			ld (debug_mark),a  
a845 3a 54 a8			ld a, (.dmark+1)  
a848 32 6c ee			ld (debug_mark+1),a  
a84b 3a 55 a8			ld a, (.dmark+2)  
a84e 32 6d ee			ld (debug_mark+2),a  
a851 18 03			jr .pastdmark  
a853 ..			.dmark: db "LST"  
a856 f1			.pastdmark: pop af  
a857			endm  
# End of macro DMARK
a857				CALLMONITOR 
a857 cd 6f ee			call debug_vector  
a85a				endm  
# End of macro CALLMONITOR
a85a			endif 
a85a			 
a85a				FORTH_DSP_VALUEHL 
a85a cd 32 9d			call macro_dsp_valuehl 
a85d				endm 
# End of macro FORTH_DSP_VALUEHL
a85d			 
a85d e5				push hl 
a85e				FORTH_DSP_POP 
a85e cd ea 9d			call macro_forth_dsp_pop 
a861				endm 
# End of macro FORTH_DSP_POP
a861 c1				pop bc 
a862			 
a862			; Start format of scratch string 
a862			 
a862 21 c1 e2			ld hl, scratch 
a865			 
a865 3e 3a			ld a, ':' 
a867 77				ld (hl),a 
a868 23				inc hl 
a869 3e 20			ld a, ' ' 
a86b 77				ld (hl), a 
a86c			 
a86c				; Get ptr to the word we need to look up 
a86c			 
a86c			;		FORTH_DSP_VALUEHL 
a86c				;v5 FORTH_DSP_VALUE 
a86c			; TODO type check 
a86c			;		inc hl    ; Skip type check  
a86c			;		push hl 
a86c			;		ex de, hl    ; put into DE 
a86c			 
a86c			 
a86c 21 71 e4			ld hl, baseram 
a86f				;ld hl, baseusermem 
a86f			 
a86f e5			push hl   ; sacreifical push 
a870			 
a870			.ldouscanm: 
a870 e1			pop hl 
a871			.ldouscan: 
a871			if DEBUG_FORTH_WORDS 
a871				DMARK "LSs" 
a871 f5				push af  
a872 3a 86 a8			ld a, (.dmark)  
a875 32 6b ee			ld (debug_mark),a  
a878 3a 87 a8			ld a, (.dmark+1)  
a87b 32 6c ee			ld (debug_mark+1),a  
a87e 3a 88 a8			ld a, (.dmark+2)  
a881 32 6d ee			ld (debug_mark+2),a  
a884 18 03			jr .pastdmark  
a886 ..			.dmark: db "LSs"  
a889 f1			.pastdmark: pop af  
a88a			endm  
# End of macro DMARK
a88a				CALLMONITOR 
a88a cd 6f ee			call debug_vector  
a88d				endm  
# End of macro CALLMONITOR
a88d			endif 
a88d			; skip dict stub 
a88d cd 39 a0			call forth_tok_next 
a890			 
a890			 
a890			; while we have words to look for 
a890			 
a890 7e			ld a, (hl)      
a891			if DEBUG_FORTH_WORDS 
a891				DMARK "LSk" 
a891 f5				push af  
a892 3a a6 a8			ld a, (.dmark)  
a895 32 6b ee			ld (debug_mark),a  
a898 3a a7 a8			ld a, (.dmark+1)  
a89b 32 6c ee			ld (debug_mark+1),a  
a89e 3a a8 a8			ld a, (.dmark+2)  
a8a1 32 6d ee			ld (debug_mark+2),a  
a8a4 18 03			jr .pastdmark  
a8a6 ..			.dmark: db "LSk"  
a8a9 f1			.pastdmark: pop af  
a8aa			endm  
# End of macro DMARK
a8aa				CALLMONITOR 
a8aa cd 6f ee			call debug_vector  
a8ad				endm  
# End of macro CALLMONITOR
a8ad			endif 
a8ad				;cp WORD_SYS_END 
a8ad				;jp z, .lunotfound 
a8ad			 
a8ad					; if we hit non uwords then gone too far 
a8ad fe 01				cp WORD_SYS_UWORD 
a8af c2 df a9				jp nz, .lunotfound 
a8b2			 
a8b2				if DEBUG_FORTH_WORDS 
a8b2					DMARK "LSu" 
a8b2 f5				push af  
a8b3 3a c7 a8			ld a, (.dmark)  
a8b6 32 6b ee			ld (debug_mark),a  
a8b9 3a c8 a8			ld a, (.dmark+1)  
a8bc 32 6c ee			ld (debug_mark+1),a  
a8bf 3a c9 a8			ld a, (.dmark+2)  
a8c2 32 6d ee			ld (debug_mark+2),a  
a8c5 18 03			jr .pastdmark  
a8c7 ..			.dmark: db "LSu"  
a8ca f1			.pastdmark: pop af  
a8cb			endm  
# End of macro DMARK
a8cb					CALLMONITOR 
a8cb cd 6f ee			call debug_vector  
a8ce				endm  
# End of macro CALLMONITOR
a8ce				endif 
a8ce			 
a8ce					; found a uword but is it the one we want... 
a8ce			 
a8ce c5					push bc     ; uword to find is on bc 
a8cf d1					pop de 
a8d0			 
a8d0 e5					push hl  ; to save the ptr 
a8d1			 
a8d1					; skip opcode 
a8d1 23					inc hl  
a8d2					; skip next ptr 
a8d2 23					inc hl  
a8d3 23					inc hl 
a8d4					; skip len 
a8d4 23					inc hl 
a8d5			 
a8d5				if DEBUG_FORTH_WORDS 
a8d5					DMARK "LSc" 
a8d5 f5				push af  
a8d6 3a ea a8			ld a, (.dmark)  
a8d9 32 6b ee			ld (debug_mark),a  
a8dc 3a eb a8			ld a, (.dmark+1)  
a8df 32 6c ee			ld (debug_mark+1),a  
a8e2 3a ec a8			ld a, (.dmark+2)  
a8e5 32 6d ee			ld (debug_mark+2),a  
a8e8 18 03			jr .pastdmark  
a8ea ..			.dmark: db "LSc"  
a8ed f1			.pastdmark: pop af  
a8ee			endm  
# End of macro DMARK
a8ee					CALLMONITOR 
a8ee cd 6f ee			call debug_vector  
a8f1				endm  
# End of macro CALLMONITOR
a8f1				endif 
a8f1 cd 71 91				call strcmp 
a8f4 c2 70 a8				jp nz, .ldouscanm 
a8f7				 
a8f7			 
a8f7			 
a8f7					; we have a uword so push its name to the stack 
a8f7			 
a8f7			;	   	push hl  ; save so we can move to next dict block 
a8f7 e1			pop hl 
a8f8			 
a8f8				if DEBUG_FORTH_WORDS 
a8f8					DMARK "LSm" 
a8f8 f5				push af  
a8f9 3a 0d a9			ld a, (.dmark)  
a8fc 32 6b ee			ld (debug_mark),a  
a8ff 3a 0e a9			ld a, (.dmark+1)  
a902 32 6c ee			ld (debug_mark+1),a  
a905 3a 0f a9			ld a, (.dmark+2)  
a908 32 6d ee			ld (debug_mark+2),a  
a90b 18 03			jr .pastdmark  
a90d ..			.dmark: db "LSm"  
a910 f1			.pastdmark: pop af  
a911			endm  
# End of macro DMARK
a911					CALLMONITOR 
a911 cd 6f ee			call debug_vector  
a914				endm  
# End of macro CALLMONITOR
a914				endif 
a914			 
a914					; skip opcode 
a914 23					inc hl  
a915					; skip next ptr 
a915 23					inc hl  
a916 23					inc hl 
a917					; skip len 
a917 7e					ld a, (hl)   ; save length to add 
a918				if DEBUG_FORTH_WORDS 
a918					DMARK "LS2" 
a918 f5				push af  
a919 3a 2d a9			ld a, (.dmark)  
a91c 32 6b ee			ld (debug_mark),a  
a91f 3a 2e a9			ld a, (.dmark+1)  
a922 32 6c ee			ld (debug_mark+1),a  
a925 3a 2f a9			ld a, (.dmark+2)  
a928 32 6d ee			ld (debug_mark+2),a  
a92b 18 03			jr .pastdmark  
a92d ..			.dmark: db "LS2"  
a930 f1			.pastdmark: pop af  
a931			endm  
# End of macro DMARK
a931					CALLMONITOR 
a931 cd 6f ee			call debug_vector  
a934				endm  
# End of macro CALLMONITOR
a934				endif 
a934			 
a934					; save this location 
a934				 
a934 e5					push hl 
a935			 
a935 23					inc hl 
a936 11 c3 e2				ld de, scratch+2 
a939 4f					ld c, a 
a93a 06 00				ld b, 0 
a93c			 
a93c				if DEBUG_FORTH_WORDS 
a93c					DMARK "LSn" 
a93c f5				push af  
a93d 3a 51 a9			ld a, (.dmark)  
a940 32 6b ee			ld (debug_mark),a  
a943 3a 52 a9			ld a, (.dmark+1)  
a946 32 6c ee			ld (debug_mark+1),a  
a949 3a 53 a9			ld a, (.dmark+2)  
a94c 32 6d ee			ld (debug_mark+2),a  
a94f 18 03			jr .pastdmark  
a951 ..			.dmark: db "LSn"  
a954 f1			.pastdmark: pop af  
a955			endm  
# End of macro DMARK
a955					CALLMONITOR 
a955 cd 6f ee			call debug_vector  
a958				endm  
# End of macro CALLMONITOR
a958				endif 
a958			 
a958					; copy uword name to scratch 
a958			 
a958 ed b0				ldir 
a95a			 
a95a 1b					dec de 
a95b 3e 20				ld a, ' '    ; change null to space 
a95d 12					ld (de), a 
a95e			 
a95e 13					inc de 
a95f			 
a95f d5					push de 
a960 c1					pop bc     ; move scratch pointer to end of word name and save it 
a961			 
a961 e1					pop hl 
a962 7e					ld a, (hl) 
a963					;inc hl 
a963					; skip word string 
a963 cd db 8c				call addatohl 
a966			 
a966 23					inc hl 
a967			 
a967				if DEBUG_FORTH_WORDS 
a967					DMARK "LS3" 
a967 f5				push af  
a968 3a 7c a9			ld a, (.dmark)  
a96b 32 6b ee			ld (debug_mark),a  
a96e 3a 7d a9			ld a, (.dmark+1)  
a971 32 6c ee			ld (debug_mark+1),a  
a974 3a 7e a9			ld a, (.dmark+2)  
a977 32 6d ee			ld (debug_mark+2),a  
a97a 18 03			jr .pastdmark  
a97c ..			.dmark: db "LS3"  
a97f f1			.pastdmark: pop af  
a980			endm  
# End of macro DMARK
a980					CALLMONITOR 
a980 cd 6f ee			call debug_vector  
a983				endm  
# End of macro CALLMONITOR
a983				endif 
a983					; should now be at the start of the machine code to setup the eval of the uword 
a983					; now locate the ptr to the string defintion 
a983			 
a983					; skip ld hl, 
a983					; then load the ptr 
a983			; TODO use get from hl ptr 
a983 23					inc hl 
a984 5e					ld e, (hl) 
a985 23					inc hl 
a986 56					ld d, (hl) 
a987 eb					ex de, hl 
a988			 
a988			 
a988				if DEBUG_FORTH_WORDS 
a988					DMARK "LSt" 
a988 f5				push af  
a989 3a 9d a9			ld a, (.dmark)  
a98c 32 6b ee			ld (debug_mark),a  
a98f 3a 9e a9			ld a, (.dmark+1)  
a992 32 6c ee			ld (debug_mark+1),a  
a995 3a 9f a9			ld a, (.dmark+2)  
a998 32 6d ee			ld (debug_mark+2),a  
a99b 18 03			jr .pastdmark  
a99d ..			.dmark: db "LSt"  
a9a0 f1			.pastdmark: pop af  
a9a1			endm  
# End of macro DMARK
a9a1					CALLMONITOR 
a9a1 cd 6f ee			call debug_vector  
a9a4				endm  
# End of macro CALLMONITOR
a9a4				endif 
a9a4			 
a9a4			; cant push right now due to tokenised strings  
a9a4			 
a9a4			; get the destination of where to copy this definition to. 
a9a4			 
a9a4 c5					push bc 
a9a5 d1					pop de 
a9a6			 
a9a6 7e			.listl:         ld a,(hl) 
a9a7 fe 00				cp 0 
a9a9 28 09				jr z, .lreplsp     ; replace zero with space 
a9ab					;cp FORTH_END_BUFFER 
a9ab fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a9ad 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a9af				 
a9af					; just copy this char as is then 
a9af			 
a9af 12					ld (de), a 
a9b0			 
a9b0 23			.listnxt:	inc hl 
a9b1 13					inc de 
a9b2 18 f2				jr .listl 
a9b4			 
a9b4 3e 20		.lreplsp:	ld a,' ' 
a9b6 12					ld (de), a 
a9b7 18 f7				jr .listnxt 
a9b9			 
a9b9			; close up uword def 
a9b9			 
a9b9			.listdone: 
a9b9 12					ld (de), a 
a9ba 13					inc de 
a9bb 3e 00				ld a, 0 
a9bd 12					ld (de), a 
a9be			 
a9be			; now have def so clean up and push to stack 
a9be			 
a9be 21 c1 e2				ld hl, scratch 
a9c1				if DEBUG_FORTH_WORDS 
a9c1					DMARK "Ltp" 
a9c1 f5				push af  
a9c2 3a d6 a9			ld a, (.dmark)  
a9c5 32 6b ee			ld (debug_mark),a  
a9c8 3a d7 a9			ld a, (.dmark+1)  
a9cb 32 6c ee			ld (debug_mark+1),a  
a9ce 3a d8 a9			ld a, (.dmark+2)  
a9d1 32 6d ee			ld (debug_mark+2),a  
a9d4 18 03			jr .pastdmark  
a9d6 ..			.dmark: db "Ltp"  
a9d9 f1			.pastdmark: pop af  
a9da			endm  
# End of macro DMARK
a9da					CALLMONITOR 
a9da cd 6f ee			call debug_vector  
a9dd				endm  
# End of macro CALLMONITOR
a9dd				endif 
a9dd			 
a9dd 18 1f			jr .listpush 
a9df			 
a9df			;.lnuword:	pop hl 
a9df			;		call forth_tok_next 
a9df			;		jp .ldouscan  
a9df			 
a9df			.lunotfound:		  
a9df			 
a9df				if DEBUG_FORTH_WORDS 
a9df					DMARK "LSn" 
a9df f5				push af  
a9e0 3a f4 a9			ld a, (.dmark)  
a9e3 32 6b ee			ld (debug_mark),a  
a9e6 3a f5 a9			ld a, (.dmark+1)  
a9e9 32 6c ee			ld (debug_mark+1),a  
a9ec 3a f6 a9			ld a, (.dmark+2)  
a9ef 32 6d ee			ld (debug_mark+2),a  
a9f2 18 03			jr .pastdmark  
a9f4 ..			.dmark: db "LSn"  
a9f7 f1			.pastdmark: pop af  
a9f8			endm  
# End of macro DMARK
a9f8					CALLMONITOR 
a9f8 cd 6f ee			call debug_vector  
a9fb				endm  
# End of macro CALLMONITOR
a9fb				endif 
a9fb			 
a9fb					 
a9fb			;		FORTH_DSP_POP 
a9fb			;		ld hl, .luno 
a9fb			 
a9fb					NEXTW			 
a9fb c3 e8 9e			jp macro_next 
a9fe				endm 
# End of macro NEXTW
a9fe			 
a9fe			.listpush: 
a9fe				if DEBUG_FORTH_WORDS 
a9fe					DMARK "LS>" 
a9fe f5				push af  
a9ff 3a 13 aa			ld a, (.dmark)  
aa02 32 6b ee			ld (debug_mark),a  
aa05 3a 14 aa			ld a, (.dmark+1)  
aa08 32 6c ee			ld (debug_mark+1),a  
aa0b 3a 15 aa			ld a, (.dmark+2)  
aa0e 32 6d ee			ld (debug_mark+2),a  
aa11 18 03			jr .pastdmark  
aa13 ..			.dmark: db "LS>"  
aa16 f1			.pastdmark: pop af  
aa17			endm  
# End of macro DMARK
aa17					CALLMONITOR 
aa17 cd 6f ee			call debug_vector  
aa1a				endm  
# End of macro CALLMONITOR
aa1a				endif 
aa1a cd a9 9b				call forth_push_str 
aa1d			 
aa1d			 
aa1d			 
aa1d					NEXTW 
aa1d c3 e8 9e			jp macro_next 
aa20				endm 
# End of macro NEXTW
aa20			 
aa20			;.luno:    db "Word not found",0 
aa20			 
aa20			 
aa20			 
aa20			 
aa20			 
aa20			;		push hl   ; save pointer to start of uword def string 
aa20			; 
aa20			;; look for FORTH_EOL_LINE 
aa20			;		ld a, FORTH_END_BUFFER 
aa20			;		call strlent 
aa20			; 
aa20			;		inc hl		 ; space for coln def 
aa20			;		inc hl 
aa20			;		inc hl          ; space for terms 
aa20			;		inc hl 
aa20			; 
aa20			;		ld a, 20   ; TODO get actual length 
aa20			;		call addatohl    ; include a random amount of room for the uword name 
aa20			; 
aa20			;		 
aa20			;	if DEBUG_FORTH_WORDS 
aa20			;		DMARK "Lt1" 
aa20			;		CALLMONITOR 
aa20			;	endif 
aa20			;		 
aa20			; 
aa20			;; malloc space for the string because we cant change it 
aa20			; 
aa20			;		call malloc 
aa20			;	if DEBUG_FORTH_MALLOC_GUARD 
aa20			;		push af 
aa20			;		call ishlzero 
aa20			;		pop af 
aa20			;		 
aa20			;		call z,malloc_error 
aa20			;	endif 
aa20			; 
aa20			;	if DEBUG_FORTH_WORDS 
aa20			;		DMARK "Lt2" 
aa20			;		CALLMONITOR 
aa20			;	endif 
aa20			;		pop de 
aa20			;		push hl    ; push the malloc to release later 
aa20			;		push hl   ;  push back a copy for the later stack push 
aa20			;		 
aa20			;; copy the string swapping out the zero terms for spaces 
aa20			; 
aa20			;		; de has our source 
aa20			;		; hl has our dest 
aa20			; 
aa20			;; add the coln def 
aa20			; 
aa20			;		ld a, ':' 
aa20			;		ld (hl), a 
aa20			;		inc hl 
aa20			;		ld a, ' ' 
aa20			;		ld (hl), a 
aa20			;		inc hl 
aa20			; 
aa20			;; add the uname word 
aa20			;		push de   ; save our string for now 
aa20			;		ex de, hl 
aa20			; 
aa20			;		FORTH_DSP_VALUE 
aa20			;		;v5 FORTH_DSP_VALUE 
aa20			; 
aa20			;		inc hl   ; skip type but we know by now this is OK 
aa20			; 
aa20			;.luword:	ld a,(hl) 
aa20			;		cp 0 
aa20			;		jr z, .luword2 
aa20			;		ld (de), a 
aa20			;		inc de 
aa20			;		inc hl 
aa20			;		jr .luword 
aa20			; 
aa20			;.luword2:	ld a, ' ' 
aa20			;		ld (de), a 
aa20			;;		inc hl 
aa20			;;		inc de 
aa20			;;		ld (de), a 
aa20			;;		inc hl 
aa20			;		inc de 
aa20			; 
aa20			;		ex de, hl 
aa20			;		pop de 
aa20			;		 
aa20			;		 
aa20			; 
aa20			;; detoken that string and copy it 
aa20			; 
aa20			;	if DEBUG_FORTH_WORDS 
aa20			;		DMARK "Lt2" 
aa20			;		CALLMONITOR 
aa20			;	endif 
aa20			;.ldetok:	ld a, (de) 
aa20			;		cp FORTH_END_BUFFER 
aa20			;		jr z, .ldetokend 
aa20			;		; swap out any zero term for space 
aa20			;		cp 0 
aa20			;		jr nz, .ldetoknext 
aa20			;		ld a, ' ' 
aa20			; 
aa20			;	if DEBUG_FORTH_WORDS 
aa20			;		DMARK "LtS" 
aa20			;		CALLMONITOR 
aa20			;	endif 
aa20			;.ldetoknext:	ld (hl), a 
aa20			;		inc de 
aa20			;		inc hl 
aa20			;		jr .ldetok 
aa20			; 
aa20			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
aa20			;		ld (hl), a  
aa20			; 
aa20			;; free that temp malloc 
aa20			; 
aa20			;		pop hl    
aa20			; 
aa20			;	if DEBUG_FORTH_WORDS 
aa20			;		DMARK "Lt4" 
aa20			;		CALLMONITOR 
aa20			;	endif 
aa20			;		call forth_apushstrhl 
aa20			; 
aa20			;		; get rid of temp malloc area 
aa20			; 
aa20			;		pop hl 
aa20			;		call free 
aa20			; 
aa20			;		jr .ludone 
aa20			; 
aa20			;.lnuword:	pop hl 
aa20			;		call forth_tok_next 
aa20			;		jp .ldouscan  
aa20			; 
aa20			;.ludone:		 pop hl 
aa20			; 
aa20					NEXTW 
aa20 c3 e8 9e			jp macro_next 
aa23				endm 
# End of macro NEXTW
aa23			 
aa23			.FORGET: 
aa23				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
aa23 5d				db WORD_SYS_CORE+73             
aa24 9c aa			dw .NOP            
aa26 07				db 6 + 1 
aa27 .. 00			db "FORGET",0              
aa2e				endm 
# End of macro CWHEAD
aa2e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa2e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
aa2e			; | |  
aa2e			; | | e.g. "MORE" forget 
aa2e					if DEBUG_FORTH_WORDS_KEY 
aa2e						DMARK "FRG" 
aa2e f5				push af  
aa2f 3a 43 aa			ld a, (.dmark)  
aa32 32 6b ee			ld (debug_mark),a  
aa35 3a 44 aa			ld a, (.dmark+1)  
aa38 32 6c ee			ld (debug_mark+1),a  
aa3b 3a 45 aa			ld a, (.dmark+2)  
aa3e 32 6d ee			ld (debug_mark+2),a  
aa41 18 03			jr .pastdmark  
aa43 ..			.dmark: db "FRG"  
aa46 f1			.pastdmark: pop af  
aa47			endm  
# End of macro DMARK
aa47						CALLMONITOR 
aa47 cd 6f ee			call debug_vector  
aa4a				endm  
# End of macro CALLMONITOR
aa4a					endif 
aa4a			 
aa4a				; find uword 
aa4a			        ; update start of word with "_" 
aa4a				; replace uword with deleted flag 
aa4a			 
aa4a			 
aa4a			;	if DEBUG_FORTH_WORDS 
aa4a			;		DMARK "FOG" 
aa4a			;		CALLMONITOR 
aa4a			;	endif 
aa4a			 
aa4a			 
aa4a					; Get ptr to the word we need to look up 
aa4a			 
aa4a					FORTH_DSP_VALUEHL 
aa4a cd 32 9d			call macro_dsp_valuehl 
aa4d				endm 
# End of macro FORTH_DSP_VALUEHL
aa4d					;v5 FORTH_DSP_VALUE 
aa4d				; TODO type check 
aa4d			;		inc hl    ; Skip type check  
aa4d e5					push hl 
aa4e c1					pop bc 
aa4f			;		ex de, hl    ; put into DE 
aa4f			 
aa4f			 
aa4f 21 71 e4				ld hl, baseram 
aa52					;ld hl, baseusermem 
aa52			 
aa52				; skip dict stub 
aa52			;	call forth_tok_next 
aa52 e5			push hl   ; sacreifical push 
aa53			 
aa53			.fldouscanm: 
aa53 e1				pop hl 
aa54			.fldouscan: 
aa54			;	if DEBUG_FORTH_WORDS 
aa54			;		DMARK "LSs" 
aa54			;		CALLMONITOR 
aa54			;	endif 
aa54				; skip dict stub 
aa54 cd 39 a0				call forth_tok_next 
aa57			 
aa57			 
aa57			; while we have words to look for 
aa57			 
aa57 7e				ld a, (hl)      
aa58			;	if DEBUG_FORTH_WORDS 
aa58			;		DMARK "LSk" 
aa58			;		CALLMONITOR 
aa58			;	endif 
aa58 fe 00				cp WORD_SYS_END 
aa5a ca 96 aa				jp z, .flunotfound 
aa5d fe 01				cp WORD_SYS_UWORD 
aa5f c2 54 aa				jp nz, .fldouscan 
aa62			 
aa62			;	if DEBUG_FORTH_WORDS 
aa62			;		DMARK "LSu" 
aa62			;		CALLMONITOR 
aa62			;	endif 
aa62			 
aa62					; found a uword but is it the one we want... 
aa62			 
aa62 c5					push bc     ; uword to find is on bc 
aa63 d1					pop de 
aa64			 
aa64 e5					push hl  ; to save the ptr 
aa65			 
aa65					; skip opcode 
aa65 23					inc hl  
aa66					; skip next ptr 
aa66 23					inc hl  
aa67 23					inc hl 
aa68					; skip len 
aa68 23					inc hl 
aa69			 
aa69			;	if DEBUG_FORTH_WORDS 
aa69			;		DMARK "LSc" 
aa69			;		CALLMONITOR 
aa69			;	endif 
aa69 cd 71 91				call strcmp 
aa6c c2 53 aa				jp nz, .fldouscanm 
aa6f			; 
aa6f			; 
aa6f			;; while we have words to look for 
aa6f			; 
aa6f			;.fdouscan:	ld a, (hl)      
aa6f			;	if DEBUG_FORTH_WORDS 
aa6f			;		DMARK "LSs" 
aa6f			;		CALLMONITOR 
aa6f			;	endif 
aa6f			;		cp WORD_SYS_END 
aa6f			;		jp z, .fudone 
aa6f			;		cp WORD_SYS_UWORD 
aa6f			;		jp nz, .fnuword 
aa6f			; 
aa6f			;	if DEBUG_FORTH_WORDS 
aa6f			;		DMARK "FGu" 
aa6f			;		CALLMONITOR 
aa6f			;	endif 
aa6f			; 
aa6f			;		; found a uword but is it the one we want... 
aa6f			; 
aa6f			; 
aa6f			;	        pop de   ; get back the dsp name 
aa6f			;		push de 
aa6f			; 
aa6f			;		push hl  ; to save the ptr 
aa6f			; 
aa6f			;		; skip opcode 
aa6f			;		inc hl  
aa6f			;		; skip next ptr 
aa6f			;		inc hl  
aa6f			;		inc hl 
aa6f			;		; skip len 
aa6f			;		inc hl 
aa6f			; 
aa6f			;	if DEBUG_FORTH_WORDS 
aa6f			;		DMARK "FGc" 
aa6f			;		CALLMONITOR 
aa6f			;	endif 
aa6f			;		call strcmp 
aa6f			;		jp nz, .fnuword 
aa6f			 
aa6f			 
aa6f e1			pop hl 
aa70			 
aa70				 
aa70				if DEBUG_FORTH_WORDS 
aa70					DMARK "FGm" 
aa70 f5				push af  
aa71 3a 85 aa			ld a, (.dmark)  
aa74 32 6b ee			ld (debug_mark),a  
aa77 3a 86 aa			ld a, (.dmark+1)  
aa7a 32 6c ee			ld (debug_mark+1),a  
aa7d 3a 87 aa			ld a, (.dmark+2)  
aa80 32 6d ee			ld (debug_mark+2),a  
aa83 18 03			jr .pastdmark  
aa85 ..			.dmark: db "FGm"  
aa88 f1			.pastdmark: pop af  
aa89			endm  
# End of macro DMARK
aa89					CALLMONITOR 
aa89 cd 6f ee			call debug_vector  
aa8c				endm  
# End of macro CALLMONITOR
aa8c				endif 
aa8c			 
aa8c			 
aa8c			 
aa8c					; we have a uword so push its name to the stack 
aa8c			 
aa8c			;	   	push hl  ; save so we can move to next dict block 
aa8c			;pop hl 
aa8c			 
aa8c					; update opcode to deleted 
aa8c 3e 03				ld a, WORD_SYS_DELETED 
aa8e 77					ld (hl), a 
aa8f			 
aa8f 23					inc hl  
aa90					; skip next ptr 
aa90 23					inc hl  
aa91 23					inc hl 
aa92					; skip len 
aa92 23					inc hl 
aa93			 
aa93					; TODO change parser to skip deleted words but for now mark it out 
aa93 3e 5f				ld a, "_" 
aa95 77					ld  (hl),a 
aa96			 
aa96			;		jr .fudone 
aa96			; 
aa96			;.fnuword:	pop hl 
aa96			;		call forth_tok_next 
aa96			;		jp .fdouscan  
aa96			 
aa96			.flunotfound:		  
aa96			 
aa96			 
aa96					 
aa96					FORTH_DSP_POP 
aa96 cd ea 9d			call macro_forth_dsp_pop 
aa99				endm 
# End of macro FORTH_DSP_POP
aa99			;		ld hl, .luno 
aa99			;.fudone:		 pop hl 
aa99					NEXTW 
aa99 c3 e8 9e			jp macro_next 
aa9c				endm 
# End of macro NEXTW
aa9c			.NOP: 
aa9c				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aa9c 61				db WORD_SYS_CORE+77             
aa9d c3 aa			dw .COMO            
aa9f 04				db 3 + 1 
aaa0 .. 00			db "NOP",0              
aaa4				endm 
# End of macro CWHEAD
aaa4			; | NOP (  --  ) Do nothing | DONE 
aaa4					if DEBUG_FORTH_WORDS_KEY 
aaa4						DMARK "NOP" 
aaa4 f5				push af  
aaa5 3a b9 aa			ld a, (.dmark)  
aaa8 32 6b ee			ld (debug_mark),a  
aaab 3a ba aa			ld a, (.dmark+1)  
aaae 32 6c ee			ld (debug_mark+1),a  
aab1 3a bb aa			ld a, (.dmark+2)  
aab4 32 6d ee			ld (debug_mark+2),a  
aab7 18 03			jr .pastdmark  
aab9 ..			.dmark: db "NOP"  
aabc f1			.pastdmark: pop af  
aabd			endm  
# End of macro DMARK
aabd						CALLMONITOR 
aabd cd 6f ee			call debug_vector  
aac0				endm  
# End of macro CALLMONITOR
aac0					endif 
aac0				       NEXTW 
aac0 c3 e8 9e			jp macro_next 
aac3				endm 
# End of macro NEXTW
aac3			.COMO: 
aac3				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aac3 6e				db WORD_SYS_CORE+90             
aac4 15 ab			dw .COMC            
aac6 02				db 1 + 1 
aac7 .. 00			db "(",0              
aac9				endm 
# End of macro CWHEAD
aac9			; | ( ( -- )  Start of comment | DONE 
aac9			 
aac9			 
aac9 2a c2 e5				ld hl, ( os_tok_ptr) 
aacc 11 10 ab			ld de, .closepar 
aacf					 
aacf					if DEBUG_FORTH_WORDS 
aacf						DMARK ").." 
aacf f5				push af  
aad0 3a e4 aa			ld a, (.dmark)  
aad3 32 6b ee			ld (debug_mark),a  
aad6 3a e5 aa			ld a, (.dmark+1)  
aad9 32 6c ee			ld (debug_mark+1),a  
aadc 3a e6 aa			ld a, (.dmark+2)  
aadf 32 6d ee			ld (debug_mark+2),a  
aae2 18 03			jr .pastdmark  
aae4 ..			.dmark: db ").."  
aae7 f1			.pastdmark: pop af  
aae8			endm  
# End of macro DMARK
aae8						CALLMONITOR 
aae8 cd 6f ee			call debug_vector  
aaeb				endm  
# End of macro CALLMONITOR
aaeb					endif 
aaeb cd 03 a0			call findnexttok  
aaee			 
aaee					if DEBUG_FORTH_WORDS 
aaee						DMARK "IF5" 
aaee f5				push af  
aaef 3a 03 ab			ld a, (.dmark)  
aaf2 32 6b ee			ld (debug_mark),a  
aaf5 3a 04 ab			ld a, (.dmark+1)  
aaf8 32 6c ee			ld (debug_mark+1),a  
aafb 3a 05 ab			ld a, (.dmark+2)  
aafe 32 6d ee			ld (debug_mark+2),a  
ab01 18 03			jr .pastdmark  
ab03 ..			.dmark: db "IF5"  
ab06 f1			.pastdmark: pop af  
ab07			endm  
# End of macro DMARK
ab07						CALLMONITOR 
ab07 cd 6f ee			call debug_vector  
ab0a				endm  
# End of macro CALLMONITOR
ab0a					endif 
ab0a				; replace below with ) exec using tok_ptr 
ab0a 22 c2 e5			ld (os_tok_ptr), hl 
ab0d c3 79 9f			jp exec1 
ab10			 
ab10 .. 00			.closepar:   db ")",0 
ab12			 
ab12				       NEXTW 
ab12 c3 e8 9e			jp macro_next 
ab15				endm 
# End of macro NEXTW
ab15			.COMC: 
ab15				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ab15 6f				db WORD_SYS_CORE+91             
ab16 1e ab			dw .SCRATCH            
ab18 02				db 1 + 1 
ab19 .. 00			db ")",0              
ab1b				endm 
# End of macro CWHEAD
ab1b			; | ) ( -- )  End of comment |  DONE  
ab1b				       NEXTW 
ab1b c3 e8 9e			jp macro_next 
ab1e				endm 
# End of macro NEXTW
ab1e			 
ab1e			.SCRATCH: 
ab1e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ab1e 6f				db WORD_SYS_CORE+91             
ab1f 59 ab			dw .INC            
ab21 08				db 7 + 1 
ab22 .. 00			db "SCRATCH",0              
ab2a				endm 
# End of macro CWHEAD
ab2a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab2a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab2a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab2a			; | |  
ab2a			; | | e.g.    : score $00 scratch ; 
ab2a			; | |  
ab2a			; | | $00 score ! 
ab2a			; | | $01 score +! 
ab2a			; | |  
ab2a			; | | e.g.   : varword $0a scratch ;  
ab2a			; | | 
ab2a			; | | $8000 varword ! 
ab2a					if DEBUG_FORTH_WORDS_KEY 
ab2a						DMARK "SCR" 
ab2a f5				push af  
ab2b 3a 3f ab			ld a, (.dmark)  
ab2e 32 6b ee			ld (debug_mark),a  
ab31 3a 40 ab			ld a, (.dmark+1)  
ab34 32 6c ee			ld (debug_mark+1),a  
ab37 3a 41 ab			ld a, (.dmark+2)  
ab3a 32 6d ee			ld (debug_mark+2),a  
ab3d 18 03			jr .pastdmark  
ab3f ..			.dmark: db "SCR"  
ab42 f1			.pastdmark: pop af  
ab43			endm  
# End of macro DMARK
ab43						CALLMONITOR 
ab43 cd 6f ee			call debug_vector  
ab46				endm  
# End of macro CALLMONITOR
ab46					endif 
ab46			 
ab46					FORTH_DSP_VALUEHL 
ab46 cd 32 9d			call macro_dsp_valuehl 
ab49				endm 
# End of macro FORTH_DSP_VALUEHL
ab49				 
ab49					FORTH_DSP_POP 
ab49 cd ea 9d			call macro_forth_dsp_pop 
ab4c				endm 
# End of macro FORTH_DSP_POP
ab4c			 
ab4c 7d					ld a, l 
ab4d 21 e6 e7				ld hl, os_var_array 
ab50 cd db 8c				call addatohl 
ab53			 
ab53 cd 3b 9b				call forth_push_numhl 
ab56			 
ab56				       NEXTW 
ab56 c3 e8 9e			jp macro_next 
ab59				endm 
# End of macro NEXTW
ab59			 
ab59			.INC: 
ab59				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab59 6f				db WORD_SYS_CORE+91             
ab5a af ab			dw .DEC            
ab5c 03				db 2 + 1 
ab5d .. 00			db "+!",0              
ab60				endm 
# End of macro CWHEAD
ab60			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab60					if DEBUG_FORTH_WORDS_KEY 
ab60						DMARK "+s_" 
ab60 f5				push af  
ab61 3a 75 ab			ld a, (.dmark)  
ab64 32 6b ee			ld (debug_mark),a  
ab67 3a 76 ab			ld a, (.dmark+1)  
ab6a 32 6c ee			ld (debug_mark+1),a  
ab6d 3a 77 ab			ld a, (.dmark+2)  
ab70 32 6d ee			ld (debug_mark+2),a  
ab73 18 03			jr .pastdmark  
ab75 ..			.dmark: db "+s_"  
ab78 f1			.pastdmark: pop af  
ab79			endm  
# End of macro DMARK
ab79						CALLMONITOR 
ab79 cd 6f ee			call debug_vector  
ab7c				endm  
# End of macro CALLMONITOR
ab7c					endif 
ab7c			 
ab7c					FORTH_DSP_VALUEHL 
ab7c cd 32 9d			call macro_dsp_valuehl 
ab7f				endm 
# End of macro FORTH_DSP_VALUEHL
ab7f			 
ab7f e5					push hl   ; save address 
ab80			 
ab80					FORTH_DSP_POP 
ab80 cd ea 9d			call macro_forth_dsp_pop 
ab83				endm 
# End of macro FORTH_DSP_POP
ab83			 
ab83					FORTH_DSP_VALUEHL 
ab83 cd 32 9d			call macro_dsp_valuehl 
ab86				endm 
# End of macro FORTH_DSP_VALUEHL
ab86			 
ab86 e5					push hl 
ab87					FORTH_DSP_POP 
ab87 cd ea 9d			call macro_forth_dsp_pop 
ab8a				endm 
# End of macro FORTH_DSP_POP
ab8a e1					pop hl 
ab8b			 
ab8b					; hl contains value to add to byte at a 
ab8b				 
ab8b eb					ex de, hl 
ab8c			 
ab8c e1					pop hl 
ab8d			 
ab8d					if DEBUG_FORTH_WORDS 
ab8d						DMARK "INC" 
ab8d f5				push af  
ab8e 3a a2 ab			ld a, (.dmark)  
ab91 32 6b ee			ld (debug_mark),a  
ab94 3a a3 ab			ld a, (.dmark+1)  
ab97 32 6c ee			ld (debug_mark+1),a  
ab9a 3a a4 ab			ld a, (.dmark+2)  
ab9d 32 6d ee			ld (debug_mark+2),a  
aba0 18 03			jr .pastdmark  
aba2 ..			.dmark: db "INC"  
aba5 f1			.pastdmark: pop af  
aba6			endm  
# End of macro DMARK
aba6						CALLMONITOR 
aba6 cd 6f ee			call debug_vector  
aba9				endm  
# End of macro CALLMONITOR
aba9					endif 
aba9			 
aba9 7e					ld a,(hl) 
abaa 83					add e 
abab 77					ld (hl),a 
abac			 
abac			 
abac			 
abac				       NEXTW 
abac c3 e8 9e			jp macro_next 
abaf				endm 
# End of macro NEXTW
abaf			 
abaf			.DEC: 
abaf				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
abaf 6f				db WORD_SYS_CORE+91             
abb0 03 ac			dw .INC2            
abb2 03				db 2 + 1 
abb3 .. 00			db "-!",0              
abb6				endm 
# End of macro CWHEAD
abb6			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
abb6					if DEBUG_FORTH_WORDS_KEY 
abb6						DMARK "-s_" 
abb6 f5				push af  
abb7 3a cb ab			ld a, (.dmark)  
abba 32 6b ee			ld (debug_mark),a  
abbd 3a cc ab			ld a, (.dmark+1)  
abc0 32 6c ee			ld (debug_mark+1),a  
abc3 3a cd ab			ld a, (.dmark+2)  
abc6 32 6d ee			ld (debug_mark+2),a  
abc9 18 03			jr .pastdmark  
abcb ..			.dmark: db "-s_"  
abce f1			.pastdmark: pop af  
abcf			endm  
# End of macro DMARK
abcf						CALLMONITOR 
abcf cd 6f ee			call debug_vector  
abd2				endm  
# End of macro CALLMONITOR
abd2					endif 
abd2			 
abd2					FORTH_DSP_VALUEHL 
abd2 cd 32 9d			call macro_dsp_valuehl 
abd5				endm 
# End of macro FORTH_DSP_VALUEHL
abd5			 
abd5 e5					push hl   ; save address 
abd6			 
abd6					FORTH_DSP_POP 
abd6 cd ea 9d			call macro_forth_dsp_pop 
abd9				endm 
# End of macro FORTH_DSP_POP
abd9			 
abd9					FORTH_DSP_VALUEHL 
abd9 cd 32 9d			call macro_dsp_valuehl 
abdc				endm 
# End of macro FORTH_DSP_VALUEHL
abdc			 
abdc					; hl contains value to add to byte at a 
abdc				 
abdc eb					ex de, hl 
abdd			 
abdd e1					pop hl 
abde			 
abde					if DEBUG_FORTH_WORDS 
abde						DMARK "DEC" 
abde f5				push af  
abdf 3a f3 ab			ld a, (.dmark)  
abe2 32 6b ee			ld (debug_mark),a  
abe5 3a f4 ab			ld a, (.dmark+1)  
abe8 32 6c ee			ld (debug_mark+1),a  
abeb 3a f5 ab			ld a, (.dmark+2)  
abee 32 6d ee			ld (debug_mark+2),a  
abf1 18 03			jr .pastdmark  
abf3 ..			.dmark: db "DEC"  
abf6 f1			.pastdmark: pop af  
abf7			endm  
# End of macro DMARK
abf7						CALLMONITOR 
abf7 cd 6f ee			call debug_vector  
abfa				endm  
# End of macro CALLMONITOR
abfa					endif 
abfa			 
abfa 7e					ld a,(hl) 
abfb 93					sub e 
abfc 77					ld (hl),a 
abfd			 
abfd			 
abfd					FORTH_DSP_POP 
abfd cd ea 9d			call macro_forth_dsp_pop 
ac00				endm 
# End of macro FORTH_DSP_POP
ac00			 
ac00				       NEXTW 
ac00 c3 e8 9e			jp macro_next 
ac03				endm 
# End of macro NEXTW
ac03			 
ac03			.INC2: 
ac03				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ac03 6f				db WORD_SYS_CORE+91             
ac04 b0 ac			dw .DEC2            
ac06 04				db 3 + 1 
ac07 .. 00			db "+2!",0              
ac0b				endm 
# End of macro CWHEAD
ac0b			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ac0b			 
ac0b					if DEBUG_FORTH_WORDS_KEY 
ac0b						DMARK "+2s" 
ac0b f5				push af  
ac0c 3a 20 ac			ld a, (.dmark)  
ac0f 32 6b ee			ld (debug_mark),a  
ac12 3a 21 ac			ld a, (.dmark+1)  
ac15 32 6c ee			ld (debug_mark+1),a  
ac18 3a 22 ac			ld a, (.dmark+2)  
ac1b 32 6d ee			ld (debug_mark+2),a  
ac1e 18 03			jr .pastdmark  
ac20 ..			.dmark: db "+2s"  
ac23 f1			.pastdmark: pop af  
ac24			endm  
# End of macro DMARK
ac24						CALLMONITOR 
ac24 cd 6f ee			call debug_vector  
ac27				endm  
# End of macro CALLMONITOR
ac27					endif 
ac27			 
ac27					; Address 
ac27			 
ac27					FORTH_DSP_VALUEHL 
ac27 cd 32 9d			call macro_dsp_valuehl 
ac2a				endm 
# End of macro FORTH_DSP_VALUEHL
ac2a			 
ac2a e5					push hl    ; save address 
ac2b			 
ac2b					; load content into de 
ac2b			 
ac2b 5e					ld e,(hl) 
ac2c 23					inc hl 
ac2d 56					ld d, (hl) 
ac2e			 
ac2e					if DEBUG_FORTH_WORDS 
ac2e						DMARK "+2a" 
ac2e f5				push af  
ac2f 3a 43 ac			ld a, (.dmark)  
ac32 32 6b ee			ld (debug_mark),a  
ac35 3a 44 ac			ld a, (.dmark+1)  
ac38 32 6c ee			ld (debug_mark+1),a  
ac3b 3a 45 ac			ld a, (.dmark+2)  
ac3e 32 6d ee			ld (debug_mark+2),a  
ac41 18 03			jr .pastdmark  
ac43 ..			.dmark: db "+2a"  
ac46 f1			.pastdmark: pop af  
ac47			endm  
# End of macro DMARK
ac47						CALLMONITOR 
ac47 cd 6f ee			call debug_vector  
ac4a				endm  
# End of macro CALLMONITOR
ac4a					endif 
ac4a			 
ac4a					FORTH_DSP_POP 
ac4a cd ea 9d			call macro_forth_dsp_pop 
ac4d				endm 
# End of macro FORTH_DSP_POP
ac4d			 
ac4d					; Get value to add 
ac4d			 
ac4d					FORTH_DSP_VALUE 
ac4d cd 1b 9d			call macro_forth_dsp_value 
ac50				endm 
# End of macro FORTH_DSP_VALUE
ac50			 
ac50					if DEBUG_FORTH_WORDS 
ac50						DMARK "+2v" 
ac50 f5				push af  
ac51 3a 65 ac			ld a, (.dmark)  
ac54 32 6b ee			ld (debug_mark),a  
ac57 3a 66 ac			ld a, (.dmark+1)  
ac5a 32 6c ee			ld (debug_mark+1),a  
ac5d 3a 67 ac			ld a, (.dmark+2)  
ac60 32 6d ee			ld (debug_mark+2),a  
ac63 18 03			jr .pastdmark  
ac65 ..			.dmark: db "+2v"  
ac68 f1			.pastdmark: pop af  
ac69			endm  
# End of macro DMARK
ac69						CALLMONITOR 
ac69 cd 6f ee			call debug_vector  
ac6c				endm  
# End of macro CALLMONITOR
ac6c					endif 
ac6c			 
ac6c 19					add hl, de 
ac6d			 
ac6d					if DEBUG_FORTH_WORDS 
ac6d						DMARK "+2+" 
ac6d f5				push af  
ac6e 3a 82 ac			ld a, (.dmark)  
ac71 32 6b ee			ld (debug_mark),a  
ac74 3a 83 ac			ld a, (.dmark+1)  
ac77 32 6c ee			ld (debug_mark+1),a  
ac7a 3a 84 ac			ld a, (.dmark+2)  
ac7d 32 6d ee			ld (debug_mark+2),a  
ac80 18 03			jr .pastdmark  
ac82 ..			.dmark: db "+2+"  
ac85 f1			.pastdmark: pop af  
ac86			endm  
# End of macro DMARK
ac86						CALLMONITOR 
ac86 cd 6f ee			call debug_vector  
ac89				endm  
# End of macro CALLMONITOR
ac89					endif 
ac89			 
ac89					; move result to de 
ac89			 
ac89 eb					ex de, hl 
ac8a			 
ac8a					; Address 
ac8a			 
ac8a e1					pop hl 
ac8b			 
ac8b					; save it back 
ac8b			 
ac8b 73					ld (hl), e 
ac8c 23					inc hl 
ac8d 72					ld (hl), d 
ac8e			 
ac8e					if DEBUG_FORTH_WORDS 
ac8e						DMARK "+2e" 
ac8e f5				push af  
ac8f 3a a3 ac			ld a, (.dmark)  
ac92 32 6b ee			ld (debug_mark),a  
ac95 3a a4 ac			ld a, (.dmark+1)  
ac98 32 6c ee			ld (debug_mark+1),a  
ac9b 3a a5 ac			ld a, (.dmark+2)  
ac9e 32 6d ee			ld (debug_mark+2),a  
aca1 18 03			jr .pastdmark  
aca3 ..			.dmark: db "+2e"  
aca6 f1			.pastdmark: pop af  
aca7			endm  
# End of macro DMARK
aca7						CALLMONITOR 
aca7 cd 6f ee			call debug_vector  
acaa				endm  
# End of macro CALLMONITOR
acaa					endif 
acaa			 
acaa			 
acaa			 
acaa					FORTH_DSP_POP 
acaa cd ea 9d			call macro_forth_dsp_pop 
acad				endm 
# End of macro FORTH_DSP_POP
acad			 
acad			 
acad				       NEXTW 
acad c3 e8 9e			jp macro_next 
acb0				endm 
# End of macro NEXTW
acb0			 
acb0			.DEC2: 
acb0				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
acb0 6f				db WORD_SYS_CORE+91             
acb1 5f ad			dw .GET2            
acb3 04				db 3 + 1 
acb4 .. 00			db "-2!",0              
acb8				endm 
# End of macro CWHEAD
acb8			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
acb8			 
acb8			 
acb8					if DEBUG_FORTH_WORDS_KEY 
acb8						DMARK "-2s" 
acb8 f5				push af  
acb9 3a cd ac			ld a, (.dmark)  
acbc 32 6b ee			ld (debug_mark),a  
acbf 3a ce ac			ld a, (.dmark+1)  
acc2 32 6c ee			ld (debug_mark+1),a  
acc5 3a cf ac			ld a, (.dmark+2)  
acc8 32 6d ee			ld (debug_mark+2),a  
accb 18 03			jr .pastdmark  
accd ..			.dmark: db "-2s"  
acd0 f1			.pastdmark: pop af  
acd1			endm  
# End of macro DMARK
acd1						CALLMONITOR 
acd1 cd 6f ee			call debug_vector  
acd4				endm  
# End of macro CALLMONITOR
acd4					endif 
acd4			 
acd4					; Address 
acd4			 
acd4					FORTH_DSP_VALUEHL 
acd4 cd 32 9d			call macro_dsp_valuehl 
acd7				endm 
# End of macro FORTH_DSP_VALUEHL
acd7			 
acd7 e5					push hl    ; save address 
acd8			 
acd8					; load content into de 
acd8			 
acd8 5e					ld e,(hl) 
acd9 23					inc hl 
acda 56					ld d, (hl) 
acdb			 
acdb					if DEBUG_FORTH_WORDS 
acdb						DMARK "-2a" 
acdb f5				push af  
acdc 3a f0 ac			ld a, (.dmark)  
acdf 32 6b ee			ld (debug_mark),a  
ace2 3a f1 ac			ld a, (.dmark+1)  
ace5 32 6c ee			ld (debug_mark+1),a  
ace8 3a f2 ac			ld a, (.dmark+2)  
aceb 32 6d ee			ld (debug_mark+2),a  
acee 18 03			jr .pastdmark  
acf0 ..			.dmark: db "-2a"  
acf3 f1			.pastdmark: pop af  
acf4			endm  
# End of macro DMARK
acf4						CALLMONITOR 
acf4 cd 6f ee			call debug_vector  
acf7				endm  
# End of macro CALLMONITOR
acf7					endif 
acf7			 
acf7					FORTH_DSP_POP 
acf7 cd ea 9d			call macro_forth_dsp_pop 
acfa				endm 
# End of macro FORTH_DSP_POP
acfa			 
acfa					; Get value to remove 
acfa			 
acfa					FORTH_DSP_VALUE 
acfa cd 1b 9d			call macro_forth_dsp_value 
acfd				endm 
# End of macro FORTH_DSP_VALUE
acfd			 
acfd					if DEBUG_FORTH_WORDS 
acfd						DMARK "-2v" 
acfd f5				push af  
acfe 3a 12 ad			ld a, (.dmark)  
ad01 32 6b ee			ld (debug_mark),a  
ad04 3a 13 ad			ld a, (.dmark+1)  
ad07 32 6c ee			ld (debug_mark+1),a  
ad0a 3a 14 ad			ld a, (.dmark+2)  
ad0d 32 6d ee			ld (debug_mark+2),a  
ad10 18 03			jr .pastdmark  
ad12 ..			.dmark: db "-2v"  
ad15 f1			.pastdmark: pop af  
ad16			endm  
# End of macro DMARK
ad16						CALLMONITOR 
ad16 cd 6f ee			call debug_vector  
ad19				endm  
# End of macro CALLMONITOR
ad19					endif 
ad19			 
ad19 eb					ex de, hl 
ad1a ed 52				sbc hl, de 
ad1c			 
ad1c					if DEBUG_FORTH_WORDS 
ad1c						DMARK "-2d" 
ad1c f5				push af  
ad1d 3a 31 ad			ld a, (.dmark)  
ad20 32 6b ee			ld (debug_mark),a  
ad23 3a 32 ad			ld a, (.dmark+1)  
ad26 32 6c ee			ld (debug_mark+1),a  
ad29 3a 33 ad			ld a, (.dmark+2)  
ad2c 32 6d ee			ld (debug_mark+2),a  
ad2f 18 03			jr .pastdmark  
ad31 ..			.dmark: db "-2d"  
ad34 f1			.pastdmark: pop af  
ad35			endm  
# End of macro DMARK
ad35						CALLMONITOR 
ad35 cd 6f ee			call debug_vector  
ad38				endm  
# End of macro CALLMONITOR
ad38					endif 
ad38			 
ad38					; move result to de 
ad38			 
ad38 eb					ex de, hl 
ad39			 
ad39					; Address 
ad39			 
ad39 e1					pop hl 
ad3a			 
ad3a					; save it back 
ad3a			 
ad3a 73					ld (hl), e 
ad3b 23					inc hl 
ad3c 72					ld (hl), d 
ad3d			 
ad3d					if DEBUG_FORTH_WORDS 
ad3d						DMARK "-2e" 
ad3d f5				push af  
ad3e 3a 52 ad			ld a, (.dmark)  
ad41 32 6b ee			ld (debug_mark),a  
ad44 3a 53 ad			ld a, (.dmark+1)  
ad47 32 6c ee			ld (debug_mark+1),a  
ad4a 3a 54 ad			ld a, (.dmark+2)  
ad4d 32 6d ee			ld (debug_mark+2),a  
ad50 18 03			jr .pastdmark  
ad52 ..			.dmark: db "-2e"  
ad55 f1			.pastdmark: pop af  
ad56			endm  
# End of macro DMARK
ad56						CALLMONITOR 
ad56 cd 6f ee			call debug_vector  
ad59				endm  
# End of macro CALLMONITOR
ad59					endif 
ad59			 
ad59			 
ad59					FORTH_DSP_POP 
ad59 cd ea 9d			call macro_forth_dsp_pop 
ad5c				endm 
# End of macro FORTH_DSP_POP
ad5c			 
ad5c			 
ad5c			 
ad5c				       NEXTW 
ad5c c3 e8 9e			jp macro_next 
ad5f				endm 
# End of macro NEXTW
ad5f			.GET2: 
ad5f				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad5f 6f				db WORD_SYS_CORE+91             
ad60 94 ad			dw .BANG2            
ad62 03				db 2 + 1 
ad63 .. 00			db "2@",0              
ad66				endm 
# End of macro CWHEAD
ad66			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad66					if DEBUG_FORTH_WORDS_KEY 
ad66						DMARK "2A_" 
ad66 f5				push af  
ad67 3a 7b ad			ld a, (.dmark)  
ad6a 32 6b ee			ld (debug_mark),a  
ad6d 3a 7c ad			ld a, (.dmark+1)  
ad70 32 6c ee			ld (debug_mark+1),a  
ad73 3a 7d ad			ld a, (.dmark+2)  
ad76 32 6d ee			ld (debug_mark+2),a  
ad79 18 03			jr .pastdmark  
ad7b ..			.dmark: db "2A_"  
ad7e f1			.pastdmark: pop af  
ad7f			endm  
# End of macro DMARK
ad7f						CALLMONITOR 
ad7f cd 6f ee			call debug_vector  
ad82				endm  
# End of macro CALLMONITOR
ad82					endif 
ad82			 
ad82					FORTH_DSP_VALUEHL 
ad82 cd 32 9d			call macro_dsp_valuehl 
ad85				endm 
# End of macro FORTH_DSP_VALUEHL
ad85			 
ad85 e5					push hl   ; save address 
ad86			 
ad86					FORTH_DSP_POP 
ad86 cd ea 9d			call macro_forth_dsp_pop 
ad89				endm 
# End of macro FORTH_DSP_POP
ad89			 
ad89 e1					pop hl 
ad8a			 
ad8a 5e					ld e, (hl) 
ad8b 23					inc hl 
ad8c 56					ld d, (hl) 
ad8d			 
ad8d eb					ex de, hl 
ad8e			 
ad8e cd 3b 9b				call forth_push_numhl 
ad91			 
ad91				       NEXTW 
ad91 c3 e8 9e			jp macro_next 
ad94				endm 
# End of macro NEXTW
ad94			.BANG2: 
ad94				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad94 6f				db WORD_SYS_CORE+91             
ad95 cc ad			dw .CONFIG            
ad97 03				db 2 + 1 
ad98 .. 00			db "2!",0              
ad9b				endm 
# End of macro CWHEAD
ad9b			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad9b					if DEBUG_FORTH_WORDS_KEY 
ad9b						DMARK "2S_" 
ad9b f5				push af  
ad9c 3a b0 ad			ld a, (.dmark)  
ad9f 32 6b ee			ld (debug_mark),a  
ada2 3a b1 ad			ld a, (.dmark+1)  
ada5 32 6c ee			ld (debug_mark+1),a  
ada8 3a b2 ad			ld a, (.dmark+2)  
adab 32 6d ee			ld (debug_mark+2),a  
adae 18 03			jr .pastdmark  
adb0 ..			.dmark: db "2S_"  
adb3 f1			.pastdmark: pop af  
adb4			endm  
# End of macro DMARK
adb4						CALLMONITOR 
adb4 cd 6f ee			call debug_vector  
adb7				endm  
# End of macro CALLMONITOR
adb7					endif 
adb7			 
adb7					FORTH_DSP_VALUEHL 
adb7 cd 32 9d			call macro_dsp_valuehl 
adba				endm 
# End of macro FORTH_DSP_VALUEHL
adba			 
adba e5					push hl   ; save address 
adbb			 
adbb			 
adbb					FORTH_DSP_POP 
adbb cd ea 9d			call macro_forth_dsp_pop 
adbe				endm 
# End of macro FORTH_DSP_POP
adbe			 
adbe					 
adbe					FORTH_DSP_VALUEHL 
adbe cd 32 9d			call macro_dsp_valuehl 
adc1				endm 
# End of macro FORTH_DSP_VALUEHL
adc1			 
adc1					FORTH_DSP_POP 
adc1 cd ea 9d			call macro_forth_dsp_pop 
adc4				endm 
# End of macro FORTH_DSP_POP
adc4			 
adc4 eb					ex de, hl    ; value now in de 
adc5			 
adc5 e1					pop hl 
adc6			 
adc6 73					ld (hl), e 
adc7			 
adc7 23					inc hl 
adc8			 
adc8 72					ld (hl), d 
adc9			 
adc9			 
adc9				       NEXTW 
adc9 c3 e8 9e			jp macro_next 
adcc				endm 
# End of macro NEXTW
adcc			.CONFIG: 
adcc				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
adcc 6f				db WORD_SYS_CORE+91             
adcd dd ad			dw .ADTOS            
adcf 07				db 6 + 1 
add0 .. 00			db "CONFIG",0              
add7				endm 
# End of macro CWHEAD
add7			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
add7			 
add7 cd 3b 93				call config 
adda					NEXTW 
adda c3 e8 9e			jp macro_next 
addd				endm 
# End of macro NEXTW
addd			 
addd			.ADTOS: 
addd				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
addd 6f				db WORD_SYS_CORE+91             
adde f3 ad			dw .SBTOS            
ade0 03				db 2 + 1 
ade1 .. 00			db "1+",0              
ade4				endm 
# End of macro CWHEAD
ade4			; | 1+ ( u -- u )  Increment value on TOS | DONE 
ade4			 
ade4					FORTH_DSP_VALUEHL 
ade4 cd 32 9d			call macro_dsp_valuehl 
ade7				endm 
# End of macro FORTH_DSP_VALUEHL
ade7 e5					push hl 
ade8			 
ade8					FORTH_DSP_POP 
ade8 cd ea 9d			call macro_forth_dsp_pop 
adeb				endm 
# End of macro FORTH_DSP_POP
adeb e1					pop hl 
adec			 
adec 23					inc hl 
aded cd 3b 9b				call forth_push_numhl 
adf0					 
adf0					NEXTW 
adf0 c3 e8 9e			jp macro_next 
adf3				endm 
# End of macro NEXTW
adf3			.SBTOS: 
adf3				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
adf3 6f				db WORD_SYS_CORE+91             
adf4 09 ae			dw .ADSTORE            
adf6 03				db 2 + 1 
adf7 .. 00			db "1-",0              
adfa				endm 
# End of macro CWHEAD
adfa			; | 1- ( u -- u )  Decrement value on TOS | DONE 
adfa			 
adfa					FORTH_DSP_VALUEHL 
adfa cd 32 9d			call macro_dsp_valuehl 
adfd				endm 
# End of macro FORTH_DSP_VALUEHL
adfd e5					push hl 
adfe			 
adfe					FORTH_DSP_POP 
adfe cd ea 9d			call macro_forth_dsp_pop 
ae01				endm 
# End of macro FORTH_DSP_POP
ae01 e1					pop hl 
ae02			 
ae02 2b					dec hl 
ae03 cd 3b 9b				call forth_push_numhl 
ae06					 
ae06					NEXTW 
ae06 c3 e8 9e			jp macro_next 
ae09				endm 
# End of macro NEXTW
ae09			.ADSTORE: 
ae09				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
ae09 6f				db WORD_SYS_CORE+91             
ae0a 1f ae			dw .ADWSTORE            
ae0c 04				db 3 + 1 
ae0d .. 00			db "1+!",0              
ae11				endm 
# End of macro CWHEAD
ae11			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ae11			 
ae11					FORTH_DSP_VALUEHL 
ae11 cd 32 9d			call macro_dsp_valuehl 
ae14				endm 
# End of macro FORTH_DSP_VALUEHL
ae14 e5					push hl 
ae15			 
ae15					FORTH_DSP_POP 
ae15 cd ea 9d			call macro_forth_dsp_pop 
ae18				endm 
# End of macro FORTH_DSP_POP
ae18 e1					pop hl 
ae19			 
ae19 7e					ld a, (hl) 
ae1a 3c					inc a 
ae1b 77					ld (hl), a 
ae1c					 
ae1c					NEXTW 
ae1c c3 e8 9e			jp macro_next 
ae1f				endm 
# End of macro NEXTW
ae1f			.ADWSTORE: 
ae1f				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
ae1f 6f				db WORD_SYS_CORE+91             
ae20 3d ae			dw .SBSTORE            
ae22 05				db 4 + 1 
ae23 .. 00			db "1+2!",0              
ae28				endm 
# End of macro CWHEAD
ae28			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ae28			 
ae28					FORTH_DSP_VALUEHL 
ae28 cd 32 9d			call macro_dsp_valuehl 
ae2b				endm 
# End of macro FORTH_DSP_VALUEHL
ae2b e5					push hl 
ae2c			 
ae2c					FORTH_DSP_POP 
ae2c cd ea 9d			call macro_forth_dsp_pop 
ae2f				endm 
# End of macro FORTH_DSP_POP
ae2f e1					pop hl 
ae30			 
ae30 e5					push hl 
ae31			 
ae31 cd 6a 9e				call loadwordinhl 
ae34 23					inc hl 
ae35			 
ae35 d1					pop de 
ae36 eb					ex de, hl 
ae37 73					ld (hl), e 
ae38 23					inc hl 
ae39 72					ld (hl), d 
ae3a					 
ae3a					NEXTW 
ae3a c3 e8 9e			jp macro_next 
ae3d				endm 
# End of macro NEXTW
ae3d			.SBSTORE: 
ae3d				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
ae3d 6f				db WORD_SYS_CORE+91             
ae3e 53 ae			dw .SBWSTORE            
ae40 04				db 3 + 1 
ae41 .. 00			db "1-!",0              
ae45				endm 
# End of macro CWHEAD
ae45			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
ae45			 
ae45					FORTH_DSP_VALUEHL 
ae45 cd 32 9d			call macro_dsp_valuehl 
ae48				endm 
# End of macro FORTH_DSP_VALUEHL
ae48 e5					push hl 
ae49			 
ae49					FORTH_DSP_POP 
ae49 cd ea 9d			call macro_forth_dsp_pop 
ae4c				endm 
# End of macro FORTH_DSP_POP
ae4c e1					pop hl 
ae4d			 
ae4d 7e					ld a, (hl) 
ae4e 3d					dec a 
ae4f 77					ld (hl), a 
ae50					 
ae50					NEXTW 
ae50 c3 e8 9e			jp macro_next 
ae53				endm 
# End of macro NEXTW
ae53			.SBWSTORE: 
ae53				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
ae53 6f				db WORD_SYS_CORE+91             
ae54 71 ae			dw .ENDCORE            
ae56 05				db 4 + 1 
ae57 .. 00			db "1-2!",0              
ae5c				endm 
# End of macro CWHEAD
ae5c			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
ae5c			 
ae5c					FORTH_DSP_VALUEHL 
ae5c cd 32 9d			call macro_dsp_valuehl 
ae5f				endm 
# End of macro FORTH_DSP_VALUEHL
ae5f e5					push hl 
ae60			 
ae60					FORTH_DSP_POP 
ae60 cd ea 9d			call macro_forth_dsp_pop 
ae63				endm 
# End of macro FORTH_DSP_POP
ae63 e1					pop hl 
ae64			 
ae64 e5					push hl 
ae65			 
ae65 cd 6a 9e				call loadwordinhl 
ae68 2b					dec hl 
ae69			 
ae69 d1					pop de 
ae6a eb					ex de, hl 
ae6b 73					ld (hl), e 
ae6c 23					inc hl 
ae6d 72					ld (hl), d 
ae6e					 
ae6e					NEXTW 
ae6e c3 e8 9e			jp macro_next 
ae71				endm 
# End of macro NEXTW
ae71			.ENDCORE: 
ae71			 
ae71			; eof 
ae71			 
ae71			 
# End of file forth_words_core.asm
ae71			include "forth_words_flow.asm" 
ae71			 
ae71			; | ## Program Flow Words 
ae71			 
ae71			.IF: 
ae71				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ae71 1e				db WORD_SYS_CORE+10             
ae72 66 af			dw .THEN            
ae74 03				db 2 + 1 
ae75 .. 00			db "IF",0              
ae78				endm 
# End of macro CWHEAD
ae78			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ae78			; 
ae78					if DEBUG_FORTH_WORDS_KEY 
ae78						DMARK "IF." 
ae78 f5				push af  
ae79 3a 8d ae			ld a, (.dmark)  
ae7c 32 6b ee			ld (debug_mark),a  
ae7f 3a 8e ae			ld a, (.dmark+1)  
ae82 32 6c ee			ld (debug_mark+1),a  
ae85 3a 8f ae			ld a, (.dmark+2)  
ae88 32 6d ee			ld (debug_mark+2),a  
ae8b 18 03			jr .pastdmark  
ae8d ..			.dmark: db "IF."  
ae90 f1			.pastdmark: pop af  
ae91			endm  
# End of macro DMARK
ae91						CALLMONITOR 
ae91 cd 6f ee			call debug_vector  
ae94				endm  
# End of macro CALLMONITOR
ae94					endif 
ae94			; eval TOS 
ae94			 
ae94				FORTH_DSP_VALUEHL 
ae94 cd 32 9d			call macro_dsp_valuehl 
ae97				endm 
# End of macro FORTH_DSP_VALUEHL
ae97			 
ae97			;	push hl 
ae97				FORTH_DSP_POP 
ae97 cd ea 9d			call macro_forth_dsp_pop 
ae9a				endm 
# End of macro FORTH_DSP_POP
ae9a			;	pop hl 
ae9a			 
ae9a					if DEBUG_FORTH_WORDS 
ae9a						DMARK "IF1" 
ae9a f5				push af  
ae9b 3a af ae			ld a, (.dmark)  
ae9e 32 6b ee			ld (debug_mark),a  
aea1 3a b0 ae			ld a, (.dmark+1)  
aea4 32 6c ee			ld (debug_mark+1),a  
aea7 3a b1 ae			ld a, (.dmark+2)  
aeaa 32 6d ee			ld (debug_mark+2),a  
aead 18 03			jr .pastdmark  
aeaf ..			.dmark: db "IF1"  
aeb2 f1			.pastdmark: pop af  
aeb3			endm  
# End of macro DMARK
aeb3						CALLMONITOR 
aeb3 cd 6f ee			call debug_vector  
aeb6				endm  
# End of macro CALLMONITOR
aeb6					endif 
aeb6 b7				or a        ; clear carry flag 
aeb7 11 00 00			ld de, 0 
aeba eb				ex de,hl 
aebb ed 52			sbc hl, de 
aebd c2 47 af			jp nz, .iftrue 
aec0			 
aec0					if DEBUG_FORTH_WORDS 
aec0						DMARK "IF2" 
aec0 f5				push af  
aec1 3a d5 ae			ld a, (.dmark)  
aec4 32 6b ee			ld (debug_mark),a  
aec7 3a d6 ae			ld a, (.dmark+1)  
aeca 32 6c ee			ld (debug_mark+1),a  
aecd 3a d7 ae			ld a, (.dmark+2)  
aed0 32 6d ee			ld (debug_mark+2),a  
aed3 18 03			jr .pastdmark  
aed5 ..			.dmark: db "IF2"  
aed8 f1			.pastdmark: pop af  
aed9			endm  
# End of macro DMARK
aed9						CALLMONITOR 
aed9 cd 6f ee			call debug_vector  
aedc				endm  
# End of macro CALLMONITOR
aedc					endif 
aedc			 
aedc			; if not true then skip to THEN 
aedc			 
aedc				; TODO get tok_ptr 
aedc				; TODO consume toks until we get to THEN 
aedc			 
aedc 2a c2 e5			ld hl, (os_tok_ptr) 
aedf					if DEBUG_FORTH_WORDS 
aedf						DMARK "IF3" 
aedf f5				push af  
aee0 3a f4 ae			ld a, (.dmark)  
aee3 32 6b ee			ld (debug_mark),a  
aee6 3a f5 ae			ld a, (.dmark+1)  
aee9 32 6c ee			ld (debug_mark+1),a  
aeec 3a f6 ae			ld a, (.dmark+2)  
aeef 32 6d ee			ld (debug_mark+2),a  
aef2 18 03			jr .pastdmark  
aef4 ..			.dmark: db "IF3"  
aef7 f1			.pastdmark: pop af  
aef8			endm  
# End of macro DMARK
aef8						CALLMONITOR 
aef8 cd 6f ee			call debug_vector  
aefb				endm  
# End of macro CALLMONITOR
aefb						 
aefb					endif 
aefb 11 42 af			ld de, .ifthen 
aefe					if DEBUG_FORTH_WORDS 
aefe						DMARK "IF4" 
aefe f5				push af  
aeff 3a 13 af			ld a, (.dmark)  
af02 32 6b ee			ld (debug_mark),a  
af05 3a 14 af			ld a, (.dmark+1)  
af08 32 6c ee			ld (debug_mark+1),a  
af0b 3a 15 af			ld a, (.dmark+2)  
af0e 32 6d ee			ld (debug_mark+2),a  
af11 18 03			jr .pastdmark  
af13 ..			.dmark: db "IF4"  
af16 f1			.pastdmark: pop af  
af17			endm  
# End of macro DMARK
af17						CALLMONITOR 
af17 cd 6f ee			call debug_vector  
af1a				endm  
# End of macro CALLMONITOR
af1a					endif 
af1a cd 03 a0			call findnexttok  
af1d			 
af1d					if DEBUG_FORTH_WORDS 
af1d						DMARK "IF5" 
af1d f5				push af  
af1e 3a 32 af			ld a, (.dmark)  
af21 32 6b ee			ld (debug_mark),a  
af24 3a 33 af			ld a, (.dmark+1)  
af27 32 6c ee			ld (debug_mark+1),a  
af2a 3a 34 af			ld a, (.dmark+2)  
af2d 32 6d ee			ld (debug_mark+2),a  
af30 18 03			jr .pastdmark  
af32 ..			.dmark: db "IF5"  
af35 f1			.pastdmark: pop af  
af36			endm  
# End of macro DMARK
af36						CALLMONITOR 
af36 cd 6f ee			call debug_vector  
af39				endm  
# End of macro CALLMONITOR
af39					endif 
af39				; TODO replace below with ; exec using tok_ptr 
af39 22 c2 e5			ld (os_tok_ptr), hl 
af3c c3 79 9f			jp exec1 
af3f				NEXTW 
af3f c3 e8 9e			jp macro_next 
af42				endm 
# End of macro NEXTW
af42			 
af42 .. 00		.ifthen:  db "THEN",0 
af47			 
af47			.iftrue:		 
af47				; Exec next words normally 
af47			 
af47				; if true then exec following IF as normal 
af47					if DEBUG_FORTH_WORDS 
af47						DMARK "IFT" 
af47 f5				push af  
af48 3a 5c af			ld a, (.dmark)  
af4b 32 6b ee			ld (debug_mark),a  
af4e 3a 5d af			ld a, (.dmark+1)  
af51 32 6c ee			ld (debug_mark+1),a  
af54 3a 5e af			ld a, (.dmark+2)  
af57 32 6d ee			ld (debug_mark+2),a  
af5a 18 03			jr .pastdmark  
af5c ..			.dmark: db "IFT"  
af5f f1			.pastdmark: pop af  
af60			endm  
# End of macro DMARK
af60						CALLMONITOR 
af60 cd 6f ee			call debug_vector  
af63				endm  
# End of macro CALLMONITOR
af63					endif 
af63			 
af63					NEXTW 
af63 c3 e8 9e			jp macro_next 
af66				endm 
# End of macro NEXTW
af66			.THEN: 
af66				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
af66 1f				db WORD_SYS_CORE+11             
af67 8e af			dw .ELSE            
af69 05				db 4 + 1 
af6a .. 00			db "THEN",0              
af6f				endm 
# End of macro CWHEAD
af6f			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
af6f					if DEBUG_FORTH_WORDS_KEY 
af6f						DMARK "THN" 
af6f f5				push af  
af70 3a 84 af			ld a, (.dmark)  
af73 32 6b ee			ld (debug_mark),a  
af76 3a 85 af			ld a, (.dmark+1)  
af79 32 6c ee			ld (debug_mark+1),a  
af7c 3a 86 af			ld a, (.dmark+2)  
af7f 32 6d ee			ld (debug_mark+2),a  
af82 18 03			jr .pastdmark  
af84 ..			.dmark: db "THN"  
af87 f1			.pastdmark: pop af  
af88			endm  
# End of macro DMARK
af88						CALLMONITOR 
af88 cd 6f ee			call debug_vector  
af8b				endm  
# End of macro CALLMONITOR
af8b					endif 
af8b					NEXTW 
af8b c3 e8 9e			jp macro_next 
af8e				endm 
# End of macro NEXTW
af8e			.ELSE: 
af8e				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
af8e 20				db WORD_SYS_CORE+12             
af8f b6 af			dw .DO            
af91 03				db 2 + 1 
af92 .. 00			db "ELSE",0              
af97				endm 
# End of macro CWHEAD
af97			; | ELSE ( -- ) Not supported - does nothing | TODO 
af97			 
af97					if DEBUG_FORTH_WORDS_KEY 
af97						DMARK "ELS" 
af97 f5				push af  
af98 3a ac af			ld a, (.dmark)  
af9b 32 6b ee			ld (debug_mark),a  
af9e 3a ad af			ld a, (.dmark+1)  
afa1 32 6c ee			ld (debug_mark+1),a  
afa4 3a ae af			ld a, (.dmark+2)  
afa7 32 6d ee			ld (debug_mark+2),a  
afaa 18 03			jr .pastdmark  
afac ..			.dmark: db "ELS"  
afaf f1			.pastdmark: pop af  
afb0			endm  
# End of macro DMARK
afb0						CALLMONITOR 
afb0 cd 6f ee			call debug_vector  
afb3				endm  
# End of macro CALLMONITOR
afb3					endif 
afb3			 
afb3			 
afb3					NEXTW 
afb3 c3 e8 9e			jp macro_next 
afb6				endm 
# End of macro NEXTW
afb6			.DO: 
afb6				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
afb6 21				db WORD_SYS_CORE+13             
afb7 dd b0			dw .LOOP            
afb9 03				db 2 + 1 
afba .. 00			db "DO",0              
afbd				endm 
# End of macro CWHEAD
afbd			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
afbd			 
afbd					if DEBUG_FORTH_WORDS_KEY 
afbd						DMARK "DO." 
afbd f5				push af  
afbe 3a d2 af			ld a, (.dmark)  
afc1 32 6b ee			ld (debug_mark),a  
afc4 3a d3 af			ld a, (.dmark+1)  
afc7 32 6c ee			ld (debug_mark+1),a  
afca 3a d4 af			ld a, (.dmark+2)  
afcd 32 6d ee			ld (debug_mark+2),a  
afd0 18 03			jr .pastdmark  
afd2 ..			.dmark: db "DO."  
afd5 f1			.pastdmark: pop af  
afd6			endm  
# End of macro DMARK
afd6						CALLMONITOR 
afd6 cd 6f ee			call debug_vector  
afd9				endm  
# End of macro CALLMONITOR
afd9					endif 
afd9			;  push pc to rsp stack past the DO 
afd9			 
afd9 2a c2 e5				ld hl, (os_tok_ptr) 
afdc 23					inc hl   ; D 
afdd 23					inc hl  ; O 
afde 23					inc hl   ; null 
afdf					if DEBUG_FORTH_WORDS 
afdf						DMARK "DO2" 
afdf f5				push af  
afe0 3a f4 af			ld a, (.dmark)  
afe3 32 6b ee			ld (debug_mark),a  
afe6 3a f5 af			ld a, (.dmark+1)  
afe9 32 6c ee			ld (debug_mark+1),a  
afec 3a f6 af			ld a, (.dmark+2)  
afef 32 6d ee			ld (debug_mark+2),a  
aff2 18 03			jr .pastdmark  
aff4 ..			.dmark: db "DO2"  
aff7 f1			.pastdmark: pop af  
aff8			endm  
# End of macro DMARK
aff8						CALLMONITOR 
aff8 cd 6f ee			call debug_vector  
affb				endm  
# End of macro CALLMONITOR
affb					endif 
affb					FORTH_RSP_NEXT 
affb cd e2 9a			call macro_forth_rsp_next 
affe				endm 
# End of macro FORTH_RSP_NEXT
affe					if DEBUG_FORTH_WORDS 
affe						DMARK "DO3" 
affe f5				push af  
afff 3a 13 b0			ld a, (.dmark)  
b002 32 6b ee			ld (debug_mark),a  
b005 3a 14 b0			ld a, (.dmark+1)  
b008 32 6c ee			ld (debug_mark+1),a  
b00b 3a 15 b0			ld a, (.dmark+2)  
b00e 32 6d ee			ld (debug_mark+2),a  
b011 18 03			jr .pastdmark  
b013 ..			.dmark: db "DO3"  
b016 f1			.pastdmark: pop af  
b017			endm  
# End of macro DMARK
b017						CALLMONITOR 
b017 cd 6f ee			call debug_vector  
b01a				endm  
# End of macro CALLMONITOR
b01a					endif 
b01a			 
b01a					;if DEBUG_FORTH_WORDS 
b01a				;		push hl 
b01a			;		endif  
b01a			 
b01a			; get counters from data stack 
b01a			 
b01a			 
b01a					FORTH_DSP_VALUEHL 
b01a cd 32 9d			call macro_dsp_valuehl 
b01d				endm 
# End of macro FORTH_DSP_VALUEHL
b01d e5					push hl		 ; hl now has starting counter which needs to be tos 
b01e			 
b01e					if DEBUG_FORTH_WORDS 
b01e						DMARK "DO4" 
b01e f5				push af  
b01f 3a 33 b0			ld a, (.dmark)  
b022 32 6b ee			ld (debug_mark),a  
b025 3a 34 b0			ld a, (.dmark+1)  
b028 32 6c ee			ld (debug_mark+1),a  
b02b 3a 35 b0			ld a, (.dmark+2)  
b02e 32 6d ee			ld (debug_mark+2),a  
b031 18 03			jr .pastdmark  
b033 ..			.dmark: db "DO4"  
b036 f1			.pastdmark: pop af  
b037			endm  
# End of macro DMARK
b037						CALLMONITOR 
b037 cd 6f ee			call debug_vector  
b03a				endm  
# End of macro CALLMONITOR
b03a					endif 
b03a					FORTH_DSP_POP 
b03a cd ea 9d			call macro_forth_dsp_pop 
b03d				endm 
# End of macro FORTH_DSP_POP
b03d			 
b03d					if DEBUG_FORTH_WORDS 
b03d						DMARK "DO5" 
b03d f5				push af  
b03e 3a 52 b0			ld a, (.dmark)  
b041 32 6b ee			ld (debug_mark),a  
b044 3a 53 b0			ld a, (.dmark+1)  
b047 32 6c ee			ld (debug_mark+1),a  
b04a 3a 54 b0			ld a, (.dmark+2)  
b04d 32 6d ee			ld (debug_mark+2),a  
b050 18 03			jr .pastdmark  
b052 ..			.dmark: db "DO5"  
b055 f1			.pastdmark: pop af  
b056			endm  
# End of macro DMARK
b056						CALLMONITOR 
b056 cd 6f ee			call debug_vector  
b059				endm  
# End of macro CALLMONITOR
b059					endif 
b059			 
b059					FORTH_DSP_VALUEHL 
b059 cd 32 9d			call macro_dsp_valuehl 
b05c				endm 
# End of macro FORTH_DSP_VALUEHL
b05c			;		push hl		 ; hl now has starting limit counter 
b05c			 
b05c					if DEBUG_FORTH_WORDS 
b05c						DMARK "DO6" 
b05c f5				push af  
b05d 3a 71 b0			ld a, (.dmark)  
b060 32 6b ee			ld (debug_mark),a  
b063 3a 72 b0			ld a, (.dmark+1)  
b066 32 6c ee			ld (debug_mark+1),a  
b069 3a 73 b0			ld a, (.dmark+2)  
b06c 32 6d ee			ld (debug_mark+2),a  
b06f 18 03			jr .pastdmark  
b071 ..			.dmark: db "DO6"  
b074 f1			.pastdmark: pop af  
b075			endm  
# End of macro DMARK
b075						CALLMONITOR 
b075 cd 6f ee			call debug_vector  
b078				endm  
# End of macro CALLMONITOR
b078					endif 
b078					FORTH_DSP_POP 
b078 cd ea 9d			call macro_forth_dsp_pop 
b07b				endm 
# End of macro FORTH_DSP_POP
b07b			 
b07b			; put counters on the loop stack 
b07b			 
b07b			;		pop hl			 ; limit counter 
b07b d1					pop de			; start counter 
b07c			 
b07c					; push limit counter 
b07c			 
b07c					if DEBUG_FORTH_WORDS 
b07c						DMARK "DO7" 
b07c f5				push af  
b07d 3a 91 b0			ld a, (.dmark)  
b080 32 6b ee			ld (debug_mark),a  
b083 3a 92 b0			ld a, (.dmark+1)  
b086 32 6c ee			ld (debug_mark+1),a  
b089 3a 93 b0			ld a, (.dmark+2)  
b08c 32 6d ee			ld (debug_mark+2),a  
b08f 18 03			jr .pastdmark  
b091 ..			.dmark: db "DO7"  
b094 f1			.pastdmark: pop af  
b095			endm  
# End of macro DMARK
b095						CALLMONITOR 
b095 cd 6f ee			call debug_vector  
b098				endm  
# End of macro CALLMONITOR
b098					endif 
b098					FORTH_LOOP_NEXT 
b098 cd 63 9d			call macro_forth_loop_next 
b09b				endm 
# End of macro FORTH_LOOP_NEXT
b09b			 
b09b					; push start counter 
b09b			 
b09b eb					ex de, hl 
b09c					if DEBUG_FORTH_WORDS 
b09c						DMARK "DO7" 
b09c f5				push af  
b09d 3a b1 b0			ld a, (.dmark)  
b0a0 32 6b ee			ld (debug_mark),a  
b0a3 3a b2 b0			ld a, (.dmark+1)  
b0a6 32 6c ee			ld (debug_mark+1),a  
b0a9 3a b3 b0			ld a, (.dmark+2)  
b0ac 32 6d ee			ld (debug_mark+2),a  
b0af 18 03			jr .pastdmark  
b0b1 ..			.dmark: db "DO7"  
b0b4 f1			.pastdmark: pop af  
b0b5			endm  
# End of macro DMARK
b0b5						CALLMONITOR 
b0b5 cd 6f ee			call debug_vector  
b0b8				endm  
# End of macro CALLMONITOR
b0b8					endif 
b0b8					FORTH_LOOP_NEXT 
b0b8 cd 63 9d			call macro_forth_loop_next 
b0bb				endm 
# End of macro FORTH_LOOP_NEXT
b0bb			 
b0bb			 
b0bb					; init first round of I counter 
b0bb			 
b0bb 22 e6 e5				ld (os_current_i), hl 
b0be			 
b0be					if DEBUG_FORTH_WORDS 
b0be						DMARK "DO8" 
b0be f5				push af  
b0bf 3a d3 b0			ld a, (.dmark)  
b0c2 32 6b ee			ld (debug_mark),a  
b0c5 3a d4 b0			ld a, (.dmark+1)  
b0c8 32 6c ee			ld (debug_mark+1),a  
b0cb 3a d5 b0			ld a, (.dmark+2)  
b0ce 32 6d ee			ld (debug_mark+2),a  
b0d1 18 03			jr .pastdmark  
b0d3 ..			.dmark: db "DO8"  
b0d6 f1			.pastdmark: pop af  
b0d7			endm  
# End of macro DMARK
b0d7						CALLMONITOR 
b0d7 cd 6f ee			call debug_vector  
b0da				endm  
# End of macro CALLMONITOR
b0da					endif 
b0da			 
b0da					NEXTW 
b0da c3 e8 9e			jp macro_next 
b0dd				endm 
# End of macro NEXTW
b0dd			.LOOP: 
b0dd				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b0dd 22				db WORD_SYS_CORE+14             
b0de f5 b1			dw .I            
b0e0 05				db 4 + 1 
b0e1 .. 00			db "LOOP",0              
b0e6				endm 
# End of macro CWHEAD
b0e6			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b0e6			 
b0e6				; pop tos as current loop count to hl 
b0e6			 
b0e6				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b0e6			 
b0e6				FORTH_LOOP_TOS 
b0e6 cd 96 9d			call macro_forth_loop_tos 
b0e9				endm 
# End of macro FORTH_LOOP_TOS
b0e9 e5				push hl 
b0ea			 
b0ea					if DEBUG_FORTH_WORDS_KEY 
b0ea						DMARK "LOP" 
b0ea f5				push af  
b0eb 3a ff b0			ld a, (.dmark)  
b0ee 32 6b ee			ld (debug_mark),a  
b0f1 3a 00 b1			ld a, (.dmark+1)  
b0f4 32 6c ee			ld (debug_mark+1),a  
b0f7 3a 01 b1			ld a, (.dmark+2)  
b0fa 32 6d ee			ld (debug_mark+2),a  
b0fd 18 03			jr .pastdmark  
b0ff ..			.dmark: db "LOP"  
b102 f1			.pastdmark: pop af  
b103			endm  
# End of macro DMARK
b103						CALLMONITOR 
b103 cd 6f ee			call debug_vector  
b106				endm  
# End of macro CALLMONITOR
b106					endif 
b106				; next item on the stack is the limit. get it 
b106			 
b106			 
b106				FORTH_LOOP_POP 
b106 cd a0 9d			call macro_forth_loop_pop 
b109				endm 
# End of macro FORTH_LOOP_POP
b109			 
b109				FORTH_LOOP_TOS 
b109 cd 96 9d			call macro_forth_loop_tos 
b10c				endm 
# End of macro FORTH_LOOP_TOS
b10c			 
b10c d1				pop de		 ; de = i, hl = limit 
b10d			 
b10d					if DEBUG_FORTH_WORDS 
b10d						DMARK "LP1" 
b10d f5				push af  
b10e 3a 22 b1			ld a, (.dmark)  
b111 32 6b ee			ld (debug_mark),a  
b114 3a 23 b1			ld a, (.dmark+1)  
b117 32 6c ee			ld (debug_mark+1),a  
b11a 3a 24 b1			ld a, (.dmark+2)  
b11d 32 6d ee			ld (debug_mark+2),a  
b120 18 03			jr .pastdmark  
b122 ..			.dmark: db "LP1"  
b125 f1			.pastdmark: pop af  
b126			endm  
# End of macro DMARK
b126						CALLMONITOR 
b126 cd 6f ee			call debug_vector  
b129				endm  
# End of macro CALLMONITOR
b129					endif 
b129			 
b129				; go back to previous word 
b129			 
b129 d5				push de    ; save I for inc later 
b12a			 
b12a			 
b12a				; get limit 
b12a				;  is I at limit? 
b12a			 
b12a			 
b12a					if DEBUG_FORTH_WORDS 
b12a						DMARK "LP1" 
b12a f5				push af  
b12b 3a 3f b1			ld a, (.dmark)  
b12e 32 6b ee			ld (debug_mark),a  
b131 3a 40 b1			ld a, (.dmark+1)  
b134 32 6c ee			ld (debug_mark+1),a  
b137 3a 41 b1			ld a, (.dmark+2)  
b13a 32 6d ee			ld (debug_mark+2),a  
b13d 18 03			jr .pastdmark  
b13f ..			.dmark: db "LP1"  
b142 f1			.pastdmark: pop af  
b143			endm  
# End of macro DMARK
b143						CALLMONITOR 
b143 cd 6f ee			call debug_vector  
b146				endm  
# End of macro CALLMONITOR
b146					endif 
b146			 
b146 ed 52			sbc hl, de 
b148			 
b148			 
b148				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b148			 
b148 20 26				jr nz, .loopnotdone 
b14a			 
b14a e1				pop hl   ; get rid of saved I 
b14b				FORTH_LOOP_POP     ; get rid of limit 
b14b cd a0 9d			call macro_forth_loop_pop 
b14e				endm 
# End of macro FORTH_LOOP_POP
b14e			 
b14e				FORTH_RSP_POP     ; get rid of DO ptr 
b14e cd 03 9b			call macro_forth_rsp_pop 
b151				endm 
# End of macro FORTH_RSP_POP
b151			 
b151			if DEBUG_FORTH_WORDS 
b151						DMARK "LP>" 
b151 f5				push af  
b152 3a 66 b1			ld a, (.dmark)  
b155 32 6b ee			ld (debug_mark),a  
b158 3a 67 b1			ld a, (.dmark+1)  
b15b 32 6c ee			ld (debug_mark+1),a  
b15e 3a 68 b1			ld a, (.dmark+2)  
b161 32 6d ee			ld (debug_mark+2),a  
b164 18 03			jr .pastdmark  
b166 ..			.dmark: db "LP>"  
b169 f1			.pastdmark: pop af  
b16a			endm  
# End of macro DMARK
b16a				CALLMONITOR 
b16a cd 6f ee			call debug_vector  
b16d				endm  
# End of macro CALLMONITOR
b16d			endif 
b16d			 
b16d					NEXTW 
b16d c3 e8 9e			jp macro_next 
b170				endm 
# End of macro NEXTW
b170				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b170			 
b170			.loopnotdone: 
b170			 
b170 e1				pop hl    ; get I 
b171 23				inc hl 
b172			 
b172			   	; save new I 
b172			 
b172			 
b172					; set I counter 
b172			 
b172 22 e6 e5				ld (os_current_i), hl 
b175			 
b175					if DEBUG_FORTH_WORDS 
b175						DMARK "LPN" 
b175 f5				push af  
b176 3a 8a b1			ld a, (.dmark)  
b179 32 6b ee			ld (debug_mark),a  
b17c 3a 8b b1			ld a, (.dmark+1)  
b17f 32 6c ee			ld (debug_mark+1),a  
b182 3a 8c b1			ld a, (.dmark+2)  
b185 32 6d ee			ld (debug_mark+2),a  
b188 18 03			jr .pastdmark  
b18a ..			.dmark: db "LPN"  
b18d f1			.pastdmark: pop af  
b18e			endm  
# End of macro DMARK
b18e					CALLMONITOR 
b18e cd 6f ee			call debug_vector  
b191				endm  
# End of macro CALLMONITOR
b191					endif 
b191					 
b191				FORTH_LOOP_NEXT 
b191 cd 63 9d			call macro_forth_loop_next 
b194				endm 
# End of macro FORTH_LOOP_NEXT
b194			 
b194			 
b194					if DEBUG_FORTH_WORDS 
b194 eb						ex de,hl 
b195					endif 
b195			 
b195			;	; get DO ptr 
b195			; 
b195					if DEBUG_FORTH_WORDS 
b195						DMARK "LP7" 
b195 f5				push af  
b196 3a aa b1			ld a, (.dmark)  
b199 32 6b ee			ld (debug_mark),a  
b19c 3a ab b1			ld a, (.dmark+1)  
b19f 32 6c ee			ld (debug_mark+1),a  
b1a2 3a ac b1			ld a, (.dmark+2)  
b1a5 32 6d ee			ld (debug_mark+2),a  
b1a8 18 03			jr .pastdmark  
b1aa ..			.dmark: db "LP7"  
b1ad f1			.pastdmark: pop af  
b1ae			endm  
# End of macro DMARK
b1ae					CALLMONITOR 
b1ae cd 6f ee			call debug_vector  
b1b1				endm  
# End of macro CALLMONITOR
b1b1					endif 
b1b1				FORTH_RSP_TOS 
b1b1 cd f9 9a			call macro_forth_rsp_tos 
b1b4				endm 
# End of macro FORTH_RSP_TOS
b1b4			 
b1b4					if DEBUG_FORTH_WORDS 
b1b4						DMARK "LP8" 
b1b4 f5				push af  
b1b5 3a c9 b1			ld a, (.dmark)  
b1b8 32 6b ee			ld (debug_mark),a  
b1bb 3a ca b1			ld a, (.dmark+1)  
b1be 32 6c ee			ld (debug_mark+1),a  
b1c1 3a cb b1			ld a, (.dmark+2)  
b1c4 32 6d ee			ld (debug_mark+2),a  
b1c7 18 03			jr .pastdmark  
b1c9 ..			.dmark: db "LP8"  
b1cc f1			.pastdmark: pop af  
b1cd			endm  
# End of macro DMARK
b1cd					CALLMONITOR 
b1cd cd 6f ee			call debug_vector  
b1d0				endm  
# End of macro CALLMONITOR
b1d0					endif 
b1d0				;push hl 
b1d0			 
b1d0				; not going to DO any more 
b1d0				; get rid of the RSP pointer as DO will add it back in 
b1d0				;FORTH_RSP_POP 
b1d0				;pop hl 
b1d0			 
b1d0				;ld hl,(cli_ret_sp) 
b1d0				;ld e, (hl) 
b1d0				;inc hl 
b1d0				;ld d, (hl) 
b1d0				;ex de,hl 
b1d0 22 c2 e5			ld (os_tok_ptr), hl 
b1d3					if DEBUG_FORTH_WORDS 
b1d3						DMARK "LP<" 
b1d3 f5				push af  
b1d4 3a e8 b1			ld a, (.dmark)  
b1d7 32 6b ee			ld (debug_mark),a  
b1da 3a e9 b1			ld a, (.dmark+1)  
b1dd 32 6c ee			ld (debug_mark+1),a  
b1e0 3a ea b1			ld a, (.dmark+2)  
b1e3 32 6d ee			ld (debug_mark+2),a  
b1e6 18 03			jr .pastdmark  
b1e8 ..			.dmark: db "LP<"  
b1eb f1			.pastdmark: pop af  
b1ec			endm  
# End of macro DMARK
b1ec					CALLMONITOR 
b1ec cd 6f ee			call debug_vector  
b1ef				endm  
# End of macro CALLMONITOR
b1ef				endif 
b1ef c3 79 9f			jp exec1 
b1f2			 
b1f2					 
b1f2			 
b1f2			 
b1f2					NEXTW 
b1f2 c3 e8 9e			jp macro_next 
b1f5				endm 
# End of macro NEXTW
b1f5			.I:  
b1f5			 
b1f5				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b1f5 5e				db WORD_SYS_CORE+74             
b1f6 20 b2			dw .DLOOP            
b1f8 02				db 1 + 1 
b1f9 .. 00			db "I",0              
b1fb				endm 
# End of macro CWHEAD
b1fb			; | I ( -- ) Current loop counter | DONE 
b1fb					if DEBUG_FORTH_WORDS_KEY 
b1fb						DMARK "I.." 
b1fb f5				push af  
b1fc 3a 10 b2			ld a, (.dmark)  
b1ff 32 6b ee			ld (debug_mark),a  
b202 3a 11 b2			ld a, (.dmark+1)  
b205 32 6c ee			ld (debug_mark+1),a  
b208 3a 12 b2			ld a, (.dmark+2)  
b20b 32 6d ee			ld (debug_mark+2),a  
b20e 18 03			jr .pastdmark  
b210 ..			.dmark: db "I.."  
b213 f1			.pastdmark: pop af  
b214			endm  
# End of macro DMARK
b214						CALLMONITOR 
b214 cd 6f ee			call debug_vector  
b217				endm  
# End of macro CALLMONITOR
b217					endif 
b217			 
b217 2a e6 e5				ld hl,(os_current_i) 
b21a cd 3b 9b				call forth_push_numhl 
b21d			 
b21d					NEXTW 
b21d c3 e8 9e			jp macro_next 
b220				endm 
# End of macro NEXTW
b220			.DLOOP: 
b220				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b220 5f				db WORD_SYS_CORE+75             
b221 01 b3			dw .REPEAT            
b223 06				db 5 + 1 
b224 .. 00			db "-LOOP",0              
b22a				endm 
# End of macro CWHEAD
b22a			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b22a				; pop tos as current loop count to hl 
b22a					if DEBUG_FORTH_WORDS_KEY 
b22a						DMARK "-LP" 
b22a f5				push af  
b22b 3a 3f b2			ld a, (.dmark)  
b22e 32 6b ee			ld (debug_mark),a  
b231 3a 40 b2			ld a, (.dmark+1)  
b234 32 6c ee			ld (debug_mark+1),a  
b237 3a 41 b2			ld a, (.dmark+2)  
b23a 32 6d ee			ld (debug_mark+2),a  
b23d 18 03			jr .pastdmark  
b23f ..			.dmark: db "-LP"  
b242 f1			.pastdmark: pop af  
b243			endm  
# End of macro DMARK
b243						CALLMONITOR 
b243 cd 6f ee			call debug_vector  
b246				endm  
# End of macro CALLMONITOR
b246					endif 
b246			 
b246				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b246			 
b246				FORTH_LOOP_TOS 
b246 cd 96 9d			call macro_forth_loop_tos 
b249				endm 
# End of macro FORTH_LOOP_TOS
b249 e5				push hl 
b24a			 
b24a					if DEBUG_FORTH_WORDS 
b24a						DMARK "-LP" 
b24a f5				push af  
b24b 3a 5f b2			ld a, (.dmark)  
b24e 32 6b ee			ld (debug_mark),a  
b251 3a 60 b2			ld a, (.dmark+1)  
b254 32 6c ee			ld (debug_mark+1),a  
b257 3a 61 b2			ld a, (.dmark+2)  
b25a 32 6d ee			ld (debug_mark+2),a  
b25d 18 03			jr .pastdmark  
b25f ..			.dmark: db "-LP"  
b262 f1			.pastdmark: pop af  
b263			endm  
# End of macro DMARK
b263						CALLMONITOR 
b263 cd 6f ee			call debug_vector  
b266				endm  
# End of macro CALLMONITOR
b266					endif 
b266				; next item on the stack is the limit. get it 
b266			 
b266			 
b266				FORTH_LOOP_POP 
b266 cd a0 9d			call macro_forth_loop_pop 
b269				endm 
# End of macro FORTH_LOOP_POP
b269			 
b269				FORTH_LOOP_TOS 
b269 cd 96 9d			call macro_forth_loop_tos 
b26c				endm 
# End of macro FORTH_LOOP_TOS
b26c			 
b26c d1				pop de		 ; de = i, hl = limit 
b26d			 
b26d					if DEBUG_FORTH_WORDS 
b26d						DMARK "-L1" 
b26d f5				push af  
b26e 3a 82 b2			ld a, (.dmark)  
b271 32 6b ee			ld (debug_mark),a  
b274 3a 83 b2			ld a, (.dmark+1)  
b277 32 6c ee			ld (debug_mark+1),a  
b27a 3a 84 b2			ld a, (.dmark+2)  
b27d 32 6d ee			ld (debug_mark+2),a  
b280 18 03			jr .pastdmark  
b282 ..			.dmark: db "-L1"  
b285 f1			.pastdmark: pop af  
b286			endm  
# End of macro DMARK
b286						CALLMONITOR 
b286 cd 6f ee			call debug_vector  
b289				endm  
# End of macro CALLMONITOR
b289					endif 
b289			 
b289				; go back to previous word 
b289			 
b289 d5				push de    ; save I for inc later 
b28a			 
b28a			 
b28a				; get limit 
b28a				;  is I at limit? 
b28a			 
b28a			 
b28a					if DEBUG_FORTH_WORDS 
b28a						DMARK "-L1" 
b28a f5				push af  
b28b 3a 9f b2			ld a, (.dmark)  
b28e 32 6b ee			ld (debug_mark),a  
b291 3a a0 b2			ld a, (.dmark+1)  
b294 32 6c ee			ld (debug_mark+1),a  
b297 3a a1 b2			ld a, (.dmark+2)  
b29a 32 6d ee			ld (debug_mark+2),a  
b29d 18 03			jr .pastdmark  
b29f ..			.dmark: db "-L1"  
b2a2 f1			.pastdmark: pop af  
b2a3			endm  
# End of macro DMARK
b2a3						CALLMONITOR 
b2a3 cd 6f ee			call debug_vector  
b2a6				endm  
# End of macro CALLMONITOR
b2a6					endif 
b2a6			 
b2a6 ed 52			sbc hl, de 
b2a8			 
b2a8			 
b2a8				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b2a8			 
b2a8 20 26				jr nz, .mloopnotdone 
b2aa			 
b2aa e1				pop hl   ; get rid of saved I 
b2ab				FORTH_LOOP_POP     ; get rid of limit 
b2ab cd a0 9d			call macro_forth_loop_pop 
b2ae				endm 
# End of macro FORTH_LOOP_POP
b2ae			 
b2ae				FORTH_RSP_POP     ; get rid of DO ptr 
b2ae cd 03 9b			call macro_forth_rsp_pop 
b2b1				endm 
# End of macro FORTH_RSP_POP
b2b1			 
b2b1			if DEBUG_FORTH_WORDS 
b2b1						DMARK "-L>" 
b2b1 f5				push af  
b2b2 3a c6 b2			ld a, (.dmark)  
b2b5 32 6b ee			ld (debug_mark),a  
b2b8 3a c7 b2			ld a, (.dmark+1)  
b2bb 32 6c ee			ld (debug_mark+1),a  
b2be 3a c8 b2			ld a, (.dmark+2)  
b2c1 32 6d ee			ld (debug_mark+2),a  
b2c4 18 03			jr .pastdmark  
b2c6 ..			.dmark: db "-L>"  
b2c9 f1			.pastdmark: pop af  
b2ca			endm  
# End of macro DMARK
b2ca				CALLMONITOR 
b2ca cd 6f ee			call debug_vector  
b2cd				endm  
# End of macro CALLMONITOR
b2cd			endif 
b2cd			 
b2cd					NEXTW 
b2cd c3 e8 9e			jp macro_next 
b2d0				endm 
# End of macro NEXTW
b2d0				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2d0			 
b2d0			.mloopnotdone: 
b2d0			 
b2d0 e1				pop hl    ; get I 
b2d1 2b				dec hl 
b2d2			 
b2d2			   	; save new I 
b2d2			 
b2d2			 
b2d2					; set I counter 
b2d2			 
b2d2 22 e6 e5				ld (os_current_i), hl 
b2d5			 
b2d5					 
b2d5				FORTH_LOOP_NEXT 
b2d5 cd 63 9d			call macro_forth_loop_next 
b2d8				endm 
# End of macro FORTH_LOOP_NEXT
b2d8			 
b2d8			 
b2d8					if DEBUG_FORTH_WORDS 
b2d8 eb						ex de,hl 
b2d9					endif 
b2d9			 
b2d9			;	; get DO ptr 
b2d9			; 
b2d9				FORTH_RSP_TOS 
b2d9 cd f9 9a			call macro_forth_rsp_tos 
b2dc				endm 
# End of macro FORTH_RSP_TOS
b2dc			 
b2dc				;push hl 
b2dc			 
b2dc				; not going to DO any more 
b2dc				; get rid of the RSP pointer as DO will add it back in 
b2dc				;FORTH_RSP_POP 
b2dc				;pop hl 
b2dc			 
b2dc			 
b2dc 22 c2 e5			ld (os_tok_ptr), hl 
b2df					if DEBUG_FORTH_WORDS 
b2df						DMARK "-L<" 
b2df f5				push af  
b2e0 3a f4 b2			ld a, (.dmark)  
b2e3 32 6b ee			ld (debug_mark),a  
b2e6 3a f5 b2			ld a, (.dmark+1)  
b2e9 32 6c ee			ld (debug_mark+1),a  
b2ec 3a f6 b2			ld a, (.dmark+2)  
b2ef 32 6d ee			ld (debug_mark+2),a  
b2f2 18 03			jr .pastdmark  
b2f4 ..			.dmark: db "-L<"  
b2f7 f1			.pastdmark: pop af  
b2f8			endm  
# End of macro DMARK
b2f8					CALLMONITOR 
b2f8 cd 6f ee			call debug_vector  
b2fb				endm  
# End of macro CALLMONITOR
b2fb				endif 
b2fb c3 79 9f			jp exec1 
b2fe			 
b2fe					 
b2fe			 
b2fe			 
b2fe			 
b2fe				NEXTW 
b2fe c3 e8 9e			jp macro_next 
b301				endm 
# End of macro NEXTW
b301			 
b301			 
b301			 
b301			 
b301			.REPEAT: 
b301				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b301 71				db WORD_SYS_CORE+93             
b302 54 b3			dw .UNTIL            
b304 06				db 5 + 1 
b305 .. 00			db "REPEAT",0              
b30c				endm 
# End of macro CWHEAD
b30c			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b30c			;  push pc to rsp stack past the REPEAT 
b30c					if DEBUG_FORTH_WORDS_KEY 
b30c						DMARK "REP" 
b30c f5				push af  
b30d 3a 21 b3			ld a, (.dmark)  
b310 32 6b ee			ld (debug_mark),a  
b313 3a 22 b3			ld a, (.dmark+1)  
b316 32 6c ee			ld (debug_mark+1),a  
b319 3a 23 b3			ld a, (.dmark+2)  
b31c 32 6d ee			ld (debug_mark+2),a  
b31f 18 03			jr .pastdmark  
b321 ..			.dmark: db "REP"  
b324 f1			.pastdmark: pop af  
b325			endm  
# End of macro DMARK
b325						CALLMONITOR 
b325 cd 6f ee			call debug_vector  
b328				endm  
# End of macro CALLMONITOR
b328					endif 
b328			 
b328 2a c2 e5				ld hl, (os_tok_ptr) 
b32b 23					inc hl   ; R 
b32c 23					inc hl  ; E 
b32d 23					inc hl   ; P 
b32e 23					inc hl   ; E 
b32f 23					inc hl   ; A 
b330 23					inc hl   ; T 
b331 23					inc hl   ; zero 
b332					FORTH_RSP_NEXT 
b332 cd e2 9a			call macro_forth_rsp_next 
b335				endm 
# End of macro FORTH_RSP_NEXT
b335			 
b335			 
b335					if DEBUG_FORTH_WORDS 
b335						DMARK "REP" 
b335 f5				push af  
b336 3a 4a b3			ld a, (.dmark)  
b339 32 6b ee			ld (debug_mark),a  
b33c 3a 4b b3			ld a, (.dmark+1)  
b33f 32 6c ee			ld (debug_mark+1),a  
b342 3a 4c b3			ld a, (.dmark+2)  
b345 32 6d ee			ld (debug_mark+2),a  
b348 18 03			jr .pastdmark  
b34a ..			.dmark: db "REP"  
b34d f1			.pastdmark: pop af  
b34e			endm  
# End of macro DMARK
b34e						;pop bc    ; TODO BUG ?????? what is this for???? 
b34e						CALLMONITOR 
b34e cd 6f ee			call debug_vector  
b351				endm  
# End of macro CALLMONITOR
b351					endif 
b351			 
b351					NEXTW 
b351 c3 e8 9e			jp macro_next 
b354				endm 
# End of macro NEXTW
b354			;	       NEXTW 
b354			 
b354			.UNTIL: 
b354				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b354 72				db WORD_SYS_CORE+94             
b355 eb b3			dw .ENDFLOW            
b357 06				db 5 + 1 
b358 .. 00			db "UNTIL",0              
b35e				endm 
# End of macro CWHEAD
b35e			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b35e			 
b35e				; pop tos as check 
b35e			 
b35e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b35e			 
b35e				FORTH_DSP_VALUEHL 
b35e cd 32 9d			call macro_dsp_valuehl 
b361				endm 
# End of macro FORTH_DSP_VALUEHL
b361			 
b361					if DEBUG_FORTH_WORDS_KEY 
b361						DMARK "UNT" 
b361 f5				push af  
b362 3a 76 b3			ld a, (.dmark)  
b365 32 6b ee			ld (debug_mark),a  
b368 3a 77 b3			ld a, (.dmark+1)  
b36b 32 6c ee			ld (debug_mark+1),a  
b36e 3a 78 b3			ld a, (.dmark+2)  
b371 32 6d ee			ld (debug_mark+2),a  
b374 18 03			jr .pastdmark  
b376 ..			.dmark: db "UNT"  
b379 f1			.pastdmark: pop af  
b37a			endm  
# End of macro DMARK
b37a						CALLMONITOR 
b37a cd 6f ee			call debug_vector  
b37d				endm  
# End of macro CALLMONITOR
b37d					endif 
b37d			 
b37d			;	push hl 
b37d				FORTH_DSP_POP 
b37d cd ea 9d			call macro_forth_dsp_pop 
b380				endm 
# End of macro FORTH_DSP_POP
b380			 
b380			;	pop hl 
b380			 
b380				; test if true 
b380			 
b380 cd 04 8d			call ishlzero 
b383			;	ld a,l 
b383			;	add h 
b383			; 
b383			;	cp 0 
b383			 
b383 20 3e			jr nz, .untilnotdone 
b385			 
b385					if DEBUG_FORTH_WORDS 
b385						DMARK "UNf" 
b385 f5				push af  
b386 3a 9a b3			ld a, (.dmark)  
b389 32 6b ee			ld (debug_mark),a  
b38c 3a 9b b3			ld a, (.dmark+1)  
b38f 32 6c ee			ld (debug_mark+1),a  
b392 3a 9c b3			ld a, (.dmark+2)  
b395 32 6d ee			ld (debug_mark+2),a  
b398 18 03			jr .pastdmark  
b39a ..			.dmark: db "UNf"  
b39d f1			.pastdmark: pop af  
b39e			endm  
# End of macro DMARK
b39e						CALLMONITOR 
b39e cd 6f ee			call debug_vector  
b3a1				endm  
# End of macro CALLMONITOR
b3a1					endif 
b3a1			 
b3a1			 
b3a1			 
b3a1				FORTH_RSP_POP     ; get rid of DO ptr 
b3a1 cd 03 9b			call macro_forth_rsp_pop 
b3a4				endm 
# End of macro FORTH_RSP_POP
b3a4			 
b3a4			if DEBUG_FORTH_WORDS 
b3a4						DMARK "UN>" 
b3a4 f5				push af  
b3a5 3a b9 b3			ld a, (.dmark)  
b3a8 32 6b ee			ld (debug_mark),a  
b3ab 3a ba b3			ld a, (.dmark+1)  
b3ae 32 6c ee			ld (debug_mark+1),a  
b3b1 3a bb b3			ld a, (.dmark+2)  
b3b4 32 6d ee			ld (debug_mark+2),a  
b3b7 18 03			jr .pastdmark  
b3b9 ..			.dmark: db "UN>"  
b3bc f1			.pastdmark: pop af  
b3bd			endm  
# End of macro DMARK
b3bd				CALLMONITOR 
b3bd cd 6f ee			call debug_vector  
b3c0				endm  
# End of macro CALLMONITOR
b3c0			endif 
b3c0			 
b3c0					NEXTW 
b3c0 c3 e8 9e			jp macro_next 
b3c3				endm 
# End of macro NEXTW
b3c3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b3c3			 
b3c3			.untilnotdone: 
b3c3			 
b3c3			 
b3c3			;	; get DO ptr 
b3c3			; 
b3c3				FORTH_RSP_TOS 
b3c3 cd f9 9a			call macro_forth_rsp_tos 
b3c6				endm 
# End of macro FORTH_RSP_TOS
b3c6			 
b3c6				;push hl 
b3c6			 
b3c6				; not going to DO any more 
b3c6				; get rid of the RSP pointer as DO will add it back in 
b3c6				;FORTH_RSP_POP 
b3c6				;pop hl 
b3c6			 
b3c6			 
b3c6 22 c2 e5			ld (os_tok_ptr), hl 
b3c9					if DEBUG_FORTH_WORDS 
b3c9						DMARK "UN<" 
b3c9 f5				push af  
b3ca 3a de b3			ld a, (.dmark)  
b3cd 32 6b ee			ld (debug_mark),a  
b3d0 3a df b3			ld a, (.dmark+1)  
b3d3 32 6c ee			ld (debug_mark+1),a  
b3d6 3a e0 b3			ld a, (.dmark+2)  
b3d9 32 6d ee			ld (debug_mark+2),a  
b3dc 18 03			jr .pastdmark  
b3de ..			.dmark: db "UN<"  
b3e1 f1			.pastdmark: pop af  
b3e2			endm  
# End of macro DMARK
b3e2					CALLMONITOR 
b3e2 cd 6f ee			call debug_vector  
b3e5				endm  
# End of macro CALLMONITOR
b3e5				endif 
b3e5 c3 79 9f			jp exec1 
b3e8			 
b3e8					 
b3e8			 
b3e8			 
b3e8					NEXTW 
b3e8 c3 e8 9e			jp macro_next 
b3eb				endm 
# End of macro NEXTW
b3eb			 
b3eb			 
b3eb			.ENDFLOW: 
b3eb			 
b3eb			; eof 
b3eb			 
# End of file forth_words_flow.asm
b3eb			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b3eb			include "forth_words_logic.asm" 
b3eb			 
b3eb			; | ## Logic Words 
b3eb			 
b3eb			.NOT: 
b3eb				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b3eb 2d				db WORD_SYS_CORE+25             
b3ec 33 b4			dw .IS            
b3ee 04				db 3 + 1 
b3ef .. 00			db "NOT",0              
b3f3				endm 
# End of macro CWHEAD
b3f3			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b3f3					if DEBUG_FORTH_WORDS_KEY 
b3f3						DMARK "NOT" 
b3f3 f5				push af  
b3f4 3a 08 b4			ld a, (.dmark)  
b3f7 32 6b ee			ld (debug_mark),a  
b3fa 3a 09 b4			ld a, (.dmark+1)  
b3fd 32 6c ee			ld (debug_mark+1),a  
b400 3a 0a b4			ld a, (.dmark+2)  
b403 32 6d ee			ld (debug_mark+2),a  
b406 18 03			jr .pastdmark  
b408 ..			.dmark: db "NOT"  
b40b f1			.pastdmark: pop af  
b40c			endm  
# End of macro DMARK
b40c						CALLMONITOR 
b40c cd 6f ee			call debug_vector  
b40f				endm  
# End of macro CALLMONITOR
b40f					endif 
b40f					FORTH_DSP 
b40f cd f8 9c			call macro_forth_dsp 
b412				endm 
# End of macro FORTH_DSP
b412 7e					ld a,(hl)	; get type of value on TOS 
b413 fe 02				cp DS_TYPE_INUM  
b415 28 03				jr z, .noti 
b417					NEXTW 
b417 c3 e8 9e			jp macro_next 
b41a				endm 
# End of macro NEXTW
b41a			.noti:          FORTH_DSP_VALUEHL 
b41a cd 32 9d			call macro_dsp_valuehl 
b41d				endm 
# End of macro FORTH_DSP_VALUEHL
b41d			;		push hl 
b41d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b41d cd ea 9d			call macro_forth_dsp_pop 
b420				endm 
# End of macro FORTH_DSP_POP
b420			;		pop hl 
b420 3e 00				ld a,0 
b422 bd					cp l 
b423 28 04				jr z, .not2t 
b425 2e 00				ld l, 0 
b427 18 02				jr .notip 
b429			 
b429 2e ff		.not2t:		ld l, 255 
b42b			 
b42b 26 00		.notip:		ld h, 0	 
b42d			 
b42d cd 3b 9b				call forth_push_numhl 
b430					NEXTW 
b430 c3 e8 9e			jp macro_next 
b433				endm 
# End of macro NEXTW
b433			 
b433			.IS: 
b433				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b433 2d				db WORD_SYS_CORE+25             
b434 59 b4			dw .LZERO            
b436 03				db 2 + 1 
b437 .. 00			db "IS",0              
b43a				endm 
# End of macro CWHEAD
b43a			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b43a					if DEBUG_FORTH_WORDS_KEY 
b43a						DMARK "IS." 
b43a f5				push af  
b43b 3a 4f b4			ld a, (.dmark)  
b43e 32 6b ee			ld (debug_mark),a  
b441 3a 50 b4			ld a, (.dmark+1)  
b444 32 6c ee			ld (debug_mark+1),a  
b447 3a 51 b4			ld a, (.dmark+2)  
b44a 32 6d ee			ld (debug_mark+2),a  
b44d 18 03			jr .pastdmark  
b44f ..			.dmark: db "IS."  
b452 f1			.pastdmark: pop af  
b453			endm  
# End of macro DMARK
b453						CALLMONITOR 
b453 cd 6f ee			call debug_vector  
b456				endm  
# End of macro CALLMONITOR
b456					endif 
b456					NEXTW 
b456 c3 e8 9e			jp macro_next 
b459				endm 
# End of macro NEXTW
b459			.LZERO: 
b459				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b459 2d				db WORD_SYS_CORE+25             
b45a 63 b4			dw .TZERO            
b45c 03				db 2 + 1 
b45d .. 00			db "0<",0              
b460				endm 
# End of macro CWHEAD
b460			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b460					NEXTW 
b460 c3 e8 9e			jp macro_next 
b463				endm 
# End of macro NEXTW
b463			.TZERO: 
b463				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b463 2e				db WORD_SYS_CORE+26             
b464 aa b4			dw .LESS            
b466 03				db 2 + 1 
b467 .. 00			db "0=",0              
b46a				endm 
# End of macro CWHEAD
b46a			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b46a				; TODO add floating point number detection 
b46a					;v5 FORTH_DSP_VALUE 
b46a					if DEBUG_FORTH_WORDS_KEY 
b46a						DMARK "0=." 
b46a f5				push af  
b46b 3a 7f b4			ld a, (.dmark)  
b46e 32 6b ee			ld (debug_mark),a  
b471 3a 80 b4			ld a, (.dmark+1)  
b474 32 6c ee			ld (debug_mark+1),a  
b477 3a 81 b4			ld a, (.dmark+2)  
b47a 32 6d ee			ld (debug_mark+2),a  
b47d 18 03			jr .pastdmark  
b47f ..			.dmark: db "0=."  
b482 f1			.pastdmark: pop af  
b483			endm  
# End of macro DMARK
b483						CALLMONITOR 
b483 cd 6f ee			call debug_vector  
b486				endm  
# End of macro CALLMONITOR
b486					endif 
b486					FORTH_DSP 
b486 cd f8 9c			call macro_forth_dsp 
b489				endm 
# End of macro FORTH_DSP
b489 7e					ld a,(hl)	; get type of value on TOS 
b48a fe 02				cp DS_TYPE_INUM  
b48c 28 00				jr z, .tz_inum 
b48e			 
b48e				if FORTH_ENABLE_FLOATMATH 
b48e					jr .tz_done 
b48e			 
b48e				endif 
b48e					 
b48e			 
b48e			.tz_inum: 
b48e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b48e cd 32 9d			call macro_dsp_valuehl 
b491				endm 
# End of macro FORTH_DSP_VALUEHL
b491			 
b491			;		push hl 
b491			 
b491					; destroy value TOS 
b491			 
b491					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b491 cd ea 9d			call macro_forth_dsp_pop 
b494				endm 
# End of macro FORTH_DSP_POP
b494			 
b494			;		pop hl 
b494			 
b494 3e 00				ld a,0 
b496			 
b496 bd					cp l 
b497 20 08				jr nz, .tz_notzero 
b499			 
b499 bc					cp h 
b49a			 
b49a 20 05				jr nz, .tz_notzero 
b49c			 
b49c			 
b49c 21 01 00				ld hl, FORTH_TRUE 
b49f 18 03				jr .tz_done 
b4a1			 
b4a1 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b4a4			 
b4a4					; push value back onto stack for another op etc 
b4a4			 
b4a4			.tz_done: 
b4a4 cd 3b 9b				call forth_push_numhl 
b4a7			 
b4a7					NEXTW 
b4a7 c3 e8 9e			jp macro_next 
b4aa				endm 
# End of macro NEXTW
b4aa			.LESS: 
b4aa				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b4aa 2f				db WORD_SYS_CORE+27             
b4ab 13 b5			dw .GT            
b4ad 02				db 1 + 1 
b4ae .. 00			db "<",0              
b4b0				endm 
# End of macro CWHEAD
b4b0			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b4b0				; TODO add floating point number detection 
b4b0					if DEBUG_FORTH_WORDS_KEY 
b4b0						DMARK "LES" 
b4b0 f5				push af  
b4b1 3a c5 b4			ld a, (.dmark)  
b4b4 32 6b ee			ld (debug_mark),a  
b4b7 3a c6 b4			ld a, (.dmark+1)  
b4ba 32 6c ee			ld (debug_mark+1),a  
b4bd 3a c7 b4			ld a, (.dmark+2)  
b4c0 32 6d ee			ld (debug_mark+2),a  
b4c3 18 03			jr .pastdmark  
b4c5 ..			.dmark: db "LES"  
b4c8 f1			.pastdmark: pop af  
b4c9			endm  
# End of macro DMARK
b4c9						CALLMONITOR 
b4c9 cd 6f ee			call debug_vector  
b4cc				endm  
# End of macro CALLMONITOR
b4cc					endif 
b4cc					FORTH_DSP 
b4cc cd f8 9c			call macro_forth_dsp 
b4cf				endm 
# End of macro FORTH_DSP
b4cf					;v5 FORTH_DSP_VALUE 
b4cf 7e					ld a,(hl)	; get type of value on TOS 
b4d0 fe 02				cp DS_TYPE_INUM  
b4d2 28 00				jr z, .less_inum 
b4d4			 
b4d4				if FORTH_ENABLE_FLOATMATH 
b4d4					jr .less_done 
b4d4			 
b4d4				endif 
b4d4					 
b4d4			 
b4d4			.less_inum: 
b4d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d4 cd 32 9d			call macro_dsp_valuehl 
b4d7				endm 
# End of macro FORTH_DSP_VALUEHL
b4d7			 
b4d7 e5					push hl  ; u2 
b4d8			 
b4d8					; destroy value TOS 
b4d8			 
b4d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4d8 cd ea 9d			call macro_forth_dsp_pop 
b4db				endm 
# End of macro FORTH_DSP_POP
b4db			 
b4db			 
b4db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4db cd 32 9d			call macro_dsp_valuehl 
b4de				endm 
# End of macro FORTH_DSP_VALUEHL
b4de			 
b4de e5					push hl    ; u1 
b4df			 
b4df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4df cd ea 9d			call macro_forth_dsp_pop 
b4e2				endm 
# End of macro FORTH_DSP_POP
b4e2			 
b4e2			 
b4e2 b7			 or a      ;clear carry flag 
b4e3 01 00 00		 ld bc, FORTH_FALSE 
b4e6 e1			  pop hl    ; u1 
b4e7 d1			  pop de    ; u2 
b4e8 ed 52		  sbc hl,de 
b4ea 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b4ec			 
b4ec 01 01 00		 ld bc, FORTH_TRUE 
b4ef			.lscont:  
b4ef c5					push bc 
b4f0 e1					pop hl 
b4f1			 
b4f1					if DEBUG_FORTH_WORDS 
b4f1						DMARK "LT1" 
b4f1 f5				push af  
b4f2 3a 06 b5			ld a, (.dmark)  
b4f5 32 6b ee			ld (debug_mark),a  
b4f8 3a 07 b5			ld a, (.dmark+1)  
b4fb 32 6c ee			ld (debug_mark+1),a  
b4fe 3a 08 b5			ld a, (.dmark+2)  
b501 32 6d ee			ld (debug_mark+2),a  
b504 18 03			jr .pastdmark  
b506 ..			.dmark: db "LT1"  
b509 f1			.pastdmark: pop af  
b50a			endm  
# End of macro DMARK
b50a						CALLMONITOR 
b50a cd 6f ee			call debug_vector  
b50d				endm  
# End of macro CALLMONITOR
b50d					endif 
b50d cd 3b 9b				call forth_push_numhl 
b510			 
b510					NEXTW 
b510 c3 e8 9e			jp macro_next 
b513				endm 
# End of macro NEXTW
b513			.GT: 
b513				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b513 30				db WORD_SYS_CORE+28             
b514 7c b5			dw .EQUAL            
b516 02				db 1 + 1 
b517 .. 00			db ">",0              
b519				endm 
# End of macro CWHEAD
b519			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b519				; TODO add floating point number detection 
b519					if DEBUG_FORTH_WORDS_KEY 
b519						DMARK "GRT" 
b519 f5				push af  
b51a 3a 2e b5			ld a, (.dmark)  
b51d 32 6b ee			ld (debug_mark),a  
b520 3a 2f b5			ld a, (.dmark+1)  
b523 32 6c ee			ld (debug_mark+1),a  
b526 3a 30 b5			ld a, (.dmark+2)  
b529 32 6d ee			ld (debug_mark+2),a  
b52c 18 03			jr .pastdmark  
b52e ..			.dmark: db "GRT"  
b531 f1			.pastdmark: pop af  
b532			endm  
# End of macro DMARK
b532						CALLMONITOR 
b532 cd 6f ee			call debug_vector  
b535				endm  
# End of macro CALLMONITOR
b535					endif 
b535					FORTH_DSP 
b535 cd f8 9c			call macro_forth_dsp 
b538				endm 
# End of macro FORTH_DSP
b538					;FORTH_DSP_VALUE 
b538 7e					ld a,(hl)	; get type of value on TOS 
b539 fe 02				cp DS_TYPE_INUM  
b53b 28 00				jr z, .gt_inum 
b53d			 
b53d				if FORTH_ENABLE_FLOATMATH 
b53d					jr .gt_done 
b53d			 
b53d				endif 
b53d					 
b53d			 
b53d			.gt_inum: 
b53d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b53d cd 32 9d			call macro_dsp_valuehl 
b540				endm 
# End of macro FORTH_DSP_VALUEHL
b540			 
b540 e5					push hl  ; u2 
b541			 
b541					; destroy value TOS 
b541			 
b541					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b541 cd ea 9d			call macro_forth_dsp_pop 
b544				endm 
# End of macro FORTH_DSP_POP
b544			 
b544			 
b544					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b544 cd 32 9d			call macro_dsp_valuehl 
b547				endm 
# End of macro FORTH_DSP_VALUEHL
b547			 
b547 e5					push hl    ; u1 
b548			 
b548					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b548 cd ea 9d			call macro_forth_dsp_pop 
b54b				endm 
# End of macro FORTH_DSP_POP
b54b			 
b54b			 
b54b b7			 or a      ;clear carry flag 
b54c 01 00 00		 ld bc, FORTH_FALSE 
b54f e1			  pop hl    ; u1 
b550 d1			  pop de    ; u2 
b551 ed 52		  sbc hl,de 
b553 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b555			 
b555 01 01 00		 ld bc, FORTH_TRUE 
b558			.gtcont:  
b558 c5					push bc 
b559 e1					pop hl 
b55a			 
b55a					if DEBUG_FORTH_WORDS 
b55a						DMARK "GT1" 
b55a f5				push af  
b55b 3a 6f b5			ld a, (.dmark)  
b55e 32 6b ee			ld (debug_mark),a  
b561 3a 70 b5			ld a, (.dmark+1)  
b564 32 6c ee			ld (debug_mark+1),a  
b567 3a 71 b5			ld a, (.dmark+2)  
b56a 32 6d ee			ld (debug_mark+2),a  
b56d 18 03			jr .pastdmark  
b56f ..			.dmark: db "GT1"  
b572 f1			.pastdmark: pop af  
b573			endm  
# End of macro DMARK
b573						CALLMONITOR 
b573 cd 6f ee			call debug_vector  
b576				endm  
# End of macro CALLMONITOR
b576					endif 
b576 cd 3b 9b				call forth_push_numhl 
b579			 
b579					NEXTW 
b579 c3 e8 9e			jp macro_next 
b57c				endm 
# End of macro NEXTW
b57c			.EQUAL: 
b57c				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b57c 31				db WORD_SYS_CORE+29             
b57d e7 b5			dw .ENDLOGIC            
b57f 02				db 1 + 1 
b580 .. 00			db "=",0              
b582				endm 
# End of macro CWHEAD
b582			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b582				; TODO add floating point number detection 
b582					if DEBUG_FORTH_WORDS_KEY 
b582						DMARK "EQ." 
b582 f5				push af  
b583 3a 97 b5			ld a, (.dmark)  
b586 32 6b ee			ld (debug_mark),a  
b589 3a 98 b5			ld a, (.dmark+1)  
b58c 32 6c ee			ld (debug_mark+1),a  
b58f 3a 99 b5			ld a, (.dmark+2)  
b592 32 6d ee			ld (debug_mark+2),a  
b595 18 03			jr .pastdmark  
b597 ..			.dmark: db "EQ."  
b59a f1			.pastdmark: pop af  
b59b			endm  
# End of macro DMARK
b59b						CALLMONITOR 
b59b cd 6f ee			call debug_vector  
b59e				endm  
# End of macro CALLMONITOR
b59e					endif 
b59e					FORTH_DSP 
b59e cd f8 9c			call macro_forth_dsp 
b5a1				endm 
# End of macro FORTH_DSP
b5a1					;v5 FORTH_DSP_VALUE 
b5a1 7e					ld a,(hl)	; get type of value on TOS 
b5a2 fe 02				cp DS_TYPE_INUM  
b5a4 28 00				jr z, .eq_inum 
b5a6			 
b5a6				if FORTH_ENABLE_FLOATMATH 
b5a6					jr .eq_done 
b5a6			 
b5a6				endif 
b5a6					 
b5a6			 
b5a6			.eq_inum: 
b5a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5a6 cd 32 9d			call macro_dsp_valuehl 
b5a9				endm 
# End of macro FORTH_DSP_VALUEHL
b5a9			 
b5a9 e5					push hl 
b5aa			 
b5aa					; destroy value TOS 
b5aa			 
b5aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5aa cd ea 9d			call macro_forth_dsp_pop 
b5ad				endm 
# End of macro FORTH_DSP_POP
b5ad			 
b5ad			 
b5ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5ad cd 32 9d			call macro_dsp_valuehl 
b5b0				endm 
# End of macro FORTH_DSP_VALUEHL
b5b0			 
b5b0					; one value on hl get other one back 
b5b0			 
b5b0 e5					push hl 
b5b1			 
b5b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5b1 cd ea 9d			call macro_forth_dsp_pop 
b5b4				endm 
# End of macro FORTH_DSP_POP
b5b4			 
b5b4 0e 00				ld c, FORTH_FALSE 
b5b6			 
b5b6 e1					pop hl 
b5b7 d1					pop de 
b5b8			 
b5b8 7b					ld a, e 
b5b9 bd					cp l 
b5ba			 
b5ba 20 06				jr nz, .eq_done 
b5bc			 
b5bc 7a					ld a, d 
b5bd bc					cp h 
b5be			 
b5be 20 02				jr nz, .eq_done 
b5c0			 
b5c0 0e 01				ld c, FORTH_TRUE 
b5c2					 
b5c2			 
b5c2			 
b5c2			.eq_done: 
b5c2			 
b5c2					; TODO push value back onto stack for another op etc 
b5c2			 
b5c2 26 00				ld h, 0 
b5c4 69					ld l, c 
b5c5					if DEBUG_FORTH_WORDS 
b5c5						DMARK "EQ1" 
b5c5 f5				push af  
b5c6 3a da b5			ld a, (.dmark)  
b5c9 32 6b ee			ld (debug_mark),a  
b5cc 3a db b5			ld a, (.dmark+1)  
b5cf 32 6c ee			ld (debug_mark+1),a  
b5d2 3a dc b5			ld a, (.dmark+2)  
b5d5 32 6d ee			ld (debug_mark+2),a  
b5d8 18 03			jr .pastdmark  
b5da ..			.dmark: db "EQ1"  
b5dd f1			.pastdmark: pop af  
b5de			endm  
# End of macro DMARK
b5de						CALLMONITOR 
b5de cd 6f ee			call debug_vector  
b5e1				endm  
# End of macro CALLMONITOR
b5e1					endif 
b5e1 cd 3b 9b				call forth_push_numhl 
b5e4			 
b5e4					NEXTW 
b5e4 c3 e8 9e			jp macro_next 
b5e7				endm 
# End of macro NEXTW
b5e7			 
b5e7			 
b5e7			.ENDLOGIC: 
b5e7			; eof 
b5e7			 
b5e7			 
# End of file forth_words_logic.asm
b5e7			include "forth_words_maths.asm" 
b5e7			 
b5e7			; | ## Maths Words 
b5e7			 
b5e7			.PLUS:	 
b5e7				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b5e7 15				db WORD_SYS_CORE+1             
b5e8 45 b6			dw .NEG            
b5ea 02				db 1 + 1 
b5eb .. 00			db "+",0              
b5ed				endm 
# End of macro CWHEAD
b5ed			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b5ed					if DEBUG_FORTH_WORDS_KEY 
b5ed						DMARK "PLU" 
b5ed f5				push af  
b5ee 3a 02 b6			ld a, (.dmark)  
b5f1 32 6b ee			ld (debug_mark),a  
b5f4 3a 03 b6			ld a, (.dmark+1)  
b5f7 32 6c ee			ld (debug_mark+1),a  
b5fa 3a 04 b6			ld a, (.dmark+2)  
b5fd 32 6d ee			ld (debug_mark+2),a  
b600 18 03			jr .pastdmark  
b602 ..			.dmark: db "PLU"  
b605 f1			.pastdmark: pop af  
b606			endm  
# End of macro DMARK
b606						CALLMONITOR 
b606 cd 6f ee			call debug_vector  
b609				endm  
# End of macro CALLMONITOR
b609					endif 
b609					; add top two values and push back result 
b609			 
b609					;for v5 FORTH_DSP_VALUE 
b609					FORTH_DSP 
b609 cd f8 9c			call macro_forth_dsp 
b60c				endm 
# End of macro FORTH_DSP
b60c 7e					ld a,(hl)	; get type of value on TOS 
b60d fe 02				cp DS_TYPE_INUM  
b60f 28 03				jr z, .dot_inum 
b611			 
b611					NEXTW 
b611 c3 e8 9e			jp macro_next 
b614				endm 
# End of macro NEXTW
b614			 
b614			; float maths 
b614			 
b614				if FORTH_ENABLE_FLOATMATH 
b614						inc hl      ; now at start of numeric as string 
b614			 
b614					if DEBUG_FORTH_MATHS 
b614						DMARK "ADD" 
b614				CALLMONITOR 
b614					endif 
b614			 
b614					;ld ix, hl 
b614					call CON 
b614			 
b614			 
b614					push hl 
b614					 
b614					 
b614			 
b614						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b614			 
b614					; get next number 
b614			 
b614						FORTH_DSP_VALUE 
b614			 
b614						inc hl      ; now at start of numeric as string 
b614			 
b614					;ld ix, hl 
b614					call CON 
b614			 
b614					push hl 
b614			 
b614			 
b614						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b614			 
b614						; TODO do add 
b614			 
b614						call IADD 
b614			 
b614						; TODO get result back as ascii 
b614			 
b614						; TODO push result  
b614			 
b614			 
b614			 
b614						jr .dot_done 
b614				endif 
b614			 
b614			.dot_inum: 
b614			 
b614			 
b614					if DEBUG_FORTH_DOT 
b614						DMARK "+IT" 
b614 f5				push af  
b615 3a 29 b6			ld a, (.dmark)  
b618 32 6b ee			ld (debug_mark),a  
b61b 3a 2a b6			ld a, (.dmark+1)  
b61e 32 6c ee			ld (debug_mark+1),a  
b621 3a 2b b6			ld a, (.dmark+2)  
b624 32 6d ee			ld (debug_mark+2),a  
b627 18 03			jr .pastdmark  
b629 ..			.dmark: db "+IT"  
b62c f1			.pastdmark: pop af  
b62d			endm  
# End of macro DMARK
b62d				CALLMONITOR 
b62d cd 6f ee			call debug_vector  
b630				endm  
# End of macro CALLMONITOR
b630					endif 
b630			 
b630					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b630 cd 32 9d			call macro_dsp_valuehl 
b633				endm 
# End of macro FORTH_DSP_VALUEHL
b633			 
b633				; TODO add floating point number detection 
b633			 
b633 e5					push hl 
b634			 
b634					; destroy value TOS 
b634			 
b634					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b634 cd ea 9d			call macro_forth_dsp_pop 
b637				endm 
# End of macro FORTH_DSP_POP
b637			 
b637			 
b637					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b637 cd 32 9d			call macro_dsp_valuehl 
b63a				endm 
# End of macro FORTH_DSP_VALUEHL
b63a			 
b63a					; one value on hl get other one back 
b63a			 
b63a d1					pop de 
b63b			 
b63b					; do the add 
b63b			 
b63b 19					add hl,de 
b63c			 
b63c					; save it 
b63c			 
b63c			;		push hl	 
b63c			 
b63c					; 
b63c			 
b63c					; destroy value TOS 
b63c			 
b63c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b63c cd ea 9d			call macro_forth_dsp_pop 
b63f				endm 
# End of macro FORTH_DSP_POP
b63f			 
b63f					; TODO push value back onto stack for another op etc 
b63f			 
b63f			;		pop hl 
b63f			 
b63f			.dot_done: 
b63f cd 3b 9b				call forth_push_numhl 
b642			 
b642					NEXTW 
b642 c3 e8 9e			jp macro_next 
b645				endm 
# End of macro NEXTW
b645			.NEG: 
b645			 
b645				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b645 17				db WORD_SYS_CORE+3             
b646 88 b6			dw .DIV            
b648 02				db 1 + 1 
b649 .. 00			db "-",0              
b64b				endm 
# End of macro CWHEAD
b64b			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b64b					if DEBUG_FORTH_WORDS_KEY 
b64b						DMARK "SUB" 
b64b f5				push af  
b64c 3a 60 b6			ld a, (.dmark)  
b64f 32 6b ee			ld (debug_mark),a  
b652 3a 61 b6			ld a, (.dmark+1)  
b655 32 6c ee			ld (debug_mark+1),a  
b658 3a 62 b6			ld a, (.dmark+2)  
b65b 32 6d ee			ld (debug_mark+2),a  
b65e 18 03			jr .pastdmark  
b660 ..			.dmark: db "SUB"  
b663 f1			.pastdmark: pop af  
b664			endm  
# End of macro DMARK
b664						CALLMONITOR 
b664 cd 6f ee			call debug_vector  
b667				endm  
# End of macro CALLMONITOR
b667					endif 
b667			 
b667			 
b667				; TODO add floating point number detection 
b667					; v5 FORTH_DSP_VALUE 
b667					FORTH_DSP 
b667 cd f8 9c			call macro_forth_dsp 
b66a				endm 
# End of macro FORTH_DSP
b66a 7e					ld a,(hl)	; get type of value on TOS 
b66b fe 02				cp DS_TYPE_INUM  
b66d 28 03				jr z, .neg_inum 
b66f			 
b66f					NEXTW 
b66f c3 e8 9e			jp macro_next 
b672				endm 
# End of macro NEXTW
b672			 
b672			; float maths 
b672			 
b672				if FORTH_ENABLE_FLOATMATH 
b672					jr .neg_done 
b672			 
b672				endif 
b672					 
b672			 
b672			.neg_inum: 
b672					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b672 cd 32 9d			call macro_dsp_valuehl 
b675				endm 
# End of macro FORTH_DSP_VALUEHL
b675			 
b675 e5					push hl 
b676			 
b676					; destroy value TOS 
b676			 
b676					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b676 cd ea 9d			call macro_forth_dsp_pop 
b679				endm 
# End of macro FORTH_DSP_POP
b679			 
b679			 
b679					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b679 cd 32 9d			call macro_dsp_valuehl 
b67c				endm 
# End of macro FORTH_DSP_VALUEHL
b67c			 
b67c					; one value on hl get other one back 
b67c			 
b67c d1					pop de 
b67d			 
b67d					; do the sub 
b67d			;		ex de, hl 
b67d			 
b67d ed 52				sbc hl,de 
b67f			 
b67f					; save it 
b67f			 
b67f			;		push hl	 
b67f			 
b67f					; 
b67f			 
b67f					; destroy value TOS 
b67f			 
b67f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b67f cd ea 9d			call macro_forth_dsp_pop 
b682				endm 
# End of macro FORTH_DSP_POP
b682			 
b682					; TODO push value back onto stack for another op etc 
b682			 
b682			;		pop hl 
b682			 
b682 cd 3b 9b				call forth_push_numhl 
b685			.neg_done: 
b685			 
b685					NEXTW 
b685 c3 e8 9e			jp macro_next 
b688				endm 
# End of macro NEXTW
b688			.DIV: 
b688				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b688 18				db WORD_SYS_CORE+4             
b689 d5 b6			dw .MUL            
b68b 02				db 1 + 1 
b68c .. 00			db "/",0              
b68e				endm 
# End of macro CWHEAD
b68e			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b68e					if DEBUG_FORTH_WORDS_KEY 
b68e						DMARK "DIV" 
b68e f5				push af  
b68f 3a a3 b6			ld a, (.dmark)  
b692 32 6b ee			ld (debug_mark),a  
b695 3a a4 b6			ld a, (.dmark+1)  
b698 32 6c ee			ld (debug_mark+1),a  
b69b 3a a5 b6			ld a, (.dmark+2)  
b69e 32 6d ee			ld (debug_mark+2),a  
b6a1 18 03			jr .pastdmark  
b6a3 ..			.dmark: db "DIV"  
b6a6 f1			.pastdmark: pop af  
b6a7			endm  
# End of macro DMARK
b6a7						CALLMONITOR 
b6a7 cd 6f ee			call debug_vector  
b6aa				endm  
# End of macro CALLMONITOR
b6aa					endif 
b6aa				; TODO add floating point number detection 
b6aa					; v5 FORTH_DSP_VALUE 
b6aa					FORTH_DSP 
b6aa cd f8 9c			call macro_forth_dsp 
b6ad				endm 
# End of macro FORTH_DSP
b6ad 7e					ld a,(hl)	; get type of value on TOS 
b6ae fe 02				cp DS_TYPE_INUM  
b6b0 28 03				jr z, .div_inum 
b6b2			 
b6b2				if FORTH_ENABLE_FLOATMATH 
b6b2					jr .div_done 
b6b2			 
b6b2				endif 
b6b2					NEXTW 
b6b2 c3 e8 9e			jp macro_next 
b6b5				endm 
# End of macro NEXTW
b6b5			.div_inum: 
b6b5			 
b6b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6b5 cd 32 9d			call macro_dsp_valuehl 
b6b8				endm 
# End of macro FORTH_DSP_VALUEHL
b6b8			 
b6b8 e5					push hl    ; to go to bc 
b6b9			 
b6b9					; destroy value TOS 
b6b9			 
b6b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6b9 cd ea 9d			call macro_forth_dsp_pop 
b6bc				endm 
# End of macro FORTH_DSP_POP
b6bc			 
b6bc			 
b6bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6bc cd 32 9d			call macro_dsp_valuehl 
b6bf				endm 
# End of macro FORTH_DSP_VALUEHL
b6bf			 
b6bf					; hl to go to de 
b6bf			 
b6bf e5					push hl 
b6c0			 
b6c0 c1					pop bc 
b6c1 d1					pop de		 
b6c2			 
b6c2			 
b6c2					if DEBUG_FORTH_MATHS 
b6c2						DMARK "DIV" 
b6c2				CALLMONITOR 
b6c2					endif 
b6c2					; one value on hl but move to a get other one back 
b6c2			 
b6c2			        
b6c2 cd 38 8c			call Div16 
b6c5			 
b6c5			;	push af	 
b6c5 e5				push hl 
b6c6 c5				push bc 
b6c7			 
b6c7					if DEBUG_FORTH_MATHS 
b6c7						DMARK "DI1" 
b6c7				CALLMONITOR 
b6c7					endif 
b6c7			 
b6c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6c7 cd ea 9d			call macro_forth_dsp_pop 
b6ca				endm 
# End of macro FORTH_DSP_POP
b6ca			 
b6ca			 
b6ca			 
b6ca e1					pop hl    ; result 
b6cb			 
b6cb cd 3b 9b				call forth_push_numhl 
b6ce			 
b6ce e1					pop hl    ; reminder 
b6cf			;		ld h,0 
b6cf			;		ld l,d 
b6cf			 
b6cf cd 3b 9b				call forth_push_numhl 
b6d2			.div_done: 
b6d2					NEXTW 
b6d2 c3 e8 9e			jp macro_next 
b6d5				endm 
# End of macro NEXTW
b6d5			.MUL: 
b6d5				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b6d5 19				db WORD_SYS_CORE+5             
b6d6 1a b7			dw .MIN            
b6d8 02				db 1 + 1 
b6d9 .. 00			db "*",0              
b6db				endm 
# End of macro CWHEAD
b6db			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b6db				; TODO add floating point number detection 
b6db					if DEBUG_FORTH_WORDS_KEY 
b6db						DMARK "MUL" 
b6db f5				push af  
b6dc 3a f0 b6			ld a, (.dmark)  
b6df 32 6b ee			ld (debug_mark),a  
b6e2 3a f1 b6			ld a, (.dmark+1)  
b6e5 32 6c ee			ld (debug_mark+1),a  
b6e8 3a f2 b6			ld a, (.dmark+2)  
b6eb 32 6d ee			ld (debug_mark+2),a  
b6ee 18 03			jr .pastdmark  
b6f0 ..			.dmark: db "MUL"  
b6f3 f1			.pastdmark: pop af  
b6f4			endm  
# End of macro DMARK
b6f4						CALLMONITOR 
b6f4 cd 6f ee			call debug_vector  
b6f7				endm  
# End of macro CALLMONITOR
b6f7					endif 
b6f7					FORTH_DSP 
b6f7 cd f8 9c			call macro_forth_dsp 
b6fa				endm 
# End of macro FORTH_DSP
b6fa					; v5 FORTH_DSP_VALUE 
b6fa 7e					ld a,(hl)	; get type of value on TOS 
b6fb fe 02				cp DS_TYPE_INUM  
b6fd 28 03				jr z, .mul_inum 
b6ff			 
b6ff				if FORTH_ENABLE_FLOATMATH 
b6ff					jr .mul_done 
b6ff			 
b6ff				endif 
b6ff			 
b6ff					NEXTW 
b6ff c3 e8 9e			jp macro_next 
b702				endm 
# End of macro NEXTW
b702			.mul_inum:	 
b702			 
b702					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b702 cd 32 9d			call macro_dsp_valuehl 
b705				endm 
# End of macro FORTH_DSP_VALUEHL
b705			 
b705 e5					push hl 
b706			 
b706					; destroy value TOS 
b706			 
b706					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b706 cd ea 9d			call macro_forth_dsp_pop 
b709				endm 
# End of macro FORTH_DSP_POP
b709			 
b709			 
b709					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b709 cd 32 9d			call macro_dsp_valuehl 
b70c				endm 
# End of macro FORTH_DSP_VALUEHL
b70c			 
b70c					; one value on hl but move to a get other one back 
b70c			 
b70c 7d					ld a, l 
b70d			 
b70d d1					pop de 
b70e			 
b70e					; do the mull 
b70e			;		ex de, hl 
b70e			 
b70e cd 5e 8c				call Mult16 
b711					; save it 
b711			 
b711			;		push hl	 
b711			 
b711					; 
b711			 
b711					; destroy value TOS 
b711			 
b711					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b711 cd ea 9d			call macro_forth_dsp_pop 
b714				endm 
# End of macro FORTH_DSP_POP
b714			 
b714					; TODO push value back onto stack for another op etc 
b714			 
b714			;		pop hl 
b714			 
b714 cd 3b 9b				call forth_push_numhl 
b717			 
b717			.mul_done: 
b717					NEXTW 
b717 c3 e8 9e			jp macro_next 
b71a				endm 
# End of macro NEXTW
b71a			 
b71a			 
b71a			 
b71a			 
b71a			.MIN: 
b71a				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b71a 49				db WORD_SYS_CORE+53             
b71b 9b b7			dw .MAX            
b71d 04				db 3 + 1 
b71e .. 00			db "MIN",0              
b722				endm 
# End of macro CWHEAD
b722			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b722					if DEBUG_FORTH_WORDS_KEY 
b722						DMARK "MIN" 
b722 f5				push af  
b723 3a 37 b7			ld a, (.dmark)  
b726 32 6b ee			ld (debug_mark),a  
b729 3a 38 b7			ld a, (.dmark+1)  
b72c 32 6c ee			ld (debug_mark+1),a  
b72f 3a 39 b7			ld a, (.dmark+2)  
b732 32 6d ee			ld (debug_mark+2),a  
b735 18 03			jr .pastdmark  
b737 ..			.dmark: db "MIN"  
b73a f1			.pastdmark: pop af  
b73b			endm  
# End of macro DMARK
b73b						CALLMONITOR 
b73b cd 6f ee			call debug_vector  
b73e				endm  
# End of macro CALLMONITOR
b73e					endif 
b73e					; get u2 
b73e			 
b73e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b73e cd 32 9d			call macro_dsp_valuehl 
b741				endm 
# End of macro FORTH_DSP_VALUEHL
b741			 
b741 e5					push hl   ; u2 
b742			 
b742					; destroy value TOS 
b742			 
b742					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b742 cd ea 9d			call macro_forth_dsp_pop 
b745				endm 
# End of macro FORTH_DSP_POP
b745			 
b745					; get u1 
b745			 
b745					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b745 cd 32 9d			call macro_dsp_valuehl 
b748				endm 
# End of macro FORTH_DSP_VALUEHL
b748			 
b748 e5					push hl  ; u1 
b749			 
b749					; destroy value TOS 
b749			 
b749					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b749 cd ea 9d			call macro_forth_dsp_pop 
b74c				endm 
# End of macro FORTH_DSP_POP
b74c			 
b74c b7			 or a      ;clear carry flag 
b74d e1			  pop hl    ; u1 
b74e d1			  pop de    ; u2 
b74f e5				push hl   ; saved in case hl is lowest 
b750 ed 52		  sbc hl,de 
b752 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b754			 
b754 e1				pop hl 
b755					if DEBUG_FORTH_WORDS 
b755						DMARK "MIN" 
b755 f5				push af  
b756 3a 6a b7			ld a, (.dmark)  
b759 32 6b ee			ld (debug_mark),a  
b75c 3a 6b b7			ld a, (.dmark+1)  
b75f 32 6c ee			ld (debug_mark+1),a  
b762 3a 6c b7			ld a, (.dmark+2)  
b765 32 6d ee			ld (debug_mark+2),a  
b768 18 03			jr .pastdmark  
b76a ..			.dmark: db "MIN"  
b76d f1			.pastdmark: pop af  
b76e			endm  
# End of macro DMARK
b76e						CALLMONITOR 
b76e cd 6f ee			call debug_vector  
b771				endm  
# End of macro CALLMONITOR
b771					endif 
b771 cd 3b 9b				call forth_push_numhl 
b774			 
b774				       NEXTW 
b774 c3 e8 9e			jp macro_next 
b777				endm 
# End of macro NEXTW
b777			 
b777			.mincont:  
b777 c1				pop bc   ; tidy up 
b778 eb				ex de , hl  
b779					if DEBUG_FORTH_WORDS 
b779						DMARK "MI1" 
b779 f5				push af  
b77a 3a 8e b7			ld a, (.dmark)  
b77d 32 6b ee			ld (debug_mark),a  
b780 3a 8f b7			ld a, (.dmark+1)  
b783 32 6c ee			ld (debug_mark+1),a  
b786 3a 90 b7			ld a, (.dmark+2)  
b789 32 6d ee			ld (debug_mark+2),a  
b78c 18 03			jr .pastdmark  
b78e ..			.dmark: db "MI1"  
b791 f1			.pastdmark: pop af  
b792			endm  
# End of macro DMARK
b792						CALLMONITOR 
b792 cd 6f ee			call debug_vector  
b795				endm  
# End of macro CALLMONITOR
b795					endif 
b795 cd 3b 9b				call forth_push_numhl 
b798			 
b798				       NEXTW 
b798 c3 e8 9e			jp macro_next 
b79b				endm 
# End of macro NEXTW
b79b			.MAX: 
b79b				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b79b 4a				db WORD_SYS_CORE+54             
b79c 1c b8			dw .RND16            
b79e 04				db 3 + 1 
b79f .. 00			db "MAX",0              
b7a3				endm 
# End of macro CWHEAD
b7a3			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b7a3					if DEBUG_FORTH_WORDS_KEY 
b7a3						DMARK "MAX" 
b7a3 f5				push af  
b7a4 3a b8 b7			ld a, (.dmark)  
b7a7 32 6b ee			ld (debug_mark),a  
b7aa 3a b9 b7			ld a, (.dmark+1)  
b7ad 32 6c ee			ld (debug_mark+1),a  
b7b0 3a ba b7			ld a, (.dmark+2)  
b7b3 32 6d ee			ld (debug_mark+2),a  
b7b6 18 03			jr .pastdmark  
b7b8 ..			.dmark: db "MAX"  
b7bb f1			.pastdmark: pop af  
b7bc			endm  
# End of macro DMARK
b7bc						CALLMONITOR 
b7bc cd 6f ee			call debug_vector  
b7bf				endm  
# End of macro CALLMONITOR
b7bf					endif 
b7bf					; get u2 
b7bf			 
b7bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7bf cd 32 9d			call macro_dsp_valuehl 
b7c2				endm 
# End of macro FORTH_DSP_VALUEHL
b7c2			 
b7c2 e5					push hl   ; u2 
b7c3			 
b7c3					; destroy value TOS 
b7c3			 
b7c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7c3 cd ea 9d			call macro_forth_dsp_pop 
b7c6				endm 
# End of macro FORTH_DSP_POP
b7c6			 
b7c6					; get u1 
b7c6			 
b7c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7c6 cd 32 9d			call macro_dsp_valuehl 
b7c9				endm 
# End of macro FORTH_DSP_VALUEHL
b7c9			 
b7c9 e5					push hl  ; u1 
b7ca			 
b7ca					; destroy value TOS 
b7ca			 
b7ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7ca cd ea 9d			call macro_forth_dsp_pop 
b7cd				endm 
# End of macro FORTH_DSP_POP
b7cd			 
b7cd b7			 or a      ;clear carry flag 
b7ce e1			  pop hl    ; u1 
b7cf d1			  pop de    ; u2 
b7d0 e5				push hl   ; saved in case hl is lowest 
b7d1 ed 52		  sbc hl,de 
b7d3 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b7d5			 
b7d5 e1				pop hl 
b7d6					if DEBUG_FORTH_WORDS 
b7d6						DMARK "MAX" 
b7d6 f5				push af  
b7d7 3a eb b7			ld a, (.dmark)  
b7da 32 6b ee			ld (debug_mark),a  
b7dd 3a ec b7			ld a, (.dmark+1)  
b7e0 32 6c ee			ld (debug_mark+1),a  
b7e3 3a ed b7			ld a, (.dmark+2)  
b7e6 32 6d ee			ld (debug_mark+2),a  
b7e9 18 03			jr .pastdmark  
b7eb ..			.dmark: db "MAX"  
b7ee f1			.pastdmark: pop af  
b7ef			endm  
# End of macro DMARK
b7ef						CALLMONITOR 
b7ef cd 6f ee			call debug_vector  
b7f2				endm  
# End of macro CALLMONITOR
b7f2					endif 
b7f2 cd 3b 9b				call forth_push_numhl 
b7f5			 
b7f5				       NEXTW 
b7f5 c3 e8 9e			jp macro_next 
b7f8				endm 
# End of macro NEXTW
b7f8			 
b7f8			.maxcont:  
b7f8 c1				pop bc   ; tidy up 
b7f9 eb				ex de , hl  
b7fa					if DEBUG_FORTH_WORDS 
b7fa						DMARK "MA1" 
b7fa f5				push af  
b7fb 3a 0f b8			ld a, (.dmark)  
b7fe 32 6b ee			ld (debug_mark),a  
b801 3a 10 b8			ld a, (.dmark+1)  
b804 32 6c ee			ld (debug_mark+1),a  
b807 3a 11 b8			ld a, (.dmark+2)  
b80a 32 6d ee			ld (debug_mark+2),a  
b80d 18 03			jr .pastdmark  
b80f ..			.dmark: db "MA1"  
b812 f1			.pastdmark: pop af  
b813			endm  
# End of macro DMARK
b813						CALLMONITOR 
b813 cd 6f ee			call debug_vector  
b816				endm  
# End of macro CALLMONITOR
b816					endif 
b816 cd 3b 9b				call forth_push_numhl 
b819				       NEXTW 
b819 c3 e8 9e			jp macro_next 
b81c				endm 
# End of macro NEXTW
b81c			 
b81c			.RND16: 
b81c				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b81c 4e				db WORD_SYS_CORE+58             
b81d 4b b8			dw .RND8            
b81f 06				db 5 + 1 
b820 .. 00			db "RND16",0              
b826				endm 
# End of macro CWHEAD
b826			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b826					if DEBUG_FORTH_WORDS_KEY 
b826						DMARK "R16" 
b826 f5				push af  
b827 3a 3b b8			ld a, (.dmark)  
b82a 32 6b ee			ld (debug_mark),a  
b82d 3a 3c b8			ld a, (.dmark+1)  
b830 32 6c ee			ld (debug_mark+1),a  
b833 3a 3d b8			ld a, (.dmark+2)  
b836 32 6d ee			ld (debug_mark+2),a  
b839 18 03			jr .pastdmark  
b83b ..			.dmark: db "R16"  
b83e f1			.pastdmark: pop af  
b83f			endm  
# End of macro DMARK
b83f						CALLMONITOR 
b83f cd 6f ee			call debug_vector  
b842				endm  
# End of macro CALLMONITOR
b842					endif 
b842 cd 02 8c				call prng16  
b845 cd 3b 9b				call forth_push_numhl 
b848				       NEXTW 
b848 c3 e8 9e			jp macro_next 
b84b				endm 
# End of macro NEXTW
b84b			.RND8: 
b84b				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b84b 60				db WORD_SYS_CORE+76             
b84c 80 b8			dw .RND            
b84e 05				db 4 + 1 
b84f .. 00			db "RND8",0              
b854				endm 
# End of macro CWHEAD
b854			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b854					if DEBUG_FORTH_WORDS_KEY 
b854						DMARK "RN8" 
b854 f5				push af  
b855 3a 69 b8			ld a, (.dmark)  
b858 32 6b ee			ld (debug_mark),a  
b85b 3a 6a b8			ld a, (.dmark+1)  
b85e 32 6c ee			ld (debug_mark+1),a  
b861 3a 6b b8			ld a, (.dmark+2)  
b864 32 6d ee			ld (debug_mark+2),a  
b867 18 03			jr .pastdmark  
b869 ..			.dmark: db "RN8"  
b86c f1			.pastdmark: pop af  
b86d			endm  
# End of macro DMARK
b86d						CALLMONITOR 
b86d cd 6f ee			call debug_vector  
b870				endm  
# End of macro CALLMONITOR
b870					endif 
b870 2a a9 eb				ld hl,(xrandc) 
b873 23					inc hl 
b874 cd 1c 8c				call xrnd 
b877 6f					ld l,a	 
b878 26 00				ld h,0 
b87a cd 3b 9b				call forth_push_numhl 
b87d				       NEXTW 
b87d c3 e8 9e			jp macro_next 
b880				endm 
# End of macro NEXTW
b880			.RND: 
b880				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b880 60				db WORD_SYS_CORE+76             
b881 86 b9			dw .ENDMATHS            
b883 04				db 3 + 1 
b884 .. 00			db "RND",0              
b888				endm 
# End of macro CWHEAD
b888			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b888			 
b888					if DEBUG_FORTH_WORDS_KEY 
b888						DMARK "RND" 
b888 f5				push af  
b889 3a 9d b8			ld a, (.dmark)  
b88c 32 6b ee			ld (debug_mark),a  
b88f 3a 9e b8			ld a, (.dmark+1)  
b892 32 6c ee			ld (debug_mark+1),a  
b895 3a 9f b8			ld a, (.dmark+2)  
b898 32 6d ee			ld (debug_mark+2),a  
b89b 18 03			jr .pastdmark  
b89d ..			.dmark: db "RND"  
b8a0 f1			.pastdmark: pop af  
b8a1			endm  
# End of macro DMARK
b8a1						CALLMONITOR 
b8a1 cd 6f ee			call debug_vector  
b8a4				endm  
# End of macro CALLMONITOR
b8a4					endif 
b8a4					 
b8a4					FORTH_DSP_VALUEHL    ; upper range 
b8a4 cd 32 9d			call macro_dsp_valuehl 
b8a7				endm 
# End of macro FORTH_DSP_VALUEHL
b8a7			 
b8a7 22 ad eb				ld (LFSRSeed), hl	 
b8aa			 
b8aa					if DEBUG_FORTH_WORDS 
b8aa						DMARK "RN1" 
b8aa f5				push af  
b8ab 3a bf b8			ld a, (.dmark)  
b8ae 32 6b ee			ld (debug_mark),a  
b8b1 3a c0 b8			ld a, (.dmark+1)  
b8b4 32 6c ee			ld (debug_mark+1),a  
b8b7 3a c1 b8			ld a, (.dmark+2)  
b8ba 32 6d ee			ld (debug_mark+2),a  
b8bd 18 03			jr .pastdmark  
b8bf ..			.dmark: db "RN1"  
b8c2 f1			.pastdmark: pop af  
b8c3			endm  
# End of macro DMARK
b8c3						CALLMONITOR 
b8c3 cd 6f ee			call debug_vector  
b8c6				endm  
# End of macro CALLMONITOR
b8c6					endif 
b8c6					FORTH_DSP_POP 
b8c6 cd ea 9d			call macro_forth_dsp_pop 
b8c9				endm 
# End of macro FORTH_DSP_POP
b8c9			 
b8c9					FORTH_DSP_VALUEHL    ; low range 
b8c9 cd 32 9d			call macro_dsp_valuehl 
b8cc				endm 
# End of macro FORTH_DSP_VALUEHL
b8cc			 
b8cc					if DEBUG_FORTH_WORDS 
b8cc						DMARK "RN2" 
b8cc f5				push af  
b8cd 3a e1 b8			ld a, (.dmark)  
b8d0 32 6b ee			ld (debug_mark),a  
b8d3 3a e2 b8			ld a, (.dmark+1)  
b8d6 32 6c ee			ld (debug_mark+1),a  
b8d9 3a e3 b8			ld a, (.dmark+2)  
b8dc 32 6d ee			ld (debug_mark+2),a  
b8df 18 03			jr .pastdmark  
b8e1 ..			.dmark: db "RN2"  
b8e4 f1			.pastdmark: pop af  
b8e5			endm  
# End of macro DMARK
b8e5						CALLMONITOR 
b8e5 cd 6f ee			call debug_vector  
b8e8				endm  
# End of macro CALLMONITOR
b8e8					endif 
b8e8 22 af eb				ld (LFSRSeed+2), hl 
b8eb			 
b8eb					FORTH_DSP_POP 
b8eb cd ea 9d			call macro_forth_dsp_pop 
b8ee				endm 
# End of macro FORTH_DSP_POP
b8ee			 
b8ee e5					push hl 
b8ef			 
b8ef e1			.inrange:	pop hl 
b8f0 cd 02 8c				call prng16  
b8f3					if DEBUG_FORTH_WORDS 
b8f3						DMARK "RN3" 
b8f3 f5				push af  
b8f4 3a 08 b9			ld a, (.dmark)  
b8f7 32 6b ee			ld (debug_mark),a  
b8fa 3a 09 b9			ld a, (.dmark+1)  
b8fd 32 6c ee			ld (debug_mark+1),a  
b900 3a 0a b9			ld a, (.dmark+2)  
b903 32 6d ee			ld (debug_mark+2),a  
b906 18 03			jr .pastdmark  
b908 ..			.dmark: db "RN3"  
b90b f1			.pastdmark: pop af  
b90c			endm  
# End of macro DMARK
b90c						CALLMONITOR 
b90c cd 6f ee			call debug_vector  
b90f				endm  
# End of macro CALLMONITOR
b90f					endif 
b90f					 
b90f					; if the range is 8bit knock out the high byte 
b90f			 
b90f ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b913			 
b913 3e 00				ld a, 0 
b915 ba					cp d  
b916 20 1e				jr nz, .hirange 
b918 26 00				ld h, 0   ; knock it down to 8bit 
b91a			 
b91a					if DEBUG_FORTH_WORDS 
b91a						DMARK "RNk" 
b91a f5				push af  
b91b 3a 2f b9			ld a, (.dmark)  
b91e 32 6b ee			ld (debug_mark),a  
b921 3a 30 b9			ld a, (.dmark+1)  
b924 32 6c ee			ld (debug_mark+1),a  
b927 3a 31 b9			ld a, (.dmark+2)  
b92a 32 6d ee			ld (debug_mark+2),a  
b92d 18 03			jr .pastdmark  
b92f ..			.dmark: db "RNk"  
b932 f1			.pastdmark: pop af  
b933			endm  
# End of macro DMARK
b933						CALLMONITOR 
b933 cd 6f ee			call debug_vector  
b936				endm  
# End of macro CALLMONITOR
b936					endif 
b936			.hirange:   
b936 e5					push hl  
b937 b7					or a  
b938 ed 52		                sbc hl, de 
b93a			 
b93a					;call cmp16 
b93a			 
b93a 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b93c e1					pop hl 
b93d e5					push hl 
b93e			 
b93e					if DEBUG_FORTH_WORDS 
b93e						DMARK "RN4" 
b93e f5				push af  
b93f 3a 53 b9			ld a, (.dmark)  
b942 32 6b ee			ld (debug_mark),a  
b945 3a 54 b9			ld a, (.dmark+1)  
b948 32 6c ee			ld (debug_mark+1),a  
b94b 3a 55 b9			ld a, (.dmark+2)  
b94e 32 6d ee			ld (debug_mark+2),a  
b951 18 03			jr .pastdmark  
b953 ..			.dmark: db "RN4"  
b956 f1			.pastdmark: pop af  
b957			endm  
# End of macro DMARK
b957						CALLMONITOR 
b957 cd 6f ee			call debug_vector  
b95a				endm  
# End of macro CALLMONITOR
b95a					endif 
b95a ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b95e					;call cmp16 
b95e				 
b95e b7					or a  
b95f ed 52		                sbc hl, de 
b961 38 8c				jr c, .inrange 
b963			 
b963 e1					pop hl 
b964					 
b964					if DEBUG_FORTH_WORDS 
b964						DMARK "RNd" 
b964 f5				push af  
b965 3a 79 b9			ld a, (.dmark)  
b968 32 6b ee			ld (debug_mark),a  
b96b 3a 7a b9			ld a, (.dmark+1)  
b96e 32 6c ee			ld (debug_mark+1),a  
b971 3a 7b b9			ld a, (.dmark+2)  
b974 32 6d ee			ld (debug_mark+2),a  
b977 18 03			jr .pastdmark  
b979 ..			.dmark: db "RNd"  
b97c f1			.pastdmark: pop af  
b97d			endm  
# End of macro DMARK
b97d						CALLMONITOR 
b97d cd 6f ee			call debug_vector  
b980				endm  
# End of macro CALLMONITOR
b980					endif 
b980			 
b980			 
b980 cd 3b 9b				call forth_push_numhl 
b983				       NEXTW 
b983 c3 e8 9e			jp macro_next 
b986				endm 
# End of macro NEXTW
b986			 
b986			.ENDMATHS: 
b986			 
b986			; eof 
b986			 
# End of file forth_words_maths.asm
b986			include "forth_words_display.asm" 
b986			 
b986			; | ## Display Words 
b986			 
b986			.ACT: 
b986			 
b986				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b986 62				db WORD_SYS_CORE+78             
b987 d2 b9			dw .INFO            
b989 07				db 6 + 1 
b98a .. 00			db "ACTIVE",0              
b991				endm 
# End of macro CWHEAD
b991			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b991			;  
b991			; | | e.g. $ff $00 do active . $01 pause loop 
b991			 
b991					if DEBUG_FORTH_WORDS_KEY 
b991						DMARK "ACT" 
b991 f5				push af  
b992 3a a6 b9			ld a, (.dmark)  
b995 32 6b ee			ld (debug_mark),a  
b998 3a a7 b9			ld a, (.dmark+1)  
b99b 32 6c ee			ld (debug_mark+1),a  
b99e 3a a8 b9			ld a, (.dmark+2)  
b9a1 32 6d ee			ld (debug_mark+2),a  
b9a4 18 03			jr .pastdmark  
b9a6 ..			.dmark: db "ACT"  
b9a9 f1			.pastdmark: pop af  
b9aa			endm  
# End of macro DMARK
b9aa						CALLMONITOR 
b9aa cd 6f ee			call debug_vector  
b9ad				endm  
# End of macro CALLMONITOR
b9ad					endif 
b9ad cd 05 8a				call active 
b9b0					if DEBUG_FORTH_WORDS 
b9b0						DMARK "ACp" 
b9b0 f5				push af  
b9b1 3a c5 b9			ld a, (.dmark)  
b9b4 32 6b ee			ld (debug_mark),a  
b9b7 3a c6 b9			ld a, (.dmark+1)  
b9ba 32 6c ee			ld (debug_mark+1),a  
b9bd 3a c7 b9			ld a, (.dmark+2)  
b9c0 32 6d ee			ld (debug_mark+2),a  
b9c3 18 03			jr .pastdmark  
b9c5 ..			.dmark: db "ACp"  
b9c8 f1			.pastdmark: pop af  
b9c9			endm  
# End of macro DMARK
b9c9						CALLMONITOR 
b9c9 cd 6f ee			call debug_vector  
b9cc				endm  
# End of macro CALLMONITOR
b9cc					endif 
b9cc cd a9 9b				call forth_push_str 
b9cf			 
b9cf					NEXTW 
b9cf c3 e8 9e			jp macro_next 
b9d2				endm 
# End of macro NEXTW
b9d2			.INFO: 
b9d2			 
b9d2				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b9d2 62				db WORD_SYS_CORE+78             
b9d3 ef b9			dw .ATP            
b9d5 05				db 4 + 1 
b9d6 .. 00			db "INFO",0              
b9db				endm 
# End of macro CWHEAD
b9db			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b9db					FORTH_DSP_VALUEHL 
b9db cd 32 9d			call macro_dsp_valuehl 
b9de				endm 
# End of macro FORTH_DSP_VALUEHL
b9de			 
b9de					FORTH_DSP_POP 
b9de cd ea 9d			call macro_forth_dsp_pop 
b9e1				endm 
# End of macro FORTH_DSP_POP
b9e1			 
b9e1 e5					push hl 
b9e2			 
b9e2					FORTH_DSP_VALUEHL 
b9e2 cd 32 9d			call macro_dsp_valuehl 
b9e5				endm 
# End of macro FORTH_DSP_VALUEHL
b9e5			 
b9e5					FORTH_DSP_POP 
b9e5 cd ea 9d			call macro_forth_dsp_pop 
b9e8				endm 
# End of macro FORTH_DSP_POP
b9e8			 
b9e8 d1					pop de 
b9e9			 
b9e9 cd 3f 8a				call info_panel 
b9ec			 
b9ec			 
b9ec					NEXTW 
b9ec c3 e8 9e			jp macro_next 
b9ef				endm 
# End of macro NEXTW
b9ef			.ATP: 
b9ef				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b9ef 62				db WORD_SYS_CORE+78             
b9f0 66 ba			dw .FB            
b9f2 04				db 3 + 1 
b9f3 .. 00			db "AT?",0              
b9f7				endm 
# End of macro CWHEAD
b9f7			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b9f7					if DEBUG_FORTH_WORDS_KEY 
b9f7						DMARK "AT?" 
b9f7 f5				push af  
b9f8 3a 0c ba			ld a, (.dmark)  
b9fb 32 6b ee			ld (debug_mark),a  
b9fe 3a 0d ba			ld a, (.dmark+1)  
ba01 32 6c ee			ld (debug_mark+1),a  
ba04 3a 0e ba			ld a, (.dmark+2)  
ba07 32 6d ee			ld (debug_mark+2),a  
ba0a 18 03			jr .pastdmark  
ba0c ..			.dmark: db "AT?"  
ba0f f1			.pastdmark: pop af  
ba10			endm  
# End of macro DMARK
ba10						CALLMONITOR 
ba10 cd 6f ee			call debug_vector  
ba13				endm  
# End of macro CALLMONITOR
ba13					endif 
ba13 3a 5e ea				ld a, (f_cursor_ptr) 
ba16			 
ba16			if DEBUG_FORTH_WORDS 
ba16				DMARK "AT?" 
ba16 f5				push af  
ba17 3a 2b ba			ld a, (.dmark)  
ba1a 32 6b ee			ld (debug_mark),a  
ba1d 3a 2c ba			ld a, (.dmark+1)  
ba20 32 6c ee			ld (debug_mark+1),a  
ba23 3a 2d ba			ld a, (.dmark+2)  
ba26 32 6d ee			ld (debug_mark+2),a  
ba29 18 03			jr .pastdmark  
ba2b ..			.dmark: db "AT?"  
ba2e f1			.pastdmark: pop af  
ba2f			endm  
# End of macro DMARK
ba2f				CALLMONITOR 
ba2f cd 6f ee			call debug_vector  
ba32				endm  
# End of macro CALLMONITOR
ba32			endif	 
ba32					; count the number of rows 
ba32			 
ba32 06 00				ld b, 0 
ba34 4f			.atpr:		ld c, a    ; save in case we go below zero 
ba35 d6 28				sub display_cols 
ba37 f2 3d ba				jp p, .atprunder 
ba3a 04					inc b 
ba3b 18 f7				jr .atpr 
ba3d			.atprunder:	 
ba3d			if DEBUG_FORTH_WORDS 
ba3d				DMARK "A?2" 
ba3d f5				push af  
ba3e 3a 52 ba			ld a, (.dmark)  
ba41 32 6b ee			ld (debug_mark),a  
ba44 3a 53 ba			ld a, (.dmark+1)  
ba47 32 6c ee			ld (debug_mark+1),a  
ba4a 3a 54 ba			ld a, (.dmark+2)  
ba4d 32 6d ee			ld (debug_mark+2),a  
ba50 18 03			jr .pastdmark  
ba52 ..			.dmark: db "A?2"  
ba55 f1			.pastdmark: pop af  
ba56			endm  
# End of macro DMARK
ba56				CALLMONITOR 
ba56 cd 6f ee			call debug_vector  
ba59				endm  
# End of macro CALLMONITOR
ba59			endif	 
ba59 26 00				ld h, 0 
ba5b 69					ld l, c 
ba5c cd 3b 9b				call forth_push_numhl 
ba5f 68					ld l, b  
ba60 cd 3b 9b				call forth_push_numhl 
ba63			 
ba63			 
ba63				NEXTW 
ba63 c3 e8 9e			jp macro_next 
ba66				endm 
# End of macro NEXTW
ba66			 
ba66			.FB: 
ba66				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
ba66 1b				db WORD_SYS_CORE+7             
ba67 b4 ba			dw .EMIT            
ba69 03				db 2 + 1 
ba6a .. 00			db "FB",0              
ba6d				endm 
# End of macro CWHEAD
ba6d			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
ba6d			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
ba6d			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
ba6d			; | | If automatic display is off then updates will not be shown until DRAW is used. 
ba6d					if DEBUG_FORTH_WORDS_KEY 
ba6d						DMARK "FB." 
ba6d f5				push af  
ba6e 3a 82 ba			ld a, (.dmark)  
ba71 32 6b ee			ld (debug_mark),a  
ba74 3a 83 ba			ld a, (.dmark+1)  
ba77 32 6c ee			ld (debug_mark+1),a  
ba7a 3a 84 ba			ld a, (.dmark+2)  
ba7d 32 6d ee			ld (debug_mark+2),a  
ba80 18 03			jr .pastdmark  
ba82 ..			.dmark: db "FB."  
ba85 f1			.pastdmark: pop af  
ba86			endm  
# End of macro DMARK
ba86						CALLMONITOR 
ba86 cd 6f ee			call debug_vector  
ba89				endm  
# End of macro CALLMONITOR
ba89					endif 
ba89			 
ba89					FORTH_DSP_VALUEHL 
ba89 cd 32 9d			call macro_dsp_valuehl 
ba8c				endm 
# End of macro FORTH_DSP_VALUEHL
ba8c			 
ba8c 7d					ld a, l 
ba8d fe 01				cp 1 
ba8f 20 05				jr nz, .fbn1 
ba91 21 10 ed				ld hl, display_fb1 
ba94 18 15				jr .fbset 
ba96 fe 02		.fbn1:		cp 2 
ba98 20 05				jr nz, .fbn2 
ba9a 21 ce eb				ld hl, display_fb2 
ba9d 18 0c				jr .fbset 
ba9f fe 03		.fbn2:		cp 3 
baa1 20 05				jr nz, .fbn3 
baa3 21 6f ec				ld hl, display_fb3 
baa6 18 03				jr .fbset 
baa8			.fbn3:		 ; if invalid number select first 
baa8 21 10 ed				ld hl, display_fb1 
baab 22 cc eb		.fbset:		ld (display_fb_active), hl 
baae			 
baae					FORTH_DSP_POP 
baae cd ea 9d			call macro_forth_dsp_pop 
bab1				endm 
# End of macro FORTH_DSP_POP
bab1			 
bab1					NEXTW 
bab1 c3 e8 9e			jp macro_next 
bab4				endm 
# End of macro NEXTW
bab4			 
bab4			 
bab4			.EMIT: 
bab4				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
bab4 1b				db WORD_SYS_CORE+7             
bab5 05 bb			dw .DOTH            
bab7 05				db 4 + 1 
bab8 .. 00			db "EMIT",0              
babd				endm 
# End of macro CWHEAD
babd			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
babd					; get value off TOS and display it 
babd			 
babd					if DEBUG_FORTH_WORDS_KEY 
babd						DMARK "EMT" 
babd f5				push af  
babe 3a d2 ba			ld a, (.dmark)  
bac1 32 6b ee			ld (debug_mark),a  
bac4 3a d3 ba			ld a, (.dmark+1)  
bac7 32 6c ee			ld (debug_mark+1),a  
baca 3a d4 ba			ld a, (.dmark+2)  
bacd 32 6d ee			ld (debug_mark+2),a  
bad0 18 03			jr .pastdmark  
bad2 ..			.dmark: db "EMT"  
bad5 f1			.pastdmark: pop af  
bad6			endm  
# End of macro DMARK
bad6						CALLMONITOR 
bad6 cd 6f ee			call debug_vector  
bad9				endm  
# End of macro CALLMONITOR
bad9					endif 
bad9			 
bad9					FORTH_DSP_VALUEHL 
bad9 cd 32 9d			call macro_dsp_valuehl 
badc				endm 
# End of macro FORTH_DSP_VALUEHL
badc			 
badc 7d					ld a,l 
badd			 
badd					; TODO write to display 
badd			 
badd 32 bf e4				ld (os_input), a 
bae0 3e 00				ld a, 0 
bae2 32 c0 e4				ld (os_input+1), a 
bae5					 
bae5 3a 5e ea				ld a, (f_cursor_ptr) 
bae8 11 bf e4				ld de, os_input 
baeb cd c1 8a				call str_at_display 
baee			 
baee			 
baee 3a 3c ea				ld a,(cli_autodisplay) 
baf1 fe 00				cp 0 
baf3 28 03				jr z, .enoupdate 
baf5 cd d1 8a						call update_display 
baf8					.enoupdate: 
baf8			 
baf8 3a 5e ea				ld a, (f_cursor_ptr) 
bafb 3c					inc a 
bafc 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
baff			 
baff			 
baff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
baff cd ea 9d			call macro_forth_dsp_pop 
bb02				endm 
# End of macro FORTH_DSP_POP
bb02			  
bb02			 
bb02					NEXTW 
bb02 c3 e8 9e			jp macro_next 
bb05				endm 
# End of macro NEXTW
bb05			.DOTH: 
bb05				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bb05 1c				db WORD_SYS_CORE+8             
bb06 35 bb			dw .DOTF            
bb08 03				db 2 + 1 
bb09 .. 00			db ".-",0              
bb0c				endm 
# End of macro CWHEAD
bb0c			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bb0c					; get value off TOS and display it 
bb0c					if DEBUG_FORTH_WORDS_KEY 
bb0c						DMARK "DTD" 
bb0c f5				push af  
bb0d 3a 21 bb			ld a, (.dmark)  
bb10 32 6b ee			ld (debug_mark),a  
bb13 3a 22 bb			ld a, (.dmark+1)  
bb16 32 6c ee			ld (debug_mark+1),a  
bb19 3a 23 bb			ld a, (.dmark+2)  
bb1c 32 6d ee			ld (debug_mark+2),a  
bb1f 18 03			jr .pastdmark  
bb21 ..			.dmark: db "DTD"  
bb24 f1			.pastdmark: pop af  
bb25			endm  
# End of macro DMARK
bb25						CALLMONITOR 
bb25 cd 6f ee			call debug_vector  
bb28				endm  
# End of macro CALLMONITOR
bb28					endif 
bb28 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bb2a 3e 00			ld a, 0 
bb2c 32 3d ea			ld (cli_mvdot), a 
bb2f c3 8c bb			jp .dotgo 
bb32				NEXTW 
bb32 c3 e8 9e			jp macro_next 
bb35				endm 
# End of macro NEXTW
bb35			.DOTF: 
bb35				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bb35 1c				db WORD_SYS_CORE+8             
bb36 63 bb			dw .DOT            
bb38 03				db 2 + 1 
bb39 .. 00			db ".>",0              
bb3c				endm 
# End of macro CWHEAD
bb3c			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
bb3c					; get value off TOS and display it 
bb3c			        ; TODO BUG adds extra spaces 
bb3c			        ; TODO BUG handle numerics? 
bb3c					if DEBUG_FORTH_WORDS_KEY 
bb3c						DMARK "DTC" 
bb3c f5				push af  
bb3d 3a 51 bb			ld a, (.dmark)  
bb40 32 6b ee			ld (debug_mark),a  
bb43 3a 52 bb			ld a, (.dmark+1)  
bb46 32 6c ee			ld (debug_mark+1),a  
bb49 3a 53 bb			ld a, (.dmark+2)  
bb4c 32 6d ee			ld (debug_mark+2),a  
bb4f 18 03			jr .pastdmark  
bb51 ..			.dmark: db "DTC"  
bb54 f1			.pastdmark: pop af  
bb55			endm  
# End of macro DMARK
bb55						CALLMONITOR 
bb55 cd 6f ee			call debug_vector  
bb58				endm  
# End of macro CALLMONITOR
bb58					endif 
bb58 3e 01			ld a, 1 
bb5a 32 3d ea			ld (cli_mvdot), a 
bb5d c3 8c bb			jp .dotgo 
bb60				NEXTW 
bb60 c3 e8 9e			jp macro_next 
bb63				endm 
# End of macro NEXTW
bb63			 
bb63			.DOT: 
bb63				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bb63 1c				db WORD_SYS_CORE+8             
bb64 3f bd			dw .CLS            
bb66 02				db 1 + 1 
bb67 .. 00			db ".",0              
bb69				endm 
# End of macro CWHEAD
bb69			        ; | . ( u -- ) Display TOS | DONE 
bb69					; get value off TOS and display it 
bb69			 
bb69					if DEBUG_FORTH_WORDS_KEY 
bb69						DMARK "DOT" 
bb69 f5				push af  
bb6a 3a 7e bb			ld a, (.dmark)  
bb6d 32 6b ee			ld (debug_mark),a  
bb70 3a 7f bb			ld a, (.dmark+1)  
bb73 32 6c ee			ld (debug_mark+1),a  
bb76 3a 80 bb			ld a, (.dmark+2)  
bb79 32 6d ee			ld (debug_mark+2),a  
bb7c 18 03			jr .pastdmark  
bb7e ..			.dmark: db "DOT"  
bb81 f1			.pastdmark: pop af  
bb82			endm  
# End of macro DMARK
bb82						CALLMONITOR 
bb82 cd 6f ee			call debug_vector  
bb85				endm  
# End of macro CALLMONITOR
bb85					endif 
bb85 3e 00			ld a, 0 
bb87 32 3d ea			ld (cli_mvdot), a 
bb8a 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bb8c				 
bb8c			 
bb8c			.dotgo: 
bb8c			 
bb8c			; move up type to on stack for parserv5 
bb8c					FORTH_DSP 
bb8c cd f8 9c			call macro_forth_dsp 
bb8f				endm 
# End of macro FORTH_DSP
bb8f				;FORTH_DSP_VALUE  
bb8f			 
bb8f			if DEBUG_FORTH_DOT 
bb8f				DMARK "DOT" 
bb8f f5				push af  
bb90 3a a4 bb			ld a, (.dmark)  
bb93 32 6b ee			ld (debug_mark),a  
bb96 3a a5 bb			ld a, (.dmark+1)  
bb99 32 6c ee			ld (debug_mark+1),a  
bb9c 3a a6 bb			ld a, (.dmark+2)  
bb9f 32 6d ee			ld (debug_mark+2),a  
bba2 18 03			jr .pastdmark  
bba4 ..			.dmark: db "DOT"  
bba7 f1			.pastdmark: pop af  
bba8			endm  
# End of macro DMARK
bba8				CALLMONITOR 
bba8 cd 6f ee			call debug_vector  
bbab				endm  
# End of macro CALLMONITOR
bbab			endif	 
bbab			;		.print: 
bbab			 
bbab 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bbac 23				inc hl   ; position to the actual value 
bbad fe 01			cp DS_TYPE_STR 
bbaf 20 06			jr nz, .dotnum1  
bbb1			 
bbb1			; display string 
bbb1				FORTH_DSP_VALUE  
bbb1 cd 1b 9d			call macro_forth_dsp_value 
bbb4				endm 
# End of macro FORTH_DSP_VALUE
bbb4 eb				ex de,hl 
bbb5 18 49			jr .dotwrite 
bbb7			 
bbb7			.dotnum1: 
bbb7 fe 02			cp DS_TYPE_INUM 
bbb9 20 44			jr nz, .dotflot 
bbbb			 
bbbb			 
bbbb			; display number 
bbbb			 
bbbb			;	push hl 
bbbb			;	call clear_display 
bbbb			;	pop hl 
bbbb			 
bbbb 5e				ld e, (hl) 
bbbc 23				inc hl 
bbbd 56				ld d, (hl) 
bbbe 21 c1 e2			ld hl, scratch 
bbc1			if DEBUG_FORTH_DOT 
bbc1				DMARK "DT1" 
bbc1 f5				push af  
bbc2 3a d6 bb			ld a, (.dmark)  
bbc5 32 6b ee			ld (debug_mark),a  
bbc8 3a d7 bb			ld a, (.dmark+1)  
bbcb 32 6c ee			ld (debug_mark+1),a  
bbce 3a d8 bb			ld a, (.dmark+2)  
bbd1 32 6d ee			ld (debug_mark+2),a  
bbd4 18 03			jr .pastdmark  
bbd6 ..			.dmark: db "DT1"  
bbd9 f1			.pastdmark: pop af  
bbda			endm  
# End of macro DMARK
bbda				CALLMONITOR 
bbda cd 6f ee			call debug_vector  
bbdd				endm  
# End of macro CALLMONITOR
bbdd			endif	 
bbdd			 
bbdd cd e8 90			call uitoa_16 
bbe0 eb				ex de,hl 
bbe1			 
bbe1			if DEBUG_FORTH_DOT 
bbe1				DMARK "DT2" 
bbe1 f5				push af  
bbe2 3a f6 bb			ld a, (.dmark)  
bbe5 32 6b ee			ld (debug_mark),a  
bbe8 3a f7 bb			ld a, (.dmark+1)  
bbeb 32 6c ee			ld (debug_mark+1),a  
bbee 3a f8 bb			ld a, (.dmark+2)  
bbf1 32 6d ee			ld (debug_mark+2),a  
bbf4 18 03			jr .pastdmark  
bbf6 ..			.dmark: db "DT2"  
bbf9 f1			.pastdmark: pop af  
bbfa			endm  
# End of macro DMARK
bbfa				CALLMONITOR 
bbfa cd 6f ee			call debug_vector  
bbfd				endm  
# End of macro CALLMONITOR
bbfd			endif	 
bbfd			 
bbfd			;	ld de, os_word_scratch 
bbfd 18 01			jr .dotwrite 
bbff			 
bbff 00			.dotflot:   nop 
bc00			; TODO print floating point number 
bc00			 
bc00			.dotwrite:		 
bc00			 
bc00					; if c is set then set all '-' to spaces 
bc00					; need to also take into account .>  
bc00			 
bc00 3e 01				ld a, 1 
bc02 b9					cp c 
bc03 20 67				jr nz, .nodashswap 
bc05			 
bc05					; DE has the string to write, working with HL 
bc05			 
bc05 06 ff				ld b, 255 
bc07 d5					push de 
bc08 e1					pop hl 
bc09			 
bc09			if DEBUG_FORTH_DOT 
bc09				DMARK "DT-" 
bc09 f5				push af  
bc0a 3a 1e bc			ld a, (.dmark)  
bc0d 32 6b ee			ld (debug_mark),a  
bc10 3a 1f bc			ld a, (.dmark+1)  
bc13 32 6c ee			ld (debug_mark+1),a  
bc16 3a 20 bc			ld a, (.dmark+2)  
bc19 32 6d ee			ld (debug_mark+2),a  
bc1c 18 03			jr .pastdmark  
bc1e ..			.dmark: db "DT-"  
bc21 f1			.pastdmark: pop af  
bc22			endm  
# End of macro DMARK
bc22				CALLMONITOR 
bc22 cd 6f ee			call debug_vector  
bc25				endm  
# End of macro CALLMONITOR
bc25			endif	 
bc25 7e			.dashscan:	ld a, (hl) 
bc26 fe 00				cp 0 
bc28 28 42				jr z, .nodashswap 
bc2a fe 2d				cp '-' 
bc2c 20 03				jr nz, .dashskip 
bc2e 3e 20				ld a, ' ' 
bc30 77					ld (hl), a 
bc31 23			.dashskip:	inc hl 
bc32			if DEBUG_FORTH_DOT 
bc32				DMARK "D-2" 
bc32 f5				push af  
bc33 3a 47 bc			ld a, (.dmark)  
bc36 32 6b ee			ld (debug_mark),a  
bc39 3a 48 bc			ld a, (.dmark+1)  
bc3c 32 6c ee			ld (debug_mark+1),a  
bc3f 3a 49 bc			ld a, (.dmark+2)  
bc42 32 6d ee			ld (debug_mark+2),a  
bc45 18 03			jr .pastdmark  
bc47 ..			.dmark: db "D-2"  
bc4a f1			.pastdmark: pop af  
bc4b			endm  
# End of macro DMARK
bc4b				CALLMONITOR 
bc4b cd 6f ee			call debug_vector  
bc4e				endm  
# End of macro CALLMONITOR
bc4e			endif	 
bc4e 10 d5				djnz .dashscan 
bc50			 
bc50			if DEBUG_FORTH_DOT 
bc50				DMARK "D-1" 
bc50 f5				push af  
bc51 3a 65 bc			ld a, (.dmark)  
bc54 32 6b ee			ld (debug_mark),a  
bc57 3a 66 bc			ld a, (.dmark+1)  
bc5a 32 6c ee			ld (debug_mark+1),a  
bc5d 3a 67 bc			ld a, (.dmark+2)  
bc60 32 6d ee			ld (debug_mark+2),a  
bc63 18 03			jr .pastdmark  
bc65 ..			.dmark: db "D-1"  
bc68 f1			.pastdmark: pop af  
bc69			endm  
# End of macro DMARK
bc69				CALLMONITOR 
bc69 cd 6f ee			call debug_vector  
bc6c				endm  
# End of macro CALLMONITOR
bc6c			endif	 
bc6c			 
bc6c			.nodashswap: 
bc6c			 
bc6c			if DEBUG_FORTH_DOT 
bc6c				DMARK "D-o" 
bc6c f5				push af  
bc6d 3a 81 bc			ld a, (.dmark)  
bc70 32 6b ee			ld (debug_mark),a  
bc73 3a 82 bc			ld a, (.dmark+1)  
bc76 32 6c ee			ld (debug_mark+1),a  
bc79 3a 83 bc			ld a, (.dmark+2)  
bc7c 32 6d ee			ld (debug_mark+2),a  
bc7f 18 03			jr .pastdmark  
bc81 ..			.dmark: db "D-o"  
bc84 f1			.pastdmark: pop af  
bc85			endm  
# End of macro DMARK
bc85				CALLMONITOR 
bc85 cd 6f ee			call debug_vector  
bc88				endm  
# End of macro CALLMONITOR
bc88			endif	 
bc88			 
bc88 d5					push de   ; save string start in case we need to advance print 
bc89			 
bc89 3a 5e ea				ld a, (f_cursor_ptr) 
bc8c cd c1 8a				call str_at_display 
bc8f 3a 3c ea				ld a,(cli_autodisplay) 
bc92 fe 00				cp 0 
bc94 28 03				jr z, .noupdate 
bc96 cd d1 8a						call update_display 
bc99					.noupdate: 
bc99			 
bc99			 
bc99					; see if we need to advance the print position 
bc99			 
bc99 e1					pop hl   ; get back string 
bc9a			;		ex de,hl 
bc9a			 
bc9a 3a 3d ea				ld a, (cli_mvdot) 
bc9d			if DEBUG_FORTH_DOT 
bc9d			;		ld e,a 
bc9d				DMARK "D>1" 
bc9d f5				push af  
bc9e 3a b2 bc			ld a, (.dmark)  
bca1 32 6b ee			ld (debug_mark),a  
bca4 3a b3 bc			ld a, (.dmark+1)  
bca7 32 6c ee			ld (debug_mark+1),a  
bcaa 3a b4 bc			ld a, (.dmark+2)  
bcad 32 6d ee			ld (debug_mark+2),a  
bcb0 18 03			jr .pastdmark  
bcb2 ..			.dmark: db "D>1"  
bcb5 f1			.pastdmark: pop af  
bcb6			endm  
# End of macro DMARK
bcb6				CALLMONITOR 
bcb6 cd 6f ee			call debug_vector  
bcb9				endm  
# End of macro CALLMONITOR
bcb9			endif	 
bcb9 fe 00				cp 0 
bcbb 28 44				jr z, .noadv 
bcbd					; yes, lets advance the print position 
bcbd 3e 00				ld a, 0 
bcbf cd 44 91				call strlent 
bcc2			if DEBUG_FORTH_DOT 
bcc2				DMARK "D-?" 
bcc2 f5				push af  
bcc3 3a d7 bc			ld a, (.dmark)  
bcc6 32 6b ee			ld (debug_mark),a  
bcc9 3a d8 bc			ld a, (.dmark+1)  
bccc 32 6c ee			ld (debug_mark+1),a  
bccf 3a d9 bc			ld a, (.dmark+2)  
bcd2 32 6d ee			ld (debug_mark+2),a  
bcd5 18 03			jr .pastdmark  
bcd7 ..			.dmark: db "D-?"  
bcda f1			.pastdmark: pop af  
bcdb			endm  
# End of macro DMARK
bcdb				CALLMONITOR 
bcdb cd 6f ee			call debug_vector  
bcde				endm  
# End of macro CALLMONITOR
bcde			endif	 
bcde 3a 5e ea				ld a, (f_cursor_ptr) 
bce1 85					add a,l 
bce2					;call addatohl 
bce2					;ld a, l 
bce2 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bce5			 
bce5			if DEBUG_FORTH_DOT 
bce5				DMARK "D->" 
bce5 f5				push af  
bce6 3a fa bc			ld a, (.dmark)  
bce9 32 6b ee			ld (debug_mark),a  
bcec 3a fb bc			ld a, (.dmark+1)  
bcef 32 6c ee			ld (debug_mark+1),a  
bcf2 3a fc bc			ld a, (.dmark+2)  
bcf5 32 6d ee			ld (debug_mark+2),a  
bcf8 18 03			jr .pastdmark  
bcfa ..			.dmark: db "D->"  
bcfd f1			.pastdmark: pop af  
bcfe			endm  
# End of macro DMARK
bcfe				CALLMONITOR 
bcfe cd 6f ee			call debug_vector  
bd01				endm  
# End of macro CALLMONITOR
bd01			endif	 
bd01			 
bd01			.noadv:	 
bd01			 
bd01					if DEBUG_FORTH_DOT_WAIT 
bd01							call next_page_prompt 
bd01					endif	 
bd01			; TODO this pop off the stack causes a crash. i dont know why 
bd01			 
bd01			 
bd01			if DEBUG_FORTH_DOT 
bd01				DMARK "DTh" 
bd01 f5				push af  
bd02 3a 16 bd			ld a, (.dmark)  
bd05 32 6b ee			ld (debug_mark),a  
bd08 3a 17 bd			ld a, (.dmark+1)  
bd0b 32 6c ee			ld (debug_mark+1),a  
bd0e 3a 18 bd			ld a, (.dmark+2)  
bd11 32 6d ee			ld (debug_mark+2),a  
bd14 18 03			jr .pastdmark  
bd16 ..			.dmark: db "DTh"  
bd19 f1			.pastdmark: pop af  
bd1a			endm  
# End of macro DMARK
bd1a				CALLMONITOR 
bd1a cd 6f ee			call debug_vector  
bd1d				endm  
# End of macro CALLMONITOR
bd1d			endif	 
bd1d			 
bd1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd1d cd ea 9d			call macro_forth_dsp_pop 
bd20				endm 
# End of macro FORTH_DSP_POP
bd20			 
bd20			if DEBUG_FORTH_DOT 
bd20				DMARK "DTi" 
bd20 f5				push af  
bd21 3a 35 bd			ld a, (.dmark)  
bd24 32 6b ee			ld (debug_mark),a  
bd27 3a 36 bd			ld a, (.dmark+1)  
bd2a 32 6c ee			ld (debug_mark+1),a  
bd2d 3a 37 bd			ld a, (.dmark+2)  
bd30 32 6d ee			ld (debug_mark+2),a  
bd33 18 03			jr .pastdmark  
bd35 ..			.dmark: db "DTi"  
bd38 f1			.pastdmark: pop af  
bd39			endm  
# End of macro DMARK
bd39				CALLMONITOR 
bd39 cd 6f ee			call debug_vector  
bd3c				endm  
# End of macro CALLMONITOR
bd3c			endif	 
bd3c			 
bd3c			 
bd3c					NEXTW 
bd3c c3 e8 9e			jp macro_next 
bd3f				endm 
# End of macro NEXTW
bd3f			 
bd3f			.CLS: 
bd3f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bd3f 35				db WORD_SYS_CORE+33             
bd40 6c bd			dw .DRAW            
bd42 04				db 3 + 1 
bd43 .. 00			db "CLS",0              
bd47				endm 
# End of macro CWHEAD
bd47			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bd47					if DEBUG_FORTH_WORDS_KEY 
bd47						DMARK "CLS" 
bd47 f5				push af  
bd48 3a 5c bd			ld a, (.dmark)  
bd4b 32 6b ee			ld (debug_mark),a  
bd4e 3a 5d bd			ld a, (.dmark+1)  
bd51 32 6c ee			ld (debug_mark+1),a  
bd54 3a 5e bd			ld a, (.dmark+2)  
bd57 32 6d ee			ld (debug_mark+2),a  
bd5a 18 03			jr .pastdmark  
bd5c ..			.dmark: db "CLS"  
bd5f f1			.pastdmark: pop af  
bd60			endm  
# End of macro DMARK
bd60						CALLMONITOR 
bd60 cd 6f ee			call debug_vector  
bd63				endm  
# End of macro CALLMONITOR
bd63					endif 
bd63 cd ae 8a				call clear_display 
bd66 c3 7a be				jp .home		; and home cursor 
bd69					NEXTW 
bd69 c3 e8 9e			jp macro_next 
bd6c				endm 
# End of macro NEXTW
bd6c			 
bd6c			.DRAW: 
bd6c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bd6c 36				db WORD_SYS_CORE+34             
bd6d 97 bd			dw .DUMP            
bd6f 05				db 4 + 1 
bd70 .. 00			db "DRAW",0              
bd75				endm 
# End of macro CWHEAD
bd75			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bd75					if DEBUG_FORTH_WORDS_KEY 
bd75						DMARK "DRW" 
bd75 f5				push af  
bd76 3a 8a bd			ld a, (.dmark)  
bd79 32 6b ee			ld (debug_mark),a  
bd7c 3a 8b bd			ld a, (.dmark+1)  
bd7f 32 6c ee			ld (debug_mark+1),a  
bd82 3a 8c bd			ld a, (.dmark+2)  
bd85 32 6d ee			ld (debug_mark+2),a  
bd88 18 03			jr .pastdmark  
bd8a ..			.dmark: db "DRW"  
bd8d f1			.pastdmark: pop af  
bd8e			endm  
# End of macro DMARK
bd8e						CALLMONITOR 
bd8e cd 6f ee			call debug_vector  
bd91				endm  
# End of macro CALLMONITOR
bd91					endif 
bd91 cd d1 8a				call update_display 
bd94					NEXTW 
bd94 c3 e8 9e			jp macro_next 
bd97				endm 
# End of macro NEXTW
bd97			 
bd97			.DUMP: 
bd97				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bd97 37				db WORD_SYS_CORE+35             
bd98 cf bd			dw .CDUMP            
bd9a 05				db 4 + 1 
bd9b .. 00			db "DUMP",0              
bda0				endm 
# End of macro CWHEAD
bda0			; | DUMP ( x -- ) With address x display dump   | DONE 
bda0			; TODO pop address to use off of the stack 
bda0					if DEBUG_FORTH_WORDS_KEY 
bda0						DMARK "DUM" 
bda0 f5				push af  
bda1 3a b5 bd			ld a, (.dmark)  
bda4 32 6b ee			ld (debug_mark),a  
bda7 3a b6 bd			ld a, (.dmark+1)  
bdaa 32 6c ee			ld (debug_mark+1),a  
bdad 3a b7 bd			ld a, (.dmark+2)  
bdb0 32 6d ee			ld (debug_mark+2),a  
bdb3 18 03			jr .pastdmark  
bdb5 ..			.dmark: db "DUM"  
bdb8 f1			.pastdmark: pop af  
bdb9			endm  
# End of macro DMARK
bdb9						CALLMONITOR 
bdb9 cd 6f ee			call debug_vector  
bdbc				endm  
# End of macro CALLMONITOR
bdbc					endif 
bdbc cd ae 8a				call clear_display 
bdbf			 
bdbf					; get address 
bdbf			 
bdbf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bdbf cd 32 9d			call macro_dsp_valuehl 
bdc2				endm 
# End of macro FORTH_DSP_VALUEHL
bdc2				 
bdc2					; save it for cdump 
bdc2			 
bdc2 22 e4 e5				ld (os_cur_ptr),hl 
bdc5			 
bdc5					; destroy value TOS 
bdc5			 
bdc5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdc5 cd ea 9d			call macro_forth_dsp_pop 
bdc8				endm 
# End of macro FORTH_DSP_POP
bdc8			 
bdc8 cd bb 99				call dumpcont	; skip old style of param parsing	 
bdcb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bdcc					NEXTW 
bdcc c3 e8 9e			jp macro_next 
bdcf				endm 
# End of macro NEXTW
bdcf			.CDUMP: 
bdcf				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bdcf 38				db WORD_SYS_CORE+36             
bdd0 ff bd			dw .DAT            
bdd2 06				db 5 + 1 
bdd3 .. 00			db "CDUMP",0              
bdd9				endm 
# End of macro CWHEAD
bdd9			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bdd9					if DEBUG_FORTH_WORDS_KEY 
bdd9						DMARK "CDP" 
bdd9 f5				push af  
bdda 3a ee bd			ld a, (.dmark)  
bddd 32 6b ee			ld (debug_mark),a  
bde0 3a ef bd			ld a, (.dmark+1)  
bde3 32 6c ee			ld (debug_mark+1),a  
bde6 3a f0 bd			ld a, (.dmark+2)  
bde9 32 6d ee			ld (debug_mark+2),a  
bdec 18 03			jr .pastdmark  
bdee ..			.dmark: db "CDP"  
bdf1 f1			.pastdmark: pop af  
bdf2			endm  
# End of macro DMARK
bdf2						CALLMONITOR 
bdf2 cd 6f ee			call debug_vector  
bdf5				endm  
# End of macro CALLMONITOR
bdf5					endif 
bdf5 cd ae 8a				call clear_display 
bdf8 cd bb 99				call dumpcont	 
bdfb c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bdfc					NEXTW 
bdfc c3 e8 9e			jp macro_next 
bdff				endm 
# End of macro NEXTW
bdff			 
bdff			 
bdff			 
bdff			 
bdff			.DAT: 
bdff				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bdff 3d				db WORD_SYS_CORE+41             
be00 55 be			dw .HOME            
be02 03				db 2 + 1 
be03 .. 00			db "AT",0              
be06				endm 
# End of macro CWHEAD
be06			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
be06					if DEBUG_FORTH_WORDS_KEY 
be06						DMARK "AT." 
be06 f5				push af  
be07 3a 1b be			ld a, (.dmark)  
be0a 32 6b ee			ld (debug_mark),a  
be0d 3a 1c be			ld a, (.dmark+1)  
be10 32 6c ee			ld (debug_mark+1),a  
be13 3a 1d be			ld a, (.dmark+2)  
be16 32 6d ee			ld (debug_mark+2),a  
be19 18 03			jr .pastdmark  
be1b ..			.dmark: db "AT."  
be1e f1			.pastdmark: pop af  
be1f			endm  
# End of macro DMARK
be1f						CALLMONITOR 
be1f cd 6f ee			call debug_vector  
be22				endm  
# End of macro CALLMONITOR
be22					endif 
be22					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be22 cd 32 9d			call macro_dsp_valuehl 
be25				endm 
# End of macro FORTH_DSP_VALUEHL
be25			 
be25			 
be25					; TODO save cursor row 
be25 7d					ld a,l 
be26 fe 02				cp 2 
be28 20 04				jr nz, .crow3 
be2a 3e 28				ld a, display_row_2 
be2c 18 12				jr .ccol1 
be2e fe 03		.crow3:		cp 3 
be30 20 04				jr nz, .crow4 
be32 3e 50				ld a, display_row_3 
be34 18 0a				jr .ccol1 
be36 fe 04		.crow4:		cp 4 
be38 20 04				jr nz, .crow1 
be3a 3e 78				ld a, display_row_4 
be3c 18 02				jr .ccol1 
be3e 3e 00		.crow1:		ld a,display_row_1 
be40 f5			.ccol1:		push af			; got row offset 
be41 6f					ld l,a 
be42 26 00				ld h,0 
be44					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be44 cd ea 9d			call macro_forth_dsp_pop 
be47				endm 
# End of macro FORTH_DSP_POP
be47					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be47 cd 32 9d			call macro_dsp_valuehl 
be4a				endm 
# End of macro FORTH_DSP_VALUEHL
be4a					; TODO save cursor col 
be4a f1					pop af 
be4b 85					add l		; add col offset 
be4c 32 5e ea				ld (f_cursor_ptr), a 
be4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be4f cd ea 9d			call macro_forth_dsp_pop 
be52				endm 
# End of macro FORTH_DSP_POP
be52			 
be52					; calculate  
be52			 
be52					NEXTW 
be52 c3 e8 9e			jp macro_next 
be55				endm 
# End of macro NEXTW
be55			 
be55			 
be55			.HOME: 
be55				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
be55 41				db WORD_SYS_CORE+45             
be56 82 be			dw .SPACE            
be58 05				db 4 + 1 
be59 .. 00			db "HOME",0              
be5e				endm 
# End of macro CWHEAD
be5e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
be5e					if DEBUG_FORTH_WORDS_KEY 
be5e						DMARK "HOM" 
be5e f5				push af  
be5f 3a 73 be			ld a, (.dmark)  
be62 32 6b ee			ld (debug_mark),a  
be65 3a 74 be			ld a, (.dmark+1)  
be68 32 6c ee			ld (debug_mark+1),a  
be6b 3a 75 be			ld a, (.dmark+2)  
be6e 32 6d ee			ld (debug_mark+2),a  
be71 18 03			jr .pastdmark  
be73 ..			.dmark: db "HOM"  
be76 f1			.pastdmark: pop af  
be77			endm  
# End of macro DMARK
be77						CALLMONITOR 
be77 cd 6f ee			call debug_vector  
be7a				endm  
# End of macro CALLMONITOR
be7a					endif 
be7a 3e 00		.home:		ld a, 0		; and home cursor 
be7c 32 5e ea				ld (f_cursor_ptr), a 
be7f					NEXTW 
be7f c3 e8 9e			jp macro_next 
be82				endm 
# End of macro NEXTW
be82			 
be82			 
be82			.SPACE: 
be82				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
be82 46				db WORD_SYS_CORE+50             
be83 b8 be			dw .SPACES            
be85 03				db 2 + 1 
be86 .. 00			db "BL",0              
be89				endm 
# End of macro CWHEAD
be89			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
be89					if DEBUG_FORTH_WORDS_KEY 
be89						DMARK "BL." 
be89 f5				push af  
be8a 3a 9e be			ld a, (.dmark)  
be8d 32 6b ee			ld (debug_mark),a  
be90 3a 9f be			ld a, (.dmark+1)  
be93 32 6c ee			ld (debug_mark+1),a  
be96 3a a0 be			ld a, (.dmark+2)  
be99 32 6d ee			ld (debug_mark+2),a  
be9c 18 03			jr .pastdmark  
be9e ..			.dmark: db "BL."  
bea1 f1			.pastdmark: pop af  
bea2			endm  
# End of macro DMARK
bea2						CALLMONITOR 
bea2 cd 6f ee			call debug_vector  
bea5				endm  
# End of macro CALLMONITOR
bea5					endif 
bea5 3e 20				ld a, " " 
bea7 32 c1 e2				ld (scratch),a 
beaa 3e 00				ld a, 0 
beac 32 c2 e2				ld (scratch+1),a 
beaf 21 c1 e2				ld hl, scratch 
beb2 cd a9 9b				call forth_push_str 
beb5					 
beb5				       NEXTW 
beb5 c3 e8 9e			jp macro_next 
beb8				endm 
# End of macro NEXTW
beb8			 
beb8			;.blstr: db " ", 0 
beb8			 
beb8			.SPACES: 
beb8				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
beb8 47				db WORD_SYS_CORE+51             
beb9 53 bf			dw .SCROLL            
bebb 07				db 6 + 1 
bebc .. 00			db "SPACES",0              
bec3				endm 
# End of macro CWHEAD
bec3			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
bec3					if DEBUG_FORTH_WORDS_KEY 
bec3						DMARK "SPS" 
bec3 f5				push af  
bec4 3a d8 be			ld a, (.dmark)  
bec7 32 6b ee			ld (debug_mark),a  
beca 3a d9 be			ld a, (.dmark+1)  
becd 32 6c ee			ld (debug_mark+1),a  
bed0 3a da be			ld a, (.dmark+2)  
bed3 32 6d ee			ld (debug_mark+2),a  
bed6 18 03			jr .pastdmark  
bed8 ..			.dmark: db "SPS"  
bedb f1			.pastdmark: pop af  
bedc			endm  
# End of macro DMARK
bedc						CALLMONITOR 
bedc cd 6f ee			call debug_vector  
bedf				endm  
# End of macro CALLMONITOR
bedf					endif 
bedf			 
bedf			 
bedf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bedf cd 32 9d			call macro_dsp_valuehl 
bee2				endm 
# End of macro FORTH_DSP_VALUEHL
bee2			 
bee2 e5					push hl    ; u 
bee3					if DEBUG_FORTH_WORDS 
bee3						DMARK "SPA" 
bee3 f5				push af  
bee4 3a f8 be			ld a, (.dmark)  
bee7 32 6b ee			ld (debug_mark),a  
beea 3a f9 be			ld a, (.dmark+1)  
beed 32 6c ee			ld (debug_mark+1),a  
bef0 3a fa be			ld a, (.dmark+2)  
bef3 32 6d ee			ld (debug_mark+2),a  
bef6 18 03			jr .pastdmark  
bef8 ..			.dmark: db "SPA"  
befb f1			.pastdmark: pop af  
befc			endm  
# End of macro DMARK
befc						CALLMONITOR 
befc cd 6f ee			call debug_vector  
beff				endm  
# End of macro CALLMONITOR
beff					endif 
beff			 
beff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
beff cd ea 9d			call macro_forth_dsp_pop 
bf02				endm 
# End of macro FORTH_DSP_POP
bf02 e1					pop hl 
bf03 0e 00				ld c, 0 
bf05 45					ld b, l 
bf06 21 c1 e2				ld hl, scratch  
bf09			 
bf09					if DEBUG_FORTH_WORDS 
bf09						DMARK "SP2" 
bf09 f5				push af  
bf0a 3a 1e bf			ld a, (.dmark)  
bf0d 32 6b ee			ld (debug_mark),a  
bf10 3a 1f bf			ld a, (.dmark+1)  
bf13 32 6c ee			ld (debug_mark+1),a  
bf16 3a 20 bf			ld a, (.dmark+2)  
bf19 32 6d ee			ld (debug_mark+2),a  
bf1c 18 03			jr .pastdmark  
bf1e ..			.dmark: db "SP2"  
bf21 f1			.pastdmark: pop af  
bf22			endm  
# End of macro DMARK
bf22						CALLMONITOR 
bf22 cd 6f ee			call debug_vector  
bf25				endm  
# End of macro CALLMONITOR
bf25					endif 
bf25 3e 20				ld a, ' ' 
bf27			.spaces1:	 
bf27 77					ld (hl),a 
bf28 23					inc hl 
bf29					 
bf29 10 fc				djnz .spaces1 
bf2b 3e 00				ld a,0 
bf2d 77					ld (hl),a 
bf2e 21 c1 e2				ld hl, scratch 
bf31					if DEBUG_FORTH_WORDS 
bf31						DMARK "SP3" 
bf31 f5				push af  
bf32 3a 46 bf			ld a, (.dmark)  
bf35 32 6b ee			ld (debug_mark),a  
bf38 3a 47 bf			ld a, (.dmark+1)  
bf3b 32 6c ee			ld (debug_mark+1),a  
bf3e 3a 48 bf			ld a, (.dmark+2)  
bf41 32 6d ee			ld (debug_mark+2),a  
bf44 18 03			jr .pastdmark  
bf46 ..			.dmark: db "SP3"  
bf49 f1			.pastdmark: pop af  
bf4a			endm  
# End of macro DMARK
bf4a						CALLMONITOR 
bf4a cd 6f ee			call debug_vector  
bf4d				endm  
# End of macro CALLMONITOR
bf4d					endif 
bf4d cd a9 9b				call forth_push_str 
bf50			 
bf50				       NEXTW 
bf50 c3 e8 9e			jp macro_next 
bf53				endm 
# End of macro NEXTW
bf53			 
bf53			 
bf53			 
bf53			.SCROLL: 
bf53				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bf53 53				db WORD_SYS_CORE+63             
bf54 80 bf			dw .SCROLLD            
bf56 07				db 6 + 1 
bf57 .. 00			db "SCROLL",0              
bf5e				endm 
# End of macro CWHEAD
bf5e			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bf5e					if DEBUG_FORTH_WORDS_KEY 
bf5e						DMARK "SCR" 
bf5e f5				push af  
bf5f 3a 73 bf			ld a, (.dmark)  
bf62 32 6b ee			ld (debug_mark),a  
bf65 3a 74 bf			ld a, (.dmark+1)  
bf68 32 6c ee			ld (debug_mark+1),a  
bf6b 3a 75 bf			ld a, (.dmark+2)  
bf6e 32 6d ee			ld (debug_mark+2),a  
bf71 18 03			jr .pastdmark  
bf73 ..			.dmark: db "SCR"  
bf76 f1			.pastdmark: pop af  
bf77			endm  
# End of macro DMARK
bf77						CALLMONITOR 
bf77 cd 6f ee			call debug_vector  
bf7a				endm  
# End of macro CALLMONITOR
bf7a					endif 
bf7a			 
bf7a cd 70 8a			call scroll_up 
bf7d			;	call update_display 
bf7d			 
bf7d					NEXTW 
bf7d c3 e8 9e			jp macro_next 
bf80				endm 
# End of macro NEXTW
bf80			 
bf80			 
bf80			 
bf80			;		; get dir 
bf80			; 
bf80			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf80			; 
bf80			;		push hl 
bf80			; 
bf80			;		; destroy value TOS 
bf80			; 
bf80			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf80			; 
bf80			;		; get count 
bf80			; 
bf80			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf80			; 
bf80			;		push hl 
bf80			; 
bf80			;		; destroy value TOS 
bf80			; 
bf80			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf80			; 
bf80			;		; one value on hl get other one back 
bf80			; 
bf80			;		pop bc    ; count 
bf80			; 
bf80			;		pop de   ; dir 
bf80			; 
bf80			; 
bf80			;		ld b, c 
bf80			; 
bf80			;.scrolldir:     push bc 
bf80			;		push de 
bf80			; 
bf80			;		ld a, 0 
bf80			;		cp e 
bf80			;		jr z, .scrollup  
bf80			;		call scroll_down 
bf80			;		jr .scrollnext 
bf80			;.scrollup:	call scroll_up 
bf80			; 
bf80			;		 
bf80			;.scrollnext: 
bf80			;		pop de 
bf80			;		pop bc 
bf80			;		djnz .scrolldir 
bf80			; 
bf80			; 
bf80			; 
bf80			; 
bf80			; 
bf80			;		NEXTW 
bf80			 
bf80			.SCROLLD: 
bf80				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bf80 53				db WORD_SYS_CORE+63             
bf81 ae bf			dw .ATQ            
bf83 08				db 7 + 1 
bf84 .. 00			db "SCROLLD",0              
bf8c				endm 
# End of macro CWHEAD
bf8c			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bf8c					if DEBUG_FORTH_WORDS_KEY 
bf8c						DMARK "SCD" 
bf8c f5				push af  
bf8d 3a a1 bf			ld a, (.dmark)  
bf90 32 6b ee			ld (debug_mark),a  
bf93 3a a2 bf			ld a, (.dmark+1)  
bf96 32 6c ee			ld (debug_mark+1),a  
bf99 3a a3 bf			ld a, (.dmark+2)  
bf9c 32 6d ee			ld (debug_mark+2),a  
bf9f 18 03			jr .pastdmark  
bfa1 ..			.dmark: db "SCD"  
bfa4 f1			.pastdmark: pop af  
bfa5			endm  
# End of macro DMARK
bfa5						CALLMONITOR 
bfa5 cd 6f ee			call debug_vector  
bfa8				endm  
# End of macro CALLMONITOR
bfa8					endif 
bfa8			 
bfa8 cd 94 8a			call scroll_down 
bfab			;	call update_display 
bfab			 
bfab					NEXTW 
bfab c3 e8 9e			jp macro_next 
bfae				endm 
# End of macro NEXTW
bfae			 
bfae			 
bfae			.ATQ: 
bfae				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bfae 62				db WORD_SYS_CORE+78             
bfaf 0c c0			dw .AUTODSP            
bfb1 04				db 3 + 1 
bfb2 .. 00			db "AT@",0              
bfb6				endm 
# End of macro CWHEAD
bfb6			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bfb6					if DEBUG_FORTH_WORDS_KEY 
bfb6						DMARK "ATA" 
bfb6 f5				push af  
bfb7 3a cb bf			ld a, (.dmark)  
bfba 32 6b ee			ld (debug_mark),a  
bfbd 3a cc bf			ld a, (.dmark+1)  
bfc0 32 6c ee			ld (debug_mark+1),a  
bfc3 3a cd bf			ld a, (.dmark+2)  
bfc6 32 6d ee			ld (debug_mark+2),a  
bfc9 18 03			jr .pastdmark  
bfcb ..			.dmark: db "ATA"  
bfce f1			.pastdmark: pop af  
bfcf			endm  
# End of macro DMARK
bfcf						CALLMONITOR 
bfcf cd 6f ee			call debug_vector  
bfd2				endm  
# End of macro CALLMONITOR
bfd2					endif 
bfd2			 
bfd2			 
bfd2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfd2 cd 32 9d			call macro_dsp_valuehl 
bfd5				endm 
# End of macro FORTH_DSP_VALUEHL
bfd5			 
bfd5					; TODO save cursor row 
bfd5 7d					ld a,l 
bfd6 fe 02				cp 2 
bfd8 20 04				jr nz, .crow3aq 
bfda 3e 28				ld a, display_row_2 
bfdc 18 12				jr .ccol1aq 
bfde fe 03		.crow3aq:		cp 3 
bfe0 20 04				jr nz, .crow4aq 
bfe2 3e 50				ld a, display_row_3 
bfe4 18 0a				jr .ccol1aq 
bfe6 fe 04		.crow4aq:		cp 4 
bfe8 20 04				jr nz, .crow1aq 
bfea 3e 78				ld a, display_row_4 
bfec 18 02				jr .ccol1aq 
bfee 3e 00		.crow1aq:		ld a,display_row_1 
bff0 f5			.ccol1aq:		push af			; got row offset 
bff1 6f					ld l,a 
bff2 26 00				ld h,0 
bff4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bff4 cd ea 9d			call macro_forth_dsp_pop 
bff7				endm 
# End of macro FORTH_DSP_POP
bff7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bff7 cd 32 9d			call macro_dsp_valuehl 
bffa				endm 
# End of macro FORTH_DSP_VALUEHL
bffa					; TODO save cursor col 
bffa f1					pop af 
bffb 85					add l		; add col offset 
bffc			 
bffc					; add current frame buffer address 
bffc 2a cc eb				ld hl, (display_fb_active) 
bfff cd db 8c				call addatohl 
c002			 
c002			 
c002			 
c002			 
c002					; get char frame buffer location offset in hl 
c002			 
c002 7e					ld a,(hl) 
c003 26 00				ld h, 0 
c005 6f					ld l, a 
c006			 
c006 cd 3b 9b				call forth_push_numhl 
c009			 
c009			 
c009					NEXTW 
c009 c3 e8 9e			jp macro_next 
c00c				endm 
# End of macro NEXTW
c00c			 
c00c			.AUTODSP: 
c00c				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
c00c 63				db WORD_SYS_CORE+79             
c00d 22 c0			dw .MENU            
c00f 05				db 4 + 1 
c010 .. 00			db "ADSP",0              
c015				endm 
# End of macro CWHEAD
c015			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
c015			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
c015			 
c015					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c015 cd 32 9d			call macro_dsp_valuehl 
c018				endm 
# End of macro FORTH_DSP_VALUEHL
c018			 
c018			;		push hl 
c018			 
c018					; destroy value TOS 
c018			 
c018					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c018 cd ea 9d			call macro_forth_dsp_pop 
c01b				endm 
# End of macro FORTH_DSP_POP
c01b			 
c01b			;		pop hl 
c01b			 
c01b 7d					ld a,l 
c01c 32 3c ea				ld (cli_autodisplay), a 
c01f				       NEXTW 
c01f c3 e8 9e			jp macro_next 
c022				endm 
# End of macro NEXTW
c022			 
c022			.MENU: 
c022				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
c022 70				db WORD_SYS_CORE+92             
c023 cb c0			dw .ENDDISPLAY            
c025 05				db 4 + 1 
c026 .. 00			db "MENU",0              
c02b				endm 
# End of macro CWHEAD
c02b			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
c02b			 
c02b			;		; get number of items on the stack 
c02b			; 
c02b				 
c02b					FORTH_DSP_VALUEHL 
c02b cd 32 9d			call macro_dsp_valuehl 
c02e				endm 
# End of macro FORTH_DSP_VALUEHL
c02e				 
c02e					if DEBUG_FORTH_WORDS_KEY 
c02e						DMARK "MNU" 
c02e f5				push af  
c02f 3a 43 c0			ld a, (.dmark)  
c032 32 6b ee			ld (debug_mark),a  
c035 3a 44 c0			ld a, (.dmark+1)  
c038 32 6c ee			ld (debug_mark+1),a  
c03b 3a 45 c0			ld a, (.dmark+2)  
c03e 32 6d ee			ld (debug_mark+2),a  
c041 18 03			jr .pastdmark  
c043 ..			.dmark: db "MNU"  
c046 f1			.pastdmark: pop af  
c047			endm  
# End of macro DMARK
c047						CALLMONITOR 
c047 cd 6f ee			call debug_vector  
c04a				endm  
# End of macro CALLMONITOR
c04a					endif 
c04a			 
c04a 45					ld b, l	 
c04b 05					dec b 
c04c			 
c04c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c04c cd ea 9d			call macro_forth_dsp_pop 
c04f				endm 
# End of macro FORTH_DSP_POP
c04f			 
c04f			 
c04f					; go directly through the stack to pluck out the string pointers and build an array 
c04f			 
c04f			;		FORTH_DSP 
c04f			 
c04f					; hl contains top most stack item 
c04f				 
c04f 11 c1 e2				ld de, scratch 
c052			 
c052			.mbuild: 
c052			 
c052					FORTH_DSP_VALUEHL 
c052 cd 32 9d			call macro_dsp_valuehl 
c055				endm 
# End of macro FORTH_DSP_VALUEHL
c055			 
c055					if DEBUG_FORTH_WORDS 
c055						DMARK "MN3" 
c055 f5				push af  
c056 3a 6a c0			ld a, (.dmark)  
c059 32 6b ee			ld (debug_mark),a  
c05c 3a 6b c0			ld a, (.dmark+1)  
c05f 32 6c ee			ld (debug_mark+1),a  
c062 3a 6c c0			ld a, (.dmark+2)  
c065 32 6d ee			ld (debug_mark+2),a  
c068 18 03			jr .pastdmark  
c06a ..			.dmark: db "MN3"  
c06d f1			.pastdmark: pop af  
c06e			endm  
# End of macro DMARK
c06e						CALLMONITOR 
c06e cd 6f ee			call debug_vector  
c071				endm  
# End of macro CALLMONITOR
c071					endif 
c071 eb					ex de, hl 
c072 73					ld (hl), e 
c073 23					inc hl 
c074 72					ld (hl), d 
c075 23					inc hl 
c076 eb					ex de, hl 
c077			 
c077					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c077 cd ea 9d			call macro_forth_dsp_pop 
c07a				endm 
# End of macro FORTH_DSP_POP
c07a			 
c07a 10 d6				djnz .mbuild 
c07c			 
c07c					; done add term 
c07c			 
c07c eb					ex de, hl 
c07d 36 00				ld (hl), 0 
c07f 23					inc hl 
c080 36 00				ld (hl), 0 
c082			 
c082				 
c082					 
c082 21 c1 e2				ld hl, scratch 
c085			 
c085					if DEBUG_FORTH_WORDS 
c085						DMARK "MNx" 
c085 f5				push af  
c086 3a 9a c0			ld a, (.dmark)  
c089 32 6b ee			ld (debug_mark),a  
c08c 3a 9b c0			ld a, (.dmark+1)  
c08f 32 6c ee			ld (debug_mark+1),a  
c092 3a 9c c0			ld a, (.dmark+2)  
c095 32 6d ee			ld (debug_mark+2),a  
c098 18 03			jr .pastdmark  
c09a ..			.dmark: db "MNx"  
c09d f1			.pastdmark: pop af  
c09e			endm  
# End of macro DMARK
c09e						CALLMONITOR 
c09e cd 6f ee			call debug_vector  
c0a1				endm  
# End of macro CALLMONITOR
c0a1					endif 
c0a1			 
c0a1			 
c0a1			 
c0a1 3e 00				ld a, 0 
c0a3 cd df 8a				call menu 
c0a6			 
c0a6			 
c0a6 6f					ld l, a 
c0a7 26 00				ld h, 0 
c0a9			 
c0a9					if DEBUG_FORTH_WORDS 
c0a9						DMARK "MNr" 
c0a9 f5				push af  
c0aa 3a be c0			ld a, (.dmark)  
c0ad 32 6b ee			ld (debug_mark),a  
c0b0 3a bf c0			ld a, (.dmark+1)  
c0b3 32 6c ee			ld (debug_mark+1),a  
c0b6 3a c0 c0			ld a, (.dmark+2)  
c0b9 32 6d ee			ld (debug_mark+2),a  
c0bc 18 03			jr .pastdmark  
c0be ..			.dmark: db "MNr"  
c0c1 f1			.pastdmark: pop af  
c0c2			endm  
# End of macro DMARK
c0c2						CALLMONITOR 
c0c2 cd 6f ee			call debug_vector  
c0c5				endm  
# End of macro CALLMONITOR
c0c5					endif 
c0c5			 
c0c5 cd 3b 9b				call forth_push_numhl 
c0c8			 
c0c8			 
c0c8			 
c0c8			 
c0c8				       NEXTW 
c0c8 c3 e8 9e			jp macro_next 
c0cb				endm 
# End of macro NEXTW
c0cb			 
c0cb			 
c0cb			.ENDDISPLAY: 
c0cb			 
c0cb			; eof 
# End of file forth_words_display.asm
c0cb			include "forth_words_str.asm" 
c0cb			 
c0cb			; | ## String Words 
c0cb			 
c0cb			.PTR:   
c0cb			 
c0cb				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c0cb 48				db WORD_SYS_CORE+52             
c0cc f8 c0			dw .STYPE            
c0ce 04				db 3 + 1 
c0cf .. 00			db "PTR",0              
c0d3				endm 
# End of macro CWHEAD
c0d3			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c0d3			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c0d3			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c0d3			 
c0d3					if DEBUG_FORTH_WORDS_KEY 
c0d3						DMARK "PTR" 
c0d3 f5				push af  
c0d4 3a e8 c0			ld a, (.dmark)  
c0d7 32 6b ee			ld (debug_mark),a  
c0da 3a e9 c0			ld a, (.dmark+1)  
c0dd 32 6c ee			ld (debug_mark+1),a  
c0e0 3a ea c0			ld a, (.dmark+2)  
c0e3 32 6d ee			ld (debug_mark+2),a  
c0e6 18 03			jr .pastdmark  
c0e8 ..			.dmark: db "PTR"  
c0eb f1			.pastdmark: pop af  
c0ec			endm  
# End of macro DMARK
c0ec						CALLMONITOR 
c0ec cd 6f ee			call debug_vector  
c0ef				endm  
# End of macro CALLMONITOR
c0ef					endif 
c0ef					FORTH_DSP_VALUEHL 
c0ef cd 32 9d			call macro_dsp_valuehl 
c0f2				endm 
# End of macro FORTH_DSP_VALUEHL
c0f2 cd 3b 9b				call forth_push_numhl 
c0f5			 
c0f5			 
c0f5					NEXTW 
c0f5 c3 e8 9e			jp macro_next 
c0f8				endm 
# End of macro NEXTW
c0f8			.STYPE: 
c0f8				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c0f8 48				db WORD_SYS_CORE+52             
c0f9 47 c1			dw .UPPER            
c0fb 06				db 5 + 1 
c0fc .. 00			db "STYPE",0              
c102				endm 
# End of macro CWHEAD
c102			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c102					if DEBUG_FORTH_WORDS_KEY 
c102						DMARK "STY" 
c102 f5				push af  
c103 3a 17 c1			ld a, (.dmark)  
c106 32 6b ee			ld (debug_mark),a  
c109 3a 18 c1			ld a, (.dmark+1)  
c10c 32 6c ee			ld (debug_mark+1),a  
c10f 3a 19 c1			ld a, (.dmark+2)  
c112 32 6d ee			ld (debug_mark+2),a  
c115 18 03			jr .pastdmark  
c117 ..			.dmark: db "STY"  
c11a f1			.pastdmark: pop af  
c11b			endm  
# End of macro DMARK
c11b						CALLMONITOR 
c11b cd 6f ee			call debug_vector  
c11e				endm  
# End of macro CALLMONITOR
c11e					endif 
c11e					FORTH_DSP 
c11e cd f8 9c			call macro_forth_dsp 
c121				endm 
# End of macro FORTH_DSP
c121					;v5 FORTH_DSP_VALUE 
c121			 
c121 7e					ld a, (hl) 
c122			 
c122 f5					push af 
c123			 
c123			; Dont destroy TOS		FORTH_DSP_POP 
c123			 
c123 f1					pop af 
c124			 
c124 fe 01				cp DS_TYPE_STR 
c126 28 09				jr z, .typestr 
c128			 
c128 fe 02				cp DS_TYPE_INUM 
c12a 28 0a				jr z, .typeinum 
c12c			 
c12c 21 45 c1				ld hl, .tna 
c12f 18 0a				jr .tpush 
c131			 
c131 21 41 c1		.typestr:	ld hl, .tstr 
c134 18 05				jr .tpush 
c136 21 43 c1		.typeinum:	ld hl, .tinum 
c139 18 00				jr .tpush 
c13b			 
c13b			.tpush: 
c13b			 
c13b cd a9 9b				call forth_push_str 
c13e			 
c13e					NEXTW 
c13e c3 e8 9e			jp macro_next 
c141				endm 
# End of macro NEXTW
c141 .. 00		.tstr:	db "s",0 
c143 .. 00		.tinum:  db "i",0 
c145 .. 00		.tna:   db "?", 0 
c147			 
c147			 
c147			.UPPER: 
c147				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c147 48				db WORD_SYS_CORE+52             
c148 82 c1			dw .LOWER            
c14a 06				db 5 + 1 
c14b .. 00			db "UPPER",0              
c151				endm 
# End of macro CWHEAD
c151			; | UPPER ( s -- s ) Upper case string s  | DONE 
c151					if DEBUG_FORTH_WORDS_KEY 
c151						DMARK "UPR" 
c151 f5				push af  
c152 3a 66 c1			ld a, (.dmark)  
c155 32 6b ee			ld (debug_mark),a  
c158 3a 67 c1			ld a, (.dmark+1)  
c15b 32 6c ee			ld (debug_mark+1),a  
c15e 3a 68 c1			ld a, (.dmark+2)  
c161 32 6d ee			ld (debug_mark+2),a  
c164 18 03			jr .pastdmark  
c166 ..			.dmark: db "UPR"  
c169 f1			.pastdmark: pop af  
c16a			endm  
# End of macro DMARK
c16a						CALLMONITOR 
c16a cd 6f ee			call debug_vector  
c16d				endm  
# End of macro CALLMONITOR
c16d					endif 
c16d			 
c16d					FORTH_DSP 
c16d cd f8 9c			call macro_forth_dsp 
c170				endm 
# End of macro FORTH_DSP
c170					 
c170			; TODO check is string type 
c170			 
c170					FORTH_DSP_VALUEHL 
c170 cd 32 9d			call macro_dsp_valuehl 
c173				endm 
# End of macro FORTH_DSP_VALUEHL
c173			; get pointer to string in hl 
c173			 
c173 7e			.toup:		ld a, (hl) 
c174 fe 00				cp 0 
c176 28 07				jr z, .toupdone 
c178			 
c178 cd 48 90				call to_upper 
c17b			 
c17b 77					ld (hl), a 
c17c 23					inc hl 
c17d 18 f4				jr .toup 
c17f			 
c17f					 
c17f			 
c17f			 
c17f			; for each char convert to upper 
c17f					 
c17f			.toupdone: 
c17f			 
c17f			 
c17f					NEXTW 
c17f c3 e8 9e			jp macro_next 
c182				endm 
# End of macro NEXTW
c182			.LOWER: 
c182				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c182 48				db WORD_SYS_CORE+52             
c183 bd c1			dw .TCASE            
c185 06				db 5 + 1 
c186 .. 00			db "LOWER",0              
c18c				endm 
# End of macro CWHEAD
c18c			; | LOWER ( s -- s ) Lower case string s  | DONE 
c18c					if DEBUG_FORTH_WORDS_KEY 
c18c						DMARK "LWR" 
c18c f5				push af  
c18d 3a a1 c1			ld a, (.dmark)  
c190 32 6b ee			ld (debug_mark),a  
c193 3a a2 c1			ld a, (.dmark+1)  
c196 32 6c ee			ld (debug_mark+1),a  
c199 3a a3 c1			ld a, (.dmark+2)  
c19c 32 6d ee			ld (debug_mark+2),a  
c19f 18 03			jr .pastdmark  
c1a1 ..			.dmark: db "LWR"  
c1a4 f1			.pastdmark: pop af  
c1a5			endm  
# End of macro DMARK
c1a5						CALLMONITOR 
c1a5 cd 6f ee			call debug_vector  
c1a8				endm  
# End of macro CALLMONITOR
c1a8					endif 
c1a8			 
c1a8					FORTH_DSP 
c1a8 cd f8 9c			call macro_forth_dsp 
c1ab				endm 
# End of macro FORTH_DSP
c1ab					 
c1ab			; TODO check is string type 
c1ab			 
c1ab					FORTH_DSP_VALUEHL 
c1ab cd 32 9d			call macro_dsp_valuehl 
c1ae				endm 
# End of macro FORTH_DSP_VALUEHL
c1ae			; get pointer to string in hl 
c1ae			 
c1ae 7e			.tolow:		ld a, (hl) 
c1af fe 00				cp 0 
c1b1 28 07				jr z, .tolowdone 
c1b3			 
c1b3 cd 51 90				call to_lower 
c1b6			 
c1b6 77					ld (hl), a 
c1b7 23					inc hl 
c1b8 18 f4				jr .tolow 
c1ba			 
c1ba					 
c1ba			 
c1ba			 
c1ba			; for each char convert to low 
c1ba					 
c1ba			.tolowdone: 
c1ba					NEXTW 
c1ba c3 e8 9e			jp macro_next 
c1bd				endm 
# End of macro NEXTW
c1bd			.TCASE: 
c1bd				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c1bd 48				db WORD_SYS_CORE+52             
c1be f3 c2			dw .SUBSTR            
c1c0 06				db 5 + 1 
c1c1 .. 00			db "TCASE",0              
c1c7				endm 
# End of macro CWHEAD
c1c7			; | TCASE ( s -- s ) Title case string s  | DONE 
c1c7					if DEBUG_FORTH_WORDS_KEY 
c1c7						DMARK "TCS" 
c1c7 f5				push af  
c1c8 3a dc c1			ld a, (.dmark)  
c1cb 32 6b ee			ld (debug_mark),a  
c1ce 3a dd c1			ld a, (.dmark+1)  
c1d1 32 6c ee			ld (debug_mark+1),a  
c1d4 3a de c1			ld a, (.dmark+2)  
c1d7 32 6d ee			ld (debug_mark+2),a  
c1da 18 03			jr .pastdmark  
c1dc ..			.dmark: db "TCS"  
c1df f1			.pastdmark: pop af  
c1e0			endm  
# End of macro DMARK
c1e0						CALLMONITOR 
c1e0 cd 6f ee			call debug_vector  
c1e3				endm  
# End of macro CALLMONITOR
c1e3					endif 
c1e3			 
c1e3					FORTH_DSP 
c1e3 cd f8 9c			call macro_forth_dsp 
c1e6				endm 
# End of macro FORTH_DSP
c1e6					 
c1e6			; TODO check is string type 
c1e6			 
c1e6					FORTH_DSP_VALUEHL 
c1e6 cd 32 9d			call macro_dsp_valuehl 
c1e9				endm 
# End of macro FORTH_DSP_VALUEHL
c1e9			; get pointer to string in hl 
c1e9			 
c1e9					if DEBUG_FORTH_WORDS 
c1e9						DMARK "TC1" 
c1e9 f5				push af  
c1ea 3a fe c1			ld a, (.dmark)  
c1ed 32 6b ee			ld (debug_mark),a  
c1f0 3a ff c1			ld a, (.dmark+1)  
c1f3 32 6c ee			ld (debug_mark+1),a  
c1f6 3a 00 c2			ld a, (.dmark+2)  
c1f9 32 6d ee			ld (debug_mark+2),a  
c1fc 18 03			jr .pastdmark  
c1fe ..			.dmark: db "TC1"  
c201 f1			.pastdmark: pop af  
c202			endm  
# End of macro DMARK
c202						CALLMONITOR 
c202 cd 6f ee			call debug_vector  
c205				endm  
# End of macro CALLMONITOR
c205					endif 
c205			 
c205					; first time in turn to upper case first char 
c205			 
c205 7e					ld a, (hl) 
c206 c3 90 c2				jp .totsiptou 
c209			 
c209			 
c209 7e			.tot:		ld a, (hl) 
c20a fe 00				cp 0 
c20c ca d4 c2				jp z, .totdone 
c20f			 
c20f					if DEBUG_FORTH_WORDS 
c20f						DMARK "TC2" 
c20f f5				push af  
c210 3a 24 c2			ld a, (.dmark)  
c213 32 6b ee			ld (debug_mark),a  
c216 3a 25 c2			ld a, (.dmark+1)  
c219 32 6c ee			ld (debug_mark+1),a  
c21c 3a 26 c2			ld a, (.dmark+2)  
c21f 32 6d ee			ld (debug_mark+2),a  
c222 18 03			jr .pastdmark  
c224 ..			.dmark: db "TC2"  
c227 f1			.pastdmark: pop af  
c228			endm  
# End of macro DMARK
c228						CALLMONITOR 
c228 cd 6f ee			call debug_vector  
c22b				endm  
# End of macro CALLMONITOR
c22b					endif 
c22b					; check to see if current char is a space 
c22b			 
c22b fe 20				cp ' ' 
c22d 28 21				jr z, .totsp 
c22f cd 51 90				call to_lower 
c232					if DEBUG_FORTH_WORDS 
c232						DMARK "TC3" 
c232 f5				push af  
c233 3a 47 c2			ld a, (.dmark)  
c236 32 6b ee			ld (debug_mark),a  
c239 3a 48 c2			ld a, (.dmark+1)  
c23c 32 6c ee			ld (debug_mark+1),a  
c23f 3a 49 c2			ld a, (.dmark+2)  
c242 32 6d ee			ld (debug_mark+2),a  
c245 18 03			jr .pastdmark  
c247 ..			.dmark: db "TC3"  
c24a f1			.pastdmark: pop af  
c24b			endm  
# End of macro DMARK
c24b						CALLMONITOR 
c24b cd 6f ee			call debug_vector  
c24e				endm  
# End of macro CALLMONITOR
c24e					endif 
c24e 18 63				jr .totnxt 
c250			 
c250			.totsp:         ; on a space, find next char which should be upper 
c250			 
c250					if DEBUG_FORTH_WORDS 
c250						DMARK "TC4" 
c250 f5				push af  
c251 3a 65 c2			ld a, (.dmark)  
c254 32 6b ee			ld (debug_mark),a  
c257 3a 66 c2			ld a, (.dmark+1)  
c25a 32 6c ee			ld (debug_mark+1),a  
c25d 3a 67 c2			ld a, (.dmark+2)  
c260 32 6d ee			ld (debug_mark+2),a  
c263 18 03			jr .pastdmark  
c265 ..			.dmark: db "TC4"  
c268 f1			.pastdmark: pop af  
c269			endm  
# End of macro DMARK
c269						CALLMONITOR 
c269 cd 6f ee			call debug_vector  
c26c				endm  
# End of macro CALLMONITOR
c26c					endif 
c26c					;; 
c26c			 
c26c fe 20				cp ' ' 
c26e 20 20				jr nz, .totsiptou 
c270 23					inc hl 
c271 7e					ld a, (hl) 
c272					if DEBUG_FORTH_WORDS 
c272						DMARK "TC5" 
c272 f5				push af  
c273 3a 87 c2			ld a, (.dmark)  
c276 32 6b ee			ld (debug_mark),a  
c279 3a 88 c2			ld a, (.dmark+1)  
c27c 32 6c ee			ld (debug_mark+1),a  
c27f 3a 89 c2			ld a, (.dmark+2)  
c282 32 6d ee			ld (debug_mark+2),a  
c285 18 03			jr .pastdmark  
c287 ..			.dmark: db "TC5"  
c28a f1			.pastdmark: pop af  
c28b			endm  
# End of macro DMARK
c28b						CALLMONITOR 
c28b cd 6f ee			call debug_vector  
c28e				endm  
# End of macro CALLMONITOR
c28e					endif 
c28e 18 c0				jr .totsp 
c290 fe 00		.totsiptou:    cp 0 
c292 28 40				jr z, .totdone 
c294					; not space and not zero term so upper case it 
c294 cd 48 90				call to_upper 
c297			 
c297					if DEBUG_FORTH_WORDS 
c297						DMARK "TC6" 
c297 f5				push af  
c298 3a ac c2			ld a, (.dmark)  
c29b 32 6b ee			ld (debug_mark),a  
c29e 3a ad c2			ld a, (.dmark+1)  
c2a1 32 6c ee			ld (debug_mark+1),a  
c2a4 3a ae c2			ld a, (.dmark+2)  
c2a7 32 6d ee			ld (debug_mark+2),a  
c2aa 18 03			jr .pastdmark  
c2ac ..			.dmark: db "TC6"  
c2af f1			.pastdmark: pop af  
c2b0			endm  
# End of macro DMARK
c2b0						CALLMONITOR 
c2b0 cd 6f ee			call debug_vector  
c2b3				endm  
# End of macro CALLMONITOR
c2b3					endif 
c2b3			 
c2b3			 
c2b3			.totnxt: 
c2b3			 
c2b3 77					ld (hl), a 
c2b4 23					inc hl 
c2b5					if DEBUG_FORTH_WORDS 
c2b5						DMARK "TC7" 
c2b5 f5				push af  
c2b6 3a ca c2			ld a, (.dmark)  
c2b9 32 6b ee			ld (debug_mark),a  
c2bc 3a cb c2			ld a, (.dmark+1)  
c2bf 32 6c ee			ld (debug_mark+1),a  
c2c2 3a cc c2			ld a, (.dmark+2)  
c2c5 32 6d ee			ld (debug_mark+2),a  
c2c8 18 03			jr .pastdmark  
c2ca ..			.dmark: db "TC7"  
c2cd f1			.pastdmark: pop af  
c2ce			endm  
# End of macro DMARK
c2ce						CALLMONITOR 
c2ce cd 6f ee			call debug_vector  
c2d1				endm  
# End of macro CALLMONITOR
c2d1					endif 
c2d1 c3 09 c2				jp .tot 
c2d4			 
c2d4					 
c2d4			 
c2d4			 
c2d4			; for each char convert to low 
c2d4					 
c2d4			.totdone: 
c2d4					if DEBUG_FORTH_WORDS 
c2d4						DMARK "TCd" 
c2d4 f5				push af  
c2d5 3a e9 c2			ld a, (.dmark)  
c2d8 32 6b ee			ld (debug_mark),a  
c2db 3a ea c2			ld a, (.dmark+1)  
c2de 32 6c ee			ld (debug_mark+1),a  
c2e1 3a eb c2			ld a, (.dmark+2)  
c2e4 32 6d ee			ld (debug_mark+2),a  
c2e7 18 03			jr .pastdmark  
c2e9 ..			.dmark: db "TCd"  
c2ec f1			.pastdmark: pop af  
c2ed			endm  
# End of macro DMARK
c2ed						CALLMONITOR 
c2ed cd 6f ee			call debug_vector  
c2f0				endm  
# End of macro CALLMONITOR
c2f0					endif 
c2f0					NEXTW 
c2f0 c3 e8 9e			jp macro_next 
c2f3				endm 
# End of macro NEXTW
c2f3			 
c2f3			.SUBSTR: 
c2f3				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c2f3 48				db WORD_SYS_CORE+52             
c2f4 51 c3			dw .LEFT            
c2f6 07				db 6 + 1 
c2f7 .. 00			db "SUBSTR",0              
c2fe				endm 
# End of macro CWHEAD
c2fe			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c2fe			 
c2fe					if DEBUG_FORTH_WORDS_KEY 
c2fe						DMARK "SST" 
c2fe f5				push af  
c2ff 3a 13 c3			ld a, (.dmark)  
c302 32 6b ee			ld (debug_mark),a  
c305 3a 14 c3			ld a, (.dmark+1)  
c308 32 6c ee			ld (debug_mark+1),a  
c30b 3a 15 c3			ld a, (.dmark+2)  
c30e 32 6d ee			ld (debug_mark+2),a  
c311 18 03			jr .pastdmark  
c313 ..			.dmark: db "SST"  
c316 f1			.pastdmark: pop af  
c317			endm  
# End of macro DMARK
c317						CALLMONITOR 
c317 cd 6f ee			call debug_vector  
c31a				endm  
# End of macro CALLMONITOR
c31a					endif 
c31a			; TODO check string type 
c31a					FORTH_DSP_VALUEHL 
c31a cd 32 9d			call macro_dsp_valuehl 
c31d				endm 
# End of macro FORTH_DSP_VALUEHL
c31d			 
c31d e5					push hl      ; string length 
c31e			 
c31e					FORTH_DSP_POP 
c31e cd ea 9d			call macro_forth_dsp_pop 
c321				endm 
# End of macro FORTH_DSP_POP
c321			 
c321					FORTH_DSP_VALUEHL 
c321 cd 32 9d			call macro_dsp_valuehl 
c324				endm 
# End of macro FORTH_DSP_VALUEHL
c324			 
c324 e5					push hl     ; start char 
c325			 
c325					FORTH_DSP_POP 
c325 cd ea 9d			call macro_forth_dsp_pop 
c328				endm 
# End of macro FORTH_DSP_POP
c328			 
c328			 
c328					FORTH_DSP_VALUE 
c328 cd 1b 9d			call macro_forth_dsp_value 
c32b				endm 
# End of macro FORTH_DSP_VALUE
c32b			 
c32b d1					pop de    ; get start post offset 
c32c			 
c32c 19					add hl, de    ; starting offset 
c32d			 
c32d c1					pop bc 
c32e c5					push bc      ; grab size of string 
c32f			 
c32f e5					push hl    ; save string start  
c330			 
c330 26 00				ld h, 0 
c332 69					ld l, c 
c333 23					inc hl 
c334 23					inc hl 
c335			 
c335 cd a2 91				call malloc 
c338				if DEBUG_FORTH_MALLOC_GUARD 
c338 cc 6b cc				call z,malloc_error 
c33b				endif 
c33b			 
c33b eb					ex de, hl      ; save malloc area for string copy 
c33c e1					pop hl    ; get back source 
c33d c1					pop bc    ; get length of string back 
c33e			 
c33e d5					push de    ; save malloc area for after we push 
c33f ed b0				ldir     ; copy substr 
c341			 
c341			 
c341 eb					ex de, hl 
c342 3e 00				ld a, 0 
c344 77					ld (hl), a   ; term substr 
c345			 
c345					 
c345 e1					pop hl    ; get malloc so we can push it 
c346 e5					push hl   ; save so we can free it afterwards 
c347			 
c347 cd a9 9b				call forth_push_str 
c34a			 
c34a e1					pop hl 
c34b cd 6c 92				call free 
c34e			 
c34e					 
c34e					 
c34e			 
c34e			 
c34e					NEXTW 
c34e c3 e8 9e			jp macro_next 
c351				endm 
# End of macro NEXTW
c351			 
c351			.LEFT: 
c351				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c351 48				db WORD_SYS_CORE+52             
c352 79 c3			dw .RIGHT            
c354 05				db 4 + 1 
c355 .. 00			db "LEFT",0              
c35a				endm 
# End of macro CWHEAD
c35a			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c35a					if DEBUG_FORTH_WORDS_KEY 
c35a						DMARK "LEF" 
c35a f5				push af  
c35b 3a 6f c3			ld a, (.dmark)  
c35e 32 6b ee			ld (debug_mark),a  
c361 3a 70 c3			ld a, (.dmark+1)  
c364 32 6c ee			ld (debug_mark+1),a  
c367 3a 71 c3			ld a, (.dmark+2)  
c36a 32 6d ee			ld (debug_mark+2),a  
c36d 18 03			jr .pastdmark  
c36f ..			.dmark: db "LEF"  
c372 f1			.pastdmark: pop af  
c373			endm  
# End of macro DMARK
c373						CALLMONITOR 
c373 cd 6f ee			call debug_vector  
c376				endm  
# End of macro CALLMONITOR
c376					endif 
c376			 
c376					NEXTW 
c376 c3 e8 9e			jp macro_next 
c379				endm 
# End of macro NEXTW
c379			.RIGHT: 
c379				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c379 48				db WORD_SYS_CORE+52             
c37a a2 c3			dw .STR2NUM            
c37c 06				db 5 + 1 
c37d .. 00			db "RIGHT",0              
c383				endm 
# End of macro CWHEAD
c383			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c383					if DEBUG_FORTH_WORDS_KEY 
c383						DMARK "RIG" 
c383 f5				push af  
c384 3a 98 c3			ld a, (.dmark)  
c387 32 6b ee			ld (debug_mark),a  
c38a 3a 99 c3			ld a, (.dmark+1)  
c38d 32 6c ee			ld (debug_mark+1),a  
c390 3a 9a c3			ld a, (.dmark+2)  
c393 32 6d ee			ld (debug_mark+2),a  
c396 18 03			jr .pastdmark  
c398 ..			.dmark: db "RIG"  
c39b f1			.pastdmark: pop af  
c39c			endm  
# End of macro DMARK
c39c						CALLMONITOR 
c39c cd 6f ee			call debug_vector  
c39f				endm  
# End of macro CALLMONITOR
c39f					endif 
c39f			 
c39f					NEXTW 
c39f c3 e8 9e			jp macro_next 
c3a2				endm 
# End of macro NEXTW
c3a2			 
c3a2			 
c3a2			.STR2NUM: 
c3a2				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c3a2 48				db WORD_SYS_CORE+52             
c3a3 2e c4			dw .NUM2STR            
c3a5 08				db 7 + 1 
c3a6 .. 00			db "STR2NUM",0              
c3ae				endm 
# End of macro CWHEAD
c3ae			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c3ae			 
c3ae			 
c3ae			; TODO STR type check to do 
c3ae					if DEBUG_FORTH_WORDS_KEY 
c3ae						DMARK "S2N" 
c3ae f5				push af  
c3af 3a c3 c3			ld a, (.dmark)  
c3b2 32 6b ee			ld (debug_mark),a  
c3b5 3a c4 c3			ld a, (.dmark+1)  
c3b8 32 6c ee			ld (debug_mark+1),a  
c3bb 3a c5 c3			ld a, (.dmark+2)  
c3be 32 6d ee			ld (debug_mark+2),a  
c3c1 18 03			jr .pastdmark  
c3c3 ..			.dmark: db "S2N"  
c3c6 f1			.pastdmark: pop af  
c3c7			endm  
# End of macro DMARK
c3c7						CALLMONITOR 
c3c7 cd 6f ee			call debug_vector  
c3ca				endm  
# End of macro CALLMONITOR
c3ca					endif 
c3ca			 
c3ca					;FORTH_DSP 
c3ca					FORTH_DSP_VALUE 
c3ca cd 1b 9d			call macro_forth_dsp_value 
c3cd				endm 
# End of macro FORTH_DSP_VALUE
c3cd					;inc hl 
c3cd			 
c3cd eb					ex de, hl 
c3ce					if DEBUG_FORTH_WORDS 
c3ce						DMARK "S2a" 
c3ce f5				push af  
c3cf 3a e3 c3			ld a, (.dmark)  
c3d2 32 6b ee			ld (debug_mark),a  
c3d5 3a e4 c3			ld a, (.dmark+1)  
c3d8 32 6c ee			ld (debug_mark+1),a  
c3db 3a e5 c3			ld a, (.dmark+2)  
c3de 32 6d ee			ld (debug_mark+2),a  
c3e1 18 03			jr .pastdmark  
c3e3 ..			.dmark: db "S2a"  
c3e6 f1			.pastdmark: pop af  
c3e7			endm  
# End of macro DMARK
c3e7						CALLMONITOR 
c3e7 cd 6f ee			call debug_vector  
c3ea				endm  
# End of macro CALLMONITOR
c3ea					endif 
c3ea cd d0 90				call string_to_uint16 
c3ed			 
c3ed					if DEBUG_FORTH_WORDS 
c3ed						DMARK "S2b" 
c3ed f5				push af  
c3ee 3a 02 c4			ld a, (.dmark)  
c3f1 32 6b ee			ld (debug_mark),a  
c3f4 3a 03 c4			ld a, (.dmark+1)  
c3f7 32 6c ee			ld (debug_mark+1),a  
c3fa 3a 04 c4			ld a, (.dmark+2)  
c3fd 32 6d ee			ld (debug_mark+2),a  
c400 18 03			jr .pastdmark  
c402 ..			.dmark: db "S2b"  
c405 f1			.pastdmark: pop af  
c406			endm  
# End of macro DMARK
c406						CALLMONITOR 
c406 cd 6f ee			call debug_vector  
c409				endm  
# End of macro CALLMONITOR
c409					endif 
c409			;		push hl 
c409					FORTH_DSP_POP 
c409 cd ea 9d			call macro_forth_dsp_pop 
c40c				endm 
# End of macro FORTH_DSP_POP
c40c			;		pop hl 
c40c					 
c40c					if DEBUG_FORTH_WORDS 
c40c						DMARK "S2b" 
c40c f5				push af  
c40d 3a 21 c4			ld a, (.dmark)  
c410 32 6b ee			ld (debug_mark),a  
c413 3a 22 c4			ld a, (.dmark+1)  
c416 32 6c ee			ld (debug_mark+1),a  
c419 3a 23 c4			ld a, (.dmark+2)  
c41c 32 6d ee			ld (debug_mark+2),a  
c41f 18 03			jr .pastdmark  
c421 ..			.dmark: db "S2b"  
c424 f1			.pastdmark: pop af  
c425			endm  
# End of macro DMARK
c425						CALLMONITOR 
c425 cd 6f ee			call debug_vector  
c428				endm  
# End of macro CALLMONITOR
c428					endif 
c428 cd 3b 9b				call forth_push_numhl	 
c42b			 
c42b				 
c42b				       NEXTW 
c42b c3 e8 9e			jp macro_next 
c42e				endm 
# End of macro NEXTW
c42e			.NUM2STR: 
c42e				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c42e 48				db WORD_SYS_CORE+52             
c42f 3d c4			dw .CONCAT            
c431 08				db 7 + 1 
c432 .. 00			db "NUM2STR",0              
c43a				endm 
# End of macro CWHEAD
c43a			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c43a			 
c43a			;		; malloc a string to target 
c43a			;		ld hl, 10     ; TODO max string size should be fine 
c43a			;		call malloc 
c43a			;		push hl    ; save malloc location 
c43a			; 
c43a			; 
c43a			;; TODO check int type 
c43a			;		FORTH_DSP_VALUEHL 
c43a			;		ld a, l 
c43a			;		call DispAToASCII   
c43a			;;TODO need to chage above call to dump into string 
c43a			; 
c43a			; 
c43a			 
c43a				       NEXTW 
c43a c3 e8 9e			jp macro_next 
c43d				endm 
# End of macro NEXTW
c43d			 
c43d			.CONCAT: 
c43d				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c43d 48				db WORD_SYS_CORE+52             
c43e f0 c4			dw .FIND            
c440 07				db 6 + 1 
c441 .. 00			db "CONCAT",0              
c448				endm 
# End of macro CWHEAD
c448			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c448			 
c448			; TODO check string type 
c448			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c448			 
c448					if DEBUG_FORTH_WORDS_KEY 
c448						DMARK "CON" 
c448 f5				push af  
c449 3a 5d c4			ld a, (.dmark)  
c44c 32 6b ee			ld (debug_mark),a  
c44f 3a 5e c4			ld a, (.dmark+1)  
c452 32 6c ee			ld (debug_mark+1),a  
c455 3a 5f c4			ld a, (.dmark+2)  
c458 32 6d ee			ld (debug_mark+2),a  
c45b 18 03			jr .pastdmark  
c45d ..			.dmark: db "CON"  
c460 f1			.pastdmark: pop af  
c461			endm  
# End of macro DMARK
c461						CALLMONITOR 
c461 cd 6f ee			call debug_vector  
c464				endm  
# End of macro CALLMONITOR
c464					endif 
c464			 
c464			 
c464					FORTH_DSP_VALUE 
c464 cd 1b 9d			call macro_forth_dsp_value 
c467				endm 
# End of macro FORTH_DSP_VALUE
c467 e5					push hl   ; s2 
c468			 
c468					FORTH_DSP_POP 
c468 cd ea 9d			call macro_forth_dsp_pop 
c46b				endm 
# End of macro FORTH_DSP_POP
c46b			 
c46b					FORTH_DSP_VALUE 
c46b cd 1b 9d			call macro_forth_dsp_value 
c46e				endm 
# End of macro FORTH_DSP_VALUE
c46e			 
c46e e5					push hl   ; s1 
c46f			 
c46f					FORTH_DSP_POP 
c46f cd ea 9d			call macro_forth_dsp_pop 
c472				endm 
# End of macro FORTH_DSP_POP
c472					 
c472			 
c472					; copy s1 
c472			 
c472				 
c472					; save ptr 
c472 e1					pop hl  
c473 e5					push hl 
c474 3e 00				ld a, 0 
c476 cd 44 91				call strlent 
c479					;inc hl    ; zer0 
c479 06 00				ld b, 0 
c47b 4d					ld c, l 
c47c e1					pop hl		 
c47d 11 c1 e2				ld de, scratch	 
c480					if DEBUG_FORTH_WORDS 
c480						DMARK "CO1" 
c480 f5				push af  
c481 3a 95 c4			ld a, (.dmark)  
c484 32 6b ee			ld (debug_mark),a  
c487 3a 96 c4			ld a, (.dmark+1)  
c48a 32 6c ee			ld (debug_mark+1),a  
c48d 3a 97 c4			ld a, (.dmark+2)  
c490 32 6d ee			ld (debug_mark+2),a  
c493 18 03			jr .pastdmark  
c495 ..			.dmark: db "CO1"  
c498 f1			.pastdmark: pop af  
c499			endm  
# End of macro DMARK
c499						CALLMONITOR 
c499 cd 6f ee			call debug_vector  
c49c				endm  
# End of macro CALLMONITOR
c49c					endif 
c49c ed b0				ldir 
c49e			 
c49e e1					pop hl 
c49f e5					push hl 
c4a0 d5					push de 
c4a1			 
c4a1			 
c4a1 3e 00				ld a, 0 
c4a3 cd 44 91				call strlent 
c4a6 23					inc hl    ; zer0 
c4a7 23					inc hl 
c4a8 06 00				ld b, 0 
c4aa 4d					ld c, l 
c4ab d1					pop de 
c4ac e1					pop hl		 
c4ad					if DEBUG_FORTH_WORDS 
c4ad						DMARK "CO2" 
c4ad f5				push af  
c4ae 3a c2 c4			ld a, (.dmark)  
c4b1 32 6b ee			ld (debug_mark),a  
c4b4 3a c3 c4			ld a, (.dmark+1)  
c4b7 32 6c ee			ld (debug_mark+1),a  
c4ba 3a c4 c4			ld a, (.dmark+2)  
c4bd 32 6d ee			ld (debug_mark+2),a  
c4c0 18 03			jr .pastdmark  
c4c2 ..			.dmark: db "CO2"  
c4c5 f1			.pastdmark: pop af  
c4c6			endm  
# End of macro DMARK
c4c6						CALLMONITOR 
c4c6 cd 6f ee			call debug_vector  
c4c9				endm  
# End of macro CALLMONITOR
c4c9					endif 
c4c9 ed b0				ldir 
c4cb			 
c4cb			 
c4cb			 
c4cb 21 c1 e2				ld hl, scratch 
c4ce					if DEBUG_FORTH_WORDS 
c4ce						DMARK "CO5" 
c4ce f5				push af  
c4cf 3a e3 c4			ld a, (.dmark)  
c4d2 32 6b ee			ld (debug_mark),a  
c4d5 3a e4 c4			ld a, (.dmark+1)  
c4d8 32 6c ee			ld (debug_mark+1),a  
c4db 3a e5 c4			ld a, (.dmark+2)  
c4de 32 6d ee			ld (debug_mark+2),a  
c4e1 18 03			jr .pastdmark  
c4e3 ..			.dmark: db "CO5"  
c4e6 f1			.pastdmark: pop af  
c4e7			endm  
# End of macro DMARK
c4e7						CALLMONITOR 
c4e7 cd 6f ee			call debug_vector  
c4ea				endm  
# End of macro CALLMONITOR
c4ea					endif 
c4ea			 
c4ea cd a9 9b				call forth_push_str 
c4ed			 
c4ed			 
c4ed			 
c4ed			 
c4ed				       NEXTW 
c4ed c3 e8 9e			jp macro_next 
c4f0				endm 
# End of macro NEXTW
c4f0			 
c4f0			 
c4f0			.FIND: 
c4f0				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c4f0 4b				db WORD_SYS_CORE+55             
c4f1 ae c5			dw .LEN            
c4f3 05				db 4 + 1 
c4f4 .. 00			db "FIND",0              
c4f9				endm 
# End of macro CWHEAD
c4f9			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c4f9			 
c4f9					if DEBUG_FORTH_WORDS_KEY 
c4f9						DMARK "FND" 
c4f9 f5				push af  
c4fa 3a 0e c5			ld a, (.dmark)  
c4fd 32 6b ee			ld (debug_mark),a  
c500 3a 0f c5			ld a, (.dmark+1)  
c503 32 6c ee			ld (debug_mark+1),a  
c506 3a 10 c5			ld a, (.dmark+2)  
c509 32 6d ee			ld (debug_mark+2),a  
c50c 18 03			jr .pastdmark  
c50e ..			.dmark: db "FND"  
c511 f1			.pastdmark: pop af  
c512			endm  
# End of macro DMARK
c512						CALLMONITOR 
c512 cd 6f ee			call debug_vector  
c515				endm  
# End of macro CALLMONITOR
c515					endif 
c515			 
c515			; TODO check string type 
c515					FORTH_DSP_VALUE 
c515 cd 1b 9d			call macro_forth_dsp_value 
c518				endm 
# End of macro FORTH_DSP_VALUE
c518			 
c518 e5					push hl    
c519 7e					ld a,(hl)    ; char to find   
c51a			; TODO change char to substr 
c51a			 
c51a f5					push af 
c51b					 
c51b			 
c51b			 
c51b					if DEBUG_FORTH_WORDS 
c51b						DMARK "FN1" 
c51b f5				push af  
c51c 3a 30 c5			ld a, (.dmark)  
c51f 32 6b ee			ld (debug_mark),a  
c522 3a 31 c5			ld a, (.dmark+1)  
c525 32 6c ee			ld (debug_mark+1),a  
c528 3a 32 c5			ld a, (.dmark+2)  
c52b 32 6d ee			ld (debug_mark+2),a  
c52e 18 03			jr .pastdmark  
c530 ..			.dmark: db "FN1"  
c533 f1			.pastdmark: pop af  
c534			endm  
# End of macro DMARK
c534						CALLMONITOR 
c534 cd 6f ee			call debug_vector  
c537				endm  
# End of macro CALLMONITOR
c537					endif 
c537			 
c537					FORTH_DSP_POP 
c537 cd ea 9d			call macro_forth_dsp_pop 
c53a				endm 
# End of macro FORTH_DSP_POP
c53a			 
c53a					; string to search 
c53a			 
c53a					FORTH_DSP_VALUE 
c53a cd 1b 9d			call macro_forth_dsp_value 
c53d				endm 
# End of macro FORTH_DSP_VALUE
c53d			 
c53d d1					pop de  ; d is char to find  
c53e			 
c53e					if DEBUG_FORTH_WORDS 
c53e						DMARK "FN2" 
c53e f5				push af  
c53f 3a 53 c5			ld a, (.dmark)  
c542 32 6b ee			ld (debug_mark),a  
c545 3a 54 c5			ld a, (.dmark+1)  
c548 32 6c ee			ld (debug_mark+1),a  
c54b 3a 55 c5			ld a, (.dmark+2)  
c54e 32 6d ee			ld (debug_mark+2),a  
c551 18 03			jr .pastdmark  
c553 ..			.dmark: db "FN2"  
c556 f1			.pastdmark: pop af  
c557			endm  
# End of macro DMARK
c557						CALLMONITOR 
c557 cd 6f ee			call debug_vector  
c55a				endm  
# End of macro CALLMONITOR
c55a					endif 
c55a					 
c55a 01 00 00				ld bc, 0 
c55d 7e			.findchar:      ld a,(hl) 
c55e fe 00				cp 0   		 
c560 28 27				jr z, .finddone     
c562 ba					cp d 
c563 28 20				jr z, .foundchar 
c565 03					inc bc 
c566 23					inc hl 
c567					if DEBUG_FORTH_WORDS 
c567						DMARK "FN3" 
c567 f5				push af  
c568 3a 7c c5			ld a, (.dmark)  
c56b 32 6b ee			ld (debug_mark),a  
c56e 3a 7d c5			ld a, (.dmark+1)  
c571 32 6c ee			ld (debug_mark+1),a  
c574 3a 7e c5			ld a, (.dmark+2)  
c577 32 6d ee			ld (debug_mark+2),a  
c57a 18 03			jr .pastdmark  
c57c ..			.dmark: db "FN3"  
c57f f1			.pastdmark: pop af  
c580			endm  
# End of macro DMARK
c580						CALLMONITOR 
c580 cd 6f ee			call debug_vector  
c583				endm  
# End of macro CALLMONITOR
c583					endif 
c583 18 d8				jr .findchar 
c585			 
c585			 
c585 c5			.foundchar:	push bc 
c586 e1					pop hl 
c587 18 03				jr .findexit 
c589			 
c589			 
c589							 
c589			 
c589			.finddone:     ; got to end of string with no find 
c589 21 00 00				ld hl, 0 
c58c			.findexit: 
c58c			 
c58c					if DEBUG_FORTH_WORDS 
c58c						DMARK "FNd" 
c58c f5				push af  
c58d 3a a1 c5			ld a, (.dmark)  
c590 32 6b ee			ld (debug_mark),a  
c593 3a a2 c5			ld a, (.dmark+1)  
c596 32 6c ee			ld (debug_mark+1),a  
c599 3a a3 c5			ld a, (.dmark+2)  
c59c 32 6d ee			ld (debug_mark+2),a  
c59f 18 03			jr .pastdmark  
c5a1 ..			.dmark: db "FNd"  
c5a4 f1			.pastdmark: pop af  
c5a5			endm  
# End of macro DMARK
c5a5						CALLMONITOR 
c5a5 cd 6f ee			call debug_vector  
c5a8				endm  
# End of macro CALLMONITOR
c5a8					endif 
c5a8 cd 3b 9b			call forth_push_numhl 
c5ab			 
c5ab				       NEXTW 
c5ab c3 e8 9e			jp macro_next 
c5ae				endm 
# End of macro NEXTW
c5ae			 
c5ae			.LEN: 
c5ae				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c5ae 4c				db WORD_SYS_CORE+56             
c5af 18 c6			dw .ASC            
c5b1 06				db 5 + 1 
c5b2 .. 00			db "COUNT",0              
c5b8				endm 
# End of macro CWHEAD
c5b8			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c5b8			 
c5b8					if DEBUG_FORTH_WORDS_KEY 
c5b8						DMARK "CNT" 
c5b8 f5				push af  
c5b9 3a cd c5			ld a, (.dmark)  
c5bc 32 6b ee			ld (debug_mark),a  
c5bf 3a ce c5			ld a, (.dmark+1)  
c5c2 32 6c ee			ld (debug_mark+1),a  
c5c5 3a cf c5			ld a, (.dmark+2)  
c5c8 32 6d ee			ld (debug_mark+2),a  
c5cb 18 03			jr .pastdmark  
c5cd ..			.dmark: db "CNT"  
c5d0 f1			.pastdmark: pop af  
c5d1			endm  
# End of macro DMARK
c5d1						CALLMONITOR 
c5d1 cd 6f ee			call debug_vector  
c5d4				endm  
# End of macro CALLMONITOR
c5d4					endif 
c5d4			; TODO check string type 
c5d4					FORTH_DSP_VALUE 
c5d4 cd 1b 9d			call macro_forth_dsp_value 
c5d7				endm 
# End of macro FORTH_DSP_VALUE
c5d7			 
c5d7			 
c5d7					if DEBUG_FORTH_WORDS 
c5d7						DMARK "CN?" 
c5d7 f5				push af  
c5d8 3a ec c5			ld a, (.dmark)  
c5db 32 6b ee			ld (debug_mark),a  
c5de 3a ed c5			ld a, (.dmark+1)  
c5e1 32 6c ee			ld (debug_mark+1),a  
c5e4 3a ee c5			ld a, (.dmark+2)  
c5e7 32 6d ee			ld (debug_mark+2),a  
c5ea 18 03			jr .pastdmark  
c5ec ..			.dmark: db "CN?"  
c5ef f1			.pastdmark: pop af  
c5f0			endm  
# End of macro DMARK
c5f0						CALLMONITOR 
c5f0 cd 6f ee			call debug_vector  
c5f3				endm  
# End of macro CALLMONITOR
c5f3					endif 
c5f3 cd 39 91				call strlenz 
c5f6					if DEBUG_FORTH_WORDS 
c5f6						DMARK "CNl" 
c5f6 f5				push af  
c5f7 3a 0b c6			ld a, (.dmark)  
c5fa 32 6b ee			ld (debug_mark),a  
c5fd 3a 0c c6			ld a, (.dmark+1)  
c600 32 6c ee			ld (debug_mark+1),a  
c603 3a 0d c6			ld a, (.dmark+2)  
c606 32 6d ee			ld (debug_mark+2),a  
c609 18 03			jr .pastdmark  
c60b ..			.dmark: db "CNl"  
c60e f1			.pastdmark: pop af  
c60f			endm  
# End of macro DMARK
c60f						CALLMONITOR 
c60f cd 6f ee			call debug_vector  
c612				endm  
# End of macro CALLMONITOR
c612					endif 
c612			 
c612 cd 3b 9b				call forth_push_numhl 
c615			 
c615			 
c615			 
c615				       NEXTW 
c615 c3 e8 9e			jp macro_next 
c618				endm 
# End of macro NEXTW
c618			.ASC: 
c618				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c618 4d				db WORD_SYS_CORE+57             
c619 86 c6			dw .CHR            
c61b 04				db 3 + 1 
c61c .. 00			db "ASC",0              
c620				endm 
# End of macro CWHEAD
c620			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c620					if DEBUG_FORTH_WORDS_KEY 
c620						DMARK "ASC" 
c620 f5				push af  
c621 3a 35 c6			ld a, (.dmark)  
c624 32 6b ee			ld (debug_mark),a  
c627 3a 36 c6			ld a, (.dmark+1)  
c62a 32 6c ee			ld (debug_mark+1),a  
c62d 3a 37 c6			ld a, (.dmark+2)  
c630 32 6d ee			ld (debug_mark+2),a  
c633 18 03			jr .pastdmark  
c635 ..			.dmark: db "ASC"  
c638 f1			.pastdmark: pop af  
c639			endm  
# End of macro DMARK
c639						CALLMONITOR 
c639 cd 6f ee			call debug_vector  
c63c				endm  
# End of macro CALLMONITOR
c63c					endif 
c63c					FORTH_DSP_VALUE 
c63c cd 1b 9d			call macro_forth_dsp_value 
c63f				endm 
# End of macro FORTH_DSP_VALUE
c63f					;v5 FORTH_DSP_VALUE 
c63f			;		inc hl      ; now at start of numeric as string 
c63f			 
c63f e5					push hl 
c640			 
c640					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c640 cd ea 9d			call macro_forth_dsp_pop 
c643				endm 
# End of macro FORTH_DSP_POP
c643			 
c643 e1					pop hl 
c644			 
c644					if DEBUG_FORTH_WORDS 
c644						DMARK "AS1" 
c644 f5				push af  
c645 3a 59 c6			ld a, (.dmark)  
c648 32 6b ee			ld (debug_mark),a  
c64b 3a 5a c6			ld a, (.dmark+1)  
c64e 32 6c ee			ld (debug_mark+1),a  
c651 3a 5b c6			ld a, (.dmark+2)  
c654 32 6d ee			ld (debug_mark+2),a  
c657 18 03			jr .pastdmark  
c659 ..			.dmark: db "AS1"  
c65c f1			.pastdmark: pop af  
c65d			endm  
# End of macro DMARK
c65d						CALLMONITOR 
c65d cd 6f ee			call debug_vector  
c660				endm  
# End of macro CALLMONITOR
c660					endif 
c660					; push the content of a onto the stack as a value 
c660			 
c660 7e					ld a,(hl)   ; get char 
c661 26 00				ld h,0 
c663 6f					ld l,a 
c664					if DEBUG_FORTH_WORDS 
c664						DMARK "AS2" 
c664 f5				push af  
c665 3a 79 c6			ld a, (.dmark)  
c668 32 6b ee			ld (debug_mark),a  
c66b 3a 7a c6			ld a, (.dmark+1)  
c66e 32 6c ee			ld (debug_mark+1),a  
c671 3a 7b c6			ld a, (.dmark+2)  
c674 32 6d ee			ld (debug_mark+2),a  
c677 18 03			jr .pastdmark  
c679 ..			.dmark: db "AS2"  
c67c f1			.pastdmark: pop af  
c67d			endm  
# End of macro DMARK
c67d						CALLMONITOR 
c67d cd 6f ee			call debug_vector  
c680				endm  
# End of macro CALLMONITOR
c680					endif 
c680 cd 3b 9b				call forth_push_numhl 
c683			 
c683				       NEXTW 
c683 c3 e8 9e			jp macro_next 
c686				endm 
# End of macro NEXTW
c686			 
c686			.CHR: 
c686				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c686 4d				db WORD_SYS_CORE+57             
c687 c2 c6			dw .ENDSTR            
c689 04				db 3 + 1 
c68a .. 00			db "CHR",0              
c68e				endm 
# End of macro CWHEAD
c68e			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c68e					if DEBUG_FORTH_WORDS_KEY 
c68e						DMARK "CHR" 
c68e f5				push af  
c68f 3a a3 c6			ld a, (.dmark)  
c692 32 6b ee			ld (debug_mark),a  
c695 3a a4 c6			ld a, (.dmark+1)  
c698 32 6c ee			ld (debug_mark+1),a  
c69b 3a a5 c6			ld a, (.dmark+2)  
c69e 32 6d ee			ld (debug_mark+2),a  
c6a1 18 03			jr .pastdmark  
c6a3 ..			.dmark: db "CHR"  
c6a6 f1			.pastdmark: pop af  
c6a7			endm  
# End of macro DMARK
c6a7						CALLMONITOR 
c6a7 cd 6f ee			call debug_vector  
c6aa				endm  
# End of macro CALLMONITOR
c6aa					endif 
c6aa					FORTH_DSP_VALUEHL 
c6aa cd 32 9d			call macro_dsp_valuehl 
c6ad				endm 
# End of macro FORTH_DSP_VALUEHL
c6ad			 
c6ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c6ad cd ea 9d			call macro_forth_dsp_pop 
c6b0				endm 
# End of macro FORTH_DSP_POP
c6b0			 
c6b0					; save asci byte as a zero term string and push string 
c6b0			 
c6b0 7d					ld a,l 
c6b1 32 c1 e2				ld (scratch), a 
c6b4			 
c6b4 3e 00				ld a, 0 
c6b6 32 c2 e2				ld (scratch+1), a 
c6b9			 
c6b9 21 c1 e2				ld hl, scratch 
c6bc cd a9 9b				call forth_push_str 
c6bf			 
c6bf			 
c6bf				       NEXTW 
c6bf c3 e8 9e			jp macro_next 
c6c2				endm 
# End of macro NEXTW
c6c2			 
c6c2			 
c6c2			 
c6c2			 
c6c2			.ENDSTR: 
c6c2			; eof 
c6c2			 
# End of file forth_words_str.asm
c6c2			include "forth_words_key.asm" 
c6c2			 
c6c2			; | ## Keyboard Words 
c6c2			 
c6c2			.KEY: 
c6c2				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c6c2 3e				db WORD_SYS_CORE+42             
c6c3 f2 c6			dw .WAITK            
c6c5 04				db 3 + 1 
c6c6 .. 00			db "KEY",0              
c6ca				endm 
# End of macro CWHEAD
c6ca			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c6ca			 
c6ca					if DEBUG_FORTH_WORDS_KEY 
c6ca						DMARK "KEY" 
c6ca f5				push af  
c6cb 3a df c6			ld a, (.dmark)  
c6ce 32 6b ee			ld (debug_mark),a  
c6d1 3a e0 c6			ld a, (.dmark+1)  
c6d4 32 6c ee			ld (debug_mark+1),a  
c6d7 3a e1 c6			ld a, (.dmark+2)  
c6da 32 6d ee			ld (debug_mark+2),a  
c6dd 18 03			jr .pastdmark  
c6df ..			.dmark: db "KEY"  
c6e2 f1			.pastdmark: pop af  
c6e3			endm  
# End of macro DMARK
c6e3						CALLMONITOR 
c6e3 cd 6f ee			call debug_vector  
c6e6				endm  
# End of macro CALLMONITOR
c6e6					endif 
c6e6			; TODO currently waits 
c6e6 cd 62 e4				call cin 
c6e9					;call cin_wait 
c6e9 6f					ld l, a 
c6ea 26 00				ld h, 0 
c6ec cd 3b 9b				call forth_push_numhl 
c6ef					NEXTW 
c6ef c3 e8 9e			jp macro_next 
c6f2				endm 
# End of macro NEXTW
c6f2			.WAITK: 
c6f2				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c6f2 3f				db WORD_SYS_CORE+43             
c6f3 24 c7			dw .ACCEPT            
c6f5 06				db 5 + 1 
c6f6 .. 00			db "WAITK",0              
c6fc				endm 
# End of macro CWHEAD
c6fc			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c6fc					if DEBUG_FORTH_WORDS_KEY 
c6fc						DMARK "WAI" 
c6fc f5				push af  
c6fd 3a 11 c7			ld a, (.dmark)  
c700 32 6b ee			ld (debug_mark),a  
c703 3a 12 c7			ld a, (.dmark+1)  
c706 32 6c ee			ld (debug_mark+1),a  
c709 3a 13 c7			ld a, (.dmark+2)  
c70c 32 6d ee			ld (debug_mark+2),a  
c70f 18 03			jr .pastdmark  
c711 ..			.dmark: db "WAI"  
c714 f1			.pastdmark: pop af  
c715			endm  
# End of macro DMARK
c715						CALLMONITOR 
c715 cd 6f ee			call debug_vector  
c718				endm  
# End of macro CALLMONITOR
c718					endif 
c718 cd 5c e4				call cin_wait 
c71b 6f					ld l, a 
c71c 26 00				ld h, 0 
c71e cd 3b 9b				call forth_push_numhl 
c721					NEXTW 
c721 c3 e8 9e			jp macro_next 
c724				endm 
# End of macro NEXTW
c724			.ACCEPT: 
c724				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c724 40				db WORD_SYS_CORE+44             
c725 82 c7			dw .EDIT            
c727 07				db 6 + 1 
c728 .. 00			db "ACCEPT",0              
c72f				endm 
# End of macro CWHEAD
c72f			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c72f					; TODO crashes on push 
c72f					if DEBUG_FORTH_WORDS_KEY 
c72f						DMARK "ACC" 
c72f f5				push af  
c730 3a 44 c7			ld a, (.dmark)  
c733 32 6b ee			ld (debug_mark),a  
c736 3a 45 c7			ld a, (.dmark+1)  
c739 32 6c ee			ld (debug_mark+1),a  
c73c 3a 46 c7			ld a, (.dmark+2)  
c73f 32 6d ee			ld (debug_mark+2),a  
c742 18 03			jr .pastdmark  
c744 ..			.dmark: db "ACC"  
c747 f1			.pastdmark: pop af  
c748			endm  
# End of macro DMARK
c748						CALLMONITOR 
c748 cd 6f ee			call debug_vector  
c74b				endm  
# End of macro CALLMONITOR
c74b					endif 
c74b 21 bf e4				ld hl, os_input 
c74e 3e 00				ld a, 0 
c750 77					ld (hl),a 
c751 3a 5e ea				ld a,(f_cursor_ptr) 
c754 16 64				ld d, 100 
c756 0e 00				ld c, 0 
c758 1e 28				ld e, 40 
c75a cd 08 8d				call input_str 
c75d					; TODO perhaps do a type check and wrap in quotes if not a number 
c75d 21 bf e4				ld hl, os_input 
c760					if DEBUG_FORTH_WORDS 
c760						DMARK "AC1" 
c760 f5				push af  
c761 3a 75 c7			ld a, (.dmark)  
c764 32 6b ee			ld (debug_mark),a  
c767 3a 76 c7			ld a, (.dmark+1)  
c76a 32 6c ee			ld (debug_mark+1),a  
c76d 3a 77 c7			ld a, (.dmark+2)  
c770 32 6d ee			ld (debug_mark+2),a  
c773 18 03			jr .pastdmark  
c775 ..			.dmark: db "AC1"  
c778 f1			.pastdmark: pop af  
c779			endm  
# End of macro DMARK
c779						CALLMONITOR 
c779 cd 6f ee			call debug_vector  
c77c				endm  
# End of macro CALLMONITOR
c77c					endif 
c77c cd a9 9b				call forth_push_str 
c77f					NEXTW 
c77f c3 e8 9e			jp macro_next 
c782				endm 
# End of macro NEXTW
c782			 
c782			.EDIT: 
c782				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c782 40				db WORD_SYS_CORE+44             
c783 24 c8			dw .DEDIT            
c785 05				db 4 + 1 
c786 .. 00			db "EDIT",0              
c78b				endm 
# End of macro CWHEAD
c78b			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c78b			 
c78b					; TODO does not copy from stack 
c78b					if DEBUG_FORTH_WORDS_KEY 
c78b						DMARK "EDT" 
c78b f5				push af  
c78c 3a a0 c7			ld a, (.dmark)  
c78f 32 6b ee			ld (debug_mark),a  
c792 3a a1 c7			ld a, (.dmark+1)  
c795 32 6c ee			ld (debug_mark+1),a  
c798 3a a2 c7			ld a, (.dmark+2)  
c79b 32 6d ee			ld (debug_mark+2),a  
c79e 18 03			jr .pastdmark  
c7a0 ..			.dmark: db "EDT"  
c7a3 f1			.pastdmark: pop af  
c7a4			endm  
# End of macro DMARK
c7a4						CALLMONITOR 
c7a4 cd 6f ee			call debug_vector  
c7a7				endm  
# End of macro CALLMONITOR
c7a7					endif 
c7a7			 
c7a7					;FORTH_DSP 
c7a7					FORTH_DSP_VALUEHL 
c7a7 cd 32 9d			call macro_dsp_valuehl 
c7aa				endm 
# End of macro FORTH_DSP_VALUEHL
c7aa			;		inc hl    ; TODO do type check 
c7aa			 
c7aa			;		call get_word_hl 
c7aa e5					push hl 
c7ab					if DEBUG_FORTH_WORDS 
c7ab						DMARK "EDp" 
c7ab f5				push af  
c7ac 3a c0 c7			ld a, (.dmark)  
c7af 32 6b ee			ld (debug_mark),a  
c7b2 3a c1 c7			ld a, (.dmark+1)  
c7b5 32 6c ee			ld (debug_mark+1),a  
c7b8 3a c2 c7			ld a, (.dmark+2)  
c7bb 32 6d ee			ld (debug_mark+2),a  
c7be 18 03			jr .pastdmark  
c7c0 ..			.dmark: db "EDp"  
c7c3 f1			.pastdmark: pop af  
c7c4			endm  
# End of macro DMARK
c7c4						CALLMONITOR 
c7c4 cd 6f ee			call debug_vector  
c7c7				endm  
# End of macro CALLMONITOR
c7c7					endif 
c7c7				;	ld a, 0 
c7c7 cd 39 91				call strlenz 
c7ca 23					inc hl 
c7cb			 
c7cb 06 00				ld b, 0 
c7cd 4d					ld c, l 
c7ce			 
c7ce e1					pop hl 
c7cf 11 bf e4				ld de, os_input 
c7d2					if DEBUG_FORTH_WORDS_KEY 
c7d2						DMARK "EDc" 
c7d2 f5				push af  
c7d3 3a e7 c7			ld a, (.dmark)  
c7d6 32 6b ee			ld (debug_mark),a  
c7d9 3a e8 c7			ld a, (.dmark+1)  
c7dc 32 6c ee			ld (debug_mark+1),a  
c7df 3a e9 c7			ld a, (.dmark+2)  
c7e2 32 6d ee			ld (debug_mark+2),a  
c7e5 18 03			jr .pastdmark  
c7e7 ..			.dmark: db "EDc"  
c7ea f1			.pastdmark: pop af  
c7eb			endm  
# End of macro DMARK
c7eb						CALLMONITOR 
c7eb cd 6f ee			call debug_vector  
c7ee				endm  
# End of macro CALLMONITOR
c7ee					endif 
c7ee ed b0				ldir 
c7f0			 
c7f0			 
c7f0 21 bf e4				ld hl, os_input 
c7f3					;ld a, 0 
c7f3					;ld (hl),a 
c7f3 3a 5e ea				ld a,(f_cursor_ptr) 
c7f6 16 64				ld d, 100 
c7f8 0e 00				ld c, 0 
c7fa 1e 28				ld e, 40 
c7fc cd 08 8d				call input_str 
c7ff					; TODO perhaps do a type check and wrap in quotes if not a number 
c7ff 21 bf e4				ld hl, os_input 
c802					if DEBUG_FORTH_WORDS 
c802						DMARK "ED1" 
c802 f5				push af  
c803 3a 17 c8			ld a, (.dmark)  
c806 32 6b ee			ld (debug_mark),a  
c809 3a 18 c8			ld a, (.dmark+1)  
c80c 32 6c ee			ld (debug_mark+1),a  
c80f 3a 19 c8			ld a, (.dmark+2)  
c812 32 6d ee			ld (debug_mark+2),a  
c815 18 03			jr .pastdmark  
c817 ..			.dmark: db "ED1"  
c81a f1			.pastdmark: pop af  
c81b			endm  
# End of macro DMARK
c81b						CALLMONITOR 
c81b cd 6f ee			call debug_vector  
c81e				endm  
# End of macro CALLMONITOR
c81e					endif 
c81e cd a9 9b				call forth_push_str 
c821					NEXTW 
c821 c3 e8 9e			jp macro_next 
c824				endm 
# End of macro NEXTW
c824			 
c824			.DEDIT: 
c824				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c824 40				db WORD_SYS_CORE+44             
c825 86 c8			dw .ENDKEY            
c827 06				db 5 + 1 
c828 .. 00			db "DEDIT",0              
c82e				endm 
# End of macro CWHEAD
c82e			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c82e			 
c82e					; TODO does not copy from stack 
c82e					if DEBUG_FORTH_WORDS_KEY 
c82e						DMARK "DED" 
c82e f5				push af  
c82f 3a 43 c8			ld a, (.dmark)  
c832 32 6b ee			ld (debug_mark),a  
c835 3a 44 c8			ld a, (.dmark+1)  
c838 32 6c ee			ld (debug_mark+1),a  
c83b 3a 45 c8			ld a, (.dmark+2)  
c83e 32 6d ee			ld (debug_mark+2),a  
c841 18 03			jr .pastdmark  
c843 ..			.dmark: db "DED"  
c846 f1			.pastdmark: pop af  
c847			endm  
# End of macro DMARK
c847						CALLMONITOR 
c847 cd 6f ee			call debug_vector  
c84a				endm  
# End of macro CALLMONITOR
c84a					endif 
c84a			 
c84a					;FORTH_DSP 
c84a					FORTH_DSP_VALUEHL 
c84a cd 32 9d			call macro_dsp_valuehl 
c84d				endm 
# End of macro FORTH_DSP_VALUEHL
c84d			;		inc hl    ; TODO do type check 
c84d			 
c84d			;		call get_word_hl 
c84d e5					push hl 
c84e e5					push hl 
c84f					FORTH_DSP_POP 
c84f cd ea 9d			call macro_forth_dsp_pop 
c852				endm 
# End of macro FORTH_DSP_POP
c852 e1					pop hl 
c853					if DEBUG_FORTH_WORDS 
c853						DMARK "EDp" 
c853 f5				push af  
c854 3a 68 c8			ld a, (.dmark)  
c857 32 6b ee			ld (debug_mark),a  
c85a 3a 69 c8			ld a, (.dmark+1)  
c85d 32 6c ee			ld (debug_mark+1),a  
c860 3a 6a c8			ld a, (.dmark+2)  
c863 32 6d ee			ld (debug_mark+2),a  
c866 18 03			jr .pastdmark  
c868 ..			.dmark: db "EDp"  
c86b f1			.pastdmark: pop af  
c86c			endm  
# End of macro DMARK
c86c						CALLMONITOR 
c86c cd 6f ee			call debug_vector  
c86f				endm  
# End of macro CALLMONITOR
c86f					endif 
c86f				;	ld a, 0 
c86f cd 39 91				call strlenz 
c872 23					inc hl 
c873			 
c873 06 00				ld b, 0 
c875 4d					ld c, l 
c876			 
c876 e1					pop hl 
c877			 
c877					;ld a, 0 
c877					;ld (hl),a 
c877 3a 5e ea				ld a,(f_cursor_ptr) 
c87a 16 64				ld d, 100 
c87c 0e 00				ld c, 0 
c87e 1e 28				ld e, 40 
c880 cd 08 8d				call input_str 
c883					; TODO perhaps do a type check and wrap in quotes if not a number 
c883					NEXTW 
c883 c3 e8 9e			jp macro_next 
c886				endm 
# End of macro NEXTW
c886			 
c886			 
c886			.ENDKEY: 
c886			; eof 
c886			 
# End of file forth_words_key.asm
c886			include "forth_words_const.asm" 
c886			 
c886			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c886			 
c886			 
c886			.SPITIME: 
c886				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c886 77				db WORD_SYS_CORE+99             
c887 9b c8			dw .VA            
c889 08				db 7 + 1 
c88a .. 00			db "SPITIME",0              
c892				endm 
# End of macro CWHEAD
c892			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c892			; 
c892			; | If using BANK devices then leave as is. 
c892			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c892			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c892			 
c892 21 64 ea				ld hl, spi_clktime  
c895 cd 3b 9b				call forth_push_numhl 
c898			 
c898					NEXTW 
c898 c3 e8 9e			jp macro_next 
c89b				endm 
# End of macro NEXTW
c89b			 
c89b			 
c89b			.VA: 
c89b				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c89b 77				db WORD_SYS_CORE+99             
c89c ab c8			dw .SYMBOL            
c89e 03				db 2 + 1 
c89f .. 00			db "VA",0              
c8a2				endm 
# End of macro CWHEAD
c8a2			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c8a2 21 28 ea				ld hl, cli_var_array 
c8a5 cd 3b 9b				call forth_push_numhl 
c8a8			 
c8a8					NEXTW 
c8a8 c3 e8 9e			jp macro_next 
c8ab				endm 
# End of macro NEXTW
c8ab			 
c8ab			.SYMBOL: 
c8ab				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c8ab 77				db WORD_SYS_CORE+99             
c8ac b5 c9			dw .ENDCONST            
c8ae 07				db 6 + 1 
c8af .. 00			db "SYMBOL",0              
c8b6				endm 
# End of macro CWHEAD
c8b6			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c8b6			; | 
c8b6			; | The value is the number reference and the final address is pushed to stack 
c8b6			 
c8b6			; | dw sym_table 
c8b6			; | dw nmi_vector 
c8b6			; | dw cli_autodisplay 
c8b6			; | dw cli_data_sp 
c8b6			; | dw cli_data_stack 
c8b6			; | dw cli_loop_sp 
c8b6			; | dw cli_loop_stack 
c8b6			; | dw cli_var_array 
c8b6			; | dw cursor_col 
c8b6			; | dw cursor_ptr 
c8b6			; | ; 10 
c8b6			; | dw cursor_row 
c8b6			; | dw debug_mark 
c8b6			; | dw display_fb0 
c8b6			; | dw display_fb1 
c8b6			; | dw display_fb2 
c8b6			; | dw display_fb3 
c8b6			; | dw display_fb_active 
c8b6			; | dw execscratch 
c8b6			; | dw f_cursor_ptr 
c8b6			; | dw hardware_word 
c8b6			; | ;20 
c8b6			; | dw input_at_cursor 
c8b6			; | dw input_at_pos 
c8b6			; | dw input_cur_flash 
c8b6			; | dw input_cur_onoff 
c8b6			; | dw input_cursor 
c8b6			; | dw input_display_size 
c8b6			; | dw input_len 
c8b6			; | dw input_ptr 
c8b6			; | dw input_size 
c8b6			; | dw input_start 
c8b6			; | ; 30 
c8b6			; | dw input_str 
c8b6			; | dw input_under_cursor 
c8b6			; | dw os_cli_cmd 
c8b6			; | dw os_cur_ptr 
c8b6			; | dw os_current_i 
c8b6			; | dw os_input 
c8b6			; | dw os_last_cmd 
c8b6			; | dw os_last_new_uword 
c8b6			; | dw debug_vector 
c8b6			; | dw os_view_hl 
c8b6			; | ;40 
c8b6			; | dw os_word_scratch 
c8b6			; | dw portbctl 
c8b6			; | dw portbdata 
c8b6			; | dw spi_cartdev 
c8b6			; | dw spi_cartdev2 
c8b6			; | dw spi_clktime 
c8b6			; | dw spi_device 
c8b6			; | dw spi_device_id 
c8b6			; | dw spi_portbyte 
c8b6			; | dw stackstore 
c8b6			; | ; 50 
c8b6			; | if STORAGE_SE 
c8b6			; | dw storage_actl 
c8b6			; | dw storage_adata 
c8b6			; | else 
c8b6			; | dw 0 
c8b6			; | dw 0 
c8b6			; | endif 
c8b6			; | dw storage_append 
c8b6			; | if STORAGE_SE 
c8b6			; | dw storage_bctl 
c8b6			; | else 
c8b6			; | dw 0 
c8b6			; | endif 
c8b6			; | dw store_bank_active 
c8b6			; | dw store_filecache 
c8b6			; | dw store_longread 
c8b6			; | dw store_openaddr 
c8b6			; | dw store_openext 
c8b6			; | dw store_openmaxext 
c8b6			; | ; 60 
c8b6			; | dw store_page 
c8b6			; | dw store_readbuf 
c8b6			; | dw store_readcont 
c8b6			; | dw store_readptr 
c8b6			; | dw store_tmpext 
c8b6			; | dw store_tmpid 
c8b6			; | dw store_tmppageid 
c8b6			; | dw malloc 
c8b6			; | dw free 
c8b6			; | dw cin 
c8b6			; | ; 70 
c8b6			; | dw cin_wait 
c8b6			; | dw forth_push_numhl 
c8b6			; | dw forth_push_str 
c8b6			 
c8b6					if DEBUG_FORTH_WORDS_KEY 
c8b6						DMARK "SYM" 
c8b6 f5				push af  
c8b7 3a cb c8			ld a, (.dmark)  
c8ba 32 6b ee			ld (debug_mark),a  
c8bd 3a cc c8			ld a, (.dmark+1)  
c8c0 32 6c ee			ld (debug_mark+1),a  
c8c3 3a cd c8			ld a, (.dmark+2)  
c8c6 32 6d ee			ld (debug_mark+2),a  
c8c9 18 03			jr .pastdmark  
c8cb ..			.dmark: db "SYM"  
c8ce f1			.pastdmark: pop af  
c8cf			endm  
# End of macro DMARK
c8cf						CALLMONITOR 
c8cf cd 6f ee			call debug_vector  
c8d2				endm  
# End of macro CALLMONITOR
c8d2					endif 
c8d2			 
c8d2					FORTH_DSP_VALUEHL 
c8d2 cd 32 9d			call macro_dsp_valuehl 
c8d5				endm 
# End of macro FORTH_DSP_VALUEHL
c8d5			 
c8d5 7d					ld a, l     
c8d6			 
c8d6			 
c8d6					if DEBUG_FORTH_WORDS 
c8d6						DMARK "SY1" 
c8d6 f5				push af  
c8d7 3a eb c8			ld a, (.dmark)  
c8da 32 6b ee			ld (debug_mark),a  
c8dd 3a ec c8			ld a, (.dmark+1)  
c8e0 32 6c ee			ld (debug_mark+1),a  
c8e3 3a ed c8			ld a, (.dmark+2)  
c8e6 32 6d ee			ld (debug_mark+2),a  
c8e9 18 03			jr .pastdmark  
c8eb ..			.dmark: db "SY1"  
c8ee f1			.pastdmark: pop af  
c8ef			endm  
# End of macro DMARK
c8ef						CALLMONITOR 
c8ef cd 6f ee			call debug_vector  
c8f2				endm  
# End of macro CALLMONITOR
c8f2					endif 
c8f2					 
c8f2 f5					push af	 
c8f3					FORTH_DSP_POP 
c8f3 cd ea 9d			call macro_forth_dsp_pop 
c8f6				endm 
# End of macro FORTH_DSP_POP
c8f6 f1					pop af 
c8f7			 
c8f7 cb 27				sla a  
c8f9				 
c8f9					 
c8f9					if DEBUG_FORTH_WORDS 
c8f9						DMARK "SY" 
c8f9 f5				push af  
c8fa 3a 0e c9			ld a, (.dmark)  
c8fd 32 6b ee			ld (debug_mark),a  
c900 3a 0f c9			ld a, (.dmark+1)  
c903 32 6c ee			ld (debug_mark+1),a  
c906 3a 10 c9			ld a, (.dmark+2)  
c909 32 6d ee			ld (debug_mark+2),a  
c90c 18 02			jr .pastdmark  
c90e ..			.dmark: db "SY"  
c910 f1			.pastdmark: pop af  
c911			endm  
# End of macro DMARK
c911						CALLMONITOR 
c911 cd 6f ee			call debug_vector  
c914				endm  
# End of macro CALLMONITOR
c914					endif 
c914			 
c914 21 23 c9				ld hl, sym_table 
c917 cd db 8c				call addatohl 
c91a cd 6a 9e				call loadwordinhl 
c91d cd 3b 9b				call forth_push_numhl 
c920			 
c920			 
c920				       NEXTW 
c920 c3 e8 9e			jp macro_next 
c923				endm 
# End of macro NEXTW
c923			 
c923			sym_table: 
c923			 
c923			; 0 
c923 23 c9		dw sym_table 
c925 72 ee		dw nmi_vector 
c927 3c ea		dw cli_autodisplay 
c929 ee e9		dw cli_data_sp 
c92b 28 e8		dw cli_data_stack 
c92d f0 e9		dw cli_loop_sp 
c92f 2a e9		dw cli_loop_stack 
c931 28 ea		dw cli_var_array 
c933 c5 eb		dw cursor_col 
c935 c3 eb		dw cursor_ptr 
c937			; 10 
c937 c4 eb		dw cursor_row 
c939 6b ee		dw debug_mark 
c93b b1 ed		dw display_fb0 
c93d 10 ed		dw display_fb1 
c93f ce eb		dw display_fb2 
c941 6f ec		dw display_fb3 
c943 cc eb		dw display_fb_active 
c945 c0 e3		dw execscratch 
c947 5e ea		dw f_cursor_ptr 
c949 75 ee		dw hardware_word 
c94b			;20 
c94b 62 ee		dw input_at_cursor 
c94d 64 ee		dw input_at_pos 
c94f 60 ee		dw input_cur_flash 
c951 5f ee		dw input_cur_onoff 
c953 55 ee		dw input_cursor 
c955 65 ee		dw input_display_size 
c957 5a ee		dw input_len 
c959 69 ee		dw input_ptr 
c95b 66 ee		dw input_size 
c95d 67 ee		dw input_start 
c95f			; 30 
c95f 08 8d		dw input_str 
c961 63 ee		dw input_under_cursor 
c963 e8 e5		dw os_cli_cmd 
c965 e4 e5		dw os_cur_ptr 
c967 e6 e5		dw os_current_i 
c969 bf e4		dw os_input 
c96b e7 e6		dw os_last_cmd 
c96d be e5		dw os_last_new_uword 
c96f 6f ee		dw debug_vector 
c971 a3 e2		dw os_view_hl 
c973			;40 
c973 c6 e5		dw os_word_scratch 
c975 c3 00		dw portbctl 
c977 c1 00		dw portbdata 
c979 63 ea		dw spi_cartdev 
c97b 62 ea		dw spi_cartdev2 
c97d 64 ea		dw spi_clktime 
c97f 60 ea		dw spi_device 
c981 5f ea		dw spi_device_id 
c983 61 ea		dw spi_portbyte 
c985 a7 eb		dw stackstore 
c987			; 50 
c987			if STORAGE_SE 
c987			dw storage_actl 
c987			dw storage_adata 
c987			else 
c987 00 00		dw 0 
c989 00 00		dw 0 
c98b			endif 
c98b 68 88		dw storage_append 
c98d			if STORAGE_SE 
c98d			dw storage_bctl 
c98d			else 
c98d 00 00		dw 0 
c98f			endif 
c98f 93 eb		dw store_bank_active 
c991 67 ea		dw store_filecache 
c993 75 ea		dw store_longread 
c995 6b ea		dw store_openaddr 
c997 6a ea		dw store_openext 
c999 69 ea		dw store_openmaxext 
c99b			; 60 
c99b 7a ea		dw store_page 
c99d 76 ea		dw store_readbuf 
c99f 6d ea		dw store_readcont 
c9a1 78 ea		dw store_readptr 
c9a3 6d ea		dw store_tmpext 
c9a5 6e ea		dw store_tmpid 
c9a7 65 ea		dw store_tmppageid 
c9a9 a2 91		dw malloc 
c9ab 6c 92		dw free 
c9ad 62 e4		dw cin 
c9af			; 70 
c9af 5c e4		dw cin_wait 
c9b1 3b 9b		dw forth_push_numhl 
c9b3 a9 9b		dw forth_push_str 
c9b5			 
c9b5			 
c9b5			.ENDCONST: 
c9b5			 
c9b5			; eof 
c9b5			 
c9b5			 
# End of file forth_words_const.asm
c9b5			 
c9b5			if STORAGE_SE 
c9b5			   	include "forth_words_storage.asm" 
c9b5			endif 
c9b5				include "forth_words_device.asm" 
c9b5			; Device related words 
c9b5			 
c9b5			; | ## Device Words 
c9b5			 
c9b5			;if SOUND_ENABLE 
c9b5			;.NOTE: 
c9b5			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c9b5			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c9b5			;		if DEBUG_FORTH_WORDS_KEY 
c9b5			;			DMARK "NTE" 
c9b5			;			CALLMONITOR 
c9b5			;		endif 
c9b5			; 
c9b5			;	 
c9b5			; 
c9b5			;		NEXTW 
c9b5			;.AFTERSOUND: 
c9b5			;endif 
c9b5			 
c9b5			 
c9b5			USE_GPIO: equ 0 
c9b5			 
c9b5			if USE_GPIO 
c9b5			.GP1: 
c9b5				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c9b5			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c9b5					NEXTW 
c9b5			.GP2: 
c9b5				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c9b5			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c9b5			 
c9b5					NEXTW 
c9b5			 
c9b5			.GP3: 
c9b5				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c9b5			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c9b5			 
c9b5					NEXTW 
c9b5			 
c9b5			.GP4: 
c9b5				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c9b5			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c9b5			 
c9b5					NEXTW 
c9b5			.SIN: 
c9b5			 
c9b5			 
c9b5			endif 
c9b5			 
c9b5			 
c9b5				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c9b5 33				db WORD_SYS_CORE+31             
c9b6 ea c9			dw .SOUT            
c9b8 03				db 2 + 1 
c9b9 .. 00			db "IN",0              
c9bc				endm 
# End of macro CWHEAD
c9bc			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c9bc					if DEBUG_FORTH_WORDS_KEY 
c9bc						DMARK "IN." 
c9bc f5				push af  
c9bd 3a d1 c9			ld a, (.dmark)  
c9c0 32 6b ee			ld (debug_mark),a  
c9c3 3a d2 c9			ld a, (.dmark+1)  
c9c6 32 6c ee			ld (debug_mark+1),a  
c9c9 3a d3 c9			ld a, (.dmark+2)  
c9cc 32 6d ee			ld (debug_mark+2),a  
c9cf 18 03			jr .pastdmark  
c9d1 ..			.dmark: db "IN."  
c9d4 f1			.pastdmark: pop af  
c9d5			endm  
# End of macro DMARK
c9d5						CALLMONITOR 
c9d5 cd 6f ee			call debug_vector  
c9d8				endm  
# End of macro CALLMONITOR
c9d8					endif 
c9d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9d8 cd 32 9d			call macro_dsp_valuehl 
c9db				endm 
# End of macro FORTH_DSP_VALUEHL
c9db			 
c9db e5					push hl 
c9dc			 
c9dc					; destroy value TOS 
c9dc			 
c9dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9dc cd ea 9d			call macro_forth_dsp_pop 
c9df				endm 
# End of macro FORTH_DSP_POP
c9df			 
c9df					; one value on hl get other one back 
c9df			 
c9df c1					pop bc 
c9e0			 
c9e0					; do the sub 
c9e0			;		ex de, hl 
c9e0			 
c9e0 ed 68				in l,(c) 
c9e2			 
c9e2					; save it 
c9e2			 
c9e2 26 00				ld h,0 
c9e4			 
c9e4					; TODO push value back onto stack for another op etc 
c9e4			 
c9e4 cd 3b 9b				call forth_push_numhl 
c9e7					NEXTW 
c9e7 c3 e8 9e			jp macro_next 
c9ea				endm 
# End of macro NEXTW
c9ea			.SOUT: 
c9ea				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c9ea 34				db WORD_SYS_CORE+32             
c9eb 3d ca			dw .SPIO            
c9ed 04				db 3 + 1 
c9ee .. 00			db "OUT",0              
c9f2				endm 
# End of macro CWHEAD
c9f2			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c9f2					if DEBUG_FORTH_WORDS_KEY 
c9f2						DMARK "OUT" 
c9f2 f5				push af  
c9f3 3a 07 ca			ld a, (.dmark)  
c9f6 32 6b ee			ld (debug_mark),a  
c9f9 3a 08 ca			ld a, (.dmark+1)  
c9fc 32 6c ee			ld (debug_mark+1),a  
c9ff 3a 09 ca			ld a, (.dmark+2)  
ca02 32 6d ee			ld (debug_mark+2),a  
ca05 18 03			jr .pastdmark  
ca07 ..			.dmark: db "OUT"  
ca0a f1			.pastdmark: pop af  
ca0b			endm  
# End of macro DMARK
ca0b						CALLMONITOR 
ca0b cd 6f ee			call debug_vector  
ca0e				endm  
# End of macro CALLMONITOR
ca0e					endif 
ca0e			 
ca0e					; get port 
ca0e			 
ca0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca0e cd 32 9d			call macro_dsp_valuehl 
ca11				endm 
# End of macro FORTH_DSP_VALUEHL
ca11			 
ca11 e5					push hl 
ca12			 
ca12					; destroy value TOS 
ca12			 
ca12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca12 cd ea 9d			call macro_forth_dsp_pop 
ca15				endm 
# End of macro FORTH_DSP_POP
ca15			 
ca15					; get byte to send 
ca15			 
ca15					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca15 cd 32 9d			call macro_dsp_valuehl 
ca18				endm 
# End of macro FORTH_DSP_VALUEHL
ca18			 
ca18			;		push hl 
ca18			 
ca18					; destroy value TOS 
ca18			 
ca18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca18 cd ea 9d			call macro_forth_dsp_pop 
ca1b				endm 
# End of macro FORTH_DSP_POP
ca1b			 
ca1b					; one value on hl get other one back 
ca1b			 
ca1b			;		pop hl 
ca1b			 
ca1b c1					pop bc 
ca1c			 
ca1c					if DEBUG_FORTH_WORDS 
ca1c						DMARK "OUT" 
ca1c f5				push af  
ca1d 3a 31 ca			ld a, (.dmark)  
ca20 32 6b ee			ld (debug_mark),a  
ca23 3a 32 ca			ld a, (.dmark+1)  
ca26 32 6c ee			ld (debug_mark+1),a  
ca29 3a 33 ca			ld a, (.dmark+2)  
ca2c 32 6d ee			ld (debug_mark+2),a  
ca2f 18 03			jr .pastdmark  
ca31 ..			.dmark: db "OUT"  
ca34 f1			.pastdmark: pop af  
ca35			endm  
# End of macro DMARK
ca35						CALLMONITOR 
ca35 cd 6f ee			call debug_vector  
ca38				endm  
# End of macro CALLMONITOR
ca38					endif 
ca38			 
ca38 ed 69				out (c), l 
ca3a			 
ca3a					NEXTW 
ca3a c3 e8 9e			jp macro_next 
ca3d				endm 
# End of macro NEXTW
ca3d			 
ca3d			 
ca3d			.SPIO: 
ca3d			 
ca3d			if STORAGE_SE 
ca3d				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
ca3d			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
ca3d			 
ca3d					call spi_ce_low 
ca3d			    NEXTW 
ca3d			 
ca3d			.SPICEH: 
ca3d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
ca3d			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
ca3d			 
ca3d					call spi_ce_high 
ca3d			    NEXTW 
ca3d			 
ca3d			 
ca3d			.SPIOb: 
ca3d			 
ca3d				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
ca3d			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
ca3d			 
ca3d					if DEBUG_FORTH_WORDS_KEY 
ca3d						DMARK "SPo" 
ca3d						CALLMONITOR 
ca3d					endif 
ca3d					; get port 
ca3d			 
ca3d			 
ca3d					; get byte to send 
ca3d			 
ca3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca3d			 
ca3d			;		push hl    ; u1  
ca3d			 
ca3d					; destroy value TOS 
ca3d			 
ca3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca3d			 
ca3d					; one value on hl get other one back 
ca3d			 
ca3d			;		pop hl   ; u2 - addr 
ca3d			 
ca3d					; TODO Send SPI byte 
ca3d			 
ca3d			;		push hl 
ca3d			;		call spi_ce_low 
ca3d			;		pop hl 
ca3d					ld a, l 
ca3d					call spi_send_byte 
ca3d			;		call spi_ce_high 
ca3d			 
ca3d					NEXTW 
ca3d			 
ca3d			.SPII: 
ca3d				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
ca3d			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
ca3d					if DEBUG_FORTH_WORDS_KEY 
ca3d						DMARK "SPi" 
ca3d						CALLMONITOR 
ca3d					endif 
ca3d			 
ca3d					; TODO Get SPI byte 
ca3d			 
ca3d					call spi_read_byte 
ca3d			 
ca3d					if DEBUG_FORTH_WORDS 
ca3d						DMARK "Si2" 
ca3d						CALLMONITOR 
ca3d					endif 
ca3d					ld h, 0 
ca3d					ld l, a 
ca3d					if DEBUG_FORTH_WORDS 
ca3d						DMARK "Si3" 
ca3d						CALLMONITOR 
ca3d					endif 
ca3d					call forth_push_numhl 
ca3d			 
ca3d					NEXTW 
ca3d			 
ca3d			 
ca3d			 
ca3d			.SESEL: 
ca3d				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
ca3d			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
ca3d					if DEBUG_FORTH_WORDS_KEY 
ca3d						DMARK "BNK" 
ca3d						CALLMONITOR 
ca3d					endif 
ca3d			 
ca3d					ld a, 255 
ca3d					ld (spi_cartdev), a 
ca3d			 
ca3d					; get bank 
ca3d			 
ca3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca3d			 
ca3d			;		push hl 
ca3d			 
ca3d					; destroy value TOS 
ca3d			 
ca3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca3d			 
ca3d					; one value on hl get other one back 
ca3d			 
ca3d			;		pop hl 
ca3d			 
ca3d			 
ca3d					ld c, SPI_CE_HIGH 
ca3d					ld b, '0'    ; human readable bank number 
ca3d			 
ca3d					ld a, l 
ca3d			 
ca3d					if DEBUG_FORTH_WORDS 
ca3d						DMARK "BNK" 
ca3d						CALLMONITOR 
ca3d					endif 
ca3d			 
ca3d					; active low 
ca3d			 
ca3d					cp 0 
ca3d					jr z, .bset 
ca3d					cp 1 
ca3d					jr nz, .b2 
ca3d					res 0, c 
ca3d					ld b, '1'    ; human readable bank number 
ca3d			.b2:		cp 2 
ca3d					jr nz, .b3 
ca3d					res 1, c 
ca3d					ld b, '2'    ; human readable bank number 
ca3d			.b3:		cp 3 
ca3d					jr nz, .b4 
ca3d					res 2, c 
ca3d					ld b, '3'    ; human readable bank number 
ca3d			.b4:		cp 4 
ca3d					jr nz, .b5 
ca3d					res 3, c 
ca3d					ld b, '4'    ; human readable bank number 
ca3d			.b5:		cp 5 
ca3d					jr nz, .bset 
ca3d					res 4, c 
ca3d					ld b, '5'    ; human readable bank number 
ca3d			 
ca3d			.bset: 
ca3d					ld a, c 
ca3d					ld (spi_device),a 
ca3d					ld a, b 
ca3d					ld (spi_device_id),a 
ca3d					if DEBUG_FORTH_WORDS 
ca3d						DMARK "BN2" 
ca3d						CALLMONITOR 
ca3d					endif 
ca3d			 
ca3d					; set default SPI clk pulse time as disabled for BANK use 
ca3d			 
ca3d					ld a, 0 
ca3d					ld (spi_clktime), a 
ca3d			 
ca3d					NEXTW 
ca3d			 
ca3d			.CARTDEV: 
ca3d				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
ca3d			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
ca3d					if DEBUG_FORTH_WORDS_KEY 
ca3d						DMARK "CDV" 
ca3d						CALLMONITOR 
ca3d					endif 
ca3d			 
ca3d					; disable se storage bank selection 
ca3d			 
ca3d					ld a, SPI_CE_HIGH		; ce high 
ca3d					ld (spi_device), a 
ca3d			 
ca3d					; get bank 
ca3d			 
ca3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ca3d			 
ca3d			;		push hl 
ca3d			 
ca3d					; destroy value TOS 
ca3d			 
ca3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ca3d			 
ca3d					; one value on hl get other one back 
ca3d			 
ca3d			;		pop hl 
ca3d			 
ca3d					; active low 
ca3d			 
ca3d					ld c, 255 
ca3d			 
ca3d					ld a, l 
ca3d					if DEBUG_FORTH_WORDS 
ca3d						DMARK "CDV" 
ca3d						CALLMONITOR 
ca3d					endif 
ca3d					cp 0 
ca3d					jr z, .cset 
ca3d					cp 1 
ca3d					jr nz, .c2 
ca3d					res 0, c 
ca3d			.c2:		cp 2 
ca3d					jr nz, .c3 
ca3d					res 1, c 
ca3d			.c3:		cp 3 
ca3d					jr nz, .c4 
ca3d					res 2, c 
ca3d			.c4:		cp 4 
ca3d					jr nz, .c5 
ca3d					res 3, c 
ca3d			.c5:		cp 5 
ca3d					jr nz, .c6 
ca3d					res 4, c 
ca3d			.c6:		cp 6 
ca3d					jr nz, .c7 
ca3d					res 5, c 
ca3d			.c7:		cp 7 
ca3d					jr nz, .c8 
ca3d					res 6, c 
ca3d			.c8:		cp 8 
ca3d					jr nz, .cset 
ca3d					res 7, c 
ca3d			.cset:		ld a, c 
ca3d					ld (spi_cartdev),a 
ca3d			 
ca3d					if DEBUG_FORTH_WORDS 
ca3d						DMARK "CD2" 
ca3d						CALLMONITOR 
ca3d					endif 
ca3d			 
ca3d					; set default SPI clk pulse time as 10ms for CARTDEV use 
ca3d			 
ca3d					ld a, $0a 
ca3d					ld (spi_clktime), a 
ca3d					NEXTW 
ca3d			endif 
ca3d			 
ca3d			.ENDDEVICE: 
ca3d			; eof 
ca3d			 
# End of file forth_words_device.asm
ca3d			 
ca3d			; var handler 
ca3d			 
ca3d			 
ca3d			.VARS: 
ca3d				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
ca3d 77				db WORD_SYS_CORE+99             
ca3e ee ca			dw .V0            
ca40 04				db 3 + 1 
ca41 .. 00			db "VAR",0              
ca45				endm 
# End of macro CWHEAD
ca45			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
ca45			;| 
ca45			;| The variable name should consist of a single letter. e.g. "a" 
ca45			;! If a full string is passed then only the first char is looked at 
ca45			;| Any other char could exceed bounds checks!  
ca45			 
ca45					if DEBUG_FORTH_WORDS_KEY 
ca45						DMARK "VAR" 
ca45 f5				push af  
ca46 3a 5a ca			ld a, (.dmark)  
ca49 32 6b ee			ld (debug_mark),a  
ca4c 3a 5b ca			ld a, (.dmark+1)  
ca4f 32 6c ee			ld (debug_mark+1),a  
ca52 3a 5c ca			ld a, (.dmark+2)  
ca55 32 6d ee			ld (debug_mark+2),a  
ca58 18 03			jr .pastdmark  
ca5a ..			.dmark: db "VAR"  
ca5d f1			.pastdmark: pop af  
ca5e			endm  
# End of macro DMARK
ca5e						CALLMONITOR 
ca5e cd 6f ee			call debug_vector  
ca61				endm  
# End of macro CALLMONITOR
ca61					endif 
ca61			 
ca61					FORTH_DSP_VALUEHL 
ca61 cd 32 9d			call macro_dsp_valuehl 
ca64				endm 
# End of macro FORTH_DSP_VALUEHL
ca64			 
ca64 7e					ld a, (hl)    ; get first char on of the string 
ca65			 
ca65			 
ca65					if DEBUG_FORTH_WORDS 
ca65						DMARK "VR1" 
ca65 f5				push af  
ca66 3a 7a ca			ld a, (.dmark)  
ca69 32 6b ee			ld (debug_mark),a  
ca6c 3a 7b ca			ld a, (.dmark+1)  
ca6f 32 6c ee			ld (debug_mark+1),a  
ca72 3a 7c ca			ld a, (.dmark+2)  
ca75 32 6d ee			ld (debug_mark+2),a  
ca78 18 03			jr .pastdmark  
ca7a ..			.dmark: db "VR1"  
ca7d f1			.pastdmark: pop af  
ca7e			endm  
# End of macro DMARK
ca7e						CALLMONITOR 
ca7e cd 6f ee			call debug_vector  
ca81				endm  
# End of macro CALLMONITOR
ca81					endif 
ca81					 
ca81 f5					push af	 
ca82					FORTH_DSP_POP 
ca82 cd ea 9d			call macro_forth_dsp_pop 
ca85				endm 
# End of macro FORTH_DSP_POP
ca85 f1					pop af 
ca86			 
ca86					; convert to upper 
ca86			 
ca86 cd 48 90				call to_upper 
ca89					if DEBUG_FORTH_WORDS 
ca89						DMARK "Vaa" 
ca89 f5				push af  
ca8a 3a 9e ca			ld a, (.dmark)  
ca8d 32 6b ee			ld (debug_mark),a  
ca90 3a 9f ca			ld a, (.dmark+1)  
ca93 32 6c ee			ld (debug_mark+1),a  
ca96 3a a0 ca			ld a, (.dmark+2)  
ca99 32 6d ee			ld (debug_mark+2),a  
ca9c 18 03			jr .pastdmark  
ca9e ..			.dmark: db "Vaa"  
caa1 f1			.pastdmark: pop af  
caa2			endm  
# End of macro DMARK
caa2						CALLMONITOR 
caa2 cd 6f ee			call debug_vector  
caa5				endm  
# End of macro CALLMONITOR
caa5					endif 
caa5 06 41				ld b, 'A' 
caa7 90					sub b			; set offset 
caa8					if DEBUG_FORTH_WORDS 
caa8						DMARK "Vbb" 
caa8 f5				push af  
caa9 3a bd ca			ld a, (.dmark)  
caac 32 6b ee			ld (debug_mark),a  
caaf 3a be ca			ld a, (.dmark+1)  
cab2 32 6c ee			ld (debug_mark+1),a  
cab5 3a bf ca			ld a, (.dmark+2)  
cab8 32 6d ee			ld (debug_mark+2),a  
cabb 18 03			jr .pastdmark  
cabd ..			.dmark: db "Vbb"  
cac0 f1			.pastdmark: pop af  
cac1			endm  
# End of macro DMARK
cac1						CALLMONITOR 
cac1 cd 6f ee			call debug_vector  
cac4				endm  
# End of macro CALLMONITOR
cac4					endif 
cac4 cb 27				sla a  
cac6				 
cac6					 
cac6					if DEBUG_FORTH_WORDS 
cac6						DMARK "VR2" 
cac6 f5				push af  
cac7 3a db ca			ld a, (.dmark)  
caca 32 6b ee			ld (debug_mark),a  
cacd 3a dc ca			ld a, (.dmark+1)  
cad0 32 6c ee			ld (debug_mark+1),a  
cad3 3a dd ca			ld a, (.dmark+2)  
cad6 32 6d ee			ld (debug_mark+2),a  
cad9 18 03			jr .pastdmark  
cadb ..			.dmark: db "VR2"  
cade f1			.pastdmark: pop af  
cadf			endm  
# End of macro DMARK
cadf						CALLMONITOR 
cadf cd 6f ee			call debug_vector  
cae2				endm  
# End of macro CALLMONITOR
cae2					endif 
cae2			 
cae2 21 f4 e9				ld hl, cli_var_array2 
cae5 cd db 8c				call addatohl 
cae8 cd 3b 9b				call forth_push_numhl 
caeb			 
caeb			 
caeb				       NEXTW 
caeb c3 e8 9e			jp macro_next 
caee				endm 
# End of macro NEXTW
caee			.V0: 
caee				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
caee 78				db WORD_SYS_CORE+100             
caef 06 cb			dw .V0Q            
caf1 04				db 3 + 1 
caf2 .. 00			db "V0!",0              
caf6				endm 
# End of macro CWHEAD
caf6			;| V0! ( u1 -- )  Store value to v0  | DONE 
caf6			 
caf6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
caf6 cd 32 9d			call macro_dsp_valuehl 
caf9				endm 
# End of macro FORTH_DSP_VALUEHL
caf9			 
caf9 11 28 ea				ld de, cli_var_array 
cafc			 
cafc eb					ex de, hl 
cafd 73					ld (hl), e 
cafe 23					inc hl 
caff 72					ld (hl), d 
cb00			 
cb00					; destroy value TOS 
cb00			 
cb00					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb00 cd ea 9d			call macro_forth_dsp_pop 
cb03				endm 
# End of macro FORTH_DSP_POP
cb03			 
cb03				       NEXTW 
cb03 c3 e8 9e			jp macro_next 
cb06				endm 
# End of macro NEXTW
cb06			.V0Q: 
cb06				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
cb06 79				db WORD_SYS_CORE+101             
cb07 17 cb			dw .V1S            
cb09 04				db 3 + 1 
cb0a .. 00			db "V0@",0              
cb0e				endm 
# End of macro CWHEAD
cb0e			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
cb0e 2a 28 ea				ld hl, (cli_var_array) 
cb11 cd 3b 9b				call forth_push_numhl 
cb14			 
cb14				       NEXTW 
cb14 c3 e8 9e			jp macro_next 
cb17				endm 
# End of macro NEXTW
cb17			.V1S: 
cb17				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
cb17 7a				db WORD_SYS_CORE+102             
cb18 2f cb			dw .V1Q            
cb1a 04				db 3 + 1 
cb1b .. 00			db "V1!",0              
cb1f				endm 
# End of macro CWHEAD
cb1f			;| V1! ( u1 -- )  Store value to v1 | DONE 
cb1f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb1f cd 32 9d			call macro_dsp_valuehl 
cb22				endm 
# End of macro FORTH_DSP_VALUEHL
cb22			 
cb22 11 2a ea				ld de, cli_var_array+2 
cb25				 
cb25 eb					ex de, hl 
cb26 73					ld (hl), e 
cb27 23					inc hl 
cb28 72					ld (hl), d 
cb29			 
cb29					; destroy value TOS 
cb29			 
cb29					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb29 cd ea 9d			call macro_forth_dsp_pop 
cb2c				endm 
# End of macro FORTH_DSP_POP
cb2c				       NEXTW 
cb2c c3 e8 9e			jp macro_next 
cb2f				endm 
# End of macro NEXTW
cb2f			.V1Q: 
cb2f				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
cb2f 7b				db WORD_SYS_CORE+103             
cb30 40 cb			dw .V2S            
cb32 04				db 3 + 1 
cb33 .. 00			db "V1@",0              
cb37				endm 
# End of macro CWHEAD
cb37			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
cb37 2a 2a ea				ld hl, (cli_var_array+2) 
cb3a cd 3b 9b				call forth_push_numhl 
cb3d				       NEXTW 
cb3d c3 e8 9e			jp macro_next 
cb40				endm 
# End of macro NEXTW
cb40			.V2S: 
cb40				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cb40 7c				db WORD_SYS_CORE+104             
cb41 58 cb			dw .V2Q            
cb43 04				db 3 + 1 
cb44 .. 00			db "V2!",0              
cb48				endm 
# End of macro CWHEAD
cb48			;| V2! ( u1 -- )  Store value to v2 | DONE 
cb48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb48 cd 32 9d			call macro_dsp_valuehl 
cb4b				endm 
# End of macro FORTH_DSP_VALUEHL
cb4b			 
cb4b 11 2c ea				ld de, cli_var_array+4 
cb4e				 
cb4e eb					ex de, hl 
cb4f 73					ld (hl), e 
cb50 23					inc hl 
cb51 72					ld (hl), d 
cb52			 
cb52					; destroy value TOS 
cb52			 
cb52					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb52 cd ea 9d			call macro_forth_dsp_pop 
cb55				endm 
# End of macro FORTH_DSP_POP
cb55				       NEXTW 
cb55 c3 e8 9e			jp macro_next 
cb58				endm 
# End of macro NEXTW
cb58			.V2Q: 
cb58				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cb58 7d				db WORD_SYS_CORE+105             
cb59 69 cb			dw .V3S            
cb5b 04				db 3 + 1 
cb5c .. 00			db "V2@",0              
cb60				endm 
# End of macro CWHEAD
cb60			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cb60 2a 2c ea				ld hl, (cli_var_array+4) 
cb63 cd 3b 9b				call forth_push_numhl 
cb66				       NEXTW 
cb66 c3 e8 9e			jp macro_next 
cb69				endm 
# End of macro NEXTW
cb69			.V3S: 
cb69				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cb69 7c				db WORD_SYS_CORE+104             
cb6a 81 cb			dw .V3Q            
cb6c 04				db 3 + 1 
cb6d .. 00			db "V3!",0              
cb71				endm 
# End of macro CWHEAD
cb71			;| V3! ( u1 -- )  Store value to v3 | DONE 
cb71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb71 cd 32 9d			call macro_dsp_valuehl 
cb74				endm 
# End of macro FORTH_DSP_VALUEHL
cb74			 
cb74 11 2e ea				ld de, cli_var_array+6 
cb77				 
cb77 eb					ex de, hl 
cb78 73					ld (hl), e 
cb79 23					inc hl 
cb7a 72					ld (hl), d 
cb7b			 
cb7b					; destroy value TOS 
cb7b			 
cb7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb7b cd ea 9d			call macro_forth_dsp_pop 
cb7e				endm 
# End of macro FORTH_DSP_POP
cb7e				       NEXTW 
cb7e c3 e8 9e			jp macro_next 
cb81				endm 
# End of macro NEXTW
cb81			.V3Q: 
cb81				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cb81 7d				db WORD_SYS_CORE+105             
cb82 92 cb			dw .END            
cb84 04				db 3 + 1 
cb85 .. 00			db "V3@",0              
cb89				endm 
# End of macro CWHEAD
cb89			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cb89 2a 2e ea				ld hl, (cli_var_array+6) 
cb8c cd 3b 9b				call forth_push_numhl 
cb8f				       NEXTW 
cb8f c3 e8 9e			jp macro_next 
cb92				endm 
# End of macro NEXTW
cb92			 
cb92			 
cb92			 
cb92			 
cb92			 
cb92			; end of dict marker 
cb92			 
cb92 00			.END:    db WORD_SYS_END 
cb93 00 00			dw 0 
cb95 00				db 0 
cb96			 
cb96			; use to jp here for user dict words to save on macro expansion  
cb96			 
cb96			user_dict_next: 
cb96				NEXTW 
cb96 c3 e8 9e			jp macro_next 
cb99				endm 
# End of macro NEXTW
cb99			 
cb99			 
cb99			user_exec: 
cb99				;    ld hl, <word code> 
cb99				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb99				;    call forthexec 
cb99				;    jp user_dict_next   (NEXT) 
cb99			        ;    <word code bytes> 
cb99 eb				ex de, hl 
cb9a 2a c2 e5			ld hl,(os_tok_ptr) 
cb9d				 
cb9d				FORTH_RSP_NEXT 
cb9d cd e2 9a			call macro_forth_rsp_next 
cba0				endm 
# End of macro FORTH_RSP_NEXT
cba0			 
cba0			if DEBUG_FORTH_UWORD 
cba0						DMARK "UEX" 
cba0 f5				push af  
cba1 3a b5 cb			ld a, (.dmark)  
cba4 32 6b ee			ld (debug_mark),a  
cba7 3a b6 cb			ld a, (.dmark+1)  
cbaa 32 6c ee			ld (debug_mark+1),a  
cbad 3a b7 cb			ld a, (.dmark+2)  
cbb0 32 6d ee			ld (debug_mark+2),a  
cbb3 18 03			jr .pastdmark  
cbb5 ..			.dmark: db "UEX"  
cbb8 f1			.pastdmark: pop af  
cbb9			endm  
# End of macro DMARK
cbb9				CALLMONITOR 
cbb9 cd 6f ee			call debug_vector  
cbbc				endm  
# End of macro CALLMONITOR
cbbc			endif 
cbbc			 
cbbc			 
cbbc			 
cbbc eb				ex de, hl 
cbbd 22 c2 e5			ld (os_tok_ptr), hl 
cbc0				 
cbc0				; Don't use next - Skips the first word in uword. 
cbc0			 
cbc0 c3 79 9f			jp exec1 
cbc3			;	NEXT 
cbc3			 
cbc3			 
cbc3			; eof 
# End of file forth_wordsv4.asm
cbc3			endif 
cbc3			;;;;;;;;;;;;;; Debug code 
cbc3			 
cbc3			 
cbc3			;if DEBUG_FORTH_PARSE 
cbc3 .. 00		.nowordfound: db "No match",0 
cbcc .. 00		.compword:	db "Comparing word ",0 
cbdc .. 00		.nextwordat:	db "Next word at",0 
cbe9 .. 00		.charmatch:	db "Char match",0 
cbf4			;endif 
cbf4			if DEBUG_FORTH_JP 
cbf4			.foundword:	db "Word match. Exec..",0 
cbf4			endif 
cbf4			;if DEBUG_FORTH_PUSH 
cbf4 .. 00		.enddict:	db "Dict end. Push.",0 
cc04 .. 00		.push_str:	db "Pushing string",0 
cc13 .. 00		.push_num:	db "Pushing number",0 
cc22 .. 00		.data_sp:	db "SP:",0 
cc26 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cc38 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cc4a .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cc5c			;endif 
cc5c			;if DEBUG_FORTH_MALLOC 
cc5c .. 00		.push_malloc:	db "Malloc address",0 
cc6b			;endif 
cc6b			 
cc6b			 
cc6b			 
cc6b			; display malloc address and current data stack pointer  
cc6b			 
cc6b			malloc_error: 
cc6b d5				push de 
cc6c f5				push af 
cc6d e5				push hl 
cc6e cd ae 8a			call clear_display 
cc71 11 91 cc			ld de, .mallocerr 
cc74 3e 00			ld a,0 
cc76			;	ld de,os_word_scratch 
cc76 cd c1 8a			call str_at_display 
cc79 3e 11			ld a, display_row_1+17 
cc7b 11 6b ee			ld de, debug_mark 
cc7e cd c1 8a			call str_at_display 
cc81 cd d1 8a			call update_display 
cc84				;call break_point_state 
cc84 cd 5c e4			call cin_wait 
cc87			 
cc87			;	ld a, ' ' 
cc87			;	ld (os_view_disable), a 
cc87 cd d1 94			call bp_on 
cc8a e1				pop hl 
cc8b f1				pop af 
cc8c d1				pop de	 
cc8d				CALLMONITOR 
cc8d cd 6f ee			call debug_vector  
cc90				endm  
# End of macro CALLMONITOR
cc90 c9				ret 
cc91			 
cc91 .. 00		.mallocerr: 	db "Malloc Error",0 
cc9e			;if DEBUG_FORTH_PUSH 
cc9e			display_data_sp: 
cc9e f5				push af 
cc9f			 
cc9f				; see if disabled 
cc9f			 
cc9f			 
cc9f 3a 6f ee			ld a, (debug_vector) 
cca2 fe c9			cp $C9  ; RET 
cca4				;ld a, (os_view_disable) 
cca4				;cp '*' 
cca4 28 67			jr z, .skipdsp 
cca6			 
cca6 e5				push hl 
cca7 e5				push hl 
cca8 e5			push hl 
cca9 cd ae 8a			call clear_display 
ccac e1			pop hl 
ccad 7c				ld a,h 
ccae 21 c6 e5			ld hl, os_word_scratch 
ccb1 cd dc 8f			call hexout 
ccb4 e1				pop hl 
ccb5 7d				ld a,l 
ccb6 21 c8 e5			ld hl, os_word_scratch+2 
ccb9 cd dc 8f			call hexout 
ccbc 21 ca e5			ld hl, os_word_scratch+4 
ccbf 3e 00			ld a,0 
ccc1 77				ld (hl),a 
ccc2 11 c6 e5			ld de,os_word_scratch 
ccc5 3e 28				ld a, display_row_2 
ccc7 cd c1 8a				call str_at_display 
ccca 11 26 cc			ld de, .wordinhl 
cccd 3e 00			ld a, display_row_1 
cccf			 
cccf cd c1 8a				call str_at_display 
ccd2 11 6b ee			ld de, debug_mark 
ccd5 3e 11			ld a, display_row_1+17 
ccd7			 
ccd7 cd c1 8a				call str_at_display 
ccda			 
ccda				; display current data stack pointer 
ccda 11 22 cc			ld de,.data_sp 
ccdd 3e 30				ld a, display_row_2 + 8 
ccdf cd c1 8a				call str_at_display 
cce2			 
cce2 2a ee e9			ld hl,(cli_data_sp) 
cce5 e5				push hl 
cce6 7c				ld a,h 
cce7 21 c6 e5			ld hl, os_word_scratch 
ccea cd dc 8f			call hexout 
cced e1				pop hl 
ccee 7d				ld a,l 
ccef 21 c8 e5			ld hl, os_word_scratch+2 
ccf2 cd dc 8f			call hexout 
ccf5 21 ca e5			ld hl, os_word_scratch+4 
ccf8 3e 00			ld a,0 
ccfa 77				ld (hl),a 
ccfb 11 c6 e5			ld de,os_word_scratch 
ccfe 3e 33				ld a, display_row_2 + 11 
cd00 cd c1 8a				call str_at_display 
cd03			 
cd03			 
cd03 cd d1 8a			call update_display 
cd06 cd f1 89			call delay1s 
cd09 cd f1 89			call delay1s 
cd0c e1				pop hl 
cd0d			.skipdsp: 
cd0d f1				pop af 
cd0e c9				ret 
cd0f			 
cd0f			display_data_malloc: 
cd0f			 
cd0f f5				push af 
cd10 e5				push hl 
cd11 e5				push hl 
cd12 e5			push hl 
cd13 cd ae 8a			call clear_display 
cd16 e1			pop hl 
cd17 7c				ld a,h 
cd18 21 c6 e5			ld hl, os_word_scratch 
cd1b cd dc 8f			call hexout 
cd1e e1				pop hl 
cd1f 7d				ld a,l 
cd20 21 c8 e5			ld hl, os_word_scratch+2 
cd23 cd dc 8f			call hexout 
cd26 21 ca e5			ld hl, os_word_scratch+4 
cd29 3e 00			ld a,0 
cd2b 77				ld (hl),a 
cd2c 11 c6 e5			ld de,os_word_scratch 
cd2f 3e 28				ld a, display_row_2 
cd31 cd c1 8a				call str_at_display 
cd34 11 5c cc			ld de, .push_malloc 
cd37 3e 00			ld a, display_row_1 
cd39			 
cd39 cd c1 8a				call str_at_display 
cd3c			 
cd3c				; display current data stack pointer 
cd3c 11 22 cc			ld de,.data_sp 
cd3f 3e 30				ld a, display_row_2 + 8 
cd41 cd c1 8a				call str_at_display 
cd44			 
cd44 2a ee e9			ld hl,(cli_data_sp) 
cd47 e5				push hl 
cd48 7c				ld a,h 
cd49 21 c6 e5			ld hl, os_word_scratch 
cd4c cd dc 8f			call hexout 
cd4f e1				pop hl 
cd50 7d				ld a,l 
cd51 21 c8 e5			ld hl, os_word_scratch+2 
cd54 cd dc 8f			call hexout 
cd57 21 ca e5			ld hl, os_word_scratch+4 
cd5a 3e 00			ld a,0 
cd5c 77				ld (hl),a 
cd5d 11 c6 e5			ld de,os_word_scratch 
cd60 3e 33				ld a, display_row_2 + 11 
cd62 cd c1 8a				call str_at_display 
cd65			 
cd65 cd d1 8a			call update_display 
cd68 cd f1 89			call delay1s 
cd6b cd f1 89			call delay1s 
cd6e e1				pop hl 
cd6f f1				pop af 
cd70 c9				ret 
cd71			;endif 
cd71			 
cd71			include "forth_autostart.asm" 
cd71			; list of commands to perform at system start up 
cd71			 
cd71			startcmds: 
cd71			;	dw test11 
cd71			;	dw test12 
cd71			;	dw test13 
cd71			;	dw test14 
cd71			;	dw test15 
cd71			;	dw test16 
cd71			;	dw test17 
cd71			;	dw ifthtest1 
cd71			;	dw ifthtest2 
cd71			;	dw ifthtest3 
cd71			;	dw mmtest1 
cd71			;	dw mmtest2 
cd71			;	dw mmtest3 
cd71			;	dw mmtest4 
cd71			;	dw mmtest5 
cd71			;	dw mmtest6 
cd71			;	dw iftest1 
cd71			;	dw iftest2 
cd71			;	dw iftest3 
cd71			;	dw looptest1 
cd71			;	dw looptest2 
cd71			;	dw test1 
cd71			;	dw test2 
cd71			;	dw test3 
cd71			;	dw test4 
cd71			;	dw game2r 
cd71			;	dw game2b1 
cd71			;	dw game2b2 
cd71			 
cd71				; start up words that are actually useful 
cd71			 
cd71			;    dw spi1 
cd71			;    dw spi2 
cd71			;    dw spi3 
cd71			;    dw spi4 
cd71			;    dw spi5 
cd71			;    dw spi6 
cd71			;    dw spi7 
cd71			; 
cd71			;    dw spi8 
cd71			;    dw spi9 
cd71			;    dw spi10 
cd71			 
cd71			; file editor 
cd71			;	dw edit1 
cd71			;	dw edit2 
cd71			;	dw edit3 
cd71			 
cd71			;	dw longread 
cd71 71 d1			dw clrstack 
cd73 a5 d1			dw type 
cd75			;	dw stest 
cd75 ca d1			dw strncpy 
cd77			;	dw list 
cd77 2b d2			dw start1 
cd79 3b d2			dw start2 
cd7b			;	dw start3 
cd7b			;	dw start3b 
cd7b			;	dw start3c 
cd7b			 
cd7b				; (unit) testing words 
cd7b			 
cd7b			;	dw mtesta 
cd7b			;	dw mtestb 
cd7b			;	dw mtestc 
cd7b			;	dw mtestd 
cd7b			;	dw mteste 
cd7b			 
cd7b				; demo/game words 
cd7b			 
cd7b			;        dw game3w 
cd7b			;        dw game3p 
cd7b			;        dw game3sc 
cd7b			;        dw game3vsi 
cd7b			;        dw game3vs 
cd7b				 
cd7b 94 dc			dw game2b 
cd7d 02 dd			dw game2bf 
cd7f 4c dd			dw game2mba 
cd81 e2 dd			dw game2mbas 
cd83 24 de			dw game2mb 
cd85			 
cd85 55 d9			dw game1 
cd87 66 d9			dw game1a 
cd89 c8 d9			dw game1b 
cd8b fd d9			dw game1c 
cd8d 33 da			dw game1d 
cd8f 64 da			dw game1s 
cd91 78 da			dw game1t 
cd93 8d da			dw game1f 
cd95 c1 da			dw game1z 
cd97 05 db			dw game1zz 
cd99			 
cd99 6f d7			dw test5 
cd9b a7 d7			dw test6 
cd9d df d7			dw test7 
cd9f f3 d7			dw test8 
cda1 1f d8			dw test9 
cda3 35 d8			dw test10 
cda5				 
cda5 dc db		        dw ssv5 
cda7 c0 db		        dw ssv4 
cda9 a4 db		        dw ssv3 
cdab 6e db		        dw ssv2 
cdad f5 db		        dw ssv1 
cdaf 3d dc		        dw ssv1cpm 
cdb1			;	dw keyup 
cdb1			;	dw keydown 
cdb1			;	dw keyleft 
cdb1			;	dw keyright 
cdb1			;	dw 	keyf1 
cdb1			;	dw keyf2 
cdb1			;	dw keyf3 
cdb1			;	dw keyf4 
cdb1			;	dw keyf5 
cdb1			;	dw keyf6 
cdb1			;	dw keyf7 
cdb1			;	dw keyf8 
cdb1			;	dw keyf9 
cdb1			;	dw keyf10 
cdb1			;	dw keyf11 
cdb1			;	dw keyf12 
cdb1			;	dw keytab 
cdb1			;	dw keycr 
cdb1			;	dw keyhome 
cdb1			;	dw keyend 
cdb1			;	dw keybs 
cdb1 00 00			db 0, 0	 
cdb3			 
cdb3			 
cdb3			; File Editor 
cdb3			 
cdb3			; ( id - ) use 'e' to edit the displayed line 
cdb3 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cdd4 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
ce09			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
ce09 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
ce41			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
ce41			 
ce41			; SPI Net support words 
ce41			 
ce41			; v0! = node to send to 
ce41			; ( str count - ) 
ce41 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce9a			 
ce9a			; spiputchr ( char node - ) 
ce9a .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
ced0			 
ced0			; spigetchr ( - n ) 
ced0 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
cefb			 
cefb			; getnode ( - n ) 
cefb .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cf28			 
cf28			; ( str node - )  
cf28 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf8e			; store string ( str i - ) 
cf8e			 
cf8e			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf8e .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cfe3			 
cfe3			; get string ( addr i -  )    TO FIX 
cfe3			 
cfe3 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d03b			 
d03b			 
d03b			; NETCHAT (TODO) 
d03b			; Program to allow two nodes to chat with eachother 
d03b			; 
d03b			; v0 - target node 
d03b			;  
d03b			; accept input at 0,0 
d03b			; if input is string send spitype to target node 
d03b			; starting at row 2,0 , while spigetchr is not zero ->  
d03b			; 
d03b			; 
d03b			; TODO add paging of get request 
d03b			 
d03b			; ( node - ) 
d03b .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d05a .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d0b2 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d12a			 
d12a			 
d12a			; Long read of currently open file 
d12a .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d171			 
d171			; clear stack  
d171			 
d171 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d1a5			 
d1a5			; type ( addr count - ) 
d1a5 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d1ca			 
d1ca			; some direct memory words 
d1ca			; strncpy ( len t f -- t ) 
d1ca			 
d1ca .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d22b			 
d22b .. 00		start1:     	db ": bpon $00 bp ;",0 
d23b .. 00		start2:     	db ": bpoff $01 bp ;",0 
d24c .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d2c7 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d327			 
d327			 
d327			; a handy word to list items on the stack 
d327			 
d327 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d391			 
d391			 
d391			; test stack  
d391			; rnd8 stest 
d391			 
d391 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d408			 
d408			; random malloc and free cycles 
d408			 
d408 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d4bd			 
d4bd			; fixed malloc and free cycles 
d4bd			 
d4bd .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d560			 
d560			; fixed double string push and drop cycle  
d560			 
d560 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d615			 
d615			; consistent fixed string push and drop cycle  
d615			 
d615 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d6b9			 
d6b9 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d76f			 
d76f			;test1:		db ": aa 1 2 3 ;", 0 
d76f			;test2:     	db "111 aa 888 999",0 
d76f			;test3:     	db ": bb 77 ;",0 
d76f			;test4:     	db "$02 $01 do i . loop bb",0 
d76f			 
d76f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d7a7 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d7df .. 00		test7:     	db ": box hline vline ;",0 
d7f3 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d81f .. 00		test9:     	db ": sw $01 adsp world ;",0 
d835 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d85a .. 00		test11:     	db "hello create .",0 
d869 .. 00		test12:     	db "hello2 create .",0 
d879			 
d879			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d879			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d879			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d879			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d879			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d879			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d879			 
d879			;iftest1:     	db "$0001 IF cls .",0 
d879			;iftest2:     	db "$0000 IF cls .",0 
d879			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d879			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d879			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d879			 
d879			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d879			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d879			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d879			 
d879			 
d879 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d89d .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d8cd .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d8f2 .. 00		sound4: db ": cha $00 ; ",0 
d8ff .. 00		sound5: db ": chb $20 ; ",0 
d90c .. 00		sound6: db ": chc $40 ; ",0 
d919 .. 00		sound7: db ": chd $60 ; ",0 
d926 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d93e .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d955			 
d955			 
d955			 
d955			 
d955			; a small guess the number game 
d955			 
d955 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d966 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d9c8			 
d9c8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d9fd .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
da33 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
da64 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
da78 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
da8d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
dac1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
db05			 
db05			; Using 'ga' save a high score across multiple runs using external storage 
db05			 
db05 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
db6e			 
db6e			 
db6e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
db6e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
db6e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
db6e			 
db6e			; simple screen saver to test code memory reuse to destruction 
db6e			 
db6e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
dba4 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
dbc0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
dbdc .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
dbf5 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dc3d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
dc94			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
dc94			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
dc94			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
dc94			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
dc94			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
dc94			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
dc94			 
dc94			 
dc94			 
dc94			; minesweeper/battleship finding game 
dc94			; draws a game board of random ship/mine positions 
dc94			; user enters coords to see if it hits on 
dc94			; game ends when all are hit 
dc94			; when hit or miss says how many may be in the area 
dc94			 
dc94			; setup the game board and then hide it 
dc94 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dd02 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dd4c			; prompt for where to target 
dd4c .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dde2 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
de07			; TODO see if the entered coords hits or misses pushes char hit of miss 
de07 .. 00		game2mbht:      db ": mbckht nop ;",0 
de16 .. 00		game2mbms:      db ": mbcms nop ;",0 
de24			; TODO how many might be near by 
de24 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
dea1			 
dea1			; Game 3 
dea1			 
dea1			; Vert scroller ski game - avoid the trees! 
dea1			 
dea1			; v0 score (ie turns) 
dea1			; v1 player pos 
dea1			; v2 left wall 
dea1			; v3 right wall 
dea1			 
dea1			; Draw side walls randomly 
dea1			 
dea1 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
decf			 
decf			; Draw player 
decf .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
deed			 
deed			; TODO Get Key 
deed			 
deed			; TODO Move left right 
deed			 
deed			; scroll and move walls a bit 
deed			 
deed .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
df1e			 
df1e			; main game loop 
df1e			 
df1e .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
df4a .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
df89			 
df89			; key board defs 
df89			 
df89 .. 00		keyup:       db ": keyup $05 ;",0 
df97 .. 00		keydown:       db ": keydown $0a ;",0 
dfa7 .. 00		keyleft:       db ": keyleft $0b ;",0 
dfb7 .. 00		keyright:       db ": keyright $0c ;",0 
dfc8 .. 00		keyf1:       db ": keyf1 $10 ;",0 
dfd6 .. 00		keyf2:       db ": keyf2 $11 ;",0 
dfe4 .. 00		keyf3:       db ": keyf3 $12 ;",0 
dff2 .. 00		keyf4:       db ": keyf4 $13 ;",0 
e000 .. 00		keyf5:       db ": keyf5 $14 ;",0 
e00e .. 00		keyf6:       db ": keyf6 $15 ;",0 
e01c .. 00		keyf7:       db ": keyf7 $16 ;",0 
e02a .. 00		keyf8:       db ": keyf8 $17 ;",0 
e038 .. 00		keyf9:       db ": keyf9 $18 ;",0 
e046 .. 00		keyf10:       db ": keyf10 $19 ;",0 
e055 .. 00		keyf11:       db ": keyf11 $1a ;",0 
e064 .. 00		keyf12:       db ": keyf12 $1b ;",0 
e073			 
e073 .. 00		keytab:       db ": keytab $09 ;",0 
e082 .. 00		keycr:       db ": keycr $0d ;",0 
e090 .. 00		keyhome:       db ": keyhome $0e ;",0 
e0a0 .. 00		keyend:       db ": keyend $0f ;",0 
e0af .. 00		keybs:       db ": keybs $08 ;",0 
e0bd			 
e0bd			   
e0bd			 
e0bd			 
e0bd			 
e0bd			; eof 
# End of file forth_autostart.asm
e0bd			 
e0bd			 
e0bd			 
e0bd			; stack over and underflow checks 
e0bd			 
e0bd			; init the words to detect the under/overflow 
e0bd			 
e0bd			chk_stk_init: 
e0bd				; a vague random number to check so we dont get any "lucky" hits 
e0bd 3e 2d			ld a, 45 
e0bf 6f				ld l, a 
e0c0 00				nop 
e0c1 3e 17			ld a, 23 
e0c3 67				ld h, a 
e0c4			 
e0c4 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
e0c7			 
e0c7			;	ld (chk_stund), hl	; stack points.... 
e0c7 22 00 ef			ld (chk_stovr), hl 
e0ca 22 ec e9			ld (chk_ret_und), hl 
e0cd 22 aa e9			ld (chk_ret_ovr), hl 
e0d0 22 28 e9			ld (chk_loop_ovr), hl 
e0d3 22 26 e8			ld (chk_data_ovr), hl 
e0d6 c9				ret 
e0d7				 
e0d7			check_stacks: 
e0d7				; check all stack words 
e0d7			 
e0d7 e5				push hl 
e0d8 d5				push de 
e0d9			 
e0d9			;	ld de,(chk_word) 
e0d9			;	ld hl, (chk_stund)	; stack points.... 
e0d9			;	if DEBUG_STK_FAULT 
e0d9			;		DMARK "FAa" 
e0d9			;		CALLMONITOR 
e0d9			;	endif 
e0d9			;	call cmp16 
e0d9			;	jp z, .chk_faulta 
e0d9			; 
e0d9			;	ld de, sfaultsu 
e0d9			;	jp .chk_fault 
e0d9			 
e0d9 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e0dc ed 5b 9d e2		ld de,(chk_word) 
e0e0				if DEBUG_STK_FAULT 
e0e0					DMARK "FAb" 
e0e0					CALLMONITOR 
e0e0				endif 
e0e0 cd f9 8c			call cmp16 
e0e3 28 06			jr z, .chk_fault1 
e0e5 11 86 e1			ld de, sfaultso 
e0e8 c3 3a e1			jp .chk_fault 
e0eb			.chk_fault1:  
e0eb 2a ec e9			ld hl, (chk_ret_und) 
e0ee ed 5b 9d e2		ld de,(chk_word) 
e0f2				if DEBUG_STK_FAULT 
e0f2					DMARK "FAU" 
e0f2					CALLMONITOR 
e0f2				endif 
e0f2 cd f9 8c			call cmp16 
e0f5 ca fe e0			jp z, .chk_fault2 
e0f8 11 96 e1			ld de, sfaultru 
e0fb c3 3a e1			jp .chk_fault 
e0fe			.chk_fault2:  
e0fe 2a aa e9			ld hl, (chk_ret_ovr) 
e101 ed 5b 9d e2		ld de,(chk_word) 
e105				if DEBUG_STK_FAULT 
e105					DMARK "FA1" 
e105					CALLMONITOR 
e105				endif 
e105 cd f9 8c			call cmp16 
e108 ca 11 e1			jp z, .chk_fault3 
e10b 11 a4 e1			ld de, sfaultro 
e10e c3 3a e1			jp .chk_fault 
e111			.chk_fault3:  
e111 2a 28 e9			ld hl, (chk_loop_ovr) 
e114 ed 5b 9d e2		ld de,(chk_word) 
e118				if DEBUG_STK_FAULT 
e118					DMARK "FA2" 
e118					CALLMONITOR 
e118				endif 
e118 cd f9 8c			call cmp16 
e11b ca 24 e1			jp z, .chk_fault4 
e11e 11 be e1			ld de, sfaultlo 
e121 c3 3a e1			jp .chk_fault 
e124			.chk_fault4:  
e124 2a 26 e8			ld hl, (chk_data_ovr) 
e127 ed 5b 9d e2		ld de,(chk_word) 
e12b				if DEBUG_STK_FAULT 
e12b					DMARK "FA3" 
e12b					CALLMONITOR 
e12b				endif 
e12b cd f9 8c			call cmp16 
e12e ca 37 e1			jp z, .chk_fault5 
e131 11 d8 e1			ld de, sfaultdo 
e134 c3 3a e1			jp .chk_fault 
e137			 
e137			 
e137			.chk_fault5:  
e137 d1				pop de 
e138 e1				pop hl 
e139			 
e139 c9				ret 
e13a			 
e13a cd ae 8a		.chk_fault: 	call clear_display 
e13d 3e 28				ld a, display_row_2 
e13f cd c1 8a				call str_at_display 
e142 11 68 e1				   ld de, .stackfault 
e145 3e 00				ld a, display_row_1 
e147 cd c1 8a				call str_at_display 
e14a 11 6b ee				    ld de, debug_mark 
e14d 3e 11				ld a, display_row_1+17 
e14f cd c1 8a				call str_at_display 
e152 cd d1 8a				call update_display 
e155			 
e155				; prompt before entering montior for investigating issue 
e155			 
e155 3e 78			ld a, display_row_4 
e157 11 2d 98			ld de, endprog 
e15a			 
e15a cd d1 8a			call update_display		 
e15d			 
e15d cd b3 9a			call next_page_prompt 
e160			 
e160 d1				pop de 
e161 e1				pop hl 
e162 cd 81 98				call monitor 
e165 c3 8a 97				jp warmstart 
e168					;jp 0 
e168					;halt 
e168			 
e168			 
e168			 
e168 .. 00		.stackfault: 	db "Stack fault:",0 
e175			 
e175 .. 00		sfaultsu: 	db	"Stack under flow",0 
e186 .. 00		sfaultso: 	db	"Stack over flow",0 
e196 .. 00		sfaultru:	db "RTS underflow",0 
e1a4 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e1be .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e1d8 .. 00		sfaultdo:	db "DTS overflow", 0 
e1e5			 
e1e5			 
e1e5			fault_dsp_under: 
e1e5 11 f7 e1			ld de, .dsp_under 
e1e8 c3 a7 e2			jp .show_fault 
e1eb			 
e1eb			fault_rsp_under: 
e1eb 11 05 e2			ld de, .rsp_under 
e1ee c3 a7 e2			jp .show_fault 
e1f1			fault_loop_under: 
e1f1 11 13 e2			ld de, .loop_under 
e1f4 c3 a7 e2			jp .show_fault 
e1f7			 
e1f7 .. 00		.dsp_under: db "DSP Underflow",0 
e205 .. 00		.rsp_under: db "RSP Underflow",0 
e213 .. 00		.loop_under: db "LOOP Underflow",0 
e222			 
e222			 
e222 d5			type_faultn: 	push de 
e223 e5					push hl 
e224 cd ae 8a				call clear_display 
e227 11 4e e2				   ld de, .typefaultn 
e22a 3e 00				ld a, display_row_1 
e22c cd c1 8a				call str_at_display 
e22f 11 6b ee				    ld de, debug_mark 
e232 3e 11				ld a, display_row_1+17 
e234 cd c1 8a				call str_at_display 
e237 cd d1 8a				call update_display 
e23a			 
e23a				; prompt before entering montior for investigating issue 
e23a			 
e23a 3e 78			ld a, display_row_4 
e23c 11 2d 98			ld de, endprog 
e23f			 
e23f cd d1 8a			call update_display		 
e242			 
e242 cd b3 9a			call next_page_prompt 
e245			 
e245 e5					push hl 
e246 d5					push de 
e247 cd 81 98				call monitor 
e24a c3 8a 97				jp warmstart 
e24d 76					halt 
e24e			 
e24e			 
e24e .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e265			 
e265 d5			type_faults: 	push de 
e266 e5					push hl 
e267 cd ae 8a				call clear_display 
e26a 11 90 e2				   ld de, .typefaults 
e26d 3e 00				ld a, display_row_1 
e26f cd c1 8a				call str_at_display 
e272 11 6b ee				    ld de, debug_mark 
e275 3e 11				ld a, display_row_1+17 
e277 cd c1 8a				call str_at_display 
e27a cd d1 8a				call update_display 
e27d			 
e27d				; prompt before entering montior for investigating issue 
e27d			 
e27d 3e 78			ld a, display_row_4 
e27f 11 2d 98			ld de, endprog 
e282			 
e282 cd d1 8a			call update_display		 
e285			 
e285 cd b3 9a			call next_page_prompt 
e288			 
e288 e1					pop hl 
e289 d1					pop de 
e28a cd 81 98				call monitor 
e28d c3 8a 97				jp warmstart 
e290			 
e290			 
e290 .. 00		.typefaults: db "STR Type Expected TOS!",0 
e2a7			 
e2a7			.show_fault: 	 
e2a7 d5					push de 
e2a8 cd ae 8a				call clear_display 
e2ab d1					pop de 
e2ac 3e 00				ld a, display_row_1 
e2ae cd c1 8a				call str_at_display 
e2b1 11 6b ee				    ld de, debug_mark 
e2b4 3e 11				ld a, display_row_1+17 
e2b6 cd c1 8a				call str_at_display 
e2b9 cd d1 8a				call update_display 
e2bc			 
e2bc				; prompt before entering montior for investigating issue 
e2bc			 
e2bc 3e 78			ld a, display_row_4 
e2be 11 2d 98			ld de, endprog 
e2c1			 
e2c1 cd d1 8a			call update_display		 
e2c4			 
e2c4 cd b3 9a			call next_page_prompt 
e2c7			 
e2c7 e1					pop hl 
e2c8 d1					pop de 
e2c9 cd 81 98				call monitor 
e2cc			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e2cc			; TODO Make optional fault restart to cli or warm boot? 
e2cc					;jp warmstart 
e2cc c3 d4 97				jp cli 
e2cf 76					halt 
e2d0			 
e2d0			; handle the auto run of code from files in storage 
e2d0			 
e2d0			 
e2d0			include "forth_startup.asm" 
e2d0			; Which startup method to use? 
e2d0			; 
e2d0			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e2d0			; followed by loading of a list of scripts in eeprom 
e2d0			 
e2d0			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e2d0			; from eeprom 
e2d0			 
e2d0			; Select with define in main stubs 
e2d0			 
e2d0			if STARTUP_V1 
e2d0				include "forth_startupv1.asm" 
e2d0			; Startup script loading version 1 
e2d0			 
e2d0			; If SE storage is available first stage is to use the selected file 
e2d0			; then go through the eeprom list 
e2d0			 
e2d0 .. 00		sprompt1: db "Startup load...",0 
e2e0 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e2f6			 
e2f6			 
e2f6			 
e2f6			 
e2f6			forth_startup: 
e2f6 21 71 cd			ld hl, startcmds 
e2f9 3e 00			ld a, 0 
e2fb 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e2fe			 
e2fe e5			.start1:	push hl 
e2ff cd ae 8a			call clear_display 
e302 11 d0 e2			ld de, sprompt1 
e305 3e 00		        ld a, display_row_1 
e307 cd c1 8a			call str_at_display 
e30a 11 e0 e2			ld de, sprompt2 
e30d 3e 28		        ld a, display_row_2 
e30f cd c1 8a			call str_at_display 
e312 e1				pop hl 
e313 e5				push hl 
e314 5e				ld e,(hl) 
e315 23				inc hl 
e316 56				ld d,(hl) 
e317 3e 50		        ld a, display_row_3 
e319 cd c1 8a			call str_at_display 
e31c cd d1 8a			call update_display 
e31f			 
e31f			 
e31f 3a e7 e6			ld a, (os_last_cmd) 
e322 fe 00			cp 0 
e324 28 05			jr z, .startprompt 
e326 cd e5 89			call delay250ms 
e329 18 24			jr .startdo 
e32b				 
e32b				 
e32b			 
e32b			.startprompt: 
e32b			 
e32b 3e 9f			ld a,display_row_4 + display_cols - 1 
e32d 11 b1 9a		        ld de, endprg 
e330 cd c1 8a			call str_at_display 
e333 cd d1 8a			call update_display 
e336 cd f1 89			call delay1s 
e339 cd 5c e4			call cin_wait 
e33c						 
e33c fe 2a			cp '*' 
e33e 28 5e			jr z, .startupend1 
e340 fe 23			cp '#' 
e342 20 07			jr nz, .startno 
e344 3e 01			ld a, 1 
e346 32 e7 e6			ld (os_last_cmd),a 
e349 18 04			jr .startdo 
e34b fe 31		.startno:	cp '1' 
e34d 28 3a			jr z,.startnxt  
e34f			 
e34f				; exec startup line 
e34f			.startdo:	 
e34f e1				pop hl 
e350 e5				push hl 
e351				 
e351 5e				ld e,(hl) 
e352 23				inc hl 
e353 56				ld d,(hl) 
e354 eb				ex de,hl 
e355			 
e355 e5				push hl 
e356			 
e356 3e 00			ld a, 0 
e358				;ld a, FORTH_END_BUFFER 
e358 cd 44 91			call strlent 
e35b 23				inc hl   ; include zero term to copy 
e35c 06 00			ld b,0 
e35e 4d				ld c,l 
e35f e1				pop hl 
e360 11 c1 e2			ld de, scratch 
e363 ed b0			ldir 
e365			 
e365			 
e365 21 c1 e2			ld hl, scratch 
e368 cd 36 9f			call forthparse 
e36b cd 76 9f			call forthexec 
e36e cd 88 9e			call forthexec_cleanup 
e371			 
e371 3e 78			ld a, display_row_4 
e373 11 2d 98			ld de, endprog 
e376			 
e376 cd d1 8a			call update_display		 
e379			 
e379 3a e7 e6			ld a, (os_last_cmd) 
e37c fe 00			cp 0 
e37e 20 09			jr nz, .startnxt 
e380 cd b3 9a			call next_page_prompt 
e383 cd ae 8a		        call clear_display 
e386 cd d1 8a			call update_display		 
e389			 
e389				; move onto next startup line? 
e389			.startnxt: 
e389			 
e389 cd e5 89			call delay250ms 
e38c e1				pop hl 
e38d			 
e38d 23				inc hl 
e38e 23				inc hl 
e38f			 
e38f e5				push hl 
e390 5e				ld e, (hl) 
e391 23				inc hl 
e392 56				ld d, (hl) 
e393 e1				pop hl 
e394				; TODO replace 0 test 
e394			 
e394 eb				ex de, hl 
e395 cd 04 8d			call ishlzero 
e398			;	ld a,e 
e398			;	add d 
e398			;	cp 0    ; any left to do? 
e398 eb				ex de, hl 
e399 c2 fe e2			jp nz, .start1 
e39c 18 01			jr .startupend 
e39e			 
e39e e1			.startupend1: pop hl 
e39f			.startupend: 
e39f			 
e39f cd ae 8a			call clear_display 
e3a2 cd d1 8a			call update_display 
e3a5 c9				ret 
e3a6			if STORAGE_SE 
e3a6			 
e3a6			sprompt3: db "Loading from start-up file?:",0 
e3a6			sprompt4: db "(Y=Any key/N=No)",0 
e3a6			 
e3a6			 
e3a6			forth_autoload: 
e3a6			 
e3a6				; load block 0 of store 1 
e3a6				 
e3a6				ld a, $fe      ; bit 0 clear 
e3a6				ld (spi_device), a 
e3a6			 
e3a6				call storage_get_block_0 
e3a6			 
e3a6				ld a, (store_page+STORE_0_AUTOFILE) 
e3a6			 
e3a6				cp 0 
e3a6				ret z     ; auto start not enabled 
e3a6			 
e3a6				call clear_display 
e3a6			 
e3a6				; set bank 
e3a6			 
e3a6					ld a, (store_page+STORE_0_BANKRUN) 
e3a6					ld (spi_device), a 
e3a6			 
e3a6				; get file id to load from and get the file name to display 
e3a6			 
e3a6					ld a, (store_page+STORE_0_FILERUN) 
e3a6			 
e3a6					ld l, 0 
e3a6					ld h, a 
e3a6					ld de, store_page 
e3a6			 
e3a6					if DEBUG_FORTH_WORDS 
e3a6						DMARK "ASp" 
e3a6						CALLMONITOR 
e3a6					endif 
e3a6					call storage_read 
e3a6			 
e3a6					if DEBUG_FORTH_WORDS 
e3a6						DMARK "ASr" 
e3a6						CALLMONITOR 
e3a6					endif 
e3a6			 
e3a6					call ishlzero 
e3a6					ret z             ; file not found 
e3a6			 
e3a6					ld a, display_row_2 + 10 
e3a6					ld de, store_page+3 
e3a6					call str_at_display 
e3a6				 
e3a6			; 
e3a6			 
e3a6				ld a, display_row_1+5 
e3a6				ld de, sprompt3 
e3a6				call str_at_display 
e3a6				ld a, display_row_3+15 
e3a6				ld de, sprompt4 
e3a6				call str_at_display 
e3a6			 
e3a6				call update_display 
e3a6			 
e3a6				call cin_wait 
e3a6				cp 'n' 
e3a6				ret z 
e3a6				cp 'N' 
e3a6				ret z 
e3a6			 
e3a6				call delay1s 
e3a6			 
e3a6				ld a, (store_page+2) 
e3a6				ld (store_openmaxext), a    ; save count of ext 
e3a6				ld a, 1  
e3a6				ld (store_openext), a    ; save count of ext 
e3a6			 
e3a6			.autof:  
e3a6				ld l , a 
e3a6				 
e3a6				ld a, (store_page) 
e3a6				ld h, a	 
e3a6				ld de, store_page 
e3a6					if DEBUG_FORTH_WORDS 
e3a6						DMARK "ASl" 
e3a6						CALLMONITOR 
e3a6					endif 
e3a6					call storage_read 
e3a6				call ishlzero 
e3a6				ret z 
e3a6			;	jr z, .autoend 
e3a6			 
e3a6					if DEBUG_FORTH_WORDS 
e3a6						DMARK "ASc" 
e3a6						CALLMONITOR 
e3a6					endif 
e3a6				ld de, store_page+2 
e3a6				ld a, display_row_4 
e3a6				call str_at_display 
e3a6			 
e3a6				call update_display 
e3a6				call delay250ms 
e3a6			 
e3a6			 
e3a6			 
e3a6				ld hl, store_page+2 
e3a6				call forthparse 
e3a6				call forthexec 
e3a6				call forthexec_cleanup 
e3a6			 
e3a6				 
e3a6				ld a, (store_openext) 
e3a6				inc a 
e3a6				ld (store_openext), a    ; save count of ext 
e3a6			 
e3a6				jr .autof 
e3a6			;.autofdone: 
e3a6			; 
e3a6			;		if DEBUG_FORTH_WORDS 
e3a6			;			DMARK "ASx" 
e3a6			;			CALLMONITOR 
e3a6			;		endif 
e3a6			;;	call clear_display 
e3a6			;	ret 
e3a6			 
e3a6			 
e3a6			 
e3a6			endif 
# End of file forth_startupv1.asm
e3a6			endif 
e3a6			if STARTUP_V2 
e3a6				include "forth_startupv2.asm" 
e3a6			endif 
e3a6			 
# End of file forth_startup.asm
e3a6			 
e3a6			; eof 
# End of file forth_kernel.asm
e3a6			;include "nascombasic.asm" 
e3a6			 
e3a6			 
e3a6			; find out where the code ends if loaded into RAM (for SC114) 
e3a6			;endofcode:  
e3a6			;	nop 
e3a6			 
e3a6			 
e3a6			; jump to nmi vector 
e3a6			 
e3a6			init_nmi: 
e3a6 3e c9			ld a, $c9   ; RET 
e3a8 32 72 ee			ld (nmi_vector), a 
e3ab c9				ret 
e3ac			nmi: 
e3ac e5				push hl 
e3ad d5				push de 
e3ae c5				push bc 
e3af f5				push af 
e3b0 cd 72 ee			call nmi_vector 
e3b3 f5				push af 
e3b4 c5				push bc 
e3b5 d5				push de 
e3b6 e5				push hl 
e3b7 ed 4d			reti 
e3b9			 
e3b9			 
e3b9			; eof 
e3b9			 
# End of file main.asm
e3b9			;include "firmware_lcd_4x40.asm" 
e3b9			;;include "firmware_lcd_4x20.asm" 
e3b9			include "firmware_serial_display.asm" 
e3b9			 
e3b9			; Serial display interface for SC114 
e3b9			 
e3b9			 
e3b9			display_row_1: equ 0 
e3b9			display_row_2: equ display_row_1+display_cols 
e3b9			display_row_3: equ display_row_2 + display_cols 
e3b9			display_row_4: equ display_row_3 + display_cols 
e3b9			 
e3b9			kLCDWidth:  EQU display_cols             ;Width in characters 
e3b9			kLCD_Line1: EQU 0x00  
e3b9			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e3b9			; E1 
e3b9			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e3b9			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e3b9			 
e3b9			lcd_init: 
e3b9				; no init as handled by the SCM bios 
e3b9 c9				ret 
e3ba			 
e3ba			 
e3ba			; low level functions for direct screen writes 
e3ba			 
e3ba			; output char at pos? 
e3ba			fLCD_Str: 
e3ba			        ;out (SC114_SIO_1_OUT),a 
e3ba c5				push bc 
e3bb 0e 02			ld c, $02 
e3bd f7				rst $30 
e3be c1				pop bc 
e3bf c9				ret 
e3c0			 
e3c0			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e3c0			fLCD_Pos: 
e3c0				; use ASCII escape to position 
e3c0			        ;out (SC114_SIO_1_OUT),a 
e3c0 c5				push bc 
e3c1 0e 02			ld c, $02 
e3c3 f7				rst $30 
e3c4 c1				pop bc 
e3c5			 
e3c5 c9				ret 
e3c6			 
e3c6			; output char at pos 
e3c6			fLCD_Data: 
e3c6			      ;  out (SC114_SIO_1_OUT),a 
e3c6 c5				push bc 
e3c7 0e 02			ld c, $02 
e3c9 f7				rst $30 
e3ca c1				pop bc 
e3cb			 
e3cb c9				ret 
e3cc			 
e3cc			; ascii cls  
e3cc			 
e3cc 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e3d0			 
e3d0			; write the frame buffer given in hl to hardware  
e3d0			write_display: 
e3d0			 
e3d0			API: equ 0 
e3d0			 
e3d0			if API 
e3d0				push bc 
e3d0				ld b, 4 
e3d0			 
e3d0			        ld (display_write_tmp), hl 	  
e3d0			 
e3d0				; clear and home cursor 
e3d0			 
e3d0				ld c, 6 
e3d0				ld de, .cls 
e3d0				rst $30 
e3d0			 
e3d0			 
e3d0			.writeln: 
e3d0			 
e3d0				ld de, (display_write_tmp) 
e3d0				ld c, 6 
e3d0				rst $30 
e3d0				ld c, 7 
e3d0				rst $30 
e3d0			 
e3d0				ld hl, (display_write_tmp) 
e3d0				ld de, display_cols 
e3d0				add hl,de 
e3d0				ld (display_write_tmp),hl 
e3d0			 
e3d0				djnz  .writeln 
e3d0			 
e3d0				pop bc 
e3d0			 
e3d0			 
e3d0				ret 
e3d0			endif 
e3d0 e5				push hl 
e3d1 c5				push bc 
e3d2 d5				push de 
e3d3			 
e3d3			;	ld c, 2 
e3d3			;	;ld de, .cls 
e3d3			;	ld a, 27 
e3d3			;	rst $30 
e3d3			;	ld c, 2 
e3d3			;	;ld de, .cls 
e3d3			;	ld a, '[' 
e3d3			;	rst $30 
e3d3			; 
e3d3			;	ld c, 2 
e3d3			;	;ld de, .cls 
e3d3			;	ld a, 'H' 
e3d3			;	rst $30 
e3d3			; 
e3d3			 
e3d3 0e 02			ld c, 2 
e3d5				;ld de, .cls 
e3d5 3e 1b			ld a, 27 
e3d7 f7				rst $30 
e3d8			 
e3d8			 
e3d8 0e 02			ld c, 2 
e3da				;ld de, .cls 
e3da 3e 5b			ld a, '[' 
e3dc f7				rst $30 
e3dd 0e 02			ld c, 2 
e3df				;ld de, .cls 
e3df 3e 32			ld a, '2' 
e3e1 f7				rst $30 
e3e2 0e 02			ld c, 2 
e3e4				;ld de, .cls 
e3e4 3e 4a			ld a, 'J' 
e3e6 f7				rst $30 
e3e7 d1				pop de 
e3e8 c1				pop bc 
e3e9 e1				pop hl 
e3ea			 
e3ea			 
e3ea 22 c9 eb		        ld (display_write_tmp), hl 	  
e3ed 3e 00			ld a, kLCD_Line1 
e3ef			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e3ef 06 28			ld b, display_cols 
e3f1 ed 5b c9 eb		ld de, (display_write_tmp) 
e3f5 cd 53 e4			call write_len_string 
e3f8				 
e3f8			 
e3f8 e5			push hl 
e3f9 d5			push de 
e3fa c5			push bc 
e3fb 0e 07			ld c, 7 
e3fd f7				rst $30 
e3fe c1			pop bc 
e3ff d1			pop de 
e400 e1			pop hl 
e401			 
e401				 
e401 2a c9 eb			ld hl, (display_write_tmp) 
e404 11 28 00			ld de, display_cols 
e407 19				add hl,de 
e408 22 c9 eb			ld (display_write_tmp),hl 
e40b			 
e40b				 
e40b 3e 28			ld a, kLCD_Line2 
e40d			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e40d 06 28			ld b, display_cols 
e40f ed 5b c9 eb		ld de, (display_write_tmp) 
e413 cd 53 e4			call write_len_string 
e416				 
e416 2a c9 eb			ld hl, (display_write_tmp) 
e419 11 28 00			ld de, display_cols 
e41c 19				add hl,de 
e41d 22 c9 eb			ld (display_write_tmp),hl 
e420			 
e420 e5			push hl 
e421 d5			push de 
e422 c5			push bc 
e423 0e 07			ld c, 7 
e425 f7				rst $30 
e426 c1			pop bc 
e427 d1			pop de 
e428 e1			pop hl 
e429			 
e429				 
e429 3e 50			ld a, kLCD_Line3 
e42b			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e42b 06 28			ld b, display_cols 
e42d ed 5b c9 eb		ld de, (display_write_tmp) 
e431 cd 53 e4			call write_len_string 
e434				 
e434 2a c9 eb			ld hl, (display_write_tmp) 
e437 11 28 00			ld de, display_cols 
e43a 19				add hl,de 
e43b 22 c9 eb			ld (display_write_tmp),hl 
e43e			 
e43e e5			push hl 
e43f d5			push de 
e440 c5			push bc 
e441 0e 07			ld c, 7 
e443 f7				rst $30 
e444 c1			pop bc 
e445 d1			pop de 
e446 e1			pop hl 
e447			 
e447				 
e447 3e 78			ld a, kLCD_Line4 
e449			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e449 06 28			ld b, display_cols 
e44b ed 5b c9 eb		ld de, (display_write_tmp) 
e44f cd 53 e4			call write_len_string 
e452 c9					ret 
e453			 
e453			 
e453				; write out a fixed length string given in b from de 
e453			 
e453 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e454 cd c6 e3		            CALL fLCD_Data      ;Write character to display 
e457 13				inc de 
e458 10 f9			djnz write_len_string 
e45a c9				ret 
e45b			 
e45b			 
e45b			; eof 
# End of file firmware_serial_display.asm
e45b			;include "firmware_key_5x10.asm" 
e45b			;;include "firmware_key_4x10.asm" 
e45b			include "firmware_key_serial.asm" 
e45b			; Serial keyboard interface for SC114 
e45b			 
e45b			key_init: 
e45b				; no init as handled by the SCM bios 
e45b c9				ret 
e45c			 
e45c			 
e45c			cin_wait: 
e45c			;	ld a, 0 
e45c			;	ret 
e45c			 
e45c				;in a,(SC114_SIO_1_IN) 
e45c			        ; Use SCM API to get from whatever console device we are using 
e45c c5				push bc 
e45d 0e 01			ld c, $01 
e45f f7				rst $30 
e460 c1				pop bc 
e461 c9				ret 
e462			 
e462			cin: 
e462			 
e462			 
e462 c5				push bc 
e463			 
e463				; any key waiting to process? 
e463 0e 03			ld c, $03 
e465 f7				rst $30 
e466 28 05			jr z, .cin_skip 
e468			 
e468				; yep, get it 
e468			 
e468 0e 01			ld c, $01 
e46a f7				rst $30 
e46b c1				pop bc 
e46c c9				ret 
e46d			.cin_skip: 
e46d 3e 00			ld a, 0 
e46f c1				pop bc 
e470 c9				ret 
e471			 
e471			 
e471			 
e471			 
# End of file firmware_key_serial.asm
e471			endofcode:  
e471			baseram:  
e471 00				nop 
e472			 
e472			heap_start: equ baseram+15  ; Starting address of heap 
e472			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e472			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e472			;VDU:  EQU     endofcode           ; BASIC Work space 
e472			; eof 
e472			 
# End of file os_mega_sc114.asm
e472
