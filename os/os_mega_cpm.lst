# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 7c 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-11 21:57' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
011f			 
011f			 
011f			 
011f			;        nop  
011f			;        nop 
011f			;;	org 05h		; null out bdos call 
011f			; 
011f			;        nop  
011f			;        nop  
011f			;        nop 
011f			;;	org 08h 
011f			;;; 
011f			;;	jp cin		; rst 8 - char in 
011f			;;; 
011f			; 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;	org 010h 
011f			;; 
011f			;	jp cout		; rest 010h  - char out 
011f			;; 
011f			;	org 01bh   
011f			; 
011f			;	;jp  		; rst 01bh   - write string to display 
011f			;	jp str_at_display 
011f			; 
011f			; 
011f			;	org 020h 
011f			; 
011f			;	; jp		 ; rst 020h - read char at screen location 
011f			; 
011f			;	org 028h 
011f			 
011f				; jp		 ; rst 028h  - storage i/o 
011f			 
011f			; 	org 030h 
011f			;	jp break_point_state 
011f			  
011f			; $30  
011f			; org 038h 
011f			; $38 
011f			 
011f			; TODO any more important entry points to add to jump table for easier coding use? 
011f			 
011f			if BASE_KEV = 1  
011f			 
011f				; need to be at $66 for nmi support 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255 
011f				jp nmi 
011f			endif 
011f			 
011f			include "firmware.asm" 
011f			  
011f			; main constants (used here and in firmware)  
011f			  
011f			; TODO have page 0 of storage as bios  
011f			  
011f			Device_A: equ 0h  
011f			Device_B: equ 040h          ; Sound  
011f			  
011f			if BASE_KEV  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_SC114  
011f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			; TODO fixup for CPM  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			Device_D: equ 0c0h             ; Keyboard and LCD  
011f			  
011f			; Odd specific debug points for testing hardware dev  
011f			  
011f			;if DEBUG_LEVEL0  
011f			;	include "debug_level0.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL1  
011f			;	include "debug_level1.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL2  
011f			;	include "debug_level2.asm"  
011f			;endif  
011f			  
011f			  
011f			CALLMONITOR: macro  
011f			;	call break_point_state  
011f			; now use the break point debug vector  
011f				call debug_vector  
011f				endm  
011f			  
011f			MALLOC_1: equ 1        ; from dk88   
011f			MALLOC_2: equ 0           ; broke  
011f			MALLOC_3: equ 0           ; really broke  
011f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011f			  
011f			if BASE_KEV   
011f			;stacksize: equ 256  
011f			; each stack entry is three bytes (type + word)  
011f			stacksize: equ 3*150  
011f			  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 512  
011f			endif  
011f			if BASE_SC114  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			;if STORAGE_SE == 0  
011f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011f			;endif  
011f			  
011f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011f			  
011f			STORE_0_AUTORUN: equ $20  
011f			  
011f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011f			  
011f			STORE_0_AUTOFILE: equ $21  
011f			STORE_0_BANKRUN: equ $23  
011f			STORE_0_FILERUN: equ $24  
011f			  
011f			; Block 0 offsets for settings  
011f			  
011f			; if set then skip prompt for start up and accept all  
011f			  
011f			STORE_0_QUICKSTART: equ $25  
011f			  
011f			; Blocks where directory table is held  
011f			  
011f			; Reducing the number of entries increases the max file size  
011f			  
011f			;STORE_DIR_START: equ 1  
011f			;STORE_DIR_END: equ 33  
011f			  
011f			; Blocks from where file data is stored  
011f			  
011f			;STORE_DATA_START: equ STORE_DIR_END + 1  
011f			  
011f			; Block indicators (<32 are data files)  
011f			  
011f			;STORE_BLOCK_CFG: equ $8f       ; config block  
011f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011f			;STORE_BLOCK_FREE: equ $85       ; data block free  
011f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011f			  
011f			  
011f			  
011f			; Directory entry flags  
011f			  
011f			;STORE_DIR_FREE: equ 0  
011f			;STORE_DIR_FILE:  equ 1  
011f			  
011f			; Structure offsets to directory entries  
011f			;STORE_DE_FLAG: equ 0  
011f			;STORE_DE_MAXEXT: equ 1  
011f			;STORE_DE_FILENAME: equ 2  
011f			  
011f			; Structure offsets to block 0  
011f			  
011f			;STORE_BK0_ISFOR: equ 1  
011f			;STORE_BK0_LABEL: equ 3  
011f			  
011f			; memory allocation   
011f			  
011f			chk_stund: equ tos+2           ; underflow check word  
011f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011f			  
011f			; keyscan table needs rows x cols buffer  
011f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011f			  
011f			keyscan_table_row1: equ chk_stovr -key_cols-1  
011f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011f			keyscan_scancol: equ keyscan_table-key_cols  
011f			;keyscan_table_len: equ key_rows*key_cols  
011f			;keybufptr: equ keyscan_table - 2  
011f			;keysymbol: equ keybufptr - 1  
011f			key_held: equ keyscan_scancol-1	; currently held  
011f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011f			key_fa: equ key_repeat_ct -1 ;  
011f			key_fb: equ key_fa -1 ;  
011f			key_fc: equ key_fb -1 ;  
011f			key_fd: equ key_fc -1 ;  
011f			key_face_held: equ key_fd - 1   
011f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011f			  
011f			hardware_config: equ key_face_held - 10  
011f			  
011f			; hardware config switches  
011f			; TODO add bitmasks on includes for hardware  
011f			; high byte for expansion ids  
011f			;     0000 0000  no card inserted  
011f			;     0000 0001  storage card inserted  
011f			;     0000 0010  spi sd card active  
011f			  
011f			;       
011f			; low byte:  
011f			;     0000 0001   4x4 keypad  
011f			;     0000 0010   full keyboard  
011f			;     0000 0011   spi/ext keyboard  
011f			;     0000 0100   20x4 lcd  
011f			;     0000 1000   40x4 lcd  
011f			;     0000 1100   spi/ext display  
011f			;     0001 0000   ide interface available  
011f			  
011f			hardware_word: equ hardware_config - 2  
011f			  
011f			; debug marker - optional display of debug point on the debug screens  
011f			  
011f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011f			  
011f			debug_umark: equ debug_vector - 6  ; current user mark  
011f			debug_mark: equ debug_umark - 4    ; internal word debug points  
011f			  
011f			; input_str vars  
011f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011f			input_size: equ input_start -1  ; number of chars  
011f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011f			input_len: equ input_cur_onoff - 5 ; length of current input  
011f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011f			  
011f			; cursor blink rate  
011f			CUR_BLINK_RATE: equ $09  
011f			;CUR_BLINK_RATE: equ 15  
011f			  
011f			key_actual_pressed: equ input_cursor - 1   
011f			key_symbol: equ key_actual_pressed - 1   
011f			key_shift: equ key_symbol - 1   
011f			  
011f			; Display allocation  
011f			  
011f			;display_rows: equ 4     ; move out to mini and mega files  
011f			;display_cols: equ 20  
011f			  
011f			display_fb_len: equ display_rows*display_cols  
011f			  
011f			; primary frame buffer     
011f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011f			; working frame buffers  
011f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011f			display_fb3: equ  display_fb1-display_fb_len - 1  
011f			display_fb2: equ  display_fb3-display_fb_len - 1  
011f			;  
011f			; pointer to active frame buffer  
011f			display_fb_active: equ display_fb2 - 2  
011f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011f			display_write_tmp: equ display_lcde1e2 - 2  
011f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011f			  
011f			;  
011f			  
011f			;; can load into de directory  
011f			cursor_col: equ display_active-1  
011f			cursor_row: equ cursor_col-1  
011f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011f			  
011f			; maths vars  
011f			  
011f			LFSRSeed: equ cursor_shape -20   
011f			randData: equ LFSRSeed - 2  
011f			xrandc: equ randData - 2  
011f			stackstore: equ xrandc - 2  
011f			seed1: equ  stackstore -2   
011f			seed2: equ seed1 - 2  
011f			  
011f			; cf storage vars  
011f			  
011f			iErrorNum:  equ seed2-1         ;Error number  
011f			iErrorReg:  equ iErrorNum -1              ;Error register  
011f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011f			  
011f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011f			  
011f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011f			  
011f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011f			store_tmpid: equ store_tmp3 - 1		; page temp id  
011f			store_tmpext: equ store_tmpid - 1		; file extent temp  
011f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011f			;  
011f			; spi vars  
011f			  
011f			  
011f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011f			spi_device_id: equ spi_device - 1    ; human readable bank number  
011f			  
011f			;;;;; forth cli params  
011f			  
011f			; TODO use a different frame buffer for forth???  
011f			  
011f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011f			  
011f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011f			  
011f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011f			  
011f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011f			  
011f			; os/forth token vars  
011f			  
011f			os_last_cmd: equ os_var_array-255  
011f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011f			os_current_i: equ os_cli_cmd-2  
011f			os_cur_ptr: equ os_current_i-2  
011f			os_word_scratch: equ os_cur_ptr-30  
011f			os_tok_len: equ os_word_scratch - 2  
011f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011f			os_tok_malloc: equ os_tok_ptr - 2  
011f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011f			execscratch: equ os_input-255        ; exec cmd eval buffer  
011f			scratch: equ execscratch-255  
011f			  
011f			os_stack_1: equ scratch - 3       ; stack holding area 1  
011f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011f			  
011f			  
011f			; temp locations for new word processing to save on adding more   
011f			  
011f			os_new_malloc: equ os_stack_4-2  
011f			os_new_parse_len: equ os_new_malloc - 2  
011f			os_new_word_len: equ os_new_parse_len - 2  
011f			os_new_work_ptr: equ os_new_word_len - 2  
011f			os_new_src_ptr: equ os_new_work_ptr - 2  
011f			os_new_exec: equ os_new_src_ptr - 2  
011f			os_new_exec_ptr: equ os_new_exec - 2  
011f			  
011f			; resume memory alloocations....  
011f			  
011f			;os_view_disable: equ os_new_exec_ptr - 1  
011f			os_view_af: equ os_new_exec_ptr - 2  
011f			os_view_hl: equ os_view_af -2  
011f			os_view_de: equ os_view_hl - 2  
011f			os_view_bc: equ os_view_de - 2  
011f			  
011f			; stack checksum word  
011f			if DEBUG_STACK_IMB  
011f				curframe: equ  os_view_de - 5  
011f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			else  
011f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			endif  
011f			  
011f			; with data stack could see memory filled with junk. need some memory management   
011f			; malloc and free entry points added  
011f			  
011f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			;heap_end: equ free_list-1  ; Starting address of heap  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			heap_end: equ chk_word-1  ; Starting address of heap  
011f			  
011f			  
011f			;if BASE_KEV   
011f			;heap_start: equ 0800eh  ; Starting address of heap  
011f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;heap_start: equ baseram+15  ; Starting address of heap  
011f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;endif  
011f			  
011f			  
011f			;;;;  
011f			  
011f			  
011f			; change below to point to last memory alloc above  
011f			topusermem:  equ   heap_start  
011f			  
011f			;if BASE_KEV   
011f			;baseusermem: equ 08000h  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;;aseusermem:     equ    12  
011f			;baseusermem:     equ    prompt  
011f			;;baseusermem:     equ    endofcode  
011f			;endif  
011f			  
011f			  
011f			; **********************************************************************  
011f			; **  Constants  
011f			; **********************************************************************  
011f			  
011f			; Constants used by this code module  
011f			kDataReg:   EQU Device_D           ;PIO port A data register  
011f			kContReg:   EQU Device_D+2           ;PIO port A control register  
011f			  
011f			  
011f			portbdata:  equ Device_D+1    ; port b data  
011f			portbctl:   equ Device_D+3    ; port b control  
011f			  
011f			  
011f			;KEY_SHIFT:   equ 5  
011f			;KEY_SYMBOLSHIFT:  equ 6  
011f			  
011f			KEY_SHIFTLOCK: equ 4  
011f			  
011f			  
011f			KEY_UP: equ 5  
011f			KEY_NEXTWORD: equ 6  
011f			KEY_PREVWORD: equ 7  
011f			KEY_BS: equ 8  
011f			KEY_TAB:  equ 9  
011f			KEY_DOWN: equ 10  
011f			KEY_LEFT: equ 11  
011f			KEY_RIGHT: equ 12  
011f			KEY_CR:   equ 13  
011f			KEY_HOME: equ 14  
011f			KEY_END: equ 15  
011f			  
011f			KEY_F1: equ 16  
011f			KEY_F2: equ 17  
011f			KEY_F3: equ 18  
011f			KEY_F4: equ 19  
011f			  
011f			KEY_F5: equ 20  
011f			KEY_F6: equ 21  
011f			KEY_F7: equ 22  
011f			KEY_F8: equ 23  
011f			  
011f			KEY_F9: equ 24  
011f			KEY_F10: equ 25  
011f			KEY_F11: equ 26  
011f			KEY_F12: equ 27  
011f			  
011f			;if DEBUG_KEY  
011f			;	KEY_MATRIX_NO_PRESS: equ '.'  
011f			;	KEY_SHIFT:   equ '.'  
011f			;	KEY_SYMBOLSHIFT:  equ '.'  
011f			;else  
011f				KEY_SHIFT:   equ '~'  
011f				KEY_SYMBOLSHIFT:  equ '~'  
011f				KEY_MATRIX_NO_PRESS: equ '~'  
011f			;endi  
011f			  
011f			  
011f			  
011f			  
011f			; Macro to make adding debug marks easier  
011f			  
011f			DMARK: macro str  
011f				push af  
011f				ld a, (.dmark)  
011f				ld (debug_mark),a  
011f				ld a, (.dmark+1)  
011f				ld (debug_mark+1),a  
011f				ld a, (.dmark+2)  
011f				ld (debug_mark+2),a  
011f				jr .pastdmark  
011f			.dmark: db str  
011f			.pastdmark: pop af  
011f			  
011f			endm  
011f			  
011f			  
011f			; macro to detect for stack imbalances  
011f			  
011f			include "stackimbal.asm"  
011f			; Macro and code to detect stock imbalances 
011f			 
011f			SPPUSH: equ 0 
011f			 
011f			; Add a stack frame which can be checked before return 
011f			 
011f			STACKFRAME: macro onoff frame1 frame2 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f						exx 
011f			 
011f						ld de, frame1 
011f						ld a, d 
011f						ld hl, curframe 
011f						call hexout 
011f						ld a, e 
011f						ld hl, curframe+2 
011f						call hexout 
011f			  
011f						ld hl, frame1 
011f						push hl 
011f						ld hl, frame2 
011f						push hl 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			endm 
011f			 
011f			STACKFRAMECHK: macro onoff frame1 frame2 
011f			 
011f					 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						exx 
011f						; check stack frame SP 
011f			 
011f						ld hl, frame2 
011f						pop de   ; frame2 
011f			 
011f						call cmp16 
011f						jr nz, .spnosame 
011f						 
011f			 
011f						ld hl, frame1 
011f						pop de   ; frame1 
011f			 
011f						call cmp16 
011f						jr z, .spfrsame 
011f			 
011f						.spnosame: call showsperror 
011f			 
011f						.spfrsame: nop 
011f			 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			 
011f			 
011f			endm 
011f			 
011f			 
011f			; for a sub routine, wrap SP collection and comparisons 
011f			 
011f			; Usage: 
011f			; 
011f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011f			 
011f			SAVESP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f			 
011f						ld (store_sp+(storeword*4)), sp 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			CHECKSP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f			 
011f						; save SP after last save 
011f				 
011f						ld (store_sp+(storeword*4)+2), sp 
011f			 
011f						push hl 
011f						ld hl, store_sp+(storeword*4) 
011f						call check_stack_sp  
011f						pop hl 
011f			 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			if DEBUG_STACK_IMB 
011f			 
011f			check_stack_sp: 
011f					push de 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					push de 
011f			 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					pop hl 
011f			 
011f			 
011f					; check to see if the same 
011f			 
011f					call cmp16 
011f					jr z, .spsame 
011f			 
011f					; not same 
011f			 
011f					call showsperror 
011f			.spsame: 
011f			 
011f					pop de 
011f			 
011f					ret 
011f			 
011f			.sperr:  db "Stack imbalance",0 
011f			 
011f			 
011f			showsperror: 
011f			 
011f			 
011f				push hl 
011f				push af 
011f				push de 
011f				call clear_display 
011f				ld de, .sperr 
011f				ld a,0 
011f			;	ld de,os_word_scratch 
011f				call str_at_display 
011f				ld a, display_row_1+17 
011f				ld de, debug_mark 
011f				call str_at_display 
011f				ld a, 0 
011f				ld (curframe+4),a 
011f				ld hl, curframe 
011f				ld de, os_word_scratch 
011f				ld a, display_row_4 
011f				call str_at_display 
011f				call update_display 
011f				;call break_point_state 
011f				call cin_wait 
011f			 
011f			;	ld a, ' ' 
011f			;	ld (os_view_disable), a 
011f				call bp_on 
011f				pop de	 
011f				pop af 
011f				pop hl 
011f				CALLMONITOR 
011f				ret 
011f			 
011f			endif 
011f			 
011f			 
011f			 
011f			; eof 
# End of file stackimbal.asm
011f			  
011f			;TODO macro to calc col and row offset into screen  
011f			  
011f			  
011f			  
011f			hardware_init:  
011f			  
011f				  
011f			  
011f					;ld a, 0  
011f					;ld (hardware_diag), a  
011f			  
011f					; clear all the buffers  
011f			  
011f 21 0a ed				ld hl, display_fb1  
0122 22 c6 eb				ld (display_fb_active), hl  
0125			  
0125 cd c8 0b				call clear_display  
0128			  
0128 21 c8 eb				ld hl, display_fb2  
012b 22 c6 eb				ld (display_fb_active), hl  
012e			  
012e cd c8 0b				call clear_display  
0131			  
0131					; init primary frame buffer area  
0131 21 ab ed				ld hl, display_fb0  
0134 22 c6 eb				ld (display_fb_active), hl  
0137			  
0137 cd c8 0b				call clear_display  
013a			  
013a			  
013a cd 40 5e				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013d			  
013d cd 2e 5f			call key_init  
0140 cd ad 01			call storage_init  
0143			  
0143				; setup malloc functions  
0143			  
0143				if MALLOC_1  
0143 cd ac 11				call  heap_init  
0146				endif  
0146				if MALLOC_4  
0146					call  heap_init  
0146				endif  
0146			  
0146				; init sound hardware if present  
0146			  
0146				if SOUND_ENABLE  
0146					call sound_init  
0146				endif  
0146			  
0146				; lcd test sequence  
0146					  
0146 cd eb 0b			call update_display  
0149 cd 00 0b			call delay1s  
014c 3e 2b			ld a,'+'  
014e cd cd 0b			call fill_display  
0151 cd eb 0b			call update_display  
0154 cd 00 0b			call delay1s  
0157 3e 2a			ld a,'*'  
0159 cd cd 0b			call fill_display  
015c cd eb 0b			call update_display  
015f cd 00 0b			call delay1s  
0162 3e 2d			ld a,'-'  
0164 cd cd 0b			call fill_display  
0167 cd eb 0b			call update_display  
016a cd 00 0b			call delay1s  
016d			  
016d			; boot splash screen  
016d			if display_cols == 20	  
016d			        ld a, display_row_1    
016d			else  
016d 3e 0a		        ld a, display_row_1 +10   
016f			endif  
016f 11 da 16			ld de, prom_bootmsg  
0172 cd db 0b			call str_at_display  
0175 cd eb 0b			call update_display  
0178			  
0178			  
0178 cd 00 0b			call delay1s  
017b cd 00 0b			call delay1s  
017e			if display_cols == 20	  
017e			            LD   A, display_row_3+2  
017e			else  
017e 3e 5c		            LD   A, display_row_3+12  
0180			endif  
0180 11 ef 16			ld de, prom_bootmsg1  
0183 cd db 0b			call str_at_display  
0186			; display debug level  
0186 3e 78		            LD   A, display_row_4  
0188 11 1b 01			ld de, debuglevel  
018b cd db 0b			call str_at_display  
018e			  
018e cd eb 0b			call update_display  
0191 cd 00 0b			call delay1s  
0194 cd 00 0b			call delay1s  
0197			  
0197			;	ld a, display_row_4+3  
0197			;	ld de, bootmsg2  
0197			;	call str_at_display  
0197			;	call update_display  
0197			;	call delay1s  
0197			;	call delay1s  
0197			  
0197			; debug mark setup  
0197			  
0197 3e 5f		ld a, '_'  
0199 32 65 ee		ld (debug_mark),a  
019c 32 66 ee		ld (debug_mark+1),a  
019f 32 67 ee		ld (debug_mark+2),a  
01a2 3e 00		ld a,0  
01a4 32 68 ee		ld (debug_mark+3),a  
01a7 32 69 ee		ld (debug_umark),a  
01aa			  
01aa c9					ret  
01ab			  
01ab			  
01ab			;bootmsg2:	db "Firmware v0.1",0  
01ab			  
01ab			; a 4x20 lcd  
01ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ab			  
01ab			;if display_cols == 20  
01ab			;	include "firmware_lcd_4x20.asm"  
01ab			;endif  
01ab			  
01ab			;if display_cols == 40  
01ab			;	include "firmware_lcd_4x40.asm"  
01ab			;endif  
01ab			  
01ab			;  
01ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ab			; TODO abstract the bit bang video out interface for dual display  
01ab			; TODO wire video out to tx pin on rc2014 bus  
01ab			  
01ab			; must supply cin, and cin_wait for low level hardware abstraction   
01ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ab			; test scancode  
01ab			  
01ab			;;;;;  
01ab			;;;  
01ab			; Moved out to mini and maxi versions  
01ab			;  
01ab			; include "firmware_key_4x4.asm"  
01ab			; using existing 4 wire x 4 resistor array for input  
01ab			;include "firmware_key_4x10.asm"  
01ab			; need to mod the board for 5 rows due to resistor array  
01ab			;include "firmware_key_5x10.asm"  
01ab			  
01ab			; storage hardware interface  
01ab			  
01ab			; use microchip serial eeprom for storage  
01ab			  
01ab			  
01ab			if STORAGE_SE  
01ab				include "firmware_spi.asm"  
01ab				include "firmware_seeprom.asm"  
01ab			else  
01ab			   ; create some stubs for the labels  
01ab c9			se_readbyte: ret  
01ac c9			se_writebyte: ret  
01ad c9			storage_init: ret  
01ae			  
01ae			endif  
01ae			  
01ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01ae			;include "firmware_cf.asm"  
01ae			  
01ae			; load up high level storage hardward abstractions  
01ae			include "firmware_storage.asm"  
01ae			 
01ae			; persisent storage hardware abstraction layer  
01ae			 
01ae			 
01ae			 
01ae			; Block 0 on storage is a config state 
01ae			 
01ae			 
01ae			 
01ae			; TODO add read phy block and write phy block functions 
01ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01ae			 
01ae			; Abstraction layer  
01ae			 
01ae			; Logocial block size is same size as physical size - using tape concept 
01ae			 
01ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01ae			 
01ae			 
01ae			 
01ae			; Filesystem layout (Logical layout) 
01ae			; 
01ae			; Block 0 - Bank config  
01ae			; 
01ae			;      Byte - 0 file id counter 
01ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01ae			;      Byte - 3-20 zero terminated bank label 
01ae			; 
01ae			; Block 1 > File storage 
01ae			; 
01ae			;      Byte 0 file id    - block 0 file details 
01ae			;      Byte 1 block id - block 0 is file  
01ae			;            Byte 2-15 - File name 
01ae			; 
01ae			;       - to end of block data 
01ae			; 
01ae			 
01ae			; Get ID for the file named in pointer held HL 
01ae			; Returns ID in HL = 255 if no file found 
01ae			 
01ae			storage_getid: 
01ae			 
01ae 22 6d ea			ld (store_tmp1), hl 
01b1			 
01b1				if DEBUG_STORESE 
01b1					DMARK "SGI" 
01b1 f5				push af  
01b2 3a c6 01			ld a, (.dmark)  
01b5 32 65 ee			ld (debug_mark),a  
01b8 3a c7 01			ld a, (.dmark+1)  
01bb 32 66 ee			ld (debug_mark+1),a  
01be 3a c8 01			ld a, (.dmark+2)  
01c1 32 67 ee			ld (debug_mark+2),a  
01c4 18 03			jr .pastdmark  
01c6 ..			.dmark: db "SGI"  
01c9 f1			.pastdmark: pop af  
01ca			endm  
# End of macro DMARK
01ca					CALLMONITOR 
01ca cd 6f ee			call debug_vector  
01cd				endm  
# End of macro CALLMONITOR
01cd				endif 
01cd				; get block 0 and set counter for number of files to scan 
01cd			 
01cd cd 38 03			call storage_get_block_0 
01d0			 
01d0 3a 74 ea			ld a, (store_page) 
01d3 47				ld b, a 
01d4			 
01d4				; get extent 0 of each file id 
01d4			 
01d4				if DEBUG_STORESE 
01d4					DMARK "SGc" 
01d4 f5				push af  
01d5 3a e9 01			ld a, (.dmark)  
01d8 32 65 ee			ld (debug_mark),a  
01db 3a ea 01			ld a, (.dmark+1)  
01de 32 66 ee			ld (debug_mark+1),a  
01e1 3a eb 01			ld a, (.dmark+2)  
01e4 32 67 ee			ld (debug_mark+2),a  
01e7 18 03			jr .pastdmark  
01e9 ..			.dmark: db "SGc"  
01ec f1			.pastdmark: pop af  
01ed			endm  
# End of macro DMARK
01ed					CALLMONITOR 
01ed cd 6f ee			call debug_vector  
01f0				endm  
# End of macro CALLMONITOR
01f0				endif 
01f0 60			.getloop:	ld h, b 
01f1 2e 00				ld l, 0 
01f3 c5					push bc 
01f4			 
01f4 11 74 ea				ld de, store_page 
01f7				if DEBUG_STORESE 
01f7					DMARK "SGr" 
01f7 f5				push af  
01f8 3a 0c 02			ld a, (.dmark)  
01fb 32 65 ee			ld (debug_mark),a  
01fe 3a 0d 02			ld a, (.dmark+1)  
0201 32 66 ee			ld (debug_mark+1),a  
0204 3a 0e 02			ld a, (.dmark+2)  
0207 32 67 ee			ld (debug_mark+2),a  
020a 18 03			jr .pastdmark  
020c ..			.dmark: db "SGr"  
020f f1			.pastdmark: pop af  
0210			endm  
# End of macro DMARK
0210					CALLMONITOR 
0210 cd 6f ee			call debug_vector  
0213				endm  
# End of macro CALLMONITOR
0213				endif 
0213 cd e0 07				call storage_read 
0216 cd 1e 0e				call ishlzero 
0219 28 2d				jr z, .gap 
021b					 
021b					; have a file name read. Is it one we want. 
021b			 
021b 2a 6d ea				ld hl, (store_tmp1) 
021e 11 77 ea				ld de, store_page+3   ; file name 
0221			 
0221				if DEBUG_STORESE 
0221					DMARK "SGc" 
0221 f5				push af  
0222 3a 36 02			ld a, (.dmark)  
0225 32 65 ee			ld (debug_mark),a  
0228 3a 37 02			ld a, (.dmark+1)  
022b 32 66 ee			ld (debug_mark+1),a  
022e 3a 38 02			ld a, (.dmark+2)  
0231 32 67 ee			ld (debug_mark+2),a  
0234 18 03			jr .pastdmark  
0236 ..			.dmark: db "SGc"  
0239 f1			.pastdmark: pop af  
023a			endm  
# End of macro DMARK
023a					CALLMONITOR 
023a cd 6f ee			call debug_vector  
023d				endm  
# End of macro CALLMONITOR
023d				endif 
023d cd 93 11				call strcmp 
0240 20 06				jr nz, .gap   ; not this one 
0242			 
0242 c1				        pop bc 
0243			 
0243 26 00				ld h, 0 
0245 68					ld l, b 
0246 18 22				jr .getdone 
0248						 
0248			 
0248			 
0248			 
0248			.gap: 
0248				if DEBUG_STORESE 
0248					DMARK "SGg" 
0248 f5				push af  
0249 3a 5d 02			ld a, (.dmark)  
024c 32 65 ee			ld (debug_mark),a  
024f 3a 5e 02			ld a, (.dmark+1)  
0252 32 66 ee			ld (debug_mark+1),a  
0255 3a 5f 02			ld a, (.dmark+2)  
0258 32 67 ee			ld (debug_mark+2),a  
025b 18 03			jr .pastdmark  
025d ..			.dmark: db "SGg"  
0260 f1			.pastdmark: pop af  
0261			endm  
# End of macro DMARK
0261					CALLMONITOR 
0261 cd 6f ee			call debug_vector  
0264				endm  
# End of macro CALLMONITOR
0264				endif 
0264			 
0264 c1					pop bc 
0265 10 89				djnz .getloop 
0267 21 ff 00				ld hl, 255 
026a			.getdone: 
026a			 
026a				if DEBUG_STORESE 
026a					DMARK "SGe" 
026a f5				push af  
026b 3a 7f 02			ld a, (.dmark)  
026e 32 65 ee			ld (debug_mark),a  
0271 3a 80 02			ld a, (.dmark+1)  
0274 32 66 ee			ld (debug_mark+1),a  
0277 3a 81 02			ld a, (.dmark+2)  
027a 32 67 ee			ld (debug_mark+2),a  
027d 18 03			jr .pastdmark  
027f ..			.dmark: db "SGe"  
0282 f1			.pastdmark: pop af  
0283			endm  
# End of macro DMARK
0283					CALLMONITOR 
0283 cd 6f ee			call debug_vector  
0286				endm  
# End of macro CALLMONITOR
0286				endif 
0286			 
0286 c9				ret 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			; Read Block 
0287			; ---------- 
0287			; 
0287			; With current bank 
0287			;  
0287			; Get block number to read 
0287			; Load physical blocks starting at start block into buffer 
0287			 
0287			; de points to buffer to use 
0287			; hl holds logical block number  
0287			 
0287			storage_read_block: 
0287			 
0287				; TODO bank selection 
0287			 
0287				; for each of the physical blocks read it into the buffer 
0287 06 40			ld b, STORE_BLOCK_PHY 
0289			 
0289				if DEBUG_STORESE 
0289 d5					push de 
028a				endif 
028a				 
028a			.rl1:    
028a			 
028a				; read physical block at hl into de 
028a			        ; increment hl and de to next read position on exit 
028a			 
028a e5				push hl 
028b d5				push de	 
028c c5				push bc 
028d			;	if DEBUG_STORESE 
028d			;		push af 
028d			;		ld a, 'R' 
028d			;		ld (debug_mark),a 
028d			;		pop af 
028d			;		CALLMONITOR 
028d			;	endif 
028d cd ab 01			call se_readbyte 
0290			;	if DEBUG_STORESE 
0290			;		ld a,(spi_portbyte) 
0290			;		ld l, a 
0290			;		push af 
0290			;		ld a, '1' 
0290			;		ld (debug_mark),a 
0290			;		pop af 
0290			;		CALLMONITOR 
0290			;	endif 
0290 c1				pop bc 
0291 d1				pop de 
0292 e1				pop hl 
0293 12				ld (de),a 
0294 23				inc hl 
0295 13				inc de 
0296			 
0296			;	if DEBUG_STORESE 
0296			;		push af 
0296			;		ld a, 'r' 
0296			;		ld (debug_mark),a 
0296			;		pop af 
0296			;		CALLMONITOR 
0296			;	endif 
0296			 
0296 10 f2			djnz .rl1 
0298			 
0298				if DEBUG_STORESE 
0298					DMARK "SRB" 
0298 f5				push af  
0299 3a ad 02			ld a, (.dmark)  
029c 32 65 ee			ld (debug_mark),a  
029f 3a ae 02			ld a, (.dmark+1)  
02a2 32 66 ee			ld (debug_mark+1),a  
02a5 3a af 02			ld a, (.dmark+2)  
02a8 32 67 ee			ld (debug_mark+2),a  
02ab 18 03			jr .pastdmark  
02ad ..			.dmark: db "SRB"  
02b0 f1			.pastdmark: pop af  
02b1			endm  
# End of macro DMARK
02b1 d1					pop de 
02b2			; 
02b2			;		push af 
02b2			;		ld a, 'R' 
02b2			;		ld (debug_mark),a 
02b2			;		pop af 
02b2					CALLMONITOR 
02b2 cd 6f ee			call debug_vector  
02b5				endm  
# End of macro CALLMONITOR
02b5				endif 
02b5 c9				ret	 
02b6				 
02b6			 
02b6			; File Size 
02b6			; --------- 
02b6			; 
02b6			;   hl file id 
02b6			; 
02b6			;  returns in hl the number of blocks 
02b6			 
02b6			storage_file_size: 
02b6 5d				ld e, l 
02b7 16 00			ld d, 0 
02b9 21 40 00			ld hl, STORE_BLOCK_PHY 
02bc					if DEBUG_FORTH_WORDS 
02bc						DMARK "SIZ" 
02bc f5				push af  
02bd 3a d1 02			ld a, (.dmark)  
02c0 32 65 ee			ld (debug_mark),a  
02c3 3a d2 02			ld a, (.dmark+1)  
02c6 32 66 ee			ld (debug_mark+1),a  
02c9 3a d3 02			ld a, (.dmark+2)  
02cc 32 67 ee			ld (debug_mark+2),a  
02cf 18 03			jr .pastdmark  
02d1 ..			.dmark: db "SIZ"  
02d4 f1			.pastdmark: pop af  
02d5			endm  
# End of macro DMARK
02d5						CALLMONITOR 
02d5 cd 6f ee			call debug_vector  
02d8				endm  
# End of macro CALLMONITOR
02d8					endif 
02d8 cd ba 05			call storage_findnextid 
02db			 
02db cd 1e 0e			call ishlzero 
02de			;	ld a, l 
02de			;	add h 
02de			;	cp 0 
02de c8				ret z			; block not found so EOF 
02df			 
02df 11 74 ea			ld de, store_page 
02e2 cd 87 02			call storage_read_block 
02e5			 
02e5 3a 76 ea			ld a, (store_page+2)	 ; get extent count 
02e8 6f				ld l, a 
02e9 26 00			ld h, 0 
02eb c9			 	ret 
02ec			 
02ec			 
02ec			; Write Block 
02ec			; ----------- 
02ec			; 
02ec			; With current bank 
02ec			;  
02ec			; Get block number to write 
02ec			; Write physical blocks starting at start block from buffer 
02ec			  
02ec			storage_write_block: 
02ec				; TODO bank selection 
02ec			 
02ec				; for each of the physical blocks read it into the buffer 
02ec 06 40			ld b, STORE_BLOCK_PHY 
02ee			 
02ee				if DEBUG_STORESE 
02ee					DMARK "SWB" 
02ee f5				push af  
02ef 3a 03 03			ld a, (.dmark)  
02f2 32 65 ee			ld (debug_mark),a  
02f5 3a 04 03			ld a, (.dmark+1)  
02f8 32 66 ee			ld (debug_mark+1),a  
02fb 3a 05 03			ld a, (.dmark+2)  
02fe 32 67 ee			ld (debug_mark+2),a  
0301 18 03			jr .pastdmark  
0303 ..			.dmark: db "SWB"  
0306 f1			.pastdmark: pop af  
0307			endm  
# End of macro DMARK
0307			 
0307					;push af 
0307					;ld a, 'W' 
0307					;ld (debug_mark),a 
0307					;pop af 
0307					CALLMONITOR 
0307 cd 6f ee			call debug_vector  
030a				endm  
# End of macro CALLMONITOR
030a				endif 
030a			 
030a			; might not be working 
030a			;	call se_writepage 
030a			 
030a			;	ret 
030a			; 
030a			 
030a			 
030a			 
030a			.wl1:    
030a			 
030a				; read physical block at hl into de 
030a			        ; increment hl and de to next read position on exit 
030a			 
030a e5				push hl 
030b d5				push de	 
030c c5				push bc 
030d 1a				ld a,(de) 
030e				;if DEBUG_STORESE 
030e			;		push af 
030e			;		ld a, 'W' 
030e			;		ld (debug_mark),a 
030e			;		pop af 
030e			;		CALLMONITOR 
030e			;	endif 
030e cd ac 01			call se_writebyte 
0311			;	call delay250ms 
0311 00				nop 
0312 00				nop 
0313 00				nop 
0314			;	if DEBUG_STORESE 
0314			;		push af 
0314			;		ld a, 'w' 
0314			;		ld (debug_mark),a 
0314			;		pop af 
0314			;		CALLMONITOR 
0314			;	endif 
0314 c1				pop bc 
0315 d1				pop de 
0316 e1				pop hl 
0317 23				inc hl 
0318 13				inc de 
0319			 
0319			 
0319 10 ef			djnz .wl1 
031b			 
031b				if DEBUG_STORESE 
031b					DMARK "SW2" 
031b f5				push af  
031c 3a 30 03			ld a, (.dmark)  
031f 32 65 ee			ld (debug_mark),a  
0322 3a 31 03			ld a, (.dmark+1)  
0325 32 66 ee			ld (debug_mark+1),a  
0328 3a 32 03			ld a, (.dmark+2)  
032b 32 67 ee			ld (debug_mark+2),a  
032e 18 03			jr .pastdmark  
0330 ..			.dmark: db "SW2"  
0333 f1			.pastdmark: pop af  
0334			endm  
# End of macro DMARK
0334			 
0334					;push af 
0334					;ld a, 'W' 
0334					;ld (debug_mark),a 
0334					;pop af 
0334					CALLMONITOR 
0334 cd 6f ee			call debug_vector  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338			 
0338			; Init bank 
0338			; --------- 
0338			; 
0338			; With current bank 
0338			; 
0338			; Setup block 0 config 
0338			;     Set 0 file id counter 
0338			;     Set formatted byte pattern 
0338			;     Zero out bank label 
0338			;      
0338			; For every logical block write 0-1 byte as null 
0338			 
0338			storage_get_block_0: 
0338			 
0338				; TODO check presence 
0338			 
0338				; get block 0 config 
0338			 
0338 21 00 00			ld hl, 0 
033b 11 74 ea			ld de, store_page 
033e cd 87 02			call storage_read_block 
0341			 
0341				if DEBUG_STORESE 
0341					DMARK "SB0" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 65 ee			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 66 ee			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 67 ee			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SB0"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a 11 74 ea				ld de, store_page 
035d			;		push af 
035d			;		ld a, 'i' 
035d			;		ld (debug_mark),a 
035d			;		pop af 
035d					CALLMONITOR 
035d cd 6f ee			call debug_vector  
0360				endm  
# End of macro CALLMONITOR
0360				endif 
0360			 
0360				; is this area formatted? 
0360			 
0360			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0360 2a 75 ea			ld hl, (store_page+1) 
0363 3e 80			ld a,0x80 
0365 bd				cp l 
0366 20 22			jr nz, .ininotformatted 
0368				; do a double check 
0368 3e 27			ld a, 0x27 
036a bc				cp h 
036b 20 1d			jr nz, .ininotformatted 
036d			 
036d				; formatted then 
036d			 
036d				if DEBUG_STORESE 
036d					DMARK "SB1" 
036d f5				push af  
036e 3a 82 03			ld a, (.dmark)  
0371 32 65 ee			ld (debug_mark),a  
0374 3a 83 03			ld a, (.dmark+1)  
0377 32 66 ee			ld (debug_mark+1),a  
037a 3a 84 03			ld a, (.dmark+2)  
037d 32 67 ee			ld (debug_mark+2),a  
0380 18 03			jr .pastdmark  
0382 ..			.dmark: db "SB1"  
0385 f1			.pastdmark: pop af  
0386			endm  
# End of macro DMARK
0386					;push af 
0386					;ld a, 'I' 
0386					;ld (debug_mark),a 
0386					;pop af 
0386					CALLMONITOR 
0386 cd 6f ee			call debug_vector  
0389				endm  
# End of macro CALLMONITOR
0389				endif 
0389 c9				ret 
038a			 
038a			.ininotformatted: 
038a				; bank not formatted so poke various bits to make sure 
038a			 
038a				if DEBUG_STORESE 
038a					DMARK "SB2" 
038a f5				push af  
038b 3a 9f 03			ld a, (.dmark)  
038e 32 65 ee			ld (debug_mark),a  
0391 3a a0 03			ld a, (.dmark+1)  
0394 32 66 ee			ld (debug_mark+1),a  
0397 3a a1 03			ld a, (.dmark+2)  
039a 32 67 ee			ld (debug_mark+2),a  
039d 18 03			jr .pastdmark  
039f ..			.dmark: db "SB2"  
03a2 f1			.pastdmark: pop af  
03a3			endm  
# End of macro DMARK
03a3					;push af 
03a3					;ld a, 'f' 
03a3					;ld (debug_mark),a 
03a3					;pop af 
03a3					CALLMONITOR 
03a3 cd 6f ee			call debug_vector  
03a6				endm  
# End of macro CALLMONITOR
03a6				endif 
03a6			 
03a6 cd c3 0a			call storage_clear_page 
03a9			 
03a9 21 74 ea			ld hl, store_page 
03ac 3e 00			ld a, 0 
03ae				 
03ae 77				ld (hl),a   ; reset file counter 
03af			 
03af 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03b2 22 75 ea		 	ld (store_page+1), hl	 
03b5			 
03b5				; set default label 
03b5			 
03b5 21 51 04			ld hl, .defaultbanklabl 
03b8 11 77 ea		 	ld de, store_page+3 
03bb 01 0f 00			ld bc, 15 
03be ed b0			ldir 
03c0			 
03c0				; Append the current bank id 
03c0 21 80 ea			ld hl, store_page+3+9 
03c3 3a 59 ea			ld a, (spi_device_id) 
03c6 77				ld (hl), a 
03c7			 
03c7				; save default page 0 
03c7			 
03c7 21 00 00			ld hl, 0 
03ca 11 74 ea			ld de, store_page 
03cd				if DEBUG_STORESE 
03cd					DMARK "SB3" 
03cd f5				push af  
03ce 3a e2 03			ld a, (.dmark)  
03d1 32 65 ee			ld (debug_mark),a  
03d4 3a e3 03			ld a, (.dmark+1)  
03d7 32 66 ee			ld (debug_mark+1),a  
03da 3a e4 03			ld a, (.dmark+2)  
03dd 32 67 ee			ld (debug_mark+2),a  
03e0 18 03			jr .pastdmark  
03e2 ..			.dmark: db "SB3"  
03e5 f1			.pastdmark: pop af  
03e6			endm  
# End of macro DMARK
03e6			;		push af 
03e6			;		ld a, 'F' 
03e6			;		ld (debug_mark),a 
03e6			;		pop af 
03e6					CALLMONITOR 
03e6 cd 6f ee			call debug_vector  
03e9				endm  
# End of macro CALLMONITOR
03e9				endif 
03e9 cd ec 02			call storage_write_block 
03ec				if DEBUG_STORESE 
03ec					DMARK "SB4" 
03ec f5				push af  
03ed 3a 01 04			ld a, (.dmark)  
03f0 32 65 ee			ld (debug_mark),a  
03f3 3a 02 04			ld a, (.dmark+1)  
03f6 32 66 ee			ld (debug_mark+1),a  
03f9 3a 03 04			ld a, (.dmark+2)  
03fc 32 67 ee			ld (debug_mark+2),a  
03ff 18 03			jr .pastdmark  
0401 ..			.dmark: db "SB4"  
0404 f1			.pastdmark: pop af  
0405			endm  
# End of macro DMARK
0405			;		push af 
0405			;		ld a, '>' 
0405			;		ld (debug_mark),a 
0405			;		pop af 
0405					CALLMONITOR 
0405 cd 6f ee			call debug_vector  
0408				endm  
# End of macro CALLMONITOR
0408				endif 
0408			 
0408 00				nop 
0409 00				nop 
040a 00				nop 
040b			 
040b				; now set 0 in every page to mark as a free block 
040b			 
040b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
040d 21 40 00			ld hl, STORE_BLOCK_PHY 
0410			 
0410 3e 00		.setmark1:   	ld a,0 
0412 e5					push hl 
0413 c5					push bc 
0414 cd ac 01				call se_writebyte 
0417 3e 0a			ld a, 10 
0419 cd e5 0a			call aDelayInMS 
041c 23				inc hl 
041d cd ac 01				call se_writebyte 
0420 3e 0a			ld a, 10 
0422 cd e5 0a			call aDelayInMS 
0425 2b				dec hl 
0426 c1					pop bc 
0427 e1					pop hl 
0428 3e 40				ld a, STORE_BLOCK_PHY 
042a cd f5 0d				call addatohl 
042d 10 e1				djnz .setmark1 
042f			 
042f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0431 3e 00		.setmark2:   	ld a,0 
0433 e5					push hl 
0434 c5					push bc 
0435 cd ac 01				call se_writebyte 
0438 3e 0a			ld a, 10 
043a cd e5 0a			call aDelayInMS 
043d 23				inc hl 
043e cd ac 01				call se_writebyte 
0441 3e 0a			ld a, 10 
0443 cd e5 0a			call aDelayInMS 
0446 2b				dec hl 
0447 c1					pop bc 
0448 e1					pop hl 
0449 3e 40				ld a, STORE_BLOCK_PHY 
044b cd f5 0d				call addatohl 
044e 10 e1				djnz .setmark2 
0450			 
0450					 
0450			 
0450			 
0450 c9				ret 
0451			 
0451			 
0451			 
0451			 
0451 .. 00		.defaultbanklabl:   db "BankLabel_",0 
045c			 
045c			 
045c			 
045c			; Label Bank 
045c			; ---------- 
045c			; 
045c			; With current bank 
045c			; Read block 0 
045c			; Set label 
045c			; Write block 0 
045c			 
045c			; label str pointer in hl 
045c			 
045c			storage_label:     
045c			 
045c				if DEBUG_STORESE 
045c					DMARK "LBL" 
045c f5				push af  
045d 3a 71 04			ld a, (.dmark)  
0460 32 65 ee			ld (debug_mark),a  
0463 3a 72 04			ld a, (.dmark+1)  
0466 32 66 ee			ld (debug_mark+1),a  
0469 3a 73 04			ld a, (.dmark+2)  
046c 32 67 ee			ld (debug_mark+2),a  
046f 18 03			jr .pastdmark  
0471 ..			.dmark: db "LBL"  
0474 f1			.pastdmark: pop af  
0475			endm  
# End of macro DMARK
0475					CALLMONITOR 
0475 cd 6f ee			call debug_vector  
0478				endm  
# End of macro CALLMONITOR
0478				endif 
0478			 
0478 e5				push hl 
0479			 
0479 cd 38 03			call storage_get_block_0 
047c			 
047c				; set default label 
047c			 
047c e1				pop hl 
047d			 
047d 11 77 ea		 	ld de, store_page+3 
0480 01 0f 00			ld bc, 15 
0483				if DEBUG_STORESE 
0483					DMARK "LB3" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 65 ee			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 66 ee			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 67 ee			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "LB3"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c					CALLMONITOR 
049c cd 6f ee			call debug_vector  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f ed b0			ldir 
04a1				; save default page 0 
04a1			 
04a1 21 00 00			ld hl, 0 
04a4 11 74 ea			ld de, store_page 
04a7				if DEBUG_STORESE 
04a7					DMARK "LBW" 
04a7 f5				push af  
04a8 3a bc 04			ld a, (.dmark)  
04ab 32 65 ee			ld (debug_mark),a  
04ae 3a bd 04			ld a, (.dmark+1)  
04b1 32 66 ee			ld (debug_mark+1),a  
04b4 3a be 04			ld a, (.dmark+2)  
04b7 32 67 ee			ld (debug_mark+2),a  
04ba 18 03			jr .pastdmark  
04bc ..			.dmark: db "LBW"  
04bf f1			.pastdmark: pop af  
04c0			endm  
# End of macro DMARK
04c0					CALLMONITOR 
04c0 cd 6f ee			call debug_vector  
04c3				endm  
# End of macro CALLMONITOR
04c3				endif 
04c3 cd ec 02			call storage_write_block 
04c6			 
04c6 c9				ret 
04c7			 
04c7			 
04c7			 
04c7			; Read Block 0 - Config 
04c7			; --------------------- 
04c7			; 
04c7			; With current bank 
04c7			; Call presence test 
04c7			;    If not present format/init bank  
04c7			; Read block 0  
04c7			;  
04c7			 
04c7			 
04c7			; Dir 
04c7			; --- 
04c7			; 
04c7			; With current bank 
04c7			; Load Block 0 Config 
04c7			; Get max file id number 
04c7			; For each logical block 
04c7			;    Read block read byte 2 
04c7			;      if first block of file 
04c7			;         Display file name 
04c7			;         Display type flags for file 
04c7			;        
04c7			 
04c7			; moving to words as this requires stack control 
04c7			 
04c7			 
04c7			; Delete File 
04c7			; ----------- 
04c7			; 
04c7			; With current bank 
04c7			; 
04c7			; Load Block 0 Config 
04c7			; Get max file id number 
04c7			; For each logical block 
04c7			;    Read block file id 
04c7			;      If first block of file and dont have file id 
04c7			;         if file to delete 
04c7			;         Save file id 
04c7			;         Null file id 
04c7			;         Write this block back 
04c7			;      If file id is one saved 
04c7			;         Null file id 
04c7			;         Write this block back 
04c7			 
04c7			 
04c7			.se_done: 
04c7 e1				pop hl 
04c8 c9				ret 
04c9			 
04c9			storage_erase: 
04c9			 
04c9				; hl contains the file id 
04c9			 
04c9 5d				ld e, l 
04ca 16 00			ld d, 0 
04cc 21 40 00			ld hl, STORE_BLOCK_PHY 
04cf					if DEBUG_FORTH_WORDS 
04cf						DMARK "ERA" 
04cf f5				push af  
04d0 3a e4 04			ld a, (.dmark)  
04d3 32 65 ee			ld (debug_mark),a  
04d6 3a e5 04			ld a, (.dmark+1)  
04d9 32 66 ee			ld (debug_mark+1),a  
04dc 3a e6 04			ld a, (.dmark+2)  
04df 32 67 ee			ld (debug_mark+2),a  
04e2 18 03			jr .pastdmark  
04e4 ..			.dmark: db "ERA"  
04e7 f1			.pastdmark: pop af  
04e8			endm  
# End of macro DMARK
04e8						CALLMONITOR 
04e8 cd 6f ee			call debug_vector  
04eb				endm  
# End of macro CALLMONITOR
04eb					endif 
04eb cd ba 05			call storage_findnextid 
04ee cd 1e 0e			call ishlzero 
04f1 c8				ret z 
04f2			 
04f2 e5				push hl 
04f3			 
04f3				; TODO check file not found 
04f3			 
04f3 11 74 ea			ld de, store_page 
04f6 cd 87 02			call storage_read_block 
04f9			 
04f9 cd 1e 0e			call ishlzero 
04fc ca c7 04			jp z,.se_done 
04ff			 
04ff					if DEBUG_FORTH_WORDS 
04ff						DMARK "ER1" 
04ff f5				push af  
0500 3a 14 05			ld a, (.dmark)  
0503 32 65 ee			ld (debug_mark),a  
0506 3a 15 05			ld a, (.dmark+1)  
0509 32 66 ee			ld (debug_mark+1),a  
050c 3a 16 05			ld a, (.dmark+2)  
050f 32 67 ee			ld (debug_mark+2),a  
0512 18 03			jr .pastdmark  
0514 ..			.dmark: db "ER1"  
0517 f1			.pastdmark: pop af  
0518			endm  
# End of macro DMARK
0518						CALLMONITOR 
0518 cd 6f ee			call debug_vector  
051b				endm  
# End of macro CALLMONITOR
051b					endif 
051b 3a 74 ea			ld a, (store_page)	; get file id 
051e 32 68 ea			ld (store_tmpid), a 
0521			 
0521 3a 76 ea			ld a, (store_page+2)    ; get count of extends 
0524 32 67 ea			ld (store_tmpext), a 
0527			 
0527				; wipe file header 
0527			 
0527 e1				pop hl 
0528 3e 00			ld a, 0 
052a 32 74 ea			ld (store_page), a 
052d 32 75 ea			ld (store_page+1),a 
0530 11 74 ea			ld de, store_page 
0533					if DEBUG_FORTH_WORDS 
0533						DMARK "ER2" 
0533 f5				push af  
0534 3a 48 05			ld a, (.dmark)  
0537 32 65 ee			ld (debug_mark),a  
053a 3a 49 05			ld a, (.dmark+1)  
053d 32 66 ee			ld (debug_mark+1),a  
0540 3a 4a 05			ld a, (.dmark+2)  
0543 32 67 ee			ld (debug_mark+2),a  
0546 18 03			jr .pastdmark  
0548 ..			.dmark: db "ER2"  
054b f1			.pastdmark: pop af  
054c			endm  
# End of macro DMARK
054c						CALLMONITOR 
054c cd 6f ee			call debug_vector  
054f				endm  
# End of macro CALLMONITOR
054f					endif 
054f cd ec 02			call storage_write_block 
0552			 
0552			 
0552				; wipe file extents 
0552			 
0552 3a 67 ea			ld a, (store_tmpext) 
0555 47				ld b, a 
0556			 
0556			.eraext:	  
0556 c5				push bc 
0557			 
0557 21 40 00			ld hl, STORE_BLOCK_PHY 
055a 3a 68 ea			ld a,(store_tmpid) 
055d 5f				ld e, a 
055e 50				ld d, b	 
055f					if DEBUG_FORTH_WORDS 
055f						DMARK "ER3" 
055f f5				push af  
0560 3a 74 05			ld a, (.dmark)  
0563 32 65 ee			ld (debug_mark),a  
0566 3a 75 05			ld a, (.dmark+1)  
0569 32 66 ee			ld (debug_mark+1),a  
056c 3a 76 05			ld a, (.dmark+2)  
056f 32 67 ee			ld (debug_mark+2),a  
0572 18 03			jr .pastdmark  
0574 ..			.dmark: db "ER3"  
0577 f1			.pastdmark: pop af  
0578			endm  
# End of macro DMARK
0578						CALLMONITOR 
0578 cd 6f ee			call debug_vector  
057b				endm  
# End of macro CALLMONITOR
057b					endif 
057b cd ba 05			call storage_findnextid 
057e cd 1e 0e			call ishlzero 
0581 ca c7 04			jp z,.se_done 
0584			 
0584 e5				push hl 
0585 11 74 ea			ld de, store_page 
0588 cd 87 02			call storage_read_block 
058b			 
058b				; free block	 
058b			 
058b 3e 00			ld a, 0 
058d 32 74 ea			ld (store_page), a 
0590 32 75 ea			ld (store_page+1),a 
0593 11 74 ea			ld de, store_page 
0596 e1				pop hl 
0597					if DEBUG_FORTH_WORDS 
0597						DMARK "ER4" 
0597 f5				push af  
0598 3a ac 05			ld a, (.dmark)  
059b 32 65 ee			ld (debug_mark),a  
059e 3a ad 05			ld a, (.dmark+1)  
05a1 32 66 ee			ld (debug_mark+1),a  
05a4 3a ae 05			ld a, (.dmark+2)  
05a7 32 67 ee			ld (debug_mark+2),a  
05aa 18 03			jr .pastdmark  
05ac ..			.dmark: db "ER4"  
05af f1			.pastdmark: pop af  
05b0			endm  
# End of macro DMARK
05b0						CALLMONITOR 
05b0 cd 6f ee			call debug_vector  
05b3				endm  
# End of macro CALLMONITOR
05b3					endif 
05b3 cd ec 02			call storage_write_block 
05b6			 
05b6 c1				pop bc 
05b7 10 9d			djnz .eraext 
05b9			 
05b9 c9				ret 
05ba			 
05ba			 
05ba			; Find Free Block 
05ba			; --------------- 
05ba			; 
05ba			; With current bank 
05ba			;  
05ba			; From given starting logical block 
05ba			;    Read block  
05ba			;    If no file id 
05ba			;         Return block id 
05ba			 
05ba			 
05ba			; hl starting page number 
05ba			; hl contains free page number or zero if no pages free 
05ba			; e contains the file id to locate 
05ba			; d contains the block number 
05ba			 
05ba			; TODO change to find file id and use zero for free block 
05ba			 
05ba			storage_findnextid: 
05ba			 
05ba				; now locate first 0 page to mark as a free block 
05ba			 
05ba 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05bc			;	ld hl, STORE_BLOCK_PHY 
05bc			 
05bc					if DEBUG_FORTH_WORDS 
05bc					DMARK "FNI" 
05bc f5				push af  
05bd 3a d1 05			ld a, (.dmark)  
05c0 32 65 ee			ld (debug_mark),a  
05c3 3a d2 05			ld a, (.dmark+1)  
05c6 32 66 ee			ld (debug_mark+1),a  
05c9 3a d3 05			ld a, (.dmark+2)  
05cc 32 67 ee			ld (debug_mark+2),a  
05cf 18 03			jr .pastdmark  
05d1 ..			.dmark: db "FNI"  
05d4 f1			.pastdmark: pop af  
05d5			endm  
# End of macro DMARK
05d5						CALLMONITOR 
05d5 cd 6f ee			call debug_vector  
05d8				endm  
# End of macro CALLMONITOR
05d8					endif 
05d8			.ff1:   	 
05d8 e5					push hl 
05d9 c5					push bc 
05da d5					push de 
05db cd ab 01				call se_readbyte 
05de 5f					ld e,a 
05df 23					inc hl 
05e0 cd ab 01				call se_readbyte 
05e3 57					ld d, a 
05e4 e1					pop hl 
05e5 e5					push hl 
05e6 cd 13 0e				call cmp16 
05e9 28 49				jr z, .fffound 
05eb			 
05eb d1					pop de 
05ec c1					pop bc 
05ed e1					pop hl 
05ee			 
05ee					; is found? 
05ee					;cp e 
05ee					;ret z 
05ee			 
05ee 3e 40				ld a, STORE_BLOCK_PHY 
05f0 cd f5 0d				call addatohl 
05f3 10 e3				djnz .ff1 
05f5			 
05f5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05f7			.ff2:   	 
05f7			 
05f7 e5					push hl 
05f8 c5					push bc 
05f9 d5					push de 
05fa cd ab 01				call se_readbyte 
05fd 5f					ld e,a 
05fe 23					inc hl 
05ff cd ab 01				call se_readbyte 
0602 57					ld d, a 
0603			 
0603 e1					pop hl 
0604 e5					push hl 
0605 cd 13 0e				call cmp16 
0608 28 2a				jr z, .fffound 
060a			 
060a d1					pop de 
060b c1					pop bc 
060c e1					pop hl 
060d					; is found? 
060d					;cp e 
060d					;ret z 
060d			 
060d 3e 40				ld a, STORE_BLOCK_PHY 
060f cd f5 0d				call addatohl 
0612 10 e3				djnz .ff2 
0614			 
0614			 
0614					if DEBUG_FORTH_WORDS 
0614					DMARK "FN-" 
0614 f5				push af  
0615 3a 29 06			ld a, (.dmark)  
0618 32 65 ee			ld (debug_mark),a  
061b 3a 2a 06			ld a, (.dmark+1)  
061e 32 66 ee			ld (debug_mark+1),a  
0621 3a 2b 06			ld a, (.dmark+2)  
0624 32 67 ee			ld (debug_mark+2),a  
0627 18 03			jr .pastdmark  
0629 ..			.dmark: db "FN-"  
062c f1			.pastdmark: pop af  
062d			endm  
# End of macro DMARK
062d					;	push af 
062d					;	ld a, 'n' 
062d					;	ld (debug_mark),a 
062d					;	pop af 
062d						CALLMONITOR 
062d cd 6f ee			call debug_vector  
0630				endm  
# End of macro CALLMONITOR
0630					endif 
0630				; no free marks! 
0630 21 00 00				ld hl, 0 
0633 c9				ret 
0634			.fffound: 
0634				 
0634			 
0634 d1					pop de 
0635 c1					pop bc 
0636 e1					pop hl 
0637					if DEBUG_FORTH_WORDS 
0637					DMARK "FNF" 
0637 f5				push af  
0638 3a 4c 06			ld a, (.dmark)  
063b 32 65 ee			ld (debug_mark),a  
063e 3a 4d 06			ld a, (.dmark+1)  
0641 32 66 ee			ld (debug_mark+1),a  
0644 3a 4e 06			ld a, (.dmark+2)  
0647 32 67 ee			ld (debug_mark+2),a  
064a 18 03			jr .pastdmark  
064c ..			.dmark: db "FNF"  
064f f1			.pastdmark: pop af  
0650			endm  
# End of macro DMARK
0650					;	push af 
0650					;	ld a, 'n' 
0650					;	ld (debug_mark),a 
0650					;	pop af 
0650						CALLMONITOR 
0650 cd 6f ee			call debug_vector  
0653				endm  
# End of macro CALLMONITOR
0653					endif 
0653 c9				ret 
0654			 
0654			 
0654			 
0654			; Free Space 
0654			; ---------- 
0654			; 
0654			; With current bank 
0654			; 
0654			; Set block count to zero 
0654			; Starting with first logical block 
0654			;      Find free block  
0654			;      If block id given, increment block count 
0654			; 
0654			;  
0654			 
0654			 
0654			; hl contains count of free blocks 
0654			 
0654			storage_freeblocks: 
0654			 
0654				; now locate first 0 page to mark as a free block 
0654			 
0654 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0656 21 40 00			ld hl, STORE_BLOCK_PHY 
0659 11 00 00			ld de, 0 
065c			 
065c			.fb1:   	 
065c e5					push hl 
065d c5					push bc 
065e d5					push de 
065f cd ab 01				call se_readbyte 
0662 d1					pop de 
0663 c1					pop bc 
0664 e1					pop hl 
0665			 
0665					; is free? 
0665 fe 00				cp 0 
0667 20 01				jr nz, .ff1cont 
0669 13					inc de 
066a			 
066a			.ff1cont: 
066a			 
066a			 
066a 3e 40				ld a, STORE_BLOCK_PHY 
066c cd f5 0d				call addatohl 
066f 10 eb				djnz .fb1 
0671			 
0671 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0673			.fb2:   	 
0673 e5					push hl 
0674 c5					push bc 
0675 d5					push de 
0676 cd ab 01				call se_readbyte 
0679 d1					pop de 
067a c1					pop bc 
067b e1					pop hl 
067c			 
067c					; is free? 
067c fe 00				cp 0 
067e 20 01				jr nz, .ff2cont 
0680 13					inc de 
0681			 
0681			.ff2cont: 
0681			 
0681 3e 40				ld a, STORE_BLOCK_PHY 
0683 cd f5 0d				call addatohl 
0686 10 eb				djnz .fb2 
0688			 
0688 eb				ex de, hl 
0689 c9				ret 
068a			 
068a			; Get File ID 
068a			; ----------- 
068a			; 
068a			; With current bank 
068a			;  
068a			; Load Block 0 Config 
068a			; Get max file id number 
068a			; For each logical block 
068a			;    Read block file id 
068a			;      If first block of file and dont have file id 
068a			;         if file get id and exit 
068a			 
068a			 
068a			 
068a			 
068a			; Create File 
068a			; ----------- 
068a			; 
068a			; With current bank  
068a			; Load Block 0 Config 
068a			; Get max file id number 
068a			; Increment file id number 
068a			; Save Config 
068a			; Find free block 
068a			; Set buffer with file name and file id 
068a			; Write buffer to free block  
068a			 
068a			 
068a			; hl point to file name 
068a			; hl returns file id 
068a			 
068a			; file format: 
068a			; byte 0 - file id 
068a			; byte 1 - extent number 
068a			; byte 2-> data 
068a			 
068a			; format for extent number 0: 
068a			; 
068a			; byte 0 - file id 
068a			; byte 1 - extent 0 
068a			; byte 2 - extent count 
068a			; byte 3 -> file name and meta data 
068a			 
068a			 
068a			storage_create: 
068a				if DEBUG_STORESE 
068a					DMARK "SCR" 
068a f5				push af  
068b 3a 9f 06			ld a, (.dmark)  
068e 32 65 ee			ld (debug_mark),a  
0691 3a a0 06			ld a, (.dmark+1)  
0694 32 66 ee			ld (debug_mark+1),a  
0697 3a a1 06			ld a, (.dmark+2)  
069a 32 67 ee			ld (debug_mark+2),a  
069d 18 03			jr .pastdmark  
069f ..			.dmark: db "SCR"  
06a2 f1			.pastdmark: pop af  
06a3			endm  
# End of macro DMARK
06a3					CALLMONITOR 
06a3 cd 6f ee			call debug_vector  
06a6				endm  
# End of macro CALLMONITOR
06a6				endif 
06a6			 
06a6 e5				push hl		; save file name pointer 
06a7			 
06a7 cd 38 03			call storage_get_block_0 
06aa			 
06aa 3a 74 ea			ld a,(store_page)	; get current file id 
06ad 3c				inc a 
06ae 32 74 ea			ld (store_page),a 
06b1				 
06b1 32 68 ea			ld (store_tmpid),a			; save id 
06b4			 
06b4 21 00 00			ld hl, 0 
06b7 11 74 ea			ld de, store_page 
06ba				if DEBUG_STORESE 
06ba					DMARK "SCw" 
06ba f5				push af  
06bb 3a cf 06			ld a, (.dmark)  
06be 32 65 ee			ld (debug_mark),a  
06c1 3a d0 06			ld a, (.dmark+1)  
06c4 32 66 ee			ld (debug_mark+1),a  
06c7 3a d1 06			ld a, (.dmark+2)  
06ca 32 67 ee			ld (debug_mark+2),a  
06cd 18 03			jr .pastdmark  
06cf ..			.dmark: db "SCw"  
06d2 f1			.pastdmark: pop af  
06d3			endm  
# End of macro DMARK
06d3					CALLMONITOR 
06d3 cd 6f ee			call debug_vector  
06d6				endm  
# End of macro CALLMONITOR
06d6				endif 
06d6 cd ec 02			call storage_write_block	 ; save update 
06d9			 
06d9				if DEBUG_STORESE 
06d9 11 74 ea				ld de, store_page 
06dc					DMARK "SCC" 
06dc f5				push af  
06dd 3a f1 06			ld a, (.dmark)  
06e0 32 65 ee			ld (debug_mark),a  
06e3 3a f2 06			ld a, (.dmark+1)  
06e6 32 66 ee			ld (debug_mark+1),a  
06e9 3a f3 06			ld a, (.dmark+2)  
06ec 32 67 ee			ld (debug_mark+2),a  
06ef 18 03			jr .pastdmark  
06f1 ..			.dmark: db "SCC"  
06f4 f1			.pastdmark: pop af  
06f5			endm  
# End of macro DMARK
06f5					CALLMONITOR 
06f5 cd 6f ee			call debug_vector  
06f8				endm  
# End of macro CALLMONITOR
06f8				endif 
06f8				;  
06f8				 
06f8 21 40 00			ld hl, STORE_BLOCK_PHY 
06fb 11 00 00			ld de, 0 
06fe cd ba 05			call storage_findnextid 
0701			 
0701 22 5f ea			ld (store_tmppageid), hl    ; save page to use  
0704			 
0704				; TODO detect 0 = no spare blocks 
0704			 
0704				; hl now contains the free page to use for the file header page 
0704			 
0704				if DEBUG_STORESE 
0704				DMARK "SCF" 
0704 f5				push af  
0705 3a 19 07			ld a, (.dmark)  
0708 32 65 ee			ld (debug_mark),a  
070b 3a 1a 07			ld a, (.dmark+1)  
070e 32 66 ee			ld (debug_mark+1),a  
0711 3a 1b 07			ld a, (.dmark+2)  
0714 32 67 ee			ld (debug_mark+2),a  
0717 18 03			jr .pastdmark  
0719 ..			.dmark: db "SCF"  
071c f1			.pastdmark: pop af  
071d			endm  
# End of macro DMARK
071d					CALLMONITOR 
071d cd 6f ee			call debug_vector  
0720				endm  
# End of macro CALLMONITOR
0720				endif 
0720			 
0720 22 5f ea			ld (store_tmppageid), hl 
0723				 
0723 3a 68 ea			ld a,(store_tmpid)    ; get file id 
0726			;	ld a, (store_filecache)			; save to cache 
0726			 
0726 32 74 ea			ld (store_page),a    ; set page id 
0729 3e 00			ld a, 0			 ; extent 0 is file header 
072b 32 75 ea			ld (store_page+1), a   ; set file extent 
072e			 
072e 32 76 ea			ld (store_page+2), a   ; extent count for the file 
0731			 
0731			;	inc hl 		; init block 0 of file 
0731			;	inc hl   		; skip file and extent id 
0731			 ;       ld a, 0 
0731			;	ld (hl),a 
0731			;	ld a, (store_filecache+1)  	; save to cache 
0731			 
0731			;	inc hl    ; file name 
0731				 
0731				 
0731 11 77 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0734				if DEBUG_STORESE 
0734					DMARK "SCc" 
0734 f5				push af  
0735 3a 49 07			ld a, (.dmark)  
0738 32 65 ee			ld (debug_mark),a  
073b 3a 4a 07			ld a, (.dmark+1)  
073e 32 66 ee			ld (debug_mark+1),a  
0741 3a 4b 07			ld a, (.dmark+2)  
0744 32 67 ee			ld (debug_mark+2),a  
0747 18 03			jr .pastdmark  
0749 ..			.dmark: db "SCc"  
074c f1			.pastdmark: pop af  
074d			endm  
# End of macro DMARK
074d					CALLMONITOR 
074d cd 6f ee			call debug_vector  
0750				endm  
# End of macro CALLMONITOR
0750				endif 
0750 e1				pop hl    ; get zero term string 
0751 e5				push hl 
0752 3e 00			ld a, 0 
0754 cd 66 11			call strlent 
0757 23				inc hl   ; cover zero term 
0758 06 00			ld b,0 
075a 4d				ld c,l 
075b e1				pop hl 
075c				;ex de, hl 
075c				if DEBUG_STORESE 
075c					DMARK "SCa" 
075c f5				push af  
075d 3a 71 07			ld a, (.dmark)  
0760 32 65 ee			ld (debug_mark),a  
0763 3a 72 07			ld a, (.dmark+1)  
0766 32 66 ee			ld (debug_mark+1),a  
0769 3a 73 07			ld a, (.dmark+2)  
076c 32 67 ee			ld (debug_mark+2),a  
076f 18 03			jr .pastdmark  
0771 ..			.dmark: db "SCa"  
0774 f1			.pastdmark: pop af  
0775			endm  
# End of macro DMARK
0775					;push af 
0775					;ld a, 'a' 
0775					;ld (debug_mark),a 
0775					;pop af 
0775					CALLMONITOR 
0775 cd 6f ee			call debug_vector  
0778				endm  
# End of macro CALLMONITOR
0778				endif 
0778 ed b0			ldir    ; copy zero term string 
077a				if DEBUG_STORESE 
077a					DMARK "SCA" 
077a f5				push af  
077b 3a 8f 07			ld a, (.dmark)  
077e 32 65 ee			ld (debug_mark),a  
0781 3a 90 07			ld a, (.dmark+1)  
0784 32 66 ee			ld (debug_mark+1),a  
0787 3a 91 07			ld a, (.dmark+2)  
078a 32 67 ee			ld (debug_mark+2),a  
078d 18 03			jr .pastdmark  
078f ..			.dmark: db "SCA"  
0792 f1			.pastdmark: pop af  
0793			endm  
# End of macro DMARK
0793					CALLMONITOR 
0793 cd 6f ee			call debug_vector  
0796				endm  
# End of macro CALLMONITOR
0796				endif 
0796			 
0796				; write file header page 
0796			 
0796 2a 5f ea			ld hl,(store_tmppageid) 
0799 11 74 ea			ld de, store_page 
079c				if DEBUG_STORESE 
079c					DMARK "SCb" 
079c f5				push af  
079d 3a b1 07			ld a, (.dmark)  
07a0 32 65 ee			ld (debug_mark),a  
07a3 3a b2 07			ld a, (.dmark+1)  
07a6 32 66 ee			ld (debug_mark+1),a  
07a9 3a b3 07			ld a, (.dmark+2)  
07ac 32 67 ee			ld (debug_mark+2),a  
07af 18 03			jr .pastdmark  
07b1 ..			.dmark: db "SCb"  
07b4 f1			.pastdmark: pop af  
07b5			endm  
# End of macro DMARK
07b5					;push af 
07b5					;ld a, 'b' 
07b5					;ld (debug_mark),a 
07b5					;pop af 
07b5					CALLMONITOR 
07b5 cd 6f ee			call debug_vector  
07b8				endm  
# End of macro CALLMONITOR
07b8				endif 
07b8 cd ec 02			call storage_write_block 
07bb			 
07bb 3a 68 ea			ld a, (store_tmpid) 
07be 6f				ld l, a 
07bf 26 00			ld h,0 
07c1				if DEBUG_STORESE 
07c1					DMARK "SCz" 
07c1 f5				push af  
07c2 3a d6 07			ld a, (.dmark)  
07c5 32 65 ee			ld (debug_mark),a  
07c8 3a d7 07			ld a, (.dmark+1)  
07cb 32 66 ee			ld (debug_mark+1),a  
07ce 3a d8 07			ld a, (.dmark+2)  
07d1 32 67 ee			ld (debug_mark+2),a  
07d4 18 03			jr .pastdmark  
07d6 ..			.dmark: db "SCz"  
07d9 f1			.pastdmark: pop af  
07da			endm  
# End of macro DMARK
07da					CALLMONITOR 
07da cd 6f ee			call debug_vector  
07dd				endm  
# End of macro CALLMONITOR
07dd				endif 
07dd c9				ret 
07de				 
07de			 
07de			 
07de			; 
07de			; Read File 
07de			; 
07de			; h - file id to locate 
07de			; l - extent to locate 
07de			; de - pointer to string to read into 
07de			; 
07de			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07de			 
07de			.sr_fail: 
07de d1				pop de 
07df c9				ret 
07e0			 
07e0			storage_read: 
07e0			 
07e0			 
07e0 d5				push de 
07e1			 
07e1			; TODO BUG the above push is it popped before the RET Z? 
07e1			 
07e1			; TODO how to handle multiple part blocks 
07e1			 
07e1				; locate file extent to read 
07e1			 
07e1 5c				ld e, h 
07e2 55				ld d, l 
07e3			 
07e3			.srext: 
07e3 22 72 ea			ld (store_readptr), hl     ; save the current extent to load 
07e6 ed 53 70 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07ea			 
07ea 21 40 00			ld hl, STORE_BLOCK_PHY 
07ed				if DEBUG_STORESE 
07ed					DMARK "sre" 
07ed f5				push af  
07ee 3a 02 08			ld a, (.dmark)  
07f1 32 65 ee			ld (debug_mark),a  
07f4 3a 03 08			ld a, (.dmark+1)  
07f7 32 66 ee			ld (debug_mark+1),a  
07fa 3a 04 08			ld a, (.dmark+2)  
07fd 32 67 ee			ld (debug_mark+2),a  
0800 18 03			jr .pastdmark  
0802 ..			.dmark: db "sre"  
0805 f1			.pastdmark: pop af  
0806			endm  
# End of macro DMARK
0806					CALLMONITOR 
0806 cd 6f ee			call debug_vector  
0809				endm  
# End of macro CALLMONITOR
0809				endif 
0809 cd ba 05			call storage_findnextid 
080c			 
080c				if DEBUG_STORESE 
080c					DMARK "srf" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 65 ee			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 66 ee			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 67 ee			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "srf"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					CALLMONITOR 
0825 cd 6f ee			call debug_vector  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 1e 0e			call ishlzero 
082b			;	ld a, l 
082b			;	add h 
082b			;	cp 0 
082b 28 b1			jr z,.sr_fail			; block not found so EOF 
082d			 
082d				; save current address for use by higher level words etc 
082d			 
082d 22 65 ea			ld (store_openaddr),hl 
0830			 
0830			 
0830				; hl contains page number to load 
0830 d1				pop de   ; get storage 
0831 ed 53 70 ea		ld (store_readbuf), de     ; current buffer to load in to 
0835 d5				push de 
0836				if DEBUG_STORESE 
0836					DMARK "srg" 
0836 f5				push af  
0837 3a 4b 08			ld a, (.dmark)  
083a 32 65 ee			ld (debug_mark),a  
083d 3a 4c 08			ld a, (.dmark+1)  
0840 32 66 ee			ld (debug_mark+1),a  
0843 3a 4d 08			ld a, (.dmark+2)  
0846 32 67 ee			ld (debug_mark+2),a  
0849 18 03			jr .pastdmark  
084b ..			.dmark: db "srg"  
084e f1			.pastdmark: pop af  
084f			endm  
# End of macro DMARK
084f					CALLMONITOR 
084f cd 6f ee			call debug_vector  
0852				endm  
# End of macro CALLMONITOR
0852				endif 
0852 cd 87 02			call storage_read_block 
0855			 
0855				; if this a continuation read??? 
0855			 
0855 2a 70 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0858			 
0858 3e 3f			ld a, STORE_BLOCK_PHY-1 
085a cd f5 0d			call addatohl 
085d 7e				ld a,(hl) 
085e fe 00			cp 0 
0860 28 02			jr z, .markiscont 
0862 3e ff			ld a, 255 
0864			 
0864			.markiscont: 
0864 32 67 ea			ld (store_readcont), a 
0867			 
0867				if DEBUG_STORESE 
0867					DMARK "srC" 
0867 f5				push af  
0868 3a 7c 08			ld a, (.dmark)  
086b 32 65 ee			ld (debug_mark),a  
086e 3a 7d 08			ld a, (.dmark+1)  
0871 32 66 ee			ld (debug_mark+1),a  
0874 3a 7e 08			ld a, (.dmark+2)  
0877 32 67 ee			ld (debug_mark+2),a  
087a 18 03			jr .pastdmark  
087c ..			.dmark: db "srC"  
087f f1			.pastdmark: pop af  
0880			endm  
# End of macro DMARK
0880					CALLMONITOR 
0880 cd 6f ee			call debug_vector  
0883				endm  
# End of macro CALLMONITOR
0883				endif 
0883				; only short reads enabled 
0883			 
0883 3a 6f ea			ld a, (store_longread) 
0886 fe 00			cp 0 
0888 ca 55 09			jp z, .readdone 
088b			 
088b			; TODO if block has no zeros then need to read next block  
088b			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
088b			; check last byte of physical block. 
088b			; if not zero then the next block needs to be loaded 
088b			 
088b			 
088b 2a 70 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
088e			 
088e 3e 3f			ld a, STORE_BLOCK_PHY-1 
0890 cd f5 0d			call addatohl 
0893				;dec hl 
0893 7e				ld a,(hl) 
0894				if DEBUG_STORESE 
0894					DMARK "sr?" 
0894 f5				push af  
0895 3a a9 08			ld a, (.dmark)  
0898 32 65 ee			ld (debug_mark),a  
089b 3a aa 08			ld a, (.dmark+1)  
089e 32 66 ee			ld (debug_mark+1),a  
08a1 3a ab 08			ld a, (.dmark+2)  
08a4 32 67 ee			ld (debug_mark+2),a  
08a7 18 03			jr .pastdmark  
08a9 ..			.dmark: db "sr?"  
08ac f1			.pastdmark: pop af  
08ad			endm  
# End of macro DMARK
08ad					CALLMONITOR 
08ad cd 6f ee			call debug_vector  
08b0				endm  
# End of macro CALLMONITOR
08b0				endif 
08b0 fe 00			cp 0 
08b2 ca 55 09			jp z, .readdone 
08b5			 
08b5				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08b5			 
08b5 23				inc hl 
08b6			 
08b6 22 70 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08b9			 
08b9 ed 5b 72 ea		ld de, (store_readptr)     ; save the current extent to load 
08bd			 
08bd eb				ex de, hl 
08be			 
08be				; next ext 
08be			 
08be 23				inc hl 
08bf 22 72 ea			ld  (store_readptr), hl     ; save the current extent to load 
08c2			 
08c2				if DEBUG_STORESE 
08c2					DMARK "sF2" 
08c2 f5				push af  
08c3 3a d7 08			ld a, (.dmark)  
08c6 32 65 ee			ld (debug_mark),a  
08c9 3a d8 08			ld a, (.dmark+1)  
08cc 32 66 ee			ld (debug_mark+1),a  
08cf 3a d9 08			ld a, (.dmark+2)  
08d2 32 67 ee			ld (debug_mark+2),a  
08d5 18 03			jr .pastdmark  
08d7 ..			.dmark: db "sF2"  
08da f1			.pastdmark: pop af  
08db			endm  
# End of macro DMARK
08db					CALLMONITOR 
08db cd 6f ee			call debug_vector  
08de				endm  
# End of macro CALLMONITOR
08de				endif 
08de			 
08de				; get and load block 
08de			 
08de cd ba 05			call storage_findnextid 
08e1			 
08e1				if DEBUG_STORESE 
08e1					DMARK "sf2" 
08e1 f5				push af  
08e2 3a f6 08			ld a, (.dmark)  
08e5 32 65 ee			ld (debug_mark),a  
08e8 3a f7 08			ld a, (.dmark+1)  
08eb 32 66 ee			ld (debug_mark+1),a  
08ee 3a f8 08			ld a, (.dmark+2)  
08f1 32 67 ee			ld (debug_mark+2),a  
08f4 18 03			jr .pastdmark  
08f6 ..			.dmark: db "sf2"  
08f9 f1			.pastdmark: pop af  
08fa			endm  
# End of macro DMARK
08fa					CALLMONITOR 
08fa cd 6f ee			call debug_vector  
08fd				endm  
# End of macro CALLMONITOR
08fd				endif 
08fd cd 1e 0e			call ishlzero 
0900			;	ld a, l 
0900			;	add h 
0900			;	cp 0 
0900 ca de 07			jp z,.sr_fail			; block not found so EOF 
0903				 
0903				; save current address for use by higher level words etc 
0903			 
0903 22 65 ea			ld (store_openaddr),hl 
0906			 
0906 cd 87 02			call storage_read_block 
0909			 
0909				; on a continuation block, we now have the file id and ext in the middle of the block 
0909				; we need to pull everything back  
0909			 
0909 ed 5b 70 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
090d 2a 70 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0910 23				inc hl 
0911 23				inc hl     ; skip id and ext 
0912 01 40 00			ld bc, STORE_BLOCK_PHY 
0915				if DEBUG_STORESE 
0915					DMARK "SR<" 
0915 f5				push af  
0916 3a 2a 09			ld a, (.dmark)  
0919 32 65 ee			ld (debug_mark),a  
091c 3a 2b 09			ld a, (.dmark+1)  
091f 32 66 ee			ld (debug_mark+1),a  
0922 3a 2c 09			ld a, (.dmark+2)  
0925 32 67 ee			ld (debug_mark+2),a  
0928 18 03			jr .pastdmark  
092a ..			.dmark: db "SR<"  
092d f1			.pastdmark: pop af  
092e			endm  
# End of macro DMARK
092e					CALLMONITOR 
092e cd 6f ee			call debug_vector  
0931				endm  
# End of macro CALLMONITOR
0931				endif 
0931 ed b0			ldir     ; copy data 
0933			 
0933				; move the pointer back and pretend we have a full buffer for next recheck 
0933			 
0933 1b				dec de 
0934 1b				dec de 
0935			 
0935			; TODO do pop below now short circuit loop????? 
0935 c1				pop bc     ; get rid of spare de on stack 
0936				if DEBUG_STORESE 
0936					DMARK "SR>" 
0936 f5				push af  
0937 3a 4b 09			ld a, (.dmark)  
093a 32 65 ee			ld (debug_mark),a  
093d 3a 4c 09			ld a, (.dmark+1)  
0940 32 66 ee			ld (debug_mark+1),a  
0943 3a 4d 09			ld a, (.dmark+2)  
0946 32 67 ee			ld (debug_mark+2),a  
0949 18 03			jr .pastdmark  
094b ..			.dmark: db "SR>"  
094e f1			.pastdmark: pop af  
094f			endm  
# End of macro DMARK
094f					CALLMONITOR 
094f cd 6f ee			call debug_vector  
0952				endm  
# End of macro CALLMONITOR
0952				endif 
0952 c3 e3 07			jp .srext 
0955			 
0955			 
0955			 
0955			 
0955			 
0955			.readdone:		 
0955 e1				pop hl 		 ; return start of data to show as not EOF 
0956 23				inc hl   ; past file id 
0957 23				inc hl   ; past ext 
0958				if DEBUG_STORESE 
0958					DMARK "SRe" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 65 ee			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 66 ee			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 67 ee			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SRe"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd 6f ee			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974 c9					ret 
0975			 
0975			 
0975			 
0975			; 
0975			; Append File 
0975			; 
0975			; hl - file id to locate 
0975			; de - pointer to (multi block) string to write 
0975			 
0975			.sa_notfound: 
0975 d1				pop de 
0976 c9				ret 
0977			 
0977			 
0977			storage_append: 
0977				; hl -  file id to append to 
0977				; de - string to append 
0977			 
0977 d5				push de 
0978				 
0978				if DEBUG_STORESE 
0978					DMARK "AP1" 
0978 f5				push af  
0979 3a 8d 09			ld a, (.dmark)  
097c 32 65 ee			ld (debug_mark),a  
097f 3a 8e 09			ld a, (.dmark+1)  
0982 32 66 ee			ld (debug_mark+1),a  
0985 3a 8f 09			ld a, (.dmark+2)  
0988 32 67 ee			ld (debug_mark+2),a  
098b 18 03			jr .pastdmark  
098d ..			.dmark: db "AP1"  
0990 f1			.pastdmark: pop af  
0991			endm  
# End of macro DMARK
0991					CALLMONITOR 
0991 cd 6f ee			call debug_vector  
0994				endm  
# End of macro CALLMONITOR
0994				endif 
0994			 
0994 7d				ld a, l 
0995 32 68 ea			ld (store_tmpid), a 
0998			 
0998				; get file header  
0998			 
0998 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
099a 3a 68 ea			ld a, (store_tmpid) 
099d 5f				ld e, a 
099e			 
099e 21 40 00				ld hl, STORE_BLOCK_PHY 
09a1 cd ba 05				call storage_findnextid 
09a4			 
09a4 cd 1e 0e			call ishlzero 
09a7 28 cc			jr z, .sa_notfound 
09a9			 
09a9 22 5f ea			ld (store_tmppageid), hl 
09ac			 
09ac				; TODO handle file id not found 
09ac			 
09ac				if DEBUG_STORESE 
09ac					DMARK "AP2" 
09ac f5				push af  
09ad 3a c1 09			ld a, (.dmark)  
09b0 32 65 ee			ld (debug_mark),a  
09b3 3a c2 09			ld a, (.dmark+1)  
09b6 32 66 ee			ld (debug_mark+1),a  
09b9 3a c3 09			ld a, (.dmark+2)  
09bc 32 67 ee			ld (debug_mark+2),a  
09bf 18 03			jr .pastdmark  
09c1 ..			.dmark: db "AP2"  
09c4 f1			.pastdmark: pop af  
09c5			endm  
# End of macro DMARK
09c5					CALLMONITOR 
09c5 cd 6f ee			call debug_vector  
09c8				endm  
# End of macro CALLMONITOR
09c8				endif 
09c8			 
09c8				; update file extent count 
09c8			 
09c8 11 74 ea			ld de, store_page 
09cb			 
09cb cd 87 02			call storage_read_block 
09ce			 
09ce				if DEBUG_STORESE 
09ce					DMARK "AP3" 
09ce f5				push af  
09cf 3a e3 09			ld a, (.dmark)  
09d2 32 65 ee			ld (debug_mark),a  
09d5 3a e4 09			ld a, (.dmark+1)  
09d8 32 66 ee			ld (debug_mark+1),a  
09db 3a e5 09			ld a, (.dmark+2)  
09de 32 67 ee			ld (debug_mark+2),a  
09e1 18 03			jr .pastdmark  
09e3 ..			.dmark: db "AP3"  
09e6 f1			.pastdmark: pop af  
09e7			endm  
# End of macro DMARK
09e7					CALLMONITOR 
09e7 cd 6f ee			call debug_vector  
09ea				endm  
# End of macro CALLMONITOR
09ea				endif 
09ea			;	ld (store_tmppageid), hl 
09ea			 
09ea 3a 76 ea			ld a, (store_page+2) 
09ed 3c				inc a 
09ee 32 76 ea			ld (store_page+2), a 
09f1 32 67 ea			ld (store_tmpext), a 
09f4				 
09f4				if DEBUG_STORESE 
09f4					DMARK "AP3" 
09f4 f5				push af  
09f5 3a 09 0a			ld a, (.dmark)  
09f8 32 65 ee			ld (debug_mark),a  
09fb 3a 0a 0a			ld a, (.dmark+1)  
09fe 32 66 ee			ld (debug_mark+1),a  
0a01 3a 0b 0a			ld a, (.dmark+2)  
0a04 32 67 ee			ld (debug_mark+2),a  
0a07 18 03			jr .pastdmark  
0a09 ..			.dmark: db "AP3"  
0a0c f1			.pastdmark: pop af  
0a0d			endm  
# End of macro DMARK
0a0d					CALLMONITOR 
0a0d cd 6f ee			call debug_vector  
0a10				endm  
# End of macro CALLMONITOR
0a10				endif 
0a10 2a 5f ea			ld hl, (store_tmppageid) 
0a13 11 74 ea			ld de, store_page 
0a16 cd ec 02			call storage_write_block 
0a19			 
0a19				; find free block 
0a19			 
0a19 11 00 00			ld de, 0			 ; file extent to locate 
0a1c			 
0a1c 21 40 00				ld hl, STORE_BLOCK_PHY 
0a1f cd ba 05				call storage_findnextid 
0a22 cd 1e 0e			call ishlzero 
0a25 ca 75 09			jp z, .sa_notfound 
0a28			 
0a28					; TODO handle no space left 
0a28					 
0a28 22 5f ea				ld (store_tmppageid), hl 
0a2b			 
0a2b				if DEBUG_STORESE 
0a2b					DMARK "AP4" 
0a2b f5				push af  
0a2c 3a 40 0a			ld a, (.dmark)  
0a2f 32 65 ee			ld (debug_mark),a  
0a32 3a 41 0a			ld a, (.dmark+1)  
0a35 32 66 ee			ld (debug_mark+1),a  
0a38 3a 42 0a			ld a, (.dmark+2)  
0a3b 32 67 ee			ld (debug_mark+2),a  
0a3e 18 03			jr .pastdmark  
0a40 ..			.dmark: db "AP4"  
0a43 f1			.pastdmark: pop af  
0a44			endm  
# End of macro DMARK
0a44					CALLMONITOR 
0a44 cd 6f ee			call debug_vector  
0a47				endm  
# End of macro CALLMONITOR
0a47				endif 
0a47					; init the buffer with zeros so we can id if the buffer is full or not 
0a47			 
0a47 e5					push hl 
0a48 c5					push bc 
0a49			 
0a49 21 74 ea				ld hl, store_page 
0a4c 06 40				ld b, STORE_BLOCK_PHY 
0a4e 3e 00				ld a, 0 
0a50 77			.zeroblock:	ld (hl), a 
0a51 23					inc hl 
0a52 10 fc				djnz .zeroblock 
0a54			 
0a54 c1					pop bc 
0a55 e1					pop hl 
0a56			 
0a56					; construct block 
0a56			 
0a56 3a 68 ea				ld a, (store_tmpid) 
0a59 32 74 ea				ld (store_page), a   ; file id 
0a5c 3a 67 ea				ld a, (store_tmpext)   ; extent for this block 
0a5f 32 75 ea				ld (store_page+1), a 
0a62			 
0a62 e1					pop hl    ; get string to write 
0a63 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a65 11 76 ea				ld de, store_page+2 
0a68			 
0a68				if DEBUG_STORESE 
0a68					DMARK "AP5" 
0a68 f5				push af  
0a69 3a 7d 0a			ld a, (.dmark)  
0a6c 32 65 ee			ld (debug_mark),a  
0a6f 3a 7e 0a			ld a, (.dmark+1)  
0a72 32 66 ee			ld (debug_mark+1),a  
0a75 3a 7f 0a			ld a, (.dmark+2)  
0a78 32 67 ee			ld (debug_mark+2),a  
0a7b 18 03			jr .pastdmark  
0a7d ..			.dmark: db "AP5"  
0a80 f1			.pastdmark: pop af  
0a81			endm  
# End of macro DMARK
0a81					CALLMONITOR 
0a81 cd 6f ee			call debug_vector  
0a84				endm  
# End of macro CALLMONITOR
0a84				endif 
0a84			 
0a84			 
0a84			 
0a84					; fill buffer with data until end of string or full block 
0a84			 
0a84 7e			.appd:		ld a, (hl) 
0a85 12					ld (de), a 
0a86 fe 00				cp 0 
0a88 28 04				jr z, .appdone 
0a8a 23					inc hl 
0a8b 13					inc de 
0a8c 10 f6				djnz .appd 
0a8e			 
0a8e e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a8f f5					push af   		; save last byte dumped 
0a90			 
0a90			 
0a90 2a 5f ea			ld hl, (store_tmppageid) 
0a93 11 74 ea			ld de, store_page 
0a96				if DEBUG_STORESE 
0a96					DMARK "AP6" 
0a96 f5				push af  
0a97 3a ab 0a			ld a, (.dmark)  
0a9a 32 65 ee			ld (debug_mark),a  
0a9d 3a ac 0a			ld a, (.dmark+1)  
0aa0 32 66 ee			ld (debug_mark+1),a  
0aa3 3a ad 0a			ld a, (.dmark+2)  
0aa6 32 67 ee			ld (debug_mark+2),a  
0aa9 18 03			jr .pastdmark  
0aab ..			.dmark: db "AP6"  
0aae f1			.pastdmark: pop af  
0aaf			endm  
# End of macro DMARK
0aaf					CALLMONITOR 
0aaf cd 6f ee			call debug_vector  
0ab2				endm  
# End of macro CALLMONITOR
0ab2				endif 
0ab2 cd ec 02				call storage_write_block 
0ab5			 
0ab5			 
0ab5				; was that a full block of data written? 
0ab5				; any more to write out? 
0ab5			 
0ab5				; if yes then set vars and jump to start of function again 
0ab5			 
0ab5 f1					pop af 
0ab6 d1					pop de 
0ab7			 
0ab7 fe 00				cp 0		 ; no, string was fully written 
0ab9 c8					ret z 
0aba			 
0aba					; setup vars for next cycle 
0aba			 
0aba 3a 68 ea				ld a, (store_tmpid) 
0abd 6f					ld l, a 
0abe 26 00				ld h, 0 
0ac0			 
0ac0 c3 77 09			 	jp storage_append	 ; yes, need to write out some more 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			if DEBUG_STORECF 
0ac3			storageput:	 
0ac3					ret 
0ac3			storageread: 
0ac3					ld hl, store_page 
0ac3					ld b, 200 
0ac3					ld a,0 
0ac3			.src:		ld (hl),a 
0ac3					inc hl 
0ac3					djnz .src 
0ac3					 
0ac3			 
0ac3					ld de, 0 
0ac3					ld bc, 1 
0ac3					ld hl, store_page 
0ac3					call cfRead 
0ac3			 
0ac3				call cfGetError 
0ac3				ld hl,scratch 
0ac3				call hexout 
0ac3				ld hl, scratch+2 
0ac3				ld a, 0 
0ac3				ld (hl),a 
0ac3				ld de, scratch 
0ac3				ld a,display_row_1 
0ac3				call str_at_display 
0ac3				call update_display 
0ac3			 
0ac3					ld hl, store_page 
0ac3					ld (os_cur_ptr),hl 
0ac3			 
0ac3					ret 
0ac3			endif 
0ac3			 
0ac3			 
0ac3			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ac3			 
0ac3			storage_clear_page: 
0ac3 e5				push hl 
0ac4 d5				push de 
0ac5 c5				push bc 
0ac6 21 74 ea			ld hl, store_page 
0ac9 3e 00			ld a, 0 
0acb 77				ld (hl), a 
0acc			 
0acc 11 75 ea			ld de, store_page+1 
0acf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ad2			 
0ad2 ed b0			ldir 
0ad4				 
0ad4 c1				pop bc 
0ad5 d1				pop de 
0ad6 e1				pop hl 
0ad7 c9				ret 
0ad8			 
0ad8			; eof 
# End of file firmware_storage.asm
0ad8			  
0ad8			; support routines for above hardware abstraction layer  
0ad8			  
0ad8			include "firmware_general.asm"        ; general support functions  
0ad8			 
0ad8			; word look up 
0ad8			 
0ad8			; in 
0ad8			; a is the index 
0ad8			; hl is pointer start of array 
0ad8			; 
0ad8			; returns 
0ad8			; hl to the word 
0ad8			; 
0ad8			 
0ad8			table_lookup:  
0ad8 d5					push de 
0ad9 eb					ex de, hl 
0ada			 
0ada 6f					ld l, a 
0adb 26 00				ld h, 0 
0add 29					add hl, hl 
0ade 19					add hl, de 
0adf 7e					ld a, (hl) 
0ae0 23					inc hl 
0ae1 66					ld h,(hl) 
0ae2 6f					ld l, a 
0ae3			 
0ae3 d1					pop de 
0ae4 c9					ret 
0ae5			 
0ae5			; Delay loops 
0ae5			 
0ae5			 
0ae5			 
0ae5			aDelayInMS: 
0ae5 c5				push bc 
0ae6 47				ld b,a 
0ae7			msdelay: 
0ae7 c5				push bc 
0ae8				 
0ae8			 
0ae8 01 41 00			ld bc,041h 
0aeb cd 03 0b			call delayloop 
0aee c1				pop bc 
0aef 05				dec b 
0af0 20 f5			jr nz,msdelay 
0af2			 
0af2			;if CPU_CLOCK_8MHZ 
0af2			;msdelay8: 
0af2			;	push bc 
0af2			;	 
0af2			; 
0af2			;	ld bc,041h 
0af2			;	call delayloop 
0af2			;	pop bc 
0af2			;	dec b 
0af2			;	jr nz,msdelay8 
0af2			;endif 
0af2			 
0af2			 
0af2 c1				pop bc 
0af3 c9				ret 
0af4			 
0af4			 
0af4			delay250ms: 
0af4				;push de 
0af4 01 00 40			ld bc, 04000h 
0af7 c3 03 0b			jp delayloop 
0afa			delay500ms: 
0afa				;push de 
0afa 01 00 80			ld bc, 08000h 
0afd c3 03 0b			jp delayloop 
0b00			delay1s: 
0b00				;push bc 
0b00			   ; Clobbers A, d and e 
0b00 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0b03			delayloop: 
0b03 c5			    push bc 
0b04			 
0b04			if BASE_CPM 
0b04 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0b07			.cpmloop: 
0b07 c5				push bc 
0b08			 
0b08			endif 
0b08			 
0b08			 
0b08			 
0b08			delayloopi: 
0b08			;	push bc 
0b08			;.dl: 
0b08 cb 47		    bit     0,a    	; 8 
0b0a cb 47		    bit     0,a    	; 8 
0b0c cb 47		    bit     0,a    	; 8 
0b0e e6 ff		    and     255  	; 7 
0b10 0b			    dec     bc      	; 6 
0b11 79			    ld      a,c     	; 4 
0b12 b0			    or      b     	; 4 
0b13 c2 08 0b		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b16			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b16				;pop de 
0b16			;pop bc 
0b16			 
0b16			if BASE_CPM 
0b16 c1				pop bc 
0b17				 
0b17 0b			    dec     bc      	; 6 
0b18 79			    ld      a,c     	; 4 
0b19 b0			    or      b     	; 4 
0b1a c2 07 0b		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b1d				 
0b1d			 
0b1d			endif 
0b1d			;if CPU_CLOCK_8MHZ 
0b1d			;    pop bc 
0b1d			;    push bc 
0b1d			;.dl8: 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    and     255  	; 7 
0b1d			;    dec     bc      	; 6 
0b1d			;    ld      a,c     	; 4 
0b1d			;    or      b     	; 4 
0b1d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1d			;endif 
0b1d			 
0b1d			;if CPU_CLOCK_10MHZ 
0b1d			;    pop bc 
0b1d			;    push bc 
0b1d			;.dl8: 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    and     255  	; 7 
0b1d			;    dec     bc      	; 6 
0b1d			;    ld      a,c     	; 4 
0b1d			;    or      b     	; 4 
0b1d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1d			;endif 
0b1d c1			    pop bc 
0b1e			 
0b1e c9				ret 
0b1f			 
0b1f			 
0b1f			 
0b1f			; eof 
# End of file firmware_general.asm
0b1f			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b1f			; display routines that use the physical hardware abstraction layer 
0b1f			 
0b1f			 
0b1f			; Display an activity indicator 
0b1f			; Each call returns the new char pointed to in hl 
0b1f			 
0b1f			active: 
0b1f 3a c0 eb			ld a, (display_active) 
0b22 fe 06			cp 6 
0b24			 
0b24 20 02			jr nz, .sne 
0b26				; gone past the last one reset sequence 
0b26 3e ff			ld a, 255 
0b28			 
0b28			.sne:   
0b28				; get the next char in seq 
0b28 3c				inc a 
0b29 32 c0 eb			ld (display_active), a 
0b2c			 
0b2c				; look up the string in the table 
0b2c 21 43 0b			ld hl, actseq 
0b2f cb 27			sla a 
0b31 cd f5 0d			call addatohl 
0b34 cd 03 1f			call loadwordinhl 
0b37			 
0b37				; forth will write the to string when pushing so move from rom to ram 
0b37			 
0b37 11 c1 eb			ld de, display_active+1 
0b3a 01 02 00			ld bc, 2 
0b3d ed b0			ldir 
0b3f			 
0b3f 21 c1 eb			ld hl, display_active+1 
0b42 c9				ret 
0b43				 
0b43				 
0b43			 
0b43			 
0b43			;db "|/-\|-\" 
0b43			 
0b43			actseq: 
0b43			 
0b43 51 0b		dw spin0 
0b45 53 0b		dw spin1 
0b47 55 0b		dw spin2 
0b49 57 0b		dw spin3 
0b4b 55 0b		dw spin2 
0b4d 53 0b		dw spin1 
0b4f 51 0b		dw spin0 
0b51			 
0b51 .. 00		spin0: db " ", 0 
0b53 .. 00		spin1: db "-", 0 
0b55 .. 00		spin2: db "+", 0 
0b57 .. 00		spin3: db "#", 0 
0b59			 
0b59			 
0b59			; information window 
0b59			 
0b59			; pass hl with 1st string to display 
0b59			; pass de with 2nd string to display 
0b59			 
0b59			info_panel: 
0b59 e5				push hl 
0b5a			 
0b5a 2a c6 eb			ld hl, (display_fb_active) 
0b5d e5				push hl    ; future de destination 
0b5e 21 ab ed				ld hl, display_fb0 
0b61 22 c6 eb				ld (display_fb_active), hl 
0b64			 
0b64			;	call clear_display 
0b64			 
0b64				if BASE_CPM 
0b64 3e 2e			ld a, '.' 
0b66				else 
0b66				ld a, 165 
0b66				endif 
0b66 cd cd 0b			call fill_display 
0b69			 
0b69			 
0b69 3e 55			ld a, display_row_3 + 5 
0b6b cd db 0b			call str_at_display 
0b6e			 
0b6e e1				pop hl 
0b6f d1				pop de 
0b70			 
0b70 e5				push hl 
0b71			 
0b71			 
0b71 3e 2d			ld a, display_row_2 + 5 
0b73 cd db 0b			call str_at_display 
0b76			 
0b76			 
0b76 cd eb 0b			call update_display 
0b79 cd 08 1b			call next_page_prompt 
0b7c cd c8 0b			call clear_display 
0b7f			 
0b7f				 
0b7f 21 0a ed				ld hl, display_fb1 
0b82 22 c6 eb				ld (display_fb_active), hl 
0b85 cd eb 0b			call update_display 
0b88			 
0b88 e1				pop hl 
0b89			 
0b89 c9				ret 
0b8a			 
0b8a			 
0b8a			 
0b8a			 
0b8a			; TODO windowing? 
0b8a			 
0b8a			; TODO scroll line up 
0b8a			 
0b8a			scroll_up: 
0b8a			 
0b8a e5				push hl 
0b8b d5				push de 
0b8c c5				push bc 
0b8d			 
0b8d				; get frame buffer  
0b8d			 
0b8d 2a c6 eb			ld hl, (display_fb_active) 
0b90 e5				push hl    ; future de destination 
0b91			 
0b91 11 28 00			ld  de, display_cols 
0b94 19				add hl, de 
0b95			 
0b95 d1				pop de 
0b96			 
0b96				;ex de, hl 
0b96 01 9f 00			ld bc, display_fb_len -1  
0b99			;if DEBUG_FORTH_WORDS 
0b99			;	DMARK "SCL" 
0b99			;	CALLMONITOR 
0b99			;endif	 
0b99 ed b0			ldir 
0b9b			 
0b9b				; wipe bottom row 
0b9b			 
0b9b			 
0b9b 2a c6 eb			ld hl, (display_fb_active) 
0b9e 11 a0 00			ld de, display_cols*display_rows 
0ba1 19				add hl, de 
0ba2 06 28			ld b, display_cols 
0ba4 3e 20			ld a, ' ' 
0ba6			.scwipe: 
0ba6 77				ld (hl), a 
0ba7 2b				dec hl 
0ba8 10 fc			djnz .scwipe 
0baa			 
0baa				;pop hl 
0baa			 
0baa c1				pop bc 
0bab d1				pop de 
0bac e1				pop hl 
0bad			 
0bad c9				ret 
0bae			 
0bae			 
0bae			;scroll_upo: 
0bae			;	ld de, display_row_1 
0bae			 ;	ld hl, display_row_2 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			;	ld de, display_row_2 
0bae			 ;	ld hl, display_row_3 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			;	ld de, display_row_3 
0bae			 ;	ld hl, display_row_4 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			 
0bae			; TODO clear row 4 
0bae			 
0bae			;	ret 
0bae			 
0bae				 
0bae			scroll_down: 
0bae			 
0bae e5				push hl 
0baf d5				push de 
0bb0 c5				push bc 
0bb1			 
0bb1				; get frame buffer  
0bb1			 
0bb1 2a c6 eb			ld hl, (display_fb_active) 
0bb4			 
0bb4 11 9f 00			ld de, display_fb_len - 1 
0bb7 19				add hl, de 
0bb8			 
0bb8 e5			push hl    ; future de destination 
0bb9			 
0bb9 11 28 00			ld  de, display_cols 
0bbc ed 52			sbc hl, de 
0bbe			 
0bbe			 
0bbe d1				pop de 
0bbf			 
0bbf			;	ex de, hl 
0bbf 01 9f 00			ld bc, display_fb_len -1  
0bc2			 
0bc2			 
0bc2				 
0bc2			 
0bc2 ed b0			ldir 
0bc4			 
0bc4				; wipe bottom row 
0bc4			 
0bc4			 
0bc4			;	ld hl, (display_fb_active) 
0bc4			;;	ld de, display_cols*display_rows 
0bc4			;;	add hl, de 
0bc4			;	ld b, display_cols 
0bc4			;	ld a, ' ' 
0bc4			;.scwiped: 
0bc4			;	ld (hl), a 
0bc4			;	dec hl 
0bc4			;	djnz .scwiped 
0bc4			 
0bc4				;pop hl 
0bc4			 
0bc4 c1				pop bc 
0bc5 d1				pop de 
0bc6 e1				pop hl 
0bc7			 
0bc7 c9				ret 
0bc8			;scroll_down: 
0bc8			;	ld de, display_row_4 
0bc8			;	ld hl, display_row_3 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;	ld de, display_row_3 
0bc8			; 	ld hl, display_row_2 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;	ld de, display_row_2 
0bc8			;	ld hl, display_row_1 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;;; TODO clear row 1 
0bc8			;	ret 
0bc8			 
0bc8			 
0bc8			 
0bc8			 
0bc8			 
0bc8			; clear active frame buffer 
0bc8			 
0bc8			clear_display: 
0bc8 3e 20			ld a, ' ' 
0bca c3 cd 0b			jp fill_display 
0bcd			 
0bcd			; fill active frame buffer with a char in A 
0bcd			 
0bcd			fill_display: 
0bcd 06 a0			ld b,display_fb_len 
0bcf 2a c6 eb			ld hl, (display_fb_active) 
0bd2 77			.fd1:	ld (hl),a 
0bd3 23				inc hl 
0bd4 10 fc			djnz .fd1 
0bd6 23				inc hl 
0bd7 3e 00			ld a,0 
0bd9 77				ld (hl),a 
0bda			 
0bda			 
0bda c9				ret 
0bdb			; Write string (DE) at pos (A) to active frame buffer 
0bdb			 
0bdb 2a c6 eb		str_at_display:    ld hl,(display_fb_active) 
0bde 06 00					ld b,0 
0be0 4f					ld c,a 
0be1 09					add hl,bc 
0be2 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0be3 b7			            OR   A              ;Null terminator? 
0be4 c8			            RET  Z              ;Yes, so finished 
0be5 77					ld (hl),a 
0be6 23				inc hl 
0be7 13			            INC  DE             ;Point to next character 
0be8 18 f8		            JR   .sad1     ;Repeat 
0bea c9					ret 
0beb			 
0beb			; using current frame buffer write to physical display 
0beb			 
0beb			update_display: 
0beb e5				push hl 
0bec 2a c6 eb			ld hl, (display_fb_active) 
0bef cd 7d 5e			call write_display 
0bf2 e1				pop hl 
0bf3 c9				ret 
0bf4			 
0bf4			; TODO scrolling 
0bf4			 
0bf4			 
0bf4			; move cursor right one char 
0bf4			cursor_right: 
0bf4			 
0bf4				; TODO shift right 
0bf4				; TODO if beyond max col 
0bf4				; TODO       cursor_next_line 
0bf4			 
0bf4 c9				ret 
0bf5			 
0bf5			 
0bf5			cursor_next_line: 
0bf5				; TODO first char 
0bf5				; TODO line down 
0bf5				; TODO if past last row 
0bf5				; TODO    scroll up 
0bf5			 
0bf5 c9				ret 
0bf6			 
0bf6			cursor_left: 
0bf6				; TODO shift left 
0bf6				; TODO if beyond left  
0bf6				; TODO     cursor prev line 
0bf6				 
0bf6 c9				ret 
0bf7			 
0bf7			cursor_prev_line: 
0bf7				; TODO last char 
0bf7				; TODO line up 
0bf7				; TODO if past first row 
0bf7				; TODO   scroll down 
0bf7			 
0bf7 c9				ret 
0bf8			 
0bf8			 
0bf8			cout: 
0bf8				; A - char 
0bf8 c9				ret 
0bf9			 
0bf9			 
0bf9			; Display a menu and allow item selection (optional toggle items) 
0bf9			; 
0bf9			; format: 
0bf9			; hl pointer to word array with zero term for items 
0bf9			; e.g.    db item1 
0bf9			;         db .... 
0bf9			;         db 0 
0bf9			; 
0bf9			; a = starting menu item  
0bf9			; 
0bf9			; de = pointer item toggle array   (todo) 
0bf9			; 
0bf9			; returns item selected in a 1-... 
0bf9			; returns 0 if back button pressed 
0bf9			; 
0bf9			; NOTE: Uses system frame buffer to display 
0bf9			; 
0bf9			; LEFT, Q = go back 
0bf9			; RIGHT, SPACE, CR = select 
0bf9			; UP, A - Up 
0bf9			; DOWN, Z - Down 
0bf9			 
0bf9			 
0bf9			 
0bf9			 
0bf9			 
0bf9			menu: 
0bf9			 
0bf9					; keep array pointer 
0bf9			 
0bf9 22 6d ea				ld (store_tmp1), hl 
0bfc 32 6b ea				ld (store_tmp2), a 
0bff			 
0bff					; check for key bounce 
0bff			 
0bff			if BASE_KEV 
0bff			 
0bff			.mbounce:	call cin 
0bff					cp 0 
0bff					jr nz, .mbounce 
0bff			endif 
0bff					; for ease use ex 
0bff			 
0bff					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bff 21 ab ed				ld hl, display_fb0 
0c02 22 c6 eb				ld (display_fb_active), hl 
0c05			 
0c05 cd c8 0b		.mloop:		call clear_display 
0c08 cd eb 0b				call update_display 
0c0b			 
0c0b					; draw selection id '>' at 1 
0c0b			 
0c0b					; init start of list display 
0c0b			 
0c0b 3e 05				ld a, 5 
0c0d 32 69 ea				ld (store_tmp3), a   ; display row count 
0c10 3a 6b ea				ld a,( store_tmp2) 
0c13 32 6c ea				ld (store_tmp2+1), a   ; display item count 
0c16			 
0c16					 
0c16			.mitem:	 
0c16			 
0c16			 
0c16 3a 6c ea				ld a,(store_tmp2+1) 
0c19 6f					ld l, a 
0c1a 26 00				ld h, 0 
0c1c 29					add hl, hl 
0c1d ed 5b 6d ea			ld de, (store_tmp1) 
0c21 19					add hl, de 
0c22 7e					ld a, (hl) 
0c23 23					inc hl 
0c24 66					ld h,(hl) 
0c25 6f					ld l, a 
0c26			 
0c26 cd 1e 0e				call ishlzero 
0c29 28 1a				jr z, .mdone 
0c2b			 
0c2b eb					ex de, hl 
0c2c 3a 69 ea				ld a, (store_tmp3) 
0c2f cd db 0b				call str_at_display 
0c32					 
0c32			 
0c32					; next item 
0c32 3a 6c ea				ld a, (store_tmp2+1) 
0c35 3c					inc a 
0c36 32 6c ea				ld (store_tmp2+1), a   ; display item count 
0c39			 
0c39			 		; next row 
0c39			 
0c39 3a 69 ea				ld a, (store_tmp3) 
0c3c c6 28				add display_cols 
0c3e 32 69 ea				ld (store_tmp3), a 
0c41			 
0c41					; at end of screen? 
0c41			 
0c41 fe 10				cp display_rows*4 
0c43 20 d1				jr nz, .mitem 
0c45			 
0c45			 
0c45			.mdone: 
0c45 cd 1e 0e				call ishlzero 
0c48 28 08				jr z, .nodn 
0c4a			 
0c4a 3e 78				ld a, display_row_4 
0c4c 11 cb 0c				ld de, .mdown 
0c4f cd db 0b				call str_at_display 
0c52			 
0c52					; draw options to fill the screens with active item on line 1 
0c52					; if current option is 2 or more then display ^ in top 
0c52			 
0c52 3a 6b ea		.nodn:		ld a, (store_tmp2) 
0c55 fe 00				cp 0 
0c57 28 08				jr z, .noup 
0c59			 
0c59 3e 00				ld a, 0 
0c5b 11 c9 0c				ld de, .mup 
0c5e cd db 0b				call str_at_display 
0c61			 
0c61 3e 02		.noup:		ld a, 2 
0c63 11 c7 0c				ld de, .msel 
0c66 cd db 0b				call str_at_display 
0c69			 
0c69					; if current option + 1 is not null then display V in bottom 
0c69					; get key 
0c69 cd eb 0b				call update_display 
0c6c			 
0c6c			 
0c6c					; handle key 
0c6c			 
0c6c cd 2f 5f				call cin_wait 
0c6f			 
0c6f fe 05				cp KEY_UP 
0c71 28 2b				jr z, .mgoup 
0c73 fe 61				cp 'a' 
0c75 28 27				jr z, .mgoup 
0c77 fe 0a				cp KEY_DOWN 
0c79 28 32				jr z, .mgod 
0c7b fe 7a				cp 'z' 
0c7d 28 2e				jr z, .mgod 
0c7f fe 20				cp ' ' 
0c81 28 34				jr z, .goend 
0c83 fe 0c				cp KEY_RIGHT 
0c85 28 30				jr z, .goend 
0c87 fe 0d				cp KEY_CR 
0c89 28 2c				jr z, .goend 
0c8b fe 71				cp 'q' 
0c8d 28 0b				jr z, .goback 
0c8f			 
0c8f fe 0b				cp KEY_LEFT 
0c91 28 07				jr z, .goback 
0c93 fe 08				cp KEY_BS 
0c95 28 03				jr z, .goback 
0c97 c3 05 0c				jp .mloop 
0c9a			 
0c9a			.goback: 
0c9a 3e 00			ld a, 0 
0c9c 18 1d			jr .goend2 
0c9e			 
0c9e				; move up one 
0c9e			.mgoup: 
0c9e 3a 6b ea				ld a, (store_tmp2) 
0ca1 fe 00				cp 0 
0ca3 ca 05 0c				jp z, .mloop 
0ca6 3d					dec a 
0ca7 32 6b ea				ld (store_tmp2), a 
0caa c3 05 0c				jp .mloop 
0cad			 
0cad				; move down one 
0cad			.mgod: 
0cad 3a 6b ea				ld a, (store_tmp2) 
0cb0 3c					inc a 
0cb1 32 6b ea				ld (store_tmp2), a 
0cb4 c3 05 0c				jp .mloop 
0cb7			 
0cb7			 
0cb7			.goend: 
0cb7					; get selected item number 
0cb7			 
0cb7 3a 6b ea				ld a, (store_tmp2) 
0cba 3c					inc a 
0cbb			 
0cbb			.goend2: 
0cbb f5					push af 
0cbc			 
0cbc					; restore active fb 
0cbc					; TODO BUG assumes fb1 
0cbc			 
0cbc 21 0a ed				ld hl, display_fb1 
0cbf 22 c6 eb				ld (display_fb_active), hl 
0cc2			 
0cc2					; restore main regs 
0cc2			 
0cc2			 
0cc2 cd eb 0b				call update_display 
0cc5			 
0cc5 f1					pop af 
0cc6			 
0cc6 c9				ret 
0cc7			 
0cc7 .. 00		.msel:   db ">",0 
0cc9 .. 00		.mup:   db "^",0 
0ccb .. 00		.mdown:   db "v",0 
0ccd			 
0ccd			 
0ccd			; eof 
0ccd			 
# End of file firmware_display.asm
0ccd			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ccd			; random number generators 
0ccd			 
0ccd			 
0ccd			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ccd			 
0ccd			 
0ccd			;-----> Generate a random number 
0ccd			; output a=answer 0<=a<=255 
0ccd			; all registers are preserved except: af 
0ccd			random: 
0ccd e5			        push    hl 
0cce d5			        push    de 
0ccf 2a a5 eb		        ld      hl,(randData) 
0cd2 ed 5f		        ld      a,r 
0cd4 57			        ld      d,a 
0cd5 5e			        ld      e,(hl) 
0cd6 19			        add     hl,de 
0cd7 85			        add     a,l 
0cd8 ac			        xor     h 
0cd9 22 a5 eb		        ld      (randData),hl 
0cdc d1			        pop     de 
0cdd e1			        pop     hl 
0cde c9			        ret 
0cdf			 
0cdf			 
0cdf			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cdf			 
0cdf			 
0cdf			 
0cdf			;------LFSR------ 
0cdf			;James Montelongo 
0cdf			;optimized by Spencer Putt 
0cdf			;out: 
0cdf			; a = 8 bit random number 
0cdf			RandLFSR: 
0cdf 21 ab eb		        ld hl,LFSRSeed+4 
0ce2 5e			        ld e,(hl) 
0ce3 23			        inc hl 
0ce4 56			        ld d,(hl) 
0ce5 23			        inc hl 
0ce6 4e			        ld c,(hl) 
0ce7 23			        inc hl 
0ce8 7e			        ld a,(hl) 
0ce9 47			        ld b,a 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 cb 13		        rl e  
0cfa cb 12			rl d 
0cfc cb 11		        rl c  
0cfe 17				rla 
0cff 67			        ld h,a 
0d00 cb 13		        rl e  
0d02 cb 12			rl d 
0d04 cb 11		        rl c  
0d06 17				rla 
0d07 a8			        xor b 
0d08 cb 13		        rl e  
0d0a cb 12			rl d 
0d0c ac			        xor h 
0d0d a9			        xor c 
0d0e aa			        xor d 
0d0f 21 ad eb		        ld hl,LFSRSeed+6 
0d12 11 ae eb		        ld de,LFSRSeed+7 
0d15 01 07 00		        ld bc,7 
0d18 ed b8		        lddr 
0d1a 12			        ld (de),a 
0d1b c9			        ret 
0d1c			 
0d1c			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d1c			 
0d1c			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d1c			 
0d1c			 
0d1c			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d1c			 
0d1c			prng16: 
0d1c			;Inputs: 
0d1c			;   (seed1) contains a 16-bit seed value 
0d1c			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d1c			;Outputs: 
0d1c			;   HL is the result 
0d1c			;   BC is the result of the LCG, so not that great of quality 
0d1c			;   DE is preserved 
0d1c			;Destroys: 
0d1c			;   AF 
0d1c			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d1c			;160cc 
0d1c			;26 bytes 
0d1c 2a 9f eb		    ld hl,(seed1) 
0d1f 44			    ld b,h 
0d20 4d			    ld c,l 
0d21 29			    add hl,hl 
0d22 29			    add hl,hl 
0d23 2c			    inc l 
0d24 09			    add hl,bc 
0d25 22 9f eb		    ld (seed1),hl 
0d28 2a 9d eb		    ld hl,(seed2) 
0d2b 29			    add hl,hl 
0d2c 9f			    sbc a,a 
0d2d e6 2d		    and %00101101 
0d2f ad			    xor l 
0d30 6f			    ld l,a 
0d31 22 9d eb		    ld (seed2),hl 
0d34 09			    add hl,bc 
0d35 c9			    ret 
0d36			 
0d36			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d36			 
0d36			rand32: 
0d36			;Inputs: 
0d36			;   (seed1_0) holds the lower 16 bits of the first seed 
0d36			;   (seed1_1) holds the upper 16 bits of the first seed 
0d36			;   (seed2_0) holds the lower 16 bits of the second seed 
0d36			;   (seed2_1) holds the upper 16 bits of the second seed 
0d36			;   **NOTE: seed2 must be non-zero 
0d36			;Outputs: 
0d36			;   HL is the result 
0d36			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d36			;Destroys: 
0d36			;   AF 
0d36			;Tested and passes all CAcert tests 
0d36			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d36			;it has a period of 18,446,744,069,414,584,320 
0d36			;roughly 18.4 quintillion. 
0d36			;LFSR taps: 0,2,6,7  = 11000101 
0d36			;291cc 
0d36			;seed1_0=$+1 
0d36			;    ld hl,12345 
0d36			;seed1_1=$+1 
0d36			;    ld de,6789 
0d36			;    ld b,h 
0d36			;    ld c,l 
0d36			;    add hl,hl \ rl e \ rl d 
0d36			;    add hl,hl \ rl e \ rl d 
0d36			;    inc l 
0d36			;    add hl,bc 
0d36			;    ld (seed1_0),hl 
0d36			;    ld hl,(seed1_1) 
0d36			;    adc hl,de 
0d36			;    ld (seed1_1),hl 
0d36			;    ex de,hl 
0d36			;seed2_0=$+1 
0d36			;    ld hl,9876 
0d36			;seed2_1=$+1 
0d36			;    ld bc,54321 
0d36			;    add hl,hl \ rl c \ rl b 
0d36			;    ld (seed2_1),bc 
0d36			;    sbc a,a 
0d36			;    and %11000101 
0d36			;    xor l 
0d36			;    ld l,a 
0d36			;    ld (seed2_0),hl 
0d36			;    ex de,hl 
0d36			;    add hl,bc 
0d36			;    ret 
0d36			; 
0d36			 
0d36			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d36			; 20 bytes, 86 cycles (excluding ret) 
0d36			 
0d36			; returns   hl = pseudorandom number 
0d36			; corrupts   a 
0d36			 
0d36			; generates 16-bit pseudorandom numbers with a period of 65535 
0d36			; using the xorshift method: 
0d36			 
0d36			; hl ^= hl << 7 
0d36			; hl ^= hl >> 9 
0d36			; hl ^= hl << 8 
0d36			 
0d36			; some alternative shift triplets which also perform well are: 
0d36			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d36			 
0d36			;  org 32768 
0d36			 
0d36			xrnd: 
0d36 2a a3 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d39 3e 00		  ld a,0 
0d3b bd			  cp l 
0d3c 20 02		  jr nz, .xrnd1 
0d3e 2e 01		  ld l, 1 
0d40			.xrnd1: 
0d40			 
0d40 7c			  ld a,h 
0d41 1f			  rra 
0d42 7d			  ld a,l 
0d43 1f			  rra 
0d44 ac			  xor h 
0d45 67			  ld h,a 
0d46 7d			  ld a,l 
0d47 1f			  rra 
0d48 7c			  ld a,h 
0d49 1f			  rra 
0d4a ad			  xor l 
0d4b 6f			  ld l,a 
0d4c ac			  xor h 
0d4d 67			  ld h,a 
0d4e			 
0d4e 22 a3 eb		  ld (xrandc),hl 
0d51			 
0d51 c9			  ret 
0d52			;  
0d52			 
0d52			 
0d52			;;;; int maths 
0d52			 
0d52			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d52			; Divide 16-bit values (with 16-bit result) 
0d52			; In: Divide BC by divider DE 
0d52			; Out: BC = result, HL = rest 
0d52			; 
0d52			Div16: 
0d52 21 00 00		    ld hl,0 
0d55 78			    ld a,b 
0d56 06 08		    ld b,8 
0d58			Div16_Loop1: 
0d58 17			    rla 
0d59 ed 6a		    adc hl,hl 
0d5b ed 52		    sbc hl,de 
0d5d 30 01		    jr nc,Div16_NoAdd1 
0d5f 19			    add hl,de 
0d60			Div16_NoAdd1: 
0d60 10 f6		    djnz Div16_Loop1 
0d62 17			    rla 
0d63 2f			    cpl 
0d64 47			    ld b,a 
0d65 79			    ld a,c 
0d66 48			    ld c,b 
0d67 06 08		    ld b,8 
0d69			Div16_Loop2: 
0d69 17			    rla 
0d6a ed 6a		    adc hl,hl 
0d6c ed 52		    sbc hl,de 
0d6e 30 01		    jr nc,Div16_NoAdd2 
0d70 19			    add hl,de 
0d71			Div16_NoAdd2: 
0d71 10 f6		    djnz Div16_Loop2 
0d73 17			    rla 
0d74 2f			    cpl 
0d75 41			    ld b,c 
0d76 4f			    ld c,a 
0d77 c9			ret 
0d78			 
0d78			 
0d78			;http://z80-heaven.wikidot.com/math 
0d78			; 
0d78			;Inputs: 
0d78			;     DE and A are factors 
0d78			;Outputs: 
0d78			;     A is not changed 
0d78			;     B is 0 
0d78			;     C is not changed 
0d78			;     DE is not changed 
0d78			;     HL is the product 
0d78			;Time: 
0d78			;     342+6x 
0d78			; 
0d78			Mult16: 
0d78			 
0d78 06 08		     ld b,8          ;7           7 
0d7a 21 00 00		     ld hl,0         ;10         10 
0d7d 29			       add hl,hl     ;11*8       88 
0d7e 07			       rlca          ;4*8        32 
0d7f 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d81 19			         add hl,de   ;--         -- 
0d82 10 f9		       djnz $-5      ;13*7+8     99 
0d84 c9			ret 
0d85			 
0d85			; 
0d85			; Square root of 16-bit value 
0d85			; In:  HL = value 
0d85			; Out:  D = result (rounded down) 
0d85			; 
0d85			;Sqr16: 
0d85			;    ld de,#0040 
0d85			;    ld a,l 
0d85			;    ld l,h 
0d85			;    ld h,d 
0d85			;    or a 
0d85			;    ld b,8 
0d85			;Sqr16_Loop: 
0d85			;    sbc hl,de 
0d85			;    jr nc,Sqr16_Skip 
0d85			;    add hl,de 
0d85			;Sqr16_Skip: 
0d85			;    ccf 
0d85			;    rl d 
0d85			;    add a,a 
0d85			;    adc hl,hl 
0d85			;    add a,a 
0d85			;    adc hl,hl 
0d85			;    djnz Sqr16_Loop 
0d85			;    ret 
0d85			; 
0d85			; 
0d85			; Divide 8-bit values 
0d85			; In: Divide E by divider C 
0d85			; Out: A = result, B = rest 
0d85			; 
0d85			Div8: 
0d85 af			    xor a 
0d86 06 08		    ld b,8 
0d88			Div8_Loop: 
0d88 cb 13		    rl e 
0d8a 17			    rla 
0d8b 91			    sub c 
0d8c 30 01		    jr nc,Div8_NoAdd 
0d8e 81			    add a,c 
0d8f			Div8_NoAdd: 
0d8f 10 f7		    djnz Div8_Loop 
0d91 47			    ld b,a 
0d92 7b			    ld a,e 
0d93 17			    rla 
0d94 2f			    cpl 
0d95 c9			    ret 
0d96			 
0d96			; 
0d96			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d96			; In: Multiply A with DE 
0d96			; Out: HL = result 
0d96			; 
0d96			Mult12U: 
0d96 2e 00		    ld l,0 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd0 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd0: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd1 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd1: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd2 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd2: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd3 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd3: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad 30 01		    jr nc,Mult12U_NoAdd4 
0daf 19			    add hl,de 
0db0			Mult12U_NoAdd4: 
0db0 29			    add hl,hl 
0db1 87			    add a,a 
0db2 30 01		    jr nc,Mult12U_NoAdd5 
0db4 19			    add hl,de 
0db5			Mult12U_NoAdd5: 
0db5 29			    add hl,hl 
0db6 87			    add a,a 
0db7 30 01		    jr nc,Mult12U_NoAdd6 
0db9 19			    add hl,de 
0dba			Mult12U_NoAdd6: 
0dba 29			    add hl,hl 
0dbb 87			    add a,a 
0dbc d0			    ret nc 
0dbd 19			    add hl,de 
0dbe c9			    ret 
0dbf			 
0dbf			; 
0dbf			; Multiply 8-bit value with a 16-bit value (right rotating) 
0dbf			; In: Multiply A with DE 
0dbf			;      Put lowest value in A for most efficient calculation 
0dbf			; Out: HL = result 
0dbf			; 
0dbf			Mult12R: 
0dbf 21 00 00		    ld hl,0 
0dc2			Mult12R_Loop: 
0dc2 cb 3f		    srl a 
0dc4 30 01		    jr nc,Mult12R_NoAdd 
0dc6 19			    add hl,de 
0dc7			Mult12R_NoAdd: 
0dc7 cb 23		    sla e 
0dc9 cb 12		    rl d 
0dcb b7			    or a 
0dcc c2 c2 0d		    jp nz,Mult12R_Loop 
0dcf c9			    ret 
0dd0			 
0dd0			; 
0dd0			; Multiply 16-bit values (with 32-bit result) 
0dd0			; In: Multiply BC with DE 
0dd0			; Out: BCHL = result 
0dd0			; 
0dd0			Mult32: 
0dd0 79			    ld a,c 
0dd1 48			    ld c,b 
0dd2 21 00 00		    ld hl,0 
0dd5 06 10		    ld b,16 
0dd7			Mult32_Loop: 
0dd7 29			    add hl,hl 
0dd8 17			    rla 
0dd9 cb 11		    rl c 
0ddb 30 07		    jr nc,Mult32_NoAdd 
0ddd 19			    add hl,de 
0dde ce 00		    adc a,0 
0de0 d2 e4 0d		    jp nc,Mult32_NoAdd 
0de3 0c			    inc c 
0de4			Mult32_NoAdd: 
0de4 10 f1		    djnz Mult32_Loop 
0de6 41			    ld b,c 
0de7 4f			    ld c,a 
0de8 c9			    ret 
0de9			 
0de9			 
0de9			 
0de9			; 
0de9			; Multiply 8-bit values 
0de9			; In:  Multiply H with E 
0de9			; Out: HL = result 
0de9			; 
0de9			Mult8: 
0de9 16 00		    ld d,0 
0deb 6a			    ld l,d 
0dec 06 08		    ld b,8 
0dee			Mult8_Loop: 
0dee 29			    add hl,hl 
0def 30 01		    jr nc,Mult8_NoAdd 
0df1 19			    add hl,de 
0df2			Mult8_NoAdd: 
0df2 10 fa		    djnz Mult8_Loop 
0df4 c9			    ret 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			;;http://z80-heaven.wikidot.com/math 
0df5			;;This divides DE by BC, storing the result in DE, remainder in HL 
0df5			; 
0df5			;DE_Div_BC:          ;1281-2x, x is at most 16 
0df5			;     ld a,16        ;7 
0df5			;     ld hl,0        ;10 
0df5			;     jp $+5         ;10 
0df5			;.DivLoop: 
0df5			;       add hl,bc    ;-- 
0df5			;       dec a        ;64 
0df5			;       jr z,.DivLoopEnd        ;86 
0df5			; 
0df5			;       sla e        ;128 
0df5			;       rl d         ;128 
0df5			;       adc hl,hl    ;240 
0df5			;       sbc hl,bc    ;240 
0df5			;       jr nc,.DivLoop ;23|21 
0df5			;       inc e        ;-- 
0df5			;       jp .DivLoop+1 
0df5			; 
0df5			;.DivLoopEnd: 
0df5			 
0df5			;HL_Div_C: 
0df5			;Inputs: 
0df5			;     HL is the numerator 
0df5			;     C is the denominator 
0df5			;Outputs: 
0df5			;     A is the remainder 
0df5			;     B is 0 
0df5			;     C is not changed 
0df5			;     DE is not changed 
0df5			;     HL is the quotient 
0df5			; 
0df5			;       ld b,16 
0df5			;       xor a 
0df5			;         add hl,hl 
0df5			;         rla 
0df5			;         cp c 
0df5			;         jr c,$+4 
0df5			;           inc l 
0df5			;           sub c 
0df5			;         djnz $-7 
0df5			 
0df5			; https://plutiedev.com/z80-add-8bit-to-16bit 
0df5			 
0df5			addatohl: 
0df5 85			    add   a, l    ; A = A+L 
0df6 6f			    ld    l, a    ; L = A+L 
0df7 8c			    adc   a, h    ; A = A+L+H+carry 
0df8 95			    sub   l       ; A = H+carry 
0df9 67			    ld    h, a    ; H = H+carry 
0dfa c9			ret 
0dfb			 
0dfb			addatode: 
0dfb 83			    add   a, e    ; A = A+L 
0dfc 5f			    ld    e, a    ; L = A+L 
0dfd 8a			    adc   a, d    ; A = A+L+H+carry 
0dfe 93			    sub   e       ; A = H+carry 
0dff 57			    ld    d, a    ; H = H+carry 
0e00 c9			ret 
0e01			 
0e01			 
0e01			addatobc: 
0e01 81			    add   a, c    ; A = A+L 
0e02 4f			    ld    c, a    ; L = A+L 
0e03 88			    adc   a, b    ; A = A+L+H+carry 
0e04 91			    sub   c       ; A = H+carry 
0e05 47			    ld    b, a    ; H = H+carry 
0e06 c9			ret 
0e07			 
0e07			subafromhl: 
0e07			   ; If A=0 do nothing 
0e07			    ; Otherwise flip A's sign. Since 
0e07			    ; the upper byte becomes -1, also 
0e07			    ; substract 1 from H. 
0e07 ed 44		    neg 
0e09 ca 12 0e		    jp    z, Skip 
0e0c 25			    dec   h 
0e0d			     
0e0d			    ; Now add the low byte as usual 
0e0d			    ; Two's complement takes care of 
0e0d			    ; ensuring the result is correct 
0e0d 85			    add   a, l 
0e0e 6f			    ld    l, a 
0e0f 8c			    adc   a, h 
0e10 95			    sub   l 
0e11 67			    ld    h, a 
0e12			Skip: 
0e12 c9				ret 
0e13			 
0e13			 
0e13			; compare hl and de 
0e13			; returns:  
0e13			; if hl = de, z=1, s=0, c0=0 
0e13			; if hl > de, z=0, s=0, c=0 
0e13			; if hl < de, z=0, s=1, c=1 
0e13			cmp16:	 
0e13 b7				or a 
0e14 ed 52			sbc hl,de 
0e16 e0				ret po 
0e17 7c				ld a,h 
0e18 1f				rra 
0e19 ee 40			xor 01000000B 
0e1b 37				scf 
0e1c 8f				adc a,a 
0e1d c9				ret 
0e1e			 
0e1e			 
0e1e			; test if hl contains zero   - A is destroyed 
0e1e			 
0e1e			ishlzero:    
0e1e b7				or a     ; reset flags 
0e1f 7c				ld a, h 
0e20 b5				or l        	 
0e21			 
0e21 c9				ret 
0e22			 
0e22			 
0e22			 
0e22			 
0e22			if FORTH_ENABLE_FLOATMATH 
0e22			;include "float/bbcmath.z80" 
0e22			include "float/lpfpcalc.asm" 
0e22			endif 
0e22			 
0e22			 
0e22			; eof 
0e22			 
# End of file firmware_maths.asm
0e22			include "firmware_strings.asm"   ; string handling  
0e22			 
0e22			 
0e22			; TODO string len 
0e22			; input text string, end on cr with zero term 
0e22			; a offset into frame buffer to start prompt 
0e22			; d is max length 
0e22			; e is display size TODO 
0e22			; c is current cursor position 
0e22			; hl is ptr to where string will be stored and edited directly 
0e22			 
0e22			 
0e22			; TODO check limit of buffer for new inserts 
0e22			; TODO check insert does not push beyond buffer 
0e22			; TODO scroll in a limited display area 
0e22			; TODO scroll whole screen on page wrap 
0e22			 
0e22			 
0e22			; TODO use LCD cursor? 
0e22			 
0e22			EDIT_V1: equ 0 
0e22			EDIT_V2: equ 1 
0e22			 
0e22			 
0e22			 
0e22			if EDIT_V2 
0e22			input_str: 
0e22			 
0e22 32 5e ee			    	ld (input_at_pos),a      ; save display position to start 
0e25			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e25 22 61 ee				ld (input_start), hl     ; save ptr to buffer 
0e28			;		ld a, c 
0e28			;		call addatohl 
0e28			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e28 7a					ld a,d 
0e29 32 60 ee			        ld (input_size), a       ; save length of input area 
0e2c 79					ld a, c 
0e2d 32 4f ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e30 7b					ld a,e 
0e31 32 5f ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e34			 
0e34			 
0e34					; add a trailing space to make screen refresh nicer 
0e34			 
0e34					;ld hl, (input_start) 
0e34					;push hl 
0e34					;ld a, 0 
0e34					;call strlent 
0e34					;ld a, l 
0e34					;pop hl 
0e34					;call addatohl 
0e34					;dec hl 
0e34					;ld a, ' ' 
0e34					;ld (hl), a 
0e34					;inc hl 
0e34					;ld (hl), a 
0e34					;inc hl 
0e34					;ld a, 0 
0e34					;ld (hl), a 
0e34			 
0e34			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e34					; init cursor shape if not set by the cin routines 
0e34 21 bb eb				ld hl, cursor_shape 
0e37			if BASE_KEV 
0e37					ld a, 255 
0e37			else 
0e37 3e 23				ld a, '#' 
0e39			endif 
0e39 77					ld (hl), a 
0e3a 23					inc hl 
0e3b 3e 00				ld a, 0 
0e3d 77					ld (hl), a 
0e3e			 
0e3e 3e 09				ld a, CUR_BLINK_RATE 
0e40 32 5a ee				ld (input_cur_flash), a 
0e43 3e 01				ld a, 1 
0e45 32 59 ee				ld (input_cur_onoff),a 
0e48			.inmain:	 
0e48			 
0e48 cd 70 0f				call input_disp_ref 
0e4b			 
0e4b					; save current length of string 
0e4b			 
0e4b 2a 61 ee				ld hl, (input_start) 
0e4e 3e 00				ld a, 0 
0e50 cd 66 11				call strlent 
0e53 7d					ld a,l 
0e54 32 54 ee				ld (input_len), a 
0e57			 
0e57					;call input_disp_oncur 
0e57			 
0e57					; display current state of input buffer 
0e57			 
0e57					; clean any backspace chars 
0e57			 
0e57 3e 20				ld a, " " 
0e59 32 bb e2				ld (scratch),a 
0e5c 3e 00				ld a, 0 
0e5e 32 bc e2				ld (scratch+1),a 
0e61 3a 5e ee				ld a,(input_at_pos) 
0e64 85					add l 
0e65 11 bb e2				ld de, scratch 
0e68 cd db 0b				call str_at_display 
0e6b			 
0e6b					; pause 1ms 
0e6b			 
0e6b 3e 01				ld a, 1 
0e6d cd e5 0a				call aDelayInMS 
0e70			 
0e70			; display cursor if visible on this cycle 
0e70			 
0e70					; dec flash counter 
0e70 3a 5a ee				ld a, (input_cur_flash) 
0e73 3d					dec a 
0e74 32 5a ee				ld (input_cur_flash), a 
0e77 fe 00				cp 0 
0e79 20 0d				jr nz, .inochgstate 
0e7b			 
0e7b			 
0e7b					; reset on change of state 
0e7b 3e 09				ld a, CUR_BLINK_RATE 
0e7d 32 5a ee				ld (input_cur_flash), a 
0e80			 
0e80					; change state 
0e80 3a 59 ee				ld a,(input_cur_onoff) 
0e83 ed 44				neg 
0e85 32 59 ee				ld (input_cur_onoff),a 
0e88			 
0e88			 
0e88			 
0e88			 
0e88					; TODO is cursor visible? 
0e88					; TODO if so then over write the char at curspos pos with the cursor shape 
0e88			 
0e88								 
0e88			 
0e88			.inochgstate: 
0e88 3a 59 ee				ld a,(input_cur_onoff) 
0e8b fe ff				cp 255 
0e8d 28 0e				jr z, .skipcursor 
0e8f 3a 5e ee				ld a, (input_at_pos) 
0e92 47					ld b, a 
0e93 3a 4f ee				ld a, (input_cursor) 
0e96 80					add b 
0e97 11 bb eb				ld de, cursor_shape 
0e9a					 
0e9a cd db 0b				call str_at_display 
0e9d			 
0e9d			.skipcursor: 
0e9d				if DEBUG_INPUTV2 
0e9d			 
0e9d					ld a,(input_at_pos) 
0e9d					ld hl, LFSRSeed 
0e9d					call hexout 
0e9d					ld a, (input_cursor) 
0e9d					ld hl, LFSRSeed+2 
0e9d					call hexout 
0e9d					ld a,(input_size) 
0e9d					ld hl, LFSRSeed+4 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_cur_onoff) 
0e9d					ld hl, LFSRSeed+6 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_cur_flash) 
0e9d					ld hl, LFSRSeed+8 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_len) 
0e9d					ld hl, LFSRSeed+10 
0e9d					call hexout 
0e9d					ld hl, LFSRSeed+12 
0e9d					ld a, 0 
0e9d					ld (hl),a 
0e9d					ld a, display_row_4 
0e9d					ld de, LFSRSeed 
0e9d					call str_at_display 
0e9d				endif 
0e9d cd eb 0b				call update_display 
0ea0			 
0ea0					; TODO keyboard processing 
0ea0			 
0ea0			if BASE_CPM 
0ea0 cd 2f 5f				call cin_wait 
0ea3			else 
0ea3					call cin    ; _wait 
0ea3			endif 
0ea3 fe 00				cp 0 
0ea5 ca 48 0e				jp z, .inmain 
0ea8			 
0ea8 fe 0b				cp KEY_LEFT    ; cursor left 
0eaa ca 62 0f				jp z, input_left 
0ead				 
0ead fe 0c				cp KEY_RIGHT      ; cursor right 
0eaf ca 69 0f				jp z, input_right 
0eb2			 
0eb2 fe 0d				cp KEY_CR 
0eb4 c8					ret z 
0eb5			 
0eb5 fe 08				cp KEY_BS 
0eb7 ca d7 0f				jp z, input_delchar 
0eba			 
0eba fe 06				cp KEY_NEXTWORD 
0ebc ca e3 0e				jp z, input_nxtword 
0ebf			 
0ebf fe 07				cp KEY_PREVWORD 
0ec1 ca 0a 0f				jp z, input_prvword 
0ec4			 
0ec4 fe 0e				cp KEY_HOME    ; jump to start of line 
0ec6 20 08				jr nz, .ikh 
0ec8 3e 00				ld a, 0 
0eca 32 4f ee				ld (input_cursor), a 
0ecd ca 48 0e				jp z, .inmain 
0ed0			.ikh: 
0ed0			 
0ed0 fe 0f				cp KEY_END     ; jump to end of line 
0ed2 20 09				jr nz, .ike 
0ed4 3a 54 ee				ld a, (input_len) 
0ed7 32 4f ee				ld (input_cursor),a 
0eda ca 48 0e				jp z, .inmain 
0edd			.ike: 
0edd fe 05			        cp KEY_UP      ; recall last command 
0edf c8					ret z 
0ee0			;jr nz, .irec 
0ee0			; TODO next word 
0ee0			; TODO prev word 
0ee0			;  
0ee0			; 
0ee0			;	ld hl, scratch 
0ee0			;	ld de, os_last_cmd 
0ee0			;	call strcpy 
0ee0			;		jp  .inmain 
0ee0			.irec: 
0ee0			;		jr .instr1 
0ee0			 
0ee0			 
0ee0			 
0ee0					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0ee0			 
0ee0			; TODO return if any special keys are given 
0ee0			;		ld l, a 
0ee0			;		ld a, 28 ; KEY_F12   ; 27 
0ee0			;		sub l 
0ee0			;		ret m 
0ee0			;		ld a, l 
0ee0					; if no special key then insert as a char 
0ee0			 
0ee0 c3 a9 0f				jp input_inschr 
0ee3			 
0ee3				 
0ee3			input_nxtword: 
0ee3				; jump to start next word after the cursor 
0ee3			 
0ee3			.insknwn:	 
0ee3 cd 9f 0f				call input_curptr	 
0ee6 7e					ld a,(hl)	 
0ee7 fe 00				cp 0 
0ee9 ca 48 0e				jp z, .inmain    ; end of string 
0eec			 
0eec			; if we are on a word, then move off of it 
0eec			 
0eec fe 20				cp ' ' 
0eee 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0ef0 21 4f ee				ld hl, input_cursor 
0ef3 34					inc (hl) 
0ef4 18 ed				jr .insknwn 
0ef6			 
0ef6			.inspace: 
0ef6			 
0ef6 cd 9f 0f				call input_curptr	 
0ef9 7e					ld a,(hl)	 
0efa fe 00				cp 0 
0efc ca 48 0e				jp z, .inmain    ; end of string 
0eff			 
0eff			; if we are on a word, then move off of it 
0eff			 
0eff fe 20				cp ' ' 
0f01 c2 48 0e				jp nz, .inmain     ; we are on non space so at next word 
0f04 21 4f ee				ld hl, input_cursor 
0f07 34					inc (hl) 
0f08 18 ec				jr .inspace 
0f0a			 
0f0a			 
0f0a			 
0f0a			 
0f0a			input_prvword: 
0f0a				; jump to the start of previous word before the cursor 
0f0a			 
0f0a			; where are we to start with currently? 
0f0a			 
0f0a cd 9f 0f				call input_curptr	 
0f0d 7e					ld a, (hl) 
0f0e fe 20				cp ' ' 
0f10 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f12			 
0f12			 
0f12			 
0f12			.inskpwn:	 
0f12 3a 4f ee				ld a,(input_cursor) 
0f15 fe 00				cp 0 
0f17 ca 48 0e				jp z, .inmain    ; start of string 
0f1a			 
0f1a			;if we are on a word, then move off of it 
0f1a			 
0f1a cd 9f 0f				call input_curptr	 
0f1d 7e					ld a, (hl) 
0f1e fe 20				cp ' ' 
0f20 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f22					;jp z, .inmain    ; start of string 
0f22 21 4f ee				ld hl, input_cursor 
0f25 35					dec (hl) 
0f26 18 ea				jr .inskpwn 
0f28			.iwstart: 
0f28 21 4f ee				ld hl, input_cursor 
0f2b 34					inc (hl) 
0f2c c3 48 0e				jp .inmain 
0f2f					 
0f2f			 
0f2f			.inspacep: 
0f2f			 
0f2f					;jp .inmain    ; start of string 
0f2f			 
0f2f			 
0f2f			 
0f2f 3a 4f ee				ld a,(input_cursor) 
0f32 fe 00				cp 0 
0f34 ca 48 0e				jp z, .inmain    ; start of string 
0f37			 
0f37			; if we are on a word, then move off of it 
0f37			 
0f37 cd 9f 0f				call input_curptr	 
0f3a 7e					ld a, (hl) 
0f3b fe 20				cp ' ' 
0f3d c2 46 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f40 21 4f ee				ld hl, input_cursor 
0f43 35					dec (hl) 
0f44 18 e9				jr .inspacep 
0f46			 
0f46			 
0f46			.incharp:	 
0f46					; eat the word to get to the start 
0f46 3a 4f ee				ld a,(input_cursor) 
0f49 fe 00				cp 0 
0f4b ca 48 0e				jp z, .inmain    ; start of string 
0f4e			 
0f4e			; if we are on a word, then move off of it 
0f4e			 
0f4e cd 9f 0f				call input_curptr	 
0f51 7e					ld a, (hl) 
0f52 fe 20				cp ' ' 
0f54 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f56 21 4f ee				ld hl, input_cursor 
0f59 35					dec (hl) 
0f5a 18 ea				jr .incharp 
0f5c			.ipwordst: 
0f5c					; at space before the prev word so reposition over it 
0f5c 21 4f ee				ld hl, input_cursor 
0f5f 34					inc (hl) 
0f60 18 b0				jr .inskpwn 
0f62					 
0f62			 
0f62			 
0f62			input_left: 
0f62				; move cursor left 
0f62 21 4f ee			ld hl, input_cursor 
0f65 35				dec (hl) 
0f66			;	cp 0 
0f66			;	jp z, .inmain    ; ignore left as at the start of the string 
0f66 c3 48 0e			jp .inmain 
0f69			 
0f69			input_right: 
0f69				; move cursor right 
0f69				 
0f69				;ld a, (input_size) 
0f69				;ld b, a 
0f69 21 4f ee			ld hl, input_cursor 
0f6c 34				inc (hl) 
0f6d				;dec b 
0f6d				;cp 0 
0f6d				;jp z, .inmain   ; ignore as at end of the string buffer 
0f6d				;ld a, b 
0f6d				;inc a 
0f6d				;ld (input_cursor), a 
0f6d c3 48 0e			jp .inmain 
0f70			 
0f70			 
0f70			 
0f70			input_disp_ref: 
0f70				; display the text from start of buffer (ie full refresh) 
0f70 3a 5e ee			ld a, (input_at_pos) 
0f73 2a 61 ee			ld hl,(input_start) 
0f76 eb				ex de, hl 
0f77 cd db 0b			call str_at_display  
0f7a c9				ret 
0f7b			input_disp_oncur: 
0f7b				; display the text from cursor position to end of buffer 
0f7b				; TODO position start of string at cursor position on screen 
0f7b				; TODO draw from that point on 
0f7b 3a 4f ee			ld a, (input_cursor) 
0f7e 47				ld b, a 
0f7f 3a 5e ee			ld a, (input_at_pos) 
0f82 80				add b 
0f83 48				ld c, b     ; save a 
0f84 78				ld a, b     ; inc string start for cursor 
0f85 2a 61 ee			ld hl,(input_start) 
0f88 cd f5 0d			call addatohl 
0f8b eb				ex de, hl 
0f8c 79				ld a, c 
0f8d cd db 0b			call str_at_display  
0f90 c9				ret 
0f91			 
0f91			input_nxtw: 
0f91				; Find next word 
0f91 c9				ret 
0f92			 
0f92			input_prvw: 
0f92				; Find previous word 
0f92 c9				ret 
0f93			 
0f93			input_lenrem:   
0f93				; Calculate the length of string remaining from current cursor 
0f93				; position to end of buffer (exc null term) 
0f93				 
0f93 3a 4f ee			ld a, (input_cursor) 
0f96 4f				ld c, a 
0f97 3a 60 ee			ld a, (input_size) 
0f9a 91				sub c 
0f9b 06 00			ld b, 0 
0f9d 0d				dec c 
0f9e c9				ret	 
0f9f			 
0f9f			input_curptr: 
0f9f				; calc address of the character under the cursor 
0f9f				 
0f9f 2a 61 ee			ld hl, (input_start) 
0fa2 3a 4f ee			ld a, (input_cursor) 
0fa5 cd f5 0d			call addatohl 
0fa8 c9				ret 
0fa9			 
0fa9			input_inschr: 
0fa9				; Insert char at cursor position 
0fa9 f5				push af   ; save char 
0faa				;call input_lenrem    ; get bc length of remaining string 
0faa			 
0faa				 
0faa cd 9f 0f			call input_curptr 
0fad			;	ld hl, (input_start) 
0fad			;	ld a, (input_cursor) 
0fad			;	call addatohl 
0fad				;push hl   ; save to come back to 
0fad			 
0fad				; shift everything up one to end of buffer 
0fad			 
0fad				;push hl 
0fad				;dec de 
0fad				;inc de 
0fad			;	ldir 
0fad				 
0fad				;pop hl 
0fad			 
0fad				; are we adding to the end of line? 
0fad			 
0fad 3a 4f ee			ld a, (input_cursor) 
0fb0 47				ld b, a 
0fb1 3a 54 ee			ld a, (input_len) 
0fb4 b8				cp b 
0fb5 20 09			jr nz, .insmid   ; no, insert in middle of text 
0fb7			 
0fb7				; tack on the end of the line 
0fb7 f1				pop af 
0fb8 77				ld (hl), a   ; save new char 
0fb9 23				inc hl 
0fba 3e 00			ld a, 0 
0fbc 77				ld (hl), a 
0fbd c3 69 0f			jp input_right 
0fc0				 
0fc0			.insmid: 
0fc0				; hl has insertion point so move everything up one to allow for insertion 
0fc0				;call input_shiftright 
0fc0 f1				pop af 
0fc1			 
0fc1			.shufinsmid: 
0fc1 47				ld b, a     ; b contains new char, c prev char at this position  
0fc2 7e				ld a, (hl) 
0fc3			 
0fc3 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0fc5 28 07			jr z, .endinsmid 
0fc7 4f				ld c, a 
0fc8 78				ld a, b 
0fc9 77				ld (hl), a 
0fca 23				inc hl 
0fcb 79				ld a, c 
0fcc 18 f3			jr .shufinsmid 
0fce				 
0fce			 
0fce			 
0fce			 
0fce			.endinsmid: 
0fce 78				ld a, b 
0fcf 77				ld (hl), a 
0fd0 23				inc hl 
0fd1 3e 00			ld a, 0 
0fd3 77				ld (hl), a 
0fd4			 
0fd4			 
0fd4			;	ld (hl), a   ; save new char 
0fd4			 
0fd4 c3 69 0f			jp input_right 
0fd7			 
0fd7			;input_shiftright: 
0fd7			;	; shift text right at cursor, hl has shift start 
0fd7			;	push hl 
0fd7			;	push de 
0fd7			;	push bc 
0fd7			; 
0fd7			; 
0fd7			;	; move to end of string past zero term 
0fd7			;	ld hl,(input_start) 
0fd7			;	ld a, (input_len) 
0fd7			;	call addatohl 
0fd7			;	inc hl 
0fd7			;;	inc hl 
0fd7			;;	inc hl 
0fd7			;	ld a, 0 
0fd7			;	ld (hl), a 
0fd7			;;	dec hl 
0fd7			;	 
0fd7			;;	ld (hl), a 
0fd7			;;	dec hl 
0fd7			; 
0fd7			;	push hl 
0fd7			;	pop de 
0fd7			;	inc de 
0fd7			;	 
0fd7			; 
0fd7			;;	ld hl,(input_start) 
0fd7			;;	ld a, (input_cursor) 
0fd7			;;	call addatohl 
0fd7			; 
0fd7			; 
0fd7			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fd7			;	call input_lenrem    ; get bc length of remaining string 
0fd7			;	;ld a, (input_cursor) 
0fd7			;	;ld c, a 
0fd7			;	ld a, (input_len) 
0fd7			;	cp 2 
0fd7			;	jr z, .iskipzero	 
0fd7			;	;sub c 
0fd7			;	;inc a 
0fd7			;	;ld c, a 
0fd7			;	;ld b, 0 
0fd7			;	inc c 
0fd7			;	inc c 
0fd7			;	; move data 
0fd7			;	lddr 
0fd7			;.iskipzero: 
0fd7			; 
0fd7			;	pop bc 
0fd7			;	pop de 
0fd7			;	pop hl 
0fd7			;	ret	 
0fd7			 
0fd7			input_delchar: 
0fd7				; Delete char at cursor position 
0fd7 cd 93 0f			call input_lenrem    ; get bc length of remaining string 
0fda 2a 61 ee			ld hl, (input_start) 
0fdd 3a 4f ee			ld a, (input_cursor) 
0fe0 cd f5 0d			call addatohl 
0fe3			 
0fe3 e5				push hl 
0fe4 d1				pop de 
0fe5 1b				dec de 
0fe6			 
0fe6			.dl:	 
0fe6 ed a0			ldi  
0fe8 7e				ld a, (hl) 
0fe9 fe 00			cp 0 
0feb 28 02			jr z, .dldone 
0fed 18 f7			jr .dl 
0fef			.dldone: 
0fef ed a0			ldi 
0ff1			 
0ff1 c3 62 0f			jp input_left 
0ff4			 
0ff4			 
0ff4			endif 
0ff4			 
0ff4			 
0ff4			 
0ff4			if EDIT_V1 
0ff4			input_str: 
0ff4			 
0ff4				    	ld (input_at_pos),a      ; save display position to start 
0ff4					add c 
0ff4					ld (input_at_cursor),a	; save draw pos of cursor 
0ff4					ld (input_start), hl     ; save ptr to buffer 
0ff4					ld a, c 
0ff4					call addatohl 
0ff4					ld (input_ptr), hl     ; save ptr to point under the cursor 
0ff4					ld a,d 
0ff4				        ld (input_size), a       ; save length of input area 
0ff4					ld a, c 
0ff4					ld (input_cursor),a      ; init cursor start position  
0ff4					ld a,e 
0ff4				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0ff4					 
0ff4					 
0ff4			 
0ff4			;		ld a,(input_ptr) 
0ff4			;		ld (input_under_cursor),a 	; save what is under the cursor 
0ff4			 
0ff4			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0ff4					; init cursor shape if not set by the cin routines 
0ff4					ld hl, cursor_shape 
0ff4			if BASE_KEV 
0ff4					ld a, 255 
0ff4			else 
0ff4					ld a, '#' 
0ff4			endif 
0ff4					ld (hl), a 
0ff4					inc hl 
0ff4					ld a, 0 
0ff4					ld (hl), a 
0ff4			 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4					ld a, 1 
0ff4					ld (input_cur_onoff),a 
0ff4			 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, 'I' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4			.is1:		; main entry loop 
0ff4			 
0ff4			 
0ff4			 
0ff4					; pause 1ms 
0ff4			 
0ff4					ld a, 1 
0ff4					call aDelayInMS 
0ff4			 
0ff4					; dec flash counter 
0ff4					ld a, (input_cur_flash) 
0ff4					dec a 
0ff4					ld (input_cur_flash), a 
0ff4					cp 0 
0ff4					jr nz, .nochgstate 
0ff4			 
0ff4			 
0ff4					; change state 
0ff4					ld a,(input_cur_onoff) 
0ff4					neg 
0ff4					ld (input_cur_onoff),a 
0ff4			 
0ff4			 
0ff4					; reset on change of state 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4			.nochgstate: 
0ff4					 
0ff4					 
0ff4			 
0ff4					; display cursor  
0ff4			 
0ff4			;		ld hl, (input_start) 
0ff4			;		ld a, (input_cursor) 
0ff4			;		call addatohl 
0ff4			 
0ff4					; get char under cursor and replace with cursor 
0ff4			ld hl, (input_ptr) 
0ff4			;		ld a, (hl) 
0ff4			;		ld (input_under_cursor),a 
0ff4			;		ld a, '_' 
0ff4			;		ld (hl), a 
0ff4			 
0ff4					; display string 
0ff4			 
0ff4					ld de, (input_start) 
0ff4					ld a, (input_at_pos) 
0ff4					call str_at_display 
0ff4			;	        call update_display 
0ff4			 
0ff4					; find place to put the cursor 
0ff4			;		add h 
0ff4			;		ld l, display_row_1 
0ff4			;		sub l 
0ff4			; (input_at_pos) 
0ff4					;ld c, a 
0ff4			;		ld a, (input_cursor) 
0ff4			;		ld l, (input_at_pos) 
0ff4			;		;ld b, h 
0ff4			;		add l 
0ff4			;		ld (input_at_cursor),a 
0ff4					;ld l,h 
0ff4			 
0ff4			;		ld h, 0 
0ff4			;		ld l,(input_at_pos) 
0ff4			;		ld a, (input_cursor) 
0ff4			;		call addatohl 
0ff4			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0ff4			;		call subafromhl 
0ff4			;		ld a,l 
0ff4			;		ld (input_at_cursor), a 
0ff4			 
0ff4				if DEBUG_INPUT 
0ff4					ld a, (hardware_diag) 
0ff4					cp 0 
0ff4					jr z, .skip_input_diag 
0ff4			 
0ff4					ld a,(input_at_pos) 
0ff4					ld hl, LFSRSeed 
0ff4					call hexout 
0ff4					ld a, (input_cursor) 
0ff4					ld hl, LFSRSeed+2 
0ff4					call hexout 
0ff4					ld a,(input_at_cursor) 
0ff4					ld hl, LFSRSeed+4 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_cur_onoff) 
0ff4					ld hl, LFSRSeed+6 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_cur_flash) 
0ff4					ld hl, LFSRSeed+8 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_len) 
0ff4					ld hl, LFSRSeed+10 
0ff4					call hexout 
0ff4					ld hl, LFSRSeed+12 
0ff4					ld a, 0 
0ff4					ld (hl),a 
0ff4					ld a, display_row_4 
0ff4					ld de, LFSRSeed 
0ff4					call str_at_display 
0ff4					.skip_input_diag: 
0ff4				endif 
0ff4			 
0ff4					; decide on if we are showing the cursor this time round 
0ff4			 
0ff4					ld a, (input_cur_onoff) 
0ff4					cp 255 
0ff4					jr z, .skipcur 
0ff4			 
0ff4			 
0ff4					ld a,(input_at_cursor) 
0ff4					ld de, cursor_shape 
0ff4					call str_at_display 
0ff4			 
0ff4					; save length of current input string 
0ff4					ld hl, (input_start) 
0ff4					ld a, 0 
0ff4					call strlent 
0ff4					ld a,l 
0ff4					ld (input_len),a 
0ff4			 
0ff4			.skipcur: 
0ff4			 
0ff4				        call update_display 
0ff4					 
0ff4			 
0ff4			 
0ff4					; wait 
0ff4				 
0ff4					; TODO loop without wait to flash the cursor and char under cursor	 
0ff4					call cin    ; _wait 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 
0ff4			 
0ff4					; get ptr to char to input into 
0ff4			 
0ff4					ld c,a 
0ff4					ld hl, (input_start) 
0ff4					ld a, (input_cursor) 
0ff4					call addatohl 
0ff4					ld (input_ptr), hl 
0ff4					ld a,c 
0ff4			 
0ff4					; replace char under cursor 
0ff4			 
0ff4			;		ld hl, (input_ptr) 
0ff4			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ff4			;		ld (hl), a 
0ff4			 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, 'i' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4					cp KEY_HOME 
0ff4					jr nz, .iske 
0ff4			 
0ff4					ld a, (input_at_pos) 
0ff4					ld (input_at_cursor),a 
0ff4					ld a, 0 
0ff4					ld (input_cursor), a 
0ff4					jp .is1 
0ff4					 
0ff4			.iske:		cp KEY_END 
0ff4					jr nz, .isknw 
0ff4					jp .is1 
0ff4			 
0ff4			.isknw:		cp KEY_NEXTWORD 
0ff4					jr nz, .iskpw 
0ff4			 
0ff4			.isknwm:	ld hl, (input_ptr) 
0ff4					ld a,(hl)	 
0ff4					cp 0 
0ff4					jp z, .is1    ; end of string 
0ff4					cp ' ' 
0ff4					jp z, .is1    ; end of word 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4					jr .isknwm 
0ff4			 
0ff4			.iskpw:		cp KEY_PREVWORD 
0ff4					jr nz, .iskl 
0ff4			.iskpwm:	 
0ff4					ld hl, (input_ptr) 
0ff4					ld a,(hl)	 
0ff4					cp 0  
0ff4					jp z, .is1    ; end of string 
0ff4					cp ' ' 
0ff4					jp z, .is1    ; end of word 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4					jr .iskpwm 
0ff4			 
0ff4			 
0ff4			.iskl:		cp KEY_LEFT 
0ff4					jr nz, .isk1 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 		; at start of line to ignore  
0ff4			 
0ff4					dec  a 		; TODO check underflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4					 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk1:		cp KEY_RIGHT 
0ff4					jr nz, .isk2 
0ff4			 
0ff4					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0ff4					ld e,a 
0ff4					ld a, (input_cursor) 
0ff4					cp e 
0ff4					jp z, .is1		; at the end of string so dont go right 
0ff4			 
0ff4					inc  a 		; TODO check overflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk2:		cp KEY_UP 
0ff4			 
0ff4					jr nz, .isk3 
0ff4			 
0ff4					; swap last command with the current on 
0ff4			 
0ff4					; move cursor to start of string 
0ff4					ld hl, (input_start) 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld a, (input_at_pos) 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld a, 0 
0ff4					ld (input_cursor), a 
0ff4					 
0ff4					; swap input and last command buffers 
0ff4			 
0ff4					ld hl, os_cli_cmd 
0ff4					ld de, os_last_cmd 
0ff4					ld b, 255 
0ff4			.swap1:		ld a, (hl) 
0ff4					ld c,a 
0ff4					ld a, (de) 
0ff4					ld (hl), a 
0ff4					ld a,c 
0ff4					ld (de),a 
0ff4					inc hl 
0ff4					inc de 
0ff4					djnz .swap1 
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk3:		cp KEY_BS 
0ff4					jr nz, .isk4 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 		; at start of line to ignore  
0ff4			 
0ff4					dec  a 		; TODO check underflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					; hl is source 
0ff4					; de needs to be source - 1 
0ff4			 
0ff4			;		ld a, 0 
0ff4			;		dec hl 
0ff4			;		ld (hl), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					; shift all data 
0ff4			 
0ff4					push hl 
0ff4					inc hl 
0ff4					pop de 
0ff4					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ff4					ld c,a 
0ff4					ld b,0 
0ff4					ldir  
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					; remove char 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld de,.iblank 
0ff4					call str_at_display 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk4:		cp KEY_CR 
0ff4					jr z, .endinput 
0ff4			 
0ff4					; else add the key press to the end 
0ff4			 
0ff4					ld c, a			; save key pressed 
0ff4			 
0ff4					ld a,(hl)		; get what is currently under char 
0ff4			 
0ff4					cp 0			; we are at the end of the string 
0ff4					jr nz, .onchar 
0ff4					 
0ff4					; add a char to the end of the string 
0ff4				 
0ff4					ld (hl),c 
0ff4					inc hl 
0ff4			;		ld a,' ' 
0ff4			;		ld (hl),a 
0ff4			;		inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4					dec hl 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4					inc a				; TODO check max string length and scroll  
0ff4					ld (input_cursor), a		; inc cursor pos 
0ff4							 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, '+' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4					jp .is1 
0ff4					 
0ff4			 
0ff4			 
0ff4					; if on a char then insert 
0ff4			.onchar: 
0ff4			 
0ff4					; TODO over flow check: make sure insert does not blow out buffer 
0ff4			 
0ff4					; need to do some maths to use lddr 
0ff4			 
0ff4					push hl   ; save char pos 
0ff4					push bc 
0ff4			 
0ff4					ld hl, (input_start) 
0ff4					ld a, (input_len) 
0ff4					call addatohl  		; end of string 
0ff4					inc hl 
0ff4					inc hl		; past zero term 
0ff4					push hl 
0ff4					inc hl 
0ff4					push hl  
0ff4			 
0ff4								; start and end of lddr set, now how much to move? 
0ff4			 
0ff4							 
0ff4					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ff4					ld b,a 
0ff4					ld a,(input_len) 
0ff4					ld e,a 
0ff4					sub b 
0ff4					inc a		;?? 
0ff4					inc a		;?? 
0ff4					inc a		;?? 
0ff4			 
0ff4					ld b,0 
0ff4					ld c,a 
0ff4			 
0ff4				if DEBUG_INPUT 
0ff4					push af 
0ff4					ld a, 'i' 
0ff4					ld (debug_mark),a 
0ff4					pop af 
0ff4			;		CALLMONITOR 
0ff4				endif 
0ff4					pop de 
0ff4					pop hl 
0ff4				if DEBUG_INPUT 
0ff4					push af 
0ff4					ld a, 'I' 
0ff4					ld (debug_mark),a 
0ff4					pop af 
0ff4			;		CALLMONITOR 
0ff4				endif 
0ff4					lddr 
0ff4				 
0ff4			 
0ff4			 
0ff4					; TODO have a key for insert/overwrite mode???? 
0ff4					pop bc 
0ff4					pop hl 
0ff4					ld (hl), c		; otherwise overwrite current char 
0ff4					 
0ff4			 
0ff4			 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4					inc  a 		; TODO check overflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.endinput:	; TODO look for end of string 
0ff4			 
0ff4					; add trailing space for end of token 
0ff4			 
0ff4					ld hl, (input_start) 
0ff4					ld a,(input_len) 
0ff4					call addatohl 
0ff4					ld a, ' ' 
0ff4					ld (hl),a 
0ff4					; TODO eof of parse marker 
0ff4			 
0ff4					inc hl 
0ff4					ld a, 0 
0ff4					ld (hl),a 
0ff4			 
0ff4			 
0ff4					ret 
0ff4			 
0ff4			.iblank: db " ",0 
0ff4			 
0ff4			 
0ff4			input_str_prev:	ld (input_at_pos), a 
0ff4					ld (input_start), hl 
0ff4					ld a,1			; add cursor 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4					ld (input_ptr), hl 
0ff4					ld a,d 
0ff4					ld (input_size), a 
0ff4					ld a,0 
0ff4					ld (input_cursor),a 
0ff4			.instr1:	 
0ff4			 
0ff4					; TODO do block cursor 
0ff4					; TODO switch cursor depending on the modifer key 
0ff4			 
0ff4					; update cursor shape change on key hold 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld a,(cursor_shape) 
0ff4					ld (hl), a 
0ff4			 
0ff4					; display entered text 
0ff4					ld a,(input_at_pos) 
0ff4			            	CALL fLCD_Pos       ;Position cursor to location in A 
0ff4			            	LD   de, (input_start) 
0ff4			            	CALL fLCD_Str       ;Display string pointed to by DE 
0ff4			 
0ff4					call cin 
0ff4					cp 0 
0ff4					jr z, .instr1 
0ff4			 
0ff4					; proecess keyboard controls first 
0ff4			 
0ff4					ld hl,(input_ptr) 
0ff4			 
0ff4					cp KEY_CR	 ; pressing enter ends input 
0ff4					jr z, .instrcr 
0ff4			 
0ff4					cp KEY_BS 	; back space 
0ff4					jr nz, .instr2 
0ff4					; process back space 
0ff4			 
0ff4					; TODO stop back space if at start of string 
0ff4					dec hl 
0ff4					dec hl ; to over write cursor 
0ff4					ld a,(cursor_shape) 
0ff4					;ld a,0 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a," " 
0ff4					ld (hl),a 
0ff4					ld (input_ptr),hl 
0ff4					 
0ff4			 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr2:	cp KEY_LEFT    ; cursor left 
0ff4					jr nz, .instr3 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4				 
0ff4			.instr3:	cp KEY_RIGHT      ; cursor right 
0ff4					jr nz, .instr4 
0ff4					inc hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr4:	cp KEY_HOME    ; jump to start of line 
0ff4					jr nz, .instr5 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr5:	cp KEY_END     ; jump to end of line 
0ff4					jr nz, .instr6 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			.instr6:        cp KEY_UP      ; recall last command 
0ff4					jr nz, .instrnew 
0ff4			 
0ff4				ld hl, scratch 
0ff4				ld de, os_last_cmd 
0ff4				call strcpy 
0ff4					jr .instr1 
0ff4			 
0ff4			 
0ff4			.instrnew:	; no special key pressed to see if we have room to store it 
0ff4			 
0ff4					; TODO do string size test 
0ff4			 
0ff4					dec hl ; to over write cursor 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,(cursor_shape) 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4			 
0ff4					ld (input_ptr),hl 
0ff4					 
0ff4					jr .instr1 
0ff4			.instrcr:	dec hl		; remove cursor 
0ff4					ld a,' '	; TODO add a trailing space for safety 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4			 
0ff4			 
0ff4					; if at end of line scroll up    
0ff4					; TODO detecting only end of line 4 for scroll up  
0ff4			 
0ff4					;ld   
0ff4			 
0ff4					ret 
0ff4			 
0ff4			 
0ff4			endif 
0ff4			; strcpy hl = dest, de source 
0ff4			 
0ff4 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ff5 b7			            OR   A              ;Null terminator? 
0ff6 c8			            RET  Z              ;Yes, so finished 
0ff7 1a					ld a,(de) 
0ff8 77					ld (hl),a 
0ff9 13			            INC  DE             ;Point to next character 
0ffa 23					inc hl 
0ffb 18 f7		            JR   strcpy       ;Repeat 
0ffd c9					ret 
0ffe			 
0ffe			 
0ffe			; TODO string_at  
0ffe			; pass string which starts with lcd offset address and then null term string 
0ffe			 
0ffe			; TODO string to dec 
0ffe			; TODO string to hex 
0ffe			; TODO byte to string hex 
0ffe			; TODO byte to string dec 
0ffe			 
0ffe			 
0ffe			 
0ffe			; from z80uartmonitor 
0ffe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffe			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0ffe			; pass hl for where to put the text 
0ffe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffe c5			hexout:	PUSH BC 
0fff f5					PUSH AF 
1000 47					LD B, A 
1001					; Upper nybble 
1001 cb 3f				SRL A 
1003 cb 3f				SRL A 
1005 cb 3f				SRL A 
1007 cb 3f				SRL A 
1009 cd 19 10				CALL tohex 
100c 77					ld (hl),a 
100d 23					inc hl	 
100e					 
100e					; Lower nybble 
100e 78					LD A, B 
100f e6 0f				AND 0FH 
1011 cd 19 10				CALL tohex 
1014 77					ld (hl),a 
1015 23					inc hl	 
1016					 
1016 f1					POP AF 
1017 c1					POP BC 
1018 c9					RET 
1019					 
1019			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1019			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1019			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1019			tohex: 
1019 e5					PUSH HL 
101a d5					PUSH DE 
101b 16 00				LD D, 0 
101d 5f					LD E, A 
101e 21 26 10				LD HL, .DATA 
1021 19					ADD HL, DE 
1022 7e					LD A, (HL) 
1023 d1					POP DE 
1024 e1					POP HL 
1025 c9					RET 
1026			 
1026			.DATA: 
1026 30					DEFB	30h	; 0 
1027 31					DEFB	31h	; 1 
1028 32					DEFB	32h	; 2 
1029 33					DEFB	33h	; 3 
102a 34					DEFB	34h	; 4 
102b 35					DEFB	35h	; 5 
102c 36					DEFB	36h	; 6 
102d 37					DEFB	37h	; 7 
102e 38					DEFB	38h	; 8 
102f 39					DEFB	39h	; 9 
1030 41					DEFB	41h	; A 
1031 42					DEFB	42h	; B 
1032 43					DEFB	43h	; C 
1033 44					DEFB	44h	; D 
1034 45					DEFB	45h	; E 
1035 46					DEFB	46h	; F 
1036			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1036			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1036			;;    subtract $30, if result > 9 then subtract $7 more 
1036			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1036			atohex: 
1036 d6 30				SUB $30 
1038 fe 0a				CP 10 
103a f8					RET M		; If result negative it was 0-9 so we're done 
103b d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
103d c9					RET		 
103e			 
103e			 
103e			 
103e			 
103e			; Get 2 ASCII characters as hex byte from pointer in hl 
103e			 
103e			BYTERD: 
103e 16 00			LD	D,00h		;Set up 
1040 cd 48 10			CALL	HEXCON		;Get byte and convert to hex 
1043 87				ADD	A,A		;First nibble so 
1044 87				ADD	A,A		;multiply by 16 
1045 87				ADD	A,A		; 
1046 87				ADD	A,A		; 
1047 57				LD	D,A		;Save hi nibble in D 
1048			HEXCON: 
1048 7e				ld a, (hl)		;Get next chr 
1049 23				inc hl 
104a d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
104c fe 0a			CP	00Ah		;Is it 0-9 ? 
104e 38 02			JR	C,NALPHA	;If so miss next bit 
1050 d6 07			SUB	007h		;Else convert alpha 
1052			NALPHA: 
1052 b2				OR	D		;Add hi nibble back 
1053 c9				RET			; 
1054			 
1054			 
1054			; 
1054			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1054			; Since the routines get_byte and therefore get_nibble are called, only valid 
1054			; characters (0-9a-f) are accepted. 
1054			; 
1054			;get_word        push    af 
1054			;                call    get_byte        ; Get the upper byte 
1054			;                ld      h, a 
1054			;                call    get_byte        ; Get the lower byte 
1054			;                ld      l, a 
1054			;                pop     af 
1054			;                ret 
1054			; 
1054			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1054			; the routine get_nibble is used only valid characters are accepted - the  
1054			; input routine only accepts characters 0-9a-f. 
1054			; 
1054 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1055 7e					ld a,(hl) 
1056 23					inc hl 
1057 cd 7c 10		                call    nibble2val      ; Get upper nibble 
105a cb 07		                rlc     a 
105c cb 07		                rlc     a 
105e cb 07		                rlc     a 
1060 cb 07		                rlc     a 
1062 47			                ld      b, a            ; Save upper four bits 
1063 7e					ld a,(hl) 
1064 cd 7c 10		                call    nibble2val      ; Get lower nibble 
1067 b0			                or      b               ; Combine both nibbles 
1068 c1			                pop     bc              ; Restore B (and C) 
1069 c9			                ret 
106a			; 
106a			; Get a hexadecimal digit from the serial line. This routine blocks until 
106a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
106a			; to the serial line interface. The lower 4 bits of A contain the value of  
106a			; that particular digit. 
106a			; 
106a			;get_nibble      ld a,(hl)           ; Read a character 
106a			;                call    to_upper        ; Convert to upper case 
106a			;                call    is_hex          ; Was it a hex digit? 
106a			;                jr      nc, get_nibble  ; No, get another character 
106a			 ;               call    nibble2val      ; Convert nibble to value 
106a			 ;               call    print_nibble 
106a			 ;               ret 
106a			; 
106a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
106a			; A valid hexadecimal digit is denoted by a set C flag. 
106a			; 
106a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
106a			;                ret     nc              ; Yes 
106a			;                cp      '0'             ; Less than '0'? 
106a			;                jr      nc, is_hex_1    ; No, continue 
106a			;                ccf                     ; Complement carry (i.e. clear it) 
106a			;                ret 
106a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
106a			;                ret     c               ; Yes 
106a			;                cp      'A'             ; Less than 'A'? 
106a			;                jr      nc, is_hex_2    ; No, continue 
106a			;                ccf                     ; Yes - clear carry and return 
106a			;                ret 
106a			;is_hex_2        scf                     ; Set carry 
106a			;                ret 
106a			; 
106a			; Convert a single character contained in A to upper case: 
106a			; 
106a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
106c d8			                ret     c 
106d fe 7b		                cp      'z' + 1         ; > 'z'? 
106f d0			                ret     nc              ; Nothing to do, either 
1070 e6 5f		                and     $5f             ; Convert to upper case 
1072 c9			                ret 
1073			 
1073			 
1073			to_lower: 
1073			 
1073			   ; if char is in [A-Z] make it lower case 
1073			 
1073			   ; enter : a = char 
1073			   ; exit  : a = lower case char 
1073			   ; uses  : af 
1073			 
1073 fe 41		   cp 'A' 
1075 d8			   ret c 
1076			    
1076 fe 5b		   cp 'Z'+1 
1078 d0			   ret nc 
1079			    
1079 f6 20		   or $20 
107b c9			   ret 
107c			 
107c			; 
107c			; Expects a hexadecimal digit (upper case!) in A and returns the 
107c			; corresponding value in A. 
107c			; 
107c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
107e 38 02		                jr      c, nibble2val_1 ; Yes 
1080 d6 07		                sub     7               ; Adjust for A-F 
1082 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1084 e6 0f		                and     $f              ; Only return lower 4 bits 
1086 c9			                ret 
1087			; 
1087			; Print_nibble prints a single hex nibble which is contained in the lower  
1087			; four bits of A: 
1087			; 
1087			;print_nibble    push    af              ; We won't destroy the contents of A 
1087			;                and     $f              ; Just in case... 
1087			;                add     a, '0'             ; If we have a digit we are done here. 
1087			;                cp      '9' + 1         ; Is the result > 9? 
1087			;                jr      c, print_nibble_1 
1087			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1087			;print_nibble_1  call    putc            ; Print the nibble and 
1087			;                pop     af              ; restore the original value of A 
1087			;                ret 
1087			;; 
1087			;; Send a CR/LF pair: 
1087			; 
1087			;crlf            push    af 
1087			;                ld      a, cr 
1087			;                call    putc 
1087			;                ld      a, lf 
1087			;                call    putc 
1087			;                pop     af 
1087			;                ret 
1087			; 
1087			; Print_word prints the four hex digits of a word to the serial line. The  
1087			; word is expected to be in HL. 
1087			; 
1087			;print_word      push    hl 
1087			;                push    af 
1087			;                ld      a, h 
1087			;                call    print_byte 
1087			;                ld      a, l 
1087			;                call    print_byte 
1087			;                pop     af 
1087			;                pop     hl 
1087			;                ret 
1087			; 
1087			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1087			; The byte to be printed is expected to be in A. 
1087			; 
1087			;print_byte      push    af              ; Save the contents of the registers 
1087			;                push    bc 
1087			;                ld      b, a 
1087			;                rrca 
1087			;                rrca 
1087			;                rrca 
1087			;                rrca 
1087			;                call    print_nibble    ; Print high nibble 
1087			;                ld      a, b 
1087			;                call    print_nibble    ; Print low nibble 
1087			;                pop     bc              ; Restore original register contents 
1087			;                pop     af 
1087			;                ret 
1087			 
1087			 
1087			 
1087			 
1087			 
1087			fourehexhl:  
1087 7e				ld a,(hl) 
1088 cd 36 10			call atohex 
108b cb 3f				SRL A 
108d cb 3f				SRL A 
108f cb 3f				SRL A 
1091 cb 3f				SRL A 
1093 47				ld b, a 
1094 23				inc hl 
1095 7e				ld a,(hl) 
1096 23				inc hl 
1097 cd 36 10			call atohex 
109a 80				add b 
109b 57				ld d,a 
109c 7e				ld a,(hl) 
109d cd 36 10			call atohex 
10a0 cb 3f				SRL A 
10a2 cb 3f				SRL A 
10a4 cb 3f				SRL A 
10a6 cb 3f				SRL A 
10a8 47				ld b, a 
10a9 23				inc hl 
10aa 7e				ld a,(hl) 
10ab 23				inc hl 
10ac cd 36 10			call atohex 
10af 80				add b 
10b0 5f				ld e, a 
10b1 d5				push de 
10b2 e1				pop hl 
10b3 c9				ret 
10b4			 
10b4			; pass hl. returns z set if the byte at hl is a digit 
10b4			;isdigithl:  
10b4			;	push bc 
10b4			;	ld a,(hl) 
10b4			;	cp ':' 
10b4			;	jr nc, .isdf 		; > 
10b4			;	cp '0' 
10b4			;	jr c, .isdf		; < 
10b4			; 
10b4			;	; TODO find a better way to set z 
10b4			; 
10b4			;	ld b,a 
10b4			;	cp b 
10b4			;	pop bc 
10b4			;	ret 
10b4			; 
10b4			;.isdf:	; not digit so clear z 
10b4			; 
10b4			;	; TODO find a better way to unset z 
10b4			; 
10b4			;	ld b,a 
10b4			;	inc b 
10b4			;	cp b 
10b4			; 
10b4			;	pop bc 
10b4			;	ret 
10b4				 
10b4				 
10b4			 
10b4			 
10b4			; pass hl as the four byte address to load 
10b4			 
10b4			get_word_hl:  
10b4 e5				push hl 
10b5 cd 54 10			call get_byte 
10b8				 
10b8 47				ld b, a 
10b9			 
10b9 e1				pop hl 
10ba 23				inc hl 
10bb 23				inc hl 
10bc			 
10bc			; TODO not able to handle a-f  
10bc 7e				ld a,(hl) 
10bd			;	;cp ':' 
10bd			;	cp 'g' 
10bd			;	jr nc, .single_byte_hl 		; > 
10bd			;	cp 'G' 
10bd			;	jr nc, .single_byte_hl 		; > 
10bd			;	cp '0' 
10bd			;	jr c, .single_byte_hl		; < 
10bd			 
10bd				;call isdigithl 
10bd fe 00			cp 0 
10bf 28 06			jr z, .single_byte_hl 
10c1			 
10c1			.getwhln:   ; hex word so get next byte 
10c1			 
10c1 cd 54 10			call get_byte 
10c4 6f				ld l, a 
10c5 60				ld h,b 
10c6 c9				ret 
10c7 68			.single_byte_hl:   ld l,b 
10c8 26 00				ld h,0 
10ca c9					ret 
10cb			 
10cb			 
10cb			 
10cb			 
10cb 21 6b 18			ld hl,asc+1 
10ce			;	ld a, (hl) 
10ce			;	call nibble2val 
10ce cd 54 10			call get_byte 
10d1			 
10d1			;	call fourehexhl 
10d1 32 ef e2			ld (scratch+52),a 
10d4				 
10d4 21 ed e2			ld hl,scratch+50 
10d7 22 de e5			ld (os_cur_ptr),hl 
10da			 
10da c9				ret 
10db			 
10db			 
10db			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10db			 
10db			; Decimal Unsigned Version 
10db			 
10db			;Number in a to decimal ASCII 
10db			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10db			;Example: display a=56 as "056" 
10db			;input: a = number 
10db			;Output: a=0,value of a in the screen 
10db			;destroys af,bc (don't know about hl and de) 
10db			DispAToASCII: 
10db 0e 9c			ld	c,-100 
10dd cd e7 10			call	.Na1 
10e0 0e f6			ld	c,-10 
10e2 cd e7 10			call	.Na1 
10e5 0e ff			ld	c,-1 
10e7 06 2f		.Na1:	ld	b,'0'-1 
10e9 04			.Na2:	inc	b 
10ea 81				add	a,c 
10eb 38 fc			jr	c,.Na2 
10ed 91				sub	c		;works as add 100/10/1 
10ee f5				push af		;safer than ld c,a 
10ef 78				ld	a,b		;char is in b 
10f0			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f0 f1				pop af		;safer than ld a,c 
10f1 c9				ret 
10f2			 
10f2			; Decimal Signed Version 
10f2			 
10f2			; DispA 
10f2			; -------------------------------------------------------------- 
10f2			; Converts a signed integer value to a zero-terminated ASCII 
10f2			; string representative of that value (using radix 10). 
10f2			; -------------------------------------------------------------- 
10f2			; INPUTS: 
10f2			;     HL     Value to convert (two's complement integer). 
10f2			;     DE     Base address of string destination. (pointer). 
10f2			; -------------------------------------------------------------- 
10f2			; OUTPUTS: 
10f2			;     None 
10f2			; -------------------------------------------------------------- 
10f2			; REGISTERS/MEMORY DESTROYED 
10f2			; AF HL 
10f2			; -------------------------------------------------------------- 
10f2			 
10f2			;DispHLToASCII: 
10f2			;   push    de 
10f2			;   push    bc 
10f2			; 
10f2			;; Detect sign of HL. 
10f2			;    bit    7, h 
10f2			;    jr     z, ._DoConvert 
10f2			; 
10f2			;; HL is negative. Output '-' to string and negate HL. 
10f2			;    ld     a, '-' 
10f2			;    ld     (de), a 
10f2			;    inc    de 
10f2			; 
10f2			;; Negate HL (using two's complement) 
10f2			;    xor    a 
10f2			;    sub    l 
10f2			;    ld     l, a 
10f2			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10f2			;    sbc    a, h 
10f2			;    ld     h, a 
10f2			; 
10f2			;; Convert HL to digit characters 
10f2			;._DoConvert: 
10f2			;    ld     b, 0     ; B will count character length of number 
10f2			;-   ld     a, 10 
10f2			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10f2			;    push   af 
10f2			;    inc    b 
10f2			;    ld     a, h 
10f2			;    or     l 
10f2			;    jr     nz, - 
10f2			; 
10f2			;; Retrieve digits from stack 
10f2			;-   pop    af 
10f2			;    or     $30 
10f2			;    ld     (de), a 
10f2			;    inc    de 
10f2			;    djnz   - 
10f2			; 
10f2			;; Terminate string with NULL 
10f2			;    xor    a 
10f2			;    ld     (de), a 
10f2			; 
10f2			;    pop    bc 
10f2			;    pop    de 
10f2			;    ret 
10f2			 
10f2			;Comments 
10f2			; 
10f2			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10f2			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10f2			;    Note that the output string will not be fixed-width. 
10f2			; 
10f2			;Example Usage 
10f2			; 
10f2			;    ld    hl, -1004 
10f2			;    ld    de, OP1 
10f2			;    call  DispA 
10f2			;    ld    hl, OP1 
10f2			;    syscall  PutS 
10f2			 
10f2			 
10f2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10f2			 
10f2			 
10f2			;Converts an ASCII string to an unsigned 16-bit integer 
10f2			;Quits when it reaches a non-decimal digit 
10f2			 
10f2			string_to_uint16: 
10f2			atoui_16: 
10f2			;Input: 
10f2			;     DE points to the string 
10f2			;Outputs: 
10f2			;     HL is the result 
10f2			;     A is the 8-bit value of the number 
10f2			;     DE points to the byte after the number 
10f2			;Destroys: 
10f2			;     BC 
10f2			;       if the string is non-empty, BC is HL/10 
10f2			;Size:  24 bytes 
10f2			;Speed: 42+d(104+{0,9}) 
10f2			;       d is the number of digits in the number 
10f2			;       max is 640 cycles for a 5 digit number 
10f2			;Assuming no leading zeros: 
10f2			;1 digit:  146cc 
10f2			;2 digit:  250cc 
10f2			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10f2			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10f2			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10f2			;avg: 544.81158447265625cc (544+13297/16384) 
10f2			;=============================================================== 
10f2 21 00 00		  ld hl,0 
10f5			.u16a: 
10f5 1a			  ld a,(de) 
10f6 d6 30		  sub 30h 
10f8 fe 0a		  cp 10 
10fa d0			  ret nc 
10fb 13			  inc de 
10fc 44			  ld b,h 
10fd 4d			  ld c,l 
10fe 29			  add hl,hl 
10ff 29			  add hl,hl 
1100 09			  add hl,bc 
1101 29			  add hl,hl 
1102 85			  add a,l 
1103 6f			  ld l,a 
1104 30 ef		  jr nc,.u16a 
1106 24			  inc h 
1107 c3 f5 10		  jp .u16a 
110a			 
110a			 
110a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
110a			 
110a			;written by Zeda 
110a			;Converts a 16-bit unsigned integer to an ASCII string. 
110a			 
110a			uitoa_16: 
110a			;Input: 
110a			;   DE is the number to convert 
110a			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
110a			;Output: 
110a			;   HL points to the null-terminated ASCII string 
110a			;      NOTE: This isn't necessarily the same as the input HL. 
110a d5			  push de 
110b c5			  push bc 
110c f5			  push af 
110d eb			  ex de,hl 
110e			 
110e 01 f0 d8		  ld bc,-10000 
1111 3e 2f		  ld a,'0'-1 
1113 3c			  inc a 
1114 09			  add hl,bc  
1115 38 fc		   jr c,$-2 
1117 12			  ld (de),a 
1118 13			  inc de 
1119			 
1119 01 e8 03		  ld bc,1000 
111c 3e 3a		  ld a,'9'+1 
111e 3d			  dec a  
111f 09			  add hl,bc  
1120 30 fc		   jr nc,$-2 
1122 12			  ld (de),a 
1123 13			  inc de 
1124			 
1124 01 9c ff		  ld bc,-100 
1127 3e 2f		  ld a,'0'-1 
1129 3c			  inc a  
112a 09			  add hl,bc  
112b 38 fc		   jr c,$-2 
112d 12			  ld (de),a 
112e 13			  inc de 
112f			 
112f 7d			  ld a,l 
1130 26 3a		  ld h,'9'+1 
1132 25			  dec h  
1133 c6 0a		  add a,10  
1135 30 fb		   jr nc,$-3 
1137 c6 30		  add a,'0' 
1139 eb			  ex de,hl 
113a 72			  ld (hl),d 
113b 23			  inc hl 
113c 77			  ld (hl),a 
113d 23			  inc hl 
113e 36 00		  ld (hl),0 
1140			 
1140			;Now strip the leading zeros 
1140 0e fa		  ld c,-6 
1142 09			  add hl,bc 
1143 3e 30		  ld a,'0' 
1145 23			  inc hl  
1146 be			  cp (hl)  
1147 28 fc		  jr z,$-2 
1149			 
1149			;Make sure that the string is non-empty! 
1149 7e			  ld a,(hl) 
114a b7			  or a 
114b 20 01		  jr nz,.atoub 
114d 2b			  dec hl 
114e			.atoub: 
114e			 
114e f1			  pop af 
114f c1			  pop bc 
1150 d1			  pop de 
1151 c9			  ret 
1152			 
1152			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1152			 
1152			toUpper: 
1152			;A is the char. 
1152			;If A is a lowercase letter, this sets it to the matching uppercase 
1152			;18cc or 30cc or 41cc 
1152			;avg: 26.75cc 
1152 fe 61		  cp 'a' 
1154 d8			  ret c 
1155 fe 7b		  cp 'z'+1 
1157 d0			  ret nc 
1158 d6 20		  sub 'a'-'A' 
115a c9			  ret 
115b			 
115b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
115b			 
115b			; String Length 
115b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
115b			 
115b			; Get the length of the null-terminated string starting at $8000 hl 
115b			;    LD     HL, $8000 
115b			 
115b			strlenz: 
115b			 
115b af			    XOR    A               ; Zero is the value we are looking for. 
115c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
115d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
115e			                           ; 65, 536 bytes (the entire addressable memory space). 
115e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1160			 
1160			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1160 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1161 6f			    LD     L, A             ; number of bytes 
1162 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1164 2b			    DEC    HL              ; Compensate for null. 
1165 c9				ret 
1166			 
1166			; Get the length of the A terminated string starting at $8000 hl 
1166			;    LD     HL, $8000 
1166			 
1166			strlent: 
1166			 
1166			                  ; A is the value we are looking for. 
1166 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1168 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
116a			                           ; 65, 536 bytes (the entire addressable memory space). 
116a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116c			 
116c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
116e 2e 00		    LD     L, 0             ; number of bytes 
1170 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1172 2b			    DEC    HL              ; Compensate for null. 
1173 c9				ret 
1174			 
1174			 
1174			;Comparing Strings 
1174			 
1174			;IN    HL     Address of string1. 
1174			;      DE     Address of string2. 
1174			 
1174			; doc given but wrong??? 
1174			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1174			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1174			; tested 
1174			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1174			 
1174			strcmp_old: 
1174 e5			    PUSH   HL 
1175 d5			    PUSH   DE 
1176			 
1176 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1177 be			    CP     (HL)            ; (want to minimize work). 
1178 38 01		    JR     C, Str1IsBigger 
117a 7e			    LD     A, (HL) 
117b			 
117b			Str1IsBigger: 
117b 4f			    LD     C, A             ; Put length in BC 
117c 06 00		    LD     B, 0 
117e 13			    INC    DE              ; Increment pointers to meat of string. 
117f 23			    INC    HL 
1180			 
1180			CmpLoop: 
1180 1a			    LD     A, (DE)          ; Compare bytes. 
1181 ed a1		    CPI 
1183 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1185 13			    INC    DE              ; Update pointer. 
1186 ea 80 11		    JP     PE, CmpLoop 
1189			 
1189 d1			    POP    DE 
118a e1			    POP    HL 
118b 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
118c be			    CP     (HL) 
118d c9			    RET 
118e			 
118e			NoMatch: 
118e 2b			    DEC    HL 
118f be			    CP     (HL)            ; Compare again to affect carry. 
1190 d1			    POP    DE 
1191 e1			    POP    HL 
1192 c9			    RET 
1193			 
1193			;; test strmp 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str2 
1193			;call strcmp 
1193			;jr z, .z1 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "NZ1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.z1: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "ZZ1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str1 
1193			;call strcmp 
1193			;jr z, .z2 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "NZ2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.z2: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "ZZ2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str2 
1193			;call strcmp 
1193			;jr c, .c1 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "Nc1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.c1: 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "cc1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str1 
1193			;call strcmp 
1193			;jr c, .c2 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "Nc2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.c2: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "cc2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;	NEXTW 
1193			;.str1:   db "string1",0 
1193			;.str2:   db "string2",0 
1193			 
1193			; only care about direct match or not 
1193			; hl and de strings 
1193			; zero set if the same 
1193			 
1193			strcmp: 
1193 1a				ld a, (de) 
1194 be				cp (hl) 
1195 28 02			jr z, .ssame 
1197 b7				or a 
1198 c9				ret 
1199			 
1199			.ssame:  
1199 fe 00			cp 0 
119b c8				ret z 
119c			 
119c 23				inc hl 
119d 13				inc de 
119e 18 f3			jr strcmp 
11a0				 
11a0				 
11a0			 
11a0			;Copyright (c) 2014, Luke Maurits 
11a0			;All rights reserved. 
11a0			; 
11a0			;Redistribution and use in source and binary forms, with or without 
11a0			;modification, are permitted provided that the following conditions are met: 
11a0			; 
11a0			;* Redistributions of source code must retain the above copyright notice, this 
11a0			;  list of conditions and the following disclaimer. 
11a0			; 
11a0			;* Redistributions in binary form must reproduce the above copyright notice, 
11a0			;  this list of conditions and the following disclaimer in the documentation 
11a0			;  and/or other materials provided with the distribution. 
11a0			; 
11a0			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
11a0			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
11a0			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
11a0			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
11a0			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
11a0			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
11a0			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
11a0			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
11a0			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
11a0			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
11a0			 
11a0			; https://github.com/lmaurits/lm512/blob/master/string.z80 
11a0			 
11a0			StrictStrCmp: 
11a0				; Load next chars of each string 
11a0 1a				ld a, (de) 
11a1 47				ld b, a 
11a2 7e				ld a, (hl) 
11a3				; Compare 
11a3 b8				cp b 
11a4				; Return non-zero if chars don't match 
11a4 c0				ret nz 
11a5				; Check for end of both strings 
11a5 fe 00			cp "\0" 
11a7				; Return if strings have ended 
11a7 c8				ret z 
11a8				; Otherwise, advance to next chars 
11a8 23				inc hl 
11a9 13				inc de 
11aa 18 f4			jr StrictStrCmp 
11ac			 
11ac			;end 
11ac			; eof 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
# End of file firmware_strings.asm
11ac			include "firmware_memory.asm"   ; malloc and free  
11ac			 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			.mallocsize: db "Wants malloc >256",0 
11ac			.mallocasize: db "MALLOC gives >256",0 
11ac			.malloczero: db "MALLOC gives zero",0 
11ac			 
11ac			malloc_guard_zerolen: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac				ld de, 0 
11ac			        call cmp16 
11ac				jr nz, .lowalloz 
11ac			 
11ac				push hl 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .malloczero 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				call bp_on 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac			.lowalloz: 
11ac			 
11ac			 
11ac				pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_entry: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowalloc 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocsize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac				call bp_on 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdone 
11ac			.lowalloc: 
11ac			 
11ac			 
11ac				pop hl 
11ac			.lowdone:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_exit: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowallocx 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocasize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac				call bp_on 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdonex 
11ac			.lowallocx: 
11ac			 
11ac				pop hl 
11ac			.lowdonex:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			endif 
11ac			 
11ac			if MALLOC_2 
11ac			; Z80 Malloc and Free Functions 
11ac			 
11ac			; Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc: 
11ac				 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_entry 
11ac			endif 
11ac			 
11ac			 
11ac			 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "mal" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of size into A 
11ac			    or h               ; Check if size is zero 
11ac			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11ac			 
11ac			    ; Allocate memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma1" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    call malloc_internal ; Call internal malloc function 
11ac			    pop af             ; Restore AF register 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret                ; Return 
11ac			 
11ac			; Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free: 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of pointer into A 
11ac			    or h               ; Check if pointer is NULL 
11ac			    jp z, free_exit    ; If pointer is NULL, exit 
11ac			 
11ac			    ; Free memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac			    call free_internal  ; Call internal free function 
11ac			    pop af             ; Restore AF register 
11ac			    ret                ; Return 
11ac			 
11ac			; Internal Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc_internal: 
11ac			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to requested size 
11ac			    ex de, hl          ; Save total size in DE, and keep it in HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			 
11ac			    ; Search for free memory block 
11ac			    ld de, (heap_end)  ; Load end of heap into DE 
11ac			    ld bc, 0           ; Initialize counter 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			malloc_search_loop: 
11ac			    ; Check if current block is free 
11ac			    ld a, (hl)         ; Load current block's status (free or used) 
11ac			    cp 0               ; Compare with zero (free) 
11ac			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11ac			 
11ac			    ; Check if current block is large enough 
11ac			    ld a, (hl+1)       ; Load high byte of block size 
11ac			    cp l               ; Compare with low byte of requested size 
11ac			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11ac			 
11ac			    ld a, (hl+2)       ; Load low byte of block size 
11ac			    cp h               ; Compare with high byte of requested size 
11ac			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11ac			 
11ac			    ; Mark block as used 
11ac			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11ac			 
11ac			    ; Calculate remaining space in block 
11ac			    ld bc, 0           ; Clear BC 
11ac			    add hl, bc         ; Increment HL to point to start of data block 
11ac			    add hl, de         ; HL = HL + DE (total size) 
11ac			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to start of data block 
11ac			 
11ac			    ; Save pointer to allocated block in HL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma5" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			malloc_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3           ; Size of management overhead 
11ac			    add hl, bc         ; Move to the next block 
11ac			    inc de             ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e            ; Load low byte of heap end address 
11ac			    cp (hl)            ; Compare with low byte of current address 
11ac			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11ac			    ld a, d            ; Load high byte of heap end address 
11ac			    cp 0               ; Check if it's zero (end of memory) 
11ac			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, allocation failed 
11ac			    xor a              ; Set result to NULL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma6" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			malloc_exit: 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma7" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			; Internal Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free_internal: 
11ac			    ld de, (heap_start) ; Load start of heap into DE 
11ac			    ld bc, 0            ; Initialize counter 
11ac			 
11ac			free_search_loop: 
11ac			    ; Check if current block contains the pointer 
11ac			    ld a, l             ; Load low byte of pointer 
11ac			    cp (hl+1)           ; Compare with high byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			    ld a, h             ; Load high byte of pointer 
11ac			    cp (hl+2)           ; Compare with low byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			 
11ac			    ; Mark block as free 
11ac			    ld (hl), 0          ; Set status byte to indicate free block 
11ac			    ret                 ; Return 
11ac			 
11ac			free_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3            ; Size of management overhead 
11ac			    add hl, bc          ; Move to the next block 
11ac			    inc de              ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e             ; Load low byte of heap end address 
11ac			    cp (hl)             ; Compare with low byte of current address 
11ac			    jr nz, free_search_loop  ; If not equal, continue searching 
11ac			    ld a, d             ; Load high byte of heap end address 
11ac			    cp 0                ; Check if it's zero (end of memory) 
11ac			    jr nz, free_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, pointer is not found in heap 
11ac			    ret 
11ac			 
11ac			free_exit: 
11ac			    ret                 ; Return 
11ac			 
11ac			; Define heap start and end addresses 
11ac			;heap_start:    .dw 0xC000   ; Start of heap 
11ac			;heap_end:      .dw 0xE000   ; End of heap 
11ac			 
11ac			endif 
11ac			 
11ac			 
11ac			if MALLOC_1 
11ac			 
11ac			 
11ac			 
11ac			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11ac			 
11ac			;moved to firmware.asm 
11ac			;heap_start        .equ  0x9000      ; Starting address of heap 
11ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11ac			 
11ac			;      .org 0 
11ac			;      jp    main 
11ac			 
11ac			 
11ac			;      .org  0x100 
11ac			;main: 
11ac			;      ld    HL, 0x8100 
11ac			;      ld    SP, HL 
11ac			; 
11ac			;      call  heap_init 
11ac			; 
11ac			;      ; Make some allocations 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9004 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9014 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9024 
11ac			; 
11ac			;      ; Free some allocations 
11ac			;      ld    HL, 0x9014 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9004 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9024 
11ac			;      call  free 
11ac			; 
11ac			; 
11ac			;      halt 
11ac			 
11ac			 
11ac			;------------------------------------------------------------------------------ 
11ac			;     heap_init                                                               : 
11ac			;                                                                             : 
11ac			; Description                                                                 : 
11ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
11ac			;                                                                             : 
11ac			;     The heap is maintained as a linked list, starting with an initial       : 
11ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11ac			;     the first free block in the heap. Each block then points to the next    : 
11ac			;     free block within the heap, and the free list ends at the first block   : 
11ac			;     with a null pointer to the next free block.                             : 
11ac			;                                                                             : 
11ac			; Parameters                                                                  : 
11ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
11ac			;     address of the heap and its size are required, along with a memory      : 
11ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11ac			;     principally stores a pointer to the first free block in the heap.       : 
11ac			;                                                                             : 
11ac			; Returns                                                                     : 
11ac			;     Nothing                                                                 : 
11ac			;------------------------------------------------------------------------------ 
11ac			heap_init: 
11ac e5			      push  HL 
11ad			 
11ad			      ; Initialise free list struct 
11ad 21 5f 5f		      ld    HL, heap_start 
11b0 22 5a 5f		      ld    (free_list), HL 
11b3 21 00 00		      ld    HL, 0 
11b6 22 5c 5f		      ld    (free_list+2), HL 
11b9			 
11b9			      ; Insert first free block at bottom of heap, consumes entire heap 
11b9 21 92 e2		      ld    HL, heap_start+heap_size-4 
11bc 22 5f 5f		      ld    (heap_start), HL        ; Next block (end of free list) 
11bf 21 33 83		      ld    HL, heap_size-4 
11c2 22 61 5f		      ld    (heap_start+2), HL      ; Block size 
11c5			 
11c5			      ; Insert end of free list block at top of heap - two null words will 
11c5			      ; terminate the free list 
11c5 21 00 00		      ld    HL, 0 
11c8 22 94 e2		      ld    (heap_start+heap_size-2), HL 
11cb 22 92 e2		      ld    (heap_start+heap_size-4), HL 
11ce			 
11ce e1			      pop   HL 
11cf			 
11cf c9			      ret 
11d0			 
11d0			 
11d0			;------------------------------------------------------------------------------ 
11d0			;     malloc                                                                  : 
11d0			;                                                                             : 
11d0			; Description                                                                 : 
11d0			;     Allocates the wanted space from the heap and returns the address of the : 
11d0			;     first useable byte of the allocation.                                   : 
11d0			;                                                                             : 
11d0			;     Allocations can happen in one of two ways:                              : 
11d0			;                                                                             : 
11d0			;     1. A free block may be found which is the exact size wanted. In this    : 
11d0			;        case the block is removed from the free list and retuedn to the      : 
11d0			;        caller.                                                              : 
11d0			;     2. A free block may be found which is larger than the size wanted. In   : 
11d0			;        this case, the larger block is split into two. The first portion of  : 
11d0			;        this block will become the requested space by the malloc call and    : 
11d0			;        is returned to the caller. The second portion becomes a new free     : 
11d0			;        block, and the free list is adjusted to maintain continuity via this : 
11d0			;        newly created block.                                                 : 
11d0			;                                                                             : 
11d0			;     malloc does not set any initial value in the allocated space, the       : 
11d0			;     caller is required to do this as required.                              : 
11d0			;                                                                             : 
11d0			;     This implementation of malloc uses the stack exclusively, and is        : 
11d0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d0			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d0			;     to avoid the use of malloc inside ISRs in general.                      : 
11d0			;                                                                             : 
11d0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d0			;                                                                             : 
11d0			; Parameters                                                                  : 
11d0			;     HL  Number of bytes wanted                                              : 
11d0			;                                                                             : 
11d0			; Returns                                                                     : 
11d0			;     HL  Address of the first useable byte of the allocation                 : 
11d0			;                                                                             : 
11d0			; Flags                                                                       : 
11d0			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d0			;                                                                             : 
11d0			; Stack frame                                                                 : 
11d0			;       |             |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     BC      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     DE      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     IX      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |  prev_free  |                                                       : 
11d0			;   +4  +-------------+                                                       : 
11d0			;       |  this_free  |                                                       : 
11d0			;   +2  +-------------+                                                       : 
11d0			;       |  next_free  |                                                       : 
11d0			;   +0  +-------------+                                                       : 
11d0			;       |             |                                                       : 
11d0			;                                                                             : 
11d0			;------------------------------------------------------------------------------ 
11d0			 
11d0			 
11d0			;malloc: 
11d0			; 
11d0			;	SAVESP ON 1 
11d0			; 
11d0			;	call malloc_code 
11d0			; 
11d0			;	CHECKSP ON 1 
11d0			;	ret 
11d0			 
11d0			 
11d0			malloc: 
11d0 c5			      push  BC 
11d1 d5			      push  DE 
11d2 dd e5		      push  IX 
11d4			if DEBUG_FORTH_MALLOC_HIGH 
11d4			call malloc_guard_entry 
11d4			endif 
11d4			 
11d4					if DEBUG_FORTH_MALLOC 
11d4						DMARK "mal" 
11d4						CALLMONITOR 
11d4					endif 
11d4 7c			      ld    A, H                    ; Exit if no space requested 
11d5 b5			      or    L 
11d6 ca 95 12		      jp    Z, malloc_early_exit 
11d9			 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			; 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			 
11d9			 
11d9			 
11d9			 
11d9					if DEBUG_FORTH_MALLOC 
11d9						DMARK "maA" 
11d9						CALLMONITOR 
11d9					endif 
11d9			      ; Set up stack frame 
11d9 eb			      ex    DE, HL 
11da 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11dd 39			      add   HL, SP 
11de f9			      ld    SP, HL 
11df dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e3 dd 39		      add   IX, SP 
11e5			 
11e5			      ; Setup initial state 
11e5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e8 19			      add   HL, DE 
11e9			 
11e9 44			      ld    B, H                    ; Move want to BC 
11ea 4d			      ld    C, L 
11eb			 
11eb 21 5a 5f		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ee dd 75 04		      ld    (IX+4), L 
11f1 dd 74 05		      ld    (IX+5), H 
11f4			 
11f4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 dd 73 02		      ld    (IX+2), E 
11fa dd 72 03		      ld    (IX+3), D 
11fd eb			      ex    DE, HL                  ; this_free ptr into HL 
11fe			 
11fe					if DEBUG_FORTH_MALLOC 
11fe						DMARK "maB" 
11fe						CALLMONITOR 
11fe					endif 
11fe			      ; Loop through free block list to find some space 
11fe			malloc_find_space: 
11fe 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1202 b3			      or    E 
1203 ca 8f 12		      jp    Z, malloc_no_space 
1206			 
1206 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1209 dd 72 01		      ld    (IX+1), D 
120c			 
120c			      ; Does this block have enough space to make the allocation? 
120c 23			      inc   HL                      ; Load free block size into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210			 
1210 eb			      ex    DE, HL                  ; Check size of block against want 
1211 b7			      or    A                       ; Ensure carry flag clear 
1212 ed 42		      sbc   HL, BC 
1214 e5			      push  HL                      ; Store the result for later (new block size) 
1215			 
1215 ca 64 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1218 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
121a			 
121a			      ; this_free block is not big enough, setup ptrs to test next free block 
121a e1			      pop   HL                      ; Discard previous result 
121b			 
121b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121e dd 66 03		      ld    H, (IX+3) 
1221 dd 75 04		      ld    (IX+4), L 
1224 dd 74 05		      ld    (IX+5), H 
1227			 
1227 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
122a dd 66 01		      ld    H, (IX+1) 
122d dd 75 02		      ld    (IX+2), L 
1230 dd 74 03		      ld    (IX+3), H 
1233			 
1233					if DEBUG_FORTH_MALLOC 
1233						DMARK "MA>" 
1233						CALLMONITOR 
1233					endif 
1233 18 c9		      jr    malloc_find_space 
1235			 
1235			      ; split a bigger block into two - requested size and remaining size 
1235			malloc_alloc_split: 
1235					if DEBUG_FORTH_MALLOC 
1235						DMARK "MAs" 
1235						CALLMONITOR 
1235					endif 
1235 eb			      ex    DE, HL                  ; Calculate address of new free block 
1236 2b			      dec   HL 
1237 2b			      dec   HL 
1238 2b			      dec   HL 
1239 09			      add   HL, BC 
123a			 
123a			      ; Create a new block and point it at next_free 
123a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123d dd 56 01		      ld    D, (IX+1) 
1240			 
1240 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1241 23			      inc   HL 
1242 72			      ld    (HL), D 
1243			 
1243 d1			      pop   DE                      ; Store size of new block into new block 
1244 23			      inc   HL 
1245 73			      ld    (HL), E 
1246 23			      inc   HL 
1247 72			      ld    (HL), D 
1248			 
1248			      ; Update this_free ptr to point to new block 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b			 
124b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124e dd 56 03		      ld    D, (IX+3) 
1251			 
1251 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1254 dd 74 03		      ld    (IX+3), H 
1257			 
1257			      ; Modify this_free block to be allocation 
1257 eb			      ex    DE, HL 
1258 af			      xor   A                       ; Null the next block ptr of allocated block 
1259 77			      ld    (HL), A 
125a 23			      inc   HL 
125b 77			      ld    (HL), A 
125c			 
125c 23			      inc   HL                      ; Store want size into allocated block 
125d 71			      ld    (HL), C 
125e 23			      inc   HL 
125f 70			      ld    (HL), B 
1260 23			      inc   HL 
1261 e5			      push  HL                      ; Address of allocation to return 
1262			 
1262 18 19		      jr    malloc_update_links 
1264			 
1264			malloc_alloc_fit: 
1264 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1265			 
1265					if DEBUG_FORTH_MALLOC 
1265						DMARK "MAf" 
1265						CALLMONITOR 
1265					endif 
1265			      ; Modify this_free block to be allocation 
1265 eb			      ex    DE, HL 
1266 2b			      dec   HL 
1267 2b			      dec   HL 
1268 2b			      dec   HL 
1269			 
1269 af			      xor   A                       ; Null the next block ptr of allocated block 
126a 77			      ld    (HL), A 
126b 23			      inc   HL 
126c 77			      ld    (HL), A 
126d			 
126d 23			      inc   HL                      ; Store address of allocation to return 
126e 23			      inc   HL 
126f 23			      inc   HL 
1270 e5			      push  HL 
1271			 
1271			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1271 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1274 dd 66 01		      ld    H, (IX+1) 
1277			 
1277 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
127a dd 74 03		      ld    (IX+3), H 
127d			 
127d			 
127d			malloc_update_links: 
127d			      ; Update prev_free ptr to point to this_free 
127d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1280 dd 66 05		      ld    H, (IX+5) 
1283			 
1283 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1286 dd 56 03		      ld    D, (IX+3) 
1289			 
1289 73			      ld    (HL), E                 ; this_free ptr into prev_free 
128a 23			      inc   HL 
128b 72			      ld    (HL), D 
128c			 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "Mul" 
128c						CALLMONITOR 
128c					endif 
128c			      ; Clear the Z flag to indicate successful allocation 
128c 7a			      ld    A, D 
128d b3			      or    E 
128e			 
128e d1			      pop   DE                      ; Address of allocation 
128f					if DEBUG_FORTH_MALLOC 
128f						DMARK "MAu" 
128f						CALLMONITOR 
128f					endif 
128f			 
128f			malloc_no_space: 
128f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1292 39			      add   HL, SP 
1293 f9			      ld    SP, HL 
1294			 
1294 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAN" 
1295						CALLMONITOR 
1295					endif 
1295			 
1295			malloc_early_exit: 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAx" 
1295						CALLMONITOR 
1295					endif 
1295 dd e1		      pop   IX 
1297 d1			      pop   DE 
1298 c1			      pop   BC 
1299			 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299 c9			      ret 
129a			 
129a			 
129a			;------------------------------------------------------------------------------ 
129a			;     free                                                                    : 
129a			;                                                                             : 
129a			; Description                                                                 : 
129a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
129a			;     returned by malloc, otherwise the behaviour is undefined.               : 
129a			;                                                                             : 
129a			;     Where possible, directly adjacent free blocks will be merged together   : 
129a			;     into larger blocks to help ensure that the heap does not become         : 
129a			;     excessively fragmented.                                                 : 
129a			;                                                                             : 
129a			;     free does not clear or set any other value into the freed space, and    : 
129a			;     therefore its contents may be visible through subsequent malloc's. The  : 
129a			;     caller should clear the freed space as required.                        : 
129a			;                                                                             : 
129a			;     This implementation of free uses the stack exclusively, and is          : 
129a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
129a			;     advisable to disable interrupts before calling free, and recommended    : 
129a			;     to avoid the use of free inside ISRs in general.                        : 
129a			;                                                                             : 
129a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
129a			;                                                                             : 
129a			; Parameters                                                                  : 
129a			;     HL  Pointer to address of first byte of allocation to be freed          : 
129a			;                                                                             : 
129a			; Returns                                                                     : 
129a			;     Nothing                                                                 : 
129a			;                                                                             : 
129a			; Stack frame                                                                 : 
129a			;       |             |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     BC      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     DE      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     IX      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |  prev_free  |                                                       : 
129a			;   +2  +-------------+                                                       : 
129a			;       |  next_free  |                                                       : 
129a			;   +0  +-------------+                                                       : 
129a			;       |             |                                                       : 
129a			;                                                                             : 
129a			;------------------------------------------------------------------------------ 
129a			free: 
129a c5			      push  BC 
129b d5			      push  DE 
129c dd e5		      push  IX 
129e			 
129e 7c			      ld    A, H                    ; Exit if ptr is null 
129f b5			      or    L 
12a0 ca 64 13		      jp    Z, free_early_exit 
12a3			 
12a3			      ; Set up stack frame 
12a3 eb			      ex    DE, HL 
12a4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a7 39			      add   HL, SP 
12a8 f9			      ld    SP, HL 
12a9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ad dd 39		      add   IX, SP 
12af			 
12af			      ; The address in HL points to the start of the useable allocated space, 
12af			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12af			      ; address of the block itself. 
12af eb			      ex    DE, HL 
12b0 11 fc ff		      ld    DE, -4 
12b3 19			      add   HL, DE 
12b4			 
12b4			      ; An allocated block must have a null next block pointer in it 
12b4 7e			      ld    A, (HL) 
12b5 23			      inc   HL 
12b6 b6			      or    (HL) 
12b7 c2 5f 13		      jp    NZ, free_done 
12ba			 
12ba 2b			      dec   HL 
12bb			 
12bb 44			      ld    B, H                    ; Copy HL to BC 
12bc 4d			      ld    C, L 
12bd			 
12bd			      ; Loop through the free list to find the first block with an address 
12bd			      ; higher than the block being freed 
12bd 21 5a 5f		      ld    HL, free_list 
12c0			 
12c0			free_find_higher_block: 
12c0 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12c1 23			      inc   HL 
12c2 56			      ld    D, (HL) 
12c3 2b			      dec   HL 
12c4			 
12c4 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c7 dd 72 01		      ld    (IX+1), D 
12ca dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12cd dd 74 03		      ld    (IX+3), H 
12d0			 
12d0 78			      ld    A, B                    ; Check if DE is greater than BC 
12d1 ba			      cp    D                       ; Compare MSB first 
12d2 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d4 30 04		      jr    NC, free_find_higher_block_skip 
12d6 79			      ld    A, C 
12d7 bb			      cp    E                       ; Then compare LSB 
12d8 38 08		      jr    C, free_found_higher_block 
12da			 
12da			free_find_higher_block_skip: 
12da 7a			      ld    A, D                    ; Reached the end of the free list? 
12db b3			      or    E 
12dc ca 5f 13		      jp    Z, free_done 
12df			 
12df eb			      ex    DE, HL 
12e0			 
12e0 18 de		      jr    free_find_higher_block 
12e2			 
12e2			free_found_higher_block: 
12e2			      ; Insert freed block between prev and next free blocks 
12e2 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e3 23			      inc   HL 
12e4 70			      ld    (HL), B 
12e5			 
12e5 60			      ld    H, B                    ; Point freed block at next free block 
12e6 69			      ld    L, C 
12e7 73			      ld    (HL), E 
12e8 23			      inc   HL 
12e9 72			      ld    (HL), D 
12ea			 
12ea			      ; Check if the freed block is adjacent to the next free block 
12ea 23			      inc   HL                      ; Load size of freed block into HL 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee eb			      ex    DE, HL 
12ef			 
12ef 09			      add   HL, BC                  ; Add addr of freed block and its size 
12f0			 
12f0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f3 dd 56 01		      ld    D, (IX+1) 
12f6			 
12f6 b7			      or    A                       ; Clear the carry flag 
12f7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f9 20 22		      jr    NZ, free_check_adjacent_to_prev 
12fb			 
12fb			      ; Freed block is adjacent to next, merge into one bigger block 
12fb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12fc 5e			      ld    E, (HL) 
12fd 23			      inc   HL 
12fe 56			      ld    D, (HL) 
12ff e5			      push  HL                      ; Save ptr to next block for later 
1300			 
1300 60			      ld    H, B                    ; Store ptr from next block into freed block 
1301 69			      ld    L, C 
1302 73			      ld    (HL), E 
1303 23			      inc   HL 
1304 72			      ld    (HL), D 
1305			 
1305 e1			      pop   HL                      ; Restore ptr to next block 
1306 23			      inc   HL                      ; Load size of next block into DE 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a d5			      push  DE                      ; Save next block size for later 
130b			 
130b 60			      ld    H, B                    ; Load size of freed block into HL 
130c 69			      ld    L, C 
130d 23			      inc   HL 
130e 23			      inc   HL 
130f 5e			      ld    E, (HL) 
1310 23			      inc   HL 
1311 56			      ld    D, (HL) 
1312 eb			      ex    DE, HL 
1313			 
1313 d1			      pop   DE                      ; Restore size of next block 
1314 19			      add   HL, DE                  ; Add sizes of both blocks 
1315 eb			      ex    DE, HL 
1316			 
1316 60			      ld    H, B                    ; Store new bigger size into freed block 
1317 69			      ld    L, C 
1318 23			      inc   HL 
1319 23			      inc   HL 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d			free_check_adjacent_to_prev: 
131d			      ; Check if the freed block is adjacent to the prev free block 
131d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1320 dd 66 03		      ld    H, (IX+3) 
1323			 
1323 23			      inc   HL                      ; Size of prev free block into DE 
1324 23			      inc   HL 
1325 5e			      ld    E, (HL) 
1326 23			      inc   HL 
1327 56			      ld    D, (HL) 
1328 2b			      dec   HL 
1329 2b			      dec   HL 
132a 2b			      dec   HL 
132b			 
132b 19			      add   HL, DE                  ; Add prev block addr and size 
132c			 
132c b7			      or    A                       ; Clear the carry flag 
132d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132f 20 2e		      jr    NZ, free_done 
1331			 
1331			      ; Freed block is adjacent to prev, merge into one bigger block 
1331 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1332 69			      ld    L, C 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 e5			      push  HL                      ; Save freed block ptr for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
133a dd 66 03		      ld    H, (IX+3) 
133d 73			      ld    (HL), E 
133e 23			      inc   HL 
133f 72			      ld    (HL), D 
1340			 
1340 e1			      pop   HL                      ; Restore freed block ptr 
1341 23			      inc   HL                      ; Load size of freed block into DE 
1342 5e			      ld    E, (HL) 
1343 23			      inc   HL 
1344 56			      ld    D, (HL) 
1345 d5			      push  DE                      ; Save freed block size for later 
1346			 
1346 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1349 dd 66 03		      ld    H, (IX+3) 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e 5e			      ld    E, (HL) 
134f 23			      inc   HL 
1350 56			      ld    D, (HL) 
1351			 
1351 e1			      pop   HL                      ; Add sizes of both blocks 
1352 19			      add   HL, DE 
1353 eb			      ex    DE, HL 
1354			 
1354 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1357 dd 66 03		      ld    H, (IX+3) 
135a 23			      inc   HL 
135b 23			      inc   HL 
135c 73			      ld    (HL), E 
135d 23			      inc   HL 
135e 72			      ld    (HL), D 
135f			 
135f			free_done: 
135f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1362 39			      add   HL, SP 
1363 f9			      ld    SP, HL 
1364			 
1364			free_early_exit: 
1364 dd e1		      pop   IX 
1366 d1			      pop   DE 
1367 c1			      pop   BC 
1368			 
1368 c9			      ret 
1369			 
1369			; moved to firmware.asm 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			;                  .dw   0 
1369			 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_3 
1369			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1369			;heap_start        .equ  0x9000      ; Starting address of heap 
1369			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1369			; 
1369			 ;     .org 0 
1369			  ;    jp    main 
1369			; 
1369			; 
1369			 ;     .org  0x100 
1369			;main: 
1369			 ;     ld    HL, 0x8100 
1369			  ;    ld    SP, HL 
1369			; 
1369			;      call  heap_init 
1369			 
1369			      ; Make some allocations 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9004 
1369			; 
1369			 ;     ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9014 
1369			 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9024 
1369			 
1369			      ; Free some allocations 
1369			;      ld    HL, 0x9014 
1369			;      call  free 
1369			 
1369			;      ld    HL, 0x9004 
1369			;      call  free 
1369			; 
1369			;      ld    HL, 0x9024 
1369			;      call  free 
1369			 
1369			 
1369			 ;     halt 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     heap_init                                                               : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Initialise the heap and make it ready for malloc and free operations.   : 
1369			;                                                                             : 
1369			;     The heap is maintained as a linked list, starting with an initial       : 
1369			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1369			;     the first free block in the heap. Each block then points to the next    : 
1369			;     free block within the heap, and the free list ends at the first block   : 
1369			;     with a null pointer to the next free block.                             : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     Inputs are compile-time only. Two defines which specify the starting    : 
1369			;     address of the heap and its size are required, along with a memory      : 
1369			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1369			;     principally stores a pointer to the first free block in the heap.       : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;------------------------------------------------------------------------------ 
1369			heap_init: 
1369			      push  HL 
1369			 
1369			      ; Initialise free list struct 
1369			      ld    HL, heap_start 
1369			      ld    (free_list), HL 
1369			      ld    HL, 0 
1369			      ld    (free_list+2), HL 
1369			 
1369			      ; Insert first free block at bottom of heap, consumes entire heap 
1369			      ld    HL, heap_start+heap_size-4 
1369			      ld    (heap_start), HL        ; Next block (end of free list) 
1369			      ld    HL, heap_size-4 
1369			      ld    (heap_start+2), HL      ; Block size 
1369			 
1369			      ; Insert end of free list block at top of heap - two null words will 
1369			      ; terminate the free list 
1369			      ld    HL, 0 
1369			      ld    (heap_start+heap_size-2), HL 
1369			      ld    (heap_start+heap_size-4), HL 
1369			 
1369			      pop   HL 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     malloc                                                                  : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Allocates the wanted space from the heap and returns the address of the : 
1369			;     first useable byte of the allocation.                                   : 
1369			;                                                                             : 
1369			;     Allocations can happen in one of two ways:                              : 
1369			;                                                                             : 
1369			;     1. A free block may be found which is the exact size wanted. In this    : 
1369			;        case the block is removed from the free list and retuedn to the      : 
1369			;        caller.                                                              : 
1369			;     2. A free block may be found which is larger than the size wanted. In   : 
1369			;        this case, the larger block is split into two. The first portion of  : 
1369			;        this block will become the requested space by the malloc call and    : 
1369			;        is returned to the caller. The second portion becomes a new free     : 
1369			;        block, and the free list is adjusted to maintain continuity via this : 
1369			;        newly created block.                                                 : 
1369			;                                                                             : 
1369			;     malloc does not set any initial value in the allocated space, the       : 
1369			;     caller is required to do this as required.                              : 
1369			;                                                                             : 
1369			;     This implementation of malloc uses the stack exclusively, and is        : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling malloc, and recommended  : 
1369			;     to avoid the use of malloc inside ISRs in general.                      : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Number of bytes wanted                                              : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     HL  Address of the first useable byte of the allocation                 : 
1369			;                                                                             : 
1369			; Flags                                                                       : 
1369			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +4  +-------------+                                                       : 
1369			;       |  this_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			malloc: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if no space requested 
1369			      or    L 
1369			      jp    Z, malloc_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; Setup initial state 
1369			      ld    HL, 4                   ; want must also include space used by block struct 
1369			      add   HL, DE 
1369			 
1369			      ld    B, H                    ; Move want to BC 
1369			      ld    C, L 
1369			 
1369			      ld    HL, free_list           ; Store prev_free ptr to stack 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    E, (HL)                 ; Store this_free ptr to stack 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ld    (IX+2), E 
1369			      ld    (IX+3), D 
1369			      ex    DE, HL                  ; this_free ptr into HL 
1369			 
1369			      ; Loop through free block list to find some space 
1369			malloc_find_space: 
1369			      ld    E, (HL)                 ; Load next_free ptr into DE 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1369			      or    E 
1369			      jp    Z, malloc_no_space 
1369			 
1369			      ld    (IX+0), E               ; Store next_free ptr to stack 
1369			      ld    (IX+1), D 
1369			 
1369			      ; Does this block have enough space to make the allocation? 
1369			      inc   HL                      ; Load free block size into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ex    DE, HL                  ; Check size of block against want 
1369			      or    A                       ; Ensure carry flag clear 
1369			      sbc   HL, BC 
1369			      push  HL                      ; Store the result for later (new block size) 
1369			 
1369			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1369			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1369			 
1369			      ; this_free block is not big enough, setup ptrs to test next free block 
1369			      pop   HL                      ; Discard previous result 
1369			 
1369			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1369			      ld    H, (IX+3) 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1369			      ld    H, (IX+1) 
1369			      ld    (IX+2), L 
1369			      ld    (IX+3), H 
1369			 
1369			      jr    malloc_find_space 
1369			 
1369			      ; split a bigger block into two - requested size and remaining size 
1369			malloc_alloc_split: 
1369			      ex    DE, HL                  ; Calculate address of new free block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      add   HL, BC 
1369			 
1369			      ; Create a new block and point it at next_free 
1369			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      ld    (HL), E                 ; Store next_free ptr into new block 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   DE                      ; Store size of new block into new block 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Update this_free ptr to point to new block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1369			      ld    (IX+3), H 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store want size into allocated block 
1369			      ld    (HL), C 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			      inc   HL 
1369			      push  HL                      ; Address of allocation to return 
1369			 
1369			      jr    malloc_update_links 
1369			 
1369			malloc_alloc_fit: 
1369			      pop   HL                      ; Dont need new block size, want is exact fit 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store address of allocation to return 
1369			      inc   HL 
1369			      inc   HL 
1369			      push  HL 
1369			 
1369			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1369			      ld    L, (IX+0)               ; next_free to HL 
1369			      ld    H, (IX+1) 
1369			 
1369			      ld    (IX+2), L               ; HL to this_free 
1369			      ld    (IX+3), H 
1369			 
1369			 
1369			malloc_update_links: 
1369			      ; Update prev_free ptr to point to this_free 
1369			      ld    L, (IX+4)               ; prev_free ptr to HL 
1369			      ld    H, (IX+5) 
1369			 
1369			      ld    E, (IX+2)               ; this_free ptr to DE 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (HL), E                 ; this_free ptr into prev_free 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Clear the Z flag to indicate successful allocation 
1369			      ld    A, D 
1369			      or    E 
1369			 
1369			      pop   DE                      ; Address of allocation 
1369			 
1369			malloc_no_space: 
1369			      ld    HL, 6                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			      ex    DE, HL                  ; Alloc addr into HL for return 
1369			 
1369			malloc_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     free                                                                    : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1369			;     returned by malloc, otherwise the behaviour is undefined.               : 
1369			;                                                                             : 
1369			;     Where possible, directly adjacent free blocks will be merged together   : 
1369			;     into larger blocks to help ensure that the heap does not become         : 
1369			;     excessively fragmented.                                                 : 
1369			;                                                                             : 
1369			;     free does not clear or set any other value into the freed space, and    : 
1369			;     therefore its contents may be visible through subsequent malloc's. The  : 
1369			;     caller should clear the freed space as required.                        : 
1369			;                                                                             : 
1369			;     This implementation of free uses the stack exclusively, and is          : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling free, and recommended    : 
1369			;     to avoid the use of free inside ISRs in general.                        : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Pointer to address of first byte of allocation to be freed          : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			free: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if ptr is null 
1369			      or    L 
1369			      jp    Z, free_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; The address in HL points to the start of the useable allocated space, 
1369			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1369			      ; address of the block itself. 
1369			      ex    DE, HL 
1369			      ld    DE, -4 
1369			      add   HL, DE 
1369			 
1369			      ; An allocated block must have a null next block pointer in it 
1369			      ld    A, (HL) 
1369			      inc   HL 
1369			      or    (HL) 
1369			      jp    NZ, free_done 
1369			 
1369			      dec   HL 
1369			 
1369			      ld    B, H                    ; Copy HL to BC 
1369			      ld    C, L 
1369			 
1369			      ; Loop through the free list to find the first block with an address 
1369			      ; higher than the block being freed 
1369			      ld    HL, free_list 
1369			 
1369			free_find_higher_block: 
1369			      ld    E, (HL)                 ; Load next ptr from free block 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			 
1369			      ld    (IX+0), E               ; Save ptr to next free block 
1369			      ld    (IX+1), D 
1369			      ld    (IX+2), L               ; Save ptr to prev free block 
1369			      ld    (IX+3), H 
1369			 
1369			      ld    A, B                    ; Check if DE is greater than BC 
1369			      cp    D                       ; Compare MSB first 
1369			      jr    Z, $+4                  ; MSB the same, compare LSB 
1369			      jr    NC, free_find_higher_block_skip 
1369			      ld    A, C 
1369			      cp    E                       ; Then compare LSB 
1369			      jr    C, free_found_higher_block 
1369			 
1369			free_find_higher_block_skip: 
1369			      ld    A, D                    ; Reached the end of the free list? 
1369			      or    E 
1369			      jp    Z, free_done 
1369			 
1369			      ex    DE, HL 
1369			 
1369			      jr    free_find_higher_block 
1369			 
1369			free_found_higher_block: 
1369			      ; Insert freed block between prev and next free blocks 
1369			      ld    (HL), C                 ; Point prev free block to freed block 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			 
1369			      ld    H, B                    ; Point freed block at next free block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Check if the freed block is adjacent to the next free block 
1369			      inc   HL                      ; Load size of freed block into HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      add   HL, BC                  ; Add addr of freed block and its size 
1369			 
1369			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_check_adjacent_to_prev 
1369			 
1369			      ; Freed block is adjacent to next, merge into one bigger block 
1369			      ex    DE, HL                  ; Load next ptr from next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save ptr to next block for later 
1369			 
1369			      ld    H, B                    ; Store ptr from next block into freed block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore ptr to next block 
1369			      inc   HL                      ; Load size of next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save next block size for later 
1369			 
1369			      ld    H, B                    ; Load size of freed block into HL 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      pop   DE                      ; Restore size of next block 
1369			      add   HL, DE                  ; Add sizes of both blocks 
1369			      ex    DE, HL 
1369			 
1369			      ld    H, B                    ; Store new bigger size into freed block 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_check_adjacent_to_prev: 
1369			      ; Check if the freed block is adjacent to the prev free block 
1369			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1369			      ld    H, (IX+3) 
1369			 
1369			      inc   HL                      ; Size of prev free block into DE 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      add   HL, DE                  ; Add prev block addr and size 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_done 
1369			 
1369			      ; Freed block is adjacent to prev, merge into one bigger block 
1369			      ld    H, B                    ; Load next ptr from freed block into DE 
1369			      ld    L, C 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save freed block ptr for later 
1369			 
1369			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1369			      ld    H, (IX+3) 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore freed block ptr 
1369			      inc   HL                      ; Load size of freed block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save freed block size for later 
1369			 
1369			      ld    L, (IX+2)               ; Load size of prev block into DE 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      pop   HL                      ; Add sizes of both blocks 
1369			      add   HL, DE 
1369			      ex    DE, HL 
1369			 
1369			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_done: 
1369			      ld    HL, 4                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			free_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;      .org 0x8000 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			 ;                 .dw   0 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_4 
1369			 
1369			; My memory allocation code. Very very simple.... 
1369			; allocate space under 250 chars 
1369			 
1369			heap_init: 
1369				; init start of heap as zero 
1369				;  
1369			 
1369				ld hl, heap_start 
1369				ld a, 0 
1369				ld (hl), a      ; empty block 
1369				inc hl 
1369				ld a, 0 
1369				ld (hl), a      ; length of block 
1369				; write end of list 
1369				inc hl 
1369				ld a,(hl) 
1369				inc hl 
1369				ld a,(hl) 
1369				 
1369			 
1369				; init some malloc vars 
1369			 
1369				ld hl, 0 
1369				ld (free_list), hl       ; store last malloc location 
1369			 
1369				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1369				ld a, 0 
1369				ld (hl), a 
1369			 
1369			 
1369				ld hl, heap_start 
1369				;  
1369				  
1369				ret 
1369			 
1369			 
1369			;    free block marker 
1369			;    requested size  
1369			;    pointer to next block 
1369			;    .... 
1369			;    next block marker 
1369			 
1369			 
1369			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1369			; 
1369			 
1369			 
1369			malloc:  
1369				push de 
1369				push bc 
1369				push af 
1369			 
1369				; hl space required 
1369				 
1369				ld c, l    ; hold space   (TODO only a max of 255) 
1369			 
1369			;	inc c     ; TODO BUG need to fix memory leak on push str 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			 
1369			 
1369			 
1369				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1369			 
1369				ld a, (free_list+3) 
1369				cp 0 
1369				jr z, .contheap 
1369			 
1369				ld hl, (free_list)     ; get last alloc 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mrs" 
1369						CALLMONITOR 
1369					endif 
1369				jr .startalloc 
1369			 
1369			.contheap: 
1369				ld hl, heap_start 
1369			 
1369			.startalloc: 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mym" 
1369						CALLMONITOR 
1369					endif 
1369			.findblock: 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmf" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369				ld a,(hl)  
1369				; if byte is zero then clear to use 
1369			 
1369				cp 0 
1369				jr z, .foundemptyblock 
1369			 
1369				; if byte is not clear 
1369				;     then byte is offset to next block 
1369			 
1369				inc hl 
1369				ld a, (hl) ; get size 
1369			.nextblock:	inc hl 
1369					ld e, (hl) 
1369					inc hl 
1369					ld d, (hl) 
1369					ex de, hl 
1369			;	inc hl  ; move past the store space 
1369			;	inc hl  ; move past zero index  
1369			 
1369				; TODO detect no more space 
1369			 
1369				push hl 
1369				ld de, heap_end 
1369				call cmp16 
1369				pop hl 
1369				jr nc, .nospace 
1369			 
1369				jr .findblock 
1369			 
1369			.nospace: ld hl, 0 
1369				jp .exit 
1369			 
1369			 
1369			.foundemptyblock:	 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mme" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; TODO has block enough space if reusing??? 
1369			 
1369				;  
1369			 
1369			; see if this block has been previously used 
1369				inc hl 
1369				ld a, (hl) 
1369				dec hl 
1369				cp 0 
1369				jr z, .newblock 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meR" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; no reusing previously allocated block 
1369			 
1369			; is it smaller than previously used? 
1369				 
1369				inc hl    ; move to size 
1369				ld a, c 
1369				sub (hl)        ; we want c < (hl) 
1369				dec hl    ; move back to marker 
1369			        jr z, .findblock 
1369			 
1369				; update with the new size which should be lower 
1369			 
1369			        ;inc  hl   ; negate next move. move back to size  
1369			 
1369			.newblock: 
1369				; need to be at marker here 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meN" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			 
1369				ld a, c 
1369			 
1369				ld (free_list+3), a	 ; flag resume from last malloc  
1369				ld (free_list), hl    ; save out last location 
1369			 
1369			 
1369				;inc a     ; space for length byte 
1369				ld (hl), a     ; save block in use marker 
1369			 
1369				inc hl   ; move to space marker 
1369				ld (hl), a    ; save new space 
1369			 
1369				inc hl   ; move to start of allocated area 
1369				 
1369			;	push hl     ; save where we are - 1  
1369			 
1369			;	inc hl  ; move past zero index  
1369				; skip space to set down new marker 
1369			 
1369				; provide some extra space for now 
1369			 
1369				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1369				inc a 
1369				inc a 
1369			 
1369				push hl   ; save where we are in the node block 
1369			 
1369				call addatohl 
1369			 
1369				; write linked list point 
1369			 
1369				pop de     ; get our node position 
1369				ex de, hl 
1369			 
1369				ld (hl), e 
1369				inc hl 
1369				ld (hl), d 
1369			 
1369				inc hl 
1369			 
1369				; now at start of allocated data so save pointer 
1369			 
1369				push hl 
1369			 
1369				; jump to position of next node and setup empty header in DE 
1369			 
1369				ex de, hl 
1369			 
1369			;	inc hl ; move past end of block 
1369			 
1369				ld a, 0 
1369				ld (hl), a   ; empty marker 
1369				inc hl 
1369				ld (hl), a   ; size 
1369				inc hl  
1369				ld (hl), a   ; ptr 
1369				inc hl 
1369				ld (hl), a   ; ptr 
1369			 
1369			 
1369				pop hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmr" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			.exit: 
1369				pop af 
1369				pop bc 
1369				pop de  
1369				ret 
1369			 
1369			 
1369			 
1369			 
1369			free:  
1369				push hl 
1369				push af 
1369				; get address in hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "fre" 
1369						CALLMONITOR 
1369					endif 
1369				; data is at hl - move to block count 
1369				dec hl 
1369				dec hl    ; get past pointer 
1369				dec hl 
1369			 
1369				ld a, (hl)    ; need this for a validation check 
1369			 
1369				dec hl    ; move to block marker 
1369			 
1369				; now check that the block count and block marker are the same  
1369			        ; this checks that we are on a malloc node and not random memory 
1369			        ; OK a faint chance this could be a problem but rare - famous last words! 
1369			 
1369				ld c, a 
1369				ld a, (hl)    
1369			 
1369				cp c 
1369				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1369			 
1369				; yes good chance we are on a malloc node 
1369			 
1369				ld a, 0      
1369				ld (hl), a   ; mark as free 
1369			 
1369				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1369			 
1369			.freeignore:  
1369			 
1369				pop af 
1369				pop hl 
1369			 
1369				ret 
1369			 
1369			 
1369			 
1369			endif 
1369			 
1369			; eof 
# End of file firmware_memory.asm
1369			  
1369			; device C  
1369			; Now handled by SPI  
1369			;if SOUND_ENABLE  
1369			;	include "firmware_sound.asm"  
1369			;endif  
1369			  
1369			include "firmware_diags.asm"  
1369			; Hardware diags menu 
1369			 
1369			 
1369			config: 
1369			 
1369 3e 00			ld a, 0 
136b 21 8f 13			ld hl, .configmn 
136e cd f9 0b			call menu 
1371			 
1371 fe 00			cp 0 
1373 c8				ret z 
1374			 
1374			;	cp 1 
1374			;	call z, .savetostore 
1374			 
1374 fe 01			cp 1 
1376			if STARTUP_V1 
1376 cc a5 13			call z, .selautoload 
1379			endif 
1379			 
1379			if STARTUP_V2 
1379				call z, .enautoload 
1379			endif 
1379 fe 02			cp 2 
137b cc 9b 13			call z, .disautoload 
137e			;	cp 3 
137e			;	call z, .selbank 
137e fe 03			cp 3 
1380 cc c3 13			call z, .debug_tog 
1383 fe 04			cp 4 
1385 cc 11 15			call z, .bpsgo 
1388 fe 05			cp 5 
138a cc ec 13			call z, hardware_diags 
138d			if STARTUP_V2 
138d				cp 6 
138d				call z, create_startup 
138d			endif 
138d 18 da			jr config 
138f			 
138f			.configmn: 
138f			;	dw prom_c3 
138f ff 16			dw prom_c2 
1391 14 17			dw prom_c2a 
1393			;	dw prom_c2b 
1393			;	dw prom_c4 
1393 33 17			dw prom_m4 
1395 4e 17			dw prom_m4b 
1397 56 17			dw prom_c1 
1399			if STARTUP_V2 
1399				dw prom_c9 
1399			endif 
1399 00 00			dw 0 
139b				 
139b			 
139b			if STARTUP_V2 
139b			.enautoload: 
139b				if STORAGE_SE 
139b				ld a, $fe      ; bit 0 clear 
139b				ld (spi_device), a 
139b			 
139b				call storage_get_block_0 
139b			 
139b				ld a, 1 
139b				ld (store_page+STORE_0_AUTOFILE), a 
139b			 
139b					ld hl, 0 
139b					ld de, store_page 
139b				call storage_write_block	 ; save update 
139b				else 
139b			 
139b				ld hl, prom_notav 
139b				ld de, prom_empty 
139b				call info_panel 
139b				endif 
139b			 
139b			 
139b				ret 
139b			endif 
139b			 
139b			.disautoload: 
139b				if STORAGE_SE 
139b				ld a, $fe      ; bit 0 clear 
139b				ld (spi_device), a 
139b			 
139b				call storage_get_block_0 
139b			 
139b				ld a, 0 
139b				ld (store_page+STORE_0_AUTOFILE), a 
139b			 
139b					ld hl, 0 
139b					ld de, store_page 
139b				call storage_write_block	 ; save update 
139b				else 
139b			 
139b 21 65 17			ld hl, prom_notav 
139e 11 7b 17			ld de, prom_empty 
13a1 cd 59 0b			call info_panel 
13a4				endif 
13a4			 
13a4			 
13a4 c9				ret 
13a5			 
13a5			if STARTUP_V1 
13a5			 
13a5			; Select auto start 
13a5			 
13a5			.selautoload: 
13a5			 
13a5				 
13a5				if STORAGE_SE 
13a5			 
13a5					call config_dir 
13a5				        ld hl, scratch 
13a5					ld a, 0 
13a5					call menu 
13a5			 
13a5					cp 0 
13a5					ret z 
13a5			 
13a5					dec a 
13a5			 
13a5			 
13a5					; locate menu option 
13a5			 
13a5					ld hl, scratch 
13a5					call table_lookup 
13a5			 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "ALl" 
13a5						CALLMONITOR 
13a5					endif 
13a5					; with the pointer to the menu it, the byte following the zero term is the file id 
13a5			 
13a5					ld a, 0 
13a5					ld bc, 50   ; max of bytes to look at 
13a5					cpir  
13a5			 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "ALb" 
13a5						CALLMONITOR 
13a5					endif 
13a5					;inc hl 
13a5			 
13a5					ld a, (hl)   ; file id 
13a5					 
13a5				        ; save bank and file ids 
13a5			 
13a5					push af 
13a5			 
13a5			; TODO need to save to block 0 on bank 1	 
13a5			 
13a5					call storage_get_block_0 
13a5			 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "AL0" 
13a5						CALLMONITOR 
13a5					endif 
13a5					pop af 
13a5			 
13a5					ld (store_page+STORE_0_FILERUN),a 
13a5					 
13a5					; save bank id 
13a5			 
13a5					ld a,(spi_device) 
13a5					ld (store_page+STORE_0_BANKRUN),a 
13a5			 
13a5					; enable auto run of store file 
13a5			 
13a5					ld a, 1 
13a5					ld (store_page+STORE_0_AUTOFILE),a 
13a5			 
13a5					; save buffer 
13a5			 
13a5					ld hl, 0 
13a5					ld de, store_page 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "ALw" 
13a5						CALLMONITOR 
13a5					endif 
13a5				call storage_write_block	 ; save update 
13a5			  
13a5			 
13a5			 
13a5			 
13a5					ld hl, scratch 
13a5					call config_fdir 
13a5			 
13a5				else 
13a5			 
13a5 21 65 17			ld hl, prom_notav 
13a8 11 7b 17			ld de, prom_empty 
13ab cd 59 0b			call info_panel 
13ae			 
13ae				endif 
13ae c9				ret 
13af			endif 
13af			 
13af			 
13af			; Select storage bank 
13af			 
13af			.selbank: 
13af			 
13af			;	if STORAGE_SE 
13af			;	else 
13af			 
13af 21 65 17			ld hl, prom_notav 
13b2 11 7b 17			ld de, prom_empty 
13b5 cd 59 0b			call info_panel 
13b8			;	endif 
13b8				 
13b8 c9				ret 
13b9			 
13b9			if STORAGE_SE 
13b9			 
13b9			.config_ldir:   
13b9				; Load storage bank labels into menu array 
13b9			 
13b9				 
13b9			 
13b9			 
13b9				ret 
13b9			 
13b9			 
13b9			endif 
13b9			 
13b9			 
13b9			; Save user words to storage 
13b9			 
13b9			.savetostore: 
13b9			 
13b9			;	if STORAGE_SE 
13b9			; 
13b9			;		call config_dir 
13b9			;	        ld hl, scratch 
13b9			;		ld a, 0 
13b9			;		call menu 
13b9			;		 
13b9			;		ld hl, scratch 
13b9			;		call config_fdir 
13b9			; 
13b9			;	else 
13b9			 
13b9 21 65 17			ld hl, prom_notav 
13bc 11 7b 17			ld de, prom_empty 
13bf cd 59 0b			call info_panel 
13c2			 
13c2			;	endif 
13c2			 
13c2 c9				ret 
13c3			 
13c3			if STARTUP_V2 
13c3			 
13c3			create_startup: 
13c3			 
13c3				ld a, 0 
13c3				ld hl, .crstart 
13c3				call menu 
13c3			 
13c3				cp 0 
13c3				ret z 
13c3			 
13c3				cp 1 
13c3				call z, .genlsword 
13c3				cp 2 
13c3				call z, .genedword 
13c3			 
13c3				cp 3 
13c3				call z, .gendemword 
13c3			 
13c3				cp 4 
13c3				call z, .genutlword 
13c3				cp 5 
13c3				call z, .genspiword 
13c3				cp 6 
13c3				call z, .genkeyword 
13c3				cp 7 
13c3				call z, .gensoundword 
13c3				cp 7 
13c3				call z, .genhwword 
13c3				jr create_startup 
13c3			 
13c3			.genhwword: 
13c3				ld hl, crs_hw 
13c3				ld de, .hwworddef 
13c3				call .genfile 
13c3				ret 
13c3			.gensoundword: 
13c3				ld hl, crs_sound 
13c3				ld de, .soundworddef 
13c3				call .genfile 
13c3				ret 
13c3			.genlsword: 
13c3				ld hl, crs_s1 
13c3				ld de, .lsworddef 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			.genedword: 
13c3				ld de, .edworddef 
13c3				ld hl, crs_s2 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			.gendemword: 
13c3				ld de, .demoworddef 
13c3				ld hl, crs_s3 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			.genutlword: 
13c3				ld hl, crs_s4 
13c3				ld de, .utilwordef 
13c3				call .genfile 
13c3				ret 
13c3			.genspiword: 
13c3				ld hl, crs_s5 
13c3				ld de, .spiworddef 
13c3				call .genfile 
13c3				ret 
13c3			.genkeyword: 
13c3				ld hl, crs_s6 
13c3				ld de, .keyworddef 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			; hl - points to file name 
13c3			; de - points to strings to add to file 
13c3			 
13c3			.genfile: 
13c3				push hl 
13c3				push de 
13c3			 
13c3				call clear_display 
13c3				ld a, display_row_1 
13c3				ld de, .genfiletxt 
13c3				call str_at_display 
13c3				call update_display 
13c3			 
13c3				pop de 
13c3				pop hl 
13c3			 
13c3			 
13c3				push de 
13c3				call storage_create 
13c3				; id in hl 
13c3				pop de   ; table of strings to add 
13c3			 
13c3			.genloop: 
13c3			 
13c3				push hl ; save id for next time around 
13c3				push de ; save de for next time around 
13c3			 
13c3				ex de, hl 
13c3				call loadwordinhl 
13c3				ex de, hl 
13c3			 
13c3				; need hl to be the id 
13c3				; need de to be the string ptr 
13c3				 
13c3				call storage_append 
13c3			 
13c3				pop de 
13c3				pop hl 
13c3			 
13c3				inc de 
13c3				inc de 
13c3			 
13c3				ld a,(de) 
13c3				cp 0 
13c3				jr nz, .genloop 
13c3				inc de 
13c3				ld a, (de) 
13c3				dec de 
13c3				cp 0 
13c3				jr nz, .genloop	 
13c3			 
13c3				ret 
13c3			 
13c3			.genfiletxt:  db "Creating file...",0 
13c3			 
13c3			.hwworddef: 
13c3				dw test5 
13c3				dw test6 
13c3				dw test7 
13c3				dw test8 
13c3				dw test9 
13c3				dw test10 
13c3				dw 0 
13c3			 
13c3			.soundworddef: 
13c3				dw sound1 
13c3				dw sound2 
13c3				dw sound3 
13c3				dw sound4 
13c3				dw sound5 
13c3				dw sound6 
13c3				dw sound7 
13c3				dw sound8 
13c3				dw sound9 
13c3				dw 0 
13c3			 
13c3			.utilwordef: 
13c3				dw strncpy 
13c3				dw type 
13c3				dw clrstack 
13c3				dw longread 
13c3				dw start1 
13c3				dw start2 
13c3			; duplicated 
13c3			;	dw start3b 
13c3			;	dw start3c 
13c3				dw list 
13c3				dw 0 
13c3			 
13c3			.lsworddef: 
13c3				dw start3b 
13c3				dw 0 
13c3			 
13c3			.edworddef: 
13c3				dw edit1 
13c3				dw edit2 
13c3				dw edit3 
13c3				dw 0 
13c3			 
13c3			.demoworddef: 
13c3				dw game1 
13c3				dw game1a 
13c3				dw game1b 
13c3				dw game1c 
13c3				dw game1d 
13c3				dw game1s 
13c3				dw game1t 
13c3				dw game1f 
13c3				dw game1z 
13c3				dw game1zz 
13c3				dw ssv2 
13c3				dw ssv3 
13c3				dw ssv4 
13c3				dw ssv5 
13c3				dw ssv1 
13c3				dw ssv1cpm	 
13c3			;	dw game2b 
13c3			;	dw game2bf 
13c3			;	dw game2mba 
13c3			;	dw game2mbas	 
13c3			;	dw game2mbht 
13c3			;	dw game2mbms 
13c3			;	dw game2mb 
13c3			;	dw game3w 
13c3			;	dw game3p 
13c3			;	dw game3sc 
13c3			;	dw game3vsi 
13c3			;	dw game3vs 
13c3				dw 0 
13c3			 
13c3			 
13c3			.spiworddef: 
13c3			 
13c3			    dw spi1 
13c3			    dw spi2 
13c3			    dw spi2b 
13c3			    dw spi3 
13c3			    dw spi4 
13c3			    dw spi5 
13c3			;    dw spi6 
13c3			;    dw spi7 
13c3			 
13c3			;    dw spi8 
13c3			;    dw spi9 
13c3			;    dw spi10 
13c3			    dw 0 
13c3			 
13c3			.keyworddef: 
13c3			 
13c3				dw keyup 
13c3				dw keydown 
13c3				dw keyleft 
13c3				dw keyright 
13c3				dw 	keyf1 
13c3				dw keyf2 
13c3				dw keyf3 
13c3				dw keyf4 
13c3				dw keyf5 
13c3				dw keyf6 
13c3				dw keyf7 
13c3				dw keyf8 
13c3				dw keyf9 
13c3				dw keyf10 
13c3				dw keyf11 
13c3				dw keyf12 
13c3				dw keytab 
13c3				dw keycr 
13c3				dw keyhome 
13c3				dw keyend 
13c3				dw keybs 
13c3				dw 0 
13c3			 
13c3			.crstart: 
13c3				dw crs_s1 
13c3				dw crs_s2 
13c3				dw crs_s3 
13c3				dw crs_s4 
13c3				dw crs_s5 
13c3				dw crs_s6 
13c3				dw crs_sound 
13c3				dw crs_hw 
13c3				dw 0 
13c3			 
13c3			endif 
13c3			 
13c3			 
13c3			if STORAGE_SE 
13c3			 
13c3			config_fdir: 
13c3				; using the scratch dir go through and release the memory allocated for each string 
13c3				 
13c3				ld hl, scratch 
13c3			.cfdir:	ld e,(hl) 
13c3				inc hl 
13c3				ld d,(hl) 
13c3				inc hl 
13c3			 
13c3				ex de, hl 
13c3				call ishlzero 
13c3				ret z     ; return on null pointer 
13c3				call free 
13c3				ex de, hl 
13c3				jr .cfdir 
13c3			 
13c3			 
13c3				ret 
13c3			 
13c3			 
13c3			config_dir: 
13c3			 
13c3				; for the config menus that need to build a directory of storage call this routine 
13c3				; it will construct a menu in scratch to pass to menu 
13c3			 
13c3				; open storage device 
13c3			 
13c3				; execute DIR to build a list of files and their ids into scratch in menu format 
13c3				; once the menu has finished then will need to call config_fdir to release the strings 
13c3				 
13c3				; c = number items 
13c3			 
13c3				 
13c3				call storage_get_block_0 
13c3			 
13c3				ld hl, store_page     ; get current id count 
13c3				ld b, (hl) 
13c3				ld c, 0    ; count of files   
13c3			 
13c3			 
13c3				ld hl, scratch 
13c3				ld (store_tmp2), hl    ; location to poke strings 
13c3			 
13c3				; check for empty drive 
13c3			 
13c3				ld a, 0 
13c3				cp b 
13c3				jp z, .dirdone 
13c3			 
13c3				 
13c3					if DEBUG_FORTH_WORDS 
13c3						DMARK "Cdc" 
13c3						CALLMONITOR 
13c3					endif 
13c3			 
13c3			 
13c3			.diritem:	 
13c3				push bc 
13c3				; for each of the current ids do a search for them and if found push to stack 
13c3			 
13c3					ld hl, STORE_BLOCK_PHY 
13c3					ld d, 0		 ; look for extent 0 of block id as this contains file name 
13c3					ld e,b 
13c3			 
13c3					call storage_findnextid 
13c3			 
13c3			 
13c3					; if found hl will be non zero 
13c3			 
13c3					call ishlzero 
13c3					jr z, .dirnotfound 
13c3			 
13c3					; increase count 
13c3			 
13c3					pop bc	 
13c3					inc c 
13c3					push bc 
13c3					 
13c3			 
13c3					; get file header and push the file name 
13c3			 
13c3					ld de, store_page 
13c3					call storage_read_block 
13c3			 
13c3					; push file id to stack 
13c3				 
13c3					ld a, (store_page) 
13c3					ld h, 0 
13c3					ld l, a 
13c3			 
13c3					;call forth_push_numhl 
13c3					; TODO store id 
13c3			 
13c3					push hl 
13c3			 
13c3					; push extent count to stack  
13c3				 
13c3					ld hl, store_page+3 
13c3			 
13c3					; get file name length 
13c3			 
13c3					call strlenz   
13c3			 
13c3					inc hl   ; cover zero term 
13c3					inc hl  ; stick the id at the end of the area 
13c3			 
13c3					push hl 
13c3					pop bc    ; move length to bc 
13c3			 
13c3					call malloc 
13c3			 
13c3					; TODO save malloc area to scratch 
13c3			 
13c3					ex de, hl 
13c3					ld hl, (store_tmp2) 
13c3					ld (hl), e 
13c3					inc hl 
13c3					ld (hl), d 
13c3					inc hl 
13c3					ld (store_tmp2), hl 
13c3			 
13c3					 
13c3			 
13c3					;pop hl   ; get source 
13c3			;		ex de, hl    ; swap aronund	 
13c3			 
13c3					ld hl, store_page+3 
13c3					if DEBUG_FORTH_WORDS 
13c3						DMARK "CFd" 
13c3						CALLMONITOR 
13c3					endif 
13c3					ldir 
13c3			 
13c3					; de is past string, move back one and store id 
13c3					 
13c3					dec de 
13c3			 
13c3					; store file id 
13c3			 
13c3					pop hl 
13c3					ex de,hl 
13c3					ld (hl), e 
13c3			 
13c3					if DEBUG_FORTH_WORDS 
13c3						DMARK "Cdi" 
13c3						CALLMONITOR 
13c3					endif 
13c3					 
13c3			.dirnotfound: 
13c3					pop bc     
13c3					djnz .diritem 
13c3				 
13c3			.dirdone:	 
13c3			 
13c3					ld a, 0 
13c3					ld hl, (store_tmp2) 
13c3					ld (hl), a 
13c3					inc hl 
13c3					ld (hl), a 
13c3					inc hl 
13c3					; push a count of the dir items found 
13c3			 
13c3			;		ld h, 0 
13c3			;		ld l, c 
13c3			 
13c3				ret 
13c3			 
13c3			endif 
13c3			 
13c3			 
13c3			; Settings 
13c3			; Run  
13c3			 
13c3			 
13c3			 
13c3			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
13c3			;;hd_menu2:   db "        2: Editor",0   
13c3			;hd_menu2:   db "        2: Editor       6: Menu",0   
13c3			;hd_menu3:   db "        3: Storage",0 
13c3			;hd_menu4:   db "0=quit  4: Debug",0 
13c3			;hd_don:     db "ON",0 
13c3			;hd_doff:     db "OFF",0 
13c3			; 
13c3			; 
13c3			; 
13c3			;hardware_diags_old:       
13c3			; 
13c3			;.diagmenu: 
13c3			;	call clear_display 
13c3			;	ld a, display_row_1 
13c3			;	ld de, hd_menu1 
13c3			;	call str_at_display 
13c3			; 
13c3			;	ld a, display_row_2 
13c3			;	ld de, hd_menu2 
13c3			;	call str_at_display 
13c3			; 
13c3			;	ld a, display_row_3 
13c3			;	ld de, hd_menu3 
13c3			;	call str_at_display 
13c3			; 
13c3			;	ld a,  display_row_4 
13c3			;	ld de, hd_menu4 
13c3			;	call str_at_display 
13c3			; 
13c3			;	; display debug state 
13c3			; 
13c3			;	ld de, hd_don 
13c3			;	ld a, (os_view_disable) 
13c3			;	cp 0 
13c3			;	jr z, .distog 
13c3			;	ld de, hd_doff 
13c3			;.distog: ld a, display_row_4+17 
13c3			;	call str_at_display 
13c3			; 
13c3			;	call update_display 
13c3			; 
13c3			;	call cin_wait 
13c3			; 
13c3			; 
13c3			; 
13c3			;	cp '4' 
13c3			;	jr nz, .diagn1 
13c3			; 
13c3			;	; debug toggle 
13c3			; 
13c3			;	ld a, (os_view_disable) 
13c3			;	ld b, '*' 
13c3			;	cp 0 
13c3			;	jr z, .debtog 
13c3			;	ld b, 0 
13c3			;.debtog:	 
13c3			;	ld a,b 
13c3			;	ld (os_view_disable),a 
13c3			; 
13c3			;.diagn1: cp '0' 
13c3			;	 ret z 
13c3			; 
13c3			;;	cp '1' 
13c3			;;       jp z, matrix	 
13c3			;;   TODO keyboard matrix test 
13c3			; 
13c3			;	cp '2' 
13c3			;	jp z, .diagedit 
13c3			; 
13c3			;;	cp '6' 
13c3			;;	jp z, .menutest 
13c3			;;if ENABLE_BASIC 
13c3			;;	cp '6' 
13c3			;;	jp z, basic 
13c3			;;endif 
13c3			 ; 
13c3			;	jp .diagmenu 
13c3			; 
13c3			; 
13c3			;	ret 
13c3			 
13c3			 
13c3			.debug_tog: 
13c3 21 0d 14			ld hl, .menudebug 
13c6				 
13c6			;	ld a, (os_view_disable) 
13c6			;	cp '*' 
13c6 3a 6f ee			ld a,(debug_vector) 
13c9 fe c9			cp $C9   ; RET 
13cb 20 04			jr nz,.tdon  
13cd 3e 01			ld a, 1 
13cf 18 02			jr .tog1 
13d1 3e 00		.tdon: ld a, 0 
13d3			 
13d3			.tog1: 
13d3 cd f9 0b			call menu 
13d6 fe 00			cp 0 
13d8 c8				ret z 
13d9 fe 01			cp 1    ; disable debug 
13db 28 04			jr z, .dtog0 
13dd 3e 2a			ld a, '*' 
13df 18 05			jr .dtogset 
13e1			.dtog0:  
13e1				;ld a, 0 
13e1 cd ff 14			call bp_on 
13e4 18 dd			jr .debug_tog 
13e6			.dtogset:  
13e6				; ld (os_view_disable), a 
13e6 cd 0b 15			call bp_off 
13e9 c3 c3 13			jp .debug_tog 
13ec			 
13ec			 
13ec			hardware_diags:       
13ec			 
13ec			.diagm: 
13ec 21 ff 13			ld hl, .menuitems 
13ef 3e 00			ld a, 0 
13f1 cd f9 0b			call menu 
13f4			 
13f4 fe 00		         cp 0 
13f6 c8				 ret z 
13f7			 
13f7 fe 02			cp 2 
13f9 ca 58 14			jp z, .diagedit 
13fc			 
13fc			;	cp '6' 
13fc			;	jp z, .menutest 
13fc			;if ENABLE_BASIC 
13fc			;	cp '6' 
13fc			;	jp z, basic 
13fc			;endif 
13fc			  
13fc c3 ec 13			jp .diagm 
13ff			 
13ff				 
13ff 13 14		.menuitems:   	dw .m1 
1401 1e 14				dw .m2 
1403 25 14				dw .m3 
1405 2d 14				dw .m5 
1407 33 14				dw .m5a 
1409 3c 14				dw .m5b 
140b 00 00				dw 0 
140d			 
140d			.menudebug: 
140d 45 14				dw .m6 
140f 4e 14				dw .m7 
1411 00 00				dw 0 
1413			 
1413 .. 00		.m1:   db "Key Matrix",0 
141e .. 00		.m2:   db "Editor",0 
1425 .. 00		.m3:   db "Storage",0 
142d .. 00		.m5:   db "Sound",0 
1433 .. 00		.m5a:  db "RAM Test",0 
143c .. 00		.m5b:  db "LCD Test",0 
1445			 
1445 .. 00		.m6:   db "Debug ON",0 
144e .. 00		.m7:   db "Debug OFF",0 
1458			 
1458			; debug editor 
1458			 
1458			.diagedit: 
1458			 
1458 21 bb e2			ld hl, scratch 
145b			;	ld bc, 250 
145b			;	ldir 
145b				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
145b 3e 00			ld a, 0 
145d 77				ld (hl), a 
145e 23				inc hl 
145f 77				ld (hl), a 
1460 23				inc hl 
1461 77				ld (hl), a 
1462			 
1462 cd c8 0b		        call clear_display 
1465 cd eb 0b			call update_display 
1468				;ld a, 1 
1468				;ld (hardware_diag), a 
1468			.diloop: 
1468 3e 00			ld a, display_row_1 
146a 0e 00			ld c, 0 
146c 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
146e 1e 28			ld e, 40 
1470			 
1470 21 bb e2			ld hl, scratch	 
1473 cd 22 0e			call input_str 
1476			 
1476 3e 28			ld a, display_row_2 
1478 11 bb e2			ld de, scratch 
147b cd db 0b			call str_at_display 
147e cd eb 0b			call update_display 
1481			 
1481 c3 68 14			jp .diloop 
1484			 
1484			 
1484			; pass word in hl 
1484			; a has display location 
1484			display_word_at: 
1484 f5				push af 
1485 e5				push hl 
1486 7c				ld a,h 
1487 21 c0 e5			ld hl, os_word_scratch 
148a cd fe 0f			call hexout 
148d e1				pop hl 
148e 7d				ld a,l 
148f 21 c2 e5			ld hl, os_word_scratch+2 
1492 cd fe 0f			call hexout 
1495 21 c4 e5			ld hl, os_word_scratch+4 
1498 3e 00			ld a,0 
149a 77				ld (hl),a 
149b 11 c0 e5			ld de,os_word_scratch 
149e f1				pop af 
149f cd db 0b				call str_at_display 
14a2 c9				ret 
14a3			 
14a3			display_ptr_state: 
14a3			 
14a3				; to restore afterwards 
14a3			 
14a3 d5				push de 
14a4 c5				push bc 
14a5 e5				push hl 
14a6 f5				push af 
14a7			 
14a7				; for use in here 
14a7			 
14a7			;	push bc 
14a7			;	push de 
14a7			;	push hl 
14a7			;	push af 
14a7			 
14a7 cd c8 0b			call clear_display 
14aa			 
14aa 11 82 16			ld de, .ptrstate 
14ad 3e 00			ld a, display_row_1 
14af cd db 0b			call str_at_display 
14b2			 
14b2				; display debug step 
14b2			 
14b2			 
14b2 11 65 ee			ld de, debug_mark 
14b5 3e 26			ld a, display_row_1+display_cols-2 
14b7 cd db 0b			call str_at_display 
14ba			 
14ba				; display a 
14ba 11 8c 16			ld de, .ptrcliptr 
14bd 3e 28			ld a, display_row_2 
14bf cd db 0b			call str_at_display 
14c2			 
14c2 f1				pop af 
14c3 2a 3a ea			ld hl,(cli_ptr) 
14c6 3e 30			ld a, display_row_2+8 
14c8 cd 84 14			call display_word_at 
14cb			 
14cb			 
14cb				; display hl 
14cb			 
14cb			 
14cb 11 94 16			ld de, .ptrclioptr 
14ce 3e 32			ld a, display_row_2+10 
14d0 cd db 0b			call str_at_display 
14d3			; 
14d3			;	pop hl 
14d3 3e 35			ld a, display_row_2+13 
14d5 2a 38 ea			ld hl,(cli_origptr) 
14d8 cd 84 14			call display_word_at 
14db			; 
14db			;	 
14db			;	; display de 
14db			 
14db			;	ld de, .regstatede 
14db			;	ld a, display_row_3 
14db			;	call str_at_display 
14db			 
14db			;	pop de 
14db			;	ld h,d 
14db			;	ld l, e 
14db			;	ld a, display_row_3+3 
14db			;	call display_word_at 
14db			 
14db			 
14db				; display bc 
14db			 
14db			;	ld de, .regstatebc 
14db			;	ld a, display_row_3+10 
14db			;	call str_at_display 
14db			 
14db			;	pop bc 
14db			;	ld h,b 
14db			;	ld l, c 
14db			;	ld a, display_row_3+13 
14db			;	call display_word_at 
14db			 
14db			 
14db				; display dsp 
14db			 
14db			;	ld de, .regstatedsp 
14db			;	ld a, display_row_4 
14db			;	call str_at_display 
14db			 
14db				 
14db			;	ld hl,(cli_data_sp) 
14db			;	ld a, display_row_4+4 
14db			;	call display_word_at 
14db			 
14db				; display rsp 
14db			 
14db 11 c3 16			ld de, .regstatersp 
14de 3e 82			ld a, display_row_4+10 
14e0 cd db 0b			call str_at_display 
14e3			 
14e3				 
14e3 2a ec e9			ld hl,(cli_ret_sp) 
14e6 3e 86			ld a, display_row_4+14 
14e8 cd 84 14			call display_word_at 
14eb			 
14eb cd eb 0b			call update_display 
14ee			 
14ee cd 00 0b			call delay1s 
14f1 cd 00 0b			call delay1s 
14f4 cd 00 0b			call delay1s 
14f7			 
14f7			 
14f7 cd 08 1b			call next_page_prompt 
14fa			 
14fa				; restore  
14fa			 
14fa f1				pop af 
14fb e1				pop hl 
14fc c1				pop bc 
14fd d1				pop de 
14fe c9				ret 
14ff			 
14ff			; Update the break point vector so that the user can hook a new routine 
14ff			 
14ff			bp_on: 
14ff 3e c3			ld a, $c3    ; JP 
1501 32 6f ee			ld (debug_vector), a 
1504 21 11 15			ld hl, break_point_state 
1507 22 70 ee			ld (debug_vector+1), hl 
150a c9				ret 
150b			 
150b			bp_off: 
150b 3e c9			ld a, $c9    ; RET 
150d 32 6f ee			ld (debug_vector), a 
1510 c9				ret 
1511			 
1511			 
1511			break_point_state: 
1511			;	push af 
1511			; 
1511			;	; see if disabled 
1511			; 
1511			;	ld a, (os_view_disable) 
1511			;	cp '*' 
1511			;	jr nz, .bpsgo 
1511			;	pop af 
1511			;	ret 
1511			 
1511			.bpsgo: 
1511			;	pop af 
1511 f5				push af 
1512 22 9d e2			ld (os_view_hl), hl 
1515 ed 53 9b e2		ld (os_view_de), de 
1519 ed 43 99 e2		ld (os_view_bc), bc 
151d e5				push hl 
151e 6f				ld l, a 
151f 26 00			ld h, 0 
1521 22 9f e2			ld (os_view_af),hl 
1524			 
1524 21 ab ed				ld hl, display_fb0 
1527 22 c6 eb				ld (display_fb_active), hl 
152a e1				pop hl	 
152b			 
152b 3e 31			ld a, '1' 
152d fe 2a		.bps1:  cp '*' 
152f cc 0b 15			call z, bp_off 
1532			;	jr nz, .bps1b 
1532			;	ld (os_view_disable),a 
1532 fe 31		.bps1b:  cp '1' 
1534 20 14			jr nz, .bps2 
1536			 
1536				; display reg 
1536			 
1536				 
1536			 
1536 3a 9f e2			ld a, (os_view_af) 
1539 2a 9d e2			ld hl, (os_view_hl) 
153c ed 5b 9b e2		ld de, (os_view_de) 
1540 ed 4b 99 e2		ld bc, (os_view_bc) 
1544 cd de 15			call display_reg_state 
1547 c3 ca 15			jp .bpschk 
154a			 
154a fe 32		.bps2:  cp '2' 
154c 20 08			jr nz, .bps3 
154e				 
154e				; display hl 
154e 2a 9d e2			ld hl, (os_view_hl) 
1551 cd c8 16			call display_dump_at_hl 
1554			 
1554 18 74			jr .bpschk 
1556			 
1556 fe 33		.bps3:  cp '3' 
1558 20 08			jr nz, .bps4 
155a			 
155a			        ; display de 
155a 2a 9b e2			ld hl, (os_view_de) 
155d cd c8 16			call display_dump_at_hl 
1560			 
1560 18 68			jr .bpschk 
1562 fe 34		.bps4:  cp '4' 
1564 20 08			jr nz, .bps5 
1566			 
1566			        ; display bc 
1566 2a 99 e2			ld hl, (os_view_bc) 
1569 cd c8 16			call display_dump_at_hl 
156c			 
156c 18 5c			jr .bpschk 
156e fe 35		.bps5:  cp '5' 
1570 20 08		        jr nz, .bps7 
1572			 
1572				; display cur ptr 
1572 2a 3a ea			ld hl, (cli_ptr) 
1575 cd c8 16			call display_dump_at_hl 
1578			 
1578 18 50			jr .bpschk 
157a fe 36		.bps7:  cp '6' 
157c 20 08			jr nz, .bps8b 
157e				 
157e				; display cur orig ptr 
157e 2a 38 ea			ld hl, (cli_origptr) 
1581 cd c8 16			call display_dump_at_hl 
1584 18 44			jr .bpschk 
1586 fe 37		.bps8b:  cp '7' 
1588 20 08			jr nz, .bps9 
158a				 
158a				; display dsp 
158a 2a e8 e9			ld hl, (cli_data_sp) 
158d cd c8 16			call display_dump_at_hl 
1590			 
1590 18 38			jr .bpschk 
1592 fe 39		.bps9:  cp '9' 
1594 20 05			jr nz, .bps8c 
1596				 
1596				; display SP 
1596			;	ld hl, sp 
1596 cd c8 16			call display_dump_at_hl 
1599			 
1599 18 2f			jr .bpschk 
159b fe 38		.bps8c:  cp '8' 
159d 20 08			jr nz, .bps8d 
159f				 
159f				; display rsp 
159f 2a ec e9			ld hl, (cli_ret_sp) 
15a2 cd c8 16			call display_dump_at_hl 
15a5			 
15a5 18 23			jr .bpschk 
15a7 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
15a9 20 05			jr nz, .bps8 
15ab cd c2 18			call monitor 
15ae			 
15ae 18 1a			jr .bpschk 
15b0 fe 30		.bps8:  cp '0' 
15b2 20 16			jr nz, .bpschk 
15b4			 
15b4 21 0a ed				ld hl, display_fb1 
15b7 22 c6 eb				ld (display_fb_active), hl 
15ba cd eb 0b				call update_display 
15bd			 
15bd				;ld a, (os_view_af) 
15bd 2a 9d e2			ld hl, (os_view_hl) 
15c0 ed 5b 9b e2		ld de, (os_view_de) 
15c4 ed 4b 99 e2		ld bc, (os_view_bc) 
15c8 f1				pop af 
15c9 c9				ret 
15ca			 
15ca			.bpschk:   
15ca cd 00 0b			call delay1s 
15cd 3e 9f		ld a,display_row_4 + display_cols - 1 
15cf 11 06 1b		        ld de, endprg 
15d2 cd db 0b			call str_at_display 
15d5 cd eb 0b			call update_display 
15d8 cd 2f 5f			call cin_wait 
15db			 
15db c3 2d 15			jp .bps1 
15de			 
15de			 
15de			display_reg_state: 
15de			 
15de				; to restore afterwards 
15de			 
15de d5				push de 
15df c5				push bc 
15e0 e5				push hl 
15e1 f5				push af 
15e2			 
15e2				; for use in here 
15e2			 
15e2 c5				push bc 
15e3 d5				push de 
15e4 e5				push hl 
15e5 f5				push af 
15e6			 
15e6 cd c8 0b			call clear_display 
15e9			 
15e9 11 9e 16			ld de, .regstate 
15ec 3e 00			ld a, display_row_1 
15ee cd db 0b			call str_at_display 
15f1			 
15f1				; display debug step 
15f1			 
15f1			 
15f1 11 65 ee			ld de, debug_mark 
15f4 3e 25			ld a, display_row_1+display_cols-3 
15f6 cd db 0b			call str_at_display 
15f9			 
15f9				; display a 
15f9 11 ba 16			ld de, .regstatea 
15fc 3e 28			ld a, display_row_2 
15fe cd db 0b			call str_at_display 
1601			 
1601 e1				pop hl 
1602			;	ld h,0 
1602			;	ld l, a 
1602 3e 2b			ld a, display_row_2+3 
1604 cd 84 14			call display_word_at 
1607			 
1607			 
1607				; display hl 
1607			 
1607			 
1607 11 ae 16			ld de, .regstatehl 
160a 3e 32			ld a, display_row_2+10 
160c cd db 0b			call str_at_display 
160f			 
160f e1				pop hl 
1610 3e 35			ld a, display_row_2+13 
1612 cd 84 14			call display_word_at 
1615			 
1615				 
1615				; display de 
1615			 
1615 11 b2 16			ld de, .regstatede 
1618 3e 50			ld a, display_row_3 
161a cd db 0b			call str_at_display 
161d			 
161d e1				pop hl 
161e			;	ld h,d 
161e			;	ld l, e 
161e 3e 53			ld a, display_row_3+3 
1620 cd 84 14			call display_word_at 
1623			 
1623			 
1623				; display bc 
1623			 
1623 11 b6 16			ld de, .regstatebc 
1626 3e 5a			ld a, display_row_3+10 
1628 cd db 0b			call str_at_display 
162b			 
162b e1				pop hl 
162c			;	ld h,b 
162c			;	ld l, c 
162c 3e 5d			ld a, display_row_3+13 
162e cd 84 14			call display_word_at 
1631			 
1631			 
1631				; display dsp 
1631			 
1631 11 be 16			ld de, .regstatedsp 
1634 3e 78			ld a, display_row_4 
1636 cd db 0b			call str_at_display 
1639			 
1639				 
1639 2a e8 e9			ld hl,(cli_data_sp) 
163c 3e 7c			ld a, display_row_4+4 
163e cd 84 14			call display_word_at 
1641			 
1641				; display rsp 
1641			 
1641 11 c3 16			ld de, .regstatersp 
1644 3e 82			ld a, display_row_4+10 
1646 cd db 0b			call str_at_display 
1649			 
1649				 
1649 2a ec e9			ld hl,(cli_ret_sp) 
164c 3e 86			ld a, display_row_4+14 
164e cd 84 14			call display_word_at 
1651			 
1651 cd eb 0b			call update_display 
1654			 
1654			;	call delay1s 
1654			;	call delay1s 
1654			;	call delay1s 
1654			 
1654			 
1654			;	call next_page_prompt 
1654			 
1654				; restore  
1654			 
1654 f1				pop af 
1655 e1				pop hl 
1656 c1				pop bc 
1657 d1				pop de 
1658 c9				ret 
1659			 
1659 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
166d .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1682 .. 00		.ptrstate:	db "Ptr State",0 
168c .. 00		.ptrcliptr:     db "cli_ptr",0 
1694 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
169e .. 00		.regstate:	db "Reg State (1/0)",0 
16ae .. 00		.regstatehl:	db "HL:",0 
16b2 .. 00		.regstatede:	db "DE:",0 
16b6 .. 00		.regstatebc:	db "BC:",0 
16ba .. 00		.regstatea:	db "A :",0 
16be .. 00		.regstatedsp:	db "DSP:",0 
16c3 .. 00		.regstatersp:	db "RSP:",0 
16c8			 
16c8			display_dump_at_hl: 
16c8 e5				push hl 
16c9 d5				push de 
16ca c5				push bc 
16cb f5				push af 
16cc			 
16cc 22 de e5			ld (os_cur_ptr),hl	 
16cf cd c8 0b			call clear_display 
16d2 cd 10 1a			call dumpcont 
16d5			;	call delay1s 
16d5			;	call next_page_prompt 
16d5			 
16d5			 
16d5 f1				pop af 
16d6 c1				pop bc 
16d7 d1				pop de 
16d8 e1				pop hl 
16d9 c9				ret 
16da			 
16da			;if ENABLE_BASIC 
16da			;	include "nascombasic.asm" 
16da			;	basic: 
16da			;	include "forth/FORTH.ASM" 
16da			;endif 
16da			 
16da			; eof 
16da			 
16da			 
# End of file firmware_diags.asm
16da			  
16da			include "firmware_prompts.asm"  
16da			; Prompts  
16da			 
16da			; boot messages 
16da			 
16da .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
16ef .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
16ff			 
16ff			 
16ff			; config menus 
16ff			 
16ff			;prom_c3: db "Add Dictionary To File",0 
16ff			 
16ff			if STARTUP_V1 
16ff .. 00		prom_c2: db "Select Autoload File",0 
1714 .. 00		prom_c2a: db "Disable Autoload File", 0 
172a			endif 
172a			 
172a			if STARTUP_V2 
172a			prom_c2: db "Enable Autoload Files",0 
172a			prom_c2a: db "Disable Autoload Files", 0 
172a			 
172a			crs_s1: db "*ls-word", 0 
172a			crs_s2: db "*ed-word", 0 
172a			crs_s3: db "*Demo-Games", 0 
172a			crs_s4: db "*Utils", 0 
172a			crs_s5: db "*SPI-Util", 0 
172a			crs_s6: db "*Key-Constants", 0 
172a			crs_sound: db "*Sound-Util", 0 
172a			crs_hw: db "*Hello-World",0 
172a			 
172a			 
172a			 
172a			endif 
172a			;prom_c2b: db "Select Storage Bank",0 
172a .. 00		prom_c4: db "Settings",0 
1733 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
174e .. 00		prom_m4b:   db "Monitor",0 
1756 .. 00		prom_c1: db "Hardware Diags",0 
1765			 
1765			 
1765			if STARTUP_V2 
1765			prom_c9: db "Create Startup Files",0 
1765			endif 
1765			 
1765 .. 00		prom_notav:    db "Feature not available",0 
177b .. 00		prom_empty:    db "",0 
177c			 
177c			; eof 
177c			 
# End of file firmware_prompts.asm
177c			  
177c			  
177c			; eof  
177c			  
# End of file firmware.asm
177c			 
177c			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
177c			;if BASE_KEV  
177c			;baseram: equ 08000h 
177c			;endif 
177c			 
177c			;if BASE_SC114 
177c			;baseram:     equ    endofcode 
177c			;endif 
177c			 
177c			 
177c			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
177c			 
177c			; start system 
177c			 
177c			coldstart: 
177c				; set sp 
177c				; di/ei 
177c			 
177c f3				di 
177d 31 00 f0			ld sp, tos 
1780 cd 2d 5e			call init_nmi 
1783			;	ei 
1783			 
1783				; init spinner 
1783 3e 00			ld a,0 
1785 32 c0 eb			ld (display_active), a 
1788			 
1788				; disable breakpoint by default 
1788			 
1788				;ld a,'*' 
1788			;	ld a,' ' 
1788			;	ld (os_view_disable),a 
1788			 
1788				; set break point vector as new break point on or off 
1788 cd 0b 15			call bp_off 
178b			 
178b				; init hardware 
178b			 
178b				; init keyboard and screen hardware 
178b			 
178b cd 1f 01			call hardware_init 
178e			 
178e			 
178e cd 00 0b			call delay1s 
1791 3e 58			ld a, display_row_3+8 
1793 11 03 01			ld de, buildtime 
1796 cd db 0b			call str_at_display 
1799 cd eb 0b			call update_display 
179c			 
179c cd 00 0b			call delay1s 
179f cd 00 0b			call delay1s 
17a2 cd 00 0b			call delay1s 
17a5			 
17a5				; detect if any keys are held down to enable breakpoints at start up 
17a5			 
17a5 cd 37 5f			call cin  
17a8 fe 00			cp 0 
17aa 28 03			jr z, .nokeys 
17ac			 
17ac				;call hardware_diags 
17ac cd 69 13			call config 
17af			 
17af			;	ld de, .bpen 
17af			;	ld a, display_row_4 
17af			;	call str_at_display 
17af			;	call update_display 
17af			; 
17af			;	ld a,0 
17af			;	ld (os_view_disable),a 
17af			; 
17af			;.bpwait: 
17af			;	call cin 
17af			;	cp 0 
17af			;	jr z, .bpwait 
17af			;	jr .nokeys 
17af			; 
17af			; 
17af			;.bpen:  db "Break points enabled!",0 
17af			 
17af			 
17af			 
17af			 
17af			 
17af			 
17af			.nokeys: 
17af			 
17af			 
17af				 
17af			 
17af			;jp  testkey 
17af			 
17af			;call storage_get_block_0 
17af			; 
17af			;ld hl, 0 
17af			;ld de, store_page 
17af			;call storage_read_block 
17af			 
17af				 
17af			;ld hl, 10 
17af			;ld de, store_page 
17af			;call storage_read_block 
17af			 
17af			 
17af			 
17af			 
17af			 
17af			;stop:	nop 
17af			;	jp stop 
17af			 
17af			 
17af			 
17af			main: 
17af cd c8 0b			call clear_display 
17b2 cd eb 0b			call update_display 
17b5			 
17b5			 
17b5			 
17b5			;	call testlcd 
17b5			 
17b5			 
17b5			 
17b5 cd 51 1f			call forth_init 
17b8			 
17b8			 
17b8			warmstart: 
17b8 cd 27 1f			call forth_warmstart 
17bb			 
17bb				; run startup word load 
17bb			        ; TODO prevent this running at warmstart after crash  
17bb			 
17bb				if STARTUP_ENABLE 
17bb			 
17bb					if STARTUP_V1 
17bb			 
17bb						if STORAGE_SE 
17bb							call forth_autoload 
17bb						endif 
17bb cd 7d 5d					call forth_startup 
17be					endif 
17be			 
17be					if STARTUP_V2 
17be			 
17be						if STORAGE_SE 
17be							call forth_autoload 
17be						else 
17be							call forth_startup 
17be						endif 
17be			 
17be			 
17be					endif 
17be			 
17be				endif 
17be			 
17be			warmstart_afterauto: 
17be			 
17be				; show free memory after boot 
17be 11 5d 18			ld de, freeram 
17c1 3e 00			ld a, display_row_1 
17c3 cd db 0b			call str_at_display 
17c6			 
17c6				; get current heap start after loading any uwords 
17c6			 
17c6				;ld de, (os_last_new_uword) 
17c6				;ex de, hl 
17c6			 
17c6			; Or use heap_size word???? 
17c6				;ld hl, heap_end 
17c6				;ld hl, heap_size 
17c6				;ld de, topusermem 
17c6				;ld de, heap_start 
17c6 ed 5b 5a 5f			ld de, (free_list )      
17ca 21 96 e2				ld hl, heap_end 
17cd ed 52			sbc hl, de 
17cf				;push hl 
17cf				;ld a,h	         	 
17cf				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
17cf				;call hexout 
17cf			   	;pop hl 
17cf			; 
17cf			;	ld a,l 
17cf			;	ld hl, os_word_scratch+2 
17cf			;	call hexout 
17cf			;	ld hl, os_word_scratch+4 
17cf			;	ld a, 0 
17cf			;	ld (hl),a 
17cf eb				ex de, hl 
17d0 21 c0 e5			ld hl, os_word_scratch 
17d3 cd 0a 11			call uitoa_16 
17d6			 
17d6			 
17d6 11 c0 e5			ld de, os_word_scratch 
17d9 3e 0d			ld a, display_row_1 + 13 
17db cd db 0b			call str_at_display 
17de cd eb 0b			call update_display 
17e1			 
17e1			 
17e1				;call demo 
17e1			 
17e1			 
17e1				; init scratch input area for cli commands 
17e1			 
17e1 21 e2 e5			ld hl, os_cli_cmd 
17e4 3e 00			ld a,0 
17e6 77				ld (hl),a 
17e7 23				inc hl 
17e8 77				ld (hl),a 
17e9			 
17e9 3e 00			ld a,0 
17eb 32 e1 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
17ee			 
17ee 32 de e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
17f1 32 df e5			ld (os_cur_ptr+1),a	 
17f4			 
17f4 32 c0 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
17f7 32 c1 e5			ld (os_word_scratch+1),a	 
17fa				 
17fa			 
17fa				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17fa 21 e2 e5			ld hl, os_cli_cmd 
17fd			 
17fd 3e 00			ld a, 0		 ; init cli input 
17ff 77				ld (hl), a 
1800 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1802			cli: 
1802				; show cli prompt 
1802				;push af 
1802				;ld a, 0 
1802				;ld de, prompt 
1802				;call str_at_display 
1802			 
1802				;call update_display 
1802				;pop af 
1802				;inc a 
1802				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1802			 
1802			.lastrecall: 
1802			 
1802 0e 00			ld c, 0 
1804 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1806 1e 28			ld e, 40 
1808			 
1808 21 e2 e5			ld hl, os_cli_cmd 
180b			 
180b				STACKFRAME OFF $fefe $9f9f 
180b				if DEBUG_STACK_IMB 
180b					if OFF 
180b						exx 
180b						ld de, $fefe 
180b						ld a, d 
180b						ld hl, curframe 
180b						call hexout 
180b						ld a, e 
180b						ld hl, curframe+2 
180b						call hexout 
180b						ld hl, $fefe 
180b						push hl 
180b						ld hl, $9f9f 
180b						push hl 
180b						exx 
180b					endif 
180b				endif 
180b			endm 
# End of macro STACKFRAME
180b			 
180b cd 22 0e			call input_str 
180e			 
180e				STACKFRAMECHK OFF $fefe $9f9f 
180e				if DEBUG_STACK_IMB 
180e					if OFF 
180e						exx 
180e						ld hl, $9f9f 
180e						pop de   ; $9f9f 
180e						call cmp16 
180e						jr nz, .spnosame 
180e						ld hl, $fefe 
180e						pop de   ; $fefe 
180e						call cmp16 
180e						jr z, .spfrsame 
180e						.spnosame: call showsperror 
180e						.spfrsame: nop 
180e						exx 
180e					endif 
180e				endif 
180e			endm 
# End of macro STACKFRAMECHK
180e			 
180e			 
180e				; check to see if last line recall has been requested 
180e			 
180e			if EDIT_V2 
180e fe 05			cp KEY_UP 
1810 20 0f			jr nz, .noexecline 
1812			 
1812 11 e2 e5			ld de, os_cli_cmd 
1815 21 e1 e6			ld hl, os_last_cmd 
1818 01 ff 00			ld bc, 255 
181b ed b0			ldir 
181d 3e 00			ld a, 0 
181f 18 e1			jr .lastrecall 
1821			endif 
1821			 
1821			.noexecline: 
1821				; no so exec the line		 
1821			 
1821				; copy input to last command 
1821			 
1821 21 e2 e5			ld hl, os_cli_cmd 
1824 11 e1 e6			ld de, os_last_cmd 
1827 01 ff 00			ld bc, 255 
182a ed b0			ldir 
182c			 
182c				; wipe current buffer 
182c			 
182c			;	ld a, 0 
182c			;	ld hl, os_cli_cmd 
182c			;	ld de, os_cli_cmd+1 
182c			;	ld bc, 254 
182c			;	ldir 
182c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
182c			;	call strcpy 
182c			;	ld a, 0 
182c			;	ld (hl), a 
182c			;	inc hl 
182c			;	ld (hl), a 
182c			;	inc hl 
182c			;	ld (hl), a 
182c			 
182c				; switch frame buffer to program  
182c			 
182c 21 0a ed				ld hl, display_fb1 
182f 22 c6 eb				ld (display_fb_active), hl 
1832			 
1832			;	nop 
1832				STACKFRAME ON $fbfe $8f9f 
1832				if DEBUG_STACK_IMB 
1832					if ON 
1832						exx 
1832						ld de, $fbfe 
1832						ld a, d 
1832						ld hl, curframe 
1832						call hexout 
1832						ld a, e 
1832						ld hl, curframe+2 
1832						call hexout 
1832						ld hl, $fbfe 
1832						push hl 
1832						ld hl, $8f9f 
1832						push hl 
1832						exx 
1832					endif 
1832				endif 
1832			endm 
# End of macro STACKFRAME
1832				; first time into the parser so pass over the current scratch pad 
1832 21 e2 e5			ld hl,os_cli_cmd 
1835				; tokenise the entered statement(s) in HL 
1835 cd cf 1f			call forthparse 
1838			        ; exec forth statements in top of return stack 
1838 cd 0f 20			call forthexec 
183b				;call forthexec_cleanup 
183b			;	call parsenext 
183b			 
183b				STACKFRAMECHK ON $fbfe $8f9f 
183b				if DEBUG_STACK_IMB 
183b					if ON 
183b						exx 
183b						ld hl, $8f9f 
183b						pop de   ; $8f9f 
183b						call cmp16 
183b						jr nz, .spnosame 
183b						ld hl, $fbfe 
183b						pop de   ; $fbfe 
183b						call cmp16 
183b						jr z, .spfrsame 
183b						.spnosame: call showsperror 
183b						.spfrsame: nop 
183b						exx 
183b					endif 
183b				endif 
183b			endm 
# End of macro STACKFRAMECHK
183b				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
183b			 
183b 3e 78			ld a, display_row_4 
183d 11 6e 18			ld de, endprog 
1840			 
1840 cd eb 0b			call update_display		 
1843			 
1843 cd 08 1b			call next_page_prompt 
1846			 
1846				; switch frame buffer to cli 
1846			 
1846 21 ab ed				ld hl, display_fb0 
1849 22 c6 eb				ld (display_fb_active), hl 
184c			 
184c			 
184c cd c8 0b		        call clear_display 
184f cd eb 0b			call update_display		 
1852			 
1852 21 e2 e5			ld hl, os_cli_cmd 
1855			 
1855 3e 00			ld a, 0		 ; init cli input 
1857 77				ld (hl), a 
1858			 
1858				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1858			 
1858				; now on last line 
1858			 
1858				; TODO scroll screen up 
1858			 
1858				; TODO instead just clear screen and place at top of screen 
1858			 
1858			;	ld a, 0 
1858			;	ld (f_cursor_ptr),a 
1858			 
1858				;call clear_display 
1858				;call update_display 
1858			 
1858				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1858 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
185a c3 02 18			jp cli 
185d			 
185d .. 00		freeram: db "Free bytes: ",0 
186a ..			asc: db "1A2F" 
186e .. 00		endprog: db "End prog...",0 
187a			 
187a			testenter2:   
187a 21 ed e2			ld hl,scratch+50 
187d 22 de e5			ld (os_cur_ptr),hl 
1880 c3 02 18			jp cli 
1883			 
1883			testenter:  
1883			 
1883 21 6a 18			ld hl,asc 
1886			;	ld a,(hl) 
1886			;	call nibble2val 
1886 cd 54 10			call get_byte 
1889			 
1889			 
1889			;	ld a,(hl) 
1889			;	call atohex 
1889			 
1889			;	call fourehexhl 
1889 32 ed e2			ld (scratch+50),a 
188c			 
188c			 
188c			 
188c 21 6c 18			ld hl,asc+2 
188f			;	ld a, (hl) 
188f			;	call nibble2val 
188f cd 54 10			call get_byte 
1892			 
1892			;	call fourehexhl 
1892 32 ef e2			ld (scratch+52),a 
1895				 
1895 21 ed e2			ld hl,scratch+50 
1898 22 de e5			ld (os_cur_ptr),hl 
189b c3 02 18			jp cli 
189e			 
189e			enter:	 
189e 3a bf e2			ld a,(scratch+4) 
18a1 fe 00			cp 0 
18a3 28 0c			jr z, .entercont 
18a5				; no, not a null term line so has an address to work out.... 
18a5			 
18a5 21 bd e2			ld hl,scratch+2 
18a8 cd b4 10			call get_word_hl 
18ab			 
18ab 22 de e5			ld (os_cur_ptr),hl	 
18ae c3 02 18			jp cli 
18b1			 
18b1			 
18b1			.entercont:  
18b1			 
18b1 21 bd e2			ld hl, scratch+2 
18b4 cd 54 10			call get_byte 
18b7			 
18b7 2a de e5		   	ld hl,(os_cur_ptr) 
18ba 77					ld (hl),a 
18bb 23					inc hl 
18bc 22 de e5				ld (os_cur_ptr),hl 
18bf				 
18bf			; get byte  
18bf			 
18bf			 
18bf c3 02 18			jp cli 
18c2			 
18c2			 
18c2			; basic monitor support 
18c2			 
18c2			monitor: 
18c2				;  
18c2 cd c8 0b			call clear_display 
18c5 3e 00			ld a, 0 
18c7 11 1b 19			ld de, .monprompt 
18ca cd db 0b			call str_at_display 
18cd cd eb 0b			call update_display 
18d0			 
18d0				; get a monitor command 
18d0			 
18d0 0e 00			ld c, 0     ; entry at top left 
18d2 16 64			ld d, 100   ; max buffer size 
18d4 1e 0f			ld e, 15    ; input scroll area 
18d6 3e 00			ld a, 0     ; init string 
18d8 21 b9 e4			ld hl, os_input 
18db 77				ld (hl), a 
18dc 23				inc hl 
18dd 77				ld (hl), a 
18de 21 b9 e4			ld hl, os_input 
18e1 3e 01			ld a, 1     ; init string 
18e3 cd 22 0e			call input_str 
18e6			 
18e6 cd c8 0b		        call clear_display 
18e9 cd eb 0b			call update_display		 
18ec			 
18ec 3a b9 e4			ld a, (os_input) 
18ef cd 52 11			call toUpper 
18f2 fe 48		        cp 'H' 
18f4 ca 8f 19		        jp z, .monhelp 
18f7 fe 44			cp 'D'		; dump 
18f9 ca c2 19			jp z, .mondump	 
18fc fe 43			cp 'C'		; dump 
18fe ca dc 19			jp z, .moncdump	 
1901 fe 4d			cp 'M'		; dump 
1903 ca 1d 19			jp z, .moneditstart 
1906 fe 55			cp 'U'		; dump 
1908 ca 29 19			jp z, .monedit	 
190b fe 47			cp 'G'		; dump 
190d ca b8 19			jp z, .monjump 
1910 fe 42			cp 'B'		; forth breakpoint 
1912 cc 11 15			call z, break_point_state 
1915 fe 51			cp 'Q'		; dump 
1917 c8				ret z	 
1918			 
1918			 
1918				; TODO "S" to access symbol by name and not need the address 
1918				; TODO "F" to find a string in memory 
1918			 
1918 c3 c2 18			jp monitor 
191b			 
191b .. 00		.monprompt: db ">", 0 
191d			 
191d			.moneditstart: 
191d				; get starting address 
191d			 
191d 21 bb e4			ld hl,os_input+2 
1920 cd b4 10			call get_word_hl 
1923			 
1923 22 de e5			ld (os_cur_ptr),hl	 
1926			 
1926 c3 c2 18			jp monitor 
1929			 
1929			.monedit: 
1929				; get byte to load 
1929			 
1929 21 bb e4			ld hl,os_input+2 
192c cd 54 10			call get_byte 
192f			 
192f				; get address to update 
192f 2a de e5			ld hl, (os_cur_ptr) 
1932			 
1932				; update byte 
1932			 
1932 77				ld (hl), a 
1933			 
1933				; move to next address and save it 
1933			 
1933 23				inc hl 
1934 22 de e5			ld (os_cur_ptr),hl	 
1937			 
1937 c3 c2 18			jp monitor 
193a			 
193a			 
193a .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
194e .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
196a .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1988 .. 00		.monhelptext4:  db "Q-Quit",0 
198f			        
198f			.monhelp: 
198f 3e 00			ld a, display_row_1 
1991 11 3a 19		        ld de, .monhelptext1 
1994			 
1994 cd db 0b			call str_at_display 
1997 3e 28			ld a, display_row_2 
1999 11 4e 19		        ld de, .monhelptext2 
199c					 
199c cd db 0b			call str_at_display 
199f 3e 50			ld a, display_row_3 
19a1 11 6a 19		        ld de, .monhelptext3 
19a4					 
19a4 cd db 0b			call str_at_display 
19a7 3e 78			ld a, display_row_4 
19a9 11 88 19		        ld de, .monhelptext4 
19ac cd db 0b			call str_at_display 
19af			 
19af cd eb 0b			call update_display		 
19b2			 
19b2 cd 08 1b			call next_page_prompt 
19b5 c3 c2 18			jp monitor 
19b8			 
19b8			.monjump:    
19b8 21 bb e4			ld hl,os_input+2 
19bb cd b4 10			call get_word_hl 
19be			 
19be e9				jp (hl) 
19bf c3 c2 18			jp monitor 
19c2			 
19c2			.mondump:    
19c2 21 bb e4			ld hl,os_input+2 
19c5 cd b4 10			call get_word_hl 
19c8			 
19c8 22 de e5			ld (os_cur_ptr),hl	 
19cb cd 10 1a			call dumpcont 
19ce 3e 78			ld a, display_row_4 
19d0 11 6e 18			ld de, endprog 
19d3			 
19d3 cd eb 0b			call update_display		 
19d6			 
19d6 cd 08 1b			call next_page_prompt 
19d9 c3 c2 18			jp monitor 
19dc			.moncdump: 
19dc cd 10 1a			call dumpcont 
19df 3e 78			ld a, display_row_4 
19e1 11 6e 18			ld de, endprog 
19e4			 
19e4 cd eb 0b			call update_display		 
19e7			 
19e7 cd 08 1b			call next_page_prompt 
19ea c3 c2 18			jp monitor 
19ed			 
19ed			 
19ed			; TODO symbol access  
19ed			 
19ed			.symbols:     ;; A list of symbols that can be called up  
19ed ab ed			dw display_fb0 
19ef .. 00			db "fb0",0  
19f3 74 ea		     	dw store_page 
19f5 .. 00			db "store_page",0 
1a00			 
1a00			 
1a00			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a00			 
1a00 3a bc e2			ld a,(scratch+1) 
1a03 fe 00			cp 0 
1a05 28 09			jr z, dumpcont 
1a07			 
1a07				; no, not a null term line so has an address to work out.... 
1a07			 
1a07 21 bd e2			ld hl,scratch+2 
1a0a cd b4 10			call get_word_hl 
1a0d			 
1a0d 22 de e5			ld (os_cur_ptr),hl	 
1a10			 
1a10			 
1a10			 
1a10			dumpcont: 
1a10			 
1a10				; dump bytes at ptr 
1a10			 
1a10			 
1a10 3e 00			ld a, display_row_1 
1a12 2a c6 eb			ld hl, (display_fb_active) 
1a15 cd f5 0d			call addatohl 
1a18 cd 40 1a			call .dumpbyterow 
1a1b			 
1a1b 3e 28			ld a, display_row_2 
1a1d 2a c6 eb			ld hl, (display_fb_active) 
1a20 cd f5 0d			call addatohl 
1a23 cd 40 1a			call .dumpbyterow 
1a26			 
1a26			 
1a26 3e 50			ld a, display_row_3 
1a28 2a c6 eb			ld hl, (display_fb_active) 
1a2b cd f5 0d			call addatohl 
1a2e cd 40 1a			call .dumpbyterow 
1a31			 
1a31 3e 78			ld a, display_row_4 
1a33 2a c6 eb			ld hl, (display_fb_active) 
1a36 cd f5 0d			call addatohl 
1a39 cd 40 1a			call .dumpbyterow 
1a3c			 
1a3c cd eb 0b			call update_display 
1a3f			;		jp cli 
1a3f c9				ret 
1a40			 
1a40			.dumpbyterow: 
1a40			 
1a40				;push af 
1a40			 
1a40 e5				push hl 
1a41			 
1a41				; calc where to poke the ascii 
1a41			if display_cols == 20 
1a41				ld a, 16 
1a41			else 
1a41 3e 1f			ld a, 31 
1a43			endif 
1a43			 
1a43 cd f5 0d			call addatohl 
1a46 22 c0 e5			ld (os_word_scratch),hl  		; save pos for later 
1a49			 
1a49			 
1a49			; display decoding address 
1a49 2a de e5		   	ld hl,(os_cur_ptr) 
1a4c			 
1a4c 7c				ld a,h 
1a4d e1				pop hl 
1a4e e5				push hl 
1a4f			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a4f cd fe 0f			call hexout 
1a52 2a de e5		   	ld hl,(os_cur_ptr) 
1a55			 
1a55 7d				ld a,l 
1a56 e1				pop hl 
1a57 23				inc hl 
1a58 23				inc hl 
1a59 e5				push hl 
1a5a			;	ld hl, os_word_scratch+2 
1a5a cd fe 0f			call hexout 
1a5d e1				pop hl 
1a5e 23				inc hl 
1a5f 23				inc hl 
1a60				;ld hl, os_word_scratch+4 
1a60 3e 3a			ld a, ':' 
1a62 77				ld (hl),a 
1a63 23				inc hl 
1a64				;ld a, 0 
1a64				;ld (hl),a 
1a64				;ld de, os_word_scratch 
1a64				;pop af 
1a64				;push af 
1a64			;		ld a, display_row_2 
1a64			;		call str_at_display 
1a64			;		call update_display 
1a64			 
1a64			 
1a64			;pop af 
1a64			;	add 5 
1a64			 
1a64			if display_cols == 20 
1a64				ld b, 4 
1a64			else 
1a64 06 08			ld b, 8 
1a66			endif	 
1a66			 
1a66			.dumpbyte: 
1a66 c5				push bc 
1a67 e5				push hl 
1a68			 
1a68			 
1a68 2a de e5		   	ld hl,(os_cur_ptr) 
1a6b 7e					ld a,(hl) 
1a6c			 
1a6c					; poke the ascii to display 
1a6c 2a c0 e5				ld hl,(os_word_scratch) 
1a6f 77					ld (hl),a 
1a70 23					inc hl 
1a71 22 c0 e5				ld (os_word_scratch),hl 
1a74			 
1a74					 
1a74			 
1a74			 
1a74 e1					pop hl 
1a75 e5					push hl 
1a76			 
1a76 cd fe 0f				call hexout 
1a79			 
1a79					 
1a79 2a de e5		   	ld hl,(os_cur_ptr) 
1a7c 23				inc hl 
1a7d 22 de e5		   	ld (os_cur_ptr),hl 
1a80			 
1a80 e1					pop hl 
1a81 23					inc hl 
1a82 23					inc hl 
1a83 23					inc hl 
1a84			 
1a84			 
1a84			 
1a84					;ld a,0 
1a84					;ld (os_word_scratch+2),a 
1a84					;pop af 
1a84					;push af 
1a84			 
1a84					;ld de, os_word_scratch 
1a84					;call str_at_display 
1a84			;		call update_display 
1a84			;		pop af 
1a84 c1					pop bc 
1a85 c6 03				add 3 
1a87 10 dd			djnz .dumpbyte 
1a89			 
1a89				 
1a89			 
1a89 c9				ret 
1a8a			 
1a8a			jump:	 
1a8a			 
1a8a 21 bd e2			ld hl,scratch+2 
1a8d cd b4 10			call get_word_hl 
1a90				;ld hl,(scratch+2) 
1a90				;call fourehexhl 
1a90			 
1a90 22 de e5			ld (os_cur_ptr),hl	 
1a93			 
1a93 e9				jp (hl) 
1a94			 
1a94			 
1a94			 
1a94			; TODO implement a basic monitor mode to start with 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			; testing and demo code during development 
1a94			 
1a94			 
1a94 .. 00		str1: db "Enter some text...",0 
1aa7 .. 00		clear: db "                    ",0 
1abc			 
1abc			demo: 
1abc			 
1abc			 
1abc			 
1abc			;	call update_display 
1abc			 
1abc				; init scratch input area for testing 
1abc 21 bb e2			ld hl, scratch	 
1abf 3e 00			ld a,0 
1ac1 77				ld (hl),a 
1ac2			 
1ac2			 
1ac2 3e 28		            LD   A, display_row_2 
1ac4			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ac4 11 94 1a		            LD   DE, str1 
1ac7 cd db 0b			call str_at_display 
1aca			 
1aca			;            CALL fLCD_Str       ;Display string pointed to by DE 
1aca			cloop:	 
1aca 3e 50		            LD   A, display_row_3 
1acc			;            CALL fLCD_Pos       ;Position cursor to location in A 
1acc 11 a7 1a		            LD   DE, clear 
1acf			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1acf cd db 0b				call str_at_display 
1ad2 3e 78			ld a, display_row_4 
1ad4 11 04 1b			ld de, prompt 
1ad7			 
1ad7 cd db 0b				call str_at_display 
1ada cd eb 0b			call update_display 
1add			 
1add 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1adf 16 0a			ld d, 10 
1ae1 21 bb e2			ld hl, scratch	 
1ae4 cd 22 0e			call input_str 
1ae7			 
1ae7			;	call clear_display 
1ae7			;'	call update_display 
1ae7			 
1ae7 3e 00		            LD   A, display_row_1 
1ae9			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ae9 11 a7 1a		            LD   DE, clear 
1aec cd db 0b				call str_at_display 
1aef			;            CALL fLCD_Str       ;Display string pointed to by DE 
1aef 3e 00		            LD   A, display_row_1 
1af1			;            CALL fLCD_Pos       ;Position cursor to location in A 
1af1 11 bb e2		            LD   DE, scratch 
1af4			;            CALL fLCD_Str       ;Display string pointed to by DE 
1af4 cd db 0b				call str_at_display 
1af7 cd eb 0b			call update_display 
1afa			 
1afa 3e 00				ld a,0 
1afc 21 bb e2			ld hl, scratch 
1aff 77				ld (hl),a 
1b00			 
1b00 00				nop 
1b01 c3 ca 1a			jp cloop 
1b04			 
1b04			 
1b04			 
1b04			; OS Prompt 
1b04			 
1b04 .. 00		prompt: db ">",0 
1b06 .. 00		endprg: db "?",0 
1b08			 
1b08			 
1b08			; handy next page prompt 
1b08			next_page_prompt: 
1b08 e5				push hl 
1b09 d5				push de 
1b0a f5				push af 
1b0b c5				push bc 
1b0c			 
1b0c 3e 9f			ld a,display_row_4 + display_cols - 1 
1b0e 11 06 1b		        ld de, endprg 
1b11 cd db 0b			call str_at_display 
1b14 cd eb 0b			call update_display 
1b17 cd 2f 5f			call cin_wait 
1b1a c1				pop bc 
1b1b f1				pop af 
1b1c d1				pop de 
1b1d e1				pop hl 
1b1e			 
1b1e			 
1b1e c9				ret 
1b1f			 
1b1f			 
1b1f			; forth parser 
1b1f			 
1b1f			; My forth kernel 
1b1f			include "forth_kernel.asm" 
1b1f			; 
1b1f			; kernel to the forth OS 
1b1f			 
1b1f			DS_TYPE_STR: equ 1     ; string type 
1b1f			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b1f			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b1f			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b1f			 
1b1f			FORTH_PARSEV1: equ 0 
1b1f			FORTH_PARSEV2: equ 0 
1b1f			FORTH_PARSEV3: equ 0 
1b1f			FORTH_PARSEV4: equ 0 
1b1f			FORTH_PARSEV5: equ 1 
1b1f			 
1b1f			;if FORTH_PARSEV5 
1b1f			;	FORTH_END_BUFFER: equ 0 
1b1f			;else 
1b1f			FORTH_END_BUFFER: equ 127 
1b1f			;endif 
1b1f			 
1b1f			FORTH_TRUE: equ 1 
1b1f			FORTH_FALSE: equ 0 
1b1f			 
1b1f			if FORTH_PARSEV4 
1b1f			include "forth_stackops.asm" 
1b1f			endif 
1b1f			 
1b1f			if FORTH_PARSEV5 
1b1f			include "forth_stackopsv5.asm" 
1b1f			 
1b1f			; Stack operations for v5 parser on wards 
1b1f			; * DATA stack 
1b1f			; * LOOP stack 
1b1f			; * RETURN stack 
1b1f			 
1b1f			 
1b1f			 
1b1f			FORTH_CHK_DSP_UNDER: macro 
1b1f				push hl 
1b1f				push de 
1b1f				ld hl,(cli_data_sp) 
1b1f				ld de, cli_data_stack 
1b1f				call cmp16 
1b1f				jp c, fault_dsp_under 
1b1f				pop de 
1b1f				pop hl 
1b1f				endm 
1b1f			 
1b1f			 
1b1f			FORTH_CHK_RSP_UNDER: macro 
1b1f				push hl 
1b1f				push de 
1b1f				ld hl,(cli_ret_sp) 
1b1f				ld de, cli_ret_stack 
1b1f				call cmp16 
1b1f				jp c, fault_rsp_under 
1b1f				pop de 
1b1f				pop hl 
1b1f				endm 
1b1f			 
1b1f			FORTH_CHK_LOOP_UNDER: macro 
1b1f				push hl 
1b1f				push de 
1b1f				ld hl,(cli_loop_sp) 
1b1f				ld de, cli_loop_stack 
1b1f				call cmp16 
1b1f				jp c, fault_loop_under 
1b1f				pop de 
1b1f				pop hl 
1b1f				endm 
1b1f			 
1b1f			FORTH_ERR_TOS_NOTSTR: macro 
1b1f				; TOSO might need more for checks when used 
1b1f				push af 
1b1f				ld a,(hl) 
1b1f				cp DS_TYPE_STR 
1b1f				jp nz, type_faultn   
1b1f				pop af 
1b1f				endm 
1b1f			 
1b1f			FORTH_ERR_TOS_NOTNUM: macro 
1b1f				push af 
1b1f				ld a,(hl) 
1b1f				cp DS_TYPE_INUM 
1b1f				jp nz, type_faultn   
1b1f				pop af 
1b1f				endm 
1b1f			 
1b1f			 
1b1f			; increase data stack pointer and save hl to it 
1b1f				 
1b1f			FORTH_DSP_NEXT: macro 
1b1f				call macro_forth_dsp_next 
1b1f				endm 
1b1f			 
1b1f			 
1b1f			macro_forth_dsp_next: 
1b1f				if DEBUG_FORTH_STACK_GUARD 
1b1f cd 55 5b				call check_stacks 
1b22				endif 
1b22 e5				push hl 
1b23 d5				push de 
1b24 eb				ex de,hl 
1b25 2a e8 e9			ld hl,(cli_data_sp) 
1b28 23				inc hl 
1b29 23				inc hl 
1b2a			 
1b2a			; PARSEV5 
1b2a 23				inc hl 
1b2b 22 e8 e9			ld (cli_data_sp),hl 
1b2e 73				ld (hl), e 
1b2f 23				inc hl 
1b30 72				ld (hl), d 
1b31 d1				pop de 
1b32 e1				pop hl 
1b33				if DEBUG_FORTH_STACK_GUARD 
1b33 cd 55 5b				call check_stacks 
1b36				endif 
1b36 c9				ret 
1b37			 
1b37			 
1b37			; increase ret stack pointer and save hl to it 
1b37				 
1b37			FORTH_RSP_NEXT: macro 
1b37				call macro_forth_rsp_next 
1b37				endm 
1b37			 
1b37			macro_forth_rsp_next: 
1b37				if DEBUG_FORTH_STACK_GUARD 
1b37 cd 55 5b				call check_stacks 
1b3a				endif 
1b3a e5				push hl 
1b3b d5				push de 
1b3c eb				ex de,hl 
1b3d 2a ec e9			ld hl,(cli_ret_sp) 
1b40 23				inc hl 
1b41 23				inc hl 
1b42 22 ec e9			ld (cli_ret_sp),hl 
1b45 73				ld (hl), e 
1b46 23				inc hl 
1b47 72				ld (hl), d 
1b48 d1				pop de 
1b49 e1				pop hl 
1b4a				if DEBUG_FORTH_STACK_GUARD 
1b4a cd 55 5b				call check_stacks 
1b4d				endif 
1b4d c9				ret 
1b4e			 
1b4e			; get current ret stack pointer and save to hl  
1b4e				 
1b4e			FORTH_RSP_TOS: macro 
1b4e				call macro_forth_rsp_tos 
1b4e				endm 
1b4e			 
1b4e			macro_forth_rsp_tos: 
1b4e				;push de 
1b4e 2a ec e9			ld hl,(cli_ret_sp) 
1b51 cd 89 1b			call loadhlptrtohl 
1b54				;ld e, (hl) 
1b54				;inc hl 
1b54				;ld d, (hl) 
1b54				;ex de, hl 
1b54					if DEBUG_FORTH_WORDS 
1b54			;			DMARK "RST" 
1b54						CALLMONITOR 
1b54 cd 6f ee			call debug_vector  
1b57				endm  
# End of macro CALLMONITOR
1b57					endif 
1b57				;pop de 
1b57 c9				ret 
1b58			 
1b58			; pop ret stack pointer 
1b58				 
1b58			FORTH_RSP_POP: macro 
1b58				call macro_forth_rsp_pop 
1b58				endm 
1b58			 
1b58			 
1b58			macro_forth_rsp_pop: 
1b58				if DEBUG_FORTH_STACK_GUARD 
1b58			;		DMARK "RPP" 
1b58 cd 55 5b				call check_stacks 
1b5b					FORTH_CHK_RSP_UNDER 
1b5b e5				push hl 
1b5c d5				push de 
1b5d 2a ec e9			ld hl,(cli_ret_sp) 
1b60 11 a6 e9			ld de, cli_ret_stack 
1b63 cd 13 0e			call cmp16 
1b66 da 6c 5c			jp c, fault_rsp_under 
1b69 d1				pop de 
1b6a e1				pop hl 
1b6b				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b6b				endif 
1b6b e5				push hl 
1b6c 2a ec e9			ld hl,(cli_ret_sp) 
1b6f			 
1b6f			 
1b6f				if FORTH_ENABLE_FREE 
1b6f			 
1b6f					; get pointer 
1b6f			 
1b6f					push de 
1b6f					push hl 
1b6f			 
1b6f					ld e, (hl) 
1b6f					inc hl 
1b6f					ld d, (hl) 
1b6f			 
1b6f					ex de, hl 
1b6f					call free 
1b6f			 
1b6f					pop hl 
1b6f					pop de 
1b6f			 
1b6f			 
1b6f				endif 
1b6f			 
1b6f			 
1b6f 2b				dec hl 
1b70 2b				dec hl 
1b71 22 ec e9			ld (cli_ret_sp), hl 
1b74				; do stack underflow checks 
1b74 e1				pop hl 
1b75				if DEBUG_FORTH_STACK_GUARD 
1b75 cd 55 5b				call check_stacks 
1b78					FORTH_CHK_RSP_UNDER 
1b78 e5				push hl 
1b79 d5				push de 
1b7a 2a ec e9			ld hl,(cli_ret_sp) 
1b7d 11 a6 e9			ld de, cli_ret_stack 
1b80 cd 13 0e			call cmp16 
1b83 da 6c 5c			jp c, fault_rsp_under 
1b86 d1				pop de 
1b87 e1				pop hl 
1b88				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b88				endif 
1b88 c9				ret 
1b89			 
1b89			 
1b89			 
1b89			; routine to load word pointed to by hl into hl 
1b89			 
1b89			loadhlptrtohl: 
1b89			 
1b89 d5				push de 
1b8a 5e				ld e, (hl) 
1b8b 23				inc hl 
1b8c 56				ld d, (hl) 
1b8d eb				ex de, hl 
1b8e d1				pop de 
1b8f			 
1b8f c9				ret 
1b90			 
1b90			 
1b90			 
1b90			 
1b90			 
1b90			; push a number held in HL onto the data stack 
1b90			; entry point for pushing a value when already in hl used in function above 
1b90			 
1b90			forth_push_numhl: 
1b90			 
1b90 e5				push hl    ; save value to push 
1b91			 
1b91			if DEBUG_FORTH_PUSH 
1b91				; see if disabled 
1b91			 
1b91			 
1b91 f5				push af 
1b92 3a 6f ee			ld a,(debug_vector) 
1b95 fe c9			cp $c9   ; ret 
1b97			;	ld a, (os_view_disable) 
1b97			;	cp '*' 
1b97 28 34			jr z, .pskip2 
1b99 e5				push hl 
1b9a e5			push hl 
1b9b cd c8 0b			call clear_display 
1b9e e1			pop hl 
1b9f 7c				ld a,h 
1ba0 21 c0 e5			ld hl, os_word_scratch 
1ba3 cd fe 0f			call hexout 
1ba6 e1				pop hl 
1ba7 7d				ld a,l 
1ba8 21 c2 e5			ld hl, os_word_scratch+2 
1bab cd fe 0f			call hexout 
1bae			 
1bae 21 c4 e5			ld hl, os_word_scratch+4 
1bb1 3e 00			ld a,0 
1bb3 77				ld (hl),a 
1bb4 11 c0 e5			ld de,os_word_scratch 
1bb7 3e 28				ld a, display_row_2 
1bb9 cd db 0b				call str_at_display 
1bbc 11 63 4d			ld de, .push_num 
1bbf 3e 00			ld a, display_row_1 
1bc1			 
1bc1 cd db 0b				call str_at_display 
1bc4			 
1bc4			 
1bc4 cd eb 0b			call update_display 
1bc7 cd 00 0b			call delay1s 
1bca cd 00 0b			call delay1s 
1bcd			.pskip2:  
1bcd			 
1bcd f1				pop af 
1bce			endif	 
1bce			 
1bce			 
1bce				FORTH_DSP_NEXT 
1bce cd 1f 1b			call macro_forth_dsp_next 
1bd1				endm 
# End of macro FORTH_DSP_NEXT
1bd1			 
1bd1 2a e8 e9			ld hl, (cli_data_sp) 
1bd4			 
1bd4				; save item type 
1bd4 3e 02			ld a,  DS_TYPE_INUM 
1bd6 77				ld (hl), a 
1bd7 23				inc hl 
1bd8			 
1bd8				; get word off stack 
1bd8 d1				pop de 
1bd9 7b				ld a,e 
1bda 77				ld (hl), a 
1bdb 23				inc hl 
1bdc 7a				ld a,d 
1bdd 77				ld (hl), a 
1bde			 
1bde			if DEBUG_FORTH_PUSH 
1bde 2b				dec hl 
1bdf 2b				dec hl 
1be0 2b				dec hl 
1be1						DMARK "PH5" 
1be1 f5				push af  
1be2 3a f6 1b			ld a, (.dmark)  
1be5 32 65 ee			ld (debug_mark),a  
1be8 3a f7 1b			ld a, (.dmark+1)  
1beb 32 66 ee			ld (debug_mark+1),a  
1bee 3a f8 1b			ld a, (.dmark+2)  
1bf1 32 67 ee			ld (debug_mark+2),a  
1bf4 18 03			jr .pastdmark  
1bf6 ..			.dmark: db "PH5"  
1bf9 f1			.pastdmark: pop af  
1bfa			endm  
# End of macro DMARK
1bfa				CALLMONITOR 
1bfa cd 6f ee			call debug_vector  
1bfd				endm  
# End of macro CALLMONITOR
1bfd			endif	 
1bfd			 
1bfd c9				ret 
1bfe			 
1bfe			 
1bfe			; Push a string to stack pointed to by hl 
1bfe			 
1bfe			forth_push_str: 
1bfe			 
1bfe			if DEBUG_FORTH_PUSH 
1bfe						DMARK "PSQ" 
1bfe f5				push af  
1bff 3a 13 1c			ld a, (.dmark)  
1c02 32 65 ee			ld (debug_mark),a  
1c05 3a 14 1c			ld a, (.dmark+1)  
1c08 32 66 ee			ld (debug_mark+1),a  
1c0b 3a 15 1c			ld a, (.dmark+2)  
1c0e 32 67 ee			ld (debug_mark+2),a  
1c11 18 03			jr .pastdmark  
1c13 ..			.dmark: db "PSQ"  
1c16 f1			.pastdmark: pop af  
1c17			endm  
# End of macro DMARK
1c17				CALLMONITOR 
1c17 cd 6f ee			call debug_vector  
1c1a				endm  
# End of macro CALLMONITOR
1c1a			endif	 
1c1a			 
1c1a			 
1c1a			    
1c1a e5				push hl 
1c1b e5				push hl 
1c1c			 
1c1c			;	ld a, 0   ; find end of string 
1c1c cd 5b 11			call strlenz 
1c1f			if DEBUG_FORTH_PUSH 
1c1f						DMARK "PQ2" 
1c1f f5				push af  
1c20 3a 34 1c			ld a, (.dmark)  
1c23 32 65 ee			ld (debug_mark),a  
1c26 3a 35 1c			ld a, (.dmark+1)  
1c29 32 66 ee			ld (debug_mark+1),a  
1c2c 3a 36 1c			ld a, (.dmark+2)  
1c2f 32 67 ee			ld (debug_mark+2),a  
1c32 18 03			jr .pastdmark  
1c34 ..			.dmark: db "PQ2"  
1c37 f1			.pastdmark: pop af  
1c38			endm  
# End of macro DMARK
1c38				CALLMONITOR 
1c38 cd 6f ee			call debug_vector  
1c3b				endm  
# End of macro CALLMONITOR
1c3b			endif	 
1c3b eb				ex de, hl 
1c3c e1				pop hl   ; get ptr to start of string 
1c3d			if DEBUG_FORTH_PUSH 
1c3d						DMARK "PQ3" 
1c3d f5				push af  
1c3e 3a 52 1c			ld a, (.dmark)  
1c41 32 65 ee			ld (debug_mark),a  
1c44 3a 53 1c			ld a, (.dmark+1)  
1c47 32 66 ee			ld (debug_mark+1),a  
1c4a 3a 54 1c			ld a, (.dmark+2)  
1c4d 32 67 ee			ld (debug_mark+2),a  
1c50 18 03			jr .pastdmark  
1c52 ..			.dmark: db "PQ3"  
1c55 f1			.pastdmark: pop af  
1c56			endm  
# End of macro DMARK
1c56				CALLMONITOR 
1c56 cd 6f ee			call debug_vector  
1c59				endm  
# End of macro CALLMONITOR
1c59			endif	 
1c59 19				add hl,de 
1c5a			if DEBUG_FORTH_PUSH 
1c5a						DMARK "PQE" 
1c5a f5				push af  
1c5b 3a 6f 1c			ld a, (.dmark)  
1c5e 32 65 ee			ld (debug_mark),a  
1c61 3a 70 1c			ld a, (.dmark+1)  
1c64 32 66 ee			ld (debug_mark+1),a  
1c67 3a 71 1c			ld a, (.dmark+2)  
1c6a 32 67 ee			ld (debug_mark+2),a  
1c6d 18 03			jr .pastdmark  
1c6f ..			.dmark: db "PQE"  
1c72 f1			.pastdmark: pop af  
1c73			endm  
# End of macro DMARK
1c73				CALLMONITOR 
1c73 cd 6f ee			call debug_vector  
1c76				endm  
# End of macro CALLMONITOR
1c76			endif	 
1c76			 
1c76 2b				dec hl    ; see if there is an optional trailing double quote 
1c77 7e				ld a,(hl) 
1c78 fe 22			cp '"' 
1c7a 20 03			jr nz, .strnoq 
1c7c 3e 00			ld a, 0      ; get rid of double quote 
1c7e 77				ld (hl), a 
1c7f 23			.strnoq: inc hl 
1c80			 
1c80 3e 00			ld a, 0 
1c82 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c83			 
1c83 13				inc de ; add one for the type string 
1c84 13				inc de ; add one for null term??? 
1c85			 
1c85				; tos is get string pointer again 
1c85				; de contains space to allocate 
1c85				 
1c85 d5				push de 
1c86			 
1c86 eb				ex de, hl 
1c87			 
1c87				;push af 
1c87			 
1c87			if DEBUG_FORTH_PUSH 
1c87						DMARK "PHm" 
1c87 f5				push af  
1c88 3a 9c 1c			ld a, (.dmark)  
1c8b 32 65 ee			ld (debug_mark),a  
1c8e 3a 9d 1c			ld a, (.dmark+1)  
1c91 32 66 ee			ld (debug_mark+1),a  
1c94 3a 9e 1c			ld a, (.dmark+2)  
1c97 32 67 ee			ld (debug_mark+2),a  
1c9a 18 03			jr .pastdmark  
1c9c ..			.dmark: db "PHm"  
1c9f f1			.pastdmark: pop af  
1ca0			endm  
# End of macro DMARK
1ca0				CALLMONITOR 
1ca0 cd 6f ee			call debug_vector  
1ca3				endm  
# End of macro CALLMONITOR
1ca3			endif	 
1ca3 cd d0 11			call malloc	; on ret hl now contains allocated memory 
1ca6				if DEBUG_FORTH_MALLOC_GUARD 
1ca6 cc bb 4d				call z,malloc_error 
1ca9				endif 
1ca9			 
1ca9				 
1ca9 c1				pop bc    ; get length 
1caa d1				pop de   ;  get string start    
1cab			 
1cab				; hl has destination from malloc 
1cab			 
1cab eb				ex de, hl    ; prep for ldir 
1cac			 
1cac d5				push de   ; save malloc area for DSP later 
1cad				;push hl   ; save malloc area for DSP later 
1cad			 
1cad			if DEBUG_FORTH_PUSH 
1cad						DMARK "PHc" 
1cad f5				push af  
1cae 3a c2 1c			ld a, (.dmark)  
1cb1 32 65 ee			ld (debug_mark),a  
1cb4 3a c3 1c			ld a, (.dmark+1)  
1cb7 32 66 ee			ld (debug_mark+1),a  
1cba 3a c4 1c			ld a, (.dmark+2)  
1cbd 32 67 ee			ld (debug_mark+2),a  
1cc0 18 03			jr .pastdmark  
1cc2 ..			.dmark: db "PHc"  
1cc5 f1			.pastdmark: pop af  
1cc6			endm  
# End of macro DMARK
1cc6				CALLMONITOR 
1cc6 cd 6f ee			call debug_vector  
1cc9				endm  
# End of macro CALLMONITOR
1cc9			endif	 
1cc9			 
1cc9			 
1cc9 ed b0			ldir 
1ccb			 
1ccb			 
1ccb				; push malloc to data stack     macro?????  
1ccb			 
1ccb				FORTH_DSP_NEXT 
1ccb cd 1f 1b			call macro_forth_dsp_next 
1cce				endm 
# End of macro FORTH_DSP_NEXT
1cce			 
1cce				; save value and type 
1cce			 
1cce 2a e8 e9			ld hl, (cli_data_sp) 
1cd1			 
1cd1				; save item type 
1cd1 3e 01			ld a,  DS_TYPE_STR 
1cd3 77				ld (hl), a 
1cd4 23				inc hl 
1cd5			 
1cd5				; get malloc word off stack 
1cd5 d1				pop de 
1cd6 73				ld (hl), e 
1cd7 23				inc hl 
1cd8 72				ld (hl), d 
1cd9			 
1cd9			 
1cd9			 
1cd9			if DEBUG_FORTH_PUSH 
1cd9 2a e8 e9			ld hl, (cli_data_sp) 
1cdc						DMARK "PHS" 
1cdc f5				push af  
1cdd 3a f1 1c			ld a, (.dmark)  
1ce0 32 65 ee			ld (debug_mark),a  
1ce3 3a f2 1c			ld a, (.dmark+1)  
1ce6 32 66 ee			ld (debug_mark+1),a  
1ce9 3a f3 1c			ld a, (.dmark+2)  
1cec 32 67 ee			ld (debug_mark+2),a  
1cef 18 03			jr .pastdmark  
1cf1 ..			.dmark: db "PHS"  
1cf4 f1			.pastdmark: pop af  
1cf5			endm  
# End of macro DMARK
1cf5				CALLMONITOR 
1cf5 cd 6f ee			call debug_vector  
1cf8				endm  
# End of macro CALLMONITOR
1cf8			;	ex de,hl 
1cf8			endif	 
1cf8				; in case of spaces, skip the ptr past the copied string 
1cf8				;pop af 
1cf8				;ld (cli_origptr),hl 
1cf8			 
1cf8 c9				ret 
1cf9			 
1cf9			 
1cf9			 
1cf9			; TODO ascii push input onto stack given hl to start of input 
1cf9			 
1cf9			; identify type 
1cf9			; if starts with a " then a string 
1cf9			; otherwise it is a number 
1cf9			;  
1cf9			; if a string 
1cf9			;     scan for ending " to get length of string to malloc for + 1 
1cf9			;     malloc 
1cf9			;     put pointer to string on stack first byte flags as string 
1cf9			; 
1cf9			; else a number 
1cf9			;    look for number format identifier 
1cf9			;    $xx hex 
1cf9			;    %xxxxx bin 
1cf9			;    xxxxx decimal 
1cf9			;    convert number to 16bit word.  
1cf9			;    malloc word + 1 with flag to identiy as num 
1cf9			;    put pointer to number on stack 
1cf9			;   
1cf9			;  
1cf9			  
1cf9			forth_apush: 
1cf9				; kernel push 
1cf9			 
1cf9			if DEBUG_FORTH_PUSH 
1cf9						DMARK "PSH" 
1cf9 f5				push af  
1cfa 3a 0e 1d			ld a, (.dmark)  
1cfd 32 65 ee			ld (debug_mark),a  
1d00 3a 0f 1d			ld a, (.dmark+1)  
1d03 32 66 ee			ld (debug_mark+1),a  
1d06 3a 10 1d			ld a, (.dmark+2)  
1d09 32 67 ee			ld (debug_mark+2),a  
1d0c 18 03			jr .pastdmark  
1d0e ..			.dmark: db "PSH"  
1d11 f1			.pastdmark: pop af  
1d12			endm  
# End of macro DMARK
1d12				CALLMONITOR 
1d12 cd 6f ee			call debug_vector  
1d15				endm  
# End of macro CALLMONITOR
1d15			endif	 
1d15				; identify input type 
1d15			 
1d15 7e				ld a,(hl) 
1d16			 
1d16 fe 23			cp '#' 
1d18 ca 52 1d			jp z, .fapdec 
1d1b			 
1d1b			 
1d1b fe 22			cp '"' 
1d1d 28 0a			jr z, .fapstr 
1d1f fe 24			cp '$' 
1d21 ca 49 1d			jp z, .faphex 
1d24 fe 25			cp '%' 
1d26 ca 31 1d			jp z, .fapbin 
1d29			;	cp 'b' 
1d29			;	jp z, .fabin 
1d29				; else decimal 
1d29			 
1d29				; TODO do decimal conversion 
1d29				; decimal is stored as a 16bit word 
1d29			 
1d29				; by default everything is a string if type is not detected 
1d29			.fapstr: ; 
1d29 fe 22			cp '"' 
1d2b 20 01			jr nz, .strnoqu 
1d2d 23				inc hl 
1d2e			.strnoqu: 
1d2e c3 fe 1b			jp forth_push_str 
1d31			 
1d31			 
1d31			 
1d31			.fapbin:    ; push a binary string.  
1d31 11 00 00			ld de, 0   ; hold a 16bit value 
1d34			 
1d34 23			.fapbinshift:	inc hl  
1d35 7e				ld a,(hl) 
1d36 fe 00			cp 0     ; done scanning  
1d38 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d3a			 
1d3a				; left shift de 
1d3a eb				ex de, hl	 
1d3b 29				add hl, hl 
1d3c			 
1d3c				; is 1 
1d3c fe 31			cp '1' 
1d3e 20 02			jr nz, .binzero 
1d40 cb 4d			bit 1, l 
1d42			.binzero: 
1d42 eb				ex de, hl	 ; save current de 
1d43 18 ef			jr .fapbinshift 
1d45			 
1d45			.fapbdone: 
1d45 eb				ex de, hl 
1d46 c3 90 1b			jp forth_push_numhl 
1d49			 
1d49			 
1d49			.faphex:   ; hex is always stored as a 16bit word 
1d49				; skip number prefix 
1d49 23				inc hl 
1d4a				; turn ascii into number 
1d4a cd b4 10			call get_word_hl	; ret 16bit word in hl 
1d4d			 
1d4d c3 90 1b			jp forth_push_numhl 
1d50			 
1d50 00				 nop 
1d51			 
1d51			.fabin:   ; TODO bin conversion 
1d51			 
1d51			 
1d51 c9				ret 
1d52			.fapdec:	 
1d52				; string to dec conversion 
1d52 23				inc hl 
1d53 eb				ex de, hl 
1d54 cd f2 10			call string_to_uint16 
1d57 c3 90 1b			jp forth_push_numhl 
1d5a c9				ret 
1d5b				 
1d5b			;atoui_16: 
1d5b			 
1d5b			; get either a string ptr or a 16bit word from the data stack 
1d5b			 
1d5b			FORTH_DSP: macro 
1d5b				call macro_forth_dsp 
1d5b				endm 
1d5b			 
1d5b			macro_forth_dsp: 
1d5b				; data stack pointer points to current word on tos 
1d5b			 
1d5b 2a e8 e9			ld hl,(cli_data_sp) 
1d5e			 
1d5e				if DEBUG_FORTH_PUSH 
1d5e						DMARK "DSP" 
1d5e f5				push af  
1d5f 3a 73 1d			ld a, (.dmark)  
1d62 32 65 ee			ld (debug_mark),a  
1d65 3a 74 1d			ld a, (.dmark+1)  
1d68 32 66 ee			ld (debug_mark+1),a  
1d6b 3a 75 1d			ld a, (.dmark+2)  
1d6e 32 67 ee			ld (debug_mark+2),a  
1d71 18 03			jr .pastdmark  
1d73 ..			.dmark: db "DSP"  
1d76 f1			.pastdmark: pop af  
1d77			endm  
# End of macro DMARK
1d77			 
1d77 cd ee 4d				call display_data_sp 
1d7a				;call break_point_state 
1d7a				;rst 030h 
1d7a				CALLMONITOR 
1d7a cd 6f ee			call debug_vector  
1d7d				endm  
# End of macro CALLMONITOR
1d7d				endif 
1d7d			 
1d7d c9				ret 
1d7e			 
1d7e			; return hl to start of value on stack 
1d7e			 
1d7e			FORTH_DSP_VALUE: macro 
1d7e				call macro_forth_dsp_value 
1d7e				endm 
1d7e			 
1d7e			macro_forth_dsp_value: 
1d7e			 
1d7e				FORTH_DSP 
1d7e cd 5b 1d			call macro_forth_dsp 
1d81				endm 
# End of macro FORTH_DSP
1d81			 
1d81 d5				push de 
1d82			 
1d82 23				inc hl ; skip type 
1d83			 
1d83 5e				ld e, (hl) 
1d84 23				inc hl 
1d85 56				ld d, (hl) 
1d86 eb				ex de,hl  
1d87			 
1d87 d1				pop de 
1d88			 
1d88 c9				ret 
1d89			 
1d89			; return hl to start of value to second item on stack 
1d89			 
1d89			FORTH_DSP_VALUEM1: macro 
1d89				call macro_forth_dsp_value_m1 
1d89				endm 
1d89			 
1d89			macro_forth_dsp_value_m1: 
1d89			 
1d89				FORTH_DSP 
1d89 cd 5b 1d			call macro_forth_dsp 
1d8c				endm 
# End of macro FORTH_DSP
1d8c			 
1d8c 2b				dec hl 
1d8d 2b				dec hl 
1d8e			;	dec hl 
1d8e			 
1d8e d5				push de 
1d8f			 
1d8f 5e				ld e, (hl) 
1d90 23				inc hl 
1d91 56				ld d, (hl) 
1d92 eb				ex de,hl  
1d93			 
1d93 d1				pop de 
1d94			 
1d94 c9				ret 
1d95			 
1d95				 
1d95			 
1d95			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d95			 
1d95			FORTH_DSP_POP: macro 
1d95				call macro_forth_dsp_pop 
1d95				endm 
1d95			 
1d95			 
1d95			; get the tos data type 
1d95			 
1d95			FORTH_DSP_TYPE:   macro 
1d95			 
1d95				;FORTH_DSP_VALUE 
1d95				FORTH_DSP 
1d95				 
1d95				; hl points to value 
1d95				; check type 
1d95			 
1d95				ld a,(hl) 
1d95			 
1d95				endm 
1d95			 
1d95			; load the tos value into hl 
1d95			 
1d95			 
1d95			FORTH_DSP_VALUEHL:  macro 
1d95				call macro_dsp_valuehl 
1d95				endm 
1d95			 
1d95			 
1d95			 
1d95			macro_dsp_valuehl: 
1d95				FORTH_DSP_VALUE 
1d95 cd 7e 1d			call macro_forth_dsp_value 
1d98				endm 
# End of macro FORTH_DSP_VALUE
1d98			 
1d98				;FORTH_ERR_TOS_NOTNUM 
1d98			 
1d98				;inc hl   ; skip type id 
1d98			 
1d98			;	push de 
1d98			; 
1d98			;	ld e, (hl) 
1d98			;	inc hl 
1d98			;	ld d, (hl) 
1d98			;	ex de,hl  
1d98			 
1d98			;	pop de 
1d98			 
1d98				if DEBUG_FORTH_PUSH 
1d98						DMARK "DVL" 
1d98 f5				push af  
1d99 3a ad 1d			ld a, (.dmark)  
1d9c 32 65 ee			ld (debug_mark),a  
1d9f 3a ae 1d			ld a, (.dmark+1)  
1da2 32 66 ee			ld (debug_mark+1),a  
1da5 3a af 1d			ld a, (.dmark+2)  
1da8 32 67 ee			ld (debug_mark+2),a  
1dab 18 03			jr .pastdmark  
1dad ..			.dmark: db "DVL"  
1db0 f1			.pastdmark: pop af  
1db1			endm  
# End of macro DMARK
1db1				CALLMONITOR 
1db1 cd 6f ee			call debug_vector  
1db4				endm  
# End of macro CALLMONITOR
1db4				endif 
1db4 c9				ret 
1db5			 
1db5			forth_apushstrhl:      
1db5				; push of string requires use of cli_origptr 
1db5				; bodge use 
1db5			 
1db5				; get current cli_origptr, save, update with temp pointer  
1db5 ed 5b 38 ea		ld de, (cli_origptr) 
1db9 22 38 ea			ld (cli_origptr), hl 
1dbc d5				push de 
1dbd cd f9 1c			call forth_apush 
1dc0 d1				pop de 
1dc1 ed 53 38 ea		ld (cli_origptr), de 
1dc5 c9			        ret	 
1dc6			 
1dc6			 
1dc6			; increase loop stack pointer and save hl to it 
1dc6				 
1dc6			FORTH_LOOP_NEXT: macro 
1dc6				call macro_forth_loop_next 
1dc6				;nop 
1dc6				endm 
1dc6			 
1dc6			macro_forth_loop_next: 
1dc6				if DEBUG_FORTH_STACK_GUARD 
1dc6 cd 55 5b				call check_stacks 
1dc9				endif 
1dc9 e5				push hl 
1dca d5				push de 
1dcb eb				ex de,hl 
1dcc 2a ea e9			ld hl,(cli_loop_sp) 
1dcf 23				inc hl 
1dd0 23				inc hl 
1dd1					if DEBUG_FORTH_WORDS 
1dd1						DMARK "LNX" 
1dd1 f5				push af  
1dd2 3a e6 1d			ld a, (.dmark)  
1dd5 32 65 ee			ld (debug_mark),a  
1dd8 3a e7 1d			ld a, (.dmark+1)  
1ddb 32 66 ee			ld (debug_mark+1),a  
1dde 3a e8 1d			ld a, (.dmark+2)  
1de1 32 67 ee			ld (debug_mark+2),a  
1de4 18 03			jr .pastdmark  
1de6 ..			.dmark: db "LNX"  
1de9 f1			.pastdmark: pop af  
1dea			endm  
# End of macro DMARK
1dea						CALLMONITOR 
1dea cd 6f ee			call debug_vector  
1ded				endm  
# End of macro CALLMONITOR
1ded					endif 
1ded 22 ea e9			ld (cli_loop_sp),hl 
1df0 73				ld (hl), e 
1df1 23				inc hl 
1df2 72				ld (hl), d 
1df3 d1				pop de    ; been reversed so save a swap on restore 
1df4 e1				pop hl 
1df5				if DEBUG_FORTH_STACK_GUARD 
1df5 cd 55 5b				call check_stacks 
1df8				endif 
1df8 c9				ret 
1df9			 
1df9			; get current ret stack pointer and save to hl  
1df9				 
1df9			FORTH_LOOP_TOS: macro 
1df9				call macro_forth_loop_tos 
1df9				endm 
1df9			 
1df9			macro_forth_loop_tos: 
1df9 d5				push de 
1dfa 2a ea e9			ld hl,(cli_loop_sp) 
1dfd 5e				ld e, (hl) 
1dfe 23				inc hl 
1dff 56				ld d, (hl) 
1e00 eb				ex de, hl 
1e01 d1				pop de 
1e02 c9				ret 
1e03			 
1e03			; pop loop stack pointer 
1e03				 
1e03			FORTH_LOOP_POP: macro 
1e03				call macro_forth_loop_pop 
1e03				endm 
1e03			 
1e03			 
1e03			macro_forth_loop_pop: 
1e03				if DEBUG_FORTH_STACK_GUARD 
1e03					DMARK "LPP" 
1e03 f5				push af  
1e04 3a 18 1e			ld a, (.dmark)  
1e07 32 65 ee			ld (debug_mark),a  
1e0a 3a 19 1e			ld a, (.dmark+1)  
1e0d 32 66 ee			ld (debug_mark+1),a  
1e10 3a 1a 1e			ld a, (.dmark+2)  
1e13 32 67 ee			ld (debug_mark+2),a  
1e16 18 03			jr .pastdmark  
1e18 ..			.dmark: db "LPP"  
1e1b f1			.pastdmark: pop af  
1e1c			endm  
# End of macro DMARK
1e1c cd 55 5b				call check_stacks 
1e1f					FORTH_CHK_LOOP_UNDER 
1e1f e5				push hl 
1e20 d5				push de 
1e21 2a ea e9			ld hl,(cli_loop_sp) 
1e24 11 24 e9			ld de, cli_loop_stack 
1e27 cd 13 0e			call cmp16 
1e2a da 72 5c			jp c, fault_loop_under 
1e2d d1				pop de 
1e2e e1				pop hl 
1e2f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e2f				endif 
1e2f e5				push hl 
1e30 2a ea e9			ld hl,(cli_loop_sp) 
1e33 2b				dec hl 
1e34 2b				dec hl 
1e35 22 ea e9			ld (cli_loop_sp), hl 
1e38				; TODO do stack underflow checks 
1e38 e1				pop hl 
1e39				if DEBUG_FORTH_STACK_GUARD 
1e39 cd 55 5b				call check_stacks 
1e3c					FORTH_CHK_LOOP_UNDER 
1e3c e5				push hl 
1e3d d5				push de 
1e3e 2a ea e9			ld hl,(cli_loop_sp) 
1e41 11 24 e9			ld de, cli_loop_stack 
1e44 cd 13 0e			call cmp16 
1e47 da 72 5c			jp c, fault_loop_under 
1e4a d1				pop de 
1e4b e1				pop hl 
1e4c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e4c				endif 
1e4c c9				ret 
1e4d			 
1e4d			macro_forth_dsp_pop: 
1e4d			 
1e4d e5				push hl 
1e4e			 
1e4e				; release malloc data 
1e4e			 
1e4e				if DEBUG_FORTH_STACK_GUARD 
1e4e cd 55 5b				call check_stacks 
1e51					FORTH_CHK_DSP_UNDER 
1e51 e5				push hl 
1e52 d5				push de 
1e53 2a e8 e9			ld hl,(cli_data_sp) 
1e56 11 22 e8			ld de, cli_data_stack 
1e59 cd 13 0e			call cmp16 
1e5c da 66 5c			jp c, fault_dsp_under 
1e5f d1				pop de 
1e60 e1				pop hl 
1e61				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e61				endif 
1e61				;ld hl,(cli_data_sp) 
1e61			if DEBUG_FORTH_DOT 
1e61				DMARK "DPP" 
1e61 f5				push af  
1e62 3a 76 1e			ld a, (.dmark)  
1e65 32 65 ee			ld (debug_mark),a  
1e68 3a 77 1e			ld a, (.dmark+1)  
1e6b 32 66 ee			ld (debug_mark+1),a  
1e6e 3a 78 1e			ld a, (.dmark+2)  
1e71 32 67 ee			ld (debug_mark+2),a  
1e74 18 03			jr .pastdmark  
1e76 ..			.dmark: db "DPP"  
1e79 f1			.pastdmark: pop af  
1e7a			endm  
# End of macro DMARK
1e7a				CALLMONITOR 
1e7a cd 6f ee			call debug_vector  
1e7d				endm  
# End of macro CALLMONITOR
1e7d			endif	 
1e7d			 
1e7d			 
1e7d			if FORTH_ENABLE_DSPPOPFREE 
1e7d			 
1e7d				FORTH_DSP 
1e7d cd 5b 1d			call macro_forth_dsp 
1e80				endm 
# End of macro FORTH_DSP
1e80			 
1e80 7e				ld a, (hl) 
1e81 fe 01			cp DS_TYPE_STR 
1e83 20 23			jr nz, .skippopfree 
1e85			 
1e85				FORTH_DSP_VALUEHL 
1e85 cd 95 1d			call macro_dsp_valuehl 
1e88				endm 
# End of macro FORTH_DSP_VALUEHL
1e88 00				nop 
1e89			if DEBUG_FORTH_DOT 
1e89				DMARK "DPf" 
1e89 f5				push af  
1e8a 3a 9e 1e			ld a, (.dmark)  
1e8d 32 65 ee			ld (debug_mark),a  
1e90 3a 9f 1e			ld a, (.dmark+1)  
1e93 32 66 ee			ld (debug_mark+1),a  
1e96 3a a0 1e			ld a, (.dmark+2)  
1e99 32 67 ee			ld (debug_mark+2),a  
1e9c 18 03			jr .pastdmark  
1e9e ..			.dmark: db "DPf"  
1ea1 f1			.pastdmark: pop af  
1ea2			endm  
# End of macro DMARK
1ea2				CALLMONITOR 
1ea2 cd 6f ee			call debug_vector  
1ea5				endm  
# End of macro CALLMONITOR
1ea5			endif	 
1ea5 cd 9a 12			call free 
1ea8			.skippopfree: 
1ea8				 
1ea8			 
1ea8			endif 
1ea8			 
1ea8			if DEBUG_FORTH_DOT_KEY 
1ea8				DMARK "DP2" 
1ea8				CALLMONITOR 
1ea8			endif	 
1ea8			 
1ea8				; move pointer down 
1ea8			 
1ea8 2a e8 e9			ld hl,(cli_data_sp) 
1eab 2b				dec hl 
1eac 2b				dec hl 
1ead			; PARSEV5 
1ead 2b				dec hl 
1eae 22 e8 e9			ld (cli_data_sp), hl 
1eb1			 
1eb1				if DEBUG_FORTH_STACK_GUARD 
1eb1 cd 55 5b				call check_stacks 
1eb4					FORTH_CHK_DSP_UNDER 
1eb4 e5				push hl 
1eb5 d5				push de 
1eb6 2a e8 e9			ld hl,(cli_data_sp) 
1eb9 11 22 e8			ld de, cli_data_stack 
1ebc cd 13 0e			call cmp16 
1ebf da 66 5c			jp c, fault_dsp_under 
1ec2 d1				pop de 
1ec3 e1				pop hl 
1ec4				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ec4				endif 
1ec4			 
1ec4 e1				pop hl 
1ec5			 
1ec5 c9				ret 
1ec6			 
1ec6			getwordathl: 
1ec6				; hl points to an address 
1ec6				; load hl with the word at that address 
1ec6			 
1ec6 d5				push de 
1ec7			 
1ec7 5e				ld e, (hl) 
1ec8 23				inc hl 
1ec9 56				ld d, (hl) 
1eca eb				ex de, hl 
1ecb			 
1ecb d1				pop de 
1ecc c9				ret 
1ecd			 
1ecd			 
1ecd			; functions to manuplite stack pointers 
1ecd			 
1ecd			; generate fragment to set hl to be pointer to a stack item 
1ecd			 
1ecd			FORTH_DSP_PTR: macro  x 
1ecd				ld hl,(cli_data_sp) 
1ecd				ld de, x * 3 
1ecd				sbc hl, de 
1ecd				endm 
1ecd			 
1ecd			 
1ecd			 
1ecd			; copy point in hl to stack tmp storage slots 1-4 
1ecd			hltostack1: 
1ecd 11 b8 e2			ld de, os_stack_1  
1ed0 c3 fb 1e			jp hltostackmv 
1ed3			 
1ed3			hltostack2:  
1ed3 11 b5 e2			ld de, os_stack_2 
1ed6 c3 fb 1e			jp hltostackmv 
1ed9			 
1ed9			hltostack3:  
1ed9 11 b2 e2			ld de, os_stack_3 
1edc c3 fb 1e			jp hltostackmv 
1edf			 
1edf			hltostack4:  
1edf 11 af e2			ld de, os_stack_4  
1ee2 c3 fb 1e			jp hltostackmv 
1ee5			 
1ee5			; copy to point in hl from stack tmp storage slots 1-4 
1ee5			hlfromstack1: 
1ee5 11 b8 e2			ld de, os_stack_1 
1ee8 c3 fa 1e			jp hlfromsttackmv 
1eeb			 
1eeb			hlfromstack2:  
1eeb 11 b5 e2			ld de, os_stack_2 
1eee c3 fa 1e			jp hlfromsttackmv 
1ef1			 
1ef1			hlfromstack3:  
1ef1 11 b2 e2			ld de, os_stack_3 
1ef4 c3 fa 1e			jp hlfromsttackmv 
1ef7			 
1ef7			hlfromstack4:  
1ef7 11 af e2			ld de, os_stack_4 
1efa			 
1efa			hlfromsttackmv: 
1efa eb				ex de, hl 
1efb			 
1efb			hltostackmv: 
1efb			 
1efb				; do stack move 
1efb c5				push bc 
1efc 01 03 00			ld bc, 3 
1eff ed b0			ldir  
1f01 c1				pop bc	 
1f02 c9				ret 
1f03			 
1f03			; eof 
1f03			 
# End of file forth_stackopsv5.asm
1f03			endif 
1f03			 
1f03			loadwordinhl:	 
1f03			 
1f03 d5				push de 
1f04			 
1f04 5e				ld e, (hl) 
1f05 23				inc hl 
1f06 56				ld d, (hl) 
1f07 eb				ex de,hl  
1f08			 
1f08 d1				pop de 
1f09			 
1f09 c9				ret 
1f0a			 
1f0a			user_word_eol:  
1f0a				; hl contains the pointer to where to create a linked list item from the end 
1f0a				; of the user dict to continue on at the system word dict 
1f0a				 
1f0a				; poke the stub of the word list linked list to repoint to rom words 
1f0a			 
1f0a				; stub format 
1f0a				; db   word id 
1f0a				; dw    link to next word 
1f0a			        ; db char length of token 
1f0a				; db string + 0 term 
1f0a				; db exec code....  
1f0a			 
1f0a 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f0c 77				ld (hl), a		; word id 
1f0d 23				inc hl 
1f0e			 
1f0e 11 d9 20			ld de, sysdict 
1f11 73				ld (hl), e		; next word link ie system dict 
1f12 23				inc hl 
1f13 72				ld (hl), d		; next word link ie system dict 
1f14 23				inc hl	 
1f15			 
1f15			;	ld (hl), sysdict		; next word link ie system dict 
1f15			;	inc hl 
1f15			;	inc hl 
1f15			 
1f15			;	inc hl 
1f15			;	inc hl 
1f15			 
1f15 3e 02			ld a, 2			; word length is 0 
1f17 77				ld (hl), a	 
1f18 23				inc hl 
1f19			 
1f19 3e 7e			ld a, '~'			; word length is 0 
1f1b 77				ld (hl), a	 
1f1c 23				inc hl 
1f1d 3e 00			ld a, 0			; save empty word 
1f1f 77				ld (hl), a 
1f20			 
1f20 c9				ret 
1f21			 
1f21				 
1f21			 
1f21			forthexec_cleanup: 
1f21				FORTH_RSP_POP 
1f21 cd 58 1b			call macro_forth_rsp_pop 
1f24				endm 
# End of macro FORTH_RSP_POP
1f24 c9				ret 
1f25			 
1f25			forth_call_hl: 
1f25				; taking hl 
1f25 e5				push hl 
1f26 c9				ret 
1f27			 
1f27			; this is called to reset Forth system but keep existing uwords etc 
1f27			 
1f27			forth_warmstart: 
1f27				; setup stack over/under flow checks 
1f27				if DEBUG_FORTH_STACK_GUARD 
1f27 cd 3b 5b				call chk_stk_init 
1f2a				endif 
1f2a			 
1f2a				; init stack pointers  - * these stacks go upwards *  
1f2a 21 a6 e9			ld hl, cli_ret_stack 
1f2d 22 ec e9			ld (cli_ret_sp), hl	 
1f30				; set bottom of stack 
1f30 3e 00			ld a,0 
1f32 77				ld (hl),a 
1f33 23				inc hl 
1f34 77				ld (hl),a 
1f35			 
1f35 21 22 e8			ld hl, cli_data_stack 
1f38 22 e8 e9			ld (cli_data_sp), hl	 
1f3b				; set bottom of stack 
1f3b 3e 00			ld a,0 
1f3d 77				ld (hl),a 
1f3e 23				inc hl 
1f3f 77				ld (hl),a 
1f40			 
1f40 21 24 e9			ld hl, cli_loop_stack 
1f43 22 ea e9			ld (cli_loop_sp), hl	 
1f46				; set bottom of stack 
1f46 3e 00			ld a,0 
1f48 77				ld (hl),a 
1f49 23				inc hl 
1f4a 77				ld (hl),a 
1f4b			 
1f4b				; init extent of current open file 
1f4b			 
1f4b 3e 00			ld a, 0 
1f4d 32 64 ea			ld (store_openext), a 
1f50			 
1f50 c9				ret 
1f51			 
1f51			 
1f51			 
1f51			; Cold Start - this is called to setup the whole Forth system 
1f51			 
1f51			forth_init: 
1f51			 
1f51				; setup stack over/under flow checks 
1f51			 
1f51			;	if DEBUG_FORTH_STACK_GUARD 
1f51			;		call chk_stk_init 
1f51			;	endif 
1f51			 
1f51				; enable auto display updates (slow.....) 
1f51			 
1f51 3e 01			ld a, 1 
1f53 32 36 ea			ld (cli_autodisplay), a 
1f56			 
1f56				; if storage is in use disable long reads for now 
1f56 3e 00			ld a, 0 
1f58 32 6f ea			ld (store_longread), a 
1f5b			 
1f5b			 
1f5b				; show start up screen 
1f5b			 
1f5b cd c8 0b			call clear_display 
1f5e			 
1f5e 3e 00			ld a,0 
1f60 32 58 ea			ld (f_cursor_ptr), a 
1f63			 
1f63				; set start of word list in start of ram - for use when creating user words 
1f63			 
1f63 21 50 5f			ld hl, baseram 
1f66 22 b8 e5			ld (os_last_new_uword), hl 
1f69 cd 0a 1f			call user_word_eol 
1f6c				 
1f6c			;		call display_data_sp 
1f6c			;		call next_page_prompt 
1f6c			 
1f6c			 
1f6c			 
1f6c			 
1f6c c9				ret 
1f6d			 
1f6d .. 00		.bootforth: db " Forth Kernel Init ",0 
1f81			 
1f81			; TODO push to stack 
1f81			 
1f81			;  
1f81			 
1f81			if FORTH_PARSEV2 
1f81			 
1f81			 
1f81				include "forth_parserv2.asm" 
1f81			 
1f81			endif 
1f81			 
1f81			 
1f81			; parse cli version 1 
1f81			 
1f81			if FORTH_PARSEV1 
1f81			 
1f81			 
1f81			 
1f81			      include "forth_parserv1.asm" 
1f81			endif 
1f81				 
1f81			if FORTH_PARSEV3 
1f81			 
1f81			 
1f81			 
1f81			      include "forth_parserv3.asm" 
1f81				include "forth_wordsv3.asm" 
1f81			endif 
1f81			 
1f81			if FORTH_PARSEV4 
1f81			 
1f81			 
1f81			 
1f81			      include "forth_parserv4.asm" 
1f81				include "forth_wordsv4.asm" 
1f81			endif 
1f81			 
1f81			if FORTH_PARSEV5 
1f81			 
1f81			 
1f81			 
1f81			      include "forth_parserv5.asm" 
1f81			 
1f81			 
1f81			; A better parser without using malloc and string copies all over the place.  
1f81			; Exec in situ should be faster 
1f81			 
1f81			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f81			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f81			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f81			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f81			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f81			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f81			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f81			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f81			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f81			 
1f81			; Core word preamble macro 
1f81			 
1f81			CWHEAD:   macro nxtword opcode lit len opflags 
1f81				db WORD_SYS_CORE+opcode             
1f81				; internal op code number 
1f81				dw nxtword            
1f81				; link to next dict word block 
1f81				db len + 1 
1f81				; literal length of dict word inc zero term 
1f81				db lit,0              
1f81				; literal dict word 
1f81			        ; TODO db opflags        
1f81				endm 
1f81			 
1f81			 
1f81			NEXTW: macro  
1f81				jp macro_next 
1f81				endm 
1f81			 
1f81			macro_next: 
1f81			if DEBUG_FORTH_PARSE_KEY 
1f81				DMARK "NXT" 
1f81				CALLMONITOR 
1f81			endif	 
1f81			;	inc hl  ; skip token null term  
1f81 ed 4b 3a ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f85 ed 5b 38 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f89 2a bc e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f8c			if DEBUG_FORTH_PARSE_KEY 
1f8c				DMARK "}AA" 
1f8c				CALLMONITOR 
1f8c			endif	 
1f8c c3 8f 20			jp execnext 
1f8f				;jp exec1 
1f8f			       
1f8f			 
1f8f			 
1f8f			; Another go at the parser to compile  
1f8f			 
1f8f			 
1f8f			; TODO rework parser to change all of the string words to byte tokens 
1f8f			; TODO do a search for  
1f8f			 
1f8f			; TODO first run normal parser to zero term sections 
1f8f			; TODO for each word do a token look up to get the op code 
1f8f			; TODO need some means to flag to the exec that this is a byte code form    
1f8f			 
1f8f			 
1f8f			forthcompile: 
1f8f			 
1f8f			; 
1f8f			; line parse: 
1f8f			;       parse raw input buffer 
1f8f			;       tokenise the words 
1f8f			;       malloc new copy (for looping etc) 
1f8f			;       copy to malloc + current pc in line to start of string and add line term 
1f8f			;       save on new rsp 
1f8f			; 
1f8f			 
1f8f			; hl to point to the line to tokenise 
1f8f			 
1f8f			;	push hl 
1f8f 22 bc e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f92			 
1f92			;	ld a,0		; string term on input 
1f92			;	call strlent 
1f92			 
1f92			;	ld (os_tok_len), hl	 ; save string length 
1f92			 
1f92			;if DEBUG_FORTH_TOK 
1f92			;	ex de,hl		 
1f92			;endif 
1f92			 
1f92			;	pop hl 		; get back string pointer 
1f92			 
1f92			if DEBUG_FORTH_TOK 
1f92						DMARK "TOc" 
1f92				CALLMONITOR 
1f92			endif 
1f92 7e			.cptoken2:    ld a,(hl) 
1f93 23				inc hl 
1f94 fe 7f			cp FORTH_END_BUFFER 
1f96 28 29			jr z, .cptokendone2 
1f98 fe 00			cp 0 
1f9a 28 25			jr z, .cptokendone2 
1f9c fe 22			cp '"' 
1f9e 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1fa0 fe 20			cp ' ' 
1fa2 20 ee			jr nz,  .cptoken2 
1fa4			 
1fa4			; TODO consume comments held between ( and ) 
1fa4			 
1fa4				; we have a space so change to zero term for dict match later 
1fa4 2b				dec hl 
1fa5 3e 00			ld a,0 
1fa7 77				ld (hl), a 
1fa8 23				inc hl 
1fa9 18 e7			jr .cptoken2 
1fab				 
1fab			 
1fab			.cptokenstr2: 
1fab				; skip all white space until either eol (because forgot to term) or end double quote 
1fab			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fab				;inc hl ; skip current double quote 
1fab 7e				ld a,(hl) 
1fac 23				inc hl 
1fad fe 22			cp '"' 
1faf 28 e1			jr z, .cptoken2 
1fb1 fe 7f			cp FORTH_END_BUFFER 
1fb3 28 0c			jr z, .cptokendone2 
1fb5 fe 00			cp 0 
1fb7 28 08			jr z, .cptokendone2 
1fb9 fe 20			cp ' ' 
1fbb 28 02			jr z, .cptmp2 
1fbd 18 ec			jr .cptokenstr2 
1fbf			 
1fbf			.cptmp2:	; we have a space so change to zero term for dict match later 
1fbf				;dec hl 
1fbf				;ld a,"-"	; TODO remove this when working 
1fbf				;ld (hl), a 
1fbf				;inc hl 
1fbf 18 ea			jr .cptokenstr2 
1fc1			 
1fc1			.cptokendone2: 
1fc1				;inc hl 
1fc1 3e 7f			ld a, FORTH_END_BUFFER 
1fc3 77				ld (hl),a 
1fc4 23				inc hl 
1fc5 3e 21			ld a, '!' 
1fc7 77				ld (hl),a 
1fc8			 
1fc8 2a bc e5			ld hl,(os_tok_ptr) 
1fcb			         
1fcb			if DEBUG_FORTH_TOK 
1fcb						DMARK "Tc1" 
1fcb				CALLMONITOR 
1fcb			endif 
1fcb			 
1fcb				; push exec string to top of return stack 
1fcb				FORTH_RSP_NEXT 
1fcb cd 37 1b			call macro_forth_rsp_next 
1fce				endm 
# End of macro FORTH_RSP_NEXT
1fce c9				ret 
1fcf			 
1fcf			; Another go at the parser need to simplify the process 
1fcf			 
1fcf			forthparse: 
1fcf			 
1fcf			; 
1fcf			; line parse: 
1fcf			;       parse raw input buffer 
1fcf			;       tokenise the words 
1fcf			;       malloc new copy (for looping etc) 
1fcf			;       copy to malloc + current pc in line to start of string and add line term 
1fcf			;       save on new rsp 
1fcf			; 
1fcf			 
1fcf			; hl to point to the line to tokenise 
1fcf			 
1fcf			;	push hl 
1fcf 22 bc e5			ld (os_tok_ptr), hl  ; save ptr to string 
1fd2			 
1fd2			;	ld a,0		; string term on input 
1fd2			;	call strlent 
1fd2			 
1fd2			;	ld (os_tok_len), hl	 ; save string length 
1fd2			 
1fd2			;if DEBUG_FORTH_TOK 
1fd2			;	ex de,hl		 
1fd2			;endif 
1fd2			 
1fd2			;	pop hl 		; get back string pointer 
1fd2			 
1fd2			if DEBUG_FORTH_TOK 
1fd2						DMARK "TOK" 
1fd2				CALLMONITOR 
1fd2			endif 
1fd2 7e			.ptoken2:    ld a,(hl) 
1fd3 23				inc hl 
1fd4 fe 7f			cp FORTH_END_BUFFER 
1fd6 28 29			jr z, .ptokendone2 
1fd8 fe 00			cp 0 
1fda 28 25			jr z, .ptokendone2 
1fdc fe 22			cp '"' 
1fde 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fe0 fe 20			cp ' ' 
1fe2 20 ee			jr nz,  .ptoken2 
1fe4			 
1fe4			; TODO consume comments held between ( and ) 
1fe4			 
1fe4				; we have a space so change to zero term for dict match later 
1fe4 2b				dec hl 
1fe5 3e 00			ld a,0 
1fe7 77				ld (hl), a 
1fe8 23				inc hl 
1fe9 18 e7			jr .ptoken2 
1feb				 
1feb			 
1feb			.ptokenstr2: 
1feb				; skip all white space until either eol (because forgot to term) or end double quote 
1feb			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1feb				;inc hl ; skip current double quote 
1feb 7e				ld a,(hl) 
1fec 23				inc hl 
1fed fe 22			cp '"' 
1fef 28 e1			jr z, .ptoken2 
1ff1 fe 7f			cp FORTH_END_BUFFER 
1ff3 28 0c			jr z, .ptokendone2 
1ff5 fe 00			cp 0 
1ff7 28 08			jr z, .ptokendone2 
1ff9 fe 20			cp ' ' 
1ffb 28 02			jr z, .ptmp2 
1ffd 18 ec			jr .ptokenstr2 
1fff			 
1fff			.ptmp2:	; we have a space so change to zero term for dict match later 
1fff				;dec hl 
1fff				;ld a,"-"	; TODO remove this when working 
1fff				;ld (hl), a 
1fff				;inc hl 
1fff 18 ea			jr .ptokenstr2 
2001			 
2001			.ptokendone2: 
2001				;inc hl 
2001 3e 7f			ld a, FORTH_END_BUFFER 
2003 77				ld (hl),a 
2004 23				inc hl 
2005 3e 21			ld a, '!' 
2007 77				ld (hl),a 
2008			 
2008 2a bc e5			ld hl,(os_tok_ptr) 
200b			         
200b			if DEBUG_FORTH_TOK 
200b						DMARK "TK1" 
200b				CALLMONITOR 
200b			endif 
200b			 
200b				; push exec string to top of return stack 
200b				FORTH_RSP_NEXT 
200b cd 37 1b			call macro_forth_rsp_next 
200e				endm 
# End of macro FORTH_RSP_NEXT
200e c9				ret 
200f			 
200f			; 
200f			;	; malloc size + buffer pointer + if is loop flag 
200f			;	ld hl,(os_tok_len) 		 ; get string length 
200f			; 
200f			;	ld a,l 
200f			; 
200f			;	cp 0			; we dont want to use a null string 
200f			;	ret z 
200f			; 
200f			;;	add 3    ; prefix malloc with buffer for current word ptr 
200f			; 
200f			;	add 5     ; TODO when certain not over writing memory remove 
200f			; 
200f			;		 
200f			; 
200f			;if DEBUG_FORTH_TOK 
200f			;			DMARK "TKE" 
200f			;	CALLMONITOR 
200f			;endif 
200f			; 
200f			;	ld l,a 
200f			;	ld h,0 
200f			;;	push hl   ; save required space for the copy later 
200f			;	call malloc 
200f			;if DEBUG_FORTH_TOK 
200f			;			DMARK "TKM" 
200f			;	CALLMONITOR 
200f			;endif 
200f			;	if DEBUG_FORTH_MALLOC_GUARD 
200f			;		push af 
200f			;		call ishlzero 
200f			;;		ld a, l 
200f			;;		add h 
200f			;;		cp 0 
200f			;		pop af 
200f			;		 
200f			;		call z,malloc_error 
200f			;	endif 
200f			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
200f			; 
200f			; 
200f			;if DEBUG_FORTH_TOK 
200f			;			DMARK "TKR" 
200f			;	CALLMONITOR 
200f			;endif 
200f			; 
200f			;	FORTH_RSP_NEXT 
200f			; 
200f			;	;inc hl	 ; go past current buffer pointer 
200f			;	;inc hl 
200f			;	;inc hl   ; and past if loop flag 
200f			;		; TODO Need to set flag  
200f			; 
200f			;	 
200f			;	 
200f			;	ex de,hl	; malloc is dest 
200f			;	ld hl, (os_tok_len) 
200f			;;	pop bc 
200f			;	ld c, l                
200f			;	ld b,0 
200f			;	ld hl, (os_tok_ptr) 
200f			; 
200f			;if DEBUG_FORTH_TOK 
200f			;			DMARK "TKT" 
200f			;	CALLMONITOR 
200f			;endif 
200f			; 
200f			;	; do str cpy 
200f			; 
200f			;	ldir      ; copy byte in hl to de 
200f			; 
200f			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
200f			; 
200f			;if DEBUG_FORTH_TOK 
200f			; 
200f			;			DMARK "TKY" 
200f			;	CALLMONITOR 
200f			;endif 
200f			;	;ld a,0 
200f			;	;ld a,FORTH_END_BUFFER 
200f			;	ex de, hl 
200f			;	;dec hl			 ; go back over the space delim at the end of word 
200f			;	;ld (hl),a 
200f			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
200f			;	ld a,FORTH_END_BUFFER 
200f			;	ld (hl),a 
200f			;	inc hl 
200f			;	ld a,FORTH_END_BUFFER 
200f			;	ld (hl),a 
200f			; 
200f			;	; init the malloc area data 
200f			;	; set pc for in current area 
200f			;	;ld hl, (os_tok_malloc) 
200f			;	;inc hl 
200f			;	;inc hl 
200f			;	;inc hl 
200f			;	;ex de,hl 
200f			;	;ld hl, (os_tok_malloc) 
200f			;	;ld (hl),e 
200f			;	;inc hl 
200f			;	;ld (hl),d 
200f			; 
200f			; 
200f			;	ld hl,(os_tok_malloc) 
200f			;if DEBUG_FORTH_PARSE_KEY 
200f			;			DMARK "TKU" 
200f			;	CALLMONITOR 
200f			;endif 
200f			; 
200f			;	ret 
200f			 
200f			forthexec: 
200f			 
200f			; line exec: 
200f			; forth parser 
200f			 
200f			; 
200f			;       get current exec line on rsp 
200f			 
200f				FORTH_RSP_TOS 
200f cd 4e 1b			call macro_forth_rsp_tos 
2012				endm 
# End of macro FORTH_RSP_TOS
2012			 
2012			;       restore current pc - hl points to malloc of data 
2012			 
2012				;ld e, (hl) 
2012				;inc hl 
2012				;ld d, (hl) 
2012				;ex de,hl 
2012			 
2012			 
2012			exec1: 
2012 22 bc e5			ld (os_tok_ptr), hl 
2015			 
2015				; copy our PC to working vars  
2015 22 3a ea			ld (cli_ptr), hl 
2018 22 38 ea			ld (cli_origptr), hl 
201b			 
201b 7e				ld a,(hl) 
201c fe 7f			cp FORTH_END_BUFFER 
201e c8				ret z 
201f			 
201f				; skip any nulls 
201f			 
201f fe 00			cp 0 
2021 20 03			jr nz, .execword 
2023 23				inc hl 
2024 18 ec			jr exec1 
2026			 
2026			 
2026			.execword: 
2026			 
2026			 
2026			 
2026			if DEBUG_FORTH_PARSE_KEY 
2026						DMARK "KYQ" 
2026				CALLMONITOR 
2026			endif 
2026			;       while at start of word: 
2026			; get start of dict (in user area first) 
2026			 
2026 21 50 5f		ld hl, baseram 
2029			;ld hl, sysdict 
2029 22 3c ea		ld (cli_nextword),hl 
202c			;           match word at pc 
202c			;           exec word 
202c			;           or push to dsp 
202c			;           forward to next token 
202c			;           if line term pop rsp and exit 
202c			;        
202c			 
202c			if DEBUG_FORTH_PARSE_KEY 
202c						DMARK "KYq" 
202c				CALLMONITOR 
202c			endif 
202c			 
202c			; 
202c			; word comp 
202c			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
202c			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
202c			;    move to start of word  
202c			;    compare word to cli_token 
202c			 
202c			.execpnword:	; HL at start of a word in the dictionary to check 
202c			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
202c			;	ld (cli_ptr), hl 
202c			 
202c 2a 3c ea			ld hl,(cli_nextword) 
202f			 
202f cd d2 20			call forth_tok_next 
2032			; tok next start here 
2032			;	; TODO skip compiled symbol for now 
2032			;	inc hl 
2032			; 
2032			;	; save pointer to next word 
2032			; 
2032			;	; hl now points to the address of the next word pointer  
2032			;	ld e, (hl) 
2032			;	inc hl 
2032			;	ld d, (hl) 
2032			;	inc l 
2032			; 
2032			;	ex de,hl 
2032			;if DEBUG_FORTH_PARSE_NEXTWORD 
2032			;	push bc 
2032			;	ld bc, (cli_nextword) 
2032			;			DMARK "NXW" 
2032			;	CALLMONITOR 
2032			;	pop bc 
2032			;endif 
2032			; tok next end here 
2032 22 3c ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
2035 eb				ex de, hl 
2036			 
2036			 
2036				; save the pointer of the current token - 1 to check against 
2036				 
2036 22 40 ea			ld (cli_token), hl   
2039				; TODO maybe remove below save if no debug 
2039				; save token string ptr for any debug later 
2039 23				inc hl  
203a 22 42 ea			ld (cli_origtoken), hl 
203d 2b				dec hl 
203e				; save pointer to the start of the next dictionay word 
203e 7e				ld a,(hl)   ; get string length 
203f 47				ld b,a 
2040			.execpnwordinc:  
2040 23				inc hl 
2041 10 fd			djnz .execpnwordinc 
2043 22 3e ea			ld (cli_execword), hl      ; save start of this words code 
2046			 
2046				; now check the word token against the string being parsed 
2046			 
2046 2a 40 ea			ld hl,(cli_token) 
2049 23				inc hl     ; skip string length (use zero term instead to end) 
204a 22 40 ea			ld (cli_token), hl 
204d			 
204d			if DEBUG_FORTH_PARSE_KEY 
204d						DMARK "KY2" 
204d			endif 
204d			if DEBUG_FORTH_PARSE_EXEC 
204d				; see if disabled 
204d			 
204d			;	ld a, (os_view_disable) 
204d			;	cp '*' 
204d				ld a, (debug_vector) 
204d				cp $c9   ; RET  
204d				jr z, .skip 
204d			 
204d				push hl 
204d				push hl 
204d				call clear_display 
204d				ld de, .compword 
204d				ld a, display_row_1 
204d				call str_at_display 
204d				pop de 
204d				ld a, display_row_2 
204d				call str_at_display 
204d				ld hl,(cli_ptr) 
204d				ld a,(hl) 
204d			        ld hl, os_word_scratch 
204d				ld (hl),a 
204d				ld a,0 
204d				inc hl 
204d				ld (hl),a 	 
204d				ld de, os_word_scratch 
204d				ld a, display_row_2+10 
204d				call str_at_display 
204d				call update_display 
204d				ld a, 100 
204d				call aDelayInMS 
204d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
204d				call delay250ms 
204d				endif 
204d				pop hl 
204d			.skip:  
204d			endif	 
204d			.execpnchar:    ; compare char between token and string to parse 
204d			 
204d			if DEBUG_FORTH_PARSE_KEY 
204d						DMARK "Ky3" 
204d			endif 
204d			if DEBUG_FORTH_PARSE_EXEC 
204d				; see if disabled 
204d			 
204d			;	ld a, (os_view_disable) 
204d			;	cp '*' 
204d				ld a, (debug_vector) 
204d				cp $C9  ; RET 
204d				jr z, .skip2 
204d			 
204d			;	call clear_display 
204d			ld hl,(cli_token) 
204d			ld a,(hl) 
204d			ld (os_word_scratch),a 
204d				ld hl,(cli_ptr) 
204d			ld a,(hl) 
204d				ld (os_word_scratch+1),a 
204d				ld a,0 
204d				ld (os_word_scratch+2),a 
204d				ld de,os_word_scratch 
204d				ld a,display_row_4 
204d				call str_at_display 
204d				call update_display 
204d			.skip2:  
204d			endif 
204d 2a 40 ea			ld hl,(cli_token) 
2050 7e				ld a, (hl)	 ; char in word token 
2051 23				inc hl 		; move to next char 
2052 22 40 ea			ld (cli_token), hl ; and save it 
2055 47				ld b,a 
2056			 
2056 2a 3a ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
2059 7e				ld a,(hl) 
205a 23				inc hl 
205b 22 3a ea			ld (cli_ptr), hl		; move to next char 
205e cd 52 11			call toUpper 		; make sure the input string matches case 
2061			 
2061			if DEBUG_FORTH_PARSE 
2061			endif 
2061			 
2061				; input stream end of token is a space so get rid of it 
2061			 
2061			;	cp ' ' 
2061			;	jr nz, .pnskipspace 
2061			; 
2061			;	ld a, 0		; make same term as word token term 
2061			; 
2061			;.pnskipspace: 
2061			 
2061			if DEBUG_FORTH_PARSE_KEY 
2061						DMARK "KY7" 
2061			endif 
2061 b8				cp b 
2062 c2 78 20			jp nz, .execpnskipword	 ; no match so move to next word 
2065				 
2065			;    if same 
2065			;       scan for string terms 0 for token and 32 for input 
2065			 
2065				 
2065			if DEBUG_FORTH_PARSE_KEY 
2065						DMARK "KY8" 
2065			endif 
2065			 
2065 80				add b			 
2066 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2068							; TODO need to make sure last word in zero term string is accounted for 
2068 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
206a			 
206a			 
206a				; at end of both strings so both are exact match 
206a			 
206a			;       skip ptr for next word 
206a			 
206a 2a 3a ea			ld hl,(cli_ptr) 	; at input string term 
206d 23				inc hl			 ; at next char 
206e 22 3a ea			ld (cli_ptr), hl     ; save for next round of the parser 
2071 22 38 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2074				 
2074				 
2074			if DEBUG_FORTH_PARSE_KEY 
2074						DMARK "KY3" 
2074			endif 
2074			 
2074			 
2074			 
2074			;       exec code block 
2074			if DEBUG_FORTH_JP 
2074				call clear_display 
2074				call update_display 
2074				call delay1s 
2074				ld hl, (cli_execword)     ; save for next check if no match on this word 
2074				ld a,h 
2074				ld hl, os_word_scratch 
2074				call hexout 
2074				ld hl, (cli_execword)     ; save for next check if no match on this word 
2074				ld a,l 
2074				ld hl, os_word_scratch+2 
2074				call hexout 
2074				ld hl, os_word_scratch+4 
2074				ld a,0 
2074				ld (hl),a 
2074				ld de,os_word_scratch 
2074				call str_at_display 
2074					ld a, display_row_2 
2074					call str_at_display 
2074				ld de, (cli_origtoken) 
2074				ld a, display_row_1+10 
2074					call str_at_display 
2074			 
2074				ld a,display_row_1 
2074				ld de, .foundword 
2074				ld a, display_row_3 
2074				call str_at_display 
2074				call update_display 
2074				call delay1s 
2074				call delay1s 
2074				call delay1s 
2074			endif 
2074			 
2074			if DEBUG_FORTH_PARSE_KEY 
2074						DMARK "KYj" 
2074			endif 
2074				; TODO save the word pointer in this exec 
2074			 
2074 2a 3e ea			ld hl,(cli_execword) 
2077 e9				jp (hl) 
2078			 
2078			 
2078			;    if not same 
2078			;	scan for zero term 
2078			;	get ptr for next word 
2078			;	goto word comp 
2078			 
2078			.execpnskipword:	; get pointer to next word 
2078 2a 3c ea			ld hl,(cli_nextword) 
207b			 
207b 7e				ld a,(hl) 
207c fe 00			cp WORD_SYS_END 
207e			;	cp 0 
207e 28 09			jr z, .execendofdict			 ; at end of words 
2080			 
2080			if DEBUG_FORTH_PARSE_KEY 
2080						DMARK "KY4" 
2080			endif 
2080			if DEBUG_FORTH_PARSE_EXEC 
2080			 
2080				; see if disabled 
2080			 
2080			;	ld a, (os_view_disable) 
2080			;	cp '*' 
2080				ld a,(debug_vector) 
2080				cp $c9   ; RET 
2080				jr z, .noskip 
2080			 
2080			 
2080				ld de, .nowordfound 
2080				ld a, display_row_3 
2080				call str_at_display 
2080				call update_display 
2080				ld a, 100 
2080				call aDelayInMS 
2080				 
2080				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2080					call delay250ms 
2080				endif 
2080			.noskip:  
2080			 
2080			endif	 
2080			 
2080 2a 38 ea			ld hl,(cli_origptr) 
2083 22 3a ea			ld (cli_ptr),hl 
2086			 
2086			if DEBUG_FORTH_PARSE_KEY 
2086						DMARK "KY5" 
2086			endif 
2086 c3 2c 20			jp .execpnword			; else go to next word 
2089			 
2089			.execendofdict:  
2089			 
2089			if DEBUG_FORTH_PARSE_KEY 
2089						DMARK "KYe" 
2089			endif 
2089			if DEBUG_FORTH_PARSE_EXEC 
2089				; see if disabled 
2089			 
2089			;	ld a, (os_view_disable) 
2089			;	cp '*' 
2089				ld a,(debug_vector) 
2089				cp $c9   ; ret 
2089				jr z, .ispskip 
2089			 
2089				call clear_display 
2089				call update_display 
2089				call delay1s 
2089				ld de, (cli_origptr) 
2089				ld a, display_row_1 
2089				call str_at_display 
2089				 
2089				ld de, .enddict 
2089				ld a, display_row_3 
2089				call str_at_display 
2089				call update_display 
2089				ld a, 100 
2089				call aDelayInMS 
2089				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2089				call delay1s 
2089				call delay1s 
2089				call delay1s 
2089				endif 
2089			.ispskip:  
2089				 
2089			endif	 
2089			 
2089			 
2089			 
2089				; if the word is not a keyword then must be a literal so push it to stack 
2089			 
2089			; push token to stack to end of word 
2089			 
2089				STACKFRAME ON $1efe $2f9f 
2089				if DEBUG_STACK_IMB 
2089					if ON 
2089						exx 
2089						ld de, $1efe 
2089						ld a, d 
2089						ld hl, curframe 
2089						call hexout 
2089						ld a, e 
2089						ld hl, curframe+2 
2089						call hexout 
2089						ld hl, $1efe 
2089						push hl 
2089						ld hl, $2f9f 
2089						push hl 
2089						exx 
2089					endif 
2089				endif 
2089			endm 
# End of macro STACKFRAME
2089			 
2089 2a bc e5		ld hl,(os_tok_ptr) 
208c cd f9 1c		call forth_apush 
208f			 
208f				STACKFRAMECHK ON $1efe $2f9f 
208f				if DEBUG_STACK_IMB 
208f					if ON 
208f						exx 
208f						ld hl, $2f9f 
208f						pop de   ; $2f9f 
208f						call cmp16 
208f						jr nz, .spnosame 
208f						ld hl, $1efe 
208f						pop de   ; $1efe 
208f						call cmp16 
208f						jr z, .spfrsame 
208f						.spnosame: call showsperror 
208f						.spfrsame: nop 
208f						exx 
208f					endif 
208f				endif 
208f			endm 
# End of macro STACKFRAMECHK
208f			 
208f			execnext: 
208f			 
208f			if DEBUG_FORTH_PARSE_KEY 
208f						DMARK "KY>" 
208f			endif 
208f			; move past token to next word 
208f			 
208f 2a bc e5		ld hl, (os_tok_ptr) 
2092 3e 00		ld a, 0 
2094 01 ff 00		ld bc, 255     ; input buffer size 
2097 ed b1		cpir 
2099			 
2099			if DEBUG_FORTH_PARSE_KEY 
2099						DMARK "KY!" 
2099				CALLMONITOR 
2099			endif	 
2099			; TODO this might place hl on the null, so will need to forward on??? 
2099			;inc hl   ; see if this gets onto the next item 
2099			 
2099			 
2099			; TODO pass a pointer to the buffer to push 
2099			; TODO call function to push 
2099			 
2099			; look for end of input 
2099			 
2099			;inc hl 
2099			;ld a,(hl) 
2099			;cp FORTH_END_BUFFER 
2099			;ret z 
2099			 
2099			 
2099 c3 12 20		jp exec1 
209c			 
209c			 
209c			 
209c			 
209c			 
209c			 
209c			 
209c			 
209c			 
209c			findnexttok: 
209c			 
209c				; hl is pointer to move 
209c				; de is the token to locate 
209c			 
209c					if DEBUG_FORTH 
209c						DMARK "NTK" 
209c						CALLMONITOR 
209c					endif 
209c d5				push de 
209d			 
209d			.fnt1:	 
209d				; find first char of token to locate 
209d			 
209d 1a				ld a, (de) 
209e 4f				ld c,a 
209f 7e				ld a,(hl) 
20a0 cd 52 11			call toUpper 
20a3					if DEBUG_FORTH 
20a3						DMARK "NT1" 
20a3						CALLMONITOR 
20a3					endif 
20a3 b9				cp c 
20a4			 
20a4 28 03			jr z, .fnt2cmpmorefirst	 
20a6			 
20a6				; first char not found move to next char 
20a6			 
20a6 23				inc hl 
20a7 18 f4			jr .fnt1 
20a9			 
20a9			.fnt2cmpmorefirst:	 
20a9				; first char of token found.  
20a9			 
20a9 e5				push hl     ; save start of token just in case it is the right one 
20aa d9				exx 
20ab e1				pop hl        ; save it to hl' 
20ac d9				exx 
20ad			 
20ad			 
20ad			.fnt2cmpmore:	 
20ad				; compare the rest 
20ad				 
20ad 23				inc hl 
20ae 13				inc de 
20af				 
20af 1a				ld a, (de) 
20b0 4f				ld c,a 
20b1 7e				ld a,(hl) 
20b2 cd 52 11			call toUpper 
20b5			 
20b5					if DEBUG_FORTH 
20b5						DMARK "NT2" 
20b5						CALLMONITOR 
20b5					endif 
20b5				; c has the token to find char 
20b5				; a has the mem to scan char 
20b5			 
20b5 b9				cp c 
20b6 28 04			jr z,.fntmatch1 
20b8			 
20b8				; they are not the same 
20b8			 
20b8					if DEBUG_FORTH 
20b8						DMARK "NT3" 
20b8						CALLMONITOR 
20b8					endif 
20b8 d1				pop de	; reset de token to look for 
20b9 d5				push de 
20ba 18 e1			jr .fnt1 
20bc				 
20bc			.fntmatch1: 
20bc			 
20bc				; is the same char a null which means we might have a full hit? 
20bc					if DEBUG_FORTH 
20bc						DMARK "NT4" 
20bc						CALLMONITOR 
20bc					endif 
20bc			 
20bc fe 00			cp 0 
20be 28 0b			jr z, .fntmatchyes 
20c0			 
20c0				; are we at the end of the token to find? 
20c0			 
20c0					if DEBUG_FORTH 
20c0						DMARK "NT5" 
20c0						CALLMONITOR 
20c0					endif 
20c0 3e 00			ld a, 0 
20c2 b9				cp c 
20c3			 
20c3 c2 ad 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
20c6			 
20c6					if DEBUG_FORTH 
20c6						DMARK "NT6" 
20c6						CALLMONITOR 
20c6					endif 
20c6				; token to find is exhusted but no match to stream 
20c6			 
20c6				; restore tok pointer and continue on 
20c6 d1				pop de 
20c7 d5				push de 
20c8 c3 9d 20			jp .fnt1 
20cb			 
20cb			 
20cb			.fntmatchyes: 
20cb			 
20cb				; hl now contains the end of the found token 
20cb			 
20cb				; get rid of saved token pointer to find 
20cb			 
20cb d1				pop de 
20cc			 
20cc					if DEBUG_FORTH 
20cc						DMARK "NT9" 
20cc						CALLMONITOR 
20cc					endif 
20cc			 
20cc				; hl will be on the null term so forward on 
20cc			 
20cc				; get back the saved start of the token 
20cc			 
20cc d9				exx 
20cd e5				push hl     ; save start of token just in case it is the right one 
20ce d9				exx 
20cf e1				pop hl        ; save it to hl 
20d0			 
20d0 c9				ret 
20d1			 
20d1			 
20d1			; LIST needs to find a specific token   
20d1			; FORGET needs to find a spefici token 
20d1			 
20d1			; SAVE needs to find all tokens by flag 
20d1			; WORDS just needs to scan through all  by flag 
20d1			; UWORDS needs to scan through all by flag 
20d1			 
20d1			 
20d1			; given hl as pointer to start of dict look up string 
20d1			; return hl as pointer to start of word block 
20d1			; or 0 if not found 
20d1			 
20d1			forth_find_tok: 
20d1 c9				ret 
20d2			 
20d2			; given hl as pointer to dict structure 
20d2			; move to the next dict block structure 
20d2			 
20d2			forth_tok_next: 
20d2				; hl now points to the address of the next word pointer  
20d2				; TODO skip compiled symbol for now 
20d2			;	push de 
20d2 23				inc hl 
20d3 5e				ld e, (hl) 
20d4 23				inc hl 
20d5 56				ld d, (hl) 
20d6 23				inc hl 
20d7			 
20d7 eb				ex de,hl 
20d8			if DEBUG_FORTH_PARSE_NEXTWORD 
20d8				push bc 
20d8				ld bc, (cli_nextword) 
20d8						DMARK "NXW" 
20d8				CALLMONITOR 
20d8				pop bc 
20d8			endif 
20d8			;	pop de	 
20d8 c9				ret 
20d9			 
20d9			 
20d9			 
20d9			; eof 
# End of file forth_parserv5.asm
20d9				include "forth_wordsv4.asm" 
20d9			 
20d9			; the core word dictionary v4 
20d9			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20d9			 
20d9			; this is a linked list for each of the system words used 
20d9			; user defined words will follow the same format but will be in ram 
20d9			 
20d9			 
20d9			; 
20d9			; 
20d9			; define linked list: 
20d9			; 
20d9			; 1. compiled byte op code 
20d9			; 2. len of text word 
20d9			; 3. text word 
20d9			; 4. ptr to next dictionary word 
20d9			; 5. asm, calls etc for the word 
20d9			; 
20d9			;  if 1 == 0 then last word in dict  
20d9			;   
20d9			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20d9			;  
20d9			;  
20d9			; create basic standard set of words 
20d9			; 
20d9			;  
20d9			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20d9			; 2DUP 2DROP 2SWAP  
20d9			; @ C@ - get byte  
20d9			; ! C! - store byte 
20d9			; 0< true if less than zero 
20d9			; 0= true if zero 
20d9			; < >  
20d9			; = true if same 
20d9			; variables 
20d9			 
20d9			 
20d9			; Hardware specific words I may need 
20d9			; 
20d9			; IN OUT  
20d9			; calls to key util functions 
20d9			; calls to hardward abstraction stuff 
20d9			; easy control of frame buffers and lcd i/o 
20d9			; keyboard  
20d9			 
20d9			 
20d9			;DICT: macro 
20d9			; op_code, len, word, next 
20d9			;    word: 
20d9			;    db op_code 
20d9			;    ds word zero term 
20d9			;    dw next 
20d9			;    endm 
20d9			 
20d9			 
20d9			 
20d9			 
20d9			; op code 1 is a flag for user define words which are to be handled differently 
20d9			 
20d9			 
20d9			; 
20d9			; 
20d9			;    TODO on entry to a word this should be the expected environment 
20d9			;    hl - tos value if number then held, if string this is the ptr 
20d9			;    de -  
20d9			 
20d9			 
20d9			; opcode ranges 
20d9			; 0 - end of word dict 
20d9			; 255 - user define words 
20d9			 
20d9			sysdict: 
20d9			include "forth_opcodes.asm" 
20d9			; op codes for forth keywords 
20d9			 
20d9			; Changing use of opcodes to flag is the word exists in compiled form or not.  
20d9			; This provides a means to compile uwords if required for higher performance 
20d9			; by avoiding the use of the keyword parser and just jumping directly to the code 
20d9			; Actually there is already a flag for if the code exists as binary thinking about it... 
20d9			 
20d9			 
20d9			 
20d9			 
20d9			 
20d9			; free to use code 0  
20d9				OPCODE_HEAP: equ  1 
20d9				OPCODE_EXEC: equ 2 
20d9				OPCODE_DUP: equ 3 
20d9				OPCODE_SWAP: equ 4 
20d9				OPCODE_COLN: equ 5 
20d9				OPCODE_SCOLN: equ 6 
20d9				OPCODE_DROP: equ 7 
20d9				OPCODE_DUP2: equ 8 
20d9				OPCODE_DROP2: equ 9 
20d9				OPCODE_SWAP2: equ 10 
20d9				OPCODE_AT: equ 11 
20d9				OPCODE_CAT: equ 12 
20d9				OPCODE_BANG: equ 13 
20d9				OPCODE_CBANG: equ 14 
20d9				OPCODE_SCALL: equ 15 
20d9				OPCODE_DEPTH: equ 16 
20d9				OPCODE_OVER: equ 17 
20d9				OPCODE_PAUSE: equ 18 
20d9				OPCODE_PAUSES: equ 19 
20d9				OPCODE_ROT: equ 20 
20d9			;free to reuse	OPCODE_WORDS: equ 21 
20d9			        OPCODE_NOT: equ 21 
20d9				OPCODE_UWORDS: equ 22 
20d9				OPCODE_BP: equ 23 
20d9				OPCODE_MONITOR: equ 24  
20d9				OPCODE_MALLOC: equ 25 
20d9				OPCODE_FREE: equ 26 
20d9				OPCODE_LIST: equ 27 
20d9				OPCODE_FORGET: equ 28 
20d9				OPCODE_NOP: equ 29 
20d9				OPCODE_COMO: equ 30 
20d9				OPCODE_COMC: equ 31 
20d9			;free to reuse	OPCODE_ENDCORE: equ 32 
20d9				OPCODE_AFTERSOUND: equ 33 
20d9				OPCODE_GP2: equ 34 
20d9				OPCODE_GP3: equ 35 
20d9				OPCODE_GP4: equ 36 
20d9				OPCODE_SIN: equ 37 
20d9				OPCODE_SOUT: equ 38 
20d9				OPCODE_SPIO: equ 39 
20d9				OPCODE_SPICEH: equ 40 
20d9				OPCODE_SPIOb: equ 41 
20d9				OPCODE_SPII: equ 42 
20d9				OPCODE_SESEL: equ 43 
20d9				OPCODE_CARTDEV: equ 44 
20d9			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20d9				OPCODE_FB: equ 46 
20d9				OPCODE_EMIT: equ 47 
20d9				OPCODE_DOTH: equ 48 
20d9				OPCODE_DOTF: equ 49 
20d9				OPCODE_DOT: equ 50 
20d9				OPCODE_CLS: equ 51 
20d9				OPCODE_DRAW: equ 52 
20d9				OPCODE_DUMP: equ 53 
20d9				OPCODE_CDUMP: equ 54 
20d9				OPCODE_DAT: equ 55 
20d9				OPCODE_HOME: equ 56 
20d9				OPCODE_SPACE: equ 57 
20d9				OPCODE_SPACES: equ 58 
20d9				OPCODE_SCROLL: equ 59 
20d9				OPCODE_ATQ: equ 60 
20d9				OPCODE_AUTODSP: equ 61 
20d9				OPCODE_MENU: equ 62 
20d9			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20d9				OPCODE_THEN: equ 64 
20d9				OPCODE_ELSE: equ 65 
20d9				OPCODE_DO: equ 66 
20d9				OPCODE_LOOP: equ 67 
20d9				OPCODE_I: equ 68 
20d9				OPCODE_DLOOP: equ 69  
20d9				OPCODE_REPEAT: equ 70  
20d9				OPCODE_UNTIL: equ 71 
20d9				OPCODE_ENDFLOW: equ 72 
20d9				OPCODE_WAITK: equ 73 
20d9				OPCODE_ACCEPT: equ 74 
20d9				OPCODE_EDIT: equ 75 
20d9			;free to reuse	OPCODE_ENDKEY: equ 76 
20d9				OPCODE_LZERO: equ 77 
20d9				OPCODE_TZERO: equ 78 
20d9				OPCODE_LESS: equ 79 
20d9				OPCODE_GT: equ 80 
20d9				OPCODE_EQUAL: equ 81  
20d9			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20d9				OPCODE_NEG: equ 83 
20d9				OPCODE_DIV: equ 84 
20d9				OPCODE_MUL: equ 85 
20d9				OPCODE_MIN: equ 86 
20d9				OPCODE_MAX: equ 87 
20d9				OPCODE_RND16: equ 88 
20d9				OPCODE_RND8: equ 89 
20d9				OPCODE_RND: equ 90 
20d9			;free to reuse	OPCODE_ENDMATHS: equ 91  
20d9				OPCODE_BYNAME: equ 92 
20d9				OPCODE_DIR: equ 93 
20d9				OPCODE_SAVE: equ 94 
20d9				OPCODE_LOAD: equ 95 
20d9				OPCODE_BSAVE: equ 96 
20d9				OPCODE_BLOAD: equ 97 
20d9				OPCODE_SEO: equ 98  
20d9				OPCODE_SEI: equ 99 
20d9				OPCODE_SFREE: equ 100 
20d9				OPCODE_SIZE: equ 101 
20d9				OPCODE_CREATE: equ 102 
20d9				OPCODE_APPEND: equ 103 
20d9				OPCODE_SDEL: equ 104 
20d9				OPCODE_OPEN: equ 105 
20d9				OPCODE_READ: equ 106 
20d9				OPCODE_EOF: equ 106 
20d9				OPCODE_FORMAT: equ 107 
20d9				OPCODE_LABEL: equ 108 
20d9				OPCODE_LABELS: equ 109 
20d9			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20d9				OPCODE_UPPER: equ 111 
20d9				OPCODE_LOWER: equ 112 
20d9				OPCODE_SUBSTR: equ 113 
20d9				OPCODE_LEFT: equ 114 
20d9				OPCODE_RIGHT: equ 115 
20d9				OPCODE_STR2NUM: equ 116 
20d9				OPCODE_NUM2STR: equ 117 
20d9				OPCODE_CONCAT: equ 118 
20d9				OPCODE_FIND: equ 119 
20d9				OPCODE_LEN: equ 120 
20d9				OPCODE_CHAR: equ 121 
20d9			; free to reuse	OPCODE_STRLEN: equ 122 
20d9			; free to reuse	OPCODE_ENDSTR: equ 123 
20d9				OPCODE_V0S: equ 124 
20d9				OPCODE_V0Q: equ 125 
20d9				OPCODE_V1S: equ 126 
20d9				OPCODE_V1Q: equ 127 
20d9				OPCODE_V2S: equ 128 
20d9				OPCODE_V2Q: equ 129 
20d9				OPCODE_V3S: equ 130 
20d9				OPCODE_V3Q: equ 131 
20d9			;free to reuse	OPCODE_END: equ 132 
20d9				OPCODE_ZDUP: equ 133 
20d9			 
20d9			; eof 
# End of file forth_opcodes.asm
20d9			 
20d9			include "forth_words_core.asm" 
20d9			 
20d9			; | ## Core Words 
20d9			 
20d9			;if MALLOC_4 
20d9			 
20d9			.HEAP: 
20d9			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20d9 15				db WORD_SYS_CORE+OPCODE_HEAP             
20da 18 21			dw .EXEC            
20dc 05				db 4 + 1 
20dd .. 00			db "HEAP",0              
20e2				endm 
# End of macro CWHEAD
20e2			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20e2			; | | u1 - Current number of bytes in the heap 
20e2			; | | u2 - Remaining bytes left on the heap 
20e2			; | |  
20e2			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20e2			 
20e2			 
20e2				if DEBUG_FORTH_WORDS_KEY 
20e2					DMARK "HEP" 
20e2 f5				push af  
20e3 3a f7 20			ld a, (.dmark)  
20e6 32 65 ee			ld (debug_mark),a  
20e9 3a f8 20			ld a, (.dmark+1)  
20ec 32 66 ee			ld (debug_mark+1),a  
20ef 3a f9 20			ld a, (.dmark+2)  
20f2 32 67 ee			ld (debug_mark+2),a  
20f5 18 03			jr .pastdmark  
20f7 ..			.dmark: db "HEP"  
20fa f1			.pastdmark: pop af  
20fb			endm  
# End of macro DMARK
20fb					CALLMONITOR 
20fb cd 6f ee			call debug_vector  
20fe				endm  
# End of macro CALLMONITOR
20fe				endif 
20fe 2a 5a 5f			ld hl, (free_list )      
2101 11 5f 5f			ld de, heap_start 
2104			 
2104 ed 52			sbc hl, de  
2106			 
2106 cd 90 1b			call forth_push_numhl 
2109			 
2109			 
2109 ed 5b 5a 5f		ld de, (free_list )      
210d 21 96 e2			ld hl, heap_end 
2110			 
2110 ed 52			sbc hl, de 
2112			 
2112 cd 90 1b			call forth_push_numhl 
2115				 
2115			 
2115				 
2115			 
2115			 
2115			 
2115				NEXTW 
2115 c3 81 1f			jp macro_next 
2118				endm 
# End of macro NEXTW
2118			;endif 
2118			 
2118			.EXEC: 
2118			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2118			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2118			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2118			;; > > 
2118			;; > >   
2118			;	STACKFRAME OFF $5efe $5f9f 
2118			; 
2118			;		if DEBUG_FORTH_WORDS_KEY 
2118			;			DMARK "EXE" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			;	FORTH_DSP_VALUEHL 
2118			; 
2118			;	FORTH_DSP_POP 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX1" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;;	ld e,(hl) 
2118			;;	inc hl 
2118			;;	ld d,(hl) 
2118			;;	ex de,hl 
2118			; 
2118			;;		if DEBUG_FORTH_WORDS 
2118			;;			DMARK "EX2" 
2118			;;			CALLMONITOR 
2118			;;		endif 
2118			;	push hl 
2118			; 
2118			;	;ld a, 0 
2118			;	;ld a, FORTH_END_BUFFER 
2118			;	call strlenz 
2118			;	inc hl   ; include zero term to copy 
2118			;	inc hl   ; include term 
2118			;	inc hl   ; include term 
2118			;	ld b,0 
2118			;	ld c,l 
2118			;	pop hl 
2118			;	ld de, execscratch 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX3" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	ldir 
2118			; 
2118			; 
2118			;	ld hl, execscratch 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EXe" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			;	call forthparse 
2118			;	call forthexec 
2118			;;	call forthexec_cleanup 
2118			;;	call forthparse 
2118			;;	call forthexec 
2118			; 
2118			;	STACKFRAMECHK OFF $5efe $5f9f 
2118			; 
2118			;	; an immediate word so no need to process any more words 
2118			;	ret 
2118			;	NEXTW 
2118			 
2118			; dead code - old version  
2118			;	FORTH_RSP_NEXT 
2118			 
2118			;  
2118			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2118			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2118			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2118			;	push hl 
2118			;	push de 
2118			;	push bc 
2118			; 
2118			; 
2118			;		if DEBUG_FORTH_WORDS_KEY 
2118			;			DMARK "EXR" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			; 
2118			; 
2118			;	;v5 FORTH_DSP_VALUE 
2118			;	FORTH_DSP_VALUEHL 
2118			; 
2118			;	; TODO do string type checks 
2118			; 
2118			;;v5	inc hl   ; skip type 
2118			; 
2118			;	push hl  ; source code  
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX1" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	ld a, 0 
2118			;	call strlent 
2118			; 
2118			;	inc hl 
2118			;	inc hl 
2118			;	inc hl 
2118			;	inc hl 
2118			; 
2118			;	push hl    ; size 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX2" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	call malloc 
2118			; 
2118			;	ex de, hl    ; de now contains malloc area 
2118			;	pop bc   	; get byte count 
2118			;	pop hl      ; get string to copy 
2118			; 
2118			;	push de     ; save malloc for free later 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX3" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	ldir       ; duplicate string 
2118			; 
2118			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2118			;	 
2118			;	; TODO fix the parse would be better than this...  
2118			;	ex de, hl 
2118			;	dec hl 
2118			;	ld a, 0 
2118			;	ld (hl), a 
2118			;	dec hl 
2118			;	ld a, ' ' 
2118			;	ld (hl), a 
2118			;	dec hl 
2118			;	ld (hl), a 
2118			; 
2118			;	dec hl 
2118			;	ld (hl), a 
2118			; 
2118			; 
2118			;	FORTH_DSP_POP  
2118			; 
2118			;	pop hl     
2118			;	push hl    ; save malloc area 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX4" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			;	call forthparse 
2118			;	call forthexec 
2118			;	 
2118			;	pop hl 
2118			;	if DEBUG_FORTH_WORDS 
2118			;		DMARK "EX5" 
2118			;		CALLMONITOR 
2118			;	endif 
2118			; 
2118			;	if FORTH_ENABLE_FREE 
2118			;	call free 
2118			;	endif 
2118			; 
2118			;	if DEBUG_FORTH_WORDS 
2118			;		DMARK "EX6" 
2118			;		CALLMONITOR 
2118			;	endif 
2118			; 
2118			;	pop bc 
2118			;	pop de 
2118			;	pop hl 
2118			;;	FORTH_RSP_POP	  
2118			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2118			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2118			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2118			; 
2118			;	if DEBUG_FORTH_WORDS 
2118			;		DMARK "EX7" 
2118			;		CALLMONITOR 
2118			;	endif 
2118			;	NEXTW 
2118			 
2118			;.STKEXEC: 
2118			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2118			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2118			; 
2118			; 
2118			;		if DEBUG_FORTH_WORDS_KEY 
2118			;			DMARK "STX" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			;	FORTH_DSP_VALUEHL 
2118			; 
2118			;	ld (store_tmp1), hl    ; count 
2118			; 
2118			;	FORTH_DSP_POP 
2118			;.stkexec1: 
2118			;	ld hl, (store_tmp1)   ; count 
2118			;	ld a, 0 
2118			;	cp l 
2118			;	ret z 
2118			; 
2118			;	dec hl 
2118			;	ld (store_tmp1), hl    ; count 
2118			;	 
2118			;	FORTH_DSP_VALUEHL 
2118			;	push hl 
2118			;	 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EXp" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	FORTH_DSP_POP 
2118			; 
2118			;	call strlenz 
2118			;	inc hl   ; include zero term to copy 
2118			;	inc hl   ; include zero term to copy 
2118			;	inc hl   ; include zero term to copy 
2118			;	ld b,0 
2118			;	ld c,l 
2118			;	pop hl 
2118			;	ld de, execscratch 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX3" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	ldir 
2118			; 
2118			; 
2118			;	ld hl, execscratch 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EXP" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			;	call forthparse 
2118			;	ld hl, execscratch 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EXx" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	call forthexec 
2118			; 
2118			;	jp .stkexec1 
2118			; 
2118			;	ret 
2118			 
2118			 
2118			.DUP: 
2118			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2118 17				db WORD_SYS_CORE+OPCODE_DUP             
2119 8e 21			dw .ZDUP            
211b 04				db 3 + 1 
211c .. 00			db "DUP",0              
2120				endm 
# End of macro CWHEAD
2120			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2120			 
2120				if DEBUG_FORTH_WORDS_KEY 
2120					DMARK "DUP" 
2120 f5				push af  
2121 3a 35 21			ld a, (.dmark)  
2124 32 65 ee			ld (debug_mark),a  
2127 3a 36 21			ld a, (.dmark+1)  
212a 32 66 ee			ld (debug_mark+1),a  
212d 3a 37 21			ld a, (.dmark+2)  
2130 32 67 ee			ld (debug_mark+2),a  
2133 18 03			jr .pastdmark  
2135 ..			.dmark: db "DUP"  
2138 f1			.pastdmark: pop af  
2139			endm  
# End of macro DMARK
2139					CALLMONITOR 
2139 cd 6f ee			call debug_vector  
213c				endm  
# End of macro CALLMONITOR
213c				endif 
213c			 
213c				FORTH_DSP 
213c cd 5b 1d			call macro_forth_dsp 
213f				endm 
# End of macro FORTH_DSP
213f			 
213f 7e				ld a, (HL) 
2140 fe 01			cp DS_TYPE_STR 
2142 20 25			jr nz, .dupinum 
2144			 
2144				; push another string 
2144			 
2144				FORTH_DSP_VALUEHL     		 
2144 cd 95 1d			call macro_dsp_valuehl 
2147				endm 
# End of macro FORTH_DSP_VALUEHL
2147			 
2147			if DEBUG_FORTH_WORDS 
2147				DMARK "DUs" 
2147 f5				push af  
2148 3a 5c 21			ld a, (.dmark)  
214b 32 65 ee			ld (debug_mark),a  
214e 3a 5d 21			ld a, (.dmark+1)  
2151 32 66 ee			ld (debug_mark+1),a  
2154 3a 5e 21			ld a, (.dmark+2)  
2157 32 67 ee			ld (debug_mark+2),a  
215a 18 03			jr .pastdmark  
215c ..			.dmark: db "DUs"  
215f f1			.pastdmark: pop af  
2160			endm  
# End of macro DMARK
2160				CALLMONITOR 
2160 cd 6f ee			call debug_vector  
2163				endm  
# End of macro CALLMONITOR
2163			endif 
2163 cd fe 1b			call forth_push_str 
2166			 
2166				NEXTW 
2166 c3 81 1f			jp macro_next 
2169				endm 
# End of macro NEXTW
2169			 
2169			 
2169			.dupinum: 
2169				 
2169			 
2169			 
2169				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2169 cd 95 1d			call macro_dsp_valuehl 
216c				endm 
# End of macro FORTH_DSP_VALUEHL
216c			 
216c			; TODO add floating point number detection 
216c			 
216c			if DEBUG_FORTH_WORDS 
216c				DMARK "DUi" 
216c f5				push af  
216d 3a 81 21			ld a, (.dmark)  
2170 32 65 ee			ld (debug_mark),a  
2173 3a 82 21			ld a, (.dmark+1)  
2176 32 66 ee			ld (debug_mark+1),a  
2179 3a 83 21			ld a, (.dmark+2)  
217c 32 67 ee			ld (debug_mark+2),a  
217f 18 03			jr .pastdmark  
2181 ..			.dmark: db "DUi"  
2184 f1			.pastdmark: pop af  
2185			endm  
# End of macro DMARK
2185				CALLMONITOR 
2185 cd 6f ee			call debug_vector  
2188				endm  
# End of macro CALLMONITOR
2188			endif 
2188			 
2188 cd 90 1b			call forth_push_numhl 
218b				NEXTW 
218b c3 81 1f			jp macro_next 
218e				endm 
# End of macro NEXTW
218e			.ZDUP: 
218e			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
218e 99				db WORD_SYS_CORE+OPCODE_ZDUP             
218f c6 21			dw .SWAP            
2191 05				db 4 + 1 
2192 .. 00			db "?DUP",0              
2197				endm 
# End of macro CWHEAD
2197			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
2197			 
2197				if DEBUG_FORTH_WORDS_KEY 
2197					DMARK "qDU" 
2197 f5				push af  
2198 3a ac 21			ld a, (.dmark)  
219b 32 65 ee			ld (debug_mark),a  
219e 3a ad 21			ld a, (.dmark+1)  
21a1 32 66 ee			ld (debug_mark+1),a  
21a4 3a ae 21			ld a, (.dmark+2)  
21a7 32 67 ee			ld (debug_mark+2),a  
21aa 18 03			jr .pastdmark  
21ac ..			.dmark: db "qDU"  
21af f1			.pastdmark: pop af  
21b0			endm  
# End of macro DMARK
21b0					CALLMONITOR 
21b0 cd 6f ee			call debug_vector  
21b3				endm  
# End of macro CALLMONITOR
21b3				endif 
21b3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21b3 cd 95 1d			call macro_dsp_valuehl 
21b6				endm 
# End of macro FORTH_DSP_VALUEHL
21b6			 
21b6 e5				push hl 
21b7			 
21b7				; is it a zero? 
21b7			 
21b7 3e 00			ld a, 0 
21b9 84				add h 
21ba 85				add l 
21bb			 
21bb e1				pop hl 
21bc			 
21bc fe 00			cp 0 
21be 28 03			jr z, .dup2orig 
21c0			 
21c0			 
21c0 cd 90 1b			call forth_push_numhl 
21c3			 
21c3			 
21c3			; TODO add floating point number detection 
21c3			 
21c3			.dup2orig: 
21c3			 
21c3				NEXTW 
21c3 c3 81 1f			jp macro_next 
21c6				endm 
# End of macro NEXTW
21c6			.SWAP: 
21c6			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
21c6 18				db WORD_SYS_CORE+OPCODE_SWAP             
21c7 1a 22			dw .COLN            
21c9 05				db 4 + 1 
21ca .. 00			db "SWAP",0              
21cf				endm 
# End of macro CWHEAD
21cf			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
21cf				if DEBUG_FORTH_WORDS_KEY 
21cf					DMARK "SWP" 
21cf f5				push af  
21d0 3a e4 21			ld a, (.dmark)  
21d3 32 65 ee			ld (debug_mark),a  
21d6 3a e5 21			ld a, (.dmark+1)  
21d9 32 66 ee			ld (debug_mark+1),a  
21dc 3a e6 21			ld a, (.dmark+2)  
21df 32 67 ee			ld (debug_mark+2),a  
21e2 18 03			jr .pastdmark  
21e4 ..			.dmark: db "SWP"  
21e7 f1			.pastdmark: pop af  
21e8			endm  
# End of macro DMARK
21e8					CALLMONITOR 
21e8 cd 6f ee			call debug_vector  
21eb				endm  
# End of macro CALLMONITOR
21eb				endif 
21eb			 
21eb			; DONE Use os stack swap memory 
21eb			 
21eb				FORTH_DSP_PTR 0     ; TOS 
21eb 2a e8 e9			ld hl,(cli_data_sp) 
21ee 11 00 00			ld de, 0 * 3 
21f1 ed 52			sbc hl, de 
21f3				endm 
# End of macro FORTH_DSP_PTR
21f3 cd cd 1e			call hltostack1 
21f6			  
21f6				FORTH_DSP_PTR 1     ; TOS 
21f6 2a e8 e9			ld hl,(cli_data_sp) 
21f9 11 03 00			ld de, 1 * 3 
21fc ed 52			sbc hl, de 
21fe				endm 
# End of macro FORTH_DSP_PTR
21fe cd d3 1e			call hltostack2 
2201			 
2201				FORTH_DSP_PTR 0     ; TOS 
2201 2a e8 e9			ld hl,(cli_data_sp) 
2204 11 00 00			ld de, 0 * 3 
2207 ed 52			sbc hl, de 
2209				endm 
# End of macro FORTH_DSP_PTR
2209 cd eb 1e			call hlfromstack2 
220c			 
220c				FORTH_DSP_PTR 1     ; TOS 
220c 2a e8 e9			ld hl,(cli_data_sp) 
220f 11 03 00			ld de, 1 * 3 
2212 ed 52			sbc hl, de 
2214				endm 
# End of macro FORTH_DSP_PTR
2214 cd e5 1e			call hlfromstack1 
2217			;	FORTH_DSP_VALUEHL 
2217			;	push hl     ; w2 
2217			; 
2217			;	FORTH_DSP_POP 
2217			; 
2217			;	FORTH_DSP_VALUEHL 
2217			; 
2217			;	FORTH_DSP_POP 
2217			; 
2217			;	pop de     ; w2	, hl = w1 
2217			; 
2217			;	ex de, hl 
2217			;	push de 
2217			; 
2217			;	call forth_push_numhl 
2217			; 
2217			;	pop hl 
2217			; 
2217			;	call forth_push_numhl 
2217				 
2217			 
2217				NEXTW 
2217 c3 81 1f			jp macro_next 
221a				endm 
# End of macro NEXTW
221a			.COLN: 
221a			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
221a 19				db WORD_SYS_CORE+OPCODE_COLN             
221b a6 23			dw .SCOLN            
221d 02				db 1 + 1 
221e .. 00			db ":",0              
2220				endm 
# End of macro CWHEAD
2220			; | : ( -- )         Create new word | DONE 
2220			 
2220				if DEBUG_FORTH_WORDS_KEY 
2220					DMARK "CLN" 
2220 f5				push af  
2221 3a 35 22			ld a, (.dmark)  
2224 32 65 ee			ld (debug_mark),a  
2227 3a 36 22			ld a, (.dmark+1)  
222a 32 66 ee			ld (debug_mark+1),a  
222d 3a 37 22			ld a, (.dmark+2)  
2230 32 67 ee			ld (debug_mark+2),a  
2233 18 03			jr .pastdmark  
2235 ..			.dmark: db "CLN"  
2238 f1			.pastdmark: pop af  
2239			endm  
# End of macro DMARK
2239					CALLMONITOR 
2239 cd 6f ee			call debug_vector  
223c				endm  
# End of macro CALLMONITOR
223c				endif 
223c			STACKFRAME OFF $8efe $989f 
223c				if DEBUG_STACK_IMB 
223c					if OFF 
223c						exx 
223c						ld de, $8efe 
223c						ld a, d 
223c						ld hl, curframe 
223c						call hexout 
223c						ld a, e 
223c						ld hl, curframe+2 
223c						call hexout 
223c						ld hl, $8efe 
223c						push hl 
223c						ld hl, $989f 
223c						push hl 
223c						exx 
223c					endif 
223c				endif 
223c			endm 
# End of macro STACKFRAME
223c			; get parser buffer length  of new word 
223c			 
223c			 
223c			 
223c				; move tok past this to start of name defintition 
223c				; TODO get word to define 
223c				; TODO Move past word token 
223c				; TODO get length of string up to the ';' 
223c			 
223c 2a bc e5		ld hl, (os_tok_ptr) 
223f 23			inc hl 
2240 23			inc hl 
2241			 
2241 3e 3b		ld a, ';' 
2243 cd 66 11		call strlent 
2246			 
2246 7d			ld a,l 
2247 32 ab e2		ld (os_new_parse_len), a 
224a			 
224a			 
224a			if DEBUG_FORTH_UWORD 
224a ed 5b bc e5	ld de, (os_tok_ptr) 
224e					DMARK ":01" 
224e f5				push af  
224f 3a 63 22			ld a, (.dmark)  
2252 32 65 ee			ld (debug_mark),a  
2255 3a 64 22			ld a, (.dmark+1)  
2258 32 66 ee			ld (debug_mark+1),a  
225b 3a 65 22			ld a, (.dmark+2)  
225e 32 67 ee			ld (debug_mark+2),a  
2261 18 03			jr .pastdmark  
2263 ..			.dmark: db ":01"  
2266 f1			.pastdmark: pop af  
2267			endm  
# End of macro DMARK
2267			CALLMONITOR 
2267 cd 6f ee			call debug_vector  
226a				endm  
# End of macro CALLMONITOR
226a			endif 
226a			 
226a			; 
226a			;  new word memory layout: 
226a			;  
226a			;    : adg 6666 ;  
226a			; 
226a			;    db   1     ; user defined word  
226a 23			inc hl    
226b			;    dw   sysdict 
226b 23			inc hl 
226c 23			inc hl 
226d			;    db <word len>+1 (for null) 
226d 23			inc hl 
226e			;    db .... <word> 
226e			; 
226e			 
226e 23			inc hl    ; some extras for the word preamble before the above 
226f 23			inc hl 
2270 23			inc hl 
2271 23			inc hl 
2272 23			inc hl 
2273 23			inc hl 
2274 23			inc hl  
2275 23			inc hl 
2276 23			inc hl 
2277 23			inc hl 
2278 23			inc hl 
2279 23			inc hl 
227a 23			inc hl 
227b 23			inc hl     ; TODO how many do we really need?     maybe only 6 
227c			;       exec word buffer 
227c			;	<ptr word>   
227c 23			inc hl 
227d 23			inc hl 
227e			;       <word list><null term> 7F final term 
227e			 
227e			 
227e			if DEBUG_FORTH_UWORD 
227e					DMARK ":02" 
227e f5				push af  
227f 3a 93 22			ld a, (.dmark)  
2282 32 65 ee			ld (debug_mark),a  
2285 3a 94 22			ld a, (.dmark+1)  
2288 32 66 ee			ld (debug_mark+1),a  
228b 3a 95 22			ld a, (.dmark+2)  
228e 32 67 ee			ld (debug_mark+2),a  
2291 18 03			jr .pastdmark  
2293 ..			.dmark: db ":02"  
2296 f1			.pastdmark: pop af  
2297			endm  
# End of macro DMARK
2297			CALLMONITOR 
2297 cd 6f ee			call debug_vector  
229a				endm  
# End of macro CALLMONITOR
229a			endif 
229a			 
229a			 
229a				; malloc the size 
229a			 
229a cd d0 11			call malloc 
229d 22 ad e2			ld (os_new_malloc), hl     ; save malloc start 
22a0			 
22a0			;    db   1     ; user defined word  
22a0 3e 01			ld a, WORD_SYS_UWORD  
22a2 77				ld (hl), a 
22a3			 
22a3 23			inc hl    
22a4			;    dw   sysdict 
22a4 11 d9 20		ld de, sysdict       ; continue on with the scan to the system dict 
22a7 73			ld (hl), e 
22a8 23			inc hl 
22a9 72			ld (hl), d 
22aa 23			inc hl 
22ab			 
22ab			 
22ab			;    Setup dict word 
22ab			 
22ab 23			inc hl 
22ac 22 a7 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
22af			 
22af			; 1. get length of dict word 
22af			 
22af			 
22af 2a bc e5		ld hl, (os_tok_ptr) 
22b2 23			inc hl 
22b3 23			inc hl    ; position to start of dict word 
22b4 3e 00		ld a, 0 
22b6 cd 66 11		call strlent 
22b9			 
22b9			 
22b9 23			inc hl    ; to include null??? 
22ba			 
22ba			; write length of dict word 
22ba			 
22ba ed 5b a7 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
22be 1b			dec de 
22bf eb			ex de, hl 
22c0 73			ld (hl), e 
22c1 eb			ex de, hl 
22c2			 
22c2			 
22c2			 
22c2			; copy  
22c2 4d			ld c, l 
22c3 06 00		ld b, 0 
22c5 ed 5b a7 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
22c9 2a bc e5		ld hl, (os_tok_ptr) 
22cc 23			inc hl 
22cd 23			inc hl    ; position to start of dict word 
22ce			 
22ce			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
22ce			 
22ce			; TODO need to convert word to upper case 
22ce			 
22ce			ucasetok:	 
22ce 7e			ld a,(hl) 
22cf cd 52 11		call toUpper 
22d2 77			ld (hl),a 
22d3 ed a0		ldi 
22d5 f2 ce 22		jp p, ucasetok 
22d8			 
22d8			 
22d8			 
22d8			; de now points to start of where the word body code should be placed 
22d8 ed 53 a7 e2	ld (os_new_work_ptr), de 
22dc			; hl now points to the words to throw at forthexec which needs to be copied 
22dc 22 a5 e2		ld (os_new_src_ptr), hl 
22df			 
22df			; TODO add 'call to forthexec' 
22df			 
22df			if DEBUG_FORTH_UWORD 
22df c5			push bc 
22e0 ed 4b ad e2	ld bc, (os_new_malloc) 
22e4					DMARK ":0x" 
22e4 f5				push af  
22e5 3a f9 22			ld a, (.dmark)  
22e8 32 65 ee			ld (debug_mark),a  
22eb 3a fa 22			ld a, (.dmark+1)  
22ee 32 66 ee			ld (debug_mark+1),a  
22f1 3a fb 22			ld a, (.dmark+2)  
22f4 32 67 ee			ld (debug_mark+2),a  
22f7 18 03			jr .pastdmark  
22f9 ..			.dmark: db ":0x"  
22fc f1			.pastdmark: pop af  
22fd			endm  
# End of macro DMARK
22fd			CALLMONITOR 
22fd cd 6f ee			call debug_vector  
2300				endm  
# End of macro CALLMONITOR
2300 c1			pop bc 
2301			endif 
2301			 
2301			 
2301			; create word preamble which should be: 
2301			 
2301			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2301			 
2301			;    ld hl, <word code> 
2301			;    jp user_exec 
2301			;    <word code bytes> 
2301			 
2301			 
2301			;	inc de     ; TODO ??? or are we already past the word's null 
2301 eb			ex de, hl 
2302			 
2302 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2304			 
2304 23			inc hl 
2305 22 a1 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2308 23			inc hl 
2309			 
2309 23			inc hl 
230a 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
230c			 
230c 01 e9 4c		ld bc, user_exec 
230f 23			inc hl 
2310 71			ld (hl), c     ; poke address of user_exec 
2311 23			inc hl 
2312 70			ld (hl), b     
2313			; 
2313			;	inc hl 
2313			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2313			; 
2313			; 
2313			;	ld bc, macro_forth_rsp_next 
2313			;	inc hl 
2313			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2313			;	inc hl 
2313			;	ld (hl), b     
2313			; 
2313			;	inc hl 
2313			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2313			; 
2313			; 
2313			;	inc hl 
2313			;	ld bc, forthexec 
2313			;	ld (hl), c     ; poke address of forthexec 
2313			;	inc hl 
2313			;	ld (hl), b      
2313			; 
2313			;	inc hl 
2313			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2313			; 
2313			;	ld bc, user_dict_next 
2313			;	inc hl 
2313			;	ld (hl), c     ; poke address of forthexec 
2313			;	inc hl 
2313			;	ld (hl), b      
2313			 
2313			; hl is now where we need to copy the word byte data to save this 
2313			 
2313 23			inc hl 
2314 22 a3 e2		ld (os_new_exec), hl 
2317			 
2317			; copy definition 
2317			 
2317 eb			ex de, hl 
2318			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2318			;	inc de    ; skip the PC for this parse 
2318 3a ab e2		ld a, (os_new_parse_len) 
231b 4f			ld c, a 
231c 06 00		ld b, 0 
231e ed b0		ldir		 ; copy defintion 
2320			 
2320			 
2320			; poke the address of where the new word bytes live for forthexec 
2320			 
2320 2a a1 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2323			 
2323 ed 5b a3 e2	ld de, (os_new_exec)      
2327			 
2327 73			ld (hl), e 
2328 23			inc hl 
2329 72			ld (hl), d 
232a			 
232a				; TODO copy last user dict word next link to this word 
232a				; TODO update last user dict word to point to this word 
232a			; 
232a			; hl f923 de 812a ; bc 811a 
232a			 
232a			if DEBUG_FORTH_UWORD 
232a c5			push bc 
232b ed 4b ad e2	ld bc, (os_new_malloc) 
232f					DMARK ":0A" 
232f f5				push af  
2330 3a 44 23			ld a, (.dmark)  
2333 32 65 ee			ld (debug_mark),a  
2336 3a 45 23			ld a, (.dmark+1)  
2339 32 66 ee			ld (debug_mark+1),a  
233c 3a 46 23			ld a, (.dmark+2)  
233f 32 67 ee			ld (debug_mark+2),a  
2342 18 03			jr .pastdmark  
2344 ..			.dmark: db ":0A"  
2347 f1			.pastdmark: pop af  
2348			endm  
# End of macro DMARK
2348			CALLMONITOR 
2348 cd 6f ee			call debug_vector  
234b				endm  
# End of macro CALLMONITOR
234b c1			pop bc 
234c			endif 
234c			if DEBUG_FORTH_UWORD 
234c c5			push bc 
234d ed 4b ad e2	ld bc, (os_new_malloc) 
2351 03			inc bc 
2352 03			inc bc 
2353 03			inc bc 
2354 03			inc bc 
2355 03			inc bc 
2356 03			inc bc 
2357 03			inc bc 
2358 03			inc bc 
2359			 
2359					DMARK ":0B" 
2359 f5				push af  
235a 3a 6e 23			ld a, (.dmark)  
235d 32 65 ee			ld (debug_mark),a  
2360 3a 6f 23			ld a, (.dmark+1)  
2363 32 66 ee			ld (debug_mark+1),a  
2366 3a 70 23			ld a, (.dmark+2)  
2369 32 67 ee			ld (debug_mark+2),a  
236c 18 03			jr .pastdmark  
236e ..			.dmark: db ":0B"  
2371 f1			.pastdmark: pop af  
2372			endm  
# End of macro DMARK
2372			CALLMONITOR 
2372 cd 6f ee			call debug_vector  
2375				endm  
# End of macro CALLMONITOR
2375 c1			pop bc 
2376			endif 
2376			 
2376			; update word dict linked list for new word 
2376			 
2376			 
2376 2a b8 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2379 23			inc hl     ; move to next work linked list ptr 
237a			 
237a ed 5b ad e2	ld de, (os_new_malloc)		 ; new next word 
237e 73			ld (hl), e 
237f 23			inc hl 
2380 72			ld (hl), d 
2381			 
2381			if DEBUG_FORTH_UWORD 
2381 ed 4b b8 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2385			endif 
2385			 
2385 ed 53 b8 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2389			 
2389			 
2389			if DEBUG_FORTH_UWORD 
2389					DMARK ":0+" 
2389 f5				push af  
238a 3a 9e 23			ld a, (.dmark)  
238d 32 65 ee			ld (debug_mark),a  
2390 3a 9f 23			ld a, (.dmark+1)  
2393 32 66 ee			ld (debug_mark+1),a  
2396 3a a0 23			ld a, (.dmark+2)  
2399 32 67 ee			ld (debug_mark+2),a  
239c 18 03			jr .pastdmark  
239e ..			.dmark: db ":0+"  
23a1 f1			.pastdmark: pop af  
23a2			endm  
# End of macro DMARK
23a2			CALLMONITOR 
23a2 cd 6f ee			call debug_vector  
23a5				endm  
# End of macro CALLMONITOR
23a5			endif 
23a5			 
23a5			STACKFRAMECHK OFF $8efe $989f 
23a5				if DEBUG_STACK_IMB 
23a5					if OFF 
23a5						exx 
23a5						ld hl, $989f 
23a5						pop de   ; $989f 
23a5						call cmp16 
23a5						jr nz, .spnosame 
23a5						ld hl, $8efe 
23a5						pop de   ; $8efe 
23a5						call cmp16 
23a5						jr z, .spfrsame 
23a5						.spnosame: call showsperror 
23a5						.spfrsame: nop 
23a5						exx 
23a5					endif 
23a5				endif 
23a5			endm 
# End of macro STACKFRAMECHK
23a5			 
23a5 c9			ret    ; dont process any remaining parser tokens as they form new word 
23a6			 
23a6			 
23a6			 
23a6			 
23a6			;		NEXT 
23a6			.SCOLN: 
23a6			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
23a6 06			db OPCODE_SCOLN 
23a7 f2 23		dw .DROP 
23a9 02			db 2 
23aa .. 00		db ";",0           
23ac			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
23ac				if DEBUG_FORTH_WORDS_KEY 
23ac					DMARK "SCN" 
23ac f5				push af  
23ad 3a c1 23			ld a, (.dmark)  
23b0 32 65 ee			ld (debug_mark),a  
23b3 3a c2 23			ld a, (.dmark+1)  
23b6 32 66 ee			ld (debug_mark+1),a  
23b9 3a c3 23			ld a, (.dmark+2)  
23bc 32 67 ee			ld (debug_mark+2),a  
23bf 18 03			jr .pastdmark  
23c1 ..			.dmark: db "SCN"  
23c4 f1			.pastdmark: pop af  
23c5			endm  
# End of macro DMARK
23c5					CALLMONITOR 
23c5 cd 6f ee			call debug_vector  
23c8				endm  
# End of macro CALLMONITOR
23c8				endif 
23c8				FORTH_RSP_TOS 
23c8 cd 4e 1b			call macro_forth_rsp_tos 
23cb				endm 
# End of macro FORTH_RSP_TOS
23cb e5				push hl 
23cc				FORTH_RSP_POP 
23cc cd 58 1b			call macro_forth_rsp_pop 
23cf				endm 
# End of macro FORTH_RSP_POP
23cf e1				pop hl 
23d0			;		ex de,hl 
23d0 22 bc e5			ld (os_tok_ptr),hl 
23d3			 
23d3			if DEBUG_FORTH_UWORD 
23d3					DMARK "SCL" 
23d3 f5				push af  
23d4 3a e8 23			ld a, (.dmark)  
23d7 32 65 ee			ld (debug_mark),a  
23da 3a e9 23			ld a, (.dmark+1)  
23dd 32 66 ee			ld (debug_mark+1),a  
23e0 3a ea 23			ld a, (.dmark+2)  
23e3 32 67 ee			ld (debug_mark+2),a  
23e6 18 03			jr .pastdmark  
23e8 ..			.dmark: db "SCL"  
23eb f1			.pastdmark: pop af  
23ec			endm  
# End of macro DMARK
23ec			CALLMONITOR 
23ec cd 6f ee			call debug_vector  
23ef				endm  
# End of macro CALLMONITOR
23ef			endif 
23ef				NEXTW 
23ef c3 81 1f			jp macro_next 
23f2				endm 
# End of macro NEXTW
23f2			 
23f2			.DROP: 
23f2			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
23f2 1b				db WORD_SYS_CORE+OPCODE_DROP             
23f3 1d 24			dw .DUP2            
23f5 05				db 4 + 1 
23f6 .. 00			db "DROP",0              
23fb				endm 
# End of macro CWHEAD
23fb			; | DROP ( w -- )   drop the TOS item   | DONE 
23fb				if DEBUG_FORTH_WORDS_KEY 
23fb					DMARK "DRP" 
23fb f5				push af  
23fc 3a 10 24			ld a, (.dmark)  
23ff 32 65 ee			ld (debug_mark),a  
2402 3a 11 24			ld a, (.dmark+1)  
2405 32 66 ee			ld (debug_mark+1),a  
2408 3a 12 24			ld a, (.dmark+2)  
240b 32 67 ee			ld (debug_mark+2),a  
240e 18 03			jr .pastdmark  
2410 ..			.dmark: db "DRP"  
2413 f1			.pastdmark: pop af  
2414			endm  
# End of macro DMARK
2414					CALLMONITOR 
2414 cd 6f ee			call debug_vector  
2417				endm  
# End of macro CALLMONITOR
2417				endif 
2417				FORTH_DSP_POP 
2417 cd 4d 1e			call macro_forth_dsp_pop 
241a				endm 
# End of macro FORTH_DSP_POP
241a				NEXTW 
241a c3 81 1f			jp macro_next 
241d				endm 
# End of macro NEXTW
241d			.DUP2: 
241d			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
241d 1c				db WORD_SYS_CORE+OPCODE_DUP2             
241e 62 24			dw .DROP2            
2420 05				db 4 + 1 
2421 .. 00			db "2DUP",0              
2426				endm 
# End of macro CWHEAD
2426			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
2426				if DEBUG_FORTH_WORDS_KEY 
2426					DMARK "2DU" 
2426 f5				push af  
2427 3a 3b 24			ld a, (.dmark)  
242a 32 65 ee			ld (debug_mark),a  
242d 3a 3c 24			ld a, (.dmark+1)  
2430 32 66 ee			ld (debug_mark+1),a  
2433 3a 3d 24			ld a, (.dmark+2)  
2436 32 67 ee			ld (debug_mark+2),a  
2439 18 03			jr .pastdmark  
243b ..			.dmark: db "2DU"  
243e f1			.pastdmark: pop af  
243f			endm  
# End of macro DMARK
243f					CALLMONITOR 
243f cd 6f ee			call debug_vector  
2442				endm  
# End of macro CALLMONITOR
2442				endif 
2442				FORTH_DSP_VALUEHL 
2442 cd 95 1d			call macro_dsp_valuehl 
2445				endm 
# End of macro FORTH_DSP_VALUEHL
2445 e5				push hl      ; 2 
2446			 
2446				FORTH_DSP_POP 
2446 cd 4d 1e			call macro_forth_dsp_pop 
2449				endm 
# End of macro FORTH_DSP_POP
2449				 
2449				FORTH_DSP_VALUEHL 
2449 cd 95 1d			call macro_dsp_valuehl 
244c				endm 
# End of macro FORTH_DSP_VALUEHL
244c			;		push hl      ; 1 
244c			 
244c				FORTH_DSP_POP 
244c cd 4d 1e			call macro_forth_dsp_pop 
244f				endm 
# End of macro FORTH_DSP_POP
244f			 
244f			;		pop hl       ; 1 
244f d1				pop de       ; 2 
2450			 
2450 cd 90 1b			call forth_push_numhl 
2453 eb				ex de, hl 
2454 cd 90 1b			call forth_push_numhl 
2457			 
2457				 
2457 eb				ex de, hl 
2458			 
2458 cd 90 1b			call forth_push_numhl 
245b eb				ex de, hl 
245c cd 90 1b			call forth_push_numhl 
245f			 
245f			 
245f				NEXTW 
245f c3 81 1f			jp macro_next 
2462				endm 
# End of macro NEXTW
2462			.DROP2: 
2462			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2462 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2463 91 24			dw .PICK            
2465 06				db 5 + 1 
2466 .. 00			db "2DROP",0              
246c				endm 
# End of macro CWHEAD
246c			; | 2DROP ( w w -- )    Double drop | DONE 
246c				if DEBUG_FORTH_WORDS_KEY 
246c					DMARK "2DR" 
246c f5				push af  
246d 3a 81 24			ld a, (.dmark)  
2470 32 65 ee			ld (debug_mark),a  
2473 3a 82 24			ld a, (.dmark+1)  
2476 32 66 ee			ld (debug_mark+1),a  
2479 3a 83 24			ld a, (.dmark+2)  
247c 32 67 ee			ld (debug_mark+2),a  
247f 18 03			jr .pastdmark  
2481 ..			.dmark: db "2DR"  
2484 f1			.pastdmark: pop af  
2485			endm  
# End of macro DMARK
2485					CALLMONITOR 
2485 cd 6f ee			call debug_vector  
2488				endm  
# End of macro CALLMONITOR
2488				endif 
2488				FORTH_DSP_POP 
2488 cd 4d 1e			call macro_forth_dsp_pop 
248b				endm 
# End of macro FORTH_DSP_POP
248b				FORTH_DSP_POP 
248b cd 4d 1e			call macro_forth_dsp_pop 
248e				endm 
# End of macro FORTH_DSP_POP
248e				NEXTW 
248e c3 81 1f			jp macro_next 
2491				endm 
# End of macro NEXTW
2491			.PICK: 
2491			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
2491 77				db WORD_SYS_CORE+99             
2492 cf 24			dw .SWAP2            
2494 05				db 4 + 1 
2495 .. 00			db "PICK",0              
249a				endm 
# End of macro CWHEAD
249a			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | TODO 
249a				if DEBUG_FORTH_WORDS_KEY 
249a					DMARK "PIK" 
249a f5				push af  
249b 3a af 24			ld a, (.dmark)  
249e 32 65 ee			ld (debug_mark),a  
24a1 3a b0 24			ld a, (.dmark+1)  
24a4 32 66 ee			ld (debug_mark+1),a  
24a7 3a b1 24			ld a, (.dmark+2)  
24aa 32 67 ee			ld (debug_mark+2),a  
24ad 18 03			jr .pastdmark  
24af ..			.dmark: db "PIK"  
24b2 f1			.pastdmark: pop af  
24b3			endm  
# End of macro DMARK
24b3					CALLMONITOR 
24b3 cd 6f ee			call debug_vector  
24b6				endm  
# End of macro CALLMONITOR
24b6				endif 
24b6			 
24b6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24b6 cd 95 1d			call macro_dsp_valuehl 
24b9				endm 
# End of macro FORTH_DSP_VALUEHL
24b9				 
24b9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24b9 cd 4d 1e			call macro_forth_dsp_pop 
24bc				endm 
# End of macro FORTH_DSP_POP
24bc			 
24bc				; init from TOS 
24bc 45				ld b, l 
24bd 21 e8 e9			ld hl, cli_data_sp 
24c0			.pkl: 
24c0 2b				dec hl 
24c1 2b				dec hl 
24c2 2b				dec hl 
24c3			 
24c3 10 fb			djnz .pkl 
24c5			 
24c5				 
24c5				; TODO do type check with correct push 
24c5			 
24c5 23				inc hl 
24c6 cd 03 1f			call loadwordinhl 
24c9 cd 90 1b			call forth_push_numhl 
24cc			 
24cc				NEXTW 
24cc c3 81 1f			jp macro_next 
24cf				endm 
# End of macro NEXTW
24cf			.SWAP2: 
24cf			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24cf 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24d0 f8 24			dw .AT            
24d2 06				db 5 + 1 
24d3 .. 00			db "2SWAP",0              
24d9				endm 
# End of macro CWHEAD
24d9			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
24d9				if DEBUG_FORTH_WORDS_KEY 
24d9					DMARK "2SW" 
24d9 f5				push af  
24da 3a ee 24			ld a, (.dmark)  
24dd 32 65 ee			ld (debug_mark),a  
24e0 3a ef 24			ld a, (.dmark+1)  
24e3 32 66 ee			ld (debug_mark+1),a  
24e6 3a f0 24			ld a, (.dmark+2)  
24e9 32 67 ee			ld (debug_mark+2),a  
24ec 18 03			jr .pastdmark  
24ee ..			.dmark: db "2SW"  
24f1 f1			.pastdmark: pop af  
24f2			endm  
# End of macro DMARK
24f2					CALLMONITOR 
24f2 cd 6f ee			call debug_vector  
24f5				endm  
# End of macro CALLMONITOR
24f5				endif 
24f5			; TODO Use os stack swap memory 
24f5				NEXTW 
24f5 c3 81 1f			jp macro_next 
24f8				endm 
# End of macro NEXTW
24f8			.AT: 
24f8			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
24f8 1f				db WORD_SYS_CORE+OPCODE_AT             
24f9 2a 25			dw .CAT            
24fb 02				db 1 + 1 
24fc .. 00			db "@",0              
24fe				endm 
# End of macro CWHEAD
24fe			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
24fe			 
24fe				if DEBUG_FORTH_WORDS_KEY 
24fe					DMARK "AT." 
24fe f5				push af  
24ff 3a 13 25			ld a, (.dmark)  
2502 32 65 ee			ld (debug_mark),a  
2505 3a 14 25			ld a, (.dmark+1)  
2508 32 66 ee			ld (debug_mark+1),a  
250b 3a 15 25			ld a, (.dmark+2)  
250e 32 67 ee			ld (debug_mark+2),a  
2511 18 03			jr .pastdmark  
2513 ..			.dmark: db "AT."  
2516 f1			.pastdmark: pop af  
2517			endm  
# End of macro DMARK
2517					CALLMONITOR 
2517 cd 6f ee			call debug_vector  
251a				endm  
# End of macro CALLMONITOR
251a				endif 
251a			.getbyteat:	 
251a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
251a cd 95 1d			call macro_dsp_valuehl 
251d				endm 
# End of macro FORTH_DSP_VALUEHL
251d				 
251d			;		push hl 
251d			 
251d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
251d cd 4d 1e			call macro_forth_dsp_pop 
2520				endm 
# End of macro FORTH_DSP_POP
2520			 
2520			;		pop hl 
2520			 
2520 7e				ld a, (hl) 
2521			 
2521 6f				ld l, a 
2522 26 00			ld h, 0 
2524 cd 90 1b			call forth_push_numhl 
2527			 
2527				NEXTW 
2527 c3 81 1f			jp macro_next 
252a				endm 
# End of macro NEXTW
252a			.CAT: 
252a			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
252a 20				db WORD_SYS_CORE+OPCODE_CAT             
252b 53 25			dw .BANG            
252d 03				db 2 + 1 
252e .. 00			db "C@",0              
2531				endm 
# End of macro CWHEAD
2531			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2531				if DEBUG_FORTH_WORDS_KEY 
2531					DMARK "CAA" 
2531 f5				push af  
2532 3a 46 25			ld a, (.dmark)  
2535 32 65 ee			ld (debug_mark),a  
2538 3a 47 25			ld a, (.dmark+1)  
253b 32 66 ee			ld (debug_mark+1),a  
253e 3a 48 25			ld a, (.dmark+2)  
2541 32 67 ee			ld (debug_mark+2),a  
2544 18 03			jr .pastdmark  
2546 ..			.dmark: db "CAA"  
2549 f1			.pastdmark: pop af  
254a			endm  
# End of macro DMARK
254a					CALLMONITOR 
254a cd 6f ee			call debug_vector  
254d				endm  
# End of macro CALLMONITOR
254d				endif 
254d c3 1a 25			jp .getbyteat 
2550				NEXTW 
2550 c3 81 1f			jp macro_next 
2553				endm 
# End of macro NEXTW
2553			.BANG: 
2553			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2553 21				db WORD_SYS_CORE+OPCODE_BANG             
2554 89 25			dw .CBANG            
2556 02				db 1 + 1 
2557 .. 00			db "!",0              
2559				endm 
# End of macro CWHEAD
2559			; | ! ( x w -- ) Store x at address w      | DONE 
2559				if DEBUG_FORTH_WORDS_KEY 
2559					DMARK "BNG" 
2559 f5				push af  
255a 3a 6e 25			ld a, (.dmark)  
255d 32 65 ee			ld (debug_mark),a  
2560 3a 6f 25			ld a, (.dmark+1)  
2563 32 66 ee			ld (debug_mark+1),a  
2566 3a 70 25			ld a, (.dmark+2)  
2569 32 67 ee			ld (debug_mark+2),a  
256c 18 03			jr .pastdmark  
256e ..			.dmark: db "BNG"  
2571 f1			.pastdmark: pop af  
2572			endm  
# End of macro DMARK
2572					CALLMONITOR 
2572 cd 6f ee			call debug_vector  
2575				endm  
# End of macro CALLMONITOR
2575				endif 
2575			 
2575			.storebyteat:		 
2575				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2575 cd 95 1d			call macro_dsp_valuehl 
2578				endm 
# End of macro FORTH_DSP_VALUEHL
2578				 
2578 e5				push hl 
2579			 
2579				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2579 cd 4d 1e			call macro_forth_dsp_pop 
257c				endm 
# End of macro FORTH_DSP_POP
257c			 
257c				; get byte to poke 
257c			 
257c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
257c cd 95 1d			call macro_dsp_valuehl 
257f				endm 
# End of macro FORTH_DSP_VALUEHL
257f e5				push hl 
2580			 
2580			 
2580				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2580 cd 4d 1e			call macro_forth_dsp_pop 
2583				endm 
# End of macro FORTH_DSP_POP
2583			 
2583			 
2583 d1				pop de 
2584 e1				pop hl 
2585			 
2585 73				ld (hl),e 
2586			 
2586			 
2586				NEXTW 
2586 c3 81 1f			jp macro_next 
2589				endm 
# End of macro NEXTW
2589			.CBANG: 
2589			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2589 22				db WORD_SYS_CORE+OPCODE_CBANG             
258a b2 25			dw .SCALL            
258c 03				db 2 + 1 
258d .. 00			db "C!",0              
2590				endm 
# End of macro CWHEAD
2590			; | C!  ( x w -- ) Store x at address w  | DONE 
2590				if DEBUG_FORTH_WORDS_KEY 
2590					DMARK "CBA" 
2590 f5				push af  
2591 3a a5 25			ld a, (.dmark)  
2594 32 65 ee			ld (debug_mark),a  
2597 3a a6 25			ld a, (.dmark+1)  
259a 32 66 ee			ld (debug_mark+1),a  
259d 3a a7 25			ld a, (.dmark+2)  
25a0 32 67 ee			ld (debug_mark+2),a  
25a3 18 03			jr .pastdmark  
25a5 ..			.dmark: db "CBA"  
25a8 f1			.pastdmark: pop af  
25a9			endm  
# End of macro DMARK
25a9					CALLMONITOR 
25a9 cd 6f ee			call debug_vector  
25ac				endm  
# End of macro CALLMONITOR
25ac				endif 
25ac c3 75 25			jp .storebyteat 
25af				NEXTW 
25af c3 81 1f			jp macro_next 
25b2				endm 
# End of macro NEXTW
25b2			.SCALL: 
25b2			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25b2 23				db WORD_SYS_CORE+OPCODE_SCALL             
25b3 e6 25			dw .DEPTH            
25b5 05				db 4 + 1 
25b6 .. 00			db "CALL",0              
25bb				endm 
# End of macro CWHEAD
25bb			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25bb				if DEBUG_FORTH_WORDS_KEY 
25bb					DMARK "CLL" 
25bb f5				push af  
25bc 3a d0 25			ld a, (.dmark)  
25bf 32 65 ee			ld (debug_mark),a  
25c2 3a d1 25			ld a, (.dmark+1)  
25c5 32 66 ee			ld (debug_mark+1),a  
25c8 3a d2 25			ld a, (.dmark+2)  
25cb 32 67 ee			ld (debug_mark+2),a  
25ce 18 03			jr .pastdmark  
25d0 ..			.dmark: db "CLL"  
25d3 f1			.pastdmark: pop af  
25d4			endm  
# End of macro DMARK
25d4					CALLMONITOR 
25d4 cd 6f ee			call debug_vector  
25d7				endm  
# End of macro CALLMONITOR
25d7				endif 
25d7			 
25d7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25d7 cd 95 1d			call macro_dsp_valuehl 
25da				endm 
# End of macro FORTH_DSP_VALUEHL
25da			 
25da			;		push hl 
25da			 
25da				; destroy value TOS 
25da			 
25da				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25da cd 4d 1e			call macro_forth_dsp_pop 
25dd				endm 
# End of macro FORTH_DSP_POP
25dd			 
25dd					 
25dd			;		pop hl 
25dd			 
25dd				; how to do a call with hl???? save SP? 
25dd cd 25 1f			call forth_call_hl 
25e0			 
25e0			 
25e0				; TODO push value back onto stack for another op etc 
25e0			 
25e0 cd 90 1b			call forth_push_numhl 
25e3				NEXTW 
25e3 c3 81 1f			jp macro_next 
25e6				endm 
# End of macro NEXTW
25e6			.DEPTH: 
25e6			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
25e6 24				db WORD_SYS_CORE+OPCODE_DEPTH             
25e7 23 26			dw .OVER            
25e9 06				db 5 + 1 
25ea .. 00			db "DEPTH",0              
25f0				endm 
# End of macro CWHEAD
25f0			; | DEPTH ( -- u ) Push count of stack | DONE 
25f0				; take current TOS and remove from base value div by two to get count 
25f0				if DEBUG_FORTH_WORDS_KEY 
25f0					DMARK "DEP" 
25f0 f5				push af  
25f1 3a 05 26			ld a, (.dmark)  
25f4 32 65 ee			ld (debug_mark),a  
25f7 3a 06 26			ld a, (.dmark+1)  
25fa 32 66 ee			ld (debug_mark+1),a  
25fd 3a 07 26			ld a, (.dmark+2)  
2600 32 67 ee			ld (debug_mark+2),a  
2603 18 03			jr .pastdmark  
2605 ..			.dmark: db "DEP"  
2608 f1			.pastdmark: pop af  
2609			endm  
# End of macro DMARK
2609					CALLMONITOR 
2609 cd 6f ee			call debug_vector  
260c				endm  
# End of macro CALLMONITOR
260c				endif 
260c			 
260c			 
260c 2a e8 e9		ld hl, (cli_data_sp) 
260f 11 22 e8		ld de, cli_data_stack 
2612 ed 52		sbc hl,de 
2614			 
2614			; div by size of stack item 
2614			 
2614 5d			ld e,l 
2615 0e 03		ld c, 3 
2617 cd 85 0d		call Div8 
261a			 
261a 6f			ld l,a 
261b 26 00		ld h,0 
261d			 
261d			;srl h 
261d			;rr l 
261d			 
261d cd 90 1b			call forth_push_numhl 
2620				NEXTW 
2620 c3 81 1f			jp macro_next 
2623				endm 
# End of macro NEXTW
2623			.OVER: 
2623			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2623 42				db WORD_SYS_CORE+46             
2624 6a 26			dw .PAUSE            
2626 05				db 4 + 1 
2627 .. 00			db "OVER",0              
262c				endm 
# End of macro CWHEAD
262c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | TOFIX 
262c				if DEBUG_FORTH_WORDS_KEY 
262c					DMARK "OVR" 
262c f5				push af  
262d 3a 41 26			ld a, (.dmark)  
2630 32 65 ee			ld (debug_mark),a  
2633 3a 42 26			ld a, (.dmark+1)  
2636 32 66 ee			ld (debug_mark+1),a  
2639 3a 43 26			ld a, (.dmark+2)  
263c 32 67 ee			ld (debug_mark+2),a  
263f 18 03			jr .pastdmark  
2641 ..			.dmark: db "OVR"  
2644 f1			.pastdmark: pop af  
2645			endm  
# End of macro DMARK
2645					CALLMONITOR 
2645 cd 6f ee			call debug_vector  
2648				endm  
# End of macro CALLMONITOR
2648				endif 
2648			 
2648			; TODO Use os stack swap memory 
2648			 
2648				; work out what type we are looking at 
2648			 
2648				FORTH_DSP_PTR 1 
2648 2a e8 e9			ld hl,(cli_data_sp) 
264b 11 03 00			ld de, 1 * 3 
264e ed 52			sbc hl, de 
2650				endm 
# End of macro FORTH_DSP_PTR
2650			 
2650 7e				ld a, (hl) 
2651				 
2651 f5				push af 
2652				; whatever the type lets get the pointer or word 
2652 23				inc hl 
2653			;; 
2653			 
2653				; type check now to decide on how to push  
2653			 
2653 cd 03 1f			call loadwordinhl 
2656 f1				pop af 
2657 fe 01			cp DS_TYPE_STR 
2659 28 06			jr z, .ovstr 
265b			 
265b				; we have a numeric so load the word and push 
265b			;	ld e, (hl) 
265b			;	inc hl 
265b			;	ld d, (hl) 
265b			;	ex de, hl 
265b cd 90 1b			call forth_push_numhl 
265e				NEXTW 
265e c3 81 1f			jp macro_next 
2661				endm 
# End of macro NEXTW
2661			 
2661			.ovstr: 
2661				; ok, a string so get the pointer and push as a string 
2661			 
2661			;	call loadwordinhl 
2661 cd fe 1b			call forth_push_str 
2664				NEXTW 
2664 c3 81 1f			jp macro_next 
2667				endm 
# End of macro NEXTW
2667			 
2667			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2667			;	push hl    ; n2 
2667			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2667			; 
2667			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2667			;	push hl    ; n1 
2667			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2667			; 
2667			;	pop de     ; n1 
2667			;	pop hl     ; n2 
2667			; 
2667			;	push de 
2667			;	push hl 
2667			;	push de 
2667			 
2667				; push back  
2667			 
2667			;	pop hl 
2667			;	call forth_push_numhl 
2667			;	pop hl 
2667			;	call forth_push_numhl 
2667			;	pop hl 
2667			;	call forth_push_numhl 
2667				NEXTW 
2667 c3 81 1f			jp macro_next 
266a				endm 
# End of macro NEXTW
266a			 
266a			.PAUSE: 
266a			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
266a 43				db WORD_SYS_CORE+47             
266b 9f 26			dw .PAUSES            
266d 08				db 7 + 1 
266e .. 00			db "PAUSEMS",0              
2676				endm 
# End of macro CWHEAD
2676			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2676				if DEBUG_FORTH_WORDS_KEY 
2676					DMARK "PMS" 
2676 f5				push af  
2677 3a 8b 26			ld a, (.dmark)  
267a 32 65 ee			ld (debug_mark),a  
267d 3a 8c 26			ld a, (.dmark+1)  
2680 32 66 ee			ld (debug_mark+1),a  
2683 3a 8d 26			ld a, (.dmark+2)  
2686 32 67 ee			ld (debug_mark+2),a  
2689 18 03			jr .pastdmark  
268b ..			.dmark: db "PMS"  
268e f1			.pastdmark: pop af  
268f			endm  
# End of macro DMARK
268f					CALLMONITOR 
268f cd 6f ee			call debug_vector  
2692				endm  
# End of macro CALLMONITOR
2692				endif 
2692				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2692 cd 95 1d			call macro_dsp_valuehl 
2695				endm 
# End of macro FORTH_DSP_VALUEHL
2695			;		push hl    ; n2 
2695				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2695 cd 4d 1e			call macro_forth_dsp_pop 
2698				endm 
# End of macro FORTH_DSP_POP
2698			;		pop hl 
2698			 
2698 7d				ld a, l 
2699 cd e5 0a			call aDelayInMS 
269c			       NEXTW 
269c c3 81 1f			jp macro_next 
269f				endm 
# End of macro NEXTW
269f			.PAUSES:  
269f			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
269f 44				db WORD_SYS_CORE+48             
26a0 0e 27			dw .ROT            
26a2 06				db 5 + 1 
26a3 .. 00			db "PAUSE",0              
26a9				endm 
# End of macro CWHEAD
26a9			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26a9				if DEBUG_FORTH_WORDS_KEY 
26a9					DMARK "PAU" 
26a9 f5				push af  
26aa 3a be 26			ld a, (.dmark)  
26ad 32 65 ee			ld (debug_mark),a  
26b0 3a bf 26			ld a, (.dmark+1)  
26b3 32 66 ee			ld (debug_mark+1),a  
26b6 3a c0 26			ld a, (.dmark+2)  
26b9 32 67 ee			ld (debug_mark+2),a  
26bc 18 03			jr .pastdmark  
26be ..			.dmark: db "PAU"  
26c1 f1			.pastdmark: pop af  
26c2			endm  
# End of macro DMARK
26c2					CALLMONITOR 
26c2 cd 6f ee			call debug_vector  
26c5				endm  
# End of macro CALLMONITOR
26c5				endif 
26c5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c5 cd 95 1d			call macro_dsp_valuehl 
26c8				endm 
# End of macro FORTH_DSP_VALUEHL
26c8			;		push hl    ; n2 
26c8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c8 cd 4d 1e			call macro_forth_dsp_pop 
26cb				endm 
# End of macro FORTH_DSP_POP
26cb			;		pop hl 
26cb 45				ld b, l 
26cc				if DEBUG_FORTH_WORDS 
26cc					DMARK "PAU" 
26cc f5				push af  
26cd 3a e1 26			ld a, (.dmark)  
26d0 32 65 ee			ld (debug_mark),a  
26d3 3a e2 26			ld a, (.dmark+1)  
26d6 32 66 ee			ld (debug_mark+1),a  
26d9 3a e3 26			ld a, (.dmark+2)  
26dc 32 67 ee			ld (debug_mark+2),a  
26df 18 03			jr .pastdmark  
26e1 ..			.dmark: db "PAU"  
26e4 f1			.pastdmark: pop af  
26e5			endm  
# End of macro DMARK
26e5					CALLMONITOR 
26e5 cd 6f ee			call debug_vector  
26e8				endm  
# End of macro CALLMONITOR
26e8				endif 
26e8 c5			.pauses1:	push bc 
26e9 cd 00 0b			call delay1s 
26ec c1				pop bc 
26ed				if DEBUG_FORTH_WORDS 
26ed					DMARK "PA1" 
26ed f5				push af  
26ee 3a 02 27			ld a, (.dmark)  
26f1 32 65 ee			ld (debug_mark),a  
26f4 3a 03 27			ld a, (.dmark+1)  
26f7 32 66 ee			ld (debug_mark+1),a  
26fa 3a 04 27			ld a, (.dmark+2)  
26fd 32 67 ee			ld (debug_mark+2),a  
2700 18 03			jr .pastdmark  
2702 ..			.dmark: db "PA1"  
2705 f1			.pastdmark: pop af  
2706			endm  
# End of macro DMARK
2706					CALLMONITOR 
2706 cd 6f ee			call debug_vector  
2709				endm  
# End of macro CALLMONITOR
2709				endif 
2709 10 dd			djnz .pauses1 
270b			 
270b			       NEXTW 
270b c3 81 1f			jp macro_next 
270e				endm 
# End of macro NEXTW
270e			.ROT: 
270e			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
270e 45				db WORD_SYS_CORE+49             
270f 77 27			dw .UWORDS            
2711 04				db 3 + 1 
2712 .. 00			db "ROT",0              
2716				endm 
# End of macro CWHEAD
2716			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | TOFIX 
2716				if DEBUG_FORTH_WORDS_KEY 
2716					DMARK "ROT" 
2716 f5				push af  
2717 3a 2b 27			ld a, (.dmark)  
271a 32 65 ee			ld (debug_mark),a  
271d 3a 2c 27			ld a, (.dmark+1)  
2720 32 66 ee			ld (debug_mark+1),a  
2723 3a 2d 27			ld a, (.dmark+2)  
2726 32 67 ee			ld (debug_mark+2),a  
2729 18 03			jr .pastdmark  
272b ..			.dmark: db "ROT"  
272e f1			.pastdmark: pop af  
272f			endm  
# End of macro DMARK
272f					CALLMONITOR 
272f cd 6f ee			call debug_vector  
2732				endm  
# End of macro CALLMONITOR
2732				endif 
2732			 
2732			; DONE Use os stack swap memory 
2732			 
2732				FORTH_DSP_PTR 0     ; u3 
2732 2a e8 e9			ld hl,(cli_data_sp) 
2735 11 00 00			ld de, 0 * 3 
2738 ed 52			sbc hl, de 
273a				endm 
# End of macro FORTH_DSP_PTR
273a cd cd 1e			call hltostack1     
273d			  
273d				FORTH_DSP_PTR 1     ; u2 
273d 2a e8 e9			ld hl,(cli_data_sp) 
2740 11 03 00			ld de, 1 * 3 
2743 ed 52			sbc hl, de 
2745				endm 
# End of macro FORTH_DSP_PTR
2745 cd d3 1e			call hltostack2      
2748			 
2748				FORTH_DSP_PTR 2     ; u1 
2748 2a e8 e9			ld hl,(cli_data_sp) 
274b 11 06 00			ld de, 2 * 3 
274e ed 52			sbc hl, de 
2750				endm 
# End of macro FORTH_DSP_PTR
2750 cd d9 1e			call hltostack3 
2753			 
2753			 
2753				FORTH_DSP_PTR 0     ;  
2753 2a e8 e9			ld hl,(cli_data_sp) 
2756 11 00 00			ld de, 0 * 3 
2759 ed 52			sbc hl, de 
275b				endm 
# End of macro FORTH_DSP_PTR
275b cd f1 1e			call hlfromstack3 
275e			 
275e				FORTH_DSP_PTR 1     ; TOS 
275e 2a e8 e9			ld hl,(cli_data_sp) 
2761 11 03 00			ld de, 1 * 3 
2764 ed 52			sbc hl, de 
2766				endm 
# End of macro FORTH_DSP_PTR
2766 cd e5 1e			call hlfromstack1 
2769			 
2769				FORTH_DSP_PTR 2     ; TOS 
2769 2a e8 e9			ld hl,(cli_data_sp) 
276c 11 06 00			ld de, 2 * 3 
276f ed 52			sbc hl, de 
2771				endm 
# End of macro FORTH_DSP_PTR
2771 cd eb 1e			call hlfromstack2 
2774			 
2774			 
2774			;	FORTH_DSP_VALUEHL 
2774			;	push hl    ; u3  
2774			; 
2774			;	FORTH_DSP_POP 
2774			; 
2774			;	FORTH_DSP_VALUEHL 
2774			;	push hl     ; u2 
2774			; 
2774			;	FORTH_DSP_POP 
2774			; 
2774			;	FORTH_DSP_VALUEHL 
2774			;	push hl     ; u1 
2774			; 
2774			;	FORTH_DSP_POP 
2774			; 
2774			;	pop bc      ; u1 
2774			;	pop hl      ; u2 
2774			;	pop de      ; u3 
2774			; 
2774			; 
2774			;	push bc 
2774			;	push de 
2774			;	push hl 
2774			; 
2774			; 
2774			;	pop hl 
2774			;	call forth_push_numhl 
2774			; 
2774			;	pop hl 
2774			;	call forth_push_numhl 
2774			; 
2774			;	pop hl 
2774			;	call forth_push_numhl 
2774				 
2774			 
2774			 
2774			 
2774			 
2774			 
2774			       NEXTW 
2774 c3 81 1f			jp macro_next 
2777				endm 
# End of macro NEXTW
2777			 
2777			.UWORDS: 
2777			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2777 50				db WORD_SYS_CORE+60             
2778 39 28			dw .BP            
277a 07				db 6 + 1 
277b .. 00			db "UWORDS",0              
2782				endm 
# End of macro CWHEAD
2782			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2782			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2782			; | | Following the count are the individual words. 
2782			; | | 
2782			; | | e.g. UWORDS 
2782			; | | BOX DIRLIST 2 
2782			; | |  
2782			; | | Can be used to save the words to storage via: 
2782			; | | UWORDS $01 DO $01 APPEND LOOP 
2782			if DEBUG_FORTH_WORDS_KEY 
2782				DMARK "UWR" 
2782 f5				push af  
2783 3a 97 27			ld a, (.dmark)  
2786 32 65 ee			ld (debug_mark),a  
2789 3a 98 27			ld a, (.dmark+1)  
278c 32 66 ee			ld (debug_mark+1),a  
278f 3a 99 27			ld a, (.dmark+2)  
2792 32 67 ee			ld (debug_mark+2),a  
2795 18 03			jr .pastdmark  
2797 ..			.dmark: db "UWR"  
279a f1			.pastdmark: pop af  
279b			endm  
# End of macro DMARK
279b				CALLMONITOR 
279b cd 6f ee			call debug_vector  
279e				endm  
# End of macro CALLMONITOR
279e			endif 
279e 21 50 5f			ld hl, baseram 
27a1				;ld hl, baseusermem 
27a1 01 00 00			ld bc, 0    ; start a counter 
27a4			 
27a4			; skip dict stub 
27a4			 
27a4 cd d2 20			call forth_tok_next 
27a7			 
27a7			 
27a7			; while we have words to look for 
27a7			 
27a7 7e			.douscan:	ld a, (hl)      
27a8			if DEBUG_FORTH_WORDS 
27a8				DMARK "UWs" 
27a8 f5				push af  
27a9 3a bd 27			ld a, (.dmark)  
27ac 32 65 ee			ld (debug_mark),a  
27af 3a be 27			ld a, (.dmark+1)  
27b2 32 66 ee			ld (debug_mark+1),a  
27b5 3a bf 27			ld a, (.dmark+2)  
27b8 32 67 ee			ld (debug_mark+2),a  
27bb 18 03			jr .pastdmark  
27bd ..			.dmark: db "UWs"  
27c0 f1			.pastdmark: pop af  
27c1			endm  
# End of macro DMARK
27c1				CALLMONITOR 
27c1 cd 6f ee			call debug_vector  
27c4				endm  
# End of macro CALLMONITOR
27c4			endif 
27c4 fe 00			cp WORD_SYS_END 
27c6 28 4d			jr z, .udone 
27c8 fe 01			cp WORD_SYS_UWORD 
27ca 20 44			jr nz, .nuword 
27cc			 
27cc			if DEBUG_FORTH_WORDS 
27cc				DMARK "UWu" 
27cc f5				push af  
27cd 3a e1 27			ld a, (.dmark)  
27d0 32 65 ee			ld (debug_mark),a  
27d3 3a e2 27			ld a, (.dmark+1)  
27d6 32 66 ee			ld (debug_mark+1),a  
27d9 3a e3 27			ld a, (.dmark+2)  
27dc 32 67 ee			ld (debug_mark+2),a  
27df 18 03			jr .pastdmark  
27e1 ..			.dmark: db "UWu"  
27e4 f1			.pastdmark: pop af  
27e5			endm  
# End of macro DMARK
27e5				CALLMONITOR 
27e5 cd 6f ee			call debug_vector  
27e8				endm  
# End of macro CALLMONITOR
27e8			endif 
27e8				; we have a uword so push its name to the stack 
27e8			 
27e8 e5				push hl  ; save so we can move to next dict block 
27e9			 
27e9				; skip opcode 
27e9 23				inc hl  
27ea				; skip next ptr 
27ea 23				inc hl  
27eb 23				inc hl 
27ec				; skip len 
27ec 23				inc hl 
27ed			if DEBUG_FORTH_WORDS 
27ed				DMARK "UWt" 
27ed f5				push af  
27ee 3a 02 28			ld a, (.dmark)  
27f1 32 65 ee			ld (debug_mark),a  
27f4 3a 03 28			ld a, (.dmark+1)  
27f7 32 66 ee			ld (debug_mark+1),a  
27fa 3a 04 28			ld a, (.dmark+2)  
27fd 32 67 ee			ld (debug_mark+2),a  
2800 18 03			jr .pastdmark  
2802 ..			.dmark: db "UWt"  
2805 f1			.pastdmark: pop af  
2806			endm  
# End of macro DMARK
2806				CALLMONITOR 
2806 cd 6f ee			call debug_vector  
2809				endm  
# End of macro CALLMONITOR
2809			endif 
2809 03				inc bc 
280a			 
280a c5				push bc 
280b cd fe 1b			call forth_push_str 
280e c1				pop bc 
280f			 
280f e1				pop hl 	 
2810			 
2810 cd d2 20		.nuword:	call forth_tok_next 
2813 18 92			jr .douscan  
2815			 
2815			.udone:		 ; push count of uwords found 
2815 c5				push bc 
2816 e1				pop hl 
2817			 
2817			if DEBUG_FORTH_WORDS 
2817				DMARK "UWc" 
2817 f5				push af  
2818 3a 2c 28			ld a, (.dmark)  
281b 32 65 ee			ld (debug_mark),a  
281e 3a 2d 28			ld a, (.dmark+1)  
2821 32 66 ee			ld (debug_mark+1),a  
2824 3a 2e 28			ld a, (.dmark+2)  
2827 32 67 ee			ld (debug_mark+2),a  
282a 18 03			jr .pastdmark  
282c ..			.dmark: db "UWc"  
282f f1			.pastdmark: pop af  
2830			endm  
# End of macro DMARK
2830				CALLMONITOR 
2830 cd 6f ee			call debug_vector  
2833				endm  
# End of macro CALLMONITOR
2833			endif 
2833 cd 90 1b			call forth_push_numhl 
2836			 
2836			 
2836			       NEXTW 
2836 c3 81 1f			jp macro_next 
2839				endm 
# End of macro NEXTW
2839			 
2839			.BP: 
2839			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2839 54				db WORD_SYS_CORE+64             
283a 73 28			dw .MONITOR            
283c 03				db 2 + 1 
283d .. 00			db "BP",0              
2840				endm 
# End of macro CWHEAD
2840			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2840			; | | $00 Will enable the break points within specific code paths 
2840			; | | $01 Will disable break points 
2840			; | |  
2840			; | | By default break points are off. Either the above can be used to enable them 
2840			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2840			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2840			; | | can disable break points. Exiting will then continue boot process. 
2840				; get byte count 
2840				if DEBUG_FORTH_WORDS_KEY 
2840					DMARK "BP." 
2840 f5				push af  
2841 3a 55 28			ld a, (.dmark)  
2844 32 65 ee			ld (debug_mark),a  
2847 3a 56 28			ld a, (.dmark+1)  
284a 32 66 ee			ld (debug_mark+1),a  
284d 3a 57 28			ld a, (.dmark+2)  
2850 32 67 ee			ld (debug_mark+2),a  
2853 18 03			jr .pastdmark  
2855 ..			.dmark: db "BP."  
2858 f1			.pastdmark: pop af  
2859			endm  
# End of macro DMARK
2859					CALLMONITOR 
2859 cd 6f ee			call debug_vector  
285c				endm  
# End of macro CALLMONITOR
285c				endif 
285c			 
285c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
285c cd 95 1d			call macro_dsp_valuehl 
285f				endm 
# End of macro FORTH_DSP_VALUEHL
285f			 
285f			;		push hl 
285f			 
285f				; destroy value TOS 
285f			 
285f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
285f cd 4d 1e			call macro_forth_dsp_pop 
2862				endm 
# End of macro FORTH_DSP_POP
2862			 
2862			;		pop hl 
2862			 
2862 3e 00			ld a,0 
2864 bd				cp l 
2865 28 06			jr z, .bpset 
2867			;		ld a, '*' 
2867 cd 0b 15			call bp_off 
286a				NEXTW 
286a c3 81 1f			jp macro_next 
286d				endm 
# End of macro NEXTW
286d			 
286d			.bpset:	 
286d				;	ld (os_view_disable), a 
286d cd ff 14			call bp_on 
2870			 
2870			 
2870				NEXTW 
2870 c3 81 1f			jp macro_next 
2873				endm 
# End of macro NEXTW
2873			 
2873			 
2873			.MONITOR: 
2873			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2873 55				db WORD_SYS_CORE+65             
2874 a4 28			dw .MALLOC            
2876 08				db 7 + 1 
2877 .. 00			db "MONITOR",0              
287f				endm 
# End of macro CWHEAD
287f			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
287f			; | | At start the current various registers will be displayed with contents. 
287f			; | | Top right corner will show the most recent debug marker seen. 
287f			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
287f			; | | and the return stack pointer (RSP). 
287f			; | | Pressing: 
287f			; | |    1 - Initial screen 
287f			; | |    2 - Display a data dump of HL 
287f			; | |    3 - Display a data dump of DE 
287f			; | |    4 - Display a data dump of BC 
287f			; | |    5 - Display a data dump of HL 
287f			; | |    6 - Display a data dump of DSP 
287f			; | |    7 - Display a data dump of RSP 
287f			; | |    8 - Display a data dump of what is at DSP 
287f			; | |    9 - Display a data dump of what is at RSP 
287f			; | |    0 - Exit monitor and continue running. This will also enable break points 
287f			; | |    * - Disable break points 
287f			; | |    # - Enter traditional monitor mode 
287f			; | | 
287f			; | | Monitor Mode 
287f			; | | ------------ 
287f			; | | A prompt of '>' will be shown for various commands: 
287f			; | |    D xxxx - Display a data dump starting from hex address xxxx 
287f			; | |    C - Continue display a data dump from the last set address 
287f			; | |    M xxxx - Set start of memory edit at address xx 
287f			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
287f			; | |    G xxxx - Exec code at specific address 
287f			; | |    Q - Return to previous 
287f				if DEBUG_FORTH_WORDS_KEY 
287f					DMARK "MON" 
287f f5				push af  
2880 3a 94 28			ld a, (.dmark)  
2883 32 65 ee			ld (debug_mark),a  
2886 3a 95 28			ld a, (.dmark+1)  
2889 32 66 ee			ld (debug_mark+1),a  
288c 3a 96 28			ld a, (.dmark+2)  
288f 32 67 ee			ld (debug_mark+2),a  
2892 18 03			jr .pastdmark  
2894 ..			.dmark: db "MON"  
2897 f1			.pastdmark: pop af  
2898			endm  
# End of macro DMARK
2898					CALLMONITOR 
2898 cd 6f ee			call debug_vector  
289b				endm  
# End of macro CALLMONITOR
289b				endif 
289b			;		ld a, 0 
289b			;		ld (os_view_disable), a 
289b cd ff 14			call bp_on 
289e			 
289e				CALLMONITOR 
289e cd 6f ee			call debug_vector  
28a1				endm  
# End of macro CALLMONITOR
28a1			 
28a1			;	call monitor 
28a1			 
28a1				NEXTW 
28a1 c3 81 1f			jp macro_next 
28a4				endm 
# End of macro NEXTW
28a4			 
28a4			 
28a4			.MALLOC: 
28a4			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28a4 56				db WORD_SYS_CORE+66             
28a5 cd 28			dw .MALLOC2            
28a7 06				db 5 + 1 
28a8 .. 00			db "ALLOT",0              
28ae				endm 
# End of macro CWHEAD
28ae			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28ae				if DEBUG_FORTH_WORDS_KEY 
28ae					DMARK "ALL" 
28ae f5				push af  
28af 3a c3 28			ld a, (.dmark)  
28b2 32 65 ee			ld (debug_mark),a  
28b5 3a c4 28			ld a, (.dmark+1)  
28b8 32 66 ee			ld (debug_mark+1),a  
28bb 3a c5 28			ld a, (.dmark+2)  
28be 32 67 ee			ld (debug_mark+2),a  
28c1 18 03			jr .pastdmark  
28c3 ..			.dmark: db "ALL"  
28c6 f1			.pastdmark: pop af  
28c7			endm  
# End of macro DMARK
28c7					CALLMONITOR 
28c7 cd 6f ee			call debug_vector  
28ca				endm  
# End of macro CALLMONITOR
28ca				endif 
28ca c3 f4 28			jp .mallocc 
28cd			.MALLOC2: 
28cd			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28cd 56				db WORD_SYS_CORE+66             
28ce 0b 29			dw .FREE            
28d0 07				db 6 + 1 
28d1 .. 00			db "MALLOC",0              
28d8				endm 
# End of macro CWHEAD
28d8			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28d8				; get byte count 
28d8				if DEBUG_FORTH_WORDS_KEY 
28d8					DMARK "MAL" 
28d8 f5				push af  
28d9 3a ed 28			ld a, (.dmark)  
28dc 32 65 ee			ld (debug_mark),a  
28df 3a ee 28			ld a, (.dmark+1)  
28e2 32 66 ee			ld (debug_mark+1),a  
28e5 3a ef 28			ld a, (.dmark+2)  
28e8 32 67 ee			ld (debug_mark+2),a  
28eb 18 03			jr .pastdmark  
28ed ..			.dmark: db "MAL"  
28f0 f1			.pastdmark: pop af  
28f1			endm  
# End of macro DMARK
28f1					CALLMONITOR 
28f1 cd 6f ee			call debug_vector  
28f4				endm  
# End of macro CALLMONITOR
28f4				endif 
28f4			.mallocc: 
28f4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28f4 cd 95 1d			call macro_dsp_valuehl 
28f7				endm 
# End of macro FORTH_DSP_VALUEHL
28f7			 
28f7			;		push hl 
28f7			 
28f7				; destroy value TOS 
28f7			 
28f7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28f7 cd 4d 1e			call macro_forth_dsp_pop 
28fa				endm 
# End of macro FORTH_DSP_POP
28fa			 
28fa			;		pop hl 
28fa cd d0 11			call malloc 
28fd			if DEBUG_FORTH_MALLOC_GUARD 
28fd f5				push af 
28fe cd 1e 0e			call ishlzero 
2901			;		ld a, l 
2901			;		add h 
2901			;		cp 0 
2901 f1				pop af 
2902				 
2902 cc bb 4d			call z,malloc_error 
2905			endif 
2905			 
2905 cd 90 1b			call forth_push_numhl 
2908				NEXTW 
2908 c3 81 1f			jp macro_next 
290b				endm 
# End of macro NEXTW
290b			 
290b			.FREE: 
290b			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
290b 57				db WORD_SYS_CORE+67             
290c 3c 29			dw .LIST            
290e 05				db 4 + 1 
290f .. 00			db "FREE",0              
2914				endm 
# End of macro CWHEAD
2914			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2914				if DEBUG_FORTH_WORDS_KEY 
2914					DMARK "FRE" 
2914 f5				push af  
2915 3a 29 29			ld a, (.dmark)  
2918 32 65 ee			ld (debug_mark),a  
291b 3a 2a 29			ld a, (.dmark+1)  
291e 32 66 ee			ld (debug_mark+1),a  
2921 3a 2b 29			ld a, (.dmark+2)  
2924 32 67 ee			ld (debug_mark+2),a  
2927 18 03			jr .pastdmark  
2929 ..			.dmark: db "FRE"  
292c f1			.pastdmark: pop af  
292d			endm  
# End of macro DMARK
292d					CALLMONITOR 
292d cd 6f ee			call debug_vector  
2930				endm  
# End of macro CALLMONITOR
2930				endif 
2930				; get address 
2930			 
2930				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2930 cd 95 1d			call macro_dsp_valuehl 
2933				endm 
# End of macro FORTH_DSP_VALUEHL
2933			 
2933			;		push hl 
2933			 
2933				; destroy value TOS 
2933			 
2933				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2933 cd 4d 1e			call macro_forth_dsp_pop 
2936				endm 
# End of macro FORTH_DSP_POP
2936			 
2936			;		pop hl 
2936			if FORTH_ENABLE_MALLOCFREE 
2936 cd 9a 12			call free 
2939			endif 
2939				NEXTW 
2939 c3 81 1f			jp macro_next 
293c				endm 
# End of macro NEXTW
293c			.LIST: 
293c			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
293c 5c				db WORD_SYS_CORE+72             
293d 38 2b			dw .FORGET            
293f 05				db 4 + 1 
2940 .. 00			db "LIST",0              
2945				endm 
# End of macro CWHEAD
2945			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2945			; | | The quoted word must be in upper case. 
2945			if DEBUG_FORTH_WORDS_KEY 
2945				DMARK "LST" 
2945 f5				push af  
2946 3a 5a 29			ld a, (.dmark)  
2949 32 65 ee			ld (debug_mark),a  
294c 3a 5b 29			ld a, (.dmark+1)  
294f 32 66 ee			ld (debug_mark+1),a  
2952 3a 5c 29			ld a, (.dmark+2)  
2955 32 67 ee			ld (debug_mark+2),a  
2958 18 03			jr .pastdmark  
295a ..			.dmark: db "LST"  
295d f1			.pastdmark: pop af  
295e			endm  
# End of macro DMARK
295e				CALLMONITOR 
295e cd 6f ee			call debug_vector  
2961				endm  
# End of macro CALLMONITOR
2961			endif 
2961			 
2961				FORTH_DSP_VALUEHL 
2961 cd 95 1d			call macro_dsp_valuehl 
2964				endm 
# End of macro FORTH_DSP_VALUEHL
2964			 
2964 e5				push hl 
2965				FORTH_DSP_POP 
2965 cd 4d 1e			call macro_forth_dsp_pop 
2968				endm 
# End of macro FORTH_DSP_POP
2968 c1				pop bc 
2969			 
2969			; Start format of scratch string 
2969			 
2969 21 bb e2			ld hl, scratch 
296c			 
296c 3e 3a			ld a, ':' 
296e 77				ld (hl),a 
296f 23				inc hl 
2970 3e 20			ld a, ' ' 
2972 77				ld (hl), a 
2973			 
2973				; Get ptr to the word we need to look up 
2973			 
2973			;		FORTH_DSP_VALUEHL 
2973				;v5 FORTH_DSP_VALUE 
2973			; TODO type check 
2973			;		inc hl    ; Skip type check  
2973			;		push hl 
2973			;		ex de, hl    ; put into DE 
2973			 
2973			 
2973 21 50 5f			ld hl, baseram 
2976				;ld hl, baseusermem 
2976			 
2976 e5			push hl   ; sacreifical push 
2977			 
2977			.ldouscanm: 
2977 e1			pop hl 
2978			.ldouscan: 
2978			if DEBUG_FORTH_WORDS 
2978				DMARK "LSs" 
2978 f5				push af  
2979 3a 8d 29			ld a, (.dmark)  
297c 32 65 ee			ld (debug_mark),a  
297f 3a 8e 29			ld a, (.dmark+1)  
2982 32 66 ee			ld (debug_mark+1),a  
2985 3a 8f 29			ld a, (.dmark+2)  
2988 32 67 ee			ld (debug_mark+2),a  
298b 18 03			jr .pastdmark  
298d ..			.dmark: db "LSs"  
2990 f1			.pastdmark: pop af  
2991			endm  
# End of macro DMARK
2991				CALLMONITOR 
2991 cd 6f ee			call debug_vector  
2994				endm  
# End of macro CALLMONITOR
2994			endif 
2994			; skip dict stub 
2994 cd d2 20			call forth_tok_next 
2997			 
2997			 
2997			; while we have words to look for 
2997			 
2997 7e			ld a, (hl)      
2998			if DEBUG_FORTH_WORDS 
2998				DMARK "LSk" 
2998 f5				push af  
2999 3a ad 29			ld a, (.dmark)  
299c 32 65 ee			ld (debug_mark),a  
299f 3a ae 29			ld a, (.dmark+1)  
29a2 32 66 ee			ld (debug_mark+1),a  
29a5 3a af 29			ld a, (.dmark+2)  
29a8 32 67 ee			ld (debug_mark+2),a  
29ab 18 03			jr .pastdmark  
29ad ..			.dmark: db "LSk"  
29b0 f1			.pastdmark: pop af  
29b1			endm  
# End of macro DMARK
29b1				CALLMONITOR 
29b1 cd 6f ee			call debug_vector  
29b4				endm  
# End of macro CALLMONITOR
29b4			endif 
29b4				;cp WORD_SYS_END 
29b4				;jp z, .lunotfound 
29b4			 
29b4					; if we hit non uwords then gone too far 
29b4 fe 01				cp WORD_SYS_UWORD 
29b6 c2 f4 2a				jp nz, .lunotfound 
29b9			 
29b9				if DEBUG_FORTH_WORDS 
29b9					DMARK "LSu" 
29b9 f5				push af  
29ba 3a ce 29			ld a, (.dmark)  
29bd 32 65 ee			ld (debug_mark),a  
29c0 3a cf 29			ld a, (.dmark+1)  
29c3 32 66 ee			ld (debug_mark+1),a  
29c6 3a d0 29			ld a, (.dmark+2)  
29c9 32 67 ee			ld (debug_mark+2),a  
29cc 18 03			jr .pastdmark  
29ce ..			.dmark: db "LSu"  
29d1 f1			.pastdmark: pop af  
29d2			endm  
# End of macro DMARK
29d2					CALLMONITOR 
29d2 cd 6f ee			call debug_vector  
29d5				endm  
# End of macro CALLMONITOR
29d5				endif 
29d5			 
29d5					; found a uword but is it the one we want... 
29d5			 
29d5 c5					push bc     ; uword to find is on bc 
29d6 d1					pop de 
29d7			 
29d7 e5					push hl  ; to save the ptr 
29d8			 
29d8					; skip opcode 
29d8 23					inc hl  
29d9					; skip next ptr 
29d9 23					inc hl  
29da 23					inc hl 
29db					; skip len 
29db 23					inc hl 
29dc			 
29dc				if DEBUG_FORTH_WORDS 
29dc					DMARK "LSc" 
29dc f5				push af  
29dd 3a f1 29			ld a, (.dmark)  
29e0 32 65 ee			ld (debug_mark),a  
29e3 3a f2 29			ld a, (.dmark+1)  
29e6 32 66 ee			ld (debug_mark+1),a  
29e9 3a f3 29			ld a, (.dmark+2)  
29ec 32 67 ee			ld (debug_mark+2),a  
29ef 18 03			jr .pastdmark  
29f1 ..			.dmark: db "LSc"  
29f4 f1			.pastdmark: pop af  
29f5			endm  
# End of macro DMARK
29f5					CALLMONITOR 
29f5 cd 6f ee			call debug_vector  
29f8				endm  
# End of macro CALLMONITOR
29f8				endif 
29f8			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
29f8			; ie. If WOO is defined first and then WO. Couldnt list WO. 
29f8			; Nope that has gone the other way. It needs to be exact not on first zero 
29f8			;		call strcmp 
29f8 c5					push bc 
29f9 cd a0 11				call StrictStrCmp 
29fc c1					pop bc 
29fd c2 77 29				jp nz, .ldouscanm 
2a00				 
2a00			 
2a00			 
2a00					; we have a uword so push its name to the stack 
2a00			 
2a00			;	   	push hl  ; save so we can move to next dict block 
2a00 e1			pop hl 
2a01			 
2a01				if DEBUG_FORTH_WORDS 
2a01					DMARK "LSm" 
2a01 f5				push af  
2a02 3a 16 2a			ld a, (.dmark)  
2a05 32 65 ee			ld (debug_mark),a  
2a08 3a 17 2a			ld a, (.dmark+1)  
2a0b 32 66 ee			ld (debug_mark+1),a  
2a0e 3a 18 2a			ld a, (.dmark+2)  
2a11 32 67 ee			ld (debug_mark+2),a  
2a14 18 03			jr .pastdmark  
2a16 ..			.dmark: db "LSm"  
2a19 f1			.pastdmark: pop af  
2a1a			endm  
# End of macro DMARK
2a1a					CALLMONITOR 
2a1a cd 6f ee			call debug_vector  
2a1d				endm  
# End of macro CALLMONITOR
2a1d				endif 
2a1d			 
2a1d					; skip opcode 
2a1d 23					inc hl  
2a1e					; skip next ptr 
2a1e 23					inc hl  
2a1f 23					inc hl 
2a20					; skip len 
2a20 7e					ld a, (hl)   ; save length to add 
2a21				if DEBUG_FORTH_WORDS 
2a21					DMARK "LS2" 
2a21 f5				push af  
2a22 3a 36 2a			ld a, (.dmark)  
2a25 32 65 ee			ld (debug_mark),a  
2a28 3a 37 2a			ld a, (.dmark+1)  
2a2b 32 66 ee			ld (debug_mark+1),a  
2a2e 3a 38 2a			ld a, (.dmark+2)  
2a31 32 67 ee			ld (debug_mark+2),a  
2a34 18 03			jr .pastdmark  
2a36 ..			.dmark: db "LS2"  
2a39 f1			.pastdmark: pop af  
2a3a			endm  
# End of macro DMARK
2a3a					CALLMONITOR 
2a3a cd 6f ee			call debug_vector  
2a3d				endm  
# End of macro CALLMONITOR
2a3d				endif 
2a3d			 
2a3d					; save this location 
2a3d				 
2a3d e5					push hl 
2a3e			 
2a3e 23					inc hl 
2a3f 11 bd e2				ld de, scratch+2 
2a42 4f					ld c, a 
2a43 06 00				ld b, 0 
2a45			 
2a45				if DEBUG_FORTH_WORDS 
2a45					DMARK "LSn" 
2a45 f5				push af  
2a46 3a 5a 2a			ld a, (.dmark)  
2a49 32 65 ee			ld (debug_mark),a  
2a4c 3a 5b 2a			ld a, (.dmark+1)  
2a4f 32 66 ee			ld (debug_mark+1),a  
2a52 3a 5c 2a			ld a, (.dmark+2)  
2a55 32 67 ee			ld (debug_mark+2),a  
2a58 18 03			jr .pastdmark  
2a5a ..			.dmark: db "LSn"  
2a5d f1			.pastdmark: pop af  
2a5e			endm  
# End of macro DMARK
2a5e					CALLMONITOR 
2a5e cd 6f ee			call debug_vector  
2a61				endm  
# End of macro CALLMONITOR
2a61				endif 
2a61			 
2a61					; copy uword name to scratch 
2a61			 
2a61			;		ldir 
2a61			.licplw:	; copy uword name to scratch converting to lower case as we go 
2a61 ed a0				ldi 
2a63 1b					dec de 
2a64 1a					ld a, (de) 
2a65 cd 73 10				call to_lower 
2a68 12					ld (de),a 
2a69 13					inc de 
2a6a 3e 00				ld a, 0 
2a6c b9					cp c 
2a6d 20 f2				jr nz, .licplw 
2a6f			 
2a6f			 
2a6f			 
2a6f 1b					dec de 
2a70 3e 20				ld a, ' '    ; change null to space 
2a72 12					ld (de), a 
2a73			 
2a73 13					inc de 
2a74			 
2a74 d5					push de 
2a75 c1					pop bc     ; move scratch pointer to end of word name and save it 
2a76			 
2a76 e1					pop hl 
2a77 7e					ld a, (hl) 
2a78					;inc hl 
2a78					; skip word string 
2a78 cd f5 0d				call addatohl 
2a7b			 
2a7b 23					inc hl 
2a7c			 
2a7c				if DEBUG_FORTH_WORDS 
2a7c					DMARK "LS3" 
2a7c f5				push af  
2a7d 3a 91 2a			ld a, (.dmark)  
2a80 32 65 ee			ld (debug_mark),a  
2a83 3a 92 2a			ld a, (.dmark+1)  
2a86 32 66 ee			ld (debug_mark+1),a  
2a89 3a 93 2a			ld a, (.dmark+2)  
2a8c 32 67 ee			ld (debug_mark+2),a  
2a8f 18 03			jr .pastdmark  
2a91 ..			.dmark: db "LS3"  
2a94 f1			.pastdmark: pop af  
2a95			endm  
# End of macro DMARK
2a95					CALLMONITOR 
2a95 cd 6f ee			call debug_vector  
2a98				endm  
# End of macro CALLMONITOR
2a98				endif 
2a98					; should now be at the start of the machine code to setup the eval of the uword 
2a98					; now locate the ptr to the string defintion 
2a98			 
2a98					; skip ld hl, 
2a98					; then load the ptr 
2a98			; TODO use get from hl ptr 
2a98 23					inc hl 
2a99 5e					ld e, (hl) 
2a9a 23					inc hl 
2a9b 56					ld d, (hl) 
2a9c eb					ex de, hl 
2a9d			 
2a9d			 
2a9d				if DEBUG_FORTH_WORDS 
2a9d					DMARK "LSt" 
2a9d f5				push af  
2a9e 3a b2 2a			ld a, (.dmark)  
2aa1 32 65 ee			ld (debug_mark),a  
2aa4 3a b3 2a			ld a, (.dmark+1)  
2aa7 32 66 ee			ld (debug_mark+1),a  
2aaa 3a b4 2a			ld a, (.dmark+2)  
2aad 32 67 ee			ld (debug_mark+2),a  
2ab0 18 03			jr .pastdmark  
2ab2 ..			.dmark: db "LSt"  
2ab5 f1			.pastdmark: pop af  
2ab6			endm  
# End of macro DMARK
2ab6					CALLMONITOR 
2ab6 cd 6f ee			call debug_vector  
2ab9				endm  
# End of macro CALLMONITOR
2ab9				endif 
2ab9			 
2ab9			; cant push right now due to tokenised strings  
2ab9			 
2ab9			; get the destination of where to copy this definition to. 
2ab9			 
2ab9 c5					push bc 
2aba d1					pop de 
2abb			 
2abb 7e			.listl:         ld a,(hl) 
2abc fe 00				cp 0 
2abe 28 09				jr z, .lreplsp     ; replace zero with space 
2ac0					;cp FORTH_END_BUFFER 
2ac0 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ac2 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ac4				 
2ac4					; just copy this char as is then 
2ac4			 
2ac4 12					ld (de), a 
2ac5			 
2ac5 23			.listnxt:	inc hl 
2ac6 13					inc de 
2ac7 18 f2				jr .listl 
2ac9			 
2ac9 3e 20		.lreplsp:	ld a,' ' 
2acb 12					ld (de), a 
2acc 18 f7				jr .listnxt 
2ace			 
2ace			; close up uword def 
2ace			 
2ace			.listdone: 
2ace 12					ld (de), a 
2acf 13					inc de 
2ad0 3e 00				ld a, 0 
2ad2 12					ld (de), a 
2ad3			 
2ad3			; now have def so clean up and push to stack 
2ad3			 
2ad3 21 bb e2				ld hl, scratch 
2ad6				if DEBUG_FORTH_WORDS 
2ad6					DMARK "Ltp" 
2ad6 f5				push af  
2ad7 3a eb 2a			ld a, (.dmark)  
2ada 32 65 ee			ld (debug_mark),a  
2add 3a ec 2a			ld a, (.dmark+1)  
2ae0 32 66 ee			ld (debug_mark+1),a  
2ae3 3a ed 2a			ld a, (.dmark+2)  
2ae6 32 67 ee			ld (debug_mark+2),a  
2ae9 18 03			jr .pastdmark  
2aeb ..			.dmark: db "Ltp"  
2aee f1			.pastdmark: pop af  
2aef			endm  
# End of macro DMARK
2aef					CALLMONITOR 
2aef cd 6f ee			call debug_vector  
2af2				endm  
# End of macro CALLMONITOR
2af2				endif 
2af2			 
2af2 18 1f			jr .listpush 
2af4			 
2af4			;.lnuword:	pop hl 
2af4			;		call forth_tok_next 
2af4			;		jp .ldouscan  
2af4			 
2af4			.lunotfound:		  
2af4			 
2af4				if DEBUG_FORTH_WORDS 
2af4					DMARK "LSn" 
2af4 f5				push af  
2af5 3a 09 2b			ld a, (.dmark)  
2af8 32 65 ee			ld (debug_mark),a  
2afb 3a 0a 2b			ld a, (.dmark+1)  
2afe 32 66 ee			ld (debug_mark+1),a  
2b01 3a 0b 2b			ld a, (.dmark+2)  
2b04 32 67 ee			ld (debug_mark+2),a  
2b07 18 03			jr .pastdmark  
2b09 ..			.dmark: db "LSn"  
2b0c f1			.pastdmark: pop af  
2b0d			endm  
# End of macro DMARK
2b0d					CALLMONITOR 
2b0d cd 6f ee			call debug_vector  
2b10				endm  
# End of macro CALLMONITOR
2b10				endif 
2b10			 
2b10					 
2b10			;		FORTH_DSP_POP 
2b10			;		ld hl, .luno 
2b10			 
2b10					NEXTW			 
2b10 c3 81 1f			jp macro_next 
2b13				endm 
# End of macro NEXTW
2b13			 
2b13			.listpush: 
2b13				if DEBUG_FORTH_WORDS 
2b13					DMARK "LS>" 
2b13 f5				push af  
2b14 3a 28 2b			ld a, (.dmark)  
2b17 32 65 ee			ld (debug_mark),a  
2b1a 3a 29 2b			ld a, (.dmark+1)  
2b1d 32 66 ee			ld (debug_mark+1),a  
2b20 3a 2a 2b			ld a, (.dmark+2)  
2b23 32 67 ee			ld (debug_mark+2),a  
2b26 18 03			jr .pastdmark  
2b28 ..			.dmark: db "LS>"  
2b2b f1			.pastdmark: pop af  
2b2c			endm  
# End of macro DMARK
2b2c					CALLMONITOR 
2b2c cd 6f ee			call debug_vector  
2b2f				endm  
# End of macro CALLMONITOR
2b2f				endif 
2b2f cd fe 1b				call forth_push_str 
2b32			 
2b32			 
2b32			 
2b32					NEXTW 
2b32 c3 81 1f			jp macro_next 
2b35				endm 
# End of macro NEXTW
2b35			 
2b35			;.luno:    db "Word not found",0 
2b35			 
2b35			 
2b35			 
2b35			 
2b35			 
2b35			;		push hl   ; save pointer to start of uword def string 
2b35			; 
2b35			;; look for FORTH_EOL_LINE 
2b35			;		ld a, FORTH_END_BUFFER 
2b35			;		call strlent 
2b35			; 
2b35			;		inc hl		 ; space for coln def 
2b35			;		inc hl 
2b35			;		inc hl          ; space for terms 
2b35			;		inc hl 
2b35			; 
2b35			;		ld a, 20   ; TODO get actual length 
2b35			;		call addatohl    ; include a random amount of room for the uword name 
2b35			; 
2b35			;		 
2b35			;	if DEBUG_FORTH_WORDS 
2b35			;		DMARK "Lt1" 
2b35			;		CALLMONITOR 
2b35			;	endif 
2b35			;		 
2b35			; 
2b35			;; malloc space for the string because we cant change it 
2b35			; 
2b35			;		call malloc 
2b35			;	if DEBUG_FORTH_MALLOC_GUARD 
2b35			;		push af 
2b35			;		call ishlzero 
2b35			;		pop af 
2b35			;		 
2b35			;		call z,malloc_error 
2b35			;	endif 
2b35			; 
2b35			;	if DEBUG_FORTH_WORDS 
2b35			;		DMARK "Lt2" 
2b35			;		CALLMONITOR 
2b35			;	endif 
2b35			;		pop de 
2b35			;		push hl    ; push the malloc to release later 
2b35			;		push hl   ;  push back a copy for the later stack push 
2b35			;		 
2b35			;; copy the string swapping out the zero terms for spaces 
2b35			; 
2b35			;		; de has our source 
2b35			;		; hl has our dest 
2b35			; 
2b35			;; add the coln def 
2b35			; 
2b35			;		ld a, ':' 
2b35			;		ld (hl), a 
2b35			;		inc hl 
2b35			;		ld a, ' ' 
2b35			;		ld (hl), a 
2b35			;		inc hl 
2b35			; 
2b35			;; add the uname word 
2b35			;		push de   ; save our string for now 
2b35			;		ex de, hl 
2b35			; 
2b35			;		FORTH_DSP_VALUE 
2b35			;		;v5 FORTH_DSP_VALUE 
2b35			; 
2b35			;		inc hl   ; skip type but we know by now this is OK 
2b35			; 
2b35			;.luword:	ld a,(hl) 
2b35			;		cp 0 
2b35			;		jr z, .luword2 
2b35			;		ld (de), a 
2b35			;		inc de 
2b35			;		inc hl 
2b35			;		jr .luword 
2b35			; 
2b35			;.luword2:	ld a, ' ' 
2b35			;		ld (de), a 
2b35			;;		inc hl 
2b35			;;		inc de 
2b35			;;		ld (de), a 
2b35			;;		inc hl 
2b35			;		inc de 
2b35			; 
2b35			;		ex de, hl 
2b35			;		pop de 
2b35			;		 
2b35			;		 
2b35			; 
2b35			;; detoken that string and copy it 
2b35			; 
2b35			;	if DEBUG_FORTH_WORDS 
2b35			;		DMARK "Lt2" 
2b35			;		CALLMONITOR 
2b35			;	endif 
2b35			;.ldetok:	ld a, (de) 
2b35			;		cp FORTH_END_BUFFER 
2b35			;		jr z, .ldetokend 
2b35			;		; swap out any zero term for space 
2b35			;		cp 0 
2b35			;		jr nz, .ldetoknext 
2b35			;		ld a, ' ' 
2b35			; 
2b35			;	if DEBUG_FORTH_WORDS 
2b35			;		DMARK "LtS" 
2b35			;		CALLMONITOR 
2b35			;	endif 
2b35			;.ldetoknext:	ld (hl), a 
2b35			;		inc de 
2b35			;		inc hl 
2b35			;		jr .ldetok 
2b35			; 
2b35			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b35			;		ld (hl), a  
2b35			; 
2b35			;; free that temp malloc 
2b35			; 
2b35			;		pop hl    
2b35			; 
2b35			;	if DEBUG_FORTH_WORDS 
2b35			;		DMARK "Lt4" 
2b35			;		CALLMONITOR 
2b35			;	endif 
2b35			;		call forth_apushstrhl 
2b35			; 
2b35			;		; get rid of temp malloc area 
2b35			; 
2b35			;		pop hl 
2b35			;		call free 
2b35			; 
2b35			;		jr .ludone 
2b35			; 
2b35			;.lnuword:	pop hl 
2b35			;		call forth_tok_next 
2b35			;		jp .ldouscan  
2b35			; 
2b35			;.ludone:		 pop hl 
2b35			; 
2b35					NEXTW 
2b35 c3 81 1f			jp macro_next 
2b38				endm 
# End of macro NEXTW
2b38			 
2b38			.FORGET: 
2b38				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b38 5d				db WORD_SYS_CORE+73             
2b39 b1 2b			dw .NOP            
2b3b 07				db 6 + 1 
2b3c .. 00			db "FORGET",0              
2b43				endm 
# End of macro CWHEAD
2b43			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b43			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2b43			; | |  
2b43			; | | e.g. "MORE" forget 
2b43					if DEBUG_FORTH_WORDS_KEY 
2b43						DMARK "FRG" 
2b43 f5				push af  
2b44 3a 58 2b			ld a, (.dmark)  
2b47 32 65 ee			ld (debug_mark),a  
2b4a 3a 59 2b			ld a, (.dmark+1)  
2b4d 32 66 ee			ld (debug_mark+1),a  
2b50 3a 5a 2b			ld a, (.dmark+2)  
2b53 32 67 ee			ld (debug_mark+2),a  
2b56 18 03			jr .pastdmark  
2b58 ..			.dmark: db "FRG"  
2b5b f1			.pastdmark: pop af  
2b5c			endm  
# End of macro DMARK
2b5c						CALLMONITOR 
2b5c cd 6f ee			call debug_vector  
2b5f				endm  
# End of macro CALLMONITOR
2b5f					endif 
2b5f			 
2b5f				; find uword 
2b5f			        ; update start of word with "_" 
2b5f				; replace uword with deleted flag 
2b5f			 
2b5f			 
2b5f			;	if DEBUG_FORTH_WORDS 
2b5f			;		DMARK "FOG" 
2b5f			;		CALLMONITOR 
2b5f			;	endif 
2b5f			 
2b5f			 
2b5f					; Get ptr to the word we need to look up 
2b5f			 
2b5f					FORTH_DSP_VALUEHL 
2b5f cd 95 1d			call macro_dsp_valuehl 
2b62				endm 
# End of macro FORTH_DSP_VALUEHL
2b62					;v5 FORTH_DSP_VALUE 
2b62				; TODO type check 
2b62			;		inc hl    ; Skip type check  
2b62 e5					push hl 
2b63 c1					pop bc 
2b64			;		ex de, hl    ; put into DE 
2b64			 
2b64			 
2b64 21 50 5f				ld hl, baseram 
2b67					;ld hl, baseusermem 
2b67			 
2b67				; skip dict stub 
2b67			;	call forth_tok_next 
2b67 e5			push hl   ; sacreifical push 
2b68			 
2b68			.fldouscanm: 
2b68 e1				pop hl 
2b69			.fldouscan: 
2b69			;	if DEBUG_FORTH_WORDS 
2b69			;		DMARK "LSs" 
2b69			;		CALLMONITOR 
2b69			;	endif 
2b69				; skip dict stub 
2b69 cd d2 20				call forth_tok_next 
2b6c			 
2b6c			 
2b6c			; while we have words to look for 
2b6c			 
2b6c 7e				ld a, (hl)      
2b6d			;	if DEBUG_FORTH_WORDS 
2b6d			;		DMARK "LSk" 
2b6d			;		CALLMONITOR 
2b6d			;	endif 
2b6d fe 00				cp WORD_SYS_END 
2b6f ca ab 2b				jp z, .flunotfound 
2b72 fe 01				cp WORD_SYS_UWORD 
2b74 c2 69 2b				jp nz, .fldouscan 
2b77			 
2b77			;	if DEBUG_FORTH_WORDS 
2b77			;		DMARK "LSu" 
2b77			;		CALLMONITOR 
2b77			;	endif 
2b77			 
2b77					; found a uword but is it the one we want... 
2b77			 
2b77 c5					push bc     ; uword to find is on bc 
2b78 d1					pop de 
2b79			 
2b79 e5					push hl  ; to save the ptr 
2b7a			 
2b7a					; skip opcode 
2b7a 23					inc hl  
2b7b					; skip next ptr 
2b7b 23					inc hl  
2b7c 23					inc hl 
2b7d					; skip len 
2b7d 23					inc hl 
2b7e			 
2b7e			;	if DEBUG_FORTH_WORDS 
2b7e			;		DMARK "LSc" 
2b7e			;		CALLMONITOR 
2b7e			;	endif 
2b7e cd 93 11				call strcmp 
2b81 c2 68 2b				jp nz, .fldouscanm 
2b84			; 
2b84			; 
2b84			;; while we have words to look for 
2b84			; 
2b84			;.fdouscan:	ld a, (hl)      
2b84			;	if DEBUG_FORTH_WORDS 
2b84			;		DMARK "LSs" 
2b84			;		CALLMONITOR 
2b84			;	endif 
2b84			;		cp WORD_SYS_END 
2b84			;		jp z, .fudone 
2b84			;		cp WORD_SYS_UWORD 
2b84			;		jp nz, .fnuword 
2b84			; 
2b84			;	if DEBUG_FORTH_WORDS 
2b84			;		DMARK "FGu" 
2b84			;		CALLMONITOR 
2b84			;	endif 
2b84			; 
2b84			;		; found a uword but is it the one we want... 
2b84			; 
2b84			; 
2b84			;	        pop de   ; get back the dsp name 
2b84			;		push de 
2b84			; 
2b84			;		push hl  ; to save the ptr 
2b84			; 
2b84			;		; skip opcode 
2b84			;		inc hl  
2b84			;		; skip next ptr 
2b84			;		inc hl  
2b84			;		inc hl 
2b84			;		; skip len 
2b84			;		inc hl 
2b84			; 
2b84			;	if DEBUG_FORTH_WORDS 
2b84			;		DMARK "FGc" 
2b84			;		CALLMONITOR 
2b84			;	endif 
2b84			;		call strcmp 
2b84			;		jp nz, .fnuword 
2b84			 
2b84			 
2b84 e1			pop hl 
2b85			 
2b85				 
2b85				if DEBUG_FORTH_WORDS 
2b85					DMARK "FGm" 
2b85 f5				push af  
2b86 3a 9a 2b			ld a, (.dmark)  
2b89 32 65 ee			ld (debug_mark),a  
2b8c 3a 9b 2b			ld a, (.dmark+1)  
2b8f 32 66 ee			ld (debug_mark+1),a  
2b92 3a 9c 2b			ld a, (.dmark+2)  
2b95 32 67 ee			ld (debug_mark+2),a  
2b98 18 03			jr .pastdmark  
2b9a ..			.dmark: db "FGm"  
2b9d f1			.pastdmark: pop af  
2b9e			endm  
# End of macro DMARK
2b9e					CALLMONITOR 
2b9e cd 6f ee			call debug_vector  
2ba1				endm  
# End of macro CALLMONITOR
2ba1				endif 
2ba1			 
2ba1			 
2ba1			 
2ba1					; we have a uword so push its name to the stack 
2ba1			 
2ba1			;	   	push hl  ; save so we can move to next dict block 
2ba1			;pop hl 
2ba1			 
2ba1					; update opcode to deleted 
2ba1 3e 03				ld a, WORD_SYS_DELETED 
2ba3 77					ld (hl), a 
2ba4			 
2ba4 23					inc hl  
2ba5					; skip next ptr 
2ba5 23					inc hl  
2ba6 23					inc hl 
2ba7					; skip len 
2ba7 23					inc hl 
2ba8			 
2ba8					; TODO change parser to skip deleted words but for now mark it out 
2ba8 3e 5f				ld a, "_" 
2baa 77					ld  (hl),a 
2bab			 
2bab			;		jr .fudone 
2bab			; 
2bab			;.fnuword:	pop hl 
2bab			;		call forth_tok_next 
2bab			;		jp .fdouscan  
2bab			 
2bab			.flunotfound:		  
2bab			 
2bab			 
2bab					 
2bab					FORTH_DSP_POP 
2bab cd 4d 1e			call macro_forth_dsp_pop 
2bae				endm 
# End of macro FORTH_DSP_POP
2bae			;		ld hl, .luno 
2bae			;.fudone:		 pop hl 
2bae					NEXTW 
2bae c3 81 1f			jp macro_next 
2bb1				endm 
# End of macro NEXTW
2bb1			.NOP: 
2bb1				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bb1 61				db WORD_SYS_CORE+77             
2bb2 d8 2b			dw .COMO            
2bb4 04				db 3 + 1 
2bb5 .. 00			db "NOP",0              
2bb9				endm 
# End of macro CWHEAD
2bb9			; | NOP (  --  ) Do nothing | DONE 
2bb9					if DEBUG_FORTH_WORDS_KEY 
2bb9						DMARK "NOP" 
2bb9 f5				push af  
2bba 3a ce 2b			ld a, (.dmark)  
2bbd 32 65 ee			ld (debug_mark),a  
2bc0 3a cf 2b			ld a, (.dmark+1)  
2bc3 32 66 ee			ld (debug_mark+1),a  
2bc6 3a d0 2b			ld a, (.dmark+2)  
2bc9 32 67 ee			ld (debug_mark+2),a  
2bcc 18 03			jr .pastdmark  
2bce ..			.dmark: db "NOP"  
2bd1 f1			.pastdmark: pop af  
2bd2			endm  
# End of macro DMARK
2bd2						CALLMONITOR 
2bd2 cd 6f ee			call debug_vector  
2bd5				endm  
# End of macro CALLMONITOR
2bd5					endif 
2bd5				       NEXTW 
2bd5 c3 81 1f			jp macro_next 
2bd8				endm 
# End of macro NEXTW
2bd8			.COMO: 
2bd8				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bd8 6e				db WORD_SYS_CORE+90             
2bd9 2a 2c			dw .COMC            
2bdb 02				db 1 + 1 
2bdc .. 00			db "(",0              
2bde				endm 
# End of macro CWHEAD
2bde			; | ( ( -- )  Start of comment | DONE 
2bde			 
2bde			 
2bde 2a bc e5				ld hl, ( os_tok_ptr) 
2be1 11 25 2c			ld de, .closepar 
2be4					 
2be4					if DEBUG_FORTH_WORDS 
2be4						DMARK ").." 
2be4 f5				push af  
2be5 3a f9 2b			ld a, (.dmark)  
2be8 32 65 ee			ld (debug_mark),a  
2beb 3a fa 2b			ld a, (.dmark+1)  
2bee 32 66 ee			ld (debug_mark+1),a  
2bf1 3a fb 2b			ld a, (.dmark+2)  
2bf4 32 67 ee			ld (debug_mark+2),a  
2bf7 18 03			jr .pastdmark  
2bf9 ..			.dmark: db ").."  
2bfc f1			.pastdmark: pop af  
2bfd			endm  
# End of macro DMARK
2bfd						CALLMONITOR 
2bfd cd 6f ee			call debug_vector  
2c00				endm  
# End of macro CALLMONITOR
2c00					endif 
2c00 cd 9c 20			call findnexttok  
2c03			 
2c03					if DEBUG_FORTH_WORDS 
2c03						DMARK "IF5" 
2c03 f5				push af  
2c04 3a 18 2c			ld a, (.dmark)  
2c07 32 65 ee			ld (debug_mark),a  
2c0a 3a 19 2c			ld a, (.dmark+1)  
2c0d 32 66 ee			ld (debug_mark+1),a  
2c10 3a 1a 2c			ld a, (.dmark+2)  
2c13 32 67 ee			ld (debug_mark+2),a  
2c16 18 03			jr .pastdmark  
2c18 ..			.dmark: db "IF5"  
2c1b f1			.pastdmark: pop af  
2c1c			endm  
# End of macro DMARK
2c1c						CALLMONITOR 
2c1c cd 6f ee			call debug_vector  
2c1f				endm  
# End of macro CALLMONITOR
2c1f					endif 
2c1f				; replace below with ) exec using tok_ptr 
2c1f 22 bc e5			ld (os_tok_ptr), hl 
2c22 c3 12 20			jp exec1 
2c25			 
2c25 .. 00			.closepar:   db ")",0 
2c27			 
2c27				       NEXTW 
2c27 c3 81 1f			jp macro_next 
2c2a				endm 
# End of macro NEXTW
2c2a			.COMC: 
2c2a				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c2a 6f				db WORD_SYS_CORE+91             
2c2b 33 2c			dw .SCRATCH            
2c2d 02				db 1 + 1 
2c2e .. 00			db ")",0              
2c30				endm 
# End of macro CWHEAD
2c30			; | ) ( -- )  End of comment |  DONE  
2c30				       NEXTW 
2c30 c3 81 1f			jp macro_next 
2c33				endm 
# End of macro NEXTW
2c33			 
2c33			.SCRATCH: 
2c33				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c33 6f				db WORD_SYS_CORE+91             
2c34 6e 2c			dw .INC            
2c36 08				db 7 + 1 
2c37 .. 00			db "SCRATCH",0              
2c3f				endm 
# End of macro CWHEAD
2c3f			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c3f			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c3f			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c3f			; | |  
2c3f			; | | e.g.    : score $00 scratch ; 
2c3f			; | |  
2c3f			; | | $00 score ! 
2c3f			; | | $01 score +! 
2c3f			; | |  
2c3f			; | | e.g.   : varword $0a scratch ;  
2c3f			; | | 
2c3f			; | | $8000 varword ! 
2c3f					if DEBUG_FORTH_WORDS_KEY 
2c3f						DMARK "SCR" 
2c3f f5				push af  
2c40 3a 54 2c			ld a, (.dmark)  
2c43 32 65 ee			ld (debug_mark),a  
2c46 3a 55 2c			ld a, (.dmark+1)  
2c49 32 66 ee			ld (debug_mark+1),a  
2c4c 3a 56 2c			ld a, (.dmark+2)  
2c4f 32 67 ee			ld (debug_mark+2),a  
2c52 18 03			jr .pastdmark  
2c54 ..			.dmark: db "SCR"  
2c57 f1			.pastdmark: pop af  
2c58			endm  
# End of macro DMARK
2c58						CALLMONITOR 
2c58 cd 6f ee			call debug_vector  
2c5b				endm  
# End of macro CALLMONITOR
2c5b					endif 
2c5b			 
2c5b					FORTH_DSP_VALUEHL 
2c5b cd 95 1d			call macro_dsp_valuehl 
2c5e				endm 
# End of macro FORTH_DSP_VALUEHL
2c5e				 
2c5e					FORTH_DSP_POP 
2c5e cd 4d 1e			call macro_forth_dsp_pop 
2c61				endm 
# End of macro FORTH_DSP_POP
2c61			 
2c61 7d					ld a, l 
2c62 21 e0 e7				ld hl, os_var_array 
2c65 cd f5 0d				call addatohl 
2c68			 
2c68 cd 90 1b				call forth_push_numhl 
2c6b			 
2c6b				       NEXTW 
2c6b c3 81 1f			jp macro_next 
2c6e				endm 
# End of macro NEXTW
2c6e			 
2c6e			.INC: 
2c6e				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c6e 6f				db WORD_SYS_CORE+91             
2c6f c4 2c			dw .DEC            
2c71 03				db 2 + 1 
2c72 .. 00			db "+!",0              
2c75				endm 
# End of macro CWHEAD
2c75			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c75					if DEBUG_FORTH_WORDS_KEY 
2c75						DMARK "+s_" 
2c75 f5				push af  
2c76 3a 8a 2c			ld a, (.dmark)  
2c79 32 65 ee			ld (debug_mark),a  
2c7c 3a 8b 2c			ld a, (.dmark+1)  
2c7f 32 66 ee			ld (debug_mark+1),a  
2c82 3a 8c 2c			ld a, (.dmark+2)  
2c85 32 67 ee			ld (debug_mark+2),a  
2c88 18 03			jr .pastdmark  
2c8a ..			.dmark: db "+s_"  
2c8d f1			.pastdmark: pop af  
2c8e			endm  
# End of macro DMARK
2c8e						CALLMONITOR 
2c8e cd 6f ee			call debug_vector  
2c91				endm  
# End of macro CALLMONITOR
2c91					endif 
2c91			 
2c91					FORTH_DSP_VALUEHL 
2c91 cd 95 1d			call macro_dsp_valuehl 
2c94				endm 
# End of macro FORTH_DSP_VALUEHL
2c94			 
2c94 e5					push hl   ; save address 
2c95			 
2c95					FORTH_DSP_POP 
2c95 cd 4d 1e			call macro_forth_dsp_pop 
2c98				endm 
# End of macro FORTH_DSP_POP
2c98			 
2c98					FORTH_DSP_VALUEHL 
2c98 cd 95 1d			call macro_dsp_valuehl 
2c9b				endm 
# End of macro FORTH_DSP_VALUEHL
2c9b			 
2c9b e5					push hl 
2c9c					FORTH_DSP_POP 
2c9c cd 4d 1e			call macro_forth_dsp_pop 
2c9f				endm 
# End of macro FORTH_DSP_POP
2c9f e1					pop hl 
2ca0			 
2ca0					; hl contains value to add to byte at a 
2ca0				 
2ca0 eb					ex de, hl 
2ca1			 
2ca1 e1					pop hl 
2ca2			 
2ca2					if DEBUG_FORTH_WORDS 
2ca2						DMARK "INC" 
2ca2 f5				push af  
2ca3 3a b7 2c			ld a, (.dmark)  
2ca6 32 65 ee			ld (debug_mark),a  
2ca9 3a b8 2c			ld a, (.dmark+1)  
2cac 32 66 ee			ld (debug_mark+1),a  
2caf 3a b9 2c			ld a, (.dmark+2)  
2cb2 32 67 ee			ld (debug_mark+2),a  
2cb5 18 03			jr .pastdmark  
2cb7 ..			.dmark: db "INC"  
2cba f1			.pastdmark: pop af  
2cbb			endm  
# End of macro DMARK
2cbb						CALLMONITOR 
2cbb cd 6f ee			call debug_vector  
2cbe				endm  
# End of macro CALLMONITOR
2cbe					endif 
2cbe			 
2cbe 7e					ld a,(hl) 
2cbf 83					add e 
2cc0 77					ld (hl),a 
2cc1			 
2cc1			 
2cc1			 
2cc1				       NEXTW 
2cc1 c3 81 1f			jp macro_next 
2cc4				endm 
# End of macro NEXTW
2cc4			 
2cc4			.DEC: 
2cc4				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cc4 6f				db WORD_SYS_CORE+91             
2cc5 18 2d			dw .INC2            
2cc7 03				db 2 + 1 
2cc8 .. 00			db "-!",0              
2ccb				endm 
# End of macro CWHEAD
2ccb			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ccb					if DEBUG_FORTH_WORDS_KEY 
2ccb						DMARK "-s_" 
2ccb f5				push af  
2ccc 3a e0 2c			ld a, (.dmark)  
2ccf 32 65 ee			ld (debug_mark),a  
2cd2 3a e1 2c			ld a, (.dmark+1)  
2cd5 32 66 ee			ld (debug_mark+1),a  
2cd8 3a e2 2c			ld a, (.dmark+2)  
2cdb 32 67 ee			ld (debug_mark+2),a  
2cde 18 03			jr .pastdmark  
2ce0 ..			.dmark: db "-s_"  
2ce3 f1			.pastdmark: pop af  
2ce4			endm  
# End of macro DMARK
2ce4						CALLMONITOR 
2ce4 cd 6f ee			call debug_vector  
2ce7				endm  
# End of macro CALLMONITOR
2ce7					endif 
2ce7			 
2ce7					FORTH_DSP_VALUEHL 
2ce7 cd 95 1d			call macro_dsp_valuehl 
2cea				endm 
# End of macro FORTH_DSP_VALUEHL
2cea			 
2cea e5					push hl   ; save address 
2ceb			 
2ceb					FORTH_DSP_POP 
2ceb cd 4d 1e			call macro_forth_dsp_pop 
2cee				endm 
# End of macro FORTH_DSP_POP
2cee			 
2cee					FORTH_DSP_VALUEHL 
2cee cd 95 1d			call macro_dsp_valuehl 
2cf1				endm 
# End of macro FORTH_DSP_VALUEHL
2cf1			 
2cf1					; hl contains value to add to byte at a 
2cf1				 
2cf1 eb					ex de, hl 
2cf2			 
2cf2 e1					pop hl 
2cf3			 
2cf3					if DEBUG_FORTH_WORDS 
2cf3						DMARK "DEC" 
2cf3 f5				push af  
2cf4 3a 08 2d			ld a, (.dmark)  
2cf7 32 65 ee			ld (debug_mark),a  
2cfa 3a 09 2d			ld a, (.dmark+1)  
2cfd 32 66 ee			ld (debug_mark+1),a  
2d00 3a 0a 2d			ld a, (.dmark+2)  
2d03 32 67 ee			ld (debug_mark+2),a  
2d06 18 03			jr .pastdmark  
2d08 ..			.dmark: db "DEC"  
2d0b f1			.pastdmark: pop af  
2d0c			endm  
# End of macro DMARK
2d0c						CALLMONITOR 
2d0c cd 6f ee			call debug_vector  
2d0f				endm  
# End of macro CALLMONITOR
2d0f					endif 
2d0f			 
2d0f 7e					ld a,(hl) 
2d10 93					sub e 
2d11 77					ld (hl),a 
2d12			 
2d12			 
2d12					FORTH_DSP_POP 
2d12 cd 4d 1e			call macro_forth_dsp_pop 
2d15				endm 
# End of macro FORTH_DSP_POP
2d15			 
2d15				       NEXTW 
2d15 c3 81 1f			jp macro_next 
2d18				endm 
# End of macro NEXTW
2d18			 
2d18			.INC2: 
2d18				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d18 6f				db WORD_SYS_CORE+91             
2d19 c5 2d			dw .DEC2            
2d1b 04				db 3 + 1 
2d1c .. 00			db "+2!",0              
2d20				endm 
# End of macro CWHEAD
2d20			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d20			 
2d20					if DEBUG_FORTH_WORDS_KEY 
2d20						DMARK "+2s" 
2d20 f5				push af  
2d21 3a 35 2d			ld a, (.dmark)  
2d24 32 65 ee			ld (debug_mark),a  
2d27 3a 36 2d			ld a, (.dmark+1)  
2d2a 32 66 ee			ld (debug_mark+1),a  
2d2d 3a 37 2d			ld a, (.dmark+2)  
2d30 32 67 ee			ld (debug_mark+2),a  
2d33 18 03			jr .pastdmark  
2d35 ..			.dmark: db "+2s"  
2d38 f1			.pastdmark: pop af  
2d39			endm  
# End of macro DMARK
2d39						CALLMONITOR 
2d39 cd 6f ee			call debug_vector  
2d3c				endm  
# End of macro CALLMONITOR
2d3c					endif 
2d3c			 
2d3c					; Address 
2d3c			 
2d3c					FORTH_DSP_VALUEHL 
2d3c cd 95 1d			call macro_dsp_valuehl 
2d3f				endm 
# End of macro FORTH_DSP_VALUEHL
2d3f			 
2d3f e5					push hl    ; save address 
2d40			 
2d40					; load content into de 
2d40			 
2d40 5e					ld e,(hl) 
2d41 23					inc hl 
2d42 56					ld d, (hl) 
2d43			 
2d43					if DEBUG_FORTH_WORDS 
2d43						DMARK "+2a" 
2d43 f5				push af  
2d44 3a 58 2d			ld a, (.dmark)  
2d47 32 65 ee			ld (debug_mark),a  
2d4a 3a 59 2d			ld a, (.dmark+1)  
2d4d 32 66 ee			ld (debug_mark+1),a  
2d50 3a 5a 2d			ld a, (.dmark+2)  
2d53 32 67 ee			ld (debug_mark+2),a  
2d56 18 03			jr .pastdmark  
2d58 ..			.dmark: db "+2a"  
2d5b f1			.pastdmark: pop af  
2d5c			endm  
# End of macro DMARK
2d5c						CALLMONITOR 
2d5c cd 6f ee			call debug_vector  
2d5f				endm  
# End of macro CALLMONITOR
2d5f					endif 
2d5f			 
2d5f					FORTH_DSP_POP 
2d5f cd 4d 1e			call macro_forth_dsp_pop 
2d62				endm 
# End of macro FORTH_DSP_POP
2d62			 
2d62					; Get value to add 
2d62			 
2d62					FORTH_DSP_VALUE 
2d62 cd 7e 1d			call macro_forth_dsp_value 
2d65				endm 
# End of macro FORTH_DSP_VALUE
2d65			 
2d65					if DEBUG_FORTH_WORDS 
2d65						DMARK "+2v" 
2d65 f5				push af  
2d66 3a 7a 2d			ld a, (.dmark)  
2d69 32 65 ee			ld (debug_mark),a  
2d6c 3a 7b 2d			ld a, (.dmark+1)  
2d6f 32 66 ee			ld (debug_mark+1),a  
2d72 3a 7c 2d			ld a, (.dmark+2)  
2d75 32 67 ee			ld (debug_mark+2),a  
2d78 18 03			jr .pastdmark  
2d7a ..			.dmark: db "+2v"  
2d7d f1			.pastdmark: pop af  
2d7e			endm  
# End of macro DMARK
2d7e						CALLMONITOR 
2d7e cd 6f ee			call debug_vector  
2d81				endm  
# End of macro CALLMONITOR
2d81					endif 
2d81			 
2d81 19					add hl, de 
2d82			 
2d82					if DEBUG_FORTH_WORDS 
2d82						DMARK "+2+" 
2d82 f5				push af  
2d83 3a 97 2d			ld a, (.dmark)  
2d86 32 65 ee			ld (debug_mark),a  
2d89 3a 98 2d			ld a, (.dmark+1)  
2d8c 32 66 ee			ld (debug_mark+1),a  
2d8f 3a 99 2d			ld a, (.dmark+2)  
2d92 32 67 ee			ld (debug_mark+2),a  
2d95 18 03			jr .pastdmark  
2d97 ..			.dmark: db "+2+"  
2d9a f1			.pastdmark: pop af  
2d9b			endm  
# End of macro DMARK
2d9b						CALLMONITOR 
2d9b cd 6f ee			call debug_vector  
2d9e				endm  
# End of macro CALLMONITOR
2d9e					endif 
2d9e			 
2d9e					; move result to de 
2d9e			 
2d9e eb					ex de, hl 
2d9f			 
2d9f					; Address 
2d9f			 
2d9f e1					pop hl 
2da0			 
2da0					; save it back 
2da0			 
2da0 73					ld (hl), e 
2da1 23					inc hl 
2da2 72					ld (hl), d 
2da3			 
2da3					if DEBUG_FORTH_WORDS 
2da3						DMARK "+2e" 
2da3 f5				push af  
2da4 3a b8 2d			ld a, (.dmark)  
2da7 32 65 ee			ld (debug_mark),a  
2daa 3a b9 2d			ld a, (.dmark+1)  
2dad 32 66 ee			ld (debug_mark+1),a  
2db0 3a ba 2d			ld a, (.dmark+2)  
2db3 32 67 ee			ld (debug_mark+2),a  
2db6 18 03			jr .pastdmark  
2db8 ..			.dmark: db "+2e"  
2dbb f1			.pastdmark: pop af  
2dbc			endm  
# End of macro DMARK
2dbc						CALLMONITOR 
2dbc cd 6f ee			call debug_vector  
2dbf				endm  
# End of macro CALLMONITOR
2dbf					endif 
2dbf			 
2dbf			 
2dbf			 
2dbf					FORTH_DSP_POP 
2dbf cd 4d 1e			call macro_forth_dsp_pop 
2dc2				endm 
# End of macro FORTH_DSP_POP
2dc2			 
2dc2			 
2dc2				       NEXTW 
2dc2 c3 81 1f			jp macro_next 
2dc5				endm 
# End of macro NEXTW
2dc5			 
2dc5			.DEC2: 
2dc5				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dc5 6f				db WORD_SYS_CORE+91             
2dc6 74 2e			dw .GET2            
2dc8 04				db 3 + 1 
2dc9 .. 00			db "-2!",0              
2dcd				endm 
# End of macro CWHEAD
2dcd			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dcd			 
2dcd			 
2dcd					if DEBUG_FORTH_WORDS_KEY 
2dcd						DMARK "-2s" 
2dcd f5				push af  
2dce 3a e2 2d			ld a, (.dmark)  
2dd1 32 65 ee			ld (debug_mark),a  
2dd4 3a e3 2d			ld a, (.dmark+1)  
2dd7 32 66 ee			ld (debug_mark+1),a  
2dda 3a e4 2d			ld a, (.dmark+2)  
2ddd 32 67 ee			ld (debug_mark+2),a  
2de0 18 03			jr .pastdmark  
2de2 ..			.dmark: db "-2s"  
2de5 f1			.pastdmark: pop af  
2de6			endm  
# End of macro DMARK
2de6						CALLMONITOR 
2de6 cd 6f ee			call debug_vector  
2de9				endm  
# End of macro CALLMONITOR
2de9					endif 
2de9			 
2de9					; Address 
2de9			 
2de9					FORTH_DSP_VALUEHL 
2de9 cd 95 1d			call macro_dsp_valuehl 
2dec				endm 
# End of macro FORTH_DSP_VALUEHL
2dec			 
2dec e5					push hl    ; save address 
2ded			 
2ded					; load content into de 
2ded			 
2ded 5e					ld e,(hl) 
2dee 23					inc hl 
2def 56					ld d, (hl) 
2df0			 
2df0					if DEBUG_FORTH_WORDS 
2df0						DMARK "-2a" 
2df0 f5				push af  
2df1 3a 05 2e			ld a, (.dmark)  
2df4 32 65 ee			ld (debug_mark),a  
2df7 3a 06 2e			ld a, (.dmark+1)  
2dfa 32 66 ee			ld (debug_mark+1),a  
2dfd 3a 07 2e			ld a, (.dmark+2)  
2e00 32 67 ee			ld (debug_mark+2),a  
2e03 18 03			jr .pastdmark  
2e05 ..			.dmark: db "-2a"  
2e08 f1			.pastdmark: pop af  
2e09			endm  
# End of macro DMARK
2e09						CALLMONITOR 
2e09 cd 6f ee			call debug_vector  
2e0c				endm  
# End of macro CALLMONITOR
2e0c					endif 
2e0c			 
2e0c					FORTH_DSP_POP 
2e0c cd 4d 1e			call macro_forth_dsp_pop 
2e0f				endm 
# End of macro FORTH_DSP_POP
2e0f			 
2e0f					; Get value to remove 
2e0f			 
2e0f					FORTH_DSP_VALUE 
2e0f cd 7e 1d			call macro_forth_dsp_value 
2e12				endm 
# End of macro FORTH_DSP_VALUE
2e12			 
2e12					if DEBUG_FORTH_WORDS 
2e12						DMARK "-2v" 
2e12 f5				push af  
2e13 3a 27 2e			ld a, (.dmark)  
2e16 32 65 ee			ld (debug_mark),a  
2e19 3a 28 2e			ld a, (.dmark+1)  
2e1c 32 66 ee			ld (debug_mark+1),a  
2e1f 3a 29 2e			ld a, (.dmark+2)  
2e22 32 67 ee			ld (debug_mark+2),a  
2e25 18 03			jr .pastdmark  
2e27 ..			.dmark: db "-2v"  
2e2a f1			.pastdmark: pop af  
2e2b			endm  
# End of macro DMARK
2e2b						CALLMONITOR 
2e2b cd 6f ee			call debug_vector  
2e2e				endm  
# End of macro CALLMONITOR
2e2e					endif 
2e2e			 
2e2e eb					ex de, hl 
2e2f ed 52				sbc hl, de 
2e31			 
2e31					if DEBUG_FORTH_WORDS 
2e31						DMARK "-2d" 
2e31 f5				push af  
2e32 3a 46 2e			ld a, (.dmark)  
2e35 32 65 ee			ld (debug_mark),a  
2e38 3a 47 2e			ld a, (.dmark+1)  
2e3b 32 66 ee			ld (debug_mark+1),a  
2e3e 3a 48 2e			ld a, (.dmark+2)  
2e41 32 67 ee			ld (debug_mark+2),a  
2e44 18 03			jr .pastdmark  
2e46 ..			.dmark: db "-2d"  
2e49 f1			.pastdmark: pop af  
2e4a			endm  
# End of macro DMARK
2e4a						CALLMONITOR 
2e4a cd 6f ee			call debug_vector  
2e4d				endm  
# End of macro CALLMONITOR
2e4d					endif 
2e4d			 
2e4d					; move result to de 
2e4d			 
2e4d eb					ex de, hl 
2e4e			 
2e4e					; Address 
2e4e			 
2e4e e1					pop hl 
2e4f			 
2e4f					; save it back 
2e4f			 
2e4f 73					ld (hl), e 
2e50 23					inc hl 
2e51 72					ld (hl), d 
2e52			 
2e52					if DEBUG_FORTH_WORDS 
2e52						DMARK "-2e" 
2e52 f5				push af  
2e53 3a 67 2e			ld a, (.dmark)  
2e56 32 65 ee			ld (debug_mark),a  
2e59 3a 68 2e			ld a, (.dmark+1)  
2e5c 32 66 ee			ld (debug_mark+1),a  
2e5f 3a 69 2e			ld a, (.dmark+2)  
2e62 32 67 ee			ld (debug_mark+2),a  
2e65 18 03			jr .pastdmark  
2e67 ..			.dmark: db "-2e"  
2e6a f1			.pastdmark: pop af  
2e6b			endm  
# End of macro DMARK
2e6b						CALLMONITOR 
2e6b cd 6f ee			call debug_vector  
2e6e				endm  
# End of macro CALLMONITOR
2e6e					endif 
2e6e			 
2e6e			 
2e6e					FORTH_DSP_POP 
2e6e cd 4d 1e			call macro_forth_dsp_pop 
2e71				endm 
# End of macro FORTH_DSP_POP
2e71			 
2e71			 
2e71			 
2e71				       NEXTW 
2e71 c3 81 1f			jp macro_next 
2e74				endm 
# End of macro NEXTW
2e74			.GET2: 
2e74				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e74 6f				db WORD_SYS_CORE+91             
2e75 a9 2e			dw .BANG2            
2e77 03				db 2 + 1 
2e78 .. 00			db "2@",0              
2e7b				endm 
# End of macro CWHEAD
2e7b			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e7b					if DEBUG_FORTH_WORDS_KEY 
2e7b						DMARK "2A_" 
2e7b f5				push af  
2e7c 3a 90 2e			ld a, (.dmark)  
2e7f 32 65 ee			ld (debug_mark),a  
2e82 3a 91 2e			ld a, (.dmark+1)  
2e85 32 66 ee			ld (debug_mark+1),a  
2e88 3a 92 2e			ld a, (.dmark+2)  
2e8b 32 67 ee			ld (debug_mark+2),a  
2e8e 18 03			jr .pastdmark  
2e90 ..			.dmark: db "2A_"  
2e93 f1			.pastdmark: pop af  
2e94			endm  
# End of macro DMARK
2e94						CALLMONITOR 
2e94 cd 6f ee			call debug_vector  
2e97				endm  
# End of macro CALLMONITOR
2e97					endif 
2e97			 
2e97					FORTH_DSP_VALUEHL 
2e97 cd 95 1d			call macro_dsp_valuehl 
2e9a				endm 
# End of macro FORTH_DSP_VALUEHL
2e9a			 
2e9a e5					push hl   ; save address 
2e9b			 
2e9b					FORTH_DSP_POP 
2e9b cd 4d 1e			call macro_forth_dsp_pop 
2e9e				endm 
# End of macro FORTH_DSP_POP
2e9e			 
2e9e e1					pop hl 
2e9f			 
2e9f 5e					ld e, (hl) 
2ea0 23					inc hl 
2ea1 56					ld d, (hl) 
2ea2			 
2ea2 eb					ex de, hl 
2ea3			 
2ea3 cd 90 1b				call forth_push_numhl 
2ea6			 
2ea6				       NEXTW 
2ea6 c3 81 1f			jp macro_next 
2ea9				endm 
# End of macro NEXTW
2ea9			.BANG2: 
2ea9				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ea9 6f				db WORD_SYS_CORE+91             
2eaa e1 2e			dw .CONFIG            
2eac 03				db 2 + 1 
2ead .. 00			db "2!",0              
2eb0				endm 
# End of macro CWHEAD
2eb0			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2eb0					if DEBUG_FORTH_WORDS_KEY 
2eb0						DMARK "2S_" 
2eb0 f5				push af  
2eb1 3a c5 2e			ld a, (.dmark)  
2eb4 32 65 ee			ld (debug_mark),a  
2eb7 3a c6 2e			ld a, (.dmark+1)  
2eba 32 66 ee			ld (debug_mark+1),a  
2ebd 3a c7 2e			ld a, (.dmark+2)  
2ec0 32 67 ee			ld (debug_mark+2),a  
2ec3 18 03			jr .pastdmark  
2ec5 ..			.dmark: db "2S_"  
2ec8 f1			.pastdmark: pop af  
2ec9			endm  
# End of macro DMARK
2ec9						CALLMONITOR 
2ec9 cd 6f ee			call debug_vector  
2ecc				endm  
# End of macro CALLMONITOR
2ecc					endif 
2ecc			 
2ecc					FORTH_DSP_VALUEHL 
2ecc cd 95 1d			call macro_dsp_valuehl 
2ecf				endm 
# End of macro FORTH_DSP_VALUEHL
2ecf			 
2ecf e5					push hl   ; save address 
2ed0			 
2ed0			 
2ed0					FORTH_DSP_POP 
2ed0 cd 4d 1e			call macro_forth_dsp_pop 
2ed3				endm 
# End of macro FORTH_DSP_POP
2ed3			 
2ed3					 
2ed3					FORTH_DSP_VALUEHL 
2ed3 cd 95 1d			call macro_dsp_valuehl 
2ed6				endm 
# End of macro FORTH_DSP_VALUEHL
2ed6			 
2ed6					FORTH_DSP_POP 
2ed6 cd 4d 1e			call macro_forth_dsp_pop 
2ed9				endm 
# End of macro FORTH_DSP_POP
2ed9			 
2ed9 eb					ex de, hl    ; value now in de 
2eda			 
2eda e1					pop hl 
2edb			 
2edb 73					ld (hl), e 
2edc			 
2edc 23					inc hl 
2edd			 
2edd 72					ld (hl), d 
2ede			 
2ede			 
2ede				       NEXTW 
2ede c3 81 1f			jp macro_next 
2ee1				endm 
# End of macro NEXTW
2ee1			.CONFIG: 
2ee1				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2ee1 6f				db WORD_SYS_CORE+91             
2ee2 f2 2e			dw .ADTOS            
2ee4 07				db 6 + 1 
2ee5 .. 00			db "CONFIG",0              
2eec				endm 
# End of macro CWHEAD
2eec			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2eec			 
2eec cd 69 13				call config 
2eef					NEXTW 
2eef c3 81 1f			jp macro_next 
2ef2				endm 
# End of macro NEXTW
2ef2			 
2ef2			.ADTOS: 
2ef2				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2ef2 6f				db WORD_SYS_CORE+91             
2ef3 08 2f			dw .SBTOS            
2ef5 03				db 2 + 1 
2ef6 .. 00			db "1+",0              
2ef9				endm 
# End of macro CWHEAD
2ef9			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2ef9			 
2ef9					FORTH_DSP_VALUEHL 
2ef9 cd 95 1d			call macro_dsp_valuehl 
2efc				endm 
# End of macro FORTH_DSP_VALUEHL
2efc e5					push hl 
2efd			 
2efd					FORTH_DSP_POP 
2efd cd 4d 1e			call macro_forth_dsp_pop 
2f00				endm 
# End of macro FORTH_DSP_POP
2f00 e1					pop hl 
2f01			 
2f01 23					inc hl 
2f02 cd 90 1b				call forth_push_numhl 
2f05					 
2f05					NEXTW 
2f05 c3 81 1f			jp macro_next 
2f08				endm 
# End of macro NEXTW
2f08			.SBTOS: 
2f08				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2f08 6f				db WORD_SYS_CORE+91             
2f09 1e 2f			dw .ADSTORE            
2f0b 03				db 2 + 1 
2f0c .. 00			db "1-",0              
2f0f				endm 
# End of macro CWHEAD
2f0f			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2f0f			 
2f0f					FORTH_DSP_VALUEHL 
2f0f cd 95 1d			call macro_dsp_valuehl 
2f12				endm 
# End of macro FORTH_DSP_VALUEHL
2f12 e5					push hl 
2f13			 
2f13					FORTH_DSP_POP 
2f13 cd 4d 1e			call macro_forth_dsp_pop 
2f16				endm 
# End of macro FORTH_DSP_POP
2f16 e1					pop hl 
2f17			 
2f17 2b					dec hl 
2f18 cd 90 1b				call forth_push_numhl 
2f1b					 
2f1b					NEXTW 
2f1b c3 81 1f			jp macro_next 
2f1e				endm 
# End of macro NEXTW
2f1e			.ADSTORE: 
2f1e				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2f1e 6f				db WORD_SYS_CORE+91             
2f1f 34 2f			dw .ADWSTORE            
2f21 04				db 3 + 1 
2f22 .. 00			db "1+!",0              
2f26				endm 
# End of macro CWHEAD
2f26			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2f26			 
2f26					FORTH_DSP_VALUEHL 
2f26 cd 95 1d			call macro_dsp_valuehl 
2f29				endm 
# End of macro FORTH_DSP_VALUEHL
2f29 e5					push hl 
2f2a			 
2f2a					FORTH_DSP_POP 
2f2a cd 4d 1e			call macro_forth_dsp_pop 
2f2d				endm 
# End of macro FORTH_DSP_POP
2f2d e1					pop hl 
2f2e			 
2f2e 7e					ld a, (hl) 
2f2f 3c					inc a 
2f30 77					ld (hl), a 
2f31					 
2f31					NEXTW 
2f31 c3 81 1f			jp macro_next 
2f34				endm 
# End of macro NEXTW
2f34			.ADWSTORE: 
2f34				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
2f34 6f				db WORD_SYS_CORE+91             
2f35 52 2f			dw .SBSTORE            
2f37 05				db 4 + 1 
2f38 .. 00			db "1+2!",0              
2f3d				endm 
# End of macro CWHEAD
2f3d			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2f3d			 
2f3d					FORTH_DSP_VALUEHL 
2f3d cd 95 1d			call macro_dsp_valuehl 
2f40				endm 
# End of macro FORTH_DSP_VALUEHL
2f40 e5					push hl 
2f41			 
2f41					FORTH_DSP_POP 
2f41 cd 4d 1e			call macro_forth_dsp_pop 
2f44				endm 
# End of macro FORTH_DSP_POP
2f44 e1					pop hl 
2f45			 
2f45 e5					push hl 
2f46			 
2f46 cd 03 1f				call loadwordinhl 
2f49 23					inc hl 
2f4a			 
2f4a d1					pop de 
2f4b eb					ex de, hl 
2f4c 73					ld (hl), e 
2f4d 23					inc hl 
2f4e 72					ld (hl), d 
2f4f					 
2f4f					NEXTW 
2f4f c3 81 1f			jp macro_next 
2f52				endm 
# End of macro NEXTW
2f52			.SBSTORE: 
2f52				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
2f52 6f				db WORD_SYS_CORE+91             
2f53 68 2f			dw .SBWSTORE            
2f55 04				db 3 + 1 
2f56 .. 00			db "1-!",0              
2f5a				endm 
# End of macro CWHEAD
2f5a			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
2f5a			 
2f5a					FORTH_DSP_VALUEHL 
2f5a cd 95 1d			call macro_dsp_valuehl 
2f5d				endm 
# End of macro FORTH_DSP_VALUEHL
2f5d e5					push hl 
2f5e			 
2f5e					FORTH_DSP_POP 
2f5e cd 4d 1e			call macro_forth_dsp_pop 
2f61				endm 
# End of macro FORTH_DSP_POP
2f61 e1					pop hl 
2f62			 
2f62 7e					ld a, (hl) 
2f63 3d					dec a 
2f64 77					ld (hl), a 
2f65					 
2f65					NEXTW 
2f65 c3 81 1f			jp macro_next 
2f68				endm 
# End of macro NEXTW
2f68			.SBWSTORE: 
2f68				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
2f68 6f				db WORD_SYS_CORE+91             
2f69 86 2f			dw .ENDCORE            
2f6b 05				db 4 + 1 
2f6c .. 00			db "1-2!",0              
2f71				endm 
# End of macro CWHEAD
2f71			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
2f71			 
2f71					FORTH_DSP_VALUEHL 
2f71 cd 95 1d			call macro_dsp_valuehl 
2f74				endm 
# End of macro FORTH_DSP_VALUEHL
2f74 e5					push hl 
2f75			 
2f75					FORTH_DSP_POP 
2f75 cd 4d 1e			call macro_forth_dsp_pop 
2f78				endm 
# End of macro FORTH_DSP_POP
2f78 e1					pop hl 
2f79			 
2f79 e5					push hl 
2f7a			 
2f7a cd 03 1f				call loadwordinhl 
2f7d 2b					dec hl 
2f7e			 
2f7e d1					pop de 
2f7f eb					ex de, hl 
2f80 73					ld (hl), e 
2f81 23					inc hl 
2f82 72					ld (hl), d 
2f83					 
2f83					NEXTW 
2f83 c3 81 1f			jp macro_next 
2f86				endm 
# End of macro NEXTW
2f86			.ENDCORE: 
2f86			 
2f86			; eof 
2f86			 
2f86			 
# End of file forth_words_core.asm
2f86			include "forth_words_flow.asm" 
2f86			 
2f86			; | ## Program Flow Words 
2f86			 
2f86			.IF: 
2f86				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f86 1e				db WORD_SYS_CORE+10             
2f87 7b 30			dw .THEN            
2f89 03				db 2 + 1 
2f8a .. 00			db "IF",0              
2f8d				endm 
# End of macro CWHEAD
2f8d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f8d			; 
2f8d					if DEBUG_FORTH_WORDS_KEY 
2f8d						DMARK "IF." 
2f8d f5				push af  
2f8e 3a a2 2f			ld a, (.dmark)  
2f91 32 65 ee			ld (debug_mark),a  
2f94 3a a3 2f			ld a, (.dmark+1)  
2f97 32 66 ee			ld (debug_mark+1),a  
2f9a 3a a4 2f			ld a, (.dmark+2)  
2f9d 32 67 ee			ld (debug_mark+2),a  
2fa0 18 03			jr .pastdmark  
2fa2 ..			.dmark: db "IF."  
2fa5 f1			.pastdmark: pop af  
2fa6			endm  
# End of macro DMARK
2fa6						CALLMONITOR 
2fa6 cd 6f ee			call debug_vector  
2fa9				endm  
# End of macro CALLMONITOR
2fa9					endif 
2fa9			; eval TOS 
2fa9			 
2fa9				FORTH_DSP_VALUEHL 
2fa9 cd 95 1d			call macro_dsp_valuehl 
2fac				endm 
# End of macro FORTH_DSP_VALUEHL
2fac			 
2fac			;	push hl 
2fac				FORTH_DSP_POP 
2fac cd 4d 1e			call macro_forth_dsp_pop 
2faf				endm 
# End of macro FORTH_DSP_POP
2faf			;	pop hl 
2faf			 
2faf					if DEBUG_FORTH_WORDS 
2faf						DMARK "IF1" 
2faf f5				push af  
2fb0 3a c4 2f			ld a, (.dmark)  
2fb3 32 65 ee			ld (debug_mark),a  
2fb6 3a c5 2f			ld a, (.dmark+1)  
2fb9 32 66 ee			ld (debug_mark+1),a  
2fbc 3a c6 2f			ld a, (.dmark+2)  
2fbf 32 67 ee			ld (debug_mark+2),a  
2fc2 18 03			jr .pastdmark  
2fc4 ..			.dmark: db "IF1"  
2fc7 f1			.pastdmark: pop af  
2fc8			endm  
# End of macro DMARK
2fc8						CALLMONITOR 
2fc8 cd 6f ee			call debug_vector  
2fcb				endm  
# End of macro CALLMONITOR
2fcb					endif 
2fcb b7				or a        ; clear carry flag 
2fcc 11 00 00			ld de, 0 
2fcf eb				ex de,hl 
2fd0 ed 52			sbc hl, de 
2fd2 c2 5c 30			jp nz, .iftrue 
2fd5			 
2fd5					if DEBUG_FORTH_WORDS 
2fd5						DMARK "IF2" 
2fd5 f5				push af  
2fd6 3a ea 2f			ld a, (.dmark)  
2fd9 32 65 ee			ld (debug_mark),a  
2fdc 3a eb 2f			ld a, (.dmark+1)  
2fdf 32 66 ee			ld (debug_mark+1),a  
2fe2 3a ec 2f			ld a, (.dmark+2)  
2fe5 32 67 ee			ld (debug_mark+2),a  
2fe8 18 03			jr .pastdmark  
2fea ..			.dmark: db "IF2"  
2fed f1			.pastdmark: pop af  
2fee			endm  
# End of macro DMARK
2fee						CALLMONITOR 
2fee cd 6f ee			call debug_vector  
2ff1				endm  
# End of macro CALLMONITOR
2ff1					endif 
2ff1			 
2ff1			; if not true then skip to THEN 
2ff1			 
2ff1				; TODO get tok_ptr 
2ff1				; TODO consume toks until we get to THEN 
2ff1			 
2ff1 2a bc e5			ld hl, (os_tok_ptr) 
2ff4					if DEBUG_FORTH_WORDS 
2ff4						DMARK "IF3" 
2ff4 f5				push af  
2ff5 3a 09 30			ld a, (.dmark)  
2ff8 32 65 ee			ld (debug_mark),a  
2ffb 3a 0a 30			ld a, (.dmark+1)  
2ffe 32 66 ee			ld (debug_mark+1),a  
3001 3a 0b 30			ld a, (.dmark+2)  
3004 32 67 ee			ld (debug_mark+2),a  
3007 18 03			jr .pastdmark  
3009 ..			.dmark: db "IF3"  
300c f1			.pastdmark: pop af  
300d			endm  
# End of macro DMARK
300d						CALLMONITOR 
300d cd 6f ee			call debug_vector  
3010				endm  
# End of macro CALLMONITOR
3010						 
3010					endif 
3010 11 57 30			ld de, .ifthen 
3013					if DEBUG_FORTH_WORDS 
3013						DMARK "IF4" 
3013 f5				push af  
3014 3a 28 30			ld a, (.dmark)  
3017 32 65 ee			ld (debug_mark),a  
301a 3a 29 30			ld a, (.dmark+1)  
301d 32 66 ee			ld (debug_mark+1),a  
3020 3a 2a 30			ld a, (.dmark+2)  
3023 32 67 ee			ld (debug_mark+2),a  
3026 18 03			jr .pastdmark  
3028 ..			.dmark: db "IF4"  
302b f1			.pastdmark: pop af  
302c			endm  
# End of macro DMARK
302c						CALLMONITOR 
302c cd 6f ee			call debug_vector  
302f				endm  
# End of macro CALLMONITOR
302f					endif 
302f cd 9c 20			call findnexttok  
3032			 
3032					if DEBUG_FORTH_WORDS 
3032						DMARK "IF5" 
3032 f5				push af  
3033 3a 47 30			ld a, (.dmark)  
3036 32 65 ee			ld (debug_mark),a  
3039 3a 48 30			ld a, (.dmark+1)  
303c 32 66 ee			ld (debug_mark+1),a  
303f 3a 49 30			ld a, (.dmark+2)  
3042 32 67 ee			ld (debug_mark+2),a  
3045 18 03			jr .pastdmark  
3047 ..			.dmark: db "IF5"  
304a f1			.pastdmark: pop af  
304b			endm  
# End of macro DMARK
304b						CALLMONITOR 
304b cd 6f ee			call debug_vector  
304e				endm  
# End of macro CALLMONITOR
304e					endif 
304e				; TODO replace below with ; exec using tok_ptr 
304e 22 bc e5			ld (os_tok_ptr), hl 
3051 c3 12 20			jp exec1 
3054				NEXTW 
3054 c3 81 1f			jp macro_next 
3057				endm 
# End of macro NEXTW
3057			 
3057 .. 00		.ifthen:  db "THEN",0 
305c			 
305c			.iftrue:		 
305c				; Exec next words normally 
305c			 
305c				; if true then exec following IF as normal 
305c					if DEBUG_FORTH_WORDS 
305c						DMARK "IFT" 
305c f5				push af  
305d 3a 71 30			ld a, (.dmark)  
3060 32 65 ee			ld (debug_mark),a  
3063 3a 72 30			ld a, (.dmark+1)  
3066 32 66 ee			ld (debug_mark+1),a  
3069 3a 73 30			ld a, (.dmark+2)  
306c 32 67 ee			ld (debug_mark+2),a  
306f 18 03			jr .pastdmark  
3071 ..			.dmark: db "IFT"  
3074 f1			.pastdmark: pop af  
3075			endm  
# End of macro DMARK
3075						CALLMONITOR 
3075 cd 6f ee			call debug_vector  
3078				endm  
# End of macro CALLMONITOR
3078					endif 
3078			 
3078					NEXTW 
3078 c3 81 1f			jp macro_next 
307b				endm 
# End of macro NEXTW
307b			.THEN: 
307b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
307b 1f				db WORD_SYS_CORE+11             
307c a3 30			dw .ELSE            
307e 05				db 4 + 1 
307f .. 00			db "THEN",0              
3084				endm 
# End of macro CWHEAD
3084			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3084					if DEBUG_FORTH_WORDS_KEY 
3084						DMARK "THN" 
3084 f5				push af  
3085 3a 99 30			ld a, (.dmark)  
3088 32 65 ee			ld (debug_mark),a  
308b 3a 9a 30			ld a, (.dmark+1)  
308e 32 66 ee			ld (debug_mark+1),a  
3091 3a 9b 30			ld a, (.dmark+2)  
3094 32 67 ee			ld (debug_mark+2),a  
3097 18 03			jr .pastdmark  
3099 ..			.dmark: db "THN"  
309c f1			.pastdmark: pop af  
309d			endm  
# End of macro DMARK
309d						CALLMONITOR 
309d cd 6f ee			call debug_vector  
30a0				endm  
# End of macro CALLMONITOR
30a0					endif 
30a0					NEXTW 
30a0 c3 81 1f			jp macro_next 
30a3				endm 
# End of macro NEXTW
30a3			.ELSE: 
30a3				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
30a3 20				db WORD_SYS_CORE+12             
30a4 cb 30			dw .DO            
30a6 03				db 2 + 1 
30a7 .. 00			db "ELSE",0              
30ac				endm 
# End of macro CWHEAD
30ac			; | ELSE ( -- ) Not supported - does nothing | TODO 
30ac			 
30ac					if DEBUG_FORTH_WORDS_KEY 
30ac						DMARK "ELS" 
30ac f5				push af  
30ad 3a c1 30			ld a, (.dmark)  
30b0 32 65 ee			ld (debug_mark),a  
30b3 3a c2 30			ld a, (.dmark+1)  
30b6 32 66 ee			ld (debug_mark+1),a  
30b9 3a c3 30			ld a, (.dmark+2)  
30bc 32 67 ee			ld (debug_mark+2),a  
30bf 18 03			jr .pastdmark  
30c1 ..			.dmark: db "ELS"  
30c4 f1			.pastdmark: pop af  
30c5			endm  
# End of macro DMARK
30c5						CALLMONITOR 
30c5 cd 6f ee			call debug_vector  
30c8				endm  
# End of macro CALLMONITOR
30c8					endif 
30c8			 
30c8			 
30c8					NEXTW 
30c8 c3 81 1f			jp macro_next 
30cb				endm 
# End of macro NEXTW
30cb			.DO: 
30cb				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
30cb 21				db WORD_SYS_CORE+13             
30cc f2 31			dw .LOOP            
30ce 03				db 2 + 1 
30cf .. 00			db "DO",0              
30d2				endm 
# End of macro CWHEAD
30d2			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
30d2			 
30d2					if DEBUG_FORTH_WORDS_KEY 
30d2						DMARK "DO." 
30d2 f5				push af  
30d3 3a e7 30			ld a, (.dmark)  
30d6 32 65 ee			ld (debug_mark),a  
30d9 3a e8 30			ld a, (.dmark+1)  
30dc 32 66 ee			ld (debug_mark+1),a  
30df 3a e9 30			ld a, (.dmark+2)  
30e2 32 67 ee			ld (debug_mark+2),a  
30e5 18 03			jr .pastdmark  
30e7 ..			.dmark: db "DO."  
30ea f1			.pastdmark: pop af  
30eb			endm  
# End of macro DMARK
30eb						CALLMONITOR 
30eb cd 6f ee			call debug_vector  
30ee				endm  
# End of macro CALLMONITOR
30ee					endif 
30ee			;  push pc to rsp stack past the DO 
30ee			 
30ee 2a bc e5				ld hl, (os_tok_ptr) 
30f1 23					inc hl   ; D 
30f2 23					inc hl  ; O 
30f3 23					inc hl   ; null 
30f4					if DEBUG_FORTH_WORDS 
30f4						DMARK "DO2" 
30f4 f5				push af  
30f5 3a 09 31			ld a, (.dmark)  
30f8 32 65 ee			ld (debug_mark),a  
30fb 3a 0a 31			ld a, (.dmark+1)  
30fe 32 66 ee			ld (debug_mark+1),a  
3101 3a 0b 31			ld a, (.dmark+2)  
3104 32 67 ee			ld (debug_mark+2),a  
3107 18 03			jr .pastdmark  
3109 ..			.dmark: db "DO2"  
310c f1			.pastdmark: pop af  
310d			endm  
# End of macro DMARK
310d						CALLMONITOR 
310d cd 6f ee			call debug_vector  
3110				endm  
# End of macro CALLMONITOR
3110					endif 
3110					FORTH_RSP_NEXT 
3110 cd 37 1b			call macro_forth_rsp_next 
3113				endm 
# End of macro FORTH_RSP_NEXT
3113					if DEBUG_FORTH_WORDS 
3113						DMARK "DO3" 
3113 f5				push af  
3114 3a 28 31			ld a, (.dmark)  
3117 32 65 ee			ld (debug_mark),a  
311a 3a 29 31			ld a, (.dmark+1)  
311d 32 66 ee			ld (debug_mark+1),a  
3120 3a 2a 31			ld a, (.dmark+2)  
3123 32 67 ee			ld (debug_mark+2),a  
3126 18 03			jr .pastdmark  
3128 ..			.dmark: db "DO3"  
312b f1			.pastdmark: pop af  
312c			endm  
# End of macro DMARK
312c						CALLMONITOR 
312c cd 6f ee			call debug_vector  
312f				endm  
# End of macro CALLMONITOR
312f					endif 
312f			 
312f					;if DEBUG_FORTH_WORDS 
312f				;		push hl 
312f			;		endif  
312f			 
312f			; get counters from data stack 
312f			 
312f			 
312f					FORTH_DSP_VALUEHL 
312f cd 95 1d			call macro_dsp_valuehl 
3132				endm 
# End of macro FORTH_DSP_VALUEHL
3132 e5					push hl		 ; hl now has starting counter which needs to be tos 
3133			 
3133					if DEBUG_FORTH_WORDS 
3133						DMARK "DO4" 
3133 f5				push af  
3134 3a 48 31			ld a, (.dmark)  
3137 32 65 ee			ld (debug_mark),a  
313a 3a 49 31			ld a, (.dmark+1)  
313d 32 66 ee			ld (debug_mark+1),a  
3140 3a 4a 31			ld a, (.dmark+2)  
3143 32 67 ee			ld (debug_mark+2),a  
3146 18 03			jr .pastdmark  
3148 ..			.dmark: db "DO4"  
314b f1			.pastdmark: pop af  
314c			endm  
# End of macro DMARK
314c						CALLMONITOR 
314c cd 6f ee			call debug_vector  
314f				endm  
# End of macro CALLMONITOR
314f					endif 
314f					FORTH_DSP_POP 
314f cd 4d 1e			call macro_forth_dsp_pop 
3152				endm 
# End of macro FORTH_DSP_POP
3152			 
3152					if DEBUG_FORTH_WORDS 
3152						DMARK "DO5" 
3152 f5				push af  
3153 3a 67 31			ld a, (.dmark)  
3156 32 65 ee			ld (debug_mark),a  
3159 3a 68 31			ld a, (.dmark+1)  
315c 32 66 ee			ld (debug_mark+1),a  
315f 3a 69 31			ld a, (.dmark+2)  
3162 32 67 ee			ld (debug_mark+2),a  
3165 18 03			jr .pastdmark  
3167 ..			.dmark: db "DO5"  
316a f1			.pastdmark: pop af  
316b			endm  
# End of macro DMARK
316b						CALLMONITOR 
316b cd 6f ee			call debug_vector  
316e				endm  
# End of macro CALLMONITOR
316e					endif 
316e			 
316e					FORTH_DSP_VALUEHL 
316e cd 95 1d			call macro_dsp_valuehl 
3171				endm 
# End of macro FORTH_DSP_VALUEHL
3171			;		push hl		 ; hl now has starting limit counter 
3171			 
3171					if DEBUG_FORTH_WORDS 
3171						DMARK "DO6" 
3171 f5				push af  
3172 3a 86 31			ld a, (.dmark)  
3175 32 65 ee			ld (debug_mark),a  
3178 3a 87 31			ld a, (.dmark+1)  
317b 32 66 ee			ld (debug_mark+1),a  
317e 3a 88 31			ld a, (.dmark+2)  
3181 32 67 ee			ld (debug_mark+2),a  
3184 18 03			jr .pastdmark  
3186 ..			.dmark: db "DO6"  
3189 f1			.pastdmark: pop af  
318a			endm  
# End of macro DMARK
318a						CALLMONITOR 
318a cd 6f ee			call debug_vector  
318d				endm  
# End of macro CALLMONITOR
318d					endif 
318d					FORTH_DSP_POP 
318d cd 4d 1e			call macro_forth_dsp_pop 
3190				endm 
# End of macro FORTH_DSP_POP
3190			 
3190			; put counters on the loop stack 
3190			 
3190			;		pop hl			 ; limit counter 
3190 d1					pop de			; start counter 
3191			 
3191					; push limit counter 
3191			 
3191					if DEBUG_FORTH_WORDS 
3191						DMARK "DO7" 
3191 f5				push af  
3192 3a a6 31			ld a, (.dmark)  
3195 32 65 ee			ld (debug_mark),a  
3198 3a a7 31			ld a, (.dmark+1)  
319b 32 66 ee			ld (debug_mark+1),a  
319e 3a a8 31			ld a, (.dmark+2)  
31a1 32 67 ee			ld (debug_mark+2),a  
31a4 18 03			jr .pastdmark  
31a6 ..			.dmark: db "DO7"  
31a9 f1			.pastdmark: pop af  
31aa			endm  
# End of macro DMARK
31aa						CALLMONITOR 
31aa cd 6f ee			call debug_vector  
31ad				endm  
# End of macro CALLMONITOR
31ad					endif 
31ad					FORTH_LOOP_NEXT 
31ad cd c6 1d			call macro_forth_loop_next 
31b0				endm 
# End of macro FORTH_LOOP_NEXT
31b0			 
31b0					; push start counter 
31b0			 
31b0 eb					ex de, hl 
31b1					if DEBUG_FORTH_WORDS 
31b1						DMARK "DO7" 
31b1 f5				push af  
31b2 3a c6 31			ld a, (.dmark)  
31b5 32 65 ee			ld (debug_mark),a  
31b8 3a c7 31			ld a, (.dmark+1)  
31bb 32 66 ee			ld (debug_mark+1),a  
31be 3a c8 31			ld a, (.dmark+2)  
31c1 32 67 ee			ld (debug_mark+2),a  
31c4 18 03			jr .pastdmark  
31c6 ..			.dmark: db "DO7"  
31c9 f1			.pastdmark: pop af  
31ca			endm  
# End of macro DMARK
31ca						CALLMONITOR 
31ca cd 6f ee			call debug_vector  
31cd				endm  
# End of macro CALLMONITOR
31cd					endif 
31cd					FORTH_LOOP_NEXT 
31cd cd c6 1d			call macro_forth_loop_next 
31d0				endm 
# End of macro FORTH_LOOP_NEXT
31d0			 
31d0			 
31d0					; init first round of I counter 
31d0			 
31d0 22 e0 e5				ld (os_current_i), hl 
31d3			 
31d3					if DEBUG_FORTH_WORDS 
31d3						DMARK "DO8" 
31d3 f5				push af  
31d4 3a e8 31			ld a, (.dmark)  
31d7 32 65 ee			ld (debug_mark),a  
31da 3a e9 31			ld a, (.dmark+1)  
31dd 32 66 ee			ld (debug_mark+1),a  
31e0 3a ea 31			ld a, (.dmark+2)  
31e3 32 67 ee			ld (debug_mark+2),a  
31e6 18 03			jr .pastdmark  
31e8 ..			.dmark: db "DO8"  
31eb f1			.pastdmark: pop af  
31ec			endm  
# End of macro DMARK
31ec						CALLMONITOR 
31ec cd 6f ee			call debug_vector  
31ef				endm  
# End of macro CALLMONITOR
31ef					endif 
31ef			 
31ef					NEXTW 
31ef c3 81 1f			jp macro_next 
31f2				endm 
# End of macro NEXTW
31f2			.LOOP: 
31f2				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31f2 22				db WORD_SYS_CORE+14             
31f3 0a 33			dw .I            
31f5 05				db 4 + 1 
31f6 .. 00			db "LOOP",0              
31fb				endm 
# End of macro CWHEAD
31fb			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31fb			 
31fb				; pop tos as current loop count to hl 
31fb			 
31fb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31fb			 
31fb				FORTH_LOOP_TOS 
31fb cd f9 1d			call macro_forth_loop_tos 
31fe				endm 
# End of macro FORTH_LOOP_TOS
31fe e5				push hl 
31ff			 
31ff					if DEBUG_FORTH_WORDS_KEY 
31ff						DMARK "LOP" 
31ff f5				push af  
3200 3a 14 32			ld a, (.dmark)  
3203 32 65 ee			ld (debug_mark),a  
3206 3a 15 32			ld a, (.dmark+1)  
3209 32 66 ee			ld (debug_mark+1),a  
320c 3a 16 32			ld a, (.dmark+2)  
320f 32 67 ee			ld (debug_mark+2),a  
3212 18 03			jr .pastdmark  
3214 ..			.dmark: db "LOP"  
3217 f1			.pastdmark: pop af  
3218			endm  
# End of macro DMARK
3218						CALLMONITOR 
3218 cd 6f ee			call debug_vector  
321b				endm  
# End of macro CALLMONITOR
321b					endif 
321b				; next item on the stack is the limit. get it 
321b			 
321b			 
321b				FORTH_LOOP_POP 
321b cd 03 1e			call macro_forth_loop_pop 
321e				endm 
# End of macro FORTH_LOOP_POP
321e			 
321e				FORTH_LOOP_TOS 
321e cd f9 1d			call macro_forth_loop_tos 
3221				endm 
# End of macro FORTH_LOOP_TOS
3221			 
3221 d1				pop de		 ; de = i, hl = limit 
3222			 
3222					if DEBUG_FORTH_WORDS 
3222						DMARK "LP1" 
3222 f5				push af  
3223 3a 37 32			ld a, (.dmark)  
3226 32 65 ee			ld (debug_mark),a  
3229 3a 38 32			ld a, (.dmark+1)  
322c 32 66 ee			ld (debug_mark+1),a  
322f 3a 39 32			ld a, (.dmark+2)  
3232 32 67 ee			ld (debug_mark+2),a  
3235 18 03			jr .pastdmark  
3237 ..			.dmark: db "LP1"  
323a f1			.pastdmark: pop af  
323b			endm  
# End of macro DMARK
323b						CALLMONITOR 
323b cd 6f ee			call debug_vector  
323e				endm  
# End of macro CALLMONITOR
323e					endif 
323e			 
323e				; go back to previous word 
323e			 
323e d5				push de    ; save I for inc later 
323f			 
323f			 
323f				; get limit 
323f				;  is I at limit? 
323f			 
323f			 
323f					if DEBUG_FORTH_WORDS 
323f						DMARK "LP1" 
323f f5				push af  
3240 3a 54 32			ld a, (.dmark)  
3243 32 65 ee			ld (debug_mark),a  
3246 3a 55 32			ld a, (.dmark+1)  
3249 32 66 ee			ld (debug_mark+1),a  
324c 3a 56 32			ld a, (.dmark+2)  
324f 32 67 ee			ld (debug_mark+2),a  
3252 18 03			jr .pastdmark  
3254 ..			.dmark: db "LP1"  
3257 f1			.pastdmark: pop af  
3258			endm  
# End of macro DMARK
3258						CALLMONITOR 
3258 cd 6f ee			call debug_vector  
325b				endm  
# End of macro CALLMONITOR
325b					endif 
325b			 
325b ed 52			sbc hl, de 
325d			 
325d			 
325d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
325d			 
325d 20 26				jr nz, .loopnotdone 
325f			 
325f e1				pop hl   ; get rid of saved I 
3260				FORTH_LOOP_POP     ; get rid of limit 
3260 cd 03 1e			call macro_forth_loop_pop 
3263				endm 
# End of macro FORTH_LOOP_POP
3263			 
3263				FORTH_RSP_POP     ; get rid of DO ptr 
3263 cd 58 1b			call macro_forth_rsp_pop 
3266				endm 
# End of macro FORTH_RSP_POP
3266			 
3266			if DEBUG_FORTH_WORDS 
3266						DMARK "LP>" 
3266 f5				push af  
3267 3a 7b 32			ld a, (.dmark)  
326a 32 65 ee			ld (debug_mark),a  
326d 3a 7c 32			ld a, (.dmark+1)  
3270 32 66 ee			ld (debug_mark+1),a  
3273 3a 7d 32			ld a, (.dmark+2)  
3276 32 67 ee			ld (debug_mark+2),a  
3279 18 03			jr .pastdmark  
327b ..			.dmark: db "LP>"  
327e f1			.pastdmark: pop af  
327f			endm  
# End of macro DMARK
327f				CALLMONITOR 
327f cd 6f ee			call debug_vector  
3282				endm  
# End of macro CALLMONITOR
3282			endif 
3282			 
3282					NEXTW 
3282 c3 81 1f			jp macro_next 
3285				endm 
# End of macro NEXTW
3285				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3285			 
3285			.loopnotdone: 
3285			 
3285 e1				pop hl    ; get I 
3286 23				inc hl 
3287			 
3287			   	; save new I 
3287			 
3287			 
3287					; set I counter 
3287			 
3287 22 e0 e5				ld (os_current_i), hl 
328a			 
328a					if DEBUG_FORTH_WORDS 
328a						DMARK "LPN" 
328a f5				push af  
328b 3a 9f 32			ld a, (.dmark)  
328e 32 65 ee			ld (debug_mark),a  
3291 3a a0 32			ld a, (.dmark+1)  
3294 32 66 ee			ld (debug_mark+1),a  
3297 3a a1 32			ld a, (.dmark+2)  
329a 32 67 ee			ld (debug_mark+2),a  
329d 18 03			jr .pastdmark  
329f ..			.dmark: db "LPN"  
32a2 f1			.pastdmark: pop af  
32a3			endm  
# End of macro DMARK
32a3					CALLMONITOR 
32a3 cd 6f ee			call debug_vector  
32a6				endm  
# End of macro CALLMONITOR
32a6					endif 
32a6					 
32a6				FORTH_LOOP_NEXT 
32a6 cd c6 1d			call macro_forth_loop_next 
32a9				endm 
# End of macro FORTH_LOOP_NEXT
32a9			 
32a9			 
32a9					if DEBUG_FORTH_WORDS 
32a9 eb						ex de,hl 
32aa					endif 
32aa			 
32aa			;	; get DO ptr 
32aa			; 
32aa					if DEBUG_FORTH_WORDS 
32aa						DMARK "LP7" 
32aa f5				push af  
32ab 3a bf 32			ld a, (.dmark)  
32ae 32 65 ee			ld (debug_mark),a  
32b1 3a c0 32			ld a, (.dmark+1)  
32b4 32 66 ee			ld (debug_mark+1),a  
32b7 3a c1 32			ld a, (.dmark+2)  
32ba 32 67 ee			ld (debug_mark+2),a  
32bd 18 03			jr .pastdmark  
32bf ..			.dmark: db "LP7"  
32c2 f1			.pastdmark: pop af  
32c3			endm  
# End of macro DMARK
32c3					CALLMONITOR 
32c3 cd 6f ee			call debug_vector  
32c6				endm  
# End of macro CALLMONITOR
32c6					endif 
32c6				FORTH_RSP_TOS 
32c6 cd 4e 1b			call macro_forth_rsp_tos 
32c9				endm 
# End of macro FORTH_RSP_TOS
32c9			 
32c9					if DEBUG_FORTH_WORDS 
32c9						DMARK "LP8" 
32c9 f5				push af  
32ca 3a de 32			ld a, (.dmark)  
32cd 32 65 ee			ld (debug_mark),a  
32d0 3a df 32			ld a, (.dmark+1)  
32d3 32 66 ee			ld (debug_mark+1),a  
32d6 3a e0 32			ld a, (.dmark+2)  
32d9 32 67 ee			ld (debug_mark+2),a  
32dc 18 03			jr .pastdmark  
32de ..			.dmark: db "LP8"  
32e1 f1			.pastdmark: pop af  
32e2			endm  
# End of macro DMARK
32e2					CALLMONITOR 
32e2 cd 6f ee			call debug_vector  
32e5				endm  
# End of macro CALLMONITOR
32e5					endif 
32e5				;push hl 
32e5			 
32e5				; not going to DO any more 
32e5				; get rid of the RSP pointer as DO will add it back in 
32e5				;FORTH_RSP_POP 
32e5				;pop hl 
32e5			 
32e5				;ld hl,(cli_ret_sp) 
32e5				;ld e, (hl) 
32e5				;inc hl 
32e5				;ld d, (hl) 
32e5				;ex de,hl 
32e5 22 bc e5			ld (os_tok_ptr), hl 
32e8					if DEBUG_FORTH_WORDS 
32e8						DMARK "LP<" 
32e8 f5				push af  
32e9 3a fd 32			ld a, (.dmark)  
32ec 32 65 ee			ld (debug_mark),a  
32ef 3a fe 32			ld a, (.dmark+1)  
32f2 32 66 ee			ld (debug_mark+1),a  
32f5 3a ff 32			ld a, (.dmark+2)  
32f8 32 67 ee			ld (debug_mark+2),a  
32fb 18 03			jr .pastdmark  
32fd ..			.dmark: db "LP<"  
3300 f1			.pastdmark: pop af  
3301			endm  
# End of macro DMARK
3301					CALLMONITOR 
3301 cd 6f ee			call debug_vector  
3304				endm  
# End of macro CALLMONITOR
3304				endif 
3304 c3 12 20			jp exec1 
3307			 
3307					 
3307			 
3307			 
3307					NEXTW 
3307 c3 81 1f			jp macro_next 
330a				endm 
# End of macro NEXTW
330a			.I:  
330a			 
330a				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
330a 5e				db WORD_SYS_CORE+74             
330b 35 33			dw .DLOOP            
330d 02				db 1 + 1 
330e .. 00			db "I",0              
3310				endm 
# End of macro CWHEAD
3310			; | I ( -- ) Current loop counter | DONE 
3310					if DEBUG_FORTH_WORDS_KEY 
3310						DMARK "I.." 
3310 f5				push af  
3311 3a 25 33			ld a, (.dmark)  
3314 32 65 ee			ld (debug_mark),a  
3317 3a 26 33			ld a, (.dmark+1)  
331a 32 66 ee			ld (debug_mark+1),a  
331d 3a 27 33			ld a, (.dmark+2)  
3320 32 67 ee			ld (debug_mark+2),a  
3323 18 03			jr .pastdmark  
3325 ..			.dmark: db "I.."  
3328 f1			.pastdmark: pop af  
3329			endm  
# End of macro DMARK
3329						CALLMONITOR 
3329 cd 6f ee			call debug_vector  
332c				endm  
# End of macro CALLMONITOR
332c					endif 
332c			 
332c 2a e0 e5				ld hl,(os_current_i) 
332f cd 90 1b				call forth_push_numhl 
3332			 
3332					NEXTW 
3332 c3 81 1f			jp macro_next 
3335				endm 
# End of macro NEXTW
3335			.DLOOP: 
3335				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3335 5f				db WORD_SYS_CORE+75             
3336 16 34			dw .REPEAT            
3338 06				db 5 + 1 
3339 .. 00			db "-LOOP",0              
333f				endm 
# End of macro CWHEAD
333f			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
333f				; pop tos as current loop count to hl 
333f					if DEBUG_FORTH_WORDS_KEY 
333f						DMARK "-LP" 
333f f5				push af  
3340 3a 54 33			ld a, (.dmark)  
3343 32 65 ee			ld (debug_mark),a  
3346 3a 55 33			ld a, (.dmark+1)  
3349 32 66 ee			ld (debug_mark+1),a  
334c 3a 56 33			ld a, (.dmark+2)  
334f 32 67 ee			ld (debug_mark+2),a  
3352 18 03			jr .pastdmark  
3354 ..			.dmark: db "-LP"  
3357 f1			.pastdmark: pop af  
3358			endm  
# End of macro DMARK
3358						CALLMONITOR 
3358 cd 6f ee			call debug_vector  
335b				endm  
# End of macro CALLMONITOR
335b					endif 
335b			 
335b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
335b			 
335b				FORTH_LOOP_TOS 
335b cd f9 1d			call macro_forth_loop_tos 
335e				endm 
# End of macro FORTH_LOOP_TOS
335e e5				push hl 
335f			 
335f					if DEBUG_FORTH_WORDS 
335f						DMARK "-LP" 
335f f5				push af  
3360 3a 74 33			ld a, (.dmark)  
3363 32 65 ee			ld (debug_mark),a  
3366 3a 75 33			ld a, (.dmark+1)  
3369 32 66 ee			ld (debug_mark+1),a  
336c 3a 76 33			ld a, (.dmark+2)  
336f 32 67 ee			ld (debug_mark+2),a  
3372 18 03			jr .pastdmark  
3374 ..			.dmark: db "-LP"  
3377 f1			.pastdmark: pop af  
3378			endm  
# End of macro DMARK
3378						CALLMONITOR 
3378 cd 6f ee			call debug_vector  
337b				endm  
# End of macro CALLMONITOR
337b					endif 
337b				; next item on the stack is the limit. get it 
337b			 
337b			 
337b				FORTH_LOOP_POP 
337b cd 03 1e			call macro_forth_loop_pop 
337e				endm 
# End of macro FORTH_LOOP_POP
337e			 
337e				FORTH_LOOP_TOS 
337e cd f9 1d			call macro_forth_loop_tos 
3381				endm 
# End of macro FORTH_LOOP_TOS
3381			 
3381 d1				pop de		 ; de = i, hl = limit 
3382			 
3382					if DEBUG_FORTH_WORDS 
3382						DMARK "-L1" 
3382 f5				push af  
3383 3a 97 33			ld a, (.dmark)  
3386 32 65 ee			ld (debug_mark),a  
3389 3a 98 33			ld a, (.dmark+1)  
338c 32 66 ee			ld (debug_mark+1),a  
338f 3a 99 33			ld a, (.dmark+2)  
3392 32 67 ee			ld (debug_mark+2),a  
3395 18 03			jr .pastdmark  
3397 ..			.dmark: db "-L1"  
339a f1			.pastdmark: pop af  
339b			endm  
# End of macro DMARK
339b						CALLMONITOR 
339b cd 6f ee			call debug_vector  
339e				endm  
# End of macro CALLMONITOR
339e					endif 
339e			 
339e				; go back to previous word 
339e			 
339e d5				push de    ; save I for inc later 
339f			 
339f			 
339f				; get limit 
339f				;  is I at limit? 
339f			 
339f			 
339f					if DEBUG_FORTH_WORDS 
339f						DMARK "-L1" 
339f f5				push af  
33a0 3a b4 33			ld a, (.dmark)  
33a3 32 65 ee			ld (debug_mark),a  
33a6 3a b5 33			ld a, (.dmark+1)  
33a9 32 66 ee			ld (debug_mark+1),a  
33ac 3a b6 33			ld a, (.dmark+2)  
33af 32 67 ee			ld (debug_mark+2),a  
33b2 18 03			jr .pastdmark  
33b4 ..			.dmark: db "-L1"  
33b7 f1			.pastdmark: pop af  
33b8			endm  
# End of macro DMARK
33b8						CALLMONITOR 
33b8 cd 6f ee			call debug_vector  
33bb				endm  
# End of macro CALLMONITOR
33bb					endif 
33bb			 
33bb ed 52			sbc hl, de 
33bd			 
33bd			 
33bd				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
33bd			 
33bd 20 26				jr nz, .mloopnotdone 
33bf			 
33bf e1				pop hl   ; get rid of saved I 
33c0				FORTH_LOOP_POP     ; get rid of limit 
33c0 cd 03 1e			call macro_forth_loop_pop 
33c3				endm 
# End of macro FORTH_LOOP_POP
33c3			 
33c3				FORTH_RSP_POP     ; get rid of DO ptr 
33c3 cd 58 1b			call macro_forth_rsp_pop 
33c6				endm 
# End of macro FORTH_RSP_POP
33c6			 
33c6			if DEBUG_FORTH_WORDS 
33c6						DMARK "-L>" 
33c6 f5				push af  
33c7 3a db 33			ld a, (.dmark)  
33ca 32 65 ee			ld (debug_mark),a  
33cd 3a dc 33			ld a, (.dmark+1)  
33d0 32 66 ee			ld (debug_mark+1),a  
33d3 3a dd 33			ld a, (.dmark+2)  
33d6 32 67 ee			ld (debug_mark+2),a  
33d9 18 03			jr .pastdmark  
33db ..			.dmark: db "-L>"  
33de f1			.pastdmark: pop af  
33df			endm  
# End of macro DMARK
33df				CALLMONITOR 
33df cd 6f ee			call debug_vector  
33e2				endm  
# End of macro CALLMONITOR
33e2			endif 
33e2			 
33e2					NEXTW 
33e2 c3 81 1f			jp macro_next 
33e5				endm 
# End of macro NEXTW
33e5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33e5			 
33e5			.mloopnotdone: 
33e5			 
33e5 e1				pop hl    ; get I 
33e6 2b				dec hl 
33e7			 
33e7			   	; save new I 
33e7			 
33e7			 
33e7					; set I counter 
33e7			 
33e7 22 e0 e5				ld (os_current_i), hl 
33ea			 
33ea					 
33ea				FORTH_LOOP_NEXT 
33ea cd c6 1d			call macro_forth_loop_next 
33ed				endm 
# End of macro FORTH_LOOP_NEXT
33ed			 
33ed			 
33ed					if DEBUG_FORTH_WORDS 
33ed eb						ex de,hl 
33ee					endif 
33ee			 
33ee			;	; get DO ptr 
33ee			; 
33ee				FORTH_RSP_TOS 
33ee cd 4e 1b			call macro_forth_rsp_tos 
33f1				endm 
# End of macro FORTH_RSP_TOS
33f1			 
33f1				;push hl 
33f1			 
33f1				; not going to DO any more 
33f1				; get rid of the RSP pointer as DO will add it back in 
33f1				;FORTH_RSP_POP 
33f1				;pop hl 
33f1			 
33f1			 
33f1 22 bc e5			ld (os_tok_ptr), hl 
33f4					if DEBUG_FORTH_WORDS 
33f4						DMARK "-L<" 
33f4 f5				push af  
33f5 3a 09 34			ld a, (.dmark)  
33f8 32 65 ee			ld (debug_mark),a  
33fb 3a 0a 34			ld a, (.dmark+1)  
33fe 32 66 ee			ld (debug_mark+1),a  
3401 3a 0b 34			ld a, (.dmark+2)  
3404 32 67 ee			ld (debug_mark+2),a  
3407 18 03			jr .pastdmark  
3409 ..			.dmark: db "-L<"  
340c f1			.pastdmark: pop af  
340d			endm  
# End of macro DMARK
340d					CALLMONITOR 
340d cd 6f ee			call debug_vector  
3410				endm  
# End of macro CALLMONITOR
3410				endif 
3410 c3 12 20			jp exec1 
3413			 
3413					 
3413			 
3413			 
3413			 
3413				NEXTW 
3413 c3 81 1f			jp macro_next 
3416				endm 
# End of macro NEXTW
3416			 
3416			 
3416			 
3416			 
3416			.REPEAT: 
3416				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3416 71				db WORD_SYS_CORE+93             
3417 69 34			dw .UNTIL            
3419 06				db 5 + 1 
341a .. 00			db "REPEAT",0              
3421				endm 
# End of macro CWHEAD
3421			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3421			;  push pc to rsp stack past the REPEAT 
3421					if DEBUG_FORTH_WORDS_KEY 
3421						DMARK "REP" 
3421 f5				push af  
3422 3a 36 34			ld a, (.dmark)  
3425 32 65 ee			ld (debug_mark),a  
3428 3a 37 34			ld a, (.dmark+1)  
342b 32 66 ee			ld (debug_mark+1),a  
342e 3a 38 34			ld a, (.dmark+2)  
3431 32 67 ee			ld (debug_mark+2),a  
3434 18 03			jr .pastdmark  
3436 ..			.dmark: db "REP"  
3439 f1			.pastdmark: pop af  
343a			endm  
# End of macro DMARK
343a						CALLMONITOR 
343a cd 6f ee			call debug_vector  
343d				endm  
# End of macro CALLMONITOR
343d					endif 
343d			 
343d 2a bc e5				ld hl, (os_tok_ptr) 
3440 23					inc hl   ; R 
3441 23					inc hl  ; E 
3442 23					inc hl   ; P 
3443 23					inc hl   ; E 
3444 23					inc hl   ; A 
3445 23					inc hl   ; T 
3446 23					inc hl   ; zero 
3447					FORTH_RSP_NEXT 
3447 cd 37 1b			call macro_forth_rsp_next 
344a				endm 
# End of macro FORTH_RSP_NEXT
344a			 
344a			 
344a					if DEBUG_FORTH_WORDS 
344a						DMARK "REP" 
344a f5				push af  
344b 3a 5f 34			ld a, (.dmark)  
344e 32 65 ee			ld (debug_mark),a  
3451 3a 60 34			ld a, (.dmark+1)  
3454 32 66 ee			ld (debug_mark+1),a  
3457 3a 61 34			ld a, (.dmark+2)  
345a 32 67 ee			ld (debug_mark+2),a  
345d 18 03			jr .pastdmark  
345f ..			.dmark: db "REP"  
3462 f1			.pastdmark: pop af  
3463			endm  
# End of macro DMARK
3463						;pop bc    ; TODO BUG ?????? what is this for???? 
3463						CALLMONITOR 
3463 cd 6f ee			call debug_vector  
3466				endm  
# End of macro CALLMONITOR
3466					endif 
3466			 
3466					NEXTW 
3466 c3 81 1f			jp macro_next 
3469				endm 
# End of macro NEXTW
3469			;	       NEXTW 
3469			 
3469			.UNTIL: 
3469				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3469 72				db WORD_SYS_CORE+94             
346a 00 35			dw .ENDFLOW            
346c 06				db 5 + 1 
346d .. 00			db "UNTIL",0              
3473				endm 
# End of macro CWHEAD
3473			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3473			 
3473				; pop tos as check 
3473			 
3473				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3473			 
3473				FORTH_DSP_VALUEHL 
3473 cd 95 1d			call macro_dsp_valuehl 
3476				endm 
# End of macro FORTH_DSP_VALUEHL
3476			 
3476					if DEBUG_FORTH_WORDS_KEY 
3476						DMARK "UNT" 
3476 f5				push af  
3477 3a 8b 34			ld a, (.dmark)  
347a 32 65 ee			ld (debug_mark),a  
347d 3a 8c 34			ld a, (.dmark+1)  
3480 32 66 ee			ld (debug_mark+1),a  
3483 3a 8d 34			ld a, (.dmark+2)  
3486 32 67 ee			ld (debug_mark+2),a  
3489 18 03			jr .pastdmark  
348b ..			.dmark: db "UNT"  
348e f1			.pastdmark: pop af  
348f			endm  
# End of macro DMARK
348f						CALLMONITOR 
348f cd 6f ee			call debug_vector  
3492				endm  
# End of macro CALLMONITOR
3492					endif 
3492			 
3492			;	push hl 
3492				FORTH_DSP_POP 
3492 cd 4d 1e			call macro_forth_dsp_pop 
3495				endm 
# End of macro FORTH_DSP_POP
3495			 
3495			;	pop hl 
3495			 
3495				; test if true 
3495			 
3495 cd 1e 0e			call ishlzero 
3498			;	ld a,l 
3498			;	add h 
3498			; 
3498			;	cp 0 
3498			 
3498 20 3e			jr nz, .untilnotdone 
349a			 
349a					if DEBUG_FORTH_WORDS 
349a						DMARK "UNf" 
349a f5				push af  
349b 3a af 34			ld a, (.dmark)  
349e 32 65 ee			ld (debug_mark),a  
34a1 3a b0 34			ld a, (.dmark+1)  
34a4 32 66 ee			ld (debug_mark+1),a  
34a7 3a b1 34			ld a, (.dmark+2)  
34aa 32 67 ee			ld (debug_mark+2),a  
34ad 18 03			jr .pastdmark  
34af ..			.dmark: db "UNf"  
34b2 f1			.pastdmark: pop af  
34b3			endm  
# End of macro DMARK
34b3						CALLMONITOR 
34b3 cd 6f ee			call debug_vector  
34b6				endm  
# End of macro CALLMONITOR
34b6					endif 
34b6			 
34b6			 
34b6			 
34b6				FORTH_RSP_POP     ; get rid of DO ptr 
34b6 cd 58 1b			call macro_forth_rsp_pop 
34b9				endm 
# End of macro FORTH_RSP_POP
34b9			 
34b9			if DEBUG_FORTH_WORDS 
34b9						DMARK "UN>" 
34b9 f5				push af  
34ba 3a ce 34			ld a, (.dmark)  
34bd 32 65 ee			ld (debug_mark),a  
34c0 3a cf 34			ld a, (.dmark+1)  
34c3 32 66 ee			ld (debug_mark+1),a  
34c6 3a d0 34			ld a, (.dmark+2)  
34c9 32 67 ee			ld (debug_mark+2),a  
34cc 18 03			jr .pastdmark  
34ce ..			.dmark: db "UN>"  
34d1 f1			.pastdmark: pop af  
34d2			endm  
# End of macro DMARK
34d2				CALLMONITOR 
34d2 cd 6f ee			call debug_vector  
34d5				endm  
# End of macro CALLMONITOR
34d5			endif 
34d5			 
34d5					NEXTW 
34d5 c3 81 1f			jp macro_next 
34d8				endm 
# End of macro NEXTW
34d8				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34d8			 
34d8			.untilnotdone: 
34d8			 
34d8			 
34d8			;	; get DO ptr 
34d8			; 
34d8				FORTH_RSP_TOS 
34d8 cd 4e 1b			call macro_forth_rsp_tos 
34db				endm 
# End of macro FORTH_RSP_TOS
34db			 
34db				;push hl 
34db			 
34db				; not going to DO any more 
34db				; get rid of the RSP pointer as DO will add it back in 
34db				;FORTH_RSP_POP 
34db				;pop hl 
34db			 
34db			 
34db 22 bc e5			ld (os_tok_ptr), hl 
34de					if DEBUG_FORTH_WORDS 
34de						DMARK "UN<" 
34de f5				push af  
34df 3a f3 34			ld a, (.dmark)  
34e2 32 65 ee			ld (debug_mark),a  
34e5 3a f4 34			ld a, (.dmark+1)  
34e8 32 66 ee			ld (debug_mark+1),a  
34eb 3a f5 34			ld a, (.dmark+2)  
34ee 32 67 ee			ld (debug_mark+2),a  
34f1 18 03			jr .pastdmark  
34f3 ..			.dmark: db "UN<"  
34f6 f1			.pastdmark: pop af  
34f7			endm  
# End of macro DMARK
34f7					CALLMONITOR 
34f7 cd 6f ee			call debug_vector  
34fa				endm  
# End of macro CALLMONITOR
34fa				endif 
34fa c3 12 20			jp exec1 
34fd			 
34fd					 
34fd			 
34fd			 
34fd					NEXTW 
34fd c3 81 1f			jp macro_next 
3500				endm 
# End of macro NEXTW
3500			 
3500			 
3500			.ENDFLOW: 
3500			 
3500			; eof 
3500			 
# End of file forth_words_flow.asm
3500			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3500			include "forth_words_logic.asm" 
3500			 
3500			; | ## Logic Words 
3500			 
3500			.NOT: 
3500				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3500 2d				db WORD_SYS_CORE+25             
3501 48 35			dw .IS            
3503 04				db 3 + 1 
3504 .. 00			db "NOT",0              
3508				endm 
# End of macro CWHEAD
3508			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3508					if DEBUG_FORTH_WORDS_KEY 
3508						DMARK "NOT" 
3508 f5				push af  
3509 3a 1d 35			ld a, (.dmark)  
350c 32 65 ee			ld (debug_mark),a  
350f 3a 1e 35			ld a, (.dmark+1)  
3512 32 66 ee			ld (debug_mark+1),a  
3515 3a 1f 35			ld a, (.dmark+2)  
3518 32 67 ee			ld (debug_mark+2),a  
351b 18 03			jr .pastdmark  
351d ..			.dmark: db "NOT"  
3520 f1			.pastdmark: pop af  
3521			endm  
# End of macro DMARK
3521						CALLMONITOR 
3521 cd 6f ee			call debug_vector  
3524				endm  
# End of macro CALLMONITOR
3524					endif 
3524					FORTH_DSP 
3524 cd 5b 1d			call macro_forth_dsp 
3527				endm 
# End of macro FORTH_DSP
3527 7e					ld a,(hl)	; get type of value on TOS 
3528 fe 02				cp DS_TYPE_INUM  
352a 28 03				jr z, .noti 
352c					NEXTW 
352c c3 81 1f			jp macro_next 
352f				endm 
# End of macro NEXTW
352f			.noti:          FORTH_DSP_VALUEHL 
352f cd 95 1d			call macro_dsp_valuehl 
3532				endm 
# End of macro FORTH_DSP_VALUEHL
3532			;		push hl 
3532					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3532 cd 4d 1e			call macro_forth_dsp_pop 
3535				endm 
# End of macro FORTH_DSP_POP
3535			;		pop hl 
3535 3e 00				ld a,0 
3537 bd					cp l 
3538 28 04				jr z, .not2t 
353a 2e 00				ld l, 0 
353c 18 02				jr .notip 
353e			 
353e 2e ff		.not2t:		ld l, 255 
3540			 
3540 26 00		.notip:		ld h, 0	 
3542			 
3542 cd 90 1b				call forth_push_numhl 
3545					NEXTW 
3545 c3 81 1f			jp macro_next 
3548				endm 
# End of macro NEXTW
3548			 
3548			.IS: 
3548				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3548 2d				db WORD_SYS_CORE+25             
3549 6e 35			dw .LZERO            
354b 03				db 2 + 1 
354c .. 00			db "IS",0              
354f				endm 
# End of macro CWHEAD
354f			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
354f					if DEBUG_FORTH_WORDS_KEY 
354f						DMARK "IS." 
354f f5				push af  
3550 3a 64 35			ld a, (.dmark)  
3553 32 65 ee			ld (debug_mark),a  
3556 3a 65 35			ld a, (.dmark+1)  
3559 32 66 ee			ld (debug_mark+1),a  
355c 3a 66 35			ld a, (.dmark+2)  
355f 32 67 ee			ld (debug_mark+2),a  
3562 18 03			jr .pastdmark  
3564 ..			.dmark: db "IS."  
3567 f1			.pastdmark: pop af  
3568			endm  
# End of macro DMARK
3568						CALLMONITOR 
3568 cd 6f ee			call debug_vector  
356b				endm  
# End of macro CALLMONITOR
356b					endif 
356b					NEXTW 
356b c3 81 1f			jp macro_next 
356e				endm 
# End of macro NEXTW
356e			.LZERO: 
356e				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
356e 2d				db WORD_SYS_CORE+25             
356f 78 35			dw .TZERO            
3571 03				db 2 + 1 
3572 .. 00			db "0<",0              
3575				endm 
# End of macro CWHEAD
3575			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3575					NEXTW 
3575 c3 81 1f			jp macro_next 
3578				endm 
# End of macro NEXTW
3578			.TZERO: 
3578				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3578 2e				db WORD_SYS_CORE+26             
3579 bf 35			dw .LESS            
357b 03				db 2 + 1 
357c .. 00			db "0=",0              
357f				endm 
# End of macro CWHEAD
357f			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
357f				; TODO add floating point number detection 
357f					;v5 FORTH_DSP_VALUE 
357f					if DEBUG_FORTH_WORDS_KEY 
357f						DMARK "0=." 
357f f5				push af  
3580 3a 94 35			ld a, (.dmark)  
3583 32 65 ee			ld (debug_mark),a  
3586 3a 95 35			ld a, (.dmark+1)  
3589 32 66 ee			ld (debug_mark+1),a  
358c 3a 96 35			ld a, (.dmark+2)  
358f 32 67 ee			ld (debug_mark+2),a  
3592 18 03			jr .pastdmark  
3594 ..			.dmark: db "0=."  
3597 f1			.pastdmark: pop af  
3598			endm  
# End of macro DMARK
3598						CALLMONITOR 
3598 cd 6f ee			call debug_vector  
359b				endm  
# End of macro CALLMONITOR
359b					endif 
359b					FORTH_DSP 
359b cd 5b 1d			call macro_forth_dsp 
359e				endm 
# End of macro FORTH_DSP
359e 7e					ld a,(hl)	; get type of value on TOS 
359f fe 02				cp DS_TYPE_INUM  
35a1 28 00				jr z, .tz_inum 
35a3			 
35a3				if FORTH_ENABLE_FLOATMATH 
35a3					jr .tz_done 
35a3			 
35a3				endif 
35a3					 
35a3			 
35a3			.tz_inum: 
35a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a3 cd 95 1d			call macro_dsp_valuehl 
35a6				endm 
# End of macro FORTH_DSP_VALUEHL
35a6			 
35a6			;		push hl 
35a6			 
35a6					; destroy value TOS 
35a6			 
35a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a6 cd 4d 1e			call macro_forth_dsp_pop 
35a9				endm 
# End of macro FORTH_DSP_POP
35a9			 
35a9			;		pop hl 
35a9			 
35a9 3e 00				ld a,0 
35ab			 
35ab bd					cp l 
35ac 20 08				jr nz, .tz_notzero 
35ae			 
35ae bc					cp h 
35af			 
35af 20 05				jr nz, .tz_notzero 
35b1			 
35b1			 
35b1 21 01 00				ld hl, FORTH_TRUE 
35b4 18 03				jr .tz_done 
35b6			 
35b6 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
35b9			 
35b9					; push value back onto stack for another op etc 
35b9			 
35b9			.tz_done: 
35b9 cd 90 1b				call forth_push_numhl 
35bc			 
35bc					NEXTW 
35bc c3 81 1f			jp macro_next 
35bf				endm 
# End of macro NEXTW
35bf			.LESS: 
35bf				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
35bf 2f				db WORD_SYS_CORE+27             
35c0 28 36			dw .GT            
35c2 02				db 1 + 1 
35c3 .. 00			db "<",0              
35c5				endm 
# End of macro CWHEAD
35c5			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
35c5				; TODO add floating point number detection 
35c5					if DEBUG_FORTH_WORDS_KEY 
35c5						DMARK "LES" 
35c5 f5				push af  
35c6 3a da 35			ld a, (.dmark)  
35c9 32 65 ee			ld (debug_mark),a  
35cc 3a db 35			ld a, (.dmark+1)  
35cf 32 66 ee			ld (debug_mark+1),a  
35d2 3a dc 35			ld a, (.dmark+2)  
35d5 32 67 ee			ld (debug_mark+2),a  
35d8 18 03			jr .pastdmark  
35da ..			.dmark: db "LES"  
35dd f1			.pastdmark: pop af  
35de			endm  
# End of macro DMARK
35de						CALLMONITOR 
35de cd 6f ee			call debug_vector  
35e1				endm  
# End of macro CALLMONITOR
35e1					endif 
35e1					FORTH_DSP 
35e1 cd 5b 1d			call macro_forth_dsp 
35e4				endm 
# End of macro FORTH_DSP
35e4					;v5 FORTH_DSP_VALUE 
35e4 7e					ld a,(hl)	; get type of value on TOS 
35e5 fe 02				cp DS_TYPE_INUM  
35e7 28 00				jr z, .less_inum 
35e9			 
35e9				if FORTH_ENABLE_FLOATMATH 
35e9					jr .less_done 
35e9			 
35e9				endif 
35e9					 
35e9			 
35e9			.less_inum: 
35e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e9 cd 95 1d			call macro_dsp_valuehl 
35ec				endm 
# End of macro FORTH_DSP_VALUEHL
35ec			 
35ec e5					push hl  ; u2 
35ed			 
35ed					; destroy value TOS 
35ed			 
35ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ed cd 4d 1e			call macro_forth_dsp_pop 
35f0				endm 
# End of macro FORTH_DSP_POP
35f0			 
35f0			 
35f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35f0 cd 95 1d			call macro_dsp_valuehl 
35f3				endm 
# End of macro FORTH_DSP_VALUEHL
35f3			 
35f3 e5					push hl    ; u1 
35f4			 
35f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f4 cd 4d 1e			call macro_forth_dsp_pop 
35f7				endm 
# End of macro FORTH_DSP_POP
35f7			 
35f7			 
35f7 b7			 or a      ;clear carry flag 
35f8 01 00 00		 ld bc, FORTH_FALSE 
35fb e1			  pop hl    ; u1 
35fc d1			  pop de    ; u2 
35fd ed 52		  sbc hl,de 
35ff 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3601			 
3601 01 01 00		 ld bc, FORTH_TRUE 
3604			.lscont:  
3604 c5					push bc 
3605 e1					pop hl 
3606			 
3606					if DEBUG_FORTH_WORDS 
3606						DMARK "LT1" 
3606 f5				push af  
3607 3a 1b 36			ld a, (.dmark)  
360a 32 65 ee			ld (debug_mark),a  
360d 3a 1c 36			ld a, (.dmark+1)  
3610 32 66 ee			ld (debug_mark+1),a  
3613 3a 1d 36			ld a, (.dmark+2)  
3616 32 67 ee			ld (debug_mark+2),a  
3619 18 03			jr .pastdmark  
361b ..			.dmark: db "LT1"  
361e f1			.pastdmark: pop af  
361f			endm  
# End of macro DMARK
361f						CALLMONITOR 
361f cd 6f ee			call debug_vector  
3622				endm  
# End of macro CALLMONITOR
3622					endif 
3622 cd 90 1b				call forth_push_numhl 
3625			 
3625					NEXTW 
3625 c3 81 1f			jp macro_next 
3628				endm 
# End of macro NEXTW
3628			.GT: 
3628				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3628 30				db WORD_SYS_CORE+28             
3629 91 36			dw .EQUAL            
362b 02				db 1 + 1 
362c .. 00			db ">",0              
362e				endm 
# End of macro CWHEAD
362e			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
362e				; TODO add floating point number detection 
362e					if DEBUG_FORTH_WORDS_KEY 
362e						DMARK "GRT" 
362e f5				push af  
362f 3a 43 36			ld a, (.dmark)  
3632 32 65 ee			ld (debug_mark),a  
3635 3a 44 36			ld a, (.dmark+1)  
3638 32 66 ee			ld (debug_mark+1),a  
363b 3a 45 36			ld a, (.dmark+2)  
363e 32 67 ee			ld (debug_mark+2),a  
3641 18 03			jr .pastdmark  
3643 ..			.dmark: db "GRT"  
3646 f1			.pastdmark: pop af  
3647			endm  
# End of macro DMARK
3647						CALLMONITOR 
3647 cd 6f ee			call debug_vector  
364a				endm  
# End of macro CALLMONITOR
364a					endif 
364a					FORTH_DSP 
364a cd 5b 1d			call macro_forth_dsp 
364d				endm 
# End of macro FORTH_DSP
364d					;FORTH_DSP_VALUE 
364d 7e					ld a,(hl)	; get type of value on TOS 
364e fe 02				cp DS_TYPE_INUM  
3650 28 00				jr z, .gt_inum 
3652			 
3652				if FORTH_ENABLE_FLOATMATH 
3652					jr .gt_done 
3652			 
3652				endif 
3652					 
3652			 
3652			.gt_inum: 
3652					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3652 cd 95 1d			call macro_dsp_valuehl 
3655				endm 
# End of macro FORTH_DSP_VALUEHL
3655			 
3655 e5					push hl  ; u2 
3656			 
3656					; destroy value TOS 
3656			 
3656					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3656 cd 4d 1e			call macro_forth_dsp_pop 
3659				endm 
# End of macro FORTH_DSP_POP
3659			 
3659			 
3659					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3659 cd 95 1d			call macro_dsp_valuehl 
365c				endm 
# End of macro FORTH_DSP_VALUEHL
365c			 
365c e5					push hl    ; u1 
365d			 
365d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
365d cd 4d 1e			call macro_forth_dsp_pop 
3660				endm 
# End of macro FORTH_DSP_POP
3660			 
3660			 
3660 b7			 or a      ;clear carry flag 
3661 01 00 00		 ld bc, FORTH_FALSE 
3664 e1			  pop hl    ; u1 
3665 d1			  pop de    ; u2 
3666 ed 52		  sbc hl,de 
3668 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
366a			 
366a 01 01 00		 ld bc, FORTH_TRUE 
366d			.gtcont:  
366d c5					push bc 
366e e1					pop hl 
366f			 
366f					if DEBUG_FORTH_WORDS 
366f						DMARK "GT1" 
366f f5				push af  
3670 3a 84 36			ld a, (.dmark)  
3673 32 65 ee			ld (debug_mark),a  
3676 3a 85 36			ld a, (.dmark+1)  
3679 32 66 ee			ld (debug_mark+1),a  
367c 3a 86 36			ld a, (.dmark+2)  
367f 32 67 ee			ld (debug_mark+2),a  
3682 18 03			jr .pastdmark  
3684 ..			.dmark: db "GT1"  
3687 f1			.pastdmark: pop af  
3688			endm  
# End of macro DMARK
3688						CALLMONITOR 
3688 cd 6f ee			call debug_vector  
368b				endm  
# End of macro CALLMONITOR
368b					endif 
368b cd 90 1b				call forth_push_numhl 
368e			 
368e					NEXTW 
368e c3 81 1f			jp macro_next 
3691				endm 
# End of macro NEXTW
3691			.EQUAL: 
3691				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3691 31				db WORD_SYS_CORE+29             
3692 fc 36			dw .ENDLOGIC            
3694 02				db 1 + 1 
3695 .. 00			db "=",0              
3697				endm 
# End of macro CWHEAD
3697			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3697				; TODO add floating point number detection 
3697					if DEBUG_FORTH_WORDS_KEY 
3697						DMARK "EQ." 
3697 f5				push af  
3698 3a ac 36			ld a, (.dmark)  
369b 32 65 ee			ld (debug_mark),a  
369e 3a ad 36			ld a, (.dmark+1)  
36a1 32 66 ee			ld (debug_mark+1),a  
36a4 3a ae 36			ld a, (.dmark+2)  
36a7 32 67 ee			ld (debug_mark+2),a  
36aa 18 03			jr .pastdmark  
36ac ..			.dmark: db "EQ."  
36af f1			.pastdmark: pop af  
36b0			endm  
# End of macro DMARK
36b0						CALLMONITOR 
36b0 cd 6f ee			call debug_vector  
36b3				endm  
# End of macro CALLMONITOR
36b3					endif 
36b3					FORTH_DSP 
36b3 cd 5b 1d			call macro_forth_dsp 
36b6				endm 
# End of macro FORTH_DSP
36b6					;v5 FORTH_DSP_VALUE 
36b6 7e					ld a,(hl)	; get type of value on TOS 
36b7 fe 02				cp DS_TYPE_INUM  
36b9 28 00				jr z, .eq_inum 
36bb			 
36bb				if FORTH_ENABLE_FLOATMATH 
36bb					jr .eq_done 
36bb			 
36bb				endif 
36bb					 
36bb			 
36bb			.eq_inum: 
36bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36bb cd 95 1d			call macro_dsp_valuehl 
36be				endm 
# End of macro FORTH_DSP_VALUEHL
36be			 
36be e5					push hl 
36bf			 
36bf					; destroy value TOS 
36bf			 
36bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36bf cd 4d 1e			call macro_forth_dsp_pop 
36c2				endm 
# End of macro FORTH_DSP_POP
36c2			 
36c2			 
36c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36c2 cd 95 1d			call macro_dsp_valuehl 
36c5				endm 
# End of macro FORTH_DSP_VALUEHL
36c5			 
36c5					; one value on hl get other one back 
36c5			 
36c5 e5					push hl 
36c6			 
36c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c6 cd 4d 1e			call macro_forth_dsp_pop 
36c9				endm 
# End of macro FORTH_DSP_POP
36c9			 
36c9 0e 00				ld c, FORTH_FALSE 
36cb			 
36cb e1					pop hl 
36cc d1					pop de 
36cd			 
36cd 7b					ld a, e 
36ce bd					cp l 
36cf			 
36cf 20 06				jr nz, .eq_done 
36d1			 
36d1 7a					ld a, d 
36d2 bc					cp h 
36d3			 
36d3 20 02				jr nz, .eq_done 
36d5			 
36d5 0e 01				ld c, FORTH_TRUE 
36d7					 
36d7			 
36d7			 
36d7			.eq_done: 
36d7			 
36d7					; TODO push value back onto stack for another op etc 
36d7			 
36d7 26 00				ld h, 0 
36d9 69					ld l, c 
36da					if DEBUG_FORTH_WORDS 
36da						DMARK "EQ1" 
36da f5				push af  
36db 3a ef 36			ld a, (.dmark)  
36de 32 65 ee			ld (debug_mark),a  
36e1 3a f0 36			ld a, (.dmark+1)  
36e4 32 66 ee			ld (debug_mark+1),a  
36e7 3a f1 36			ld a, (.dmark+2)  
36ea 32 67 ee			ld (debug_mark+2),a  
36ed 18 03			jr .pastdmark  
36ef ..			.dmark: db "EQ1"  
36f2 f1			.pastdmark: pop af  
36f3			endm  
# End of macro DMARK
36f3						CALLMONITOR 
36f3 cd 6f ee			call debug_vector  
36f6				endm  
# End of macro CALLMONITOR
36f6					endif 
36f6 cd 90 1b				call forth_push_numhl 
36f9			 
36f9					NEXTW 
36f9 c3 81 1f			jp macro_next 
36fc				endm 
# End of macro NEXTW
36fc			 
36fc			 
36fc			.ENDLOGIC: 
36fc			; eof 
36fc			 
36fc			 
# End of file forth_words_logic.asm
36fc			include "forth_words_maths.asm" 
36fc			 
36fc			; | ## Maths Words 
36fc			 
36fc			.PLUS:	 
36fc				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36fc 15				db WORD_SYS_CORE+1             
36fd 5a 37			dw .NEG            
36ff 02				db 1 + 1 
3700 .. 00			db "+",0              
3702				endm 
# End of macro CWHEAD
3702			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3702					if DEBUG_FORTH_WORDS_KEY 
3702						DMARK "PLU" 
3702 f5				push af  
3703 3a 17 37			ld a, (.dmark)  
3706 32 65 ee			ld (debug_mark),a  
3709 3a 18 37			ld a, (.dmark+1)  
370c 32 66 ee			ld (debug_mark+1),a  
370f 3a 19 37			ld a, (.dmark+2)  
3712 32 67 ee			ld (debug_mark+2),a  
3715 18 03			jr .pastdmark  
3717 ..			.dmark: db "PLU"  
371a f1			.pastdmark: pop af  
371b			endm  
# End of macro DMARK
371b						CALLMONITOR 
371b cd 6f ee			call debug_vector  
371e				endm  
# End of macro CALLMONITOR
371e					endif 
371e					; add top two values and push back result 
371e			 
371e					;for v5 FORTH_DSP_VALUE 
371e					FORTH_DSP 
371e cd 5b 1d			call macro_forth_dsp 
3721				endm 
# End of macro FORTH_DSP
3721 7e					ld a,(hl)	; get type of value on TOS 
3722 fe 02				cp DS_TYPE_INUM  
3724 28 03				jr z, .dot_inum 
3726			 
3726					NEXTW 
3726 c3 81 1f			jp macro_next 
3729				endm 
# End of macro NEXTW
3729			 
3729			; float maths 
3729			 
3729				if FORTH_ENABLE_FLOATMATH 
3729						inc hl      ; now at start of numeric as string 
3729			 
3729					if DEBUG_FORTH_MATHS 
3729						DMARK "ADD" 
3729				CALLMONITOR 
3729					endif 
3729			 
3729					;ld ix, hl 
3729					call CON 
3729			 
3729			 
3729					push hl 
3729					 
3729					 
3729			 
3729						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3729			 
3729					; get next number 
3729			 
3729						FORTH_DSP_VALUE 
3729			 
3729						inc hl      ; now at start of numeric as string 
3729			 
3729					;ld ix, hl 
3729					call CON 
3729			 
3729					push hl 
3729			 
3729			 
3729						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3729			 
3729						; TODO do add 
3729			 
3729						call IADD 
3729			 
3729						; TODO get result back as ascii 
3729			 
3729						; TODO push result  
3729			 
3729			 
3729			 
3729						jr .dot_done 
3729				endif 
3729			 
3729			.dot_inum: 
3729			 
3729			 
3729					if DEBUG_FORTH_DOT 
3729						DMARK "+IT" 
3729 f5				push af  
372a 3a 3e 37			ld a, (.dmark)  
372d 32 65 ee			ld (debug_mark),a  
3730 3a 3f 37			ld a, (.dmark+1)  
3733 32 66 ee			ld (debug_mark+1),a  
3736 3a 40 37			ld a, (.dmark+2)  
3739 32 67 ee			ld (debug_mark+2),a  
373c 18 03			jr .pastdmark  
373e ..			.dmark: db "+IT"  
3741 f1			.pastdmark: pop af  
3742			endm  
# End of macro DMARK
3742				CALLMONITOR 
3742 cd 6f ee			call debug_vector  
3745				endm  
# End of macro CALLMONITOR
3745					endif 
3745			 
3745					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3745 cd 95 1d			call macro_dsp_valuehl 
3748				endm 
# End of macro FORTH_DSP_VALUEHL
3748			 
3748				; TODO add floating point number detection 
3748			 
3748 e5					push hl 
3749			 
3749					; destroy value TOS 
3749			 
3749					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3749 cd 4d 1e			call macro_forth_dsp_pop 
374c				endm 
# End of macro FORTH_DSP_POP
374c			 
374c			 
374c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
374c cd 95 1d			call macro_dsp_valuehl 
374f				endm 
# End of macro FORTH_DSP_VALUEHL
374f			 
374f					; one value on hl get other one back 
374f			 
374f d1					pop de 
3750			 
3750					; do the add 
3750			 
3750 19					add hl,de 
3751			 
3751					; save it 
3751			 
3751			;		push hl	 
3751			 
3751					; 
3751			 
3751					; destroy value TOS 
3751			 
3751					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3751 cd 4d 1e			call macro_forth_dsp_pop 
3754				endm 
# End of macro FORTH_DSP_POP
3754			 
3754					; TODO push value back onto stack for another op etc 
3754			 
3754			;		pop hl 
3754			 
3754			.dot_done: 
3754 cd 90 1b				call forth_push_numhl 
3757			 
3757					NEXTW 
3757 c3 81 1f			jp macro_next 
375a				endm 
# End of macro NEXTW
375a			.NEG: 
375a			 
375a				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
375a 17				db WORD_SYS_CORE+3             
375b 9d 37			dw .DIV            
375d 02				db 1 + 1 
375e .. 00			db "-",0              
3760				endm 
# End of macro CWHEAD
3760			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3760					if DEBUG_FORTH_WORDS_KEY 
3760						DMARK "SUB" 
3760 f5				push af  
3761 3a 75 37			ld a, (.dmark)  
3764 32 65 ee			ld (debug_mark),a  
3767 3a 76 37			ld a, (.dmark+1)  
376a 32 66 ee			ld (debug_mark+1),a  
376d 3a 77 37			ld a, (.dmark+2)  
3770 32 67 ee			ld (debug_mark+2),a  
3773 18 03			jr .pastdmark  
3775 ..			.dmark: db "SUB"  
3778 f1			.pastdmark: pop af  
3779			endm  
# End of macro DMARK
3779						CALLMONITOR 
3779 cd 6f ee			call debug_vector  
377c				endm  
# End of macro CALLMONITOR
377c					endif 
377c			 
377c			 
377c				; TODO add floating point number detection 
377c					; v5 FORTH_DSP_VALUE 
377c					FORTH_DSP 
377c cd 5b 1d			call macro_forth_dsp 
377f				endm 
# End of macro FORTH_DSP
377f 7e					ld a,(hl)	; get type of value on TOS 
3780 fe 02				cp DS_TYPE_INUM  
3782 28 03				jr z, .neg_inum 
3784			 
3784					NEXTW 
3784 c3 81 1f			jp macro_next 
3787				endm 
# End of macro NEXTW
3787			 
3787			; float maths 
3787			 
3787				if FORTH_ENABLE_FLOATMATH 
3787					jr .neg_done 
3787			 
3787				endif 
3787					 
3787			 
3787			.neg_inum: 
3787					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3787 cd 95 1d			call macro_dsp_valuehl 
378a				endm 
# End of macro FORTH_DSP_VALUEHL
378a			 
378a e5					push hl 
378b			 
378b					; destroy value TOS 
378b			 
378b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378b cd 4d 1e			call macro_forth_dsp_pop 
378e				endm 
# End of macro FORTH_DSP_POP
378e			 
378e			 
378e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
378e cd 95 1d			call macro_dsp_valuehl 
3791				endm 
# End of macro FORTH_DSP_VALUEHL
3791			 
3791					; one value on hl get other one back 
3791			 
3791 d1					pop de 
3792			 
3792					; do the sub 
3792			;		ex de, hl 
3792			 
3792 ed 52				sbc hl,de 
3794			 
3794					; save it 
3794			 
3794			;		push hl	 
3794			 
3794					; 
3794			 
3794					; destroy value TOS 
3794			 
3794					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3794 cd 4d 1e			call macro_forth_dsp_pop 
3797				endm 
# End of macro FORTH_DSP_POP
3797			 
3797					; TODO push value back onto stack for another op etc 
3797			 
3797			;		pop hl 
3797			 
3797 cd 90 1b				call forth_push_numhl 
379a			.neg_done: 
379a			 
379a					NEXTW 
379a c3 81 1f			jp macro_next 
379d				endm 
# End of macro NEXTW
379d			.DIV: 
379d				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
379d 18				db WORD_SYS_CORE+4             
379e ea 37			dw .MUL            
37a0 02				db 1 + 1 
37a1 .. 00			db "/",0              
37a3				endm 
# End of macro CWHEAD
37a3			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
37a3					if DEBUG_FORTH_WORDS_KEY 
37a3						DMARK "DIV" 
37a3 f5				push af  
37a4 3a b8 37			ld a, (.dmark)  
37a7 32 65 ee			ld (debug_mark),a  
37aa 3a b9 37			ld a, (.dmark+1)  
37ad 32 66 ee			ld (debug_mark+1),a  
37b0 3a ba 37			ld a, (.dmark+2)  
37b3 32 67 ee			ld (debug_mark+2),a  
37b6 18 03			jr .pastdmark  
37b8 ..			.dmark: db "DIV"  
37bb f1			.pastdmark: pop af  
37bc			endm  
# End of macro DMARK
37bc						CALLMONITOR 
37bc cd 6f ee			call debug_vector  
37bf				endm  
# End of macro CALLMONITOR
37bf					endif 
37bf				; TODO add floating point number detection 
37bf					; v5 FORTH_DSP_VALUE 
37bf					FORTH_DSP 
37bf cd 5b 1d			call macro_forth_dsp 
37c2				endm 
# End of macro FORTH_DSP
37c2 7e					ld a,(hl)	; get type of value on TOS 
37c3 fe 02				cp DS_TYPE_INUM  
37c5 28 03				jr z, .div_inum 
37c7			 
37c7				if FORTH_ENABLE_FLOATMATH 
37c7					jr .div_done 
37c7			 
37c7				endif 
37c7					NEXTW 
37c7 c3 81 1f			jp macro_next 
37ca				endm 
# End of macro NEXTW
37ca			.div_inum: 
37ca			 
37ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ca cd 95 1d			call macro_dsp_valuehl 
37cd				endm 
# End of macro FORTH_DSP_VALUEHL
37cd			 
37cd e5					push hl    ; to go to bc 
37ce			 
37ce					; destroy value TOS 
37ce			 
37ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ce cd 4d 1e			call macro_forth_dsp_pop 
37d1				endm 
# End of macro FORTH_DSP_POP
37d1			 
37d1			 
37d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d1 cd 95 1d			call macro_dsp_valuehl 
37d4				endm 
# End of macro FORTH_DSP_VALUEHL
37d4			 
37d4					; hl to go to de 
37d4			 
37d4 e5					push hl 
37d5			 
37d5 c1					pop bc 
37d6 d1					pop de		 
37d7			 
37d7			 
37d7					if DEBUG_FORTH_MATHS 
37d7						DMARK "DIV" 
37d7				CALLMONITOR 
37d7					endif 
37d7					; one value on hl but move to a get other one back 
37d7			 
37d7			        
37d7 cd 52 0d			call Div16 
37da			 
37da			;	push af	 
37da e5				push hl 
37db c5				push bc 
37dc			 
37dc					if DEBUG_FORTH_MATHS 
37dc						DMARK "DI1" 
37dc				CALLMONITOR 
37dc					endif 
37dc			 
37dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37dc cd 4d 1e			call macro_forth_dsp_pop 
37df				endm 
# End of macro FORTH_DSP_POP
37df			 
37df			 
37df			 
37df e1					pop hl    ; result 
37e0			 
37e0 cd 90 1b				call forth_push_numhl 
37e3			 
37e3 e1					pop hl    ; reminder 
37e4			;		ld h,0 
37e4			;		ld l,d 
37e4			 
37e4 cd 90 1b				call forth_push_numhl 
37e7			.div_done: 
37e7					NEXTW 
37e7 c3 81 1f			jp macro_next 
37ea				endm 
# End of macro NEXTW
37ea			.MUL: 
37ea				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
37ea 19				db WORD_SYS_CORE+5             
37eb 2f 38			dw .MIN            
37ed 02				db 1 + 1 
37ee .. 00			db "*",0              
37f0				endm 
# End of macro CWHEAD
37f0			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37f0				; TODO add floating point number detection 
37f0					if DEBUG_FORTH_WORDS_KEY 
37f0						DMARK "MUL" 
37f0 f5				push af  
37f1 3a 05 38			ld a, (.dmark)  
37f4 32 65 ee			ld (debug_mark),a  
37f7 3a 06 38			ld a, (.dmark+1)  
37fa 32 66 ee			ld (debug_mark+1),a  
37fd 3a 07 38			ld a, (.dmark+2)  
3800 32 67 ee			ld (debug_mark+2),a  
3803 18 03			jr .pastdmark  
3805 ..			.dmark: db "MUL"  
3808 f1			.pastdmark: pop af  
3809			endm  
# End of macro DMARK
3809						CALLMONITOR 
3809 cd 6f ee			call debug_vector  
380c				endm  
# End of macro CALLMONITOR
380c					endif 
380c					FORTH_DSP 
380c cd 5b 1d			call macro_forth_dsp 
380f				endm 
# End of macro FORTH_DSP
380f					; v5 FORTH_DSP_VALUE 
380f 7e					ld a,(hl)	; get type of value on TOS 
3810 fe 02				cp DS_TYPE_INUM  
3812 28 03				jr z, .mul_inum 
3814			 
3814				if FORTH_ENABLE_FLOATMATH 
3814					jr .mul_done 
3814			 
3814				endif 
3814			 
3814					NEXTW 
3814 c3 81 1f			jp macro_next 
3817				endm 
# End of macro NEXTW
3817			.mul_inum:	 
3817			 
3817					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3817 cd 95 1d			call macro_dsp_valuehl 
381a				endm 
# End of macro FORTH_DSP_VALUEHL
381a			 
381a e5					push hl 
381b			 
381b					; destroy value TOS 
381b			 
381b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
381b cd 4d 1e			call macro_forth_dsp_pop 
381e				endm 
# End of macro FORTH_DSP_POP
381e			 
381e			 
381e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
381e cd 95 1d			call macro_dsp_valuehl 
3821				endm 
# End of macro FORTH_DSP_VALUEHL
3821			 
3821					; one value on hl but move to a get other one back 
3821			 
3821 7d					ld a, l 
3822			 
3822 d1					pop de 
3823			 
3823					; do the mull 
3823			;		ex de, hl 
3823			 
3823 cd 78 0d				call Mult16 
3826					; save it 
3826			 
3826			;		push hl	 
3826			 
3826					; 
3826			 
3826					; destroy value TOS 
3826			 
3826					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3826 cd 4d 1e			call macro_forth_dsp_pop 
3829				endm 
# End of macro FORTH_DSP_POP
3829			 
3829					; TODO push value back onto stack for another op etc 
3829			 
3829			;		pop hl 
3829			 
3829 cd 90 1b				call forth_push_numhl 
382c			 
382c			.mul_done: 
382c					NEXTW 
382c c3 81 1f			jp macro_next 
382f				endm 
# End of macro NEXTW
382f			 
382f			 
382f			 
382f			 
382f			.MIN: 
382f				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
382f 49				db WORD_SYS_CORE+53             
3830 b0 38			dw .MAX            
3832 04				db 3 + 1 
3833 .. 00			db "MIN",0              
3837				endm 
# End of macro CWHEAD
3837			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3837					if DEBUG_FORTH_WORDS_KEY 
3837						DMARK "MIN" 
3837 f5				push af  
3838 3a 4c 38			ld a, (.dmark)  
383b 32 65 ee			ld (debug_mark),a  
383e 3a 4d 38			ld a, (.dmark+1)  
3841 32 66 ee			ld (debug_mark+1),a  
3844 3a 4e 38			ld a, (.dmark+2)  
3847 32 67 ee			ld (debug_mark+2),a  
384a 18 03			jr .pastdmark  
384c ..			.dmark: db "MIN"  
384f f1			.pastdmark: pop af  
3850			endm  
# End of macro DMARK
3850						CALLMONITOR 
3850 cd 6f ee			call debug_vector  
3853				endm  
# End of macro CALLMONITOR
3853					endif 
3853					; get u2 
3853			 
3853					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3853 cd 95 1d			call macro_dsp_valuehl 
3856				endm 
# End of macro FORTH_DSP_VALUEHL
3856			 
3856 e5					push hl   ; u2 
3857			 
3857					; destroy value TOS 
3857			 
3857					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3857 cd 4d 1e			call macro_forth_dsp_pop 
385a				endm 
# End of macro FORTH_DSP_POP
385a			 
385a					; get u1 
385a			 
385a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
385a cd 95 1d			call macro_dsp_valuehl 
385d				endm 
# End of macro FORTH_DSP_VALUEHL
385d			 
385d e5					push hl  ; u1 
385e			 
385e					; destroy value TOS 
385e			 
385e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
385e cd 4d 1e			call macro_forth_dsp_pop 
3861				endm 
# End of macro FORTH_DSP_POP
3861			 
3861 b7			 or a      ;clear carry flag 
3862 e1			  pop hl    ; u1 
3863 d1			  pop de    ; u2 
3864 e5				push hl   ; saved in case hl is lowest 
3865 ed 52		  sbc hl,de 
3867 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3869			 
3869 e1				pop hl 
386a					if DEBUG_FORTH_WORDS 
386a						DMARK "MIN" 
386a f5				push af  
386b 3a 7f 38			ld a, (.dmark)  
386e 32 65 ee			ld (debug_mark),a  
3871 3a 80 38			ld a, (.dmark+1)  
3874 32 66 ee			ld (debug_mark+1),a  
3877 3a 81 38			ld a, (.dmark+2)  
387a 32 67 ee			ld (debug_mark+2),a  
387d 18 03			jr .pastdmark  
387f ..			.dmark: db "MIN"  
3882 f1			.pastdmark: pop af  
3883			endm  
# End of macro DMARK
3883						CALLMONITOR 
3883 cd 6f ee			call debug_vector  
3886				endm  
# End of macro CALLMONITOR
3886					endif 
3886 cd 90 1b				call forth_push_numhl 
3889			 
3889				       NEXTW 
3889 c3 81 1f			jp macro_next 
388c				endm 
# End of macro NEXTW
388c			 
388c			.mincont:  
388c c1				pop bc   ; tidy up 
388d eb				ex de , hl  
388e					if DEBUG_FORTH_WORDS 
388e						DMARK "MI1" 
388e f5				push af  
388f 3a a3 38			ld a, (.dmark)  
3892 32 65 ee			ld (debug_mark),a  
3895 3a a4 38			ld a, (.dmark+1)  
3898 32 66 ee			ld (debug_mark+1),a  
389b 3a a5 38			ld a, (.dmark+2)  
389e 32 67 ee			ld (debug_mark+2),a  
38a1 18 03			jr .pastdmark  
38a3 ..			.dmark: db "MI1"  
38a6 f1			.pastdmark: pop af  
38a7			endm  
# End of macro DMARK
38a7						CALLMONITOR 
38a7 cd 6f ee			call debug_vector  
38aa				endm  
# End of macro CALLMONITOR
38aa					endif 
38aa cd 90 1b				call forth_push_numhl 
38ad			 
38ad				       NEXTW 
38ad c3 81 1f			jp macro_next 
38b0				endm 
# End of macro NEXTW
38b0			.MAX: 
38b0				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
38b0 4a				db WORD_SYS_CORE+54             
38b1 31 39			dw .RND16            
38b3 04				db 3 + 1 
38b4 .. 00			db "MAX",0              
38b8				endm 
# End of macro CWHEAD
38b8			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
38b8					if DEBUG_FORTH_WORDS_KEY 
38b8						DMARK "MAX" 
38b8 f5				push af  
38b9 3a cd 38			ld a, (.dmark)  
38bc 32 65 ee			ld (debug_mark),a  
38bf 3a ce 38			ld a, (.dmark+1)  
38c2 32 66 ee			ld (debug_mark+1),a  
38c5 3a cf 38			ld a, (.dmark+2)  
38c8 32 67 ee			ld (debug_mark+2),a  
38cb 18 03			jr .pastdmark  
38cd ..			.dmark: db "MAX"  
38d0 f1			.pastdmark: pop af  
38d1			endm  
# End of macro DMARK
38d1						CALLMONITOR 
38d1 cd 6f ee			call debug_vector  
38d4				endm  
# End of macro CALLMONITOR
38d4					endif 
38d4					; get u2 
38d4			 
38d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38d4 cd 95 1d			call macro_dsp_valuehl 
38d7				endm 
# End of macro FORTH_DSP_VALUEHL
38d7			 
38d7 e5					push hl   ; u2 
38d8			 
38d8					; destroy value TOS 
38d8			 
38d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38d8 cd 4d 1e			call macro_forth_dsp_pop 
38db				endm 
# End of macro FORTH_DSP_POP
38db			 
38db					; get u1 
38db			 
38db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38db cd 95 1d			call macro_dsp_valuehl 
38de				endm 
# End of macro FORTH_DSP_VALUEHL
38de			 
38de e5					push hl  ; u1 
38df			 
38df					; destroy value TOS 
38df			 
38df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38df cd 4d 1e			call macro_forth_dsp_pop 
38e2				endm 
# End of macro FORTH_DSP_POP
38e2			 
38e2 b7			 or a      ;clear carry flag 
38e3 e1			  pop hl    ; u1 
38e4 d1			  pop de    ; u2 
38e5 e5				push hl   ; saved in case hl is lowest 
38e6 ed 52		  sbc hl,de 
38e8 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
38ea			 
38ea e1				pop hl 
38eb					if DEBUG_FORTH_WORDS 
38eb						DMARK "MAX" 
38eb f5				push af  
38ec 3a 00 39			ld a, (.dmark)  
38ef 32 65 ee			ld (debug_mark),a  
38f2 3a 01 39			ld a, (.dmark+1)  
38f5 32 66 ee			ld (debug_mark+1),a  
38f8 3a 02 39			ld a, (.dmark+2)  
38fb 32 67 ee			ld (debug_mark+2),a  
38fe 18 03			jr .pastdmark  
3900 ..			.dmark: db "MAX"  
3903 f1			.pastdmark: pop af  
3904			endm  
# End of macro DMARK
3904						CALLMONITOR 
3904 cd 6f ee			call debug_vector  
3907				endm  
# End of macro CALLMONITOR
3907					endif 
3907 cd 90 1b				call forth_push_numhl 
390a			 
390a				       NEXTW 
390a c3 81 1f			jp macro_next 
390d				endm 
# End of macro NEXTW
390d			 
390d			.maxcont:  
390d c1				pop bc   ; tidy up 
390e eb				ex de , hl  
390f					if DEBUG_FORTH_WORDS 
390f						DMARK "MA1" 
390f f5				push af  
3910 3a 24 39			ld a, (.dmark)  
3913 32 65 ee			ld (debug_mark),a  
3916 3a 25 39			ld a, (.dmark+1)  
3919 32 66 ee			ld (debug_mark+1),a  
391c 3a 26 39			ld a, (.dmark+2)  
391f 32 67 ee			ld (debug_mark+2),a  
3922 18 03			jr .pastdmark  
3924 ..			.dmark: db "MA1"  
3927 f1			.pastdmark: pop af  
3928			endm  
# End of macro DMARK
3928						CALLMONITOR 
3928 cd 6f ee			call debug_vector  
392b				endm  
# End of macro CALLMONITOR
392b					endif 
392b cd 90 1b				call forth_push_numhl 
392e				       NEXTW 
392e c3 81 1f			jp macro_next 
3931				endm 
# End of macro NEXTW
3931			 
3931			.RND16: 
3931				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3931 4e				db WORD_SYS_CORE+58             
3932 60 39			dw .RND8            
3934 06				db 5 + 1 
3935 .. 00			db "RND16",0              
393b				endm 
# End of macro CWHEAD
393b			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
393b					if DEBUG_FORTH_WORDS_KEY 
393b						DMARK "R16" 
393b f5				push af  
393c 3a 50 39			ld a, (.dmark)  
393f 32 65 ee			ld (debug_mark),a  
3942 3a 51 39			ld a, (.dmark+1)  
3945 32 66 ee			ld (debug_mark+1),a  
3948 3a 52 39			ld a, (.dmark+2)  
394b 32 67 ee			ld (debug_mark+2),a  
394e 18 03			jr .pastdmark  
3950 ..			.dmark: db "R16"  
3953 f1			.pastdmark: pop af  
3954			endm  
# End of macro DMARK
3954						CALLMONITOR 
3954 cd 6f ee			call debug_vector  
3957				endm  
# End of macro CALLMONITOR
3957					endif 
3957 cd 1c 0d				call prng16  
395a cd 90 1b				call forth_push_numhl 
395d				       NEXTW 
395d c3 81 1f			jp macro_next 
3960				endm 
# End of macro NEXTW
3960			.RND8: 
3960				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3960 60				db WORD_SYS_CORE+76             
3961 95 39			dw .RND            
3963 05				db 4 + 1 
3964 .. 00			db "RND8",0              
3969				endm 
# End of macro CWHEAD
3969			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3969					if DEBUG_FORTH_WORDS_KEY 
3969						DMARK "RN8" 
3969 f5				push af  
396a 3a 7e 39			ld a, (.dmark)  
396d 32 65 ee			ld (debug_mark),a  
3970 3a 7f 39			ld a, (.dmark+1)  
3973 32 66 ee			ld (debug_mark+1),a  
3976 3a 80 39			ld a, (.dmark+2)  
3979 32 67 ee			ld (debug_mark+2),a  
397c 18 03			jr .pastdmark  
397e ..			.dmark: db "RN8"  
3981 f1			.pastdmark: pop af  
3982			endm  
# End of macro DMARK
3982						CALLMONITOR 
3982 cd 6f ee			call debug_vector  
3985				endm  
# End of macro CALLMONITOR
3985					endif 
3985 2a a3 eb				ld hl,(xrandc) 
3988 23					inc hl 
3989 cd 36 0d				call xrnd 
398c 6f					ld l,a	 
398d 26 00				ld h,0 
398f cd 90 1b				call forth_push_numhl 
3992				       NEXTW 
3992 c3 81 1f			jp macro_next 
3995				endm 
# End of macro NEXTW
3995			.RND: 
3995				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3995 60				db WORD_SYS_CORE+76             
3996 9b 3a			dw .ENDMATHS            
3998 04				db 3 + 1 
3999 .. 00			db "RND",0              
399d				endm 
# End of macro CWHEAD
399d			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
399d			 
399d					if DEBUG_FORTH_WORDS_KEY 
399d						DMARK "RND" 
399d f5				push af  
399e 3a b2 39			ld a, (.dmark)  
39a1 32 65 ee			ld (debug_mark),a  
39a4 3a b3 39			ld a, (.dmark+1)  
39a7 32 66 ee			ld (debug_mark+1),a  
39aa 3a b4 39			ld a, (.dmark+2)  
39ad 32 67 ee			ld (debug_mark+2),a  
39b0 18 03			jr .pastdmark  
39b2 ..			.dmark: db "RND"  
39b5 f1			.pastdmark: pop af  
39b6			endm  
# End of macro DMARK
39b6						CALLMONITOR 
39b6 cd 6f ee			call debug_vector  
39b9				endm  
# End of macro CALLMONITOR
39b9					endif 
39b9					 
39b9					FORTH_DSP_VALUEHL    ; upper range 
39b9 cd 95 1d			call macro_dsp_valuehl 
39bc				endm 
# End of macro FORTH_DSP_VALUEHL
39bc			 
39bc 22 a7 eb				ld (LFSRSeed), hl	 
39bf			 
39bf					if DEBUG_FORTH_WORDS 
39bf						DMARK "RN1" 
39bf f5				push af  
39c0 3a d4 39			ld a, (.dmark)  
39c3 32 65 ee			ld (debug_mark),a  
39c6 3a d5 39			ld a, (.dmark+1)  
39c9 32 66 ee			ld (debug_mark+1),a  
39cc 3a d6 39			ld a, (.dmark+2)  
39cf 32 67 ee			ld (debug_mark+2),a  
39d2 18 03			jr .pastdmark  
39d4 ..			.dmark: db "RN1"  
39d7 f1			.pastdmark: pop af  
39d8			endm  
# End of macro DMARK
39d8						CALLMONITOR 
39d8 cd 6f ee			call debug_vector  
39db				endm  
# End of macro CALLMONITOR
39db					endif 
39db					FORTH_DSP_POP 
39db cd 4d 1e			call macro_forth_dsp_pop 
39de				endm 
# End of macro FORTH_DSP_POP
39de			 
39de					FORTH_DSP_VALUEHL    ; low range 
39de cd 95 1d			call macro_dsp_valuehl 
39e1				endm 
# End of macro FORTH_DSP_VALUEHL
39e1			 
39e1					if DEBUG_FORTH_WORDS 
39e1						DMARK "RN2" 
39e1 f5				push af  
39e2 3a f6 39			ld a, (.dmark)  
39e5 32 65 ee			ld (debug_mark),a  
39e8 3a f7 39			ld a, (.dmark+1)  
39eb 32 66 ee			ld (debug_mark+1),a  
39ee 3a f8 39			ld a, (.dmark+2)  
39f1 32 67 ee			ld (debug_mark+2),a  
39f4 18 03			jr .pastdmark  
39f6 ..			.dmark: db "RN2"  
39f9 f1			.pastdmark: pop af  
39fa			endm  
# End of macro DMARK
39fa						CALLMONITOR 
39fa cd 6f ee			call debug_vector  
39fd				endm  
# End of macro CALLMONITOR
39fd					endif 
39fd 22 a9 eb				ld (LFSRSeed+2), hl 
3a00			 
3a00					FORTH_DSP_POP 
3a00 cd 4d 1e			call macro_forth_dsp_pop 
3a03				endm 
# End of macro FORTH_DSP_POP
3a03			 
3a03 e5					push hl 
3a04			 
3a04 e1			.inrange:	pop hl 
3a05 cd 1c 0d				call prng16  
3a08					if DEBUG_FORTH_WORDS 
3a08						DMARK "RN3" 
3a08 f5				push af  
3a09 3a 1d 3a			ld a, (.dmark)  
3a0c 32 65 ee			ld (debug_mark),a  
3a0f 3a 1e 3a			ld a, (.dmark+1)  
3a12 32 66 ee			ld (debug_mark+1),a  
3a15 3a 1f 3a			ld a, (.dmark+2)  
3a18 32 67 ee			ld (debug_mark+2),a  
3a1b 18 03			jr .pastdmark  
3a1d ..			.dmark: db "RN3"  
3a20 f1			.pastdmark: pop af  
3a21			endm  
# End of macro DMARK
3a21						CALLMONITOR 
3a21 cd 6f ee			call debug_vector  
3a24				endm  
# End of macro CALLMONITOR
3a24					endif 
3a24					 
3a24					; if the range is 8bit knock out the high byte 
3a24			 
3a24 ed 5b a7 eb			ld de, (LFSRSeed)     ; check high level 
3a28			 
3a28 3e 00				ld a, 0 
3a2a ba					cp d  
3a2b 20 1e				jr nz, .hirange 
3a2d 26 00				ld h, 0   ; knock it down to 8bit 
3a2f			 
3a2f					if DEBUG_FORTH_WORDS 
3a2f						DMARK "RNk" 
3a2f f5				push af  
3a30 3a 44 3a			ld a, (.dmark)  
3a33 32 65 ee			ld (debug_mark),a  
3a36 3a 45 3a			ld a, (.dmark+1)  
3a39 32 66 ee			ld (debug_mark+1),a  
3a3c 3a 46 3a			ld a, (.dmark+2)  
3a3f 32 67 ee			ld (debug_mark+2),a  
3a42 18 03			jr .pastdmark  
3a44 ..			.dmark: db "RNk"  
3a47 f1			.pastdmark: pop af  
3a48			endm  
# End of macro DMARK
3a48						CALLMONITOR 
3a48 cd 6f ee			call debug_vector  
3a4b				endm  
# End of macro CALLMONITOR
3a4b					endif 
3a4b			.hirange:   
3a4b e5					push hl  
3a4c b7					or a  
3a4d ed 52		                sbc hl, de 
3a4f			 
3a4f					;call cmp16 
3a4f			 
3a4f 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a51 e1					pop hl 
3a52 e5					push hl 
3a53			 
3a53					if DEBUG_FORTH_WORDS 
3a53						DMARK "RN4" 
3a53 f5				push af  
3a54 3a 68 3a			ld a, (.dmark)  
3a57 32 65 ee			ld (debug_mark),a  
3a5a 3a 69 3a			ld a, (.dmark+1)  
3a5d 32 66 ee			ld (debug_mark+1),a  
3a60 3a 6a 3a			ld a, (.dmark+2)  
3a63 32 67 ee			ld (debug_mark+2),a  
3a66 18 03			jr .pastdmark  
3a68 ..			.dmark: db "RN4"  
3a6b f1			.pastdmark: pop af  
3a6c			endm  
# End of macro DMARK
3a6c						CALLMONITOR 
3a6c cd 6f ee			call debug_vector  
3a6f				endm  
# End of macro CALLMONITOR
3a6f					endif 
3a6f ed 5b a9 eb			ld de, (LFSRSeed+2)   ; check low range 
3a73					;call cmp16 
3a73				 
3a73 b7					or a  
3a74 ed 52		                sbc hl, de 
3a76 38 8c				jr c, .inrange 
3a78			 
3a78 e1					pop hl 
3a79					 
3a79					if DEBUG_FORTH_WORDS 
3a79						DMARK "RNd" 
3a79 f5				push af  
3a7a 3a 8e 3a			ld a, (.dmark)  
3a7d 32 65 ee			ld (debug_mark),a  
3a80 3a 8f 3a			ld a, (.dmark+1)  
3a83 32 66 ee			ld (debug_mark+1),a  
3a86 3a 90 3a			ld a, (.dmark+2)  
3a89 32 67 ee			ld (debug_mark+2),a  
3a8c 18 03			jr .pastdmark  
3a8e ..			.dmark: db "RNd"  
3a91 f1			.pastdmark: pop af  
3a92			endm  
# End of macro DMARK
3a92						CALLMONITOR 
3a92 cd 6f ee			call debug_vector  
3a95				endm  
# End of macro CALLMONITOR
3a95					endif 
3a95			 
3a95			 
3a95 cd 90 1b				call forth_push_numhl 
3a98				       NEXTW 
3a98 c3 81 1f			jp macro_next 
3a9b				endm 
# End of macro NEXTW
3a9b			 
3a9b			.ENDMATHS: 
3a9b			 
3a9b			; eof 
3a9b			 
# End of file forth_words_maths.asm
3a9b			include "forth_words_display.asm" 
3a9b			 
3a9b			; | ## Display Words 
3a9b			 
3a9b			.ACT: 
3a9b			 
3a9b				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3a9b 62				db WORD_SYS_CORE+78             
3a9c e7 3a			dw .INFO            
3a9e 07				db 6 + 1 
3a9f .. 00			db "ACTIVE",0              
3aa6				endm 
# End of macro CWHEAD
3aa6			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3aa6			;  
3aa6			; | | To display a pulsing activity indicator in a processing loop do this... 
3aa6			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3aa6			 
3aa6					if DEBUG_FORTH_WORDS_KEY 
3aa6						DMARK "ACT" 
3aa6 f5				push af  
3aa7 3a bb 3a			ld a, (.dmark)  
3aaa 32 65 ee			ld (debug_mark),a  
3aad 3a bc 3a			ld a, (.dmark+1)  
3ab0 32 66 ee			ld (debug_mark+1),a  
3ab3 3a bd 3a			ld a, (.dmark+2)  
3ab6 32 67 ee			ld (debug_mark+2),a  
3ab9 18 03			jr .pastdmark  
3abb ..			.dmark: db "ACT"  
3abe f1			.pastdmark: pop af  
3abf			endm  
# End of macro DMARK
3abf						CALLMONITOR 
3abf cd 6f ee			call debug_vector  
3ac2				endm  
# End of macro CALLMONITOR
3ac2					endif 
3ac2 cd 1f 0b				call active 
3ac5					if DEBUG_FORTH_WORDS 
3ac5						DMARK "ACp" 
3ac5 f5				push af  
3ac6 3a da 3a			ld a, (.dmark)  
3ac9 32 65 ee			ld (debug_mark),a  
3acc 3a db 3a			ld a, (.dmark+1)  
3acf 32 66 ee			ld (debug_mark+1),a  
3ad2 3a dc 3a			ld a, (.dmark+2)  
3ad5 32 67 ee			ld (debug_mark+2),a  
3ad8 18 03			jr .pastdmark  
3ada ..			.dmark: db "ACp"  
3add f1			.pastdmark: pop af  
3ade			endm  
# End of macro DMARK
3ade						CALLMONITOR 
3ade cd 6f ee			call debug_vector  
3ae1				endm  
# End of macro CALLMONITOR
3ae1					endif 
3ae1 cd fe 1b				call forth_push_str 
3ae4			 
3ae4					NEXTW 
3ae4 c3 81 1f			jp macro_next 
3ae7				endm 
# End of macro NEXTW
3ae7			.INFO: 
3ae7			 
3ae7				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3ae7 62				db WORD_SYS_CORE+78             
3ae8 04 3b			dw .ATP            
3aea 05				db 4 + 1 
3aeb .. 00			db "INFO",0              
3af0				endm 
# End of macro CWHEAD
3af0			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3af0					FORTH_DSP_VALUEHL 
3af0 cd 95 1d			call macro_dsp_valuehl 
3af3				endm 
# End of macro FORTH_DSP_VALUEHL
3af3			 
3af3					FORTH_DSP_POP 
3af3 cd 4d 1e			call macro_forth_dsp_pop 
3af6				endm 
# End of macro FORTH_DSP_POP
3af6			 
3af6 e5					push hl 
3af7			 
3af7					FORTH_DSP_VALUEHL 
3af7 cd 95 1d			call macro_dsp_valuehl 
3afa				endm 
# End of macro FORTH_DSP_VALUEHL
3afa			 
3afa					FORTH_DSP_POP 
3afa cd 4d 1e			call macro_forth_dsp_pop 
3afd				endm 
# End of macro FORTH_DSP_POP
3afd			 
3afd d1					pop de 
3afe			 
3afe cd 59 0b				call info_panel 
3b01			 
3b01			 
3b01					NEXTW 
3b01 c3 81 1f			jp macro_next 
3b04				endm 
# End of macro NEXTW
3b04			.ATP: 
3b04				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3b04 62				db WORD_SYS_CORE+78             
3b05 7b 3b			dw .FB            
3b07 04				db 3 + 1 
3b08 .. 00			db "AT?",0              
3b0c				endm 
# End of macro CWHEAD
3b0c			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3b0c					if DEBUG_FORTH_WORDS_KEY 
3b0c						DMARK "AT?" 
3b0c f5				push af  
3b0d 3a 21 3b			ld a, (.dmark)  
3b10 32 65 ee			ld (debug_mark),a  
3b13 3a 22 3b			ld a, (.dmark+1)  
3b16 32 66 ee			ld (debug_mark+1),a  
3b19 3a 23 3b			ld a, (.dmark+2)  
3b1c 32 67 ee			ld (debug_mark+2),a  
3b1f 18 03			jr .pastdmark  
3b21 ..			.dmark: db "AT?"  
3b24 f1			.pastdmark: pop af  
3b25			endm  
# End of macro DMARK
3b25						CALLMONITOR 
3b25 cd 6f ee			call debug_vector  
3b28				endm  
# End of macro CALLMONITOR
3b28					endif 
3b28 3a 58 ea				ld a, (f_cursor_ptr) 
3b2b			 
3b2b			if DEBUG_FORTH_WORDS 
3b2b				DMARK "AT?" 
3b2b f5				push af  
3b2c 3a 40 3b			ld a, (.dmark)  
3b2f 32 65 ee			ld (debug_mark),a  
3b32 3a 41 3b			ld a, (.dmark+1)  
3b35 32 66 ee			ld (debug_mark+1),a  
3b38 3a 42 3b			ld a, (.dmark+2)  
3b3b 32 67 ee			ld (debug_mark+2),a  
3b3e 18 03			jr .pastdmark  
3b40 ..			.dmark: db "AT?"  
3b43 f1			.pastdmark: pop af  
3b44			endm  
# End of macro DMARK
3b44				CALLMONITOR 
3b44 cd 6f ee			call debug_vector  
3b47				endm  
# End of macro CALLMONITOR
3b47			endif	 
3b47					; count the number of rows 
3b47			 
3b47 06 00				ld b, 0 
3b49 4f			.atpr:		ld c, a    ; save in case we go below zero 
3b4a d6 28				sub display_cols 
3b4c f2 52 3b				jp p, .atprunder 
3b4f 04					inc b 
3b50 18 f7				jr .atpr 
3b52			.atprunder:	 
3b52			if DEBUG_FORTH_WORDS 
3b52				DMARK "A?2" 
3b52 f5				push af  
3b53 3a 67 3b			ld a, (.dmark)  
3b56 32 65 ee			ld (debug_mark),a  
3b59 3a 68 3b			ld a, (.dmark+1)  
3b5c 32 66 ee			ld (debug_mark+1),a  
3b5f 3a 69 3b			ld a, (.dmark+2)  
3b62 32 67 ee			ld (debug_mark+2),a  
3b65 18 03			jr .pastdmark  
3b67 ..			.dmark: db "A?2"  
3b6a f1			.pastdmark: pop af  
3b6b			endm  
# End of macro DMARK
3b6b				CALLMONITOR 
3b6b cd 6f ee			call debug_vector  
3b6e				endm  
# End of macro CALLMONITOR
3b6e			endif	 
3b6e 26 00				ld h, 0 
3b70 69					ld l, c 
3b71 cd 90 1b				call forth_push_numhl 
3b74 68					ld l, b  
3b75 cd 90 1b				call forth_push_numhl 
3b78			 
3b78			 
3b78				NEXTW 
3b78 c3 81 1f			jp macro_next 
3b7b				endm 
# End of macro NEXTW
3b7b			 
3b7b			.FB: 
3b7b				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b7b 1b				db WORD_SYS_CORE+7             
3b7c c9 3b			dw .EMIT            
3b7e 03				db 2 + 1 
3b7f .. 00			db "FB",0              
3b82				endm 
# End of macro CWHEAD
3b82			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b82			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b82			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b82			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b82					if DEBUG_FORTH_WORDS_KEY 
3b82						DMARK "FB." 
3b82 f5				push af  
3b83 3a 97 3b			ld a, (.dmark)  
3b86 32 65 ee			ld (debug_mark),a  
3b89 3a 98 3b			ld a, (.dmark+1)  
3b8c 32 66 ee			ld (debug_mark+1),a  
3b8f 3a 99 3b			ld a, (.dmark+2)  
3b92 32 67 ee			ld (debug_mark+2),a  
3b95 18 03			jr .pastdmark  
3b97 ..			.dmark: db "FB."  
3b9a f1			.pastdmark: pop af  
3b9b			endm  
# End of macro DMARK
3b9b						CALLMONITOR 
3b9b cd 6f ee			call debug_vector  
3b9e				endm  
# End of macro CALLMONITOR
3b9e					endif 
3b9e			 
3b9e					FORTH_DSP_VALUEHL 
3b9e cd 95 1d			call macro_dsp_valuehl 
3ba1				endm 
# End of macro FORTH_DSP_VALUEHL
3ba1			 
3ba1 7d					ld a, l 
3ba2 fe 01				cp 1 
3ba4 20 05				jr nz, .fbn1 
3ba6 21 0a ed				ld hl, display_fb1 
3ba9 18 15				jr .fbset 
3bab fe 02		.fbn1:		cp 2 
3bad 20 05				jr nz, .fbn2 
3baf 21 c8 eb				ld hl, display_fb2 
3bb2 18 0c				jr .fbset 
3bb4 fe 03		.fbn2:		cp 3 
3bb6 20 05				jr nz, .fbn3 
3bb8 21 69 ec				ld hl, display_fb3 
3bbb 18 03				jr .fbset 
3bbd			.fbn3:		 ; if invalid number select first 
3bbd 21 0a ed				ld hl, display_fb1 
3bc0 22 c6 eb		.fbset:		ld (display_fb_active), hl 
3bc3			 
3bc3					FORTH_DSP_POP 
3bc3 cd 4d 1e			call macro_forth_dsp_pop 
3bc6				endm 
# End of macro FORTH_DSP_POP
3bc6			 
3bc6					NEXTW 
3bc6 c3 81 1f			jp macro_next 
3bc9				endm 
# End of macro NEXTW
3bc9			 
3bc9			 
3bc9			.EMIT: 
3bc9				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3bc9 1b				db WORD_SYS_CORE+7             
3bca 1a 3c			dw .DOTH            
3bcc 05				db 4 + 1 
3bcd .. 00			db "EMIT",0              
3bd2				endm 
# End of macro CWHEAD
3bd2			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3bd2					; get value off TOS and display it 
3bd2			 
3bd2					if DEBUG_FORTH_WORDS_KEY 
3bd2						DMARK "EMT" 
3bd2 f5				push af  
3bd3 3a e7 3b			ld a, (.dmark)  
3bd6 32 65 ee			ld (debug_mark),a  
3bd9 3a e8 3b			ld a, (.dmark+1)  
3bdc 32 66 ee			ld (debug_mark+1),a  
3bdf 3a e9 3b			ld a, (.dmark+2)  
3be2 32 67 ee			ld (debug_mark+2),a  
3be5 18 03			jr .pastdmark  
3be7 ..			.dmark: db "EMT"  
3bea f1			.pastdmark: pop af  
3beb			endm  
# End of macro DMARK
3beb						CALLMONITOR 
3beb cd 6f ee			call debug_vector  
3bee				endm  
# End of macro CALLMONITOR
3bee					endif 
3bee			 
3bee					FORTH_DSP_VALUEHL 
3bee cd 95 1d			call macro_dsp_valuehl 
3bf1				endm 
# End of macro FORTH_DSP_VALUEHL
3bf1			 
3bf1 7d					ld a,l 
3bf2			 
3bf2					; TODO write to display 
3bf2			 
3bf2 32 b9 e4				ld (os_input), a 
3bf5 3e 00				ld a, 0 
3bf7 32 ba e4				ld (os_input+1), a 
3bfa					 
3bfa 3a 58 ea				ld a, (f_cursor_ptr) 
3bfd 11 b9 e4				ld de, os_input 
3c00 cd db 0b				call str_at_display 
3c03			 
3c03			 
3c03 3a 36 ea				ld a,(cli_autodisplay) 
3c06 fe 00				cp 0 
3c08 28 03				jr z, .enoupdate 
3c0a cd eb 0b						call update_display 
3c0d					.enoupdate: 
3c0d			 
3c0d 3a 58 ea				ld a, (f_cursor_ptr) 
3c10 3c					inc a 
3c11 32 58 ea				ld (f_cursor_ptr), a   ; save new pos 
3c14			 
3c14			 
3c14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c14 cd 4d 1e			call macro_forth_dsp_pop 
3c17				endm 
# End of macro FORTH_DSP_POP
3c17			  
3c17			 
3c17					NEXTW 
3c17 c3 81 1f			jp macro_next 
3c1a				endm 
# End of macro NEXTW
3c1a			.DOTH: 
3c1a				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3c1a 1c				db WORD_SYS_CORE+8             
3c1b 4a 3c			dw .DOTF            
3c1d 03				db 2 + 1 
3c1e .. 00			db ".-",0              
3c21				endm 
# End of macro CWHEAD
3c21			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3c21					; get value off TOS and display it 
3c21					if DEBUG_FORTH_WORDS_KEY 
3c21						DMARK "DTD" 
3c21 f5				push af  
3c22 3a 36 3c			ld a, (.dmark)  
3c25 32 65 ee			ld (debug_mark),a  
3c28 3a 37 3c			ld a, (.dmark+1)  
3c2b 32 66 ee			ld (debug_mark+1),a  
3c2e 3a 38 3c			ld a, (.dmark+2)  
3c31 32 67 ee			ld (debug_mark+2),a  
3c34 18 03			jr .pastdmark  
3c36 ..			.dmark: db "DTD"  
3c39 f1			.pastdmark: pop af  
3c3a			endm  
# End of macro DMARK
3c3a						CALLMONITOR 
3c3a cd 6f ee			call debug_vector  
3c3d				endm  
# End of macro CALLMONITOR
3c3d					endif 
3c3d 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3c3f 3e 00			ld a, 0 
3c41 32 37 ea			ld (cli_mvdot), a 
3c44 c3 a1 3c			jp .dotgo 
3c47				NEXTW 
3c47 c3 81 1f			jp macro_next 
3c4a				endm 
# End of macro NEXTW
3c4a			.DOTF: 
3c4a				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3c4a 1c				db WORD_SYS_CORE+8             
3c4b 78 3c			dw .DOT            
3c4d 03				db 2 + 1 
3c4e .. 00			db ".>",0              
3c51				endm 
# End of macro CWHEAD
3c51			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3c51					; get value off TOS and display it 
3c51			        ; TODO BUG adds extra spaces 
3c51			        ; TODO BUG handle numerics? 
3c51					if DEBUG_FORTH_WORDS_KEY 
3c51						DMARK "DTC" 
3c51 f5				push af  
3c52 3a 66 3c			ld a, (.dmark)  
3c55 32 65 ee			ld (debug_mark),a  
3c58 3a 67 3c			ld a, (.dmark+1)  
3c5b 32 66 ee			ld (debug_mark+1),a  
3c5e 3a 68 3c			ld a, (.dmark+2)  
3c61 32 67 ee			ld (debug_mark+2),a  
3c64 18 03			jr .pastdmark  
3c66 ..			.dmark: db "DTC"  
3c69 f1			.pastdmark: pop af  
3c6a			endm  
# End of macro DMARK
3c6a						CALLMONITOR 
3c6a cd 6f ee			call debug_vector  
3c6d				endm  
# End of macro CALLMONITOR
3c6d					endif 
3c6d 3e 01			ld a, 1 
3c6f 32 37 ea			ld (cli_mvdot), a 
3c72 c3 a1 3c			jp .dotgo 
3c75				NEXTW 
3c75 c3 81 1f			jp macro_next 
3c78				endm 
# End of macro NEXTW
3c78			 
3c78			.DOT: 
3c78				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c78 1c				db WORD_SYS_CORE+8             
3c79 54 3e			dw .CLS            
3c7b 02				db 1 + 1 
3c7c .. 00			db ".",0              
3c7e				endm 
# End of macro CWHEAD
3c7e			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3c7e					; get value off TOS and display it 
3c7e			 
3c7e					if DEBUG_FORTH_WORDS_KEY 
3c7e						DMARK "DOT" 
3c7e f5				push af  
3c7f 3a 93 3c			ld a, (.dmark)  
3c82 32 65 ee			ld (debug_mark),a  
3c85 3a 94 3c			ld a, (.dmark+1)  
3c88 32 66 ee			ld (debug_mark+1),a  
3c8b 3a 95 3c			ld a, (.dmark+2)  
3c8e 32 67 ee			ld (debug_mark+2),a  
3c91 18 03			jr .pastdmark  
3c93 ..			.dmark: db "DOT"  
3c96 f1			.pastdmark: pop af  
3c97			endm  
# End of macro DMARK
3c97						CALLMONITOR 
3c97 cd 6f ee			call debug_vector  
3c9a				endm  
# End of macro CALLMONITOR
3c9a					endif 
3c9a 3e 00			ld a, 0 
3c9c 32 37 ea			ld (cli_mvdot), a 
3c9f 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3ca1				 
3ca1			 
3ca1			.dotgo: 
3ca1			 
3ca1			; move up type to on stack for parserv5 
3ca1					FORTH_DSP 
3ca1 cd 5b 1d			call macro_forth_dsp 
3ca4				endm 
# End of macro FORTH_DSP
3ca4				;FORTH_DSP_VALUE  
3ca4			 
3ca4			if DEBUG_FORTH_DOT 
3ca4				DMARK "DOT" 
3ca4 f5				push af  
3ca5 3a b9 3c			ld a, (.dmark)  
3ca8 32 65 ee			ld (debug_mark),a  
3cab 3a ba 3c			ld a, (.dmark+1)  
3cae 32 66 ee			ld (debug_mark+1),a  
3cb1 3a bb 3c			ld a, (.dmark+2)  
3cb4 32 67 ee			ld (debug_mark+2),a  
3cb7 18 03			jr .pastdmark  
3cb9 ..			.dmark: db "DOT"  
3cbc f1			.pastdmark: pop af  
3cbd			endm  
# End of macro DMARK
3cbd				CALLMONITOR 
3cbd cd 6f ee			call debug_vector  
3cc0				endm  
# End of macro CALLMONITOR
3cc0			endif	 
3cc0			;		.print: 
3cc0			 
3cc0 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3cc1 23				inc hl   ; position to the actual value 
3cc2 fe 01			cp DS_TYPE_STR 
3cc4 20 06			jr nz, .dotnum1  
3cc6			 
3cc6			; display string 
3cc6				FORTH_DSP_VALUE  
3cc6 cd 7e 1d			call macro_forth_dsp_value 
3cc9				endm 
# End of macro FORTH_DSP_VALUE
3cc9 eb				ex de,hl 
3cca 18 49			jr .dotwrite 
3ccc			 
3ccc			.dotnum1: 
3ccc fe 02			cp DS_TYPE_INUM 
3cce 20 44			jr nz, .dotflot 
3cd0			 
3cd0			 
3cd0			; display number 
3cd0			 
3cd0			;	push hl 
3cd0			;	call clear_display 
3cd0			;	pop hl 
3cd0			 
3cd0 5e				ld e, (hl) 
3cd1 23				inc hl 
3cd2 56				ld d, (hl) 
3cd3 21 bb e2			ld hl, scratch 
3cd6			if DEBUG_FORTH_DOT 
3cd6				DMARK "DT1" 
3cd6 f5				push af  
3cd7 3a eb 3c			ld a, (.dmark)  
3cda 32 65 ee			ld (debug_mark),a  
3cdd 3a ec 3c			ld a, (.dmark+1)  
3ce0 32 66 ee			ld (debug_mark+1),a  
3ce3 3a ed 3c			ld a, (.dmark+2)  
3ce6 32 67 ee			ld (debug_mark+2),a  
3ce9 18 03			jr .pastdmark  
3ceb ..			.dmark: db "DT1"  
3cee f1			.pastdmark: pop af  
3cef			endm  
# End of macro DMARK
3cef				CALLMONITOR 
3cef cd 6f ee			call debug_vector  
3cf2				endm  
# End of macro CALLMONITOR
3cf2			endif	 
3cf2			 
3cf2 cd 0a 11			call uitoa_16 
3cf5 eb				ex de,hl 
3cf6			 
3cf6			if DEBUG_FORTH_DOT 
3cf6				DMARK "DT2" 
3cf6 f5				push af  
3cf7 3a 0b 3d			ld a, (.dmark)  
3cfa 32 65 ee			ld (debug_mark),a  
3cfd 3a 0c 3d			ld a, (.dmark+1)  
3d00 32 66 ee			ld (debug_mark+1),a  
3d03 3a 0d 3d			ld a, (.dmark+2)  
3d06 32 67 ee			ld (debug_mark+2),a  
3d09 18 03			jr .pastdmark  
3d0b ..			.dmark: db "DT2"  
3d0e f1			.pastdmark: pop af  
3d0f			endm  
# End of macro DMARK
3d0f				CALLMONITOR 
3d0f cd 6f ee			call debug_vector  
3d12				endm  
# End of macro CALLMONITOR
3d12			endif	 
3d12			 
3d12			;	ld de, os_word_scratch 
3d12 18 01			jr .dotwrite 
3d14			 
3d14 00			.dotflot:   nop 
3d15			; TODO print floating point number 
3d15			 
3d15			.dotwrite:		 
3d15			 
3d15					; if c is set then set all '-' to spaces 
3d15					; need to also take into account .>  
3d15			 
3d15 3e 01				ld a, 1 
3d17 b9					cp c 
3d18 20 67				jr nz, .nodashswap 
3d1a			 
3d1a					; DE has the string to write, working with HL 
3d1a			 
3d1a 06 ff				ld b, 255 
3d1c d5					push de 
3d1d e1					pop hl 
3d1e			 
3d1e			if DEBUG_FORTH_DOT 
3d1e				DMARK "DT-" 
3d1e f5				push af  
3d1f 3a 33 3d			ld a, (.dmark)  
3d22 32 65 ee			ld (debug_mark),a  
3d25 3a 34 3d			ld a, (.dmark+1)  
3d28 32 66 ee			ld (debug_mark+1),a  
3d2b 3a 35 3d			ld a, (.dmark+2)  
3d2e 32 67 ee			ld (debug_mark+2),a  
3d31 18 03			jr .pastdmark  
3d33 ..			.dmark: db "DT-"  
3d36 f1			.pastdmark: pop af  
3d37			endm  
# End of macro DMARK
3d37				CALLMONITOR 
3d37 cd 6f ee			call debug_vector  
3d3a				endm  
# End of macro CALLMONITOR
3d3a			endif	 
3d3a 7e			.dashscan:	ld a, (hl) 
3d3b fe 00				cp 0 
3d3d 28 42				jr z, .nodashswap 
3d3f fe 2d				cp '-' 
3d41 20 03				jr nz, .dashskip 
3d43 3e 20				ld a, ' ' 
3d45 77					ld (hl), a 
3d46 23			.dashskip:	inc hl 
3d47			if DEBUG_FORTH_DOT 
3d47				DMARK "D-2" 
3d47 f5				push af  
3d48 3a 5c 3d			ld a, (.dmark)  
3d4b 32 65 ee			ld (debug_mark),a  
3d4e 3a 5d 3d			ld a, (.dmark+1)  
3d51 32 66 ee			ld (debug_mark+1),a  
3d54 3a 5e 3d			ld a, (.dmark+2)  
3d57 32 67 ee			ld (debug_mark+2),a  
3d5a 18 03			jr .pastdmark  
3d5c ..			.dmark: db "D-2"  
3d5f f1			.pastdmark: pop af  
3d60			endm  
# End of macro DMARK
3d60				CALLMONITOR 
3d60 cd 6f ee			call debug_vector  
3d63				endm  
# End of macro CALLMONITOR
3d63			endif	 
3d63 10 d5				djnz .dashscan 
3d65			 
3d65			if DEBUG_FORTH_DOT 
3d65				DMARK "D-1" 
3d65 f5				push af  
3d66 3a 7a 3d			ld a, (.dmark)  
3d69 32 65 ee			ld (debug_mark),a  
3d6c 3a 7b 3d			ld a, (.dmark+1)  
3d6f 32 66 ee			ld (debug_mark+1),a  
3d72 3a 7c 3d			ld a, (.dmark+2)  
3d75 32 67 ee			ld (debug_mark+2),a  
3d78 18 03			jr .pastdmark  
3d7a ..			.dmark: db "D-1"  
3d7d f1			.pastdmark: pop af  
3d7e			endm  
# End of macro DMARK
3d7e				CALLMONITOR 
3d7e cd 6f ee			call debug_vector  
3d81				endm  
# End of macro CALLMONITOR
3d81			endif	 
3d81			 
3d81			.nodashswap: 
3d81			 
3d81			if DEBUG_FORTH_DOT 
3d81				DMARK "D-o" 
3d81 f5				push af  
3d82 3a 96 3d			ld a, (.dmark)  
3d85 32 65 ee			ld (debug_mark),a  
3d88 3a 97 3d			ld a, (.dmark+1)  
3d8b 32 66 ee			ld (debug_mark+1),a  
3d8e 3a 98 3d			ld a, (.dmark+2)  
3d91 32 67 ee			ld (debug_mark+2),a  
3d94 18 03			jr .pastdmark  
3d96 ..			.dmark: db "D-o"  
3d99 f1			.pastdmark: pop af  
3d9a			endm  
# End of macro DMARK
3d9a				CALLMONITOR 
3d9a cd 6f ee			call debug_vector  
3d9d				endm  
# End of macro CALLMONITOR
3d9d			endif	 
3d9d			 
3d9d d5					push de   ; save string start in case we need to advance print 
3d9e			 
3d9e 3a 58 ea				ld a, (f_cursor_ptr) 
3da1 cd db 0b				call str_at_display 
3da4 3a 36 ea				ld a,(cli_autodisplay) 
3da7 fe 00				cp 0 
3da9 28 03				jr z, .noupdate 
3dab cd eb 0b						call update_display 
3dae					.noupdate: 
3dae			 
3dae			 
3dae					; see if we need to advance the print position 
3dae			 
3dae e1					pop hl   ; get back string 
3daf			;		ex de,hl 
3daf			 
3daf 3a 37 ea				ld a, (cli_mvdot) 
3db2			if DEBUG_FORTH_DOT 
3db2			;		ld e,a 
3db2				DMARK "D>1" 
3db2 f5				push af  
3db3 3a c7 3d			ld a, (.dmark)  
3db6 32 65 ee			ld (debug_mark),a  
3db9 3a c8 3d			ld a, (.dmark+1)  
3dbc 32 66 ee			ld (debug_mark+1),a  
3dbf 3a c9 3d			ld a, (.dmark+2)  
3dc2 32 67 ee			ld (debug_mark+2),a  
3dc5 18 03			jr .pastdmark  
3dc7 ..			.dmark: db "D>1"  
3dca f1			.pastdmark: pop af  
3dcb			endm  
# End of macro DMARK
3dcb				CALLMONITOR 
3dcb cd 6f ee			call debug_vector  
3dce				endm  
# End of macro CALLMONITOR
3dce			endif	 
3dce fe 00				cp 0 
3dd0 28 44				jr z, .noadv 
3dd2					; yes, lets advance the print position 
3dd2 3e 00				ld a, 0 
3dd4 cd 66 11				call strlent 
3dd7			if DEBUG_FORTH_DOT 
3dd7				DMARK "D-?" 
3dd7 f5				push af  
3dd8 3a ec 3d			ld a, (.dmark)  
3ddb 32 65 ee			ld (debug_mark),a  
3dde 3a ed 3d			ld a, (.dmark+1)  
3de1 32 66 ee			ld (debug_mark+1),a  
3de4 3a ee 3d			ld a, (.dmark+2)  
3de7 32 67 ee			ld (debug_mark+2),a  
3dea 18 03			jr .pastdmark  
3dec ..			.dmark: db "D-?"  
3def f1			.pastdmark: pop af  
3df0			endm  
# End of macro DMARK
3df0				CALLMONITOR 
3df0 cd 6f ee			call debug_vector  
3df3				endm  
# End of macro CALLMONITOR
3df3			endif	 
3df3 3a 58 ea				ld a, (f_cursor_ptr) 
3df6 85					add a,l 
3df7					;call addatohl 
3df7					;ld a, l 
3df7 32 58 ea				ld (f_cursor_ptr), a   ; save new pos 
3dfa			 
3dfa			if DEBUG_FORTH_DOT 
3dfa				DMARK "D->" 
3dfa f5				push af  
3dfb 3a 0f 3e			ld a, (.dmark)  
3dfe 32 65 ee			ld (debug_mark),a  
3e01 3a 10 3e			ld a, (.dmark+1)  
3e04 32 66 ee			ld (debug_mark+1),a  
3e07 3a 11 3e			ld a, (.dmark+2)  
3e0a 32 67 ee			ld (debug_mark+2),a  
3e0d 18 03			jr .pastdmark  
3e0f ..			.dmark: db "D->"  
3e12 f1			.pastdmark: pop af  
3e13			endm  
# End of macro DMARK
3e13				CALLMONITOR 
3e13 cd 6f ee			call debug_vector  
3e16				endm  
# End of macro CALLMONITOR
3e16			endif	 
3e16			 
3e16			.noadv:	 
3e16			 
3e16					if DEBUG_FORTH_DOT_WAIT 
3e16							call next_page_prompt 
3e16					endif	 
3e16			; TODO this pop off the stack causes a crash. i dont know why 
3e16			 
3e16			 
3e16			if DEBUG_FORTH_DOT 
3e16				DMARK "DTh" 
3e16 f5				push af  
3e17 3a 2b 3e			ld a, (.dmark)  
3e1a 32 65 ee			ld (debug_mark),a  
3e1d 3a 2c 3e			ld a, (.dmark+1)  
3e20 32 66 ee			ld (debug_mark+1),a  
3e23 3a 2d 3e			ld a, (.dmark+2)  
3e26 32 67 ee			ld (debug_mark+2),a  
3e29 18 03			jr .pastdmark  
3e2b ..			.dmark: db "DTh"  
3e2e f1			.pastdmark: pop af  
3e2f			endm  
# End of macro DMARK
3e2f				CALLMONITOR 
3e2f cd 6f ee			call debug_vector  
3e32				endm  
# End of macro CALLMONITOR
3e32			endif	 
3e32			 
3e32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e32 cd 4d 1e			call macro_forth_dsp_pop 
3e35				endm 
# End of macro FORTH_DSP_POP
3e35			 
3e35			if DEBUG_FORTH_DOT 
3e35				DMARK "DTi" 
3e35 f5				push af  
3e36 3a 4a 3e			ld a, (.dmark)  
3e39 32 65 ee			ld (debug_mark),a  
3e3c 3a 4b 3e			ld a, (.dmark+1)  
3e3f 32 66 ee			ld (debug_mark+1),a  
3e42 3a 4c 3e			ld a, (.dmark+2)  
3e45 32 67 ee			ld (debug_mark+2),a  
3e48 18 03			jr .pastdmark  
3e4a ..			.dmark: db "DTi"  
3e4d f1			.pastdmark: pop af  
3e4e			endm  
# End of macro DMARK
3e4e				CALLMONITOR 
3e4e cd 6f ee			call debug_vector  
3e51				endm  
# End of macro CALLMONITOR
3e51			endif	 
3e51			 
3e51			 
3e51					NEXTW 
3e51 c3 81 1f			jp macro_next 
3e54				endm 
# End of macro NEXTW
3e54			 
3e54			.CLS: 
3e54				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e54 35				db WORD_SYS_CORE+33             
3e55 81 3e			dw .DRAW            
3e57 04				db 3 + 1 
3e58 .. 00			db "CLS",0              
3e5c				endm 
# End of macro CWHEAD
3e5c			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e5c					if DEBUG_FORTH_WORDS_KEY 
3e5c						DMARK "CLS" 
3e5c f5				push af  
3e5d 3a 71 3e			ld a, (.dmark)  
3e60 32 65 ee			ld (debug_mark),a  
3e63 3a 72 3e			ld a, (.dmark+1)  
3e66 32 66 ee			ld (debug_mark+1),a  
3e69 3a 73 3e			ld a, (.dmark+2)  
3e6c 32 67 ee			ld (debug_mark+2),a  
3e6f 18 03			jr .pastdmark  
3e71 ..			.dmark: db "CLS"  
3e74 f1			.pastdmark: pop af  
3e75			endm  
# End of macro DMARK
3e75						CALLMONITOR 
3e75 cd 6f ee			call debug_vector  
3e78				endm  
# End of macro CALLMONITOR
3e78					endif 
3e78 cd c8 0b				call clear_display 
3e7b c3 8f 3f				jp .home		; and home cursor 
3e7e					NEXTW 
3e7e c3 81 1f			jp macro_next 
3e81				endm 
# End of macro NEXTW
3e81			 
3e81			.DRAW: 
3e81				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e81 36				db WORD_SYS_CORE+34             
3e82 ac 3e			dw .DUMP            
3e84 05				db 4 + 1 
3e85 .. 00			db "DRAW",0              
3e8a				endm 
# End of macro CWHEAD
3e8a			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e8a					if DEBUG_FORTH_WORDS_KEY 
3e8a						DMARK "DRW" 
3e8a f5				push af  
3e8b 3a 9f 3e			ld a, (.dmark)  
3e8e 32 65 ee			ld (debug_mark),a  
3e91 3a a0 3e			ld a, (.dmark+1)  
3e94 32 66 ee			ld (debug_mark+1),a  
3e97 3a a1 3e			ld a, (.dmark+2)  
3e9a 32 67 ee			ld (debug_mark+2),a  
3e9d 18 03			jr .pastdmark  
3e9f ..			.dmark: db "DRW"  
3ea2 f1			.pastdmark: pop af  
3ea3			endm  
# End of macro DMARK
3ea3						CALLMONITOR 
3ea3 cd 6f ee			call debug_vector  
3ea6				endm  
# End of macro CALLMONITOR
3ea6					endif 
3ea6 cd eb 0b				call update_display 
3ea9					NEXTW 
3ea9 c3 81 1f			jp macro_next 
3eac				endm 
# End of macro NEXTW
3eac			 
3eac			.DUMP: 
3eac				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3eac 37				db WORD_SYS_CORE+35             
3ead e4 3e			dw .CDUMP            
3eaf 05				db 4 + 1 
3eb0 .. 00			db "DUMP",0              
3eb5				endm 
# End of macro CWHEAD
3eb5			; | DUMP ( x -- ) With address x display dump   | DONE 
3eb5			; TODO pop address to use off of the stack 
3eb5					if DEBUG_FORTH_WORDS_KEY 
3eb5						DMARK "DUM" 
3eb5 f5				push af  
3eb6 3a ca 3e			ld a, (.dmark)  
3eb9 32 65 ee			ld (debug_mark),a  
3ebc 3a cb 3e			ld a, (.dmark+1)  
3ebf 32 66 ee			ld (debug_mark+1),a  
3ec2 3a cc 3e			ld a, (.dmark+2)  
3ec5 32 67 ee			ld (debug_mark+2),a  
3ec8 18 03			jr .pastdmark  
3eca ..			.dmark: db "DUM"  
3ecd f1			.pastdmark: pop af  
3ece			endm  
# End of macro DMARK
3ece						CALLMONITOR 
3ece cd 6f ee			call debug_vector  
3ed1				endm  
# End of macro CALLMONITOR
3ed1					endif 
3ed1 cd c8 0b				call clear_display 
3ed4			 
3ed4					; get address 
3ed4			 
3ed4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ed4 cd 95 1d			call macro_dsp_valuehl 
3ed7				endm 
# End of macro FORTH_DSP_VALUEHL
3ed7				 
3ed7					; save it for cdump 
3ed7			 
3ed7 22 de e5				ld (os_cur_ptr),hl 
3eda			 
3eda					; destroy value TOS 
3eda			 
3eda					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eda cd 4d 1e			call macro_forth_dsp_pop 
3edd				endm 
# End of macro FORTH_DSP_POP
3edd			 
3edd cd 10 1a				call dumpcont	; skip old style of param parsing	 
3ee0 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3ee1					NEXTW 
3ee1 c3 81 1f			jp macro_next 
3ee4				endm 
# End of macro NEXTW
3ee4			.CDUMP: 
3ee4				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3ee4 38				db WORD_SYS_CORE+36             
3ee5 14 3f			dw .DAT            
3ee7 06				db 5 + 1 
3ee8 .. 00			db "CDUMP",0              
3eee				endm 
# End of macro CWHEAD
3eee			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3eee					if DEBUG_FORTH_WORDS_KEY 
3eee						DMARK "CDP" 
3eee f5				push af  
3eef 3a 03 3f			ld a, (.dmark)  
3ef2 32 65 ee			ld (debug_mark),a  
3ef5 3a 04 3f			ld a, (.dmark+1)  
3ef8 32 66 ee			ld (debug_mark+1),a  
3efb 3a 05 3f			ld a, (.dmark+2)  
3efe 32 67 ee			ld (debug_mark+2),a  
3f01 18 03			jr .pastdmark  
3f03 ..			.dmark: db "CDP"  
3f06 f1			.pastdmark: pop af  
3f07			endm  
# End of macro DMARK
3f07						CALLMONITOR 
3f07 cd 6f ee			call debug_vector  
3f0a				endm  
# End of macro CALLMONITOR
3f0a					endif 
3f0a cd c8 0b				call clear_display 
3f0d cd 10 1a				call dumpcont	 
3f10 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3f11					NEXTW 
3f11 c3 81 1f			jp macro_next 
3f14				endm 
# End of macro NEXTW
3f14			 
3f14			 
3f14			 
3f14			 
3f14			.DAT: 
3f14				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3f14 3d				db WORD_SYS_CORE+41             
3f15 6a 3f			dw .HOME            
3f17 03				db 2 + 1 
3f18 .. 00			db "AT",0              
3f1b				endm 
# End of macro CWHEAD
3f1b			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3f1b					if DEBUG_FORTH_WORDS_KEY 
3f1b						DMARK "AT." 
3f1b f5				push af  
3f1c 3a 30 3f			ld a, (.dmark)  
3f1f 32 65 ee			ld (debug_mark),a  
3f22 3a 31 3f			ld a, (.dmark+1)  
3f25 32 66 ee			ld (debug_mark+1),a  
3f28 3a 32 3f			ld a, (.dmark+2)  
3f2b 32 67 ee			ld (debug_mark+2),a  
3f2e 18 03			jr .pastdmark  
3f30 ..			.dmark: db "AT."  
3f33 f1			.pastdmark: pop af  
3f34			endm  
# End of macro DMARK
3f34						CALLMONITOR 
3f34 cd 6f ee			call debug_vector  
3f37				endm  
# End of macro CALLMONITOR
3f37					endif 
3f37					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f37 cd 95 1d			call macro_dsp_valuehl 
3f3a				endm 
# End of macro FORTH_DSP_VALUEHL
3f3a			 
3f3a			 
3f3a					; TODO save cursor row 
3f3a 7d					ld a,l 
3f3b fe 02				cp 2 
3f3d 20 04				jr nz, .crow3 
3f3f 3e 28				ld a, display_row_2 
3f41 18 12				jr .ccol1 
3f43 fe 03		.crow3:		cp 3 
3f45 20 04				jr nz, .crow4 
3f47 3e 50				ld a, display_row_3 
3f49 18 0a				jr .ccol1 
3f4b fe 04		.crow4:		cp 4 
3f4d 20 04				jr nz, .crow1 
3f4f 3e 78				ld a, display_row_4 
3f51 18 02				jr .ccol1 
3f53 3e 00		.crow1:		ld a,display_row_1 
3f55 f5			.ccol1:		push af			; got row offset 
3f56 6f					ld l,a 
3f57 26 00				ld h,0 
3f59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f59 cd 4d 1e			call macro_forth_dsp_pop 
3f5c				endm 
# End of macro FORTH_DSP_POP
3f5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f5c cd 95 1d			call macro_dsp_valuehl 
3f5f				endm 
# End of macro FORTH_DSP_VALUEHL
3f5f					; TODO save cursor col 
3f5f f1					pop af 
3f60 85					add l		; add col offset 
3f61 32 58 ea				ld (f_cursor_ptr), a 
3f64					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f64 cd 4d 1e			call macro_forth_dsp_pop 
3f67				endm 
# End of macro FORTH_DSP_POP
3f67			 
3f67					; calculate  
3f67			 
3f67					NEXTW 
3f67 c3 81 1f			jp macro_next 
3f6a				endm 
# End of macro NEXTW
3f6a			 
3f6a			 
3f6a			.HOME: 
3f6a				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
3f6a 41				db WORD_SYS_CORE+45             
3f6b 97 3f			dw .CR            
3f6d 05				db 4 + 1 
3f6e .. 00			db "HOME",0              
3f73				endm 
# End of macro CWHEAD
3f73			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f73					if DEBUG_FORTH_WORDS_KEY 
3f73						DMARK "HOM" 
3f73 f5				push af  
3f74 3a 88 3f			ld a, (.dmark)  
3f77 32 65 ee			ld (debug_mark),a  
3f7a 3a 89 3f			ld a, (.dmark+1)  
3f7d 32 66 ee			ld (debug_mark+1),a  
3f80 3a 8a 3f			ld a, (.dmark+2)  
3f83 32 67 ee			ld (debug_mark+2),a  
3f86 18 03			jr .pastdmark  
3f88 ..			.dmark: db "HOM"  
3f8b f1			.pastdmark: pop af  
3f8c			endm  
# End of macro DMARK
3f8c						CALLMONITOR 
3f8c cd 6f ee			call debug_vector  
3f8f				endm  
# End of macro CALLMONITOR
3f8f					endif 
3f8f 3e 00		.home:		ld a, 0		; and home cursor 
3f91 32 58 ea				ld (f_cursor_ptr), a 
3f94					NEXTW 
3f94 c3 81 1f			jp macro_next 
3f97				endm 
# End of macro NEXTW
3f97			 
3f97			 
3f97			.CR: 
3f97				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
3f97 46				db WORD_SYS_CORE+50             
3f98 d2 3f			dw .SPACE            
3f9a 03				db 2 + 1 
3f9b .. 00			db "CR",0              
3f9e				endm 
# End of macro CWHEAD
3f9e			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
3f9e					if DEBUG_FORTH_WORDS_KEY 
3f9e						DMARK "CR." 
3f9e f5				push af  
3f9f 3a b3 3f			ld a, (.dmark)  
3fa2 32 65 ee			ld (debug_mark),a  
3fa5 3a b4 3f			ld a, (.dmark+1)  
3fa8 32 66 ee			ld (debug_mark+1),a  
3fab 3a b5 3f			ld a, (.dmark+2)  
3fae 32 67 ee			ld (debug_mark+2),a  
3fb1 18 03			jr .pastdmark  
3fb3 ..			.dmark: db "CR."  
3fb6 f1			.pastdmark: pop af  
3fb7			endm  
# End of macro DMARK
3fb7						CALLMONITOR 
3fb7 cd 6f ee			call debug_vector  
3fba				endm  
# End of macro CALLMONITOR
3fba					endif 
3fba 3e 0d				ld a, 13 
3fbc 32 bb e2				ld (scratch),a 
3fbf 3e 0a				ld a, 10 
3fc1 32 bc e2				ld (scratch+1),a 
3fc4 3e 00				ld a, 0 
3fc6 32 bd e2				ld (scratch+2),a 
3fc9 21 bb e2				ld hl, scratch 
3fcc cd fe 1b				call forth_push_str 
3fcf					 
3fcf				       NEXTW 
3fcf c3 81 1f			jp macro_next 
3fd2				endm 
# End of macro NEXTW
3fd2			.SPACE: 
3fd2				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3fd2 46				db WORD_SYS_CORE+50             
3fd3 08 40			dw .SPACES            
3fd5 03				db 2 + 1 
3fd6 .. 00			db "BL",0              
3fd9				endm 
# End of macro CWHEAD
3fd9			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3fd9					if DEBUG_FORTH_WORDS_KEY 
3fd9						DMARK "BL." 
3fd9 f5				push af  
3fda 3a ee 3f			ld a, (.dmark)  
3fdd 32 65 ee			ld (debug_mark),a  
3fe0 3a ef 3f			ld a, (.dmark+1)  
3fe3 32 66 ee			ld (debug_mark+1),a  
3fe6 3a f0 3f			ld a, (.dmark+2)  
3fe9 32 67 ee			ld (debug_mark+2),a  
3fec 18 03			jr .pastdmark  
3fee ..			.dmark: db "BL."  
3ff1 f1			.pastdmark: pop af  
3ff2			endm  
# End of macro DMARK
3ff2						CALLMONITOR 
3ff2 cd 6f ee			call debug_vector  
3ff5				endm  
# End of macro CALLMONITOR
3ff5					endif 
3ff5 3e 20				ld a, " " 
3ff7 32 bb e2				ld (scratch),a 
3ffa 3e 00				ld a, 0 
3ffc 32 bc e2				ld (scratch+1),a 
3fff 21 bb e2				ld hl, scratch 
4002 cd fe 1b				call forth_push_str 
4005					 
4005				       NEXTW 
4005 c3 81 1f			jp macro_next 
4008				endm 
# End of macro NEXTW
4008			 
4008			;.blstr: db " ", 0 
4008			 
4008			.SPACES: 
4008				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4008 47				db WORD_SYS_CORE+51             
4009 a3 40			dw .SCROLL            
400b 07				db 6 + 1 
400c .. 00			db "SPACES",0              
4013				endm 
# End of macro CWHEAD
4013			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4013					if DEBUG_FORTH_WORDS_KEY 
4013						DMARK "SPS" 
4013 f5				push af  
4014 3a 28 40			ld a, (.dmark)  
4017 32 65 ee			ld (debug_mark),a  
401a 3a 29 40			ld a, (.dmark+1)  
401d 32 66 ee			ld (debug_mark+1),a  
4020 3a 2a 40			ld a, (.dmark+2)  
4023 32 67 ee			ld (debug_mark+2),a  
4026 18 03			jr .pastdmark  
4028 ..			.dmark: db "SPS"  
402b f1			.pastdmark: pop af  
402c			endm  
# End of macro DMARK
402c						CALLMONITOR 
402c cd 6f ee			call debug_vector  
402f				endm  
# End of macro CALLMONITOR
402f					endif 
402f			 
402f			 
402f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
402f cd 95 1d			call macro_dsp_valuehl 
4032				endm 
# End of macro FORTH_DSP_VALUEHL
4032			 
4032 e5					push hl    ; u 
4033					if DEBUG_FORTH_WORDS 
4033						DMARK "SPA" 
4033 f5				push af  
4034 3a 48 40			ld a, (.dmark)  
4037 32 65 ee			ld (debug_mark),a  
403a 3a 49 40			ld a, (.dmark+1)  
403d 32 66 ee			ld (debug_mark+1),a  
4040 3a 4a 40			ld a, (.dmark+2)  
4043 32 67 ee			ld (debug_mark+2),a  
4046 18 03			jr .pastdmark  
4048 ..			.dmark: db "SPA"  
404b f1			.pastdmark: pop af  
404c			endm  
# End of macro DMARK
404c						CALLMONITOR 
404c cd 6f ee			call debug_vector  
404f				endm  
# End of macro CALLMONITOR
404f					endif 
404f			 
404f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
404f cd 4d 1e			call macro_forth_dsp_pop 
4052				endm 
# End of macro FORTH_DSP_POP
4052 e1					pop hl 
4053 0e 00				ld c, 0 
4055 45					ld b, l 
4056 21 bb e2				ld hl, scratch  
4059			 
4059					if DEBUG_FORTH_WORDS 
4059						DMARK "SP2" 
4059 f5				push af  
405a 3a 6e 40			ld a, (.dmark)  
405d 32 65 ee			ld (debug_mark),a  
4060 3a 6f 40			ld a, (.dmark+1)  
4063 32 66 ee			ld (debug_mark+1),a  
4066 3a 70 40			ld a, (.dmark+2)  
4069 32 67 ee			ld (debug_mark+2),a  
406c 18 03			jr .pastdmark  
406e ..			.dmark: db "SP2"  
4071 f1			.pastdmark: pop af  
4072			endm  
# End of macro DMARK
4072						CALLMONITOR 
4072 cd 6f ee			call debug_vector  
4075				endm  
# End of macro CALLMONITOR
4075					endif 
4075 3e 20				ld a, ' ' 
4077			.spaces1:	 
4077 77					ld (hl),a 
4078 23					inc hl 
4079					 
4079 10 fc				djnz .spaces1 
407b 3e 00				ld a,0 
407d 77					ld (hl),a 
407e 21 bb e2				ld hl, scratch 
4081					if DEBUG_FORTH_WORDS 
4081						DMARK "SP3" 
4081 f5				push af  
4082 3a 96 40			ld a, (.dmark)  
4085 32 65 ee			ld (debug_mark),a  
4088 3a 97 40			ld a, (.dmark+1)  
408b 32 66 ee			ld (debug_mark+1),a  
408e 3a 98 40			ld a, (.dmark+2)  
4091 32 67 ee			ld (debug_mark+2),a  
4094 18 03			jr .pastdmark  
4096 ..			.dmark: db "SP3"  
4099 f1			.pastdmark: pop af  
409a			endm  
# End of macro DMARK
409a						CALLMONITOR 
409a cd 6f ee			call debug_vector  
409d				endm  
# End of macro CALLMONITOR
409d					endif 
409d cd fe 1b				call forth_push_str 
40a0			 
40a0				       NEXTW 
40a0 c3 81 1f			jp macro_next 
40a3				endm 
# End of macro NEXTW
40a3			 
40a3			 
40a3			 
40a3			.SCROLL: 
40a3				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
40a3 53				db WORD_SYS_CORE+63             
40a4 d0 40			dw .SCROLLD            
40a6 07				db 6 + 1 
40a7 .. 00			db "SCROLL",0              
40ae				endm 
# End of macro CWHEAD
40ae			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
40ae					if DEBUG_FORTH_WORDS_KEY 
40ae						DMARK "SCR" 
40ae f5				push af  
40af 3a c3 40			ld a, (.dmark)  
40b2 32 65 ee			ld (debug_mark),a  
40b5 3a c4 40			ld a, (.dmark+1)  
40b8 32 66 ee			ld (debug_mark+1),a  
40bb 3a c5 40			ld a, (.dmark+2)  
40be 32 67 ee			ld (debug_mark+2),a  
40c1 18 03			jr .pastdmark  
40c3 ..			.dmark: db "SCR"  
40c6 f1			.pastdmark: pop af  
40c7			endm  
# End of macro DMARK
40c7						CALLMONITOR 
40c7 cd 6f ee			call debug_vector  
40ca				endm  
# End of macro CALLMONITOR
40ca					endif 
40ca			 
40ca cd 8a 0b			call scroll_up 
40cd			;	call update_display 
40cd			 
40cd					NEXTW 
40cd c3 81 1f			jp macro_next 
40d0				endm 
# End of macro NEXTW
40d0			 
40d0			 
40d0			 
40d0			;		; get dir 
40d0			; 
40d0			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40d0			; 
40d0			;		push hl 
40d0			; 
40d0			;		; destroy value TOS 
40d0			; 
40d0			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40d0			; 
40d0			;		; get count 
40d0			; 
40d0			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40d0			; 
40d0			;		push hl 
40d0			; 
40d0			;		; destroy value TOS 
40d0			; 
40d0			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40d0			; 
40d0			;		; one value on hl get other one back 
40d0			; 
40d0			;		pop bc    ; count 
40d0			; 
40d0			;		pop de   ; dir 
40d0			; 
40d0			; 
40d0			;		ld b, c 
40d0			; 
40d0			;.scrolldir:     push bc 
40d0			;		push de 
40d0			; 
40d0			;		ld a, 0 
40d0			;		cp e 
40d0			;		jr z, .scrollup  
40d0			;		call scroll_down 
40d0			;		jr .scrollnext 
40d0			;.scrollup:	call scroll_up 
40d0			; 
40d0			;		 
40d0			;.scrollnext: 
40d0			;		pop de 
40d0			;		pop bc 
40d0			;		djnz .scrolldir 
40d0			; 
40d0			; 
40d0			; 
40d0			; 
40d0			; 
40d0			;		NEXTW 
40d0			 
40d0			.SCROLLD: 
40d0				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
40d0 53				db WORD_SYS_CORE+63             
40d1 fe 40			dw .ATQ            
40d3 08				db 7 + 1 
40d4 .. 00			db "SCROLLD",0              
40dc				endm 
# End of macro CWHEAD
40dc			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
40dc					if DEBUG_FORTH_WORDS_KEY 
40dc						DMARK "SCD" 
40dc f5				push af  
40dd 3a f1 40			ld a, (.dmark)  
40e0 32 65 ee			ld (debug_mark),a  
40e3 3a f2 40			ld a, (.dmark+1)  
40e6 32 66 ee			ld (debug_mark+1),a  
40e9 3a f3 40			ld a, (.dmark+2)  
40ec 32 67 ee			ld (debug_mark+2),a  
40ef 18 03			jr .pastdmark  
40f1 ..			.dmark: db "SCD"  
40f4 f1			.pastdmark: pop af  
40f5			endm  
# End of macro DMARK
40f5						CALLMONITOR 
40f5 cd 6f ee			call debug_vector  
40f8				endm  
# End of macro CALLMONITOR
40f8					endif 
40f8			 
40f8 cd ae 0b			call scroll_down 
40fb			;	call update_display 
40fb			 
40fb					NEXTW 
40fb c3 81 1f			jp macro_next 
40fe				endm 
# End of macro NEXTW
40fe			 
40fe			 
40fe			.ATQ: 
40fe				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
40fe 62				db WORD_SYS_CORE+78             
40ff 5c 41			dw .AUTODSP            
4101 04				db 3 + 1 
4102 .. 00			db "AT@",0              
4106				endm 
# End of macro CWHEAD
4106			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4106					if DEBUG_FORTH_WORDS_KEY 
4106						DMARK "ATA" 
4106 f5				push af  
4107 3a 1b 41			ld a, (.dmark)  
410a 32 65 ee			ld (debug_mark),a  
410d 3a 1c 41			ld a, (.dmark+1)  
4110 32 66 ee			ld (debug_mark+1),a  
4113 3a 1d 41			ld a, (.dmark+2)  
4116 32 67 ee			ld (debug_mark+2),a  
4119 18 03			jr .pastdmark  
411b ..			.dmark: db "ATA"  
411e f1			.pastdmark: pop af  
411f			endm  
# End of macro DMARK
411f						CALLMONITOR 
411f cd 6f ee			call debug_vector  
4122				endm  
# End of macro CALLMONITOR
4122					endif 
4122			 
4122			 
4122					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4122 cd 95 1d			call macro_dsp_valuehl 
4125				endm 
# End of macro FORTH_DSP_VALUEHL
4125			 
4125					; TODO save cursor row 
4125 7d					ld a,l 
4126 fe 02				cp 2 
4128 20 04				jr nz, .crow3aq 
412a 3e 28				ld a, display_row_2 
412c 18 12				jr .ccol1aq 
412e fe 03		.crow3aq:		cp 3 
4130 20 04				jr nz, .crow4aq 
4132 3e 50				ld a, display_row_3 
4134 18 0a				jr .ccol1aq 
4136 fe 04		.crow4aq:		cp 4 
4138 20 04				jr nz, .crow1aq 
413a 3e 78				ld a, display_row_4 
413c 18 02				jr .ccol1aq 
413e 3e 00		.crow1aq:		ld a,display_row_1 
4140 f5			.ccol1aq:		push af			; got row offset 
4141 6f					ld l,a 
4142 26 00				ld h,0 
4144					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4144 cd 4d 1e			call macro_forth_dsp_pop 
4147				endm 
# End of macro FORTH_DSP_POP
4147					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4147 cd 95 1d			call macro_dsp_valuehl 
414a				endm 
# End of macro FORTH_DSP_VALUEHL
414a					; TODO save cursor col 
414a f1					pop af 
414b 85					add l		; add col offset 
414c			 
414c					; add current frame buffer address 
414c 2a c6 eb				ld hl, (display_fb_active) 
414f cd f5 0d				call addatohl 
4152			 
4152			 
4152			 
4152			 
4152					; get char frame buffer location offset in hl 
4152			 
4152 7e					ld a,(hl) 
4153 26 00				ld h, 0 
4155 6f					ld l, a 
4156			 
4156 cd 90 1b				call forth_push_numhl 
4159			 
4159			 
4159					NEXTW 
4159 c3 81 1f			jp macro_next 
415c				endm 
# End of macro NEXTW
415c			 
415c			.AUTODSP: 
415c				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
415c 63				db WORD_SYS_CORE+79             
415d 72 41			dw .MENU            
415f 05				db 4 + 1 
4160 .. 00			db "ADSP",0              
4165				endm 
# End of macro CWHEAD
4165			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4165			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4165			 
4165					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4165 cd 95 1d			call macro_dsp_valuehl 
4168				endm 
# End of macro FORTH_DSP_VALUEHL
4168			 
4168			;		push hl 
4168			 
4168					; destroy value TOS 
4168			 
4168					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4168 cd 4d 1e			call macro_forth_dsp_pop 
416b				endm 
# End of macro FORTH_DSP_POP
416b			 
416b			;		pop hl 
416b			 
416b 7d					ld a,l 
416c 32 36 ea				ld (cli_autodisplay), a 
416f				       NEXTW 
416f c3 81 1f			jp macro_next 
4172				endm 
# End of macro NEXTW
4172			 
4172			.MENU: 
4172				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4172 70				db WORD_SYS_CORE+92             
4173 1b 42			dw .ENDDISPLAY            
4175 05				db 4 + 1 
4176 .. 00			db "MENU",0              
417b				endm 
# End of macro CWHEAD
417b			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
417b			 
417b			;		; get number of items on the stack 
417b			; 
417b				 
417b					FORTH_DSP_VALUEHL 
417b cd 95 1d			call macro_dsp_valuehl 
417e				endm 
# End of macro FORTH_DSP_VALUEHL
417e				 
417e					if DEBUG_FORTH_WORDS_KEY 
417e						DMARK "MNU" 
417e f5				push af  
417f 3a 93 41			ld a, (.dmark)  
4182 32 65 ee			ld (debug_mark),a  
4185 3a 94 41			ld a, (.dmark+1)  
4188 32 66 ee			ld (debug_mark+1),a  
418b 3a 95 41			ld a, (.dmark+2)  
418e 32 67 ee			ld (debug_mark+2),a  
4191 18 03			jr .pastdmark  
4193 ..			.dmark: db "MNU"  
4196 f1			.pastdmark: pop af  
4197			endm  
# End of macro DMARK
4197						CALLMONITOR 
4197 cd 6f ee			call debug_vector  
419a				endm  
# End of macro CALLMONITOR
419a					endif 
419a			 
419a 45					ld b, l	 
419b 05					dec b 
419c			 
419c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
419c cd 4d 1e			call macro_forth_dsp_pop 
419f				endm 
# End of macro FORTH_DSP_POP
419f			 
419f			 
419f					; go directly through the stack to pluck out the string pointers and build an array 
419f			 
419f			;		FORTH_DSP 
419f			 
419f					; hl contains top most stack item 
419f				 
419f 11 bb e2				ld de, scratch 
41a2			 
41a2			.mbuild: 
41a2			 
41a2					FORTH_DSP_VALUEHL 
41a2 cd 95 1d			call macro_dsp_valuehl 
41a5				endm 
# End of macro FORTH_DSP_VALUEHL
41a5			 
41a5					if DEBUG_FORTH_WORDS 
41a5						DMARK "MN3" 
41a5 f5				push af  
41a6 3a ba 41			ld a, (.dmark)  
41a9 32 65 ee			ld (debug_mark),a  
41ac 3a bb 41			ld a, (.dmark+1)  
41af 32 66 ee			ld (debug_mark+1),a  
41b2 3a bc 41			ld a, (.dmark+2)  
41b5 32 67 ee			ld (debug_mark+2),a  
41b8 18 03			jr .pastdmark  
41ba ..			.dmark: db "MN3"  
41bd f1			.pastdmark: pop af  
41be			endm  
# End of macro DMARK
41be						CALLMONITOR 
41be cd 6f ee			call debug_vector  
41c1				endm  
# End of macro CALLMONITOR
41c1					endif 
41c1 eb					ex de, hl 
41c2 73					ld (hl), e 
41c3 23					inc hl 
41c4 72					ld (hl), d 
41c5 23					inc hl 
41c6 eb					ex de, hl 
41c7			 
41c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41c7 cd 4d 1e			call macro_forth_dsp_pop 
41ca				endm 
# End of macro FORTH_DSP_POP
41ca			 
41ca 10 d6				djnz .mbuild 
41cc			 
41cc					; done add term 
41cc			 
41cc eb					ex de, hl 
41cd 36 00				ld (hl), 0 
41cf 23					inc hl 
41d0 36 00				ld (hl), 0 
41d2			 
41d2				 
41d2					 
41d2 21 bb e2				ld hl, scratch 
41d5			 
41d5					if DEBUG_FORTH_WORDS 
41d5						DMARK "MNx" 
41d5 f5				push af  
41d6 3a ea 41			ld a, (.dmark)  
41d9 32 65 ee			ld (debug_mark),a  
41dc 3a eb 41			ld a, (.dmark+1)  
41df 32 66 ee			ld (debug_mark+1),a  
41e2 3a ec 41			ld a, (.dmark+2)  
41e5 32 67 ee			ld (debug_mark+2),a  
41e8 18 03			jr .pastdmark  
41ea ..			.dmark: db "MNx"  
41ed f1			.pastdmark: pop af  
41ee			endm  
# End of macro DMARK
41ee						CALLMONITOR 
41ee cd 6f ee			call debug_vector  
41f1				endm  
# End of macro CALLMONITOR
41f1					endif 
41f1			 
41f1			 
41f1			 
41f1 3e 00				ld a, 0 
41f3 cd f9 0b				call menu 
41f6			 
41f6			 
41f6 6f					ld l, a 
41f7 26 00				ld h, 0 
41f9			 
41f9					if DEBUG_FORTH_WORDS 
41f9						DMARK "MNr" 
41f9 f5				push af  
41fa 3a 0e 42			ld a, (.dmark)  
41fd 32 65 ee			ld (debug_mark),a  
4200 3a 0f 42			ld a, (.dmark+1)  
4203 32 66 ee			ld (debug_mark+1),a  
4206 3a 10 42			ld a, (.dmark+2)  
4209 32 67 ee			ld (debug_mark+2),a  
420c 18 03			jr .pastdmark  
420e ..			.dmark: db "MNr"  
4211 f1			.pastdmark: pop af  
4212			endm  
# End of macro DMARK
4212						CALLMONITOR 
4212 cd 6f ee			call debug_vector  
4215				endm  
# End of macro CALLMONITOR
4215					endif 
4215			 
4215 cd 90 1b				call forth_push_numhl 
4218			 
4218			 
4218			 
4218			 
4218				       NEXTW 
4218 c3 81 1f			jp macro_next 
421b				endm 
# End of macro NEXTW
421b			 
421b			 
421b			.ENDDISPLAY: 
421b			 
421b			; eof 
# End of file forth_words_display.asm
421b			include "forth_words_str.asm" 
421b			 
421b			; | ## String Words 
421b			 
421b			.PTR:   
421b			 
421b				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
421b 48				db WORD_SYS_CORE+52             
421c 48 42			dw .STYPE            
421e 04				db 3 + 1 
421f .. 00			db "PTR",0              
4223				endm 
# End of macro CWHEAD
4223			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4223			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4223			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4223			 
4223					if DEBUG_FORTH_WORDS_KEY 
4223						DMARK "PTR" 
4223 f5				push af  
4224 3a 38 42			ld a, (.dmark)  
4227 32 65 ee			ld (debug_mark),a  
422a 3a 39 42			ld a, (.dmark+1)  
422d 32 66 ee			ld (debug_mark+1),a  
4230 3a 3a 42			ld a, (.dmark+2)  
4233 32 67 ee			ld (debug_mark+2),a  
4236 18 03			jr .pastdmark  
4238 ..			.dmark: db "PTR"  
423b f1			.pastdmark: pop af  
423c			endm  
# End of macro DMARK
423c						CALLMONITOR 
423c cd 6f ee			call debug_vector  
423f				endm  
# End of macro CALLMONITOR
423f					endif 
423f					FORTH_DSP_VALUEHL 
423f cd 95 1d			call macro_dsp_valuehl 
4242				endm 
# End of macro FORTH_DSP_VALUEHL
4242 cd 90 1b				call forth_push_numhl 
4245			 
4245			 
4245					NEXTW 
4245 c3 81 1f			jp macro_next 
4248				endm 
# End of macro NEXTW
4248			.STYPE: 
4248				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4248 48				db WORD_SYS_CORE+52             
4249 97 42			dw .UPPER            
424b 06				db 5 + 1 
424c .. 00			db "STYPE",0              
4252				endm 
# End of macro CWHEAD
4252			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4252					if DEBUG_FORTH_WORDS_KEY 
4252						DMARK "STY" 
4252 f5				push af  
4253 3a 67 42			ld a, (.dmark)  
4256 32 65 ee			ld (debug_mark),a  
4259 3a 68 42			ld a, (.dmark+1)  
425c 32 66 ee			ld (debug_mark+1),a  
425f 3a 69 42			ld a, (.dmark+2)  
4262 32 67 ee			ld (debug_mark+2),a  
4265 18 03			jr .pastdmark  
4267 ..			.dmark: db "STY"  
426a f1			.pastdmark: pop af  
426b			endm  
# End of macro DMARK
426b						CALLMONITOR 
426b cd 6f ee			call debug_vector  
426e				endm  
# End of macro CALLMONITOR
426e					endif 
426e					FORTH_DSP 
426e cd 5b 1d			call macro_forth_dsp 
4271				endm 
# End of macro FORTH_DSP
4271					;v5 FORTH_DSP_VALUE 
4271			 
4271 7e					ld a, (hl) 
4272			 
4272 f5					push af 
4273			 
4273			; Dont destroy TOS		FORTH_DSP_POP 
4273			 
4273 f1					pop af 
4274			 
4274 fe 01				cp DS_TYPE_STR 
4276 28 09				jr z, .typestr 
4278			 
4278 fe 02				cp DS_TYPE_INUM 
427a 28 0a				jr z, .typeinum 
427c			 
427c 21 95 42				ld hl, .tna 
427f 18 0a				jr .tpush 
4281			 
4281 21 91 42		.typestr:	ld hl, .tstr 
4284 18 05				jr .tpush 
4286 21 93 42		.typeinum:	ld hl, .tinum 
4289 18 00				jr .tpush 
428b			 
428b			.tpush: 
428b			 
428b cd fe 1b				call forth_push_str 
428e			 
428e					NEXTW 
428e c3 81 1f			jp macro_next 
4291				endm 
# End of macro NEXTW
4291 .. 00		.tstr:	db "s",0 
4293 .. 00		.tinum:  db "i",0 
4295 .. 00		.tna:   db "?", 0 
4297			 
4297			 
4297			.UPPER: 
4297				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4297 48				db WORD_SYS_CORE+52             
4298 d2 42			dw .LOWER            
429a 06				db 5 + 1 
429b .. 00			db "UPPER",0              
42a1				endm 
# End of macro CWHEAD
42a1			; | UPPER ( s -- s ) Upper case string s  | DONE 
42a1					if DEBUG_FORTH_WORDS_KEY 
42a1						DMARK "UPR" 
42a1 f5				push af  
42a2 3a b6 42			ld a, (.dmark)  
42a5 32 65 ee			ld (debug_mark),a  
42a8 3a b7 42			ld a, (.dmark+1)  
42ab 32 66 ee			ld (debug_mark+1),a  
42ae 3a b8 42			ld a, (.dmark+2)  
42b1 32 67 ee			ld (debug_mark+2),a  
42b4 18 03			jr .pastdmark  
42b6 ..			.dmark: db "UPR"  
42b9 f1			.pastdmark: pop af  
42ba			endm  
# End of macro DMARK
42ba						CALLMONITOR 
42ba cd 6f ee			call debug_vector  
42bd				endm  
# End of macro CALLMONITOR
42bd					endif 
42bd			 
42bd					FORTH_DSP 
42bd cd 5b 1d			call macro_forth_dsp 
42c0				endm 
# End of macro FORTH_DSP
42c0					 
42c0			; TODO check is string type 
42c0			 
42c0					FORTH_DSP_VALUEHL 
42c0 cd 95 1d			call macro_dsp_valuehl 
42c3				endm 
# End of macro FORTH_DSP_VALUEHL
42c3			; get pointer to string in hl 
42c3			 
42c3 7e			.toup:		ld a, (hl) 
42c4 fe 00				cp 0 
42c6 28 07				jr z, .toupdone 
42c8			 
42c8 cd 6a 10				call to_upper 
42cb			 
42cb 77					ld (hl), a 
42cc 23					inc hl 
42cd 18 f4				jr .toup 
42cf			 
42cf					 
42cf			 
42cf			 
42cf			; for each char convert to upper 
42cf					 
42cf			.toupdone: 
42cf			 
42cf			 
42cf					NEXTW 
42cf c3 81 1f			jp macro_next 
42d2				endm 
# End of macro NEXTW
42d2			.LOWER: 
42d2				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
42d2 48				db WORD_SYS_CORE+52             
42d3 0d 43			dw .TCASE            
42d5 06				db 5 + 1 
42d6 .. 00			db "LOWER",0              
42dc				endm 
# End of macro CWHEAD
42dc			; | LOWER ( s -- s ) Lower case string s  | DONE 
42dc					if DEBUG_FORTH_WORDS_KEY 
42dc						DMARK "LWR" 
42dc f5				push af  
42dd 3a f1 42			ld a, (.dmark)  
42e0 32 65 ee			ld (debug_mark),a  
42e3 3a f2 42			ld a, (.dmark+1)  
42e6 32 66 ee			ld (debug_mark+1),a  
42e9 3a f3 42			ld a, (.dmark+2)  
42ec 32 67 ee			ld (debug_mark+2),a  
42ef 18 03			jr .pastdmark  
42f1 ..			.dmark: db "LWR"  
42f4 f1			.pastdmark: pop af  
42f5			endm  
# End of macro DMARK
42f5						CALLMONITOR 
42f5 cd 6f ee			call debug_vector  
42f8				endm  
# End of macro CALLMONITOR
42f8					endif 
42f8			 
42f8					FORTH_DSP 
42f8 cd 5b 1d			call macro_forth_dsp 
42fb				endm 
# End of macro FORTH_DSP
42fb					 
42fb			; TODO check is string type 
42fb			 
42fb					FORTH_DSP_VALUEHL 
42fb cd 95 1d			call macro_dsp_valuehl 
42fe				endm 
# End of macro FORTH_DSP_VALUEHL
42fe			; get pointer to string in hl 
42fe			 
42fe 7e			.tolow:		ld a, (hl) 
42ff fe 00				cp 0 
4301 28 07				jr z, .tolowdone 
4303			 
4303 cd 73 10				call to_lower 
4306			 
4306 77					ld (hl), a 
4307 23					inc hl 
4308 18 f4				jr .tolow 
430a			 
430a					 
430a			 
430a			 
430a			; for each char convert to low 
430a					 
430a			.tolowdone: 
430a					NEXTW 
430a c3 81 1f			jp macro_next 
430d				endm 
# End of macro NEXTW
430d			.TCASE: 
430d				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
430d 48				db WORD_SYS_CORE+52             
430e 43 44			dw .SUBSTR            
4310 06				db 5 + 1 
4311 .. 00			db "TCASE",0              
4317				endm 
# End of macro CWHEAD
4317			; | TCASE ( s -- s ) Title case string s  | DONE 
4317					if DEBUG_FORTH_WORDS_KEY 
4317						DMARK "TCS" 
4317 f5				push af  
4318 3a 2c 43			ld a, (.dmark)  
431b 32 65 ee			ld (debug_mark),a  
431e 3a 2d 43			ld a, (.dmark+1)  
4321 32 66 ee			ld (debug_mark+1),a  
4324 3a 2e 43			ld a, (.dmark+2)  
4327 32 67 ee			ld (debug_mark+2),a  
432a 18 03			jr .pastdmark  
432c ..			.dmark: db "TCS"  
432f f1			.pastdmark: pop af  
4330			endm  
# End of macro DMARK
4330						CALLMONITOR 
4330 cd 6f ee			call debug_vector  
4333				endm  
# End of macro CALLMONITOR
4333					endif 
4333			 
4333					FORTH_DSP 
4333 cd 5b 1d			call macro_forth_dsp 
4336				endm 
# End of macro FORTH_DSP
4336					 
4336			; TODO check is string type 
4336			 
4336					FORTH_DSP_VALUEHL 
4336 cd 95 1d			call macro_dsp_valuehl 
4339				endm 
# End of macro FORTH_DSP_VALUEHL
4339			; get pointer to string in hl 
4339			 
4339					if DEBUG_FORTH_WORDS 
4339						DMARK "TC1" 
4339 f5				push af  
433a 3a 4e 43			ld a, (.dmark)  
433d 32 65 ee			ld (debug_mark),a  
4340 3a 4f 43			ld a, (.dmark+1)  
4343 32 66 ee			ld (debug_mark+1),a  
4346 3a 50 43			ld a, (.dmark+2)  
4349 32 67 ee			ld (debug_mark+2),a  
434c 18 03			jr .pastdmark  
434e ..			.dmark: db "TC1"  
4351 f1			.pastdmark: pop af  
4352			endm  
# End of macro DMARK
4352						CALLMONITOR 
4352 cd 6f ee			call debug_vector  
4355				endm  
# End of macro CALLMONITOR
4355					endif 
4355			 
4355					; first time in turn to upper case first char 
4355			 
4355 7e					ld a, (hl) 
4356 c3 e0 43				jp .totsiptou 
4359			 
4359			 
4359 7e			.tot:		ld a, (hl) 
435a fe 00				cp 0 
435c ca 24 44				jp z, .totdone 
435f			 
435f					if DEBUG_FORTH_WORDS 
435f						DMARK "TC2" 
435f f5				push af  
4360 3a 74 43			ld a, (.dmark)  
4363 32 65 ee			ld (debug_mark),a  
4366 3a 75 43			ld a, (.dmark+1)  
4369 32 66 ee			ld (debug_mark+1),a  
436c 3a 76 43			ld a, (.dmark+2)  
436f 32 67 ee			ld (debug_mark+2),a  
4372 18 03			jr .pastdmark  
4374 ..			.dmark: db "TC2"  
4377 f1			.pastdmark: pop af  
4378			endm  
# End of macro DMARK
4378						CALLMONITOR 
4378 cd 6f ee			call debug_vector  
437b				endm  
# End of macro CALLMONITOR
437b					endif 
437b					; check to see if current char is a space 
437b			 
437b fe 20				cp ' ' 
437d 28 21				jr z, .totsp 
437f cd 73 10				call to_lower 
4382					if DEBUG_FORTH_WORDS 
4382						DMARK "TC3" 
4382 f5				push af  
4383 3a 97 43			ld a, (.dmark)  
4386 32 65 ee			ld (debug_mark),a  
4389 3a 98 43			ld a, (.dmark+1)  
438c 32 66 ee			ld (debug_mark+1),a  
438f 3a 99 43			ld a, (.dmark+2)  
4392 32 67 ee			ld (debug_mark+2),a  
4395 18 03			jr .pastdmark  
4397 ..			.dmark: db "TC3"  
439a f1			.pastdmark: pop af  
439b			endm  
# End of macro DMARK
439b						CALLMONITOR 
439b cd 6f ee			call debug_vector  
439e				endm  
# End of macro CALLMONITOR
439e					endif 
439e 18 63				jr .totnxt 
43a0			 
43a0			.totsp:         ; on a space, find next char which should be upper 
43a0			 
43a0					if DEBUG_FORTH_WORDS 
43a0						DMARK "TC4" 
43a0 f5				push af  
43a1 3a b5 43			ld a, (.dmark)  
43a4 32 65 ee			ld (debug_mark),a  
43a7 3a b6 43			ld a, (.dmark+1)  
43aa 32 66 ee			ld (debug_mark+1),a  
43ad 3a b7 43			ld a, (.dmark+2)  
43b0 32 67 ee			ld (debug_mark+2),a  
43b3 18 03			jr .pastdmark  
43b5 ..			.dmark: db "TC4"  
43b8 f1			.pastdmark: pop af  
43b9			endm  
# End of macro DMARK
43b9						CALLMONITOR 
43b9 cd 6f ee			call debug_vector  
43bc				endm  
# End of macro CALLMONITOR
43bc					endif 
43bc					;; 
43bc			 
43bc fe 20				cp ' ' 
43be 20 20				jr nz, .totsiptou 
43c0 23					inc hl 
43c1 7e					ld a, (hl) 
43c2					if DEBUG_FORTH_WORDS 
43c2						DMARK "TC5" 
43c2 f5				push af  
43c3 3a d7 43			ld a, (.dmark)  
43c6 32 65 ee			ld (debug_mark),a  
43c9 3a d8 43			ld a, (.dmark+1)  
43cc 32 66 ee			ld (debug_mark+1),a  
43cf 3a d9 43			ld a, (.dmark+2)  
43d2 32 67 ee			ld (debug_mark+2),a  
43d5 18 03			jr .pastdmark  
43d7 ..			.dmark: db "TC5"  
43da f1			.pastdmark: pop af  
43db			endm  
# End of macro DMARK
43db						CALLMONITOR 
43db cd 6f ee			call debug_vector  
43de				endm  
# End of macro CALLMONITOR
43de					endif 
43de 18 c0				jr .totsp 
43e0 fe 00		.totsiptou:    cp 0 
43e2 28 40				jr z, .totdone 
43e4					; not space and not zero term so upper case it 
43e4 cd 6a 10				call to_upper 
43e7			 
43e7					if DEBUG_FORTH_WORDS 
43e7						DMARK "TC6" 
43e7 f5				push af  
43e8 3a fc 43			ld a, (.dmark)  
43eb 32 65 ee			ld (debug_mark),a  
43ee 3a fd 43			ld a, (.dmark+1)  
43f1 32 66 ee			ld (debug_mark+1),a  
43f4 3a fe 43			ld a, (.dmark+2)  
43f7 32 67 ee			ld (debug_mark+2),a  
43fa 18 03			jr .pastdmark  
43fc ..			.dmark: db "TC6"  
43ff f1			.pastdmark: pop af  
4400			endm  
# End of macro DMARK
4400						CALLMONITOR 
4400 cd 6f ee			call debug_vector  
4403				endm  
# End of macro CALLMONITOR
4403					endif 
4403			 
4403			 
4403			.totnxt: 
4403			 
4403 77					ld (hl), a 
4404 23					inc hl 
4405					if DEBUG_FORTH_WORDS 
4405						DMARK "TC7" 
4405 f5				push af  
4406 3a 1a 44			ld a, (.dmark)  
4409 32 65 ee			ld (debug_mark),a  
440c 3a 1b 44			ld a, (.dmark+1)  
440f 32 66 ee			ld (debug_mark+1),a  
4412 3a 1c 44			ld a, (.dmark+2)  
4415 32 67 ee			ld (debug_mark+2),a  
4418 18 03			jr .pastdmark  
441a ..			.dmark: db "TC7"  
441d f1			.pastdmark: pop af  
441e			endm  
# End of macro DMARK
441e						CALLMONITOR 
441e cd 6f ee			call debug_vector  
4421				endm  
# End of macro CALLMONITOR
4421					endif 
4421 c3 59 43				jp .tot 
4424			 
4424					 
4424			 
4424			 
4424			; for each char convert to low 
4424					 
4424			.totdone: 
4424					if DEBUG_FORTH_WORDS 
4424						DMARK "TCd" 
4424 f5				push af  
4425 3a 39 44			ld a, (.dmark)  
4428 32 65 ee			ld (debug_mark),a  
442b 3a 3a 44			ld a, (.dmark+1)  
442e 32 66 ee			ld (debug_mark+1),a  
4431 3a 3b 44			ld a, (.dmark+2)  
4434 32 67 ee			ld (debug_mark+2),a  
4437 18 03			jr .pastdmark  
4439 ..			.dmark: db "TCd"  
443c f1			.pastdmark: pop af  
443d			endm  
# End of macro DMARK
443d						CALLMONITOR 
443d cd 6f ee			call debug_vector  
4440				endm  
# End of macro CALLMONITOR
4440					endif 
4440					NEXTW 
4440 c3 81 1f			jp macro_next 
4443				endm 
# End of macro NEXTW
4443			 
4443			.SUBSTR: 
4443				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4443 48				db WORD_SYS_CORE+52             
4444 a1 44			dw .LEFT            
4446 07				db 6 + 1 
4447 .. 00			db "SUBSTR",0              
444e				endm 
# End of macro CWHEAD
444e			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
444e			 
444e					if DEBUG_FORTH_WORDS_KEY 
444e						DMARK "SST" 
444e f5				push af  
444f 3a 63 44			ld a, (.dmark)  
4452 32 65 ee			ld (debug_mark),a  
4455 3a 64 44			ld a, (.dmark+1)  
4458 32 66 ee			ld (debug_mark+1),a  
445b 3a 65 44			ld a, (.dmark+2)  
445e 32 67 ee			ld (debug_mark+2),a  
4461 18 03			jr .pastdmark  
4463 ..			.dmark: db "SST"  
4466 f1			.pastdmark: pop af  
4467			endm  
# End of macro DMARK
4467						CALLMONITOR 
4467 cd 6f ee			call debug_vector  
446a				endm  
# End of macro CALLMONITOR
446a					endif 
446a			; TODO check string type 
446a					FORTH_DSP_VALUEHL 
446a cd 95 1d			call macro_dsp_valuehl 
446d				endm 
# End of macro FORTH_DSP_VALUEHL
446d			 
446d e5					push hl      ; string length 
446e			 
446e					FORTH_DSP_POP 
446e cd 4d 1e			call macro_forth_dsp_pop 
4471				endm 
# End of macro FORTH_DSP_POP
4471			 
4471					FORTH_DSP_VALUEHL 
4471 cd 95 1d			call macro_dsp_valuehl 
4474				endm 
# End of macro FORTH_DSP_VALUEHL
4474			 
4474 e5					push hl     ; start char 
4475			 
4475					FORTH_DSP_POP 
4475 cd 4d 1e			call macro_forth_dsp_pop 
4478				endm 
# End of macro FORTH_DSP_POP
4478			 
4478			 
4478					FORTH_DSP_VALUE 
4478 cd 7e 1d			call macro_forth_dsp_value 
447b				endm 
# End of macro FORTH_DSP_VALUE
447b			 
447b d1					pop de    ; get start post offset 
447c			 
447c 19					add hl, de    ; starting offset 
447d			 
447d c1					pop bc 
447e c5					push bc      ; grab size of string 
447f			 
447f e5					push hl    ; save string start  
4480			 
4480 26 00				ld h, 0 
4482 69					ld l, c 
4483 23					inc hl 
4484 23					inc hl 
4485			 
4485 cd d0 11				call malloc 
4488				if DEBUG_FORTH_MALLOC_GUARD 
4488 cc bb 4d				call z,malloc_error 
448b				endif 
448b			 
448b eb					ex de, hl      ; save malloc area for string copy 
448c e1					pop hl    ; get back source 
448d c1					pop bc    ; get length of string back 
448e			 
448e d5					push de    ; save malloc area for after we push 
448f ed b0				ldir     ; copy substr 
4491			 
4491			 
4491 eb					ex de, hl 
4492 3e 00				ld a, 0 
4494 77					ld (hl), a   ; term substr 
4495			 
4495					 
4495 e1					pop hl    ; get malloc so we can push it 
4496 e5					push hl   ; save so we can free it afterwards 
4497			 
4497 cd fe 1b				call forth_push_str 
449a			 
449a e1					pop hl 
449b cd 9a 12				call free 
449e			 
449e					 
449e					 
449e			 
449e			 
449e					NEXTW 
449e c3 81 1f			jp macro_next 
44a1				endm 
# End of macro NEXTW
44a1			 
44a1			.LEFT: 
44a1				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
44a1 48				db WORD_SYS_CORE+52             
44a2 c9 44			dw .RIGHT            
44a4 05				db 4 + 1 
44a5 .. 00			db "LEFT",0              
44aa				endm 
# End of macro CWHEAD
44aa			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
44aa					if DEBUG_FORTH_WORDS_KEY 
44aa						DMARK "LEF" 
44aa f5				push af  
44ab 3a bf 44			ld a, (.dmark)  
44ae 32 65 ee			ld (debug_mark),a  
44b1 3a c0 44			ld a, (.dmark+1)  
44b4 32 66 ee			ld (debug_mark+1),a  
44b7 3a c1 44			ld a, (.dmark+2)  
44ba 32 67 ee			ld (debug_mark+2),a  
44bd 18 03			jr .pastdmark  
44bf ..			.dmark: db "LEF"  
44c2 f1			.pastdmark: pop af  
44c3			endm  
# End of macro DMARK
44c3						CALLMONITOR 
44c3 cd 6f ee			call debug_vector  
44c6				endm  
# End of macro CALLMONITOR
44c6					endif 
44c6			 
44c6					NEXTW 
44c6 c3 81 1f			jp macro_next 
44c9				endm 
# End of macro NEXTW
44c9			.RIGHT: 
44c9				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
44c9 48				db WORD_SYS_CORE+52             
44ca f2 44			dw .STR2NUM            
44cc 06				db 5 + 1 
44cd .. 00			db "RIGHT",0              
44d3				endm 
# End of macro CWHEAD
44d3			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
44d3					if DEBUG_FORTH_WORDS_KEY 
44d3						DMARK "RIG" 
44d3 f5				push af  
44d4 3a e8 44			ld a, (.dmark)  
44d7 32 65 ee			ld (debug_mark),a  
44da 3a e9 44			ld a, (.dmark+1)  
44dd 32 66 ee			ld (debug_mark+1),a  
44e0 3a ea 44			ld a, (.dmark+2)  
44e3 32 67 ee			ld (debug_mark+2),a  
44e6 18 03			jr .pastdmark  
44e8 ..			.dmark: db "RIG"  
44eb f1			.pastdmark: pop af  
44ec			endm  
# End of macro DMARK
44ec						CALLMONITOR 
44ec cd 6f ee			call debug_vector  
44ef				endm  
# End of macro CALLMONITOR
44ef					endif 
44ef			 
44ef					NEXTW 
44ef c3 81 1f			jp macro_next 
44f2				endm 
# End of macro NEXTW
44f2			 
44f2			 
44f2			.STR2NUM: 
44f2				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
44f2 48				db WORD_SYS_CORE+52             
44f3 7e 45			dw .NUM2STR            
44f5 08				db 7 + 1 
44f6 .. 00			db "STR2NUM",0              
44fe				endm 
# End of macro CWHEAD
44fe			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
44fe			 
44fe			 
44fe			; TODO STR type check to do 
44fe					if DEBUG_FORTH_WORDS_KEY 
44fe						DMARK "S2N" 
44fe f5				push af  
44ff 3a 13 45			ld a, (.dmark)  
4502 32 65 ee			ld (debug_mark),a  
4505 3a 14 45			ld a, (.dmark+1)  
4508 32 66 ee			ld (debug_mark+1),a  
450b 3a 15 45			ld a, (.dmark+2)  
450e 32 67 ee			ld (debug_mark+2),a  
4511 18 03			jr .pastdmark  
4513 ..			.dmark: db "S2N"  
4516 f1			.pastdmark: pop af  
4517			endm  
# End of macro DMARK
4517						CALLMONITOR 
4517 cd 6f ee			call debug_vector  
451a				endm  
# End of macro CALLMONITOR
451a					endif 
451a			 
451a					;FORTH_DSP 
451a					FORTH_DSP_VALUE 
451a cd 7e 1d			call macro_forth_dsp_value 
451d				endm 
# End of macro FORTH_DSP_VALUE
451d					;inc hl 
451d			 
451d eb					ex de, hl 
451e					if DEBUG_FORTH_WORDS 
451e						DMARK "S2a" 
451e f5				push af  
451f 3a 33 45			ld a, (.dmark)  
4522 32 65 ee			ld (debug_mark),a  
4525 3a 34 45			ld a, (.dmark+1)  
4528 32 66 ee			ld (debug_mark+1),a  
452b 3a 35 45			ld a, (.dmark+2)  
452e 32 67 ee			ld (debug_mark+2),a  
4531 18 03			jr .pastdmark  
4533 ..			.dmark: db "S2a"  
4536 f1			.pastdmark: pop af  
4537			endm  
# End of macro DMARK
4537						CALLMONITOR 
4537 cd 6f ee			call debug_vector  
453a				endm  
# End of macro CALLMONITOR
453a					endif 
453a cd f2 10				call string_to_uint16 
453d			 
453d					if DEBUG_FORTH_WORDS 
453d						DMARK "S2b" 
453d f5				push af  
453e 3a 52 45			ld a, (.dmark)  
4541 32 65 ee			ld (debug_mark),a  
4544 3a 53 45			ld a, (.dmark+1)  
4547 32 66 ee			ld (debug_mark+1),a  
454a 3a 54 45			ld a, (.dmark+2)  
454d 32 67 ee			ld (debug_mark+2),a  
4550 18 03			jr .pastdmark  
4552 ..			.dmark: db "S2b"  
4555 f1			.pastdmark: pop af  
4556			endm  
# End of macro DMARK
4556						CALLMONITOR 
4556 cd 6f ee			call debug_vector  
4559				endm  
# End of macro CALLMONITOR
4559					endif 
4559			;		push hl 
4559					FORTH_DSP_POP 
4559 cd 4d 1e			call macro_forth_dsp_pop 
455c				endm 
# End of macro FORTH_DSP_POP
455c			;		pop hl 
455c					 
455c					if DEBUG_FORTH_WORDS 
455c						DMARK "S2b" 
455c f5				push af  
455d 3a 71 45			ld a, (.dmark)  
4560 32 65 ee			ld (debug_mark),a  
4563 3a 72 45			ld a, (.dmark+1)  
4566 32 66 ee			ld (debug_mark+1),a  
4569 3a 73 45			ld a, (.dmark+2)  
456c 32 67 ee			ld (debug_mark+2),a  
456f 18 03			jr .pastdmark  
4571 ..			.dmark: db "S2b"  
4574 f1			.pastdmark: pop af  
4575			endm  
# End of macro DMARK
4575						CALLMONITOR 
4575 cd 6f ee			call debug_vector  
4578				endm  
# End of macro CALLMONITOR
4578					endif 
4578 cd 90 1b				call forth_push_numhl	 
457b			 
457b				 
457b				       NEXTW 
457b c3 81 1f			jp macro_next 
457e				endm 
# End of macro NEXTW
457e			.NUM2STR: 
457e				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
457e 48				db WORD_SYS_CORE+52             
457f 8d 45			dw .CONCAT            
4581 08				db 7 + 1 
4582 .. 00			db "NUM2STR",0              
458a				endm 
# End of macro CWHEAD
458a			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
458a			 
458a			;		; malloc a string to target 
458a			;		ld hl, 10     ; TODO max string size should be fine 
458a			;		call malloc 
458a			;		push hl    ; save malloc location 
458a			; 
458a			; 
458a			;; TODO check int type 
458a			;		FORTH_DSP_VALUEHL 
458a			;		ld a, l 
458a			;		call DispAToASCII   
458a			;;TODO need to chage above call to dump into string 
458a			; 
458a			; 
458a			 
458a				       NEXTW 
458a c3 81 1f			jp macro_next 
458d				endm 
# End of macro NEXTW
458d			 
458d			.CONCAT: 
458d				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
458d 48				db WORD_SYS_CORE+52             
458e 40 46			dw .FIND            
4590 07				db 6 + 1 
4591 .. 00			db "CONCAT",0              
4598				endm 
# End of macro CWHEAD
4598			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4598			 
4598			; TODO check string type 
4598			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4598			 
4598					if DEBUG_FORTH_WORDS_KEY 
4598						DMARK "CON" 
4598 f5				push af  
4599 3a ad 45			ld a, (.dmark)  
459c 32 65 ee			ld (debug_mark),a  
459f 3a ae 45			ld a, (.dmark+1)  
45a2 32 66 ee			ld (debug_mark+1),a  
45a5 3a af 45			ld a, (.dmark+2)  
45a8 32 67 ee			ld (debug_mark+2),a  
45ab 18 03			jr .pastdmark  
45ad ..			.dmark: db "CON"  
45b0 f1			.pastdmark: pop af  
45b1			endm  
# End of macro DMARK
45b1						CALLMONITOR 
45b1 cd 6f ee			call debug_vector  
45b4				endm  
# End of macro CALLMONITOR
45b4					endif 
45b4			 
45b4			 
45b4					FORTH_DSP_VALUE 
45b4 cd 7e 1d			call macro_forth_dsp_value 
45b7				endm 
# End of macro FORTH_DSP_VALUE
45b7 e5					push hl   ; s2 
45b8			 
45b8					FORTH_DSP_POP 
45b8 cd 4d 1e			call macro_forth_dsp_pop 
45bb				endm 
# End of macro FORTH_DSP_POP
45bb			 
45bb					FORTH_DSP_VALUE 
45bb cd 7e 1d			call macro_forth_dsp_value 
45be				endm 
# End of macro FORTH_DSP_VALUE
45be			 
45be e5					push hl   ; s1 
45bf			 
45bf					FORTH_DSP_POP 
45bf cd 4d 1e			call macro_forth_dsp_pop 
45c2				endm 
# End of macro FORTH_DSP_POP
45c2					 
45c2			 
45c2					; copy s1 
45c2			 
45c2				 
45c2					; save ptr 
45c2 e1					pop hl  
45c3 e5					push hl 
45c4 3e 00				ld a, 0 
45c6 cd 66 11				call strlent 
45c9					;inc hl    ; zer0 
45c9 06 00				ld b, 0 
45cb 4d					ld c, l 
45cc e1					pop hl		 
45cd 11 bb e2				ld de, scratch	 
45d0					if DEBUG_FORTH_WORDS 
45d0						DMARK "CO1" 
45d0 f5				push af  
45d1 3a e5 45			ld a, (.dmark)  
45d4 32 65 ee			ld (debug_mark),a  
45d7 3a e6 45			ld a, (.dmark+1)  
45da 32 66 ee			ld (debug_mark+1),a  
45dd 3a e7 45			ld a, (.dmark+2)  
45e0 32 67 ee			ld (debug_mark+2),a  
45e3 18 03			jr .pastdmark  
45e5 ..			.dmark: db "CO1"  
45e8 f1			.pastdmark: pop af  
45e9			endm  
# End of macro DMARK
45e9						CALLMONITOR 
45e9 cd 6f ee			call debug_vector  
45ec				endm  
# End of macro CALLMONITOR
45ec					endif 
45ec ed b0				ldir 
45ee			 
45ee e1					pop hl 
45ef e5					push hl 
45f0 d5					push de 
45f1			 
45f1			 
45f1 3e 00				ld a, 0 
45f3 cd 66 11				call strlent 
45f6 23					inc hl    ; zer0 
45f7 23					inc hl 
45f8 06 00				ld b, 0 
45fa 4d					ld c, l 
45fb d1					pop de 
45fc e1					pop hl		 
45fd					if DEBUG_FORTH_WORDS 
45fd						DMARK "CO2" 
45fd f5				push af  
45fe 3a 12 46			ld a, (.dmark)  
4601 32 65 ee			ld (debug_mark),a  
4604 3a 13 46			ld a, (.dmark+1)  
4607 32 66 ee			ld (debug_mark+1),a  
460a 3a 14 46			ld a, (.dmark+2)  
460d 32 67 ee			ld (debug_mark+2),a  
4610 18 03			jr .pastdmark  
4612 ..			.dmark: db "CO2"  
4615 f1			.pastdmark: pop af  
4616			endm  
# End of macro DMARK
4616						CALLMONITOR 
4616 cd 6f ee			call debug_vector  
4619				endm  
# End of macro CALLMONITOR
4619					endif 
4619 ed b0				ldir 
461b			 
461b			 
461b			 
461b 21 bb e2				ld hl, scratch 
461e					if DEBUG_FORTH_WORDS 
461e						DMARK "CO5" 
461e f5				push af  
461f 3a 33 46			ld a, (.dmark)  
4622 32 65 ee			ld (debug_mark),a  
4625 3a 34 46			ld a, (.dmark+1)  
4628 32 66 ee			ld (debug_mark+1),a  
462b 3a 35 46			ld a, (.dmark+2)  
462e 32 67 ee			ld (debug_mark+2),a  
4631 18 03			jr .pastdmark  
4633 ..			.dmark: db "CO5"  
4636 f1			.pastdmark: pop af  
4637			endm  
# End of macro DMARK
4637						CALLMONITOR 
4637 cd 6f ee			call debug_vector  
463a				endm  
# End of macro CALLMONITOR
463a					endif 
463a			 
463a cd fe 1b				call forth_push_str 
463d			 
463d			 
463d			 
463d			 
463d				       NEXTW 
463d c3 81 1f			jp macro_next 
4640				endm 
# End of macro NEXTW
4640			 
4640			 
4640			.FIND: 
4640				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4640 4b				db WORD_SYS_CORE+55             
4641 fe 46			dw .LEN            
4643 05				db 4 + 1 
4644 .. 00			db "FIND",0              
4649				endm 
# End of macro CWHEAD
4649			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4649			 
4649					if DEBUG_FORTH_WORDS_KEY 
4649						DMARK "FND" 
4649 f5				push af  
464a 3a 5e 46			ld a, (.dmark)  
464d 32 65 ee			ld (debug_mark),a  
4650 3a 5f 46			ld a, (.dmark+1)  
4653 32 66 ee			ld (debug_mark+1),a  
4656 3a 60 46			ld a, (.dmark+2)  
4659 32 67 ee			ld (debug_mark+2),a  
465c 18 03			jr .pastdmark  
465e ..			.dmark: db "FND"  
4661 f1			.pastdmark: pop af  
4662			endm  
# End of macro DMARK
4662						CALLMONITOR 
4662 cd 6f ee			call debug_vector  
4665				endm  
# End of macro CALLMONITOR
4665					endif 
4665			 
4665			; TODO check string type 
4665					FORTH_DSP_VALUE 
4665 cd 7e 1d			call macro_forth_dsp_value 
4668				endm 
# End of macro FORTH_DSP_VALUE
4668			 
4668 e5					push hl    
4669 7e					ld a,(hl)    ; char to find   
466a			; TODO change char to substr 
466a			 
466a f5					push af 
466b					 
466b			 
466b			 
466b					if DEBUG_FORTH_WORDS 
466b						DMARK "FN1" 
466b f5				push af  
466c 3a 80 46			ld a, (.dmark)  
466f 32 65 ee			ld (debug_mark),a  
4672 3a 81 46			ld a, (.dmark+1)  
4675 32 66 ee			ld (debug_mark+1),a  
4678 3a 82 46			ld a, (.dmark+2)  
467b 32 67 ee			ld (debug_mark+2),a  
467e 18 03			jr .pastdmark  
4680 ..			.dmark: db "FN1"  
4683 f1			.pastdmark: pop af  
4684			endm  
# End of macro DMARK
4684						CALLMONITOR 
4684 cd 6f ee			call debug_vector  
4687				endm  
# End of macro CALLMONITOR
4687					endif 
4687			 
4687					FORTH_DSP_POP 
4687 cd 4d 1e			call macro_forth_dsp_pop 
468a				endm 
# End of macro FORTH_DSP_POP
468a			 
468a					; string to search 
468a			 
468a					FORTH_DSP_VALUE 
468a cd 7e 1d			call macro_forth_dsp_value 
468d				endm 
# End of macro FORTH_DSP_VALUE
468d			 
468d d1					pop de  ; d is char to find  
468e			 
468e					if DEBUG_FORTH_WORDS 
468e						DMARK "FN2" 
468e f5				push af  
468f 3a a3 46			ld a, (.dmark)  
4692 32 65 ee			ld (debug_mark),a  
4695 3a a4 46			ld a, (.dmark+1)  
4698 32 66 ee			ld (debug_mark+1),a  
469b 3a a5 46			ld a, (.dmark+2)  
469e 32 67 ee			ld (debug_mark+2),a  
46a1 18 03			jr .pastdmark  
46a3 ..			.dmark: db "FN2"  
46a6 f1			.pastdmark: pop af  
46a7			endm  
# End of macro DMARK
46a7						CALLMONITOR 
46a7 cd 6f ee			call debug_vector  
46aa				endm  
# End of macro CALLMONITOR
46aa					endif 
46aa					 
46aa 01 00 00				ld bc, 0 
46ad 7e			.findchar:      ld a,(hl) 
46ae fe 00				cp 0   		 
46b0 28 27				jr z, .finddone     
46b2 ba					cp d 
46b3 28 20				jr z, .foundchar 
46b5 03					inc bc 
46b6 23					inc hl 
46b7					if DEBUG_FORTH_WORDS 
46b7						DMARK "FN3" 
46b7 f5				push af  
46b8 3a cc 46			ld a, (.dmark)  
46bb 32 65 ee			ld (debug_mark),a  
46be 3a cd 46			ld a, (.dmark+1)  
46c1 32 66 ee			ld (debug_mark+1),a  
46c4 3a ce 46			ld a, (.dmark+2)  
46c7 32 67 ee			ld (debug_mark+2),a  
46ca 18 03			jr .pastdmark  
46cc ..			.dmark: db "FN3"  
46cf f1			.pastdmark: pop af  
46d0			endm  
# End of macro DMARK
46d0						CALLMONITOR 
46d0 cd 6f ee			call debug_vector  
46d3				endm  
# End of macro CALLMONITOR
46d3					endif 
46d3 18 d8				jr .findchar 
46d5			 
46d5			 
46d5 c5			.foundchar:	push bc 
46d6 e1					pop hl 
46d7 18 03				jr .findexit 
46d9			 
46d9			 
46d9							 
46d9			 
46d9			.finddone:     ; got to end of string with no find 
46d9 21 00 00				ld hl, 0 
46dc			.findexit: 
46dc			 
46dc					if DEBUG_FORTH_WORDS 
46dc						DMARK "FNd" 
46dc f5				push af  
46dd 3a f1 46			ld a, (.dmark)  
46e0 32 65 ee			ld (debug_mark),a  
46e3 3a f2 46			ld a, (.dmark+1)  
46e6 32 66 ee			ld (debug_mark+1),a  
46e9 3a f3 46			ld a, (.dmark+2)  
46ec 32 67 ee			ld (debug_mark+2),a  
46ef 18 03			jr .pastdmark  
46f1 ..			.dmark: db "FNd"  
46f4 f1			.pastdmark: pop af  
46f5			endm  
# End of macro DMARK
46f5						CALLMONITOR 
46f5 cd 6f ee			call debug_vector  
46f8				endm  
# End of macro CALLMONITOR
46f8					endif 
46f8 cd 90 1b			call forth_push_numhl 
46fb			 
46fb				       NEXTW 
46fb c3 81 1f			jp macro_next 
46fe				endm 
# End of macro NEXTW
46fe			 
46fe			.LEN: 
46fe				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
46fe 4c				db WORD_SYS_CORE+56             
46ff 68 47			dw .ASC            
4701 06				db 5 + 1 
4702 .. 00			db "COUNT",0              
4708				endm 
# End of macro CWHEAD
4708			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4708			 
4708					if DEBUG_FORTH_WORDS_KEY 
4708						DMARK "CNT" 
4708 f5				push af  
4709 3a 1d 47			ld a, (.dmark)  
470c 32 65 ee			ld (debug_mark),a  
470f 3a 1e 47			ld a, (.dmark+1)  
4712 32 66 ee			ld (debug_mark+1),a  
4715 3a 1f 47			ld a, (.dmark+2)  
4718 32 67 ee			ld (debug_mark+2),a  
471b 18 03			jr .pastdmark  
471d ..			.dmark: db "CNT"  
4720 f1			.pastdmark: pop af  
4721			endm  
# End of macro DMARK
4721						CALLMONITOR 
4721 cd 6f ee			call debug_vector  
4724				endm  
# End of macro CALLMONITOR
4724					endif 
4724			; TODO check string type 
4724					FORTH_DSP_VALUE 
4724 cd 7e 1d			call macro_forth_dsp_value 
4727				endm 
# End of macro FORTH_DSP_VALUE
4727			 
4727			 
4727					if DEBUG_FORTH_WORDS 
4727						DMARK "CN?" 
4727 f5				push af  
4728 3a 3c 47			ld a, (.dmark)  
472b 32 65 ee			ld (debug_mark),a  
472e 3a 3d 47			ld a, (.dmark+1)  
4731 32 66 ee			ld (debug_mark+1),a  
4734 3a 3e 47			ld a, (.dmark+2)  
4737 32 67 ee			ld (debug_mark+2),a  
473a 18 03			jr .pastdmark  
473c ..			.dmark: db "CN?"  
473f f1			.pastdmark: pop af  
4740			endm  
# End of macro DMARK
4740						CALLMONITOR 
4740 cd 6f ee			call debug_vector  
4743				endm  
# End of macro CALLMONITOR
4743					endif 
4743 cd 5b 11				call strlenz 
4746					if DEBUG_FORTH_WORDS 
4746						DMARK "CNl" 
4746 f5				push af  
4747 3a 5b 47			ld a, (.dmark)  
474a 32 65 ee			ld (debug_mark),a  
474d 3a 5c 47			ld a, (.dmark+1)  
4750 32 66 ee			ld (debug_mark+1),a  
4753 3a 5d 47			ld a, (.dmark+2)  
4756 32 67 ee			ld (debug_mark+2),a  
4759 18 03			jr .pastdmark  
475b ..			.dmark: db "CNl"  
475e f1			.pastdmark: pop af  
475f			endm  
# End of macro DMARK
475f						CALLMONITOR 
475f cd 6f ee			call debug_vector  
4762				endm  
# End of macro CALLMONITOR
4762					endif 
4762			 
4762 cd 90 1b				call forth_push_numhl 
4765			 
4765			 
4765			 
4765				       NEXTW 
4765 c3 81 1f			jp macro_next 
4768				endm 
# End of macro NEXTW
4768			.ASC: 
4768				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4768 4d				db WORD_SYS_CORE+57             
4769 d6 47			dw .CHR            
476b 04				db 3 + 1 
476c .. 00			db "ASC",0              
4770				endm 
# End of macro CWHEAD
4770			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4770					if DEBUG_FORTH_WORDS_KEY 
4770						DMARK "ASC" 
4770 f5				push af  
4771 3a 85 47			ld a, (.dmark)  
4774 32 65 ee			ld (debug_mark),a  
4777 3a 86 47			ld a, (.dmark+1)  
477a 32 66 ee			ld (debug_mark+1),a  
477d 3a 87 47			ld a, (.dmark+2)  
4780 32 67 ee			ld (debug_mark+2),a  
4783 18 03			jr .pastdmark  
4785 ..			.dmark: db "ASC"  
4788 f1			.pastdmark: pop af  
4789			endm  
# End of macro DMARK
4789						CALLMONITOR 
4789 cd 6f ee			call debug_vector  
478c				endm  
# End of macro CALLMONITOR
478c					endif 
478c					FORTH_DSP_VALUE 
478c cd 7e 1d			call macro_forth_dsp_value 
478f				endm 
# End of macro FORTH_DSP_VALUE
478f					;v5 FORTH_DSP_VALUE 
478f			;		inc hl      ; now at start of numeric as string 
478f			 
478f e5					push hl 
4790			 
4790					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4790 cd 4d 1e			call macro_forth_dsp_pop 
4793				endm 
# End of macro FORTH_DSP_POP
4793			 
4793 e1					pop hl 
4794			 
4794					if DEBUG_FORTH_WORDS 
4794						DMARK "AS1" 
4794 f5				push af  
4795 3a a9 47			ld a, (.dmark)  
4798 32 65 ee			ld (debug_mark),a  
479b 3a aa 47			ld a, (.dmark+1)  
479e 32 66 ee			ld (debug_mark+1),a  
47a1 3a ab 47			ld a, (.dmark+2)  
47a4 32 67 ee			ld (debug_mark+2),a  
47a7 18 03			jr .pastdmark  
47a9 ..			.dmark: db "AS1"  
47ac f1			.pastdmark: pop af  
47ad			endm  
# End of macro DMARK
47ad						CALLMONITOR 
47ad cd 6f ee			call debug_vector  
47b0				endm  
# End of macro CALLMONITOR
47b0					endif 
47b0					; push the content of a onto the stack as a value 
47b0			 
47b0 7e					ld a,(hl)   ; get char 
47b1 26 00				ld h,0 
47b3 6f					ld l,a 
47b4					if DEBUG_FORTH_WORDS 
47b4						DMARK "AS2" 
47b4 f5				push af  
47b5 3a c9 47			ld a, (.dmark)  
47b8 32 65 ee			ld (debug_mark),a  
47bb 3a ca 47			ld a, (.dmark+1)  
47be 32 66 ee			ld (debug_mark+1),a  
47c1 3a cb 47			ld a, (.dmark+2)  
47c4 32 67 ee			ld (debug_mark+2),a  
47c7 18 03			jr .pastdmark  
47c9 ..			.dmark: db "AS2"  
47cc f1			.pastdmark: pop af  
47cd			endm  
# End of macro DMARK
47cd						CALLMONITOR 
47cd cd 6f ee			call debug_vector  
47d0				endm  
# End of macro CALLMONITOR
47d0					endif 
47d0 cd 90 1b				call forth_push_numhl 
47d3			 
47d3				       NEXTW 
47d3 c3 81 1f			jp macro_next 
47d6				endm 
# End of macro NEXTW
47d6			 
47d6			.CHR: 
47d6				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
47d6 4d				db WORD_SYS_CORE+57             
47d7 12 48			dw .ENDSTR            
47d9 04				db 3 + 1 
47da .. 00			db "CHR",0              
47de				endm 
# End of macro CWHEAD
47de			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
47de					if DEBUG_FORTH_WORDS_KEY 
47de						DMARK "CHR" 
47de f5				push af  
47df 3a f3 47			ld a, (.dmark)  
47e2 32 65 ee			ld (debug_mark),a  
47e5 3a f4 47			ld a, (.dmark+1)  
47e8 32 66 ee			ld (debug_mark+1),a  
47eb 3a f5 47			ld a, (.dmark+2)  
47ee 32 67 ee			ld (debug_mark+2),a  
47f1 18 03			jr .pastdmark  
47f3 ..			.dmark: db "CHR"  
47f6 f1			.pastdmark: pop af  
47f7			endm  
# End of macro DMARK
47f7						CALLMONITOR 
47f7 cd 6f ee			call debug_vector  
47fa				endm  
# End of macro CALLMONITOR
47fa					endif 
47fa					FORTH_DSP_VALUEHL 
47fa cd 95 1d			call macro_dsp_valuehl 
47fd				endm 
# End of macro FORTH_DSP_VALUEHL
47fd			 
47fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47fd cd 4d 1e			call macro_forth_dsp_pop 
4800				endm 
# End of macro FORTH_DSP_POP
4800			 
4800					; save asci byte as a zero term string and push string 
4800			 
4800 7d					ld a,l 
4801 32 bb e2				ld (scratch), a 
4804			 
4804 3e 00				ld a, 0 
4806 32 bc e2				ld (scratch+1), a 
4809			 
4809 21 bb e2				ld hl, scratch 
480c cd fe 1b				call forth_push_str 
480f			 
480f			 
480f				       NEXTW 
480f c3 81 1f			jp macro_next 
4812				endm 
# End of macro NEXTW
4812			 
4812			 
4812			 
4812			 
4812			.ENDSTR: 
4812			; eof 
4812			 
# End of file forth_words_str.asm
4812			include "forth_words_key.asm" 
4812			 
4812			; | ## Keyboard Words 
4812			 
4812			.KEY: 
4812				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4812 3e				db WORD_SYS_CORE+42             
4813 42 48			dw .WAITK            
4815 04				db 3 + 1 
4816 .. 00			db "KEY",0              
481a				endm 
# End of macro CWHEAD
481a			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
481a			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
481a			; | | Can use something like this to process: 
481a			; | | > repeat active . key ?dup if emit then #1 until  
481a			 
481a					if DEBUG_FORTH_WORDS_KEY 
481a						DMARK "KEY" 
481a f5				push af  
481b 3a 2f 48			ld a, (.dmark)  
481e 32 65 ee			ld (debug_mark),a  
4821 3a 30 48			ld a, (.dmark+1)  
4824 32 66 ee			ld (debug_mark+1),a  
4827 3a 31 48			ld a, (.dmark+2)  
482a 32 67 ee			ld (debug_mark+2),a  
482d 18 03			jr .pastdmark  
482f ..			.dmark: db "KEY"  
4832 f1			.pastdmark: pop af  
4833			endm  
# End of macro DMARK
4833						CALLMONITOR 
4833 cd 6f ee			call debug_vector  
4836				endm  
# End of macro CALLMONITOR
4836					endif 
4836			; TODO currently waits 
4836 cd 37 5f				call cin 
4839					;call cin_wait 
4839 6f					ld l, a 
483a 26 00				ld h, 0 
483c cd 90 1b				call forth_push_numhl 
483f					NEXTW 
483f c3 81 1f			jp macro_next 
4842				endm 
# End of macro NEXTW
4842			.WAITK: 
4842				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4842 3f				db WORD_SYS_CORE+43             
4843 74 48			dw .ACCEPT            
4845 06				db 5 + 1 
4846 .. 00			db "WAITK",0              
484c				endm 
# End of macro CWHEAD
484c			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
484c					if DEBUG_FORTH_WORDS_KEY 
484c						DMARK "WAI" 
484c f5				push af  
484d 3a 61 48			ld a, (.dmark)  
4850 32 65 ee			ld (debug_mark),a  
4853 3a 62 48			ld a, (.dmark+1)  
4856 32 66 ee			ld (debug_mark+1),a  
4859 3a 63 48			ld a, (.dmark+2)  
485c 32 67 ee			ld (debug_mark+2),a  
485f 18 03			jr .pastdmark  
4861 ..			.dmark: db "WAI"  
4864 f1			.pastdmark: pop af  
4865			endm  
# End of macro DMARK
4865						CALLMONITOR 
4865 cd 6f ee			call debug_vector  
4868				endm  
# End of macro CALLMONITOR
4868					endif 
4868 cd 2f 5f				call cin_wait 
486b 6f					ld l, a 
486c 26 00				ld h, 0 
486e cd 90 1b				call forth_push_numhl 
4871					NEXTW 
4871 c3 81 1f			jp macro_next 
4874				endm 
# End of macro NEXTW
4874			.ACCEPT: 
4874				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4874 40				db WORD_SYS_CORE+44             
4875 d2 48			dw .EDIT            
4877 07				db 6 + 1 
4878 .. 00			db "ACCEPT",0              
487f				endm 
# End of macro CWHEAD
487f			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
487f					; TODO crashes on push 
487f					if DEBUG_FORTH_WORDS_KEY 
487f						DMARK "ACC" 
487f f5				push af  
4880 3a 94 48			ld a, (.dmark)  
4883 32 65 ee			ld (debug_mark),a  
4886 3a 95 48			ld a, (.dmark+1)  
4889 32 66 ee			ld (debug_mark+1),a  
488c 3a 96 48			ld a, (.dmark+2)  
488f 32 67 ee			ld (debug_mark+2),a  
4892 18 03			jr .pastdmark  
4894 ..			.dmark: db "ACC"  
4897 f1			.pastdmark: pop af  
4898			endm  
# End of macro DMARK
4898						CALLMONITOR 
4898 cd 6f ee			call debug_vector  
489b				endm  
# End of macro CALLMONITOR
489b					endif 
489b 21 b9 e4				ld hl, os_input 
489e 3e 00				ld a, 0 
48a0 77					ld (hl),a 
48a1 3a 58 ea				ld a,(f_cursor_ptr) 
48a4 16 64				ld d, 100 
48a6 0e 00				ld c, 0 
48a8 1e 28				ld e, 40 
48aa cd 22 0e				call input_str 
48ad					; TODO perhaps do a type check and wrap in quotes if not a number 
48ad 21 b9 e4				ld hl, os_input 
48b0					if DEBUG_FORTH_WORDS 
48b0						DMARK "AC1" 
48b0 f5				push af  
48b1 3a c5 48			ld a, (.dmark)  
48b4 32 65 ee			ld (debug_mark),a  
48b7 3a c6 48			ld a, (.dmark+1)  
48ba 32 66 ee			ld (debug_mark+1),a  
48bd 3a c7 48			ld a, (.dmark+2)  
48c0 32 67 ee			ld (debug_mark+2),a  
48c3 18 03			jr .pastdmark  
48c5 ..			.dmark: db "AC1"  
48c8 f1			.pastdmark: pop af  
48c9			endm  
# End of macro DMARK
48c9						CALLMONITOR 
48c9 cd 6f ee			call debug_vector  
48cc				endm  
# End of macro CALLMONITOR
48cc					endif 
48cc cd fe 1b				call forth_push_str 
48cf					NEXTW 
48cf c3 81 1f			jp macro_next 
48d2				endm 
# End of macro NEXTW
48d2			 
48d2			.EDIT: 
48d2				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
48d2 40				db WORD_SYS_CORE+44             
48d3 74 49			dw .DEDIT            
48d5 05				db 4 + 1 
48d6 .. 00			db "EDIT",0              
48db				endm 
# End of macro CWHEAD
48db			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
48db			 
48db					; TODO does not copy from stack 
48db					if DEBUG_FORTH_WORDS_KEY 
48db						DMARK "EDT" 
48db f5				push af  
48dc 3a f0 48			ld a, (.dmark)  
48df 32 65 ee			ld (debug_mark),a  
48e2 3a f1 48			ld a, (.dmark+1)  
48e5 32 66 ee			ld (debug_mark+1),a  
48e8 3a f2 48			ld a, (.dmark+2)  
48eb 32 67 ee			ld (debug_mark+2),a  
48ee 18 03			jr .pastdmark  
48f0 ..			.dmark: db "EDT"  
48f3 f1			.pastdmark: pop af  
48f4			endm  
# End of macro DMARK
48f4						CALLMONITOR 
48f4 cd 6f ee			call debug_vector  
48f7				endm  
# End of macro CALLMONITOR
48f7					endif 
48f7			 
48f7					;FORTH_DSP 
48f7					FORTH_DSP_VALUEHL 
48f7 cd 95 1d			call macro_dsp_valuehl 
48fa				endm 
# End of macro FORTH_DSP_VALUEHL
48fa			;		inc hl    ; TODO do type check 
48fa			 
48fa			;		call get_word_hl 
48fa e5					push hl 
48fb					if DEBUG_FORTH_WORDS 
48fb						DMARK "EDp" 
48fb f5				push af  
48fc 3a 10 49			ld a, (.dmark)  
48ff 32 65 ee			ld (debug_mark),a  
4902 3a 11 49			ld a, (.dmark+1)  
4905 32 66 ee			ld (debug_mark+1),a  
4908 3a 12 49			ld a, (.dmark+2)  
490b 32 67 ee			ld (debug_mark+2),a  
490e 18 03			jr .pastdmark  
4910 ..			.dmark: db "EDp"  
4913 f1			.pastdmark: pop af  
4914			endm  
# End of macro DMARK
4914						CALLMONITOR 
4914 cd 6f ee			call debug_vector  
4917				endm  
# End of macro CALLMONITOR
4917					endif 
4917				;	ld a, 0 
4917 cd 5b 11				call strlenz 
491a 23					inc hl 
491b			 
491b 06 00				ld b, 0 
491d 4d					ld c, l 
491e			 
491e e1					pop hl 
491f 11 b9 e4				ld de, os_input 
4922					if DEBUG_FORTH_WORDS_KEY 
4922						DMARK "EDc" 
4922 f5				push af  
4923 3a 37 49			ld a, (.dmark)  
4926 32 65 ee			ld (debug_mark),a  
4929 3a 38 49			ld a, (.dmark+1)  
492c 32 66 ee			ld (debug_mark+1),a  
492f 3a 39 49			ld a, (.dmark+2)  
4932 32 67 ee			ld (debug_mark+2),a  
4935 18 03			jr .pastdmark  
4937 ..			.dmark: db "EDc"  
493a f1			.pastdmark: pop af  
493b			endm  
# End of macro DMARK
493b						CALLMONITOR 
493b cd 6f ee			call debug_vector  
493e				endm  
# End of macro CALLMONITOR
493e					endif 
493e ed b0				ldir 
4940			 
4940			 
4940 21 b9 e4				ld hl, os_input 
4943					;ld a, 0 
4943					;ld (hl),a 
4943 3a 58 ea				ld a,(f_cursor_ptr) 
4946 16 64				ld d, 100 
4948 0e 00				ld c, 0 
494a 1e 28				ld e, 40 
494c cd 22 0e				call input_str 
494f					; TODO perhaps do a type check and wrap in quotes if not a number 
494f 21 b9 e4				ld hl, os_input 
4952					if DEBUG_FORTH_WORDS 
4952						DMARK "ED1" 
4952 f5				push af  
4953 3a 67 49			ld a, (.dmark)  
4956 32 65 ee			ld (debug_mark),a  
4959 3a 68 49			ld a, (.dmark+1)  
495c 32 66 ee			ld (debug_mark+1),a  
495f 3a 69 49			ld a, (.dmark+2)  
4962 32 67 ee			ld (debug_mark+2),a  
4965 18 03			jr .pastdmark  
4967 ..			.dmark: db "ED1"  
496a f1			.pastdmark: pop af  
496b			endm  
# End of macro DMARK
496b						CALLMONITOR 
496b cd 6f ee			call debug_vector  
496e				endm  
# End of macro CALLMONITOR
496e					endif 
496e cd fe 1b				call forth_push_str 
4971					NEXTW 
4971 c3 81 1f			jp macro_next 
4974				endm 
# End of macro NEXTW
4974			 
4974			.DEDIT: 
4974				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4974 40				db WORD_SYS_CORE+44             
4975 d6 49			dw .ENDKEY            
4977 06				db 5 + 1 
4978 .. 00			db "DEDIT",0              
497e				endm 
# End of macro CWHEAD
497e			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
497e			 
497e					; TODO does not copy from stack 
497e					if DEBUG_FORTH_WORDS_KEY 
497e						DMARK "DED" 
497e f5				push af  
497f 3a 93 49			ld a, (.dmark)  
4982 32 65 ee			ld (debug_mark),a  
4985 3a 94 49			ld a, (.dmark+1)  
4988 32 66 ee			ld (debug_mark+1),a  
498b 3a 95 49			ld a, (.dmark+2)  
498e 32 67 ee			ld (debug_mark+2),a  
4991 18 03			jr .pastdmark  
4993 ..			.dmark: db "DED"  
4996 f1			.pastdmark: pop af  
4997			endm  
# End of macro DMARK
4997						CALLMONITOR 
4997 cd 6f ee			call debug_vector  
499a				endm  
# End of macro CALLMONITOR
499a					endif 
499a			 
499a					;FORTH_DSP 
499a					FORTH_DSP_VALUEHL 
499a cd 95 1d			call macro_dsp_valuehl 
499d				endm 
# End of macro FORTH_DSP_VALUEHL
499d			;		inc hl    ; TODO do type check 
499d			 
499d			;		call get_word_hl 
499d e5					push hl 
499e e5					push hl 
499f					FORTH_DSP_POP 
499f cd 4d 1e			call macro_forth_dsp_pop 
49a2				endm 
# End of macro FORTH_DSP_POP
49a2 e1					pop hl 
49a3					if DEBUG_FORTH_WORDS 
49a3						DMARK "EDp" 
49a3 f5				push af  
49a4 3a b8 49			ld a, (.dmark)  
49a7 32 65 ee			ld (debug_mark),a  
49aa 3a b9 49			ld a, (.dmark+1)  
49ad 32 66 ee			ld (debug_mark+1),a  
49b0 3a ba 49			ld a, (.dmark+2)  
49b3 32 67 ee			ld (debug_mark+2),a  
49b6 18 03			jr .pastdmark  
49b8 ..			.dmark: db "EDp"  
49bb f1			.pastdmark: pop af  
49bc			endm  
# End of macro DMARK
49bc						CALLMONITOR 
49bc cd 6f ee			call debug_vector  
49bf				endm  
# End of macro CALLMONITOR
49bf					endif 
49bf				;	ld a, 0 
49bf cd 5b 11				call strlenz 
49c2 23					inc hl 
49c3			 
49c3 06 00				ld b, 0 
49c5 4d					ld c, l 
49c6			 
49c6 e1					pop hl 
49c7			 
49c7					;ld a, 0 
49c7					;ld (hl),a 
49c7 3a 58 ea				ld a,(f_cursor_ptr) 
49ca 16 64				ld d, 100 
49cc 0e 00				ld c, 0 
49ce 1e 28				ld e, 40 
49d0 cd 22 0e				call input_str 
49d3					; TODO perhaps do a type check and wrap in quotes if not a number 
49d3					NEXTW 
49d3 c3 81 1f			jp macro_next 
49d6				endm 
# End of macro NEXTW
49d6			 
49d6			 
49d6			.ENDKEY: 
49d6			; eof 
49d6			 
# End of file forth_words_key.asm
49d6			include "forth_words_const.asm" 
49d6			 
49d6			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
49d6			 
49d6			 
49d6			.SPITIME: 
49d6				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
49d6 77				db WORD_SYS_CORE+99             
49d7 eb 49			dw .VA            
49d9 08				db 7 + 1 
49da .. 00			db "SPITIME",0              
49e2				endm 
# End of macro CWHEAD
49e2			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
49e2			; 
49e2			; | | If using BANK devices then leave as is. 
49e2			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
49e2			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
49e2			 
49e2 21 5e ea				ld hl, spi_clktime  
49e5 cd 90 1b				call forth_push_numhl 
49e8			 
49e8					NEXTW 
49e8 c3 81 1f			jp macro_next 
49eb				endm 
# End of macro NEXTW
49eb			 
49eb			 
49eb			.VA: 
49eb				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
49eb 77				db WORD_SYS_CORE+99             
49ec fb 49			dw .SYMBOL            
49ee 03				db 2 + 1 
49ef .. 00			db "VA",0              
49f2				endm 
# End of macro CWHEAD
49f2			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
49f2 21 22 ea				ld hl, cli_var_array 
49f5 cd 90 1b				call forth_push_numhl 
49f8			 
49f8					NEXTW 
49f8 c3 81 1f			jp macro_next 
49fb				endm 
# End of macro NEXTW
49fb			 
49fb			.SYMBOL: 
49fb				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
49fb 77				db WORD_SYS_CORE+99             
49fc 05 4b			dw .ENDCONST            
49fe 07				db 6 + 1 
49ff .. 00			db "SYMBOL",0              
4a06				endm 
# End of macro CWHEAD
4a06			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4a06			; | 
4a06			; | | The value is the number reference and the final address is pushed to stack 
4a06			 
4a06			; | | ``` 
4a06			; | | dw sym_table 
4a06			; | | dw nmi_vector 
4a06			; | | dw cli_autodisplay 
4a06			; | | dw cli_data_sp 
4a06			; | | dw cli_data_stack 
4a06			; | | dw cli_loop_sp 
4a06			; | | dw cli_loop_stack 
4a06			; | | dw cli_var_array 
4a06			; | | dw cursor_col 
4a06			; | | dw cursor_ptr 
4a06			; | | ; 10 
4a06			; | | dw cursor_row 
4a06			; | | dw debug_mark 
4a06			; | | dw display_fb0 
4a06			; | | dw display_fb1 
4a06			; | | dw display_fb2 
4a06			; | | dw display_fb3 
4a06			; | | dw display_fb_active 
4a06			; | | dw execscratch 
4a06			; | | dw f_cursor_ptr 
4a06			; | | dw hardware_word 
4a06			; | | ;20 
4a06			; | | dw input_at_cursor 
4a06			; | | dw input_at_pos 
4a06			; | | dw input_cur_flash 
4a06			; | | dw input_cur_onoff 
4a06			; | | dw input_cursor 
4a06			; | | dw input_display_size 
4a06			; | | dw input_len 
4a06			; | | dw input_ptr 
4a06			; | | dw input_size 
4a06			; | | dw input_start 
4a06			; | | ; 30 
4a06			; | | dw input_str 
4a06			; | | dw input_under_cursor 
4a06			; | | dw os_cli_cmd 
4a06			; | | dw os_cur_ptr 
4a06			; | | dw os_current_i 
4a06			; | | dw os_input 
4a06			; | | dw os_last_cmd 
4a06			; | | dw os_last_new_uword 
4a06			; | | dw debug_vector 
4a06			; | | dw os_view_hl 
4a06			; | | ;40 
4a06			; | | dw os_word_scratch 
4a06			; | | dw portbctl 
4a06			; | | dw portbdata 
4a06			; | | dw spi_cartdev 
4a06			; | | dw spi_cartdev2 
4a06			; | | dw spi_clktime 
4a06			; | | dw spi_device 
4a06			; | | dw spi_device_id 
4a06			; | | dw spi_portbyte 
4a06			; | | dw stackstore 
4a06			; | | ; 50 
4a06			; | | if STORAGE_SE 
4a06			; | | dw storage_actl 
4a06			; | | dw storage_adata 
4a06			; | | else 
4a06			; | | dw 0 
4a06			; | | dw 0 
4a06			; | | endif 
4a06			; | | dw storage_append 
4a06			; | | if STORAGE_SE 
4a06			; | | dw storage_bctl 
4a06			; | | else 
4a06			; | | dw 0 
4a06			; | | endif 
4a06			; | | dw store_bank_active 
4a06			; | | dw store_filecache 
4a06			; | | dw store_longread 
4a06			; | | dw store_openaddr 
4a06			; | | dw store_openext 
4a06			; | | dw store_openmaxext 
4a06			; | | ; 60 
4a06			; | | dw store_page 
4a06			; | | dw store_readbuf 
4a06			; | | dw store_readcont 
4a06			; | | dw store_readptr 
4a06			; | | dw store_tmpext 
4a06			; | | dw store_tmpid 
4a06			; | | dw store_tmppageid 
4a06			; | | dw malloc 
4a06			; | | dw free 
4a06			; | | dw cin 
4a06			; | | ; 70 
4a06			; | | dw cin_wait 
4a06			; | | dw forth_push_numhl 
4a06			; | | dw forth_push_str 
4a06			; | | ``` 
4a06			 
4a06					if DEBUG_FORTH_WORDS_KEY 
4a06						DMARK "SYM" 
4a06 f5				push af  
4a07 3a 1b 4a			ld a, (.dmark)  
4a0a 32 65 ee			ld (debug_mark),a  
4a0d 3a 1c 4a			ld a, (.dmark+1)  
4a10 32 66 ee			ld (debug_mark+1),a  
4a13 3a 1d 4a			ld a, (.dmark+2)  
4a16 32 67 ee			ld (debug_mark+2),a  
4a19 18 03			jr .pastdmark  
4a1b ..			.dmark: db "SYM"  
4a1e f1			.pastdmark: pop af  
4a1f			endm  
# End of macro DMARK
4a1f						CALLMONITOR 
4a1f cd 6f ee			call debug_vector  
4a22				endm  
# End of macro CALLMONITOR
4a22					endif 
4a22			 
4a22					FORTH_DSP_VALUEHL 
4a22 cd 95 1d			call macro_dsp_valuehl 
4a25				endm 
# End of macro FORTH_DSP_VALUEHL
4a25			 
4a25 7d					ld a, l     
4a26			 
4a26			 
4a26					if DEBUG_FORTH_WORDS 
4a26						DMARK "SY1" 
4a26 f5				push af  
4a27 3a 3b 4a			ld a, (.dmark)  
4a2a 32 65 ee			ld (debug_mark),a  
4a2d 3a 3c 4a			ld a, (.dmark+1)  
4a30 32 66 ee			ld (debug_mark+1),a  
4a33 3a 3d 4a			ld a, (.dmark+2)  
4a36 32 67 ee			ld (debug_mark+2),a  
4a39 18 03			jr .pastdmark  
4a3b ..			.dmark: db "SY1"  
4a3e f1			.pastdmark: pop af  
4a3f			endm  
# End of macro DMARK
4a3f						CALLMONITOR 
4a3f cd 6f ee			call debug_vector  
4a42				endm  
# End of macro CALLMONITOR
4a42					endif 
4a42					 
4a42 f5					push af	 
4a43					FORTH_DSP_POP 
4a43 cd 4d 1e			call macro_forth_dsp_pop 
4a46				endm 
# End of macro FORTH_DSP_POP
4a46 f1					pop af 
4a47			 
4a47 cb 27				sla a  
4a49				 
4a49					 
4a49					if DEBUG_FORTH_WORDS 
4a49						DMARK "SY" 
4a49 f5				push af  
4a4a 3a 5e 4a			ld a, (.dmark)  
4a4d 32 65 ee			ld (debug_mark),a  
4a50 3a 5f 4a			ld a, (.dmark+1)  
4a53 32 66 ee			ld (debug_mark+1),a  
4a56 3a 60 4a			ld a, (.dmark+2)  
4a59 32 67 ee			ld (debug_mark+2),a  
4a5c 18 02			jr .pastdmark  
4a5e ..			.dmark: db "SY"  
4a60 f1			.pastdmark: pop af  
4a61			endm  
# End of macro DMARK
4a61						CALLMONITOR 
4a61 cd 6f ee			call debug_vector  
4a64				endm  
# End of macro CALLMONITOR
4a64					endif 
4a64			 
4a64 21 73 4a				ld hl, sym_table 
4a67 cd f5 0d				call addatohl 
4a6a cd 03 1f				call loadwordinhl 
4a6d cd 90 1b				call forth_push_numhl 
4a70			 
4a70			 
4a70				       NEXTW 
4a70 c3 81 1f			jp macro_next 
4a73				endm 
# End of macro NEXTW
4a73			 
4a73			sym_table: 
4a73			 
4a73			; 0 
4a73 73 4a		dw sym_table 
4a75 72 ee		dw nmi_vector 
4a77 36 ea		dw cli_autodisplay 
4a79 e8 e9		dw cli_data_sp 
4a7b 22 e8		dw cli_data_stack 
4a7d ea e9		dw cli_loop_sp 
4a7f 24 e9		dw cli_loop_stack 
4a81 22 ea		dw cli_var_array 
4a83 bf eb		dw cursor_col 
4a85 bd eb		dw cursor_ptr 
4a87			; 10 
4a87 be eb		dw cursor_row 
4a89 65 ee		dw debug_mark 
4a8b ab ed		dw display_fb0 
4a8d 0a ed		dw display_fb1 
4a8f c8 eb		dw display_fb2 
4a91 69 ec		dw display_fb3 
4a93 c6 eb		dw display_fb_active 
4a95 ba e3		dw execscratch 
4a97 58 ea		dw f_cursor_ptr 
4a99 75 ee		dw hardware_word 
4a9b			;20 
4a9b 5c ee		dw input_at_cursor 
4a9d 5e ee		dw input_at_pos 
4a9f 5a ee		dw input_cur_flash 
4aa1 59 ee		dw input_cur_onoff 
4aa3 4f ee		dw input_cursor 
4aa5 5f ee		dw input_display_size 
4aa7 54 ee		dw input_len 
4aa9 63 ee		dw input_ptr 
4aab 60 ee		dw input_size 
4aad 61 ee		dw input_start 
4aaf			; 30 
4aaf 22 0e		dw input_str 
4ab1 5d ee		dw input_under_cursor 
4ab3 e2 e5		dw os_cli_cmd 
4ab5 de e5		dw os_cur_ptr 
4ab7 e0 e5		dw os_current_i 
4ab9 b9 e4		dw os_input 
4abb e1 e6		dw os_last_cmd 
4abd b8 e5		dw os_last_new_uword 
4abf 6f ee		dw debug_vector 
4ac1 9d e2		dw os_view_hl 
4ac3			;40 
4ac3 c0 e5		dw os_word_scratch 
4ac5 c3 00		dw portbctl 
4ac7 c1 00		dw portbdata 
4ac9 5d ea		dw spi_cartdev 
4acb 5c ea		dw spi_cartdev2 
4acd 5e ea		dw spi_clktime 
4acf 5a ea		dw spi_device 
4ad1 59 ea		dw spi_device_id 
4ad3 5b ea		dw spi_portbyte 
4ad5 a1 eb		dw stackstore 
4ad7			; 50 
4ad7			if STORAGE_SE 
4ad7			dw storage_actl 
4ad7			dw storage_adata 
4ad7			else 
4ad7 00 00		dw 0 
4ad9 00 00		dw 0 
4adb			endif 
4adb 77 09		dw storage_append 
4add			if STORAGE_SE 
4add			dw storage_bctl 
4add			else 
4add 00 00		dw 0 
4adf			endif 
4adf 8d eb		dw store_bank_active 
4ae1 61 ea		dw store_filecache 
4ae3 6f ea		dw store_longread 
4ae5 65 ea		dw store_openaddr 
4ae7 64 ea		dw store_openext 
4ae9 63 ea		dw store_openmaxext 
4aeb			; 60 
4aeb 74 ea		dw store_page 
4aed 70 ea		dw store_readbuf 
4aef 67 ea		dw store_readcont 
4af1 72 ea		dw store_readptr 
4af3 67 ea		dw store_tmpext 
4af5 68 ea		dw store_tmpid 
4af7 5f ea		dw store_tmppageid 
4af9 d0 11		dw malloc 
4afb 9a 12		dw free 
4afd 37 5f		dw cin 
4aff			; 70 
4aff 2f 5f		dw cin_wait 
4b01 90 1b		dw forth_push_numhl 
4b03 fe 1b		dw forth_push_str 
4b05			 
4b05			 
4b05			.ENDCONST: 
4b05			 
4b05			; eof 
4b05			 
4b05			 
# End of file forth_words_const.asm
4b05			 
4b05			if STORAGE_SE 
4b05			   	include "forth_words_storage.asm" 
4b05			endif 
4b05				include "forth_words_device.asm" 
4b05			; Device related words 
4b05			 
4b05			; | ## Device Words 
4b05			 
4b05			;if SOUND_ENABLE 
4b05			;.NOTE: 
4b05			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4b05			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4b05			;		if DEBUG_FORTH_WORDS_KEY 
4b05			;			DMARK "NTE" 
4b05			;			CALLMONITOR 
4b05			;		endif 
4b05			; 
4b05			;	 
4b05			; 
4b05			;		NEXTW 
4b05			;.AFTERSOUND: 
4b05			;endif 
4b05			 
4b05			 
4b05			USE_GPIO: equ 0 
4b05			 
4b05			if USE_GPIO 
4b05			.GP1: 
4b05				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4b05			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4b05					NEXTW 
4b05			.GP2: 
4b05				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4b05			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4b05			 
4b05					NEXTW 
4b05			 
4b05			.GP3: 
4b05				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4b05			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4b05			 
4b05					NEXTW 
4b05			 
4b05			.GP4: 
4b05				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4b05			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4b05			 
4b05					NEXTW 
4b05			.SIN: 
4b05			 
4b05			 
4b05			endif 
4b05			 
4b05			 
4b05				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4b05 33				db WORD_SYS_CORE+31             
4b06 3a 4b			dw .SOUT            
4b08 03				db 2 + 1 
4b09 .. 00			db "IN",0              
4b0c				endm 
# End of macro CWHEAD
4b0c			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4b0c					if DEBUG_FORTH_WORDS_KEY 
4b0c						DMARK "IN." 
4b0c f5				push af  
4b0d 3a 21 4b			ld a, (.dmark)  
4b10 32 65 ee			ld (debug_mark),a  
4b13 3a 22 4b			ld a, (.dmark+1)  
4b16 32 66 ee			ld (debug_mark+1),a  
4b19 3a 23 4b			ld a, (.dmark+2)  
4b1c 32 67 ee			ld (debug_mark+2),a  
4b1f 18 03			jr .pastdmark  
4b21 ..			.dmark: db "IN."  
4b24 f1			.pastdmark: pop af  
4b25			endm  
# End of macro DMARK
4b25						CALLMONITOR 
4b25 cd 6f ee			call debug_vector  
4b28				endm  
# End of macro CALLMONITOR
4b28					endif 
4b28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b28 cd 95 1d			call macro_dsp_valuehl 
4b2b				endm 
# End of macro FORTH_DSP_VALUEHL
4b2b			 
4b2b e5					push hl 
4b2c			 
4b2c					; destroy value TOS 
4b2c			 
4b2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b2c cd 4d 1e			call macro_forth_dsp_pop 
4b2f				endm 
# End of macro FORTH_DSP_POP
4b2f			 
4b2f					; one value on hl get other one back 
4b2f			 
4b2f c1					pop bc 
4b30			 
4b30					; do the sub 
4b30			;		ex de, hl 
4b30			 
4b30 ed 68				in l,(c) 
4b32			 
4b32					; save it 
4b32			 
4b32 26 00				ld h,0 
4b34			 
4b34					; TODO push value back onto stack for another op etc 
4b34			 
4b34 cd 90 1b				call forth_push_numhl 
4b37					NEXTW 
4b37 c3 81 1f			jp macro_next 
4b3a				endm 
# End of macro NEXTW
4b3a			.SOUT: 
4b3a				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4b3a 34				db WORD_SYS_CORE+32             
4b3b 8d 4b			dw .SPIO            
4b3d 04				db 3 + 1 
4b3e .. 00			db "OUT",0              
4b42				endm 
# End of macro CWHEAD
4b42			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4b42					if DEBUG_FORTH_WORDS_KEY 
4b42						DMARK "OUT" 
4b42 f5				push af  
4b43 3a 57 4b			ld a, (.dmark)  
4b46 32 65 ee			ld (debug_mark),a  
4b49 3a 58 4b			ld a, (.dmark+1)  
4b4c 32 66 ee			ld (debug_mark+1),a  
4b4f 3a 59 4b			ld a, (.dmark+2)  
4b52 32 67 ee			ld (debug_mark+2),a  
4b55 18 03			jr .pastdmark  
4b57 ..			.dmark: db "OUT"  
4b5a f1			.pastdmark: pop af  
4b5b			endm  
# End of macro DMARK
4b5b						CALLMONITOR 
4b5b cd 6f ee			call debug_vector  
4b5e				endm  
# End of macro CALLMONITOR
4b5e					endif 
4b5e			 
4b5e					; get port 
4b5e			 
4b5e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b5e cd 95 1d			call macro_dsp_valuehl 
4b61				endm 
# End of macro FORTH_DSP_VALUEHL
4b61			 
4b61 e5					push hl 
4b62			 
4b62					; destroy value TOS 
4b62			 
4b62					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b62 cd 4d 1e			call macro_forth_dsp_pop 
4b65				endm 
# End of macro FORTH_DSP_POP
4b65			 
4b65					; get byte to send 
4b65			 
4b65					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b65 cd 95 1d			call macro_dsp_valuehl 
4b68				endm 
# End of macro FORTH_DSP_VALUEHL
4b68			 
4b68			;		push hl 
4b68			 
4b68					; destroy value TOS 
4b68			 
4b68					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b68 cd 4d 1e			call macro_forth_dsp_pop 
4b6b				endm 
# End of macro FORTH_DSP_POP
4b6b			 
4b6b					; one value on hl get other one back 
4b6b			 
4b6b			;		pop hl 
4b6b			 
4b6b c1					pop bc 
4b6c			 
4b6c					if DEBUG_FORTH_WORDS 
4b6c						DMARK "OUT" 
4b6c f5				push af  
4b6d 3a 81 4b			ld a, (.dmark)  
4b70 32 65 ee			ld (debug_mark),a  
4b73 3a 82 4b			ld a, (.dmark+1)  
4b76 32 66 ee			ld (debug_mark+1),a  
4b79 3a 83 4b			ld a, (.dmark+2)  
4b7c 32 67 ee			ld (debug_mark+2),a  
4b7f 18 03			jr .pastdmark  
4b81 ..			.dmark: db "OUT"  
4b84 f1			.pastdmark: pop af  
4b85			endm  
# End of macro DMARK
4b85						CALLMONITOR 
4b85 cd 6f ee			call debug_vector  
4b88				endm  
# End of macro CALLMONITOR
4b88					endif 
4b88			 
4b88 ed 69				out (c), l 
4b8a			 
4b8a					NEXTW 
4b8a c3 81 1f			jp macro_next 
4b8d				endm 
# End of macro NEXTW
4b8d			 
4b8d			 
4b8d			.SPIO: 
4b8d			 
4b8d			if STORAGE_SE 
4b8d				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4b8d			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4b8d			 
4b8d					call spi_ce_low 
4b8d			    NEXTW 
4b8d			 
4b8d			.SPICEH: 
4b8d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4b8d			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4b8d			 
4b8d					call spi_ce_high 
4b8d			    NEXTW 
4b8d			 
4b8d			 
4b8d			.SPIOb: 
4b8d			 
4b8d				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4b8d			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4b8d			 
4b8d					if DEBUG_FORTH_WORDS_KEY 
4b8d						DMARK "SPo" 
4b8d						CALLMONITOR 
4b8d					endif 
4b8d					; get port 
4b8d			 
4b8d			 
4b8d					; get byte to send 
4b8d			 
4b8d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b8d			 
4b8d			;		push hl    ; u1  
4b8d			 
4b8d					; destroy value TOS 
4b8d			 
4b8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b8d			 
4b8d					; one value on hl get other one back 
4b8d			 
4b8d			;		pop hl   ; u2 - addr 
4b8d			 
4b8d					; TODO Send SPI byte 
4b8d			 
4b8d			;		push hl 
4b8d			;		call spi_ce_low 
4b8d			;		pop hl 
4b8d					ld a, l 
4b8d					call spi_send_byte 
4b8d			;		call spi_ce_high 
4b8d			 
4b8d					NEXTW 
4b8d			 
4b8d			.SPII: 
4b8d				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4b8d			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4b8d					if DEBUG_FORTH_WORDS_KEY 
4b8d						DMARK "SPi" 
4b8d						CALLMONITOR 
4b8d					endif 
4b8d			 
4b8d					; TODO Get SPI byte 
4b8d			 
4b8d					call spi_read_byte 
4b8d			 
4b8d					if DEBUG_FORTH_WORDS 
4b8d						DMARK "Si2" 
4b8d						CALLMONITOR 
4b8d					endif 
4b8d					ld h, 0 
4b8d					ld l, a 
4b8d					if DEBUG_FORTH_WORDS 
4b8d						DMARK "Si3" 
4b8d						CALLMONITOR 
4b8d					endif 
4b8d					call forth_push_numhl 
4b8d			 
4b8d					NEXTW 
4b8d			 
4b8d			 
4b8d			 
4b8d			.SESEL: 
4b8d				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4b8d			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4b8d					if DEBUG_FORTH_WORDS_KEY 
4b8d						DMARK "BNK" 
4b8d						CALLMONITOR 
4b8d					endif 
4b8d			 
4b8d					ld a, 255 
4b8d					ld (spi_cartdev), a 
4b8d			 
4b8d					; get bank 
4b8d			 
4b8d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b8d			 
4b8d			;		push hl 
4b8d			 
4b8d					; destroy value TOS 
4b8d			 
4b8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b8d			 
4b8d					; one value on hl get other one back 
4b8d			 
4b8d			;		pop hl 
4b8d			 
4b8d			 
4b8d					ld c, SPI_CE_HIGH 
4b8d					ld b, '0'    ; human readable bank number 
4b8d			 
4b8d					ld a, l 
4b8d			 
4b8d					if DEBUG_FORTH_WORDS 
4b8d						DMARK "BNK" 
4b8d						CALLMONITOR 
4b8d					endif 
4b8d			 
4b8d					; active low 
4b8d			 
4b8d					cp 0 
4b8d					jr z, .bset 
4b8d					cp 1 
4b8d					jr nz, .b2 
4b8d					res 0, c 
4b8d					ld b, '1'    ; human readable bank number 
4b8d			.b2:		cp 2 
4b8d					jr nz, .b3 
4b8d					res 1, c 
4b8d					ld b, '2'    ; human readable bank number 
4b8d			.b3:		cp 3 
4b8d					jr nz, .b4 
4b8d					res 2, c 
4b8d					ld b, '3'    ; human readable bank number 
4b8d			.b4:		cp 4 
4b8d					jr nz, .b5 
4b8d					res 3, c 
4b8d					ld b, '4'    ; human readable bank number 
4b8d			.b5:		cp 5 
4b8d					jr nz, .bset 
4b8d					res 4, c 
4b8d					ld b, '5'    ; human readable bank number 
4b8d			 
4b8d			.bset: 
4b8d					ld a, c 
4b8d					ld (spi_device),a 
4b8d					ld a, b 
4b8d					ld (spi_device_id),a 
4b8d					if DEBUG_FORTH_WORDS 
4b8d						DMARK "BN2" 
4b8d						CALLMONITOR 
4b8d					endif 
4b8d			 
4b8d					; set default SPI clk pulse time as disabled for BANK use 
4b8d			 
4b8d					ld a, 0 
4b8d					ld (spi_clktime), a 
4b8d			 
4b8d					NEXTW 
4b8d			 
4b8d			.CARTDEV: 
4b8d				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4b8d			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4b8d					if DEBUG_FORTH_WORDS_KEY 
4b8d						DMARK "CDV" 
4b8d						CALLMONITOR 
4b8d					endif 
4b8d			 
4b8d					; disable se storage bank selection 
4b8d			 
4b8d					ld a, SPI_CE_HIGH		; ce high 
4b8d					ld (spi_device), a 
4b8d			 
4b8d					; get bank 
4b8d			 
4b8d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b8d			 
4b8d			;		push hl 
4b8d			 
4b8d					; destroy value TOS 
4b8d			 
4b8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b8d			 
4b8d					; one value on hl get other one back 
4b8d			 
4b8d			;		pop hl 
4b8d			 
4b8d					; active low 
4b8d			 
4b8d					ld c, 255 
4b8d			 
4b8d					ld a, l 
4b8d					if DEBUG_FORTH_WORDS 
4b8d						DMARK "CDV" 
4b8d						CALLMONITOR 
4b8d					endif 
4b8d					cp 0 
4b8d					jr z, .cset 
4b8d					cp 1 
4b8d					jr nz, .c2 
4b8d					res 0, c 
4b8d			.c2:		cp 2 
4b8d					jr nz, .c3 
4b8d					res 1, c 
4b8d			.c3:		cp 3 
4b8d					jr nz, .c4 
4b8d					res 2, c 
4b8d			.c4:		cp 4 
4b8d					jr nz, .c5 
4b8d					res 3, c 
4b8d			.c5:		cp 5 
4b8d					jr nz, .c6 
4b8d					res 4, c 
4b8d			.c6:		cp 6 
4b8d					jr nz, .c7 
4b8d					res 5, c 
4b8d			.c7:		cp 7 
4b8d					jr nz, .c8 
4b8d					res 6, c 
4b8d			.c8:		cp 8 
4b8d					jr nz, .cset 
4b8d					res 7, c 
4b8d			.cset:		ld a, c 
4b8d					ld (spi_cartdev),a 
4b8d			 
4b8d					if DEBUG_FORTH_WORDS 
4b8d						DMARK "CD2" 
4b8d						CALLMONITOR 
4b8d					endif 
4b8d			 
4b8d					; set default SPI clk pulse time as 10ms for CARTDEV use 
4b8d			 
4b8d					ld a, $0a 
4b8d					ld (spi_clktime), a 
4b8d					NEXTW 
4b8d			endif 
4b8d			 
4b8d			.ENDDEVICE: 
4b8d			; eof 
4b8d			 
# End of file forth_words_device.asm
4b8d			 
4b8d			; var handler 
4b8d			 
4b8d			 
4b8d			.VARS: 
4b8d				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4b8d 77				db WORD_SYS_CORE+99             
4b8e 3e 4c			dw .V0            
4b90 04				db 3 + 1 
4b91 .. 00			db "VAR",0              
4b95				endm 
# End of macro CWHEAD
4b95			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4b95			;| 
4b95			;| The variable name should consist of a single letter. e.g. "a" 
4b95			;! If a full string is passed then only the first char is looked at 
4b95			;| Any other char could exceed bounds checks!  
4b95			 
4b95					if DEBUG_FORTH_WORDS_KEY 
4b95						DMARK "VAR" 
4b95 f5				push af  
4b96 3a aa 4b			ld a, (.dmark)  
4b99 32 65 ee			ld (debug_mark),a  
4b9c 3a ab 4b			ld a, (.dmark+1)  
4b9f 32 66 ee			ld (debug_mark+1),a  
4ba2 3a ac 4b			ld a, (.dmark+2)  
4ba5 32 67 ee			ld (debug_mark+2),a  
4ba8 18 03			jr .pastdmark  
4baa ..			.dmark: db "VAR"  
4bad f1			.pastdmark: pop af  
4bae			endm  
# End of macro DMARK
4bae						CALLMONITOR 
4bae cd 6f ee			call debug_vector  
4bb1				endm  
# End of macro CALLMONITOR
4bb1					endif 
4bb1			 
4bb1					FORTH_DSP_VALUEHL 
4bb1 cd 95 1d			call macro_dsp_valuehl 
4bb4				endm 
# End of macro FORTH_DSP_VALUEHL
4bb4			 
4bb4 7e					ld a, (hl)    ; get first char on of the string 
4bb5			 
4bb5			 
4bb5					if DEBUG_FORTH_WORDS 
4bb5						DMARK "VR1" 
4bb5 f5				push af  
4bb6 3a ca 4b			ld a, (.dmark)  
4bb9 32 65 ee			ld (debug_mark),a  
4bbc 3a cb 4b			ld a, (.dmark+1)  
4bbf 32 66 ee			ld (debug_mark+1),a  
4bc2 3a cc 4b			ld a, (.dmark+2)  
4bc5 32 67 ee			ld (debug_mark+2),a  
4bc8 18 03			jr .pastdmark  
4bca ..			.dmark: db "VR1"  
4bcd f1			.pastdmark: pop af  
4bce			endm  
# End of macro DMARK
4bce						CALLMONITOR 
4bce cd 6f ee			call debug_vector  
4bd1				endm  
# End of macro CALLMONITOR
4bd1					endif 
4bd1					 
4bd1 f5					push af	 
4bd2					FORTH_DSP_POP 
4bd2 cd 4d 1e			call macro_forth_dsp_pop 
4bd5				endm 
# End of macro FORTH_DSP_POP
4bd5 f1					pop af 
4bd6			 
4bd6					; convert to upper 
4bd6			 
4bd6 cd 6a 10				call to_upper 
4bd9					if DEBUG_FORTH_WORDS 
4bd9						DMARK "Vaa" 
4bd9 f5				push af  
4bda 3a ee 4b			ld a, (.dmark)  
4bdd 32 65 ee			ld (debug_mark),a  
4be0 3a ef 4b			ld a, (.dmark+1)  
4be3 32 66 ee			ld (debug_mark+1),a  
4be6 3a f0 4b			ld a, (.dmark+2)  
4be9 32 67 ee			ld (debug_mark+2),a  
4bec 18 03			jr .pastdmark  
4bee ..			.dmark: db "Vaa"  
4bf1 f1			.pastdmark: pop af  
4bf2			endm  
# End of macro DMARK
4bf2						CALLMONITOR 
4bf2 cd 6f ee			call debug_vector  
4bf5				endm  
# End of macro CALLMONITOR
4bf5					endif 
4bf5 06 41				ld b, 'A' 
4bf7 90					sub b			; set offset 
4bf8					if DEBUG_FORTH_WORDS 
4bf8						DMARK "Vbb" 
4bf8 f5				push af  
4bf9 3a 0d 4c			ld a, (.dmark)  
4bfc 32 65 ee			ld (debug_mark),a  
4bff 3a 0e 4c			ld a, (.dmark+1)  
4c02 32 66 ee			ld (debug_mark+1),a  
4c05 3a 0f 4c			ld a, (.dmark+2)  
4c08 32 67 ee			ld (debug_mark+2),a  
4c0b 18 03			jr .pastdmark  
4c0d ..			.dmark: db "Vbb"  
4c10 f1			.pastdmark: pop af  
4c11			endm  
# End of macro DMARK
4c11						CALLMONITOR 
4c11 cd 6f ee			call debug_vector  
4c14				endm  
# End of macro CALLMONITOR
4c14					endif 
4c14 cb 27				sla a  
4c16				 
4c16					 
4c16					if DEBUG_FORTH_WORDS 
4c16						DMARK "VR2" 
4c16 f5				push af  
4c17 3a 2b 4c			ld a, (.dmark)  
4c1a 32 65 ee			ld (debug_mark),a  
4c1d 3a 2c 4c			ld a, (.dmark+1)  
4c20 32 66 ee			ld (debug_mark+1),a  
4c23 3a 2d 4c			ld a, (.dmark+2)  
4c26 32 67 ee			ld (debug_mark+2),a  
4c29 18 03			jr .pastdmark  
4c2b ..			.dmark: db "VR2"  
4c2e f1			.pastdmark: pop af  
4c2f			endm  
# End of macro DMARK
4c2f						CALLMONITOR 
4c2f cd 6f ee			call debug_vector  
4c32				endm  
# End of macro CALLMONITOR
4c32					endif 
4c32			 
4c32 21 ee e9				ld hl, cli_var_array2 
4c35 cd f5 0d				call addatohl 
4c38 cd 90 1b				call forth_push_numhl 
4c3b			 
4c3b			 
4c3b				       NEXTW 
4c3b c3 81 1f			jp macro_next 
4c3e				endm 
# End of macro NEXTW
4c3e			.V0: 
4c3e				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4c3e 78				db WORD_SYS_CORE+100             
4c3f 56 4c			dw .V0Q            
4c41 04				db 3 + 1 
4c42 .. 00			db "V0!",0              
4c46				endm 
# End of macro CWHEAD
4c46			;| V0! ( u1 -- )  Store value to v0  | DONE 
4c46			 
4c46					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c46 cd 95 1d			call macro_dsp_valuehl 
4c49				endm 
# End of macro FORTH_DSP_VALUEHL
4c49			 
4c49 11 22 ea				ld de, cli_var_array 
4c4c			 
4c4c eb					ex de, hl 
4c4d 73					ld (hl), e 
4c4e 23					inc hl 
4c4f 72					ld (hl), d 
4c50			 
4c50					; destroy value TOS 
4c50			 
4c50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c50 cd 4d 1e			call macro_forth_dsp_pop 
4c53				endm 
# End of macro FORTH_DSP_POP
4c53			 
4c53				       NEXTW 
4c53 c3 81 1f			jp macro_next 
4c56				endm 
# End of macro NEXTW
4c56			.V0Q: 
4c56				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4c56 79				db WORD_SYS_CORE+101             
4c57 67 4c			dw .V1S            
4c59 04				db 3 + 1 
4c5a .. 00			db "V0@",0              
4c5e				endm 
# End of macro CWHEAD
4c5e			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4c5e 2a 22 ea				ld hl, (cli_var_array) 
4c61 cd 90 1b				call forth_push_numhl 
4c64			 
4c64				       NEXTW 
4c64 c3 81 1f			jp macro_next 
4c67				endm 
# End of macro NEXTW
4c67			.V1S: 
4c67				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4c67 7a				db WORD_SYS_CORE+102             
4c68 7f 4c			dw .V1Q            
4c6a 04				db 3 + 1 
4c6b .. 00			db "V1!",0              
4c6f				endm 
# End of macro CWHEAD
4c6f			;| V1! ( u1 -- )  Store value to v1 | DONE 
4c6f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c6f cd 95 1d			call macro_dsp_valuehl 
4c72				endm 
# End of macro FORTH_DSP_VALUEHL
4c72			 
4c72 11 24 ea				ld de, cli_var_array+2 
4c75				 
4c75 eb					ex de, hl 
4c76 73					ld (hl), e 
4c77 23					inc hl 
4c78 72					ld (hl), d 
4c79			 
4c79					; destroy value TOS 
4c79			 
4c79					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c79 cd 4d 1e			call macro_forth_dsp_pop 
4c7c				endm 
# End of macro FORTH_DSP_POP
4c7c				       NEXTW 
4c7c c3 81 1f			jp macro_next 
4c7f				endm 
# End of macro NEXTW
4c7f			.V1Q: 
4c7f				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4c7f 7b				db WORD_SYS_CORE+103             
4c80 90 4c			dw .V2S            
4c82 04				db 3 + 1 
4c83 .. 00			db "V1@",0              
4c87				endm 
# End of macro CWHEAD
4c87			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4c87 2a 24 ea				ld hl, (cli_var_array+2) 
4c8a cd 90 1b				call forth_push_numhl 
4c8d				       NEXTW 
4c8d c3 81 1f			jp macro_next 
4c90				endm 
# End of macro NEXTW
4c90			.V2S: 
4c90				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4c90 7c				db WORD_SYS_CORE+104             
4c91 a8 4c			dw .V2Q            
4c93 04				db 3 + 1 
4c94 .. 00			db "V2!",0              
4c98				endm 
# End of macro CWHEAD
4c98			;| V2! ( u1 -- )  Store value to v2 | DONE 
4c98					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c98 cd 95 1d			call macro_dsp_valuehl 
4c9b				endm 
# End of macro FORTH_DSP_VALUEHL
4c9b			 
4c9b 11 26 ea				ld de, cli_var_array+4 
4c9e				 
4c9e eb					ex de, hl 
4c9f 73					ld (hl), e 
4ca0 23					inc hl 
4ca1 72					ld (hl), d 
4ca2			 
4ca2					; destroy value TOS 
4ca2			 
4ca2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ca2 cd 4d 1e			call macro_forth_dsp_pop 
4ca5				endm 
# End of macro FORTH_DSP_POP
4ca5				       NEXTW 
4ca5 c3 81 1f			jp macro_next 
4ca8				endm 
# End of macro NEXTW
4ca8			.V2Q: 
4ca8				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4ca8 7d				db WORD_SYS_CORE+105             
4ca9 b9 4c			dw .V3S            
4cab 04				db 3 + 1 
4cac .. 00			db "V2@",0              
4cb0				endm 
# End of macro CWHEAD
4cb0			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4cb0 2a 26 ea				ld hl, (cli_var_array+4) 
4cb3 cd 90 1b				call forth_push_numhl 
4cb6				       NEXTW 
4cb6 c3 81 1f			jp macro_next 
4cb9				endm 
# End of macro NEXTW
4cb9			.V3S: 
4cb9				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4cb9 7c				db WORD_SYS_CORE+104             
4cba d1 4c			dw .V3Q            
4cbc 04				db 3 + 1 
4cbd .. 00			db "V3!",0              
4cc1				endm 
# End of macro CWHEAD
4cc1			;| V3! ( u1 -- )  Store value to v3 | DONE 
4cc1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cc1 cd 95 1d			call macro_dsp_valuehl 
4cc4				endm 
# End of macro FORTH_DSP_VALUEHL
4cc4			 
4cc4 11 28 ea				ld de, cli_var_array+6 
4cc7				 
4cc7 eb					ex de, hl 
4cc8 73					ld (hl), e 
4cc9 23					inc hl 
4cca 72					ld (hl), d 
4ccb			 
4ccb					; destroy value TOS 
4ccb			 
4ccb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ccb cd 4d 1e			call macro_forth_dsp_pop 
4cce				endm 
# End of macro FORTH_DSP_POP
4cce				       NEXTW 
4cce c3 81 1f			jp macro_next 
4cd1				endm 
# End of macro NEXTW
4cd1			.V3Q: 
4cd1				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4cd1 7d				db WORD_SYS_CORE+105             
4cd2 e2 4c			dw .END            
4cd4 04				db 3 + 1 
4cd5 .. 00			db "V3@",0              
4cd9				endm 
# End of macro CWHEAD
4cd9			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4cd9 2a 28 ea				ld hl, (cli_var_array+6) 
4cdc cd 90 1b				call forth_push_numhl 
4cdf				       NEXTW 
4cdf c3 81 1f			jp macro_next 
4ce2				endm 
# End of macro NEXTW
4ce2			 
4ce2			 
4ce2			 
4ce2			 
4ce2			 
4ce2			; end of dict marker 
4ce2			 
4ce2 00			.END:    db WORD_SYS_END 
4ce3 00 00			dw 0 
4ce5 00				db 0 
4ce6			 
4ce6			; use to jp here for user dict words to save on macro expansion  
4ce6			 
4ce6			user_dict_next: 
4ce6				NEXTW 
4ce6 c3 81 1f			jp macro_next 
4ce9				endm 
# End of macro NEXTW
4ce9			 
4ce9			 
4ce9			user_exec: 
4ce9				;    ld hl, <word code> 
4ce9				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4ce9				;    call forthexec 
4ce9				;    jp user_dict_next   (NEXT) 
4ce9			        ;    <word code bytes> 
4ce9 eb				ex de, hl 
4cea 2a bc e5			ld hl,(os_tok_ptr) 
4ced				 
4ced				FORTH_RSP_NEXT 
4ced cd 37 1b			call macro_forth_rsp_next 
4cf0				endm 
# End of macro FORTH_RSP_NEXT
4cf0			 
4cf0			if DEBUG_FORTH_UWORD 
4cf0						DMARK "UEX" 
4cf0 f5				push af  
4cf1 3a 05 4d			ld a, (.dmark)  
4cf4 32 65 ee			ld (debug_mark),a  
4cf7 3a 06 4d			ld a, (.dmark+1)  
4cfa 32 66 ee			ld (debug_mark+1),a  
4cfd 3a 07 4d			ld a, (.dmark+2)  
4d00 32 67 ee			ld (debug_mark+2),a  
4d03 18 03			jr .pastdmark  
4d05 ..			.dmark: db "UEX"  
4d08 f1			.pastdmark: pop af  
4d09			endm  
# End of macro DMARK
4d09				CALLMONITOR 
4d09 cd 6f ee			call debug_vector  
4d0c				endm  
# End of macro CALLMONITOR
4d0c			endif 
4d0c			 
4d0c			 
4d0c			 
4d0c eb				ex de, hl 
4d0d 22 bc e5			ld (os_tok_ptr), hl 
4d10				 
4d10				; Don't use next - Skips the first word in uword. 
4d10			 
4d10 c3 12 20			jp exec1 
4d13			;	NEXT 
4d13			 
4d13			 
4d13			; eof 
# End of file forth_wordsv4.asm
4d13			endif 
4d13			;;;;;;;;;;;;;; Debug code 
4d13			 
4d13			 
4d13			;if DEBUG_FORTH_PARSE 
4d13 .. 00		.nowordfound: db "No match",0 
4d1c .. 00		.compword:	db "Comparing word ",0 
4d2c .. 00		.nextwordat:	db "Next word at",0 
4d39 .. 00		.charmatch:	db "Char match",0 
4d44			;endif 
4d44			if DEBUG_FORTH_JP 
4d44			.foundword:	db "Word match. Exec..",0 
4d44			endif 
4d44			;if DEBUG_FORTH_PUSH 
4d44 .. 00		.enddict:	db "Dict end. Push.",0 
4d54 .. 00		.push_str:	db "Pushing string",0 
4d63 .. 00		.push_num:	db "Pushing number",0 
4d72 .. 00		.data_sp:	db "SP:",0 
4d76 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4d88 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4d9a .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4dac			;endif 
4dac			;if DEBUG_FORTH_MALLOC 
4dac .. 00		.push_malloc:	db "Malloc address",0 
4dbb			;endif 
4dbb			 
4dbb			 
4dbb			 
4dbb			; display malloc address and current data stack pointer  
4dbb			 
4dbb			malloc_error: 
4dbb d5				push de 
4dbc f5				push af 
4dbd e5				push hl 
4dbe cd c8 0b			call clear_display 
4dc1 11 e1 4d			ld de, .mallocerr 
4dc4 3e 00			ld a,0 
4dc6			;	ld de,os_word_scratch 
4dc6 cd db 0b			call str_at_display 
4dc9 3e 11			ld a, display_row_1+17 
4dcb 11 65 ee			ld de, debug_mark 
4dce cd db 0b			call str_at_display 
4dd1 cd eb 0b			call update_display 
4dd4				;call break_point_state 
4dd4 cd 2f 5f			call cin_wait 
4dd7			 
4dd7			;	ld a, ' ' 
4dd7			;	ld (os_view_disable), a 
4dd7 cd ff 14			call bp_on 
4dda e1				pop hl 
4ddb f1				pop af 
4ddc d1				pop de	 
4ddd				CALLMONITOR 
4ddd cd 6f ee			call debug_vector  
4de0				endm  
# End of macro CALLMONITOR
4de0 c9				ret 
4de1			 
4de1 .. 00		.mallocerr: 	db "Malloc Error",0 
4dee			;if DEBUG_FORTH_PUSH 
4dee			display_data_sp: 
4dee f5				push af 
4def			 
4def				; see if disabled 
4def			 
4def			 
4def 3a 6f ee			ld a, (debug_vector) 
4df2 fe c9			cp $C9  ; RET 
4df4				;ld a, (os_view_disable) 
4df4				;cp '*' 
4df4 28 67			jr z, .skipdsp 
4df6			 
4df6 e5				push hl 
4df7 e5				push hl 
4df8 e5			push hl 
4df9 cd c8 0b			call clear_display 
4dfc e1			pop hl 
4dfd 7c				ld a,h 
4dfe 21 c0 e5			ld hl, os_word_scratch 
4e01 cd fe 0f			call hexout 
4e04 e1				pop hl 
4e05 7d				ld a,l 
4e06 21 c2 e5			ld hl, os_word_scratch+2 
4e09 cd fe 0f			call hexout 
4e0c 21 c4 e5			ld hl, os_word_scratch+4 
4e0f 3e 00			ld a,0 
4e11 77				ld (hl),a 
4e12 11 c0 e5			ld de,os_word_scratch 
4e15 3e 28				ld a, display_row_2 
4e17 cd db 0b				call str_at_display 
4e1a 11 76 4d			ld de, .wordinhl 
4e1d 3e 00			ld a, display_row_1 
4e1f			 
4e1f cd db 0b				call str_at_display 
4e22 11 65 ee			ld de, debug_mark 
4e25 3e 11			ld a, display_row_1+17 
4e27			 
4e27 cd db 0b				call str_at_display 
4e2a			 
4e2a				; display current data stack pointer 
4e2a 11 72 4d			ld de,.data_sp 
4e2d 3e 30				ld a, display_row_2 + 8 
4e2f cd db 0b				call str_at_display 
4e32			 
4e32 2a e8 e9			ld hl,(cli_data_sp) 
4e35 e5				push hl 
4e36 7c				ld a,h 
4e37 21 c0 e5			ld hl, os_word_scratch 
4e3a cd fe 0f			call hexout 
4e3d e1				pop hl 
4e3e 7d				ld a,l 
4e3f 21 c2 e5			ld hl, os_word_scratch+2 
4e42 cd fe 0f			call hexout 
4e45 21 c4 e5			ld hl, os_word_scratch+4 
4e48 3e 00			ld a,0 
4e4a 77				ld (hl),a 
4e4b 11 c0 e5			ld de,os_word_scratch 
4e4e 3e 33				ld a, display_row_2 + 11 
4e50 cd db 0b				call str_at_display 
4e53			 
4e53			 
4e53 cd eb 0b			call update_display 
4e56 cd 00 0b			call delay1s 
4e59 cd 00 0b			call delay1s 
4e5c e1				pop hl 
4e5d			.skipdsp: 
4e5d f1				pop af 
4e5e c9				ret 
4e5f			 
4e5f			display_data_malloc: 
4e5f			 
4e5f f5				push af 
4e60 e5				push hl 
4e61 e5				push hl 
4e62 e5			push hl 
4e63 cd c8 0b			call clear_display 
4e66 e1			pop hl 
4e67 7c				ld a,h 
4e68 21 c0 e5			ld hl, os_word_scratch 
4e6b cd fe 0f			call hexout 
4e6e e1				pop hl 
4e6f 7d				ld a,l 
4e70 21 c2 e5			ld hl, os_word_scratch+2 
4e73 cd fe 0f			call hexout 
4e76 21 c4 e5			ld hl, os_word_scratch+4 
4e79 3e 00			ld a,0 
4e7b 77				ld (hl),a 
4e7c 11 c0 e5			ld de,os_word_scratch 
4e7f 3e 28				ld a, display_row_2 
4e81 cd db 0b				call str_at_display 
4e84 11 ac 4d			ld de, .push_malloc 
4e87 3e 00			ld a, display_row_1 
4e89			 
4e89 cd db 0b				call str_at_display 
4e8c			 
4e8c				; display current data stack pointer 
4e8c 11 72 4d			ld de,.data_sp 
4e8f 3e 30				ld a, display_row_2 + 8 
4e91 cd db 0b				call str_at_display 
4e94			 
4e94 2a e8 e9			ld hl,(cli_data_sp) 
4e97 e5				push hl 
4e98 7c				ld a,h 
4e99 21 c0 e5			ld hl, os_word_scratch 
4e9c cd fe 0f			call hexout 
4e9f e1				pop hl 
4ea0 7d				ld a,l 
4ea1 21 c2 e5			ld hl, os_word_scratch+2 
4ea4 cd fe 0f			call hexout 
4ea7 21 c4 e5			ld hl, os_word_scratch+4 
4eaa 3e 00			ld a,0 
4eac 77				ld (hl),a 
4ead 11 c0 e5			ld de,os_word_scratch 
4eb0 3e 33				ld a, display_row_2 + 11 
4eb2 cd db 0b				call str_at_display 
4eb5			 
4eb5 cd eb 0b			call update_display 
4eb8 cd 00 0b			call delay1s 
4ebb cd 00 0b			call delay1s 
4ebe e1				pop hl 
4ebf f1				pop af 
4ec0 c9				ret 
4ec1			;endif 
4ec1			 
4ec1			include "forth_autostart.asm" 
4ec1			; list of commands to perform at system start up 
4ec1			 
4ec1			startcmds: 
4ec1			;	dw test11 
4ec1			;	dw test12 
4ec1			;	dw test13 
4ec1			;	dw test14 
4ec1			;	dw test15 
4ec1			;	dw test16 
4ec1			;	dw test17 
4ec1			;	dw ifthtest1 
4ec1			;	dw ifthtest2 
4ec1			;	dw ifthtest3 
4ec1			;	dw mmtest1 
4ec1			;	dw mmtest2 
4ec1			;	dw mmtest3 
4ec1			;	dw mmtest4 
4ec1			;	dw mmtest5 
4ec1			;	dw mmtest6 
4ec1			;	dw iftest1 
4ec1			;	dw iftest2 
4ec1			;	dw iftest3 
4ec1			;	dw looptest1 
4ec1			;	dw looptest2 
4ec1			;	dw test1 
4ec1			;	dw test2 
4ec1			;	dw test3 
4ec1			;	dw test4 
4ec1			;	dw game2r 
4ec1			;	dw game2b1 
4ec1			;	dw game2b2 
4ec1			 
4ec1				; start up words that are actually useful 
4ec1			 
4ec1			;    dw spi1 
4ec1			;    dw spi2 
4ec1			;    dw spi3 
4ec1			;    dw spi4 
4ec1			;    dw spi5 
4ec1			;    dw spi6 
4ec1			;    dw spi7 
4ec1			; 
4ec1			;    dw spi8 
4ec1			;    dw spi9 
4ec1			;    dw spi10 
4ec1			 
4ec1			; file editor 
4ec1			;	dw edit1 
4ec1			;	dw edit2 
4ec1			;	dw edit3 
4ec1			 
4ec1			;	dw longread 
4ec1 e1 52			dw clrstack 
4ec3 15 53			dw type 
4ec5			;	dw stest 
4ec5 3a 53			dw strncpy 
4ec7			;	dw list 
4ec7 9b 53			dw start1 
4ec9 ab 53			dw start2 
4ecb			;	dw start3 
4ecb			;	dw start3b 
4ecb			;	dw start3c 
4ecb			 
4ecb				; (unit) testing words 
4ecb			 
4ecb			;	dw mtesta 
4ecb			;	dw mtestb 
4ecb			;	dw mtestc 
4ecb			;	dw mtestd 
4ecb			;	dw mteste 
4ecb			 
4ecb				; demo/game words 
4ecb			 
4ecb			;        dw game3w 
4ecb			;        dw game3p 
4ecb			;        dw game3sc 
4ecb			;        dw game3vsi 
4ecb			;        dw game3vs 
4ecb				 
4ecb			;	dw game2b 
4ecb			;	dw game2bf 
4ecb			;	dw game2mba 
4ecb			;	dw game2mbas 
4ecb			;	dw game2mb 
4ecb			 
4ecb c8 56			dw game1 
4ecd d9 56			dw game1a 
4ecf 3b 57			dw game1b 
4ed1 70 57			dw game1c 
4ed3 a6 57			dw game1d 
4ed5 d7 57			dw game1s 
4ed7 eb 57			dw game1t 
4ed9 00 58			dw game1f 
4edb 34 58			dw game1z 
4edd 78 58			dw game1zz 
4edf			 
4edf 01 55			dw test5 
4ee1 39 55			dw test6 
4ee3 71 55			dw test7 
4ee5 85 55			dw test8 
4ee7 b1 55			dw test9 
4ee9 c7 55			dw test10 
4eeb				 
4eeb 4f 59		        dw ssv5 
4eed 33 59		        dw ssv4 
4eef 17 59		        dw ssv3 
4ef1 e1 58		        dw ssv2 
4ef3 68 59		        dw ssv1 
4ef5 b0 59		        dw ssv1cpm 
4ef7			;	dw keyup 
4ef7			;	dw keydown 
4ef7			;	dw keyleft 
4ef7			;	dw keyright 
4ef7			;	dw 	keyf1 
4ef7			;	dw keyf2 
4ef7			;	dw keyf3 
4ef7			;	dw keyf4 
4ef7			;	dw keyf5 
4ef7			;	dw keyf6 
4ef7			;	dw keyf7 
4ef7			;	dw keyf8 
4ef7			;	dw keyf9 
4ef7			;	dw keyf10 
4ef7			;	dw keyf11 
4ef7			;	dw keyf12 
4ef7			;	dw keytab 
4ef7			;	dw keycr 
4ef7			;	dw keyhome 
4ef7			;	dw keyend 
4ef7			;	dw keybs 
4ef7 00 00			db 0, 0	 
4ef9			 
4ef9			 
4ef9			; File Editor 
4ef9			 
4ef9			; ( id - ) use 'e' to edit the displayed line 
4ef9 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4f1a .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4f4f			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4f4f .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f87			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f87			 
4f87			; SPI Net support words 
4f87			 
4f87			; v0! = node to send to 
4f87			; ( str count - ) 
4f87 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4fe0			 
4fe0			; spiputc ( char node - ) 
4fe0 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
5014			; spiputc ( u node - ) 
5014 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
5042			 
5042			; spigetc ( - n ) 
5042 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
506b			 
506b			; getnode ( - n ) 
506b .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5098			 
5098			; ( str node - )  
5098 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
50fe			; store string ( str i - ) 
50fe			 
50fe			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
50fe .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5153			 
5153			; get string ( addr i -  )    TO FIX 
5153			 
5153 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
51ab			 
51ab			 
51ab			; NETCHAT (TODO) 
51ab			; Program to allow two nodes to chat with eachother 
51ab			; 
51ab			; v0 - target node 
51ab			;  
51ab			; accept input at 0,0 
51ab			; if input is string send spitype to target node 
51ab			; starting at row 2,0 , while spigetchr is not zero ->  
51ab			; 
51ab			; 
51ab			; TODO add paging of get request 
51ab			 
51ab			; ( node - ) 
51ab .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
51ca .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5222 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
529a			 
529a			 
529a			; Long read of currently open file 
529a .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
52e1			 
52e1			; clear stack  
52e1			 
52e1 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
5315			 
5315			; type ( addr count - ) 
5315 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
533a			 
533a			; some direct memory words 
533a			; strncpy ( len t f -- t ) 
533a			 
533a .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
539b			 
539b .. 00		start1:     	db ": bpon $00 bp ;",0 
53ab .. 00		start2:     	db ": bpoff $01 bp ;",0 
53bc .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5437 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5497			 
5497			 
5497			; a handy word to list items on the stack 
5497			 
5497 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5501			 
5501			 
5501			; test stack  
5501			; rnd8 stest 
5501			 
5501			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5501			 
5501			; random malloc and free cycles 
5501			 
5501			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5501			 
5501			; fixed malloc and free cycles 
5501			 
5501			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5501			 
5501			; fixed double string push and drop cycle  
5501			 
5501			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5501			 
5501			; consistent fixed string push and drop cycle  
5501			 
5501			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5501			 
5501			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5501			 
5501			;test1:		db ": aa 1 2 3 ;", 0 
5501			;test2:     	db "111 aa 888 999",0 
5501			;test3:     	db ": bb 77 ;",0 
5501			;test4:     	db "$02 $01 do i . loop bb",0 
5501			 
5501 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5539 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5571 .. 00		test7:     	db ": box hline vline ;",0 
5585 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
55b1 .. 00		test9:     	db ": sw $01 adsp world ;",0 
55c7 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
55ec			;test11:     	db "hello create .",0 
55ec			;test12:     	db "hello2 create .",0 
55ec			 
55ec			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
55ec			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
55ec			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
55ec			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
55ec			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
55ec			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
55ec			 
55ec			;iftest1:     	db "$0001 IF cls .",0 
55ec			;iftest2:     	db "$0000 IF cls .",0 
55ec			;iftest3:     	db "$0002 $0003 - IF cls .",0 
55ec			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
55ec			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
55ec			 
55ec			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
55ec			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
55ec			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
55ec			 
55ec			 
55ec .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5610 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5640 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5665 .. 00		sound4: db ": cha $00 ; ",0 
5672 .. 00		sound5: db ": chb $20 ; ",0 
567f .. 00		sound6: db ": chc $40 ; ",0 
568c .. 00		sound7: db ": chd $60 ; ",0 
5699 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
56b1 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
56c8			 
56c8			 
56c8			 
56c8			 
56c8			; a small guess the number game 
56c8			 
56c8 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
56d9 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
573b			 
573b .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5770 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
57a6 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
57d7 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
57eb .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5800 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5834 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5878			 
5878			; Using 'ga' save a high score across multiple runs using external storage 
5878			 
5878 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
58e1			 
58e1			 
58e1			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
58e1			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
58e1			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
58e1			 
58e1			; simple screen saver to test code memory reuse to destruction 
58e1			 
58e1 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5917 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5933 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
594f .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5968 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
59b0 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5a07			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5a07			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5a07			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5a07			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5a07			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5a07			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5a07			 
5a07			 
5a07			 
5a07			; minesweeper/battleship finding game 
5a07			; draws a game board of random ship/mine positions 
5a07			; user enters coords to see if it hits on 
5a07			; game ends when all are hit 
5a07			; when hit or miss says how many may be in the area 
5a07			 
5a07			; setup the game board and then hide it 
5a07			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5a07			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5a07			;; prompt for where to target 
5a07			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5a07			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5a07			;; TODO see if the entered coords hits or misses pushes char hit of miss 
5a07			;game2mbht:      db ": mbckht nop ;",0 
5a07			;game2mbms:      db ": mbcms nop ;",0 
5a07			; TODO how many might be near by 
5a07			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5a07			 
5a07			; Game 3 
5a07			 
5a07			; Vert scroller ski game - avoid the trees! 
5a07			 
5a07			; v0 score (ie turns) 
5a07			; v1 player pos 
5a07			; v2 left wall 
5a07			; v3 right wall 
5a07			 
5a07			; Draw side walls randomly 
5a07			 
5a07			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5a07			 
5a07			; Draw player 
5a07			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5a07			 
5a07			; TODO Get Key 
5a07			 
5a07			; TODO Move left right 
5a07			 
5a07			; scroll and move walls a bit 
5a07			 
5a07			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5a07			 
5a07			; main game loop 
5a07			 
5a07			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5a07			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5a07			 
5a07			; key board defs 
5a07			 
5a07 .. 00		keyup:       db ": keyup $05 ;",0 
5a15 .. 00		keydown:       db ": keydown $0a ;",0 
5a25 .. 00		keyleft:       db ": keyleft $0b ;",0 
5a35 .. 00		keyright:       db ": keyright $0c ;",0 
5a46 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5a54 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5a62 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5a70 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5a7e .. 00		keyf5:       db ": keyf5 $14 ;",0 
5a8c .. 00		keyf6:       db ": keyf6 $15 ;",0 
5a9a .. 00		keyf7:       db ": keyf7 $16 ;",0 
5aa8 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5ab6 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5ac4 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5ad3 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5ae2 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5af1			 
5af1 .. 00		keytab:       db ": keytab $09 ;",0 
5b00 .. 00		keycr:       db ": keycr $0d ;",0 
5b0e .. 00		keyhome:       db ": keyhome $0e ;",0 
5b1e .. 00		keyend:       db ": keyend $0f ;",0 
5b2d .. 00		keybs:       db ": keybs $08 ;",0 
5b3b			 
5b3b			   
5b3b			 
5b3b			 
5b3b			 
5b3b			; eof 
# End of file forth_autostart.asm
5b3b			 
5b3b			 
5b3b			 
5b3b			; stack over and underflow checks 
5b3b			 
5b3b			; init the words to detect the under/overflow 
5b3b			 
5b3b			chk_stk_init: 
5b3b				; a vague random number to check so we dont get any "lucky" hits 
5b3b 3e 2d			ld a, 45 
5b3d 6f				ld l, a 
5b3e 00				nop 
5b3f 3e 17			ld a, 23 
5b41 67				ld h, a 
5b42			 
5b42 22 97 e2			ld (chk_word), hl     ; the word we need to check against 
5b45			 
5b45			;	ld (chk_stund), hl	; stack points.... 
5b45 22 00 ef			ld (chk_stovr), hl 
5b48 22 e6 e9			ld (chk_ret_und), hl 
5b4b 22 a4 e9			ld (chk_ret_ovr), hl 
5b4e 22 22 e9			ld (chk_loop_ovr), hl 
5b51 22 20 e8			ld (chk_data_ovr), hl 
5b54 c9				ret 
5b55				 
5b55			check_stacks: 
5b55				; check all stack words 
5b55			 
5b55 e5				push hl 
5b56 d5				push de 
5b57			 
5b57			;	ld de,(chk_word) 
5b57			;	ld hl, (chk_stund)	; stack points.... 
5b57			;	if DEBUG_STK_FAULT 
5b57			;		DMARK "FAa" 
5b57			;		CALLMONITOR 
5b57			;	endif 
5b57			;	call cmp16 
5b57			;	jp z, .chk_faulta 
5b57			; 
5b57			;	ld de, sfaultsu 
5b57			;	jp .chk_fault 
5b57			 
5b57 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5b5a ed 5b 97 e2		ld de,(chk_word) 
5b5e				if DEBUG_STK_FAULT 
5b5e					DMARK "FAb" 
5b5e					CALLMONITOR 
5b5e				endif 
5b5e cd 13 0e			call cmp16 
5b61 28 06			jr z, .chk_fault1 
5b63 11 07 5c			ld de, sfaultso 
5b66 c3 b8 5b			jp .chk_fault 
5b69			.chk_fault1:  
5b69 2a e6 e9			ld hl, (chk_ret_und) 
5b6c ed 5b 97 e2		ld de,(chk_word) 
5b70				if DEBUG_STK_FAULT 
5b70					DMARK "FAU" 
5b70					CALLMONITOR 
5b70				endif 
5b70 cd 13 0e			call cmp16 
5b73 ca 7c 5b			jp z, .chk_fault2 
5b76 11 17 5c			ld de, sfaultru 
5b79 c3 b8 5b			jp .chk_fault 
5b7c			.chk_fault2:  
5b7c 2a a4 e9			ld hl, (chk_ret_ovr) 
5b7f ed 5b 97 e2		ld de,(chk_word) 
5b83				if DEBUG_STK_FAULT 
5b83					DMARK "FA1" 
5b83					CALLMONITOR 
5b83				endif 
5b83 cd 13 0e			call cmp16 
5b86 ca 8f 5b			jp z, .chk_fault3 
5b89 11 25 5c			ld de, sfaultro 
5b8c c3 b8 5b			jp .chk_fault 
5b8f			.chk_fault3:  
5b8f 2a 22 e9			ld hl, (chk_loop_ovr) 
5b92 ed 5b 97 e2		ld de,(chk_word) 
5b96				if DEBUG_STK_FAULT 
5b96					DMARK "FA2" 
5b96					CALLMONITOR 
5b96				endif 
5b96 cd 13 0e			call cmp16 
5b99 ca a2 5b			jp z, .chk_fault4 
5b9c 11 3f 5c			ld de, sfaultlo 
5b9f c3 b8 5b			jp .chk_fault 
5ba2			.chk_fault4:  
5ba2 2a 20 e8			ld hl, (chk_data_ovr) 
5ba5 ed 5b 97 e2		ld de,(chk_word) 
5ba9				if DEBUG_STK_FAULT 
5ba9					DMARK "FA3" 
5ba9					CALLMONITOR 
5ba9				endif 
5ba9 cd 13 0e			call cmp16 
5bac ca b5 5b			jp z, .chk_fault5 
5baf 11 59 5c			ld de, sfaultdo 
5bb2 c3 b8 5b			jp .chk_fault 
5bb5			 
5bb5			 
5bb5			.chk_fault5:  
5bb5 d1				pop de 
5bb6 e1				pop hl 
5bb7			 
5bb7 c9				ret 
5bb8			 
5bb8 cd c8 0b		.chk_fault: 	call clear_display 
5bbb 3e 28				ld a, display_row_2 
5bbd cd db 0b				call str_at_display 
5bc0 11 e9 5b				   ld de, .stackfault 
5bc3 3e 00				ld a, display_row_1 
5bc5 cd db 0b				call str_at_display 
5bc8 11 65 ee				    ld de, debug_mark 
5bcb 3e 11				ld a, display_row_1+17 
5bcd cd db 0b				call str_at_display 
5bd0 cd eb 0b				call update_display 
5bd3			 
5bd3				; prompt before entering montior for investigating issue 
5bd3			 
5bd3 3e 78			ld a, display_row_4 
5bd5 11 6e 18			ld de, endprog 
5bd8			 
5bd8 cd eb 0b			call update_display		 
5bdb			 
5bdb cd 08 1b			call next_page_prompt 
5bde			 
5bde d1				pop de 
5bdf e1				pop hl 
5be0 cd c2 18				call monitor 
5be3 cd 27 1f				call forth_warmstart 
5be6 c3 be 17				jp warmstart_afterauto 
5be9					;jp 0 
5be9					;halt 
5be9			 
5be9			 
5be9			 
5be9 .. 00		.stackfault: 	db "Stack fault:",0 
5bf6			 
5bf6 .. 00		sfaultsu: 	db	"Stack under flow",0 
5c07 .. 00		sfaultso: 	db	"Stack over flow",0 
5c17 .. 00		sfaultru:	db "RTS underflow",0 
5c25 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5c3f .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5c59 .. 00		sfaultdo:	db "DTS overflow", 0 
5c66			 
5c66			 
5c66			fault_dsp_under: 
5c66 11 78 5c			ld de, .dsp_under 
5c69 c3 2e 5d			jp .show_fault 
5c6c			 
5c6c			fault_rsp_under: 
5c6c 11 86 5c			ld de, .rsp_under 
5c6f c3 2e 5d			jp .show_fault 
5c72			fault_loop_under: 
5c72 11 94 5c			ld de, .loop_under 
5c75 c3 2e 5d			jp .show_fault 
5c78			 
5c78 .. 00		.dsp_under: db "DSP Underflow",0 
5c86 .. 00		.rsp_under: db "RSP Underflow",0 
5c94 .. 00		.loop_under: db "LOOP Underflow",0 
5ca3			 
5ca3			 
5ca3 d5			type_faultn: 	push de 
5ca4 e5					push hl 
5ca5 cd c8 0b				call clear_display 
5ca8 11 d2 5c				   ld de, .typefaultn 
5cab 3e 00				ld a, display_row_1 
5cad cd db 0b				call str_at_display 
5cb0 11 65 ee				    ld de, debug_mark 
5cb3 3e 11				ld a, display_row_1+17 
5cb5 cd db 0b				call str_at_display 
5cb8 cd eb 0b				call update_display 
5cbb			 
5cbb				; prompt before entering montior for investigating issue 
5cbb			 
5cbb 3e 78			ld a, display_row_4 
5cbd 11 6e 18			ld de, endprog 
5cc0			 
5cc0 cd eb 0b			call update_display		 
5cc3			 
5cc3 cd 08 1b			call next_page_prompt 
5cc6			 
5cc6 e5					push hl 
5cc7 d5					push de 
5cc8 cd c2 18				call monitor 
5ccb cd 27 1f				call forth_warmstart 
5cce c3 be 17				jp warmstart_afterauto 
5cd1 76					halt 
5cd2			 
5cd2			 
5cd2 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5ce9			 
5ce9 d5			type_faults: 	push de 
5cea e5					push hl 
5ceb cd c8 0b				call clear_display 
5cee 11 17 5d				   ld de, .typefaults 
5cf1 3e 00				ld a, display_row_1 
5cf3 cd db 0b				call str_at_display 
5cf6 11 65 ee				    ld de, debug_mark 
5cf9 3e 11				ld a, display_row_1+17 
5cfb cd db 0b				call str_at_display 
5cfe cd eb 0b				call update_display 
5d01			 
5d01				; prompt before entering montior for investigating issue 
5d01			 
5d01 3e 78			ld a, display_row_4 
5d03 11 6e 18			ld de, endprog 
5d06			 
5d06 cd eb 0b			call update_display		 
5d09			 
5d09 cd 08 1b			call next_page_prompt 
5d0c			 
5d0c e1					pop hl 
5d0d d1					pop de 
5d0e cd c2 18				call monitor 
5d11 cd 27 1f				call forth_warmstart 
5d14 c3 be 17				jp warmstart_afterauto 
5d17			 
5d17			 
5d17 .. 00		.typefaults: db "STR Type Expected TOS!",0 
5d2e			 
5d2e			.show_fault: 	 
5d2e d5					push de 
5d2f cd c8 0b				call clear_display 
5d32 d1					pop de 
5d33 3e 00				ld a, display_row_1 
5d35 cd db 0b				call str_at_display 
5d38 11 65 ee				    ld de, debug_mark 
5d3b 3e 11				ld a, display_row_1+17 
5d3d cd db 0b				call str_at_display 
5d40 cd eb 0b				call update_display 
5d43			 
5d43				; prompt before entering montior for investigating issue 
5d43			 
5d43 3e 78			ld a, display_row_4 
5d45 11 6e 18			ld de, endprog 
5d48			 
5d48 cd eb 0b			call update_display		 
5d4b			 
5d4b cd 08 1b			call next_page_prompt 
5d4e			 
5d4e e1					pop hl 
5d4f d1					pop de 
5d50 cd c2 18				call monitor 
5d53			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5d53			; TODO Make optional fault restart to cli or warm boot? 
5d53					;jp warmstart 
5d53 c3 02 18				jp cli 
5d56 76					halt 
5d57			 
5d57			 
5d57			; handle the auto run of code from files in storage 
5d57			 
5d57			 
5d57			include "forth_startup.asm" 
5d57			; Which startup method to use? 
5d57			; 
5d57			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
5d57			; followed by loading of a list of scripts in eeprom 
5d57			 
5d57			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
5d57			; from eeprom 
5d57			 
5d57			; Select with define in main stubs 
5d57			 
5d57			if STARTUP_V1 
5d57				include "forth_startupv1.asm" 
5d57			; Startup script loading version 1 
5d57			 
5d57			; If SE storage is available first stage is to use the selected file 
5d57			; then go through the eeprom list 
5d57			 
5d57 .. 00		sprompt1: db "Startup load...",0 
5d67 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5d7d			 
5d7d			 
5d7d			 
5d7d			 
5d7d			forth_startup: 
5d7d 21 c1 4e			ld hl, startcmds 
5d80 3e 00			ld a, 0 
5d82 32 e1 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5d85			 
5d85 e5			.start1:	push hl 
5d86 cd c8 0b			call clear_display 
5d89 11 57 5d			ld de, sprompt1 
5d8c 3e 00		        ld a, display_row_1 
5d8e cd db 0b			call str_at_display 
5d91 11 67 5d			ld de, sprompt2 
5d94 3e 28		        ld a, display_row_2 
5d96 cd db 0b			call str_at_display 
5d99 e1				pop hl 
5d9a e5				push hl 
5d9b 5e				ld e,(hl) 
5d9c 23				inc hl 
5d9d 56				ld d,(hl) 
5d9e 3e 50		        ld a, display_row_3 
5da0 cd db 0b			call str_at_display 
5da3 cd eb 0b			call update_display 
5da6			 
5da6			 
5da6 3a e1 e6			ld a, (os_last_cmd) 
5da9 fe 00			cp 0 
5dab 28 05			jr z, .startprompt 
5dad cd f4 0a			call delay250ms 
5db0 18 24			jr .startdo 
5db2				 
5db2				 
5db2			 
5db2			.startprompt: 
5db2			 
5db2 3e 9f			ld a,display_row_4 + display_cols - 1 
5db4 11 06 1b		        ld de, endprg 
5db7 cd db 0b			call str_at_display 
5dba cd eb 0b			call update_display 
5dbd cd 00 0b			call delay1s 
5dc0 cd 2f 5f			call cin_wait 
5dc3						 
5dc3 fe 2a			cp '*' 
5dc5 28 5e			jr z, .startupend1 
5dc7 fe 23			cp '#' 
5dc9 20 07			jr nz, .startno 
5dcb 3e 01			ld a, 1 
5dcd 32 e1 e6			ld (os_last_cmd),a 
5dd0 18 04			jr .startdo 
5dd2 fe 31		.startno:	cp '1' 
5dd4 28 3a			jr z,.startnxt  
5dd6			 
5dd6				; exec startup line 
5dd6			.startdo:	 
5dd6 e1				pop hl 
5dd7 e5				push hl 
5dd8				 
5dd8 5e				ld e,(hl) 
5dd9 23				inc hl 
5dda 56				ld d,(hl) 
5ddb eb				ex de,hl 
5ddc			 
5ddc e5				push hl 
5ddd			 
5ddd 3e 00			ld a, 0 
5ddf				;ld a, FORTH_END_BUFFER 
5ddf cd 66 11			call strlent 
5de2 23				inc hl   ; include zero term to copy 
5de3 06 00			ld b,0 
5de5 4d				ld c,l 
5de6 e1				pop hl 
5de7 11 bb e2			ld de, scratch 
5dea ed b0			ldir 
5dec			 
5dec			 
5dec 21 bb e2			ld hl, scratch 
5def cd cf 1f			call forthparse 
5df2 cd 0f 20			call forthexec 
5df5 cd 21 1f			call forthexec_cleanup 
5df8			 
5df8 3e 78			ld a, display_row_4 
5dfa 11 6e 18			ld de, endprog 
5dfd			 
5dfd cd eb 0b			call update_display		 
5e00			 
5e00 3a e1 e6			ld a, (os_last_cmd) 
5e03 fe 00			cp 0 
5e05 20 09			jr nz, .startnxt 
5e07 cd 08 1b			call next_page_prompt 
5e0a cd c8 0b		        call clear_display 
5e0d cd eb 0b			call update_display		 
5e10			 
5e10				; move onto next startup line? 
5e10			.startnxt: 
5e10			 
5e10 cd f4 0a			call delay250ms 
5e13 e1				pop hl 
5e14			 
5e14 23				inc hl 
5e15 23				inc hl 
5e16			 
5e16 e5				push hl 
5e17 5e				ld e, (hl) 
5e18 23				inc hl 
5e19 56				ld d, (hl) 
5e1a e1				pop hl 
5e1b				; TODO replace 0 test 
5e1b			 
5e1b eb				ex de, hl 
5e1c cd 1e 0e			call ishlzero 
5e1f			;	ld a,e 
5e1f			;	add d 
5e1f			;	cp 0    ; any left to do? 
5e1f eb				ex de, hl 
5e20 c2 85 5d			jp nz, .start1 
5e23 18 01			jr .startupend 
5e25			 
5e25 e1			.startupend1: pop hl 
5e26			.startupend: 
5e26			 
5e26 cd c8 0b			call clear_display 
5e29 cd eb 0b			call update_display 
5e2c c9				ret 
5e2d			if STORAGE_SE 
5e2d			 
5e2d			sprompt3: db "Loading from start-up file?:",0 
5e2d			sprompt4: db "(Y=Any key/N=No)",0 
5e2d			 
5e2d			 
5e2d			forth_autoload: 
5e2d			 
5e2d				; load block 0 of store 1 
5e2d				 
5e2d				ld a, $fe      ; bit 0 clear 
5e2d				ld (spi_device), a 
5e2d			 
5e2d				call storage_get_block_0 
5e2d			 
5e2d				ld a, (store_page+STORE_0_AUTOFILE) 
5e2d			 
5e2d				cp 0 
5e2d				ret z     ; auto start not enabled 
5e2d			 
5e2d				call clear_display 
5e2d			 
5e2d				; set bank 
5e2d			 
5e2d					ld a, (store_page+STORE_0_BANKRUN) 
5e2d					ld (spi_device), a 
5e2d			 
5e2d				; get file id to load from and get the file name to display 
5e2d			 
5e2d					ld a, (store_page+STORE_0_FILERUN) 
5e2d			 
5e2d					ld l, 0 
5e2d					ld h, a 
5e2d					ld de, store_page 
5e2d			 
5e2d					if DEBUG_FORTH_WORDS 
5e2d						DMARK "ASp" 
5e2d						CALLMONITOR 
5e2d					endif 
5e2d					call storage_read 
5e2d			 
5e2d					if DEBUG_FORTH_WORDS 
5e2d						DMARK "ASr" 
5e2d						CALLMONITOR 
5e2d					endif 
5e2d			 
5e2d					call ishlzero 
5e2d					ret z             ; file not found 
5e2d			 
5e2d					ld a, display_row_2 + 10 
5e2d					ld de, store_page+3 
5e2d					call str_at_display 
5e2d				 
5e2d			; 
5e2d			 
5e2d				ld a, display_row_1+5 
5e2d				ld de, sprompt3 
5e2d				call str_at_display 
5e2d				ld a, display_row_3+15 
5e2d				ld de, sprompt4 
5e2d				call str_at_display 
5e2d			 
5e2d				call update_display 
5e2d			 
5e2d				call cin_wait 
5e2d				cp 'n' 
5e2d				ret z 
5e2d				cp 'N' 
5e2d				ret z 
5e2d			 
5e2d				call delay1s 
5e2d			 
5e2d				ld a, (store_page+2) 
5e2d				ld (store_openmaxext), a    ; save count of ext 
5e2d				ld a, 1  
5e2d				ld (store_openext), a    ; save count of ext 
5e2d			 
5e2d			.autof:  
5e2d				ld l , a 
5e2d				 
5e2d				ld a, (store_page) 
5e2d				ld h, a	 
5e2d				ld de, store_page 
5e2d					if DEBUG_FORTH_WORDS 
5e2d						DMARK "ASl" 
5e2d						CALLMONITOR 
5e2d					endif 
5e2d					call storage_read 
5e2d				call ishlzero 
5e2d				ret z 
5e2d			;	jr z, .autoend 
5e2d			 
5e2d					if DEBUG_FORTH_WORDS 
5e2d						DMARK "ASc" 
5e2d						CALLMONITOR 
5e2d					endif 
5e2d				ld de, store_page+2 
5e2d				ld a, display_row_4 
5e2d				call str_at_display 
5e2d			 
5e2d				call update_display 
5e2d				call delay250ms 
5e2d			 
5e2d			 
5e2d			 
5e2d				ld hl, store_page+2 
5e2d				call forthparse 
5e2d				call forthexec 
5e2d				call forthexec_cleanup 
5e2d			 
5e2d				 
5e2d				ld a, (store_openext) 
5e2d				inc a 
5e2d				ld (store_openext), a    ; save count of ext 
5e2d			 
5e2d				jr .autof 
5e2d			;.autofdone: 
5e2d			; 
5e2d			;		if DEBUG_FORTH_WORDS 
5e2d			;			DMARK "ASx" 
5e2d			;			CALLMONITOR 
5e2d			;		endif 
5e2d			;;	call clear_display 
5e2d			;	ret 
5e2d			 
5e2d			 
5e2d			 
5e2d			endif 
# End of file forth_startupv1.asm
5e2d			endif 
5e2d			if STARTUP_V2 
5e2d				include "forth_startupv2.asm" 
5e2d			endif 
5e2d			 
# End of file forth_startup.asm
5e2d			 
5e2d			; eof 
# End of file forth_kernel.asm
5e2d			;include "nascombasic.asm" 
5e2d			 
5e2d			 
5e2d			; find out where the code ends if loaded into RAM (for SC114) 
5e2d			;endofcode:  
5e2d			;	nop 
5e2d			 
5e2d			 
5e2d			; jump to nmi vector 
5e2d			 
5e2d			init_nmi: 
5e2d 3e c9			ld a, $c9   ; RET 
5e2f 32 72 ee			ld (nmi_vector), a 
5e32 c9				ret 
5e33			nmi: 
5e33 e5				push hl 
5e34 d5				push de 
5e35 c5				push bc 
5e36 f5				push af 
5e37 cd 72 ee			call nmi_vector 
5e3a f5				push af 
5e3b c5				push bc 
5e3c d5				push de 
5e3d e5				push hl 
5e3e ed 4d			reti 
5e40			 
5e40			 
5e40			; eof 
5e40			 
# End of file main.asm
5e40			;include "firmware_lcd_4x40.asm" 
5e40			;;include "firmware_lcd_4x20.asm" 
5e40			include "firmware_cpm_display.asm" 
5e40			 
5e40			; Serial display interface for SC114 
5e40			 
5e40			 
5e40			display_row_1: equ 0 
5e40			display_row_2: equ display_row_1+display_cols 
5e40			display_row_3: equ display_row_2 + display_cols 
5e40			display_row_4: equ display_row_3 + display_cols 
5e40			 
5e40			kLCDWidth:  EQU display_cols             ;Width in characters 
5e40			kLCD_Line1: EQU 0x00  
5e40			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5e40			; E1 
5e40			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5e40			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5e40			 
5e40			lcd_init: 
5e40				; no init as handled by the SCM bios 
5e40 c9				ret 
5e41			 
5e41			 
5e41			; low level functions for direct screen writes 
5e41			 
5e41			; output char at pos? 
5e41			fLCD_Str: 
5e41			        ;out (SC114_SIO_1_OUT),a 
5e41 c5				push bc 
5e42 d5				push de 
5e43 5f				ld e, a 
5e44			; TODO Replace with CP/M BIOS call 
5e44 0e 02			ld c, $02 
5e46 cd 05 00			call 5 
5e49 d1				pop de 
5e4a c1				pop bc 
5e4b c9				ret 
5e4c			 
5e4c			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5e4c			fLCD_Pos: 
5e4c				; use ASCII escape to position 
5e4c			        ;out (SC114_SIO_1_OUT),a 
5e4c c5				push bc 
5e4d d5				push de 
5e4e 5f				ld e, a 
5e4f 0e 02			ld c, $02 
5e51			; TODO Replace with CP/M BIOS call 
5e51 cd 05 00			call 5 
5e54 d1				pop de 
5e55 c1				pop bc 
5e56			 
5e56 c9				ret 
5e57			 
5e57			; output char at pos 
5e57			fLCD_Data: 
5e57			      ;  out (SC114_SIO_1_OUT),a 
5e57 c5				push bc 
5e58 d5				push de 
5e59 0e 02			ld c, $02 
5e5b 5f				ld e, a 
5e5c			; TODO Replace with CP/M BIOS call 
5e5c cd 05 00			call 5 
5e5f d1				pop de 
5e60 c1				pop bc 
5e61			 
5e61 c9				ret 
5e62			 
5e62			; ascii cls  
5e62			 
5e62 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5e66			 
5e66 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5e7d			;.clscpm: db 3, $3c,"$" 
5e7d			 
5e7d			; write the frame buffer given in hl to hardware  
5e7d			write_display: 
5e7d			 
5e7d			API: equ 0 
5e7d			 
5e7d			if API 
5e7d				push bc 
5e7d				ld b, 4 
5e7d			 
5e7d			        ld (display_write_tmp), hl 	  
5e7d			 
5e7d				; clear and home cursor 
5e7d			 
5e7d				ld c, 9 
5e7d				ld de, .cls 
5e7d			; TODO Replace with CP/M BIOS call 
5e7d				call 5 
5e7d			 
5e7d			 
5e7d			.writeln: 
5e7d			 
5e7d				ld de, (display_write_tmp) 
5e7d				ld c, 6 
5e7d			; TODO Replace with CP/M BIOS call 
5e7d				rst $30 
5e7d				ld c, 7 
5e7d				rst $30 
5e7d			 
5e7d				ld hl, (display_write_tmp) 
5e7d				ld de, display_cols 
5e7d				add hl,de 
5e7d				ld (display_write_tmp),hl 
5e7d			 
5e7d				djnz  .writeln 
5e7d			 
5e7d				pop bc 
5e7d			 
5e7d			 
5e7d				ret 
5e7d			endif 
5e7d e5				push hl 
5e7e c5				push bc 
5e7f d5				push de 
5e80			 
5e80			;	ld c, 2 
5e80			;	;ld de, .cls 
5e80			;	ld a, 27 
5e80			;	rst $30 
5e80			;	ld c, 2 
5e80			;	;ld de, .cls 
5e80			;	ld a, '[' 
5e80			;	rst $30 
5e80			; 
5e80			;	ld c, 2 
5e80			;	;ld de, .cls 
5e80			;	ld a, 'H' 
5e80			;	rst $30 
5e80			; 
5e80			 
5e80			 
5e80			; lots of CR/LF 
5e80			;	ld c, 9 
5e80			;	ld de, .clscpm 
5e80			;	call 5 
5e80			 
5e80			; xterm cls 
5e80 0e 02			ld c, 2 
5e82 1e 1b			ld e, 27 
5e84 cd 05 00			call 5 
5e87			; cls causes too much flicker 
5e87			;	ld c, 2 
5e87			;	ld e, 'c' 
5e87			;	call 5 
5e87			 
5e87			; use xterm home instead 
5e87 0e 02			ld c, 2 
5e89 1e 5b			ld e, '[' 
5e8b cd 05 00			call 5 
5e8e 0e 02			ld c, 2 
5e90 1e 48			ld e, 'H' 
5e92 cd 05 00			call 5 
5e95			LLL: equ 0 
5e95			 
5e95			if LLL 
5e95			 
5e95				ld c, 2 
5e95				;ld de, .cls 
5e95				ld e, 27 
5e95			; TODO Replace with CP/M BIOS call 
5e95				call 5 
5e95			 
5e95			 
5e95				ld c, 2 
5e95				;ld de, .cls 
5e95				ld e, '[' 
5e95			; TODO Replace with CP/M BIOS call 
5e95				call 5 
5e95				ld c, 2 
5e95				;ld de, .cls 
5e95				ld e, '2' 
5e95			; TODO Replace with CP/M BIOS call 
5e95				call 5 
5e95				ld c, 2 
5e95				;ld de, .cls 
5e95				ld e, 'J' 
5e95			; TODO Replace with CP/M BIOS call 
5e95				call 5 
5e95			 
5e95			endif 
5e95			 
5e95 d1				pop de 
5e96 c1				pop bc 
5e97 e1				pop hl 
5e98			 
5e98			 
5e98 22 c3 eb		        ld (display_write_tmp), hl 	  
5e9b 3e 00			ld a, kLCD_Line1 
5e9d			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5e9d 06 28			ld b, display_cols 
5e9f ed 5b c3 eb		ld de, (display_write_tmp) 
5ea3 cd 26 5f			call write_len_string 
5ea6				 
5ea6			 
5ea6 e5			push hl 
5ea7 d5			push de 
5ea8 c5			push bc 
5ea9 0e 02			ld c, 2 
5eab 1e 0a			ld e, 10 
5ead cd 05 00			call 5 
5eb0 0e 02			ld c, 2 
5eb2 1e 0d			ld e, 13 
5eb4 cd 05 00			call 5 
5eb7			; TODO Replace with CP/M BIOS call 
5eb7				;rst $30 
5eb7 c1			pop bc 
5eb8 d1			pop de 
5eb9 e1			pop hl 
5eba			 
5eba				 
5eba 2a c3 eb			ld hl, (display_write_tmp) 
5ebd 11 28 00			ld de, display_cols 
5ec0 19				add hl,de 
5ec1 22 c3 eb			ld (display_write_tmp),hl 
5ec4			 
5ec4				 
5ec4 3e 28			ld a, kLCD_Line2 
5ec6			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5ec6 06 28			ld b, display_cols 
5ec8 ed 5b c3 eb		ld de, (display_write_tmp) 
5ecc cd 26 5f			call write_len_string 
5ecf				 
5ecf 2a c3 eb			ld hl, (display_write_tmp) 
5ed2 11 28 00			ld de, display_cols 
5ed5 19				add hl,de 
5ed6 22 c3 eb			ld (display_write_tmp),hl 
5ed9			 
5ed9 e5			push hl 
5eda d5			push de 
5edb c5			push bc 
5edc 0e 07			ld c, 7 
5ede			; TODO Replace with CP/M BIOS call 
5ede				;rst $30 
5ede 0e 02			ld c, 2 
5ee0 1e 0a			ld e, 10 
5ee2 cd 05 00			call 5 
5ee5 0e 02			ld c, 2 
5ee7 1e 0d			ld e, 13 
5ee9 cd 05 00			call 5 
5eec c1			pop bc 
5eed d1			pop de 
5eee e1			pop hl 
5eef			 
5eef				 
5eef 3e 50			ld a, kLCD_Line3 
5ef1			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5ef1 06 28			ld b, display_cols 
5ef3 ed 5b c3 eb		ld de, (display_write_tmp) 
5ef7 cd 26 5f			call write_len_string 
5efa				 
5efa 2a c3 eb			ld hl, (display_write_tmp) 
5efd 11 28 00			ld de, display_cols 
5f00 19				add hl,de 
5f01 22 c3 eb			ld (display_write_tmp),hl 
5f04			 
5f04 e5			push hl 
5f05 d5			push de 
5f06 c5			push bc 
5f07 0e 07			ld c, 7 
5f09			; TODO Replace with CP/M BIOS call 
5f09				;rst $30 
5f09 0e 02			ld c, 2 
5f0b 1e 0a			ld e, 10 
5f0d cd 05 00			call 5 
5f10 0e 02			ld c, 2 
5f12 1e 0d			ld e, 13 
5f14 cd 05 00			call 5 
5f17 c1			pop bc 
5f18 d1			pop de 
5f19 e1			pop hl 
5f1a			 
5f1a				 
5f1a 3e 78			ld a, kLCD_Line4 
5f1c			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5f1c 06 28			ld b, display_cols 
5f1e ed 5b c3 eb		ld de, (display_write_tmp) 
5f22 cd 26 5f			call write_len_string 
5f25 c9					ret 
5f26			 
5f26			 
5f26				; write out a fixed length string given in b from de 
5f26			 
5f26 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5f27 cd 57 5e		            CALL fLCD_Data      ;Write character to display 
5f2a 13				inc de 
5f2b 10 f9			djnz write_len_string 
5f2d c9				ret 
5f2e			 
5f2e			 
5f2e			; eof 
# End of file firmware_cpm_display.asm
5f2e			;include "firmware_key_5x10.asm" 
5f2e			;;include "firmware_key_4x10.asm" 
5f2e			include "firmware_key_cpm.asm" 
5f2e			; Serial keyboard interface for SC114 
5f2e			 
5f2e			 
5f2e			key_init: 
5f2e				; no init as handled by the SCM bios 
5f2e c9				ret 
5f2f			 
5f2f			 
5f2f			cin_wait: 
5f2f			;	ld a, 0 
5f2f			;	ret 
5f2f			 
5f2f				;in a,(SC114_SIO_1_IN) 
5f2f			        ; Use SCM API to get from whatever console device we are using 
5f2f			 
5f2f			; TODO Replace with CP/M BIOS call 
5f2f c5				push bc 
5f30 0e 01			ld c, $01 
5f32 cd 05 00			call 5 
5f35 c1				pop bc 
5f36 c9				ret 
5f37			 
5f37			cin: 
5f37			 
5f37			 
5f37 c5				push bc 
5f38			 
5f38				; any key waiting to process? 
5f38			; TODO Replace with CP/M BIOS call 
5f38 0e 06			ld c, $06 
5f3a cd 05 00			call 5 
5f3d 28 0d			jr z, .cin_skip 
5f3f			 
5f3f				; yep, get it 
5f3f			 
5f3f 0e 01			ld c, $01 
5f41			; TODO Replace with CP/M BIOS call 
5f41 cd 05 00			call 5 
5f44			 
5f44 fe 7f			cp $7f     ; back space 
5f46 20 02			jr nz, .skipbs 
5f48 3e 08			ld a, KEY_BS 
5f4a			.skipbs: 
5f4a			 
5f4a c1				pop bc 
5f4b c9				ret 
5f4c			.cin_skip: 
5f4c 3e 00			ld a, 0 
5f4e c1				pop bc 
5f4f c9				ret 
5f50			 
5f50			 
5f50			 
5f50			 
# End of file firmware_key_cpm.asm
5f50			endofcode:  
5f50			baseram:  
5f50 00				nop 
5f51			 
5f51			heap_start: equ baseram+15  ; Starting address of heap 
5f51			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5f51			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5f51			;VDU:  EQU     endofcode           ; BASIC Work space 
5f51			; eof 
5f51			 
# End of file os_mega_cpm.asm
5f51
