# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 9b 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd 18 0d				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd 18 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd 18 0d				call clear_display  
0037			  
0037			  
0037 cd 37 74				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd ce 76			call key_init  
003d cd fe 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd ef 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd ac 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd 3b 0d			call update_display  
0049 cd 95 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd 1d 0d			call fill_display  
0051 cd 3b 0d			call update_display  
0054 cd 95 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd 1d 0d			call fill_display  
005c cd 3b 0d			call update_display  
005f cd 95 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd 1d 0d			call fill_display  
0067 cd 3b 0d			call update_display  
006a cd 95 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 74 1b			ld de, prom_bootmsg  
0072 cd 2b 0d			call str_at_display  
0075 cd 3b 0d			call update_display  
0078			  
0078			  
0078 cd 95 0c			call delay1s  
007b cd 95 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 89 1b			ld de, prom_bootmsg1  
0083 cd 2b 0d			call str_at_display  
0086 cd 3b 0d			call update_display  
0089 cd 95 0c			call delay1s  
008c cd 95 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			;  Perform SCLK wait pulse 
00a0			 
00a0			spi_clk: 
00a0 f5				push af 
00a1 3a 6b fa			ld a, (spi_clktime) 
00a4 fe 00			cp 0 
00a6 28 03			jr z, .scskip 
00a8 cd 7a 0c			call aDelayInMS 
00ab			.scskip: 
00ab f1				pop af 
00ac c9				ret 
00ad			 
00ad			 
00ad			 
00ad			; TODO store port id for spi device ie dev c 
00ad			; TODO store pin for SO 
00ad			; TODO store pin for SI 
00ad			; TODO store pin for SCLK 
00ad			 
00ad			; 
00ad			 
00ad			; ensure that spi bus is in a stable state with default pins  
00ad			 
00ad			se_stable_spi:   
00ad			 
00ad				 ; set DI high, CE high , SCLK low 
00ad				;ld a, SPI_DI | SPI_CE0 
00ad 3e 07			ld a, SPI_DI  
00af cd b9 01			call spi_ce_high 
00b2 d3 80			 out (storage_adata),a 
00b4 32 68 fa			ld (spi_portbyte),a 
00b7			 
00b7				if DEBUG_SPI 
00b7					push hl 
00b7					ld l, a 
00b7					DMARK "SPI" 
00b7					CALLMONITOR 
00b7					pop hl 
00b7				endif 
00b7 c9				ret 
00b8			 
00b8			; byte to send in a 
00b8			 
00b8			spi_send_byte: 
00b8				; save byte to send for bit mask shift out 
00b8 4f			        ld c,a 
00b9 3a 68 fa			ld a,(spi_portbyte) 
00bc				  
00bc				; clock out	each bit of the byte msb first 
00bc			 
00bc 06 08			ld b, 8 
00be			.ssb1: 
00be				; clear so bit  
00be cb bf			res SPI_DI, a 
00c0 cb 11			rl c 
00c2				; if bit 7 is set then carry is set 
00c2 30 02			jr nc, .ssb2 
00c4 cb ff			set SPI_DI,a 
00c6			.ssb2:  ; output bit to ensure it is stable 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce cd a0 00			call spi_clk 
00d1				; then low 
00d1 cb af			res SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6 cd a0 00			call spi_clk 
00d9 10 e3			djnz .ssb1 
00db			 
00db 32 68 fa			ld (spi_portbyte),a 
00de c9				ret 
00df			 
00df			; TODO low level get byte into A on spi 
00df			 
00df			spi_read_byte:  
00df			 
00df				; save byte to send for bit mask shift out 
00df 0e 00		    ld c,0 
00e1 3a 68 fa			ld a,(spi_portbyte) 
00e4				  
00e4				; clock out	each bit of the byte msb first 
00e4			 
00e4			 
00e4				; clock bit high 
00e4 cb ef			set SPI_SCLK,a 
00e6 d3 80			out (storage_adata),a 
00e8 00				nop 
00e9 cd a0 00			call spi_clk 
00ec			 
00ec			    ; read DO  
00ec			 
00ec cb f9		    set 7,c 
00ee db 80			in a,(storage_adata) 
00f0 cb 77		    bit SPI_DO,a 
00f2 20 02		    jr nz, .b7 
00f4 cb b9		    res 7,c 
00f6			.b7: 
00f6				; then low 
00f6 cb af			res SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb cd a0 00			call spi_clk 
00fe			     
00fe			 
00fe				; clock bit high 
00fe cb ef			set SPI_SCLK,a 
0100 d3 80			out (storage_adata),a 
0102 00				nop 
0103 cd a0 00			call spi_clk 
0106			 
0106			    ; read DO  
0106			 
0106 cb f1		    set 6,c 
0108 db 80			in a,(storage_adata) 
010a cb 77		    bit SPI_DO,a 
010c 20 02		    jr nz, .b6 
010e cb b1		    res 6,c 
0110			.b6: 
0110				; then low 
0110 cb af			res SPI_SCLK,a 
0112 d3 80			out (storage_adata),a 
0114 00				nop 
0115 cd a0 00			call spi_clk 
0118			 
0118				; clock bit high 
0118 cb ef			set SPI_SCLK,a 
011a d3 80			out (storage_adata),a 
011c 00				nop 
011d cd a0 00			call spi_clk 
0120			 
0120			 
0120			    ; read DO  
0120			 
0120 cb e9		    set 5,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b5 
0128 cb a9		    res 5,c 
012a			.b5: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f cd a0 00			call spi_clk 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137 cd a0 00			call spi_clk 
013a			 
013a			    ; read DO  
013a			 
013a cb e1		    set 4,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b4 
0142 cb a1		    res 4,c 
0144			.b4: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149 cd a0 00			call spi_clk 
014c				; clock bit high 
014c cb ef			set SPI_SCLK,a 
014e d3 80			out (storage_adata),a 
0150 00				nop 
0151 cd a0 00			call spi_clk 
0154			 
0154			    ; read DO  
0154			 
0154 cb d9		    set 3,c 
0156 db 80			in a,(storage_adata) 
0158 cb 77		    bit SPI_DO,a 
015a 20 02		    jr nz, .b3 
015c cb 99		    res 3,c 
015e			.b3: 
015e				; then low 
015e cb af			res SPI_SCLK,a 
0160 d3 80			out (storage_adata),a 
0162 00				nop 
0163 cd a0 00			call spi_clk 
0166				; clock bit high 
0166 cb ef			set SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b cd a0 00			call spi_clk 
016e			 
016e			    ; read DO  
016e			 
016e cb d1		    set 2,c 
0170 db 80			in a,(storage_adata) 
0172 cb 77		    bit SPI_DO,a 
0174 20 02		    jr nz, .b2 
0176 cb 91		    res 2,c 
0178			.b2: 
0178				; then low 
0178 cb af			res SPI_SCLK,a 
017a d3 80			out (storage_adata),a 
017c 00				nop 
017d cd a0 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184 00				nop 
0185 cd a0 00			call spi_clk 
0188			 
0188			    ; read DO  
0188			 
0188 cb c9		    set 1,c 
018a db 80			in a,(storage_adata) 
018c cb 77		    bit SPI_DO,a 
018e 20 02		    jr nz, .b1 
0190 cb 89		    res 1,c 
0192			.b1: 
0192				; then low 
0192 cb af			res SPI_SCLK,a 
0194 d3 80			out (storage_adata),a 
0196 00				nop 
0197 cd a0 00			call spi_clk 
019a				; clock bit high 
019a cb ef			set SPI_SCLK,a 
019c d3 80			out (storage_adata),a 
019e 00				nop 
019f cd a0 00			call spi_clk 
01a2			 
01a2			    ; read DO  
01a2			 
01a2 cb c1		    set 0,c 
01a4 db 80			in a,(storage_adata) 
01a6 cb 77		    bit SPI_DO,a 
01a8 20 02		    jr nz, .b0 
01aa cb 81		    res 0,c 
01ac			.b0: 
01ac				; then low 
01ac cb af			res SPI_SCLK,a 
01ae d3 80			out (storage_adata),a 
01b0 00				nop 
01b1 cd a0 00			call spi_clk 
01b4			 
01b4			 
01b4 32 68 fa			ld (spi_portbyte),a 
01b7			 
01b7			    ; return byte 
01b7 79			    ld a,c 
01b8			 
01b8			 
01b8 c9				ret 
01b9			 
01b9			 
01b9			 
01b9			spi_ce_high: 
01b9			 
01b9				if DEBUG_SPI_HARD_CE0 
01b9			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b9					ret 
01b9			 
01b9				endif 
01b9			 
01b9			 
01b9 f5				push af 
01ba			 
01ba				; send direct ce to port b 
01ba 3e ff			ld a, 255 
01bc d3 81			out (storage_bdata), a 
01be			 
01be f1				pop af 
01bf			 
01bf				; for port a that shares with spi lines AND the mask 
01bf			  
01bf				if DEBUG_SPI 
01bf					push hl 
01bf					ld h, a 
01bf				endif 
01bf			;	ld c, SPI_CE_HIGH 
01bf			;	and c 
01bf cb c7			set SPI_CE0, a 
01c1 cb cf			set SPI_CE1, a 
01c3 cb d7			set SPI_CE2, a 
01c5 cb df			set SPI_CE3, a 
01c7 cb e7			set SPI_CE4, a 
01c9			 
01c9				if DEBUG_SPI 
01c9					ld l, a 
01c9					DMARK "CEh" 
01c9					CALLMONITOR 
01c9					pop hl 
01c9				endif 
01c9 c9				ret 
01ca			 
01ca			 
01ca			spi_ce_low: 
01ca			 
01ca				if DEBUG_SPI_HARD_CE0 
01ca			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ca					ret 
01ca			 
01ca				endif 
01ca			 
01ca c5				push bc 
01cb f5				push af 
01cc			 
01cc				; send direct ce to port b 
01cc 3a 6a fa			ld a, (spi_cartdev) 
01cf d3 81			out (storage_bdata), a 
01d1			 
01d1			 
01d1			 
01d1				; for port a that shares with spi lines AND the mask 
01d1			 
01d1 3a 67 fa			ld a, (spi_device)  
01d4 4f				ld c, a 
01d5			 
01d5 f1				pop af 
01d6			 
01d6				; detect CEx 
01d6			 
01d6				if DEBUG_SPI 
01d6					push hl 
01d6					ld h, a 
01d6				endif 
01d6			 
01d6 cb 41			bit SPI_CE0, c 
01d8 20 04			jr nz, .cel1 
01da cb 87			res SPI_CE0, a 
01dc 18 1e			jr .celn 
01de			.cel1: 
01de cb 49			bit SPI_CE1, c 
01e0 20 04			jr nz, .cel2 
01e2 cb 8f			res SPI_CE1, a 
01e4 18 16			jr .celn 
01e6			.cel2: 
01e6 cb 51			bit SPI_CE2, c 
01e8 20 04			jr nz, .cel3 
01ea cb 97			res SPI_CE2, a 
01ec 18 0e			jr .celn 
01ee			.cel3: 
01ee cb 59			bit SPI_CE3, c 
01f0 20 04			jr nz, .cel4 
01f2 cb 9f			res SPI_CE3, a 
01f4 18 06			jr .celn 
01f6			.cel4: 
01f6 cb 61			bit SPI_CE4, c 
01f8 20 02			jr nz, .celn 
01fa cb a7			res SPI_CE4, a 
01fc			.celn: 
01fc			 
01fc			 
01fc			 
01fc			;	add c 
01fc			 
01fc				if DEBUG_SPI 
01fc					ld l, a 
01fc					DMARK "CEl" 
01fc					CALLMONITOR 
01fc					pop hl 
01fc				endif 
01fc c1				pop bc 
01fd c9				ret 
01fe			 
01fe			 
01fe			 
01fe			; eof 
01fe			 
01fe			 
01fe			 
01fe			 
01fe			 
# End of file firmware_spi.asm
01fe				include "firmware_seeprom.asm"  
01fe			; 
01fe			; persisent storage interface via microchip serial eeprom 
01fe			 
01fe			; port a pio 2 
01fe			; pa 7 - si 
01fe			; pa 6 - sclk  
01fe			; pa 5 - so 
01fe			; pa 4 - cs 
01fe			; pa 3 - cs 
01fe			; pa 2 - cs 
01fe			; pa 1 - cs 
01fe			; pa 0 - cs 
01fe			; 
01fe			; TODO get block 
01fe			; TODO save block 
01fe			; TODO load file 
01fe			; TODO save file 
01fe			; TODO get dir  
01fe			 
01fe			;  
01fe			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fe			storage_actl: equ Device_C+2     ; device c port a 
01fe			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fe			storage_bctl: equ Device_C+3     ; device c port b 
01fe			 
01fe			 
01fe			; TODO move these to hardware driver file 
01fe			 
01fe			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fe			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fe			; storage bank file system format 
01fe			; 
01fe			; first page of bank: 
01fe			; 	addr 0 - status check 
01fe			;       addr 1 - write protect flag 
01fe			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fe			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fe			;         TODO see if scanning whole of for available next file id is fast enough 
01fe			;	addr 4 > zero term string of bank label 
01fe			; 
01fe			;        
01fe			;  
01fe			; first page of any file: 
01fe			;      byte 0 - file id  
01fe			;      byte 1-17 - fixed file name  
01fe			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fe			; 
01fe			; other pages of any file: 
01fe			;      byte 0 - file id 
01fe			;      byte 1> - file data 
01fe			; 
01fe			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fe			;  
01fe			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fe			 
01fe			 
01fe			;storage_so_bit: 5 
01fe			;storage_si_bit: 7 
01fe			;storage_sclk_bit: 6 
01fe			  
01fe			 
01fe			; init storage pio 
01fe			 
01fe			storage_init: 
01fe			 
01fe			 
01fe					; set default SPI clk pulse time as disabled 
01fe			 
01fe 3e 00				ld a, 0 
0200 32 6b fa				ld (spi_clktime), a 
0203			 
0203					; init hardware 
0203			 
0203 3e cf		            LD   A, 11001111b 
0205 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0207 3e 00		            LD   A, 00000000b 
0209 cb f7			set SPI_DO,a 
020b			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
020b d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020d			 
020d 3e cf		            LD   A, 11001111b 
020f d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0211 3e 00		            LD   A, 00000000b 
0213 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0215			 
0215				; set all external spi devices off  
0215 3e ff			ld a, 255 
0217 32 67 fa			ld (spi_device), a 
021a 32 6a fa			ld (spi_cartdev), a 
021d			 
021d					; ensure the spi bus is in a default stable state 
021d cd ad 00				call se_stable_spi 
0220			 
0220			; TODO scan spi bus and gather which storage banks are present 
0220			 
0220			; populate store_bank_active  
0220			; for each ce line activate and attempt to write first byte of bank and read back 
0220			; if zero is returned then bank is empty 
0220			;   
0220			; 
0220			 
0220					; init file extent cache to save on slow reads 
0220			 
0220			;	ld hl, store_filecache 
0220			;	ld de, 0 
0220			;	ld hl,(de)	 
0220			 
0220			 
0220 c9			    ret 
0221			 
0221			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0221			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0221			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0221			 
0221			; INSTRUCTION SET 
0221			; READ 0000 0011 Read data from memory array beginning at selected address 
0221			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0221			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0221			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0221			; RDSR 0000 0101 Read STATUS register 
0221			; WRSR 0000 0001 Write STATUS register 
0221			; PE 0100 0010 Page Erase – erase one page in memory array 
0221			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0221			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0221			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0221			 
0221			; TODO send byte steam for page without setting the address for every single byte 
0221			; TODO read byte  
0221			 
0221			; byte in a 
0221			; address in hl  
0221			se_writebyte: 
0221			        
0221			    ;   ld c, a 
0221 f5			        push af 
0222 e5			        push hl 
0223			 
0223			    ; initi write mode 
0223			    ; 
0223			    ;CS low 
0223			 
0223 3a 68 fa		       ld a,(spi_portbyte) 
0226 cd ca 01			call spi_ce_low 
0229			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0229 d3 80		       out (storage_adata),a 
022b 32 68 fa		       ld (spi_portbyte), a 
022e			 
022e			    ;clock out wren instruction 
022e			 
022e 3e 06		    ld a, store_wren_ins 
0230 cd b8 00		    call spi_send_byte  
0233			 
0233			    ;cs high to enable write latch 
0233			 
0233 3a 68 fa		       ld a,(spi_portbyte) 
0236 cd b9 01			call spi_ce_high 
0239			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0239 d3 80		       out (storage_adata),a 
023b 32 68 fa		       ld (spi_portbyte), a 
023e			 
023e 00				nop 
023f			    ; 
023f			    ; intial write data 
023f			    ; 
023f			    ; cs low 
023f			     
023f 3a 68 fa		       ld a,(spi_portbyte) 
0242 cd ca 01			call spi_ce_low 
0245			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0245 d3 80		       out (storage_adata),a 
0247 32 68 fa		       ld (spi_portbyte), a 
024a			 
024a			    ; clock out write instruction 
024a			     
024a 3e 02		    ld a, store_write_ins  
024c cd b8 00		    call spi_send_byte  
024f			 
024f			    ; clock out address (depending on address size) 
024f			     
024f e1			    pop hl 
0250 7c			    ld a,h    ; address out msb first 
0251 cd b8 00		    call spi_send_byte  
0254 7d			    ld a,l 
0255 cd b8 00		    call spi_send_byte  
0258			 
0258			    ; clock out byte(s) for page 
0258			 
0258 f1			    pop af 
0259 cd b8 00		    call spi_send_byte  
025c			 
025c			    ; end write with ce high 
025c 3a 68 fa		       ld a,(spi_portbyte) 
025f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025f cd b9 01			call spi_ce_high 
0262 d3 80		       out (storage_adata),a 
0264 32 68 fa		       ld (spi_portbyte), a 
0267			 
0267				; pause for internal write cycle 
0267 3e 0a			ld a, 10 
0269 cd 7a 0c			call aDelayInMS 
026c c9			    ret 
026d			 
026d			; buffer to write in de 
026d			; address in hl  
026d			se_writepage: 
026d			        
026d			    ;   ld c, a 
026d d5				push de 
026e e5			        push hl 
026f			 
026f			    ; initi write mode 
026f			    ; 
026f			    ;CS low 
026f			 
026f 3a 68 fa		       ld a,(spi_portbyte) 
0272 cd ca 01			call spi_ce_low 
0275			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0275 d3 80		       out (storage_adata),a 
0277 32 68 fa		       ld (spi_portbyte), a 
027a			 
027a			    ;clock out wren instruction 
027a			 
027a 3e 06		    ld a, store_wren_ins 
027c cd b8 00		    call spi_send_byte  
027f			 
027f			    ;cs high to enable write latch 
027f			 
027f 3a 68 fa		       ld a,(spi_portbyte) 
0282 cd b9 01			call spi_ce_high 
0285			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 68 fa		       ld (spi_portbyte), a 
028a			 
028a 00				nop 
028b			    ; 
028b			    ; intial write data 
028b			    ; 
028b			    ; cs low 
028b			     
028b 3a 68 fa		       ld a,(spi_portbyte) 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e cd ca 01			call spi_ce_low 
0291 d3 80		       out (storage_adata),a 
0293 32 68 fa		       ld (spi_portbyte), a 
0296			 
0296			    ; clock out write instruction 
0296			     
0296 3e 02		    ld a, store_write_ins  
0298 cd b8 00		    call spi_send_byte  
029b			 
029b			    ; clock out address (depending on address size) 
029b			     
029b e1			    pop hl 
029c 7c			    ld a,h    ; address out msb first 
029d cd b8 00		    call spi_send_byte  
02a0 7d			    ld a,l 
02a1 cd b8 00		    call spi_send_byte  
02a4			 
02a4			    ; clock out byte(s) for page 
02a4			 
02a4 e1				pop hl 
02a5 06 40			ld b, STORE_BLOCK_PHY 
02a7			.bytewrite: 
02a7			 
02a7 7e				ld a,(hl) 
02a8 e5			    push hl 
02a9 c5				push bc 
02aa cd b8 00		    call spi_send_byte  
02ad c1				pop bc 
02ae e1				pop hl 
02af			 
02af			    ; end write with ce high 
02af 3a 68 fa		       ld a,(spi_portbyte) 
02b2 cd b9 01			call spi_ce_high 
02b5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b5 d3 80		       out (storage_adata),a 
02b7 32 68 fa		       ld (spi_portbyte), a 
02ba			 
02ba 23				inc hl 
02bb 10 ea			djnz .bytewrite 
02bd			 
02bd				; pause for internal write cycle 
02bd 3e 64			ld a, 100 
02bf cd 7a 0c			call aDelayInMS 
02c2 c9			    ret 
02c3			; returns byte in a 
02c3			; address in hl  
02c3			se_readbyte: 
02c3 d5				push de 
02c4 c5				push bc 
02c5			 
02c5			    ;   ld c, a 
02c5 e5			        push hl 
02c6			 
02c6			    ; initi write mode 
02c6			    ; 
02c6			    ;CS low 
02c6			 
02c6 3a 68 fa		       ld a,(spi_portbyte) 
02c9 cd ca 01			call spi_ce_low 
02cc			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cc d3 80		       out (storage_adata),a 
02ce 32 68 fa		       ld (spi_portbyte), a 
02d1			 
02d1			    ;clock out wren instruction 
02d1			 
02d1 3e 03		    ld a, store_read_ins 
02d3 cd b8 00		    call spi_send_byte  
02d6			 
02d6			 
02d6			    ; clock out address (depending on address size) 
02d6			     
02d6 e1			    pop hl 
02d7 7c			    ld a,h    ; address out msb first 
02d8 cd b8 00		    call spi_send_byte  
02db 7d			    ld a,l 
02dc cd b8 00		    call spi_send_byte  
02df			 
02df			    ; clock in byte(s) for page 
02df			 
02df cd df 00		    call spi_read_byte  
02e2 f5				push af 
02e3			 
02e3			    ; end write with ce high 
02e3 3a 68 fa		       ld a,(spi_portbyte) 
02e6			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e6 cd b9 01			call spi_ce_high 
02e9 d3 80		       out (storage_adata),a 
02eb 32 68 fa		       ld (spi_portbyte), a 
02ee			 
02ee f1				pop af 
02ef			 
02ef c1				pop bc 
02f0 d1				pop de 
02f1			 
02f1 c9			    ret 
02f2			 
02f2			if DEBUG_STORESE 
02f2			 
02f2			storageput:  
02f2			 
02f2			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02f2			 
02f2 21 ca f1			ld hl,scratch+2 
02f5 cd 03 13			call get_word_hl 
02f8			 
02f8				; stuff it here for the moment as it will be overwritten later anyway 
02f8			 
02f8 22 eb f4			ld (os_cur_ptr),hl	 
02fb			 
02fb			 
02fb			; get pointer to start of string 
02fb			 
02fb 21 cf f1			ld hl, scratch+7 
02fe			 
02fe			; loop writing char of string to eeprom 
02fe			 
02fe 7e			.writestr:	ld a,(hl) 
02ff fe 00				cp 0 
0301 28 12				jr z, .wsdone		; done writing 
0303 e5					push hl 
0304 2a eb f4				ld hl,(os_cur_ptr) 
0307 cd 21 02				call se_writebyte 
030a			 
030a 2a eb f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030d 23					inc hl 
030e 22 eb f4				ld (os_cur_ptr),hl 
0311			 
0311					; restore string pointer and get next char 
0311			 
0311 e1					pop hl 
0312 23					inc hl 
0313 18 e9				jr .writestr 
0315			 
0315			 
0315			 
0315			.wsdone: 
0315			 
0315			 
0315			; when done load first page into a buffer  
0315			 
0315 21 00 80				ld hl,08000h		; start in ram 
0318 22 eb f4				ld (os_cur_ptr),hl 
031b 21 00 00				ld hl, 0		 ; start of page 
031e 22 f0 f1				ld (scratch+40),hl	; hang on to it 
0321			 
0321 06 80				ld b, 128		; actually get more then one page 
0323 c5			.wsload:	push bc 
0324 2a f0 f1				ld hl,(scratch+40) 
0327 e5					push hl 
0328 cd c3 02				call se_readbyte 
032b			 
032b					; a now as the byte 
032b			 
032b 2a eb f4				ld hl,(os_cur_ptr) 
032e 77					ld (hl),a 
032f					; inc next buffer area 
032f 23					inc hl 
0330 22 eb f4				ld (os_cur_ptr),hl 
0333			 
0333					; get eeprom position, inc and save for next round 
0333 e1					pop hl		 
0334 23					inc hl 
0335 22 f0 f1				ld (scratch+40),hl 
0338 c1					pop bc 
0339 10 e8				djnz .wsload 
033b			 
033b			; set 'd' pointer to start of buffer 
033b			 
033b 21 00 80				ld hl,08000h 
033e 22 eb f4				ld (os_cur_ptr),hl 
0341			 
0341			 
0341 c9			ret 
0342			 
0342			 
0342 c9			storageread: ret 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			endif 
0343			 
0343			 
0343			 
# End of file firmware_seeprom.asm
0343			else  
0343			   ; create some stubs for the labels  
0343			se_readbyte: ret  
0343			se_writebyte: ret  
0343			storage_init: ret  
0343			  
0343			endif  
0343			  
0343			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0343			;include "firmware_cf.asm"  
0343			  
0343			; load up high level storage hardward abstractions  
0343			include "firmware_storage.asm"  
0343			 
0343			; persisent storage hardware abstraction layer  
0343			 
0343			 
0343			 
0343			; Block 0 on storage is a config state 
0343			 
0343			 
0343			 
0343			; TODO add read phy block and write phy block functions 
0343			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0343			 
0343			; Abstraction layer  
0343			 
0343			; Logocial block size is same size as physical size - using tape concept 
0343			 
0343			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0343			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0343			 
0343			 
0343			 
0343			; Filesystem layout (Logical layout) 
0343			; 
0343			; Block 0 - Bank config  
0343			; 
0343			;      Byte - 0 file id counter 
0343			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0343			;      Byte - 3-20 zero terminated bank label 
0343			; 
0343			; Block 1 > File storage 
0343			; 
0343			;      Byte 0 file id    - block 0 file details 
0343			;      Byte 1 block id - block 0 is file  
0343			;            Byte 2-15 - File name 
0343			; 
0343			;       - to end of block data 
0343			; 
0343			 
0343			; Get ID for the file named in pointer held HL 
0343			; Returns ID in HL = 255 if no file found 
0343			 
0343			storage_getid: 
0343			 
0343 22 7a fa			ld (store_tmp1), hl 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SGI" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 6e fe			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 6f fe			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 70 fe			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SGI"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f					CALLMONITOR 
035f cd 9e 19			call break_point_state  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362				; get block 0 and set counter for number of files to scan 
0362			 
0362 cd cd 04			call storage_get_block_0 
0365			 
0365 3a 81 fa			ld a, (store_page) 
0368 47				ld b, a 
0369			 
0369				; get extent 0 of each file id 
0369			 
0369				if DEBUG_STORESE 
0369					DMARK "SGc" 
0369 f5				push af  
036a 3a 7e 03			ld a, (.dmark)  
036d 32 6e fe			ld (debug_mark),a  
0370 3a 7f 03			ld a, (.dmark+1)  
0373 32 6f fe			ld (debug_mark+1),a  
0376 3a 80 03			ld a, (.dmark+2)  
0379 32 70 fe			ld (debug_mark+2),a  
037c 18 03			jr .pastdmark  
037e ..			.dmark: db "SGc"  
0381 f1			.pastdmark: pop af  
0382			endm  
# End of macro DMARK
0382					CALLMONITOR 
0382 cd 9e 19			call break_point_state  
0385				endm  
# End of macro CALLMONITOR
0385				endif 
0385 60			.getloop:	ld h, b 
0386 2e 00				ld l, 0 
0388 c5					push bc 
0389			 
0389 11 81 fa				ld de, store_page 
038c				if DEBUG_STORESE 
038c					DMARK "SGr" 
038c f5				push af  
038d 3a a1 03			ld a, (.dmark)  
0390 32 6e fe			ld (debug_mark),a  
0393 3a a2 03			ld a, (.dmark+1)  
0396 32 6f fe			ld (debug_mark+1),a  
0399 3a a3 03			ld a, (.dmark+2)  
039c 32 70 fe			ld (debug_mark+2),a  
039f 18 03			jr .pastdmark  
03a1 ..			.dmark: db "SGr"  
03a4 f1			.pastdmark: pop af  
03a5			endm  
# End of macro DMARK
03a5					CALLMONITOR 
03a5 cd 9e 19			call break_point_state  
03a8				endm  
# End of macro CALLMONITOR
03a8				endif 
03a8 cd 75 09				call storage_read 
03ab cd 75 0f				call ishlzero 
03ae 28 2d				jr z, .gap 
03b0					 
03b0					; have a file name read. Is it one we want. 
03b0			 
03b0 2a 7a fa				ld hl, (store_tmp1) 
03b3 11 84 fa				ld de, store_page+3   ; file name 
03b6			 
03b6				if DEBUG_STORESE 
03b6					DMARK "SGc" 
03b6 f5				push af  
03b7 3a cb 03			ld a, (.dmark)  
03ba 32 6e fe			ld (debug_mark),a  
03bd 3a cc 03			ld a, (.dmark+1)  
03c0 32 6f fe			ld (debug_mark+1),a  
03c3 3a cd 03			ld a, (.dmark+2)  
03c6 32 70 fe			ld (debug_mark+2),a  
03c9 18 03			jr .pastdmark  
03cb ..			.dmark: db "SGc"  
03ce f1			.pastdmark: pop af  
03cf			endm  
# End of macro DMARK
03cf					CALLMONITOR 
03cf cd 9e 19			call break_point_state  
03d2				endm  
# End of macro CALLMONITOR
03d2				endif 
03d2 cd e2 13				call strcmp 
03d5 20 06				jr nz, .gap   ; not this one 
03d7			 
03d7 c1				        pop bc 
03d8			 
03d8 26 00				ld h, 0 
03da 68					ld l, b 
03db 18 22				jr .getdone 
03dd						 
03dd			 
03dd			 
03dd			 
03dd			.gap: 
03dd				if DEBUG_STORESE 
03dd					DMARK "SGg" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6e fe			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6f fe			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 70 fe			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SGg"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6					CALLMONITOR 
03f6 cd 9e 19			call break_point_state  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 c1					pop bc 
03fa 10 89				djnz .getloop 
03fc 21 ff 00				ld hl, 255 
03ff			.getdone: 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGe" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 6e fe			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 6f fe			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 70 fe			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGe"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd 9e 19			call break_point_state  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b			 
041b c9				ret 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			; Read Block 
041c			; ---------- 
041c			; 
041c			; With current bank 
041c			;  
041c			; Get block number to read 
041c			; Load physical blocks starting at start block into buffer 
041c			 
041c			; de points to buffer to use 
041c			; hl holds logical block number  
041c			 
041c			storage_read_block: 
041c			 
041c				; TODO bank selection 
041c			 
041c				; for each of the physical blocks read it into the buffer 
041c 06 40			ld b, STORE_BLOCK_PHY 
041e			 
041e				if DEBUG_STORESE 
041e d5					push de 
041f				endif 
041f				 
041f			.rl1:    
041f			 
041f				; read physical block at hl into de 
041f			        ; increment hl and de to next read position on exit 
041f			 
041f e5				push hl 
0420 d5				push de	 
0421 c5				push bc 
0422			;	if DEBUG_STORESE 
0422			;		push af 
0422			;		ld a, 'R' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 cd c3 02			call se_readbyte 
0425			;	if DEBUG_STORESE 
0425			;		ld a,(spi_portbyte) 
0425			;		ld l, a 
0425			;		push af 
0425			;		ld a, '1' 
0425			;		ld (debug_mark),a 
0425			;		pop af 
0425			;		CALLMONITOR 
0425			;	endif 
0425 c1				pop bc 
0426 d1				pop de 
0427 e1				pop hl 
0428 12				ld (de),a 
0429 23				inc hl 
042a 13				inc de 
042b			 
042b			;	if DEBUG_STORESE 
042b			;		push af 
042b			;		ld a, 'r' 
042b			;		ld (debug_mark),a 
042b			;		pop af 
042b			;		CALLMONITOR 
042b			;	endif 
042b			 
042b 10 f2			djnz .rl1 
042d			 
042d				if DEBUG_STORESE 
042d					DMARK "SRB" 
042d f5				push af  
042e 3a 42 04			ld a, (.dmark)  
0431 32 6e fe			ld (debug_mark),a  
0434 3a 43 04			ld a, (.dmark+1)  
0437 32 6f fe			ld (debug_mark+1),a  
043a 3a 44 04			ld a, (.dmark+2)  
043d 32 70 fe			ld (debug_mark+2),a  
0440 18 03			jr .pastdmark  
0442 ..			.dmark: db "SRB"  
0445 f1			.pastdmark: pop af  
0446			endm  
# End of macro DMARK
0446 d1					pop de 
0447			; 
0447			;		push af 
0447			;		ld a, 'R' 
0447			;		ld (debug_mark),a 
0447			;		pop af 
0447					CALLMONITOR 
0447 cd 9e 19			call break_point_state  
044a				endm  
# End of macro CALLMONITOR
044a				endif 
044a c9				ret	 
044b				 
044b			 
044b			; File Size 
044b			; --------- 
044b			; 
044b			;   hl file id 
044b			; 
044b			;  returns in hl the number of blocks 
044b			 
044b			storage_file_size: 
044b 5d				ld e, l 
044c 16 00			ld d, 0 
044e 21 40 00			ld hl, STORE_BLOCK_PHY 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "SIZ" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 6e fe			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 6f fe			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 70 fe			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "SIZ"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd 9e 19			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 4f 07			call storage_findnextid 
0470			 
0470 cd 75 0f			call ishlzero 
0473			;	ld a, l 
0473			;	add h 
0473			;	cp 0 
0473 c8				ret z			; block not found so EOF 
0474			 
0474 11 81 fa			ld de, store_page 
0477 cd 1c 04			call storage_read_block 
047a			 
047a 3a 83 fa			ld a, (store_page+2)	 ; get extent count 
047d 6f				ld l, a 
047e 26 00			ld h, 0 
0480 c9			 	ret 
0481			 
0481			 
0481			; Write Block 
0481			; ----------- 
0481			; 
0481			; With current bank 
0481			;  
0481			; Get block number to write 
0481			; Write physical blocks starting at start block from buffer 
0481			  
0481			storage_write_block: 
0481				; TODO bank selection 
0481			 
0481				; for each of the physical blocks read it into the buffer 
0481 06 40			ld b, STORE_BLOCK_PHY 
0483			 
0483				if DEBUG_STORESE 
0483					DMARK "SWB" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 6e fe			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 6f fe			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 70 fe			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "SWB"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c			 
049c					;push af 
049c					;ld a, 'W' 
049c					;ld (debug_mark),a 
049c					;pop af 
049c					CALLMONITOR 
049c cd 9e 19			call break_point_state  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f			 
049f			; might not be working 
049f			;	call se_writepage 
049f			 
049f			;	ret 
049f			; 
049f			 
049f			 
049f			 
049f			.wl1:    
049f			 
049f				; read physical block at hl into de 
049f			        ; increment hl and de to next read position on exit 
049f			 
049f e5				push hl 
04a0 d5				push de	 
04a1 c5				push bc 
04a2 1a				ld a,(de) 
04a3				;if DEBUG_STORESE 
04a3			;		push af 
04a3			;		ld a, 'W' 
04a3			;		ld (debug_mark),a 
04a3			;		pop af 
04a3			;		CALLMONITOR 
04a3			;	endif 
04a3 cd 21 02			call se_writebyte 
04a6			;	call delay250ms 
04a6 00				nop 
04a7 00				nop 
04a8 00				nop 
04a9			;	if DEBUG_STORESE 
04a9			;		push af 
04a9			;		ld a, 'w' 
04a9			;		ld (debug_mark),a 
04a9			;		pop af 
04a9			;		CALLMONITOR 
04a9			;	endif 
04a9 c1				pop bc 
04aa d1				pop de 
04ab e1				pop hl 
04ac 23				inc hl 
04ad 13				inc de 
04ae			 
04ae			 
04ae 10 ef			djnz .wl1 
04b0			 
04b0				if DEBUG_STORESE 
04b0					DMARK "SW2" 
04b0 f5				push af  
04b1 3a c5 04			ld a, (.dmark)  
04b4 32 6e fe			ld (debug_mark),a  
04b7 3a c6 04			ld a, (.dmark+1)  
04ba 32 6f fe			ld (debug_mark+1),a  
04bd 3a c7 04			ld a, (.dmark+2)  
04c0 32 70 fe			ld (debug_mark+2),a  
04c3 18 03			jr .pastdmark  
04c5 ..			.dmark: db "SW2"  
04c8 f1			.pastdmark: pop af  
04c9			endm  
# End of macro DMARK
04c9			 
04c9					;push af 
04c9					;ld a, 'W' 
04c9					;ld (debug_mark),a 
04c9					;pop af 
04c9					CALLMONITOR 
04c9 cd 9e 19			call break_point_state  
04cc				endm  
# End of macro CALLMONITOR
04cc				endif 
04cc c9				ret	 
04cd			 
04cd			; Init bank 
04cd			; --------- 
04cd			; 
04cd			; With current bank 
04cd			; 
04cd			; Setup block 0 config 
04cd			;     Set 0 file id counter 
04cd			;     Set formatted byte pattern 
04cd			;     Zero out bank label 
04cd			;      
04cd			; For every logical block write 0-1 byte as null 
04cd			 
04cd			storage_get_block_0: 
04cd			 
04cd				; TODO check presence 
04cd			 
04cd				; get block 0 config 
04cd			 
04cd 21 00 00			ld hl, 0 
04d0 11 81 fa			ld de, store_page 
04d3 cd 1c 04			call storage_read_block 
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "SB0" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 6e fe			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 6f fe			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 70 fe			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "SB0"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef 11 81 fa				ld de, store_page 
04f2			;		push af 
04f2			;		ld a, 'i' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2					CALLMONITOR 
04f2 cd 9e 19			call break_point_state  
04f5				endm  
# End of macro CALLMONITOR
04f5				endif 
04f5			 
04f5				; is this area formatted? 
04f5			 
04f5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f5 2a 82 fa			ld hl, (store_page+1) 
04f8 3e 80			ld a,0x80 
04fa bd				cp l 
04fb 20 22			jr nz, .ininotformatted 
04fd				; do a double check 
04fd 3e 27			ld a, 0x27 
04ff bc				cp h 
0500 20 1d			jr nz, .ininotformatted 
0502			 
0502				; formatted then 
0502			 
0502				if DEBUG_STORESE 
0502					DMARK "SB1" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 6e fe			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 6f fe			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 70 fe			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "SB1"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					;push af 
051b					;ld a, 'I' 
051b					;ld (debug_mark),a 
051b					;pop af 
051b					CALLMONITOR 
051b cd 9e 19			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e c9				ret 
051f			 
051f			.ininotformatted: 
051f				; bank not formatted so poke various bits to make sure 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB2" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 6e fe			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 6f fe			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 70 fe			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB2"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538					;push af 
0538					;ld a, 'f' 
0538					;ld (debug_mark),a 
0538					;pop af 
0538					CALLMONITOR 
0538 cd 9e 19			call break_point_state  
053b				endm  
# End of macro CALLMONITOR
053b				endif 
053b			 
053b cd 58 0c			call storage_clear_page 
053e			 
053e 21 81 fa			ld hl, store_page 
0541 3e 00			ld a, 0 
0543				 
0543 77				ld (hl),a   ; reset file counter 
0544			 
0544 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0547 22 82 fa		 	ld (store_page+1), hl	 
054a			 
054a				; set default label 
054a			 
054a 21 e6 05			ld hl, .defaultbanklabl 
054d 11 84 fa		 	ld de, store_page+3 
0550 01 0f 00			ld bc, 15 
0553 ed b0			ldir 
0555			 
0555				; Append the current bank id 
0555 21 8d fa			ld hl, store_page+3+9 
0558 3a 66 fa			ld a, (spi_device_id) 
055b 77				ld (hl), a 
055c			 
055c				; save default page 0 
055c			 
055c 21 00 00			ld hl, 0 
055f 11 81 fa			ld de, store_page 
0562				if DEBUG_STORESE 
0562					DMARK "SB3" 
0562 f5				push af  
0563 3a 77 05			ld a, (.dmark)  
0566 32 6e fe			ld (debug_mark),a  
0569 3a 78 05			ld a, (.dmark+1)  
056c 32 6f fe			ld (debug_mark+1),a  
056f 3a 79 05			ld a, (.dmark+2)  
0572 32 70 fe			ld (debug_mark+2),a  
0575 18 03			jr .pastdmark  
0577 ..			.dmark: db "SB3"  
057a f1			.pastdmark: pop af  
057b			endm  
# End of macro DMARK
057b			;		push af 
057b			;		ld a, 'F' 
057b			;		ld (debug_mark),a 
057b			;		pop af 
057b					CALLMONITOR 
057b cd 9e 19			call break_point_state  
057e				endm  
# End of macro CALLMONITOR
057e				endif 
057e cd 81 04			call storage_write_block 
0581				if DEBUG_STORESE 
0581					DMARK "SB4" 
0581 f5				push af  
0582 3a 96 05			ld a, (.dmark)  
0585 32 6e fe			ld (debug_mark),a  
0588 3a 97 05			ld a, (.dmark+1)  
058b 32 6f fe			ld (debug_mark+1),a  
058e 3a 98 05			ld a, (.dmark+2)  
0591 32 70 fe			ld (debug_mark+2),a  
0594 18 03			jr .pastdmark  
0596 ..			.dmark: db "SB4"  
0599 f1			.pastdmark: pop af  
059a			endm  
# End of macro DMARK
059a			;		push af 
059a			;		ld a, '>' 
059a			;		ld (debug_mark),a 
059a			;		pop af 
059a					CALLMONITOR 
059a cd 9e 19			call break_point_state  
059d				endm  
# End of macro CALLMONITOR
059d				endif 
059d			 
059d 00				nop 
059e 00				nop 
059f 00				nop 
05a0			 
05a0				; now set 0 in every page to mark as a free block 
05a0			 
05a0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05a2 21 40 00			ld hl, STORE_BLOCK_PHY 
05a5			 
05a5 3e 00		.setmark1:   	ld a,0 
05a7 e5					push hl 
05a8 c5					push bc 
05a9 cd 21 02				call se_writebyte 
05ac 3e 0a			ld a, 10 
05ae cd 7a 0c			call aDelayInMS 
05b1 23				inc hl 
05b2 cd 21 02				call se_writebyte 
05b5 3e 0a			ld a, 10 
05b7 cd 7a 0c			call aDelayInMS 
05ba 2b				dec hl 
05bb c1					pop bc 
05bc e1					pop hl 
05bd 3e 40				ld a, STORE_BLOCK_PHY 
05bf cd 4c 0f				call addatohl 
05c2 10 e1				djnz .setmark1 
05c4			 
05c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c6 3e 00		.setmark2:   	ld a,0 
05c8 e5					push hl 
05c9 c5					push bc 
05ca cd 21 02				call se_writebyte 
05cd 3e 0a			ld a, 10 
05cf cd 7a 0c			call aDelayInMS 
05d2 23				inc hl 
05d3 cd 21 02				call se_writebyte 
05d6 3e 0a			ld a, 10 
05d8 cd 7a 0c			call aDelayInMS 
05db 2b				dec hl 
05dc c1					pop bc 
05dd e1					pop hl 
05de 3e 40				ld a, STORE_BLOCK_PHY 
05e0 cd 4c 0f				call addatohl 
05e3 10 e1				djnz .setmark2 
05e5			 
05e5					 
05e5			 
05e5			 
05e5 c9				ret 
05e6			 
05e6			 
05e6			 
05e6			 
05e6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05f1			 
05f1			 
05f1			 
05f1			; Label Bank 
05f1			; ---------- 
05f1			; 
05f1			; With current bank 
05f1			; Read block 0 
05f1			; Set label 
05f1			; Write block 0 
05f1			 
05f1			; label str pointer in hl 
05f1			 
05f1			storage_label:     
05f1			 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBL" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 6e fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 6f fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 70 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBL"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd 9e 19			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d			 
060d e5				push hl 
060e			 
060e cd cd 04			call storage_get_block_0 
0611			 
0611				; set default label 
0611			 
0611 e1				pop hl 
0612			 
0612 11 84 fa		 	ld de, store_page+3 
0615 01 0f 00			ld bc, 15 
0618				if DEBUG_STORESE 
0618					DMARK "LB3" 
0618 f5				push af  
0619 3a 2d 06			ld a, (.dmark)  
061c 32 6e fe			ld (debug_mark),a  
061f 3a 2e 06			ld a, (.dmark+1)  
0622 32 6f fe			ld (debug_mark+1),a  
0625 3a 2f 06			ld a, (.dmark+2)  
0628 32 70 fe			ld (debug_mark+2),a  
062b 18 03			jr .pastdmark  
062d ..			.dmark: db "LB3"  
0630 f1			.pastdmark: pop af  
0631			endm  
# End of macro DMARK
0631					CALLMONITOR 
0631 cd 9e 19			call break_point_state  
0634				endm  
# End of macro CALLMONITOR
0634				endif 
0634 ed b0			ldir 
0636				; save default page 0 
0636			 
0636 21 00 00			ld hl, 0 
0639 11 81 fa			ld de, store_page 
063c				if DEBUG_STORESE 
063c					DMARK "LBW" 
063c f5				push af  
063d 3a 51 06			ld a, (.dmark)  
0640 32 6e fe			ld (debug_mark),a  
0643 3a 52 06			ld a, (.dmark+1)  
0646 32 6f fe			ld (debug_mark+1),a  
0649 3a 53 06			ld a, (.dmark+2)  
064c 32 70 fe			ld (debug_mark+2),a  
064f 18 03			jr .pastdmark  
0651 ..			.dmark: db "LBW"  
0654 f1			.pastdmark: pop af  
0655			endm  
# End of macro DMARK
0655					CALLMONITOR 
0655 cd 9e 19			call break_point_state  
0658				endm  
# End of macro CALLMONITOR
0658				endif 
0658 cd 81 04			call storage_write_block 
065b			 
065b c9				ret 
065c			 
065c			 
065c			 
065c			; Read Block 0 - Config 
065c			; --------------------- 
065c			; 
065c			; With current bank 
065c			; Call presence test 
065c			;    If not present format/init bank  
065c			; Read block 0  
065c			;  
065c			 
065c			 
065c			; Dir 
065c			; --- 
065c			; 
065c			; With current bank 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block read byte 2 
065c			;      if first block of file 
065c			;         Display file name 
065c			;         Display type flags for file 
065c			;        
065c			 
065c			; moving to words as this requires stack control 
065c			 
065c			 
065c			; Delete File 
065c			; ----------- 
065c			; 
065c			; With current bank 
065c			; 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block file id 
065c			;      If first block of file and dont have file id 
065c			;         if file to delete 
065c			;         Save file id 
065c			;         Null file id 
065c			;         Write this block back 
065c			;      If file id is one saved 
065c			;         Null file id 
065c			;         Write this block back 
065c			 
065c			 
065c			.se_done: 
065c e1				pop hl 
065d c9				ret 
065e			 
065e			storage_erase: 
065e			 
065e				; hl contains the file id 
065e			 
065e 5d				ld e, l 
065f 16 00			ld d, 0 
0661 21 40 00			ld hl, STORE_BLOCK_PHY 
0664					if DEBUG_FORTH_WORDS 
0664						DMARK "ERA" 
0664 f5				push af  
0665 3a 79 06			ld a, (.dmark)  
0668 32 6e fe			ld (debug_mark),a  
066b 3a 7a 06			ld a, (.dmark+1)  
066e 32 6f fe			ld (debug_mark+1),a  
0671 3a 7b 06			ld a, (.dmark+2)  
0674 32 70 fe			ld (debug_mark+2),a  
0677 18 03			jr .pastdmark  
0679 ..			.dmark: db "ERA"  
067c f1			.pastdmark: pop af  
067d			endm  
# End of macro DMARK
067d						CALLMONITOR 
067d cd 9e 19			call break_point_state  
0680				endm  
# End of macro CALLMONITOR
0680					endif 
0680 cd 4f 07			call storage_findnextid 
0683 cd 75 0f			call ishlzero 
0686 c8				ret z 
0687			 
0687 e5				push hl 
0688			 
0688				; TODO check file not found 
0688			 
0688 11 81 fa			ld de, store_page 
068b cd 1c 04			call storage_read_block 
068e			 
068e cd 75 0f			call ishlzero 
0691 ca 5c 06			jp z,.se_done 
0694			 
0694					if DEBUG_FORTH_WORDS 
0694						DMARK "ER1" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 6e fe			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 6f fe			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 70 fe			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "ER1"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad						CALLMONITOR 
06ad cd 9e 19			call break_point_state  
06b0				endm  
# End of macro CALLMONITOR
06b0					endif 
06b0 3a 81 fa			ld a, (store_page)	; get file id 
06b3 32 75 fa			ld (store_tmpid), a 
06b6			 
06b6 3a 83 fa			ld a, (store_page+2)    ; get count of extends 
06b9 32 74 fa			ld (store_tmpext), a 
06bc			 
06bc				; wipe file header 
06bc			 
06bc e1				pop hl 
06bd 3e 00			ld a, 0 
06bf 32 81 fa			ld (store_page), a 
06c2 32 82 fa			ld (store_page+1),a 
06c5 11 81 fa			ld de, store_page 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER2" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 6e fe			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 6f fe			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 70 fe			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER2"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd 9e 19			call break_point_state  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 cd 81 04			call storage_write_block 
06e7			 
06e7			 
06e7				; wipe file extents 
06e7			 
06e7 3a 74 fa			ld a, (store_tmpext) 
06ea 47				ld b, a 
06eb			 
06eb			.eraext:	  
06eb c5				push bc 
06ec			 
06ec 21 40 00			ld hl, STORE_BLOCK_PHY 
06ef 3a 75 fa			ld a,(store_tmpid) 
06f2 5f				ld e, a 
06f3 50				ld d, b	 
06f4					if DEBUG_FORTH_WORDS 
06f4						DMARK "ER3" 
06f4 f5				push af  
06f5 3a 09 07			ld a, (.dmark)  
06f8 32 6e fe			ld (debug_mark),a  
06fb 3a 0a 07			ld a, (.dmark+1)  
06fe 32 6f fe			ld (debug_mark+1),a  
0701 3a 0b 07			ld a, (.dmark+2)  
0704 32 70 fe			ld (debug_mark+2),a  
0707 18 03			jr .pastdmark  
0709 ..			.dmark: db "ER3"  
070c f1			.pastdmark: pop af  
070d			endm  
# End of macro DMARK
070d						CALLMONITOR 
070d cd 9e 19			call break_point_state  
0710				endm  
# End of macro CALLMONITOR
0710					endif 
0710 cd 4f 07			call storage_findnextid 
0713 cd 75 0f			call ishlzero 
0716 ca 5c 06			jp z,.se_done 
0719			 
0719 e5				push hl 
071a 11 81 fa			ld de, store_page 
071d cd 1c 04			call storage_read_block 
0720			 
0720				; free block	 
0720			 
0720 3e 00			ld a, 0 
0722 32 81 fa			ld (store_page), a 
0725 32 82 fa			ld (store_page+1),a 
0728 11 81 fa			ld de, store_page 
072b e1				pop hl 
072c					if DEBUG_FORTH_WORDS 
072c						DMARK "ER4" 
072c f5				push af  
072d 3a 41 07			ld a, (.dmark)  
0730 32 6e fe			ld (debug_mark),a  
0733 3a 42 07			ld a, (.dmark+1)  
0736 32 6f fe			ld (debug_mark+1),a  
0739 3a 43 07			ld a, (.dmark+2)  
073c 32 70 fe			ld (debug_mark+2),a  
073f 18 03			jr .pastdmark  
0741 ..			.dmark: db "ER4"  
0744 f1			.pastdmark: pop af  
0745			endm  
# End of macro DMARK
0745						CALLMONITOR 
0745 cd 9e 19			call break_point_state  
0748				endm  
# End of macro CALLMONITOR
0748					endif 
0748 cd 81 04			call storage_write_block 
074b			 
074b c1				pop bc 
074c 10 9d			djnz .eraext 
074e			 
074e c9				ret 
074f			 
074f			 
074f			; Find Free Block 
074f			; --------------- 
074f			; 
074f			; With current bank 
074f			;  
074f			; From given starting logical block 
074f			;    Read block  
074f			;    If no file id 
074f			;         Return block id 
074f			 
074f			 
074f			; hl starting page number 
074f			; hl contains free page number or zero if no pages free 
074f			; e contains the file id to locate 
074f			; d contains the block number 
074f			 
074f			; TODO change to find file id and use zero for free block 
074f			 
074f			storage_findnextid: 
074f			 
074f				; now locate first 0 page to mark as a free block 
074f			 
074f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0751			;	ld hl, STORE_BLOCK_PHY 
0751			 
0751					if DEBUG_FORTH_WORDS 
0751					DMARK "FNI" 
0751 f5				push af  
0752 3a 66 07			ld a, (.dmark)  
0755 32 6e fe			ld (debug_mark),a  
0758 3a 67 07			ld a, (.dmark+1)  
075b 32 6f fe			ld (debug_mark+1),a  
075e 3a 68 07			ld a, (.dmark+2)  
0761 32 70 fe			ld (debug_mark+2),a  
0764 18 03			jr .pastdmark  
0766 ..			.dmark: db "FNI"  
0769 f1			.pastdmark: pop af  
076a			endm  
# End of macro DMARK
076a						CALLMONITOR 
076a cd 9e 19			call break_point_state  
076d				endm  
# End of macro CALLMONITOR
076d					endif 
076d			.ff1:   	 
076d e5					push hl 
076e c5					push bc 
076f d5					push de 
0770 cd c3 02				call se_readbyte 
0773 5f					ld e,a 
0774 23					inc hl 
0775 cd c3 02				call se_readbyte 
0778 57					ld d, a 
0779 e1					pop hl 
077a e5					push hl 
077b cd 6a 0f				call cmp16 
077e 28 49				jr z, .fffound 
0780			 
0780 d1					pop de 
0781 c1					pop bc 
0782 e1					pop hl 
0783			 
0783					; is found? 
0783					;cp e 
0783					;ret z 
0783			 
0783 3e 40				ld a, STORE_BLOCK_PHY 
0785 cd 4c 0f				call addatohl 
0788 10 e3				djnz .ff1 
078a			 
078a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
078c			.ff2:   	 
078c			 
078c e5					push hl 
078d c5					push bc 
078e d5					push de 
078f cd c3 02				call se_readbyte 
0792 5f					ld e,a 
0793 23					inc hl 
0794 cd c3 02				call se_readbyte 
0797 57					ld d, a 
0798			 
0798 e1					pop hl 
0799 e5					push hl 
079a cd 6a 0f				call cmp16 
079d 28 2a				jr z, .fffound 
079f			 
079f d1					pop de 
07a0 c1					pop bc 
07a1 e1					pop hl 
07a2					; is found? 
07a2					;cp e 
07a2					;ret z 
07a2			 
07a2 3e 40				ld a, STORE_BLOCK_PHY 
07a4 cd 4c 0f				call addatohl 
07a7 10 e3				djnz .ff2 
07a9			 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FN-" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 6e fe			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 6f fe			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 70 fe			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FN-"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2					;	push af 
07c2					;	ld a, 'n' 
07c2					;	ld (debug_mark),a 
07c2					;	pop af 
07c2						CALLMONITOR 
07c2 cd 9e 19			call break_point_state  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5				; no free marks! 
07c5 21 00 00				ld hl, 0 
07c8 c9				ret 
07c9			.fffound: 
07c9				 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc					if DEBUG_FORTH_WORDS 
07cc					DMARK "FNF" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 6e fe			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 6f fe			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 70 fe			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "FNF"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;	push af 
07e5					;	ld a, 'n' 
07e5					;	ld (debug_mark),a 
07e5					;	pop af 
07e5						CALLMONITOR 
07e5 cd 9e 19			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8					endif 
07e8 c9				ret 
07e9			 
07e9			 
07e9			 
07e9			; Free Space 
07e9			; ---------- 
07e9			; 
07e9			; With current bank 
07e9			; 
07e9			; Set block count to zero 
07e9			; Starting with first logical block 
07e9			;      Find free block  
07e9			;      If block id given, increment block count 
07e9			; 
07e9			;  
07e9			 
07e9			 
07e9			; hl contains count of free blocks 
07e9			 
07e9			storage_freeblocks: 
07e9			 
07e9				; now locate first 0 page to mark as a free block 
07e9			 
07e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07eb 21 40 00			ld hl, STORE_BLOCK_PHY 
07ee 11 00 00			ld de, 0 
07f1			 
07f1			.fb1:   	 
07f1 e5					push hl 
07f2 c5					push bc 
07f3 d5					push de 
07f4 cd c3 02				call se_readbyte 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa			 
07fa					; is free? 
07fa fe 00				cp 0 
07fc 20 01				jr nz, .ff1cont 
07fe 13					inc de 
07ff			 
07ff			.ff1cont: 
07ff			 
07ff			 
07ff 3e 40				ld a, STORE_BLOCK_PHY 
0801 cd 4c 0f				call addatohl 
0804 10 eb				djnz .fb1 
0806			 
0806 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0808			.fb2:   	 
0808 e5					push hl 
0809 c5					push bc 
080a d5					push de 
080b cd c3 02				call se_readbyte 
080e d1					pop de 
080f c1					pop bc 
0810 e1					pop hl 
0811			 
0811					; is free? 
0811 fe 00				cp 0 
0813 20 01				jr nz, .ff2cont 
0815 13					inc de 
0816			 
0816			.ff2cont: 
0816			 
0816 3e 40				ld a, STORE_BLOCK_PHY 
0818 cd 4c 0f				call addatohl 
081b 10 eb				djnz .fb2 
081d			 
081d eb				ex de, hl 
081e c9				ret 
081f			 
081f			; Get File ID 
081f			; ----------- 
081f			; 
081f			; With current bank 
081f			;  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; For each logical block 
081f			;    Read block file id 
081f			;      If first block of file and dont have file id 
081f			;         if file get id and exit 
081f			 
081f			 
081f			 
081f			 
081f			; Create File 
081f			; ----------- 
081f			; 
081f			; With current bank  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; Increment file id number 
081f			; Save Config 
081f			; Find free block 
081f			; Set buffer with file name and file id 
081f			; Write buffer to free block  
081f			 
081f			 
081f			; hl point to file name 
081f			; hl returns file id 
081f			 
081f			; file format: 
081f			; byte 0 - file id 
081f			; byte 1 - extent number 
081f			; byte 2-> data 
081f			 
081f			; format for extent number 0: 
081f			; 
081f			; byte 0 - file id 
081f			; byte 1 - extent 0 
081f			; byte 2 - extent count 
081f			; byte 3 -> file name and meta data 
081f			 
081f			 
081f			storage_create: 
081f				if DEBUG_STORESE 
081f					DMARK "SCR" 
081f f5				push af  
0820 3a 34 08			ld a, (.dmark)  
0823 32 6e fe			ld (debug_mark),a  
0826 3a 35 08			ld a, (.dmark+1)  
0829 32 6f fe			ld (debug_mark+1),a  
082c 3a 36 08			ld a, (.dmark+2)  
082f 32 70 fe			ld (debug_mark+2),a  
0832 18 03			jr .pastdmark  
0834 ..			.dmark: db "SCR"  
0837 f1			.pastdmark: pop af  
0838			endm  
# End of macro DMARK
0838					CALLMONITOR 
0838 cd 9e 19			call break_point_state  
083b				endm  
# End of macro CALLMONITOR
083b				endif 
083b			 
083b e5				push hl		; save file name pointer 
083c			 
083c cd cd 04			call storage_get_block_0 
083f			 
083f 3a 81 fa			ld a,(store_page)	; get current file id 
0842 3c				inc a 
0843 32 81 fa			ld (store_page),a 
0846				 
0846 32 75 fa			ld (store_tmpid),a			; save id 
0849			 
0849 21 00 00			ld hl, 0 
084c 11 81 fa			ld de, store_page 
084f				if DEBUG_STORESE 
084f					DMARK "SCw" 
084f f5				push af  
0850 3a 64 08			ld a, (.dmark)  
0853 32 6e fe			ld (debug_mark),a  
0856 3a 65 08			ld a, (.dmark+1)  
0859 32 6f fe			ld (debug_mark+1),a  
085c 3a 66 08			ld a, (.dmark+2)  
085f 32 70 fe			ld (debug_mark+2),a  
0862 18 03			jr .pastdmark  
0864 ..			.dmark: db "SCw"  
0867 f1			.pastdmark: pop af  
0868			endm  
# End of macro DMARK
0868					CALLMONITOR 
0868 cd 9e 19			call break_point_state  
086b				endm  
# End of macro CALLMONITOR
086b				endif 
086b cd 81 04			call storage_write_block	 ; save update 
086e			 
086e				if DEBUG_STORESE 
086e 11 81 fa				ld de, store_page 
0871					DMARK "SCC" 
0871 f5				push af  
0872 3a 86 08			ld a, (.dmark)  
0875 32 6e fe			ld (debug_mark),a  
0878 3a 87 08			ld a, (.dmark+1)  
087b 32 6f fe			ld (debug_mark+1),a  
087e 3a 88 08			ld a, (.dmark+2)  
0881 32 70 fe			ld (debug_mark+2),a  
0884 18 03			jr .pastdmark  
0886 ..			.dmark: db "SCC"  
0889 f1			.pastdmark: pop af  
088a			endm  
# End of macro DMARK
088a					CALLMONITOR 
088a cd 9e 19			call break_point_state  
088d				endm  
# End of macro CALLMONITOR
088d				endif 
088d				;  
088d				 
088d 21 40 00			ld hl, STORE_BLOCK_PHY 
0890 11 00 00			ld de, 0 
0893 cd 4f 07			call storage_findnextid 
0896			 
0896 22 6c fa			ld (store_tmppageid), hl    ; save page to use  
0899			 
0899				; TODO detect 0 = no spare blocks 
0899			 
0899				; hl now contains the free page to use for the file header page 
0899			 
0899				if DEBUG_STORESE 
0899				DMARK "SCF" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 6e fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 6f fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 70 fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCF"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd 9e 19			call break_point_state  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5			 
08b5 22 6c fa			ld (store_tmppageid), hl 
08b8				 
08b8 3a 75 fa			ld a,(store_tmpid)    ; get file id 
08bb			;	ld a, (store_filecache)			; save to cache 
08bb			 
08bb 32 81 fa			ld (store_page),a    ; set page id 
08be 3e 00			ld a, 0			 ; extent 0 is file header 
08c0 32 82 fa			ld (store_page+1), a   ; set file extent 
08c3			 
08c3 32 83 fa			ld (store_page+2), a   ; extent count for the file 
08c6			 
08c6			;	inc hl 		; init block 0 of file 
08c6			;	inc hl   		; skip file and extent id 
08c6			 ;       ld a, 0 
08c6			;	ld (hl),a 
08c6			;	ld a, (store_filecache+1)  	; save to cache 
08c6			 
08c6			;	inc hl    ; file name 
08c6				 
08c6				 
08c6 11 84 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
08c9				if DEBUG_STORESE 
08c9					DMARK "SCc" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 6e fe			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 6f fe			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 70 fe			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCc"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd 9e 19			call break_point_state  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5 e1				pop hl    ; get zero term string 
08e6 e5				push hl 
08e7 3e 00			ld a, 0 
08e9 cd b5 13			call strlent 
08ec 23				inc hl   ; cover zero term 
08ed 06 00			ld b,0 
08ef 4d				ld c,l 
08f0 e1				pop hl 
08f1				;ex de, hl 
08f1				if DEBUG_STORESE 
08f1					DMARK "SCa" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 6e fe			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 6f fe			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 70 fe			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCa"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					;push af 
090a					;ld a, 'a' 
090a					;ld (debug_mark),a 
090a					;pop af 
090a					CALLMONITOR 
090a cd 9e 19			call break_point_state  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d ed b0			ldir    ; copy zero term string 
090f				if DEBUG_STORESE 
090f					DMARK "SCA" 
090f f5				push af  
0910 3a 24 09			ld a, (.dmark)  
0913 32 6e fe			ld (debug_mark),a  
0916 3a 25 09			ld a, (.dmark+1)  
0919 32 6f fe			ld (debug_mark+1),a  
091c 3a 26 09			ld a, (.dmark+2)  
091f 32 70 fe			ld (debug_mark+2),a  
0922 18 03			jr .pastdmark  
0924 ..			.dmark: db "SCA"  
0927 f1			.pastdmark: pop af  
0928			endm  
# End of macro DMARK
0928					CALLMONITOR 
0928 cd 9e 19			call break_point_state  
092b				endm  
# End of macro CALLMONITOR
092b				endif 
092b			 
092b				; write file header page 
092b			 
092b 2a 6c fa			ld hl,(store_tmppageid) 
092e 11 81 fa			ld de, store_page 
0931				if DEBUG_STORESE 
0931					DMARK "SCb" 
0931 f5				push af  
0932 3a 46 09			ld a, (.dmark)  
0935 32 6e fe			ld (debug_mark),a  
0938 3a 47 09			ld a, (.dmark+1)  
093b 32 6f fe			ld (debug_mark+1),a  
093e 3a 48 09			ld a, (.dmark+2)  
0941 32 70 fe			ld (debug_mark+2),a  
0944 18 03			jr .pastdmark  
0946 ..			.dmark: db "SCb"  
0949 f1			.pastdmark: pop af  
094a			endm  
# End of macro DMARK
094a					;push af 
094a					;ld a, 'b' 
094a					;ld (debug_mark),a 
094a					;pop af 
094a					CALLMONITOR 
094a cd 9e 19			call break_point_state  
094d				endm  
# End of macro CALLMONITOR
094d				endif 
094d cd 81 04			call storage_write_block 
0950			 
0950 3a 75 fa			ld a, (store_tmpid) 
0953 6f				ld l, a 
0954 26 00			ld h,0 
0956				if DEBUG_STORESE 
0956					DMARK "SCz" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 6e fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 6f fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 70 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "SCz"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd 9e 19			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 c9				ret 
0973				 
0973			 
0973			 
0973			; 
0973			; Read File 
0973			; 
0973			; h - file id to locate 
0973			; l - extent to locate 
0973			; de - pointer to string to read into 
0973			; 
0973			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0973			 
0973			.sr_fail: 
0973 d1				pop de 
0974 c9				ret 
0975			 
0975			storage_read: 
0975			 
0975			 
0975 d5				push de 
0976			 
0976			; TODO BUG the above push is it popped before the RET Z? 
0976			 
0976			; TODO how to handle multiple part blocks 
0976			 
0976				; locate file extent to read 
0976			 
0976 5c				ld e, h 
0977 55				ld d, l 
0978			 
0978			.srext: 
0978 22 7f fa			ld (store_readptr), hl     ; save the current extent to load 
097b ed 53 7d fa		ld (store_readbuf), de     ; save the current buffer to load in to 
097f			 
097f 21 40 00			ld hl, STORE_BLOCK_PHY 
0982				if DEBUG_STORESE 
0982					DMARK "sre" 
0982 f5				push af  
0983 3a 97 09			ld a, (.dmark)  
0986 32 6e fe			ld (debug_mark),a  
0989 3a 98 09			ld a, (.dmark+1)  
098c 32 6f fe			ld (debug_mark+1),a  
098f 3a 99 09			ld a, (.dmark+2)  
0992 32 70 fe			ld (debug_mark+2),a  
0995 18 03			jr .pastdmark  
0997 ..			.dmark: db "sre"  
099a f1			.pastdmark: pop af  
099b			endm  
# End of macro DMARK
099b					CALLMONITOR 
099b cd 9e 19			call break_point_state  
099e				endm  
# End of macro CALLMONITOR
099e				endif 
099e cd 4f 07			call storage_findnextid 
09a1			 
09a1				if DEBUG_STORESE 
09a1					DMARK "srf" 
09a1 f5				push af  
09a2 3a b6 09			ld a, (.dmark)  
09a5 32 6e fe			ld (debug_mark),a  
09a8 3a b7 09			ld a, (.dmark+1)  
09ab 32 6f fe			ld (debug_mark+1),a  
09ae 3a b8 09			ld a, (.dmark+2)  
09b1 32 70 fe			ld (debug_mark+2),a  
09b4 18 03			jr .pastdmark  
09b6 ..			.dmark: db "srf"  
09b9 f1			.pastdmark: pop af  
09ba			endm  
# End of macro DMARK
09ba					CALLMONITOR 
09ba cd 9e 19			call break_point_state  
09bd				endm  
# End of macro CALLMONITOR
09bd				endif 
09bd cd 75 0f			call ishlzero 
09c0			;	ld a, l 
09c0			;	add h 
09c0			;	cp 0 
09c0 28 b1			jr z,.sr_fail			; block not found so EOF 
09c2			 
09c2				; save current address for use by higher level words etc 
09c2			 
09c2 22 72 fa			ld (store_openaddr),hl 
09c5			 
09c5			 
09c5				; hl contains page number to load 
09c5 d1				pop de   ; get storage 
09c6 ed 53 7d fa		ld (store_readbuf), de     ; current buffer to load in to 
09ca d5				push de 
09cb				if DEBUG_STORESE 
09cb					DMARK "srg" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6e fe			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6f fe			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 70 fe			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "srg"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd 9e 19			call break_point_state  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 1c 04			call storage_read_block 
09ea			 
09ea				; if this a continuation read??? 
09ea			 
09ea 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09ed			 
09ed 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ef cd 4c 0f			call addatohl 
09f2 7e				ld a,(hl) 
09f3 fe 00			cp 0 
09f5 28 02			jr z, .markiscont 
09f7 3e ff			ld a, 255 
09f9			 
09f9			.markiscont: 
09f9 32 74 fa			ld (store_readcont), a 
09fc			 
09fc				if DEBUG_STORESE 
09fc					DMARK "srC" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 6e fe			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 6f fe			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 70 fe			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "srC"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd 9e 19			call break_point_state  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18				; only short reads enabled 
0a18			 
0a18 3a 7c fa			ld a, (store_longread) 
0a1b fe 00			cp 0 
0a1d ca ea 0a			jp z, .readdone 
0a20			 
0a20			; TODO if block has no zeros then need to read next block  
0a20			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a20			; check last byte of physical block. 
0a20			; if not zero then the next block needs to be loaded 
0a20			 
0a20			 
0a20 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a23			 
0a23 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a25 cd 4c 0f			call addatohl 
0a28				;dec hl 
0a28 7e				ld a,(hl) 
0a29				if DEBUG_STORESE 
0a29					DMARK "sr?" 
0a29 f5				push af  
0a2a 3a 3e 0a			ld a, (.dmark)  
0a2d 32 6e fe			ld (debug_mark),a  
0a30 3a 3f 0a			ld a, (.dmark+1)  
0a33 32 6f fe			ld (debug_mark+1),a  
0a36 3a 40 0a			ld a, (.dmark+2)  
0a39 32 70 fe			ld (debug_mark+2),a  
0a3c 18 03			jr .pastdmark  
0a3e ..			.dmark: db "sr?"  
0a41 f1			.pastdmark: pop af  
0a42			endm  
# End of macro DMARK
0a42					CALLMONITOR 
0a42 cd 9e 19			call break_point_state  
0a45				endm  
# End of macro CALLMONITOR
0a45				endif 
0a45 fe 00			cp 0 
0a47 ca ea 0a			jp z, .readdone 
0a4a			 
0a4a				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a4a			 
0a4a 23				inc hl 
0a4b			 
0a4b 22 7d fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4e			 
0a4e ed 5b 7f fa		ld de, (store_readptr)     ; save the current extent to load 
0a52			 
0a52 eb				ex de, hl 
0a53			 
0a53				; next ext 
0a53			 
0a53 23				inc hl 
0a54 22 7f fa			ld  (store_readptr), hl     ; save the current extent to load 
0a57			 
0a57				if DEBUG_STORESE 
0a57					DMARK "sF2" 
0a57 f5				push af  
0a58 3a 6c 0a			ld a, (.dmark)  
0a5b 32 6e fe			ld (debug_mark),a  
0a5e 3a 6d 0a			ld a, (.dmark+1)  
0a61 32 6f fe			ld (debug_mark+1),a  
0a64 3a 6e 0a			ld a, (.dmark+2)  
0a67 32 70 fe			ld (debug_mark+2),a  
0a6a 18 03			jr .pastdmark  
0a6c ..			.dmark: db "sF2"  
0a6f f1			.pastdmark: pop af  
0a70			endm  
# End of macro DMARK
0a70					CALLMONITOR 
0a70 cd 9e 19			call break_point_state  
0a73				endm  
# End of macro CALLMONITOR
0a73				endif 
0a73			 
0a73				; get and load block 
0a73			 
0a73 cd 4f 07			call storage_findnextid 
0a76			 
0a76				if DEBUG_STORESE 
0a76					DMARK "sf2" 
0a76 f5				push af  
0a77 3a 8b 0a			ld a, (.dmark)  
0a7a 32 6e fe			ld (debug_mark),a  
0a7d 3a 8c 0a			ld a, (.dmark+1)  
0a80 32 6f fe			ld (debug_mark+1),a  
0a83 3a 8d 0a			ld a, (.dmark+2)  
0a86 32 70 fe			ld (debug_mark+2),a  
0a89 18 03			jr .pastdmark  
0a8b ..			.dmark: db "sf2"  
0a8e f1			.pastdmark: pop af  
0a8f			endm  
# End of macro DMARK
0a8f					CALLMONITOR 
0a8f cd 9e 19			call break_point_state  
0a92				endm  
# End of macro CALLMONITOR
0a92				endif 
0a92 cd 75 0f			call ishlzero 
0a95			;	ld a, l 
0a95			;	add h 
0a95			;	cp 0 
0a95 ca 73 09			jp z,.sr_fail			; block not found so EOF 
0a98				 
0a98				; save current address for use by higher level words etc 
0a98			 
0a98 22 72 fa			ld (store_openaddr),hl 
0a9b			 
0a9b cd 1c 04			call storage_read_block 
0a9e			 
0a9e				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9e				; we need to pull everything back  
0a9e			 
0a9e ed 5b 7d fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aa2 2a 7d fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa5 23				inc hl 
0aa6 23				inc hl     ; skip id and ext 
0aa7 01 40 00			ld bc, STORE_BLOCK_PHY 
0aaa				if DEBUG_STORESE 
0aaa					DMARK "SR<" 
0aaa f5				push af  
0aab 3a bf 0a			ld a, (.dmark)  
0aae 32 6e fe			ld (debug_mark),a  
0ab1 3a c0 0a			ld a, (.dmark+1)  
0ab4 32 6f fe			ld (debug_mark+1),a  
0ab7 3a c1 0a			ld a, (.dmark+2)  
0aba 32 70 fe			ld (debug_mark+2),a  
0abd 18 03			jr .pastdmark  
0abf ..			.dmark: db "SR<"  
0ac2 f1			.pastdmark: pop af  
0ac3			endm  
# End of macro DMARK
0ac3					CALLMONITOR 
0ac3 cd 9e 19			call break_point_state  
0ac6				endm  
# End of macro CALLMONITOR
0ac6				endif 
0ac6 ed b0			ldir     ; copy data 
0ac8			 
0ac8				; move the pointer back and pretend we have a full buffer for next recheck 
0ac8			 
0ac8 1b				dec de 
0ac9 1b				dec de 
0aca			 
0aca			; TODO do pop below now short circuit loop????? 
0aca c1				pop bc     ; get rid of spare de on stack 
0acb				if DEBUG_STORESE 
0acb					DMARK "SR>" 
0acb f5				push af  
0acc 3a e0 0a			ld a, (.dmark)  
0acf 32 6e fe			ld (debug_mark),a  
0ad2 3a e1 0a			ld a, (.dmark+1)  
0ad5 32 6f fe			ld (debug_mark+1),a  
0ad8 3a e2 0a			ld a, (.dmark+2)  
0adb 32 70 fe			ld (debug_mark+2),a  
0ade 18 03			jr .pastdmark  
0ae0 ..			.dmark: db "SR>"  
0ae3 f1			.pastdmark: pop af  
0ae4			endm  
# End of macro DMARK
0ae4					CALLMONITOR 
0ae4 cd 9e 19			call break_point_state  
0ae7				endm  
# End of macro CALLMONITOR
0ae7				endif 
0ae7 c3 78 09			jp .srext 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			.readdone:		 
0aea e1				pop hl 		 ; return start of data to show as not EOF 
0aeb 23				inc hl   ; past file id 
0aec 23				inc hl   ; past ext 
0aed				if DEBUG_STORESE 
0aed					DMARK "SRe" 
0aed f5				push af  
0aee 3a 02 0b			ld a, (.dmark)  
0af1 32 6e fe			ld (debug_mark),a  
0af4 3a 03 0b			ld a, (.dmark+1)  
0af7 32 6f fe			ld (debug_mark+1),a  
0afa 3a 04 0b			ld a, (.dmark+2)  
0afd 32 70 fe			ld (debug_mark+2),a  
0b00 18 03			jr .pastdmark  
0b02 ..			.dmark: db "SRe"  
0b05 f1			.pastdmark: pop af  
0b06			endm  
# End of macro DMARK
0b06					CALLMONITOR 
0b06 cd 9e 19			call break_point_state  
0b09				endm  
# End of macro CALLMONITOR
0b09				endif 
0b09 c9					ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			; 
0b0a			; Append File 
0b0a			; 
0b0a			; hl - file id to locate 
0b0a			; de - pointer to (multi block) string to write 
0b0a			 
0b0a			.sa_notfound: 
0b0a d1				pop de 
0b0b c9				ret 
0b0c			 
0b0c			 
0b0c			storage_append: 
0b0c				; hl -  file id to append to 
0b0c				; de - string to append 
0b0c			 
0b0c d5				push de 
0b0d				 
0b0d				if DEBUG_STORESE 
0b0d					DMARK "AP1" 
0b0d f5				push af  
0b0e 3a 22 0b			ld a, (.dmark)  
0b11 32 6e fe			ld (debug_mark),a  
0b14 3a 23 0b			ld a, (.dmark+1)  
0b17 32 6f fe			ld (debug_mark+1),a  
0b1a 3a 24 0b			ld a, (.dmark+2)  
0b1d 32 70 fe			ld (debug_mark+2),a  
0b20 18 03			jr .pastdmark  
0b22 ..			.dmark: db "AP1"  
0b25 f1			.pastdmark: pop af  
0b26			endm  
# End of macro DMARK
0b26					CALLMONITOR 
0b26 cd 9e 19			call break_point_state  
0b29				endm  
# End of macro CALLMONITOR
0b29				endif 
0b29			 
0b29 7d				ld a, l 
0b2a 32 75 fa			ld (store_tmpid), a 
0b2d			 
0b2d				; get file header  
0b2d			 
0b2d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2f 3a 75 fa			ld a, (store_tmpid) 
0b32 5f				ld e, a 
0b33			 
0b33 21 40 00				ld hl, STORE_BLOCK_PHY 
0b36 cd 4f 07				call storage_findnextid 
0b39			 
0b39 cd 75 0f			call ishlzero 
0b3c 28 cc			jr z, .sa_notfound 
0b3e			 
0b3e 22 6c fa			ld (store_tmppageid), hl 
0b41			 
0b41				; TODO handle file id not found 
0b41			 
0b41				if DEBUG_STORESE 
0b41					DMARK "AP2" 
0b41 f5				push af  
0b42 3a 56 0b			ld a, (.dmark)  
0b45 32 6e fe			ld (debug_mark),a  
0b48 3a 57 0b			ld a, (.dmark+1)  
0b4b 32 6f fe			ld (debug_mark+1),a  
0b4e 3a 58 0b			ld a, (.dmark+2)  
0b51 32 70 fe			ld (debug_mark+2),a  
0b54 18 03			jr .pastdmark  
0b56 ..			.dmark: db "AP2"  
0b59 f1			.pastdmark: pop af  
0b5a			endm  
# End of macro DMARK
0b5a					CALLMONITOR 
0b5a cd 9e 19			call break_point_state  
0b5d				endm  
# End of macro CALLMONITOR
0b5d				endif 
0b5d			 
0b5d				; update file extent count 
0b5d			 
0b5d 11 81 fa			ld de, store_page 
0b60			 
0b60 cd 1c 04			call storage_read_block 
0b63			 
0b63				if DEBUG_STORESE 
0b63					DMARK "AP3" 
0b63 f5				push af  
0b64 3a 78 0b			ld a, (.dmark)  
0b67 32 6e fe			ld (debug_mark),a  
0b6a 3a 79 0b			ld a, (.dmark+1)  
0b6d 32 6f fe			ld (debug_mark+1),a  
0b70 3a 7a 0b			ld a, (.dmark+2)  
0b73 32 70 fe			ld (debug_mark+2),a  
0b76 18 03			jr .pastdmark  
0b78 ..			.dmark: db "AP3"  
0b7b f1			.pastdmark: pop af  
0b7c			endm  
# End of macro DMARK
0b7c					CALLMONITOR 
0b7c cd 9e 19			call break_point_state  
0b7f				endm  
# End of macro CALLMONITOR
0b7f				endif 
0b7f			;	ld (store_tmppageid), hl 
0b7f			 
0b7f 3a 83 fa			ld a, (store_page+2) 
0b82 3c				inc a 
0b83 32 83 fa			ld (store_page+2), a 
0b86 32 74 fa			ld (store_tmpext), a 
0b89				 
0b89				if DEBUG_STORESE 
0b89					DMARK "AP3" 
0b89 f5				push af  
0b8a 3a 9e 0b			ld a, (.dmark)  
0b8d 32 6e fe			ld (debug_mark),a  
0b90 3a 9f 0b			ld a, (.dmark+1)  
0b93 32 6f fe			ld (debug_mark+1),a  
0b96 3a a0 0b			ld a, (.dmark+2)  
0b99 32 70 fe			ld (debug_mark+2),a  
0b9c 18 03			jr .pastdmark  
0b9e ..			.dmark: db "AP3"  
0ba1 f1			.pastdmark: pop af  
0ba2			endm  
# End of macro DMARK
0ba2					CALLMONITOR 
0ba2 cd 9e 19			call break_point_state  
0ba5				endm  
# End of macro CALLMONITOR
0ba5				endif 
0ba5 2a 6c fa			ld hl, (store_tmppageid) 
0ba8 11 81 fa			ld de, store_page 
0bab cd 81 04			call storage_write_block 
0bae			 
0bae				; find free block 
0bae			 
0bae 11 00 00			ld de, 0			 ; file extent to locate 
0bb1			 
0bb1 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb4 cd 4f 07				call storage_findnextid 
0bb7 cd 75 0f			call ishlzero 
0bba ca 0a 0b			jp z, .sa_notfound 
0bbd			 
0bbd					; TODO handle no space left 
0bbd					 
0bbd 22 6c fa				ld (store_tmppageid), hl 
0bc0			 
0bc0				if DEBUG_STORESE 
0bc0					DMARK "AP4" 
0bc0 f5				push af  
0bc1 3a d5 0b			ld a, (.dmark)  
0bc4 32 6e fe			ld (debug_mark),a  
0bc7 3a d6 0b			ld a, (.dmark+1)  
0bca 32 6f fe			ld (debug_mark+1),a  
0bcd 3a d7 0b			ld a, (.dmark+2)  
0bd0 32 70 fe			ld (debug_mark+2),a  
0bd3 18 03			jr .pastdmark  
0bd5 ..			.dmark: db "AP4"  
0bd8 f1			.pastdmark: pop af  
0bd9			endm  
# End of macro DMARK
0bd9					CALLMONITOR 
0bd9 cd 9e 19			call break_point_state  
0bdc				endm  
# End of macro CALLMONITOR
0bdc				endif 
0bdc					; init the buffer with zeros so we can id if the buffer is full or not 
0bdc			 
0bdc e5					push hl 
0bdd c5					push bc 
0bde			 
0bde 21 81 fa				ld hl, store_page 
0be1 06 40				ld b, STORE_BLOCK_PHY 
0be3 3e 00				ld a, 0 
0be5 77			.zeroblock:	ld (hl), a 
0be6 23					inc hl 
0be7 10 fc				djnz .zeroblock 
0be9			 
0be9 c1					pop bc 
0bea e1					pop hl 
0beb			 
0beb					; construct block 
0beb			 
0beb 3a 75 fa				ld a, (store_tmpid) 
0bee 32 81 fa				ld (store_page), a   ; file id 
0bf1 3a 74 fa				ld a, (store_tmpext)   ; extent for this block 
0bf4 32 82 fa				ld (store_page+1), a 
0bf7			 
0bf7 e1					pop hl    ; get string to write 
0bf8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bfa 11 83 fa				ld de, store_page+2 
0bfd			 
0bfd				if DEBUG_STORESE 
0bfd					DMARK "AP5" 
0bfd f5				push af  
0bfe 3a 12 0c			ld a, (.dmark)  
0c01 32 6e fe			ld (debug_mark),a  
0c04 3a 13 0c			ld a, (.dmark+1)  
0c07 32 6f fe			ld (debug_mark+1),a  
0c0a 3a 14 0c			ld a, (.dmark+2)  
0c0d 32 70 fe			ld (debug_mark+2),a  
0c10 18 03			jr .pastdmark  
0c12 ..			.dmark: db "AP5"  
0c15 f1			.pastdmark: pop af  
0c16			endm  
# End of macro DMARK
0c16					CALLMONITOR 
0c16 cd 9e 19			call break_point_state  
0c19				endm  
# End of macro CALLMONITOR
0c19				endif 
0c19			 
0c19			 
0c19			 
0c19					; fill buffer with data until end of string or full block 
0c19			 
0c19 7e			.appd:		ld a, (hl) 
0c1a 12					ld (de), a 
0c1b fe 00				cp 0 
0c1d 28 04				jr z, .appdone 
0c1f 23					inc hl 
0c20 13					inc de 
0c21 10 f6				djnz .appd 
0c23			 
0c23 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c24 f5					push af   		; save last byte dumped 
0c25			 
0c25			 
0c25 2a 6c fa			ld hl, (store_tmppageid) 
0c28 11 81 fa			ld de, store_page 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP6" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 6e fe			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 6f fe			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 70 fe			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP6"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd 9e 19			call break_point_state  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47 cd 81 04				call storage_write_block 
0c4a			 
0c4a			 
0c4a				; was that a full block of data written? 
0c4a				; any more to write out? 
0c4a			 
0c4a				; if yes then set vars and jump to start of function again 
0c4a			 
0c4a f1					pop af 
0c4b d1					pop de 
0c4c			 
0c4c fe 00				cp 0		 ; no, string was fully written 
0c4e c8					ret z 
0c4f			 
0c4f					; setup vars for next cycle 
0c4f			 
0c4f 3a 75 fa				ld a, (store_tmpid) 
0c52 6f					ld l, a 
0c53 26 00				ld h, 0 
0c55			 
0c55 c3 0c 0b			 	jp storage_append	 ; yes, need to write out some more 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			if DEBUG_STORECF 
0c58			storageput:	 
0c58					ret 
0c58			storageread: 
0c58					ld hl, store_page 
0c58					ld b, 200 
0c58					ld a,0 
0c58			.src:		ld (hl),a 
0c58					inc hl 
0c58					djnz .src 
0c58					 
0c58			 
0c58					ld de, 0 
0c58					ld bc, 1 
0c58					ld hl, store_page 
0c58					call cfRead 
0c58			 
0c58				call cfGetError 
0c58				ld hl,scratch 
0c58				call hexout 
0c58				ld hl, scratch+2 
0c58				ld a, 0 
0c58				ld (hl),a 
0c58				ld de, scratch 
0c58				ld a,display_row_1 
0c58				call str_at_display 
0c58				call update_display 
0c58			 
0c58					ld hl, store_page 
0c58					ld (os_cur_ptr),hl 
0c58			 
0c58					ret 
0c58			endif 
0c58			 
0c58			 
0c58			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c58			 
0c58			storage_clear_page: 
0c58 e5				push hl 
0c59 d5				push de 
0c5a c5				push bc 
0c5b 21 81 fa			ld hl, store_page 
0c5e 3e 00			ld a, 0 
0c60 77				ld (hl), a 
0c61			 
0c61 11 82 fa			ld de, store_page+1 
0c64 01 18 01			ld bc, STORE_BLOCK_LOG 
0c67			 
0c67 ed b0			ldir 
0c69				 
0c69 c1				pop bc 
0c6a d1				pop de 
0c6b e1				pop hl 
0c6c c9				ret 
0c6d			 
0c6d			; eof 
# End of file firmware_storage.asm
0c6d			  
0c6d			; support routines for above hardware abstraction layer  
0c6d			  
0c6d			include "firmware_general.asm"        ; general support functions  
0c6d			 
0c6d			; word look up 
0c6d			 
0c6d			; in 
0c6d			; a is the index 
0c6d			; hl is pointer start of array 
0c6d			; 
0c6d			; returns 
0c6d			; hl to the word 
0c6d			; 
0c6d			 
0c6d			table_lookup:  
0c6d d5					push de 
0c6e eb					ex de, hl 
0c6f			 
0c6f 6f					ld l, a 
0c70 26 00				ld h, 0 
0c72 29					add hl, hl 
0c73 19					add hl, de 
0c74 7e					ld a, (hl) 
0c75 23					inc hl 
0c76 66					ld h,(hl) 
0c77 6f					ld l, a 
0c78			 
0c78 d1					pop de 
0c79 c9					ret 
0c7a			 
0c7a			; Delay loops 
0c7a			 
0c7a			 
0c7a			 
0c7a			aDelayInMS: 
0c7a c5				push bc 
0c7b 47				ld b,a 
0c7c			msdelay: 
0c7c c5				push bc 
0c7d				 
0c7d			 
0c7d 01 41 00			ld bc,041h 
0c80 cd 98 0c			call delayloop 
0c83 c1				pop bc 
0c84 05				dec b 
0c85 20 f5			jr nz,msdelay 
0c87			 
0c87			;if CPU_CLOCK_8MHZ 
0c87			;msdelay8: 
0c87			;	push bc 
0c87			;	 
0c87			; 
0c87			;	ld bc,041h 
0c87			;	call delayloop 
0c87			;	pop bc 
0c87			;	dec b 
0c87			;	jr nz,msdelay8 
0c87			;endif 
0c87			 
0c87			 
0c87 c1				pop bc 
0c88 c9				ret 
0c89			 
0c89			 
0c89			delay250ms: 
0c89				;push de 
0c89 01 00 40			ld bc, 04000h 
0c8c c3 98 0c			jp delayloop 
0c8f			delay500ms: 
0c8f				;push de 
0c8f 01 00 80			ld bc, 08000h 
0c92 c3 98 0c			jp delayloop 
0c95			delay1s: 
0c95				;push bc 
0c95			   ; Clobbers A, d and e 
0c95 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c98			delayloop: 
0c98 c5			    push bc 
0c99			 
0c99			if BASE_CPM 
0c99				ld bc, CPM_DELAY_TUNE 
0c99			.cpmloop: 
0c99				push bc 
0c99			 
0c99			endif 
0c99			 
0c99			 
0c99			 
0c99			delayloopi: 
0c99			;	push bc 
0c99			;.dl: 
0c99 cb 47		    bit     0,a    	; 8 
0c9b cb 47		    bit     0,a    	; 8 
0c9d cb 47		    bit     0,a    	; 8 
0c9f e6 ff		    and     255  	; 7 
0ca1 0b			    dec     bc      	; 6 
0ca2 79			    ld      a,c     	; 4 
0ca3 b0			    or      b     	; 4 
0ca4 c2 99 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca7			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca7				;pop de 
0ca7			;pop bc 
0ca7			 
0ca7			if BASE_CPM 
0ca7				pop bc 
0ca7				 
0ca7			    dec     bc      	; 6 
0ca7			    ld      a,c     	; 4 
0ca7			    or      b     	; 4 
0ca7			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca7				 
0ca7			 
0ca7			endif 
0ca7			;if CPU_CLOCK_8MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7			 
0ca7			;if CPU_CLOCK_10MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7 c1			    pop bc 
0ca8			 
0ca8 c9				ret 
0ca9			 
0ca9			 
0ca9			 
0ca9			; eof 
# End of file firmware_general.asm
0ca9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca9			; display routines that use the physical hardware abstraction layer 
0ca9			 
0ca9			 
0ca9			; information window 
0ca9			 
0ca9			; pass hl with 1st string to display 
0ca9			; pass de with 2nd string to display 
0ca9			 
0ca9			info_panel: 
0ca9 e5				push hl 
0caa			 
0caa 2a cf fb			ld hl, (display_fb_active) 
0cad e5				push hl    ; future de destination 
0cae 21 b4 fd				ld hl, display_fb0 
0cb1 22 cf fb				ld (display_fb_active), hl 
0cb4			 
0cb4			;	call clear_display 
0cb4			 
0cb4				if BASE_CPM 
0cb4				ld a, '.' 
0cb4				else 
0cb4 3e a5			ld a, 165 
0cb6				endif 
0cb6 cd 1d 0d			call fill_display 
0cb9			 
0cb9			 
0cb9 3e 55			ld a, display_row_3 + 5 
0cbb cd 2b 0d			call str_at_display 
0cbe			 
0cbe e1				pop hl 
0cbf d1				pop de 
0cc0			 
0cc0 e5				push hl 
0cc1			 
0cc1			 
0cc1 3e 2d			ld a, display_row_2 + 5 
0cc3 cd 2b 0d			call str_at_display 
0cc6			 
0cc6			 
0cc6 cd 3b 0d			call update_display 
0cc9 cd e1 1f			call next_page_prompt 
0ccc cd 18 0d			call clear_display 
0ccf			 
0ccf				 
0ccf 21 13 fd				ld hl, display_fb1 
0cd2 22 cf fb				ld (display_fb_active), hl 
0cd5 cd 3b 0d			call update_display 
0cd8			 
0cd8 e1				pop hl 
0cd9			 
0cd9 c9				ret 
0cda			 
0cda			 
0cda			 
0cda			 
0cda			; TODO windowing? 
0cda			 
0cda			; TODO scroll line up 
0cda			 
0cda			scroll_up: 
0cda			 
0cda e5				push hl 
0cdb d5				push de 
0cdc c5				push bc 
0cdd			 
0cdd				; get frame buffer  
0cdd			 
0cdd 2a cf fb			ld hl, (display_fb_active) 
0ce0 e5				push hl    ; future de destination 
0ce1			 
0ce1 11 28 00			ld  de, display_cols 
0ce4 19				add hl, de 
0ce5			 
0ce5 d1				pop de 
0ce6			 
0ce6				;ex de, hl 
0ce6 01 9f 00			ld bc, display_fb_len -1  
0ce9			;if DEBUG_FORTH_WORDS 
0ce9			;	DMARK "SCL" 
0ce9			;	CALLMONITOR 
0ce9			;endif	 
0ce9 ed b0			ldir 
0ceb			 
0ceb				; wipe bottom row 
0ceb			 
0ceb			 
0ceb 2a cf fb			ld hl, (display_fb_active) 
0cee 11 a0 00			ld de, display_cols*display_rows 
0cf1 19				add hl, de 
0cf2 06 28			ld b, display_cols 
0cf4 3e 20			ld a, ' ' 
0cf6			.scwipe: 
0cf6 77				ld (hl), a 
0cf7 2b				dec hl 
0cf8 10 fc			djnz .scwipe 
0cfa			 
0cfa				;pop hl 
0cfa			 
0cfa c1				pop bc 
0cfb d1				pop de 
0cfc e1				pop hl 
0cfd			 
0cfd c9				ret 
0cfe			 
0cfe			 
0cfe			;scroll_upo: 
0cfe			;	ld de, display_row_1 
0cfe			 ;	ld hl, display_row_2 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_2 
0cfe			 ;	ld hl, display_row_3 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_3 
0cfe			 ;	ld hl, display_row_4 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			 
0cfe			; TODO clear row 4 
0cfe			 
0cfe			;	ret 
0cfe			 
0cfe				 
0cfe			scroll_down: 
0cfe			 
0cfe e5				push hl 
0cff d5				push de 
0d00 c5				push bc 
0d01			 
0d01				; get frame buffer  
0d01			 
0d01 2a cf fb			ld hl, (display_fb_active) 
0d04			 
0d04 11 9f 00			ld de, display_fb_len - 1 
0d07 19				add hl, de 
0d08			 
0d08 e5			push hl    ; future de destination 
0d09			 
0d09 11 28 00			ld  de, display_cols 
0d0c ed 52			sbc hl, de 
0d0e			 
0d0e			 
0d0e d1				pop de 
0d0f			 
0d0f			;	ex de, hl 
0d0f 01 9f 00			ld bc, display_fb_len -1  
0d12			 
0d12			 
0d12				 
0d12			 
0d12 ed b0			ldir 
0d14			 
0d14				; wipe bottom row 
0d14			 
0d14			 
0d14			;	ld hl, (display_fb_active) 
0d14			;;	ld de, display_cols*display_rows 
0d14			;;	add hl, de 
0d14			;	ld b, display_cols 
0d14			;	ld a, ' ' 
0d14			;.scwiped: 
0d14			;	ld (hl), a 
0d14			;	dec hl 
0d14			;	djnz .scwiped 
0d14			 
0d14				;pop hl 
0d14			 
0d14 c1				pop bc 
0d15 d1				pop de 
0d16 e1				pop hl 
0d17			 
0d17 c9				ret 
0d18			;scroll_down: 
0d18			;	ld de, display_row_4 
0d18			;	ld hl, display_row_3 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_3 
0d18			; 	ld hl, display_row_2 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_2 
0d18			;	ld hl, display_row_1 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;;; TODO clear row 1 
0d18			;	ret 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			; clear active frame buffer 
0d18			 
0d18			clear_display: 
0d18 3e 20			ld a, ' ' 
0d1a c3 1d 0d			jp fill_display 
0d1d			 
0d1d			; fill active frame buffer with a char in A 
0d1d			 
0d1d			fill_display: 
0d1d 06 a0			ld b,display_fb_len 
0d1f 2a cf fb			ld hl, (display_fb_active) 
0d22 77			.fd1:	ld (hl),a 
0d23 23				inc hl 
0d24 10 fc			djnz .fd1 
0d26 23				inc hl 
0d27 3e 00			ld a,0 
0d29 77				ld (hl),a 
0d2a			 
0d2a			 
0d2a c9				ret 
0d2b			; Write string (DE) at pos (A) to active frame buffer 
0d2b			 
0d2b 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0d2e 06 00					ld b,0 
0d30 4f					ld c,a 
0d31 09					add hl,bc 
0d32 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d33 b7			            OR   A              ;Null terminator? 
0d34 c8			            RET  Z              ;Yes, so finished 
0d35 77					ld (hl),a 
0d36 23				inc hl 
0d37 13			            INC  DE             ;Point to next character 
0d38 18 f8		            JR   .sad1     ;Repeat 
0d3a c9					ret 
0d3b			 
0d3b			; using current frame buffer write to physical display 
0d3b			 
0d3b			update_display: 
0d3b e5				push hl 
0d3c 2a cf fb			ld hl, (display_fb_active) 
0d3f cd 63 74			call write_display 
0d42 e1				pop hl 
0d43 c9				ret 
0d44			 
0d44			; TODO scrolling 
0d44			 
0d44			 
0d44			; move cursor right one char 
0d44			cursor_right: 
0d44			 
0d44				; TODO shift right 
0d44				; TODO if beyond max col 
0d44				; TODO       cursor_next_line 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			cursor_next_line: 
0d45				; TODO first char 
0d45				; TODO line down 
0d45				; TODO if past last row 
0d45				; TODO    scroll up 
0d45			 
0d45 c9				ret 
0d46			 
0d46			cursor_left: 
0d46				; TODO shift left 
0d46				; TODO if beyond left  
0d46				; TODO     cursor prev line 
0d46				 
0d46 c9				ret 
0d47			 
0d47			cursor_prev_line: 
0d47				; TODO last char 
0d47				; TODO line up 
0d47				; TODO if past first row 
0d47				; TODO   scroll down 
0d47			 
0d47 c9				ret 
0d48			 
0d48			 
0d48			cout: 
0d48				; A - char 
0d48 c9				ret 
0d49			 
0d49			 
0d49			; Display a menu and allow item selection (optional toggle items) 
0d49			; 
0d49			; format: 
0d49			; hl pointer to word array with zero term for items 
0d49			; e.g.    db item1 
0d49			;         db .... 
0d49			;         db 0 
0d49			; 
0d49			; a = starting menu item  
0d49			; 
0d49			; de = pointer item toggle array   (todo) 
0d49			; 
0d49			; returns item selected in a 1-... 
0d49			; returns 0 if back button pressed 
0d49			; 
0d49			; NOTE: Uses system frame buffer to display 
0d49			; 
0d49			; LEFT, Q = go back 
0d49			; RIGHT, SPACE, CR = select 
0d49			; UP, A - Up 
0d49			; DOWN, Z - Down 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			menu: 
0d49			 
0d49					; keep array pointer 
0d49			 
0d49 22 7a fa				ld (store_tmp1), hl 
0d4c 32 78 fa				ld (store_tmp2), a 
0d4f			 
0d4f					; check for key bounce 
0d4f			 
0d4f			if BASE_KEV 
0d4f			 
0d4f cd ae 77		.mbounce:	call cin 
0d52 fe 00				cp 0 
0d54 20 f9				jr nz, .mbounce 
0d56			endif 
0d56					; for ease use ex 
0d56			 
0d56					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d56 21 b4 fd				ld hl, display_fb0 
0d59 22 cf fb				ld (display_fb_active), hl 
0d5c			 
0d5c cd 18 0d		.mloop:		call clear_display 
0d5f cd 3b 0d				call update_display 
0d62			 
0d62					; draw selection id '>' at 1 
0d62			 
0d62					; init start of list display 
0d62			 
0d62 3e 05				ld a, 5 
0d64 32 76 fa				ld (store_tmp3), a   ; display row count 
0d67 3a 78 fa				ld a,( store_tmp2) 
0d6a 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d6d			 
0d6d					 
0d6d			.mitem:	 
0d6d			 
0d6d			 
0d6d 3a 79 fa				ld a,(store_tmp2+1) 
0d70 6f					ld l, a 
0d71 26 00				ld h, 0 
0d73 29					add hl, hl 
0d74 ed 5b 7a fa			ld de, (store_tmp1) 
0d78 19					add hl, de 
0d79 7e					ld a, (hl) 
0d7a 23					inc hl 
0d7b 66					ld h,(hl) 
0d7c 6f					ld l, a 
0d7d			 
0d7d cd 75 0f				call ishlzero 
0d80 28 1a				jr z, .mdone 
0d82			 
0d82 eb					ex de, hl 
0d83 3a 76 fa				ld a, (store_tmp3) 
0d86 cd 2b 0d				call str_at_display 
0d89					 
0d89			 
0d89					; next item 
0d89 3a 79 fa				ld a, (store_tmp2+1) 
0d8c 3c					inc a 
0d8d 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d90			 
0d90			 		; next row 
0d90			 
0d90 3a 76 fa				ld a, (store_tmp3) 
0d93 c6 28				add display_cols 
0d95 32 76 fa				ld (store_tmp3), a 
0d98			 
0d98					; at end of screen? 
0d98			 
0d98 fe 10				cp display_rows*4 
0d9a 20 d1				jr nz, .mitem 
0d9c			 
0d9c			 
0d9c			.mdone: 
0d9c cd 75 0f				call ishlzero 
0d9f 28 08				jr z, .nodn 
0da1			 
0da1 3e 78				ld a, display_row_4 
0da3 11 22 0e				ld de, .mdown 
0da6 cd 2b 0d				call str_at_display 
0da9			 
0da9					; draw options to fill the screens with active item on line 1 
0da9					; if current option is 2 or more then display ^ in top 
0da9			 
0da9 3a 78 fa		.nodn:		ld a, (store_tmp2) 
0dac fe 00				cp 0 
0dae 28 08				jr z, .noup 
0db0			 
0db0 3e 00				ld a, 0 
0db2 11 20 0e				ld de, .mup 
0db5 cd 2b 0d				call str_at_display 
0db8			 
0db8 3e 02		.noup:		ld a, 2 
0dba 11 1e 0e				ld de, .msel 
0dbd cd 2b 0d				call str_at_display 
0dc0			 
0dc0					; if current option + 1 is not null then display V in bottom 
0dc0					; get key 
0dc0 cd 3b 0d				call update_display 
0dc3			 
0dc3			 
0dc3					; handle key 
0dc3			 
0dc3 cd 9d 77				call cin_wait 
0dc6			 
0dc6 fe 05				cp KEY_UP 
0dc8 28 2b				jr z, .mgoup 
0dca fe 61				cp 'a' 
0dcc 28 27				jr z, .mgoup 
0dce fe 0a				cp KEY_DOWN 
0dd0 28 32				jr z, .mgod 
0dd2 fe 7a				cp 'z' 
0dd4 28 2e				jr z, .mgod 
0dd6 fe 20				cp ' ' 
0dd8 28 34				jr z, .goend 
0dda fe 0c				cp KEY_RIGHT 
0ddc 28 30				jr z, .goend 
0dde fe 0d				cp KEY_CR 
0de0 28 2c				jr z, .goend 
0de2 fe 71				cp 'q' 
0de4 28 0b				jr z, .goback 
0de6			 
0de6 fe 0b				cp KEY_LEFT 
0de8 28 07				jr z, .goback 
0dea fe 08				cp KEY_BS 
0dec 28 03				jr z, .goback 
0dee c3 5c 0d				jp .mloop 
0df1			 
0df1			.goback: 
0df1 3e 00			ld a, 0 
0df3 18 1d			jr .goend2 
0df5			 
0df5				; move up one 
0df5			.mgoup: 
0df5 3a 78 fa				ld a, (store_tmp2) 
0df8 fe 00				cp 0 
0dfa ca 5c 0d				jp z, .mloop 
0dfd 3d					dec a 
0dfe 32 78 fa				ld (store_tmp2), a 
0e01 c3 5c 0d				jp .mloop 
0e04			 
0e04				; move down one 
0e04			.mgod: 
0e04 3a 78 fa				ld a, (store_tmp2) 
0e07 3c					inc a 
0e08 32 78 fa				ld (store_tmp2), a 
0e0b c3 5c 0d				jp .mloop 
0e0e			 
0e0e			 
0e0e			.goend: 
0e0e					; get selected item number 
0e0e			 
0e0e 3a 78 fa				ld a, (store_tmp2) 
0e11 3c					inc a 
0e12			 
0e12			.goend2: 
0e12 f5					push af 
0e13			 
0e13					; restore active fb 
0e13					; TODO BUG assumes fb1 
0e13			 
0e13 21 13 fd				ld hl, display_fb1 
0e16 22 cf fb				ld (display_fb_active), hl 
0e19			 
0e19					; restore main regs 
0e19			 
0e19			 
0e19 cd 3b 0d				call update_display 
0e1c			 
0e1c f1					pop af 
0e1d			 
0e1d c9				ret 
0e1e			 
0e1e .. 00		.msel:   db ">",0 
0e20 .. 00		.mup:   db "^",0 
0e22 .. 00		.mdown:   db "v",0 
0e24			 
0e24			 
0e24			; eof 
0e24			 
# End of file firmware_display.asm
0e24			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e24			; random number generators 
0e24			 
0e24			 
0e24			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e24			 
0e24			 
0e24			;-----> Generate a random number 
0e24			; output a=answer 0<=a<=255 
0e24			; all registers are preserved except: af 
0e24			random: 
0e24 e5			        push    hl 
0e25 d5			        push    de 
0e26 2a b1 fb		        ld      hl,(randData) 
0e29 ed 5f		        ld      a,r 
0e2b 57			        ld      d,a 
0e2c 5e			        ld      e,(hl) 
0e2d 19			        add     hl,de 
0e2e 85			        add     a,l 
0e2f ac			        xor     h 
0e30 22 b1 fb		        ld      (randData),hl 
0e33 d1			        pop     de 
0e34 e1			        pop     hl 
0e35 c9			        ret 
0e36			 
0e36			 
0e36			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e36			 
0e36			 
0e36			 
0e36			;------LFSR------ 
0e36			;James Montelongo 
0e36			;optimized by Spencer Putt 
0e36			;out: 
0e36			; a = 8 bit random number 
0e36			RandLFSR: 
0e36 21 b7 fb		        ld hl,LFSRSeed+4 
0e39 5e			        ld e,(hl) 
0e3a 23			        inc hl 
0e3b 56			        ld d,(hl) 
0e3c 23			        inc hl 
0e3d 4e			        ld c,(hl) 
0e3e 23			        inc hl 
0e3f 7e			        ld a,(hl) 
0e40 47			        ld b,a 
0e41 cb 13		        rl e  
0e43 cb 12			rl d 
0e45 cb 11		        rl c  
0e47 17				rla 
0e48 cb 13		        rl e  
0e4a cb 12			rl d 
0e4c cb 11		        rl c  
0e4e 17				rla 
0e4f cb 13		        rl e  
0e51 cb 12			rl d 
0e53 cb 11		        rl c  
0e55 17				rla 
0e56 67			        ld h,a 
0e57 cb 13		        rl e  
0e59 cb 12			rl d 
0e5b cb 11		        rl c  
0e5d 17				rla 
0e5e a8			        xor b 
0e5f cb 13		        rl e  
0e61 cb 12			rl d 
0e63 ac			        xor h 
0e64 a9			        xor c 
0e65 aa			        xor d 
0e66 21 b9 fb		        ld hl,LFSRSeed+6 
0e69 11 ba fb		        ld de,LFSRSeed+7 
0e6c 01 07 00		        ld bc,7 
0e6f ed b8		        lddr 
0e71 12			        ld (de),a 
0e72 c9			        ret 
0e73			 
0e73			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e73			 
0e73			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e73			 
0e73			 
0e73			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e73			 
0e73			prng16: 
0e73			;Inputs: 
0e73			;   (seed1) contains a 16-bit seed value 
0e73			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e73			;Outputs: 
0e73			;   HL is the result 
0e73			;   BC is the result of the LCG, so not that great of quality 
0e73			;   DE is preserved 
0e73			;Destroys: 
0e73			;   AF 
0e73			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e73			;160cc 
0e73			;26 bytes 
0e73 2a ab fb		    ld hl,(seed1) 
0e76 44			    ld b,h 
0e77 4d			    ld c,l 
0e78 29			    add hl,hl 
0e79 29			    add hl,hl 
0e7a 2c			    inc l 
0e7b 09			    add hl,bc 
0e7c 22 ab fb		    ld (seed1),hl 
0e7f 2a a9 fb		    ld hl,(seed2) 
0e82 29			    add hl,hl 
0e83 9f			    sbc a,a 
0e84 e6 2d		    and %00101101 
0e86 ad			    xor l 
0e87 6f			    ld l,a 
0e88 22 a9 fb		    ld (seed2),hl 
0e8b 09			    add hl,bc 
0e8c c9			    ret 
0e8d			 
0e8d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e8d			 
0e8d			rand32: 
0e8d			;Inputs: 
0e8d			;   (seed1_0) holds the lower 16 bits of the first seed 
0e8d			;   (seed1_1) holds the upper 16 bits of the first seed 
0e8d			;   (seed2_0) holds the lower 16 bits of the second seed 
0e8d			;   (seed2_1) holds the upper 16 bits of the second seed 
0e8d			;   **NOTE: seed2 must be non-zero 
0e8d			;Outputs: 
0e8d			;   HL is the result 
0e8d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e8d			;Destroys: 
0e8d			;   AF 
0e8d			;Tested and passes all CAcert tests 
0e8d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e8d			;it has a period of 18,446,744,069,414,584,320 
0e8d			;roughly 18.4 quintillion. 
0e8d			;LFSR taps: 0,2,6,7  = 11000101 
0e8d			;291cc 
0e8d			;seed1_0=$+1 
0e8d			;    ld hl,12345 
0e8d			;seed1_1=$+1 
0e8d			;    ld de,6789 
0e8d			;    ld b,h 
0e8d			;    ld c,l 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    inc l 
0e8d			;    add hl,bc 
0e8d			;    ld (seed1_0),hl 
0e8d			;    ld hl,(seed1_1) 
0e8d			;    adc hl,de 
0e8d			;    ld (seed1_1),hl 
0e8d			;    ex de,hl 
0e8d			;seed2_0=$+1 
0e8d			;    ld hl,9876 
0e8d			;seed2_1=$+1 
0e8d			;    ld bc,54321 
0e8d			;    add hl,hl \ rl c \ rl b 
0e8d			;    ld (seed2_1),bc 
0e8d			;    sbc a,a 
0e8d			;    and %11000101 
0e8d			;    xor l 
0e8d			;    ld l,a 
0e8d			;    ld (seed2_0),hl 
0e8d			;    ex de,hl 
0e8d			;    add hl,bc 
0e8d			;    ret 
0e8d			; 
0e8d			 
0e8d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e8d			; 20 bytes, 86 cycles (excluding ret) 
0e8d			 
0e8d			; returns   hl = pseudorandom number 
0e8d			; corrupts   a 
0e8d			 
0e8d			; generates 16-bit pseudorandom numbers with a period of 65535 
0e8d			; using the xorshift method: 
0e8d			 
0e8d			; hl ^= hl << 7 
0e8d			; hl ^= hl >> 9 
0e8d			; hl ^= hl << 8 
0e8d			 
0e8d			; some alternative shift triplets which also perform well are: 
0e8d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e8d			 
0e8d			;  org 32768 
0e8d			 
0e8d			xrnd: 
0e8d 2a af fb		  ld hl,(xrandc)       ; seed must not be 0 
0e90 3e 00		  ld a,0 
0e92 bd			  cp l 
0e93 20 02		  jr nz, .xrnd1 
0e95 2e 01		  ld l, 1 
0e97			.xrnd1: 
0e97			 
0e97 7c			  ld a,h 
0e98 1f			  rra 
0e99 7d			  ld a,l 
0e9a 1f			  rra 
0e9b ac			  xor h 
0e9c 67			  ld h,a 
0e9d 7d			  ld a,l 
0e9e 1f			  rra 
0e9f 7c			  ld a,h 
0ea0 1f			  rra 
0ea1 ad			  xor l 
0ea2 6f			  ld l,a 
0ea3 ac			  xor h 
0ea4 67			  ld h,a 
0ea5			 
0ea5 22 af fb		  ld (xrandc),hl 
0ea8			 
0ea8 c9			  ret 
0ea9			;  
0ea9			 
0ea9			 
0ea9			;;;; int maths 
0ea9			 
0ea9			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ea9			; Divide 16-bit values (with 16-bit result) 
0ea9			; In: Divide BC by divider DE 
0ea9			; Out: BC = result, HL = rest 
0ea9			; 
0ea9			Div16: 
0ea9 21 00 00		    ld hl,0 
0eac 78			    ld a,b 
0ead 06 08		    ld b,8 
0eaf			Div16_Loop1: 
0eaf 17			    rla 
0eb0 ed 6a		    adc hl,hl 
0eb2 ed 52		    sbc hl,de 
0eb4 30 01		    jr nc,Div16_NoAdd1 
0eb6 19			    add hl,de 
0eb7			Div16_NoAdd1: 
0eb7 10 f6		    djnz Div16_Loop1 
0eb9 17			    rla 
0eba 2f			    cpl 
0ebb 47			    ld b,a 
0ebc 79			    ld a,c 
0ebd 48			    ld c,b 
0ebe 06 08		    ld b,8 
0ec0			Div16_Loop2: 
0ec0 17			    rla 
0ec1 ed 6a		    adc hl,hl 
0ec3 ed 52		    sbc hl,de 
0ec5 30 01		    jr nc,Div16_NoAdd2 
0ec7 19			    add hl,de 
0ec8			Div16_NoAdd2: 
0ec8 10 f6		    djnz Div16_Loop2 
0eca 17			    rla 
0ecb 2f			    cpl 
0ecc 41			    ld b,c 
0ecd 4f			    ld c,a 
0ece c9			ret 
0ecf			 
0ecf			 
0ecf			;http://z80-heaven.wikidot.com/math 
0ecf			; 
0ecf			;Inputs: 
0ecf			;     DE and A are factors 
0ecf			;Outputs: 
0ecf			;     A is not changed 
0ecf			;     B is 0 
0ecf			;     C is not changed 
0ecf			;     DE is not changed 
0ecf			;     HL is the product 
0ecf			;Time: 
0ecf			;     342+6x 
0ecf			; 
0ecf			Mult16: 
0ecf			 
0ecf 06 08		     ld b,8          ;7           7 
0ed1 21 00 00		     ld hl,0         ;10         10 
0ed4 29			       add hl,hl     ;11*8       88 
0ed5 07			       rlca          ;4*8        32 
0ed6 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ed8 19			         add hl,de   ;--         -- 
0ed9 10 f9		       djnz $-5      ;13*7+8     99 
0edb c9			ret 
0edc			 
0edc			; 
0edc			; Square root of 16-bit value 
0edc			; In:  HL = value 
0edc			; Out:  D = result (rounded down) 
0edc			; 
0edc			;Sqr16: 
0edc			;    ld de,#0040 
0edc			;    ld a,l 
0edc			;    ld l,h 
0edc			;    ld h,d 
0edc			;    or a 
0edc			;    ld b,8 
0edc			;Sqr16_Loop: 
0edc			;    sbc hl,de 
0edc			;    jr nc,Sqr16_Skip 
0edc			;    add hl,de 
0edc			;Sqr16_Skip: 
0edc			;    ccf 
0edc			;    rl d 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    djnz Sqr16_Loop 
0edc			;    ret 
0edc			; 
0edc			; 
0edc			; Divide 8-bit values 
0edc			; In: Divide E by divider C 
0edc			; Out: A = result, B = rest 
0edc			; 
0edc			Div8: 
0edc af			    xor a 
0edd 06 08		    ld b,8 
0edf			Div8_Loop: 
0edf cb 13		    rl e 
0ee1 17			    rla 
0ee2 91			    sub c 
0ee3 30 01		    jr nc,Div8_NoAdd 
0ee5 81			    add a,c 
0ee6			Div8_NoAdd: 
0ee6 10 f7		    djnz Div8_Loop 
0ee8 47			    ld b,a 
0ee9 7b			    ld a,e 
0eea 17			    rla 
0eeb 2f			    cpl 
0eec c9			    ret 
0eed			 
0eed			; 
0eed			; Multiply 8-bit value with a 16-bit value (unrolled) 
0eed			; In: Multiply A with DE 
0eed			; Out: HL = result 
0eed			; 
0eed			Mult12U: 
0eed 2e 00		    ld l,0 
0eef 87			    add a,a 
0ef0 30 01		    jr nc,Mult12U_NoAdd0 
0ef2 19			    add hl,de 
0ef3			Mult12U_NoAdd0: 
0ef3 29			    add hl,hl 
0ef4 87			    add a,a 
0ef5 30 01		    jr nc,Mult12U_NoAdd1 
0ef7 19			    add hl,de 
0ef8			Mult12U_NoAdd1: 
0ef8 29			    add hl,hl 
0ef9 87			    add a,a 
0efa 30 01		    jr nc,Mult12U_NoAdd2 
0efc 19			    add hl,de 
0efd			Mult12U_NoAdd2: 
0efd 29			    add hl,hl 
0efe 87			    add a,a 
0eff 30 01		    jr nc,Mult12U_NoAdd3 
0f01 19			    add hl,de 
0f02			Mult12U_NoAdd3: 
0f02 29			    add hl,hl 
0f03 87			    add a,a 
0f04 30 01		    jr nc,Mult12U_NoAdd4 
0f06 19			    add hl,de 
0f07			Mult12U_NoAdd4: 
0f07 29			    add hl,hl 
0f08 87			    add a,a 
0f09 30 01		    jr nc,Mult12U_NoAdd5 
0f0b 19			    add hl,de 
0f0c			Mult12U_NoAdd5: 
0f0c 29			    add hl,hl 
0f0d 87			    add a,a 
0f0e 30 01		    jr nc,Mult12U_NoAdd6 
0f10 19			    add hl,de 
0f11			Mult12U_NoAdd6: 
0f11 29			    add hl,hl 
0f12 87			    add a,a 
0f13 d0			    ret nc 
0f14 19			    add hl,de 
0f15 c9			    ret 
0f16			 
0f16			; 
0f16			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f16			; In: Multiply A with DE 
0f16			;      Put lowest value in A for most efficient calculation 
0f16			; Out: HL = result 
0f16			; 
0f16			Mult12R: 
0f16 21 00 00		    ld hl,0 
0f19			Mult12R_Loop: 
0f19 cb 3f		    srl a 
0f1b 30 01		    jr nc,Mult12R_NoAdd 
0f1d 19			    add hl,de 
0f1e			Mult12R_NoAdd: 
0f1e cb 23		    sla e 
0f20 cb 12		    rl d 
0f22 b7			    or a 
0f23 c2 19 0f		    jp nz,Mult12R_Loop 
0f26 c9			    ret 
0f27			 
0f27			; 
0f27			; Multiply 16-bit values (with 32-bit result) 
0f27			; In: Multiply BC with DE 
0f27			; Out: BCHL = result 
0f27			; 
0f27			Mult32: 
0f27 79			    ld a,c 
0f28 48			    ld c,b 
0f29 21 00 00		    ld hl,0 
0f2c 06 10		    ld b,16 
0f2e			Mult32_Loop: 
0f2e 29			    add hl,hl 
0f2f 17			    rla 
0f30 cb 11		    rl c 
0f32 30 07		    jr nc,Mult32_NoAdd 
0f34 19			    add hl,de 
0f35 ce 00		    adc a,0 
0f37 d2 3b 0f		    jp nc,Mult32_NoAdd 
0f3a 0c			    inc c 
0f3b			Mult32_NoAdd: 
0f3b 10 f1		    djnz Mult32_Loop 
0f3d 41			    ld b,c 
0f3e 4f			    ld c,a 
0f3f c9			    ret 
0f40			 
0f40			 
0f40			 
0f40			; 
0f40			; Multiply 8-bit values 
0f40			; In:  Multiply H with E 
0f40			; Out: HL = result 
0f40			; 
0f40			Mult8: 
0f40 16 00		    ld d,0 
0f42 6a			    ld l,d 
0f43 06 08		    ld b,8 
0f45			Mult8_Loop: 
0f45 29			    add hl,hl 
0f46 30 01		    jr nc,Mult8_NoAdd 
0f48 19			    add hl,de 
0f49			Mult8_NoAdd: 
0f49 10 fa		    djnz Mult8_Loop 
0f4b c9			    ret 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			;;http://z80-heaven.wikidot.com/math 
0f4c			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f4c			; 
0f4c			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f4c			;     ld a,16        ;7 
0f4c			;     ld hl,0        ;10 
0f4c			;     jp $+5         ;10 
0f4c			;.DivLoop: 
0f4c			;       add hl,bc    ;-- 
0f4c			;       dec a        ;64 
0f4c			;       jr z,.DivLoopEnd        ;86 
0f4c			; 
0f4c			;       sla e        ;128 
0f4c			;       rl d         ;128 
0f4c			;       adc hl,hl    ;240 
0f4c			;       sbc hl,bc    ;240 
0f4c			;       jr nc,.DivLoop ;23|21 
0f4c			;       inc e        ;-- 
0f4c			;       jp .DivLoop+1 
0f4c			; 
0f4c			;.DivLoopEnd: 
0f4c			 
0f4c			;HL_Div_C: 
0f4c			;Inputs: 
0f4c			;     HL is the numerator 
0f4c			;     C is the denominator 
0f4c			;Outputs: 
0f4c			;     A is the remainder 
0f4c			;     B is 0 
0f4c			;     C is not changed 
0f4c			;     DE is not changed 
0f4c			;     HL is the quotient 
0f4c			; 
0f4c			;       ld b,16 
0f4c			;       xor a 
0f4c			;         add hl,hl 
0f4c			;         rla 
0f4c			;         cp c 
0f4c			;         jr c,$+4 
0f4c			;           inc l 
0f4c			;           sub c 
0f4c			;         djnz $-7 
0f4c			 
0f4c			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f4c			 
0f4c			addatohl: 
0f4c 85			    add   a, l    ; A = A+L 
0f4d 6f			    ld    l, a    ; L = A+L 
0f4e 8c			    adc   a, h    ; A = A+L+H+carry 
0f4f 95			    sub   l       ; A = H+carry 
0f50 67			    ld    h, a    ; H = H+carry 
0f51 c9			ret 
0f52			 
0f52			addatode: 
0f52 83			    add   a, e    ; A = A+L 
0f53 5f			    ld    e, a    ; L = A+L 
0f54 8a			    adc   a, d    ; A = A+L+H+carry 
0f55 93			    sub   e       ; A = H+carry 
0f56 57			    ld    d, a    ; H = H+carry 
0f57 c9			ret 
0f58			 
0f58			 
0f58			addatobc: 
0f58 81			    add   a, c    ; A = A+L 
0f59 4f			    ld    c, a    ; L = A+L 
0f5a 88			    adc   a, b    ; A = A+L+H+carry 
0f5b 91			    sub   c       ; A = H+carry 
0f5c 47			    ld    b, a    ; H = H+carry 
0f5d c9			ret 
0f5e			 
0f5e			subafromhl: 
0f5e			   ; If A=0 do nothing 
0f5e			    ; Otherwise flip A's sign. Since 
0f5e			    ; the upper byte becomes -1, also 
0f5e			    ; substract 1 from H. 
0f5e ed 44		    neg 
0f60 ca 69 0f		    jp    z, Skip 
0f63 25			    dec   h 
0f64			     
0f64			    ; Now add the low byte as usual 
0f64			    ; Two's complement takes care of 
0f64			    ; ensuring the result is correct 
0f64 85			    add   a, l 
0f65 6f			    ld    l, a 
0f66 8c			    adc   a, h 
0f67 95			    sub   l 
0f68 67			    ld    h, a 
0f69			Skip: 
0f69 c9				ret 
0f6a			 
0f6a			 
0f6a			; compare hl and de 
0f6a			; returns:  
0f6a			; if hl = de, z=1, s=0, c0=0 
0f6a			; if hl > de, z=0, s=0, c=0 
0f6a			; if hl < de, z=0, s=1, c=1 
0f6a			cmp16:	 
0f6a b7				or a 
0f6b ed 52			sbc hl,de 
0f6d e0				ret po 
0f6e 7c				ld a,h 
0f6f 1f				rra 
0f70 ee 40			xor 01000000B 
0f72 37				scf 
0f73 8f				adc a,a 
0f74 c9				ret 
0f75			 
0f75			 
0f75			; test if hl contains zero   - A is destroyed 
0f75			 
0f75			ishlzero:    
0f75 b7				or a     ; reset flags 
0f76 7c				ld a, h 
0f77 b5				or l        	 
0f78			 
0f78 c9				ret 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			if FORTH_ENABLE_FLOATMATH 
0f79			;include "float/bbcmath.z80" 
0f79			include "float/lpfpcalc.asm" 
0f79			endif 
0f79			 
0f79			 
0f79			; eof 
0f79			 
# End of file firmware_maths.asm
0f79			include "firmware_strings.asm"   ; string handling  
0f79			 
0f79			 
0f79			; TODO string len 
0f79			; input text string, end on cr with zero term 
0f79			; a offset into frame buffer to start prompt 
0f79			; d is max length 
0f79			; e is display size TODO 
0f79			; c is current cursor position 
0f79			; hl is ptr to where string will be stored 
0f79			 
0f79			 
0f79			; TODO check limit of buffer for new inserts 
0f79			; TODO check insert does not push beyond buffer 
0f79			; TODO scroll in a limited display area 
0f79			; TODO scroll whole screen on page wrap 
0f79			 
0f79			 
0f79			; TODO handle KEY_PREVWORD 
0f79			; TODO handle KEY_NEXTWORD 
0f79			; TODO handle KEY_HOME 
0f79			; TODO handle KEY_END 
0f79			; TODO use LCD cursor? 
0f79			 
0f79 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f7c 81					add c 
0f7d 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f80 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0f83 79					ld a, c 
0f84 cd 4c 0f				call addatohl 
0f87 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f8a 7a					ld a,d 
0f8b 32 69 fe			        ld (input_size), a       ; save length of input area 
0f8e 79					ld a, c 
0f8f 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0f92 7b					ld a,e 
0f93 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f96					 
0f96					 
0f96			 
0f96			;		ld a,(input_ptr) 
0f96			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f96			 
0f96			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f96					; init cursor shape if not set by the cin routines 
0f96 21 c7 fb				ld hl, cursor_shape 
0f99 3e ff				ld a, 255 
0f9b 77					ld (hl), a 
0f9c 23					inc hl 
0f9d 3e 00				ld a, 0 
0f9f 77					ld (hl), a 
0fa0			 
0fa0 3e 0f				ld a, CUR_BLINK_RATE 
0fa2 32 63 fe				ld (input_cur_flash), a 
0fa5 3e 01				ld a, 1 
0fa7 32 62 fe				ld (input_cur_onoff),a 
0faa			 
0faa			;	if DEBUG_INPUT 
0faa			;		push af 
0faa			;		ld a, 'I' 
0faa			;		ld (debug_mark),a 
0faa			;		pop af 
0faa			;		CALLMONITOR 
0faa			;	endif 
0faa			.is1:		; main entry loop 
0faa			 
0faa			 
0faa			 
0faa					; pause 1ms 
0faa			 
0faa 3e 01				ld a, 1 
0fac cd 7a 0c				call aDelayInMS 
0faf			 
0faf					; dec flash counter 
0faf 3a 63 fe				ld a, (input_cur_flash) 
0fb2 3d					dec a 
0fb3 32 63 fe				ld (input_cur_flash), a 
0fb6 fe 00				cp 0 
0fb8 20 0d				jr nz, .nochgstate 
0fba			 
0fba			 
0fba					; change state 
0fba 3a 62 fe				ld a,(input_cur_onoff) 
0fbd ed 44				neg 
0fbf 32 62 fe				ld (input_cur_onoff),a 
0fc2			 
0fc2			 
0fc2					; reset on change of state 
0fc2 3e 0f				ld a, CUR_BLINK_RATE 
0fc4 32 63 fe				ld (input_cur_flash), a 
0fc7			 
0fc7			.nochgstate: 
0fc7					 
0fc7					 
0fc7			 
0fc7					; display cursor  
0fc7			 
0fc7			;		ld hl, (input_start) 
0fc7			;		ld a, (input_cursor) 
0fc7			;		call addatohl 
0fc7			 
0fc7					; get char under cursor and replace with cursor 
0fc7 2a 6c fe		ld hl, (input_ptr) 
0fca			;		ld a, (hl) 
0fca			;		ld (input_under_cursor),a 
0fca			;		ld a, '_' 
0fca			;		ld (hl), a 
0fca			 
0fca					; display string 
0fca			 
0fca ed 5b 6a fe			ld de, (input_start) 
0fce 3a 67 fe				ld a, (input_at_pos) 
0fd1 cd 2b 0d				call str_at_display 
0fd4			;	        call update_display 
0fd4			 
0fd4					; find place to put the cursor 
0fd4			;		add h 
0fd4			;		ld l, display_row_1 
0fd4			;		sub l 
0fd4			; (input_at_pos) 
0fd4					;ld c, a 
0fd4			;		ld a, (input_cursor) 
0fd4			;		ld l, (input_at_pos) 
0fd4			;		;ld b, h 
0fd4			;		add l 
0fd4			;		ld (input_at_cursor),a 
0fd4					;ld l,h 
0fd4			 
0fd4			;		ld h, 0 
0fd4			;		ld l,(input_at_pos) 
0fd4			;		ld a, (input_cursor) 
0fd4			;		call addatohl 
0fd4			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd4			;		call subafromhl 
0fd4			;		ld a,l 
0fd4			;		ld (input_at_cursor), a 
0fd4			 
0fd4				if DEBUG_INPUT 
0fd4					ld a, (hardware_diag) 
0fd4					cp 0 
0fd4					jr z, .skip_input_diag 
0fd4			 
0fd4					ld a,(input_at_pos) 
0fd4					ld hl, LFSRSeed 
0fd4					call hexout 
0fd4					ld a, (input_cursor) 
0fd4					ld hl, LFSRSeed+2 
0fd4					call hexout 
0fd4					ld a,(input_at_cursor) 
0fd4					ld hl, LFSRSeed+4 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_onoff) 
0fd4					ld hl, LFSRSeed+6 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_flash) 
0fd4					ld hl, LFSRSeed+8 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_len) 
0fd4					ld hl, LFSRSeed+10 
0fd4					call hexout 
0fd4					ld hl, LFSRSeed+12 
0fd4					ld a, 0 
0fd4					ld (hl),a 
0fd4					ld a, display_row_4 
0fd4					ld de, LFSRSeed 
0fd4					call str_at_display 
0fd4					.skip_input_diag: 
0fd4				endif 
0fd4			 
0fd4					; decide on if we are showing the cursor this time round 
0fd4			 
0fd4 3a 62 fe				ld a, (input_cur_onoff) 
0fd7 fe ff				cp 255 
0fd9 28 13				jr z, .skipcur 
0fdb			 
0fdb			 
0fdb 3a 65 fe				ld a,(input_at_cursor) 
0fde 11 c7 fb				ld de, cursor_shape 
0fe1 cd 2b 0d				call str_at_display 
0fe4			 
0fe4					; save length of current input string 
0fe4 2a 6a fe				ld hl, (input_start) 
0fe7 cd aa 13				call strlenz 
0fea 7d					ld a,l 
0feb 32 5d fe				ld (input_len),a 
0fee			 
0fee			.skipcur: 
0fee			 
0fee cd 3b 0d			        call update_display 
0ff1					 
0ff1			 
0ff1			 
0ff1					; wait 
0ff1				 
0ff1					; TODO loop without wait to flash the cursor and char under cursor	 
0ff1 cd ae 77				call cin    ; _wait 
0ff4			 
0ff4 fe 00				cp 0 
0ff6 ca aa 0f				jp z, .is1 
0ff9			 
0ff9					; get ptr to char to input into 
0ff9			 
0ff9 4f					ld c,a 
0ffa 2a 6a fe				ld hl, (input_start) 
0ffd 3a 58 fe				ld a, (input_cursor) 
1000 cd 4c 0f				call addatohl 
1003 22 6c fe				ld (input_ptr), hl 
1006 79					ld a,c 
1007			 
1007					; replace char under cursor 
1007			 
1007			;		ld hl, (input_ptr) 
1007			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1007			;		ld (hl), a 
1007			 
1007			;	if DEBUG_INPUT 
1007			;		push af 
1007			;		ld a, 'i' 
1007			;		ld (debug_mark),a 
1007			;		pop af 
1007			;		CALLMONITOR 
1007			;	endif 
1007 fe 0e				cp KEY_HOME 
1009 20 0e				jr nz, .iske 
100b			 
100b 3a 67 fe				ld a, (input_at_pos) 
100e 32 65 fe				ld (input_at_cursor),a 
1011 3e 00				ld a, 0 
1013 32 58 fe				ld (input_cursor), a 
1016 c3 aa 0f				jp .is1 
1019					 
1019 fe 0f		.iske:		cp KEY_END 
101b 20 03				jr nz, .isknw 
101d c3 aa 0f				jp .is1 
1020			 
1020 fe 06		.isknw:		cp KEY_NEXTWORD 
1022 20 1b				jr nz, .iskpw 
1024			 
1024 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
1027 7e					ld a,(hl)	 
1028 fe 00				cp 0 
102a ca aa 0f				jp z, .is1    ; end of string 
102d fe 20				cp ' ' 
102f ca aa 0f				jp z, .is1    ; end of word 
1032 23					inc hl 
1033 22 6c fe				ld (input_ptr), hl 
1036 3a 65 fe				ld a, (input_at_cursor) 
1039 3c					inc a 
103a 32 65 fe				ld (input_at_cursor), a 
103d 18 e5				jr .isknwm 
103f			 
103f fe 07		.iskpw:		cp KEY_PREVWORD 
1041 20 1b				jr nz, .iskl 
1043			.iskpwm:	 
1043 2a 6c fe				ld hl, (input_ptr) 
1046 7e					ld a,(hl)	 
1047 fe 00				cp 0  
1049 ca aa 0f				jp z, .is1    ; end of string 
104c fe 20				cp ' ' 
104e ca aa 0f				jp z, .is1    ; end of word 
1051 2b					dec hl 
1052 22 6c fe				ld (input_ptr), hl 
1055 3a 65 fe				ld a, (input_at_cursor) 
1058 3d					dec a 
1059 32 65 fe				ld (input_at_cursor), a 
105c 18 e5				jr .iskpwm 
105e			 
105e			 
105e fe 0b		.iskl:		cp KEY_LEFT 
1060 20 27				jr nz, .isk1 
1062			 
1062 3a 58 fe				ld a, (input_cursor) 
1065			 
1065 fe 00				cp 0 
1067 ca aa 0f				jp z, .is1 		; at start of line to ignore  
106a			 
106a 3d					dec  a 		; TODO check underflow 
106b 32 58 fe				ld (input_cursor), a 
106e			 
106e 2a 6c fe				ld hl, (input_ptr) 
1071 2b					dec hl 
1072 22 6c fe				ld (input_ptr), hl 
1075					 
1075 3a 65 fe				ld a, (input_at_cursor) 
1078 3d					dec a 
1079 32 65 fe				ld (input_at_cursor), a 
107c			 
107c 3e 01				ld a, 1		; show cursor moving 
107e 32 62 fe				ld (input_cur_onoff),a 
1081 3e 0f				ld a, CUR_BLINK_RATE 
1083 32 63 fe				ld (input_cur_flash), a 
1086			 
1086 c3 aa 0f				jp .is1 
1089			 
1089 fe 0c		.isk1:		cp KEY_RIGHT 
108b 20 2a				jr nz, .isk2 
108d			 
108d 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1090 5f					ld e,a 
1091 3a 58 fe				ld a, (input_cursor) 
1094 bb					cp e 
1095 ca aa 0f				jp z, .is1		; at the end of string so dont go right 
1098			 
1098 3c					inc  a 		; TODO check overflow 
1099 32 58 fe				ld (input_cursor), a 
109c			 
109c 3a 65 fe				ld a, (input_at_cursor) 
109f 3c					inc a 
10a0 32 65 fe				ld (input_at_cursor), a 
10a3			 
10a3 2a 6c fe				ld hl, (input_ptr) 
10a6 23					inc hl 
10a7 22 6c fe				ld (input_ptr), hl 
10aa			 
10aa 3e 01				ld a, 1		; show cursor moving 
10ac 32 62 fe				ld (input_cur_onoff),a 
10af 3e 0f				ld a, CUR_BLINK_RATE 
10b1 32 63 fe				ld (input_cur_flash), a 
10b4			 
10b4 c3 aa 0f				jp .is1 
10b7			 
10b7 fe 05		.isk2:		cp KEY_UP 
10b9			 
10b9 20 26				jr nz, .isk3 
10bb			 
10bb					; swap last command with the current on 
10bb			 
10bb					; move cursor to start of string 
10bb 2a 6a fe				ld hl, (input_start) 
10be 22 6c fe				ld (input_ptr), hl 
10c1			 
10c1 3a 67 fe				ld a, (input_at_pos) 
10c4 32 65 fe				ld (input_at_cursor), a 
10c7			 
10c7 3e 00				ld a, 0 
10c9 32 58 fe				ld (input_cursor), a 
10cc					 
10cc					; swap input and last command buffers 
10cc			 
10cc 21 ef f4				ld hl, os_cli_cmd 
10cf 11 ee f5				ld de, os_last_cmd 
10d2 06 ff				ld b, 255 
10d4 7e			.swap1:		ld a, (hl) 
10d5 4f					ld c,a 
10d6 1a					ld a, (de) 
10d7 77					ld (hl), a 
10d8 79					ld a,c 
10d9 12					ld (de),a 
10da 23					inc hl 
10db 13					inc de 
10dc 10 f6				djnz .swap1 
10de			 
10de			 
10de			 
10de			 
10de			 
10de c3 aa 0f				jp .is1 
10e1			 
10e1 fe 08		.isk3:		cp KEY_BS 
10e3 20 3c				jr nz, .isk4 
10e5			 
10e5 3a 58 fe				ld a, (input_cursor) 
10e8			 
10e8 fe 00				cp 0 
10ea ca aa 0f				jp z, .is1 		; at start of line to ignore  
10ed			 
10ed 3d					dec  a 		; TODO check underflow 
10ee 32 58 fe				ld (input_cursor), a 
10f1			 
10f1					; hl is source 
10f1					; de needs to be source - 1 
10f1			 
10f1			;		ld a, 0 
10f1			;		dec hl 
10f1			;		ld (hl), a 
10f1			 
10f1 2a 6c fe				ld hl, (input_ptr) 
10f4 2b					dec hl 
10f5 22 6c fe				ld (input_ptr), hl 
10f8			 
10f8					; shift all data 
10f8			 
10f8 e5					push hl 
10f9 23					inc hl 
10fa d1					pop de 
10fb 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10fe 4f					ld c,a 
10ff 06 00				ld b,0 
1101 ed b0				ldir  
1103			 
1103			 
1103			 
1103			 
1103 3a 65 fe				ld a, (input_at_cursor) 
1106 3d					dec a 
1107 32 65 fe				ld (input_at_cursor), a 
110a			 
110a			 
110a 3e 01				ld a, 1		; show cursor moving 
110c 32 62 fe				ld (input_cur_onoff),a 
110f 3e 0f				ld a, CUR_BLINK_RATE 
1111 32 63 fe				ld (input_cur_flash), a 
1114			 
1114					; remove char 
1114 3a 65 fe				ld a, (input_at_cursor) 
1117 3c					inc a 
1118 11 a2 11				ld de,.iblank 
111b cd 2b 0d				call str_at_display 
111e			 
111e c3 aa 0f				jp .is1 
1121			 
1121 fe 0d		.isk4:		cp KEY_CR 
1123 28 6c				jr z, .endinput 
1125			 
1125					; else add the key press to the end 
1125			 
1125 4f					ld c, a			; save key pressed 
1126			 
1126 7e					ld a,(hl)		; get what is currently under char 
1127			 
1127 fe 00				cp 0			; we are at the end of the string 
1129 20 2f				jr nz, .onchar 
112b					 
112b					; add a char to the end of the string 
112b				 
112b 71					ld (hl),c 
112c 23					inc hl 
112d			;		ld a,' ' 
112d			;		ld (hl),a 
112d			;		inc hl 
112d 3e 00				ld a,0 
112f 77					ld (hl),a 
1130 2b					dec hl 
1131			 
1131 3a 58 fe				ld a, (input_cursor) 
1134 3c					inc a				; TODO check max string length and scroll  
1135 32 58 fe				ld (input_cursor), a		; inc cursor pos 
1138							 
1138 3a 65 fe				ld a, (input_at_cursor) 
113b 3c					inc a 
113c 32 65 fe				ld (input_at_cursor), a 
113f			 
113f 2a 6c fe				ld hl, (input_ptr) 
1142 23					inc hl 
1143 22 6c fe				ld (input_ptr), hl 
1146			 
1146 2a 6c fe				ld hl, (input_ptr) 
1149 23					inc hl 
114a 22 6c fe				ld (input_ptr), hl 
114d			;	if DEBUG_INPUT 
114d			;		push af 
114d			;		ld a, '+' 
114d			;		ld (debug_mark),a 
114d			;		pop af 
114d			;		CALLMONITOR 
114d			;	endif 
114d 3e 01				ld a, 1		; show cursor moving 
114f 32 62 fe				ld (input_cur_onoff),a 
1152 3e 0f				ld a, CUR_BLINK_RATE 
1154 32 63 fe				ld (input_cur_flash), a 
1157 c3 aa 0f				jp .is1 
115a					 
115a			 
115a			 
115a					; if on a char then insert 
115a			.onchar: 
115a			 
115a					; TODO over flow check: make sure insert does not blow out buffer 
115a			 
115a					; need to do some maths to use lddr 
115a			 
115a e5					push hl   ; save char pos 
115b c5					push bc 
115c			 
115c 2a 6a fe				ld hl, (input_start) 
115f 3a 5d fe				ld a, (input_len) 
1162 cd 4c 0f				call addatohl  		; end of string 
1165 23					inc hl 
1166 23					inc hl		; past zero term 
1167 e5					push hl 
1168 23					inc hl 
1169 e5					push hl  
116a			 
116a								; start and end of lddr set, now how much to move? 
116a			 
116a							 
116a 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
116d 47					ld b,a 
116e 3a 5d fe				ld a,(input_len) 
1171 5f					ld e,a 
1172 90					sub b 
1173 3c					inc a		;?? 
1174 3c					inc a		;?? 
1175 3c					inc a		;?? 
1176			 
1176 06 00				ld b,0 
1178 4f					ld c,a 
1179			 
1179				if DEBUG_INPUT 
1179					push af 
1179					ld a, 'i' 
1179					ld (debug_mark),a 
1179					pop af 
1179			;		CALLMONITOR 
1179				endif 
1179 d1					pop de 
117a e1					pop hl 
117b				if DEBUG_INPUT 
117b					push af 
117b					ld a, 'I' 
117b					ld (debug_mark),a 
117b					pop af 
117b			;		CALLMONITOR 
117b				endif 
117b ed b8				lddr 
117d				 
117d			 
117d			 
117d					; TODO have a key for insert/overwrite mode???? 
117d c1					pop bc 
117e e1					pop hl 
117f 71					ld (hl), c		; otherwise overwrite current char 
1180					 
1180			 
1180			 
1180			 
1180 3a 58 fe				ld a, (input_cursor) 
1183 3c					inc  a 		; TODO check overflow 
1184 32 58 fe				ld (input_cursor), a 
1187			 
1187 3a 65 fe				ld a, (input_at_cursor) 
118a 3c					inc a 
118b 32 65 fe				ld (input_at_cursor), a 
118e			 
118e c3 aa 0f				jp .is1 
1191			 
1191			.endinput:	; TODO look for end of string 
1191			 
1191					; add trailing space for end of token 
1191			 
1191 2a 6a fe				ld hl, (input_start) 
1194 3a 5d fe				ld a,(input_len) 
1197 cd 4c 0f				call addatohl 
119a 3e 20				ld a, ' ' 
119c 77					ld (hl),a 
119d					; TODO eof of parse marker 
119d			 
119d 23					inc hl 
119e 3e 00				ld a, 0 
11a0 77					ld (hl),a 
11a1			 
11a1			 
11a1 c9					ret 
11a2			 
11a2 .. 00		.iblank: db " ",0 
11a4			 
11a4			 
11a4 32 67 fe		input_str_prev:	ld (input_at_pos), a 
11a7 22 6a fe				ld (input_start), hl 
11aa 3e 01				ld a,1			; add cursor 
11ac 77					ld (hl),a 
11ad 23					inc hl 
11ae 3e 00				ld a,0 
11b0 77					ld (hl),a 
11b1 22 6c fe				ld (input_ptr), hl 
11b4 7a					ld a,d 
11b5 32 69 fe				ld (input_size), a 
11b8 3e 00				ld a,0 
11ba 32 58 fe				ld (input_cursor),a 
11bd			.instr1:	 
11bd			 
11bd					; TODO do block cursor 
11bd					; TODO switch cursor depending on the modifer key 
11bd			 
11bd					; update cursor shape change on key hold 
11bd			 
11bd 2a 6c fe				ld hl, (input_ptr) 
11c0 2b					dec hl 
11c1 3a c7 fb				ld a,(cursor_shape) 
11c4 77					ld (hl), a 
11c5			 
11c5					; display entered text 
11c5 3a 67 fe				ld a,(input_at_pos) 
11c8 cd 72 75		            	CALL fLCD_Pos       ;Position cursor to location in A 
11cb ed 5b 6a fe	            	LD   de, (input_start) 
11cf cd 94 75		            	CALL fLCD_Str       ;Display string pointed to by DE 
11d2			 
11d2 cd ae 77				call cin 
11d5 fe 00				cp 0 
11d7 28 e4				jr z, .instr1 
11d9			 
11d9					; proecess keyboard controls first 
11d9			 
11d9 2a 6c fe				ld hl,(input_ptr) 
11dc			 
11dc fe 0d				cp KEY_CR	 ; pressing enter ends input 
11de 28 5a				jr z, .instrcr 
11e0			 
11e0 fe 08				cp KEY_BS 	; back space 
11e2 20 0f				jr nz, .instr2 
11e4					; process back space 
11e4			 
11e4					; TODO stop back space if at start of string 
11e4 2b					dec hl 
11e5 2b					dec hl ; to over write cursor 
11e6 3a c7 fb				ld a,(cursor_shape) 
11e9					;ld a,0 
11e9 77					ld (hl),a 
11ea 23					inc hl 
11eb 3e 20				ld a," " 
11ed 77					ld (hl),a 
11ee 22 6c fe				ld (input_ptr),hl 
11f1					 
11f1			 
11f1 18 ca				jr .instr1 
11f3			 
11f3 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11f5 20 06				jr nz, .instr3 
11f7 2b					dec hl 
11f8 22 6c fe				ld (input_ptr),hl 
11fb 18 c0				jr .instr1 
11fd				 
11fd fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11ff 20 06				jr nz, .instr4 
1201 23					inc hl 
1202 22 6c fe				ld (input_ptr),hl 
1205 18 b6				jr .instr1 
1207			 
1207 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1209 20 06				jr nz, .instr5 
120b 2b					dec hl 
120c 22 6c fe				ld (input_ptr),hl 
120f 18 ac				jr .instr1 
1211			 
1211 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1213 20 06				jr nz, .instr6 
1215 2b					dec hl 
1216 22 6c fe				ld (input_ptr),hl 
1219 18 a2				jr .instr1 
121b fe 05		.instr6:        cp KEY_UP      ; recall last command 
121d 20 0b				jr nz, .instrnew 
121f			 
121f 21 c8 f1			ld hl, scratch 
1222 11 ee f5			ld de, os_last_cmd 
1225 cd 43 12			call strcpy 
1228 18 93				jr .instr1 
122a			 
122a			 
122a			.instrnew:	; no special key pressed to see if we have room to store it 
122a			 
122a					; TODO do string size test 
122a			 
122a 2b					dec hl ; to over write cursor 
122b 77					ld (hl),a 
122c 23					inc hl 
122d 3a c7 fb				ld a,(cursor_shape) 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235			 
1235 22 6c fe				ld (input_ptr),hl 
1238					 
1238 18 83				jr .instr1 
123a 2b			.instrcr:	dec hl		; remove cursor 
123b 3e 20				ld a,' '	; TODO add a trailing space for safety 
123d 77					ld (hl),a 
123e 23					inc hl 
123f 3e 00				ld a,0 
1241 77					ld (hl),a 
1242			 
1242			 
1242					; if at end of line scroll up    
1242					; TODO detecting only end of line 4 for scroll up  
1242			 
1242					;ld   
1242			 
1242 c9					ret 
1243			 
1243			 
1243			; strcpy hl = dest, de source 
1243			 
1243 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1244 b7			            OR   A              ;Null terminator? 
1245 c8			            RET  Z              ;Yes, so finished 
1246 1a					ld a,(de) 
1247 77					ld (hl),a 
1248 13			            INC  DE             ;Point to next character 
1249 23					inc hl 
124a 18 f7		            JR   strcpy       ;Repeat 
124c c9					ret 
124d			 
124d			 
124d			; TODO string_at  
124d			; pass string which starts with lcd offset address and then null term string 
124d			 
124d			; TODO string to dec 
124d			; TODO string to hex 
124d			; TODO byte to string hex 
124d			; TODO byte to string dec 
124d			 
124d			 
124d			 
124d			; from z80uartmonitor 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
124d			; pass hl for where to put the text 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d c5			hexout:	PUSH BC 
124e f5					PUSH AF 
124f 47					LD B, A 
1250					; Upper nybble 
1250 cb 3f				SRL A 
1252 cb 3f				SRL A 
1254 cb 3f				SRL A 
1256 cb 3f				SRL A 
1258 cd 68 12				CALL tohex 
125b 77					ld (hl),a 
125c 23					inc hl	 
125d					 
125d					; Lower nybble 
125d 78					LD A, B 
125e e6 0f				AND 0FH 
1260 cd 68 12				CALL tohex 
1263 77					ld (hl),a 
1264 23					inc hl	 
1265					 
1265 f1					POP AF 
1266 c1					POP BC 
1267 c9					RET 
1268					 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			tohex: 
1268 e5					PUSH HL 
1269 d5					PUSH DE 
126a 16 00				LD D, 0 
126c 5f					LD E, A 
126d 21 75 12				LD HL, .DATA 
1270 19					ADD HL, DE 
1271 7e					LD A, (HL) 
1272 d1					POP DE 
1273 e1					POP HL 
1274 c9					RET 
1275			 
1275			.DATA: 
1275 30					DEFB	30h	; 0 
1276 31					DEFB	31h	; 1 
1277 32					DEFB	32h	; 2 
1278 33					DEFB	33h	; 3 
1279 34					DEFB	34h	; 4 
127a 35					DEFB	35h	; 5 
127b 36					DEFB	36h	; 6 
127c 37					DEFB	37h	; 7 
127d 38					DEFB	38h	; 8 
127e 39					DEFB	39h	; 9 
127f 41					DEFB	41h	; A 
1280 42					DEFB	42h	; B 
1281 43					DEFB	43h	; C 
1282 44					DEFB	44h	; D 
1283 45					DEFB	45h	; E 
1284 46					DEFB	46h	; F 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1285			;;    subtract $30, if result > 9 then subtract $7 more 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			atohex: 
1285 d6 30				SUB $30 
1287 fe 0a				CP 10 
1289 f8					RET M		; If result negative it was 0-9 so we're done 
128a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
128c c9					RET		 
128d			 
128d			 
128d			 
128d			 
128d			; Get 2 ASCII characters as hex byte from pointer in hl 
128d			 
128d			BYTERD: 
128d 16 00			LD	D,00h		;Set up 
128f cd 97 12			CALL	HEXCON		;Get byte and convert to hex 
1292 87				ADD	A,A		;First nibble so 
1293 87				ADD	A,A		;multiply by 16 
1294 87				ADD	A,A		; 
1295 87				ADD	A,A		; 
1296 57				LD	D,A		;Save hi nibble in D 
1297			HEXCON: 
1297 7e				ld a, (hl)		;Get next chr 
1298 23				inc hl 
1299 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
129b fe 0a			CP	00Ah		;Is it 0-9 ? 
129d 38 02			JR	C,NALPHA	;If so miss next bit 
129f d6 07			SUB	007h		;Else convert alpha 
12a1			NALPHA: 
12a1 b2				OR	D		;Add hi nibble back 
12a2 c9				RET			; 
12a3			 
12a3			 
12a3			; 
12a3			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12a3			; Since the routines get_byte and therefore get_nibble are called, only valid 
12a3			; characters (0-9a-f) are accepted. 
12a3			; 
12a3			;get_word        push    af 
12a3			;                call    get_byte        ; Get the upper byte 
12a3			;                ld      h, a 
12a3			;                call    get_byte        ; Get the lower byte 
12a3			;                ld      l, a 
12a3			;                pop     af 
12a3			;                ret 
12a3			; 
12a3			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12a3			; the routine get_nibble is used only valid characters are accepted - the  
12a3			; input routine only accepts characters 0-9a-f. 
12a3			; 
12a3 c5			get_byte:        push    bc              ; Save contents of B (and C) 
12a4 7e					ld a,(hl) 
12a5 23					inc hl 
12a6 cd cb 12		                call    nibble2val      ; Get upper nibble 
12a9 cb 07		                rlc     a 
12ab cb 07		                rlc     a 
12ad cb 07		                rlc     a 
12af cb 07		                rlc     a 
12b1 47			                ld      b, a            ; Save upper four bits 
12b2 7e					ld a,(hl) 
12b3 cd cb 12		                call    nibble2val      ; Get lower nibble 
12b6 b0			                or      b               ; Combine both nibbles 
12b7 c1			                pop     bc              ; Restore B (and C) 
12b8 c9			                ret 
12b9			; 
12b9			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b9			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b9			; to the serial line interface. The lower 4 bits of A contain the value of  
12b9			; that particular digit. 
12b9			; 
12b9			;get_nibble      ld a,(hl)           ; Read a character 
12b9			;                call    to_upper        ; Convert to upper case 
12b9			;                call    is_hex          ; Was it a hex digit? 
12b9			;                jr      nc, get_nibble  ; No, get another character 
12b9			 ;               call    nibble2val      ; Convert nibble to value 
12b9			 ;               call    print_nibble 
12b9			 ;               ret 
12b9			; 
12b9			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b9			; A valid hexadecimal digit is denoted by a set C flag. 
12b9			; 
12b9			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b9			;                ret     nc              ; Yes 
12b9			;                cp      '0'             ; Less than '0'? 
12b9			;                jr      nc, is_hex_1    ; No, continue 
12b9			;                ccf                     ; Complement carry (i.e. clear it) 
12b9			;                ret 
12b9			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b9			;                ret     c               ; Yes 
12b9			;                cp      'A'             ; Less than 'A'? 
12b9			;                jr      nc, is_hex_2    ; No, continue 
12b9			;                ccf                     ; Yes - clear carry and return 
12b9			;                ret 
12b9			;is_hex_2        scf                     ; Set carry 
12b9			;                ret 
12b9			; 
12b9			; Convert a single character contained in A to upper case: 
12b9			; 
12b9 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12bb d8			                ret     c 
12bc fe 7b		                cp      'z' + 1         ; > 'z'? 
12be d0			                ret     nc              ; Nothing to do, either 
12bf e6 5f		                and     $5f             ; Convert to upper case 
12c1 c9			                ret 
12c2			 
12c2			 
12c2			to_lower: 
12c2			 
12c2			   ; if char is in [A-Z] make it lower case 
12c2			 
12c2			   ; enter : a = char 
12c2			   ; exit  : a = lower case char 
12c2			   ; uses  : af 
12c2			 
12c2 fe 41		   cp 'A' 
12c4 d8			   ret c 
12c5			    
12c5 fe 5b		   cp 'Z'+1 
12c7 d0			   ret nc 
12c8			    
12c8 f6 20		   or $20 
12ca c9			   ret 
12cb			 
12cb			; 
12cb			; Expects a hexadecimal digit (upper case!) in A and returns the 
12cb			; corresponding value in A. 
12cb			; 
12cb fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12cd 38 02		                jr      c, nibble2val_1 ; Yes 
12cf d6 07		                sub     7               ; Adjust for A-F 
12d1 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12d3 e6 0f		                and     $f              ; Only return lower 4 bits 
12d5 c9			                ret 
12d6			; 
12d6			; Print_nibble prints a single hex nibble which is contained in the lower  
12d6			; four bits of A: 
12d6			; 
12d6			;print_nibble    push    af              ; We won't destroy the contents of A 
12d6			;                and     $f              ; Just in case... 
12d6			;                add     a, '0'             ; If we have a digit we are done here. 
12d6			;                cp      '9' + 1         ; Is the result > 9? 
12d6			;                jr      c, print_nibble_1 
12d6			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12d6			;print_nibble_1  call    putc            ; Print the nibble and 
12d6			;                pop     af              ; restore the original value of A 
12d6			;                ret 
12d6			;; 
12d6			;; Send a CR/LF pair: 
12d6			; 
12d6			;crlf            push    af 
12d6			;                ld      a, cr 
12d6			;                call    putc 
12d6			;                ld      a, lf 
12d6			;                call    putc 
12d6			;                pop     af 
12d6			;                ret 
12d6			; 
12d6			; Print_word prints the four hex digits of a word to the serial line. The  
12d6			; word is expected to be in HL. 
12d6			; 
12d6			;print_word      push    hl 
12d6			;                push    af 
12d6			;                ld      a, h 
12d6			;                call    print_byte 
12d6			;                ld      a, l 
12d6			;                call    print_byte 
12d6			;                pop     af 
12d6			;                pop     hl 
12d6			;                ret 
12d6			; 
12d6			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12d6			; The byte to be printed is expected to be in A. 
12d6			; 
12d6			;print_byte      push    af              ; Save the contents of the registers 
12d6			;                push    bc 
12d6			;                ld      b, a 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                call    print_nibble    ; Print high nibble 
12d6			;                ld      a, b 
12d6			;                call    print_nibble    ; Print low nibble 
12d6			;                pop     bc              ; Restore original register contents 
12d6			;                pop     af 
12d6			;                ret 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			fourehexhl:  
12d6 7e				ld a,(hl) 
12d7 cd 85 12			call atohex 
12da cb 3f				SRL A 
12dc cb 3f				SRL A 
12de cb 3f				SRL A 
12e0 cb 3f				SRL A 
12e2 47				ld b, a 
12e3 23				inc hl 
12e4 7e				ld a,(hl) 
12e5 23				inc hl 
12e6 cd 85 12			call atohex 
12e9 80				add b 
12ea 57				ld d,a 
12eb 7e				ld a,(hl) 
12ec cd 85 12			call atohex 
12ef cb 3f				SRL A 
12f1 cb 3f				SRL A 
12f3 cb 3f				SRL A 
12f5 cb 3f				SRL A 
12f7 47				ld b, a 
12f8 23				inc hl 
12f9 7e				ld a,(hl) 
12fa 23				inc hl 
12fb cd 85 12			call atohex 
12fe 80				add b 
12ff 5f				ld e, a 
1300 d5				push de 
1301 e1				pop hl 
1302 c9				ret 
1303			 
1303			; pass hl. returns z set if the byte at hl is a digit 
1303			;isdigithl:  
1303			;	push bc 
1303			;	ld a,(hl) 
1303			;	cp ':' 
1303			;	jr nc, .isdf 		; > 
1303			;	cp '0' 
1303			;	jr c, .isdf		; < 
1303			; 
1303			;	; TODO find a better way to set z 
1303			; 
1303			;	ld b,a 
1303			;	cp b 
1303			;	pop bc 
1303			;	ret 
1303			; 
1303			;.isdf:	; not digit so clear z 
1303			; 
1303			;	; TODO find a better way to unset z 
1303			; 
1303			;	ld b,a 
1303			;	inc b 
1303			;	cp b 
1303			; 
1303			;	pop bc 
1303			;	ret 
1303				 
1303				 
1303			 
1303			 
1303			; pass hl as the four byte address to load 
1303			 
1303			get_word_hl:  
1303 e5				push hl 
1304 cd a3 12			call get_byte 
1307				 
1307 47				ld b, a 
1308			 
1308 e1				pop hl 
1309 23				inc hl 
130a 23				inc hl 
130b			 
130b			; TODO not able to handle a-f  
130b 7e				ld a,(hl) 
130c			;	;cp ':' 
130c			;	cp 'g' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp 'G' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp '0' 
130c			;	jr c, .single_byte_hl		; < 
130c			 
130c				;call isdigithl 
130c fe 00			cp 0 
130e 28 06			jr z, .single_byte_hl 
1310			 
1310			.getwhln:   ; hex word so get next byte 
1310			 
1310 cd a3 12			call get_byte 
1313 6f				ld l, a 
1314 60				ld h,b 
1315 c9				ret 
1316 68			.single_byte_hl:   ld l,b 
1317 26 00				ld h,0 
1319 c9					ret 
131a			 
131a			 
131a			 
131a			 
131a 21 80 1d			ld hl,asc+1 
131d			;	ld a, (hl) 
131d			;	call nibble2val 
131d cd a3 12			call get_byte 
1320			 
1320			;	call fourehexhl 
1320 32 fc f1			ld (scratch+52),a 
1323				 
1323 21 fa f1			ld hl,scratch+50 
1326 22 eb f4			ld (os_cur_ptr),hl 
1329			 
1329 c9				ret 
132a			 
132a			 
132a			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
132a			 
132a			; Decimal Unsigned Version 
132a			 
132a			;Number in a to decimal ASCII 
132a			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
132a			;Example: display a=56 as "056" 
132a			;input: a = number 
132a			;Output: a=0,value of a in the screen 
132a			;destroys af,bc (don't know about hl and de) 
132a			DispAToASCII: 
132a 0e 9c			ld	c,-100 
132c cd 36 13			call	.Na1 
132f 0e f6			ld	c,-10 
1331 cd 36 13			call	.Na1 
1334 0e ff			ld	c,-1 
1336 06 2f		.Na1:	ld	b,'0'-1 
1338 04			.Na2:	inc	b 
1339 81				add	a,c 
133a 38 fc			jr	c,.Na2 
133c 91				sub	c		;works as add 100/10/1 
133d f5				push af		;safer than ld c,a 
133e 78				ld	a,b		;char is in b 
133f			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
133f f1				pop af		;safer than ld a,c 
1340 c9				ret 
1341			 
1341			; Decimal Signed Version 
1341			 
1341			; DispA 
1341			; -------------------------------------------------------------- 
1341			; Converts a signed integer value to a zero-terminated ASCII 
1341			; string representative of that value (using radix 10). 
1341			; -------------------------------------------------------------- 
1341			; INPUTS: 
1341			;     HL     Value to convert (two's complement integer). 
1341			;     DE     Base address of string destination. (pointer). 
1341			; -------------------------------------------------------------- 
1341			; OUTPUTS: 
1341			;     None 
1341			; -------------------------------------------------------------- 
1341			; REGISTERS/MEMORY DESTROYED 
1341			; AF HL 
1341			; -------------------------------------------------------------- 
1341			 
1341			;DispHLToASCII: 
1341			;   push    de 
1341			;   push    bc 
1341			; 
1341			;; Detect sign of HL. 
1341			;    bit    7, h 
1341			;    jr     z, ._DoConvert 
1341			; 
1341			;; HL is negative. Output '-' to string and negate HL. 
1341			;    ld     a, '-' 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			; 
1341			;; Negate HL (using two's complement) 
1341			;    xor    a 
1341			;    sub    l 
1341			;    ld     l, a 
1341			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1341			;    sbc    a, h 
1341			;    ld     h, a 
1341			; 
1341			;; Convert HL to digit characters 
1341			;._DoConvert: 
1341			;    ld     b, 0     ; B will count character length of number 
1341			;-   ld     a, 10 
1341			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1341			;    push   af 
1341			;    inc    b 
1341			;    ld     a, h 
1341			;    or     l 
1341			;    jr     nz, - 
1341			; 
1341			;; Retrieve digits from stack 
1341			;-   pop    af 
1341			;    or     $30 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			;    djnz   - 
1341			; 
1341			;; Terminate string with NULL 
1341			;    xor    a 
1341			;    ld     (de), a 
1341			; 
1341			;    pop    bc 
1341			;    pop    de 
1341			;    ret 
1341			 
1341			;Comments 
1341			; 
1341			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1341			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1341			;    Note that the output string will not be fixed-width. 
1341			; 
1341			;Example Usage 
1341			; 
1341			;    ld    hl, -1004 
1341			;    ld    de, OP1 
1341			;    call  DispA 
1341			;    ld    hl, OP1 
1341			;    syscall  PutS 
1341			 
1341			 
1341			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1341			 
1341			 
1341			;Converts an ASCII string to an unsigned 16-bit integer 
1341			;Quits when it reaches a non-decimal digit 
1341			 
1341			string_to_uint16: 
1341			atoui_16: 
1341			;Input: 
1341			;     DE points to the string 
1341			;Outputs: 
1341			;     HL is the result 
1341			;     A is the 8-bit value of the number 
1341			;     DE points to the byte after the number 
1341			;Destroys: 
1341			;     BC 
1341			;       if the string is non-empty, BC is HL/10 
1341			;Size:  24 bytes 
1341			;Speed: 42+d(104+{0,9}) 
1341			;       d is the number of digits in the number 
1341			;       max is 640 cycles for a 5 digit number 
1341			;Assuming no leading zeros: 
1341			;1 digit:  146cc 
1341			;2 digit:  250cc 
1341			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1341			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1341			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1341			;avg: 544.81158447265625cc (544+13297/16384) 
1341			;=============================================================== 
1341 21 00 00		  ld hl,0 
1344			.u16a: 
1344 1a			  ld a,(de) 
1345 d6 30		  sub 30h 
1347 fe 0a		  cp 10 
1349 d0			  ret nc 
134a 13			  inc de 
134b 44			  ld b,h 
134c 4d			  ld c,l 
134d 29			  add hl,hl 
134e 29			  add hl,hl 
134f 09			  add hl,bc 
1350 29			  add hl,hl 
1351 85			  add a,l 
1352 6f			  ld l,a 
1353 30 ef		  jr nc,.u16a 
1355 24			  inc h 
1356 c3 44 13		  jp .u16a 
1359			 
1359			 
1359			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1359			 
1359			;written by Zeda 
1359			;Converts a 16-bit unsigned integer to an ASCII string. 
1359			 
1359			uitoa_16: 
1359			;Input: 
1359			;   DE is the number to convert 
1359			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1359			;Output: 
1359			;   HL points to the null-terminated ASCII string 
1359			;      NOTE: This isn't necessarily the same as the input HL. 
1359 d5			  push de 
135a c5			  push bc 
135b f5			  push af 
135c eb			  ex de,hl 
135d			 
135d 01 f0 d8		  ld bc,-10000 
1360 3e 2f		  ld a,'0'-1 
1362 3c			  inc a 
1363 09			  add hl,bc  
1364 38 fc		   jr c,$-2 
1366 12			  ld (de),a 
1367 13			  inc de 
1368			 
1368 01 e8 03		  ld bc,1000 
136b 3e 3a		  ld a,'9'+1 
136d 3d			  dec a  
136e 09			  add hl,bc  
136f 30 fc		   jr nc,$-2 
1371 12			  ld (de),a 
1372 13			  inc de 
1373			 
1373 01 9c ff		  ld bc,-100 
1376 3e 2f		  ld a,'0'-1 
1378 3c			  inc a  
1379 09			  add hl,bc  
137a 38 fc		   jr c,$-2 
137c 12			  ld (de),a 
137d 13			  inc de 
137e			 
137e 7d			  ld a,l 
137f 26 3a		  ld h,'9'+1 
1381 25			  dec h  
1382 c6 0a		  add a,10  
1384 30 fb		   jr nc,$-3 
1386 c6 30		  add a,'0' 
1388 eb			  ex de,hl 
1389 72			  ld (hl),d 
138a 23			  inc hl 
138b 77			  ld (hl),a 
138c 23			  inc hl 
138d 36 00		  ld (hl),0 
138f			 
138f			;Now strip the leading zeros 
138f 0e fa		  ld c,-6 
1391 09			  add hl,bc 
1392 3e 30		  ld a,'0' 
1394 23			  inc hl  
1395 be			  cp (hl)  
1396 28 fc		  jr z,$-2 
1398			 
1398			;Make sure that the string is non-empty! 
1398 7e			  ld a,(hl) 
1399 b7			  or a 
139a 20 01		  jr nz,.atoub 
139c 2b			  dec hl 
139d			.atoub: 
139d			 
139d f1			  pop af 
139e c1			  pop bc 
139f d1			  pop de 
13a0 c9			  ret 
13a1			 
13a1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
13a1			 
13a1			toUpper: 
13a1			;A is the char. 
13a1			;If A is a lowercase letter, this sets it to the matching uppercase 
13a1			;18cc or 30cc or 41cc 
13a1			;avg: 26.75cc 
13a1 fe 61		  cp 'a' 
13a3 d8			  ret c 
13a4 fe 7b		  cp 'z'+1 
13a6 d0			  ret nc 
13a7 d6 20		  sub 'a'-'A' 
13a9 c9			  ret 
13aa			 
13aa			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13aa			 
13aa			; String Length 
13aa			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13aa			 
13aa			; Get the length of the null-terminated string starting at $8000 hl 
13aa			;    LD     HL, $8000 
13aa			 
13aa			strlenz: 
13aa			 
13aa af			    XOR    A               ; Zero is the value we are looking for. 
13ab 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13ac 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13ad			                           ; 65, 536 bytes (the entire addressable memory space). 
13ad ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13af			 
13af			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13af 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13b0 6f			    LD     L, A             ; number of bytes 
13b1 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13b3 2b			    DEC    HL              ; Compensate for null. 
13b4 c9				ret 
13b5			 
13b5			; Get the length of the A terminated string starting at $8000 hl 
13b5			;    LD     HL, $8000 
13b5			 
13b5			strlent: 
13b5			 
13b5			                  ; A is the value we are looking for. 
13b5 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b7 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b9			                           ; 65, 536 bytes (the entire addressable memory space). 
13b9 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13bb			 
13bb			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13bb 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13bd 2e 00		    LD     L, 0             ; number of bytes 
13bf ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13c1 2b			    DEC    HL              ; Compensate for null. 
13c2 c9				ret 
13c3			 
13c3			 
13c3			;Comparing Strings 
13c3			 
13c3			;IN    HL     Address of string1. 
13c3			;      DE     Address of string2. 
13c3			 
13c3			; doc given but wrong??? 
13c3			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13c3			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13c3			; tested 
13c3			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13c3			 
13c3			strcmp_old: 
13c3 e5			    PUSH   HL 
13c4 d5			    PUSH   DE 
13c5			 
13c5 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13c6 be			    CP     (HL)            ; (want to minimize work). 
13c7 38 01		    JR     C, Str1IsBigger 
13c9 7e			    LD     A, (HL) 
13ca			 
13ca			Str1IsBigger: 
13ca 4f			    LD     C, A             ; Put length in BC 
13cb 06 00		    LD     B, 0 
13cd 13			    INC    DE              ; Increment pointers to meat of string. 
13ce 23			    INC    HL 
13cf			 
13cf			CmpLoop: 
13cf 1a			    LD     A, (DE)          ; Compare bytes. 
13d0 ed a1		    CPI 
13d2 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13d4 13			    INC    DE              ; Update pointer. 
13d5 ea cf 13		    JP     PE, CmpLoop 
13d8			 
13d8 d1			    POP    DE 
13d9 e1			    POP    HL 
13da 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13db be			    CP     (HL) 
13dc c9			    RET 
13dd			 
13dd			NoMatch: 
13dd 2b			    DEC    HL 
13de be			    CP     (HL)            ; Compare again to affect carry. 
13df d1			    POP    DE 
13e0 e1			    POP    HL 
13e1 c9			    RET 
13e2			 
13e2			;; test strmp 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr z, .z1 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z1: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr z, .z2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr c, .c1 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c1: 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr c, .c2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;	NEXTW 
13e2			;.str1:   db "string1",0 
13e2			;.str2:   db "string2",0 
13e2			 
13e2			; only care about direct match or not 
13e2			; hl and de strings 
13e2			; zero set if the same 
13e2			 
13e2			strcmp: 
13e2 1a				ld a, (de) 
13e3 be				cp (hl) 
13e4 28 02			jr z, .ssame 
13e6 b7				or a 
13e7 c9				ret 
13e8			 
13e8			.ssame:  
13e8 fe 00			cp 0 
13ea c8				ret z 
13eb			 
13eb 23				inc hl 
13ec 13				inc de 
13ed 18 f3			jr strcmp 
13ef				 
13ef				 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			; eof 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
# End of file firmware_strings.asm
13ef			include "firmware_memory.asm"   ; malloc and free  
13ef			 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			.mallocsize: db "Wants malloc >256",0 
13ef			.mallocasize: db "MALLOC gives >256",0 
13ef			.malloczero: db "MALLOC gives zero",0 
13ef			 
13ef			malloc_guard_zerolen: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef				ld de, 0 
13ef			        call cmp16 
13ef				jr nz, .lowalloz 
13ef			 
13ef				push hl 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .malloczero 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef			.lowalloz: 
13ef			 
13ef			 
13ef				pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_entry: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowalloc 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocsize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdone 
13ef			.lowalloc: 
13ef			 
13ef			 
13ef				pop hl 
13ef			.lowdone:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_exit: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowallocx 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocasize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdonex 
13ef			.lowallocx: 
13ef			 
13ef				pop hl 
13ef			.lowdonex:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			endif 
13ef			 
13ef			if MALLOC_2 
13ef			; Z80 Malloc and Free Functions 
13ef			 
13ef			; Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc: 
13ef				 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_entry 
13ef			endif 
13ef			 
13ef			 
13ef			 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "mal" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of size into A 
13ef			    or h               ; Check if size is zero 
13ef			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13ef			 
13ef			    ; Allocate memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma1" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    call malloc_internal ; Call internal malloc function 
13ef			    pop af             ; Restore AF register 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret                ; Return 
13ef			 
13ef			; Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free: 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of pointer into A 
13ef			    or h               ; Check if pointer is NULL 
13ef			    jp z, free_exit    ; If pointer is NULL, exit 
13ef			 
13ef			    ; Free memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef			    call free_internal  ; Call internal free function 
13ef			    pop af             ; Restore AF register 
13ef			    ret                ; Return 
13ef			 
13ef			; Internal Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc_internal: 
13ef			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to requested size 
13ef			    ex de, hl          ; Save total size in DE, and keep it in HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			 
13ef			    ; Search for free memory block 
13ef			    ld de, (heap_end)  ; Load end of heap into DE 
13ef			    ld bc, 0           ; Initialize counter 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			malloc_search_loop: 
13ef			    ; Check if current block is free 
13ef			    ld a, (hl)         ; Load current block's status (free or used) 
13ef			    cp 0               ; Compare with zero (free) 
13ef			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13ef			 
13ef			    ; Check if current block is large enough 
13ef			    ld a, (hl+1)       ; Load high byte of block size 
13ef			    cp l               ; Compare with low byte of requested size 
13ef			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13ef			 
13ef			    ld a, (hl+2)       ; Load low byte of block size 
13ef			    cp h               ; Compare with high byte of requested size 
13ef			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13ef			 
13ef			    ; Mark block as used 
13ef			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13ef			 
13ef			    ; Calculate remaining space in block 
13ef			    ld bc, 0           ; Clear BC 
13ef			    add hl, bc         ; Increment HL to point to start of data block 
13ef			    add hl, de         ; HL = HL + DE (total size) 
13ef			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to start of data block 
13ef			 
13ef			    ; Save pointer to allocated block in HL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma5" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			malloc_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3           ; Size of management overhead 
13ef			    add hl, bc         ; Move to the next block 
13ef			    inc de             ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e            ; Load low byte of heap end address 
13ef			    cp (hl)            ; Compare with low byte of current address 
13ef			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13ef			    ld a, d            ; Load high byte of heap end address 
13ef			    cp 0               ; Check if it's zero (end of memory) 
13ef			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, allocation failed 
13ef			    xor a              ; Set result to NULL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma6" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			malloc_exit: 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma7" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			; Internal Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free_internal: 
13ef			    ld de, (heap_start) ; Load start of heap into DE 
13ef			    ld bc, 0            ; Initialize counter 
13ef			 
13ef			free_search_loop: 
13ef			    ; Check if current block contains the pointer 
13ef			    ld a, l             ; Load low byte of pointer 
13ef			    cp (hl+1)           ; Compare with high byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			    ld a, h             ; Load high byte of pointer 
13ef			    cp (hl+2)           ; Compare with low byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			 
13ef			    ; Mark block as free 
13ef			    ld (hl), 0          ; Set status byte to indicate free block 
13ef			    ret                 ; Return 
13ef			 
13ef			free_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3            ; Size of management overhead 
13ef			    add hl, bc          ; Move to the next block 
13ef			    inc de              ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e             ; Load low byte of heap end address 
13ef			    cp (hl)             ; Compare with low byte of current address 
13ef			    jr nz, free_search_loop  ; If not equal, continue searching 
13ef			    ld a, d             ; Load high byte of heap end address 
13ef			    cp 0                ; Check if it's zero (end of memory) 
13ef			    jr nz, free_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, pointer is not found in heap 
13ef			    ret 
13ef			 
13ef			free_exit: 
13ef			    ret                 ; Return 
13ef			 
13ef			; Define heap start and end addresses 
13ef			;heap_start:    .dw 0xC000   ; Start of heap 
13ef			;heap_end:      .dw 0xE000   ; End of heap 
13ef			 
13ef			endif 
13ef			 
13ef			 
13ef			if MALLOC_1 
13ef			 
13ef			 
13ef			 
13ef			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13ef			 
13ef			;moved to firmware.asm 
13ef			;heap_start        .equ  0x9000      ; Starting address of heap 
13ef			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ef			 
13ef			;      .org 0 
13ef			;      jp    main 
13ef			 
13ef			 
13ef			;      .org  0x100 
13ef			;main: 
13ef			;      ld    HL, 0x8100 
13ef			;      ld    SP, HL 
13ef			; 
13ef			;      call  heap_init 
13ef			; 
13ef			;      ; Make some allocations 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9004 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9014 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9024 
13ef			; 
13ef			;      ; Free some allocations 
13ef			;      ld    HL, 0x9014 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9004 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9024 
13ef			;      call  free 
13ef			; 
13ef			; 
13ef			;      halt 
13ef			 
13ef			 
13ef			;------------------------------------------------------------------------------ 
13ef			;     heap_init                                                               : 
13ef			;                                                                             : 
13ef			; Description                                                                 : 
13ef			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ef			;                                                                             : 
13ef			;     The heap is maintained as a linked list, starting with an initial       : 
13ef			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ef			;     the first free block in the heap. Each block then points to the next    : 
13ef			;     free block within the heap, and the free list ends at the first block   : 
13ef			;     with a null pointer to the next free block.                             : 
13ef			;                                                                             : 
13ef			; Parameters                                                                  : 
13ef			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ef			;     address of the heap and its size are required, along with a memory      : 
13ef			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ef			;     principally stores a pointer to the first free block in the heap.       : 
13ef			;                                                                             : 
13ef			; Returns                                                                     : 
13ef			;     Nothing                                                                 : 
13ef			;------------------------------------------------------------------------------ 
13ef			heap_init: 
13ef e5			      push  HL 
13f0			 
13f0			      ; Initialise free list struct 
13f0 21 0e 80		      ld    HL, heap_start 
13f3 22 0a 80		      ld    (free_list), HL 
13f6 21 00 00		      ld    HL, 0 
13f9 22 0c 80		      ld    (free_list+2), HL 
13fc			 
13fc			      ; Insert first free block at bottom of heap, consumes entire heap 
13fc 21 aa f1		      ld    HL, heap_start+heap_size-4 
13ff 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1402 21 9c 71		      ld    HL, heap_size-4 
1405 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1408			 
1408			      ; Insert end of free list block at top of heap - two null words will 
1408			      ; terminate the free list 
1408 21 00 00		      ld    HL, 0 
140b 22 ac f1		      ld    (heap_start+heap_size-2), HL 
140e 22 aa f1		      ld    (heap_start+heap_size-4), HL 
1411			 
1411 e1			      pop   HL 
1412			 
1412 c9			      ret 
1413			 
1413			 
1413			;------------------------------------------------------------------------------ 
1413			;     malloc                                                                  : 
1413			;                                                                             : 
1413			; Description                                                                 : 
1413			;     Allocates the wanted space from the heap and returns the address of the : 
1413			;     first useable byte of the allocation.                                   : 
1413			;                                                                             : 
1413			;     Allocations can happen in one of two ways:                              : 
1413			;                                                                             : 
1413			;     1. A free block may be found which is the exact size wanted. In this    : 
1413			;        case the block is removed from the free list and retuedn to the      : 
1413			;        caller.                                                              : 
1413			;     2. A free block may be found which is larger than the size wanted. In   : 
1413			;        this case, the larger block is split into two. The first portion of  : 
1413			;        this block will become the requested space by the malloc call and    : 
1413			;        is returned to the caller. The second portion becomes a new free     : 
1413			;        block, and the free list is adjusted to maintain continuity via this : 
1413			;        newly created block.                                                 : 
1413			;                                                                             : 
1413			;     malloc does not set any initial value in the allocated space, the       : 
1413			;     caller is required to do this as required.                              : 
1413			;                                                                             : 
1413			;     This implementation of malloc uses the stack exclusively, and is        : 
1413			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1413			;     advisable to disable interrupts before calling malloc, and recommended  : 
1413			;     to avoid the use of malloc inside ISRs in general.                      : 
1413			;                                                                             : 
1413			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1413			;                                                                             : 
1413			; Parameters                                                                  : 
1413			;     HL  Number of bytes wanted                                              : 
1413			;                                                                             : 
1413			; Returns                                                                     : 
1413			;     HL  Address of the first useable byte of the allocation                 : 
1413			;                                                                             : 
1413			; Flags                                                                       : 
1413			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1413			;                                                                             : 
1413			; Stack frame                                                                 : 
1413			;       |             |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     BC      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     DE      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     IX      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |  prev_free  |                                                       : 
1413			;   +4  +-------------+                                                       : 
1413			;       |  this_free  |                                                       : 
1413			;   +2  +-------------+                                                       : 
1413			;       |  next_free  |                                                       : 
1413			;   +0  +-------------+                                                       : 
1413			;       |             |                                                       : 
1413			;                                                                             : 
1413			;------------------------------------------------------------------------------ 
1413			 
1413			 
1413			;malloc: 
1413			; 
1413			;	SAVESP ON 1 
1413			; 
1413			;	call malloc_code 
1413			; 
1413			;	CHECKSP ON 1 
1413			;	ret 
1413			 
1413			 
1413			malloc: 
1413 c5			      push  BC 
1414 d5			      push  DE 
1415 dd e5		      push  IX 
1417			if DEBUG_FORTH_MALLOC_HIGH 
1417			call malloc_guard_entry 
1417			endif 
1417			 
1417					if DEBUG_FORTH_MALLOC 
1417						DMARK "mal" 
1417						CALLMONITOR 
1417					endif 
1417 7c			      ld    A, H                    ; Exit if no space requested 
1418 b5			      or    L 
1419 ca d8 14		      jp    Z, malloc_early_exit 
141c			 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			; 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			 
141c			 
141c			 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "maA" 
141c						CALLMONITOR 
141c					endif 
141c			      ; Set up stack frame 
141c eb			      ex    DE, HL 
141d 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1420 39			      add   HL, SP 
1421 f9			      ld    SP, HL 
1422 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1426 dd 39		      add   IX, SP 
1428			 
1428			      ; Setup initial state 
1428 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
142b 19			      add   HL, DE 
142c			 
142c 44			      ld    B, H                    ; Move want to BC 
142d 4d			      ld    C, L 
142e			 
142e 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1431 dd 75 04		      ld    (IX+4), L 
1434 dd 74 05		      ld    (IX+5), H 
1437			 
1437 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1438 23			      inc   HL 
1439 56			      ld    D, (HL) 
143a dd 73 02		      ld    (IX+2), E 
143d dd 72 03		      ld    (IX+3), D 
1440 eb			      ex    DE, HL                  ; this_free ptr into HL 
1441			 
1441					if DEBUG_FORTH_MALLOC 
1441						DMARK "maB" 
1441						CALLMONITOR 
1441					endif 
1441			      ; Loop through free block list to find some space 
1441			malloc_find_space: 
1441 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1442 23			      inc   HL 
1443 56			      ld    D, (HL) 
1444			 
1444 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1445 b3			      or    E 
1446 ca d2 14		      jp    Z, malloc_no_space 
1449			 
1449 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
144c dd 72 01		      ld    (IX+1), D 
144f			 
144f			      ; Does this block have enough space to make the allocation? 
144f 23			      inc   HL                      ; Load free block size into DE 
1450 5e			      ld    E, (HL) 
1451 23			      inc   HL 
1452 56			      ld    D, (HL) 
1453			 
1453 eb			      ex    DE, HL                  ; Check size of block against want 
1454 b7			      or    A                       ; Ensure carry flag clear 
1455 ed 42		      sbc   HL, BC 
1457 e5			      push  HL                      ; Store the result for later (new block size) 
1458			 
1458 ca a7 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
145b 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
145d			 
145d			      ; this_free block is not big enough, setup ptrs to test next free block 
145d e1			      pop   HL                      ; Discard previous result 
145e			 
145e dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1461 dd 66 03		      ld    H, (IX+3) 
1464 dd 75 04		      ld    (IX+4), L 
1467 dd 74 05		      ld    (IX+5), H 
146a			 
146a dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
146d dd 66 01		      ld    H, (IX+1) 
1470 dd 75 02		      ld    (IX+2), L 
1473 dd 74 03		      ld    (IX+3), H 
1476			 
1476					if DEBUG_FORTH_MALLOC 
1476						DMARK "MA>" 
1476						CALLMONITOR 
1476					endif 
1476 18 c9		      jr    malloc_find_space 
1478			 
1478			      ; split a bigger block into two - requested size and remaining size 
1478			malloc_alloc_split: 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAs" 
1478						CALLMONITOR 
1478					endif 
1478 eb			      ex    DE, HL                  ; Calculate address of new free block 
1479 2b			      dec   HL 
147a 2b			      dec   HL 
147b 2b			      dec   HL 
147c 09			      add   HL, BC 
147d			 
147d			      ; Create a new block and point it at next_free 
147d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1480 dd 56 01		      ld    D, (IX+1) 
1483			 
1483 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1484 23			      inc   HL 
1485 72			      ld    (HL), D 
1486			 
1486 d1			      pop   DE                      ; Store size of new block into new block 
1487 23			      inc   HL 
1488 73			      ld    (HL), E 
1489 23			      inc   HL 
148a 72			      ld    (HL), D 
148b			 
148b			      ; Update this_free ptr to point to new block 
148b 2b			      dec   HL 
148c 2b			      dec   HL 
148d 2b			      dec   HL 
148e			 
148e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1491 dd 56 03		      ld    D, (IX+3) 
1494			 
1494 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1497 dd 74 03		      ld    (IX+3), H 
149a			 
149a			      ; Modify this_free block to be allocation 
149a eb			      ex    DE, HL 
149b af			      xor   A                       ; Null the next block ptr of allocated block 
149c 77			      ld    (HL), A 
149d 23			      inc   HL 
149e 77			      ld    (HL), A 
149f			 
149f 23			      inc   HL                      ; Store want size into allocated block 
14a0 71			      ld    (HL), C 
14a1 23			      inc   HL 
14a2 70			      ld    (HL), B 
14a3 23			      inc   HL 
14a4 e5			      push  HL                      ; Address of allocation to return 
14a5			 
14a5 18 19		      jr    malloc_update_links 
14a7			 
14a7			malloc_alloc_fit: 
14a7 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14a8			 
14a8					if DEBUG_FORTH_MALLOC 
14a8						DMARK "MAf" 
14a8						CALLMONITOR 
14a8					endif 
14a8			      ; Modify this_free block to be allocation 
14a8 eb			      ex    DE, HL 
14a9 2b			      dec   HL 
14aa 2b			      dec   HL 
14ab 2b			      dec   HL 
14ac			 
14ac af			      xor   A                       ; Null the next block ptr of allocated block 
14ad 77			      ld    (HL), A 
14ae 23			      inc   HL 
14af 77			      ld    (HL), A 
14b0			 
14b0 23			      inc   HL                      ; Store address of allocation to return 
14b1 23			      inc   HL 
14b2 23			      inc   HL 
14b3 e5			      push  HL 
14b4			 
14b4			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b4 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14b7 dd 66 01		      ld    H, (IX+1) 
14ba			 
14ba dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14bd dd 74 03		      ld    (IX+3), H 
14c0			 
14c0			 
14c0			malloc_update_links: 
14c0			      ; Update prev_free ptr to point to this_free 
14c0 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c3 dd 66 05		      ld    H, (IX+5) 
14c6			 
14c6 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14c9 dd 56 03		      ld    D, (IX+3) 
14cc			 
14cc 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14cd 23			      inc   HL 
14ce 72			      ld    (HL), D 
14cf			 
14cf					if DEBUG_FORTH_MALLOC 
14cf						DMARK "Mul" 
14cf						CALLMONITOR 
14cf					endif 
14cf			      ; Clear the Z flag to indicate successful allocation 
14cf 7a			      ld    A, D 
14d0 b3			      or    E 
14d1			 
14d1 d1			      pop   DE                      ; Address of allocation 
14d2					if DEBUG_FORTH_MALLOC 
14d2						DMARK "MAu" 
14d2						CALLMONITOR 
14d2					endif 
14d2			 
14d2			malloc_no_space: 
14d2 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14d5 39			      add   HL, SP 
14d6 f9			      ld    SP, HL 
14d7			 
14d7 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAN" 
14d8						CALLMONITOR 
14d8					endif 
14d8			 
14d8			malloc_early_exit: 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAx" 
14d8						CALLMONITOR 
14d8					endif 
14d8 dd e1		      pop   IX 
14da d1			      pop   DE 
14db c1			      pop   BC 
14dc			 
14dc			if DEBUG_FORTH_MALLOC_HIGH 
14dc			call malloc_guard_exit 
14dc			call malloc_guard_zerolen 
14dc			endif 
14dc c9			      ret 
14dd			 
14dd			 
14dd			;------------------------------------------------------------------------------ 
14dd			;     free                                                                    : 
14dd			;                                                                             : 
14dd			; Description                                                                 : 
14dd			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14dd			;     returned by malloc, otherwise the behaviour is undefined.               : 
14dd			;                                                                             : 
14dd			;     Where possible, directly adjacent free blocks will be merged together   : 
14dd			;     into larger blocks to help ensure that the heap does not become         : 
14dd			;     excessively fragmented.                                                 : 
14dd			;                                                                             : 
14dd			;     free does not clear or set any other value into the freed space, and    : 
14dd			;     therefore its contents may be visible through subsequent malloc's. The  : 
14dd			;     caller should clear the freed space as required.                        : 
14dd			;                                                                             : 
14dd			;     This implementation of free uses the stack exclusively, and is          : 
14dd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14dd			;     advisable to disable interrupts before calling free, and recommended    : 
14dd			;     to avoid the use of free inside ISRs in general.                        : 
14dd			;                                                                             : 
14dd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14dd			;                                                                             : 
14dd			; Parameters                                                                  : 
14dd			;     HL  Pointer to address of first byte of allocation to be freed          : 
14dd			;                                                                             : 
14dd			; Returns                                                                     : 
14dd			;     Nothing                                                                 : 
14dd			;                                                                             : 
14dd			; Stack frame                                                                 : 
14dd			;       |             |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     BC      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     DE      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     IX      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |  prev_free  |                                                       : 
14dd			;   +2  +-------------+                                                       : 
14dd			;       |  next_free  |                                                       : 
14dd			;   +0  +-------------+                                                       : 
14dd			;       |             |                                                       : 
14dd			;                                                                             : 
14dd			;------------------------------------------------------------------------------ 
14dd			free: 
14dd c5			      push  BC 
14de d5			      push  DE 
14df dd e5		      push  IX 
14e1			 
14e1 7c			      ld    A, H                    ; Exit if ptr is null 
14e2 b5			      or    L 
14e3 ca a7 15		      jp    Z, free_early_exit 
14e6			 
14e6			      ; Set up stack frame 
14e6 eb			      ex    DE, HL 
14e7 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14ea 39			      add   HL, SP 
14eb f9			      ld    SP, HL 
14ec dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14f0 dd 39		      add   IX, SP 
14f2			 
14f2			      ; The address in HL points to the start of the useable allocated space, 
14f2			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14f2			      ; address of the block itself. 
14f2 eb			      ex    DE, HL 
14f3 11 fc ff		      ld    DE, -4 
14f6 19			      add   HL, DE 
14f7			 
14f7			      ; An allocated block must have a null next block pointer in it 
14f7 7e			      ld    A, (HL) 
14f8 23			      inc   HL 
14f9 b6			      or    (HL) 
14fa c2 a2 15		      jp    NZ, free_done 
14fd			 
14fd 2b			      dec   HL 
14fe			 
14fe 44			      ld    B, H                    ; Copy HL to BC 
14ff 4d			      ld    C, L 
1500			 
1500			      ; Loop through the free list to find the first block with an address 
1500			      ; higher than the block being freed 
1500 21 0a 80		      ld    HL, free_list 
1503			 
1503			free_find_higher_block: 
1503 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1504 23			      inc   HL 
1505 56			      ld    D, (HL) 
1506 2b			      dec   HL 
1507			 
1507 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
150a dd 72 01		      ld    (IX+1), D 
150d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1510 dd 74 03		      ld    (IX+3), H 
1513			 
1513 78			      ld    A, B                    ; Check if DE is greater than BC 
1514 ba			      cp    D                       ; Compare MSB first 
1515 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1517 30 04		      jr    NC, free_find_higher_block_skip 
1519 79			      ld    A, C 
151a bb			      cp    E                       ; Then compare LSB 
151b 38 08		      jr    C, free_found_higher_block 
151d			 
151d			free_find_higher_block_skip: 
151d 7a			      ld    A, D                    ; Reached the end of the free list? 
151e b3			      or    E 
151f ca a2 15		      jp    Z, free_done 
1522			 
1522 eb			      ex    DE, HL 
1523			 
1523 18 de		      jr    free_find_higher_block 
1525			 
1525			free_found_higher_block: 
1525			      ; Insert freed block between prev and next free blocks 
1525 71			      ld    (HL), C                 ; Point prev free block to freed block 
1526 23			      inc   HL 
1527 70			      ld    (HL), B 
1528			 
1528 60			      ld    H, B                    ; Point freed block at next free block 
1529 69			      ld    L, C 
152a 73			      ld    (HL), E 
152b 23			      inc   HL 
152c 72			      ld    (HL), D 
152d			 
152d			      ; Check if the freed block is adjacent to the next free block 
152d 23			      inc   HL                      ; Load size of freed block into HL 
152e 5e			      ld    E, (HL) 
152f 23			      inc   HL 
1530 56			      ld    D, (HL) 
1531 eb			      ex    DE, HL 
1532			 
1532 09			      add   HL, BC                  ; Add addr of freed block and its size 
1533			 
1533 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1536 dd 56 01		      ld    D, (IX+1) 
1539			 
1539 b7			      or    A                       ; Clear the carry flag 
153a ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
153c 20 22		      jr    NZ, free_check_adjacent_to_prev 
153e			 
153e			      ; Freed block is adjacent to next, merge into one bigger block 
153e eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
153f 5e			      ld    E, (HL) 
1540 23			      inc   HL 
1541 56			      ld    D, (HL) 
1542 e5			      push  HL                      ; Save ptr to next block for later 
1543			 
1543 60			      ld    H, B                    ; Store ptr from next block into freed block 
1544 69			      ld    L, C 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548 e1			      pop   HL                      ; Restore ptr to next block 
1549 23			      inc   HL                      ; Load size of next block into DE 
154a 5e			      ld    E, (HL) 
154b 23			      inc   HL 
154c 56			      ld    D, (HL) 
154d d5			      push  DE                      ; Save next block size for later 
154e			 
154e 60			      ld    H, B                    ; Load size of freed block into HL 
154f 69			      ld    L, C 
1550 23			      inc   HL 
1551 23			      inc   HL 
1552 5e			      ld    E, (HL) 
1553 23			      inc   HL 
1554 56			      ld    D, (HL) 
1555 eb			      ex    DE, HL 
1556			 
1556 d1			      pop   DE                      ; Restore size of next block 
1557 19			      add   HL, DE                  ; Add sizes of both blocks 
1558 eb			      ex    DE, HL 
1559			 
1559 60			      ld    H, B                    ; Store new bigger size into freed block 
155a 69			      ld    L, C 
155b 23			      inc   HL 
155c 23			      inc   HL 
155d 73			      ld    (HL), E 
155e 23			      inc   HL 
155f 72			      ld    (HL), D 
1560			 
1560			free_check_adjacent_to_prev: 
1560			      ; Check if the freed block is adjacent to the prev free block 
1560 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1563 dd 66 03		      ld    H, (IX+3) 
1566			 
1566 23			      inc   HL                      ; Size of prev free block into DE 
1567 23			      inc   HL 
1568 5e			      ld    E, (HL) 
1569 23			      inc   HL 
156a 56			      ld    D, (HL) 
156b 2b			      dec   HL 
156c 2b			      dec   HL 
156d 2b			      dec   HL 
156e			 
156e 19			      add   HL, DE                  ; Add prev block addr and size 
156f			 
156f b7			      or    A                       ; Clear the carry flag 
1570 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1572 20 2e		      jr    NZ, free_done 
1574			 
1574			      ; Freed block is adjacent to prev, merge into one bigger block 
1574 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1575 69			      ld    L, C 
1576 5e			      ld    E, (HL) 
1577 23			      inc   HL 
1578 56			      ld    D, (HL) 
1579 e5			      push  HL                      ; Save freed block ptr for later 
157a			 
157a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
157d dd 66 03		      ld    H, (IX+3) 
1580 73			      ld    (HL), E 
1581 23			      inc   HL 
1582 72			      ld    (HL), D 
1583			 
1583 e1			      pop   HL                      ; Restore freed block ptr 
1584 23			      inc   HL                      ; Load size of freed block into DE 
1585 5e			      ld    E, (HL) 
1586 23			      inc   HL 
1587 56			      ld    D, (HL) 
1588 d5			      push  DE                      ; Save freed block size for later 
1589			 
1589 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
158c dd 66 03		      ld    H, (IX+3) 
158f 23			      inc   HL 
1590 23			      inc   HL 
1591 5e			      ld    E, (HL) 
1592 23			      inc   HL 
1593 56			      ld    D, (HL) 
1594			 
1594 e1			      pop   HL                      ; Add sizes of both blocks 
1595 19			      add   HL, DE 
1596 eb			      ex    DE, HL 
1597			 
1597 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
159a dd 66 03		      ld    H, (IX+3) 
159d 23			      inc   HL 
159e 23			      inc   HL 
159f 73			      ld    (HL), E 
15a0 23			      inc   HL 
15a1 72			      ld    (HL), D 
15a2			 
15a2			free_done: 
15a2 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15a5 39			      add   HL, SP 
15a6 f9			      ld    SP, HL 
15a7			 
15a7			free_early_exit: 
15a7 dd e1		      pop   IX 
15a9 d1			      pop   DE 
15aa c1			      pop   BC 
15ab			 
15ab c9			      ret 
15ac			 
15ac			; moved to firmware.asm 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			;                  .dw   0 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_3 
15ac			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15ac			;heap_start        .equ  0x9000      ; Starting address of heap 
15ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15ac			; 
15ac			 ;     .org 0 
15ac			  ;    jp    main 
15ac			; 
15ac			; 
15ac			 ;     .org  0x100 
15ac			;main: 
15ac			 ;     ld    HL, 0x8100 
15ac			  ;    ld    SP, HL 
15ac			; 
15ac			;      call  heap_init 
15ac			 
15ac			      ; Make some allocations 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9004 
15ac			; 
15ac			 ;     ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9014 
15ac			 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9024 
15ac			 
15ac			      ; Free some allocations 
15ac			;      ld    HL, 0x9014 
15ac			;      call  free 
15ac			 
15ac			;      ld    HL, 0x9004 
15ac			;      call  free 
15ac			; 
15ac			;      ld    HL, 0x9024 
15ac			;      call  free 
15ac			 
15ac			 
15ac			 ;     halt 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     heap_init                                                               : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
15ac			;                                                                             : 
15ac			;     The heap is maintained as a linked list, starting with an initial       : 
15ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15ac			;     the first free block in the heap. Each block then points to the next    : 
15ac			;     free block within the heap, and the free list ends at the first block   : 
15ac			;     with a null pointer to the next free block.                             : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
15ac			;     address of the heap and its size are required, along with a memory      : 
15ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15ac			;     principally stores a pointer to the first free block in the heap.       : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;------------------------------------------------------------------------------ 
15ac			heap_init: 
15ac			      push  HL 
15ac			 
15ac			      ; Initialise free list struct 
15ac			      ld    HL, heap_start 
15ac			      ld    (free_list), HL 
15ac			      ld    HL, 0 
15ac			      ld    (free_list+2), HL 
15ac			 
15ac			      ; Insert first free block at bottom of heap, consumes entire heap 
15ac			      ld    HL, heap_start+heap_size-4 
15ac			      ld    (heap_start), HL        ; Next block (end of free list) 
15ac			      ld    HL, heap_size-4 
15ac			      ld    (heap_start+2), HL      ; Block size 
15ac			 
15ac			      ; Insert end of free list block at top of heap - two null words will 
15ac			      ; terminate the free list 
15ac			      ld    HL, 0 
15ac			      ld    (heap_start+heap_size-2), HL 
15ac			      ld    (heap_start+heap_size-4), HL 
15ac			 
15ac			      pop   HL 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     malloc                                                                  : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Allocates the wanted space from the heap and returns the address of the : 
15ac			;     first useable byte of the allocation.                                   : 
15ac			;                                                                             : 
15ac			;     Allocations can happen in one of two ways:                              : 
15ac			;                                                                             : 
15ac			;     1. A free block may be found which is the exact size wanted. In this    : 
15ac			;        case the block is removed from the free list and retuedn to the      : 
15ac			;        caller.                                                              : 
15ac			;     2. A free block may be found which is larger than the size wanted. In   : 
15ac			;        this case, the larger block is split into two. The first portion of  : 
15ac			;        this block will become the requested space by the malloc call and    : 
15ac			;        is returned to the caller. The second portion becomes a new free     : 
15ac			;        block, and the free list is adjusted to maintain continuity via this : 
15ac			;        newly created block.                                                 : 
15ac			;                                                                             : 
15ac			;     malloc does not set any initial value in the allocated space, the       : 
15ac			;     caller is required to do this as required.                              : 
15ac			;                                                                             : 
15ac			;     This implementation of malloc uses the stack exclusively, and is        : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling malloc, and recommended  : 
15ac			;     to avoid the use of malloc inside ISRs in general.                      : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Number of bytes wanted                                              : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     HL  Address of the first useable byte of the allocation                 : 
15ac			;                                                                             : 
15ac			; Flags                                                                       : 
15ac			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +4  +-------------+                                                       : 
15ac			;       |  this_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			malloc: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if no space requested 
15ac			      or    L 
15ac			      jp    Z, malloc_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; Setup initial state 
15ac			      ld    HL, 4                   ; want must also include space used by block struct 
15ac			      add   HL, DE 
15ac			 
15ac			      ld    B, H                    ; Move want to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ld    HL, free_list           ; Store prev_free ptr to stack 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    E, (HL)                 ; Store this_free ptr to stack 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ld    (IX+2), E 
15ac			      ld    (IX+3), D 
15ac			      ex    DE, HL                  ; this_free ptr into HL 
15ac			 
15ac			      ; Loop through free block list to find some space 
15ac			malloc_find_space: 
15ac			      ld    E, (HL)                 ; Load next_free ptr into DE 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15ac			      or    E 
15ac			      jp    Z, malloc_no_space 
15ac			 
15ac			      ld    (IX+0), E               ; Store next_free ptr to stack 
15ac			      ld    (IX+1), D 
15ac			 
15ac			      ; Does this block have enough space to make the allocation? 
15ac			      inc   HL                      ; Load free block size into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ex    DE, HL                  ; Check size of block against want 
15ac			      or    A                       ; Ensure carry flag clear 
15ac			      sbc   HL, BC 
15ac			      push  HL                      ; Store the result for later (new block size) 
15ac			 
15ac			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15ac			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15ac			 
15ac			      ; this_free block is not big enough, setup ptrs to test next free block 
15ac			      pop   HL                      ; Discard previous result 
15ac			 
15ac			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15ac			      ld    H, (IX+3) 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15ac			      ld    H, (IX+1) 
15ac			      ld    (IX+2), L 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      jr    malloc_find_space 
15ac			 
15ac			      ; split a bigger block into two - requested size and remaining size 
15ac			malloc_alloc_split: 
15ac			      ex    DE, HL                  ; Calculate address of new free block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      add   HL, BC 
15ac			 
15ac			      ; Create a new block and point it at next_free 
15ac			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      ld    (HL), E                 ; Store next_free ptr into new block 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   DE                      ; Store size of new block into new block 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Update this_free ptr to point to new block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store want size into allocated block 
15ac			      ld    (HL), C 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			      inc   HL 
15ac			      push  HL                      ; Address of allocation to return 
15ac			 
15ac			      jr    malloc_update_links 
15ac			 
15ac			malloc_alloc_fit: 
15ac			      pop   HL                      ; Dont need new block size, want is exact fit 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store address of allocation to return 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      push  HL 
15ac			 
15ac			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15ac			      ld    L, (IX+0)               ; next_free to HL 
15ac			      ld    H, (IX+1) 
15ac			 
15ac			      ld    (IX+2), L               ; HL to this_free 
15ac			      ld    (IX+3), H 
15ac			 
15ac			 
15ac			malloc_update_links: 
15ac			      ; Update prev_free ptr to point to this_free 
15ac			      ld    L, (IX+4)               ; prev_free ptr to HL 
15ac			      ld    H, (IX+5) 
15ac			 
15ac			      ld    E, (IX+2)               ; this_free ptr to DE 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (HL), E                 ; this_free ptr into prev_free 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Clear the Z flag to indicate successful allocation 
15ac			      ld    A, D 
15ac			      or    E 
15ac			 
15ac			      pop   DE                      ; Address of allocation 
15ac			 
15ac			malloc_no_space: 
15ac			      ld    HL, 6                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			      ex    DE, HL                  ; Alloc addr into HL for return 
15ac			 
15ac			malloc_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     free                                                                    : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15ac			;     returned by malloc, otherwise the behaviour is undefined.               : 
15ac			;                                                                             : 
15ac			;     Where possible, directly adjacent free blocks will be merged together   : 
15ac			;     into larger blocks to help ensure that the heap does not become         : 
15ac			;     excessively fragmented.                                                 : 
15ac			;                                                                             : 
15ac			;     free does not clear or set any other value into the freed space, and    : 
15ac			;     therefore its contents may be visible through subsequent malloc's. The  : 
15ac			;     caller should clear the freed space as required.                        : 
15ac			;                                                                             : 
15ac			;     This implementation of free uses the stack exclusively, and is          : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling free, and recommended    : 
15ac			;     to avoid the use of free inside ISRs in general.                        : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Pointer to address of first byte of allocation to be freed          : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			free: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if ptr is null 
15ac			      or    L 
15ac			      jp    Z, free_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; The address in HL points to the start of the useable allocated space, 
15ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15ac			      ; address of the block itself. 
15ac			      ex    DE, HL 
15ac			      ld    DE, -4 
15ac			      add   HL, DE 
15ac			 
15ac			      ; An allocated block must have a null next block pointer in it 
15ac			      ld    A, (HL) 
15ac			      inc   HL 
15ac			      or    (HL) 
15ac			      jp    NZ, free_done 
15ac			 
15ac			      dec   HL 
15ac			 
15ac			      ld    B, H                    ; Copy HL to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ; Loop through the free list to find the first block with an address 
15ac			      ; higher than the block being freed 
15ac			      ld    HL, free_list 
15ac			 
15ac			free_find_higher_block: 
15ac			      ld    E, (HL)                 ; Load next ptr from free block 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			 
15ac			      ld    (IX+0), E               ; Save ptr to next free block 
15ac			      ld    (IX+1), D 
15ac			      ld    (IX+2), L               ; Save ptr to prev free block 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ld    A, B                    ; Check if DE is greater than BC 
15ac			      cp    D                       ; Compare MSB first 
15ac			      jr    Z, $+4                  ; MSB the same, compare LSB 
15ac			      jr    NC, free_find_higher_block_skip 
15ac			      ld    A, C 
15ac			      cp    E                       ; Then compare LSB 
15ac			      jr    C, free_found_higher_block 
15ac			 
15ac			free_find_higher_block_skip: 
15ac			      ld    A, D                    ; Reached the end of the free list? 
15ac			      or    E 
15ac			      jp    Z, free_done 
15ac			 
15ac			      ex    DE, HL 
15ac			 
15ac			      jr    free_find_higher_block 
15ac			 
15ac			free_found_higher_block: 
15ac			      ; Insert freed block between prev and next free blocks 
15ac			      ld    (HL), C                 ; Point prev free block to freed block 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			 
15ac			      ld    H, B                    ; Point freed block at next free block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Check if the freed block is adjacent to the next free block 
15ac			      inc   HL                      ; Load size of freed block into HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      add   HL, BC                  ; Add addr of freed block and its size 
15ac			 
15ac			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_check_adjacent_to_prev 
15ac			 
15ac			      ; Freed block is adjacent to next, merge into one bigger block 
15ac			      ex    DE, HL                  ; Load next ptr from next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save ptr to next block for later 
15ac			 
15ac			      ld    H, B                    ; Store ptr from next block into freed block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore ptr to next block 
15ac			      inc   HL                      ; Load size of next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save next block size for later 
15ac			 
15ac			      ld    H, B                    ; Load size of freed block into HL 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      pop   DE                      ; Restore size of next block 
15ac			      add   HL, DE                  ; Add sizes of both blocks 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    H, B                    ; Store new bigger size into freed block 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_check_adjacent_to_prev: 
15ac			      ; Check if the freed block is adjacent to the prev free block 
15ac			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15ac			      ld    H, (IX+3) 
15ac			 
15ac			      inc   HL                      ; Size of prev free block into DE 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      add   HL, DE                  ; Add prev block addr and size 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_done 
15ac			 
15ac			      ; Freed block is adjacent to prev, merge into one bigger block 
15ac			      ld    H, B                    ; Load next ptr from freed block into DE 
15ac			      ld    L, C 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save freed block ptr for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15ac			      ld    H, (IX+3) 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore freed block ptr 
15ac			      inc   HL                      ; Load size of freed block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save freed block size for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Load size of prev block into DE 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      pop   HL                      ; Add sizes of both blocks 
15ac			      add   HL, DE 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_done: 
15ac			      ld    HL, 4                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			free_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;      .org 0x8000 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			 ;                 .dw   0 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_4 
15ac			 
15ac			; My memory allocation code. Very very simple.... 
15ac			; allocate space under 250 chars 
15ac			 
15ac			heap_init: 
15ac				; init start of heap as zero 
15ac				;  
15ac			 
15ac				ld hl, heap_start 
15ac				ld a, 0 
15ac				ld (hl), a      ; empty block 
15ac				inc hl 
15ac				ld a, 0 
15ac				ld (hl), a      ; length of block 
15ac				; write end of list 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				 
15ac			 
15ac				; init some malloc vars 
15ac			 
15ac				ld hl, 0 
15ac				ld (free_list), hl       ; store last malloc location 
15ac			 
15ac				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15ac				ld a, 0 
15ac				ld (hl), a 
15ac			 
15ac			 
15ac				ld hl, heap_start 
15ac				;  
15ac				  
15ac				ret 
15ac			 
15ac			 
15ac			;    free block marker 
15ac			;    requested size  
15ac			;    pointer to next block 
15ac			;    .... 
15ac			;    next block marker 
15ac			 
15ac			 
15ac			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15ac			; 
15ac			 
15ac			 
15ac			malloc:  
15ac				push de 
15ac				push bc 
15ac				push af 
15ac			 
15ac				; hl space required 
15ac				 
15ac				ld c, l    ; hold space   (TODO only a max of 255) 
15ac			 
15ac			;	inc c     ; TODO BUG need to fix memory leak on push str 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			 
15ac			 
15ac			 
15ac				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15ac			 
15ac				ld a, (free_list+3) 
15ac				cp 0 
15ac				jr z, .contheap 
15ac			 
15ac				ld hl, (free_list)     ; get last alloc 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mrs" 
15ac						CALLMONITOR 
15ac					endif 
15ac				jr .startalloc 
15ac			 
15ac			.contheap: 
15ac				ld hl, heap_start 
15ac			 
15ac			.startalloc: 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mym" 
15ac						CALLMONITOR 
15ac					endif 
15ac			.findblock: 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmf" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac				ld a,(hl)  
15ac				; if byte is zero then clear to use 
15ac			 
15ac				cp 0 
15ac				jr z, .foundemptyblock 
15ac			 
15ac				; if byte is not clear 
15ac				;     then byte is offset to next block 
15ac			 
15ac				inc hl 
15ac				ld a, (hl) ; get size 
15ac			.nextblock:	inc hl 
15ac					ld e, (hl) 
15ac					inc hl 
15ac					ld d, (hl) 
15ac					ex de, hl 
15ac			;	inc hl  ; move past the store space 
15ac			;	inc hl  ; move past zero index  
15ac			 
15ac				; TODO detect no more space 
15ac			 
15ac				push hl 
15ac				ld de, heap_end 
15ac				call cmp16 
15ac				pop hl 
15ac				jr nc, .nospace 
15ac			 
15ac				jr .findblock 
15ac			 
15ac			.nospace: ld hl, 0 
15ac				jp .exit 
15ac			 
15ac			 
15ac			.foundemptyblock:	 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mme" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; TODO has block enough space if reusing??? 
15ac			 
15ac				;  
15ac			 
15ac			; see if this block has been previously used 
15ac				inc hl 
15ac				ld a, (hl) 
15ac				dec hl 
15ac				cp 0 
15ac				jr z, .newblock 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meR" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; no reusing previously allocated block 
15ac			 
15ac			; is it smaller than previously used? 
15ac				 
15ac				inc hl    ; move to size 
15ac				ld a, c 
15ac				sub (hl)        ; we want c < (hl) 
15ac				dec hl    ; move back to marker 
15ac			        jr z, .findblock 
15ac			 
15ac				; update with the new size which should be lower 
15ac			 
15ac			        ;inc  hl   ; negate next move. move back to size  
15ac			 
15ac			.newblock: 
15ac				; need to be at marker here 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meN" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			 
15ac				ld a, c 
15ac			 
15ac				ld (free_list+3), a	 ; flag resume from last malloc  
15ac				ld (free_list), hl    ; save out last location 
15ac			 
15ac			 
15ac				;inc a     ; space for length byte 
15ac				ld (hl), a     ; save block in use marker 
15ac			 
15ac				inc hl   ; move to space marker 
15ac				ld (hl), a    ; save new space 
15ac			 
15ac				inc hl   ; move to start of allocated area 
15ac				 
15ac			;	push hl     ; save where we are - 1  
15ac			 
15ac			;	inc hl  ; move past zero index  
15ac				; skip space to set down new marker 
15ac			 
15ac				; provide some extra space for now 
15ac			 
15ac				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15ac				inc a 
15ac				inc a 
15ac			 
15ac				push hl   ; save where we are in the node block 
15ac			 
15ac				call addatohl 
15ac			 
15ac				; write linked list point 
15ac			 
15ac				pop de     ; get our node position 
15ac				ex de, hl 
15ac			 
15ac				ld (hl), e 
15ac				inc hl 
15ac				ld (hl), d 
15ac			 
15ac				inc hl 
15ac			 
15ac				; now at start of allocated data so save pointer 
15ac			 
15ac				push hl 
15ac			 
15ac				; jump to position of next node and setup empty header in DE 
15ac			 
15ac				ex de, hl 
15ac			 
15ac			;	inc hl ; move past end of block 
15ac			 
15ac				ld a, 0 
15ac				ld (hl), a   ; empty marker 
15ac				inc hl 
15ac				ld (hl), a   ; size 
15ac				inc hl  
15ac				ld (hl), a   ; ptr 
15ac				inc hl 
15ac				ld (hl), a   ; ptr 
15ac			 
15ac			 
15ac				pop hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmr" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			.exit: 
15ac				pop af 
15ac				pop bc 
15ac				pop de  
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			 
15ac			free:  
15ac				push hl 
15ac				push af 
15ac				; get address in hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "fre" 
15ac						CALLMONITOR 
15ac					endif 
15ac				; data is at hl - move to block count 
15ac				dec hl 
15ac				dec hl    ; get past pointer 
15ac				dec hl 
15ac			 
15ac				ld a, (hl)    ; need this for a validation check 
15ac			 
15ac				dec hl    ; move to block marker 
15ac			 
15ac				; now check that the block count and block marker are the same  
15ac			        ; this checks that we are on a malloc node and not random memory 
15ac			        ; OK a faint chance this could be a problem but rare - famous last words! 
15ac			 
15ac				ld c, a 
15ac				ld a, (hl)    
15ac			 
15ac				cp c 
15ac				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15ac			 
15ac				; yes good chance we are on a malloc node 
15ac			 
15ac				ld a, 0      
15ac				ld (hl), a   ; mark as free 
15ac			 
15ac				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15ac			 
15ac			.freeignore:  
15ac			 
15ac				pop af 
15ac				pop hl 
15ac			 
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			; eof 
# End of file firmware_memory.asm
15ac			  
15ac			; device C  
15ac			if SOUND_ENABLE  
15ac				include "firmware_sound.asm"  
15ac			; Sound abstraction layer 
15ac			 
15ac			; support different sound chips through common interface 
15ac			 
15ac			SOUND_DEVICE_AY: equ 0 
15ac			 
15ac			SOUND_DEVICE: equ Device_A 
15ac			 
15ac			 
15ac			 
15ac			if SOUND_DEVICE_AY 
15ac				include "firmware_sound_ay38910.asm" 
15ac			else 
15ac				include "firmware_sound_sn76489an.asm" 
15ac			 
15ac			; Device support for SN76489AN sound chip 
15ac			 
15ac			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
15ac			; http://danceswithferrets.org/geekblog/?p=93 
15ac			; https://www.smspower.org/Development/SN76489 
15ac			 
15ac			; D0 [ 3] 
15ac			; D1 [ 2] 
15ac			; D2 [ 1] 
15ac			; D3 [15] 
15ac			; D4 [13] 
15ac			; D5 [12] 
15ac			; D6 [11] 
15ac			; D7 [10] 
15ac			; /WE [ 5] 
15ac			; CLK [14] 
15ac			; /OE [ 6] 
15ac			; AUDIO [ 7] 
15ac			; GND 8 
15ac			; +5 16 
15ac			; 
15ac			 
15ac			; Write sequence: 
15ac			; CE low 
15ac			; Data bus 
15ac			; WE low then high 
15ac			; 32 clock cycles / 8ns write time at 4mhz 
15ac			; 
15ac			; https://github.com/jblang/SN76489 
15ac			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
15ac			; Tried: 
15ac			; 
15ac			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
15ac			; 
15ac			; Connected WE to OR too 
15ac			;  
15ac			; That enabled the clock when required 
15ac			; However still random bus corruption. Need further investigation 
15ac			 
15ac			 
15ac			SOUND_LATCH: equ 10000000B 
15ac			SOUND_DATA: equ 0B 
15ac			SOUND_CH0:  equ 0B    ; Tone 
15ac			SOUND_CH1: equ 0100000B        ; Tone 
15ac			SOUND_CH2: equ 1000000B   ; Tone 
15ac			SOUND_CH3: equ 1100000B    ; Noise 
15ac			SOUND_VOL: equ 10000B 
15ac			SOUND_TONE: equ 0B 
15ac			 
15ac			 
15ac			sound_init: 
15ac 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
15ae cd c3 15			call note_send_byte 
15b1 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
15b3 cd c3 15			call note_send_byte 
15b6 cd 89 0c			call delay250ms 
15b9 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
15bb cd c3 15			call note_send_byte 
15be cd 89 0c			call delay250ms 
15c1 c9				ret 
15c2			 
15c2			; Play a note 
15c2			; h = note 
15c2			; l = duration 
15c2			; a = channel 
15c2			 
15c2			 
15c2			;  frequ = clock / ( 2 x reg valu x 32 )  
15c2			 
15c2			note:  
15c2				 
15c2			 
15c2 c9				ret 
15c3			 
15c3			note_send_byte: 
15c3				; byte in a 
15c3			 
15c3				; we high 
15c3 d3 40			out (Device_B), a 
15c5			;	ld a, 1 
15c5			;	call aDelayInMS 
15c5 00				nop  
15c6 00				nop  
15c7 00				nop  
15c8 00				nop  
15c9				; we low 
15c9 d3 40			out (Device_B), a 
15cb			;	ld a, 1 
15cb			;	call aDelayInMS 
15cb 00				nop  
15cc 00				nop  
15cd 00				nop  
15ce 00				nop  
15cf				; we high 
15cf d3 40			out (Device_B), a 
15d1			;	ld a, 1 
15d1			;	call aDelayInMS 
15d1 00				nop  
15d2 00				nop  
15d3 00				nop  
15d4 00				nop  
15d5			 
15d5			 
15d5 c9				ret 
15d6			 
15d6			;void SilenceAllChannels() 
15d6			;{ 
15d6			;  SendByte(0x9f); 
15d6			;  SendByte(0xbf); 
15d6			;  SendByte(0xdf); 
15d6			;  SendByte(0xff); 
15d6			;} 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound_sn76489an.asm
15d6			endif 
15d6			 
15d6			 
15d6			; Abstraction entry points 
15d6			 
15d6			; init  
15d6			 
15d6			; sound_init in specific hardware files 
15d6			 
15d6			; Play a note 
15d6			; h = note 
15d6			; l = duration 
15d6			; a = channel 
15d6			 
15d6			;note:     
15d6			;	ret 
15d6			 
15d6			 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound.asm
15d6			endif  
15d6			  
15d6			include "firmware_diags.asm"  
15d6			; Hardware diags menu 
15d6			 
15d6			 
15d6			config: 
15d6			 
15d6 3e 00			ld a, 0 
15d8 21 0b 16			ld hl, .configmn 
15db cd 49 0d			call menu 
15de			 
15de fe 00			cp 0 
15e0 c8				ret z 
15e1			 
15e1 fe 01			cp 1 
15e3 cc 4d 16			call z, .savetostore 
15e6			 
15e6 fe 02			cp 2 
15e8			if STARTUP_V1 
15e8				call z, .selautoload 
15e8			endif 
15e8			 
15e8			if STARTUP_V2 
15e8 cc 1d 16			call z, .enautoload 
15eb			endif 
15eb fe 03			cp 3 
15ed cc 34 16			call z, .disautoload 
15f0 fe 04			cp 4 
15f2 cc 4b 16			call z, .selbank 
15f5 fe 05			cp 5 
15f7 cc 65 18			call z, .debug_tog 
15fa fe 06			cp 6 
15fc cc a8 19			call z, .bpsgo 
15ff fe 07			cp 7 
1601 cc 8b 18			call z, hardware_diags 
1604			if STARTUP_V2 
1604 fe 08			cp 8 
1606 cc 5f 16			call z, create_startup 
1609			endif 
1609 18 cb			jr config 
160b			 
160b			.configmn: 
160b 99 1b			dw prom_c3 
160d b0 1b			dw prom_c2 
160f c6 1b			dw prom_c2a 
1611 20 1c			dw prom_c2b 
1613			;	dw prom_c4 
1613 3d 1c			dw prom_m4 
1615 58 1c			dw prom_m4b 
1617 60 1c			dw prom_c1 
1619			if STARTUP_V2 
1619 6f 1c			dw prom_c9 
161b			endif 
161b 00 00			dw 0 
161d				 
161d			 
161d			if STARTUP_V2 
161d			.enautoload: 
161d				if STORAGE_SE 
161d 3e fe			ld a, $fe      ; bit 0 clear 
161f 32 67 fa			ld (spi_device), a 
1622			 
1622 cd cd 04			call storage_get_block_0 
1625			 
1625 3e 01			ld a, 1 
1627 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
162a			 
162a 21 00 00				ld hl, 0 
162d 11 81 fa				ld de, store_page 
1630 cd 81 04			call storage_write_block	 ; save update 
1633				else 
1633			 
1633				ld hl, prom_notav 
1633				ld de, prom_empty 
1633				call info_panel 
1633				endif 
1633			 
1633			 
1633 c9				ret 
1634			endif 
1634			 
1634			.disautoload: 
1634				if STORAGE_SE 
1634 3e fe			ld a, $fe      ; bit 0 clear 
1636 32 67 fa			ld (spi_device), a 
1639			 
1639 cd cd 04			call storage_get_block_0 
163c			 
163c 3e 00			ld a, 0 
163e 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
1641			 
1641 21 00 00				ld hl, 0 
1644 11 81 fa				ld de, store_page 
1647 cd 81 04			call storage_write_block	 ; save update 
164a				else 
164a			 
164a				ld hl, prom_notav 
164a				ld de, prom_empty 
164a				call info_panel 
164a				endif 
164a			 
164a			 
164a c9				ret 
164b			 
164b			if STARTUP_V1 
164b			 
164b			; Select auto start 
164b			 
164b			.selautoload: 
164b			 
164b				 
164b				if STORAGE_SE 
164b			 
164b					call config_dir 
164b				        ld hl, scratch 
164b					ld a, 0 
164b					call menu 
164b			 
164b					cp 0 
164b					ret z 
164b			 
164b					dec a 
164b			 
164b			 
164b					; locate menu option 
164b			 
164b					ld hl, scratch 
164b					call table_lookup 
164b			 
164b					if DEBUG_FORTH_WORDS 
164b						DMARK "ALl" 
164b						CALLMONITOR 
164b					endif 
164b					; with the pointer to the menu it, the byte following the zero term is the file id 
164b			 
164b					ld a, 0 
164b					ld bc, 50   ; max of bytes to look at 
164b					cpir  
164b			 
164b					if DEBUG_FORTH_WORDS 
164b						DMARK "ALb" 
164b						CALLMONITOR 
164b					endif 
164b					;inc hl 
164b			 
164b					ld a, (hl)   ; file id 
164b					 
164b				        ; save bank and file ids 
164b			 
164b					push af 
164b			 
164b			; TODO need to save to block 0 on bank 1	 
164b			 
164b					call storage_get_block_0 
164b			 
164b					if DEBUG_FORTH_WORDS 
164b						DMARK "AL0" 
164b						CALLMONITOR 
164b					endif 
164b					pop af 
164b			 
164b					ld (store_page+STORE_0_FILERUN),a 
164b					 
164b					; save bank id 
164b			 
164b					ld a,(spi_device) 
164b					ld (store_page+STORE_0_BANKRUN),a 
164b			 
164b					; enable auto run of store file 
164b			 
164b					ld a, 1 
164b					ld (store_page+STORE_0_AUTOFILE),a 
164b			 
164b					; save buffer 
164b			 
164b					ld hl, 0 
164b					ld de, store_page 
164b					if DEBUG_FORTH_WORDS 
164b						DMARK "ALw" 
164b						CALLMONITOR 
164b					endif 
164b				call storage_write_block	 ; save update 
164b			  
164b			 
164b			 
164b			 
164b					ld hl, scratch 
164b					call config_fdir 
164b			 
164b				else 
164b			 
164b				ld hl, prom_notav 
164b				ld de, prom_empty 
164b				call info_panel 
164b			 
164b				endif 
164b				ret 
164b			endif 
164b			 
164b			 
164b			; Select storage bank 
164b			 
164b			.selbank: 
164b			 
164b				if STORAGE_SE 
164b				else 
164b			 
164b				ld hl, prom_notav 
164b				ld de, prom_empty 
164b				call info_panel 
164b				endif 
164b				 
164b c9				ret 
164c			 
164c			if STORAGE_SE 
164c			 
164c			.config_ldir:   
164c				; Load storage bank labels into menu array 
164c			 
164c				 
164c			 
164c			 
164c c9				ret 
164d			 
164d			 
164d			endif 
164d			 
164d			 
164d			; Save user words to storage 
164d			 
164d			.savetostore: 
164d			 
164d				if STORAGE_SE 
164d			 
164d cd af 17				call config_dir 
1650 21 c8 f1			        ld hl, scratch 
1653 3e 00				ld a, 0 
1655 cd 49 0d				call menu 
1658					 
1658 21 c8 f1				ld hl, scratch 
165b cd 9c 17				call config_fdir 
165e			 
165e				else 
165e			 
165e				ld hl, prom_notav 
165e				ld de, prom_empty 
165e				call info_panel 
165e			 
165e				endif 
165e			 
165e c9				ret 
165f			 
165f			if STARTUP_V2 
165f			 
165f			create_startup: 
165f			 
165f 3e 00			ld a, 0 
1661 21 8e 17			ld hl, .crstart 
1664 cd 49 0d			call menu 
1667			 
1667 fe 00			cp 0 
1669 c8				ret z 
166a			 
166a fe 01			cp 1 
166c cc 8a 16			call z, .genlsword 
166f fe 02			cp 2 
1671 cc 94 16			call z, .genedword 
1674			 
1674 fe 03			cp 3 
1676 cc 9e 16			call z, .gendemword 
1679			 
1679 fe 04			cp 4 
167b cc a8 16			call z, .genutlword 
167e fe 05			cp 5 
1680 cc b2 16			call z, .genspiword 
1683 fe 06			cp 6 
1685 cc bc 16			call z, .genkeyword 
1688 18 d5			jr create_startup 
168a			 
168a			.genlsword: 
168a 21 dd 1b			ld hl, crs_s1 
168d 11 fa 16			ld de, .lsworddef 
1690 cd c6 16			call .genfile 
1693 c9				ret 
1694			 
1694			.genedword: 
1694 11 fe 16			ld de, .edworddef 
1697 21 e6 1b			ld hl, crs_s2 
169a cd c6 16			call .genfile 
169d c9				ret 
169e			 
169e			.gendemword: 
169e 11 06 17			ld de, .demoworddef 
16a1 21 ef 1b			ld hl, crs_s3 
16a4 cd c6 16			call .genfile 
16a7 c9				ret 
16a8			 
16a8			.genutlword: 
16a8 21 fe 1b			ld hl, crs_s4 
16ab 11 e6 16			ld de, .utilwordef 
16ae cd c6 16			call .genfile 
16b1 c9				ret 
16b2			.genspiword: 
16b2 21 05 1c			ld hl, crs_s5 
16b5 11 4c 17			ld de, .spiworddef 
16b8 cd c6 16			call .genfile 
16bb c9				ret 
16bc			.genkeyword: 
16bc 21 11 1c			ld hl, crs_s6 
16bf 11 62 17			ld de, .keyworddef 
16c2 cd c6 16			call .genfile 
16c5 c9				ret 
16c6			 
16c6			; hl - points to file name 
16c6			; de - points to strings to add to file 
16c6			 
16c6			.genfile: 
16c6 d5				push de 
16c7 cd 1f 08			call storage_create 
16ca				; id in hl 
16ca d1				pop de   ; table of strings to add 
16cb			 
16cb			.genloop: 
16cb			 
16cb e5				push hl ; save id for next time around 
16cc d5				push de ; save de for next time around 
16cd			 
16cd eb				ex de, hl 
16ce cd 98 23			call loadwordinhl 
16d1 eb				ex de, hl 
16d2			 
16d2				; need hl to be the id 
16d2				; need de to be the string ptr 
16d2				 
16d2 cd 0c 0b			call storage_append 
16d5			 
16d5 d1				pop de 
16d6 e1				pop hl 
16d7			 
16d7 13				inc de 
16d8 13				inc de 
16d9			 
16d9 1a				ld a,(de) 
16da fe 00			cp 0 
16dc 20 ed			jr nz, .genloop 
16de 13				inc de 
16df 1a				ld a, (de) 
16e0 1b				dec de 
16e1 fe 00			cp 0 
16e3 20 e6			jr nz, .genloop	 
16e5			 
16e5 c9				ret 
16e6			 
16e6			 
16e6			.utilwordef: 
16e6 7a 62			dw strncpy 
16e8 56 62			dw type 
16ea 23 62			dw clrstack 
16ec dc 61			dw longread 
16ee db 62			dw start1 
16f0 eb 62			dw start2 
16f2 fc 62			dw start3b 
16f4 77 63			dw start3c 
16f6 d7 63			dw list 
16f8 00 00			dw 0 
16fa			 
16fa			.lsworddef: 
16fa fc 62			dw start3b 
16fc 00 00			dw 0 
16fe			 
16fe			.edworddef: 
16fe 6a 5e			dw edit1 
1700 8b 5e			dw edit2 
1702 c0 5e			dw edit3 
1704 00 00			dw 0 
1706			 
1706			.demoworddef: 
1706 1f 68			dw test5 
1708 57 68			dw test6 
170a 8f 68			dw test7 
170c a3 68			dw test8 
170e cf 68			dw test9 
1710 e5 68			dw test10 
1712 29 69			dw game1 
1714 3a 69			dw game1a 
1716 9c 69			dw game1b 
1718 d1 69			dw game1c 
171a 07 6a			dw game1d 
171c 38 6a			dw game1s 
171e 4c 6a			dw game1t 
1720 61 6a			dw game1f 
1722 95 6a			dw game1z 
1724 d9 6a			dw game1zz 
1726 42 6b			dw ssv2 
1728 78 6b			dw ssv3 
172a 94 6b			dw ssv4 
172c b0 6b			dw ssv5 
172e c9 6b			dw ssv1 
1730 11 6c			dw ssv1cpm	 
1732 68 6c			dw game2b 
1734 d6 6c			dw game2bf 
1736 20 6d			dw game2mba 
1738 b6 6d			dw game2mbas	 
173a db 6d			dw game2mbht 
173c ea 6d			dw game2mbms 
173e f8 6d			dw game2mb 
1740 75 6e			dw game3w 
1742 a3 6e			dw game3p 
1744 c1 6e			dw game3sc 
1746 f2 6e			dw game3vsi 
1748 1e 6f			dw game3vs 
174a 00 00			dw 0 
174c			 
174c			 
174c			.spiworddef: 
174c			 
174c f8 5e		    dw spi1 
174e 51 5f		    dw spi2 
1750 df 5f		    dw spi3 
1752 87 5f		    dw spi4 
1754 b2 5f		    dw spi5 
1756 45 60		    dw spi6 
1758 9a 60		    dw spi7 
175a			 
175a f2 60		    dw spi8 
175c 11 61		    dw spi9 
175e 69 61		    dw spi10 
1760 00 00		    dw 0 
1762			 
1762			.keyworddef: 
1762			 
1762 5d 6f			dw keyup 
1764 6b 6f			dw keydown 
1766 7b 6f			dw keyleft 
1768 8b 6f			dw keyright 
176a 9c 6f			dw 	keyf1 
176c aa 6f			dw keyf2 
176e b8 6f			dw keyf3 
1770 c6 6f			dw keyf4 
1772 d4 6f			dw keyf5 
1774 e2 6f			dw keyf6 
1776 f0 6f			dw keyf7 
1778 fe 6f			dw keyf8 
177a 0c 70			dw keyf9 
177c 1a 70			dw keyf10 
177e 29 70			dw keyf11 
1780 38 70			dw keyf12 
1782 47 70			dw keytab 
1784 56 70			dw keycr 
1786 64 70			dw keyhome 
1788 74 70			dw keyend 
178a 83 70			dw keybs 
178c 00 00			dw 0 
178e			 
178e			.crstart: 
178e dd 1b			dw crs_s1 
1790 e6 1b			dw crs_s2 
1792 ef 1b			dw crs_s3 
1794 fe 1b			dw crs_s4 
1796 05 1c			dw crs_s5 
1798 11 1c			dw crs_s6 
179a 00 00			dw 0 
179c			 
179c			endif 
179c			 
179c			 
179c			if STORAGE_SE 
179c			 
179c			config_fdir: 
179c				; using the scratch dir go through and release the memory allocated for each string 
179c				 
179c 21 c8 f1			ld hl, scratch 
179f 5e			.cfdir:	ld e,(hl) 
17a0 23				inc hl 
17a1 56				ld d,(hl) 
17a2 23				inc hl 
17a3			 
17a3 eb				ex de, hl 
17a4 cd 75 0f			call ishlzero 
17a7 c8				ret z     ; return on null pointer 
17a8 cd dd 14			call free 
17ab eb				ex de, hl 
17ac 18 f1			jr .cfdir 
17ae			 
17ae			 
17ae c9				ret 
17af			 
17af			 
17af			config_dir: 
17af			 
17af				; for the config menus that need to build a directory of storage call this routine 
17af				; it will construct a menu in scratch to pass to menu 
17af			 
17af				; open storage device 
17af			 
17af				; execute DIR to build a list of files and their ids into scratch in menu format 
17af				; once the menu has finished then will need to call config_fdir to release the strings 
17af				 
17af				; c = number items 
17af			 
17af				 
17af cd cd 04			call storage_get_block_0 
17b2			 
17b2 21 81 fa			ld hl, store_page     ; get current id count 
17b5 46				ld b, (hl) 
17b6 0e 00			ld c, 0    ; count of files   
17b8			 
17b8			 
17b8 21 c8 f1			ld hl, scratch 
17bb 22 78 fa			ld (store_tmp2), hl    ; location to poke strings 
17be			 
17be				; check for empty drive 
17be			 
17be 3e 00			ld a, 0 
17c0 b8				cp b 
17c1 ca 5b 18			jp z, .dirdone 
17c4			 
17c4				 
17c4					if DEBUG_FORTH_WORDS 
17c4						DMARK "Cdc" 
17c4 f5				push af  
17c5 3a d9 17			ld a, (.dmark)  
17c8 32 6e fe			ld (debug_mark),a  
17cb 3a da 17			ld a, (.dmark+1)  
17ce 32 6f fe			ld (debug_mark+1),a  
17d1 3a db 17			ld a, (.dmark+2)  
17d4 32 70 fe			ld (debug_mark+2),a  
17d7 18 03			jr .pastdmark  
17d9 ..			.dmark: db "Cdc"  
17dc f1			.pastdmark: pop af  
17dd			endm  
# End of macro DMARK
17dd						CALLMONITOR 
17dd cd 9e 19			call break_point_state  
17e0				endm  
# End of macro CALLMONITOR
17e0					endif 
17e0			 
17e0			 
17e0			.diritem:	 
17e0 c5				push bc 
17e1				; for each of the current ids do a search for them and if found push to stack 
17e1			 
17e1 21 40 00				ld hl, STORE_BLOCK_PHY 
17e4 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
17e6 58					ld e,b 
17e7			 
17e7 cd 4f 07				call storage_findnextid 
17ea			 
17ea			 
17ea					; if found hl will be non zero 
17ea			 
17ea cd 75 0f				call ishlzero 
17ed 28 69				jr z, .dirnotfound 
17ef			 
17ef					; increase count 
17ef			 
17ef c1					pop bc	 
17f0 0c					inc c 
17f1 c5					push bc 
17f2					 
17f2			 
17f2					; get file header and push the file name 
17f2			 
17f2 11 81 fa				ld de, store_page 
17f5 cd 1c 04				call storage_read_block 
17f8			 
17f8					; push file id to stack 
17f8				 
17f8 3a 81 fa				ld a, (store_page) 
17fb 26 00				ld h, 0 
17fd 6f					ld l, a 
17fe			 
17fe					;call forth_push_numhl 
17fe					; TODO store id 
17fe			 
17fe e5					push hl 
17ff			 
17ff					; push extent count to stack  
17ff				 
17ff 21 84 fa				ld hl, store_page+3 
1802			 
1802					; get file name length 
1802			 
1802 cd aa 13				call strlenz   
1805			 
1805 23					inc hl   ; cover zero term 
1806 23					inc hl  ; stick the id at the end of the area 
1807			 
1807 e5					push hl 
1808 c1					pop bc    ; move length to bc 
1809			 
1809 cd 13 14				call malloc 
180c			 
180c					; TODO save malloc area to scratch 
180c			 
180c eb					ex de, hl 
180d 2a 78 fa				ld hl, (store_tmp2) 
1810 73					ld (hl), e 
1811 23					inc hl 
1812 72					ld (hl), d 
1813 23					inc hl 
1814 22 78 fa				ld (store_tmp2), hl 
1817			 
1817					 
1817			 
1817					;pop hl   ; get source 
1817			;		ex de, hl    ; swap aronund	 
1817			 
1817 21 84 fa				ld hl, store_page+3 
181a					if DEBUG_FORTH_WORDS 
181a						DMARK "CFd" 
181a f5				push af  
181b 3a 2f 18			ld a, (.dmark)  
181e 32 6e fe			ld (debug_mark),a  
1821 3a 30 18			ld a, (.dmark+1)  
1824 32 6f fe			ld (debug_mark+1),a  
1827 3a 31 18			ld a, (.dmark+2)  
182a 32 70 fe			ld (debug_mark+2),a  
182d 18 03			jr .pastdmark  
182f ..			.dmark: db "CFd"  
1832 f1			.pastdmark: pop af  
1833			endm  
# End of macro DMARK
1833						CALLMONITOR 
1833 cd 9e 19			call break_point_state  
1836				endm  
# End of macro CALLMONITOR
1836					endif 
1836 ed b0				ldir 
1838			 
1838					; de is past string, move back one and store id 
1838					 
1838 1b					dec de 
1839			 
1839					; store file id 
1839			 
1839 e1					pop hl 
183a eb					ex de,hl 
183b 73					ld (hl), e 
183c			 
183c					if DEBUG_FORTH_WORDS 
183c						DMARK "Cdi" 
183c f5				push af  
183d 3a 51 18			ld a, (.dmark)  
1840 32 6e fe			ld (debug_mark),a  
1843 3a 52 18			ld a, (.dmark+1)  
1846 32 6f fe			ld (debug_mark+1),a  
1849 3a 53 18			ld a, (.dmark+2)  
184c 32 70 fe			ld (debug_mark+2),a  
184f 18 03			jr .pastdmark  
1851 ..			.dmark: db "Cdi"  
1854 f1			.pastdmark: pop af  
1855			endm  
# End of macro DMARK
1855						CALLMONITOR 
1855 cd 9e 19			call break_point_state  
1858				endm  
# End of macro CALLMONITOR
1858					endif 
1858					 
1858			.dirnotfound: 
1858 c1					pop bc     
1859 10 85				djnz .diritem 
185b				 
185b			.dirdone:	 
185b			 
185b 3e 00				ld a, 0 
185d 2a 78 fa				ld hl, (store_tmp2) 
1860 77					ld (hl), a 
1861 23					inc hl 
1862 77					ld (hl), a 
1863 23					inc hl 
1864					; push a count of the dir items found 
1864			 
1864			;		ld h, 0 
1864			;		ld l, c 
1864			 
1864 c9				ret 
1865			 
1865			endif 
1865			 
1865			 
1865			; Settings 
1865			; Run  
1865			 
1865			 
1865			 
1865			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1865			;;hd_menu2:   db "        2: Editor",0   
1865			;hd_menu2:   db "        2: Editor       6: Menu",0   
1865			;hd_menu3:   db "        3: Storage",0 
1865			;hd_menu4:   db "0=quit  4: Debug",0 
1865			;hd_don:     db "ON",0 
1865			;hd_doff:     db "OFF",0 
1865			; 
1865			; 
1865			; 
1865			;hardware_diags_old:       
1865			; 
1865			;.diagmenu: 
1865			;	call clear_display 
1865			;	ld a, display_row_1 
1865			;	ld de, hd_menu1 
1865			;	call str_at_display 
1865			; 
1865			;	ld a, display_row_2 
1865			;	ld de, hd_menu2 
1865			;	call str_at_display 
1865			; 
1865			;	ld a, display_row_3 
1865			;	ld de, hd_menu3 
1865			;	call str_at_display 
1865			; 
1865			;	ld a,  display_row_4 
1865			;	ld de, hd_menu4 
1865			;	call str_at_display 
1865			; 
1865			;	; display debug state 
1865			; 
1865			;	ld de, hd_don 
1865			;	ld a, (os_view_disable) 
1865			;	cp 0 
1865			;	jr z, .distog 
1865			;	ld de, hd_doff 
1865			;.distog: ld a, display_row_4+17 
1865			;	call str_at_display 
1865			; 
1865			;	call update_display 
1865			; 
1865			;	call cin_wait 
1865			; 
1865			; 
1865			; 
1865			;	cp '4' 
1865			;	jr nz, .diagn1 
1865			; 
1865			;	; debug toggle 
1865			; 
1865			;	ld a, (os_view_disable) 
1865			;	ld b, '*' 
1865			;	cp 0 
1865			;	jr z, .debtog 
1865			;	ld b, 0 
1865			;.debtog:	 
1865			;	ld a,b 
1865			;	ld (os_view_disable),a 
1865			; 
1865			;.diagn1: cp '0' 
1865			;	 ret z 
1865			; 
1865			;;	cp '1' 
1865			;;       jp z, matrix	 
1865			;;   TODO keyboard matrix test 
1865			; 
1865			;	cp '2' 
1865			;	jp z, .diagedit 
1865			; 
1865			;;	cp '6' 
1865			;;	jp z, .menutest 
1865			;;if ENABLE_BASIC 
1865			;;	cp '6' 
1865			;;	jp z, basic 
1865			;;endif 
1865			 ; 
1865			;	jp .diagmenu 
1865			; 
1865			; 
1865			;	ret 
1865			 
1865			 
1865			.debug_tog: 
1865 21 ac 18			ld hl, .menudebug 
1868				 
1868 3a b9 f1			ld a, (os_view_disable) 
186b fe 2a			cp '*' 
186d 20 04			jr nz,.tdon  
186f 3e 01			ld a, 1 
1871 18 02			jr .tog1 
1873 3e 00		.tdon: ld a, 0 
1875			 
1875			.tog1: 
1875 cd 49 0d			call menu 
1878 fe 00			cp 0 
187a c8				ret z 
187b fe 01			cp 1    ; disable debug 
187d 28 04			jr z, .dtog0 
187f 3e 2a			ld a, '*' 
1881 18 02			jr .dtogset 
1883 3e 00		.dtog0: ld a, 0 
1885 32 b9 f1		.dtogset:  ld (os_view_disable), a 
1888 c3 65 18			jp .debug_tog 
188b			 
188b			 
188b			hardware_diags:       
188b			 
188b			.diagm: 
188b 21 9e 18			ld hl, .menuitems 
188e 3e 00			ld a, 0 
1890 cd 49 0d			call menu 
1893			 
1893 fe 00		         cp 0 
1895 c8				 ret z 
1896			 
1896 fe 02			cp 2 
1898 ca f7 18			jp z, .diagedit 
189b			 
189b			;	cp '6' 
189b			;	jp z, .menutest 
189b			;if ENABLE_BASIC 
189b			;	cp '6' 
189b			;	jp z, basic 
189b			;endif 
189b			  
189b c3 8b 18			jp .diagm 
189e			 
189e				 
189e b2 18		.menuitems:   	dw .m1 
18a0 bd 18				dw .m2 
18a2 c4 18				dw .m3 
18a4 cc 18				dw .m5 
18a6 d2 18				dw .m5a 
18a8 db 18				dw .m5b 
18aa 00 00				dw 0 
18ac			 
18ac			.menudebug: 
18ac e4 18				dw .m6 
18ae ed 18				dw .m7 
18b0 00 00				dw 0 
18b2			 
18b2 .. 00		.m1:   db "Key Matrix",0 
18bd .. 00		.m2:   db "Editor",0 
18c4 .. 00		.m3:   db "Storage",0 
18cc .. 00		.m5:   db "Sound",0 
18d2 .. 00		.m5a:  db "RAM Test",0 
18db .. 00		.m5b:  db "LCD Test",0 
18e4			 
18e4 .. 00		.m6:   db "Debug ON",0 
18ed .. 00		.m7:   db "Debug OFF",0 
18f7			 
18f7			; debug editor 
18f7			 
18f7			.diagedit: 
18f7			 
18f7 21 c8 f1			ld hl, scratch 
18fa			;	ld bc, 250 
18fa			;	ldir 
18fa				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18fa 3e 00			ld a, 0 
18fc 77				ld (hl), a 
18fd 23				inc hl 
18fe 77				ld (hl), a 
18ff 23				inc hl 
1900 77				ld (hl), a 
1901			 
1901 cd 18 0d		        call clear_display 
1904 cd 3b 0d			call update_display 
1907				;ld a, 1 
1907				;ld (hardware_diag), a 
1907			.diloop: 
1907 3e 00			ld a, display_row_1 
1909 0e 00			ld c, 0 
190b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
190d 1e 28			ld e, 40 
190f			 
190f 21 c8 f1			ld hl, scratch	 
1912 cd 79 0f			call input_str 
1915			 
1915 3e 28			ld a, display_row_2 
1917 11 c8 f1			ld de, scratch 
191a cd 2b 0d			call str_at_display 
191d cd 3b 0d			call update_display 
1920			 
1920 c3 07 19			jp .diloop 
1923			 
1923			 
1923			; pass word in hl 
1923			; a has display location 
1923			display_word_at: 
1923 f5				push af 
1924 e5				push hl 
1925 7c				ld a,h 
1926 21 cd f4			ld hl, os_word_scratch 
1929 cd 4d 12			call hexout 
192c e1				pop hl 
192d 7d				ld a,l 
192e 21 cf f4			ld hl, os_word_scratch+2 
1931 cd 4d 12			call hexout 
1934 21 d1 f4			ld hl, os_word_scratch+4 
1937 3e 00			ld a,0 
1939 77				ld (hl),a 
193a 11 cd f4			ld de,os_word_scratch 
193d f1				pop af 
193e cd 2b 0d				call str_at_display 
1941 c9				ret 
1942			 
1942			display_ptr_state: 
1942			 
1942				; to restore afterwards 
1942			 
1942 d5				push de 
1943 c5				push bc 
1944 e5				push hl 
1945 f5				push af 
1946			 
1946				; for use in here 
1946			 
1946			;	push bc 
1946			;	push de 
1946			;	push hl 
1946			;	push af 
1946			 
1946 cd 18 0d			call clear_display 
1949			 
1949 11 1c 1b			ld de, .ptrstate 
194c 3e 00			ld a, display_row_1 
194e cd 2b 0d			call str_at_display 
1951			 
1951				; display debug step 
1951			 
1951			 
1951 11 6e fe			ld de, debug_mark 
1954 3e 26			ld a, display_row_1+display_cols-2 
1956 cd 2b 0d			call str_at_display 
1959			 
1959				; display a 
1959 11 26 1b			ld de, .ptrcliptr 
195c 3e 28			ld a, display_row_2 
195e cd 2b 0d			call str_at_display 
1961			 
1961 f1				pop af 
1962 2a 47 fa			ld hl,(cli_ptr) 
1965 3e 30			ld a, display_row_2+8 
1967 cd 23 19			call display_word_at 
196a			 
196a			 
196a				; display hl 
196a			 
196a			 
196a 11 2e 1b			ld de, .ptrclioptr 
196d 3e 32			ld a, display_row_2+10 
196f cd 2b 0d			call str_at_display 
1972			; 
1972			;	pop hl 
1972 3e 35			ld a, display_row_2+13 
1974 2a 45 fa			ld hl,(cli_origptr) 
1977 cd 23 19			call display_word_at 
197a			; 
197a			;	 
197a			;	; display de 
197a			 
197a			;	ld de, .regstatede 
197a			;	ld a, display_row_3 
197a			;	call str_at_display 
197a			 
197a			;	pop de 
197a			;	ld h,d 
197a			;	ld l, e 
197a			;	ld a, display_row_3+3 
197a			;	call display_word_at 
197a			 
197a			 
197a				; display bc 
197a			 
197a			;	ld de, .regstatebc 
197a			;	ld a, display_row_3+10 
197a			;	call str_at_display 
197a			 
197a			;	pop bc 
197a			;	ld h,b 
197a			;	ld l, c 
197a			;	ld a, display_row_3+13 
197a			;	call display_word_at 
197a			 
197a			 
197a				; display dsp 
197a			 
197a			;	ld de, .regstatedsp 
197a			;	ld a, display_row_4 
197a			;	call str_at_display 
197a			 
197a				 
197a			;	ld hl,(cli_data_sp) 
197a			;	ld a, display_row_4+4 
197a			;	call display_word_at 
197a			 
197a				; display rsp 
197a			 
197a 11 5d 1b			ld de, .regstatersp 
197d 3e 82			ld a, display_row_4+10 
197f cd 2b 0d			call str_at_display 
1982			 
1982				 
1982 2a f9 f9			ld hl,(cli_ret_sp) 
1985 3e 86			ld a, display_row_4+14 
1987 cd 23 19			call display_word_at 
198a			 
198a cd 3b 0d			call update_display 
198d			 
198d cd 95 0c			call delay1s 
1990 cd 95 0c			call delay1s 
1993 cd 95 0c			call delay1s 
1996			 
1996			 
1996 cd e1 1f			call next_page_prompt 
1999			 
1999				; restore  
1999			 
1999 f1				pop af 
199a e1				pop hl 
199b c1				pop bc 
199c d1				pop de 
199d c9				ret 
199e			 
199e			break_point_state: 
199e f5				push af 
199f			 
199f				; see if disabled 
199f			 
199f 3a b9 f1			ld a, (os_view_disable) 
19a2 fe 2a			cp '*' 
19a4 20 02			jr nz, .bpsgo 
19a6 f1				pop af 
19a7 c9				ret 
19a8			 
19a8			.bpsgo: 
19a8 f1				pop af 
19a9 f5				push af 
19aa 22 b5 f1			ld (os_view_hl), hl 
19ad ed 53 b3 f1		ld (os_view_de), de 
19b1 ed 43 b1 f1		ld (os_view_bc), bc 
19b5 e5				push hl 
19b6 6f				ld l, a 
19b7 26 00			ld h, 0 
19b9 22 b7 f1			ld (os_view_af),hl 
19bc			 
19bc 21 b4 fd				ld hl, display_fb0 
19bf 22 cf fb				ld (display_fb_active), hl 
19c2 e1				pop hl	 
19c3			 
19c3 3e 31			ld a, '1' 
19c5 fe 2a		.bps1:  cp '*' 
19c7 20 03			jr nz, .bps1b 
19c9 32 b9 f1			ld (os_view_disable),a 
19cc fe 31		.bps1b:  cp '1' 
19ce 20 14			jr nz, .bps2 
19d0			 
19d0				; display reg 
19d0			 
19d0				 
19d0			 
19d0 3a b7 f1			ld a, (os_view_af) 
19d3 2a b5 f1			ld hl, (os_view_hl) 
19d6 ed 5b b3 f1		ld de, (os_view_de) 
19da ed 4b b1 f1		ld bc, (os_view_bc) 
19de cd 78 1a			call display_reg_state 
19e1 c3 64 1a			jp .bpschk 
19e4			 
19e4 fe 32		.bps2:  cp '2' 
19e6 20 08			jr nz, .bps3 
19e8				 
19e8				; display hl 
19e8 2a b5 f1			ld hl, (os_view_hl) 
19eb cd 62 1b			call display_dump_at_hl 
19ee			 
19ee 18 74			jr .bpschk 
19f0			 
19f0 fe 33		.bps3:  cp '3' 
19f2 20 08			jr nz, .bps4 
19f4			 
19f4			        ; display de 
19f4 2a b3 f1			ld hl, (os_view_de) 
19f7 cd 62 1b			call display_dump_at_hl 
19fa			 
19fa 18 68			jr .bpschk 
19fc fe 34		.bps4:  cp '4' 
19fe 20 08			jr nz, .bps5 
1a00			 
1a00			        ; display bc 
1a00 2a b1 f1			ld hl, (os_view_bc) 
1a03 cd 62 1b			call display_dump_at_hl 
1a06			 
1a06 18 5c			jr .bpschk 
1a08 fe 35		.bps5:  cp '5' 
1a0a 20 08		        jr nz, .bps7 
1a0c			 
1a0c				; display cur ptr 
1a0c 2a 47 fa			ld hl, (cli_ptr) 
1a0f cd 62 1b			call display_dump_at_hl 
1a12			 
1a12 18 50			jr .bpschk 
1a14 fe 36		.bps7:  cp '6' 
1a16 20 08			jr nz, .bps8b 
1a18				 
1a18				; display cur orig ptr 
1a18 2a 45 fa			ld hl, (cli_origptr) 
1a1b cd 62 1b			call display_dump_at_hl 
1a1e 18 44			jr .bpschk 
1a20 fe 37		.bps8b:  cp '7' 
1a22 20 08			jr nz, .bps9 
1a24				 
1a24				; display dsp 
1a24 2a f5 f9			ld hl, (cli_data_sp) 
1a27 cd 62 1b			call display_dump_at_hl 
1a2a			 
1a2a 18 38			jr .bpschk 
1a2c fe 39		.bps9:  cp '9' 
1a2e 20 05			jr nz, .bps8c 
1a30				 
1a30				; display SP 
1a30			;	ld hl, sp 
1a30 cd 62 1b			call display_dump_at_hl 
1a33			 
1a33 18 2f			jr .bpschk 
1a35 fe 38		.bps8c:  cp '8' 
1a37 20 08			jr nz, .bps8d 
1a39				 
1a39				; display rsp 
1a39 2a f9 f9			ld hl, (cli_ret_sp) 
1a3c cd 62 1b			call display_dump_at_hl 
1a3f			 
1a3f 18 23			jr .bpschk 
1a41 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1a43 20 05			jr nz, .bps8 
1a45 cd d7 1d			call monitor 
1a48			 
1a48 18 1a			jr .bpschk 
1a4a fe 30		.bps8:  cp '0' 
1a4c 20 16			jr nz, .bpschk 
1a4e			 
1a4e 21 13 fd				ld hl, display_fb1 
1a51 22 cf fb				ld (display_fb_active), hl 
1a54 cd 3b 0d				call update_display 
1a57			 
1a57				;ld a, (os_view_af) 
1a57 2a b5 f1			ld hl, (os_view_hl) 
1a5a ed 5b b3 f1		ld de, (os_view_de) 
1a5e ed 4b b1 f1		ld bc, (os_view_bc) 
1a62 f1				pop af 
1a63 c9				ret 
1a64			 
1a64			.bpschk:   
1a64 cd 95 0c			call delay1s 
1a67 3e 9f		ld a,display_row_4 + display_cols - 1 
1a69 11 df 1f		        ld de, endprg 
1a6c cd 2b 0d			call str_at_display 
1a6f cd 3b 0d			call update_display 
1a72 cd 9d 77			call cin_wait 
1a75			 
1a75 c3 c5 19			jp .bps1 
1a78			 
1a78			 
1a78			display_reg_state: 
1a78			 
1a78				; to restore afterwards 
1a78			 
1a78 d5				push de 
1a79 c5				push bc 
1a7a e5				push hl 
1a7b f5				push af 
1a7c			 
1a7c				; for use in here 
1a7c			 
1a7c c5				push bc 
1a7d d5				push de 
1a7e e5				push hl 
1a7f f5				push af 
1a80			 
1a80 cd 18 0d			call clear_display 
1a83			 
1a83 11 38 1b			ld de, .regstate 
1a86 3e 00			ld a, display_row_1 
1a88 cd 2b 0d			call str_at_display 
1a8b			 
1a8b				; display debug step 
1a8b			 
1a8b			 
1a8b 11 6e fe			ld de, debug_mark 
1a8e 3e 25			ld a, display_row_1+display_cols-3 
1a90 cd 2b 0d			call str_at_display 
1a93			 
1a93				; display a 
1a93 11 54 1b			ld de, .regstatea 
1a96 3e 28			ld a, display_row_2 
1a98 cd 2b 0d			call str_at_display 
1a9b			 
1a9b e1				pop hl 
1a9c			;	ld h,0 
1a9c			;	ld l, a 
1a9c 3e 2b			ld a, display_row_2+3 
1a9e cd 23 19			call display_word_at 
1aa1			 
1aa1			 
1aa1				; display hl 
1aa1			 
1aa1			 
1aa1 11 48 1b			ld de, .regstatehl 
1aa4 3e 32			ld a, display_row_2+10 
1aa6 cd 2b 0d			call str_at_display 
1aa9			 
1aa9 e1				pop hl 
1aaa 3e 35			ld a, display_row_2+13 
1aac cd 23 19			call display_word_at 
1aaf			 
1aaf				 
1aaf				; display de 
1aaf			 
1aaf 11 4c 1b			ld de, .regstatede 
1ab2 3e 50			ld a, display_row_3 
1ab4 cd 2b 0d			call str_at_display 
1ab7			 
1ab7 e1				pop hl 
1ab8			;	ld h,d 
1ab8			;	ld l, e 
1ab8 3e 53			ld a, display_row_3+3 
1aba cd 23 19			call display_word_at 
1abd			 
1abd			 
1abd				; display bc 
1abd			 
1abd 11 50 1b			ld de, .regstatebc 
1ac0 3e 5a			ld a, display_row_3+10 
1ac2 cd 2b 0d			call str_at_display 
1ac5			 
1ac5 e1				pop hl 
1ac6			;	ld h,b 
1ac6			;	ld l, c 
1ac6 3e 5d			ld a, display_row_3+13 
1ac8 cd 23 19			call display_word_at 
1acb			 
1acb			 
1acb				; display dsp 
1acb			 
1acb 11 58 1b			ld de, .regstatedsp 
1ace 3e 78			ld a, display_row_4 
1ad0 cd 2b 0d			call str_at_display 
1ad3			 
1ad3				 
1ad3 2a f5 f9			ld hl,(cli_data_sp) 
1ad6 3e 7c			ld a, display_row_4+4 
1ad8 cd 23 19			call display_word_at 
1adb			 
1adb				; display rsp 
1adb			 
1adb 11 5d 1b			ld de, .regstatersp 
1ade 3e 82			ld a, display_row_4+10 
1ae0 cd 2b 0d			call str_at_display 
1ae3			 
1ae3				 
1ae3 2a f9 f9			ld hl,(cli_ret_sp) 
1ae6 3e 86			ld a, display_row_4+14 
1ae8 cd 23 19			call display_word_at 
1aeb			 
1aeb cd 3b 0d			call update_display 
1aee			 
1aee			;	call delay1s 
1aee			;	call delay1s 
1aee			;	call delay1s 
1aee			 
1aee			 
1aee			;	call next_page_prompt 
1aee			 
1aee				; restore  
1aee			 
1aee f1				pop af 
1aef e1				pop hl 
1af0 c1				pop bc 
1af1 d1				pop de 
1af2 c9				ret 
1af3			 
1af3 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1b07 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1b1c .. 00		.ptrstate:	db "Ptr State",0 
1b26 .. 00		.ptrcliptr:     db "cli_ptr",0 
1b2e .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1b38 .. 00		.regstate:	db "Reg State (1/0)",0 
1b48 .. 00		.regstatehl:	db "HL:",0 
1b4c .. 00		.regstatede:	db "DE:",0 
1b50 .. 00		.regstatebc:	db "BC:",0 
1b54 .. 00		.regstatea:	db "A :",0 
1b58 .. 00		.regstatedsp:	db "DSP:",0 
1b5d .. 00		.regstatersp:	db "RSP:",0 
1b62			 
1b62			display_dump_at_hl: 
1b62 e5				push hl 
1b63 d5				push de 
1b64 c5				push bc 
1b65 f5				push af 
1b66			 
1b66 22 eb f4			ld (os_cur_ptr),hl	 
1b69 cd 18 0d			call clear_display 
1b6c cd e9 1e			call dumpcont 
1b6f			;	call delay1s 
1b6f			;	call next_page_prompt 
1b6f			 
1b6f			 
1b6f f1				pop af 
1b70 c1				pop bc 
1b71 d1				pop de 
1b72 e1				pop hl 
1b73 c9				ret 
1b74			 
1b74			;if ENABLE_BASIC 
1b74			;	include "nascombasic.asm" 
1b74			;	basic: 
1b74			;	include "forth/FORTH.ASM" 
1b74			;endif 
1b74			 
1b74			; eof 
1b74			 
1b74			 
# End of file firmware_diags.asm
1b74			  
1b74			include "firmware_prompts.asm"  
1b74			; Prompts  
1b74			 
1b74			; boot messages 
1b74			 
1b74 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1b89 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b99			 
1b99			 
1b99			; config menus 
1b99			 
1b99 .. 00		prom_c3: db "Add Dictionary To File",0 
1bb0			if STARTUP_V1 
1bb0			prom_c2: db "Select Autoload File",0 
1bb0			prom_c2a: db "Disable Autoload File", 0 
1bb0			endif 
1bb0			if STARTUP_V2 
1bb0 .. 00		prom_c2: db "Enable Autoload Files",0 
1bc6 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1bdd			 
1bdd .. 00		crs_s1: db "*ls-word", 0 
1be6 .. 00		crs_s2: db "*ed-word", 0 
1bef .. 00		crs_s3: db "*Demo-Programs", 0 
1bfe .. 00		crs_s4: db "*Utils", 0 
1c05 .. 00		crs_s5: db "*SPI-Addons", 0 
1c11 .. 00		crs_s6: db "*Key-constants", 0 
1c20			 
1c20			 
1c20			 
1c20			endif 
1c20 .. 00		prom_c2b: db "Select Storage Bank",0 
1c34 .. 00		prom_c4: db "Settings",0 
1c3d .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1c58 .. 00		prom_m4b:   db "Monitor",0 
1c60 .. 00		prom_c1: db "Hardware Diags",0 
1c6f			 
1c6f			 
1c6f			if STARTUP_V2 
1c6f .. 00		prom_c9: db "Create Startup Files",0 
1c84			endif 
1c84			 
1c84 .. 00		prom_notav:    db "Feature not available",0 
1c9a .. 00		prom_empty:    db "",0 
1c9b			 
1c9b			; eof 
1c9b			 
# End of file firmware_prompts.asm
1c9b			  
1c9b			  
1c9b			; eof  
1c9b			  
# End of file firmware.asm
1c9b			 
1c9b			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c9b			;if BASE_KEV  
1c9b			;baseram: equ 08000h 
1c9b			;endif 
1c9b			 
1c9b			;if BASE_SC114 
1c9b			;baseram:     equ    endofcode 
1c9b			;endif 
1c9b			 
1c9b			 
1c9b			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c9b			 
1c9b			; start system 
1c9b			 
1c9b			coldstart: 
1c9b				; set sp 
1c9b				; di/ei 
1c9b			 
1c9b f3				di 
1c9c 31 fd ff			ld sp, tos 
1c9f			;	ei 
1c9f			 
1c9f			 
1c9f				; disable breakpoint by default 
1c9f			 
1c9f 3e 2a			ld a,'*' 
1ca1 32 b9 f1			ld (os_view_disable),a 
1ca4			 
1ca4				; init hardware 
1ca4			 
1ca4				; init keyboard and screen hardware 
1ca4			 
1ca4 cd 1c 00			call hardware_init 
1ca7			 
1ca7			 
1ca7 cd 95 0c			call delay1s 
1caa 3e 58			ld a, display_row_3+8 
1cac 11 03 00			ld de, buildtime 
1caf cd 2b 0d			call str_at_display 
1cb2 cd 3b 0d			call update_display 
1cb5			 
1cb5 cd 95 0c			call delay1s 
1cb8 cd 95 0c			call delay1s 
1cbb cd 95 0c			call delay1s 
1cbe			 
1cbe				; detect if any keys are held down to enable breakpoints at start up 
1cbe			 
1cbe cd ae 77			call cin  
1cc1 fe 00			cp 0 
1cc3 28 03			jr z, .nokeys 
1cc5			 
1cc5				;call hardware_diags 
1cc5 cd d6 15			call config 
1cc8			 
1cc8			;	ld de, .bpen 
1cc8			;	ld a, display_row_4 
1cc8			;	call str_at_display 
1cc8			;	call update_display 
1cc8			; 
1cc8			;	ld a,0 
1cc8			;	ld (os_view_disable),a 
1cc8			; 
1cc8			;.bpwait: 
1cc8			;	call cin 
1cc8			;	cp 0 
1cc8			;	jr z, .bpwait 
1cc8			;	jr .nokeys 
1cc8			; 
1cc8			; 
1cc8			;.bpen:  db "Break points enabled!",0 
1cc8			 
1cc8			 
1cc8			 
1cc8			 
1cc8			 
1cc8			 
1cc8			.nokeys: 
1cc8			 
1cc8			 
1cc8				 
1cc8			 
1cc8			;jp  testkey 
1cc8			 
1cc8			;call storage_get_block_0 
1cc8			; 
1cc8			;ld hl, 0 
1cc8			;ld de, store_page 
1cc8			;call storage_read_block 
1cc8			 
1cc8				 
1cc8			;ld hl, 10 
1cc8			;ld de, store_page 
1cc8			;call storage_read_block 
1cc8			 
1cc8			 
1cc8			 
1cc8			 
1cc8			 
1cc8			;stop:	nop 
1cc8			;	jp stop 
1cc8			 
1cc8			 
1cc8			 
1cc8			main: 
1cc8 cd 18 0d			call clear_display 
1ccb cd 3b 0d			call update_display 
1cce			 
1cce			 
1cce			 
1cce			;	call testlcd 
1cce			 
1cce			 
1cce			 
1cce cd e6 23			call forth_init 
1cd1			 
1cd1			 
1cd1			warmstart: 
1cd1 cd bc 23			call forth_warmstart 
1cd4			 
1cd4				; run startup word load 
1cd4			        ; TODO prevent this running at warmstart after crash  
1cd4			 
1cd4				if STARTUP_ENABLE 
1cd4			 
1cd4					if STARTUP_V1 
1cd4			 
1cd4						if STORAGE_SE 
1cd4							call forth_autoload 
1cd4						endif 
1cd4						call forth_startup 
1cd4					endif 
1cd4			 
1cd4					if STARTUP_V2 
1cd4			 
1cd4						if STORAGE_SE 
1cd4 cd c0 72						call forth_autoload 
1cd7						else 
1cd7							call forth_startup 
1cd7						endif 
1cd7			 
1cd7			 
1cd7					endif 
1cd7			 
1cd7				endif 
1cd7			 
1cd7				; show free memory after boot 
1cd7 11 71 1d			ld de, freeram 
1cda 3e 00			ld a, display_row_1 
1cdc cd 2b 0d			call str_at_display 
1cdf			 
1cdf			; Or use heap_size word???? 
1cdf 21 ae f1			ld hl, heap_end 
1ce2 11 0e 80			ld de, heap_start 
1ce5 ed 52			sbc hl, de 
1ce7 e5				push hl 
1ce8 7c				ld a,h	         	 
1ce9 21 cd f4			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1cec cd 4d 12			call hexout 
1cef e1			   	pop hl 
1cf0			 
1cf0 7d				ld a,l 
1cf1 21 cf f4			ld hl, os_word_scratch+2 
1cf4 cd 4d 12			call hexout 
1cf7 21 d1 f4			ld hl, os_word_scratch+4 
1cfa 3e 00			ld a, 0 
1cfc 77				ld (hl),a 
1cfd 11 cd f4			ld de, os_word_scratch 
1d00 3e 0d			ld a, display_row_1 + 13 
1d02 cd 2b 0d			call str_at_display 
1d05 cd 3b 0d			call update_display 
1d08			 
1d08			 
1d08				;call demo 
1d08			 
1d08			 
1d08				; init scratch input area for cli commands 
1d08			 
1d08 21 ef f4			ld hl, os_cli_cmd 
1d0b 3e 00			ld a,0 
1d0d 77				ld (hl),a 
1d0e 23				inc hl 
1d0f 77				ld (hl),a 
1d10			 
1d10 3e 00			ld a,0 
1d12 32 ee f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d15			 
1d15 32 eb f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d18 32 ec f4			ld (os_cur_ptr+1),a	 
1d1b			 
1d1b 32 cd f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1d1e 32 ce f4			ld (os_word_scratch+1),a	 
1d21				 
1d21			 
1d21				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d21 21 ef f4			ld hl, os_cli_cmd 
1d24			 
1d24 3e 00			ld a, 0		 ; init cli input 
1d26 77				ld (hl), a 
1d27 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d29			cli: 
1d29				; show cli prompt 
1d29				;push af 
1d29				;ld a, 0 
1d29				;ld de, prompt 
1d29				;call str_at_display 
1d29			 
1d29				;call update_display 
1d29				;pop af 
1d29				;inc a 
1d29				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d29 0e 00			ld c, 0 
1d2b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1d2d 1e 28			ld e, 40 
1d2f			 
1d2f 21 ef f4			ld hl, os_cli_cmd 
1d32			 
1d32				STACKFRAME OFF $fefe $9f9f 
1d32				if DEBUG_STACK_IMB 
1d32					if OFF 
1d32						exx 
1d32						ld de, $fefe 
1d32						ld a, d 
1d32						ld hl, curframe 
1d32						call hexout 
1d32						ld a, e 
1d32						ld hl, curframe+2 
1d32						call hexout 
1d32						ld hl, $fefe 
1d32						push hl 
1d32						ld hl, $9f9f 
1d32						push hl 
1d32						exx 
1d32					endif 
1d32				endif 
1d32			endm 
# End of macro STACKFRAME
1d32			 
1d32 cd 79 0f			call input_str 
1d35			 
1d35				STACKFRAMECHK OFF $fefe $9f9f 
1d35				if DEBUG_STACK_IMB 
1d35					if OFF 
1d35						exx 
1d35						ld hl, $9f9f 
1d35						pop de   ; $9f9f 
1d35						call cmp16 
1d35						jr nz, .spnosame 
1d35						ld hl, $fefe 
1d35						pop de   ; $fefe 
1d35						call cmp16 
1d35						jr z, .spfrsame 
1d35						.spnosame: call showsperror 
1d35						.spfrsame: nop 
1d35						exx 
1d35					endif 
1d35				endif 
1d35			endm 
# End of macro STACKFRAMECHK
1d35			 
1d35				; copy input to last command 
1d35			 
1d35 21 ef f4			ld hl, os_cli_cmd 
1d38 11 ee f5			ld de, os_last_cmd 
1d3b 01 ff 00			ld bc, 255 
1d3e ed b0			ldir 
1d40			 
1d40				; wipe current buffer 
1d40			 
1d40			;	ld a, 0 
1d40			;	ld hl, os_cli_cmd 
1d40			;	ld de, os_cli_cmd+1 
1d40			;	ld bc, 254 
1d40			;	ldir 
1d40				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1d40			;	call strcpy 
1d40			;	ld a, 0 
1d40			;	ld (hl), a 
1d40			;	inc hl 
1d40			;	ld (hl), a 
1d40			;	inc hl 
1d40			;	ld (hl), a 
1d40			 
1d40				; switch frame buffer to program  
1d40			 
1d40 21 13 fd				ld hl, display_fb1 
1d43 22 cf fb				ld (display_fb_active), hl 
1d46			 
1d46			;	nop 
1d46				STACKFRAME ON $fbfe $8f9f 
1d46				if DEBUG_STACK_IMB 
1d46					if ON 
1d46						exx 
1d46						ld de, $fbfe 
1d46						ld a, d 
1d46						ld hl, curframe 
1d46						call hexout 
1d46						ld a, e 
1d46						ld hl, curframe+2 
1d46						call hexout 
1d46						ld hl, $fbfe 
1d46						push hl 
1d46						ld hl, $8f9f 
1d46						push hl 
1d46						exx 
1d46					endif 
1d46				endif 
1d46			endm 
# End of macro STACKFRAME
1d46				; first time into the parser so pass over the current scratch pad 
1d46 21 ef f4			ld hl,os_cli_cmd 
1d49				; tokenise the entered statement(s) in HL 
1d49 cd 64 24			call forthparse 
1d4c			        ; exec forth statements in top of return stack 
1d4c cd a4 24			call forthexec 
1d4f				;call forthexec_cleanup 
1d4f			;	call parsenext 
1d4f			 
1d4f				STACKFRAMECHK ON $fbfe $8f9f 
1d4f				if DEBUG_STACK_IMB 
1d4f					if ON 
1d4f						exx 
1d4f						ld hl, $8f9f 
1d4f						pop de   ; $8f9f 
1d4f						call cmp16 
1d4f						jr nz, .spnosame 
1d4f						ld hl, $fbfe 
1d4f						pop de   ; $fbfe 
1d4f						call cmp16 
1d4f						jr z, .spfrsame 
1d4f						.spnosame: call showsperror 
1d4f						.spfrsame: nop 
1d4f						exx 
1d4f					endif 
1d4f				endif 
1d4f			endm 
# End of macro STACKFRAMECHK
1d4f				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1d4f			 
1d4f 3e 78			ld a, display_row_4 
1d51 11 83 1d			ld de, endprog 
1d54			 
1d54 cd 3b 0d			call update_display		 
1d57			 
1d57 cd e1 1f			call next_page_prompt 
1d5a			 
1d5a				; switch frame buffer to cli 
1d5a			 
1d5a 21 b4 fd				ld hl, display_fb0 
1d5d 22 cf fb				ld (display_fb_active), hl 
1d60			 
1d60			 
1d60 cd 18 0d		        call clear_display 
1d63 cd 3b 0d			call update_display		 
1d66			 
1d66 21 ef f4			ld hl, os_cli_cmd 
1d69			 
1d69 3e 00			ld a, 0		 ; init cli input 
1d6b 77				ld (hl), a 
1d6c			 
1d6c				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d6c			 
1d6c				; now on last line 
1d6c			 
1d6c				; TODO scroll screen up 
1d6c			 
1d6c				; TODO instead just clear screen and place at top of screen 
1d6c			 
1d6c			;	ld a, 0 
1d6c			;	ld (f_cursor_ptr),a 
1d6c			 
1d6c				;call clear_display 
1d6c				;call update_display 
1d6c			 
1d6c				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d6c 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d6e c3 29 1d			jp cli 
1d71			 
1d71 .. 00		freeram: db "Free bytes: $",0 
1d7f ..			asc: db "1A2F" 
1d83 .. 00		endprog: db "End prog...",0 
1d8f			 
1d8f			testenter2:   
1d8f 21 fa f1			ld hl,scratch+50 
1d92 22 eb f4			ld (os_cur_ptr),hl 
1d95 c3 29 1d			jp cli 
1d98			 
1d98			testenter:  
1d98			 
1d98 21 7f 1d			ld hl,asc 
1d9b			;	ld a,(hl) 
1d9b			;	call nibble2val 
1d9b cd a3 12			call get_byte 
1d9e			 
1d9e			 
1d9e			;	ld a,(hl) 
1d9e			;	call atohex 
1d9e			 
1d9e			;	call fourehexhl 
1d9e 32 fa f1			ld (scratch+50),a 
1da1			 
1da1			 
1da1			 
1da1 21 81 1d			ld hl,asc+2 
1da4			;	ld a, (hl) 
1da4			;	call nibble2val 
1da4 cd a3 12			call get_byte 
1da7			 
1da7			;	call fourehexhl 
1da7 32 fc f1			ld (scratch+52),a 
1daa				 
1daa 21 fa f1			ld hl,scratch+50 
1dad 22 eb f4			ld (os_cur_ptr),hl 
1db0 c3 29 1d			jp cli 
1db3			 
1db3			enter:	 
1db3 3a cc f1			ld a,(scratch+4) 
1db6 fe 00			cp 0 
1db8 28 0c			jr z, .entercont 
1dba				; no, not a null term line so has an address to work out.... 
1dba			 
1dba 21 ca f1			ld hl,scratch+2 
1dbd cd 03 13			call get_word_hl 
1dc0			 
1dc0 22 eb f4			ld (os_cur_ptr),hl	 
1dc3 c3 29 1d			jp cli 
1dc6			 
1dc6			 
1dc6			.entercont:  
1dc6			 
1dc6 21 ca f1			ld hl, scratch+2 
1dc9 cd a3 12			call get_byte 
1dcc			 
1dcc 2a eb f4		   	ld hl,(os_cur_ptr) 
1dcf 77					ld (hl),a 
1dd0 23					inc hl 
1dd1 22 eb f4				ld (os_cur_ptr),hl 
1dd4				 
1dd4			; get byte  
1dd4			 
1dd4			 
1dd4 c3 29 1d			jp cli 
1dd7			 
1dd7			 
1dd7			; basic monitor support 
1dd7			 
1dd7			monitor: 
1dd7				;  
1dd7 cd 18 0d			call clear_display 
1dda 3e 00			ld a, 0 
1ddc 11 24 1e			ld de, .monprompt 
1ddf cd 2b 0d			call str_at_display 
1de2 cd 3b 0d			call update_display 
1de5			 
1de5				; get a monitor command 
1de5			 
1de5 0e 00			ld c, 0     ; entry at top left 
1de7 16 64			ld d, 100   ; max buffer size 
1de9 1e 0f			ld e, 15    ; input scroll area 
1deb 3e 00			ld a, 0     ; init string 
1ded 21 c6 f3			ld hl, os_input 
1df0 77				ld (hl), a 
1df1 23				inc hl 
1df2 77				ld (hl), a 
1df3 21 c6 f3			ld hl, os_input 
1df6 3e 01			ld a, 1     ; init string 
1df8 cd 79 0f			call input_str 
1dfb			 
1dfb cd 18 0d		        call clear_display 
1dfe cd 3b 0d			call update_display		 
1e01			 
1e01 3a c6 f3			ld a, (os_input) 
1e04 cd a1 13			call toUpper 
1e07 fe 48		        cp 'H' 
1e09 28 6f		        jr z, .monhelp 
1e0b fe 44			cp 'D'		; dump 
1e0d ca 9b 1e			jp z, .mondump	 
1e10 fe 43			cp 'C'		; dump 
1e12 ca b5 1e			jp z, .moncdump	 
1e15 fe 4d			cp 'M'		; dump 
1e17 ca 26 1e			jp z, .moneditstart 
1e1a fe 55			cp 'U'		; dump 
1e1c 28 14			jr z, .monedit	 
1e1e fe 51			cp 'Q'		; dump 
1e20 c8				ret z	 
1e21			 
1e21			 
1e21				; TODO "S" to access symbol by name and not need the address 
1e21				; TODO "F" to find a string in memory 
1e21			 
1e21 c3 d7 1d			jp monitor 
1e24			 
1e24 .. 00		.monprompt: db ">", 0 
1e26			 
1e26			.moneditstart: 
1e26				; get starting address 
1e26			 
1e26 21 c8 f3			ld hl,os_input+2 
1e29 cd 03 13			call get_word_hl 
1e2c			 
1e2c 22 eb f4			ld (os_cur_ptr),hl	 
1e2f			 
1e2f c3 d7 1d			jp monitor 
1e32			 
1e32			.monedit: 
1e32				; get byte to load 
1e32			 
1e32 21 c8 f3			ld hl,os_input+2 
1e35 cd a3 12			call get_byte 
1e38			 
1e38				; get address to update 
1e38 2a eb f4			ld hl, (os_cur_ptr) 
1e3b			 
1e3b				; update byte 
1e3b			 
1e3b 77				ld (hl), a 
1e3c			 
1e3c				; move to next address and save it 
1e3c			 
1e3c 23				inc hl 
1e3d 22 eb f4			ld (os_cur_ptr),hl	 
1e40			 
1e40 c3 d7 1d			jp monitor 
1e43			 
1e43			 
1e43 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1e57 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e73 .. 00		.monhelptext3:  db "Q-Quit",0 
1e7a			        
1e7a			.monhelp: 
1e7a 3e 00			ld a, display_row_1 
1e7c 11 43 1e		        ld de, .monhelptext1 
1e7f			 
1e7f cd 2b 0d			call str_at_display 
1e82 3e 28			ld a, display_row_2 
1e84 11 57 1e		        ld de, .monhelptext2 
1e87					 
1e87 cd 2b 0d			call str_at_display 
1e8a 3e 50			ld a, display_row_3 
1e8c 11 73 1e		        ld de, .monhelptext3 
1e8f					 
1e8f cd 2b 0d			call str_at_display 
1e92 cd 3b 0d			call update_display		 
1e95			 
1e95 cd e1 1f			call next_page_prompt 
1e98 c3 d7 1d			jp monitor 
1e9b			 
1e9b			.mondump:    
1e9b 21 c8 f3			ld hl,os_input+2 
1e9e cd 03 13			call get_word_hl 
1ea1			 
1ea1 22 eb f4			ld (os_cur_ptr),hl	 
1ea4 cd e9 1e			call dumpcont 
1ea7 3e 78			ld a, display_row_4 
1ea9 11 83 1d			ld de, endprog 
1eac			 
1eac cd 3b 0d			call update_display		 
1eaf			 
1eaf cd e1 1f			call next_page_prompt 
1eb2 c3 d7 1d			jp monitor 
1eb5			.moncdump: 
1eb5 cd e9 1e			call dumpcont 
1eb8 3e 78			ld a, display_row_4 
1eba 11 83 1d			ld de, endprog 
1ebd			 
1ebd cd 3b 0d			call update_display		 
1ec0			 
1ec0 cd e1 1f			call next_page_prompt 
1ec3 c3 d7 1d			jp monitor 
1ec6			 
1ec6			 
1ec6			; TODO symbol access  
1ec6			 
1ec6			.symbols:     ;; A list of symbols that can be called up  
1ec6 b4 fd			dw display_fb0 
1ec8 .. 00			db "fb0",0  
1ecc 81 fa		     	dw store_page 
1ece .. 00			db "store_page",0 
1ed9			 
1ed9			 
1ed9			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ed9			 
1ed9 3a c9 f1			ld a,(scratch+1) 
1edc fe 00			cp 0 
1ede 28 09			jr z, dumpcont 
1ee0			 
1ee0				; no, not a null term line so has an address to work out.... 
1ee0			 
1ee0 21 ca f1			ld hl,scratch+2 
1ee3 cd 03 13			call get_word_hl 
1ee6			 
1ee6 22 eb f4			ld (os_cur_ptr),hl	 
1ee9			 
1ee9			 
1ee9			 
1ee9			dumpcont: 
1ee9			 
1ee9				; dump bytes at ptr 
1ee9			 
1ee9			 
1ee9 3e 00			ld a, display_row_1 
1eeb 2a cf fb			ld hl, (display_fb_active) 
1eee cd 4c 0f			call addatohl 
1ef1 cd 19 1f			call .dumpbyterow 
1ef4			 
1ef4 3e 28			ld a, display_row_2 
1ef6 2a cf fb			ld hl, (display_fb_active) 
1ef9 cd 4c 0f			call addatohl 
1efc cd 19 1f			call .dumpbyterow 
1eff			 
1eff			 
1eff 3e 50			ld a, display_row_3 
1f01 2a cf fb			ld hl, (display_fb_active) 
1f04 cd 4c 0f			call addatohl 
1f07 cd 19 1f			call .dumpbyterow 
1f0a			 
1f0a 3e 78			ld a, display_row_4 
1f0c 2a cf fb			ld hl, (display_fb_active) 
1f0f cd 4c 0f			call addatohl 
1f12 cd 19 1f			call .dumpbyterow 
1f15			 
1f15 cd 3b 0d			call update_display 
1f18			;		jp cli 
1f18 c9				ret 
1f19			 
1f19			.dumpbyterow: 
1f19			 
1f19				;push af 
1f19			 
1f19 e5				push hl 
1f1a			 
1f1a				; calc where to poke the ascii 
1f1a			if display_cols == 20 
1f1a				ld a, 16 
1f1a			else 
1f1a 3e 1f			ld a, 31 
1f1c			endif 
1f1c			 
1f1c cd 4c 0f			call addatohl 
1f1f 22 cd f4			ld (os_word_scratch),hl  		; save pos for later 
1f22			 
1f22			 
1f22			; display decoding address 
1f22 2a eb f4		   	ld hl,(os_cur_ptr) 
1f25			 
1f25 7c				ld a,h 
1f26 e1				pop hl 
1f27 e5				push hl 
1f28			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f28 cd 4d 12			call hexout 
1f2b 2a eb f4		   	ld hl,(os_cur_ptr) 
1f2e			 
1f2e 7d				ld a,l 
1f2f e1				pop hl 
1f30 23				inc hl 
1f31 23				inc hl 
1f32 e5				push hl 
1f33			;	ld hl, os_word_scratch+2 
1f33 cd 4d 12			call hexout 
1f36 e1				pop hl 
1f37 23				inc hl 
1f38 23				inc hl 
1f39				;ld hl, os_word_scratch+4 
1f39 3e 3a			ld a, ':' 
1f3b 77				ld (hl),a 
1f3c 23				inc hl 
1f3d				;ld a, 0 
1f3d				;ld (hl),a 
1f3d				;ld de, os_word_scratch 
1f3d				;pop af 
1f3d				;push af 
1f3d			;		ld a, display_row_2 
1f3d			;		call str_at_display 
1f3d			;		call update_display 
1f3d			 
1f3d			 
1f3d			;pop af 
1f3d			;	add 5 
1f3d			 
1f3d			if display_cols == 20 
1f3d				ld b, 4 
1f3d			else 
1f3d 06 08			ld b, 8 
1f3f			endif	 
1f3f			 
1f3f			.dumpbyte: 
1f3f c5				push bc 
1f40 e5				push hl 
1f41			 
1f41			 
1f41 2a eb f4		   	ld hl,(os_cur_ptr) 
1f44 7e					ld a,(hl) 
1f45			 
1f45					; poke the ascii to display 
1f45 2a cd f4				ld hl,(os_word_scratch) 
1f48 77					ld (hl),a 
1f49 23					inc hl 
1f4a 22 cd f4				ld (os_word_scratch),hl 
1f4d			 
1f4d					 
1f4d			 
1f4d			 
1f4d e1					pop hl 
1f4e e5					push hl 
1f4f			 
1f4f cd 4d 12				call hexout 
1f52			 
1f52					 
1f52 2a eb f4		   	ld hl,(os_cur_ptr) 
1f55 23				inc hl 
1f56 22 eb f4		   	ld (os_cur_ptr),hl 
1f59			 
1f59 e1					pop hl 
1f5a 23					inc hl 
1f5b 23					inc hl 
1f5c 23					inc hl 
1f5d			 
1f5d			 
1f5d			 
1f5d					;ld a,0 
1f5d					;ld (os_word_scratch+2),a 
1f5d					;pop af 
1f5d					;push af 
1f5d			 
1f5d					;ld de, os_word_scratch 
1f5d					;call str_at_display 
1f5d			;		call update_display 
1f5d			;		pop af 
1f5d c1					pop bc 
1f5e c6 03				add 3 
1f60 10 dd			djnz .dumpbyte 
1f62			 
1f62				 
1f62			 
1f62 c9				ret 
1f63			 
1f63			jump:	 
1f63			 
1f63 21 ca f1			ld hl,scratch+2 
1f66 cd 03 13			call get_word_hl 
1f69				;ld hl,(scratch+2) 
1f69				;call fourehexhl 
1f69			 
1f69 22 eb f4			ld (os_cur_ptr),hl	 
1f6c			 
1f6c e9				jp (hl) 
1f6d			 
1f6d			 
1f6d			 
1f6d			; TODO implement a basic monitor mode to start with 
1f6d			 
1f6d			 
1f6d			 
1f6d			 
1f6d			 
1f6d			 
1f6d			 
1f6d			 
1f6d			 
1f6d			; testing and demo code during development 
1f6d			 
1f6d			 
1f6d .. 00		str1: db "Enter some text...",0 
1f80 .. 00		clear: db "                    ",0 
1f95			 
1f95			demo: 
1f95			 
1f95			 
1f95			 
1f95			;	call update_display 
1f95			 
1f95				; init scratch input area for testing 
1f95 21 c8 f1			ld hl, scratch	 
1f98 3e 00			ld a,0 
1f9a 77				ld (hl),a 
1f9b			 
1f9b			 
1f9b 3e 28		            LD   A, display_row_2 
1f9d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f9d 11 6d 1f		            LD   DE, str1 
1fa0 cd 2b 0d			call str_at_display 
1fa3			 
1fa3			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fa3			cloop:	 
1fa3 3e 50		            LD   A, display_row_3 
1fa5			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa5 11 80 1f		            LD   DE, clear 
1fa8			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1fa8 cd 2b 0d				call str_at_display 
1fab 3e 78			ld a, display_row_4 
1fad 11 dd 1f			ld de, prompt 
1fb0			 
1fb0 cd 2b 0d				call str_at_display 
1fb3 cd 3b 0d			call update_display 
1fb6			 
1fb6 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1fb8 16 0a			ld d, 10 
1fba 21 c8 f1			ld hl, scratch	 
1fbd cd 79 0f			call input_str 
1fc0			 
1fc0			;	call clear_display 
1fc0			;'	call update_display 
1fc0			 
1fc0 3e 00		            LD   A, display_row_1 
1fc2			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fc2 11 80 1f		            LD   DE, clear 
1fc5 cd 2b 0d				call str_at_display 
1fc8			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fc8 3e 00		            LD   A, display_row_1 
1fca			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fca 11 c8 f1		            LD   DE, scratch 
1fcd			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fcd cd 2b 0d				call str_at_display 
1fd0 cd 3b 0d			call update_display 
1fd3			 
1fd3 3e 00				ld a,0 
1fd5 21 c8 f1			ld hl, scratch 
1fd8 77				ld (hl),a 
1fd9			 
1fd9 00				nop 
1fda c3 a3 1f			jp cloop 
1fdd			 
1fdd			 
1fdd			 
1fdd			; OS Prompt 
1fdd			 
1fdd .. 00		prompt: db ">",0 
1fdf .. 00		endprg: db "?",0 
1fe1			 
1fe1			 
1fe1			; handy next page prompt 
1fe1			next_page_prompt: 
1fe1 e5				push hl 
1fe2 d5				push de 
1fe3 f5				push af 
1fe4 c5				push bc 
1fe5			 
1fe5 3e 9f			ld a,display_row_4 + display_cols - 1 
1fe7 11 df 1f		        ld de, endprg 
1fea cd 2b 0d			call str_at_display 
1fed cd 3b 0d			call update_display 
1ff0 cd 9d 77			call cin_wait 
1ff3 c1				pop bc 
1ff4 f1				pop af 
1ff5 d1				pop de 
1ff6 e1				pop hl 
1ff7			 
1ff7			 
1ff7 c9				ret 
1ff8			 
1ff8			 
1ff8			; forth parser 
1ff8			 
1ff8			; My forth kernel 
1ff8			include "forth_kernel.asm" 
1ff8			; 
1ff8			; kernel to the forth OS 
1ff8			 
1ff8			DS_TYPE_STR: equ 1     ; string type 
1ff8			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ff8			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ff8			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ff8			 
1ff8			FORTH_PARSEV1: equ 0 
1ff8			FORTH_PARSEV2: equ 0 
1ff8			FORTH_PARSEV3: equ 0 
1ff8			FORTH_PARSEV4: equ 0 
1ff8			FORTH_PARSEV5: equ 1 
1ff8			 
1ff8			;if FORTH_PARSEV5 
1ff8			;	FORTH_END_BUFFER: equ 0 
1ff8			;else 
1ff8			FORTH_END_BUFFER: equ 127 
1ff8			;endif 
1ff8			 
1ff8			FORTH_TRUE: equ 1 
1ff8			FORTH_FALSE: equ 0 
1ff8			 
1ff8			if FORTH_PARSEV4 
1ff8			include "forth_stackops.asm" 
1ff8			endif 
1ff8			 
1ff8			if FORTH_PARSEV5 
1ff8			include "forth_stackopsv5.asm" 
1ff8			 
1ff8			; Stack operations for v5 parser on wards 
1ff8			; * DATA stack 
1ff8			; * LOOP stack 
1ff8			; * RETURN stack 
1ff8			 
1ff8			 
1ff8			 
1ff8			FORTH_CHK_DSP_UNDER: macro 
1ff8				push hl 
1ff8				push de 
1ff8				ld hl,(cli_data_sp) 
1ff8				ld de, cli_data_stack 
1ff8				call cmp16 
1ff8				jp c, fault_dsp_under 
1ff8				pop de 
1ff8				pop hl 
1ff8				endm 
1ff8			 
1ff8			 
1ff8			FORTH_CHK_RSP_UNDER: macro 
1ff8				push hl 
1ff8				push de 
1ff8				ld hl,(cli_ret_sp) 
1ff8				ld de, cli_ret_stack 
1ff8				call cmp16 
1ff8				jp c, fault_rsp_under 
1ff8				pop de 
1ff8				pop hl 
1ff8				endm 
1ff8			 
1ff8			FORTH_CHK_LOOP_UNDER: macro 
1ff8				push hl 
1ff8				push de 
1ff8				ld hl,(cli_loop_sp) 
1ff8				ld de, cli_loop_stack 
1ff8				call cmp16 
1ff8				jp c, fault_loop_under 
1ff8				pop de 
1ff8				pop hl 
1ff8				endm 
1ff8			 
1ff8			FORTH_ERR_TOS_NOTSTR: macro 
1ff8				; TOSO might need more for checks when used 
1ff8				push af 
1ff8				ld a,(hl) 
1ff8				cp DS_TYPE_STR 
1ff8				jp nz, type_faultn   
1ff8				pop af 
1ff8				endm 
1ff8			 
1ff8			FORTH_ERR_TOS_NOTNUM: macro 
1ff8				push af 
1ff8				ld a,(hl) 
1ff8				cp DS_TYPE_INUM 
1ff8				jp nz, type_faultn   
1ff8				pop af 
1ff8				endm 
1ff8			 
1ff8			 
1ff8			; increase data stack pointer and save hl to it 
1ff8				 
1ff8			FORTH_DSP_NEXT: macro 
1ff8				call macro_forth_dsp_next 
1ff8				endm 
1ff8			 
1ff8			 
1ff8			macro_forth_dsp_next: 
1ff8				if DEBUG_FORTH_STACK_GUARD 
1ff8 cd ab 70				call check_stacks 
1ffb				endif 
1ffb e5				push hl 
1ffc d5				push de 
1ffd eb				ex de,hl 
1ffe 2a f5 f9			ld hl,(cli_data_sp) 
2001 23				inc hl 
2002 23				inc hl 
2003			 
2003			; PARSEV5 
2003 23				inc hl 
2004 22 f5 f9			ld (cli_data_sp),hl 
2007 73				ld (hl), e 
2008 23				inc hl 
2009 72				ld (hl), d 
200a d1				pop de 
200b e1				pop hl 
200c				if DEBUG_FORTH_STACK_GUARD 
200c cd ab 70				call check_stacks 
200f				endif 
200f c9				ret 
2010			 
2010			 
2010			; increase ret stack pointer and save hl to it 
2010				 
2010			FORTH_RSP_NEXT: macro 
2010				call macro_forth_rsp_next 
2010				endm 
2010			 
2010			macro_forth_rsp_next: 
2010				if DEBUG_FORTH_STACK_GUARD 
2010 cd ab 70				call check_stacks 
2013				endif 
2013 e5				push hl 
2014 d5				push de 
2015 eb				ex de,hl 
2016 2a f9 f9			ld hl,(cli_ret_sp) 
2019 23				inc hl 
201a 23				inc hl 
201b 22 f9 f9			ld (cli_ret_sp),hl 
201e 73				ld (hl), e 
201f 23				inc hl 
2020 72				ld (hl), d 
2021 d1				pop de 
2022 e1				pop hl 
2023				if DEBUG_FORTH_STACK_GUARD 
2023 cd ab 70				call check_stacks 
2026				endif 
2026 c9				ret 
2027			 
2027			; get current ret stack pointer and save to hl  
2027				 
2027			FORTH_RSP_TOS: macro 
2027				call macro_forth_rsp_tos 
2027				endm 
2027			 
2027			macro_forth_rsp_tos: 
2027				;push de 
2027 2a f9 f9			ld hl,(cli_ret_sp) 
202a cd 62 20			call loadhlptrtohl 
202d				;ld e, (hl) 
202d				;inc hl 
202d				;ld d, (hl) 
202d				;ex de, hl 
202d					if DEBUG_FORTH_WORDS 
202d			;			DMARK "RST" 
202d						CALLMONITOR 
202d cd 9e 19			call break_point_state  
2030				endm  
# End of macro CALLMONITOR
2030					endif 
2030				;pop de 
2030 c9				ret 
2031			 
2031			; pop ret stack pointer 
2031				 
2031			FORTH_RSP_POP: macro 
2031				call macro_forth_rsp_pop 
2031				endm 
2031			 
2031			 
2031			macro_forth_rsp_pop: 
2031				if DEBUG_FORTH_STACK_GUARD 
2031			;		DMARK "RPP" 
2031 cd ab 70				call check_stacks 
2034					FORTH_CHK_RSP_UNDER 
2034 e5				push hl 
2035 d5				push de 
2036 2a f9 f9			ld hl,(cli_ret_sp) 
2039 11 b3 f9			ld de, cli_ret_stack 
203c cd 6a 0f			call cmp16 
203f da bf 71			jp c, fault_rsp_under 
2042 d1				pop de 
2043 e1				pop hl 
2044				endm 
# End of macro FORTH_CHK_RSP_UNDER
2044				endif 
2044 e5				push hl 
2045 2a f9 f9			ld hl,(cli_ret_sp) 
2048			 
2048			 
2048				if FORTH_ENABLE_FREE 
2048			 
2048					; get pointer 
2048			 
2048					push de 
2048					push hl 
2048			 
2048					ld e, (hl) 
2048					inc hl 
2048					ld d, (hl) 
2048			 
2048					ex de, hl 
2048					call free 
2048			 
2048					pop hl 
2048					pop de 
2048			 
2048			 
2048				endif 
2048			 
2048			 
2048 2b				dec hl 
2049 2b				dec hl 
204a 22 f9 f9			ld (cli_ret_sp), hl 
204d				; do stack underflow checks 
204d e1				pop hl 
204e				if DEBUG_FORTH_STACK_GUARD 
204e cd ab 70				call check_stacks 
2051					FORTH_CHK_RSP_UNDER 
2051 e5				push hl 
2052 d5				push de 
2053 2a f9 f9			ld hl,(cli_ret_sp) 
2056 11 b3 f9			ld de, cli_ret_stack 
2059 cd 6a 0f			call cmp16 
205c da bf 71			jp c, fault_rsp_under 
205f d1				pop de 
2060 e1				pop hl 
2061				endm 
# End of macro FORTH_CHK_RSP_UNDER
2061				endif 
2061 c9				ret 
2062			 
2062			 
2062			 
2062			; routine to load word pointed to by hl into hl 
2062			 
2062			loadhlptrtohl: 
2062			 
2062 d5				push de 
2063 5e				ld e, (hl) 
2064 23				inc hl 
2065 56				ld d, (hl) 
2066 eb				ex de, hl 
2067 d1				pop de 
2068			 
2068 c9				ret 
2069			 
2069			 
2069			 
2069			 
2069			 
2069			; push a number held in HL onto the data stack 
2069			; entry point for pushing a value when already in hl used in function above 
2069			 
2069			forth_push_numhl: 
2069			 
2069 e5				push hl    ; save value to push 
206a			 
206a			if DEBUG_FORTH_PUSH 
206a				; see if disabled 
206a			 
206a			 
206a f5				push af 
206b 3a b9 f1			ld a, (os_view_disable) 
206e fe 2a			cp '*' 
2070 28 34			jr z, .pskip2 
2072 e5				push hl 
2073 e5			push hl 
2074 cd 18 0d			call clear_display 
2077 e1			pop hl 
2078 7c				ld a,h 
2079 21 cd f4			ld hl, os_word_scratch 
207c cd 4d 12			call hexout 
207f e1				pop hl 
2080 7d				ld a,l 
2081 21 cf f4			ld hl, os_word_scratch+2 
2084 cd 4d 12			call hexout 
2087			 
2087 21 d1 f4			ld hl, os_word_scratch+4 
208a 3e 00			ld a,0 
208c 77				ld (hl),a 
208d 11 cd f4			ld de,os_word_scratch 
2090 3e 28				ld a, display_row_2 
2092 cd 2b 0d				call str_at_display 
2095 11 90 5c			ld de, .push_num 
2098 3e 00			ld a, display_row_1 
209a			 
209a cd 2b 0d				call str_at_display 
209d			 
209d			 
209d cd 3b 0d			call update_display 
20a0 cd 95 0c			call delay1s 
20a3 cd 95 0c			call delay1s 
20a6			.pskip2:  
20a6			 
20a6 f1				pop af 
20a7			endif	 
20a7			 
20a7			 
20a7				FORTH_DSP_NEXT 
20a7 cd f8 1f			call macro_forth_dsp_next 
20aa				endm 
# End of macro FORTH_DSP_NEXT
20aa			 
20aa 2a f5 f9			ld hl, (cli_data_sp) 
20ad			 
20ad				; save item type 
20ad 3e 02			ld a,  DS_TYPE_INUM 
20af 77				ld (hl), a 
20b0 23				inc hl 
20b1			 
20b1				; get word off stack 
20b1 d1				pop de 
20b2 7b				ld a,e 
20b3 77				ld (hl), a 
20b4 23				inc hl 
20b5 7a				ld a,d 
20b6 77				ld (hl), a 
20b7			 
20b7			if DEBUG_FORTH_PUSH 
20b7 2b				dec hl 
20b8 2b				dec hl 
20b9 2b				dec hl 
20ba						DMARK "PH5" 
20ba f5				push af  
20bb 3a cf 20			ld a, (.dmark)  
20be 32 6e fe			ld (debug_mark),a  
20c1 3a d0 20			ld a, (.dmark+1)  
20c4 32 6f fe			ld (debug_mark+1),a  
20c7 3a d1 20			ld a, (.dmark+2)  
20ca 32 70 fe			ld (debug_mark+2),a  
20cd 18 03			jr .pastdmark  
20cf ..			.dmark: db "PH5"  
20d2 f1			.pastdmark: pop af  
20d3			endm  
# End of macro DMARK
20d3				CALLMONITOR 
20d3 cd 9e 19			call break_point_state  
20d6				endm  
# End of macro CALLMONITOR
20d6			endif	 
20d6			 
20d6 c9				ret 
20d7			 
20d7			 
20d7			; Push a string to stack pointed to by hl 
20d7			 
20d7			forth_push_str: 
20d7			 
20d7			if DEBUG_FORTH_PUSH 
20d7						DMARK "PSQ" 
20d7 f5				push af  
20d8 3a ec 20			ld a, (.dmark)  
20db 32 6e fe			ld (debug_mark),a  
20de 3a ed 20			ld a, (.dmark+1)  
20e1 32 6f fe			ld (debug_mark+1),a  
20e4 3a ee 20			ld a, (.dmark+2)  
20e7 32 70 fe			ld (debug_mark+2),a  
20ea 18 03			jr .pastdmark  
20ec ..			.dmark: db "PSQ"  
20ef f1			.pastdmark: pop af  
20f0			endm  
# End of macro DMARK
20f0				CALLMONITOR 
20f0 cd 9e 19			call break_point_state  
20f3				endm  
# End of macro CALLMONITOR
20f3			endif	 
20f3			    
20f3 e5				push hl 
20f4 e5				push hl 
20f5			 
20f5			;	ld a, 0   ; find end of string 
20f5 cd aa 13			call strlenz 
20f8			if DEBUG_FORTH_PUSH 
20f8						DMARK "PQ2" 
20f8 f5				push af  
20f9 3a 0d 21			ld a, (.dmark)  
20fc 32 6e fe			ld (debug_mark),a  
20ff 3a 0e 21			ld a, (.dmark+1)  
2102 32 6f fe			ld (debug_mark+1),a  
2105 3a 0f 21			ld a, (.dmark+2)  
2108 32 70 fe			ld (debug_mark+2),a  
210b 18 03			jr .pastdmark  
210d ..			.dmark: db "PQ2"  
2110 f1			.pastdmark: pop af  
2111			endm  
# End of macro DMARK
2111				CALLMONITOR 
2111 cd 9e 19			call break_point_state  
2114				endm  
# End of macro CALLMONITOR
2114			endif	 
2114 eb				ex de, hl 
2115 e1				pop hl   ; get ptr to start of string 
2116			if DEBUG_FORTH_PUSH 
2116						DMARK "PQ3" 
2116 f5				push af  
2117 3a 2b 21			ld a, (.dmark)  
211a 32 6e fe			ld (debug_mark),a  
211d 3a 2c 21			ld a, (.dmark+1)  
2120 32 6f fe			ld (debug_mark+1),a  
2123 3a 2d 21			ld a, (.dmark+2)  
2126 32 70 fe			ld (debug_mark+2),a  
2129 18 03			jr .pastdmark  
212b ..			.dmark: db "PQ3"  
212e f1			.pastdmark: pop af  
212f			endm  
# End of macro DMARK
212f				CALLMONITOR 
212f cd 9e 19			call break_point_state  
2132				endm  
# End of macro CALLMONITOR
2132			endif	 
2132 19				add hl,de 
2133			if DEBUG_FORTH_PUSH 
2133						DMARK "PQE" 
2133 f5				push af  
2134 3a 48 21			ld a, (.dmark)  
2137 32 6e fe			ld (debug_mark),a  
213a 3a 49 21			ld a, (.dmark+1)  
213d 32 6f fe			ld (debug_mark+1),a  
2140 3a 4a 21			ld a, (.dmark+2)  
2143 32 70 fe			ld (debug_mark+2),a  
2146 18 03			jr .pastdmark  
2148 ..			.dmark: db "PQE"  
214b f1			.pastdmark: pop af  
214c			endm  
# End of macro DMARK
214c				CALLMONITOR 
214c cd 9e 19			call break_point_state  
214f				endm  
# End of macro CALLMONITOR
214f			endif	 
214f			 
214f 2b				dec hl    ; see if there is an optional trailing double quote 
2150 7e				ld a,(hl) 
2151 fe 22			cp '"' 
2153 20 03			jr nz, .strnoq 
2155 3e 00			ld a, 0      ; get rid of double quote 
2157 77				ld (hl), a 
2158 23			.strnoq: inc hl 
2159			 
2159 3e 00			ld a, 0 
215b 77				ld (hl), a     ; add null term and get rid of trailing double quote 
215c			 
215c 13				inc de ; add one for the type string 
215d 13				inc de ; add one for null term??? 
215e			 
215e				; tos is get string pointer again 
215e				; de contains space to allocate 
215e				 
215e d5				push de 
215f			 
215f eb				ex de, hl 
2160			 
2160				;push af 
2160			 
2160			if DEBUG_FORTH_PUSH 
2160						DMARK "PHm" 
2160 f5				push af  
2161 3a 75 21			ld a, (.dmark)  
2164 32 6e fe			ld (debug_mark),a  
2167 3a 76 21			ld a, (.dmark+1)  
216a 32 6f fe			ld (debug_mark+1),a  
216d 3a 77 21			ld a, (.dmark+2)  
2170 32 70 fe			ld (debug_mark+2),a  
2173 18 03			jr .pastdmark  
2175 ..			.dmark: db "PHm"  
2178 f1			.pastdmark: pop af  
2179			endm  
# End of macro DMARK
2179				CALLMONITOR 
2179 cd 9e 19			call break_point_state  
217c				endm  
# End of macro CALLMONITOR
217c			endif	 
217c cd 13 14			call malloc	; on ret hl now contains allocated memory 
217f				if DEBUG_FORTH_MALLOC_GUARD 
217f cc e8 5c				call z,malloc_error 
2182				endif 
2182			 
2182				 
2182 c1				pop bc    ; get length 
2183 d1				pop de   ;  get string start    
2184			 
2184				; hl has destination from malloc 
2184			 
2184 eb				ex de, hl    ; prep for ldir 
2185			 
2185 d5				push de   ; save malloc area for DSP later 
2186				;push hl   ; save malloc area for DSP later 
2186			 
2186			if DEBUG_FORTH_PUSH 
2186						DMARK "PHc" 
2186 f5				push af  
2187 3a 9b 21			ld a, (.dmark)  
218a 32 6e fe			ld (debug_mark),a  
218d 3a 9c 21			ld a, (.dmark+1)  
2190 32 6f fe			ld (debug_mark+1),a  
2193 3a 9d 21			ld a, (.dmark+2)  
2196 32 70 fe			ld (debug_mark+2),a  
2199 18 03			jr .pastdmark  
219b ..			.dmark: db "PHc"  
219e f1			.pastdmark: pop af  
219f			endm  
# End of macro DMARK
219f				CALLMONITOR 
219f cd 9e 19			call break_point_state  
21a2				endm  
# End of macro CALLMONITOR
21a2			endif	 
21a2			 
21a2			 
21a2 ed b0			ldir 
21a4			 
21a4			 
21a4				; push malloc to data stack     macro?????  
21a4			 
21a4				FORTH_DSP_NEXT 
21a4 cd f8 1f			call macro_forth_dsp_next 
21a7				endm 
# End of macro FORTH_DSP_NEXT
21a7			 
21a7				; save value and type 
21a7			 
21a7 2a f5 f9			ld hl, (cli_data_sp) 
21aa			 
21aa				; save item type 
21aa 3e 01			ld a,  DS_TYPE_STR 
21ac 77				ld (hl), a 
21ad 23				inc hl 
21ae			 
21ae				; get malloc word off stack 
21ae d1				pop de 
21af 73				ld (hl), e 
21b0 23				inc hl 
21b1 72				ld (hl), d 
21b2			 
21b2			 
21b2			 
21b2			if DEBUG_FORTH_PUSH 
21b2 2a f5 f9			ld hl, (cli_data_sp) 
21b5						DMARK "PHS" 
21b5 f5				push af  
21b6 3a ca 21			ld a, (.dmark)  
21b9 32 6e fe			ld (debug_mark),a  
21bc 3a cb 21			ld a, (.dmark+1)  
21bf 32 6f fe			ld (debug_mark+1),a  
21c2 3a cc 21			ld a, (.dmark+2)  
21c5 32 70 fe			ld (debug_mark+2),a  
21c8 18 03			jr .pastdmark  
21ca ..			.dmark: db "PHS"  
21cd f1			.pastdmark: pop af  
21ce			endm  
# End of macro DMARK
21ce				CALLMONITOR 
21ce cd 9e 19			call break_point_state  
21d1				endm  
# End of macro CALLMONITOR
21d1			;	ex de,hl 
21d1			endif	 
21d1				; in case of spaces, skip the ptr past the copied string 
21d1				;pop af 
21d1				;ld (cli_origptr),hl 
21d1			 
21d1 c9				ret 
21d2			 
21d2			 
21d2			 
21d2			; TODO ascii push input onto stack given hl to start of input 
21d2			 
21d2			; identify type 
21d2			; if starts with a " then a string 
21d2			; otherwise it is a number 
21d2			;  
21d2			; if a string 
21d2			;     scan for ending " to get length of string to malloc for + 1 
21d2			;     malloc 
21d2			;     put pointer to string on stack first byte flags as string 
21d2			; 
21d2			; else a number 
21d2			;    look for number format identifier 
21d2			;    $xx hex 
21d2			;    %xxxxx bin 
21d2			;    xxxxx decimal 
21d2			;    convert number to 16bit word.  
21d2			;    malloc word + 1 with flag to identiy as num 
21d2			;    put pointer to number on stack 
21d2			;   
21d2			;  
21d2			  
21d2			forth_apush: 
21d2				; kernel push 
21d2			 
21d2			if DEBUG_FORTH_PUSH 
21d2						DMARK "PSH" 
21d2 f5				push af  
21d3 3a e7 21			ld a, (.dmark)  
21d6 32 6e fe			ld (debug_mark),a  
21d9 3a e8 21			ld a, (.dmark+1)  
21dc 32 6f fe			ld (debug_mark+1),a  
21df 3a e9 21			ld a, (.dmark+2)  
21e2 32 70 fe			ld (debug_mark+2),a  
21e5 18 03			jr .pastdmark  
21e7 ..			.dmark: db "PSH"  
21ea f1			.pastdmark: pop af  
21eb			endm  
# End of macro DMARK
21eb				CALLMONITOR 
21eb cd 9e 19			call break_point_state  
21ee				endm  
# End of macro CALLMONITOR
21ee			endif	 
21ee				; identify input type 
21ee			 
21ee 7e				ld a,(hl) 
21ef fe 22			cp '"' 
21f1 28 0a			jr z, .fapstr 
21f3 fe 24			cp '$' 
21f5 ca 1d 22			jp z, .faphex 
21f8 fe 25			cp '%' 
21fa ca 05 22			jp z, .fapbin 
21fd			;	cp 'b' 
21fd			;	jp z, .fabin 
21fd				; else decimal 
21fd			 
21fd				; TODO do decimal conversion 
21fd				; decimal is stored as a 16bit word 
21fd			 
21fd				; by default everything is a string if type is not detected 
21fd			.fapstr: ; 
21fd fe 22			cp '"' 
21ff 20 01			jr nz, .strnoqu 
2201 23				inc hl 
2202			.strnoqu: 
2202 c3 d7 20			jp forth_push_str 
2205			 
2205			 
2205			 
2205			.fapbin:    ; push a binary string.  
2205 11 00 00			ld de, 0   ; hold a 16bit value 
2208			 
2208 23			.fapbinshift:	inc hl  
2209 7e				ld a,(hl) 
220a fe 00			cp 0     ; done scanning  
220c 28 0b			jr z, .fapbdone  	; got it in HL so push  
220e			 
220e				; left shift de 
220e eb				ex de, hl	 
220f 29				add hl, hl 
2210			 
2210				; is 1 
2210 fe 31			cp '1' 
2212 20 02			jr nz, .binzero 
2214 cb 4d			bit 1, l 
2216			.binzero: 
2216 eb				ex de, hl	 ; save current de 
2217 18 ef			jr .fapbinshift 
2219			 
2219			.fapbdone: 
2219 eb				ex de, hl 
221a c3 69 20			jp forth_push_numhl 
221d			 
221d			 
221d			.faphex:   ; hex is always stored as a 16bit word 
221d				; skip number prefix 
221d 23				inc hl 
221e				; turn ascii into number 
221e cd 03 13			call get_word_hl	; ret 16bit word in hl 
2221			 
2221 c3 69 20			jp forth_push_numhl 
2224			 
2224 00				 nop 
2225			 
2225			.fabin:   ; TODO bin conversion 
2225			 
2225			 
2225 c9				ret 
2226			 
2226			 
2226			; get either a string ptr or a 16bit word from the data stack 
2226			 
2226			FORTH_DSP: macro 
2226				call macro_forth_dsp 
2226				endm 
2226			 
2226			macro_forth_dsp: 
2226				; data stack pointer points to current word on tos 
2226			 
2226 2a f5 f9			ld hl,(cli_data_sp) 
2229			 
2229				if DEBUG_FORTH_PUSH 
2229						DMARK "DSP" 
2229 f5				push af  
222a 3a 3e 22			ld a, (.dmark)  
222d 32 6e fe			ld (debug_mark),a  
2230 3a 3f 22			ld a, (.dmark+1)  
2233 32 6f fe			ld (debug_mark+1),a  
2236 3a 40 22			ld a, (.dmark+2)  
2239 32 70 fe			ld (debug_mark+2),a  
223c 18 03			jr .pastdmark  
223e ..			.dmark: db "DSP"  
2241 f1			.pastdmark: pop af  
2242			endm  
# End of macro DMARK
2242			 
2242 cd 1d 5d				call display_data_sp 
2245				;call break_point_state 
2245				;rst 030h 
2245				CALLMONITOR 
2245 cd 9e 19			call break_point_state  
2248				endm  
# End of macro CALLMONITOR
2248				endif 
2248			 
2248 c9				ret 
2249			 
2249			; return hl to start of value on stack 
2249			 
2249			FORTH_DSP_VALUE: macro 
2249				call macro_forth_dsp_value 
2249				endm 
2249			 
2249			macro_forth_dsp_value: 
2249			 
2249				FORTH_DSP 
2249 cd 26 22			call macro_forth_dsp 
224c				endm 
# End of macro FORTH_DSP
224c			 
224c d5				push de 
224d			 
224d 23				inc hl ; skip type 
224e			 
224e 5e				ld e, (hl) 
224f 23				inc hl 
2250 56				ld d, (hl) 
2251 eb				ex de,hl  
2252			 
2252 d1				pop de 
2253			 
2253 c9				ret 
2254			 
2254			; return hl to start of value to second item on stack 
2254			 
2254			FORTH_DSP_VALUEM1: macro 
2254				call macro_forth_dsp_value_m1 
2254				endm 
2254			 
2254			macro_forth_dsp_value_m1: 
2254			 
2254				FORTH_DSP 
2254 cd 26 22			call macro_forth_dsp 
2257				endm 
# End of macro FORTH_DSP
2257			 
2257 2b				dec hl 
2258 2b				dec hl 
2259			;	dec hl 
2259			 
2259 d5				push de 
225a			 
225a 5e				ld e, (hl) 
225b 23				inc hl 
225c 56				ld d, (hl) 
225d eb				ex de,hl  
225e			 
225e d1				pop de 
225f			 
225f c9				ret 
2260			 
2260				 
2260			 
2260			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2260			 
2260			FORTH_DSP_POP: macro 
2260				call macro_forth_dsp_pop 
2260				endm 
2260			 
2260			 
2260			; get the tos data type 
2260			 
2260			FORTH_DSP_TYPE:   macro 
2260			 
2260				;FORTH_DSP_VALUE 
2260				FORTH_DSP 
2260				 
2260				; hl points to value 
2260				; check type 
2260			 
2260				ld a,(hl) 
2260			 
2260				endm 
2260			 
2260			; load the tos value into hl 
2260			 
2260			 
2260			FORTH_DSP_VALUEHL:  macro 
2260				call macro_dsp_valuehl 
2260				endm 
2260			 
2260			 
2260			 
2260			macro_dsp_valuehl: 
2260				FORTH_DSP_VALUE 
2260 cd 49 22			call macro_forth_dsp_value 
2263				endm 
# End of macro FORTH_DSP_VALUE
2263			 
2263				;FORTH_ERR_TOS_NOTNUM 
2263			 
2263				;inc hl   ; skip type id 
2263			 
2263			;	push de 
2263			; 
2263			;	ld e, (hl) 
2263			;	inc hl 
2263			;	ld d, (hl) 
2263			;	ex de,hl  
2263			 
2263			;	pop de 
2263			 
2263				if DEBUG_FORTH_PUSH 
2263						DMARK "DVL" 
2263 f5				push af  
2264 3a 78 22			ld a, (.dmark)  
2267 32 6e fe			ld (debug_mark),a  
226a 3a 79 22			ld a, (.dmark+1)  
226d 32 6f fe			ld (debug_mark+1),a  
2270 3a 7a 22			ld a, (.dmark+2)  
2273 32 70 fe			ld (debug_mark+2),a  
2276 18 03			jr .pastdmark  
2278 ..			.dmark: db "DVL"  
227b f1			.pastdmark: pop af  
227c			endm  
# End of macro DMARK
227c				CALLMONITOR 
227c cd 9e 19			call break_point_state  
227f				endm  
# End of macro CALLMONITOR
227f				endif 
227f c9				ret 
2280			 
2280			forth_apushstrhl:      
2280				; push of string requires use of cli_origptr 
2280				; bodge use 
2280			 
2280				; get current cli_origptr, save, update with temp pointer  
2280 ed 5b 45 fa		ld de, (cli_origptr) 
2284 22 45 fa			ld (cli_origptr), hl 
2287 d5				push de 
2288 cd d2 21			call forth_apush 
228b d1				pop de 
228c ed 53 45 fa		ld (cli_origptr), de 
2290 c9			        ret	 
2291			 
2291			 
2291			; increase loop stack pointer and save hl to it 
2291				 
2291			FORTH_LOOP_NEXT: macro 
2291				call macro_forth_loop_next 
2291				;nop 
2291				endm 
2291			 
2291			macro_forth_loop_next: 
2291				if DEBUG_FORTH_STACK_GUARD 
2291 cd ab 70				call check_stacks 
2294				endif 
2294 e5				push hl 
2295 d5				push de 
2296 eb				ex de,hl 
2297 2a f7 f9			ld hl,(cli_loop_sp) 
229a 23				inc hl 
229b 23				inc hl 
229c					if DEBUG_FORTH_WORDS 
229c						DMARK "LNX" 
229c f5				push af  
229d 3a b1 22			ld a, (.dmark)  
22a0 32 6e fe			ld (debug_mark),a  
22a3 3a b2 22			ld a, (.dmark+1)  
22a6 32 6f fe			ld (debug_mark+1),a  
22a9 3a b3 22			ld a, (.dmark+2)  
22ac 32 70 fe			ld (debug_mark+2),a  
22af 18 03			jr .pastdmark  
22b1 ..			.dmark: db "LNX"  
22b4 f1			.pastdmark: pop af  
22b5			endm  
# End of macro DMARK
22b5						CALLMONITOR 
22b5 cd 9e 19			call break_point_state  
22b8				endm  
# End of macro CALLMONITOR
22b8					endif 
22b8 22 f7 f9			ld (cli_loop_sp),hl 
22bb 73				ld (hl), e 
22bc 23				inc hl 
22bd 72				ld (hl), d 
22be d1				pop de    ; been reversed so save a swap on restore 
22bf e1				pop hl 
22c0				if DEBUG_FORTH_STACK_GUARD 
22c0 cd ab 70				call check_stacks 
22c3				endif 
22c3 c9				ret 
22c4			 
22c4			; get current ret stack pointer and save to hl  
22c4				 
22c4			FORTH_LOOP_TOS: macro 
22c4				call macro_forth_loop_tos 
22c4				endm 
22c4			 
22c4			macro_forth_loop_tos: 
22c4 d5				push de 
22c5 2a f7 f9			ld hl,(cli_loop_sp) 
22c8 5e				ld e, (hl) 
22c9 23				inc hl 
22ca 56				ld d, (hl) 
22cb eb				ex de, hl 
22cc d1				pop de 
22cd c9				ret 
22ce			 
22ce			; pop loop stack pointer 
22ce				 
22ce			FORTH_LOOP_POP: macro 
22ce				call macro_forth_loop_pop 
22ce				endm 
22ce			 
22ce			 
22ce			macro_forth_loop_pop: 
22ce				if DEBUG_FORTH_STACK_GUARD 
22ce					DMARK "LPP" 
22ce f5				push af  
22cf 3a e3 22			ld a, (.dmark)  
22d2 32 6e fe			ld (debug_mark),a  
22d5 3a e4 22			ld a, (.dmark+1)  
22d8 32 6f fe			ld (debug_mark+1),a  
22db 3a e5 22			ld a, (.dmark+2)  
22de 32 70 fe			ld (debug_mark+2),a  
22e1 18 03			jr .pastdmark  
22e3 ..			.dmark: db "LPP"  
22e6 f1			.pastdmark: pop af  
22e7			endm  
# End of macro DMARK
22e7 cd ab 70				call check_stacks 
22ea					FORTH_CHK_LOOP_UNDER 
22ea e5				push hl 
22eb d5				push de 
22ec 2a f7 f9			ld hl,(cli_loop_sp) 
22ef 11 31 f9			ld de, cli_loop_stack 
22f2 cd 6a 0f			call cmp16 
22f5 da c5 71			jp c, fault_loop_under 
22f8 d1				pop de 
22f9 e1				pop hl 
22fa				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22fa				endif 
22fa e5				push hl 
22fb 2a f7 f9			ld hl,(cli_loop_sp) 
22fe 2b				dec hl 
22ff 2b				dec hl 
2300 22 f7 f9			ld (cli_loop_sp), hl 
2303				; TODO do stack underflow checks 
2303 e1				pop hl 
2304				if DEBUG_FORTH_STACK_GUARD 
2304 cd ab 70				call check_stacks 
2307					FORTH_CHK_LOOP_UNDER 
2307 e5				push hl 
2308 d5				push de 
2309 2a f7 f9			ld hl,(cli_loop_sp) 
230c 11 31 f9			ld de, cli_loop_stack 
230f cd 6a 0f			call cmp16 
2312 da c5 71			jp c, fault_loop_under 
2315 d1				pop de 
2316 e1				pop hl 
2317				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2317				endif 
2317 c9				ret 
2318			 
2318			macro_forth_dsp_pop: 
2318			 
2318 e5				push hl 
2319			 
2319				; release malloc data 
2319			 
2319				if DEBUG_FORTH_STACK_GUARD 
2319 cd ab 70				call check_stacks 
231c					FORTH_CHK_DSP_UNDER 
231c e5				push hl 
231d d5				push de 
231e 2a f5 f9			ld hl,(cli_data_sp) 
2321 11 2f f7			ld de, cli_data_stack 
2324 cd 6a 0f			call cmp16 
2327 da b9 71			jp c, fault_dsp_under 
232a d1				pop de 
232b e1				pop hl 
232c				endm 
# End of macro FORTH_CHK_DSP_UNDER
232c				endif 
232c				;ld hl,(cli_data_sp) 
232c			if DEBUG_FORTH_DOT 
232c				DMARK "DPP" 
232c f5				push af  
232d 3a 41 23			ld a, (.dmark)  
2330 32 6e fe			ld (debug_mark),a  
2333 3a 42 23			ld a, (.dmark+1)  
2336 32 6f fe			ld (debug_mark+1),a  
2339 3a 43 23			ld a, (.dmark+2)  
233c 32 70 fe			ld (debug_mark+2),a  
233f 18 03			jr .pastdmark  
2341 ..			.dmark: db "DPP"  
2344 f1			.pastdmark: pop af  
2345			endm  
# End of macro DMARK
2345				CALLMONITOR 
2345 cd 9e 19			call break_point_state  
2348				endm  
# End of macro CALLMONITOR
2348			endif	 
2348			 
2348			 
2348			if FORTH_ENABLE_DSPPOPFREE 
2348			 
2348				FORTH_DSP 
2348 cd 26 22			call macro_forth_dsp 
234b				endm 
# End of macro FORTH_DSP
234b			 
234b 7e				ld a, (hl) 
234c fe 01			cp DS_TYPE_STR 
234e 20 23			jr nz, .skippopfree 
2350			 
2350				FORTH_DSP_VALUEHL 
2350 cd 60 22			call macro_dsp_valuehl 
2353				endm 
# End of macro FORTH_DSP_VALUEHL
2353 00				nop 
2354			if DEBUG_FORTH_DOT 
2354				DMARK "DPf" 
2354 f5				push af  
2355 3a 69 23			ld a, (.dmark)  
2358 32 6e fe			ld (debug_mark),a  
235b 3a 6a 23			ld a, (.dmark+1)  
235e 32 6f fe			ld (debug_mark+1),a  
2361 3a 6b 23			ld a, (.dmark+2)  
2364 32 70 fe			ld (debug_mark+2),a  
2367 18 03			jr .pastdmark  
2369 ..			.dmark: db "DPf"  
236c f1			.pastdmark: pop af  
236d			endm  
# End of macro DMARK
236d				CALLMONITOR 
236d cd 9e 19			call break_point_state  
2370				endm  
# End of macro CALLMONITOR
2370			endif	 
2370 cd dd 14			call free 
2373			.skippopfree: 
2373				 
2373			 
2373			endif 
2373			 
2373			if DEBUG_FORTH_DOT_KEY 
2373				DMARK "DP2" 
2373				CALLMONITOR 
2373			endif	 
2373			 
2373				; move pointer down 
2373			 
2373 2a f5 f9			ld hl,(cli_data_sp) 
2376 2b				dec hl 
2377 2b				dec hl 
2378			; PARSEV5 
2378 2b				dec hl 
2379 22 f5 f9			ld (cli_data_sp), hl 
237c			 
237c				if DEBUG_FORTH_STACK_GUARD 
237c cd ab 70				call check_stacks 
237f					FORTH_CHK_DSP_UNDER 
237f e5				push hl 
2380 d5				push de 
2381 2a f5 f9			ld hl,(cli_data_sp) 
2384 11 2f f7			ld de, cli_data_stack 
2387 cd 6a 0f			call cmp16 
238a da b9 71			jp c, fault_dsp_under 
238d d1				pop de 
238e e1				pop hl 
238f				endm 
# End of macro FORTH_CHK_DSP_UNDER
238f				endif 
238f			 
238f e1				pop hl 
2390			 
2390 c9				ret 
2391			 
2391			getwordathl: 
2391				; hl points to an address 
2391				; load hl with the word at that address 
2391			 
2391 d5				push de 
2392			 
2392 5e				ld e, (hl) 
2393 23				inc hl 
2394 56				ld d, (hl) 
2395 eb				ex de, hl 
2396			 
2396 d1				pop de 
2397 c9				ret 
2398			 
2398			 
2398			 
2398			 
2398			 
2398			; eof 
2398			 
# End of file forth_stackopsv5.asm
2398			endif 
2398			 
2398			loadwordinhl:	 
2398			 
2398 d5				push de 
2399			 
2399 5e				ld e, (hl) 
239a 23				inc hl 
239b 56				ld d, (hl) 
239c eb				ex de,hl  
239d			 
239d d1				pop de 
239e			 
239e c9				ret 
239f			 
239f			user_word_eol:  
239f				; hl contains the pointer to where to create a linked list item from the end 
239f				; of the user dict to continue on at the system word dict 
239f				 
239f				; poke the stub of the word list linked list to repoint to rom words 
239f			 
239f				; stub format 
239f				; db   word id 
239f				; dw    link to next word 
239f			        ; db char length of token 
239f				; db string + 0 term 
239f				; db exec code....  
239f			 
239f 3e 00			ld a, WORD_SYS_ROOT     ; root word 
23a1 77				ld (hl), a		; word id 
23a2 23				inc hl 
23a3			 
23a3 11 6e 25			ld de, sysdict 
23a6 73				ld (hl), e		; next word link ie system dict 
23a7 23				inc hl 
23a8 72				ld (hl), d		; next word link ie system dict 
23a9 23				inc hl	 
23aa			 
23aa			;	ld (hl), sysdict		; next word link ie system dict 
23aa			;	inc hl 
23aa			;	inc hl 
23aa			 
23aa			;	inc hl 
23aa			;	inc hl 
23aa			 
23aa 3e 02			ld a, 2			; word length is 0 
23ac 77				ld (hl), a	 
23ad 23				inc hl 
23ae			 
23ae 3e 7e			ld a, '~'			; word length is 0 
23b0 77				ld (hl), a	 
23b1 23				inc hl 
23b2 3e 00			ld a, 0			; save empty word 
23b4 77				ld (hl), a 
23b5			 
23b5 c9				ret 
23b6			 
23b6				 
23b6			 
23b6			forthexec_cleanup: 
23b6				FORTH_RSP_POP 
23b6 cd 31 20			call macro_forth_rsp_pop 
23b9				endm 
# End of macro FORTH_RSP_POP
23b9 c9				ret 
23ba			 
23ba			forth_call_hl: 
23ba				; taking hl 
23ba e5				push hl 
23bb c9				ret 
23bc			 
23bc			; this is called to reset Forth system but keep existing uwords etc 
23bc			 
23bc			forth_warmstart: 
23bc				; setup stack over/under flow checks 
23bc				if DEBUG_FORTH_STACK_GUARD 
23bc cd 91 70				call chk_stk_init 
23bf				endif 
23bf			 
23bf				; init stack pointers  - * these stacks go upwards *  
23bf 21 b3 f9			ld hl, cli_ret_stack 
23c2 22 f9 f9			ld (cli_ret_sp), hl	 
23c5				; set bottom of stack 
23c5 3e 00			ld a,0 
23c7 77				ld (hl),a 
23c8 23				inc hl 
23c9 77				ld (hl),a 
23ca			 
23ca 21 2f f7			ld hl, cli_data_stack 
23cd 22 f5 f9			ld (cli_data_sp), hl	 
23d0				; set bottom of stack 
23d0 3e 00			ld a,0 
23d2 77				ld (hl),a 
23d3 23				inc hl 
23d4 77				ld (hl),a 
23d5			 
23d5 21 31 f9			ld hl, cli_loop_stack 
23d8 22 f7 f9			ld (cli_loop_sp), hl	 
23db				; set bottom of stack 
23db 3e 00			ld a,0 
23dd 77				ld (hl),a 
23de 23				inc hl 
23df 77				ld (hl),a 
23e0			 
23e0				; init extent of current open file 
23e0			 
23e0 3e 00			ld a, 0 
23e2 32 71 fa			ld (store_openext), a 
23e5			 
23e5 c9				ret 
23e6			 
23e6			 
23e6			; Cold Start - this is called to setup the whole Forth system 
23e6			 
23e6			forth_init: 
23e6			 
23e6				; setup stack over/under flow checks 
23e6			 
23e6			;	if DEBUG_FORTH_STACK_GUARD 
23e6			;		call chk_stk_init 
23e6			;	endif 
23e6			 
23e6				; enable auto display updates (slow.....) 
23e6			 
23e6 3e 01			ld a, 1 
23e8 32 43 fa			ld (cli_autodisplay), a 
23eb			 
23eb				; if storage is in use disable long reads for now 
23eb 3e 00			ld a, 0 
23ed 32 7c fa			ld (store_longread), a 
23f0			 
23f0			 
23f0				; show start up screen 
23f0			 
23f0 cd 18 0d			call clear_display 
23f3			 
23f3 3e 00			ld a,0 
23f5 32 65 fa			ld (f_cursor_ptr), a 
23f8			 
23f8				; set start of word list in start of ram - for use when creating user words 
23f8			 
23f8 21 00 80			ld hl, baseram 
23fb 22 c5 f4			ld (os_last_new_uword), hl 
23fe cd 9f 23			call user_word_eol 
2401				 
2401			;		call display_data_sp 
2401			;		call next_page_prompt 
2401			 
2401			 
2401			 
2401			 
2401 c9				ret 
2402			 
2402 .. 00		.bootforth: db " Forth Kernel Init ",0 
2416			 
2416			; TODO push to stack 
2416			 
2416			;  
2416			 
2416			if FORTH_PARSEV2 
2416			 
2416			 
2416				include "forth_parserv2.asm" 
2416			 
2416			endif 
2416			 
2416			 
2416			; parse cli version 1 
2416			 
2416			if FORTH_PARSEV1 
2416			 
2416			 
2416			 
2416			      include "forth_parserv1.asm" 
2416			endif 
2416				 
2416			if FORTH_PARSEV3 
2416			 
2416			 
2416			 
2416			      include "forth_parserv3.asm" 
2416				include "forth_wordsv3.asm" 
2416			endif 
2416			 
2416			if FORTH_PARSEV4 
2416			 
2416			 
2416			 
2416			      include "forth_parserv4.asm" 
2416				include "forth_wordsv4.asm" 
2416			endif 
2416			 
2416			if FORTH_PARSEV5 
2416			 
2416			 
2416			 
2416			      include "forth_parserv5.asm" 
2416			 
2416			 
2416			; A better parser without using malloc and string copies all over the place.  
2416			; Exec in situ should be faster 
2416			 
2416			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2416			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2416			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2416			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2416			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2416			WORD_SYS_END: equ 0   ; Opcode for all user words 
2416			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2416			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2416			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2416			 
2416			; Core word preamble macro 
2416			 
2416			CWHEAD:   macro nxtword opcode lit len opflags 
2416				db WORD_SYS_CORE+opcode             
2416				; internal op code number 
2416				dw nxtword            
2416				; link to next dict word block 
2416				db len + 1 
2416				; literal length of dict word inc zero term 
2416				db lit,0              
2416				; literal dict word 
2416			        ; TODO db opflags        
2416				endm 
2416			 
2416			 
2416			NEXTW: macro  
2416				jp macro_next 
2416				endm 
2416			 
2416			macro_next: 
2416			if DEBUG_FORTH_PARSE_KEY 
2416				DMARK "NXT" 
2416				CALLMONITOR 
2416			endif	 
2416			;	inc hl  ; skip token null term  
2416 ed 4b 47 fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
241a ed 5b 45 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
241e 2a c9 f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2421			if DEBUG_FORTH_PARSE_KEY 
2421				DMARK "}AA" 
2421				CALLMONITOR 
2421			endif	 
2421 c3 24 25			jp execnext 
2424				;jp exec1 
2424			       
2424			 
2424			 
2424			; Another go at the parser to compile  
2424			 
2424			 
2424			; TODO rework parser to change all of the string words to byte tokens 
2424			; TODO do a search for  
2424			 
2424			; TODO first run normal parser to zero term sections 
2424			; TODO for each word do a token look up to get the op code 
2424			; TODO need some means to flag to the exec that this is a byte code form    
2424			 
2424			 
2424			forthcompile: 
2424			 
2424			; 
2424			; line parse: 
2424			;       parse raw input buffer 
2424			;       tokenise the words 
2424			;       malloc new copy (for looping etc) 
2424			;       copy to malloc + current pc in line to start of string and add line term 
2424			;       save on new rsp 
2424			; 
2424			 
2424			; hl to point to the line to tokenise 
2424			 
2424			;	push hl 
2424 22 c9 f4			ld (os_tok_ptr), hl  ; save ptr to string 
2427			 
2427			;	ld a,0		; string term on input 
2427			;	call strlent 
2427			 
2427			;	ld (os_tok_len), hl	 ; save string length 
2427			 
2427			;if DEBUG_FORTH_TOK 
2427			;	ex de,hl		 
2427			;endif 
2427			 
2427			;	pop hl 		; get back string pointer 
2427			 
2427			if DEBUG_FORTH_TOK 
2427						DMARK "TOc" 
2427				CALLMONITOR 
2427			endif 
2427 7e			.cptoken2:    ld a,(hl) 
2428 23				inc hl 
2429 fe 7f			cp FORTH_END_BUFFER 
242b 28 29			jr z, .cptokendone2 
242d fe 00			cp 0 
242f 28 25			jr z, .cptokendone2 
2431 fe 22			cp '"' 
2433 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2435 fe 20			cp ' ' 
2437 20 ee			jr nz,  .cptoken2 
2439			 
2439			; TODO consume comments held between ( and ) 
2439			 
2439				; we have a space so change to zero term for dict match later 
2439 2b				dec hl 
243a 3e 00			ld a,0 
243c 77				ld (hl), a 
243d 23				inc hl 
243e 18 e7			jr .cptoken2 
2440				 
2440			 
2440			.cptokenstr2: 
2440				; skip all white space until either eol (because forgot to term) or end double quote 
2440			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2440				;inc hl ; skip current double quote 
2440 7e				ld a,(hl) 
2441 23				inc hl 
2442 fe 22			cp '"' 
2444 28 e1			jr z, .cptoken2 
2446 fe 7f			cp FORTH_END_BUFFER 
2448 28 0c			jr z, .cptokendone2 
244a fe 00			cp 0 
244c 28 08			jr z, .cptokendone2 
244e fe 20			cp ' ' 
2450 28 02			jr z, .cptmp2 
2452 18 ec			jr .cptokenstr2 
2454			 
2454			.cptmp2:	; we have a space so change to zero term for dict match later 
2454				;dec hl 
2454				;ld a,"-"	; TODO remove this when working 
2454				;ld (hl), a 
2454				;inc hl 
2454 18 ea			jr .cptokenstr2 
2456			 
2456			.cptokendone2: 
2456				;inc hl 
2456 3e 7f			ld a, FORTH_END_BUFFER 
2458 77				ld (hl),a 
2459 23				inc hl 
245a 3e 21			ld a, '!' 
245c 77				ld (hl),a 
245d			 
245d 2a c9 f4			ld hl,(os_tok_ptr) 
2460			         
2460			if DEBUG_FORTH_TOK 
2460						DMARK "Tc1" 
2460				CALLMONITOR 
2460			endif 
2460			 
2460				; push exec string to top of return stack 
2460				FORTH_RSP_NEXT 
2460 cd 10 20			call macro_forth_rsp_next 
2463				endm 
# End of macro FORTH_RSP_NEXT
2463 c9				ret 
2464			 
2464			; Another go at the parser need to simplify the process 
2464			 
2464			forthparse: 
2464			 
2464			; 
2464			; line parse: 
2464			;       parse raw input buffer 
2464			;       tokenise the words 
2464			;       malloc new copy (for looping etc) 
2464			;       copy to malloc + current pc in line to start of string and add line term 
2464			;       save on new rsp 
2464			; 
2464			 
2464			; hl to point to the line to tokenise 
2464			 
2464			;	push hl 
2464 22 c9 f4			ld (os_tok_ptr), hl  ; save ptr to string 
2467			 
2467			;	ld a,0		; string term on input 
2467			;	call strlent 
2467			 
2467			;	ld (os_tok_len), hl	 ; save string length 
2467			 
2467			;if DEBUG_FORTH_TOK 
2467			;	ex de,hl		 
2467			;endif 
2467			 
2467			;	pop hl 		; get back string pointer 
2467			 
2467			if DEBUG_FORTH_TOK 
2467						DMARK "TOK" 
2467				CALLMONITOR 
2467			endif 
2467 7e			.ptoken2:    ld a,(hl) 
2468 23				inc hl 
2469 fe 7f			cp FORTH_END_BUFFER 
246b 28 29			jr z, .ptokendone2 
246d fe 00			cp 0 
246f 28 25			jr z, .ptokendone2 
2471 fe 22			cp '"' 
2473 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2475 fe 20			cp ' ' 
2477 20 ee			jr nz,  .ptoken2 
2479			 
2479			; TODO consume comments held between ( and ) 
2479			 
2479				; we have a space so change to zero term for dict match later 
2479 2b				dec hl 
247a 3e 00			ld a,0 
247c 77				ld (hl), a 
247d 23				inc hl 
247e 18 e7			jr .ptoken2 
2480				 
2480			 
2480			.ptokenstr2: 
2480				; skip all white space until either eol (because forgot to term) or end double quote 
2480			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2480				;inc hl ; skip current double quote 
2480 7e				ld a,(hl) 
2481 23				inc hl 
2482 fe 22			cp '"' 
2484 28 e1			jr z, .ptoken2 
2486 fe 7f			cp FORTH_END_BUFFER 
2488 28 0c			jr z, .ptokendone2 
248a fe 00			cp 0 
248c 28 08			jr z, .ptokendone2 
248e fe 20			cp ' ' 
2490 28 02			jr z, .ptmp2 
2492 18 ec			jr .ptokenstr2 
2494			 
2494			.ptmp2:	; we have a space so change to zero term for dict match later 
2494				;dec hl 
2494				;ld a,"-"	; TODO remove this when working 
2494				;ld (hl), a 
2494				;inc hl 
2494 18 ea			jr .ptokenstr2 
2496			 
2496			.ptokendone2: 
2496				;inc hl 
2496 3e 7f			ld a, FORTH_END_BUFFER 
2498 77				ld (hl),a 
2499 23				inc hl 
249a 3e 21			ld a, '!' 
249c 77				ld (hl),a 
249d			 
249d 2a c9 f4			ld hl,(os_tok_ptr) 
24a0			         
24a0			if DEBUG_FORTH_TOK 
24a0						DMARK "TK1" 
24a0				CALLMONITOR 
24a0			endif 
24a0			 
24a0				; push exec string to top of return stack 
24a0				FORTH_RSP_NEXT 
24a0 cd 10 20			call macro_forth_rsp_next 
24a3				endm 
# End of macro FORTH_RSP_NEXT
24a3 c9				ret 
24a4			 
24a4			; 
24a4			;	; malloc size + buffer pointer + if is loop flag 
24a4			;	ld hl,(os_tok_len) 		 ; get string length 
24a4			; 
24a4			;	ld a,l 
24a4			; 
24a4			;	cp 0			; we dont want to use a null string 
24a4			;	ret z 
24a4			; 
24a4			;;	add 3    ; prefix malloc with buffer for current word ptr 
24a4			; 
24a4			;	add 5     ; TODO when certain not over writing memory remove 
24a4			; 
24a4			;		 
24a4			; 
24a4			;if DEBUG_FORTH_TOK 
24a4			;			DMARK "TKE" 
24a4			;	CALLMONITOR 
24a4			;endif 
24a4			; 
24a4			;	ld l,a 
24a4			;	ld h,0 
24a4			;;	push hl   ; save required space for the copy later 
24a4			;	call malloc 
24a4			;if DEBUG_FORTH_TOK 
24a4			;			DMARK "TKM" 
24a4			;	CALLMONITOR 
24a4			;endif 
24a4			;	if DEBUG_FORTH_MALLOC_GUARD 
24a4			;		push af 
24a4			;		call ishlzero 
24a4			;;		ld a, l 
24a4			;;		add h 
24a4			;;		cp 0 
24a4			;		pop af 
24a4			;		 
24a4			;		call z,malloc_error 
24a4			;	endif 
24a4			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
24a4			; 
24a4			; 
24a4			;if DEBUG_FORTH_TOK 
24a4			;			DMARK "TKR" 
24a4			;	CALLMONITOR 
24a4			;endif 
24a4			; 
24a4			;	FORTH_RSP_NEXT 
24a4			; 
24a4			;	;inc hl	 ; go past current buffer pointer 
24a4			;	;inc hl 
24a4			;	;inc hl   ; and past if loop flag 
24a4			;		; TODO Need to set flag  
24a4			; 
24a4			;	 
24a4			;	 
24a4			;	ex de,hl	; malloc is dest 
24a4			;	ld hl, (os_tok_len) 
24a4			;;	pop bc 
24a4			;	ld c, l                
24a4			;	ld b,0 
24a4			;	ld hl, (os_tok_ptr) 
24a4			; 
24a4			;if DEBUG_FORTH_TOK 
24a4			;			DMARK "TKT" 
24a4			;	CALLMONITOR 
24a4			;endif 
24a4			; 
24a4			;	; do str cpy 
24a4			; 
24a4			;	ldir      ; copy byte in hl to de 
24a4			; 
24a4			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
24a4			; 
24a4			;if DEBUG_FORTH_TOK 
24a4			; 
24a4			;			DMARK "TKY" 
24a4			;	CALLMONITOR 
24a4			;endif 
24a4			;	;ld a,0 
24a4			;	;ld a,FORTH_END_BUFFER 
24a4			;	ex de, hl 
24a4			;	;dec hl			 ; go back over the space delim at the end of word 
24a4			;	;ld (hl),a 
24a4			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
24a4			;	ld a,FORTH_END_BUFFER 
24a4			;	ld (hl),a 
24a4			;	inc hl 
24a4			;	ld a,FORTH_END_BUFFER 
24a4			;	ld (hl),a 
24a4			; 
24a4			;	; init the malloc area data 
24a4			;	; set pc for in current area 
24a4			;	;ld hl, (os_tok_malloc) 
24a4			;	;inc hl 
24a4			;	;inc hl 
24a4			;	;inc hl 
24a4			;	;ex de,hl 
24a4			;	;ld hl, (os_tok_malloc) 
24a4			;	;ld (hl),e 
24a4			;	;inc hl 
24a4			;	;ld (hl),d 
24a4			; 
24a4			; 
24a4			;	ld hl,(os_tok_malloc) 
24a4			;if DEBUG_FORTH_PARSE_KEY 
24a4			;			DMARK "TKU" 
24a4			;	CALLMONITOR 
24a4			;endif 
24a4			; 
24a4			;	ret 
24a4			 
24a4			forthexec: 
24a4			 
24a4			; line exec: 
24a4			; forth parser 
24a4			 
24a4			; 
24a4			;       get current exec line on rsp 
24a4			 
24a4				FORTH_RSP_TOS 
24a4 cd 27 20			call macro_forth_rsp_tos 
24a7				endm 
# End of macro FORTH_RSP_TOS
24a7			 
24a7			;       restore current pc - hl points to malloc of data 
24a7			 
24a7				;ld e, (hl) 
24a7				;inc hl 
24a7				;ld d, (hl) 
24a7				;ex de,hl 
24a7			 
24a7			 
24a7			exec1: 
24a7 22 c9 f4			ld (os_tok_ptr), hl 
24aa			 
24aa				; copy our PC to working vars  
24aa 22 47 fa			ld (cli_ptr), hl 
24ad 22 45 fa			ld (cli_origptr), hl 
24b0			 
24b0 7e				ld a,(hl) 
24b1 fe 7f			cp FORTH_END_BUFFER 
24b3 c8				ret z 
24b4			 
24b4				; skip any nulls 
24b4			 
24b4 fe 00			cp 0 
24b6 20 03			jr nz, .execword 
24b8 23				inc hl 
24b9 18 ec			jr exec1 
24bb			 
24bb			 
24bb			.execword: 
24bb			 
24bb			 
24bb			 
24bb			if DEBUG_FORTH_PARSE_KEY 
24bb						DMARK "KYQ" 
24bb				CALLMONITOR 
24bb			endif 
24bb			;       while at start of word: 
24bb			; get start of dict (in user area first) 
24bb			 
24bb 21 00 80		ld hl, baseram 
24be			;ld hl, sysdict 
24be 22 49 fa		ld (cli_nextword),hl 
24c1			;           match word at pc 
24c1			;           exec word 
24c1			;           or push to dsp 
24c1			;           forward to next token 
24c1			;           if line term pop rsp and exit 
24c1			;        
24c1			 
24c1			if DEBUG_FORTH_PARSE_KEY 
24c1						DMARK "KYq" 
24c1				CALLMONITOR 
24c1			endif 
24c1			 
24c1			; 
24c1			; word comp 
24c1			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
24c1			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
24c1			;    move to start of word  
24c1			;    compare word to cli_token 
24c1			 
24c1			.execpnword:	; HL at start of a word in the dictionary to check 
24c1			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
24c1			;	ld (cli_ptr), hl 
24c1			 
24c1 2a 49 fa			ld hl,(cli_nextword) 
24c4			 
24c4 cd 67 25			call forth_tok_next 
24c7			; tok next start here 
24c7			;	; TODO skip compiled symbol for now 
24c7			;	inc hl 
24c7			; 
24c7			;	; save pointer to next word 
24c7			; 
24c7			;	; hl now points to the address of the next word pointer  
24c7			;	ld e, (hl) 
24c7			;	inc hl 
24c7			;	ld d, (hl) 
24c7			;	inc l 
24c7			; 
24c7			;	ex de,hl 
24c7			;if DEBUG_FORTH_PARSE_NEXTWORD 
24c7			;	push bc 
24c7			;	ld bc, (cli_nextword) 
24c7			;			DMARK "NXW" 
24c7			;	CALLMONITOR 
24c7			;	pop bc 
24c7			;endif 
24c7			; tok next end here 
24c7 22 49 fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
24ca eb				ex de, hl 
24cb			 
24cb			 
24cb				; save the pointer of the current token - 1 to check against 
24cb				 
24cb 22 4d fa			ld (cli_token), hl   
24ce				; TODO maybe remove below save if no debug 
24ce				; save token string ptr for any debug later 
24ce 23				inc hl  
24cf 22 4f fa			ld (cli_origtoken), hl 
24d2 2b				dec hl 
24d3				; save pointer to the start of the next dictionay word 
24d3 7e				ld a,(hl)   ; get string length 
24d4 47				ld b,a 
24d5			.execpnwordinc:  
24d5 23				inc hl 
24d6 10 fd			djnz .execpnwordinc 
24d8 22 4b fa			ld (cli_execword), hl      ; save start of this words code 
24db			 
24db				; now check the word token against the string being parsed 
24db			 
24db 2a 4d fa			ld hl,(cli_token) 
24de 23				inc hl     ; skip string length (use zero term instead to end) 
24df 22 4d fa			ld (cli_token), hl 
24e2			 
24e2			if DEBUG_FORTH_PARSE_KEY 
24e2						DMARK "KY2" 
24e2			endif 
24e2			if DEBUG_FORTH_PARSE_EXEC 
24e2				; see if disabled 
24e2			 
24e2				ld a, (os_view_disable) 
24e2				cp '*' 
24e2				jr z, .skip 
24e2			 
24e2				push hl 
24e2				push hl 
24e2				call clear_display 
24e2				ld de, .compword 
24e2				ld a, display_row_1 
24e2				call str_at_display 
24e2				pop de 
24e2				ld a, display_row_2 
24e2				call str_at_display 
24e2				ld hl,(cli_ptr) 
24e2				ld a,(hl) 
24e2			        ld hl, os_word_scratch 
24e2				ld (hl),a 
24e2				ld a,0 
24e2				inc hl 
24e2				ld (hl),a 	 
24e2				ld de, os_word_scratch 
24e2				ld a, display_row_2+10 
24e2				call str_at_display 
24e2				call update_display 
24e2				ld a, 100 
24e2				call aDelayInMS 
24e2				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24e2				call delay250ms 
24e2				endif 
24e2				pop hl 
24e2			.skip:  
24e2			endif	 
24e2			.execpnchar:    ; compare char between token and string to parse 
24e2			 
24e2			if DEBUG_FORTH_PARSE_KEY 
24e2						DMARK "Ky3" 
24e2			endif 
24e2			if DEBUG_FORTH_PARSE_EXEC 
24e2				; see if disabled 
24e2			 
24e2				ld a, (os_view_disable) 
24e2				cp '*' 
24e2				jr z, .skip2 
24e2			 
24e2			;	call clear_display 
24e2			ld hl,(cli_token) 
24e2			ld a,(hl) 
24e2			ld (os_word_scratch),a 
24e2				ld hl,(cli_ptr) 
24e2			ld a,(hl) 
24e2				ld (os_word_scratch+1),a 
24e2				ld a,0 
24e2				ld (os_word_scratch+2),a 
24e2				ld de,os_word_scratch 
24e2				ld a,display_row_4 
24e2				call str_at_display 
24e2				call update_display 
24e2			.skip2:  
24e2			endif 
24e2 2a 4d fa			ld hl,(cli_token) 
24e5 7e				ld a, (hl)	 ; char in word token 
24e6 23				inc hl 		; move to next char 
24e7 22 4d fa			ld (cli_token), hl ; and save it 
24ea 47				ld b,a 
24eb			 
24eb 2a 47 fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
24ee 7e				ld a,(hl) 
24ef 23				inc hl 
24f0 22 47 fa			ld (cli_ptr), hl		; move to next char 
24f3 cd a1 13			call toUpper 		; make sure the input string matches case 
24f6			 
24f6			if DEBUG_FORTH_PARSE 
24f6			endif 
24f6			 
24f6				; input stream end of token is a space so get rid of it 
24f6			 
24f6			;	cp ' ' 
24f6			;	jr nz, .pnskipspace 
24f6			; 
24f6			;	ld a, 0		; make same term as word token term 
24f6			; 
24f6			;.pnskipspace: 
24f6			 
24f6			if DEBUG_FORTH_PARSE_KEY 
24f6						DMARK "KY7" 
24f6			endif 
24f6 b8				cp b 
24f7 c2 0d 25			jp nz, .execpnskipword	 ; no match so move to next word 
24fa				 
24fa			;    if same 
24fa			;       scan for string terms 0 for token and 32 for input 
24fa			 
24fa				 
24fa			if DEBUG_FORTH_PARSE_KEY 
24fa						DMARK "KY8" 
24fa			endif 
24fa			 
24fa 80				add b			 
24fb fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
24fd							; TODO need to make sure last word in zero term string is accounted for 
24fd 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
24ff			 
24ff			 
24ff				; at end of both strings so both are exact match 
24ff			 
24ff			;       skip ptr for next word 
24ff			 
24ff 2a 47 fa			ld hl,(cli_ptr) 	; at input string term 
2502 23				inc hl			 ; at next char 
2503 22 47 fa			ld (cli_ptr), hl     ; save for next round of the parser 
2506 22 45 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2509				 
2509				 
2509			if DEBUG_FORTH_PARSE_KEY 
2509						DMARK "KY3" 
2509			endif 
2509			 
2509			 
2509			 
2509			;       exec code block 
2509			if DEBUG_FORTH_JP 
2509				call clear_display 
2509				call update_display 
2509				call delay1s 
2509				ld hl, (cli_execword)     ; save for next check if no match on this word 
2509				ld a,h 
2509				ld hl, os_word_scratch 
2509				call hexout 
2509				ld hl, (cli_execword)     ; save for next check if no match on this word 
2509				ld a,l 
2509				ld hl, os_word_scratch+2 
2509				call hexout 
2509				ld hl, os_word_scratch+4 
2509				ld a,0 
2509				ld (hl),a 
2509				ld de,os_word_scratch 
2509				call str_at_display 
2509					ld a, display_row_2 
2509					call str_at_display 
2509				ld de, (cli_origtoken) 
2509				ld a, display_row_1+10 
2509					call str_at_display 
2509			 
2509				ld a,display_row_1 
2509				ld de, .foundword 
2509				ld a, display_row_3 
2509				call str_at_display 
2509				call update_display 
2509				call delay1s 
2509				call delay1s 
2509				call delay1s 
2509			endif 
2509			 
2509			if DEBUG_FORTH_PARSE_KEY 
2509						DMARK "KYj" 
2509			endif 
2509				; TODO save the word pointer in this exec 
2509			 
2509 2a 4b fa			ld hl,(cli_execword) 
250c e9				jp (hl) 
250d			 
250d			 
250d			;    if not same 
250d			;	scan for zero term 
250d			;	get ptr for next word 
250d			;	goto word comp 
250d			 
250d			.execpnskipword:	; get pointer to next word 
250d 2a 49 fa			ld hl,(cli_nextword) 
2510			 
2510 7e				ld a,(hl) 
2511 fe 00			cp WORD_SYS_END 
2513			;	cp 0 
2513 28 09			jr z, .execendofdict			 ; at end of words 
2515			 
2515			if DEBUG_FORTH_PARSE_KEY 
2515						DMARK "KY4" 
2515			endif 
2515			if DEBUG_FORTH_PARSE_EXEC 
2515			 
2515				; see if disabled 
2515			 
2515				ld a, (os_view_disable) 
2515				cp '*' 
2515				jr z, .noskip 
2515			 
2515			 
2515				ld de, .nowordfound 
2515				ld a, display_row_3 
2515				call str_at_display 
2515				call update_display 
2515				ld a, 100 
2515				call aDelayInMS 
2515				 
2515				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2515					call delay250ms 
2515				endif 
2515			.noskip:  
2515			 
2515			endif	 
2515			 
2515 2a 45 fa			ld hl,(cli_origptr) 
2518 22 47 fa			ld (cli_ptr),hl 
251b			 
251b			if DEBUG_FORTH_PARSE_KEY 
251b						DMARK "KY5" 
251b			endif 
251b c3 c1 24			jp .execpnword			; else go to next word 
251e			 
251e			.execendofdict:  
251e			 
251e			if DEBUG_FORTH_PARSE_KEY 
251e						DMARK "KYe" 
251e			endif 
251e			if DEBUG_FORTH_PARSE_EXEC 
251e				; see if disabled 
251e			 
251e				ld a, (os_view_disable) 
251e				cp '*' 
251e				jr z, .ispskip 
251e			 
251e				call clear_display 
251e				call update_display 
251e				call delay1s 
251e				ld de, (cli_origptr) 
251e				ld a, display_row_1 
251e				call str_at_display 
251e				 
251e				ld de, .enddict 
251e				ld a, display_row_3 
251e				call str_at_display 
251e				call update_display 
251e				ld a, 100 
251e				call aDelayInMS 
251e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
251e				call delay1s 
251e				call delay1s 
251e				call delay1s 
251e				endif 
251e			.ispskip:  
251e				 
251e			endif	 
251e			 
251e			 
251e			 
251e				; if the word is not a keyword then must be a literal so push it to stack 
251e			 
251e			; push token to stack to end of word 
251e			 
251e				STACKFRAME ON $1efe $2f9f 
251e				if DEBUG_STACK_IMB 
251e					if ON 
251e						exx 
251e						ld de, $1efe 
251e						ld a, d 
251e						ld hl, curframe 
251e						call hexout 
251e						ld a, e 
251e						ld hl, curframe+2 
251e						call hexout 
251e						ld hl, $1efe 
251e						push hl 
251e						ld hl, $2f9f 
251e						push hl 
251e						exx 
251e					endif 
251e				endif 
251e			endm 
# End of macro STACKFRAME
251e			 
251e 2a c9 f4		ld hl,(os_tok_ptr) 
2521 cd d2 21		call forth_apush 
2524			 
2524				STACKFRAMECHK ON $1efe $2f9f 
2524				if DEBUG_STACK_IMB 
2524					if ON 
2524						exx 
2524						ld hl, $2f9f 
2524						pop de   ; $2f9f 
2524						call cmp16 
2524						jr nz, .spnosame 
2524						ld hl, $1efe 
2524						pop de   ; $1efe 
2524						call cmp16 
2524						jr z, .spfrsame 
2524						.spnosame: call showsperror 
2524						.spfrsame: nop 
2524						exx 
2524					endif 
2524				endif 
2524			endm 
# End of macro STACKFRAMECHK
2524			 
2524			execnext: 
2524			 
2524			if DEBUG_FORTH_PARSE_KEY 
2524						DMARK "KY>" 
2524			endif 
2524			; move past token to next word 
2524			 
2524 2a c9 f4		ld hl, (os_tok_ptr) 
2527 3e 00		ld a, 0 
2529 01 ff 00		ld bc, 255     ; input buffer size 
252c ed b1		cpir 
252e			 
252e			if DEBUG_FORTH_PARSE_KEY 
252e						DMARK "KY!" 
252e				CALLMONITOR 
252e			endif	 
252e			; TODO this might place hl on the null, so will need to forward on??? 
252e			;inc hl   ; see if this gets onto the next item 
252e			 
252e			 
252e			; TODO pass a pointer to the buffer to push 
252e			; TODO call function to push 
252e			 
252e			; look for end of input 
252e			 
252e			;inc hl 
252e			;ld a,(hl) 
252e			;cp FORTH_END_BUFFER 
252e			;ret z 
252e			 
252e			 
252e c3 a7 24		jp exec1 
2531			 
2531			 
2531			 
2531			 
2531			 
2531			 
2531			 
2531			 
2531			 
2531			findnexttok: 
2531			 
2531				; hl is pointer to move 
2531				; de is the token to locate 
2531			 
2531					if DEBUG_FORTH 
2531						DMARK "NTK" 
2531						CALLMONITOR 
2531					endif 
2531 d5				push de 
2532			 
2532			.fnt1:	 
2532				; find first char of token to locate 
2532			 
2532 1a				ld a, (de) 
2533 4f				ld c,a 
2534 7e				ld a,(hl) 
2535 cd a1 13			call toUpper 
2538					if DEBUG_FORTH 
2538						DMARK "NT1" 
2538						CALLMONITOR 
2538					endif 
2538 b9				cp c 
2539			 
2539 28 03			jr z, .fnt2cmpmorefirst	 
253b			 
253b				; first char not found move to next char 
253b			 
253b 23				inc hl 
253c 18 f4			jr .fnt1 
253e			 
253e			.fnt2cmpmorefirst:	 
253e				; first char of token found.  
253e			 
253e e5				push hl     ; save start of token just in case it is the right one 
253f d9				exx 
2540 e1				pop hl        ; save it to hl' 
2541 d9				exx 
2542			 
2542			 
2542			.fnt2cmpmore:	 
2542				; compare the rest 
2542				 
2542 23				inc hl 
2543 13				inc de 
2544				 
2544 1a				ld a, (de) 
2545 4f				ld c,a 
2546 7e				ld a,(hl) 
2547 cd a1 13			call toUpper 
254a			 
254a					if DEBUG_FORTH 
254a						DMARK "NT2" 
254a						CALLMONITOR 
254a					endif 
254a				; c has the token to find char 
254a				; a has the mem to scan char 
254a			 
254a b9				cp c 
254b 28 04			jr z,.fntmatch1 
254d			 
254d				; they are not the same 
254d			 
254d					if DEBUG_FORTH 
254d						DMARK "NT3" 
254d						CALLMONITOR 
254d					endif 
254d d1				pop de	; reset de token to look for 
254e d5				push de 
254f 18 e1			jr .fnt1 
2551				 
2551			.fntmatch1: 
2551			 
2551				; is the same char a null which means we might have a full hit? 
2551					if DEBUG_FORTH 
2551						DMARK "NT4" 
2551						CALLMONITOR 
2551					endif 
2551			 
2551 fe 00			cp 0 
2553 28 0b			jr z, .fntmatchyes 
2555			 
2555				; are we at the end of the token to find? 
2555			 
2555					if DEBUG_FORTH 
2555						DMARK "NT5" 
2555						CALLMONITOR 
2555					endif 
2555 3e 00			ld a, 0 
2557 b9				cp c 
2558			 
2558 c2 42 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
255b			 
255b					if DEBUG_FORTH 
255b						DMARK "NT6" 
255b						CALLMONITOR 
255b					endif 
255b				; token to find is exhusted but no match to stream 
255b			 
255b				; restore tok pointer and continue on 
255b d1				pop de 
255c d5				push de 
255d c3 32 25			jp .fnt1 
2560			 
2560			 
2560			.fntmatchyes: 
2560			 
2560				; hl now contains the end of the found token 
2560			 
2560				; get rid of saved token pointer to find 
2560			 
2560 d1				pop de 
2561			 
2561					if DEBUG_FORTH 
2561						DMARK "NT9" 
2561						CALLMONITOR 
2561					endif 
2561			 
2561				; hl will be on the null term so forward on 
2561			 
2561				; get back the saved start of the token 
2561			 
2561 d9				exx 
2562 e5				push hl     ; save start of token just in case it is the right one 
2563 d9				exx 
2564 e1				pop hl        ; save it to hl 
2565			 
2565 c9				ret 
2566			 
2566			 
2566			; LIST needs to find a specific token   
2566			; FORGET needs to find a spefici token 
2566			 
2566			; SAVE needs to find all tokens by flag 
2566			; WORDS just needs to scan through all  by flag 
2566			; UWORDS needs to scan through all by flag 
2566			 
2566			 
2566			; given hl as pointer to start of dict look up string 
2566			; return hl as pointer to start of word block 
2566			; or 0 if not found 
2566			 
2566			forth_find_tok: 
2566 c9				ret 
2567			 
2567			; given hl as pointer to dict structure 
2567			; move to the next dict block structure 
2567			 
2567			forth_tok_next: 
2567				; hl now points to the address of the next word pointer  
2567				; TODO skip compiled symbol for now 
2567			;	push de 
2567 23				inc hl 
2568 5e				ld e, (hl) 
2569 23				inc hl 
256a 56				ld d, (hl) 
256b 23				inc hl 
256c			 
256c eb				ex de,hl 
256d			if DEBUG_FORTH_PARSE_NEXTWORD 
256d				push bc 
256d				ld bc, (cli_nextword) 
256d						DMARK "NXW" 
256d				CALLMONITOR 
256d				pop bc 
256d			endif 
256d			;	pop de	 
256d c9				ret 
256e			 
256e			 
256e			 
256e			; eof 
# End of file forth_parserv5.asm
256e				include "forth_wordsv4.asm" 
256e			 
256e			; the core word dictionary v4 
256e			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
256e			 
256e			; this is a linked list for each of the system words used 
256e			; user defined words will follow the same format but will be in ram 
256e			 
256e			 
256e			; 
256e			; 
256e			; define linked list: 
256e			; 
256e			; 1. compiled byte op code 
256e			; 2. len of text word 
256e			; 3. text word 
256e			; 4. ptr to next dictionary word 
256e			; 5. asm, calls etc for the word 
256e			; 
256e			;  if 1 == 0 then last word in dict  
256e			;   
256e			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
256e			;  
256e			;  
256e			; create basic standard set of words 
256e			; 
256e			;  
256e			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
256e			; 2DUP 2DROP 2SWAP  
256e			; @ C@ - get byte  
256e			; ! C! - store byte 
256e			; 0< true if less than zero 
256e			; 0= true if zero 
256e			; < >  
256e			; = true if same 
256e			; variables 
256e			 
256e			 
256e			; Hardware specific words I may need 
256e			; 
256e			; IN OUT  
256e			; calls to key util functions 
256e			; calls to hardward abstraction stuff 
256e			; easy control of frame buffers and lcd i/o 
256e			; keyboard  
256e			 
256e			 
256e			;DICT: macro 
256e			; op_code, len, word, next 
256e			;    word: 
256e			;    db op_code 
256e			;    ds word zero term 
256e			;    dw next 
256e			;    endm 
256e			 
256e			 
256e			 
256e			 
256e			; op code 1 is a flag for user define words which are to be handled differently 
256e			 
256e			 
256e			; 
256e			; 
256e			;    TODO on entry to a word this should be the expected environment 
256e			;    hl - tos value if number then held, if string this is the ptr 
256e			;    de -  
256e			 
256e			 
256e			; opcode ranges 
256e			; 0 - end of word dict 
256e			; 255 - user define words 
256e			 
256e			sysdict: 
256e			include "forth_opcodes.asm" 
256e			; op codes for forth keywords 
256e			; free to use code 0  
256e				OPCODE_HEAP: equ  1 
256e				OPCODE_EXEC: equ 2 
256e				OPCODE_DUP: equ 3 
256e				OPCODE_SWAP: equ 4 
256e				OPCODE_COLN: equ 5 
256e				OPCODE_SCOLN: equ 6 
256e				OPCODE_DROP: equ 7 
256e				OPCODE_DUP2: equ 8 
256e				OPCODE_DROP2: equ 9 
256e				OPCODE_SWAP2: equ 10 
256e				OPCODE_AT: equ 11 
256e				OPCODE_CAT: equ 12 
256e				OPCODE_BANG: equ 13 
256e				OPCODE_CBANG: equ 14 
256e				OPCODE_SCALL: equ 15 
256e				OPCODE_DEPTH: equ 16 
256e				OPCODE_OVER: equ 17 
256e				OPCODE_PAUSE: equ 18 
256e				OPCODE_PAUSES: equ 19 
256e				OPCODE_ROT: equ 20 
256e			;free to reuse	OPCODE_WORDS: equ 21 
256e			        OPCODE_NOT: equ 21 
256e				OPCODE_UWORDS: equ 22 
256e				OPCODE_BP: equ 23 
256e				OPCODE_MONITOR: equ 24  
256e				OPCODE_MALLOC: equ 25 
256e				OPCODE_FREE: equ 26 
256e				OPCODE_LIST: equ 27 
256e				OPCODE_FORGET: equ 28 
256e				OPCODE_NOP: equ 29 
256e				OPCODE_COMO: equ 30 
256e				OPCODE_COMC: equ 31 
256e			;free to reuse	OPCODE_ENDCORE: equ 32 
256e				OPCODE_AFTERSOUND: equ 33 
256e				OPCODE_GP2: equ 34 
256e				OPCODE_GP3: equ 35 
256e				OPCODE_GP4: equ 36 
256e				OPCODE_SIN: equ 37 
256e				OPCODE_SOUT: equ 38 
256e				OPCODE_SPIO: equ 39 
256e				OPCODE_SPICEH: equ 40 
256e				OPCODE_SPIOb: equ 41 
256e				OPCODE_SPII: equ 42 
256e				OPCODE_SESEL: equ 43 
256e				OPCODE_CARTDEV: equ 44 
256e			; free to reuse	OPCODE_ENDDEVICE: equ 45 
256e				OPCODE_FB: equ 46 
256e				OPCODE_EMIT: equ 47 
256e				OPCODE_DOTH: equ 48 
256e				OPCODE_DOTF: equ 49 
256e				OPCODE_DOT: equ 50 
256e				OPCODE_CLS: equ 51 
256e				OPCODE_DRAW: equ 52 
256e				OPCODE_DUMP: equ 53 
256e				OPCODE_CDUMP: equ 54 
256e				OPCODE_DAT: equ 55 
256e				OPCODE_HOME: equ 56 
256e				OPCODE_SPACE: equ 57 
256e				OPCODE_SPACES: equ 58 
256e				OPCODE_SCROLL: equ 59 
256e				OPCODE_ATQ: equ 60 
256e				OPCODE_AUTODSP: equ 61 
256e				OPCODE_MENU: equ 62 
256e			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
256e				OPCODE_THEN: equ 64 
256e				OPCODE_ELSE: equ 65 
256e				OPCODE_DO: equ 66 
256e				OPCODE_LOOP: equ 67 
256e				OPCODE_I: equ 68 
256e				OPCODE_DLOOP: equ 69  
256e				OPCODE_REPEAT: equ 70  
256e				OPCODE_UNTIL: equ 71 
256e				OPCODE_ENDFLOW: equ 72 
256e				OPCODE_WAITK: equ 73 
256e				OPCODE_ACCEPT: equ 74 
256e				OPCODE_EDIT: equ 75 
256e			;free to reuse	OPCODE_ENDKEY: equ 76 
256e				OPCODE_LZERO: equ 77 
256e				OPCODE_TZERO: equ 78 
256e				OPCODE_LESS: equ 79 
256e				OPCODE_GT: equ 80 
256e				OPCODE_EQUAL: equ 81  
256e			;free to reuse	OPCODE_ENDLOGIC: equ 82 
256e				OPCODE_NEG: equ 83 
256e				OPCODE_DIV: equ 84 
256e				OPCODE_MUL: equ 85 
256e				OPCODE_MIN: equ 86 
256e				OPCODE_MAX: equ 87 
256e				OPCODE_RND16: equ 88 
256e				OPCODE_RND8: equ 89 
256e				OPCODE_RND: equ 90 
256e			;free to reuse	OPCODE_ENDMATHS: equ 91  
256e				OPCODE_BYNAME: equ 92 
256e				OPCODE_DIR: equ 93 
256e				OPCODE_SAVE: equ 94 
256e				OPCODE_LOAD: equ 95 
256e				OPCODE_BSAVE: equ 96 
256e				OPCODE_BLOAD: equ 97 
256e				OPCODE_SEO: equ 98  
256e				OPCODE_SEI: equ 99 
256e				OPCODE_SFREE: equ 100 
256e				OPCODE_SIZE: equ 101 
256e				OPCODE_CREATE: equ 102 
256e				OPCODE_APPEND: equ 103 
256e				OPCODE_SDEL: equ 104 
256e				OPCODE_OPEN: equ 105 
256e				OPCODE_READ: equ 106 
256e				OPCODE_EOF: equ 106 
256e				OPCODE_FORMAT: equ 107 
256e				OPCODE_LABEL: equ 108 
256e				OPCODE_LABELS: equ 109 
256e			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
256e				OPCODE_UPPER: equ 111 
256e				OPCODE_LOWER: equ 112 
256e				OPCODE_SUBSTR: equ 113 
256e				OPCODE_LEFT: equ 114 
256e				OPCODE_RIGHT: equ 115 
256e				OPCODE_STR2NUM: equ 116 
256e				OPCODE_NUM2STR: equ 117 
256e				OPCODE_CONCAT: equ 118 
256e				OPCODE_FIND: equ 119 
256e				OPCODE_LEN: equ 120 
256e				OPCODE_CHAR: equ 121 
256e			; free to reuse	OPCODE_STRLEN: equ 122 
256e			; free to reuse	OPCODE_ENDSTR: equ 123 
256e				OPCODE_V0S: equ 124 
256e				OPCODE_V0Q: equ 125 
256e				OPCODE_V1S: equ 126 
256e				OPCODE_V1Q: equ 127 
256e				OPCODE_V2S: equ 128 
256e				OPCODE_V2Q: equ 129 
256e				OPCODE_V3S: equ 130 
256e				OPCODE_V3Q: equ 131 
256e			;free to reuse	OPCODE_END: equ 132 
256e				OPCODE_ZDUP: equ 133 
256e			 
256e			; eof 
# End of file forth_opcodes.asm
256e			 
256e			include "forth_words_core.asm" 
256e			 
256e			; | ## Core Words 
256e			 
256e			;if MALLOC_4 
256e			 
256e			.HEAP: 
256e				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
256e 15				db WORD_SYS_CORE+OPCODE_HEAP             
256f ad 25			dw .EXEC            
2571 05				db 4 + 1 
2572 .. 00			db "HEAP",0              
2577				endm 
# End of macro CWHEAD
2577			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2577			; | | u1 - Current number of bytes in the heap 
2577			; | | u2 - Remaining bytes left on the heap 
2577			; | |  
2577			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2577			 
2577			 
2577					if DEBUG_FORTH_WORDS_KEY 
2577						DMARK "HEP" 
2577 f5				push af  
2578 3a 8c 25			ld a, (.dmark)  
257b 32 6e fe			ld (debug_mark),a  
257e 3a 8d 25			ld a, (.dmark+1)  
2581 32 6f fe			ld (debug_mark+1),a  
2584 3a 8e 25			ld a, (.dmark+2)  
2587 32 70 fe			ld (debug_mark+2),a  
258a 18 03			jr .pastdmark  
258c ..			.dmark: db "HEP"  
258f f1			.pastdmark: pop af  
2590			endm  
# End of macro DMARK
2590						CALLMONITOR 
2590 cd 9e 19			call break_point_state  
2593				endm  
# End of macro CALLMONITOR
2593					endif 
2593 2a 0a 80				ld hl, (free_list )      
2596 11 0e 80				ld de, heap_start 
2599			 
2599 ed 52				sbc hl, de  
259b			 
259b cd 69 20				call forth_push_numhl 
259e			 
259e			 
259e ed 5b 0a 80			ld de, (free_list )      
25a2 21 ae f1				ld hl, heap_end 
25a5			 
25a5 ed 52				sbc hl, de 
25a7			 
25a7 cd 69 20				call forth_push_numhl 
25aa					 
25aa			 
25aa					 
25aa			 
25aa			 
25aa			 
25aa					NEXTW 
25aa c3 16 24			jp macro_next 
25ad				endm 
# End of macro NEXTW
25ad			;endif 
25ad			 
25ad			.EXEC: 
25ad			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
25ad			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
25ad			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
25ad			;; > > 
25ad			;; > >   
25ad			;	STACKFRAME OFF $5efe $5f9f 
25ad			; 
25ad			;		if DEBUG_FORTH_WORDS_KEY 
25ad			;			DMARK "EXE" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			; 
25ad			;	FORTH_DSP_VALUEHL 
25ad			; 
25ad			;	FORTH_DSP_POP 
25ad			; 
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EX1" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			;;	ld e,(hl) 
25ad			;;	inc hl 
25ad			;;	ld d,(hl) 
25ad			;;	ex de,hl 
25ad			; 
25ad			;;		if DEBUG_FORTH_WORDS 
25ad			;;			DMARK "EX2" 
25ad			;;			CALLMONITOR 
25ad			;;		endif 
25ad			;	push hl 
25ad			; 
25ad			;	;ld a, 0 
25ad			;	;ld a, FORTH_END_BUFFER 
25ad			;	call strlenz 
25ad			;	inc hl   ; include zero term to copy 
25ad			;	inc hl   ; include term 
25ad			;	inc hl   ; include term 
25ad			;	ld b,0 
25ad			;	ld c,l 
25ad			;	pop hl 
25ad			;	ld de, execscratch 
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EX3" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			;	ldir 
25ad			; 
25ad			; 
25ad			;	ld hl, execscratch 
25ad			; 
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EXe" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			; 
25ad			;	call forthparse 
25ad			;	call forthexec 
25ad			;;	call forthexec_cleanup 
25ad			;;	call forthparse 
25ad			;;	call forthexec 
25ad			; 
25ad			;	STACKFRAMECHK OFF $5efe $5f9f 
25ad			; 
25ad			;	; an immediate word so no need to process any more words 
25ad			;	ret 
25ad			;	NEXTW 
25ad			 
25ad			; dead code - old version  
25ad			;	FORTH_RSP_NEXT 
25ad			 
25ad			;  
25ad			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
25ad			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
25ad			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
25ad			;	push hl 
25ad			;	push de 
25ad			;	push bc 
25ad			; 
25ad			; 
25ad			;		if DEBUG_FORTH_WORDS_KEY 
25ad			;			DMARK "EXR" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			; 
25ad			; 
25ad			; 
25ad			;	;v5 FORTH_DSP_VALUE 
25ad			;	FORTH_DSP_VALUEHL 
25ad			; 
25ad			;	; TODO do string type checks 
25ad			; 
25ad			;;v5	inc hl   ; skip type 
25ad			; 
25ad			;	push hl  ; source code  
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EX1" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			;	ld a, 0 
25ad			;	call strlent 
25ad			; 
25ad			;	inc hl 
25ad			;	inc hl 
25ad			;	inc hl 
25ad			;	inc hl 
25ad			; 
25ad			;	push hl    ; size 
25ad			; 
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EX2" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			;	call malloc 
25ad			; 
25ad			;	ex de, hl    ; de now contains malloc area 
25ad			;	pop bc   	; get byte count 
25ad			;	pop hl      ; get string to copy 
25ad			; 
25ad			;	push de     ; save malloc for free later 
25ad			; 
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EX3" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			;	ldir       ; duplicate string 
25ad			; 
25ad			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
25ad			;	 
25ad			;	; TODO fix the parse would be better than this...  
25ad			;	ex de, hl 
25ad			;	dec hl 
25ad			;	ld a, 0 
25ad			;	ld (hl), a 
25ad			;	dec hl 
25ad			;	ld a, ' ' 
25ad			;	ld (hl), a 
25ad			;	dec hl 
25ad			;	ld (hl), a 
25ad			; 
25ad			;	dec hl 
25ad			;	ld (hl), a 
25ad			; 
25ad			; 
25ad			;	FORTH_DSP_POP  
25ad			; 
25ad			;	pop hl     
25ad			;	push hl    ; save malloc area 
25ad			; 
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EX4" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			; 
25ad			;	call forthparse 
25ad			;	call forthexec 
25ad			;	 
25ad			;	pop hl 
25ad			;	if DEBUG_FORTH_WORDS 
25ad			;		DMARK "EX5" 
25ad			;		CALLMONITOR 
25ad			;	endif 
25ad			; 
25ad			;	if FORTH_ENABLE_FREE 
25ad			;	call free 
25ad			;	endif 
25ad			; 
25ad			;	if DEBUG_FORTH_WORDS 
25ad			;		DMARK "EX6" 
25ad			;		CALLMONITOR 
25ad			;	endif 
25ad			; 
25ad			;	pop bc 
25ad			;	pop de 
25ad			;	pop hl 
25ad			;;	FORTH_RSP_POP	  
25ad			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
25ad			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
25ad			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
25ad			; 
25ad			;	if DEBUG_FORTH_WORDS 
25ad			;		DMARK "EX7" 
25ad			;		CALLMONITOR 
25ad			;	endif 
25ad			;	NEXTW 
25ad			 
25ad			;.STKEXEC: 
25ad			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
25ad			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
25ad			; 
25ad			; 
25ad			;		if DEBUG_FORTH_WORDS_KEY 
25ad			;			DMARK "STX" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			; 
25ad			;	FORTH_DSP_VALUEHL 
25ad			; 
25ad			;	ld (store_tmp1), hl    ; count 
25ad			; 
25ad			;	FORTH_DSP_POP 
25ad			;.stkexec1: 
25ad			;	ld hl, (store_tmp1)   ; count 
25ad			;	ld a, 0 
25ad			;	cp l 
25ad			;	ret z 
25ad			; 
25ad			;	dec hl 
25ad			;	ld (store_tmp1), hl    ; count 
25ad			;	 
25ad			;	FORTH_DSP_VALUEHL 
25ad			;	push hl 
25ad			;	 
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EXp" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			;	FORTH_DSP_POP 
25ad			; 
25ad			;	call strlenz 
25ad			;	inc hl   ; include zero term to copy 
25ad			;	inc hl   ; include zero term to copy 
25ad			;	inc hl   ; include zero term to copy 
25ad			;	ld b,0 
25ad			;	ld c,l 
25ad			;	pop hl 
25ad			;	ld de, execscratch 
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EX3" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			;	ldir 
25ad			; 
25ad			; 
25ad			;	ld hl, execscratch 
25ad			; 
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EXP" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			; 
25ad			;	call forthparse 
25ad			;	ld hl, execscratch 
25ad			;		if DEBUG_FORTH_WORDS 
25ad			;			DMARK "EXx" 
25ad			;			CALLMONITOR 
25ad			;		endif 
25ad			;	call forthexec 
25ad			; 
25ad			;	jp .stkexec1 
25ad			; 
25ad			;	ret 
25ad			 
25ad			 
25ad			.DUP: 
25ad				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
25ad 17				db WORD_SYS_CORE+OPCODE_DUP             
25ae 23 26			dw .ZDUP            
25b0 04				db 3 + 1 
25b1 .. 00			db "DUP",0              
25b5				endm 
# End of macro CWHEAD
25b5			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
25b5			 
25b5					if DEBUG_FORTH_WORDS_KEY 
25b5						DMARK "DUP" 
25b5 f5				push af  
25b6 3a ca 25			ld a, (.dmark)  
25b9 32 6e fe			ld (debug_mark),a  
25bc 3a cb 25			ld a, (.dmark+1)  
25bf 32 6f fe			ld (debug_mark+1),a  
25c2 3a cc 25			ld a, (.dmark+2)  
25c5 32 70 fe			ld (debug_mark+2),a  
25c8 18 03			jr .pastdmark  
25ca ..			.dmark: db "DUP"  
25cd f1			.pastdmark: pop af  
25ce			endm  
# End of macro DMARK
25ce						CALLMONITOR 
25ce cd 9e 19			call break_point_state  
25d1				endm  
# End of macro CALLMONITOR
25d1					endif 
25d1			 
25d1					FORTH_DSP 
25d1 cd 26 22			call macro_forth_dsp 
25d4				endm 
# End of macro FORTH_DSP
25d4			 
25d4 7e					ld a, (HL) 
25d5 fe 01				cp DS_TYPE_STR 
25d7 20 25				jr nz, .dupinum 
25d9			 
25d9					; push another string 
25d9			 
25d9					FORTH_DSP_VALUEHL     		 
25d9 cd 60 22			call macro_dsp_valuehl 
25dc				endm 
# End of macro FORTH_DSP_VALUEHL
25dc			 
25dc				if DEBUG_FORTH_WORDS 
25dc					DMARK "DUs" 
25dc f5				push af  
25dd 3a f1 25			ld a, (.dmark)  
25e0 32 6e fe			ld (debug_mark),a  
25e3 3a f2 25			ld a, (.dmark+1)  
25e6 32 6f fe			ld (debug_mark+1),a  
25e9 3a f3 25			ld a, (.dmark+2)  
25ec 32 70 fe			ld (debug_mark+2),a  
25ef 18 03			jr .pastdmark  
25f1 ..			.dmark: db "DUs"  
25f4 f1			.pastdmark: pop af  
25f5			endm  
# End of macro DMARK
25f5					CALLMONITOR 
25f5 cd 9e 19			call break_point_state  
25f8				endm  
# End of macro CALLMONITOR
25f8				endif 
25f8 cd d7 20				call forth_push_str 
25fb			 
25fb					NEXTW 
25fb c3 16 24			jp macro_next 
25fe				endm 
# End of macro NEXTW
25fe			 
25fe			 
25fe			.dupinum: 
25fe					 
25fe			 
25fe			 
25fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25fe cd 60 22			call macro_dsp_valuehl 
2601				endm 
# End of macro FORTH_DSP_VALUEHL
2601			 
2601				; TODO add floating point number detection 
2601			 
2601				if DEBUG_FORTH_WORDS 
2601					DMARK "DUi" 
2601 f5				push af  
2602 3a 16 26			ld a, (.dmark)  
2605 32 6e fe			ld (debug_mark),a  
2608 3a 17 26			ld a, (.dmark+1)  
260b 32 6f fe			ld (debug_mark+1),a  
260e 3a 18 26			ld a, (.dmark+2)  
2611 32 70 fe			ld (debug_mark+2),a  
2614 18 03			jr .pastdmark  
2616 ..			.dmark: db "DUi"  
2619 f1			.pastdmark: pop af  
261a			endm  
# End of macro DMARK
261a					CALLMONITOR 
261a cd 9e 19			call break_point_state  
261d				endm  
# End of macro CALLMONITOR
261d				endif 
261d			 
261d cd 69 20				call forth_push_numhl 
2620					NEXTW 
2620 c3 16 24			jp macro_next 
2623				endm 
# End of macro NEXTW
2623			.ZDUP: 
2623				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2623 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2624 5b 26			dw .SWAP            
2626 05				db 4 + 1 
2627 .. 00			db "?DUP",0              
262c				endm 
# End of macro CWHEAD
262c			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
262c			 
262c					if DEBUG_FORTH_WORDS_KEY 
262c						DMARK "qDU" 
262c f5				push af  
262d 3a 41 26			ld a, (.dmark)  
2630 32 6e fe			ld (debug_mark),a  
2633 3a 42 26			ld a, (.dmark+1)  
2636 32 6f fe			ld (debug_mark+1),a  
2639 3a 43 26			ld a, (.dmark+2)  
263c 32 70 fe			ld (debug_mark+2),a  
263f 18 03			jr .pastdmark  
2641 ..			.dmark: db "qDU"  
2644 f1			.pastdmark: pop af  
2645			endm  
# End of macro DMARK
2645						CALLMONITOR 
2645 cd 9e 19			call break_point_state  
2648				endm  
# End of macro CALLMONITOR
2648					endif 
2648					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2648 cd 60 22			call macro_dsp_valuehl 
264b				endm 
# End of macro FORTH_DSP_VALUEHL
264b			 
264b e5					push hl 
264c			 
264c					; is it a zero? 
264c			 
264c 3e 00				ld a, 0 
264e 84					add h 
264f 85					add l 
2650			 
2650 e1					pop hl 
2651			 
2651 fe 00				cp 0 
2653 28 03				jr z, .dup2orig 
2655			 
2655			 
2655 cd 69 20				call forth_push_numhl 
2658			 
2658			 
2658				; TODO add floating point number detection 
2658			 
2658			.dup2orig: 
2658			 
2658					NEXTW 
2658 c3 16 24			jp macro_next 
265b				endm 
# End of macro NEXTW
265b			.SWAP: 
265b				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
265b 18				db WORD_SYS_CORE+OPCODE_SWAP             
265c 9a 26			dw .COLN            
265e 05				db 4 + 1 
265f .. 00			db "SWAP",0              
2664				endm 
# End of macro CWHEAD
2664			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2664					if DEBUG_FORTH_WORDS_KEY 
2664						DMARK "SWP" 
2664 f5				push af  
2665 3a 79 26			ld a, (.dmark)  
2668 32 6e fe			ld (debug_mark),a  
266b 3a 7a 26			ld a, (.dmark+1)  
266e 32 6f fe			ld (debug_mark+1),a  
2671 3a 7b 26			ld a, (.dmark+2)  
2674 32 70 fe			ld (debug_mark+2),a  
2677 18 03			jr .pastdmark  
2679 ..			.dmark: db "SWP"  
267c f1			.pastdmark: pop af  
267d			endm  
# End of macro DMARK
267d						CALLMONITOR 
267d cd 9e 19			call break_point_state  
2680				endm  
# End of macro CALLMONITOR
2680					endif 
2680			 
2680					FORTH_DSP_VALUEHL 
2680 cd 60 22			call macro_dsp_valuehl 
2683				endm 
# End of macro FORTH_DSP_VALUEHL
2683 e5					push hl     ; w2 
2684			 
2684					FORTH_DSP_POP 
2684 cd 18 23			call macro_forth_dsp_pop 
2687				endm 
# End of macro FORTH_DSP_POP
2687			 
2687					FORTH_DSP_VALUEHL 
2687 cd 60 22			call macro_dsp_valuehl 
268a				endm 
# End of macro FORTH_DSP_VALUEHL
268a			 
268a					FORTH_DSP_POP 
268a cd 18 23			call macro_forth_dsp_pop 
268d				endm 
# End of macro FORTH_DSP_POP
268d			 
268d d1					pop de     ; w2	, hl = w1 
268e			 
268e eb					ex de, hl 
268f d5					push de 
2690			 
2690 cd 69 20				call forth_push_numhl 
2693			 
2693 e1					pop hl 
2694			 
2694 cd 69 20				call forth_push_numhl 
2697					 
2697			 
2697					NEXTW 
2697 c3 16 24			jp macro_next 
269a				endm 
# End of macro NEXTW
269a			.COLN: 
269a				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
269a 19				db WORD_SYS_CORE+OPCODE_COLN             
269b 26 28			dw .SCOLN            
269d 02				db 1 + 1 
269e .. 00			db ":",0              
26a0				endm 
# End of macro CWHEAD
26a0			; | : ( -- )         Create new word | DONE 
26a0			 
26a0					if DEBUG_FORTH_WORDS_KEY 
26a0						DMARK "CLN" 
26a0 f5				push af  
26a1 3a b5 26			ld a, (.dmark)  
26a4 32 6e fe			ld (debug_mark),a  
26a7 3a b6 26			ld a, (.dmark+1)  
26aa 32 6f fe			ld (debug_mark+1),a  
26ad 3a b7 26			ld a, (.dmark+2)  
26b0 32 70 fe			ld (debug_mark+2),a  
26b3 18 03			jr .pastdmark  
26b5 ..			.dmark: db "CLN"  
26b8 f1			.pastdmark: pop af  
26b9			endm  
# End of macro DMARK
26b9						CALLMONITOR 
26b9 cd 9e 19			call break_point_state  
26bc				endm  
# End of macro CALLMONITOR
26bc					endif 
26bc				STACKFRAME OFF $8efe $989f 
26bc				if DEBUG_STACK_IMB 
26bc					if OFF 
26bc						exx 
26bc						ld de, $8efe 
26bc						ld a, d 
26bc						ld hl, curframe 
26bc						call hexout 
26bc						ld a, e 
26bc						ld hl, curframe+2 
26bc						call hexout 
26bc						ld hl, $8efe 
26bc						push hl 
26bc						ld hl, $989f 
26bc						push hl 
26bc						exx 
26bc					endif 
26bc				endif 
26bc			endm 
# End of macro STACKFRAME
26bc				; get parser buffer length  of new word 
26bc			 
26bc				 
26bc			 
26bc					; move tok past this to start of name defintition 
26bc					; TODO get word to define 
26bc					; TODO Move past word token 
26bc					; TODO get length of string up to the ';' 
26bc			 
26bc 2a c9 f4			ld hl, (os_tok_ptr) 
26bf 23				inc hl 
26c0 23				inc hl 
26c1			 
26c1 3e 3b			ld a, ';' 
26c3 cd b5 13			call strlent 
26c6			 
26c6 7d				ld a,l 
26c7 32 c4 f1			ld (os_new_parse_len), a 
26ca			 
26ca			 
26ca			if DEBUG_FORTH_UWORD 
26ca ed 5b c9 f4		ld de, (os_tok_ptr) 
26ce						DMARK ":01" 
26ce f5				push af  
26cf 3a e3 26			ld a, (.dmark)  
26d2 32 6e fe			ld (debug_mark),a  
26d5 3a e4 26			ld a, (.dmark+1)  
26d8 32 6f fe			ld (debug_mark+1),a  
26db 3a e5 26			ld a, (.dmark+2)  
26de 32 70 fe			ld (debug_mark+2),a  
26e1 18 03			jr .pastdmark  
26e3 ..			.dmark: db ":01"  
26e6 f1			.pastdmark: pop af  
26e7			endm  
# End of macro DMARK
26e7				CALLMONITOR 
26e7 cd 9e 19			call break_point_state  
26ea				endm  
# End of macro CALLMONITOR
26ea			endif 
26ea			 
26ea			; 
26ea			;  new word memory layout: 
26ea			;  
26ea			;    : adg 6666 ;  
26ea			; 
26ea			;    db   1     ; user defined word  
26ea 23				inc hl    
26eb			;    dw   sysdict 
26eb 23				inc hl 
26ec 23				inc hl 
26ed			;    db <word len>+1 (for null) 
26ed 23				inc hl 
26ee			;    db .... <word> 
26ee			; 
26ee			 
26ee 23				inc hl    ; some extras for the word preamble before the above 
26ef 23				inc hl 
26f0 23				inc hl 
26f1 23				inc hl 
26f2 23				inc hl 
26f3 23				inc hl 
26f4 23				inc hl  
26f5 23				inc hl 
26f6 23				inc hl 
26f7 23				inc hl 
26f8 23				inc hl 
26f9 23				inc hl 
26fa 23				inc hl 
26fb 23				inc hl     ; TODO how many do we really need?     maybe only 6 
26fc			;       exec word buffer 
26fc			;	<ptr word>   
26fc 23				inc hl 
26fd 23				inc hl 
26fe			;       <word list><null term> 7F final term 
26fe			 
26fe			 
26fe			if DEBUG_FORTH_UWORD 
26fe						DMARK ":02" 
26fe f5				push af  
26ff 3a 13 27			ld a, (.dmark)  
2702 32 6e fe			ld (debug_mark),a  
2705 3a 14 27			ld a, (.dmark+1)  
2708 32 6f fe			ld (debug_mark+1),a  
270b 3a 15 27			ld a, (.dmark+2)  
270e 32 70 fe			ld (debug_mark+2),a  
2711 18 03			jr .pastdmark  
2713 ..			.dmark: db ":02"  
2716 f1			.pastdmark: pop af  
2717			endm  
# End of macro DMARK
2717				CALLMONITOR 
2717 cd 9e 19			call break_point_state  
271a				endm  
# End of macro CALLMONITOR
271a			endif 
271a			 
271a				 
271a					; malloc the size 
271a			 
271a cd 13 14				call malloc 
271d 22 c6 f1				ld (os_new_malloc), hl     ; save malloc start 
2720			 
2720			;    db   1     ; user defined word  
2720 3e 01				ld a, WORD_SYS_UWORD  
2722 77					ld (hl), a 
2723				 
2723 23				inc hl    
2724			;    dw   sysdict 
2724 11 6e 25			ld de, sysdict       ; continue on with the scan to the system dict 
2727 73				ld (hl), e 
2728 23				inc hl 
2729 72				ld (hl), d 
272a 23				inc hl 
272b			 
272b			 
272b			;    Setup dict word 
272b			 
272b 23				inc hl 
272c 22 c0 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
272f			 
272f				; 1. get length of dict word 
272f			 
272f			 
272f 2a c9 f4			ld hl, (os_tok_ptr) 
2732 23				inc hl 
2733 23				inc hl    ; position to start of dict word 
2734 3e 00			ld a, 0 
2736 cd b5 13			call strlent 
2739			 
2739			 
2739 23				inc hl    ; to include null??? 
273a			 
273a				; write length of dict word 
273a			 
273a ed 5b c0 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
273e 1b				dec de 
273f eb				ex de, hl 
2740 73				ld (hl), e 
2741 eb				ex de, hl 
2742			 
2742				 
2742			 
2742				; copy  
2742 4d				ld c, l 
2743 06 00			ld b, 0 
2745 ed 5b c0 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2749 2a c9 f4			ld hl, (os_tok_ptr) 
274c 23				inc hl 
274d 23				inc hl    ; position to start of dict word 
274e				 
274e			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
274e				 
274e				; TODO need to convert word to upper case 
274e			 
274e			ucasetok:	 
274e 7e				ld a,(hl) 
274f cd a1 13			call toUpper 
2752 77				ld (hl),a 
2753 ed a0			ldi 
2755 f2 4e 27		 	jp p, ucasetok 
2758			 
2758			 
2758			 
2758				; de now points to start of where the word body code should be placed 
2758 ed 53 c0 f1		ld (os_new_work_ptr), de 
275c				; hl now points to the words to throw at forthexec which needs to be copied 
275c 22 be f1			ld (os_new_src_ptr), hl 
275f			 
275f				; TODO add 'call to forthexec' 
275f			 
275f			if DEBUG_FORTH_UWORD 
275f c5				push bc 
2760 ed 4b c6 f1		ld bc, (os_new_malloc) 
2764						DMARK ":0x" 
2764 f5				push af  
2765 3a 79 27			ld a, (.dmark)  
2768 32 6e fe			ld (debug_mark),a  
276b 3a 7a 27			ld a, (.dmark+1)  
276e 32 6f fe			ld (debug_mark+1),a  
2771 3a 7b 27			ld a, (.dmark+2)  
2774 32 70 fe			ld (debug_mark+2),a  
2777 18 03			jr .pastdmark  
2779 ..			.dmark: db ":0x"  
277c f1			.pastdmark: pop af  
277d			endm  
# End of macro DMARK
277d				CALLMONITOR 
277d cd 9e 19			call break_point_state  
2780				endm  
# End of macro CALLMONITOR
2780 c1				pop bc 
2781			endif 
2781			 
2781			 
2781				; create word preamble which should be: 
2781			 
2781			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2781			 
2781				;    ld hl, <word code> 
2781				;    jp user_exec 
2781			        ;    <word code bytes> 
2781			 
2781			 
2781			;	inc de     ; TODO ??? or are we already past the word's null 
2781 eb				ex de, hl 
2782			 
2782 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2784			 
2784 23				inc hl 
2785 22 ba f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2788 23				inc hl 
2789			 
2789 23				inc hl 
278a 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
278c			 
278c 01 16 5c			ld bc, user_exec 
278f 23				inc hl 
2790 71				ld (hl), c     ; poke address of user_exec 
2791 23				inc hl 
2792 70				ld (hl), b     
2793			 ; 
2793			;	inc hl 
2793			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2793			; 
2793			; 
2793			;	ld bc, macro_forth_rsp_next 
2793			;	inc hl 
2793			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2793			;	inc hl 
2793			;	ld (hl), b     
2793			 ; 
2793			;	inc hl 
2793			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2793			; 
2793			; 
2793			;	inc hl 
2793			;	ld bc, forthexec 
2793			;	ld (hl), c     ; poke address of forthexec 
2793			;	inc hl 
2793			;	ld (hl), b      
2793			; 
2793			;	inc hl 
2793			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2793			; 
2793			;	ld bc, user_dict_next 
2793			;	inc hl 
2793			;	ld (hl), c     ; poke address of forthexec 
2793			;	inc hl 
2793			;	ld (hl), b      
2793			 
2793				; hl is now where we need to copy the word byte data to save this 
2793			 
2793 23				inc hl 
2794 22 bc f1			ld (os_new_exec), hl 
2797				 
2797				; copy definition 
2797			 
2797 eb				ex de, hl 
2798			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2798			;	inc de    ; skip the PC for this parse 
2798 3a c4 f1			ld a, (os_new_parse_len) 
279b 4f				ld c, a 
279c 06 00			ld b, 0 
279e ed b0			ldir		 ; copy defintion 
27a0			 
27a0			 
27a0				; poke the address of where the new word bytes live for forthexec 
27a0			 
27a0 2a ba f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
27a3			 
27a3 ed 5b bc f1		ld de, (os_new_exec)      
27a7				 
27a7 73				ld (hl), e 
27a8 23				inc hl 
27a9 72				ld (hl), d 
27aa			 
27aa					; TODO copy last user dict word next link to this word 
27aa					; TODO update last user dict word to point to this word 
27aa			; 
27aa			; hl f923 de 812a ; bc 811a 
27aa			 
27aa			if DEBUG_FORTH_UWORD 
27aa c5				push bc 
27ab ed 4b c6 f1		ld bc, (os_new_malloc) 
27af						DMARK ":0A" 
27af f5				push af  
27b0 3a c4 27			ld a, (.dmark)  
27b3 32 6e fe			ld (debug_mark),a  
27b6 3a c5 27			ld a, (.dmark+1)  
27b9 32 6f fe			ld (debug_mark+1),a  
27bc 3a c6 27			ld a, (.dmark+2)  
27bf 32 70 fe			ld (debug_mark+2),a  
27c2 18 03			jr .pastdmark  
27c4 ..			.dmark: db ":0A"  
27c7 f1			.pastdmark: pop af  
27c8			endm  
# End of macro DMARK
27c8				CALLMONITOR 
27c8 cd 9e 19			call break_point_state  
27cb				endm  
# End of macro CALLMONITOR
27cb c1				pop bc 
27cc			endif 
27cc			if DEBUG_FORTH_UWORD 
27cc c5				push bc 
27cd ed 4b c6 f1		ld bc, (os_new_malloc) 
27d1 03				inc bc 
27d2 03				inc bc 
27d3 03				inc bc 
27d4 03				inc bc 
27d5 03				inc bc 
27d6 03				inc bc 
27d7 03				inc bc 
27d8 03				inc bc 
27d9			 
27d9						DMARK ":0B" 
27d9 f5				push af  
27da 3a ee 27			ld a, (.dmark)  
27dd 32 6e fe			ld (debug_mark),a  
27e0 3a ef 27			ld a, (.dmark+1)  
27e3 32 6f fe			ld (debug_mark+1),a  
27e6 3a f0 27			ld a, (.dmark+2)  
27e9 32 70 fe			ld (debug_mark+2),a  
27ec 18 03			jr .pastdmark  
27ee ..			.dmark: db ":0B"  
27f1 f1			.pastdmark: pop af  
27f2			endm  
# End of macro DMARK
27f2				CALLMONITOR 
27f2 cd 9e 19			call break_point_state  
27f5				endm  
# End of macro CALLMONITOR
27f5 c1				pop bc 
27f6			endif 
27f6			 
27f6			; update word dict linked list for new word 
27f6			 
27f6			 
27f6 2a c5 f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
27f9 23			inc hl     ; move to next work linked list ptr 
27fa			 
27fa ed 5b c6 f1	ld de, (os_new_malloc)		 ; new next word 
27fe 73			ld (hl), e 
27ff 23			inc hl 
2800 72			ld (hl), d 
2801			 
2801			if DEBUG_FORTH_UWORD 
2801 ed 4b c5 f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2805			endif 
2805			 
2805 ed 53 c5 f4	ld (os_last_new_uword), de      ; update last new uword ptr 
2809			 
2809			 
2809			if DEBUG_FORTH_UWORD 
2809						DMARK ":0+" 
2809 f5				push af  
280a 3a 1e 28			ld a, (.dmark)  
280d 32 6e fe			ld (debug_mark),a  
2810 3a 1f 28			ld a, (.dmark+1)  
2813 32 6f fe			ld (debug_mark+1),a  
2816 3a 20 28			ld a, (.dmark+2)  
2819 32 70 fe			ld (debug_mark+2),a  
281c 18 03			jr .pastdmark  
281e ..			.dmark: db ":0+"  
2821 f1			.pastdmark: pop af  
2822			endm  
# End of macro DMARK
2822				CALLMONITOR 
2822 cd 9e 19			call break_point_state  
2825				endm  
# End of macro CALLMONITOR
2825			endif 
2825			 
2825				STACKFRAMECHK OFF $8efe $989f 
2825				if DEBUG_STACK_IMB 
2825					if OFF 
2825						exx 
2825						ld hl, $989f 
2825						pop de   ; $989f 
2825						call cmp16 
2825						jr nz, .spnosame 
2825						ld hl, $8efe 
2825						pop de   ; $8efe 
2825						call cmp16 
2825						jr z, .spfrsame 
2825						.spnosame: call showsperror 
2825						.spfrsame: nop 
2825						exx 
2825					endif 
2825				endif 
2825			endm 
# End of macro STACKFRAMECHK
2825			 
2825 c9			ret    ; dont process any remaining parser tokens as they form new word 
2826			 
2826			 
2826			 
2826			 
2826			;		NEXT 
2826			.SCOLN: 
2826			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2826 06				db OPCODE_SCOLN 
2827 72 28			dw .DROP 
2829 02				db 2 
282a .. 00			db ";",0           
282c			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
282c					if DEBUG_FORTH_WORDS_KEY 
282c						DMARK "SCN" 
282c f5				push af  
282d 3a 41 28			ld a, (.dmark)  
2830 32 6e fe			ld (debug_mark),a  
2833 3a 42 28			ld a, (.dmark+1)  
2836 32 6f fe			ld (debug_mark+1),a  
2839 3a 43 28			ld a, (.dmark+2)  
283c 32 70 fe			ld (debug_mark+2),a  
283f 18 03			jr .pastdmark  
2841 ..			.dmark: db "SCN"  
2844 f1			.pastdmark: pop af  
2845			endm  
# End of macro DMARK
2845						CALLMONITOR 
2845 cd 9e 19			call break_point_state  
2848				endm  
# End of macro CALLMONITOR
2848					endif 
2848					FORTH_RSP_TOS 
2848 cd 27 20			call macro_forth_rsp_tos 
284b				endm 
# End of macro FORTH_RSP_TOS
284b e5					push hl 
284c					FORTH_RSP_POP 
284c cd 31 20			call macro_forth_rsp_pop 
284f				endm 
# End of macro FORTH_RSP_POP
284f e1					pop hl 
2850			;		ex de,hl 
2850 22 c9 f4				ld (os_tok_ptr),hl 
2853			 
2853			if DEBUG_FORTH_UWORD 
2853						DMARK "SCL" 
2853 f5				push af  
2854 3a 68 28			ld a, (.dmark)  
2857 32 6e fe			ld (debug_mark),a  
285a 3a 69 28			ld a, (.dmark+1)  
285d 32 6f fe			ld (debug_mark+1),a  
2860 3a 6a 28			ld a, (.dmark+2)  
2863 32 70 fe			ld (debug_mark+2),a  
2866 18 03			jr .pastdmark  
2868 ..			.dmark: db "SCL"  
286b f1			.pastdmark: pop af  
286c			endm  
# End of macro DMARK
286c				CALLMONITOR 
286c cd 9e 19			call break_point_state  
286f				endm  
# End of macro CALLMONITOR
286f			endif 
286f					NEXTW 
286f c3 16 24			jp macro_next 
2872				endm 
# End of macro NEXTW
2872			 
2872			.DROP: 
2872				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2872 1b				db WORD_SYS_CORE+OPCODE_DROP             
2873 9d 28			dw .DUP2            
2875 05				db 4 + 1 
2876 .. 00			db "DROP",0              
287b				endm 
# End of macro CWHEAD
287b			; | DROP ( w -- )   drop the TOS item   | DONE 
287b					if DEBUG_FORTH_WORDS_KEY 
287b						DMARK "DRP" 
287b f5				push af  
287c 3a 90 28			ld a, (.dmark)  
287f 32 6e fe			ld (debug_mark),a  
2882 3a 91 28			ld a, (.dmark+1)  
2885 32 6f fe			ld (debug_mark+1),a  
2888 3a 92 28			ld a, (.dmark+2)  
288b 32 70 fe			ld (debug_mark+2),a  
288e 18 03			jr .pastdmark  
2890 ..			.dmark: db "DRP"  
2893 f1			.pastdmark: pop af  
2894			endm  
# End of macro DMARK
2894						CALLMONITOR 
2894 cd 9e 19			call break_point_state  
2897				endm  
# End of macro CALLMONITOR
2897					endif 
2897					FORTH_DSP_POP 
2897 cd 18 23			call macro_forth_dsp_pop 
289a				endm 
# End of macro FORTH_DSP_POP
289a					NEXTW 
289a c3 16 24			jp macro_next 
289d				endm 
# End of macro NEXTW
289d			.DUP2: 
289d				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
289d 1c				db WORD_SYS_CORE+OPCODE_DUP2             
289e e2 28			dw .DROP2            
28a0 05				db 4 + 1 
28a1 .. 00			db "2DUP",0              
28a6				endm 
# End of macro CWHEAD
28a6			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
28a6					if DEBUG_FORTH_WORDS_KEY 
28a6						DMARK "2DU" 
28a6 f5				push af  
28a7 3a bb 28			ld a, (.dmark)  
28aa 32 6e fe			ld (debug_mark),a  
28ad 3a bc 28			ld a, (.dmark+1)  
28b0 32 6f fe			ld (debug_mark+1),a  
28b3 3a bd 28			ld a, (.dmark+2)  
28b6 32 70 fe			ld (debug_mark+2),a  
28b9 18 03			jr .pastdmark  
28bb ..			.dmark: db "2DU"  
28be f1			.pastdmark: pop af  
28bf			endm  
# End of macro DMARK
28bf						CALLMONITOR 
28bf cd 9e 19			call break_point_state  
28c2				endm  
# End of macro CALLMONITOR
28c2					endif 
28c2					FORTH_DSP_VALUEHL 
28c2 cd 60 22			call macro_dsp_valuehl 
28c5				endm 
# End of macro FORTH_DSP_VALUEHL
28c5 e5					push hl      ; 2 
28c6			 
28c6					FORTH_DSP_POP 
28c6 cd 18 23			call macro_forth_dsp_pop 
28c9				endm 
# End of macro FORTH_DSP_POP
28c9					 
28c9					FORTH_DSP_VALUEHL 
28c9 cd 60 22			call macro_dsp_valuehl 
28cc				endm 
# End of macro FORTH_DSP_VALUEHL
28cc			;		push hl      ; 1 
28cc			 
28cc					FORTH_DSP_POP 
28cc cd 18 23			call macro_forth_dsp_pop 
28cf				endm 
# End of macro FORTH_DSP_POP
28cf			 
28cf			;		pop hl       ; 1 
28cf d1					pop de       ; 2 
28d0			 
28d0 cd 69 20				call forth_push_numhl 
28d3 eb					ex de, hl 
28d4 cd 69 20				call forth_push_numhl 
28d7			 
28d7					 
28d7 eb					ex de, hl 
28d8			 
28d8 cd 69 20				call forth_push_numhl 
28db eb					ex de, hl 
28dc cd 69 20				call forth_push_numhl 
28df			 
28df			 
28df					NEXTW 
28df c3 16 24			jp macro_next 
28e2				endm 
# End of macro NEXTW
28e2			.DROP2: 
28e2				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
28e2 1d				db WORD_SYS_CORE+OPCODE_DROP2             
28e3 11 29			dw .SWAP2            
28e5 06				db 5 + 1 
28e6 .. 00			db "2DROP",0              
28ec				endm 
# End of macro CWHEAD
28ec			; | 2DROP ( w w -- )    Double drop | DONE 
28ec					if DEBUG_FORTH_WORDS_KEY 
28ec						DMARK "2DR" 
28ec f5				push af  
28ed 3a 01 29			ld a, (.dmark)  
28f0 32 6e fe			ld (debug_mark),a  
28f3 3a 02 29			ld a, (.dmark+1)  
28f6 32 6f fe			ld (debug_mark+1),a  
28f9 3a 03 29			ld a, (.dmark+2)  
28fc 32 70 fe			ld (debug_mark+2),a  
28ff 18 03			jr .pastdmark  
2901 ..			.dmark: db "2DR"  
2904 f1			.pastdmark: pop af  
2905			endm  
# End of macro DMARK
2905						CALLMONITOR 
2905 cd 9e 19			call break_point_state  
2908				endm  
# End of macro CALLMONITOR
2908					endif 
2908					FORTH_DSP_POP 
2908 cd 18 23			call macro_forth_dsp_pop 
290b				endm 
# End of macro FORTH_DSP_POP
290b					FORTH_DSP_POP 
290b cd 18 23			call macro_forth_dsp_pop 
290e				endm 
# End of macro FORTH_DSP_POP
290e					NEXTW 
290e c3 16 24			jp macro_next 
2911				endm 
# End of macro NEXTW
2911			.SWAP2: 
2911				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2911 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2912 3a 29			dw .AT            
2914 06				db 5 + 1 
2915 .. 00			db "2SWAP",0              
291b				endm 
# End of macro CWHEAD
291b			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
291b					if DEBUG_FORTH_WORDS_KEY 
291b						DMARK "2SW" 
291b f5				push af  
291c 3a 30 29			ld a, (.dmark)  
291f 32 6e fe			ld (debug_mark),a  
2922 3a 31 29			ld a, (.dmark+1)  
2925 32 6f fe			ld (debug_mark+1),a  
2928 3a 32 29			ld a, (.dmark+2)  
292b 32 70 fe			ld (debug_mark+2),a  
292e 18 03			jr .pastdmark  
2930 ..			.dmark: db "2SW"  
2933 f1			.pastdmark: pop af  
2934			endm  
# End of macro DMARK
2934						CALLMONITOR 
2934 cd 9e 19			call break_point_state  
2937				endm  
# End of macro CALLMONITOR
2937					endif 
2937					NEXTW 
2937 c3 16 24			jp macro_next 
293a				endm 
# End of macro NEXTW
293a			.AT: 
293a				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
293a 1f				db WORD_SYS_CORE+OPCODE_AT             
293b 6c 29			dw .CAT            
293d 02				db 1 + 1 
293e .. 00			db "@",0              
2940				endm 
# End of macro CWHEAD
2940			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2940			 
2940					if DEBUG_FORTH_WORDS_KEY 
2940						DMARK "AT." 
2940 f5				push af  
2941 3a 55 29			ld a, (.dmark)  
2944 32 6e fe			ld (debug_mark),a  
2947 3a 56 29			ld a, (.dmark+1)  
294a 32 6f fe			ld (debug_mark+1),a  
294d 3a 57 29			ld a, (.dmark+2)  
2950 32 70 fe			ld (debug_mark+2),a  
2953 18 03			jr .pastdmark  
2955 ..			.dmark: db "AT."  
2958 f1			.pastdmark: pop af  
2959			endm  
# End of macro DMARK
2959						CALLMONITOR 
2959 cd 9e 19			call break_point_state  
295c				endm  
# End of macro CALLMONITOR
295c					endif 
295c			.getbyteat:	 
295c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
295c cd 60 22			call macro_dsp_valuehl 
295f				endm 
# End of macro FORTH_DSP_VALUEHL
295f					 
295f			;		push hl 
295f				 
295f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
295f cd 18 23			call macro_forth_dsp_pop 
2962				endm 
# End of macro FORTH_DSP_POP
2962			 
2962			;		pop hl 
2962			 
2962 7e					ld a, (hl) 
2963			 
2963 6f					ld l, a 
2964 26 00				ld h, 0 
2966 cd 69 20				call forth_push_numhl 
2969			 
2969					NEXTW 
2969 c3 16 24			jp macro_next 
296c				endm 
# End of macro NEXTW
296c			.CAT: 
296c				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
296c 20				db WORD_SYS_CORE+OPCODE_CAT             
296d 95 29			dw .BANG            
296f 03				db 2 + 1 
2970 .. 00			db "C@",0              
2973				endm 
# End of macro CWHEAD
2973			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2973					if DEBUG_FORTH_WORDS_KEY 
2973						DMARK "CAA" 
2973 f5				push af  
2974 3a 88 29			ld a, (.dmark)  
2977 32 6e fe			ld (debug_mark),a  
297a 3a 89 29			ld a, (.dmark+1)  
297d 32 6f fe			ld (debug_mark+1),a  
2980 3a 8a 29			ld a, (.dmark+2)  
2983 32 70 fe			ld (debug_mark+2),a  
2986 18 03			jr .pastdmark  
2988 ..			.dmark: db "CAA"  
298b f1			.pastdmark: pop af  
298c			endm  
# End of macro DMARK
298c						CALLMONITOR 
298c cd 9e 19			call break_point_state  
298f				endm  
# End of macro CALLMONITOR
298f					endif 
298f c3 5c 29				jp .getbyteat 
2992					NEXTW 
2992 c3 16 24			jp macro_next 
2995				endm 
# End of macro NEXTW
2995			.BANG: 
2995				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2995 21				db WORD_SYS_CORE+OPCODE_BANG             
2996 cb 29			dw .CBANG            
2998 02				db 1 + 1 
2999 .. 00			db "!",0              
299b				endm 
# End of macro CWHEAD
299b			; | ! ( x w -- ) Store x at address w      | DONE 
299b					if DEBUG_FORTH_WORDS_KEY 
299b						DMARK "BNG" 
299b f5				push af  
299c 3a b0 29			ld a, (.dmark)  
299f 32 6e fe			ld (debug_mark),a  
29a2 3a b1 29			ld a, (.dmark+1)  
29a5 32 6f fe			ld (debug_mark+1),a  
29a8 3a b2 29			ld a, (.dmark+2)  
29ab 32 70 fe			ld (debug_mark+2),a  
29ae 18 03			jr .pastdmark  
29b0 ..			.dmark: db "BNG"  
29b3 f1			.pastdmark: pop af  
29b4			endm  
# End of macro DMARK
29b4						CALLMONITOR 
29b4 cd 9e 19			call break_point_state  
29b7				endm  
# End of macro CALLMONITOR
29b7					endif 
29b7			 
29b7			.storebyteat:		 
29b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29b7 cd 60 22			call macro_dsp_valuehl 
29ba				endm 
# End of macro FORTH_DSP_VALUEHL
29ba					 
29ba e5					push hl 
29bb				 
29bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29bb cd 18 23			call macro_forth_dsp_pop 
29be				endm 
# End of macro FORTH_DSP_POP
29be			 
29be					; get byte to poke 
29be			 
29be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29be cd 60 22			call macro_dsp_valuehl 
29c1				endm 
# End of macro FORTH_DSP_VALUEHL
29c1 e5					push hl 
29c2			 
29c2			 
29c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c2 cd 18 23			call macro_forth_dsp_pop 
29c5				endm 
# End of macro FORTH_DSP_POP
29c5			 
29c5			 
29c5 d1					pop de 
29c6 e1					pop hl 
29c7			 
29c7 73					ld (hl),e 
29c8			 
29c8			 
29c8					NEXTW 
29c8 c3 16 24			jp macro_next 
29cb				endm 
# End of macro NEXTW
29cb			.CBANG: 
29cb				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
29cb 22				db WORD_SYS_CORE+OPCODE_CBANG             
29cc f4 29			dw .SCALL            
29ce 03				db 2 + 1 
29cf .. 00			db "C!",0              
29d2				endm 
# End of macro CWHEAD
29d2			; | C!  ( x w -- ) Store x at address w  | DONE 
29d2					if DEBUG_FORTH_WORDS_KEY 
29d2						DMARK "CBA" 
29d2 f5				push af  
29d3 3a e7 29			ld a, (.dmark)  
29d6 32 6e fe			ld (debug_mark),a  
29d9 3a e8 29			ld a, (.dmark+1)  
29dc 32 6f fe			ld (debug_mark+1),a  
29df 3a e9 29			ld a, (.dmark+2)  
29e2 32 70 fe			ld (debug_mark+2),a  
29e5 18 03			jr .pastdmark  
29e7 ..			.dmark: db "CBA"  
29ea f1			.pastdmark: pop af  
29eb			endm  
# End of macro DMARK
29eb						CALLMONITOR 
29eb cd 9e 19			call break_point_state  
29ee				endm  
# End of macro CALLMONITOR
29ee					endif 
29ee c3 b7 29				jp .storebyteat 
29f1					NEXTW 
29f1 c3 16 24			jp macro_next 
29f4				endm 
# End of macro NEXTW
29f4			.SCALL: 
29f4				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
29f4 23				db WORD_SYS_CORE+OPCODE_SCALL             
29f5 28 2a			dw .DEPTH            
29f7 05				db 4 + 1 
29f8 .. 00			db "CALL",0              
29fd				endm 
# End of macro CWHEAD
29fd			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
29fd					if DEBUG_FORTH_WORDS_KEY 
29fd						DMARK "CLL" 
29fd f5				push af  
29fe 3a 12 2a			ld a, (.dmark)  
2a01 32 6e fe			ld (debug_mark),a  
2a04 3a 13 2a			ld a, (.dmark+1)  
2a07 32 6f fe			ld (debug_mark+1),a  
2a0a 3a 14 2a			ld a, (.dmark+2)  
2a0d 32 70 fe			ld (debug_mark+2),a  
2a10 18 03			jr .pastdmark  
2a12 ..			.dmark: db "CLL"  
2a15 f1			.pastdmark: pop af  
2a16			endm  
# End of macro DMARK
2a16						CALLMONITOR 
2a16 cd 9e 19			call break_point_state  
2a19				endm  
# End of macro CALLMONITOR
2a19					endif 
2a19			 
2a19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a19 cd 60 22			call macro_dsp_valuehl 
2a1c				endm 
# End of macro FORTH_DSP_VALUEHL
2a1c			 
2a1c			;		push hl 
2a1c			 
2a1c					; destroy value TOS 
2a1c			 
2a1c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a1c cd 18 23			call macro_forth_dsp_pop 
2a1f				endm 
# End of macro FORTH_DSP_POP
2a1f			 
2a1f						 
2a1f			;		pop hl 
2a1f			 
2a1f					; how to do a call with hl???? save SP? 
2a1f cd ba 23				call forth_call_hl 
2a22			 
2a22			 
2a22					; TODO push value back onto stack for another op etc 
2a22			 
2a22 cd 69 20				call forth_push_numhl 
2a25					NEXTW 
2a25 c3 16 24			jp macro_next 
2a28				endm 
# End of macro NEXTW
2a28			.DEPTH: 
2a28				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2a28 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2a29 65 2a			dw .OVER            
2a2b 06				db 5 + 1 
2a2c .. 00			db "DEPTH",0              
2a32				endm 
# End of macro CWHEAD
2a32			; | DEPTH ( -- u ) Push count of stack | DONE 
2a32					; take current TOS and remove from base value div by two to get count 
2a32					if DEBUG_FORTH_WORDS_KEY 
2a32						DMARK "DEP" 
2a32 f5				push af  
2a33 3a 47 2a			ld a, (.dmark)  
2a36 32 6e fe			ld (debug_mark),a  
2a39 3a 48 2a			ld a, (.dmark+1)  
2a3c 32 6f fe			ld (debug_mark+1),a  
2a3f 3a 49 2a			ld a, (.dmark+2)  
2a42 32 70 fe			ld (debug_mark+2),a  
2a45 18 03			jr .pastdmark  
2a47 ..			.dmark: db "DEP"  
2a4a f1			.pastdmark: pop af  
2a4b			endm  
# End of macro DMARK
2a4b						CALLMONITOR 
2a4b cd 9e 19			call break_point_state  
2a4e				endm  
# End of macro CALLMONITOR
2a4e					endif 
2a4e			 
2a4e			 
2a4e 2a f5 f9			ld hl, (cli_data_sp) 
2a51 11 2f f7			ld de, cli_data_stack 
2a54 ed 52			sbc hl,de 
2a56				 
2a56				; div by size of stack item 
2a56			 
2a56 5d				ld e,l 
2a57 0e 03			ld c, 3 
2a59 cd dc 0e			call Div8 
2a5c			 
2a5c 6f				ld l,a 
2a5d 26 00			ld h,0 
2a5f			 
2a5f				;srl h 
2a5f				;rr l 
2a5f			 
2a5f cd 69 20				call forth_push_numhl 
2a62					NEXTW 
2a62 c3 16 24			jp macro_next 
2a65				endm 
# End of macro NEXTW
2a65			.OVER: 
2a65				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2a65 42				db WORD_SYS_CORE+46             
2a66 ac 2a			dw .PAUSE            
2a68 05				db 4 + 1 
2a69 .. 00			db "OVER",0              
2a6e				endm 
# End of macro CWHEAD
2a6e			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2a6e					if DEBUG_FORTH_WORDS_KEY 
2a6e						DMARK "OVR" 
2a6e f5				push af  
2a6f 3a 83 2a			ld a, (.dmark)  
2a72 32 6e fe			ld (debug_mark),a  
2a75 3a 84 2a			ld a, (.dmark+1)  
2a78 32 6f fe			ld (debug_mark+1),a  
2a7b 3a 85 2a			ld a, (.dmark+2)  
2a7e 32 70 fe			ld (debug_mark+2),a  
2a81 18 03			jr .pastdmark  
2a83 ..			.dmark: db "OVR"  
2a86 f1			.pastdmark: pop af  
2a87			endm  
# End of macro DMARK
2a87						CALLMONITOR 
2a87 cd 9e 19			call break_point_state  
2a8a				endm  
# End of macro CALLMONITOR
2a8a					endif 
2a8a			 
2a8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a8a cd 60 22			call macro_dsp_valuehl 
2a8d				endm 
# End of macro FORTH_DSP_VALUEHL
2a8d e5					push hl    ; n2 
2a8e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a8e cd 18 23			call macro_forth_dsp_pop 
2a91				endm 
# End of macro FORTH_DSP_POP
2a91			 
2a91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a91 cd 60 22			call macro_dsp_valuehl 
2a94				endm 
# End of macro FORTH_DSP_VALUEHL
2a94 e5					push hl    ; n1 
2a95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a95 cd 18 23			call macro_forth_dsp_pop 
2a98				endm 
# End of macro FORTH_DSP_POP
2a98			 
2a98 d1					pop de     ; n1 
2a99 e1					pop hl     ; n2 
2a9a			 
2a9a d5					push de 
2a9b e5					push hl 
2a9c d5					push de 
2a9d			 
2a9d					; push back  
2a9d			 
2a9d e1					pop hl 
2a9e cd 69 20				call forth_push_numhl 
2aa1 e1					pop hl 
2aa2 cd 69 20				call forth_push_numhl 
2aa5 e1					pop hl 
2aa6 cd 69 20				call forth_push_numhl 
2aa9					NEXTW 
2aa9 c3 16 24			jp macro_next 
2aac				endm 
# End of macro NEXTW
2aac			 
2aac			.PAUSE: 
2aac				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2aac 43				db WORD_SYS_CORE+47             
2aad e1 2a			dw .PAUSES            
2aaf 08				db 7 + 1 
2ab0 .. 00			db "PAUSEMS",0              
2ab8				endm 
# End of macro CWHEAD
2ab8			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2ab8					if DEBUG_FORTH_WORDS_KEY 
2ab8						DMARK "PMS" 
2ab8 f5				push af  
2ab9 3a cd 2a			ld a, (.dmark)  
2abc 32 6e fe			ld (debug_mark),a  
2abf 3a ce 2a			ld a, (.dmark+1)  
2ac2 32 6f fe			ld (debug_mark+1),a  
2ac5 3a cf 2a			ld a, (.dmark+2)  
2ac8 32 70 fe			ld (debug_mark+2),a  
2acb 18 03			jr .pastdmark  
2acd ..			.dmark: db "PMS"  
2ad0 f1			.pastdmark: pop af  
2ad1			endm  
# End of macro DMARK
2ad1						CALLMONITOR 
2ad1 cd 9e 19			call break_point_state  
2ad4				endm  
# End of macro CALLMONITOR
2ad4					endif 
2ad4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ad4 cd 60 22			call macro_dsp_valuehl 
2ad7				endm 
# End of macro FORTH_DSP_VALUEHL
2ad7			;		push hl    ; n2 
2ad7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ad7 cd 18 23			call macro_forth_dsp_pop 
2ada				endm 
# End of macro FORTH_DSP_POP
2ada			;		pop hl 
2ada			 
2ada 7d					ld a, l 
2adb cd 7a 0c				call aDelayInMS 
2ade				       NEXTW 
2ade c3 16 24			jp macro_next 
2ae1				endm 
# End of macro NEXTW
2ae1			.PAUSES:  
2ae1				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2ae1 44				db WORD_SYS_CORE+48             
2ae2 50 2b			dw .ROT            
2ae4 06				db 5 + 1 
2ae5 .. 00			db "PAUSE",0              
2aeb				endm 
# End of macro CWHEAD
2aeb			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2aeb					if DEBUG_FORTH_WORDS_KEY 
2aeb						DMARK "PAU" 
2aeb f5				push af  
2aec 3a 00 2b			ld a, (.dmark)  
2aef 32 6e fe			ld (debug_mark),a  
2af2 3a 01 2b			ld a, (.dmark+1)  
2af5 32 6f fe			ld (debug_mark+1),a  
2af8 3a 02 2b			ld a, (.dmark+2)  
2afb 32 70 fe			ld (debug_mark+2),a  
2afe 18 03			jr .pastdmark  
2b00 ..			.dmark: db "PAU"  
2b03 f1			.pastdmark: pop af  
2b04			endm  
# End of macro DMARK
2b04						CALLMONITOR 
2b04 cd 9e 19			call break_point_state  
2b07				endm  
# End of macro CALLMONITOR
2b07					endif 
2b07					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b07 cd 60 22			call macro_dsp_valuehl 
2b0a				endm 
# End of macro FORTH_DSP_VALUEHL
2b0a			;		push hl    ; n2 
2b0a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b0a cd 18 23			call macro_forth_dsp_pop 
2b0d				endm 
# End of macro FORTH_DSP_POP
2b0d			;		pop hl 
2b0d 45					ld b, l 
2b0e					if DEBUG_FORTH_WORDS 
2b0e						DMARK "PAU" 
2b0e f5				push af  
2b0f 3a 23 2b			ld a, (.dmark)  
2b12 32 6e fe			ld (debug_mark),a  
2b15 3a 24 2b			ld a, (.dmark+1)  
2b18 32 6f fe			ld (debug_mark+1),a  
2b1b 3a 25 2b			ld a, (.dmark+2)  
2b1e 32 70 fe			ld (debug_mark+2),a  
2b21 18 03			jr .pastdmark  
2b23 ..			.dmark: db "PAU"  
2b26 f1			.pastdmark: pop af  
2b27			endm  
# End of macro DMARK
2b27						CALLMONITOR 
2b27 cd 9e 19			call break_point_state  
2b2a				endm  
# End of macro CALLMONITOR
2b2a					endif 
2b2a c5			.pauses1:	push bc 
2b2b cd 95 0c				call delay1s 
2b2e c1					pop bc 
2b2f					if DEBUG_FORTH_WORDS 
2b2f						DMARK "PA1" 
2b2f f5				push af  
2b30 3a 44 2b			ld a, (.dmark)  
2b33 32 6e fe			ld (debug_mark),a  
2b36 3a 45 2b			ld a, (.dmark+1)  
2b39 32 6f fe			ld (debug_mark+1),a  
2b3c 3a 46 2b			ld a, (.dmark+2)  
2b3f 32 70 fe			ld (debug_mark+2),a  
2b42 18 03			jr .pastdmark  
2b44 ..			.dmark: db "PA1"  
2b47 f1			.pastdmark: pop af  
2b48			endm  
# End of macro DMARK
2b48						CALLMONITOR 
2b48 cd 9e 19			call break_point_state  
2b4b				endm  
# End of macro CALLMONITOR
2b4b					endif 
2b4b 10 dd				djnz .pauses1 
2b4d			 
2b4d				       NEXTW 
2b4d c3 16 24			jp macro_next 
2b50				endm 
# End of macro NEXTW
2b50			.ROT: 
2b50				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2b50 45				db WORD_SYS_CORE+49             
2b51 9e 2b			dw .UWORDS            
2b53 04				db 3 + 1 
2b54 .. 00			db "ROT",0              
2b58				endm 
# End of macro CWHEAD
2b58			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2b58					if DEBUG_FORTH_WORDS_KEY 
2b58						DMARK "ROT" 
2b58 f5				push af  
2b59 3a 6d 2b			ld a, (.dmark)  
2b5c 32 6e fe			ld (debug_mark),a  
2b5f 3a 6e 2b			ld a, (.dmark+1)  
2b62 32 6f fe			ld (debug_mark+1),a  
2b65 3a 6f 2b			ld a, (.dmark+2)  
2b68 32 70 fe			ld (debug_mark+2),a  
2b6b 18 03			jr .pastdmark  
2b6d ..			.dmark: db "ROT"  
2b70 f1			.pastdmark: pop af  
2b71			endm  
# End of macro DMARK
2b71						CALLMONITOR 
2b71 cd 9e 19			call break_point_state  
2b74				endm  
# End of macro CALLMONITOR
2b74					endif 
2b74			 
2b74					FORTH_DSP_VALUEHL 
2b74 cd 60 22			call macro_dsp_valuehl 
2b77				endm 
# End of macro FORTH_DSP_VALUEHL
2b77 e5					push hl    ; u3  
2b78			 
2b78					FORTH_DSP_POP 
2b78 cd 18 23			call macro_forth_dsp_pop 
2b7b				endm 
# End of macro FORTH_DSP_POP
2b7b			   
2b7b					FORTH_DSP_VALUEHL 
2b7b cd 60 22			call macro_dsp_valuehl 
2b7e				endm 
# End of macro FORTH_DSP_VALUEHL
2b7e e5					push hl     ; u2 
2b7f			 
2b7f					FORTH_DSP_POP 
2b7f cd 18 23			call macro_forth_dsp_pop 
2b82				endm 
# End of macro FORTH_DSP_POP
2b82			 
2b82					FORTH_DSP_VALUEHL 
2b82 cd 60 22			call macro_dsp_valuehl 
2b85				endm 
# End of macro FORTH_DSP_VALUEHL
2b85 e5					push hl     ; u1 
2b86			 
2b86					FORTH_DSP_POP 
2b86 cd 18 23			call macro_forth_dsp_pop 
2b89				endm 
# End of macro FORTH_DSP_POP
2b89			 
2b89 c1					pop bc      ; u1 
2b8a e1					pop hl      ; u2 
2b8b d1					pop de      ; u3 
2b8c			 
2b8c			 
2b8c c5					push bc 
2b8d d5					push de 
2b8e e5					push hl 
2b8f			 
2b8f			 
2b8f e1					pop hl 
2b90 cd 69 20				call forth_push_numhl 
2b93			 
2b93 e1					pop hl 
2b94 cd 69 20				call forth_push_numhl 
2b97			 
2b97 e1					pop hl 
2b98 cd 69 20				call forth_push_numhl 
2b9b					 
2b9b			 
2b9b			 
2b9b			 
2b9b			 
2b9b			 
2b9b				       NEXTW 
2b9b c3 16 24			jp macro_next 
2b9e				endm 
# End of macro NEXTW
2b9e			 
2b9e			.UWORDS: 
2b9e				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2b9e 50				db WORD_SYS_CORE+60             
2b9f 60 2c			dw .BP            
2ba1 07				db 6 + 1 
2ba2 .. 00			db "UWORDS",0              
2ba9				endm 
# End of macro CWHEAD
2ba9			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2ba9			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2ba9			; | | Following the count are the individual words. 
2ba9			; | | 
2ba9			; | | e.g. UWORDS 
2ba9			; | | BOX DIRLIST 2 
2ba9			; | |  
2ba9			; | | Can be used to save the words to storage via: 
2ba9			; | | UWORDS $01 DO $01 APPEND LOOP 
2ba9				if DEBUG_FORTH_WORDS_KEY 
2ba9					DMARK "UWR" 
2ba9 f5				push af  
2baa 3a be 2b			ld a, (.dmark)  
2bad 32 6e fe			ld (debug_mark),a  
2bb0 3a bf 2b			ld a, (.dmark+1)  
2bb3 32 6f fe			ld (debug_mark+1),a  
2bb6 3a c0 2b			ld a, (.dmark+2)  
2bb9 32 70 fe			ld (debug_mark+2),a  
2bbc 18 03			jr .pastdmark  
2bbe ..			.dmark: db "UWR"  
2bc1 f1			.pastdmark: pop af  
2bc2			endm  
# End of macro DMARK
2bc2					CALLMONITOR 
2bc2 cd 9e 19			call break_point_state  
2bc5				endm  
# End of macro CALLMONITOR
2bc5				endif 
2bc5 21 00 80				ld hl, baseram 
2bc8					;ld hl, baseusermem 
2bc8 01 00 00				ld bc, 0    ; start a counter 
2bcb			 
2bcb				; skip dict stub 
2bcb			 
2bcb cd 67 25				call forth_tok_next 
2bce			 
2bce			 
2bce			; while we have words to look for 
2bce			 
2bce 7e			.douscan:	ld a, (hl)      
2bcf				if DEBUG_FORTH_WORDS 
2bcf					DMARK "UWs" 
2bcf f5				push af  
2bd0 3a e4 2b			ld a, (.dmark)  
2bd3 32 6e fe			ld (debug_mark),a  
2bd6 3a e5 2b			ld a, (.dmark+1)  
2bd9 32 6f fe			ld (debug_mark+1),a  
2bdc 3a e6 2b			ld a, (.dmark+2)  
2bdf 32 70 fe			ld (debug_mark+2),a  
2be2 18 03			jr .pastdmark  
2be4 ..			.dmark: db "UWs"  
2be7 f1			.pastdmark: pop af  
2be8			endm  
# End of macro DMARK
2be8					CALLMONITOR 
2be8 cd 9e 19			call break_point_state  
2beb				endm  
# End of macro CALLMONITOR
2beb				endif 
2beb fe 00				cp WORD_SYS_END 
2bed 28 4d				jr z, .udone 
2bef fe 01				cp WORD_SYS_UWORD 
2bf1 20 44				jr nz, .nuword 
2bf3			 
2bf3				if DEBUG_FORTH_WORDS 
2bf3					DMARK "UWu" 
2bf3 f5				push af  
2bf4 3a 08 2c			ld a, (.dmark)  
2bf7 32 6e fe			ld (debug_mark),a  
2bfa 3a 09 2c			ld a, (.dmark+1)  
2bfd 32 6f fe			ld (debug_mark+1),a  
2c00 3a 0a 2c			ld a, (.dmark+2)  
2c03 32 70 fe			ld (debug_mark+2),a  
2c06 18 03			jr .pastdmark  
2c08 ..			.dmark: db "UWu"  
2c0b f1			.pastdmark: pop af  
2c0c			endm  
# End of macro DMARK
2c0c					CALLMONITOR 
2c0c cd 9e 19			call break_point_state  
2c0f				endm  
# End of macro CALLMONITOR
2c0f				endif 
2c0f					; we have a uword so push its name to the stack 
2c0f			 
2c0f e5				   	push hl  ; save so we can move to next dict block 
2c10			 
2c10					; skip opcode 
2c10 23					inc hl  
2c11					; skip next ptr 
2c11 23					inc hl  
2c12 23					inc hl 
2c13					; skip len 
2c13 23					inc hl 
2c14				if DEBUG_FORTH_WORDS 
2c14					DMARK "UWt" 
2c14 f5				push af  
2c15 3a 29 2c			ld a, (.dmark)  
2c18 32 6e fe			ld (debug_mark),a  
2c1b 3a 2a 2c			ld a, (.dmark+1)  
2c1e 32 6f fe			ld (debug_mark+1),a  
2c21 3a 2b 2c			ld a, (.dmark+2)  
2c24 32 70 fe			ld (debug_mark+2),a  
2c27 18 03			jr .pastdmark  
2c29 ..			.dmark: db "UWt"  
2c2c f1			.pastdmark: pop af  
2c2d			endm  
# End of macro DMARK
2c2d					CALLMONITOR 
2c2d cd 9e 19			call break_point_state  
2c30				endm  
# End of macro CALLMONITOR
2c30				endif 
2c30 03					inc bc 
2c31			 
2c31 c5					push bc 
2c32 cd d7 20				call forth_push_str 
2c35 c1					pop bc 
2c36			 
2c36 e1					pop hl 	 
2c37			 
2c37 cd 67 25		.nuword:	call forth_tok_next 
2c3a 18 92				jr .douscan  
2c3c			 
2c3c			.udone:		 ; push count of uwords found 
2c3c c5					push bc 
2c3d e1					pop hl 
2c3e			 
2c3e				if DEBUG_FORTH_WORDS 
2c3e					DMARK "UWc" 
2c3e f5				push af  
2c3f 3a 53 2c			ld a, (.dmark)  
2c42 32 6e fe			ld (debug_mark),a  
2c45 3a 54 2c			ld a, (.dmark+1)  
2c48 32 6f fe			ld (debug_mark+1),a  
2c4b 3a 55 2c			ld a, (.dmark+2)  
2c4e 32 70 fe			ld (debug_mark+2),a  
2c51 18 03			jr .pastdmark  
2c53 ..			.dmark: db "UWc"  
2c56 f1			.pastdmark: pop af  
2c57			endm  
# End of macro DMARK
2c57					CALLMONITOR 
2c57 cd 9e 19			call break_point_state  
2c5a				endm  
# End of macro CALLMONITOR
2c5a				endif 
2c5a cd 69 20				call forth_push_numhl 
2c5d			 
2c5d			 
2c5d				       NEXTW 
2c5d c3 16 24			jp macro_next 
2c60				endm 
# End of macro NEXTW
2c60			 
2c60			.BP: 
2c60				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2c60 54				db WORD_SYS_CORE+64             
2c61 96 2c			dw .MONITOR            
2c63 03				db 2 + 1 
2c64 .. 00			db "BP",0              
2c67				endm 
# End of macro CWHEAD
2c67			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2c67			; | | $00 Will enable the break points within specific code paths 
2c67			; | | $01 Will disable break points 
2c67			; | |  
2c67			; | | By default break points are off. Either the above can be used to enable them 
2c67			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2c67			; | | and on release of the pressed key a message will be disaplayed to notify 
2c67			; | | that break points are enabled. Pressing any key will then continue boot process. 
2c67					; get byte count 
2c67					if DEBUG_FORTH_WORDS_KEY 
2c67						DMARK "BP." 
2c67 f5				push af  
2c68 3a 7c 2c			ld a, (.dmark)  
2c6b 32 6e fe			ld (debug_mark),a  
2c6e 3a 7d 2c			ld a, (.dmark+1)  
2c71 32 6f fe			ld (debug_mark+1),a  
2c74 3a 7e 2c			ld a, (.dmark+2)  
2c77 32 70 fe			ld (debug_mark+2),a  
2c7a 18 03			jr .pastdmark  
2c7c ..			.dmark: db "BP."  
2c7f f1			.pastdmark: pop af  
2c80			endm  
# End of macro DMARK
2c80						CALLMONITOR 
2c80 cd 9e 19			call break_point_state  
2c83				endm  
# End of macro CALLMONITOR
2c83					endif 
2c83			 
2c83					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c83 cd 60 22			call macro_dsp_valuehl 
2c86				endm 
# End of macro FORTH_DSP_VALUEHL
2c86			 
2c86			;		push hl 
2c86			 
2c86					; destroy value TOS 
2c86			 
2c86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c86 cd 18 23			call macro_forth_dsp_pop 
2c89				endm 
# End of macro FORTH_DSP_POP
2c89			 
2c89			;		pop hl 
2c89			 
2c89 3e 00				ld a,0 
2c8b bd					cp l 
2c8c 28 02				jr z, .bpset 
2c8e 3e 2a				ld a, '*' 
2c90			 
2c90 32 b9 f1		.bpset:		ld (os_view_disable), a 
2c93			 
2c93			 
2c93					NEXTW 
2c93 c3 16 24			jp macro_next 
2c96				endm 
# End of macro NEXTW
2c96			 
2c96			 
2c96			.MONITOR: 
2c96				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2c96 55				db WORD_SYS_CORE+65             
2c97 c9 2c			dw .MALLOC            
2c99 08				db 7 + 1 
2c9a .. 00			db "MONITOR",0              
2ca2				endm 
# End of macro CWHEAD
2ca2			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2ca2			; | | At start the current various registers will be displayed with contents. 
2ca2			; | | Top right corner will show the most recent debug marker seen. 
2ca2			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2ca2			; | | and the return stack pointer (RSP). 
2ca2			; | | Pressing: 
2ca2			; | |    1 - Initial screen 
2ca2			; | |    2 - Display a data dump of HL 
2ca2			; | |    3 - Display a data dump of DE 
2ca2			; | |    4 - Display a data dump of BC 
2ca2			; | |    5 - Display a data dump of HL 
2ca2			; | |    6 - Display a data dump of DSP 
2ca2			; | |    7 - Display a data dump of RSP 
2ca2			; | |    8 - Display a data dump of what is at DSP 
2ca2			; | |    9 - Display a data dump of what is at RSP 
2ca2			; | |    0 - Exit monitor and continue running. This will also enable break points 
2ca2			; | |    * - Disable break points 
2ca2			; | |    # - Enter traditional monitor mode 
2ca2			; | | 
2ca2			; | | Monitor Mode 
2ca2			; | | ------------ 
2ca2			; | | A prompt of '>' will be shown for various commands: 
2ca2			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2ca2			; | |    C - Continue display a data dump from the last set address 
2ca2			; | |    M xxxx - Set start of memory edit at address xx 
2ca2			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2ca2			; | |    Q - Return to previous 
2ca2					if DEBUG_FORTH_WORDS_KEY 
2ca2						DMARK "MON" 
2ca2 f5				push af  
2ca3 3a b7 2c			ld a, (.dmark)  
2ca6 32 6e fe			ld (debug_mark),a  
2ca9 3a b8 2c			ld a, (.dmark+1)  
2cac 32 6f fe			ld (debug_mark+1),a  
2caf 3a b9 2c			ld a, (.dmark+2)  
2cb2 32 70 fe			ld (debug_mark+2),a  
2cb5 18 03			jr .pastdmark  
2cb7 ..			.dmark: db "MON"  
2cba f1			.pastdmark: pop af  
2cbb			endm  
# End of macro DMARK
2cbb						CALLMONITOR 
2cbb cd 9e 19			call break_point_state  
2cbe				endm  
# End of macro CALLMONITOR
2cbe					endif 
2cbe 3e 00				ld a, 0 
2cc0 32 b9 f1				ld (os_view_disable), a 
2cc3			 
2cc3					CALLMONITOR 
2cc3 cd 9e 19			call break_point_state  
2cc6				endm  
# End of macro CALLMONITOR
2cc6			 
2cc6			;	call monitor 
2cc6			 
2cc6					NEXTW 
2cc6 c3 16 24			jp macro_next 
2cc9				endm 
# End of macro NEXTW
2cc9			 
2cc9			 
2cc9			.MALLOC: 
2cc9				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2cc9 56				db WORD_SYS_CORE+66             
2cca f2 2c			dw .MALLOC2            
2ccc 06				db 5 + 1 
2ccd .. 00			db "ALLOT",0              
2cd3				endm 
# End of macro CWHEAD
2cd3			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2cd3					if DEBUG_FORTH_WORDS_KEY 
2cd3						DMARK "ALL" 
2cd3 f5				push af  
2cd4 3a e8 2c			ld a, (.dmark)  
2cd7 32 6e fe			ld (debug_mark),a  
2cda 3a e9 2c			ld a, (.dmark+1)  
2cdd 32 6f fe			ld (debug_mark+1),a  
2ce0 3a ea 2c			ld a, (.dmark+2)  
2ce3 32 70 fe			ld (debug_mark+2),a  
2ce6 18 03			jr .pastdmark  
2ce8 ..			.dmark: db "ALL"  
2ceb f1			.pastdmark: pop af  
2cec			endm  
# End of macro DMARK
2cec						CALLMONITOR 
2cec cd 9e 19			call break_point_state  
2cef				endm  
# End of macro CALLMONITOR
2cef					endif 
2cef c3 19 2d				jp .mallocc 
2cf2			.MALLOC2: 
2cf2				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2cf2 56				db WORD_SYS_CORE+66             
2cf3 30 2d			dw .FREE            
2cf5 07				db 6 + 1 
2cf6 .. 00			db "MALLOC",0              
2cfd				endm 
# End of macro CWHEAD
2cfd			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2cfd					; get byte count 
2cfd					if DEBUG_FORTH_WORDS_KEY 
2cfd						DMARK "MAL" 
2cfd f5				push af  
2cfe 3a 12 2d			ld a, (.dmark)  
2d01 32 6e fe			ld (debug_mark),a  
2d04 3a 13 2d			ld a, (.dmark+1)  
2d07 32 6f fe			ld (debug_mark+1),a  
2d0a 3a 14 2d			ld a, (.dmark+2)  
2d0d 32 70 fe			ld (debug_mark+2),a  
2d10 18 03			jr .pastdmark  
2d12 ..			.dmark: db "MAL"  
2d15 f1			.pastdmark: pop af  
2d16			endm  
# End of macro DMARK
2d16						CALLMONITOR 
2d16 cd 9e 19			call break_point_state  
2d19				endm  
# End of macro CALLMONITOR
2d19					endif 
2d19			.mallocc: 
2d19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d19 cd 60 22			call macro_dsp_valuehl 
2d1c				endm 
# End of macro FORTH_DSP_VALUEHL
2d1c			 
2d1c			;		push hl 
2d1c			 
2d1c					; destroy value TOS 
2d1c			 
2d1c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d1c cd 18 23			call macro_forth_dsp_pop 
2d1f				endm 
# End of macro FORTH_DSP_POP
2d1f			 
2d1f			;		pop hl 
2d1f cd 13 14				call malloc 
2d22				if DEBUG_FORTH_MALLOC_GUARD 
2d22 f5					push af 
2d23 cd 75 0f				call ishlzero 
2d26			;		ld a, l 
2d26			;		add h 
2d26			;		cp 0 
2d26 f1					pop af 
2d27					 
2d27 cc e8 5c				call z,malloc_error 
2d2a				endif 
2d2a			 
2d2a cd 69 20				call forth_push_numhl 
2d2d					NEXTW 
2d2d c3 16 24			jp macro_next 
2d30				endm 
# End of macro NEXTW
2d30			 
2d30			.FREE: 
2d30				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2d30 57				db WORD_SYS_CORE+67             
2d31 61 2d			dw .LIST            
2d33 05				db 4 + 1 
2d34 .. 00			db "FREE",0              
2d39				endm 
# End of macro CWHEAD
2d39			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2d39					if DEBUG_FORTH_WORDS_KEY 
2d39						DMARK "FRE" 
2d39 f5				push af  
2d3a 3a 4e 2d			ld a, (.dmark)  
2d3d 32 6e fe			ld (debug_mark),a  
2d40 3a 4f 2d			ld a, (.dmark+1)  
2d43 32 6f fe			ld (debug_mark+1),a  
2d46 3a 50 2d			ld a, (.dmark+2)  
2d49 32 70 fe			ld (debug_mark+2),a  
2d4c 18 03			jr .pastdmark  
2d4e ..			.dmark: db "FRE"  
2d51 f1			.pastdmark: pop af  
2d52			endm  
# End of macro DMARK
2d52						CALLMONITOR 
2d52 cd 9e 19			call break_point_state  
2d55				endm  
# End of macro CALLMONITOR
2d55					endif 
2d55					; get address 
2d55			 
2d55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d55 cd 60 22			call macro_dsp_valuehl 
2d58				endm 
# End of macro FORTH_DSP_VALUEHL
2d58			 
2d58			;		push hl 
2d58			 
2d58					; destroy value TOS 
2d58			 
2d58					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d58 cd 18 23			call macro_forth_dsp_pop 
2d5b				endm 
# End of macro FORTH_DSP_POP
2d5b			 
2d5b			;		pop hl 
2d5b			if FORTH_ENABLE_MALLOCFREE 
2d5b cd dd 14				call free 
2d5e			endif 
2d5e					NEXTW 
2d5e c3 16 24			jp macro_next 
2d61				endm 
# End of macro NEXTW
2d61			.LIST: 
2d61				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2d61 5c				db WORD_SYS_CORE+72             
2d62 4f 2f			dw .FORGET            
2d64 05				db 4 + 1 
2d65 .. 00			db "LIST",0              
2d6a				endm 
# End of macro CWHEAD
2d6a			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2d6a			; | | The quoted word must be in upper case. 
2d6a				if DEBUG_FORTH_WORDS_KEY 
2d6a					DMARK "LST" 
2d6a f5				push af  
2d6b 3a 7f 2d			ld a, (.dmark)  
2d6e 32 6e fe			ld (debug_mark),a  
2d71 3a 80 2d			ld a, (.dmark+1)  
2d74 32 6f fe			ld (debug_mark+1),a  
2d77 3a 81 2d			ld a, (.dmark+2)  
2d7a 32 70 fe			ld (debug_mark+2),a  
2d7d 18 03			jr .pastdmark  
2d7f ..			.dmark: db "LST"  
2d82 f1			.pastdmark: pop af  
2d83			endm  
# End of macro DMARK
2d83					CALLMONITOR 
2d83 cd 9e 19			call break_point_state  
2d86				endm  
# End of macro CALLMONITOR
2d86				endif 
2d86			 
2d86					FORTH_DSP_VALUEHL 
2d86 cd 60 22			call macro_dsp_valuehl 
2d89				endm 
# End of macro FORTH_DSP_VALUEHL
2d89			 
2d89 e5					push hl 
2d8a					FORTH_DSP_POP 
2d8a cd 18 23			call macro_forth_dsp_pop 
2d8d				endm 
# End of macro FORTH_DSP_POP
2d8d c1					pop bc 
2d8e			 
2d8e			; Start format of scratch string 
2d8e			 
2d8e 21 c8 f1				ld hl, scratch 
2d91			 
2d91 3e 3a				ld a, ':' 
2d93 77					ld (hl),a 
2d94 23					inc hl 
2d95 3e 20				ld a, ' ' 
2d97 77					ld (hl), a 
2d98			 
2d98					; Get ptr to the word we need to look up 
2d98			 
2d98			;		FORTH_DSP_VALUEHL 
2d98					;v5 FORTH_DSP_VALUE 
2d98				; TODO type check 
2d98			;		inc hl    ; Skip type check  
2d98			;		push hl 
2d98			;		ex de, hl    ; put into DE 
2d98			 
2d98			 
2d98 21 00 80				ld hl, baseram 
2d9b					;ld hl, baseusermem 
2d9b			 
2d9b e5			push hl   ; sacreifical push 
2d9c			 
2d9c			.ldouscanm: 
2d9c e1				pop hl 
2d9d			.ldouscan: 
2d9d				if DEBUG_FORTH_WORDS 
2d9d					DMARK "LSs" 
2d9d f5				push af  
2d9e 3a b2 2d			ld a, (.dmark)  
2da1 32 6e fe			ld (debug_mark),a  
2da4 3a b3 2d			ld a, (.dmark+1)  
2da7 32 6f fe			ld (debug_mark+1),a  
2daa 3a b4 2d			ld a, (.dmark+2)  
2dad 32 70 fe			ld (debug_mark+2),a  
2db0 18 03			jr .pastdmark  
2db2 ..			.dmark: db "LSs"  
2db5 f1			.pastdmark: pop af  
2db6			endm  
# End of macro DMARK
2db6					CALLMONITOR 
2db6 cd 9e 19			call break_point_state  
2db9				endm  
# End of macro CALLMONITOR
2db9				endif 
2db9				; skip dict stub 
2db9 cd 67 25				call forth_tok_next 
2dbc			 
2dbc			 
2dbc			; while we have words to look for 
2dbc			 
2dbc 7e				ld a, (hl)      
2dbd				if DEBUG_FORTH_WORDS 
2dbd					DMARK "LSk" 
2dbd f5				push af  
2dbe 3a d2 2d			ld a, (.dmark)  
2dc1 32 6e fe			ld (debug_mark),a  
2dc4 3a d3 2d			ld a, (.dmark+1)  
2dc7 32 6f fe			ld (debug_mark+1),a  
2dca 3a d4 2d			ld a, (.dmark+2)  
2dcd 32 70 fe			ld (debug_mark+2),a  
2dd0 18 03			jr .pastdmark  
2dd2 ..			.dmark: db "LSk"  
2dd5 f1			.pastdmark: pop af  
2dd6			endm  
# End of macro DMARK
2dd6					CALLMONITOR 
2dd6 cd 9e 19			call break_point_state  
2dd9				endm  
# End of macro CALLMONITOR
2dd9				endif 
2dd9					;cp WORD_SYS_END 
2dd9					;jp z, .lunotfound 
2dd9			 
2dd9					; if we hit non uwords then gone too far 
2dd9 fe 01				cp WORD_SYS_UWORD 
2ddb c2 0b 2f				jp nz, .lunotfound 
2dde			 
2dde				if DEBUG_FORTH_WORDS 
2dde					DMARK "LSu" 
2dde f5				push af  
2ddf 3a f3 2d			ld a, (.dmark)  
2de2 32 6e fe			ld (debug_mark),a  
2de5 3a f4 2d			ld a, (.dmark+1)  
2de8 32 6f fe			ld (debug_mark+1),a  
2deb 3a f5 2d			ld a, (.dmark+2)  
2dee 32 70 fe			ld (debug_mark+2),a  
2df1 18 03			jr .pastdmark  
2df3 ..			.dmark: db "LSu"  
2df6 f1			.pastdmark: pop af  
2df7			endm  
# End of macro DMARK
2df7					CALLMONITOR 
2df7 cd 9e 19			call break_point_state  
2dfa				endm  
# End of macro CALLMONITOR
2dfa				endif 
2dfa			 
2dfa					; found a uword but is it the one we want... 
2dfa			 
2dfa c5					push bc     ; uword to find is on bc 
2dfb d1					pop de 
2dfc			 
2dfc e5					push hl  ; to save the ptr 
2dfd			 
2dfd					; skip opcode 
2dfd 23					inc hl  
2dfe					; skip next ptr 
2dfe 23					inc hl  
2dff 23					inc hl 
2e00					; skip len 
2e00 23					inc hl 
2e01			 
2e01				if DEBUG_FORTH_WORDS 
2e01					DMARK "LSc" 
2e01 f5				push af  
2e02 3a 16 2e			ld a, (.dmark)  
2e05 32 6e fe			ld (debug_mark),a  
2e08 3a 17 2e			ld a, (.dmark+1)  
2e0b 32 6f fe			ld (debug_mark+1),a  
2e0e 3a 18 2e			ld a, (.dmark+2)  
2e11 32 70 fe			ld (debug_mark+2),a  
2e14 18 03			jr .pastdmark  
2e16 ..			.dmark: db "LSc"  
2e19 f1			.pastdmark: pop af  
2e1a			endm  
# End of macro DMARK
2e1a					CALLMONITOR 
2e1a cd 9e 19			call break_point_state  
2e1d				endm  
# End of macro CALLMONITOR
2e1d				endif 
2e1d cd e2 13				call strcmp 
2e20 c2 9c 2d				jp nz, .ldouscanm 
2e23				 
2e23			 
2e23			 
2e23					; we have a uword so push its name to the stack 
2e23			 
2e23			;	   	push hl  ; save so we can move to next dict block 
2e23 e1			pop hl 
2e24			 
2e24				if DEBUG_FORTH_WORDS 
2e24					DMARK "LSm" 
2e24 f5				push af  
2e25 3a 39 2e			ld a, (.dmark)  
2e28 32 6e fe			ld (debug_mark),a  
2e2b 3a 3a 2e			ld a, (.dmark+1)  
2e2e 32 6f fe			ld (debug_mark+1),a  
2e31 3a 3b 2e			ld a, (.dmark+2)  
2e34 32 70 fe			ld (debug_mark+2),a  
2e37 18 03			jr .pastdmark  
2e39 ..			.dmark: db "LSm"  
2e3c f1			.pastdmark: pop af  
2e3d			endm  
# End of macro DMARK
2e3d					CALLMONITOR 
2e3d cd 9e 19			call break_point_state  
2e40				endm  
# End of macro CALLMONITOR
2e40				endif 
2e40			 
2e40					; skip opcode 
2e40 23					inc hl  
2e41					; skip next ptr 
2e41 23					inc hl  
2e42 23					inc hl 
2e43					; skip len 
2e43 7e					ld a, (hl)   ; save length to add 
2e44				if DEBUG_FORTH_WORDS 
2e44					DMARK "LS2" 
2e44 f5				push af  
2e45 3a 59 2e			ld a, (.dmark)  
2e48 32 6e fe			ld (debug_mark),a  
2e4b 3a 5a 2e			ld a, (.dmark+1)  
2e4e 32 6f fe			ld (debug_mark+1),a  
2e51 3a 5b 2e			ld a, (.dmark+2)  
2e54 32 70 fe			ld (debug_mark+2),a  
2e57 18 03			jr .pastdmark  
2e59 ..			.dmark: db "LS2"  
2e5c f1			.pastdmark: pop af  
2e5d			endm  
# End of macro DMARK
2e5d					CALLMONITOR 
2e5d cd 9e 19			call break_point_state  
2e60				endm  
# End of macro CALLMONITOR
2e60				endif 
2e60			 
2e60					; save this location 
2e60				 
2e60 e5					push hl 
2e61			 
2e61 23					inc hl 
2e62 11 ca f1				ld de, scratch+2 
2e65 4f					ld c, a 
2e66 06 00				ld b, 0 
2e68			 
2e68				if DEBUG_FORTH_WORDS 
2e68					DMARK "LSn" 
2e68 f5				push af  
2e69 3a 7d 2e			ld a, (.dmark)  
2e6c 32 6e fe			ld (debug_mark),a  
2e6f 3a 7e 2e			ld a, (.dmark+1)  
2e72 32 6f fe			ld (debug_mark+1),a  
2e75 3a 7f 2e			ld a, (.dmark+2)  
2e78 32 70 fe			ld (debug_mark+2),a  
2e7b 18 03			jr .pastdmark  
2e7d ..			.dmark: db "LSn"  
2e80 f1			.pastdmark: pop af  
2e81			endm  
# End of macro DMARK
2e81					CALLMONITOR 
2e81 cd 9e 19			call break_point_state  
2e84				endm  
# End of macro CALLMONITOR
2e84				endif 
2e84			 
2e84					; copy uword name to scratch 
2e84			 
2e84 ed b0				ldir 
2e86			 
2e86 1b					dec de 
2e87 3e 20				ld a, ' '    ; change null to space 
2e89 12					ld (de), a 
2e8a			 
2e8a 13					inc de 
2e8b			 
2e8b d5					push de 
2e8c c1					pop bc     ; move scratch pointer to end of word name and save it 
2e8d			 
2e8d e1					pop hl 
2e8e 7e					ld a, (hl) 
2e8f					;inc hl 
2e8f					; skip word string 
2e8f cd 4c 0f				call addatohl 
2e92			 
2e92 23					inc hl 
2e93			 
2e93				if DEBUG_FORTH_WORDS 
2e93					DMARK "LS3" 
2e93 f5				push af  
2e94 3a a8 2e			ld a, (.dmark)  
2e97 32 6e fe			ld (debug_mark),a  
2e9a 3a a9 2e			ld a, (.dmark+1)  
2e9d 32 6f fe			ld (debug_mark+1),a  
2ea0 3a aa 2e			ld a, (.dmark+2)  
2ea3 32 70 fe			ld (debug_mark+2),a  
2ea6 18 03			jr .pastdmark  
2ea8 ..			.dmark: db "LS3"  
2eab f1			.pastdmark: pop af  
2eac			endm  
# End of macro DMARK
2eac					CALLMONITOR 
2eac cd 9e 19			call break_point_state  
2eaf				endm  
# End of macro CALLMONITOR
2eaf				endif 
2eaf					; should now be at the start of the machine code to setup the eval of the uword 
2eaf					; now locate the ptr to the string defintion 
2eaf			 
2eaf					; skip ld hl, 
2eaf					; then load the ptr 
2eaf			; TODO use get from hl ptr 
2eaf 23					inc hl 
2eb0 5e					ld e, (hl) 
2eb1 23					inc hl 
2eb2 56					ld d, (hl) 
2eb3 eb					ex de, hl 
2eb4			 
2eb4			 
2eb4				if DEBUG_FORTH_WORDS 
2eb4					DMARK "LSt" 
2eb4 f5				push af  
2eb5 3a c9 2e			ld a, (.dmark)  
2eb8 32 6e fe			ld (debug_mark),a  
2ebb 3a ca 2e			ld a, (.dmark+1)  
2ebe 32 6f fe			ld (debug_mark+1),a  
2ec1 3a cb 2e			ld a, (.dmark+2)  
2ec4 32 70 fe			ld (debug_mark+2),a  
2ec7 18 03			jr .pastdmark  
2ec9 ..			.dmark: db "LSt"  
2ecc f1			.pastdmark: pop af  
2ecd			endm  
# End of macro DMARK
2ecd					CALLMONITOR 
2ecd cd 9e 19			call break_point_state  
2ed0				endm  
# End of macro CALLMONITOR
2ed0				endif 
2ed0			 
2ed0			; cant push right now due to tokenised strings  
2ed0			 
2ed0			; get the destination of where to copy this definition to. 
2ed0			 
2ed0 c5					push bc 
2ed1 d1					pop de 
2ed2			 
2ed2 7e			.listl:         ld a,(hl) 
2ed3 fe 00				cp 0 
2ed5 28 09				jr z, .lreplsp     ; replace zero with space 
2ed7					;cp FORTH_END_BUFFER 
2ed7 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ed9 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2edb				 
2edb					; just copy this char as is then 
2edb			 
2edb 12					ld (de), a 
2edc			 
2edc 23			.listnxt:	inc hl 
2edd 13					inc de 
2ede 18 f2				jr .listl 
2ee0			 
2ee0 3e 20		.lreplsp:	ld a,' ' 
2ee2 12					ld (de), a 
2ee3 18 f7				jr .listnxt 
2ee5			 
2ee5			; close up uword def 
2ee5			 
2ee5			.listdone: 
2ee5 12					ld (de), a 
2ee6 13					inc de 
2ee7 3e 00				ld a, 0 
2ee9 12					ld (de), a 
2eea			 
2eea			; now have def so clean up and push to stack 
2eea			 
2eea 21 c8 f1				ld hl, scratch 
2eed				if DEBUG_FORTH_WORDS 
2eed					DMARK "Ltp" 
2eed f5				push af  
2eee 3a 02 2f			ld a, (.dmark)  
2ef1 32 6e fe			ld (debug_mark),a  
2ef4 3a 03 2f			ld a, (.dmark+1)  
2ef7 32 6f fe			ld (debug_mark+1),a  
2efa 3a 04 2f			ld a, (.dmark+2)  
2efd 32 70 fe			ld (debug_mark+2),a  
2f00 18 03			jr .pastdmark  
2f02 ..			.dmark: db "Ltp"  
2f05 f1			.pastdmark: pop af  
2f06			endm  
# End of macro DMARK
2f06					CALLMONITOR 
2f06 cd 9e 19			call break_point_state  
2f09				endm  
# End of macro CALLMONITOR
2f09				endif 
2f09			 
2f09 18 1f			jr .listpush 
2f0b			 
2f0b			;.lnuword:	pop hl 
2f0b			;		call forth_tok_next 
2f0b			;		jp .ldouscan  
2f0b			 
2f0b			.lunotfound:		  
2f0b			 
2f0b				if DEBUG_FORTH_WORDS 
2f0b					DMARK "LSn" 
2f0b f5				push af  
2f0c 3a 20 2f			ld a, (.dmark)  
2f0f 32 6e fe			ld (debug_mark),a  
2f12 3a 21 2f			ld a, (.dmark+1)  
2f15 32 6f fe			ld (debug_mark+1),a  
2f18 3a 22 2f			ld a, (.dmark+2)  
2f1b 32 70 fe			ld (debug_mark+2),a  
2f1e 18 03			jr .pastdmark  
2f20 ..			.dmark: db "LSn"  
2f23 f1			.pastdmark: pop af  
2f24			endm  
# End of macro DMARK
2f24					CALLMONITOR 
2f24 cd 9e 19			call break_point_state  
2f27				endm  
# End of macro CALLMONITOR
2f27				endif 
2f27			 
2f27					 
2f27			;		FORTH_DSP_POP 
2f27			;		ld hl, .luno 
2f27			 
2f27					NEXTW			 
2f27 c3 16 24			jp macro_next 
2f2a				endm 
# End of macro NEXTW
2f2a			 
2f2a			.listpush: 
2f2a				if DEBUG_FORTH_WORDS 
2f2a					DMARK "LS>" 
2f2a f5				push af  
2f2b 3a 3f 2f			ld a, (.dmark)  
2f2e 32 6e fe			ld (debug_mark),a  
2f31 3a 40 2f			ld a, (.dmark+1)  
2f34 32 6f fe			ld (debug_mark+1),a  
2f37 3a 41 2f			ld a, (.dmark+2)  
2f3a 32 70 fe			ld (debug_mark+2),a  
2f3d 18 03			jr .pastdmark  
2f3f ..			.dmark: db "LS>"  
2f42 f1			.pastdmark: pop af  
2f43			endm  
# End of macro DMARK
2f43					CALLMONITOR 
2f43 cd 9e 19			call break_point_state  
2f46				endm  
# End of macro CALLMONITOR
2f46				endif 
2f46 cd d7 20				call forth_push_str 
2f49			 
2f49			 
2f49			 
2f49					NEXTW 
2f49 c3 16 24			jp macro_next 
2f4c				endm 
# End of macro NEXTW
2f4c			 
2f4c			;.luno:    db "Word not found",0 
2f4c			 
2f4c			 
2f4c			 
2f4c			 
2f4c			 
2f4c			;		push hl   ; save pointer to start of uword def string 
2f4c			; 
2f4c			;; look for FORTH_EOL_LINE 
2f4c			;		ld a, FORTH_END_BUFFER 
2f4c			;		call strlent 
2f4c			; 
2f4c			;		inc hl		 ; space for coln def 
2f4c			;		inc hl 
2f4c			;		inc hl          ; space for terms 
2f4c			;		inc hl 
2f4c			; 
2f4c			;		ld a, 20   ; TODO get actual length 
2f4c			;		call addatohl    ; include a random amount of room for the uword name 
2f4c			; 
2f4c			;		 
2f4c			;	if DEBUG_FORTH_WORDS 
2f4c			;		DMARK "Lt1" 
2f4c			;		CALLMONITOR 
2f4c			;	endif 
2f4c			;		 
2f4c			; 
2f4c			;; malloc space for the string because we cant change it 
2f4c			; 
2f4c			;		call malloc 
2f4c			;	if DEBUG_FORTH_MALLOC_GUARD 
2f4c			;		push af 
2f4c			;		call ishlzero 
2f4c			;		pop af 
2f4c			;		 
2f4c			;		call z,malloc_error 
2f4c			;	endif 
2f4c			; 
2f4c			;	if DEBUG_FORTH_WORDS 
2f4c			;		DMARK "Lt2" 
2f4c			;		CALLMONITOR 
2f4c			;	endif 
2f4c			;		pop de 
2f4c			;		push hl    ; push the malloc to release later 
2f4c			;		push hl   ;  push back a copy for the later stack push 
2f4c			;		 
2f4c			;; copy the string swapping out the zero terms for spaces 
2f4c			; 
2f4c			;		; de has our source 
2f4c			;		; hl has our dest 
2f4c			; 
2f4c			;; add the coln def 
2f4c			; 
2f4c			;		ld a, ':' 
2f4c			;		ld (hl), a 
2f4c			;		inc hl 
2f4c			;		ld a, ' ' 
2f4c			;		ld (hl), a 
2f4c			;		inc hl 
2f4c			; 
2f4c			;; add the uname word 
2f4c			;		push de   ; save our string for now 
2f4c			;		ex de, hl 
2f4c			; 
2f4c			;		FORTH_DSP_VALUE 
2f4c			;		;v5 FORTH_DSP_VALUE 
2f4c			; 
2f4c			;		inc hl   ; skip type but we know by now this is OK 
2f4c			; 
2f4c			;.luword:	ld a,(hl) 
2f4c			;		cp 0 
2f4c			;		jr z, .luword2 
2f4c			;		ld (de), a 
2f4c			;		inc de 
2f4c			;		inc hl 
2f4c			;		jr .luword 
2f4c			; 
2f4c			;.luword2:	ld a, ' ' 
2f4c			;		ld (de), a 
2f4c			;;		inc hl 
2f4c			;;		inc de 
2f4c			;;		ld (de), a 
2f4c			;;		inc hl 
2f4c			;		inc de 
2f4c			; 
2f4c			;		ex de, hl 
2f4c			;		pop de 
2f4c			;		 
2f4c			;		 
2f4c			; 
2f4c			;; detoken that string and copy it 
2f4c			; 
2f4c			;	if DEBUG_FORTH_WORDS 
2f4c			;		DMARK "Lt2" 
2f4c			;		CALLMONITOR 
2f4c			;	endif 
2f4c			;.ldetok:	ld a, (de) 
2f4c			;		cp FORTH_END_BUFFER 
2f4c			;		jr z, .ldetokend 
2f4c			;		; swap out any zero term for space 
2f4c			;		cp 0 
2f4c			;		jr nz, .ldetoknext 
2f4c			;		ld a, ' ' 
2f4c			; 
2f4c			;	if DEBUG_FORTH_WORDS 
2f4c			;		DMARK "LtS" 
2f4c			;		CALLMONITOR 
2f4c			;	endif 
2f4c			;.ldetoknext:	ld (hl), a 
2f4c			;		inc de 
2f4c			;		inc hl 
2f4c			;		jr .ldetok 
2f4c			; 
2f4c			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2f4c			;		ld (hl), a  
2f4c			; 
2f4c			;; free that temp malloc 
2f4c			; 
2f4c			;		pop hl    
2f4c			; 
2f4c			;	if DEBUG_FORTH_WORDS 
2f4c			;		DMARK "Lt4" 
2f4c			;		CALLMONITOR 
2f4c			;	endif 
2f4c			;		call forth_apushstrhl 
2f4c			; 
2f4c			;		; get rid of temp malloc area 
2f4c			; 
2f4c			;		pop hl 
2f4c			;		call free 
2f4c			; 
2f4c			;		jr .ludone 
2f4c			; 
2f4c			;.lnuword:	pop hl 
2f4c			;		call forth_tok_next 
2f4c			;		jp .ldouscan  
2f4c			; 
2f4c			;.ludone:		 pop hl 
2f4c			; 
2f4c					NEXTW 
2f4c c3 16 24			jp macro_next 
2f4f				endm 
# End of macro NEXTW
2f4f			 
2f4f			.FORGET: 
2f4f				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2f4f 5d				db WORD_SYS_CORE+73             
2f50 c8 2f			dw .NOP            
2f52 07				db 6 + 1 
2f53 .. 00			db "FORGET",0              
2f5a				endm 
# End of macro CWHEAD
2f5a			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2f5a			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2f5a			; | |  
2f5a			; | | e.g. "MORE" forget 
2f5a					if DEBUG_FORTH_WORDS_KEY 
2f5a						DMARK "FRG" 
2f5a f5				push af  
2f5b 3a 6f 2f			ld a, (.dmark)  
2f5e 32 6e fe			ld (debug_mark),a  
2f61 3a 70 2f			ld a, (.dmark+1)  
2f64 32 6f fe			ld (debug_mark+1),a  
2f67 3a 71 2f			ld a, (.dmark+2)  
2f6a 32 70 fe			ld (debug_mark+2),a  
2f6d 18 03			jr .pastdmark  
2f6f ..			.dmark: db "FRG"  
2f72 f1			.pastdmark: pop af  
2f73			endm  
# End of macro DMARK
2f73						CALLMONITOR 
2f73 cd 9e 19			call break_point_state  
2f76				endm  
# End of macro CALLMONITOR
2f76					endif 
2f76			 
2f76				; find uword 
2f76			        ; update start of word with "_" 
2f76				; replace uword with deleted flag 
2f76			 
2f76			 
2f76			;	if DEBUG_FORTH_WORDS 
2f76			;		DMARK "FOG" 
2f76			;		CALLMONITOR 
2f76			;	endif 
2f76			 
2f76			 
2f76					; Get ptr to the word we need to look up 
2f76			 
2f76					FORTH_DSP_VALUEHL 
2f76 cd 60 22			call macro_dsp_valuehl 
2f79				endm 
# End of macro FORTH_DSP_VALUEHL
2f79					;v5 FORTH_DSP_VALUE 
2f79				; TODO type check 
2f79			;		inc hl    ; Skip type check  
2f79 e5					push hl 
2f7a c1					pop bc 
2f7b			;		ex de, hl    ; put into DE 
2f7b			 
2f7b			 
2f7b 21 00 80				ld hl, baseram 
2f7e					;ld hl, baseusermem 
2f7e			 
2f7e				; skip dict stub 
2f7e			;	call forth_tok_next 
2f7e e5			push hl   ; sacreifical push 
2f7f			 
2f7f			.fldouscanm: 
2f7f e1				pop hl 
2f80			.fldouscan: 
2f80			;	if DEBUG_FORTH_WORDS 
2f80			;		DMARK "LSs" 
2f80			;		CALLMONITOR 
2f80			;	endif 
2f80				; skip dict stub 
2f80 cd 67 25				call forth_tok_next 
2f83			 
2f83			 
2f83			; while we have words to look for 
2f83			 
2f83 7e				ld a, (hl)      
2f84			;	if DEBUG_FORTH_WORDS 
2f84			;		DMARK "LSk" 
2f84			;		CALLMONITOR 
2f84			;	endif 
2f84 fe 00				cp WORD_SYS_END 
2f86 ca c2 2f				jp z, .flunotfound 
2f89 fe 01				cp WORD_SYS_UWORD 
2f8b c2 80 2f				jp nz, .fldouscan 
2f8e			 
2f8e			;	if DEBUG_FORTH_WORDS 
2f8e			;		DMARK "LSu" 
2f8e			;		CALLMONITOR 
2f8e			;	endif 
2f8e			 
2f8e					; found a uword but is it the one we want... 
2f8e			 
2f8e c5					push bc     ; uword to find is on bc 
2f8f d1					pop de 
2f90			 
2f90 e5					push hl  ; to save the ptr 
2f91			 
2f91					; skip opcode 
2f91 23					inc hl  
2f92					; skip next ptr 
2f92 23					inc hl  
2f93 23					inc hl 
2f94					; skip len 
2f94 23					inc hl 
2f95			 
2f95			;	if DEBUG_FORTH_WORDS 
2f95			;		DMARK "LSc" 
2f95			;		CALLMONITOR 
2f95			;	endif 
2f95 cd e2 13				call strcmp 
2f98 c2 7f 2f				jp nz, .fldouscanm 
2f9b			; 
2f9b			; 
2f9b			;; while we have words to look for 
2f9b			; 
2f9b			;.fdouscan:	ld a, (hl)      
2f9b			;	if DEBUG_FORTH_WORDS 
2f9b			;		DMARK "LSs" 
2f9b			;		CALLMONITOR 
2f9b			;	endif 
2f9b			;		cp WORD_SYS_END 
2f9b			;		jp z, .fudone 
2f9b			;		cp WORD_SYS_UWORD 
2f9b			;		jp nz, .fnuword 
2f9b			; 
2f9b			;	if DEBUG_FORTH_WORDS 
2f9b			;		DMARK "FGu" 
2f9b			;		CALLMONITOR 
2f9b			;	endif 
2f9b			; 
2f9b			;		; found a uword but is it the one we want... 
2f9b			; 
2f9b			; 
2f9b			;	        pop de   ; get back the dsp name 
2f9b			;		push de 
2f9b			; 
2f9b			;		push hl  ; to save the ptr 
2f9b			; 
2f9b			;		; skip opcode 
2f9b			;		inc hl  
2f9b			;		; skip next ptr 
2f9b			;		inc hl  
2f9b			;		inc hl 
2f9b			;		; skip len 
2f9b			;		inc hl 
2f9b			; 
2f9b			;	if DEBUG_FORTH_WORDS 
2f9b			;		DMARK "FGc" 
2f9b			;		CALLMONITOR 
2f9b			;	endif 
2f9b			;		call strcmp 
2f9b			;		jp nz, .fnuword 
2f9b			 
2f9b			 
2f9b e1			pop hl 
2f9c			 
2f9c				 
2f9c				if DEBUG_FORTH_WORDS 
2f9c					DMARK "FGm" 
2f9c f5				push af  
2f9d 3a b1 2f			ld a, (.dmark)  
2fa0 32 6e fe			ld (debug_mark),a  
2fa3 3a b2 2f			ld a, (.dmark+1)  
2fa6 32 6f fe			ld (debug_mark+1),a  
2fa9 3a b3 2f			ld a, (.dmark+2)  
2fac 32 70 fe			ld (debug_mark+2),a  
2faf 18 03			jr .pastdmark  
2fb1 ..			.dmark: db "FGm"  
2fb4 f1			.pastdmark: pop af  
2fb5			endm  
# End of macro DMARK
2fb5					CALLMONITOR 
2fb5 cd 9e 19			call break_point_state  
2fb8				endm  
# End of macro CALLMONITOR
2fb8				endif 
2fb8			 
2fb8			 
2fb8			 
2fb8					; we have a uword so push its name to the stack 
2fb8			 
2fb8			;	   	push hl  ; save so we can move to next dict block 
2fb8			;pop hl 
2fb8			 
2fb8					; update opcode to deleted 
2fb8 3e 03				ld a, WORD_SYS_DELETED 
2fba 77					ld (hl), a 
2fbb			 
2fbb 23					inc hl  
2fbc					; skip next ptr 
2fbc 23					inc hl  
2fbd 23					inc hl 
2fbe					; skip len 
2fbe 23					inc hl 
2fbf			 
2fbf					; TODO change parser to skip deleted words but for now mark it out 
2fbf 3e 5f				ld a, "_" 
2fc1 77					ld  (hl),a 
2fc2			 
2fc2			;		jr .fudone 
2fc2			; 
2fc2			;.fnuword:	pop hl 
2fc2			;		call forth_tok_next 
2fc2			;		jp .fdouscan  
2fc2			 
2fc2			.flunotfound:		  
2fc2			 
2fc2			 
2fc2					 
2fc2					FORTH_DSP_POP 
2fc2 cd 18 23			call macro_forth_dsp_pop 
2fc5				endm 
# End of macro FORTH_DSP_POP
2fc5			;		ld hl, .luno 
2fc5			;.fudone:		 pop hl 
2fc5					NEXTW 
2fc5 c3 16 24			jp macro_next 
2fc8				endm 
# End of macro NEXTW
2fc8			.NOP: 
2fc8				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2fc8 61				db WORD_SYS_CORE+77             
2fc9 ef 2f			dw .COMO            
2fcb 04				db 3 + 1 
2fcc .. 00			db "NOP",0              
2fd0				endm 
# End of macro CWHEAD
2fd0			; | NOP (  --  ) Do nothing | DONE 
2fd0					if DEBUG_FORTH_WORDS_KEY 
2fd0						DMARK "NOP" 
2fd0 f5				push af  
2fd1 3a e5 2f			ld a, (.dmark)  
2fd4 32 6e fe			ld (debug_mark),a  
2fd7 3a e6 2f			ld a, (.dmark+1)  
2fda 32 6f fe			ld (debug_mark+1),a  
2fdd 3a e7 2f			ld a, (.dmark+2)  
2fe0 32 70 fe			ld (debug_mark+2),a  
2fe3 18 03			jr .pastdmark  
2fe5 ..			.dmark: db "NOP"  
2fe8 f1			.pastdmark: pop af  
2fe9			endm  
# End of macro DMARK
2fe9						CALLMONITOR 
2fe9 cd 9e 19			call break_point_state  
2fec				endm  
# End of macro CALLMONITOR
2fec					endif 
2fec				       NEXTW 
2fec c3 16 24			jp macro_next 
2fef				endm 
# End of macro NEXTW
2fef			.COMO: 
2fef				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2fef 6e				db WORD_SYS_CORE+90             
2ff0 41 30			dw .COMC            
2ff2 02				db 1 + 1 
2ff3 .. 00			db "(",0              
2ff5				endm 
# End of macro CWHEAD
2ff5			; | ( ( -- )  Start of comment | DONE 
2ff5			 
2ff5			 
2ff5 2a c9 f4				ld hl, ( os_tok_ptr) 
2ff8 11 3c 30			ld de, .closepar 
2ffb					 
2ffb					if DEBUG_FORTH_WORDS 
2ffb						DMARK ").." 
2ffb f5				push af  
2ffc 3a 10 30			ld a, (.dmark)  
2fff 32 6e fe			ld (debug_mark),a  
3002 3a 11 30			ld a, (.dmark+1)  
3005 32 6f fe			ld (debug_mark+1),a  
3008 3a 12 30			ld a, (.dmark+2)  
300b 32 70 fe			ld (debug_mark+2),a  
300e 18 03			jr .pastdmark  
3010 ..			.dmark: db ").."  
3013 f1			.pastdmark: pop af  
3014			endm  
# End of macro DMARK
3014						CALLMONITOR 
3014 cd 9e 19			call break_point_state  
3017				endm  
# End of macro CALLMONITOR
3017					endif 
3017 cd 31 25			call findnexttok  
301a			 
301a					if DEBUG_FORTH_WORDS 
301a						DMARK "IF5" 
301a f5				push af  
301b 3a 2f 30			ld a, (.dmark)  
301e 32 6e fe			ld (debug_mark),a  
3021 3a 30 30			ld a, (.dmark+1)  
3024 32 6f fe			ld (debug_mark+1),a  
3027 3a 31 30			ld a, (.dmark+2)  
302a 32 70 fe			ld (debug_mark+2),a  
302d 18 03			jr .pastdmark  
302f ..			.dmark: db "IF5"  
3032 f1			.pastdmark: pop af  
3033			endm  
# End of macro DMARK
3033						CALLMONITOR 
3033 cd 9e 19			call break_point_state  
3036				endm  
# End of macro CALLMONITOR
3036					endif 
3036				; replace below with ) exec using tok_ptr 
3036 22 c9 f4			ld (os_tok_ptr), hl 
3039 c3 a7 24			jp exec1 
303c			 
303c .. 00			.closepar:   db ")",0 
303e			 
303e				       NEXTW 
303e c3 16 24			jp macro_next 
3041				endm 
# End of macro NEXTW
3041			.COMC: 
3041				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
3041 6f				db WORD_SYS_CORE+91             
3042 4a 30			dw .SCRATCH            
3044 02				db 1 + 1 
3045 .. 00			db ")",0              
3047				endm 
# End of macro CWHEAD
3047			; | ) ( -- )  End of comment |  DONE  
3047				       NEXTW 
3047 c3 16 24			jp macro_next 
304a				endm 
# End of macro NEXTW
304a			 
304a			.SCRATCH: 
304a				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
304a 6f				db WORD_SYS_CORE+91             
304b 85 30			dw .INC            
304d 08				db 7 + 1 
304e .. 00			db "SCRATCH",0              
3056				endm 
# End of macro CWHEAD
3056			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3056			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3056			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3056			; | |  
3056			; | | e.g.    : score $00 scratch ; 
3056			; | |  
3056			; | | $00 score ! 
3056			; | | $01 score +! 
3056			; | |  
3056			; | | e.g.   : varword $0a scratch ;  
3056			; | | 
3056			; | | $8000 varword ! 
3056					if DEBUG_FORTH_WORDS_KEY 
3056						DMARK "SCR" 
3056 f5				push af  
3057 3a 6b 30			ld a, (.dmark)  
305a 32 6e fe			ld (debug_mark),a  
305d 3a 6c 30			ld a, (.dmark+1)  
3060 32 6f fe			ld (debug_mark+1),a  
3063 3a 6d 30			ld a, (.dmark+2)  
3066 32 70 fe			ld (debug_mark+2),a  
3069 18 03			jr .pastdmark  
306b ..			.dmark: db "SCR"  
306e f1			.pastdmark: pop af  
306f			endm  
# End of macro DMARK
306f						CALLMONITOR 
306f cd 9e 19			call break_point_state  
3072				endm  
# End of macro CALLMONITOR
3072					endif 
3072			 
3072					FORTH_DSP_VALUEHL 
3072 cd 60 22			call macro_dsp_valuehl 
3075				endm 
# End of macro FORTH_DSP_VALUEHL
3075				 
3075					FORTH_DSP_POP 
3075 cd 18 23			call macro_forth_dsp_pop 
3078				endm 
# End of macro FORTH_DSP_POP
3078			 
3078 7d					ld a, l 
3079 21 ed f6				ld hl, os_var_array 
307c cd 4c 0f				call addatohl 
307f			 
307f cd 69 20				call forth_push_numhl 
3082			 
3082				       NEXTW 
3082 c3 16 24			jp macro_next 
3085				endm 
# End of macro NEXTW
3085			 
3085			.INC: 
3085				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3085 6f				db WORD_SYS_CORE+91             
3086 d9 30			dw .DEC            
3088 03				db 2 + 1 
3089 .. 00			db "+!",0              
308c				endm 
# End of macro CWHEAD
308c			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
308c					if DEBUG_FORTH_WORDS_KEY 
308c						DMARK "+s_" 
308c f5				push af  
308d 3a a1 30			ld a, (.dmark)  
3090 32 6e fe			ld (debug_mark),a  
3093 3a a2 30			ld a, (.dmark+1)  
3096 32 6f fe			ld (debug_mark+1),a  
3099 3a a3 30			ld a, (.dmark+2)  
309c 32 70 fe			ld (debug_mark+2),a  
309f 18 03			jr .pastdmark  
30a1 ..			.dmark: db "+s_"  
30a4 f1			.pastdmark: pop af  
30a5			endm  
# End of macro DMARK
30a5						CALLMONITOR 
30a5 cd 9e 19			call break_point_state  
30a8				endm  
# End of macro CALLMONITOR
30a8					endif 
30a8			 
30a8					FORTH_DSP_VALUEHL 
30a8 cd 60 22			call macro_dsp_valuehl 
30ab				endm 
# End of macro FORTH_DSP_VALUEHL
30ab			 
30ab e5					push hl   ; save address 
30ac			 
30ac					FORTH_DSP_POP 
30ac cd 18 23			call macro_forth_dsp_pop 
30af				endm 
# End of macro FORTH_DSP_POP
30af			 
30af					FORTH_DSP_VALUEHL 
30af cd 60 22			call macro_dsp_valuehl 
30b2				endm 
# End of macro FORTH_DSP_VALUEHL
30b2			 
30b2					FORTH_DSP_POP 
30b2 cd 18 23			call macro_forth_dsp_pop 
30b5				endm 
# End of macro FORTH_DSP_POP
30b5			 
30b5					; hl contains value to add to byte at a 
30b5				 
30b5 eb					ex de, hl 
30b6			 
30b6 e1					pop hl 
30b7			 
30b7					if DEBUG_FORTH_WORDS 
30b7						DMARK "INC" 
30b7 f5				push af  
30b8 3a cc 30			ld a, (.dmark)  
30bb 32 6e fe			ld (debug_mark),a  
30be 3a cd 30			ld a, (.dmark+1)  
30c1 32 6f fe			ld (debug_mark+1),a  
30c4 3a ce 30			ld a, (.dmark+2)  
30c7 32 70 fe			ld (debug_mark+2),a  
30ca 18 03			jr .pastdmark  
30cc ..			.dmark: db "INC"  
30cf f1			.pastdmark: pop af  
30d0			endm  
# End of macro DMARK
30d0						CALLMONITOR 
30d0 cd 9e 19			call break_point_state  
30d3				endm  
# End of macro CALLMONITOR
30d3					endif 
30d3			 
30d3 7e					ld a,(hl) 
30d4 83					add e 
30d5 77					ld (hl),a 
30d6			 
30d6			 
30d6			 
30d6				       NEXTW 
30d6 c3 16 24			jp macro_next 
30d9				endm 
# End of macro NEXTW
30d9			 
30d9			.DEC: 
30d9				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
30d9 6f				db WORD_SYS_CORE+91             
30da 2a 31			dw .INC2            
30dc 03				db 2 + 1 
30dd .. 00			db "-!",0              
30e0				endm 
# End of macro CWHEAD
30e0			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
30e0					if DEBUG_FORTH_WORDS_KEY 
30e0						DMARK "-s_" 
30e0 f5				push af  
30e1 3a f5 30			ld a, (.dmark)  
30e4 32 6e fe			ld (debug_mark),a  
30e7 3a f6 30			ld a, (.dmark+1)  
30ea 32 6f fe			ld (debug_mark+1),a  
30ed 3a f7 30			ld a, (.dmark+2)  
30f0 32 70 fe			ld (debug_mark+2),a  
30f3 18 03			jr .pastdmark  
30f5 ..			.dmark: db "-s_"  
30f8 f1			.pastdmark: pop af  
30f9			endm  
# End of macro DMARK
30f9						CALLMONITOR 
30f9 cd 9e 19			call break_point_state  
30fc				endm  
# End of macro CALLMONITOR
30fc					endif 
30fc			 
30fc					FORTH_DSP_VALUEHL 
30fc cd 60 22			call macro_dsp_valuehl 
30ff				endm 
# End of macro FORTH_DSP_VALUEHL
30ff			 
30ff e5					push hl   ; save address 
3100			 
3100					FORTH_DSP_POP 
3100 cd 18 23			call macro_forth_dsp_pop 
3103				endm 
# End of macro FORTH_DSP_POP
3103			 
3103					FORTH_DSP_VALUEHL 
3103 cd 60 22			call macro_dsp_valuehl 
3106				endm 
# End of macro FORTH_DSP_VALUEHL
3106			 
3106					; hl contains value to add to byte at a 
3106				 
3106 eb					ex de, hl 
3107			 
3107 e1					pop hl 
3108			 
3108					if DEBUG_FORTH_WORDS 
3108						DMARK "DEC" 
3108 f5				push af  
3109 3a 1d 31			ld a, (.dmark)  
310c 32 6e fe			ld (debug_mark),a  
310f 3a 1e 31			ld a, (.dmark+1)  
3112 32 6f fe			ld (debug_mark+1),a  
3115 3a 1f 31			ld a, (.dmark+2)  
3118 32 70 fe			ld (debug_mark+2),a  
311b 18 03			jr .pastdmark  
311d ..			.dmark: db "DEC"  
3120 f1			.pastdmark: pop af  
3121			endm  
# End of macro DMARK
3121						CALLMONITOR 
3121 cd 9e 19			call break_point_state  
3124				endm  
# End of macro CALLMONITOR
3124					endif 
3124			 
3124 7e					ld a,(hl) 
3125 93					sub e 
3126 77					ld (hl),a 
3127			 
3127			 
3127			 
3127				       NEXTW 
3127 c3 16 24			jp macro_next 
312a				endm 
# End of macro NEXTW
312a			 
312a			.INC2: 
312a				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
312a 6f				db WORD_SYS_CORE+91             
312b d4 31			dw .DEC2            
312d 04				db 3 + 1 
312e .. 00			db "+2!",0              
3132				endm 
# End of macro CWHEAD
3132			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3132			 
3132					if DEBUG_FORTH_WORDS_KEY 
3132						DMARK "+2s" 
3132 f5				push af  
3133 3a 47 31			ld a, (.dmark)  
3136 32 6e fe			ld (debug_mark),a  
3139 3a 48 31			ld a, (.dmark+1)  
313c 32 6f fe			ld (debug_mark+1),a  
313f 3a 49 31			ld a, (.dmark+2)  
3142 32 70 fe			ld (debug_mark+2),a  
3145 18 03			jr .pastdmark  
3147 ..			.dmark: db "+2s"  
314a f1			.pastdmark: pop af  
314b			endm  
# End of macro DMARK
314b						CALLMONITOR 
314b cd 9e 19			call break_point_state  
314e				endm  
# End of macro CALLMONITOR
314e					endif 
314e			 
314e					; Address 
314e			 
314e					FORTH_DSP_VALUEHL 
314e cd 60 22			call macro_dsp_valuehl 
3151				endm 
# End of macro FORTH_DSP_VALUEHL
3151			 
3151 e5					push hl    ; save address 
3152			 
3152					; load content into de 
3152			 
3152 5e					ld e,(hl) 
3153 23					inc hl 
3154 56					ld d, (hl) 
3155			 
3155					if DEBUG_FORTH_WORDS 
3155						DMARK "+2a" 
3155 f5				push af  
3156 3a 6a 31			ld a, (.dmark)  
3159 32 6e fe			ld (debug_mark),a  
315c 3a 6b 31			ld a, (.dmark+1)  
315f 32 6f fe			ld (debug_mark+1),a  
3162 3a 6c 31			ld a, (.dmark+2)  
3165 32 70 fe			ld (debug_mark+2),a  
3168 18 03			jr .pastdmark  
316a ..			.dmark: db "+2a"  
316d f1			.pastdmark: pop af  
316e			endm  
# End of macro DMARK
316e						CALLMONITOR 
316e cd 9e 19			call break_point_state  
3171				endm  
# End of macro CALLMONITOR
3171					endif 
3171			 
3171					FORTH_DSP_POP 
3171 cd 18 23			call macro_forth_dsp_pop 
3174				endm 
# End of macro FORTH_DSP_POP
3174			 
3174					; Get value to add 
3174			 
3174					FORTH_DSP_VALUE 
3174 cd 49 22			call macro_forth_dsp_value 
3177				endm 
# End of macro FORTH_DSP_VALUE
3177			 
3177					if DEBUG_FORTH_WORDS 
3177						DMARK "+2v" 
3177 f5				push af  
3178 3a 8c 31			ld a, (.dmark)  
317b 32 6e fe			ld (debug_mark),a  
317e 3a 8d 31			ld a, (.dmark+1)  
3181 32 6f fe			ld (debug_mark+1),a  
3184 3a 8e 31			ld a, (.dmark+2)  
3187 32 70 fe			ld (debug_mark+2),a  
318a 18 03			jr .pastdmark  
318c ..			.dmark: db "+2v"  
318f f1			.pastdmark: pop af  
3190			endm  
# End of macro DMARK
3190						CALLMONITOR 
3190 cd 9e 19			call break_point_state  
3193				endm  
# End of macro CALLMONITOR
3193					endif 
3193			 
3193 19					add hl, de 
3194			 
3194					if DEBUG_FORTH_WORDS 
3194						DMARK "+2+" 
3194 f5				push af  
3195 3a a9 31			ld a, (.dmark)  
3198 32 6e fe			ld (debug_mark),a  
319b 3a aa 31			ld a, (.dmark+1)  
319e 32 6f fe			ld (debug_mark+1),a  
31a1 3a ab 31			ld a, (.dmark+2)  
31a4 32 70 fe			ld (debug_mark+2),a  
31a7 18 03			jr .pastdmark  
31a9 ..			.dmark: db "+2+"  
31ac f1			.pastdmark: pop af  
31ad			endm  
# End of macro DMARK
31ad						CALLMONITOR 
31ad cd 9e 19			call break_point_state  
31b0				endm  
# End of macro CALLMONITOR
31b0					endif 
31b0			 
31b0					; move result to de 
31b0			 
31b0 eb					ex de, hl 
31b1			 
31b1					; Address 
31b1			 
31b1 e1					pop hl 
31b2			 
31b2					; save it back 
31b2			 
31b2 73					ld (hl), e 
31b3 23					inc hl 
31b4 72					ld (hl), d 
31b5			 
31b5					if DEBUG_FORTH_WORDS 
31b5						DMARK "+2e" 
31b5 f5				push af  
31b6 3a ca 31			ld a, (.dmark)  
31b9 32 6e fe			ld (debug_mark),a  
31bc 3a cb 31			ld a, (.dmark+1)  
31bf 32 6f fe			ld (debug_mark+1),a  
31c2 3a cc 31			ld a, (.dmark+2)  
31c5 32 70 fe			ld (debug_mark+2),a  
31c8 18 03			jr .pastdmark  
31ca ..			.dmark: db "+2e"  
31cd f1			.pastdmark: pop af  
31ce			endm  
# End of macro DMARK
31ce						CALLMONITOR 
31ce cd 9e 19			call break_point_state  
31d1				endm  
# End of macro CALLMONITOR
31d1					endif 
31d1			 
31d1			 
31d1			 
31d1			 
31d1			 
31d1				       NEXTW 
31d1 c3 16 24			jp macro_next 
31d4				endm 
# End of macro NEXTW
31d4			 
31d4			.DEC2: 
31d4				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
31d4 6f				db WORD_SYS_CORE+91             
31d5 80 32			dw .GET2            
31d7 04				db 3 + 1 
31d8 .. 00			db "-2!",0              
31dc				endm 
# End of macro CWHEAD
31dc			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
31dc			 
31dc			 
31dc					if DEBUG_FORTH_WORDS_KEY 
31dc						DMARK "-2s" 
31dc f5				push af  
31dd 3a f1 31			ld a, (.dmark)  
31e0 32 6e fe			ld (debug_mark),a  
31e3 3a f2 31			ld a, (.dmark+1)  
31e6 32 6f fe			ld (debug_mark+1),a  
31e9 3a f3 31			ld a, (.dmark+2)  
31ec 32 70 fe			ld (debug_mark+2),a  
31ef 18 03			jr .pastdmark  
31f1 ..			.dmark: db "-2s"  
31f4 f1			.pastdmark: pop af  
31f5			endm  
# End of macro DMARK
31f5						CALLMONITOR 
31f5 cd 9e 19			call break_point_state  
31f8				endm  
# End of macro CALLMONITOR
31f8					endif 
31f8			 
31f8					; Address 
31f8			 
31f8					FORTH_DSP_VALUEHL 
31f8 cd 60 22			call macro_dsp_valuehl 
31fb				endm 
# End of macro FORTH_DSP_VALUEHL
31fb			 
31fb e5					push hl    ; save address 
31fc			 
31fc					; load content into de 
31fc			 
31fc 5e					ld e,(hl) 
31fd 23					inc hl 
31fe 56					ld d, (hl) 
31ff			 
31ff					if DEBUG_FORTH_WORDS 
31ff						DMARK "-2a" 
31ff f5				push af  
3200 3a 14 32			ld a, (.dmark)  
3203 32 6e fe			ld (debug_mark),a  
3206 3a 15 32			ld a, (.dmark+1)  
3209 32 6f fe			ld (debug_mark+1),a  
320c 3a 16 32			ld a, (.dmark+2)  
320f 32 70 fe			ld (debug_mark+2),a  
3212 18 03			jr .pastdmark  
3214 ..			.dmark: db "-2a"  
3217 f1			.pastdmark: pop af  
3218			endm  
# End of macro DMARK
3218						CALLMONITOR 
3218 cd 9e 19			call break_point_state  
321b				endm  
# End of macro CALLMONITOR
321b					endif 
321b			 
321b					FORTH_DSP_POP 
321b cd 18 23			call macro_forth_dsp_pop 
321e				endm 
# End of macro FORTH_DSP_POP
321e			 
321e					; Get value to remove 
321e			 
321e					FORTH_DSP_VALUE 
321e cd 49 22			call macro_forth_dsp_value 
3221				endm 
# End of macro FORTH_DSP_VALUE
3221			 
3221					if DEBUG_FORTH_WORDS 
3221						DMARK "-2v" 
3221 f5				push af  
3222 3a 36 32			ld a, (.dmark)  
3225 32 6e fe			ld (debug_mark),a  
3228 3a 37 32			ld a, (.dmark+1)  
322b 32 6f fe			ld (debug_mark+1),a  
322e 3a 38 32			ld a, (.dmark+2)  
3231 32 70 fe			ld (debug_mark+2),a  
3234 18 03			jr .pastdmark  
3236 ..			.dmark: db "-2v"  
3239 f1			.pastdmark: pop af  
323a			endm  
# End of macro DMARK
323a						CALLMONITOR 
323a cd 9e 19			call break_point_state  
323d				endm  
# End of macro CALLMONITOR
323d					endif 
323d			 
323d eb					ex de, hl 
323e ed 52				sbc hl, de 
3240			 
3240					if DEBUG_FORTH_WORDS 
3240						DMARK "-2d" 
3240 f5				push af  
3241 3a 55 32			ld a, (.dmark)  
3244 32 6e fe			ld (debug_mark),a  
3247 3a 56 32			ld a, (.dmark+1)  
324a 32 6f fe			ld (debug_mark+1),a  
324d 3a 57 32			ld a, (.dmark+2)  
3250 32 70 fe			ld (debug_mark+2),a  
3253 18 03			jr .pastdmark  
3255 ..			.dmark: db "-2d"  
3258 f1			.pastdmark: pop af  
3259			endm  
# End of macro DMARK
3259						CALLMONITOR 
3259 cd 9e 19			call break_point_state  
325c				endm  
# End of macro CALLMONITOR
325c					endif 
325c			 
325c					; move result to de 
325c			 
325c eb					ex de, hl 
325d			 
325d					; Address 
325d			 
325d e1					pop hl 
325e			 
325e					; save it back 
325e			 
325e 73					ld (hl), e 
325f 23					inc hl 
3260 72					ld (hl), d 
3261			 
3261					if DEBUG_FORTH_WORDS 
3261						DMARK "-2e" 
3261 f5				push af  
3262 3a 76 32			ld a, (.dmark)  
3265 32 6e fe			ld (debug_mark),a  
3268 3a 77 32			ld a, (.dmark+1)  
326b 32 6f fe			ld (debug_mark+1),a  
326e 3a 78 32			ld a, (.dmark+2)  
3271 32 70 fe			ld (debug_mark+2),a  
3274 18 03			jr .pastdmark  
3276 ..			.dmark: db "-2e"  
3279 f1			.pastdmark: pop af  
327a			endm  
# End of macro DMARK
327a						CALLMONITOR 
327a cd 9e 19			call break_point_state  
327d				endm  
# End of macro CALLMONITOR
327d					endif 
327d			 
327d			 
327d			 
327d			 
327d			 
327d				       NEXTW 
327d c3 16 24			jp macro_next 
3280				endm 
# End of macro NEXTW
3280			.GET2: 
3280				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3280 6f				db WORD_SYS_CORE+91             
3281 b0 32			dw .BANG2            
3283 03				db 2 + 1 
3284 .. 00			db "2@",0              
3287				endm 
# End of macro CWHEAD
3287			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3287					if DEBUG_FORTH_WORDS_KEY 
3287						DMARK "2A_" 
3287 f5				push af  
3288 3a 9c 32			ld a, (.dmark)  
328b 32 6e fe			ld (debug_mark),a  
328e 3a 9d 32			ld a, (.dmark+1)  
3291 32 6f fe			ld (debug_mark+1),a  
3294 3a 9e 32			ld a, (.dmark+2)  
3297 32 70 fe			ld (debug_mark+2),a  
329a 18 03			jr .pastdmark  
329c ..			.dmark: db "2A_"  
329f f1			.pastdmark: pop af  
32a0			endm  
# End of macro DMARK
32a0						CALLMONITOR 
32a0 cd 9e 19			call break_point_state  
32a3				endm  
# End of macro CALLMONITOR
32a3					endif 
32a3			 
32a3					FORTH_DSP_VALUEHL 
32a3 cd 60 22			call macro_dsp_valuehl 
32a6				endm 
# End of macro FORTH_DSP_VALUEHL
32a6			 
32a6 5e					ld e, (hl) 
32a7 23					inc hl 
32a8 56					ld d, (hl) 
32a9			 
32a9 eb					ex de, hl 
32aa			 
32aa cd 69 20				call forth_push_numhl 
32ad			 
32ad				       NEXTW 
32ad c3 16 24			jp macro_next 
32b0				endm 
# End of macro NEXTW
32b0			.BANG2: 
32b0				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
32b0 6f				db WORD_SYS_CORE+91             
32b1 e8 32			dw .CONFIG            
32b3 03				db 2 + 1 
32b4 .. 00			db "2!",0              
32b7				endm 
# End of macro CWHEAD
32b7			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
32b7					if DEBUG_FORTH_WORDS_KEY 
32b7						DMARK "2S_" 
32b7 f5				push af  
32b8 3a cc 32			ld a, (.dmark)  
32bb 32 6e fe			ld (debug_mark),a  
32be 3a cd 32			ld a, (.dmark+1)  
32c1 32 6f fe			ld (debug_mark+1),a  
32c4 3a ce 32			ld a, (.dmark+2)  
32c7 32 70 fe			ld (debug_mark+2),a  
32ca 18 03			jr .pastdmark  
32cc ..			.dmark: db "2S_"  
32cf f1			.pastdmark: pop af  
32d0			endm  
# End of macro DMARK
32d0						CALLMONITOR 
32d0 cd 9e 19			call break_point_state  
32d3				endm  
# End of macro CALLMONITOR
32d3					endif 
32d3			 
32d3					FORTH_DSP_VALUEHL 
32d3 cd 60 22			call macro_dsp_valuehl 
32d6				endm 
# End of macro FORTH_DSP_VALUEHL
32d6			 
32d6 e5					push hl   ; save address 
32d7			 
32d7			 
32d7					FORTH_DSP_POP 
32d7 cd 18 23			call macro_forth_dsp_pop 
32da				endm 
# End of macro FORTH_DSP_POP
32da			 
32da					 
32da					FORTH_DSP_VALUEHL 
32da cd 60 22			call macro_dsp_valuehl 
32dd				endm 
# End of macro FORTH_DSP_VALUEHL
32dd			 
32dd					FORTH_DSP_POP 
32dd cd 18 23			call macro_forth_dsp_pop 
32e0				endm 
# End of macro FORTH_DSP_POP
32e0			 
32e0 eb					ex de, hl    ; value now in de 
32e1			 
32e1 e1					pop hl 
32e2			 
32e2 73					ld (hl), e 
32e3			 
32e3 23					inc hl 
32e4			 
32e4 72					ld (hl), d 
32e5			 
32e5			 
32e5				       NEXTW 
32e5 c3 16 24			jp macro_next 
32e8				endm 
# End of macro NEXTW
32e8			.CONFIG: 
32e8				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
32e8 6f				db WORD_SYS_CORE+91             
32e9 f9 32			dw .ENDCORE            
32eb 07				db 6 + 1 
32ec .. 00			db "CONFIG",0              
32f3				endm 
# End of macro CWHEAD
32f3			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
32f3			 
32f3 cd d6 15				call config 
32f6					NEXTW 
32f6 c3 16 24			jp macro_next 
32f9				endm 
# End of macro NEXTW
32f9			.ENDCORE: 
32f9			 
32f9			; eof 
32f9			 
32f9			 
# End of file forth_words_core.asm
32f9			include "forth_words_flow.asm" 
32f9			 
32f9			; | ## Program Flow Words 
32f9			 
32f9			.IF: 
32f9				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
32f9 1e				db WORD_SYS_CORE+10             
32fa ee 33			dw .THEN            
32fc 03				db 2 + 1 
32fd .. 00			db "IF",0              
3300				endm 
# End of macro CWHEAD
3300			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3300			; 
3300					if DEBUG_FORTH_WORDS_KEY 
3300						DMARK "IF." 
3300 f5				push af  
3301 3a 15 33			ld a, (.dmark)  
3304 32 6e fe			ld (debug_mark),a  
3307 3a 16 33			ld a, (.dmark+1)  
330a 32 6f fe			ld (debug_mark+1),a  
330d 3a 17 33			ld a, (.dmark+2)  
3310 32 70 fe			ld (debug_mark+2),a  
3313 18 03			jr .pastdmark  
3315 ..			.dmark: db "IF."  
3318 f1			.pastdmark: pop af  
3319			endm  
# End of macro DMARK
3319						CALLMONITOR 
3319 cd 9e 19			call break_point_state  
331c				endm  
# End of macro CALLMONITOR
331c					endif 
331c			; eval TOS 
331c			 
331c				FORTH_DSP_VALUEHL 
331c cd 60 22			call macro_dsp_valuehl 
331f				endm 
# End of macro FORTH_DSP_VALUEHL
331f			 
331f			;	push hl 
331f				FORTH_DSP_POP 
331f cd 18 23			call macro_forth_dsp_pop 
3322				endm 
# End of macro FORTH_DSP_POP
3322			;	pop hl 
3322			 
3322					if DEBUG_FORTH_WORDS 
3322						DMARK "IF1" 
3322 f5				push af  
3323 3a 37 33			ld a, (.dmark)  
3326 32 6e fe			ld (debug_mark),a  
3329 3a 38 33			ld a, (.dmark+1)  
332c 32 6f fe			ld (debug_mark+1),a  
332f 3a 39 33			ld a, (.dmark+2)  
3332 32 70 fe			ld (debug_mark+2),a  
3335 18 03			jr .pastdmark  
3337 ..			.dmark: db "IF1"  
333a f1			.pastdmark: pop af  
333b			endm  
# End of macro DMARK
333b						CALLMONITOR 
333b cd 9e 19			call break_point_state  
333e				endm  
# End of macro CALLMONITOR
333e					endif 
333e b7				or a        ; clear carry flag 
333f 11 00 00			ld de, 0 
3342 eb				ex de,hl 
3343 ed 52			sbc hl, de 
3345 c2 cf 33			jp nz, .iftrue 
3348			 
3348					if DEBUG_FORTH_WORDS 
3348						DMARK "IF2" 
3348 f5				push af  
3349 3a 5d 33			ld a, (.dmark)  
334c 32 6e fe			ld (debug_mark),a  
334f 3a 5e 33			ld a, (.dmark+1)  
3352 32 6f fe			ld (debug_mark+1),a  
3355 3a 5f 33			ld a, (.dmark+2)  
3358 32 70 fe			ld (debug_mark+2),a  
335b 18 03			jr .pastdmark  
335d ..			.dmark: db "IF2"  
3360 f1			.pastdmark: pop af  
3361			endm  
# End of macro DMARK
3361						CALLMONITOR 
3361 cd 9e 19			call break_point_state  
3364				endm  
# End of macro CALLMONITOR
3364					endif 
3364			 
3364			; if not true then skip to THEN 
3364			 
3364				; TODO get tok_ptr 
3364				; TODO consume toks until we get to THEN 
3364			 
3364 2a c9 f4			ld hl, (os_tok_ptr) 
3367					if DEBUG_FORTH_WORDS 
3367						DMARK "IF3" 
3367 f5				push af  
3368 3a 7c 33			ld a, (.dmark)  
336b 32 6e fe			ld (debug_mark),a  
336e 3a 7d 33			ld a, (.dmark+1)  
3371 32 6f fe			ld (debug_mark+1),a  
3374 3a 7e 33			ld a, (.dmark+2)  
3377 32 70 fe			ld (debug_mark+2),a  
337a 18 03			jr .pastdmark  
337c ..			.dmark: db "IF3"  
337f f1			.pastdmark: pop af  
3380			endm  
# End of macro DMARK
3380						CALLMONITOR 
3380 cd 9e 19			call break_point_state  
3383				endm  
# End of macro CALLMONITOR
3383						 
3383					endif 
3383 11 ca 33			ld de, .ifthen 
3386					if DEBUG_FORTH_WORDS 
3386						DMARK "IF4" 
3386 f5				push af  
3387 3a 9b 33			ld a, (.dmark)  
338a 32 6e fe			ld (debug_mark),a  
338d 3a 9c 33			ld a, (.dmark+1)  
3390 32 6f fe			ld (debug_mark+1),a  
3393 3a 9d 33			ld a, (.dmark+2)  
3396 32 70 fe			ld (debug_mark+2),a  
3399 18 03			jr .pastdmark  
339b ..			.dmark: db "IF4"  
339e f1			.pastdmark: pop af  
339f			endm  
# End of macro DMARK
339f						CALLMONITOR 
339f cd 9e 19			call break_point_state  
33a2				endm  
# End of macro CALLMONITOR
33a2					endif 
33a2 cd 31 25			call findnexttok  
33a5			 
33a5					if DEBUG_FORTH_WORDS 
33a5						DMARK "IF5" 
33a5 f5				push af  
33a6 3a ba 33			ld a, (.dmark)  
33a9 32 6e fe			ld (debug_mark),a  
33ac 3a bb 33			ld a, (.dmark+1)  
33af 32 6f fe			ld (debug_mark+1),a  
33b2 3a bc 33			ld a, (.dmark+2)  
33b5 32 70 fe			ld (debug_mark+2),a  
33b8 18 03			jr .pastdmark  
33ba ..			.dmark: db "IF5"  
33bd f1			.pastdmark: pop af  
33be			endm  
# End of macro DMARK
33be						CALLMONITOR 
33be cd 9e 19			call break_point_state  
33c1				endm  
# End of macro CALLMONITOR
33c1					endif 
33c1				; TODO replace below with ; exec using tok_ptr 
33c1 22 c9 f4			ld (os_tok_ptr), hl 
33c4 c3 a7 24			jp exec1 
33c7				NEXTW 
33c7 c3 16 24			jp macro_next 
33ca				endm 
# End of macro NEXTW
33ca			 
33ca .. 00		.ifthen:  db "THEN",0 
33cf			 
33cf			.iftrue:		 
33cf				; Exec next words normally 
33cf			 
33cf				; if true then exec following IF as normal 
33cf					if DEBUG_FORTH_WORDS 
33cf						DMARK "IFT" 
33cf f5				push af  
33d0 3a e4 33			ld a, (.dmark)  
33d3 32 6e fe			ld (debug_mark),a  
33d6 3a e5 33			ld a, (.dmark+1)  
33d9 32 6f fe			ld (debug_mark+1),a  
33dc 3a e6 33			ld a, (.dmark+2)  
33df 32 70 fe			ld (debug_mark+2),a  
33e2 18 03			jr .pastdmark  
33e4 ..			.dmark: db "IFT"  
33e7 f1			.pastdmark: pop af  
33e8			endm  
# End of macro DMARK
33e8						CALLMONITOR 
33e8 cd 9e 19			call break_point_state  
33eb				endm  
# End of macro CALLMONITOR
33eb					endif 
33eb			 
33eb					NEXTW 
33eb c3 16 24			jp macro_next 
33ee				endm 
# End of macro NEXTW
33ee			.THEN: 
33ee				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
33ee 1f				db WORD_SYS_CORE+11             
33ef 16 34			dw .ELSE            
33f1 05				db 4 + 1 
33f2 .. 00			db "THEN",0              
33f7				endm 
# End of macro CWHEAD
33f7			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
33f7					if DEBUG_FORTH_WORDS_KEY 
33f7						DMARK "THN" 
33f7 f5				push af  
33f8 3a 0c 34			ld a, (.dmark)  
33fb 32 6e fe			ld (debug_mark),a  
33fe 3a 0d 34			ld a, (.dmark+1)  
3401 32 6f fe			ld (debug_mark+1),a  
3404 3a 0e 34			ld a, (.dmark+2)  
3407 32 70 fe			ld (debug_mark+2),a  
340a 18 03			jr .pastdmark  
340c ..			.dmark: db "THN"  
340f f1			.pastdmark: pop af  
3410			endm  
# End of macro DMARK
3410						CALLMONITOR 
3410 cd 9e 19			call break_point_state  
3413				endm  
# End of macro CALLMONITOR
3413					endif 
3413					NEXTW 
3413 c3 16 24			jp macro_next 
3416				endm 
# End of macro NEXTW
3416			.ELSE: 
3416				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3416 20				db WORD_SYS_CORE+12             
3417 3e 34			dw .DO            
3419 03				db 2 + 1 
341a .. 00			db "ELSE",0              
341f				endm 
# End of macro CWHEAD
341f			; | ELSE ( -- ) Not supported - does nothing | TODO 
341f			 
341f					if DEBUG_FORTH_WORDS_KEY 
341f						DMARK "ELS" 
341f f5				push af  
3420 3a 34 34			ld a, (.dmark)  
3423 32 6e fe			ld (debug_mark),a  
3426 3a 35 34			ld a, (.dmark+1)  
3429 32 6f fe			ld (debug_mark+1),a  
342c 3a 36 34			ld a, (.dmark+2)  
342f 32 70 fe			ld (debug_mark+2),a  
3432 18 03			jr .pastdmark  
3434 ..			.dmark: db "ELS"  
3437 f1			.pastdmark: pop af  
3438			endm  
# End of macro DMARK
3438						CALLMONITOR 
3438 cd 9e 19			call break_point_state  
343b				endm  
# End of macro CALLMONITOR
343b					endif 
343b			 
343b			 
343b					NEXTW 
343b c3 16 24			jp macro_next 
343e				endm 
# End of macro NEXTW
343e			.DO: 
343e				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
343e 21				db WORD_SYS_CORE+13             
343f 65 35			dw .LOOP            
3441 03				db 2 + 1 
3442 .. 00			db "DO",0              
3445				endm 
# End of macro CWHEAD
3445			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3445			 
3445					if DEBUG_FORTH_WORDS_KEY 
3445						DMARK "DO." 
3445 f5				push af  
3446 3a 5a 34			ld a, (.dmark)  
3449 32 6e fe			ld (debug_mark),a  
344c 3a 5b 34			ld a, (.dmark+1)  
344f 32 6f fe			ld (debug_mark+1),a  
3452 3a 5c 34			ld a, (.dmark+2)  
3455 32 70 fe			ld (debug_mark+2),a  
3458 18 03			jr .pastdmark  
345a ..			.dmark: db "DO."  
345d f1			.pastdmark: pop af  
345e			endm  
# End of macro DMARK
345e						CALLMONITOR 
345e cd 9e 19			call break_point_state  
3461				endm  
# End of macro CALLMONITOR
3461					endif 
3461			;  push pc to rsp stack past the DO 
3461			 
3461 2a c9 f4				ld hl, (os_tok_ptr) 
3464 23					inc hl   ; D 
3465 23					inc hl  ; O 
3466 23					inc hl   ; null 
3467					if DEBUG_FORTH_WORDS 
3467						DMARK "DO2" 
3467 f5				push af  
3468 3a 7c 34			ld a, (.dmark)  
346b 32 6e fe			ld (debug_mark),a  
346e 3a 7d 34			ld a, (.dmark+1)  
3471 32 6f fe			ld (debug_mark+1),a  
3474 3a 7e 34			ld a, (.dmark+2)  
3477 32 70 fe			ld (debug_mark+2),a  
347a 18 03			jr .pastdmark  
347c ..			.dmark: db "DO2"  
347f f1			.pastdmark: pop af  
3480			endm  
# End of macro DMARK
3480						CALLMONITOR 
3480 cd 9e 19			call break_point_state  
3483				endm  
# End of macro CALLMONITOR
3483					endif 
3483					FORTH_RSP_NEXT 
3483 cd 10 20			call macro_forth_rsp_next 
3486				endm 
# End of macro FORTH_RSP_NEXT
3486					if DEBUG_FORTH_WORDS 
3486						DMARK "DO3" 
3486 f5				push af  
3487 3a 9b 34			ld a, (.dmark)  
348a 32 6e fe			ld (debug_mark),a  
348d 3a 9c 34			ld a, (.dmark+1)  
3490 32 6f fe			ld (debug_mark+1),a  
3493 3a 9d 34			ld a, (.dmark+2)  
3496 32 70 fe			ld (debug_mark+2),a  
3499 18 03			jr .pastdmark  
349b ..			.dmark: db "DO3"  
349e f1			.pastdmark: pop af  
349f			endm  
# End of macro DMARK
349f						CALLMONITOR 
349f cd 9e 19			call break_point_state  
34a2				endm  
# End of macro CALLMONITOR
34a2					endif 
34a2			 
34a2					;if DEBUG_FORTH_WORDS 
34a2				;		push hl 
34a2			;		endif  
34a2			 
34a2			; get counters from data stack 
34a2			 
34a2			 
34a2					FORTH_DSP_VALUEHL 
34a2 cd 60 22			call macro_dsp_valuehl 
34a5				endm 
# End of macro FORTH_DSP_VALUEHL
34a5 e5					push hl		 ; hl now has starting counter which needs to be tos 
34a6			 
34a6					if DEBUG_FORTH_WORDS 
34a6						DMARK "DO4" 
34a6 f5				push af  
34a7 3a bb 34			ld a, (.dmark)  
34aa 32 6e fe			ld (debug_mark),a  
34ad 3a bc 34			ld a, (.dmark+1)  
34b0 32 6f fe			ld (debug_mark+1),a  
34b3 3a bd 34			ld a, (.dmark+2)  
34b6 32 70 fe			ld (debug_mark+2),a  
34b9 18 03			jr .pastdmark  
34bb ..			.dmark: db "DO4"  
34be f1			.pastdmark: pop af  
34bf			endm  
# End of macro DMARK
34bf						CALLMONITOR 
34bf cd 9e 19			call break_point_state  
34c2				endm  
# End of macro CALLMONITOR
34c2					endif 
34c2					FORTH_DSP_POP 
34c2 cd 18 23			call macro_forth_dsp_pop 
34c5				endm 
# End of macro FORTH_DSP_POP
34c5			 
34c5					if DEBUG_FORTH_WORDS 
34c5						DMARK "DO5" 
34c5 f5				push af  
34c6 3a da 34			ld a, (.dmark)  
34c9 32 6e fe			ld (debug_mark),a  
34cc 3a db 34			ld a, (.dmark+1)  
34cf 32 6f fe			ld (debug_mark+1),a  
34d2 3a dc 34			ld a, (.dmark+2)  
34d5 32 70 fe			ld (debug_mark+2),a  
34d8 18 03			jr .pastdmark  
34da ..			.dmark: db "DO5"  
34dd f1			.pastdmark: pop af  
34de			endm  
# End of macro DMARK
34de						CALLMONITOR 
34de cd 9e 19			call break_point_state  
34e1				endm  
# End of macro CALLMONITOR
34e1					endif 
34e1			 
34e1					FORTH_DSP_VALUEHL 
34e1 cd 60 22			call macro_dsp_valuehl 
34e4				endm 
# End of macro FORTH_DSP_VALUEHL
34e4			;		push hl		 ; hl now has starting limit counter 
34e4			 
34e4					if DEBUG_FORTH_WORDS 
34e4						DMARK "DO6" 
34e4 f5				push af  
34e5 3a f9 34			ld a, (.dmark)  
34e8 32 6e fe			ld (debug_mark),a  
34eb 3a fa 34			ld a, (.dmark+1)  
34ee 32 6f fe			ld (debug_mark+1),a  
34f1 3a fb 34			ld a, (.dmark+2)  
34f4 32 70 fe			ld (debug_mark+2),a  
34f7 18 03			jr .pastdmark  
34f9 ..			.dmark: db "DO6"  
34fc f1			.pastdmark: pop af  
34fd			endm  
# End of macro DMARK
34fd						CALLMONITOR 
34fd cd 9e 19			call break_point_state  
3500				endm  
# End of macro CALLMONITOR
3500					endif 
3500					FORTH_DSP_POP 
3500 cd 18 23			call macro_forth_dsp_pop 
3503				endm 
# End of macro FORTH_DSP_POP
3503			 
3503			; put counters on the loop stack 
3503			 
3503			;		pop hl			 ; limit counter 
3503 d1					pop de			; start counter 
3504			 
3504					; push limit counter 
3504			 
3504					if DEBUG_FORTH_WORDS 
3504						DMARK "DO7" 
3504 f5				push af  
3505 3a 19 35			ld a, (.dmark)  
3508 32 6e fe			ld (debug_mark),a  
350b 3a 1a 35			ld a, (.dmark+1)  
350e 32 6f fe			ld (debug_mark+1),a  
3511 3a 1b 35			ld a, (.dmark+2)  
3514 32 70 fe			ld (debug_mark+2),a  
3517 18 03			jr .pastdmark  
3519 ..			.dmark: db "DO7"  
351c f1			.pastdmark: pop af  
351d			endm  
# End of macro DMARK
351d						CALLMONITOR 
351d cd 9e 19			call break_point_state  
3520				endm  
# End of macro CALLMONITOR
3520					endif 
3520					FORTH_LOOP_NEXT 
3520 cd 91 22			call macro_forth_loop_next 
3523				endm 
# End of macro FORTH_LOOP_NEXT
3523			 
3523					; push start counter 
3523			 
3523 eb					ex de, hl 
3524					if DEBUG_FORTH_WORDS 
3524						DMARK "DO7" 
3524 f5				push af  
3525 3a 39 35			ld a, (.dmark)  
3528 32 6e fe			ld (debug_mark),a  
352b 3a 3a 35			ld a, (.dmark+1)  
352e 32 6f fe			ld (debug_mark+1),a  
3531 3a 3b 35			ld a, (.dmark+2)  
3534 32 70 fe			ld (debug_mark+2),a  
3537 18 03			jr .pastdmark  
3539 ..			.dmark: db "DO7"  
353c f1			.pastdmark: pop af  
353d			endm  
# End of macro DMARK
353d						CALLMONITOR 
353d cd 9e 19			call break_point_state  
3540				endm  
# End of macro CALLMONITOR
3540					endif 
3540					FORTH_LOOP_NEXT 
3540 cd 91 22			call macro_forth_loop_next 
3543				endm 
# End of macro FORTH_LOOP_NEXT
3543			 
3543			 
3543					; init first round of I counter 
3543			 
3543 22 ed f4				ld (os_current_i), hl 
3546			 
3546					if DEBUG_FORTH_WORDS 
3546						DMARK "DO8" 
3546 f5				push af  
3547 3a 5b 35			ld a, (.dmark)  
354a 32 6e fe			ld (debug_mark),a  
354d 3a 5c 35			ld a, (.dmark+1)  
3550 32 6f fe			ld (debug_mark+1),a  
3553 3a 5d 35			ld a, (.dmark+2)  
3556 32 70 fe			ld (debug_mark+2),a  
3559 18 03			jr .pastdmark  
355b ..			.dmark: db "DO8"  
355e f1			.pastdmark: pop af  
355f			endm  
# End of macro DMARK
355f						CALLMONITOR 
355f cd 9e 19			call break_point_state  
3562				endm  
# End of macro CALLMONITOR
3562					endif 
3562			 
3562					NEXTW 
3562 c3 16 24			jp macro_next 
3565				endm 
# End of macro NEXTW
3565			.LOOP: 
3565				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3565 22				db WORD_SYS_CORE+14             
3566 7d 36			dw .I            
3568 05				db 4 + 1 
3569 .. 00			db "LOOP",0              
356e				endm 
# End of macro CWHEAD
356e			; | LOOP ( -- ) Increment and test loop counter  | DONE 
356e			 
356e				; pop tos as current loop count to hl 
356e			 
356e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
356e			 
356e				FORTH_LOOP_TOS 
356e cd c4 22			call macro_forth_loop_tos 
3571				endm 
# End of macro FORTH_LOOP_TOS
3571 e5				push hl 
3572			 
3572					if DEBUG_FORTH_WORDS_KEY 
3572						DMARK "LOP" 
3572 f5				push af  
3573 3a 87 35			ld a, (.dmark)  
3576 32 6e fe			ld (debug_mark),a  
3579 3a 88 35			ld a, (.dmark+1)  
357c 32 6f fe			ld (debug_mark+1),a  
357f 3a 89 35			ld a, (.dmark+2)  
3582 32 70 fe			ld (debug_mark+2),a  
3585 18 03			jr .pastdmark  
3587 ..			.dmark: db "LOP"  
358a f1			.pastdmark: pop af  
358b			endm  
# End of macro DMARK
358b						CALLMONITOR 
358b cd 9e 19			call break_point_state  
358e				endm  
# End of macro CALLMONITOR
358e					endif 
358e				; next item on the stack is the limit. get it 
358e			 
358e			 
358e				FORTH_LOOP_POP 
358e cd ce 22			call macro_forth_loop_pop 
3591				endm 
# End of macro FORTH_LOOP_POP
3591			 
3591				FORTH_LOOP_TOS 
3591 cd c4 22			call macro_forth_loop_tos 
3594				endm 
# End of macro FORTH_LOOP_TOS
3594			 
3594 d1				pop de		 ; de = i, hl = limit 
3595			 
3595					if DEBUG_FORTH_WORDS 
3595						DMARK "LP1" 
3595 f5				push af  
3596 3a aa 35			ld a, (.dmark)  
3599 32 6e fe			ld (debug_mark),a  
359c 3a ab 35			ld a, (.dmark+1)  
359f 32 6f fe			ld (debug_mark+1),a  
35a2 3a ac 35			ld a, (.dmark+2)  
35a5 32 70 fe			ld (debug_mark+2),a  
35a8 18 03			jr .pastdmark  
35aa ..			.dmark: db "LP1"  
35ad f1			.pastdmark: pop af  
35ae			endm  
# End of macro DMARK
35ae						CALLMONITOR 
35ae cd 9e 19			call break_point_state  
35b1				endm  
# End of macro CALLMONITOR
35b1					endif 
35b1			 
35b1				; go back to previous word 
35b1			 
35b1 d5				push de    ; save I for inc later 
35b2			 
35b2			 
35b2				; get limit 
35b2				;  is I at limit? 
35b2			 
35b2			 
35b2					if DEBUG_FORTH_WORDS 
35b2						DMARK "LP1" 
35b2 f5				push af  
35b3 3a c7 35			ld a, (.dmark)  
35b6 32 6e fe			ld (debug_mark),a  
35b9 3a c8 35			ld a, (.dmark+1)  
35bc 32 6f fe			ld (debug_mark+1),a  
35bf 3a c9 35			ld a, (.dmark+2)  
35c2 32 70 fe			ld (debug_mark+2),a  
35c5 18 03			jr .pastdmark  
35c7 ..			.dmark: db "LP1"  
35ca f1			.pastdmark: pop af  
35cb			endm  
# End of macro DMARK
35cb						CALLMONITOR 
35cb cd 9e 19			call break_point_state  
35ce				endm  
# End of macro CALLMONITOR
35ce					endif 
35ce			 
35ce ed 52			sbc hl, de 
35d0			 
35d0			 
35d0				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35d0			 
35d0 20 26				jr nz, .loopnotdone 
35d2			 
35d2 e1				pop hl   ; get rid of saved I 
35d3				FORTH_LOOP_POP     ; get rid of limit 
35d3 cd ce 22			call macro_forth_loop_pop 
35d6				endm 
# End of macro FORTH_LOOP_POP
35d6			 
35d6				FORTH_RSP_POP     ; get rid of DO ptr 
35d6 cd 31 20			call macro_forth_rsp_pop 
35d9				endm 
# End of macro FORTH_RSP_POP
35d9			 
35d9			if DEBUG_FORTH_WORDS 
35d9						DMARK "LP>" 
35d9 f5				push af  
35da 3a ee 35			ld a, (.dmark)  
35dd 32 6e fe			ld (debug_mark),a  
35e0 3a ef 35			ld a, (.dmark+1)  
35e3 32 6f fe			ld (debug_mark+1),a  
35e6 3a f0 35			ld a, (.dmark+2)  
35e9 32 70 fe			ld (debug_mark+2),a  
35ec 18 03			jr .pastdmark  
35ee ..			.dmark: db "LP>"  
35f1 f1			.pastdmark: pop af  
35f2			endm  
# End of macro DMARK
35f2				CALLMONITOR 
35f2 cd 9e 19			call break_point_state  
35f5				endm  
# End of macro CALLMONITOR
35f5			endif 
35f5			 
35f5					NEXTW 
35f5 c3 16 24			jp macro_next 
35f8				endm 
# End of macro NEXTW
35f8				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
35f8			 
35f8			.loopnotdone: 
35f8			 
35f8 e1				pop hl    ; get I 
35f9 23				inc hl 
35fa			 
35fa			   	; save new I 
35fa			 
35fa			 
35fa					; set I counter 
35fa			 
35fa 22 ed f4				ld (os_current_i), hl 
35fd			 
35fd					if DEBUG_FORTH_WORDS 
35fd						DMARK "LPN" 
35fd f5				push af  
35fe 3a 12 36			ld a, (.dmark)  
3601 32 6e fe			ld (debug_mark),a  
3604 3a 13 36			ld a, (.dmark+1)  
3607 32 6f fe			ld (debug_mark+1),a  
360a 3a 14 36			ld a, (.dmark+2)  
360d 32 70 fe			ld (debug_mark+2),a  
3610 18 03			jr .pastdmark  
3612 ..			.dmark: db "LPN"  
3615 f1			.pastdmark: pop af  
3616			endm  
# End of macro DMARK
3616					CALLMONITOR 
3616 cd 9e 19			call break_point_state  
3619				endm  
# End of macro CALLMONITOR
3619					endif 
3619					 
3619				FORTH_LOOP_NEXT 
3619 cd 91 22			call macro_forth_loop_next 
361c				endm 
# End of macro FORTH_LOOP_NEXT
361c			 
361c			 
361c					if DEBUG_FORTH_WORDS 
361c eb						ex de,hl 
361d					endif 
361d			 
361d			;	; get DO ptr 
361d			; 
361d					if DEBUG_FORTH_WORDS 
361d						DMARK "LP7" 
361d f5				push af  
361e 3a 32 36			ld a, (.dmark)  
3621 32 6e fe			ld (debug_mark),a  
3624 3a 33 36			ld a, (.dmark+1)  
3627 32 6f fe			ld (debug_mark+1),a  
362a 3a 34 36			ld a, (.dmark+2)  
362d 32 70 fe			ld (debug_mark+2),a  
3630 18 03			jr .pastdmark  
3632 ..			.dmark: db "LP7"  
3635 f1			.pastdmark: pop af  
3636			endm  
# End of macro DMARK
3636					CALLMONITOR 
3636 cd 9e 19			call break_point_state  
3639				endm  
# End of macro CALLMONITOR
3639					endif 
3639				FORTH_RSP_TOS 
3639 cd 27 20			call macro_forth_rsp_tos 
363c				endm 
# End of macro FORTH_RSP_TOS
363c			 
363c					if DEBUG_FORTH_WORDS 
363c						DMARK "LP8" 
363c f5				push af  
363d 3a 51 36			ld a, (.dmark)  
3640 32 6e fe			ld (debug_mark),a  
3643 3a 52 36			ld a, (.dmark+1)  
3646 32 6f fe			ld (debug_mark+1),a  
3649 3a 53 36			ld a, (.dmark+2)  
364c 32 70 fe			ld (debug_mark+2),a  
364f 18 03			jr .pastdmark  
3651 ..			.dmark: db "LP8"  
3654 f1			.pastdmark: pop af  
3655			endm  
# End of macro DMARK
3655					CALLMONITOR 
3655 cd 9e 19			call break_point_state  
3658				endm  
# End of macro CALLMONITOR
3658					endif 
3658				;push hl 
3658			 
3658				; not going to DO any more 
3658				; get rid of the RSP pointer as DO will add it back in 
3658				;FORTH_RSP_POP 
3658				;pop hl 
3658			 
3658				;ld hl,(cli_ret_sp) 
3658				;ld e, (hl) 
3658				;inc hl 
3658				;ld d, (hl) 
3658				;ex de,hl 
3658 22 c9 f4			ld (os_tok_ptr), hl 
365b					if DEBUG_FORTH_WORDS 
365b						DMARK "LP<" 
365b f5				push af  
365c 3a 70 36			ld a, (.dmark)  
365f 32 6e fe			ld (debug_mark),a  
3662 3a 71 36			ld a, (.dmark+1)  
3665 32 6f fe			ld (debug_mark+1),a  
3668 3a 72 36			ld a, (.dmark+2)  
366b 32 70 fe			ld (debug_mark+2),a  
366e 18 03			jr .pastdmark  
3670 ..			.dmark: db "LP<"  
3673 f1			.pastdmark: pop af  
3674			endm  
# End of macro DMARK
3674					CALLMONITOR 
3674 cd 9e 19			call break_point_state  
3677				endm  
# End of macro CALLMONITOR
3677				endif 
3677 c3 a7 24			jp exec1 
367a			 
367a					 
367a			 
367a			 
367a					NEXTW 
367a c3 16 24			jp macro_next 
367d				endm 
# End of macro NEXTW
367d			.I:  
367d			 
367d				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
367d 5e				db WORD_SYS_CORE+74             
367e a8 36			dw .DLOOP            
3680 02				db 1 + 1 
3681 .. 00			db "I",0              
3683				endm 
# End of macro CWHEAD
3683			; | I ( -- ) Current loop counter | DONE 
3683					if DEBUG_FORTH_WORDS_KEY 
3683						DMARK "I.." 
3683 f5				push af  
3684 3a 98 36			ld a, (.dmark)  
3687 32 6e fe			ld (debug_mark),a  
368a 3a 99 36			ld a, (.dmark+1)  
368d 32 6f fe			ld (debug_mark+1),a  
3690 3a 9a 36			ld a, (.dmark+2)  
3693 32 70 fe			ld (debug_mark+2),a  
3696 18 03			jr .pastdmark  
3698 ..			.dmark: db "I.."  
369b f1			.pastdmark: pop af  
369c			endm  
# End of macro DMARK
369c						CALLMONITOR 
369c cd 9e 19			call break_point_state  
369f				endm  
# End of macro CALLMONITOR
369f					endif 
369f			 
369f 2a ed f4				ld hl,(os_current_i) 
36a2 cd 69 20				call forth_push_numhl 
36a5			 
36a5					NEXTW 
36a5 c3 16 24			jp macro_next 
36a8				endm 
# End of macro NEXTW
36a8			.DLOOP: 
36a8				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
36a8 5f				db WORD_SYS_CORE+75             
36a9 89 37			dw .REPEAT            
36ab 06				db 5 + 1 
36ac .. 00			db "-LOOP",0              
36b2				endm 
# End of macro CWHEAD
36b2			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
36b2				; pop tos as current loop count to hl 
36b2					if DEBUG_FORTH_WORDS_KEY 
36b2						DMARK "-LP" 
36b2 f5				push af  
36b3 3a c7 36			ld a, (.dmark)  
36b6 32 6e fe			ld (debug_mark),a  
36b9 3a c8 36			ld a, (.dmark+1)  
36bc 32 6f fe			ld (debug_mark+1),a  
36bf 3a c9 36			ld a, (.dmark+2)  
36c2 32 70 fe			ld (debug_mark+2),a  
36c5 18 03			jr .pastdmark  
36c7 ..			.dmark: db "-LP"  
36ca f1			.pastdmark: pop af  
36cb			endm  
# End of macro DMARK
36cb						CALLMONITOR 
36cb cd 9e 19			call break_point_state  
36ce				endm  
# End of macro CALLMONITOR
36ce					endif 
36ce			 
36ce				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36ce			 
36ce				FORTH_LOOP_TOS 
36ce cd c4 22			call macro_forth_loop_tos 
36d1				endm 
# End of macro FORTH_LOOP_TOS
36d1 e5				push hl 
36d2			 
36d2					if DEBUG_FORTH_WORDS 
36d2						DMARK "-LP" 
36d2 f5				push af  
36d3 3a e7 36			ld a, (.dmark)  
36d6 32 6e fe			ld (debug_mark),a  
36d9 3a e8 36			ld a, (.dmark+1)  
36dc 32 6f fe			ld (debug_mark+1),a  
36df 3a e9 36			ld a, (.dmark+2)  
36e2 32 70 fe			ld (debug_mark+2),a  
36e5 18 03			jr .pastdmark  
36e7 ..			.dmark: db "-LP"  
36ea f1			.pastdmark: pop af  
36eb			endm  
# End of macro DMARK
36eb						CALLMONITOR 
36eb cd 9e 19			call break_point_state  
36ee				endm  
# End of macro CALLMONITOR
36ee					endif 
36ee				; next item on the stack is the limit. get it 
36ee			 
36ee			 
36ee				FORTH_LOOP_POP 
36ee cd ce 22			call macro_forth_loop_pop 
36f1				endm 
# End of macro FORTH_LOOP_POP
36f1			 
36f1				FORTH_LOOP_TOS 
36f1 cd c4 22			call macro_forth_loop_tos 
36f4				endm 
# End of macro FORTH_LOOP_TOS
36f4			 
36f4 d1				pop de		 ; de = i, hl = limit 
36f5			 
36f5					if DEBUG_FORTH_WORDS 
36f5						DMARK "-L1" 
36f5 f5				push af  
36f6 3a 0a 37			ld a, (.dmark)  
36f9 32 6e fe			ld (debug_mark),a  
36fc 3a 0b 37			ld a, (.dmark+1)  
36ff 32 6f fe			ld (debug_mark+1),a  
3702 3a 0c 37			ld a, (.dmark+2)  
3705 32 70 fe			ld (debug_mark+2),a  
3708 18 03			jr .pastdmark  
370a ..			.dmark: db "-L1"  
370d f1			.pastdmark: pop af  
370e			endm  
# End of macro DMARK
370e						CALLMONITOR 
370e cd 9e 19			call break_point_state  
3711				endm  
# End of macro CALLMONITOR
3711					endif 
3711			 
3711				; go back to previous word 
3711			 
3711 d5				push de    ; save I for inc later 
3712			 
3712			 
3712				; get limit 
3712				;  is I at limit? 
3712			 
3712			 
3712					if DEBUG_FORTH_WORDS 
3712						DMARK "-L1" 
3712 f5				push af  
3713 3a 27 37			ld a, (.dmark)  
3716 32 6e fe			ld (debug_mark),a  
3719 3a 28 37			ld a, (.dmark+1)  
371c 32 6f fe			ld (debug_mark+1),a  
371f 3a 29 37			ld a, (.dmark+2)  
3722 32 70 fe			ld (debug_mark+2),a  
3725 18 03			jr .pastdmark  
3727 ..			.dmark: db "-L1"  
372a f1			.pastdmark: pop af  
372b			endm  
# End of macro DMARK
372b						CALLMONITOR 
372b cd 9e 19			call break_point_state  
372e				endm  
# End of macro CALLMONITOR
372e					endif 
372e			 
372e ed 52			sbc hl, de 
3730			 
3730			 
3730				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3730			 
3730 20 26				jr nz, .mloopnotdone 
3732			 
3732 e1				pop hl   ; get rid of saved I 
3733				FORTH_LOOP_POP     ; get rid of limit 
3733 cd ce 22			call macro_forth_loop_pop 
3736				endm 
# End of macro FORTH_LOOP_POP
3736			 
3736				FORTH_RSP_POP     ; get rid of DO ptr 
3736 cd 31 20			call macro_forth_rsp_pop 
3739				endm 
# End of macro FORTH_RSP_POP
3739			 
3739			if DEBUG_FORTH_WORDS 
3739						DMARK "-L>" 
3739 f5				push af  
373a 3a 4e 37			ld a, (.dmark)  
373d 32 6e fe			ld (debug_mark),a  
3740 3a 4f 37			ld a, (.dmark+1)  
3743 32 6f fe			ld (debug_mark+1),a  
3746 3a 50 37			ld a, (.dmark+2)  
3749 32 70 fe			ld (debug_mark+2),a  
374c 18 03			jr .pastdmark  
374e ..			.dmark: db "-L>"  
3751 f1			.pastdmark: pop af  
3752			endm  
# End of macro DMARK
3752				CALLMONITOR 
3752 cd 9e 19			call break_point_state  
3755				endm  
# End of macro CALLMONITOR
3755			endif 
3755			 
3755					NEXTW 
3755 c3 16 24			jp macro_next 
3758				endm 
# End of macro NEXTW
3758				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3758			 
3758			.mloopnotdone: 
3758			 
3758 e1				pop hl    ; get I 
3759 2b				dec hl 
375a			 
375a			   	; save new I 
375a			 
375a			 
375a					; set I counter 
375a			 
375a 22 ed f4				ld (os_current_i), hl 
375d			 
375d					 
375d				FORTH_LOOP_NEXT 
375d cd 91 22			call macro_forth_loop_next 
3760				endm 
# End of macro FORTH_LOOP_NEXT
3760			 
3760			 
3760					if DEBUG_FORTH_WORDS 
3760 eb						ex de,hl 
3761					endif 
3761			 
3761			;	; get DO ptr 
3761			; 
3761				FORTH_RSP_TOS 
3761 cd 27 20			call macro_forth_rsp_tos 
3764				endm 
# End of macro FORTH_RSP_TOS
3764			 
3764				;push hl 
3764			 
3764				; not going to DO any more 
3764				; get rid of the RSP pointer as DO will add it back in 
3764				;FORTH_RSP_POP 
3764				;pop hl 
3764			 
3764			 
3764 22 c9 f4			ld (os_tok_ptr), hl 
3767					if DEBUG_FORTH_WORDS 
3767						DMARK "-L<" 
3767 f5				push af  
3768 3a 7c 37			ld a, (.dmark)  
376b 32 6e fe			ld (debug_mark),a  
376e 3a 7d 37			ld a, (.dmark+1)  
3771 32 6f fe			ld (debug_mark+1),a  
3774 3a 7e 37			ld a, (.dmark+2)  
3777 32 70 fe			ld (debug_mark+2),a  
377a 18 03			jr .pastdmark  
377c ..			.dmark: db "-L<"  
377f f1			.pastdmark: pop af  
3780			endm  
# End of macro DMARK
3780					CALLMONITOR 
3780 cd 9e 19			call break_point_state  
3783				endm  
# End of macro CALLMONITOR
3783				endif 
3783 c3 a7 24			jp exec1 
3786			 
3786					 
3786			 
3786			 
3786			 
3786				NEXTW 
3786 c3 16 24			jp macro_next 
3789				endm 
# End of macro NEXTW
3789			 
3789			 
3789			 
3789			 
3789			.REPEAT: 
3789				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3789 71				db WORD_SYS_CORE+93             
378a dc 37			dw .UNTIL            
378c 06				db 5 + 1 
378d .. 00			db "REPEAT",0              
3794				endm 
# End of macro CWHEAD
3794			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3794			;  push pc to rsp stack past the REPEAT 
3794					if DEBUG_FORTH_WORDS_KEY 
3794						DMARK "REP" 
3794 f5				push af  
3795 3a a9 37			ld a, (.dmark)  
3798 32 6e fe			ld (debug_mark),a  
379b 3a aa 37			ld a, (.dmark+1)  
379e 32 6f fe			ld (debug_mark+1),a  
37a1 3a ab 37			ld a, (.dmark+2)  
37a4 32 70 fe			ld (debug_mark+2),a  
37a7 18 03			jr .pastdmark  
37a9 ..			.dmark: db "REP"  
37ac f1			.pastdmark: pop af  
37ad			endm  
# End of macro DMARK
37ad						CALLMONITOR 
37ad cd 9e 19			call break_point_state  
37b0				endm  
# End of macro CALLMONITOR
37b0					endif 
37b0			 
37b0 2a c9 f4				ld hl, (os_tok_ptr) 
37b3 23					inc hl   ; R 
37b4 23					inc hl  ; E 
37b5 23					inc hl   ; P 
37b6 23					inc hl   ; E 
37b7 23					inc hl   ; A 
37b8 23					inc hl   ; T 
37b9 23					inc hl   ; zero 
37ba					FORTH_RSP_NEXT 
37ba cd 10 20			call macro_forth_rsp_next 
37bd				endm 
# End of macro FORTH_RSP_NEXT
37bd			 
37bd			 
37bd					if DEBUG_FORTH_WORDS 
37bd						DMARK "REP" 
37bd f5				push af  
37be 3a d2 37			ld a, (.dmark)  
37c1 32 6e fe			ld (debug_mark),a  
37c4 3a d3 37			ld a, (.dmark+1)  
37c7 32 6f fe			ld (debug_mark+1),a  
37ca 3a d4 37			ld a, (.dmark+2)  
37cd 32 70 fe			ld (debug_mark+2),a  
37d0 18 03			jr .pastdmark  
37d2 ..			.dmark: db "REP"  
37d5 f1			.pastdmark: pop af  
37d6			endm  
# End of macro DMARK
37d6						;pop bc    ; TODO BUG ?????? what is this for???? 
37d6						CALLMONITOR 
37d6 cd 9e 19			call break_point_state  
37d9				endm  
# End of macro CALLMONITOR
37d9					endif 
37d9			 
37d9					NEXTW 
37d9 c3 16 24			jp macro_next 
37dc				endm 
# End of macro NEXTW
37dc			;	       NEXTW 
37dc			 
37dc			.UNTIL: 
37dc				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
37dc 72				db WORD_SYS_CORE+94             
37dd 73 38			dw .ENDFLOW            
37df 06				db 5 + 1 
37e0 .. 00			db "UNTIL",0              
37e6				endm 
# End of macro CWHEAD
37e6			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
37e6			 
37e6				; pop tos as check 
37e6			 
37e6				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
37e6			 
37e6				FORTH_DSP_VALUEHL 
37e6 cd 60 22			call macro_dsp_valuehl 
37e9				endm 
# End of macro FORTH_DSP_VALUEHL
37e9			 
37e9					if DEBUG_FORTH_WORDS_KEY 
37e9						DMARK "UNT" 
37e9 f5				push af  
37ea 3a fe 37			ld a, (.dmark)  
37ed 32 6e fe			ld (debug_mark),a  
37f0 3a ff 37			ld a, (.dmark+1)  
37f3 32 6f fe			ld (debug_mark+1),a  
37f6 3a 00 38			ld a, (.dmark+2)  
37f9 32 70 fe			ld (debug_mark+2),a  
37fc 18 03			jr .pastdmark  
37fe ..			.dmark: db "UNT"  
3801 f1			.pastdmark: pop af  
3802			endm  
# End of macro DMARK
3802						CALLMONITOR 
3802 cd 9e 19			call break_point_state  
3805				endm  
# End of macro CALLMONITOR
3805					endif 
3805			 
3805			;	push hl 
3805				FORTH_DSP_POP 
3805 cd 18 23			call macro_forth_dsp_pop 
3808				endm 
# End of macro FORTH_DSP_POP
3808			 
3808			;	pop hl 
3808			 
3808				; test if true 
3808			 
3808 cd 75 0f			call ishlzero 
380b			;	ld a,l 
380b			;	add h 
380b			; 
380b			;	cp 0 
380b			 
380b 20 3e			jr nz, .untilnotdone 
380d			 
380d					if DEBUG_FORTH_WORDS 
380d						DMARK "UNf" 
380d f5				push af  
380e 3a 22 38			ld a, (.dmark)  
3811 32 6e fe			ld (debug_mark),a  
3814 3a 23 38			ld a, (.dmark+1)  
3817 32 6f fe			ld (debug_mark+1),a  
381a 3a 24 38			ld a, (.dmark+2)  
381d 32 70 fe			ld (debug_mark+2),a  
3820 18 03			jr .pastdmark  
3822 ..			.dmark: db "UNf"  
3825 f1			.pastdmark: pop af  
3826			endm  
# End of macro DMARK
3826						CALLMONITOR 
3826 cd 9e 19			call break_point_state  
3829				endm  
# End of macro CALLMONITOR
3829					endif 
3829			 
3829			 
3829			 
3829				FORTH_RSP_POP     ; get rid of DO ptr 
3829 cd 31 20			call macro_forth_rsp_pop 
382c				endm 
# End of macro FORTH_RSP_POP
382c			 
382c			if DEBUG_FORTH_WORDS 
382c						DMARK "UN>" 
382c f5				push af  
382d 3a 41 38			ld a, (.dmark)  
3830 32 6e fe			ld (debug_mark),a  
3833 3a 42 38			ld a, (.dmark+1)  
3836 32 6f fe			ld (debug_mark+1),a  
3839 3a 43 38			ld a, (.dmark+2)  
383c 32 70 fe			ld (debug_mark+2),a  
383f 18 03			jr .pastdmark  
3841 ..			.dmark: db "UN>"  
3844 f1			.pastdmark: pop af  
3845			endm  
# End of macro DMARK
3845				CALLMONITOR 
3845 cd 9e 19			call break_point_state  
3848				endm  
# End of macro CALLMONITOR
3848			endif 
3848			 
3848					NEXTW 
3848 c3 16 24			jp macro_next 
384b				endm 
# End of macro NEXTW
384b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
384b			 
384b			.untilnotdone: 
384b			 
384b			 
384b			;	; get DO ptr 
384b			; 
384b				FORTH_RSP_TOS 
384b cd 27 20			call macro_forth_rsp_tos 
384e				endm 
# End of macro FORTH_RSP_TOS
384e			 
384e				;push hl 
384e			 
384e				; not going to DO any more 
384e				; get rid of the RSP pointer as DO will add it back in 
384e				;FORTH_RSP_POP 
384e				;pop hl 
384e			 
384e			 
384e 22 c9 f4			ld (os_tok_ptr), hl 
3851					if DEBUG_FORTH_WORDS 
3851						DMARK "UN<" 
3851 f5				push af  
3852 3a 66 38			ld a, (.dmark)  
3855 32 6e fe			ld (debug_mark),a  
3858 3a 67 38			ld a, (.dmark+1)  
385b 32 6f fe			ld (debug_mark+1),a  
385e 3a 68 38			ld a, (.dmark+2)  
3861 32 70 fe			ld (debug_mark+2),a  
3864 18 03			jr .pastdmark  
3866 ..			.dmark: db "UN<"  
3869 f1			.pastdmark: pop af  
386a			endm  
# End of macro DMARK
386a					CALLMONITOR 
386a cd 9e 19			call break_point_state  
386d				endm  
# End of macro CALLMONITOR
386d				endif 
386d c3 a7 24			jp exec1 
3870			 
3870					 
3870			 
3870			 
3870					NEXTW 
3870 c3 16 24			jp macro_next 
3873				endm 
# End of macro NEXTW
3873			 
3873			 
3873			.ENDFLOW: 
3873			 
3873			; eof 
3873			 
# End of file forth_words_flow.asm
3873			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3873			include "forth_words_logic.asm" 
3873			 
3873			; | ## Logic Words 
3873			 
3873			.NOT: 
3873				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3873 2d				db WORD_SYS_CORE+25             
3874 bb 38			dw .IS            
3876 04				db 3 + 1 
3877 .. 00			db "NOT",0              
387b				endm 
# End of macro CWHEAD
387b			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
387b					if DEBUG_FORTH_WORDS_KEY 
387b						DMARK "NOT" 
387b f5				push af  
387c 3a 90 38			ld a, (.dmark)  
387f 32 6e fe			ld (debug_mark),a  
3882 3a 91 38			ld a, (.dmark+1)  
3885 32 6f fe			ld (debug_mark+1),a  
3888 3a 92 38			ld a, (.dmark+2)  
388b 32 70 fe			ld (debug_mark+2),a  
388e 18 03			jr .pastdmark  
3890 ..			.dmark: db "NOT"  
3893 f1			.pastdmark: pop af  
3894			endm  
# End of macro DMARK
3894						CALLMONITOR 
3894 cd 9e 19			call break_point_state  
3897				endm  
# End of macro CALLMONITOR
3897					endif 
3897					FORTH_DSP 
3897 cd 26 22			call macro_forth_dsp 
389a				endm 
# End of macro FORTH_DSP
389a 7e					ld a,(hl)	; get type of value on TOS 
389b fe 02				cp DS_TYPE_INUM  
389d 28 03				jr z, .noti 
389f					NEXTW 
389f c3 16 24			jp macro_next 
38a2				endm 
# End of macro NEXTW
38a2			.noti:          FORTH_DSP_VALUEHL 
38a2 cd 60 22			call macro_dsp_valuehl 
38a5				endm 
# End of macro FORTH_DSP_VALUEHL
38a5			;		push hl 
38a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38a5 cd 18 23			call macro_forth_dsp_pop 
38a8				endm 
# End of macro FORTH_DSP_POP
38a8			;		pop hl 
38a8 3e 00				ld a,0 
38aa bd					cp l 
38ab 28 04				jr z, .not2t 
38ad 2e 00				ld l, 0 
38af 18 02				jr .notip 
38b1			 
38b1 2e ff		.not2t:		ld l, 255 
38b3			 
38b3 26 00		.notip:		ld h, 0	 
38b5			 
38b5 cd 69 20				call forth_push_numhl 
38b8					NEXTW 
38b8 c3 16 24			jp macro_next 
38bb				endm 
# End of macro NEXTW
38bb			 
38bb			.IS: 
38bb				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
38bb 2d				db WORD_SYS_CORE+25             
38bc e1 38			dw .LZERO            
38be 03				db 2 + 1 
38bf .. 00			db "IS",0              
38c2				endm 
# End of macro CWHEAD
38c2			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
38c2					if DEBUG_FORTH_WORDS_KEY 
38c2						DMARK "IS." 
38c2 f5				push af  
38c3 3a d7 38			ld a, (.dmark)  
38c6 32 6e fe			ld (debug_mark),a  
38c9 3a d8 38			ld a, (.dmark+1)  
38cc 32 6f fe			ld (debug_mark+1),a  
38cf 3a d9 38			ld a, (.dmark+2)  
38d2 32 70 fe			ld (debug_mark+2),a  
38d5 18 03			jr .pastdmark  
38d7 ..			.dmark: db "IS."  
38da f1			.pastdmark: pop af  
38db			endm  
# End of macro DMARK
38db						CALLMONITOR 
38db cd 9e 19			call break_point_state  
38de				endm  
# End of macro CALLMONITOR
38de					endif 
38de					NEXTW 
38de c3 16 24			jp macro_next 
38e1				endm 
# End of macro NEXTW
38e1			.LZERO: 
38e1				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
38e1 2d				db WORD_SYS_CORE+25             
38e2 eb 38			dw .TZERO            
38e4 03				db 2 + 1 
38e5 .. 00			db "0<",0              
38e8				endm 
# End of macro CWHEAD
38e8			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
38e8					NEXTW 
38e8 c3 16 24			jp macro_next 
38eb				endm 
# End of macro NEXTW
38eb			.TZERO: 
38eb				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
38eb 2e				db WORD_SYS_CORE+26             
38ec 32 39			dw .LESS            
38ee 03				db 2 + 1 
38ef .. 00			db "0=",0              
38f2				endm 
# End of macro CWHEAD
38f2			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
38f2				; TODO add floating point number detection 
38f2					;v5 FORTH_DSP_VALUE 
38f2					if DEBUG_FORTH_WORDS_KEY 
38f2						DMARK "0=." 
38f2 f5				push af  
38f3 3a 07 39			ld a, (.dmark)  
38f6 32 6e fe			ld (debug_mark),a  
38f9 3a 08 39			ld a, (.dmark+1)  
38fc 32 6f fe			ld (debug_mark+1),a  
38ff 3a 09 39			ld a, (.dmark+2)  
3902 32 70 fe			ld (debug_mark+2),a  
3905 18 03			jr .pastdmark  
3907 ..			.dmark: db "0=."  
390a f1			.pastdmark: pop af  
390b			endm  
# End of macro DMARK
390b						CALLMONITOR 
390b cd 9e 19			call break_point_state  
390e				endm  
# End of macro CALLMONITOR
390e					endif 
390e					FORTH_DSP 
390e cd 26 22			call macro_forth_dsp 
3911				endm 
# End of macro FORTH_DSP
3911 7e					ld a,(hl)	; get type of value on TOS 
3912 fe 02				cp DS_TYPE_INUM  
3914 28 00				jr z, .tz_inum 
3916			 
3916				if FORTH_ENABLE_FLOATMATH 
3916					jr .tz_done 
3916			 
3916				endif 
3916					 
3916			 
3916			.tz_inum: 
3916					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3916 cd 60 22			call macro_dsp_valuehl 
3919				endm 
# End of macro FORTH_DSP_VALUEHL
3919			 
3919			;		push hl 
3919			 
3919					; destroy value TOS 
3919			 
3919					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3919 cd 18 23			call macro_forth_dsp_pop 
391c				endm 
# End of macro FORTH_DSP_POP
391c			 
391c			;		pop hl 
391c			 
391c 3e 00				ld a,0 
391e			 
391e bd					cp l 
391f 20 08				jr nz, .tz_notzero 
3921			 
3921 bc					cp h 
3922			 
3922 20 05				jr nz, .tz_notzero 
3924			 
3924			 
3924 21 01 00				ld hl, FORTH_TRUE 
3927 18 03				jr .tz_done 
3929			 
3929 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
392c			 
392c					; push value back onto stack for another op etc 
392c			 
392c			.tz_done: 
392c cd 69 20				call forth_push_numhl 
392f			 
392f					NEXTW 
392f c3 16 24			jp macro_next 
3932				endm 
# End of macro NEXTW
3932			.LESS: 
3932				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3932 2f				db WORD_SYS_CORE+27             
3933 9b 39			dw .GT            
3935 02				db 1 + 1 
3936 .. 00			db "<",0              
3938				endm 
# End of macro CWHEAD
3938			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3938				; TODO add floating point number detection 
3938					if DEBUG_FORTH_WORDS_KEY 
3938						DMARK "LES" 
3938 f5				push af  
3939 3a 4d 39			ld a, (.dmark)  
393c 32 6e fe			ld (debug_mark),a  
393f 3a 4e 39			ld a, (.dmark+1)  
3942 32 6f fe			ld (debug_mark+1),a  
3945 3a 4f 39			ld a, (.dmark+2)  
3948 32 70 fe			ld (debug_mark+2),a  
394b 18 03			jr .pastdmark  
394d ..			.dmark: db "LES"  
3950 f1			.pastdmark: pop af  
3951			endm  
# End of macro DMARK
3951						CALLMONITOR 
3951 cd 9e 19			call break_point_state  
3954				endm  
# End of macro CALLMONITOR
3954					endif 
3954					FORTH_DSP 
3954 cd 26 22			call macro_forth_dsp 
3957				endm 
# End of macro FORTH_DSP
3957					;v5 FORTH_DSP_VALUE 
3957 7e					ld a,(hl)	; get type of value on TOS 
3958 fe 02				cp DS_TYPE_INUM  
395a 28 00				jr z, .less_inum 
395c			 
395c				if FORTH_ENABLE_FLOATMATH 
395c					jr .less_done 
395c			 
395c				endif 
395c					 
395c			 
395c			.less_inum: 
395c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
395c cd 60 22			call macro_dsp_valuehl 
395f				endm 
# End of macro FORTH_DSP_VALUEHL
395f			 
395f e5					push hl  ; u2 
3960			 
3960					; destroy value TOS 
3960			 
3960					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3960 cd 18 23			call macro_forth_dsp_pop 
3963				endm 
# End of macro FORTH_DSP_POP
3963			 
3963			 
3963					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3963 cd 60 22			call macro_dsp_valuehl 
3966				endm 
# End of macro FORTH_DSP_VALUEHL
3966			 
3966 e5					push hl    ; u1 
3967			 
3967					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3967 cd 18 23			call macro_forth_dsp_pop 
396a				endm 
# End of macro FORTH_DSP_POP
396a			 
396a			 
396a b7			 or a      ;clear carry flag 
396b 01 00 00		 ld bc, FORTH_FALSE 
396e e1			  pop hl    ; u1 
396f d1			  pop de    ; u2 
3970 ed 52		  sbc hl,de 
3972 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3974			 
3974 01 01 00		 ld bc, FORTH_TRUE 
3977			.lscont:  
3977 c5					push bc 
3978 e1					pop hl 
3979			 
3979					if DEBUG_FORTH_WORDS 
3979						DMARK "LT1" 
3979 f5				push af  
397a 3a 8e 39			ld a, (.dmark)  
397d 32 6e fe			ld (debug_mark),a  
3980 3a 8f 39			ld a, (.dmark+1)  
3983 32 6f fe			ld (debug_mark+1),a  
3986 3a 90 39			ld a, (.dmark+2)  
3989 32 70 fe			ld (debug_mark+2),a  
398c 18 03			jr .pastdmark  
398e ..			.dmark: db "LT1"  
3991 f1			.pastdmark: pop af  
3992			endm  
# End of macro DMARK
3992						CALLMONITOR 
3992 cd 9e 19			call break_point_state  
3995				endm  
# End of macro CALLMONITOR
3995					endif 
3995 cd 69 20				call forth_push_numhl 
3998			 
3998					NEXTW 
3998 c3 16 24			jp macro_next 
399b				endm 
# End of macro NEXTW
399b			.GT: 
399b				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
399b 30				db WORD_SYS_CORE+28             
399c 04 3a			dw .EQUAL            
399e 02				db 1 + 1 
399f .. 00			db ">",0              
39a1				endm 
# End of macro CWHEAD
39a1			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
39a1				; TODO add floating point number detection 
39a1					if DEBUG_FORTH_WORDS_KEY 
39a1						DMARK "GRT" 
39a1 f5				push af  
39a2 3a b6 39			ld a, (.dmark)  
39a5 32 6e fe			ld (debug_mark),a  
39a8 3a b7 39			ld a, (.dmark+1)  
39ab 32 6f fe			ld (debug_mark+1),a  
39ae 3a b8 39			ld a, (.dmark+2)  
39b1 32 70 fe			ld (debug_mark+2),a  
39b4 18 03			jr .pastdmark  
39b6 ..			.dmark: db "GRT"  
39b9 f1			.pastdmark: pop af  
39ba			endm  
# End of macro DMARK
39ba						CALLMONITOR 
39ba cd 9e 19			call break_point_state  
39bd				endm  
# End of macro CALLMONITOR
39bd					endif 
39bd					FORTH_DSP 
39bd cd 26 22			call macro_forth_dsp 
39c0				endm 
# End of macro FORTH_DSP
39c0					;FORTH_DSP_VALUE 
39c0 7e					ld a,(hl)	; get type of value on TOS 
39c1 fe 02				cp DS_TYPE_INUM  
39c3 28 00				jr z, .gt_inum 
39c5			 
39c5				if FORTH_ENABLE_FLOATMATH 
39c5					jr .gt_done 
39c5			 
39c5				endif 
39c5					 
39c5			 
39c5			.gt_inum: 
39c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39c5 cd 60 22			call macro_dsp_valuehl 
39c8				endm 
# End of macro FORTH_DSP_VALUEHL
39c8			 
39c8 e5					push hl  ; u2 
39c9			 
39c9					; destroy value TOS 
39c9			 
39c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c9 cd 18 23			call macro_forth_dsp_pop 
39cc				endm 
# End of macro FORTH_DSP_POP
39cc			 
39cc			 
39cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39cc cd 60 22			call macro_dsp_valuehl 
39cf				endm 
# End of macro FORTH_DSP_VALUEHL
39cf			 
39cf e5					push hl    ; u1 
39d0			 
39d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39d0 cd 18 23			call macro_forth_dsp_pop 
39d3				endm 
# End of macro FORTH_DSP_POP
39d3			 
39d3			 
39d3 b7			 or a      ;clear carry flag 
39d4 01 00 00		 ld bc, FORTH_FALSE 
39d7 e1			  pop hl    ; u1 
39d8 d1			  pop de    ; u2 
39d9 ed 52		  sbc hl,de 
39db 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
39dd			 
39dd 01 01 00		 ld bc, FORTH_TRUE 
39e0			.gtcont:  
39e0 c5					push bc 
39e1 e1					pop hl 
39e2			 
39e2					if DEBUG_FORTH_WORDS 
39e2						DMARK "GT1" 
39e2 f5				push af  
39e3 3a f7 39			ld a, (.dmark)  
39e6 32 6e fe			ld (debug_mark),a  
39e9 3a f8 39			ld a, (.dmark+1)  
39ec 32 6f fe			ld (debug_mark+1),a  
39ef 3a f9 39			ld a, (.dmark+2)  
39f2 32 70 fe			ld (debug_mark+2),a  
39f5 18 03			jr .pastdmark  
39f7 ..			.dmark: db "GT1"  
39fa f1			.pastdmark: pop af  
39fb			endm  
# End of macro DMARK
39fb						CALLMONITOR 
39fb cd 9e 19			call break_point_state  
39fe				endm  
# End of macro CALLMONITOR
39fe					endif 
39fe cd 69 20				call forth_push_numhl 
3a01			 
3a01					NEXTW 
3a01 c3 16 24			jp macro_next 
3a04				endm 
# End of macro NEXTW
3a04			.EQUAL: 
3a04				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3a04 31				db WORD_SYS_CORE+29             
3a05 6f 3a			dw .ENDLOGIC            
3a07 02				db 1 + 1 
3a08 .. 00			db "=",0              
3a0a				endm 
# End of macro CWHEAD
3a0a			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3a0a				; TODO add floating point number detection 
3a0a					if DEBUG_FORTH_WORDS_KEY 
3a0a						DMARK "EQ." 
3a0a f5				push af  
3a0b 3a 1f 3a			ld a, (.dmark)  
3a0e 32 6e fe			ld (debug_mark),a  
3a11 3a 20 3a			ld a, (.dmark+1)  
3a14 32 6f fe			ld (debug_mark+1),a  
3a17 3a 21 3a			ld a, (.dmark+2)  
3a1a 32 70 fe			ld (debug_mark+2),a  
3a1d 18 03			jr .pastdmark  
3a1f ..			.dmark: db "EQ."  
3a22 f1			.pastdmark: pop af  
3a23			endm  
# End of macro DMARK
3a23						CALLMONITOR 
3a23 cd 9e 19			call break_point_state  
3a26				endm  
# End of macro CALLMONITOR
3a26					endif 
3a26					FORTH_DSP 
3a26 cd 26 22			call macro_forth_dsp 
3a29				endm 
# End of macro FORTH_DSP
3a29					;v5 FORTH_DSP_VALUE 
3a29 7e					ld a,(hl)	; get type of value on TOS 
3a2a fe 02				cp DS_TYPE_INUM  
3a2c 28 00				jr z, .eq_inum 
3a2e			 
3a2e				if FORTH_ENABLE_FLOATMATH 
3a2e					jr .eq_done 
3a2e			 
3a2e				endif 
3a2e					 
3a2e			 
3a2e			.eq_inum: 
3a2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a2e cd 60 22			call macro_dsp_valuehl 
3a31				endm 
# End of macro FORTH_DSP_VALUEHL
3a31			 
3a31 e5					push hl 
3a32			 
3a32					; destroy value TOS 
3a32			 
3a32					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a32 cd 18 23			call macro_forth_dsp_pop 
3a35				endm 
# End of macro FORTH_DSP_POP
3a35			 
3a35			 
3a35					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a35 cd 60 22			call macro_dsp_valuehl 
3a38				endm 
# End of macro FORTH_DSP_VALUEHL
3a38			 
3a38					; one value on hl get other one back 
3a38			 
3a38 e5					push hl 
3a39			 
3a39					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a39 cd 18 23			call macro_forth_dsp_pop 
3a3c				endm 
# End of macro FORTH_DSP_POP
3a3c			 
3a3c 0e 00				ld c, FORTH_FALSE 
3a3e			 
3a3e e1					pop hl 
3a3f d1					pop de 
3a40			 
3a40 7b					ld a, e 
3a41 bd					cp l 
3a42			 
3a42 20 06				jr nz, .eq_done 
3a44			 
3a44 7a					ld a, d 
3a45 bc					cp h 
3a46			 
3a46 20 02				jr nz, .eq_done 
3a48			 
3a48 0e 01				ld c, FORTH_TRUE 
3a4a					 
3a4a			 
3a4a			 
3a4a			.eq_done: 
3a4a			 
3a4a					; TODO push value back onto stack for another op etc 
3a4a			 
3a4a 26 00				ld h, 0 
3a4c 69					ld l, c 
3a4d					if DEBUG_FORTH_WORDS 
3a4d						DMARK "EQ1" 
3a4d f5				push af  
3a4e 3a 62 3a			ld a, (.dmark)  
3a51 32 6e fe			ld (debug_mark),a  
3a54 3a 63 3a			ld a, (.dmark+1)  
3a57 32 6f fe			ld (debug_mark+1),a  
3a5a 3a 64 3a			ld a, (.dmark+2)  
3a5d 32 70 fe			ld (debug_mark+2),a  
3a60 18 03			jr .pastdmark  
3a62 ..			.dmark: db "EQ1"  
3a65 f1			.pastdmark: pop af  
3a66			endm  
# End of macro DMARK
3a66						CALLMONITOR 
3a66 cd 9e 19			call break_point_state  
3a69				endm  
# End of macro CALLMONITOR
3a69					endif 
3a69 cd 69 20				call forth_push_numhl 
3a6c			 
3a6c					NEXTW 
3a6c c3 16 24			jp macro_next 
3a6f				endm 
# End of macro NEXTW
3a6f			 
3a6f			 
3a6f			.ENDLOGIC: 
3a6f			; eof 
3a6f			 
3a6f			 
# End of file forth_words_logic.asm
3a6f			include "forth_words_maths.asm" 
3a6f			 
3a6f			; | ## Maths Words 
3a6f			 
3a6f			.PLUS:	 
3a6f				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3a6f 15				db WORD_SYS_CORE+1             
3a70 cd 3a			dw .NEG            
3a72 02				db 1 + 1 
3a73 .. 00			db "+",0              
3a75				endm 
# End of macro CWHEAD
3a75			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3a75					if DEBUG_FORTH_WORDS_KEY 
3a75						DMARK "PLU" 
3a75 f5				push af  
3a76 3a 8a 3a			ld a, (.dmark)  
3a79 32 6e fe			ld (debug_mark),a  
3a7c 3a 8b 3a			ld a, (.dmark+1)  
3a7f 32 6f fe			ld (debug_mark+1),a  
3a82 3a 8c 3a			ld a, (.dmark+2)  
3a85 32 70 fe			ld (debug_mark+2),a  
3a88 18 03			jr .pastdmark  
3a8a ..			.dmark: db "PLU"  
3a8d f1			.pastdmark: pop af  
3a8e			endm  
# End of macro DMARK
3a8e						CALLMONITOR 
3a8e cd 9e 19			call break_point_state  
3a91				endm  
# End of macro CALLMONITOR
3a91					endif 
3a91					; add top two values and push back result 
3a91			 
3a91					;for v5 FORTH_DSP_VALUE 
3a91					FORTH_DSP 
3a91 cd 26 22			call macro_forth_dsp 
3a94				endm 
# End of macro FORTH_DSP
3a94 7e					ld a,(hl)	; get type of value on TOS 
3a95 fe 02				cp DS_TYPE_INUM  
3a97 28 03				jr z, .dot_inum 
3a99			 
3a99					NEXTW 
3a99 c3 16 24			jp macro_next 
3a9c				endm 
# End of macro NEXTW
3a9c			 
3a9c			; float maths 
3a9c			 
3a9c				if FORTH_ENABLE_FLOATMATH 
3a9c						inc hl      ; now at start of numeric as string 
3a9c			 
3a9c					if DEBUG_FORTH_MATHS 
3a9c						DMARK "ADD" 
3a9c				CALLMONITOR 
3a9c					endif 
3a9c			 
3a9c					;ld ix, hl 
3a9c					call CON 
3a9c			 
3a9c			 
3a9c					push hl 
3a9c					 
3a9c					 
3a9c			 
3a9c						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3a9c			 
3a9c					; get next number 
3a9c			 
3a9c						FORTH_DSP_VALUE 
3a9c			 
3a9c						inc hl      ; now at start of numeric as string 
3a9c			 
3a9c					;ld ix, hl 
3a9c					call CON 
3a9c			 
3a9c					push hl 
3a9c			 
3a9c			 
3a9c						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9c			 
3a9c						; TODO do add 
3a9c			 
3a9c						call IADD 
3a9c			 
3a9c						; TODO get result back as ascii 
3a9c			 
3a9c						; TODO push result  
3a9c			 
3a9c			 
3a9c			 
3a9c						jr .dot_done 
3a9c				endif 
3a9c			 
3a9c			.dot_inum: 
3a9c			 
3a9c			 
3a9c					if DEBUG_FORTH_DOT 
3a9c						DMARK "+IT" 
3a9c f5				push af  
3a9d 3a b1 3a			ld a, (.dmark)  
3aa0 32 6e fe			ld (debug_mark),a  
3aa3 3a b2 3a			ld a, (.dmark+1)  
3aa6 32 6f fe			ld (debug_mark+1),a  
3aa9 3a b3 3a			ld a, (.dmark+2)  
3aac 32 70 fe			ld (debug_mark+2),a  
3aaf 18 03			jr .pastdmark  
3ab1 ..			.dmark: db "+IT"  
3ab4 f1			.pastdmark: pop af  
3ab5			endm  
# End of macro DMARK
3ab5				CALLMONITOR 
3ab5 cd 9e 19			call break_point_state  
3ab8				endm  
# End of macro CALLMONITOR
3ab8					endif 
3ab8			 
3ab8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ab8 cd 60 22			call macro_dsp_valuehl 
3abb				endm 
# End of macro FORTH_DSP_VALUEHL
3abb			 
3abb				; TODO add floating point number detection 
3abb			 
3abb e5					push hl 
3abc			 
3abc					; destroy value TOS 
3abc			 
3abc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3abc cd 18 23			call macro_forth_dsp_pop 
3abf				endm 
# End of macro FORTH_DSP_POP
3abf			 
3abf			 
3abf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3abf cd 60 22			call macro_dsp_valuehl 
3ac2				endm 
# End of macro FORTH_DSP_VALUEHL
3ac2			 
3ac2					; one value on hl get other one back 
3ac2			 
3ac2 d1					pop de 
3ac3			 
3ac3					; do the add 
3ac3			 
3ac3 19					add hl,de 
3ac4			 
3ac4					; save it 
3ac4			 
3ac4			;		push hl	 
3ac4			 
3ac4					; 
3ac4			 
3ac4					; destroy value TOS 
3ac4			 
3ac4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac4 cd 18 23			call macro_forth_dsp_pop 
3ac7				endm 
# End of macro FORTH_DSP_POP
3ac7			 
3ac7					; TODO push value back onto stack for another op etc 
3ac7			 
3ac7			;		pop hl 
3ac7			 
3ac7			.dot_done: 
3ac7 cd 69 20				call forth_push_numhl 
3aca			 
3aca					NEXTW 
3aca c3 16 24			jp macro_next 
3acd				endm 
# End of macro NEXTW
3acd			.NEG: 
3acd			 
3acd				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3acd 17				db WORD_SYS_CORE+3             
3ace 10 3b			dw .DIV            
3ad0 02				db 1 + 1 
3ad1 .. 00			db "-",0              
3ad3				endm 
# End of macro CWHEAD
3ad3			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3ad3					if DEBUG_FORTH_WORDS_KEY 
3ad3						DMARK "SUB" 
3ad3 f5				push af  
3ad4 3a e8 3a			ld a, (.dmark)  
3ad7 32 6e fe			ld (debug_mark),a  
3ada 3a e9 3a			ld a, (.dmark+1)  
3add 32 6f fe			ld (debug_mark+1),a  
3ae0 3a ea 3a			ld a, (.dmark+2)  
3ae3 32 70 fe			ld (debug_mark+2),a  
3ae6 18 03			jr .pastdmark  
3ae8 ..			.dmark: db "SUB"  
3aeb f1			.pastdmark: pop af  
3aec			endm  
# End of macro DMARK
3aec						CALLMONITOR 
3aec cd 9e 19			call break_point_state  
3aef				endm  
# End of macro CALLMONITOR
3aef					endif 
3aef			 
3aef			 
3aef				; TODO add floating point number detection 
3aef					; v5 FORTH_DSP_VALUE 
3aef					FORTH_DSP 
3aef cd 26 22			call macro_forth_dsp 
3af2				endm 
# End of macro FORTH_DSP
3af2 7e					ld a,(hl)	; get type of value on TOS 
3af3 fe 02				cp DS_TYPE_INUM  
3af5 28 03				jr z, .neg_inum 
3af7			 
3af7					NEXTW 
3af7 c3 16 24			jp macro_next 
3afa				endm 
# End of macro NEXTW
3afa			 
3afa			; float maths 
3afa			 
3afa				if FORTH_ENABLE_FLOATMATH 
3afa					jr .neg_done 
3afa			 
3afa				endif 
3afa					 
3afa			 
3afa			.neg_inum: 
3afa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3afa cd 60 22			call macro_dsp_valuehl 
3afd				endm 
# End of macro FORTH_DSP_VALUEHL
3afd			 
3afd e5					push hl 
3afe			 
3afe					; destroy value TOS 
3afe			 
3afe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3afe cd 18 23			call macro_forth_dsp_pop 
3b01				endm 
# End of macro FORTH_DSP_POP
3b01			 
3b01			 
3b01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b01 cd 60 22			call macro_dsp_valuehl 
3b04				endm 
# End of macro FORTH_DSP_VALUEHL
3b04			 
3b04					; one value on hl get other one back 
3b04			 
3b04 d1					pop de 
3b05			 
3b05					; do the sub 
3b05			;		ex de, hl 
3b05			 
3b05 ed 52				sbc hl,de 
3b07			 
3b07					; save it 
3b07			 
3b07			;		push hl	 
3b07			 
3b07					; 
3b07			 
3b07					; destroy value TOS 
3b07			 
3b07					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b07 cd 18 23			call macro_forth_dsp_pop 
3b0a				endm 
# End of macro FORTH_DSP_POP
3b0a			 
3b0a					; TODO push value back onto stack for another op etc 
3b0a			 
3b0a			;		pop hl 
3b0a			 
3b0a cd 69 20				call forth_push_numhl 
3b0d			.neg_done: 
3b0d			 
3b0d					NEXTW 
3b0d c3 16 24			jp macro_next 
3b10				endm 
# End of macro NEXTW
3b10			.DIV: 
3b10				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3b10 18				db WORD_SYS_CORE+4             
3b11 5d 3b			dw .MUL            
3b13 02				db 1 + 1 
3b14 .. 00			db "/",0              
3b16				endm 
# End of macro CWHEAD
3b16			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3b16					if DEBUG_FORTH_WORDS_KEY 
3b16						DMARK "DIV" 
3b16 f5				push af  
3b17 3a 2b 3b			ld a, (.dmark)  
3b1a 32 6e fe			ld (debug_mark),a  
3b1d 3a 2c 3b			ld a, (.dmark+1)  
3b20 32 6f fe			ld (debug_mark+1),a  
3b23 3a 2d 3b			ld a, (.dmark+2)  
3b26 32 70 fe			ld (debug_mark+2),a  
3b29 18 03			jr .pastdmark  
3b2b ..			.dmark: db "DIV"  
3b2e f1			.pastdmark: pop af  
3b2f			endm  
# End of macro DMARK
3b2f						CALLMONITOR 
3b2f cd 9e 19			call break_point_state  
3b32				endm  
# End of macro CALLMONITOR
3b32					endif 
3b32				; TODO add floating point number detection 
3b32					; v5 FORTH_DSP_VALUE 
3b32					FORTH_DSP 
3b32 cd 26 22			call macro_forth_dsp 
3b35				endm 
# End of macro FORTH_DSP
3b35 7e					ld a,(hl)	; get type of value on TOS 
3b36 fe 02				cp DS_TYPE_INUM  
3b38 28 03				jr z, .div_inum 
3b3a			 
3b3a				if FORTH_ENABLE_FLOATMATH 
3b3a					jr .div_done 
3b3a			 
3b3a				endif 
3b3a					NEXTW 
3b3a c3 16 24			jp macro_next 
3b3d				endm 
# End of macro NEXTW
3b3d			.div_inum: 
3b3d			 
3b3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b3d cd 60 22			call macro_dsp_valuehl 
3b40				endm 
# End of macro FORTH_DSP_VALUEHL
3b40			 
3b40 e5					push hl    ; to go to bc 
3b41			 
3b41					; destroy value TOS 
3b41			 
3b41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b41 cd 18 23			call macro_forth_dsp_pop 
3b44				endm 
# End of macro FORTH_DSP_POP
3b44			 
3b44			 
3b44					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b44 cd 60 22			call macro_dsp_valuehl 
3b47				endm 
# End of macro FORTH_DSP_VALUEHL
3b47			 
3b47					; hl to go to de 
3b47			 
3b47 e5					push hl 
3b48			 
3b48 c1					pop bc 
3b49 d1					pop de		 
3b4a			 
3b4a			 
3b4a					if DEBUG_FORTH_MATHS 
3b4a						DMARK "DIV" 
3b4a				CALLMONITOR 
3b4a					endif 
3b4a					; one value on hl but move to a get other one back 
3b4a			 
3b4a			        
3b4a cd a9 0e			call Div16 
3b4d			 
3b4d			;	push af	 
3b4d e5				push hl 
3b4e c5				push bc 
3b4f			 
3b4f					if DEBUG_FORTH_MATHS 
3b4f						DMARK "DI1" 
3b4f				CALLMONITOR 
3b4f					endif 
3b4f			 
3b4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b4f cd 18 23			call macro_forth_dsp_pop 
3b52				endm 
# End of macro FORTH_DSP_POP
3b52			 
3b52			 
3b52			 
3b52 e1					pop hl    ; result 
3b53			 
3b53 cd 69 20				call forth_push_numhl 
3b56			 
3b56 e1					pop hl    ; reminder 
3b57			;		ld h,0 
3b57			;		ld l,d 
3b57			 
3b57 cd 69 20				call forth_push_numhl 
3b5a			.div_done: 
3b5a					NEXTW 
3b5a c3 16 24			jp macro_next 
3b5d				endm 
# End of macro NEXTW
3b5d			.MUL: 
3b5d				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3b5d 19				db WORD_SYS_CORE+5             
3b5e a2 3b			dw .MIN            
3b60 02				db 1 + 1 
3b61 .. 00			db "*",0              
3b63				endm 
# End of macro CWHEAD
3b63			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3b63				; TODO add floating point number detection 
3b63					if DEBUG_FORTH_WORDS_KEY 
3b63						DMARK "MUL" 
3b63 f5				push af  
3b64 3a 78 3b			ld a, (.dmark)  
3b67 32 6e fe			ld (debug_mark),a  
3b6a 3a 79 3b			ld a, (.dmark+1)  
3b6d 32 6f fe			ld (debug_mark+1),a  
3b70 3a 7a 3b			ld a, (.dmark+2)  
3b73 32 70 fe			ld (debug_mark+2),a  
3b76 18 03			jr .pastdmark  
3b78 ..			.dmark: db "MUL"  
3b7b f1			.pastdmark: pop af  
3b7c			endm  
# End of macro DMARK
3b7c						CALLMONITOR 
3b7c cd 9e 19			call break_point_state  
3b7f				endm  
# End of macro CALLMONITOR
3b7f					endif 
3b7f					FORTH_DSP 
3b7f cd 26 22			call macro_forth_dsp 
3b82				endm 
# End of macro FORTH_DSP
3b82					; v5 FORTH_DSP_VALUE 
3b82 7e					ld a,(hl)	; get type of value on TOS 
3b83 fe 02				cp DS_TYPE_INUM  
3b85 28 03				jr z, .mul_inum 
3b87			 
3b87				if FORTH_ENABLE_FLOATMATH 
3b87					jr .mul_done 
3b87			 
3b87				endif 
3b87			 
3b87					NEXTW 
3b87 c3 16 24			jp macro_next 
3b8a				endm 
# End of macro NEXTW
3b8a			.mul_inum:	 
3b8a			 
3b8a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b8a cd 60 22			call macro_dsp_valuehl 
3b8d				endm 
# End of macro FORTH_DSP_VALUEHL
3b8d			 
3b8d e5					push hl 
3b8e			 
3b8e					; destroy value TOS 
3b8e			 
3b8e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b8e cd 18 23			call macro_forth_dsp_pop 
3b91				endm 
# End of macro FORTH_DSP_POP
3b91			 
3b91			 
3b91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b91 cd 60 22			call macro_dsp_valuehl 
3b94				endm 
# End of macro FORTH_DSP_VALUEHL
3b94			 
3b94					; one value on hl but move to a get other one back 
3b94			 
3b94 7d					ld a, l 
3b95			 
3b95 d1					pop de 
3b96			 
3b96					; do the mull 
3b96			;		ex de, hl 
3b96			 
3b96 cd cf 0e				call Mult16 
3b99					; save it 
3b99			 
3b99			;		push hl	 
3b99			 
3b99					; 
3b99			 
3b99					; destroy value TOS 
3b99			 
3b99					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b99 cd 18 23			call macro_forth_dsp_pop 
3b9c				endm 
# End of macro FORTH_DSP_POP
3b9c			 
3b9c					; TODO push value back onto stack for another op etc 
3b9c			 
3b9c			;		pop hl 
3b9c			 
3b9c cd 69 20				call forth_push_numhl 
3b9f			 
3b9f			.mul_done: 
3b9f					NEXTW 
3b9f c3 16 24			jp macro_next 
3ba2				endm 
# End of macro NEXTW
3ba2			 
3ba2			 
3ba2			 
3ba2			 
3ba2			.MIN: 
3ba2				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3ba2 49				db WORD_SYS_CORE+53             
3ba3 23 3c			dw .MAX            
3ba5 04				db 3 + 1 
3ba6 .. 00			db "MIN",0              
3baa				endm 
# End of macro CWHEAD
3baa			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3baa					if DEBUG_FORTH_WORDS_KEY 
3baa						DMARK "MIN" 
3baa f5				push af  
3bab 3a bf 3b			ld a, (.dmark)  
3bae 32 6e fe			ld (debug_mark),a  
3bb1 3a c0 3b			ld a, (.dmark+1)  
3bb4 32 6f fe			ld (debug_mark+1),a  
3bb7 3a c1 3b			ld a, (.dmark+2)  
3bba 32 70 fe			ld (debug_mark+2),a  
3bbd 18 03			jr .pastdmark  
3bbf ..			.dmark: db "MIN"  
3bc2 f1			.pastdmark: pop af  
3bc3			endm  
# End of macro DMARK
3bc3						CALLMONITOR 
3bc3 cd 9e 19			call break_point_state  
3bc6				endm  
# End of macro CALLMONITOR
3bc6					endif 
3bc6					; get u2 
3bc6			 
3bc6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bc6 cd 60 22			call macro_dsp_valuehl 
3bc9				endm 
# End of macro FORTH_DSP_VALUEHL
3bc9			 
3bc9 e5					push hl   ; u2 
3bca			 
3bca					; destroy value TOS 
3bca			 
3bca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bca cd 18 23			call macro_forth_dsp_pop 
3bcd				endm 
# End of macro FORTH_DSP_POP
3bcd			 
3bcd					; get u1 
3bcd			 
3bcd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bcd cd 60 22			call macro_dsp_valuehl 
3bd0				endm 
# End of macro FORTH_DSP_VALUEHL
3bd0			 
3bd0 e5					push hl  ; u1 
3bd1			 
3bd1					; destroy value TOS 
3bd1			 
3bd1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd1 cd 18 23			call macro_forth_dsp_pop 
3bd4				endm 
# End of macro FORTH_DSP_POP
3bd4			 
3bd4 b7			 or a      ;clear carry flag 
3bd5 e1			  pop hl    ; u1 
3bd6 d1			  pop de    ; u2 
3bd7 e5				push hl   ; saved in case hl is lowest 
3bd8 ed 52		  sbc hl,de 
3bda 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3bdc			 
3bdc e1				pop hl 
3bdd					if DEBUG_FORTH_WORDS 
3bdd						DMARK "MIN" 
3bdd f5				push af  
3bde 3a f2 3b			ld a, (.dmark)  
3be1 32 6e fe			ld (debug_mark),a  
3be4 3a f3 3b			ld a, (.dmark+1)  
3be7 32 6f fe			ld (debug_mark+1),a  
3bea 3a f4 3b			ld a, (.dmark+2)  
3bed 32 70 fe			ld (debug_mark+2),a  
3bf0 18 03			jr .pastdmark  
3bf2 ..			.dmark: db "MIN"  
3bf5 f1			.pastdmark: pop af  
3bf6			endm  
# End of macro DMARK
3bf6						CALLMONITOR 
3bf6 cd 9e 19			call break_point_state  
3bf9				endm  
# End of macro CALLMONITOR
3bf9					endif 
3bf9 cd 69 20				call forth_push_numhl 
3bfc			 
3bfc				       NEXTW 
3bfc c3 16 24			jp macro_next 
3bff				endm 
# End of macro NEXTW
3bff			 
3bff			.mincont:  
3bff c1				pop bc   ; tidy up 
3c00 eb				ex de , hl  
3c01					if DEBUG_FORTH_WORDS 
3c01						DMARK "MI1" 
3c01 f5				push af  
3c02 3a 16 3c			ld a, (.dmark)  
3c05 32 6e fe			ld (debug_mark),a  
3c08 3a 17 3c			ld a, (.dmark+1)  
3c0b 32 6f fe			ld (debug_mark+1),a  
3c0e 3a 18 3c			ld a, (.dmark+2)  
3c11 32 70 fe			ld (debug_mark+2),a  
3c14 18 03			jr .pastdmark  
3c16 ..			.dmark: db "MI1"  
3c19 f1			.pastdmark: pop af  
3c1a			endm  
# End of macro DMARK
3c1a						CALLMONITOR 
3c1a cd 9e 19			call break_point_state  
3c1d				endm  
# End of macro CALLMONITOR
3c1d					endif 
3c1d cd 69 20				call forth_push_numhl 
3c20			 
3c20				       NEXTW 
3c20 c3 16 24			jp macro_next 
3c23				endm 
# End of macro NEXTW
3c23			.MAX: 
3c23				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3c23 4a				db WORD_SYS_CORE+54             
3c24 a4 3c			dw .RND16            
3c26 04				db 3 + 1 
3c27 .. 00			db "MAX",0              
3c2b				endm 
# End of macro CWHEAD
3c2b			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3c2b					if DEBUG_FORTH_WORDS_KEY 
3c2b						DMARK "MAX" 
3c2b f5				push af  
3c2c 3a 40 3c			ld a, (.dmark)  
3c2f 32 6e fe			ld (debug_mark),a  
3c32 3a 41 3c			ld a, (.dmark+1)  
3c35 32 6f fe			ld (debug_mark+1),a  
3c38 3a 42 3c			ld a, (.dmark+2)  
3c3b 32 70 fe			ld (debug_mark+2),a  
3c3e 18 03			jr .pastdmark  
3c40 ..			.dmark: db "MAX"  
3c43 f1			.pastdmark: pop af  
3c44			endm  
# End of macro DMARK
3c44						CALLMONITOR 
3c44 cd 9e 19			call break_point_state  
3c47				endm  
# End of macro CALLMONITOR
3c47					endif 
3c47					; get u2 
3c47			 
3c47					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c47 cd 60 22			call macro_dsp_valuehl 
3c4a				endm 
# End of macro FORTH_DSP_VALUEHL
3c4a			 
3c4a e5					push hl   ; u2 
3c4b			 
3c4b					; destroy value TOS 
3c4b			 
3c4b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4b cd 18 23			call macro_forth_dsp_pop 
3c4e				endm 
# End of macro FORTH_DSP_POP
3c4e			 
3c4e					; get u1 
3c4e			 
3c4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c4e cd 60 22			call macro_dsp_valuehl 
3c51				endm 
# End of macro FORTH_DSP_VALUEHL
3c51			 
3c51 e5					push hl  ; u1 
3c52			 
3c52					; destroy value TOS 
3c52			 
3c52					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c52 cd 18 23			call macro_forth_dsp_pop 
3c55				endm 
# End of macro FORTH_DSP_POP
3c55			 
3c55 b7			 or a      ;clear carry flag 
3c56 e1			  pop hl    ; u1 
3c57 d1			  pop de    ; u2 
3c58 e5				push hl   ; saved in case hl is lowest 
3c59 ed 52		  sbc hl,de 
3c5b 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3c5d			 
3c5d e1				pop hl 
3c5e					if DEBUG_FORTH_WORDS 
3c5e						DMARK "MAX" 
3c5e f5				push af  
3c5f 3a 73 3c			ld a, (.dmark)  
3c62 32 6e fe			ld (debug_mark),a  
3c65 3a 74 3c			ld a, (.dmark+1)  
3c68 32 6f fe			ld (debug_mark+1),a  
3c6b 3a 75 3c			ld a, (.dmark+2)  
3c6e 32 70 fe			ld (debug_mark+2),a  
3c71 18 03			jr .pastdmark  
3c73 ..			.dmark: db "MAX"  
3c76 f1			.pastdmark: pop af  
3c77			endm  
# End of macro DMARK
3c77						CALLMONITOR 
3c77 cd 9e 19			call break_point_state  
3c7a				endm  
# End of macro CALLMONITOR
3c7a					endif 
3c7a cd 69 20				call forth_push_numhl 
3c7d			 
3c7d				       NEXTW 
3c7d c3 16 24			jp macro_next 
3c80				endm 
# End of macro NEXTW
3c80			 
3c80			.maxcont:  
3c80 c1				pop bc   ; tidy up 
3c81 eb				ex de , hl  
3c82					if DEBUG_FORTH_WORDS 
3c82						DMARK "MA1" 
3c82 f5				push af  
3c83 3a 97 3c			ld a, (.dmark)  
3c86 32 6e fe			ld (debug_mark),a  
3c89 3a 98 3c			ld a, (.dmark+1)  
3c8c 32 6f fe			ld (debug_mark+1),a  
3c8f 3a 99 3c			ld a, (.dmark+2)  
3c92 32 70 fe			ld (debug_mark+2),a  
3c95 18 03			jr .pastdmark  
3c97 ..			.dmark: db "MA1"  
3c9a f1			.pastdmark: pop af  
3c9b			endm  
# End of macro DMARK
3c9b						CALLMONITOR 
3c9b cd 9e 19			call break_point_state  
3c9e				endm  
# End of macro CALLMONITOR
3c9e					endif 
3c9e cd 69 20				call forth_push_numhl 
3ca1				       NEXTW 
3ca1 c3 16 24			jp macro_next 
3ca4				endm 
# End of macro NEXTW
3ca4			 
3ca4			.RND16: 
3ca4				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3ca4 4e				db WORD_SYS_CORE+58             
3ca5 d3 3c			dw .RND8            
3ca7 06				db 5 + 1 
3ca8 .. 00			db "RND16",0              
3cae				endm 
# End of macro CWHEAD
3cae			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3cae					if DEBUG_FORTH_WORDS_KEY 
3cae						DMARK "R16" 
3cae f5				push af  
3caf 3a c3 3c			ld a, (.dmark)  
3cb2 32 6e fe			ld (debug_mark),a  
3cb5 3a c4 3c			ld a, (.dmark+1)  
3cb8 32 6f fe			ld (debug_mark+1),a  
3cbb 3a c5 3c			ld a, (.dmark+2)  
3cbe 32 70 fe			ld (debug_mark+2),a  
3cc1 18 03			jr .pastdmark  
3cc3 ..			.dmark: db "R16"  
3cc6 f1			.pastdmark: pop af  
3cc7			endm  
# End of macro DMARK
3cc7						CALLMONITOR 
3cc7 cd 9e 19			call break_point_state  
3cca				endm  
# End of macro CALLMONITOR
3cca					endif 
3cca cd 73 0e				call prng16  
3ccd cd 69 20				call forth_push_numhl 
3cd0				       NEXTW 
3cd0 c3 16 24			jp macro_next 
3cd3				endm 
# End of macro NEXTW
3cd3			.RND8: 
3cd3				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3cd3 60				db WORD_SYS_CORE+76             
3cd4 08 3d			dw .RND            
3cd6 05				db 4 + 1 
3cd7 .. 00			db "RND8",0              
3cdc				endm 
# End of macro CWHEAD
3cdc			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3cdc					if DEBUG_FORTH_WORDS_KEY 
3cdc						DMARK "RN8" 
3cdc f5				push af  
3cdd 3a f1 3c			ld a, (.dmark)  
3ce0 32 6e fe			ld (debug_mark),a  
3ce3 3a f2 3c			ld a, (.dmark+1)  
3ce6 32 6f fe			ld (debug_mark+1),a  
3ce9 3a f3 3c			ld a, (.dmark+2)  
3cec 32 70 fe			ld (debug_mark+2),a  
3cef 18 03			jr .pastdmark  
3cf1 ..			.dmark: db "RN8"  
3cf4 f1			.pastdmark: pop af  
3cf5			endm  
# End of macro DMARK
3cf5						CALLMONITOR 
3cf5 cd 9e 19			call break_point_state  
3cf8				endm  
# End of macro CALLMONITOR
3cf8					endif 
3cf8 2a af fb				ld hl,(xrandc) 
3cfb 23					inc hl 
3cfc cd 8d 0e				call xrnd 
3cff 6f					ld l,a	 
3d00 26 00				ld h,0 
3d02 cd 69 20				call forth_push_numhl 
3d05				       NEXTW 
3d05 c3 16 24			jp macro_next 
3d08				endm 
# End of macro NEXTW
3d08			.RND: 
3d08				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3d08 60				db WORD_SYS_CORE+76             
3d09 0e 3e			dw .ENDMATHS            
3d0b 04				db 3 + 1 
3d0c .. 00			db "RND",0              
3d10				endm 
# End of macro CWHEAD
3d10			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3d10			 
3d10					if DEBUG_FORTH_WORDS_KEY 
3d10						DMARK "RND" 
3d10 f5				push af  
3d11 3a 25 3d			ld a, (.dmark)  
3d14 32 6e fe			ld (debug_mark),a  
3d17 3a 26 3d			ld a, (.dmark+1)  
3d1a 32 6f fe			ld (debug_mark+1),a  
3d1d 3a 27 3d			ld a, (.dmark+2)  
3d20 32 70 fe			ld (debug_mark+2),a  
3d23 18 03			jr .pastdmark  
3d25 ..			.dmark: db "RND"  
3d28 f1			.pastdmark: pop af  
3d29			endm  
# End of macro DMARK
3d29						CALLMONITOR 
3d29 cd 9e 19			call break_point_state  
3d2c				endm  
# End of macro CALLMONITOR
3d2c					endif 
3d2c					 
3d2c					FORTH_DSP_VALUEHL    ; upper range 
3d2c cd 60 22			call macro_dsp_valuehl 
3d2f				endm 
# End of macro FORTH_DSP_VALUEHL
3d2f			 
3d2f 22 b3 fb				ld (LFSRSeed), hl	 
3d32			 
3d32					if DEBUG_FORTH_WORDS 
3d32						DMARK "RN1" 
3d32 f5				push af  
3d33 3a 47 3d			ld a, (.dmark)  
3d36 32 6e fe			ld (debug_mark),a  
3d39 3a 48 3d			ld a, (.dmark+1)  
3d3c 32 6f fe			ld (debug_mark+1),a  
3d3f 3a 49 3d			ld a, (.dmark+2)  
3d42 32 70 fe			ld (debug_mark+2),a  
3d45 18 03			jr .pastdmark  
3d47 ..			.dmark: db "RN1"  
3d4a f1			.pastdmark: pop af  
3d4b			endm  
# End of macro DMARK
3d4b						CALLMONITOR 
3d4b cd 9e 19			call break_point_state  
3d4e				endm  
# End of macro CALLMONITOR
3d4e					endif 
3d4e					FORTH_DSP_POP 
3d4e cd 18 23			call macro_forth_dsp_pop 
3d51				endm 
# End of macro FORTH_DSP_POP
3d51			 
3d51					FORTH_DSP_VALUEHL    ; low range 
3d51 cd 60 22			call macro_dsp_valuehl 
3d54				endm 
# End of macro FORTH_DSP_VALUEHL
3d54			 
3d54					if DEBUG_FORTH_WORDS 
3d54						DMARK "RN2" 
3d54 f5				push af  
3d55 3a 69 3d			ld a, (.dmark)  
3d58 32 6e fe			ld (debug_mark),a  
3d5b 3a 6a 3d			ld a, (.dmark+1)  
3d5e 32 6f fe			ld (debug_mark+1),a  
3d61 3a 6b 3d			ld a, (.dmark+2)  
3d64 32 70 fe			ld (debug_mark+2),a  
3d67 18 03			jr .pastdmark  
3d69 ..			.dmark: db "RN2"  
3d6c f1			.pastdmark: pop af  
3d6d			endm  
# End of macro DMARK
3d6d						CALLMONITOR 
3d6d cd 9e 19			call break_point_state  
3d70				endm  
# End of macro CALLMONITOR
3d70					endif 
3d70 22 b5 fb				ld (LFSRSeed+2), hl 
3d73			 
3d73					FORTH_DSP_POP 
3d73 cd 18 23			call macro_forth_dsp_pop 
3d76				endm 
# End of macro FORTH_DSP_POP
3d76			 
3d76 e5					push hl 
3d77			 
3d77 e1			.inrange:	pop hl 
3d78 cd 73 0e				call prng16  
3d7b					if DEBUG_FORTH_WORDS 
3d7b						DMARK "RN3" 
3d7b f5				push af  
3d7c 3a 90 3d			ld a, (.dmark)  
3d7f 32 6e fe			ld (debug_mark),a  
3d82 3a 91 3d			ld a, (.dmark+1)  
3d85 32 6f fe			ld (debug_mark+1),a  
3d88 3a 92 3d			ld a, (.dmark+2)  
3d8b 32 70 fe			ld (debug_mark+2),a  
3d8e 18 03			jr .pastdmark  
3d90 ..			.dmark: db "RN3"  
3d93 f1			.pastdmark: pop af  
3d94			endm  
# End of macro DMARK
3d94						CALLMONITOR 
3d94 cd 9e 19			call break_point_state  
3d97				endm  
# End of macro CALLMONITOR
3d97					endif 
3d97					 
3d97					; if the range is 8bit knock out the high byte 
3d97			 
3d97 ed 5b b3 fb			ld de, (LFSRSeed)     ; check high level 
3d9b			 
3d9b 3e 00				ld a, 0 
3d9d ba					cp d  
3d9e 20 1e				jr nz, .hirange 
3da0 26 00				ld h, 0   ; knock it down to 8bit 
3da2			 
3da2					if DEBUG_FORTH_WORDS 
3da2						DMARK "RNk" 
3da2 f5				push af  
3da3 3a b7 3d			ld a, (.dmark)  
3da6 32 6e fe			ld (debug_mark),a  
3da9 3a b8 3d			ld a, (.dmark+1)  
3dac 32 6f fe			ld (debug_mark+1),a  
3daf 3a b9 3d			ld a, (.dmark+2)  
3db2 32 70 fe			ld (debug_mark+2),a  
3db5 18 03			jr .pastdmark  
3db7 ..			.dmark: db "RNk"  
3dba f1			.pastdmark: pop af  
3dbb			endm  
# End of macro DMARK
3dbb						CALLMONITOR 
3dbb cd 9e 19			call break_point_state  
3dbe				endm  
# End of macro CALLMONITOR
3dbe					endif 
3dbe			.hirange:   
3dbe e5					push hl  
3dbf b7					or a  
3dc0 ed 52		                sbc hl, de 
3dc2			 
3dc2					;call cmp16 
3dc2			 
3dc2 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3dc4 e1					pop hl 
3dc5 e5					push hl 
3dc6			 
3dc6					if DEBUG_FORTH_WORDS 
3dc6						DMARK "RN4" 
3dc6 f5				push af  
3dc7 3a db 3d			ld a, (.dmark)  
3dca 32 6e fe			ld (debug_mark),a  
3dcd 3a dc 3d			ld a, (.dmark+1)  
3dd0 32 6f fe			ld (debug_mark+1),a  
3dd3 3a dd 3d			ld a, (.dmark+2)  
3dd6 32 70 fe			ld (debug_mark+2),a  
3dd9 18 03			jr .pastdmark  
3ddb ..			.dmark: db "RN4"  
3dde f1			.pastdmark: pop af  
3ddf			endm  
# End of macro DMARK
3ddf						CALLMONITOR 
3ddf cd 9e 19			call break_point_state  
3de2				endm  
# End of macro CALLMONITOR
3de2					endif 
3de2 ed 5b b5 fb			ld de, (LFSRSeed+2)   ; check low range 
3de6					;call cmp16 
3de6				 
3de6 b7					or a  
3de7 ed 52		                sbc hl, de 
3de9 38 8c				jr c, .inrange 
3deb			 
3deb e1					pop hl 
3dec					 
3dec					if DEBUG_FORTH_WORDS 
3dec						DMARK "RNd" 
3dec f5				push af  
3ded 3a 01 3e			ld a, (.dmark)  
3df0 32 6e fe			ld (debug_mark),a  
3df3 3a 02 3e			ld a, (.dmark+1)  
3df6 32 6f fe			ld (debug_mark+1),a  
3df9 3a 03 3e			ld a, (.dmark+2)  
3dfc 32 70 fe			ld (debug_mark+2),a  
3dff 18 03			jr .pastdmark  
3e01 ..			.dmark: db "RNd"  
3e04 f1			.pastdmark: pop af  
3e05			endm  
# End of macro DMARK
3e05						CALLMONITOR 
3e05 cd 9e 19			call break_point_state  
3e08				endm  
# End of macro CALLMONITOR
3e08					endif 
3e08			 
3e08			 
3e08 cd 69 20				call forth_push_numhl 
3e0b				       NEXTW 
3e0b c3 16 24			jp macro_next 
3e0e				endm 
# End of macro NEXTW
3e0e			 
3e0e			.ENDMATHS: 
3e0e			 
3e0e			; eof 
3e0e			 
# End of file forth_words_maths.asm
3e0e			include "forth_words_display.asm" 
3e0e			 
3e0e			; | ## Display Words 
3e0e			 
3e0e			.INFO: 
3e0e			 
3e0e				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3e0e 62				db WORD_SYS_CORE+78             
3e0f 2b 3e			dw .ATP            
3e11 05				db 4 + 1 
3e12 .. 00			db "INFO",0              
3e17				endm 
# End of macro CWHEAD
3e17			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3e17					FORTH_DSP_VALUEHL 
3e17 cd 60 22			call macro_dsp_valuehl 
3e1a				endm 
# End of macro FORTH_DSP_VALUEHL
3e1a			 
3e1a					FORTH_DSP_POP 
3e1a cd 18 23			call macro_forth_dsp_pop 
3e1d				endm 
# End of macro FORTH_DSP_POP
3e1d			 
3e1d e5					push hl 
3e1e			 
3e1e					FORTH_DSP_VALUEHL 
3e1e cd 60 22			call macro_dsp_valuehl 
3e21				endm 
# End of macro FORTH_DSP_VALUEHL
3e21			 
3e21					FORTH_DSP_POP 
3e21 cd 18 23			call macro_forth_dsp_pop 
3e24				endm 
# End of macro FORTH_DSP_POP
3e24			 
3e24 d1					pop de 
3e25			 
3e25 cd a9 0c				call info_panel 
3e28			 
3e28			 
3e28					NEXTW 
3e28 c3 16 24			jp macro_next 
3e2b				endm 
# End of macro NEXTW
3e2b			.ATP: 
3e2b				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3e2b 62				db WORD_SYS_CORE+78             
3e2c a2 3e			dw .FB            
3e2e 04				db 3 + 1 
3e2f .. 00			db "AT?",0              
3e33				endm 
# End of macro CWHEAD
3e33			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3e33					if DEBUG_FORTH_WORDS_KEY 
3e33						DMARK "AT?" 
3e33 f5				push af  
3e34 3a 48 3e			ld a, (.dmark)  
3e37 32 6e fe			ld (debug_mark),a  
3e3a 3a 49 3e			ld a, (.dmark+1)  
3e3d 32 6f fe			ld (debug_mark+1),a  
3e40 3a 4a 3e			ld a, (.dmark+2)  
3e43 32 70 fe			ld (debug_mark+2),a  
3e46 18 03			jr .pastdmark  
3e48 ..			.dmark: db "AT?"  
3e4b f1			.pastdmark: pop af  
3e4c			endm  
# End of macro DMARK
3e4c						CALLMONITOR 
3e4c cd 9e 19			call break_point_state  
3e4f				endm  
# End of macro CALLMONITOR
3e4f					endif 
3e4f 3a 65 fa				ld a, (f_cursor_ptr) 
3e52			 
3e52			if DEBUG_FORTH_WORDS 
3e52				DMARK "AT?" 
3e52 f5				push af  
3e53 3a 67 3e			ld a, (.dmark)  
3e56 32 6e fe			ld (debug_mark),a  
3e59 3a 68 3e			ld a, (.dmark+1)  
3e5c 32 6f fe			ld (debug_mark+1),a  
3e5f 3a 69 3e			ld a, (.dmark+2)  
3e62 32 70 fe			ld (debug_mark+2),a  
3e65 18 03			jr .pastdmark  
3e67 ..			.dmark: db "AT?"  
3e6a f1			.pastdmark: pop af  
3e6b			endm  
# End of macro DMARK
3e6b				CALLMONITOR 
3e6b cd 9e 19			call break_point_state  
3e6e				endm  
# End of macro CALLMONITOR
3e6e			endif	 
3e6e					; count the number of rows 
3e6e			 
3e6e 06 00				ld b, 0 
3e70 4f			.atpr:		ld c, a    ; save in case we go below zero 
3e71 d6 28				sub display_cols 
3e73 f2 79 3e				jp p, .atprunder 
3e76 04					inc b 
3e77 18 f7				jr .atpr 
3e79			.atprunder:	 
3e79			if DEBUG_FORTH_WORDS 
3e79				DMARK "A?2" 
3e79 f5				push af  
3e7a 3a 8e 3e			ld a, (.dmark)  
3e7d 32 6e fe			ld (debug_mark),a  
3e80 3a 8f 3e			ld a, (.dmark+1)  
3e83 32 6f fe			ld (debug_mark+1),a  
3e86 3a 90 3e			ld a, (.dmark+2)  
3e89 32 70 fe			ld (debug_mark+2),a  
3e8c 18 03			jr .pastdmark  
3e8e ..			.dmark: db "A?2"  
3e91 f1			.pastdmark: pop af  
3e92			endm  
# End of macro DMARK
3e92				CALLMONITOR 
3e92 cd 9e 19			call break_point_state  
3e95				endm  
# End of macro CALLMONITOR
3e95			endif	 
3e95 26 00				ld h, 0 
3e97 69					ld l, c 
3e98 cd 69 20				call forth_push_numhl 
3e9b 68					ld l, b  
3e9c cd 69 20				call forth_push_numhl 
3e9f			 
3e9f			 
3e9f				NEXTW 
3e9f c3 16 24			jp macro_next 
3ea2				endm 
# End of macro NEXTW
3ea2			 
3ea2			.FB: 
3ea2				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ea2 1b				db WORD_SYS_CORE+7             
3ea3 f0 3e			dw .EMIT            
3ea5 03				db 2 + 1 
3ea6 .. 00			db "FB",0              
3ea9				endm 
# End of macro CWHEAD
3ea9			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ea9			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ea9			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ea9			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ea9					if DEBUG_FORTH_WORDS_KEY 
3ea9						DMARK "FB." 
3ea9 f5				push af  
3eaa 3a be 3e			ld a, (.dmark)  
3ead 32 6e fe			ld (debug_mark),a  
3eb0 3a bf 3e			ld a, (.dmark+1)  
3eb3 32 6f fe			ld (debug_mark+1),a  
3eb6 3a c0 3e			ld a, (.dmark+2)  
3eb9 32 70 fe			ld (debug_mark+2),a  
3ebc 18 03			jr .pastdmark  
3ebe ..			.dmark: db "FB."  
3ec1 f1			.pastdmark: pop af  
3ec2			endm  
# End of macro DMARK
3ec2						CALLMONITOR 
3ec2 cd 9e 19			call break_point_state  
3ec5				endm  
# End of macro CALLMONITOR
3ec5					endif 
3ec5			 
3ec5					FORTH_DSP_VALUEHL 
3ec5 cd 60 22			call macro_dsp_valuehl 
3ec8				endm 
# End of macro FORTH_DSP_VALUEHL
3ec8			 
3ec8 7d					ld a, l 
3ec9 fe 01				cp 1 
3ecb 20 05				jr nz, .fbn1 
3ecd 21 13 fd				ld hl, display_fb1 
3ed0 18 15				jr .fbset 
3ed2 fe 02		.fbn1:		cp 2 
3ed4 20 05				jr nz, .fbn2 
3ed6 21 d1 fb				ld hl, display_fb2 
3ed9 18 0c				jr .fbset 
3edb fe 03		.fbn2:		cp 3 
3edd 20 05				jr nz, .fbn3 
3edf 21 72 fc				ld hl, display_fb3 
3ee2 18 03				jr .fbset 
3ee4			.fbn3:		 ; if invalid number select first 
3ee4 21 13 fd				ld hl, display_fb1 
3ee7 22 cf fb		.fbset:		ld (display_fb_active), hl 
3eea			 
3eea					FORTH_DSP_POP 
3eea cd 18 23			call macro_forth_dsp_pop 
3eed				endm 
# End of macro FORTH_DSP_POP
3eed			 
3eed					NEXTW 
3eed c3 16 24			jp macro_next 
3ef0				endm 
# End of macro NEXTW
3ef0			 
3ef0			 
3ef0			.EMIT: 
3ef0				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3ef0 1b				db WORD_SYS_CORE+7             
3ef1 41 3f			dw .DOTH            
3ef3 05				db 4 + 1 
3ef4 .. 00			db "EMIT",0              
3ef9				endm 
# End of macro CWHEAD
3ef9			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3ef9					; get value off TOS and display it 
3ef9			 
3ef9					if DEBUG_FORTH_WORDS_KEY 
3ef9						DMARK "EMT" 
3ef9 f5				push af  
3efa 3a 0e 3f			ld a, (.dmark)  
3efd 32 6e fe			ld (debug_mark),a  
3f00 3a 0f 3f			ld a, (.dmark+1)  
3f03 32 6f fe			ld (debug_mark+1),a  
3f06 3a 10 3f			ld a, (.dmark+2)  
3f09 32 70 fe			ld (debug_mark+2),a  
3f0c 18 03			jr .pastdmark  
3f0e ..			.dmark: db "EMT"  
3f11 f1			.pastdmark: pop af  
3f12			endm  
# End of macro DMARK
3f12						CALLMONITOR 
3f12 cd 9e 19			call break_point_state  
3f15				endm  
# End of macro CALLMONITOR
3f15					endif 
3f15			 
3f15					FORTH_DSP_VALUEHL 
3f15 cd 60 22			call macro_dsp_valuehl 
3f18				endm 
# End of macro FORTH_DSP_VALUEHL
3f18			 
3f18 7d					ld a,l 
3f19			 
3f19					; TODO write to display 
3f19			 
3f19 32 c6 f3				ld (os_input), a 
3f1c 3e 00				ld a, 0 
3f1e 32 c7 f3				ld (os_input+1), a 
3f21					 
3f21 3a 65 fa				ld a, (f_cursor_ptr) 
3f24 11 c6 f3				ld de, os_input 
3f27 cd 2b 0d				call str_at_display 
3f2a			 
3f2a			 
3f2a 3a 43 fa				ld a,(cli_autodisplay) 
3f2d fe 00				cp 0 
3f2f 28 03				jr z, .enoupdate 
3f31 cd 3b 0d						call update_display 
3f34					.enoupdate: 
3f34			 
3f34 3a 65 fa				ld a, (f_cursor_ptr) 
3f37 3c					inc a 
3f38 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
3f3b			 
3f3b			 
3f3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f3b cd 18 23			call macro_forth_dsp_pop 
3f3e				endm 
# End of macro FORTH_DSP_POP
3f3e			  
3f3e			 
3f3e					NEXTW 
3f3e c3 16 24			jp macro_next 
3f41				endm 
# End of macro NEXTW
3f41			.DOTH: 
3f41				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3f41 1c				db WORD_SYS_CORE+8             
3f42 71 3f			dw .DOTF            
3f44 03				db 2 + 1 
3f45 .. 00			db ".-",0              
3f48				endm 
# End of macro CWHEAD
3f48			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3f48					; get value off TOS and display it 
3f48					if DEBUG_FORTH_WORDS_KEY 
3f48						DMARK "DTD" 
3f48 f5				push af  
3f49 3a 5d 3f			ld a, (.dmark)  
3f4c 32 6e fe			ld (debug_mark),a  
3f4f 3a 5e 3f			ld a, (.dmark+1)  
3f52 32 6f fe			ld (debug_mark+1),a  
3f55 3a 5f 3f			ld a, (.dmark+2)  
3f58 32 70 fe			ld (debug_mark+2),a  
3f5b 18 03			jr .pastdmark  
3f5d ..			.dmark: db "DTD"  
3f60 f1			.pastdmark: pop af  
3f61			endm  
# End of macro DMARK
3f61						CALLMONITOR 
3f61 cd 9e 19			call break_point_state  
3f64				endm  
# End of macro CALLMONITOR
3f64					endif 
3f64 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3f66 3e 00			ld a, 0 
3f68 32 44 fa			ld (cli_mvdot), a 
3f6b c3 c8 3f			jp .dotgo 
3f6e				NEXTW 
3f6e c3 16 24			jp macro_next 
3f71				endm 
# End of macro NEXTW
3f71			.DOTF: 
3f71				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3f71 1c				db WORD_SYS_CORE+8             
3f72 9f 3f			dw .DOT            
3f74 03				db 2 + 1 
3f75 .. 00			db ".>",0              
3f78				endm 
# End of macro CWHEAD
3f78			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3f78					; get value off TOS and display it 
3f78			        ; TODO BUG adds extra spaces 
3f78			        ; TODO BUG handle numerics? 
3f78					if DEBUG_FORTH_WORDS_KEY 
3f78						DMARK "DTC" 
3f78 f5				push af  
3f79 3a 8d 3f			ld a, (.dmark)  
3f7c 32 6e fe			ld (debug_mark),a  
3f7f 3a 8e 3f			ld a, (.dmark+1)  
3f82 32 6f fe			ld (debug_mark+1),a  
3f85 3a 8f 3f			ld a, (.dmark+2)  
3f88 32 70 fe			ld (debug_mark+2),a  
3f8b 18 03			jr .pastdmark  
3f8d ..			.dmark: db "DTC"  
3f90 f1			.pastdmark: pop af  
3f91			endm  
# End of macro DMARK
3f91						CALLMONITOR 
3f91 cd 9e 19			call break_point_state  
3f94				endm  
# End of macro CALLMONITOR
3f94					endif 
3f94 3e 01			ld a, 1 
3f96 32 44 fa			ld (cli_mvdot), a 
3f99 c3 c8 3f			jp .dotgo 
3f9c				NEXTW 
3f9c c3 16 24			jp macro_next 
3f9f				endm 
# End of macro NEXTW
3f9f			 
3f9f			.DOT: 
3f9f				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3f9f 1c				db WORD_SYS_CORE+8             
3fa0 7b 41			dw .CLS            
3fa2 02				db 1 + 1 
3fa3 .. 00			db ".",0              
3fa5				endm 
# End of macro CWHEAD
3fa5			        ; | . ( u -- ) Display TOS | DONE 
3fa5					; get value off TOS and display it 
3fa5			 
3fa5					if DEBUG_FORTH_WORDS_KEY 
3fa5						DMARK "DOT" 
3fa5 f5				push af  
3fa6 3a ba 3f			ld a, (.dmark)  
3fa9 32 6e fe			ld (debug_mark),a  
3fac 3a bb 3f			ld a, (.dmark+1)  
3faf 32 6f fe			ld (debug_mark+1),a  
3fb2 3a bc 3f			ld a, (.dmark+2)  
3fb5 32 70 fe			ld (debug_mark+2),a  
3fb8 18 03			jr .pastdmark  
3fba ..			.dmark: db "DOT"  
3fbd f1			.pastdmark: pop af  
3fbe			endm  
# End of macro DMARK
3fbe						CALLMONITOR 
3fbe cd 9e 19			call break_point_state  
3fc1				endm  
# End of macro CALLMONITOR
3fc1					endif 
3fc1 3e 00			ld a, 0 
3fc3 32 44 fa			ld (cli_mvdot), a 
3fc6 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3fc8				 
3fc8			 
3fc8			.dotgo: 
3fc8			 
3fc8			; move up type to on stack for parserv5 
3fc8					FORTH_DSP 
3fc8 cd 26 22			call macro_forth_dsp 
3fcb				endm 
# End of macro FORTH_DSP
3fcb				;FORTH_DSP_VALUE  
3fcb			 
3fcb			if DEBUG_FORTH_DOT 
3fcb				DMARK "DOT" 
3fcb f5				push af  
3fcc 3a e0 3f			ld a, (.dmark)  
3fcf 32 6e fe			ld (debug_mark),a  
3fd2 3a e1 3f			ld a, (.dmark+1)  
3fd5 32 6f fe			ld (debug_mark+1),a  
3fd8 3a e2 3f			ld a, (.dmark+2)  
3fdb 32 70 fe			ld (debug_mark+2),a  
3fde 18 03			jr .pastdmark  
3fe0 ..			.dmark: db "DOT"  
3fe3 f1			.pastdmark: pop af  
3fe4			endm  
# End of macro DMARK
3fe4				CALLMONITOR 
3fe4 cd 9e 19			call break_point_state  
3fe7				endm  
# End of macro CALLMONITOR
3fe7			endif	 
3fe7			;		.print: 
3fe7			 
3fe7 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3fe8 23				inc hl   ; position to the actual value 
3fe9 fe 01			cp DS_TYPE_STR 
3feb 20 06			jr nz, .dotnum1  
3fed			 
3fed			; display string 
3fed				FORTH_DSP_VALUE  
3fed cd 49 22			call macro_forth_dsp_value 
3ff0				endm 
# End of macro FORTH_DSP_VALUE
3ff0 eb				ex de,hl 
3ff1 18 49			jr .dotwrite 
3ff3			 
3ff3			.dotnum1: 
3ff3 fe 02			cp DS_TYPE_INUM 
3ff5 20 44			jr nz, .dotflot 
3ff7			 
3ff7			 
3ff7			; display number 
3ff7			 
3ff7			;	push hl 
3ff7			;	call clear_display 
3ff7			;	pop hl 
3ff7			 
3ff7 5e				ld e, (hl) 
3ff8 23				inc hl 
3ff9 56				ld d, (hl) 
3ffa 21 c8 f1			ld hl, scratch 
3ffd			if DEBUG_FORTH_DOT 
3ffd				DMARK "DT1" 
3ffd f5				push af  
3ffe 3a 12 40			ld a, (.dmark)  
4001 32 6e fe			ld (debug_mark),a  
4004 3a 13 40			ld a, (.dmark+1)  
4007 32 6f fe			ld (debug_mark+1),a  
400a 3a 14 40			ld a, (.dmark+2)  
400d 32 70 fe			ld (debug_mark+2),a  
4010 18 03			jr .pastdmark  
4012 ..			.dmark: db "DT1"  
4015 f1			.pastdmark: pop af  
4016			endm  
# End of macro DMARK
4016				CALLMONITOR 
4016 cd 9e 19			call break_point_state  
4019				endm  
# End of macro CALLMONITOR
4019			endif	 
4019			 
4019 cd 59 13			call uitoa_16 
401c eb				ex de,hl 
401d			 
401d			if DEBUG_FORTH_DOT 
401d				DMARK "DT2" 
401d f5				push af  
401e 3a 32 40			ld a, (.dmark)  
4021 32 6e fe			ld (debug_mark),a  
4024 3a 33 40			ld a, (.dmark+1)  
4027 32 6f fe			ld (debug_mark+1),a  
402a 3a 34 40			ld a, (.dmark+2)  
402d 32 70 fe			ld (debug_mark+2),a  
4030 18 03			jr .pastdmark  
4032 ..			.dmark: db "DT2"  
4035 f1			.pastdmark: pop af  
4036			endm  
# End of macro DMARK
4036				CALLMONITOR 
4036 cd 9e 19			call break_point_state  
4039				endm  
# End of macro CALLMONITOR
4039			endif	 
4039			 
4039			;	ld de, os_word_scratch 
4039 18 01			jr .dotwrite 
403b			 
403b 00			.dotflot:   nop 
403c			; TODO print floating point number 
403c			 
403c			.dotwrite:		 
403c			 
403c					; if c is set then set all '-' to spaces 
403c					; need to also take into account .>  
403c			 
403c 3e 01				ld a, 1 
403e b9					cp c 
403f 20 67				jr nz, .nodashswap 
4041			 
4041					; DE has the string to write, working with HL 
4041			 
4041 06 ff				ld b, 255 
4043 d5					push de 
4044 e1					pop hl 
4045			 
4045			if DEBUG_FORTH_DOT 
4045				DMARK "DT-" 
4045 f5				push af  
4046 3a 5a 40			ld a, (.dmark)  
4049 32 6e fe			ld (debug_mark),a  
404c 3a 5b 40			ld a, (.dmark+1)  
404f 32 6f fe			ld (debug_mark+1),a  
4052 3a 5c 40			ld a, (.dmark+2)  
4055 32 70 fe			ld (debug_mark+2),a  
4058 18 03			jr .pastdmark  
405a ..			.dmark: db "DT-"  
405d f1			.pastdmark: pop af  
405e			endm  
# End of macro DMARK
405e				CALLMONITOR 
405e cd 9e 19			call break_point_state  
4061				endm  
# End of macro CALLMONITOR
4061			endif	 
4061 7e			.dashscan:	ld a, (hl) 
4062 fe 00				cp 0 
4064 28 42				jr z, .nodashswap 
4066 fe 2d				cp '-' 
4068 20 03				jr nz, .dashskip 
406a 3e 20				ld a, ' ' 
406c 77					ld (hl), a 
406d 23			.dashskip:	inc hl 
406e			if DEBUG_FORTH_DOT 
406e				DMARK "D-2" 
406e f5				push af  
406f 3a 83 40			ld a, (.dmark)  
4072 32 6e fe			ld (debug_mark),a  
4075 3a 84 40			ld a, (.dmark+1)  
4078 32 6f fe			ld (debug_mark+1),a  
407b 3a 85 40			ld a, (.dmark+2)  
407e 32 70 fe			ld (debug_mark+2),a  
4081 18 03			jr .pastdmark  
4083 ..			.dmark: db "D-2"  
4086 f1			.pastdmark: pop af  
4087			endm  
# End of macro DMARK
4087				CALLMONITOR 
4087 cd 9e 19			call break_point_state  
408a				endm  
# End of macro CALLMONITOR
408a			endif	 
408a 10 d5				djnz .dashscan 
408c			 
408c			if DEBUG_FORTH_DOT 
408c				DMARK "D-1" 
408c f5				push af  
408d 3a a1 40			ld a, (.dmark)  
4090 32 6e fe			ld (debug_mark),a  
4093 3a a2 40			ld a, (.dmark+1)  
4096 32 6f fe			ld (debug_mark+1),a  
4099 3a a3 40			ld a, (.dmark+2)  
409c 32 70 fe			ld (debug_mark+2),a  
409f 18 03			jr .pastdmark  
40a1 ..			.dmark: db "D-1"  
40a4 f1			.pastdmark: pop af  
40a5			endm  
# End of macro DMARK
40a5				CALLMONITOR 
40a5 cd 9e 19			call break_point_state  
40a8				endm  
# End of macro CALLMONITOR
40a8			endif	 
40a8			 
40a8			.nodashswap: 
40a8			 
40a8			if DEBUG_FORTH_DOT 
40a8				DMARK "D-o" 
40a8 f5				push af  
40a9 3a bd 40			ld a, (.dmark)  
40ac 32 6e fe			ld (debug_mark),a  
40af 3a be 40			ld a, (.dmark+1)  
40b2 32 6f fe			ld (debug_mark+1),a  
40b5 3a bf 40			ld a, (.dmark+2)  
40b8 32 70 fe			ld (debug_mark+2),a  
40bb 18 03			jr .pastdmark  
40bd ..			.dmark: db "D-o"  
40c0 f1			.pastdmark: pop af  
40c1			endm  
# End of macro DMARK
40c1				CALLMONITOR 
40c1 cd 9e 19			call break_point_state  
40c4				endm  
# End of macro CALLMONITOR
40c4			endif	 
40c4			 
40c4 d5					push de   ; save string start in case we need to advance print 
40c5			 
40c5 3a 65 fa				ld a, (f_cursor_ptr) 
40c8 cd 2b 0d				call str_at_display 
40cb 3a 43 fa				ld a,(cli_autodisplay) 
40ce fe 00				cp 0 
40d0 28 03				jr z, .noupdate 
40d2 cd 3b 0d						call update_display 
40d5					.noupdate: 
40d5			 
40d5			 
40d5					; see if we need to advance the print position 
40d5			 
40d5 e1					pop hl   ; get back string 
40d6			;		ex de,hl 
40d6			 
40d6 3a 44 fa				ld a, (cli_mvdot) 
40d9			if DEBUG_FORTH_DOT 
40d9			;		ld e,a 
40d9				DMARK "D>1" 
40d9 f5				push af  
40da 3a ee 40			ld a, (.dmark)  
40dd 32 6e fe			ld (debug_mark),a  
40e0 3a ef 40			ld a, (.dmark+1)  
40e3 32 6f fe			ld (debug_mark+1),a  
40e6 3a f0 40			ld a, (.dmark+2)  
40e9 32 70 fe			ld (debug_mark+2),a  
40ec 18 03			jr .pastdmark  
40ee ..			.dmark: db "D>1"  
40f1 f1			.pastdmark: pop af  
40f2			endm  
# End of macro DMARK
40f2				CALLMONITOR 
40f2 cd 9e 19			call break_point_state  
40f5				endm  
# End of macro CALLMONITOR
40f5			endif	 
40f5 fe 00				cp 0 
40f7 28 44				jr z, .noadv 
40f9					; yes, lets advance the print position 
40f9 3e 00				ld a, 0 
40fb cd b5 13				call strlent 
40fe			if DEBUG_FORTH_DOT 
40fe				DMARK "D-?" 
40fe f5				push af  
40ff 3a 13 41			ld a, (.dmark)  
4102 32 6e fe			ld (debug_mark),a  
4105 3a 14 41			ld a, (.dmark+1)  
4108 32 6f fe			ld (debug_mark+1),a  
410b 3a 15 41			ld a, (.dmark+2)  
410e 32 70 fe			ld (debug_mark+2),a  
4111 18 03			jr .pastdmark  
4113 ..			.dmark: db "D-?"  
4116 f1			.pastdmark: pop af  
4117			endm  
# End of macro DMARK
4117				CALLMONITOR 
4117 cd 9e 19			call break_point_state  
411a				endm  
# End of macro CALLMONITOR
411a			endif	 
411a 3a 65 fa				ld a, (f_cursor_ptr) 
411d 85					add a,l 
411e					;call addatohl 
411e					;ld a, l 
411e 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
4121			 
4121			if DEBUG_FORTH_DOT 
4121				DMARK "D->" 
4121 f5				push af  
4122 3a 36 41			ld a, (.dmark)  
4125 32 6e fe			ld (debug_mark),a  
4128 3a 37 41			ld a, (.dmark+1)  
412b 32 6f fe			ld (debug_mark+1),a  
412e 3a 38 41			ld a, (.dmark+2)  
4131 32 70 fe			ld (debug_mark+2),a  
4134 18 03			jr .pastdmark  
4136 ..			.dmark: db "D->"  
4139 f1			.pastdmark: pop af  
413a			endm  
# End of macro DMARK
413a				CALLMONITOR 
413a cd 9e 19			call break_point_state  
413d				endm  
# End of macro CALLMONITOR
413d			endif	 
413d			 
413d			.noadv:	 
413d			 
413d					if DEBUG_FORTH_DOT_WAIT 
413d							call next_page_prompt 
413d					endif	 
413d			; TODO this pop off the stack causes a crash. i dont know why 
413d			 
413d			 
413d			if DEBUG_FORTH_DOT 
413d				DMARK "DTh" 
413d f5				push af  
413e 3a 52 41			ld a, (.dmark)  
4141 32 6e fe			ld (debug_mark),a  
4144 3a 53 41			ld a, (.dmark+1)  
4147 32 6f fe			ld (debug_mark+1),a  
414a 3a 54 41			ld a, (.dmark+2)  
414d 32 70 fe			ld (debug_mark+2),a  
4150 18 03			jr .pastdmark  
4152 ..			.dmark: db "DTh"  
4155 f1			.pastdmark: pop af  
4156			endm  
# End of macro DMARK
4156				CALLMONITOR 
4156 cd 9e 19			call break_point_state  
4159				endm  
# End of macro CALLMONITOR
4159			endif	 
4159			 
4159					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4159 cd 18 23			call macro_forth_dsp_pop 
415c				endm 
# End of macro FORTH_DSP_POP
415c			 
415c			if DEBUG_FORTH_DOT 
415c				DMARK "DTi" 
415c f5				push af  
415d 3a 71 41			ld a, (.dmark)  
4160 32 6e fe			ld (debug_mark),a  
4163 3a 72 41			ld a, (.dmark+1)  
4166 32 6f fe			ld (debug_mark+1),a  
4169 3a 73 41			ld a, (.dmark+2)  
416c 32 70 fe			ld (debug_mark+2),a  
416f 18 03			jr .pastdmark  
4171 ..			.dmark: db "DTi"  
4174 f1			.pastdmark: pop af  
4175			endm  
# End of macro DMARK
4175				CALLMONITOR 
4175 cd 9e 19			call break_point_state  
4178				endm  
# End of macro CALLMONITOR
4178			endif	 
4178			 
4178			 
4178					NEXTW 
4178 c3 16 24			jp macro_next 
417b				endm 
# End of macro NEXTW
417b			 
417b			.CLS: 
417b				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
417b 35				db WORD_SYS_CORE+33             
417c a8 41			dw .DRAW            
417e 04				db 3 + 1 
417f .. 00			db "CLS",0              
4183				endm 
# End of macro CWHEAD
4183			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4183					if DEBUG_FORTH_WORDS_KEY 
4183						DMARK "CLS" 
4183 f5				push af  
4184 3a 98 41			ld a, (.dmark)  
4187 32 6e fe			ld (debug_mark),a  
418a 3a 99 41			ld a, (.dmark+1)  
418d 32 6f fe			ld (debug_mark+1),a  
4190 3a 9a 41			ld a, (.dmark+2)  
4193 32 70 fe			ld (debug_mark+2),a  
4196 18 03			jr .pastdmark  
4198 ..			.dmark: db "CLS"  
419b f1			.pastdmark: pop af  
419c			endm  
# End of macro DMARK
419c						CALLMONITOR 
419c cd 9e 19			call break_point_state  
419f				endm  
# End of macro CALLMONITOR
419f					endif 
419f cd 18 0d				call clear_display 
41a2 c3 b6 42				jp .home		; and home cursor 
41a5					NEXTW 
41a5 c3 16 24			jp macro_next 
41a8				endm 
# End of macro NEXTW
41a8			 
41a8			.DRAW: 
41a8				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
41a8 36				db WORD_SYS_CORE+34             
41a9 d3 41			dw .DUMP            
41ab 05				db 4 + 1 
41ac .. 00			db "DRAW",0              
41b1				endm 
# End of macro CWHEAD
41b1			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
41b1					if DEBUG_FORTH_WORDS_KEY 
41b1						DMARK "DRW" 
41b1 f5				push af  
41b2 3a c6 41			ld a, (.dmark)  
41b5 32 6e fe			ld (debug_mark),a  
41b8 3a c7 41			ld a, (.dmark+1)  
41bb 32 6f fe			ld (debug_mark+1),a  
41be 3a c8 41			ld a, (.dmark+2)  
41c1 32 70 fe			ld (debug_mark+2),a  
41c4 18 03			jr .pastdmark  
41c6 ..			.dmark: db "DRW"  
41c9 f1			.pastdmark: pop af  
41ca			endm  
# End of macro DMARK
41ca						CALLMONITOR 
41ca cd 9e 19			call break_point_state  
41cd				endm  
# End of macro CALLMONITOR
41cd					endif 
41cd cd 3b 0d				call update_display 
41d0					NEXTW 
41d0 c3 16 24			jp macro_next 
41d3				endm 
# End of macro NEXTW
41d3			 
41d3			.DUMP: 
41d3				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
41d3 37				db WORD_SYS_CORE+35             
41d4 0b 42			dw .CDUMP            
41d6 05				db 4 + 1 
41d7 .. 00			db "DUMP",0              
41dc				endm 
# End of macro CWHEAD
41dc			; | DUMP ( x -- ) With address x display dump   | DONE 
41dc			; TODO pop address to use off of the stack 
41dc					if DEBUG_FORTH_WORDS_KEY 
41dc						DMARK "DUM" 
41dc f5				push af  
41dd 3a f1 41			ld a, (.dmark)  
41e0 32 6e fe			ld (debug_mark),a  
41e3 3a f2 41			ld a, (.dmark+1)  
41e6 32 6f fe			ld (debug_mark+1),a  
41e9 3a f3 41			ld a, (.dmark+2)  
41ec 32 70 fe			ld (debug_mark+2),a  
41ef 18 03			jr .pastdmark  
41f1 ..			.dmark: db "DUM"  
41f4 f1			.pastdmark: pop af  
41f5			endm  
# End of macro DMARK
41f5						CALLMONITOR 
41f5 cd 9e 19			call break_point_state  
41f8				endm  
# End of macro CALLMONITOR
41f8					endif 
41f8 cd 18 0d				call clear_display 
41fb			 
41fb					; get address 
41fb			 
41fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
41fb cd 60 22			call macro_dsp_valuehl 
41fe				endm 
# End of macro FORTH_DSP_VALUEHL
41fe				 
41fe					; save it for cdump 
41fe			 
41fe 22 eb f4				ld (os_cur_ptr),hl 
4201			 
4201					; destroy value TOS 
4201			 
4201					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4201 cd 18 23			call macro_forth_dsp_pop 
4204				endm 
# End of macro FORTH_DSP_POP
4204			 
4204 cd e9 1e				call dumpcont	; skip old style of param parsing	 
4207 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4208					NEXTW 
4208 c3 16 24			jp macro_next 
420b				endm 
# End of macro NEXTW
420b			.CDUMP: 
420b				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
420b 38				db WORD_SYS_CORE+36             
420c 3b 42			dw .DAT            
420e 06				db 5 + 1 
420f .. 00			db "CDUMP",0              
4215				endm 
# End of macro CWHEAD
4215			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4215					if DEBUG_FORTH_WORDS_KEY 
4215						DMARK "CDP" 
4215 f5				push af  
4216 3a 2a 42			ld a, (.dmark)  
4219 32 6e fe			ld (debug_mark),a  
421c 3a 2b 42			ld a, (.dmark+1)  
421f 32 6f fe			ld (debug_mark+1),a  
4222 3a 2c 42			ld a, (.dmark+2)  
4225 32 70 fe			ld (debug_mark+2),a  
4228 18 03			jr .pastdmark  
422a ..			.dmark: db "CDP"  
422d f1			.pastdmark: pop af  
422e			endm  
# End of macro DMARK
422e						CALLMONITOR 
422e cd 9e 19			call break_point_state  
4231				endm  
# End of macro CALLMONITOR
4231					endif 
4231 cd 18 0d				call clear_display 
4234 cd e9 1e				call dumpcont	 
4237 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4238					NEXTW 
4238 c3 16 24			jp macro_next 
423b				endm 
# End of macro NEXTW
423b			 
423b			 
423b			 
423b			 
423b			.DAT: 
423b				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
423b 3d				db WORD_SYS_CORE+41             
423c 91 42			dw .HOME            
423e 03				db 2 + 1 
423f .. 00			db "AT",0              
4242				endm 
# End of macro CWHEAD
4242			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4242					if DEBUG_FORTH_WORDS_KEY 
4242						DMARK "AT." 
4242 f5				push af  
4243 3a 57 42			ld a, (.dmark)  
4246 32 6e fe			ld (debug_mark),a  
4249 3a 58 42			ld a, (.dmark+1)  
424c 32 6f fe			ld (debug_mark+1),a  
424f 3a 59 42			ld a, (.dmark+2)  
4252 32 70 fe			ld (debug_mark+2),a  
4255 18 03			jr .pastdmark  
4257 ..			.dmark: db "AT."  
425a f1			.pastdmark: pop af  
425b			endm  
# End of macro DMARK
425b						CALLMONITOR 
425b cd 9e 19			call break_point_state  
425e				endm  
# End of macro CALLMONITOR
425e					endif 
425e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
425e cd 60 22			call macro_dsp_valuehl 
4261				endm 
# End of macro FORTH_DSP_VALUEHL
4261			 
4261			 
4261					; TODO save cursor row 
4261 7d					ld a,l 
4262 fe 02				cp 2 
4264 20 04				jr nz, .crow3 
4266 3e 28				ld a, display_row_2 
4268 18 12				jr .ccol1 
426a fe 03		.crow3:		cp 3 
426c 20 04				jr nz, .crow4 
426e 3e 50				ld a, display_row_3 
4270 18 0a				jr .ccol1 
4272 fe 04		.crow4:		cp 4 
4274 20 04				jr nz, .crow1 
4276 3e 78				ld a, display_row_4 
4278 18 02				jr .ccol1 
427a 3e 00		.crow1:		ld a,display_row_1 
427c f5			.ccol1:		push af			; got row offset 
427d 6f					ld l,a 
427e 26 00				ld h,0 
4280					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4280 cd 18 23			call macro_forth_dsp_pop 
4283				endm 
# End of macro FORTH_DSP_POP
4283					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4283 cd 60 22			call macro_dsp_valuehl 
4286				endm 
# End of macro FORTH_DSP_VALUEHL
4286					; TODO save cursor col 
4286 f1					pop af 
4287 85					add l		; add col offset 
4288 32 65 fa				ld (f_cursor_ptr), a 
428b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
428b cd 18 23			call macro_forth_dsp_pop 
428e				endm 
# End of macro FORTH_DSP_POP
428e			 
428e					; calculate  
428e			 
428e					NEXTW 
428e c3 16 24			jp macro_next 
4291				endm 
# End of macro NEXTW
4291			 
4291			 
4291			.HOME: 
4291				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
4291 41				db WORD_SYS_CORE+45             
4292 be 42			dw .SPACE            
4294 05				db 4 + 1 
4295 .. 00			db "HOME",0              
429a				endm 
# End of macro CWHEAD
429a			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
429a					if DEBUG_FORTH_WORDS_KEY 
429a						DMARK "HOM" 
429a f5				push af  
429b 3a af 42			ld a, (.dmark)  
429e 32 6e fe			ld (debug_mark),a  
42a1 3a b0 42			ld a, (.dmark+1)  
42a4 32 6f fe			ld (debug_mark+1),a  
42a7 3a b1 42			ld a, (.dmark+2)  
42aa 32 70 fe			ld (debug_mark+2),a  
42ad 18 03			jr .pastdmark  
42af ..			.dmark: db "HOM"  
42b2 f1			.pastdmark: pop af  
42b3			endm  
# End of macro DMARK
42b3						CALLMONITOR 
42b3 cd 9e 19			call break_point_state  
42b6				endm  
# End of macro CALLMONITOR
42b6					endif 
42b6 3e 00		.home:		ld a, 0		; and home cursor 
42b8 32 65 fa				ld (f_cursor_ptr), a 
42bb					NEXTW 
42bb c3 16 24			jp macro_next 
42be				endm 
# End of macro NEXTW
42be			 
42be			 
42be			.SPACE: 
42be				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
42be 46				db WORD_SYS_CORE+50             
42bf f4 42			dw .SPACES            
42c1 03				db 2 + 1 
42c2 .. 00			db "BL",0              
42c5				endm 
# End of macro CWHEAD
42c5			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
42c5					if DEBUG_FORTH_WORDS_KEY 
42c5						DMARK "BL." 
42c5 f5				push af  
42c6 3a da 42			ld a, (.dmark)  
42c9 32 6e fe			ld (debug_mark),a  
42cc 3a db 42			ld a, (.dmark+1)  
42cf 32 6f fe			ld (debug_mark+1),a  
42d2 3a dc 42			ld a, (.dmark+2)  
42d5 32 70 fe			ld (debug_mark+2),a  
42d8 18 03			jr .pastdmark  
42da ..			.dmark: db "BL."  
42dd f1			.pastdmark: pop af  
42de			endm  
# End of macro DMARK
42de						CALLMONITOR 
42de cd 9e 19			call break_point_state  
42e1				endm  
# End of macro CALLMONITOR
42e1					endif 
42e1 3e 20				ld a, " " 
42e3 32 c8 f1				ld (scratch),a 
42e6 3e 00				ld a, 0 
42e8 32 c9 f1				ld (scratch+1),a 
42eb 21 c8 f1				ld hl, scratch 
42ee cd d7 20				call forth_push_str 
42f1					 
42f1				       NEXTW 
42f1 c3 16 24			jp macro_next 
42f4				endm 
# End of macro NEXTW
42f4			 
42f4			;.blstr: db " ", 0 
42f4			 
42f4			.SPACES: 
42f4				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
42f4 47				db WORD_SYS_CORE+51             
42f5 8f 43			dw .SCROLL            
42f7 07				db 6 + 1 
42f8 .. 00			db "SPACES",0              
42ff				endm 
# End of macro CWHEAD
42ff			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
42ff					if DEBUG_FORTH_WORDS_KEY 
42ff						DMARK "SPS" 
42ff f5				push af  
4300 3a 14 43			ld a, (.dmark)  
4303 32 6e fe			ld (debug_mark),a  
4306 3a 15 43			ld a, (.dmark+1)  
4309 32 6f fe			ld (debug_mark+1),a  
430c 3a 16 43			ld a, (.dmark+2)  
430f 32 70 fe			ld (debug_mark+2),a  
4312 18 03			jr .pastdmark  
4314 ..			.dmark: db "SPS"  
4317 f1			.pastdmark: pop af  
4318			endm  
# End of macro DMARK
4318						CALLMONITOR 
4318 cd 9e 19			call break_point_state  
431b				endm  
# End of macro CALLMONITOR
431b					endif 
431b			 
431b			 
431b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
431b cd 60 22			call macro_dsp_valuehl 
431e				endm 
# End of macro FORTH_DSP_VALUEHL
431e			 
431e e5					push hl    ; u 
431f					if DEBUG_FORTH_WORDS 
431f						DMARK "SPA" 
431f f5				push af  
4320 3a 34 43			ld a, (.dmark)  
4323 32 6e fe			ld (debug_mark),a  
4326 3a 35 43			ld a, (.dmark+1)  
4329 32 6f fe			ld (debug_mark+1),a  
432c 3a 36 43			ld a, (.dmark+2)  
432f 32 70 fe			ld (debug_mark+2),a  
4332 18 03			jr .pastdmark  
4334 ..			.dmark: db "SPA"  
4337 f1			.pastdmark: pop af  
4338			endm  
# End of macro DMARK
4338						CALLMONITOR 
4338 cd 9e 19			call break_point_state  
433b				endm  
# End of macro CALLMONITOR
433b					endif 
433b			 
433b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
433b cd 18 23			call macro_forth_dsp_pop 
433e				endm 
# End of macro FORTH_DSP_POP
433e e1					pop hl 
433f 0e 00				ld c, 0 
4341 45					ld b, l 
4342 21 c8 f1				ld hl, scratch  
4345			 
4345					if DEBUG_FORTH_WORDS 
4345						DMARK "SP2" 
4345 f5				push af  
4346 3a 5a 43			ld a, (.dmark)  
4349 32 6e fe			ld (debug_mark),a  
434c 3a 5b 43			ld a, (.dmark+1)  
434f 32 6f fe			ld (debug_mark+1),a  
4352 3a 5c 43			ld a, (.dmark+2)  
4355 32 70 fe			ld (debug_mark+2),a  
4358 18 03			jr .pastdmark  
435a ..			.dmark: db "SP2"  
435d f1			.pastdmark: pop af  
435e			endm  
# End of macro DMARK
435e						CALLMONITOR 
435e cd 9e 19			call break_point_state  
4361				endm  
# End of macro CALLMONITOR
4361					endif 
4361 3e 20				ld a, ' ' 
4363			.spaces1:	 
4363 77					ld (hl),a 
4364 23					inc hl 
4365					 
4365 10 fc				djnz .spaces1 
4367 3e 00				ld a,0 
4369 77					ld (hl),a 
436a 21 c8 f1				ld hl, scratch 
436d					if DEBUG_FORTH_WORDS 
436d						DMARK "SP3" 
436d f5				push af  
436e 3a 82 43			ld a, (.dmark)  
4371 32 6e fe			ld (debug_mark),a  
4374 3a 83 43			ld a, (.dmark+1)  
4377 32 6f fe			ld (debug_mark+1),a  
437a 3a 84 43			ld a, (.dmark+2)  
437d 32 70 fe			ld (debug_mark+2),a  
4380 18 03			jr .pastdmark  
4382 ..			.dmark: db "SP3"  
4385 f1			.pastdmark: pop af  
4386			endm  
# End of macro DMARK
4386						CALLMONITOR 
4386 cd 9e 19			call break_point_state  
4389				endm  
# End of macro CALLMONITOR
4389					endif 
4389 cd d7 20				call forth_push_str 
438c			 
438c				       NEXTW 
438c c3 16 24			jp macro_next 
438f				endm 
# End of macro NEXTW
438f			 
438f			 
438f			 
438f			.SCROLL: 
438f				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
438f 53				db WORD_SYS_CORE+63             
4390 bc 43			dw .SCROLLD            
4392 07				db 6 + 1 
4393 .. 00			db "SCROLL",0              
439a				endm 
# End of macro CWHEAD
439a			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
439a					if DEBUG_FORTH_WORDS_KEY 
439a						DMARK "SCR" 
439a f5				push af  
439b 3a af 43			ld a, (.dmark)  
439e 32 6e fe			ld (debug_mark),a  
43a1 3a b0 43			ld a, (.dmark+1)  
43a4 32 6f fe			ld (debug_mark+1),a  
43a7 3a b1 43			ld a, (.dmark+2)  
43aa 32 70 fe			ld (debug_mark+2),a  
43ad 18 03			jr .pastdmark  
43af ..			.dmark: db "SCR"  
43b2 f1			.pastdmark: pop af  
43b3			endm  
# End of macro DMARK
43b3						CALLMONITOR 
43b3 cd 9e 19			call break_point_state  
43b6				endm  
# End of macro CALLMONITOR
43b6					endif 
43b6			 
43b6 cd da 0c			call scroll_up 
43b9			;	call update_display 
43b9			 
43b9					NEXTW 
43b9 c3 16 24			jp macro_next 
43bc				endm 
# End of macro NEXTW
43bc			 
43bc			 
43bc			 
43bc			;		; get dir 
43bc			; 
43bc			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43bc			; 
43bc			;		push hl 
43bc			; 
43bc			;		; destroy value TOS 
43bc			; 
43bc			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43bc			; 
43bc			;		; get count 
43bc			; 
43bc			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43bc			; 
43bc			;		push hl 
43bc			; 
43bc			;		; destroy value TOS 
43bc			; 
43bc			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43bc			; 
43bc			;		; one value on hl get other one back 
43bc			; 
43bc			;		pop bc    ; count 
43bc			; 
43bc			;		pop de   ; dir 
43bc			; 
43bc			; 
43bc			;		ld b, c 
43bc			; 
43bc			;.scrolldir:     push bc 
43bc			;		push de 
43bc			; 
43bc			;		ld a, 0 
43bc			;		cp e 
43bc			;		jr z, .scrollup  
43bc			;		call scroll_down 
43bc			;		jr .scrollnext 
43bc			;.scrollup:	call scroll_up 
43bc			; 
43bc			;		 
43bc			;.scrollnext: 
43bc			;		pop de 
43bc			;		pop bc 
43bc			;		djnz .scrolldir 
43bc			; 
43bc			; 
43bc			; 
43bc			; 
43bc			; 
43bc			;		NEXTW 
43bc			 
43bc			.SCROLLD: 
43bc				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
43bc 53				db WORD_SYS_CORE+63             
43bd ea 43			dw .ATQ            
43bf 08				db 7 + 1 
43c0 .. 00			db "SCROLLD",0              
43c8				endm 
# End of macro CWHEAD
43c8			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
43c8					if DEBUG_FORTH_WORDS_KEY 
43c8						DMARK "SCD" 
43c8 f5				push af  
43c9 3a dd 43			ld a, (.dmark)  
43cc 32 6e fe			ld (debug_mark),a  
43cf 3a de 43			ld a, (.dmark+1)  
43d2 32 6f fe			ld (debug_mark+1),a  
43d5 3a df 43			ld a, (.dmark+2)  
43d8 32 70 fe			ld (debug_mark+2),a  
43db 18 03			jr .pastdmark  
43dd ..			.dmark: db "SCD"  
43e0 f1			.pastdmark: pop af  
43e1			endm  
# End of macro DMARK
43e1						CALLMONITOR 
43e1 cd 9e 19			call break_point_state  
43e4				endm  
# End of macro CALLMONITOR
43e4					endif 
43e4			 
43e4 cd fe 0c			call scroll_down 
43e7			;	call update_display 
43e7			 
43e7					NEXTW 
43e7 c3 16 24			jp macro_next 
43ea				endm 
# End of macro NEXTW
43ea			 
43ea			 
43ea			.ATQ: 
43ea				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
43ea 62				db WORD_SYS_CORE+78             
43eb 48 44			dw .AUTODSP            
43ed 04				db 3 + 1 
43ee .. 00			db "AT@",0              
43f2				endm 
# End of macro CWHEAD
43f2			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
43f2					if DEBUG_FORTH_WORDS_KEY 
43f2						DMARK "ATA" 
43f2 f5				push af  
43f3 3a 07 44			ld a, (.dmark)  
43f6 32 6e fe			ld (debug_mark),a  
43f9 3a 08 44			ld a, (.dmark+1)  
43fc 32 6f fe			ld (debug_mark+1),a  
43ff 3a 09 44			ld a, (.dmark+2)  
4402 32 70 fe			ld (debug_mark+2),a  
4405 18 03			jr .pastdmark  
4407 ..			.dmark: db "ATA"  
440a f1			.pastdmark: pop af  
440b			endm  
# End of macro DMARK
440b						CALLMONITOR 
440b cd 9e 19			call break_point_state  
440e				endm  
# End of macro CALLMONITOR
440e					endif 
440e			 
440e			 
440e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
440e cd 60 22			call macro_dsp_valuehl 
4411				endm 
# End of macro FORTH_DSP_VALUEHL
4411			 
4411					; TODO save cursor row 
4411 7d					ld a,l 
4412 fe 02				cp 2 
4414 20 04				jr nz, .crow3aq 
4416 3e 28				ld a, display_row_2 
4418 18 12				jr .ccol1aq 
441a fe 03		.crow3aq:		cp 3 
441c 20 04				jr nz, .crow4aq 
441e 3e 50				ld a, display_row_3 
4420 18 0a				jr .ccol1aq 
4422 fe 04		.crow4aq:		cp 4 
4424 20 04				jr nz, .crow1aq 
4426 3e 78				ld a, display_row_4 
4428 18 02				jr .ccol1aq 
442a 3e 00		.crow1aq:		ld a,display_row_1 
442c f5			.ccol1aq:		push af			; got row offset 
442d 6f					ld l,a 
442e 26 00				ld h,0 
4430					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4430 cd 18 23			call macro_forth_dsp_pop 
4433				endm 
# End of macro FORTH_DSP_POP
4433					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4433 cd 60 22			call macro_dsp_valuehl 
4436				endm 
# End of macro FORTH_DSP_VALUEHL
4436					; TODO save cursor col 
4436 f1					pop af 
4437 85					add l		; add col offset 
4438			 
4438					; add current frame buffer address 
4438 2a cf fb				ld hl, (display_fb_active) 
443b cd 4c 0f				call addatohl 
443e			 
443e			 
443e			 
443e			 
443e					; get char frame buffer location offset in hl 
443e			 
443e 7e					ld a,(hl) 
443f 26 00				ld h, 0 
4441 6f					ld l, a 
4442			 
4442 cd 69 20				call forth_push_numhl 
4445			 
4445			 
4445					NEXTW 
4445 c3 16 24			jp macro_next 
4448				endm 
# End of macro NEXTW
4448			 
4448			.AUTODSP: 
4448				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4448 63				db WORD_SYS_CORE+79             
4449 5e 44			dw .MENU            
444b 05				db 4 + 1 
444c .. 00			db "ADSP",0              
4451				endm 
# End of macro CWHEAD
4451			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4451			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4451			 
4451					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4451 cd 60 22			call macro_dsp_valuehl 
4454				endm 
# End of macro FORTH_DSP_VALUEHL
4454			 
4454			;		push hl 
4454			 
4454					; destroy value TOS 
4454			 
4454					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4454 cd 18 23			call macro_forth_dsp_pop 
4457				endm 
# End of macro FORTH_DSP_POP
4457			 
4457			;		pop hl 
4457			 
4457 7d					ld a,l 
4458 32 43 fa				ld (cli_autodisplay), a 
445b				       NEXTW 
445b c3 16 24			jp macro_next 
445e				endm 
# End of macro NEXTW
445e			 
445e			.MENU: 
445e				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
445e 70				db WORD_SYS_CORE+92             
445f 07 45			dw .ENDDISPLAY            
4461 05				db 4 + 1 
4462 .. 00			db "MENU",0              
4467				endm 
# End of macro CWHEAD
4467			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4467			 
4467			;		; get number of items on the stack 
4467			; 
4467				 
4467					FORTH_DSP_VALUEHL 
4467 cd 60 22			call macro_dsp_valuehl 
446a				endm 
# End of macro FORTH_DSP_VALUEHL
446a				 
446a					if DEBUG_FORTH_WORDS_KEY 
446a						DMARK "MNU" 
446a f5				push af  
446b 3a 7f 44			ld a, (.dmark)  
446e 32 6e fe			ld (debug_mark),a  
4471 3a 80 44			ld a, (.dmark+1)  
4474 32 6f fe			ld (debug_mark+1),a  
4477 3a 81 44			ld a, (.dmark+2)  
447a 32 70 fe			ld (debug_mark+2),a  
447d 18 03			jr .pastdmark  
447f ..			.dmark: db "MNU"  
4482 f1			.pastdmark: pop af  
4483			endm  
# End of macro DMARK
4483						CALLMONITOR 
4483 cd 9e 19			call break_point_state  
4486				endm  
# End of macro CALLMONITOR
4486					endif 
4486			 
4486 45					ld b, l	 
4487 05					dec b 
4488			 
4488					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4488 cd 18 23			call macro_forth_dsp_pop 
448b				endm 
# End of macro FORTH_DSP_POP
448b			 
448b			 
448b					; go directly through the stack to pluck out the string pointers and build an array 
448b			 
448b			;		FORTH_DSP 
448b			 
448b					; hl contains top most stack item 
448b				 
448b 11 c8 f1				ld de, scratch 
448e			 
448e			.mbuild: 
448e			 
448e					FORTH_DSP_VALUEHL 
448e cd 60 22			call macro_dsp_valuehl 
4491				endm 
# End of macro FORTH_DSP_VALUEHL
4491			 
4491					if DEBUG_FORTH_WORDS 
4491						DMARK "MN3" 
4491 f5				push af  
4492 3a a6 44			ld a, (.dmark)  
4495 32 6e fe			ld (debug_mark),a  
4498 3a a7 44			ld a, (.dmark+1)  
449b 32 6f fe			ld (debug_mark+1),a  
449e 3a a8 44			ld a, (.dmark+2)  
44a1 32 70 fe			ld (debug_mark+2),a  
44a4 18 03			jr .pastdmark  
44a6 ..			.dmark: db "MN3"  
44a9 f1			.pastdmark: pop af  
44aa			endm  
# End of macro DMARK
44aa						CALLMONITOR 
44aa cd 9e 19			call break_point_state  
44ad				endm  
# End of macro CALLMONITOR
44ad					endif 
44ad eb					ex de, hl 
44ae 73					ld (hl), e 
44af 23					inc hl 
44b0 72					ld (hl), d 
44b1 23					inc hl 
44b2 eb					ex de, hl 
44b3			 
44b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b3 cd 18 23			call macro_forth_dsp_pop 
44b6				endm 
# End of macro FORTH_DSP_POP
44b6			 
44b6 10 d6				djnz .mbuild 
44b8			 
44b8					; done add term 
44b8			 
44b8 eb					ex de, hl 
44b9 36 00				ld (hl), 0 
44bb 23					inc hl 
44bc 36 00				ld (hl), 0 
44be			 
44be				 
44be					 
44be 21 c8 f1				ld hl, scratch 
44c1			 
44c1					if DEBUG_FORTH_WORDS 
44c1						DMARK "MNx" 
44c1 f5				push af  
44c2 3a d6 44			ld a, (.dmark)  
44c5 32 6e fe			ld (debug_mark),a  
44c8 3a d7 44			ld a, (.dmark+1)  
44cb 32 6f fe			ld (debug_mark+1),a  
44ce 3a d8 44			ld a, (.dmark+2)  
44d1 32 70 fe			ld (debug_mark+2),a  
44d4 18 03			jr .pastdmark  
44d6 ..			.dmark: db "MNx"  
44d9 f1			.pastdmark: pop af  
44da			endm  
# End of macro DMARK
44da						CALLMONITOR 
44da cd 9e 19			call break_point_state  
44dd				endm  
# End of macro CALLMONITOR
44dd					endif 
44dd			 
44dd			 
44dd			 
44dd 3e 00				ld a, 0 
44df cd 49 0d				call menu 
44e2			 
44e2			 
44e2 6f					ld l, a 
44e3 26 00				ld h, 0 
44e5			 
44e5					if DEBUG_FORTH_WORDS 
44e5						DMARK "MNr" 
44e5 f5				push af  
44e6 3a fa 44			ld a, (.dmark)  
44e9 32 6e fe			ld (debug_mark),a  
44ec 3a fb 44			ld a, (.dmark+1)  
44ef 32 6f fe			ld (debug_mark+1),a  
44f2 3a fc 44			ld a, (.dmark+2)  
44f5 32 70 fe			ld (debug_mark+2),a  
44f8 18 03			jr .pastdmark  
44fa ..			.dmark: db "MNr"  
44fd f1			.pastdmark: pop af  
44fe			endm  
# End of macro DMARK
44fe						CALLMONITOR 
44fe cd 9e 19			call break_point_state  
4501				endm  
# End of macro CALLMONITOR
4501					endif 
4501			 
4501 cd 69 20				call forth_push_numhl 
4504			 
4504			 
4504			 
4504			 
4504				       NEXTW 
4504 c3 16 24			jp macro_next 
4507				endm 
# End of macro NEXTW
4507			 
4507			 
4507			.ENDDISPLAY: 
4507			 
4507			; eof 
# End of file forth_words_display.asm
4507			include "forth_words_str.asm" 
4507			 
4507			; | ## String Words 
4507			 
4507			.PTR:   
4507			 
4507				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4507 48				db WORD_SYS_CORE+52             
4508 34 45			dw .STYPE            
450a 04				db 3 + 1 
450b .. 00			db "PTR",0              
450f				endm 
# End of macro CWHEAD
450f			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
450f			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
450f			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
450f			 
450f					if DEBUG_FORTH_WORDS_KEY 
450f						DMARK "PTR" 
450f f5				push af  
4510 3a 24 45			ld a, (.dmark)  
4513 32 6e fe			ld (debug_mark),a  
4516 3a 25 45			ld a, (.dmark+1)  
4519 32 6f fe			ld (debug_mark+1),a  
451c 3a 26 45			ld a, (.dmark+2)  
451f 32 70 fe			ld (debug_mark+2),a  
4522 18 03			jr .pastdmark  
4524 ..			.dmark: db "PTR"  
4527 f1			.pastdmark: pop af  
4528			endm  
# End of macro DMARK
4528						CALLMONITOR 
4528 cd 9e 19			call break_point_state  
452b				endm  
# End of macro CALLMONITOR
452b					endif 
452b					FORTH_DSP_VALUEHL 
452b cd 60 22			call macro_dsp_valuehl 
452e				endm 
# End of macro FORTH_DSP_VALUEHL
452e cd 69 20				call forth_push_numhl 
4531			 
4531			 
4531					NEXTW 
4531 c3 16 24			jp macro_next 
4534				endm 
# End of macro NEXTW
4534			.STYPE: 
4534				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4534 48				db WORD_SYS_CORE+52             
4535 83 45			dw .UPPER            
4537 06				db 5 + 1 
4538 .. 00			db "STYPE",0              
453e				endm 
# End of macro CWHEAD
453e			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
453e					if DEBUG_FORTH_WORDS_KEY 
453e						DMARK "STY" 
453e f5				push af  
453f 3a 53 45			ld a, (.dmark)  
4542 32 6e fe			ld (debug_mark),a  
4545 3a 54 45			ld a, (.dmark+1)  
4548 32 6f fe			ld (debug_mark+1),a  
454b 3a 55 45			ld a, (.dmark+2)  
454e 32 70 fe			ld (debug_mark+2),a  
4551 18 03			jr .pastdmark  
4553 ..			.dmark: db "STY"  
4556 f1			.pastdmark: pop af  
4557			endm  
# End of macro DMARK
4557						CALLMONITOR 
4557 cd 9e 19			call break_point_state  
455a				endm  
# End of macro CALLMONITOR
455a					endif 
455a					FORTH_DSP 
455a cd 26 22			call macro_forth_dsp 
455d				endm 
# End of macro FORTH_DSP
455d					;v5 FORTH_DSP_VALUE 
455d			 
455d 7e					ld a, (hl) 
455e			 
455e f5					push af 
455f			 
455f			; Dont destroy TOS		FORTH_DSP_POP 
455f			 
455f f1					pop af 
4560			 
4560 fe 01				cp DS_TYPE_STR 
4562 28 09				jr z, .typestr 
4564			 
4564 fe 02				cp DS_TYPE_INUM 
4566 28 0a				jr z, .typeinum 
4568			 
4568 21 81 45				ld hl, .tna 
456b 18 0a				jr .tpush 
456d			 
456d 21 7d 45		.typestr:	ld hl, .tstr 
4570 18 05				jr .tpush 
4572 21 7f 45		.typeinum:	ld hl, .tinum 
4575 18 00				jr .tpush 
4577			 
4577			.tpush: 
4577			 
4577 cd d7 20				call forth_push_str 
457a			 
457a					NEXTW 
457a c3 16 24			jp macro_next 
457d				endm 
# End of macro NEXTW
457d .. 00		.tstr:	db "s",0 
457f .. 00		.tinum:  db "i",0 
4581 .. 00		.tna:   db "?", 0 
4583			 
4583			 
4583			.UPPER: 
4583				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4583 48				db WORD_SYS_CORE+52             
4584 be 45			dw .LOWER            
4586 06				db 5 + 1 
4587 .. 00			db "UPPER",0              
458d				endm 
# End of macro CWHEAD
458d			; | UPPER ( s -- s ) Upper case string s  | DONE 
458d					if DEBUG_FORTH_WORDS_KEY 
458d						DMARK "UPR" 
458d f5				push af  
458e 3a a2 45			ld a, (.dmark)  
4591 32 6e fe			ld (debug_mark),a  
4594 3a a3 45			ld a, (.dmark+1)  
4597 32 6f fe			ld (debug_mark+1),a  
459a 3a a4 45			ld a, (.dmark+2)  
459d 32 70 fe			ld (debug_mark+2),a  
45a0 18 03			jr .pastdmark  
45a2 ..			.dmark: db "UPR"  
45a5 f1			.pastdmark: pop af  
45a6			endm  
# End of macro DMARK
45a6						CALLMONITOR 
45a6 cd 9e 19			call break_point_state  
45a9				endm  
# End of macro CALLMONITOR
45a9					endif 
45a9			 
45a9					FORTH_DSP 
45a9 cd 26 22			call macro_forth_dsp 
45ac				endm 
# End of macro FORTH_DSP
45ac					 
45ac			; TODO check is string type 
45ac			 
45ac					FORTH_DSP_VALUEHL 
45ac cd 60 22			call macro_dsp_valuehl 
45af				endm 
# End of macro FORTH_DSP_VALUEHL
45af			; get pointer to string in hl 
45af			 
45af 7e			.toup:		ld a, (hl) 
45b0 fe 00				cp 0 
45b2 28 07				jr z, .toupdone 
45b4			 
45b4 cd b9 12				call to_upper 
45b7			 
45b7 77					ld (hl), a 
45b8 23					inc hl 
45b9 18 f4				jr .toup 
45bb			 
45bb					 
45bb			 
45bb			 
45bb			; for each char convert to upper 
45bb					 
45bb			.toupdone: 
45bb			 
45bb			 
45bb					NEXTW 
45bb c3 16 24			jp macro_next 
45be				endm 
# End of macro NEXTW
45be			.LOWER: 
45be				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
45be 48				db WORD_SYS_CORE+52             
45bf f9 45			dw .TCASE            
45c1 06				db 5 + 1 
45c2 .. 00			db "LOWER",0              
45c8				endm 
# End of macro CWHEAD
45c8			; | LOWER ( s -- s ) Lower case string s  | DONE 
45c8					if DEBUG_FORTH_WORDS_KEY 
45c8						DMARK "LWR" 
45c8 f5				push af  
45c9 3a dd 45			ld a, (.dmark)  
45cc 32 6e fe			ld (debug_mark),a  
45cf 3a de 45			ld a, (.dmark+1)  
45d2 32 6f fe			ld (debug_mark+1),a  
45d5 3a df 45			ld a, (.dmark+2)  
45d8 32 70 fe			ld (debug_mark+2),a  
45db 18 03			jr .pastdmark  
45dd ..			.dmark: db "LWR"  
45e0 f1			.pastdmark: pop af  
45e1			endm  
# End of macro DMARK
45e1						CALLMONITOR 
45e1 cd 9e 19			call break_point_state  
45e4				endm  
# End of macro CALLMONITOR
45e4					endif 
45e4			 
45e4					FORTH_DSP 
45e4 cd 26 22			call macro_forth_dsp 
45e7				endm 
# End of macro FORTH_DSP
45e7					 
45e7			; TODO check is string type 
45e7			 
45e7					FORTH_DSP_VALUEHL 
45e7 cd 60 22			call macro_dsp_valuehl 
45ea				endm 
# End of macro FORTH_DSP_VALUEHL
45ea			; get pointer to string in hl 
45ea			 
45ea 7e			.tolow:		ld a, (hl) 
45eb fe 00				cp 0 
45ed 28 07				jr z, .tolowdone 
45ef			 
45ef cd c2 12				call to_lower 
45f2			 
45f2 77					ld (hl), a 
45f3 23					inc hl 
45f4 18 f4				jr .tolow 
45f6			 
45f6					 
45f6			 
45f6			 
45f6			; for each char convert to low 
45f6					 
45f6			.tolowdone: 
45f6					NEXTW 
45f6 c3 16 24			jp macro_next 
45f9				endm 
# End of macro NEXTW
45f9			.TCASE: 
45f9				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
45f9 48				db WORD_SYS_CORE+52             
45fa 2f 47			dw .SUBSTR            
45fc 06				db 5 + 1 
45fd .. 00			db "TCASE",0              
4603				endm 
# End of macro CWHEAD
4603			; | TCASE ( s -- s ) Title case string s  | DONE 
4603					if DEBUG_FORTH_WORDS_KEY 
4603						DMARK "TCS" 
4603 f5				push af  
4604 3a 18 46			ld a, (.dmark)  
4607 32 6e fe			ld (debug_mark),a  
460a 3a 19 46			ld a, (.dmark+1)  
460d 32 6f fe			ld (debug_mark+1),a  
4610 3a 1a 46			ld a, (.dmark+2)  
4613 32 70 fe			ld (debug_mark+2),a  
4616 18 03			jr .pastdmark  
4618 ..			.dmark: db "TCS"  
461b f1			.pastdmark: pop af  
461c			endm  
# End of macro DMARK
461c						CALLMONITOR 
461c cd 9e 19			call break_point_state  
461f				endm  
# End of macro CALLMONITOR
461f					endif 
461f			 
461f					FORTH_DSP 
461f cd 26 22			call macro_forth_dsp 
4622				endm 
# End of macro FORTH_DSP
4622					 
4622			; TODO check is string type 
4622			 
4622					FORTH_DSP_VALUEHL 
4622 cd 60 22			call macro_dsp_valuehl 
4625				endm 
# End of macro FORTH_DSP_VALUEHL
4625			; get pointer to string in hl 
4625			 
4625					if DEBUG_FORTH_WORDS 
4625						DMARK "TC1" 
4625 f5				push af  
4626 3a 3a 46			ld a, (.dmark)  
4629 32 6e fe			ld (debug_mark),a  
462c 3a 3b 46			ld a, (.dmark+1)  
462f 32 6f fe			ld (debug_mark+1),a  
4632 3a 3c 46			ld a, (.dmark+2)  
4635 32 70 fe			ld (debug_mark+2),a  
4638 18 03			jr .pastdmark  
463a ..			.dmark: db "TC1"  
463d f1			.pastdmark: pop af  
463e			endm  
# End of macro DMARK
463e						CALLMONITOR 
463e cd 9e 19			call break_point_state  
4641				endm  
# End of macro CALLMONITOR
4641					endif 
4641			 
4641					; first time in turn to upper case first char 
4641			 
4641 7e					ld a, (hl) 
4642 c3 cc 46				jp .totsiptou 
4645			 
4645			 
4645 7e			.tot:		ld a, (hl) 
4646 fe 00				cp 0 
4648 ca 10 47				jp z, .totdone 
464b			 
464b					if DEBUG_FORTH_WORDS 
464b						DMARK "TC2" 
464b f5				push af  
464c 3a 60 46			ld a, (.dmark)  
464f 32 6e fe			ld (debug_mark),a  
4652 3a 61 46			ld a, (.dmark+1)  
4655 32 6f fe			ld (debug_mark+1),a  
4658 3a 62 46			ld a, (.dmark+2)  
465b 32 70 fe			ld (debug_mark+2),a  
465e 18 03			jr .pastdmark  
4660 ..			.dmark: db "TC2"  
4663 f1			.pastdmark: pop af  
4664			endm  
# End of macro DMARK
4664						CALLMONITOR 
4664 cd 9e 19			call break_point_state  
4667				endm  
# End of macro CALLMONITOR
4667					endif 
4667					; check to see if current char is a space 
4667			 
4667 fe 20				cp ' ' 
4669 28 21				jr z, .totsp 
466b cd c2 12				call to_lower 
466e					if DEBUG_FORTH_WORDS 
466e						DMARK "TC3" 
466e f5				push af  
466f 3a 83 46			ld a, (.dmark)  
4672 32 6e fe			ld (debug_mark),a  
4675 3a 84 46			ld a, (.dmark+1)  
4678 32 6f fe			ld (debug_mark+1),a  
467b 3a 85 46			ld a, (.dmark+2)  
467e 32 70 fe			ld (debug_mark+2),a  
4681 18 03			jr .pastdmark  
4683 ..			.dmark: db "TC3"  
4686 f1			.pastdmark: pop af  
4687			endm  
# End of macro DMARK
4687						CALLMONITOR 
4687 cd 9e 19			call break_point_state  
468a				endm  
# End of macro CALLMONITOR
468a					endif 
468a 18 63				jr .totnxt 
468c			 
468c			.totsp:         ; on a space, find next char which should be upper 
468c			 
468c					if DEBUG_FORTH_WORDS 
468c						DMARK "TC4" 
468c f5				push af  
468d 3a a1 46			ld a, (.dmark)  
4690 32 6e fe			ld (debug_mark),a  
4693 3a a2 46			ld a, (.dmark+1)  
4696 32 6f fe			ld (debug_mark+1),a  
4699 3a a3 46			ld a, (.dmark+2)  
469c 32 70 fe			ld (debug_mark+2),a  
469f 18 03			jr .pastdmark  
46a1 ..			.dmark: db "TC4"  
46a4 f1			.pastdmark: pop af  
46a5			endm  
# End of macro DMARK
46a5						CALLMONITOR 
46a5 cd 9e 19			call break_point_state  
46a8				endm  
# End of macro CALLMONITOR
46a8					endif 
46a8					;; 
46a8			 
46a8 fe 20				cp ' ' 
46aa 20 20				jr nz, .totsiptou 
46ac 23					inc hl 
46ad 7e					ld a, (hl) 
46ae					if DEBUG_FORTH_WORDS 
46ae						DMARK "TC5" 
46ae f5				push af  
46af 3a c3 46			ld a, (.dmark)  
46b2 32 6e fe			ld (debug_mark),a  
46b5 3a c4 46			ld a, (.dmark+1)  
46b8 32 6f fe			ld (debug_mark+1),a  
46bb 3a c5 46			ld a, (.dmark+2)  
46be 32 70 fe			ld (debug_mark+2),a  
46c1 18 03			jr .pastdmark  
46c3 ..			.dmark: db "TC5"  
46c6 f1			.pastdmark: pop af  
46c7			endm  
# End of macro DMARK
46c7						CALLMONITOR 
46c7 cd 9e 19			call break_point_state  
46ca				endm  
# End of macro CALLMONITOR
46ca					endif 
46ca 18 c0				jr .totsp 
46cc fe 00		.totsiptou:    cp 0 
46ce 28 40				jr z, .totdone 
46d0					; not space and not zero term so upper case it 
46d0 cd b9 12				call to_upper 
46d3			 
46d3					if DEBUG_FORTH_WORDS 
46d3						DMARK "TC6" 
46d3 f5				push af  
46d4 3a e8 46			ld a, (.dmark)  
46d7 32 6e fe			ld (debug_mark),a  
46da 3a e9 46			ld a, (.dmark+1)  
46dd 32 6f fe			ld (debug_mark+1),a  
46e0 3a ea 46			ld a, (.dmark+2)  
46e3 32 70 fe			ld (debug_mark+2),a  
46e6 18 03			jr .pastdmark  
46e8 ..			.dmark: db "TC6"  
46eb f1			.pastdmark: pop af  
46ec			endm  
# End of macro DMARK
46ec						CALLMONITOR 
46ec cd 9e 19			call break_point_state  
46ef				endm  
# End of macro CALLMONITOR
46ef					endif 
46ef			 
46ef			 
46ef			.totnxt: 
46ef			 
46ef 77					ld (hl), a 
46f0 23					inc hl 
46f1					if DEBUG_FORTH_WORDS 
46f1						DMARK "TC7" 
46f1 f5				push af  
46f2 3a 06 47			ld a, (.dmark)  
46f5 32 6e fe			ld (debug_mark),a  
46f8 3a 07 47			ld a, (.dmark+1)  
46fb 32 6f fe			ld (debug_mark+1),a  
46fe 3a 08 47			ld a, (.dmark+2)  
4701 32 70 fe			ld (debug_mark+2),a  
4704 18 03			jr .pastdmark  
4706 ..			.dmark: db "TC7"  
4709 f1			.pastdmark: pop af  
470a			endm  
# End of macro DMARK
470a						CALLMONITOR 
470a cd 9e 19			call break_point_state  
470d				endm  
# End of macro CALLMONITOR
470d					endif 
470d c3 45 46				jp .tot 
4710			 
4710					 
4710			 
4710			 
4710			; for each char convert to low 
4710					 
4710			.totdone: 
4710					if DEBUG_FORTH_WORDS 
4710						DMARK "TCd" 
4710 f5				push af  
4711 3a 25 47			ld a, (.dmark)  
4714 32 6e fe			ld (debug_mark),a  
4717 3a 26 47			ld a, (.dmark+1)  
471a 32 6f fe			ld (debug_mark+1),a  
471d 3a 27 47			ld a, (.dmark+2)  
4720 32 70 fe			ld (debug_mark+2),a  
4723 18 03			jr .pastdmark  
4725 ..			.dmark: db "TCd"  
4728 f1			.pastdmark: pop af  
4729			endm  
# End of macro DMARK
4729						CALLMONITOR 
4729 cd 9e 19			call break_point_state  
472c				endm  
# End of macro CALLMONITOR
472c					endif 
472c					NEXTW 
472c c3 16 24			jp macro_next 
472f				endm 
# End of macro NEXTW
472f			 
472f			.SUBSTR: 
472f				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
472f 48				db WORD_SYS_CORE+52             
4730 8d 47			dw .LEFT            
4732 07				db 6 + 1 
4733 .. 00			db "SUBSTR",0              
473a				endm 
# End of macro CWHEAD
473a			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
473a			 
473a					if DEBUG_FORTH_WORDS_KEY 
473a						DMARK "SST" 
473a f5				push af  
473b 3a 4f 47			ld a, (.dmark)  
473e 32 6e fe			ld (debug_mark),a  
4741 3a 50 47			ld a, (.dmark+1)  
4744 32 6f fe			ld (debug_mark+1),a  
4747 3a 51 47			ld a, (.dmark+2)  
474a 32 70 fe			ld (debug_mark+2),a  
474d 18 03			jr .pastdmark  
474f ..			.dmark: db "SST"  
4752 f1			.pastdmark: pop af  
4753			endm  
# End of macro DMARK
4753						CALLMONITOR 
4753 cd 9e 19			call break_point_state  
4756				endm  
# End of macro CALLMONITOR
4756					endif 
4756			; TODO check string type 
4756					FORTH_DSP_VALUEHL 
4756 cd 60 22			call macro_dsp_valuehl 
4759				endm 
# End of macro FORTH_DSP_VALUEHL
4759			 
4759 e5					push hl      ; string length 
475a			 
475a					FORTH_DSP_POP 
475a cd 18 23			call macro_forth_dsp_pop 
475d				endm 
# End of macro FORTH_DSP_POP
475d			 
475d					FORTH_DSP_VALUEHL 
475d cd 60 22			call macro_dsp_valuehl 
4760				endm 
# End of macro FORTH_DSP_VALUEHL
4760			 
4760 e5					push hl     ; start char 
4761			 
4761					FORTH_DSP_POP 
4761 cd 18 23			call macro_forth_dsp_pop 
4764				endm 
# End of macro FORTH_DSP_POP
4764			 
4764			 
4764					FORTH_DSP_VALUE 
4764 cd 49 22			call macro_forth_dsp_value 
4767				endm 
# End of macro FORTH_DSP_VALUE
4767			 
4767 d1					pop de    ; get start post offset 
4768			 
4768 19					add hl, de    ; starting offset 
4769			 
4769 c1					pop bc 
476a c5					push bc      ; grab size of string 
476b			 
476b e5					push hl    ; save string start  
476c			 
476c 26 00				ld h, 0 
476e 69					ld l, c 
476f 23					inc hl 
4770 23					inc hl 
4771			 
4771 cd 13 14				call malloc 
4774				if DEBUG_FORTH_MALLOC_GUARD 
4774 cc e8 5c				call z,malloc_error 
4777				endif 
4777			 
4777 eb					ex de, hl      ; save malloc area for string copy 
4778 e1					pop hl    ; get back source 
4779 c1					pop bc    ; get length of string back 
477a			 
477a d5					push de    ; save malloc area for after we push 
477b ed b0				ldir     ; copy substr 
477d			 
477d			 
477d eb					ex de, hl 
477e 3e 00				ld a, 0 
4780 77					ld (hl), a   ; term substr 
4781			 
4781					 
4781 e1					pop hl    ; get malloc so we can push it 
4782 e5					push hl   ; save so we can free it afterwards 
4783			 
4783 cd d7 20				call forth_push_str 
4786			 
4786 e1					pop hl 
4787 cd dd 14				call free 
478a			 
478a					 
478a					 
478a			 
478a			 
478a					NEXTW 
478a c3 16 24			jp macro_next 
478d				endm 
# End of macro NEXTW
478d			 
478d			.LEFT: 
478d				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
478d 48				db WORD_SYS_CORE+52             
478e b5 47			dw .RIGHT            
4790 05				db 4 + 1 
4791 .. 00			db "LEFT",0              
4796				endm 
# End of macro CWHEAD
4796			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4796					if DEBUG_FORTH_WORDS_KEY 
4796						DMARK "LEF" 
4796 f5				push af  
4797 3a ab 47			ld a, (.dmark)  
479a 32 6e fe			ld (debug_mark),a  
479d 3a ac 47			ld a, (.dmark+1)  
47a0 32 6f fe			ld (debug_mark+1),a  
47a3 3a ad 47			ld a, (.dmark+2)  
47a6 32 70 fe			ld (debug_mark+2),a  
47a9 18 03			jr .pastdmark  
47ab ..			.dmark: db "LEF"  
47ae f1			.pastdmark: pop af  
47af			endm  
# End of macro DMARK
47af						CALLMONITOR 
47af cd 9e 19			call break_point_state  
47b2				endm  
# End of macro CALLMONITOR
47b2					endif 
47b2			 
47b2					NEXTW 
47b2 c3 16 24			jp macro_next 
47b5				endm 
# End of macro NEXTW
47b5			.RIGHT: 
47b5				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
47b5 48				db WORD_SYS_CORE+52             
47b6 de 47			dw .STR2NUM            
47b8 06				db 5 + 1 
47b9 .. 00			db "RIGHT",0              
47bf				endm 
# End of macro CWHEAD
47bf			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
47bf					if DEBUG_FORTH_WORDS_KEY 
47bf						DMARK "RIG" 
47bf f5				push af  
47c0 3a d4 47			ld a, (.dmark)  
47c3 32 6e fe			ld (debug_mark),a  
47c6 3a d5 47			ld a, (.dmark+1)  
47c9 32 6f fe			ld (debug_mark+1),a  
47cc 3a d6 47			ld a, (.dmark+2)  
47cf 32 70 fe			ld (debug_mark+2),a  
47d2 18 03			jr .pastdmark  
47d4 ..			.dmark: db "RIG"  
47d7 f1			.pastdmark: pop af  
47d8			endm  
# End of macro DMARK
47d8						CALLMONITOR 
47d8 cd 9e 19			call break_point_state  
47db				endm  
# End of macro CALLMONITOR
47db					endif 
47db			 
47db					NEXTW 
47db c3 16 24			jp macro_next 
47de				endm 
# End of macro NEXTW
47de			 
47de			 
47de			.STR2NUM: 
47de				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
47de 48				db WORD_SYS_CORE+52             
47df 6a 48			dw .NUM2STR            
47e1 08				db 7 + 1 
47e2 .. 00			db "STR2NUM",0              
47ea				endm 
# End of macro CWHEAD
47ea			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
47ea			 
47ea			 
47ea			; TODO STR type check to do 
47ea					if DEBUG_FORTH_WORDS_KEY 
47ea						DMARK "S2N" 
47ea f5				push af  
47eb 3a ff 47			ld a, (.dmark)  
47ee 32 6e fe			ld (debug_mark),a  
47f1 3a 00 48			ld a, (.dmark+1)  
47f4 32 6f fe			ld (debug_mark+1),a  
47f7 3a 01 48			ld a, (.dmark+2)  
47fa 32 70 fe			ld (debug_mark+2),a  
47fd 18 03			jr .pastdmark  
47ff ..			.dmark: db "S2N"  
4802 f1			.pastdmark: pop af  
4803			endm  
# End of macro DMARK
4803						CALLMONITOR 
4803 cd 9e 19			call break_point_state  
4806				endm  
# End of macro CALLMONITOR
4806					endif 
4806			 
4806					;FORTH_DSP 
4806					FORTH_DSP_VALUE 
4806 cd 49 22			call macro_forth_dsp_value 
4809				endm 
# End of macro FORTH_DSP_VALUE
4809					;inc hl 
4809			 
4809 eb					ex de, hl 
480a					if DEBUG_FORTH_WORDS 
480a						DMARK "S2a" 
480a f5				push af  
480b 3a 1f 48			ld a, (.dmark)  
480e 32 6e fe			ld (debug_mark),a  
4811 3a 20 48			ld a, (.dmark+1)  
4814 32 6f fe			ld (debug_mark+1),a  
4817 3a 21 48			ld a, (.dmark+2)  
481a 32 70 fe			ld (debug_mark+2),a  
481d 18 03			jr .pastdmark  
481f ..			.dmark: db "S2a"  
4822 f1			.pastdmark: pop af  
4823			endm  
# End of macro DMARK
4823						CALLMONITOR 
4823 cd 9e 19			call break_point_state  
4826				endm  
# End of macro CALLMONITOR
4826					endif 
4826 cd 41 13				call string_to_uint16 
4829			 
4829					if DEBUG_FORTH_WORDS 
4829						DMARK "S2b" 
4829 f5				push af  
482a 3a 3e 48			ld a, (.dmark)  
482d 32 6e fe			ld (debug_mark),a  
4830 3a 3f 48			ld a, (.dmark+1)  
4833 32 6f fe			ld (debug_mark+1),a  
4836 3a 40 48			ld a, (.dmark+2)  
4839 32 70 fe			ld (debug_mark+2),a  
483c 18 03			jr .pastdmark  
483e ..			.dmark: db "S2b"  
4841 f1			.pastdmark: pop af  
4842			endm  
# End of macro DMARK
4842						CALLMONITOR 
4842 cd 9e 19			call break_point_state  
4845				endm  
# End of macro CALLMONITOR
4845					endif 
4845			;		push hl 
4845					FORTH_DSP_POP 
4845 cd 18 23			call macro_forth_dsp_pop 
4848				endm 
# End of macro FORTH_DSP_POP
4848			;		pop hl 
4848					 
4848					if DEBUG_FORTH_WORDS 
4848						DMARK "S2b" 
4848 f5				push af  
4849 3a 5d 48			ld a, (.dmark)  
484c 32 6e fe			ld (debug_mark),a  
484f 3a 5e 48			ld a, (.dmark+1)  
4852 32 6f fe			ld (debug_mark+1),a  
4855 3a 5f 48			ld a, (.dmark+2)  
4858 32 70 fe			ld (debug_mark+2),a  
485b 18 03			jr .pastdmark  
485d ..			.dmark: db "S2b"  
4860 f1			.pastdmark: pop af  
4861			endm  
# End of macro DMARK
4861						CALLMONITOR 
4861 cd 9e 19			call break_point_state  
4864				endm  
# End of macro CALLMONITOR
4864					endif 
4864 cd 69 20				call forth_push_numhl	 
4867			 
4867				 
4867				       NEXTW 
4867 c3 16 24			jp macro_next 
486a				endm 
# End of macro NEXTW
486a			.NUM2STR: 
486a				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
486a 48				db WORD_SYS_CORE+52             
486b 79 48			dw .CONCAT            
486d 08				db 7 + 1 
486e .. 00			db "NUM2STR",0              
4876				endm 
# End of macro CWHEAD
4876			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4876			 
4876			;		; malloc a string to target 
4876			;		ld hl, 10     ; TODO max string size should be fine 
4876			;		call malloc 
4876			;		push hl    ; save malloc location 
4876			; 
4876			; 
4876			;; TODO check int type 
4876			;		FORTH_DSP_VALUEHL 
4876			;		ld a, l 
4876			;		call DispAToASCII   
4876			;;TODO need to chage above call to dump into string 
4876			; 
4876			; 
4876			 
4876				       NEXTW 
4876 c3 16 24			jp macro_next 
4879				endm 
# End of macro NEXTW
4879			 
4879			.CONCAT: 
4879				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4879 48				db WORD_SYS_CORE+52             
487a 2c 49			dw .FIND            
487c 07				db 6 + 1 
487d .. 00			db "CONCAT",0              
4884				endm 
# End of macro CWHEAD
4884			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4884			 
4884			; TODO check string type 
4884			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4884			 
4884					if DEBUG_FORTH_WORDS_KEY 
4884						DMARK "CON" 
4884 f5				push af  
4885 3a 99 48			ld a, (.dmark)  
4888 32 6e fe			ld (debug_mark),a  
488b 3a 9a 48			ld a, (.dmark+1)  
488e 32 6f fe			ld (debug_mark+1),a  
4891 3a 9b 48			ld a, (.dmark+2)  
4894 32 70 fe			ld (debug_mark+2),a  
4897 18 03			jr .pastdmark  
4899 ..			.dmark: db "CON"  
489c f1			.pastdmark: pop af  
489d			endm  
# End of macro DMARK
489d						CALLMONITOR 
489d cd 9e 19			call break_point_state  
48a0				endm  
# End of macro CALLMONITOR
48a0					endif 
48a0			 
48a0			 
48a0					FORTH_DSP_VALUE 
48a0 cd 49 22			call macro_forth_dsp_value 
48a3				endm 
# End of macro FORTH_DSP_VALUE
48a3 e5					push hl   ; s2 
48a4			 
48a4					FORTH_DSP_POP 
48a4 cd 18 23			call macro_forth_dsp_pop 
48a7				endm 
# End of macro FORTH_DSP_POP
48a7			 
48a7					FORTH_DSP_VALUE 
48a7 cd 49 22			call macro_forth_dsp_value 
48aa				endm 
# End of macro FORTH_DSP_VALUE
48aa			 
48aa e5					push hl   ; s1 
48ab			 
48ab					FORTH_DSP_POP 
48ab cd 18 23			call macro_forth_dsp_pop 
48ae				endm 
# End of macro FORTH_DSP_POP
48ae					 
48ae			 
48ae					; copy s1 
48ae			 
48ae				 
48ae					; save ptr 
48ae e1					pop hl  
48af e5					push hl 
48b0 3e 00				ld a, 0 
48b2 cd b5 13				call strlent 
48b5					;inc hl    ; zer0 
48b5 06 00				ld b, 0 
48b7 4d					ld c, l 
48b8 e1					pop hl		 
48b9 11 c8 f1				ld de, scratch	 
48bc					if DEBUG_FORTH_WORDS 
48bc						DMARK "CO1" 
48bc f5				push af  
48bd 3a d1 48			ld a, (.dmark)  
48c0 32 6e fe			ld (debug_mark),a  
48c3 3a d2 48			ld a, (.dmark+1)  
48c6 32 6f fe			ld (debug_mark+1),a  
48c9 3a d3 48			ld a, (.dmark+2)  
48cc 32 70 fe			ld (debug_mark+2),a  
48cf 18 03			jr .pastdmark  
48d1 ..			.dmark: db "CO1"  
48d4 f1			.pastdmark: pop af  
48d5			endm  
# End of macro DMARK
48d5						CALLMONITOR 
48d5 cd 9e 19			call break_point_state  
48d8				endm  
# End of macro CALLMONITOR
48d8					endif 
48d8 ed b0				ldir 
48da			 
48da e1					pop hl 
48db e5					push hl 
48dc d5					push de 
48dd			 
48dd			 
48dd 3e 00				ld a, 0 
48df cd b5 13				call strlent 
48e2 23					inc hl    ; zer0 
48e3 23					inc hl 
48e4 06 00				ld b, 0 
48e6 4d					ld c, l 
48e7 d1					pop de 
48e8 e1					pop hl		 
48e9					if DEBUG_FORTH_WORDS 
48e9						DMARK "CO2" 
48e9 f5				push af  
48ea 3a fe 48			ld a, (.dmark)  
48ed 32 6e fe			ld (debug_mark),a  
48f0 3a ff 48			ld a, (.dmark+1)  
48f3 32 6f fe			ld (debug_mark+1),a  
48f6 3a 00 49			ld a, (.dmark+2)  
48f9 32 70 fe			ld (debug_mark+2),a  
48fc 18 03			jr .pastdmark  
48fe ..			.dmark: db "CO2"  
4901 f1			.pastdmark: pop af  
4902			endm  
# End of macro DMARK
4902						CALLMONITOR 
4902 cd 9e 19			call break_point_state  
4905				endm  
# End of macro CALLMONITOR
4905					endif 
4905 ed b0				ldir 
4907			 
4907			 
4907			 
4907 21 c8 f1				ld hl, scratch 
490a					if DEBUG_FORTH_WORDS 
490a						DMARK "CO5" 
490a f5				push af  
490b 3a 1f 49			ld a, (.dmark)  
490e 32 6e fe			ld (debug_mark),a  
4911 3a 20 49			ld a, (.dmark+1)  
4914 32 6f fe			ld (debug_mark+1),a  
4917 3a 21 49			ld a, (.dmark+2)  
491a 32 70 fe			ld (debug_mark+2),a  
491d 18 03			jr .pastdmark  
491f ..			.dmark: db "CO5"  
4922 f1			.pastdmark: pop af  
4923			endm  
# End of macro DMARK
4923						CALLMONITOR 
4923 cd 9e 19			call break_point_state  
4926				endm  
# End of macro CALLMONITOR
4926					endif 
4926			 
4926 cd d7 20				call forth_push_str 
4929			 
4929			 
4929			 
4929			 
4929				       NEXTW 
4929 c3 16 24			jp macro_next 
492c				endm 
# End of macro NEXTW
492c			 
492c			 
492c			.FIND: 
492c				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
492c 4b				db WORD_SYS_CORE+55             
492d ea 49			dw .LEN            
492f 05				db 4 + 1 
4930 .. 00			db "FIND",0              
4935				endm 
# End of macro CWHEAD
4935			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4935			 
4935					if DEBUG_FORTH_WORDS_KEY 
4935						DMARK "FND" 
4935 f5				push af  
4936 3a 4a 49			ld a, (.dmark)  
4939 32 6e fe			ld (debug_mark),a  
493c 3a 4b 49			ld a, (.dmark+1)  
493f 32 6f fe			ld (debug_mark+1),a  
4942 3a 4c 49			ld a, (.dmark+2)  
4945 32 70 fe			ld (debug_mark+2),a  
4948 18 03			jr .pastdmark  
494a ..			.dmark: db "FND"  
494d f1			.pastdmark: pop af  
494e			endm  
# End of macro DMARK
494e						CALLMONITOR 
494e cd 9e 19			call break_point_state  
4951				endm  
# End of macro CALLMONITOR
4951					endif 
4951			 
4951			; TODO check string type 
4951					FORTH_DSP_VALUE 
4951 cd 49 22			call macro_forth_dsp_value 
4954				endm 
# End of macro FORTH_DSP_VALUE
4954			 
4954 e5					push hl    
4955 7e					ld a,(hl)    ; char to find   
4956			; TODO change char to substr 
4956			 
4956 f5					push af 
4957					 
4957			 
4957			 
4957					if DEBUG_FORTH_WORDS 
4957						DMARK "FN1" 
4957 f5				push af  
4958 3a 6c 49			ld a, (.dmark)  
495b 32 6e fe			ld (debug_mark),a  
495e 3a 6d 49			ld a, (.dmark+1)  
4961 32 6f fe			ld (debug_mark+1),a  
4964 3a 6e 49			ld a, (.dmark+2)  
4967 32 70 fe			ld (debug_mark+2),a  
496a 18 03			jr .pastdmark  
496c ..			.dmark: db "FN1"  
496f f1			.pastdmark: pop af  
4970			endm  
# End of macro DMARK
4970						CALLMONITOR 
4970 cd 9e 19			call break_point_state  
4973				endm  
# End of macro CALLMONITOR
4973					endif 
4973			 
4973					FORTH_DSP_POP 
4973 cd 18 23			call macro_forth_dsp_pop 
4976				endm 
# End of macro FORTH_DSP_POP
4976			 
4976					; string to search 
4976			 
4976					FORTH_DSP_VALUE 
4976 cd 49 22			call macro_forth_dsp_value 
4979				endm 
# End of macro FORTH_DSP_VALUE
4979			 
4979 d1					pop de  ; d is char to find  
497a			 
497a					if DEBUG_FORTH_WORDS 
497a						DMARK "FN2" 
497a f5				push af  
497b 3a 8f 49			ld a, (.dmark)  
497e 32 6e fe			ld (debug_mark),a  
4981 3a 90 49			ld a, (.dmark+1)  
4984 32 6f fe			ld (debug_mark+1),a  
4987 3a 91 49			ld a, (.dmark+2)  
498a 32 70 fe			ld (debug_mark+2),a  
498d 18 03			jr .pastdmark  
498f ..			.dmark: db "FN2"  
4992 f1			.pastdmark: pop af  
4993			endm  
# End of macro DMARK
4993						CALLMONITOR 
4993 cd 9e 19			call break_point_state  
4996				endm  
# End of macro CALLMONITOR
4996					endif 
4996					 
4996 01 00 00				ld bc, 0 
4999 7e			.findchar:      ld a,(hl) 
499a fe 00				cp 0   		 
499c 28 27				jr z, .finddone     
499e ba					cp d 
499f 28 20				jr z, .foundchar 
49a1 03					inc bc 
49a2 23					inc hl 
49a3					if DEBUG_FORTH_WORDS 
49a3						DMARK "FN3" 
49a3 f5				push af  
49a4 3a b8 49			ld a, (.dmark)  
49a7 32 6e fe			ld (debug_mark),a  
49aa 3a b9 49			ld a, (.dmark+1)  
49ad 32 6f fe			ld (debug_mark+1),a  
49b0 3a ba 49			ld a, (.dmark+2)  
49b3 32 70 fe			ld (debug_mark+2),a  
49b6 18 03			jr .pastdmark  
49b8 ..			.dmark: db "FN3"  
49bb f1			.pastdmark: pop af  
49bc			endm  
# End of macro DMARK
49bc						CALLMONITOR 
49bc cd 9e 19			call break_point_state  
49bf				endm  
# End of macro CALLMONITOR
49bf					endif 
49bf 18 d8				jr .findchar 
49c1			 
49c1			 
49c1 c5			.foundchar:	push bc 
49c2 e1					pop hl 
49c3 18 03				jr .findexit 
49c5			 
49c5			 
49c5							 
49c5			 
49c5			.finddone:     ; got to end of string with no find 
49c5 21 00 00				ld hl, 0 
49c8			.findexit: 
49c8			 
49c8					if DEBUG_FORTH_WORDS 
49c8						DMARK "FNd" 
49c8 f5				push af  
49c9 3a dd 49			ld a, (.dmark)  
49cc 32 6e fe			ld (debug_mark),a  
49cf 3a de 49			ld a, (.dmark+1)  
49d2 32 6f fe			ld (debug_mark+1),a  
49d5 3a df 49			ld a, (.dmark+2)  
49d8 32 70 fe			ld (debug_mark+2),a  
49db 18 03			jr .pastdmark  
49dd ..			.dmark: db "FNd"  
49e0 f1			.pastdmark: pop af  
49e1			endm  
# End of macro DMARK
49e1						CALLMONITOR 
49e1 cd 9e 19			call break_point_state  
49e4				endm  
# End of macro CALLMONITOR
49e4					endif 
49e4 cd 69 20			call forth_push_numhl 
49e7			 
49e7				       NEXTW 
49e7 c3 16 24			jp macro_next 
49ea				endm 
# End of macro NEXTW
49ea			 
49ea			.LEN: 
49ea				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
49ea 4c				db WORD_SYS_CORE+56             
49eb 54 4a			dw .ASC            
49ed 06				db 5 + 1 
49ee .. 00			db "COUNT",0              
49f4				endm 
# End of macro CWHEAD
49f4			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
49f4			 
49f4					if DEBUG_FORTH_WORDS_KEY 
49f4						DMARK "CNT" 
49f4 f5				push af  
49f5 3a 09 4a			ld a, (.dmark)  
49f8 32 6e fe			ld (debug_mark),a  
49fb 3a 0a 4a			ld a, (.dmark+1)  
49fe 32 6f fe			ld (debug_mark+1),a  
4a01 3a 0b 4a			ld a, (.dmark+2)  
4a04 32 70 fe			ld (debug_mark+2),a  
4a07 18 03			jr .pastdmark  
4a09 ..			.dmark: db "CNT"  
4a0c f1			.pastdmark: pop af  
4a0d			endm  
# End of macro DMARK
4a0d						CALLMONITOR 
4a0d cd 9e 19			call break_point_state  
4a10				endm  
# End of macro CALLMONITOR
4a10					endif 
4a10			; TODO check string type 
4a10					FORTH_DSP_VALUE 
4a10 cd 49 22			call macro_forth_dsp_value 
4a13				endm 
# End of macro FORTH_DSP_VALUE
4a13			 
4a13			 
4a13					if DEBUG_FORTH_WORDS 
4a13						DMARK "CN?" 
4a13 f5				push af  
4a14 3a 28 4a			ld a, (.dmark)  
4a17 32 6e fe			ld (debug_mark),a  
4a1a 3a 29 4a			ld a, (.dmark+1)  
4a1d 32 6f fe			ld (debug_mark+1),a  
4a20 3a 2a 4a			ld a, (.dmark+2)  
4a23 32 70 fe			ld (debug_mark+2),a  
4a26 18 03			jr .pastdmark  
4a28 ..			.dmark: db "CN?"  
4a2b f1			.pastdmark: pop af  
4a2c			endm  
# End of macro DMARK
4a2c						CALLMONITOR 
4a2c cd 9e 19			call break_point_state  
4a2f				endm  
# End of macro CALLMONITOR
4a2f					endif 
4a2f cd aa 13				call strlenz 
4a32					if DEBUG_FORTH_WORDS 
4a32						DMARK "CNl" 
4a32 f5				push af  
4a33 3a 47 4a			ld a, (.dmark)  
4a36 32 6e fe			ld (debug_mark),a  
4a39 3a 48 4a			ld a, (.dmark+1)  
4a3c 32 6f fe			ld (debug_mark+1),a  
4a3f 3a 49 4a			ld a, (.dmark+2)  
4a42 32 70 fe			ld (debug_mark+2),a  
4a45 18 03			jr .pastdmark  
4a47 ..			.dmark: db "CNl"  
4a4a f1			.pastdmark: pop af  
4a4b			endm  
# End of macro DMARK
4a4b						CALLMONITOR 
4a4b cd 9e 19			call break_point_state  
4a4e				endm  
# End of macro CALLMONITOR
4a4e					endif 
4a4e			 
4a4e cd 69 20				call forth_push_numhl 
4a51			 
4a51			 
4a51			 
4a51				       NEXTW 
4a51 c3 16 24			jp macro_next 
4a54				endm 
# End of macro NEXTW
4a54			.ASC: 
4a54				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4a54 4d				db WORD_SYS_CORE+57             
4a55 c2 4a			dw .CHR            
4a57 04				db 3 + 1 
4a58 .. 00			db "ASC",0              
4a5c				endm 
# End of macro CWHEAD
4a5c			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4a5c					if DEBUG_FORTH_WORDS_KEY 
4a5c						DMARK "ASC" 
4a5c f5				push af  
4a5d 3a 71 4a			ld a, (.dmark)  
4a60 32 6e fe			ld (debug_mark),a  
4a63 3a 72 4a			ld a, (.dmark+1)  
4a66 32 6f fe			ld (debug_mark+1),a  
4a69 3a 73 4a			ld a, (.dmark+2)  
4a6c 32 70 fe			ld (debug_mark+2),a  
4a6f 18 03			jr .pastdmark  
4a71 ..			.dmark: db "ASC"  
4a74 f1			.pastdmark: pop af  
4a75			endm  
# End of macro DMARK
4a75						CALLMONITOR 
4a75 cd 9e 19			call break_point_state  
4a78				endm  
# End of macro CALLMONITOR
4a78					endif 
4a78					FORTH_DSP_VALUE 
4a78 cd 49 22			call macro_forth_dsp_value 
4a7b				endm 
# End of macro FORTH_DSP_VALUE
4a7b					;v5 FORTH_DSP_VALUE 
4a7b			;		inc hl      ; now at start of numeric as string 
4a7b			 
4a7b e5					push hl 
4a7c			 
4a7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a7c cd 18 23			call macro_forth_dsp_pop 
4a7f				endm 
# End of macro FORTH_DSP_POP
4a7f			 
4a7f e1					pop hl 
4a80			 
4a80					if DEBUG_FORTH_WORDS 
4a80						DMARK "AS1" 
4a80 f5				push af  
4a81 3a 95 4a			ld a, (.dmark)  
4a84 32 6e fe			ld (debug_mark),a  
4a87 3a 96 4a			ld a, (.dmark+1)  
4a8a 32 6f fe			ld (debug_mark+1),a  
4a8d 3a 97 4a			ld a, (.dmark+2)  
4a90 32 70 fe			ld (debug_mark+2),a  
4a93 18 03			jr .pastdmark  
4a95 ..			.dmark: db "AS1"  
4a98 f1			.pastdmark: pop af  
4a99			endm  
# End of macro DMARK
4a99						CALLMONITOR 
4a99 cd 9e 19			call break_point_state  
4a9c				endm  
# End of macro CALLMONITOR
4a9c					endif 
4a9c					; push the content of a onto the stack as a value 
4a9c			 
4a9c 7e					ld a,(hl)   ; get char 
4a9d 26 00				ld h,0 
4a9f 6f					ld l,a 
4aa0					if DEBUG_FORTH_WORDS 
4aa0						DMARK "AS2" 
4aa0 f5				push af  
4aa1 3a b5 4a			ld a, (.dmark)  
4aa4 32 6e fe			ld (debug_mark),a  
4aa7 3a b6 4a			ld a, (.dmark+1)  
4aaa 32 6f fe			ld (debug_mark+1),a  
4aad 3a b7 4a			ld a, (.dmark+2)  
4ab0 32 70 fe			ld (debug_mark+2),a  
4ab3 18 03			jr .pastdmark  
4ab5 ..			.dmark: db "AS2"  
4ab8 f1			.pastdmark: pop af  
4ab9			endm  
# End of macro DMARK
4ab9						CALLMONITOR 
4ab9 cd 9e 19			call break_point_state  
4abc				endm  
# End of macro CALLMONITOR
4abc					endif 
4abc cd 69 20				call forth_push_numhl 
4abf			 
4abf				       NEXTW 
4abf c3 16 24			jp macro_next 
4ac2				endm 
# End of macro NEXTW
4ac2			 
4ac2			.CHR: 
4ac2				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4ac2 4d				db WORD_SYS_CORE+57             
4ac3 fe 4a			dw .ENDSTR            
4ac5 04				db 3 + 1 
4ac6 .. 00			db "CHR",0              
4aca				endm 
# End of macro CWHEAD
4aca			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4aca					if DEBUG_FORTH_WORDS_KEY 
4aca						DMARK "CHR" 
4aca f5				push af  
4acb 3a df 4a			ld a, (.dmark)  
4ace 32 6e fe			ld (debug_mark),a  
4ad1 3a e0 4a			ld a, (.dmark+1)  
4ad4 32 6f fe			ld (debug_mark+1),a  
4ad7 3a e1 4a			ld a, (.dmark+2)  
4ada 32 70 fe			ld (debug_mark+2),a  
4add 18 03			jr .pastdmark  
4adf ..			.dmark: db "CHR"  
4ae2 f1			.pastdmark: pop af  
4ae3			endm  
# End of macro DMARK
4ae3						CALLMONITOR 
4ae3 cd 9e 19			call break_point_state  
4ae6				endm  
# End of macro CALLMONITOR
4ae6					endif 
4ae6					FORTH_DSP_VALUEHL 
4ae6 cd 60 22			call macro_dsp_valuehl 
4ae9				endm 
# End of macro FORTH_DSP_VALUEHL
4ae9			 
4ae9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae9 cd 18 23			call macro_forth_dsp_pop 
4aec				endm 
# End of macro FORTH_DSP_POP
4aec			 
4aec					; save asci byte as a zero term string and push string 
4aec			 
4aec 7d					ld a,l 
4aed 32 c8 f1				ld (scratch), a 
4af0			 
4af0 3e 00				ld a, 0 
4af2 32 c9 f1				ld (scratch+1), a 
4af5			 
4af5 21 c8 f1				ld hl, scratch 
4af8 cd d7 20				call forth_push_str 
4afb			 
4afb			 
4afb				       NEXTW 
4afb c3 16 24			jp macro_next 
4afe				endm 
# End of macro NEXTW
4afe			 
4afe			 
4afe			 
4afe			 
4afe			.ENDSTR: 
4afe			; eof 
4afe			 
# End of file forth_words_str.asm
4afe			include "forth_words_key.asm" 
4afe			 
4afe			; | ## Keyboard Words 
4afe			 
4afe			.KEY: 
4afe				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4afe 3e				db WORD_SYS_CORE+42             
4aff 2e 4b			dw .WAITK            
4b01 04				db 3 + 1 
4b02 .. 00			db "KEY",0              
4b06				endm 
# End of macro CWHEAD
4b06			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4b06			 
4b06					if DEBUG_FORTH_WORDS_KEY 
4b06						DMARK "KEY" 
4b06 f5				push af  
4b07 3a 1b 4b			ld a, (.dmark)  
4b0a 32 6e fe			ld (debug_mark),a  
4b0d 3a 1c 4b			ld a, (.dmark+1)  
4b10 32 6f fe			ld (debug_mark+1),a  
4b13 3a 1d 4b			ld a, (.dmark+2)  
4b16 32 70 fe			ld (debug_mark+2),a  
4b19 18 03			jr .pastdmark  
4b1b ..			.dmark: db "KEY"  
4b1e f1			.pastdmark: pop af  
4b1f			endm  
# End of macro DMARK
4b1f						CALLMONITOR 
4b1f cd 9e 19			call break_point_state  
4b22				endm  
# End of macro CALLMONITOR
4b22					endif 
4b22			; TODO currently waits 
4b22 cd ae 77				call cin 
4b25					;call cin_wait 
4b25 6f					ld l, a 
4b26 26 00				ld h, 0 
4b28 cd 69 20				call forth_push_numhl 
4b2b					NEXTW 
4b2b c3 16 24			jp macro_next 
4b2e				endm 
# End of macro NEXTW
4b2e			.WAITK: 
4b2e				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4b2e 3f				db WORD_SYS_CORE+43             
4b2f 60 4b			dw .ACCEPT            
4b31 06				db 5 + 1 
4b32 .. 00			db "WAITK",0              
4b38				endm 
# End of macro CWHEAD
4b38			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4b38					if DEBUG_FORTH_WORDS_KEY 
4b38						DMARK "WAI" 
4b38 f5				push af  
4b39 3a 4d 4b			ld a, (.dmark)  
4b3c 32 6e fe			ld (debug_mark),a  
4b3f 3a 4e 4b			ld a, (.dmark+1)  
4b42 32 6f fe			ld (debug_mark+1),a  
4b45 3a 4f 4b			ld a, (.dmark+2)  
4b48 32 70 fe			ld (debug_mark+2),a  
4b4b 18 03			jr .pastdmark  
4b4d ..			.dmark: db "WAI"  
4b50 f1			.pastdmark: pop af  
4b51			endm  
# End of macro DMARK
4b51						CALLMONITOR 
4b51 cd 9e 19			call break_point_state  
4b54				endm  
# End of macro CALLMONITOR
4b54					endif 
4b54 cd 9d 77				call cin_wait 
4b57 6f					ld l, a 
4b58 26 00				ld h, 0 
4b5a cd 69 20				call forth_push_numhl 
4b5d					NEXTW 
4b5d c3 16 24			jp macro_next 
4b60				endm 
# End of macro NEXTW
4b60			.ACCEPT: 
4b60				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4b60 40				db WORD_SYS_CORE+44             
4b61 be 4b			dw .EDIT            
4b63 07				db 6 + 1 
4b64 .. 00			db "ACCEPT",0              
4b6b				endm 
# End of macro CWHEAD
4b6b			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4b6b					; TODO crashes on push 
4b6b					if DEBUG_FORTH_WORDS_KEY 
4b6b						DMARK "ACC" 
4b6b f5				push af  
4b6c 3a 80 4b			ld a, (.dmark)  
4b6f 32 6e fe			ld (debug_mark),a  
4b72 3a 81 4b			ld a, (.dmark+1)  
4b75 32 6f fe			ld (debug_mark+1),a  
4b78 3a 82 4b			ld a, (.dmark+2)  
4b7b 32 70 fe			ld (debug_mark+2),a  
4b7e 18 03			jr .pastdmark  
4b80 ..			.dmark: db "ACC"  
4b83 f1			.pastdmark: pop af  
4b84			endm  
# End of macro DMARK
4b84						CALLMONITOR 
4b84 cd 9e 19			call break_point_state  
4b87				endm  
# End of macro CALLMONITOR
4b87					endif 
4b87 21 c6 f3				ld hl, os_input 
4b8a 3e 00				ld a, 0 
4b8c 77					ld (hl),a 
4b8d 3a 65 fa				ld a,(f_cursor_ptr) 
4b90 16 64				ld d, 100 
4b92 0e 00				ld c, 0 
4b94 1e 28				ld e, 40 
4b96 cd 79 0f				call input_str 
4b99					; TODO perhaps do a type check and wrap in quotes if not a number 
4b99 21 c6 f3				ld hl, os_input 
4b9c					if DEBUG_FORTH_WORDS 
4b9c						DMARK "AC1" 
4b9c f5				push af  
4b9d 3a b1 4b			ld a, (.dmark)  
4ba0 32 6e fe			ld (debug_mark),a  
4ba3 3a b2 4b			ld a, (.dmark+1)  
4ba6 32 6f fe			ld (debug_mark+1),a  
4ba9 3a b3 4b			ld a, (.dmark+2)  
4bac 32 70 fe			ld (debug_mark+2),a  
4baf 18 03			jr .pastdmark  
4bb1 ..			.dmark: db "AC1"  
4bb4 f1			.pastdmark: pop af  
4bb5			endm  
# End of macro DMARK
4bb5						CALLMONITOR 
4bb5 cd 9e 19			call break_point_state  
4bb8				endm  
# End of macro CALLMONITOR
4bb8					endif 
4bb8 cd d7 20				call forth_push_str 
4bbb					NEXTW 
4bbb c3 16 24			jp macro_next 
4bbe				endm 
# End of macro NEXTW
4bbe			 
4bbe			.EDIT: 
4bbe				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4bbe 40				db WORD_SYS_CORE+44             
4bbf 60 4c			dw .DEDIT            
4bc1 05				db 4 + 1 
4bc2 .. 00			db "EDIT",0              
4bc7				endm 
# End of macro CWHEAD
4bc7			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4bc7			 
4bc7					; TODO does not copy from stack 
4bc7					if DEBUG_FORTH_WORDS_KEY 
4bc7						DMARK "EDT" 
4bc7 f5				push af  
4bc8 3a dc 4b			ld a, (.dmark)  
4bcb 32 6e fe			ld (debug_mark),a  
4bce 3a dd 4b			ld a, (.dmark+1)  
4bd1 32 6f fe			ld (debug_mark+1),a  
4bd4 3a de 4b			ld a, (.dmark+2)  
4bd7 32 70 fe			ld (debug_mark+2),a  
4bda 18 03			jr .pastdmark  
4bdc ..			.dmark: db "EDT"  
4bdf f1			.pastdmark: pop af  
4be0			endm  
# End of macro DMARK
4be0						CALLMONITOR 
4be0 cd 9e 19			call break_point_state  
4be3				endm  
# End of macro CALLMONITOR
4be3					endif 
4be3			 
4be3					;FORTH_DSP 
4be3					FORTH_DSP_VALUEHL 
4be3 cd 60 22			call macro_dsp_valuehl 
4be6				endm 
# End of macro FORTH_DSP_VALUEHL
4be6			;		inc hl    ; TODO do type check 
4be6			 
4be6			;		call get_word_hl 
4be6 e5					push hl 
4be7					if DEBUG_FORTH_WORDS 
4be7						DMARK "EDp" 
4be7 f5				push af  
4be8 3a fc 4b			ld a, (.dmark)  
4beb 32 6e fe			ld (debug_mark),a  
4bee 3a fd 4b			ld a, (.dmark+1)  
4bf1 32 6f fe			ld (debug_mark+1),a  
4bf4 3a fe 4b			ld a, (.dmark+2)  
4bf7 32 70 fe			ld (debug_mark+2),a  
4bfa 18 03			jr .pastdmark  
4bfc ..			.dmark: db "EDp"  
4bff f1			.pastdmark: pop af  
4c00			endm  
# End of macro DMARK
4c00						CALLMONITOR 
4c00 cd 9e 19			call break_point_state  
4c03				endm  
# End of macro CALLMONITOR
4c03					endif 
4c03				;	ld a, 0 
4c03 cd aa 13				call strlenz 
4c06 23					inc hl 
4c07			 
4c07 06 00				ld b, 0 
4c09 4d					ld c, l 
4c0a			 
4c0a e1					pop hl 
4c0b 11 c6 f3				ld de, os_input 
4c0e					if DEBUG_FORTH_WORDS_KEY 
4c0e						DMARK "EDc" 
4c0e f5				push af  
4c0f 3a 23 4c			ld a, (.dmark)  
4c12 32 6e fe			ld (debug_mark),a  
4c15 3a 24 4c			ld a, (.dmark+1)  
4c18 32 6f fe			ld (debug_mark+1),a  
4c1b 3a 25 4c			ld a, (.dmark+2)  
4c1e 32 70 fe			ld (debug_mark+2),a  
4c21 18 03			jr .pastdmark  
4c23 ..			.dmark: db "EDc"  
4c26 f1			.pastdmark: pop af  
4c27			endm  
# End of macro DMARK
4c27						CALLMONITOR 
4c27 cd 9e 19			call break_point_state  
4c2a				endm  
# End of macro CALLMONITOR
4c2a					endif 
4c2a ed b0				ldir 
4c2c			 
4c2c			 
4c2c 21 c6 f3				ld hl, os_input 
4c2f					;ld a, 0 
4c2f					;ld (hl),a 
4c2f 3a 65 fa				ld a,(f_cursor_ptr) 
4c32 16 64				ld d, 100 
4c34 0e 00				ld c, 0 
4c36 1e 28				ld e, 40 
4c38 cd 79 0f				call input_str 
4c3b					; TODO perhaps do a type check and wrap in quotes if not a number 
4c3b 21 c6 f3				ld hl, os_input 
4c3e					if DEBUG_FORTH_WORDS 
4c3e						DMARK "ED1" 
4c3e f5				push af  
4c3f 3a 53 4c			ld a, (.dmark)  
4c42 32 6e fe			ld (debug_mark),a  
4c45 3a 54 4c			ld a, (.dmark+1)  
4c48 32 6f fe			ld (debug_mark+1),a  
4c4b 3a 55 4c			ld a, (.dmark+2)  
4c4e 32 70 fe			ld (debug_mark+2),a  
4c51 18 03			jr .pastdmark  
4c53 ..			.dmark: db "ED1"  
4c56 f1			.pastdmark: pop af  
4c57			endm  
# End of macro DMARK
4c57						CALLMONITOR 
4c57 cd 9e 19			call break_point_state  
4c5a				endm  
# End of macro CALLMONITOR
4c5a					endif 
4c5a cd d7 20				call forth_push_str 
4c5d					NEXTW 
4c5d c3 16 24			jp macro_next 
4c60				endm 
# End of macro NEXTW
4c60			 
4c60			.DEDIT: 
4c60				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4c60 40				db WORD_SYS_CORE+44             
4c61 c2 4c			dw .ENDKEY            
4c63 06				db 5 + 1 
4c64 .. 00			db "DEDIT",0              
4c6a				endm 
# End of macro CWHEAD
4c6a			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4c6a			 
4c6a					; TODO does not copy from stack 
4c6a					if DEBUG_FORTH_WORDS_KEY 
4c6a						DMARK "DED" 
4c6a f5				push af  
4c6b 3a 7f 4c			ld a, (.dmark)  
4c6e 32 6e fe			ld (debug_mark),a  
4c71 3a 80 4c			ld a, (.dmark+1)  
4c74 32 6f fe			ld (debug_mark+1),a  
4c77 3a 81 4c			ld a, (.dmark+2)  
4c7a 32 70 fe			ld (debug_mark+2),a  
4c7d 18 03			jr .pastdmark  
4c7f ..			.dmark: db "DED"  
4c82 f1			.pastdmark: pop af  
4c83			endm  
# End of macro DMARK
4c83						CALLMONITOR 
4c83 cd 9e 19			call break_point_state  
4c86				endm  
# End of macro CALLMONITOR
4c86					endif 
4c86			 
4c86					;FORTH_DSP 
4c86					FORTH_DSP_VALUEHL 
4c86 cd 60 22			call macro_dsp_valuehl 
4c89				endm 
# End of macro FORTH_DSP_VALUEHL
4c89			;		inc hl    ; TODO do type check 
4c89			 
4c89			;		call get_word_hl 
4c89 e5					push hl 
4c8a e5					push hl 
4c8b					FORTH_DSP_POP 
4c8b cd 18 23			call macro_forth_dsp_pop 
4c8e				endm 
# End of macro FORTH_DSP_POP
4c8e e1					pop hl 
4c8f					if DEBUG_FORTH_WORDS 
4c8f						DMARK "EDp" 
4c8f f5				push af  
4c90 3a a4 4c			ld a, (.dmark)  
4c93 32 6e fe			ld (debug_mark),a  
4c96 3a a5 4c			ld a, (.dmark+1)  
4c99 32 6f fe			ld (debug_mark+1),a  
4c9c 3a a6 4c			ld a, (.dmark+2)  
4c9f 32 70 fe			ld (debug_mark+2),a  
4ca2 18 03			jr .pastdmark  
4ca4 ..			.dmark: db "EDp"  
4ca7 f1			.pastdmark: pop af  
4ca8			endm  
# End of macro DMARK
4ca8						CALLMONITOR 
4ca8 cd 9e 19			call break_point_state  
4cab				endm  
# End of macro CALLMONITOR
4cab					endif 
4cab				;	ld a, 0 
4cab cd aa 13				call strlenz 
4cae 23					inc hl 
4caf			 
4caf 06 00				ld b, 0 
4cb1 4d					ld c, l 
4cb2			 
4cb2 e1					pop hl 
4cb3			 
4cb3					;ld a, 0 
4cb3					;ld (hl),a 
4cb3 3a 65 fa				ld a,(f_cursor_ptr) 
4cb6 16 64				ld d, 100 
4cb8 0e 00				ld c, 0 
4cba 1e 28				ld e, 40 
4cbc cd 79 0f				call input_str 
4cbf					; TODO perhaps do a type check and wrap in quotes if not a number 
4cbf					NEXTW 
4cbf c3 16 24			jp macro_next 
4cc2				endm 
# End of macro NEXTW
4cc2			 
4cc2			 
4cc2			.ENDKEY: 
4cc2			; eof 
4cc2			 
# End of file forth_words_key.asm
4cc2			include "forth_words_const.asm" 
4cc2			 
4cc2			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4cc2			 
4cc2			 
4cc2			.SPITIME: 
4cc2				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4cc2 77				db WORD_SYS_CORE+99             
4cc3 d7 4c			dw .VA            
4cc5 08				db 7 + 1 
4cc6 .. 00			db "SPITIME",0              
4cce				endm 
# End of macro CWHEAD
4cce			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4cce			; 
4cce			; | If using BANK devices then leave as is. 
4cce			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4cce			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4cce			 
4cce 21 6b fa				ld hl, spi_clktime  
4cd1 cd 69 20				call forth_push_numhl 
4cd4			 
4cd4					NEXTW 
4cd4 c3 16 24			jp macro_next 
4cd7				endm 
# End of macro NEXTW
4cd7			 
4cd7			 
4cd7			.VA: 
4cd7				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4cd7 77				db WORD_SYS_CORE+99             
4cd8 e7 4c			dw .SYMBOL            
4cda 03				db 2 + 1 
4cdb .. 00			db "VA",0              
4cde				endm 
# End of macro CWHEAD
4cde			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4cde 21 2f fa				ld hl, cli_var_array 
4ce1 cd 69 20				call forth_push_numhl 
4ce4			 
4ce4					NEXTW 
4ce4 c3 16 24			jp macro_next 
4ce7				endm 
# End of macro NEXTW
4ce7			 
4ce7			.SYMBOL: 
4ce7				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4ce7 77				db WORD_SYS_CORE+99             
4ce8 1f 4e			dw .ENDCONST            
4cea 07				db 6 + 1 
4ceb .. 00			db "SYMBOL",0              
4cf2				endm 
# End of macro CWHEAD
4cf2			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4cf2			; | 
4cf2			; | The value is the number reference and the final address is pushed to stack 
4cf2			 
4cf2					if DEBUG_FORTH_WORDS_KEY 
4cf2						DMARK "SYM" 
4cf2 f5				push af  
4cf3 3a 07 4d			ld a, (.dmark)  
4cf6 32 6e fe			ld (debug_mark),a  
4cf9 3a 08 4d			ld a, (.dmark+1)  
4cfc 32 6f fe			ld (debug_mark+1),a  
4cff 3a 09 4d			ld a, (.dmark+2)  
4d02 32 70 fe			ld (debug_mark+2),a  
4d05 18 03			jr .pastdmark  
4d07 ..			.dmark: db "SYM"  
4d0a f1			.pastdmark: pop af  
4d0b			endm  
# End of macro DMARK
4d0b						CALLMONITOR 
4d0b cd 9e 19			call break_point_state  
4d0e				endm  
# End of macro CALLMONITOR
4d0e					endif 
4d0e			 
4d0e					FORTH_DSP_VALUEHL 
4d0e cd 60 22			call macro_dsp_valuehl 
4d11				endm 
# End of macro FORTH_DSP_VALUEHL
4d11			 
4d11 7d					ld a, l     
4d12			 
4d12			 
4d12					if DEBUG_FORTH_WORDS 
4d12						DMARK "SY1" 
4d12 f5				push af  
4d13 3a 27 4d			ld a, (.dmark)  
4d16 32 6e fe			ld (debug_mark),a  
4d19 3a 28 4d			ld a, (.dmark+1)  
4d1c 32 6f fe			ld (debug_mark+1),a  
4d1f 3a 29 4d			ld a, (.dmark+2)  
4d22 32 70 fe			ld (debug_mark+2),a  
4d25 18 03			jr .pastdmark  
4d27 ..			.dmark: db "SY1"  
4d2a f1			.pastdmark: pop af  
4d2b			endm  
# End of macro DMARK
4d2b						CALLMONITOR 
4d2b cd 9e 19			call break_point_state  
4d2e				endm  
# End of macro CALLMONITOR
4d2e					endif 
4d2e					 
4d2e f5					push af	 
4d2f					FORTH_DSP_POP 
4d2f cd 18 23			call macro_forth_dsp_pop 
4d32				endm 
# End of macro FORTH_DSP_POP
4d32 f1					pop af 
4d33			 
4d33 cb 27				sla a  
4d35				 
4d35					 
4d35					if DEBUG_FORTH_WORDS 
4d35						DMARK "SY" 
4d35 f5				push af  
4d36 3a 4a 4d			ld a, (.dmark)  
4d39 32 6e fe			ld (debug_mark),a  
4d3c 3a 4b 4d			ld a, (.dmark+1)  
4d3f 32 6f fe			ld (debug_mark+1),a  
4d42 3a 4c 4d			ld a, (.dmark+2)  
4d45 32 70 fe			ld (debug_mark+2),a  
4d48 18 02			jr .pastdmark  
4d4a ..			.dmark: db "SY"  
4d4c f1			.pastdmark: pop af  
4d4d			endm  
# End of macro DMARK
4d4d						CALLMONITOR 
4d4d cd 9e 19			call break_point_state  
4d50				endm  
# End of macro CALLMONITOR
4d50					endif 
4d50			 
4d50 21 5f 4d				ld hl, sym_table 
4d53 cd 4c 0f				call addatohl 
4d56 cd 98 23				call loadwordinhl 
4d59 cd 69 20				call forth_push_numhl 
4d5c			 
4d5c			 
4d5c				       NEXTW 
4d5c c3 16 24			jp macro_next 
4d5f				endm 
# End of macro NEXTW
4d5f			 
4d5f			sym_table: 
4d5f			 
4d5f			; 0 
4d5f 43 fa		dw cli_autodisplay 
4d61 51 fa		dw cli_buffer 
4d63 f5 f9		dw cli_data_sp 
4d65 2f f7		dw cli_data_stack 
4d67 4b fa		dw cli_execword 
4d69 f7 f9		dw cli_loop_sp 
4d6b 31 f9		dw cli_loop_stack 
4d6d 44 fa		dw cli_mvdot 
4d6f 49 fa		dw cli_nextword 
4d71 45 fa		dw cli_origptr 
4d73 4f fa		dw cli_origtoken 
4d75			; 11 
4d75 47 fa		dw cli_ptr 
4d77 f9 f9		dw cli_ret_sp 
4d79 b3 f9		dw cli_ret_stack 
4d7b 4d fa		dw cli_token 
4d7d 2f fa		dw cli_var_array 
4d7f cb fb		dw cursor_col 
4d81 c9 fb		dw cursor_ptr 
4d83 ca fb		dw cursor_row 
4d85 c7 fb		dw cursor_shape 
4d87 6e fe		dw debug_mark 
4d89			; 21 
4d89 b4 fd		dw display_fb0 
4d8b 13 fd		dw display_fb1 
4d8d d1 fb		dw display_fb2 
4d8f 72 fc		dw display_fb3 
4d91 cf fb		dw display_fb_active 
4d93 c7 f2		dw execscratch 
4d95 65 fa		dw f_cursor_ptr 
4d97 72 fe		dw hardware_word 
4d99 65 fe		dw input_at_cursor 
4d9b 67 fe		dw input_at_pos 
4d9d			; 31 
4d9d 63 fe		dw input_cur_flash 
4d9f 62 fe		dw input_cur_onoff 
4da1 58 fe		dw input_cursor 
4da3 68 fe		dw input_display_size 
4da5 5d fe		dw input_len 
4da7 6c fe		dw input_ptr 
4da9 69 fe		dw input_size 
4dab 6a fe		dw input_start 
4dad 79 0f		dw input_str 
4daf 66 fe		dw input_under_cursor 
4db1			; 41 
4db1 57 fe		dw key_actual_pressed 
4db3 82 fe		dw key_fa 
4db5 7e fe		dw key_face_held 
4db7 81 fe		dw key_fb 
4db9 80 fe		dw key_fc 
4dbb 7f fe		dw key_fd 
4dbd 88 fe		dw key_held 
4dbf 87 fe		dw key_held_prev 
4dc1 ce 76		dw key_init 
4dc3 83 fe		dw key_repeat_ct 
4dc5			; 51 
4dc5 05 00		dw key_rows 
4dc7 55 fe		dw key_shift 
4dc9 56 fe		dw key_symbol 
4dcb 89 fe		dw keyscan_scancol 
4dcd 93 fe		dw keyscan_table 
4dcf f2 fe		dw keyscan_table_row1 
4dd1 e7 fe		dw keyscan_table_row2 
4dd3 dc fe		dw keyscan_table_row3 
4dd5 d1 fe		dw keyscan_table_row4 
4dd7 c6 fe		dw keyscan_table_row5 
4dd9			; 61 
4dd9 ef f4		dw os_cli_cmd 
4ddb eb f4		dw os_cur_ptr 
4ddd ed f4		dw os_current_i 
4ddf c6 f3		dw os_input 
4de1 ee f5		dw os_last_cmd 
4de3 c5 f4		dw os_last_new_uword 
4de5 b9 f1		dw os_view_disable 
4de7 b5 f1		dw os_view_hl 
4de9 cd f4		dw os_word_scratch 
4deb c3 00		dw portbctl 
4ded			; 71 
4ded c1 00		dw portbdata 
4def 6a fa		dw spi_cartdev 
4df1 69 fa		dw spi_cartdev2 
4df3 6b fa		dw spi_clktime 
4df5 67 fa		dw spi_device 
4df7 66 fa		dw spi_device_id 
4df9 68 fa		dw spi_portbyte 
4dfb ad fb		dw stackstore 
4dfd			if STORAGE_SE 
4dfd 82 00		dw storage_actl 
4dff 80 00		dw storage_adata 
4e01			else 
4e01			dw 0 
4e01			dw 0 
4e01			endif 
4e01			; 81 
4e01 0c 0b		dw storage_append 
4e03			if STORAGE_SE 
4e03 83 00		dw storage_bctl 
4e05			else 
4e05			dw 0 
4e05			endif 
4e05 99 fb		dw store_bank_active 
4e07 6e fa		dw store_filecache 
4e09 7c fa		dw store_longread 
4e0b 72 fa		dw store_openaddr 
4e0d 71 fa		dw store_openext 
4e0f 70 fa		dw store_openmaxext 
4e11 81 fa		dw store_page 
4e13 7d fa		dw store_readbuf 
4e15			; 91 
4e15 74 fa		dw store_readcont 
4e17 7f fa		dw store_readptr 
4e19 74 fa		dw store_tmpext 
4e1b 75 fa		dw store_tmpid 
4e1d 6c fa		dw store_tmppageid 
4e1f			 
4e1f			 
4e1f			.ENDCONST: 
4e1f			 
4e1f			; eof 
4e1f			 
4e1f			 
# End of file forth_words_const.asm
4e1f			 
4e1f			if STORAGE_SE 
4e1f			   	include "forth_words_storage.asm" 
4e1f			 
4e1f			; | ## Fixed Storage Words 
4e1f			 
4e1f			.RENAME: 
4e1f			  
4e1f				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4e1f 3a				db WORD_SYS_CORE+38             
4e20 15 4f			dw .RECORD            
4e22 07				db 6 + 1 
4e23 .. 00			db "RENAME",0              
4e2a				endm 
# End of macro CWHEAD
4e2a			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4e2a			; | | Compatible with PicoSPINet  
4e2a					if DEBUG_FORTH_WORDS_KEY 
4e2a						DMARK "REN" 
4e2a f5				push af  
4e2b 3a 3f 4e			ld a, (.dmark)  
4e2e 32 6e fe			ld (debug_mark),a  
4e31 3a 40 4e			ld a, (.dmark+1)  
4e34 32 6f fe			ld (debug_mark+1),a  
4e37 3a 41 4e			ld a, (.dmark+2)  
4e3a 32 70 fe			ld (debug_mark+2),a  
4e3d 18 03			jr .pastdmark  
4e3f ..			.dmark: db "REN"  
4e42 f1			.pastdmark: pop af  
4e43			endm  
# End of macro DMARK
4e43						CALLMONITOR 
4e43 cd 9e 19			call break_point_state  
4e46				endm  
# End of macro CALLMONITOR
4e46					endif 
4e46			 
4e46			 
4e46					; preserve some internal vars used by other file handing routines 
4e46			 
4e46 2a 72 fa				ld hl, (store_openaddr) 
4e49 e5					push hl 
4e4a 3a 74 fa				ld a, (store_readcont) 
4e4d f5					push af 
4e4e			 
4e4e					FORTH_DSP_VALUEHL 
4e4e cd 60 22			call macro_dsp_valuehl 
4e51				endm 
# End of macro FORTH_DSP_VALUEHL
4e51			 
4e51					; move ext and id around for the file header 
4e51			 
4e51 65					ld h, l 
4e52 2e 00				ld l, 0 
4e54			 
4e54 e5					push hl    ; id 
4e55			 
4e55					FORTH_DSP_POP 
4e55 cd 18 23			call macro_forth_dsp_pop 
4e58				endm 
# End of macro FORTH_DSP_POP
4e58			 
4e58					; Locate the file header 
4e58			 
4e58 e1					pop hl 
4e59 e5					push hl 
4e5a 11 81 fa				ld de, store_page      ; get block zero of file 
4e5d					if DEBUG_FORTH_WORDS 
4e5d						DMARK "REr" 
4e5d f5				push af  
4e5e 3a 72 4e			ld a, (.dmark)  
4e61 32 6e fe			ld (debug_mark),a  
4e64 3a 73 4e			ld a, (.dmark+1)  
4e67 32 6f fe			ld (debug_mark+1),a  
4e6a 3a 74 4e			ld a, (.dmark+2)  
4e6d 32 70 fe			ld (debug_mark+2),a  
4e70 18 03			jr .pastdmark  
4e72 ..			.dmark: db "REr"  
4e75 f1			.pastdmark: pop af  
4e76			endm  
# End of macro DMARK
4e76						CALLMONITOR 
4e76 cd 9e 19			call break_point_state  
4e79				endm  
# End of macro CALLMONITOR
4e79					endif 
4e79 cd 75 09				call storage_read 
4e7c			 
4e7c cd 75 0f			call ishlzero 
4e7f 20 05			jr nz, .rnfound 
4e81			 
4e81				; file does not exist so indicate with 255 extents in use 
4e81			 
4e81 3e ff			ld a, 255 
4e83 e1				pop hl ; clear dup hl 
4e84 18 7b			jr .skiprneof 
4e86			 
4e86			 
4e86			.rnfound: 
4e86					; file found so rename 
4e86			 
4e86					FORTH_DSP_VALUEHL 
4e86 cd 60 22			call macro_dsp_valuehl 
4e89				endm 
# End of macro FORTH_DSP_VALUEHL
4e89			 
4e89 e5				push hl 
4e8a 3e 00			ld a, 0 
4e8c cd b5 13			call strlent 
4e8f 23				inc hl   ; cover zero term 
4e90 06 00			ld b,0 
4e92 4d				ld c,l 
4e93 e1				pop hl 
4e94 11 84 fa				ld de, store_page + 3 
4e97 ed b0				ldir 
4e99			 
4e99 11 81 fa				ld de, store_page 
4e9c					if DEBUG_FORTH_WORDS 
4e9c						DMARK "RER" 
4e9c f5				push af  
4e9d 3a b1 4e			ld a, (.dmark)  
4ea0 32 6e fe			ld (debug_mark),a  
4ea3 3a b2 4e			ld a, (.dmark+1)  
4ea6 32 6f fe			ld (debug_mark+1),a  
4ea9 3a b3 4e			ld a, (.dmark+2)  
4eac 32 70 fe			ld (debug_mark+2),a  
4eaf 18 03			jr .pastdmark  
4eb1 ..			.dmark: db "RER"  
4eb4 f1			.pastdmark: pop af  
4eb5			endm  
# End of macro DMARK
4eb5						CALLMONITOR 
4eb5 cd 9e 19			call break_point_state  
4eb8				endm  
# End of macro CALLMONITOR
4eb8					endif 
4eb8			 
4eb8 e1					pop hl    ; get orig file id and mangle it for find id 
4eb9 55					ld d, l 
4eba 5c					ld e, h 
4ebb			 
4ebb 21 00 00				ld hl, 0 
4ebe					if DEBUG_FORTH_WORDS 
4ebe						DMARK "REf" 
4ebe f5				push af  
4ebf 3a d3 4e			ld a, (.dmark)  
4ec2 32 6e fe			ld (debug_mark),a  
4ec5 3a d4 4e			ld a, (.dmark+1)  
4ec8 32 6f fe			ld (debug_mark+1),a  
4ecb 3a d5 4e			ld a, (.dmark+2)  
4ece 32 70 fe			ld (debug_mark+2),a  
4ed1 18 03			jr .pastdmark  
4ed3 ..			.dmark: db "REf"  
4ed6 f1			.pastdmark: pop af  
4ed7			endm  
# End of macro DMARK
4ed7						CALLMONITOR 
4ed7 cd 9e 19			call break_point_state  
4eda				endm  
# End of macro CALLMONITOR
4eda					endif 
4eda cd 4f 07				call storage_findnextid 
4edd 11 81 fa				ld de, store_page 
4ee0					if DEBUG_FORTH_WORDS 
4ee0						DMARK "REw" 
4ee0 f5				push af  
4ee1 3a f5 4e			ld a, (.dmark)  
4ee4 32 6e fe			ld (debug_mark),a  
4ee7 3a f6 4e			ld a, (.dmark+1)  
4eea 32 6f fe			ld (debug_mark+1),a  
4eed 3a f7 4e			ld a, (.dmark+2)  
4ef0 32 70 fe			ld (debug_mark+2),a  
4ef3 18 03			jr .pastdmark  
4ef5 ..			.dmark: db "REw"  
4ef8 f1			.pastdmark: pop af  
4ef9			endm  
# End of macro DMARK
4ef9						CALLMONITOR 
4ef9 cd 9e 19			call break_point_state  
4efc				endm  
# End of macro CALLMONITOR
4efc					endif 
4efc cd 81 04				call storage_write_block 
4eff			 
4eff 3e 00				ld a, 0 
4f01			.skiprneof: 
4f01					; drop file name 
4f01					FORTH_DSP_POP 
4f01 cd 18 23			call macro_forth_dsp_pop 
4f04				endm 
# End of macro FORTH_DSP_POP
4f04			 
4f04 6f					ld l, a 
4f05 26 00				ld h, 0 
4f07 cd 69 20				call forth_push_numhl 
4f0a			 
4f0a			 
4f0a f1					pop af 
4f0b 32 74 fa				ld (store_readcont),a 
4f0e e1					pop hl 
4f0f 22 72 fa				ld (store_openaddr), hl 
4f12						 
4f12				NEXTW 
4f12 c3 16 24			jp macro_next 
4f15				endm 
# End of macro NEXTW
4f15			.RECORD: 
4f15			  
4f15				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4f15 3a				db WORD_SYS_CORE+38             
4f16 b9 4f			dw .BREAD            
4f18 07				db 6 + 1 
4f19 .. 00			db "RECORD",0              
4f20				endm 
# End of macro CWHEAD
4f20			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4f20			; | | Compatible with PicoSPINet  
4f20			 
4f20					if DEBUG_FORTH_WORDS_KEY 
4f20						DMARK "REC" 
4f20 f5				push af  
4f21 3a 35 4f			ld a, (.dmark)  
4f24 32 6e fe			ld (debug_mark),a  
4f27 3a 36 4f			ld a, (.dmark+1)  
4f2a 32 6f fe			ld (debug_mark+1),a  
4f2d 3a 37 4f			ld a, (.dmark+2)  
4f30 32 70 fe			ld (debug_mark+2),a  
4f33 18 03			jr .pastdmark  
4f35 ..			.dmark: db "REC"  
4f38 f1			.pastdmark: pop af  
4f39			endm  
# End of macro DMARK
4f39						CALLMONITOR 
4f39 cd 9e 19			call break_point_state  
4f3c				endm  
# End of macro CALLMONITOR
4f3c					endif 
4f3c			 
4f3c					FORTH_DSP_VALUEHL 
4f3c cd 60 22			call macro_dsp_valuehl 
4f3f				endm 
# End of macro FORTH_DSP_VALUEHL
4f3f			 
4f3f e5					push hl    ; id 
4f40			 
4f40					FORTH_DSP_POP 
4f40 cd 18 23			call macro_forth_dsp_pop 
4f43				endm 
# End of macro FORTH_DSP_POP
4f43			 
4f43					FORTH_DSP_VALUEHL 
4f43 cd 60 22			call macro_dsp_valuehl 
4f46				endm 
# End of macro FORTH_DSP_VALUEHL
4f46			 
4f46					FORTH_DSP_POP 
4f46 cd 18 23			call macro_forth_dsp_pop 
4f49				endm 
# End of macro FORTH_DSP_POP
4f49			 
4f49 d1					pop de     ; get file id 
4f4a			 
4f4a					; e = file id 
4f4a					; l = file extent 
4f4a			 
4f4a			 
4f4a					; construct request to access file extent 
4f4a			 
4f4a			;		ld a, e 
4f4a 63					ld h, e 
4f4b					 
4f4b					 
4f4b					 
4f4b			 
4f4b					; e has id 
4f4b			 
4f4b 11 81 fa			ld de, store_page 
4f4e					if DEBUG_FORTH_WORDS 
4f4e						DMARK "REr" 
4f4e f5				push af  
4f4f 3a 63 4f			ld a, (.dmark)  
4f52 32 6e fe			ld (debug_mark),a  
4f55 3a 64 4f			ld a, (.dmark+1)  
4f58 32 6f fe			ld (debug_mark+1),a  
4f5b 3a 65 4f			ld a, (.dmark+2)  
4f5e 32 70 fe			ld (debug_mark+2),a  
4f61 18 03			jr .pastdmark  
4f63 ..			.dmark: db "REr"  
4f66 f1			.pastdmark: pop af  
4f67			endm  
# End of macro DMARK
4f67						CALLMONITOR 
4f67 cd 9e 19			call break_point_state  
4f6a				endm  
# End of macro CALLMONITOR
4f6a					endif 
4f6a cd 75 09				call storage_read 
4f6d cd 75 0f			call ishlzero 
4f70 28 22			jr z, .recnotfound 
4f72			 
4f72			 
4f72					if DEBUG_FORTH_WORDS 
4f72						DMARK "REe" 
4f72 f5				push af  
4f73 3a 87 4f			ld a, (.dmark)  
4f76 32 6e fe			ld (debug_mark),a  
4f79 3a 88 4f			ld a, (.dmark+1)  
4f7c 32 6f fe			ld (debug_mark+1),a  
4f7f 3a 89 4f			ld a, (.dmark+2)  
4f82 32 70 fe			ld (debug_mark+2),a  
4f85 18 03			jr .pastdmark  
4f87 ..			.dmark: db "REe"  
4f8a f1			.pastdmark: pop af  
4f8b			endm  
# End of macro DMARK
4f8b						CALLMONITOR 
4f8b cd 9e 19			call break_point_state  
4f8e				endm  
# End of macro CALLMONITOR
4f8e					endif 
4f8e cd d7 20			call forth_push_str 
4f91			 
4f91					NEXTW 
4f91 c3 16 24			jp macro_next 
4f94				endm 
# End of macro NEXTW
4f94			 
4f94			.recnotfound: 
4f94					if DEBUG_FORTH_WORDS 
4f94						DMARK "REf" 
4f94 f5				push af  
4f95 3a a9 4f			ld a, (.dmark)  
4f98 32 6e fe			ld (debug_mark),a  
4f9b 3a aa 4f			ld a, (.dmark+1)  
4f9e 32 6f fe			ld (debug_mark+1),a  
4fa1 3a ab 4f			ld a, (.dmark+2)  
4fa4 32 70 fe			ld (debug_mark+2),a  
4fa7 18 03			jr .pastdmark  
4fa9 ..			.dmark: db "REf"  
4fac f1			.pastdmark: pop af  
4fad			endm  
# End of macro DMARK
4fad						CALLMONITOR 
4fad cd 9e 19			call break_point_state  
4fb0				endm  
# End of macro CALLMONITOR
4fb0					endif 
4fb0 21 ff 00			ld hl, 255 
4fb3 cd 69 20			call forth_push_numhl 
4fb6				NEXTW 
4fb6 c3 16 24			jp macro_next 
4fb9				endm 
# End of macro NEXTW
4fb9			 
4fb9			 
4fb9			.BREAD: 
4fb9			  
4fb9				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4fb9 3a				db WORD_SYS_CORE+38             
4fba 3c 50			dw .BWRITE            
4fbc 06				db 5 + 1 
4fbd .. 00			db "BREAD",0              
4fc3				endm 
# End of macro CWHEAD
4fc3			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
4fc3			; | | Compatible with PicoSPINet  
4fc3				 
4fc3					if DEBUG_FORTH_WORDS_KEY 
4fc3						DMARK "BRD" 
4fc3 f5				push af  
4fc4 3a d8 4f			ld a, (.dmark)  
4fc7 32 6e fe			ld (debug_mark),a  
4fca 3a d9 4f			ld a, (.dmark+1)  
4fcd 32 6f fe			ld (debug_mark+1),a  
4fd0 3a da 4f			ld a, (.dmark+2)  
4fd3 32 70 fe			ld (debug_mark+2),a  
4fd6 18 03			jr .pastdmark  
4fd8 ..			.dmark: db "BRD"  
4fdb f1			.pastdmark: pop af  
4fdc			endm  
# End of macro DMARK
4fdc						CALLMONITOR 
4fdc cd 9e 19			call break_point_state  
4fdf				endm  
# End of macro CALLMONITOR
4fdf					endif 
4fdf			 
4fdf				FORTH_DSP_VALUEHL 
4fdf cd 60 22			call macro_dsp_valuehl 
4fe2				endm 
# End of macro FORTH_DSP_VALUEHL
4fe2			 
4fe2				FORTH_DSP_POP 
4fe2 cd 18 23			call macro_forth_dsp_pop 
4fe5				endm 
# End of macro FORTH_DSP_POP
4fe5			 
4fe5				; calc block address 
4fe5			 
4fe5 eb				ex de, hl 
4fe6 3e 40			ld a, STORE_BLOCK_PHY 
4fe8 cd cf 0e			call Mult16 
4feb			 
4feb			 
4feb 11 81 fa			ld de, store_page 
4fee			 
4fee					if DEBUG_FORTH_WORDS 
4fee						DMARK "BR1" 
4fee f5				push af  
4fef 3a 03 50			ld a, (.dmark)  
4ff2 32 6e fe			ld (debug_mark),a  
4ff5 3a 04 50			ld a, (.dmark+1)  
4ff8 32 6f fe			ld (debug_mark+1),a  
4ffb 3a 05 50			ld a, (.dmark+2)  
4ffe 32 70 fe			ld (debug_mark+2),a  
5001 18 03			jr .pastdmark  
5003 ..			.dmark: db "BR1"  
5006 f1			.pastdmark: pop af  
5007			endm  
# End of macro DMARK
5007						CALLMONITOR 
5007 cd 9e 19			call break_point_state  
500a				endm  
# End of macro CALLMONITOR
500a					endif 
500a			 
500a cd 1c 04			call storage_read_block 
500d			 
500d cd 75 0f			call ishlzero 
5010 20 05			jr nz, .brfound 
5012			 
5012 cd 69 20			call forth_push_numhl 
5015 18 22			jr .brdone 
5017			 
5017			 
5017			.brfound: 
5017 21 83 fa		        ld hl, store_page+2 
501a			 
501a					if DEBUG_FORTH_WORDS 
501a						DMARK "BR2" 
501a f5				push af  
501b 3a 2f 50			ld a, (.dmark)  
501e 32 6e fe			ld (debug_mark),a  
5021 3a 30 50			ld a, (.dmark+1)  
5024 32 6f fe			ld (debug_mark+1),a  
5027 3a 31 50			ld a, (.dmark+2)  
502a 32 70 fe			ld (debug_mark+2),a  
502d 18 03			jr .pastdmark  
502f ..			.dmark: db "BR2"  
5032 f1			.pastdmark: pop af  
5033			endm  
# End of macro DMARK
5033						CALLMONITOR 
5033 cd 9e 19			call break_point_state  
5036				endm  
# End of macro CALLMONITOR
5036					endif 
5036			 
5036 cd d7 20			call forth_push_str 
5039			 
5039			 
5039			.brdone: 
5039			 
5039					NEXTW 
5039 c3 16 24			jp macro_next 
503c				endm 
# End of macro NEXTW
503c			.BWRITE: 
503c				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
503c 3a				db WORD_SYS_CORE+38             
503d d1 50			dw .BUPD            
503f 07				db 6 + 1 
5040 .. 00			db "BWRITE",0              
5047				endm 
# End of macro CWHEAD
5047			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5047			; | | Compatible with PicoSPINet  
5047			 
5047					if DEBUG_FORTH_WORDS_KEY 
5047						DMARK "BWR" 
5047 f5				push af  
5048 3a 5c 50			ld a, (.dmark)  
504b 32 6e fe			ld (debug_mark),a  
504e 3a 5d 50			ld a, (.dmark+1)  
5051 32 6f fe			ld (debug_mark+1),a  
5054 3a 5e 50			ld a, (.dmark+2)  
5057 32 70 fe			ld (debug_mark+2),a  
505a 18 03			jr .pastdmark  
505c ..			.dmark: db "BWR"  
505f f1			.pastdmark: pop af  
5060			endm  
# End of macro DMARK
5060						CALLMONITOR 
5060 cd 9e 19			call break_point_state  
5063				endm  
# End of macro CALLMONITOR
5063					endif 
5063			 
5063				FORTH_DSP_VALUEHL 
5063 cd 60 22			call macro_dsp_valuehl 
5066				endm 
# End of macro FORTH_DSP_VALUEHL
5066			 
5066				; calc block address 
5066			 
5066 eb				ex de, hl 
5067 3e 40			ld a, STORE_BLOCK_PHY 
5069 cd cf 0e			call Mult16 
506c			 
506c e5				push hl         ; address 
506d			 
506d				FORTH_DSP_POP 
506d cd 18 23			call macro_forth_dsp_pop 
5070				endm 
# End of macro FORTH_DSP_POP
5070			 
5070				FORTH_DSP_VALUEHL 
5070 cd 60 22			call macro_dsp_valuehl 
5073				endm 
# End of macro FORTH_DSP_VALUEHL
5073			 
5073				FORTH_DSP_POP 
5073 cd 18 23			call macro_forth_dsp_pop 
5076				endm 
# End of macro FORTH_DSP_POP
5076			 
5076 cd 58 0c			call storage_clear_page 
5079			 
5079				; copy string to store page 
5079			 
5079 e5				push hl     ; save string address 
507a			 
507a 3e 00			ld a, 0 
507c cd b5 13			call strlent 
507f			 
507f 23				inc hl 
5080			 
5080 4d				ld c, l 
5081 06 00			ld b, 0 
5083			 
5083 e1				pop hl 
5084 11 83 fa			ld de, store_page + 2 
5087					if DEBUG_FORTH_WORDS 
5087						DMARK "BW1" 
5087 f5				push af  
5088 3a 9c 50			ld a, (.dmark)  
508b 32 6e fe			ld (debug_mark),a  
508e 3a 9d 50			ld a, (.dmark+1)  
5091 32 6f fe			ld (debug_mark+1),a  
5094 3a 9e 50			ld a, (.dmark+2)  
5097 32 70 fe			ld (debug_mark+2),a  
509a 18 03			jr .pastdmark  
509c ..			.dmark: db "BW1"  
509f f1			.pastdmark: pop af  
50a0			endm  
# End of macro DMARK
50a0						CALLMONITOR 
50a0 cd 9e 19			call break_point_state  
50a3				endm  
# End of macro CALLMONITOR
50a3					endif 
50a3 ed b0			ldir 
50a5			 
50a5			 
50a5				; poke the start of the block with flags to prevent high level file ops hitting the block 
50a5			 
50a5 21 ff ff			ld hl, $ffff 
50a8			 
50a8 22 81 fa			ld (store_page), hl	 
50ab				 
50ab e1				pop hl    ; get address 
50ac 11 81 fa			ld de, store_page 
50af			 
50af					if DEBUG_FORTH_WORDS 
50af						DMARK "BW2" 
50af f5				push af  
50b0 3a c4 50			ld a, (.dmark)  
50b3 32 6e fe			ld (debug_mark),a  
50b6 3a c5 50			ld a, (.dmark+1)  
50b9 32 6f fe			ld (debug_mark+1),a  
50bc 3a c6 50			ld a, (.dmark+2)  
50bf 32 70 fe			ld (debug_mark+2),a  
50c2 18 03			jr .pastdmark  
50c4 ..			.dmark: db "BW2"  
50c7 f1			.pastdmark: pop af  
50c8			endm  
# End of macro DMARK
50c8						CALLMONITOR 
50c8 cd 9e 19			call break_point_state  
50cb				endm  
# End of macro CALLMONITOR
50cb					endif 
50cb			 
50cb cd 81 04			call storage_write_block 
50ce			 
50ce					NEXTW 
50ce c3 16 24			jp macro_next 
50d1				endm 
# End of macro NEXTW
50d1			 
50d1			.BUPD: 
50d1				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
50d1 3a				db WORD_SYS_CORE+38             
50d2 27 51			dw .BYID            
50d4 05				db 4 + 1 
50d5 .. 00			db "BUPD",0              
50da				endm 
# End of macro CWHEAD
50da			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
50da			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
50da			; | | or completely different file system structure. 
50da			; | | Compatible with PicoSPINet  
50da			 
50da					if DEBUG_FORTH_WORDS_KEY 
50da						DMARK "BUD" 
50da f5				push af  
50db 3a ef 50			ld a, (.dmark)  
50de 32 6e fe			ld (debug_mark),a  
50e1 3a f0 50			ld a, (.dmark+1)  
50e4 32 6f fe			ld (debug_mark+1),a  
50e7 3a f1 50			ld a, (.dmark+2)  
50ea 32 70 fe			ld (debug_mark+2),a  
50ed 18 03			jr .pastdmark  
50ef ..			.dmark: db "BUD"  
50f2 f1			.pastdmark: pop af  
50f3			endm  
# End of macro DMARK
50f3						CALLMONITOR 
50f3 cd 9e 19			call break_point_state  
50f6				endm  
# End of macro CALLMONITOR
50f6					endif 
50f6			 
50f6				FORTH_DSP_VALUEHL 
50f6 cd 60 22			call macro_dsp_valuehl 
50f9				endm 
# End of macro FORTH_DSP_VALUEHL
50f9			 
50f9				; calc block address 
50f9			 
50f9 eb				ex de, hl 
50fa 3e 40			ld a, STORE_BLOCK_PHY 
50fc cd cf 0e			call Mult16 
50ff			 
50ff				FORTH_DSP_POP 
50ff cd 18 23			call macro_forth_dsp_pop 
5102				endm 
# End of macro FORTH_DSP_POP
5102			 
5102			 
5102 11 81 fa			ld de, store_page 
5105			 
5105					if DEBUG_FORTH_WORDS 
5105						DMARK "BUe" 
5105 f5				push af  
5106 3a 1a 51			ld a, (.dmark)  
5109 32 6e fe			ld (debug_mark),a  
510c 3a 1b 51			ld a, (.dmark+1)  
510f 32 6f fe			ld (debug_mark+1),a  
5112 3a 1c 51			ld a, (.dmark+2)  
5115 32 70 fe			ld (debug_mark+2),a  
5118 18 03			jr .pastdmark  
511a ..			.dmark: db "BUe"  
511d f1			.pastdmark: pop af  
511e			endm  
# End of macro DMARK
511e						CALLMONITOR 
511e cd 9e 19			call break_point_state  
5121				endm  
# End of macro CALLMONITOR
5121					endif 
5121			 
5121 cd 81 04			call storage_write_block 
5124			 
5124					NEXTW 
5124 c3 16 24			jp macro_next 
5127				endm 
# End of macro NEXTW
5127			 
5127			.BYID: 
5127			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5127			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5127			; 
5127			;		 
5127			;		if DEBUG_FORTH_WORDS_KEY 
5127			;			DMARK "BYID" 
5127			;			CALLMONITOR 
5127			;		endif 
5127			; 
5127			;		; get direct address 
5127			; 
5127			;		FORTH_DSP_VALUEHL 
5127			; 
5127			;		FORTH_DSP_POP 
5127			; 
5127			;	; calc block address 
5127			; 
5127			;	ex de, hl 
5127			;	ld a, STORE_BLOCK_PHY 
5127			;	call Mult16 
5127			;	;	do BREAD with number as param 
5127			;	; push the file name	 
5127			;	ld de, store_page 
5127			;	call storage_read_block 
5127			 ;       ld hl, store_page+2 
5127			; 
5127			; 
5127			;		NEXTW 
5127			;.BYNAME: 
5127				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5127 3a				db WORD_SYS_CORE+38             
5128 40 51			dw .DIR            
512a 06				db 5 + 1 
512b .. 00			db "GETID",0              
5131				endm 
# End of macro CWHEAD
5131			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
5131			; | | Compatible with PicoSPINet  
5131			 
5131					; get pointer to file name to seek 
5131			 
5131					FORTH_DSP_VALUEHL 
5131 cd 60 22			call macro_dsp_valuehl 
5134				endm 
# End of macro FORTH_DSP_VALUEHL
5134			 
5134			 
5134 cd 43 03				call storage_getid  
5137			 
5137					FORTH_DSP_POP 
5137 cd 18 23			call macro_forth_dsp_pop 
513a				endm 
# End of macro FORTH_DSP_POP
513a			 
513a cd 69 20				call forth_push_numhl 
513d			 
513d					NEXTW 
513d c3 16 24			jp macro_next 
5140				endm 
# End of macro NEXTW
5140			; 
5140			.DIR: 
5140				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
5140 3a				db WORD_SYS_CORE+38             
5141 44 52			dw .SAVE            
5143 04				db 3 + 1 
5144 .. 00			db "DIR",0              
5148				endm 
# End of macro CWHEAD
5148			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5148			; | | Compatible with PicoSPINet  
5148			 
5148					if DEBUG_FORTH_WORDS_KEY 
5148						DMARK "DIR" 
5148 f5				push af  
5149 3a 5d 51			ld a, (.dmark)  
514c 32 6e fe			ld (debug_mark),a  
514f 3a 5e 51			ld a, (.dmark+1)  
5152 32 6f fe			ld (debug_mark+1),a  
5155 3a 5f 51			ld a, (.dmark+2)  
5158 32 70 fe			ld (debug_mark+2),a  
515b 18 03			jr .pastdmark  
515d ..			.dmark: db "DIR"  
5160 f1			.pastdmark: pop af  
5161			endm  
# End of macro DMARK
5161						CALLMONITOR 
5161 cd 9e 19			call break_point_state  
5164				endm  
# End of macro CALLMONITOR
5164					endif 
5164 cd cd 04			call storage_get_block_0 
5167			 
5167 21 81 fa			ld hl, store_page     ; get current id count 
516a 46				ld b, (hl) 
516b 0e 00			ld c, 0    ; count of files   
516d					if DEBUG_FORTH_WORDS 
516d						DMARK "DI1" 
516d f5				push af  
516e 3a 82 51			ld a, (.dmark)  
5171 32 6e fe			ld (debug_mark),a  
5174 3a 83 51			ld a, (.dmark+1)  
5177 32 6f fe			ld (debug_mark+1),a  
517a 3a 84 51			ld a, (.dmark+2)  
517d 32 70 fe			ld (debug_mark+2),a  
5180 18 03			jr .pastdmark  
5182 ..			.dmark: db "DI1"  
5185 f1			.pastdmark: pop af  
5186			endm  
# End of macro DMARK
5186						CALLMONITOR 
5186 cd 9e 19			call break_point_state  
5189				endm  
# End of macro CALLMONITOR
5189					endif 
5189			 
5189				; check for empty drive 
5189			 
5189 3e 00			ld a, 0 
518b b8				cp b 
518c ca fa 51			jp z, .dirdone 
518f			 
518f				; for each of the current ids do a search for them and if found push to stack 
518f			 
518f c5			.diritem:	push bc 
5190 21 40 00				ld hl, STORE_BLOCK_PHY 
5193 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5195 58					ld e,b 
5196			 
5196			;		if DEBUG_FORTH_WORDS 
5196			;			DMARK "DI2" 
5196			;			CALLMONITOR 
5196			;		endif 
5196			 
5196 cd 4f 07				call storage_findnextid 
5199			 
5199			;		if DEBUG_FORTH_WORDS 
5199			;			DMARK "DI3" 
5199			;			CALLMONITOR 
5199			;		endif 
5199			 
5199					; if found hl will be non zero 
5199			 
5199 cd 75 0f				call ishlzero 
519c			;		ld a, l 
519c			;		add h 
519c			; 
519c			;		cp 0 
519c 28 59				jr z, .dirnotfound 
519e			 
519e					; increase count 
519e			 
519e c1					pop bc	 
519f 0c					inc c 
51a0 c5					push bc 
51a1					 
51a1			 
51a1					; get file header and push the file name 
51a1			 
51a1 11 81 fa				ld de, store_page 
51a4 cd 1c 04				call storage_read_block 
51a7			 
51a7					; push file id to stack 
51a7				 
51a7 3a 81 fa				ld a, (store_page) 
51aa 26 00				ld h, 0 
51ac 6f					ld l, a 
51ad cd 69 20				call forth_push_numhl 
51b0			 
51b0					; push extent count to stack  
51b0				 
51b0 3a 83 fa				ld a, (store_page+2) 
51b3 26 00				ld h, 0 
51b5 6f					ld l, a 
51b6 cd 69 20				call forth_push_numhl 
51b9			 
51b9					; push file name 
51b9			 
51b9 21 84 fa				ld hl, store_page+3 
51bc					if DEBUG_FORTH_WORDS 
51bc						DMARK "DI5" 
51bc f5				push af  
51bd 3a d1 51			ld a, (.dmark)  
51c0 32 6e fe			ld (debug_mark),a  
51c3 3a d2 51			ld a, (.dmark+1)  
51c6 32 6f fe			ld (debug_mark+1),a  
51c9 3a d3 51			ld a, (.dmark+2)  
51cc 32 70 fe			ld (debug_mark+2),a  
51cf 18 03			jr .pastdmark  
51d1 ..			.dmark: db "DI5"  
51d4 f1			.pastdmark: pop af  
51d5			endm  
# End of macro DMARK
51d5						CALLMONITOR 
51d5 cd 9e 19			call break_point_state  
51d8				endm  
# End of macro CALLMONITOR
51d8					endif 
51d8 cd d7 20				call forth_push_str 
51db					if DEBUG_FORTH_WORDS 
51db						DMARK "DI6" 
51db f5				push af  
51dc 3a f0 51			ld a, (.dmark)  
51df 32 6e fe			ld (debug_mark),a  
51e2 3a f1 51			ld a, (.dmark+1)  
51e5 32 6f fe			ld (debug_mark+1),a  
51e8 3a f2 51			ld a, (.dmark+2)  
51eb 32 70 fe			ld (debug_mark+2),a  
51ee 18 03			jr .pastdmark  
51f0 ..			.dmark: db "DI6"  
51f3 f1			.pastdmark: pop af  
51f4			endm  
# End of macro DMARK
51f4						CALLMONITOR 
51f4 cd 9e 19			call break_point_state  
51f7				endm  
# End of macro CALLMONITOR
51f7					endif 
51f7			.dirnotfound: 
51f7 c1					pop bc     
51f8 10 95				djnz .diritem 
51fa				 
51fa			.dirdone:	 
51fa					if DEBUG_FORTH_WORDS 
51fa						DMARK "DI7" 
51fa f5				push af  
51fb 3a 0f 52			ld a, (.dmark)  
51fe 32 6e fe			ld (debug_mark),a  
5201 3a 10 52			ld a, (.dmark+1)  
5204 32 6f fe			ld (debug_mark+1),a  
5207 3a 11 52			ld a, (.dmark+2)  
520a 32 70 fe			ld (debug_mark+2),a  
520d 18 03			jr .pastdmark  
520f ..			.dmark: db "DI7"  
5212 f1			.pastdmark: pop af  
5213			endm  
# End of macro DMARK
5213						CALLMONITOR 
5213 cd 9e 19			call break_point_state  
5216				endm  
# End of macro CALLMONITOR
5216					endif 
5216			 
5216					; push a count of the dir items found 
5216			 
5216 26 00				ld h, 0 
5218 69					ld l, c 
5219 cd 69 20				call forth_push_numhl 
521c			 
521c					; push the bank label 
521c			 
521c cd cd 04				call storage_get_block_0 
521f			 
521f				 
521f 21 84 fa		 		ld hl, store_page+3 
5222			 
5222					if DEBUG_FORTH_WORDS 
5222						DMARK "DI8" 
5222 f5				push af  
5223 3a 37 52			ld a, (.dmark)  
5226 32 6e fe			ld (debug_mark),a  
5229 3a 38 52			ld a, (.dmark+1)  
522c 32 6f fe			ld (debug_mark+1),a  
522f 3a 39 52			ld a, (.dmark+2)  
5232 32 70 fe			ld (debug_mark+2),a  
5235 18 03			jr .pastdmark  
5237 ..			.dmark: db "DI8"  
523a f1			.pastdmark: pop af  
523b			endm  
# End of macro DMARK
523b						CALLMONITOR 
523b cd 9e 19			call break_point_state  
523e				endm  
# End of macro CALLMONITOR
523e					endif 
523e cd d7 20				call forth_push_str 
5241			 
5241			 
5241				 
5241					NEXTW 
5241 c3 16 24			jp macro_next 
5244				endm 
# End of macro NEXTW
5244			.SAVE: 
5244			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5244			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5244			;		NEXTW 
5244			;.LOAD: 
5244			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5244			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5244			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5244			;; > > The LOAD command can not be used in any user words or compound lines. 
5244			; 
5244			;		; store_openext use it. If zero it is EOF 
5244			; 
5244			;		; read block from current stream id 
5244			;		; if the block does not contain zero term keep reading blocks until zero found 
5244			;		; push the block to stack 
5244			;		; save the block id to stream 
5244			; 
5244			; 
5244			;		FORTH_DSP_VALUEHL 
5244			; 
5244			;;		push hl 
5244			; 
5244			;	if DEBUG_STORESE 
5244			;		DMARK "LOA" 
5244			;		CALLMONITOR 
5244			;	endif 
5244			;		FORTH_DSP_POP 
5244			; 
5244			;;		pop hl 
5244			; 
5244			;		ld h, l 
5244			;		ld l, 0 
5244			; 
5244			;		push hl     ; stack holds current file id and extent to work with 
5244			; 
5244			; 
5244			;		ld de, store_page      ; get block zero of file 
5244			;	if DEBUG_STORESE 
5244			;		DMARK "LO0" 
5244			;		CALLMONITOR 
5244			;	endif 
5244			;		call storage_read 
5244			; 
5244			;		ld a, (store_page+2)    ; max extents for this file 
5244			;		ld  (store_openmaxext),a   ; get our limit 
5244			; 
5244			;	if DEBUG_STORESE 
5244			;		DMARK "LOE" 
5244			;		CALLMONITOR 
5244			;	endif 
5244			; 
5244			;; TODO dont know why max extents are not present 
5244			;;		cp 0 
5244			;;		jp z, .loadeof     ; dont read past eof 
5244			; 
5244			;;		ld a, 1   ; start from the head of the file 
5244			; 
5244			;.loadline:	pop hl 
5244			;		inc hl 
5244			;		ld  a, (store_openmaxext)   ; get our limit 
5244			;	if DEBUG_STORESE 
5244			;		DMARK "LOx" 
5244			;		CALLMONITOR 
5244			;	endif 
5244			;		inc a 
5244			;		cp l 
5244			;		jp z, .loadeof 
5244			;		push hl    ; save current extent 
5244			; 
5244			;		ld de, store_page 
5244			; 
5244			;	if DEBUG_STORESE 
5244			;		DMARK "LO1" 
5244			;		CALLMONITOR 
5244			;	endif 
5244			;		call storage_read 
5244			; 
5244			;	if DEBUG_STORESE 
5244			;		DMARK "LO2" 
5244			;		CALLMONITOR 
5244			;	endif 
5244			;	call ishlzero 
5244			;	ld a, l 
5244			;	add h 
5244			;	cp 0 
5244			;	jr z, .loadeof 
5244			; 
5244			;	; not eof so hl should point to data to exec 
5244			; 
5244			;	; will need to add the FORTH_END_BUFFER flag 
5244			 ; 
5244			;	ld hl, store_page+2 
5244			;	ld bc, 255 
5244			;	ld a, 0 
5244			;	cpir 
5244			;	if DEBUG_STORESE 
5244			;		DMARK "LOt" 
5244			;		CALLMONITOR 
5244			;	endif 
5244			;	dec hl 
5244			;	ld a, ' ' 
5244			;	ld (hl), a 
5244			;	inc hl 
5244			;	ld (hl), a 
5244			;	inc hl 
5244			;	ld (hl), a 
5244			;	inc hl 
5244			;	ld a, FORTH_END_BUFFER 
5244			;	ld (hl), a 
5244			; 
5244			;	; TODO handle more than a single block read 
5244			; 
5244			; 
5244			;	ld hl, store_page+2 
5244			; 
5244			;	ld (os_tok_ptr), hl 
5244			; 
5244			;	if DEBUG_STORESE 
5244			;		DMARK "LO3" 
5244			;		CALLMONITOR 
5244			;	endif 
5244			; 
5244			;	call forthparse 
5244			;	call forthexec 
5244			;	call forthexec_cleanup 
5244			; 
5244			;	; go to next extent 
5244			; 
5244			;	; get next block  or mark as eof 
5244			;	jp .loadline 
5244			; 
5244			; 
5244			; 
5244			;	       NEXTW 
5244			;.loadeof:	ld a, 0 
5244			;		ld (store_openext), a 
5244			; 
5244			;	if DEBUG_STORESE 
5244			;		DMARK "LOF" 
5244			;		CALLMONITOR 
5244			;	endif 
5244			;		ret 
5244			;		;NEXTW 
5244			;.BSAVE:   
5244			; 
5244			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5244			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5244			;		NEXTW 
5244			;.BLOAD: 
5244			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5244			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5244			;		NEXTW 
5244			;;;; counter gap 
5244			 
5244			 
5244			.SEO: 
5244				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5244 64				db WORD_SYS_CORE+80             
5245 63 52			dw .SEI            
5247 04				db 3 + 1 
5248 .. 00			db "SEO",0              
524c				endm 
# End of macro CWHEAD
524c			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
524c			 
524c					; get port 
524c			 
524c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
524c cd 60 22			call macro_dsp_valuehl 
524f				endm 
# End of macro FORTH_DSP_VALUEHL
524f			 
524f e5					push hl    ; u2 - byte 
5250			 
5250					; destroy value TOS 
5250			 
5250					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5250 cd 18 23			call macro_forth_dsp_pop 
5253				endm 
# End of macro FORTH_DSP_POP
5253			 
5253					; get byte to send 
5253			 
5253					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5253 cd 60 22			call macro_dsp_valuehl 
5256				endm 
# End of macro FORTH_DSP_VALUEHL
5256			 
5256 e5					push hl    ; u1 - addr 
5257			 
5257					; destroy value TOS 
5257			 
5257					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5257 cd 18 23			call macro_forth_dsp_pop 
525a				endm 
# End of macro FORTH_DSP_POP
525a			 
525a					; one value on hl get other one back 
525a			 
525a d1					pop de   ; u1 - byte 
525b			 
525b e1					pop hl   ; u2 - addr 
525c			 
525c					; TODO Send SPI byte 
525c			 
525c			 
525c 7b					ld a, e 
525d cd 21 02				call se_writebyte 
5260			 
5260					 
5260			 
5260					NEXTW 
5260 c3 16 24			jp macro_next 
5263				endm 
# End of macro NEXTW
5263			 
5263			.SEI: 
5263				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5263 65				db WORD_SYS_CORE+81             
5264 7d 52			dw .SFREE            
5266 04				db 3 + 1 
5267 .. 00			db "SEI",0              
526b				endm 
# End of macro CWHEAD
526b			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
526b			 
526b					; get port 
526b			 
526b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
526b cd 60 22			call macro_dsp_valuehl 
526e				endm 
# End of macro FORTH_DSP_VALUEHL
526e			 
526e			;		push hl 
526e			 
526e					; destroy value TOS 
526e			 
526e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
526e cd 18 23			call macro_forth_dsp_pop 
5271				endm 
# End of macro FORTH_DSP_POP
5271			 
5271					; one value on hl get other one back 
5271			 
5271			;		pop hl 
5271			 
5271			 
5271					; TODO Get SPI byte 
5271			 
5271 cd c3 02				call se_readbyte 
5274			 
5274 26 00				ld h, 0 
5276 6f					ld l, a 
5277 cd 69 20				call forth_push_numhl 
527a			 
527a					NEXTW 
527a c3 16 24			jp macro_next 
527d				endm 
# End of macro NEXTW
527d			 
527d			.SFREE: 
527d				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
527d 67				db WORD_SYS_CORE+83             
527e ac 52			dw .SIZE            
5280 06				db 5 + 1 
5281 .. 00			db "FFREE",0              
5287				endm 
# End of macro CWHEAD
5287			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5287			; | | Compatible with PicoSPINet  
5287					if DEBUG_FORTH_WORDS_KEY 
5287						DMARK "FFR" 
5287 f5				push af  
5288 3a 9c 52			ld a, (.dmark)  
528b 32 6e fe			ld (debug_mark),a  
528e 3a 9d 52			ld a, (.dmark+1)  
5291 32 6f fe			ld (debug_mark+1),a  
5294 3a 9e 52			ld a, (.dmark+2)  
5297 32 70 fe			ld (debug_mark+2),a  
529a 18 03			jr .pastdmark  
529c ..			.dmark: db "FFR"  
529f f1			.pastdmark: pop af  
52a0			endm  
# End of macro DMARK
52a0						CALLMONITOR 
52a0 cd 9e 19			call break_point_state  
52a3				endm  
# End of macro CALLMONITOR
52a3					endif 
52a3			 
52a3 cd e9 07				call storage_freeblocks 
52a6			 
52a6 cd 69 20				call forth_push_numhl 
52a9			 
52a9				       NEXTW 
52a9 c3 16 24			jp macro_next 
52ac				endm 
# End of macro NEXTW
52ac			.SIZE: 
52ac				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
52ac 67				db WORD_SYS_CORE+83             
52ad e0 52			dw .CREATE            
52af 05				db 4 + 1 
52b0 .. 00			db "SIZE",0              
52b5				endm 
# End of macro CWHEAD
52b5			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
52b5			; | | Compatible with PicoSPINet  
52b5					if DEBUG_FORTH_WORDS_KEY 
52b5						DMARK "SIZ" 
52b5 f5				push af  
52b6 3a ca 52			ld a, (.dmark)  
52b9 32 6e fe			ld (debug_mark),a  
52bc 3a cb 52			ld a, (.dmark+1)  
52bf 32 6f fe			ld (debug_mark+1),a  
52c2 3a cc 52			ld a, (.dmark+2)  
52c5 32 70 fe			ld (debug_mark+2),a  
52c8 18 03			jr .pastdmark  
52ca ..			.dmark: db "SIZ"  
52cd f1			.pastdmark: pop af  
52ce			endm  
# End of macro DMARK
52ce						CALLMONITOR 
52ce cd 9e 19			call break_point_state  
52d1				endm  
# End of macro CALLMONITOR
52d1					endif 
52d1			 
52d1					FORTH_DSP_VALUEHL 
52d1 cd 60 22			call macro_dsp_valuehl 
52d4				endm 
# End of macro FORTH_DSP_VALUEHL
52d4			;		push hl 
52d4					FORTH_DSP_POP 
52d4 cd 18 23			call macro_forth_dsp_pop 
52d7				endm 
# End of macro FORTH_DSP_POP
52d7			;		pop hl 
52d7 cd 4b 04				call storage_file_size 
52da			 
52da cd 69 20				call forth_push_numhl 
52dd			  
52dd			 
52dd				       NEXTW 
52dd c3 16 24			jp macro_next 
52e0				endm 
# End of macro NEXTW
52e0			 
52e0			.CREATE: 
52e0				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
52e0 68				db WORD_SYS_CORE+84             
52e1 4e 53			dw .APPEND            
52e3 07				db 6 + 1 
52e4 .. 00			db "CREATE",0              
52eb				endm 
# End of macro CWHEAD
52eb			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
52eb			; | | e.g.  
52eb			; | | TestProgram CREATE 
52eb			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
52eb			; | |  
52eb			; | | Max file IDs are 255. 
52eb			; | |  
52eb			; | | Compatible with PicoSPINet  
52eb					 
52eb					if DEBUG_FORTH_WORDS_KEY 
52eb						DMARK "CRT" 
52eb f5				push af  
52ec 3a 00 53			ld a, (.dmark)  
52ef 32 6e fe			ld (debug_mark),a  
52f2 3a 01 53			ld a, (.dmark+1)  
52f5 32 6f fe			ld (debug_mark+1),a  
52f8 3a 02 53			ld a, (.dmark+2)  
52fb 32 70 fe			ld (debug_mark+2),a  
52fe 18 03			jr .pastdmark  
5300 ..			.dmark: db "CRT"  
5303 f1			.pastdmark: pop af  
5304			endm  
# End of macro DMARK
5304						CALLMONITOR 
5304 cd 9e 19			call break_point_state  
5307				endm  
# End of macro CALLMONITOR
5307					endif 
5307			;		call storage_get_block_0 
5307			 
5307					; TODO pop hl 
5307			 
5307					;v5 FORTH_DSP_VALUE 
5307					FORTH_DSP_VALUE 
5307 cd 49 22			call macro_forth_dsp_value 
530a				endm 
# End of macro FORTH_DSP_VALUE
530a			 
530a				if DEBUG_STORESE 
530a					DMARK "CR1" 
530a f5				push af  
530b 3a 1f 53			ld a, (.dmark)  
530e 32 6e fe			ld (debug_mark),a  
5311 3a 20 53			ld a, (.dmark+1)  
5314 32 6f fe			ld (debug_mark+1),a  
5317 3a 21 53			ld a, (.dmark+2)  
531a 32 70 fe			ld (debug_mark+2),a  
531d 18 03			jr .pastdmark  
531f ..			.dmark: db "CR1"  
5322 f1			.pastdmark: pop af  
5323			endm  
# End of macro DMARK
5323					CALLMONITOR 
5323 cd 9e 19			call break_point_state  
5326				endm  
# End of macro CALLMONITOR
5326				endif 
5326			;		push hl 
5326			;		FORTH_DSP_POP 
5326			;		pop hl 
5326			 
5326			;		inc hl   ; move past the type marker 
5326			 
5326 cd 1f 08				call storage_create 
5329			 
5329				if DEBUG_STORESE 
5329					DMARK "CT1" 
5329 f5				push af  
532a 3a 3e 53			ld a, (.dmark)  
532d 32 6e fe			ld (debug_mark),a  
5330 3a 3f 53			ld a, (.dmark+1)  
5333 32 6f fe			ld (debug_mark+1),a  
5336 3a 40 53			ld a, (.dmark+2)  
5339 32 70 fe			ld (debug_mark+2),a  
533c 18 03			jr .pastdmark  
533e ..			.dmark: db "CT1"  
5341 f1			.pastdmark: pop af  
5342			endm  
# End of macro DMARK
5342					CALLMONITOR 
5342 cd 9e 19			call break_point_state  
5345				endm  
# End of macro CALLMONITOR
5345				endif 
5345			;		push hl 
5345					FORTH_DSP_POP 
5345 cd 18 23			call macro_forth_dsp_pop 
5348				endm 
# End of macro FORTH_DSP_POP
5348			;		pop hl 
5348					; push file id to stack 
5348 cd 69 20				call forth_push_numhl 
534b			 
534b			 
534b			 
534b				       NEXTW 
534b c3 16 24			jp macro_next 
534e				endm 
# End of macro NEXTW
534e			 
534e			.APPEND: 
534e				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
534e 69				db WORD_SYS_CORE+85             
534f df 53			dw .SDEL            
5351 07				db 6 + 1 
5352 .. 00			db "APPEND",0              
5359				endm 
# End of macro CWHEAD
5359			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5359			; | | e.g. 
5359			; | | Test CREATE      -> $01 
5359			; | | "A string to add to file" $01 APPEND 
5359			; | |  
5359			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5359			; | | Compatible with PicoSPINet  
5359					if DEBUG_FORTH_WORDS_KEY 
5359						DMARK "APP" 
5359 f5				push af  
535a 3a 6e 53			ld a, (.dmark)  
535d 32 6e fe			ld (debug_mark),a  
5360 3a 6f 53			ld a, (.dmark+1)  
5363 32 6f fe			ld (debug_mark+1),a  
5366 3a 70 53			ld a, (.dmark+2)  
5369 32 70 fe			ld (debug_mark+2),a  
536c 18 03			jr .pastdmark  
536e ..			.dmark: db "APP"  
5371 f1			.pastdmark: pop af  
5372			endm  
# End of macro DMARK
5372						CALLMONITOR 
5372 cd 9e 19			call break_point_state  
5375				endm  
# End of macro CALLMONITOR
5375					endif 
5375			 
5375					FORTH_DSP_VALUEHL 
5375 cd 60 22			call macro_dsp_valuehl 
5378				endm 
# End of macro FORTH_DSP_VALUEHL
5378 e5					push hl 	; save file id 
5379			 
5379				if DEBUG_STORESE 
5379					DMARK "AP1" 
5379 f5				push af  
537a 3a 8e 53			ld a, (.dmark)  
537d 32 6e fe			ld (debug_mark),a  
5380 3a 8f 53			ld a, (.dmark+1)  
5383 32 6f fe			ld (debug_mark+1),a  
5386 3a 90 53			ld a, (.dmark+2)  
5389 32 70 fe			ld (debug_mark+2),a  
538c 18 03			jr .pastdmark  
538e ..			.dmark: db "AP1"  
5391 f1			.pastdmark: pop af  
5392			endm  
# End of macro DMARK
5392					CALLMONITOR 
5392 cd 9e 19			call break_point_state  
5395				endm  
# End of macro CALLMONITOR
5395				endif 
5395					FORTH_DSP_POP 
5395 cd 18 23			call macro_forth_dsp_pop 
5398				endm 
# End of macro FORTH_DSP_POP
5398			 
5398					FORTH_DSP_VALUEHL 
5398 cd 60 22			call macro_dsp_valuehl 
539b				endm 
# End of macro FORTH_DSP_VALUEHL
539b					;v5 FORTH_DSP_VALUE 
539b e5					push hl 	; save ptr to string to save 
539c			 
539c				if DEBUG_STORESE 
539c					DMARK "AP1" 
539c f5				push af  
539d 3a b1 53			ld a, (.dmark)  
53a0 32 6e fe			ld (debug_mark),a  
53a3 3a b2 53			ld a, (.dmark+1)  
53a6 32 6f fe			ld (debug_mark+1),a  
53a9 3a b3 53			ld a, (.dmark+2)  
53ac 32 70 fe			ld (debug_mark+2),a  
53af 18 03			jr .pastdmark  
53b1 ..			.dmark: db "AP1"  
53b4 f1			.pastdmark: pop af  
53b5			endm  
# End of macro DMARK
53b5					CALLMONITOR 
53b5 cd 9e 19			call break_point_state  
53b8				endm  
# End of macro CALLMONITOR
53b8				endif 
53b8					FORTH_DSP_POP 
53b8 cd 18 23			call macro_forth_dsp_pop 
53bb				endm 
# End of macro FORTH_DSP_POP
53bb			 
53bb d1					pop de 
53bc e1					pop hl 
53bd				if DEBUG_STORESE 
53bd					DMARK "AP2" 
53bd f5				push af  
53be 3a d2 53			ld a, (.dmark)  
53c1 32 6e fe			ld (debug_mark),a  
53c4 3a d3 53			ld a, (.dmark+1)  
53c7 32 6f fe			ld (debug_mark+1),a  
53ca 3a d4 53			ld a, (.dmark+2)  
53cd 32 70 fe			ld (debug_mark+2),a  
53d0 18 03			jr .pastdmark  
53d2 ..			.dmark: db "AP2"  
53d5 f1			.pastdmark: pop af  
53d6			endm  
# End of macro DMARK
53d6					CALLMONITOR 
53d6 cd 9e 19			call break_point_state  
53d9				endm  
# End of macro CALLMONITOR
53d9				endif 
53d9					;inc de ; skip var type indicator 
53d9			 
53d9					; TODO how to append numerics???? 
53d9			 
53d9 cd 0c 0b				call storage_append		 
53dc			 
53dc				       NEXTW 
53dc c3 16 24			jp macro_next 
53df				endm 
# End of macro NEXTW
53df			.SDEL: 
53df				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
53df 6a				db WORD_SYS_CORE+86             
53e0 2b 54			dw .OPEN            
53e2 05				db 4 + 1 
53e3 .. 00			db "ERA",0              
53e7				endm 
# End of macro CWHEAD
53e7			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
53e7			; | | Compatible with PicoSPINet  
53e7					FORTH_DSP_VALUEHL 
53e7 cd 60 22			call macro_dsp_valuehl 
53ea				endm 
# End of macro FORTH_DSP_VALUEHL
53ea			;		push hl 	; save file id 
53ea			 
53ea					if DEBUG_FORTH_WORDS_KEY 
53ea						DMARK "ERA" 
53ea f5				push af  
53eb 3a ff 53			ld a, (.dmark)  
53ee 32 6e fe			ld (debug_mark),a  
53f1 3a 00 54			ld a, (.dmark+1)  
53f4 32 6f fe			ld (debug_mark+1),a  
53f7 3a 01 54			ld a, (.dmark+2)  
53fa 32 70 fe			ld (debug_mark+2),a  
53fd 18 03			jr .pastdmark  
53ff ..			.dmark: db "ERA"  
5402 f1			.pastdmark: pop af  
5403			endm  
# End of macro DMARK
5403						CALLMONITOR 
5403 cd 9e 19			call break_point_state  
5406				endm  
# End of macro CALLMONITOR
5406					endif 
5406				if DEBUG_STORESE 
5406					DMARK "ER1" 
5406 f5				push af  
5407 3a 1b 54			ld a, (.dmark)  
540a 32 6e fe			ld (debug_mark),a  
540d 3a 1c 54			ld a, (.dmark+1)  
5410 32 6f fe			ld (debug_mark+1),a  
5413 3a 1d 54			ld a, (.dmark+2)  
5416 32 70 fe			ld (debug_mark+2),a  
5419 18 03			jr .pastdmark  
541b ..			.dmark: db "ER1"  
541e f1			.pastdmark: pop af  
541f			endm  
# End of macro DMARK
541f					CALLMONITOR 
541f cd 9e 19			call break_point_state  
5422				endm  
# End of macro CALLMONITOR
5422				endif 
5422					FORTH_DSP_POP 
5422 cd 18 23			call macro_forth_dsp_pop 
5425				endm 
# End of macro FORTH_DSP_POP
5425			 
5425			;		pop hl 
5425			 
5425 cd 5e 06				call storage_erase 
5428				       NEXTW 
5428 c3 16 24			jp macro_next 
542b				endm 
# End of macro NEXTW
542b			 
542b			.OPEN: 
542b				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
542b 6b				db WORD_SYS_CORE+87             
542c bf 54			dw .READ            
542e 05				db 4 + 1 
542f .. 00			db "OPEN",0              
5434				endm 
# End of macro CWHEAD
5434			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5434			; | | e.g. 
5434			; | | $01 OPEN $01 DO $01 READ . LOOP 
5434			; | | 
5434			; | | Will return with 255 blocks if the file does not exist 
5434			; | | Compatible with PicoSPINet  
5434			 
5434					if DEBUG_FORTH_WORDS_KEY 
5434						DMARK "OPN" 
5434 f5				push af  
5435 3a 49 54			ld a, (.dmark)  
5438 32 6e fe			ld (debug_mark),a  
543b 3a 4a 54			ld a, (.dmark+1)  
543e 32 6f fe			ld (debug_mark+1),a  
5441 3a 4b 54			ld a, (.dmark+2)  
5444 32 70 fe			ld (debug_mark+2),a  
5447 18 03			jr .pastdmark  
5449 ..			.dmark: db "OPN"  
544c f1			.pastdmark: pop af  
544d			endm  
# End of macro DMARK
544d						CALLMONITOR 
544d cd 9e 19			call break_point_state  
5450				endm  
# End of macro CALLMONITOR
5450					endif 
5450					; TODO handle multiple file opens 
5450			 
5450 3e 01			       	ld a, 1 
5452 32 71 fa				ld (store_openext), a 
5455			 
5455					; get max extents for this file 
5455				 
5455								 
5455					FORTH_DSP_VALUEHL 
5455 cd 60 22			call macro_dsp_valuehl 
5458				endm 
# End of macro FORTH_DSP_VALUEHL
5458			 
5458 65					ld h, l 
5459 2e 00				ld l, 0 
545b			 
545b					; store file id 
545b			 
545b 7c					ld a, h 
545c 32 6e fa				ld (store_filecache), a 
545f			 
545f				if DEBUG_STORESE 
545f					DMARK "OPN" 
545f f5				push af  
5460 3a 74 54			ld a, (.dmark)  
5463 32 6e fe			ld (debug_mark),a  
5466 3a 75 54			ld a, (.dmark+1)  
5469 32 6f fe			ld (debug_mark+1),a  
546c 3a 76 54			ld a, (.dmark+2)  
546f 32 70 fe			ld (debug_mark+2),a  
5472 18 03			jr .pastdmark  
5474 ..			.dmark: db "OPN"  
5477 f1			.pastdmark: pop af  
5478			endm  
# End of macro DMARK
5478					CALLMONITOR 
5478 cd 9e 19			call break_point_state  
547b				endm  
# End of macro CALLMONITOR
547b				endif 
547b			;		push hl 
547b					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
547b cd 18 23			call macro_forth_dsp_pop 
547e				endm 
# End of macro FORTH_DSP_POP
547e			;		pop hl 
547e						 
547e 11 81 fa				ld de, store_page      ; get block zero of file 
5481 cd 75 09				call storage_read 
5484 cd 75 0f			call ishlzero 
5487 20 04			jr nz, .opfound 
5489			 
5489				; file does not exist so indicate with 255 extents in use 
5489			 
5489 3e ff			ld a, 255 
548b 18 29			jr .skipopeneof 
548d			 
548d			 
548d			.opfound: 
548d			 
548d			 
548d 3a 83 fa				ld a, (store_page+2)    ; max extents for this file 
5490 32 70 fa				ld  (store_openmaxext), a   ; get our limit and push 
5493					 
5493				if DEBUG_STORESE 
5493					DMARK "OPx" 
5493 f5				push af  
5494 3a a8 54			ld a, (.dmark)  
5497 32 6e fe			ld (debug_mark),a  
549a 3a a9 54			ld a, (.dmark+1)  
549d 32 6f fe			ld (debug_mark+1),a  
54a0 3a aa 54			ld a, (.dmark+2)  
54a3 32 70 fe			ld (debug_mark+2),a  
54a6 18 03			jr .pastdmark  
54a8 ..			.dmark: db "OPx"  
54ab f1			.pastdmark: pop af  
54ac			endm  
# End of macro DMARK
54ac					CALLMONITOR 
54ac cd 9e 19			call break_point_state  
54af				endm  
# End of macro CALLMONITOR
54af				endif 
54af fe 00				cp 0 
54b1 20 03				jr nz, .skipopeneof 
54b3					; have opened an empty file 
54b3					 
54b3 32 71 fa				ld (store_openext), a 
54b6			 
54b6			.skipopeneof: 
54b6			 
54b6 6f					ld l, a 
54b7 26 00				ld h, 0 
54b9 cd 69 20				call forth_push_numhl 
54bc			 
54bc			 
54bc				       NEXTW 
54bc c3 16 24			jp macro_next 
54bf				endm 
# End of macro NEXTW
54bf			.READ: 
54bf				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
54bf 6c				db WORD_SYS_CORE+88             
54c0 e9 55			dw .EOF            
54c2 05				db 4 + 1 
54c3 .. 00			db "READ",0              
54c8				endm 
# End of macro CWHEAD
54c8			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
54c8			; | | e.g. 
54c8			; | | $01 OPEN $01 DO READ . LOOP 
54c8			; | | 
54c8			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
54c8			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
54c8			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
54c8			; | | two bytes contain the file id and extent. 
54c8			; | |  
54c8			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
54c8			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
54c8			; | | Compatible with PicoSPINet  
54c8			 
54c8					if DEBUG_FORTH_WORDS_KEY 
54c8						DMARK "REA" 
54c8 f5				push af  
54c9 3a dd 54			ld a, (.dmark)  
54cc 32 6e fe			ld (debug_mark),a  
54cf 3a de 54			ld a, (.dmark+1)  
54d2 32 6f fe			ld (debug_mark+1),a  
54d5 3a df 54			ld a, (.dmark+2)  
54d8 32 70 fe			ld (debug_mark+2),a  
54db 18 03			jr .pastdmark  
54dd ..			.dmark: db "REA"  
54e0 f1			.pastdmark: pop af  
54e1			endm  
# End of macro DMARK
54e1						CALLMONITOR 
54e1 cd 9e 19			call break_point_state  
54e4				endm  
# End of macro CALLMONITOR
54e4					endif 
54e4					; store_openext use it. If zero it is EOF 
54e4			 
54e4					; read block from current stream id 
54e4					; if the block does not contain zero term keep reading blocks until zero found 
54e4					; push the block to stack 
54e4					; save the block id to stream 
54e4			 
54e4			 
54e4 cd 16 56				call .testeof 
54e7 3e 01				ld a, 1 
54e9 bd					cp l 
54ea ca c5 55				jp z, .ateof 
54ed			 
54ed			 
54ed			;		FORTH_DSP_VALUEHL 
54ed			 
54ed			;		push hl 
54ed			 
54ed			;	if DEBUG_STORESE 
54ed			;		DMARK "REA" 
54ed			;		CALLMONITOR 
54ed			;	endif 
54ed			;		FORTH_DSP_POP 
54ed			 
54ed			;		pop hl 
54ed				 
54ed 3a 6e fa				ld a, (store_filecache) 
54f0 67					ld h,a 
54f1			 
54f1 3a 71 fa				ld a, (store_openext) 
54f4 6f					ld l, a 
54f5					 
54f5 fe 00				cp 0 
54f7 ca c5 55				jp z, .ateof     ; dont read past eof 
54fa			 
54fa cd 58 0c				call storage_clear_page 
54fd			 
54fd 11 81 fa				ld de, store_page 
5500				if DEBUG_STORESE 
5500					DMARK "RE1" 
5500 f5				push af  
5501 3a 15 55			ld a, (.dmark)  
5504 32 6e fe			ld (debug_mark),a  
5507 3a 16 55			ld a, (.dmark+1)  
550a 32 6f fe			ld (debug_mark+1),a  
550d 3a 17 55			ld a, (.dmark+2)  
5510 32 70 fe			ld (debug_mark+2),a  
5513 18 03			jr .pastdmark  
5515 ..			.dmark: db "RE1"  
5518 f1			.pastdmark: pop af  
5519			endm  
# End of macro DMARK
5519					CALLMONITOR 
5519 cd 9e 19			call break_point_state  
551c				endm  
# End of macro CALLMONITOR
551c				endif 
551c cd 75 09				call storage_read 
551f			 
551f				if DEBUG_STORESE 
551f					DMARK "RE2" 
551f f5				push af  
5520 3a 34 55			ld a, (.dmark)  
5523 32 6e fe			ld (debug_mark),a  
5526 3a 35 55			ld a, (.dmark+1)  
5529 32 6f fe			ld (debug_mark+1),a  
552c 3a 36 55			ld a, (.dmark+2)  
552f 32 70 fe			ld (debug_mark+2),a  
5532 18 03			jr .pastdmark  
5534 ..			.dmark: db "RE2"  
5537 f1			.pastdmark: pop af  
5538			endm  
# End of macro DMARK
5538					CALLMONITOR 
5538 cd 9e 19			call break_point_state  
553b				endm  
# End of macro CALLMONITOR
553b				endif 
553b cd 75 0f			call ishlzero 
553e			;	ld a, l 
553e			;	add h 
553e			;	cp 0 
553e ca c5 55			jp z, .readeof 
5541			 
5541				; not eof so hl should point to data to push to stack 
5541			 
5541				if DEBUG_STORESE 
5541					DMARK "RE3" 
5541 f5				push af  
5542 3a 56 55			ld a, (.dmark)  
5545 32 6e fe			ld (debug_mark),a  
5548 3a 57 55			ld a, (.dmark+1)  
554b 32 6f fe			ld (debug_mark+1),a  
554e 3a 58 55			ld a, (.dmark+2)  
5551 32 70 fe			ld (debug_mark+2),a  
5554 18 03			jr .pastdmark  
5556 ..			.dmark: db "RE3"  
5559 f1			.pastdmark: pop af  
555a			endm  
# End of macro DMARK
555a					CALLMONITOR 
555a cd 9e 19			call break_point_state  
555d				endm  
# End of macro CALLMONITOR
555d				endif 
555d cd d7 20			call forth_push_str 
5560			 
5560				if DEBUG_STORESE 
5560					DMARK "RE4" 
5560 f5				push af  
5561 3a 75 55			ld a, (.dmark)  
5564 32 6e fe			ld (debug_mark),a  
5567 3a 76 55			ld a, (.dmark+1)  
556a 32 6f fe			ld (debug_mark+1),a  
556d 3a 77 55			ld a, (.dmark+2)  
5570 32 70 fe			ld (debug_mark+2),a  
5573 18 03			jr .pastdmark  
5575 ..			.dmark: db "RE4"  
5578 f1			.pastdmark: pop af  
5579			endm  
# End of macro DMARK
5579					CALLMONITOR 
5579 cd 9e 19			call break_point_state  
557c				endm  
# End of macro CALLMONITOR
557c				endif 
557c				; get next block  or mark as eof 
557c			 
557c 3a 70 fa			ld a, (store_openmaxext)   ; get our limit 
557f 4f				ld c, a	 
5580 3a 71 fa			ld a, (store_openext) 
5583			 
5583				if DEBUG_STORESE 
5583					DMARK "RE5" 
5583 f5				push af  
5584 3a 98 55			ld a, (.dmark)  
5587 32 6e fe			ld (debug_mark),a  
558a 3a 99 55			ld a, (.dmark+1)  
558d 32 6f fe			ld (debug_mark+1),a  
5590 3a 9a 55			ld a, (.dmark+2)  
5593 32 70 fe			ld (debug_mark+2),a  
5596 18 03			jr .pastdmark  
5598 ..			.dmark: db "RE5"  
559b f1			.pastdmark: pop af  
559c			endm  
# End of macro DMARK
559c					CALLMONITOR 
559c cd 9e 19			call break_point_state  
559f				endm  
# End of macro CALLMONITOR
559f				endif 
559f b9				cp c 
55a0 28 23			jr z, .readeof     ; at last extent 
55a2			 
55a2 3c					inc a 
55a3 32 71 fa				ld (store_openext), a 
55a6			 
55a6				if DEBUG_STORESE 
55a6					DMARK "RE6" 
55a6 f5				push af  
55a7 3a bb 55			ld a, (.dmark)  
55aa 32 6e fe			ld (debug_mark),a  
55ad 3a bc 55			ld a, (.dmark+1)  
55b0 32 6f fe			ld (debug_mark+1),a  
55b3 3a bd 55			ld a, (.dmark+2)  
55b6 32 70 fe			ld (debug_mark+2),a  
55b9 18 03			jr .pastdmark  
55bb ..			.dmark: db "RE6"  
55be f1			.pastdmark: pop af  
55bf			endm  
# End of macro DMARK
55bf					CALLMONITOR 
55bf cd 9e 19			call break_point_state  
55c2				endm  
# End of macro CALLMONITOR
55c2				endif 
55c2			 
55c2			 
55c2				       NEXTW 
55c2 c3 16 24			jp macro_next 
55c5				endm 
# End of macro NEXTW
55c5			.ateof: 
55c5				;	ld hl, .showeof 
55c5				;	call forth_push_str 
55c5 3e 00		.readeof:	ld a, 0 
55c7 32 71 fa				ld (store_openext), a 
55ca			 
55ca					 
55ca				if DEBUG_STORESE 
55ca					DMARK "REF" 
55ca f5				push af  
55cb 3a df 55			ld a, (.dmark)  
55ce 32 6e fe			ld (debug_mark),a  
55d1 3a e0 55			ld a, (.dmark+1)  
55d4 32 6f fe			ld (debug_mark+1),a  
55d7 3a e1 55			ld a, (.dmark+2)  
55da 32 70 fe			ld (debug_mark+2),a  
55dd 18 03			jr .pastdmark  
55df ..			.dmark: db "REF"  
55e2 f1			.pastdmark: pop af  
55e3			endm  
# End of macro DMARK
55e3					CALLMONITOR 
55e3 cd 9e 19			call break_point_state  
55e6				endm  
# End of macro CALLMONITOR
55e6				endif 
55e6				       NEXTW 
55e6 c3 16 24			jp macro_next 
55e9				endm 
# End of macro NEXTW
55e9			 
55e9			;.showeof:   db "eof", 0 
55e9			 
55e9			 
55e9			.EOF: 
55e9				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
55e9 6d				db WORD_SYS_CORE+89             
55ea 2b 56			dw .FORMAT            
55ec 04				db 3 + 1 
55ed .. 00			db "EOF",0              
55f1				endm 
# End of macro CWHEAD
55f1			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
55f1			; | | e.g. 
55f1			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
55f1			; | | Compatible with PicoSPINet  
55f1					; TODO if current block id for stream is zero then push true else false 
55f1			 
55f1					if DEBUG_FORTH_WORDS_KEY 
55f1						DMARK "EOF" 
55f1 f5				push af  
55f2 3a 06 56			ld a, (.dmark)  
55f5 32 6e fe			ld (debug_mark),a  
55f8 3a 07 56			ld a, (.dmark+1)  
55fb 32 6f fe			ld (debug_mark+1),a  
55fe 3a 08 56			ld a, (.dmark+2)  
5601 32 70 fe			ld (debug_mark+2),a  
5604 18 03			jr .pastdmark  
5606 ..			.dmark: db "EOF"  
5609 f1			.pastdmark: pop af  
560a			endm  
# End of macro DMARK
560a						CALLMONITOR 
560a cd 9e 19			call break_point_state  
560d				endm  
# End of macro CALLMONITOR
560d					endif 
560d			 
560d					; TODO handlue multiple file streams 
560d			 
560d			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
560d cd 16 56				call .testeof 
5610 cd 69 20				call forth_push_numhl 
5613			 
5613			 
5613				       NEXTW 
5613 c3 16 24			jp macro_next 
5616				endm 
# End of macro NEXTW
5616			 
5616			.testeof: 
5616 2e 01				ld l, 1 
5618 3a 70 fa				ld a, (store_openmaxext) 
561b fe 00				cp 0 
561d 28 09				jr  z, .eofdone   ; empty file 
561f 3a 71 fa				ld a, (store_openext) 
5622 fe 00				cp 0 
5624 28 02				jr  z, .eofdone 
5626 2e 00				ld l, 0 
5628 26 00		.eofdone:	ld h, 0 
562a c9					ret 
562b			 
562b			 
562b			 
562b			 
562b			.FORMAT: 
562b				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
562b 6d				db WORD_SYS_CORE+89             
562c 7c 56			dw .LABEL            
562e 07				db 6 + 1 
562f .. 00			db "FORMAT",0              
5636				endm 
# End of macro CWHEAD
5636			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5636			; | | Compatible with PicoSPINet  
5636					; TODO if current block id for stream is zero then push true else false 
5636				 
5636				if DEBUG_STORESE 
5636					DMARK "FOR" 
5636 f5				push af  
5637 3a 4b 56			ld a, (.dmark)  
563a 32 6e fe			ld (debug_mark),a  
563d 3a 4c 56			ld a, (.dmark+1)  
5640 32 6f fe			ld (debug_mark+1),a  
5643 3a 4d 56			ld a, (.dmark+2)  
5646 32 70 fe			ld (debug_mark+2),a  
5649 18 03			jr .pastdmark  
564b ..			.dmark: db "FOR"  
564e f1			.pastdmark: pop af  
564f			endm  
# End of macro DMARK
564f					CALLMONITOR 
564f cd 9e 19			call break_point_state  
5652				endm  
# End of macro CALLMONITOR
5652				endif 
5652					; Wipes the bank check flags to cause a reformat on next block 0 read 
5652			 
5652 21 01 00				ld hl, 1 
5655 3e 00				ld a, 0 
5657 cd 21 02				call se_writebyte 
565a			 
565a				if DEBUG_STORESE 
565a					DMARK "FO0" 
565a f5				push af  
565b 3a 6f 56			ld a, (.dmark)  
565e 32 6e fe			ld (debug_mark),a  
5661 3a 70 56			ld a, (.dmark+1)  
5664 32 6f fe			ld (debug_mark+1),a  
5667 3a 71 56			ld a, (.dmark+2)  
566a 32 70 fe			ld (debug_mark+2),a  
566d 18 03			jr .pastdmark  
566f ..			.dmark: db "FO0"  
5672 f1			.pastdmark: pop af  
5673			endm  
# End of macro DMARK
5673					CALLMONITOR 
5673 cd 9e 19			call break_point_state  
5676				endm  
# End of macro CALLMONITOR
5676				endif 
5676					; force bank init 
5676			 
5676 cd cd 04				call storage_get_block_0 
5679					 
5679				       NEXTW 
5679 c3 16 24			jp macro_next 
567c				endm 
# End of macro NEXTW
567c			.LABEL: 
567c				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
567c 6d				db WORD_SYS_CORE+89             
567d ca 56			dw .STOREPAGE            
567f 06				db 5 + 1 
5680 .. 00			db "LABEL",0              
5686				endm 
# End of macro CWHEAD
5686			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5686			; | | Compatible with PicoSPINet  
5686					; TODO test to see if bank is selected 
5686				 
5686					if DEBUG_FORTH_WORDS_KEY 
5686						DMARK "LBL" 
5686 f5				push af  
5687 3a 9b 56			ld a, (.dmark)  
568a 32 6e fe			ld (debug_mark),a  
568d 3a 9c 56			ld a, (.dmark+1)  
5690 32 6f fe			ld (debug_mark+1),a  
5693 3a 9d 56			ld a, (.dmark+2)  
5696 32 70 fe			ld (debug_mark+2),a  
5699 18 03			jr .pastdmark  
569b ..			.dmark: db "LBL"  
569e f1			.pastdmark: pop af  
569f			endm  
# End of macro DMARK
569f						CALLMONITOR 
569f cd 9e 19			call break_point_state  
56a2				endm  
# End of macro CALLMONITOR
56a2					endif 
56a2			;	if DEBUG_STORESE 
56a2			;		DMARK "LBL" 
56a2			;		CALLMONITOR 
56a2			;	endif 
56a2					FORTH_DSP_VALUEHL 
56a2 cd 60 22			call macro_dsp_valuehl 
56a5				endm 
# End of macro FORTH_DSP_VALUEHL
56a5					;v5FORTH_DSP_VALUE 
56a5					 
56a5			;		push hl 
56a5					FORTH_DSP_POP 
56a5 cd 18 23			call macro_forth_dsp_pop 
56a8				endm 
# End of macro FORTH_DSP_POP
56a8			;		pop hl 
56a8			 
56a8			;v5		inc hl   ; move past the type marker 
56a8			 
56a8				if DEBUG_STORESE 
56a8					DMARK "LBl" 
56a8 f5				push af  
56a9 3a bd 56			ld a, (.dmark)  
56ac 32 6e fe			ld (debug_mark),a  
56af 3a be 56			ld a, (.dmark+1)  
56b2 32 6f fe			ld (debug_mark+1),a  
56b5 3a bf 56			ld a, (.dmark+2)  
56b8 32 70 fe			ld (debug_mark+2),a  
56bb 18 03			jr .pastdmark  
56bd ..			.dmark: db "LBl"  
56c0 f1			.pastdmark: pop af  
56c1			endm  
# End of macro DMARK
56c1					CALLMONITOR 
56c1 cd 9e 19			call break_point_state  
56c4				endm  
# End of macro CALLMONITOR
56c4				endif 
56c4 cd f1 05				call storage_label 
56c7			 
56c7				       NEXTW 
56c7 c3 16 24			jp macro_next 
56ca				endm 
# End of macro NEXTW
56ca			.STOREPAGE: 
56ca				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
56ca 6d				db WORD_SYS_CORE+89             
56cb fd 56			dw .LABELS            
56cd 0a				db 9 + 1 
56ce .. 00			db "STOREPAGE",0              
56d8				endm 
# End of macro CWHEAD
56d8			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
56d8			; | | Compatible with PicoSPINet  
56d8					; TODO test to see if bank is selected 
56d8				 
56d8					if DEBUG_FORTH_WORDS_KEY 
56d8						DMARK "STP" 
56d8 f5				push af  
56d9 3a ed 56			ld a, (.dmark)  
56dc 32 6e fe			ld (debug_mark),a  
56df 3a ee 56			ld a, (.dmark+1)  
56e2 32 6f fe			ld (debug_mark+1),a  
56e5 3a ef 56			ld a, (.dmark+2)  
56e8 32 70 fe			ld (debug_mark+2),a  
56eb 18 03			jr .pastdmark  
56ed ..			.dmark: db "STP"  
56f0 f1			.pastdmark: pop af  
56f1			endm  
# End of macro DMARK
56f1						CALLMONITOR 
56f1 cd 9e 19			call break_point_state  
56f4				endm  
# End of macro CALLMONITOR
56f4					endif 
56f4			;	if DEBUG_STORESE 
56f4			;		DMARK "STP" 
56f4			;		CALLMONITOR 
56f4			;	endif 
56f4			 
56f4 21 81 fa			ld hl, store_page 
56f7 cd 69 20			call forth_push_numhl 
56fa			 
56fa			 
56fa				       NEXTW 
56fa c3 16 24			jp macro_next 
56fd				endm 
# End of macro NEXTW
56fd			.LABELS: 
56fd				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
56fd 6d				db WORD_SYS_CORE+89             
56fe 87 57			dw .SCONST1            
5700 07				db 6 + 1 
5701 .. 00			db "LABELS",0              
5708				endm 
# End of macro CWHEAD
5708			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
5708			; | | *NOT* Compatible with PicoSPINet  
5708					;  
5708			 
5708					; save the current device selected to restore afterwards 
5708				 
5708 3a 67 fa				ld a, (spi_device) 
570b f5					push af 
570c			 
570c			 
570c					; run through each of the banks 
570c			 
570c 21 01 00				ld hl, 1 
570f cd 69 20				call forth_push_numhl 
5712 3e ff				ld a, SPI_CE_HIGH 
5714 cb 87				res SPI_CE0, a 
5716 32 67 fa				ld (spi_device), a 
5719 cd cd 04				call storage_get_block_0 
571c 21 84 fa				ld hl, store_page+3 
571f cd d7 20				call forth_push_str 
5722			 
5722					 
5722 21 02 00				ld hl, 2 
5725 cd 69 20				call forth_push_numhl 
5728 3e ff				ld a, SPI_CE_HIGH 
572a cb 8f				res SPI_CE1, a 
572c 32 67 fa				ld (spi_device), a 
572f cd cd 04				call storage_get_block_0 
5732 21 84 fa				ld hl, store_page+3 
5735 cd d7 20				call forth_push_str 
5738			 
5738					 
5738 21 03 00				ld hl, 3 
573b cd 69 20				call forth_push_numhl 
573e 3e ff				ld a, SPI_CE_HIGH 
5740 cb 97				res SPI_CE2, a 
5742 32 67 fa				ld (spi_device), a 
5745 cd cd 04				call storage_get_block_0 
5748 21 84 fa				ld hl, store_page+3 
574b cd d7 20				call forth_push_str 
574e			 
574e			 
574e 21 04 00				ld hl, 4 
5751 cd 69 20				call forth_push_numhl 
5754 3e ff				ld a, SPI_CE_HIGH 
5756 cb 9f				res SPI_CE3, a 
5758 32 67 fa				ld (spi_device), a 
575b cd cd 04				call storage_get_block_0 
575e 21 84 fa				ld hl, store_page+3 
5761 cd d7 20				call forth_push_str 
5764			 
5764					 
5764			 
5764 21 05 00				ld hl, 5 
5767 cd 69 20				call forth_push_numhl 
576a 3e ff				ld a, SPI_CE_HIGH 
576c cb a7				res SPI_CE4, a 
576e 32 67 fa				ld (spi_device), a 
5771 cd cd 04				call storage_get_block_0 
5774 21 84 fa				ld hl, store_page+3 
5777 cd d7 20				call forth_push_str 
577a			 
577a					 
577a					; push fixed count of storage devices (on board) for now 
577a			 
577a 21 05 00				ld hl, 5 
577d cd 69 20				call forth_push_numhl 
5780			 
5780					; restore selected device  
5780				 
5780 f1					pop af 
5781 32 67 fa				ld (spi_device), a 
5784			 
5784				       NEXTW 
5784 c3 16 24			jp macro_next 
5787				endm 
# End of macro NEXTW
5787			 
5787			.SCONST1: 
5787				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5787 6d				db WORD_SYS_CORE+89             
5788 9e 57			dw .SCONST2            
578a 07				db 6 + 1 
578b .. 00			db "FILEID",0              
5792				endm 
# End of macro CWHEAD
5792			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5792			; | | Compatible with PicoSPINet  
5792 3a 6e fa				ld a, (store_filecache) 
5795 26 00				ld h, 0 
5797 6f					ld l, a 
5798 cd 69 20				call forth_push_numhl 
579b					NEXTW 
579b c3 16 24			jp macro_next 
579e				endm 
# End of macro NEXTW
579e			.SCONST2: 
579e				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
579e 6d				db WORD_SYS_CORE+89             
579f b6 57			dw .SCONST3            
57a1 08				db 7 + 1 
57a2 .. 00			db "FILEEXT",0              
57aa				endm 
# End of macro CWHEAD
57aa			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
57aa			; | | Compatible with PicoSPINet  
57aa 3a 71 fa				ld a, (store_openext) 
57ad 26 00				ld h, 0 
57af 6f					ld l, a 
57b0 cd 69 20				call forth_push_numhl 
57b3					NEXTW 
57b3 c3 16 24			jp macro_next 
57b6				endm 
# End of macro NEXTW
57b6			.SCONST3: 
57b6				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
57b6 6d				db WORD_SYS_CORE+89             
57b7 ce 57			dw .SCONST4            
57b9 08				db 7 + 1 
57ba .. 00			db "FILEMAX",0              
57c2				endm 
# End of macro CWHEAD
57c2			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
57c2			; | | Compatible with PicoSPINet  
57c2 3a 70 fa				ld a, (store_openmaxext) 
57c5 26 00				ld h, 0 
57c7 6f					ld l, a 
57c8 cd 69 20				call forth_push_numhl 
57cb					NEXTW 
57cb c3 16 24			jp macro_next 
57ce				endm 
# End of macro NEXTW
57ce			.SCONST4: 
57ce				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
57ce 6d				db WORD_SYS_CORE+89             
57cf e4 57			dw .SCONST5            
57d1 09				db 8 + 1 
57d2 .. 00			db "FILEADDR",0              
57db				endm 
# End of macro CWHEAD
57db			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
57db			; | | Compatible with PicoSPINet  
57db 2a 72 fa				ld hl, (store_openaddr) 
57de cd 69 20				call forth_push_numhl 
57e1					NEXTW 
57e1 c3 16 24			jp macro_next 
57e4				endm 
# End of macro NEXTW
57e4			.SCONST5: 
57e4				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
57e4 6d				db WORD_SYS_CORE+89             
57e5 05 58			dw .SCONST6            
57e7 09				db 8 + 1 
57e8 .. 00			db "FILEPAGE",0              
57f1				endm 
# End of macro CWHEAD
57f1			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
57f1			; | | Compatible with PicoSPINet  
57f1 2a 72 fa				ld hl, (store_openaddr) 
57f4 e5					push hl 
57f5 c1					pop bc 
57f6 16 00				ld d, 0 
57f8 1e 40				ld e, STORE_BLOCK_PHY 
57fa cd a9 0e				call Div16 
57fd c5					push bc 
57fe e1					pop hl 
57ff cd 69 20				call forth_push_numhl 
5802					NEXTW 
5802 c3 16 24			jp macro_next 
5805				endm 
# End of macro NEXTW
5805			.SCONST6: 
5805				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5805 6d				db WORD_SYS_CORE+89             
5806 1e 58			dw .ENDSTORAGE            
5808 09				db 8 + 1 
5809 .. 00			db "READCONT",0              
5812				endm 
# End of macro CWHEAD
5812			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5812			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5812			; | | a further read should, if applicable, be CONCAT to the previous read. 
5812			; | | Compatible with PicoSPINet  
5812 3a 74 fa				ld a, (store_readcont) 
5815 26 00				ld h, 0 
5817 6f					ld l, a 
5818 cd 69 20				call forth_push_numhl 
581b					NEXTW 
581b c3 16 24			jp macro_next 
581e				endm 
# End of macro NEXTW
581e			.ENDSTORAGE: 
581e			; eof 
# End of file forth_words_storage.asm
581e			endif 
581e				include "forth_words_device.asm" 
581e			; Device related words 
581e			 
581e			; | ## Device Words 
581e			 
581e			;if SOUND_ENABLE 
581e			;.NOTE: 
581e			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
581e			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
581e			;		if DEBUG_FORTH_WORDS_KEY 
581e			;			DMARK "NTE" 
581e			;			CALLMONITOR 
581e			;		endif 
581e			; 
581e			;	 
581e			; 
581e			;		NEXTW 
581e			;.AFTERSOUND: 
581e			;endif 
581e			 
581e			 
581e			USE_GPIO: equ 0 
581e			 
581e			if USE_GPIO 
581e			.GP1: 
581e				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
581e			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
581e					NEXTW 
581e			.GP2: 
581e				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
581e			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
581e			 
581e					NEXTW 
581e			 
581e			.GP3: 
581e				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
581e			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
581e			 
581e					NEXTW 
581e			 
581e			.GP4: 
581e				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
581e			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
581e			 
581e					NEXTW 
581e			.SIN: 
581e			 
581e			 
581e			endif 
581e			 
581e			 
581e				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
581e 33				db WORD_SYS_CORE+31             
581f 53 58			dw .SOUT            
5821 03				db 2 + 1 
5822 .. 00			db "IN",0              
5825				endm 
# End of macro CWHEAD
5825			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5825					if DEBUG_FORTH_WORDS_KEY 
5825						DMARK "IN." 
5825 f5				push af  
5826 3a 3a 58			ld a, (.dmark)  
5829 32 6e fe			ld (debug_mark),a  
582c 3a 3b 58			ld a, (.dmark+1)  
582f 32 6f fe			ld (debug_mark+1),a  
5832 3a 3c 58			ld a, (.dmark+2)  
5835 32 70 fe			ld (debug_mark+2),a  
5838 18 03			jr .pastdmark  
583a ..			.dmark: db "IN."  
583d f1			.pastdmark: pop af  
583e			endm  
# End of macro DMARK
583e						CALLMONITOR 
583e cd 9e 19			call break_point_state  
5841				endm  
# End of macro CALLMONITOR
5841					endif 
5841					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5841 cd 60 22			call macro_dsp_valuehl 
5844				endm 
# End of macro FORTH_DSP_VALUEHL
5844			 
5844 e5					push hl 
5845			 
5845					; destroy value TOS 
5845			 
5845					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5845 cd 18 23			call macro_forth_dsp_pop 
5848				endm 
# End of macro FORTH_DSP_POP
5848			 
5848					; one value on hl get other one back 
5848			 
5848 c1					pop bc 
5849			 
5849					; do the sub 
5849			;		ex de, hl 
5849			 
5849 ed 68				in l,(c) 
584b			 
584b					; save it 
584b			 
584b 26 00				ld h,0 
584d			 
584d					; TODO push value back onto stack for another op etc 
584d			 
584d cd 69 20				call forth_push_numhl 
5850					NEXTW 
5850 c3 16 24			jp macro_next 
5853				endm 
# End of macro NEXTW
5853			.SOUT: 
5853				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5853 34				db WORD_SYS_CORE+32             
5854 a6 58			dw .SPIO            
5856 04				db 3 + 1 
5857 .. 00			db "OUT",0              
585b				endm 
# End of macro CWHEAD
585b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
585b					if DEBUG_FORTH_WORDS_KEY 
585b						DMARK "OUT" 
585b f5				push af  
585c 3a 70 58			ld a, (.dmark)  
585f 32 6e fe			ld (debug_mark),a  
5862 3a 71 58			ld a, (.dmark+1)  
5865 32 6f fe			ld (debug_mark+1),a  
5868 3a 72 58			ld a, (.dmark+2)  
586b 32 70 fe			ld (debug_mark+2),a  
586e 18 03			jr .pastdmark  
5870 ..			.dmark: db "OUT"  
5873 f1			.pastdmark: pop af  
5874			endm  
# End of macro DMARK
5874						CALLMONITOR 
5874 cd 9e 19			call break_point_state  
5877				endm  
# End of macro CALLMONITOR
5877					endif 
5877			 
5877					; get port 
5877			 
5877					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5877 cd 60 22			call macro_dsp_valuehl 
587a				endm 
# End of macro FORTH_DSP_VALUEHL
587a			 
587a e5					push hl 
587b			 
587b					; destroy value TOS 
587b			 
587b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
587b cd 18 23			call macro_forth_dsp_pop 
587e				endm 
# End of macro FORTH_DSP_POP
587e			 
587e					; get byte to send 
587e			 
587e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
587e cd 60 22			call macro_dsp_valuehl 
5881				endm 
# End of macro FORTH_DSP_VALUEHL
5881			 
5881			;		push hl 
5881			 
5881					; destroy value TOS 
5881			 
5881					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5881 cd 18 23			call macro_forth_dsp_pop 
5884				endm 
# End of macro FORTH_DSP_POP
5884			 
5884					; one value on hl get other one back 
5884			 
5884			;		pop hl 
5884			 
5884 c1					pop bc 
5885			 
5885					if DEBUG_FORTH_WORDS 
5885						DMARK "OUT" 
5885 f5				push af  
5886 3a 9a 58			ld a, (.dmark)  
5889 32 6e fe			ld (debug_mark),a  
588c 3a 9b 58			ld a, (.dmark+1)  
588f 32 6f fe			ld (debug_mark+1),a  
5892 3a 9c 58			ld a, (.dmark+2)  
5895 32 70 fe			ld (debug_mark+2),a  
5898 18 03			jr .pastdmark  
589a ..			.dmark: db "OUT"  
589d f1			.pastdmark: pop af  
589e			endm  
# End of macro DMARK
589e						CALLMONITOR 
589e cd 9e 19			call break_point_state  
58a1				endm  
# End of macro CALLMONITOR
58a1					endif 
58a1			 
58a1 ed 69				out (c), l 
58a3			 
58a3					NEXTW 
58a3 c3 16 24			jp macro_next 
58a6				endm 
# End of macro NEXTW
58a6			 
58a6			 
58a6			.SPIO: 
58a6			 
58a6			if STORAGE_SE 
58a6				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
58a6 51				db WORD_SYS_CORE+61             
58a7 b7 58			dw .SPICEH            
58a9 07				db 6 + 1 
58aa .. 00			db "SPICEL",0              
58b1				endm 
# End of macro CWHEAD
58b1			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
58b1			 
58b1 cd ca 01				call spi_ce_low 
58b4			    NEXTW 
58b4 c3 16 24			jp macro_next 
58b7				endm 
# End of macro NEXTW
58b7			 
58b7			.SPICEH: 
58b7				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
58b7 51				db WORD_SYS_CORE+61             
58b8 c8 58			dw .SPIOb            
58ba 07				db 6 + 1 
58bb .. 00			db "SPICEH",0              
58c2				endm 
# End of macro CWHEAD
58c2			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
58c2			 
58c2 cd b9 01				call spi_ce_high 
58c5			    NEXTW 
58c5 c3 16 24			jp macro_next 
58c8				endm 
# End of macro NEXTW
58c8			 
58c8			 
58c8			.SPIOb: 
58c8			 
58c8				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
58c8 51				db WORD_SYS_CORE+61             
58c9 fa 58			dw .SPII            
58cb 05				db 4 + 1 
58cc .. 00			db "SPIO",0              
58d1				endm 
# End of macro CWHEAD
58d1			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
58d1			 
58d1					if DEBUG_FORTH_WORDS_KEY 
58d1						DMARK "SPo" 
58d1 f5				push af  
58d2 3a e6 58			ld a, (.dmark)  
58d5 32 6e fe			ld (debug_mark),a  
58d8 3a e7 58			ld a, (.dmark+1)  
58db 32 6f fe			ld (debug_mark+1),a  
58de 3a e8 58			ld a, (.dmark+2)  
58e1 32 70 fe			ld (debug_mark+2),a  
58e4 18 03			jr .pastdmark  
58e6 ..			.dmark: db "SPo"  
58e9 f1			.pastdmark: pop af  
58ea			endm  
# End of macro DMARK
58ea						CALLMONITOR 
58ea cd 9e 19			call break_point_state  
58ed				endm  
# End of macro CALLMONITOR
58ed					endif 
58ed					; get port 
58ed			 
58ed			 
58ed					; get byte to send 
58ed			 
58ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58ed cd 60 22			call macro_dsp_valuehl 
58f0				endm 
# End of macro FORTH_DSP_VALUEHL
58f0			 
58f0			;		push hl    ; u1  
58f0			 
58f0					; destroy value TOS 
58f0			 
58f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58f0 cd 18 23			call macro_forth_dsp_pop 
58f3				endm 
# End of macro FORTH_DSP_POP
58f3			 
58f3					; one value on hl get other one back 
58f3			 
58f3			;		pop hl   ; u2 - addr 
58f3			 
58f3					; TODO Send SPI byte 
58f3			 
58f3			;		push hl 
58f3			;		call spi_ce_low 
58f3			;		pop hl 
58f3 7d					ld a, l 
58f4 cd b8 00				call spi_send_byte 
58f7			;		call spi_ce_high 
58f7			 
58f7					NEXTW 
58f7 c3 16 24			jp macro_next 
58fa				endm 
# End of macro NEXTW
58fa			 
58fa			.SPII: 
58fa				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
58fa 52				db WORD_SYS_CORE+62             
58fb 63 59			dw .SESEL            
58fd 06				db 5 + 1 
58fe .. 00			db "SPII",0              
5903				endm 
# End of macro CWHEAD
5903			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5903					if DEBUG_FORTH_WORDS_KEY 
5903						DMARK "SPi" 
5903 f5				push af  
5904 3a 18 59			ld a, (.dmark)  
5907 32 6e fe			ld (debug_mark),a  
590a 3a 19 59			ld a, (.dmark+1)  
590d 32 6f fe			ld (debug_mark+1),a  
5910 3a 1a 59			ld a, (.dmark+2)  
5913 32 70 fe			ld (debug_mark+2),a  
5916 18 03			jr .pastdmark  
5918 ..			.dmark: db "SPi"  
591b f1			.pastdmark: pop af  
591c			endm  
# End of macro DMARK
591c						CALLMONITOR 
591c cd 9e 19			call break_point_state  
591f				endm  
# End of macro CALLMONITOR
591f					endif 
591f			 
591f					; TODO Get SPI byte 
591f			 
591f cd df 00				call spi_read_byte 
5922			 
5922					if DEBUG_FORTH_WORDS 
5922						DMARK "Si2" 
5922 f5				push af  
5923 3a 37 59			ld a, (.dmark)  
5926 32 6e fe			ld (debug_mark),a  
5929 3a 38 59			ld a, (.dmark+1)  
592c 32 6f fe			ld (debug_mark+1),a  
592f 3a 39 59			ld a, (.dmark+2)  
5932 32 70 fe			ld (debug_mark+2),a  
5935 18 03			jr .pastdmark  
5937 ..			.dmark: db "Si2"  
593a f1			.pastdmark: pop af  
593b			endm  
# End of macro DMARK
593b						CALLMONITOR 
593b cd 9e 19			call break_point_state  
593e				endm  
# End of macro CALLMONITOR
593e					endif 
593e 26 00				ld h, 0 
5940 6f					ld l, a 
5941					if DEBUG_FORTH_WORDS 
5941						DMARK "Si3" 
5941 f5				push af  
5942 3a 56 59			ld a, (.dmark)  
5945 32 6e fe			ld (debug_mark),a  
5948 3a 57 59			ld a, (.dmark+1)  
594b 32 6f fe			ld (debug_mark+1),a  
594e 3a 58 59			ld a, (.dmark+2)  
5951 32 70 fe			ld (debug_mark+2),a  
5954 18 03			jr .pastdmark  
5956 ..			.dmark: db "Si3"  
5959 f1			.pastdmark: pop af  
595a			endm  
# End of macro DMARK
595a						CALLMONITOR 
595a cd 9e 19			call break_point_state  
595d				endm  
# End of macro CALLMONITOR
595d					endif 
595d cd 69 20				call forth_push_numhl 
5960			 
5960					NEXTW 
5960 c3 16 24			jp macro_next 
5963				endm 
# End of macro NEXTW
5963			 
5963			 
5963			 
5963			.SESEL: 
5963				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5963 66				db WORD_SYS_CORE+82             
5964 0c 5a			dw .CARTDEV            
5966 05				db 4 + 1 
5967 .. 00			db "BANK",0              
596c				endm 
# End of macro CWHEAD
596c			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
596c					if DEBUG_FORTH_WORDS_KEY 
596c						DMARK "BNK" 
596c f5				push af  
596d 3a 81 59			ld a, (.dmark)  
5970 32 6e fe			ld (debug_mark),a  
5973 3a 82 59			ld a, (.dmark+1)  
5976 32 6f fe			ld (debug_mark+1),a  
5979 3a 83 59			ld a, (.dmark+2)  
597c 32 70 fe			ld (debug_mark+2),a  
597f 18 03			jr .pastdmark  
5981 ..			.dmark: db "BNK"  
5984 f1			.pastdmark: pop af  
5985			endm  
# End of macro DMARK
5985						CALLMONITOR 
5985 cd 9e 19			call break_point_state  
5988				endm  
# End of macro CALLMONITOR
5988					endif 
5988			 
5988 3e ff				ld a, 255 
598a 32 6a fa				ld (spi_cartdev), a 
598d			 
598d					; get bank 
598d			 
598d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
598d cd 60 22			call macro_dsp_valuehl 
5990				endm 
# End of macro FORTH_DSP_VALUEHL
5990			 
5990			;		push hl 
5990			 
5990					; destroy value TOS 
5990			 
5990					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5990 cd 18 23			call macro_forth_dsp_pop 
5993				endm 
# End of macro FORTH_DSP_POP
5993			 
5993					; one value on hl get other one back 
5993			 
5993			;		pop hl 
5993			 
5993			 
5993 0e ff				ld c, SPI_CE_HIGH 
5995 06 30				ld b, '0'    ; human readable bank number 
5997			 
5997 7d					ld a, l 
5998			 
5998					if DEBUG_FORTH_WORDS 
5998						DMARK "BNK" 
5998 f5				push af  
5999 3a ad 59			ld a, (.dmark)  
599c 32 6e fe			ld (debug_mark),a  
599f 3a ae 59			ld a, (.dmark+1)  
59a2 32 6f fe			ld (debug_mark+1),a  
59a5 3a af 59			ld a, (.dmark+2)  
59a8 32 70 fe			ld (debug_mark+2),a  
59ab 18 03			jr .pastdmark  
59ad ..			.dmark: db "BNK"  
59b0 f1			.pastdmark: pop af  
59b1			endm  
# End of macro DMARK
59b1						CALLMONITOR 
59b1 cd 9e 19			call break_point_state  
59b4				endm  
# End of macro CALLMONITOR
59b4					endif 
59b4			 
59b4					; active low 
59b4			 
59b4 fe 00				cp 0 
59b6 28 28				jr z, .bset 
59b8 fe 01				cp 1 
59ba 20 04				jr nz, .b2 
59bc cb 81				res 0, c 
59be 06 31				ld b, '1'    ; human readable bank number 
59c0 fe 02		.b2:		cp 2 
59c2 20 04				jr nz, .b3 
59c4 cb 89				res 1, c 
59c6 06 32				ld b, '2'    ; human readable bank number 
59c8 fe 03		.b3:		cp 3 
59ca 20 04				jr nz, .b4 
59cc cb 91				res 2, c 
59ce 06 33				ld b, '3'    ; human readable bank number 
59d0 fe 04		.b4:		cp 4 
59d2 20 04				jr nz, .b5 
59d4 cb 99				res 3, c 
59d6 06 34				ld b, '4'    ; human readable bank number 
59d8 fe 05		.b5:		cp 5 
59da 20 04				jr nz, .bset 
59dc cb a1				res 4, c 
59de 06 35				ld b, '5'    ; human readable bank number 
59e0			 
59e0			.bset: 
59e0 79					ld a, c 
59e1 32 67 fa				ld (spi_device),a 
59e4 78					ld a, b 
59e5 32 66 fa				ld (spi_device_id),a 
59e8					if DEBUG_FORTH_WORDS 
59e8						DMARK "BN2" 
59e8 f5				push af  
59e9 3a fd 59			ld a, (.dmark)  
59ec 32 6e fe			ld (debug_mark),a  
59ef 3a fe 59			ld a, (.dmark+1)  
59f2 32 6f fe			ld (debug_mark+1),a  
59f5 3a ff 59			ld a, (.dmark+2)  
59f8 32 70 fe			ld (debug_mark+2),a  
59fb 18 03			jr .pastdmark  
59fd ..			.dmark: db "BN2"  
5a00 f1			.pastdmark: pop af  
5a01			endm  
# End of macro DMARK
5a01						CALLMONITOR 
5a01 cd 9e 19			call break_point_state  
5a04				endm  
# End of macro CALLMONITOR
5a04					endif 
5a04			 
5a04					; set default SPI clk pulse time as disabled for BANK use 
5a04			 
5a04 3e 00				ld a, 0 
5a06 32 6b fa				ld (spi_clktime), a 
5a09			 
5a09					NEXTW 
5a09 c3 16 24			jp macro_next 
5a0c				endm 
# End of macro NEXTW
5a0c			 
5a0c			.CARTDEV: 
5a0c				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5a0c 66				db WORD_SYS_CORE+82             
5a0d ba 5a			dw .ENDDEVICE            
5a0f 08				db 7 + 1 
5a10 .. 00			db "CARTDEV",0              
5a18				endm 
# End of macro CWHEAD
5a18			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5a18					if DEBUG_FORTH_WORDS_KEY 
5a18						DMARK "CDV" 
5a18 f5				push af  
5a19 3a 2d 5a			ld a, (.dmark)  
5a1c 32 6e fe			ld (debug_mark),a  
5a1f 3a 2e 5a			ld a, (.dmark+1)  
5a22 32 6f fe			ld (debug_mark+1),a  
5a25 3a 2f 5a			ld a, (.dmark+2)  
5a28 32 70 fe			ld (debug_mark+2),a  
5a2b 18 03			jr .pastdmark  
5a2d ..			.dmark: db "CDV"  
5a30 f1			.pastdmark: pop af  
5a31			endm  
# End of macro DMARK
5a31						CALLMONITOR 
5a31 cd 9e 19			call break_point_state  
5a34				endm  
# End of macro CALLMONITOR
5a34					endif 
5a34			 
5a34					; disable se storage bank selection 
5a34			 
5a34 3e ff				ld a, SPI_CE_HIGH		; ce high 
5a36 32 67 fa				ld (spi_device), a 
5a39			 
5a39					; get bank 
5a39			 
5a39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a39 cd 60 22			call macro_dsp_valuehl 
5a3c				endm 
# End of macro FORTH_DSP_VALUEHL
5a3c			 
5a3c			;		push hl 
5a3c			 
5a3c					; destroy value TOS 
5a3c			 
5a3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a3c cd 18 23			call macro_forth_dsp_pop 
5a3f				endm 
# End of macro FORTH_DSP_POP
5a3f			 
5a3f					; one value on hl get other one back 
5a3f			 
5a3f			;		pop hl 
5a3f			 
5a3f					; active low 
5a3f			 
5a3f 0e ff				ld c, 255 
5a41			 
5a41 7d					ld a, l 
5a42					if DEBUG_FORTH_WORDS 
5a42						DMARK "CDV" 
5a42 f5				push af  
5a43 3a 57 5a			ld a, (.dmark)  
5a46 32 6e fe			ld (debug_mark),a  
5a49 3a 58 5a			ld a, (.dmark+1)  
5a4c 32 6f fe			ld (debug_mark+1),a  
5a4f 3a 59 5a			ld a, (.dmark+2)  
5a52 32 70 fe			ld (debug_mark+2),a  
5a55 18 03			jr .pastdmark  
5a57 ..			.dmark: db "CDV"  
5a5a f1			.pastdmark: pop af  
5a5b			endm  
# End of macro DMARK
5a5b						CALLMONITOR 
5a5b cd 9e 19			call break_point_state  
5a5e				endm  
# End of macro CALLMONITOR
5a5e					endif 
5a5e fe 00				cp 0 
5a60 28 30				jr z, .cset 
5a62 fe 01				cp 1 
5a64 20 02				jr nz, .c2 
5a66 cb 81				res 0, c 
5a68 fe 02		.c2:		cp 2 
5a6a 20 02				jr nz, .c3 
5a6c cb 89				res 1, c 
5a6e fe 03		.c3:		cp 3 
5a70 20 02				jr nz, .c4 
5a72 cb 91				res 2, c 
5a74 fe 04		.c4:		cp 4 
5a76 20 02				jr nz, .c5 
5a78 cb 99				res 3, c 
5a7a fe 05		.c5:		cp 5 
5a7c 20 02				jr nz, .c6 
5a7e cb a1				res 4, c 
5a80 fe 06		.c6:		cp 6 
5a82 20 02				jr nz, .c7 
5a84 cb a9				res 5, c 
5a86 fe 07		.c7:		cp 7 
5a88 20 02				jr nz, .c8 
5a8a cb b1				res 6, c 
5a8c fe 08		.c8:		cp 8 
5a8e 20 02				jr nz, .cset 
5a90 cb b9				res 7, c 
5a92 79			.cset:		ld a, c 
5a93 32 6a fa				ld (spi_cartdev),a 
5a96			 
5a96					if DEBUG_FORTH_WORDS 
5a96						DMARK "CD2" 
5a96 f5				push af  
5a97 3a ab 5a			ld a, (.dmark)  
5a9a 32 6e fe			ld (debug_mark),a  
5a9d 3a ac 5a			ld a, (.dmark+1)  
5aa0 32 6f fe			ld (debug_mark+1),a  
5aa3 3a ad 5a			ld a, (.dmark+2)  
5aa6 32 70 fe			ld (debug_mark+2),a  
5aa9 18 03			jr .pastdmark  
5aab ..			.dmark: db "CD2"  
5aae f1			.pastdmark: pop af  
5aaf			endm  
# End of macro DMARK
5aaf						CALLMONITOR 
5aaf cd 9e 19			call break_point_state  
5ab2				endm  
# End of macro CALLMONITOR
5ab2					endif 
5ab2			 
5ab2					; set default SPI clk pulse time as 10ms for CARTDEV use 
5ab2			 
5ab2 3e 0a				ld a, $0a 
5ab4 32 6b fa				ld (spi_clktime), a 
5ab7					NEXTW 
5ab7 c3 16 24			jp macro_next 
5aba				endm 
# End of macro NEXTW
5aba			endif 
5aba			 
5aba			.ENDDEVICE: 
5aba			; eof 
5aba			 
# End of file forth_words_device.asm
5aba			 
5aba			; var handler 
5aba			 
5aba			 
5aba			.VARS: 
5aba				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5aba 77				db WORD_SYS_CORE+99             
5abb 6b 5b			dw .V0            
5abd 04				db 3 + 1 
5abe .. 00			db "VAR",0              
5ac2				endm 
# End of macro CWHEAD
5ac2			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5ac2			;| 
5ac2			;| The variable name should consist of a single letter. e.g. "a" 
5ac2			;! If a full string is passed then only the first char is looked at 
5ac2			;| Any other char could exceed bounds checks!  
5ac2			 
5ac2					if DEBUG_FORTH_WORDS_KEY 
5ac2						DMARK "VAR" 
5ac2 f5				push af  
5ac3 3a d7 5a			ld a, (.dmark)  
5ac6 32 6e fe			ld (debug_mark),a  
5ac9 3a d8 5a			ld a, (.dmark+1)  
5acc 32 6f fe			ld (debug_mark+1),a  
5acf 3a d9 5a			ld a, (.dmark+2)  
5ad2 32 70 fe			ld (debug_mark+2),a  
5ad5 18 03			jr .pastdmark  
5ad7 ..			.dmark: db "VAR"  
5ada f1			.pastdmark: pop af  
5adb			endm  
# End of macro DMARK
5adb						CALLMONITOR 
5adb cd 9e 19			call break_point_state  
5ade				endm  
# End of macro CALLMONITOR
5ade					endif 
5ade			 
5ade					FORTH_DSP_VALUEHL 
5ade cd 60 22			call macro_dsp_valuehl 
5ae1				endm 
# End of macro FORTH_DSP_VALUEHL
5ae1			 
5ae1 7e					ld a, (hl)    ; get first char on of the string 
5ae2			 
5ae2			 
5ae2					if DEBUG_FORTH_WORDS 
5ae2						DMARK "VR1" 
5ae2 f5				push af  
5ae3 3a f7 5a			ld a, (.dmark)  
5ae6 32 6e fe			ld (debug_mark),a  
5ae9 3a f8 5a			ld a, (.dmark+1)  
5aec 32 6f fe			ld (debug_mark+1),a  
5aef 3a f9 5a			ld a, (.dmark+2)  
5af2 32 70 fe			ld (debug_mark+2),a  
5af5 18 03			jr .pastdmark  
5af7 ..			.dmark: db "VR1"  
5afa f1			.pastdmark: pop af  
5afb			endm  
# End of macro DMARK
5afb						CALLMONITOR 
5afb cd 9e 19			call break_point_state  
5afe				endm  
# End of macro CALLMONITOR
5afe					endif 
5afe					 
5afe f5					push af	 
5aff					FORTH_DSP_POP 
5aff cd 18 23			call macro_forth_dsp_pop 
5b02				endm 
# End of macro FORTH_DSP_POP
5b02 f1					pop af 
5b03			 
5b03					; convert to upper 
5b03			 
5b03 cd b9 12				call to_upper 
5b06					if DEBUG_FORTH_WORDS 
5b06						DMARK "Vaa" 
5b06 f5				push af  
5b07 3a 1b 5b			ld a, (.dmark)  
5b0a 32 6e fe			ld (debug_mark),a  
5b0d 3a 1c 5b			ld a, (.dmark+1)  
5b10 32 6f fe			ld (debug_mark+1),a  
5b13 3a 1d 5b			ld a, (.dmark+2)  
5b16 32 70 fe			ld (debug_mark+2),a  
5b19 18 03			jr .pastdmark  
5b1b ..			.dmark: db "Vaa"  
5b1e f1			.pastdmark: pop af  
5b1f			endm  
# End of macro DMARK
5b1f						CALLMONITOR 
5b1f cd 9e 19			call break_point_state  
5b22				endm  
# End of macro CALLMONITOR
5b22					endif 
5b22 06 41				ld b, 'A' 
5b24 90					sub b			; set offset 
5b25					if DEBUG_FORTH_WORDS 
5b25						DMARK "Vbb" 
5b25 f5				push af  
5b26 3a 3a 5b			ld a, (.dmark)  
5b29 32 6e fe			ld (debug_mark),a  
5b2c 3a 3b 5b			ld a, (.dmark+1)  
5b2f 32 6f fe			ld (debug_mark+1),a  
5b32 3a 3c 5b			ld a, (.dmark+2)  
5b35 32 70 fe			ld (debug_mark+2),a  
5b38 18 03			jr .pastdmark  
5b3a ..			.dmark: db "Vbb"  
5b3d f1			.pastdmark: pop af  
5b3e			endm  
# End of macro DMARK
5b3e						CALLMONITOR 
5b3e cd 9e 19			call break_point_state  
5b41				endm  
# End of macro CALLMONITOR
5b41					endif 
5b41 cb 27				sla a  
5b43				 
5b43					 
5b43					if DEBUG_FORTH_WORDS 
5b43						DMARK "VR2" 
5b43 f5				push af  
5b44 3a 58 5b			ld a, (.dmark)  
5b47 32 6e fe			ld (debug_mark),a  
5b4a 3a 59 5b			ld a, (.dmark+1)  
5b4d 32 6f fe			ld (debug_mark+1),a  
5b50 3a 5a 5b			ld a, (.dmark+2)  
5b53 32 70 fe			ld (debug_mark+2),a  
5b56 18 03			jr .pastdmark  
5b58 ..			.dmark: db "VR2"  
5b5b f1			.pastdmark: pop af  
5b5c			endm  
# End of macro DMARK
5b5c						CALLMONITOR 
5b5c cd 9e 19			call break_point_state  
5b5f				endm  
# End of macro CALLMONITOR
5b5f					endif 
5b5f			 
5b5f 21 fb f9				ld hl, cli_var_array2 
5b62 cd 4c 0f				call addatohl 
5b65 cd 69 20				call forth_push_numhl 
5b68			 
5b68			 
5b68				       NEXTW 
5b68 c3 16 24			jp macro_next 
5b6b				endm 
# End of macro NEXTW
5b6b			.V0: 
5b6b				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5b6b 78				db WORD_SYS_CORE+100             
5b6c 83 5b			dw .V0Q            
5b6e 04				db 3 + 1 
5b6f .. 00			db "V0!",0              
5b73				endm 
# End of macro CWHEAD
5b73			;| V0! ( u1 -- )  Store value to v0  | DONE 
5b73			 
5b73					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b73 cd 60 22			call macro_dsp_valuehl 
5b76				endm 
# End of macro FORTH_DSP_VALUEHL
5b76			 
5b76 11 2f fa				ld de, cli_var_array 
5b79			 
5b79 eb					ex de, hl 
5b7a 73					ld (hl), e 
5b7b 23					inc hl 
5b7c 72					ld (hl), d 
5b7d			 
5b7d					; destroy value TOS 
5b7d			 
5b7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b7d cd 18 23			call macro_forth_dsp_pop 
5b80				endm 
# End of macro FORTH_DSP_POP
5b80			 
5b80				       NEXTW 
5b80 c3 16 24			jp macro_next 
5b83				endm 
# End of macro NEXTW
5b83			.V0Q: 
5b83				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5b83 79				db WORD_SYS_CORE+101             
5b84 94 5b			dw .V1S            
5b86 04				db 3 + 1 
5b87 .. 00			db "V0@",0              
5b8b				endm 
# End of macro CWHEAD
5b8b			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5b8b 2a 2f fa				ld hl, (cli_var_array) 
5b8e cd 69 20				call forth_push_numhl 
5b91			 
5b91				       NEXTW 
5b91 c3 16 24			jp macro_next 
5b94				endm 
# End of macro NEXTW
5b94			.V1S: 
5b94				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5b94 7a				db WORD_SYS_CORE+102             
5b95 ac 5b			dw .V1Q            
5b97 04				db 3 + 1 
5b98 .. 00			db "V1!",0              
5b9c				endm 
# End of macro CWHEAD
5b9c			;| V1! ( u1 -- )  Store value to v1 | DONE 
5b9c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b9c cd 60 22			call macro_dsp_valuehl 
5b9f				endm 
# End of macro FORTH_DSP_VALUEHL
5b9f			 
5b9f 11 31 fa				ld de, cli_var_array+2 
5ba2				 
5ba2 eb					ex de, hl 
5ba3 73					ld (hl), e 
5ba4 23					inc hl 
5ba5 72					ld (hl), d 
5ba6			 
5ba6					; destroy value TOS 
5ba6			 
5ba6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ba6 cd 18 23			call macro_forth_dsp_pop 
5ba9				endm 
# End of macro FORTH_DSP_POP
5ba9				       NEXTW 
5ba9 c3 16 24			jp macro_next 
5bac				endm 
# End of macro NEXTW
5bac			.V1Q: 
5bac				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5bac 7b				db WORD_SYS_CORE+103             
5bad bd 5b			dw .V2S            
5baf 04				db 3 + 1 
5bb0 .. 00			db "V1@",0              
5bb4				endm 
# End of macro CWHEAD
5bb4			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5bb4 2a 31 fa				ld hl, (cli_var_array+2) 
5bb7 cd 69 20				call forth_push_numhl 
5bba				       NEXTW 
5bba c3 16 24			jp macro_next 
5bbd				endm 
# End of macro NEXTW
5bbd			.V2S: 
5bbd				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5bbd 7c				db WORD_SYS_CORE+104             
5bbe d5 5b			dw .V2Q            
5bc0 04				db 3 + 1 
5bc1 .. 00			db "V2!",0              
5bc5				endm 
# End of macro CWHEAD
5bc5			;| V2! ( u1 -- )  Store value to v2 | DONE 
5bc5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5bc5 cd 60 22			call macro_dsp_valuehl 
5bc8				endm 
# End of macro FORTH_DSP_VALUEHL
5bc8			 
5bc8 11 33 fa				ld de, cli_var_array+4 
5bcb				 
5bcb eb					ex de, hl 
5bcc 73					ld (hl), e 
5bcd 23					inc hl 
5bce 72					ld (hl), d 
5bcf			 
5bcf					; destroy value TOS 
5bcf			 
5bcf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5bcf cd 18 23			call macro_forth_dsp_pop 
5bd2				endm 
# End of macro FORTH_DSP_POP
5bd2				       NEXTW 
5bd2 c3 16 24			jp macro_next 
5bd5				endm 
# End of macro NEXTW
5bd5			.V2Q: 
5bd5				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5bd5 7d				db WORD_SYS_CORE+105             
5bd6 e6 5b			dw .V3S            
5bd8 04				db 3 + 1 
5bd9 .. 00			db "V2@",0              
5bdd				endm 
# End of macro CWHEAD
5bdd			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5bdd 2a 33 fa				ld hl, (cli_var_array+4) 
5be0 cd 69 20				call forth_push_numhl 
5be3				       NEXTW 
5be3 c3 16 24			jp macro_next 
5be6				endm 
# End of macro NEXTW
5be6			.V3S: 
5be6				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5be6 7c				db WORD_SYS_CORE+104             
5be7 fe 5b			dw .V3Q            
5be9 04				db 3 + 1 
5bea .. 00			db "V3!",0              
5bee				endm 
# End of macro CWHEAD
5bee			;| V3! ( u1 -- )  Store value to v3 | DONE 
5bee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5bee cd 60 22			call macro_dsp_valuehl 
5bf1				endm 
# End of macro FORTH_DSP_VALUEHL
5bf1			 
5bf1 11 35 fa				ld de, cli_var_array+6 
5bf4				 
5bf4 eb					ex de, hl 
5bf5 73					ld (hl), e 
5bf6 23					inc hl 
5bf7 72					ld (hl), d 
5bf8			 
5bf8					; destroy value TOS 
5bf8			 
5bf8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5bf8 cd 18 23			call macro_forth_dsp_pop 
5bfb				endm 
# End of macro FORTH_DSP_POP
5bfb				       NEXTW 
5bfb c3 16 24			jp macro_next 
5bfe				endm 
# End of macro NEXTW
5bfe			.V3Q: 
5bfe				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5bfe 7d				db WORD_SYS_CORE+105             
5bff 0f 5c			dw .END            
5c01 04				db 3 + 1 
5c02 .. 00			db "V3@",0              
5c06				endm 
# End of macro CWHEAD
5c06			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5c06 2a 35 fa				ld hl, (cli_var_array+6) 
5c09 cd 69 20				call forth_push_numhl 
5c0c				       NEXTW 
5c0c c3 16 24			jp macro_next 
5c0f				endm 
# End of macro NEXTW
5c0f			 
5c0f			 
5c0f			 
5c0f			 
5c0f			 
5c0f			; end of dict marker 
5c0f			 
5c0f 00			.END:    db WORD_SYS_END 
5c10 00 00			dw 0 
5c12 00				db 0 
5c13			 
5c13			; use to jp here for user dict words to save on macro expansion  
5c13			 
5c13			user_dict_next: 
5c13				NEXTW 
5c13 c3 16 24			jp macro_next 
5c16				endm 
# End of macro NEXTW
5c16			 
5c16			 
5c16			user_exec: 
5c16				;    ld hl, <word code> 
5c16				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5c16				;    call forthexec 
5c16				;    jp user_dict_next   (NEXT) 
5c16			        ;    <word code bytes> 
5c16 eb				ex de, hl 
5c17 2a c9 f4			ld hl,(os_tok_ptr) 
5c1a				 
5c1a				FORTH_RSP_NEXT 
5c1a cd 10 20			call macro_forth_rsp_next 
5c1d				endm 
# End of macro FORTH_RSP_NEXT
5c1d			 
5c1d			if DEBUG_FORTH_UWORD 
5c1d						DMARK "UEX" 
5c1d f5				push af  
5c1e 3a 32 5c			ld a, (.dmark)  
5c21 32 6e fe			ld (debug_mark),a  
5c24 3a 33 5c			ld a, (.dmark+1)  
5c27 32 6f fe			ld (debug_mark+1),a  
5c2a 3a 34 5c			ld a, (.dmark+2)  
5c2d 32 70 fe			ld (debug_mark+2),a  
5c30 18 03			jr .pastdmark  
5c32 ..			.dmark: db "UEX"  
5c35 f1			.pastdmark: pop af  
5c36			endm  
# End of macro DMARK
5c36				CALLMONITOR 
5c36 cd 9e 19			call break_point_state  
5c39				endm  
# End of macro CALLMONITOR
5c39			endif 
5c39			 
5c39			 
5c39			 
5c39 eb				ex de, hl 
5c3a 22 c9 f4			ld (os_tok_ptr), hl 
5c3d				 
5c3d				; Don't use next - Skips the first word in uword. 
5c3d			 
5c3d c3 a7 24			jp exec1 
5c40			;	NEXT 
5c40			 
5c40			 
5c40			; eof 
# End of file forth_wordsv4.asm
5c40			endif 
5c40			;;;;;;;;;;;;;; Debug code 
5c40			 
5c40			 
5c40			;if DEBUG_FORTH_PARSE 
5c40 .. 00		.nowordfound: db "No match",0 
5c49 .. 00		.compword:	db "Comparing word ",0 
5c59 .. 00		.nextwordat:	db "Next word at",0 
5c66 .. 00		.charmatch:	db "Char match",0 
5c71			;endif 
5c71			if DEBUG_FORTH_JP 
5c71			.foundword:	db "Word match. Exec..",0 
5c71			endif 
5c71			;if DEBUG_FORTH_PUSH 
5c71 .. 00		.enddict:	db "Dict end. Push.",0 
5c81 .. 00		.push_str:	db "Pushing string",0 
5c90 .. 00		.push_num:	db "Pushing number",0 
5c9f .. 00		.data_sp:	db "SP:",0 
5ca3 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5cb5 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5cc7 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5cd9			;endif 
5cd9			;if DEBUG_FORTH_MALLOC 
5cd9 .. 00		.push_malloc:	db "Malloc address",0 
5ce8			;endif 
5ce8			 
5ce8			 
5ce8			 
5ce8			; display malloc address and current data stack pointer  
5ce8			 
5ce8			malloc_error: 
5ce8 d5				push de 
5ce9 f5				push af 
5cea e5				push hl 
5ceb cd 18 0d			call clear_display 
5cee 11 10 5d			ld de, .mallocerr 
5cf1 3e 00			ld a,0 
5cf3			;	ld de,os_word_scratch 
5cf3 cd 2b 0d			call str_at_display 
5cf6 3e 11			ld a, display_row_1+17 
5cf8 11 6e fe			ld de, debug_mark 
5cfb cd 2b 0d			call str_at_display 
5cfe cd 3b 0d			call update_display 
5d01				;call break_point_state 
5d01 cd 9d 77			call cin_wait 
5d04			 
5d04 3e 20			ld a, ' ' 
5d06 32 b9 f1			ld (os_view_disable), a 
5d09 e1				pop hl 
5d0a f1				pop af 
5d0b d1				pop de	 
5d0c				CALLMONITOR 
5d0c cd 9e 19			call break_point_state  
5d0f				endm  
# End of macro CALLMONITOR
5d0f c9				ret 
5d10			 
5d10 .. 00		.mallocerr: 	db "Malloc Error",0 
5d1d			;if DEBUG_FORTH_PUSH 
5d1d			display_data_sp: 
5d1d f5				push af 
5d1e			 
5d1e				; see if disabled 
5d1e			 
5d1e 3a b9 f1			ld a, (os_view_disable) 
5d21 fe 2a			cp '*' 
5d23 28 67			jr z, .skipdsp 
5d25			 
5d25 e5				push hl 
5d26 e5				push hl 
5d27 e5			push hl 
5d28 cd 18 0d			call clear_display 
5d2b e1			pop hl 
5d2c 7c				ld a,h 
5d2d 21 cd f4			ld hl, os_word_scratch 
5d30 cd 4d 12			call hexout 
5d33 e1				pop hl 
5d34 7d				ld a,l 
5d35 21 cf f4			ld hl, os_word_scratch+2 
5d38 cd 4d 12			call hexout 
5d3b 21 d1 f4			ld hl, os_word_scratch+4 
5d3e 3e 00			ld a,0 
5d40 77				ld (hl),a 
5d41 11 cd f4			ld de,os_word_scratch 
5d44 3e 28				ld a, display_row_2 
5d46 cd 2b 0d				call str_at_display 
5d49 11 a3 5c			ld de, .wordinhl 
5d4c 3e 00			ld a, display_row_1 
5d4e			 
5d4e cd 2b 0d				call str_at_display 
5d51 11 6e fe			ld de, debug_mark 
5d54 3e 11			ld a, display_row_1+17 
5d56			 
5d56 cd 2b 0d				call str_at_display 
5d59			 
5d59				; display current data stack pointer 
5d59 11 9f 5c			ld de,.data_sp 
5d5c 3e 30				ld a, display_row_2 + 8 
5d5e cd 2b 0d				call str_at_display 
5d61			 
5d61 2a f5 f9			ld hl,(cli_data_sp) 
5d64 e5				push hl 
5d65 7c				ld a,h 
5d66 21 cd f4			ld hl, os_word_scratch 
5d69 cd 4d 12			call hexout 
5d6c e1				pop hl 
5d6d 7d				ld a,l 
5d6e 21 cf f4			ld hl, os_word_scratch+2 
5d71 cd 4d 12			call hexout 
5d74 21 d1 f4			ld hl, os_word_scratch+4 
5d77 3e 00			ld a,0 
5d79 77				ld (hl),a 
5d7a 11 cd f4			ld de,os_word_scratch 
5d7d 3e 33				ld a, display_row_2 + 11 
5d7f cd 2b 0d				call str_at_display 
5d82			 
5d82			 
5d82 cd 3b 0d			call update_display 
5d85 cd 95 0c			call delay1s 
5d88 cd 95 0c			call delay1s 
5d8b e1				pop hl 
5d8c			.skipdsp: 
5d8c f1				pop af 
5d8d c9				ret 
5d8e			 
5d8e			display_data_malloc: 
5d8e			 
5d8e f5				push af 
5d8f e5				push hl 
5d90 e5				push hl 
5d91 e5			push hl 
5d92 cd 18 0d			call clear_display 
5d95 e1			pop hl 
5d96 7c				ld a,h 
5d97 21 cd f4			ld hl, os_word_scratch 
5d9a cd 4d 12			call hexout 
5d9d e1				pop hl 
5d9e 7d				ld a,l 
5d9f 21 cf f4			ld hl, os_word_scratch+2 
5da2 cd 4d 12			call hexout 
5da5 21 d1 f4			ld hl, os_word_scratch+4 
5da8 3e 00			ld a,0 
5daa 77				ld (hl),a 
5dab 11 cd f4			ld de,os_word_scratch 
5dae 3e 28				ld a, display_row_2 
5db0 cd 2b 0d				call str_at_display 
5db3 11 d9 5c			ld de, .push_malloc 
5db6 3e 00			ld a, display_row_1 
5db8			 
5db8 cd 2b 0d				call str_at_display 
5dbb			 
5dbb				; display current data stack pointer 
5dbb 11 9f 5c			ld de,.data_sp 
5dbe 3e 30				ld a, display_row_2 + 8 
5dc0 cd 2b 0d				call str_at_display 
5dc3			 
5dc3 2a f5 f9			ld hl,(cli_data_sp) 
5dc6 e5				push hl 
5dc7 7c				ld a,h 
5dc8 21 cd f4			ld hl, os_word_scratch 
5dcb cd 4d 12			call hexout 
5dce e1				pop hl 
5dcf 7d				ld a,l 
5dd0 21 cf f4			ld hl, os_word_scratch+2 
5dd3 cd 4d 12			call hexout 
5dd6 21 d1 f4			ld hl, os_word_scratch+4 
5dd9 3e 00			ld a,0 
5ddb 77				ld (hl),a 
5ddc 11 cd f4			ld de,os_word_scratch 
5ddf 3e 33				ld a, display_row_2 + 11 
5de1 cd 2b 0d				call str_at_display 
5de4			 
5de4 cd 3b 0d			call update_display 
5de7 cd 95 0c			call delay1s 
5dea cd 95 0c			call delay1s 
5ded e1				pop hl 
5dee f1				pop af 
5def c9				ret 
5df0			;endif 
5df0			 
5df0			include "forth_autostart.asm" 
5df0			; list of commands to perform at system start up 
5df0			 
5df0			startcmds: 
5df0			;	dw test11 
5df0			;	dw test12 
5df0			;	dw test13 
5df0			;	dw test14 
5df0			;	dw test15 
5df0			;	dw test16 
5df0			;	dw test17 
5df0			;	dw ifthtest1 
5df0			;	dw ifthtest2 
5df0			;	dw ifthtest3 
5df0			;	dw mmtest1 
5df0			;	dw mmtest2 
5df0			;	dw mmtest3 
5df0			;	dw mmtest4 
5df0			;	dw mmtest5 
5df0			;	dw mmtest6 
5df0			;	dw iftest1 
5df0			;	dw iftest2 
5df0			;	dw iftest3 
5df0			;	dw looptest1 
5df0			;	dw looptest2 
5df0			;	dw test1 
5df0			;	dw test2 
5df0			;	dw test3 
5df0			;	dw test4 
5df0			;	dw game2r 
5df0			;	dw game2b1 
5df0			;	dw game2b2 
5df0			 
5df0				; start up words that are actually useful 
5df0			 
5df0 f8 5e		    dw spi1 
5df2 51 5f		    dw spi2 
5df4 df 5f		    dw spi3 
5df6 87 5f		    dw spi4 
5df8 b2 5f		    dw spi5 
5dfa 45 60		    dw spi6 
5dfc 9a 60		    dw spi7 
5dfe			 
5dfe f2 60		    dw spi8 
5e00 11 61		    dw spi9 
5e02 69 61		    dw spi10 
5e04			 
5e04			; file editor 
5e04 6a 5e			dw edit1 
5e06 8b 5e			dw edit2 
5e08 c0 5e			dw edit3 
5e0a			 
5e0a dc 61			dw longread 
5e0c 23 62			dw clrstack 
5e0e 56 62			dw type 
5e10 41 64			dw stest 
5e12 7a 62			dw strncpy 
5e14 d7 63			dw list 
5e16 db 62			dw start1 
5e18 eb 62			dw start2 
5e1a			;	dw start3 
5e1a fc 62			dw start3b 
5e1c 77 63			dw start3c 
5e1e			 
5e1e				; (unit) testing words 
5e1e			 
5e1e b8 64			dw mtesta 
5e20 6d 65			dw mtestb 
5e22 10 66			dw mtestc 
5e24 c5 66			dw mtestd 
5e26 69 67			dw mteste 
5e28			 
5e28				; demo/game words 
5e28			 
5e28 75 6e		        dw game3w 
5e2a a3 6e		        dw game3p 
5e2c c1 6e		        dw game3sc 
5e2e f2 6e		        dw game3vsi 
5e30 1e 6f		        dw game3vs 
5e32				 
5e32 68 6c			dw game2b 
5e34 d6 6c			dw game2bf 
5e36 20 6d			dw game2mba 
5e38 b6 6d			dw game2mbas 
5e3a f8 6d			dw game2mb 
5e3c			 
5e3c 29 69			dw game1 
5e3e 3a 69			dw game1a 
5e40 9c 69			dw game1b 
5e42 d1 69			dw game1c 
5e44 07 6a			dw game1d 
5e46 38 6a			dw game1s 
5e48 4c 6a			dw game1t 
5e4a 61 6a			dw game1f 
5e4c 95 6a			dw game1z 
5e4e d9 6a			dw game1zz 
5e50			 
5e50 1f 68			dw test5 
5e52 57 68			dw test6 
5e54 8f 68			dw test7 
5e56 a3 68			dw test8 
5e58 cf 68			dw test9 
5e5a e5 68			dw test10 
5e5c				 
5e5c b0 6b		        dw ssv5 
5e5e 94 6b		        dw ssv4 
5e60 78 6b		        dw ssv3 
5e62 42 6b		        dw ssv2 
5e64 c9 6b		        dw ssv1 
5e66 11 6c		        dw ssv1cpm 
5e68			;	dw keyup 
5e68			;	dw keydown 
5e68			;	dw keyleft 
5e68			;	dw keyright 
5e68			;	dw 	keyf1 
5e68			;	dw keyf2 
5e68			;	dw keyf3 
5e68			;	dw keyf4 
5e68			;	dw keyf5 
5e68			;	dw keyf6 
5e68			;	dw keyf7 
5e68			;	dw keyf8 
5e68			;	dw keyf9 
5e68			;	dw keyf10 
5e68			;	dw keyf11 
5e68			;	dw keyf12 
5e68			;	dw keytab 
5e68			;	dw keycr 
5e68			;	dw keyhome 
5e68			;	dw keyend 
5e68			;	dw keybs 
5e68 00 00			db 0, 0	 
5e6a			 
5e6a			 
5e6a			; File Editor 
5e6a			 
5e6a			; ( id - ) use 'e' to edit the displayed line 
5e6a .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5e8b .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5ec0			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5ec0 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5ef8			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5ef8			 
5ef8			; SPI Net support words 
5ef8			 
5ef8			; v0! = node to send to 
5ef8			; ( str count - ) 
5ef8 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5f51			 
5f51			; spiputchr ( char node - ) 
5f51 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
5f87			 
5f87			; spigetchr ( - n ) 
5f87 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5fb2			 
5fb2			; getnode ( - n ) 
5fb2 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5fdf			 
5fdf			; ( str node - )  
5fdf .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6045			; store string ( str i - ) 
6045			 
6045			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6045 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
609a			 
609a			; get string ( addr i -  )    TO FIX 
609a			 
609a .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
60f2			 
60f2			 
60f2			; NETCHAT (TODO) 
60f2			; Program to allow two nodes to chat with eachother 
60f2			; 
60f2			; v0 - target node 
60f2			;  
60f2			; accept input at 0,0 
60f2			; if input is string send spitype to target node 
60f2			; starting at row 2,0 , while spigetchr is not zero ->  
60f2			; 
60f2			; 
60f2			; TODO add paging of get request 
60f2			 
60f2			; ( node - ) 
60f2 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6111 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6169 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
61dc			 
61dc			 
61dc			; Long read of currently open file 
61dc .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6223			 
6223			; clear stack  
6223			 
6223 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
6256			 
6256			; type ( addr count - ) 
6256 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
627a			 
627a			; some direct memory words 
627a			; strncpy ( len t f -- t ) 
627a			 
627a .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
62db			 
62db .. 00		start1:     	db ": bpon $00 bp ;",0 
62eb .. 00		start2:     	db ": bpoff $01 bp ;",0 
62fc .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6377 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
63d7			 
63d7			 
63d7			; a handy word to list items on the stack 
63d7			 
63d7 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6441			 
6441			 
6441			; test stack  
6441			; rnd8 stest 
6441			 
6441 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
64b8			 
64b8			; random malloc and free cycles 
64b8			 
64b8 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
656d			 
656d			; fixed malloc and free cycles 
656d			 
656d .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6610			 
6610			; fixed double string push and drop cycle  
6610			 
6610 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
66c5			 
66c5			; consistent fixed string push and drop cycle  
66c5			 
66c5 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6769			 
6769 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
681f			 
681f			;test1:		db ": aa 1 2 3 ;", 0 
681f			;test2:     	db "111 aa 888 999",0 
681f			;test3:     	db ": bb 77 ;",0 
681f			;test4:     	db "$02 $01 do i . loop bb",0 
681f			 
681f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6857 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
688f .. 00		test7:     	db ": box hline vline ;",0 
68a3 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
68cf .. 00		test9:     	db ": sw $01 adsp world ;",0 
68e5 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
690a .. 00		test11:     	db "hello create .",0 
6919 .. 00		test12:     	db "hello2 create .",0 
6929			 
6929			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6929			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6929			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6929			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6929			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6929			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6929			 
6929			;iftest1:     	db "$0001 IF cls .",0 
6929			;iftest2:     	db "$0000 IF cls .",0 
6929			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6929			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6929			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6929			 
6929			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6929			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6929			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6929			 
6929			 
6929			 
6929			; a small guess the number game 
6929			 
6929 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
693a .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
699c			 
699c .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
69d1 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6a07 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6a38 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6a4c .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6a61 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6a95 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6ad9			 
6ad9			; Using 'ga' save a high score across multiple runs using external storage 
6ad9			 
6ad9 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6b42			 
6b42			 
6b42			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6b42			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6b42			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6b42			 
6b42			; simple screen saver to test code memory reuse to destruction 
6b42			 
6b42 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6b78 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6b94 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6bb0 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6bc9 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6c11 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6c68			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6c68			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6c68			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6c68			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6c68			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6c68			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6c68			 
6c68			 
6c68			 
6c68			; minesweeper/battleship finding game 
6c68			; draws a game board of random ship/mine positions 
6c68			; user enters coords to see if it hits on 
6c68			; game ends when all are hit 
6c68			; when hit or miss says how many may be in the area 
6c68			 
6c68			; setup the game board and then hide it 
6c68 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6cd6 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6d20			; prompt for where to target 
6d20 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6db6 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6ddb			; TODO see if the entered coords hits or misses pushes char hit of miss 
6ddb .. 00		game2mbht:      db ": mbckht nop ;",0 
6dea .. 00		game2mbms:      db ": mbcms nop ;",0 
6df8			; TODO how many might be near by 
6df8 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6e75			 
6e75			; Game 3 
6e75			 
6e75			; Vert scroller ski game - avoid the trees! 
6e75			 
6e75			; v0 score (ie turns) 
6e75			; v1 player pos 
6e75			; v2 left wall 
6e75			; v3 right wall 
6e75			 
6e75			; Draw side walls randomly 
6e75			 
6e75 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6ea3			 
6ea3			; Draw player 
6ea3 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6ec1			 
6ec1			; TODO Get Key 
6ec1			 
6ec1			; TODO Move left right 
6ec1			 
6ec1			; scroll and move walls a bit 
6ec1			 
6ec1 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6ef2			 
6ef2			; main game loop 
6ef2			 
6ef2 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6f1e .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6f5d			 
6f5d			; key board defs 
6f5d			 
6f5d .. 00		keyup:       db ": keyup $05 ;",0 
6f6b .. 00		keydown:       db ": keydown $0a ;",0 
6f7b .. 00		keyleft:       db ": keyleft $0b ;",0 
6f8b .. 00		keyright:       db ": keyright $0c ;",0 
6f9c .. 00		keyf1:       db ": keyf1 $10 ;",0 
6faa .. 00		keyf2:       db ": keyf2 $11 ;",0 
6fb8 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6fc6 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6fd4 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6fe2 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6ff0 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6ffe .. 00		keyf8:       db ": keyf8 $17 ;",0 
700c .. 00		keyf9:       db ": keyf9 $18 ;",0 
701a .. 00		keyf10:       db ": keyf10 $19 ;",0 
7029 .. 00		keyf11:       db ": keyf11 $1a ;",0 
7038 .. 00		keyf12:       db ": keyf12 $1b ;",0 
7047			 
7047 .. 00		keytab:       db ": keytab $09 ;",0 
7056 .. 00		keycr:       db ": keycr $0d ;",0 
7064 .. 00		keyhome:       db ": keyhome $0e ;",0 
7074 .. 00		keyend:       db ": keyend $0f ;",0 
7083 .. 00		keybs:       db ": keybs $08 ;",0 
7091			 
7091			   
7091			 
7091			 
7091			 
7091			; eof 
# End of file forth_autostart.asm
7091			 
7091			 
7091			 
7091			; stack over and underflow checks 
7091			 
7091			; init the words to detect the under/overflow 
7091			 
7091			chk_stk_init: 
7091				; a vague random number to check so we dont get any "lucky" hits 
7091 3e 2d			ld a, 45 
7093 6f				ld l, a 
7094 00				nop 
7095 3e 17			ld a, 23 
7097 67				ld h, a 
7098			 
7098 22 af f1			ld (chk_word), hl     ; the word we need to check against 
709b			 
709b			;	ld (chk_stund), hl	; stack points.... 
709b 22 fd fe			ld (chk_stovr), hl 
709e 22 f3 f9			ld (chk_ret_und), hl 
70a1 22 b1 f9			ld (chk_ret_ovr), hl 
70a4 22 2f f9			ld (chk_loop_ovr), hl 
70a7 22 2d f7			ld (chk_data_ovr), hl 
70aa c9				ret 
70ab				 
70ab			check_stacks: 
70ab				; check all stack words 
70ab			 
70ab e5				push hl 
70ac d5				push de 
70ad			 
70ad			;	ld de,(chk_word) 
70ad			;	ld hl, (chk_stund)	; stack points.... 
70ad			;	if DEBUG_STK_FAULT 
70ad			;		DMARK "FAa" 
70ad			;		CALLMONITOR 
70ad			;	endif 
70ad			;	call cmp16 
70ad			;	jp z, .chk_faulta 
70ad			; 
70ad			;	ld de, sfaultsu 
70ad			;	jp .chk_fault 
70ad			 
70ad 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
70b0 ed 5b af f1		ld de,(chk_word) 
70b4				if DEBUG_STK_FAULT 
70b4					DMARK "FAb" 
70b4					CALLMONITOR 
70b4				endif 
70b4 cd 6a 0f			call cmp16 
70b7 28 06			jr z, .chk_fault1 
70b9 11 5a 71			ld de, sfaultso 
70bc c3 0e 71			jp .chk_fault 
70bf			.chk_fault1:  
70bf 2a f3 f9			ld hl, (chk_ret_und) 
70c2 ed 5b af f1		ld de,(chk_word) 
70c6				if DEBUG_STK_FAULT 
70c6					DMARK "FAU" 
70c6					CALLMONITOR 
70c6				endif 
70c6 cd 6a 0f			call cmp16 
70c9 ca d2 70			jp z, .chk_fault2 
70cc 11 6a 71			ld de, sfaultru 
70cf c3 0e 71			jp .chk_fault 
70d2			.chk_fault2:  
70d2 2a b1 f9			ld hl, (chk_ret_ovr) 
70d5 ed 5b af f1		ld de,(chk_word) 
70d9				if DEBUG_STK_FAULT 
70d9					DMARK "FA1" 
70d9					CALLMONITOR 
70d9				endif 
70d9 cd 6a 0f			call cmp16 
70dc ca e5 70			jp z, .chk_fault3 
70df 11 78 71			ld de, sfaultro 
70e2 c3 0e 71			jp .chk_fault 
70e5			.chk_fault3:  
70e5 2a 2f f9			ld hl, (chk_loop_ovr) 
70e8 ed 5b af f1		ld de,(chk_word) 
70ec				if DEBUG_STK_FAULT 
70ec					DMARK "FA2" 
70ec					CALLMONITOR 
70ec				endif 
70ec cd 6a 0f			call cmp16 
70ef ca f8 70			jp z, .chk_fault4 
70f2 11 92 71			ld de, sfaultlo 
70f5 c3 0e 71			jp .chk_fault 
70f8			.chk_fault4:  
70f8 2a 2d f7			ld hl, (chk_data_ovr) 
70fb ed 5b af f1		ld de,(chk_word) 
70ff				if DEBUG_STK_FAULT 
70ff					DMARK "FA3" 
70ff					CALLMONITOR 
70ff				endif 
70ff cd 6a 0f			call cmp16 
7102 ca 0b 71			jp z, .chk_fault5 
7105 11 ac 71			ld de, sfaultdo 
7108 c3 0e 71			jp .chk_fault 
710b			 
710b			 
710b			.chk_fault5:  
710b d1				pop de 
710c e1				pop hl 
710d			 
710d c9				ret 
710e			 
710e cd 18 0d		.chk_fault: 	call clear_display 
7111 3e 28				ld a, display_row_2 
7113 cd 2b 0d				call str_at_display 
7116 11 3c 71				   ld de, .stackfault 
7119 3e 00				ld a, display_row_1 
711b cd 2b 0d				call str_at_display 
711e 11 6e fe				    ld de, debug_mark 
7121 3e 11				ld a, display_row_1+17 
7123 cd 2b 0d				call str_at_display 
7126 cd 3b 0d				call update_display 
7129			 
7129				; prompt before entering montior for investigating issue 
7129			 
7129 3e 78			ld a, display_row_4 
712b 11 83 1d			ld de, endprog 
712e			 
712e cd 3b 0d			call update_display		 
7131			 
7131 cd e1 1f			call next_page_prompt 
7134			 
7134 d1				pop de 
7135 e1				pop hl 
7136 cd d7 1d				call monitor 
7139 c3 d1 1c				jp warmstart 
713c					;jp 0 
713c					;halt 
713c			 
713c			 
713c			 
713c .. 00		.stackfault: 	db "Stack fault:",0 
7149			 
7149 .. 00		sfaultsu: 	db	"Stack under flow",0 
715a .. 00		sfaultso: 	db	"Stack over flow",0 
716a .. 00		sfaultru:	db "RTS underflow",0 
7178 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7192 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
71ac .. 00		sfaultdo:	db "DTS overflow", 0 
71b9			 
71b9			 
71b9			fault_dsp_under: 
71b9 11 cb 71			ld de, .dsp_under 
71bc c3 7b 72			jp .show_fault 
71bf			 
71bf			fault_rsp_under: 
71bf 11 d9 71			ld de, .rsp_under 
71c2 c3 7b 72			jp .show_fault 
71c5			fault_loop_under: 
71c5 11 e7 71			ld de, .loop_under 
71c8 c3 7b 72			jp .show_fault 
71cb			 
71cb .. 00		.dsp_under: db "DSP Underflow",0 
71d9 .. 00		.rsp_under: db "RSP Underflow",0 
71e7 .. 00		.loop_under: db "LOOP Underflow",0 
71f6			 
71f6			 
71f6 d5			type_faultn: 	push de 
71f7 e5					push hl 
71f8 cd 18 0d				call clear_display 
71fb 11 22 72				   ld de, .typefaultn 
71fe 3e 00				ld a, display_row_1 
7200 cd 2b 0d				call str_at_display 
7203 11 6e fe				    ld de, debug_mark 
7206 3e 11				ld a, display_row_1+17 
7208 cd 2b 0d				call str_at_display 
720b cd 3b 0d				call update_display 
720e			 
720e				; prompt before entering montior for investigating issue 
720e			 
720e 3e 78			ld a, display_row_4 
7210 11 83 1d			ld de, endprog 
7213			 
7213 cd 3b 0d			call update_display		 
7216			 
7216 cd e1 1f			call next_page_prompt 
7219			 
7219 e5					push hl 
721a d5					push de 
721b cd d7 1d				call monitor 
721e c3 d1 1c				jp warmstart 
7221 76					halt 
7222			 
7222			 
7222 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
7239			 
7239 d5			type_faults: 	push de 
723a e5					push hl 
723b cd 18 0d				call clear_display 
723e 11 64 72				   ld de, .typefaults 
7241 3e 00				ld a, display_row_1 
7243 cd 2b 0d				call str_at_display 
7246 11 6e fe				    ld de, debug_mark 
7249 3e 11				ld a, display_row_1+17 
724b cd 2b 0d				call str_at_display 
724e cd 3b 0d				call update_display 
7251			 
7251				; prompt before entering montior for investigating issue 
7251			 
7251 3e 78			ld a, display_row_4 
7253 11 83 1d			ld de, endprog 
7256			 
7256 cd 3b 0d			call update_display		 
7259			 
7259 cd e1 1f			call next_page_prompt 
725c			 
725c e1					pop hl 
725d d1					pop de 
725e cd d7 1d				call monitor 
7261 c3 d1 1c				jp warmstart 
7264			 
7264			 
7264 .. 00		.typefaults: db "STR Type Expected TOS!",0 
727b			 
727b			.show_fault: 	 
727b d5					push de 
727c cd 18 0d				call clear_display 
727f d1					pop de 
7280 3e 00				ld a, display_row_1 
7282 cd 2b 0d				call str_at_display 
7285 11 6e fe				    ld de, debug_mark 
7288 3e 11				ld a, display_row_1+17 
728a cd 2b 0d				call str_at_display 
728d cd 3b 0d				call update_display 
7290			 
7290				; prompt before entering montior for investigating issue 
7290			 
7290 3e 78			ld a, display_row_4 
7292 11 83 1d			ld de, endprog 
7295			 
7295 cd 3b 0d			call update_display		 
7298			 
7298 cd e1 1f			call next_page_prompt 
729b			 
729b e1					pop hl 
729c d1					pop de 
729d cd d7 1d				call monitor 
72a0			; do a dump to cli and not warmstart so we preserve all of the uwords.  
72a0			; TODO Make optional fault restart to cli or warm boot? 
72a0					;jp warmstart 
72a0 c3 29 1d				jp cli 
72a3 76					halt 
72a4			 
72a4			; handle the auto run of code from files in storage 
72a4			 
72a4			 
72a4			include "forth_startup.asm" 
72a4			; Which startup method to use? 
72a4			; 
72a4			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
72a4			; followed by loading of a list of scripts in eeprom 
72a4			 
72a4			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
72a4			; from eeprom 
72a4			 
72a4			; Select with define in main stubs 
72a4			 
72a4			if STARTUP_V1 
72a4				include "forth_startupv1.asm" 
72a4			endif 
72a4			if STARTUP_V2 
72a4				include "forth_startupv2.asm" 
72a4			; Version 2 of the startup  
72a4			;  
72a4			; Auto load any files in bank 1 that start with a '*' 
72a4			; If no se storage then revert to using eprom 
72a4			 
72a4			 
72a4			if STORAGE_SE = 0 
72a4			 
72a4			sprompt1: db "Startup load...",0 
72a4			sprompt2: db "Run? 1=No *=End #=All",0 
72a4			 
72a4			 
72a4			 
72a4			 
72a4			forth_startup: 
72a4				ld hl, startcmds 
72a4				ld a, 0 
72a4				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
72a4			 
72a4			.start1:	push hl 
72a4				call clear_display 
72a4				ld de, sprompt1 
72a4			        ld a, display_row_1 
72a4				call str_at_display 
72a4				ld de, sprompt2 
72a4			        ld a, display_row_2 
72a4				call str_at_display 
72a4				pop hl 
72a4				push hl 
72a4				ld e,(hl) 
72a4				inc hl 
72a4				ld d,(hl) 
72a4			        ld a, display_row_3 
72a4				call str_at_display 
72a4				call update_display 
72a4			 
72a4			 
72a4				ld a, (os_last_cmd) 
72a4				cp 0 
72a4				jr z, .startprompt 
72a4				call delay250ms 
72a4				jr .startdo 
72a4				 
72a4				 
72a4			 
72a4			.startprompt: 
72a4			 
72a4				ld a,display_row_4 + display_cols - 1 
72a4			        ld de, endprg 
72a4				call str_at_display 
72a4				call update_display 
72a4				call delay1s 
72a4				call cin_wait 
72a4						 
72a4				cp '*' 
72a4				jr z, .startupend1 
72a4				cp '#' 
72a4				jr nz, .startno 
72a4				ld a, 1 
72a4				ld (os_last_cmd),a 
72a4				jr .startdo 
72a4			.startno:	cp '1' 
72a4				jr z,.startnxt  
72a4			 
72a4				; exec startup line 
72a4			.startdo:	 
72a4				pop hl 
72a4				push hl 
72a4				 
72a4				ld e,(hl) 
72a4				inc hl 
72a4				ld d,(hl) 
72a4				ex de,hl 
72a4			 
72a4				push hl 
72a4			 
72a4				ld a, 0 
72a4				;ld a, FORTH_END_BUFFER 
72a4				call strlent 
72a4				inc hl   ; include zero term to copy 
72a4				ld b,0 
72a4				ld c,l 
72a4				pop hl 
72a4				ld de, scratch 
72a4				ldir 
72a4			 
72a4			 
72a4				ld hl, scratch 
72a4				call forthparse 
72a4				call forthexec 
72a4				call forthexec_cleanup 
72a4			 
72a4				ld a, display_row_4 
72a4				ld de, endprog 
72a4			 
72a4				call update_display		 
72a4			 
72a4				ld a, (os_last_cmd) 
72a4				cp 0 
72a4				jr nz, .startnxt 
72a4				call next_page_prompt 
72a4			        call clear_display 
72a4				call update_display		 
72a4			 
72a4				; move onto next startup line? 
72a4			.startnxt: 
72a4			 
72a4				call delay250ms 
72a4				pop hl 
72a4			 
72a4				inc hl 
72a4				inc hl 
72a4			 
72a4				push hl 
72a4				ld e, (hl) 
72a4				inc hl 
72a4				ld d, (hl) 
72a4				pop hl 
72a4				; TODO replace 0 test 
72a4			 
72a4				ex de, hl 
72a4				call ishlzero 
72a4			;	ld a,e 
72a4			;	add d 
72a4			;	cp 0    ; any left to do? 
72a4				ex de, hl 
72a4				jp nz, .start1 
72a4				jr .startupend 
72a4			 
72a4			.startupend1: pop hl 
72a4			.startupend: 
72a4			 
72a4				call clear_display 
72a4				call update_display 
72a4				ret 
72a4			endif 
72a4			 
72a4			 
72a4			if STORAGE_SE 
72a4			 
72a4 .. 00		sprompt3: db "Loading from start-up file:",0 
72c0			;sprompt4: db "(Any key to stop)",0 
72c0			 
72c0			 
72c0			forth_autoload: 
72c0			 
72c0				; load block 0 of store 1 
72c0				 
72c0 3e fe			ld a, $fe      ; bit 0 clear 
72c2 32 67 fa			ld (spi_device), a 
72c5			 
72c5 cd cd 04			call storage_get_block_0 
72c8			 
72c8 3a a2 fa			ld a, (store_page+STORE_0_AUTOFILE) 
72cb			 
72cb fe 00			cp 0 
72cd c8				ret z     ; auto start not enabled 
72ce			 
72ce cd 18 0d			call clear_display 
72d1			 
72d1				; set bank 
72d1			 
72d1 3a a4 fa				ld a, (store_page+STORE_0_BANKRUN) 
72d4 32 67 fa				ld (spi_device), a 
72d7			 
72d7			 
72d7				; generate a directory of bank 1 and search for flagged files 
72d7			 
72d7					if DEBUG_FORTH_WORDS_KEY 
72d7						DMARK "DIR" 
72d7 f5				push af  
72d8 3a ec 72			ld a, (.dmark)  
72db 32 6e fe			ld (debug_mark),a  
72de 3a ed 72			ld a, (.dmark+1)  
72e1 32 6f fe			ld (debug_mark+1),a  
72e4 3a ee 72			ld a, (.dmark+2)  
72e7 32 70 fe			ld (debug_mark+2),a  
72ea 18 03			jr .pastdmark  
72ec ..			.dmark: db "DIR"  
72ef f1			.pastdmark: pop af  
72f0			endm  
# End of macro DMARK
72f0						CALLMONITOR 
72f0 cd 9e 19			call break_point_state  
72f3				endm  
# End of macro CALLMONITOR
72f3					endif 
72f3			 
72f3 cd cd 04			call storage_get_block_0 
72f6			 
72f6 21 81 fa			ld hl, store_page     ; get current id count 
72f9 46				ld b, (hl) 
72fa 0e 00			ld c, 0    ; count of files   
72fc					if DEBUG_FORTH_WORDS 
72fc						DMARK "DI1" 
72fc f5				push af  
72fd 3a 11 73			ld a, (.dmark)  
7300 32 6e fe			ld (debug_mark),a  
7303 3a 12 73			ld a, (.dmark+1)  
7306 32 6f fe			ld (debug_mark+1),a  
7309 3a 13 73			ld a, (.dmark+2)  
730c 32 70 fe			ld (debug_mark+2),a  
730f 18 03			jr .pastdmark  
7311 ..			.dmark: db "DI1"  
7314 f1			.pastdmark: pop af  
7315			endm  
# End of macro DMARK
7315						CALLMONITOR 
7315 cd 9e 19			call break_point_state  
7318				endm  
# End of macro CALLMONITOR
7318					endif 
7318			 
7318				; check for empty drive 
7318			 
7318 3e 00			ld a, 0 
731a b8				cp b 
731b ca 4d 73			jp z, .dirdone 
731e			 
731e				; for each of the current ids do a search for them and if found push to stack 
731e			 
731e c5			.diritem:	push bc 
731f 21 40 00				ld hl, STORE_BLOCK_PHY 
7322 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
7324 58					ld e,b 
7325			 
7325			;		if DEBUG_FORTH_WORDS 
7325			;			DMARK "DI2" 
7325			;			CALLMONITOR 
7325			;		endif 
7325			 
7325 cd 4f 07				call storage_findnextid 
7328			 
7328			;		if DEBUG_FORTH_WORDS 
7328			;			DMARK "DI3" 
7328			;			CALLMONITOR 
7328			;		endif 
7328			 
7328					; if found hl will be non zero 
7328			 
7328 cd 75 0f				call ishlzero 
732b			;		ld a, l 
732b			;		add h 
732b			; 
732b			;		cp 0 
732b 28 1d				jr z, .dirnotfound 
732d			 
732d					; increase count 
732d			 
732d c1					pop bc	 
732e 0c					inc c 
732f c5					push bc 
7330					 
7330			 
7330					; get file header and push the file name 
7330			 
7330 11 81 fa				ld de, store_page 
7333 cd 1c 04				call storage_read_block 
7336			 
7336					; push file id to stack 
7336				 
7336			 
7336					; is this a file we want to run? 
7336			 
7336 21 84 fa				ld hl, store_page+3 
7339 7e					ld a,(hl) 
733a fe 2a				cp '*' 
733c 20 0c				jr nz,  .dirnotfound 
733e					 
733e			 
733e			 
733e 3a 81 fa				ld a, (store_page) 
7341 d5					push de 
7342 e5					push hl 
7343 c5					push bc 
7344 cd 6a 73				call .autorunf 
7347 c1					pop bc 
7348 e1					pop hl 
7349 d1					pop de 
734a			 
734a			 
734a			 
734a				; save this extent 
734a			 
734a					; push file name 
734a			;display file name to run 
734a			 
734a			;		ld hl, store_page+3 
734a			;		if DEBUG_FORTH_WORDS 
734a			;			DMARK "DI5" 
734a			;			CALLMONITOR 
734a			;		endif 
734a			; 
734a			;		 
734a			; 
734a			;		call forth_push_str 
734a			;		if DEBUG_FORTH_WORDS 
734a			;			DMARK "DI6" 
734a			;			CALLMONITOR 
734a			;		endif 
734a			.dirnotfound: 
734a c1					pop bc     
734b 10 d1				djnz .diritem 
734d				 
734d			.dirdone:	 
734d					if DEBUG_FORTH_WORDS 
734d						DMARK "DI7" 
734d f5				push af  
734e 3a 62 73			ld a, (.dmark)  
7351 32 6e fe			ld (debug_mark),a  
7354 3a 63 73			ld a, (.dmark+1)  
7357 32 6f fe			ld (debug_mark+1),a  
735a 3a 64 73			ld a, (.dmark+2)  
735d 32 70 fe			ld (debug_mark+2),a  
7360 18 03			jr .pastdmark  
7362 ..			.dmark: db "DI7"  
7365 f1			.pastdmark: pop af  
7366			endm  
# End of macro DMARK
7366						CALLMONITOR 
7366 cd 9e 19			call break_point_state  
7369				endm  
# End of macro CALLMONITOR
7369					endif 
7369			 
7369			 
7369			 
7369 c9					ret 
736a			 
736a			 
736a			 
736a			 
736a			 
736a			.autorunf: 
736a			 
736a			 
736a				; get file id to load from and get the file name to display 
736a			 
736a			;		ld a, (store_page+STORE_0_FILERUN) 
736a			 
736a 2e 00				ld l, 0 
736c 67					ld h, a 
736d 11 81 fa				ld de, store_page 
7370			 
7370					if DEBUG_FORTH_WORDS 
7370						DMARK "ASp" 
7370 f5				push af  
7371 3a 85 73			ld a, (.dmark)  
7374 32 6e fe			ld (debug_mark),a  
7377 3a 86 73			ld a, (.dmark+1)  
737a 32 6f fe			ld (debug_mark+1),a  
737d 3a 87 73			ld a, (.dmark+2)  
7380 32 70 fe			ld (debug_mark+2),a  
7383 18 03			jr .pastdmark  
7385 ..			.dmark: db "ASp"  
7388 f1			.pastdmark: pop af  
7389			endm  
# End of macro DMARK
7389						CALLMONITOR 
7389 cd 9e 19			call break_point_state  
738c				endm  
# End of macro CALLMONITOR
738c					endif 
738c cd 75 09				call storage_read 
738f			 
738f					if DEBUG_FORTH_WORDS 
738f						DMARK "ASr" 
738f f5				push af  
7390 3a a4 73			ld a, (.dmark)  
7393 32 6e fe			ld (debug_mark),a  
7396 3a a5 73			ld a, (.dmark+1)  
7399 32 6f fe			ld (debug_mark+1),a  
739c 3a a6 73			ld a, (.dmark+2)  
739f 32 70 fe			ld (debug_mark+2),a  
73a2 18 03			jr .pastdmark  
73a4 ..			.dmark: db "ASr"  
73a7 f1			.pastdmark: pop af  
73a8			endm  
# End of macro DMARK
73a8						CALLMONITOR 
73a8 cd 9e 19			call break_point_state  
73ab				endm  
# End of macro CALLMONITOR
73ab					endif 
73ab			 
73ab cd 75 0f				call ishlzero 
73ae c8					ret z             ; file not found 
73af			 
73af 3e 32				ld a, display_row_2 + 10 
73b1 11 84 fa				ld de, store_page+3 
73b4 cd 2b 0d				call str_at_display 
73b7				 
73b7			; 
73b7			 
73b7 3e 05			ld a, display_row_1+5 
73b9 11 a4 72			ld de, sprompt3 
73bc cd 2b 0d			call str_at_display 
73bf			;	ld a, display_row_3+15 
73bf			;	ld de, sprompt4 
73bf			;	call str_at_display 
73bf			 
73bf cd 3b 0d			call update_display 
73c2			 
73c2			;	call cin_wait 
73c2			;	cp 'n' 
73c2			;	ret z 
73c2			;	cp 'N' 
73c2			;	ret z 
73c2			 
73c2			;	call delay1s 
73c2			 
73c2 3a 83 fa			ld a, (store_page+2) 
73c5 32 70 fa			ld (store_openmaxext), a    ; save count of ext 
73c8 3e 01			ld a, 1  
73ca 32 71 fa			ld (store_openext), a    ; save count of ext 
73cd			 
73cd			.autof:  
73cd 6f				ld l , a 
73ce				 
73ce 3a 81 fa			ld a, (store_page) 
73d1 67				ld h, a	 
73d2 11 81 fa			ld de, store_page 
73d5					if DEBUG_FORTH_WORDS 
73d5						DMARK "ASl" 
73d5 f5				push af  
73d6 3a ea 73			ld a, (.dmark)  
73d9 32 6e fe			ld (debug_mark),a  
73dc 3a eb 73			ld a, (.dmark+1)  
73df 32 6f fe			ld (debug_mark+1),a  
73e2 3a ec 73			ld a, (.dmark+2)  
73e5 32 70 fe			ld (debug_mark+2),a  
73e8 18 03			jr .pastdmark  
73ea ..			.dmark: db "ASl"  
73ed f1			.pastdmark: pop af  
73ee			endm  
# End of macro DMARK
73ee						CALLMONITOR 
73ee cd 9e 19			call break_point_state  
73f1				endm  
# End of macro CALLMONITOR
73f1					endif 
73f1 cd 75 09				call storage_read 
73f4 cd 75 0f			call ishlzero 
73f7 c8				ret z 
73f8			;	jr z, .autoend 
73f8			 
73f8					if DEBUG_FORTH_WORDS 
73f8						DMARK "ASc" 
73f8 f5				push af  
73f9 3a 0d 74			ld a, (.dmark)  
73fc 32 6e fe			ld (debug_mark),a  
73ff 3a 0e 74			ld a, (.dmark+1)  
7402 32 6f fe			ld (debug_mark+1),a  
7405 3a 0f 74			ld a, (.dmark+2)  
7408 32 70 fe			ld (debug_mark+2),a  
740b 18 03			jr .pastdmark  
740d ..			.dmark: db "ASc"  
7410 f1			.pastdmark: pop af  
7411			endm  
# End of macro DMARK
7411						CALLMONITOR 
7411 cd 9e 19			call break_point_state  
7414				endm  
# End of macro CALLMONITOR
7414					endif 
7414 11 83 fa			ld de, store_page+2 
7417 3e 78			ld a, display_row_4 
7419 cd 2b 0d			call str_at_display 
741c			 
741c cd 3b 0d			call update_display 
741f cd 89 0c			call delay250ms 
7422			 
7422			 
7422			 
7422 21 83 fa			ld hl, store_page+2 
7425 cd 64 24			call forthparse 
7428 cd a4 24			call forthexec 
742b cd b6 23			call forthexec_cleanup 
742e			 
742e				 
742e 3a 71 fa			ld a, (store_openext) 
7431 3c				inc a 
7432 32 71 fa			ld (store_openext), a    ; save count of ext 
7435			 
7435 18 96			jr .autof 
7437			;.autofdone: 
7437			; 
7437			;		if DEBUG_FORTH_WORDS 
7437			;			DMARK "ASx" 
7437			;			CALLMONITOR 
7437			;		endif 
7437			;;	call clear_display 
7437			;	ret 
7437			 
7437			 
7437			 
7437			endif 
# End of file forth_startupv2.asm
7437			endif 
7437			 
# End of file forth_startup.asm
7437			 
7437			; eof 
# End of file forth_kernel.asm
7437			;include "nascombasic.asm" 
7437			 
7437			 
7437			; find out where the code ends if loaded into RAM (for SC114) 
7437			;endofcode:  
7437			;	nop 
7437			 
7437			 
7437			; eof 
7437			 
# End of file main.asm
7437			include "firmware_lcd_4x40.asm" 
7437			; **********************************************************************  
7437			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
7437			; **********************************************************************  
7437			;  
7437			; **  Written as a Small Computer Monitor App  
7437			; **  www.scc.me.uk  
7437			;  
7437			; History  
7437			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
7437			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
7437			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
7437			;  
7437			; **********************************************************************  
7437			;  
7437			; This program is an example of one of the methods of interfacing an   
7437			; alphanumeric LCD module.   
7437			;  
7437			; In this example the display is connected to either a Z80 PIO or a   
7437			; simple 8-bit output port.   
7437			;  
7437			; This interfacing method uses 4-bit data mode and uses time delays  
7437			; rather than polling the display's ready status. As a result the   
7437			; interface only requires 6 simple output lines:  
7437			;   Output bit 0 = not used  
7437			;   Output bit 1 = not used  
7437			;   Output bit 2 = RS         High = data, Low = instruction  
7437			;   Output bit 3 = E          Active high  
7437			;   Output bit 4 = DB4  
7437			;   Output bit 5 = DB5  
7437			;   Output bit 6 = DB6  
7437			;   Output bit 7 = DB7  
7437			; Display's R/W is connected to 0v so it is always in write mode  
7437			;  
7437			; This set up should work with any system supporting the RC2014 bus  
7437			  
7437			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
7437			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
7437			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
7437			;  
7437			; **********************************************************************  
7437			  
7437			; Additonal for 4x40. E1 and E2 instead of just E   
7437			; TODO swipe vidout signal on port a to activate E2  
7437			  
7437			; **********************************************************************  
7437			; **  Constants  
7437			; **********************************************************************  
7437			; LCD constants required by LCD support module  
7437			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
7437			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
7437			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
7437			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
7437			; TODO Decide which E is being set  
7437			kLCDWidth:  EQU display_cols             ;Width in characters  
7437			  
7437			; **********************************************************************  
7437			; **  Code library usage  
7437			; **********************************************************************  
7437			  
7437			; send character to current cursor position  
7437			; wraps and/or scrolls screen automatically  
7437			  
7437			  
7437			  
7437			lcd_init:  
7437			  
7437			; SCMonAPI functions used  
7437			  
7437			; Alphanumeric LCD functions used  
7437			; no need to specify specific functions for this module  
7437			  
7437 3e cf		            LD   A, 11001111b  
7439 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
743b 3e 00		            LD   A, 00000000b  
743d d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
743f			  
743f			; Initialise alphanumeric LCD module  
743f 3e 00				ld a, 0  
7441 32 ce fb				ld (display_lcde1e2), a  
7444 cd c5 74		            CALL fLCD_Init      ;Initialise LCD module  
7447 3e 01				ld a, 1  
7449 32 ce fb				ld (display_lcde1e2), a  
744c cd c5 74		            CALL fLCD_Init      ;Initialise LCD module  
744f			  
744f c9				ret  
7450			  
7450			;  
7450			;;  
7450			; lcd functions  
7450			;  
7450			;  
7450			  
7450			; what is at cursor position   
7450			  
7450			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7450			;		call curptr  
7450			;		ret  
7450			  
7450			  
7450			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7450			  
7450			curptr:  
7450 c5				push bc  
7451 21 b4 fd			ld hl, display_fb0  
7454			cpr:	  
7454				; loop for cursor whole row  
7454 0e 28			ld c, display_cols  
7456 23			cpr1:	inc hl  
7457 0d				dec c  
7458 20 fc			jr nz, cpr1  
745a 05				dec b  
745b 20 f7			jr nz, cpr  
745d			  
745d				; add col	  
745d			  
745d 23			cpr2:	inc hl  
745e 1d				dec e  
745f 20 fc			jr nz, cpr2  
7461			  
7461 c1				pop bc  
7462 c9				ret  
7463				  
7463			  
7463			  
7463			  
7463			  
7463			; write the frame buffer given in hl to hardware   
7463 22 cc fb		write_display: ld (display_write_tmp), hl 	   
7466 3e 00			ld a, kLCD_Line1  
7468 cd 72 75		            CALL fLCD_Pos       ;Position cursor to location in A  
746b 06 28			ld b, display_cols  
746d ed 5b cc fb		ld de, (display_write_tmp)  
7471 cd bd 74			call write_len_string  
7474				  
7474				  
7474 2a cc fb			ld hl, (display_write_tmp)  
7477 11 28 00			ld de, display_cols  
747a 19				add hl,de  
747b 22 cc fb			ld (display_write_tmp),hl  
747e			  
747e				  
747e 3e 28			ld a, kLCD_Line2  
7480 cd 72 75		            CALL fLCD_Pos       ;Position cursor to location in A  
7483 06 28			ld b, display_cols  
7485 ed 5b cc fb		ld de, (display_write_tmp)  
7489 cd bd 74			call write_len_string  
748c				  
748c 2a cc fb			ld hl, (display_write_tmp)  
748f 11 28 00			ld de, display_cols  
7492 19				add hl,de  
7493 22 cc fb			ld (display_write_tmp),hl  
7496			  
7496				  
7496 3e 50			ld a, kLCD_Line3  
7498 cd 72 75		            CALL fLCD_Pos       ;Position cursor to location in A  
749b 06 28			ld b, display_cols  
749d ed 5b cc fb		ld de, (display_write_tmp)  
74a1 cd bd 74			call write_len_string  
74a4				  
74a4 2a cc fb			ld hl, (display_write_tmp)  
74a7 11 28 00			ld de, display_cols  
74aa 19				add hl,de  
74ab 22 cc fb			ld (display_write_tmp),hl  
74ae			  
74ae				  
74ae 3e 78			ld a, kLCD_Line4  
74b0 cd 72 75		            CALL fLCD_Pos       ;Position cursor to location in A  
74b3 06 28			ld b, display_cols  
74b5 ed 5b cc fb		ld de, (display_write_tmp)  
74b9 cd bd 74			call write_len_string  
74bc c9					ret  
74bd				  
74bd				; write out a fixed length string given in b from de  
74bd			  
74bd 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
74be cd 2a 75		            CALL fLCD_Data      ;Write character to display  
74c1 13				inc de  
74c2 10 f9			djnz write_len_string  
74c4 c9				ret  
74c5			  
74c5			; Some other things to do  
74c5			;            LD   A, kLCD_Clear ;Display clear  
74c5			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
74c5			;            LD   A, kLCD_Under ;Display on with underscore cursor  
74c5			;            LD   A, kLCD_On     ;Display on with no cursor  
74c5			;            ;LD   A, kLCD_Off   ;Display off  
74c5			;            CALL fLCD_Inst      ;Send instruction to display  
74c5			;  
74c5			;  
74c5			;            halt  
74c5			;  
74c5			;  
74c5			;MsgHello:   DB  "Hello World!",0  
74c5			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
74c5			  
74c5			; Custom characters 5 pixels wide by 8 pixels high  
74c5			; Up to 8 custom characters can be defined  
74c5			;BitMaps:      
74c5			;; Character 0x00 = Battery icon  
74c5			;            DB  01110b  
74c5			;            DB  11011b  
74c5			;            DB  10001b  
74c5			;            DB  10001b  
74c5			;            DB  11111b  
74c5			;            DB  11111b  
74c5			;            DB  11111b  
74c5			;            DB  11111b  
74c5			;; Character 0x01 = Bluetooth icon  
74c5			;            DB  01100b  
74c5			;            DB  01010b  
74c5			;            DB  11100b  
74c5			;            DB  01000b  
74c5			;            DB  11100b  
74c5			;            DB  01010b  
74c5			;            DB  01100b  
74c5			;            DB  00000b  
74c5			;  
74c5			  
74c5			  
74c5			; **********************************************************************  
74c5			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
74c5			; **********************************************************************  
74c5			;  
74c5			; **  Written as a Small Computer Monitor App   
74c5			; **  Version 0.1 SCC 2018-05-16  
74c5			; **  www.scc.me.uk  
74c5			;  
74c5			; **********************************************************************  
74c5			;  
74c5			; This module provides support for alphanumeric LCD modules using with  
74c5			; *  HD44780 (or compatible) controller  
74c5			; *  5 x 7 pixel fonts  
74c5			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
74c5			; *  Interface via six digital outputs to the display (see below)  
74c5			;  
74c5			; LCD module pinout:  
74c5			;   1  Vss   0v supply  
74c5			;   2  Vdd   5v supply  
74c5			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
74c5			;   4  RS    High = data, Low = instruction  
74c5			;   5  R/W   High = Read, Low = Write  
74c5			;   6  E     Enable signal (active high)  
74c5			;   7  DB0   Data bit 0  
74c5			;   8  DB1   Data bit 1  
74c5			;   9  DB2   Data bit 2  
74c5			;  10  DB3   Data bit 3  
74c5			;  11  DB4   Data bit 4  
74c5			;  12  DB5   Data bit 5  
74c5			;  13  DB6   Data bit 6  
74c5			;  14  DB7   Data bit 7  
74c5			;  15  A     Backlight anode (+)  
74c5			;  16  K     Backlight cathode (-)  
74c5			;  
74c5			; This interfacing method uses 4-bit data mode and uses time delays  
74c5			; rather than polling the display's ready status. As a result the   
74c5			; interface only requires 6 simple output lines:  
74c5			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
74c5			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
74c5			;   LCD DB4 = Microcomputer output port bit 4  
74c5			;   LCD DB5 = Microcomputer output port bit 5  
74c5			;   LCD DB6 = Microcomputer output port bit 6  
74c5			;   LCD DB7 = Microcomputer output port bit 7  
74c5			; Display's R/W is connected to 0v so it is always in write mode  
74c5			; All 6 connections must be on the same port address <kLCDPrt>  
74c5			; This method also allows a decent length of cable from micro to LCD  
74c5			;  
74c5			; **********************************************************************  
74c5			;  
74c5			; To include the code for any given function provided by this module,   
74c5			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
74c5			; the parent source file.  
74c5			; For example:  #REQUIRES   uHexPrefix  
74c5			;  
74c5			; Also #INCLUDE this file at some point after the #REQUIRES statements  
74c5			; in the parent source file.  
74c5			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
74c5			;  
74c5			; These are the function names provided by this module:  
74c5			; fLCD_Init                     ;Initialise LCD  
74c5			; fLCD_Inst                     ;Send instruction to LCD  
74c5			; fLCD_Data                     ;Send data byte to LCD  
74c5			; fLCD_Pos                      ;Position cursor  
74c5			; fLCD_Str                      ;Display string  
74c5			; fLCD_Def                      ;Define custom character  
74c5			;  
74c5			; **********************************************************************  
74c5			;  
74c5			; Requires SCMonAPI.asm to also be included in the project  
74c5			;  
74c5			  
74c5			  
74c5			; **********************************************************************  
74c5			; **  Constants  
74c5			; **********************************************************************  
74c5			  
74c5			; Constants that must be defined externally  
74c5			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
74c5			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
74c5			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
74c5			;kLCDWidth: EQU 20             ;Width in characters  
74c5			  
74c5			; general line offsets in any frame buffer  
74c5			  
74c5			  
74c5			display_row_1: equ 0  
74c5			display_row_2: equ display_row_1+display_cols  
74c5			display_row_3: equ display_row_2 + display_cols  
74c5			display_row_4: equ display_row_3 + display_cols  
74c5			;display_row_4_eol:   
74c5			  
74c5			  
74c5			; Cursor position values for the start of each line  
74c5			  
74c5			; E  
74c5			kLCD_Line1: EQU 0x00   
74c5			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
74c5			; E1  
74c5			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
74c5			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
74c5			  
74c5			; Instructions to send as A register to fLCD_Inst  
74c5			kLCD_Clear: EQU 00000001b     ;LCD clear  
74c5			kLCD_Off:   EQU 00001000b     ;LCD off  
74c5			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
74c5			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
74c5			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
74c5			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
74c5			  
74c5			; Constants used by this code module  
74c5			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
74c5			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
74c5			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
74c5			  
74c5			  
74c5			  
74c5			; **********************************************************************  
74c5			; **  LCD support functions  
74c5			; **********************************************************************  
74c5			  
74c5			; Initialise alphanumeric LCD module  
74c5			; LCD control register codes:  
74c5			;   DL   0 = 4-bit mode        1 = 8-bit mode  
74c5			;   N    0 = 1-line mode       1 = 2-line mode  
74c5			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
74c5			;   D    0 = Display off       1 = Display on  
74c5			;   C    0 = Cursor off        1 = Cursor on  
74c5			;   B    0 = Blinking off      1 = Blinking on  
74c5			;   ID   0 = Decrement mode    1 = Increment mode  
74c5			;   SH   0 = Entire shift off  1 = Entire shift on  
74c5 3e 28		fLCD_Init:  LD   A, 40  
74c7 cd ec 75		            CALL LCDDelay       ;Delay 40ms after power up  
74ca			; For reliable reset set 8-bit mode - 3 times  
74ca cd bc 75		            CALL WrFn8bit       ;Function = 8-bit mode  
74cd cd bc 75		            CALL WrFn8bit       ;Function = 8-bit mode  
74d0 cd bc 75		            CALL WrFn8bit       ;Function = 8-bit mode  
74d3			; Set 4-bit mode  
74d3 cd b8 75		            CALL WrFn4bit       ;Function = 4-bit mode  
74d6 cd ea 75		            CALL LCDDelay1      ;Delay 37 us or more  
74d9			; Function set  
74d9 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
74db cd ee 74		            CALL fLCD_Inst      ;2 line, display on  
74de			; Display On/Off control  
74de 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
74e0 cd ee 74		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
74e3			; Display Clear  
74e3 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
74e5 cd ee 74		            CALL fLCD_Inst      ;Clear display  
74e8			; Entry mode  
74e8 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
74ea cd ee 74		            CALL fLCD_Inst      ;Increment mode, shift off  
74ed			; Display module now initialised  
74ed c9			            RET  
74ee			; ok to here  
74ee			  
74ee			; Write instruction to LCD  
74ee			;   On entry: A = Instruction byte to be written  
74ee			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
74ee f5			fLCD_Inst:  PUSH AF  
74ef f5			            PUSH AF  
74f0 cd 02 75		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
74f3 f1			            POP  AF  
74f4 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
74f5 17			            RLA  
74f6 17			            RLA  
74f7 17			            RLA  
74f8 cd 02 75		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
74fb 3e 02		            LD   A, 2  
74fd cd ec 75		            CALL LCDDelay       ;Delay 2 ms to complete   
7500 f1			            POP  AF  
7501 c9			            RET  
7502			Wr4bits:   
7502 f5					push af  
7503 3a ce fb				ld a, (display_lcde1e2)  
7506 fe 00				cp 0     ; e  
7508 20 10				jr nz, .wea2	  
750a f1					pop af  
750b e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
750d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
750f cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7511 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7513 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7515 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7517 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7519 c9			            RET  
751a f1			.wea2:		pop af  
751b e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
751d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
751f cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7521 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7523 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7525 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7527 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7529 c9			            RET  
752a			  
752a			  
752a			; Write data to LCD  
752a			;   On entry: A = Data byte to be written  
752a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
752a f5			fLCD_Data:  PUSH AF  
752b f5			            PUSH AF  
752c cd 3e 75		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
752f f1			            POP  AF  
7530 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7531 17			            RLA  
7532 17			            RLA  
7533 17			            RLA  
7534 cd 3e 75		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7537 3e 96		            LD   A, 150  
7539 3d			Wait:      DEC  A              ;Wait a while to allow data   
753a 20 fd		            JR   NZ, Wait      ;  write to complete  
753c f1			            POP  AF  
753d c9			            RET  
753e			Wr4bitsa:     
753e f5					push af  
753f 3a ce fb				ld a, (display_lcde1e2)  
7542 fe 00				cp 0     ; e1  
7544 20 16				jr nz, .we2	  
7546 f1					pop af  
7547 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7549 cb d7		            SET  kLCDBitRS, A  
754b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
754d cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
754f cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7551 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7553 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7555 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7557 cb 97		            RES  kLCDBitRS, A  
7559 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
755b c9			            RET  
755c f1			.we2:		pop af  
755d e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
755f cb d7		            SET  kLCDBitRS, A  
7561 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7563 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7565 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7567 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7569 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
756b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
756d cb 97		            RES  kLCDBitRS, A  
756f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7571 c9			            RET  
7572			  
7572			  
7572			; Position cursor to specified location  
7572			;   On entry: A = Cursor position  
7572			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7572 f5			fLCD_Pos:   PUSH AF  
7573					; at this point set the E1 or E2 flag depending on position  
7573			  
7573 c5					push bc  
7574			;		push af  
7574 06 00				ld b, 0  
7576 4f					ld c, a  
7577 3e 4f				ld a, kLCD_Line3-1  
7579 b7			 		or a      ;clear carry flag  
757a 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
757b 38 04				jr c, .pe1  
757d			  
757d					; E selection  
757d cb 80				res 0, b         ; bit 0 unset e  
757f			;		pop af    ; before line 3 so recover orig pos  
757f			;		ld c, a    ; save for poking back  
757f 18 06				jr .peset	          
7581			.pe1:          	; E2 selection  
7581 cb c0				set 0, b         ; bit 0 set e1  
7583 79					ld a, c  
7584 de 4f				sbc a, kLCD_Line3-1  
7586 4f					ld c, a	         ; save caculated offset  
7587			;		pop af     ; bin this original value now we have calculated form  
7587			  
7587			.peset:		; set bit  
7587 78					ld a, b  
7588 32 ce fb				ld (display_lcde1e2), a 	  
758b 79					ld a, c  
758c c1					pop bc  
758d			  
758d f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
758f cd ee 74		            CALL fLCD_Inst      ;Write instruction to LCD  
7592 f1			            POP  AF  
7593 c9			            RET  
7594			  
7594			  
7594			; Output text string to LCD  
7594			;   On entry: DE = Pointer to null terminated text string  
7594			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7594 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7595 b7			            OR   A              ;Null terminator?  
7596 c8			            RET  Z              ;Yes, so finished  
7597 cd 2a 75		            CALL fLCD_Data      ;Write character to display  
759a 13			            INC  DE             ;Point to next character  
759b 18 f7		            JR   fLCD_Str       ;Repeat  
759d c9					ret  
759e			  
759e			; Define custom character  
759e			;   On entry: A = Character number (0 to 7)  
759e			;             DE = Pointer to character bitmap data  
759e			;   On exit:  A = Next character number  
759e			;             DE = Next location following bitmap  
759e			;             BC HL IX IY I AF' BC' DE' HL' preserved  
759e			; Character is   
759e c5			fLCD_Def:   PUSH BC  
759f f5			            PUSH AF  
75a0 07			            RLCA                ;Calculate location  
75a1 07			            RLCA                ;  for bitmap data  
75a2 07			            RLCA                ;  = 8 x CharacterNumber  
75a3 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
75a5 cd ee 74		            CALL fLCD_Inst      ;Write instruction to LCD  
75a8 06 00		            LD   B, 0  
75aa 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
75ab cd 2a 75		            CALL fLCD_Data      ;Write byte to display  
75ae 13			            INC  DE             ;Point to next byte  
75af 04			            INC  B              ;Count bytes  
75b0 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
75b2 28 f6		            JR   Z, Loop       ;No, so repeat  
75b4 f1			            POP  AF  
75b5 3c			            INC  A              ;Increment character number  
75b6 c1			            POP  BC  
75b7 c9			            RET  
75b8			  
75b8			  
75b8			; **********************************************************************  
75b8			; **  Private functions  
75b8			; **********************************************************************  
75b8			  
75b8			; Write function to LCD  
75b8			;   On entry: A = Function byte to be written  
75b8			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
75b8 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
75ba 18 02		            JR   WrFunc  
75bc 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
75be f5			WrFunc:     PUSH AF  
75bf f5					push af  
75c0 3a ce fb				ld a, (display_lcde1e2)  
75c3 fe 00				cp 0     ; e1  
75c5 20 0f				jr nz, .wfea2	  
75c7 f1					pop af  
75c8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
75ca cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
75cc cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
75ce d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
75d0 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
75d2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
75d4 18 0d			jr .wfskip  
75d6 f1			.wfea2:		pop af  
75d7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
75d9 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
75db cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
75dd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
75df cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
75e1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
75e3 3e 05		.wfskip:            LD  A, 5  
75e5 cd ec 75		            CALL LCDDelay       ;Delay 5 ms to complete  
75e8 f1			            POP  AF  
75e9 c9			            RET  
75ea			  
75ea			  
75ea			; Delay in milliseconds  
75ea			;   On entry: A = Number of milliseconds delay  
75ea			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
75ea 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
75ec d5			LCDDelay:   PUSH DE  
75ed 5f			            LD   E, A           ;Delay by 'A' ms  
75ee 16 00		            LD   D, 0  
75f0 cd 7a 0c		            CALL aDelayInMS  
75f3 d1			            POP  DE  
75f4 c9			            RET  
75f5			  
75f5			  
75f5			testlcd:  
75f5 3e 00			ld a, kLCD_Line1  
75f7 cd 72 75			call fLCD_Pos  
75fa 06 28			ld b, 40  
75fc 11 2a 76			ld de, .ttext1  
75ff cd bd 74			call write_len_string  
7602			  
7602 3e 28			ld a, kLCD_Line2  
7604 cd 72 75			call fLCD_Pos  
7607 06 28			ld b, 40  
7609 11 53 76			ld de, .ttext2  
760c cd bd 74			call write_len_string  
760f 3e 50			ld a, kLCD_Line3  
7611 cd 72 75			call fLCD_Pos  
7614 06 28			ld b, 40  
7616 11 7c 76			ld de, .ttext3  
7619 cd bd 74			call write_len_string  
761c 3e 78			ld a, kLCD_Line4  
761e cd 72 75			call fLCD_Pos  
7621 06 28			ld b, 40  
7623 11 a5 76			ld de, .ttext4  
7626 cd bd 74			call write_len_string  
7629			  
7629 76				halt  
762a			  
762a			  
762a .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7653 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
767c .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
76a5 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
76ce			   
76ce			  
76ce			  
76ce			; eof  
76ce			  
# End of file firmware_lcd_4x40.asm
76ce			;include "firmware_lcd_4x20.asm" 
76ce			include "firmware_key_5x10.asm" 
76ce			; 5 x 10 decade counter scanner  
76ce			  
76ce			  
76ce			; TODO do cursor shape change for shift keys  
76ce			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
76ce			  
76ce			  
76ce			; bit mask for each scan column and row for teing the matrix  
76ce			  
76ce			  
76ce			key_init:  
76ce			  
76ce			; SCMonAPI functions used  
76ce			  
76ce			; Alphanumeric LCD functions used  
76ce			; no need to specify specific functions for this module  
76ce			  
76ce			  
76ce 3e cf		            LD   A, 11001111b  
76d0 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
76d2			;            LD   A, 00000000b  
76d2 3e 1f		            LD   A, 00011111b  
76d4 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
76d6			  
76d6			  
76d6				; TODO Configure cursor shapes  
76d6			  
76d6				; Load cursor shapes   
76d6 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
76d8 11 e8 76		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
76db 06 02		            LD   B, 2           ;Number of characters to define  
76dd cd 9e 75		.DefLoop:   CALL fLCD_Def       ;Define custom character  
76e0 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
76e2			  
76e2 3e 01				ld a, 1  
76e4 32 c7 fb			ld (cursor_shape),a  
76e7 c9				ret  
76e8			  
76e8			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
76e8			; Up to 8 custom characters can be defined  
76e8			.cursor_shapes:      
76e8			;; Character 0x00 = Normal  
76e8 1f			            DB  11111b  
76e9 1f			            DB  11111b  
76ea 1f			            DB  11111b  
76eb 1f			            DB  11111b  
76ec 1f			            DB  11111b  
76ed 1f			            DB  11111b  
76ee 1f			            DB  11111b  
76ef 1f			            DB  11111b  
76f0			;; Character 0x01 = Modifier  
76f0 1f			            DB  11111b  
76f1 1b			            DB  11011b  
76f2 1b			            DB  11011b  
76f3 1b			            DB  11011b  
76f4 1b			            DB  11011b  
76f5 1f			            DB  11111b  
76f6 1b			            DB  11011b  
76f7 1f			            DB  11111b  
76f8			  
76f8			  
76f8			  
76f8			  
76f8			; Display custom character 0  
76f8			;            LD   A, kLCD_Line1+14  
76f8			;            CALL fLCD_Pos       ;Position cursor to location in A  
76f8			;            LD   A, 0  
76f8			;            CALL fLCD_Data      ;Write character in A at cursor  
76f8			  
76f8			; Display custom character 1  
76f8			;            LD   A, kLCD_Line2+14  
76f8			;            CALL fLCD_Pos      ;Position cursor to location in A  
76f8			;            LD   A, 1  
76f8			;            CALL fLCD_Data     ;Write character in A at cursor  
76f8			  
76f8			; keyboard scanning   
76f8			  
76f8			; character in from keyboard  
76f8			  
76f8			; mapping for the pcb layout  
76f8			  
76f8			.matrix_to_char:  
76f8 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7703 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
770e 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7719 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7724 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
772f			.matrix_to_shift:  
772f			  
772f .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
773a .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7745 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7750 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
775b .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7766			  
7766			.matrix_to_symbolshift:  
7766			  
7766 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7771 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
777c 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7787			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7787 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7792 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
779d			  
779d			  
779d			  
779d			; mapping for a simple straight through breadboard layout  
779d			  
779d			;.matrix_to_char:  
779d			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
779d			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
779d			;		db "asdfghjkl",KEY_CR,0  
779d			;		db "qwertyuiop",0  
779d			;		 db "1234567890",0  
779d			;.matrix_to_shift:  
779d			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
779d			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
779d			;		db "ASDFGHJKL",KEY_CR,0  
779d			;		db "QWERTYUIOP",0  
779d			;		 db "!",'"',"#$%^&*()",0  
779d			;.matrix_to_symbolshift:  
779d			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
779d			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
779d			;		db "_?*fghjk=",KEY_CR,0  
779d			;		db "-/+*[]{}@#",0  
779d			;		 db "1234567890",0  
779d			  
779d			;.matrix_to_char: db "D#0*C987B654A321"  
779d			  
779d			  
779d				  
779d			  
779d			; add cin and cin_wait  
779d			  
779d cd ae 77		cin_wait: 	call cin  
77a0						if DEBUG_KEYCINWAIT  
77a0							push af  
77a0							  
77a0							ld hl,key_repeat_ct  
77a0							ld (hl),a  
77a0							inc hl  
77a0							call hexout  
77a0							ld hl,key_repeat_ct+3  
77a0							ld a,0  
77a0							ld (hl),a  
77a0			  
77a0							    LD   A, kLCD_Line1+11  
77a0							    CALL fLCD_Pos       ;Position cursor to location in A  
77a0							    LD   DE, key_repeat_ct  
77a0							    ;LD   DE, MsgHello  
77a0							    CALL fLCD_Str       ;Display string pointed to by DE  
77a0			  
77a0			  
77a0			  
77a0							pop af  
77a0						endif  
77a0 fe 00			cp 0  
77a2 28 f9			jr z, cin_wait   ; block until key press  
77a4			  
77a4							if DEBUG_KEYCINWAIT  
77a4								push af  
77a4			  
77a4								ld a, 'A'	  
77a4								ld hl,key_repeat_ct  
77a4								ld (hl),a  
77a4								inc hl  
77a4								ld a,0  
77a4								ld (hl),a  
77a4			  
77a4								    LD   A, kLCD_Line2+11  
77a4								    CALL fLCD_Pos       ;Position cursor to location in A  
77a4								    LD   DE, key_repeat_ct  
77a4								    ;LD   DE, MsgHello  
77a4								    CALL fLCD_Str       ;Display string pointed to by DE  
77a4			  
77a4							call delay500ms  
77a4			  
77a4								pop af  
77a4							endif  
77a4 f5				push af   ; save key pressed  
77a5			  
77a5			.cin_wait1:	  
77a5							if DEBUG_KEYCINWAIT  
77a5								push af  
77a5			  
77a5								ld a, 'b'	  
77a5								ld hl,key_repeat_ct  
77a5								ld (hl),a  
77a5								inc hl  
77a5								ld a,0  
77a5								ld (hl),a  
77a5			  
77a5								    LD   A, kLCD_Line2+11  
77a5								    CALL fLCD_Pos       ;Position cursor to location in A  
77a5								    LD   DE, key_repeat_ct  
77a5								    ;LD   DE, MsgHello  
77a5								    CALL fLCD_Str       ;Display string pointed to by DE  
77a5			  
77a5			  
77a5							call delay500ms  
77a5			  
77a5								pop af  
77a5							endif  
77a5			  
77a5 cd ae 77		call cin  
77a8 fe 00			cp 0  
77aa 20 f9			jr nz, .cin_wait1  	; wait for key release  
77ac			if DEBUG_KEYCINWAIT  
77ac				push af  
77ac			  
77ac				ld a, '3'	  
77ac				ld hl,key_repeat_ct  
77ac				ld (hl),a  
77ac				inc hl  
77ac				ld a,0  
77ac				ld (hl),a  
77ac			  
77ac			            LD   A, kLCD_Line2+11  
77ac			            CALL fLCD_Pos       ;Position cursor to location in A  
77ac			            LD   DE, key_repeat_ct  
77ac			            ;LD   DE, MsgHello  
77ac			            CALL fLCD_Str       ;Display string pointed to by DE  
77ac			  
77ac			  
77ac			call delay500ms  
77ac			  
77ac				pop af  
77ac			endif  
77ac			  
77ac f1				pop af   ; get key  
77ad c9				ret  
77ae			  
77ae			  
77ae cd c2 77		cin: 	call .mtoc  
77b1			  
77b1			if DEBUG_KEYCIN  
77b1				push af  
77b1				  
77b1				ld hl,key_repeat_ct  
77b1				ld (hl),a  
77b1				inc hl  
77b1				call hexout  
77b1				ld hl,key_repeat_ct+3  
77b1				ld a,0  
77b1				ld (hl),a  
77b1			  
77b1			            LD   A, kLCD_Line3+15  
77b1			            CALL fLCD_Pos       ;Position cursor to location in A  
77b1			            LD   DE, key_repeat_ct  
77b1			            ;LD   DE, MsgHello  
77b1			            CALL fLCD_Str       ;Display string pointed to by DE  
77b1			  
77b1			  
77b1			call delay500ms  
77b1			  
77b1				pop af  
77b1			endif  
77b1			  
77b1			  
77b1				; no key held  
77b1 fe 00			cp 0  
77b3 c8				ret z  
77b4			  
77b4			if DEBUG_KEYCIN  
77b4				push af  
77b4			  
77b4				ld a, '1'	  
77b4				ld hl,key_repeat_ct  
77b4				ld (hl),a  
77b4				inc hl  
77b4				ld a,0  
77b4				ld (hl),a  
77b4			  
77b4			            LD   A, kLCD_Line4+15  
77b4			            CALL fLCD_Pos       ;Position cursor to location in A  
77b4			            LD   DE, key_repeat_ct  
77b4			            ;LD   DE, MsgHello  
77b4			            CALL fLCD_Str       ;Display string pointed to by DE  
77b4			  
77b4			  
77b4			call delay500ms  
77b4			  
77b4				pop af  
77b4			endif  
77b4			  
77b4				; stop key bounce  
77b4			  
77b4 32 88 fe			ld (key_held),a		 ; save it  
77b7 47				ld b, a  
77b8			  
77b8 c5			.cina1:	push bc  
77b9			if DEBUG_KEYCIN  
77b9				push af  
77b9			  
77b9				ld hl,key_repeat_ct  
77b9				inc hl  
77b9				call hexout  
77b9				ld hl,key_repeat_ct+3  
77b9				ld a,0  
77b9				ld (hl),a  
77b9				ld hl,key_repeat_ct  
77b9				ld a, '2'	  
77b9				ld (hl),a  
77b9			  
77b9			            LD   A, kLCD_Line4+15  
77b9			            CALL fLCD_Pos       ;Position cursor to location in A  
77b9			            LD   DE, key_repeat_ct  
77b9			            ;LD   DE, MsgHello  
77b9			            CALL fLCD_Str       ;Display string pointed to by DE  
77b9			  
77b9				pop af  
77b9			endif  
77b9 cd c2 77			call .mtoc  
77bc c1				pop bc  
77bd b8				cp b  
77be 28 f8			jr z, .cina1  
77c0 78				ld a,b		  
77c1			if DEBUG_KEYCIN  
77c1				push af  
77c1			  
77c1				ld hl,key_repeat_ct  
77c1				inc hl  
77c1				call hexout  
77c1				ld hl,key_repeat_ct+3  
77c1				ld a,0  
77c1				ld (hl),a  
77c1				ld hl,key_repeat_ct  
77c1				ld a, '3'	  
77c1				ld (hl),a  
77c1			  
77c1			            LD   A, kLCD_Line4+15  
77c1			            CALL fLCD_Pos       ;Position cursor to location in A  
77c1			            LD   DE, key_repeat_ct  
77c1			            ;LD   DE, MsgHello  
77c1			            CALL fLCD_Str       ;Display string pointed to by DE  
77c1			  
77c1				pop af  
77c1			endif  
77c1 c9				ret  
77c2			  
77c2			; detect keyboard modifier key press and apply new overlay to the face key held  
77c2			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
77c2			  
77c2			;.cin_map_modifier:   
77c2			;	ld a, (hl)  
77c2			;	and 255  
77c2			;	ret NZ		; modifier key not flagged  
77c2			;  
77c2			;	; get key face  
77c2			;  
77c2			;	ld b,(key_face_held)  
77c2			;  
77c2			;	ld b, key_cols * key_rows  
77c2			;  
77c2			;	push de  
77c2			;	pop hl  
77c2			;  
77c2			;.mmod1: ld a,(hl)   ; get map test  
77c2			;	cp b  
77c2			;	jr z, .mmod2  
77c2			;  
77c2			;  
77c2			;  
77c2			;.mmod2: inc hl    ;   
77c2			;  
77c2			;	  
77c2			;  
77c2			;	  
77c2			;  
77c2			;	ld hl,key_actual_pressed  
77c2			;	ld (hl),a,  
77c2			;	ret  
77c2			  
77c2			; map matrix key held to char on face of key  
77c2			  
77c2			.mtoc:  
77c2			  
77c2			; test decade counter strobes  
77c2			  
77c2			;.decadetest1:  
77c2			  
77c2			; reset counter  
77c2			;ld a, 128  
77c2			;out (portbdata),a  
77c2			  
77c2			  
77c2			;ld b, 5  
77c2			;.dec1:  
77c2			;ld a, 0  
77c2			;out (portbdata),a  
77c2			;call delay1s  
77c2			  
77c2			;ld a, 32  
77c2			;out (portbdata),a  
77c2			;call delay1s  
77c2			;call delay1s  
77c2			;call delay1s  
77c2			;  
77c2			;ld a, 64+32  
77c2			;out (portbdata),a  
77c2			;call delay1s  
77c2			;;djnz .dec1  
77c2			;  
77c2			;jp .decadetest1  
77c2			  
77c2			  
77c2			  
77c2			  
77c2			  
77c2			  
77c2			  
77c2			  
77c2			  
77c2			  
77c2				; scan keyboard matrix and generate raw scan map  
77c2 cd 55 78			call matrix  
77c5			  
77c5				; reuse c bit 0 left modifer button - ie shift  
77c5			        ; reuse c bit 1 for right modifer button - ie symbol shift  
77c5				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
77c5			  
77c5 0e 00			ld c, 0  
77c7			  
77c7				; TODO set flags for modifer key presses   
77c7				; TODO do a search for modifer key...  
77c7			  
77c7				;ld hl,keyscan_table_row4  
77c7 21 e7 fe			ld hl,keyscan_table_row2  
77ca			  
77ca 7e				ld a, (hl)  
77cb fe 23			cp '#'  
77cd 20 07			jr nz, .nextmodcheck  
77cf cb c1			set 0, c  
77d1 21 2f 77			ld hl, .matrix_to_shift  
77d4 18 21			jr .dokeymap  
77d6				; TODO for now igonre  
77d6			.nextmodcheck:  
77d6 21 dc fe			ld hl,keyscan_table_row3  
77d9			  
77d9 7e				ld a, (hl)  
77da fe 23			cp '#'  
77dc 20 07			jr nz, .nextmodcheck2  
77de cb c9			set 1, c   
77e0 21 66 77			ld hl, .matrix_to_symbolshift  
77e3 18 12			jr .dokeymap  
77e5			.nextmodcheck2:  
77e5 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
77e8			  
77e8 7e				ld a, (hl)  
77e9 fe 23			cp '#'  
77eb 20 07			jr nz, .donemodcheck  
77ed cb c9			set 1, c   
77ef 21 2f 77			ld hl, .matrix_to_shift  
77f2 18 03			jr .dokeymap  
77f4			  
77f4				; no modifer found so just map to normal keys  
77f4				; get mtoc map matrix to respective keys  
77f4			;	ld hl, .matrix_to_char  
77f4			;	ld hl, .matrix_to_char  
77f4			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
77f4			;	ld a, KEY_SHIFT  
77f4			;	call findchar  
77f4			;  
77f4			;	; got offset to key modifer in b  
77f4			;  
77f4			;	ld hl,keyscan_table_row5  
77f4			;  
77f4			;	ld a,b  
77f4			;	call addatohl  
77f4			;	ld a,(hl)  
77f4			;  
77f4			;	cp '#'  
77f4			;	jr nz, .nextmodcheck  
77f4			;	set 0, c  
77f4			;	ld hl, .matrix_to_char  
77f4			;	jr .dokeymap  
77f4			;	; TODO for now igonre  
77f4			;.nextmodcheck:  
77f4			;	ld hl, .matrix_to_symbolshift  
77f4			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
77f4			;	ld a, KEY_SYMBOLSHIFT  
77f4			;	call findchar  
77f4			;  
77f4			;  
77f4			;	; got offset to key modifer in b  
77f4			;  
77f4			;	ld hl,keyscan_table_row5  
77f4			;  
77f4			;	ld a,b  
77f4			;	call addatohl  
77f4			;	ld a,(hl)  
77f4			;  
77f4			;	cp '#'  
77f4			;	jr nz, .donemodcheck  
77f4			;	set 1, c   
77f4			;	ld hl, .matrix_to_symbolshift  
77f4			;	jr .dokeymap  
77f4			  
77f4			  
77f4			  
77f4			.donemodcheck:  
77f4				; no modifer found so just map to normal keys  
77f4				; get mtoc map matrix to respective keys  
77f4 21 f8 76			ld hl, .matrix_to_char  
77f7			  
77f7			.dokeymap:  
77f7				;ld (key_fa), c   
77f7 cd 10 78			call .mapkeys  
77fa			  
77fa			  
77fa			if DEBUG_KEY  
77fa			  
77fa			; Display text on first line  
77fa			            LD   A, kLCD_Line1  
77fa			            CALL fLCD_Pos       ;Position cursor to location in A  
77fa			            LD   DE, keyscan_table_row1  
77fa			            ;LD   DE, MsgHello  
77fa			            CALL fLCD_Str       ;Display string pointed to by DE  
77fa			  
77fa			; Display text on second line  
77fa			            LD   A, kLCD_Line2  
77fa			            CALL fLCD_Pos       ;Position cursor to location in A  
77fa			            LD   DE, keyscan_table_row2  
77fa			            CALL fLCD_Str       ;Display string pointed to by DE  
77fa			            LD   A, kLCD_Line3  
77fa			            CALL fLCD_Pos       ;Position cursor to location in A  
77fa			            LD   DE, keyscan_table_row3  
77fa			            CALL fLCD_Str       ;Display string pointed to by DE  
77fa			            LD   A, kLCD_Line4  
77fa			            CALL fLCD_Pos       ;Position cursor to location in A  
77fa			            LD   DE, keyscan_table_row4  
77fa			            CALL fLCD_Str       ;Display string pointed to by DE  
77fa			            LD   A, kLCD_Line1+10  
77fa			            CALL fLCD_Pos       ;Position cursor to location in A  
77fa			            LD   DE, keyscan_table_row5  
77fa			            CALL fLCD_Str       ;Display string pointed to by DE  
77fa			  
77fa				;call delay250ms  
77fa			endif  
77fa			;	jp testkey  
77fa			  
77fa			; get first char reported  
77fa			  
77fa 21 c6 fe			ld hl,keyscan_table_row5  
77fd			  
77fd				;ld b, 46   ; 30 keys to remap + 8 nulls   
77fd 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
77ff			.findkey:  
77ff 7e				ld a,(hl)  
7800 fe 00			cp 0  
7802 28 04			jr z, .nextkey  
7804 fe 7e			cp KEY_MATRIX_NO_PRESS  
7806 20 06			jr nz, .foundkey  
7808			.nextkey:  
7808 23				inc hl  
7809 10 f4			djnz .findkey  
780b 3e 00			ld a,0  
780d c9				ret  
780e			.foundkey:  
780e 7e				ld a,(hl)  
780f c9				ret  
7810				  
7810			  
7810			; convert the raw key map given hl for destination key  
7810			.mapkeys:  
7810 11 c6 fe			ld de,keyscan_table_row5  
7813			  
7813 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7815			.remap:  
7815 1a				ld a,(de)  
7816 fe 23			cp '#'  
7818 20 02			jr nz, .remapnext  
781a				;CALLMONITOR  
781a 7e				ld a,(hl)  
781b 12				ld (de),a  
781c			  
781c			  
781c			  
781c			.remapnext:  
781c 23				inc hl  
781d 13				inc de  
781e 10 f5			djnz .remap  
7820				  
7820 c9				ret  
7821			  
7821			  
7821			  
7821			.mtocold2:  
7821			  
7821			;	; flag if key D is held down and remove from reporting  
7821			;	ld bc, .key_map_fd    
7821			;	ld hl, keyscan_table  
7821			;	ld de, key_fd  
7821			;	call .key_shift_hold  
7821			;	cp 255  
7821			;	jr z, .cinmap  
7821			;	; flag if key C is held down and remove from reporting  
7821			;	ld bc, .key_map_fc    
7821			;	ld hl, keyscan_table+key_cols  
7821			;	ld de, key_fc  
7821			;	call .key_shift_hold  
7821			;	cp 255  
7821			;	jr z, .cinmap  
7821			;	; flag if key B is held down and remove from reporting  
7821			;	ld bc, .key_map_fb    
7821			;	ld hl, keyscan_table+(key_cols*2)  
7821			;	ld de, key_fb  
7821			;	call .key_shift_hold  
7821			;	cp 255  
7821			;	jr z, .cinmap  
7821			;	; flag if key A is held down and remove from reporting  
7821			;	ld bc, .key_map_fa    
7821			;	ld hl, keyscan_table+(key_cols*3)  
7821			;	ld de, key_fa  
7821			;	call .key_shift_hold  
7821			;	cp 255  
7821			;	jr z, .cinmap  
7821			  
7821 11 f8 76			ld de, .matrix_to_char  
7824			  
7824			  
7824			.cinmap1:   
7824				if DEBUG_KEY  
7824			            LD   A, kLCD_Line4  
7824			            CALL fLCD_Pos       ;Position cursor to location in A  
7824					push de  
7824			            LD   DE, keyscan_table  
7824			            CALL fLCD_Str       ;Display string pointed to by DE  
7824					pop de  
7824				endif  
7824			  
7824				; scan key matrix table for any held key  
7824			  
7824				; de holds either the default matrix or one selected above  
7824			  
7824 21 93 fe			ld hl, keyscan_table  
7827 06 32			ld b,key_cols*key_rows  
7829			  
7829 7e			.cin11:	ld a,(hl)  
782a fe 23			cp '#'  
782c 28 08			jr z, .cinhit1  
782e 23				inc hl  
782f 13				inc de  
7830 05				dec b  
7831 20 f6			jr nz, .cin11  
7833				; no key found held  
7833 3e 00			ld a,0  
7835 c9				ret  
7836 d5			.cinhit1: push de  
7837 e1				pop hl  
7838 7e				ld a,(hl)  
7839 c9				ret  
783a			  
783a			; flag a control key is held   
783a			; hl is key pin, de is flag indicator  
783a			  
783a			.key_shift_hold1:  
783a c5				push bc  
783b 3e 01			ld a, 1  
783d 32 c7 fb			ld (cursor_shape),a  
7840 06 00			ld b, 0  
7842 7e				ld a, (hl)  
7843 fe 2e			cp '.'  
7845 28 0a			jr z, .key_shift11  
7847 06 ff			ld b, 255  
7849 3e 2b			ld a, '+'    ; hide key from later scans  
784b 77				ld (hl),a  
784c 3e 02			ld a, 2  
784e 32 c7 fb			ld (cursor_shape),a  
7851			.key_shift11:  
7851				; write flag indicator  
7851 78				ld a,b  
7852 12				ld (de),a  
7853			  
7853 d1				pop de    ; de now holds the key map ptr  
7854 c9				ret  
7855			  
7855				  
7855			  
7855			; scans keyboard matrix and flags key press in memory array	  
7855				  
7855			matrix:  
7855				;call matrix  
7855				; TODO optimise the code....  
7855			  
7855			  
7855			;ld hl, keyscan_table_row1  
7855			;ld de, keyscan_table_row1+1  
7855			;ld bc,46  
7855			;ld a,KEY_MATRIX_NO_PRESS  
7855			;ldir  
7855			  
7855			  
7855			  
7855			; reset counter  
7855 3e 80		ld a, 128  
7857 d3 c1		out (portbdata),a  
7859			  
7859 06 0a		ld b, 10  
785b 0e 00		ld c, 0       ; current clock toggle  
785d			  
785d			.colscan:  
785d			  
785d			; set current column  
785d			; disable clock enable and set clock low  
785d			  
785d			;ld a, 0  
785d			;out (portbdata),a  
785d			  
785d			; For each column scan for switches  
785d			  
785d c5			push bc  
785e 21 89 fe		ld hl, keyscan_scancol  
7861 cd 6a 79		call .rowscan  
7864 c1			pop bc  
7865			  
7865			  
7865			; get back current column  
7865			  
7865			; translate the row scan  
7865			  
7865			;   
7865			; row 1  
7865			  
7865 78			ld a,b  
7866			  
7866 21 fc fe		LD   hl, keyscan_table_row1+10  
7869			  
7869 cd 5e 0f		call subafromhl  
786c			;call addatohl  
786c			  
786c 11 89 fe		ld de, keyscan_scancol  
786f			  
786f 1a			ld a,(de)  
7870 77			ld (hl),a  
7871			  
7871			  
7871			  
7871			  
7871			; row 2  
7871			  
7871 78			ld a,b  
7872			  
7872 21 f1 fe		LD   hl, keyscan_table_row2+10  
7875			  
7875			;call addatohl  
7875 cd 5e 0f		call subafromhl  
7878			  
7878			  
7878 11 8a fe		ld de, keyscan_scancol+1  
787b			  
787b 1a			ld a,(de)  
787c 77			ld (hl),a  
787d			  
787d			  
787d			; row 3  
787d			  
787d 78			ld a,b  
787e			  
787e 21 e6 fe		LD   hl, keyscan_table_row3+10  
7881			  
7881			;call addatohl  
7881 cd 5e 0f		call subafromhl  
7884			  
7884 11 8b fe		ld de, keyscan_scancol+2  
7887			  
7887 1a			ld a,(de)  
7888 77			ld (hl),a  
7889			  
7889			  
7889			  
7889			; row 4  
7889			  
7889 78			ld a,b  
788a			  
788a 21 db fe		LD   hl, keyscan_table_row4+10  
788d			  
788d			;call addatohl  
788d cd 5e 0f		call subafromhl  
7890			  
7890 11 8c fe		ld de, keyscan_scancol+3  
7893			  
7893 1a			ld a,(de)  
7894 77			ld (hl),a  
7895			  
7895			; row 5  
7895			  
7895 78			ld a,b  
7896			  
7896 21 d0 fe		LD   hl, keyscan_table_row5+10  
7899			  
7899			;call addatohl  
7899 cd 5e 0f		call subafromhl  
789c			  
789c 11 8d fe		ld de, keyscan_scancol+4  
789f			  
789f 1a			ld a,(de)  
78a0 77			ld (hl),a  
78a1			  
78a1			; handshake next column  
78a1			  
78a1			  
78a1 3e 40		ld a, 64  
78a3 d3 c1		out (portbdata),a  
78a5			  
78a5 3e 00		ld a, 0  
78a7 d3 c1		out (portbdata),a  
78a9			  
78a9			; toggle clk and move to next column  
78a9			;ld a, 64  
78a9			;cp c  
78a9			;  
78a9			;jr z, .coltoglow  
78a9			;ld c, a  
78a9			;jr .coltog  
78a9			;.coltoglow:  
78a9			;ld c, 0  
78a9			;.coltog:  
78a9			;ld a, c  
78a9			;out (portbdata),a  
78a9			  
78a9 10 b2		djnz .colscan  
78ab			  
78ab 3e 0a		ld a,10  
78ad 21 f2 fe		LD   hl, keyscan_table_row1  
78b0 cd 4c 0f		call addatohl  
78b3 3e 00		ld a, 0  
78b5 77			ld (hl), a  
78b6			  
78b6			  
78b6 3e 0a		ld a,10  
78b8 21 e7 fe		LD   hl, keyscan_table_row2  
78bb cd 4c 0f		call addatohl  
78be 3e 00		ld a, 0  
78c0 77			ld (hl), a  
78c1			  
78c1 3e 0a		ld a,10  
78c3 21 dc fe		LD   hl, keyscan_table_row3  
78c6 cd 4c 0f		call addatohl  
78c9 3e 00		ld a, 0  
78cb 77			ld (hl), a  
78cc			  
78cc 3e 0a		ld a,10  
78ce 21 d1 fe		LD   hl, keyscan_table_row4  
78d1 cd 4c 0f		call addatohl  
78d4 3e 00		ld a, 0  
78d6 77			ld (hl), a  
78d7			  
78d7 3e 0a		ld a,10  
78d9 21 c6 fe		LD   hl, keyscan_table_row5  
78dc cd 4c 0f		call addatohl  
78df 3e 00		ld a, 0  
78e1 77			ld (hl), a  
78e2			  
78e2			if DEBUG_KEY_MATRIX  
78e2			  
78e2			; Display text on first line  
78e2			            LD   A, kLCD_Line1  
78e2			            CALL fLCD_Pos       ;Position cursor to location in A  
78e2			            LD   DE, keyscan_table_row1  
78e2			            ;LD   DE, MsgHello  
78e2			            CALL fLCD_Str       ;Display string pointed to by DE  
78e2			  
78e2			; Display text on second line  
78e2			            LD   A, kLCD_Line2  
78e2			            CALL fLCD_Pos       ;Position cursor to location in A  
78e2			            LD   DE, keyscan_table_row2  
78e2			            CALL fLCD_Str       ;Display string pointed to by DE  
78e2			            LD   A, kLCD_Line3  
78e2			            CALL fLCD_Pos       ;Position cursor to location in A  
78e2			            LD   DE, keyscan_table_row3  
78e2			            CALL fLCD_Str       ;Display string pointed to by DE  
78e2			            LD   A, kLCD_Line4  
78e2			            CALL fLCD_Pos       ;Position cursor to location in A  
78e2			            LD   DE, keyscan_table_row4  
78e2			            CALL fLCD_Str       ;Display string pointed to by DE  
78e2			            LD   A, kLCD_Line4+10  
78e2			            CALL fLCD_Pos       ;Position cursor to location in A  
78e2			            LD   DE, keyscan_table_row5  
78e2			            CALL fLCD_Str       ;Display string pointed to by DE  
78e2			  
78e2			;call delay250ms  
78e2				jp matrix  
78e2			endif  
78e2 c9			ret  
78e3			  
78e3			; using decade counter....  
78e3			  
78e3			  
78e3			; TODO reset decade counter to start of scan  
78e3			  
78e3			; reset 15  
78e3			; clock 14  
78e3			; ce 13  
78e3			  
78e3			; 1 - q5  
78e3			; 2 - q1  
78e3			; 3 - q0  
78e3			; 4 - q2  
78e3			; 5 - q6  
78e3			; 6 - q7  
78e3			; 7 - q3  
78e3			; 8 - vss  
78e3			; 9 - q8  
78e3			; 10 - q4  
78e3			; 11 - q9  
78e3			; 12 - cout  
78e3			; 16 - vdd  
78e3			  
78e3			; clock      ce       reset     output  
78e3			; 0          x        0         n  
78e3			; x          1        0         n  
78e3			; x          x        1         q0  
78e3			; rising     0        0         n+1  
78e3			; falling    x        0         n  
78e3			; x          rising   0         n  
78e3			; 1          falling  0         x+1  
78e3			;  
78e3			; x = dont care, if n < 5 carry = 1 otherwise 0  
78e3			  
78e3			;   
78e3			; reset   
78e3			; 13=0, 14=0, 15=1 .. 15=0  
78e3			;  
78e3			; handshake line  
78e3			; 14=1.... read line 14=0  
78e3			  
78e3			  
78e3			  
78e3			  
78e3			  
78e3			; TODO hand shake clock for next column scan  
78e3			; TODO detect each row  
78e3			  
78e3			  
78e3			  
78e3			  
78e3			; reset 128  
78e3			; clock 64  
78e3			; ce 32  
78e3			  
78e3			  
78e3			.cyclestart:  
78e3			  
78e3			; reset counter  
78e3 3e 80		ld a, 128  
78e5 d3 c1		out (portbdata),a  
78e7			  
78e7			; loop leds  
78e7 06 0a		ld b,10  
78e9			  
78e9			.cycle1:  
78e9 c5			push bc  
78ea 3e 00		ld a, 0  
78ec d3 c1		out (portbdata),a  
78ee cd 89 0c		call delay250ms  
78f1			  
78f1 3e 40		ld a, 64  
78f3 d3 c1		out (portbdata),a  
78f5 cd 89 0c		call delay250ms  
78f8			  
78f8 3e 00		ld a, 0  
78fa d3 c1		out (portbdata),a  
78fc cd 89 0c		call delay250ms  
78ff			  
78ff c1			pop bc  
7900 10 e7		djnz .cycle1  
7902			  
7902			  
7902 18 df		jr .cyclestart  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			; map matrix key held to char on face of key  
7904			  
7904			;.mtocold:  
7904			;  
7904			;  
7904			;; reset counter  
7904			;ld a, 128  
7904			;out (portbdata),a  
7904			;  
7904			;  
7904			;; scan keyboard row 1  
7904			;ld a, 0  
7904			;out (portbdata),a  
7904			;;ld a, 64  
7904			;;out (portbdata),a  
7904			;  
7904			;  
7904			;	ld a, 128  
7904			;	ld hl, keyscan_table  
7904			;	call .rowscan  
7904			;  
7904			;;ld a, 0  
7904			;;out (portbdata),a  
7904			;ld a, 64  
7904			;out (portbdata),a  
7904			;  
7904			;	ld a, 64  
7904			;	ld hl, keyscan_table+key_cols  
7904			;	call .rowscan  
7904			;  
7904			;ld a, 0  
7904			;out (portbdata),a  
7904			;;ld a, 64  
7904			;;out (portbdata),a  
7904			;	ld a, 32  
7904			;	ld hl, keyscan_table+(key_cols*2)  
7904			;	call .rowscan  
7904			;  
7904			;  
7904			;;ld a, 0  
7904			;;out (portbdata),a  
7904			;ld a, 64  
7904			;out (portbdata),a  
7904			;  
7904			;	ld a, 16  
7904			;	ld hl, keyscan_table+(key_cols*3)  
7904			;	call .rowscan  
7904			;  
7904			;  
7904			;	; flag if key D is held down and remove from reporting  
7904			;	ld bc, .key_map_fd    
7904			;	ld hl, keyscan_table  
7904			;	ld de, key_fd  
7904			;	call .key_shift_hold  
7904			;	cp 255  
7904			;	jr z, .cinmap  
7904			;	; flag if key C is held down and remove from reporting  
7904			;	ld bc, .key_map_fc    
7904			;	ld hl, keyscan_table+key_cols  
7904			;	ld de, key_fc  
7904			;	call .key_shift_hold  
7904			;	cp 255  
7904			;	jr z, .cinmap  
7904			;	; flag if key B is held down and remove from reporting  
7904			;	ld bc, .key_map_fb    
7904			;	ld hl, keyscan_table+(key_cols*2)  
7904			;	ld de, key_fb  
7904			;	call .key_shift_hold  
7904			;	cp 255  
7904			;	jr z, .cinmap  
7904			;	; flag if key A is held down and remove from reporting  
7904			;	ld bc, .key_map_fa    
7904			;	ld hl, keyscan_table+(key_cols*3)  
7904			;	ld de, key_fa  
7904			;	call .key_shift_hold  
7904			;	cp 255  
7904			;	jr z, .cinmap  
7904			;  
7904			;	ld de, .matrix_to_char  
7904			;  
7904			;  
7904			;.cinmap:   
7904			;	if DEBUG_KEY  
7904			;            LD   A, kLCD_Line4  
7904			;            CALL fLCD_Pos       ;Position cursor to location in A  
7904			;		push de  
7904			;            LD   DE, keyscan_table  
7904			;            CALL fLCD_Str       ;Display string pointed to by DE  
7904			;		pop de  
7904			;	endif  
7904			  
7904				; scan key matrix table for any held key  
7904			  
7904				; de holds either the default matrix or one selected above  
7904			  
7904			;	ld hl, keyscan_table  
7904			;	ld b,key_cols*key_rows  
7904			;  
7904			;.cin1:	ld a,(hl)  
7904			;	cp '#'  
7904			;	jr z, .cinhit  
7904			;	inc hl  
7904			;	inc de  
7904			;	dec b  
7904			;	jr nz, .cin1  
7904			;	; no key found held  
7904			;	ld a,0  
7904			;	ret  
7904			;.cinhit: push de  
7904			;	pop hl  
7904			;	ld a,(hl)  
7904			;	ret  
7904			  
7904			; flag a control key is held   
7904			; hl is key pin, de is flag indicator  
7904			  
7904			;.key_shift_hold:  
7904			;	push bc  
7904			;	ld a, 1  
7904			;	ld (cursor_shape),a  
7904			;	ld b, 0  
7904			;	ld a, (hl)  
7904			;	cp '.'  
7904			;	jr z, .key_shift1  
7904			;	ld b, 255  
7904			;	ld a, '+'    ; hide key from later scans  
7904			;	ld (hl),a  
7904			;	ld a, 2  
7904			;	ld (cursor_shape),a  
7904			;.key_shift1:  
7904			;	; write flag indicator  
7904			;	ld a,b  
7904			;	ld (de),a  
7904			;  
7904			;	pop de    ; de now holds the key map ptr  
7904			;	ret  
7904			  
7904				  
7904				  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			  
7904			;	push hl  
7904			;	push de  
7904			;	push bc  
7904			;	call keyscan  
7904			;	; map key matrix to ascii value of key face  
7904			;  
7904			;	ld hl, key_face_map  
7904			;	ld de, keyscan_table  
7904			;  
7904			;	; get how many keys to look at  
7904			;	ld b, keyscan_table_len  
7904			;	  
7904			;  
7904			;	; at this stage fall out on first key hit  
7904			;	; TODO handle multiple key press  
7904			;  
7904			;map1:	ld a,(hl)  
7904			;	cp '#'  
7904			;	jr z, keyhit  
7904			;	inc hl  
7904			;	inc de  
7904			;	dec b  
7904			;	jr nz, map1  
7904			;nohit:	ld a, 0  
7904			;	jr keydone  
7904			;keyhit: push de  
7904			;	pop hl  
7904			;	ld a,(hl)  
7904			;keydone:  
7904			;	push bc  
7904			;	push de  
7904			; 	push hl  
7904			;	ret   
7904			;  
7904			  
7904			  
7904			  
7904			  
7904			; scan physical key matrix  
7904			  
7904			  
7904			;keyscan:  
7904			;  
7904			;; for each key_row use keyscanr bit mask for out  
7904			;; then read in for keyscanc bitmask  
7904			;; save result of row scan to keyscantable  
7904			;  
7904			;; scan keyboard row 1  
7904			;  
7904			;	ld b, key_rows  
7904			;	ld hl, key_scanr  
7904			;	ld de, keyscan_table  
7904			;  
7904			;rowloop:  
7904			;  
7904			;	ld a,(hl)		; out bit mask to energise keyboard row  
7904			;	call rowscan  
7904			;	inc hl  
7904			;	dec b  
7904			;	jr nz, rowloop  
7904			;  
7904			;	ret  
7904			;  
7904			;  
7904			;; pass a out bitmask, b row number  
7904			;arowscan:   
7904			;	push bc  
7904			;  
7904			;	ld d, b  
7904			;  
7904			;	; calculate buffer location for this row  
7904			;  
7904			;	ld hl, keyscan_table	  
7904			;kbufr:  ld e, key_cols  
7904			;kbufc:	inc hl  
7904			;	dec e  
7904			;	jr nz, kbufc  
7904			;	dec d  
7904			;	jr nz, kbufr  
7904			;  
7904			;	; energise row and read columns  
7904			;  
7904			;	out (portbdata),a  
7904			;	in a,(portbdata)  
7904			;	ld c,a  
7904			;  
7904			;  
7904			;	; save buffer loc  
7904			;  
7904			;	ld (keybufptr), hl  
7904			;  
7904			;	ld hl, key_scanc  
7904			;	ld d, key_cols  
7904			;  
7904			;	; for each column check each bit mask  
7904			;  
7904			;colloop:  
7904			;	  
7904			;  
7904			;	; reset flags for the row   
7904			;  
7904			;	ld b,'.'  
7904			;	and (hl)  
7904			;	jr z, maskskip  
7904			;	ld b,'#'  
7904			;maskskip:  
7904			;	; save  key state  
7904			;	push hl  
7904			;	ld hl, (keybufptr)  
7904			;	ld (hl), b  
7904			;	inc hl  
7904			;	ld (keybufptr), hl  
7904			;  
7904			;	; move to next bit mask  
7904			;	pop hl  
7904			;	inc hl  
7904			;  
7904			;	dec d  
7904			;	jr nz, colloop  
7904			;  
7904			;	ret  
7904			;  
7904			;  
7904			;;  
7904			; lcd functions  
7904			;  
7904			;  
7904			  
7904			;if DEBUG_KEY_MATRIX  
7904			  
7904			; test function to display hardware view of matrix state  
7904			  
7904			matrixold:  
7904			  
7904			  
7904			  
7904			; reset counter  
7904 3e 80		ld a, 128  
7906 d3 c1		out (portbdata),a  
7908			; scan keyboard row 1  
7908 3e 00		ld a, 0  
790a d3 c1		out (portbdata),a  
790c			;ld a, 64  
790c			;out (portbdata),a  
790c 3e 80			ld a, 128  
790e 21 f2 fe			ld hl, keyscan_table_row1  
7911 cd 6a 79			call .rowscan  
7914			  
7914			;ld a, 0  
7914			;out (portbdata),a  
7914 3e 40		ld a, 64  
7916 d3 c1		out (portbdata),a  
7918 3e 40			ld a, 64  
791a 21 e7 fe			ld hl, keyscan_table_row2  
791d cd 6a 79			call .rowscan  
7920			  
7920 3e 00		ld a, 0  
7922 d3 c1		out (portbdata),a  
7924			;ld a, 64  
7924			;out (portbdata),a  
7924 3e 20			ld a, 32  
7926 21 dc fe			ld hl, keyscan_table_row3  
7929 cd 6a 79			call .rowscan  
792c			  
792c			;ld a, 0  
792c			;out (portbdata),a  
792c 3e 40		ld a, 64  
792e d3 c1		out (portbdata),a  
7930 3e 10			ld a, 16  
7932 21 d1 fe			ld hl, keyscan_table_row4  
7935 cd 6a 79			call .rowscan  
7938			  
7938			; Display text on first line  
7938 3e 00		            LD   A, kLCD_Line1  
793a cd 72 75		            CALL fLCD_Pos       ;Position cursor to location in A  
793d 11 f2 fe		            LD   DE, keyscan_table_row1  
7940			            ;LD   DE, MsgHello  
7940 cd 94 75		            CALL fLCD_Str       ;Display string pointed to by DE  
7943			  
7943			; Display text on second line  
7943 3e 28		            LD   A, kLCD_Line2  
7945 cd 72 75		            CALL fLCD_Pos       ;Position cursor to location in A  
7948 11 e7 fe		            LD   DE, keyscan_table_row2  
794b cd 94 75		            CALL fLCD_Str       ;Display string pointed to by DE  
794e 3e 50		            LD   A, kLCD_Line3  
7950 cd 72 75		            CALL fLCD_Pos       ;Position cursor to location in A  
7953 11 dc fe		            LD   DE, keyscan_table_row3  
7956 cd 94 75		            CALL fLCD_Str       ;Display string pointed to by DE  
7959 3e 78		            LD   A, kLCD_Line4  
795b cd 72 75		            CALL fLCD_Pos       ;Position cursor to location in A  
795e 11 d1 fe		            LD   DE, keyscan_table_row4  
7961 cd 94 75		            CALL fLCD_Str       ;Display string pointed to by DE  
7964			  
7964 cd 89 0c			call delay250ms  
7967 c3 55 78			jp matrix  
796a			  
796a			; pass de as row display flags  
796a			.rowscan:   
796a			;	out (portbdata),a  
796a db c1			in a,(portbdata)  
796c 4f				ld c,a  
796d				; reset flags for the row   
796d 06 7e			ld b,KEY_MATRIX_NO_PRESS  
796f e6 01			and 1  
7971 28 02			jr z, .p1on  
7973 06 23			ld b,'#'  
7975			.p1on:  
7975 70				ld (hl), b  
7976 23				inc hl  
7977			  
7977 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7979 79				ld a,c  
797a e6 02			and 2  
797c			;	bit 0,a  
797c 28 02			jr z, .p2on  
797e 06 23			ld b,'#'  
7980			.p2on:  
7980 70				ld (hl), b  
7981 23				inc hl  
7982			;  
7982 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7984 79				ld a,c  
7985 e6 04			and 4  
7987			;;	bit 0,a  
7987 28 02			jr z, .p3on  
7989 06 23			ld b,'#'  
798b			.p3on:  
798b 70				ld (hl), b  
798c 23				inc hl  
798d			;;  
798d 06 7e			ld b,KEY_MATRIX_NO_PRESS  
798f			;;	bit 0,a  
798f 79				ld a,c  
7990 e6 08			and 8  
7992 28 02			jr z, .p4on  
7994 06 23			ld b,'#'  
7996			.p4on:  
7996 70				ld (hl), b  
7997 23				inc hl  
7998			  
7998 06 7e			ld b,KEY_MATRIX_NO_PRESS  
799a			;;	bit 0,a  
799a 79				ld a,c  
799b e6 10			and 16  
799d 28 02			jr z, .p5on  
799f 06 23			ld b,'#'  
79a1			.p5on:  
79a1 70				ld (hl), b  
79a2 23				inc hl  
79a3			; zero term  
79a3 06 00			ld b,0  
79a5 70				ld (hl), b  
79a6			  
79a6 c9			.rscandone: ret  
79a7			  
79a7			;addatohl:  
79a7			;  
79a7			 ;add   a, l    ; A = A+L  
79a7			  ;  ld    l, a    ; L = A+L  
79a7			   ; adc   a, h    ; A = A+L+H+carry  
79a7			   ; sub   l       ; A = H+carry  
79a7			   ; ld    h, a    ; H = H+carry  
79a7			  
79a7			;ret  
79a7			; eof  
# End of file firmware_key_5x10.asm
79a7			;include "firmware_key_4x10.asm" 
79a7			 
79a7			heap_size:    equ heap_end - heap_start 
79a7			;eof 
# End of file os_mega.asm
79a7
