# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 51 16			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 512*2  
0103			  
0103			STACK_RET_SIZE: equ 128  
0103			STACK_LOOP_SIZE: equ 512  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 256  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $20  
0103			  
0103			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_AUTOFILE: equ $21  
0103			STORE_0_BANKRUN: equ $23  
0103			STORE_0_FILERUN: equ $24  
0103			  
0103			; Block 0 offsets for settings  
0103			  
0103			; if set then skip prompt for start up and accept all  
0103			  
0103			STORE_0_QUICKSTART: equ $25  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0103			  
0103			hardware_config: equ key_face_held - 10  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_config - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103				  
0103			  
0103					;ld a, 0  
0103					;ld (hardware_diag), a  
0103			  
0103					; clear all the buffers  
0103			  
0103 21 16 ed				ld hl, display_fb1  
0106 22 d2 eb				ld (display_fb_active), hl  
0109			  
0109 cd 80 09				call clear_display  
010c			  
010c 21 d4 eb				ld hl, display_fb2  
010f 22 d2 eb				ld (display_fb_active), hl  
0112			  
0112 cd 80 09				call clear_display  
0115			  
0115					; init primary frame buffer area  
0115 21 b7 ed				ld hl, display_fb0  
0118 22 d2 eb				ld (display_fb_active), hl  
011b			  
011b cd 80 09				call clear_display  
011e			  
011e			  
011e cd 36 58				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0121			  
0121 cd 24 59			call key_init  
0124 cd 86 01			call storage_init  
0127			  
0127				; setup malloc functions  
0127			  
0127				if MALLOC_1  
0127 cd 50 10				call  heap_init  
012a				endif  
012a				if MALLOC_4  
012a					call  heap_init  
012a				endif  
012a			  
012a				; init sound hardware if present  
012a			  
012a				if SOUND_ENABLE  
012a					call sound_init  
012a				endif  
012a			  
012a				; lcd test sequence  
012a					  
012a cd a3 09			call update_display  
012d cd f2 08			call delay1s  
0130 3e 2b			ld a,'+'  
0132 cd 85 09			call fill_display  
0135 cd a3 09			call update_display  
0138 cd f2 08			call delay1s  
013b 3e 2a			ld a,'*'  
013d cd 85 09			call fill_display  
0140 cd a3 09			call update_display  
0143 cd f2 08			call delay1s  
0146 3e 2d			ld a,'-'  
0148 cd 85 09			call fill_display  
014b cd a3 09			call update_display  
014e cd f2 08			call delay1s  
0151			  
0151			; boot splash screen  
0151			if display_cols == 20	  
0151			        ld a, display_row_1    
0151			else  
0151 3e 0a		        ld a, display_row_1 +10   
0153			endif  
0153 11 84 15			ld de, prom_bootmsg  
0156 cd 93 09			call str_at_display  
0159 cd a3 09			call update_display  
015c			  
015c			  
015c cd f2 08			call delay1s  
015f cd f2 08			call delay1s  
0162			if display_cols == 20	  
0162			            LD   A, display_row_3+2  
0162			else  
0162 3e 5c		            LD   A, display_row_3+12  
0164			endif  
0164 11 99 15			ld de, prom_bootmsg1  
0167 cd 93 09			call str_at_display  
016a cd a3 09			call update_display  
016d cd f2 08			call delay1s  
0170 cd f2 08			call delay1s  
0173			  
0173			;	ld a, display_row_4+3  
0173			;	ld de, bootmsg2  
0173			;	call str_at_display  
0173			;	call update_display  
0173			;	call delay1s  
0173			;	call delay1s  
0173			  
0173			; debug mark setup  
0173			  
0173 3e 5f		ld a, '_'  
0175 32 71 ee		ld (debug_mark),a  
0178 32 72 ee		ld (debug_mark+1),a  
017b 32 73 ee		ld (debug_mark+2),a  
017e 3e 00		ld a,0  
0180 32 74 ee		ld (debug_mark+3),a  
0183			  
0183 c9					ret  
0184			  
0184			  
0184			;bootmsg2:	db "Firmware v0.1",0  
0184			  
0184			; a 4x20 lcd  
0184			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
0184			  
0184			;if display_cols == 20  
0184			;	include "firmware_lcd_4x20.asm"  
0184			;endif  
0184			  
0184			;if display_cols == 40  
0184			;	include "firmware_lcd_4x40.asm"  
0184			;endif  
0184			  
0184			;  
0184			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
0184			; TODO abstract the bit bang video out interface for dual display  
0184			; TODO wire video out to tx pin on rc2014 bus  
0184			  
0184			; must supply cin, and cin_wait for low level hardware abstraction   
0184			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
0184			; test scancode  
0184			  
0184			;;;;;  
0184			;;;  
0184			; Moved out to mini and maxi versions  
0184			;  
0184			; include "firmware_key_4x4.asm"  
0184			; using existing 4 wire x 4 resistor array for input  
0184			;include "firmware_key_4x10.asm"  
0184			; need to mod the board for 5 rows due to resistor array  
0184			;include "firmware_key_5x10.asm"  
0184			  
0184			; storage hardware interface  
0184			  
0184			; use microchip serial eeprom for storage  
0184			  
0184			  
0184			if STORAGE_SE  
0184				include "firmware_spi.asm"  
0184				include "firmware_seeprom.asm"  
0184			else  
0184			   ; create some stubs for the labels  
0184 c9			se_readbyte: ret  
0185 c9			se_writebyte: ret  
0186 c9			storage_init: ret  
0187			  
0187			endif  
0187			  
0187			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0187			;include "firmware_cf.asm"  
0187			  
0187			; load up high level storage hardward abstractions  
0187			include "firmware_storage.asm"  
0187			 
0187			; persisent storage hardware abstraction layer  
0187			 
0187			 
0187			 
0187			; Block 0 on storage is a config state 
0187			 
0187			 
0187			 
0187			; TODO add read phy block and write phy block functions 
0187			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0187			 
0187			; Abstraction layer  
0187			 
0187			; Logocial block size is same size as physical size - using tape concept 
0187			 
0187			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0187			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0187			 
0187			 
0187			 
0187			; Filesystem layout (Logical layout) 
0187			; 
0187			; Block 0 - Bank config  
0187			; 
0187			;      Byte - 0 file id counter 
0187			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0187			;      Byte - 3-20 zero terminated bank label 
0187			; 
0187			; Block 1 > File storage 
0187			; 
0187			;      Byte 0 file id    - block 0 file details 
0187			;      Byte 1 block id - block 0 is file  
0187			;            Byte 2-15 - File name 
0187			; 
0187			;       - to end of block data 
0187			; 
0187			 
0187			 
0187			; Read Block 
0187			; ---------- 
0187			; 
0187			; With current bank 
0187			;  
0187			; Get block number to read 
0187			; Load physical blocks starting at start block into buffer 
0187			 
0187			; de points to buffer to use 
0187			; hl holds logical block number  
0187			 
0187			storage_read_block: 
0187			 
0187				; TODO bank selection 
0187			 
0187				; for each of the physical blocks read it into the buffer 
0187 06 40			ld b, STORE_BLOCK_PHY 
0189			 
0189				if DEBUG_STORESE 
0189 d5					push de 
018a				endif 
018a				 
018a			.rl1:    
018a			 
018a				; read physical block at hl into de 
018a			        ; increment hl and de to next read position on exit 
018a			 
018a e5				push hl 
018b d5				push de	 
018c c5				push bc 
018d			;	if DEBUG_STORESE 
018d			;		push af 
018d			;		ld a, 'R' 
018d			;		ld (debug_mark),a 
018d			;		pop af 
018d			;		CALLMONITOR 
018d			;	endif 
018d cd 84 01			call se_readbyte 
0190			;	if DEBUG_STORESE 
0190			;		ld a,(spi_portbyte) 
0190			;		ld l, a 
0190			;		push af 
0190			;		ld a, '1' 
0190			;		ld (debug_mark),a 
0190			;		pop af 
0190			;		CALLMONITOR 
0190			;	endif 
0190 c1				pop bc 
0191 d1				pop de 
0192 e1				pop hl 
0193 12				ld (de),a 
0194 23				inc hl 
0195 13				inc de 
0196			 
0196			;	if DEBUG_STORESE 
0196			;		push af 
0196			;		ld a, 'r' 
0196			;		ld (debug_mark),a 
0196			;		pop af 
0196			;		CALLMONITOR 
0196			;	endif 
0196			 
0196 10 f2			djnz .rl1 
0198			 
0198				if DEBUG_STORESE 
0198					DMARK "SRB" 
0198 f5				push af  
0199 3a ad 01			ld a, (.dmark)  
019c 32 71 ee			ld (debug_mark),a  
019f 3a ae 01			ld a, (.dmark+1)  
01a2 32 72 ee			ld (debug_mark+1),a  
01a5 3a af 01			ld a, (.dmark+2)  
01a8 32 73 ee			ld (debug_mark+2),a  
01ab 18 03			jr .pastdmark  
01ad ..			.dmark: db "SRB"  
01b0 f1			.pastdmark: pop af  
01b1			endm  
# End of macro DMARK
01b1 d1					pop de 
01b2			; 
01b2			;		push af 
01b2			;		ld a, 'R' 
01b2			;		ld (debug_mark),a 
01b2			;		pop af 
01b2					CALLMONITOR 
01b2 cd ae 13			call break_point_state  
01b5				endm  
# End of macro CALLMONITOR
01b5				endif 
01b5 c9				ret	 
01b6				 
01b6			 
01b6			; File Size 
01b6			; --------- 
01b6			; 
01b6			;   hl file id 
01b6			; 
01b6			;  returns in hl the number of blocks 
01b6			 
01b6			storage_file_size: 
01b6 5d				ld e, l 
01b7 16 00			ld d, 0 
01b9 21 40 00			ld hl, STORE_BLOCK_PHY 
01bc					if DEBUG_FORTH_WORDS 
01bc						DMARK "SIZ" 
01bc f5				push af  
01bd 3a d1 01			ld a, (.dmark)  
01c0 32 71 ee			ld (debug_mark),a  
01c3 3a d2 01			ld a, (.dmark+1)  
01c6 32 72 ee			ld (debug_mark+1),a  
01c9 3a d3 01			ld a, (.dmark+2)  
01cc 32 73 ee			ld (debug_mark+2),a  
01cf 18 03			jr .pastdmark  
01d1 ..			.dmark: db "SIZ"  
01d4 f1			.pastdmark: pop af  
01d5			endm  
# End of macro DMARK
01d5						CALLMONITOR 
01d5 cd ae 13			call break_point_state  
01d8				endm  
# End of macro CALLMONITOR
01d8					endif 
01d8 cd ba 04			call storage_findnextid 
01db			 
01db cd d6 0b			call ishlzero 
01de			;	ld a, l 
01de			;	add h 
01de			;	cp 0 
01de c8				ret z			; block not found so EOF 
01df			 
01df 11 5c eb			ld de, store_page 
01e2 cd 87 01			call storage_read_block 
01e5			 
01e5 3a 5e eb			ld a, (store_page+2)	 ; get extent count 
01e8 6f				ld l, a 
01e9 26 00			ld h, 0 
01eb c9			 	ret 
01ec			 
01ec			 
01ec			; Write Block 
01ec			; ----------- 
01ec			; 
01ec			; With current bank 
01ec			;  
01ec			; Get block number to write 
01ec			; Write physical blocks starting at start block from buffer 
01ec			  
01ec			storage_write_block: 
01ec				; TODO bank selection 
01ec			 
01ec				; for each of the physical blocks read it into the buffer 
01ec 06 40			ld b, STORE_BLOCK_PHY 
01ee			 
01ee				if DEBUG_STORESE 
01ee					DMARK "SWB" 
01ee f5				push af  
01ef 3a 03 02			ld a, (.dmark)  
01f2 32 71 ee			ld (debug_mark),a  
01f5 3a 04 02			ld a, (.dmark+1)  
01f8 32 72 ee			ld (debug_mark+1),a  
01fb 3a 05 02			ld a, (.dmark+2)  
01fe 32 73 ee			ld (debug_mark+2),a  
0201 18 03			jr .pastdmark  
0203 ..			.dmark: db "SWB"  
0206 f1			.pastdmark: pop af  
0207			endm  
# End of macro DMARK
0207			 
0207					;push af 
0207					;ld a, 'W' 
0207					;ld (debug_mark),a 
0207					;pop af 
0207					CALLMONITOR 
0207 cd ae 13			call break_point_state  
020a				endm  
# End of macro CALLMONITOR
020a				endif 
020a			 
020a			; might not be working 
020a			;	call se_writepage 
020a			 
020a			;	ret 
020a			; 
020a			 
020a			 
020a			 
020a			.wl1:    
020a			 
020a				; read physical block at hl into de 
020a			        ; increment hl and de to next read position on exit 
020a			 
020a e5				push hl 
020b d5				push de	 
020c c5				push bc 
020d 1a				ld a,(de) 
020e				;if DEBUG_STORESE 
020e			;		push af 
020e			;		ld a, 'W' 
020e			;		ld (debug_mark),a 
020e			;		pop af 
020e			;		CALLMONITOR 
020e			;	endif 
020e cd 85 01			call se_writebyte 
0211			;	call delay250ms 
0211 00				nop 
0212 00				nop 
0213 00				nop 
0214			;	if DEBUG_STORESE 
0214			;		push af 
0214			;		ld a, 'w' 
0214			;		ld (debug_mark),a 
0214			;		pop af 
0214			;		CALLMONITOR 
0214			;	endif 
0214 c1				pop bc 
0215 d1				pop de 
0216 e1				pop hl 
0217 23				inc hl 
0218 13				inc de 
0219			 
0219			 
0219 10 ef			djnz .wl1 
021b			 
021b				if DEBUG_STORESE 
021b					DMARK "SW2" 
021b f5				push af  
021c 3a 30 02			ld a, (.dmark)  
021f 32 71 ee			ld (debug_mark),a  
0222 3a 31 02			ld a, (.dmark+1)  
0225 32 72 ee			ld (debug_mark+1),a  
0228 3a 32 02			ld a, (.dmark+2)  
022b 32 73 ee			ld (debug_mark+2),a  
022e 18 03			jr .pastdmark  
0230 ..			.dmark: db "SW2"  
0233 f1			.pastdmark: pop af  
0234			endm  
# End of macro DMARK
0234			 
0234					;push af 
0234					;ld a, 'W' 
0234					;ld (debug_mark),a 
0234					;pop af 
0234					CALLMONITOR 
0234 cd ae 13			call break_point_state  
0237				endm  
# End of macro CALLMONITOR
0237				endif 
0237 c9				ret	 
0238			 
0238			; Init bank 
0238			; --------- 
0238			; 
0238			; With current bank 
0238			; 
0238			; Setup block 0 config 
0238			;     Set 0 file id counter 
0238			;     Set formatted byte pattern 
0238			;     Zero out bank label 
0238			;      
0238			; For every logical block write 0-1 byte as null 
0238			 
0238			storage_get_block_0: 
0238			 
0238				; TODO check presence 
0238			 
0238				; get block 0 config 
0238			 
0238 21 00 00			ld hl, 0 
023b 11 5c eb			ld de, store_page 
023e cd 87 01			call storage_read_block 
0241			 
0241				if DEBUG_STORESE 
0241					DMARK "SB0" 
0241 f5				push af  
0242 3a 56 02			ld a, (.dmark)  
0245 32 71 ee			ld (debug_mark),a  
0248 3a 57 02			ld a, (.dmark+1)  
024b 32 72 ee			ld (debug_mark+1),a  
024e 3a 58 02			ld a, (.dmark+2)  
0251 32 73 ee			ld (debug_mark+2),a  
0254 18 03			jr .pastdmark  
0256 ..			.dmark: db "SB0"  
0259 f1			.pastdmark: pop af  
025a			endm  
# End of macro DMARK
025a 11 5c eb				ld de, store_page 
025d			;		push af 
025d			;		ld a, 'i' 
025d			;		ld (debug_mark),a 
025d			;		pop af 
025d					CALLMONITOR 
025d cd ae 13			call break_point_state  
0260				endm  
# End of macro CALLMONITOR
0260				endif 
0260			 
0260				; is this area formatted? 
0260			 
0260			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0260 2a 5d eb			ld hl, (store_page+1) 
0263 3e 80			ld a,0x80 
0265 bd				cp l 
0266 20 22			jr nz, .ininotformatted 
0268				; do a double check 
0268 3e 27			ld a, 0x27 
026a bc				cp h 
026b 20 1d			jr nz, .ininotformatted 
026d			 
026d				; formatted then 
026d			 
026d				if DEBUG_STORESE 
026d					DMARK "SB1" 
026d f5				push af  
026e 3a 82 02			ld a, (.dmark)  
0271 32 71 ee			ld (debug_mark),a  
0274 3a 83 02			ld a, (.dmark+1)  
0277 32 72 ee			ld (debug_mark+1),a  
027a 3a 84 02			ld a, (.dmark+2)  
027d 32 73 ee			ld (debug_mark+2),a  
0280 18 03			jr .pastdmark  
0282 ..			.dmark: db "SB1"  
0285 f1			.pastdmark: pop af  
0286			endm  
# End of macro DMARK
0286					;push af 
0286					;ld a, 'I' 
0286					;ld (debug_mark),a 
0286					;pop af 
0286					CALLMONITOR 
0286 cd ae 13			call break_point_state  
0289				endm  
# End of macro CALLMONITOR
0289				endif 
0289 c9				ret 
028a			 
028a			.ininotformatted: 
028a				; bank not formatted so poke various bits to make sure 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SB2" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 71 ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 72 ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 73 ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SB2"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3					;push af 
02a3					;ld a, 'f' 
02a3					;ld (debug_mark),a 
02a3					;pop af 
02a3					CALLMONITOR 
02a3 cd ae 13			call break_point_state  
02a6				endm  
# End of macro CALLMONITOR
02a6				endif 
02a6			 
02a6 cd b5 08			call storage_clear_page 
02a9			 
02a9 21 5c eb			ld hl, store_page 
02ac 3e 00			ld a, 0 
02ae				 
02ae 77				ld (hl),a   ; reset file counter 
02af			 
02af 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02b2 22 5d eb		 	ld (store_page+1), hl	 
02b5			 
02b5				; set default label 
02b5			 
02b5 21 51 03			ld hl, .defaultbanklabl 
02b8 11 5f eb		 	ld de, store_page+3 
02bb 01 0f 00			ld bc, 15 
02be ed b0			ldir 
02c0			 
02c0				; Append the current bank id 
02c0 21 68 eb			ld hl, store_page+3+9 
02c3 3a 41 eb			ld a, (spi_device_id) 
02c6 77				ld (hl), a 
02c7			 
02c7				; save default page 0 
02c7			 
02c7 21 00 00			ld hl, 0 
02ca 11 5c eb			ld de, store_page 
02cd				if DEBUG_STORESE 
02cd					DMARK "SB3" 
02cd f5				push af  
02ce 3a e2 02			ld a, (.dmark)  
02d1 32 71 ee			ld (debug_mark),a  
02d4 3a e3 02			ld a, (.dmark+1)  
02d7 32 72 ee			ld (debug_mark+1),a  
02da 3a e4 02			ld a, (.dmark+2)  
02dd 32 73 ee			ld (debug_mark+2),a  
02e0 18 03			jr .pastdmark  
02e2 ..			.dmark: db "SB3"  
02e5 f1			.pastdmark: pop af  
02e6			endm  
# End of macro DMARK
02e6			;		push af 
02e6			;		ld a, 'F' 
02e6			;		ld (debug_mark),a 
02e6			;		pop af 
02e6					CALLMONITOR 
02e6 cd ae 13			call break_point_state  
02e9				endm  
# End of macro CALLMONITOR
02e9				endif 
02e9 cd ec 01			call storage_write_block 
02ec				if DEBUG_STORESE 
02ec					DMARK "SB4" 
02ec f5				push af  
02ed 3a 01 03			ld a, (.dmark)  
02f0 32 71 ee			ld (debug_mark),a  
02f3 3a 02 03			ld a, (.dmark+1)  
02f6 32 72 ee			ld (debug_mark+1),a  
02f9 3a 03 03			ld a, (.dmark+2)  
02fc 32 73 ee			ld (debug_mark+2),a  
02ff 18 03			jr .pastdmark  
0301 ..			.dmark: db "SB4"  
0304 f1			.pastdmark: pop af  
0305			endm  
# End of macro DMARK
0305			;		push af 
0305			;		ld a, '>' 
0305			;		ld (debug_mark),a 
0305			;		pop af 
0305					CALLMONITOR 
0305 cd ae 13			call break_point_state  
0308				endm  
# End of macro CALLMONITOR
0308				endif 
0308			 
0308 00				nop 
0309 00				nop 
030a 00				nop 
030b			 
030b				; now set 0 in every page to mark as a free block 
030b			 
030b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
030d 21 40 00			ld hl, STORE_BLOCK_PHY 
0310			 
0310 3e 00		.setmark1:   	ld a,0 
0312 e5					push hl 
0313 c5					push bc 
0314 cd 85 01				call se_writebyte 
0317 3e 0a			ld a, 10 
0319 cd d7 08			call aDelayInMS 
031c 23				inc hl 
031d cd 85 01				call se_writebyte 
0320 3e 0a			ld a, 10 
0322 cd d7 08			call aDelayInMS 
0325 2b				dec hl 
0326 c1					pop bc 
0327 e1					pop hl 
0328 3e 40				ld a, STORE_BLOCK_PHY 
032a cd ad 0b				call addatohl 
032d 10 e1				djnz .setmark1 
032f			 
032f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0331 3e 00		.setmark2:   	ld a,0 
0333 e5					push hl 
0334 c5					push bc 
0335 cd 85 01				call se_writebyte 
0338 3e 0a			ld a, 10 
033a cd d7 08			call aDelayInMS 
033d 23				inc hl 
033e cd 85 01				call se_writebyte 
0341 3e 0a			ld a, 10 
0343 cd d7 08			call aDelayInMS 
0346 2b				dec hl 
0347 c1					pop bc 
0348 e1					pop hl 
0349 3e 40				ld a, STORE_BLOCK_PHY 
034b cd ad 0b				call addatohl 
034e 10 e1				djnz .setmark2 
0350			 
0350					 
0350			 
0350			 
0350 c9				ret 
0351			 
0351			 
0351			 
0351			 
0351 .. 00		.defaultbanklabl:   db "BankLabel_",0 
035c			 
035c			 
035c			 
035c			; Label Bank 
035c			; ---------- 
035c			; 
035c			; With current bank 
035c			; Read block 0 
035c			; Set label 
035c			; Write block 0 
035c			 
035c			; label str pointer in hl 
035c			 
035c			storage_label:     
035c			 
035c				if DEBUG_STORESE 
035c					DMARK "LBL" 
035c f5				push af  
035d 3a 71 03			ld a, (.dmark)  
0360 32 71 ee			ld (debug_mark),a  
0363 3a 72 03			ld a, (.dmark+1)  
0366 32 72 ee			ld (debug_mark+1),a  
0369 3a 73 03			ld a, (.dmark+2)  
036c 32 73 ee			ld (debug_mark+2),a  
036f 18 03			jr .pastdmark  
0371 ..			.dmark: db "LBL"  
0374 f1			.pastdmark: pop af  
0375			endm  
# End of macro DMARK
0375					CALLMONITOR 
0375 cd ae 13			call break_point_state  
0378				endm  
# End of macro CALLMONITOR
0378				endif 
0378			 
0378 e5				push hl 
0379			 
0379 cd 38 02			call storage_get_block_0 
037c			 
037c				; set default label 
037c			 
037c e1				pop hl 
037d			 
037d 11 5f eb		 	ld de, store_page+3 
0380 01 0f 00			ld bc, 15 
0383				if DEBUG_STORESE 
0383					DMARK "LB3" 
0383 f5				push af  
0384 3a 98 03			ld a, (.dmark)  
0387 32 71 ee			ld (debug_mark),a  
038a 3a 99 03			ld a, (.dmark+1)  
038d 32 72 ee			ld (debug_mark+1),a  
0390 3a 9a 03			ld a, (.dmark+2)  
0393 32 73 ee			ld (debug_mark+2),a  
0396 18 03			jr .pastdmark  
0398 ..			.dmark: db "LB3"  
039b f1			.pastdmark: pop af  
039c			endm  
# End of macro DMARK
039c					CALLMONITOR 
039c cd ae 13			call break_point_state  
039f				endm  
# End of macro CALLMONITOR
039f				endif 
039f ed b0			ldir 
03a1				; save default page 0 
03a1			 
03a1 21 00 00			ld hl, 0 
03a4 11 5c eb			ld de, store_page 
03a7				if DEBUG_STORESE 
03a7					DMARK "LBW" 
03a7 f5				push af  
03a8 3a bc 03			ld a, (.dmark)  
03ab 32 71 ee			ld (debug_mark),a  
03ae 3a bd 03			ld a, (.dmark+1)  
03b1 32 72 ee			ld (debug_mark+1),a  
03b4 3a be 03			ld a, (.dmark+2)  
03b7 32 73 ee			ld (debug_mark+2),a  
03ba 18 03			jr .pastdmark  
03bc ..			.dmark: db "LBW"  
03bf f1			.pastdmark: pop af  
03c0			endm  
# End of macro DMARK
03c0					CALLMONITOR 
03c0 cd ae 13			call break_point_state  
03c3				endm  
# End of macro CALLMONITOR
03c3				endif 
03c3 cd ec 01			call storage_write_block 
03c6			 
03c6 c9				ret 
03c7			 
03c7			 
03c7			 
03c7			; Read Block 0 - Config 
03c7			; --------------------- 
03c7			; 
03c7			; With current bank 
03c7			; Call presence test 
03c7			;    If not present format/init bank  
03c7			; Read block 0  
03c7			;  
03c7			 
03c7			 
03c7			; Dir 
03c7			; --- 
03c7			; 
03c7			; With current bank 
03c7			; Load Block 0 Config 
03c7			; Get max file id number 
03c7			; For each logical block 
03c7			;    Read block read byte 2 
03c7			;      if first block of file 
03c7			;         Display file name 
03c7			;         Display type flags for file 
03c7			;        
03c7			 
03c7			; moving to words as this requires stack control 
03c7			 
03c7			 
03c7			; Delete File 
03c7			; ----------- 
03c7			; 
03c7			; With current bank 
03c7			; 
03c7			; Load Block 0 Config 
03c7			; Get max file id number 
03c7			; For each logical block 
03c7			;    Read block file id 
03c7			;      If first block of file and dont have file id 
03c7			;         if file to delete 
03c7			;         Save file id 
03c7			;         Null file id 
03c7			;         Write this block back 
03c7			;      If file id is one saved 
03c7			;         Null file id 
03c7			;         Write this block back 
03c7			 
03c7			 
03c7			.se_done: 
03c7 e1				pop hl 
03c8 c9				ret 
03c9			 
03c9			storage_erase: 
03c9			 
03c9				; hl contains the file id 
03c9			 
03c9 5d				ld e, l 
03ca 16 00			ld d, 0 
03cc 21 40 00			ld hl, STORE_BLOCK_PHY 
03cf					if DEBUG_FORTH_WORDS 
03cf						DMARK "ERA" 
03cf f5				push af  
03d0 3a e4 03			ld a, (.dmark)  
03d3 32 71 ee			ld (debug_mark),a  
03d6 3a e5 03			ld a, (.dmark+1)  
03d9 32 72 ee			ld (debug_mark+1),a  
03dc 3a e6 03			ld a, (.dmark+2)  
03df 32 73 ee			ld (debug_mark+2),a  
03e2 18 03			jr .pastdmark  
03e4 ..			.dmark: db "ERA"  
03e7 f1			.pastdmark: pop af  
03e8			endm  
# End of macro DMARK
03e8						CALLMONITOR 
03e8 cd ae 13			call break_point_state  
03eb				endm  
# End of macro CALLMONITOR
03eb					endif 
03eb cd ba 04			call storage_findnextid 
03ee cd d6 0b			call ishlzero 
03f1 c8				ret z 
03f2			 
03f2 e5				push hl 
03f3			 
03f3				; TODO check file not found 
03f3			 
03f3 11 5c eb			ld de, store_page 
03f6 cd 87 01			call storage_read_block 
03f9			 
03f9 cd d6 0b			call ishlzero 
03fc ca c7 03			jp z,.se_done 
03ff			 
03ff					if DEBUG_FORTH_WORDS 
03ff						DMARK "ER1" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 71 ee			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 72 ee			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 73 ee			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "ER1"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418						CALLMONITOR 
0418 cd ae 13			call break_point_state  
041b				endm  
# End of macro CALLMONITOR
041b					endif 
041b 3a 5c eb			ld a, (store_page)	; get file id 
041e 32 55 eb			ld (store_tmpid), a 
0421			 
0421 3a 5e eb			ld a, (store_page+2)    ; get count of extends 
0424 32 54 eb			ld (store_tmpext), a 
0427			 
0427				; wipe file header 
0427			 
0427 e1				pop hl 
0428 3e 00			ld a, 0 
042a 32 5c eb			ld (store_page), a 
042d 32 5d eb			ld (store_page+1),a 
0430 11 5c eb			ld de, store_page 
0433					if DEBUG_FORTH_WORDS 
0433						DMARK "ER2" 
0433 f5				push af  
0434 3a 48 04			ld a, (.dmark)  
0437 32 71 ee			ld (debug_mark),a  
043a 3a 49 04			ld a, (.dmark+1)  
043d 32 72 ee			ld (debug_mark+1),a  
0440 3a 4a 04			ld a, (.dmark+2)  
0443 32 73 ee			ld (debug_mark+2),a  
0446 18 03			jr .pastdmark  
0448 ..			.dmark: db "ER2"  
044b f1			.pastdmark: pop af  
044c			endm  
# End of macro DMARK
044c						CALLMONITOR 
044c cd ae 13			call break_point_state  
044f				endm  
# End of macro CALLMONITOR
044f					endif 
044f cd ec 01			call storage_write_block 
0452			 
0452			 
0452				; wipe file extents 
0452			 
0452 3a 54 eb			ld a, (store_tmpext) 
0455 47				ld b, a 
0456			 
0456			.eraext:	  
0456 c5				push bc 
0457			 
0457 21 40 00			ld hl, STORE_BLOCK_PHY 
045a 3a 55 eb			ld a,(store_tmpid) 
045d 5f				ld e, a 
045e 50				ld d, b	 
045f					if DEBUG_FORTH_WORDS 
045f						DMARK "ER3" 
045f f5				push af  
0460 3a 74 04			ld a, (.dmark)  
0463 32 71 ee			ld (debug_mark),a  
0466 3a 75 04			ld a, (.dmark+1)  
0469 32 72 ee			ld (debug_mark+1),a  
046c 3a 76 04			ld a, (.dmark+2)  
046f 32 73 ee			ld (debug_mark+2),a  
0472 18 03			jr .pastdmark  
0474 ..			.dmark: db "ER3"  
0477 f1			.pastdmark: pop af  
0478			endm  
# End of macro DMARK
0478						CALLMONITOR 
0478 cd ae 13			call break_point_state  
047b				endm  
# End of macro CALLMONITOR
047b					endif 
047b cd ba 04			call storage_findnextid 
047e cd d6 0b			call ishlzero 
0481 ca c7 03			jp z,.se_done 
0484			 
0484 e5				push hl 
0485 11 5c eb			ld de, store_page 
0488 cd 87 01			call storage_read_block 
048b			 
048b				; free block	 
048b			 
048b 3e 00			ld a, 0 
048d 32 5c eb			ld (store_page), a 
0490 32 5d eb			ld (store_page+1),a 
0493 11 5c eb			ld de, store_page 
0496 e1				pop hl 
0497					if DEBUG_FORTH_WORDS 
0497						DMARK "ER4" 
0497 f5				push af  
0498 3a ac 04			ld a, (.dmark)  
049b 32 71 ee			ld (debug_mark),a  
049e 3a ad 04			ld a, (.dmark+1)  
04a1 32 72 ee			ld (debug_mark+1),a  
04a4 3a ae 04			ld a, (.dmark+2)  
04a7 32 73 ee			ld (debug_mark+2),a  
04aa 18 03			jr .pastdmark  
04ac ..			.dmark: db "ER4"  
04af f1			.pastdmark: pop af  
04b0			endm  
# End of macro DMARK
04b0						CALLMONITOR 
04b0 cd ae 13			call break_point_state  
04b3				endm  
# End of macro CALLMONITOR
04b3					endif 
04b3 cd ec 01			call storage_write_block 
04b6			 
04b6 c1				pop bc 
04b7 10 9d			djnz .eraext 
04b9			 
04b9 c9				ret 
04ba			 
04ba			 
04ba			; Find Free Block 
04ba			; --------------- 
04ba			; 
04ba			; With current bank 
04ba			;  
04ba			; From given starting logical block 
04ba			;    Read block  
04ba			;    If no file id 
04ba			;         Return block id 
04ba			 
04ba			 
04ba			; hl starting page number 
04ba			; hl contains free page number or zero if no pages free 
04ba			; e contains the file id to locate 
04ba			; d contains the block number 
04ba			 
04ba			; TODO change to find file id and use zero for free block 
04ba			 
04ba			storage_findnextid: 
04ba			 
04ba				; now locate first 0 page to mark as a free block 
04ba			 
04ba 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04bc			;	ld hl, STORE_BLOCK_PHY 
04bc			 
04bc					if DEBUG_FORTH_WORDS 
04bc					DMARK "FNI" 
04bc f5				push af  
04bd 3a d1 04			ld a, (.dmark)  
04c0 32 71 ee			ld (debug_mark),a  
04c3 3a d2 04			ld a, (.dmark+1)  
04c6 32 72 ee			ld (debug_mark+1),a  
04c9 3a d3 04			ld a, (.dmark+2)  
04cc 32 73 ee			ld (debug_mark+2),a  
04cf 18 03			jr .pastdmark  
04d1 ..			.dmark: db "FNI"  
04d4 f1			.pastdmark: pop af  
04d5			endm  
# End of macro DMARK
04d5						CALLMONITOR 
04d5 cd ae 13			call break_point_state  
04d8				endm  
# End of macro CALLMONITOR
04d8					endif 
04d8			.ff1:   	 
04d8 e5					push hl 
04d9 c5					push bc 
04da d5					push de 
04db cd 84 01				call se_readbyte 
04de 5f					ld e,a 
04df 23					inc hl 
04e0 cd 84 01				call se_readbyte 
04e3 57					ld d, a 
04e4 e1					pop hl 
04e5 e5					push hl 
04e6 cd cb 0b				call cmp16 
04e9 28 49				jr z, .fffound 
04eb			 
04eb d1					pop de 
04ec c1					pop bc 
04ed e1					pop hl 
04ee			 
04ee					; is found? 
04ee					;cp e 
04ee					;ret z 
04ee			 
04ee 3e 40				ld a, STORE_BLOCK_PHY 
04f0 cd ad 0b				call addatohl 
04f3 10 e3				djnz .ff1 
04f5			 
04f5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04f7			.ff2:   	 
04f7			 
04f7 e5					push hl 
04f8 c5					push bc 
04f9 d5					push de 
04fa cd 84 01				call se_readbyte 
04fd 5f					ld e,a 
04fe 23					inc hl 
04ff cd 84 01				call se_readbyte 
0502 57					ld d, a 
0503			 
0503 e1					pop hl 
0504 e5					push hl 
0505 cd cb 0b				call cmp16 
0508 28 2a				jr z, .fffound 
050a			 
050a d1					pop de 
050b c1					pop bc 
050c e1					pop hl 
050d					; is found? 
050d					;cp e 
050d					;ret z 
050d			 
050d 3e 40				ld a, STORE_BLOCK_PHY 
050f cd ad 0b				call addatohl 
0512 10 e3				djnz .ff2 
0514			 
0514			 
0514					if DEBUG_FORTH_WORDS 
0514					DMARK "FN-" 
0514 f5				push af  
0515 3a 29 05			ld a, (.dmark)  
0518 32 71 ee			ld (debug_mark),a  
051b 3a 2a 05			ld a, (.dmark+1)  
051e 32 72 ee			ld (debug_mark+1),a  
0521 3a 2b 05			ld a, (.dmark+2)  
0524 32 73 ee			ld (debug_mark+2),a  
0527 18 03			jr .pastdmark  
0529 ..			.dmark: db "FN-"  
052c f1			.pastdmark: pop af  
052d			endm  
# End of macro DMARK
052d					;	push af 
052d					;	ld a, 'n' 
052d					;	ld (debug_mark),a 
052d					;	pop af 
052d						CALLMONITOR 
052d cd ae 13			call break_point_state  
0530				endm  
# End of macro CALLMONITOR
0530					endif 
0530				; no free marks! 
0530 21 00 00				ld hl, 0 
0533 c9				ret 
0534			.fffound: 
0534				 
0534			 
0534 d1					pop de 
0535 c1					pop bc 
0536 e1					pop hl 
0537					if DEBUG_FORTH_WORDS 
0537					DMARK "FNF" 
0537 f5				push af  
0538 3a 4c 05			ld a, (.dmark)  
053b 32 71 ee			ld (debug_mark),a  
053e 3a 4d 05			ld a, (.dmark+1)  
0541 32 72 ee			ld (debug_mark+1),a  
0544 3a 4e 05			ld a, (.dmark+2)  
0547 32 73 ee			ld (debug_mark+2),a  
054a 18 03			jr .pastdmark  
054c ..			.dmark: db "FNF"  
054f f1			.pastdmark: pop af  
0550			endm  
# End of macro DMARK
0550					;	push af 
0550					;	ld a, 'n' 
0550					;	ld (debug_mark),a 
0550					;	pop af 
0550						CALLMONITOR 
0550 cd ae 13			call break_point_state  
0553				endm  
# End of macro CALLMONITOR
0553					endif 
0553 c9				ret 
0554			 
0554			 
0554			 
0554			; Free Space 
0554			; ---------- 
0554			; 
0554			; With current bank 
0554			; 
0554			; Set block count to zero 
0554			; Starting with first logical block 
0554			;      Find free block  
0554			;      If block id given, increment block count 
0554			; 
0554			;  
0554			 
0554			 
0554			; hl contains count of free blocks 
0554			 
0554			storage_freeblocks: 
0554			 
0554				; now locate first 0 page to mark as a free block 
0554			 
0554 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0556 21 40 00			ld hl, STORE_BLOCK_PHY 
0559 11 00 00			ld de, 0 
055c			 
055c			.fb1:   	 
055c e5					push hl 
055d c5					push bc 
055e d5					push de 
055f cd 84 01				call se_readbyte 
0562 d1					pop de 
0563 c1					pop bc 
0564 e1					pop hl 
0565			 
0565					; is free? 
0565 fe 00				cp 0 
0567 20 01				jr nz, .ff1cont 
0569 13					inc de 
056a			 
056a			.ff1cont: 
056a			 
056a			 
056a 3e 40				ld a, STORE_BLOCK_PHY 
056c cd ad 0b				call addatohl 
056f 10 eb				djnz .fb1 
0571			 
0571 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0573			.fb2:   	 
0573 e5					push hl 
0574 c5					push bc 
0575 d5					push de 
0576 cd 84 01				call se_readbyte 
0579 d1					pop de 
057a c1					pop bc 
057b e1					pop hl 
057c			 
057c					; is free? 
057c fe 00				cp 0 
057e 20 01				jr nz, .ff2cont 
0580 13					inc de 
0581			 
0581			.ff2cont: 
0581			 
0581 3e 40				ld a, STORE_BLOCK_PHY 
0583 cd ad 0b				call addatohl 
0586 10 eb				djnz .fb2 
0588			 
0588 eb				ex de, hl 
0589 c9				ret 
058a			 
058a			; Get File ID 
058a			; ----------- 
058a			; 
058a			; With current bank 
058a			;  
058a			; Load Block 0 Config 
058a			; Get max file id number 
058a			; For each logical block 
058a			;    Read block file id 
058a			;      If first block of file and dont have file id 
058a			;         if file get id and exit 
058a			 
058a			 
058a			 
058a			 
058a			; Create File 
058a			; ----------- 
058a			; 
058a			; With current bank  
058a			; Load Block 0 Config 
058a			; Get max file id number 
058a			; Increment file id number 
058a			; Save Config 
058a			; Find free block 
058a			; Set buffer with file name and file id 
058a			; Write buffer to free block  
058a			 
058a			 
058a			; hl point to file name 
058a			; hl returns file id 
058a			 
058a			; file format: 
058a			; byte 0 - file id 
058a			; byte 1 - extent number 
058a			; byte 2-> data 
058a			 
058a			; format for extent number 0: 
058a			; 
058a			; byte 0 - file id 
058a			; byte 1 - extent 0 
058a			; byte 2 - extent count 
058a			; byte 3 -> file name and meta data 
058a			 
058a			 
058a			storage_create: 
058a				if DEBUG_STORESE 
058a					DMARK "SCR" 
058a f5				push af  
058b 3a 9f 05			ld a, (.dmark)  
058e 32 71 ee			ld (debug_mark),a  
0591 3a a0 05			ld a, (.dmark+1)  
0594 32 72 ee			ld (debug_mark+1),a  
0597 3a a1 05			ld a, (.dmark+2)  
059a 32 73 ee			ld (debug_mark+2),a  
059d 18 03			jr .pastdmark  
059f ..			.dmark: db "SCR"  
05a2 f1			.pastdmark: pop af  
05a3			endm  
# End of macro DMARK
05a3					CALLMONITOR 
05a3 cd ae 13			call break_point_state  
05a6				endm  
# End of macro CALLMONITOR
05a6				endif 
05a6			 
05a6 e5				push hl		; save file name pointer 
05a7			 
05a7 cd 38 02			call storage_get_block_0 
05aa			 
05aa 3a 5c eb			ld a,(store_page)	; get current file id 
05ad 3c				inc a 
05ae 32 5c eb			ld (store_page),a 
05b1				 
05b1 32 55 eb			ld (store_tmpid),a			; save id 
05b4			 
05b4 21 00 00			ld hl, 0 
05b7 11 5c eb			ld de, store_page 
05ba				if DEBUG_STORESE 
05ba					DMARK "SCw" 
05ba f5				push af  
05bb 3a cf 05			ld a, (.dmark)  
05be 32 71 ee			ld (debug_mark),a  
05c1 3a d0 05			ld a, (.dmark+1)  
05c4 32 72 ee			ld (debug_mark+1),a  
05c7 3a d1 05			ld a, (.dmark+2)  
05ca 32 73 ee			ld (debug_mark+2),a  
05cd 18 03			jr .pastdmark  
05cf ..			.dmark: db "SCw"  
05d2 f1			.pastdmark: pop af  
05d3			endm  
# End of macro DMARK
05d3					CALLMONITOR 
05d3 cd ae 13			call break_point_state  
05d6				endm  
# End of macro CALLMONITOR
05d6				endif 
05d6 cd ec 01			call storage_write_block	 ; save update 
05d9			 
05d9				if DEBUG_STORESE 
05d9 11 5c eb				ld de, store_page 
05dc					DMARK "SCC" 
05dc f5				push af  
05dd 3a f1 05			ld a, (.dmark)  
05e0 32 71 ee			ld (debug_mark),a  
05e3 3a f2 05			ld a, (.dmark+1)  
05e6 32 72 ee			ld (debug_mark+1),a  
05e9 3a f3 05			ld a, (.dmark+2)  
05ec 32 73 ee			ld (debug_mark+2),a  
05ef 18 03			jr .pastdmark  
05f1 ..			.dmark: db "SCC"  
05f4 f1			.pastdmark: pop af  
05f5			endm  
# End of macro DMARK
05f5					CALLMONITOR 
05f5 cd ae 13			call break_point_state  
05f8				endm  
# End of macro CALLMONITOR
05f8				endif 
05f8				;  
05f8				 
05f8 21 40 00			ld hl, STORE_BLOCK_PHY 
05fb 11 00 00			ld de, 0 
05fe cd ba 04			call storage_findnextid 
0601			 
0601 22 46 eb			ld (store_tmppageid), hl    ; save page to use  
0604			 
0604				; TODO detect 0 = no spare blocks 
0604			 
0604				; hl now contains the free page to use for the file header page 
0604			 
0604				if DEBUG_STORESE 
0604				DMARK "SCF" 
0604 f5				push af  
0605 3a 19 06			ld a, (.dmark)  
0608 32 71 ee			ld (debug_mark),a  
060b 3a 1a 06			ld a, (.dmark+1)  
060e 32 72 ee			ld (debug_mark+1),a  
0611 3a 1b 06			ld a, (.dmark+2)  
0614 32 73 ee			ld (debug_mark+2),a  
0617 18 03			jr .pastdmark  
0619 ..			.dmark: db "SCF"  
061c f1			.pastdmark: pop af  
061d			endm  
# End of macro DMARK
061d					CALLMONITOR 
061d cd ae 13			call break_point_state  
0620				endm  
# End of macro CALLMONITOR
0620				endif 
0620			 
0620 22 46 eb			ld (store_tmppageid), hl 
0623				 
0623 3a 55 eb			ld a,(store_tmpid)    ; get file id 
0626			;	ld a, (store_filecache)			; save to cache 
0626			 
0626 32 5c eb			ld (store_page),a    ; set page id 
0629 3e 00			ld a, 0			 ; extent 0 is file header 
062b 32 5d eb			ld (store_page+1), a   ; set file extent 
062e			 
062e 32 5e eb			ld (store_page+2), a   ; extent count for the file 
0631			 
0631			;	inc hl 		; init block 0 of file 
0631			;	inc hl   		; skip file and extent id 
0631			 ;       ld a, 0 
0631			;	ld (hl),a 
0631			;	ld a, (store_filecache+1)  	; save to cache 
0631			 
0631			;	inc hl    ; file name 
0631				 
0631				 
0631 11 5f eb			ld de, store_page+3    ; get buffer for term string to use as file name 
0634				if DEBUG_STORESE 
0634					DMARK "SCc" 
0634 f5				push af  
0635 3a 49 06			ld a, (.dmark)  
0638 32 71 ee			ld (debug_mark),a  
063b 3a 4a 06			ld a, (.dmark+1)  
063e 32 72 ee			ld (debug_mark+1),a  
0641 3a 4b 06			ld a, (.dmark+2)  
0644 32 73 ee			ld (debug_mark+2),a  
0647 18 03			jr .pastdmark  
0649 ..			.dmark: db "SCc"  
064c f1			.pastdmark: pop af  
064d			endm  
# End of macro DMARK
064d					CALLMONITOR 
064d cd ae 13			call break_point_state  
0650				endm  
# End of macro CALLMONITOR
0650				endif 
0650 e1				pop hl    ; get zero term string 
0651 e5				push hl 
0652 3e 00			ld a, 0 
0654 cd 16 10			call strlent 
0657 23				inc hl   ; cover zero term 
0658 06 00			ld b,0 
065a 4d				ld c,l 
065b e1				pop hl 
065c				;ex de, hl 
065c				if DEBUG_STORESE 
065c					DMARK "SCa" 
065c f5				push af  
065d 3a 71 06			ld a, (.dmark)  
0660 32 71 ee			ld (debug_mark),a  
0663 3a 72 06			ld a, (.dmark+1)  
0666 32 72 ee			ld (debug_mark+1),a  
0669 3a 73 06			ld a, (.dmark+2)  
066c 32 73 ee			ld (debug_mark+2),a  
066f 18 03			jr .pastdmark  
0671 ..			.dmark: db "SCa"  
0674 f1			.pastdmark: pop af  
0675			endm  
# End of macro DMARK
0675					;push af 
0675					;ld a, 'a' 
0675					;ld (debug_mark),a 
0675					;pop af 
0675					CALLMONITOR 
0675 cd ae 13			call break_point_state  
0678				endm  
# End of macro CALLMONITOR
0678				endif 
0678 ed b0			ldir    ; copy zero term string 
067a				if DEBUG_STORESE 
067a					DMARK "SCA" 
067a f5				push af  
067b 3a 8f 06			ld a, (.dmark)  
067e 32 71 ee			ld (debug_mark),a  
0681 3a 90 06			ld a, (.dmark+1)  
0684 32 72 ee			ld (debug_mark+1),a  
0687 3a 91 06			ld a, (.dmark+2)  
068a 32 73 ee			ld (debug_mark+2),a  
068d 18 03			jr .pastdmark  
068f ..			.dmark: db "SCA"  
0692 f1			.pastdmark: pop af  
0693			endm  
# End of macro DMARK
0693					CALLMONITOR 
0693 cd ae 13			call break_point_state  
0696				endm  
# End of macro CALLMONITOR
0696				endif 
0696			 
0696				; write file header page 
0696			 
0696 2a 46 eb			ld hl,(store_tmppageid) 
0699 11 5c eb			ld de, store_page 
069c				if DEBUG_STORESE 
069c					DMARK "SCb" 
069c f5				push af  
069d 3a b1 06			ld a, (.dmark)  
06a0 32 71 ee			ld (debug_mark),a  
06a3 3a b2 06			ld a, (.dmark+1)  
06a6 32 72 ee			ld (debug_mark+1),a  
06a9 3a b3 06			ld a, (.dmark+2)  
06ac 32 73 ee			ld (debug_mark+2),a  
06af 18 03			jr .pastdmark  
06b1 ..			.dmark: db "SCb"  
06b4 f1			.pastdmark: pop af  
06b5			endm  
# End of macro DMARK
06b5					;push af 
06b5					;ld a, 'b' 
06b5					;ld (debug_mark),a 
06b5					;pop af 
06b5					CALLMONITOR 
06b5 cd ae 13			call break_point_state  
06b8				endm  
# End of macro CALLMONITOR
06b8				endif 
06b8 cd ec 01			call storage_write_block 
06bb			 
06bb 3a 55 eb			ld a, (store_tmpid) 
06be 6f				ld l, a 
06bf 26 00			ld h,0 
06c1				if DEBUG_STORESE 
06c1					DMARK "SCz" 
06c1 f5				push af  
06c2 3a d6 06			ld a, (.dmark)  
06c5 32 71 ee			ld (debug_mark),a  
06c8 3a d7 06			ld a, (.dmark+1)  
06cb 32 72 ee			ld (debug_mark+1),a  
06ce 3a d8 06			ld a, (.dmark+2)  
06d1 32 73 ee			ld (debug_mark+2),a  
06d4 18 03			jr .pastdmark  
06d6 ..			.dmark: db "SCz"  
06d9 f1			.pastdmark: pop af  
06da			endm  
# End of macro DMARK
06da					CALLMONITOR 
06da cd ae 13			call break_point_state  
06dd				endm  
# End of macro CALLMONITOR
06dd				endif 
06dd c9				ret 
06de				 
06de			 
06de			 
06de			; 
06de			; Read File 
06de			; 
06de			; h - file id to locate 
06de			; l - extent to locate 
06de			; de - pointer to string to read into 
06de			; 
06de			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
06de			 
06de			.sr_fail: 
06de d1				pop de 
06df c9				ret 
06e0			 
06e0			storage_read: 
06e0 d5				push de 
06e1			 
06e1			; TODO BUG the above push is it popped before the RET Z? 
06e1			 
06e1			; TODO how to handle multiple part blocks 
06e1			 
06e1				; locate file extent to read 
06e1			 
06e1 5c				ld e, h 
06e2 55				ld d, l 
06e3 21 40 00			ld hl, STORE_BLOCK_PHY 
06e6				if DEBUG_STORESE 
06e6					DMARK "SRE" 
06e6 f5				push af  
06e7 3a fb 06			ld a, (.dmark)  
06ea 32 71 ee			ld (debug_mark),a  
06ed 3a fc 06			ld a, (.dmark+1)  
06f0 32 72 ee			ld (debug_mark+1),a  
06f3 3a fd 06			ld a, (.dmark+2)  
06f6 32 73 ee			ld (debug_mark+2),a  
06f9 18 03			jr .pastdmark  
06fb ..			.dmark: db "SRE"  
06fe f1			.pastdmark: pop af  
06ff			endm  
# End of macro DMARK
06ff					CALLMONITOR 
06ff cd ae 13			call break_point_state  
0702				endm  
# End of macro CALLMONITOR
0702				endif 
0702 cd ba 04			call storage_findnextid 
0705			 
0705				if DEBUG_STORESE 
0705					DMARK "SRf" 
0705 f5				push af  
0706 3a 1a 07			ld a, (.dmark)  
0709 32 71 ee			ld (debug_mark),a  
070c 3a 1b 07			ld a, (.dmark+1)  
070f 32 72 ee			ld (debug_mark+1),a  
0712 3a 1c 07			ld a, (.dmark+2)  
0715 32 73 ee			ld (debug_mark+2),a  
0718 18 03			jr .pastdmark  
071a ..			.dmark: db "SRf"  
071d f1			.pastdmark: pop af  
071e			endm  
# End of macro DMARK
071e					CALLMONITOR 
071e cd ae 13			call break_point_state  
0721				endm  
# End of macro CALLMONITOR
0721				endif 
0721 cd d6 0b			call ishlzero 
0724			;	ld a, l 
0724			;	add h 
0724			;	cp 0 
0724 28 b8			jr z,.sr_fail			; block not found so EOF 
0726			 
0726				; hl contains page number to load 
0726 d1				pop de   ; get storage 
0727 d5				push de 
0728				if DEBUG_STORESE 
0728					DMARK "SRg" 
0728 f5				push af  
0729 3a 3d 07			ld a, (.dmark)  
072c 32 71 ee			ld (debug_mark),a  
072f 3a 3e 07			ld a, (.dmark+1)  
0732 32 72 ee			ld (debug_mark+1),a  
0735 3a 3f 07			ld a, (.dmark+2)  
0738 32 73 ee			ld (debug_mark+2),a  
073b 18 03			jr .pastdmark  
073d ..			.dmark: db "SRg"  
0740 f1			.pastdmark: pop af  
0741			endm  
# End of macro DMARK
0741					CALLMONITOR 
0741 cd ae 13			call break_point_state  
0744				endm  
# End of macro CALLMONITOR
0744				endif 
0744 cd 87 01			call storage_read_block 
0747			 
0747			 
0747			; TODO if block has no zeros then need to read next block  
0747			 
0747			 
0747					 
0747 e1				pop hl 		 ; return start of data to show as not EOF 
0748 23				inc hl   ; past file id 
0749 23				inc hl   ; past ext 
074a				if DEBUG_STORESE 
074a					DMARK "SRe" 
074a f5				push af  
074b 3a 5f 07			ld a, (.dmark)  
074e 32 71 ee			ld (debug_mark),a  
0751 3a 60 07			ld a, (.dmark+1)  
0754 32 72 ee			ld (debug_mark+1),a  
0757 3a 61 07			ld a, (.dmark+2)  
075a 32 73 ee			ld (debug_mark+2),a  
075d 18 03			jr .pastdmark  
075f ..			.dmark: db "SRe"  
0762 f1			.pastdmark: pop af  
0763			endm  
# End of macro DMARK
0763					CALLMONITOR 
0763 cd ae 13			call break_point_state  
0766				endm  
# End of macro CALLMONITOR
0766				endif 
0766 c9					ret 
0767			 
0767			 
0767			 
0767			; 
0767			; Append File 
0767			; 
0767			; hl - file id to locate 
0767			; de - pointer to (multi block) string to write 
0767			 
0767			.sa_notfound: 
0767 d1				pop de 
0768 c9				ret 
0769			 
0769			 
0769			storage_append: 
0769				; hl -  file id to append to 
0769				; de - string to append 
0769			 
0769 d5				push de 
076a				 
076a				if DEBUG_STORESE 
076a					DMARK "AP1" 
076a f5				push af  
076b 3a 7f 07			ld a, (.dmark)  
076e 32 71 ee			ld (debug_mark),a  
0771 3a 80 07			ld a, (.dmark+1)  
0774 32 72 ee			ld (debug_mark+1),a  
0777 3a 81 07			ld a, (.dmark+2)  
077a 32 73 ee			ld (debug_mark+2),a  
077d 18 03			jr .pastdmark  
077f ..			.dmark: db "AP1"  
0782 f1			.pastdmark: pop af  
0783			endm  
# End of macro DMARK
0783					CALLMONITOR 
0783 cd ae 13			call break_point_state  
0786				endm  
# End of macro CALLMONITOR
0786				endif 
0786			 
0786 7d				ld a, l 
0787 32 55 eb			ld (store_tmpid), a 
078a			 
078a				; get file header  
078a			 
078a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
078c 3a 55 eb			ld a, (store_tmpid) 
078f 5f				ld e, a 
0790			 
0790 21 40 00				ld hl, STORE_BLOCK_PHY 
0793 cd ba 04				call storage_findnextid 
0796			 
0796 cd d6 0b			call ishlzero 
0799 28 cc			jr z, .sa_notfound 
079b			 
079b 22 46 eb			ld (store_tmppageid), hl 
079e			 
079e				; TODO handle file id not found 
079e			 
079e				if DEBUG_STORESE 
079e					DMARK "AP2" 
079e f5				push af  
079f 3a b3 07			ld a, (.dmark)  
07a2 32 71 ee			ld (debug_mark),a  
07a5 3a b4 07			ld a, (.dmark+1)  
07a8 32 72 ee			ld (debug_mark+1),a  
07ab 3a b5 07			ld a, (.dmark+2)  
07ae 32 73 ee			ld (debug_mark+2),a  
07b1 18 03			jr .pastdmark  
07b3 ..			.dmark: db "AP2"  
07b6 f1			.pastdmark: pop af  
07b7			endm  
# End of macro DMARK
07b7					CALLMONITOR 
07b7 cd ae 13			call break_point_state  
07ba				endm  
# End of macro CALLMONITOR
07ba				endif 
07ba			 
07ba				; update file extent count 
07ba			 
07ba 11 5c eb			ld de, store_page 
07bd			 
07bd cd 87 01			call storage_read_block 
07c0			 
07c0				if DEBUG_STORESE 
07c0					DMARK "AP3" 
07c0 f5				push af  
07c1 3a d5 07			ld a, (.dmark)  
07c4 32 71 ee			ld (debug_mark),a  
07c7 3a d6 07			ld a, (.dmark+1)  
07ca 32 72 ee			ld (debug_mark+1),a  
07cd 3a d7 07			ld a, (.dmark+2)  
07d0 32 73 ee			ld (debug_mark+2),a  
07d3 18 03			jr .pastdmark  
07d5 ..			.dmark: db "AP3"  
07d8 f1			.pastdmark: pop af  
07d9			endm  
# End of macro DMARK
07d9					CALLMONITOR 
07d9 cd ae 13			call break_point_state  
07dc				endm  
# End of macro CALLMONITOR
07dc				endif 
07dc			;	ld (store_tmppageid), hl 
07dc			 
07dc 3a 5e eb			ld a, (store_page+2) 
07df 3c				inc a 
07e0 32 5e eb			ld (store_page+2), a 
07e3 32 54 eb			ld (store_tmpext), a 
07e6				 
07e6				if DEBUG_STORESE 
07e6					DMARK "AP3" 
07e6 f5				push af  
07e7 3a fb 07			ld a, (.dmark)  
07ea 32 71 ee			ld (debug_mark),a  
07ed 3a fc 07			ld a, (.dmark+1)  
07f0 32 72 ee			ld (debug_mark+1),a  
07f3 3a fd 07			ld a, (.dmark+2)  
07f6 32 73 ee			ld (debug_mark+2),a  
07f9 18 03			jr .pastdmark  
07fb ..			.dmark: db "AP3"  
07fe f1			.pastdmark: pop af  
07ff			endm  
# End of macro DMARK
07ff					CALLMONITOR 
07ff cd ae 13			call break_point_state  
0802				endm  
# End of macro CALLMONITOR
0802				endif 
0802 2a 46 eb			ld hl, (store_tmppageid) 
0805 11 5c eb			ld de, store_page 
0808 cd ec 01			call storage_write_block 
080b			 
080b				; find free block 
080b			 
080b 11 00 00			ld de, 0			 ; file extent to locate 
080e			 
080e 21 40 00				ld hl, STORE_BLOCK_PHY 
0811 cd ba 04				call storage_findnextid 
0814 cd d6 0b			call ishlzero 
0817 ca 67 07			jp z, .sa_notfound 
081a			 
081a					; TODO handle no space left 
081a					 
081a 22 46 eb				ld (store_tmppageid), hl 
081d			 
081d				if DEBUG_STORESE 
081d					DMARK "AP4" 
081d f5				push af  
081e 3a 32 08			ld a, (.dmark)  
0821 32 71 ee			ld (debug_mark),a  
0824 3a 33 08			ld a, (.dmark+1)  
0827 32 72 ee			ld (debug_mark+1),a  
082a 3a 34 08			ld a, (.dmark+2)  
082d 32 73 ee			ld (debug_mark+2),a  
0830 18 03			jr .pastdmark  
0832 ..			.dmark: db "AP4"  
0835 f1			.pastdmark: pop af  
0836			endm  
# End of macro DMARK
0836					CALLMONITOR 
0836 cd ae 13			call break_point_state  
0839				endm  
# End of macro CALLMONITOR
0839				endif 
0839					; init the buffer with zeros so we can id if the buffer is full or not 
0839			 
0839 e5					push hl 
083a c5					push bc 
083b			 
083b 21 5c eb				ld hl, store_page 
083e 06 40				ld b, STORE_BLOCK_PHY 
0840 3e 00				ld a, 0 
0842 77			.zeroblock:	ld (hl), a 
0843 23					inc hl 
0844 10 fc				djnz .zeroblock 
0846			 
0846 c1					pop bc 
0847 e1					pop hl 
0848			 
0848					; construct block 
0848			 
0848 3a 55 eb				ld a, (store_tmpid) 
084b 32 5c eb				ld (store_page), a   ; file id 
084e 3a 54 eb				ld a, (store_tmpext)   ; extent for this block 
0851 32 5d eb				ld (store_page+1), a 
0854			 
0854 e1					pop hl    ; get string to write 
0855 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0857 11 5e eb				ld de, store_page+2 
085a			 
085a				if DEBUG_STORESE 
085a					DMARK "AP5" 
085a f5				push af  
085b 3a 6f 08			ld a, (.dmark)  
085e 32 71 ee			ld (debug_mark),a  
0861 3a 70 08			ld a, (.dmark+1)  
0864 32 72 ee			ld (debug_mark+1),a  
0867 3a 71 08			ld a, (.dmark+2)  
086a 32 73 ee			ld (debug_mark+2),a  
086d 18 03			jr .pastdmark  
086f ..			.dmark: db "AP5"  
0872 f1			.pastdmark: pop af  
0873			endm  
# End of macro DMARK
0873					CALLMONITOR 
0873 cd ae 13			call break_point_state  
0876				endm  
# End of macro CALLMONITOR
0876				endif 
0876			 
0876			 
0876			 
0876					; fill buffer with data until end of string or full block 
0876			 
0876 7e			.appd:		ld a, (hl) 
0877 12					ld (de), a 
0878 fe 00				cp 0 
087a 28 04				jr z, .appdone 
087c 23					inc hl 
087d 13					inc de 
087e 10 f6				djnz .appd 
0880			 
0880 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0881 f5					push af   		; save last byte dumped 
0882			 
0882			 
0882 2a 46 eb			ld hl, (store_tmppageid) 
0885 11 5c eb			ld de, store_page 
0888				if DEBUG_STORESE 
0888					DMARK "AP6" 
0888 f5				push af  
0889 3a 9d 08			ld a, (.dmark)  
088c 32 71 ee			ld (debug_mark),a  
088f 3a 9e 08			ld a, (.dmark+1)  
0892 32 72 ee			ld (debug_mark+1),a  
0895 3a 9f 08			ld a, (.dmark+2)  
0898 32 73 ee			ld (debug_mark+2),a  
089b 18 03			jr .pastdmark  
089d ..			.dmark: db "AP6"  
08a0 f1			.pastdmark: pop af  
08a1			endm  
# End of macro DMARK
08a1					CALLMONITOR 
08a1 cd ae 13			call break_point_state  
08a4				endm  
# End of macro CALLMONITOR
08a4				endif 
08a4 cd ec 01				call storage_write_block 
08a7			 
08a7			 
08a7				; was that a full block of data written? 
08a7				; any more to write out? 
08a7			 
08a7				; if yes then set vars and jump to start of function again 
08a7			 
08a7 f1					pop af 
08a8 d1					pop de 
08a9			 
08a9 fe 00				cp 0		 ; no, string was fully written 
08ab c8					ret z 
08ac			 
08ac					; setup vars for next cycle 
08ac			 
08ac 3a 55 eb				ld a, (store_tmpid) 
08af 6f					ld l, a 
08b0 26 00				ld h, 0 
08b2			 
08b2 c3 69 07			 	jp storage_append	 ; yes, need to write out some more 
08b5			 
08b5			 
08b5			 
08b5			 
08b5			 
08b5			 
08b5			 
08b5			if DEBUG_STORECF 
08b5			storageput:	 
08b5					ret 
08b5			storageread: 
08b5					ld hl, store_page 
08b5					ld b, 200 
08b5					ld a,0 
08b5			.src:		ld (hl),a 
08b5					inc hl 
08b5					djnz .src 
08b5					 
08b5			 
08b5					ld de, 0 
08b5					ld bc, 1 
08b5					ld hl, store_page 
08b5					call cfRead 
08b5			 
08b5				call cfGetError 
08b5				ld hl,scratch 
08b5				call hexout 
08b5				ld hl, scratch+2 
08b5				ld a, 0 
08b5				ld (hl),a 
08b5				ld de, scratch 
08b5				ld a,display_row_1 
08b5				call str_at_display 
08b5				call update_display 
08b5			 
08b5					ld hl, store_page 
08b5					ld (os_cur_ptr),hl 
08b5			 
08b5					ret 
08b5			endif 
08b5			 
08b5			 
08b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
08b5			 
08b5			storage_clear_page: 
08b5 e5				push hl 
08b6 d5				push de 
08b7 c5				push bc 
08b8 21 5c eb			ld hl, store_page 
08bb 3e 00			ld a, 0 
08bd 77				ld (hl), a 
08be			 
08be 11 5d eb			ld de, store_page+1 
08c1 01 40 00			ld bc, STORE_BLOCK_PHY 
08c4			 
08c4 ed b0			ldir 
08c6				 
08c6 c1				pop bc 
08c7 d1				pop de 
08c8 e1				pop hl 
08c9 c9				ret 
08ca			 
08ca			; eof 
# End of file firmware_storage.asm
08ca			  
08ca			; support routines for above hardware abstraction layer  
08ca			  
08ca			include "firmware_general.asm"        ; general support functions  
08ca			 
08ca			; word look up 
08ca			 
08ca			; in 
08ca			; a is the index 
08ca			; hl is pointer start of array 
08ca			; 
08ca			; returns 
08ca			; hl to the word 
08ca			; 
08ca			 
08ca			table_lookup:  
08ca d5					push de 
08cb eb					ex de, hl 
08cc			 
08cc 6f					ld l, a 
08cd 26 00				ld h, 0 
08cf 29					add hl, hl 
08d0 19					add hl, de 
08d1 7e					ld a, (hl) 
08d2 23					inc hl 
08d3 66					ld h,(hl) 
08d4 6f					ld l, a 
08d5			 
08d5 d1					pop de 
08d6 c9					ret 
08d7			 
08d7			; Delay loops 
08d7			 
08d7			 
08d7			 
08d7			aDelayInMS: 
08d7 c5				push bc 
08d8 47				ld b,a 
08d9			msdelay: 
08d9 c5				push bc 
08da				 
08da			 
08da 01 41 00			ld bc,041h 
08dd cd f5 08			call delayloop 
08e0 c1				pop bc 
08e1 05				dec b 
08e2 20 f5			jr nz,msdelay 
08e4			 
08e4			;if CPU_CLOCK_8MHZ 
08e4			;msdelay8: 
08e4			;	push bc 
08e4			;	 
08e4			; 
08e4			;	ld bc,041h 
08e4			;	call delayloop 
08e4			;	pop bc 
08e4			;	dec b 
08e4			;	jr nz,msdelay8 
08e4			;endif 
08e4			 
08e4			 
08e4 c1				pop bc 
08e5 c9				ret 
08e6			 
08e6			 
08e6			delay250ms: 
08e6				;push de 
08e6 01 00 40			ld bc, 04000h 
08e9 c3 f5 08			jp delayloop 
08ec			delay500ms: 
08ec				;push de 
08ec 01 00 80			ld bc, 08000h 
08ef c3 f5 08			jp delayloop 
08f2			delay1s: 
08f2				;push bc 
08f2			   ; Clobbers A, d and e 
08f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
08f5			delayloop: 
08f5 c5			    push bc 
08f6			 
08f6			if BASE_CPM 
08f6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
08f9			.cpmloop: 
08f9 c5				push bc 
08fa			 
08fa			endif 
08fa			 
08fa			 
08fa			 
08fa			delayloopi: 
08fa			;	push bc 
08fa			;.dl: 
08fa cb 47		    bit     0,a    	; 8 
08fc cb 47		    bit     0,a    	; 8 
08fe cb 47		    bit     0,a    	; 8 
0900 e6 ff		    and     255  	; 7 
0902 0b			    dec     bc      	; 6 
0903 79			    ld      a,c     	; 4 
0904 b0			    or      b     	; 4 
0905 c2 fa 08		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0908			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0908				;pop de 
0908			;pop bc 
0908			 
0908			if BASE_CPM 
0908 c1				pop bc 
0909				 
0909 0b			    dec     bc      	; 6 
090a 79			    ld      a,c     	; 4 
090b b0			    or      b     	; 4 
090c c2 f9 08		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
090f				 
090f			 
090f			endif 
090f			;if CPU_CLOCK_8MHZ 
090f			;    pop bc 
090f			;    push bc 
090f			;.dl8: 
090f			;    bit     0,a    	; 8 
090f			;    bit     0,a    	; 8 
090f			;    bit     0,a    	; 8 
090f			;    and     255  	; 7 
090f			;    dec     bc      	; 6 
090f			;    ld      a,c     	; 4 
090f			;    or      b     	; 4 
090f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
090f			;endif 
090f			 
090f			;if CPU_CLOCK_10MHZ 
090f			;    pop bc 
090f			;    push bc 
090f			;.dl8: 
090f			;    bit     0,a    	; 8 
090f			;    bit     0,a    	; 8 
090f			;    bit     0,a    	; 8 
090f			;    and     255  	; 7 
090f			;    dec     bc      	; 6 
090f			;    ld      a,c     	; 4 
090f			;    or      b     	; 4 
090f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
090f			;endif 
090f c1			    pop bc 
0910			 
0910 c9				ret 
0911			 
0911			 
0911			 
0911			; eof 
# End of file firmware_general.asm
0911			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0911			; display routines that use the physical hardware abstraction layer 
0911			 
0911			 
0911			; information window 
0911			 
0911			; pass hl with 1st string to display 
0911			; pass de with 2nd string to display 
0911			 
0911			info_panel: 
0911 e5				push hl 
0912			 
0912 2a d2 eb			ld hl, (display_fb_active) 
0915 e5				push hl    ; future de destination 
0916 21 b7 ed				ld hl, display_fb0 
0919 22 d2 eb				ld (display_fb_active), hl 
091c			 
091c			;	call clear_display 
091c			 
091c				if BASE_CPM 
091c 3e 2e			ld a, '.' 
091e				else 
091e				ld a, 165 
091e				endif 
091e cd 85 09			call fill_display 
0921			 
0921			 
0921 3e 55			ld a, display_row_3 + 5 
0923 cd 93 09			call str_at_display 
0926			 
0926 e1				pop hl 
0927 d1				pop de 
0928			 
0928 e5				push hl 
0929			 
0929			 
0929 3e 2d			ld a, display_row_2 + 5 
092b cd 93 09			call str_at_display 
092e			 
092e			 
092e cd a3 09			call update_display 
0931 cd 80 19			call next_page_prompt 
0934 cd 80 09			call clear_display 
0937			 
0937				 
0937 21 16 ed				ld hl, display_fb1 
093a 22 d2 eb				ld (display_fb_active), hl 
093d cd a3 09			call update_display 
0940			 
0940 e1				pop hl 
0941			 
0941 c9				ret 
0942			 
0942			 
0942			 
0942			 
0942			; TODO windowing? 
0942			 
0942			; TODO scroll line up 
0942			 
0942			scroll_up: 
0942			 
0942 e5				push hl 
0943 d5				push de 
0944 c5				push bc 
0945			 
0945				; get frame buffer  
0945			 
0945 2a d2 eb			ld hl, (display_fb_active) 
0948 e5				push hl    ; future de destination 
0949			 
0949 11 28 00			ld  de, display_cols 
094c 19				add hl, de 
094d			 
094d d1				pop de 
094e			 
094e				;ex de, hl 
094e 01 9f 00			ld bc, display_fb_len -1  
0951			;if DEBUG_FORTH_WORDS 
0951			;	DMARK "SCL" 
0951			;	CALLMONITOR 
0951			;endif	 
0951 ed b0			ldir 
0953			 
0953				; wipe bottom row 
0953			 
0953			 
0953 2a d2 eb			ld hl, (display_fb_active) 
0956 11 a0 00			ld de, display_cols*display_rows 
0959 19				add hl, de 
095a 06 28			ld b, display_cols 
095c 3e 20			ld a, ' ' 
095e			.scwipe: 
095e 77				ld (hl), a 
095f 2b				dec hl 
0960 10 fc			djnz .scwipe 
0962			 
0962				;pop hl 
0962			 
0962 c1				pop bc 
0963 d1				pop de 
0964 e1				pop hl 
0965			 
0965 c9				ret 
0966			 
0966			 
0966			;scroll_upo: 
0966			;	ld de, display_row_1 
0966			 ;	ld hl, display_row_2 
0966			;	ld bc, display_cols 
0966			;	ldir 
0966			;	ld de, display_row_2 
0966			 ;	ld hl, display_row_3 
0966			;	ld bc, display_cols 
0966			;	ldir 
0966			;	ld de, display_row_3 
0966			 ;	ld hl, display_row_4 
0966			;	ld bc, display_cols 
0966			;	ldir 
0966			 
0966			; TODO clear row 4 
0966			 
0966			;	ret 
0966			 
0966				 
0966			scroll_down: 
0966			 
0966 e5				push hl 
0967 d5				push de 
0968 c5				push bc 
0969			 
0969				; get frame buffer  
0969			 
0969 2a d2 eb			ld hl, (display_fb_active) 
096c			 
096c 11 9f 00			ld de, display_fb_len - 1 
096f 19				add hl, de 
0970			 
0970 e5			push hl    ; future de destination 
0971			 
0971 11 28 00			ld  de, display_cols 
0974 ed 52			sbc hl, de 
0976			 
0976			 
0976 d1				pop de 
0977			 
0977			;	ex de, hl 
0977 01 9f 00			ld bc, display_fb_len -1  
097a			 
097a			 
097a				 
097a			 
097a ed b0			ldir 
097c			 
097c				; wipe bottom row 
097c			 
097c			 
097c			;	ld hl, (display_fb_active) 
097c			;;	ld de, display_cols*display_rows 
097c			;;	add hl, de 
097c			;	ld b, display_cols 
097c			;	ld a, ' ' 
097c			;.scwiped: 
097c			;	ld (hl), a 
097c			;	dec hl 
097c			;	djnz .scwiped 
097c			 
097c				;pop hl 
097c			 
097c c1				pop bc 
097d d1				pop de 
097e e1				pop hl 
097f			 
097f c9				ret 
0980			;scroll_down: 
0980			;	ld de, display_row_4 
0980			;	ld hl, display_row_3 
0980			;	ld bc, display_cols 
0980			;	ldir 
0980			;	ld de, display_row_3 
0980			; 	ld hl, display_row_2 
0980			;	ld bc, display_cols 
0980			;	ldir 
0980			;	ld de, display_row_2 
0980			;	ld hl, display_row_1 
0980			;	ld bc, display_cols 
0980			;	ldir 
0980			;;; TODO clear row 1 
0980			;	ret 
0980			 
0980			 
0980			 
0980			 
0980			 
0980			; clear active frame buffer 
0980			 
0980			clear_display: 
0980 3e 20			ld a, ' ' 
0982 c3 85 09			jp fill_display 
0985			 
0985			; fill active frame buffer with a char in A 
0985			 
0985			fill_display: 
0985 06 a0			ld b,display_fb_len 
0987 2a d2 eb			ld hl, (display_fb_active) 
098a 77			.fd1:	ld (hl),a 
098b 23				inc hl 
098c 10 fc			djnz .fd1 
098e 23				inc hl 
098f 3e 00			ld a,0 
0991 77				ld (hl),a 
0992			 
0992			 
0992 c9				ret 
0993			; Write string (DE) at pos (A) to active frame buffer 
0993			 
0993 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
0996 06 00					ld b,0 
0998 4f					ld c,a 
0999 09					add hl,bc 
099a 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
099b b7			            OR   A              ;Null terminator? 
099c c8			            RET  Z              ;Yes, so finished 
099d 77					ld (hl),a 
099e 23				inc hl 
099f 13			            INC  DE             ;Point to next character 
09a0 18 f8		            JR   .sad1     ;Repeat 
09a2 c9					ret 
09a3			 
09a3			; using current frame buffer write to physical display 
09a3			 
09a3			update_display: 
09a3 e5				push hl 
09a4 2a d2 eb			ld hl, (display_fb_active) 
09a7 cd 73 58			call write_display 
09aa e1				pop hl 
09ab c9				ret 
09ac			 
09ac			; TODO scrolling 
09ac			 
09ac			 
09ac			; move cursor right one char 
09ac			cursor_right: 
09ac			 
09ac				; TODO shift right 
09ac				; TODO if beyond max col 
09ac				; TODO       cursor_next_line 
09ac			 
09ac c9				ret 
09ad			 
09ad			 
09ad			cursor_next_line: 
09ad				; TODO first char 
09ad				; TODO line down 
09ad				; TODO if past last row 
09ad				; TODO    scroll up 
09ad			 
09ad c9				ret 
09ae			 
09ae			cursor_left: 
09ae				; TODO shift left 
09ae				; TODO if beyond left  
09ae				; TODO     cursor prev line 
09ae				 
09ae c9				ret 
09af			 
09af			cursor_prev_line: 
09af				; TODO last char 
09af				; TODO line up 
09af				; TODO if past first row 
09af				; TODO   scroll down 
09af			 
09af c9				ret 
09b0			 
09b0			 
09b0			cout: 
09b0				; A - char 
09b0 c9				ret 
09b1			 
09b1			 
09b1			; Display a menu and allow item selection (optional toggle items) 
09b1			; 
09b1			; format: 
09b1			; hl pointer to word array with zero term for items 
09b1			; e.g.    db item1 
09b1			;         db .... 
09b1			;         db 0 
09b1			; 
09b1			; a = starting menu item  
09b1			; 
09b1			; de = pointer item toggle array   (todo) 
09b1			; 
09b1			; returns item selected in a 1-... 
09b1			; returns 0 if back button pressed 
09b1			; 
09b1			; NOTE: Uses system frame buffer to display 
09b1			; 
09b1			; LEFT, Q = go back 
09b1			; RIGHT, SPACE, CR = select 
09b1			; UP, A - Up 
09b1			; DOWN, Z - Down 
09b1			 
09b1			 
09b1			 
09b1			 
09b1			 
09b1			menu: 
09b1			 
09b1					; keep array pointer 
09b1			 
09b1 22 5a eb				ld (store_tmp1), hl 
09b4 32 58 eb				ld (store_tmp2), a 
09b7			 
09b7					; check for key bounce 
09b7			 
09b7			if BASE_KEV 
09b7			 
09b7			.mbounce:	call cin 
09b7					cp 0 
09b7					jr nz, .mbounce 
09b7			endif 
09b7					; for ease use ex 
09b7			 
09b7					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
09b7 21 b7 ed				ld hl, display_fb0 
09ba 22 d2 eb				ld (display_fb_active), hl 
09bd			 
09bd cd 80 09		.mloop:		call clear_display 
09c0 cd a3 09				call update_display 
09c3			 
09c3					; draw selection id '>' at 1 
09c3			 
09c3					; init start of list display 
09c3			 
09c3 3e 05				ld a, 5 
09c5 32 56 eb				ld (store_tmp3), a   ; display row count 
09c8 3a 58 eb				ld a,( store_tmp2) 
09cb 32 59 eb				ld (store_tmp2+1), a   ; display item count 
09ce			 
09ce					 
09ce			.mitem:	 
09ce			 
09ce			 
09ce 3a 59 eb				ld a,(store_tmp2+1) 
09d1 6f					ld l, a 
09d2 26 00				ld h, 0 
09d4 29					add hl, hl 
09d5 ed 5b 5a eb			ld de, (store_tmp1) 
09d9 19					add hl, de 
09da 7e					ld a, (hl) 
09db 23					inc hl 
09dc 66					ld h,(hl) 
09dd 6f					ld l, a 
09de			 
09de cd d6 0b				call ishlzero 
09e1 28 1a				jr z, .mdone 
09e3			 
09e3 eb					ex de, hl 
09e4 3a 56 eb				ld a, (store_tmp3) 
09e7 cd 93 09				call str_at_display 
09ea					 
09ea			 
09ea					; next item 
09ea 3a 59 eb				ld a, (store_tmp2+1) 
09ed 3c					inc a 
09ee 32 59 eb				ld (store_tmp2+1), a   ; display item count 
09f1			 
09f1			 		; next row 
09f1			 
09f1 3a 56 eb				ld a, (store_tmp3) 
09f4 c6 28				add display_cols 
09f6 32 56 eb				ld (store_tmp3), a 
09f9			 
09f9					; at end of screen? 
09f9			 
09f9 fe 10				cp display_rows*4 
09fb 20 d1				jr nz, .mitem 
09fd			 
09fd			 
09fd			.mdone: 
09fd cd d6 0b				call ishlzero 
0a00 28 08				jr z, .nodn 
0a02			 
0a02 3e 78				ld a, display_row_4 
0a04 11 83 0a				ld de, .mdown 
0a07 cd 93 09				call str_at_display 
0a0a			 
0a0a					; draw options to fill the screens with active item on line 1 
0a0a					; if current option is 2 or more then display ^ in top 
0a0a			 
0a0a 3a 58 eb		.nodn:		ld a, (store_tmp2) 
0a0d fe 00				cp 0 
0a0f 28 08				jr z, .noup 
0a11			 
0a11 3e 00				ld a, 0 
0a13 11 81 0a				ld de, .mup 
0a16 cd 93 09				call str_at_display 
0a19			 
0a19 3e 02		.noup:		ld a, 2 
0a1b 11 7f 0a				ld de, .msel 
0a1e cd 93 09				call str_at_display 
0a21			 
0a21					; if current option + 1 is not null then display V in bottom 
0a21					; get key 
0a21 cd a3 09				call update_display 
0a24			 
0a24			 
0a24					; handle key 
0a24			 
0a24 cd 25 59				call cin_wait 
0a27			 
0a27 fe 05				cp KEY_UP 
0a29 28 2b				jr z, .mgoup 
0a2b fe 61				cp 'a' 
0a2d 28 27				jr z, .mgoup 
0a2f fe 0a				cp KEY_DOWN 
0a31 28 32				jr z, .mgod 
0a33 fe 7a				cp 'z' 
0a35 28 2e				jr z, .mgod 
0a37 fe 20				cp ' ' 
0a39 28 34				jr z, .goend 
0a3b fe 0c				cp KEY_RIGHT 
0a3d 28 30				jr z, .goend 
0a3f fe 0d				cp KEY_CR 
0a41 28 2c				jr z, .goend 
0a43 fe 71				cp 'q' 
0a45 28 0b				jr z, .goback 
0a47			 
0a47 fe 0b				cp KEY_LEFT 
0a49 28 07				jr z, .goback 
0a4b fe 08				cp KEY_BS 
0a4d 28 03				jr z, .goback 
0a4f c3 bd 09				jp .mloop 
0a52			 
0a52			.goback: 
0a52 3e 00			ld a, 0 
0a54 18 1d			jr .goend2 
0a56			 
0a56				; move up one 
0a56			.mgoup: 
0a56 3a 58 eb				ld a, (store_tmp2) 
0a59 fe 00				cp 0 
0a5b ca bd 09				jp z, .mloop 
0a5e 3d					dec a 
0a5f 32 58 eb				ld (store_tmp2), a 
0a62 c3 bd 09				jp .mloop 
0a65			 
0a65				; move down one 
0a65			.mgod: 
0a65 3a 58 eb				ld a, (store_tmp2) 
0a68 3c					inc a 
0a69 32 58 eb				ld (store_tmp2), a 
0a6c c3 bd 09				jp .mloop 
0a6f			 
0a6f			 
0a6f			.goend: 
0a6f					; get selected item number 
0a6f			 
0a6f 3a 58 eb				ld a, (store_tmp2) 
0a72 3c					inc a 
0a73			 
0a73			.goend2: 
0a73 f5					push af 
0a74			 
0a74					; restore active fb 
0a74					; TODO BUG assumes fb1 
0a74			 
0a74 21 16 ed				ld hl, display_fb1 
0a77 22 d2 eb				ld (display_fb_active), hl 
0a7a			 
0a7a					; restore main regs 
0a7a			 
0a7a			 
0a7a cd a3 09				call update_display 
0a7d			 
0a7d f1					pop af 
0a7e			 
0a7e c9				ret 
0a7f			 
0a7f .. 00		.msel:   db ">",0 
0a81 .. 00		.mup:   db "^",0 
0a83 .. 00		.mdown:   db "v",0 
0a85			 
0a85			 
0a85			; eof 
0a85			 
# End of file firmware_display.asm
0a85			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0a85			; random number generators 
0a85			 
0a85			 
0a85			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0a85			 
0a85			 
0a85			;-----> Generate a random number 
0a85			; output a=answer 0<=a<=255 
0a85			; all registers are preserved except: af 
0a85			random: 
0a85 e5			        push    hl 
0a86 d5			        push    de 
0a87 2a b4 eb		        ld      hl,(randData) 
0a8a ed 5f		        ld      a,r 
0a8c 57			        ld      d,a 
0a8d 5e			        ld      e,(hl) 
0a8e 19			        add     hl,de 
0a8f 85			        add     a,l 
0a90 ac			        xor     h 
0a91 22 b4 eb		        ld      (randData),hl 
0a94 d1			        pop     de 
0a95 e1			        pop     hl 
0a96 c9			        ret 
0a97			 
0a97			 
0a97			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0a97			 
0a97			 
0a97			 
0a97			;------LFSR------ 
0a97			;James Montelongo 
0a97			;optimized by Spencer Putt 
0a97			;out: 
0a97			; a = 8 bit random number 
0a97			RandLFSR: 
0a97 21 ba eb		        ld hl,LFSRSeed+4 
0a9a 5e			        ld e,(hl) 
0a9b 23			        inc hl 
0a9c 56			        ld d,(hl) 
0a9d 23			        inc hl 
0a9e 4e			        ld c,(hl) 
0a9f 23			        inc hl 
0aa0 7e			        ld a,(hl) 
0aa1 47			        ld b,a 
0aa2 cb 13		        rl e  
0aa4 cb 12			rl d 
0aa6 cb 11		        rl c  
0aa8 17				rla 
0aa9 cb 13		        rl e  
0aab cb 12			rl d 
0aad cb 11		        rl c  
0aaf 17				rla 
0ab0 cb 13		        rl e  
0ab2 cb 12			rl d 
0ab4 cb 11		        rl c  
0ab6 17				rla 
0ab7 67			        ld h,a 
0ab8 cb 13		        rl e  
0aba cb 12			rl d 
0abc cb 11		        rl c  
0abe 17				rla 
0abf a8			        xor b 
0ac0 cb 13		        rl e  
0ac2 cb 12			rl d 
0ac4 ac			        xor h 
0ac5 a9			        xor c 
0ac6 aa			        xor d 
0ac7 21 bc eb		        ld hl,LFSRSeed+6 
0aca 11 bd eb		        ld de,LFSRSeed+7 
0acd 01 07 00		        ld bc,7 
0ad0 ed b8		        lddr 
0ad2 12			        ld (de),a 
0ad3 c9			        ret 
0ad4			 
0ad4			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ad4			 
0ad4			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ad4			 
0ad4			 
0ad4			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ad4			 
0ad4			prng16: 
0ad4			;Inputs: 
0ad4			;   (seed1) contains a 16-bit seed value 
0ad4			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ad4			;Outputs: 
0ad4			;   HL is the result 
0ad4			;   BC is the result of the LCG, so not that great of quality 
0ad4			;   DE is preserved 
0ad4			;Destroys: 
0ad4			;   AF 
0ad4			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ad4			;160cc 
0ad4			;26 bytes 
0ad4 2a ae eb		    ld hl,(seed1) 
0ad7 44			    ld b,h 
0ad8 4d			    ld c,l 
0ad9 29			    add hl,hl 
0ada 29			    add hl,hl 
0adb 2c			    inc l 
0adc 09			    add hl,bc 
0add 22 ae eb		    ld (seed1),hl 
0ae0 2a ac eb		    ld hl,(seed2) 
0ae3 29			    add hl,hl 
0ae4 9f			    sbc a,a 
0ae5 e6 2d		    and %00101101 
0ae7 ad			    xor l 
0ae8 6f			    ld l,a 
0ae9 22 ac eb		    ld (seed2),hl 
0aec 09			    add hl,bc 
0aed c9			    ret 
0aee			 
0aee			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0aee			 
0aee			rand32: 
0aee			;Inputs: 
0aee			;   (seed1_0) holds the lower 16 bits of the first seed 
0aee			;   (seed1_1) holds the upper 16 bits of the first seed 
0aee			;   (seed2_0) holds the lower 16 bits of the second seed 
0aee			;   (seed2_1) holds the upper 16 bits of the second seed 
0aee			;   **NOTE: seed2 must be non-zero 
0aee			;Outputs: 
0aee			;   HL is the result 
0aee			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0aee			;Destroys: 
0aee			;   AF 
0aee			;Tested and passes all CAcert tests 
0aee			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0aee			;it has a period of 18,446,744,069,414,584,320 
0aee			;roughly 18.4 quintillion. 
0aee			;LFSR taps: 0,2,6,7  = 11000101 
0aee			;291cc 
0aee			;seed1_0=$+1 
0aee			;    ld hl,12345 
0aee			;seed1_1=$+1 
0aee			;    ld de,6789 
0aee			;    ld b,h 
0aee			;    ld c,l 
0aee			;    add hl,hl \ rl e \ rl d 
0aee			;    add hl,hl \ rl e \ rl d 
0aee			;    inc l 
0aee			;    add hl,bc 
0aee			;    ld (seed1_0),hl 
0aee			;    ld hl,(seed1_1) 
0aee			;    adc hl,de 
0aee			;    ld (seed1_1),hl 
0aee			;    ex de,hl 
0aee			;seed2_0=$+1 
0aee			;    ld hl,9876 
0aee			;seed2_1=$+1 
0aee			;    ld bc,54321 
0aee			;    add hl,hl \ rl c \ rl b 
0aee			;    ld (seed2_1),bc 
0aee			;    sbc a,a 
0aee			;    and %11000101 
0aee			;    xor l 
0aee			;    ld l,a 
0aee			;    ld (seed2_0),hl 
0aee			;    ex de,hl 
0aee			;    add hl,bc 
0aee			;    ret 
0aee			; 
0aee			 
0aee			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0aee			; 20 bytes, 86 cycles (excluding ret) 
0aee			 
0aee			; returns   hl = pseudorandom number 
0aee			; corrupts   a 
0aee			 
0aee			; generates 16-bit pseudorandom numbers with a period of 65535 
0aee			; using the xorshift method: 
0aee			 
0aee			; hl ^= hl << 7 
0aee			; hl ^= hl >> 9 
0aee			; hl ^= hl << 8 
0aee			 
0aee			; some alternative shift triplets which also perform well are: 
0aee			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0aee			 
0aee			;  org 32768 
0aee			 
0aee			xrnd: 
0aee 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
0af1 3e 00		  ld a,0 
0af3 bd			  cp l 
0af4 20 02		  jr nz, .xrnd1 
0af6 2e 01		  ld l, 1 
0af8			.xrnd1: 
0af8			 
0af8 7c			  ld a,h 
0af9 1f			  rra 
0afa 7d			  ld a,l 
0afb 1f			  rra 
0afc ac			  xor h 
0afd 67			  ld h,a 
0afe 7d			  ld a,l 
0aff 1f			  rra 
0b00 7c			  ld a,h 
0b01 1f			  rra 
0b02 ad			  xor l 
0b03 6f			  ld l,a 
0b04 ac			  xor h 
0b05 67			  ld h,a 
0b06			 
0b06 22 b2 eb		  ld (xrandc),hl 
0b09			 
0b09 c9			  ret 
0b0a			;  
0b0a			 
0b0a			 
0b0a			;;;; int maths 
0b0a			 
0b0a			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b0a			; Divide 16-bit values (with 16-bit result) 
0b0a			; In: Divide BC by divider DE 
0b0a			; Out: BC = result, HL = rest 
0b0a			; 
0b0a			Div16: 
0b0a 21 00 00		    ld hl,0 
0b0d 78			    ld a,b 
0b0e 06 08		    ld b,8 
0b10			Div16_Loop1: 
0b10 17			    rla 
0b11 ed 6a		    adc hl,hl 
0b13 ed 52		    sbc hl,de 
0b15 30 01		    jr nc,Div16_NoAdd1 
0b17 19			    add hl,de 
0b18			Div16_NoAdd1: 
0b18 10 f6		    djnz Div16_Loop1 
0b1a 17			    rla 
0b1b 2f			    cpl 
0b1c 47			    ld b,a 
0b1d 79			    ld a,c 
0b1e 48			    ld c,b 
0b1f 06 08		    ld b,8 
0b21			Div16_Loop2: 
0b21 17			    rla 
0b22 ed 6a		    adc hl,hl 
0b24 ed 52		    sbc hl,de 
0b26 30 01		    jr nc,Div16_NoAdd2 
0b28 19			    add hl,de 
0b29			Div16_NoAdd2: 
0b29 10 f6		    djnz Div16_Loop2 
0b2b 17			    rla 
0b2c 2f			    cpl 
0b2d 41			    ld b,c 
0b2e 4f			    ld c,a 
0b2f c9			ret 
0b30			 
0b30			 
0b30			;http://z80-heaven.wikidot.com/math 
0b30			; 
0b30			;Inputs: 
0b30			;     DE and A are factors 
0b30			;Outputs: 
0b30			;     A is not changed 
0b30			;     B is 0 
0b30			;     C is not changed 
0b30			;     DE is not changed 
0b30			;     HL is the product 
0b30			;Time: 
0b30			;     342+6x 
0b30			; 
0b30			Mult16: 
0b30			 
0b30 06 08		     ld b,8          ;7           7 
0b32 21 00 00		     ld hl,0         ;10         10 
0b35 29			       add hl,hl     ;11*8       88 
0b36 07			       rlca          ;4*8        32 
0b37 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b39 19			         add hl,de   ;--         -- 
0b3a 10 f9		       djnz $-5      ;13*7+8     99 
0b3c c9			ret 
0b3d			 
0b3d			; 
0b3d			; Square root of 16-bit value 
0b3d			; In:  HL = value 
0b3d			; Out:  D = result (rounded down) 
0b3d			; 
0b3d			;Sqr16: 
0b3d			;    ld de,#0040 
0b3d			;    ld a,l 
0b3d			;    ld l,h 
0b3d			;    ld h,d 
0b3d			;    or a 
0b3d			;    ld b,8 
0b3d			;Sqr16_Loop: 
0b3d			;    sbc hl,de 
0b3d			;    jr nc,Sqr16_Skip 
0b3d			;    add hl,de 
0b3d			;Sqr16_Skip: 
0b3d			;    ccf 
0b3d			;    rl d 
0b3d			;    add a,a 
0b3d			;    adc hl,hl 
0b3d			;    add a,a 
0b3d			;    adc hl,hl 
0b3d			;    djnz Sqr16_Loop 
0b3d			;    ret 
0b3d			; 
0b3d			; 
0b3d			; Divide 8-bit values 
0b3d			; In: Divide E by divider C 
0b3d			; Out: A = result, B = rest 
0b3d			; 
0b3d			Div8: 
0b3d af			    xor a 
0b3e 06 08		    ld b,8 
0b40			Div8_Loop: 
0b40 cb 13		    rl e 
0b42 17			    rla 
0b43 91			    sub c 
0b44 30 01		    jr nc,Div8_NoAdd 
0b46 81			    add a,c 
0b47			Div8_NoAdd: 
0b47 10 f7		    djnz Div8_Loop 
0b49 47			    ld b,a 
0b4a 7b			    ld a,e 
0b4b 17			    rla 
0b4c 2f			    cpl 
0b4d c9			    ret 
0b4e			 
0b4e			; 
0b4e			; Multiply 8-bit value with a 16-bit value (unrolled) 
0b4e			; In: Multiply A with DE 
0b4e			; Out: HL = result 
0b4e			; 
0b4e			Mult12U: 
0b4e 2e 00		    ld l,0 
0b50 87			    add a,a 
0b51 30 01		    jr nc,Mult12U_NoAdd0 
0b53 19			    add hl,de 
0b54			Mult12U_NoAdd0: 
0b54 29			    add hl,hl 
0b55 87			    add a,a 
0b56 30 01		    jr nc,Mult12U_NoAdd1 
0b58 19			    add hl,de 
0b59			Mult12U_NoAdd1: 
0b59 29			    add hl,hl 
0b5a 87			    add a,a 
0b5b 30 01		    jr nc,Mult12U_NoAdd2 
0b5d 19			    add hl,de 
0b5e			Mult12U_NoAdd2: 
0b5e 29			    add hl,hl 
0b5f 87			    add a,a 
0b60 30 01		    jr nc,Mult12U_NoAdd3 
0b62 19			    add hl,de 
0b63			Mult12U_NoAdd3: 
0b63 29			    add hl,hl 
0b64 87			    add a,a 
0b65 30 01		    jr nc,Mult12U_NoAdd4 
0b67 19			    add hl,de 
0b68			Mult12U_NoAdd4: 
0b68 29			    add hl,hl 
0b69 87			    add a,a 
0b6a 30 01		    jr nc,Mult12U_NoAdd5 
0b6c 19			    add hl,de 
0b6d			Mult12U_NoAdd5: 
0b6d 29			    add hl,hl 
0b6e 87			    add a,a 
0b6f 30 01		    jr nc,Mult12U_NoAdd6 
0b71 19			    add hl,de 
0b72			Mult12U_NoAdd6: 
0b72 29			    add hl,hl 
0b73 87			    add a,a 
0b74 d0			    ret nc 
0b75 19			    add hl,de 
0b76 c9			    ret 
0b77			 
0b77			; 
0b77			; Multiply 8-bit value with a 16-bit value (right rotating) 
0b77			; In: Multiply A with DE 
0b77			;      Put lowest value in A for most efficient calculation 
0b77			; Out: HL = result 
0b77			; 
0b77			Mult12R: 
0b77 21 00 00		    ld hl,0 
0b7a			Mult12R_Loop: 
0b7a cb 3f		    srl a 
0b7c 30 01		    jr nc,Mult12R_NoAdd 
0b7e 19			    add hl,de 
0b7f			Mult12R_NoAdd: 
0b7f cb 23		    sla e 
0b81 cb 12		    rl d 
0b83 b7			    or a 
0b84 c2 7a 0b		    jp nz,Mult12R_Loop 
0b87 c9			    ret 
0b88			 
0b88			; 
0b88			; Multiply 16-bit values (with 32-bit result) 
0b88			; In: Multiply BC with DE 
0b88			; Out: BCHL = result 
0b88			; 
0b88			Mult32: 
0b88 79			    ld a,c 
0b89 48			    ld c,b 
0b8a 21 00 00		    ld hl,0 
0b8d 06 10		    ld b,16 
0b8f			Mult32_Loop: 
0b8f 29			    add hl,hl 
0b90 17			    rla 
0b91 cb 11		    rl c 
0b93 30 07		    jr nc,Mult32_NoAdd 
0b95 19			    add hl,de 
0b96 ce 00		    adc a,0 
0b98 d2 9c 0b		    jp nc,Mult32_NoAdd 
0b9b 0c			    inc c 
0b9c			Mult32_NoAdd: 
0b9c 10 f1		    djnz Mult32_Loop 
0b9e 41			    ld b,c 
0b9f 4f			    ld c,a 
0ba0 c9			    ret 
0ba1			 
0ba1			 
0ba1			 
0ba1			; 
0ba1			; Multiply 8-bit values 
0ba1			; In:  Multiply H with E 
0ba1			; Out: HL = result 
0ba1			; 
0ba1			Mult8: 
0ba1 16 00		    ld d,0 
0ba3 6a			    ld l,d 
0ba4 06 08		    ld b,8 
0ba6			Mult8_Loop: 
0ba6 29			    add hl,hl 
0ba7 30 01		    jr nc,Mult8_NoAdd 
0ba9 19			    add hl,de 
0baa			Mult8_NoAdd: 
0baa 10 fa		    djnz Mult8_Loop 
0bac c9			    ret 
0bad			 
0bad			 
0bad			 
0bad			 
0bad			 
0bad			 
0bad			 
0bad			 
0bad			;;http://z80-heaven.wikidot.com/math 
0bad			;;This divides DE by BC, storing the result in DE, remainder in HL 
0bad			; 
0bad			;DE_Div_BC:          ;1281-2x, x is at most 16 
0bad			;     ld a,16        ;7 
0bad			;     ld hl,0        ;10 
0bad			;     jp $+5         ;10 
0bad			;.DivLoop: 
0bad			;       add hl,bc    ;-- 
0bad			;       dec a        ;64 
0bad			;       jr z,.DivLoopEnd        ;86 
0bad			; 
0bad			;       sla e        ;128 
0bad			;       rl d         ;128 
0bad			;       adc hl,hl    ;240 
0bad			;       sbc hl,bc    ;240 
0bad			;       jr nc,.DivLoop ;23|21 
0bad			;       inc e        ;-- 
0bad			;       jp .DivLoop+1 
0bad			; 
0bad			;.DivLoopEnd: 
0bad			 
0bad			;HL_Div_C: 
0bad			;Inputs: 
0bad			;     HL is the numerator 
0bad			;     C is the denominator 
0bad			;Outputs: 
0bad			;     A is the remainder 
0bad			;     B is 0 
0bad			;     C is not changed 
0bad			;     DE is not changed 
0bad			;     HL is the quotient 
0bad			; 
0bad			;       ld b,16 
0bad			;       xor a 
0bad			;         add hl,hl 
0bad			;         rla 
0bad			;         cp c 
0bad			;         jr c,$+4 
0bad			;           inc l 
0bad			;           sub c 
0bad			;         djnz $-7 
0bad			 
0bad			; https://plutiedev.com/z80-add-8bit-to-16bit 
0bad			 
0bad			addatohl: 
0bad 85			    add   a, l    ; A = A+L 
0bae 6f			    ld    l, a    ; L = A+L 
0baf 8c			    adc   a, h    ; A = A+L+H+carry 
0bb0 95			    sub   l       ; A = H+carry 
0bb1 67			    ld    h, a    ; H = H+carry 
0bb2 c9			ret 
0bb3			 
0bb3			addatode: 
0bb3 83			    add   a, e    ; A = A+L 
0bb4 5f			    ld    e, a    ; L = A+L 
0bb5 8a			    adc   a, d    ; A = A+L+H+carry 
0bb6 93			    sub   e       ; A = H+carry 
0bb7 57			    ld    d, a    ; H = H+carry 
0bb8 c9			ret 
0bb9			 
0bb9			 
0bb9			addatobc: 
0bb9 81			    add   a, c    ; A = A+L 
0bba 4f			    ld    c, a    ; L = A+L 
0bbb 88			    adc   a, b    ; A = A+L+H+carry 
0bbc 91			    sub   c       ; A = H+carry 
0bbd 47			    ld    b, a    ; H = H+carry 
0bbe c9			ret 
0bbf			 
0bbf			subafromhl: 
0bbf			   ; If A=0 do nothing 
0bbf			    ; Otherwise flip A's sign. Since 
0bbf			    ; the upper byte becomes -1, also 
0bbf			    ; substract 1 from H. 
0bbf ed 44		    neg 
0bc1 ca ca 0b		    jp    z, Skip 
0bc4 25			    dec   h 
0bc5			     
0bc5			    ; Now add the low byte as usual 
0bc5			    ; Two's complement takes care of 
0bc5			    ; ensuring the result is correct 
0bc5 85			    add   a, l 
0bc6 6f			    ld    l, a 
0bc7 8c			    adc   a, h 
0bc8 95			    sub   l 
0bc9 67			    ld    h, a 
0bca			Skip: 
0bca c9				ret 
0bcb			 
0bcb			 
0bcb			; compare hl and de 
0bcb			; returns:  
0bcb			; if hl = de, z=1, s=0, c0=0 
0bcb			; if hl > de, z=0, s=0, c=0 
0bcb			; if hl < de, z=0, s=1, c=1 
0bcb			cmp16:	 
0bcb b7				or a 
0bcc ed 52			sbc hl,de 
0bce e0				ret po 
0bcf 7c				ld a,h 
0bd0 1f				rra 
0bd1 ee 40			xor 01000000B 
0bd3 37				scf 
0bd4 8f				adc a,a 
0bd5 c9				ret 
0bd6			 
0bd6			 
0bd6			; test if hl contains zero   - A is destroyed 
0bd6			 
0bd6			ishlzero:    
0bd6 b7				or a     ; reset flags 
0bd7 7c				ld a, h 
0bd8 b5				or l        	 
0bd9			 
0bd9 c9				ret 
0bda			 
0bda			 
0bda			 
0bda			 
0bda			if FORTH_ENABLE_FLOATMATH 
0bda			;include "float/bbcmath.z80" 
0bda			include "float/lpfpcalc.asm" 
0bda			endif 
0bda			 
0bda			 
0bda			; eof 
0bda			 
# End of file firmware_maths.asm
0bda			include "firmware_strings.asm"   ; string handling  
0bda			 
0bda			 
0bda			; TODO string len 
0bda			; input text string, end on cr with zero term 
0bda			; a offset into frame buffer to start prompt 
0bda			; d is max length 
0bda			; e is display size TODO 
0bda			; c is current cursor position 
0bda			; hl is ptr to where string will be stored 
0bda			 
0bda			 
0bda			; TODO check limit of buffer for new inserts 
0bda			; TODO check insert does not push beyond buffer 
0bda			; TODO scroll in a limited display area 
0bda			; TODO scroll whole screen on page wrap 
0bda			 
0bda			 
0bda			; TODO handle KEY_PREVWORD 
0bda			; TODO handle KEY_NEXTWORD 
0bda			; TODO handle KEY_HOME 
0bda			; TODO handle KEY_END 
0bda			; TODO use LCD cursor? 
0bda			 
0bda 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0bdd 81					add c 
0bde 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0be1 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0be4 79					ld a, c 
0be5 cd ad 0b				call addatohl 
0be8 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0beb 7a					ld a,d 
0bec 32 6c ee			        ld (input_size), a       ; save length of input area 
0bef 79					ld a, c 
0bf0 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0bf3 7b					ld a,e 
0bf4 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0bf7					 
0bf7					 
0bf7			 
0bf7			;		ld a,(input_ptr) 
0bf7			;		ld (input_under_cursor),a 	; save what is under the cursor 
0bf7			 
0bf7			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0bf7					; init cursor shape if not set by the cin routines 
0bf7 21 ca eb				ld hl, cursor_shape 
0bfa 3e ff				ld a, 255 
0bfc 77					ld (hl), a 
0bfd 23					inc hl 
0bfe 3e 00				ld a, 0 
0c00 77					ld (hl), a 
0c01			 
0c01 3e 0f				ld a, CUR_BLINK_RATE 
0c03 32 66 ee				ld (input_cur_flash), a 
0c06 3e 01				ld a, 1 
0c08 32 65 ee				ld (input_cur_onoff),a 
0c0b			 
0c0b			;	if DEBUG_INPUT 
0c0b			;		push af 
0c0b			;		ld a, 'I' 
0c0b			;		ld (debug_mark),a 
0c0b			;		pop af 
0c0b			;		CALLMONITOR 
0c0b			;	endif 
0c0b			.is1:		; main entry loop 
0c0b			 
0c0b			 
0c0b			 
0c0b					; pause 1ms 
0c0b			 
0c0b 3e 01				ld a, 1 
0c0d cd d7 08				call aDelayInMS 
0c10			 
0c10					; dec flash counter 
0c10 3a 66 ee				ld a, (input_cur_flash) 
0c13 3d					dec a 
0c14 32 66 ee				ld (input_cur_flash), a 
0c17 fe 00				cp 0 
0c19 20 0d				jr nz, .nochgstate 
0c1b			 
0c1b			 
0c1b					; change state 
0c1b 3a 65 ee				ld a,(input_cur_onoff) 
0c1e ed 44				neg 
0c20 32 65 ee				ld (input_cur_onoff),a 
0c23			 
0c23			 
0c23					; reset on change of state 
0c23 3e 0f				ld a, CUR_BLINK_RATE 
0c25 32 66 ee				ld (input_cur_flash), a 
0c28			 
0c28			.nochgstate: 
0c28					 
0c28					 
0c28			 
0c28					; display cursor  
0c28			 
0c28			;		ld hl, (input_start) 
0c28			;		ld a, (input_cursor) 
0c28			;		call addatohl 
0c28			 
0c28					; get char under cursor and replace with cursor 
0c28 2a 6f ee		ld hl, (input_ptr) 
0c2b			;		ld a, (hl) 
0c2b			;		ld (input_under_cursor),a 
0c2b			;		ld a, '_' 
0c2b			;		ld (hl), a 
0c2b			 
0c2b					; display string 
0c2b			 
0c2b ed 5b 6d ee			ld de, (input_start) 
0c2f 3a 6a ee				ld a, (input_at_pos) 
0c32 cd 93 09				call str_at_display 
0c35			;	        call update_display 
0c35			 
0c35					; find place to put the cursor 
0c35			;		add h 
0c35			;		ld l, display_row_1 
0c35			;		sub l 
0c35			; (input_at_pos) 
0c35					;ld c, a 
0c35			;		ld a, (input_cursor) 
0c35			;		ld l, (input_at_pos) 
0c35			;		;ld b, h 
0c35			;		add l 
0c35			;		ld (input_at_cursor),a 
0c35					;ld l,h 
0c35			 
0c35			;		ld h, 0 
0c35			;		ld l,(input_at_pos) 
0c35			;		ld a, (input_cursor) 
0c35			;		call addatohl 
0c35			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c35			;		call subafromhl 
0c35			;		ld a,l 
0c35			;		ld (input_at_cursor), a 
0c35			 
0c35				if DEBUG_INPUT 
0c35					ld a, (hardware_diag) 
0c35					cp 0 
0c35					jr z, .skip_input_diag 
0c35			 
0c35					ld a,(input_at_pos) 
0c35					ld hl, LFSRSeed 
0c35					call hexout 
0c35					ld a, (input_cursor) 
0c35					ld hl, LFSRSeed+2 
0c35					call hexout 
0c35					ld a,(input_at_cursor) 
0c35					ld hl, LFSRSeed+4 
0c35					call hexout 
0c35			 
0c35					ld a,(input_cur_onoff) 
0c35					ld hl, LFSRSeed+6 
0c35					call hexout 
0c35			 
0c35					ld a,(input_cur_flash) 
0c35					ld hl, LFSRSeed+8 
0c35					call hexout 
0c35			 
0c35					ld a,(input_len) 
0c35					ld hl, LFSRSeed+10 
0c35					call hexout 
0c35					ld hl, LFSRSeed+12 
0c35					ld a, 0 
0c35					ld (hl),a 
0c35					ld a, display_row_4 
0c35					ld de, LFSRSeed 
0c35					call str_at_display 
0c35					.skip_input_diag: 
0c35				endif 
0c35			 
0c35					; decide on if we are showing the cursor this time round 
0c35			 
0c35 3a 65 ee				ld a, (input_cur_onoff) 
0c38 fe ff				cp 255 
0c3a 28 13				jr z, .skipcur 
0c3c			 
0c3c			 
0c3c 3a 68 ee				ld a,(input_at_cursor) 
0c3f 11 ca eb				ld de, cursor_shape 
0c42 cd 93 09				call str_at_display 
0c45			 
0c45					; save length of current input string 
0c45 2a 6d ee				ld hl, (input_start) 
0c48 cd 0b 10				call strlenz 
0c4b 7d					ld a,l 
0c4c 32 60 ee				ld (input_len),a 
0c4f			 
0c4f			.skipcur: 
0c4f			 
0c4f cd a3 09			        call update_display 
0c52					 
0c52			 
0c52			 
0c52					; wait 
0c52				 
0c52					; TODO loop without wait to flash the cursor and char under cursor	 
0c52 cd 2d 59				call cin    ; _wait 
0c55			 
0c55 fe 00				cp 0 
0c57 ca 0b 0c				jp z, .is1 
0c5a			 
0c5a					; get ptr to char to input into 
0c5a			 
0c5a 4f					ld c,a 
0c5b 2a 6d ee				ld hl, (input_start) 
0c5e 3a 5b ee				ld a, (input_cursor) 
0c61 cd ad 0b				call addatohl 
0c64 22 6f ee				ld (input_ptr), hl 
0c67 79					ld a,c 
0c68			 
0c68					; replace char under cursor 
0c68			 
0c68			;		ld hl, (input_ptr) 
0c68			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0c68			;		ld (hl), a 
0c68			 
0c68			;	if DEBUG_INPUT 
0c68			;		push af 
0c68			;		ld a, 'i' 
0c68			;		ld (debug_mark),a 
0c68			;		pop af 
0c68			;		CALLMONITOR 
0c68			;	endif 
0c68 fe 0e				cp KEY_HOME 
0c6a 20 0e				jr nz, .iske 
0c6c			 
0c6c 3a 6a ee				ld a, (input_at_pos) 
0c6f 32 68 ee				ld (input_at_cursor),a 
0c72 3e 00				ld a, 0 
0c74 32 5b ee				ld (input_cursor), a 
0c77 c3 0b 0c				jp .is1 
0c7a					 
0c7a fe 0f		.iske:		cp KEY_END 
0c7c 20 03				jr nz, .isknw 
0c7e c3 0b 0c				jp .is1 
0c81			 
0c81 fe 06		.isknw:		cp KEY_NEXTWORD 
0c83 20 1b				jr nz, .iskpw 
0c85			 
0c85 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0c88 7e					ld a,(hl)	 
0c89 fe 00				cp 0 
0c8b ca 0b 0c				jp z, .is1    ; end of string 
0c8e fe 20				cp ' ' 
0c90 ca 0b 0c				jp z, .is1    ; end of word 
0c93 23					inc hl 
0c94 22 6f ee				ld (input_ptr), hl 
0c97 3a 68 ee				ld a, (input_at_cursor) 
0c9a 3c					inc a 
0c9b 32 68 ee				ld (input_at_cursor), a 
0c9e 18 e5				jr .isknwm 
0ca0			 
0ca0 fe 07		.iskpw:		cp KEY_PREVWORD 
0ca2 20 1b				jr nz, .iskl 
0ca4			.iskpwm:	 
0ca4 2a 6f ee				ld hl, (input_ptr) 
0ca7 7e					ld a,(hl)	 
0ca8 fe 00				cp 0  
0caa ca 0b 0c				jp z, .is1    ; end of string 
0cad fe 20				cp ' ' 
0caf ca 0b 0c				jp z, .is1    ; end of word 
0cb2 2b					dec hl 
0cb3 22 6f ee				ld (input_ptr), hl 
0cb6 3a 68 ee				ld a, (input_at_cursor) 
0cb9 3d					dec a 
0cba 32 68 ee				ld (input_at_cursor), a 
0cbd 18 e5				jr .iskpwm 
0cbf			 
0cbf			 
0cbf fe 0b		.iskl:		cp KEY_LEFT 
0cc1 20 27				jr nz, .isk1 
0cc3			 
0cc3 3a 5b ee				ld a, (input_cursor) 
0cc6			 
0cc6 fe 00				cp 0 
0cc8 ca 0b 0c				jp z, .is1 		; at start of line to ignore  
0ccb			 
0ccb 3d					dec  a 		; TODO check underflow 
0ccc 32 5b ee				ld (input_cursor), a 
0ccf			 
0ccf 2a 6f ee				ld hl, (input_ptr) 
0cd2 2b					dec hl 
0cd3 22 6f ee				ld (input_ptr), hl 
0cd6					 
0cd6 3a 68 ee				ld a, (input_at_cursor) 
0cd9 3d					dec a 
0cda 32 68 ee				ld (input_at_cursor), a 
0cdd			 
0cdd 3e 01				ld a, 1		; show cursor moving 
0cdf 32 65 ee				ld (input_cur_onoff),a 
0ce2 3e 0f				ld a, CUR_BLINK_RATE 
0ce4 32 66 ee				ld (input_cur_flash), a 
0ce7			 
0ce7 c3 0b 0c				jp .is1 
0cea			 
0cea fe 0c		.isk1:		cp KEY_RIGHT 
0cec 20 2a				jr nz, .isk2 
0cee			 
0cee 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0cf1 5f					ld e,a 
0cf2 3a 5b ee				ld a, (input_cursor) 
0cf5 bb					cp e 
0cf6 ca 0b 0c				jp z, .is1		; at the end of string so dont go right 
0cf9			 
0cf9 3c					inc  a 		; TODO check overflow 
0cfa 32 5b ee				ld (input_cursor), a 
0cfd			 
0cfd 3a 68 ee				ld a, (input_at_cursor) 
0d00 3c					inc a 
0d01 32 68 ee				ld (input_at_cursor), a 
0d04			 
0d04 2a 6f ee				ld hl, (input_ptr) 
0d07 23					inc hl 
0d08 22 6f ee				ld (input_ptr), hl 
0d0b			 
0d0b 3e 01				ld a, 1		; show cursor moving 
0d0d 32 65 ee				ld (input_cur_onoff),a 
0d10 3e 0f				ld a, CUR_BLINK_RATE 
0d12 32 66 ee				ld (input_cur_flash), a 
0d15			 
0d15 c3 0b 0c				jp .is1 
0d18			 
0d18 fe 05		.isk2:		cp KEY_UP 
0d1a			 
0d1a 20 26				jr nz, .isk3 
0d1c			 
0d1c					; swap last command with the current on 
0d1c			 
0d1c					; move cursor to start of string 
0d1c 2a 6d ee				ld hl, (input_start) 
0d1f 22 6f ee				ld (input_ptr), hl 
0d22			 
0d22 3a 6a ee				ld a, (input_at_pos) 
0d25 32 68 ee				ld (input_at_cursor), a 
0d28			 
0d28 3e 00				ld a, 0 
0d2a 32 5b ee				ld (input_cursor), a 
0d2d					 
0d2d					; swap input and last command buffers 
0d2d			 
0d2d 21 7e e6				ld hl, os_cli_cmd 
0d30 11 7d e7				ld de, os_last_cmd 
0d33 06 ff				ld b, 255 
0d35 7e			.swap1:		ld a, (hl) 
0d36 4f					ld c,a 
0d37 1a					ld a, (de) 
0d38 77					ld (hl), a 
0d39 79					ld a,c 
0d3a 12					ld (de),a 
0d3b 23					inc hl 
0d3c 13					inc de 
0d3d 10 f6				djnz .swap1 
0d3f			 
0d3f			 
0d3f			 
0d3f			 
0d3f			 
0d3f c3 0b 0c				jp .is1 
0d42			 
0d42 fe 08		.isk3:		cp KEY_BS 
0d44 20 3c				jr nz, .isk4 
0d46			 
0d46 3a 5b ee				ld a, (input_cursor) 
0d49			 
0d49 fe 00				cp 0 
0d4b ca 0b 0c				jp z, .is1 		; at start of line to ignore  
0d4e			 
0d4e 3d					dec  a 		; TODO check underflow 
0d4f 32 5b ee				ld (input_cursor), a 
0d52			 
0d52					; hl is source 
0d52					; de needs to be source - 1 
0d52			 
0d52			;		ld a, 0 
0d52			;		dec hl 
0d52			;		ld (hl), a 
0d52			 
0d52 2a 6f ee				ld hl, (input_ptr) 
0d55 2b					dec hl 
0d56 22 6f ee				ld (input_ptr), hl 
0d59			 
0d59					; shift all data 
0d59			 
0d59 e5					push hl 
0d5a 23					inc hl 
0d5b d1					pop de 
0d5c 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0d5f 4f					ld c,a 
0d60 06 00				ld b,0 
0d62 ed b0				ldir  
0d64			 
0d64			 
0d64			 
0d64			 
0d64 3a 68 ee				ld a, (input_at_cursor) 
0d67 3d					dec a 
0d68 32 68 ee				ld (input_at_cursor), a 
0d6b			 
0d6b			 
0d6b 3e 01				ld a, 1		; show cursor moving 
0d6d 32 65 ee				ld (input_cur_onoff),a 
0d70 3e 0f				ld a, CUR_BLINK_RATE 
0d72 32 66 ee				ld (input_cur_flash), a 
0d75			 
0d75					; remove char 
0d75 3a 68 ee				ld a, (input_at_cursor) 
0d78 3c					inc a 
0d79 11 03 0e				ld de,.iblank 
0d7c cd 93 09				call str_at_display 
0d7f			 
0d7f c3 0b 0c				jp .is1 
0d82			 
0d82 fe 0d		.isk4:		cp KEY_CR 
0d84 28 6c				jr z, .endinput 
0d86			 
0d86					; else add the key press to the end 
0d86			 
0d86 4f					ld c, a			; save key pressed 
0d87			 
0d87 7e					ld a,(hl)		; get what is currently under char 
0d88			 
0d88 fe 00				cp 0			; we are at the end of the string 
0d8a 20 2f				jr nz, .onchar 
0d8c					 
0d8c					; add a char to the end of the string 
0d8c				 
0d8c 71					ld (hl),c 
0d8d 23					inc hl 
0d8e			;		ld a,' ' 
0d8e			;		ld (hl),a 
0d8e			;		inc hl 
0d8e 3e 00				ld a,0 
0d90 77					ld (hl),a 
0d91 2b					dec hl 
0d92			 
0d92 3a 5b ee				ld a, (input_cursor) 
0d95 3c					inc a				; TODO check max string length and scroll  
0d96 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0d99							 
0d99 3a 68 ee				ld a, (input_at_cursor) 
0d9c 3c					inc a 
0d9d 32 68 ee				ld (input_at_cursor), a 
0da0			 
0da0 2a 6f ee				ld hl, (input_ptr) 
0da3 23					inc hl 
0da4 22 6f ee				ld (input_ptr), hl 
0da7			 
0da7 2a 6f ee				ld hl, (input_ptr) 
0daa 23					inc hl 
0dab 22 6f ee				ld (input_ptr), hl 
0dae			;	if DEBUG_INPUT 
0dae			;		push af 
0dae			;		ld a, '+' 
0dae			;		ld (debug_mark),a 
0dae			;		pop af 
0dae			;		CALLMONITOR 
0dae			;	endif 
0dae 3e 01				ld a, 1		; show cursor moving 
0db0 32 65 ee				ld (input_cur_onoff),a 
0db3 3e 0f				ld a, CUR_BLINK_RATE 
0db5 32 66 ee				ld (input_cur_flash), a 
0db8 c3 0b 0c				jp .is1 
0dbb					 
0dbb			 
0dbb			 
0dbb					; if on a char then insert 
0dbb			.onchar: 
0dbb			 
0dbb					; TODO over flow check: make sure insert does not blow out buffer 
0dbb			 
0dbb					; need to do some maths to use lddr 
0dbb			 
0dbb e5					push hl   ; save char pos 
0dbc c5					push bc 
0dbd			 
0dbd 2a 6d ee				ld hl, (input_start) 
0dc0 3a 60 ee				ld a, (input_len) 
0dc3 cd ad 0b				call addatohl  		; end of string 
0dc6 23					inc hl 
0dc7 23					inc hl		; past zero term 
0dc8 e5					push hl 
0dc9 23					inc hl 
0dca e5					push hl  
0dcb			 
0dcb								; start and end of lddr set, now how much to move? 
0dcb			 
0dcb							 
0dcb 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0dce 47					ld b,a 
0dcf 3a 60 ee				ld a,(input_len) 
0dd2 5f					ld e,a 
0dd3 90					sub b 
0dd4 3c					inc a		;?? 
0dd5 3c					inc a		;?? 
0dd6 3c					inc a		;?? 
0dd7			 
0dd7 06 00				ld b,0 
0dd9 4f					ld c,a 
0dda			 
0dda				if DEBUG_INPUT 
0dda					push af 
0dda					ld a, 'i' 
0dda					ld (debug_mark),a 
0dda					pop af 
0dda			;		CALLMONITOR 
0dda				endif 
0dda d1					pop de 
0ddb e1					pop hl 
0ddc				if DEBUG_INPUT 
0ddc					push af 
0ddc					ld a, 'I' 
0ddc					ld (debug_mark),a 
0ddc					pop af 
0ddc			;		CALLMONITOR 
0ddc				endif 
0ddc ed b8				lddr 
0dde				 
0dde			 
0dde			 
0dde					; TODO have a key for insert/overwrite mode???? 
0dde c1					pop bc 
0ddf e1					pop hl 
0de0 71					ld (hl), c		; otherwise overwrite current char 
0de1					 
0de1			 
0de1			 
0de1			 
0de1 3a 5b ee				ld a, (input_cursor) 
0de4 3c					inc  a 		; TODO check overflow 
0de5 32 5b ee				ld (input_cursor), a 
0de8			 
0de8 3a 68 ee				ld a, (input_at_cursor) 
0deb 3c					inc a 
0dec 32 68 ee				ld (input_at_cursor), a 
0def			 
0def c3 0b 0c				jp .is1 
0df2			 
0df2			.endinput:	; TODO look for end of string 
0df2			 
0df2					; add trailing space for end of token 
0df2			 
0df2 2a 6d ee				ld hl, (input_start) 
0df5 3a 60 ee				ld a,(input_len) 
0df8 cd ad 0b				call addatohl 
0dfb 3e 20				ld a, ' ' 
0dfd 77					ld (hl),a 
0dfe					; TODO eof of parse marker 
0dfe			 
0dfe 23					inc hl 
0dff 3e 00				ld a, 0 
0e01 77					ld (hl),a 
0e02			 
0e02			 
0e02 c9					ret 
0e03			 
0e03 .. 00		.iblank: db " ",0 
0e05			 
0e05			 
0e05 32 6a ee		input_str_prev:	ld (input_at_pos), a 
0e08 22 6d ee				ld (input_start), hl 
0e0b 3e 01				ld a,1			; add cursor 
0e0d 77					ld (hl),a 
0e0e 23					inc hl 
0e0f 3e 00				ld a,0 
0e11 77					ld (hl),a 
0e12 22 6f ee				ld (input_ptr), hl 
0e15 7a					ld a,d 
0e16 32 6c ee				ld (input_size), a 
0e19 3e 00				ld a,0 
0e1b 32 5b ee				ld (input_cursor),a 
0e1e			.instr1:	 
0e1e			 
0e1e					; TODO do block cursor 
0e1e					; TODO switch cursor depending on the modifer key 
0e1e			 
0e1e					; update cursor shape change on key hold 
0e1e			 
0e1e 2a 6f ee				ld hl, (input_ptr) 
0e21 2b					dec hl 
0e22 3a ca eb				ld a,(cursor_shape) 
0e25 77					ld (hl), a 
0e26			 
0e26					; display entered text 
0e26 3a 6a ee				ld a,(input_at_pos) 
0e29 cd 42 58		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e2c ed 5b 6d ee	            	LD   de, (input_start) 
0e30 cd 37 58		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e33			 
0e33 cd 2d 59				call cin 
0e36 fe 00				cp 0 
0e38 28 e4				jr z, .instr1 
0e3a			 
0e3a					; proecess keyboard controls first 
0e3a			 
0e3a 2a 6f ee				ld hl,(input_ptr) 
0e3d			 
0e3d fe 0d				cp KEY_CR	 ; pressing enter ends input 
0e3f 28 5a				jr z, .instrcr 
0e41			 
0e41 fe 08				cp KEY_BS 	; back space 
0e43 20 0f				jr nz, .instr2 
0e45					; process back space 
0e45			 
0e45					; TODO stop back space if at start of string 
0e45 2b					dec hl 
0e46 2b					dec hl ; to over write cursor 
0e47 3a ca eb				ld a,(cursor_shape) 
0e4a					;ld a,0 
0e4a 77					ld (hl),a 
0e4b 23					inc hl 
0e4c 3e 20				ld a," " 
0e4e 77					ld (hl),a 
0e4f 22 6f ee				ld (input_ptr),hl 
0e52					 
0e52			 
0e52 18 ca				jr .instr1 
0e54			 
0e54 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0e56 20 06				jr nz, .instr3 
0e58 2b					dec hl 
0e59 22 6f ee				ld (input_ptr),hl 
0e5c 18 c0				jr .instr1 
0e5e				 
0e5e fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0e60 20 06				jr nz, .instr4 
0e62 23					inc hl 
0e63 22 6f ee				ld (input_ptr),hl 
0e66 18 b6				jr .instr1 
0e68			 
0e68 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0e6a 20 06				jr nz, .instr5 
0e6c 2b					dec hl 
0e6d 22 6f ee				ld (input_ptr),hl 
0e70 18 ac				jr .instr1 
0e72			 
0e72 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0e74 20 06				jr nz, .instr6 
0e76 2b					dec hl 
0e77 22 6f ee				ld (input_ptr),hl 
0e7a 18 a2				jr .instr1 
0e7c fe 05		.instr6:        cp KEY_UP      ; recall last command 
0e7e 20 0b				jr nz, .instrnew 
0e80			 
0e80 21 57 e3			ld hl, scratch 
0e83 11 7d e7			ld de, os_last_cmd 
0e86 cd a4 0e			call strcpy 
0e89 18 93				jr .instr1 
0e8b			 
0e8b			 
0e8b			.instrnew:	; no special key pressed to see if we have room to store it 
0e8b			 
0e8b					; TODO do string size test 
0e8b			 
0e8b 2b					dec hl ; to over write cursor 
0e8c 77					ld (hl),a 
0e8d 23					inc hl 
0e8e 3a ca eb				ld a,(cursor_shape) 
0e91 77					ld (hl),a 
0e92 23					inc hl 
0e93 3e 00				ld a,0 
0e95 77					ld (hl),a 
0e96			 
0e96 22 6f ee				ld (input_ptr),hl 
0e99					 
0e99 18 83				jr .instr1 
0e9b 2b			.instrcr:	dec hl		; remove cursor 
0e9c 3e 20				ld a,' '	; TODO add a trailing space for safety 
0e9e 77					ld (hl),a 
0e9f 23					inc hl 
0ea0 3e 00				ld a,0 
0ea2 77					ld (hl),a 
0ea3			 
0ea3			 
0ea3					; if at end of line scroll up    
0ea3					; TODO detecting only end of line 4 for scroll up  
0ea3			 
0ea3					;ld   
0ea3			 
0ea3 c9					ret 
0ea4			 
0ea4			 
0ea4			; strcpy hl = dest, de source 
0ea4			 
0ea4 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ea5 b7			            OR   A              ;Null terminator? 
0ea6 c8			            RET  Z              ;Yes, so finished 
0ea7 1a					ld a,(de) 
0ea8 77					ld (hl),a 
0ea9 13			            INC  DE             ;Point to next character 
0eaa 23					inc hl 
0eab 18 f7		            JR   strcpy       ;Repeat 
0ead c9					ret 
0eae			 
0eae			 
0eae			; TODO string_at  
0eae			; pass string which starts with lcd offset address and then null term string 
0eae			 
0eae			; TODO string to dec 
0eae			; TODO string to hex 
0eae			; TODO byte to string hex 
0eae			; TODO byte to string dec 
0eae			 
0eae			 
0eae			 
0eae			; from z80uartmonitor 
0eae			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eae			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0eae			; pass hl for where to put the text 
0eae			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0eae c5			hexout:	PUSH BC 
0eaf f5					PUSH AF 
0eb0 47					LD B, A 
0eb1					; Upper nybble 
0eb1 cb 3f				SRL A 
0eb3 cb 3f				SRL A 
0eb5 cb 3f				SRL A 
0eb7 cb 3f				SRL A 
0eb9 cd c9 0e				CALL tohex 
0ebc 77					ld (hl),a 
0ebd 23					inc hl	 
0ebe					 
0ebe					; Lower nybble 
0ebe 78					LD A, B 
0ebf e6 0f				AND 0FH 
0ec1 cd c9 0e				CALL tohex 
0ec4 77					ld (hl),a 
0ec5 23					inc hl	 
0ec6					 
0ec6 f1					POP AF 
0ec7 c1					POP BC 
0ec8 c9					RET 
0ec9					 
0ec9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ec9			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0ec9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ec9			tohex: 
0ec9 e5					PUSH HL 
0eca d5					PUSH DE 
0ecb 16 00				LD D, 0 
0ecd 5f					LD E, A 
0ece 21 d6 0e				LD HL, .DATA 
0ed1 19					ADD HL, DE 
0ed2 7e					LD A, (HL) 
0ed3 d1					POP DE 
0ed4 e1					POP HL 
0ed5 c9					RET 
0ed6			 
0ed6			.DATA: 
0ed6 30					DEFB	30h	; 0 
0ed7 31					DEFB	31h	; 1 
0ed8 32					DEFB	32h	; 2 
0ed9 33					DEFB	33h	; 3 
0eda 34					DEFB	34h	; 4 
0edb 35					DEFB	35h	; 5 
0edc 36					DEFB	36h	; 6 
0edd 37					DEFB	37h	; 7 
0ede 38					DEFB	38h	; 8 
0edf 39					DEFB	39h	; 9 
0ee0 41					DEFB	41h	; A 
0ee1 42					DEFB	42h	; B 
0ee2 43					DEFB	43h	; C 
0ee3 44					DEFB	44h	; D 
0ee4 45					DEFB	45h	; E 
0ee5 46					DEFB	46h	; F 
0ee6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0ee6			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0ee6			;;    subtract $30, if result > 9 then subtract $7 more 
0ee6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0ee6			atohex: 
0ee6 d6 30				SUB $30 
0ee8 fe 0a				CP 10 
0eea f8					RET M		; If result negative it was 0-9 so we're done 
0eeb d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0eed c9					RET		 
0eee			 
0eee			 
0eee			 
0eee			 
0eee			; Get 2 ASCII characters as hex byte from pointer in hl 
0eee			 
0eee			BYTERD: 
0eee 16 00			LD	D,00h		;Set up 
0ef0 cd f8 0e			CALL	HEXCON		;Get byte and convert to hex 
0ef3 87				ADD	A,A		;First nibble so 
0ef4 87				ADD	A,A		;multiply by 16 
0ef5 87				ADD	A,A		; 
0ef6 87				ADD	A,A		; 
0ef7 57				LD	D,A		;Save hi nibble in D 
0ef8			HEXCON: 
0ef8 7e				ld a, (hl)		;Get next chr 
0ef9 23				inc hl 
0efa d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0efc fe 0a			CP	00Ah		;Is it 0-9 ? 
0efe 38 02			JR	C,NALPHA	;If so miss next bit 
0f00 d6 07			SUB	007h		;Else convert alpha 
0f02			NALPHA: 
0f02 b2				OR	D		;Add hi nibble back 
0f03 c9				RET			; 
0f04			 
0f04			 
0f04			; 
0f04			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f04			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f04			; characters (0-9a-f) are accepted. 
0f04			; 
0f04			;get_word        push    af 
0f04			;                call    get_byte        ; Get the upper byte 
0f04			;                ld      h, a 
0f04			;                call    get_byte        ; Get the lower byte 
0f04			;                ld      l, a 
0f04			;                pop     af 
0f04			;                ret 
0f04			; 
0f04			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f04			; the routine get_nibble is used only valid characters are accepted - the  
0f04			; input routine only accepts characters 0-9a-f. 
0f04			; 
0f04 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f05 7e					ld a,(hl) 
0f06 23					inc hl 
0f07 cd 2c 0f		                call    nibble2val      ; Get upper nibble 
0f0a cb 07		                rlc     a 
0f0c cb 07		                rlc     a 
0f0e cb 07		                rlc     a 
0f10 cb 07		                rlc     a 
0f12 47			                ld      b, a            ; Save upper four bits 
0f13 7e					ld a,(hl) 
0f14 cd 2c 0f		                call    nibble2val      ; Get lower nibble 
0f17 b0			                or      b               ; Combine both nibbles 
0f18 c1			                pop     bc              ; Restore B (and C) 
0f19 c9			                ret 
0f1a			; 
0f1a			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f1a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f1a			; to the serial line interface. The lower 4 bits of A contain the value of  
0f1a			; that particular digit. 
0f1a			; 
0f1a			;get_nibble      ld a,(hl)           ; Read a character 
0f1a			;                call    to_upper        ; Convert to upper case 
0f1a			;                call    is_hex          ; Was it a hex digit? 
0f1a			;                jr      nc, get_nibble  ; No, get another character 
0f1a			 ;               call    nibble2val      ; Convert nibble to value 
0f1a			 ;               call    print_nibble 
0f1a			 ;               ret 
0f1a			; 
0f1a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f1a			; A valid hexadecimal digit is denoted by a set C flag. 
0f1a			; 
0f1a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f1a			;                ret     nc              ; Yes 
0f1a			;                cp      '0'             ; Less than '0'? 
0f1a			;                jr      nc, is_hex_1    ; No, continue 
0f1a			;                ccf                     ; Complement carry (i.e. clear it) 
0f1a			;                ret 
0f1a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f1a			;                ret     c               ; Yes 
0f1a			;                cp      'A'             ; Less than 'A'? 
0f1a			;                jr      nc, is_hex_2    ; No, continue 
0f1a			;                ccf                     ; Yes - clear carry and return 
0f1a			;                ret 
0f1a			;is_hex_2        scf                     ; Set carry 
0f1a			;                ret 
0f1a			; 
0f1a			; Convert a single character contained in A to upper case: 
0f1a			; 
0f1a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f1c d8			                ret     c 
0f1d fe 7b		                cp      'z' + 1         ; > 'z'? 
0f1f d0			                ret     nc              ; Nothing to do, either 
0f20 e6 5f		                and     $5f             ; Convert to upper case 
0f22 c9			                ret 
0f23			 
0f23			 
0f23			to_lower: 
0f23			 
0f23			   ; if char is in [A-Z] make it lower case 
0f23			 
0f23			   ; enter : a = char 
0f23			   ; exit  : a = lower case char 
0f23			   ; uses  : af 
0f23			 
0f23 fe 41		   cp 'A' 
0f25 d8			   ret c 
0f26			    
0f26 fe 5b		   cp 'Z'+1 
0f28 d0			   ret nc 
0f29			    
0f29 f6 20		   or $20 
0f2b c9			   ret 
0f2c			 
0f2c			; 
0f2c			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f2c			; corresponding value in A. 
0f2c			; 
0f2c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f2e 38 02		                jr      c, nibble2val_1 ; Yes 
0f30 d6 07		                sub     7               ; Adjust for A-F 
0f32 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f34 e6 0f		                and     $f              ; Only return lower 4 bits 
0f36 c9			                ret 
0f37			; 
0f37			; Print_nibble prints a single hex nibble which is contained in the lower  
0f37			; four bits of A: 
0f37			; 
0f37			;print_nibble    push    af              ; We won't destroy the contents of A 
0f37			;                and     $f              ; Just in case... 
0f37			;                add     a, '0'             ; If we have a digit we are done here. 
0f37			;                cp      '9' + 1         ; Is the result > 9? 
0f37			;                jr      c, print_nibble_1 
0f37			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f37			;print_nibble_1  call    putc            ; Print the nibble and 
0f37			;                pop     af              ; restore the original value of A 
0f37			;                ret 
0f37			;; 
0f37			;; Send a CR/LF pair: 
0f37			; 
0f37			;crlf            push    af 
0f37			;                ld      a, cr 
0f37			;                call    putc 
0f37			;                ld      a, lf 
0f37			;                call    putc 
0f37			;                pop     af 
0f37			;                ret 
0f37			; 
0f37			; Print_word prints the four hex digits of a word to the serial line. The  
0f37			; word is expected to be in HL. 
0f37			; 
0f37			;print_word      push    hl 
0f37			;                push    af 
0f37			;                ld      a, h 
0f37			;                call    print_byte 
0f37			;                ld      a, l 
0f37			;                call    print_byte 
0f37			;                pop     af 
0f37			;                pop     hl 
0f37			;                ret 
0f37			; 
0f37			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f37			; The byte to be printed is expected to be in A. 
0f37			; 
0f37			;print_byte      push    af              ; Save the contents of the registers 
0f37			;                push    bc 
0f37			;                ld      b, a 
0f37			;                rrca 
0f37			;                rrca 
0f37			;                rrca 
0f37			;                rrca 
0f37			;                call    print_nibble    ; Print high nibble 
0f37			;                ld      a, b 
0f37			;                call    print_nibble    ; Print low nibble 
0f37			;                pop     bc              ; Restore original register contents 
0f37			;                pop     af 
0f37			;                ret 
0f37			 
0f37			 
0f37			 
0f37			 
0f37			 
0f37			fourehexhl:  
0f37 7e				ld a,(hl) 
0f38 cd e6 0e			call atohex 
0f3b cb 3f				SRL A 
0f3d cb 3f				SRL A 
0f3f cb 3f				SRL A 
0f41 cb 3f				SRL A 
0f43 47				ld b, a 
0f44 23				inc hl 
0f45 7e				ld a,(hl) 
0f46 23				inc hl 
0f47 cd e6 0e			call atohex 
0f4a 80				add b 
0f4b 57				ld d,a 
0f4c 7e				ld a,(hl) 
0f4d cd e6 0e			call atohex 
0f50 cb 3f				SRL A 
0f52 cb 3f				SRL A 
0f54 cb 3f				SRL A 
0f56 cb 3f				SRL A 
0f58 47				ld b, a 
0f59 23				inc hl 
0f5a 7e				ld a,(hl) 
0f5b 23				inc hl 
0f5c cd e6 0e			call atohex 
0f5f 80				add b 
0f60 5f				ld e, a 
0f61 d5				push de 
0f62 e1				pop hl 
0f63 c9				ret 
0f64			 
0f64			; pass hl. returns z set if the byte at hl is a digit 
0f64			;isdigithl:  
0f64			;	push bc 
0f64			;	ld a,(hl) 
0f64			;	cp ':' 
0f64			;	jr nc, .isdf 		; > 
0f64			;	cp '0' 
0f64			;	jr c, .isdf		; < 
0f64			; 
0f64			;	; TODO find a better way to set z 
0f64			; 
0f64			;	ld b,a 
0f64			;	cp b 
0f64			;	pop bc 
0f64			;	ret 
0f64			; 
0f64			;.isdf:	; not digit so clear z 
0f64			; 
0f64			;	; TODO find a better way to unset z 
0f64			; 
0f64			;	ld b,a 
0f64			;	inc b 
0f64			;	cp b 
0f64			; 
0f64			;	pop bc 
0f64			;	ret 
0f64				 
0f64				 
0f64			 
0f64			 
0f64			; pass hl as the four byte address to load 
0f64			 
0f64			get_word_hl:  
0f64 e5				push hl 
0f65 cd 04 0f			call get_byte 
0f68				 
0f68 47				ld b, a 
0f69			 
0f69 e1				pop hl 
0f6a 23				inc hl 
0f6b 23				inc hl 
0f6c			 
0f6c			; TODO not able to handle a-f  
0f6c 7e				ld a,(hl) 
0f6d			;	;cp ':' 
0f6d			;	cp 'g' 
0f6d			;	jr nc, .single_byte_hl 		; > 
0f6d			;	cp 'G' 
0f6d			;	jr nc, .single_byte_hl 		; > 
0f6d			;	cp '0' 
0f6d			;	jr c, .single_byte_hl		; < 
0f6d			 
0f6d				;call isdigithl 
0f6d fe 00			cp 0 
0f6f 28 06			jr z, .single_byte_hl 
0f71			 
0f71			.getwhln:   ; hex word so get next byte 
0f71			 
0f71 cd 04 0f			call get_byte 
0f74 6f				ld l, a 
0f75 60				ld h,b 
0f76 c9				ret 
0f77 68			.single_byte_hl:   ld l,b 
0f78 26 00				ld h,0 
0f7a c9					ret 
0f7b			 
0f7b			 
0f7b			 
0f7b			 
0f7b 21 1f 17			ld hl,asc+1 
0f7e			;	ld a, (hl) 
0f7e			;	call nibble2val 
0f7e cd 04 0f			call get_byte 
0f81			 
0f81			;	call fourehexhl 
0f81 32 8b e3			ld (scratch+52),a 
0f84				 
0f84 21 89 e3			ld hl,scratch+50 
0f87 22 7a e6			ld (os_cur_ptr),hl 
0f8a			 
0f8a c9				ret 
0f8b			 
0f8b			 
0f8b			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0f8b			 
0f8b			; Decimal Unsigned Version 
0f8b			 
0f8b			;Number in a to decimal ASCII 
0f8b			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0f8b			;Example: display a=56 as "056" 
0f8b			;input: a = number 
0f8b			;Output: a=0,value of a in the screen 
0f8b			;destroys af,bc (don't know about hl and de) 
0f8b			DispAToASCII: 
0f8b 0e 9c			ld	c,-100 
0f8d cd 97 0f			call	.Na1 
0f90 0e f6			ld	c,-10 
0f92 cd 97 0f			call	.Na1 
0f95 0e ff			ld	c,-1 
0f97 06 2f		.Na1:	ld	b,'0'-1 
0f99 04			.Na2:	inc	b 
0f9a 81				add	a,c 
0f9b 38 fc			jr	c,.Na2 
0f9d 91				sub	c		;works as add 100/10/1 
0f9e f5				push af		;safer than ld c,a 
0f9f 78				ld	a,b		;char is in b 
0fa0			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
0fa0 f1				pop af		;safer than ld a,c 
0fa1 c9				ret 
0fa2			 
0fa2			; Decimal Signed Version 
0fa2			 
0fa2			; DispA 
0fa2			; -------------------------------------------------------------- 
0fa2			; Converts a signed integer value to a zero-terminated ASCII 
0fa2			; string representative of that value (using radix 10). 
0fa2			; -------------------------------------------------------------- 
0fa2			; INPUTS: 
0fa2			;     HL     Value to convert (two's complement integer). 
0fa2			;     DE     Base address of string destination. (pointer). 
0fa2			; -------------------------------------------------------------- 
0fa2			; OUTPUTS: 
0fa2			;     None 
0fa2			; -------------------------------------------------------------- 
0fa2			; REGISTERS/MEMORY DESTROYED 
0fa2			; AF HL 
0fa2			; -------------------------------------------------------------- 
0fa2			 
0fa2			;DispHLToASCII: 
0fa2			;   push    de 
0fa2			;   push    bc 
0fa2			; 
0fa2			;; Detect sign of HL. 
0fa2			;    bit    7, h 
0fa2			;    jr     z, ._DoConvert 
0fa2			; 
0fa2			;; HL is negative. Output '-' to string and negate HL. 
0fa2			;    ld     a, '-' 
0fa2			;    ld     (de), a 
0fa2			;    inc    de 
0fa2			; 
0fa2			;; Negate HL (using two's complement) 
0fa2			;    xor    a 
0fa2			;    sub    l 
0fa2			;    ld     l, a 
0fa2			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
0fa2			;    sbc    a, h 
0fa2			;    ld     h, a 
0fa2			; 
0fa2			;; Convert HL to digit characters 
0fa2			;._DoConvert: 
0fa2			;    ld     b, 0     ; B will count character length of number 
0fa2			;-   ld     a, 10 
0fa2			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
0fa2			;    push   af 
0fa2			;    inc    b 
0fa2			;    ld     a, h 
0fa2			;    or     l 
0fa2			;    jr     nz, - 
0fa2			; 
0fa2			;; Retrieve digits from stack 
0fa2			;-   pop    af 
0fa2			;    or     $30 
0fa2			;    ld     (de), a 
0fa2			;    inc    de 
0fa2			;    djnz   - 
0fa2			; 
0fa2			;; Terminate string with NULL 
0fa2			;    xor    a 
0fa2			;    ld     (de), a 
0fa2			; 
0fa2			;    pop    bc 
0fa2			;    pop    de 
0fa2			;    ret 
0fa2			 
0fa2			;Comments 
0fa2			; 
0fa2			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
0fa2			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
0fa2			;    Note that the output string will not be fixed-width. 
0fa2			; 
0fa2			;Example Usage 
0fa2			; 
0fa2			;    ld    hl, -1004 
0fa2			;    ld    de, OP1 
0fa2			;    call  DispA 
0fa2			;    ld    hl, OP1 
0fa2			;    syscall  PutS 
0fa2			 
0fa2			 
0fa2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fa2			 
0fa2			 
0fa2			;Converts an ASCII string to an unsigned 16-bit integer 
0fa2			;Quits when it reaches a non-decimal digit 
0fa2			 
0fa2			string_to_uint16: 
0fa2			atoui_16: 
0fa2			;Input: 
0fa2			;     DE points to the string 
0fa2			;Outputs: 
0fa2			;     HL is the result 
0fa2			;     A is the 8-bit value of the number 
0fa2			;     DE points to the byte after the number 
0fa2			;Destroys: 
0fa2			;     BC 
0fa2			;       if the string is non-empty, BC is HL/10 
0fa2			;Size:  24 bytes 
0fa2			;Speed: 42+d(104+{0,9}) 
0fa2			;       d is the number of digits in the number 
0fa2			;       max is 640 cycles for a 5 digit number 
0fa2			;Assuming no leading zeros: 
0fa2			;1 digit:  146cc 
0fa2			;2 digit:  250cc 
0fa2			;3 digit:  354cc or 363cc (avg: 354.126cc) 
0fa2			;4 digit:  458cc or 467cc (avg: 458.27cc) 
0fa2			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
0fa2			;avg: 544.81158447265625cc (544+13297/16384) 
0fa2			;=============================================================== 
0fa2 21 00 00		  ld hl,0 
0fa5			.u16a: 
0fa5 1a			  ld a,(de) 
0fa6 d6 30		  sub 30h 
0fa8 fe 0a		  cp 10 
0faa d0			  ret nc 
0fab 13			  inc de 
0fac 44			  ld b,h 
0fad 4d			  ld c,l 
0fae 29			  add hl,hl 
0faf 29			  add hl,hl 
0fb0 09			  add hl,bc 
0fb1 29			  add hl,hl 
0fb2 85			  add a,l 
0fb3 6f			  ld l,a 
0fb4 30 ef		  jr nc,.u16a 
0fb6 24			  inc h 
0fb7 c3 a5 0f		  jp .u16a 
0fba			 
0fba			 
0fba			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
0fba			 
0fba			;written by Zeda 
0fba			;Converts a 16-bit unsigned integer to an ASCII string. 
0fba			 
0fba			uitoa_16: 
0fba			;Input: 
0fba			;   DE is the number to convert 
0fba			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
0fba			;Output: 
0fba			;   HL points to the null-terminated ASCII string 
0fba			;      NOTE: This isn't necessarily the same as the input HL. 
0fba d5			  push de 
0fbb c5			  push bc 
0fbc f5			  push af 
0fbd eb			  ex de,hl 
0fbe			 
0fbe 01 f0 d8		  ld bc,-10000 
0fc1 3e 2f		  ld a,'0'-1 
0fc3 3c			  inc a 
0fc4 09			  add hl,bc  
0fc5 38 fc		   jr c,$-2 
0fc7 12			  ld (de),a 
0fc8 13			  inc de 
0fc9			 
0fc9 01 e8 03		  ld bc,1000 
0fcc 3e 3a		  ld a,'9'+1 
0fce 3d			  dec a  
0fcf 09			  add hl,bc  
0fd0 30 fc		   jr nc,$-2 
0fd2 12			  ld (de),a 
0fd3 13			  inc de 
0fd4			 
0fd4 01 9c ff		  ld bc,-100 
0fd7 3e 2f		  ld a,'0'-1 
0fd9 3c			  inc a  
0fda 09			  add hl,bc  
0fdb 38 fc		   jr c,$-2 
0fdd 12			  ld (de),a 
0fde 13			  inc de 
0fdf			 
0fdf 7d			  ld a,l 
0fe0 26 3a		  ld h,'9'+1 
0fe2 25			  dec h  
0fe3 c6 0a		  add a,10  
0fe5 30 fb		   jr nc,$-3 
0fe7 c6 30		  add a,'0' 
0fe9 eb			  ex de,hl 
0fea 72			  ld (hl),d 
0feb 23			  inc hl 
0fec 77			  ld (hl),a 
0fed 23			  inc hl 
0fee 36 00		  ld (hl),0 
0ff0			 
0ff0			;Now strip the leading zeros 
0ff0 0e fa		  ld c,-6 
0ff2 09			  add hl,bc 
0ff3 3e 30		  ld a,'0' 
0ff5 23			  inc hl  
0ff6 be			  cp (hl)  
0ff7 28 fc		  jr z,$-2 
0ff9			 
0ff9			;Make sure that the string is non-empty! 
0ff9 7e			  ld a,(hl) 
0ffa b7			  or a 
0ffb 20 01		  jr nz,.atoub 
0ffd 2b			  dec hl 
0ffe			.atoub: 
0ffe			 
0ffe f1			  pop af 
0fff c1			  pop bc 
1000 d1			  pop de 
1001 c9			  ret 
1002			 
1002			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1002			 
1002			toUpper: 
1002			;A is the char. 
1002			;If A is a lowercase letter, this sets it to the matching uppercase 
1002			;18cc or 30cc or 41cc 
1002			;avg: 26.75cc 
1002 fe 61		  cp 'a' 
1004 d8			  ret c 
1005 fe 7b		  cp 'z'+1 
1007 d0			  ret nc 
1008 d6 20		  sub 'a'-'A' 
100a c9			  ret 
100b			 
100b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
100b			 
100b			; String Length 
100b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
100b			 
100b			; Get the length of the null-terminated string starting at $8000 hl 
100b			;    LD     HL, $8000 
100b			 
100b			strlenz: 
100b			 
100b af			    XOR    A               ; Zero is the value we are looking for. 
100c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
100d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
100e			                           ; 65, 536 bytes (the entire addressable memory space). 
100e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1010			 
1010			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1010 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1011 6f			    LD     L, A             ; number of bytes 
1012 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1014 2b			    DEC    HL              ; Compensate for null. 
1015 c9				ret 
1016			 
1016			; Get the length of the A terminated string starting at $8000 hl 
1016			;    LD     HL, $8000 
1016			 
1016			strlent: 
1016			 
1016			                  ; A is the value we are looking for. 
1016 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1018 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
101a			                           ; 65, 536 bytes (the entire addressable memory space). 
101a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
101c			 
101c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
101c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
101e 2e 00		    LD     L, 0             ; number of bytes 
1020 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1022 2b			    DEC    HL              ; Compensate for null. 
1023 c9				ret 
1024			 
1024			 
1024			;Comparing Strings 
1024			 
1024			;IN    HL     Address of string1. 
1024			;      DE     Address of string2. 
1024			 
1024			; doc given but wrong??? 
1024			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1024			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1024			; tested 
1024			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1024			 
1024			strcmp_old: 
1024 e5			    PUSH   HL 
1025 d5			    PUSH   DE 
1026			 
1026 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1027 be			    CP     (HL)            ; (want to minimize work). 
1028 38 01		    JR     C, Str1IsBigger 
102a 7e			    LD     A, (HL) 
102b			 
102b			Str1IsBigger: 
102b 4f			    LD     C, A             ; Put length in BC 
102c 06 00		    LD     B, 0 
102e 13			    INC    DE              ; Increment pointers to meat of string. 
102f 23			    INC    HL 
1030			 
1030			CmpLoop: 
1030 1a			    LD     A, (DE)          ; Compare bytes. 
1031 ed a1		    CPI 
1033 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1035 13			    INC    DE              ; Update pointer. 
1036 ea 30 10		    JP     PE, CmpLoop 
1039			 
1039 d1			    POP    DE 
103a e1			    POP    HL 
103b 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
103c be			    CP     (HL) 
103d c9			    RET 
103e			 
103e			NoMatch: 
103e 2b			    DEC    HL 
103f be			    CP     (HL)            ; Compare again to affect carry. 
1040 d1			    POP    DE 
1041 e1			    POP    HL 
1042 c9			    RET 
1043			 
1043			;; test strmp 
1043			; 
1043			;ld de, .str1 
1043			;ld hl, .str2 
1043			;call strcmp 
1043			;jr z, .z1 
1043			;;this 
1043			;	if DEBUG_FORTH_WORDS 
1043			;		DMARK "NZ1" 
1043			;		CALLMONITOR 
1043			;	endif 
1043			;.z1: 
1043			; 
1043			;	if DEBUG_FORTH_WORDS 
1043			;		DMARK "ZZ1" 
1043			;		CALLMONITOR 
1043			;	endif 
1043			; 
1043			;ld de, .str1 
1043			;ld hl, .str1 
1043			;call strcmp 
1043			;jr z, .z2 
1043			;;this 
1043			;	if DEBUG_FORTH_WORDS 
1043			;		DMARK "NZ2" 
1043			;		CALLMONITOR 
1043			;	endif 
1043			;.z2: 
1043			; 
1043			;	if DEBUG_FORTH_WORDS 
1043			;		DMARK "ZZ2" 
1043			;		CALLMONITOR 
1043			;	endif 
1043			; 
1043			;ld de, .str1 
1043			;ld hl, .str2 
1043			;call strcmp 
1043			;jr c, .c1 
1043			; 
1043			;	if DEBUG_FORTH_WORDS 
1043			;		DMARK "Nc1" 
1043			;		CALLMONITOR 
1043			;	endif 
1043			;.c1: 
1043			;;this 
1043			;	if DEBUG_FORTH_WORDS 
1043			;		DMARK "cc1" 
1043			;		CALLMONITOR 
1043			;	endif 
1043			; 
1043			;ld de, .str1 
1043			;ld hl, .str1 
1043			;call strcmp 
1043			;jr c, .c2 
1043			;;this 
1043			;	if DEBUG_FORTH_WORDS 
1043			;		DMARK "Nc2" 
1043			;		CALLMONITOR 
1043			;	endif 
1043			;.c2: 
1043			; 
1043			;	if DEBUG_FORTH_WORDS 
1043			;		DMARK "cc2" 
1043			;		CALLMONITOR 
1043			;	endif 
1043			;	NEXTW 
1043			;.str1:   db "string1",0 
1043			;.str2:   db "string2",0 
1043			 
1043			; only care about direct match or not 
1043			; hl and de strings 
1043			; zero set if the same 
1043			 
1043			strcmp: 
1043 1a				ld a, (de) 
1044 be				cp (hl) 
1045 28 02			jr z, .ssame 
1047 b7				or a 
1048 c9				ret 
1049			 
1049			.ssame:  
1049 fe 00			cp 0 
104b c8				ret z 
104c			 
104c 23				inc hl 
104d 13				inc de 
104e 18 f3			jr strcmp 
1050				 
1050				 
1050			 
1050			 
1050			 
1050			 
1050			; eof 
1050			 
1050			 
1050			 
1050			 
1050			 
1050			 
# End of file firmware_strings.asm
1050			include "firmware_memory.asm"   ; malloc and free  
1050			 
1050			if DEBUG_FORTH_MALLOC_HIGH 
1050			.mallocsize: db "Wants malloc >256",0 
1050			.mallocasize: db "MALLOC gives >256",0 
1050			.malloczero: db "MALLOC gives zero",0 
1050			 
1050			malloc_guard_zerolen: 
1050				push hl 
1050				push de 
1050				push af 
1050			 
1050				ld de, 0 
1050			        call cmp16 
1050				jr nz, .lowalloz 
1050			 
1050				push hl 
1050				push de 
1050					ld hl, display_fb0 
1050					ld (display_fb_active), hl 
1050				call clear_display 
1050				ld a, 0 
1050				ld de, .malloczero 
1050				call str_at_display 
1050				call update_display 
1050				call delay1s 
1050				call delay1s 
1050				ld a, 0 
1050				ld (os_view_disable), a 
1050			 
1050				pop de 
1050				pop hl 
1050			 
1050				 
1050			 
1050				CALLMONITOR 
1050			.lowalloz: 
1050			 
1050			 
1050				pop af 
1050				pop de 
1050				pop hl 
1050			ret 
1050			 
1050			malloc_guard_entry: 
1050				push hl 
1050				push de 
1050				push af 
1050			 
1050			 	or a      ;clear carry flag 
1050				push hl 
1050				ld de, 255 
1050				sbc hl, de 
1050				jr c, .lowalloc 
1050			 
1050				push de 
1050					ld hl, display_fb0 
1050					ld (display_fb_active), hl 
1050				call clear_display 
1050				ld a, 0 
1050				ld de, .mallocsize 
1050				call str_at_display 
1050				call update_display 
1050				call delay1s 
1050				call delay1s 
1050				ld a, 0 
1050				ld (os_view_disable), a 
1050			 
1050				pop de 
1050				pop hl 
1050			 
1050				 
1050			 
1050				CALLMONITOR 
1050				jr .lowdone 
1050			.lowalloc: 
1050			 
1050			 
1050				pop hl 
1050			.lowdone:	pop af 
1050				pop de 
1050				pop hl 
1050			ret 
1050			 
1050			malloc_guard_exit: 
1050				push hl 
1050				push de 
1050				push af 
1050			 
1050			 	or a      ;clear carry flag 
1050				push hl 
1050				ld de, 255 
1050				sbc hl, de 
1050				jr c, .lowallocx 
1050			 
1050				push de 
1050					ld hl, display_fb0 
1050					ld (display_fb_active), hl 
1050				call clear_display 
1050				ld a, 0 
1050				ld de, .mallocasize 
1050				call str_at_display 
1050				call update_display 
1050				call delay1s 
1050				call delay1s 
1050				ld a, 0 
1050				ld (os_view_disable), a 
1050				pop de 
1050				pop hl 
1050			 
1050				CALLMONITOR 
1050				jr .lowdonex 
1050			.lowallocx: 
1050			 
1050				pop hl 
1050			.lowdonex:	pop af 
1050				pop de 
1050				pop hl 
1050			ret 
1050			endif 
1050			 
1050			if MALLOC_2 
1050			; Z80 Malloc and Free Functions 
1050			 
1050			; Malloc Function: 
1050			; Input: 
1050			;   HL: Size of block to allocate 
1050			; Output: 
1050			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1050			 
1050			malloc: 
1050				 
1050			if DEBUG_FORTH_MALLOC_HIGH 
1050			call malloc_guard_entry 
1050			endif 
1050			 
1050			 
1050			 
1050			 
1050					if DEBUG_FORTH_MALLOC 
1050						DMARK "mal" 
1050						CALLMONITOR 
1050					endif 
1050			    push af            ; Save AF register 
1050			    ld a, l            ; Load low byte of size into A 
1050			    or h               ; Check if size is zero 
1050			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1050			 
1050			    ; Allocate memory 
1050			    ld hl, (heap_start) ; Load start of heap into HL 
1050					if DEBUG_FORTH_MALLOC 
1050						DMARK "ma1" 
1050						CALLMONITOR 
1050					endif 
1050			    call malloc_internal ; Call internal malloc function 
1050			    pop af             ; Restore AF register 
1050			if DEBUG_FORTH_MALLOC_HIGH 
1050			call malloc_guard_exit 
1050			call malloc_guard_zerolen 
1050			endif 
1050			    ret                ; Return 
1050			 
1050			; Free Function: 
1050			; Input: 
1050			;   HL: Pointer to memory block to free 
1050			; Output: 
1050			;   None 
1050			 
1050			free: 
1050			    push af            ; Save AF register 
1050			    ld a, l            ; Load low byte of pointer into A 
1050			    or h               ; Check if pointer is NULL 
1050			    jp z, free_exit    ; If pointer is NULL, exit 
1050			 
1050			    ; Free memory 
1050			    ld hl, (heap_start) ; Load start of heap into HL 
1050			    call free_internal  ; Call internal free function 
1050			    pop af             ; Restore AF register 
1050			    ret                ; Return 
1050			 
1050			; Internal Malloc Function: 
1050			; Input: 
1050			;   HL: Size of block to allocate 
1050			; Output: 
1050			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1050			 
1050			malloc_internal: 
1050			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1050			    add hl, bc         ; Add management overhead to requested size 
1050			    ex de, hl          ; Save total size in DE, and keep it in HL 
1050					if DEBUG_FORTH_MALLOC 
1050						DMARK "ma2" 
1050						CALLMONITOR 
1050					endif 
1050			 
1050			    ; Search for free memory block 
1050			    ld de, (heap_end)  ; Load end of heap into DE 
1050			    ld bc, 0           ; Initialize counter 
1050			 
1050					if DEBUG_FORTH_MALLOC 
1050						DMARK "ma2" 
1050						CALLMONITOR 
1050					endif 
1050			malloc_search_loop: 
1050			    ; Check if current block is free 
1050			    ld a, (hl)         ; Load current block's status (free or used) 
1050			    cp 0               ; Compare with zero (free) 
1050			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1050			 
1050			    ; Check if current block is large enough 
1050			    ld a, (hl+1)       ; Load high byte of block size 
1050			    cp l               ; Compare with low byte of requested size 
1050			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1050			 
1050			    ld a, (hl+2)       ; Load low byte of block size 
1050			    cp h               ; Compare with high byte of requested size 
1050			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1050			 
1050			    ; Mark block as used 
1050			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1050			 
1050			    ; Calculate remaining space in block 
1050			    ld bc, 0           ; Clear BC 
1050			    add hl, bc         ; Increment HL to point to start of data block 
1050			    add hl, de         ; HL = HL + DE (total size) 
1050			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1050			    add hl, bc         ; Add management overhead to start of data block 
1050			 
1050			    ; Save pointer to allocated block in HL 
1050			if DEBUG_FORTH_MALLOC_HIGH 
1050						DMARK "ma5" 
1050			call malloc_guard_exit 
1050			call malloc_guard_zerolen 
1050			endif 
1050			    ret 
1050			 
1050			malloc_skip_block_check: 
1050			    ; Move to the next block 
1050			    ld bc, 3           ; Size of management overhead 
1050			    add hl, bc         ; Move to the next block 
1050			    inc de             ; Increment counter 
1050			 
1050			    ; Check if we have reached the end of heap 
1050			    ld a, e            ; Load low byte of heap end address 
1050			    cp (hl)            ; Compare with low byte of current address 
1050			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1050			    ld a, d            ; Load high byte of heap end address 
1050			    cp 0               ; Check if it's zero (end of memory) 
1050			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1050			 
1050			    ; If we reached here, allocation failed 
1050			    xor a              ; Set result to NULL 
1050			if DEBUG_FORTH_MALLOC_HIGH 
1050						DMARK "ma6" 
1050			call malloc_guard_exit 
1050			call malloc_guard_zerolen 
1050			endif 
1050			    ret 
1050			malloc_exit: 
1050			if DEBUG_FORTH_MALLOC_HIGH 
1050						DMARK "ma7" 
1050			call malloc_guard_exit 
1050			call malloc_guard_zerolen 
1050			endif 
1050			    ret 
1050			 
1050			; Internal Free Function: 
1050			; Input: 
1050			;   HL: Pointer to memory block to free 
1050			; Output: 
1050			;   None 
1050			 
1050			free_internal: 
1050			    ld de, (heap_start) ; Load start of heap into DE 
1050			    ld bc, 0            ; Initialize counter 
1050			 
1050			free_search_loop: 
1050			    ; Check if current block contains the pointer 
1050			    ld a, l             ; Load low byte of pointer 
1050			    cp (hl+1)           ; Compare with high byte of current block's address 
1050			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1050			    ld a, h             ; Load high byte of pointer 
1050			    cp (hl+2)           ; Compare with low byte of current block's address 
1050			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1050			 
1050			    ; Mark block as free 
1050			    ld (hl), 0          ; Set status byte to indicate free block 
1050			    ret                 ; Return 
1050			 
1050			free_skip_block_check: 
1050			    ; Move to the next block 
1050			    ld bc, 3            ; Size of management overhead 
1050			    add hl, bc          ; Move to the next block 
1050			    inc de              ; Increment counter 
1050			 
1050			    ; Check if we have reached the end of heap 
1050			    ld a, e             ; Load low byte of heap end address 
1050			    cp (hl)             ; Compare with low byte of current address 
1050			    jr nz, free_search_loop  ; If not equal, continue searching 
1050			    ld a, d             ; Load high byte of heap end address 
1050			    cp 0                ; Check if it's zero (end of memory) 
1050			    jr nz, free_search_loop  ; If not zero, continue searching 
1050			 
1050			    ; If we reached here, pointer is not found in heap 
1050			    ret 
1050			 
1050			free_exit: 
1050			    ret                 ; Return 
1050			 
1050			; Define heap start and end addresses 
1050			;heap_start:    .dw 0xC000   ; Start of heap 
1050			;heap_end:      .dw 0xE000   ; End of heap 
1050			 
1050			endif 
1050			 
1050			 
1050			if MALLOC_1 
1050			 
1050			 
1050			 
1050			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1050			 
1050			;moved to firmware.asm 
1050			;heap_start        .equ  0x9000      ; Starting address of heap 
1050			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1050			 
1050			;      .org 0 
1050			;      jp    main 
1050			 
1050			 
1050			;      .org  0x100 
1050			;main: 
1050			;      ld    HL, 0x8100 
1050			;      ld    SP, HL 
1050			; 
1050			;      call  heap_init 
1050			; 
1050			;      ; Make some allocations 
1050			;      ld    HL, 12 
1050			;      call  malloc            ; Allocates 0x9004 
1050			; 
1050			;      ld    HL, 12 
1050			;      call  malloc            ; Allocates 0x9014 
1050			; 
1050			;      ld    HL, 12 
1050			;      call  malloc            ; Allocates 0x9024 
1050			; 
1050			;      ; Free some allocations 
1050			;      ld    HL, 0x9014 
1050			;      call  free 
1050			; 
1050			;      ld    HL, 0x9004 
1050			;      call  free 
1050			; 
1050			;      ld    HL, 0x9024 
1050			;      call  free 
1050			; 
1050			; 
1050			;      halt 
1050			 
1050			 
1050			;------------------------------------------------------------------------------ 
1050			;     heap_init                                                               : 
1050			;                                                                             : 
1050			; Description                                                                 : 
1050			;     Initialise the heap and make it ready for malloc and free operations.   : 
1050			;                                                                             : 
1050			;     The heap is maintained as a linked list, starting with an initial       : 
1050			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1050			;     the first free block in the heap. Each block then points to the next    : 
1050			;     free block within the heap, and the free list ends at the first block   : 
1050			;     with a null pointer to the next free block.                             : 
1050			;                                                                             : 
1050			; Parameters                                                                  : 
1050			;     Inputs are compile-time only. Two defines which specify the starting    : 
1050			;     address of the heap and its size are required, along with a memory      : 
1050			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1050			;     principally stores a pointer to the first free block in the heap.       : 
1050			;                                                                             : 
1050			; Returns                                                                     : 
1050			;     Nothing                                                                 : 
1050			;------------------------------------------------------------------------------ 
1050			heap_init: 
1050 e5			      push  HL 
1051			 
1051			      ; Initialise free list struct 
1051 21 55 59		      ld    HL, heap_start 
1054 22 50 59		      ld    (free_list), HL 
1057 21 00 00		      ld    HL, 0 
105a 22 52 59		      ld    (free_list+2), HL 
105d			 
105d			      ; Insert first free block at bottom of heap, consumes entire heap 
105d 21 39 e3		      ld    HL, heap_start+heap_size-4 
1060 22 55 59		      ld    (heap_start), HL        ; Next block (end of free list) 
1063 21 e4 89		      ld    HL, heap_size-4 
1066 22 57 59		      ld    (heap_start+2), HL      ; Block size 
1069			 
1069			      ; Insert end of free list block at top of heap - two null words will 
1069			      ; terminate the free list 
1069 21 00 00		      ld    HL, 0 
106c 22 3b e3		      ld    (heap_start+heap_size-2), HL 
106f 22 39 e3		      ld    (heap_start+heap_size-4), HL 
1072			 
1072 e1			      pop   HL 
1073			 
1073 c9			      ret 
1074			 
1074			 
1074			;------------------------------------------------------------------------------ 
1074			;     malloc                                                                  : 
1074			;                                                                             : 
1074			; Description                                                                 : 
1074			;     Allocates the wanted space from the heap and returns the address of the : 
1074			;     first useable byte of the allocation.                                   : 
1074			;                                                                             : 
1074			;     Allocations can happen in one of two ways:                              : 
1074			;                                                                             : 
1074			;     1. A free block may be found which is the exact size wanted. In this    : 
1074			;        case the block is removed from the free list and retuedn to the      : 
1074			;        caller.                                                              : 
1074			;     2. A free block may be found which is larger than the size wanted. In   : 
1074			;        this case, the larger block is split into two. The first portion of  : 
1074			;        this block will become the requested space by the malloc call and    : 
1074			;        is returned to the caller. The second portion becomes a new free     : 
1074			;        block, and the free list is adjusted to maintain continuity via this : 
1074			;        newly created block.                                                 : 
1074			;                                                                             : 
1074			;     malloc does not set any initial value in the allocated space, the       : 
1074			;     caller is required to do this as required.                              : 
1074			;                                                                             : 
1074			;     This implementation of malloc uses the stack exclusively, and is        : 
1074			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1074			;     advisable to disable interrupts before calling malloc, and recommended  : 
1074			;     to avoid the use of malloc inside ISRs in general.                      : 
1074			;                                                                             : 
1074			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1074			;                                                                             : 
1074			; Parameters                                                                  : 
1074			;     HL  Number of bytes wanted                                              : 
1074			;                                                                             : 
1074			; Returns                                                                     : 
1074			;     HL  Address of the first useable byte of the allocation                 : 
1074			;                                                                             : 
1074			; Flags                                                                       : 
1074			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1074			;                                                                             : 
1074			; Stack frame                                                                 : 
1074			;       |             |                                                       : 
1074			;       +-------------+                                                       : 
1074			;       |     BC      |                                                       : 
1074			;       +-------------+                                                       : 
1074			;       |     DE      |                                                       : 
1074			;       +-------------+                                                       : 
1074			;       |     IX      |                                                       : 
1074			;       +-------------+                                                       : 
1074			;       |  prev_free  |                                                       : 
1074			;   +4  +-------------+                                                       : 
1074			;       |  this_free  |                                                       : 
1074			;   +2  +-------------+                                                       : 
1074			;       |  next_free  |                                                       : 
1074			;   +0  +-------------+                                                       : 
1074			;       |             |                                                       : 
1074			;                                                                             : 
1074			;------------------------------------------------------------------------------ 
1074			 
1074			 
1074			;malloc: 
1074			; 
1074			;	SAVESP ON 1 
1074			; 
1074			;	call malloc_code 
1074			; 
1074			;	CHECKSP ON 1 
1074			;	ret 
1074			 
1074			 
1074			malloc: 
1074 c5			      push  BC 
1075 d5			      push  DE 
1076 dd e5		      push  IX 
1078			if DEBUG_FORTH_MALLOC_HIGH 
1078			call malloc_guard_entry 
1078			endif 
1078			 
1078					if DEBUG_FORTH_MALLOC 
1078						DMARK "mal" 
1078						CALLMONITOR 
1078					endif 
1078 7c			      ld    A, H                    ; Exit if no space requested 
1079 b5			      or    L 
107a ca 39 11		      jp    Z, malloc_early_exit 
107d			 
107d			;inc hl 
107d			;inc hl 
107d			;inc hl 
107d			; 
107d			;inc hl 
107d			;inc hl 
107d			;inc hl 
107d			;inc hl 
107d			;inc hl 
107d			;inc hl 
107d			;inc hl 
107d			;inc hl 
107d			;inc hl 
107d			 
107d			 
107d			 
107d			 
107d					if DEBUG_FORTH_MALLOC 
107d						DMARK "maA" 
107d						CALLMONITOR 
107d					endif 
107d			      ; Set up stack frame 
107d eb			      ex    DE, HL 
107e 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1081 39			      add   HL, SP 
1082 f9			      ld    SP, HL 
1083 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1087 dd 39		      add   IX, SP 
1089			 
1089			      ; Setup initial state 
1089 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
108c 19			      add   HL, DE 
108d			 
108d 44			      ld    B, H                    ; Move want to BC 
108e 4d			      ld    C, L 
108f			 
108f 21 50 59		      ld    HL, free_list           ; Store prev_free ptr to stack 
1092 dd 75 04		      ld    (IX+4), L 
1095 dd 74 05		      ld    (IX+5), H 
1098			 
1098 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1099 23			      inc   HL 
109a 56			      ld    D, (HL) 
109b dd 73 02		      ld    (IX+2), E 
109e dd 72 03		      ld    (IX+3), D 
10a1 eb			      ex    DE, HL                  ; this_free ptr into HL 
10a2			 
10a2					if DEBUG_FORTH_MALLOC 
10a2						DMARK "maB" 
10a2						CALLMONITOR 
10a2					endif 
10a2			      ; Loop through free block list to find some space 
10a2			malloc_find_space: 
10a2 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
10a3 23			      inc   HL 
10a4 56			      ld    D, (HL) 
10a5			 
10a5 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
10a6 b3			      or    E 
10a7 ca 33 11		      jp    Z, malloc_no_space 
10aa			 
10aa dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
10ad dd 72 01		      ld    (IX+1), D 
10b0			 
10b0			      ; Does this block have enough space to make the allocation? 
10b0 23			      inc   HL                      ; Load free block size into DE 
10b1 5e			      ld    E, (HL) 
10b2 23			      inc   HL 
10b3 56			      ld    D, (HL) 
10b4			 
10b4 eb			      ex    DE, HL                  ; Check size of block against want 
10b5 b7			      or    A                       ; Ensure carry flag clear 
10b6 ed 42		      sbc   HL, BC 
10b8 e5			      push  HL                      ; Store the result for later (new block size) 
10b9			 
10b9 ca 08 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
10bc 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
10be			 
10be			      ; this_free block is not big enough, setup ptrs to test next free block 
10be e1			      pop   HL                      ; Discard previous result 
10bf			 
10bf dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
10c2 dd 66 03		      ld    H, (IX+3) 
10c5 dd 75 04		      ld    (IX+4), L 
10c8 dd 74 05		      ld    (IX+5), H 
10cb			 
10cb dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
10ce dd 66 01		      ld    H, (IX+1) 
10d1 dd 75 02		      ld    (IX+2), L 
10d4 dd 74 03		      ld    (IX+3), H 
10d7			 
10d7					if DEBUG_FORTH_MALLOC 
10d7						DMARK "MA>" 
10d7						CALLMONITOR 
10d7					endif 
10d7 18 c9		      jr    malloc_find_space 
10d9			 
10d9			      ; split a bigger block into two - requested size and remaining size 
10d9			malloc_alloc_split: 
10d9					if DEBUG_FORTH_MALLOC 
10d9						DMARK "MAs" 
10d9						CALLMONITOR 
10d9					endif 
10d9 eb			      ex    DE, HL                  ; Calculate address of new free block 
10da 2b			      dec   HL 
10db 2b			      dec   HL 
10dc 2b			      dec   HL 
10dd 09			      add   HL, BC 
10de			 
10de			      ; Create a new block and point it at next_free 
10de dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
10e1 dd 56 01		      ld    D, (IX+1) 
10e4			 
10e4 73			      ld    (HL), E                 ; Store next_free ptr into new block 
10e5 23			      inc   HL 
10e6 72			      ld    (HL), D 
10e7			 
10e7 d1			      pop   DE                      ; Store size of new block into new block 
10e8 23			      inc   HL 
10e9 73			      ld    (HL), E 
10ea 23			      inc   HL 
10eb 72			      ld    (HL), D 
10ec			 
10ec			      ; Update this_free ptr to point to new block 
10ec 2b			      dec   HL 
10ed 2b			      dec   HL 
10ee 2b			      dec   HL 
10ef			 
10ef dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
10f2 dd 56 03		      ld    D, (IX+3) 
10f5			 
10f5 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
10f8 dd 74 03		      ld    (IX+3), H 
10fb			 
10fb			      ; Modify this_free block to be allocation 
10fb eb			      ex    DE, HL 
10fc af			      xor   A                       ; Null the next block ptr of allocated block 
10fd 77			      ld    (HL), A 
10fe 23			      inc   HL 
10ff 77			      ld    (HL), A 
1100			 
1100 23			      inc   HL                      ; Store want size into allocated block 
1101 71			      ld    (HL), C 
1102 23			      inc   HL 
1103 70			      ld    (HL), B 
1104 23			      inc   HL 
1105 e5			      push  HL                      ; Address of allocation to return 
1106			 
1106 18 19		      jr    malloc_update_links 
1108			 
1108			malloc_alloc_fit: 
1108 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1109			 
1109					if DEBUG_FORTH_MALLOC 
1109						DMARK "MAf" 
1109						CALLMONITOR 
1109					endif 
1109			      ; Modify this_free block to be allocation 
1109 eb			      ex    DE, HL 
110a 2b			      dec   HL 
110b 2b			      dec   HL 
110c 2b			      dec   HL 
110d			 
110d af			      xor   A                       ; Null the next block ptr of allocated block 
110e 77			      ld    (HL), A 
110f 23			      inc   HL 
1110 77			      ld    (HL), A 
1111			 
1111 23			      inc   HL                      ; Store address of allocation to return 
1112 23			      inc   HL 
1113 23			      inc   HL 
1114 e5			      push  HL 
1115			 
1115			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1115 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1118 dd 66 01		      ld    H, (IX+1) 
111b			 
111b dd 75 02		      ld    (IX+2), L               ; HL to this_free 
111e dd 74 03		      ld    (IX+3), H 
1121			 
1121			 
1121			malloc_update_links: 
1121			      ; Update prev_free ptr to point to this_free 
1121 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1124 dd 66 05		      ld    H, (IX+5) 
1127			 
1127 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
112a dd 56 03		      ld    D, (IX+3) 
112d			 
112d 73			      ld    (HL), E                 ; this_free ptr into prev_free 
112e 23			      inc   HL 
112f 72			      ld    (HL), D 
1130			 
1130					if DEBUG_FORTH_MALLOC 
1130						DMARK "Mul" 
1130						CALLMONITOR 
1130					endif 
1130			      ; Clear the Z flag to indicate successful allocation 
1130 7a			      ld    A, D 
1131 b3			      or    E 
1132			 
1132 d1			      pop   DE                      ; Address of allocation 
1133					if DEBUG_FORTH_MALLOC 
1133						DMARK "MAu" 
1133						CALLMONITOR 
1133					endif 
1133			 
1133			malloc_no_space: 
1133 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1136 39			      add   HL, SP 
1137 f9			      ld    SP, HL 
1138			 
1138 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1139					if DEBUG_FORTH_MALLOC 
1139						DMARK "MAN" 
1139						CALLMONITOR 
1139					endif 
1139			 
1139			malloc_early_exit: 
1139					if DEBUG_FORTH_MALLOC 
1139						DMARK "MAx" 
1139						CALLMONITOR 
1139					endif 
1139 dd e1		      pop   IX 
113b d1			      pop   DE 
113c c1			      pop   BC 
113d			 
113d			if DEBUG_FORTH_MALLOC_HIGH 
113d			call malloc_guard_exit 
113d			call malloc_guard_zerolen 
113d			endif 
113d c9			      ret 
113e			 
113e			 
113e			;------------------------------------------------------------------------------ 
113e			;     free                                                                    : 
113e			;                                                                             : 
113e			; Description                                                                 : 
113e			;     Return the space pointed to by HL to the heap. HL must be an address as : 
113e			;     returned by malloc, otherwise the behaviour is undefined.               : 
113e			;                                                                             : 
113e			;     Where possible, directly adjacent free blocks will be merged together   : 
113e			;     into larger blocks to help ensure that the heap does not become         : 
113e			;     excessively fragmented.                                                 : 
113e			;                                                                             : 
113e			;     free does not clear or set any other value into the freed space, and    : 
113e			;     therefore its contents may be visible through subsequent malloc's. The  : 
113e			;     caller should clear the freed space as required.                        : 
113e			;                                                                             : 
113e			;     This implementation of free uses the stack exclusively, and is          : 
113e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
113e			;     advisable to disable interrupts before calling free, and recommended    : 
113e			;     to avoid the use of free inside ISRs in general.                        : 
113e			;                                                                             : 
113e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
113e			;                                                                             : 
113e			; Parameters                                                                  : 
113e			;     HL  Pointer to address of first byte of allocation to be freed          : 
113e			;                                                                             : 
113e			; Returns                                                                     : 
113e			;     Nothing                                                                 : 
113e			;                                                                             : 
113e			; Stack frame                                                                 : 
113e			;       |             |                                                       : 
113e			;       +-------------+                                                       : 
113e			;       |     BC      |                                                       : 
113e			;       +-------------+                                                       : 
113e			;       |     DE      |                                                       : 
113e			;       +-------------+                                                       : 
113e			;       |     IX      |                                                       : 
113e			;       +-------------+                                                       : 
113e			;       |  prev_free  |                                                       : 
113e			;   +2  +-------------+                                                       : 
113e			;       |  next_free  |                                                       : 
113e			;   +0  +-------------+                                                       : 
113e			;       |             |                                                       : 
113e			;                                                                             : 
113e			;------------------------------------------------------------------------------ 
113e			free: 
113e c5			      push  BC 
113f d5			      push  DE 
1140 dd e5		      push  IX 
1142			 
1142 7c			      ld    A, H                    ; Exit if ptr is null 
1143 b5			      or    L 
1144 ca 08 12		      jp    Z, free_early_exit 
1147			 
1147			      ; Set up stack frame 
1147 eb			      ex    DE, HL 
1148 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
114b 39			      add   HL, SP 
114c f9			      ld    SP, HL 
114d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1151 dd 39		      add   IX, SP 
1153			 
1153			      ; The address in HL points to the start of the useable allocated space, 
1153			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1153			      ; address of the block itself. 
1153 eb			      ex    DE, HL 
1154 11 fc ff		      ld    DE, -4 
1157 19			      add   HL, DE 
1158			 
1158			      ; An allocated block must have a null next block pointer in it 
1158 7e			      ld    A, (HL) 
1159 23			      inc   HL 
115a b6			      or    (HL) 
115b c2 03 12		      jp    NZ, free_done 
115e			 
115e 2b			      dec   HL 
115f			 
115f 44			      ld    B, H                    ; Copy HL to BC 
1160 4d			      ld    C, L 
1161			 
1161			      ; Loop through the free list to find the first block with an address 
1161			      ; higher than the block being freed 
1161 21 50 59		      ld    HL, free_list 
1164			 
1164			free_find_higher_block: 
1164 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1165 23			      inc   HL 
1166 56			      ld    D, (HL) 
1167 2b			      dec   HL 
1168			 
1168 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
116b dd 72 01		      ld    (IX+1), D 
116e dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1171 dd 74 03		      ld    (IX+3), H 
1174			 
1174 78			      ld    A, B                    ; Check if DE is greater than BC 
1175 ba			      cp    D                       ; Compare MSB first 
1176 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1178 30 04		      jr    NC, free_find_higher_block_skip 
117a 79			      ld    A, C 
117b bb			      cp    E                       ; Then compare LSB 
117c 38 08		      jr    C, free_found_higher_block 
117e			 
117e			free_find_higher_block_skip: 
117e 7a			      ld    A, D                    ; Reached the end of the free list? 
117f b3			      or    E 
1180 ca 03 12		      jp    Z, free_done 
1183			 
1183 eb			      ex    DE, HL 
1184			 
1184 18 de		      jr    free_find_higher_block 
1186			 
1186			free_found_higher_block: 
1186			      ; Insert freed block between prev and next free blocks 
1186 71			      ld    (HL), C                 ; Point prev free block to freed block 
1187 23			      inc   HL 
1188 70			      ld    (HL), B 
1189			 
1189 60			      ld    H, B                    ; Point freed block at next free block 
118a 69			      ld    L, C 
118b 73			      ld    (HL), E 
118c 23			      inc   HL 
118d 72			      ld    (HL), D 
118e			 
118e			      ; Check if the freed block is adjacent to the next free block 
118e 23			      inc   HL                      ; Load size of freed block into HL 
118f 5e			      ld    E, (HL) 
1190 23			      inc   HL 
1191 56			      ld    D, (HL) 
1192 eb			      ex    DE, HL 
1193			 
1193 09			      add   HL, BC                  ; Add addr of freed block and its size 
1194			 
1194 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1197 dd 56 01		      ld    D, (IX+1) 
119a			 
119a b7			      or    A                       ; Clear the carry flag 
119b ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
119d 20 22		      jr    NZ, free_check_adjacent_to_prev 
119f			 
119f			      ; Freed block is adjacent to next, merge into one bigger block 
119f eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
11a0 5e			      ld    E, (HL) 
11a1 23			      inc   HL 
11a2 56			      ld    D, (HL) 
11a3 e5			      push  HL                      ; Save ptr to next block for later 
11a4			 
11a4 60			      ld    H, B                    ; Store ptr from next block into freed block 
11a5 69			      ld    L, C 
11a6 73			      ld    (HL), E 
11a7 23			      inc   HL 
11a8 72			      ld    (HL), D 
11a9			 
11a9 e1			      pop   HL                      ; Restore ptr to next block 
11aa 23			      inc   HL                      ; Load size of next block into DE 
11ab 5e			      ld    E, (HL) 
11ac 23			      inc   HL 
11ad 56			      ld    D, (HL) 
11ae d5			      push  DE                      ; Save next block size for later 
11af			 
11af 60			      ld    H, B                    ; Load size of freed block into HL 
11b0 69			      ld    L, C 
11b1 23			      inc   HL 
11b2 23			      inc   HL 
11b3 5e			      ld    E, (HL) 
11b4 23			      inc   HL 
11b5 56			      ld    D, (HL) 
11b6 eb			      ex    DE, HL 
11b7			 
11b7 d1			      pop   DE                      ; Restore size of next block 
11b8 19			      add   HL, DE                  ; Add sizes of both blocks 
11b9 eb			      ex    DE, HL 
11ba			 
11ba 60			      ld    H, B                    ; Store new bigger size into freed block 
11bb 69			      ld    L, C 
11bc 23			      inc   HL 
11bd 23			      inc   HL 
11be 73			      ld    (HL), E 
11bf 23			      inc   HL 
11c0 72			      ld    (HL), D 
11c1			 
11c1			free_check_adjacent_to_prev: 
11c1			      ; Check if the freed block is adjacent to the prev free block 
11c1 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
11c4 dd 66 03		      ld    H, (IX+3) 
11c7			 
11c7 23			      inc   HL                      ; Size of prev free block into DE 
11c8 23			      inc   HL 
11c9 5e			      ld    E, (HL) 
11ca 23			      inc   HL 
11cb 56			      ld    D, (HL) 
11cc 2b			      dec   HL 
11cd 2b			      dec   HL 
11ce 2b			      dec   HL 
11cf			 
11cf 19			      add   HL, DE                  ; Add prev block addr and size 
11d0			 
11d0 b7			      or    A                       ; Clear the carry flag 
11d1 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
11d3 20 2e		      jr    NZ, free_done 
11d5			 
11d5			      ; Freed block is adjacent to prev, merge into one bigger block 
11d5 60			      ld    H, B                    ; Load next ptr from freed block into DE 
11d6 69			      ld    L, C 
11d7 5e			      ld    E, (HL) 
11d8 23			      inc   HL 
11d9 56			      ld    D, (HL) 
11da e5			      push  HL                      ; Save freed block ptr for later 
11db			 
11db dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
11de dd 66 03		      ld    H, (IX+3) 
11e1 73			      ld    (HL), E 
11e2 23			      inc   HL 
11e3 72			      ld    (HL), D 
11e4			 
11e4 e1			      pop   HL                      ; Restore freed block ptr 
11e5 23			      inc   HL                      ; Load size of freed block into DE 
11e6 5e			      ld    E, (HL) 
11e7 23			      inc   HL 
11e8 56			      ld    D, (HL) 
11e9 d5			      push  DE                      ; Save freed block size for later 
11ea			 
11ea dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
11ed dd 66 03		      ld    H, (IX+3) 
11f0 23			      inc   HL 
11f1 23			      inc   HL 
11f2 5e			      ld    E, (HL) 
11f3 23			      inc   HL 
11f4 56			      ld    D, (HL) 
11f5			 
11f5 e1			      pop   HL                      ; Add sizes of both blocks 
11f6 19			      add   HL, DE 
11f7 eb			      ex    DE, HL 
11f8			 
11f8 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
11fb dd 66 03		      ld    H, (IX+3) 
11fe 23			      inc   HL 
11ff 23			      inc   HL 
1200 73			      ld    (HL), E 
1201 23			      inc   HL 
1202 72			      ld    (HL), D 
1203			 
1203			free_done: 
1203 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1206 39			      add   HL, SP 
1207 f9			      ld    SP, HL 
1208			 
1208			free_early_exit: 
1208 dd e1		      pop   IX 
120a d1			      pop   DE 
120b c1			      pop   BC 
120c			 
120c c9			      ret 
120d			 
120d			; moved to firmware.asm 
120d			; 
120d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
120d			;                  .dw   0 
120d			 
120d			 
120d			endif 
120d			 
120d			 
120d			if MALLOC_3 
120d			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
120d			;heap_start        .equ  0x9000      ; Starting address of heap 
120d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
120d			; 
120d			 ;     .org 0 
120d			  ;    jp    main 
120d			; 
120d			; 
120d			 ;     .org  0x100 
120d			;main: 
120d			 ;     ld    HL, 0x8100 
120d			  ;    ld    SP, HL 
120d			; 
120d			;      call  heap_init 
120d			 
120d			      ; Make some allocations 
120d			;      ld    HL, 12 
120d			;      call  malloc            ; Allocates 0x9004 
120d			; 
120d			 ;     ld    HL, 12 
120d			;      call  malloc            ; Allocates 0x9014 
120d			 
120d			;      ld    HL, 12 
120d			;      call  malloc            ; Allocates 0x9024 
120d			 
120d			      ; Free some allocations 
120d			;      ld    HL, 0x9014 
120d			;      call  free 
120d			 
120d			;      ld    HL, 0x9004 
120d			;      call  free 
120d			; 
120d			;      ld    HL, 0x9024 
120d			;      call  free 
120d			 
120d			 
120d			 ;     halt 
120d			 
120d			 
120d			;------------------------------------------------------------------------------ 
120d			;     heap_init                                                               : 
120d			;                                                                             : 
120d			; Description                                                                 : 
120d			;     Initialise the heap and make it ready for malloc and free operations.   : 
120d			;                                                                             : 
120d			;     The heap is maintained as a linked list, starting with an initial       : 
120d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
120d			;     the first free block in the heap. Each block then points to the next    : 
120d			;     free block within the heap, and the free list ends at the first block   : 
120d			;     with a null pointer to the next free block.                             : 
120d			;                                                                             : 
120d			; Parameters                                                                  : 
120d			;     Inputs are compile-time only. Two defines which specify the starting    : 
120d			;     address of the heap and its size are required, along with a memory      : 
120d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
120d			;     principally stores a pointer to the first free block in the heap.       : 
120d			;                                                                             : 
120d			; Returns                                                                     : 
120d			;     Nothing                                                                 : 
120d			;------------------------------------------------------------------------------ 
120d			heap_init: 
120d			      push  HL 
120d			 
120d			      ; Initialise free list struct 
120d			      ld    HL, heap_start 
120d			      ld    (free_list), HL 
120d			      ld    HL, 0 
120d			      ld    (free_list+2), HL 
120d			 
120d			      ; Insert first free block at bottom of heap, consumes entire heap 
120d			      ld    HL, heap_start+heap_size-4 
120d			      ld    (heap_start), HL        ; Next block (end of free list) 
120d			      ld    HL, heap_size-4 
120d			      ld    (heap_start+2), HL      ; Block size 
120d			 
120d			      ; Insert end of free list block at top of heap - two null words will 
120d			      ; terminate the free list 
120d			      ld    HL, 0 
120d			      ld    (heap_start+heap_size-2), HL 
120d			      ld    (heap_start+heap_size-4), HL 
120d			 
120d			      pop   HL 
120d			 
120d			      ret 
120d			 
120d			 
120d			;------------------------------------------------------------------------------ 
120d			;     malloc                                                                  : 
120d			;                                                                             : 
120d			; Description                                                                 : 
120d			;     Allocates the wanted space from the heap and returns the address of the : 
120d			;     first useable byte of the allocation.                                   : 
120d			;                                                                             : 
120d			;     Allocations can happen in one of two ways:                              : 
120d			;                                                                             : 
120d			;     1. A free block may be found which is the exact size wanted. In this    : 
120d			;        case the block is removed from the free list and retuedn to the      : 
120d			;        caller.                                                              : 
120d			;     2. A free block may be found which is larger than the size wanted. In   : 
120d			;        this case, the larger block is split into two. The first portion of  : 
120d			;        this block will become the requested space by the malloc call and    : 
120d			;        is returned to the caller. The second portion becomes a new free     : 
120d			;        block, and the free list is adjusted to maintain continuity via this : 
120d			;        newly created block.                                                 : 
120d			;                                                                             : 
120d			;     malloc does not set any initial value in the allocated space, the       : 
120d			;     caller is required to do this as required.                              : 
120d			;                                                                             : 
120d			;     This implementation of malloc uses the stack exclusively, and is        : 
120d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
120d			;     advisable to disable interrupts before calling malloc, and recommended  : 
120d			;     to avoid the use of malloc inside ISRs in general.                      : 
120d			;                                                                             : 
120d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
120d			;                                                                             : 
120d			; Parameters                                                                  : 
120d			;     HL  Number of bytes wanted                                              : 
120d			;                                                                             : 
120d			; Returns                                                                     : 
120d			;     HL  Address of the first useable byte of the allocation                 : 
120d			;                                                                             : 
120d			; Flags                                                                       : 
120d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
120d			;                                                                             : 
120d			; Stack frame                                                                 : 
120d			;       |             |                                                       : 
120d			;       +-------------+                                                       : 
120d			;       |     BC      |                                                       : 
120d			;       +-------------+                                                       : 
120d			;       |     DE      |                                                       : 
120d			;       +-------------+                                                       : 
120d			;       |     IX      |                                                       : 
120d			;       +-------------+                                                       : 
120d			;       |  prev_free  |                                                       : 
120d			;   +4  +-------------+                                                       : 
120d			;       |  this_free  |                                                       : 
120d			;   +2  +-------------+                                                       : 
120d			;       |  next_free  |                                                       : 
120d			;   +0  +-------------+                                                       : 
120d			;       |             |                                                       : 
120d			;                                                                             : 
120d			;------------------------------------------------------------------------------ 
120d			malloc: 
120d			      push  BC 
120d			      push  DE 
120d			      push  IX 
120d			 
120d			      ld    A, H                    ; Exit if no space requested 
120d			      or    L 
120d			      jp    Z, malloc_early_exit 
120d			 
120d			      ; Set up stack frame 
120d			      ex    DE, HL 
120d			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
120d			      add   HL, SP 
120d			      ld    SP, HL 
120d			      ld    IX, 0                   ; Use IX as a frame pointer 
120d			      add   IX, SP 
120d			 
120d			      ; Setup initial state 
120d			      ld    HL, 4                   ; want must also include space used by block struct 
120d			      add   HL, DE 
120d			 
120d			      ld    B, H                    ; Move want to BC 
120d			      ld    C, L 
120d			 
120d			      ld    HL, free_list           ; Store prev_free ptr to stack 
120d			      ld    (IX+4), L 
120d			      ld    (IX+5), H 
120d			 
120d			      ld    E, (HL)                 ; Store this_free ptr to stack 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			      ld    (IX+2), E 
120d			      ld    (IX+3), D 
120d			      ex    DE, HL                  ; this_free ptr into HL 
120d			 
120d			      ; Loop through free block list to find some space 
120d			malloc_find_space: 
120d			      ld    E, (HL)                 ; Load next_free ptr into DE 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			 
120d			      ld    A, D                    ; Check for null next_free ptr - end of free list 
120d			      or    E 
120d			      jp    Z, malloc_no_space 
120d			 
120d			      ld    (IX+0), E               ; Store next_free ptr to stack 
120d			      ld    (IX+1), D 
120d			 
120d			      ; Does this block have enough space to make the allocation? 
120d			      inc   HL                      ; Load free block size into DE 
120d			      ld    E, (HL) 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			 
120d			      ex    DE, HL                  ; Check size of block against want 
120d			      or    A                       ; Ensure carry flag clear 
120d			      sbc   HL, BC 
120d			      push  HL                      ; Store the result for later (new block size) 
120d			 
120d			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
120d			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
120d			 
120d			      ; this_free block is not big enough, setup ptrs to test next free block 
120d			      pop   HL                      ; Discard previous result 
120d			 
120d			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
120d			      ld    H, (IX+3) 
120d			      ld    (IX+4), L 
120d			      ld    (IX+5), H 
120d			 
120d			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
120d			      ld    H, (IX+1) 
120d			      ld    (IX+2), L 
120d			      ld    (IX+3), H 
120d			 
120d			      jr    malloc_find_space 
120d			 
120d			      ; split a bigger block into two - requested size and remaining size 
120d			malloc_alloc_split: 
120d			      ex    DE, HL                  ; Calculate address of new free block 
120d			      dec   HL 
120d			      dec   HL 
120d			      dec   HL 
120d			      add   HL, BC 
120d			 
120d			      ; Create a new block and point it at next_free 
120d			      ld    E, (IX+0)               ; Load next_free ptr into DE 
120d			      ld    D, (IX+1) 
120d			 
120d			      ld    (HL), E                 ; Store next_free ptr into new block 
120d			      inc   HL 
120d			      ld    (HL), D 
120d			 
120d			      pop   DE                      ; Store size of new block into new block 
120d			      inc   HL 
120d			      ld    (HL), E 
120d			      inc   HL 
120d			      ld    (HL), D 
120d			 
120d			      ; Update this_free ptr to point to new block 
120d			      dec   HL 
120d			      dec   HL 
120d			      dec   HL 
120d			 
120d			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
120d			      ld    D, (IX+3) 
120d			 
120d			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
120d			      ld    (IX+3), H 
120d			 
120d			      ; Modify this_free block to be allocation 
120d			      ex    DE, HL 
120d			      xor   A                       ; Null the next block ptr of allocated block 
120d			      ld    (HL), A 
120d			      inc   HL 
120d			      ld    (HL), A 
120d			 
120d			      inc   HL                      ; Store want size into allocated block 
120d			      ld    (HL), C 
120d			      inc   HL 
120d			      ld    (HL), B 
120d			      inc   HL 
120d			      push  HL                      ; Address of allocation to return 
120d			 
120d			      jr    malloc_update_links 
120d			 
120d			malloc_alloc_fit: 
120d			      pop   HL                      ; Dont need new block size, want is exact fit 
120d			 
120d			      ; Modify this_free block to be allocation 
120d			      ex    DE, HL 
120d			      dec   HL 
120d			      dec   HL 
120d			      dec   HL 
120d			 
120d			      xor   A                       ; Null the next block ptr of allocated block 
120d			      ld    (HL), A 
120d			      inc   HL 
120d			      ld    (HL), A 
120d			 
120d			      inc   HL                      ; Store address of allocation to return 
120d			      inc   HL 
120d			      inc   HL 
120d			      push  HL 
120d			 
120d			      ; Copy next_free ptr to this_free, remove allocated block from free list 
120d			      ld    L, (IX+0)               ; next_free to HL 
120d			      ld    H, (IX+1) 
120d			 
120d			      ld    (IX+2), L               ; HL to this_free 
120d			      ld    (IX+3), H 
120d			 
120d			 
120d			malloc_update_links: 
120d			      ; Update prev_free ptr to point to this_free 
120d			      ld    L, (IX+4)               ; prev_free ptr to HL 
120d			      ld    H, (IX+5) 
120d			 
120d			      ld    E, (IX+2)               ; this_free ptr to DE 
120d			      ld    D, (IX+3) 
120d			 
120d			      ld    (HL), E                 ; this_free ptr into prev_free 
120d			      inc   HL 
120d			      ld    (HL), D 
120d			 
120d			      ; Clear the Z flag to indicate successful allocation 
120d			      ld    A, D 
120d			      or    E 
120d			 
120d			      pop   DE                      ; Address of allocation 
120d			 
120d			malloc_no_space: 
120d			      ld    HL, 6                   ; Clean up stack frame 
120d			      add   HL, SP 
120d			      ld    SP, HL 
120d			 
120d			      ex    DE, HL                  ; Alloc addr into HL for return 
120d			 
120d			malloc_early_exit: 
120d			      pop   IX 
120d			      pop   DE 
120d			      pop   BC 
120d			 
120d			      ret 
120d			 
120d			 
120d			;------------------------------------------------------------------------------ 
120d			;     free                                                                    : 
120d			;                                                                             : 
120d			; Description                                                                 : 
120d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
120d			;     returned by malloc, otherwise the behaviour is undefined.               : 
120d			;                                                                             : 
120d			;     Where possible, directly adjacent free blocks will be merged together   : 
120d			;     into larger blocks to help ensure that the heap does not become         : 
120d			;     excessively fragmented.                                                 : 
120d			;                                                                             : 
120d			;     free does not clear or set any other value into the freed space, and    : 
120d			;     therefore its contents may be visible through subsequent malloc's. The  : 
120d			;     caller should clear the freed space as required.                        : 
120d			;                                                                             : 
120d			;     This implementation of free uses the stack exclusively, and is          : 
120d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
120d			;     advisable to disable interrupts before calling free, and recommended    : 
120d			;     to avoid the use of free inside ISRs in general.                        : 
120d			;                                                                             : 
120d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
120d			;                                                                             : 
120d			; Parameters                                                                  : 
120d			;     HL  Pointer to address of first byte of allocation to be freed          : 
120d			;                                                                             : 
120d			; Returns                                                                     : 
120d			;     Nothing                                                                 : 
120d			;                                                                             : 
120d			; Stack frame                                                                 : 
120d			;       |             |                                                       : 
120d			;       +-------------+                                                       : 
120d			;       |     BC      |                                                       : 
120d			;       +-------------+                                                       : 
120d			;       |     DE      |                                                       : 
120d			;       +-------------+                                                       : 
120d			;       |     IX      |                                                       : 
120d			;       +-------------+                                                       : 
120d			;       |  prev_free  |                                                       : 
120d			;   +2  +-------------+                                                       : 
120d			;       |  next_free  |                                                       : 
120d			;   +0  +-------------+                                                       : 
120d			;       |             |                                                       : 
120d			;                                                                             : 
120d			;------------------------------------------------------------------------------ 
120d			free: 
120d			      push  BC 
120d			      push  DE 
120d			      push  IX 
120d			 
120d			      ld    A, H                    ; Exit if ptr is null 
120d			      or    L 
120d			      jp    Z, free_early_exit 
120d			 
120d			      ; Set up stack frame 
120d			      ex    DE, HL 
120d			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
120d			      add   HL, SP 
120d			      ld    SP, HL 
120d			      ld    IX, 0                   ; Use IX as a frame pointer 
120d			      add   IX, SP 
120d			 
120d			      ; The address in HL points to the start of the useable allocated space, 
120d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
120d			      ; address of the block itself. 
120d			      ex    DE, HL 
120d			      ld    DE, -4 
120d			      add   HL, DE 
120d			 
120d			      ; An allocated block must have a null next block pointer in it 
120d			      ld    A, (HL) 
120d			      inc   HL 
120d			      or    (HL) 
120d			      jp    NZ, free_done 
120d			 
120d			      dec   HL 
120d			 
120d			      ld    B, H                    ; Copy HL to BC 
120d			      ld    C, L 
120d			 
120d			      ; Loop through the free list to find the first block with an address 
120d			      ; higher than the block being freed 
120d			      ld    HL, free_list 
120d			 
120d			free_find_higher_block: 
120d			      ld    E, (HL)                 ; Load next ptr from free block 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			      dec   HL 
120d			 
120d			      ld    (IX+0), E               ; Save ptr to next free block 
120d			      ld    (IX+1), D 
120d			      ld    (IX+2), L               ; Save ptr to prev free block 
120d			      ld    (IX+3), H 
120d			 
120d			      ld    A, B                    ; Check if DE is greater than BC 
120d			      cp    D                       ; Compare MSB first 
120d			      jr    Z, $+4                  ; MSB the same, compare LSB 
120d			      jr    NC, free_find_higher_block_skip 
120d			      ld    A, C 
120d			      cp    E                       ; Then compare LSB 
120d			      jr    C, free_found_higher_block 
120d			 
120d			free_find_higher_block_skip: 
120d			      ld    A, D                    ; Reached the end of the free list? 
120d			      or    E 
120d			      jp    Z, free_done 
120d			 
120d			      ex    DE, HL 
120d			 
120d			      jr    free_find_higher_block 
120d			 
120d			free_found_higher_block: 
120d			      ; Insert freed block between prev and next free blocks 
120d			      ld    (HL), C                 ; Point prev free block to freed block 
120d			      inc   HL 
120d			      ld    (HL), B 
120d			 
120d			      ld    H, B                    ; Point freed block at next free block 
120d			      ld    L, C 
120d			      ld    (HL), E 
120d			      inc   HL 
120d			      ld    (HL), D 
120d			 
120d			      ; Check if the freed block is adjacent to the next free block 
120d			      inc   HL                      ; Load size of freed block into HL 
120d			      ld    E, (HL) 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			      ex    DE, HL 
120d			 
120d			      add   HL, BC                  ; Add addr of freed block and its size 
120d			 
120d			      ld    E, (IX+0)               ; Load addr of next free block into DE 
120d			      ld    D, (IX+1) 
120d			 
120d			      or    A                       ; Clear the carry flag 
120d			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
120d			      jr    NZ, free_check_adjacent_to_prev 
120d			 
120d			      ; Freed block is adjacent to next, merge into one bigger block 
120d			      ex    DE, HL                  ; Load next ptr from next block into DE 
120d			      ld    E, (HL) 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			      push  HL                      ; Save ptr to next block for later 
120d			 
120d			      ld    H, B                    ; Store ptr from next block into freed block 
120d			      ld    L, C 
120d			      ld    (HL), E 
120d			      inc   HL 
120d			      ld    (HL), D 
120d			 
120d			      pop   HL                      ; Restore ptr to next block 
120d			      inc   HL                      ; Load size of next block into DE 
120d			      ld    E, (HL) 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			      push  DE                      ; Save next block size for later 
120d			 
120d			      ld    H, B                    ; Load size of freed block into HL 
120d			      ld    L, C 
120d			      inc   HL 
120d			      inc   HL 
120d			      ld    E, (HL) 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			      ex    DE, HL 
120d			 
120d			      pop   DE                      ; Restore size of next block 
120d			      add   HL, DE                  ; Add sizes of both blocks 
120d			      ex    DE, HL 
120d			 
120d			      ld    H, B                    ; Store new bigger size into freed block 
120d			      ld    L, C 
120d			      inc   HL 
120d			      inc   HL 
120d			      ld    (HL), E 
120d			      inc   HL 
120d			      ld    (HL), D 
120d			 
120d			free_check_adjacent_to_prev: 
120d			      ; Check if the freed block is adjacent to the prev free block 
120d			      ld    L, (IX+2)               ; Prev free block ptr into HL 
120d			      ld    H, (IX+3) 
120d			 
120d			      inc   HL                      ; Size of prev free block into DE 
120d			      inc   HL 
120d			      ld    E, (HL) 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			      dec   HL 
120d			      dec   HL 
120d			      dec   HL 
120d			 
120d			      add   HL, DE                  ; Add prev block addr and size 
120d			 
120d			      or    A                       ; Clear the carry flag 
120d			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
120d			      jr    NZ, free_done 
120d			 
120d			      ; Freed block is adjacent to prev, merge into one bigger block 
120d			      ld    H, B                    ; Load next ptr from freed block into DE 
120d			      ld    L, C 
120d			      ld    E, (HL) 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			      push  HL                      ; Save freed block ptr for later 
120d			 
120d			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
120d			      ld    H, (IX+3) 
120d			      ld    (HL), E 
120d			      inc   HL 
120d			      ld    (HL), D 
120d			 
120d			      pop   HL                      ; Restore freed block ptr 
120d			      inc   HL                      ; Load size of freed block into DE 
120d			      ld    E, (HL) 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			      push  DE                      ; Save freed block size for later 
120d			 
120d			      ld    L, (IX+2)               ; Load size of prev block into DE 
120d			      ld    H, (IX+3) 
120d			      inc   HL 
120d			      inc   HL 
120d			      ld    E, (HL) 
120d			      inc   HL 
120d			      ld    D, (HL) 
120d			 
120d			      pop   HL                      ; Add sizes of both blocks 
120d			      add   HL, DE 
120d			      ex    DE, HL 
120d			 
120d			      ld    L, (IX+2)               ; Store new bigger size into prev block 
120d			      ld    H, (IX+3) 
120d			      inc   HL 
120d			      inc   HL 
120d			      ld    (HL), E 
120d			      inc   HL 
120d			      ld    (HL), D 
120d			 
120d			free_done: 
120d			      ld    HL, 4                   ; Clean up stack frame 
120d			      add   HL, SP 
120d			      ld    SP, HL 
120d			 
120d			free_early_exit: 
120d			      pop   IX 
120d			      pop   DE 
120d			      pop   BC 
120d			 
120d			      ret 
120d			 
120d			 
120d			;      .org 0x8000 
120d			; 
120d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
120d			 ;                 .dw   0 
120d			 
120d			endif 
120d			 
120d			 
120d			if MALLOC_4 
120d			 
120d			; My memory allocation code. Very very simple.... 
120d			; allocate space under 250 chars 
120d			 
120d			heap_init: 
120d				; init start of heap as zero 
120d				;  
120d			 
120d				ld hl, heap_start 
120d				ld a, 0 
120d				ld (hl), a      ; empty block 
120d				inc hl 
120d				ld a, 0 
120d				ld (hl), a      ; length of block 
120d				; write end of list 
120d				inc hl 
120d				ld a,(hl) 
120d				inc hl 
120d				ld a,(hl) 
120d				 
120d			 
120d				; init some malloc vars 
120d			 
120d				ld hl, 0 
120d				ld (free_list), hl       ; store last malloc location 
120d			 
120d				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
120d				ld a, 0 
120d				ld (hl), a 
120d			 
120d			 
120d				ld hl, heap_start 
120d				;  
120d				  
120d				ret 
120d			 
120d			 
120d			;    free block marker 
120d			;    requested size  
120d			;    pointer to next block 
120d			;    .... 
120d			;    next block marker 
120d			 
120d			 
120d			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
120d			; 
120d			 
120d			 
120d			malloc:  
120d				push de 
120d				push bc 
120d				push af 
120d			 
120d				; hl space required 
120d				 
120d				ld c, l    ; hold space   (TODO only a max of 255) 
120d			 
120d			;	inc c     ; TODO BUG need to fix memory leak on push str 
120d			;	inc c 
120d			;	inc c 
120d			;	inc c 
120d			;	inc c 
120d			;	inc c 
120d			;	inc c 
120d			 
120d			 
120d			 
120d				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
120d			 
120d				ld a, (free_list+3) 
120d				cp 0 
120d				jr z, .contheap 
120d			 
120d				ld hl, (free_list)     ; get last alloc 
120d					if DEBUG_FORTH_MALLOC_INT 
120d						DMARK "mrs" 
120d						CALLMONITOR 
120d					endif 
120d				jr .startalloc 
120d			 
120d			.contheap: 
120d				ld hl, heap_start 
120d			 
120d			.startalloc: 
120d			 
120d					if DEBUG_FORTH_MALLOC_INT 
120d						DMARK "mym" 
120d						CALLMONITOR 
120d					endif 
120d			.findblock: 
120d					if DEBUG_FORTH_MALLOC_INT 
120d						DMARK "mmf" 
120d						CALLMONITOR 
120d					endif 
120d			 
120d				ld a,(hl)  
120d				; if byte is zero then clear to use 
120d			 
120d				cp 0 
120d				jr z, .foundemptyblock 
120d			 
120d				; if byte is not clear 
120d				;     then byte is offset to next block 
120d			 
120d				inc hl 
120d				ld a, (hl) ; get size 
120d			.nextblock:	inc hl 
120d					ld e, (hl) 
120d					inc hl 
120d					ld d, (hl) 
120d					ex de, hl 
120d			;	inc hl  ; move past the store space 
120d			;	inc hl  ; move past zero index  
120d			 
120d				; TODO detect no more space 
120d			 
120d				push hl 
120d				ld de, heap_end 
120d				call cmp16 
120d				pop hl 
120d				jr nc, .nospace 
120d			 
120d				jr .findblock 
120d			 
120d			.nospace: ld hl, 0 
120d				jp .exit 
120d			 
120d			 
120d			.foundemptyblock:	 
120d					if DEBUG_FORTH_MALLOC_INT 
120d						DMARK "mme" 
120d						CALLMONITOR 
120d					endif 
120d			 
120d			; TODO has block enough space if reusing??? 
120d			 
120d				;  
120d			 
120d			; see if this block has been previously used 
120d				inc hl 
120d				ld a, (hl) 
120d				dec hl 
120d				cp 0 
120d				jr z, .newblock 
120d			 
120d					if DEBUG_FORTH_MALLOC_INT 
120d						DMARK "meR" 
120d						CALLMONITOR 
120d					endif 
120d			 
120d			; no reusing previously allocated block 
120d			 
120d			; is it smaller than previously used? 
120d				 
120d				inc hl    ; move to size 
120d				ld a, c 
120d				sub (hl)        ; we want c < (hl) 
120d				dec hl    ; move back to marker 
120d			        jr z, .findblock 
120d			 
120d				; update with the new size which should be lower 
120d			 
120d			        ;inc  hl   ; negate next move. move back to size  
120d			 
120d			.newblock: 
120d				; need to be at marker here 
120d			 
120d					if DEBUG_FORTH_MALLOC_INT 
120d						DMARK "meN" 
120d						CALLMONITOR 
120d					endif 
120d			 
120d			 
120d				ld a, c 
120d			 
120d				ld (free_list+3), a	 ; flag resume from last malloc  
120d				ld (free_list), hl    ; save out last location 
120d			 
120d			 
120d				;inc a     ; space for length byte 
120d				ld (hl), a     ; save block in use marker 
120d			 
120d				inc hl   ; move to space marker 
120d				ld (hl), a    ; save new space 
120d			 
120d				inc hl   ; move to start of allocated area 
120d				 
120d			;	push hl     ; save where we are - 1  
120d			 
120d			;	inc hl  ; move past zero index  
120d				; skip space to set down new marker 
120d			 
120d				; provide some extra space for now 
120d			 
120d				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
120d				inc a 
120d				inc a 
120d			 
120d				push hl   ; save where we are in the node block 
120d			 
120d				call addatohl 
120d			 
120d				; write linked list point 
120d			 
120d				pop de     ; get our node position 
120d				ex de, hl 
120d			 
120d				ld (hl), e 
120d				inc hl 
120d				ld (hl), d 
120d			 
120d				inc hl 
120d			 
120d				; now at start of allocated data so save pointer 
120d			 
120d				push hl 
120d			 
120d				; jump to position of next node and setup empty header in DE 
120d			 
120d				ex de, hl 
120d			 
120d			;	inc hl ; move past end of block 
120d			 
120d				ld a, 0 
120d				ld (hl), a   ; empty marker 
120d				inc hl 
120d				ld (hl), a   ; size 
120d				inc hl  
120d				ld (hl), a   ; ptr 
120d				inc hl 
120d				ld (hl), a   ; ptr 
120d			 
120d			 
120d				pop hl 
120d			 
120d					if DEBUG_FORTH_MALLOC_INT 
120d						DMARK "mmr" 
120d						CALLMONITOR 
120d					endif 
120d			 
120d			.exit: 
120d				pop af 
120d				pop bc 
120d				pop de  
120d				ret 
120d			 
120d			 
120d			 
120d			 
120d			free:  
120d				push hl 
120d				push af 
120d				; get address in hl 
120d			 
120d					if DEBUG_FORTH_MALLOC_INT 
120d						DMARK "fre" 
120d						CALLMONITOR 
120d					endif 
120d				; data is at hl - move to block count 
120d				dec hl 
120d				dec hl    ; get past pointer 
120d				dec hl 
120d			 
120d				ld a, (hl)    ; need this for a validation check 
120d			 
120d				dec hl    ; move to block marker 
120d			 
120d				; now check that the block count and block marker are the same  
120d			        ; this checks that we are on a malloc node and not random memory 
120d			        ; OK a faint chance this could be a problem but rare - famous last words! 
120d			 
120d				ld c, a 
120d				ld a, (hl)    
120d			 
120d				cp c 
120d				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
120d			 
120d				; yes good chance we are on a malloc node 
120d			 
120d				ld a, 0      
120d				ld (hl), a   ; mark as free 
120d			 
120d				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
120d			 
120d			.freeignore:  
120d			 
120d				pop af 
120d				pop hl 
120d			 
120d				ret 
120d			 
120d			 
120d			 
120d			endif 
120d			 
120d			; eof 
# End of file firmware_memory.asm
120d			  
120d			; device C  
120d			if SOUND_ENABLE  
120d				include "firmware_sound.asm"  
120d			endif  
120d			  
120d			include "firmware_diags.asm"  
120d			; Hardware diags menu 
120d			 
120d			 
120d			config: 
120d			 
120d 3e 00			ld a, 0 
120f 21 3d 12			ld hl, .configmn 
1212 cd b1 09			call menu 
1215			 
1215 fe 00			cp 0 
1217 c8				ret z 
1218			 
1218 fe 01			cp 1 
121a cc 6b 12			call z, .savetostore 
121d			 
121d fe 02			cp 2 
121f cc 57 12			call z, .selautoload 
1222 fe 03			cp 3 
1224 cc 4d 12			call z, .disautoload 
1227 fe 04			cp 4 
1229 cc 61 12			call z, .selbank 
122c fe 05			cp 5 
122e cc 75 12			call z, .debug_tog 
1231 fe 06			cp 6 
1233 cc b8 13			call z, .bpsgo 
1236 fe 07			cp 7 
1238 cc 9b 12			call z, hardware_diags 
123b			 
123b 18 d0			jr config 
123d			 
123d			.configmn: 
123d a9 15			dw prom_c3 
123f c0 15			dw prom_c2 
1241 d5 15			dw prom_c2a 
1243 eb 15			dw prom_c2b 
1245			;	dw prom_c4 
1245 08 16			dw prom_m4 
1247 23 16			dw prom_m4b 
1249 2b 16			dw prom_c1 
124b 00 00			dw 0 
124d				 
124d			 
124d			 
124d			 
124d			.disautoload: 
124d				if STORAGE_SE 
124d				ld a, $fe      ; bit 0 clear 
124d				ld (spi_device), a 
124d			 
124d				call storage_get_block_0 
124d			 
124d				ld a, 0 
124d				ld (store_page+STORE_0_AUTOFILE), a 
124d			 
124d					ld hl, 0 
124d					ld de, store_page 
124d				call storage_write_block	 ; save update 
124d				else 
124d			 
124d 21 3a 16			ld hl, prom_notav 
1250 11 50 16			ld de, prom_empty 
1253 cd 11 09			call info_panel 
1256				endif 
1256			 
1256			 
1256 c9				ret 
1257			 
1257			 
1257			 
1257			; Select auto start 
1257			 
1257			.selautoload: 
1257			 
1257				 
1257				if STORAGE_SE 
1257			 
1257					call config_dir 
1257				        ld hl, scratch 
1257					ld a, 0 
1257					call menu 
1257			 
1257					cp 0 
1257					ret z 
1257			 
1257					dec a 
1257			 
1257			 
1257					; locate menu option 
1257			 
1257					ld hl, scratch 
1257					call table_lookup 
1257			 
1257					if DEBUG_FORTH_WORDS 
1257						DMARK "ALl" 
1257						CALLMONITOR 
1257					endif 
1257					; with the pointer to the menu it, the byte following the zero term is the file id 
1257			 
1257					ld a, 0 
1257					ld bc, 50   ; max of bytes to look at 
1257					cpir  
1257			 
1257					if DEBUG_FORTH_WORDS 
1257						DMARK "ALb" 
1257						CALLMONITOR 
1257					endif 
1257					;inc hl 
1257			 
1257					ld a, (hl)   ; file id 
1257					 
1257				        ; save bank and file ids 
1257			 
1257					push af 
1257			 
1257			; TODO need to save to block 0 on bank 1	 
1257			 
1257					call storage_get_block_0 
1257			 
1257					if DEBUG_FORTH_WORDS 
1257						DMARK "AL0" 
1257						CALLMONITOR 
1257					endif 
1257					pop af 
1257			 
1257					ld (store_page+STORE_0_FILERUN),a 
1257					 
1257					; save bank id 
1257			 
1257					ld a,(spi_device) 
1257					ld (store_page+STORE_0_BANKRUN),a 
1257			 
1257					; enable auto run of store file 
1257			 
1257					ld a, 1 
1257					ld (store_page+STORE_0_AUTOFILE),a 
1257			 
1257					; save buffer 
1257			 
1257					ld hl, 0 
1257					ld de, store_page 
1257					if DEBUG_FORTH_WORDS 
1257						DMARK "ALw" 
1257						CALLMONITOR 
1257					endif 
1257				call storage_write_block	 ; save update 
1257			  
1257			 
1257			 
1257			 
1257					ld hl, scratch 
1257					call config_fdir 
1257			 
1257				else 
1257			 
1257 21 3a 16			ld hl, prom_notav 
125a 11 50 16			ld de, prom_empty 
125d cd 11 09			call info_panel 
1260			 
1260				endif 
1260 c9				ret 
1261			 
1261			 
1261			 
1261			; Select storage bank 
1261			 
1261			.selbank: 
1261			 
1261				if STORAGE_SE 
1261				else 
1261			 
1261 21 3a 16			ld hl, prom_notav 
1264 11 50 16			ld de, prom_empty 
1267 cd 11 09			call info_panel 
126a				endif 
126a				 
126a c9				ret 
126b			 
126b			if STORAGE_SE 
126b			 
126b			.config_ldir:   
126b				; Load storage bank labels into menu array 
126b			 
126b				 
126b			 
126b			 
126b				ret 
126b			 
126b			 
126b			endif 
126b			 
126b			 
126b			; Save user words to storage 
126b			 
126b			.savetostore: 
126b			 
126b				if STORAGE_SE 
126b			 
126b					call config_dir 
126b				        ld hl, scratch 
126b					ld a, 0 
126b					call menu 
126b					 
126b					ld hl, scratch 
126b					call config_fdir 
126b			 
126b				else 
126b			 
126b 21 3a 16			ld hl, prom_notav 
126e 11 50 16			ld de, prom_empty 
1271 cd 11 09			call info_panel 
1274			 
1274				endif 
1274			 
1274 c9				ret 
1275			 
1275			 
1275			 
1275			if STORAGE_SE 
1275			 
1275			config_fdir: 
1275				; using the scratch dir go through and release the memory allocated for each string 
1275				 
1275				ld hl, scratch 
1275			.cfdir:	ld e,(hl) 
1275				inc hl 
1275				ld d,(hl) 
1275				inc hl 
1275			 
1275				ex de, hl 
1275				call ishlzero 
1275				ret z     ; return on null pointer 
1275				call free 
1275				ex de, hl 
1275				jr .cfdir 
1275			 
1275			 
1275				ret 
1275			 
1275			 
1275			config_dir: 
1275			 
1275				; for the config menus that need to build a directory of storage call this routine 
1275				; it will construct a menu in scratch to pass to menu 
1275			 
1275				; open storage device 
1275			 
1275				; execute DIR to build a list of files and their ids into scratch in menu format 
1275				; once the menu has finished then will need to call config_fdir to release the strings 
1275				 
1275				; c = number items 
1275			 
1275				 
1275				call storage_get_block_0 
1275			 
1275				ld hl, store_page     ; get current id count 
1275				ld b, (hl) 
1275				ld c, 0    ; count of files   
1275			 
1275			 
1275				ld hl, scratch 
1275				ld (store_tmp2), hl    ; location to poke strings 
1275			 
1275				; check for empty drive 
1275			 
1275				ld a, 0 
1275				cp b 
1275				jp z, .dirdone 
1275			 
1275				 
1275					if DEBUG_FORTH_WORDS 
1275						DMARK "Cdc" 
1275						CALLMONITOR 
1275					endif 
1275			 
1275			 
1275			.diritem:	 
1275				push bc 
1275				; for each of the current ids do a search for them and if found push to stack 
1275			 
1275					ld hl, STORE_BLOCK_PHY 
1275					ld d, 0		 ; look for extent 0 of block id as this contains file name 
1275					ld e,b 
1275			 
1275					call storage_findnextid 
1275			 
1275			 
1275					; if found hl will be non zero 
1275			 
1275					call ishlzero 
1275					jr z, .dirnotfound 
1275			 
1275					; increase count 
1275			 
1275					pop bc	 
1275					inc c 
1275					push bc 
1275					 
1275			 
1275					; get file header and push the file name 
1275			 
1275					ld de, store_page 
1275					call storage_read_block 
1275			 
1275					; push file id to stack 
1275				 
1275					ld a, (store_page) 
1275					ld h, 0 
1275					ld l, a 
1275			 
1275					;call forth_push_numhl 
1275					; TODO store id 
1275			 
1275					push hl 
1275			 
1275					; push extent count to stack  
1275				 
1275					ld hl, store_page+3 
1275			 
1275					; get file name length 
1275			 
1275					call strlenz   
1275			 
1275					inc hl   ; cover zero term 
1275					inc hl  ; stick the id at the end of the area 
1275			 
1275					push hl 
1275					pop bc    ; move length to bc 
1275			 
1275					call malloc 
1275			 
1275					; TODO save malloc area to scratch 
1275			 
1275					ex de, hl 
1275					ld hl, (store_tmp2) 
1275					ld (hl), e 
1275					inc hl 
1275					ld (hl), d 
1275					inc hl 
1275					ld (store_tmp2), hl 
1275			 
1275					 
1275			 
1275					;pop hl   ; get source 
1275			;		ex de, hl    ; swap aronund	 
1275			 
1275					ld hl, store_page+3 
1275					if DEBUG_FORTH_WORDS 
1275						DMARK "CFd" 
1275						CALLMONITOR 
1275					endif 
1275					ldir 
1275			 
1275					; de is past string, move back one and store id 
1275					 
1275					dec de 
1275			 
1275					; store file id 
1275			 
1275					pop hl 
1275					ex de,hl 
1275					ld (hl), e 
1275			 
1275					if DEBUG_FORTH_WORDS 
1275						DMARK "Cdi" 
1275						CALLMONITOR 
1275					endif 
1275					 
1275			.dirnotfound: 
1275					pop bc     
1275					djnz .diritem 
1275				 
1275			.dirdone:	 
1275			 
1275					ld a, 0 
1275					ld hl, (store_tmp2) 
1275					ld (hl), a 
1275					inc hl 
1275					ld (hl), a 
1275					inc hl 
1275					; push a count of the dir items found 
1275			 
1275			;		ld h, 0 
1275			;		ld l, c 
1275			 
1275				ret 
1275			 
1275			endif 
1275			 
1275			 
1275			; Settings 
1275			; Run  
1275			 
1275			 
1275			 
1275			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1275			;;hd_menu2:   db "        2: Editor",0   
1275			;hd_menu2:   db "        2: Editor       6: Menu",0   
1275			;hd_menu3:   db "        3: Storage",0 
1275			;hd_menu4:   db "0=quit  4: Debug",0 
1275			;hd_don:     db "ON",0 
1275			;hd_doff:     db "OFF",0 
1275			; 
1275			; 
1275			; 
1275			;hardware_diags_old:       
1275			; 
1275			;.diagmenu: 
1275			;	call clear_display 
1275			;	ld a, display_row_1 
1275			;	ld de, hd_menu1 
1275			;	call str_at_display 
1275			; 
1275			;	ld a, display_row_2 
1275			;	ld de, hd_menu2 
1275			;	call str_at_display 
1275			; 
1275			;	ld a, display_row_3 
1275			;	ld de, hd_menu3 
1275			;	call str_at_display 
1275			; 
1275			;	ld a,  display_row_4 
1275			;	ld de, hd_menu4 
1275			;	call str_at_display 
1275			; 
1275			;	; display debug state 
1275			; 
1275			;	ld de, hd_don 
1275			;	ld a, (os_view_disable) 
1275			;	cp 0 
1275			;	jr z, .distog 
1275			;	ld de, hd_doff 
1275			;.distog: ld a, display_row_4+17 
1275			;	call str_at_display 
1275			; 
1275			;	call update_display 
1275			; 
1275			;	call cin_wait 
1275			; 
1275			; 
1275			; 
1275			;	cp '4' 
1275			;	jr nz, .diagn1 
1275			; 
1275			;	; debug toggle 
1275			; 
1275			;	ld a, (os_view_disable) 
1275			;	ld b, '*' 
1275			;	cp 0 
1275			;	jr z, .debtog 
1275			;	ld b, 0 
1275			;.debtog:	 
1275			;	ld a,b 
1275			;	ld (os_view_disable),a 
1275			; 
1275			;.diagn1: cp '0' 
1275			;	 ret z 
1275			; 
1275			;;	cp '1' 
1275			;;       jp z, matrix	 
1275			;;   TODO keyboard matrix test 
1275			; 
1275			;	cp '2' 
1275			;	jp z, .diagedit 
1275			; 
1275			;;	cp '6' 
1275			;;	jp z, .menutest 
1275			;;if ENABLE_BASIC 
1275			;;	cp '6' 
1275			;;	jp z, basic 
1275			;;endif 
1275			 ; 
1275			;	jp .diagmenu 
1275			; 
1275			; 
1275			;	ret 
1275			 
1275			 
1275			.debug_tog: 
1275 21 bc 12			ld hl, .menudebug 
1278				 
1278 3a 48 e3			ld a, (os_view_disable) 
127b fe 2a			cp '*' 
127d 20 04			jr nz,.tdon  
127f 3e 01			ld a, 1 
1281 18 02			jr .tog1 
1283 3e 00		.tdon: ld a, 0 
1285			 
1285			.tog1: 
1285 cd b1 09			call menu 
1288 fe 00			cp 0 
128a c8				ret z 
128b fe 01			cp 1    ; disable debug 
128d 28 04			jr z, .dtog0 
128f 3e 2a			ld a, '*' 
1291 18 02			jr .dtogset 
1293 3e 00		.dtog0: ld a, 0 
1295 32 48 e3		.dtogset:  ld (os_view_disable), a 
1298 c3 75 12			jp .debug_tog 
129b			 
129b			 
129b			hardware_diags:       
129b			 
129b			.diagm: 
129b 21 ae 12			ld hl, .menuitems 
129e 3e 00			ld a, 0 
12a0 cd b1 09			call menu 
12a3			 
12a3 fe 00		         cp 0 
12a5 c8				 ret z 
12a6			 
12a6 fe 02			cp 2 
12a8 ca 07 13			jp z, .diagedit 
12ab			 
12ab			;	cp '6' 
12ab			;	jp z, .menutest 
12ab			;if ENABLE_BASIC 
12ab			;	cp '6' 
12ab			;	jp z, basic 
12ab			;endif 
12ab			  
12ab c3 9b 12			jp .diagm 
12ae			 
12ae				 
12ae c2 12		.menuitems:   	dw .m1 
12b0 cd 12				dw .m2 
12b2 d4 12				dw .m3 
12b4 dc 12				dw .m5 
12b6 e2 12				dw .m5a 
12b8 eb 12				dw .m5b 
12ba 00 00				dw 0 
12bc			 
12bc			.menudebug: 
12bc f4 12				dw .m6 
12be fd 12				dw .m7 
12c0 00 00				dw 0 
12c2			 
12c2 .. 00		.m1:   db "Key Matrix",0 
12cd .. 00		.m2:   db "Editor",0 
12d4 .. 00		.m3:   db "Storage",0 
12dc .. 00		.m5:   db "Sound",0 
12e2 .. 00		.m5a:  db "RAM Test",0 
12eb .. 00		.m5b:  db "LCD Test",0 
12f4			 
12f4 .. 00		.m6:   db "Debug ON",0 
12fd .. 00		.m7:   db "Debug OFF",0 
1307			 
1307			; debug editor 
1307			 
1307			.diagedit: 
1307			 
1307 21 57 e3			ld hl, scratch 
130a			;	ld bc, 250 
130a			;	ldir 
130a				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
130a 3e 00			ld a, 0 
130c 77				ld (hl), a 
130d 23				inc hl 
130e 77				ld (hl), a 
130f 23				inc hl 
1310 77				ld (hl), a 
1311			 
1311 cd 80 09		        call clear_display 
1314 cd a3 09			call update_display 
1317				;ld a, 1 
1317				;ld (hardware_diag), a 
1317			.diloop: 
1317 3e 00			ld a, display_row_1 
1319 0e 00			ld c, 0 
131b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
131d 1e 28			ld e, 40 
131f			 
131f 21 57 e3			ld hl, scratch	 
1322 cd da 0b			call input_str 
1325			 
1325 3e 28			ld a, display_row_2 
1327 11 57 e3			ld de, scratch 
132a cd 93 09			call str_at_display 
132d cd a3 09			call update_display 
1330			 
1330 c3 17 13			jp .diloop 
1333			 
1333			 
1333			; pass word in hl 
1333			; a has display location 
1333			display_word_at: 
1333 f5				push af 
1334 e5				push hl 
1335 7c				ld a,h 
1336 21 5c e6			ld hl, os_word_scratch 
1339 cd ae 0e			call hexout 
133c e1				pop hl 
133d 7d				ld a,l 
133e 21 5e e6			ld hl, os_word_scratch+2 
1341 cd ae 0e			call hexout 
1344 21 60 e6			ld hl, os_word_scratch+4 
1347 3e 00			ld a,0 
1349 77				ld (hl),a 
134a 11 5c e6			ld de,os_word_scratch 
134d f1				pop af 
134e cd 93 09				call str_at_display 
1351 c9				ret 
1352			 
1352			display_ptr_state: 
1352			 
1352				; to restore afterwards 
1352			 
1352 d5				push de 
1353 c5				push bc 
1354 e5				push hl 
1355 f5				push af 
1356			 
1356				; for use in here 
1356			 
1356			;	push bc 
1356			;	push de 
1356			;	push hl 
1356			;	push af 
1356			 
1356 cd 80 09			call clear_display 
1359			 
1359 11 2c 15			ld de, .ptrstate 
135c 3e 00			ld a, display_row_1 
135e cd 93 09			call str_at_display 
1361			 
1361				; display debug step 
1361			 
1361			 
1361 11 71 ee			ld de, debug_mark 
1364 3e 26			ld a, display_row_1+display_cols-2 
1366 cd 93 09			call str_at_display 
1369			 
1369				; display a 
1369 11 36 15			ld de, .ptrcliptr 
136c 3e 28			ld a, display_row_2 
136e cd 93 09			call str_at_display 
1371			 
1371 f1				pop af 
1372 2a 22 eb			ld hl,(cli_ptr) 
1375 3e 30			ld a, display_row_2+8 
1377 cd 33 13			call display_word_at 
137a			 
137a			 
137a				; display hl 
137a			 
137a			 
137a 11 3e 15			ld de, .ptrclioptr 
137d 3e 32			ld a, display_row_2+10 
137f cd 93 09			call str_at_display 
1382			; 
1382			;	pop hl 
1382 3e 35			ld a, display_row_2+13 
1384 2a 20 eb			ld hl,(cli_origptr) 
1387 cd 33 13			call display_word_at 
138a			; 
138a			;	 
138a			;	; display de 
138a			 
138a			;	ld de, .regstatede 
138a			;	ld a, display_row_3 
138a			;	call str_at_display 
138a			 
138a			;	pop de 
138a			;	ld h,d 
138a			;	ld l, e 
138a			;	ld a, display_row_3+3 
138a			;	call display_word_at 
138a			 
138a			 
138a				; display bc 
138a			 
138a			;	ld de, .regstatebc 
138a			;	ld a, display_row_3+10 
138a			;	call str_at_display 
138a			 
138a			;	pop bc 
138a			;	ld h,b 
138a			;	ld l, c 
138a			;	ld a, display_row_3+13 
138a			;	call display_word_at 
138a			 
138a			 
138a				; display dsp 
138a			 
138a			;	ld de, .regstatedsp 
138a			;	ld a, display_row_4 
138a			;	call str_at_display 
138a			 
138a				 
138a			;	ld hl,(cli_data_sp) 
138a			;	ld a, display_row_4+4 
138a			;	call display_word_at 
138a			 
138a				; display rsp 
138a			 
138a 11 6d 15			ld de, .regstatersp 
138d 3e 82			ld a, display_row_4+10 
138f cd 93 09			call str_at_display 
1392			 
1392				 
1392 2a 08 eb			ld hl,(cli_ret_sp) 
1395 3e 86			ld a, display_row_4+14 
1397 cd 33 13			call display_word_at 
139a			 
139a cd a3 09			call update_display 
139d			 
139d cd f2 08			call delay1s 
13a0 cd f2 08			call delay1s 
13a3 cd f2 08			call delay1s 
13a6			 
13a6			 
13a6 cd 80 19			call next_page_prompt 
13a9			 
13a9				; restore  
13a9			 
13a9 f1				pop af 
13aa e1				pop hl 
13ab c1				pop bc 
13ac d1				pop de 
13ad c9				ret 
13ae			 
13ae			break_point_state: 
13ae f5				push af 
13af			 
13af				; see if disabled 
13af			 
13af 3a 48 e3			ld a, (os_view_disable) 
13b2 fe 2a			cp '*' 
13b4 20 02			jr nz, .bpsgo 
13b6 f1				pop af 
13b7 c9				ret 
13b8			 
13b8			.bpsgo: 
13b8 f1				pop af 
13b9 f5				push af 
13ba 22 44 e3			ld (os_view_hl), hl 
13bd ed 53 42 e3		ld (os_view_de), de 
13c1 ed 43 40 e3		ld (os_view_bc), bc 
13c5 e5				push hl 
13c6 6f				ld l, a 
13c7 26 00			ld h, 0 
13c9 22 46 e3			ld (os_view_af),hl 
13cc			 
13cc 21 b7 ed				ld hl, display_fb0 
13cf 22 d2 eb				ld (display_fb_active), hl 
13d2 e1				pop hl	 
13d3			 
13d3 3e 31			ld a, '1' 
13d5 fe 2a		.bps1:  cp '*' 
13d7 20 03			jr nz, .bps1b 
13d9 32 48 e3			ld (os_view_disable),a 
13dc fe 31		.bps1b:  cp '1' 
13de 20 14			jr nz, .bps2 
13e0			 
13e0				; display reg 
13e0			 
13e0				 
13e0			 
13e0 3a 46 e3			ld a, (os_view_af) 
13e3 2a 44 e3			ld hl, (os_view_hl) 
13e6 ed 5b 42 e3		ld de, (os_view_de) 
13ea ed 4b 40 e3		ld bc, (os_view_bc) 
13ee cd 88 14			call display_reg_state 
13f1 c3 74 14			jp .bpschk 
13f4			 
13f4 fe 32		.bps2:  cp '2' 
13f6 20 08			jr nz, .bps3 
13f8				 
13f8				; display hl 
13f8 2a 44 e3			ld hl, (os_view_hl) 
13fb cd 72 15			call display_dump_at_hl 
13fe			 
13fe 18 74			jr .bpschk 
1400			 
1400 fe 33		.bps3:  cp '3' 
1402 20 08			jr nz, .bps4 
1404			 
1404			        ; display de 
1404 2a 42 e3			ld hl, (os_view_de) 
1407 cd 72 15			call display_dump_at_hl 
140a			 
140a 18 68			jr .bpschk 
140c fe 34		.bps4:  cp '4' 
140e 20 08			jr nz, .bps5 
1410			 
1410			        ; display bc 
1410 2a 40 e3			ld hl, (os_view_bc) 
1413 cd 72 15			call display_dump_at_hl 
1416			 
1416 18 5c			jr .bpschk 
1418 fe 35		.bps5:  cp '5' 
141a 20 08		        jr nz, .bps7 
141c			 
141c				; display cur ptr 
141c 2a 22 eb			ld hl, (cli_ptr) 
141f cd 72 15			call display_dump_at_hl 
1422			 
1422 18 50			jr .bpschk 
1424 fe 36		.bps7:  cp '6' 
1426 20 08			jr nz, .bps8b 
1428				 
1428				; display cur orig ptr 
1428 2a 20 eb			ld hl, (cli_origptr) 
142b cd 72 15			call display_dump_at_hl 
142e 18 44			jr .bpschk 
1430 fe 37		.bps8b:  cp '7' 
1432 20 08			jr nz, .bps9 
1434				 
1434				; display dsp 
1434 2a 04 eb			ld hl, (cli_data_sp) 
1437 cd 72 15			call display_dump_at_hl 
143a			 
143a 18 38			jr .bpschk 
143c fe 39		.bps9:  cp '9' 
143e 20 05			jr nz, .bps8c 
1440				 
1440				; display SP 
1440			;	ld hl, sp 
1440 cd 72 15			call display_dump_at_hl 
1443			 
1443 18 2f			jr .bpschk 
1445 fe 38		.bps8c:  cp '8' 
1447 20 08			jr nz, .bps8d 
1449				 
1449				; display rsp 
1449 2a 08 eb			ld hl, (cli_ret_sp) 
144c cd 72 15			call display_dump_at_hl 
144f			 
144f 18 23			jr .bpschk 
1451 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1453 20 05			jr nz, .bps8 
1455 cd 76 17			call monitor 
1458			 
1458 18 1a			jr .bpschk 
145a fe 30		.bps8:  cp '0' 
145c 20 16			jr nz, .bpschk 
145e			 
145e 21 16 ed				ld hl, display_fb1 
1461 22 d2 eb				ld (display_fb_active), hl 
1464 cd a3 09				call update_display 
1467			 
1467				;ld a, (os_view_af) 
1467 2a 44 e3			ld hl, (os_view_hl) 
146a ed 5b 42 e3		ld de, (os_view_de) 
146e ed 4b 40 e3		ld bc, (os_view_bc) 
1472 f1				pop af 
1473 c9				ret 
1474			 
1474			.bpschk:   
1474 cd f2 08			call delay1s 
1477 3e 9f		ld a,display_row_4 + display_cols - 1 
1479 11 7e 19		        ld de, endprg 
147c cd 93 09			call str_at_display 
147f cd a3 09			call update_display 
1482 cd 25 59			call cin_wait 
1485			 
1485 c3 d5 13			jp .bps1 
1488			 
1488			 
1488			display_reg_state: 
1488			 
1488				; to restore afterwards 
1488			 
1488 d5				push de 
1489 c5				push bc 
148a e5				push hl 
148b f5				push af 
148c			 
148c				; for use in here 
148c			 
148c c5				push bc 
148d d5				push de 
148e e5				push hl 
148f f5				push af 
1490			 
1490 cd 80 09			call clear_display 
1493			 
1493 11 48 15			ld de, .regstate 
1496 3e 00			ld a, display_row_1 
1498 cd 93 09			call str_at_display 
149b			 
149b				; display debug step 
149b			 
149b			 
149b 11 71 ee			ld de, debug_mark 
149e 3e 25			ld a, display_row_1+display_cols-3 
14a0 cd 93 09			call str_at_display 
14a3			 
14a3				; display a 
14a3 11 64 15			ld de, .regstatea 
14a6 3e 28			ld a, display_row_2 
14a8 cd 93 09			call str_at_display 
14ab			 
14ab e1				pop hl 
14ac			;	ld h,0 
14ac			;	ld l, a 
14ac 3e 2b			ld a, display_row_2+3 
14ae cd 33 13			call display_word_at 
14b1			 
14b1			 
14b1				; display hl 
14b1			 
14b1			 
14b1 11 58 15			ld de, .regstatehl 
14b4 3e 32			ld a, display_row_2+10 
14b6 cd 93 09			call str_at_display 
14b9			 
14b9 e1				pop hl 
14ba 3e 35			ld a, display_row_2+13 
14bc cd 33 13			call display_word_at 
14bf			 
14bf				 
14bf				; display de 
14bf			 
14bf 11 5c 15			ld de, .regstatede 
14c2 3e 50			ld a, display_row_3 
14c4 cd 93 09			call str_at_display 
14c7			 
14c7 e1				pop hl 
14c8			;	ld h,d 
14c8			;	ld l, e 
14c8 3e 53			ld a, display_row_3+3 
14ca cd 33 13			call display_word_at 
14cd			 
14cd			 
14cd				; display bc 
14cd			 
14cd 11 60 15			ld de, .regstatebc 
14d0 3e 5a			ld a, display_row_3+10 
14d2 cd 93 09			call str_at_display 
14d5			 
14d5 e1				pop hl 
14d6			;	ld h,b 
14d6			;	ld l, c 
14d6 3e 5d			ld a, display_row_3+13 
14d8 cd 33 13			call display_word_at 
14db			 
14db			 
14db				; display dsp 
14db			 
14db 11 68 15			ld de, .regstatedsp 
14de 3e 78			ld a, display_row_4 
14e0 cd 93 09			call str_at_display 
14e3			 
14e3				 
14e3 2a 04 eb			ld hl,(cli_data_sp) 
14e6 3e 7c			ld a, display_row_4+4 
14e8 cd 33 13			call display_word_at 
14eb			 
14eb				; display rsp 
14eb			 
14eb 11 6d 15			ld de, .regstatersp 
14ee 3e 82			ld a, display_row_4+10 
14f0 cd 93 09			call str_at_display 
14f3			 
14f3				 
14f3 2a 08 eb			ld hl,(cli_ret_sp) 
14f6 3e 86			ld a, display_row_4+14 
14f8 cd 33 13			call display_word_at 
14fb			 
14fb cd a3 09			call update_display 
14fe			 
14fe			;	call delay1s 
14fe			;	call delay1s 
14fe			;	call delay1s 
14fe			 
14fe			 
14fe			;	call next_page_prompt 
14fe			 
14fe				; restore  
14fe			 
14fe f1				pop af 
14ff e1				pop hl 
1500 c1				pop bc 
1501 d1				pop de 
1502 c9				ret 
1503			 
1503 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1517 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
152c .. 00		.ptrstate:	db "Ptr State",0 
1536 .. 00		.ptrcliptr:     db "cli_ptr",0 
153e .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1548 .. 00		.regstate:	db "Reg State (1/0)",0 
1558 .. 00		.regstatehl:	db "HL:",0 
155c .. 00		.regstatede:	db "DE:",0 
1560 .. 00		.regstatebc:	db "BC:",0 
1564 .. 00		.regstatea:	db "A :",0 
1568 .. 00		.regstatedsp:	db "DSP:",0 
156d .. 00		.regstatersp:	db "RSP:",0 
1572			 
1572			display_dump_at_hl: 
1572 e5				push hl 
1573 d5				push de 
1574 c5				push bc 
1575 f5				push af 
1576			 
1576 22 7a e6			ld (os_cur_ptr),hl	 
1579 cd 80 09			call clear_display 
157c cd 88 18			call dumpcont 
157f			;	call delay1s 
157f			;	call next_page_prompt 
157f			 
157f			 
157f f1				pop af 
1580 c1				pop bc 
1581 d1				pop de 
1582 e1				pop hl 
1583 c9				ret 
1584			 
1584			;if ENABLE_BASIC 
1584			;	include "nascombasic.asm" 
1584			;	basic: 
1584			;	include "forth/FORTH.ASM" 
1584			;endif 
1584			 
1584			; eof 
1584			 
1584			 
# End of file firmware_diags.asm
1584			  
1584			include "firmware_prompts.asm"  
1584			; Prompts  
1584			 
1584			; boot messages 
1584			 
1584 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.5",0 
1599 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
15a9			 
15a9			 
15a9			; config menus 
15a9			 
15a9 .. 00		prom_c3: db "Add Dictionary To File",0 
15c0 .. 00		prom_c2: db "Select Autoload File",0 
15d5 .. 00		prom_c2a: db "Disable Autoload File", 0 
15eb .. 00		prom_c2b: db "Select Storage Bank",0 
15ff .. 00		prom_c4: db "Settings",0 
1608 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1623 .. 00		prom_m4b:   db "Monitor",0 
162b .. 00		prom_c1: db "Hardware Diags",0 
163a			 
163a			 
163a .. 00		prom_notav:    db "Feature not available",0 
1650 .. 00		prom_empty:    db "",0 
1651			 
1651			; eof 
1651			 
# End of file firmware_prompts.asm
1651			  
1651			  
1651			; eof  
1651			  
# End of file firmware.asm
1651			 
1651			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1651			;if BASE_KEV  
1651			;baseram: equ 08000h 
1651			;endif 
1651			 
1651			;if BASE_SC114 
1651			;baseram:     equ    endofcode 
1651			;endif 
1651			 
1651			 
1651			; start system 
1651			 
1651			coldstart: 
1651				; set sp 
1651				; di/ei 
1651			 
1651 f3				di 
1652 31 00 f0			ld sp, tos 
1655			;	ei 
1655			 
1655			 
1655				; disable breakpoint by default 
1655			 
1655 3e 2a			ld a,'*' 
1657 32 48 e3			ld (os_view_disable),a 
165a			 
165a				; init hardware 
165a			 
165a				; init keyboard and screen hardware 
165a			 
165a cd 03 01			call hardware_init 
165d			 
165d			 
165d				; detect if any keys are held down to enable breakpoints at start up 
165d			 
165d cd 2d 59			call cin  
1660 fe 00			cp 0 
1662 28 03			jr z, .nokeys 
1664			 
1664				;call hardware_diags 
1664 cd 0d 12			call config 
1667			 
1667			;	ld de, .bpen 
1667			;	ld a, display_row_4 
1667			;	call str_at_display 
1667			;	call update_display 
1667			; 
1667			;	ld a,0 
1667			;	ld (os_view_disable),a 
1667			; 
1667			;.bpwait: 
1667			;	call cin 
1667			;	cp 0 
1667			;	jr z, .bpwait 
1667			;	jr .nokeys 
1667			; 
1667			; 
1667			;.bpen:  db "Break points enabled!",0 
1667			 
1667			 
1667			 
1667			 
1667			 
1667			 
1667			.nokeys: 
1667			 
1667			 
1667				 
1667			 
1667			;jp  testkey 
1667			 
1667			;call storage_get_block_0 
1667			; 
1667			;ld hl, 0 
1667			;ld de, store_page 
1667			;call storage_read_block 
1667			 
1667				 
1667			;ld hl, 10 
1667			;ld de, store_page 
1667			;call storage_read_block 
1667			 
1667			 
1667			 
1667			 
1667			 
1667			;stop:	nop 
1667			;	jp stop 
1667			 
1667			 
1667			 
1667			main: 
1667 cd 80 09			call clear_display 
166a cd a3 09			call update_display 
166d			 
166d			 
166d			 
166d			;	call testlcd 
166d			 
166d			 
166d			 
166d cd 46 1d			call forth_init 
1670			 
1670			 
1670			warmstart: 
1670 cd 1c 1d			call forth_warmstart 
1673			 
1673				; run startup word load 
1673			        ; TODO prevent this running at warmstart after crash  
1673			 
1673				if STARTUP_ENABLE 
1673					if STORAGE_SE 
1673						call forth_autoload 
1673					endif 
1673 cd 73 55				call forth_startup 
1676			 
1676			 
1676				endif 
1676			 
1676				; show free memory after boot 
1676 11 10 17			ld de, freeram 
1679 3e 00			ld a, display_row_1 
167b cd 93 09			call str_at_display 
167e			 
167e			; Or use heap_size word???? 
167e 21 3d e3			ld hl, heap_end 
1681 11 55 59			ld de, heap_start 
1684 ed 52			sbc hl, de 
1686 e5				push hl 
1687 7c				ld a,h	         	 
1688 21 5c e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
168b cd ae 0e			call hexout 
168e e1			   	pop hl 
168f			 
168f 7d				ld a,l 
1690 21 5e e6			ld hl, os_word_scratch+2 
1693 cd ae 0e			call hexout 
1696 21 60 e6			ld hl, os_word_scratch+4 
1699 3e 00			ld a, 0 
169b 77				ld (hl),a 
169c 11 5c e6			ld de, os_word_scratch 
169f 3e 0d			ld a, display_row_1 + 13 
16a1 cd 93 09			call str_at_display 
16a4 cd a3 09			call update_display 
16a7			 
16a7			 
16a7				;call demo 
16a7			 
16a7			 
16a7				; init scratch input area for cli commands 
16a7			 
16a7 21 7e e6			ld hl, os_cli_cmd 
16aa 3e 00			ld a,0 
16ac 77				ld (hl),a 
16ad 23				inc hl 
16ae 77				ld (hl),a 
16af			 
16af 3e 00			ld a,0 
16b1 32 7d e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
16b4			 
16b4 32 7a e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
16b7 32 7b e6			ld (os_cur_ptr+1),a	 
16ba			 
16ba 32 5c e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
16bd 32 5d e6			ld (os_word_scratch+1),a	 
16c0				 
16c0			 
16c0				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16c0 21 7e e6			ld hl, os_cli_cmd 
16c3			 
16c3 3e 00			ld a, 0		 ; init cli input 
16c5 77				ld (hl), a 
16c6 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
16c8			cli: 
16c8				; show cli prompt 
16c8				;push af 
16c8				;ld a, 0 
16c8				;ld de, prompt 
16c8				;call str_at_display 
16c8			 
16c8				;call update_display 
16c8				;pop af 
16c8				;inc a 
16c8				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
16c8 0e 00			ld c, 0 
16ca 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16cc 1e 28			ld e, 40 
16ce			 
16ce 21 7e e6			ld hl, os_cli_cmd 
16d1			 
16d1				STACKFRAME OFF $fefe $9f9f 
16d1				if DEBUG_STACK_IMB 
16d1					if OFF 
16d1						exx 
16d1						ld de, $fefe 
16d1						ld a, d 
16d1						ld hl, curframe 
16d1						call hexout 
16d1						ld a, e 
16d1						ld hl, curframe+2 
16d1						call hexout 
16d1						ld hl, $fefe 
16d1						push hl 
16d1						ld hl, $9f9f 
16d1						push hl 
16d1						exx 
16d1					endif 
16d1				endif 
16d1			endm 
# End of macro STACKFRAME
16d1			 
16d1 cd da 0b			call input_str 
16d4			 
16d4				STACKFRAMECHK OFF $fefe $9f9f 
16d4				if DEBUG_STACK_IMB 
16d4					if OFF 
16d4						exx 
16d4						ld hl, $9f9f 
16d4						pop de   ; $9f9f 
16d4						call cmp16 
16d4						jr nz, .spnosame 
16d4						ld hl, $fefe 
16d4						pop de   ; $fefe 
16d4						call cmp16 
16d4						jr z, .spfrsame 
16d4						.spnosame: call showsperror 
16d4						.spfrsame: nop 
16d4						exx 
16d4					endif 
16d4				endif 
16d4			endm 
# End of macro STACKFRAMECHK
16d4			 
16d4				; copy input to last command 
16d4			 
16d4 21 7e e6			ld hl, os_cli_cmd 
16d7 11 7d e7			ld de, os_last_cmd 
16da 01 ff 00			ld bc, 255 
16dd ed b0			ldir 
16df			 
16df				; wipe current buffer 
16df			 
16df			;	ld a, 0 
16df			;	ld hl, os_cli_cmd 
16df			;	ld de, os_cli_cmd+1 
16df			;	ld bc, 254 
16df			;	ldir 
16df				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16df			;	call strcpy 
16df			;	ld a, 0 
16df			;	ld (hl), a 
16df			;	inc hl 
16df			;	ld (hl), a 
16df			;	inc hl 
16df			;	ld (hl), a 
16df			 
16df				; switch frame buffer to program  
16df			 
16df 21 16 ed				ld hl, display_fb1 
16e2 22 d2 eb				ld (display_fb_active), hl 
16e5			 
16e5			;	nop 
16e5				STACKFRAME ON $fbfe $8f9f 
16e5				if DEBUG_STACK_IMB 
16e5					if ON 
16e5						exx 
16e5						ld de, $fbfe 
16e5						ld a, d 
16e5						ld hl, curframe 
16e5						call hexout 
16e5						ld a, e 
16e5						ld hl, curframe+2 
16e5						call hexout 
16e5						ld hl, $fbfe 
16e5						push hl 
16e5						ld hl, $8f9f 
16e5						push hl 
16e5						exx 
16e5					endif 
16e5				endif 
16e5			endm 
# End of macro STACKFRAME
16e5				; first time into the parser so pass over the current scratch pad 
16e5 21 7e e6			ld hl,os_cli_cmd 
16e8				; tokenise the entered statement(s) in HL 
16e8 cd bf 1d			call forthparse 
16eb			        ; exec forth statements in top of return stack 
16eb cd ff 1d			call forthexec 
16ee				;call forthexec_cleanup 
16ee			;	call parsenext 
16ee			 
16ee				STACKFRAMECHK ON $fbfe $8f9f 
16ee				if DEBUG_STACK_IMB 
16ee					if ON 
16ee						exx 
16ee						ld hl, $8f9f 
16ee						pop de   ; $8f9f 
16ee						call cmp16 
16ee						jr nz, .spnosame 
16ee						ld hl, $fbfe 
16ee						pop de   ; $fbfe 
16ee						call cmp16 
16ee						jr z, .spfrsame 
16ee						.spnosame: call showsperror 
16ee						.spfrsame: nop 
16ee						exx 
16ee					endif 
16ee				endif 
16ee			endm 
# End of macro STACKFRAMECHK
16ee				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
16ee			 
16ee 3e 78			ld a, display_row_4 
16f0 11 22 17			ld de, endprog 
16f3			 
16f3 cd a3 09			call update_display		 
16f6			 
16f6 cd 80 19			call next_page_prompt 
16f9			 
16f9				; switch frame buffer to cli 
16f9			 
16f9 21 b7 ed				ld hl, display_fb0 
16fc 22 d2 eb				ld (display_fb_active), hl 
16ff			 
16ff			 
16ff cd 80 09		        call clear_display 
1702 cd a3 09			call update_display		 
1705			 
1705 21 7e e6			ld hl, os_cli_cmd 
1708			 
1708 3e 00			ld a, 0		 ; init cli input 
170a 77				ld (hl), a 
170b			 
170b				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
170b			 
170b				; now on last line 
170b			 
170b				; TODO scroll screen up 
170b			 
170b				; TODO instead just clear screen and place at top of screen 
170b			 
170b			;	ld a, 0 
170b			;	ld (f_cursor_ptr),a 
170b			 
170b				;call clear_display 
170b				;call update_display 
170b			 
170b				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
170b 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
170d c3 c8 16			jp cli 
1710			 
1710 .. 00		freeram: db "Free bytes: $",0 
171e ..			asc: db "1A2F" 
1722 .. 00		endprog: db "End prog...",0 
172e			 
172e			testenter2:   
172e 21 89 e3			ld hl,scratch+50 
1731 22 7a e6			ld (os_cur_ptr),hl 
1734 c3 c8 16			jp cli 
1737			 
1737			testenter:  
1737			 
1737 21 1e 17			ld hl,asc 
173a			;	ld a,(hl) 
173a			;	call nibble2val 
173a cd 04 0f			call get_byte 
173d			 
173d			 
173d			;	ld a,(hl) 
173d			;	call atohex 
173d			 
173d			;	call fourehexhl 
173d 32 89 e3			ld (scratch+50),a 
1740			 
1740			 
1740			 
1740 21 20 17			ld hl,asc+2 
1743			;	ld a, (hl) 
1743			;	call nibble2val 
1743 cd 04 0f			call get_byte 
1746			 
1746			;	call fourehexhl 
1746 32 8b e3			ld (scratch+52),a 
1749				 
1749 21 89 e3			ld hl,scratch+50 
174c 22 7a e6			ld (os_cur_ptr),hl 
174f c3 c8 16			jp cli 
1752			 
1752			enter:	 
1752 3a 5b e3			ld a,(scratch+4) 
1755 fe 00			cp 0 
1757 28 0c			jr z, .entercont 
1759				; no, not a null term line so has an address to work out.... 
1759			 
1759 21 59 e3			ld hl,scratch+2 
175c cd 64 0f			call get_word_hl 
175f			 
175f 22 7a e6			ld (os_cur_ptr),hl	 
1762 c3 c8 16			jp cli 
1765			 
1765			 
1765			.entercont:  
1765			 
1765 21 59 e3			ld hl, scratch+2 
1768 cd 04 0f			call get_byte 
176b			 
176b 2a 7a e6		   	ld hl,(os_cur_ptr) 
176e 77					ld (hl),a 
176f 23					inc hl 
1770 22 7a e6				ld (os_cur_ptr),hl 
1773				 
1773			; get byte  
1773			 
1773			 
1773 c3 c8 16			jp cli 
1776			 
1776			 
1776			; basic monitor support 
1776			 
1776			monitor: 
1776				;  
1776 cd 80 09			call clear_display 
1779 3e 00			ld a, 0 
177b 11 c3 17			ld de, .monprompt 
177e cd 93 09			call str_at_display 
1781 cd a3 09			call update_display 
1784			 
1784				; get a monitor command 
1784			 
1784 0e 00			ld c, 0     ; entry at top left 
1786 16 64			ld d, 100   ; max buffer size 
1788 1e 0f			ld e, 15    ; input scroll area 
178a 3e 00			ld a, 0     ; init string 
178c 21 55 e5			ld hl, os_input 
178f 77				ld (hl), a 
1790 23				inc hl 
1791 77				ld (hl), a 
1792 21 55 e5			ld hl, os_input 
1795 3e 01			ld a, 1     ; init string 
1797 cd da 0b			call input_str 
179a			 
179a cd 80 09		        call clear_display 
179d cd a3 09			call update_display		 
17a0			 
17a0 3a 55 e5			ld a, (os_input) 
17a3 cd 02 10			call toUpper 
17a6 fe 48		        cp 'H' 
17a8 28 6f		        jr z, .monhelp 
17aa fe 44			cp 'D'		; dump 
17ac ca 3a 18			jp z, .mondump	 
17af fe 43			cp 'C'		; dump 
17b1 ca 54 18			jp z, .moncdump	 
17b4 fe 4d			cp 'M'		; dump 
17b6 ca c5 17			jp z, .moneditstart 
17b9 fe 55			cp 'U'		; dump 
17bb 28 14			jr z, .monedit	 
17bd fe 51			cp 'Q'		; dump 
17bf c8				ret z	 
17c0			 
17c0			 
17c0				; TODO "S" to access symbol by name and not need the address 
17c0				; TODO "F" to find a string in memory 
17c0			 
17c0 c3 76 17			jp monitor 
17c3			 
17c3 .. 00		.monprompt: db ">", 0 
17c5			 
17c5			.moneditstart: 
17c5				; get starting address 
17c5			 
17c5 21 57 e5			ld hl,os_input+2 
17c8 cd 64 0f			call get_word_hl 
17cb			 
17cb 22 7a e6			ld (os_cur_ptr),hl	 
17ce			 
17ce c3 76 17			jp monitor 
17d1			 
17d1			.monedit: 
17d1				; get byte to load 
17d1			 
17d1 21 57 e5			ld hl,os_input+2 
17d4 cd 04 0f			call get_byte 
17d7			 
17d7				; get address to update 
17d7 2a 7a e6			ld hl, (os_cur_ptr) 
17da			 
17da				; update byte 
17da			 
17da 77				ld (hl), a 
17db			 
17db				; move to next address and save it 
17db			 
17db 23				inc hl 
17dc 22 7a e6			ld (os_cur_ptr),hl	 
17df			 
17df c3 76 17			jp monitor 
17e2			 
17e2			 
17e2 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
17f6 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1812 .. 00		.monhelptext3:  db "Q-Quit",0 
1819			        
1819			.monhelp: 
1819 3e 00			ld a, display_row_1 
181b 11 e2 17		        ld de, .monhelptext1 
181e			 
181e cd 93 09			call str_at_display 
1821 3e 28			ld a, display_row_2 
1823 11 f6 17		        ld de, .monhelptext2 
1826					 
1826 cd 93 09			call str_at_display 
1829 3e 50			ld a, display_row_3 
182b 11 12 18		        ld de, .monhelptext3 
182e					 
182e cd 93 09			call str_at_display 
1831 cd a3 09			call update_display		 
1834			 
1834 cd 80 19			call next_page_prompt 
1837 c3 76 17			jp monitor 
183a			 
183a			.mondump:    
183a 21 57 e5			ld hl,os_input+2 
183d cd 64 0f			call get_word_hl 
1840			 
1840 22 7a e6			ld (os_cur_ptr),hl	 
1843 cd 88 18			call dumpcont 
1846 3e 78			ld a, display_row_4 
1848 11 22 17			ld de, endprog 
184b			 
184b cd a3 09			call update_display		 
184e			 
184e cd 80 19			call next_page_prompt 
1851 c3 76 17			jp monitor 
1854			.moncdump: 
1854 cd 88 18			call dumpcont 
1857 3e 78			ld a, display_row_4 
1859 11 22 17			ld de, endprog 
185c			 
185c cd a3 09			call update_display		 
185f			 
185f cd 80 19			call next_page_prompt 
1862 c3 76 17			jp monitor 
1865			 
1865			 
1865			; TODO symbol access  
1865			 
1865			.symbols:     ;; A list of symbols that can be called up  
1865 b7 ed			dw display_fb0 
1867 .. 00			db "fb0",0  
186b 5c eb		     	dw store_page 
186d .. 00			db "store_page",0 
1878			 
1878			 
1878			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1878			 
1878 3a 58 e3			ld a,(scratch+1) 
187b fe 00			cp 0 
187d 28 09			jr z, dumpcont 
187f			 
187f				; no, not a null term line so has an address to work out.... 
187f			 
187f 21 59 e3			ld hl,scratch+2 
1882 cd 64 0f			call get_word_hl 
1885			 
1885 22 7a e6			ld (os_cur_ptr),hl	 
1888			 
1888			 
1888			 
1888			dumpcont: 
1888			 
1888				; dump bytes at ptr 
1888			 
1888			 
1888 3e 00			ld a, display_row_1 
188a 2a d2 eb			ld hl, (display_fb_active) 
188d cd ad 0b			call addatohl 
1890 cd b8 18			call .dumpbyterow 
1893			 
1893 3e 28			ld a, display_row_2 
1895 2a d2 eb			ld hl, (display_fb_active) 
1898 cd ad 0b			call addatohl 
189b cd b8 18			call .dumpbyterow 
189e			 
189e			 
189e 3e 50			ld a, display_row_3 
18a0 2a d2 eb			ld hl, (display_fb_active) 
18a3 cd ad 0b			call addatohl 
18a6 cd b8 18			call .dumpbyterow 
18a9			 
18a9 3e 78			ld a, display_row_4 
18ab 2a d2 eb			ld hl, (display_fb_active) 
18ae cd ad 0b			call addatohl 
18b1 cd b8 18			call .dumpbyterow 
18b4			 
18b4 cd a3 09			call update_display 
18b7			;		jp cli 
18b7 c9				ret 
18b8			 
18b8			.dumpbyterow: 
18b8			 
18b8				;push af 
18b8			 
18b8 e5				push hl 
18b9			 
18b9				; calc where to poke the ascii 
18b9			if display_cols == 20 
18b9				ld a, 16 
18b9			else 
18b9 3e 1f			ld a, 31 
18bb			endif 
18bb			 
18bb cd ad 0b			call addatohl 
18be 22 5c e6			ld (os_word_scratch),hl  		; save pos for later 
18c1			 
18c1			 
18c1			; display decoding address 
18c1 2a 7a e6		   	ld hl,(os_cur_ptr) 
18c4			 
18c4 7c				ld a,h 
18c5 e1				pop hl 
18c6 e5				push hl 
18c7			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18c7 cd ae 0e			call hexout 
18ca 2a 7a e6		   	ld hl,(os_cur_ptr) 
18cd			 
18cd 7d				ld a,l 
18ce e1				pop hl 
18cf 23				inc hl 
18d0 23				inc hl 
18d1 e5				push hl 
18d2			;	ld hl, os_word_scratch+2 
18d2 cd ae 0e			call hexout 
18d5 e1				pop hl 
18d6 23				inc hl 
18d7 23				inc hl 
18d8				;ld hl, os_word_scratch+4 
18d8 3e 3a			ld a, ':' 
18da 77				ld (hl),a 
18db 23				inc hl 
18dc				;ld a, 0 
18dc				;ld (hl),a 
18dc				;ld de, os_word_scratch 
18dc				;pop af 
18dc				;push af 
18dc			;		ld a, display_row_2 
18dc			;		call str_at_display 
18dc			;		call update_display 
18dc			 
18dc			 
18dc			;pop af 
18dc			;	add 5 
18dc			 
18dc			if display_cols == 20 
18dc				ld b, 4 
18dc			else 
18dc 06 08			ld b, 8 
18de			endif	 
18de			 
18de			.dumpbyte: 
18de c5				push bc 
18df e5				push hl 
18e0			 
18e0			 
18e0 2a 7a e6		   	ld hl,(os_cur_ptr) 
18e3 7e					ld a,(hl) 
18e4			 
18e4					; poke the ascii to display 
18e4 2a 5c e6				ld hl,(os_word_scratch) 
18e7 77					ld (hl),a 
18e8 23					inc hl 
18e9 22 5c e6				ld (os_word_scratch),hl 
18ec			 
18ec					 
18ec			 
18ec			 
18ec e1					pop hl 
18ed e5					push hl 
18ee			 
18ee cd ae 0e				call hexout 
18f1			 
18f1					 
18f1 2a 7a e6		   	ld hl,(os_cur_ptr) 
18f4 23				inc hl 
18f5 22 7a e6		   	ld (os_cur_ptr),hl 
18f8			 
18f8 e1					pop hl 
18f9 23					inc hl 
18fa 23					inc hl 
18fb 23					inc hl 
18fc			 
18fc			 
18fc			 
18fc					;ld a,0 
18fc					;ld (os_word_scratch+2),a 
18fc					;pop af 
18fc					;push af 
18fc			 
18fc					;ld de, os_word_scratch 
18fc					;call str_at_display 
18fc			;		call update_display 
18fc			;		pop af 
18fc c1					pop bc 
18fd c6 03				add 3 
18ff 10 dd			djnz .dumpbyte 
1901			 
1901				 
1901			 
1901 c9				ret 
1902			 
1902			jump:	 
1902			 
1902 21 59 e3			ld hl,scratch+2 
1905 cd 64 0f			call get_word_hl 
1908				;ld hl,(scratch+2) 
1908				;call fourehexhl 
1908			 
1908 22 7a e6			ld (os_cur_ptr),hl	 
190b			 
190b e9				jp (hl) 
190c			 
190c			 
190c			 
190c			; TODO implement a basic monitor mode to start with 
190c			 
190c			 
190c			 
190c			 
190c			 
190c			 
190c			 
190c			 
190c			 
190c			; testing and demo code during development 
190c			 
190c			 
190c .. 00		str1: db "Enter some text...",0 
191f .. 00		clear: db "                    ",0 
1934			 
1934			demo: 
1934			 
1934			 
1934			 
1934			;	call update_display 
1934			 
1934				; init scratch input area for testing 
1934 21 57 e3			ld hl, scratch	 
1937 3e 00			ld a,0 
1939 77				ld (hl),a 
193a			 
193a			 
193a 3e 28		            LD   A, display_row_2 
193c			;            CALL fLCD_Pos       ;Position cursor to location in A 
193c 11 0c 19		            LD   DE, str1 
193f cd 93 09			call str_at_display 
1942			 
1942			;            CALL fLCD_Str       ;Display string pointed to by DE 
1942			cloop:	 
1942 3e 50		            LD   A, display_row_3 
1944			;            CALL fLCD_Pos       ;Position cursor to location in A 
1944 11 1f 19		            LD   DE, clear 
1947			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1947 cd 93 09				call str_at_display 
194a 3e 78			ld a, display_row_4 
194c 11 7c 19			ld de, prompt 
194f			 
194f cd 93 09				call str_at_display 
1952 cd a3 09			call update_display 
1955			 
1955 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1957 16 0a			ld d, 10 
1959 21 57 e3			ld hl, scratch	 
195c cd da 0b			call input_str 
195f			 
195f			;	call clear_display 
195f			;'	call update_display 
195f			 
195f 3e 00		            LD   A, display_row_1 
1961			;            CALL fLCD_Pos       ;Position cursor to location in A 
1961 11 1f 19		            LD   DE, clear 
1964 cd 93 09				call str_at_display 
1967			;            CALL fLCD_Str       ;Display string pointed to by DE 
1967 3e 00		            LD   A, display_row_1 
1969			;            CALL fLCD_Pos       ;Position cursor to location in A 
1969 11 57 e3		            LD   DE, scratch 
196c			;            CALL fLCD_Str       ;Display string pointed to by DE 
196c cd 93 09				call str_at_display 
196f cd a3 09			call update_display 
1972			 
1972 3e 00				ld a,0 
1974 21 57 e3			ld hl, scratch 
1977 77				ld (hl),a 
1978			 
1978 00				nop 
1979 c3 42 19			jp cloop 
197c			 
197c			 
197c			 
197c			; OS Prompt 
197c			 
197c .. 00		prompt: db ">",0 
197e .. 00		endprg: db "?",0 
1980			 
1980			 
1980			; handy next page prompt 
1980			next_page_prompt: 
1980 e5				push hl 
1981 d5				push de 
1982 f5				push af 
1983 c5				push bc 
1984			 
1984 3e 9f			ld a,display_row_4 + display_cols - 1 
1986 11 7e 19		        ld de, endprg 
1989 cd 93 09			call str_at_display 
198c cd a3 09			call update_display 
198f cd 25 59			call cin_wait 
1992 c1				pop bc 
1993 f1				pop af 
1994 d1				pop de 
1995 e1				pop hl 
1996			 
1996			 
1996 c9				ret 
1997			 
1997			 
1997			; forth parser 
1997			 
1997			; My forth kernel 
1997			include "forth_kernel.asm" 
1997			; 
1997			; kernel to the forth OS 
1997			 
1997			DS_TYPE_STR: equ 1     ; string type 
1997			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1997			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1997			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1997			 
1997			FORTH_PARSEV1: equ 0 
1997			FORTH_PARSEV2: equ 0 
1997			FORTH_PARSEV3: equ 0 
1997			FORTH_PARSEV4: equ 0 
1997			FORTH_PARSEV5: equ 1 
1997			 
1997			;if FORTH_PARSEV5 
1997			;	FORTH_END_BUFFER: equ 0 
1997			;else 
1997			FORTH_END_BUFFER: equ 127 
1997			;endif 
1997			 
1997			FORTH_TRUE: equ 1 
1997			FORTH_FALSE: equ 0 
1997			 
1997			if FORTH_PARSEV4 
1997			include "forth_stackops.asm" 
1997			endif 
1997			 
1997			if FORTH_PARSEV5 
1997			include "forth_stackopsv5.asm" 
1997			 
1997			; Stack operations for v5 parser on wards 
1997			; * DATA stack 
1997			; * LOOP stack 
1997			; * RETURN stack 
1997			 
1997			 
1997			 
1997			FORTH_CHK_DSP_UNDER: macro 
1997				push hl 
1997				push de 
1997				ld hl,(cli_data_sp) 
1997				ld de, cli_data_stack 
1997				call cmp16 
1997				jp c, fault_dsp_under 
1997				pop de 
1997				pop hl 
1997				endm 
1997			 
1997			 
1997			FORTH_CHK_RSP_UNDER: macro 
1997				push hl 
1997				push de 
1997				ld hl,(cli_ret_sp) 
1997				ld de, cli_ret_stack 
1997				call cmp16 
1997				jp c, fault_rsp_under 
1997				pop de 
1997				pop hl 
1997				endm 
1997			 
1997			FORTH_CHK_LOOP_UNDER: macro 
1997				push hl 
1997				push de 
1997				ld hl,(cli_loop_sp) 
1997				ld de, cli_loop_stack 
1997				call cmp16 
1997				jp c, fault_loop_under 
1997				pop de 
1997				pop hl 
1997				endm 
1997			 
1997			FORTH_ERR_TOS_NOTSTR: macro 
1997				; TOSO might need more for checks when used 
1997				push af 
1997				ld a,(hl) 
1997				cp DS_TYPE_STR 
1997				jp nz, type_faultn   
1997				pop af 
1997				endm 
1997			 
1997			FORTH_ERR_TOS_NOTNUM: macro 
1997				push af 
1997				ld a,(hl) 
1997				cp DS_TYPE_INUM 
1997				jp nz, type_faultn   
1997				pop af 
1997				endm 
1997			 
1997			 
1997			; increase data stack pointer and save hl to it 
1997				 
1997			FORTH_DSP_NEXT: macro 
1997				call macro_forth_dsp_next 
1997				endm 
1997			 
1997			 
1997			macro_forth_dsp_next: 
1997				if DEBUG_FORTH_STACK_GUARD 
1997 cd 3d 56				call check_stacks 
199a				endif 
199a e5				push hl 
199b d5				push de 
199c eb				ex de,hl 
199d 2a 04 eb			ld hl,(cli_data_sp) 
19a0 23				inc hl 
19a1 23				inc hl 
19a2			 
19a2			; PARSEV5 
19a2 23				inc hl 
19a3 22 04 eb			ld (cli_data_sp),hl 
19a6 73				ld (hl), e 
19a7 23				inc hl 
19a8 72				ld (hl), d 
19a9 d1				pop de 
19aa e1				pop hl 
19ab				if DEBUG_FORTH_STACK_GUARD 
19ab cd 3d 56				call check_stacks 
19ae				endif 
19ae c9				ret 
19af			 
19af			 
19af			; increase ret stack pointer and save hl to it 
19af				 
19af			FORTH_RSP_NEXT: macro 
19af				call macro_forth_rsp_next 
19af				endm 
19af			 
19af			macro_forth_rsp_next: 
19af				if DEBUG_FORTH_STACK_GUARD 
19af cd 3d 56				call check_stacks 
19b2				endif 
19b2 e5				push hl 
19b3 d5				push de 
19b4 eb				ex de,hl 
19b5 2a 08 eb			ld hl,(cli_ret_sp) 
19b8 23				inc hl 
19b9 23				inc hl 
19ba 22 08 eb			ld (cli_ret_sp),hl 
19bd 73				ld (hl), e 
19be 23				inc hl 
19bf 72				ld (hl), d 
19c0 d1				pop de 
19c1 e1				pop hl 
19c2				if DEBUG_FORTH_STACK_GUARD 
19c2 cd 3d 56				call check_stacks 
19c5				endif 
19c5 c9				ret 
19c6			 
19c6			; get current ret stack pointer and save to hl  
19c6				 
19c6			FORTH_RSP_TOS: macro 
19c6				call macro_forth_rsp_tos 
19c6				endm 
19c6			 
19c6			macro_forth_rsp_tos: 
19c6				;push de 
19c6 2a 08 eb			ld hl,(cli_ret_sp) 
19c9 cd 01 1a			call loadhlptrtohl 
19cc				;ld e, (hl) 
19cc				;inc hl 
19cc				;ld d, (hl) 
19cc				;ex de, hl 
19cc					if DEBUG_FORTH_WORDS 
19cc			;			DMARK "RST" 
19cc						CALLMONITOR 
19cc cd ae 13			call break_point_state  
19cf				endm  
# End of macro CALLMONITOR
19cf					endif 
19cf				;pop de 
19cf c9				ret 
19d0			 
19d0			; pop ret stack pointer 
19d0				 
19d0			FORTH_RSP_POP: macro 
19d0				call macro_forth_rsp_pop 
19d0				endm 
19d0			 
19d0			 
19d0			macro_forth_rsp_pop: 
19d0				if DEBUG_FORTH_STACK_GUARD 
19d0			;		DMARK "RPP" 
19d0 cd 3d 56				call check_stacks 
19d3					FORTH_CHK_RSP_UNDER 
19d3 e5				push hl 
19d4 d5				push de 
19d5 2a 08 eb			ld hl,(cli_ret_sp) 
19d8 11 c2 ea			ld de, cli_ret_stack 
19db cd cb 0b			call cmp16 
19de da 51 57			jp c, fault_rsp_under 
19e1 d1				pop de 
19e2 e1				pop hl 
19e3				endm 
# End of macro FORTH_CHK_RSP_UNDER
19e3				endif 
19e3 e5				push hl 
19e4 2a 08 eb			ld hl,(cli_ret_sp) 
19e7			 
19e7			 
19e7				if FORTH_ENABLE_FREE 
19e7			 
19e7					; get pointer 
19e7			 
19e7					push de 
19e7					push hl 
19e7			 
19e7					ld e, (hl) 
19e7					inc hl 
19e7					ld d, (hl) 
19e7			 
19e7					ex de, hl 
19e7					call free 
19e7			 
19e7					pop hl 
19e7					pop de 
19e7			 
19e7			 
19e7				endif 
19e7			 
19e7			 
19e7 2b				dec hl 
19e8 2b				dec hl 
19e9 22 08 eb			ld (cli_ret_sp), hl 
19ec				; do stack underflow checks 
19ec e1				pop hl 
19ed				if DEBUG_FORTH_STACK_GUARD 
19ed cd 3d 56				call check_stacks 
19f0					FORTH_CHK_RSP_UNDER 
19f0 e5				push hl 
19f1 d5				push de 
19f2 2a 08 eb			ld hl,(cli_ret_sp) 
19f5 11 c2 ea			ld de, cli_ret_stack 
19f8 cd cb 0b			call cmp16 
19fb da 51 57			jp c, fault_rsp_under 
19fe d1				pop de 
19ff e1				pop hl 
1a00				endm 
# End of macro FORTH_CHK_RSP_UNDER
1a00				endif 
1a00 c9				ret 
1a01			 
1a01			 
1a01			 
1a01			; routine to load word pointed to by hl into hl 
1a01			 
1a01			loadhlptrtohl: 
1a01			 
1a01 d5				push de 
1a02 5e				ld e, (hl) 
1a03 23				inc hl 
1a04 56				ld d, (hl) 
1a05 eb				ex de, hl 
1a06 d1				pop de 
1a07			 
1a07 c9				ret 
1a08			 
1a08			 
1a08			 
1a08			 
1a08			 
1a08			; push a number held in HL onto the data stack 
1a08			; entry point for pushing a value when already in hl used in function above 
1a08			 
1a08			forth_push_numhl: 
1a08			 
1a08 e5				push hl    ; save value to push 
1a09			 
1a09			if DEBUG_FORTH_PUSH 
1a09				; see if disabled 
1a09			 
1a09			 
1a09 f5				push af 
1a0a 3a 48 e3			ld a, (os_view_disable) 
1a0d fe 2a			cp '*' 
1a0f 28 34			jr z, .pskip2 
1a11 e5				push hl 
1a12 e5			push hl 
1a13 cd 80 09			call clear_display 
1a16 e1			pop hl 
1a17 7c				ld a,h 
1a18 21 5c e6			ld hl, os_word_scratch 
1a1b cd ae 0e			call hexout 
1a1e e1				pop hl 
1a1f 7d				ld a,l 
1a20 21 5e e6			ld hl, os_word_scratch+2 
1a23 cd ae 0e			call hexout 
1a26			 
1a26 21 60 e6			ld hl, os_word_scratch+4 
1a29 3e 00			ld a,0 
1a2b 77				ld (hl),a 
1a2c 11 5c e6			ld de,os_word_scratch 
1a2f 3e 28				ld a, display_row_2 
1a31 cd 93 09				call str_at_display 
1a34 11 4b 45			ld de, .push_num 
1a37 3e 00			ld a, display_row_1 
1a39			 
1a39 cd 93 09				call str_at_display 
1a3c			 
1a3c			 
1a3c cd a3 09			call update_display 
1a3f cd f2 08			call delay1s 
1a42 cd f2 08			call delay1s 
1a45			.pskip2:  
1a45			 
1a45 f1				pop af 
1a46			endif	 
1a46			 
1a46			 
1a46				FORTH_DSP_NEXT 
1a46 cd 97 19			call macro_forth_dsp_next 
1a49				endm 
# End of macro FORTH_DSP_NEXT
1a49			 
1a49 2a 04 eb			ld hl, (cli_data_sp) 
1a4c			 
1a4c				; save item type 
1a4c 3e 02			ld a,  DS_TYPE_INUM 
1a4e 77				ld (hl), a 
1a4f 23				inc hl 
1a50			 
1a50				; get word off stack 
1a50 d1				pop de 
1a51 7b				ld a,e 
1a52 77				ld (hl), a 
1a53 23				inc hl 
1a54 7a				ld a,d 
1a55 77				ld (hl), a 
1a56			 
1a56			if DEBUG_FORTH_PUSH 
1a56 2b				dec hl 
1a57 2b				dec hl 
1a58 2b				dec hl 
1a59						DMARK "PH5" 
1a59 f5				push af  
1a5a 3a 6e 1a			ld a, (.dmark)  
1a5d 32 71 ee			ld (debug_mark),a  
1a60 3a 6f 1a			ld a, (.dmark+1)  
1a63 32 72 ee			ld (debug_mark+1),a  
1a66 3a 70 1a			ld a, (.dmark+2)  
1a69 32 73 ee			ld (debug_mark+2),a  
1a6c 18 03			jr .pastdmark  
1a6e ..			.dmark: db "PH5"  
1a71 f1			.pastdmark: pop af  
1a72			endm  
# End of macro DMARK
1a72				CALLMONITOR 
1a72 cd ae 13			call break_point_state  
1a75				endm  
# End of macro CALLMONITOR
1a75			endif	 
1a75			 
1a75 c9				ret 
1a76			 
1a76			 
1a76			; Push a string to stack pointed to by hl 
1a76			 
1a76			forth_push_str: 
1a76			 
1a76			if DEBUG_FORTH_PUSH 
1a76						DMARK "PSQ" 
1a76 f5				push af  
1a77 3a 8b 1a			ld a, (.dmark)  
1a7a 32 71 ee			ld (debug_mark),a  
1a7d 3a 8c 1a			ld a, (.dmark+1)  
1a80 32 72 ee			ld (debug_mark+1),a  
1a83 3a 8d 1a			ld a, (.dmark+2)  
1a86 32 73 ee			ld (debug_mark+2),a  
1a89 18 03			jr .pastdmark  
1a8b ..			.dmark: db "PSQ"  
1a8e f1			.pastdmark: pop af  
1a8f			endm  
# End of macro DMARK
1a8f				CALLMONITOR 
1a8f cd ae 13			call break_point_state  
1a92				endm  
# End of macro CALLMONITOR
1a92			endif	 
1a92			    
1a92 e5				push hl 
1a93 e5				push hl 
1a94			 
1a94			;	ld a, 0   ; find end of string 
1a94 cd 0b 10			call strlenz 
1a97			if DEBUG_FORTH_PUSH 
1a97						DMARK "PQ2" 
1a97 f5				push af  
1a98 3a ac 1a			ld a, (.dmark)  
1a9b 32 71 ee			ld (debug_mark),a  
1a9e 3a ad 1a			ld a, (.dmark+1)  
1aa1 32 72 ee			ld (debug_mark+1),a  
1aa4 3a ae 1a			ld a, (.dmark+2)  
1aa7 32 73 ee			ld (debug_mark+2),a  
1aaa 18 03			jr .pastdmark  
1aac ..			.dmark: db "PQ2"  
1aaf f1			.pastdmark: pop af  
1ab0			endm  
# End of macro DMARK
1ab0				CALLMONITOR 
1ab0 cd ae 13			call break_point_state  
1ab3				endm  
# End of macro CALLMONITOR
1ab3			endif	 
1ab3 eb				ex de, hl 
1ab4 e1				pop hl   ; get ptr to start of string 
1ab5			if DEBUG_FORTH_PUSH 
1ab5						DMARK "PQ3" 
1ab5 f5				push af  
1ab6 3a ca 1a			ld a, (.dmark)  
1ab9 32 71 ee			ld (debug_mark),a  
1abc 3a cb 1a			ld a, (.dmark+1)  
1abf 32 72 ee			ld (debug_mark+1),a  
1ac2 3a cc 1a			ld a, (.dmark+2)  
1ac5 32 73 ee			ld (debug_mark+2),a  
1ac8 18 03			jr .pastdmark  
1aca ..			.dmark: db "PQ3"  
1acd f1			.pastdmark: pop af  
1ace			endm  
# End of macro DMARK
1ace				CALLMONITOR 
1ace cd ae 13			call break_point_state  
1ad1				endm  
# End of macro CALLMONITOR
1ad1			endif	 
1ad1 19				add hl,de 
1ad2			if DEBUG_FORTH_PUSH 
1ad2						DMARK "PQE" 
1ad2 f5				push af  
1ad3 3a e7 1a			ld a, (.dmark)  
1ad6 32 71 ee			ld (debug_mark),a  
1ad9 3a e8 1a			ld a, (.dmark+1)  
1adc 32 72 ee			ld (debug_mark+1),a  
1adf 3a e9 1a			ld a, (.dmark+2)  
1ae2 32 73 ee			ld (debug_mark+2),a  
1ae5 18 03			jr .pastdmark  
1ae7 ..			.dmark: db "PQE"  
1aea f1			.pastdmark: pop af  
1aeb			endm  
# End of macro DMARK
1aeb				CALLMONITOR 
1aeb cd ae 13			call break_point_state  
1aee				endm  
# End of macro CALLMONITOR
1aee			endif	 
1aee			 
1aee 2b				dec hl    ; see if there is an optional trailing double quote 
1aef 7e				ld a,(hl) 
1af0 fe 22			cp '"' 
1af2 20 03			jr nz, .strnoq 
1af4 3e 00			ld a, 0      ; get rid of double quote 
1af6 77				ld (hl), a 
1af7 23			.strnoq: inc hl 
1af8			 
1af8 3e 00			ld a, 0 
1afa 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1afb			 
1afb 13				inc de ; add one for the type string 
1afc 13				inc de ; add one for null term??? 
1afd			 
1afd				; tos is get string pointer again 
1afd				; de contains space to allocate 
1afd				 
1afd d5				push de 
1afe			 
1afe eb				ex de, hl 
1aff			 
1aff				;push af 
1aff			 
1aff			if DEBUG_FORTH_PUSH 
1aff						DMARK "PHm" 
1aff f5				push af  
1b00 3a 14 1b			ld a, (.dmark)  
1b03 32 71 ee			ld (debug_mark),a  
1b06 3a 15 1b			ld a, (.dmark+1)  
1b09 32 72 ee			ld (debug_mark+1),a  
1b0c 3a 16 1b			ld a, (.dmark+2)  
1b0f 32 73 ee			ld (debug_mark+2),a  
1b12 18 03			jr .pastdmark  
1b14 ..			.dmark: db "PHm"  
1b17 f1			.pastdmark: pop af  
1b18			endm  
# End of macro DMARK
1b18				CALLMONITOR 
1b18 cd ae 13			call break_point_state  
1b1b				endm  
# End of macro CALLMONITOR
1b1b			endif	 
1b1b cd 74 10			call malloc	; on ret hl now contains allocated memory 
1b1e				if DEBUG_FORTH_MALLOC_GUARD 
1b1e cc a3 45				call z,malloc_error 
1b21				endif 
1b21			 
1b21				 
1b21 c1				pop bc    ; get length 
1b22 d1				pop de   ;  get string start    
1b23			 
1b23				; hl has destination from malloc 
1b23			 
1b23 eb				ex de, hl    ; prep for ldir 
1b24			 
1b24 d5				push de   ; save malloc area for DSP later 
1b25				;push hl   ; save malloc area for DSP later 
1b25			 
1b25			if DEBUG_FORTH_PUSH 
1b25						DMARK "PHc" 
1b25 f5				push af  
1b26 3a 3a 1b			ld a, (.dmark)  
1b29 32 71 ee			ld (debug_mark),a  
1b2c 3a 3b 1b			ld a, (.dmark+1)  
1b2f 32 72 ee			ld (debug_mark+1),a  
1b32 3a 3c 1b			ld a, (.dmark+2)  
1b35 32 73 ee			ld (debug_mark+2),a  
1b38 18 03			jr .pastdmark  
1b3a ..			.dmark: db "PHc"  
1b3d f1			.pastdmark: pop af  
1b3e			endm  
# End of macro DMARK
1b3e				CALLMONITOR 
1b3e cd ae 13			call break_point_state  
1b41				endm  
# End of macro CALLMONITOR
1b41			endif	 
1b41			 
1b41			 
1b41 ed b0			ldir 
1b43			 
1b43			 
1b43				; push malloc to data stack     macro?????  
1b43			 
1b43				FORTH_DSP_NEXT 
1b43 cd 97 19			call macro_forth_dsp_next 
1b46				endm 
# End of macro FORTH_DSP_NEXT
1b46			 
1b46				; save value and type 
1b46			 
1b46 2a 04 eb			ld hl, (cli_data_sp) 
1b49			 
1b49				; save item type 
1b49 3e 01			ld a,  DS_TYPE_STR 
1b4b 77				ld (hl), a 
1b4c 23				inc hl 
1b4d			 
1b4d				; get malloc word off stack 
1b4d d1				pop de 
1b4e 73				ld (hl), e 
1b4f 23				inc hl 
1b50 72				ld (hl), d 
1b51			 
1b51			 
1b51			 
1b51			if DEBUG_FORTH_PUSH 
1b51 2a 04 eb			ld hl, (cli_data_sp) 
1b54						DMARK "PHS" 
1b54 f5				push af  
1b55 3a 69 1b			ld a, (.dmark)  
1b58 32 71 ee			ld (debug_mark),a  
1b5b 3a 6a 1b			ld a, (.dmark+1)  
1b5e 32 72 ee			ld (debug_mark+1),a  
1b61 3a 6b 1b			ld a, (.dmark+2)  
1b64 32 73 ee			ld (debug_mark+2),a  
1b67 18 03			jr .pastdmark  
1b69 ..			.dmark: db "PHS"  
1b6c f1			.pastdmark: pop af  
1b6d			endm  
# End of macro DMARK
1b6d				CALLMONITOR 
1b6d cd ae 13			call break_point_state  
1b70				endm  
# End of macro CALLMONITOR
1b70			;	ex de,hl 
1b70			endif	 
1b70				; in case of spaces, skip the ptr past the copied string 
1b70				;pop af 
1b70				;ld (cli_origptr),hl 
1b70			 
1b70 c9				ret 
1b71			 
1b71			 
1b71			 
1b71			; TODO ascii push input onto stack given hl to start of input 
1b71			 
1b71			; identify type 
1b71			; if starts with a " then a string 
1b71			; otherwise it is a number 
1b71			;  
1b71			; if a string 
1b71			;     scan for ending " to get length of string to malloc for + 1 
1b71			;     malloc 
1b71			;     put pointer to string on stack first byte flags as string 
1b71			; 
1b71			; else a number 
1b71			;    look for number format identifier 
1b71			;    $xx hex 
1b71			;    %xxxxx bin 
1b71			;    xxxxx decimal 
1b71			;    convert number to 16bit word.  
1b71			;    malloc word + 1 with flag to identiy as num 
1b71			;    put pointer to number on stack 
1b71			;   
1b71			;  
1b71			  
1b71			forth_apush: 
1b71				; kernel push 
1b71			 
1b71			if DEBUG_FORTH_PUSH 
1b71						DMARK "PSH" 
1b71 f5				push af  
1b72 3a 86 1b			ld a, (.dmark)  
1b75 32 71 ee			ld (debug_mark),a  
1b78 3a 87 1b			ld a, (.dmark+1)  
1b7b 32 72 ee			ld (debug_mark+1),a  
1b7e 3a 88 1b			ld a, (.dmark+2)  
1b81 32 73 ee			ld (debug_mark+2),a  
1b84 18 03			jr .pastdmark  
1b86 ..			.dmark: db "PSH"  
1b89 f1			.pastdmark: pop af  
1b8a			endm  
# End of macro DMARK
1b8a				CALLMONITOR 
1b8a cd ae 13			call break_point_state  
1b8d				endm  
# End of macro CALLMONITOR
1b8d			endif	 
1b8d				; identify input type 
1b8d			 
1b8d 7e				ld a,(hl) 
1b8e fe 22			cp '"' 
1b90 28 0a			jr z, .fapstr 
1b92 fe 24			cp '$' 
1b94 ca bc 1b			jp z, .faphex 
1b97 fe 25			cp '%' 
1b99 ca a4 1b			jp z, .fapbin 
1b9c			;	cp 'b' 
1b9c			;	jp z, .fabin 
1b9c				; else decimal 
1b9c			 
1b9c				; TODO do decimal conversion 
1b9c				; decimal is stored as a 16bit word 
1b9c			 
1b9c				; by default everything is a string if type is not detected 
1b9c			.fapstr: ; 
1b9c fe 22			cp '"' 
1b9e 20 01			jr nz, .strnoqu 
1ba0 23				inc hl 
1ba1			.strnoqu: 
1ba1 c3 76 1a			jp forth_push_str 
1ba4			 
1ba4			 
1ba4			 
1ba4			.fapbin:    ; push a binary string.  
1ba4 11 00 00			ld de, 0   ; hold a 16bit value 
1ba7			 
1ba7 23			.fapbinshift:	inc hl  
1ba8 7e				ld a,(hl) 
1ba9 fe 00			cp 0     ; done scanning  
1bab 28 0b			jr z, .fapbdone  	; got it in HL so push  
1bad			 
1bad				; left shift de 
1bad eb				ex de, hl	 
1bae 29				add hl, hl 
1baf			 
1baf				; is 1 
1baf fe 31			cp '1' 
1bb1 20 02			jr nz, .binzero 
1bb3 cb 4d			bit 1, l 
1bb5			.binzero: 
1bb5 eb				ex de, hl	 ; save current de 
1bb6 18 ef			jr .fapbinshift 
1bb8			 
1bb8			.fapbdone: 
1bb8 eb				ex de, hl 
1bb9 c3 08 1a			jp forth_push_numhl 
1bbc			 
1bbc			 
1bbc			.faphex:   ; hex is always stored as a 16bit word 
1bbc				; skip number prefix 
1bbc 23				inc hl 
1bbd				; turn ascii into number 
1bbd cd 64 0f			call get_word_hl	; ret 16bit word in hl 
1bc0			 
1bc0 c3 08 1a			jp forth_push_numhl 
1bc3			 
1bc3 00				 nop 
1bc4			 
1bc4			.fabin:   ; TODO bin conversion 
1bc4			 
1bc4			 
1bc4 c9				ret 
1bc5			 
1bc5			 
1bc5			; get either a string ptr or a 16bit word from the data stack 
1bc5			 
1bc5			FORTH_DSP: macro 
1bc5				call macro_forth_dsp 
1bc5				endm 
1bc5			 
1bc5			macro_forth_dsp: 
1bc5				; data stack pointer points to current word on tos 
1bc5			 
1bc5 2a 04 eb			ld hl,(cli_data_sp) 
1bc8			 
1bc8				if DEBUG_FORTH_PUSH 
1bc8						DMARK "DSP" 
1bc8 f5				push af  
1bc9 3a dd 1b			ld a, (.dmark)  
1bcc 32 71 ee			ld (debug_mark),a  
1bcf 3a de 1b			ld a, (.dmark+1)  
1bd2 32 72 ee			ld (debug_mark+1),a  
1bd5 3a df 1b			ld a, (.dmark+2)  
1bd8 32 73 ee			ld (debug_mark+2),a  
1bdb 18 03			jr .pastdmark  
1bdd ..			.dmark: db "DSP"  
1be0 f1			.pastdmark: pop af  
1be1			endm  
# End of macro DMARK
1be1			 
1be1 cd d8 45				call display_data_sp 
1be4				;call break_point_state 
1be4				;rst 030h 
1be4				CALLMONITOR 
1be4 cd ae 13			call break_point_state  
1be7				endm  
# End of macro CALLMONITOR
1be7				endif 
1be7			 
1be7 c9				ret 
1be8			 
1be8			; return hl to start of value on stack 
1be8			 
1be8			FORTH_DSP_VALUE: macro 
1be8				call macro_forth_dsp_value 
1be8				endm 
1be8			 
1be8			macro_forth_dsp_value: 
1be8			 
1be8				FORTH_DSP 
1be8 cd c5 1b			call macro_forth_dsp 
1beb				endm 
# End of macro FORTH_DSP
1beb			 
1beb d5				push de 
1bec			 
1bec 23				inc hl ; skip type 
1bed			 
1bed 5e				ld e, (hl) 
1bee 23				inc hl 
1bef 56				ld d, (hl) 
1bf0 eb				ex de,hl  
1bf1			 
1bf1 d1				pop de 
1bf2			 
1bf2 c9				ret 
1bf3			 
1bf3			; return hl to start of value to second item on stack 
1bf3			 
1bf3			FORTH_DSP_VALUEM1: macro 
1bf3				call macro_forth_dsp_value_m1 
1bf3				endm 
1bf3			 
1bf3			macro_forth_dsp_value_m1: 
1bf3			 
1bf3				FORTH_DSP 
1bf3 cd c5 1b			call macro_forth_dsp 
1bf6				endm 
# End of macro FORTH_DSP
1bf6			 
1bf6 2b				dec hl 
1bf7 2b				dec hl 
1bf8			;	dec hl 
1bf8			 
1bf8 d5				push de 
1bf9			 
1bf9 5e				ld e, (hl) 
1bfa 23				inc hl 
1bfb 56				ld d, (hl) 
1bfc eb				ex de,hl  
1bfd			 
1bfd d1				pop de 
1bfe			 
1bfe c9				ret 
1bff			 
1bff				 
1bff			 
1bff			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1bff			 
1bff			FORTH_DSP_POP: macro 
1bff				call macro_forth_dsp_pop 
1bff				endm 
1bff			 
1bff			 
1bff			; get the tos data type 
1bff			 
1bff			FORTH_DSP_TYPE:   macro 
1bff			 
1bff				;FORTH_DSP_VALUE 
1bff				FORTH_DSP 
1bff				 
1bff				; hl points to value 
1bff				; check type 
1bff			 
1bff				ld a,(hl) 
1bff			 
1bff				endm 
1bff			 
1bff			; load the tos value into hl 
1bff			 
1bff			 
1bff			FORTH_DSP_VALUEHL:  macro 
1bff				call macro_dsp_valuehl 
1bff				endm 
1bff			 
1bff			 
1bff			 
1bff			macro_dsp_valuehl: 
1bff				FORTH_DSP_VALUE 
1bff cd e8 1b			call macro_forth_dsp_value 
1c02				endm 
# End of macro FORTH_DSP_VALUE
1c02			 
1c02				;FORTH_ERR_TOS_NOTNUM 
1c02			 
1c02				;inc hl   ; skip type id 
1c02			 
1c02			;	push de 
1c02			; 
1c02			;	ld e, (hl) 
1c02			;	inc hl 
1c02			;	ld d, (hl) 
1c02			;	ex de,hl  
1c02			 
1c02			;	pop de 
1c02			 
1c02				if DEBUG_FORTH_PUSH 
1c02						DMARK "DVL" 
1c02 f5				push af  
1c03 3a 17 1c			ld a, (.dmark)  
1c06 32 71 ee			ld (debug_mark),a  
1c09 3a 18 1c			ld a, (.dmark+1)  
1c0c 32 72 ee			ld (debug_mark+1),a  
1c0f 3a 19 1c			ld a, (.dmark+2)  
1c12 32 73 ee			ld (debug_mark+2),a  
1c15 18 03			jr .pastdmark  
1c17 ..			.dmark: db "DVL"  
1c1a f1			.pastdmark: pop af  
1c1b			endm  
# End of macro DMARK
1c1b				CALLMONITOR 
1c1b cd ae 13			call break_point_state  
1c1e				endm  
# End of macro CALLMONITOR
1c1e				endif 
1c1e c9				ret 
1c1f			 
1c1f			forth_apushstrhl:      
1c1f				; push of string requires use of cli_origptr 
1c1f				; bodge use 
1c1f			 
1c1f				; get current cli_origptr, save, update with temp pointer  
1c1f ed 5b 20 eb		ld de, (cli_origptr) 
1c23 22 20 eb			ld (cli_origptr), hl 
1c26 d5				push de 
1c27 cd 71 1b			call forth_apush 
1c2a d1				pop de 
1c2b ed 53 20 eb		ld (cli_origptr), de 
1c2f c9			        ret	 
1c30			 
1c30			 
1c30			; increase loop stack pointer and save hl to it 
1c30				 
1c30			FORTH_LOOP_NEXT: macro 
1c30				call macro_forth_loop_next 
1c30				;nop 
1c30				endm 
1c30			 
1c30			macro_forth_loop_next: 
1c30				if DEBUG_FORTH_STACK_GUARD 
1c30 cd 3d 56				call check_stacks 
1c33				endif 
1c33 e5				push hl 
1c34 d5				push de 
1c35 eb				ex de,hl 
1c36 2a 06 eb			ld hl,(cli_loop_sp) 
1c39 23				inc hl 
1c3a 23				inc hl 
1c3b					if DEBUG_FORTH_WORDS 
1c3b						DMARK "LNX" 
1c3b f5				push af  
1c3c 3a 50 1c			ld a, (.dmark)  
1c3f 32 71 ee			ld (debug_mark),a  
1c42 3a 51 1c			ld a, (.dmark+1)  
1c45 32 72 ee			ld (debug_mark+1),a  
1c48 3a 52 1c			ld a, (.dmark+2)  
1c4b 32 73 ee			ld (debug_mark+2),a  
1c4e 18 03			jr .pastdmark  
1c50 ..			.dmark: db "LNX"  
1c53 f1			.pastdmark: pop af  
1c54			endm  
# End of macro DMARK
1c54						CALLMONITOR 
1c54 cd ae 13			call break_point_state  
1c57				endm  
# End of macro CALLMONITOR
1c57					endif 
1c57 22 06 eb			ld (cli_loop_sp),hl 
1c5a 73				ld (hl), e 
1c5b 23				inc hl 
1c5c 72				ld (hl), d 
1c5d d1				pop de    ; been reversed so save a swap on restore 
1c5e e1				pop hl 
1c5f				if DEBUG_FORTH_STACK_GUARD 
1c5f cd 3d 56				call check_stacks 
1c62				endif 
1c62 c9				ret 
1c63			 
1c63			; get current ret stack pointer and save to hl  
1c63				 
1c63			FORTH_LOOP_TOS: macro 
1c63				call macro_forth_loop_tos 
1c63				endm 
1c63			 
1c63			macro_forth_loop_tos: 
1c63 d5				push de 
1c64 2a 06 eb			ld hl,(cli_loop_sp) 
1c67 5e				ld e, (hl) 
1c68 23				inc hl 
1c69 56				ld d, (hl) 
1c6a eb				ex de, hl 
1c6b d1				pop de 
1c6c c9				ret 
1c6d			 
1c6d			; pop loop stack pointer 
1c6d				 
1c6d			FORTH_LOOP_POP: macro 
1c6d				call macro_forth_loop_pop 
1c6d				endm 
1c6d			 
1c6d			 
1c6d			macro_forth_loop_pop: 
1c6d				if DEBUG_FORTH_STACK_GUARD 
1c6d					DMARK "LPP" 
1c6d f5				push af  
1c6e 3a 82 1c			ld a, (.dmark)  
1c71 32 71 ee			ld (debug_mark),a  
1c74 3a 83 1c			ld a, (.dmark+1)  
1c77 32 72 ee			ld (debug_mark+1),a  
1c7a 3a 84 1c			ld a, (.dmark+2)  
1c7d 32 73 ee			ld (debug_mark+2),a  
1c80 18 03			jr .pastdmark  
1c82 ..			.dmark: db "LPP"  
1c85 f1			.pastdmark: pop af  
1c86			endm  
# End of macro DMARK
1c86 cd 3d 56				call check_stacks 
1c89					FORTH_CHK_LOOP_UNDER 
1c89 e5				push hl 
1c8a d5				push de 
1c8b 2a 06 eb			ld hl,(cli_loop_sp) 
1c8e 11 c0 e9			ld de, cli_loop_stack 
1c91 cd cb 0b			call cmp16 
1c94 da 57 57			jp c, fault_loop_under 
1c97 d1				pop de 
1c98 e1				pop hl 
1c99				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1c99				endif 
1c99 e5				push hl 
1c9a 2a 06 eb			ld hl,(cli_loop_sp) 
1c9d 2b				dec hl 
1c9e 2b				dec hl 
1c9f 22 06 eb			ld (cli_loop_sp), hl 
1ca2				; TODO do stack underflow checks 
1ca2 e1				pop hl 
1ca3				if DEBUG_FORTH_STACK_GUARD 
1ca3 cd 3d 56				call check_stacks 
1ca6					FORTH_CHK_LOOP_UNDER 
1ca6 e5				push hl 
1ca7 d5				push de 
1ca8 2a 06 eb			ld hl,(cli_loop_sp) 
1cab 11 c0 e9			ld de, cli_loop_stack 
1cae cd cb 0b			call cmp16 
1cb1 da 57 57			jp c, fault_loop_under 
1cb4 d1				pop de 
1cb5 e1				pop hl 
1cb6				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1cb6				endif 
1cb6 c9				ret 
1cb7			 
1cb7			macro_forth_dsp_pop: 
1cb7			 
1cb7 e5				push hl 
1cb8			 
1cb8				; release malloc data 
1cb8			 
1cb8				if DEBUG_FORTH_STACK_GUARD 
1cb8 cd 3d 56				call check_stacks 
1cbb					FORTH_CHK_DSP_UNDER 
1cbb e5				push hl 
1cbc d5				push de 
1cbd 2a 04 eb			ld hl,(cli_data_sp) 
1cc0 11 be e8			ld de, cli_data_stack 
1cc3 cd cb 0b			call cmp16 
1cc6 da 4b 57			jp c, fault_dsp_under 
1cc9 d1				pop de 
1cca e1				pop hl 
1ccb				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ccb				endif 
1ccb				;ld hl,(cli_data_sp) 
1ccb			if DEBUG_FORTH_DOT 
1ccb				DMARK "DPP" 
1ccb				CALLMONITOR 
1ccb			endif	 
1ccb			 
1ccb			 
1ccb			if FORTH_ENABLE_DSPPOPFREE 
1ccb			 
1ccb				FORTH_DSP 
1ccb cd c5 1b			call macro_forth_dsp 
1cce				endm 
# End of macro FORTH_DSP
1cce			 
1cce 7e				ld a, (hl) 
1ccf fe 01			cp DS_TYPE_STR 
1cd1 20 07			jr nz, .skippopfree 
1cd3			 
1cd3				FORTH_DSP_VALUEHL 
1cd3 cd ff 1b			call macro_dsp_valuehl 
1cd6				endm 
# End of macro FORTH_DSP_VALUEHL
1cd6 00				nop 
1cd7			if DEBUG_FORTH_DOT 
1cd7				DMARK "DPf" 
1cd7				CALLMONITOR 
1cd7			endif	 
1cd7 cd 3e 11			call free 
1cda			.skippopfree: 
1cda				 
1cda			 
1cda			endif 
1cda			 
1cda			if DEBUG_FORTH_DOT_KEY 
1cda				DMARK "DP2" 
1cda				CALLMONITOR 
1cda			endif	 
1cda			 
1cda				; move pointer down 
1cda			 
1cda 2a 04 eb			ld hl,(cli_data_sp) 
1cdd 2b				dec hl 
1cde 2b				dec hl 
1cdf			; PARSEV5 
1cdf 2b				dec hl 
1ce0 22 04 eb			ld (cli_data_sp), hl 
1ce3			 
1ce3				if DEBUG_FORTH_STACK_GUARD 
1ce3 cd 3d 56				call check_stacks 
1ce6					FORTH_CHK_DSP_UNDER 
1ce6 e5				push hl 
1ce7 d5				push de 
1ce8 2a 04 eb			ld hl,(cli_data_sp) 
1ceb 11 be e8			ld de, cli_data_stack 
1cee cd cb 0b			call cmp16 
1cf1 da 4b 57			jp c, fault_dsp_under 
1cf4 d1				pop de 
1cf5 e1				pop hl 
1cf6				endm 
# End of macro FORTH_CHK_DSP_UNDER
1cf6				endif 
1cf6			 
1cf6 e1				pop hl 
1cf7			 
1cf7 c9				ret 
1cf8			 
1cf8			getwordathl: 
1cf8				; hl points to an address 
1cf8				; load hl with the word at that address 
1cf8			 
1cf8 d5				push de 
1cf9			 
1cf9 5e				ld e, (hl) 
1cfa 23				inc hl 
1cfb 56				ld d, (hl) 
1cfc eb				ex de, hl 
1cfd			 
1cfd d1				pop de 
1cfe c9				ret 
1cff			 
1cff			 
1cff			 
1cff			 
1cff			 
1cff			; eof 
1cff			 
# End of file forth_stackopsv5.asm
1cff			endif 
1cff			 
1cff			user_word_eol:  
1cff				; hl contains the pointer to where to create a linked list item from the end 
1cff				; of the user dict to continue on at the system word dict 
1cff				 
1cff				; poke the stub of the word list linked list to repoint to rom words 
1cff			 
1cff				; stub format 
1cff				; db   word id 
1cff				; dw    link to next word 
1cff			        ; db char length of token 
1cff				; db string + 0 term 
1cff				; db exec code....  
1cff			 
1cff 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1d01 77				ld (hl), a		; word id 
1d02 23				inc hl 
1d03			 
1d03 11 c9 1e			ld de, sysdict 
1d06 73				ld (hl), e		; next word link ie system dict 
1d07 23				inc hl 
1d08 72				ld (hl), d		; next word link ie system dict 
1d09 23				inc hl	 
1d0a			 
1d0a			;	ld (hl), sysdict		; next word link ie system dict 
1d0a			;	inc hl 
1d0a			;	inc hl 
1d0a			 
1d0a			;	inc hl 
1d0a			;	inc hl 
1d0a			 
1d0a 3e 02			ld a, 2			; word length is 0 
1d0c 77				ld (hl), a	 
1d0d 23				inc hl 
1d0e			 
1d0e 3e 7e			ld a, '~'			; word length is 0 
1d10 77				ld (hl), a	 
1d11 23				inc hl 
1d12 3e 00			ld a, 0			; save empty word 
1d14 77				ld (hl), a 
1d15			 
1d15 c9				ret 
1d16			 
1d16				 
1d16			 
1d16			forthexec_cleanup: 
1d16				FORTH_RSP_POP 
1d16 cd d0 19			call macro_forth_rsp_pop 
1d19				endm 
# End of macro FORTH_RSP_POP
1d19 c9				ret 
1d1a			 
1d1a			forth_call_hl: 
1d1a				; taking hl 
1d1a e5				push hl 
1d1b c9				ret 
1d1c			 
1d1c			; this is called to reset Forth system but keep existing uwords etc 
1d1c			 
1d1c			forth_warmstart: 
1d1c				; setup stack over/under flow checks 
1d1c				if DEBUG_FORTH_STACK_GUARD 
1d1c cd 23 56				call chk_stk_init 
1d1f				endif 
1d1f			 
1d1f				; init stack pointers  - * these stacks go upwards *  
1d1f 21 c2 ea			ld hl, cli_ret_stack 
1d22 22 08 eb			ld (cli_ret_sp), hl	 
1d25				; set bottom of stack 
1d25 3e 00			ld a,0 
1d27 77				ld (hl),a 
1d28 23				inc hl 
1d29 77				ld (hl),a 
1d2a			 
1d2a 21 be e8			ld hl, cli_data_stack 
1d2d 22 04 eb			ld (cli_data_sp), hl	 
1d30				; set bottom of stack 
1d30 3e 00			ld a,0 
1d32 77				ld (hl),a 
1d33 23				inc hl 
1d34 77				ld (hl),a 
1d35			 
1d35 21 c0 e9			ld hl, cli_loop_stack 
1d38 22 06 eb			ld (cli_loop_sp), hl	 
1d3b				; set bottom of stack 
1d3b 3e 00			ld a,0 
1d3d 77				ld (hl),a 
1d3e 23				inc hl 
1d3f 77				ld (hl),a 
1d40			 
1d40				; init extent of current open file 
1d40			 
1d40 3e 00			ld a, 0 
1d42 32 53 eb			ld (store_openext), a 
1d45			 
1d45 c9				ret 
1d46			 
1d46			 
1d46			; Cold Start - this is called to setup the whole Forth system 
1d46			 
1d46			forth_init: 
1d46			 
1d46				; setup stack over/under flow checks 
1d46			 
1d46			;	if DEBUG_FORTH_STACK_GUARD 
1d46			;		call chk_stk_init 
1d46			;	endif 
1d46			 
1d46				; enable auto display updates (slow.....) 
1d46			 
1d46 3e 01			ld a, 1 
1d48 32 1e eb			ld (cli_autodisplay), a 
1d4b			 
1d4b			 
1d4b			 
1d4b				; show start up screen 
1d4b			 
1d4b cd 80 09			call clear_display 
1d4e			 
1d4e 3e 00			ld a,0 
1d50 32 40 eb			ld (f_cursor_ptr), a 
1d53			 
1d53				; set start of word list in start of ram - for use when creating user words 
1d53			 
1d53 21 46 59			ld hl, baseram 
1d56 22 54 e6			ld (os_last_new_uword), hl 
1d59 cd ff 1c			call user_word_eol 
1d5c				 
1d5c			;		call display_data_sp 
1d5c			;		call next_page_prompt 
1d5c			 
1d5c			 
1d5c			 
1d5c			 
1d5c c9				ret 
1d5d			 
1d5d .. 00		.bootforth: db " Forth Kernel Init ",0 
1d71			 
1d71			; TODO push to stack 
1d71			 
1d71			;  
1d71			 
1d71			if FORTH_PARSEV2 
1d71			 
1d71			 
1d71				include "forth_parserv2.asm" 
1d71			 
1d71			endif 
1d71			 
1d71			 
1d71			; parse cli version 1 
1d71			 
1d71			if FORTH_PARSEV1 
1d71			 
1d71			 
1d71			 
1d71			      include "forth_parserv1.asm" 
1d71			endif 
1d71				 
1d71			if FORTH_PARSEV3 
1d71			 
1d71			 
1d71			 
1d71			      include "forth_parserv3.asm" 
1d71				include "forth_wordsv3.asm" 
1d71			endif 
1d71			 
1d71			if FORTH_PARSEV4 
1d71			 
1d71			 
1d71			 
1d71			      include "forth_parserv4.asm" 
1d71				include "forth_wordsv4.asm" 
1d71			endif 
1d71			 
1d71			if FORTH_PARSEV5 
1d71			 
1d71			 
1d71			 
1d71			      include "forth_parserv5.asm" 
1d71			 
1d71			 
1d71			; A better parser without using malloc and string copies all over the place.  
1d71			; Exec in situ should be faster 
1d71			 
1d71			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1d71			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1d71			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1d71			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1d71			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1d71			WORD_SYS_END: equ 0   ; Opcode for all user words 
1d71			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1d71			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1d71			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1d71			 
1d71			; Core word preamble macro 
1d71			 
1d71			CWHEAD:   macro nxtword opcode lit len opflags 
1d71				db WORD_SYS_CORE+opcode             
1d71				; internal op code number 
1d71				dw nxtword            
1d71				; link to next dict word block 
1d71				db len + 1 
1d71				; literal length of dict word inc zero term 
1d71				db lit,0              
1d71				; literal dict word 
1d71			        ; TODO db opflags        
1d71				endm 
1d71			 
1d71			 
1d71			NEXTW: macro  
1d71				jp macro_next 
1d71				endm 
1d71			 
1d71			macro_next: 
1d71			if DEBUG_FORTH_PARSE_KEY 
1d71				DMARK "NXT" 
1d71				CALLMONITOR 
1d71			endif	 
1d71			;	inc hl  ; skip token null term  
1d71 ed 4b 22 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1d75 ed 5b 20 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1d79 2a 58 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1d7c			if DEBUG_FORTH_PARSE_KEY 
1d7c				DMARK "}AA" 
1d7c				CALLMONITOR 
1d7c			endif	 
1d7c c3 7f 1e			jp execnext 
1d7f				;jp exec1 
1d7f			       
1d7f			 
1d7f			 
1d7f			; Another go at the parser to compile  
1d7f			 
1d7f			 
1d7f			; TODO rework parser to change all of the string words to byte tokens 
1d7f			; TODO do a search for  
1d7f			 
1d7f			; TODO first run normal parser to zero term sections 
1d7f			; TODO for each word do a token look up to get the op code 
1d7f			; TODO need some means to flag to the exec that this is a byte code form    
1d7f			 
1d7f			 
1d7f			forthcompile: 
1d7f			 
1d7f			; 
1d7f			; line parse: 
1d7f			;       parse raw input buffer 
1d7f			;       tokenise the words 
1d7f			;       malloc new copy (for looping etc) 
1d7f			;       copy to malloc + current pc in line to start of string and add line term 
1d7f			;       save on new rsp 
1d7f			; 
1d7f			 
1d7f			; hl to point to the line to tokenise 
1d7f			 
1d7f			;	push hl 
1d7f 22 58 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1d82			 
1d82			;	ld a,0		; string term on input 
1d82			;	call strlent 
1d82			 
1d82			;	ld (os_tok_len), hl	 ; save string length 
1d82			 
1d82			;if DEBUG_FORTH_TOK 
1d82			;	ex de,hl		 
1d82			;endif 
1d82			 
1d82			;	pop hl 		; get back string pointer 
1d82			 
1d82			if DEBUG_FORTH_TOK 
1d82						DMARK "TOc" 
1d82				CALLMONITOR 
1d82			endif 
1d82 7e			.cptoken2:    ld a,(hl) 
1d83 23				inc hl 
1d84 fe 7f			cp FORTH_END_BUFFER 
1d86 28 29			jr z, .cptokendone2 
1d88 fe 00			cp 0 
1d8a 28 25			jr z, .cptokendone2 
1d8c fe 22			cp '"' 
1d8e 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1d90 fe 20			cp ' ' 
1d92 20 ee			jr nz,  .cptoken2 
1d94			 
1d94			; TODO consume comments held between ( and ) 
1d94			 
1d94				; we have a space so change to zero term for dict match later 
1d94 2b				dec hl 
1d95 3e 00			ld a,0 
1d97 77				ld (hl), a 
1d98 23				inc hl 
1d99 18 e7			jr .cptoken2 
1d9b				 
1d9b			 
1d9b			.cptokenstr2: 
1d9b				; skip all white space until either eol (because forgot to term) or end double quote 
1d9b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1d9b				;inc hl ; skip current double quote 
1d9b 7e				ld a,(hl) 
1d9c 23				inc hl 
1d9d fe 22			cp '"' 
1d9f 28 e1			jr z, .cptoken2 
1da1 fe 7f			cp FORTH_END_BUFFER 
1da3 28 0c			jr z, .cptokendone2 
1da5 fe 00			cp 0 
1da7 28 08			jr z, .cptokendone2 
1da9 fe 20			cp ' ' 
1dab 28 02			jr z, .cptmp2 
1dad 18 ec			jr .cptokenstr2 
1daf			 
1daf			.cptmp2:	; we have a space so change to zero term for dict match later 
1daf				;dec hl 
1daf				;ld a,"-"	; TODO remove this when working 
1daf				;ld (hl), a 
1daf				;inc hl 
1daf 18 ea			jr .cptokenstr2 
1db1			 
1db1			.cptokendone2: 
1db1				;inc hl 
1db1 3e 7f			ld a, FORTH_END_BUFFER 
1db3 77				ld (hl),a 
1db4 23				inc hl 
1db5 3e 21			ld a, '!' 
1db7 77				ld (hl),a 
1db8			 
1db8 2a 58 e6			ld hl,(os_tok_ptr) 
1dbb			         
1dbb			if DEBUG_FORTH_TOK 
1dbb						DMARK "Tc1" 
1dbb				CALLMONITOR 
1dbb			endif 
1dbb			 
1dbb				; push exec string to top of return stack 
1dbb				FORTH_RSP_NEXT 
1dbb cd af 19			call macro_forth_rsp_next 
1dbe				endm 
# End of macro FORTH_RSP_NEXT
1dbe c9				ret 
1dbf			 
1dbf			; Another go at the parser need to simplify the process 
1dbf			 
1dbf			forthparse: 
1dbf			 
1dbf			; 
1dbf			; line parse: 
1dbf			;       parse raw input buffer 
1dbf			;       tokenise the words 
1dbf			;       malloc new copy (for looping etc) 
1dbf			;       copy to malloc + current pc in line to start of string and add line term 
1dbf			;       save on new rsp 
1dbf			; 
1dbf			 
1dbf			; hl to point to the line to tokenise 
1dbf			 
1dbf			;	push hl 
1dbf 22 58 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1dc2			 
1dc2			;	ld a,0		; string term on input 
1dc2			;	call strlent 
1dc2			 
1dc2			;	ld (os_tok_len), hl	 ; save string length 
1dc2			 
1dc2			;if DEBUG_FORTH_TOK 
1dc2			;	ex de,hl		 
1dc2			;endif 
1dc2			 
1dc2			;	pop hl 		; get back string pointer 
1dc2			 
1dc2			if DEBUG_FORTH_TOK 
1dc2						DMARK "TOK" 
1dc2				CALLMONITOR 
1dc2			endif 
1dc2 7e			.ptoken2:    ld a,(hl) 
1dc3 23				inc hl 
1dc4 fe 7f			cp FORTH_END_BUFFER 
1dc6 28 29			jr z, .ptokendone2 
1dc8 fe 00			cp 0 
1dca 28 25			jr z, .ptokendone2 
1dcc fe 22			cp '"' 
1dce 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1dd0 fe 20			cp ' ' 
1dd2 20 ee			jr nz,  .ptoken2 
1dd4			 
1dd4			; TODO consume comments held between ( and ) 
1dd4			 
1dd4				; we have a space so change to zero term for dict match later 
1dd4 2b				dec hl 
1dd5 3e 00			ld a,0 
1dd7 77				ld (hl), a 
1dd8 23				inc hl 
1dd9 18 e7			jr .ptoken2 
1ddb				 
1ddb			 
1ddb			.ptokenstr2: 
1ddb				; skip all white space until either eol (because forgot to term) or end double quote 
1ddb			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1ddb				;inc hl ; skip current double quote 
1ddb 7e				ld a,(hl) 
1ddc 23				inc hl 
1ddd fe 22			cp '"' 
1ddf 28 e1			jr z, .ptoken2 
1de1 fe 7f			cp FORTH_END_BUFFER 
1de3 28 0c			jr z, .ptokendone2 
1de5 fe 00			cp 0 
1de7 28 08			jr z, .ptokendone2 
1de9 fe 20			cp ' ' 
1deb 28 02			jr z, .ptmp2 
1ded 18 ec			jr .ptokenstr2 
1def			 
1def			.ptmp2:	; we have a space so change to zero term for dict match later 
1def				;dec hl 
1def				;ld a,"-"	; TODO remove this when working 
1def				;ld (hl), a 
1def				;inc hl 
1def 18 ea			jr .ptokenstr2 
1df1			 
1df1			.ptokendone2: 
1df1				;inc hl 
1df1 3e 7f			ld a, FORTH_END_BUFFER 
1df3 77				ld (hl),a 
1df4 23				inc hl 
1df5 3e 21			ld a, '!' 
1df7 77				ld (hl),a 
1df8			 
1df8 2a 58 e6			ld hl,(os_tok_ptr) 
1dfb			         
1dfb			if DEBUG_FORTH_TOK 
1dfb						DMARK "TK1" 
1dfb				CALLMONITOR 
1dfb			endif 
1dfb			 
1dfb				; push exec string to top of return stack 
1dfb				FORTH_RSP_NEXT 
1dfb cd af 19			call macro_forth_rsp_next 
1dfe				endm 
# End of macro FORTH_RSP_NEXT
1dfe c9				ret 
1dff			 
1dff			; 
1dff			;	; malloc size + buffer pointer + if is loop flag 
1dff			;	ld hl,(os_tok_len) 		 ; get string length 
1dff			; 
1dff			;	ld a,l 
1dff			; 
1dff			;	cp 0			; we dont want to use a null string 
1dff			;	ret z 
1dff			; 
1dff			;;	add 3    ; prefix malloc with buffer for current word ptr 
1dff			; 
1dff			;	add 5     ; TODO when certain not over writing memory remove 
1dff			; 
1dff			;		 
1dff			; 
1dff			;if DEBUG_FORTH_TOK 
1dff			;			DMARK "TKE" 
1dff			;	CALLMONITOR 
1dff			;endif 
1dff			; 
1dff			;	ld l,a 
1dff			;	ld h,0 
1dff			;;	push hl   ; save required space for the copy later 
1dff			;	call malloc 
1dff			;if DEBUG_FORTH_TOK 
1dff			;			DMARK "TKM" 
1dff			;	CALLMONITOR 
1dff			;endif 
1dff			;	if DEBUG_FORTH_MALLOC_GUARD 
1dff			;		push af 
1dff			;		call ishlzero 
1dff			;;		ld a, l 
1dff			;;		add h 
1dff			;;		cp 0 
1dff			;		pop af 
1dff			;		 
1dff			;		call z,malloc_error 
1dff			;	endif 
1dff			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1dff			; 
1dff			; 
1dff			;if DEBUG_FORTH_TOK 
1dff			;			DMARK "TKR" 
1dff			;	CALLMONITOR 
1dff			;endif 
1dff			; 
1dff			;	FORTH_RSP_NEXT 
1dff			; 
1dff			;	;inc hl	 ; go past current buffer pointer 
1dff			;	;inc hl 
1dff			;	;inc hl   ; and past if loop flag 
1dff			;		; TODO Need to set flag  
1dff			; 
1dff			;	 
1dff			;	 
1dff			;	ex de,hl	; malloc is dest 
1dff			;	ld hl, (os_tok_len) 
1dff			;;	pop bc 
1dff			;	ld c, l                
1dff			;	ld b,0 
1dff			;	ld hl, (os_tok_ptr) 
1dff			; 
1dff			;if DEBUG_FORTH_TOK 
1dff			;			DMARK "TKT" 
1dff			;	CALLMONITOR 
1dff			;endif 
1dff			; 
1dff			;	; do str cpy 
1dff			; 
1dff			;	ldir      ; copy byte in hl to de 
1dff			; 
1dff			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1dff			; 
1dff			;if DEBUG_FORTH_TOK 
1dff			; 
1dff			;			DMARK "TKY" 
1dff			;	CALLMONITOR 
1dff			;endif 
1dff			;	;ld a,0 
1dff			;	;ld a,FORTH_END_BUFFER 
1dff			;	ex de, hl 
1dff			;	;dec hl			 ; go back over the space delim at the end of word 
1dff			;	;ld (hl),a 
1dff			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1dff			;	ld a,FORTH_END_BUFFER 
1dff			;	ld (hl),a 
1dff			;	inc hl 
1dff			;	ld a,FORTH_END_BUFFER 
1dff			;	ld (hl),a 
1dff			; 
1dff			;	; init the malloc area data 
1dff			;	; set pc for in current area 
1dff			;	;ld hl, (os_tok_malloc) 
1dff			;	;inc hl 
1dff			;	;inc hl 
1dff			;	;inc hl 
1dff			;	;ex de,hl 
1dff			;	;ld hl, (os_tok_malloc) 
1dff			;	;ld (hl),e 
1dff			;	;inc hl 
1dff			;	;ld (hl),d 
1dff			; 
1dff			; 
1dff			;	ld hl,(os_tok_malloc) 
1dff			;if DEBUG_FORTH_PARSE_KEY 
1dff			;			DMARK "TKU" 
1dff			;	CALLMONITOR 
1dff			;endif 
1dff			; 
1dff			;	ret 
1dff			 
1dff			forthexec: 
1dff			 
1dff			; line exec: 
1dff			; forth parser 
1dff			 
1dff			; 
1dff			;       get current exec line on rsp 
1dff			 
1dff				FORTH_RSP_TOS 
1dff cd c6 19			call macro_forth_rsp_tos 
1e02				endm 
# End of macro FORTH_RSP_TOS
1e02			 
1e02			;       restore current pc - hl points to malloc of data 
1e02			 
1e02				;ld e, (hl) 
1e02				;inc hl 
1e02				;ld d, (hl) 
1e02				;ex de,hl 
1e02			 
1e02			 
1e02			exec1: 
1e02 22 58 e6			ld (os_tok_ptr), hl 
1e05			 
1e05				; copy our PC to working vars  
1e05 22 22 eb			ld (cli_ptr), hl 
1e08 22 20 eb			ld (cli_origptr), hl 
1e0b			 
1e0b 7e				ld a,(hl) 
1e0c fe 7f			cp FORTH_END_BUFFER 
1e0e c8				ret z 
1e0f			 
1e0f				; skip any nulls 
1e0f			 
1e0f fe 00			cp 0 
1e11 20 03			jr nz, .execword 
1e13 23				inc hl 
1e14 18 ec			jr exec1 
1e16			 
1e16			 
1e16			.execword: 
1e16			 
1e16			 
1e16			 
1e16			if DEBUG_FORTH_PARSE_KEY 
1e16						DMARK "KYQ" 
1e16				CALLMONITOR 
1e16			endif 
1e16			;       while at start of word: 
1e16			; get start of dict (in user area first) 
1e16			 
1e16 21 46 59		ld hl, baseram 
1e19			;ld hl, sysdict 
1e19 22 24 eb		ld (cli_nextword),hl 
1e1c			;           match word at pc 
1e1c			;           exec word 
1e1c			;           or push to dsp 
1e1c			;           forward to next token 
1e1c			;           if line term pop rsp and exit 
1e1c			;        
1e1c			 
1e1c			if DEBUG_FORTH_PARSE_KEY 
1e1c						DMARK "KYq" 
1e1c				CALLMONITOR 
1e1c			endif 
1e1c			 
1e1c			; 
1e1c			; word comp 
1e1c			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1e1c			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1e1c			;    move to start of word  
1e1c			;    compare word to cli_token 
1e1c			 
1e1c			.execpnword:	; HL at start of a word in the dictionary to check 
1e1c			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1e1c			;	ld (cli_ptr), hl 
1e1c			 
1e1c 2a 24 eb			ld hl,(cli_nextword) 
1e1f			 
1e1f cd c2 1e			call forth_tok_next 
1e22			; tok next start here 
1e22			;	; TODO skip compiled symbol for now 
1e22			;	inc hl 
1e22			; 
1e22			;	; save pointer to next word 
1e22			; 
1e22			;	; hl now points to the address of the next word pointer  
1e22			;	ld e, (hl) 
1e22			;	inc hl 
1e22			;	ld d, (hl) 
1e22			;	inc l 
1e22			; 
1e22			;	ex de,hl 
1e22			;if DEBUG_FORTH_PARSE_NEXTWORD 
1e22			;	push bc 
1e22			;	ld bc, (cli_nextword) 
1e22			;			DMARK "NXW" 
1e22			;	CALLMONITOR 
1e22			;	pop bc 
1e22			;endif 
1e22			; tok next end here 
1e22 22 24 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1e25 eb				ex de, hl 
1e26			 
1e26			 
1e26				; save the pointer of the current token - 1 to check against 
1e26				 
1e26 22 28 eb			ld (cli_token), hl   
1e29				; TODO maybe remove below save if no debug 
1e29				; save token string ptr for any debug later 
1e29 23				inc hl  
1e2a 22 2a eb			ld (cli_origtoken), hl 
1e2d 2b				dec hl 
1e2e				; save pointer to the start of the next dictionay word 
1e2e 7e				ld a,(hl)   ; get string length 
1e2f 47				ld b,a 
1e30			.execpnwordinc:  
1e30 23				inc hl 
1e31 10 fd			djnz .execpnwordinc 
1e33 22 26 eb			ld (cli_execword), hl      ; save start of this words code 
1e36			 
1e36				; now check the word token against the string being parsed 
1e36			 
1e36 2a 28 eb			ld hl,(cli_token) 
1e39 23				inc hl     ; skip string length (use zero term instead to end) 
1e3a 22 28 eb			ld (cli_token), hl 
1e3d			 
1e3d			if DEBUG_FORTH_PARSE_KEY 
1e3d						DMARK "KY2" 
1e3d			endif 
1e3d			if DEBUG_FORTH_PARSE_EXEC 
1e3d				; see if disabled 
1e3d			 
1e3d				ld a, (os_view_disable) 
1e3d				cp '*' 
1e3d				jr z, .skip 
1e3d			 
1e3d				push hl 
1e3d				push hl 
1e3d				call clear_display 
1e3d				ld de, .compword 
1e3d				ld a, display_row_1 
1e3d				call str_at_display 
1e3d				pop de 
1e3d				ld a, display_row_2 
1e3d				call str_at_display 
1e3d				ld hl,(cli_ptr) 
1e3d				ld a,(hl) 
1e3d			        ld hl, os_word_scratch 
1e3d				ld (hl),a 
1e3d				ld a,0 
1e3d				inc hl 
1e3d				ld (hl),a 	 
1e3d				ld de, os_word_scratch 
1e3d				ld a, display_row_2+10 
1e3d				call str_at_display 
1e3d				call update_display 
1e3d				ld a, 100 
1e3d				call aDelayInMS 
1e3d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e3d				call delay250ms 
1e3d				endif 
1e3d				pop hl 
1e3d			.skip:  
1e3d			endif	 
1e3d			.execpnchar:    ; compare char between token and string to parse 
1e3d			 
1e3d			if DEBUG_FORTH_PARSE_KEY 
1e3d						DMARK "Ky3" 
1e3d			endif 
1e3d			if DEBUG_FORTH_PARSE_EXEC 
1e3d				; see if disabled 
1e3d			 
1e3d				ld a, (os_view_disable) 
1e3d				cp '*' 
1e3d				jr z, .skip2 
1e3d			 
1e3d			;	call clear_display 
1e3d			ld hl,(cli_token) 
1e3d			ld a,(hl) 
1e3d			ld (os_word_scratch),a 
1e3d				ld hl,(cli_ptr) 
1e3d			ld a,(hl) 
1e3d				ld (os_word_scratch+1),a 
1e3d				ld a,0 
1e3d				ld (os_word_scratch+2),a 
1e3d				ld de,os_word_scratch 
1e3d				ld a,display_row_4 
1e3d				call str_at_display 
1e3d				call update_display 
1e3d			.skip2:  
1e3d			endif 
1e3d 2a 28 eb			ld hl,(cli_token) 
1e40 7e				ld a, (hl)	 ; char in word token 
1e41 23				inc hl 		; move to next char 
1e42 22 28 eb			ld (cli_token), hl ; and save it 
1e45 47				ld b,a 
1e46			 
1e46 2a 22 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1e49 7e				ld a,(hl) 
1e4a 23				inc hl 
1e4b 22 22 eb			ld (cli_ptr), hl		; move to next char 
1e4e cd 02 10			call toUpper 		; make sure the input string matches case 
1e51			 
1e51			if DEBUG_FORTH_PARSE 
1e51			endif 
1e51			 
1e51				; input stream end of token is a space so get rid of it 
1e51			 
1e51			;	cp ' ' 
1e51			;	jr nz, .pnskipspace 
1e51			; 
1e51			;	ld a, 0		; make same term as word token term 
1e51			; 
1e51			;.pnskipspace: 
1e51			 
1e51			if DEBUG_FORTH_PARSE_KEY 
1e51						DMARK "KY7" 
1e51			endif 
1e51 b8				cp b 
1e52 c2 68 1e			jp nz, .execpnskipword	 ; no match so move to next word 
1e55				 
1e55			;    if same 
1e55			;       scan for string terms 0 for token and 32 for input 
1e55			 
1e55				 
1e55			if DEBUG_FORTH_PARSE_KEY 
1e55						DMARK "KY8" 
1e55			endif 
1e55			 
1e55 80				add b			 
1e56 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1e58							; TODO need to make sure last word in zero term string is accounted for 
1e58 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1e5a			 
1e5a			 
1e5a				; at end of both strings so both are exact match 
1e5a			 
1e5a			;       skip ptr for next word 
1e5a			 
1e5a 2a 22 eb			ld hl,(cli_ptr) 	; at input string term 
1e5d 23				inc hl			 ; at next char 
1e5e 22 22 eb			ld (cli_ptr), hl     ; save for next round of the parser 
1e61 22 20 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1e64				 
1e64				 
1e64			if DEBUG_FORTH_PARSE_KEY 
1e64						DMARK "KY3" 
1e64			endif 
1e64			 
1e64			 
1e64			 
1e64			;       exec code block 
1e64			if DEBUG_FORTH_JP 
1e64				call clear_display 
1e64				call update_display 
1e64				call delay1s 
1e64				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e64				ld a,h 
1e64				ld hl, os_word_scratch 
1e64				call hexout 
1e64				ld hl, (cli_execword)     ; save for next check if no match on this word 
1e64				ld a,l 
1e64				ld hl, os_word_scratch+2 
1e64				call hexout 
1e64				ld hl, os_word_scratch+4 
1e64				ld a,0 
1e64				ld (hl),a 
1e64				ld de,os_word_scratch 
1e64				call str_at_display 
1e64					ld a, display_row_2 
1e64					call str_at_display 
1e64				ld de, (cli_origtoken) 
1e64				ld a, display_row_1+10 
1e64					call str_at_display 
1e64			 
1e64				ld a,display_row_1 
1e64				ld de, .foundword 
1e64				ld a, display_row_3 
1e64				call str_at_display 
1e64				call update_display 
1e64				call delay1s 
1e64				call delay1s 
1e64				call delay1s 
1e64			endif 
1e64			 
1e64			if DEBUG_FORTH_PARSE_KEY 
1e64						DMARK "KYj" 
1e64			endif 
1e64				; TODO save the word pointer in this exec 
1e64			 
1e64 2a 26 eb			ld hl,(cli_execword) 
1e67 e9				jp (hl) 
1e68			 
1e68			 
1e68			;    if not same 
1e68			;	scan for zero term 
1e68			;	get ptr for next word 
1e68			;	goto word comp 
1e68			 
1e68			.execpnskipword:	; get pointer to next word 
1e68 2a 24 eb			ld hl,(cli_nextword) 
1e6b			 
1e6b 7e				ld a,(hl) 
1e6c fe 00			cp WORD_SYS_END 
1e6e			;	cp 0 
1e6e 28 09			jr z, .execendofdict			 ; at end of words 
1e70			 
1e70			if DEBUG_FORTH_PARSE_KEY 
1e70						DMARK "KY4" 
1e70			endif 
1e70			if DEBUG_FORTH_PARSE_EXEC 
1e70			 
1e70				; see if disabled 
1e70			 
1e70				ld a, (os_view_disable) 
1e70				cp '*' 
1e70				jr z, .noskip 
1e70			 
1e70			 
1e70				ld de, .nowordfound 
1e70				ld a, display_row_3 
1e70				call str_at_display 
1e70				call update_display 
1e70				ld a, 100 
1e70				call aDelayInMS 
1e70				 
1e70				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e70					call delay250ms 
1e70				endif 
1e70			.noskip:  
1e70			 
1e70			endif	 
1e70			 
1e70 2a 20 eb			ld hl,(cli_origptr) 
1e73 22 22 eb			ld (cli_ptr),hl 
1e76			 
1e76			if DEBUG_FORTH_PARSE_KEY 
1e76						DMARK "KY5" 
1e76			endif 
1e76 c3 1c 1e			jp .execpnword			; else go to next word 
1e79			 
1e79			.execendofdict:  
1e79			 
1e79			if DEBUG_FORTH_PARSE_KEY 
1e79						DMARK "KYe" 
1e79			endif 
1e79			if DEBUG_FORTH_PARSE_EXEC 
1e79				; see if disabled 
1e79			 
1e79				ld a, (os_view_disable) 
1e79				cp '*' 
1e79				jr z, .ispskip 
1e79			 
1e79				call clear_display 
1e79				call update_display 
1e79				call delay1s 
1e79				ld de, (cli_origptr) 
1e79				ld a, display_row_1 
1e79				call str_at_display 
1e79				 
1e79				ld de, .enddict 
1e79				ld a, display_row_3 
1e79				call str_at_display 
1e79				call update_display 
1e79				ld a, 100 
1e79				call aDelayInMS 
1e79				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1e79				call delay1s 
1e79				call delay1s 
1e79				call delay1s 
1e79				endif 
1e79			.ispskip:  
1e79				 
1e79			endif	 
1e79			 
1e79			 
1e79			 
1e79				; if the word is not a keyword then must be a literal so push it to stack 
1e79			 
1e79			; push token to stack to end of word 
1e79			 
1e79				STACKFRAME ON $1efe $2f9f 
1e79				if DEBUG_STACK_IMB 
1e79					if ON 
1e79						exx 
1e79						ld de, $1efe 
1e79						ld a, d 
1e79						ld hl, curframe 
1e79						call hexout 
1e79						ld a, e 
1e79						ld hl, curframe+2 
1e79						call hexout 
1e79						ld hl, $1efe 
1e79						push hl 
1e79						ld hl, $2f9f 
1e79						push hl 
1e79						exx 
1e79					endif 
1e79				endif 
1e79			endm 
# End of macro STACKFRAME
1e79			 
1e79 2a 58 e6		ld hl,(os_tok_ptr) 
1e7c cd 71 1b		call forth_apush 
1e7f			 
1e7f				STACKFRAMECHK ON $1efe $2f9f 
1e7f				if DEBUG_STACK_IMB 
1e7f					if ON 
1e7f						exx 
1e7f						ld hl, $2f9f 
1e7f						pop de   ; $2f9f 
1e7f						call cmp16 
1e7f						jr nz, .spnosame 
1e7f						ld hl, $1efe 
1e7f						pop de   ; $1efe 
1e7f						call cmp16 
1e7f						jr z, .spfrsame 
1e7f						.spnosame: call showsperror 
1e7f						.spfrsame: nop 
1e7f						exx 
1e7f					endif 
1e7f				endif 
1e7f			endm 
# End of macro STACKFRAMECHK
1e7f			 
1e7f			execnext: 
1e7f			 
1e7f			if DEBUG_FORTH_PARSE_KEY 
1e7f						DMARK "KY>" 
1e7f			endif 
1e7f			; move past token to next word 
1e7f			 
1e7f 2a 58 e6		ld hl, (os_tok_ptr) 
1e82 3e 00		ld a, 0 
1e84 01 ff 00		ld bc, 255     ; input buffer size 
1e87 ed b1		cpir 
1e89			 
1e89			if DEBUG_FORTH_PARSE_KEY 
1e89						DMARK "KY!" 
1e89				CALLMONITOR 
1e89			endif	 
1e89			; TODO this might place hl on the null, so will need to forward on??? 
1e89			;inc hl   ; see if this gets onto the next item 
1e89			 
1e89			 
1e89			; TODO pass a pointer to the buffer to push 
1e89			; TODO call function to push 
1e89			 
1e89			; look for end of input 
1e89			 
1e89			;inc hl 
1e89			;ld a,(hl) 
1e89			;cp FORTH_END_BUFFER 
1e89			;ret z 
1e89			 
1e89			 
1e89 c3 02 1e		jp exec1 
1e8c			 
1e8c			 
1e8c			 
1e8c			 
1e8c			 
1e8c			 
1e8c			 
1e8c			 
1e8c			 
1e8c			findnexttok: 
1e8c			 
1e8c				; hl is pointer to move 
1e8c				; de is the token to locate 
1e8c			 
1e8c					if DEBUG_FORTH 
1e8c						DMARK "NTK" 
1e8c						CALLMONITOR 
1e8c					endif 
1e8c d5				push de 
1e8d			 
1e8d			.fnt1:	 
1e8d				; find first char of token to locate 
1e8d			 
1e8d 1a				ld a, (de) 
1e8e 4f				ld c,a 
1e8f 7e				ld a,(hl) 
1e90 cd 02 10			call toUpper 
1e93					if DEBUG_FORTH 
1e93						DMARK "NT1" 
1e93						CALLMONITOR 
1e93					endif 
1e93 b9				cp c 
1e94			 
1e94 28 03			jr z, .fnt2cmpmorefirst	 
1e96			 
1e96				; first char not found move to next char 
1e96			 
1e96 23				inc hl 
1e97 18 f4			jr .fnt1 
1e99			 
1e99			.fnt2cmpmorefirst:	 
1e99				; first char of token found.  
1e99			 
1e99 e5				push hl     ; save start of token just in case it is the right one 
1e9a d9				exx 
1e9b e1				pop hl        ; save it to hl' 
1e9c d9				exx 
1e9d			 
1e9d			 
1e9d			.fnt2cmpmore:	 
1e9d				; compare the rest 
1e9d				 
1e9d 23				inc hl 
1e9e 13				inc de 
1e9f				 
1e9f 1a				ld a, (de) 
1ea0 4f				ld c,a 
1ea1 7e				ld a,(hl) 
1ea2 cd 02 10			call toUpper 
1ea5			 
1ea5					if DEBUG_FORTH 
1ea5						DMARK "NT2" 
1ea5						CALLMONITOR 
1ea5					endif 
1ea5				; c has the token to find char 
1ea5				; a has the mem to scan char 
1ea5			 
1ea5 b9				cp c 
1ea6 28 04			jr z,.fntmatch1 
1ea8			 
1ea8				; they are not the same 
1ea8			 
1ea8					if DEBUG_FORTH 
1ea8						DMARK "NT3" 
1ea8						CALLMONITOR 
1ea8					endif 
1ea8 d1				pop de	; reset de token to look for 
1ea9 d5				push de 
1eaa 18 e1			jr .fnt1 
1eac				 
1eac			.fntmatch1: 
1eac			 
1eac				; is the same char a null which means we might have a full hit? 
1eac					if DEBUG_FORTH 
1eac						DMARK "NT4" 
1eac						CALLMONITOR 
1eac					endif 
1eac			 
1eac fe 00			cp 0 
1eae 28 0b			jr z, .fntmatchyes 
1eb0			 
1eb0				; are we at the end of the token to find? 
1eb0			 
1eb0					if DEBUG_FORTH 
1eb0						DMARK "NT5" 
1eb0						CALLMONITOR 
1eb0					endif 
1eb0 3e 00			ld a, 0 
1eb2 b9				cp c 
1eb3			 
1eb3 c2 9d 1e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1eb6			 
1eb6					if DEBUG_FORTH 
1eb6						DMARK "NT6" 
1eb6						CALLMONITOR 
1eb6					endif 
1eb6				; token to find is exhusted but no match to stream 
1eb6			 
1eb6				; restore tok pointer and continue on 
1eb6 d1				pop de 
1eb7 d5				push de 
1eb8 c3 8d 1e			jp .fnt1 
1ebb			 
1ebb			 
1ebb			.fntmatchyes: 
1ebb			 
1ebb				; hl now contains the end of the found token 
1ebb			 
1ebb				; get rid of saved token pointer to find 
1ebb			 
1ebb d1				pop de 
1ebc			 
1ebc					if DEBUG_FORTH 
1ebc						DMARK "NT9" 
1ebc						CALLMONITOR 
1ebc					endif 
1ebc			 
1ebc				; hl will be on the null term so forward on 
1ebc			 
1ebc				; get back the saved start of the token 
1ebc			 
1ebc d9				exx 
1ebd e5				push hl     ; save start of token just in case it is the right one 
1ebe d9				exx 
1ebf e1				pop hl        ; save it to hl 
1ec0			 
1ec0 c9				ret 
1ec1			 
1ec1			 
1ec1			; LIST needs to find a specific token   
1ec1			; FORGET needs to find a spefici token 
1ec1			 
1ec1			; SAVE needs to find all tokens by flag 
1ec1			; WORDS just needs to scan through all  by flag 
1ec1			; UWORDS needs to scan through all by flag 
1ec1			 
1ec1			 
1ec1			; given hl as pointer to start of dict look up string 
1ec1			; return hl as pointer to start of word block 
1ec1			; or 0 if not found 
1ec1			 
1ec1			forth_find_tok: 
1ec1 c9				ret 
1ec2			 
1ec2			; given hl as pointer to dict structure 
1ec2			; move to the next dict block structure 
1ec2			 
1ec2			forth_tok_next: 
1ec2				; hl now points to the address of the next word pointer  
1ec2				; TODO skip compiled symbol for now 
1ec2			;	push de 
1ec2 23				inc hl 
1ec3 5e				ld e, (hl) 
1ec4 23				inc hl 
1ec5 56				ld d, (hl) 
1ec6 23				inc hl 
1ec7			 
1ec7 eb				ex de,hl 
1ec8			if DEBUG_FORTH_PARSE_NEXTWORD 
1ec8				push bc 
1ec8				ld bc, (cli_nextword) 
1ec8						DMARK "NXW" 
1ec8				CALLMONITOR 
1ec8				pop bc 
1ec8			endif 
1ec8			;	pop de	 
1ec8 c9				ret 
1ec9			 
1ec9			 
1ec9			 
1ec9			; eof 
# End of file forth_parserv5.asm
1ec9				include "forth_wordsv4.asm" 
1ec9			 
1ec9			; the core word dictionary v4 
1ec9			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1ec9			 
1ec9			; this is a linked list for each of the system words used 
1ec9			; user defined words will follow the same format but will be in ram 
1ec9			 
1ec9			 
1ec9			; 
1ec9			; 
1ec9			; define linked list: 
1ec9			; 
1ec9			; 1. compiled byte op code 
1ec9			; 2. len of text word 
1ec9			; 3. text word 
1ec9			; 4. ptr to next dictionary word 
1ec9			; 5. asm, calls etc for the word 
1ec9			; 
1ec9			;  if 1 == 0 then last word in dict  
1ec9			;   
1ec9			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1ec9			;  
1ec9			;  
1ec9			; create basic standard set of words 
1ec9			; 
1ec9			;  
1ec9			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1ec9			; 2DUP 2DROP 2SWAP  
1ec9			; @ C@ - get byte  
1ec9			; ! C! - store byte 
1ec9			; 0< true if less than zero 
1ec9			; 0= true if zero 
1ec9			; < >  
1ec9			; = true if same 
1ec9			; variables 
1ec9			 
1ec9			 
1ec9			; Hardware specific words I may need 
1ec9			; 
1ec9			; IN OUT  
1ec9			; calls to key util functions 
1ec9			; calls to hardward abstraction stuff 
1ec9			; easy control of frame buffers and lcd i/o 
1ec9			; keyboard  
1ec9			 
1ec9			 
1ec9			;DICT: macro 
1ec9			; op_code, len, word, next 
1ec9			;    word: 
1ec9			;    db op_code 
1ec9			;    ds word zero term 
1ec9			;    dw next 
1ec9			;    endm 
1ec9			 
1ec9			 
1ec9			 
1ec9			 
1ec9			; op code 1 is a flag for user define words which are to be handled differently 
1ec9			 
1ec9			 
1ec9			; 
1ec9			; 
1ec9			;    TODO on entry to a word this should be the expected environment 
1ec9			;    hl - tos value if number then held, if string this is the ptr 
1ec9			;    de -  
1ec9			 
1ec9			 
1ec9			; opcode ranges 
1ec9			; 0 - end of word dict 
1ec9			; 255 - user define words 
1ec9			 
1ec9			sysdict: 
1ec9			include "forth_opcodes.asm" 
1ec9			; op codes for forth keywords 
1ec9			; free to use code 0  
1ec9				OPCODE_HEAP: equ  1 
1ec9				OPCODE_EXEC: equ 2 
1ec9				OPCODE_DUP: equ 3 
1ec9				OPCODE_SWAP: equ 4 
1ec9				OPCODE_COLN: equ 5 
1ec9				OPCODE_SCOLN: equ 6 
1ec9				OPCODE_DROP: equ 7 
1ec9				OPCODE_DUP2: equ 8 
1ec9				OPCODE_DROP2: equ 9 
1ec9				OPCODE_SWAP2: equ 10 
1ec9				OPCODE_AT: equ 11 
1ec9				OPCODE_CAT: equ 12 
1ec9				OPCODE_BANG: equ 13 
1ec9				OPCODE_CBANG: equ 14 
1ec9				OPCODE_SCALL: equ 15 
1ec9				OPCODE_DEPTH: equ 16 
1ec9				OPCODE_OVER: equ 17 
1ec9				OPCODE_PAUSE: equ 18 
1ec9				OPCODE_PAUSES: equ 19 
1ec9				OPCODE_ROT: equ 20 
1ec9			;free to reuse	OPCODE_WORDS: equ 21 
1ec9			        OPCODE_NOT: equ 21 
1ec9				OPCODE_UWORDS: equ 22 
1ec9				OPCODE_BP: equ 23 
1ec9				OPCODE_MONITOR: equ 24  
1ec9				OPCODE_MALLOC: equ 25 
1ec9				OPCODE_FREE: equ 26 
1ec9				OPCODE_LIST: equ 27 
1ec9				OPCODE_FORGET: equ 28 
1ec9				OPCODE_NOP: equ 29 
1ec9				OPCODE_COMO: equ 30 
1ec9				OPCODE_COMC: equ 31 
1ec9			;free to reuse	OPCODE_ENDCORE: equ 32 
1ec9				OPCODE_AFTERSOUND: equ 33 
1ec9				OPCODE_GP2: equ 34 
1ec9				OPCODE_GP3: equ 35 
1ec9				OPCODE_GP4: equ 36 
1ec9				OPCODE_SIN: equ 37 
1ec9				OPCODE_SOUT: equ 38 
1ec9				OPCODE_SPIO: equ 39 
1ec9				OPCODE_SPICEH: equ 40 
1ec9				OPCODE_SPIOb: equ 41 
1ec9				OPCODE_SPII: equ 42 
1ec9				OPCODE_SESEL: equ 43 
1ec9				OPCODE_CARTDEV: equ 44 
1ec9			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1ec9				OPCODE_FB: equ 46 
1ec9				OPCODE_EMIT: equ 47 
1ec9				OPCODE_DOTH: equ 48 
1ec9				OPCODE_DOTF: equ 49 
1ec9				OPCODE_DOT: equ 50 
1ec9				OPCODE_CLS: equ 51 
1ec9				OPCODE_DRAW: equ 52 
1ec9				OPCODE_DUMP: equ 53 
1ec9				OPCODE_CDUMP: equ 54 
1ec9				OPCODE_DAT: equ 55 
1ec9				OPCODE_HOME: equ 56 
1ec9				OPCODE_SPACE: equ 57 
1ec9				OPCODE_SPACES: equ 58 
1ec9				OPCODE_SCROLL: equ 59 
1ec9				OPCODE_ATQ: equ 60 
1ec9				OPCODE_AUTODSP: equ 61 
1ec9				OPCODE_MENU: equ 62 
1ec9			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1ec9				OPCODE_THEN: equ 64 
1ec9				OPCODE_ELSE: equ 65 
1ec9				OPCODE_DO: equ 66 
1ec9				OPCODE_LOOP: equ 67 
1ec9				OPCODE_I: equ 68 
1ec9				OPCODE_DLOOP: equ 69  
1ec9				OPCODE_REPEAT: equ 70  
1ec9				OPCODE_UNTIL: equ 71 
1ec9				OPCODE_ENDFLOW: equ 72 
1ec9				OPCODE_WAITK: equ 73 
1ec9				OPCODE_ACCEPT: equ 74 
1ec9				OPCODE_EDIT: equ 75 
1ec9			;free to reuse	OPCODE_ENDKEY: equ 76 
1ec9				OPCODE_LZERO: equ 77 
1ec9				OPCODE_TZERO: equ 78 
1ec9				OPCODE_LESS: equ 79 
1ec9				OPCODE_GT: equ 80 
1ec9				OPCODE_EQUAL: equ 81  
1ec9			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1ec9				OPCODE_NEG: equ 83 
1ec9				OPCODE_DIV: equ 84 
1ec9				OPCODE_MUL: equ 85 
1ec9				OPCODE_MIN: equ 86 
1ec9				OPCODE_MAX: equ 87 
1ec9				OPCODE_RND16: equ 88 
1ec9				OPCODE_RND8: equ 89 
1ec9				OPCODE_RND: equ 90 
1ec9			;free to reuse	OPCODE_ENDMATHS: equ 91  
1ec9				OPCODE_BYNAME: equ 92 
1ec9				OPCODE_DIR: equ 93 
1ec9				OPCODE_SAVE: equ 94 
1ec9				OPCODE_LOAD: equ 95 
1ec9				OPCODE_BSAVE: equ 96 
1ec9				OPCODE_BLOAD: equ 97 
1ec9				OPCODE_SEO: equ 98  
1ec9				OPCODE_SEI: equ 99 
1ec9				OPCODE_SFREE: equ 100 
1ec9				OPCODE_SIZE: equ 101 
1ec9				OPCODE_CREATE: equ 102 
1ec9				OPCODE_APPEND: equ 103 
1ec9				OPCODE_SDEL: equ 104 
1ec9				OPCODE_OPEN: equ 105 
1ec9				OPCODE_READ: equ 106 
1ec9				OPCODE_EOF: equ 106 
1ec9				OPCODE_FORMAT: equ 107 
1ec9				OPCODE_LABEL: equ 108 
1ec9				OPCODE_LABELS: equ 109 
1ec9			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1ec9				OPCODE_UPPER: equ 111 
1ec9				OPCODE_LOWER: equ 112 
1ec9				OPCODE_SUBSTR: equ 113 
1ec9				OPCODE_LEFT: equ 114 
1ec9				OPCODE_RIGHT: equ 115 
1ec9				OPCODE_STR2NUM: equ 116 
1ec9				OPCODE_NUM2STR: equ 117 
1ec9				OPCODE_CONCAT: equ 118 
1ec9				OPCODE_FIND: equ 119 
1ec9				OPCODE_LEN: equ 120 
1ec9				OPCODE_CHAR: equ 121 
1ec9			; free to reuse	OPCODE_STRLEN: equ 122 
1ec9			; free to reuse	OPCODE_ENDSTR: equ 123 
1ec9				OPCODE_V0S: equ 124 
1ec9				OPCODE_V0Q: equ 125 
1ec9				OPCODE_V1S: equ 126 
1ec9				OPCODE_V1Q: equ 127 
1ec9				OPCODE_V2S: equ 128 
1ec9				OPCODE_V2Q: equ 129 
1ec9				OPCODE_V3S: equ 130 
1ec9				OPCODE_V3Q: equ 131 
1ec9			;free to reuse	OPCODE_END: equ 132 
1ec9				OPCODE_ZDUP: equ 133 
1ec9			 
1ec9			; eof 
# End of file forth_opcodes.asm
1ec9			 
1ec9			include "forth_words_core.asm" 
1ec9			 
1ec9			; | ## Core Words 
1ec9			 
1ec9			;if MALLOC_4 
1ec9			 
1ec9			.HEAP: 
1ec9				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1ec9 15				db WORD_SYS_CORE+OPCODE_HEAP             
1eca 08 1f			dw .EXEC            
1ecc 05				db 4 + 1 
1ecd .. 00			db "HEAP",0              
1ed2				endm 
# End of macro CWHEAD
1ed2			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1ed2			; | | u1 - Current number of bytes in the heap 
1ed2			; | | u2 - Remaining bytes left on the heap 
1ed2			; | |  
1ed2			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1ed2			 
1ed2			 
1ed2					if DEBUG_FORTH_WORDS_KEY 
1ed2						DMARK "HEP" 
1ed2 f5				push af  
1ed3 3a e7 1e			ld a, (.dmark)  
1ed6 32 71 ee			ld (debug_mark),a  
1ed9 3a e8 1e			ld a, (.dmark+1)  
1edc 32 72 ee			ld (debug_mark+1),a  
1edf 3a e9 1e			ld a, (.dmark+2)  
1ee2 32 73 ee			ld (debug_mark+2),a  
1ee5 18 03			jr .pastdmark  
1ee7 ..			.dmark: db "HEP"  
1eea f1			.pastdmark: pop af  
1eeb			endm  
# End of macro DMARK
1eeb						CALLMONITOR 
1eeb cd ae 13			call break_point_state  
1eee				endm  
# End of macro CALLMONITOR
1eee					endif 
1eee 2a 50 59				ld hl, (free_list )      
1ef1 11 55 59				ld de, heap_start 
1ef4			 
1ef4 ed 52				sbc hl, de  
1ef6			 
1ef6 cd 08 1a				call forth_push_numhl 
1ef9			 
1ef9			 
1ef9 ed 5b 50 59			ld de, (free_list )      
1efd 21 3d e3				ld hl, heap_end 
1f00			 
1f00 ed 52				sbc hl, de 
1f02			 
1f02 cd 08 1a				call forth_push_numhl 
1f05					 
1f05			 
1f05					 
1f05			 
1f05			 
1f05			 
1f05					NEXTW 
1f05 c3 71 1d			jp macro_next 
1f08				endm 
# End of macro NEXTW
1f08			;endif 
1f08			 
1f08			.EXEC: 
1f08			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1f08			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
1f08			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1f08			;; > > 
1f08			;; > >   
1f08			;	STACKFRAME OFF $5efe $5f9f 
1f08			; 
1f08			;		if DEBUG_FORTH_WORDS_KEY 
1f08			;			DMARK "EXE" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			; 
1f08			;	FORTH_DSP_VALUEHL 
1f08			; 
1f08			;	FORTH_DSP_POP 
1f08			; 
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EX1" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			;;	ld e,(hl) 
1f08			;;	inc hl 
1f08			;;	ld d,(hl) 
1f08			;;	ex de,hl 
1f08			; 
1f08			;;		if DEBUG_FORTH_WORDS 
1f08			;;			DMARK "EX2" 
1f08			;;			CALLMONITOR 
1f08			;;		endif 
1f08			;	push hl 
1f08			; 
1f08			;	;ld a, 0 
1f08			;	;ld a, FORTH_END_BUFFER 
1f08			;	call strlenz 
1f08			;	inc hl   ; include zero term to copy 
1f08			;	inc hl   ; include term 
1f08			;	inc hl   ; include term 
1f08			;	ld b,0 
1f08			;	ld c,l 
1f08			;	pop hl 
1f08			;	ld de, execscratch 
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EX3" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			;	ldir 
1f08			; 
1f08			; 
1f08			;	ld hl, execscratch 
1f08			; 
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EXe" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			; 
1f08			;	call forthparse 
1f08			;	call forthexec 
1f08			;;	call forthexec_cleanup 
1f08			;;	call forthparse 
1f08			;;	call forthexec 
1f08			; 
1f08			;	STACKFRAMECHK OFF $5efe $5f9f 
1f08			; 
1f08			;	; an immediate word so no need to process any more words 
1f08			;	ret 
1f08			;	NEXTW 
1f08			 
1f08			; dead code - old version  
1f08			;	FORTH_RSP_NEXT 
1f08			 
1f08			;  
1f08			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f08			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f08			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f08			;	push hl 
1f08			;	push de 
1f08			;	push bc 
1f08			; 
1f08			; 
1f08			;		if DEBUG_FORTH_WORDS_KEY 
1f08			;			DMARK "EXR" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			; 
1f08			; 
1f08			; 
1f08			;	;v5 FORTH_DSP_VALUE 
1f08			;	FORTH_DSP_VALUEHL 
1f08			; 
1f08			;	; TODO do string type checks 
1f08			; 
1f08			;;v5	inc hl   ; skip type 
1f08			; 
1f08			;	push hl  ; source code  
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EX1" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			;	ld a, 0 
1f08			;	call strlent 
1f08			; 
1f08			;	inc hl 
1f08			;	inc hl 
1f08			;	inc hl 
1f08			;	inc hl 
1f08			; 
1f08			;	push hl    ; size 
1f08			; 
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EX2" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			;	call malloc 
1f08			; 
1f08			;	ex de, hl    ; de now contains malloc area 
1f08			;	pop bc   	; get byte count 
1f08			;	pop hl      ; get string to copy 
1f08			; 
1f08			;	push de     ; save malloc for free later 
1f08			; 
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EX3" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			;	ldir       ; duplicate string 
1f08			; 
1f08			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1f08			;	 
1f08			;	; TODO fix the parse would be better than this...  
1f08			;	ex de, hl 
1f08			;	dec hl 
1f08			;	ld a, 0 
1f08			;	ld (hl), a 
1f08			;	dec hl 
1f08			;	ld a, ' ' 
1f08			;	ld (hl), a 
1f08			;	dec hl 
1f08			;	ld (hl), a 
1f08			; 
1f08			;	dec hl 
1f08			;	ld (hl), a 
1f08			; 
1f08			; 
1f08			;	FORTH_DSP_POP  
1f08			; 
1f08			;	pop hl     
1f08			;	push hl    ; save malloc area 
1f08			; 
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EX4" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			; 
1f08			;	call forthparse 
1f08			;	call forthexec 
1f08			;	 
1f08			;	pop hl 
1f08			;	if DEBUG_FORTH_WORDS 
1f08			;		DMARK "EX5" 
1f08			;		CALLMONITOR 
1f08			;	endif 
1f08			; 
1f08			;	if FORTH_ENABLE_FREE 
1f08			;	call free 
1f08			;	endif 
1f08			; 
1f08			;	if DEBUG_FORTH_WORDS 
1f08			;		DMARK "EX6" 
1f08			;		CALLMONITOR 
1f08			;	endif 
1f08			; 
1f08			;	pop bc 
1f08			;	pop de 
1f08			;	pop hl 
1f08			;;	FORTH_RSP_POP	  
1f08			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1f08			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1f08			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1f08			; 
1f08			;	if DEBUG_FORTH_WORDS 
1f08			;		DMARK "EX7" 
1f08			;		CALLMONITOR 
1f08			;	endif 
1f08			;	NEXTW 
1f08			 
1f08			;.STKEXEC: 
1f08			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1f08			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
1f08			; 
1f08			; 
1f08			;		if DEBUG_FORTH_WORDS_KEY 
1f08			;			DMARK "STX" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			; 
1f08			;	FORTH_DSP_VALUEHL 
1f08			; 
1f08			;	ld (store_tmp1), hl    ; count 
1f08			; 
1f08			;	FORTH_DSP_POP 
1f08			;.stkexec1: 
1f08			;	ld hl, (store_tmp1)   ; count 
1f08			;	ld a, 0 
1f08			;	cp l 
1f08			;	ret z 
1f08			; 
1f08			;	dec hl 
1f08			;	ld (store_tmp1), hl    ; count 
1f08			;	 
1f08			;	FORTH_DSP_VALUEHL 
1f08			;	push hl 
1f08			;	 
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EXp" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			;	FORTH_DSP_POP 
1f08			; 
1f08			;	call strlenz 
1f08			;	inc hl   ; include zero term to copy 
1f08			;	inc hl   ; include zero term to copy 
1f08			;	inc hl   ; include zero term to copy 
1f08			;	ld b,0 
1f08			;	ld c,l 
1f08			;	pop hl 
1f08			;	ld de, execscratch 
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EX3" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			;	ldir 
1f08			; 
1f08			; 
1f08			;	ld hl, execscratch 
1f08			; 
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EXP" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			; 
1f08			;	call forthparse 
1f08			;	ld hl, execscratch 
1f08			;		if DEBUG_FORTH_WORDS 
1f08			;			DMARK "EXx" 
1f08			;			CALLMONITOR 
1f08			;		endif 
1f08			;	call forthexec 
1f08			; 
1f08			;	jp .stkexec1 
1f08			; 
1f08			;	ret 
1f08			 
1f08			 
1f08			.DUP: 
1f08				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1f08 17				db WORD_SYS_CORE+OPCODE_DUP             
1f09 7e 1f			dw .ZDUP            
1f0b 04				db 3 + 1 
1f0c .. 00			db "DUP",0              
1f10				endm 
# End of macro CWHEAD
1f10			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1f10			 
1f10					if DEBUG_FORTH_WORDS_KEY 
1f10						DMARK "DUP" 
1f10 f5				push af  
1f11 3a 25 1f			ld a, (.dmark)  
1f14 32 71 ee			ld (debug_mark),a  
1f17 3a 26 1f			ld a, (.dmark+1)  
1f1a 32 72 ee			ld (debug_mark+1),a  
1f1d 3a 27 1f			ld a, (.dmark+2)  
1f20 32 73 ee			ld (debug_mark+2),a  
1f23 18 03			jr .pastdmark  
1f25 ..			.dmark: db "DUP"  
1f28 f1			.pastdmark: pop af  
1f29			endm  
# End of macro DMARK
1f29						CALLMONITOR 
1f29 cd ae 13			call break_point_state  
1f2c				endm  
# End of macro CALLMONITOR
1f2c					endif 
1f2c			 
1f2c					FORTH_DSP 
1f2c cd c5 1b			call macro_forth_dsp 
1f2f				endm 
# End of macro FORTH_DSP
1f2f			 
1f2f 7e					ld a, (HL) 
1f30 fe 01				cp DS_TYPE_STR 
1f32 20 25				jr nz, .dupinum 
1f34			 
1f34					; push another string 
1f34			 
1f34					FORTH_DSP_VALUEHL     		 
1f34 cd ff 1b			call macro_dsp_valuehl 
1f37				endm 
# End of macro FORTH_DSP_VALUEHL
1f37			 
1f37				if DEBUG_FORTH_WORDS 
1f37					DMARK "DUs" 
1f37 f5				push af  
1f38 3a 4c 1f			ld a, (.dmark)  
1f3b 32 71 ee			ld (debug_mark),a  
1f3e 3a 4d 1f			ld a, (.dmark+1)  
1f41 32 72 ee			ld (debug_mark+1),a  
1f44 3a 4e 1f			ld a, (.dmark+2)  
1f47 32 73 ee			ld (debug_mark+2),a  
1f4a 18 03			jr .pastdmark  
1f4c ..			.dmark: db "DUs"  
1f4f f1			.pastdmark: pop af  
1f50			endm  
# End of macro DMARK
1f50					CALLMONITOR 
1f50 cd ae 13			call break_point_state  
1f53				endm  
# End of macro CALLMONITOR
1f53				endif 
1f53 cd 76 1a				call forth_push_str 
1f56			 
1f56					NEXTW 
1f56 c3 71 1d			jp macro_next 
1f59				endm 
# End of macro NEXTW
1f59			 
1f59			 
1f59			.dupinum: 
1f59					 
1f59			 
1f59			 
1f59					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f59 cd ff 1b			call macro_dsp_valuehl 
1f5c				endm 
# End of macro FORTH_DSP_VALUEHL
1f5c			 
1f5c				; TODO add floating point number detection 
1f5c			 
1f5c				if DEBUG_FORTH_WORDS 
1f5c					DMARK "DUi" 
1f5c f5				push af  
1f5d 3a 71 1f			ld a, (.dmark)  
1f60 32 71 ee			ld (debug_mark),a  
1f63 3a 72 1f			ld a, (.dmark+1)  
1f66 32 72 ee			ld (debug_mark+1),a  
1f69 3a 73 1f			ld a, (.dmark+2)  
1f6c 32 73 ee			ld (debug_mark+2),a  
1f6f 18 03			jr .pastdmark  
1f71 ..			.dmark: db "DUi"  
1f74 f1			.pastdmark: pop af  
1f75			endm  
# End of macro DMARK
1f75					CALLMONITOR 
1f75 cd ae 13			call break_point_state  
1f78				endm  
# End of macro CALLMONITOR
1f78				endif 
1f78			 
1f78 cd 08 1a				call forth_push_numhl 
1f7b					NEXTW 
1f7b c3 71 1d			jp macro_next 
1f7e				endm 
# End of macro NEXTW
1f7e			.ZDUP: 
1f7e				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1f7e 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1f7f b6 1f			dw .SWAP            
1f81 05				db 4 + 1 
1f82 .. 00			db "?DUP",0              
1f87				endm 
# End of macro CWHEAD
1f87			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1f87			 
1f87					if DEBUG_FORTH_WORDS_KEY 
1f87						DMARK "qDU" 
1f87 f5				push af  
1f88 3a 9c 1f			ld a, (.dmark)  
1f8b 32 71 ee			ld (debug_mark),a  
1f8e 3a 9d 1f			ld a, (.dmark+1)  
1f91 32 72 ee			ld (debug_mark+1),a  
1f94 3a 9e 1f			ld a, (.dmark+2)  
1f97 32 73 ee			ld (debug_mark+2),a  
1f9a 18 03			jr .pastdmark  
1f9c ..			.dmark: db "qDU"  
1f9f f1			.pastdmark: pop af  
1fa0			endm  
# End of macro DMARK
1fa0						CALLMONITOR 
1fa0 cd ae 13			call break_point_state  
1fa3				endm  
# End of macro CALLMONITOR
1fa3					endif 
1fa3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1fa3 cd ff 1b			call macro_dsp_valuehl 
1fa6				endm 
# End of macro FORTH_DSP_VALUEHL
1fa6			 
1fa6 e5					push hl 
1fa7			 
1fa7					; is it a zero? 
1fa7			 
1fa7 3e 00				ld a, 0 
1fa9 84					add h 
1faa 85					add l 
1fab			 
1fab e1					pop hl 
1fac			 
1fac fe 00				cp 0 
1fae 28 03				jr z, .dup2orig 
1fb0			 
1fb0			 
1fb0 cd 08 1a				call forth_push_numhl 
1fb3			 
1fb3			 
1fb3				; TODO add floating point number detection 
1fb3			 
1fb3			.dup2orig: 
1fb3			 
1fb3					NEXTW 
1fb3 c3 71 1d			jp macro_next 
1fb6				endm 
# End of macro NEXTW
1fb6			.SWAP: 
1fb6				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1fb6 18				db WORD_SYS_CORE+OPCODE_SWAP             
1fb7 f5 1f			dw .COLN            
1fb9 05				db 4 + 1 
1fba .. 00			db "SWAP",0              
1fbf				endm 
# End of macro CWHEAD
1fbf			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1fbf					if DEBUG_FORTH_WORDS_KEY 
1fbf						DMARK "SWP" 
1fbf f5				push af  
1fc0 3a d4 1f			ld a, (.dmark)  
1fc3 32 71 ee			ld (debug_mark),a  
1fc6 3a d5 1f			ld a, (.dmark+1)  
1fc9 32 72 ee			ld (debug_mark+1),a  
1fcc 3a d6 1f			ld a, (.dmark+2)  
1fcf 32 73 ee			ld (debug_mark+2),a  
1fd2 18 03			jr .pastdmark  
1fd4 ..			.dmark: db "SWP"  
1fd7 f1			.pastdmark: pop af  
1fd8			endm  
# End of macro DMARK
1fd8						CALLMONITOR 
1fd8 cd ae 13			call break_point_state  
1fdb				endm  
# End of macro CALLMONITOR
1fdb					endif 
1fdb			 
1fdb					FORTH_DSP_VALUEHL 
1fdb cd ff 1b			call macro_dsp_valuehl 
1fde				endm 
# End of macro FORTH_DSP_VALUEHL
1fde e5					push hl     ; w2 
1fdf			 
1fdf					FORTH_DSP_POP 
1fdf cd b7 1c			call macro_forth_dsp_pop 
1fe2				endm 
# End of macro FORTH_DSP_POP
1fe2			 
1fe2					FORTH_DSP_VALUEHL 
1fe2 cd ff 1b			call macro_dsp_valuehl 
1fe5				endm 
# End of macro FORTH_DSP_VALUEHL
1fe5			 
1fe5					FORTH_DSP_POP 
1fe5 cd b7 1c			call macro_forth_dsp_pop 
1fe8				endm 
# End of macro FORTH_DSP_POP
1fe8			 
1fe8 d1					pop de     ; w2	, hl = w1 
1fe9			 
1fe9 eb					ex de, hl 
1fea d5					push de 
1feb			 
1feb cd 08 1a				call forth_push_numhl 
1fee			 
1fee e1					pop hl 
1fef			 
1fef cd 08 1a				call forth_push_numhl 
1ff2					 
1ff2			 
1ff2					NEXTW 
1ff2 c3 71 1d			jp macro_next 
1ff5				endm 
# End of macro NEXTW
1ff5			.COLN: 
1ff5				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1ff5 19				db WORD_SYS_CORE+OPCODE_COLN             
1ff6 81 21			dw .SCOLN            
1ff8 02				db 1 + 1 
1ff9 .. 00			db ":",0              
1ffb				endm 
# End of macro CWHEAD
1ffb			; | : ( -- )         Create new word | DONE 
1ffb			 
1ffb					if DEBUG_FORTH_WORDS_KEY 
1ffb						DMARK "CLN" 
1ffb f5				push af  
1ffc 3a 10 20			ld a, (.dmark)  
1fff 32 71 ee			ld (debug_mark),a  
2002 3a 11 20			ld a, (.dmark+1)  
2005 32 72 ee			ld (debug_mark+1),a  
2008 3a 12 20			ld a, (.dmark+2)  
200b 32 73 ee			ld (debug_mark+2),a  
200e 18 03			jr .pastdmark  
2010 ..			.dmark: db "CLN"  
2013 f1			.pastdmark: pop af  
2014			endm  
# End of macro DMARK
2014						CALLMONITOR 
2014 cd ae 13			call break_point_state  
2017				endm  
# End of macro CALLMONITOR
2017					endif 
2017				STACKFRAME OFF $8efe $989f 
2017				if DEBUG_STACK_IMB 
2017					if OFF 
2017						exx 
2017						ld de, $8efe 
2017						ld a, d 
2017						ld hl, curframe 
2017						call hexout 
2017						ld a, e 
2017						ld hl, curframe+2 
2017						call hexout 
2017						ld hl, $8efe 
2017						push hl 
2017						ld hl, $989f 
2017						push hl 
2017						exx 
2017					endif 
2017				endif 
2017			endm 
# End of macro STACKFRAME
2017				; get parser buffer length  of new word 
2017			 
2017				 
2017			 
2017					; move tok past this to start of name defintition 
2017					; TODO get word to define 
2017					; TODO Move past word token 
2017					; TODO get length of string up to the ';' 
2017			 
2017 2a 58 e6			ld hl, (os_tok_ptr) 
201a 23				inc hl 
201b 23				inc hl 
201c			 
201c 3e 3b			ld a, ';' 
201e cd 16 10			call strlent 
2021			 
2021 7d				ld a,l 
2022 32 53 e3			ld (os_new_parse_len), a 
2025			 
2025			 
2025			if DEBUG_FORTH_UWORD 
2025 ed 5b 58 e6		ld de, (os_tok_ptr) 
2029						DMARK ":01" 
2029 f5				push af  
202a 3a 3e 20			ld a, (.dmark)  
202d 32 71 ee			ld (debug_mark),a  
2030 3a 3f 20			ld a, (.dmark+1)  
2033 32 72 ee			ld (debug_mark+1),a  
2036 3a 40 20			ld a, (.dmark+2)  
2039 32 73 ee			ld (debug_mark+2),a  
203c 18 03			jr .pastdmark  
203e ..			.dmark: db ":01"  
2041 f1			.pastdmark: pop af  
2042			endm  
# End of macro DMARK
2042				CALLMONITOR 
2042 cd ae 13			call break_point_state  
2045				endm  
# End of macro CALLMONITOR
2045			endif 
2045			 
2045			; 
2045			;  new word memory layout: 
2045			;  
2045			;    : adg 6666 ;  
2045			; 
2045			;    db   1     ; user defined word  
2045 23				inc hl    
2046			;    dw   sysdict 
2046 23				inc hl 
2047 23				inc hl 
2048			;    db <word len>+1 (for null) 
2048 23				inc hl 
2049			;    db .... <word> 
2049			; 
2049			 
2049 23				inc hl    ; some extras for the word preamble before the above 
204a 23				inc hl 
204b 23				inc hl 
204c 23				inc hl 
204d 23				inc hl 
204e 23				inc hl 
204f 23				inc hl  
2050 23				inc hl 
2051 23				inc hl 
2052 23				inc hl 
2053 23				inc hl 
2054 23				inc hl 
2055 23				inc hl 
2056 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2057			;       exec word buffer 
2057			;	<ptr word>   
2057 23				inc hl 
2058 23				inc hl 
2059			;       <word list><null term> 7F final term 
2059			 
2059			 
2059			if DEBUG_FORTH_UWORD 
2059						DMARK ":02" 
2059 f5				push af  
205a 3a 6e 20			ld a, (.dmark)  
205d 32 71 ee			ld (debug_mark),a  
2060 3a 6f 20			ld a, (.dmark+1)  
2063 32 72 ee			ld (debug_mark+1),a  
2066 3a 70 20			ld a, (.dmark+2)  
2069 32 73 ee			ld (debug_mark+2),a  
206c 18 03			jr .pastdmark  
206e ..			.dmark: db ":02"  
2071 f1			.pastdmark: pop af  
2072			endm  
# End of macro DMARK
2072				CALLMONITOR 
2072 cd ae 13			call break_point_state  
2075				endm  
# End of macro CALLMONITOR
2075			endif 
2075			 
2075				 
2075					; malloc the size 
2075			 
2075 cd 74 10				call malloc 
2078 22 55 e3				ld (os_new_malloc), hl     ; save malloc start 
207b			 
207b			;    db   1     ; user defined word  
207b 3e 01				ld a, WORD_SYS_UWORD  
207d 77					ld (hl), a 
207e				 
207e 23				inc hl    
207f			;    dw   sysdict 
207f 11 c9 1e			ld de, sysdict       ; continue on with the scan to the system dict 
2082 73				ld (hl), e 
2083 23				inc hl 
2084 72				ld (hl), d 
2085 23				inc hl 
2086			 
2086			 
2086			;    Setup dict word 
2086			 
2086 23				inc hl 
2087 22 4f e3			ld (os_new_work_ptr), hl     ; save start of dict word  
208a			 
208a				; 1. get length of dict word 
208a			 
208a			 
208a 2a 58 e6			ld hl, (os_tok_ptr) 
208d 23				inc hl 
208e 23				inc hl    ; position to start of dict word 
208f 3e 00			ld a, 0 
2091 cd 16 10			call strlent 
2094			 
2094			 
2094 23				inc hl    ; to include null??? 
2095			 
2095				; write length of dict word 
2095			 
2095 ed 5b 4f e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2099 1b				dec de 
209a eb				ex de, hl 
209b 73				ld (hl), e 
209c eb				ex de, hl 
209d			 
209d				 
209d			 
209d				; copy  
209d 4d				ld c, l 
209e 06 00			ld b, 0 
20a0 ed 5b 4f e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
20a4 2a 58 e6			ld hl, (os_tok_ptr) 
20a7 23				inc hl 
20a8 23				inc hl    ; position to start of dict word 
20a9				 
20a9			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
20a9				 
20a9				; TODO need to convert word to upper case 
20a9			 
20a9			ucasetok:	 
20a9 7e				ld a,(hl) 
20aa cd 02 10			call toUpper 
20ad 77				ld (hl),a 
20ae ed a0			ldi 
20b0 f2 a9 20		 	jp p, ucasetok 
20b3			 
20b3			 
20b3			 
20b3				; de now points to start of where the word body code should be placed 
20b3 ed 53 4f e3		ld (os_new_work_ptr), de 
20b7				; hl now points to the words to throw at forthexec which needs to be copied 
20b7 22 4d e3			ld (os_new_src_ptr), hl 
20ba			 
20ba				; TODO add 'call to forthexec' 
20ba			 
20ba			if DEBUG_FORTH_UWORD 
20ba c5				push bc 
20bb ed 4b 55 e3		ld bc, (os_new_malloc) 
20bf						DMARK ":0x" 
20bf f5				push af  
20c0 3a d4 20			ld a, (.dmark)  
20c3 32 71 ee			ld (debug_mark),a  
20c6 3a d5 20			ld a, (.dmark+1)  
20c9 32 72 ee			ld (debug_mark+1),a  
20cc 3a d6 20			ld a, (.dmark+2)  
20cf 32 73 ee			ld (debug_mark+2),a  
20d2 18 03			jr .pastdmark  
20d4 ..			.dmark: db ":0x"  
20d7 f1			.pastdmark: pop af  
20d8			endm  
# End of macro DMARK
20d8				CALLMONITOR 
20d8 cd ae 13			call break_point_state  
20db				endm  
# End of macro CALLMONITOR
20db c1				pop bc 
20dc			endif 
20dc			 
20dc			 
20dc				; create word preamble which should be: 
20dc			 
20dc			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
20dc			 
20dc				;    ld hl, <word code> 
20dc				;    jp user_exec 
20dc			        ;    <word code bytes> 
20dc			 
20dc			 
20dc			;	inc de     ; TODO ??? or are we already past the word's null 
20dc eb				ex de, hl 
20dd			 
20dd 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
20df			 
20df 23				inc hl 
20e0 22 49 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
20e3 23				inc hl 
20e4			 
20e4 23				inc hl 
20e5 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
20e7			 
20e7 01 d1 44			ld bc, user_exec 
20ea 23				inc hl 
20eb 71				ld (hl), c     ; poke address of user_exec 
20ec 23				inc hl 
20ed 70				ld (hl), b     
20ee			 ; 
20ee			;	inc hl 
20ee			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
20ee			; 
20ee			; 
20ee			;	ld bc, macro_forth_rsp_next 
20ee			;	inc hl 
20ee			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
20ee			;	inc hl 
20ee			;	ld (hl), b     
20ee			 ; 
20ee			;	inc hl 
20ee			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
20ee			; 
20ee			; 
20ee			;	inc hl 
20ee			;	ld bc, forthexec 
20ee			;	ld (hl), c     ; poke address of forthexec 
20ee			;	inc hl 
20ee			;	ld (hl), b      
20ee			; 
20ee			;	inc hl 
20ee			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
20ee			; 
20ee			;	ld bc, user_dict_next 
20ee			;	inc hl 
20ee			;	ld (hl), c     ; poke address of forthexec 
20ee			;	inc hl 
20ee			;	ld (hl), b      
20ee			 
20ee				; hl is now where we need to copy the word byte data to save this 
20ee			 
20ee 23				inc hl 
20ef 22 4b e3			ld (os_new_exec), hl 
20f2				 
20f2				; copy definition 
20f2			 
20f2 eb				ex de, hl 
20f3			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
20f3			;	inc de    ; skip the PC for this parse 
20f3 3a 53 e3			ld a, (os_new_parse_len) 
20f6 4f				ld c, a 
20f7 06 00			ld b, 0 
20f9 ed b0			ldir		 ; copy defintion 
20fb			 
20fb			 
20fb				; poke the address of where the new word bytes live for forthexec 
20fb			 
20fb 2a 49 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
20fe			 
20fe ed 5b 4b e3		ld de, (os_new_exec)      
2102				 
2102 73				ld (hl), e 
2103 23				inc hl 
2104 72				ld (hl), d 
2105			 
2105					; TODO copy last user dict word next link to this word 
2105					; TODO update last user dict word to point to this word 
2105			; 
2105			; hl f923 de 812a ; bc 811a 
2105			 
2105			if DEBUG_FORTH_UWORD 
2105 c5				push bc 
2106 ed 4b 55 e3		ld bc, (os_new_malloc) 
210a						DMARK ":0A" 
210a f5				push af  
210b 3a 1f 21			ld a, (.dmark)  
210e 32 71 ee			ld (debug_mark),a  
2111 3a 20 21			ld a, (.dmark+1)  
2114 32 72 ee			ld (debug_mark+1),a  
2117 3a 21 21			ld a, (.dmark+2)  
211a 32 73 ee			ld (debug_mark+2),a  
211d 18 03			jr .pastdmark  
211f ..			.dmark: db ":0A"  
2122 f1			.pastdmark: pop af  
2123			endm  
# End of macro DMARK
2123				CALLMONITOR 
2123 cd ae 13			call break_point_state  
2126				endm  
# End of macro CALLMONITOR
2126 c1				pop bc 
2127			endif 
2127			if DEBUG_FORTH_UWORD 
2127 c5				push bc 
2128 ed 4b 55 e3		ld bc, (os_new_malloc) 
212c 03				inc bc 
212d 03				inc bc 
212e 03				inc bc 
212f 03				inc bc 
2130 03				inc bc 
2131 03				inc bc 
2132 03				inc bc 
2133 03				inc bc 
2134			 
2134						DMARK ":0B" 
2134 f5				push af  
2135 3a 49 21			ld a, (.dmark)  
2138 32 71 ee			ld (debug_mark),a  
213b 3a 4a 21			ld a, (.dmark+1)  
213e 32 72 ee			ld (debug_mark+1),a  
2141 3a 4b 21			ld a, (.dmark+2)  
2144 32 73 ee			ld (debug_mark+2),a  
2147 18 03			jr .pastdmark  
2149 ..			.dmark: db ":0B"  
214c f1			.pastdmark: pop af  
214d			endm  
# End of macro DMARK
214d				CALLMONITOR 
214d cd ae 13			call break_point_state  
2150				endm  
# End of macro CALLMONITOR
2150 c1				pop bc 
2151			endif 
2151			 
2151			; update word dict linked list for new word 
2151			 
2151			 
2151 2a 54 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2154 23			inc hl     ; move to next work linked list ptr 
2155			 
2155 ed 5b 55 e3	ld de, (os_new_malloc)		 ; new next word 
2159 73			ld (hl), e 
215a 23			inc hl 
215b 72			ld (hl), d 
215c			 
215c			if DEBUG_FORTH_UWORD 
215c ed 4b 54 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2160			endif 
2160			 
2160 ed 53 54 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
2164			 
2164			 
2164			if DEBUG_FORTH_UWORD 
2164						DMARK ":0+" 
2164 f5				push af  
2165 3a 79 21			ld a, (.dmark)  
2168 32 71 ee			ld (debug_mark),a  
216b 3a 7a 21			ld a, (.dmark+1)  
216e 32 72 ee			ld (debug_mark+1),a  
2171 3a 7b 21			ld a, (.dmark+2)  
2174 32 73 ee			ld (debug_mark+2),a  
2177 18 03			jr .pastdmark  
2179 ..			.dmark: db ":0+"  
217c f1			.pastdmark: pop af  
217d			endm  
# End of macro DMARK
217d				CALLMONITOR 
217d cd ae 13			call break_point_state  
2180				endm  
# End of macro CALLMONITOR
2180			endif 
2180			 
2180				STACKFRAMECHK OFF $8efe $989f 
2180				if DEBUG_STACK_IMB 
2180					if OFF 
2180						exx 
2180						ld hl, $989f 
2180						pop de   ; $989f 
2180						call cmp16 
2180						jr nz, .spnosame 
2180						ld hl, $8efe 
2180						pop de   ; $8efe 
2180						call cmp16 
2180						jr z, .spfrsame 
2180						.spnosame: call showsperror 
2180						.spfrsame: nop 
2180						exx 
2180					endif 
2180				endif 
2180			endm 
# End of macro STACKFRAMECHK
2180			 
2180 c9			ret    ; dont process any remaining parser tokens as they form new word 
2181			 
2181			 
2181			 
2181			 
2181			;		NEXT 
2181			.SCOLN: 
2181			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2181 06				db OPCODE_SCOLN 
2182 cd 21			dw .DROP 
2184 02				db 2 
2185 .. 00			db ";",0           
2187			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2187					if DEBUG_FORTH_WORDS_KEY 
2187						DMARK "SCN" 
2187 f5				push af  
2188 3a 9c 21			ld a, (.dmark)  
218b 32 71 ee			ld (debug_mark),a  
218e 3a 9d 21			ld a, (.dmark+1)  
2191 32 72 ee			ld (debug_mark+1),a  
2194 3a 9e 21			ld a, (.dmark+2)  
2197 32 73 ee			ld (debug_mark+2),a  
219a 18 03			jr .pastdmark  
219c ..			.dmark: db "SCN"  
219f f1			.pastdmark: pop af  
21a0			endm  
# End of macro DMARK
21a0						CALLMONITOR 
21a0 cd ae 13			call break_point_state  
21a3				endm  
# End of macro CALLMONITOR
21a3					endif 
21a3					FORTH_RSP_TOS 
21a3 cd c6 19			call macro_forth_rsp_tos 
21a6				endm 
# End of macro FORTH_RSP_TOS
21a6 e5					push hl 
21a7					FORTH_RSP_POP 
21a7 cd d0 19			call macro_forth_rsp_pop 
21aa				endm 
# End of macro FORTH_RSP_POP
21aa e1					pop hl 
21ab			;		ex de,hl 
21ab 22 58 e6				ld (os_tok_ptr),hl 
21ae			 
21ae			if DEBUG_FORTH_UWORD 
21ae						DMARK "SCL" 
21ae f5				push af  
21af 3a c3 21			ld a, (.dmark)  
21b2 32 71 ee			ld (debug_mark),a  
21b5 3a c4 21			ld a, (.dmark+1)  
21b8 32 72 ee			ld (debug_mark+1),a  
21bb 3a c5 21			ld a, (.dmark+2)  
21be 32 73 ee			ld (debug_mark+2),a  
21c1 18 03			jr .pastdmark  
21c3 ..			.dmark: db "SCL"  
21c6 f1			.pastdmark: pop af  
21c7			endm  
# End of macro DMARK
21c7				CALLMONITOR 
21c7 cd ae 13			call break_point_state  
21ca				endm  
# End of macro CALLMONITOR
21ca			endif 
21ca					NEXTW 
21ca c3 71 1d			jp macro_next 
21cd				endm 
# End of macro NEXTW
21cd			 
21cd			.DROP: 
21cd				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
21cd 1b				db WORD_SYS_CORE+OPCODE_DROP             
21ce f8 21			dw .DUP2            
21d0 05				db 4 + 1 
21d1 .. 00			db "DROP",0              
21d6				endm 
# End of macro CWHEAD
21d6			; | DROP ( w -- )   drop the TOS item   | DONE 
21d6					if DEBUG_FORTH_WORDS_KEY 
21d6						DMARK "DRP" 
21d6 f5				push af  
21d7 3a eb 21			ld a, (.dmark)  
21da 32 71 ee			ld (debug_mark),a  
21dd 3a ec 21			ld a, (.dmark+1)  
21e0 32 72 ee			ld (debug_mark+1),a  
21e3 3a ed 21			ld a, (.dmark+2)  
21e6 32 73 ee			ld (debug_mark+2),a  
21e9 18 03			jr .pastdmark  
21eb ..			.dmark: db "DRP"  
21ee f1			.pastdmark: pop af  
21ef			endm  
# End of macro DMARK
21ef						CALLMONITOR 
21ef cd ae 13			call break_point_state  
21f2				endm  
# End of macro CALLMONITOR
21f2					endif 
21f2					FORTH_DSP_POP 
21f2 cd b7 1c			call macro_forth_dsp_pop 
21f5				endm 
# End of macro FORTH_DSP_POP
21f5					NEXTW 
21f5 c3 71 1d			jp macro_next 
21f8				endm 
# End of macro NEXTW
21f8			.DUP2: 
21f8				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
21f8 1c				db WORD_SYS_CORE+OPCODE_DUP2             
21f9 3d 22			dw .DROP2            
21fb 05				db 4 + 1 
21fc .. 00			db "2DUP",0              
2201				endm 
# End of macro CWHEAD
2201			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2201					if DEBUG_FORTH_WORDS_KEY 
2201						DMARK "2DU" 
2201 f5				push af  
2202 3a 16 22			ld a, (.dmark)  
2205 32 71 ee			ld (debug_mark),a  
2208 3a 17 22			ld a, (.dmark+1)  
220b 32 72 ee			ld (debug_mark+1),a  
220e 3a 18 22			ld a, (.dmark+2)  
2211 32 73 ee			ld (debug_mark+2),a  
2214 18 03			jr .pastdmark  
2216 ..			.dmark: db "2DU"  
2219 f1			.pastdmark: pop af  
221a			endm  
# End of macro DMARK
221a						CALLMONITOR 
221a cd ae 13			call break_point_state  
221d				endm  
# End of macro CALLMONITOR
221d					endif 
221d					FORTH_DSP_VALUEHL 
221d cd ff 1b			call macro_dsp_valuehl 
2220				endm 
# End of macro FORTH_DSP_VALUEHL
2220 e5					push hl      ; 2 
2221			 
2221					FORTH_DSP_POP 
2221 cd b7 1c			call macro_forth_dsp_pop 
2224				endm 
# End of macro FORTH_DSP_POP
2224					 
2224					FORTH_DSP_VALUEHL 
2224 cd ff 1b			call macro_dsp_valuehl 
2227				endm 
# End of macro FORTH_DSP_VALUEHL
2227			;		push hl      ; 1 
2227			 
2227					FORTH_DSP_POP 
2227 cd b7 1c			call macro_forth_dsp_pop 
222a				endm 
# End of macro FORTH_DSP_POP
222a			 
222a			;		pop hl       ; 1 
222a d1					pop de       ; 2 
222b			 
222b cd 08 1a				call forth_push_numhl 
222e eb					ex de, hl 
222f cd 08 1a				call forth_push_numhl 
2232			 
2232					 
2232 eb					ex de, hl 
2233			 
2233 cd 08 1a				call forth_push_numhl 
2236 eb					ex de, hl 
2237 cd 08 1a				call forth_push_numhl 
223a			 
223a			 
223a					NEXTW 
223a c3 71 1d			jp macro_next 
223d				endm 
# End of macro NEXTW
223d			.DROP2: 
223d				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
223d 1d				db WORD_SYS_CORE+OPCODE_DROP2             
223e 6c 22			dw .SWAP2            
2240 06				db 5 + 1 
2241 .. 00			db "2DROP",0              
2247				endm 
# End of macro CWHEAD
2247			; | 2DROP ( w w -- )    Double drop | DONE 
2247					if DEBUG_FORTH_WORDS_KEY 
2247						DMARK "2DR" 
2247 f5				push af  
2248 3a 5c 22			ld a, (.dmark)  
224b 32 71 ee			ld (debug_mark),a  
224e 3a 5d 22			ld a, (.dmark+1)  
2251 32 72 ee			ld (debug_mark+1),a  
2254 3a 5e 22			ld a, (.dmark+2)  
2257 32 73 ee			ld (debug_mark+2),a  
225a 18 03			jr .pastdmark  
225c ..			.dmark: db "2DR"  
225f f1			.pastdmark: pop af  
2260			endm  
# End of macro DMARK
2260						CALLMONITOR 
2260 cd ae 13			call break_point_state  
2263				endm  
# End of macro CALLMONITOR
2263					endif 
2263					FORTH_DSP_POP 
2263 cd b7 1c			call macro_forth_dsp_pop 
2266				endm 
# End of macro FORTH_DSP_POP
2266					FORTH_DSP_POP 
2266 cd b7 1c			call macro_forth_dsp_pop 
2269				endm 
# End of macro FORTH_DSP_POP
2269					NEXTW 
2269 c3 71 1d			jp macro_next 
226c				endm 
# End of macro NEXTW
226c			.SWAP2: 
226c				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
226c 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
226d 95 22			dw .AT            
226f 06				db 5 + 1 
2270 .. 00			db "2SWAP",0              
2276				endm 
# End of macro CWHEAD
2276			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2276					if DEBUG_FORTH_WORDS_KEY 
2276						DMARK "2SW" 
2276 f5				push af  
2277 3a 8b 22			ld a, (.dmark)  
227a 32 71 ee			ld (debug_mark),a  
227d 3a 8c 22			ld a, (.dmark+1)  
2280 32 72 ee			ld (debug_mark+1),a  
2283 3a 8d 22			ld a, (.dmark+2)  
2286 32 73 ee			ld (debug_mark+2),a  
2289 18 03			jr .pastdmark  
228b ..			.dmark: db "2SW"  
228e f1			.pastdmark: pop af  
228f			endm  
# End of macro DMARK
228f						CALLMONITOR 
228f cd ae 13			call break_point_state  
2292				endm  
# End of macro CALLMONITOR
2292					endif 
2292					NEXTW 
2292 c3 71 1d			jp macro_next 
2295				endm 
# End of macro NEXTW
2295			.AT: 
2295				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2295 1f				db WORD_SYS_CORE+OPCODE_AT             
2296 c7 22			dw .CAT            
2298 02				db 1 + 1 
2299 .. 00			db "@",0              
229b				endm 
# End of macro CWHEAD
229b			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
229b			 
229b					if DEBUG_FORTH_WORDS_KEY 
229b						DMARK "AT." 
229b f5				push af  
229c 3a b0 22			ld a, (.dmark)  
229f 32 71 ee			ld (debug_mark),a  
22a2 3a b1 22			ld a, (.dmark+1)  
22a5 32 72 ee			ld (debug_mark+1),a  
22a8 3a b2 22			ld a, (.dmark+2)  
22ab 32 73 ee			ld (debug_mark+2),a  
22ae 18 03			jr .pastdmark  
22b0 ..			.dmark: db "AT."  
22b3 f1			.pastdmark: pop af  
22b4			endm  
# End of macro DMARK
22b4						CALLMONITOR 
22b4 cd ae 13			call break_point_state  
22b7				endm  
# End of macro CALLMONITOR
22b7					endif 
22b7			.getbyteat:	 
22b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22b7 cd ff 1b			call macro_dsp_valuehl 
22ba				endm 
# End of macro FORTH_DSP_VALUEHL
22ba					 
22ba			;		push hl 
22ba				 
22ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22ba cd b7 1c			call macro_forth_dsp_pop 
22bd				endm 
# End of macro FORTH_DSP_POP
22bd			 
22bd			;		pop hl 
22bd			 
22bd 7e					ld a, (hl) 
22be			 
22be 6f					ld l, a 
22bf 26 00				ld h, 0 
22c1 cd 08 1a				call forth_push_numhl 
22c4			 
22c4					NEXTW 
22c4 c3 71 1d			jp macro_next 
22c7				endm 
# End of macro NEXTW
22c7			.CAT: 
22c7				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
22c7 20				db WORD_SYS_CORE+OPCODE_CAT             
22c8 f0 22			dw .BANG            
22ca 03				db 2 + 1 
22cb .. 00			db "C@",0              
22ce				endm 
# End of macro CWHEAD
22ce			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
22ce					if DEBUG_FORTH_WORDS_KEY 
22ce						DMARK "CAA" 
22ce f5				push af  
22cf 3a e3 22			ld a, (.dmark)  
22d2 32 71 ee			ld (debug_mark),a  
22d5 3a e4 22			ld a, (.dmark+1)  
22d8 32 72 ee			ld (debug_mark+1),a  
22db 3a e5 22			ld a, (.dmark+2)  
22de 32 73 ee			ld (debug_mark+2),a  
22e1 18 03			jr .pastdmark  
22e3 ..			.dmark: db "CAA"  
22e6 f1			.pastdmark: pop af  
22e7			endm  
# End of macro DMARK
22e7						CALLMONITOR 
22e7 cd ae 13			call break_point_state  
22ea				endm  
# End of macro CALLMONITOR
22ea					endif 
22ea c3 b7 22				jp .getbyteat 
22ed					NEXTW 
22ed c3 71 1d			jp macro_next 
22f0				endm 
# End of macro NEXTW
22f0			.BANG: 
22f0				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
22f0 21				db WORD_SYS_CORE+OPCODE_BANG             
22f1 26 23			dw .CBANG            
22f3 02				db 1 + 1 
22f4 .. 00			db "!",0              
22f6				endm 
# End of macro CWHEAD
22f6			; | ! ( x w -- ) Store x at address w      | DONE 
22f6					if DEBUG_FORTH_WORDS_KEY 
22f6						DMARK "BNG" 
22f6 f5				push af  
22f7 3a 0b 23			ld a, (.dmark)  
22fa 32 71 ee			ld (debug_mark),a  
22fd 3a 0c 23			ld a, (.dmark+1)  
2300 32 72 ee			ld (debug_mark+1),a  
2303 3a 0d 23			ld a, (.dmark+2)  
2306 32 73 ee			ld (debug_mark+2),a  
2309 18 03			jr .pastdmark  
230b ..			.dmark: db "BNG"  
230e f1			.pastdmark: pop af  
230f			endm  
# End of macro DMARK
230f						CALLMONITOR 
230f cd ae 13			call break_point_state  
2312				endm  
# End of macro CALLMONITOR
2312					endif 
2312			 
2312			.storebyteat:		 
2312					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2312 cd ff 1b			call macro_dsp_valuehl 
2315				endm 
# End of macro FORTH_DSP_VALUEHL
2315					 
2315 e5					push hl 
2316				 
2316					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2316 cd b7 1c			call macro_forth_dsp_pop 
2319				endm 
# End of macro FORTH_DSP_POP
2319			 
2319					; get byte to poke 
2319			 
2319					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2319 cd ff 1b			call macro_dsp_valuehl 
231c				endm 
# End of macro FORTH_DSP_VALUEHL
231c e5					push hl 
231d			 
231d			 
231d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
231d cd b7 1c			call macro_forth_dsp_pop 
2320				endm 
# End of macro FORTH_DSP_POP
2320			 
2320			 
2320 d1					pop de 
2321 e1					pop hl 
2322			 
2322 73					ld (hl),e 
2323			 
2323			 
2323					NEXTW 
2323 c3 71 1d			jp macro_next 
2326				endm 
# End of macro NEXTW
2326			.CBANG: 
2326				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2326 22				db WORD_SYS_CORE+OPCODE_CBANG             
2327 4f 23			dw .SCALL            
2329 03				db 2 + 1 
232a .. 00			db "C!",0              
232d				endm 
# End of macro CWHEAD
232d			; | C!  ( x w -- ) Store x at address w  | DONE 
232d					if DEBUG_FORTH_WORDS_KEY 
232d						DMARK "CBA" 
232d f5				push af  
232e 3a 42 23			ld a, (.dmark)  
2331 32 71 ee			ld (debug_mark),a  
2334 3a 43 23			ld a, (.dmark+1)  
2337 32 72 ee			ld (debug_mark+1),a  
233a 3a 44 23			ld a, (.dmark+2)  
233d 32 73 ee			ld (debug_mark+2),a  
2340 18 03			jr .pastdmark  
2342 ..			.dmark: db "CBA"  
2345 f1			.pastdmark: pop af  
2346			endm  
# End of macro DMARK
2346						CALLMONITOR 
2346 cd ae 13			call break_point_state  
2349				endm  
# End of macro CALLMONITOR
2349					endif 
2349 c3 12 23				jp .storebyteat 
234c					NEXTW 
234c c3 71 1d			jp macro_next 
234f				endm 
# End of macro NEXTW
234f			.SCALL: 
234f				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
234f 23				db WORD_SYS_CORE+OPCODE_SCALL             
2350 83 23			dw .DEPTH            
2352 05				db 4 + 1 
2353 .. 00			db "CALL",0              
2358				endm 
# End of macro CWHEAD
2358			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2358					if DEBUG_FORTH_WORDS_KEY 
2358						DMARK "CLL" 
2358 f5				push af  
2359 3a 6d 23			ld a, (.dmark)  
235c 32 71 ee			ld (debug_mark),a  
235f 3a 6e 23			ld a, (.dmark+1)  
2362 32 72 ee			ld (debug_mark+1),a  
2365 3a 6f 23			ld a, (.dmark+2)  
2368 32 73 ee			ld (debug_mark+2),a  
236b 18 03			jr .pastdmark  
236d ..			.dmark: db "CLL"  
2370 f1			.pastdmark: pop af  
2371			endm  
# End of macro DMARK
2371						CALLMONITOR 
2371 cd ae 13			call break_point_state  
2374				endm  
# End of macro CALLMONITOR
2374					endif 
2374			 
2374					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2374 cd ff 1b			call macro_dsp_valuehl 
2377				endm 
# End of macro FORTH_DSP_VALUEHL
2377			 
2377			;		push hl 
2377			 
2377					; destroy value TOS 
2377			 
2377					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2377 cd b7 1c			call macro_forth_dsp_pop 
237a				endm 
# End of macro FORTH_DSP_POP
237a			 
237a						 
237a			;		pop hl 
237a			 
237a					; how to do a call with hl???? save SP? 
237a cd 1a 1d				call forth_call_hl 
237d			 
237d			 
237d					; TODO push value back onto stack for another op etc 
237d			 
237d cd 08 1a				call forth_push_numhl 
2380					NEXTW 
2380 c3 71 1d			jp macro_next 
2383				endm 
# End of macro NEXTW
2383			.DEPTH: 
2383				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2383 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2384 c0 23			dw .OVER            
2386 06				db 5 + 1 
2387 .. 00			db "DEPTH",0              
238d				endm 
# End of macro CWHEAD
238d			; | DEPTH ( -- u ) Push count of stack | DONE 
238d					; take current TOS and remove from base value div by two to get count 
238d					if DEBUG_FORTH_WORDS_KEY 
238d						DMARK "DEP" 
238d f5				push af  
238e 3a a2 23			ld a, (.dmark)  
2391 32 71 ee			ld (debug_mark),a  
2394 3a a3 23			ld a, (.dmark+1)  
2397 32 72 ee			ld (debug_mark+1),a  
239a 3a a4 23			ld a, (.dmark+2)  
239d 32 73 ee			ld (debug_mark+2),a  
23a0 18 03			jr .pastdmark  
23a2 ..			.dmark: db "DEP"  
23a5 f1			.pastdmark: pop af  
23a6			endm  
# End of macro DMARK
23a6						CALLMONITOR 
23a6 cd ae 13			call break_point_state  
23a9				endm  
# End of macro CALLMONITOR
23a9					endif 
23a9			 
23a9			 
23a9 2a 04 eb			ld hl, (cli_data_sp) 
23ac 11 be e8			ld de, cli_data_stack 
23af ed 52			sbc hl,de 
23b1				 
23b1				; div by size of stack item 
23b1			 
23b1 5d				ld e,l 
23b2 0e 03			ld c, 3 
23b4 cd 3d 0b			call Div8 
23b7			 
23b7 6f				ld l,a 
23b8 26 00			ld h,0 
23ba			 
23ba				;srl h 
23ba				;rr l 
23ba			 
23ba cd 08 1a				call forth_push_numhl 
23bd					NEXTW 
23bd c3 71 1d			jp macro_next 
23c0				endm 
# End of macro NEXTW
23c0			.OVER: 
23c0				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
23c0 42				db WORD_SYS_CORE+46             
23c1 07 24			dw .PAUSE            
23c3 05				db 4 + 1 
23c4 .. 00			db "OVER",0              
23c9				endm 
# End of macro CWHEAD
23c9			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
23c9					if DEBUG_FORTH_WORDS_KEY 
23c9						DMARK "OVR" 
23c9 f5				push af  
23ca 3a de 23			ld a, (.dmark)  
23cd 32 71 ee			ld (debug_mark),a  
23d0 3a df 23			ld a, (.dmark+1)  
23d3 32 72 ee			ld (debug_mark+1),a  
23d6 3a e0 23			ld a, (.dmark+2)  
23d9 32 73 ee			ld (debug_mark+2),a  
23dc 18 03			jr .pastdmark  
23de ..			.dmark: db "OVR"  
23e1 f1			.pastdmark: pop af  
23e2			endm  
# End of macro DMARK
23e2						CALLMONITOR 
23e2 cd ae 13			call break_point_state  
23e5				endm  
# End of macro CALLMONITOR
23e5					endif 
23e5			 
23e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23e5 cd ff 1b			call macro_dsp_valuehl 
23e8				endm 
# End of macro FORTH_DSP_VALUEHL
23e8 e5					push hl    ; n2 
23e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23e9 cd b7 1c			call macro_forth_dsp_pop 
23ec				endm 
# End of macro FORTH_DSP_POP
23ec			 
23ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23ec cd ff 1b			call macro_dsp_valuehl 
23ef				endm 
# End of macro FORTH_DSP_VALUEHL
23ef e5					push hl    ; n1 
23f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23f0 cd b7 1c			call macro_forth_dsp_pop 
23f3				endm 
# End of macro FORTH_DSP_POP
23f3			 
23f3 d1					pop de     ; n1 
23f4 e1					pop hl     ; n2 
23f5			 
23f5 d5					push de 
23f6 e5					push hl 
23f7 d5					push de 
23f8			 
23f8					; push back  
23f8			 
23f8 e1					pop hl 
23f9 cd 08 1a				call forth_push_numhl 
23fc e1					pop hl 
23fd cd 08 1a				call forth_push_numhl 
2400 e1					pop hl 
2401 cd 08 1a				call forth_push_numhl 
2404					NEXTW 
2404 c3 71 1d			jp macro_next 
2407				endm 
# End of macro NEXTW
2407			 
2407			.PAUSE: 
2407				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2407 43				db WORD_SYS_CORE+47             
2408 3c 24			dw .PAUSES            
240a 08				db 7 + 1 
240b .. 00			db "PAUSEMS",0              
2413				endm 
# End of macro CWHEAD
2413			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2413					if DEBUG_FORTH_WORDS_KEY 
2413						DMARK "PMS" 
2413 f5				push af  
2414 3a 28 24			ld a, (.dmark)  
2417 32 71 ee			ld (debug_mark),a  
241a 3a 29 24			ld a, (.dmark+1)  
241d 32 72 ee			ld (debug_mark+1),a  
2420 3a 2a 24			ld a, (.dmark+2)  
2423 32 73 ee			ld (debug_mark+2),a  
2426 18 03			jr .pastdmark  
2428 ..			.dmark: db "PMS"  
242b f1			.pastdmark: pop af  
242c			endm  
# End of macro DMARK
242c						CALLMONITOR 
242c cd ae 13			call break_point_state  
242f				endm  
# End of macro CALLMONITOR
242f					endif 
242f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
242f cd ff 1b			call macro_dsp_valuehl 
2432				endm 
# End of macro FORTH_DSP_VALUEHL
2432			;		push hl    ; n2 
2432					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2432 cd b7 1c			call macro_forth_dsp_pop 
2435				endm 
# End of macro FORTH_DSP_POP
2435			;		pop hl 
2435			 
2435 7d					ld a, l 
2436 cd d7 08				call aDelayInMS 
2439				       NEXTW 
2439 c3 71 1d			jp macro_next 
243c				endm 
# End of macro NEXTW
243c			.PAUSES:  
243c				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
243c 44				db WORD_SYS_CORE+48             
243d ab 24			dw .ROT            
243f 06				db 5 + 1 
2440 .. 00			db "PAUSE",0              
2446				endm 
# End of macro CWHEAD
2446			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2446					if DEBUG_FORTH_WORDS_KEY 
2446						DMARK "PAU" 
2446 f5				push af  
2447 3a 5b 24			ld a, (.dmark)  
244a 32 71 ee			ld (debug_mark),a  
244d 3a 5c 24			ld a, (.dmark+1)  
2450 32 72 ee			ld (debug_mark+1),a  
2453 3a 5d 24			ld a, (.dmark+2)  
2456 32 73 ee			ld (debug_mark+2),a  
2459 18 03			jr .pastdmark  
245b ..			.dmark: db "PAU"  
245e f1			.pastdmark: pop af  
245f			endm  
# End of macro DMARK
245f						CALLMONITOR 
245f cd ae 13			call break_point_state  
2462				endm  
# End of macro CALLMONITOR
2462					endif 
2462					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2462 cd ff 1b			call macro_dsp_valuehl 
2465				endm 
# End of macro FORTH_DSP_VALUEHL
2465			;		push hl    ; n2 
2465					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2465 cd b7 1c			call macro_forth_dsp_pop 
2468				endm 
# End of macro FORTH_DSP_POP
2468			;		pop hl 
2468 45					ld b, l 
2469					if DEBUG_FORTH_WORDS 
2469						DMARK "PAU" 
2469 f5				push af  
246a 3a 7e 24			ld a, (.dmark)  
246d 32 71 ee			ld (debug_mark),a  
2470 3a 7f 24			ld a, (.dmark+1)  
2473 32 72 ee			ld (debug_mark+1),a  
2476 3a 80 24			ld a, (.dmark+2)  
2479 32 73 ee			ld (debug_mark+2),a  
247c 18 03			jr .pastdmark  
247e ..			.dmark: db "PAU"  
2481 f1			.pastdmark: pop af  
2482			endm  
# End of macro DMARK
2482						CALLMONITOR 
2482 cd ae 13			call break_point_state  
2485				endm  
# End of macro CALLMONITOR
2485					endif 
2485 c5			.pauses1:	push bc 
2486 cd f2 08				call delay1s 
2489 c1					pop bc 
248a					if DEBUG_FORTH_WORDS 
248a						DMARK "PA1" 
248a f5				push af  
248b 3a 9f 24			ld a, (.dmark)  
248e 32 71 ee			ld (debug_mark),a  
2491 3a a0 24			ld a, (.dmark+1)  
2494 32 72 ee			ld (debug_mark+1),a  
2497 3a a1 24			ld a, (.dmark+2)  
249a 32 73 ee			ld (debug_mark+2),a  
249d 18 03			jr .pastdmark  
249f ..			.dmark: db "PA1"  
24a2 f1			.pastdmark: pop af  
24a3			endm  
# End of macro DMARK
24a3						CALLMONITOR 
24a3 cd ae 13			call break_point_state  
24a6				endm  
# End of macro CALLMONITOR
24a6					endif 
24a6 10 dd				djnz .pauses1 
24a8			 
24a8				       NEXTW 
24a8 c3 71 1d			jp macro_next 
24ab				endm 
# End of macro NEXTW
24ab			.ROT: 
24ab				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
24ab 45				db WORD_SYS_CORE+49             
24ac f9 24			dw .UWORDS            
24ae 04				db 3 + 1 
24af .. 00			db "ROT",0              
24b3				endm 
# End of macro CWHEAD
24b3			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
24b3					if DEBUG_FORTH_WORDS_KEY 
24b3						DMARK "ROT" 
24b3 f5				push af  
24b4 3a c8 24			ld a, (.dmark)  
24b7 32 71 ee			ld (debug_mark),a  
24ba 3a c9 24			ld a, (.dmark+1)  
24bd 32 72 ee			ld (debug_mark+1),a  
24c0 3a ca 24			ld a, (.dmark+2)  
24c3 32 73 ee			ld (debug_mark+2),a  
24c6 18 03			jr .pastdmark  
24c8 ..			.dmark: db "ROT"  
24cb f1			.pastdmark: pop af  
24cc			endm  
# End of macro DMARK
24cc						CALLMONITOR 
24cc cd ae 13			call break_point_state  
24cf				endm  
# End of macro CALLMONITOR
24cf					endif 
24cf			 
24cf					FORTH_DSP_VALUEHL 
24cf cd ff 1b			call macro_dsp_valuehl 
24d2				endm 
# End of macro FORTH_DSP_VALUEHL
24d2 e5					push hl    ; u3  
24d3			 
24d3					FORTH_DSP_POP 
24d3 cd b7 1c			call macro_forth_dsp_pop 
24d6				endm 
# End of macro FORTH_DSP_POP
24d6			   
24d6					FORTH_DSP_VALUEHL 
24d6 cd ff 1b			call macro_dsp_valuehl 
24d9				endm 
# End of macro FORTH_DSP_VALUEHL
24d9 e5					push hl     ; u2 
24da			 
24da					FORTH_DSP_POP 
24da cd b7 1c			call macro_forth_dsp_pop 
24dd				endm 
# End of macro FORTH_DSP_POP
24dd			 
24dd					FORTH_DSP_VALUEHL 
24dd cd ff 1b			call macro_dsp_valuehl 
24e0				endm 
# End of macro FORTH_DSP_VALUEHL
24e0 e5					push hl     ; u1 
24e1			 
24e1					FORTH_DSP_POP 
24e1 cd b7 1c			call macro_forth_dsp_pop 
24e4				endm 
# End of macro FORTH_DSP_POP
24e4			 
24e4 c1					pop bc      ; u1 
24e5 e1					pop hl      ; u2 
24e6 d1					pop de      ; u3 
24e7			 
24e7			 
24e7 c5					push bc 
24e8 d5					push de 
24e9 e5					push hl 
24ea			 
24ea			 
24ea e1					pop hl 
24eb cd 08 1a				call forth_push_numhl 
24ee			 
24ee e1					pop hl 
24ef cd 08 1a				call forth_push_numhl 
24f2			 
24f2 e1					pop hl 
24f3 cd 08 1a				call forth_push_numhl 
24f6					 
24f6			 
24f6			 
24f6			 
24f6			 
24f6			 
24f6				       NEXTW 
24f6 c3 71 1d			jp macro_next 
24f9				endm 
# End of macro NEXTW
24f9			 
24f9			.UWORDS: 
24f9				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
24f9 50				db WORD_SYS_CORE+60             
24fa bb 25			dw .BP            
24fc 07				db 6 + 1 
24fd .. 00			db "UWORDS",0              
2504				endm 
# End of macro CWHEAD
2504			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2504			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2504			; | | Following the count are the individual words. 
2504			; | | 
2504			; | | e.g. UWORDS 
2504			; | | BOX DIRLIST 2 
2504			; | |  
2504			; | | Can be used to save the words to storage via: 
2504			; | | UWORDS $01 DO $01 APPEND LOOP 
2504				if DEBUG_FORTH_WORDS_KEY 
2504					DMARK "UWR" 
2504 f5				push af  
2505 3a 19 25			ld a, (.dmark)  
2508 32 71 ee			ld (debug_mark),a  
250b 3a 1a 25			ld a, (.dmark+1)  
250e 32 72 ee			ld (debug_mark+1),a  
2511 3a 1b 25			ld a, (.dmark+2)  
2514 32 73 ee			ld (debug_mark+2),a  
2517 18 03			jr .pastdmark  
2519 ..			.dmark: db "UWR"  
251c f1			.pastdmark: pop af  
251d			endm  
# End of macro DMARK
251d					CALLMONITOR 
251d cd ae 13			call break_point_state  
2520				endm  
# End of macro CALLMONITOR
2520				endif 
2520 21 46 59				ld hl, baseram 
2523					;ld hl, baseusermem 
2523 01 00 00				ld bc, 0    ; start a counter 
2526			 
2526				; skip dict stub 
2526			 
2526 cd c2 1e				call forth_tok_next 
2529			 
2529			 
2529			; while we have words to look for 
2529			 
2529 7e			.douscan:	ld a, (hl)      
252a				if DEBUG_FORTH_WORDS 
252a					DMARK "UWs" 
252a f5				push af  
252b 3a 3f 25			ld a, (.dmark)  
252e 32 71 ee			ld (debug_mark),a  
2531 3a 40 25			ld a, (.dmark+1)  
2534 32 72 ee			ld (debug_mark+1),a  
2537 3a 41 25			ld a, (.dmark+2)  
253a 32 73 ee			ld (debug_mark+2),a  
253d 18 03			jr .pastdmark  
253f ..			.dmark: db "UWs"  
2542 f1			.pastdmark: pop af  
2543			endm  
# End of macro DMARK
2543					CALLMONITOR 
2543 cd ae 13			call break_point_state  
2546				endm  
# End of macro CALLMONITOR
2546				endif 
2546 fe 00				cp WORD_SYS_END 
2548 28 4d				jr z, .udone 
254a fe 01				cp WORD_SYS_UWORD 
254c 20 44				jr nz, .nuword 
254e			 
254e				if DEBUG_FORTH_WORDS 
254e					DMARK "UWu" 
254e f5				push af  
254f 3a 63 25			ld a, (.dmark)  
2552 32 71 ee			ld (debug_mark),a  
2555 3a 64 25			ld a, (.dmark+1)  
2558 32 72 ee			ld (debug_mark+1),a  
255b 3a 65 25			ld a, (.dmark+2)  
255e 32 73 ee			ld (debug_mark+2),a  
2561 18 03			jr .pastdmark  
2563 ..			.dmark: db "UWu"  
2566 f1			.pastdmark: pop af  
2567			endm  
# End of macro DMARK
2567					CALLMONITOR 
2567 cd ae 13			call break_point_state  
256a				endm  
# End of macro CALLMONITOR
256a				endif 
256a					; we have a uword so push its name to the stack 
256a			 
256a e5				   	push hl  ; save so we can move to next dict block 
256b			 
256b					; skip opcode 
256b 23					inc hl  
256c					; skip next ptr 
256c 23					inc hl  
256d 23					inc hl 
256e					; skip len 
256e 23					inc hl 
256f				if DEBUG_FORTH_WORDS 
256f					DMARK "UWt" 
256f f5				push af  
2570 3a 84 25			ld a, (.dmark)  
2573 32 71 ee			ld (debug_mark),a  
2576 3a 85 25			ld a, (.dmark+1)  
2579 32 72 ee			ld (debug_mark+1),a  
257c 3a 86 25			ld a, (.dmark+2)  
257f 32 73 ee			ld (debug_mark+2),a  
2582 18 03			jr .pastdmark  
2584 ..			.dmark: db "UWt"  
2587 f1			.pastdmark: pop af  
2588			endm  
# End of macro DMARK
2588					CALLMONITOR 
2588 cd ae 13			call break_point_state  
258b				endm  
# End of macro CALLMONITOR
258b				endif 
258b 03					inc bc 
258c			 
258c c5					push bc 
258d cd 76 1a				call forth_push_str 
2590 c1					pop bc 
2591			 
2591 e1					pop hl 	 
2592			 
2592 cd c2 1e		.nuword:	call forth_tok_next 
2595 18 92				jr .douscan  
2597			 
2597			.udone:		 ; push count of uwords found 
2597 c5					push bc 
2598 e1					pop hl 
2599			 
2599				if DEBUG_FORTH_WORDS 
2599					DMARK "UWc" 
2599 f5				push af  
259a 3a ae 25			ld a, (.dmark)  
259d 32 71 ee			ld (debug_mark),a  
25a0 3a af 25			ld a, (.dmark+1)  
25a3 32 72 ee			ld (debug_mark+1),a  
25a6 3a b0 25			ld a, (.dmark+2)  
25a9 32 73 ee			ld (debug_mark+2),a  
25ac 18 03			jr .pastdmark  
25ae ..			.dmark: db "UWc"  
25b1 f1			.pastdmark: pop af  
25b2			endm  
# End of macro DMARK
25b2					CALLMONITOR 
25b2 cd ae 13			call break_point_state  
25b5				endm  
# End of macro CALLMONITOR
25b5				endif 
25b5 cd 08 1a				call forth_push_numhl 
25b8			 
25b8			 
25b8				       NEXTW 
25b8 c3 71 1d			jp macro_next 
25bb				endm 
# End of macro NEXTW
25bb			 
25bb			.BP: 
25bb				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
25bb 54				db WORD_SYS_CORE+64             
25bc f1 25			dw .MONITOR            
25be 03				db 2 + 1 
25bf .. 00			db "BP",0              
25c2				endm 
# End of macro CWHEAD
25c2			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
25c2			; | | $00 Will enable the break points within specific code paths 
25c2			; | | $01 Will disable break points 
25c2			; | |  
25c2			; | | By default break points are off. Either the above can be used to enable them 
25c2			; | | or if a key is held down during start up the spashscreen will appear to freeze 
25c2			; | | and on release of the pressed key a message will be disaplayed to notify 
25c2			; | | that break points are enabled. Pressing any key will then continue boot process. 
25c2					; get byte count 
25c2					if DEBUG_FORTH_WORDS_KEY 
25c2						DMARK "BP." 
25c2 f5				push af  
25c3 3a d7 25			ld a, (.dmark)  
25c6 32 71 ee			ld (debug_mark),a  
25c9 3a d8 25			ld a, (.dmark+1)  
25cc 32 72 ee			ld (debug_mark+1),a  
25cf 3a d9 25			ld a, (.dmark+2)  
25d2 32 73 ee			ld (debug_mark+2),a  
25d5 18 03			jr .pastdmark  
25d7 ..			.dmark: db "BP."  
25da f1			.pastdmark: pop af  
25db			endm  
# End of macro DMARK
25db						CALLMONITOR 
25db cd ae 13			call break_point_state  
25de				endm  
# End of macro CALLMONITOR
25de					endif 
25de			 
25de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25de cd ff 1b			call macro_dsp_valuehl 
25e1				endm 
# End of macro FORTH_DSP_VALUEHL
25e1			 
25e1			;		push hl 
25e1			 
25e1					; destroy value TOS 
25e1			 
25e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25e1 cd b7 1c			call macro_forth_dsp_pop 
25e4				endm 
# End of macro FORTH_DSP_POP
25e4			 
25e4			;		pop hl 
25e4			 
25e4 3e 00				ld a,0 
25e6 bd					cp l 
25e7 28 02				jr z, .bpset 
25e9 3e 2a				ld a, '*' 
25eb			 
25eb 32 48 e3		.bpset:		ld (os_view_disable), a 
25ee			 
25ee			 
25ee					NEXTW 
25ee c3 71 1d			jp macro_next 
25f1				endm 
# End of macro NEXTW
25f1			 
25f1			 
25f1			.MONITOR: 
25f1				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
25f1 55				db WORD_SYS_CORE+65             
25f2 24 26			dw .MALLOC            
25f4 08				db 7 + 1 
25f5 .. 00			db "MONITOR",0              
25fd				endm 
# End of macro CWHEAD
25fd			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
25fd			; | | At start the current various registers will be displayed with contents. 
25fd			; | | Top right corner will show the most recent debug marker seen. 
25fd			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
25fd			; | | and the return stack pointer (RSP). 
25fd			; | | Pressing: 
25fd			; | |    1 - Initial screen 
25fd			; | |    2 - Display a data dump of HL 
25fd			; | |    3 - Display a data dump of DE 
25fd			; | |    4 - Display a data dump of BC 
25fd			; | |    5 - Display a data dump of HL 
25fd			; | |    6 - Display a data dump of DSP 
25fd			; | |    7 - Display a data dump of RSP 
25fd			; | |    8 - Display a data dump of what is at DSP 
25fd			; | |    9 - Display a data dump of what is at RSP 
25fd			; | |    0 - Exit monitor and continue running. This will also enable break points 
25fd			; | |    * - Disable break points 
25fd			; | |    # - Enter traditional monitor mode 
25fd			; | | 
25fd			; | | Monitor Mode 
25fd			; | | ------------ 
25fd			; | | A prompt of '>' will be shown for various commands: 
25fd			; | |    D xxxx - Display a data dump starting from hex address xxxx 
25fd			; | |    C - Continue display a data dump from the last set address 
25fd			; | |    M xxxx - Set start of memory edit at address xx 
25fd			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
25fd			; | |    Q - Return to previous 
25fd					if DEBUG_FORTH_WORDS_KEY 
25fd						DMARK "MON" 
25fd f5				push af  
25fe 3a 12 26			ld a, (.dmark)  
2601 32 71 ee			ld (debug_mark),a  
2604 3a 13 26			ld a, (.dmark+1)  
2607 32 72 ee			ld (debug_mark+1),a  
260a 3a 14 26			ld a, (.dmark+2)  
260d 32 73 ee			ld (debug_mark+2),a  
2610 18 03			jr .pastdmark  
2612 ..			.dmark: db "MON"  
2615 f1			.pastdmark: pop af  
2616			endm  
# End of macro DMARK
2616						CALLMONITOR 
2616 cd ae 13			call break_point_state  
2619				endm  
# End of macro CALLMONITOR
2619					endif 
2619 3e 00				ld a, 0 
261b 32 48 e3				ld (os_view_disable), a 
261e			 
261e					CALLMONITOR 
261e cd ae 13			call break_point_state  
2621				endm  
# End of macro CALLMONITOR
2621			 
2621			;	call monitor 
2621			 
2621					NEXTW 
2621 c3 71 1d			jp macro_next 
2624				endm 
# End of macro NEXTW
2624			 
2624			 
2624			.MALLOC: 
2624				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2624 56				db WORD_SYS_CORE+66             
2625 4d 26			dw .MALLOC2            
2627 06				db 5 + 1 
2628 .. 00			db "ALLOT",0              
262e				endm 
# End of macro CWHEAD
262e			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
262e					if DEBUG_FORTH_WORDS_KEY 
262e						DMARK "ALL" 
262e f5				push af  
262f 3a 43 26			ld a, (.dmark)  
2632 32 71 ee			ld (debug_mark),a  
2635 3a 44 26			ld a, (.dmark+1)  
2638 32 72 ee			ld (debug_mark+1),a  
263b 3a 45 26			ld a, (.dmark+2)  
263e 32 73 ee			ld (debug_mark+2),a  
2641 18 03			jr .pastdmark  
2643 ..			.dmark: db "ALL"  
2646 f1			.pastdmark: pop af  
2647			endm  
# End of macro DMARK
2647						CALLMONITOR 
2647 cd ae 13			call break_point_state  
264a				endm  
# End of macro CALLMONITOR
264a					endif 
264a c3 74 26				jp .mallocc 
264d			.MALLOC2: 
264d				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
264d 56				db WORD_SYS_CORE+66             
264e 8b 26			dw .FREE            
2650 07				db 6 + 1 
2651 .. 00			db "MALLOC",0              
2658				endm 
# End of macro CWHEAD
2658			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2658					; get byte count 
2658					if DEBUG_FORTH_WORDS_KEY 
2658						DMARK "MAL" 
2658 f5				push af  
2659 3a 6d 26			ld a, (.dmark)  
265c 32 71 ee			ld (debug_mark),a  
265f 3a 6e 26			ld a, (.dmark+1)  
2662 32 72 ee			ld (debug_mark+1),a  
2665 3a 6f 26			ld a, (.dmark+2)  
2668 32 73 ee			ld (debug_mark+2),a  
266b 18 03			jr .pastdmark  
266d ..			.dmark: db "MAL"  
2670 f1			.pastdmark: pop af  
2671			endm  
# End of macro DMARK
2671						CALLMONITOR 
2671 cd ae 13			call break_point_state  
2674				endm  
# End of macro CALLMONITOR
2674					endif 
2674			.mallocc: 
2674					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2674 cd ff 1b			call macro_dsp_valuehl 
2677				endm 
# End of macro FORTH_DSP_VALUEHL
2677			 
2677			;		push hl 
2677			 
2677					; destroy value TOS 
2677			 
2677					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2677 cd b7 1c			call macro_forth_dsp_pop 
267a				endm 
# End of macro FORTH_DSP_POP
267a			 
267a			;		pop hl 
267a cd 74 10				call malloc 
267d				if DEBUG_FORTH_MALLOC_GUARD 
267d f5					push af 
267e cd d6 0b				call ishlzero 
2681			;		ld a, l 
2681			;		add h 
2681			;		cp 0 
2681 f1					pop af 
2682					 
2682 cc a3 45				call z,malloc_error 
2685				endif 
2685			 
2685 cd 08 1a				call forth_push_numhl 
2688					NEXTW 
2688 c3 71 1d			jp macro_next 
268b				endm 
# End of macro NEXTW
268b			 
268b			.FREE: 
268b				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
268b 57				db WORD_SYS_CORE+67             
268c bc 26			dw .LIST            
268e 05				db 4 + 1 
268f .. 00			db "FREE",0              
2694				endm 
# End of macro CWHEAD
2694			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2694					if DEBUG_FORTH_WORDS_KEY 
2694						DMARK "FRE" 
2694 f5				push af  
2695 3a a9 26			ld a, (.dmark)  
2698 32 71 ee			ld (debug_mark),a  
269b 3a aa 26			ld a, (.dmark+1)  
269e 32 72 ee			ld (debug_mark+1),a  
26a1 3a ab 26			ld a, (.dmark+2)  
26a4 32 73 ee			ld (debug_mark+2),a  
26a7 18 03			jr .pastdmark  
26a9 ..			.dmark: db "FRE"  
26ac f1			.pastdmark: pop af  
26ad			endm  
# End of macro DMARK
26ad						CALLMONITOR 
26ad cd ae 13			call break_point_state  
26b0				endm  
# End of macro CALLMONITOR
26b0					endif 
26b0					; get address 
26b0			 
26b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b0 cd ff 1b			call macro_dsp_valuehl 
26b3				endm 
# End of macro FORTH_DSP_VALUEHL
26b3			 
26b3			;		push hl 
26b3			 
26b3					; destroy value TOS 
26b3			 
26b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26b3 cd b7 1c			call macro_forth_dsp_pop 
26b6				endm 
# End of macro FORTH_DSP_POP
26b6			 
26b6			;		pop hl 
26b6			if FORTH_ENABLE_MALLOCFREE 
26b6 cd 3e 11				call free 
26b9			endif 
26b9					NEXTW 
26b9 c3 71 1d			jp macro_next 
26bc				endm 
# End of macro NEXTW
26bc			.LIST: 
26bc				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
26bc 5c				db WORD_SYS_CORE+72             
26bd aa 28			dw .FORGET            
26bf 05				db 4 + 1 
26c0 .. 00			db "LIST",0              
26c5				endm 
# End of macro CWHEAD
26c5			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
26c5			; | | The quoted word must be in upper case. 
26c5				if DEBUG_FORTH_WORDS_KEY 
26c5					DMARK "LST" 
26c5 f5				push af  
26c6 3a da 26			ld a, (.dmark)  
26c9 32 71 ee			ld (debug_mark),a  
26cc 3a db 26			ld a, (.dmark+1)  
26cf 32 72 ee			ld (debug_mark+1),a  
26d2 3a dc 26			ld a, (.dmark+2)  
26d5 32 73 ee			ld (debug_mark+2),a  
26d8 18 03			jr .pastdmark  
26da ..			.dmark: db "LST"  
26dd f1			.pastdmark: pop af  
26de			endm  
# End of macro DMARK
26de					CALLMONITOR 
26de cd ae 13			call break_point_state  
26e1				endm  
# End of macro CALLMONITOR
26e1				endif 
26e1			 
26e1					FORTH_DSP_VALUEHL 
26e1 cd ff 1b			call macro_dsp_valuehl 
26e4				endm 
# End of macro FORTH_DSP_VALUEHL
26e4			 
26e4 e5					push hl 
26e5					FORTH_DSP_POP 
26e5 cd b7 1c			call macro_forth_dsp_pop 
26e8				endm 
# End of macro FORTH_DSP_POP
26e8 c1					pop bc 
26e9			 
26e9			; Start format of scratch string 
26e9			 
26e9 21 57 e3				ld hl, scratch 
26ec			 
26ec 3e 3a				ld a, ':' 
26ee 77					ld (hl),a 
26ef 23					inc hl 
26f0 3e 20				ld a, ' ' 
26f2 77					ld (hl), a 
26f3			 
26f3					; Get ptr to the word we need to look up 
26f3			 
26f3			;		FORTH_DSP_VALUEHL 
26f3					;v5 FORTH_DSP_VALUE 
26f3				; TODO type check 
26f3			;		inc hl    ; Skip type check  
26f3			;		push hl 
26f3			;		ex de, hl    ; put into DE 
26f3			 
26f3			 
26f3 21 46 59				ld hl, baseram 
26f6					;ld hl, baseusermem 
26f6			 
26f6 e5			push hl   ; sacreifical push 
26f7			 
26f7			.ldouscanm: 
26f7 e1				pop hl 
26f8			.ldouscan: 
26f8				if DEBUG_FORTH_WORDS 
26f8					DMARK "LSs" 
26f8 f5				push af  
26f9 3a 0d 27			ld a, (.dmark)  
26fc 32 71 ee			ld (debug_mark),a  
26ff 3a 0e 27			ld a, (.dmark+1)  
2702 32 72 ee			ld (debug_mark+1),a  
2705 3a 0f 27			ld a, (.dmark+2)  
2708 32 73 ee			ld (debug_mark+2),a  
270b 18 03			jr .pastdmark  
270d ..			.dmark: db "LSs"  
2710 f1			.pastdmark: pop af  
2711			endm  
# End of macro DMARK
2711					CALLMONITOR 
2711 cd ae 13			call break_point_state  
2714				endm  
# End of macro CALLMONITOR
2714				endif 
2714				; skip dict stub 
2714 cd c2 1e				call forth_tok_next 
2717			 
2717			 
2717			; while we have words to look for 
2717			 
2717 7e				ld a, (hl)      
2718				if DEBUG_FORTH_WORDS 
2718					DMARK "LSk" 
2718 f5				push af  
2719 3a 2d 27			ld a, (.dmark)  
271c 32 71 ee			ld (debug_mark),a  
271f 3a 2e 27			ld a, (.dmark+1)  
2722 32 72 ee			ld (debug_mark+1),a  
2725 3a 2f 27			ld a, (.dmark+2)  
2728 32 73 ee			ld (debug_mark+2),a  
272b 18 03			jr .pastdmark  
272d ..			.dmark: db "LSk"  
2730 f1			.pastdmark: pop af  
2731			endm  
# End of macro DMARK
2731					CALLMONITOR 
2731 cd ae 13			call break_point_state  
2734				endm  
# End of macro CALLMONITOR
2734				endif 
2734					;cp WORD_SYS_END 
2734					;jp z, .lunotfound 
2734			 
2734					; if we hit non uwords then gone too far 
2734 fe 01				cp WORD_SYS_UWORD 
2736 c2 66 28				jp nz, .lunotfound 
2739			 
2739				if DEBUG_FORTH_WORDS 
2739					DMARK "LSu" 
2739 f5				push af  
273a 3a 4e 27			ld a, (.dmark)  
273d 32 71 ee			ld (debug_mark),a  
2740 3a 4f 27			ld a, (.dmark+1)  
2743 32 72 ee			ld (debug_mark+1),a  
2746 3a 50 27			ld a, (.dmark+2)  
2749 32 73 ee			ld (debug_mark+2),a  
274c 18 03			jr .pastdmark  
274e ..			.dmark: db "LSu"  
2751 f1			.pastdmark: pop af  
2752			endm  
# End of macro DMARK
2752					CALLMONITOR 
2752 cd ae 13			call break_point_state  
2755				endm  
# End of macro CALLMONITOR
2755				endif 
2755			 
2755					; found a uword but is it the one we want... 
2755			 
2755 c5					push bc     ; uword to find is on bc 
2756 d1					pop de 
2757			 
2757 e5					push hl  ; to save the ptr 
2758			 
2758					; skip opcode 
2758 23					inc hl  
2759					; skip next ptr 
2759 23					inc hl  
275a 23					inc hl 
275b					; skip len 
275b 23					inc hl 
275c			 
275c				if DEBUG_FORTH_WORDS 
275c					DMARK "LSc" 
275c f5				push af  
275d 3a 71 27			ld a, (.dmark)  
2760 32 71 ee			ld (debug_mark),a  
2763 3a 72 27			ld a, (.dmark+1)  
2766 32 72 ee			ld (debug_mark+1),a  
2769 3a 73 27			ld a, (.dmark+2)  
276c 32 73 ee			ld (debug_mark+2),a  
276f 18 03			jr .pastdmark  
2771 ..			.dmark: db "LSc"  
2774 f1			.pastdmark: pop af  
2775			endm  
# End of macro DMARK
2775					CALLMONITOR 
2775 cd ae 13			call break_point_state  
2778				endm  
# End of macro CALLMONITOR
2778				endif 
2778 cd 43 10				call strcmp 
277b c2 f7 26				jp nz, .ldouscanm 
277e				 
277e			 
277e			 
277e					; we have a uword so push its name to the stack 
277e			 
277e			;	   	push hl  ; save so we can move to next dict block 
277e e1			pop hl 
277f			 
277f				if DEBUG_FORTH_WORDS 
277f					DMARK "LSm" 
277f f5				push af  
2780 3a 94 27			ld a, (.dmark)  
2783 32 71 ee			ld (debug_mark),a  
2786 3a 95 27			ld a, (.dmark+1)  
2789 32 72 ee			ld (debug_mark+1),a  
278c 3a 96 27			ld a, (.dmark+2)  
278f 32 73 ee			ld (debug_mark+2),a  
2792 18 03			jr .pastdmark  
2794 ..			.dmark: db "LSm"  
2797 f1			.pastdmark: pop af  
2798			endm  
# End of macro DMARK
2798					CALLMONITOR 
2798 cd ae 13			call break_point_state  
279b				endm  
# End of macro CALLMONITOR
279b				endif 
279b			 
279b					; skip opcode 
279b 23					inc hl  
279c					; skip next ptr 
279c 23					inc hl  
279d 23					inc hl 
279e					; skip len 
279e 7e					ld a, (hl)   ; save length to add 
279f				if DEBUG_FORTH_WORDS 
279f					DMARK "LS2" 
279f f5				push af  
27a0 3a b4 27			ld a, (.dmark)  
27a3 32 71 ee			ld (debug_mark),a  
27a6 3a b5 27			ld a, (.dmark+1)  
27a9 32 72 ee			ld (debug_mark+1),a  
27ac 3a b6 27			ld a, (.dmark+2)  
27af 32 73 ee			ld (debug_mark+2),a  
27b2 18 03			jr .pastdmark  
27b4 ..			.dmark: db "LS2"  
27b7 f1			.pastdmark: pop af  
27b8			endm  
# End of macro DMARK
27b8					CALLMONITOR 
27b8 cd ae 13			call break_point_state  
27bb				endm  
# End of macro CALLMONITOR
27bb				endif 
27bb			 
27bb					; save this location 
27bb				 
27bb e5					push hl 
27bc			 
27bc 23					inc hl 
27bd 11 59 e3				ld de, scratch+2 
27c0 4f					ld c, a 
27c1 06 00				ld b, 0 
27c3			 
27c3				if DEBUG_FORTH_WORDS 
27c3					DMARK "LSn" 
27c3 f5				push af  
27c4 3a d8 27			ld a, (.dmark)  
27c7 32 71 ee			ld (debug_mark),a  
27ca 3a d9 27			ld a, (.dmark+1)  
27cd 32 72 ee			ld (debug_mark+1),a  
27d0 3a da 27			ld a, (.dmark+2)  
27d3 32 73 ee			ld (debug_mark+2),a  
27d6 18 03			jr .pastdmark  
27d8 ..			.dmark: db "LSn"  
27db f1			.pastdmark: pop af  
27dc			endm  
# End of macro DMARK
27dc					CALLMONITOR 
27dc cd ae 13			call break_point_state  
27df				endm  
# End of macro CALLMONITOR
27df				endif 
27df			 
27df					; copy uword name to scratch 
27df			 
27df ed b0				ldir 
27e1			 
27e1 1b					dec de 
27e2 3e 20				ld a, ' '    ; change null to space 
27e4 12					ld (de), a 
27e5			 
27e5 13					inc de 
27e6			 
27e6 d5					push de 
27e7 c1					pop bc     ; move scratch pointer to end of word name and save it 
27e8			 
27e8 e1					pop hl 
27e9 7e					ld a, (hl) 
27ea					;inc hl 
27ea					; skip word string 
27ea cd ad 0b				call addatohl 
27ed			 
27ed 23					inc hl 
27ee			 
27ee				if DEBUG_FORTH_WORDS 
27ee					DMARK "LS3" 
27ee f5				push af  
27ef 3a 03 28			ld a, (.dmark)  
27f2 32 71 ee			ld (debug_mark),a  
27f5 3a 04 28			ld a, (.dmark+1)  
27f8 32 72 ee			ld (debug_mark+1),a  
27fb 3a 05 28			ld a, (.dmark+2)  
27fe 32 73 ee			ld (debug_mark+2),a  
2801 18 03			jr .pastdmark  
2803 ..			.dmark: db "LS3"  
2806 f1			.pastdmark: pop af  
2807			endm  
# End of macro DMARK
2807					CALLMONITOR 
2807 cd ae 13			call break_point_state  
280a				endm  
# End of macro CALLMONITOR
280a				endif 
280a					; should now be at the start of the machine code to setup the eval of the uword 
280a					; now locate the ptr to the string defintion 
280a			 
280a					; skip ld hl, 
280a					; then load the ptr 
280a			; TODO use get from hl ptr 
280a 23					inc hl 
280b 5e					ld e, (hl) 
280c 23					inc hl 
280d 56					ld d, (hl) 
280e eb					ex de, hl 
280f			 
280f			 
280f				if DEBUG_FORTH_WORDS 
280f					DMARK "LSt" 
280f f5				push af  
2810 3a 24 28			ld a, (.dmark)  
2813 32 71 ee			ld (debug_mark),a  
2816 3a 25 28			ld a, (.dmark+1)  
2819 32 72 ee			ld (debug_mark+1),a  
281c 3a 26 28			ld a, (.dmark+2)  
281f 32 73 ee			ld (debug_mark+2),a  
2822 18 03			jr .pastdmark  
2824 ..			.dmark: db "LSt"  
2827 f1			.pastdmark: pop af  
2828			endm  
# End of macro DMARK
2828					CALLMONITOR 
2828 cd ae 13			call break_point_state  
282b				endm  
# End of macro CALLMONITOR
282b				endif 
282b			 
282b			; cant push right now due to tokenised strings  
282b			 
282b			; get the destination of where to copy this definition to. 
282b			 
282b c5					push bc 
282c d1					pop de 
282d			 
282d 7e			.listl:         ld a,(hl) 
282e fe 00				cp 0 
2830 28 09				jr z, .lreplsp     ; replace zero with space 
2832					;cp FORTH_END_BUFFER 
2832 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2834 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2836				 
2836					; just copy this char as is then 
2836			 
2836 12					ld (de), a 
2837			 
2837 23			.listnxt:	inc hl 
2838 13					inc de 
2839 18 f2				jr .listl 
283b			 
283b 3e 20		.lreplsp:	ld a,' ' 
283d 12					ld (de), a 
283e 18 f7				jr .listnxt 
2840			 
2840			; close up uword def 
2840			 
2840			.listdone: 
2840 12					ld (de), a 
2841 13					inc de 
2842 3e 00				ld a, 0 
2844 12					ld (de), a 
2845			 
2845			; now have def so clean up and push to stack 
2845			 
2845 21 57 e3				ld hl, scratch 
2848				if DEBUG_FORTH_WORDS 
2848					DMARK "Ltp" 
2848 f5				push af  
2849 3a 5d 28			ld a, (.dmark)  
284c 32 71 ee			ld (debug_mark),a  
284f 3a 5e 28			ld a, (.dmark+1)  
2852 32 72 ee			ld (debug_mark+1),a  
2855 3a 5f 28			ld a, (.dmark+2)  
2858 32 73 ee			ld (debug_mark+2),a  
285b 18 03			jr .pastdmark  
285d ..			.dmark: db "Ltp"  
2860 f1			.pastdmark: pop af  
2861			endm  
# End of macro DMARK
2861					CALLMONITOR 
2861 cd ae 13			call break_point_state  
2864				endm  
# End of macro CALLMONITOR
2864				endif 
2864			 
2864 18 1f			jr .listpush 
2866			 
2866			;.lnuword:	pop hl 
2866			;		call forth_tok_next 
2866			;		jp .ldouscan  
2866			 
2866			.lunotfound:		  
2866			 
2866				if DEBUG_FORTH_WORDS 
2866					DMARK "LSn" 
2866 f5				push af  
2867 3a 7b 28			ld a, (.dmark)  
286a 32 71 ee			ld (debug_mark),a  
286d 3a 7c 28			ld a, (.dmark+1)  
2870 32 72 ee			ld (debug_mark+1),a  
2873 3a 7d 28			ld a, (.dmark+2)  
2876 32 73 ee			ld (debug_mark+2),a  
2879 18 03			jr .pastdmark  
287b ..			.dmark: db "LSn"  
287e f1			.pastdmark: pop af  
287f			endm  
# End of macro DMARK
287f					CALLMONITOR 
287f cd ae 13			call break_point_state  
2882				endm  
# End of macro CALLMONITOR
2882				endif 
2882			 
2882					 
2882			;		FORTH_DSP_POP 
2882			;		ld hl, .luno 
2882			 
2882					NEXTW			 
2882 c3 71 1d			jp macro_next 
2885				endm 
# End of macro NEXTW
2885			 
2885			.listpush: 
2885				if DEBUG_FORTH_WORDS 
2885					DMARK "LS>" 
2885 f5				push af  
2886 3a 9a 28			ld a, (.dmark)  
2889 32 71 ee			ld (debug_mark),a  
288c 3a 9b 28			ld a, (.dmark+1)  
288f 32 72 ee			ld (debug_mark+1),a  
2892 3a 9c 28			ld a, (.dmark+2)  
2895 32 73 ee			ld (debug_mark+2),a  
2898 18 03			jr .pastdmark  
289a ..			.dmark: db "LS>"  
289d f1			.pastdmark: pop af  
289e			endm  
# End of macro DMARK
289e					CALLMONITOR 
289e cd ae 13			call break_point_state  
28a1				endm  
# End of macro CALLMONITOR
28a1				endif 
28a1 cd 76 1a				call forth_push_str 
28a4			 
28a4			 
28a4			 
28a4					NEXTW 
28a4 c3 71 1d			jp macro_next 
28a7				endm 
# End of macro NEXTW
28a7			 
28a7			;.luno:    db "Word not found",0 
28a7			 
28a7			 
28a7			 
28a7			 
28a7			 
28a7			;		push hl   ; save pointer to start of uword def string 
28a7			; 
28a7			;; look for FORTH_EOL_LINE 
28a7			;		ld a, FORTH_END_BUFFER 
28a7			;		call strlent 
28a7			; 
28a7			;		inc hl		 ; space for coln def 
28a7			;		inc hl 
28a7			;		inc hl          ; space for terms 
28a7			;		inc hl 
28a7			; 
28a7			;		ld a, 20   ; TODO get actual length 
28a7			;		call addatohl    ; include a random amount of room for the uword name 
28a7			; 
28a7			;		 
28a7			;	if DEBUG_FORTH_WORDS 
28a7			;		DMARK "Lt1" 
28a7			;		CALLMONITOR 
28a7			;	endif 
28a7			;		 
28a7			; 
28a7			;; malloc space for the string because we cant change it 
28a7			; 
28a7			;		call malloc 
28a7			;	if DEBUG_FORTH_MALLOC_GUARD 
28a7			;		push af 
28a7			;		call ishlzero 
28a7			;		pop af 
28a7			;		 
28a7			;		call z,malloc_error 
28a7			;	endif 
28a7			; 
28a7			;	if DEBUG_FORTH_WORDS 
28a7			;		DMARK "Lt2" 
28a7			;		CALLMONITOR 
28a7			;	endif 
28a7			;		pop de 
28a7			;		push hl    ; push the malloc to release later 
28a7			;		push hl   ;  push back a copy for the later stack push 
28a7			;		 
28a7			;; copy the string swapping out the zero terms for spaces 
28a7			; 
28a7			;		; de has our source 
28a7			;		; hl has our dest 
28a7			; 
28a7			;; add the coln def 
28a7			; 
28a7			;		ld a, ':' 
28a7			;		ld (hl), a 
28a7			;		inc hl 
28a7			;		ld a, ' ' 
28a7			;		ld (hl), a 
28a7			;		inc hl 
28a7			; 
28a7			;; add the uname word 
28a7			;		push de   ; save our string for now 
28a7			;		ex de, hl 
28a7			; 
28a7			;		FORTH_DSP_VALUE 
28a7			;		;v5 FORTH_DSP_VALUE 
28a7			; 
28a7			;		inc hl   ; skip type but we know by now this is OK 
28a7			; 
28a7			;.luword:	ld a,(hl) 
28a7			;		cp 0 
28a7			;		jr z, .luword2 
28a7			;		ld (de), a 
28a7			;		inc de 
28a7			;		inc hl 
28a7			;		jr .luword 
28a7			; 
28a7			;.luword2:	ld a, ' ' 
28a7			;		ld (de), a 
28a7			;;		inc hl 
28a7			;;		inc de 
28a7			;;		ld (de), a 
28a7			;;		inc hl 
28a7			;		inc de 
28a7			; 
28a7			;		ex de, hl 
28a7			;		pop de 
28a7			;		 
28a7			;		 
28a7			; 
28a7			;; detoken that string and copy it 
28a7			; 
28a7			;	if DEBUG_FORTH_WORDS 
28a7			;		DMARK "Lt2" 
28a7			;		CALLMONITOR 
28a7			;	endif 
28a7			;.ldetok:	ld a, (de) 
28a7			;		cp FORTH_END_BUFFER 
28a7			;		jr z, .ldetokend 
28a7			;		; swap out any zero term for space 
28a7			;		cp 0 
28a7			;		jr nz, .ldetoknext 
28a7			;		ld a, ' ' 
28a7			; 
28a7			;	if DEBUG_FORTH_WORDS 
28a7			;		DMARK "LtS" 
28a7			;		CALLMONITOR 
28a7			;	endif 
28a7			;.ldetoknext:	ld (hl), a 
28a7			;		inc de 
28a7			;		inc hl 
28a7			;		jr .ldetok 
28a7			; 
28a7			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
28a7			;		ld (hl), a  
28a7			; 
28a7			;; free that temp malloc 
28a7			; 
28a7			;		pop hl    
28a7			; 
28a7			;	if DEBUG_FORTH_WORDS 
28a7			;		DMARK "Lt4" 
28a7			;		CALLMONITOR 
28a7			;	endif 
28a7			;		call forth_apushstrhl 
28a7			; 
28a7			;		; get rid of temp malloc area 
28a7			; 
28a7			;		pop hl 
28a7			;		call free 
28a7			; 
28a7			;		jr .ludone 
28a7			; 
28a7			;.lnuword:	pop hl 
28a7			;		call forth_tok_next 
28a7			;		jp .ldouscan  
28a7			; 
28a7			;.ludone:		 pop hl 
28a7			; 
28a7					NEXTW 
28a7 c3 71 1d			jp macro_next 
28aa				endm 
# End of macro NEXTW
28aa			 
28aa			.FORGET: 
28aa				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
28aa 5d				db WORD_SYS_CORE+73             
28ab 23 29			dw .NOP            
28ad 07				db 6 + 1 
28ae .. 00			db "FORGET",0              
28b5				endm 
# End of macro CWHEAD
28b5			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
28b5			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
28b5			; | |  
28b5			; | | e.g. "MORE" forget 
28b5					if DEBUG_FORTH_WORDS_KEY 
28b5						DMARK "FRG" 
28b5 f5				push af  
28b6 3a ca 28			ld a, (.dmark)  
28b9 32 71 ee			ld (debug_mark),a  
28bc 3a cb 28			ld a, (.dmark+1)  
28bf 32 72 ee			ld (debug_mark+1),a  
28c2 3a cc 28			ld a, (.dmark+2)  
28c5 32 73 ee			ld (debug_mark+2),a  
28c8 18 03			jr .pastdmark  
28ca ..			.dmark: db "FRG"  
28cd f1			.pastdmark: pop af  
28ce			endm  
# End of macro DMARK
28ce						CALLMONITOR 
28ce cd ae 13			call break_point_state  
28d1				endm  
# End of macro CALLMONITOR
28d1					endif 
28d1			 
28d1				; find uword 
28d1			        ; update start of word with "_" 
28d1				; replace uword with deleted flag 
28d1			 
28d1			 
28d1			;	if DEBUG_FORTH_WORDS 
28d1			;		DMARK "FOG" 
28d1			;		CALLMONITOR 
28d1			;	endif 
28d1			 
28d1			 
28d1					; Get ptr to the word we need to look up 
28d1			 
28d1					FORTH_DSP_VALUEHL 
28d1 cd ff 1b			call macro_dsp_valuehl 
28d4				endm 
# End of macro FORTH_DSP_VALUEHL
28d4					;v5 FORTH_DSP_VALUE 
28d4				; TODO type check 
28d4			;		inc hl    ; Skip type check  
28d4 e5					push hl 
28d5 c1					pop bc 
28d6			;		ex de, hl    ; put into DE 
28d6			 
28d6			 
28d6 21 46 59				ld hl, baseram 
28d9					;ld hl, baseusermem 
28d9			 
28d9				; skip dict stub 
28d9			;	call forth_tok_next 
28d9 e5			push hl   ; sacreifical push 
28da			 
28da			.fldouscanm: 
28da e1				pop hl 
28db			.fldouscan: 
28db			;	if DEBUG_FORTH_WORDS 
28db			;		DMARK "LSs" 
28db			;		CALLMONITOR 
28db			;	endif 
28db				; skip dict stub 
28db cd c2 1e				call forth_tok_next 
28de			 
28de			 
28de			; while we have words to look for 
28de			 
28de 7e				ld a, (hl)      
28df			;	if DEBUG_FORTH_WORDS 
28df			;		DMARK "LSk" 
28df			;		CALLMONITOR 
28df			;	endif 
28df fe 00				cp WORD_SYS_END 
28e1 ca 1d 29				jp z, .flunotfound 
28e4 fe 01				cp WORD_SYS_UWORD 
28e6 c2 db 28				jp nz, .fldouscan 
28e9			 
28e9			;	if DEBUG_FORTH_WORDS 
28e9			;		DMARK "LSu" 
28e9			;		CALLMONITOR 
28e9			;	endif 
28e9			 
28e9					; found a uword but is it the one we want... 
28e9			 
28e9 c5					push bc     ; uword to find is on bc 
28ea d1					pop de 
28eb			 
28eb e5					push hl  ; to save the ptr 
28ec			 
28ec					; skip opcode 
28ec 23					inc hl  
28ed					; skip next ptr 
28ed 23					inc hl  
28ee 23					inc hl 
28ef					; skip len 
28ef 23					inc hl 
28f0			 
28f0			;	if DEBUG_FORTH_WORDS 
28f0			;		DMARK "LSc" 
28f0			;		CALLMONITOR 
28f0			;	endif 
28f0 cd 43 10				call strcmp 
28f3 c2 da 28				jp nz, .fldouscanm 
28f6			; 
28f6			; 
28f6			;; while we have words to look for 
28f6			; 
28f6			;.fdouscan:	ld a, (hl)      
28f6			;	if DEBUG_FORTH_WORDS 
28f6			;		DMARK "LSs" 
28f6			;		CALLMONITOR 
28f6			;	endif 
28f6			;		cp WORD_SYS_END 
28f6			;		jp z, .fudone 
28f6			;		cp WORD_SYS_UWORD 
28f6			;		jp nz, .fnuword 
28f6			; 
28f6			;	if DEBUG_FORTH_WORDS 
28f6			;		DMARK "FGu" 
28f6			;		CALLMONITOR 
28f6			;	endif 
28f6			; 
28f6			;		; found a uword but is it the one we want... 
28f6			; 
28f6			; 
28f6			;	        pop de   ; get back the dsp name 
28f6			;		push de 
28f6			; 
28f6			;		push hl  ; to save the ptr 
28f6			; 
28f6			;		; skip opcode 
28f6			;		inc hl  
28f6			;		; skip next ptr 
28f6			;		inc hl  
28f6			;		inc hl 
28f6			;		; skip len 
28f6			;		inc hl 
28f6			; 
28f6			;	if DEBUG_FORTH_WORDS 
28f6			;		DMARK "FGc" 
28f6			;		CALLMONITOR 
28f6			;	endif 
28f6			;		call strcmp 
28f6			;		jp nz, .fnuword 
28f6			 
28f6			 
28f6 e1			pop hl 
28f7			 
28f7				 
28f7				if DEBUG_FORTH_WORDS 
28f7					DMARK "FGm" 
28f7 f5				push af  
28f8 3a 0c 29			ld a, (.dmark)  
28fb 32 71 ee			ld (debug_mark),a  
28fe 3a 0d 29			ld a, (.dmark+1)  
2901 32 72 ee			ld (debug_mark+1),a  
2904 3a 0e 29			ld a, (.dmark+2)  
2907 32 73 ee			ld (debug_mark+2),a  
290a 18 03			jr .pastdmark  
290c ..			.dmark: db "FGm"  
290f f1			.pastdmark: pop af  
2910			endm  
# End of macro DMARK
2910					CALLMONITOR 
2910 cd ae 13			call break_point_state  
2913				endm  
# End of macro CALLMONITOR
2913				endif 
2913			 
2913			 
2913			 
2913					; we have a uword so push its name to the stack 
2913			 
2913			;	   	push hl  ; save so we can move to next dict block 
2913			;pop hl 
2913			 
2913					; update opcode to deleted 
2913 3e 03				ld a, WORD_SYS_DELETED 
2915 77					ld (hl), a 
2916			 
2916 23					inc hl  
2917					; skip next ptr 
2917 23					inc hl  
2918 23					inc hl 
2919					; skip len 
2919 23					inc hl 
291a			 
291a					; TODO change parser to skip deleted words but for now mark it out 
291a 3e 5f				ld a, "_" 
291c 77					ld  (hl),a 
291d			 
291d			;		jr .fudone 
291d			; 
291d			;.fnuword:	pop hl 
291d			;		call forth_tok_next 
291d			;		jp .fdouscan  
291d			 
291d			.flunotfound:		  
291d			 
291d			 
291d					 
291d					FORTH_DSP_POP 
291d cd b7 1c			call macro_forth_dsp_pop 
2920				endm 
# End of macro FORTH_DSP_POP
2920			;		ld hl, .luno 
2920			;.fudone:		 pop hl 
2920					NEXTW 
2920 c3 71 1d			jp macro_next 
2923				endm 
# End of macro NEXTW
2923			.NOP: 
2923				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2923 61				db WORD_SYS_CORE+77             
2924 4a 29			dw .COMO            
2926 04				db 3 + 1 
2927 .. 00			db "NOP",0              
292b				endm 
# End of macro CWHEAD
292b			; | NOP (  --  ) Do nothing | DONE 
292b					if DEBUG_FORTH_WORDS_KEY 
292b						DMARK "NOP" 
292b f5				push af  
292c 3a 40 29			ld a, (.dmark)  
292f 32 71 ee			ld (debug_mark),a  
2932 3a 41 29			ld a, (.dmark+1)  
2935 32 72 ee			ld (debug_mark+1),a  
2938 3a 42 29			ld a, (.dmark+2)  
293b 32 73 ee			ld (debug_mark+2),a  
293e 18 03			jr .pastdmark  
2940 ..			.dmark: db "NOP"  
2943 f1			.pastdmark: pop af  
2944			endm  
# End of macro DMARK
2944						CALLMONITOR 
2944 cd ae 13			call break_point_state  
2947				endm  
# End of macro CALLMONITOR
2947					endif 
2947				       NEXTW 
2947 c3 71 1d			jp macro_next 
294a				endm 
# End of macro NEXTW
294a			.COMO: 
294a				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
294a 6e				db WORD_SYS_CORE+90             
294b 9c 29			dw .COMC            
294d 02				db 1 + 1 
294e .. 00			db "(",0              
2950				endm 
# End of macro CWHEAD
2950			; | ( ( -- )  Start of comment | DONE 
2950			 
2950			 
2950 2a 58 e6				ld hl, ( os_tok_ptr) 
2953 11 97 29			ld de, .closepar 
2956					 
2956					if DEBUG_FORTH_WORDS 
2956						DMARK ").." 
2956 f5				push af  
2957 3a 6b 29			ld a, (.dmark)  
295a 32 71 ee			ld (debug_mark),a  
295d 3a 6c 29			ld a, (.dmark+1)  
2960 32 72 ee			ld (debug_mark+1),a  
2963 3a 6d 29			ld a, (.dmark+2)  
2966 32 73 ee			ld (debug_mark+2),a  
2969 18 03			jr .pastdmark  
296b ..			.dmark: db ").."  
296e f1			.pastdmark: pop af  
296f			endm  
# End of macro DMARK
296f						CALLMONITOR 
296f cd ae 13			call break_point_state  
2972				endm  
# End of macro CALLMONITOR
2972					endif 
2972 cd 8c 1e			call findnexttok  
2975			 
2975					if DEBUG_FORTH_WORDS 
2975						DMARK "IF5" 
2975 f5				push af  
2976 3a 8a 29			ld a, (.dmark)  
2979 32 71 ee			ld (debug_mark),a  
297c 3a 8b 29			ld a, (.dmark+1)  
297f 32 72 ee			ld (debug_mark+1),a  
2982 3a 8c 29			ld a, (.dmark+2)  
2985 32 73 ee			ld (debug_mark+2),a  
2988 18 03			jr .pastdmark  
298a ..			.dmark: db "IF5"  
298d f1			.pastdmark: pop af  
298e			endm  
# End of macro DMARK
298e						CALLMONITOR 
298e cd ae 13			call break_point_state  
2991				endm  
# End of macro CALLMONITOR
2991					endif 
2991				; replace below with ) exec using tok_ptr 
2991 22 58 e6			ld (os_tok_ptr), hl 
2994 c3 02 1e			jp exec1 
2997			 
2997 .. 00			.closepar:   db ")",0 
2999			 
2999				       NEXTW 
2999 c3 71 1d			jp macro_next 
299c				endm 
# End of macro NEXTW
299c			.COMC: 
299c				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
299c 6f				db WORD_SYS_CORE+91             
299d a5 29			dw .SCRATCH            
299f 02				db 1 + 1 
29a0 .. 00			db ")",0              
29a2				endm 
# End of macro CWHEAD
29a2			; | ) ( -- )  End of comment |  DONE  
29a2				       NEXTW 
29a2 c3 71 1d			jp macro_next 
29a5				endm 
# End of macro NEXTW
29a5			 
29a5			.SCRATCH: 
29a5				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
29a5 6f				db WORD_SYS_CORE+91             
29a6 e0 29			dw .INC            
29a8 08				db 7 + 1 
29a9 .. 00			db "SCRATCH",0              
29b1				endm 
# End of macro CWHEAD
29b1			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
29b1			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
29b1			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
29b1			; | |  
29b1			; | | e.g.    : score $00 scratch ; 
29b1			; | |  
29b1			; | | $00 score ! 
29b1			; | | $01 score +! 
29b1			; | |  
29b1			; | | e.g.   : varword $0a scratch ;  
29b1			; | | 
29b1			; | | $8000 varword ! 
29b1					if DEBUG_FORTH_WORDS_KEY 
29b1						DMARK "SCR" 
29b1 f5				push af  
29b2 3a c6 29			ld a, (.dmark)  
29b5 32 71 ee			ld (debug_mark),a  
29b8 3a c7 29			ld a, (.dmark+1)  
29bb 32 72 ee			ld (debug_mark+1),a  
29be 3a c8 29			ld a, (.dmark+2)  
29c1 32 73 ee			ld (debug_mark+2),a  
29c4 18 03			jr .pastdmark  
29c6 ..			.dmark: db "SCR"  
29c9 f1			.pastdmark: pop af  
29ca			endm  
# End of macro DMARK
29ca						CALLMONITOR 
29ca cd ae 13			call break_point_state  
29cd				endm  
# End of macro CALLMONITOR
29cd					endif 
29cd			 
29cd					FORTH_DSP_VALUEHL 
29cd cd ff 1b			call macro_dsp_valuehl 
29d0				endm 
# End of macro FORTH_DSP_VALUEHL
29d0				 
29d0					FORTH_DSP_POP 
29d0 cd b7 1c			call macro_forth_dsp_pop 
29d3				endm 
# End of macro FORTH_DSP_POP
29d3			 
29d3 7d					ld a, l 
29d4 21 7c e8				ld hl, os_var_array 
29d7 cd ad 0b				call addatohl 
29da			 
29da cd 08 1a				call forth_push_numhl 
29dd			 
29dd				       NEXTW 
29dd c3 71 1d			jp macro_next 
29e0				endm 
# End of macro NEXTW
29e0			 
29e0			.INC: 
29e0				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
29e0 6f				db WORD_SYS_CORE+91             
29e1 34 2a			dw .DEC            
29e3 03				db 2 + 1 
29e4 .. 00			db "+!",0              
29e7				endm 
# End of macro CWHEAD
29e7			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
29e7					if DEBUG_FORTH_WORDS_KEY 
29e7						DMARK "+s_" 
29e7 f5				push af  
29e8 3a fc 29			ld a, (.dmark)  
29eb 32 71 ee			ld (debug_mark),a  
29ee 3a fd 29			ld a, (.dmark+1)  
29f1 32 72 ee			ld (debug_mark+1),a  
29f4 3a fe 29			ld a, (.dmark+2)  
29f7 32 73 ee			ld (debug_mark+2),a  
29fa 18 03			jr .pastdmark  
29fc ..			.dmark: db "+s_"  
29ff f1			.pastdmark: pop af  
2a00			endm  
# End of macro DMARK
2a00						CALLMONITOR 
2a00 cd ae 13			call break_point_state  
2a03				endm  
# End of macro CALLMONITOR
2a03					endif 
2a03			 
2a03					FORTH_DSP_VALUEHL 
2a03 cd ff 1b			call macro_dsp_valuehl 
2a06				endm 
# End of macro FORTH_DSP_VALUEHL
2a06			 
2a06 e5					push hl   ; save address 
2a07			 
2a07					FORTH_DSP_POP 
2a07 cd b7 1c			call macro_forth_dsp_pop 
2a0a				endm 
# End of macro FORTH_DSP_POP
2a0a			 
2a0a					FORTH_DSP_VALUEHL 
2a0a cd ff 1b			call macro_dsp_valuehl 
2a0d				endm 
# End of macro FORTH_DSP_VALUEHL
2a0d			 
2a0d					FORTH_DSP_POP 
2a0d cd b7 1c			call macro_forth_dsp_pop 
2a10				endm 
# End of macro FORTH_DSP_POP
2a10			 
2a10					; hl contains value to add to byte at a 
2a10				 
2a10 eb					ex de, hl 
2a11			 
2a11 e1					pop hl 
2a12			 
2a12					if DEBUG_FORTH_WORDS 
2a12						DMARK "INC" 
2a12 f5				push af  
2a13 3a 27 2a			ld a, (.dmark)  
2a16 32 71 ee			ld (debug_mark),a  
2a19 3a 28 2a			ld a, (.dmark+1)  
2a1c 32 72 ee			ld (debug_mark+1),a  
2a1f 3a 29 2a			ld a, (.dmark+2)  
2a22 32 73 ee			ld (debug_mark+2),a  
2a25 18 03			jr .pastdmark  
2a27 ..			.dmark: db "INC"  
2a2a f1			.pastdmark: pop af  
2a2b			endm  
# End of macro DMARK
2a2b						CALLMONITOR 
2a2b cd ae 13			call break_point_state  
2a2e				endm  
# End of macro CALLMONITOR
2a2e					endif 
2a2e			 
2a2e 7e					ld a,(hl) 
2a2f 83					add e 
2a30 77					ld (hl),a 
2a31			 
2a31			 
2a31			 
2a31				       NEXTW 
2a31 c3 71 1d			jp macro_next 
2a34				endm 
# End of macro NEXTW
2a34			 
2a34			.DEC: 
2a34				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2a34 6f				db WORD_SYS_CORE+91             
2a35 85 2a			dw .INC2            
2a37 03				db 2 + 1 
2a38 .. 00			db "-!",0              
2a3b				endm 
# End of macro CWHEAD
2a3b			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2a3b					if DEBUG_FORTH_WORDS_KEY 
2a3b						DMARK "-s_" 
2a3b f5				push af  
2a3c 3a 50 2a			ld a, (.dmark)  
2a3f 32 71 ee			ld (debug_mark),a  
2a42 3a 51 2a			ld a, (.dmark+1)  
2a45 32 72 ee			ld (debug_mark+1),a  
2a48 3a 52 2a			ld a, (.dmark+2)  
2a4b 32 73 ee			ld (debug_mark+2),a  
2a4e 18 03			jr .pastdmark  
2a50 ..			.dmark: db "-s_"  
2a53 f1			.pastdmark: pop af  
2a54			endm  
# End of macro DMARK
2a54						CALLMONITOR 
2a54 cd ae 13			call break_point_state  
2a57				endm  
# End of macro CALLMONITOR
2a57					endif 
2a57			 
2a57					FORTH_DSP_VALUEHL 
2a57 cd ff 1b			call macro_dsp_valuehl 
2a5a				endm 
# End of macro FORTH_DSP_VALUEHL
2a5a			 
2a5a e5					push hl   ; save address 
2a5b			 
2a5b					FORTH_DSP_POP 
2a5b cd b7 1c			call macro_forth_dsp_pop 
2a5e				endm 
# End of macro FORTH_DSP_POP
2a5e			 
2a5e					FORTH_DSP_VALUEHL 
2a5e cd ff 1b			call macro_dsp_valuehl 
2a61				endm 
# End of macro FORTH_DSP_VALUEHL
2a61			 
2a61					; hl contains value to add to byte at a 
2a61				 
2a61 eb					ex de, hl 
2a62			 
2a62 e1					pop hl 
2a63			 
2a63					if DEBUG_FORTH_WORDS 
2a63						DMARK "DEC" 
2a63 f5				push af  
2a64 3a 78 2a			ld a, (.dmark)  
2a67 32 71 ee			ld (debug_mark),a  
2a6a 3a 79 2a			ld a, (.dmark+1)  
2a6d 32 72 ee			ld (debug_mark+1),a  
2a70 3a 7a 2a			ld a, (.dmark+2)  
2a73 32 73 ee			ld (debug_mark+2),a  
2a76 18 03			jr .pastdmark  
2a78 ..			.dmark: db "DEC"  
2a7b f1			.pastdmark: pop af  
2a7c			endm  
# End of macro DMARK
2a7c						CALLMONITOR 
2a7c cd ae 13			call break_point_state  
2a7f				endm  
# End of macro CALLMONITOR
2a7f					endif 
2a7f			 
2a7f 7e					ld a,(hl) 
2a80 93					sub e 
2a81 77					ld (hl),a 
2a82			 
2a82			 
2a82			 
2a82				       NEXTW 
2a82 c3 71 1d			jp macro_next 
2a85				endm 
# End of macro NEXTW
2a85			 
2a85			.INC2: 
2a85				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2a85 6f				db WORD_SYS_CORE+91             
2a86 2f 2b			dw .DEC2            
2a88 04				db 3 + 1 
2a89 .. 00			db "+2!",0              
2a8d				endm 
# End of macro CWHEAD
2a8d			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2a8d			 
2a8d					if DEBUG_FORTH_WORDS_KEY 
2a8d						DMARK "+2s" 
2a8d f5				push af  
2a8e 3a a2 2a			ld a, (.dmark)  
2a91 32 71 ee			ld (debug_mark),a  
2a94 3a a3 2a			ld a, (.dmark+1)  
2a97 32 72 ee			ld (debug_mark+1),a  
2a9a 3a a4 2a			ld a, (.dmark+2)  
2a9d 32 73 ee			ld (debug_mark+2),a  
2aa0 18 03			jr .pastdmark  
2aa2 ..			.dmark: db "+2s"  
2aa5 f1			.pastdmark: pop af  
2aa6			endm  
# End of macro DMARK
2aa6						CALLMONITOR 
2aa6 cd ae 13			call break_point_state  
2aa9				endm  
# End of macro CALLMONITOR
2aa9					endif 
2aa9			 
2aa9					; Address 
2aa9			 
2aa9					FORTH_DSP_VALUEHL 
2aa9 cd ff 1b			call macro_dsp_valuehl 
2aac				endm 
# End of macro FORTH_DSP_VALUEHL
2aac			 
2aac e5					push hl    ; save address 
2aad			 
2aad					; load content into de 
2aad			 
2aad 5e					ld e,(hl) 
2aae 23					inc hl 
2aaf 56					ld d, (hl) 
2ab0			 
2ab0					if DEBUG_FORTH_WORDS 
2ab0						DMARK "+2a" 
2ab0 f5				push af  
2ab1 3a c5 2a			ld a, (.dmark)  
2ab4 32 71 ee			ld (debug_mark),a  
2ab7 3a c6 2a			ld a, (.dmark+1)  
2aba 32 72 ee			ld (debug_mark+1),a  
2abd 3a c7 2a			ld a, (.dmark+2)  
2ac0 32 73 ee			ld (debug_mark+2),a  
2ac3 18 03			jr .pastdmark  
2ac5 ..			.dmark: db "+2a"  
2ac8 f1			.pastdmark: pop af  
2ac9			endm  
# End of macro DMARK
2ac9						CALLMONITOR 
2ac9 cd ae 13			call break_point_state  
2acc				endm  
# End of macro CALLMONITOR
2acc					endif 
2acc			 
2acc					FORTH_DSP_POP 
2acc cd b7 1c			call macro_forth_dsp_pop 
2acf				endm 
# End of macro FORTH_DSP_POP
2acf			 
2acf					; Get value to add 
2acf			 
2acf					FORTH_DSP_VALUE 
2acf cd e8 1b			call macro_forth_dsp_value 
2ad2				endm 
# End of macro FORTH_DSP_VALUE
2ad2			 
2ad2					if DEBUG_FORTH_WORDS 
2ad2						DMARK "+2v" 
2ad2 f5				push af  
2ad3 3a e7 2a			ld a, (.dmark)  
2ad6 32 71 ee			ld (debug_mark),a  
2ad9 3a e8 2a			ld a, (.dmark+1)  
2adc 32 72 ee			ld (debug_mark+1),a  
2adf 3a e9 2a			ld a, (.dmark+2)  
2ae2 32 73 ee			ld (debug_mark+2),a  
2ae5 18 03			jr .pastdmark  
2ae7 ..			.dmark: db "+2v"  
2aea f1			.pastdmark: pop af  
2aeb			endm  
# End of macro DMARK
2aeb						CALLMONITOR 
2aeb cd ae 13			call break_point_state  
2aee				endm  
# End of macro CALLMONITOR
2aee					endif 
2aee			 
2aee 19					add hl, de 
2aef			 
2aef					if DEBUG_FORTH_WORDS 
2aef						DMARK "+2+" 
2aef f5				push af  
2af0 3a 04 2b			ld a, (.dmark)  
2af3 32 71 ee			ld (debug_mark),a  
2af6 3a 05 2b			ld a, (.dmark+1)  
2af9 32 72 ee			ld (debug_mark+1),a  
2afc 3a 06 2b			ld a, (.dmark+2)  
2aff 32 73 ee			ld (debug_mark+2),a  
2b02 18 03			jr .pastdmark  
2b04 ..			.dmark: db "+2+"  
2b07 f1			.pastdmark: pop af  
2b08			endm  
# End of macro DMARK
2b08						CALLMONITOR 
2b08 cd ae 13			call break_point_state  
2b0b				endm  
# End of macro CALLMONITOR
2b0b					endif 
2b0b			 
2b0b					; move result to de 
2b0b			 
2b0b eb					ex de, hl 
2b0c			 
2b0c					; Address 
2b0c			 
2b0c e1					pop hl 
2b0d			 
2b0d					; save it back 
2b0d			 
2b0d 73					ld (hl), e 
2b0e 23					inc hl 
2b0f 72					ld (hl), d 
2b10			 
2b10					if DEBUG_FORTH_WORDS 
2b10						DMARK "+2e" 
2b10 f5				push af  
2b11 3a 25 2b			ld a, (.dmark)  
2b14 32 71 ee			ld (debug_mark),a  
2b17 3a 26 2b			ld a, (.dmark+1)  
2b1a 32 72 ee			ld (debug_mark+1),a  
2b1d 3a 27 2b			ld a, (.dmark+2)  
2b20 32 73 ee			ld (debug_mark+2),a  
2b23 18 03			jr .pastdmark  
2b25 ..			.dmark: db "+2e"  
2b28 f1			.pastdmark: pop af  
2b29			endm  
# End of macro DMARK
2b29						CALLMONITOR 
2b29 cd ae 13			call break_point_state  
2b2c				endm  
# End of macro CALLMONITOR
2b2c					endif 
2b2c			 
2b2c			 
2b2c			 
2b2c			 
2b2c			 
2b2c				       NEXTW 
2b2c c3 71 1d			jp macro_next 
2b2f				endm 
# End of macro NEXTW
2b2f			 
2b2f			.DEC2: 
2b2f				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2b2f 6f				db WORD_SYS_CORE+91             
2b30 db 2b			dw .GET2            
2b32 04				db 3 + 1 
2b33 .. 00			db "-2!",0              
2b37				endm 
# End of macro CWHEAD
2b37			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2b37			 
2b37			 
2b37					if DEBUG_FORTH_WORDS_KEY 
2b37						DMARK "-2s" 
2b37 f5				push af  
2b38 3a 4c 2b			ld a, (.dmark)  
2b3b 32 71 ee			ld (debug_mark),a  
2b3e 3a 4d 2b			ld a, (.dmark+1)  
2b41 32 72 ee			ld (debug_mark+1),a  
2b44 3a 4e 2b			ld a, (.dmark+2)  
2b47 32 73 ee			ld (debug_mark+2),a  
2b4a 18 03			jr .pastdmark  
2b4c ..			.dmark: db "-2s"  
2b4f f1			.pastdmark: pop af  
2b50			endm  
# End of macro DMARK
2b50						CALLMONITOR 
2b50 cd ae 13			call break_point_state  
2b53				endm  
# End of macro CALLMONITOR
2b53					endif 
2b53			 
2b53					; Address 
2b53			 
2b53					FORTH_DSP_VALUEHL 
2b53 cd ff 1b			call macro_dsp_valuehl 
2b56				endm 
# End of macro FORTH_DSP_VALUEHL
2b56			 
2b56 e5					push hl    ; save address 
2b57			 
2b57					; load content into de 
2b57			 
2b57 5e					ld e,(hl) 
2b58 23					inc hl 
2b59 56					ld d, (hl) 
2b5a			 
2b5a					if DEBUG_FORTH_WORDS 
2b5a						DMARK "-2a" 
2b5a f5				push af  
2b5b 3a 6f 2b			ld a, (.dmark)  
2b5e 32 71 ee			ld (debug_mark),a  
2b61 3a 70 2b			ld a, (.dmark+1)  
2b64 32 72 ee			ld (debug_mark+1),a  
2b67 3a 71 2b			ld a, (.dmark+2)  
2b6a 32 73 ee			ld (debug_mark+2),a  
2b6d 18 03			jr .pastdmark  
2b6f ..			.dmark: db "-2a"  
2b72 f1			.pastdmark: pop af  
2b73			endm  
# End of macro DMARK
2b73						CALLMONITOR 
2b73 cd ae 13			call break_point_state  
2b76				endm  
# End of macro CALLMONITOR
2b76					endif 
2b76			 
2b76					FORTH_DSP_POP 
2b76 cd b7 1c			call macro_forth_dsp_pop 
2b79				endm 
# End of macro FORTH_DSP_POP
2b79			 
2b79					; Get value to remove 
2b79			 
2b79					FORTH_DSP_VALUE 
2b79 cd e8 1b			call macro_forth_dsp_value 
2b7c				endm 
# End of macro FORTH_DSP_VALUE
2b7c			 
2b7c					if DEBUG_FORTH_WORDS 
2b7c						DMARK "-2v" 
2b7c f5				push af  
2b7d 3a 91 2b			ld a, (.dmark)  
2b80 32 71 ee			ld (debug_mark),a  
2b83 3a 92 2b			ld a, (.dmark+1)  
2b86 32 72 ee			ld (debug_mark+1),a  
2b89 3a 93 2b			ld a, (.dmark+2)  
2b8c 32 73 ee			ld (debug_mark+2),a  
2b8f 18 03			jr .pastdmark  
2b91 ..			.dmark: db "-2v"  
2b94 f1			.pastdmark: pop af  
2b95			endm  
# End of macro DMARK
2b95						CALLMONITOR 
2b95 cd ae 13			call break_point_state  
2b98				endm  
# End of macro CALLMONITOR
2b98					endif 
2b98			 
2b98 eb					ex de, hl 
2b99 ed 52				sbc hl, de 
2b9b			 
2b9b					if DEBUG_FORTH_WORDS 
2b9b						DMARK "-2d" 
2b9b f5				push af  
2b9c 3a b0 2b			ld a, (.dmark)  
2b9f 32 71 ee			ld (debug_mark),a  
2ba2 3a b1 2b			ld a, (.dmark+1)  
2ba5 32 72 ee			ld (debug_mark+1),a  
2ba8 3a b2 2b			ld a, (.dmark+2)  
2bab 32 73 ee			ld (debug_mark+2),a  
2bae 18 03			jr .pastdmark  
2bb0 ..			.dmark: db "-2d"  
2bb3 f1			.pastdmark: pop af  
2bb4			endm  
# End of macro DMARK
2bb4						CALLMONITOR 
2bb4 cd ae 13			call break_point_state  
2bb7				endm  
# End of macro CALLMONITOR
2bb7					endif 
2bb7			 
2bb7					; move result to de 
2bb7			 
2bb7 eb					ex de, hl 
2bb8			 
2bb8					; Address 
2bb8			 
2bb8 e1					pop hl 
2bb9			 
2bb9					; save it back 
2bb9			 
2bb9 73					ld (hl), e 
2bba 23					inc hl 
2bbb 72					ld (hl), d 
2bbc			 
2bbc					if DEBUG_FORTH_WORDS 
2bbc						DMARK "-2e" 
2bbc f5				push af  
2bbd 3a d1 2b			ld a, (.dmark)  
2bc0 32 71 ee			ld (debug_mark),a  
2bc3 3a d2 2b			ld a, (.dmark+1)  
2bc6 32 72 ee			ld (debug_mark+1),a  
2bc9 3a d3 2b			ld a, (.dmark+2)  
2bcc 32 73 ee			ld (debug_mark+2),a  
2bcf 18 03			jr .pastdmark  
2bd1 ..			.dmark: db "-2e"  
2bd4 f1			.pastdmark: pop af  
2bd5			endm  
# End of macro DMARK
2bd5						CALLMONITOR 
2bd5 cd ae 13			call break_point_state  
2bd8				endm  
# End of macro CALLMONITOR
2bd8					endif 
2bd8			 
2bd8			 
2bd8			 
2bd8			 
2bd8			 
2bd8				       NEXTW 
2bd8 c3 71 1d			jp macro_next 
2bdb				endm 
# End of macro NEXTW
2bdb			.GET2: 
2bdb				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2bdb 6f				db WORD_SYS_CORE+91             
2bdc 0b 2c			dw .BANG2            
2bde 03				db 2 + 1 
2bdf .. 00			db "2@",0              
2be2				endm 
# End of macro CWHEAD
2be2			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2be2					if DEBUG_FORTH_WORDS_KEY 
2be2						DMARK "2A_" 
2be2 f5				push af  
2be3 3a f7 2b			ld a, (.dmark)  
2be6 32 71 ee			ld (debug_mark),a  
2be9 3a f8 2b			ld a, (.dmark+1)  
2bec 32 72 ee			ld (debug_mark+1),a  
2bef 3a f9 2b			ld a, (.dmark+2)  
2bf2 32 73 ee			ld (debug_mark+2),a  
2bf5 18 03			jr .pastdmark  
2bf7 ..			.dmark: db "2A_"  
2bfa f1			.pastdmark: pop af  
2bfb			endm  
# End of macro DMARK
2bfb						CALLMONITOR 
2bfb cd ae 13			call break_point_state  
2bfe				endm  
# End of macro CALLMONITOR
2bfe					endif 
2bfe			 
2bfe					FORTH_DSP_VALUEHL 
2bfe cd ff 1b			call macro_dsp_valuehl 
2c01				endm 
# End of macro FORTH_DSP_VALUEHL
2c01			 
2c01 5e					ld e, (hl) 
2c02 23					inc hl 
2c03 56					ld d, (hl) 
2c04			 
2c04 eb					ex de, hl 
2c05			 
2c05 cd 08 1a				call forth_push_numhl 
2c08			 
2c08				       NEXTW 
2c08 c3 71 1d			jp macro_next 
2c0b				endm 
# End of macro NEXTW
2c0b			.BANG2: 
2c0b				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2c0b 6f				db WORD_SYS_CORE+91             
2c0c 43 2c			dw .CONFIG            
2c0e 03				db 2 + 1 
2c0f .. 00			db "2!",0              
2c12				endm 
# End of macro CWHEAD
2c12			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2c12					if DEBUG_FORTH_WORDS_KEY 
2c12						DMARK "2S_" 
2c12 f5				push af  
2c13 3a 27 2c			ld a, (.dmark)  
2c16 32 71 ee			ld (debug_mark),a  
2c19 3a 28 2c			ld a, (.dmark+1)  
2c1c 32 72 ee			ld (debug_mark+1),a  
2c1f 3a 29 2c			ld a, (.dmark+2)  
2c22 32 73 ee			ld (debug_mark+2),a  
2c25 18 03			jr .pastdmark  
2c27 ..			.dmark: db "2S_"  
2c2a f1			.pastdmark: pop af  
2c2b			endm  
# End of macro DMARK
2c2b						CALLMONITOR 
2c2b cd ae 13			call break_point_state  
2c2e				endm  
# End of macro CALLMONITOR
2c2e					endif 
2c2e			 
2c2e					FORTH_DSP_VALUEHL 
2c2e cd ff 1b			call macro_dsp_valuehl 
2c31				endm 
# End of macro FORTH_DSP_VALUEHL
2c31			 
2c31 e5					push hl   ; save address 
2c32			 
2c32			 
2c32					FORTH_DSP_POP 
2c32 cd b7 1c			call macro_forth_dsp_pop 
2c35				endm 
# End of macro FORTH_DSP_POP
2c35			 
2c35					 
2c35					FORTH_DSP_VALUEHL 
2c35 cd ff 1b			call macro_dsp_valuehl 
2c38				endm 
# End of macro FORTH_DSP_VALUEHL
2c38			 
2c38					FORTH_DSP_POP 
2c38 cd b7 1c			call macro_forth_dsp_pop 
2c3b				endm 
# End of macro FORTH_DSP_POP
2c3b			 
2c3b eb					ex de, hl    ; value now in de 
2c3c			 
2c3c e1					pop hl 
2c3d			 
2c3d 73					ld (hl), e 
2c3e			 
2c3e 23					inc hl 
2c3f			 
2c3f 72					ld (hl), d 
2c40			 
2c40			 
2c40				       NEXTW 
2c40 c3 71 1d			jp macro_next 
2c43				endm 
# End of macro NEXTW
2c43			.CONFIG: 
2c43				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2c43 6f				db WORD_SYS_CORE+91             
2c44 54 2c			dw .ENDCORE            
2c46 07				db 6 + 1 
2c47 .. 00			db "CONFIG",0              
2c4e				endm 
# End of macro CWHEAD
2c4e			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2c4e			 
2c4e cd 0d 12				call config 
2c51					NEXTW 
2c51 c3 71 1d			jp macro_next 
2c54				endm 
# End of macro NEXTW
2c54			.ENDCORE: 
2c54			 
2c54			; eof 
2c54			 
2c54			 
# End of file forth_words_core.asm
2c54			include "forth_words_flow.asm" 
2c54			 
2c54			; | ## Program Flow Words 
2c54			 
2c54			.IF: 
2c54				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2c54 1e				db WORD_SYS_CORE+10             
2c55 49 2d			dw .THEN            
2c57 03				db 2 + 1 
2c58 .. 00			db "IF",0              
2c5b				endm 
# End of macro CWHEAD
2c5b			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2c5b			; 
2c5b					if DEBUG_FORTH_WORDS_KEY 
2c5b						DMARK "IF." 
2c5b f5				push af  
2c5c 3a 70 2c			ld a, (.dmark)  
2c5f 32 71 ee			ld (debug_mark),a  
2c62 3a 71 2c			ld a, (.dmark+1)  
2c65 32 72 ee			ld (debug_mark+1),a  
2c68 3a 72 2c			ld a, (.dmark+2)  
2c6b 32 73 ee			ld (debug_mark+2),a  
2c6e 18 03			jr .pastdmark  
2c70 ..			.dmark: db "IF."  
2c73 f1			.pastdmark: pop af  
2c74			endm  
# End of macro DMARK
2c74						CALLMONITOR 
2c74 cd ae 13			call break_point_state  
2c77				endm  
# End of macro CALLMONITOR
2c77					endif 
2c77			; eval TOS 
2c77			 
2c77				FORTH_DSP_VALUEHL 
2c77 cd ff 1b			call macro_dsp_valuehl 
2c7a				endm 
# End of macro FORTH_DSP_VALUEHL
2c7a			 
2c7a			;	push hl 
2c7a				FORTH_DSP_POP 
2c7a cd b7 1c			call macro_forth_dsp_pop 
2c7d				endm 
# End of macro FORTH_DSP_POP
2c7d			;	pop hl 
2c7d			 
2c7d					if DEBUG_FORTH_WORDS 
2c7d						DMARK "IF1" 
2c7d f5				push af  
2c7e 3a 92 2c			ld a, (.dmark)  
2c81 32 71 ee			ld (debug_mark),a  
2c84 3a 93 2c			ld a, (.dmark+1)  
2c87 32 72 ee			ld (debug_mark+1),a  
2c8a 3a 94 2c			ld a, (.dmark+2)  
2c8d 32 73 ee			ld (debug_mark+2),a  
2c90 18 03			jr .pastdmark  
2c92 ..			.dmark: db "IF1"  
2c95 f1			.pastdmark: pop af  
2c96			endm  
# End of macro DMARK
2c96						CALLMONITOR 
2c96 cd ae 13			call break_point_state  
2c99				endm  
# End of macro CALLMONITOR
2c99					endif 
2c99 b7				or a        ; clear carry flag 
2c9a 11 00 00			ld de, 0 
2c9d eb				ex de,hl 
2c9e ed 52			sbc hl, de 
2ca0 c2 2a 2d			jp nz, .iftrue 
2ca3			 
2ca3					if DEBUG_FORTH_WORDS 
2ca3						DMARK "IF2" 
2ca3 f5				push af  
2ca4 3a b8 2c			ld a, (.dmark)  
2ca7 32 71 ee			ld (debug_mark),a  
2caa 3a b9 2c			ld a, (.dmark+1)  
2cad 32 72 ee			ld (debug_mark+1),a  
2cb0 3a ba 2c			ld a, (.dmark+2)  
2cb3 32 73 ee			ld (debug_mark+2),a  
2cb6 18 03			jr .pastdmark  
2cb8 ..			.dmark: db "IF2"  
2cbb f1			.pastdmark: pop af  
2cbc			endm  
# End of macro DMARK
2cbc						CALLMONITOR 
2cbc cd ae 13			call break_point_state  
2cbf				endm  
# End of macro CALLMONITOR
2cbf					endif 
2cbf			 
2cbf			; if not true then skip to THEN 
2cbf			 
2cbf				; TODO get tok_ptr 
2cbf				; TODO consume toks until we get to THEN 
2cbf			 
2cbf 2a 58 e6			ld hl, (os_tok_ptr) 
2cc2					if DEBUG_FORTH_WORDS 
2cc2						DMARK "IF3" 
2cc2 f5				push af  
2cc3 3a d7 2c			ld a, (.dmark)  
2cc6 32 71 ee			ld (debug_mark),a  
2cc9 3a d8 2c			ld a, (.dmark+1)  
2ccc 32 72 ee			ld (debug_mark+1),a  
2ccf 3a d9 2c			ld a, (.dmark+2)  
2cd2 32 73 ee			ld (debug_mark+2),a  
2cd5 18 03			jr .pastdmark  
2cd7 ..			.dmark: db "IF3"  
2cda f1			.pastdmark: pop af  
2cdb			endm  
# End of macro DMARK
2cdb						CALLMONITOR 
2cdb cd ae 13			call break_point_state  
2cde				endm  
# End of macro CALLMONITOR
2cde						 
2cde					endif 
2cde 11 25 2d			ld de, .ifthen 
2ce1					if DEBUG_FORTH_WORDS 
2ce1						DMARK "IF4" 
2ce1 f5				push af  
2ce2 3a f6 2c			ld a, (.dmark)  
2ce5 32 71 ee			ld (debug_mark),a  
2ce8 3a f7 2c			ld a, (.dmark+1)  
2ceb 32 72 ee			ld (debug_mark+1),a  
2cee 3a f8 2c			ld a, (.dmark+2)  
2cf1 32 73 ee			ld (debug_mark+2),a  
2cf4 18 03			jr .pastdmark  
2cf6 ..			.dmark: db "IF4"  
2cf9 f1			.pastdmark: pop af  
2cfa			endm  
# End of macro DMARK
2cfa						CALLMONITOR 
2cfa cd ae 13			call break_point_state  
2cfd				endm  
# End of macro CALLMONITOR
2cfd					endif 
2cfd cd 8c 1e			call findnexttok  
2d00			 
2d00					if DEBUG_FORTH_WORDS 
2d00						DMARK "IF5" 
2d00 f5				push af  
2d01 3a 15 2d			ld a, (.dmark)  
2d04 32 71 ee			ld (debug_mark),a  
2d07 3a 16 2d			ld a, (.dmark+1)  
2d0a 32 72 ee			ld (debug_mark+1),a  
2d0d 3a 17 2d			ld a, (.dmark+2)  
2d10 32 73 ee			ld (debug_mark+2),a  
2d13 18 03			jr .pastdmark  
2d15 ..			.dmark: db "IF5"  
2d18 f1			.pastdmark: pop af  
2d19			endm  
# End of macro DMARK
2d19						CALLMONITOR 
2d19 cd ae 13			call break_point_state  
2d1c				endm  
# End of macro CALLMONITOR
2d1c					endif 
2d1c				; TODO replace below with ; exec using tok_ptr 
2d1c 22 58 e6			ld (os_tok_ptr), hl 
2d1f c3 02 1e			jp exec1 
2d22				NEXTW 
2d22 c3 71 1d			jp macro_next 
2d25				endm 
# End of macro NEXTW
2d25			 
2d25 .. 00		.ifthen:  db "THEN",0 
2d2a			 
2d2a			.iftrue:		 
2d2a				; Exec next words normally 
2d2a			 
2d2a				; if true then exec following IF as normal 
2d2a					if DEBUG_FORTH_WORDS 
2d2a						DMARK "IFT" 
2d2a f5				push af  
2d2b 3a 3f 2d			ld a, (.dmark)  
2d2e 32 71 ee			ld (debug_mark),a  
2d31 3a 40 2d			ld a, (.dmark+1)  
2d34 32 72 ee			ld (debug_mark+1),a  
2d37 3a 41 2d			ld a, (.dmark+2)  
2d3a 32 73 ee			ld (debug_mark+2),a  
2d3d 18 03			jr .pastdmark  
2d3f ..			.dmark: db "IFT"  
2d42 f1			.pastdmark: pop af  
2d43			endm  
# End of macro DMARK
2d43						CALLMONITOR 
2d43 cd ae 13			call break_point_state  
2d46				endm  
# End of macro CALLMONITOR
2d46					endif 
2d46			 
2d46					NEXTW 
2d46 c3 71 1d			jp macro_next 
2d49				endm 
# End of macro NEXTW
2d49			.THEN: 
2d49				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2d49 1f				db WORD_SYS_CORE+11             
2d4a 71 2d			dw .ELSE            
2d4c 05				db 4 + 1 
2d4d .. 00			db "THEN",0              
2d52				endm 
# End of macro CWHEAD
2d52			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2d52					if DEBUG_FORTH_WORDS_KEY 
2d52						DMARK "THN" 
2d52 f5				push af  
2d53 3a 67 2d			ld a, (.dmark)  
2d56 32 71 ee			ld (debug_mark),a  
2d59 3a 68 2d			ld a, (.dmark+1)  
2d5c 32 72 ee			ld (debug_mark+1),a  
2d5f 3a 69 2d			ld a, (.dmark+2)  
2d62 32 73 ee			ld (debug_mark+2),a  
2d65 18 03			jr .pastdmark  
2d67 ..			.dmark: db "THN"  
2d6a f1			.pastdmark: pop af  
2d6b			endm  
# End of macro DMARK
2d6b						CALLMONITOR 
2d6b cd ae 13			call break_point_state  
2d6e				endm  
# End of macro CALLMONITOR
2d6e					endif 
2d6e					NEXTW 
2d6e c3 71 1d			jp macro_next 
2d71				endm 
# End of macro NEXTW
2d71			.ELSE: 
2d71				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2d71 20				db WORD_SYS_CORE+12             
2d72 99 2d			dw .DO            
2d74 03				db 2 + 1 
2d75 .. 00			db "ELSE",0              
2d7a				endm 
# End of macro CWHEAD
2d7a			; | ELSE ( -- ) Not supported - does nothing | TODO 
2d7a			 
2d7a					if DEBUG_FORTH_WORDS_KEY 
2d7a						DMARK "ELS" 
2d7a f5				push af  
2d7b 3a 8f 2d			ld a, (.dmark)  
2d7e 32 71 ee			ld (debug_mark),a  
2d81 3a 90 2d			ld a, (.dmark+1)  
2d84 32 72 ee			ld (debug_mark+1),a  
2d87 3a 91 2d			ld a, (.dmark+2)  
2d8a 32 73 ee			ld (debug_mark+2),a  
2d8d 18 03			jr .pastdmark  
2d8f ..			.dmark: db "ELS"  
2d92 f1			.pastdmark: pop af  
2d93			endm  
# End of macro DMARK
2d93						CALLMONITOR 
2d93 cd ae 13			call break_point_state  
2d96				endm  
# End of macro CALLMONITOR
2d96					endif 
2d96			 
2d96			 
2d96					NEXTW 
2d96 c3 71 1d			jp macro_next 
2d99				endm 
# End of macro NEXTW
2d99			.DO: 
2d99				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2d99 21				db WORD_SYS_CORE+13             
2d9a c0 2e			dw .LOOP            
2d9c 03				db 2 + 1 
2d9d .. 00			db "DO",0              
2da0				endm 
# End of macro CWHEAD
2da0			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2da0			 
2da0					if DEBUG_FORTH_WORDS_KEY 
2da0						DMARK "DO." 
2da0 f5				push af  
2da1 3a b5 2d			ld a, (.dmark)  
2da4 32 71 ee			ld (debug_mark),a  
2da7 3a b6 2d			ld a, (.dmark+1)  
2daa 32 72 ee			ld (debug_mark+1),a  
2dad 3a b7 2d			ld a, (.dmark+2)  
2db0 32 73 ee			ld (debug_mark+2),a  
2db3 18 03			jr .pastdmark  
2db5 ..			.dmark: db "DO."  
2db8 f1			.pastdmark: pop af  
2db9			endm  
# End of macro DMARK
2db9						CALLMONITOR 
2db9 cd ae 13			call break_point_state  
2dbc				endm  
# End of macro CALLMONITOR
2dbc					endif 
2dbc			;  push pc to rsp stack past the DO 
2dbc			 
2dbc 2a 58 e6				ld hl, (os_tok_ptr) 
2dbf 23					inc hl   ; D 
2dc0 23					inc hl  ; O 
2dc1 23					inc hl   ; null 
2dc2					if DEBUG_FORTH_WORDS 
2dc2						DMARK "DO2" 
2dc2 f5				push af  
2dc3 3a d7 2d			ld a, (.dmark)  
2dc6 32 71 ee			ld (debug_mark),a  
2dc9 3a d8 2d			ld a, (.dmark+1)  
2dcc 32 72 ee			ld (debug_mark+1),a  
2dcf 3a d9 2d			ld a, (.dmark+2)  
2dd2 32 73 ee			ld (debug_mark+2),a  
2dd5 18 03			jr .pastdmark  
2dd7 ..			.dmark: db "DO2"  
2dda f1			.pastdmark: pop af  
2ddb			endm  
# End of macro DMARK
2ddb						CALLMONITOR 
2ddb cd ae 13			call break_point_state  
2dde				endm  
# End of macro CALLMONITOR
2dde					endif 
2dde					FORTH_RSP_NEXT 
2dde cd af 19			call macro_forth_rsp_next 
2de1				endm 
# End of macro FORTH_RSP_NEXT
2de1					if DEBUG_FORTH_WORDS 
2de1						DMARK "DO3" 
2de1 f5				push af  
2de2 3a f6 2d			ld a, (.dmark)  
2de5 32 71 ee			ld (debug_mark),a  
2de8 3a f7 2d			ld a, (.dmark+1)  
2deb 32 72 ee			ld (debug_mark+1),a  
2dee 3a f8 2d			ld a, (.dmark+2)  
2df1 32 73 ee			ld (debug_mark+2),a  
2df4 18 03			jr .pastdmark  
2df6 ..			.dmark: db "DO3"  
2df9 f1			.pastdmark: pop af  
2dfa			endm  
# End of macro DMARK
2dfa						CALLMONITOR 
2dfa cd ae 13			call break_point_state  
2dfd				endm  
# End of macro CALLMONITOR
2dfd					endif 
2dfd			 
2dfd					;if DEBUG_FORTH_WORDS 
2dfd				;		push hl 
2dfd			;		endif  
2dfd			 
2dfd			; get counters from data stack 
2dfd			 
2dfd			 
2dfd					FORTH_DSP_VALUEHL 
2dfd cd ff 1b			call macro_dsp_valuehl 
2e00				endm 
# End of macro FORTH_DSP_VALUEHL
2e00 e5					push hl		 ; hl now has starting counter which needs to be tos 
2e01			 
2e01					if DEBUG_FORTH_WORDS 
2e01						DMARK "DO4" 
2e01 f5				push af  
2e02 3a 16 2e			ld a, (.dmark)  
2e05 32 71 ee			ld (debug_mark),a  
2e08 3a 17 2e			ld a, (.dmark+1)  
2e0b 32 72 ee			ld (debug_mark+1),a  
2e0e 3a 18 2e			ld a, (.dmark+2)  
2e11 32 73 ee			ld (debug_mark+2),a  
2e14 18 03			jr .pastdmark  
2e16 ..			.dmark: db "DO4"  
2e19 f1			.pastdmark: pop af  
2e1a			endm  
# End of macro DMARK
2e1a						CALLMONITOR 
2e1a cd ae 13			call break_point_state  
2e1d				endm  
# End of macro CALLMONITOR
2e1d					endif 
2e1d					FORTH_DSP_POP 
2e1d cd b7 1c			call macro_forth_dsp_pop 
2e20				endm 
# End of macro FORTH_DSP_POP
2e20			 
2e20					if DEBUG_FORTH_WORDS 
2e20						DMARK "DO5" 
2e20 f5				push af  
2e21 3a 35 2e			ld a, (.dmark)  
2e24 32 71 ee			ld (debug_mark),a  
2e27 3a 36 2e			ld a, (.dmark+1)  
2e2a 32 72 ee			ld (debug_mark+1),a  
2e2d 3a 37 2e			ld a, (.dmark+2)  
2e30 32 73 ee			ld (debug_mark+2),a  
2e33 18 03			jr .pastdmark  
2e35 ..			.dmark: db "DO5"  
2e38 f1			.pastdmark: pop af  
2e39			endm  
# End of macro DMARK
2e39						CALLMONITOR 
2e39 cd ae 13			call break_point_state  
2e3c				endm  
# End of macro CALLMONITOR
2e3c					endif 
2e3c			 
2e3c					FORTH_DSP_VALUEHL 
2e3c cd ff 1b			call macro_dsp_valuehl 
2e3f				endm 
# End of macro FORTH_DSP_VALUEHL
2e3f			;		push hl		 ; hl now has starting limit counter 
2e3f			 
2e3f					if DEBUG_FORTH_WORDS 
2e3f						DMARK "DO6" 
2e3f f5				push af  
2e40 3a 54 2e			ld a, (.dmark)  
2e43 32 71 ee			ld (debug_mark),a  
2e46 3a 55 2e			ld a, (.dmark+1)  
2e49 32 72 ee			ld (debug_mark+1),a  
2e4c 3a 56 2e			ld a, (.dmark+2)  
2e4f 32 73 ee			ld (debug_mark+2),a  
2e52 18 03			jr .pastdmark  
2e54 ..			.dmark: db "DO6"  
2e57 f1			.pastdmark: pop af  
2e58			endm  
# End of macro DMARK
2e58						CALLMONITOR 
2e58 cd ae 13			call break_point_state  
2e5b				endm  
# End of macro CALLMONITOR
2e5b					endif 
2e5b					FORTH_DSP_POP 
2e5b cd b7 1c			call macro_forth_dsp_pop 
2e5e				endm 
# End of macro FORTH_DSP_POP
2e5e			 
2e5e			; put counters on the loop stack 
2e5e			 
2e5e			;		pop hl			 ; limit counter 
2e5e d1					pop de			; start counter 
2e5f			 
2e5f					; push limit counter 
2e5f			 
2e5f					if DEBUG_FORTH_WORDS 
2e5f						DMARK "DO7" 
2e5f f5				push af  
2e60 3a 74 2e			ld a, (.dmark)  
2e63 32 71 ee			ld (debug_mark),a  
2e66 3a 75 2e			ld a, (.dmark+1)  
2e69 32 72 ee			ld (debug_mark+1),a  
2e6c 3a 76 2e			ld a, (.dmark+2)  
2e6f 32 73 ee			ld (debug_mark+2),a  
2e72 18 03			jr .pastdmark  
2e74 ..			.dmark: db "DO7"  
2e77 f1			.pastdmark: pop af  
2e78			endm  
# End of macro DMARK
2e78						CALLMONITOR 
2e78 cd ae 13			call break_point_state  
2e7b				endm  
# End of macro CALLMONITOR
2e7b					endif 
2e7b					FORTH_LOOP_NEXT 
2e7b cd 30 1c			call macro_forth_loop_next 
2e7e				endm 
# End of macro FORTH_LOOP_NEXT
2e7e			 
2e7e					; push start counter 
2e7e			 
2e7e eb					ex de, hl 
2e7f					if DEBUG_FORTH_WORDS 
2e7f						DMARK "DO7" 
2e7f f5				push af  
2e80 3a 94 2e			ld a, (.dmark)  
2e83 32 71 ee			ld (debug_mark),a  
2e86 3a 95 2e			ld a, (.dmark+1)  
2e89 32 72 ee			ld (debug_mark+1),a  
2e8c 3a 96 2e			ld a, (.dmark+2)  
2e8f 32 73 ee			ld (debug_mark+2),a  
2e92 18 03			jr .pastdmark  
2e94 ..			.dmark: db "DO7"  
2e97 f1			.pastdmark: pop af  
2e98			endm  
# End of macro DMARK
2e98						CALLMONITOR 
2e98 cd ae 13			call break_point_state  
2e9b				endm  
# End of macro CALLMONITOR
2e9b					endif 
2e9b					FORTH_LOOP_NEXT 
2e9b cd 30 1c			call macro_forth_loop_next 
2e9e				endm 
# End of macro FORTH_LOOP_NEXT
2e9e			 
2e9e			 
2e9e					; init first round of I counter 
2e9e			 
2e9e 22 7c e6				ld (os_current_i), hl 
2ea1			 
2ea1					if DEBUG_FORTH_WORDS 
2ea1						DMARK "DO8" 
2ea1 f5				push af  
2ea2 3a b6 2e			ld a, (.dmark)  
2ea5 32 71 ee			ld (debug_mark),a  
2ea8 3a b7 2e			ld a, (.dmark+1)  
2eab 32 72 ee			ld (debug_mark+1),a  
2eae 3a b8 2e			ld a, (.dmark+2)  
2eb1 32 73 ee			ld (debug_mark+2),a  
2eb4 18 03			jr .pastdmark  
2eb6 ..			.dmark: db "DO8"  
2eb9 f1			.pastdmark: pop af  
2eba			endm  
# End of macro DMARK
2eba						CALLMONITOR 
2eba cd ae 13			call break_point_state  
2ebd				endm  
# End of macro CALLMONITOR
2ebd					endif 
2ebd			 
2ebd					NEXTW 
2ebd c3 71 1d			jp macro_next 
2ec0				endm 
# End of macro NEXTW
2ec0			.LOOP: 
2ec0				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2ec0 22				db WORD_SYS_CORE+14             
2ec1 d8 2f			dw .I            
2ec3 05				db 4 + 1 
2ec4 .. 00			db "LOOP",0              
2ec9				endm 
# End of macro CWHEAD
2ec9			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2ec9			 
2ec9				; pop tos as current loop count to hl 
2ec9			 
2ec9				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2ec9			 
2ec9				FORTH_LOOP_TOS 
2ec9 cd 63 1c			call macro_forth_loop_tos 
2ecc				endm 
# End of macro FORTH_LOOP_TOS
2ecc e5				push hl 
2ecd			 
2ecd					if DEBUG_FORTH_WORDS_KEY 
2ecd						DMARK "LOP" 
2ecd f5				push af  
2ece 3a e2 2e			ld a, (.dmark)  
2ed1 32 71 ee			ld (debug_mark),a  
2ed4 3a e3 2e			ld a, (.dmark+1)  
2ed7 32 72 ee			ld (debug_mark+1),a  
2eda 3a e4 2e			ld a, (.dmark+2)  
2edd 32 73 ee			ld (debug_mark+2),a  
2ee0 18 03			jr .pastdmark  
2ee2 ..			.dmark: db "LOP"  
2ee5 f1			.pastdmark: pop af  
2ee6			endm  
# End of macro DMARK
2ee6						CALLMONITOR 
2ee6 cd ae 13			call break_point_state  
2ee9				endm  
# End of macro CALLMONITOR
2ee9					endif 
2ee9				; next item on the stack is the limit. get it 
2ee9			 
2ee9			 
2ee9				FORTH_LOOP_POP 
2ee9 cd 6d 1c			call macro_forth_loop_pop 
2eec				endm 
# End of macro FORTH_LOOP_POP
2eec			 
2eec				FORTH_LOOP_TOS 
2eec cd 63 1c			call macro_forth_loop_tos 
2eef				endm 
# End of macro FORTH_LOOP_TOS
2eef			 
2eef d1				pop de		 ; de = i, hl = limit 
2ef0			 
2ef0					if DEBUG_FORTH_WORDS 
2ef0						DMARK "LP1" 
2ef0 f5				push af  
2ef1 3a 05 2f			ld a, (.dmark)  
2ef4 32 71 ee			ld (debug_mark),a  
2ef7 3a 06 2f			ld a, (.dmark+1)  
2efa 32 72 ee			ld (debug_mark+1),a  
2efd 3a 07 2f			ld a, (.dmark+2)  
2f00 32 73 ee			ld (debug_mark+2),a  
2f03 18 03			jr .pastdmark  
2f05 ..			.dmark: db "LP1"  
2f08 f1			.pastdmark: pop af  
2f09			endm  
# End of macro DMARK
2f09						CALLMONITOR 
2f09 cd ae 13			call break_point_state  
2f0c				endm  
# End of macro CALLMONITOR
2f0c					endif 
2f0c			 
2f0c				; go back to previous word 
2f0c			 
2f0c d5				push de    ; save I for inc later 
2f0d			 
2f0d			 
2f0d				; get limit 
2f0d				;  is I at limit? 
2f0d			 
2f0d			 
2f0d					if DEBUG_FORTH_WORDS 
2f0d						DMARK "LP1" 
2f0d f5				push af  
2f0e 3a 22 2f			ld a, (.dmark)  
2f11 32 71 ee			ld (debug_mark),a  
2f14 3a 23 2f			ld a, (.dmark+1)  
2f17 32 72 ee			ld (debug_mark+1),a  
2f1a 3a 24 2f			ld a, (.dmark+2)  
2f1d 32 73 ee			ld (debug_mark+2),a  
2f20 18 03			jr .pastdmark  
2f22 ..			.dmark: db "LP1"  
2f25 f1			.pastdmark: pop af  
2f26			endm  
# End of macro DMARK
2f26						CALLMONITOR 
2f26 cd ae 13			call break_point_state  
2f29				endm  
# End of macro CALLMONITOR
2f29					endif 
2f29			 
2f29 ed 52			sbc hl, de 
2f2b			 
2f2b			 
2f2b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2f2b			 
2f2b 20 26				jr nz, .loopnotdone 
2f2d			 
2f2d e1				pop hl   ; get rid of saved I 
2f2e				FORTH_LOOP_POP     ; get rid of limit 
2f2e cd 6d 1c			call macro_forth_loop_pop 
2f31				endm 
# End of macro FORTH_LOOP_POP
2f31			 
2f31				FORTH_RSP_POP     ; get rid of DO ptr 
2f31 cd d0 19			call macro_forth_rsp_pop 
2f34				endm 
# End of macro FORTH_RSP_POP
2f34			 
2f34			if DEBUG_FORTH_WORDS 
2f34						DMARK "LP>" 
2f34 f5				push af  
2f35 3a 49 2f			ld a, (.dmark)  
2f38 32 71 ee			ld (debug_mark),a  
2f3b 3a 4a 2f			ld a, (.dmark+1)  
2f3e 32 72 ee			ld (debug_mark+1),a  
2f41 3a 4b 2f			ld a, (.dmark+2)  
2f44 32 73 ee			ld (debug_mark+2),a  
2f47 18 03			jr .pastdmark  
2f49 ..			.dmark: db "LP>"  
2f4c f1			.pastdmark: pop af  
2f4d			endm  
# End of macro DMARK
2f4d				CALLMONITOR 
2f4d cd ae 13			call break_point_state  
2f50				endm  
# End of macro CALLMONITOR
2f50			endif 
2f50			 
2f50					NEXTW 
2f50 c3 71 1d			jp macro_next 
2f53				endm 
# End of macro NEXTW
2f53				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2f53			 
2f53			.loopnotdone: 
2f53			 
2f53 e1				pop hl    ; get I 
2f54 23				inc hl 
2f55			 
2f55			   	; save new I 
2f55			 
2f55			 
2f55					; set I counter 
2f55			 
2f55 22 7c e6				ld (os_current_i), hl 
2f58			 
2f58					if DEBUG_FORTH_WORDS 
2f58						DMARK "LPN" 
2f58 f5				push af  
2f59 3a 6d 2f			ld a, (.dmark)  
2f5c 32 71 ee			ld (debug_mark),a  
2f5f 3a 6e 2f			ld a, (.dmark+1)  
2f62 32 72 ee			ld (debug_mark+1),a  
2f65 3a 6f 2f			ld a, (.dmark+2)  
2f68 32 73 ee			ld (debug_mark+2),a  
2f6b 18 03			jr .pastdmark  
2f6d ..			.dmark: db "LPN"  
2f70 f1			.pastdmark: pop af  
2f71			endm  
# End of macro DMARK
2f71					CALLMONITOR 
2f71 cd ae 13			call break_point_state  
2f74				endm  
# End of macro CALLMONITOR
2f74					endif 
2f74					 
2f74				FORTH_LOOP_NEXT 
2f74 cd 30 1c			call macro_forth_loop_next 
2f77				endm 
# End of macro FORTH_LOOP_NEXT
2f77			 
2f77			 
2f77					if DEBUG_FORTH_WORDS 
2f77 eb						ex de,hl 
2f78					endif 
2f78			 
2f78			;	; get DO ptr 
2f78			; 
2f78					if DEBUG_FORTH_WORDS 
2f78						DMARK "LP7" 
2f78 f5				push af  
2f79 3a 8d 2f			ld a, (.dmark)  
2f7c 32 71 ee			ld (debug_mark),a  
2f7f 3a 8e 2f			ld a, (.dmark+1)  
2f82 32 72 ee			ld (debug_mark+1),a  
2f85 3a 8f 2f			ld a, (.dmark+2)  
2f88 32 73 ee			ld (debug_mark+2),a  
2f8b 18 03			jr .pastdmark  
2f8d ..			.dmark: db "LP7"  
2f90 f1			.pastdmark: pop af  
2f91			endm  
# End of macro DMARK
2f91					CALLMONITOR 
2f91 cd ae 13			call break_point_state  
2f94				endm  
# End of macro CALLMONITOR
2f94					endif 
2f94				FORTH_RSP_TOS 
2f94 cd c6 19			call macro_forth_rsp_tos 
2f97				endm 
# End of macro FORTH_RSP_TOS
2f97			 
2f97					if DEBUG_FORTH_WORDS 
2f97						DMARK "LP8" 
2f97 f5				push af  
2f98 3a ac 2f			ld a, (.dmark)  
2f9b 32 71 ee			ld (debug_mark),a  
2f9e 3a ad 2f			ld a, (.dmark+1)  
2fa1 32 72 ee			ld (debug_mark+1),a  
2fa4 3a ae 2f			ld a, (.dmark+2)  
2fa7 32 73 ee			ld (debug_mark+2),a  
2faa 18 03			jr .pastdmark  
2fac ..			.dmark: db "LP8"  
2faf f1			.pastdmark: pop af  
2fb0			endm  
# End of macro DMARK
2fb0					CALLMONITOR 
2fb0 cd ae 13			call break_point_state  
2fb3				endm  
# End of macro CALLMONITOR
2fb3					endif 
2fb3				;push hl 
2fb3			 
2fb3				; not going to DO any more 
2fb3				; get rid of the RSP pointer as DO will add it back in 
2fb3				;FORTH_RSP_POP 
2fb3				;pop hl 
2fb3			 
2fb3				;ld hl,(cli_ret_sp) 
2fb3				;ld e, (hl) 
2fb3				;inc hl 
2fb3				;ld d, (hl) 
2fb3				;ex de,hl 
2fb3 22 58 e6			ld (os_tok_ptr), hl 
2fb6					if DEBUG_FORTH_WORDS 
2fb6						DMARK "LP<" 
2fb6 f5				push af  
2fb7 3a cb 2f			ld a, (.dmark)  
2fba 32 71 ee			ld (debug_mark),a  
2fbd 3a cc 2f			ld a, (.dmark+1)  
2fc0 32 72 ee			ld (debug_mark+1),a  
2fc3 3a cd 2f			ld a, (.dmark+2)  
2fc6 32 73 ee			ld (debug_mark+2),a  
2fc9 18 03			jr .pastdmark  
2fcb ..			.dmark: db "LP<"  
2fce f1			.pastdmark: pop af  
2fcf			endm  
# End of macro DMARK
2fcf					CALLMONITOR 
2fcf cd ae 13			call break_point_state  
2fd2				endm  
# End of macro CALLMONITOR
2fd2				endif 
2fd2 c3 02 1e			jp exec1 
2fd5			 
2fd5					 
2fd5			 
2fd5			 
2fd5					NEXTW 
2fd5 c3 71 1d			jp macro_next 
2fd8				endm 
# End of macro NEXTW
2fd8			.I:  
2fd8			 
2fd8				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2fd8 5e				db WORD_SYS_CORE+74             
2fd9 03 30			dw .DLOOP            
2fdb 02				db 1 + 1 
2fdc .. 00			db "I",0              
2fde				endm 
# End of macro CWHEAD
2fde			; | I ( -- ) Current loop counter | DONE 
2fde					if DEBUG_FORTH_WORDS_KEY 
2fde						DMARK "I.." 
2fde f5				push af  
2fdf 3a f3 2f			ld a, (.dmark)  
2fe2 32 71 ee			ld (debug_mark),a  
2fe5 3a f4 2f			ld a, (.dmark+1)  
2fe8 32 72 ee			ld (debug_mark+1),a  
2feb 3a f5 2f			ld a, (.dmark+2)  
2fee 32 73 ee			ld (debug_mark+2),a  
2ff1 18 03			jr .pastdmark  
2ff3 ..			.dmark: db "I.."  
2ff6 f1			.pastdmark: pop af  
2ff7			endm  
# End of macro DMARK
2ff7						CALLMONITOR 
2ff7 cd ae 13			call break_point_state  
2ffa				endm  
# End of macro CALLMONITOR
2ffa					endif 
2ffa			 
2ffa 2a 7c e6				ld hl,(os_current_i) 
2ffd cd 08 1a				call forth_push_numhl 
3000			 
3000					NEXTW 
3000 c3 71 1d			jp macro_next 
3003				endm 
# End of macro NEXTW
3003			.DLOOP: 
3003				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3003 5f				db WORD_SYS_CORE+75             
3004 e4 30			dw .REPEAT            
3006 06				db 5 + 1 
3007 .. 00			db "-LOOP",0              
300d				endm 
# End of macro CWHEAD
300d			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
300d				; pop tos as current loop count to hl 
300d					if DEBUG_FORTH_WORDS_KEY 
300d						DMARK "-LP" 
300d f5				push af  
300e 3a 22 30			ld a, (.dmark)  
3011 32 71 ee			ld (debug_mark),a  
3014 3a 23 30			ld a, (.dmark+1)  
3017 32 72 ee			ld (debug_mark+1),a  
301a 3a 24 30			ld a, (.dmark+2)  
301d 32 73 ee			ld (debug_mark+2),a  
3020 18 03			jr .pastdmark  
3022 ..			.dmark: db "-LP"  
3025 f1			.pastdmark: pop af  
3026			endm  
# End of macro DMARK
3026						CALLMONITOR 
3026 cd ae 13			call break_point_state  
3029				endm  
# End of macro CALLMONITOR
3029					endif 
3029			 
3029				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3029			 
3029				FORTH_LOOP_TOS 
3029 cd 63 1c			call macro_forth_loop_tos 
302c				endm 
# End of macro FORTH_LOOP_TOS
302c e5				push hl 
302d			 
302d					if DEBUG_FORTH_WORDS 
302d						DMARK "-LP" 
302d f5				push af  
302e 3a 42 30			ld a, (.dmark)  
3031 32 71 ee			ld (debug_mark),a  
3034 3a 43 30			ld a, (.dmark+1)  
3037 32 72 ee			ld (debug_mark+1),a  
303a 3a 44 30			ld a, (.dmark+2)  
303d 32 73 ee			ld (debug_mark+2),a  
3040 18 03			jr .pastdmark  
3042 ..			.dmark: db "-LP"  
3045 f1			.pastdmark: pop af  
3046			endm  
# End of macro DMARK
3046						CALLMONITOR 
3046 cd ae 13			call break_point_state  
3049				endm  
# End of macro CALLMONITOR
3049					endif 
3049				; next item on the stack is the limit. get it 
3049			 
3049			 
3049				FORTH_LOOP_POP 
3049 cd 6d 1c			call macro_forth_loop_pop 
304c				endm 
# End of macro FORTH_LOOP_POP
304c			 
304c				FORTH_LOOP_TOS 
304c cd 63 1c			call macro_forth_loop_tos 
304f				endm 
# End of macro FORTH_LOOP_TOS
304f			 
304f d1				pop de		 ; de = i, hl = limit 
3050			 
3050					if DEBUG_FORTH_WORDS 
3050						DMARK "-L1" 
3050 f5				push af  
3051 3a 65 30			ld a, (.dmark)  
3054 32 71 ee			ld (debug_mark),a  
3057 3a 66 30			ld a, (.dmark+1)  
305a 32 72 ee			ld (debug_mark+1),a  
305d 3a 67 30			ld a, (.dmark+2)  
3060 32 73 ee			ld (debug_mark+2),a  
3063 18 03			jr .pastdmark  
3065 ..			.dmark: db "-L1"  
3068 f1			.pastdmark: pop af  
3069			endm  
# End of macro DMARK
3069						CALLMONITOR 
3069 cd ae 13			call break_point_state  
306c				endm  
# End of macro CALLMONITOR
306c					endif 
306c			 
306c				; go back to previous word 
306c			 
306c d5				push de    ; save I for inc later 
306d			 
306d			 
306d				; get limit 
306d				;  is I at limit? 
306d			 
306d			 
306d					if DEBUG_FORTH_WORDS 
306d						DMARK "-L1" 
306d f5				push af  
306e 3a 82 30			ld a, (.dmark)  
3071 32 71 ee			ld (debug_mark),a  
3074 3a 83 30			ld a, (.dmark+1)  
3077 32 72 ee			ld (debug_mark+1),a  
307a 3a 84 30			ld a, (.dmark+2)  
307d 32 73 ee			ld (debug_mark+2),a  
3080 18 03			jr .pastdmark  
3082 ..			.dmark: db "-L1"  
3085 f1			.pastdmark: pop af  
3086			endm  
# End of macro DMARK
3086						CALLMONITOR 
3086 cd ae 13			call break_point_state  
3089				endm  
# End of macro CALLMONITOR
3089					endif 
3089			 
3089 ed 52			sbc hl, de 
308b			 
308b			 
308b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
308b			 
308b 20 26				jr nz, .mloopnotdone 
308d			 
308d e1				pop hl   ; get rid of saved I 
308e				FORTH_LOOP_POP     ; get rid of limit 
308e cd 6d 1c			call macro_forth_loop_pop 
3091				endm 
# End of macro FORTH_LOOP_POP
3091			 
3091				FORTH_RSP_POP     ; get rid of DO ptr 
3091 cd d0 19			call macro_forth_rsp_pop 
3094				endm 
# End of macro FORTH_RSP_POP
3094			 
3094			if DEBUG_FORTH_WORDS 
3094						DMARK "-L>" 
3094 f5				push af  
3095 3a a9 30			ld a, (.dmark)  
3098 32 71 ee			ld (debug_mark),a  
309b 3a aa 30			ld a, (.dmark+1)  
309e 32 72 ee			ld (debug_mark+1),a  
30a1 3a ab 30			ld a, (.dmark+2)  
30a4 32 73 ee			ld (debug_mark+2),a  
30a7 18 03			jr .pastdmark  
30a9 ..			.dmark: db "-L>"  
30ac f1			.pastdmark: pop af  
30ad			endm  
# End of macro DMARK
30ad				CALLMONITOR 
30ad cd ae 13			call break_point_state  
30b0				endm  
# End of macro CALLMONITOR
30b0			endif 
30b0			 
30b0					NEXTW 
30b0 c3 71 1d			jp macro_next 
30b3				endm 
# End of macro NEXTW
30b3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
30b3			 
30b3			.mloopnotdone: 
30b3			 
30b3 e1				pop hl    ; get I 
30b4 2b				dec hl 
30b5			 
30b5			   	; save new I 
30b5			 
30b5			 
30b5					; set I counter 
30b5			 
30b5 22 7c e6				ld (os_current_i), hl 
30b8			 
30b8					 
30b8				FORTH_LOOP_NEXT 
30b8 cd 30 1c			call macro_forth_loop_next 
30bb				endm 
# End of macro FORTH_LOOP_NEXT
30bb			 
30bb			 
30bb					if DEBUG_FORTH_WORDS 
30bb eb						ex de,hl 
30bc					endif 
30bc			 
30bc			;	; get DO ptr 
30bc			; 
30bc				FORTH_RSP_TOS 
30bc cd c6 19			call macro_forth_rsp_tos 
30bf				endm 
# End of macro FORTH_RSP_TOS
30bf			 
30bf				;push hl 
30bf			 
30bf				; not going to DO any more 
30bf				; get rid of the RSP pointer as DO will add it back in 
30bf				;FORTH_RSP_POP 
30bf				;pop hl 
30bf			 
30bf			 
30bf 22 58 e6			ld (os_tok_ptr), hl 
30c2					if DEBUG_FORTH_WORDS 
30c2						DMARK "-L<" 
30c2 f5				push af  
30c3 3a d7 30			ld a, (.dmark)  
30c6 32 71 ee			ld (debug_mark),a  
30c9 3a d8 30			ld a, (.dmark+1)  
30cc 32 72 ee			ld (debug_mark+1),a  
30cf 3a d9 30			ld a, (.dmark+2)  
30d2 32 73 ee			ld (debug_mark+2),a  
30d5 18 03			jr .pastdmark  
30d7 ..			.dmark: db "-L<"  
30da f1			.pastdmark: pop af  
30db			endm  
# End of macro DMARK
30db					CALLMONITOR 
30db cd ae 13			call break_point_state  
30de				endm  
# End of macro CALLMONITOR
30de				endif 
30de c3 02 1e			jp exec1 
30e1			 
30e1					 
30e1			 
30e1			 
30e1			 
30e1				NEXTW 
30e1 c3 71 1d			jp macro_next 
30e4				endm 
# End of macro NEXTW
30e4			 
30e4			 
30e4			 
30e4			 
30e4			.REPEAT: 
30e4				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
30e4 71				db WORD_SYS_CORE+93             
30e5 37 31			dw .UNTIL            
30e7 06				db 5 + 1 
30e8 .. 00			db "REPEAT",0              
30ef				endm 
# End of macro CWHEAD
30ef			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
30ef			;  push pc to rsp stack past the REPEAT 
30ef					if DEBUG_FORTH_WORDS_KEY 
30ef						DMARK "REP" 
30ef f5				push af  
30f0 3a 04 31			ld a, (.dmark)  
30f3 32 71 ee			ld (debug_mark),a  
30f6 3a 05 31			ld a, (.dmark+1)  
30f9 32 72 ee			ld (debug_mark+1),a  
30fc 3a 06 31			ld a, (.dmark+2)  
30ff 32 73 ee			ld (debug_mark+2),a  
3102 18 03			jr .pastdmark  
3104 ..			.dmark: db "REP"  
3107 f1			.pastdmark: pop af  
3108			endm  
# End of macro DMARK
3108						CALLMONITOR 
3108 cd ae 13			call break_point_state  
310b				endm  
# End of macro CALLMONITOR
310b					endif 
310b			 
310b 2a 58 e6				ld hl, (os_tok_ptr) 
310e 23					inc hl   ; R 
310f 23					inc hl  ; E 
3110 23					inc hl   ; P 
3111 23					inc hl   ; E 
3112 23					inc hl   ; A 
3113 23					inc hl   ; T 
3114 23					inc hl   ; zero 
3115					FORTH_RSP_NEXT 
3115 cd af 19			call macro_forth_rsp_next 
3118				endm 
# End of macro FORTH_RSP_NEXT
3118			 
3118			 
3118					if DEBUG_FORTH_WORDS 
3118						DMARK "REP" 
3118 f5				push af  
3119 3a 2d 31			ld a, (.dmark)  
311c 32 71 ee			ld (debug_mark),a  
311f 3a 2e 31			ld a, (.dmark+1)  
3122 32 72 ee			ld (debug_mark+1),a  
3125 3a 2f 31			ld a, (.dmark+2)  
3128 32 73 ee			ld (debug_mark+2),a  
312b 18 03			jr .pastdmark  
312d ..			.dmark: db "REP"  
3130 f1			.pastdmark: pop af  
3131			endm  
# End of macro DMARK
3131						;pop bc    ; TODO BUG ?????? what is this for???? 
3131						CALLMONITOR 
3131 cd ae 13			call break_point_state  
3134				endm  
# End of macro CALLMONITOR
3134					endif 
3134			 
3134					NEXTW 
3134 c3 71 1d			jp macro_next 
3137				endm 
# End of macro NEXTW
3137			;	       NEXTW 
3137			 
3137			.UNTIL: 
3137				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3137 72				db WORD_SYS_CORE+94             
3138 ce 31			dw .ENDFLOW            
313a 06				db 5 + 1 
313b .. 00			db "UNTIL",0              
3141				endm 
# End of macro CWHEAD
3141			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3141			 
3141				; pop tos as check 
3141			 
3141				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3141			 
3141				FORTH_DSP_VALUEHL 
3141 cd ff 1b			call macro_dsp_valuehl 
3144				endm 
# End of macro FORTH_DSP_VALUEHL
3144			 
3144					if DEBUG_FORTH_WORDS_KEY 
3144						DMARK "UNT" 
3144 f5				push af  
3145 3a 59 31			ld a, (.dmark)  
3148 32 71 ee			ld (debug_mark),a  
314b 3a 5a 31			ld a, (.dmark+1)  
314e 32 72 ee			ld (debug_mark+1),a  
3151 3a 5b 31			ld a, (.dmark+2)  
3154 32 73 ee			ld (debug_mark+2),a  
3157 18 03			jr .pastdmark  
3159 ..			.dmark: db "UNT"  
315c f1			.pastdmark: pop af  
315d			endm  
# End of macro DMARK
315d						CALLMONITOR 
315d cd ae 13			call break_point_state  
3160				endm  
# End of macro CALLMONITOR
3160					endif 
3160			 
3160			;	push hl 
3160				FORTH_DSP_POP 
3160 cd b7 1c			call macro_forth_dsp_pop 
3163				endm 
# End of macro FORTH_DSP_POP
3163			 
3163			;	pop hl 
3163			 
3163				; test if true 
3163			 
3163 cd d6 0b			call ishlzero 
3166			;	ld a,l 
3166			;	add h 
3166			; 
3166			;	cp 0 
3166			 
3166 20 3e			jr nz, .untilnotdone 
3168			 
3168					if DEBUG_FORTH_WORDS 
3168						DMARK "UNf" 
3168 f5				push af  
3169 3a 7d 31			ld a, (.dmark)  
316c 32 71 ee			ld (debug_mark),a  
316f 3a 7e 31			ld a, (.dmark+1)  
3172 32 72 ee			ld (debug_mark+1),a  
3175 3a 7f 31			ld a, (.dmark+2)  
3178 32 73 ee			ld (debug_mark+2),a  
317b 18 03			jr .pastdmark  
317d ..			.dmark: db "UNf"  
3180 f1			.pastdmark: pop af  
3181			endm  
# End of macro DMARK
3181						CALLMONITOR 
3181 cd ae 13			call break_point_state  
3184				endm  
# End of macro CALLMONITOR
3184					endif 
3184			 
3184			 
3184			 
3184				FORTH_RSP_POP     ; get rid of DO ptr 
3184 cd d0 19			call macro_forth_rsp_pop 
3187				endm 
# End of macro FORTH_RSP_POP
3187			 
3187			if DEBUG_FORTH_WORDS 
3187						DMARK "UN>" 
3187 f5				push af  
3188 3a 9c 31			ld a, (.dmark)  
318b 32 71 ee			ld (debug_mark),a  
318e 3a 9d 31			ld a, (.dmark+1)  
3191 32 72 ee			ld (debug_mark+1),a  
3194 3a 9e 31			ld a, (.dmark+2)  
3197 32 73 ee			ld (debug_mark+2),a  
319a 18 03			jr .pastdmark  
319c ..			.dmark: db "UN>"  
319f f1			.pastdmark: pop af  
31a0			endm  
# End of macro DMARK
31a0				CALLMONITOR 
31a0 cd ae 13			call break_point_state  
31a3				endm  
# End of macro CALLMONITOR
31a3			endif 
31a3			 
31a3					NEXTW 
31a3 c3 71 1d			jp macro_next 
31a6				endm 
# End of macro NEXTW
31a6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31a6			 
31a6			.untilnotdone: 
31a6			 
31a6			 
31a6			;	; get DO ptr 
31a6			; 
31a6				FORTH_RSP_TOS 
31a6 cd c6 19			call macro_forth_rsp_tos 
31a9				endm 
# End of macro FORTH_RSP_TOS
31a9			 
31a9				;push hl 
31a9			 
31a9				; not going to DO any more 
31a9				; get rid of the RSP pointer as DO will add it back in 
31a9				;FORTH_RSP_POP 
31a9				;pop hl 
31a9			 
31a9			 
31a9 22 58 e6			ld (os_tok_ptr), hl 
31ac					if DEBUG_FORTH_WORDS 
31ac						DMARK "UN<" 
31ac f5				push af  
31ad 3a c1 31			ld a, (.dmark)  
31b0 32 71 ee			ld (debug_mark),a  
31b3 3a c2 31			ld a, (.dmark+1)  
31b6 32 72 ee			ld (debug_mark+1),a  
31b9 3a c3 31			ld a, (.dmark+2)  
31bc 32 73 ee			ld (debug_mark+2),a  
31bf 18 03			jr .pastdmark  
31c1 ..			.dmark: db "UN<"  
31c4 f1			.pastdmark: pop af  
31c5			endm  
# End of macro DMARK
31c5					CALLMONITOR 
31c5 cd ae 13			call break_point_state  
31c8				endm  
# End of macro CALLMONITOR
31c8				endif 
31c8 c3 02 1e			jp exec1 
31cb			 
31cb					 
31cb			 
31cb			 
31cb					NEXTW 
31cb c3 71 1d			jp macro_next 
31ce				endm 
# End of macro NEXTW
31ce			 
31ce			 
31ce			.ENDFLOW: 
31ce			 
31ce			; eof 
31ce			 
# End of file forth_words_flow.asm
31ce			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
31ce			include "forth_words_logic.asm" 
31ce			 
31ce			; | ## Logic Words 
31ce			 
31ce			.NOT: 
31ce				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
31ce 2d				db WORD_SYS_CORE+25             
31cf 16 32			dw .IS            
31d1 04				db 3 + 1 
31d2 .. 00			db "NOT",0              
31d6				endm 
# End of macro CWHEAD
31d6			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
31d6					if DEBUG_FORTH_WORDS_KEY 
31d6						DMARK "NOT" 
31d6 f5				push af  
31d7 3a eb 31			ld a, (.dmark)  
31da 32 71 ee			ld (debug_mark),a  
31dd 3a ec 31			ld a, (.dmark+1)  
31e0 32 72 ee			ld (debug_mark+1),a  
31e3 3a ed 31			ld a, (.dmark+2)  
31e6 32 73 ee			ld (debug_mark+2),a  
31e9 18 03			jr .pastdmark  
31eb ..			.dmark: db "NOT"  
31ee f1			.pastdmark: pop af  
31ef			endm  
# End of macro DMARK
31ef						CALLMONITOR 
31ef cd ae 13			call break_point_state  
31f2				endm  
# End of macro CALLMONITOR
31f2					endif 
31f2					FORTH_DSP 
31f2 cd c5 1b			call macro_forth_dsp 
31f5				endm 
# End of macro FORTH_DSP
31f5 7e					ld a,(hl)	; get type of value on TOS 
31f6 fe 02				cp DS_TYPE_INUM  
31f8 28 03				jr z, .noti 
31fa					NEXTW 
31fa c3 71 1d			jp macro_next 
31fd				endm 
# End of macro NEXTW
31fd			.noti:          FORTH_DSP_VALUEHL 
31fd cd ff 1b			call macro_dsp_valuehl 
3200				endm 
# End of macro FORTH_DSP_VALUEHL
3200			;		push hl 
3200					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3200 cd b7 1c			call macro_forth_dsp_pop 
3203				endm 
# End of macro FORTH_DSP_POP
3203			;		pop hl 
3203 3e 00				ld a,0 
3205 bd					cp l 
3206 28 04				jr z, .not2t 
3208 2e 00				ld l, 0 
320a 18 02				jr .notip 
320c			 
320c 2e ff		.not2t:		ld l, 255 
320e			 
320e 26 00		.notip:		ld h, 0	 
3210			 
3210 cd 08 1a				call forth_push_numhl 
3213					NEXTW 
3213 c3 71 1d			jp macro_next 
3216				endm 
# End of macro NEXTW
3216			 
3216			.IS: 
3216				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3216 2d				db WORD_SYS_CORE+25             
3217 3c 32			dw .LZERO            
3219 03				db 2 + 1 
321a .. 00			db "IS",0              
321d				endm 
# End of macro CWHEAD
321d			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
321d					if DEBUG_FORTH_WORDS_KEY 
321d						DMARK "IS." 
321d f5				push af  
321e 3a 32 32			ld a, (.dmark)  
3221 32 71 ee			ld (debug_mark),a  
3224 3a 33 32			ld a, (.dmark+1)  
3227 32 72 ee			ld (debug_mark+1),a  
322a 3a 34 32			ld a, (.dmark+2)  
322d 32 73 ee			ld (debug_mark+2),a  
3230 18 03			jr .pastdmark  
3232 ..			.dmark: db "IS."  
3235 f1			.pastdmark: pop af  
3236			endm  
# End of macro DMARK
3236						CALLMONITOR 
3236 cd ae 13			call break_point_state  
3239				endm  
# End of macro CALLMONITOR
3239					endif 
3239					NEXTW 
3239 c3 71 1d			jp macro_next 
323c				endm 
# End of macro NEXTW
323c			.LZERO: 
323c				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
323c 2d				db WORD_SYS_CORE+25             
323d 46 32			dw .TZERO            
323f 03				db 2 + 1 
3240 .. 00			db "0<",0              
3243				endm 
# End of macro CWHEAD
3243			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3243					NEXTW 
3243 c3 71 1d			jp macro_next 
3246				endm 
# End of macro NEXTW
3246			.TZERO: 
3246				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3246 2e				db WORD_SYS_CORE+26             
3247 8d 32			dw .LESS            
3249 03				db 2 + 1 
324a .. 00			db "0=",0              
324d				endm 
# End of macro CWHEAD
324d			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
324d				; TODO add floating point number detection 
324d					;v5 FORTH_DSP_VALUE 
324d					if DEBUG_FORTH_WORDS_KEY 
324d						DMARK "0=." 
324d f5				push af  
324e 3a 62 32			ld a, (.dmark)  
3251 32 71 ee			ld (debug_mark),a  
3254 3a 63 32			ld a, (.dmark+1)  
3257 32 72 ee			ld (debug_mark+1),a  
325a 3a 64 32			ld a, (.dmark+2)  
325d 32 73 ee			ld (debug_mark+2),a  
3260 18 03			jr .pastdmark  
3262 ..			.dmark: db "0=."  
3265 f1			.pastdmark: pop af  
3266			endm  
# End of macro DMARK
3266						CALLMONITOR 
3266 cd ae 13			call break_point_state  
3269				endm  
# End of macro CALLMONITOR
3269					endif 
3269					FORTH_DSP 
3269 cd c5 1b			call macro_forth_dsp 
326c				endm 
# End of macro FORTH_DSP
326c 7e					ld a,(hl)	; get type of value on TOS 
326d fe 02				cp DS_TYPE_INUM  
326f 28 00				jr z, .tz_inum 
3271			 
3271				if FORTH_ENABLE_FLOATMATH 
3271					jr .tz_done 
3271			 
3271				endif 
3271					 
3271			 
3271			.tz_inum: 
3271					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3271 cd ff 1b			call macro_dsp_valuehl 
3274				endm 
# End of macro FORTH_DSP_VALUEHL
3274			 
3274			;		push hl 
3274			 
3274					; destroy value TOS 
3274			 
3274					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3274 cd b7 1c			call macro_forth_dsp_pop 
3277				endm 
# End of macro FORTH_DSP_POP
3277			 
3277			;		pop hl 
3277			 
3277 3e 00				ld a,0 
3279			 
3279 bd					cp l 
327a 20 08				jr nz, .tz_notzero 
327c			 
327c bc					cp h 
327d			 
327d 20 05				jr nz, .tz_notzero 
327f			 
327f			 
327f 21 01 00				ld hl, FORTH_TRUE 
3282 18 03				jr .tz_done 
3284			 
3284 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3287			 
3287					; push value back onto stack for another op etc 
3287			 
3287			.tz_done: 
3287 cd 08 1a				call forth_push_numhl 
328a			 
328a					NEXTW 
328a c3 71 1d			jp macro_next 
328d				endm 
# End of macro NEXTW
328d			.LESS: 
328d				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
328d 2f				db WORD_SYS_CORE+27             
328e f6 32			dw .GT            
3290 02				db 1 + 1 
3291 .. 00			db "<",0              
3293				endm 
# End of macro CWHEAD
3293			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3293				; TODO add floating point number detection 
3293					if DEBUG_FORTH_WORDS_KEY 
3293						DMARK "LES" 
3293 f5				push af  
3294 3a a8 32			ld a, (.dmark)  
3297 32 71 ee			ld (debug_mark),a  
329a 3a a9 32			ld a, (.dmark+1)  
329d 32 72 ee			ld (debug_mark+1),a  
32a0 3a aa 32			ld a, (.dmark+2)  
32a3 32 73 ee			ld (debug_mark+2),a  
32a6 18 03			jr .pastdmark  
32a8 ..			.dmark: db "LES"  
32ab f1			.pastdmark: pop af  
32ac			endm  
# End of macro DMARK
32ac						CALLMONITOR 
32ac cd ae 13			call break_point_state  
32af				endm  
# End of macro CALLMONITOR
32af					endif 
32af					FORTH_DSP 
32af cd c5 1b			call macro_forth_dsp 
32b2				endm 
# End of macro FORTH_DSP
32b2					;v5 FORTH_DSP_VALUE 
32b2 7e					ld a,(hl)	; get type of value on TOS 
32b3 fe 02				cp DS_TYPE_INUM  
32b5 28 00				jr z, .less_inum 
32b7			 
32b7				if FORTH_ENABLE_FLOATMATH 
32b7					jr .less_done 
32b7			 
32b7				endif 
32b7					 
32b7			 
32b7			.less_inum: 
32b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32b7 cd ff 1b			call macro_dsp_valuehl 
32ba				endm 
# End of macro FORTH_DSP_VALUEHL
32ba			 
32ba e5					push hl  ; u2 
32bb			 
32bb					; destroy value TOS 
32bb			 
32bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32bb cd b7 1c			call macro_forth_dsp_pop 
32be				endm 
# End of macro FORTH_DSP_POP
32be			 
32be			 
32be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32be cd ff 1b			call macro_dsp_valuehl 
32c1				endm 
# End of macro FORTH_DSP_VALUEHL
32c1			 
32c1 e5					push hl    ; u1 
32c2			 
32c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32c2 cd b7 1c			call macro_forth_dsp_pop 
32c5				endm 
# End of macro FORTH_DSP_POP
32c5			 
32c5			 
32c5 b7			 or a      ;clear carry flag 
32c6 01 00 00		 ld bc, FORTH_FALSE 
32c9 e1			  pop hl    ; u1 
32ca d1			  pop de    ; u2 
32cb ed 52		  sbc hl,de 
32cd 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
32cf			 
32cf 01 01 00		 ld bc, FORTH_TRUE 
32d2			.lscont:  
32d2 c5					push bc 
32d3 e1					pop hl 
32d4			 
32d4					if DEBUG_FORTH_WORDS 
32d4						DMARK "LT1" 
32d4 f5				push af  
32d5 3a e9 32			ld a, (.dmark)  
32d8 32 71 ee			ld (debug_mark),a  
32db 3a ea 32			ld a, (.dmark+1)  
32de 32 72 ee			ld (debug_mark+1),a  
32e1 3a eb 32			ld a, (.dmark+2)  
32e4 32 73 ee			ld (debug_mark+2),a  
32e7 18 03			jr .pastdmark  
32e9 ..			.dmark: db "LT1"  
32ec f1			.pastdmark: pop af  
32ed			endm  
# End of macro DMARK
32ed						CALLMONITOR 
32ed cd ae 13			call break_point_state  
32f0				endm  
# End of macro CALLMONITOR
32f0					endif 
32f0 cd 08 1a				call forth_push_numhl 
32f3			 
32f3					NEXTW 
32f3 c3 71 1d			jp macro_next 
32f6				endm 
# End of macro NEXTW
32f6			.GT: 
32f6				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
32f6 30				db WORD_SYS_CORE+28             
32f7 5f 33			dw .EQUAL            
32f9 02				db 1 + 1 
32fa .. 00			db ">",0              
32fc				endm 
# End of macro CWHEAD
32fc			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
32fc				; TODO add floating point number detection 
32fc					if DEBUG_FORTH_WORDS_KEY 
32fc						DMARK "GRT" 
32fc f5				push af  
32fd 3a 11 33			ld a, (.dmark)  
3300 32 71 ee			ld (debug_mark),a  
3303 3a 12 33			ld a, (.dmark+1)  
3306 32 72 ee			ld (debug_mark+1),a  
3309 3a 13 33			ld a, (.dmark+2)  
330c 32 73 ee			ld (debug_mark+2),a  
330f 18 03			jr .pastdmark  
3311 ..			.dmark: db "GRT"  
3314 f1			.pastdmark: pop af  
3315			endm  
# End of macro DMARK
3315						CALLMONITOR 
3315 cd ae 13			call break_point_state  
3318				endm  
# End of macro CALLMONITOR
3318					endif 
3318					FORTH_DSP 
3318 cd c5 1b			call macro_forth_dsp 
331b				endm 
# End of macro FORTH_DSP
331b					;FORTH_DSP_VALUE 
331b 7e					ld a,(hl)	; get type of value on TOS 
331c fe 02				cp DS_TYPE_INUM  
331e 28 00				jr z, .gt_inum 
3320			 
3320				if FORTH_ENABLE_FLOATMATH 
3320					jr .gt_done 
3320			 
3320				endif 
3320					 
3320			 
3320			.gt_inum: 
3320					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3320 cd ff 1b			call macro_dsp_valuehl 
3323				endm 
# End of macro FORTH_DSP_VALUEHL
3323			 
3323 e5					push hl  ; u2 
3324			 
3324					; destroy value TOS 
3324			 
3324					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3324 cd b7 1c			call macro_forth_dsp_pop 
3327				endm 
# End of macro FORTH_DSP_POP
3327			 
3327			 
3327					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3327 cd ff 1b			call macro_dsp_valuehl 
332a				endm 
# End of macro FORTH_DSP_VALUEHL
332a			 
332a e5					push hl    ; u1 
332b			 
332b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
332b cd b7 1c			call macro_forth_dsp_pop 
332e				endm 
# End of macro FORTH_DSP_POP
332e			 
332e			 
332e b7			 or a      ;clear carry flag 
332f 01 00 00		 ld bc, FORTH_FALSE 
3332 e1			  pop hl    ; u1 
3333 d1			  pop de    ; u2 
3334 ed 52		  sbc hl,de 
3336 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3338			 
3338 01 01 00		 ld bc, FORTH_TRUE 
333b			.gtcont:  
333b c5					push bc 
333c e1					pop hl 
333d			 
333d					if DEBUG_FORTH_WORDS 
333d						DMARK "GT1" 
333d f5				push af  
333e 3a 52 33			ld a, (.dmark)  
3341 32 71 ee			ld (debug_mark),a  
3344 3a 53 33			ld a, (.dmark+1)  
3347 32 72 ee			ld (debug_mark+1),a  
334a 3a 54 33			ld a, (.dmark+2)  
334d 32 73 ee			ld (debug_mark+2),a  
3350 18 03			jr .pastdmark  
3352 ..			.dmark: db "GT1"  
3355 f1			.pastdmark: pop af  
3356			endm  
# End of macro DMARK
3356						CALLMONITOR 
3356 cd ae 13			call break_point_state  
3359				endm  
# End of macro CALLMONITOR
3359					endif 
3359 cd 08 1a				call forth_push_numhl 
335c			 
335c					NEXTW 
335c c3 71 1d			jp macro_next 
335f				endm 
# End of macro NEXTW
335f			.EQUAL: 
335f				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
335f 31				db WORD_SYS_CORE+29             
3360 ca 33			dw .ENDLOGIC            
3362 02				db 1 + 1 
3363 .. 00			db "=",0              
3365				endm 
# End of macro CWHEAD
3365			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3365				; TODO add floating point number detection 
3365					if DEBUG_FORTH_WORDS_KEY 
3365						DMARK "EQ." 
3365 f5				push af  
3366 3a 7a 33			ld a, (.dmark)  
3369 32 71 ee			ld (debug_mark),a  
336c 3a 7b 33			ld a, (.dmark+1)  
336f 32 72 ee			ld (debug_mark+1),a  
3372 3a 7c 33			ld a, (.dmark+2)  
3375 32 73 ee			ld (debug_mark+2),a  
3378 18 03			jr .pastdmark  
337a ..			.dmark: db "EQ."  
337d f1			.pastdmark: pop af  
337e			endm  
# End of macro DMARK
337e						CALLMONITOR 
337e cd ae 13			call break_point_state  
3381				endm  
# End of macro CALLMONITOR
3381					endif 
3381					FORTH_DSP 
3381 cd c5 1b			call macro_forth_dsp 
3384				endm 
# End of macro FORTH_DSP
3384					;v5 FORTH_DSP_VALUE 
3384 7e					ld a,(hl)	; get type of value on TOS 
3385 fe 02				cp DS_TYPE_INUM  
3387 28 00				jr z, .eq_inum 
3389			 
3389				if FORTH_ENABLE_FLOATMATH 
3389					jr .eq_done 
3389			 
3389				endif 
3389					 
3389			 
3389			.eq_inum: 
3389					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3389 cd ff 1b			call macro_dsp_valuehl 
338c				endm 
# End of macro FORTH_DSP_VALUEHL
338c			 
338c e5					push hl 
338d			 
338d					; destroy value TOS 
338d			 
338d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
338d cd b7 1c			call macro_forth_dsp_pop 
3390				endm 
# End of macro FORTH_DSP_POP
3390			 
3390			 
3390					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3390 cd ff 1b			call macro_dsp_valuehl 
3393				endm 
# End of macro FORTH_DSP_VALUEHL
3393			 
3393					; one value on hl get other one back 
3393			 
3393 e5					push hl 
3394			 
3394					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3394 cd b7 1c			call macro_forth_dsp_pop 
3397				endm 
# End of macro FORTH_DSP_POP
3397			 
3397 0e 00				ld c, FORTH_FALSE 
3399			 
3399 e1					pop hl 
339a d1					pop de 
339b			 
339b 7b					ld a, e 
339c bd					cp l 
339d			 
339d 20 06				jr nz, .eq_done 
339f			 
339f 7a					ld a, d 
33a0 bc					cp h 
33a1			 
33a1 20 02				jr nz, .eq_done 
33a3			 
33a3 0e 01				ld c, FORTH_TRUE 
33a5					 
33a5			 
33a5			 
33a5			.eq_done: 
33a5			 
33a5					; TODO push value back onto stack for another op etc 
33a5			 
33a5 26 00				ld h, 0 
33a7 69					ld l, c 
33a8					if DEBUG_FORTH_WORDS 
33a8						DMARK "EQ1" 
33a8 f5				push af  
33a9 3a bd 33			ld a, (.dmark)  
33ac 32 71 ee			ld (debug_mark),a  
33af 3a be 33			ld a, (.dmark+1)  
33b2 32 72 ee			ld (debug_mark+1),a  
33b5 3a bf 33			ld a, (.dmark+2)  
33b8 32 73 ee			ld (debug_mark+2),a  
33bb 18 03			jr .pastdmark  
33bd ..			.dmark: db "EQ1"  
33c0 f1			.pastdmark: pop af  
33c1			endm  
# End of macro DMARK
33c1						CALLMONITOR 
33c1 cd ae 13			call break_point_state  
33c4				endm  
# End of macro CALLMONITOR
33c4					endif 
33c4 cd 08 1a				call forth_push_numhl 
33c7			 
33c7					NEXTW 
33c7 c3 71 1d			jp macro_next 
33ca				endm 
# End of macro NEXTW
33ca			 
33ca			 
33ca			.ENDLOGIC: 
33ca			; eof 
33ca			 
33ca			 
# End of file forth_words_logic.asm
33ca			include "forth_words_maths.asm" 
33ca			 
33ca			; | ## Maths Words 
33ca			 
33ca			.PLUS:	 
33ca				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
33ca 15				db WORD_SYS_CORE+1             
33cb 0c 34			dw .NEG            
33cd 02				db 1 + 1 
33ce .. 00			db "+",0              
33d0				endm 
# End of macro CWHEAD
33d0			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
33d0					if DEBUG_FORTH_WORDS_KEY 
33d0						DMARK "PLU" 
33d0 f5				push af  
33d1 3a e5 33			ld a, (.dmark)  
33d4 32 71 ee			ld (debug_mark),a  
33d7 3a e6 33			ld a, (.dmark+1)  
33da 32 72 ee			ld (debug_mark+1),a  
33dd 3a e7 33			ld a, (.dmark+2)  
33e0 32 73 ee			ld (debug_mark+2),a  
33e3 18 03			jr .pastdmark  
33e5 ..			.dmark: db "PLU"  
33e8 f1			.pastdmark: pop af  
33e9			endm  
# End of macro DMARK
33e9						CALLMONITOR 
33e9 cd ae 13			call break_point_state  
33ec				endm  
# End of macro CALLMONITOR
33ec					endif 
33ec					; add top two values and push back result 
33ec			 
33ec					;for v5 FORTH_DSP_VALUE 
33ec					FORTH_DSP 
33ec cd c5 1b			call macro_forth_dsp 
33ef				endm 
# End of macro FORTH_DSP
33ef 7e					ld a,(hl)	; get type of value on TOS 
33f0 fe 02				cp DS_TYPE_INUM  
33f2 28 03				jr z, .dot_inum 
33f4			 
33f4					NEXTW 
33f4 c3 71 1d			jp macro_next 
33f7				endm 
# End of macro NEXTW
33f7			 
33f7			; float maths 
33f7			 
33f7				if FORTH_ENABLE_FLOATMATH 
33f7						inc hl      ; now at start of numeric as string 
33f7			 
33f7					if DEBUG_FORTH_MATHS 
33f7						DMARK "ADD" 
33f7				CALLMONITOR 
33f7					endif 
33f7			 
33f7					;ld ix, hl 
33f7					call CON 
33f7			 
33f7			 
33f7					push hl 
33f7					 
33f7					 
33f7			 
33f7						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
33f7			 
33f7					; get next number 
33f7			 
33f7						FORTH_DSP_VALUE 
33f7			 
33f7						inc hl      ; now at start of numeric as string 
33f7			 
33f7					;ld ix, hl 
33f7					call CON 
33f7			 
33f7					push hl 
33f7			 
33f7			 
33f7						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33f7			 
33f7						; TODO do add 
33f7			 
33f7						call IADD 
33f7			 
33f7						; TODO get result back as ascii 
33f7			 
33f7						; TODO push result  
33f7			 
33f7			 
33f7			 
33f7						jr .dot_done 
33f7				endif 
33f7			 
33f7			.dot_inum: 
33f7			 
33f7			 
33f7					if DEBUG_FORTH_DOT 
33f7						DMARK "+IT" 
33f7				CALLMONITOR 
33f7					endif 
33f7			 
33f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33f7 cd ff 1b			call macro_dsp_valuehl 
33fa				endm 
# End of macro FORTH_DSP_VALUEHL
33fa			 
33fa				; TODO add floating point number detection 
33fa			 
33fa e5					push hl 
33fb			 
33fb					; destroy value TOS 
33fb			 
33fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33fb cd b7 1c			call macro_forth_dsp_pop 
33fe				endm 
# End of macro FORTH_DSP_POP
33fe			 
33fe			 
33fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33fe cd ff 1b			call macro_dsp_valuehl 
3401				endm 
# End of macro FORTH_DSP_VALUEHL
3401			 
3401					; one value on hl get other one back 
3401			 
3401 d1					pop de 
3402			 
3402					; do the add 
3402			 
3402 19					add hl,de 
3403			 
3403					; save it 
3403			 
3403			;		push hl	 
3403			 
3403					; 
3403			 
3403					; destroy value TOS 
3403			 
3403					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3403 cd b7 1c			call macro_forth_dsp_pop 
3406				endm 
# End of macro FORTH_DSP_POP
3406			 
3406					; TODO push value back onto stack for another op etc 
3406			 
3406			;		pop hl 
3406			 
3406			.dot_done: 
3406 cd 08 1a				call forth_push_numhl 
3409			 
3409					NEXTW 
3409 c3 71 1d			jp macro_next 
340c				endm 
# End of macro NEXTW
340c			.NEG: 
340c			 
340c				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
340c 17				db WORD_SYS_CORE+3             
340d 4f 34			dw .DIV            
340f 02				db 1 + 1 
3410 .. 00			db "-",0              
3412				endm 
# End of macro CWHEAD
3412			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3412					if DEBUG_FORTH_WORDS_KEY 
3412						DMARK "SUB" 
3412 f5				push af  
3413 3a 27 34			ld a, (.dmark)  
3416 32 71 ee			ld (debug_mark),a  
3419 3a 28 34			ld a, (.dmark+1)  
341c 32 72 ee			ld (debug_mark+1),a  
341f 3a 29 34			ld a, (.dmark+2)  
3422 32 73 ee			ld (debug_mark+2),a  
3425 18 03			jr .pastdmark  
3427 ..			.dmark: db "SUB"  
342a f1			.pastdmark: pop af  
342b			endm  
# End of macro DMARK
342b						CALLMONITOR 
342b cd ae 13			call break_point_state  
342e				endm  
# End of macro CALLMONITOR
342e					endif 
342e			 
342e			 
342e				; TODO add floating point number detection 
342e					; v5 FORTH_DSP_VALUE 
342e					FORTH_DSP 
342e cd c5 1b			call macro_forth_dsp 
3431				endm 
# End of macro FORTH_DSP
3431 7e					ld a,(hl)	; get type of value on TOS 
3432 fe 02				cp DS_TYPE_INUM  
3434 28 03				jr z, .neg_inum 
3436			 
3436					NEXTW 
3436 c3 71 1d			jp macro_next 
3439				endm 
# End of macro NEXTW
3439			 
3439			; float maths 
3439			 
3439				if FORTH_ENABLE_FLOATMATH 
3439					jr .neg_done 
3439			 
3439				endif 
3439					 
3439			 
3439			.neg_inum: 
3439					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3439 cd ff 1b			call macro_dsp_valuehl 
343c				endm 
# End of macro FORTH_DSP_VALUEHL
343c			 
343c e5					push hl 
343d			 
343d					; destroy value TOS 
343d			 
343d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
343d cd b7 1c			call macro_forth_dsp_pop 
3440				endm 
# End of macro FORTH_DSP_POP
3440			 
3440			 
3440					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3440 cd ff 1b			call macro_dsp_valuehl 
3443				endm 
# End of macro FORTH_DSP_VALUEHL
3443			 
3443					; one value on hl get other one back 
3443			 
3443 d1					pop de 
3444			 
3444					; do the sub 
3444			;		ex de, hl 
3444			 
3444 ed 52				sbc hl,de 
3446			 
3446					; save it 
3446			 
3446			;		push hl	 
3446			 
3446					; 
3446			 
3446					; destroy value TOS 
3446			 
3446					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3446 cd b7 1c			call macro_forth_dsp_pop 
3449				endm 
# End of macro FORTH_DSP_POP
3449			 
3449					; TODO push value back onto stack for another op etc 
3449			 
3449			;		pop hl 
3449			 
3449 cd 08 1a				call forth_push_numhl 
344c			.neg_done: 
344c			 
344c					NEXTW 
344c c3 71 1d			jp macro_next 
344f				endm 
# End of macro NEXTW
344f			.DIV: 
344f				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
344f 18				db WORD_SYS_CORE+4             
3450 9c 34			dw .MUL            
3452 02				db 1 + 1 
3453 .. 00			db "/",0              
3455				endm 
# End of macro CWHEAD
3455			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3455					if DEBUG_FORTH_WORDS_KEY 
3455						DMARK "DIV" 
3455 f5				push af  
3456 3a 6a 34			ld a, (.dmark)  
3459 32 71 ee			ld (debug_mark),a  
345c 3a 6b 34			ld a, (.dmark+1)  
345f 32 72 ee			ld (debug_mark+1),a  
3462 3a 6c 34			ld a, (.dmark+2)  
3465 32 73 ee			ld (debug_mark+2),a  
3468 18 03			jr .pastdmark  
346a ..			.dmark: db "DIV"  
346d f1			.pastdmark: pop af  
346e			endm  
# End of macro DMARK
346e						CALLMONITOR 
346e cd ae 13			call break_point_state  
3471				endm  
# End of macro CALLMONITOR
3471					endif 
3471				; TODO add floating point number detection 
3471					; v5 FORTH_DSP_VALUE 
3471					FORTH_DSP 
3471 cd c5 1b			call macro_forth_dsp 
3474				endm 
# End of macro FORTH_DSP
3474 7e					ld a,(hl)	; get type of value on TOS 
3475 fe 02				cp DS_TYPE_INUM  
3477 28 03				jr z, .div_inum 
3479			 
3479				if FORTH_ENABLE_FLOATMATH 
3479					jr .div_done 
3479			 
3479				endif 
3479					NEXTW 
3479 c3 71 1d			jp macro_next 
347c				endm 
# End of macro NEXTW
347c			.div_inum: 
347c			 
347c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
347c cd ff 1b			call macro_dsp_valuehl 
347f				endm 
# End of macro FORTH_DSP_VALUEHL
347f			 
347f e5					push hl    ; to go to bc 
3480			 
3480					; destroy value TOS 
3480			 
3480					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3480 cd b7 1c			call macro_forth_dsp_pop 
3483				endm 
# End of macro FORTH_DSP_POP
3483			 
3483			 
3483					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3483 cd ff 1b			call macro_dsp_valuehl 
3486				endm 
# End of macro FORTH_DSP_VALUEHL
3486			 
3486					; hl to go to de 
3486			 
3486 e5					push hl 
3487			 
3487 c1					pop bc 
3488 d1					pop de		 
3489			 
3489			 
3489					if DEBUG_FORTH_MATHS 
3489						DMARK "DIV" 
3489				CALLMONITOR 
3489					endif 
3489					; one value on hl but move to a get other one back 
3489			 
3489			        
3489 cd 0a 0b			call Div16 
348c			 
348c			;	push af	 
348c e5				push hl 
348d c5				push bc 
348e			 
348e					if DEBUG_FORTH_MATHS 
348e						DMARK "DI1" 
348e				CALLMONITOR 
348e					endif 
348e			 
348e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
348e cd b7 1c			call macro_forth_dsp_pop 
3491				endm 
# End of macro FORTH_DSP_POP
3491			 
3491			 
3491			 
3491 e1					pop hl    ; result 
3492			 
3492 cd 08 1a				call forth_push_numhl 
3495			 
3495 e1					pop hl    ; reminder 
3496			;		ld h,0 
3496			;		ld l,d 
3496			 
3496 cd 08 1a				call forth_push_numhl 
3499			.div_done: 
3499					NEXTW 
3499 c3 71 1d			jp macro_next 
349c				endm 
# End of macro NEXTW
349c			.MUL: 
349c				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
349c 19				db WORD_SYS_CORE+5             
349d e1 34			dw .MIN            
349f 02				db 1 + 1 
34a0 .. 00			db "*",0              
34a2				endm 
# End of macro CWHEAD
34a2			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
34a2				; TODO add floating point number detection 
34a2					if DEBUG_FORTH_WORDS_KEY 
34a2						DMARK "MUL" 
34a2 f5				push af  
34a3 3a b7 34			ld a, (.dmark)  
34a6 32 71 ee			ld (debug_mark),a  
34a9 3a b8 34			ld a, (.dmark+1)  
34ac 32 72 ee			ld (debug_mark+1),a  
34af 3a b9 34			ld a, (.dmark+2)  
34b2 32 73 ee			ld (debug_mark+2),a  
34b5 18 03			jr .pastdmark  
34b7 ..			.dmark: db "MUL"  
34ba f1			.pastdmark: pop af  
34bb			endm  
# End of macro DMARK
34bb						CALLMONITOR 
34bb cd ae 13			call break_point_state  
34be				endm  
# End of macro CALLMONITOR
34be					endif 
34be					FORTH_DSP 
34be cd c5 1b			call macro_forth_dsp 
34c1				endm 
# End of macro FORTH_DSP
34c1					; v5 FORTH_DSP_VALUE 
34c1 7e					ld a,(hl)	; get type of value on TOS 
34c2 fe 02				cp DS_TYPE_INUM  
34c4 28 03				jr z, .mul_inum 
34c6			 
34c6				if FORTH_ENABLE_FLOATMATH 
34c6					jr .mul_done 
34c6			 
34c6				endif 
34c6			 
34c6					NEXTW 
34c6 c3 71 1d			jp macro_next 
34c9				endm 
# End of macro NEXTW
34c9			.mul_inum:	 
34c9			 
34c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34c9 cd ff 1b			call macro_dsp_valuehl 
34cc				endm 
# End of macro FORTH_DSP_VALUEHL
34cc			 
34cc e5					push hl 
34cd			 
34cd					; destroy value TOS 
34cd			 
34cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34cd cd b7 1c			call macro_forth_dsp_pop 
34d0				endm 
# End of macro FORTH_DSP_POP
34d0			 
34d0			 
34d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d0 cd ff 1b			call macro_dsp_valuehl 
34d3				endm 
# End of macro FORTH_DSP_VALUEHL
34d3			 
34d3					; one value on hl but move to a get other one back 
34d3			 
34d3 7d					ld a, l 
34d4			 
34d4 d1					pop de 
34d5			 
34d5					; do the mull 
34d5			;		ex de, hl 
34d5			 
34d5 cd 30 0b				call Mult16 
34d8					; save it 
34d8			 
34d8			;		push hl	 
34d8			 
34d8					; 
34d8			 
34d8					; destroy value TOS 
34d8			 
34d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d8 cd b7 1c			call macro_forth_dsp_pop 
34db				endm 
# End of macro FORTH_DSP_POP
34db			 
34db					; TODO push value back onto stack for another op etc 
34db			 
34db			;		pop hl 
34db			 
34db cd 08 1a				call forth_push_numhl 
34de			 
34de			.mul_done: 
34de					NEXTW 
34de c3 71 1d			jp macro_next 
34e1				endm 
# End of macro NEXTW
34e1			 
34e1			 
34e1			 
34e1			 
34e1			.MIN: 
34e1				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
34e1 49				db WORD_SYS_CORE+53             
34e2 62 35			dw .MAX            
34e4 04				db 3 + 1 
34e5 .. 00			db "MIN",0              
34e9				endm 
# End of macro CWHEAD
34e9			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
34e9					if DEBUG_FORTH_WORDS_KEY 
34e9						DMARK "MIN" 
34e9 f5				push af  
34ea 3a fe 34			ld a, (.dmark)  
34ed 32 71 ee			ld (debug_mark),a  
34f0 3a ff 34			ld a, (.dmark+1)  
34f3 32 72 ee			ld (debug_mark+1),a  
34f6 3a 00 35			ld a, (.dmark+2)  
34f9 32 73 ee			ld (debug_mark+2),a  
34fc 18 03			jr .pastdmark  
34fe ..			.dmark: db "MIN"  
3501 f1			.pastdmark: pop af  
3502			endm  
# End of macro DMARK
3502						CALLMONITOR 
3502 cd ae 13			call break_point_state  
3505				endm  
# End of macro CALLMONITOR
3505					endif 
3505					; get u2 
3505			 
3505					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3505 cd ff 1b			call macro_dsp_valuehl 
3508				endm 
# End of macro FORTH_DSP_VALUEHL
3508			 
3508 e5					push hl   ; u2 
3509			 
3509					; destroy value TOS 
3509			 
3509					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3509 cd b7 1c			call macro_forth_dsp_pop 
350c				endm 
# End of macro FORTH_DSP_POP
350c			 
350c					; get u1 
350c			 
350c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
350c cd ff 1b			call macro_dsp_valuehl 
350f				endm 
# End of macro FORTH_DSP_VALUEHL
350f			 
350f e5					push hl  ; u1 
3510			 
3510					; destroy value TOS 
3510			 
3510					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3510 cd b7 1c			call macro_forth_dsp_pop 
3513				endm 
# End of macro FORTH_DSP_POP
3513			 
3513 b7			 or a      ;clear carry flag 
3514 e1			  pop hl    ; u1 
3515 d1			  pop de    ; u2 
3516 e5				push hl   ; saved in case hl is lowest 
3517 ed 52		  sbc hl,de 
3519 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
351b			 
351b e1				pop hl 
351c					if DEBUG_FORTH_WORDS 
351c						DMARK "MIN" 
351c f5				push af  
351d 3a 31 35			ld a, (.dmark)  
3520 32 71 ee			ld (debug_mark),a  
3523 3a 32 35			ld a, (.dmark+1)  
3526 32 72 ee			ld (debug_mark+1),a  
3529 3a 33 35			ld a, (.dmark+2)  
352c 32 73 ee			ld (debug_mark+2),a  
352f 18 03			jr .pastdmark  
3531 ..			.dmark: db "MIN"  
3534 f1			.pastdmark: pop af  
3535			endm  
# End of macro DMARK
3535						CALLMONITOR 
3535 cd ae 13			call break_point_state  
3538				endm  
# End of macro CALLMONITOR
3538					endif 
3538 cd 08 1a				call forth_push_numhl 
353b			 
353b				       NEXTW 
353b c3 71 1d			jp macro_next 
353e				endm 
# End of macro NEXTW
353e			 
353e			.mincont:  
353e c1				pop bc   ; tidy up 
353f eb				ex de , hl  
3540					if DEBUG_FORTH_WORDS 
3540						DMARK "MI1" 
3540 f5				push af  
3541 3a 55 35			ld a, (.dmark)  
3544 32 71 ee			ld (debug_mark),a  
3547 3a 56 35			ld a, (.dmark+1)  
354a 32 72 ee			ld (debug_mark+1),a  
354d 3a 57 35			ld a, (.dmark+2)  
3550 32 73 ee			ld (debug_mark+2),a  
3553 18 03			jr .pastdmark  
3555 ..			.dmark: db "MI1"  
3558 f1			.pastdmark: pop af  
3559			endm  
# End of macro DMARK
3559						CALLMONITOR 
3559 cd ae 13			call break_point_state  
355c				endm  
# End of macro CALLMONITOR
355c					endif 
355c cd 08 1a				call forth_push_numhl 
355f			 
355f				       NEXTW 
355f c3 71 1d			jp macro_next 
3562				endm 
# End of macro NEXTW
3562			.MAX: 
3562				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3562 4a				db WORD_SYS_CORE+54             
3563 e3 35			dw .RND16            
3565 04				db 3 + 1 
3566 .. 00			db "MAX",0              
356a				endm 
# End of macro CWHEAD
356a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
356a					if DEBUG_FORTH_WORDS_KEY 
356a						DMARK "MAX" 
356a f5				push af  
356b 3a 7f 35			ld a, (.dmark)  
356e 32 71 ee			ld (debug_mark),a  
3571 3a 80 35			ld a, (.dmark+1)  
3574 32 72 ee			ld (debug_mark+1),a  
3577 3a 81 35			ld a, (.dmark+2)  
357a 32 73 ee			ld (debug_mark+2),a  
357d 18 03			jr .pastdmark  
357f ..			.dmark: db "MAX"  
3582 f1			.pastdmark: pop af  
3583			endm  
# End of macro DMARK
3583						CALLMONITOR 
3583 cd ae 13			call break_point_state  
3586				endm  
# End of macro CALLMONITOR
3586					endif 
3586					; get u2 
3586			 
3586					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3586 cd ff 1b			call macro_dsp_valuehl 
3589				endm 
# End of macro FORTH_DSP_VALUEHL
3589			 
3589 e5					push hl   ; u2 
358a			 
358a					; destroy value TOS 
358a			 
358a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
358a cd b7 1c			call macro_forth_dsp_pop 
358d				endm 
# End of macro FORTH_DSP_POP
358d			 
358d					; get u1 
358d			 
358d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
358d cd ff 1b			call macro_dsp_valuehl 
3590				endm 
# End of macro FORTH_DSP_VALUEHL
3590			 
3590 e5					push hl  ; u1 
3591			 
3591					; destroy value TOS 
3591			 
3591					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3591 cd b7 1c			call macro_forth_dsp_pop 
3594				endm 
# End of macro FORTH_DSP_POP
3594			 
3594 b7			 or a      ;clear carry flag 
3595 e1			  pop hl    ; u1 
3596 d1			  pop de    ; u2 
3597 e5				push hl   ; saved in case hl is lowest 
3598 ed 52		  sbc hl,de 
359a 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
359c			 
359c e1				pop hl 
359d					if DEBUG_FORTH_WORDS 
359d						DMARK "MAX" 
359d f5				push af  
359e 3a b2 35			ld a, (.dmark)  
35a1 32 71 ee			ld (debug_mark),a  
35a4 3a b3 35			ld a, (.dmark+1)  
35a7 32 72 ee			ld (debug_mark+1),a  
35aa 3a b4 35			ld a, (.dmark+2)  
35ad 32 73 ee			ld (debug_mark+2),a  
35b0 18 03			jr .pastdmark  
35b2 ..			.dmark: db "MAX"  
35b5 f1			.pastdmark: pop af  
35b6			endm  
# End of macro DMARK
35b6						CALLMONITOR 
35b6 cd ae 13			call break_point_state  
35b9				endm  
# End of macro CALLMONITOR
35b9					endif 
35b9 cd 08 1a				call forth_push_numhl 
35bc			 
35bc				       NEXTW 
35bc c3 71 1d			jp macro_next 
35bf				endm 
# End of macro NEXTW
35bf			 
35bf			.maxcont:  
35bf c1				pop bc   ; tidy up 
35c0 eb				ex de , hl  
35c1					if DEBUG_FORTH_WORDS 
35c1						DMARK "MA1" 
35c1 f5				push af  
35c2 3a d6 35			ld a, (.dmark)  
35c5 32 71 ee			ld (debug_mark),a  
35c8 3a d7 35			ld a, (.dmark+1)  
35cb 32 72 ee			ld (debug_mark+1),a  
35ce 3a d8 35			ld a, (.dmark+2)  
35d1 32 73 ee			ld (debug_mark+2),a  
35d4 18 03			jr .pastdmark  
35d6 ..			.dmark: db "MA1"  
35d9 f1			.pastdmark: pop af  
35da			endm  
# End of macro DMARK
35da						CALLMONITOR 
35da cd ae 13			call break_point_state  
35dd				endm  
# End of macro CALLMONITOR
35dd					endif 
35dd cd 08 1a				call forth_push_numhl 
35e0				       NEXTW 
35e0 c3 71 1d			jp macro_next 
35e3				endm 
# End of macro NEXTW
35e3			 
35e3			.RND16: 
35e3				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
35e3 4e				db WORD_SYS_CORE+58             
35e4 12 36			dw .RND8            
35e6 06				db 5 + 1 
35e7 .. 00			db "RND16",0              
35ed				endm 
# End of macro CWHEAD
35ed			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
35ed					if DEBUG_FORTH_WORDS_KEY 
35ed						DMARK "R16" 
35ed f5				push af  
35ee 3a 02 36			ld a, (.dmark)  
35f1 32 71 ee			ld (debug_mark),a  
35f4 3a 03 36			ld a, (.dmark+1)  
35f7 32 72 ee			ld (debug_mark+1),a  
35fa 3a 04 36			ld a, (.dmark+2)  
35fd 32 73 ee			ld (debug_mark+2),a  
3600 18 03			jr .pastdmark  
3602 ..			.dmark: db "R16"  
3605 f1			.pastdmark: pop af  
3606			endm  
# End of macro DMARK
3606						CALLMONITOR 
3606 cd ae 13			call break_point_state  
3609				endm  
# End of macro CALLMONITOR
3609					endif 
3609 cd d4 0a				call prng16  
360c cd 08 1a				call forth_push_numhl 
360f				       NEXTW 
360f c3 71 1d			jp macro_next 
3612				endm 
# End of macro NEXTW
3612			.RND8: 
3612				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3612 60				db WORD_SYS_CORE+76             
3613 47 36			dw .RND            
3615 05				db 4 + 1 
3616 .. 00			db "RND8",0              
361b				endm 
# End of macro CWHEAD
361b			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
361b					if DEBUG_FORTH_WORDS_KEY 
361b						DMARK "RN8" 
361b f5				push af  
361c 3a 30 36			ld a, (.dmark)  
361f 32 71 ee			ld (debug_mark),a  
3622 3a 31 36			ld a, (.dmark+1)  
3625 32 72 ee			ld (debug_mark+1),a  
3628 3a 32 36			ld a, (.dmark+2)  
362b 32 73 ee			ld (debug_mark+2),a  
362e 18 03			jr .pastdmark  
3630 ..			.dmark: db "RN8"  
3633 f1			.pastdmark: pop af  
3634			endm  
# End of macro DMARK
3634						CALLMONITOR 
3634 cd ae 13			call break_point_state  
3637				endm  
# End of macro CALLMONITOR
3637					endif 
3637 2a b2 eb				ld hl,(xrandc) 
363a 23					inc hl 
363b cd ee 0a				call xrnd 
363e 6f					ld l,a	 
363f 26 00				ld h,0 
3641 cd 08 1a				call forth_push_numhl 
3644				       NEXTW 
3644 c3 71 1d			jp macro_next 
3647				endm 
# End of macro NEXTW
3647			.RND: 
3647				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3647 60				db WORD_SYS_CORE+76             
3648 4d 37			dw .ENDMATHS            
364a 04				db 3 + 1 
364b .. 00			db "RND",0              
364f				endm 
# End of macro CWHEAD
364f			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
364f			 
364f					if DEBUG_FORTH_WORDS_KEY 
364f						DMARK "RND" 
364f f5				push af  
3650 3a 64 36			ld a, (.dmark)  
3653 32 71 ee			ld (debug_mark),a  
3656 3a 65 36			ld a, (.dmark+1)  
3659 32 72 ee			ld (debug_mark+1),a  
365c 3a 66 36			ld a, (.dmark+2)  
365f 32 73 ee			ld (debug_mark+2),a  
3662 18 03			jr .pastdmark  
3664 ..			.dmark: db "RND"  
3667 f1			.pastdmark: pop af  
3668			endm  
# End of macro DMARK
3668						CALLMONITOR 
3668 cd ae 13			call break_point_state  
366b				endm  
# End of macro CALLMONITOR
366b					endif 
366b					 
366b					FORTH_DSP_VALUEHL    ; upper range 
366b cd ff 1b			call macro_dsp_valuehl 
366e				endm 
# End of macro FORTH_DSP_VALUEHL
366e			 
366e 22 b6 eb				ld (LFSRSeed), hl	 
3671			 
3671					if DEBUG_FORTH_WORDS 
3671						DMARK "RN1" 
3671 f5				push af  
3672 3a 86 36			ld a, (.dmark)  
3675 32 71 ee			ld (debug_mark),a  
3678 3a 87 36			ld a, (.dmark+1)  
367b 32 72 ee			ld (debug_mark+1),a  
367e 3a 88 36			ld a, (.dmark+2)  
3681 32 73 ee			ld (debug_mark+2),a  
3684 18 03			jr .pastdmark  
3686 ..			.dmark: db "RN1"  
3689 f1			.pastdmark: pop af  
368a			endm  
# End of macro DMARK
368a						CALLMONITOR 
368a cd ae 13			call break_point_state  
368d				endm  
# End of macro CALLMONITOR
368d					endif 
368d					FORTH_DSP_POP 
368d cd b7 1c			call macro_forth_dsp_pop 
3690				endm 
# End of macro FORTH_DSP_POP
3690			 
3690					FORTH_DSP_VALUEHL    ; low range 
3690 cd ff 1b			call macro_dsp_valuehl 
3693				endm 
# End of macro FORTH_DSP_VALUEHL
3693			 
3693					if DEBUG_FORTH_WORDS 
3693						DMARK "RN2" 
3693 f5				push af  
3694 3a a8 36			ld a, (.dmark)  
3697 32 71 ee			ld (debug_mark),a  
369a 3a a9 36			ld a, (.dmark+1)  
369d 32 72 ee			ld (debug_mark+1),a  
36a0 3a aa 36			ld a, (.dmark+2)  
36a3 32 73 ee			ld (debug_mark+2),a  
36a6 18 03			jr .pastdmark  
36a8 ..			.dmark: db "RN2"  
36ab f1			.pastdmark: pop af  
36ac			endm  
# End of macro DMARK
36ac						CALLMONITOR 
36ac cd ae 13			call break_point_state  
36af				endm  
# End of macro CALLMONITOR
36af					endif 
36af 22 b8 eb				ld (LFSRSeed+2), hl 
36b2			 
36b2					FORTH_DSP_POP 
36b2 cd b7 1c			call macro_forth_dsp_pop 
36b5				endm 
# End of macro FORTH_DSP_POP
36b5			 
36b5 e5					push hl 
36b6			 
36b6 e1			.inrange:	pop hl 
36b7 cd d4 0a				call prng16  
36ba					if DEBUG_FORTH_WORDS 
36ba						DMARK "RN3" 
36ba f5				push af  
36bb 3a cf 36			ld a, (.dmark)  
36be 32 71 ee			ld (debug_mark),a  
36c1 3a d0 36			ld a, (.dmark+1)  
36c4 32 72 ee			ld (debug_mark+1),a  
36c7 3a d1 36			ld a, (.dmark+2)  
36ca 32 73 ee			ld (debug_mark+2),a  
36cd 18 03			jr .pastdmark  
36cf ..			.dmark: db "RN3"  
36d2 f1			.pastdmark: pop af  
36d3			endm  
# End of macro DMARK
36d3						CALLMONITOR 
36d3 cd ae 13			call break_point_state  
36d6				endm  
# End of macro CALLMONITOR
36d6					endif 
36d6					 
36d6					; if the range is 8bit knock out the high byte 
36d6			 
36d6 ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
36da			 
36da 3e 00				ld a, 0 
36dc ba					cp d  
36dd 20 1e				jr nz, .hirange 
36df 26 00				ld h, 0   ; knock it down to 8bit 
36e1			 
36e1					if DEBUG_FORTH_WORDS 
36e1						DMARK "RNk" 
36e1 f5				push af  
36e2 3a f6 36			ld a, (.dmark)  
36e5 32 71 ee			ld (debug_mark),a  
36e8 3a f7 36			ld a, (.dmark+1)  
36eb 32 72 ee			ld (debug_mark+1),a  
36ee 3a f8 36			ld a, (.dmark+2)  
36f1 32 73 ee			ld (debug_mark+2),a  
36f4 18 03			jr .pastdmark  
36f6 ..			.dmark: db "RNk"  
36f9 f1			.pastdmark: pop af  
36fa			endm  
# End of macro DMARK
36fa						CALLMONITOR 
36fa cd ae 13			call break_point_state  
36fd				endm  
# End of macro CALLMONITOR
36fd					endif 
36fd			.hirange:   
36fd e5					push hl  
36fe b7					or a  
36ff ed 52		                sbc hl, de 
3701			 
3701					;call cmp16 
3701			 
3701 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3703 e1					pop hl 
3704 e5					push hl 
3705			 
3705					if DEBUG_FORTH_WORDS 
3705						DMARK "RN4" 
3705 f5				push af  
3706 3a 1a 37			ld a, (.dmark)  
3709 32 71 ee			ld (debug_mark),a  
370c 3a 1b 37			ld a, (.dmark+1)  
370f 32 72 ee			ld (debug_mark+1),a  
3712 3a 1c 37			ld a, (.dmark+2)  
3715 32 73 ee			ld (debug_mark+2),a  
3718 18 03			jr .pastdmark  
371a ..			.dmark: db "RN4"  
371d f1			.pastdmark: pop af  
371e			endm  
# End of macro DMARK
371e						CALLMONITOR 
371e cd ae 13			call break_point_state  
3721				endm  
# End of macro CALLMONITOR
3721					endif 
3721 ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
3725					;call cmp16 
3725				 
3725 b7					or a  
3726 ed 52		                sbc hl, de 
3728 38 8c				jr c, .inrange 
372a			 
372a e1					pop hl 
372b					 
372b					if DEBUG_FORTH_WORDS 
372b						DMARK "RNd" 
372b f5				push af  
372c 3a 40 37			ld a, (.dmark)  
372f 32 71 ee			ld (debug_mark),a  
3732 3a 41 37			ld a, (.dmark+1)  
3735 32 72 ee			ld (debug_mark+1),a  
3738 3a 42 37			ld a, (.dmark+2)  
373b 32 73 ee			ld (debug_mark+2),a  
373e 18 03			jr .pastdmark  
3740 ..			.dmark: db "RNd"  
3743 f1			.pastdmark: pop af  
3744			endm  
# End of macro DMARK
3744						CALLMONITOR 
3744 cd ae 13			call break_point_state  
3747				endm  
# End of macro CALLMONITOR
3747					endif 
3747			 
3747			 
3747 cd 08 1a				call forth_push_numhl 
374a				       NEXTW 
374a c3 71 1d			jp macro_next 
374d				endm 
# End of macro NEXTW
374d			 
374d			.ENDMATHS: 
374d			 
374d			; eof 
374d			 
# End of file forth_words_maths.asm
374d			include "forth_words_display.asm" 
374d			 
374d			; | ## Display Words 
374d			 
374d			.INFO: 
374d			 
374d				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
374d 62				db WORD_SYS_CORE+78             
374e 6a 37			dw .ATP            
3750 05				db 4 + 1 
3751 .. 00			db "INFO",0              
3756				endm 
# End of macro CWHEAD
3756			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3756					FORTH_DSP_VALUEHL 
3756 cd ff 1b			call macro_dsp_valuehl 
3759				endm 
# End of macro FORTH_DSP_VALUEHL
3759			 
3759					FORTH_DSP_POP 
3759 cd b7 1c			call macro_forth_dsp_pop 
375c				endm 
# End of macro FORTH_DSP_POP
375c			 
375c e5					push hl 
375d			 
375d					FORTH_DSP_VALUEHL 
375d cd ff 1b			call macro_dsp_valuehl 
3760				endm 
# End of macro FORTH_DSP_VALUEHL
3760			 
3760					FORTH_DSP_POP 
3760 cd b7 1c			call macro_forth_dsp_pop 
3763				endm 
# End of macro FORTH_DSP_POP
3763			 
3763 d1					pop de 
3764			 
3764 cd 11 09				call info_panel 
3767			 
3767			 
3767					NEXTW 
3767 c3 71 1d			jp macro_next 
376a				endm 
# End of macro NEXTW
376a			.ATP: 
376a				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
376a 62				db WORD_SYS_CORE+78             
376b e1 37			dw .FB            
376d 04				db 3 + 1 
376e .. 00			db "AT?",0              
3772				endm 
# End of macro CWHEAD
3772			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3772					if DEBUG_FORTH_WORDS_KEY 
3772						DMARK "AT?" 
3772 f5				push af  
3773 3a 87 37			ld a, (.dmark)  
3776 32 71 ee			ld (debug_mark),a  
3779 3a 88 37			ld a, (.dmark+1)  
377c 32 72 ee			ld (debug_mark+1),a  
377f 3a 89 37			ld a, (.dmark+2)  
3782 32 73 ee			ld (debug_mark+2),a  
3785 18 03			jr .pastdmark  
3787 ..			.dmark: db "AT?"  
378a f1			.pastdmark: pop af  
378b			endm  
# End of macro DMARK
378b						CALLMONITOR 
378b cd ae 13			call break_point_state  
378e				endm  
# End of macro CALLMONITOR
378e					endif 
378e 3a 40 eb				ld a, (f_cursor_ptr) 
3791			 
3791			if DEBUG_FORTH_WORDS 
3791				DMARK "AT?" 
3791 f5				push af  
3792 3a a6 37			ld a, (.dmark)  
3795 32 71 ee			ld (debug_mark),a  
3798 3a a7 37			ld a, (.dmark+1)  
379b 32 72 ee			ld (debug_mark+1),a  
379e 3a a8 37			ld a, (.dmark+2)  
37a1 32 73 ee			ld (debug_mark+2),a  
37a4 18 03			jr .pastdmark  
37a6 ..			.dmark: db "AT?"  
37a9 f1			.pastdmark: pop af  
37aa			endm  
# End of macro DMARK
37aa				CALLMONITOR 
37aa cd ae 13			call break_point_state  
37ad				endm  
# End of macro CALLMONITOR
37ad			endif	 
37ad					; count the number of rows 
37ad			 
37ad 06 00				ld b, 0 
37af 4f			.atpr:		ld c, a    ; save in case we go below zero 
37b0 d6 28				sub display_cols 
37b2 f2 b8 37				jp p, .atprunder 
37b5 04					inc b 
37b6 18 f7				jr .atpr 
37b8			.atprunder:	 
37b8			if DEBUG_FORTH_WORDS 
37b8				DMARK "A?2" 
37b8 f5				push af  
37b9 3a cd 37			ld a, (.dmark)  
37bc 32 71 ee			ld (debug_mark),a  
37bf 3a ce 37			ld a, (.dmark+1)  
37c2 32 72 ee			ld (debug_mark+1),a  
37c5 3a cf 37			ld a, (.dmark+2)  
37c8 32 73 ee			ld (debug_mark+2),a  
37cb 18 03			jr .pastdmark  
37cd ..			.dmark: db "A?2"  
37d0 f1			.pastdmark: pop af  
37d1			endm  
# End of macro DMARK
37d1				CALLMONITOR 
37d1 cd ae 13			call break_point_state  
37d4				endm  
# End of macro CALLMONITOR
37d4			endif	 
37d4 26 00				ld h, 0 
37d6 69					ld l, c 
37d7 cd 08 1a				call forth_push_numhl 
37da 68					ld l, b  
37db cd 08 1a				call forth_push_numhl 
37de			 
37de			 
37de				NEXTW 
37de c3 71 1d			jp macro_next 
37e1				endm 
# End of macro NEXTW
37e1			 
37e1			.FB: 
37e1				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
37e1 1b				db WORD_SYS_CORE+7             
37e2 2f 38			dw .EMIT            
37e4 03				db 2 + 1 
37e5 .. 00			db "FB",0              
37e8				endm 
# End of macro CWHEAD
37e8			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
37e8			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
37e8			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
37e8			; | | If automatic display is off then updates will not be shown until DRAW is used. 
37e8					if DEBUG_FORTH_WORDS_KEY 
37e8						DMARK "FB." 
37e8 f5				push af  
37e9 3a fd 37			ld a, (.dmark)  
37ec 32 71 ee			ld (debug_mark),a  
37ef 3a fe 37			ld a, (.dmark+1)  
37f2 32 72 ee			ld (debug_mark+1),a  
37f5 3a ff 37			ld a, (.dmark+2)  
37f8 32 73 ee			ld (debug_mark+2),a  
37fb 18 03			jr .pastdmark  
37fd ..			.dmark: db "FB."  
3800 f1			.pastdmark: pop af  
3801			endm  
# End of macro DMARK
3801						CALLMONITOR 
3801 cd ae 13			call break_point_state  
3804				endm  
# End of macro CALLMONITOR
3804					endif 
3804			 
3804					FORTH_DSP_VALUEHL 
3804 cd ff 1b			call macro_dsp_valuehl 
3807				endm 
# End of macro FORTH_DSP_VALUEHL
3807			 
3807 7d					ld a, l 
3808 fe 01				cp 1 
380a 20 05				jr nz, .fbn1 
380c 21 16 ed				ld hl, display_fb1 
380f 18 15				jr .fbset 
3811 fe 02		.fbn1:		cp 2 
3813 20 05				jr nz, .fbn2 
3815 21 d4 eb				ld hl, display_fb2 
3818 18 0c				jr .fbset 
381a fe 03		.fbn2:		cp 3 
381c 20 05				jr nz, .fbn3 
381e 21 75 ec				ld hl, display_fb3 
3821 18 03				jr .fbset 
3823			.fbn3:		 ; if invalid number select first 
3823 21 16 ed				ld hl, display_fb1 
3826 22 d2 eb		.fbset:		ld (display_fb_active), hl 
3829			 
3829					FORTH_DSP_POP 
3829 cd b7 1c			call macro_forth_dsp_pop 
382c				endm 
# End of macro FORTH_DSP_POP
382c			 
382c					NEXTW 
382c c3 71 1d			jp macro_next 
382f				endm 
# End of macro NEXTW
382f			 
382f			 
382f			.EMIT: 
382f				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
382f 1b				db WORD_SYS_CORE+7             
3830 80 38			dw .DOTH            
3832 05				db 4 + 1 
3833 .. 00			db "EMIT",0              
3838				endm 
# End of macro CWHEAD
3838			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3838					; get value off TOS and display it 
3838			 
3838					if DEBUG_FORTH_WORDS_KEY 
3838						DMARK "EMT" 
3838 f5				push af  
3839 3a 4d 38			ld a, (.dmark)  
383c 32 71 ee			ld (debug_mark),a  
383f 3a 4e 38			ld a, (.dmark+1)  
3842 32 72 ee			ld (debug_mark+1),a  
3845 3a 4f 38			ld a, (.dmark+2)  
3848 32 73 ee			ld (debug_mark+2),a  
384b 18 03			jr .pastdmark  
384d ..			.dmark: db "EMT"  
3850 f1			.pastdmark: pop af  
3851			endm  
# End of macro DMARK
3851						CALLMONITOR 
3851 cd ae 13			call break_point_state  
3854				endm  
# End of macro CALLMONITOR
3854					endif 
3854			 
3854					FORTH_DSP_VALUEHL 
3854 cd ff 1b			call macro_dsp_valuehl 
3857				endm 
# End of macro FORTH_DSP_VALUEHL
3857			 
3857 7d					ld a,l 
3858			 
3858					; TODO write to display 
3858			 
3858 32 55 e5				ld (os_input), a 
385b 3e 00				ld a, 0 
385d 32 56 e5				ld (os_input+1), a 
3860					 
3860 3a 40 eb				ld a, (f_cursor_ptr) 
3863 11 55 e5				ld de, os_input 
3866 cd 93 09				call str_at_display 
3869			 
3869			 
3869 3a 1e eb				ld a,(cli_autodisplay) 
386c fe 00				cp 0 
386e 28 03				jr z, .enoupdate 
3870 cd a3 09						call update_display 
3873					.enoupdate: 
3873			 
3873 3a 40 eb				ld a, (f_cursor_ptr) 
3876 3c					inc a 
3877 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
387a			 
387a			 
387a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
387a cd b7 1c			call macro_forth_dsp_pop 
387d				endm 
# End of macro FORTH_DSP_POP
387d			  
387d			 
387d					NEXTW 
387d c3 71 1d			jp macro_next 
3880				endm 
# End of macro NEXTW
3880			.DOTH: 
3880				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3880 1c				db WORD_SYS_CORE+8             
3881 b0 38			dw .DOTF            
3883 03				db 2 + 1 
3884 .. 00			db ".-",0              
3887				endm 
# End of macro CWHEAD
3887			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3887					; get value off TOS and display it 
3887					if DEBUG_FORTH_WORDS_KEY 
3887						DMARK "DTD" 
3887 f5				push af  
3888 3a 9c 38			ld a, (.dmark)  
388b 32 71 ee			ld (debug_mark),a  
388e 3a 9d 38			ld a, (.dmark+1)  
3891 32 72 ee			ld (debug_mark+1),a  
3894 3a 9e 38			ld a, (.dmark+2)  
3897 32 73 ee			ld (debug_mark+2),a  
389a 18 03			jr .pastdmark  
389c ..			.dmark: db "DTD"  
389f f1			.pastdmark: pop af  
38a0			endm  
# End of macro DMARK
38a0						CALLMONITOR 
38a0 cd ae 13			call break_point_state  
38a3				endm  
# End of macro CALLMONITOR
38a3					endif 
38a3 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
38a5 3e 00			ld a, 0 
38a7 32 1f eb			ld (cli_mvdot), a 
38aa c3 07 39			jp .dotgo 
38ad				NEXTW 
38ad c3 71 1d			jp macro_next 
38b0				endm 
# End of macro NEXTW
38b0			.DOTF: 
38b0				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
38b0 1c				db WORD_SYS_CORE+8             
38b1 de 38			dw .DOT            
38b3 03				db 2 + 1 
38b4 .. 00			db ".>",0              
38b7				endm 
# End of macro CWHEAD
38b7			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
38b7					; get value off TOS and display it 
38b7			        ; TODO BUG adds extra spaces 
38b7			        ; TODO BUG handle numerics? 
38b7					if DEBUG_FORTH_WORDS_KEY 
38b7						DMARK "DTC" 
38b7 f5				push af  
38b8 3a cc 38			ld a, (.dmark)  
38bb 32 71 ee			ld (debug_mark),a  
38be 3a cd 38			ld a, (.dmark+1)  
38c1 32 72 ee			ld (debug_mark+1),a  
38c4 3a ce 38			ld a, (.dmark+2)  
38c7 32 73 ee			ld (debug_mark+2),a  
38ca 18 03			jr .pastdmark  
38cc ..			.dmark: db "DTC"  
38cf f1			.pastdmark: pop af  
38d0			endm  
# End of macro DMARK
38d0						CALLMONITOR 
38d0 cd ae 13			call break_point_state  
38d3				endm  
# End of macro CALLMONITOR
38d3					endif 
38d3 3e 01			ld a, 1 
38d5 32 1f eb			ld (cli_mvdot), a 
38d8 c3 07 39			jp .dotgo 
38db				NEXTW 
38db c3 71 1d			jp macro_next 
38de				endm 
# End of macro NEXTW
38de			 
38de			.DOT: 
38de				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
38de 1c				db WORD_SYS_CORE+8             
38df 6a 39			dw .CLS            
38e1 02				db 1 + 1 
38e2 .. 00			db ".",0              
38e4				endm 
# End of macro CWHEAD
38e4			        ; | . ( u -- ) Display TOS | DONE 
38e4					; get value off TOS and display it 
38e4			 
38e4					if DEBUG_FORTH_WORDS_KEY 
38e4						DMARK "DOT" 
38e4 f5				push af  
38e5 3a f9 38			ld a, (.dmark)  
38e8 32 71 ee			ld (debug_mark),a  
38eb 3a fa 38			ld a, (.dmark+1)  
38ee 32 72 ee			ld (debug_mark+1),a  
38f1 3a fb 38			ld a, (.dmark+2)  
38f4 32 73 ee			ld (debug_mark+2),a  
38f7 18 03			jr .pastdmark  
38f9 ..			.dmark: db "DOT"  
38fc f1			.pastdmark: pop af  
38fd			endm  
# End of macro DMARK
38fd						CALLMONITOR 
38fd cd ae 13			call break_point_state  
3900				endm  
# End of macro CALLMONITOR
3900					endif 
3900 3e 00			ld a, 0 
3902 32 1f eb			ld (cli_mvdot), a 
3905 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3907				 
3907			 
3907			.dotgo: 
3907			 
3907			; move up type to on stack for parserv5 
3907					FORTH_DSP 
3907 cd c5 1b			call macro_forth_dsp 
390a				endm 
# End of macro FORTH_DSP
390a				;FORTH_DSP_VALUE  
390a			 
390a			if DEBUG_FORTH_DOT 
390a				DMARK "DOT" 
390a				CALLMONITOR 
390a			endif	 
390a			;		.print: 
390a			 
390a 7e				ld a,(hl)  ; work out what type of value is on the TOS 
390b 23				inc hl   ; position to the actual value 
390c fe 01			cp DS_TYPE_STR 
390e 20 06			jr nz, .dotnum1  
3910			 
3910			; display string 
3910				FORTH_DSP_VALUE  
3910 cd e8 1b			call macro_forth_dsp_value 
3913				endm 
# End of macro FORTH_DSP_VALUE
3913 eb				ex de,hl 
3914 18 11			jr .dotwrite 
3916			 
3916			.dotnum1: 
3916 fe 02			cp DS_TYPE_INUM 
3918 20 0c			jr nz, .dotflot 
391a			 
391a			 
391a			; display number 
391a			 
391a			;	push hl 
391a			;	call clear_display 
391a			;	pop hl 
391a			 
391a 5e				ld e, (hl) 
391b 23				inc hl 
391c 56				ld d, (hl) 
391d 21 57 e3			ld hl, scratch 
3920			if DEBUG_FORTH_DOT 
3920				DMARK "DT1" 
3920				CALLMONITOR 
3920			endif	 
3920			 
3920 cd ba 0f			call uitoa_16 
3923 eb				ex de,hl 
3924			 
3924			if DEBUG_FORTH_DOT 
3924				DMARK "DT2" 
3924				CALLMONITOR 
3924			endif	 
3924			 
3924			;	ld de, os_word_scratch 
3924 18 01			jr .dotwrite 
3926			 
3926 00			.dotflot:   nop 
3927			; TODO print floating point number 
3927			 
3927			.dotwrite:		 
3927			 
3927					; if c is set then set all '-' to spaces 
3927					; need to also take into account .>  
3927			 
3927 3e 01				ld a, 1 
3929 b9					cp c 
392a 20 13				jr nz, .nodashswap 
392c			 
392c					; DE has the string to write, working with HL 
392c			 
392c 06 ff				ld b, 255 
392e d5					push de 
392f e1					pop hl 
3930			 
3930			if DEBUG_FORTH_DOT 
3930				DMARK "DT-" 
3930				CALLMONITOR 
3930			endif	 
3930 7e			.dashscan:	ld a, (hl) 
3931 fe 00				cp 0 
3933 28 0a				jr z, .nodashswap 
3935 fe 2d				cp '-' 
3937 20 03				jr nz, .dashskip 
3939 3e 20				ld a, ' ' 
393b 77					ld (hl), a 
393c 23			.dashskip:	inc hl 
393d			if DEBUG_FORTH_DOT 
393d				DMARK "D-2" 
393d				CALLMONITOR 
393d			endif	 
393d 10 f1				djnz .dashscan 
393f			 
393f			if DEBUG_FORTH_DOT 
393f				DMARK "D-1" 
393f				CALLMONITOR 
393f			endif	 
393f			 
393f			.nodashswap: 
393f			 
393f e5					push hl   ; save string start in case we need to advance print 
3940			 
3940 3a 40 eb				ld a, (f_cursor_ptr) 
3943 cd 93 09				call str_at_display 
3946 3a 1e eb				ld a,(cli_autodisplay) 
3949 fe 00				cp 0 
394b 28 03				jr z, .noupdate 
394d cd a3 09						call update_display 
3950					.noupdate: 
3950			 
3950			 
3950					; see if we need to advance the print position 
3950			 
3950 e1					pop hl   ; get back string 
3951			 
3951 3a 1f eb				ld a, (cli_mvdot) 
3954			if DEBUG_FORTH_DOT 
3954					ld e,a 
3954				DMARK "D>1" 
3954				CALLMONITOR 
3954			endif	 
3954 fe 00				cp 0 
3956 28 0c				jr z, .noadv 
3958					; yes, lets advance the print position 
3958 3e 00				ld a, 0 
395a cd 16 10				call strlent 
395d 3a 40 eb				ld a, (f_cursor_ptr) 
3960 85					add a,l 
3961					;call addatohl 
3961					;ld a, l 
3961 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
3964			 
3964			if DEBUG_FORTH_DOT 
3964				DMARK "D->" 
3964				CALLMONITOR 
3964			endif	 
3964			 
3964			.noadv:	 
3964			 
3964					if DEBUG_FORTH_DOT_WAIT 
3964							call next_page_prompt 
3964					endif	 
3964			; TODO this pop off the stack causes a crash. i dont know why 
3964			 
3964			 
3964			if DEBUG_FORTH_DOT 
3964				DMARK "DTh" 
3964				CALLMONITOR 
3964			endif	 
3964			 
3964					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3964 cd b7 1c			call macro_forth_dsp_pop 
3967				endm 
# End of macro FORTH_DSP_POP
3967			 
3967			if DEBUG_FORTH_DOT 
3967				DMARK "DTi" 
3967				CALLMONITOR 
3967			endif	 
3967			 
3967			 
3967					NEXTW 
3967 c3 71 1d			jp macro_next 
396a				endm 
# End of macro NEXTW
396a			 
396a			.CLS: 
396a				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
396a 35				db WORD_SYS_CORE+33             
396b 97 39			dw .DRAW            
396d 04				db 3 + 1 
396e .. 00			db "CLS",0              
3972				endm 
# End of macro CWHEAD
3972			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3972					if DEBUG_FORTH_WORDS_KEY 
3972						DMARK "CLS" 
3972 f5				push af  
3973 3a 87 39			ld a, (.dmark)  
3976 32 71 ee			ld (debug_mark),a  
3979 3a 88 39			ld a, (.dmark+1)  
397c 32 72 ee			ld (debug_mark+1),a  
397f 3a 89 39			ld a, (.dmark+2)  
3982 32 73 ee			ld (debug_mark+2),a  
3985 18 03			jr .pastdmark  
3987 ..			.dmark: db "CLS"  
398a f1			.pastdmark: pop af  
398b			endm  
# End of macro DMARK
398b						CALLMONITOR 
398b cd ae 13			call break_point_state  
398e				endm  
# End of macro CALLMONITOR
398e					endif 
398e cd 80 09				call clear_display 
3991 c3 a5 3a				jp .home		; and home cursor 
3994					NEXTW 
3994 c3 71 1d			jp macro_next 
3997				endm 
# End of macro NEXTW
3997			 
3997			.DRAW: 
3997				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3997 36				db WORD_SYS_CORE+34             
3998 c2 39			dw .DUMP            
399a 05				db 4 + 1 
399b .. 00			db "DRAW",0              
39a0				endm 
# End of macro CWHEAD
39a0			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
39a0					if DEBUG_FORTH_WORDS_KEY 
39a0						DMARK "DRW" 
39a0 f5				push af  
39a1 3a b5 39			ld a, (.dmark)  
39a4 32 71 ee			ld (debug_mark),a  
39a7 3a b6 39			ld a, (.dmark+1)  
39aa 32 72 ee			ld (debug_mark+1),a  
39ad 3a b7 39			ld a, (.dmark+2)  
39b0 32 73 ee			ld (debug_mark+2),a  
39b3 18 03			jr .pastdmark  
39b5 ..			.dmark: db "DRW"  
39b8 f1			.pastdmark: pop af  
39b9			endm  
# End of macro DMARK
39b9						CALLMONITOR 
39b9 cd ae 13			call break_point_state  
39bc				endm  
# End of macro CALLMONITOR
39bc					endif 
39bc cd a3 09				call update_display 
39bf					NEXTW 
39bf c3 71 1d			jp macro_next 
39c2				endm 
# End of macro NEXTW
39c2			 
39c2			.DUMP: 
39c2				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
39c2 37				db WORD_SYS_CORE+35             
39c3 fa 39			dw .CDUMP            
39c5 05				db 4 + 1 
39c6 .. 00			db "DUMP",0              
39cb				endm 
# End of macro CWHEAD
39cb			; | DUMP ( x -- ) With address x display dump   | DONE 
39cb			; TODO pop address to use off of the stack 
39cb					if DEBUG_FORTH_WORDS_KEY 
39cb						DMARK "DUM" 
39cb f5				push af  
39cc 3a e0 39			ld a, (.dmark)  
39cf 32 71 ee			ld (debug_mark),a  
39d2 3a e1 39			ld a, (.dmark+1)  
39d5 32 72 ee			ld (debug_mark+1),a  
39d8 3a e2 39			ld a, (.dmark+2)  
39db 32 73 ee			ld (debug_mark+2),a  
39de 18 03			jr .pastdmark  
39e0 ..			.dmark: db "DUM"  
39e3 f1			.pastdmark: pop af  
39e4			endm  
# End of macro DMARK
39e4						CALLMONITOR 
39e4 cd ae 13			call break_point_state  
39e7				endm  
# End of macro CALLMONITOR
39e7					endif 
39e7 cd 80 09				call clear_display 
39ea			 
39ea					; get address 
39ea			 
39ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ea cd ff 1b			call macro_dsp_valuehl 
39ed				endm 
# End of macro FORTH_DSP_VALUEHL
39ed				 
39ed					; save it for cdump 
39ed			 
39ed 22 7a e6				ld (os_cur_ptr),hl 
39f0			 
39f0					; destroy value TOS 
39f0			 
39f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f0 cd b7 1c			call macro_forth_dsp_pop 
39f3				endm 
# End of macro FORTH_DSP_POP
39f3			 
39f3 cd 88 18				call dumpcont	; skip old style of param parsing	 
39f6 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
39f7					NEXTW 
39f7 c3 71 1d			jp macro_next 
39fa				endm 
# End of macro NEXTW
39fa			.CDUMP: 
39fa				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
39fa 38				db WORD_SYS_CORE+36             
39fb 2a 3a			dw .DAT            
39fd 06				db 5 + 1 
39fe .. 00			db "CDUMP",0              
3a04				endm 
# End of macro CWHEAD
3a04			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3a04					if DEBUG_FORTH_WORDS_KEY 
3a04						DMARK "CDP" 
3a04 f5				push af  
3a05 3a 19 3a			ld a, (.dmark)  
3a08 32 71 ee			ld (debug_mark),a  
3a0b 3a 1a 3a			ld a, (.dmark+1)  
3a0e 32 72 ee			ld (debug_mark+1),a  
3a11 3a 1b 3a			ld a, (.dmark+2)  
3a14 32 73 ee			ld (debug_mark+2),a  
3a17 18 03			jr .pastdmark  
3a19 ..			.dmark: db "CDP"  
3a1c f1			.pastdmark: pop af  
3a1d			endm  
# End of macro DMARK
3a1d						CALLMONITOR 
3a1d cd ae 13			call break_point_state  
3a20				endm  
# End of macro CALLMONITOR
3a20					endif 
3a20 cd 80 09				call clear_display 
3a23 cd 88 18				call dumpcont	 
3a26 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3a27					NEXTW 
3a27 c3 71 1d			jp macro_next 
3a2a				endm 
# End of macro NEXTW
3a2a			 
3a2a			 
3a2a			 
3a2a			 
3a2a			.DAT: 
3a2a				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3a2a 3d				db WORD_SYS_CORE+41             
3a2b 80 3a			dw .HOME            
3a2d 03				db 2 + 1 
3a2e .. 00			db "AT",0              
3a31				endm 
# End of macro CWHEAD
3a31			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3a31					if DEBUG_FORTH_WORDS_KEY 
3a31						DMARK "AT." 
3a31 f5				push af  
3a32 3a 46 3a			ld a, (.dmark)  
3a35 32 71 ee			ld (debug_mark),a  
3a38 3a 47 3a			ld a, (.dmark+1)  
3a3b 32 72 ee			ld (debug_mark+1),a  
3a3e 3a 48 3a			ld a, (.dmark+2)  
3a41 32 73 ee			ld (debug_mark+2),a  
3a44 18 03			jr .pastdmark  
3a46 ..			.dmark: db "AT."  
3a49 f1			.pastdmark: pop af  
3a4a			endm  
# End of macro DMARK
3a4a						CALLMONITOR 
3a4a cd ae 13			call break_point_state  
3a4d				endm  
# End of macro CALLMONITOR
3a4d					endif 
3a4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a4d cd ff 1b			call macro_dsp_valuehl 
3a50				endm 
# End of macro FORTH_DSP_VALUEHL
3a50			 
3a50			 
3a50					; TODO save cursor row 
3a50 7d					ld a,l 
3a51 fe 02				cp 2 
3a53 20 04				jr nz, .crow3 
3a55 3e 28				ld a, display_row_2 
3a57 18 12				jr .ccol1 
3a59 fe 03		.crow3:		cp 3 
3a5b 20 04				jr nz, .crow4 
3a5d 3e 50				ld a, display_row_3 
3a5f 18 0a				jr .ccol1 
3a61 fe 04		.crow4:		cp 4 
3a63 20 04				jr nz, .crow1 
3a65 3e 78				ld a, display_row_4 
3a67 18 02				jr .ccol1 
3a69 3e 00		.crow1:		ld a,display_row_1 
3a6b f5			.ccol1:		push af			; got row offset 
3a6c 6f					ld l,a 
3a6d 26 00				ld h,0 
3a6f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a6f cd b7 1c			call macro_forth_dsp_pop 
3a72				endm 
# End of macro FORTH_DSP_POP
3a72					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a72 cd ff 1b			call macro_dsp_valuehl 
3a75				endm 
# End of macro FORTH_DSP_VALUEHL
3a75					; TODO save cursor col 
3a75 f1					pop af 
3a76 85					add l		; add col offset 
3a77 32 40 eb				ld (f_cursor_ptr), a 
3a7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a7a cd b7 1c			call macro_forth_dsp_pop 
3a7d				endm 
# End of macro FORTH_DSP_POP
3a7d			 
3a7d					; calculate  
3a7d			 
3a7d					NEXTW 
3a7d c3 71 1d			jp macro_next 
3a80				endm 
# End of macro NEXTW
3a80			 
3a80			 
3a80			.HOME: 
3a80				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3a80 41				db WORD_SYS_CORE+45             
3a81 ad 3a			dw .SPACE            
3a83 05				db 4 + 1 
3a84 .. 00			db "HOME",0              
3a89				endm 
# End of macro CWHEAD
3a89			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3a89					if DEBUG_FORTH_WORDS_KEY 
3a89						DMARK "HOM" 
3a89 f5				push af  
3a8a 3a 9e 3a			ld a, (.dmark)  
3a8d 32 71 ee			ld (debug_mark),a  
3a90 3a 9f 3a			ld a, (.dmark+1)  
3a93 32 72 ee			ld (debug_mark+1),a  
3a96 3a a0 3a			ld a, (.dmark+2)  
3a99 32 73 ee			ld (debug_mark+2),a  
3a9c 18 03			jr .pastdmark  
3a9e ..			.dmark: db "HOM"  
3aa1 f1			.pastdmark: pop af  
3aa2			endm  
# End of macro DMARK
3aa2						CALLMONITOR 
3aa2 cd ae 13			call break_point_state  
3aa5				endm  
# End of macro CALLMONITOR
3aa5					endif 
3aa5 3e 00		.home:		ld a, 0		; and home cursor 
3aa7 32 40 eb				ld (f_cursor_ptr), a 
3aaa					NEXTW 
3aaa c3 71 1d			jp macro_next 
3aad				endm 
# End of macro NEXTW
3aad			 
3aad			 
3aad			.SPACE: 
3aad				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3aad 46				db WORD_SYS_CORE+50             
3aae db 3a			dw .SPACES            
3ab0 03				db 2 + 1 
3ab1 .. 00			db "BL",0              
3ab4				endm 
# End of macro CWHEAD
3ab4			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3ab4					if DEBUG_FORTH_WORDS_KEY 
3ab4						DMARK "BL." 
3ab4 f5				push af  
3ab5 3a c9 3a			ld a, (.dmark)  
3ab8 32 71 ee			ld (debug_mark),a  
3abb 3a ca 3a			ld a, (.dmark+1)  
3abe 32 72 ee			ld (debug_mark+1),a  
3ac1 3a cb 3a			ld a, (.dmark+2)  
3ac4 32 73 ee			ld (debug_mark+2),a  
3ac7 18 03			jr .pastdmark  
3ac9 ..			.dmark: db "BL."  
3acc f1			.pastdmark: pop af  
3acd			endm  
# End of macro DMARK
3acd						CALLMONITOR 
3acd cd ae 13			call break_point_state  
3ad0				endm  
# End of macro CALLMONITOR
3ad0					endif 
3ad0 21 d9 3a				ld hl, .blstr 
3ad3 cd 76 1a				call forth_push_str 
3ad6					 
3ad6				       NEXTW 
3ad6 c3 71 1d			jp macro_next 
3ad9				endm 
# End of macro NEXTW
3ad9			 
3ad9 .. 00		.blstr: db " ", 0 
3adb			 
3adb			.SPACES: 
3adb				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3adb 47				db WORD_SYS_CORE+51             
3adc 76 3b			dw .SCROLL            
3ade 07				db 6 + 1 
3adf .. 00			db "SPACES",0              
3ae6				endm 
# End of macro CWHEAD
3ae6			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3ae6					if DEBUG_FORTH_WORDS_KEY 
3ae6						DMARK "SPS" 
3ae6 f5				push af  
3ae7 3a fb 3a			ld a, (.dmark)  
3aea 32 71 ee			ld (debug_mark),a  
3aed 3a fc 3a			ld a, (.dmark+1)  
3af0 32 72 ee			ld (debug_mark+1),a  
3af3 3a fd 3a			ld a, (.dmark+2)  
3af6 32 73 ee			ld (debug_mark+2),a  
3af9 18 03			jr .pastdmark  
3afb ..			.dmark: db "SPS"  
3afe f1			.pastdmark: pop af  
3aff			endm  
# End of macro DMARK
3aff						CALLMONITOR 
3aff cd ae 13			call break_point_state  
3b02				endm  
# End of macro CALLMONITOR
3b02					endif 
3b02			 
3b02			 
3b02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b02 cd ff 1b			call macro_dsp_valuehl 
3b05				endm 
# End of macro FORTH_DSP_VALUEHL
3b05			 
3b05			;		push hl    ; u 
3b05					if DEBUG_FORTH_WORDS 
3b05						DMARK "SPA" 
3b05 f5				push af  
3b06 3a 1a 3b			ld a, (.dmark)  
3b09 32 71 ee			ld (debug_mark),a  
3b0c 3a 1b 3b			ld a, (.dmark+1)  
3b0f 32 72 ee			ld (debug_mark+1),a  
3b12 3a 1c 3b			ld a, (.dmark+2)  
3b15 32 73 ee			ld (debug_mark+2),a  
3b18 18 03			jr .pastdmark  
3b1a ..			.dmark: db "SPA"  
3b1d f1			.pastdmark: pop af  
3b1e			endm  
# End of macro DMARK
3b1e						CALLMONITOR 
3b1e cd ae 13			call break_point_state  
3b21				endm  
# End of macro CALLMONITOR
3b21					endif 
3b21			 
3b21					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b21 cd b7 1c			call macro_forth_dsp_pop 
3b24				endm 
# End of macro FORTH_DSP_POP
3b24			;		pop hl 
3b24 4d					ld c, l 
3b25 06 00				ld b, 0 
3b27 21 57 e3				ld hl, scratch  
3b2a			 
3b2a					if DEBUG_FORTH_WORDS 
3b2a						DMARK "SP2" 
3b2a f5				push af  
3b2b 3a 3f 3b			ld a, (.dmark)  
3b2e 32 71 ee			ld (debug_mark),a  
3b31 3a 40 3b			ld a, (.dmark+1)  
3b34 32 72 ee			ld (debug_mark+1),a  
3b37 3a 41 3b			ld a, (.dmark+2)  
3b3a 32 73 ee			ld (debug_mark+2),a  
3b3d 18 03			jr .pastdmark  
3b3f ..			.dmark: db "SP2"  
3b42 f1			.pastdmark: pop af  
3b43			endm  
# End of macro DMARK
3b43						CALLMONITOR 
3b43 cd ae 13			call break_point_state  
3b46				endm  
# End of macro CALLMONITOR
3b46					endif 
3b46 3e 20				ld a, ' ' 
3b48 c5			.spaces1:	push bc 
3b49 77					ld (hl),a 
3b4a 23					inc hl 
3b4b c1					pop bc 
3b4c 10 fa				djnz .spaces1 
3b4e 3e 00				ld a,0 
3b50 77					ld (hl),a 
3b51 21 57 e3				ld hl, scratch 
3b54					if DEBUG_FORTH_WORDS 
3b54						DMARK "SP3" 
3b54 f5				push af  
3b55 3a 69 3b			ld a, (.dmark)  
3b58 32 71 ee			ld (debug_mark),a  
3b5b 3a 6a 3b			ld a, (.dmark+1)  
3b5e 32 72 ee			ld (debug_mark+1),a  
3b61 3a 6b 3b			ld a, (.dmark+2)  
3b64 32 73 ee			ld (debug_mark+2),a  
3b67 18 03			jr .pastdmark  
3b69 ..			.dmark: db "SP3"  
3b6c f1			.pastdmark: pop af  
3b6d			endm  
# End of macro DMARK
3b6d						CALLMONITOR 
3b6d cd ae 13			call break_point_state  
3b70				endm  
# End of macro CALLMONITOR
3b70					endif 
3b70 cd 71 1b				call forth_apush 
3b73			 
3b73				       NEXTW 
3b73 c3 71 1d			jp macro_next 
3b76				endm 
# End of macro NEXTW
3b76			 
3b76			 
3b76			 
3b76			.SCROLL: 
3b76				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3b76 53				db WORD_SYS_CORE+63             
3b77 a3 3b			dw .SCROLLD            
3b79 07				db 6 + 1 
3b7a .. 00			db "SCROLL",0              
3b81				endm 
# End of macro CWHEAD
3b81			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3b81					if DEBUG_FORTH_WORDS_KEY 
3b81						DMARK "SCR" 
3b81 f5				push af  
3b82 3a 96 3b			ld a, (.dmark)  
3b85 32 71 ee			ld (debug_mark),a  
3b88 3a 97 3b			ld a, (.dmark+1)  
3b8b 32 72 ee			ld (debug_mark+1),a  
3b8e 3a 98 3b			ld a, (.dmark+2)  
3b91 32 73 ee			ld (debug_mark+2),a  
3b94 18 03			jr .pastdmark  
3b96 ..			.dmark: db "SCR"  
3b99 f1			.pastdmark: pop af  
3b9a			endm  
# End of macro DMARK
3b9a						CALLMONITOR 
3b9a cd ae 13			call break_point_state  
3b9d				endm  
# End of macro CALLMONITOR
3b9d					endif 
3b9d			 
3b9d cd 42 09			call scroll_up 
3ba0			;	call update_display 
3ba0			 
3ba0					NEXTW 
3ba0 c3 71 1d			jp macro_next 
3ba3				endm 
# End of macro NEXTW
3ba3			 
3ba3			 
3ba3			 
3ba3			;		; get dir 
3ba3			; 
3ba3			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ba3			; 
3ba3			;		push hl 
3ba3			; 
3ba3			;		; destroy value TOS 
3ba3			; 
3ba3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ba3			; 
3ba3			;		; get count 
3ba3			; 
3ba3			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ba3			; 
3ba3			;		push hl 
3ba3			; 
3ba3			;		; destroy value TOS 
3ba3			; 
3ba3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ba3			; 
3ba3			;		; one value on hl get other one back 
3ba3			; 
3ba3			;		pop bc    ; count 
3ba3			; 
3ba3			;		pop de   ; dir 
3ba3			; 
3ba3			; 
3ba3			;		ld b, c 
3ba3			; 
3ba3			;.scrolldir:     push bc 
3ba3			;		push de 
3ba3			; 
3ba3			;		ld a, 0 
3ba3			;		cp e 
3ba3			;		jr z, .scrollup  
3ba3			;		call scroll_down 
3ba3			;		jr .scrollnext 
3ba3			;.scrollup:	call scroll_up 
3ba3			; 
3ba3			;		 
3ba3			;.scrollnext: 
3ba3			;		pop de 
3ba3			;		pop bc 
3ba3			;		djnz .scrolldir 
3ba3			; 
3ba3			; 
3ba3			; 
3ba3			; 
3ba3			; 
3ba3			;		NEXTW 
3ba3			 
3ba3			.SCROLLD: 
3ba3				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3ba3 53				db WORD_SYS_CORE+63             
3ba4 d1 3b			dw .ATQ            
3ba6 08				db 7 + 1 
3ba7 .. 00			db "SCROLLD",0              
3baf				endm 
# End of macro CWHEAD
3baf			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3baf					if DEBUG_FORTH_WORDS_KEY 
3baf						DMARK "SCD" 
3baf f5				push af  
3bb0 3a c4 3b			ld a, (.dmark)  
3bb3 32 71 ee			ld (debug_mark),a  
3bb6 3a c5 3b			ld a, (.dmark+1)  
3bb9 32 72 ee			ld (debug_mark+1),a  
3bbc 3a c6 3b			ld a, (.dmark+2)  
3bbf 32 73 ee			ld (debug_mark+2),a  
3bc2 18 03			jr .pastdmark  
3bc4 ..			.dmark: db "SCD"  
3bc7 f1			.pastdmark: pop af  
3bc8			endm  
# End of macro DMARK
3bc8						CALLMONITOR 
3bc8 cd ae 13			call break_point_state  
3bcb				endm  
# End of macro CALLMONITOR
3bcb					endif 
3bcb			 
3bcb cd 66 09			call scroll_down 
3bce			;	call update_display 
3bce			 
3bce					NEXTW 
3bce c3 71 1d			jp macro_next 
3bd1				endm 
# End of macro NEXTW
3bd1			 
3bd1			 
3bd1			.ATQ: 
3bd1				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3bd1 62				db WORD_SYS_CORE+78             
3bd2 2f 3c			dw .AUTODSP            
3bd4 04				db 3 + 1 
3bd5 .. 00			db "AT@",0              
3bd9				endm 
# End of macro CWHEAD
3bd9			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3bd9					if DEBUG_FORTH_WORDS_KEY 
3bd9						DMARK "ATA" 
3bd9 f5				push af  
3bda 3a ee 3b			ld a, (.dmark)  
3bdd 32 71 ee			ld (debug_mark),a  
3be0 3a ef 3b			ld a, (.dmark+1)  
3be3 32 72 ee			ld (debug_mark+1),a  
3be6 3a f0 3b			ld a, (.dmark+2)  
3be9 32 73 ee			ld (debug_mark+2),a  
3bec 18 03			jr .pastdmark  
3bee ..			.dmark: db "ATA"  
3bf1 f1			.pastdmark: pop af  
3bf2			endm  
# End of macro DMARK
3bf2						CALLMONITOR 
3bf2 cd ae 13			call break_point_state  
3bf5				endm  
# End of macro CALLMONITOR
3bf5					endif 
3bf5			 
3bf5			 
3bf5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf5 cd ff 1b			call macro_dsp_valuehl 
3bf8				endm 
# End of macro FORTH_DSP_VALUEHL
3bf8			 
3bf8					; TODO save cursor row 
3bf8 7d					ld a,l 
3bf9 fe 02				cp 2 
3bfb 20 04				jr nz, .crow3aq 
3bfd 3e 28				ld a, display_row_2 
3bff 18 12				jr .ccol1aq 
3c01 fe 03		.crow3aq:		cp 3 
3c03 20 04				jr nz, .crow4aq 
3c05 3e 50				ld a, display_row_3 
3c07 18 0a				jr .ccol1aq 
3c09 fe 04		.crow4aq:		cp 4 
3c0b 20 04				jr nz, .crow1aq 
3c0d 3e 78				ld a, display_row_4 
3c0f 18 02				jr .ccol1aq 
3c11 3e 00		.crow1aq:		ld a,display_row_1 
3c13 f5			.ccol1aq:		push af			; got row offset 
3c14 6f					ld l,a 
3c15 26 00				ld h,0 
3c17					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c17 cd b7 1c			call macro_forth_dsp_pop 
3c1a				endm 
# End of macro FORTH_DSP_POP
3c1a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c1a cd ff 1b			call macro_dsp_valuehl 
3c1d				endm 
# End of macro FORTH_DSP_VALUEHL
3c1d					; TODO save cursor col 
3c1d f1					pop af 
3c1e 85					add l		; add col offset 
3c1f			 
3c1f					; add current frame buffer address 
3c1f 2a d2 eb				ld hl, (display_fb_active) 
3c22 cd ad 0b				call addatohl 
3c25			 
3c25			 
3c25			 
3c25			 
3c25					; get char frame buffer location offset in hl 
3c25			 
3c25 7e					ld a,(hl) 
3c26 26 00				ld h, 0 
3c28 6f					ld l, a 
3c29			 
3c29 cd 08 1a				call forth_push_numhl 
3c2c			 
3c2c			 
3c2c					NEXTW 
3c2c c3 71 1d			jp macro_next 
3c2f				endm 
# End of macro NEXTW
3c2f			 
3c2f			.AUTODSP: 
3c2f				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3c2f 63				db WORD_SYS_CORE+79             
3c30 45 3c			dw .MENU            
3c32 05				db 4 + 1 
3c33 .. 00			db "ADSP",0              
3c38				endm 
# End of macro CWHEAD
3c38			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3c38			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3c38			 
3c38					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c38 cd ff 1b			call macro_dsp_valuehl 
3c3b				endm 
# End of macro FORTH_DSP_VALUEHL
3c3b			 
3c3b			;		push hl 
3c3b			 
3c3b					; destroy value TOS 
3c3b			 
3c3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c3b cd b7 1c			call macro_forth_dsp_pop 
3c3e				endm 
# End of macro FORTH_DSP_POP
3c3e			 
3c3e			;		pop hl 
3c3e			 
3c3e 7d					ld a,l 
3c3f 32 1e eb				ld (cli_autodisplay), a 
3c42				       NEXTW 
3c42 c3 71 1d			jp macro_next 
3c45				endm 
# End of macro NEXTW
3c45			 
3c45			.MENU: 
3c45				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3c45 70				db WORD_SYS_CORE+92             
3c46 ee 3c			dw .ENDDISPLAY            
3c48 05				db 4 + 1 
3c49 .. 00			db "MENU",0              
3c4e				endm 
# End of macro CWHEAD
3c4e			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3c4e			 
3c4e			;		; get number of items on the stack 
3c4e			; 
3c4e				 
3c4e					FORTH_DSP_VALUEHL 
3c4e cd ff 1b			call macro_dsp_valuehl 
3c51				endm 
# End of macro FORTH_DSP_VALUEHL
3c51				 
3c51					if DEBUG_FORTH_WORDS_KEY 
3c51						DMARK "MNU" 
3c51 f5				push af  
3c52 3a 66 3c			ld a, (.dmark)  
3c55 32 71 ee			ld (debug_mark),a  
3c58 3a 67 3c			ld a, (.dmark+1)  
3c5b 32 72 ee			ld (debug_mark+1),a  
3c5e 3a 68 3c			ld a, (.dmark+2)  
3c61 32 73 ee			ld (debug_mark+2),a  
3c64 18 03			jr .pastdmark  
3c66 ..			.dmark: db "MNU"  
3c69 f1			.pastdmark: pop af  
3c6a			endm  
# End of macro DMARK
3c6a						CALLMONITOR 
3c6a cd ae 13			call break_point_state  
3c6d				endm  
# End of macro CALLMONITOR
3c6d					endif 
3c6d			 
3c6d 45					ld b, l	 
3c6e 05					dec b 
3c6f			 
3c6f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c6f cd b7 1c			call macro_forth_dsp_pop 
3c72				endm 
# End of macro FORTH_DSP_POP
3c72			 
3c72			 
3c72					; go directly through the stack to pluck out the string pointers and build an array 
3c72			 
3c72			;		FORTH_DSP 
3c72			 
3c72					; hl contains top most stack item 
3c72				 
3c72 11 57 e3				ld de, scratch 
3c75			 
3c75			.mbuild: 
3c75			 
3c75					FORTH_DSP_VALUEHL 
3c75 cd ff 1b			call macro_dsp_valuehl 
3c78				endm 
# End of macro FORTH_DSP_VALUEHL
3c78			 
3c78					if DEBUG_FORTH_WORDS 
3c78						DMARK "MN3" 
3c78 f5				push af  
3c79 3a 8d 3c			ld a, (.dmark)  
3c7c 32 71 ee			ld (debug_mark),a  
3c7f 3a 8e 3c			ld a, (.dmark+1)  
3c82 32 72 ee			ld (debug_mark+1),a  
3c85 3a 8f 3c			ld a, (.dmark+2)  
3c88 32 73 ee			ld (debug_mark+2),a  
3c8b 18 03			jr .pastdmark  
3c8d ..			.dmark: db "MN3"  
3c90 f1			.pastdmark: pop af  
3c91			endm  
# End of macro DMARK
3c91						CALLMONITOR 
3c91 cd ae 13			call break_point_state  
3c94				endm  
# End of macro CALLMONITOR
3c94					endif 
3c94 eb					ex de, hl 
3c95 73					ld (hl), e 
3c96 23					inc hl 
3c97 72					ld (hl), d 
3c98 23					inc hl 
3c99 eb					ex de, hl 
3c9a			 
3c9a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c9a cd b7 1c			call macro_forth_dsp_pop 
3c9d				endm 
# End of macro FORTH_DSP_POP
3c9d			 
3c9d 10 d6				djnz .mbuild 
3c9f			 
3c9f					; done add term 
3c9f			 
3c9f eb					ex de, hl 
3ca0 36 00				ld (hl), 0 
3ca2 23					inc hl 
3ca3 36 00				ld (hl), 0 
3ca5			 
3ca5				 
3ca5					 
3ca5 21 57 e3				ld hl, scratch 
3ca8			 
3ca8					if DEBUG_FORTH_WORDS 
3ca8						DMARK "MNx" 
3ca8 f5				push af  
3ca9 3a bd 3c			ld a, (.dmark)  
3cac 32 71 ee			ld (debug_mark),a  
3caf 3a be 3c			ld a, (.dmark+1)  
3cb2 32 72 ee			ld (debug_mark+1),a  
3cb5 3a bf 3c			ld a, (.dmark+2)  
3cb8 32 73 ee			ld (debug_mark+2),a  
3cbb 18 03			jr .pastdmark  
3cbd ..			.dmark: db "MNx"  
3cc0 f1			.pastdmark: pop af  
3cc1			endm  
# End of macro DMARK
3cc1						CALLMONITOR 
3cc1 cd ae 13			call break_point_state  
3cc4				endm  
# End of macro CALLMONITOR
3cc4					endif 
3cc4			 
3cc4			 
3cc4			 
3cc4 3e 00				ld a, 0 
3cc6 cd b1 09				call menu 
3cc9			 
3cc9			 
3cc9 6f					ld l, a 
3cca 26 00				ld h, 0 
3ccc			 
3ccc					if DEBUG_FORTH_WORDS 
3ccc						DMARK "MNr" 
3ccc f5				push af  
3ccd 3a e1 3c			ld a, (.dmark)  
3cd0 32 71 ee			ld (debug_mark),a  
3cd3 3a e2 3c			ld a, (.dmark+1)  
3cd6 32 72 ee			ld (debug_mark+1),a  
3cd9 3a e3 3c			ld a, (.dmark+2)  
3cdc 32 73 ee			ld (debug_mark+2),a  
3cdf 18 03			jr .pastdmark  
3ce1 ..			.dmark: db "MNr"  
3ce4 f1			.pastdmark: pop af  
3ce5			endm  
# End of macro DMARK
3ce5						CALLMONITOR 
3ce5 cd ae 13			call break_point_state  
3ce8				endm  
# End of macro CALLMONITOR
3ce8					endif 
3ce8			 
3ce8 cd 08 1a				call forth_push_numhl 
3ceb			 
3ceb			 
3ceb			 
3ceb			 
3ceb				       NEXTW 
3ceb c3 71 1d			jp macro_next 
3cee				endm 
# End of macro NEXTW
3cee			 
3cee			 
3cee			.ENDDISPLAY: 
3cee			 
3cee			; eof 
# End of file forth_words_display.asm
3cee			include "forth_words_str.asm" 
3cee			 
3cee			; | ## String Words 
3cee			 
3cee			.PTR:   
3cee			 
3cee				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3cee 48				db WORD_SYS_CORE+52             
3cef 1b 3d			dw .STYPE            
3cf1 04				db 3 + 1 
3cf2 .. 00			db "PTR",0              
3cf6				endm 
# End of macro CWHEAD
3cf6			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3cf6			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3cf6			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3cf6			 
3cf6					if DEBUG_FORTH_WORDS_KEY 
3cf6						DMARK "PTR" 
3cf6 f5				push af  
3cf7 3a 0b 3d			ld a, (.dmark)  
3cfa 32 71 ee			ld (debug_mark),a  
3cfd 3a 0c 3d			ld a, (.dmark+1)  
3d00 32 72 ee			ld (debug_mark+1),a  
3d03 3a 0d 3d			ld a, (.dmark+2)  
3d06 32 73 ee			ld (debug_mark+2),a  
3d09 18 03			jr .pastdmark  
3d0b ..			.dmark: db "PTR"  
3d0e f1			.pastdmark: pop af  
3d0f			endm  
# End of macro DMARK
3d0f						CALLMONITOR 
3d0f cd ae 13			call break_point_state  
3d12				endm  
# End of macro CALLMONITOR
3d12					endif 
3d12					FORTH_DSP_VALUEHL 
3d12 cd ff 1b			call macro_dsp_valuehl 
3d15				endm 
# End of macro FORTH_DSP_VALUEHL
3d15 cd 08 1a				call forth_push_numhl 
3d18			 
3d18			 
3d18					NEXTW 
3d18 c3 71 1d			jp macro_next 
3d1b				endm 
# End of macro NEXTW
3d1b			.STYPE: 
3d1b				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3d1b 48				db WORD_SYS_CORE+52             
3d1c 6a 3d			dw .UPPER            
3d1e 06				db 5 + 1 
3d1f .. 00			db "STYPE",0              
3d25				endm 
# End of macro CWHEAD
3d25			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3d25					if DEBUG_FORTH_WORDS_KEY 
3d25						DMARK "STY" 
3d25 f5				push af  
3d26 3a 3a 3d			ld a, (.dmark)  
3d29 32 71 ee			ld (debug_mark),a  
3d2c 3a 3b 3d			ld a, (.dmark+1)  
3d2f 32 72 ee			ld (debug_mark+1),a  
3d32 3a 3c 3d			ld a, (.dmark+2)  
3d35 32 73 ee			ld (debug_mark+2),a  
3d38 18 03			jr .pastdmark  
3d3a ..			.dmark: db "STY"  
3d3d f1			.pastdmark: pop af  
3d3e			endm  
# End of macro DMARK
3d3e						CALLMONITOR 
3d3e cd ae 13			call break_point_state  
3d41				endm  
# End of macro CALLMONITOR
3d41					endif 
3d41					FORTH_DSP 
3d41 cd c5 1b			call macro_forth_dsp 
3d44				endm 
# End of macro FORTH_DSP
3d44					;v5 FORTH_DSP_VALUE 
3d44			 
3d44 7e					ld a, (hl) 
3d45			 
3d45 f5					push af 
3d46			 
3d46			; Dont destroy TOS		FORTH_DSP_POP 
3d46			 
3d46 f1					pop af 
3d47			 
3d47 fe 01				cp DS_TYPE_STR 
3d49 28 09				jr z, .typestr 
3d4b			 
3d4b fe 02				cp DS_TYPE_INUM 
3d4d 28 0a				jr z, .typeinum 
3d4f			 
3d4f 21 68 3d				ld hl, .tna 
3d52 18 0a				jr .tpush 
3d54			 
3d54 21 64 3d		.typestr:	ld hl, .tstr 
3d57 18 05				jr .tpush 
3d59 21 66 3d		.typeinum:	ld hl, .tinum 
3d5c 18 00				jr .tpush 
3d5e			 
3d5e			.tpush: 
3d5e			 
3d5e cd 76 1a				call forth_push_str 
3d61			 
3d61					NEXTW 
3d61 c3 71 1d			jp macro_next 
3d64				endm 
# End of macro NEXTW
3d64 .. 00		.tstr:	db "s",0 
3d66 .. 00		.tinum:  db "i",0 
3d68 .. 00		.tna:   db "?", 0 
3d6a			 
3d6a			 
3d6a			.UPPER: 
3d6a				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3d6a 48				db WORD_SYS_CORE+52             
3d6b a5 3d			dw .LOWER            
3d6d 06				db 5 + 1 
3d6e .. 00			db "UPPER",0              
3d74				endm 
# End of macro CWHEAD
3d74			; | UPPER ( s -- s ) Upper case string s  | DONE 
3d74					if DEBUG_FORTH_WORDS_KEY 
3d74						DMARK "UPR" 
3d74 f5				push af  
3d75 3a 89 3d			ld a, (.dmark)  
3d78 32 71 ee			ld (debug_mark),a  
3d7b 3a 8a 3d			ld a, (.dmark+1)  
3d7e 32 72 ee			ld (debug_mark+1),a  
3d81 3a 8b 3d			ld a, (.dmark+2)  
3d84 32 73 ee			ld (debug_mark+2),a  
3d87 18 03			jr .pastdmark  
3d89 ..			.dmark: db "UPR"  
3d8c f1			.pastdmark: pop af  
3d8d			endm  
# End of macro DMARK
3d8d						CALLMONITOR 
3d8d cd ae 13			call break_point_state  
3d90				endm  
# End of macro CALLMONITOR
3d90					endif 
3d90			 
3d90					FORTH_DSP 
3d90 cd c5 1b			call macro_forth_dsp 
3d93				endm 
# End of macro FORTH_DSP
3d93					 
3d93			; TODO check is string type 
3d93			 
3d93					FORTH_DSP_VALUEHL 
3d93 cd ff 1b			call macro_dsp_valuehl 
3d96				endm 
# End of macro FORTH_DSP_VALUEHL
3d96			; get pointer to string in hl 
3d96			 
3d96 7e			.toup:		ld a, (hl) 
3d97 fe 00				cp 0 
3d99 28 07				jr z, .toupdone 
3d9b			 
3d9b cd 1a 0f				call to_upper 
3d9e			 
3d9e 77					ld (hl), a 
3d9f 23					inc hl 
3da0 18 f4				jr .toup 
3da2			 
3da2					 
3da2			 
3da2			 
3da2			; for each char convert to upper 
3da2					 
3da2			.toupdone: 
3da2			 
3da2			 
3da2					NEXTW 
3da2 c3 71 1d			jp macro_next 
3da5				endm 
# End of macro NEXTW
3da5			.LOWER: 
3da5				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3da5 48				db WORD_SYS_CORE+52             
3da6 e0 3d			dw .TCASE            
3da8 06				db 5 + 1 
3da9 .. 00			db "LOWER",0              
3daf				endm 
# End of macro CWHEAD
3daf			; | LOWER ( s -- s ) Lower case string s  | DONE 
3daf					if DEBUG_FORTH_WORDS_KEY 
3daf						DMARK "LWR" 
3daf f5				push af  
3db0 3a c4 3d			ld a, (.dmark)  
3db3 32 71 ee			ld (debug_mark),a  
3db6 3a c5 3d			ld a, (.dmark+1)  
3db9 32 72 ee			ld (debug_mark+1),a  
3dbc 3a c6 3d			ld a, (.dmark+2)  
3dbf 32 73 ee			ld (debug_mark+2),a  
3dc2 18 03			jr .pastdmark  
3dc4 ..			.dmark: db "LWR"  
3dc7 f1			.pastdmark: pop af  
3dc8			endm  
# End of macro DMARK
3dc8						CALLMONITOR 
3dc8 cd ae 13			call break_point_state  
3dcb				endm  
# End of macro CALLMONITOR
3dcb					endif 
3dcb			 
3dcb					FORTH_DSP 
3dcb cd c5 1b			call macro_forth_dsp 
3dce				endm 
# End of macro FORTH_DSP
3dce					 
3dce			; TODO check is string type 
3dce			 
3dce					FORTH_DSP_VALUEHL 
3dce cd ff 1b			call macro_dsp_valuehl 
3dd1				endm 
# End of macro FORTH_DSP_VALUEHL
3dd1			; get pointer to string in hl 
3dd1			 
3dd1 7e			.tolow:		ld a, (hl) 
3dd2 fe 00				cp 0 
3dd4 28 07				jr z, .tolowdone 
3dd6			 
3dd6 cd 23 0f				call to_lower 
3dd9			 
3dd9 77					ld (hl), a 
3dda 23					inc hl 
3ddb 18 f4				jr .tolow 
3ddd			 
3ddd					 
3ddd			 
3ddd			 
3ddd			; for each char convert to low 
3ddd					 
3ddd			.tolowdone: 
3ddd					NEXTW 
3ddd c3 71 1d			jp macro_next 
3de0				endm 
# End of macro NEXTW
3de0			.TCASE: 
3de0				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3de0 48				db WORD_SYS_CORE+52             
3de1 16 3f			dw .SUBSTR            
3de3 06				db 5 + 1 
3de4 .. 00			db "TCASE",0              
3dea				endm 
# End of macro CWHEAD
3dea			; | TCASE ( s -- s ) Title case string s  | DONE 
3dea					if DEBUG_FORTH_WORDS_KEY 
3dea						DMARK "TCS" 
3dea f5				push af  
3deb 3a ff 3d			ld a, (.dmark)  
3dee 32 71 ee			ld (debug_mark),a  
3df1 3a 00 3e			ld a, (.dmark+1)  
3df4 32 72 ee			ld (debug_mark+1),a  
3df7 3a 01 3e			ld a, (.dmark+2)  
3dfa 32 73 ee			ld (debug_mark+2),a  
3dfd 18 03			jr .pastdmark  
3dff ..			.dmark: db "TCS"  
3e02 f1			.pastdmark: pop af  
3e03			endm  
# End of macro DMARK
3e03						CALLMONITOR 
3e03 cd ae 13			call break_point_state  
3e06				endm  
# End of macro CALLMONITOR
3e06					endif 
3e06			 
3e06					FORTH_DSP 
3e06 cd c5 1b			call macro_forth_dsp 
3e09				endm 
# End of macro FORTH_DSP
3e09					 
3e09			; TODO check is string type 
3e09			 
3e09					FORTH_DSP_VALUEHL 
3e09 cd ff 1b			call macro_dsp_valuehl 
3e0c				endm 
# End of macro FORTH_DSP_VALUEHL
3e0c			; get pointer to string in hl 
3e0c			 
3e0c					if DEBUG_FORTH_WORDS 
3e0c						DMARK "TC1" 
3e0c f5				push af  
3e0d 3a 21 3e			ld a, (.dmark)  
3e10 32 71 ee			ld (debug_mark),a  
3e13 3a 22 3e			ld a, (.dmark+1)  
3e16 32 72 ee			ld (debug_mark+1),a  
3e19 3a 23 3e			ld a, (.dmark+2)  
3e1c 32 73 ee			ld (debug_mark+2),a  
3e1f 18 03			jr .pastdmark  
3e21 ..			.dmark: db "TC1"  
3e24 f1			.pastdmark: pop af  
3e25			endm  
# End of macro DMARK
3e25						CALLMONITOR 
3e25 cd ae 13			call break_point_state  
3e28				endm  
# End of macro CALLMONITOR
3e28					endif 
3e28			 
3e28					; first time in turn to upper case first char 
3e28			 
3e28 7e					ld a, (hl) 
3e29 c3 b3 3e				jp .totsiptou 
3e2c			 
3e2c			 
3e2c 7e			.tot:		ld a, (hl) 
3e2d fe 00				cp 0 
3e2f ca f7 3e				jp z, .totdone 
3e32			 
3e32					if DEBUG_FORTH_WORDS 
3e32						DMARK "TC2" 
3e32 f5				push af  
3e33 3a 47 3e			ld a, (.dmark)  
3e36 32 71 ee			ld (debug_mark),a  
3e39 3a 48 3e			ld a, (.dmark+1)  
3e3c 32 72 ee			ld (debug_mark+1),a  
3e3f 3a 49 3e			ld a, (.dmark+2)  
3e42 32 73 ee			ld (debug_mark+2),a  
3e45 18 03			jr .pastdmark  
3e47 ..			.dmark: db "TC2"  
3e4a f1			.pastdmark: pop af  
3e4b			endm  
# End of macro DMARK
3e4b						CALLMONITOR 
3e4b cd ae 13			call break_point_state  
3e4e				endm  
# End of macro CALLMONITOR
3e4e					endif 
3e4e					; check to see if current char is a space 
3e4e			 
3e4e fe 20				cp ' ' 
3e50 28 21				jr z, .totsp 
3e52 cd 23 0f				call to_lower 
3e55					if DEBUG_FORTH_WORDS 
3e55						DMARK "TC3" 
3e55 f5				push af  
3e56 3a 6a 3e			ld a, (.dmark)  
3e59 32 71 ee			ld (debug_mark),a  
3e5c 3a 6b 3e			ld a, (.dmark+1)  
3e5f 32 72 ee			ld (debug_mark+1),a  
3e62 3a 6c 3e			ld a, (.dmark+2)  
3e65 32 73 ee			ld (debug_mark+2),a  
3e68 18 03			jr .pastdmark  
3e6a ..			.dmark: db "TC3"  
3e6d f1			.pastdmark: pop af  
3e6e			endm  
# End of macro DMARK
3e6e						CALLMONITOR 
3e6e cd ae 13			call break_point_state  
3e71				endm  
# End of macro CALLMONITOR
3e71					endif 
3e71 18 63				jr .totnxt 
3e73			 
3e73			.totsp:         ; on a space, find next char which should be upper 
3e73			 
3e73					if DEBUG_FORTH_WORDS 
3e73						DMARK "TC4" 
3e73 f5				push af  
3e74 3a 88 3e			ld a, (.dmark)  
3e77 32 71 ee			ld (debug_mark),a  
3e7a 3a 89 3e			ld a, (.dmark+1)  
3e7d 32 72 ee			ld (debug_mark+1),a  
3e80 3a 8a 3e			ld a, (.dmark+2)  
3e83 32 73 ee			ld (debug_mark+2),a  
3e86 18 03			jr .pastdmark  
3e88 ..			.dmark: db "TC4"  
3e8b f1			.pastdmark: pop af  
3e8c			endm  
# End of macro DMARK
3e8c						CALLMONITOR 
3e8c cd ae 13			call break_point_state  
3e8f				endm  
# End of macro CALLMONITOR
3e8f					endif 
3e8f					;; 
3e8f			 
3e8f fe 20				cp ' ' 
3e91 20 20				jr nz, .totsiptou 
3e93 23					inc hl 
3e94 7e					ld a, (hl) 
3e95					if DEBUG_FORTH_WORDS 
3e95						DMARK "TC5" 
3e95 f5				push af  
3e96 3a aa 3e			ld a, (.dmark)  
3e99 32 71 ee			ld (debug_mark),a  
3e9c 3a ab 3e			ld a, (.dmark+1)  
3e9f 32 72 ee			ld (debug_mark+1),a  
3ea2 3a ac 3e			ld a, (.dmark+2)  
3ea5 32 73 ee			ld (debug_mark+2),a  
3ea8 18 03			jr .pastdmark  
3eaa ..			.dmark: db "TC5"  
3ead f1			.pastdmark: pop af  
3eae			endm  
# End of macro DMARK
3eae						CALLMONITOR 
3eae cd ae 13			call break_point_state  
3eb1				endm  
# End of macro CALLMONITOR
3eb1					endif 
3eb1 18 c0				jr .totsp 
3eb3 fe 00		.totsiptou:    cp 0 
3eb5 28 40				jr z, .totdone 
3eb7					; not space and not zero term so upper case it 
3eb7 cd 1a 0f				call to_upper 
3eba			 
3eba					if DEBUG_FORTH_WORDS 
3eba						DMARK "TC6" 
3eba f5				push af  
3ebb 3a cf 3e			ld a, (.dmark)  
3ebe 32 71 ee			ld (debug_mark),a  
3ec1 3a d0 3e			ld a, (.dmark+1)  
3ec4 32 72 ee			ld (debug_mark+1),a  
3ec7 3a d1 3e			ld a, (.dmark+2)  
3eca 32 73 ee			ld (debug_mark+2),a  
3ecd 18 03			jr .pastdmark  
3ecf ..			.dmark: db "TC6"  
3ed2 f1			.pastdmark: pop af  
3ed3			endm  
# End of macro DMARK
3ed3						CALLMONITOR 
3ed3 cd ae 13			call break_point_state  
3ed6				endm  
# End of macro CALLMONITOR
3ed6					endif 
3ed6			 
3ed6			 
3ed6			.totnxt: 
3ed6			 
3ed6 77					ld (hl), a 
3ed7 23					inc hl 
3ed8					if DEBUG_FORTH_WORDS 
3ed8						DMARK "TC7" 
3ed8 f5				push af  
3ed9 3a ed 3e			ld a, (.dmark)  
3edc 32 71 ee			ld (debug_mark),a  
3edf 3a ee 3e			ld a, (.dmark+1)  
3ee2 32 72 ee			ld (debug_mark+1),a  
3ee5 3a ef 3e			ld a, (.dmark+2)  
3ee8 32 73 ee			ld (debug_mark+2),a  
3eeb 18 03			jr .pastdmark  
3eed ..			.dmark: db "TC7"  
3ef0 f1			.pastdmark: pop af  
3ef1			endm  
# End of macro DMARK
3ef1						CALLMONITOR 
3ef1 cd ae 13			call break_point_state  
3ef4				endm  
# End of macro CALLMONITOR
3ef4					endif 
3ef4 c3 2c 3e				jp .tot 
3ef7			 
3ef7					 
3ef7			 
3ef7			 
3ef7			; for each char convert to low 
3ef7					 
3ef7			.totdone: 
3ef7					if DEBUG_FORTH_WORDS 
3ef7						DMARK "TCd" 
3ef7 f5				push af  
3ef8 3a 0c 3f			ld a, (.dmark)  
3efb 32 71 ee			ld (debug_mark),a  
3efe 3a 0d 3f			ld a, (.dmark+1)  
3f01 32 72 ee			ld (debug_mark+1),a  
3f04 3a 0e 3f			ld a, (.dmark+2)  
3f07 32 73 ee			ld (debug_mark+2),a  
3f0a 18 03			jr .pastdmark  
3f0c ..			.dmark: db "TCd"  
3f0f f1			.pastdmark: pop af  
3f10			endm  
# End of macro DMARK
3f10						CALLMONITOR 
3f10 cd ae 13			call break_point_state  
3f13				endm  
# End of macro CALLMONITOR
3f13					endif 
3f13					NEXTW 
3f13 c3 71 1d			jp macro_next 
3f16				endm 
# End of macro NEXTW
3f16			 
3f16			.SUBSTR: 
3f16				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3f16 48				db WORD_SYS_CORE+52             
3f17 74 3f			dw .LEFT            
3f19 07				db 6 + 1 
3f1a .. 00			db "SUBSTR",0              
3f21				endm 
# End of macro CWHEAD
3f21			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3f21			 
3f21					if DEBUG_FORTH_WORDS_KEY 
3f21						DMARK "SST" 
3f21 f5				push af  
3f22 3a 36 3f			ld a, (.dmark)  
3f25 32 71 ee			ld (debug_mark),a  
3f28 3a 37 3f			ld a, (.dmark+1)  
3f2b 32 72 ee			ld (debug_mark+1),a  
3f2e 3a 38 3f			ld a, (.dmark+2)  
3f31 32 73 ee			ld (debug_mark+2),a  
3f34 18 03			jr .pastdmark  
3f36 ..			.dmark: db "SST"  
3f39 f1			.pastdmark: pop af  
3f3a			endm  
# End of macro DMARK
3f3a						CALLMONITOR 
3f3a cd ae 13			call break_point_state  
3f3d				endm  
# End of macro CALLMONITOR
3f3d					endif 
3f3d			; TODO check string type 
3f3d					FORTH_DSP_VALUEHL 
3f3d cd ff 1b			call macro_dsp_valuehl 
3f40				endm 
# End of macro FORTH_DSP_VALUEHL
3f40			 
3f40 e5					push hl      ; string length 
3f41			 
3f41					FORTH_DSP_POP 
3f41 cd b7 1c			call macro_forth_dsp_pop 
3f44				endm 
# End of macro FORTH_DSP_POP
3f44			 
3f44					FORTH_DSP_VALUEHL 
3f44 cd ff 1b			call macro_dsp_valuehl 
3f47				endm 
# End of macro FORTH_DSP_VALUEHL
3f47			 
3f47 e5					push hl     ; start char 
3f48			 
3f48					FORTH_DSP_POP 
3f48 cd b7 1c			call macro_forth_dsp_pop 
3f4b				endm 
# End of macro FORTH_DSP_POP
3f4b			 
3f4b			 
3f4b					FORTH_DSP_VALUE 
3f4b cd e8 1b			call macro_forth_dsp_value 
3f4e				endm 
# End of macro FORTH_DSP_VALUE
3f4e			 
3f4e d1					pop de    ; get start post offset 
3f4f			 
3f4f 19					add hl, de    ; starting offset 
3f50			 
3f50 c1					pop bc 
3f51 c5					push bc      ; grab size of string 
3f52			 
3f52 e5					push hl    ; save string start  
3f53			 
3f53 26 00				ld h, 0 
3f55 69					ld l, c 
3f56 23					inc hl 
3f57 23					inc hl 
3f58			 
3f58 cd 74 10				call malloc 
3f5b				if DEBUG_FORTH_MALLOC_GUARD 
3f5b cc a3 45				call z,malloc_error 
3f5e				endif 
3f5e			 
3f5e eb					ex de, hl      ; save malloc area for string copy 
3f5f e1					pop hl    ; get back source 
3f60 c1					pop bc    ; get length of string back 
3f61			 
3f61 d5					push de    ; save malloc area for after we push 
3f62 ed b0				ldir     ; copy substr 
3f64			 
3f64			 
3f64 eb					ex de, hl 
3f65 3e 00				ld a, 0 
3f67 77					ld (hl), a   ; term substr 
3f68			 
3f68					 
3f68 e1					pop hl    ; get malloc so we can push it 
3f69 e5					push hl   ; save so we can free it afterwards 
3f6a			 
3f6a cd 76 1a				call forth_push_str 
3f6d			 
3f6d e1					pop hl 
3f6e cd 3e 11				call free 
3f71			 
3f71					 
3f71					 
3f71			 
3f71			 
3f71					NEXTW 
3f71 c3 71 1d			jp macro_next 
3f74				endm 
# End of macro NEXTW
3f74			 
3f74			.LEFT: 
3f74				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3f74 48				db WORD_SYS_CORE+52             
3f75 9c 3f			dw .RIGHT            
3f77 05				db 4 + 1 
3f78 .. 00			db "LEFT",0              
3f7d				endm 
# End of macro CWHEAD
3f7d			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3f7d					if DEBUG_FORTH_WORDS_KEY 
3f7d						DMARK "LEF" 
3f7d f5				push af  
3f7e 3a 92 3f			ld a, (.dmark)  
3f81 32 71 ee			ld (debug_mark),a  
3f84 3a 93 3f			ld a, (.dmark+1)  
3f87 32 72 ee			ld (debug_mark+1),a  
3f8a 3a 94 3f			ld a, (.dmark+2)  
3f8d 32 73 ee			ld (debug_mark+2),a  
3f90 18 03			jr .pastdmark  
3f92 ..			.dmark: db "LEF"  
3f95 f1			.pastdmark: pop af  
3f96			endm  
# End of macro DMARK
3f96						CALLMONITOR 
3f96 cd ae 13			call break_point_state  
3f99				endm  
# End of macro CALLMONITOR
3f99					endif 
3f99			 
3f99					NEXTW 
3f99 c3 71 1d			jp macro_next 
3f9c				endm 
# End of macro NEXTW
3f9c			.RIGHT: 
3f9c				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3f9c 48				db WORD_SYS_CORE+52             
3f9d c5 3f			dw .STR2NUM            
3f9f 06				db 5 + 1 
3fa0 .. 00			db "RIGHT",0              
3fa6				endm 
# End of macro CWHEAD
3fa6			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3fa6					if DEBUG_FORTH_WORDS_KEY 
3fa6						DMARK "RIG" 
3fa6 f5				push af  
3fa7 3a bb 3f			ld a, (.dmark)  
3faa 32 71 ee			ld (debug_mark),a  
3fad 3a bc 3f			ld a, (.dmark+1)  
3fb0 32 72 ee			ld (debug_mark+1),a  
3fb3 3a bd 3f			ld a, (.dmark+2)  
3fb6 32 73 ee			ld (debug_mark+2),a  
3fb9 18 03			jr .pastdmark  
3fbb ..			.dmark: db "RIG"  
3fbe f1			.pastdmark: pop af  
3fbf			endm  
# End of macro DMARK
3fbf						CALLMONITOR 
3fbf cd ae 13			call break_point_state  
3fc2				endm  
# End of macro CALLMONITOR
3fc2					endif 
3fc2			 
3fc2					NEXTW 
3fc2 c3 71 1d			jp macro_next 
3fc5				endm 
# End of macro NEXTW
3fc5			 
3fc5			 
3fc5			.STR2NUM: 
3fc5				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3fc5 48				db WORD_SYS_CORE+52             
3fc6 51 40			dw .NUM2STR            
3fc8 08				db 7 + 1 
3fc9 .. 00			db "STR2NUM",0              
3fd1				endm 
# End of macro CWHEAD
3fd1			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3fd1			 
3fd1			 
3fd1			; TODO STR type check to do 
3fd1					if DEBUG_FORTH_WORDS_KEY 
3fd1						DMARK "S2N" 
3fd1 f5				push af  
3fd2 3a e6 3f			ld a, (.dmark)  
3fd5 32 71 ee			ld (debug_mark),a  
3fd8 3a e7 3f			ld a, (.dmark+1)  
3fdb 32 72 ee			ld (debug_mark+1),a  
3fde 3a e8 3f			ld a, (.dmark+2)  
3fe1 32 73 ee			ld (debug_mark+2),a  
3fe4 18 03			jr .pastdmark  
3fe6 ..			.dmark: db "S2N"  
3fe9 f1			.pastdmark: pop af  
3fea			endm  
# End of macro DMARK
3fea						CALLMONITOR 
3fea cd ae 13			call break_point_state  
3fed				endm  
# End of macro CALLMONITOR
3fed					endif 
3fed			 
3fed					;FORTH_DSP 
3fed					FORTH_DSP_VALUE 
3fed cd e8 1b			call macro_forth_dsp_value 
3ff0				endm 
# End of macro FORTH_DSP_VALUE
3ff0					;inc hl 
3ff0			 
3ff0 eb					ex de, hl 
3ff1					if DEBUG_FORTH_WORDS 
3ff1						DMARK "S2a" 
3ff1 f5				push af  
3ff2 3a 06 40			ld a, (.dmark)  
3ff5 32 71 ee			ld (debug_mark),a  
3ff8 3a 07 40			ld a, (.dmark+1)  
3ffb 32 72 ee			ld (debug_mark+1),a  
3ffe 3a 08 40			ld a, (.dmark+2)  
4001 32 73 ee			ld (debug_mark+2),a  
4004 18 03			jr .pastdmark  
4006 ..			.dmark: db "S2a"  
4009 f1			.pastdmark: pop af  
400a			endm  
# End of macro DMARK
400a						CALLMONITOR 
400a cd ae 13			call break_point_state  
400d				endm  
# End of macro CALLMONITOR
400d					endif 
400d cd a2 0f				call string_to_uint16 
4010			 
4010					if DEBUG_FORTH_WORDS 
4010						DMARK "S2b" 
4010 f5				push af  
4011 3a 25 40			ld a, (.dmark)  
4014 32 71 ee			ld (debug_mark),a  
4017 3a 26 40			ld a, (.dmark+1)  
401a 32 72 ee			ld (debug_mark+1),a  
401d 3a 27 40			ld a, (.dmark+2)  
4020 32 73 ee			ld (debug_mark+2),a  
4023 18 03			jr .pastdmark  
4025 ..			.dmark: db "S2b"  
4028 f1			.pastdmark: pop af  
4029			endm  
# End of macro DMARK
4029						CALLMONITOR 
4029 cd ae 13			call break_point_state  
402c				endm  
# End of macro CALLMONITOR
402c					endif 
402c			;		push hl 
402c					FORTH_DSP_POP 
402c cd b7 1c			call macro_forth_dsp_pop 
402f				endm 
# End of macro FORTH_DSP_POP
402f			;		pop hl 
402f					 
402f					if DEBUG_FORTH_WORDS 
402f						DMARK "S2b" 
402f f5				push af  
4030 3a 44 40			ld a, (.dmark)  
4033 32 71 ee			ld (debug_mark),a  
4036 3a 45 40			ld a, (.dmark+1)  
4039 32 72 ee			ld (debug_mark+1),a  
403c 3a 46 40			ld a, (.dmark+2)  
403f 32 73 ee			ld (debug_mark+2),a  
4042 18 03			jr .pastdmark  
4044 ..			.dmark: db "S2b"  
4047 f1			.pastdmark: pop af  
4048			endm  
# End of macro DMARK
4048						CALLMONITOR 
4048 cd ae 13			call break_point_state  
404b				endm  
# End of macro CALLMONITOR
404b					endif 
404b cd 08 1a				call forth_push_numhl	 
404e			 
404e				 
404e				       NEXTW 
404e c3 71 1d			jp macro_next 
4051				endm 
# End of macro NEXTW
4051			.NUM2STR: 
4051				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4051 48				db WORD_SYS_CORE+52             
4052 60 40			dw .CONCAT            
4054 08				db 7 + 1 
4055 .. 00			db "NUM2STR",0              
405d				endm 
# End of macro CWHEAD
405d			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
405d			 
405d			;		; malloc a string to target 
405d			;		ld hl, 10     ; TODO max string size should be fine 
405d			;		call malloc 
405d			;		push hl    ; save malloc location 
405d			; 
405d			; 
405d			;; TODO check int type 
405d			;		FORTH_DSP_VALUEHL 
405d			;		ld a, l 
405d			;		call DispAToASCII   
405d			;;TODO need to chage above call to dump into string 
405d			; 
405d			; 
405d			 
405d				       NEXTW 
405d c3 71 1d			jp macro_next 
4060				endm 
# End of macro NEXTW
4060			 
4060			.CONCAT: 
4060				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4060 48				db WORD_SYS_CORE+52             
4061 13 41			dw .FIND            
4063 07				db 6 + 1 
4064 .. 00			db "CONCAT",0              
406b				endm 
# End of macro CWHEAD
406b			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
406b			 
406b			; TODO check string type 
406b			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
406b			 
406b					if DEBUG_FORTH_WORDS_KEY 
406b						DMARK "CON" 
406b f5				push af  
406c 3a 80 40			ld a, (.dmark)  
406f 32 71 ee			ld (debug_mark),a  
4072 3a 81 40			ld a, (.dmark+1)  
4075 32 72 ee			ld (debug_mark+1),a  
4078 3a 82 40			ld a, (.dmark+2)  
407b 32 73 ee			ld (debug_mark+2),a  
407e 18 03			jr .pastdmark  
4080 ..			.dmark: db "CON"  
4083 f1			.pastdmark: pop af  
4084			endm  
# End of macro DMARK
4084						CALLMONITOR 
4084 cd ae 13			call break_point_state  
4087				endm  
# End of macro CALLMONITOR
4087					endif 
4087			 
4087			 
4087					FORTH_DSP_VALUE 
4087 cd e8 1b			call macro_forth_dsp_value 
408a				endm 
# End of macro FORTH_DSP_VALUE
408a e5					push hl   ; s2 
408b			 
408b					FORTH_DSP_POP 
408b cd b7 1c			call macro_forth_dsp_pop 
408e				endm 
# End of macro FORTH_DSP_POP
408e			 
408e					FORTH_DSP_VALUE 
408e cd e8 1b			call macro_forth_dsp_value 
4091				endm 
# End of macro FORTH_DSP_VALUE
4091			 
4091 e5					push hl   ; s1 
4092			 
4092					FORTH_DSP_POP 
4092 cd b7 1c			call macro_forth_dsp_pop 
4095				endm 
# End of macro FORTH_DSP_POP
4095					 
4095			 
4095					; copy s1 
4095			 
4095				 
4095					; save ptr 
4095 e1					pop hl  
4096 e5					push hl 
4097 3e 00				ld a, 0 
4099 cd 16 10				call strlent 
409c					;inc hl    ; zer0 
409c 06 00				ld b, 0 
409e 4d					ld c, l 
409f e1					pop hl		 
40a0 11 57 e3				ld de, scratch	 
40a3					if DEBUG_FORTH_WORDS 
40a3						DMARK "CO1" 
40a3 f5				push af  
40a4 3a b8 40			ld a, (.dmark)  
40a7 32 71 ee			ld (debug_mark),a  
40aa 3a b9 40			ld a, (.dmark+1)  
40ad 32 72 ee			ld (debug_mark+1),a  
40b0 3a ba 40			ld a, (.dmark+2)  
40b3 32 73 ee			ld (debug_mark+2),a  
40b6 18 03			jr .pastdmark  
40b8 ..			.dmark: db "CO1"  
40bb f1			.pastdmark: pop af  
40bc			endm  
# End of macro DMARK
40bc						CALLMONITOR 
40bc cd ae 13			call break_point_state  
40bf				endm  
# End of macro CALLMONITOR
40bf					endif 
40bf ed b0				ldir 
40c1			 
40c1 e1					pop hl 
40c2 e5					push hl 
40c3 d5					push de 
40c4			 
40c4			 
40c4 3e 00				ld a, 0 
40c6 cd 16 10				call strlent 
40c9 23					inc hl    ; zer0 
40ca 23					inc hl 
40cb 06 00				ld b, 0 
40cd 4d					ld c, l 
40ce d1					pop de 
40cf e1					pop hl		 
40d0					if DEBUG_FORTH_WORDS 
40d0						DMARK "CO2" 
40d0 f5				push af  
40d1 3a e5 40			ld a, (.dmark)  
40d4 32 71 ee			ld (debug_mark),a  
40d7 3a e6 40			ld a, (.dmark+1)  
40da 32 72 ee			ld (debug_mark+1),a  
40dd 3a e7 40			ld a, (.dmark+2)  
40e0 32 73 ee			ld (debug_mark+2),a  
40e3 18 03			jr .pastdmark  
40e5 ..			.dmark: db "CO2"  
40e8 f1			.pastdmark: pop af  
40e9			endm  
# End of macro DMARK
40e9						CALLMONITOR 
40e9 cd ae 13			call break_point_state  
40ec				endm  
# End of macro CALLMONITOR
40ec					endif 
40ec ed b0				ldir 
40ee			 
40ee			 
40ee			 
40ee 21 57 e3				ld hl, scratch 
40f1					if DEBUG_FORTH_WORDS 
40f1						DMARK "CO5" 
40f1 f5				push af  
40f2 3a 06 41			ld a, (.dmark)  
40f5 32 71 ee			ld (debug_mark),a  
40f8 3a 07 41			ld a, (.dmark+1)  
40fb 32 72 ee			ld (debug_mark+1),a  
40fe 3a 08 41			ld a, (.dmark+2)  
4101 32 73 ee			ld (debug_mark+2),a  
4104 18 03			jr .pastdmark  
4106 ..			.dmark: db "CO5"  
4109 f1			.pastdmark: pop af  
410a			endm  
# End of macro DMARK
410a						CALLMONITOR 
410a cd ae 13			call break_point_state  
410d				endm  
# End of macro CALLMONITOR
410d					endif 
410d			 
410d cd 76 1a				call forth_push_str 
4110			 
4110			 
4110			 
4110			 
4110				       NEXTW 
4110 c3 71 1d			jp macro_next 
4113				endm 
# End of macro NEXTW
4113			 
4113			 
4113			.FIND: 
4113				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4113 4b				db WORD_SYS_CORE+55             
4114 d1 41			dw .LEN            
4116 05				db 4 + 1 
4117 .. 00			db "FIND",0              
411c				endm 
# End of macro CWHEAD
411c			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
411c			 
411c					if DEBUG_FORTH_WORDS_KEY 
411c						DMARK "FND" 
411c f5				push af  
411d 3a 31 41			ld a, (.dmark)  
4120 32 71 ee			ld (debug_mark),a  
4123 3a 32 41			ld a, (.dmark+1)  
4126 32 72 ee			ld (debug_mark+1),a  
4129 3a 33 41			ld a, (.dmark+2)  
412c 32 73 ee			ld (debug_mark+2),a  
412f 18 03			jr .pastdmark  
4131 ..			.dmark: db "FND"  
4134 f1			.pastdmark: pop af  
4135			endm  
# End of macro DMARK
4135						CALLMONITOR 
4135 cd ae 13			call break_point_state  
4138				endm  
# End of macro CALLMONITOR
4138					endif 
4138			 
4138			; TODO check string type 
4138					FORTH_DSP_VALUE 
4138 cd e8 1b			call macro_forth_dsp_value 
413b				endm 
# End of macro FORTH_DSP_VALUE
413b			 
413b e5					push hl    
413c 7e					ld a,(hl)    ; char to find   
413d			; TODO change char to substr 
413d			 
413d f5					push af 
413e					 
413e			 
413e			 
413e					if DEBUG_FORTH_WORDS 
413e						DMARK "FN1" 
413e f5				push af  
413f 3a 53 41			ld a, (.dmark)  
4142 32 71 ee			ld (debug_mark),a  
4145 3a 54 41			ld a, (.dmark+1)  
4148 32 72 ee			ld (debug_mark+1),a  
414b 3a 55 41			ld a, (.dmark+2)  
414e 32 73 ee			ld (debug_mark+2),a  
4151 18 03			jr .pastdmark  
4153 ..			.dmark: db "FN1"  
4156 f1			.pastdmark: pop af  
4157			endm  
# End of macro DMARK
4157						CALLMONITOR 
4157 cd ae 13			call break_point_state  
415a				endm  
# End of macro CALLMONITOR
415a					endif 
415a			 
415a					FORTH_DSP_POP 
415a cd b7 1c			call macro_forth_dsp_pop 
415d				endm 
# End of macro FORTH_DSP_POP
415d			 
415d					; string to search 
415d			 
415d					FORTH_DSP_VALUE 
415d cd e8 1b			call macro_forth_dsp_value 
4160				endm 
# End of macro FORTH_DSP_VALUE
4160			 
4160 d1					pop de  ; d is char to find  
4161			 
4161					if DEBUG_FORTH_WORDS 
4161						DMARK "FN2" 
4161 f5				push af  
4162 3a 76 41			ld a, (.dmark)  
4165 32 71 ee			ld (debug_mark),a  
4168 3a 77 41			ld a, (.dmark+1)  
416b 32 72 ee			ld (debug_mark+1),a  
416e 3a 78 41			ld a, (.dmark+2)  
4171 32 73 ee			ld (debug_mark+2),a  
4174 18 03			jr .pastdmark  
4176 ..			.dmark: db "FN2"  
4179 f1			.pastdmark: pop af  
417a			endm  
# End of macro DMARK
417a						CALLMONITOR 
417a cd ae 13			call break_point_state  
417d				endm  
# End of macro CALLMONITOR
417d					endif 
417d					 
417d 01 00 00				ld bc, 0 
4180 7e			.findchar:      ld a,(hl) 
4181 fe 00				cp 0   		 
4183 28 27				jr z, .finddone     
4185 ba					cp d 
4186 28 20				jr z, .foundchar 
4188 03					inc bc 
4189 23					inc hl 
418a					if DEBUG_FORTH_WORDS 
418a						DMARK "FN3" 
418a f5				push af  
418b 3a 9f 41			ld a, (.dmark)  
418e 32 71 ee			ld (debug_mark),a  
4191 3a a0 41			ld a, (.dmark+1)  
4194 32 72 ee			ld (debug_mark+1),a  
4197 3a a1 41			ld a, (.dmark+2)  
419a 32 73 ee			ld (debug_mark+2),a  
419d 18 03			jr .pastdmark  
419f ..			.dmark: db "FN3"  
41a2 f1			.pastdmark: pop af  
41a3			endm  
# End of macro DMARK
41a3						CALLMONITOR 
41a3 cd ae 13			call break_point_state  
41a6				endm  
# End of macro CALLMONITOR
41a6					endif 
41a6 18 d8				jr .findchar 
41a8			 
41a8			 
41a8 c5			.foundchar:	push bc 
41a9 e1					pop hl 
41aa 18 03				jr .findexit 
41ac			 
41ac			 
41ac							 
41ac			 
41ac			.finddone:     ; got to end of string with no find 
41ac 21 00 00				ld hl, 0 
41af			.findexit: 
41af			 
41af					if DEBUG_FORTH_WORDS 
41af						DMARK "FNd" 
41af f5				push af  
41b0 3a c4 41			ld a, (.dmark)  
41b3 32 71 ee			ld (debug_mark),a  
41b6 3a c5 41			ld a, (.dmark+1)  
41b9 32 72 ee			ld (debug_mark+1),a  
41bc 3a c6 41			ld a, (.dmark+2)  
41bf 32 73 ee			ld (debug_mark+2),a  
41c2 18 03			jr .pastdmark  
41c4 ..			.dmark: db "FNd"  
41c7 f1			.pastdmark: pop af  
41c8			endm  
# End of macro DMARK
41c8						CALLMONITOR 
41c8 cd ae 13			call break_point_state  
41cb				endm  
# End of macro CALLMONITOR
41cb					endif 
41cb cd 08 1a			call forth_push_numhl 
41ce			 
41ce				       NEXTW 
41ce c3 71 1d			jp macro_next 
41d1				endm 
# End of macro NEXTW
41d1			 
41d1			.LEN: 
41d1				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
41d1 4c				db WORD_SYS_CORE+56             
41d2 06 42			dw .CHAR            
41d4 06				db 5 + 1 
41d5 .. 00			db "COUNT",0              
41db				endm 
# End of macro CWHEAD
41db			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
41db			 
41db					if DEBUG_FORTH_WORDS_KEY 
41db						DMARK "CNT" 
41db f5				push af  
41dc 3a f0 41			ld a, (.dmark)  
41df 32 71 ee			ld (debug_mark),a  
41e2 3a f1 41			ld a, (.dmark+1)  
41e5 32 72 ee			ld (debug_mark+1),a  
41e8 3a f2 41			ld a, (.dmark+2)  
41eb 32 73 ee			ld (debug_mark+2),a  
41ee 18 03			jr .pastdmark  
41f0 ..			.dmark: db "CNT"  
41f3 f1			.pastdmark: pop af  
41f4			endm  
# End of macro DMARK
41f4						CALLMONITOR 
41f4 cd ae 13			call break_point_state  
41f7				endm  
# End of macro CALLMONITOR
41f7					endif 
41f7			; TODO check string type 
41f7					FORTH_DSP 
41f7 cd c5 1b			call macro_forth_dsp 
41fa				endm 
# End of macro FORTH_DSP
41fa					;v5FORTH_DSP_VALUE 
41fa			 
41fa 23					inc hl 
41fb			 
41fb 3e 00				ld a, 0 
41fd cd 16 10				call strlent 
4200			 
4200 cd 08 1a				call forth_push_numhl 
4203			 
4203			 
4203			 
4203				       NEXTW 
4203 c3 71 1d			jp macro_next 
4206				endm 
# End of macro NEXTW
4206			.CHAR: 
4206				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4206 4d				db WORD_SYS_CORE+57             
4207 3c 42			dw .ENDSTR            
4209 05				db 4 + 1 
420a .. 00			db "CHAR",0              
420f				endm 
# End of macro CWHEAD
420f			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
420f					if DEBUG_FORTH_WORDS_KEY 
420f						DMARK "CHR" 
420f f5				push af  
4210 3a 24 42			ld a, (.dmark)  
4213 32 71 ee			ld (debug_mark),a  
4216 3a 25 42			ld a, (.dmark+1)  
4219 32 72 ee			ld (debug_mark+1),a  
421c 3a 26 42			ld a, (.dmark+2)  
421f 32 73 ee			ld (debug_mark+2),a  
4222 18 03			jr .pastdmark  
4224 ..			.dmark: db "CHR"  
4227 f1			.pastdmark: pop af  
4228			endm  
# End of macro DMARK
4228						CALLMONITOR 
4228 cd ae 13			call break_point_state  
422b				endm  
# End of macro CALLMONITOR
422b					endif 
422b					FORTH_DSP 
422b cd c5 1b			call macro_forth_dsp 
422e				endm 
# End of macro FORTH_DSP
422e					;v5 FORTH_DSP_VALUE 
422e 23					inc hl      ; now at start of numeric as string 
422f			 
422f			;		push hl 
422f			 
422f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
422f cd b7 1c			call macro_forth_dsp_pop 
4232				endm 
# End of macro FORTH_DSP_POP
4232			 
4232			;		pop hl 
4232			 
4232					; push the content of a onto the stack as a value 
4232			 
4232 7e					ld a,(hl)   ; get char 
4233 26 00				ld h,0 
4235 6f					ld l,a 
4236 cd 08 1a				call forth_push_numhl 
4239			 
4239				       NEXTW 
4239 c3 71 1d			jp macro_next 
423c				endm 
# End of macro NEXTW
423c			 
423c			 
423c			 
423c			 
423c			.ENDSTR: 
423c			; eof 
423c			 
# End of file forth_words_str.asm
423c			include "forth_words_key.asm" 
423c			 
423c			; | ## Keyboard Words 
423c			 
423c			.KEY: 
423c				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
423c 3e				db WORD_SYS_CORE+42             
423d 6c 42			dw .WAITK            
423f 04				db 3 + 1 
4240 .. 00			db "KEY",0              
4244				endm 
# End of macro CWHEAD
4244			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4244			 
4244					if DEBUG_FORTH_WORDS_KEY 
4244						DMARK "KEY" 
4244 f5				push af  
4245 3a 59 42			ld a, (.dmark)  
4248 32 71 ee			ld (debug_mark),a  
424b 3a 5a 42			ld a, (.dmark+1)  
424e 32 72 ee			ld (debug_mark+1),a  
4251 3a 5b 42			ld a, (.dmark+2)  
4254 32 73 ee			ld (debug_mark+2),a  
4257 18 03			jr .pastdmark  
4259 ..			.dmark: db "KEY"  
425c f1			.pastdmark: pop af  
425d			endm  
# End of macro DMARK
425d						CALLMONITOR 
425d cd ae 13			call break_point_state  
4260				endm  
# End of macro CALLMONITOR
4260					endif 
4260			; TODO currently waits 
4260 cd 2d 59				call cin 
4263					;call cin_wait 
4263 6f					ld l, a 
4264 26 00				ld h, 0 
4266 cd 08 1a				call forth_push_numhl 
4269					NEXTW 
4269 c3 71 1d			jp macro_next 
426c				endm 
# End of macro NEXTW
426c			.WAITK: 
426c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
426c 3f				db WORD_SYS_CORE+43             
426d 9e 42			dw .ACCEPT            
426f 06				db 5 + 1 
4270 .. 00			db "WAITK",0              
4276				endm 
# End of macro CWHEAD
4276			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4276					if DEBUG_FORTH_WORDS_KEY 
4276						DMARK "WAI" 
4276 f5				push af  
4277 3a 8b 42			ld a, (.dmark)  
427a 32 71 ee			ld (debug_mark),a  
427d 3a 8c 42			ld a, (.dmark+1)  
4280 32 72 ee			ld (debug_mark+1),a  
4283 3a 8d 42			ld a, (.dmark+2)  
4286 32 73 ee			ld (debug_mark+2),a  
4289 18 03			jr .pastdmark  
428b ..			.dmark: db "WAI"  
428e f1			.pastdmark: pop af  
428f			endm  
# End of macro DMARK
428f						CALLMONITOR 
428f cd ae 13			call break_point_state  
4292				endm  
# End of macro CALLMONITOR
4292					endif 
4292 cd 25 59				call cin_wait 
4295 6f					ld l, a 
4296 26 00				ld h, 0 
4298 cd 08 1a				call forth_push_numhl 
429b					NEXTW 
429b c3 71 1d			jp macro_next 
429e				endm 
# End of macro NEXTW
429e			.ACCEPT: 
429e				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
429e 40				db WORD_SYS_CORE+44             
429f fc 42			dw .EDIT            
42a1 07				db 6 + 1 
42a2 .. 00			db "ACCEPT",0              
42a9				endm 
# End of macro CWHEAD
42a9			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
42a9					; TODO crashes on push 
42a9					if DEBUG_FORTH_WORDS_KEY 
42a9						DMARK "ACC" 
42a9 f5				push af  
42aa 3a be 42			ld a, (.dmark)  
42ad 32 71 ee			ld (debug_mark),a  
42b0 3a bf 42			ld a, (.dmark+1)  
42b3 32 72 ee			ld (debug_mark+1),a  
42b6 3a c0 42			ld a, (.dmark+2)  
42b9 32 73 ee			ld (debug_mark+2),a  
42bc 18 03			jr .pastdmark  
42be ..			.dmark: db "ACC"  
42c1 f1			.pastdmark: pop af  
42c2			endm  
# End of macro DMARK
42c2						CALLMONITOR 
42c2 cd ae 13			call break_point_state  
42c5				endm  
# End of macro CALLMONITOR
42c5					endif 
42c5 21 55 e5				ld hl, os_input 
42c8 3e 00				ld a, 0 
42ca 77					ld (hl),a 
42cb 3a 40 eb				ld a,(f_cursor_ptr) 
42ce 16 64				ld d, 100 
42d0 0e 00				ld c, 0 
42d2 1e 28				ld e, 40 
42d4 cd da 0b				call input_str 
42d7					; TODO perhaps do a type check and wrap in quotes if not a number 
42d7 21 55 e5				ld hl, os_input 
42da					if DEBUG_FORTH_WORDS 
42da						DMARK "AC1" 
42da f5				push af  
42db 3a ef 42			ld a, (.dmark)  
42de 32 71 ee			ld (debug_mark),a  
42e1 3a f0 42			ld a, (.dmark+1)  
42e4 32 72 ee			ld (debug_mark+1),a  
42e7 3a f1 42			ld a, (.dmark+2)  
42ea 32 73 ee			ld (debug_mark+2),a  
42ed 18 03			jr .pastdmark  
42ef ..			.dmark: db "AC1"  
42f2 f1			.pastdmark: pop af  
42f3			endm  
# End of macro DMARK
42f3						CALLMONITOR 
42f3 cd ae 13			call break_point_state  
42f6				endm  
# End of macro CALLMONITOR
42f6					endif 
42f6 cd 76 1a				call forth_push_str 
42f9					NEXTW 
42f9 c3 71 1d			jp macro_next 
42fc				endm 
# End of macro NEXTW
42fc			 
42fc			.EDIT: 
42fc				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
42fc 40				db WORD_SYS_CORE+44             
42fd 9e 43			dw .ENDKEY            
42ff 05				db 4 + 1 
4300 .. 00			db "EDIT",0              
4305				endm 
# End of macro CWHEAD
4305			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4305			 
4305					; TODO does not copy from stack 
4305					if DEBUG_FORTH_WORDS_KEY 
4305						DMARK "EDT" 
4305 f5				push af  
4306 3a 1a 43			ld a, (.dmark)  
4309 32 71 ee			ld (debug_mark),a  
430c 3a 1b 43			ld a, (.dmark+1)  
430f 32 72 ee			ld (debug_mark+1),a  
4312 3a 1c 43			ld a, (.dmark+2)  
4315 32 73 ee			ld (debug_mark+2),a  
4318 18 03			jr .pastdmark  
431a ..			.dmark: db "EDT"  
431d f1			.pastdmark: pop af  
431e			endm  
# End of macro DMARK
431e						CALLMONITOR 
431e cd ae 13			call break_point_state  
4321				endm  
# End of macro CALLMONITOR
4321					endif 
4321			 
4321					;FORTH_DSP 
4321					FORTH_DSP_VALUEHL 
4321 cd ff 1b			call macro_dsp_valuehl 
4324				endm 
# End of macro FORTH_DSP_VALUEHL
4324			;		inc hl    ; TODO do type check 
4324			 
4324			;		call get_word_hl 
4324 e5					push hl 
4325					if DEBUG_FORTH_WORDS 
4325						DMARK "EDp" 
4325 f5				push af  
4326 3a 3a 43			ld a, (.dmark)  
4329 32 71 ee			ld (debug_mark),a  
432c 3a 3b 43			ld a, (.dmark+1)  
432f 32 72 ee			ld (debug_mark+1),a  
4332 3a 3c 43			ld a, (.dmark+2)  
4335 32 73 ee			ld (debug_mark+2),a  
4338 18 03			jr .pastdmark  
433a ..			.dmark: db "EDp"  
433d f1			.pastdmark: pop af  
433e			endm  
# End of macro DMARK
433e						CALLMONITOR 
433e cd ae 13			call break_point_state  
4341				endm  
# End of macro CALLMONITOR
4341					endif 
4341				;	ld a, 0 
4341 cd 0b 10				call strlenz 
4344 23					inc hl 
4345			 
4345 06 00				ld b, 0 
4347 4d					ld c, l 
4348			 
4348 e1					pop hl 
4349 11 55 e5				ld de, os_input 
434c					if DEBUG_FORTH_WORDS_KEY 
434c						DMARK "EDc" 
434c f5				push af  
434d 3a 61 43			ld a, (.dmark)  
4350 32 71 ee			ld (debug_mark),a  
4353 3a 62 43			ld a, (.dmark+1)  
4356 32 72 ee			ld (debug_mark+1),a  
4359 3a 63 43			ld a, (.dmark+2)  
435c 32 73 ee			ld (debug_mark+2),a  
435f 18 03			jr .pastdmark  
4361 ..			.dmark: db "EDc"  
4364 f1			.pastdmark: pop af  
4365			endm  
# End of macro DMARK
4365						CALLMONITOR 
4365 cd ae 13			call break_point_state  
4368				endm  
# End of macro CALLMONITOR
4368					endif 
4368 ed b0				ldir 
436a			 
436a			 
436a 21 55 e5				ld hl, os_input 
436d					;ld a, 0 
436d					;ld (hl),a 
436d 3a 40 eb				ld a,(f_cursor_ptr) 
4370 16 64				ld d, 100 
4372 0e 00				ld c, 0 
4374 1e 28				ld e, 40 
4376 cd da 0b				call input_str 
4379					; TODO perhaps do a type check and wrap in quotes if not a number 
4379 21 55 e5				ld hl, os_input 
437c					if DEBUG_FORTH_WORDS 
437c						DMARK "ED1" 
437c f5				push af  
437d 3a 91 43			ld a, (.dmark)  
4380 32 71 ee			ld (debug_mark),a  
4383 3a 92 43			ld a, (.dmark+1)  
4386 32 72 ee			ld (debug_mark+1),a  
4389 3a 93 43			ld a, (.dmark+2)  
438c 32 73 ee			ld (debug_mark+2),a  
438f 18 03			jr .pastdmark  
4391 ..			.dmark: db "ED1"  
4394 f1			.pastdmark: pop af  
4395			endm  
# End of macro DMARK
4395						CALLMONITOR 
4395 cd ae 13			call break_point_state  
4398				endm  
# End of macro CALLMONITOR
4398					endif 
4398 cd 76 1a				call forth_push_str 
439b					NEXTW 
439b c3 71 1d			jp macro_next 
439e				endm 
# End of macro NEXTW
439e			 
439e			 
439e			 
439e			.ENDKEY: 
439e			; eof 
439e			 
# End of file forth_words_key.asm
439e			 
439e			if STORAGE_SE 
439e			   	include "forth_words_storage.asm" 
439e			endif 
439e				include "forth_words_device.asm" 
439e			; Device related words 
439e			 
439e			; | ## Device Words 
439e			 
439e			if SOUND_ENABLE 
439e			.NOTE: 
439e				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
439e			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
439e					if DEBUG_FORTH_WORDS_KEY 
439e						DMARK "NTE" 
439e						CALLMONITOR 
439e					endif 
439e			 
439e				 
439e			 
439e					NEXTW 
439e			.AFTERSOUND: 
439e			endif 
439e			 
439e			 
439e			USE_GPIO: equ 0 
439e			 
439e			if USE_GPIO 
439e			.GP1: 
439e				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
439e			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
439e					NEXTW 
439e			.GP2: 
439e				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
439e			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
439e			 
439e					NEXTW 
439e			 
439e			.GP3: 
439e				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
439e			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
439e			 
439e					NEXTW 
439e			 
439e			.GP4: 
439e				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
439e			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
439e			 
439e					NEXTW 
439e			.SIN: 
439e			 
439e			 
439e			endif 
439e			 
439e			 
439e				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
439e 33				db WORD_SYS_CORE+31             
439f d3 43			dw .SOUT            
43a1 03				db 2 + 1 
43a2 .. 00			db "IN",0              
43a5				endm 
# End of macro CWHEAD
43a5			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
43a5					if DEBUG_FORTH_WORDS_KEY 
43a5						DMARK "IN." 
43a5 f5				push af  
43a6 3a ba 43			ld a, (.dmark)  
43a9 32 71 ee			ld (debug_mark),a  
43ac 3a bb 43			ld a, (.dmark+1)  
43af 32 72 ee			ld (debug_mark+1),a  
43b2 3a bc 43			ld a, (.dmark+2)  
43b5 32 73 ee			ld (debug_mark+2),a  
43b8 18 03			jr .pastdmark  
43ba ..			.dmark: db "IN."  
43bd f1			.pastdmark: pop af  
43be			endm  
# End of macro DMARK
43be						CALLMONITOR 
43be cd ae 13			call break_point_state  
43c1				endm  
# End of macro CALLMONITOR
43c1					endif 
43c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43c1 cd ff 1b			call macro_dsp_valuehl 
43c4				endm 
# End of macro FORTH_DSP_VALUEHL
43c4			 
43c4 e5					push hl 
43c5			 
43c5					; destroy value TOS 
43c5			 
43c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43c5 cd b7 1c			call macro_forth_dsp_pop 
43c8				endm 
# End of macro FORTH_DSP_POP
43c8			 
43c8					; one value on hl get other one back 
43c8			 
43c8 c1					pop bc 
43c9			 
43c9					; do the sub 
43c9			;		ex de, hl 
43c9			 
43c9 ed 68				in l,(c) 
43cb			 
43cb					; save it 
43cb			 
43cb 26 00				ld h,0 
43cd			 
43cd					; TODO push value back onto stack for another op etc 
43cd			 
43cd cd 08 1a				call forth_push_numhl 
43d0					NEXTW 
43d0 c3 71 1d			jp macro_next 
43d3				endm 
# End of macro NEXTW
43d3			.SOUT: 
43d3				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
43d3 34				db WORD_SYS_CORE+32             
43d4 26 44			dw .SPIO            
43d6 04				db 3 + 1 
43d7 .. 00			db "OUT",0              
43db				endm 
# End of macro CWHEAD
43db			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
43db					if DEBUG_FORTH_WORDS_KEY 
43db						DMARK "OUT" 
43db f5				push af  
43dc 3a f0 43			ld a, (.dmark)  
43df 32 71 ee			ld (debug_mark),a  
43e2 3a f1 43			ld a, (.dmark+1)  
43e5 32 72 ee			ld (debug_mark+1),a  
43e8 3a f2 43			ld a, (.dmark+2)  
43eb 32 73 ee			ld (debug_mark+2),a  
43ee 18 03			jr .pastdmark  
43f0 ..			.dmark: db "OUT"  
43f3 f1			.pastdmark: pop af  
43f4			endm  
# End of macro DMARK
43f4						CALLMONITOR 
43f4 cd ae 13			call break_point_state  
43f7				endm  
# End of macro CALLMONITOR
43f7					endif 
43f7			 
43f7					; get port 
43f7			 
43f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43f7 cd ff 1b			call macro_dsp_valuehl 
43fa				endm 
# End of macro FORTH_DSP_VALUEHL
43fa			 
43fa e5					push hl 
43fb			 
43fb					; destroy value TOS 
43fb			 
43fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43fb cd b7 1c			call macro_forth_dsp_pop 
43fe				endm 
# End of macro FORTH_DSP_POP
43fe			 
43fe					; get byte to send 
43fe			 
43fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43fe cd ff 1b			call macro_dsp_valuehl 
4401				endm 
# End of macro FORTH_DSP_VALUEHL
4401			 
4401			;		push hl 
4401			 
4401					; destroy value TOS 
4401			 
4401					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4401 cd b7 1c			call macro_forth_dsp_pop 
4404				endm 
# End of macro FORTH_DSP_POP
4404			 
4404					; one value on hl get other one back 
4404			 
4404			;		pop hl 
4404			 
4404 c1					pop bc 
4405			 
4405					if DEBUG_FORTH_WORDS 
4405						DMARK "OUT" 
4405 f5				push af  
4406 3a 1a 44			ld a, (.dmark)  
4409 32 71 ee			ld (debug_mark),a  
440c 3a 1b 44			ld a, (.dmark+1)  
440f 32 72 ee			ld (debug_mark+1),a  
4412 3a 1c 44			ld a, (.dmark+2)  
4415 32 73 ee			ld (debug_mark+2),a  
4418 18 03			jr .pastdmark  
441a ..			.dmark: db "OUT"  
441d f1			.pastdmark: pop af  
441e			endm  
# End of macro DMARK
441e						CALLMONITOR 
441e cd ae 13			call break_point_state  
4421				endm  
# End of macro CALLMONITOR
4421					endif 
4421			 
4421 ed 69				out (c), l 
4423			 
4423					NEXTW 
4423 c3 71 1d			jp macro_next 
4426				endm 
# End of macro NEXTW
4426			 
4426			 
4426			.SPIO: 
4426			 
4426			if STORAGE_SE 
4426				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4426			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4426			 
4426					call spi_ce_low 
4426			    NEXTW 
4426			 
4426			.SPICEH: 
4426				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4426			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4426			 
4426					call spi_ce_high 
4426			    NEXTW 
4426			 
4426			 
4426			.SPIOb: 
4426			 
4426				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4426			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4426			 
4426					; get port 
4426			 
4426			 
4426					; get byte to send 
4426			 
4426					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4426			 
4426			;		push hl    ; u1  
4426			 
4426					; destroy value TOS 
4426			 
4426					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4426			 
4426					; one value on hl get other one back 
4426			 
4426			;		pop hl   ; u2 - addr 
4426			 
4426					; TODO Send SPI byte 
4426			 
4426					ld a, l 
4426					call spi_send_byte 
4426			 
4426					NEXTW 
4426			 
4426			.SPII: 
4426				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4426			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4426			 
4426					; TODO Get SPI byte 
4426			 
4426					call spi_read_byte 
4426			 
4426					ld h, 0 
4426					ld l, a 
4426					call forth_push_numhl 
4426			 
4426					NEXTW 
4426			 
4426			 
4426			 
4426			.SESEL: 
4426				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4426			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4426					if DEBUG_FORTH_WORDS_KEY 
4426						DMARK "BNK" 
4426						CALLMONITOR 
4426					endif 
4426			 
4426					ld a, 255 
4426					ld (spi_cartdev), a 
4426			 
4426					; get bank 
4426			 
4426					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4426			 
4426			;		push hl 
4426			 
4426					; destroy value TOS 
4426			 
4426					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4426			 
4426					; one value on hl get other one back 
4426			 
4426			;		pop hl 
4426			 
4426			 
4426					ld c, SPI_CE_HIGH 
4426					ld b, '0'    ; human readable bank number 
4426			 
4426					ld a, l 
4426			 
4426					if DEBUG_FORTH_WORDS 
4426						DMARK "BNK" 
4426						CALLMONITOR 
4426					endif 
4426			 
4426					; active low 
4426			 
4426					cp 0 
4426					jr z, .bset 
4426					cp 1 
4426					jr nz, .b2 
4426					res 0, c 
4426					ld b, '1'    ; human readable bank number 
4426			.b2:		cp 2 
4426					jr nz, .b3 
4426					res 1, c 
4426					ld b, '2'    ; human readable bank number 
4426			.b3:		cp 3 
4426					jr nz, .b4 
4426					res 2, c 
4426					ld b, '3'    ; human readable bank number 
4426			.b4:		cp 4 
4426					jr nz, .b5 
4426					res 3, c 
4426					ld b, '4'    ; human readable bank number 
4426			.b5:		cp 5 
4426					jr nz, .bset 
4426					res 4, c 
4426					ld b, '5'    ; human readable bank number 
4426			 
4426			.bset: 
4426					ld a, c 
4426					ld (spi_device),a 
4426					ld a, b 
4426					ld (spi_device_id),a 
4426					if DEBUG_FORTH_WORDS 
4426						DMARK "BN2" 
4426						CALLMONITOR 
4426					endif 
4426			 
4426					NEXTW 
4426			 
4426			.CARTDEV: 
4426				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4426			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4426					if DEBUG_FORTH_WORDS_KEY 
4426						DMARK "CDV" 
4426						CALLMONITOR 
4426					endif 
4426			 
4426					; disable se storage bank selection 
4426			 
4426					ld a, SPI_CE_HIGH		; ce high 
4426					ld (spi_device), a 
4426			 
4426					; get bank 
4426			 
4426					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4426			 
4426			;		push hl 
4426			 
4426					; destroy value TOS 
4426			 
4426					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4426			 
4426					; one value on hl get other one back 
4426			 
4426			;		pop hl 
4426			 
4426					; active low 
4426			 
4426					ld c, 255 
4426			 
4426					ld a, l 
4426					if DEBUG_FORTH_WORDS 
4426						DMARK "CDV" 
4426						CALLMONITOR 
4426					endif 
4426					cp 0 
4426					jr z, .cset 
4426					cp 1 
4426					jr nz, .c2 
4426					res 0, c 
4426			.c2:		cp 2 
4426					jr nz, .c3 
4426					res 1, c 
4426			.c3:		cp 3 
4426					jr nz, .c4 
4426					res 2, c 
4426			.c4:		cp 4 
4426					jr nz, .c5 
4426					res 3, c 
4426			.c5:		cp 5 
4426					jr nz, .c6 
4426					res 4, c 
4426			.c6:		cp 6 
4426					jr nz, .c7 
4426					res 5, c 
4426			.c7:		cp 7 
4426					jr nz, .c8 
4426					res 6, c 
4426			.c8:		cp 8 
4426					jr nz, .cset 
4426					res 7, c 
4426			.cset:		ld a, c 
4426					ld (spi_cartdev),a 
4426			 
4426					if DEBUG_FORTH_WORDS 
4426						DMARK "CD2" 
4426						CALLMONITOR 
4426					endif 
4426					NEXTW 
4426			endif 
4426			 
4426			.ENDDEVICE: 
4426			; eof 
4426			 
# End of file forth_words_device.asm
4426			 
4426			; var handler 
4426			 
4426			 
4426			.VARS: 
4426				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4426 78				db WORD_SYS_CORE+100             
4427 3e 44			dw .V0Q            
4429 04				db 3 + 1 
442a .. 00			db "V0!",0              
442e				endm 
# End of macro CWHEAD
442e			;| V0! ( u1 -- )  Store value to v0  | DONE 
442e			 
442e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
442e cd ff 1b			call macro_dsp_valuehl 
4431				endm 
# End of macro FORTH_DSP_VALUEHL
4431			 
4431 11 0a eb				ld de, cli_var_array 
4434			 
4434 eb					ex de, hl 
4435 73					ld (hl), e 
4436 23					inc hl 
4437 72					ld (hl), d 
4438			 
4438					; destroy value TOS 
4438			 
4438					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4438 cd b7 1c			call macro_forth_dsp_pop 
443b				endm 
# End of macro FORTH_DSP_POP
443b			 
443b				       NEXTW 
443b c3 71 1d			jp macro_next 
443e				endm 
# End of macro NEXTW
443e			.V0Q: 
443e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
443e 79				db WORD_SYS_CORE+101             
443f 4f 44			dw .V1S            
4441 04				db 3 + 1 
4442 .. 00			db "V0@",0              
4446				endm 
# End of macro CWHEAD
4446			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4446 2a 0a eb				ld hl, (cli_var_array) 
4449 cd 08 1a				call forth_push_numhl 
444c			 
444c				       NEXTW 
444c c3 71 1d			jp macro_next 
444f				endm 
# End of macro NEXTW
444f			.V1S: 
444f				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
444f 7a				db WORD_SYS_CORE+102             
4450 67 44			dw .V1Q            
4452 04				db 3 + 1 
4453 .. 00			db "V1!",0              
4457				endm 
# End of macro CWHEAD
4457			;| V1! ( u1 -- )  Store value to v1 | DONE 
4457					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4457 cd ff 1b			call macro_dsp_valuehl 
445a				endm 
# End of macro FORTH_DSP_VALUEHL
445a			 
445a 11 0c eb				ld de, cli_var_array+2 
445d				 
445d eb					ex de, hl 
445e 73					ld (hl), e 
445f 23					inc hl 
4460 72					ld (hl), d 
4461			 
4461					; destroy value TOS 
4461			 
4461					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4461 cd b7 1c			call macro_forth_dsp_pop 
4464				endm 
# End of macro FORTH_DSP_POP
4464				       NEXTW 
4464 c3 71 1d			jp macro_next 
4467				endm 
# End of macro NEXTW
4467			.V1Q: 
4467				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4467 7b				db WORD_SYS_CORE+103             
4468 78 44			dw .V2S            
446a 04				db 3 + 1 
446b .. 00			db "V1@",0              
446f				endm 
# End of macro CWHEAD
446f			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
446f 2a 0c eb				ld hl, (cli_var_array+2) 
4472 cd 08 1a				call forth_push_numhl 
4475				       NEXTW 
4475 c3 71 1d			jp macro_next 
4478				endm 
# End of macro NEXTW
4478			.V2S: 
4478				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4478 7c				db WORD_SYS_CORE+104             
4479 90 44			dw .V2Q            
447b 04				db 3 + 1 
447c .. 00			db "V2!",0              
4480				endm 
# End of macro CWHEAD
4480			;| V2! ( u1 -- )  Store value to v2 | DONE 
4480					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4480 cd ff 1b			call macro_dsp_valuehl 
4483				endm 
# End of macro FORTH_DSP_VALUEHL
4483			 
4483 11 0e eb				ld de, cli_var_array+4 
4486				 
4486 eb					ex de, hl 
4487 73					ld (hl), e 
4488 23					inc hl 
4489 72					ld (hl), d 
448a			 
448a					; destroy value TOS 
448a			 
448a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
448a cd b7 1c			call macro_forth_dsp_pop 
448d				endm 
# End of macro FORTH_DSP_POP
448d				       NEXTW 
448d c3 71 1d			jp macro_next 
4490				endm 
# End of macro NEXTW
4490			.V2Q: 
4490				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4490 7d				db WORD_SYS_CORE+105             
4491 a1 44			dw .V3S            
4493 04				db 3 + 1 
4494 .. 00			db "V2@",0              
4498				endm 
# End of macro CWHEAD
4498			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4498 2a 0e eb				ld hl, (cli_var_array+4) 
449b cd 08 1a				call forth_push_numhl 
449e				       NEXTW 
449e c3 71 1d			jp macro_next 
44a1				endm 
# End of macro NEXTW
44a1			.V3S: 
44a1				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
44a1 7c				db WORD_SYS_CORE+104             
44a2 b9 44			dw .V3Q            
44a4 04				db 3 + 1 
44a5 .. 00			db "V3!",0              
44a9				endm 
# End of macro CWHEAD
44a9			;| V3! ( u1 -- )  Store value to v3 | DONE 
44a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44a9 cd ff 1b			call macro_dsp_valuehl 
44ac				endm 
# End of macro FORTH_DSP_VALUEHL
44ac			 
44ac 11 10 eb				ld de, cli_var_array+6 
44af				 
44af eb					ex de, hl 
44b0 73					ld (hl), e 
44b1 23					inc hl 
44b2 72					ld (hl), d 
44b3			 
44b3					; destroy value TOS 
44b3			 
44b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b3 cd b7 1c			call macro_forth_dsp_pop 
44b6				endm 
# End of macro FORTH_DSP_POP
44b6				       NEXTW 
44b6 c3 71 1d			jp macro_next 
44b9				endm 
# End of macro NEXTW
44b9			.V3Q: 
44b9				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
44b9 7d				db WORD_SYS_CORE+105             
44ba ca 44			dw .END            
44bc 04				db 3 + 1 
44bd .. 00			db "V3@",0              
44c1				endm 
# End of macro CWHEAD
44c1			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
44c1 2a 10 eb				ld hl, (cli_var_array+6) 
44c4 cd 08 1a				call forth_push_numhl 
44c7				       NEXTW 
44c7 c3 71 1d			jp macro_next 
44ca				endm 
# End of macro NEXTW
44ca			 
44ca			 
44ca			 
44ca			 
44ca			 
44ca			; end of dict marker 
44ca			 
44ca 00			.END:    db WORD_SYS_END 
44cb 00 00			dw 0 
44cd 00				db 0 
44ce			 
44ce			; use to jp here for user dict words to save on macro expansion  
44ce			 
44ce			user_dict_next: 
44ce				NEXTW 
44ce c3 71 1d			jp macro_next 
44d1				endm 
# End of macro NEXTW
44d1			 
44d1			 
44d1			user_exec: 
44d1				;    ld hl, <word code> 
44d1				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
44d1				;    call forthexec 
44d1				;    jp user_dict_next   (NEXT) 
44d1			        ;    <word code bytes> 
44d1 eb				ex de, hl 
44d2 2a 58 e6			ld hl,(os_tok_ptr) 
44d5				 
44d5				FORTH_RSP_NEXT 
44d5 cd af 19			call macro_forth_rsp_next 
44d8				endm 
# End of macro FORTH_RSP_NEXT
44d8			 
44d8			if DEBUG_FORTH_UWORD 
44d8						DMARK "UEX" 
44d8 f5				push af  
44d9 3a ed 44			ld a, (.dmark)  
44dc 32 71 ee			ld (debug_mark),a  
44df 3a ee 44			ld a, (.dmark+1)  
44e2 32 72 ee			ld (debug_mark+1),a  
44e5 3a ef 44			ld a, (.dmark+2)  
44e8 32 73 ee			ld (debug_mark+2),a  
44eb 18 03			jr .pastdmark  
44ed ..			.dmark: db "UEX"  
44f0 f1			.pastdmark: pop af  
44f1			endm  
# End of macro DMARK
44f1				CALLMONITOR 
44f1 cd ae 13			call break_point_state  
44f4				endm  
# End of macro CALLMONITOR
44f4			endif 
44f4			 
44f4			 
44f4			 
44f4 eb				ex de, hl 
44f5 22 58 e6			ld (os_tok_ptr), hl 
44f8				 
44f8				; Don't use next - Skips the first word in uword. 
44f8			 
44f8 c3 02 1e			jp exec1 
44fb			;	NEXT 
44fb			 
44fb			 
44fb			; eof 
# End of file forth_wordsv4.asm
44fb			endif 
44fb			;;;;;;;;;;;;;; Debug code 
44fb			 
44fb			 
44fb			;if DEBUG_FORTH_PARSE 
44fb .. 00		.nowordfound: db "No match",0 
4504 .. 00		.compword:	db "Comparing word ",0 
4514 .. 00		.nextwordat:	db "Next word at",0 
4521 .. 00		.charmatch:	db "Char match",0 
452c			;endif 
452c			if DEBUG_FORTH_JP 
452c			.foundword:	db "Word match. Exec..",0 
452c			endif 
452c			;if DEBUG_FORTH_PUSH 
452c .. 00		.enddict:	db "Dict end. Push.",0 
453c .. 00		.push_str:	db "Pushing string",0 
454b .. 00		.push_num:	db "Pushing number",0 
455a .. 00		.data_sp:	db "SP:",0 
455e .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4570 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4582 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4594			;endif 
4594			;if DEBUG_FORTH_MALLOC 
4594 .. 00		.push_malloc:	db "Malloc address",0 
45a3			;endif 
45a3			 
45a3			 
45a3			 
45a3			; display malloc address and current data stack pointer  
45a3			 
45a3			malloc_error: 
45a3 d5				push de 
45a4 f5				push af 
45a5 e5				push hl 
45a6 cd 80 09			call clear_display 
45a9 11 cb 45			ld de, .mallocerr 
45ac 3e 00			ld a,0 
45ae			;	ld de,os_word_scratch 
45ae cd 93 09			call str_at_display 
45b1 3e 11			ld a, display_row_1+17 
45b3 11 71 ee			ld de, debug_mark 
45b6 cd 93 09			call str_at_display 
45b9 cd a3 09			call update_display 
45bc				;call break_point_state 
45bc cd 25 59			call cin_wait 
45bf			 
45bf 3e 20			ld a, ' ' 
45c1 32 48 e3			ld (os_view_disable), a 
45c4 e1				pop hl 
45c5 f1				pop af 
45c6 d1				pop de	 
45c7				CALLMONITOR 
45c7 cd ae 13			call break_point_state  
45ca				endm  
# End of macro CALLMONITOR
45ca c9				ret 
45cb			 
45cb .. 00		.mallocerr: 	db "Malloc Error",0 
45d8			;if DEBUG_FORTH_PUSH 
45d8			display_data_sp: 
45d8 f5				push af 
45d9			 
45d9				; see if disabled 
45d9			 
45d9 3a 48 e3			ld a, (os_view_disable) 
45dc fe 2a			cp '*' 
45de 28 67			jr z, .skipdsp 
45e0			 
45e0 e5				push hl 
45e1 e5				push hl 
45e2 e5			push hl 
45e3 cd 80 09			call clear_display 
45e6 e1			pop hl 
45e7 7c				ld a,h 
45e8 21 5c e6			ld hl, os_word_scratch 
45eb cd ae 0e			call hexout 
45ee e1				pop hl 
45ef 7d				ld a,l 
45f0 21 5e e6			ld hl, os_word_scratch+2 
45f3 cd ae 0e			call hexout 
45f6 21 60 e6			ld hl, os_word_scratch+4 
45f9 3e 00			ld a,0 
45fb 77				ld (hl),a 
45fc 11 5c e6			ld de,os_word_scratch 
45ff 3e 28				ld a, display_row_2 
4601 cd 93 09				call str_at_display 
4604 11 5e 45			ld de, .wordinhl 
4607 3e 00			ld a, display_row_1 
4609			 
4609 cd 93 09				call str_at_display 
460c 11 71 ee			ld de, debug_mark 
460f 3e 11			ld a, display_row_1+17 
4611			 
4611 cd 93 09				call str_at_display 
4614			 
4614				; display current data stack pointer 
4614 11 5a 45			ld de,.data_sp 
4617 3e 30				ld a, display_row_2 + 8 
4619 cd 93 09				call str_at_display 
461c			 
461c 2a 04 eb			ld hl,(cli_data_sp) 
461f e5				push hl 
4620 7c				ld a,h 
4621 21 5c e6			ld hl, os_word_scratch 
4624 cd ae 0e			call hexout 
4627 e1				pop hl 
4628 7d				ld a,l 
4629 21 5e e6			ld hl, os_word_scratch+2 
462c cd ae 0e			call hexout 
462f 21 60 e6			ld hl, os_word_scratch+4 
4632 3e 00			ld a,0 
4634 77				ld (hl),a 
4635 11 5c e6			ld de,os_word_scratch 
4638 3e 33				ld a, display_row_2 + 11 
463a cd 93 09				call str_at_display 
463d			 
463d			 
463d cd a3 09			call update_display 
4640 cd f2 08			call delay1s 
4643 cd f2 08			call delay1s 
4646 e1				pop hl 
4647			.skipdsp: 
4647 f1				pop af 
4648 c9				ret 
4649			 
4649			display_data_malloc: 
4649			 
4649 f5				push af 
464a e5				push hl 
464b e5				push hl 
464c e5			push hl 
464d cd 80 09			call clear_display 
4650 e1			pop hl 
4651 7c				ld a,h 
4652 21 5c e6			ld hl, os_word_scratch 
4655 cd ae 0e			call hexout 
4658 e1				pop hl 
4659 7d				ld a,l 
465a 21 5e e6			ld hl, os_word_scratch+2 
465d cd ae 0e			call hexout 
4660 21 60 e6			ld hl, os_word_scratch+4 
4663 3e 00			ld a,0 
4665 77				ld (hl),a 
4666 11 5c e6			ld de,os_word_scratch 
4669 3e 28				ld a, display_row_2 
466b cd 93 09				call str_at_display 
466e 11 94 45			ld de, .push_malloc 
4671 3e 00			ld a, display_row_1 
4673			 
4673 cd 93 09				call str_at_display 
4676			 
4676				; display current data stack pointer 
4676 11 5a 45			ld de,.data_sp 
4679 3e 30				ld a, display_row_2 + 8 
467b cd 93 09				call str_at_display 
467e			 
467e 2a 04 eb			ld hl,(cli_data_sp) 
4681 e5				push hl 
4682 7c				ld a,h 
4683 21 5c e6			ld hl, os_word_scratch 
4686 cd ae 0e			call hexout 
4689 e1				pop hl 
468a 7d				ld a,l 
468b 21 5e e6			ld hl, os_word_scratch+2 
468e cd ae 0e			call hexout 
4691 21 60 e6			ld hl, os_word_scratch+4 
4694 3e 00			ld a,0 
4696 77				ld (hl),a 
4697 11 5c e6			ld de,os_word_scratch 
469a 3e 33				ld a, display_row_2 + 11 
469c cd 93 09				call str_at_display 
469f			 
469f cd a3 09			call update_display 
46a2 cd f2 08			call delay1s 
46a5 cd f2 08			call delay1s 
46a8 e1				pop hl 
46a9 f1				pop af 
46aa c9				ret 
46ab			;endif 
46ab			 
46ab			include "forth_autostart.asm" 
46ab			; list of commands to perform at system start up 
46ab			 
46ab			startcmds: 
46ab			;	dw test11 
46ab			;	dw test12 
46ab			;	dw test13 
46ab			;	dw test14 
46ab			;	dw test15 
46ab			;	dw test16 
46ab			;	dw test17 
46ab			;	dw ifthtest1 
46ab			;	dw ifthtest2 
46ab			;	dw ifthtest3 
46ab			;	dw mmtest1 
46ab			;	dw mmtest2 
46ab			;	dw mmtest3 
46ab			;	dw mmtest4 
46ab			;	dw mmtest5 
46ab			;	dw mmtest6 
46ab			;	dw iftest1 
46ab			;	dw iftest2 
46ab			;	dw iftest3 
46ab			;	dw looptest1 
46ab			;	dw looptest2 
46ab			;	dw test1 
46ab			;	dw test2 
46ab			;	dw test3 
46ab			;	dw test4 
46ab			;	dw game2r 
46ab			;	dw game2b1 
46ab			;	dw game2b2 
46ab			 
46ab				; start up words that are actually useful 
46ab			 
46ab 09 47			dw clrstack 
46ad 3c 47			dw type 
46af fd 48			dw stest 
46b1 60 47			dw strncpy 
46b3 9e 48			dw list 
46b5 c1 47			dw start1 
46b7 d3 47			dw start2 
46b9			;	dw start3 
46b9 e6 47			dw start3b 
46bb 3e 48			dw start3c 
46bd			 
46bd				; (unit) testing words 
46bd			 
46bd 74 49			dw mtesta 
46bf 29 4a			dw mtestb 
46c1 cc 4a			dw mtestc 
46c3 81 4b			dw mtestd 
46c5 25 4c			dw mteste 
46c7			 
46c7				; demo/game words 
46c7			 
46c7 31 53		        dw game3w 
46c9 5f 53		        dw game3p 
46cb 7d 53		        dw game3sc 
46cd ae 53		        dw game3vsi 
46cf da 53		        dw game3vs 
46d1				 
46d1 24 51			dw game2b 
46d3 92 51			dw game2bf 
46d5 dc 51			dw game2mba 
46d7 72 52			dw game2mbas 
46d9 b4 52			dw game2mb 
46db			 
46db e5 4d			dw game1 
46dd f6 4d			dw game1a 
46df 58 4e			dw game1b 
46e1 8d 4e			dw game1c 
46e3 c3 4e			dw game1d 
46e5 f4 4e			dw game1s 
46e7 08 4f			dw game1t 
46e9 1d 4f			dw game1f 
46eb 51 4f			dw game1z 
46ed 95 4f			dw game1zz 
46ef			 
46ef db 4c			dw test5 
46f1 13 4d			dw test6 
46f3 4b 4d			dw test7 
46f5 5f 4d			dw test8 
46f7 8b 4d			dw test9 
46f9 a1 4d			dw test10 
46fb				 
46fb 6c 50		        dw ssv5 
46fd 50 50		        dw ssv4 
46ff 34 50		        dw ssv3 
4701 fe 4f		        dw ssv2 
4703 85 50		        dw ssv1 
4705 cd 50		        dw ssv1cpm 
4707			;	dw keyup 
4707			;	dw keydown 
4707			;	dw keyleft 
4707			;	dw keyright 
4707			;	dw 	keyf1 
4707			;	dw keyf2 
4707			;	dw keyf3 
4707			;	dw keyf4 
4707			;	dw keyf5 
4707			;	dw keyf6 
4707			;	dw keyf7 
4707			;	dw keyf8 
4707			;	dw keyf9 
4707			;	dw keyf10 
4707			;	dw keyf11 
4707			;	dw keyf12 
4707			;	dw keytab 
4707			;	dw keycr 
4707			;	dw keyhome 
4707			;	dw keyend 
4707			;	dw keybs 
4707 00 00			db 0, 0	 
4709			 
4709			 
4709			; clear stack  
4709			 
4709 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
473c			 
473c			; type ( addr count - ) 
473c .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4760			 
4760			; some direct memory words 
4760			; strncpy ( len t f -- t ) 
4760			 
4760 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
47c1			 
47c1 .. 00		start1:     	db ": bpon $0000 bp ;",0 
47d3 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
47e6			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
47e6 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
483e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
489e			 
489e			 
489e			; a handy word to list items on the stack 
489e			 
489e .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
48fd			 
48fd			 
48fd			; test stack  
48fd			; rnd8 stest 
48fd			 
48fd .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4974			 
4974			; random malloc and free cycles 
4974			 
4974 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4a29			 
4a29			; fixed malloc and free cycles 
4a29			 
4a29 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4acc			 
4acc			; fixed double string push and drop cycle  
4acc			 
4acc .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4b81			 
4b81			; consistent fixed string push and drop cycle  
4b81			 
4b81 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4c25			 
4c25 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4cdb			 
4cdb			;test1:		db ": aa 1 2 3 ;", 0 
4cdb			;test2:     	db "111 aa 888 999",0 
4cdb			;test3:     	db ": bb 77 ;",0 
4cdb			;test4:     	db "$02 $01 do i . loop bb",0 
4cdb			 
4cdb .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4d13 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4d4b .. 00		test7:     	db ": box hline vline ;",0 
4d5f .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4d8b .. 00		test9:     	db ": sw $01 adsp world ;",0 
4da1 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4dc6 .. 00		test11:     	db "hello create .",0 
4dd5 .. 00		test12:     	db "hello2 create .",0 
4de5			 
4de5			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4de5			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4de5			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4de5			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4de5			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4de5			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4de5			 
4de5			;iftest1:     	db "$0001 IF cls .",0 
4de5			;iftest2:     	db "$0000 IF cls .",0 
4de5			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4de5			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4de5			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4de5			 
4de5			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4de5			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4de5			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4de5			 
4de5			 
4de5			 
4de5			; a small guess the number game 
4de5			 
4de5 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4df6 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4e58			 
4e58 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4e8d .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4ec3 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4ef4 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
4f08 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
4f1d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
4f51 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
4f95			 
4f95			; Using 'ga' save a high score across multiple runs using external storage 
4f95			 
4f95 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
4ffe			 
4ffe			 
4ffe			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
4ffe			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
4ffe			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
4ffe			 
4ffe			; simple screen saver to test code memory reuse to destruction 
4ffe			 
4ffe .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5034 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5050 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
506c .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5085 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
50cd .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5124			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5124			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5124			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5124			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5124			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5124			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5124			 
5124			 
5124			 
5124			; minesweeper/battleship finding game 
5124			; draws a game board of random ship/mine positions 
5124			; user enters coords to see if it hits on 
5124			; game ends when all are hit 
5124			; when hit or miss says how many may be in the area 
5124			 
5124			; setup the game board and then hide it 
5124 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5192 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
51dc			; prompt for where to target 
51dc .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5272 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5297			; TODO see if the entered coords hits or misses pushes char hit of miss 
5297 .. 00		game2mbht:      db ": mbckht nop ;",0 
52a6 .. 00		game2mbms:      db ": mbcms nop ;",0 
52b4			; TODO how many might be near by 
52b4 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5331			 
5331			; Game 3 
5331			 
5331			; Vert scroller ski game - avoid the trees! 
5331			 
5331			; v0 score (ie turns) 
5331			; v1 player pos 
5331			; v2 left wall 
5331			; v3 right wall 
5331			 
5331			; Draw side walls randomly 
5331			 
5331 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
535f			 
535f			; Draw player 
535f .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
537d			 
537d			; TODO Get Key 
537d			 
537d			; TODO Move left right 
537d			 
537d			; scroll and move walls a bit 
537d			 
537d .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
53ae			 
53ae			; main game loop 
53ae			 
53ae .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
53da .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5419			 
5419			; key board defs 
5419			 
5419 .. 00		keyup:       db ": keyup $05 ;",0 
5427 .. 00		keydown:       db ": keydown $0a ;",0 
5437 .. 00		keyleft:       db ": keyleft $0b ;",0 
5447 .. 00		keyright:       db ": keyright $0c ;",0 
5458 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5466 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5474 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5482 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5490 .. 00		keyf5:       db ": keyf5 $14 ;",0 
549e .. 00		keyf6:       db ": keyf6 $15 ;",0 
54ac .. 00		keyf7:       db ": keyf7 $16 ;",0 
54ba .. 00		keyf8:       db ": keyf8 $17 ;",0 
54c8 .. 00		keyf9:       db ": keyf9 $18 ;",0 
54d6 .. 00		keyf10:       db ": keyf10 $19 ;",0 
54e5 .. 00		keyf11:       db ": keyf11 $1a ;",0 
54f4 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5503			 
5503 .. 00		keytab:       db ": keytab $09 ;",0 
5512 .. 00		keycr:       db ": keycr $0d ;",0 
5520 .. 00		keyhome:       db ": keyhome $0e ;",0 
5530 .. 00		keyend:       db ": keyend $0f ;",0 
553f .. 00		keybs:       db ": keybs $08 ;",0 
554d			 
554d			   
554d			 
554d			 
554d			 
554d			; eof 
# End of file forth_autostart.asm
554d			 
554d .. 00		sprompt1: db "Startup load...",0 
555d .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5573			 
5573			 
5573			 
5573			 
5573			forth_startup: 
5573 21 ab 46			ld hl, startcmds 
5576 3e 00			ld a, 0 
5578 32 7d e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
557b			 
557b e5			.start1:	push hl 
557c cd 80 09			call clear_display 
557f 11 4d 55			ld de, sprompt1 
5582 3e 00		        ld a, display_row_1 
5584 cd 93 09			call str_at_display 
5587 11 5d 55			ld de, sprompt2 
558a 3e 28		        ld a, display_row_2 
558c cd 93 09			call str_at_display 
558f e1				pop hl 
5590 e5				push hl 
5591 5e				ld e,(hl) 
5592 23				inc hl 
5593 56				ld d,(hl) 
5594 3e 50		        ld a, display_row_3 
5596 cd 93 09			call str_at_display 
5599 cd a3 09			call update_display 
559c			 
559c			 
559c 3a 7d e7			ld a, (os_last_cmd) 
559f fe 00			cp 0 
55a1 28 05			jr z, .startprompt 
55a3 cd e6 08			call delay250ms 
55a6 18 24			jr .startdo 
55a8				 
55a8				 
55a8			 
55a8			.startprompt: 
55a8			 
55a8 3e 9f			ld a,display_row_4 + display_cols - 1 
55aa 11 7e 19		        ld de, endprg 
55ad cd 93 09			call str_at_display 
55b0 cd a3 09			call update_display 
55b3 cd f2 08			call delay1s 
55b6 cd 25 59			call cin_wait 
55b9						 
55b9 fe 2a			cp '*' 
55bb 28 5e			jr z, .startupend1 
55bd fe 23			cp '#' 
55bf 20 07			jr nz, .startno 
55c1 3e 01			ld a, 1 
55c3 32 7d e7			ld (os_last_cmd),a 
55c6 18 04			jr .startdo 
55c8 fe 31		.startno:	cp '1' 
55ca 28 3a			jr z,.startnxt  
55cc			 
55cc				; exec startup line 
55cc			.startdo:	 
55cc e1				pop hl 
55cd e5				push hl 
55ce				 
55ce 5e				ld e,(hl) 
55cf 23				inc hl 
55d0 56				ld d,(hl) 
55d1 eb				ex de,hl 
55d2			 
55d2 e5				push hl 
55d3			 
55d3 3e 00			ld a, 0 
55d5				;ld a, FORTH_END_BUFFER 
55d5 cd 16 10			call strlent 
55d8 23				inc hl   ; include zero term to copy 
55d9 06 00			ld b,0 
55db 4d				ld c,l 
55dc e1				pop hl 
55dd 11 57 e3			ld de, scratch 
55e0 ed b0			ldir 
55e2			 
55e2			 
55e2 21 57 e3			ld hl, scratch 
55e5 cd bf 1d			call forthparse 
55e8 cd ff 1d			call forthexec 
55eb cd 16 1d			call forthexec_cleanup 
55ee			 
55ee 3e 78			ld a, display_row_4 
55f0 11 22 17			ld de, endprog 
55f3			 
55f3 cd a3 09			call update_display		 
55f6			 
55f6 3a 7d e7			ld a, (os_last_cmd) 
55f9 fe 00			cp 0 
55fb 20 09			jr nz, .startnxt 
55fd cd 80 19			call next_page_prompt 
5600 cd 80 09		        call clear_display 
5603 cd a3 09			call update_display		 
5606			 
5606				; move onto next startup line? 
5606			.startnxt: 
5606			 
5606 cd e6 08			call delay250ms 
5609 e1				pop hl 
560a			 
560a 23				inc hl 
560b 23				inc hl 
560c			 
560c e5				push hl 
560d 5e				ld e, (hl) 
560e 23				inc hl 
560f 56				ld d, (hl) 
5610 e1				pop hl 
5611				; TODO replace 0 test 
5611			 
5611 eb				ex de, hl 
5612 cd d6 0b			call ishlzero 
5615			;	ld a,e 
5615			;	add d 
5615			;	cp 0    ; any left to do? 
5615 eb				ex de, hl 
5616 c2 7b 55			jp nz, .start1 
5619 18 01			jr .startupend 
561b			 
561b e1			.startupend1: pop hl 
561c			.startupend: 
561c			 
561c cd 80 09			call clear_display 
561f cd a3 09			call update_display 
5622 c9				ret 
5623			 
5623			 
5623			; stack over and underflow checks 
5623			 
5623			; init the words to detect the under/overflow 
5623			 
5623			chk_stk_init: 
5623				; a vague random number to check so we dont get any "lucky" hits 
5623 3e 2d			ld a, 45 
5625 6f				ld l, a 
5626 00				nop 
5627 3e 17			ld a, 23 
5629 67				ld h, a 
562a			 
562a 22 3e e3			ld (chk_word), hl     ; the word we need to check against 
562d			 
562d			;	ld (chk_stund), hl	; stack points.... 
562d 22 00 ef			ld (chk_stovr), hl 
5630 22 02 eb			ld (chk_ret_und), hl 
5633 22 c0 ea			ld (chk_ret_ovr), hl 
5636 22 be e9			ld (chk_loop_ovr), hl 
5639 22 bc e8			ld (chk_data_ovr), hl 
563c c9				ret 
563d				 
563d			check_stacks: 
563d				; check all stack words 
563d			 
563d e5				push hl 
563e d5				push de 
563f			 
563f			;	ld de,(chk_word) 
563f			;	ld hl, (chk_stund)	; stack points.... 
563f			;	if DEBUG_STK_FAULT 
563f			;		DMARK "FAa" 
563f			;		CALLMONITOR 
563f			;	endif 
563f			;	call cmp16 
563f			;	jp z, .chk_faulta 
563f			; 
563f			;	ld de, sfaultsu 
563f			;	jp .chk_fault 
563f			 
563f 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5642 ed 5b 3e e3		ld de,(chk_word) 
5646				if DEBUG_STK_FAULT 
5646					DMARK "FAb" 
5646					CALLMONITOR 
5646				endif 
5646 cd cb 0b			call cmp16 
5649 28 06			jr z, .chk_fault1 
564b 11 ec 56			ld de, sfaultso 
564e c3 a0 56			jp .chk_fault 
5651			.chk_fault1:  
5651 2a 02 eb			ld hl, (chk_ret_und) 
5654 ed 5b 3e e3		ld de,(chk_word) 
5658				if DEBUG_STK_FAULT 
5658					DMARK "FAU" 
5658					CALLMONITOR 
5658				endif 
5658 cd cb 0b			call cmp16 
565b ca 64 56			jp z, .chk_fault2 
565e 11 fc 56			ld de, sfaultru 
5661 c3 a0 56			jp .chk_fault 
5664			.chk_fault2:  
5664 2a c0 ea			ld hl, (chk_ret_ovr) 
5667 ed 5b 3e e3		ld de,(chk_word) 
566b				if DEBUG_STK_FAULT 
566b					DMARK "FA1" 
566b					CALLMONITOR 
566b				endif 
566b cd cb 0b			call cmp16 
566e ca 77 56			jp z, .chk_fault3 
5671 11 0a 57			ld de, sfaultro 
5674 c3 a0 56			jp .chk_fault 
5677			.chk_fault3:  
5677 2a be e9			ld hl, (chk_loop_ovr) 
567a ed 5b 3e e3		ld de,(chk_word) 
567e				if DEBUG_STK_FAULT 
567e					DMARK "FA2" 
567e					CALLMONITOR 
567e				endif 
567e cd cb 0b			call cmp16 
5681 ca 8a 56			jp z, .chk_fault4 
5684 11 24 57			ld de, sfaultlo 
5687 c3 a0 56			jp .chk_fault 
568a			.chk_fault4:  
568a 2a bc e8			ld hl, (chk_data_ovr) 
568d ed 5b 3e e3		ld de,(chk_word) 
5691				if DEBUG_STK_FAULT 
5691					DMARK "FA3" 
5691					CALLMONITOR 
5691				endif 
5691 cd cb 0b			call cmp16 
5694 ca 9d 56			jp z, .chk_fault5 
5697 11 3e 57			ld de, sfaultdo 
569a c3 a0 56			jp .chk_fault 
569d			 
569d			 
569d			.chk_fault5:  
569d d1				pop de 
569e e1				pop hl 
569f			 
569f c9				ret 
56a0			 
56a0 cd 80 09		.chk_fault: 	call clear_display 
56a3 3e 28				ld a, display_row_2 
56a5 cd 93 09				call str_at_display 
56a8 11 ce 56				   ld de, .stackfault 
56ab 3e 00				ld a, display_row_1 
56ad cd 93 09				call str_at_display 
56b0 11 71 ee				    ld de, debug_mark 
56b3 3e 11				ld a, display_row_1+17 
56b5 cd 93 09				call str_at_display 
56b8 cd a3 09				call update_display 
56bb			 
56bb				; prompt before entering montior for investigating issue 
56bb			 
56bb 3e 78			ld a, display_row_4 
56bd 11 22 17			ld de, endprog 
56c0			 
56c0 cd a3 09			call update_display		 
56c3			 
56c3 cd 80 19			call next_page_prompt 
56c6			 
56c6 d1				pop de 
56c7 e1				pop hl 
56c8 cd 76 17				call monitor 
56cb c3 70 16				jp warmstart 
56ce					;jp 0 
56ce					;halt 
56ce			 
56ce			 
56ce			 
56ce .. 00		.stackfault: 	db "Stack fault:",0 
56db			 
56db .. 00		sfaultsu: 	db	"Stack under flow",0 
56ec .. 00		sfaultso: 	db	"Stack over flow",0 
56fc .. 00		sfaultru:	db "RTS underflow",0 
570a .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5724 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
573e .. 00		sfaultdo:	db "DTS overflow", 0 
574b			 
574b			 
574b			fault_dsp_under: 
574b 11 5d 57			ld de, .dsp_under 
574e c3 0d 58			jp .show_fault 
5751			 
5751			fault_rsp_under: 
5751 11 6b 57			ld de, .rsp_under 
5754 c3 0d 58			jp .show_fault 
5757			fault_loop_under: 
5757 11 79 57			ld de, .loop_under 
575a c3 0d 58			jp .show_fault 
575d			 
575d .. 00		.dsp_under: db "DSP Underflow",0 
576b .. 00		.rsp_under: db "RSP Underflow",0 
5779 .. 00		.loop_under: db "LOOP Underflow",0 
5788			 
5788			 
5788 d5			type_faultn: 	push de 
5789 e5					push hl 
578a cd 80 09				call clear_display 
578d 11 b4 57				   ld de, .typefaultn 
5790 3e 00				ld a, display_row_1 
5792 cd 93 09				call str_at_display 
5795 11 71 ee				    ld de, debug_mark 
5798 3e 11				ld a, display_row_1+17 
579a cd 93 09				call str_at_display 
579d cd a3 09				call update_display 
57a0			 
57a0				; prompt before entering montior for investigating issue 
57a0			 
57a0 3e 78			ld a, display_row_4 
57a2 11 22 17			ld de, endprog 
57a5			 
57a5 cd a3 09			call update_display		 
57a8			 
57a8 cd 80 19			call next_page_prompt 
57ab			 
57ab e5					push hl 
57ac d5					push de 
57ad cd 76 17				call monitor 
57b0 c3 70 16				jp warmstart 
57b3 76					halt 
57b4			 
57b4			 
57b4 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
57cb			 
57cb d5			type_faults: 	push de 
57cc e5					push hl 
57cd cd 80 09				call clear_display 
57d0 11 f6 57				   ld de, .typefaults 
57d3 3e 00				ld a, display_row_1 
57d5 cd 93 09				call str_at_display 
57d8 11 71 ee				    ld de, debug_mark 
57db 3e 11				ld a, display_row_1+17 
57dd cd 93 09				call str_at_display 
57e0 cd a3 09				call update_display 
57e3			 
57e3				; prompt before entering montior for investigating issue 
57e3			 
57e3 3e 78			ld a, display_row_4 
57e5 11 22 17			ld de, endprog 
57e8			 
57e8 cd a3 09			call update_display		 
57eb			 
57eb cd 80 19			call next_page_prompt 
57ee			 
57ee e1					pop hl 
57ef d1					pop de 
57f0 cd 76 17				call monitor 
57f3 c3 70 16				jp warmstart 
57f6			 
57f6			 
57f6 .. 00		.typefaults: db "STR Type Expected TOS!",0 
580d			 
580d			.show_fault: 	 
580d d5					push de 
580e cd 80 09				call clear_display 
5811 d1					pop de 
5812 3e 00				ld a, display_row_1 
5814 cd 93 09				call str_at_display 
5817 11 71 ee				    ld de, debug_mark 
581a 3e 11				ld a, display_row_1+17 
581c cd 93 09				call str_at_display 
581f cd a3 09				call update_display 
5822			 
5822				; prompt before entering montior for investigating issue 
5822			 
5822 3e 78			ld a, display_row_4 
5824 11 22 17			ld de, endprog 
5827			 
5827 cd a3 09			call update_display		 
582a			 
582a cd 80 19			call next_page_prompt 
582d			 
582d e1					pop hl 
582e d1					pop de 
582f cd 76 17				call monitor 
5832			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5832			; TODO Make optional fault restart to cli or warm boot? 
5832					;jp warmstart 
5832 c3 c8 16				jp cli 
5835 76					halt 
5836			 
5836			; handle the auto run of code from files in storage 
5836			 
5836			 
5836			if STORAGE_SE 
5836			 
5836			sprompt3: db "Loading from start-up file?:",0 
5836			sprompt4: db "(Y=Any key/N=No)",0 
5836			 
5836			 
5836			forth_autoload: 
5836			 
5836				; load block 0 of store 1 
5836				 
5836				ld a, $fe      ; bit 0 clear 
5836				ld (spi_device), a 
5836			 
5836				call storage_get_block_0 
5836			 
5836				ld a, (store_page+STORE_0_AUTOFILE) 
5836			 
5836				cp 0 
5836				ret z     ; auto start not enabled 
5836			 
5836				call clear_display 
5836			 
5836				; set bank 
5836			 
5836					ld a, (store_page+STORE_0_BANKRUN) 
5836					ld (spi_device), a 
5836			 
5836				; get file id to load from and get the file name to display 
5836			 
5836					ld a, (store_page+STORE_0_FILERUN) 
5836			 
5836					ld l, 0 
5836					ld h, a 
5836					ld de, store_page 
5836			 
5836					if DEBUG_FORTH_WORDS 
5836						DMARK "ASp" 
5836						CALLMONITOR 
5836					endif 
5836					call storage_read 
5836			 
5836					if DEBUG_FORTH_WORDS 
5836						DMARK "ASr" 
5836						CALLMONITOR 
5836					endif 
5836			 
5836					call ishlzero 
5836					ret z             ; file not found 
5836			 
5836					ld a, display_row_2 + 10 
5836					ld de, store_page+3 
5836					call str_at_display 
5836				 
5836			; 
5836			 
5836				ld a, display_row_1+5 
5836				ld de, sprompt3 
5836				call str_at_display 
5836				ld a, display_row_3+15 
5836				ld de, sprompt4 
5836				call str_at_display 
5836			 
5836				call update_display 
5836			 
5836				call cin_wait 
5836				cp 'n' 
5836				ret z 
5836				cp 'N' 
5836				ret z 
5836			 
5836				call delay1s 
5836			 
5836				ld a, (store_page+2) 
5836				ld (store_openmaxext), a    ; save count of ext 
5836				ld a, 1  
5836				ld (store_openext), a    ; save count of ext 
5836			 
5836			.autof:  
5836				ld l , a 
5836				 
5836				ld a, (store_page) 
5836				ld h, a	 
5836				ld de, store_page 
5836					if DEBUG_FORTH_WORDS 
5836						DMARK "ASl" 
5836						CALLMONITOR 
5836					endif 
5836					call storage_read 
5836				call ishlzero 
5836				ret z 
5836			;	jr z, .autoend 
5836			 
5836					if DEBUG_FORTH_WORDS 
5836						DMARK "ASc" 
5836						CALLMONITOR 
5836					endif 
5836				ld de, store_page+2 
5836				ld a, display_row_4 
5836				call str_at_display 
5836			 
5836				call update_display 
5836				call delay250ms 
5836			 
5836			 
5836			 
5836				ld hl, store_page+2 
5836				call forthparse 
5836				call forthexec 
5836				call forthexec_cleanup 
5836			 
5836				 
5836				ld a, (store_openext) 
5836				inc a 
5836				ld (store_openext), a    ; save count of ext 
5836			 
5836				jr .autof 
5836			;.autofdone: 
5836			; 
5836			;		if DEBUG_FORTH_WORDS 
5836			;			DMARK "ASx" 
5836			;			CALLMONITOR 
5836			;		endif 
5836			;;	call clear_display 
5836			;	ret 
5836			 
5836			 
5836			 
5836			endif 
5836			 
5836			 
5836			; eof 
# End of file forth_kernel.asm
5836			;include "nascombasic.asm" 
5836			 
5836			 
5836			; find out where the code ends if loaded into RAM (for SC114) 
5836			;endofcode:  
5836			;	nop 
5836			 
5836			 
5836			; eof 
5836			 
# End of file main.asm
5836			;include "firmware_lcd_4x40.asm" 
5836			;;include "firmware_lcd_4x20.asm" 
5836			include "firmware_cpm_display.asm" 
5836			 
5836			; Serial display interface for SC114 
5836			 
5836			 
5836			display_row_1: equ 0 
5836			display_row_2: equ display_row_1+display_cols 
5836			display_row_3: equ display_row_2 + display_cols 
5836			display_row_4: equ display_row_3 + display_cols 
5836			 
5836			kLCDWidth:  EQU display_cols             ;Width in characters 
5836			kLCD_Line1: EQU 0x00  
5836			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5836			; E1 
5836			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5836			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5836			 
5836			lcd_init: 
5836				; no init as handled by the SCM bios 
5836 c9				ret 
5837			 
5837			 
5837			; low level functions for direct screen writes 
5837			 
5837			; output char at pos? 
5837			fLCD_Str: 
5837			        ;out (SC114_SIO_1_OUT),a 
5837 c5				push bc 
5838 d5				push de 
5839 5f				ld e, a 
583a			; TODO Replace with CP/M BIOS call 
583a 0e 02			ld c, $02 
583c cd 05 00			call 5 
583f d1				pop de 
5840 c1				pop bc 
5841 c9				ret 
5842			 
5842			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5842			fLCD_Pos: 
5842				; use ASCII escape to position 
5842			        ;out (SC114_SIO_1_OUT),a 
5842 c5				push bc 
5843 d5				push de 
5844 5f				ld e, a 
5845 0e 02			ld c, $02 
5847			; TODO Replace with CP/M BIOS call 
5847 cd 05 00			call 5 
584a d1				pop de 
584b c1				pop bc 
584c			 
584c c9				ret 
584d			 
584d			; output char at pos 
584d			fLCD_Data: 
584d			      ;  out (SC114_SIO_1_OUT),a 
584d c5				push bc 
584e d5				push de 
584f 0e 02			ld c, $02 
5851 5f				ld e, a 
5852			; TODO Replace with CP/M BIOS call 
5852 cd 05 00			call 5 
5855 d1				pop de 
5856 c1				pop bc 
5857			 
5857 c9				ret 
5858			 
5858			; ascii cls  
5858			 
5858 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
585c			 
585c 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5873			;.clscpm: db 3, $3c,"$" 
5873			 
5873			; write the frame buffer given in hl to hardware  
5873			write_display: 
5873			 
5873			API: equ 0 
5873			 
5873			if API 
5873				push bc 
5873				ld b, 4 
5873			 
5873			        ld (display_write_tmp), hl 	  
5873			 
5873				; clear and home cursor 
5873			 
5873				ld c, 9 
5873				ld de, .cls 
5873			; TODO Replace with CP/M BIOS call 
5873				call 5 
5873			 
5873			 
5873			.writeln: 
5873			 
5873				ld de, (display_write_tmp) 
5873				ld c, 6 
5873			; TODO Replace with CP/M BIOS call 
5873				rst $30 
5873				ld c, 7 
5873				rst $30 
5873			 
5873				ld hl, (display_write_tmp) 
5873				ld de, display_cols 
5873				add hl,de 
5873				ld (display_write_tmp),hl 
5873			 
5873				djnz  .writeln 
5873			 
5873				pop bc 
5873			 
5873			 
5873				ret 
5873			endif 
5873 e5				push hl 
5874 c5				push bc 
5875 d5				push de 
5876			 
5876			;	ld c, 2 
5876			;	;ld de, .cls 
5876			;	ld a, 27 
5876			;	rst $30 
5876			;	ld c, 2 
5876			;	;ld de, .cls 
5876			;	ld a, '[' 
5876			;	rst $30 
5876			; 
5876			;	ld c, 2 
5876			;	;ld de, .cls 
5876			;	ld a, 'H' 
5876			;	rst $30 
5876			; 
5876			 
5876			 
5876			; lots of CR/LF 
5876			;	ld c, 9 
5876			;	ld de, .clscpm 
5876			;	call 5 
5876			 
5876			; xterm cls 
5876 0e 02			ld c, 2 
5878 1e 1b			ld e, 27 
587a cd 05 00			call 5 
587d			; cls causes too much flicker 
587d			;	ld c, 2 
587d			;	ld e, 'c' 
587d			;	call 5 
587d			 
587d			; use xterm home instead 
587d 0e 02			ld c, 2 
587f 1e 5b			ld e, '[' 
5881 cd 05 00			call 5 
5884 0e 02			ld c, 2 
5886 1e 48			ld e, 'H' 
5888 cd 05 00			call 5 
588b			LLL: equ 0 
588b			 
588b			if LLL 
588b			 
588b				ld c, 2 
588b				;ld de, .cls 
588b				ld e, 27 
588b			; TODO Replace with CP/M BIOS call 
588b				call 5 
588b			 
588b			 
588b				ld c, 2 
588b				;ld de, .cls 
588b				ld e, '[' 
588b			; TODO Replace with CP/M BIOS call 
588b				call 5 
588b				ld c, 2 
588b				;ld de, .cls 
588b				ld e, '2' 
588b			; TODO Replace with CP/M BIOS call 
588b				call 5 
588b				ld c, 2 
588b				;ld de, .cls 
588b				ld e, 'J' 
588b			; TODO Replace with CP/M BIOS call 
588b				call 5 
588b			 
588b			endif 
588b			 
588b d1				pop de 
588c c1				pop bc 
588d e1				pop hl 
588e			 
588e			 
588e 22 cf eb		        ld (display_write_tmp), hl 	  
5891 3e 00			ld a, kLCD_Line1 
5893			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5893 06 28			ld b, display_cols 
5895 ed 5b cf eb		ld de, (display_write_tmp) 
5899 cd 1c 59			call write_len_string 
589c				 
589c			 
589c e5			push hl 
589d d5			push de 
589e c5			push bc 
589f 0e 02			ld c, 2 
58a1 1e 0a			ld e, 10 
58a3 cd 05 00			call 5 
58a6 0e 02			ld c, 2 
58a8 1e 0d			ld e, 13 
58aa cd 05 00			call 5 
58ad			; TODO Replace with CP/M BIOS call 
58ad				;rst $30 
58ad c1			pop bc 
58ae d1			pop de 
58af e1			pop hl 
58b0			 
58b0				 
58b0 2a cf eb			ld hl, (display_write_tmp) 
58b3 11 28 00			ld de, display_cols 
58b6 19				add hl,de 
58b7 22 cf eb			ld (display_write_tmp),hl 
58ba			 
58ba				 
58ba 3e 28			ld a, kLCD_Line2 
58bc			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
58bc 06 28			ld b, display_cols 
58be ed 5b cf eb		ld de, (display_write_tmp) 
58c2 cd 1c 59			call write_len_string 
58c5				 
58c5 2a cf eb			ld hl, (display_write_tmp) 
58c8 11 28 00			ld de, display_cols 
58cb 19				add hl,de 
58cc 22 cf eb			ld (display_write_tmp),hl 
58cf			 
58cf e5			push hl 
58d0 d5			push de 
58d1 c5			push bc 
58d2 0e 07			ld c, 7 
58d4			; TODO Replace with CP/M BIOS call 
58d4				;rst $30 
58d4 0e 02			ld c, 2 
58d6 1e 0a			ld e, 10 
58d8 cd 05 00			call 5 
58db 0e 02			ld c, 2 
58dd 1e 0d			ld e, 13 
58df cd 05 00			call 5 
58e2 c1			pop bc 
58e3 d1			pop de 
58e4 e1			pop hl 
58e5			 
58e5				 
58e5 3e 50			ld a, kLCD_Line3 
58e7			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
58e7 06 28			ld b, display_cols 
58e9 ed 5b cf eb		ld de, (display_write_tmp) 
58ed cd 1c 59			call write_len_string 
58f0				 
58f0 2a cf eb			ld hl, (display_write_tmp) 
58f3 11 28 00			ld de, display_cols 
58f6 19				add hl,de 
58f7 22 cf eb			ld (display_write_tmp),hl 
58fa			 
58fa e5			push hl 
58fb d5			push de 
58fc c5			push bc 
58fd 0e 07			ld c, 7 
58ff			; TODO Replace with CP/M BIOS call 
58ff				;rst $30 
58ff 0e 02			ld c, 2 
5901 1e 0a			ld e, 10 
5903 cd 05 00			call 5 
5906 0e 02			ld c, 2 
5908 1e 0d			ld e, 13 
590a cd 05 00			call 5 
590d c1			pop bc 
590e d1			pop de 
590f e1			pop hl 
5910			 
5910				 
5910 3e 78			ld a, kLCD_Line4 
5912			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5912 06 28			ld b, display_cols 
5914 ed 5b cf eb		ld de, (display_write_tmp) 
5918 cd 1c 59			call write_len_string 
591b c9					ret 
591c			 
591c			 
591c				; write out a fixed length string given in b from de 
591c			 
591c 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
591d cd 4d 58		            CALL fLCD_Data      ;Write character to display 
5920 13				inc de 
5921 10 f9			djnz write_len_string 
5923 c9				ret 
5924			 
5924			 
5924			; eof 
# End of file firmware_cpm_display.asm
5924			;include "firmware_key_5x10.asm" 
5924			;;include "firmware_key_4x10.asm" 
5924			include "firmware_key_cpm.asm" 
5924			; Serial keyboard interface for SC114 
5924			 
5924			 
5924			key_init: 
5924				; no init as handled by the SCM bios 
5924 c9				ret 
5925			 
5925			 
5925			cin_wait: 
5925			;	ld a, 0 
5925			;	ret 
5925			 
5925				;in a,(SC114_SIO_1_IN) 
5925			        ; Use SCM API to get from whatever console device we are using 
5925			 
5925			; TODO Replace with CP/M BIOS call 
5925 c5				push bc 
5926 0e 01			ld c, $01 
5928 cd 05 00			call 5 
592b c1				pop bc 
592c c9				ret 
592d			 
592d			cin: 
592d			 
592d			 
592d c5				push bc 
592e			 
592e				; any key waiting to process? 
592e			; TODO Replace with CP/M BIOS call 
592e 0e 06			ld c, $06 
5930 cd 05 00			call 5 
5933 28 0d			jr z, .cin_skip 
5935			 
5935				; yep, get it 
5935			 
5935 0e 01			ld c, $01 
5937			; TODO Replace with CP/M BIOS call 
5937 cd 05 00			call 5 
593a			 
593a fe 7f			cp $7f     ; back space 
593c 20 02			jr nz, .skipbs 
593e 3e 08			ld a, KEY_BS 
5940			.skipbs: 
5940			 
5940 c1				pop bc 
5941 c9				ret 
5942			.cin_skip: 
5942 3e 00			ld a, 0 
5944 c1				pop bc 
5945 c9				ret 
5946			 
5946			 
5946			 
5946			 
# End of file firmware_key_cpm.asm
5946			endofcode:  
5946			baseram:  
5946 00				nop 
5947			 
5947			heap_start: equ baseram+15  ; Starting address of heap 
5947			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5947			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5947			;VDU:  EQU     endofcode           ; BASIC Work space 
5947			; eof 
5947			 
# End of file os_mega_cpm.asm
5947
