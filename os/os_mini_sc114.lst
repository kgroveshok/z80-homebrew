# File os_mini_sc114.asm
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			 
0000			 
0000			tos:	equ 0f000h 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			SC103_PIO: equ 068h 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 86 94			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $3c holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_FILERUN: equ $3c  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $3c  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 c6 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 05 ee				ld hl, display_fb1  
800b 22 61 ed				ld (display_fb_active), hl  
800e			  
800e cd 3c 88				call clear_display  
8011			  
8011 21 63 ed				ld hl, display_fb2  
8014 22 61 ed				ld (display_fb_active), hl  
8017			  
8017 cd 3c 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 56 ee				ld hl, display_fb0  
801d 22 61 ed				ld (display_fb_active), hl  
8020			  
8020 cd 3c 88				call clear_display  
8023			  
8023			  
8023 cd 78 d7				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 1a d8			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 0c 8f				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd 5f 88			call update_display  
8032 cd ea 87			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 41 88			call fill_display  
803a cd 5f 88			call update_display  
803d cd ea 87			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 41 88			call fill_display  
8045 cd 5f 88			call update_display  
8048 cd ea 87			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 41 88			call fill_display  
8050 cd 5f 88			call update_display  
8053 cd ea 87			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056 3e 00		        ld a, display_row_1    
8058			else  
8058			        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd 4f 88			call str_at_display  
805e cd 5f 88			call update_display  
8061			  
8061			  
8061 cd ea 87			call delay1s  
8064 cd ea 87			call delay1s  
8067			if display_cols == 20	  
8067 3e 2a		            LD   A, display_row_3+2  
8069			else  
8069			            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd 4f 88			call str_at_display  
806f cd 5f 88			call update_display  
8072 cd ea 87			call delay1s  
8075 cd ea 87			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 c0 ee		ld (debug_mark),a  
807d 32 c1 ee		ld (debug_mark+1),a  
8080 32 c2 ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 c3 ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 c0 ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 c1 ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 c2 ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd b0 92			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 c0 ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 c1 ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 c2 ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd b0 92			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd cf 83			call storage_findnextid 
8105			 
8105 cd 92 8a			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 eb ec			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a ed ec			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 c0 ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 c1 ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 c2 ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd b0 92			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 c0 ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 c1 ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 c2 ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd b0 92			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 eb ec			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 c0 ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 c1 ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 c2 ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 eb ec				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd b0 92			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a ec ec			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 c0 ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 c1 ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 c2 ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd b0 92			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 c0 ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 c1 ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 c2 ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd b0 92			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 21 eb ec			ld hl, store_page 
81d3 3e 00			ld a, 0 
81d5				 
81d5 77				ld (hl),a   ; reset file counter 
81d6			 
81d6 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81d9 22 ec ec		 	ld (store_page+1), hl	 
81dc			 
81dc				; set default label 
81dc			 
81dc 21 78 82			ld hl, .defaultbanklabl 
81df 11 ee ec		 	ld de, store_page+3 
81e2 01 0f 00			ld bc, 15 
81e5 ed b0			ldir 
81e7			 
81e7				; Append the current bank id 
81e7 21 f7 ec			ld hl, store_page+3+9 
81ea 3a d0 ec			ld a, (spi_device_id) 
81ed 77				ld (hl), a 
81ee			 
81ee				; save default page 0 
81ee			 
81ee 21 00 00			ld hl, 0 
81f1 11 eb ec			ld de, store_page 
81f4				if DEBUG_STORESE 
81f4					DMARK "SB3" 
81f4 f5				push af  
81f5 3a 09 82			ld a, (.dmark)  
81f8 32 c0 ee			ld (debug_mark),a  
81fb 3a 0a 82			ld a, (.dmark+1)  
81fe 32 c1 ee			ld (debug_mark+1),a  
8201 3a 0b 82			ld a, (.dmark+2)  
8204 32 c2 ee			ld (debug_mark+2),a  
8207 18 03			jr .pastdmark  
8209 ..			.dmark: db "SB3"  
820c f1			.pastdmark: pop af  
820d			endm  
# End of macro DMARK
820d			;		push af 
820d			;		ld a, 'F' 
820d			;		ld (debug_mark),a 
820d			;		pop af 
820d					CALLMONITOR 
820d cd b0 92			call break_point_state  
8210				endm  
# End of macro CALLMONITOR
8210				endif 
8210 cd 16 81			call storage_write_block 
8213				if DEBUG_STORESE 
8213					DMARK "SB4" 
8213 f5				push af  
8214 3a 28 82			ld a, (.dmark)  
8217 32 c0 ee			ld (debug_mark),a  
821a 3a 29 82			ld a, (.dmark+1)  
821d 32 c1 ee			ld (debug_mark+1),a  
8220 3a 2a 82			ld a, (.dmark+2)  
8223 32 c2 ee			ld (debug_mark+2),a  
8226 18 03			jr .pastdmark  
8228 ..			.dmark: db "SB4"  
822b f1			.pastdmark: pop af  
822c			endm  
# End of macro DMARK
822c			;		push af 
822c			;		ld a, '>' 
822c			;		ld (debug_mark),a 
822c			;		pop af 
822c					CALLMONITOR 
822c cd b0 92			call break_point_state  
822f				endm  
# End of macro CALLMONITOR
822f				endif 
822f			 
822f 00				nop 
8230 00				nop 
8231 00				nop 
8232			 
8232				; now set 0 in every page to mark as a free block 
8232			 
8232 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8234 21 40 00			ld hl, STORE_BLOCK_PHY 
8237			 
8237 3e 00		.setmark1:   	ld a,0 
8239 e5					push hl 
823a c5					push bc 
823b cd af 80				call se_writebyte 
823e 3e 0a			ld a, 10 
8240 cd cf 87			call aDelayInMS 
8243 23				inc hl 
8244 cd af 80				call se_writebyte 
8247 3e 0a			ld a, 10 
8249 cd cf 87			call aDelayInMS 
824c 2b				dec hl 
824d c1					pop bc 
824e e1					pop hl 
824f 3e 40				ld a, STORE_BLOCK_PHY 
8251 cd 69 8a				call addatohl 
8254 10 e1				djnz .setmark1 
8256			 
8256 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8258 3e 00		.setmark2:   	ld a,0 
825a e5					push hl 
825b c5					push bc 
825c cd af 80				call se_writebyte 
825f 3e 0a			ld a, 10 
8261 cd cf 87			call aDelayInMS 
8264 23				inc hl 
8265 cd af 80				call se_writebyte 
8268 3e 0a			ld a, 10 
826a cd cf 87			call aDelayInMS 
826d 2b				dec hl 
826e c1					pop bc 
826f e1					pop hl 
8270 3e 40				ld a, STORE_BLOCK_PHY 
8272 cd 69 8a				call addatohl 
8275 10 e1				djnz .setmark2 
8277			 
8277					 
8277			 
8277			 
8277 c9				ret 
8278			 
8278			 
8278			 
8278			 
8278 .. 00		.defaultbanklabl:   db "BankLabel_",0 
8283			 
8283			 
8283			 
8283			; Label Bank 
8283			; ---------- 
8283			; 
8283			; With current bank 
8283			; Read block 0 
8283			; Set label 
8283			; Write block 0 
8283			 
8283			; label str pointer in hl 
8283			 
8283			storage_label:     
8283			 
8283				if DEBUG_STORESE 
8283					DMARK "LBL" 
8283 f5				push af  
8284 3a 98 82			ld a, (.dmark)  
8287 32 c0 ee			ld (debug_mark),a  
828a 3a 99 82			ld a, (.dmark+1)  
828d 32 c1 ee			ld (debug_mark+1),a  
8290 3a 9a 82			ld a, (.dmark+2)  
8293 32 c2 ee			ld (debug_mark+2),a  
8296 18 03			jr .pastdmark  
8298 ..			.dmark: db "LBL"  
829b f1			.pastdmark: pop af  
829c			endm  
# End of macro DMARK
829c					CALLMONITOR 
829c cd b0 92			call break_point_state  
829f				endm  
# End of macro CALLMONITOR
829f				endif 
829f			 
829f e5				push hl 
82a0			 
82a0 cd 62 81			call storage_get_block_0 
82a3			 
82a3				; set default label 
82a3			 
82a3 e1				pop hl 
82a4			 
82a4 11 ee ec		 	ld de, store_page+3 
82a7 01 0f 00			ld bc, 15 
82aa				if DEBUG_STORESE 
82aa					DMARK "LB3" 
82aa f5				push af  
82ab 3a bf 82			ld a, (.dmark)  
82ae 32 c0 ee			ld (debug_mark),a  
82b1 3a c0 82			ld a, (.dmark+1)  
82b4 32 c1 ee			ld (debug_mark+1),a  
82b7 3a c1 82			ld a, (.dmark+2)  
82ba 32 c2 ee			ld (debug_mark+2),a  
82bd 18 03			jr .pastdmark  
82bf ..			.dmark: db "LB3"  
82c2 f1			.pastdmark: pop af  
82c3			endm  
# End of macro DMARK
82c3					CALLMONITOR 
82c3 cd b0 92			call break_point_state  
82c6				endm  
# End of macro CALLMONITOR
82c6				endif 
82c6 ed b0			ldir 
82c8				; save default page 0 
82c8			 
82c8 21 00 00			ld hl, 0 
82cb 11 eb ec			ld de, store_page 
82ce				if DEBUG_STORESE 
82ce					DMARK "LBW" 
82ce f5				push af  
82cf 3a e3 82			ld a, (.dmark)  
82d2 32 c0 ee			ld (debug_mark),a  
82d5 3a e4 82			ld a, (.dmark+1)  
82d8 32 c1 ee			ld (debug_mark+1),a  
82db 3a e5 82			ld a, (.dmark+2)  
82de 32 c2 ee			ld (debug_mark+2),a  
82e1 18 03			jr .pastdmark  
82e3 ..			.dmark: db "LBW"  
82e6 f1			.pastdmark: pop af  
82e7			endm  
# End of macro DMARK
82e7					CALLMONITOR 
82e7 cd b0 92			call break_point_state  
82ea				endm  
# End of macro CALLMONITOR
82ea				endif 
82ea cd 16 81			call storage_write_block 
82ed			 
82ed c9				ret 
82ee			 
82ee			 
82ee			 
82ee			; Read Block 0 - Config 
82ee			; --------------------- 
82ee			; 
82ee			; With current bank 
82ee			; Call presence test 
82ee			;    If not present format/init bank  
82ee			; Read block 0  
82ee			;  
82ee			 
82ee			 
82ee			; Dir 
82ee			; --- 
82ee			; 
82ee			; With current bank 
82ee			; Load Block 0 Config 
82ee			; Get max file id number 
82ee			; For each logical block 
82ee			;    Read block read byte 2 
82ee			;      if first block of file 
82ee			;         Display file name 
82ee			;         Display type flags for file 
82ee			;        
82ee			 
82ee			; moving to words as this requires stack control 
82ee			 
82ee			 
82ee			; Delete File 
82ee			; ----------- 
82ee			; 
82ee			; With current bank 
82ee			; 
82ee			; Load Block 0 Config 
82ee			; Get max file id number 
82ee			; For each logical block 
82ee			;    Read block file id 
82ee			;      If first block of file and dont have file id 
82ee			;         if file to delete 
82ee			;         Save file id 
82ee			;         Null file id 
82ee			;         Write this block back 
82ee			;      If file id is one saved 
82ee			;         Null file id 
82ee			;         Write this block back 
82ee			 
82ee			storage_erase: 
82ee			 
82ee				; hl contains the file id 
82ee			 
82ee 5d				ld e, l 
82ef 16 00			ld d, 0 
82f1 21 40 00			ld hl, STORE_BLOCK_PHY 
82f4					if DEBUG_FORTH_WORDS 
82f4						DMARK "ERA" 
82f4 f5				push af  
82f5 3a 09 83			ld a, (.dmark)  
82f8 32 c0 ee			ld (debug_mark),a  
82fb 3a 0a 83			ld a, (.dmark+1)  
82fe 32 c1 ee			ld (debug_mark+1),a  
8301 3a 0b 83			ld a, (.dmark+2)  
8304 32 c2 ee			ld (debug_mark+2),a  
8307 18 03			jr .pastdmark  
8309 ..			.dmark: db "ERA"  
830c f1			.pastdmark: pop af  
830d			endm  
# End of macro DMARK
830d						CALLMONITOR 
830d cd b0 92			call break_point_state  
8310				endm  
# End of macro CALLMONITOR
8310					endif 
8310 cd cf 83			call storage_findnextid 
8313			 
8313 e5				push hl 
8314			 
8314				; TODO check file not found 
8314			 
8314 11 eb ec			ld de, store_page 
8317 cd b1 80			call storage_read_block 
831a			 
831a					if DEBUG_FORTH_WORDS 
831a						DMARK "ER1" 
831a f5				push af  
831b 3a 2f 83			ld a, (.dmark)  
831e 32 c0 ee			ld (debug_mark),a  
8321 3a 30 83			ld a, (.dmark+1)  
8324 32 c1 ee			ld (debug_mark+1),a  
8327 3a 31 83			ld a, (.dmark+2)  
832a 32 c2 ee			ld (debug_mark+2),a  
832d 18 03			jr .pastdmark  
832f ..			.dmark: db "ER1"  
8332 f1			.pastdmark: pop af  
8333			endm  
# End of macro DMARK
8333						CALLMONITOR 
8333 cd b0 92			call break_point_state  
8336				endm  
# End of macro CALLMONITOR
8336					endif 
8336 3a eb ec			ld a, (store_page)	; get file id 
8339 32 e4 ec			ld (store_tmpid), a 
833c			 
833c 3a ed ec			ld a, (store_page+2)    ; get count of extends 
833f 32 e3 ec			ld (store_tmpext), a 
8342			 
8342				; wipe file header 
8342			 
8342 e1				pop hl 
8343 3e 00			ld a, 0 
8345 32 eb ec			ld (store_page), a 
8348 32 ec ec			ld (store_page+1),a 
834b 11 eb ec			ld de, store_page 
834e					if DEBUG_FORTH_WORDS 
834e						DMARK "ER2" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 c0 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 c1 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 c2 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "ER2"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367						CALLMONITOR 
8367 cd b0 92			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a					endif 
836a cd 16 81			call storage_write_block 
836d			 
836d			 
836d				; wipe file extents 
836d			 
836d 3a e3 ec			ld a, (store_tmpext) 
8370 47				ld b, a 
8371			 
8371			.eraext:	  
8371 c5				push bc 
8372			 
8372 21 40 00			ld hl, STORE_BLOCK_PHY 
8375 3a e4 ec			ld a,(store_tmpid) 
8378 5f				ld e, a 
8379 50				ld d, b	 
837a					if DEBUG_FORTH_WORDS 
837a						DMARK "ER3" 
837a f5				push af  
837b 3a 8f 83			ld a, (.dmark)  
837e 32 c0 ee			ld (debug_mark),a  
8381 3a 90 83			ld a, (.dmark+1)  
8384 32 c1 ee			ld (debug_mark+1),a  
8387 3a 91 83			ld a, (.dmark+2)  
838a 32 c2 ee			ld (debug_mark+2),a  
838d 18 03			jr .pastdmark  
838f ..			.dmark: db "ER3"  
8392 f1			.pastdmark: pop af  
8393			endm  
# End of macro DMARK
8393						CALLMONITOR 
8393 cd b0 92			call break_point_state  
8396				endm  
# End of macro CALLMONITOR
8396					endif 
8396 cd cf 83			call storage_findnextid 
8399			 
8399 e5				push hl 
839a 11 eb ec			ld de, store_page 
839d cd b1 80			call storage_read_block 
83a0			 
83a0				; free block	 
83a0			 
83a0 3e 00			ld a, 0 
83a2 32 eb ec			ld (store_page), a 
83a5 32 ec ec			ld (store_page+1),a 
83a8 11 eb ec			ld de, store_page 
83ab e1				pop hl 
83ac					if DEBUG_FORTH_WORDS 
83ac						DMARK "ER4" 
83ac f5				push af  
83ad 3a c1 83			ld a, (.dmark)  
83b0 32 c0 ee			ld (debug_mark),a  
83b3 3a c2 83			ld a, (.dmark+1)  
83b6 32 c1 ee			ld (debug_mark+1),a  
83b9 3a c3 83			ld a, (.dmark+2)  
83bc 32 c2 ee			ld (debug_mark+2),a  
83bf 18 03			jr .pastdmark  
83c1 ..			.dmark: db "ER4"  
83c4 f1			.pastdmark: pop af  
83c5			endm  
# End of macro DMARK
83c5						CALLMONITOR 
83c5 cd b0 92			call break_point_state  
83c8				endm  
# End of macro CALLMONITOR
83c8					endif 
83c8 cd 16 81			call storage_write_block 
83cb			 
83cb c1				pop bc 
83cc 10 a3			djnz .eraext 
83ce			 
83ce c9				ret 
83cf			 
83cf			 
83cf			; Find Free Block 
83cf			; --------------- 
83cf			; 
83cf			; With current bank 
83cf			;  
83cf			; From given starting logical block 
83cf			;    Read block  
83cf			;    If no file id 
83cf			;         Return block id 
83cf			 
83cf			 
83cf			; hl starting page number 
83cf			; hl contains free page number or zero if no pages free 
83cf			; e contains the file id to locate 
83cf			; d contains the block number 
83cf			 
83cf			; TODO change to find file id and use zero for free block 
83cf			 
83cf			storage_findnextid: 
83cf			 
83cf				; now locate first 0 page to mark as a free block 
83cf			 
83cf 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83d1			;	ld hl, STORE_BLOCK_PHY 
83d1			 
83d1					if DEBUG_FORTH_WORDS 
83d1					DMARK "FNI" 
83d1 f5				push af  
83d2 3a e6 83			ld a, (.dmark)  
83d5 32 c0 ee			ld (debug_mark),a  
83d8 3a e7 83			ld a, (.dmark+1)  
83db 32 c1 ee			ld (debug_mark+1),a  
83de 3a e8 83			ld a, (.dmark+2)  
83e1 32 c2 ee			ld (debug_mark+2),a  
83e4 18 03			jr .pastdmark  
83e6 ..			.dmark: db "FNI"  
83e9 f1			.pastdmark: pop af  
83ea			endm  
# End of macro DMARK
83ea						CALLMONITOR 
83ea cd b0 92			call break_point_state  
83ed				endm  
# End of macro CALLMONITOR
83ed					endif 
83ed			.ff1:   	 
83ed e5					push hl 
83ee c5					push bc 
83ef d5					push de 
83f0 cd ae 80				call se_readbyte 
83f3 5f					ld e,a 
83f4 23					inc hl 
83f5 cd ae 80				call se_readbyte 
83f8 57					ld d, a 
83f9 e1					pop hl 
83fa e5					push hl 
83fb cd 87 8a				call cmp16 
83fe 28 49				jr z, .fffound 
8400			 
8400 d1					pop de 
8401 c1					pop bc 
8402 e1					pop hl 
8403			 
8403					; is found? 
8403					;cp e 
8403					;ret z 
8403			 
8403 3e 40				ld a, STORE_BLOCK_PHY 
8405 cd 69 8a				call addatohl 
8408 10 e3				djnz .ff1 
840a			 
840a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
840c			.ff2:   	 
840c			 
840c e5					push hl 
840d c5					push bc 
840e d5					push de 
840f cd ae 80				call se_readbyte 
8412 5f					ld e,a 
8413 23					inc hl 
8414 cd ae 80				call se_readbyte 
8417 57					ld d, a 
8418			 
8418 e1					pop hl 
8419 e5					push hl 
841a cd 87 8a				call cmp16 
841d 28 2a				jr z, .fffound 
841f			 
841f d1					pop de 
8420 c1					pop bc 
8421 e1					pop hl 
8422					; is found? 
8422					;cp e 
8422					;ret z 
8422			 
8422 3e 40				ld a, STORE_BLOCK_PHY 
8424 cd 69 8a				call addatohl 
8427 10 e3				djnz .ff2 
8429			 
8429			 
8429					if DEBUG_FORTH_WORDS 
8429					DMARK "FN-" 
8429 f5				push af  
842a 3a 3e 84			ld a, (.dmark)  
842d 32 c0 ee			ld (debug_mark),a  
8430 3a 3f 84			ld a, (.dmark+1)  
8433 32 c1 ee			ld (debug_mark+1),a  
8436 3a 40 84			ld a, (.dmark+2)  
8439 32 c2 ee			ld (debug_mark+2),a  
843c 18 03			jr .pastdmark  
843e ..			.dmark: db "FN-"  
8441 f1			.pastdmark: pop af  
8442			endm  
# End of macro DMARK
8442					;	push af 
8442					;	ld a, 'n' 
8442					;	ld (debug_mark),a 
8442					;	pop af 
8442						CALLMONITOR 
8442 cd b0 92			call break_point_state  
8445				endm  
# End of macro CALLMONITOR
8445					endif 
8445				; no free marks! 
8445 21 00 00				ld hl, 0 
8448 c9				ret 
8449			.fffound: 
8449				 
8449			 
8449 d1					pop de 
844a c1					pop bc 
844b e1					pop hl 
844c					if DEBUG_FORTH_WORDS 
844c					DMARK "FNF" 
844c f5				push af  
844d 3a 61 84			ld a, (.dmark)  
8450 32 c0 ee			ld (debug_mark),a  
8453 3a 62 84			ld a, (.dmark+1)  
8456 32 c1 ee			ld (debug_mark+1),a  
8459 3a 63 84			ld a, (.dmark+2)  
845c 32 c2 ee			ld (debug_mark+2),a  
845f 18 03			jr .pastdmark  
8461 ..			.dmark: db "FNF"  
8464 f1			.pastdmark: pop af  
8465			endm  
# End of macro DMARK
8465					;	push af 
8465					;	ld a, 'n' 
8465					;	ld (debug_mark),a 
8465					;	pop af 
8465						CALLMONITOR 
8465 cd b0 92			call break_point_state  
8468				endm  
# End of macro CALLMONITOR
8468					endif 
8468 c9				ret 
8469			 
8469			 
8469			 
8469			; Free Space 
8469			; ---------- 
8469			; 
8469			; With current bank 
8469			; 
8469			; Set block count to zero 
8469			; Starting with first logical block 
8469			;      Find free block  
8469			;      If block id given, increment block count 
8469			; 
8469			;  
8469			 
8469			 
8469			; hl contains count of free blocks 
8469			 
8469			storage_freeblocks: 
8469			 
8469				; now locate first 0 page to mark as a free block 
8469			 
8469 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
846b 21 40 00			ld hl, STORE_BLOCK_PHY 
846e 11 00 00			ld de, 0 
8471			 
8471			.fb1:   	 
8471 e5					push hl 
8472 c5					push bc 
8473 d5					push de 
8474 cd ae 80				call se_readbyte 
8477 d1					pop de 
8478 c1					pop bc 
8479 e1					pop hl 
847a			 
847a					; is free? 
847a fe 00				cp 0 
847c 20 01				jr nz, .ff1cont 
847e 13					inc de 
847f			 
847f			.ff1cont: 
847f			 
847f			 
847f 3e 40				ld a, STORE_BLOCK_PHY 
8481 cd 69 8a				call addatohl 
8484 10 eb				djnz .fb1 
8486			 
8486 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8488			.fb2:   	 
8488 e5					push hl 
8489 c5					push bc 
848a d5					push de 
848b cd ae 80				call se_readbyte 
848e d1					pop de 
848f c1					pop bc 
8490 e1					pop hl 
8491			 
8491					; is free? 
8491 fe 00				cp 0 
8493 20 01				jr nz, .ff2cont 
8495 13					inc de 
8496			 
8496			.ff2cont: 
8496			 
8496 3e 40				ld a, STORE_BLOCK_PHY 
8498 cd 69 8a				call addatohl 
849b 10 eb				djnz .fb2 
849d			 
849d eb				ex de, hl 
849e c9				ret 
849f			 
849f			; Get File ID 
849f			; ----------- 
849f			; 
849f			; With current bank 
849f			;  
849f			; Load Block 0 Config 
849f			; Get max file id number 
849f			; For each logical block 
849f			;    Read block file id 
849f			;      If first block of file and dont have file id 
849f			;         if file get id and exit 
849f			 
849f			 
849f			 
849f			 
849f			; Create File 
849f			; ----------- 
849f			; 
849f			; With current bank  
849f			; Load Block 0 Config 
849f			; Get max file id number 
849f			; Increment file id number 
849f			; Save Config 
849f			; Find free block 
849f			; Set buffer with file name and file id 
849f			; Write buffer to free block  
849f			 
849f			 
849f			; hl point to file name 
849f			; hl returns file id 
849f			 
849f			; file format: 
849f			; byte 0 - file id 
849f			; byte 1 - extent number 
849f			; byte 2-> data 
849f			 
849f			; format for extent number 0: 
849f			; 
849f			; byte 0 - file id 
849f			; byte 1 - extent 0 
849f			; byte 2 - extent count 
849f			; byte 3 -> file name and meta data 
849f			 
849f			 
849f			storage_create: 
849f				if DEBUG_STORESE 
849f					DMARK "SCR" 
849f f5				push af  
84a0 3a b4 84			ld a, (.dmark)  
84a3 32 c0 ee			ld (debug_mark),a  
84a6 3a b5 84			ld a, (.dmark+1)  
84a9 32 c1 ee			ld (debug_mark+1),a  
84ac 3a b6 84			ld a, (.dmark+2)  
84af 32 c2 ee			ld (debug_mark+2),a  
84b2 18 03			jr .pastdmark  
84b4 ..			.dmark: db "SCR"  
84b7 f1			.pastdmark: pop af  
84b8			endm  
# End of macro DMARK
84b8					CALLMONITOR 
84b8 cd b0 92			call break_point_state  
84bb				endm  
# End of macro CALLMONITOR
84bb				endif 
84bb			 
84bb e5				push hl		; save file name pointer 
84bc			 
84bc cd 62 81			call storage_get_block_0 
84bf			 
84bf 3a eb ec			ld a,(store_page)	; get current file id 
84c2 3c				inc a 
84c3 32 eb ec			ld (store_page),a 
84c6				 
84c6 32 e4 ec			ld (store_tmpid),a			; save id 
84c9			 
84c9 21 00 00			ld hl, 0 
84cc 11 eb ec			ld de, store_page 
84cf				if DEBUG_STORESE 
84cf					DMARK "SCw" 
84cf f5				push af  
84d0 3a e4 84			ld a, (.dmark)  
84d3 32 c0 ee			ld (debug_mark),a  
84d6 3a e5 84			ld a, (.dmark+1)  
84d9 32 c1 ee			ld (debug_mark+1),a  
84dc 3a e6 84			ld a, (.dmark+2)  
84df 32 c2 ee			ld (debug_mark+2),a  
84e2 18 03			jr .pastdmark  
84e4 ..			.dmark: db "SCw"  
84e7 f1			.pastdmark: pop af  
84e8			endm  
# End of macro DMARK
84e8					CALLMONITOR 
84e8 cd b0 92			call break_point_state  
84eb				endm  
# End of macro CALLMONITOR
84eb				endif 
84eb cd 16 81			call storage_write_block	 ; save update 
84ee			 
84ee				if DEBUG_STORESE 
84ee 11 eb ec				ld de, store_page 
84f1					DMARK "SCC" 
84f1 f5				push af  
84f2 3a 06 85			ld a, (.dmark)  
84f5 32 c0 ee			ld (debug_mark),a  
84f8 3a 07 85			ld a, (.dmark+1)  
84fb 32 c1 ee			ld (debug_mark+1),a  
84fe 3a 08 85			ld a, (.dmark+2)  
8501 32 c2 ee			ld (debug_mark+2),a  
8504 18 03			jr .pastdmark  
8506 ..			.dmark: db "SCC"  
8509 f1			.pastdmark: pop af  
850a			endm  
# End of macro DMARK
850a					CALLMONITOR 
850a cd b0 92			call break_point_state  
850d				endm  
# End of macro CALLMONITOR
850d				endif 
850d				;  
850d				 
850d 21 40 00			ld hl, STORE_BLOCK_PHY 
8510 11 00 00			ld de, 0 
8513 cd cf 83			call storage_findnextid 
8516			 
8516 22 d5 ec			ld (store_tmppageid), hl    ; save page to use  
8519			 
8519				; TODO detect 0 = no spare blocks 
8519			 
8519				; hl now contains the free page to use for the file header page 
8519			 
8519				if DEBUG_STORESE 
8519				DMARK "SCF" 
8519 f5				push af  
851a 3a 2e 85			ld a, (.dmark)  
851d 32 c0 ee			ld (debug_mark),a  
8520 3a 2f 85			ld a, (.dmark+1)  
8523 32 c1 ee			ld (debug_mark+1),a  
8526 3a 30 85			ld a, (.dmark+2)  
8529 32 c2 ee			ld (debug_mark+2),a  
852c 18 03			jr .pastdmark  
852e ..			.dmark: db "SCF"  
8531 f1			.pastdmark: pop af  
8532			endm  
# End of macro DMARK
8532					CALLMONITOR 
8532 cd b0 92			call break_point_state  
8535				endm  
# End of macro CALLMONITOR
8535				endif 
8535			 
8535 22 d5 ec			ld (store_tmppageid), hl 
8538				 
8538 3a e4 ec			ld a,(store_tmpid)    ; get file id 
853b			;	ld a, (store_filecache)			; save to cache 
853b			 
853b 32 eb ec			ld (store_page),a    ; set page id 
853e 3e 00			ld a, 0			 ; extent 0 is file header 
8540 32 ec ec			ld (store_page+1), a   ; set file extent 
8543			 
8543 32 ed ec			ld (store_page+2), a   ; extent count for the file 
8546			 
8546			;	inc hl 		; init block 0 of file 
8546			;	inc hl   		; skip file and extent id 
8546			 ;       ld a, 0 
8546			;	ld (hl),a 
8546			;	ld a, (store_filecache+1)  	; save to cache 
8546			 
8546			;	inc hl    ; file name 
8546				 
8546				 
8546 11 ee ec			ld de, store_page+3    ; get buffer for term string to use as file name 
8549				if DEBUG_STORESE 
8549					DMARK "SCc" 
8549 f5				push af  
854a 3a 5e 85			ld a, (.dmark)  
854d 32 c0 ee			ld (debug_mark),a  
8550 3a 5f 85			ld a, (.dmark+1)  
8553 32 c1 ee			ld (debug_mark+1),a  
8556 3a 60 85			ld a, (.dmark+2)  
8559 32 c2 ee			ld (debug_mark+2),a  
855c 18 03			jr .pastdmark  
855e ..			.dmark: db "SCc"  
8561 f1			.pastdmark: pop af  
8562			endm  
# End of macro DMARK
8562					CALLMONITOR 
8562 cd b0 92			call break_point_state  
8565				endm  
# End of macro CALLMONITOR
8565				endif 
8565 e1				pop hl    ; get zero term string 
8566 e5				push hl 
8567 3e 00			ld a, 0 
8569 cd d2 8e			call strlent 
856c 23				inc hl   ; cover zero term 
856d 06 00			ld b,0 
856f 4d				ld c,l 
8570 e1				pop hl 
8571				;ex de, hl 
8571				if DEBUG_STORESE 
8571					DMARK "SCa" 
8571 f5				push af  
8572 3a 86 85			ld a, (.dmark)  
8575 32 c0 ee			ld (debug_mark),a  
8578 3a 87 85			ld a, (.dmark+1)  
857b 32 c1 ee			ld (debug_mark+1),a  
857e 3a 88 85			ld a, (.dmark+2)  
8581 32 c2 ee			ld (debug_mark+2),a  
8584 18 03			jr .pastdmark  
8586 ..			.dmark: db "SCa"  
8589 f1			.pastdmark: pop af  
858a			endm  
# End of macro DMARK
858a					;push af 
858a					;ld a, 'a' 
858a					;ld (debug_mark),a 
858a					;pop af 
858a					CALLMONITOR 
858a cd b0 92			call break_point_state  
858d				endm  
# End of macro CALLMONITOR
858d				endif 
858d ed b0			ldir    ; copy zero term string 
858f				if DEBUG_STORESE 
858f					DMARK "SCA" 
858f f5				push af  
8590 3a a4 85			ld a, (.dmark)  
8593 32 c0 ee			ld (debug_mark),a  
8596 3a a5 85			ld a, (.dmark+1)  
8599 32 c1 ee			ld (debug_mark+1),a  
859c 3a a6 85			ld a, (.dmark+2)  
859f 32 c2 ee			ld (debug_mark+2),a  
85a2 18 03			jr .pastdmark  
85a4 ..			.dmark: db "SCA"  
85a7 f1			.pastdmark: pop af  
85a8			endm  
# End of macro DMARK
85a8					CALLMONITOR 
85a8 cd b0 92			call break_point_state  
85ab				endm  
# End of macro CALLMONITOR
85ab				endif 
85ab			 
85ab				; write file header page 
85ab			 
85ab 2a d5 ec			ld hl,(store_tmppageid) 
85ae 11 eb ec			ld de, store_page 
85b1				if DEBUG_STORESE 
85b1					DMARK "SCb" 
85b1 f5				push af  
85b2 3a c6 85			ld a, (.dmark)  
85b5 32 c0 ee			ld (debug_mark),a  
85b8 3a c7 85			ld a, (.dmark+1)  
85bb 32 c1 ee			ld (debug_mark+1),a  
85be 3a c8 85			ld a, (.dmark+2)  
85c1 32 c2 ee			ld (debug_mark+2),a  
85c4 18 03			jr .pastdmark  
85c6 ..			.dmark: db "SCb"  
85c9 f1			.pastdmark: pop af  
85ca			endm  
# End of macro DMARK
85ca					;push af 
85ca					;ld a, 'b' 
85ca					;ld (debug_mark),a 
85ca					;pop af 
85ca					CALLMONITOR 
85ca cd b0 92			call break_point_state  
85cd				endm  
# End of macro CALLMONITOR
85cd				endif 
85cd cd 16 81			call storage_write_block 
85d0			 
85d0 3a e4 ec			ld a, (store_tmpid) 
85d3 6f				ld l, a 
85d4 26 00			ld h,0 
85d6				if DEBUG_STORESE 
85d6					DMARK "SCz" 
85d6 f5				push af  
85d7 3a eb 85			ld a, (.dmark)  
85da 32 c0 ee			ld (debug_mark),a  
85dd 3a ec 85			ld a, (.dmark+1)  
85e0 32 c1 ee			ld (debug_mark+1),a  
85e3 3a ed 85			ld a, (.dmark+2)  
85e6 32 c2 ee			ld (debug_mark+2),a  
85e9 18 03			jr .pastdmark  
85eb ..			.dmark: db "SCz"  
85ee f1			.pastdmark: pop af  
85ef			endm  
# End of macro DMARK
85ef					CALLMONITOR 
85ef cd b0 92			call break_point_state  
85f2				endm  
# End of macro CALLMONITOR
85f2				endif 
85f2 c9				ret 
85f3				 
85f3			 
85f3			 
85f3			; 
85f3			; Read File 
85f3			; 
85f3			; h - file id to locate 
85f3			; l - extent to locate 
85f3			; de - pointer to string to read into 
85f3			; 
85f3			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85f3			storage_read: 
85f3 d5				push de 
85f4			 
85f4			; TODO BUG the above push is it popped before the RET Z? 
85f4			 
85f4			; TODO how to handle multiple part blocks 
85f4			 
85f4				; locate file extent to read 
85f4			 
85f4 5c				ld e, h 
85f5 55				ld d, l 
85f6 21 40 00			ld hl, STORE_BLOCK_PHY 
85f9				if DEBUG_STORESE 
85f9					DMARK "SRE" 
85f9 f5				push af  
85fa 3a 0e 86			ld a, (.dmark)  
85fd 32 c0 ee			ld (debug_mark),a  
8600 3a 0f 86			ld a, (.dmark+1)  
8603 32 c1 ee			ld (debug_mark+1),a  
8606 3a 10 86			ld a, (.dmark+2)  
8609 32 c2 ee			ld (debug_mark+2),a  
860c 18 03			jr .pastdmark  
860e ..			.dmark: db "SRE"  
8611 f1			.pastdmark: pop af  
8612			endm  
# End of macro DMARK
8612					CALLMONITOR 
8612 cd b0 92			call break_point_state  
8615				endm  
# End of macro CALLMONITOR
8615				endif 
8615 cd cf 83			call storage_findnextid 
8618			 
8618				if DEBUG_STORESE 
8618					DMARK "SRf" 
8618 f5				push af  
8619 3a 2d 86			ld a, (.dmark)  
861c 32 c0 ee			ld (debug_mark),a  
861f 3a 2e 86			ld a, (.dmark+1)  
8622 32 c1 ee			ld (debug_mark+1),a  
8625 3a 2f 86			ld a, (.dmark+2)  
8628 32 c2 ee			ld (debug_mark+2),a  
862b 18 03			jr .pastdmark  
862d ..			.dmark: db "SRf"  
8630 f1			.pastdmark: pop af  
8631			endm  
# End of macro DMARK
8631					CALLMONITOR 
8631 cd b0 92			call break_point_state  
8634				endm  
# End of macro CALLMONITOR
8634				endif 
8634 cd 92 8a			call ishlzero 
8637			;	ld a, l 
8637			;	add h 
8637			;	cp 0 
8637 c8				ret z			; block not found so EOF 
8638			 
8638				; hl contains page number to load 
8638 d1				pop de   ; get storage 
8639 d5				push de 
863a				if DEBUG_STORESE 
863a					DMARK "SRg" 
863a f5				push af  
863b 3a 4f 86			ld a, (.dmark)  
863e 32 c0 ee			ld (debug_mark),a  
8641 3a 50 86			ld a, (.dmark+1)  
8644 32 c1 ee			ld (debug_mark+1),a  
8647 3a 51 86			ld a, (.dmark+2)  
864a 32 c2 ee			ld (debug_mark+2),a  
864d 18 03			jr .pastdmark  
864f ..			.dmark: db "SRg"  
8652 f1			.pastdmark: pop af  
8653			endm  
# End of macro DMARK
8653					CALLMONITOR 
8653 cd b0 92			call break_point_state  
8656				endm  
# End of macro CALLMONITOR
8656				endif 
8656 cd b1 80			call storage_read_block 
8659			 
8659			 
8659			; TODO if block has no zeros then need to read next block  
8659			 
8659			 
8659					 
8659 e1				pop hl 		 ; return start of data to show as not EOF 
865a 23				inc hl   ; past file id 
865b 23				inc hl   ; past ext 
865c				if DEBUG_STORESE 
865c					DMARK "SRe" 
865c f5				push af  
865d 3a 71 86			ld a, (.dmark)  
8660 32 c0 ee			ld (debug_mark),a  
8663 3a 72 86			ld a, (.dmark+1)  
8666 32 c1 ee			ld (debug_mark+1),a  
8669 3a 73 86			ld a, (.dmark+2)  
866c 32 c2 ee			ld (debug_mark+2),a  
866f 18 03			jr .pastdmark  
8671 ..			.dmark: db "SRe"  
8674 f1			.pastdmark: pop af  
8675			endm  
# End of macro DMARK
8675					CALLMONITOR 
8675 cd b0 92			call break_point_state  
8678				endm  
# End of macro CALLMONITOR
8678				endif 
8678 c9					ret 
8679			 
8679			 
8679			 
8679			; 
8679			; Append File 
8679			; 
8679			; hl - file id to locate 
8679			; de - pointer to (multi block) string to write 
8679			 
8679			 
8679			storage_append: 
8679				; hl -  file id to append to 
8679				; de - string to append 
8679			 
8679 d5				push de 
867a				 
867a				if DEBUG_STORESE 
867a					DMARK "AP1" 
867a f5				push af  
867b 3a 8f 86			ld a, (.dmark)  
867e 32 c0 ee			ld (debug_mark),a  
8681 3a 90 86			ld a, (.dmark+1)  
8684 32 c1 ee			ld (debug_mark+1),a  
8687 3a 91 86			ld a, (.dmark+2)  
868a 32 c2 ee			ld (debug_mark+2),a  
868d 18 03			jr .pastdmark  
868f ..			.dmark: db "AP1"  
8692 f1			.pastdmark: pop af  
8693			endm  
# End of macro DMARK
8693					CALLMONITOR 
8693 cd b0 92			call break_point_state  
8696				endm  
# End of macro CALLMONITOR
8696				endif 
8696			 
8696 7d				ld a, l 
8697 32 e4 ec			ld (store_tmpid), a 
869a			 
869a				; get file header  
869a			 
869a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
869c 3a e4 ec			ld a, (store_tmpid) 
869f 5f				ld e, a 
86a0			 
86a0 21 40 00				ld hl, STORE_BLOCK_PHY 
86a3 cd cf 83				call storage_findnextid 
86a6			 
86a6 22 d5 ec			ld (store_tmppageid), hl 
86a9			 
86a9				; TODO handle file id not found 
86a9			 
86a9				if DEBUG_STORESE 
86a9					DMARK "AP2" 
86a9 f5				push af  
86aa 3a be 86			ld a, (.dmark)  
86ad 32 c0 ee			ld (debug_mark),a  
86b0 3a bf 86			ld a, (.dmark+1)  
86b3 32 c1 ee			ld (debug_mark+1),a  
86b6 3a c0 86			ld a, (.dmark+2)  
86b9 32 c2 ee			ld (debug_mark+2),a  
86bc 18 03			jr .pastdmark  
86be ..			.dmark: db "AP2"  
86c1 f1			.pastdmark: pop af  
86c2			endm  
# End of macro DMARK
86c2					CALLMONITOR 
86c2 cd b0 92			call break_point_state  
86c5				endm  
# End of macro CALLMONITOR
86c5				endif 
86c5			 
86c5				; update file extent count 
86c5			 
86c5 11 eb ec			ld de, store_page 
86c8			 
86c8 cd b1 80			call storage_read_block 
86cb			 
86cb				if DEBUG_STORESE 
86cb					DMARK "AP3" 
86cb f5				push af  
86cc 3a e0 86			ld a, (.dmark)  
86cf 32 c0 ee			ld (debug_mark),a  
86d2 3a e1 86			ld a, (.dmark+1)  
86d5 32 c1 ee			ld (debug_mark+1),a  
86d8 3a e2 86			ld a, (.dmark+2)  
86db 32 c2 ee			ld (debug_mark+2),a  
86de 18 03			jr .pastdmark  
86e0 ..			.dmark: db "AP3"  
86e3 f1			.pastdmark: pop af  
86e4			endm  
# End of macro DMARK
86e4					CALLMONITOR 
86e4 cd b0 92			call break_point_state  
86e7				endm  
# End of macro CALLMONITOR
86e7				endif 
86e7			;	ld (store_tmppageid), hl 
86e7			 
86e7 3a ed ec			ld a, (store_page+2) 
86ea 3c				inc a 
86eb 32 ed ec			ld (store_page+2), a 
86ee 32 e3 ec			ld (store_tmpext), a 
86f1				 
86f1				if DEBUG_STORESE 
86f1					DMARK "AP3" 
86f1 f5				push af  
86f2 3a 06 87			ld a, (.dmark)  
86f5 32 c0 ee			ld (debug_mark),a  
86f8 3a 07 87			ld a, (.dmark+1)  
86fb 32 c1 ee			ld (debug_mark+1),a  
86fe 3a 08 87			ld a, (.dmark+2)  
8701 32 c2 ee			ld (debug_mark+2),a  
8704 18 03			jr .pastdmark  
8706 ..			.dmark: db "AP3"  
8709 f1			.pastdmark: pop af  
870a			endm  
# End of macro DMARK
870a					CALLMONITOR 
870a cd b0 92			call break_point_state  
870d				endm  
# End of macro CALLMONITOR
870d				endif 
870d 2a d5 ec			ld hl, (store_tmppageid) 
8710 11 eb ec			ld de, store_page 
8713 cd 16 81			call storage_write_block 
8716			 
8716				; find free block 
8716			 
8716 11 00 00			ld de, 0			 ; file extent to locate 
8719			 
8719 21 40 00				ld hl, STORE_BLOCK_PHY 
871c cd cf 83				call storage_findnextid 
871f			 
871f					; TODO handle no space left 
871f					 
871f 22 d5 ec				ld (store_tmppageid), hl 
8722			 
8722				if DEBUG_STORESE 
8722					DMARK "AP4" 
8722 f5				push af  
8723 3a 37 87			ld a, (.dmark)  
8726 32 c0 ee			ld (debug_mark),a  
8729 3a 38 87			ld a, (.dmark+1)  
872c 32 c1 ee			ld (debug_mark+1),a  
872f 3a 39 87			ld a, (.dmark+2)  
8732 32 c2 ee			ld (debug_mark+2),a  
8735 18 03			jr .pastdmark  
8737 ..			.dmark: db "AP4"  
873a f1			.pastdmark: pop af  
873b			endm  
# End of macro DMARK
873b					CALLMONITOR 
873b cd b0 92			call break_point_state  
873e				endm  
# End of macro CALLMONITOR
873e				endif 
873e					; init the buffer with zeros so we can id if the buffer is full or not 
873e			 
873e e5					push hl 
873f c5					push bc 
8740			 
8740 21 eb ec				ld hl, store_page 
8743 06 40				ld b, STORE_BLOCK_PHY 
8745 3e 00				ld a, 0 
8747 77			.zeroblock:	ld (hl), a 
8748 23					inc hl 
8749 10 fc				djnz .zeroblock 
874b			 
874b c1					pop bc 
874c e1					pop hl 
874d			 
874d					; construct block 
874d			 
874d 3a e4 ec				ld a, (store_tmpid) 
8750 32 eb ec				ld (store_page), a   ; file id 
8753 3a e3 ec				ld a, (store_tmpext)   ; extent for this block 
8756 32 ec ec				ld (store_page+1), a 
8759			 
8759 e1					pop hl    ; get string to write 
875a 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
875c 11 ed ec				ld de, store_page+2 
875f			 
875f				if DEBUG_STORESE 
875f					DMARK "AP5" 
875f f5				push af  
8760 3a 74 87			ld a, (.dmark)  
8763 32 c0 ee			ld (debug_mark),a  
8766 3a 75 87			ld a, (.dmark+1)  
8769 32 c1 ee			ld (debug_mark+1),a  
876c 3a 76 87			ld a, (.dmark+2)  
876f 32 c2 ee			ld (debug_mark+2),a  
8772 18 03			jr .pastdmark  
8774 ..			.dmark: db "AP5"  
8777 f1			.pastdmark: pop af  
8778			endm  
# End of macro DMARK
8778					CALLMONITOR 
8778 cd b0 92			call break_point_state  
877b				endm  
# End of macro CALLMONITOR
877b				endif 
877b			 
877b			 
877b			 
877b					; fill buffer with data until end of string or full block 
877b			 
877b 7e			.appd:		ld a, (hl) 
877c 12					ld (de), a 
877d fe 00				cp 0 
877f 28 04				jr z, .appdone 
8781 23					inc hl 
8782 13					inc de 
8783 10 f6				djnz .appd 
8785			 
8785 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8786 f5					push af   		; save last byte dumped 
8787			 
8787			 
8787 2a d5 ec			ld hl, (store_tmppageid) 
878a 11 eb ec			ld de, store_page 
878d				if DEBUG_STORESE 
878d					DMARK "AP6" 
878d f5				push af  
878e 3a a2 87			ld a, (.dmark)  
8791 32 c0 ee			ld (debug_mark),a  
8794 3a a3 87			ld a, (.dmark+1)  
8797 32 c1 ee			ld (debug_mark+1),a  
879a 3a a4 87			ld a, (.dmark+2)  
879d 32 c2 ee			ld (debug_mark+2),a  
87a0 18 03			jr .pastdmark  
87a2 ..			.dmark: db "AP6"  
87a5 f1			.pastdmark: pop af  
87a6			endm  
# End of macro DMARK
87a6					CALLMONITOR 
87a6 cd b0 92			call break_point_state  
87a9				endm  
# End of macro CALLMONITOR
87a9				endif 
87a9 cd 16 81				call storage_write_block 
87ac			 
87ac			 
87ac				; was that a full block of data written? 
87ac				; any more to write out? 
87ac			 
87ac				; if yes then set vars and jump to start of function again 
87ac			 
87ac f1					pop af 
87ad d1					pop de 
87ae			 
87ae fe 00				cp 0		 ; no, string was fully written 
87b0 c8					ret z 
87b1			 
87b1					; setup vars for next cycle 
87b1			 
87b1 3a e4 ec				ld a, (store_tmpid) 
87b4 6f					ld l, a 
87b5 26 00				ld h, 0 
87b7			 
87b7 c3 79 86			 	jp storage_append	 ; yes, need to write out some more 
87ba			 
87ba			 
87ba			 
87ba			 
87ba			 
87ba			 
87ba			 
87ba			if DEBUG_STORECF 
87ba			storageput:	 
87ba					ret 
87ba			storageread: 
87ba					ld hl, store_page 
87ba					ld b, 200 
87ba					ld a,0 
87ba			.src:		ld (hl),a 
87ba					inc hl 
87ba					djnz .src 
87ba					 
87ba			 
87ba					ld de, 0 
87ba					ld bc, 1 
87ba					ld hl, store_page 
87ba					call cfRead 
87ba			 
87ba				call cfGetError 
87ba				ld hl,scratch 
87ba				call hexout 
87ba				ld hl, scratch+2 
87ba				ld a, 0 
87ba				ld (hl),a 
87ba				ld de, scratch 
87ba				ld a,display_row_1 
87ba				call str_at_display 
87ba				call update_display 
87ba			 
87ba					ld hl, store_page 
87ba					ld (os_cur_ptr),hl 
87ba			 
87ba					ret 
87ba			endif 
87ba			 
87ba			 
87ba			; Clear out the main buffer store (used to remove junk before writing a new block) 
87ba			 
87ba			storage_clear_page: 
87ba e5				push hl 
87bb d5				push de 
87bc c5				push bc 
87bd 21 eb ec			ld hl, store_page 
87c0 3e 00			ld a, 0 
87c2 77				ld (hl), a 
87c3			 
87c3 11 ec ec			ld de, store_page+1 
87c6 01 40 00			ld bc, STORE_BLOCK_PHY 
87c9			 
87c9 ed b0			ldir 
87cb				 
87cb c1				pop bc 
87cc d1				pop de 
87cd e1				pop hl 
87ce c9				ret 
87cf			 
87cf			; eof 
# End of file firmware_storage.asm
87cf			  
87cf			; support routines for above hardware abstraction layer  
87cf			  
87cf			include "firmware_general.asm"        ; general support functions  
87cf			 
87cf			 
87cf			 
87cf			; Delay loops 
87cf			 
87cf			 
87cf			 
87cf			aDelayInMS: 
87cf c5				push bc 
87d0 47				ld b,a 
87d1			msdelay: 
87d1 c5				push bc 
87d2				 
87d2			 
87d2 01 41 00			ld bc,041h 
87d5 cd ed 87			call delayloop 
87d8 c1				pop bc 
87d9 05				dec b 
87da 20 f5			jr nz,msdelay 
87dc			 
87dc			;if CPU_CLOCK_8MHZ 
87dc			;msdelay8: 
87dc			;	push bc 
87dc			;	 
87dc			; 
87dc			;	ld bc,041h 
87dc			;	call delayloop 
87dc			;	pop bc 
87dc			;	dec b 
87dc			;	jr nz,msdelay8 
87dc			;endif 
87dc			 
87dc			 
87dc c1				pop bc 
87dd c9				ret 
87de			 
87de			 
87de			delay250ms: 
87de				;push de 
87de 01 00 40			ld bc, 04000h 
87e1 c3 ed 87			jp delayloop 
87e4			delay500ms: 
87e4				;push de 
87e4 01 00 80			ld bc, 08000h 
87e7 c3 ed 87			jp delayloop 
87ea			delay1s: 
87ea				;push bc 
87ea			   ; Clobbers A, d and e 
87ea 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
87ed			delayloop: 
87ed c5			    push bc 
87ee			 
87ee			if BASE_CPM 
87ee				ld bc, CPM_DELAY_TUNE 
87ee			.cpmloop: 
87ee				push bc 
87ee			 
87ee			endif 
87ee			 
87ee			 
87ee			 
87ee			delayloopi: 
87ee			;	push bc 
87ee			;.dl: 
87ee cb 47		    bit     0,a    	; 8 
87f0 cb 47		    bit     0,a    	; 8 
87f2 cb 47		    bit     0,a    	; 8 
87f4 e6 ff		    and     255  	; 7 
87f6 0b			    dec     bc      	; 6 
87f7 79			    ld      a,c     	; 4 
87f8 b0			    or      b     	; 4 
87f9 c2 ee 87		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
87fc			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
87fc				;pop de 
87fc			;pop bc 
87fc			 
87fc			if BASE_CPM 
87fc				pop bc 
87fc				 
87fc			    dec     bc      	; 6 
87fc			    ld      a,c     	; 4 
87fc			    or      b     	; 4 
87fc			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
87fc				 
87fc			 
87fc			endif 
87fc			;if CPU_CLOCK_8MHZ 
87fc			;    pop bc 
87fc			;    push bc 
87fc			;.dl8: 
87fc			;    bit     0,a    	; 8 
87fc			;    bit     0,a    	; 8 
87fc			;    bit     0,a    	; 8 
87fc			;    and     255  	; 7 
87fc			;    dec     bc      	; 6 
87fc			;    ld      a,c     	; 4 
87fc			;    or      b     	; 4 
87fc			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
87fc			;endif 
87fc			 
87fc			;if CPU_CLOCK_10MHZ 
87fc			;    pop bc 
87fc			;    push bc 
87fc			;.dl8: 
87fc			;    bit     0,a    	; 8 
87fc			;    bit     0,a    	; 8 
87fc			;    bit     0,a    	; 8 
87fc			;    and     255  	; 7 
87fc			;    dec     bc      	; 6 
87fc			;    ld      a,c     	; 4 
87fc			;    or      b     	; 4 
87fc			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
87fc			;endif 
87fc c1			    pop bc 
87fd			 
87fd c9				ret 
87fe			 
87fe			 
87fe			 
87fe			; eof 
# End of file firmware_general.asm
87fe			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
87fe			; display routines that use the physical hardware abstraction layer 
87fe			 
87fe			 
87fe			; TODO windowing? 
87fe			 
87fe			; TODO scroll line up 
87fe			 
87fe			scroll_up: 
87fe			 
87fe e5				push hl 
87ff d5				push de 
8800 c5				push bc 
8801			 
8801				; get frame buffer  
8801			 
8801 2a 61 ed			ld hl, (display_fb_active) 
8804 e5				push hl    ; future de destination 
8805			 
8805 11 14 00			ld  de, display_cols 
8808 19				add hl, de 
8809			 
8809 d1				pop de 
880a			 
880a				;ex de, hl 
880a 01 4f 00			ld bc, display_fb_len -1  
880d			;if DEBUG_FORTH_WORDS 
880d			;	DMARK "SCL" 
880d			;	CALLMONITOR 
880d			;endif	 
880d ed b0			ldir 
880f			 
880f				; wipe bottom row 
880f			 
880f			 
880f 2a 61 ed			ld hl, (display_fb_active) 
8812 11 50 00			ld de, display_cols*display_rows 
8815 19				add hl, de 
8816 06 14			ld b, display_cols 
8818 3e 20			ld a, ' ' 
881a			.scwipe: 
881a 77				ld (hl), a 
881b 2b				dec hl 
881c 10 fc			djnz .scwipe 
881e			 
881e				;pop hl 
881e			 
881e c1				pop bc 
881f d1				pop de 
8820 e1				pop hl 
8821			 
8821 c9				ret 
8822			 
8822			 
8822			;scroll_upo: 
8822			;	ld de, display_row_1 
8822			 ;	ld hl, display_row_2 
8822			;	ld bc, display_cols 
8822			;	ldir 
8822			;	ld de, display_row_2 
8822			 ;	ld hl, display_row_3 
8822			;	ld bc, display_cols 
8822			;	ldir 
8822			;	ld de, display_row_3 
8822			 ;	ld hl, display_row_4 
8822			;	ld bc, display_cols 
8822			;	ldir 
8822			 
8822			; TODO clear row 4 
8822			 
8822			;	ret 
8822			 
8822				 
8822			scroll_down: 
8822			 
8822 e5				push hl 
8823 d5				push de 
8824 c5				push bc 
8825			 
8825				; get frame buffer  
8825			 
8825 2a 61 ed			ld hl, (display_fb_active) 
8828			 
8828 11 4f 00			ld de, display_fb_len - 1 
882b 19				add hl, de 
882c			 
882c e5			push hl    ; future de destination 
882d			 
882d 11 14 00			ld  de, display_cols 
8830 ed 52			sbc hl, de 
8832			 
8832			 
8832 d1				pop de 
8833			 
8833			;	ex de, hl 
8833 01 4f 00			ld bc, display_fb_len -1  
8836			 
8836			 
8836				 
8836			 
8836 ed b0			ldir 
8838			 
8838				; wipe bottom row 
8838			 
8838			 
8838			;	ld hl, (display_fb_active) 
8838			;;	ld de, display_cols*display_rows 
8838			;;	add hl, de 
8838			;	ld b, display_cols 
8838			;	ld a, ' ' 
8838			;.scwiped: 
8838			;	ld (hl), a 
8838			;	dec hl 
8838			;	djnz .scwiped 
8838			 
8838				;pop hl 
8838			 
8838 c1				pop bc 
8839 d1				pop de 
883a e1				pop hl 
883b			 
883b c9				ret 
883c			;scroll_down: 
883c			;	ld de, display_row_4 
883c			;	ld hl, display_row_3 
883c			;	ld bc, display_cols 
883c			;	ldir 
883c			;	ld de, display_row_3 
883c			; 	ld hl, display_row_2 
883c			;	ld bc, display_cols 
883c			;	ldir 
883c			;	ld de, display_row_2 
883c			;	ld hl, display_row_1 
883c			;	ld bc, display_cols 
883c			;	ldir 
883c			;;; TODO clear row 1 
883c			;	ret 
883c			 
883c			 
883c			 
883c			 
883c			 
883c			; clear active frame buffer 
883c			 
883c			clear_display: 
883c 3e 20			ld a, ' ' 
883e c3 41 88			jp fill_display 
8841			 
8841			; fill active frame buffer with a char in A 
8841			 
8841			fill_display: 
8841 06 50			ld b,display_fb_len 
8843 2a 61 ed			ld hl, (display_fb_active) 
8846 77			.fd1:	ld (hl),a 
8847 23				inc hl 
8848 10 fc			djnz .fd1 
884a 23				inc hl 
884b 3e 00			ld a,0 
884d 77				ld (hl),a 
884e			 
884e			 
884e c9				ret 
884f			; Write string (DE) at pos (A) to active frame buffer 
884f			 
884f 2a 61 ed		str_at_display:    ld hl,(display_fb_active) 
8852 06 00					ld b,0 
8854 4f					ld c,a 
8855 09					add hl,bc 
8856 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8857 b7			            OR   A              ;Null terminator? 
8858 c8			            RET  Z              ;Yes, so finished 
8859 77					ld (hl),a 
885a 23				inc hl 
885b 13			            INC  DE             ;Point to next character 
885c 18 f8		            JR   .sad1     ;Repeat 
885e c9					ret 
885f			 
885f			; using current frame buffer write to physical display 
885f			 
885f			update_display: 
885f e5				push hl 
8860 2a 61 ed			ld hl, (display_fb_active) 
8863 cd 8f d7			call write_display 
8866 e1				pop hl 
8867 c9				ret 
8868			 
8868			; TODO scrolling 
8868			 
8868			 
8868			; move cursor right one char 
8868			cursor_right: 
8868			 
8868				; TODO shift right 
8868				; TODO if beyond max col 
8868				; TODO       cursor_next_line 
8868			 
8868 c9				ret 
8869			 
8869			 
8869			cursor_next_line: 
8869				; TODO first char 
8869				; TODO line down 
8869				; TODO if past last row 
8869				; TODO    scroll up 
8869			 
8869 c9				ret 
886a			 
886a			cursor_left: 
886a				; TODO shift left 
886a				; TODO if beyond left  
886a				; TODO     cursor prev line 
886a				 
886a c9				ret 
886b			 
886b			cursor_prev_line: 
886b				; TODO last char 
886b				; TODO line up 
886b				; TODO if past first row 
886b				; TODO   scroll down 
886b			 
886b c9				ret 
886c			 
886c			 
886c			cout: 
886c				; A - char 
886c c9				ret 
886d			 
886d			 
886d			; Display a menu and allow item selection (optional toggle items) 
886d			; 
886d			; format: 
886d			; hl pointer to word array with zero term for items 
886d			; e.g.    db item1 
886d			;         db .... 
886d			;         db 0 
886d			; 
886d			; a = starting menu item  
886d			; 
886d			; de = pointer item toggle array   (todo) 
886d			; 
886d			; returns item selected in a 1-... 
886d			; returns 0 if back button pressed 
886d			; 
886d			; NOTE: Uses system frame buffer to display 
886d			; 
886d			; LEFT, Q = go back 
886d			; RIGHT, SPACE, CR = select 
886d			; UP, A - Up 
886d			; DOWN, Z - Down 
886d			 
886d			 
886d			 
886d			 
886d			 
886d			menu: 
886d			 
886d					; keep array pointer 
886d			 
886d 22 e9 ec				ld (store_tmp1), hl 
8870 32 e7 ec				ld (store_tmp2), a 
8873			 
8873					; check for key bounce 
8873			 
8873			if BASE_KEV 
8873			 
8873			.mbounce:	call cin 
8873					cp 0 
8873					jr nz, .mbounce 
8873			endif 
8873					; for ease use ex 
8873			 
8873					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8873 21 56 ee				ld hl, display_fb0 
8876 22 61 ed				ld (display_fb_active), hl 
8879			 
8879 cd 3c 88		.mloop:		call clear_display 
887c cd 5f 88				call update_display 
887f			 
887f					; draw selection id '>' at 1 
887f			 
887f					; init start of list display 
887f			 
887f 3e 05				ld a, 5 
8881 32 e5 ec				ld (store_tmp3), a   ; display row count 
8884 3a e7 ec				ld a,( store_tmp2) 
8887 32 e8 ec				ld (store_tmp2+1), a   ; display item count 
888a			 
888a					 
888a			.mitem:	 
888a			 
888a			 
888a 3a e8 ec				ld a,(store_tmp2+1) 
888d 6f					ld l, a 
888e 26 00				ld h, 0 
8890 29					add hl, hl 
8891 ed 5b e9 ec			ld de, (store_tmp1) 
8895 19					add hl, de 
8896 7e					ld a, (hl) 
8897 23					inc hl 
8898 66					ld h,(hl) 
8899 6f					ld l, a 
889a			 
889a cd 92 8a				call ishlzero 
889d 28 1a				jr z, .mdone 
889f			 
889f eb					ex de, hl 
88a0 3a e5 ec				ld a, (store_tmp3) 
88a3 cd 4f 88				call str_at_display 
88a6					 
88a6			 
88a6					; next item 
88a6 3a e8 ec				ld a, (store_tmp2+1) 
88a9 3c					inc a 
88aa 32 e8 ec				ld (store_tmp2+1), a   ; display item count 
88ad			 
88ad			 		; next row 
88ad			 
88ad 3a e5 ec				ld a, (store_tmp3) 
88b0 c6 14				add display_cols 
88b2 32 e5 ec				ld (store_tmp3), a 
88b5			 
88b5					; at end of screen? 
88b5			 
88b5 fe 10				cp display_rows*4 
88b7 20 d1				jr nz, .mitem 
88b9			 
88b9			 
88b9			.mdone: 
88b9 cd 92 8a				call ishlzero 
88bc 28 08				jr z, .nodn 
88be			 
88be 3e 3c				ld a, display_row_4 
88c0 11 3f 89				ld de, .mdown 
88c3 cd 4f 88				call str_at_display 
88c6			 
88c6					; draw options to fill the screens with active item on line 1 
88c6					; if current option is 2 or more then display ^ in top 
88c6			 
88c6 3a e7 ec		.nodn:		ld a, (store_tmp2) 
88c9 fe 00				cp 0 
88cb 28 08				jr z, .noup 
88cd			 
88cd 3e 00				ld a, 0 
88cf 11 3d 89				ld de, .mup 
88d2 cd 4f 88				call str_at_display 
88d5			 
88d5 3e 02		.noup:		ld a, 2 
88d7 11 3b 89				ld de, .msel 
88da cd 4f 88				call str_at_display 
88dd			 
88dd					; if current option + 1 is not null then display V in bottom 
88dd					; get key 
88dd cd 5f 88				call update_display 
88e0			 
88e0			 
88e0					; handle key 
88e0			 
88e0 cd 1b d8				call cin_wait 
88e3			 
88e3 fe 05				cp KEY_UP 
88e5 28 2b				jr z, .mgoup 
88e7 fe 61				cp 'a' 
88e9 28 27				jr z, .mgoup 
88eb fe 0a				cp KEY_DOWN 
88ed 28 32				jr z, .mgod 
88ef fe 7a				cp 'z' 
88f1 28 2e				jr z, .mgod 
88f3 fe 20				cp ' ' 
88f5 28 34				jr z, .goend 
88f7 fe 0c				cp KEY_RIGHT 
88f9 28 30				jr z, .goend 
88fb fe 0d				cp KEY_CR 
88fd 28 2c				jr z, .goend 
88ff fe 71				cp 'q' 
8901 28 0b				jr z, .goback 
8903			 
8903 fe 0b				cp KEY_LEFT 
8905 28 07				jr z, .goback 
8907 fe 08				cp KEY_BS 
8909 28 03				jr z, .goback 
890b c3 79 88				jp .mloop 
890e			 
890e			.goback: 
890e 3e 00			ld a, 0 
8910 18 1d			jr .goend2 
8912			 
8912				; move up one 
8912			.mgoup: 
8912 3a e7 ec				ld a, (store_tmp2) 
8915 fe 00				cp 0 
8917 ca 79 88				jp z, .mloop 
891a 3d					dec a 
891b 32 e7 ec				ld (store_tmp2), a 
891e c3 79 88				jp .mloop 
8921			 
8921				; move down one 
8921			.mgod: 
8921 3a e7 ec				ld a, (store_tmp2) 
8924 3c					inc a 
8925 32 e7 ec				ld (store_tmp2), a 
8928 c3 79 88				jp .mloop 
892b			 
892b			 
892b			.goend: 
892b					; get selected item number 
892b			 
892b 3a e7 ec				ld a, (store_tmp2) 
892e 3c					inc a 
892f			 
892f			.goend2: 
892f f5					push af 
8930			 
8930					; restore active fb 
8930					; TODO BUG assumes fb1 
8930			 
8930 21 05 ee				ld hl, display_fb1 
8933 22 61 ed				ld (display_fb_active), hl 
8936			 
8936					; restore main regs 
8936			 
8936			 
8936 cd 5f 88				call update_display 
8939			 
8939 f1					pop af 
893a			 
893a c9				ret 
893b			 
893b .. 00		.msel:   db ">",0 
893d .. 00		.mup:   db "^",0 
893f .. 00		.mdown:   db "v",0 
8941			 
8941			 
8941			; eof 
8941			 
# End of file firmware_display.asm
8941			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8941			; random number generators 
8941			 
8941			 
8941			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8941			 
8941			 
8941			;-----> Generate a random number 
8941			; output a=answer 0<=a<=255 
8941			; all registers are preserved except: af 
8941			random: 
8941 e5			        push    hl 
8942 d5			        push    de 
8943 2a 43 ed		        ld      hl,(randData) 
8946 ed 5f		        ld      a,r 
8948 57			        ld      d,a 
8949 5e			        ld      e,(hl) 
894a 19			        add     hl,de 
894b 85			        add     a,l 
894c ac			        xor     h 
894d 22 43 ed		        ld      (randData),hl 
8950 d1			        pop     de 
8951 e1			        pop     hl 
8952 c9			        ret 
8953			 
8953			 
8953			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8953			 
8953			 
8953			 
8953			;------LFSR------ 
8953			;James Montelongo 
8953			;optimized by Spencer Putt 
8953			;out: 
8953			; a = 8 bit random number 
8953			RandLFSR: 
8953 21 49 ed		        ld hl,LFSRSeed+4 
8956 5e			        ld e,(hl) 
8957 23			        inc hl 
8958 56			        ld d,(hl) 
8959 23			        inc hl 
895a 4e			        ld c,(hl) 
895b 23			        inc hl 
895c 7e			        ld a,(hl) 
895d 47			        ld b,a 
895e cb 13		        rl e  
8960 cb 12			rl d 
8962 cb 11		        rl c  
8964 17				rla 
8965 cb 13		        rl e  
8967 cb 12			rl d 
8969 cb 11		        rl c  
896b 17				rla 
896c cb 13		        rl e  
896e cb 12			rl d 
8970 cb 11		        rl c  
8972 17				rla 
8973 67			        ld h,a 
8974 cb 13		        rl e  
8976 cb 12			rl d 
8978 cb 11		        rl c  
897a 17				rla 
897b a8			        xor b 
897c cb 13		        rl e  
897e cb 12			rl d 
8980 ac			        xor h 
8981 a9			        xor c 
8982 aa			        xor d 
8983 21 4b ed		        ld hl,LFSRSeed+6 
8986 11 4c ed		        ld de,LFSRSeed+7 
8989 01 07 00		        ld bc,7 
898c ed b8		        lddr 
898e 12			        ld (de),a 
898f c9			        ret 
8990			 
8990			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8990			 
8990			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8990			 
8990			 
8990			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8990			 
8990			prng16: 
8990			;Inputs: 
8990			;   (seed1) contains a 16-bit seed value 
8990			;   (seed2) contains a NON-ZERO 16-bit seed value 
8990			;Outputs: 
8990			;   HL is the result 
8990			;   BC is the result of the LCG, so not that great of quality 
8990			;   DE is preserved 
8990			;Destroys: 
8990			;   AF 
8990			;cycle: 4,294,901,760 (almost 4.3 billion) 
8990			;160cc 
8990			;26 bytes 
8990 2a 3d ed		    ld hl,(seed1) 
8993 44			    ld b,h 
8994 4d			    ld c,l 
8995 29			    add hl,hl 
8996 29			    add hl,hl 
8997 2c			    inc l 
8998 09			    add hl,bc 
8999 22 3d ed		    ld (seed1),hl 
899c 2a 3b ed		    ld hl,(seed2) 
899f 29			    add hl,hl 
89a0 9f			    sbc a,a 
89a1 e6 2d		    and %00101101 
89a3 ad			    xor l 
89a4 6f			    ld l,a 
89a5 22 3b ed		    ld (seed2),hl 
89a8 09			    add hl,bc 
89a9 c9			    ret 
89aa			 
89aa			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
89aa			 
89aa			rand32: 
89aa			;Inputs: 
89aa			;   (seed1_0) holds the lower 16 bits of the first seed 
89aa			;   (seed1_1) holds the upper 16 bits of the first seed 
89aa			;   (seed2_0) holds the lower 16 bits of the second seed 
89aa			;   (seed2_1) holds the upper 16 bits of the second seed 
89aa			;   **NOTE: seed2 must be non-zero 
89aa			;Outputs: 
89aa			;   HL is the result 
89aa			;   BC,DE can be used as lower quality values, but are not independent of HL. 
89aa			;Destroys: 
89aa			;   AF 
89aa			;Tested and passes all CAcert tests 
89aa			;Uses a very simple 32-bit LCG and 32-bit LFSR 
89aa			;it has a period of 18,446,744,069,414,584,320 
89aa			;roughly 18.4 quintillion. 
89aa			;LFSR taps: 0,2,6,7  = 11000101 
89aa			;291cc 
89aa			;seed1_0=$+1 
89aa			;    ld hl,12345 
89aa			;seed1_1=$+1 
89aa			;    ld de,6789 
89aa			;    ld b,h 
89aa			;    ld c,l 
89aa			;    add hl,hl \ rl e \ rl d 
89aa			;    add hl,hl \ rl e \ rl d 
89aa			;    inc l 
89aa			;    add hl,bc 
89aa			;    ld (seed1_0),hl 
89aa			;    ld hl,(seed1_1) 
89aa			;    adc hl,de 
89aa			;    ld (seed1_1),hl 
89aa			;    ex de,hl 
89aa			;seed2_0=$+1 
89aa			;    ld hl,9876 
89aa			;seed2_1=$+1 
89aa			;    ld bc,54321 
89aa			;    add hl,hl \ rl c \ rl b 
89aa			;    ld (seed2_1),bc 
89aa			;    sbc a,a 
89aa			;    and %11000101 
89aa			;    xor l 
89aa			;    ld l,a 
89aa			;    ld (seed2_0),hl 
89aa			;    ex de,hl 
89aa			;    add hl,bc 
89aa			;    ret 
89aa			; 
89aa			 
89aa			; 16-bit xorshift pseudorandom number generator by John Metcalf 
89aa			; 20 bytes, 86 cycles (excluding ret) 
89aa			 
89aa			; returns   hl = pseudorandom number 
89aa			; corrupts   a 
89aa			 
89aa			; generates 16-bit pseudorandom numbers with a period of 65535 
89aa			; using the xorshift method: 
89aa			 
89aa			; hl ^= hl << 7 
89aa			; hl ^= hl >> 9 
89aa			; hl ^= hl << 8 
89aa			 
89aa			; some alternative shift triplets which also perform well are: 
89aa			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
89aa			 
89aa			;  org 32768 
89aa			 
89aa			xrnd: 
89aa 2a 41 ed		  ld hl,(xrandc)       ; seed must not be 0 
89ad 3e 00		  ld a,0 
89af bd			  cp l 
89b0 20 02		  jr nz, .xrnd1 
89b2 2e 01		  ld l, 1 
89b4			.xrnd1: 
89b4			 
89b4 7c			  ld a,h 
89b5 1f			  rra 
89b6 7d			  ld a,l 
89b7 1f			  rra 
89b8 ac			  xor h 
89b9 67			  ld h,a 
89ba 7d			  ld a,l 
89bb 1f			  rra 
89bc 7c			  ld a,h 
89bd 1f			  rra 
89be ad			  xor l 
89bf 6f			  ld l,a 
89c0 ac			  xor h 
89c1 67			  ld h,a 
89c2			 
89c2 22 41 ed		  ld (xrandc),hl 
89c5			 
89c5 c9			  ret 
89c6			;  
89c6			 
89c6			 
89c6			;;;; int maths 
89c6			 
89c6			; https://map.grauw.nl/articles/mult_div_shifts.php 
89c6			; Divide 16-bit values (with 16-bit result) 
89c6			; In: Divide BC by divider DE 
89c6			; Out: BC = result, HL = rest 
89c6			; 
89c6			Div16: 
89c6 21 00 00		    ld hl,0 
89c9 78			    ld a,b 
89ca 06 08		    ld b,8 
89cc			Div16_Loop1: 
89cc 17			    rla 
89cd ed 6a		    adc hl,hl 
89cf ed 52		    sbc hl,de 
89d1 30 01		    jr nc,Div16_NoAdd1 
89d3 19			    add hl,de 
89d4			Div16_NoAdd1: 
89d4 10 f6		    djnz Div16_Loop1 
89d6 17			    rla 
89d7 2f			    cpl 
89d8 47			    ld b,a 
89d9 79			    ld a,c 
89da 48			    ld c,b 
89db 06 08		    ld b,8 
89dd			Div16_Loop2: 
89dd 17			    rla 
89de ed 6a		    adc hl,hl 
89e0 ed 52		    sbc hl,de 
89e2 30 01		    jr nc,Div16_NoAdd2 
89e4 19			    add hl,de 
89e5			Div16_NoAdd2: 
89e5 10 f6		    djnz Div16_Loop2 
89e7 17			    rla 
89e8 2f			    cpl 
89e9 41			    ld b,c 
89ea 4f			    ld c,a 
89eb c9			ret 
89ec			 
89ec			 
89ec			;http://z80-heaven.wikidot.com/math 
89ec			; 
89ec			;Inputs: 
89ec			;     DE and A are factors 
89ec			;Outputs: 
89ec			;     A is not changed 
89ec			;     B is 0 
89ec			;     C is not changed 
89ec			;     DE is not changed 
89ec			;     HL is the product 
89ec			;Time: 
89ec			;     342+6x 
89ec			; 
89ec			Mult16: 
89ec			 
89ec 06 08		     ld b,8          ;7           7 
89ee 21 00 00		     ld hl,0         ;10         10 
89f1 29			       add hl,hl     ;11*8       88 
89f2 07			       rlca          ;4*8        32 
89f3 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
89f5 19			         add hl,de   ;--         -- 
89f6 10 f9		       djnz $-5      ;13*7+8     99 
89f8 c9			ret 
89f9			 
89f9			; 
89f9			; Square root of 16-bit value 
89f9			; In:  HL = value 
89f9			; Out:  D = result (rounded down) 
89f9			; 
89f9			;Sqr16: 
89f9			;    ld de,#0040 
89f9			;    ld a,l 
89f9			;    ld l,h 
89f9			;    ld h,d 
89f9			;    or a 
89f9			;    ld b,8 
89f9			;Sqr16_Loop: 
89f9			;    sbc hl,de 
89f9			;    jr nc,Sqr16_Skip 
89f9			;    add hl,de 
89f9			;Sqr16_Skip: 
89f9			;    ccf 
89f9			;    rl d 
89f9			;    add a,a 
89f9			;    adc hl,hl 
89f9			;    add a,a 
89f9			;    adc hl,hl 
89f9			;    djnz Sqr16_Loop 
89f9			;    ret 
89f9			; 
89f9			; 
89f9			; Divide 8-bit values 
89f9			; In: Divide E by divider C 
89f9			; Out: A = result, B = rest 
89f9			; 
89f9			Div8: 
89f9 af			    xor a 
89fa 06 08		    ld b,8 
89fc			Div8_Loop: 
89fc cb 13		    rl e 
89fe 17			    rla 
89ff 91			    sub c 
8a00 30 01		    jr nc,Div8_NoAdd 
8a02 81			    add a,c 
8a03			Div8_NoAdd: 
8a03 10 f7		    djnz Div8_Loop 
8a05 47			    ld b,a 
8a06 7b			    ld a,e 
8a07 17			    rla 
8a08 2f			    cpl 
8a09 c9			    ret 
8a0a			 
8a0a			; 
8a0a			; Multiply 8-bit value with a 16-bit value (unrolled) 
8a0a			; In: Multiply A with DE 
8a0a			; Out: HL = result 
8a0a			; 
8a0a			Mult12U: 
8a0a 2e 00		    ld l,0 
8a0c 87			    add a,a 
8a0d 30 01		    jr nc,Mult12U_NoAdd0 
8a0f 19			    add hl,de 
8a10			Mult12U_NoAdd0: 
8a10 29			    add hl,hl 
8a11 87			    add a,a 
8a12 30 01		    jr nc,Mult12U_NoAdd1 
8a14 19			    add hl,de 
8a15			Mult12U_NoAdd1: 
8a15 29			    add hl,hl 
8a16 87			    add a,a 
8a17 30 01		    jr nc,Mult12U_NoAdd2 
8a19 19			    add hl,de 
8a1a			Mult12U_NoAdd2: 
8a1a 29			    add hl,hl 
8a1b 87			    add a,a 
8a1c 30 01		    jr nc,Mult12U_NoAdd3 
8a1e 19			    add hl,de 
8a1f			Mult12U_NoAdd3: 
8a1f 29			    add hl,hl 
8a20 87			    add a,a 
8a21 30 01		    jr nc,Mult12U_NoAdd4 
8a23 19			    add hl,de 
8a24			Mult12U_NoAdd4: 
8a24 29			    add hl,hl 
8a25 87			    add a,a 
8a26 30 01		    jr nc,Mult12U_NoAdd5 
8a28 19			    add hl,de 
8a29			Mult12U_NoAdd5: 
8a29 29			    add hl,hl 
8a2a 87			    add a,a 
8a2b 30 01		    jr nc,Mult12U_NoAdd6 
8a2d 19			    add hl,de 
8a2e			Mult12U_NoAdd6: 
8a2e 29			    add hl,hl 
8a2f 87			    add a,a 
8a30 d0			    ret nc 
8a31 19			    add hl,de 
8a32 c9			    ret 
8a33			 
8a33			; 
8a33			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a33			; In: Multiply A with DE 
8a33			;      Put lowest value in A for most efficient calculation 
8a33			; Out: HL = result 
8a33			; 
8a33			Mult12R: 
8a33 21 00 00		    ld hl,0 
8a36			Mult12R_Loop: 
8a36 cb 3f		    srl a 
8a38 30 01		    jr nc,Mult12R_NoAdd 
8a3a 19			    add hl,de 
8a3b			Mult12R_NoAdd: 
8a3b cb 23		    sla e 
8a3d cb 12		    rl d 
8a3f b7			    or a 
8a40 c2 36 8a		    jp nz,Mult12R_Loop 
8a43 c9			    ret 
8a44			 
8a44			; 
8a44			; Multiply 16-bit values (with 32-bit result) 
8a44			; In: Multiply BC with DE 
8a44			; Out: BCHL = result 
8a44			; 
8a44			Mult32: 
8a44 79			    ld a,c 
8a45 48			    ld c,b 
8a46 21 00 00		    ld hl,0 
8a49 06 10		    ld b,16 
8a4b			Mult32_Loop: 
8a4b 29			    add hl,hl 
8a4c 17			    rla 
8a4d cb 11		    rl c 
8a4f 30 07		    jr nc,Mult32_NoAdd 
8a51 19			    add hl,de 
8a52 ce 00		    adc a,0 
8a54 d2 58 8a		    jp nc,Mult32_NoAdd 
8a57 0c			    inc c 
8a58			Mult32_NoAdd: 
8a58 10 f1		    djnz Mult32_Loop 
8a5a 41			    ld b,c 
8a5b 4f			    ld c,a 
8a5c c9			    ret 
8a5d			 
8a5d			 
8a5d			 
8a5d			; 
8a5d			; Multiply 8-bit values 
8a5d			; In:  Multiply H with E 
8a5d			; Out: HL = result 
8a5d			; 
8a5d			Mult8: 
8a5d 16 00		    ld d,0 
8a5f 6a			    ld l,d 
8a60 06 08		    ld b,8 
8a62			Mult8_Loop: 
8a62 29			    add hl,hl 
8a63 30 01		    jr nc,Mult8_NoAdd 
8a65 19			    add hl,de 
8a66			Mult8_NoAdd: 
8a66 10 fa		    djnz Mult8_Loop 
8a68 c9			    ret 
8a69			 
8a69			 
8a69			 
8a69			 
8a69			 
8a69			 
8a69			 
8a69			 
8a69			;;http://z80-heaven.wikidot.com/math 
8a69			;;This divides DE by BC, storing the result in DE, remainder in HL 
8a69			; 
8a69			;DE_Div_BC:          ;1281-2x, x is at most 16 
8a69			;     ld a,16        ;7 
8a69			;     ld hl,0        ;10 
8a69			;     jp $+5         ;10 
8a69			;.DivLoop: 
8a69			;       add hl,bc    ;-- 
8a69			;       dec a        ;64 
8a69			;       jr z,.DivLoopEnd        ;86 
8a69			; 
8a69			;       sla e        ;128 
8a69			;       rl d         ;128 
8a69			;       adc hl,hl    ;240 
8a69			;       sbc hl,bc    ;240 
8a69			;       jr nc,.DivLoop ;23|21 
8a69			;       inc e        ;-- 
8a69			;       jp .DivLoop+1 
8a69			; 
8a69			;.DivLoopEnd: 
8a69			 
8a69			;HL_Div_C: 
8a69			;Inputs: 
8a69			;     HL is the numerator 
8a69			;     C is the denominator 
8a69			;Outputs: 
8a69			;     A is the remainder 
8a69			;     B is 0 
8a69			;     C is not changed 
8a69			;     DE is not changed 
8a69			;     HL is the quotient 
8a69			; 
8a69			;       ld b,16 
8a69			;       xor a 
8a69			;         add hl,hl 
8a69			;         rla 
8a69			;         cp c 
8a69			;         jr c,$+4 
8a69			;           inc l 
8a69			;           sub c 
8a69			;         djnz $-7 
8a69			 
8a69			; https://plutiedev.com/z80-add-8bit-to-16bit 
8a69			 
8a69			addatohl: 
8a69 85			    add   a, l    ; A = A+L 
8a6a 6f			    ld    l, a    ; L = A+L 
8a6b 8c			    adc   a, h    ; A = A+L+H+carry 
8a6c 95			    sub   l       ; A = H+carry 
8a6d 67			    ld    h, a    ; H = H+carry 
8a6e c9			ret 
8a6f			 
8a6f			addatode: 
8a6f 83			    add   a, e    ; A = A+L 
8a70 5f			    ld    e, a    ; L = A+L 
8a71 8a			    adc   a, d    ; A = A+L+H+carry 
8a72 93			    sub   e       ; A = H+carry 
8a73 57			    ld    d, a    ; H = H+carry 
8a74 c9			ret 
8a75			 
8a75			 
8a75			addatobc: 
8a75 81			    add   a, c    ; A = A+L 
8a76 4f			    ld    c, a    ; L = A+L 
8a77 88			    adc   a, b    ; A = A+L+H+carry 
8a78 91			    sub   c       ; A = H+carry 
8a79 47			    ld    b, a    ; H = H+carry 
8a7a c9			ret 
8a7b			 
8a7b			subafromhl: 
8a7b			   ; If A=0 do nothing 
8a7b			    ; Otherwise flip A's sign. Since 
8a7b			    ; the upper byte becomes -1, also 
8a7b			    ; substract 1 from H. 
8a7b ed 44		    neg 
8a7d ca 86 8a		    jp    z, Skip 
8a80 25			    dec   h 
8a81			     
8a81			    ; Now add the low byte as usual 
8a81			    ; Two's complement takes care of 
8a81			    ; ensuring the result is correct 
8a81 85			    add   a, l 
8a82 6f			    ld    l, a 
8a83 8c			    adc   a, h 
8a84 95			    sub   l 
8a85 67			    ld    h, a 
8a86			Skip: 
8a86 c9				ret 
8a87			 
8a87			 
8a87			; compare hl and de 
8a87			; returns:  
8a87			; if hl = de, z=1, s=0, c0=0 
8a87			; if hl > de, z=0, s=0, c=0 
8a87			; if hl < de, z=0, s=1, c=1 
8a87			cmp16:	 
8a87 b7				or a 
8a88 ed 52			sbc hl,de 
8a8a e0				ret po 
8a8b 7c				ld a,h 
8a8c 1f				rra 
8a8d ee 40			xor 01000000B 
8a8f 37				scf 
8a90 8f				adc a,a 
8a91 c9				ret 
8a92			 
8a92			 
8a92			; test if hl contains zero   - A is destroyed 
8a92			 
8a92			ishlzero:    
8a92 b7				or a     ; reset flags 
8a93 7c				ld a, h 
8a94 b5				or l        	 
8a95			 
8a95 c9				ret 
8a96			 
8a96			 
8a96			 
8a96			 
8a96			if FORTH_ENABLE_FLOATMATH 
8a96			;include "float/bbcmath.z80" 
8a96			include "float/lpfpcalc.asm" 
8a96			endif 
8a96			 
8a96			 
8a96			; eof 
8a96			 
# End of file firmware_maths.asm
8a96			include "firmware_strings.asm"   ; string handling  
8a96			 
8a96			 
8a96			; TODO string len 
8a96			; input text string, end on cr with zero term 
8a96			; a offset into frame buffer to start prompt 
8a96			; d is max length 
8a96			; e is display size TODO 
8a96			; c is current cursor position 
8a96			; hl is ptr to where string will be stored 
8a96			 
8a96			 
8a96			; TODO check limit of buffer for new inserts 
8a96			; TODO check insert does not push beyond buffer 
8a96			; TODO scroll in a limited display area 
8a96			; TODO scroll whole screen on page wrap 
8a96			 
8a96			 
8a96			; TODO handle KEY_PREVWORD 
8a96			; TODO handle KEY_NEXTWORD 
8a96			; TODO handle KEY_HOME 
8a96			; TODO handle KEY_END 
8a96			; TODO use LCD cursor? 
8a96			 
8a96 32 b9 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8a99 81					add c 
8a9a 32 b7 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8a9d 22 bc ee				ld (input_start), hl     ; save ptr to buffer 
8aa0 79					ld a, c 
8aa1 cd 69 8a				call addatohl 
8aa4 22 be ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8aa7 7a					ld a,d 
8aa8 32 bb ee			        ld (input_size), a       ; save length of input area 
8aab 79					ld a, c 
8aac 32 aa ee				ld (input_cursor),a      ; init cursor start position  
8aaf 7b					ld a,e 
8ab0 32 ba ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ab3					 
8ab3					 
8ab3			 
8ab3			;		ld a,(input_ptr) 
8ab3			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ab3			 
8ab3			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ab3					; init cursor shape if not set by the cin routines 
8ab3 21 59 ed				ld hl, cursor_shape 
8ab6 3e ff				ld a, 255 
8ab8 77					ld (hl), a 
8ab9 23					inc hl 
8aba 3e 00				ld a, 0 
8abc 77					ld (hl), a 
8abd			 
8abd 3e 0f				ld a, CUR_BLINK_RATE 
8abf 32 b5 ee				ld (input_cur_flash), a 
8ac2 3e 01				ld a, 1 
8ac4 32 b4 ee				ld (input_cur_onoff),a 
8ac7			 
8ac7			;	if DEBUG_INPUT 
8ac7			;		push af 
8ac7			;		ld a, 'I' 
8ac7			;		ld (debug_mark),a 
8ac7			;		pop af 
8ac7			;		CALLMONITOR 
8ac7			;	endif 
8ac7			.is1:		; main entry loop 
8ac7			 
8ac7			 
8ac7			 
8ac7					; pause 1ms 
8ac7			 
8ac7 3e 01				ld a, 1 
8ac9 cd cf 87				call aDelayInMS 
8acc			 
8acc					; dec flash counter 
8acc 3a b5 ee				ld a, (input_cur_flash) 
8acf 3d					dec a 
8ad0 32 b5 ee				ld (input_cur_flash), a 
8ad3 fe 00				cp 0 
8ad5 20 0d				jr nz, .nochgstate 
8ad7			 
8ad7			 
8ad7					; change state 
8ad7 3a b4 ee				ld a,(input_cur_onoff) 
8ada ed 44				neg 
8adc 32 b4 ee				ld (input_cur_onoff),a 
8adf			 
8adf			 
8adf					; reset on change of state 
8adf 3e 0f				ld a, CUR_BLINK_RATE 
8ae1 32 b5 ee				ld (input_cur_flash), a 
8ae4			 
8ae4			.nochgstate: 
8ae4					 
8ae4					 
8ae4			 
8ae4					; display cursor  
8ae4			 
8ae4			;		ld hl, (input_start) 
8ae4			;		ld a, (input_cursor) 
8ae4			;		call addatohl 
8ae4			 
8ae4					; get char under cursor and replace with cursor 
8ae4 2a be ee		ld hl, (input_ptr) 
8ae7			;		ld a, (hl) 
8ae7			;		ld (input_under_cursor),a 
8ae7			;		ld a, '_' 
8ae7			;		ld (hl), a 
8ae7			 
8ae7					; display string 
8ae7			 
8ae7 ed 5b bc ee			ld de, (input_start) 
8aeb 3a b9 ee				ld a, (input_at_pos) 
8aee cd 4f 88				call str_at_display 
8af1			;	        call update_display 
8af1			 
8af1					; find place to put the cursor 
8af1			;		add h 
8af1			;		ld l, display_row_1 
8af1			;		sub l 
8af1			; (input_at_pos) 
8af1					;ld c, a 
8af1			;		ld a, (input_cursor) 
8af1			;		ld l, (input_at_pos) 
8af1			;		;ld b, h 
8af1			;		add l 
8af1			;		ld (input_at_cursor),a 
8af1					;ld l,h 
8af1			 
8af1			;		ld h, 0 
8af1			;		ld l,(input_at_pos) 
8af1			;		ld a, (input_cursor) 
8af1			;		call addatohl 
8af1			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8af1			;		call subafromhl 
8af1			;		ld a,l 
8af1			;		ld (input_at_cursor), a 
8af1			 
8af1				if DEBUG_INPUT 
8af1					ld a, (hardware_diag) 
8af1					cp 0 
8af1					jr z, .skip_input_diag 
8af1			 
8af1					ld a,(input_at_pos) 
8af1					ld hl, LFSRSeed 
8af1					call hexout 
8af1					ld a, (input_cursor) 
8af1					ld hl, LFSRSeed+2 
8af1					call hexout 
8af1					ld a,(input_at_cursor) 
8af1					ld hl, LFSRSeed+4 
8af1					call hexout 
8af1			 
8af1					ld a,(input_cur_onoff) 
8af1					ld hl, LFSRSeed+6 
8af1					call hexout 
8af1			 
8af1					ld a,(input_cur_flash) 
8af1					ld hl, LFSRSeed+8 
8af1					call hexout 
8af1			 
8af1					ld a,(input_len) 
8af1					ld hl, LFSRSeed+10 
8af1					call hexout 
8af1					ld hl, LFSRSeed+12 
8af1					ld a, 0 
8af1					ld (hl),a 
8af1					ld a, display_row_4 
8af1					ld de, LFSRSeed 
8af1					call str_at_display 
8af1					.skip_input_diag: 
8af1				endif 
8af1			 
8af1					; decide on if we are showing the cursor this time round 
8af1			 
8af1 3a b4 ee				ld a, (input_cur_onoff) 
8af4 fe ff				cp 255 
8af6 28 13				jr z, .skipcur 
8af8			 
8af8			 
8af8 3a b7 ee				ld a,(input_at_cursor) 
8afb 11 59 ed				ld de, cursor_shape 
8afe cd 4f 88				call str_at_display 
8b01			 
8b01					; save length of current input string 
8b01 2a bc ee				ld hl, (input_start) 
8b04 cd c7 8e				call strlenz 
8b07 7d					ld a,l 
8b08 32 af ee				ld (input_len),a 
8b0b			 
8b0b			.skipcur: 
8b0b			 
8b0b cd 5f 88			        call update_display 
8b0e					 
8b0e			 
8b0e			 
8b0e					; wait 
8b0e				 
8b0e					; TODO loop without wait to flash the cursor and char under cursor	 
8b0e cd 21 d8				call cin    ; _wait 
8b11			 
8b11 fe 00				cp 0 
8b13 ca c7 8a				jp z, .is1 
8b16			 
8b16					; get ptr to char to input into 
8b16			 
8b16 4f					ld c,a 
8b17 2a bc ee				ld hl, (input_start) 
8b1a 3a aa ee				ld a, (input_cursor) 
8b1d cd 69 8a				call addatohl 
8b20 22 be ee				ld (input_ptr), hl 
8b23 79					ld a,c 
8b24			 
8b24					; replace char under cursor 
8b24			 
8b24			;		ld hl, (input_ptr) 
8b24			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b24			;		ld (hl), a 
8b24			 
8b24			;	if DEBUG_INPUT 
8b24			;		push af 
8b24			;		ld a, 'i' 
8b24			;		ld (debug_mark),a 
8b24			;		pop af 
8b24			;		CALLMONITOR 
8b24			;	endif 
8b24 fe 0e				cp KEY_HOME 
8b26 20 0e				jr nz, .iske 
8b28			 
8b28 3a b9 ee				ld a, (input_at_pos) 
8b2b 32 b7 ee				ld (input_at_cursor),a 
8b2e 3e 00				ld a, 0 
8b30 32 aa ee				ld (input_cursor), a 
8b33 c3 c7 8a				jp .is1 
8b36					 
8b36 fe 0f		.iske:		cp KEY_END 
8b38 20 03				jr nz, .isknw 
8b3a c3 c7 8a				jp .is1 
8b3d			 
8b3d fe 06		.isknw:		cp KEY_NEXTWORD 
8b3f 20 1b				jr nz, .iskpw 
8b41			 
8b41 2a be ee		.isknwm:	ld hl, (input_ptr) 
8b44 7e					ld a,(hl)	 
8b45 fe 00				cp 0 
8b47 ca c7 8a				jp z, .is1    ; end of string 
8b4a fe 20				cp ' ' 
8b4c ca c7 8a				jp z, .is1    ; end of word 
8b4f 23					inc hl 
8b50 22 be ee				ld (input_ptr), hl 
8b53 3a b7 ee				ld a, (input_at_cursor) 
8b56 3c					inc a 
8b57 32 b7 ee				ld (input_at_cursor), a 
8b5a 18 e5				jr .isknwm 
8b5c			 
8b5c fe 07		.iskpw:		cp KEY_PREVWORD 
8b5e 20 1b				jr nz, .iskl 
8b60			.iskpwm:	 
8b60 2a be ee				ld hl, (input_ptr) 
8b63 7e					ld a,(hl)	 
8b64 fe 00				cp 0  
8b66 ca c7 8a				jp z, .is1    ; end of string 
8b69 fe 20				cp ' ' 
8b6b ca c7 8a				jp z, .is1    ; end of word 
8b6e 2b					dec hl 
8b6f 22 be ee				ld (input_ptr), hl 
8b72 3a b7 ee				ld a, (input_at_cursor) 
8b75 3d					dec a 
8b76 32 b7 ee				ld (input_at_cursor), a 
8b79 18 e5				jr .iskpwm 
8b7b			 
8b7b			 
8b7b fe 0b		.iskl:		cp KEY_LEFT 
8b7d 20 27				jr nz, .isk1 
8b7f			 
8b7f 3a aa ee				ld a, (input_cursor) 
8b82			 
8b82 fe 00				cp 0 
8b84 ca c7 8a				jp z, .is1 		; at start of line to ignore  
8b87			 
8b87 3d					dec  a 		; TODO check underflow 
8b88 32 aa ee				ld (input_cursor), a 
8b8b			 
8b8b 2a be ee				ld hl, (input_ptr) 
8b8e 2b					dec hl 
8b8f 22 be ee				ld (input_ptr), hl 
8b92					 
8b92 3a b7 ee				ld a, (input_at_cursor) 
8b95 3d					dec a 
8b96 32 b7 ee				ld (input_at_cursor), a 
8b99			 
8b99 3e 01				ld a, 1		; show cursor moving 
8b9b 32 b4 ee				ld (input_cur_onoff),a 
8b9e 3e 0f				ld a, CUR_BLINK_RATE 
8ba0 32 b5 ee				ld (input_cur_flash), a 
8ba3			 
8ba3 c3 c7 8a				jp .is1 
8ba6			 
8ba6 fe 0c		.isk1:		cp KEY_RIGHT 
8ba8 20 2a				jr nz, .isk2 
8baa			 
8baa 3a af ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8bad 5f					ld e,a 
8bae 3a aa ee				ld a, (input_cursor) 
8bb1 bb					cp e 
8bb2 ca c7 8a				jp z, .is1		; at the end of string so dont go right 
8bb5			 
8bb5 3c					inc  a 		; TODO check overflow 
8bb6 32 aa ee				ld (input_cursor), a 
8bb9			 
8bb9 3a b7 ee				ld a, (input_at_cursor) 
8bbc 3c					inc a 
8bbd 32 b7 ee				ld (input_at_cursor), a 
8bc0			 
8bc0 2a be ee				ld hl, (input_ptr) 
8bc3 23					inc hl 
8bc4 22 be ee				ld (input_ptr), hl 
8bc7			 
8bc7 3e 01				ld a, 1		; show cursor moving 
8bc9 32 b4 ee				ld (input_cur_onoff),a 
8bcc 3e 0f				ld a, CUR_BLINK_RATE 
8bce 32 b5 ee				ld (input_cur_flash), a 
8bd1			 
8bd1 c3 c7 8a				jp .is1 
8bd4			 
8bd4 fe 05		.isk2:		cp KEY_UP 
8bd6			 
8bd6 20 26				jr nz, .isk3 
8bd8			 
8bd8					; swap last command with the current on 
8bd8			 
8bd8					; move cursor to start of string 
8bd8 2a bc ee				ld hl, (input_start) 
8bdb 22 be ee				ld (input_ptr), hl 
8bde			 
8bde 3a b9 ee				ld a, (input_at_pos) 
8be1 32 b7 ee				ld (input_at_cursor), a 
8be4			 
8be4 3e 00				ld a, 0 
8be6 32 aa ee				ld (input_cursor), a 
8be9					 
8be9					; swap input and last command buffers 
8be9			 
8be9 21 0d e8				ld hl, os_cli_cmd 
8bec 11 0c e9				ld de, os_last_cmd 
8bef 06 ff				ld b, 255 
8bf1 7e			.swap1:		ld a, (hl) 
8bf2 4f					ld c,a 
8bf3 1a					ld a, (de) 
8bf4 77					ld (hl), a 
8bf5 79					ld a,c 
8bf6 12					ld (de),a 
8bf7 23					inc hl 
8bf8 13					inc de 
8bf9 10 f6				djnz .swap1 
8bfb			 
8bfb			 
8bfb			 
8bfb			 
8bfb			 
8bfb c3 c7 8a				jp .is1 
8bfe			 
8bfe fe 08		.isk3:		cp KEY_BS 
8c00 20 3c				jr nz, .isk4 
8c02			 
8c02 3a aa ee				ld a, (input_cursor) 
8c05			 
8c05 fe 00				cp 0 
8c07 ca c7 8a				jp z, .is1 		; at start of line to ignore  
8c0a			 
8c0a 3d					dec  a 		; TODO check underflow 
8c0b 32 aa ee				ld (input_cursor), a 
8c0e			 
8c0e					; hl is source 
8c0e					; de needs to be source - 1 
8c0e			 
8c0e			;		ld a, 0 
8c0e			;		dec hl 
8c0e			;		ld (hl), a 
8c0e			 
8c0e 2a be ee				ld hl, (input_ptr) 
8c11 2b					dec hl 
8c12 22 be ee				ld (input_ptr), hl 
8c15			 
8c15					; shift all data 
8c15			 
8c15 e5					push hl 
8c16 23					inc hl 
8c17 d1					pop de 
8c18 3a af ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c1b 4f					ld c,a 
8c1c 06 00				ld b,0 
8c1e ed b0				ldir  
8c20			 
8c20			 
8c20			 
8c20			 
8c20 3a b7 ee				ld a, (input_at_cursor) 
8c23 3d					dec a 
8c24 32 b7 ee				ld (input_at_cursor), a 
8c27			 
8c27			 
8c27 3e 01				ld a, 1		; show cursor moving 
8c29 32 b4 ee				ld (input_cur_onoff),a 
8c2c 3e 0f				ld a, CUR_BLINK_RATE 
8c2e 32 b5 ee				ld (input_cur_flash), a 
8c31			 
8c31					; remove char 
8c31 3a b7 ee				ld a, (input_at_cursor) 
8c34 3c					inc a 
8c35 11 bf 8c				ld de,.iblank 
8c38 cd 4f 88				call str_at_display 
8c3b			 
8c3b c3 c7 8a				jp .is1 
8c3e			 
8c3e fe 0d		.isk4:		cp KEY_CR 
8c40 28 6c				jr z, .endinput 
8c42			 
8c42					; else add the key press to the end 
8c42			 
8c42 4f					ld c, a			; save key pressed 
8c43			 
8c43 7e					ld a,(hl)		; get what is currently under char 
8c44			 
8c44 fe 00				cp 0			; we are at the end of the string 
8c46 20 2f				jr nz, .onchar 
8c48					 
8c48					; add a char to the end of the string 
8c48				 
8c48 71					ld (hl),c 
8c49 23					inc hl 
8c4a			;		ld a,' ' 
8c4a			;		ld (hl),a 
8c4a			;		inc hl 
8c4a 3e 00				ld a,0 
8c4c 77					ld (hl),a 
8c4d 2b					dec hl 
8c4e			 
8c4e 3a aa ee				ld a, (input_cursor) 
8c51 3c					inc a				; TODO check max string length and scroll  
8c52 32 aa ee				ld (input_cursor), a		; inc cursor pos 
8c55							 
8c55 3a b7 ee				ld a, (input_at_cursor) 
8c58 3c					inc a 
8c59 32 b7 ee				ld (input_at_cursor), a 
8c5c			 
8c5c 2a be ee				ld hl, (input_ptr) 
8c5f 23					inc hl 
8c60 22 be ee				ld (input_ptr), hl 
8c63			 
8c63 2a be ee				ld hl, (input_ptr) 
8c66 23					inc hl 
8c67 22 be ee				ld (input_ptr), hl 
8c6a			;	if DEBUG_INPUT 
8c6a			;		push af 
8c6a			;		ld a, '+' 
8c6a			;		ld (debug_mark),a 
8c6a			;		pop af 
8c6a			;		CALLMONITOR 
8c6a			;	endif 
8c6a 3e 01				ld a, 1		; show cursor moving 
8c6c 32 b4 ee				ld (input_cur_onoff),a 
8c6f 3e 0f				ld a, CUR_BLINK_RATE 
8c71 32 b5 ee				ld (input_cur_flash), a 
8c74 c3 c7 8a				jp .is1 
8c77					 
8c77			 
8c77			 
8c77					; if on a char then insert 
8c77			.onchar: 
8c77			 
8c77					; TODO over flow check: make sure insert does not blow out buffer 
8c77			 
8c77					; need to do some maths to use lddr 
8c77			 
8c77 e5					push hl   ; save char pos 
8c78 c5					push bc 
8c79			 
8c79 2a bc ee				ld hl, (input_start) 
8c7c 3a af ee				ld a, (input_len) 
8c7f cd 69 8a				call addatohl  		; end of string 
8c82 23					inc hl 
8c83 23					inc hl		; past zero term 
8c84 e5					push hl 
8c85 23					inc hl 
8c86 e5					push hl  
8c87			 
8c87								; start and end of lddr set, now how much to move? 
8c87			 
8c87							 
8c87 3a aa ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8c8a 47					ld b,a 
8c8b 3a af ee				ld a,(input_len) 
8c8e 5f					ld e,a 
8c8f 90					sub b 
8c90 3c					inc a		;?? 
8c91 3c					inc a		;?? 
8c92 3c					inc a		;?? 
8c93			 
8c93 06 00				ld b,0 
8c95 4f					ld c,a 
8c96			 
8c96				if DEBUG_INPUT 
8c96					push af 
8c96					ld a, 'i' 
8c96					ld (debug_mark),a 
8c96					pop af 
8c96			;		CALLMONITOR 
8c96				endif 
8c96 d1					pop de 
8c97 e1					pop hl 
8c98				if DEBUG_INPUT 
8c98					push af 
8c98					ld a, 'I' 
8c98					ld (debug_mark),a 
8c98					pop af 
8c98			;		CALLMONITOR 
8c98				endif 
8c98 ed b8				lddr 
8c9a				 
8c9a			 
8c9a			 
8c9a					; TODO have a key for insert/overwrite mode???? 
8c9a c1					pop bc 
8c9b e1					pop hl 
8c9c 71					ld (hl), c		; otherwise overwrite current char 
8c9d					 
8c9d			 
8c9d			 
8c9d			 
8c9d 3a aa ee				ld a, (input_cursor) 
8ca0 3c					inc  a 		; TODO check overflow 
8ca1 32 aa ee				ld (input_cursor), a 
8ca4			 
8ca4 3a b7 ee				ld a, (input_at_cursor) 
8ca7 3c					inc a 
8ca8 32 b7 ee				ld (input_at_cursor), a 
8cab			 
8cab c3 c7 8a				jp .is1 
8cae			 
8cae			.endinput:	; TODO look for end of string 
8cae			 
8cae					; add trailing space for end of token 
8cae			 
8cae 2a bc ee				ld hl, (input_start) 
8cb1 3a af ee				ld a,(input_len) 
8cb4 cd 69 8a				call addatohl 
8cb7 3e 20				ld a, ' ' 
8cb9 77					ld (hl),a 
8cba					; TODO eof of parse marker 
8cba			 
8cba 23					inc hl 
8cbb 3e 00				ld a, 0 
8cbd 77					ld (hl),a 
8cbe			 
8cbe			 
8cbe c9					ret 
8cbf			 
8cbf .. 00		.iblank: db " ",0 
8cc1			 
8cc1			 
8cc1 32 b9 ee		input_str_prev:	ld (input_at_pos), a 
8cc4 22 bc ee				ld (input_start), hl 
8cc7 3e 01				ld a,1			; add cursor 
8cc9 77					ld (hl),a 
8cca 23					inc hl 
8ccb 3e 00				ld a,0 
8ccd 77					ld (hl),a 
8cce 22 be ee				ld (input_ptr), hl 
8cd1 7a					ld a,d 
8cd2 32 bb ee				ld (input_size), a 
8cd5 3e 00				ld a,0 
8cd7 32 aa ee				ld (input_cursor),a 
8cda			.instr1:	 
8cda			 
8cda					; TODO do block cursor 
8cda					; TODO switch cursor depending on the modifer key 
8cda			 
8cda					; update cursor shape change on key hold 
8cda			 
8cda 2a be ee				ld hl, (input_ptr) 
8cdd 2b					dec hl 
8cde 3a 59 ed				ld a,(cursor_shape) 
8ce1 77					ld (hl), a 
8ce2			 
8ce2					; display entered text 
8ce2 3a b9 ee				ld a,(input_at_pos) 
8ce5 cd 7f d7		            	CALL fLCD_Pos       ;Position cursor to location in A 
8ce8 ed 5b bc ee	            	LD   de, (input_start) 
8cec cd 79 d7		            	CALL fLCD_Str       ;Display string pointed to by DE 
8cef			 
8cef cd 21 d8				call cin 
8cf2 fe 00				cp 0 
8cf4 28 e4				jr z, .instr1 
8cf6			 
8cf6					; proecess keyboard controls first 
8cf6			 
8cf6 2a be ee				ld hl,(input_ptr) 
8cf9			 
8cf9 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8cfb 28 5a				jr z, .instrcr 
8cfd			 
8cfd fe 08				cp KEY_BS 	; back space 
8cff 20 0f				jr nz, .instr2 
8d01					; process back space 
8d01			 
8d01					; TODO stop back space if at start of string 
8d01 2b					dec hl 
8d02 2b					dec hl ; to over write cursor 
8d03 3a 59 ed				ld a,(cursor_shape) 
8d06					;ld a,0 
8d06 77					ld (hl),a 
8d07 23					inc hl 
8d08 3e 20				ld a," " 
8d0a 77					ld (hl),a 
8d0b 22 be ee				ld (input_ptr),hl 
8d0e					 
8d0e			 
8d0e 18 ca				jr .instr1 
8d10			 
8d10 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d12 20 06				jr nz, .instr3 
8d14 2b					dec hl 
8d15 22 be ee				ld (input_ptr),hl 
8d18 18 c0				jr .instr1 
8d1a				 
8d1a fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d1c 20 06				jr nz, .instr4 
8d1e 23					inc hl 
8d1f 22 be ee				ld (input_ptr),hl 
8d22 18 b6				jr .instr1 
8d24			 
8d24 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d26 20 06				jr nz, .instr5 
8d28 2b					dec hl 
8d29 22 be ee				ld (input_ptr),hl 
8d2c 18 ac				jr .instr1 
8d2e			 
8d2e fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d30 20 06				jr nz, .instr6 
8d32 2b					dec hl 
8d33 22 be ee				ld (input_ptr),hl 
8d36 18 a2				jr .instr1 
8d38 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d3a 20 0b				jr nz, .instrnew 
8d3c			 
8d3c 21 e6 e4			ld hl, scratch 
8d3f 11 0c e9			ld de, os_last_cmd 
8d42 cd 60 8d			call strcpy 
8d45 18 93				jr .instr1 
8d47			 
8d47			 
8d47			.instrnew:	; no special key pressed to see if we have room to store it 
8d47			 
8d47					; TODO do string size test 
8d47			 
8d47 2b					dec hl ; to over write cursor 
8d48 77					ld (hl),a 
8d49 23					inc hl 
8d4a 3a 59 ed				ld a,(cursor_shape) 
8d4d 77					ld (hl),a 
8d4e 23					inc hl 
8d4f 3e 00				ld a,0 
8d51 77					ld (hl),a 
8d52			 
8d52 22 be ee				ld (input_ptr),hl 
8d55					 
8d55 18 83				jr .instr1 
8d57 2b			.instrcr:	dec hl		; remove cursor 
8d58 3e 20				ld a,' '	; TODO add a trailing space for safety 
8d5a 77					ld (hl),a 
8d5b 23					inc hl 
8d5c 3e 00				ld a,0 
8d5e 77					ld (hl),a 
8d5f			 
8d5f			 
8d5f					; if at end of line scroll up    
8d5f					; TODO detecting only end of line 4 for scroll up  
8d5f			 
8d5f					;ld   
8d5f			 
8d5f c9					ret 
8d60			 
8d60			 
8d60			; strcpy hl = dest, de source 
8d60			 
8d60 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8d61 b7			            OR   A              ;Null terminator? 
8d62 c8			            RET  Z              ;Yes, so finished 
8d63 1a					ld a,(de) 
8d64 77					ld (hl),a 
8d65 13			            INC  DE             ;Point to next character 
8d66 23					inc hl 
8d67 18 f7		            JR   strcpy       ;Repeat 
8d69 c9					ret 
8d6a			 
8d6a			 
8d6a			; TODO string_at  
8d6a			; pass string which starts with lcd offset address and then null term string 
8d6a			 
8d6a			; TODO string to dec 
8d6a			; TODO string to hex 
8d6a			; TODO byte to string hex 
8d6a			; TODO byte to string dec 
8d6a			 
8d6a			 
8d6a			 
8d6a			; from z80uartmonitor 
8d6a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8d6a			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8d6a			; pass hl for where to put the text 
8d6a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8d6a c5			hexout:	PUSH BC 
8d6b f5					PUSH AF 
8d6c 47					LD B, A 
8d6d					; Upper nybble 
8d6d cb 3f				SRL A 
8d6f cb 3f				SRL A 
8d71 cb 3f				SRL A 
8d73 cb 3f				SRL A 
8d75 cd 85 8d				CALL tohex 
8d78 77					ld (hl),a 
8d79 23					inc hl	 
8d7a					 
8d7a					; Lower nybble 
8d7a 78					LD A, B 
8d7b e6 0f				AND 0FH 
8d7d cd 85 8d				CALL tohex 
8d80 77					ld (hl),a 
8d81 23					inc hl	 
8d82					 
8d82 f1					POP AF 
8d83 c1					POP BC 
8d84 c9					RET 
8d85					 
8d85			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8d85			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8d85			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8d85			tohex: 
8d85 e5					PUSH HL 
8d86 d5					PUSH DE 
8d87 16 00				LD D, 0 
8d89 5f					LD E, A 
8d8a 21 92 8d				LD HL, .DATA 
8d8d 19					ADD HL, DE 
8d8e 7e					LD A, (HL) 
8d8f d1					POP DE 
8d90 e1					POP HL 
8d91 c9					RET 
8d92			 
8d92			.DATA: 
8d92 30					DEFB	30h	; 0 
8d93 31					DEFB	31h	; 1 
8d94 32					DEFB	32h	; 2 
8d95 33					DEFB	33h	; 3 
8d96 34					DEFB	34h	; 4 
8d97 35					DEFB	35h	; 5 
8d98 36					DEFB	36h	; 6 
8d99 37					DEFB	37h	; 7 
8d9a 38					DEFB	38h	; 8 
8d9b 39					DEFB	39h	; 9 
8d9c 41					DEFB	41h	; A 
8d9d 42					DEFB	42h	; B 
8d9e 43					DEFB	43h	; C 
8d9f 44					DEFB	44h	; D 
8da0 45					DEFB	45h	; E 
8da1 46					DEFB	46h	; F 
8da2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8da2			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8da2			;;    subtract $30, if result > 9 then subtract $7 more 
8da2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8da2			atohex: 
8da2 d6 30				SUB $30 
8da4 fe 0a				CP 10 
8da6 f8					RET M		; If result negative it was 0-9 so we're done 
8da7 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8da9 c9					RET		 
8daa			 
8daa			 
8daa			 
8daa			 
8daa			; Get 2 ASCII characters as hex byte from pointer in hl 
8daa			 
8daa			BYTERD: 
8daa 16 00			LD	D,00h		;Set up 
8dac cd b4 8d			CALL	HEXCON		;Get byte and convert to hex 
8daf 87				ADD	A,A		;First nibble so 
8db0 87				ADD	A,A		;multiply by 16 
8db1 87				ADD	A,A		; 
8db2 87				ADD	A,A		; 
8db3 57				LD	D,A		;Save hi nibble in D 
8db4			HEXCON: 
8db4 7e				ld a, (hl)		;Get next chr 
8db5 23				inc hl 
8db6 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8db8 fe 0a			CP	00Ah		;Is it 0-9 ? 
8dba 38 02			JR	C,NALPHA	;If so miss next bit 
8dbc d6 07			SUB	007h		;Else convert alpha 
8dbe			NALPHA: 
8dbe b2				OR	D		;Add hi nibble back 
8dbf c9				RET			; 
8dc0			 
8dc0			 
8dc0			; 
8dc0			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8dc0			; Since the routines get_byte and therefore get_nibble are called, only valid 
8dc0			; characters (0-9a-f) are accepted. 
8dc0			; 
8dc0			;get_word        push    af 
8dc0			;                call    get_byte        ; Get the upper byte 
8dc0			;                ld      h, a 
8dc0			;                call    get_byte        ; Get the lower byte 
8dc0			;                ld      l, a 
8dc0			;                pop     af 
8dc0			;                ret 
8dc0			; 
8dc0			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8dc0			; the routine get_nibble is used only valid characters are accepted - the  
8dc0			; input routine only accepts characters 0-9a-f. 
8dc0			; 
8dc0 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8dc1 7e					ld a,(hl) 
8dc2 23					inc hl 
8dc3 cd e8 8d		                call    nibble2val      ; Get upper nibble 
8dc6 cb 07		                rlc     a 
8dc8 cb 07		                rlc     a 
8dca cb 07		                rlc     a 
8dcc cb 07		                rlc     a 
8dce 47			                ld      b, a            ; Save upper four bits 
8dcf 7e					ld a,(hl) 
8dd0 cd e8 8d		                call    nibble2val      ; Get lower nibble 
8dd3 b0			                or      b               ; Combine both nibbles 
8dd4 c1			                pop     bc              ; Restore B (and C) 
8dd5 c9			                ret 
8dd6			; 
8dd6			; Get a hexadecimal digit from the serial line. This routine blocks until 
8dd6			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8dd6			; to the serial line interface. The lower 4 bits of A contain the value of  
8dd6			; that particular digit. 
8dd6			; 
8dd6			;get_nibble      ld a,(hl)           ; Read a character 
8dd6			;                call    to_upper        ; Convert to upper case 
8dd6			;                call    is_hex          ; Was it a hex digit? 
8dd6			;                jr      nc, get_nibble  ; No, get another character 
8dd6			 ;               call    nibble2val      ; Convert nibble to value 
8dd6			 ;               call    print_nibble 
8dd6			 ;               ret 
8dd6			; 
8dd6			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8dd6			; A valid hexadecimal digit is denoted by a set C flag. 
8dd6			; 
8dd6			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8dd6			;                ret     nc              ; Yes 
8dd6			;                cp      '0'             ; Less than '0'? 
8dd6			;                jr      nc, is_hex_1    ; No, continue 
8dd6			;                ccf                     ; Complement carry (i.e. clear it) 
8dd6			;                ret 
8dd6			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8dd6			;                ret     c               ; Yes 
8dd6			;                cp      'A'             ; Less than 'A'? 
8dd6			;                jr      nc, is_hex_2    ; No, continue 
8dd6			;                ccf                     ; Yes - clear carry and return 
8dd6			;                ret 
8dd6			;is_hex_2        scf                     ; Set carry 
8dd6			;                ret 
8dd6			; 
8dd6			; Convert a single character contained in A to upper case: 
8dd6			; 
8dd6 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8dd8 d8			                ret     c 
8dd9 fe 7b		                cp      'z' + 1         ; > 'z'? 
8ddb d0			                ret     nc              ; Nothing to do, either 
8ddc e6 5f		                and     $5f             ; Convert to upper case 
8dde c9			                ret 
8ddf			 
8ddf			 
8ddf			to_lower: 
8ddf			 
8ddf			   ; if char is in [A-Z] make it lower case 
8ddf			 
8ddf			   ; enter : a = char 
8ddf			   ; exit  : a = lower case char 
8ddf			   ; uses  : af 
8ddf			 
8ddf fe 41		   cp 'A' 
8de1 d8			   ret c 
8de2			    
8de2 fe 5b		   cp 'Z'+1 
8de4 d0			   ret nc 
8de5			    
8de5 f6 20		   or $20 
8de7 c9			   ret 
8de8			 
8de8			; 
8de8			; Expects a hexadecimal digit (upper case!) in A and returns the 
8de8			; corresponding value in A. 
8de8			; 
8de8 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8dea 38 02		                jr      c, nibble2val_1 ; Yes 
8dec d6 07		                sub     7               ; Adjust for A-F 
8dee d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8df0 e6 0f		                and     $f              ; Only return lower 4 bits 
8df2 c9			                ret 
8df3			; 
8df3			; Print_nibble prints a single hex nibble which is contained in the lower  
8df3			; four bits of A: 
8df3			; 
8df3			;print_nibble    push    af              ; We won't destroy the contents of A 
8df3			;                and     $f              ; Just in case... 
8df3			;                add     a, '0'             ; If we have a digit we are done here. 
8df3			;                cp      '9' + 1         ; Is the result > 9? 
8df3			;                jr      c, print_nibble_1 
8df3			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8df3			;print_nibble_1  call    putc            ; Print the nibble and 
8df3			;                pop     af              ; restore the original value of A 
8df3			;                ret 
8df3			;; 
8df3			;; Send a CR/LF pair: 
8df3			; 
8df3			;crlf            push    af 
8df3			;                ld      a, cr 
8df3			;                call    putc 
8df3			;                ld      a, lf 
8df3			;                call    putc 
8df3			;                pop     af 
8df3			;                ret 
8df3			; 
8df3			; Print_word prints the four hex digits of a word to the serial line. The  
8df3			; word is expected to be in HL. 
8df3			; 
8df3			;print_word      push    hl 
8df3			;                push    af 
8df3			;                ld      a, h 
8df3			;                call    print_byte 
8df3			;                ld      a, l 
8df3			;                call    print_byte 
8df3			;                pop     af 
8df3			;                pop     hl 
8df3			;                ret 
8df3			; 
8df3			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8df3			; The byte to be printed is expected to be in A. 
8df3			; 
8df3			;print_byte      push    af              ; Save the contents of the registers 
8df3			;                push    bc 
8df3			;                ld      b, a 
8df3			;                rrca 
8df3			;                rrca 
8df3			;                rrca 
8df3			;                rrca 
8df3			;                call    print_nibble    ; Print high nibble 
8df3			;                ld      a, b 
8df3			;                call    print_nibble    ; Print low nibble 
8df3			;                pop     bc              ; Restore original register contents 
8df3			;                pop     af 
8df3			;                ret 
8df3			 
8df3			 
8df3			 
8df3			 
8df3			 
8df3			fourehexhl:  
8df3 7e				ld a,(hl) 
8df4 cd a2 8d			call atohex 
8df7 cb 3f				SRL A 
8df9 cb 3f				SRL A 
8dfb cb 3f				SRL A 
8dfd cb 3f				SRL A 
8dff 47				ld b, a 
8e00 23				inc hl 
8e01 7e				ld a,(hl) 
8e02 23				inc hl 
8e03 cd a2 8d			call atohex 
8e06 80				add b 
8e07 57				ld d,a 
8e08 7e				ld a,(hl) 
8e09 cd a2 8d			call atohex 
8e0c cb 3f				SRL A 
8e0e cb 3f				SRL A 
8e10 cb 3f				SRL A 
8e12 cb 3f				SRL A 
8e14 47				ld b, a 
8e15 23				inc hl 
8e16 7e				ld a,(hl) 
8e17 23				inc hl 
8e18 cd a2 8d			call atohex 
8e1b 80				add b 
8e1c 5f				ld e, a 
8e1d d5				push de 
8e1e e1				pop hl 
8e1f c9				ret 
8e20			 
8e20			; pass hl. returns z set if the byte at hl is a digit 
8e20			;isdigithl:  
8e20			;	push bc 
8e20			;	ld a,(hl) 
8e20			;	cp ':' 
8e20			;	jr nc, .isdf 		; > 
8e20			;	cp '0' 
8e20			;	jr c, .isdf		; < 
8e20			; 
8e20			;	; TODO find a better way to set z 
8e20			; 
8e20			;	ld b,a 
8e20			;	cp b 
8e20			;	pop bc 
8e20			;	ret 
8e20			; 
8e20			;.isdf:	; not digit so clear z 
8e20			; 
8e20			;	; TODO find a better way to unset z 
8e20			; 
8e20			;	ld b,a 
8e20			;	inc b 
8e20			;	cp b 
8e20			; 
8e20			;	pop bc 
8e20			;	ret 
8e20				 
8e20				 
8e20			 
8e20			 
8e20			; pass hl as the four byte address to load 
8e20			 
8e20			get_word_hl:  
8e20 e5				push hl 
8e21 cd c0 8d			call get_byte 
8e24				 
8e24 47				ld b, a 
8e25			 
8e25 e1				pop hl 
8e26 23				inc hl 
8e27 23				inc hl 
8e28			 
8e28			; TODO not able to handle a-f  
8e28 7e				ld a,(hl) 
8e29			;	;cp ':' 
8e29			;	cp 'g' 
8e29			;	jr nc, .single_byte_hl 		; > 
8e29			;	cp 'G' 
8e29			;	jr nc, .single_byte_hl 		; > 
8e29			;	cp '0' 
8e29			;	jr c, .single_byte_hl		; < 
8e29			 
8e29				;call isdigithl 
8e29 fe 00			cp 0 
8e2b 28 06			jr z, .single_byte_hl 
8e2d			 
8e2d			.getwhln:   ; hex word so get next byte 
8e2d			 
8e2d cd c0 8d			call get_byte 
8e30 6f				ld l, a 
8e31 60				ld h,b 
8e32 c9				ret 
8e33 68			.single_byte_hl:   ld l,b 
8e34 26 00				ld h,0 
8e36 c9					ret 
8e37			 
8e37			 
8e37			 
8e37			 
8e37 21 54 95			ld hl,asc+1 
8e3a			;	ld a, (hl) 
8e3a			;	call nibble2val 
8e3a cd c0 8d			call get_byte 
8e3d			 
8e3d			;	call fourehexhl 
8e3d 32 1a e5			ld (scratch+52),a 
8e40				 
8e40 21 18 e5			ld hl,scratch+50 
8e43 22 09 e8			ld (os_cur_ptr),hl 
8e46			 
8e46 c9				ret 
8e47			 
8e47			 
8e47			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e47			 
8e47			; Decimal Unsigned Version 
8e47			 
8e47			;Number in a to decimal ASCII 
8e47			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e47			;Example: display a=56 as "056" 
8e47			;input: a = number 
8e47			;Output: a=0,value of a in the screen 
8e47			;destroys af,bc (don't know about hl and de) 
8e47			DispAToASCII: 
8e47 0e 9c			ld	c,-100 
8e49 cd 53 8e			call	.Na1 
8e4c 0e f6			ld	c,-10 
8e4e cd 53 8e			call	.Na1 
8e51 0e ff			ld	c,-1 
8e53 06 2f		.Na1:	ld	b,'0'-1 
8e55 04			.Na2:	inc	b 
8e56 81				add	a,c 
8e57 38 fc			jr	c,.Na2 
8e59 91				sub	c		;works as add 100/10/1 
8e5a f5				push af		;safer than ld c,a 
8e5b 78				ld	a,b		;char is in b 
8e5c			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8e5c f1				pop af		;safer than ld a,c 
8e5d c9				ret 
8e5e			 
8e5e			; Decimal Signed Version 
8e5e			 
8e5e			; DispA 
8e5e			; -------------------------------------------------------------- 
8e5e			; Converts a signed integer value to a zero-terminated ASCII 
8e5e			; string representative of that value (using radix 10). 
8e5e			; -------------------------------------------------------------- 
8e5e			; INPUTS: 
8e5e			;     HL     Value to convert (two's complement integer). 
8e5e			;     DE     Base address of string destination. (pointer). 
8e5e			; -------------------------------------------------------------- 
8e5e			; OUTPUTS: 
8e5e			;     None 
8e5e			; -------------------------------------------------------------- 
8e5e			; REGISTERS/MEMORY DESTROYED 
8e5e			; AF HL 
8e5e			; -------------------------------------------------------------- 
8e5e			 
8e5e			;DispHLToASCII: 
8e5e			;   push    de 
8e5e			;   push    bc 
8e5e			; 
8e5e			;; Detect sign of HL. 
8e5e			;    bit    7, h 
8e5e			;    jr     z, ._DoConvert 
8e5e			; 
8e5e			;; HL is negative. Output '-' to string and negate HL. 
8e5e			;    ld     a, '-' 
8e5e			;    ld     (de), a 
8e5e			;    inc    de 
8e5e			; 
8e5e			;; Negate HL (using two's complement) 
8e5e			;    xor    a 
8e5e			;    sub    l 
8e5e			;    ld     l, a 
8e5e			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8e5e			;    sbc    a, h 
8e5e			;    ld     h, a 
8e5e			; 
8e5e			;; Convert HL to digit characters 
8e5e			;._DoConvert: 
8e5e			;    ld     b, 0     ; B will count character length of number 
8e5e			;-   ld     a, 10 
8e5e			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8e5e			;    push   af 
8e5e			;    inc    b 
8e5e			;    ld     a, h 
8e5e			;    or     l 
8e5e			;    jr     nz, - 
8e5e			; 
8e5e			;; Retrieve digits from stack 
8e5e			;-   pop    af 
8e5e			;    or     $30 
8e5e			;    ld     (de), a 
8e5e			;    inc    de 
8e5e			;    djnz   - 
8e5e			; 
8e5e			;; Terminate string with NULL 
8e5e			;    xor    a 
8e5e			;    ld     (de), a 
8e5e			; 
8e5e			;    pop    bc 
8e5e			;    pop    de 
8e5e			;    ret 
8e5e			 
8e5e			;Comments 
8e5e			; 
8e5e			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8e5e			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8e5e			;    Note that the output string will not be fixed-width. 
8e5e			; 
8e5e			;Example Usage 
8e5e			; 
8e5e			;    ld    hl, -1004 
8e5e			;    ld    de, OP1 
8e5e			;    call  DispA 
8e5e			;    ld    hl, OP1 
8e5e			;    syscall  PutS 
8e5e			 
8e5e			 
8e5e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8e5e			 
8e5e			 
8e5e			;Converts an ASCII string to an unsigned 16-bit integer 
8e5e			;Quits when it reaches a non-decimal digit 
8e5e			 
8e5e			string_to_uint16: 
8e5e			atoui_16: 
8e5e			;Input: 
8e5e			;     DE points to the string 
8e5e			;Outputs: 
8e5e			;     HL is the result 
8e5e			;     A is the 8-bit value of the number 
8e5e			;     DE points to the byte after the number 
8e5e			;Destroys: 
8e5e			;     BC 
8e5e			;       if the string is non-empty, BC is HL/10 
8e5e			;Size:  24 bytes 
8e5e			;Speed: 42+d(104+{0,9}) 
8e5e			;       d is the number of digits in the number 
8e5e			;       max is 640 cycles for a 5 digit number 
8e5e			;Assuming no leading zeros: 
8e5e			;1 digit:  146cc 
8e5e			;2 digit:  250cc 
8e5e			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8e5e			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8e5e			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8e5e			;avg: 544.81158447265625cc (544+13297/16384) 
8e5e			;=============================================================== 
8e5e 21 00 00		  ld hl,0 
8e61			.u16a: 
8e61 1a			  ld a,(de) 
8e62 d6 30		  sub 30h 
8e64 fe 0a		  cp 10 
8e66 d0			  ret nc 
8e67 13			  inc de 
8e68 44			  ld b,h 
8e69 4d			  ld c,l 
8e6a 29			  add hl,hl 
8e6b 29			  add hl,hl 
8e6c 09			  add hl,bc 
8e6d 29			  add hl,hl 
8e6e 85			  add a,l 
8e6f 6f			  ld l,a 
8e70 30 ef		  jr nc,.u16a 
8e72 24			  inc h 
8e73 c3 61 8e		  jp .u16a 
8e76			 
8e76			 
8e76			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8e76			 
8e76			;written by Zeda 
8e76			;Converts a 16-bit unsigned integer to an ASCII string. 
8e76			 
8e76			uitoa_16: 
8e76			;Input: 
8e76			;   DE is the number to convert 
8e76			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8e76			;Output: 
8e76			;   HL points to the null-terminated ASCII string 
8e76			;      NOTE: This isn't necessarily the same as the input HL. 
8e76 d5			  push de 
8e77 c5			  push bc 
8e78 f5			  push af 
8e79 eb			  ex de,hl 
8e7a			 
8e7a 01 f0 d8		  ld bc,-10000 
8e7d 3e 2f		  ld a,'0'-1 
8e7f 3c			  inc a 
8e80 09			  add hl,bc  
8e81 38 fc		   jr c,$-2 
8e83 12			  ld (de),a 
8e84 13			  inc de 
8e85			 
8e85 01 e8 03		  ld bc,1000 
8e88 3e 3a		  ld a,'9'+1 
8e8a 3d			  dec a  
8e8b 09			  add hl,bc  
8e8c 30 fc		   jr nc,$-2 
8e8e 12			  ld (de),a 
8e8f 13			  inc de 
8e90			 
8e90 01 9c ff		  ld bc,-100 
8e93 3e 2f		  ld a,'0'-1 
8e95 3c			  inc a  
8e96 09			  add hl,bc  
8e97 38 fc		   jr c,$-2 
8e99 12			  ld (de),a 
8e9a 13			  inc de 
8e9b			 
8e9b 7d			  ld a,l 
8e9c 26 3a		  ld h,'9'+1 
8e9e 25			  dec h  
8e9f c6 0a		  add a,10  
8ea1 30 fb		   jr nc,$-3 
8ea3 c6 30		  add a,'0' 
8ea5 eb			  ex de,hl 
8ea6 72			  ld (hl),d 
8ea7 23			  inc hl 
8ea8 77			  ld (hl),a 
8ea9 23			  inc hl 
8eaa 36 00		  ld (hl),0 
8eac			 
8eac			;Now strip the leading zeros 
8eac 0e fa		  ld c,-6 
8eae 09			  add hl,bc 
8eaf 3e 30		  ld a,'0' 
8eb1 23			  inc hl  
8eb2 be			  cp (hl)  
8eb3 28 fc		  jr z,$-2 
8eb5			 
8eb5			;Make sure that the string is non-empty! 
8eb5 7e			  ld a,(hl) 
8eb6 b7			  or a 
8eb7 20 01		  jr nz,.atoub 
8eb9 2b			  dec hl 
8eba			.atoub: 
8eba			 
8eba f1			  pop af 
8ebb c1			  pop bc 
8ebc d1			  pop de 
8ebd c9			  ret 
8ebe			 
8ebe			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8ebe			 
8ebe			toUpper: 
8ebe			;A is the char. 
8ebe			;If A is a lowercase letter, this sets it to the matching uppercase 
8ebe			;18cc or 30cc or 41cc 
8ebe			;avg: 26.75cc 
8ebe fe 61		  cp 'a' 
8ec0 d8			  ret c 
8ec1 fe 7b		  cp 'z'+1 
8ec3 d0			  ret nc 
8ec4 d6 20		  sub 'a'-'A' 
8ec6 c9			  ret 
8ec7			 
8ec7			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8ec7			 
8ec7			; String Length 
8ec7			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8ec7			 
8ec7			; Get the length of the null-terminated string starting at $8000 hl 
8ec7			;    LD     HL, $8000 
8ec7			 
8ec7			strlenz: 
8ec7			 
8ec7 af			    XOR    A               ; Zero is the value we are looking for. 
8ec8 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8ec9 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8eca			                           ; 65, 536 bytes (the entire addressable memory space). 
8eca ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8ecc			 
8ecc			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8ecc 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8ecd 6f			    LD     L, A             ; number of bytes 
8ece ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8ed0 2b			    DEC    HL              ; Compensate for null. 
8ed1 c9				ret 
8ed2			 
8ed2			; Get the length of the A terminated string starting at $8000 hl 
8ed2			;    LD     HL, $8000 
8ed2			 
8ed2			strlent: 
8ed2			 
8ed2			                  ; A is the value we are looking for. 
8ed2 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8ed4 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8ed6			                           ; 65, 536 bytes (the entire addressable memory space). 
8ed6 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8ed8			 
8ed8			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8ed8 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8eda 2e 00		    LD     L, 0             ; number of bytes 
8edc ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8ede 2b			    DEC    HL              ; Compensate for null. 
8edf c9				ret 
8ee0			 
8ee0			 
8ee0			;Comparing Strings 
8ee0			 
8ee0			;IN    HL     Address of string1. 
8ee0			;      DE     Address of string2. 
8ee0			 
8ee0			; doc given but wrong??? 
8ee0			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8ee0			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8ee0			; tested 
8ee0			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8ee0			 
8ee0			strcmp_old: 
8ee0 e5			    PUSH   HL 
8ee1 d5			    PUSH   DE 
8ee2			 
8ee2 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8ee3 be			    CP     (HL)            ; (want to minimize work). 
8ee4 38 01		    JR     C, Str1IsBigger 
8ee6 7e			    LD     A, (HL) 
8ee7			 
8ee7			Str1IsBigger: 
8ee7 4f			    LD     C, A             ; Put length in BC 
8ee8 06 00		    LD     B, 0 
8eea 13			    INC    DE              ; Increment pointers to meat of string. 
8eeb 23			    INC    HL 
8eec			 
8eec			CmpLoop: 
8eec 1a			    LD     A, (DE)          ; Compare bytes. 
8eed ed a1		    CPI 
8eef 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8ef1 13			    INC    DE              ; Update pointer. 
8ef2 ea ec 8e		    JP     PE, CmpLoop 
8ef5			 
8ef5 d1			    POP    DE 
8ef6 e1			    POP    HL 
8ef7 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8ef8 be			    CP     (HL) 
8ef9 c9			    RET 
8efa			 
8efa			NoMatch: 
8efa 2b			    DEC    HL 
8efb be			    CP     (HL)            ; Compare again to affect carry. 
8efc d1			    POP    DE 
8efd e1			    POP    HL 
8efe c9			    RET 
8eff			 
8eff			;; test strmp 
8eff			; 
8eff			;ld de, .str1 
8eff			;ld hl, .str2 
8eff			;call strcmp 
8eff			;jr z, .z1 
8eff			;;this 
8eff			;	if DEBUG_FORTH_WORDS 
8eff			;		DMARK "NZ1" 
8eff			;		CALLMONITOR 
8eff			;	endif 
8eff			;.z1: 
8eff			; 
8eff			;	if DEBUG_FORTH_WORDS 
8eff			;		DMARK "ZZ1" 
8eff			;		CALLMONITOR 
8eff			;	endif 
8eff			; 
8eff			;ld de, .str1 
8eff			;ld hl, .str1 
8eff			;call strcmp 
8eff			;jr z, .z2 
8eff			;;this 
8eff			;	if DEBUG_FORTH_WORDS 
8eff			;		DMARK "NZ2" 
8eff			;		CALLMONITOR 
8eff			;	endif 
8eff			;.z2: 
8eff			; 
8eff			;	if DEBUG_FORTH_WORDS 
8eff			;		DMARK "ZZ2" 
8eff			;		CALLMONITOR 
8eff			;	endif 
8eff			; 
8eff			;ld de, .str1 
8eff			;ld hl, .str2 
8eff			;call strcmp 
8eff			;jr c, .c1 
8eff			; 
8eff			;	if DEBUG_FORTH_WORDS 
8eff			;		DMARK "Nc1" 
8eff			;		CALLMONITOR 
8eff			;	endif 
8eff			;.c1: 
8eff			;;this 
8eff			;	if DEBUG_FORTH_WORDS 
8eff			;		DMARK "cc1" 
8eff			;		CALLMONITOR 
8eff			;	endif 
8eff			; 
8eff			;ld de, .str1 
8eff			;ld hl, .str1 
8eff			;call strcmp 
8eff			;jr c, .c2 
8eff			;;this 
8eff			;	if DEBUG_FORTH_WORDS 
8eff			;		DMARK "Nc2" 
8eff			;		CALLMONITOR 
8eff			;	endif 
8eff			;.c2: 
8eff			; 
8eff			;	if DEBUG_FORTH_WORDS 
8eff			;		DMARK "cc2" 
8eff			;		CALLMONITOR 
8eff			;	endif 
8eff			;	NEXTW 
8eff			;.str1:   db "string1",0 
8eff			;.str2:   db "string2",0 
8eff			 
8eff			; only care about direct match or not 
8eff			; hl and de strings 
8eff			; zero set if the same 
8eff			 
8eff			strcmp: 
8eff 1a				ld a, (de) 
8f00 be				cp (hl) 
8f01 28 02			jr z, .ssame 
8f03 b7				or a 
8f04 c9				ret 
8f05			 
8f05			.ssame:  
8f05 fe 00			cp 0 
8f07 c8				ret z 
8f08			 
8f08 23				inc hl 
8f09 13				inc de 
8f0a 18 f3			jr strcmp 
8f0c				 
8f0c				 
8f0c			 
8f0c			 
8f0c			 
8f0c			 
8f0c			; eof 
8f0c			 
8f0c			 
8f0c			 
8f0c			 
8f0c			 
8f0c			 
# End of file firmware_strings.asm
8f0c			include "firmware_memory.asm"   ; malloc and free  
8f0c			 
8f0c			if DEBUG_FORTH_MALLOC_HIGH 
8f0c			.mallocsize: db "Wants malloc >256",0 
8f0c			.mallocasize: db "MALLOC gives >256",0 
8f0c			.malloczero: db "MALLOC gives zero",0 
8f0c			 
8f0c			malloc_guard_zerolen: 
8f0c				push hl 
8f0c				push de 
8f0c				push af 
8f0c			 
8f0c				ld de, 0 
8f0c			        call cmp16 
8f0c				jr nz, .lowalloz 
8f0c			 
8f0c				push hl 
8f0c				push de 
8f0c					ld hl, display_fb0 
8f0c					ld (display_fb_active), hl 
8f0c				call clear_display 
8f0c				ld a, 0 
8f0c				ld de, .malloczero 
8f0c				call str_at_display 
8f0c				call update_display 
8f0c				call delay1s 
8f0c				call delay1s 
8f0c				ld a, 0 
8f0c				ld (os_view_disable), a 
8f0c			 
8f0c				pop de 
8f0c				pop hl 
8f0c			 
8f0c				 
8f0c			 
8f0c				CALLMONITOR 
8f0c			.lowalloz: 
8f0c			 
8f0c			 
8f0c				pop af 
8f0c				pop de 
8f0c				pop hl 
8f0c			ret 
8f0c			 
8f0c			malloc_guard_entry: 
8f0c				push hl 
8f0c				push de 
8f0c				push af 
8f0c			 
8f0c			 	or a      ;clear carry flag 
8f0c				push hl 
8f0c				ld de, 255 
8f0c				sbc hl, de 
8f0c				jr c, .lowalloc 
8f0c			 
8f0c				push de 
8f0c					ld hl, display_fb0 
8f0c					ld (display_fb_active), hl 
8f0c				call clear_display 
8f0c				ld a, 0 
8f0c				ld de, .mallocsize 
8f0c				call str_at_display 
8f0c				call update_display 
8f0c				call delay1s 
8f0c				call delay1s 
8f0c				ld a, 0 
8f0c				ld (os_view_disable), a 
8f0c			 
8f0c				pop de 
8f0c				pop hl 
8f0c			 
8f0c				 
8f0c			 
8f0c				CALLMONITOR 
8f0c				jr .lowdone 
8f0c			.lowalloc: 
8f0c			 
8f0c			 
8f0c				pop hl 
8f0c			.lowdone:	pop af 
8f0c				pop de 
8f0c				pop hl 
8f0c			ret 
8f0c			 
8f0c			malloc_guard_exit: 
8f0c				push hl 
8f0c				push de 
8f0c				push af 
8f0c			 
8f0c			 	or a      ;clear carry flag 
8f0c				push hl 
8f0c				ld de, 255 
8f0c				sbc hl, de 
8f0c				jr c, .lowallocx 
8f0c			 
8f0c				push de 
8f0c					ld hl, display_fb0 
8f0c					ld (display_fb_active), hl 
8f0c				call clear_display 
8f0c				ld a, 0 
8f0c				ld de, .mallocasize 
8f0c				call str_at_display 
8f0c				call update_display 
8f0c				call delay1s 
8f0c				call delay1s 
8f0c				ld a, 0 
8f0c				ld (os_view_disable), a 
8f0c				pop de 
8f0c				pop hl 
8f0c			 
8f0c				CALLMONITOR 
8f0c				jr .lowdonex 
8f0c			.lowallocx: 
8f0c			 
8f0c				pop hl 
8f0c			.lowdonex:	pop af 
8f0c				pop de 
8f0c				pop hl 
8f0c			ret 
8f0c			endif 
8f0c			 
8f0c			if MALLOC_2 
8f0c			; Z80 Malloc and Free Functions 
8f0c			 
8f0c			; Malloc Function: 
8f0c			; Input: 
8f0c			;   HL: Size of block to allocate 
8f0c			; Output: 
8f0c			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f0c			 
8f0c			malloc: 
8f0c				 
8f0c			if DEBUG_FORTH_MALLOC_HIGH 
8f0c			call malloc_guard_entry 
8f0c			endif 
8f0c			 
8f0c			 
8f0c			 
8f0c			 
8f0c					if DEBUG_FORTH_MALLOC 
8f0c						DMARK "mal" 
8f0c						CALLMONITOR 
8f0c					endif 
8f0c			    push af            ; Save AF register 
8f0c			    ld a, l            ; Load low byte of size into A 
8f0c			    or h               ; Check if size is zero 
8f0c			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f0c			 
8f0c			    ; Allocate memory 
8f0c			    ld hl, (heap_start) ; Load start of heap into HL 
8f0c					if DEBUG_FORTH_MALLOC 
8f0c						DMARK "ma1" 
8f0c						CALLMONITOR 
8f0c					endif 
8f0c			    call malloc_internal ; Call internal malloc function 
8f0c			    pop af             ; Restore AF register 
8f0c			if DEBUG_FORTH_MALLOC_HIGH 
8f0c			call malloc_guard_exit 
8f0c			call malloc_guard_zerolen 
8f0c			endif 
8f0c			    ret                ; Return 
8f0c			 
8f0c			; Free Function: 
8f0c			; Input: 
8f0c			;   HL: Pointer to memory block to free 
8f0c			; Output: 
8f0c			;   None 
8f0c			 
8f0c			free: 
8f0c			    push af            ; Save AF register 
8f0c			    ld a, l            ; Load low byte of pointer into A 
8f0c			    or h               ; Check if pointer is NULL 
8f0c			    jp z, free_exit    ; If pointer is NULL, exit 
8f0c			 
8f0c			    ; Free memory 
8f0c			    ld hl, (heap_start) ; Load start of heap into HL 
8f0c			    call free_internal  ; Call internal free function 
8f0c			    pop af             ; Restore AF register 
8f0c			    ret                ; Return 
8f0c			 
8f0c			; Internal Malloc Function: 
8f0c			; Input: 
8f0c			;   HL: Size of block to allocate 
8f0c			; Output: 
8f0c			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f0c			 
8f0c			malloc_internal: 
8f0c			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f0c			    add hl, bc         ; Add management overhead to requested size 
8f0c			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f0c					if DEBUG_FORTH_MALLOC 
8f0c						DMARK "ma2" 
8f0c						CALLMONITOR 
8f0c					endif 
8f0c			 
8f0c			    ; Search for free memory block 
8f0c			    ld de, (heap_end)  ; Load end of heap into DE 
8f0c			    ld bc, 0           ; Initialize counter 
8f0c			 
8f0c					if DEBUG_FORTH_MALLOC 
8f0c						DMARK "ma2" 
8f0c						CALLMONITOR 
8f0c					endif 
8f0c			malloc_search_loop: 
8f0c			    ; Check if current block is free 
8f0c			    ld a, (hl)         ; Load current block's status (free or used) 
8f0c			    cp 0               ; Compare with zero (free) 
8f0c			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f0c			 
8f0c			    ; Check if current block is large enough 
8f0c			    ld a, (hl+1)       ; Load high byte of block size 
8f0c			    cp l               ; Compare with low byte of requested size 
8f0c			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f0c			 
8f0c			    ld a, (hl+2)       ; Load low byte of block size 
8f0c			    cp h               ; Compare with high byte of requested size 
8f0c			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f0c			 
8f0c			    ; Mark block as used 
8f0c			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f0c			 
8f0c			    ; Calculate remaining space in block 
8f0c			    ld bc, 0           ; Clear BC 
8f0c			    add hl, bc         ; Increment HL to point to start of data block 
8f0c			    add hl, de         ; HL = HL + DE (total size) 
8f0c			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f0c			    add hl, bc         ; Add management overhead to start of data block 
8f0c			 
8f0c			    ; Save pointer to allocated block in HL 
8f0c			if DEBUG_FORTH_MALLOC_HIGH 
8f0c						DMARK "ma5" 
8f0c			call malloc_guard_exit 
8f0c			call malloc_guard_zerolen 
8f0c			endif 
8f0c			    ret 
8f0c			 
8f0c			malloc_skip_block_check: 
8f0c			    ; Move to the next block 
8f0c			    ld bc, 3           ; Size of management overhead 
8f0c			    add hl, bc         ; Move to the next block 
8f0c			    inc de             ; Increment counter 
8f0c			 
8f0c			    ; Check if we have reached the end of heap 
8f0c			    ld a, e            ; Load low byte of heap end address 
8f0c			    cp (hl)            ; Compare with low byte of current address 
8f0c			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f0c			    ld a, d            ; Load high byte of heap end address 
8f0c			    cp 0               ; Check if it's zero (end of memory) 
8f0c			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f0c			 
8f0c			    ; If we reached here, allocation failed 
8f0c			    xor a              ; Set result to NULL 
8f0c			if DEBUG_FORTH_MALLOC_HIGH 
8f0c						DMARK "ma6" 
8f0c			call malloc_guard_exit 
8f0c			call malloc_guard_zerolen 
8f0c			endif 
8f0c			    ret 
8f0c			malloc_exit: 
8f0c			if DEBUG_FORTH_MALLOC_HIGH 
8f0c						DMARK "ma7" 
8f0c			call malloc_guard_exit 
8f0c			call malloc_guard_zerolen 
8f0c			endif 
8f0c			    ret 
8f0c			 
8f0c			; Internal Free Function: 
8f0c			; Input: 
8f0c			;   HL: Pointer to memory block to free 
8f0c			; Output: 
8f0c			;   None 
8f0c			 
8f0c			free_internal: 
8f0c			    ld de, (heap_start) ; Load start of heap into DE 
8f0c			    ld bc, 0            ; Initialize counter 
8f0c			 
8f0c			free_search_loop: 
8f0c			    ; Check if current block contains the pointer 
8f0c			    ld a, l             ; Load low byte of pointer 
8f0c			    cp (hl+1)           ; Compare with high byte of current block's address 
8f0c			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f0c			    ld a, h             ; Load high byte of pointer 
8f0c			    cp (hl+2)           ; Compare with low byte of current block's address 
8f0c			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f0c			 
8f0c			    ; Mark block as free 
8f0c			    ld (hl), 0          ; Set status byte to indicate free block 
8f0c			    ret                 ; Return 
8f0c			 
8f0c			free_skip_block_check: 
8f0c			    ; Move to the next block 
8f0c			    ld bc, 3            ; Size of management overhead 
8f0c			    add hl, bc          ; Move to the next block 
8f0c			    inc de              ; Increment counter 
8f0c			 
8f0c			    ; Check if we have reached the end of heap 
8f0c			    ld a, e             ; Load low byte of heap end address 
8f0c			    cp (hl)             ; Compare with low byte of current address 
8f0c			    jr nz, free_search_loop  ; If not equal, continue searching 
8f0c			    ld a, d             ; Load high byte of heap end address 
8f0c			    cp 0                ; Check if it's zero (end of memory) 
8f0c			    jr nz, free_search_loop  ; If not zero, continue searching 
8f0c			 
8f0c			    ; If we reached here, pointer is not found in heap 
8f0c			    ret 
8f0c			 
8f0c			free_exit: 
8f0c			    ret                 ; Return 
8f0c			 
8f0c			; Define heap start and end addresses 
8f0c			;heap_start:    .dw 0xC000   ; Start of heap 
8f0c			;heap_end:      .dw 0xE000   ; End of heap 
8f0c			 
8f0c			endif 
8f0c			 
8f0c			 
8f0c			if MALLOC_1 
8f0c			 
8f0c			 
8f0c			 
8f0c			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f0c			 
8f0c			;moved to firmware.asm 
8f0c			;heap_start        .equ  0x9000      ; Starting address of heap 
8f0c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f0c			 
8f0c			;      .org 0 
8f0c			;      jp    main 
8f0c			 
8f0c			 
8f0c			;      .org  0x100 
8f0c			;main: 
8f0c			;      ld    HL, 0x8100 
8f0c			;      ld    SP, HL 
8f0c			; 
8f0c			;      call  heap_init 
8f0c			; 
8f0c			;      ; Make some allocations 
8f0c			;      ld    HL, 12 
8f0c			;      call  malloc            ; Allocates 0x9004 
8f0c			; 
8f0c			;      ld    HL, 12 
8f0c			;      call  malloc            ; Allocates 0x9014 
8f0c			; 
8f0c			;      ld    HL, 12 
8f0c			;      call  malloc            ; Allocates 0x9024 
8f0c			; 
8f0c			;      ; Free some allocations 
8f0c			;      ld    HL, 0x9014 
8f0c			;      call  free 
8f0c			; 
8f0c			;      ld    HL, 0x9004 
8f0c			;      call  free 
8f0c			; 
8f0c			;      ld    HL, 0x9024 
8f0c			;      call  free 
8f0c			; 
8f0c			; 
8f0c			;      halt 
8f0c			 
8f0c			 
8f0c			;------------------------------------------------------------------------------ 
8f0c			;     heap_init                                                               : 
8f0c			;                                                                             : 
8f0c			; Description                                                                 : 
8f0c			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f0c			;                                                                             : 
8f0c			;     The heap is maintained as a linked list, starting with an initial       : 
8f0c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f0c			;     the first free block in the heap. Each block then points to the next    : 
8f0c			;     free block within the heap, and the free list ends at the first block   : 
8f0c			;     with a null pointer to the next free block.                             : 
8f0c			;                                                                             : 
8f0c			; Parameters                                                                  : 
8f0c			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f0c			;     address of the heap and its size are required, along with a memory      : 
8f0c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f0c			;     principally stores a pointer to the first free block in the heap.       : 
8f0c			;                                                                             : 
8f0c			; Returns                                                                     : 
8f0c			;     Nothing                                                                 : 
8f0c			;------------------------------------------------------------------------------ 
8f0c			heap_init: 
8f0c e5			      push  HL 
8f0d			 
8f0d			      ; Initialise free list struct 
8f0d 21 3f d8		      ld    HL, heap_start 
8f10 22 3a d8		      ld    (free_list), HL 
8f13 21 00 00		      ld    HL, 0 
8f16 22 3c d8		      ld    (free_list+2), HL 
8f19			 
8f19			      ; Insert first free block at bottom of heap, consumes entire heap 
8f19 21 c8 e4		      ld    HL, heap_start+heap_size-4 
8f1c 22 3f d8		      ld    (heap_start), HL        ; Next block (end of free list) 
8f1f 21 89 0c		      ld    HL, heap_size-4 
8f22 22 41 d8		      ld    (heap_start+2), HL      ; Block size 
8f25			 
8f25			      ; Insert end of free list block at top of heap - two null words will 
8f25			      ; terminate the free list 
8f25 21 00 00		      ld    HL, 0 
8f28 22 ca e4		      ld    (heap_start+heap_size-2), HL 
8f2b 22 c8 e4		      ld    (heap_start+heap_size-4), HL 
8f2e			 
8f2e e1			      pop   HL 
8f2f			 
8f2f c9			      ret 
8f30			 
8f30			 
8f30			;------------------------------------------------------------------------------ 
8f30			;     malloc                                                                  : 
8f30			;                                                                             : 
8f30			; Description                                                                 : 
8f30			;     Allocates the wanted space from the heap and returns the address of the : 
8f30			;     first useable byte of the allocation.                                   : 
8f30			;                                                                             : 
8f30			;     Allocations can happen in one of two ways:                              : 
8f30			;                                                                             : 
8f30			;     1. A free block may be found which is the exact size wanted. In this    : 
8f30			;        case the block is removed from the free list and retuedn to the      : 
8f30			;        caller.                                                              : 
8f30			;     2. A free block may be found which is larger than the size wanted. In   : 
8f30			;        this case, the larger block is split into two. The first portion of  : 
8f30			;        this block will become the requested space by the malloc call and    : 
8f30			;        is returned to the caller. The second portion becomes a new free     : 
8f30			;        block, and the free list is adjusted to maintain continuity via this : 
8f30			;        newly created block.                                                 : 
8f30			;                                                                             : 
8f30			;     malloc does not set any initial value in the allocated space, the       : 
8f30			;     caller is required to do this as required.                              : 
8f30			;                                                                             : 
8f30			;     This implementation of malloc uses the stack exclusively, and is        : 
8f30			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f30			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f30			;     to avoid the use of malloc inside ISRs in general.                      : 
8f30			;                                                                             : 
8f30			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f30			;                                                                             : 
8f30			; Parameters                                                                  : 
8f30			;     HL  Number of bytes wanted                                              : 
8f30			;                                                                             : 
8f30			; Returns                                                                     : 
8f30			;     HL  Address of the first useable byte of the allocation                 : 
8f30			;                                                                             : 
8f30			; Flags                                                                       : 
8f30			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f30			;                                                                             : 
8f30			; Stack frame                                                                 : 
8f30			;       |             |                                                       : 
8f30			;       +-------------+                                                       : 
8f30			;       |     BC      |                                                       : 
8f30			;       +-------------+                                                       : 
8f30			;       |     DE      |                                                       : 
8f30			;       +-------------+                                                       : 
8f30			;       |     IX      |                                                       : 
8f30			;       +-------------+                                                       : 
8f30			;       |  prev_free  |                                                       : 
8f30			;   +4  +-------------+                                                       : 
8f30			;       |  this_free  |                                                       : 
8f30			;   +2  +-------------+                                                       : 
8f30			;       |  next_free  |                                                       : 
8f30			;   +0  +-------------+                                                       : 
8f30			;       |             |                                                       : 
8f30			;                                                                             : 
8f30			;------------------------------------------------------------------------------ 
8f30			 
8f30			 
8f30			;malloc: 
8f30			; 
8f30			;	SAVESP ON 1 
8f30			; 
8f30			;	call malloc_code 
8f30			; 
8f30			;	CHECKSP ON 1 
8f30			;	ret 
8f30			 
8f30			 
8f30			malloc: 
8f30 c5			      push  BC 
8f31 d5			      push  DE 
8f32 dd e5		      push  IX 
8f34			if DEBUG_FORTH_MALLOC_HIGH 
8f34			call malloc_guard_entry 
8f34			endif 
8f34			 
8f34					if DEBUG_FORTH_MALLOC 
8f34						DMARK "mal" 
8f34						CALLMONITOR 
8f34					endif 
8f34 7c			      ld    A, H                    ; Exit if no space requested 
8f35 b5			      or    L 
8f36 ca f5 8f		      jp    Z, malloc_early_exit 
8f39			 
8f39			;inc hl 
8f39			;inc hl 
8f39			;inc hl 
8f39			; 
8f39			;inc hl 
8f39			;inc hl 
8f39			;inc hl 
8f39			;inc hl 
8f39			;inc hl 
8f39			;inc hl 
8f39			;inc hl 
8f39			;inc hl 
8f39			;inc hl 
8f39			 
8f39			 
8f39			 
8f39			 
8f39					if DEBUG_FORTH_MALLOC 
8f39						DMARK "maA" 
8f39						CALLMONITOR 
8f39					endif 
8f39			      ; Set up stack frame 
8f39 eb			      ex    DE, HL 
8f3a 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f3d 39			      add   HL, SP 
8f3e f9			      ld    SP, HL 
8f3f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f43 dd 39		      add   IX, SP 
8f45			 
8f45			      ; Setup initial state 
8f45 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f48 19			      add   HL, DE 
8f49			 
8f49 44			      ld    B, H                    ; Move want to BC 
8f4a 4d			      ld    C, L 
8f4b			 
8f4b 21 3a d8		      ld    HL, free_list           ; Store prev_free ptr to stack 
8f4e dd 75 04		      ld    (IX+4), L 
8f51 dd 74 05		      ld    (IX+5), H 
8f54			 
8f54 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8f55 23			      inc   HL 
8f56 56			      ld    D, (HL) 
8f57 dd 73 02		      ld    (IX+2), E 
8f5a dd 72 03		      ld    (IX+3), D 
8f5d eb			      ex    DE, HL                  ; this_free ptr into HL 
8f5e			 
8f5e					if DEBUG_FORTH_MALLOC 
8f5e						DMARK "maB" 
8f5e						CALLMONITOR 
8f5e					endif 
8f5e			      ; Loop through free block list to find some space 
8f5e			malloc_find_space: 
8f5e 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8f5f 23			      inc   HL 
8f60 56			      ld    D, (HL) 
8f61			 
8f61 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8f62 b3			      or    E 
8f63 ca ef 8f		      jp    Z, malloc_no_space 
8f66			 
8f66 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8f69 dd 72 01		      ld    (IX+1), D 
8f6c			 
8f6c			      ; Does this block have enough space to make the allocation? 
8f6c 23			      inc   HL                      ; Load free block size into DE 
8f6d 5e			      ld    E, (HL) 
8f6e 23			      inc   HL 
8f6f 56			      ld    D, (HL) 
8f70			 
8f70 eb			      ex    DE, HL                  ; Check size of block against want 
8f71 b7			      or    A                       ; Ensure carry flag clear 
8f72 ed 42		      sbc   HL, BC 
8f74 e5			      push  HL                      ; Store the result for later (new block size) 
8f75			 
8f75 ca c4 8f		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8f78 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8f7a			 
8f7a			      ; this_free block is not big enough, setup ptrs to test next free block 
8f7a e1			      pop   HL                      ; Discard previous result 
8f7b			 
8f7b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8f7e dd 66 03		      ld    H, (IX+3) 
8f81 dd 75 04		      ld    (IX+4), L 
8f84 dd 74 05		      ld    (IX+5), H 
8f87			 
8f87 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8f8a dd 66 01		      ld    H, (IX+1) 
8f8d dd 75 02		      ld    (IX+2), L 
8f90 dd 74 03		      ld    (IX+3), H 
8f93			 
8f93					if DEBUG_FORTH_MALLOC 
8f93						DMARK "MA>" 
8f93						CALLMONITOR 
8f93					endif 
8f93 18 c9		      jr    malloc_find_space 
8f95			 
8f95			      ; split a bigger block into two - requested size and remaining size 
8f95			malloc_alloc_split: 
8f95					if DEBUG_FORTH_MALLOC 
8f95						DMARK "MAs" 
8f95						CALLMONITOR 
8f95					endif 
8f95 eb			      ex    DE, HL                  ; Calculate address of new free block 
8f96 2b			      dec   HL 
8f97 2b			      dec   HL 
8f98 2b			      dec   HL 
8f99 09			      add   HL, BC 
8f9a			 
8f9a			      ; Create a new block and point it at next_free 
8f9a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8f9d dd 56 01		      ld    D, (IX+1) 
8fa0			 
8fa0 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8fa1 23			      inc   HL 
8fa2 72			      ld    (HL), D 
8fa3			 
8fa3 d1			      pop   DE                      ; Store size of new block into new block 
8fa4 23			      inc   HL 
8fa5 73			      ld    (HL), E 
8fa6 23			      inc   HL 
8fa7 72			      ld    (HL), D 
8fa8			 
8fa8			      ; Update this_free ptr to point to new block 
8fa8 2b			      dec   HL 
8fa9 2b			      dec   HL 
8faa 2b			      dec   HL 
8fab			 
8fab dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8fae dd 56 03		      ld    D, (IX+3) 
8fb1			 
8fb1 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8fb4 dd 74 03		      ld    (IX+3), H 
8fb7			 
8fb7			      ; Modify this_free block to be allocation 
8fb7 eb			      ex    DE, HL 
8fb8 af			      xor   A                       ; Null the next block ptr of allocated block 
8fb9 77			      ld    (HL), A 
8fba 23			      inc   HL 
8fbb 77			      ld    (HL), A 
8fbc			 
8fbc 23			      inc   HL                      ; Store want size into allocated block 
8fbd 71			      ld    (HL), C 
8fbe 23			      inc   HL 
8fbf 70			      ld    (HL), B 
8fc0 23			      inc   HL 
8fc1 e5			      push  HL                      ; Address of allocation to return 
8fc2			 
8fc2 18 19		      jr    malloc_update_links 
8fc4			 
8fc4			malloc_alloc_fit: 
8fc4 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
8fc5			 
8fc5					if DEBUG_FORTH_MALLOC 
8fc5						DMARK "MAf" 
8fc5						CALLMONITOR 
8fc5					endif 
8fc5			      ; Modify this_free block to be allocation 
8fc5 eb			      ex    DE, HL 
8fc6 2b			      dec   HL 
8fc7 2b			      dec   HL 
8fc8 2b			      dec   HL 
8fc9			 
8fc9 af			      xor   A                       ; Null the next block ptr of allocated block 
8fca 77			      ld    (HL), A 
8fcb 23			      inc   HL 
8fcc 77			      ld    (HL), A 
8fcd			 
8fcd 23			      inc   HL                      ; Store address of allocation to return 
8fce 23			      inc   HL 
8fcf 23			      inc   HL 
8fd0 e5			      push  HL 
8fd1			 
8fd1			      ; Copy next_free ptr to this_free, remove allocated block from free list 
8fd1 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
8fd4 dd 66 01		      ld    H, (IX+1) 
8fd7			 
8fd7 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
8fda dd 74 03		      ld    (IX+3), H 
8fdd			 
8fdd			 
8fdd			malloc_update_links: 
8fdd			      ; Update prev_free ptr to point to this_free 
8fdd dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
8fe0 dd 66 05		      ld    H, (IX+5) 
8fe3			 
8fe3 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
8fe6 dd 56 03		      ld    D, (IX+3) 
8fe9			 
8fe9 73			      ld    (HL), E                 ; this_free ptr into prev_free 
8fea 23			      inc   HL 
8feb 72			      ld    (HL), D 
8fec			 
8fec					if DEBUG_FORTH_MALLOC 
8fec						DMARK "Mul" 
8fec						CALLMONITOR 
8fec					endif 
8fec			      ; Clear the Z flag to indicate successful allocation 
8fec 7a			      ld    A, D 
8fed b3			      or    E 
8fee			 
8fee d1			      pop   DE                      ; Address of allocation 
8fef					if DEBUG_FORTH_MALLOC 
8fef						DMARK "MAu" 
8fef						CALLMONITOR 
8fef					endif 
8fef			 
8fef			malloc_no_space: 
8fef 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
8ff2 39			      add   HL, SP 
8ff3 f9			      ld    SP, HL 
8ff4			 
8ff4 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
8ff5					if DEBUG_FORTH_MALLOC 
8ff5						DMARK "MAN" 
8ff5						CALLMONITOR 
8ff5					endif 
8ff5			 
8ff5			malloc_early_exit: 
8ff5					if DEBUG_FORTH_MALLOC 
8ff5						DMARK "MAx" 
8ff5						CALLMONITOR 
8ff5					endif 
8ff5 dd e1		      pop   IX 
8ff7 d1			      pop   DE 
8ff8 c1			      pop   BC 
8ff9			 
8ff9			if DEBUG_FORTH_MALLOC_HIGH 
8ff9			call malloc_guard_exit 
8ff9			call malloc_guard_zerolen 
8ff9			endif 
8ff9 c9			      ret 
8ffa			 
8ffa			 
8ffa			;------------------------------------------------------------------------------ 
8ffa			;     free                                                                    : 
8ffa			;                                                                             : 
8ffa			; Description                                                                 : 
8ffa			;     Return the space pointed to by HL to the heap. HL must be an address as : 
8ffa			;     returned by malloc, otherwise the behaviour is undefined.               : 
8ffa			;                                                                             : 
8ffa			;     Where possible, directly adjacent free blocks will be merged together   : 
8ffa			;     into larger blocks to help ensure that the heap does not become         : 
8ffa			;     excessively fragmented.                                                 : 
8ffa			;                                                                             : 
8ffa			;     free does not clear or set any other value into the freed space, and    : 
8ffa			;     therefore its contents may be visible through subsequent malloc's. The  : 
8ffa			;     caller should clear the freed space as required.                        : 
8ffa			;                                                                             : 
8ffa			;     This implementation of free uses the stack exclusively, and is          : 
8ffa			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8ffa			;     advisable to disable interrupts before calling free, and recommended    : 
8ffa			;     to avoid the use of free inside ISRs in general.                        : 
8ffa			;                                                                             : 
8ffa			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8ffa			;                                                                             : 
8ffa			; Parameters                                                                  : 
8ffa			;     HL  Pointer to address of first byte of allocation to be freed          : 
8ffa			;                                                                             : 
8ffa			; Returns                                                                     : 
8ffa			;     Nothing                                                                 : 
8ffa			;                                                                             : 
8ffa			; Stack frame                                                                 : 
8ffa			;       |             |                                                       : 
8ffa			;       +-------------+                                                       : 
8ffa			;       |     BC      |                                                       : 
8ffa			;       +-------------+                                                       : 
8ffa			;       |     DE      |                                                       : 
8ffa			;       +-------------+                                                       : 
8ffa			;       |     IX      |                                                       : 
8ffa			;       +-------------+                                                       : 
8ffa			;       |  prev_free  |                                                       : 
8ffa			;   +2  +-------------+                                                       : 
8ffa			;       |  next_free  |                                                       : 
8ffa			;   +0  +-------------+                                                       : 
8ffa			;       |             |                                                       : 
8ffa			;                                                                             : 
8ffa			;------------------------------------------------------------------------------ 
8ffa			free: 
8ffa c5			      push  BC 
8ffb d5			      push  DE 
8ffc dd e5		      push  IX 
8ffe			 
8ffe 7c			      ld    A, H                    ; Exit if ptr is null 
8fff b5			      or    L 
9000 ca c4 90		      jp    Z, free_early_exit 
9003			 
9003			      ; Set up stack frame 
9003 eb			      ex    DE, HL 
9004 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9007 39			      add   HL, SP 
9008 f9			      ld    SP, HL 
9009 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
900d dd 39		      add   IX, SP 
900f			 
900f			      ; The address in HL points to the start of the useable allocated space, 
900f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
900f			      ; address of the block itself. 
900f eb			      ex    DE, HL 
9010 11 fc ff		      ld    DE, -4 
9013 19			      add   HL, DE 
9014			 
9014			      ; An allocated block must have a null next block pointer in it 
9014 7e			      ld    A, (HL) 
9015 23			      inc   HL 
9016 b6			      or    (HL) 
9017 c2 bf 90		      jp    NZ, free_done 
901a			 
901a 2b			      dec   HL 
901b			 
901b 44			      ld    B, H                    ; Copy HL to BC 
901c 4d			      ld    C, L 
901d			 
901d			      ; Loop through the free list to find the first block with an address 
901d			      ; higher than the block being freed 
901d 21 3a d8		      ld    HL, free_list 
9020			 
9020			free_find_higher_block: 
9020 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9021 23			      inc   HL 
9022 56			      ld    D, (HL) 
9023 2b			      dec   HL 
9024			 
9024 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9027 dd 72 01		      ld    (IX+1), D 
902a dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
902d dd 74 03		      ld    (IX+3), H 
9030			 
9030 78			      ld    A, B                    ; Check if DE is greater than BC 
9031 ba			      cp    D                       ; Compare MSB first 
9032 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9034 30 04		      jr    NC, free_find_higher_block_skip 
9036 79			      ld    A, C 
9037 bb			      cp    E                       ; Then compare LSB 
9038 38 08		      jr    C, free_found_higher_block 
903a			 
903a			free_find_higher_block_skip: 
903a 7a			      ld    A, D                    ; Reached the end of the free list? 
903b b3			      or    E 
903c ca bf 90		      jp    Z, free_done 
903f			 
903f eb			      ex    DE, HL 
9040			 
9040 18 de		      jr    free_find_higher_block 
9042			 
9042			free_found_higher_block: 
9042			      ; Insert freed block between prev and next free blocks 
9042 71			      ld    (HL), C                 ; Point prev free block to freed block 
9043 23			      inc   HL 
9044 70			      ld    (HL), B 
9045			 
9045 60			      ld    H, B                    ; Point freed block at next free block 
9046 69			      ld    L, C 
9047 73			      ld    (HL), E 
9048 23			      inc   HL 
9049 72			      ld    (HL), D 
904a			 
904a			      ; Check if the freed block is adjacent to the next free block 
904a 23			      inc   HL                      ; Load size of freed block into HL 
904b 5e			      ld    E, (HL) 
904c 23			      inc   HL 
904d 56			      ld    D, (HL) 
904e eb			      ex    DE, HL 
904f			 
904f 09			      add   HL, BC                  ; Add addr of freed block and its size 
9050			 
9050 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
9053 dd 56 01		      ld    D, (IX+1) 
9056			 
9056 b7			      or    A                       ; Clear the carry flag 
9057 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9059 20 22		      jr    NZ, free_check_adjacent_to_prev 
905b			 
905b			      ; Freed block is adjacent to next, merge into one bigger block 
905b eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
905c 5e			      ld    E, (HL) 
905d 23			      inc   HL 
905e 56			      ld    D, (HL) 
905f e5			      push  HL                      ; Save ptr to next block for later 
9060			 
9060 60			      ld    H, B                    ; Store ptr from next block into freed block 
9061 69			      ld    L, C 
9062 73			      ld    (HL), E 
9063 23			      inc   HL 
9064 72			      ld    (HL), D 
9065			 
9065 e1			      pop   HL                      ; Restore ptr to next block 
9066 23			      inc   HL                      ; Load size of next block into DE 
9067 5e			      ld    E, (HL) 
9068 23			      inc   HL 
9069 56			      ld    D, (HL) 
906a d5			      push  DE                      ; Save next block size for later 
906b			 
906b 60			      ld    H, B                    ; Load size of freed block into HL 
906c 69			      ld    L, C 
906d 23			      inc   HL 
906e 23			      inc   HL 
906f 5e			      ld    E, (HL) 
9070 23			      inc   HL 
9071 56			      ld    D, (HL) 
9072 eb			      ex    DE, HL 
9073			 
9073 d1			      pop   DE                      ; Restore size of next block 
9074 19			      add   HL, DE                  ; Add sizes of both blocks 
9075 eb			      ex    DE, HL 
9076			 
9076 60			      ld    H, B                    ; Store new bigger size into freed block 
9077 69			      ld    L, C 
9078 23			      inc   HL 
9079 23			      inc   HL 
907a 73			      ld    (HL), E 
907b 23			      inc   HL 
907c 72			      ld    (HL), D 
907d			 
907d			free_check_adjacent_to_prev: 
907d			      ; Check if the freed block is adjacent to the prev free block 
907d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
9080 dd 66 03		      ld    H, (IX+3) 
9083			 
9083 23			      inc   HL                      ; Size of prev free block into DE 
9084 23			      inc   HL 
9085 5e			      ld    E, (HL) 
9086 23			      inc   HL 
9087 56			      ld    D, (HL) 
9088 2b			      dec   HL 
9089 2b			      dec   HL 
908a 2b			      dec   HL 
908b			 
908b 19			      add   HL, DE                  ; Add prev block addr and size 
908c			 
908c b7			      or    A                       ; Clear the carry flag 
908d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
908f 20 2e		      jr    NZ, free_done 
9091			 
9091			      ; Freed block is adjacent to prev, merge into one bigger block 
9091 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9092 69			      ld    L, C 
9093 5e			      ld    E, (HL) 
9094 23			      inc   HL 
9095 56			      ld    D, (HL) 
9096 e5			      push  HL                      ; Save freed block ptr for later 
9097			 
9097 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
909a dd 66 03		      ld    H, (IX+3) 
909d 73			      ld    (HL), E 
909e 23			      inc   HL 
909f 72			      ld    (HL), D 
90a0			 
90a0 e1			      pop   HL                      ; Restore freed block ptr 
90a1 23			      inc   HL                      ; Load size of freed block into DE 
90a2 5e			      ld    E, (HL) 
90a3 23			      inc   HL 
90a4 56			      ld    D, (HL) 
90a5 d5			      push  DE                      ; Save freed block size for later 
90a6			 
90a6 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
90a9 dd 66 03		      ld    H, (IX+3) 
90ac 23			      inc   HL 
90ad 23			      inc   HL 
90ae 5e			      ld    E, (HL) 
90af 23			      inc   HL 
90b0 56			      ld    D, (HL) 
90b1			 
90b1 e1			      pop   HL                      ; Add sizes of both blocks 
90b2 19			      add   HL, DE 
90b3 eb			      ex    DE, HL 
90b4			 
90b4 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
90b7 dd 66 03		      ld    H, (IX+3) 
90ba 23			      inc   HL 
90bb 23			      inc   HL 
90bc 73			      ld    (HL), E 
90bd 23			      inc   HL 
90be 72			      ld    (HL), D 
90bf			 
90bf			free_done: 
90bf 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
90c2 39			      add   HL, SP 
90c3 f9			      ld    SP, HL 
90c4			 
90c4			free_early_exit: 
90c4 dd e1		      pop   IX 
90c6 d1			      pop   DE 
90c7 c1			      pop   BC 
90c8			 
90c8 c9			      ret 
90c9			 
90c9			; moved to firmware.asm 
90c9			; 
90c9			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
90c9			;                  .dw   0 
90c9			 
90c9			 
90c9			endif 
90c9			 
90c9			 
90c9			if MALLOC_3 
90c9			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
90c9			;heap_start        .equ  0x9000      ; Starting address of heap 
90c9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
90c9			; 
90c9			 ;     .org 0 
90c9			  ;    jp    main 
90c9			; 
90c9			; 
90c9			 ;     .org  0x100 
90c9			;main: 
90c9			 ;     ld    HL, 0x8100 
90c9			  ;    ld    SP, HL 
90c9			; 
90c9			;      call  heap_init 
90c9			 
90c9			      ; Make some allocations 
90c9			;      ld    HL, 12 
90c9			;      call  malloc            ; Allocates 0x9004 
90c9			; 
90c9			 ;     ld    HL, 12 
90c9			;      call  malloc            ; Allocates 0x9014 
90c9			 
90c9			;      ld    HL, 12 
90c9			;      call  malloc            ; Allocates 0x9024 
90c9			 
90c9			      ; Free some allocations 
90c9			;      ld    HL, 0x9014 
90c9			;      call  free 
90c9			 
90c9			;      ld    HL, 0x9004 
90c9			;      call  free 
90c9			; 
90c9			;      ld    HL, 0x9024 
90c9			;      call  free 
90c9			 
90c9			 
90c9			 ;     halt 
90c9			 
90c9			 
90c9			;------------------------------------------------------------------------------ 
90c9			;     heap_init                                                               : 
90c9			;                                                                             : 
90c9			; Description                                                                 : 
90c9			;     Initialise the heap and make it ready for malloc and free operations.   : 
90c9			;                                                                             : 
90c9			;     The heap is maintained as a linked list, starting with an initial       : 
90c9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
90c9			;     the first free block in the heap. Each block then points to the next    : 
90c9			;     free block within the heap, and the free list ends at the first block   : 
90c9			;     with a null pointer to the next free block.                             : 
90c9			;                                                                             : 
90c9			; Parameters                                                                  : 
90c9			;     Inputs are compile-time only. Two defines which specify the starting    : 
90c9			;     address of the heap and its size are required, along with a memory      : 
90c9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
90c9			;     principally stores a pointer to the first free block in the heap.       : 
90c9			;                                                                             : 
90c9			; Returns                                                                     : 
90c9			;     Nothing                                                                 : 
90c9			;------------------------------------------------------------------------------ 
90c9			heap_init: 
90c9			      push  HL 
90c9			 
90c9			      ; Initialise free list struct 
90c9			      ld    HL, heap_start 
90c9			      ld    (free_list), HL 
90c9			      ld    HL, 0 
90c9			      ld    (free_list+2), HL 
90c9			 
90c9			      ; Insert first free block at bottom of heap, consumes entire heap 
90c9			      ld    HL, heap_start+heap_size-4 
90c9			      ld    (heap_start), HL        ; Next block (end of free list) 
90c9			      ld    HL, heap_size-4 
90c9			      ld    (heap_start+2), HL      ; Block size 
90c9			 
90c9			      ; Insert end of free list block at top of heap - two null words will 
90c9			      ; terminate the free list 
90c9			      ld    HL, 0 
90c9			      ld    (heap_start+heap_size-2), HL 
90c9			      ld    (heap_start+heap_size-4), HL 
90c9			 
90c9			      pop   HL 
90c9			 
90c9			      ret 
90c9			 
90c9			 
90c9			;------------------------------------------------------------------------------ 
90c9			;     malloc                                                                  : 
90c9			;                                                                             : 
90c9			; Description                                                                 : 
90c9			;     Allocates the wanted space from the heap and returns the address of the : 
90c9			;     first useable byte of the allocation.                                   : 
90c9			;                                                                             : 
90c9			;     Allocations can happen in one of two ways:                              : 
90c9			;                                                                             : 
90c9			;     1. A free block may be found which is the exact size wanted. In this    : 
90c9			;        case the block is removed from the free list and retuedn to the      : 
90c9			;        caller.                                                              : 
90c9			;     2. A free block may be found which is larger than the size wanted. In   : 
90c9			;        this case, the larger block is split into two. The first portion of  : 
90c9			;        this block will become the requested space by the malloc call and    : 
90c9			;        is returned to the caller. The second portion becomes a new free     : 
90c9			;        block, and the free list is adjusted to maintain continuity via this : 
90c9			;        newly created block.                                                 : 
90c9			;                                                                             : 
90c9			;     malloc does not set any initial value in the allocated space, the       : 
90c9			;     caller is required to do this as required.                              : 
90c9			;                                                                             : 
90c9			;     This implementation of malloc uses the stack exclusively, and is        : 
90c9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90c9			;     advisable to disable interrupts before calling malloc, and recommended  : 
90c9			;     to avoid the use of malloc inside ISRs in general.                      : 
90c9			;                                                                             : 
90c9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90c9			;                                                                             : 
90c9			; Parameters                                                                  : 
90c9			;     HL  Number of bytes wanted                                              : 
90c9			;                                                                             : 
90c9			; Returns                                                                     : 
90c9			;     HL  Address of the first useable byte of the allocation                 : 
90c9			;                                                                             : 
90c9			; Flags                                                                       : 
90c9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90c9			;                                                                             : 
90c9			; Stack frame                                                                 : 
90c9			;       |             |                                                       : 
90c9			;       +-------------+                                                       : 
90c9			;       |     BC      |                                                       : 
90c9			;       +-------------+                                                       : 
90c9			;       |     DE      |                                                       : 
90c9			;       +-------------+                                                       : 
90c9			;       |     IX      |                                                       : 
90c9			;       +-------------+                                                       : 
90c9			;       |  prev_free  |                                                       : 
90c9			;   +4  +-------------+                                                       : 
90c9			;       |  this_free  |                                                       : 
90c9			;   +2  +-------------+                                                       : 
90c9			;       |  next_free  |                                                       : 
90c9			;   +0  +-------------+                                                       : 
90c9			;       |             |                                                       : 
90c9			;                                                                             : 
90c9			;------------------------------------------------------------------------------ 
90c9			malloc: 
90c9			      push  BC 
90c9			      push  DE 
90c9			      push  IX 
90c9			 
90c9			      ld    A, H                    ; Exit if no space requested 
90c9			      or    L 
90c9			      jp    Z, malloc_early_exit 
90c9			 
90c9			      ; Set up stack frame 
90c9			      ex    DE, HL 
90c9			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90c9			      add   HL, SP 
90c9			      ld    SP, HL 
90c9			      ld    IX, 0                   ; Use IX as a frame pointer 
90c9			      add   IX, SP 
90c9			 
90c9			      ; Setup initial state 
90c9			      ld    HL, 4                   ; want must also include space used by block struct 
90c9			      add   HL, DE 
90c9			 
90c9			      ld    B, H                    ; Move want to BC 
90c9			      ld    C, L 
90c9			 
90c9			      ld    HL, free_list           ; Store prev_free ptr to stack 
90c9			      ld    (IX+4), L 
90c9			      ld    (IX+5), H 
90c9			 
90c9			      ld    E, (HL)                 ; Store this_free ptr to stack 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			      ld    (IX+2), E 
90c9			      ld    (IX+3), D 
90c9			      ex    DE, HL                  ; this_free ptr into HL 
90c9			 
90c9			      ; Loop through free block list to find some space 
90c9			malloc_find_space: 
90c9			      ld    E, (HL)                 ; Load next_free ptr into DE 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			 
90c9			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90c9			      or    E 
90c9			      jp    Z, malloc_no_space 
90c9			 
90c9			      ld    (IX+0), E               ; Store next_free ptr to stack 
90c9			      ld    (IX+1), D 
90c9			 
90c9			      ; Does this block have enough space to make the allocation? 
90c9			      inc   HL                      ; Load free block size into DE 
90c9			      ld    E, (HL) 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			 
90c9			      ex    DE, HL                  ; Check size of block against want 
90c9			      or    A                       ; Ensure carry flag clear 
90c9			      sbc   HL, BC 
90c9			      push  HL                      ; Store the result for later (new block size) 
90c9			 
90c9			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
90c9			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
90c9			 
90c9			      ; this_free block is not big enough, setup ptrs to test next free block 
90c9			      pop   HL                      ; Discard previous result 
90c9			 
90c9			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
90c9			      ld    H, (IX+3) 
90c9			      ld    (IX+4), L 
90c9			      ld    (IX+5), H 
90c9			 
90c9			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
90c9			      ld    H, (IX+1) 
90c9			      ld    (IX+2), L 
90c9			      ld    (IX+3), H 
90c9			 
90c9			      jr    malloc_find_space 
90c9			 
90c9			      ; split a bigger block into two - requested size and remaining size 
90c9			malloc_alloc_split: 
90c9			      ex    DE, HL                  ; Calculate address of new free block 
90c9			      dec   HL 
90c9			      dec   HL 
90c9			      dec   HL 
90c9			      add   HL, BC 
90c9			 
90c9			      ; Create a new block and point it at next_free 
90c9			      ld    E, (IX+0)               ; Load next_free ptr into DE 
90c9			      ld    D, (IX+1) 
90c9			 
90c9			      ld    (HL), E                 ; Store next_free ptr into new block 
90c9			      inc   HL 
90c9			      ld    (HL), D 
90c9			 
90c9			      pop   DE                      ; Store size of new block into new block 
90c9			      inc   HL 
90c9			      ld    (HL), E 
90c9			      inc   HL 
90c9			      ld    (HL), D 
90c9			 
90c9			      ; Update this_free ptr to point to new block 
90c9			      dec   HL 
90c9			      dec   HL 
90c9			      dec   HL 
90c9			 
90c9			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
90c9			      ld    D, (IX+3) 
90c9			 
90c9			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
90c9			      ld    (IX+3), H 
90c9			 
90c9			      ; Modify this_free block to be allocation 
90c9			      ex    DE, HL 
90c9			      xor   A                       ; Null the next block ptr of allocated block 
90c9			      ld    (HL), A 
90c9			      inc   HL 
90c9			      ld    (HL), A 
90c9			 
90c9			      inc   HL                      ; Store want size into allocated block 
90c9			      ld    (HL), C 
90c9			      inc   HL 
90c9			      ld    (HL), B 
90c9			      inc   HL 
90c9			      push  HL                      ; Address of allocation to return 
90c9			 
90c9			      jr    malloc_update_links 
90c9			 
90c9			malloc_alloc_fit: 
90c9			      pop   HL                      ; Dont need new block size, want is exact fit 
90c9			 
90c9			      ; Modify this_free block to be allocation 
90c9			      ex    DE, HL 
90c9			      dec   HL 
90c9			      dec   HL 
90c9			      dec   HL 
90c9			 
90c9			      xor   A                       ; Null the next block ptr of allocated block 
90c9			      ld    (HL), A 
90c9			      inc   HL 
90c9			      ld    (HL), A 
90c9			 
90c9			      inc   HL                      ; Store address of allocation to return 
90c9			      inc   HL 
90c9			      inc   HL 
90c9			      push  HL 
90c9			 
90c9			      ; Copy next_free ptr to this_free, remove allocated block from free list 
90c9			      ld    L, (IX+0)               ; next_free to HL 
90c9			      ld    H, (IX+1) 
90c9			 
90c9			      ld    (IX+2), L               ; HL to this_free 
90c9			      ld    (IX+3), H 
90c9			 
90c9			 
90c9			malloc_update_links: 
90c9			      ; Update prev_free ptr to point to this_free 
90c9			      ld    L, (IX+4)               ; prev_free ptr to HL 
90c9			      ld    H, (IX+5) 
90c9			 
90c9			      ld    E, (IX+2)               ; this_free ptr to DE 
90c9			      ld    D, (IX+3) 
90c9			 
90c9			      ld    (HL), E                 ; this_free ptr into prev_free 
90c9			      inc   HL 
90c9			      ld    (HL), D 
90c9			 
90c9			      ; Clear the Z flag to indicate successful allocation 
90c9			      ld    A, D 
90c9			      or    E 
90c9			 
90c9			      pop   DE                      ; Address of allocation 
90c9			 
90c9			malloc_no_space: 
90c9			      ld    HL, 6                   ; Clean up stack frame 
90c9			      add   HL, SP 
90c9			      ld    SP, HL 
90c9			 
90c9			      ex    DE, HL                  ; Alloc addr into HL for return 
90c9			 
90c9			malloc_early_exit: 
90c9			      pop   IX 
90c9			      pop   DE 
90c9			      pop   BC 
90c9			 
90c9			      ret 
90c9			 
90c9			 
90c9			;------------------------------------------------------------------------------ 
90c9			;     free                                                                    : 
90c9			;                                                                             : 
90c9			; Description                                                                 : 
90c9			;     Return the space pointed to by HL to the heap. HL must be an address as : 
90c9			;     returned by malloc, otherwise the behaviour is undefined.               : 
90c9			;                                                                             : 
90c9			;     Where possible, directly adjacent free blocks will be merged together   : 
90c9			;     into larger blocks to help ensure that the heap does not become         : 
90c9			;     excessively fragmented.                                                 : 
90c9			;                                                                             : 
90c9			;     free does not clear or set any other value into the freed space, and    : 
90c9			;     therefore its contents may be visible through subsequent malloc's. The  : 
90c9			;     caller should clear the freed space as required.                        : 
90c9			;                                                                             : 
90c9			;     This implementation of free uses the stack exclusively, and is          : 
90c9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90c9			;     advisable to disable interrupts before calling free, and recommended    : 
90c9			;     to avoid the use of free inside ISRs in general.                        : 
90c9			;                                                                             : 
90c9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90c9			;                                                                             : 
90c9			; Parameters                                                                  : 
90c9			;     HL  Pointer to address of first byte of allocation to be freed          : 
90c9			;                                                                             : 
90c9			; Returns                                                                     : 
90c9			;     Nothing                                                                 : 
90c9			;                                                                             : 
90c9			; Stack frame                                                                 : 
90c9			;       |             |                                                       : 
90c9			;       +-------------+                                                       : 
90c9			;       |     BC      |                                                       : 
90c9			;       +-------------+                                                       : 
90c9			;       |     DE      |                                                       : 
90c9			;       +-------------+                                                       : 
90c9			;       |     IX      |                                                       : 
90c9			;       +-------------+                                                       : 
90c9			;       |  prev_free  |                                                       : 
90c9			;   +2  +-------------+                                                       : 
90c9			;       |  next_free  |                                                       : 
90c9			;   +0  +-------------+                                                       : 
90c9			;       |             |                                                       : 
90c9			;                                                                             : 
90c9			;------------------------------------------------------------------------------ 
90c9			free: 
90c9			      push  BC 
90c9			      push  DE 
90c9			      push  IX 
90c9			 
90c9			      ld    A, H                    ; Exit if ptr is null 
90c9			      or    L 
90c9			      jp    Z, free_early_exit 
90c9			 
90c9			      ; Set up stack frame 
90c9			      ex    DE, HL 
90c9			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
90c9			      add   HL, SP 
90c9			      ld    SP, HL 
90c9			      ld    IX, 0                   ; Use IX as a frame pointer 
90c9			      add   IX, SP 
90c9			 
90c9			      ; The address in HL points to the start of the useable allocated space, 
90c9			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
90c9			      ; address of the block itself. 
90c9			      ex    DE, HL 
90c9			      ld    DE, -4 
90c9			      add   HL, DE 
90c9			 
90c9			      ; An allocated block must have a null next block pointer in it 
90c9			      ld    A, (HL) 
90c9			      inc   HL 
90c9			      or    (HL) 
90c9			      jp    NZ, free_done 
90c9			 
90c9			      dec   HL 
90c9			 
90c9			      ld    B, H                    ; Copy HL to BC 
90c9			      ld    C, L 
90c9			 
90c9			      ; Loop through the free list to find the first block with an address 
90c9			      ; higher than the block being freed 
90c9			      ld    HL, free_list 
90c9			 
90c9			free_find_higher_block: 
90c9			      ld    E, (HL)                 ; Load next ptr from free block 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			      dec   HL 
90c9			 
90c9			      ld    (IX+0), E               ; Save ptr to next free block 
90c9			      ld    (IX+1), D 
90c9			      ld    (IX+2), L               ; Save ptr to prev free block 
90c9			      ld    (IX+3), H 
90c9			 
90c9			      ld    A, B                    ; Check if DE is greater than BC 
90c9			      cp    D                       ; Compare MSB first 
90c9			      jr    Z, $+4                  ; MSB the same, compare LSB 
90c9			      jr    NC, free_find_higher_block_skip 
90c9			      ld    A, C 
90c9			      cp    E                       ; Then compare LSB 
90c9			      jr    C, free_found_higher_block 
90c9			 
90c9			free_find_higher_block_skip: 
90c9			      ld    A, D                    ; Reached the end of the free list? 
90c9			      or    E 
90c9			      jp    Z, free_done 
90c9			 
90c9			      ex    DE, HL 
90c9			 
90c9			      jr    free_find_higher_block 
90c9			 
90c9			free_found_higher_block: 
90c9			      ; Insert freed block between prev and next free blocks 
90c9			      ld    (HL), C                 ; Point prev free block to freed block 
90c9			      inc   HL 
90c9			      ld    (HL), B 
90c9			 
90c9			      ld    H, B                    ; Point freed block at next free block 
90c9			      ld    L, C 
90c9			      ld    (HL), E 
90c9			      inc   HL 
90c9			      ld    (HL), D 
90c9			 
90c9			      ; Check if the freed block is adjacent to the next free block 
90c9			      inc   HL                      ; Load size of freed block into HL 
90c9			      ld    E, (HL) 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			      ex    DE, HL 
90c9			 
90c9			      add   HL, BC                  ; Add addr of freed block and its size 
90c9			 
90c9			      ld    E, (IX+0)               ; Load addr of next free block into DE 
90c9			      ld    D, (IX+1) 
90c9			 
90c9			      or    A                       ; Clear the carry flag 
90c9			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
90c9			      jr    NZ, free_check_adjacent_to_prev 
90c9			 
90c9			      ; Freed block is adjacent to next, merge into one bigger block 
90c9			      ex    DE, HL                  ; Load next ptr from next block into DE 
90c9			      ld    E, (HL) 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			      push  HL                      ; Save ptr to next block for later 
90c9			 
90c9			      ld    H, B                    ; Store ptr from next block into freed block 
90c9			      ld    L, C 
90c9			      ld    (HL), E 
90c9			      inc   HL 
90c9			      ld    (HL), D 
90c9			 
90c9			      pop   HL                      ; Restore ptr to next block 
90c9			      inc   HL                      ; Load size of next block into DE 
90c9			      ld    E, (HL) 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			      push  DE                      ; Save next block size for later 
90c9			 
90c9			      ld    H, B                    ; Load size of freed block into HL 
90c9			      ld    L, C 
90c9			      inc   HL 
90c9			      inc   HL 
90c9			      ld    E, (HL) 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			      ex    DE, HL 
90c9			 
90c9			      pop   DE                      ; Restore size of next block 
90c9			      add   HL, DE                  ; Add sizes of both blocks 
90c9			      ex    DE, HL 
90c9			 
90c9			      ld    H, B                    ; Store new bigger size into freed block 
90c9			      ld    L, C 
90c9			      inc   HL 
90c9			      inc   HL 
90c9			      ld    (HL), E 
90c9			      inc   HL 
90c9			      ld    (HL), D 
90c9			 
90c9			free_check_adjacent_to_prev: 
90c9			      ; Check if the freed block is adjacent to the prev free block 
90c9			      ld    L, (IX+2)               ; Prev free block ptr into HL 
90c9			      ld    H, (IX+3) 
90c9			 
90c9			      inc   HL                      ; Size of prev free block into DE 
90c9			      inc   HL 
90c9			      ld    E, (HL) 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			      dec   HL 
90c9			      dec   HL 
90c9			      dec   HL 
90c9			 
90c9			      add   HL, DE                  ; Add prev block addr and size 
90c9			 
90c9			      or    A                       ; Clear the carry flag 
90c9			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90c9			      jr    NZ, free_done 
90c9			 
90c9			      ; Freed block is adjacent to prev, merge into one bigger block 
90c9			      ld    H, B                    ; Load next ptr from freed block into DE 
90c9			      ld    L, C 
90c9			      ld    E, (HL) 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			      push  HL                      ; Save freed block ptr for later 
90c9			 
90c9			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90c9			      ld    H, (IX+3) 
90c9			      ld    (HL), E 
90c9			      inc   HL 
90c9			      ld    (HL), D 
90c9			 
90c9			      pop   HL                      ; Restore freed block ptr 
90c9			      inc   HL                      ; Load size of freed block into DE 
90c9			      ld    E, (HL) 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			      push  DE                      ; Save freed block size for later 
90c9			 
90c9			      ld    L, (IX+2)               ; Load size of prev block into DE 
90c9			      ld    H, (IX+3) 
90c9			      inc   HL 
90c9			      inc   HL 
90c9			      ld    E, (HL) 
90c9			      inc   HL 
90c9			      ld    D, (HL) 
90c9			 
90c9			      pop   HL                      ; Add sizes of both blocks 
90c9			      add   HL, DE 
90c9			      ex    DE, HL 
90c9			 
90c9			      ld    L, (IX+2)               ; Store new bigger size into prev block 
90c9			      ld    H, (IX+3) 
90c9			      inc   HL 
90c9			      inc   HL 
90c9			      ld    (HL), E 
90c9			      inc   HL 
90c9			      ld    (HL), D 
90c9			 
90c9			free_done: 
90c9			      ld    HL, 4                   ; Clean up stack frame 
90c9			      add   HL, SP 
90c9			      ld    SP, HL 
90c9			 
90c9			free_early_exit: 
90c9			      pop   IX 
90c9			      pop   DE 
90c9			      pop   BC 
90c9			 
90c9			      ret 
90c9			 
90c9			 
90c9			;      .org 0x8000 
90c9			; 
90c9			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
90c9			 ;                 .dw   0 
90c9			 
90c9			endif 
90c9			 
90c9			 
90c9			if MALLOC_4 
90c9			 
90c9			; My memory allocation code. Very very simple.... 
90c9			; allocate space under 250 chars 
90c9			 
90c9			heap_init: 
90c9				; init start of heap as zero 
90c9				;  
90c9			 
90c9				ld hl, heap_start 
90c9				ld a, 0 
90c9				ld (hl), a      ; empty block 
90c9				inc hl 
90c9				ld a, 0 
90c9				ld (hl), a      ; length of block 
90c9				; write end of list 
90c9				inc hl 
90c9				ld a,(hl) 
90c9				inc hl 
90c9				ld a,(hl) 
90c9				 
90c9			 
90c9				; init some malloc vars 
90c9			 
90c9				ld hl, 0 
90c9				ld (free_list), hl       ; store last malloc location 
90c9			 
90c9				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
90c9				ld a, 0 
90c9				ld (hl), a 
90c9			 
90c9			 
90c9				ld hl, heap_start 
90c9				;  
90c9				  
90c9				ret 
90c9			 
90c9			 
90c9			;    free block marker 
90c9			;    requested size  
90c9			;    pointer to next block 
90c9			;    .... 
90c9			;    next block marker 
90c9			 
90c9			 
90c9			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
90c9			; 
90c9			 
90c9			 
90c9			malloc:  
90c9				push de 
90c9				push bc 
90c9				push af 
90c9			 
90c9				; hl space required 
90c9				 
90c9				ld c, l    ; hold space   (TODO only a max of 255) 
90c9			 
90c9			;	inc c     ; TODO BUG need to fix memory leak on push str 
90c9			;	inc c 
90c9			;	inc c 
90c9			;	inc c 
90c9			;	inc c 
90c9			;	inc c 
90c9			;	inc c 
90c9			 
90c9			 
90c9			 
90c9				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
90c9			 
90c9				ld a, (free_list+3) 
90c9				cp 0 
90c9				jr z, .contheap 
90c9			 
90c9				ld hl, (free_list)     ; get last alloc 
90c9					if DEBUG_FORTH_MALLOC_INT 
90c9						DMARK "mrs" 
90c9						CALLMONITOR 
90c9					endif 
90c9				jr .startalloc 
90c9			 
90c9			.contheap: 
90c9				ld hl, heap_start 
90c9			 
90c9			.startalloc: 
90c9			 
90c9					if DEBUG_FORTH_MALLOC_INT 
90c9						DMARK "mym" 
90c9						CALLMONITOR 
90c9					endif 
90c9			.findblock: 
90c9					if DEBUG_FORTH_MALLOC_INT 
90c9						DMARK "mmf" 
90c9						CALLMONITOR 
90c9					endif 
90c9			 
90c9				ld a,(hl)  
90c9				; if byte is zero then clear to use 
90c9			 
90c9				cp 0 
90c9				jr z, .foundemptyblock 
90c9			 
90c9				; if byte is not clear 
90c9				;     then byte is offset to next block 
90c9			 
90c9				inc hl 
90c9				ld a, (hl) ; get size 
90c9			.nextblock:	inc hl 
90c9					ld e, (hl) 
90c9					inc hl 
90c9					ld d, (hl) 
90c9					ex de, hl 
90c9			;	inc hl  ; move past the store space 
90c9			;	inc hl  ; move past zero index  
90c9			 
90c9				; TODO detect no more space 
90c9			 
90c9				push hl 
90c9				ld de, heap_end 
90c9				call cmp16 
90c9				pop hl 
90c9				jr nc, .nospace 
90c9			 
90c9				jr .findblock 
90c9			 
90c9			.nospace: ld hl, 0 
90c9				jp .exit 
90c9			 
90c9			 
90c9			.foundemptyblock:	 
90c9					if DEBUG_FORTH_MALLOC_INT 
90c9						DMARK "mme" 
90c9						CALLMONITOR 
90c9					endif 
90c9			 
90c9			; TODO has block enough space if reusing??? 
90c9			 
90c9				;  
90c9			 
90c9			; see if this block has been previously used 
90c9				inc hl 
90c9				ld a, (hl) 
90c9				dec hl 
90c9				cp 0 
90c9				jr z, .newblock 
90c9			 
90c9					if DEBUG_FORTH_MALLOC_INT 
90c9						DMARK "meR" 
90c9						CALLMONITOR 
90c9					endif 
90c9			 
90c9			; no reusing previously allocated block 
90c9			 
90c9			; is it smaller than previously used? 
90c9				 
90c9				inc hl    ; move to size 
90c9				ld a, c 
90c9				sub (hl)        ; we want c < (hl) 
90c9				dec hl    ; move back to marker 
90c9			        jr z, .findblock 
90c9			 
90c9				; update with the new size which should be lower 
90c9			 
90c9			        ;inc  hl   ; negate next move. move back to size  
90c9			 
90c9			.newblock: 
90c9				; need to be at marker here 
90c9			 
90c9					if DEBUG_FORTH_MALLOC_INT 
90c9						DMARK "meN" 
90c9						CALLMONITOR 
90c9					endif 
90c9			 
90c9			 
90c9				ld a, c 
90c9			 
90c9				ld (free_list+3), a	 ; flag resume from last malloc  
90c9				ld (free_list), hl    ; save out last location 
90c9			 
90c9			 
90c9				;inc a     ; space for length byte 
90c9				ld (hl), a     ; save block in use marker 
90c9			 
90c9				inc hl   ; move to space marker 
90c9				ld (hl), a    ; save new space 
90c9			 
90c9				inc hl   ; move to start of allocated area 
90c9				 
90c9			;	push hl     ; save where we are - 1  
90c9			 
90c9			;	inc hl  ; move past zero index  
90c9				; skip space to set down new marker 
90c9			 
90c9				; provide some extra space for now 
90c9			 
90c9				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
90c9				inc a 
90c9				inc a 
90c9			 
90c9				push hl   ; save where we are in the node block 
90c9			 
90c9				call addatohl 
90c9			 
90c9				; write linked list point 
90c9			 
90c9				pop de     ; get our node position 
90c9				ex de, hl 
90c9			 
90c9				ld (hl), e 
90c9				inc hl 
90c9				ld (hl), d 
90c9			 
90c9				inc hl 
90c9			 
90c9				; now at start of allocated data so save pointer 
90c9			 
90c9				push hl 
90c9			 
90c9				; jump to position of next node and setup empty header in DE 
90c9			 
90c9				ex de, hl 
90c9			 
90c9			;	inc hl ; move past end of block 
90c9			 
90c9				ld a, 0 
90c9				ld (hl), a   ; empty marker 
90c9				inc hl 
90c9				ld (hl), a   ; size 
90c9				inc hl  
90c9				ld (hl), a   ; ptr 
90c9				inc hl 
90c9				ld (hl), a   ; ptr 
90c9			 
90c9			 
90c9				pop hl 
90c9			 
90c9					if DEBUG_FORTH_MALLOC_INT 
90c9						DMARK "mmr" 
90c9						CALLMONITOR 
90c9					endif 
90c9			 
90c9			.exit: 
90c9				pop af 
90c9				pop bc 
90c9				pop de  
90c9				ret 
90c9			 
90c9			 
90c9			 
90c9			 
90c9			free:  
90c9				push hl 
90c9				push af 
90c9				; get address in hl 
90c9			 
90c9					if DEBUG_FORTH_MALLOC_INT 
90c9						DMARK "fre" 
90c9						CALLMONITOR 
90c9					endif 
90c9				; data is at hl - move to block count 
90c9				dec hl 
90c9				dec hl    ; get past pointer 
90c9				dec hl 
90c9			 
90c9				ld a, (hl)    ; need this for a validation check 
90c9			 
90c9				dec hl    ; move to block marker 
90c9			 
90c9				; now check that the block count and block marker are the same  
90c9			        ; this checks that we are on a malloc node and not random memory 
90c9			        ; OK a faint chance this could be a problem but rare - famous last words! 
90c9			 
90c9				ld c, a 
90c9				ld a, (hl)    
90c9			 
90c9				cp c 
90c9				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
90c9			 
90c9				; yes good chance we are on a malloc node 
90c9			 
90c9				ld a, 0      
90c9				ld (hl), a   ; mark as free 
90c9			 
90c9				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
90c9			 
90c9			.freeignore:  
90c9			 
90c9				pop af 
90c9				pop hl 
90c9			 
90c9				ret 
90c9			 
90c9			 
90c9			 
90c9			endif 
90c9			 
90c9			; eof 
# End of file firmware_memory.asm
90c9			  
90c9			; device C  
90c9			if SOUND_ENABLE  
90c9				include "firmware_sound.asm"  
90c9			endif  
90c9			  
90c9			include "firmware_diags.asm"  
90c9			; Hardware diags menu 
90c9			 
90c9			 
90c9			config: 
90c9			 
90c9 3e 00			ld a, 0 
90cb 21 ea 90			ld hl, .configmn 
90ce cd 6d 88			call menu 
90d1			 
90d1 fe 00			cp 0 
90d3 c8				ret z 
90d4			 
90d4 fe 01			cp 1 
90d6 cc 71 91			call z, .savetostore 
90d9			 
90d9 fe 03			cp 3 
90db cc 70 91			call z, .selbank 
90de fe 05			cp 5 
90e0 cc 72 91			call z, .debug_tog 
90e3 fe 06			cp 6 
90e5 cc 98 91			call z, hardware_diags 
90e8			 
90e8 18 df			jr config 
90ea			 
90ea			.configmn: 
90ea f8 90			dw .c3 
90ec 14 91			dw .c2 
90ee 29 91			dw .c2b 
90f0 3d 91			dw .c4 
90f2 46 91			dw .m4 
90f4 61 91			dw .c1 
90f6 00 00			dw 0 
90f8				 
90f8			 
90f8 .. 00		.c3: db "Add User Dictionary To File",0 
9114 .. 00		.c2: db "Select Autoload File",0 
9129 .. 00		.c2b: db "Select Storage Bank",0 
913d .. 00		.c4: db "Settings",0 
9146 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
9161 .. 00		.c1: db "Hardware Diags",0 
9170			 
9170			; Select storage bank 
9170			 
9170			.selbank: 
9170			 
9170				if STORAGE_SE 
9170				endif 
9170				 
9170 c9				ret 
9171			 
9171			if STORAGE_SE 
9171			 
9171			.config_ldir:   
9171				; Load storage bank labels into menu array 
9171			 
9171				 
9171			 
9171			 
9171				ret 
9171			 
9171			 
9171			endif 
9171			 
9171			 
9171			; Save user words to storage 
9171			 
9171			.savetostore: 
9171			 
9171				if STORAGE_SE 
9171			 
9171					call config_dir 
9171				        ld hl, scratch 
9171					ld a, 0 
9171					call menu 
9171					 
9171					ld hl, scratch 
9171					call config_fdir 
9171			 
9171			 
9171				endif 
9171			 
9171 c9				ret 
9172			 
9172			 
9172			 
9172			if STORAGE_SE 
9172			 
9172			config_fdir: 
9172				; using the scratch dir go through and release the memory allocated for each string 
9172				 
9172				ld hl, scratch 
9172			.cfdir:	ld e,(hl) 
9172				inc hl 
9172				ld d,(hl) 
9172				inc hl 
9172			 
9172				ex de, hl 
9172				call ishlzero 
9172				ret z     ; return on null pointer 
9172				call free 
9172				ex de, hl 
9172				jr .cfdir 
9172			 
9172			 
9172				ret 
9172			 
9172			 
9172			config_dir: 
9172			 
9172				; for the config menus that need to build a directory of storage call this routine 
9172				; it will construct a menu in scratch to pass to menu 
9172			 
9172				; open storage device 
9172			 
9172				; execute DIR to build a list of files and their ids into scratch in menu format 
9172				; once the menu has finished then will need to call config_fdir to release the strings 
9172				 
9172				; c = number items 
9172			 
9172				 
9172				call storage_get_block_0 
9172			 
9172				ld hl, store_page     ; get current id count 
9172				ld b, (hl) 
9172				ld c, 0    ; count of files   
9172			 
9172			 
9172				ld hl, scratch 
9172				ld (store_tmp2), hl    ; location to poke strings 
9172			 
9172				; check for empty drive 
9172			 
9172				ld a, 0 
9172				cp b 
9172				jp z, .dirdone 
9172			 
9172				 
9172					if DEBUG_FORTH_WORDS 
9172						DMARK "Cdc" 
9172						CALLMONITOR 
9172					endif 
9172			 
9172			 
9172			.diritem:	 
9172				push bc 
9172				; for each of the current ids do a search for them and if found push to stack 
9172			 
9172					ld hl, STORE_BLOCK_PHY 
9172					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9172					ld e,b 
9172			 
9172					call storage_findnextid 
9172			 
9172			 
9172					; if found hl will be non zero 
9172			 
9172					call ishlzero 
9172					jr z, .dirnotfound 
9172			 
9172					; increase count 
9172			 
9172					pop bc	 
9172					inc c 
9172					push bc 
9172					 
9172			 
9172					; get file header and push the file name 
9172			 
9172					ld de, store_page 
9172					call storage_read_block 
9172			 
9172					; push file id to stack 
9172				 
9172					ld a, (store_page) 
9172					ld h, 0 
9172					ld l, a 
9172			 
9172					;call forth_push_numhl 
9172					; TODO store id 
9172			 
9172					push hl 
9172			 
9172					; push extent count to stack  
9172				 
9172					ld hl, store_page+3 
9172			 
9172					; get file name length 
9172			 
9172					call strlenz   
9172			 
9172					inc hl   ; cover zero term 
9172					inc hl  ; stick the id at the end of the area 
9172			 
9172					push hl 
9172					pop bc    ; move length to bc 
9172			 
9172					call malloc 
9172			 
9172					; TODO save malloc area to scratch 
9172			 
9172					ex de, hl 
9172					ld hl, (store_tmp2) 
9172					ld (hl), e 
9172					inc hl 
9172					ld (hl), d 
9172					inc hl 
9172					ld (store_tmp2), hl 
9172			 
9172					 
9172			 
9172					;pop hl   ; get source 
9172			;		ex de, hl    ; swap aronund	 
9172			 
9172					ld hl, store_page+3 
9172					if DEBUG_FORTH_WORDS 
9172						DMARK "CFd" 
9172						CALLMONITOR 
9172					endif 
9172					ldir 
9172			 
9172					; de is past string, move back one and store id 
9172					 
9172					dec de 
9172			 
9172					; store file id 
9172			 
9172					pop hl 
9172					ex de,hl 
9172					ld (hl), e 
9172			 
9172					if DEBUG_FORTH_WORDS 
9172						DMARK "Cdi" 
9172						CALLMONITOR 
9172					endif 
9172					 
9172			.dirnotfound: 
9172					pop bc     
9172					djnz .diritem 
9172				 
9172			.dirdone:	 
9172			 
9172					ld a, 0 
9172					ld hl, (store_tmp2) 
9172					ld (hl), a 
9172					inc hl 
9172					ld (hl), a 
9172					inc hl 
9172					; push a count of the dir items found 
9172			 
9172			;		ld h, 0 
9172			;		ld l, c 
9172			 
9172				ret 
9172			 
9172			endif 
9172			 
9172			 
9172			; Settings 
9172			; Run  
9172			 
9172			 
9172			 
9172			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9172			;;hd_menu2:   db "        2: Editor",0   
9172			;hd_menu2:   db "        2: Editor       6: Menu",0   
9172			;hd_menu3:   db "        3: Storage",0 
9172			;hd_menu4:   db "0=quit  4: Debug",0 
9172			;hd_don:     db "ON",0 
9172			;hd_doff:     db "OFF",0 
9172			; 
9172			; 
9172			; 
9172			;hardware_diags_old:       
9172			; 
9172			;.diagmenu: 
9172			;	call clear_display 
9172			;	ld a, display_row_1 
9172			;	ld de, hd_menu1 
9172			;	call str_at_display 
9172			; 
9172			;	ld a, display_row_2 
9172			;	ld de, hd_menu2 
9172			;	call str_at_display 
9172			; 
9172			;	ld a, display_row_3 
9172			;	ld de, hd_menu3 
9172			;	call str_at_display 
9172			; 
9172			;	ld a,  display_row_4 
9172			;	ld de, hd_menu4 
9172			;	call str_at_display 
9172			; 
9172			;	; display debug state 
9172			; 
9172			;	ld de, hd_don 
9172			;	ld a, (os_view_disable) 
9172			;	cp 0 
9172			;	jr z, .distog 
9172			;	ld de, hd_doff 
9172			;.distog: ld a, display_row_4+17 
9172			;	call str_at_display 
9172			; 
9172			;	call update_display 
9172			; 
9172			;	call cin_wait 
9172			; 
9172			; 
9172			; 
9172			;	cp '4' 
9172			;	jr nz, .diagn1 
9172			; 
9172			;	; debug toggle 
9172			; 
9172			;	ld a, (os_view_disable) 
9172			;	ld b, '*' 
9172			;	cp 0 
9172			;	jr z, .debtog 
9172			;	ld b, 0 
9172			;.debtog:	 
9172			;	ld a,b 
9172			;	ld (os_view_disable),a 
9172			; 
9172			;.diagn1: cp '0' 
9172			;	 ret z 
9172			; 
9172			;;	cp '1' 
9172			;;       jp z, matrix	 
9172			;;   TODO keyboard matrix test 
9172			; 
9172			;	cp '2' 
9172			;	jp z, .diagedit 
9172			; 
9172			;;	cp '6' 
9172			;;	jp z, .menutest 
9172			;;if ENABLE_BASIC 
9172			;;	cp '6' 
9172			;;	jp z, basic 
9172			;;endif 
9172			 ; 
9172			;	jp .diagmenu 
9172			; 
9172			; 
9172			;	ret 
9172			 
9172			 
9172			.debug_tog: 
9172 21 b9 91			ld hl, .menudebug 
9175				 
9175 3a d7 e4			ld a, (os_view_disable) 
9178 fe 2a			cp '*' 
917a 20 04			jr nz,.tdon  
917c 3e 01			ld a, 1 
917e 18 02			jr .tog1 
9180 3e 00		.tdon: ld a, 0 
9182			 
9182			.tog1: 
9182 cd 6d 88			call menu 
9185 fe 00			cp 0 
9187 c8				ret z 
9188 fe 01			cp 1    ; disable debug 
918a 28 04			jr z, .dtog0 
918c 3e 2a			ld a, '*' 
918e 18 02			jr .dtogset 
9190 3e 00		.dtog0: ld a, 0 
9192 32 d7 e4		.dtogset:  ld (os_view_disable), a 
9195 c3 72 91			jp .debug_tog 
9198			 
9198			 
9198			hardware_diags:       
9198			 
9198			.diagm: 
9198 21 ab 91			ld hl, .menuitems 
919b 3e 00			ld a, 0 
919d cd 6d 88			call menu 
91a0			 
91a0 fe 00		         cp 0 
91a2 c8				 ret z 
91a3			 
91a3 fe 02			cp 2 
91a5 ca 04 92			jp z, .diagedit 
91a8			 
91a8			;	cp '6' 
91a8			;	jp z, .menutest 
91a8			;if ENABLE_BASIC 
91a8			;	cp '6' 
91a8			;	jp z, basic 
91a8			;endif 
91a8			  
91a8 c3 98 91			jp .diagm 
91ab			 
91ab				 
91ab bf 91		.menuitems:   	dw .m1 
91ad ca 91				dw .m2 
91af d1 91				dw .m3 
91b1 d9 91				dw .m5 
91b3 df 91				dw .m5a 
91b5 e8 91				dw .m5b 
91b7 00 00				dw 0 
91b9			 
91b9			.menudebug: 
91b9 f1 91				dw .m6 
91bb fa 91				dw .m7 
91bd 00 00				dw 0 
91bf			 
91bf .. 00		.m1:   db "Key Matrix",0 
91ca .. 00		.m2:   db "Editor",0 
91d1 .. 00		.m3:   db "Storage",0 
91d9 .. 00		.m5:   db "Sound",0 
91df .. 00		.m5a:  db "RAM Test",0 
91e8 .. 00		.m5b:  db "LCD Test",0 
91f1			 
91f1 .. 00		.m6:   db "Debug ON",0 
91fa .. 00		.m7:   db "Debug OFF",0 
9204			 
9204			; debug editor 
9204			 
9204			.diagedit: 
9204			 
9204 21 e6 e4			ld hl, scratch 
9207			;	ld bc, 250 
9207			;	ldir 
9207				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9207 3e 00			ld a, 0 
9209 77				ld (hl), a 
920a 23				inc hl 
920b 77				ld (hl), a 
920c 23				inc hl 
920d 77				ld (hl), a 
920e			 
920e cd 3c 88		        call clear_display 
9211 cd 5f 88			call update_display 
9214 3e 01			ld a, 1 
9216 32 c6 ee			ld (hardware_diag), a 
9219			.diloop: 
9219 3e 00			ld a, display_row_1 
921b 0e 00			ld c, 0 
921d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
921f 1e 28			ld e, 40 
9221			 
9221 21 e6 e4			ld hl, scratch	 
9224 cd 96 8a			call input_str 
9227			 
9227 3e 14			ld a, display_row_2 
9229 11 e6 e4			ld de, scratch 
922c cd 4f 88			call str_at_display 
922f cd 5f 88			call update_display 
9232			 
9232 c3 19 92			jp .diloop 
9235			 
9235			 
9235			; pass word in hl 
9235			; a has display location 
9235			display_word_at: 
9235 f5				push af 
9236 e5				push hl 
9237 7c				ld a,h 
9238 21 eb e7			ld hl, os_word_scratch 
923b cd 6a 8d			call hexout 
923e e1				pop hl 
923f 7d				ld a,l 
9240 21 ed e7			ld hl, os_word_scratch+2 
9243 cd 6a 8d			call hexout 
9246 21 ef e7			ld hl, os_word_scratch+4 
9249 3e 00			ld a,0 
924b 77				ld (hl),a 
924c 11 eb e7			ld de,os_word_scratch 
924f f1				pop af 
9250 cd 4f 88				call str_at_display 
9253 c9				ret 
9254			 
9254			display_ptr_state: 
9254			 
9254				; to restore afterwards 
9254			 
9254 d5				push de 
9255 c5				push bc 
9256 e5				push hl 
9257 f5				push af 
9258			 
9258				; for use in here 
9258			 
9258			;	push bc 
9258			;	push de 
9258			;	push hl 
9258			;	push af 
9258			 
9258 cd 3c 88			call clear_display 
925b			 
925b 11 2e 94			ld de, .ptrstate 
925e 3e 00			ld a, display_row_1 
9260 cd 4f 88			call str_at_display 
9263			 
9263				; display debug step 
9263			 
9263			 
9263 11 c0 ee			ld de, debug_mark 
9266 3e 12			ld a, display_row_1+display_cols-2 
9268 cd 4f 88			call str_at_display 
926b			 
926b				; display a 
926b 11 38 94			ld de, .ptrcliptr 
926e 3e 14			ld a, display_row_2 
9270 cd 4f 88			call str_at_display 
9273			 
9273 f1				pop af 
9274 2a b1 ec			ld hl,(cli_ptr) 
9277 3e 1c			ld a, display_row_2+8 
9279 cd 35 92			call display_word_at 
927c			 
927c			 
927c				; display hl 
927c			 
927c			 
927c 11 40 94			ld de, .ptrclioptr 
927f 3e 1e			ld a, display_row_2+10 
9281 cd 4f 88			call str_at_display 
9284			; 
9284			;	pop hl 
9284 3e 21			ld a, display_row_2+13 
9286 2a af ec			ld hl,(cli_origptr) 
9289 cd 35 92			call display_word_at 
928c			; 
928c			;	 
928c			;	; display de 
928c			 
928c			;	ld de, .regstatede 
928c			;	ld a, display_row_3 
928c			;	call str_at_display 
928c			 
928c			;	pop de 
928c			;	ld h,d 
928c			;	ld l, e 
928c			;	ld a, display_row_3+3 
928c			;	call display_word_at 
928c			 
928c			 
928c				; display bc 
928c			 
928c			;	ld de, .regstatebc 
928c			;	ld a, display_row_3+10 
928c			;	call str_at_display 
928c			 
928c			;	pop bc 
928c			;	ld h,b 
928c			;	ld l, c 
928c			;	ld a, display_row_3+13 
928c			;	call display_word_at 
928c			 
928c			 
928c				; display dsp 
928c			 
928c			;	ld de, .regstatedsp 
928c			;	ld a, display_row_4 
928c			;	call str_at_display 
928c			 
928c				 
928c			;	ld hl,(cli_data_sp) 
928c			;	ld a, display_row_4+4 
928c			;	call display_word_at 
928c			 
928c				; display rsp 
928c			 
928c 11 6f 94			ld de, .regstatersp 
928f 3e 46			ld a, display_row_4+10 
9291 cd 4f 88			call str_at_display 
9294			 
9294				 
9294 2a 97 ec			ld hl,(cli_ret_sp) 
9297 3e 4a			ld a, display_row_4+14 
9299 cd 35 92			call display_word_at 
929c			 
929c cd 5f 88			call update_display 
929f			 
929f cd ea 87			call delay1s 
92a2 cd ea 87			call delay1s 
92a5 cd ea 87			call delay1s 
92a8			 
92a8			 
92a8 cd b5 97			call next_page_prompt 
92ab			 
92ab				; restore  
92ab			 
92ab f1				pop af 
92ac e1				pop hl 
92ad c1				pop bc 
92ae d1				pop de 
92af c9				ret 
92b0			 
92b0			break_point_state: 
92b0 f5				push af 
92b1			 
92b1				; see if disabled 
92b1			 
92b1 3a d7 e4			ld a, (os_view_disable) 
92b4 fe 2a			cp '*' 
92b6 20 02			jr nz, .bpsgo 
92b8 f1				pop af 
92b9 c9				ret 
92ba			 
92ba			.bpsgo: 
92ba f1				pop af 
92bb f5				push af 
92bc 22 d3 e4			ld (os_view_hl), hl 
92bf ed 53 d1 e4		ld (os_view_de), de 
92c3 ed 43 cf e4		ld (os_view_bc), bc 
92c7 e5				push hl 
92c8 6f				ld l, a 
92c9 26 00			ld h, 0 
92cb 22 d5 e4			ld (os_view_af),hl 
92ce			 
92ce 21 56 ee				ld hl, display_fb0 
92d1 22 61 ed				ld (display_fb_active), hl 
92d4 e1				pop hl	 
92d5			 
92d5 3e 31			ld a, '1' 
92d7 fe 2a		.bps1:  cp '*' 
92d9 20 03			jr nz, .bps1b 
92db 32 d7 e4			ld (os_view_disable),a 
92de fe 31		.bps1b:  cp '1' 
92e0 20 14			jr nz, .bps2 
92e2			 
92e2				; display reg 
92e2			 
92e2				 
92e2			 
92e2 3a d5 e4			ld a, (os_view_af) 
92e5 2a d3 e4			ld hl, (os_view_hl) 
92e8 ed 5b d1 e4		ld de, (os_view_de) 
92ec ed 4b cf e4		ld bc, (os_view_bc) 
92f0 cd 8a 93			call display_reg_state 
92f3 c3 76 93			jp .bpschk 
92f6			 
92f6 fe 32		.bps2:  cp '2' 
92f8 20 08			jr nz, .bps3 
92fa				 
92fa				; display hl 
92fa 2a d3 e4			ld hl, (os_view_hl) 
92fd cd 74 94			call display_dump_at_hl 
9300			 
9300 18 74			jr .bpschk 
9302			 
9302 fe 33		.bps3:  cp '3' 
9304 20 08			jr nz, .bps4 
9306			 
9306			        ; display de 
9306 2a d1 e4			ld hl, (os_view_de) 
9309 cd 74 94			call display_dump_at_hl 
930c			 
930c 18 68			jr .bpschk 
930e fe 34		.bps4:  cp '4' 
9310 20 08			jr nz, .bps5 
9312			 
9312			        ; display bc 
9312 2a cf e4			ld hl, (os_view_bc) 
9315 cd 74 94			call display_dump_at_hl 
9318			 
9318 18 5c			jr .bpschk 
931a fe 35		.bps5:  cp '5' 
931c 20 08		        jr nz, .bps7 
931e			 
931e				; display cur ptr 
931e 2a b1 ec			ld hl, (cli_ptr) 
9321 cd 74 94			call display_dump_at_hl 
9324			 
9324 18 50			jr .bpschk 
9326 fe 36		.bps7:  cp '6' 
9328 20 08			jr nz, .bps8b 
932a				 
932a				; display cur orig ptr 
932a 2a af ec			ld hl, (cli_origptr) 
932d cd 74 94			call display_dump_at_hl 
9330 18 44			jr .bpschk 
9332 fe 37		.bps8b:  cp '7' 
9334 20 08			jr nz, .bps9 
9336				 
9336				; display dsp 
9336 2a 93 ec			ld hl, (cli_data_sp) 
9339 cd 74 94			call display_dump_at_hl 
933c			 
933c 18 38			jr .bpschk 
933e fe 39		.bps9:  cp '9' 
9340 20 05			jr nz, .bps8c 
9342				 
9342				; display SP 
9342			;	ld hl, sp 
9342 cd 74 94			call display_dump_at_hl 
9345			 
9345 18 2f			jr .bpschk 
9347 fe 38		.bps8c:  cp '8' 
9349 20 08			jr nz, .bps8d 
934b				 
934b				; display rsp 
934b 2a 97 ec			ld hl, (cli_ret_sp) 
934e cd 74 94			call display_dump_at_hl 
9351			 
9351 18 23			jr .bpschk 
9353 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9355 20 05			jr nz, .bps8 
9357 cd ab 95			call monitor 
935a			 
935a 18 1a			jr .bpschk 
935c fe 30		.bps8:  cp '0' 
935e 20 16			jr nz, .bpschk 
9360			 
9360 21 05 ee				ld hl, display_fb1 
9363 22 61 ed				ld (display_fb_active), hl 
9366 cd 5f 88				call update_display 
9369			 
9369				;ld a, (os_view_af) 
9369 2a d3 e4			ld hl, (os_view_hl) 
936c ed 5b d1 e4		ld de, (os_view_de) 
9370 ed 4b cf e4		ld bc, (os_view_bc) 
9374 f1				pop af 
9375 c9				ret 
9376			 
9376			.bpschk:   
9376 cd ea 87			call delay1s 
9379 3e 4f		ld a,display_row_4 + display_cols - 1 
937b 11 b3 97		        ld de, endprg 
937e cd 4f 88			call str_at_display 
9381 cd 5f 88			call update_display 
9384 cd 1b d8			call cin_wait 
9387			 
9387 c3 d7 92			jp .bps1 
938a			 
938a			 
938a			display_reg_state: 
938a			 
938a				; to restore afterwards 
938a			 
938a d5				push de 
938b c5				push bc 
938c e5				push hl 
938d f5				push af 
938e			 
938e				; for use in here 
938e			 
938e c5				push bc 
938f d5				push de 
9390 e5				push hl 
9391 f5				push af 
9392			 
9392 cd 3c 88			call clear_display 
9395			 
9395 11 4a 94			ld de, .regstate 
9398 3e 00			ld a, display_row_1 
939a cd 4f 88			call str_at_display 
939d			 
939d				; display debug step 
939d			 
939d			 
939d 11 c0 ee			ld de, debug_mark 
93a0 3e 11			ld a, display_row_1+display_cols-3 
93a2 cd 4f 88			call str_at_display 
93a5			 
93a5				; display a 
93a5 11 66 94			ld de, .regstatea 
93a8 3e 14			ld a, display_row_2 
93aa cd 4f 88			call str_at_display 
93ad			 
93ad e1				pop hl 
93ae			;	ld h,0 
93ae			;	ld l, a 
93ae 3e 17			ld a, display_row_2+3 
93b0 cd 35 92			call display_word_at 
93b3			 
93b3			 
93b3				; display hl 
93b3			 
93b3			 
93b3 11 5a 94			ld de, .regstatehl 
93b6 3e 1e			ld a, display_row_2+10 
93b8 cd 4f 88			call str_at_display 
93bb			 
93bb e1				pop hl 
93bc 3e 21			ld a, display_row_2+13 
93be cd 35 92			call display_word_at 
93c1			 
93c1				 
93c1				; display de 
93c1			 
93c1 11 5e 94			ld de, .regstatede 
93c4 3e 28			ld a, display_row_3 
93c6 cd 4f 88			call str_at_display 
93c9			 
93c9 e1				pop hl 
93ca			;	ld h,d 
93ca			;	ld l, e 
93ca 3e 2b			ld a, display_row_3+3 
93cc cd 35 92			call display_word_at 
93cf			 
93cf			 
93cf				; display bc 
93cf			 
93cf 11 62 94			ld de, .regstatebc 
93d2 3e 32			ld a, display_row_3+10 
93d4 cd 4f 88			call str_at_display 
93d7			 
93d7 e1				pop hl 
93d8			;	ld h,b 
93d8			;	ld l, c 
93d8 3e 35			ld a, display_row_3+13 
93da cd 35 92			call display_word_at 
93dd			 
93dd			 
93dd				; display dsp 
93dd			 
93dd 11 6a 94			ld de, .regstatedsp 
93e0 3e 3c			ld a, display_row_4 
93e2 cd 4f 88			call str_at_display 
93e5			 
93e5				 
93e5 2a 93 ec			ld hl,(cli_data_sp) 
93e8 3e 40			ld a, display_row_4+4 
93ea cd 35 92			call display_word_at 
93ed			 
93ed				; display rsp 
93ed			 
93ed 11 6f 94			ld de, .regstatersp 
93f0 3e 46			ld a, display_row_4+10 
93f2 cd 4f 88			call str_at_display 
93f5			 
93f5				 
93f5 2a 97 ec			ld hl,(cli_ret_sp) 
93f8 3e 4a			ld a, display_row_4+14 
93fa cd 35 92			call display_word_at 
93fd			 
93fd cd 5f 88			call update_display 
9400			 
9400			;	call delay1s 
9400			;	call delay1s 
9400			;	call delay1s 
9400			 
9400			 
9400			;	call next_page_prompt 
9400			 
9400				; restore  
9400			 
9400 f1				pop af 
9401 e1				pop hl 
9402 c1				pop bc 
9403 d1				pop de 
9404 c9				ret 
9405			 
9405 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9419 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
942e .. 00		.ptrstate:	db "Ptr State",0 
9438 .. 00		.ptrcliptr:     db "cli_ptr",0 
9440 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
944a .. 00		.regstate:	db "Reg State (1/0)",0 
945a .. 00		.regstatehl:	db "HL:",0 
945e .. 00		.regstatede:	db "DE:",0 
9462 .. 00		.regstatebc:	db "BC:",0 
9466 .. 00		.regstatea:	db "A :",0 
946a .. 00		.regstatedsp:	db "DSP:",0 
946f .. 00		.regstatersp:	db "RSP:",0 
9474			 
9474			display_dump_at_hl: 
9474 e5				push hl 
9475 d5				push de 
9476 c5				push bc 
9477 f5				push af 
9478			 
9478 22 09 e8			ld (os_cur_ptr),hl	 
947b cd 3c 88			call clear_display 
947e cd bd 96			call dumpcont 
9481			;	call delay1s 
9481			;	call next_page_prompt 
9481			 
9481			 
9481 f1				pop af 
9482 c1				pop bc 
9483 d1				pop de 
9484 e1				pop hl 
9485 c9				ret 
9486			 
9486			;if ENABLE_BASIC 
9486			;	include "nascombasic.asm" 
9486			;	basic: 
9486			;	include "forth/FORTH.ASM" 
9486			;endif 
9486			 
9486			; eof 
9486			 
9486			 
# End of file firmware_diags.asm
9486			  
9486			  
9486			  
9486			  
9486			; eof  
9486			  
# End of file firmware.asm
9486			 
9486			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9486			;if BASE_KEV  
9486			;baseram: equ 08000h 
9486			;endif 
9486			 
9486			;if BASE_SC114 
9486			;baseram:     equ    endofcode 
9486			;endif 
9486			 
9486			 
9486			; start system 
9486			 
9486			coldstart: 
9486				; set sp 
9486				; di/ei 
9486			 
9486 f3				di 
9487 31 00 f0			ld sp, tos 
948a			;	ei 
948a			 
948a			 
948a				; disable breakpoint by default 
948a			 
948a 3e 2a			ld a,'*' 
948c 32 d7 e4			ld (os_view_disable),a 
948f			 
948f				; init hardware 
948f			 
948f				; init keyboard and screen hardware 
948f			 
948f cd 03 80			call hardware_init 
9492			 
9492			 
9492				; detect if any keys are held down to enable breakpoints at start up 
9492			 
9492 cd 21 d8			call cin  
9495 fe 00			cp 0 
9497 28 03			jr z, .nokeys 
9499			 
9499				;call hardware_diags 
9499 cd c9 90			call config 
949c			 
949c			;	ld de, .bpen 
949c			;	ld a, display_row_4 
949c			;	call str_at_display 
949c			;	call update_display 
949c			; 
949c			;	ld a,0 
949c			;	ld (os_view_disable),a 
949c			; 
949c			;.bpwait: 
949c			;	call cin 
949c			;	cp 0 
949c			;	jr z, .bpwait 
949c			;	jr .nokeys 
949c			; 
949c			; 
949c			;.bpen:  db "Break points enabled!",0 
949c			 
949c			 
949c			 
949c			 
949c			 
949c			 
949c			.nokeys: 
949c			 
949c			 
949c				 
949c			 
949c			;jp  testkey 
949c			 
949c			;call storage_get_block_0 
949c			; 
949c			;ld hl, 0 
949c			;ld de, store_page 
949c			;call storage_read_block 
949c			 
949c				 
949c			;ld hl, 10 
949c			;ld de, store_page 
949c			;call storage_read_block 
949c			 
949c			 
949c			 
949c			 
949c			 
949c			;stop:	nop 
949c			;	jp stop 
949c			 
949c			 
949c			 
949c			main: 
949c cd 3c 88			call clear_display 
949f cd 5f 88			call update_display 
94a2			 
94a2			 
94a2			 
94a2			;	call testlcd 
94a2			 
94a2			 
94a2			 
94a2 cd 7b 9b			call forth_init 
94a5			 
94a5			 
94a5			warmstart: 
94a5 cd 51 9b			call forth_warmstart 
94a8			 
94a8				; run startup word load 
94a8			        ; TODO prevent this running at warmstart after crash  
94a8			 
94a8				if STARTUP_ENABLE 
94a8 cd b5 d4				call forth_startup 
94ab				endif 
94ab			 
94ab				; show free memory after boot 
94ab 11 45 95			ld de, freeram 
94ae 3e 00			ld a, display_row_1 
94b0 cd 4f 88			call str_at_display 
94b3			 
94b3			; Or use heap_size word???? 
94b3 21 cc e4			ld hl, heap_end 
94b6 11 3f d8			ld de, heap_start 
94b9 ed 52			sbc hl, de 
94bb e5				push hl 
94bc 7c				ld a,h	         	 
94bd 21 eb e7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
94c0 cd 6a 8d			call hexout 
94c3 e1			   	pop hl 
94c4			 
94c4 7d				ld a,l 
94c5 21 ed e7			ld hl, os_word_scratch+2 
94c8 cd 6a 8d			call hexout 
94cb 21 ef e7			ld hl, os_word_scratch+4 
94ce 3e 00			ld a, 0 
94d0 77				ld (hl),a 
94d1 11 eb e7			ld de, os_word_scratch 
94d4 3e 0d			ld a, display_row_1 + 13 
94d6 cd 4f 88			call str_at_display 
94d9 cd 5f 88			call update_display 
94dc			 
94dc			 
94dc				;call demo 
94dc			 
94dc			 
94dc				; init scratch input area for cli commands 
94dc			 
94dc 21 0d e8			ld hl, os_cli_cmd 
94df 3e 00			ld a,0 
94e1 77				ld (hl),a 
94e2 23				inc hl 
94e3 77				ld (hl),a 
94e4			 
94e4 3e 00			ld a,0 
94e6 32 0c e9			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
94e9			 
94e9 32 09 e8			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
94ec 32 0a e8			ld (os_cur_ptr+1),a	 
94ef			 
94ef 32 eb e7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
94f2 32 ec e7			ld (os_word_scratch+1),a	 
94f5				 
94f5			 
94f5				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
94f5 21 0d e8			ld hl, os_cli_cmd 
94f8			 
94f8 3e 00			ld a, 0		 ; init cli input 
94fa 77				ld (hl), a 
94fb 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
94fd			cli: 
94fd				; show cli prompt 
94fd				;push af 
94fd				;ld a, 0 
94fd				;ld de, prompt 
94fd				;call str_at_display 
94fd			 
94fd				;call update_display 
94fd				;pop af 
94fd				;inc a 
94fd				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
94fd 0e 00			ld c, 0 
94ff 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9501 1e 28			ld e, 40 
9503			 
9503 21 0d e8			ld hl, os_cli_cmd 
9506			 
9506				STACKFRAME OFF $fefe $9f9f 
9506				if DEBUG_STACK_IMB 
9506					if OFF 
9506						exx 
9506						ld de, $fefe 
9506						ld a, d 
9506						ld hl, curframe 
9506						call hexout 
9506						ld a, e 
9506						ld hl, curframe+2 
9506						call hexout 
9506						ld hl, $fefe 
9506						push hl 
9506						ld hl, $9f9f 
9506						push hl 
9506						exx 
9506					endif 
9506				endif 
9506			endm 
# End of macro STACKFRAME
9506			 
9506 cd 96 8a			call input_str 
9509			 
9509				STACKFRAMECHK OFF $fefe $9f9f 
9509				if DEBUG_STACK_IMB 
9509					if OFF 
9509						exx 
9509						ld hl, $9f9f 
9509						pop de   ; $9f9f 
9509						call cmp16 
9509						jr nz, .spnosame 
9509						ld hl, $fefe 
9509						pop de   ; $fefe 
9509						call cmp16 
9509						jr z, .spfrsame 
9509						.spnosame: call showsperror 
9509						.spfrsame: nop 
9509						exx 
9509					endif 
9509				endif 
9509			endm 
# End of macro STACKFRAMECHK
9509			 
9509				; copy input to last command 
9509			 
9509 21 0d e8			ld hl, os_cli_cmd 
950c 11 0c e9			ld de, os_last_cmd 
950f 01 ff 00			ld bc, 255 
9512 ed b0			ldir 
9514			 
9514				; wipe current buffer 
9514			 
9514			;	ld a, 0 
9514			;	ld hl, os_cli_cmd 
9514			;	ld de, os_cli_cmd+1 
9514			;	ld bc, 254 
9514			;	ldir 
9514				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9514			;	call strcpy 
9514			;	ld a, 0 
9514			;	ld (hl), a 
9514			;	inc hl 
9514			;	ld (hl), a 
9514			;	inc hl 
9514			;	ld (hl), a 
9514			 
9514				; switch frame buffer to program  
9514			 
9514 21 05 ee				ld hl, display_fb1 
9517 22 61 ed				ld (display_fb_active), hl 
951a			 
951a			;	nop 
951a				STACKFRAME ON $fbfe $8f9f 
951a				if DEBUG_STACK_IMB 
951a					if ON 
951a						exx 
951a						ld de, $fbfe 
951a						ld a, d 
951a						ld hl, curframe 
951a						call hexout 
951a						ld a, e 
951a						ld hl, curframe+2 
951a						call hexout 
951a						ld hl, $fbfe 
951a						push hl 
951a						ld hl, $8f9f 
951a						push hl 
951a						exx 
951a					endif 
951a				endif 
951a			endm 
# End of macro STACKFRAME
951a				; first time into the parser so pass over the current scratch pad 
951a 21 0d e8			ld hl,os_cli_cmd 
951d				; tokenise the entered statement(s) in HL 
951d cd f4 9b			call forthparse 
9520			        ; exec forth statements in top of return stack 
9520 cd 34 9c			call forthexec 
9523				;call forthexec_cleanup 
9523			;	call parsenext 
9523			 
9523				STACKFRAMECHK ON $fbfe $8f9f 
9523				if DEBUG_STACK_IMB 
9523					if ON 
9523						exx 
9523						ld hl, $8f9f 
9523						pop de   ; $8f9f 
9523						call cmp16 
9523						jr nz, .spnosame 
9523						ld hl, $fbfe 
9523						pop de   ; $fbfe 
9523						call cmp16 
9523						jr z, .spfrsame 
9523						.spnosame: call showsperror 
9523						.spfrsame: nop 
9523						exx 
9523					endif 
9523				endif 
9523			endm 
# End of macro STACKFRAMECHK
9523				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9523			 
9523 3e 3c			ld a, display_row_4 
9525 11 57 95			ld de, endprog 
9528			 
9528 cd 5f 88			call update_display		 
952b			 
952b cd b5 97			call next_page_prompt 
952e			 
952e				; switch frame buffer to cli 
952e			 
952e 21 56 ee				ld hl, display_fb0 
9531 22 61 ed				ld (display_fb_active), hl 
9534			 
9534			 
9534 cd 3c 88		        call clear_display 
9537 cd 5f 88			call update_display		 
953a			 
953a 21 0d e8			ld hl, os_cli_cmd 
953d			 
953d 3e 00			ld a, 0		 ; init cli input 
953f 77				ld (hl), a 
9540			 
9540				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9540			 
9540				; now on last line 
9540			 
9540				; TODO scroll screen up 
9540			 
9540				; TODO instead just clear screen and place at top of screen 
9540			 
9540			;	ld a, 0 
9540			;	ld (f_cursor_ptr),a 
9540			 
9540				;call clear_display 
9540				;call update_display 
9540			 
9540				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9540 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9542 c3 fd 94			jp cli 
9545			 
9545 .. 00		freeram: db "Free bytes: $",0 
9553 ..			asc: db "1A2F" 
9557 .. 00		endprog: db "End prog...",0 
9563			 
9563			testenter2:   
9563 21 18 e5			ld hl,scratch+50 
9566 22 09 e8			ld (os_cur_ptr),hl 
9569 c3 fd 94			jp cli 
956c			 
956c			testenter:  
956c			 
956c 21 53 95			ld hl,asc 
956f			;	ld a,(hl) 
956f			;	call nibble2val 
956f cd c0 8d			call get_byte 
9572			 
9572			 
9572			;	ld a,(hl) 
9572			;	call atohex 
9572			 
9572			;	call fourehexhl 
9572 32 18 e5			ld (scratch+50),a 
9575			 
9575			 
9575			 
9575 21 55 95			ld hl,asc+2 
9578			;	ld a, (hl) 
9578			;	call nibble2val 
9578 cd c0 8d			call get_byte 
957b			 
957b			;	call fourehexhl 
957b 32 1a e5			ld (scratch+52),a 
957e				 
957e 21 18 e5			ld hl,scratch+50 
9581 22 09 e8			ld (os_cur_ptr),hl 
9584 c3 fd 94			jp cli 
9587			 
9587			enter:	 
9587 3a ea e4			ld a,(scratch+4) 
958a fe 00			cp 0 
958c 28 0c			jr z, .entercont 
958e				; no, not a null term line so has an address to work out.... 
958e			 
958e 21 e8 e4			ld hl,scratch+2 
9591 cd 20 8e			call get_word_hl 
9594			 
9594 22 09 e8			ld (os_cur_ptr),hl	 
9597 c3 fd 94			jp cli 
959a			 
959a			 
959a			.entercont:  
959a			 
959a 21 e8 e4			ld hl, scratch+2 
959d cd c0 8d			call get_byte 
95a0			 
95a0 2a 09 e8		   	ld hl,(os_cur_ptr) 
95a3 77					ld (hl),a 
95a4 23					inc hl 
95a5 22 09 e8				ld (os_cur_ptr),hl 
95a8				 
95a8			; get byte  
95a8			 
95a8			 
95a8 c3 fd 94			jp cli 
95ab			 
95ab			 
95ab			; basic monitor support 
95ab			 
95ab			monitor: 
95ab				;  
95ab cd 3c 88			call clear_display 
95ae 3e 00			ld a, 0 
95b0 11 f8 95			ld de, .monprompt 
95b3 cd 4f 88			call str_at_display 
95b6 cd 5f 88			call update_display 
95b9			 
95b9				; get a monitor command 
95b9			 
95b9 0e 00			ld c, 0     ; entry at top left 
95bb 16 64			ld d, 100   ; max buffer size 
95bd 1e 0f			ld e, 15    ; input scroll area 
95bf 3e 00			ld a, 0     ; init string 
95c1 21 e4 e6			ld hl, os_input 
95c4 77				ld (hl), a 
95c5 23				inc hl 
95c6 77				ld (hl), a 
95c7 21 e4 e6			ld hl, os_input 
95ca 3e 01			ld a, 1     ; init string 
95cc cd 96 8a			call input_str 
95cf			 
95cf cd 3c 88		        call clear_display 
95d2 cd 5f 88			call update_display		 
95d5			 
95d5 3a e4 e6			ld a, (os_input) 
95d8 cd be 8e			call toUpper 
95db fe 48		        cp 'H' 
95dd 28 6f		        jr z, .monhelp 
95df fe 44			cp 'D'		; dump 
95e1 ca 6f 96			jp z, .mondump	 
95e4 fe 43			cp 'C'		; dump 
95e6 ca 89 96			jp z, .moncdump	 
95e9 fe 4d			cp 'M'		; dump 
95eb ca fa 95			jp z, .moneditstart 
95ee fe 55			cp 'U'		; dump 
95f0 28 14			jr z, .monedit	 
95f2 fe 51			cp 'Q'		; dump 
95f4 c8				ret z	 
95f5			 
95f5			 
95f5				; TODO "S" to access symbol by name and not need the address 
95f5				; TODO "F" to find a string in memory 
95f5			 
95f5 c3 ab 95			jp monitor 
95f8			 
95f8 .. 00		.monprompt: db ">", 0 
95fa			 
95fa			.moneditstart: 
95fa				; get starting address 
95fa			 
95fa 21 e6 e6			ld hl,os_input+2 
95fd cd 20 8e			call get_word_hl 
9600			 
9600 22 09 e8			ld (os_cur_ptr),hl	 
9603			 
9603 c3 ab 95			jp monitor 
9606			 
9606			.monedit: 
9606				; get byte to load 
9606			 
9606 21 e6 e6			ld hl,os_input+2 
9609 cd c0 8d			call get_byte 
960c			 
960c				; get address to update 
960c 2a 09 e8			ld hl, (os_cur_ptr) 
960f			 
960f				; update byte 
960f			 
960f 77				ld (hl), a 
9610			 
9610				; move to next address and save it 
9610			 
9610 23				inc hl 
9611 22 09 e8			ld (os_cur_ptr),hl	 
9614			 
9614 c3 ab 95			jp monitor 
9617			 
9617			 
9617 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
962b .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9647 .. 00		.monhelptext3:  db "Q-Quit",0 
964e			        
964e			.monhelp: 
964e 3e 00			ld a, display_row_1 
9650 11 17 96		        ld de, .monhelptext1 
9653			 
9653 cd 4f 88			call str_at_display 
9656 3e 14			ld a, display_row_2 
9658 11 2b 96		        ld de, .monhelptext2 
965b					 
965b cd 4f 88			call str_at_display 
965e 3e 28			ld a, display_row_3 
9660 11 47 96		        ld de, .monhelptext3 
9663					 
9663 cd 4f 88			call str_at_display 
9666 cd 5f 88			call update_display		 
9669			 
9669 cd b5 97			call next_page_prompt 
966c c3 ab 95			jp monitor 
966f			 
966f			.mondump:    
966f 21 e6 e6			ld hl,os_input+2 
9672 cd 20 8e			call get_word_hl 
9675			 
9675 22 09 e8			ld (os_cur_ptr),hl	 
9678 cd bd 96			call dumpcont 
967b 3e 3c			ld a, display_row_4 
967d 11 57 95			ld de, endprog 
9680			 
9680 cd 5f 88			call update_display		 
9683			 
9683 cd b5 97			call next_page_prompt 
9686 c3 ab 95			jp monitor 
9689			.moncdump: 
9689 cd bd 96			call dumpcont 
968c 3e 3c			ld a, display_row_4 
968e 11 57 95			ld de, endprog 
9691			 
9691 cd 5f 88			call update_display		 
9694			 
9694 cd b5 97			call next_page_prompt 
9697 c3 ab 95			jp monitor 
969a			 
969a			 
969a			; TODO symbol access  
969a			 
969a			.symbols:     ;; A list of symbols that can be called up  
969a 56 ee			dw display_fb0 
969c .. 00			db "fb0",0  
96a0 eb ec		     	dw store_page 
96a2 .. 00			db "store_page",0 
96ad			 
96ad			 
96ad			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
96ad			 
96ad 3a e7 e4			ld a,(scratch+1) 
96b0 fe 00			cp 0 
96b2 28 09			jr z, dumpcont 
96b4			 
96b4				; no, not a null term line so has an address to work out.... 
96b4			 
96b4 21 e8 e4			ld hl,scratch+2 
96b7 cd 20 8e			call get_word_hl 
96ba			 
96ba 22 09 e8			ld (os_cur_ptr),hl	 
96bd			 
96bd			 
96bd			 
96bd			dumpcont: 
96bd			 
96bd				; dump bytes at ptr 
96bd			 
96bd			 
96bd 3e 00			ld a, display_row_1 
96bf 2a 61 ed			ld hl, (display_fb_active) 
96c2 cd 69 8a			call addatohl 
96c5 cd ed 96			call .dumpbyterow 
96c8			 
96c8 3e 14			ld a, display_row_2 
96ca 2a 61 ed			ld hl, (display_fb_active) 
96cd cd 69 8a			call addatohl 
96d0 cd ed 96			call .dumpbyterow 
96d3			 
96d3			 
96d3 3e 28			ld a, display_row_3 
96d5 2a 61 ed			ld hl, (display_fb_active) 
96d8 cd 69 8a			call addatohl 
96db cd ed 96			call .dumpbyterow 
96de			 
96de 3e 3c			ld a, display_row_4 
96e0 2a 61 ed			ld hl, (display_fb_active) 
96e3 cd 69 8a			call addatohl 
96e6 cd ed 96			call .dumpbyterow 
96e9			 
96e9 cd 5f 88			call update_display 
96ec			;		jp cli 
96ec c9				ret 
96ed			 
96ed			.dumpbyterow: 
96ed			 
96ed				;push af 
96ed			 
96ed e5				push hl 
96ee			 
96ee				; calc where to poke the ascii 
96ee			if display_cols == 20 
96ee 3e 10			ld a, 16 
96f0			else 
96f0				ld a, 31 
96f0			endif 
96f0			 
96f0 cd 69 8a			call addatohl 
96f3 22 eb e7			ld (os_word_scratch),hl  		; save pos for later 
96f6			 
96f6			 
96f6			; display decoding address 
96f6 2a 09 e8		   	ld hl,(os_cur_ptr) 
96f9			 
96f9 7c				ld a,h 
96fa e1				pop hl 
96fb e5				push hl 
96fc			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
96fc cd 6a 8d			call hexout 
96ff 2a 09 e8		   	ld hl,(os_cur_ptr) 
9702			 
9702 7d				ld a,l 
9703 e1				pop hl 
9704 23				inc hl 
9705 23				inc hl 
9706 e5				push hl 
9707			;	ld hl, os_word_scratch+2 
9707 cd 6a 8d			call hexout 
970a e1				pop hl 
970b 23				inc hl 
970c 23				inc hl 
970d				;ld hl, os_word_scratch+4 
970d 3e 3a			ld a, ':' 
970f 77				ld (hl),a 
9710 23				inc hl 
9711				;ld a, 0 
9711				;ld (hl),a 
9711				;ld de, os_word_scratch 
9711				;pop af 
9711				;push af 
9711			;		ld a, display_row_2 
9711			;		call str_at_display 
9711			;		call update_display 
9711			 
9711			 
9711			;pop af 
9711			;	add 5 
9711			 
9711			if display_cols == 20 
9711 06 04			ld b, 4 
9713			else 
9713				ld b, 8 
9713			endif	 
9713			 
9713			.dumpbyte: 
9713 c5				push bc 
9714 e5				push hl 
9715			 
9715			 
9715 2a 09 e8		   	ld hl,(os_cur_ptr) 
9718 7e					ld a,(hl) 
9719			 
9719					; poke the ascii to display 
9719 2a eb e7				ld hl,(os_word_scratch) 
971c 77					ld (hl),a 
971d 23					inc hl 
971e 22 eb e7				ld (os_word_scratch),hl 
9721			 
9721					 
9721			 
9721			 
9721 e1					pop hl 
9722 e5					push hl 
9723			 
9723 cd 6a 8d				call hexout 
9726			 
9726					 
9726 2a 09 e8		   	ld hl,(os_cur_ptr) 
9729 23				inc hl 
972a 22 09 e8		   	ld (os_cur_ptr),hl 
972d			 
972d e1					pop hl 
972e 23					inc hl 
972f 23					inc hl 
9730 23					inc hl 
9731			 
9731			 
9731			 
9731					;ld a,0 
9731					;ld (os_word_scratch+2),a 
9731					;pop af 
9731					;push af 
9731			 
9731					;ld de, os_word_scratch 
9731					;call str_at_display 
9731			;		call update_display 
9731			;		pop af 
9731 c1					pop bc 
9732 c6 03				add 3 
9734 10 dd			djnz .dumpbyte 
9736			 
9736				 
9736			 
9736 c9				ret 
9737			 
9737			jump:	 
9737			 
9737 21 e8 e4			ld hl,scratch+2 
973a cd 20 8e			call get_word_hl 
973d				;ld hl,(scratch+2) 
973d				;call fourehexhl 
973d			 
973d 22 09 e8			ld (os_cur_ptr),hl	 
9740			 
9740 e9				jp (hl) 
9741			 
9741			 
9741			 
9741			; TODO implement a basic monitor mode to start with 
9741			 
9741			 
9741			 
9741			 
9741			 
9741			 
9741			 
9741			 
9741			 
9741			; testing and demo code during development 
9741			 
9741			 
9741 .. 00		str1: db "Enter some text...",0 
9754 .. 00		clear: db "                    ",0 
9769			 
9769			demo: 
9769			 
9769			 
9769			 
9769			;	call update_display 
9769			 
9769				; init scratch input area for testing 
9769 21 e6 e4			ld hl, scratch	 
976c 3e 00			ld a,0 
976e 77				ld (hl),a 
976f			 
976f			 
976f 3e 14		            LD   A, display_row_2 
9771			;            CALL fLCD_Pos       ;Position cursor to location in A 
9771 11 41 97		            LD   DE, str1 
9774 cd 4f 88			call str_at_display 
9777			 
9777			;            CALL fLCD_Str       ;Display string pointed to by DE 
9777			cloop:	 
9777 3e 28		            LD   A, display_row_3 
9779			;            CALL fLCD_Pos       ;Position cursor to location in A 
9779 11 54 97		            LD   DE, clear 
977c			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
977c cd 4f 88				call str_at_display 
977f 3e 3c			ld a, display_row_4 
9781 11 b1 97			ld de, prompt 
9784			 
9784 cd 4f 88				call str_at_display 
9787 cd 5f 88			call update_display 
978a			 
978a 3e 3d			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
978c 16 0a			ld d, 10 
978e 21 e6 e4			ld hl, scratch	 
9791 cd 96 8a			call input_str 
9794			 
9794			;	call clear_display 
9794			;'	call update_display 
9794			 
9794 3e 00		            LD   A, display_row_1 
9796			;            CALL fLCD_Pos       ;Position cursor to location in A 
9796 11 54 97		            LD   DE, clear 
9799 cd 4f 88				call str_at_display 
979c			;            CALL fLCD_Str       ;Display string pointed to by DE 
979c 3e 00		            LD   A, display_row_1 
979e			;            CALL fLCD_Pos       ;Position cursor to location in A 
979e 11 e6 e4		            LD   DE, scratch 
97a1			;            CALL fLCD_Str       ;Display string pointed to by DE 
97a1 cd 4f 88				call str_at_display 
97a4 cd 5f 88			call update_display 
97a7			 
97a7 3e 00				ld a,0 
97a9 21 e6 e4			ld hl, scratch 
97ac 77				ld (hl),a 
97ad			 
97ad 00				nop 
97ae c3 77 97			jp cloop 
97b1			 
97b1			 
97b1			 
97b1			; OS Prompt 
97b1			 
97b1 .. 00		prompt: db ">",0 
97b3 .. 00		endprg: db "?",0 
97b5			 
97b5			 
97b5			; handy next page prompt 
97b5			next_page_prompt: 
97b5 e5				push hl 
97b6 d5				push de 
97b7 f5				push af 
97b8 c5				push bc 
97b9			 
97b9 3e 4f			ld a,display_row_4 + display_cols - 1 
97bb 11 b3 97		        ld de, endprg 
97be cd 4f 88			call str_at_display 
97c1 cd 5f 88			call update_display 
97c4 cd 1b d8			call cin_wait 
97c7 c1				pop bc 
97c8 f1				pop af 
97c9 d1				pop de 
97ca e1				pop hl 
97cb			 
97cb			 
97cb c9				ret 
97cc			 
97cc			 
97cc			; forth parser 
97cc			 
97cc			; My forth kernel 
97cc			include "forth_kernel.asm" 
97cc			; 
97cc			; kernel to the forth OS 
97cc			 
97cc			DS_TYPE_STR: equ 1     ; string type 
97cc			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
97cc			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
97cc			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
97cc			 
97cc			FORTH_PARSEV1: equ 0 
97cc			FORTH_PARSEV2: equ 0 
97cc			FORTH_PARSEV3: equ 0 
97cc			FORTH_PARSEV4: equ 0 
97cc			FORTH_PARSEV5: equ 1 
97cc			 
97cc			;if FORTH_PARSEV5 
97cc			;	FORTH_END_BUFFER: equ 0 
97cc			;else 
97cc			FORTH_END_BUFFER: equ 127 
97cc			;endif 
97cc			 
97cc			FORTH_TRUE: equ 1 
97cc			FORTH_FALSE: equ 0 
97cc			 
97cc			if FORTH_PARSEV4 
97cc			include "forth_stackops.asm" 
97cc			endif 
97cc			 
97cc			if FORTH_PARSEV5 
97cc			include "forth_stackopsv5.asm" 
97cc			 
97cc			; Stack operations for v5 parser on wards 
97cc			; * DATA stack 
97cc			; * LOOP stack 
97cc			; * RETURN stack 
97cc			 
97cc			 
97cc			 
97cc			FORTH_CHK_DSP_UNDER: macro 
97cc				push hl 
97cc				push de 
97cc				ld hl,(cli_data_sp) 
97cc				ld de, cli_data_stack 
97cc				call cmp16 
97cc				jp c, fault_dsp_under 
97cc				pop de 
97cc				pop hl 
97cc				endm 
97cc			 
97cc			 
97cc			FORTH_CHK_RSP_UNDER: macro 
97cc				push hl 
97cc				push de 
97cc				ld hl,(cli_ret_sp) 
97cc				ld de, cli_ret_stack 
97cc				call cmp16 
97cc				jp c, fault_rsp_under 
97cc				pop de 
97cc				pop hl 
97cc				endm 
97cc			 
97cc			FORTH_CHK_LOOP_UNDER: macro 
97cc				push hl 
97cc				push de 
97cc				ld hl,(cli_loop_sp) 
97cc				ld de, cli_loop_stack 
97cc				call cmp16 
97cc				jp c, fault_loop_under 
97cc				pop de 
97cc				pop hl 
97cc				endm 
97cc			 
97cc			FORTH_ERR_TOS_NOTSTR: macro 
97cc				; TOSO might need more for checks when used 
97cc				push af 
97cc				ld a,(hl) 
97cc				cp DS_TYPE_STR 
97cc				jp nz, type_faultn   
97cc				pop af 
97cc				endm 
97cc			 
97cc			FORTH_ERR_TOS_NOTNUM: macro 
97cc				push af 
97cc				ld a,(hl) 
97cc				cp DS_TYPE_INUM 
97cc				jp nz, type_faultn   
97cc				pop af 
97cc				endm 
97cc			 
97cc			 
97cc			; increase data stack pointer and save hl to it 
97cc				 
97cc			FORTH_DSP_NEXT: macro 
97cc				call macro_forth_dsp_next 
97cc				endm 
97cc			 
97cc			 
97cc			macro_forth_dsp_next: 
97cc				if DEBUG_FORTH_STACK_GUARD 
97cc cd 7f d5				call check_stacks 
97cf				endif 
97cf e5				push hl 
97d0 d5				push de 
97d1 eb				ex de,hl 
97d2 2a 93 ec			ld hl,(cli_data_sp) 
97d5 23				inc hl 
97d6 23				inc hl 
97d7			 
97d7			; PARSEV5 
97d7 23				inc hl 
97d8 22 93 ec			ld (cli_data_sp),hl 
97db 73				ld (hl), e 
97dc 23				inc hl 
97dd 72				ld (hl), d 
97de d1				pop de 
97df e1				pop hl 
97e0				if DEBUG_FORTH_STACK_GUARD 
97e0 cd 7f d5				call check_stacks 
97e3				endif 
97e3 c9				ret 
97e4			 
97e4			 
97e4			; increase ret stack pointer and save hl to it 
97e4				 
97e4			FORTH_RSP_NEXT: macro 
97e4				call macro_forth_rsp_next 
97e4				endm 
97e4			 
97e4			macro_forth_rsp_next: 
97e4				if DEBUG_FORTH_STACK_GUARD 
97e4 cd 7f d5				call check_stacks 
97e7				endif 
97e7 e5				push hl 
97e8 d5				push de 
97e9 eb				ex de,hl 
97ea 2a 97 ec			ld hl,(cli_ret_sp) 
97ed 23				inc hl 
97ee 23				inc hl 
97ef 22 97 ec			ld (cli_ret_sp),hl 
97f2 73				ld (hl), e 
97f3 23				inc hl 
97f4 72				ld (hl), d 
97f5 d1				pop de 
97f6 e1				pop hl 
97f7				if DEBUG_FORTH_STACK_GUARD 
97f7 cd 7f d5				call check_stacks 
97fa				endif 
97fa c9				ret 
97fb			 
97fb			; get current ret stack pointer and save to hl  
97fb				 
97fb			FORTH_RSP_TOS: macro 
97fb				call macro_forth_rsp_tos 
97fb				endm 
97fb			 
97fb			macro_forth_rsp_tos: 
97fb				;push de 
97fb 2a 97 ec			ld hl,(cli_ret_sp) 
97fe cd 36 98			call loadhlptrtohl 
9801				;ld e, (hl) 
9801				;inc hl 
9801				;ld d, (hl) 
9801				;ex de, hl 
9801					if DEBUG_FORTH_WORDS 
9801			;			DMARK "RST" 
9801						CALLMONITOR 
9801 cd b0 92			call break_point_state  
9804				endm  
# End of macro CALLMONITOR
9804					endif 
9804				;pop de 
9804 c9				ret 
9805			 
9805			; pop ret stack pointer 
9805				 
9805			FORTH_RSP_POP: macro 
9805				call macro_forth_rsp_pop 
9805				endm 
9805			 
9805			 
9805			macro_forth_rsp_pop: 
9805				if DEBUG_FORTH_STACK_GUARD 
9805			;		DMARK "RPP" 
9805 cd 7f d5				call check_stacks 
9808					FORTH_CHK_RSP_UNDER 
9808 e5				push hl 
9809 d5				push de 
980a 2a 97 ec			ld hl,(cli_ret_sp) 
980d 11 51 ec			ld de, cli_ret_stack 
9810 cd 87 8a			call cmp16 
9813 da 93 d6			jp c, fault_rsp_under 
9816 d1				pop de 
9817 e1				pop hl 
9818				endm 
# End of macro FORTH_CHK_RSP_UNDER
9818				endif 
9818 e5				push hl 
9819 2a 97 ec			ld hl,(cli_ret_sp) 
981c			 
981c			 
981c				if FORTH_ENABLE_FREE 
981c			 
981c					; get pointer 
981c			 
981c					push de 
981c					push hl 
981c			 
981c					ld e, (hl) 
981c					inc hl 
981c					ld d, (hl) 
981c			 
981c					ex de, hl 
981c					call free 
981c			 
981c					pop hl 
981c					pop de 
981c			 
981c			 
981c				endif 
981c			 
981c			 
981c 2b				dec hl 
981d 2b				dec hl 
981e 22 97 ec			ld (cli_ret_sp), hl 
9821				; do stack underflow checks 
9821 e1				pop hl 
9822				if DEBUG_FORTH_STACK_GUARD 
9822 cd 7f d5				call check_stacks 
9825					FORTH_CHK_RSP_UNDER 
9825 e5				push hl 
9826 d5				push de 
9827 2a 97 ec			ld hl,(cli_ret_sp) 
982a 11 51 ec			ld de, cli_ret_stack 
982d cd 87 8a			call cmp16 
9830 da 93 d6			jp c, fault_rsp_under 
9833 d1				pop de 
9834 e1				pop hl 
9835				endm 
# End of macro FORTH_CHK_RSP_UNDER
9835				endif 
9835 c9				ret 
9836			 
9836			 
9836			 
9836			; routine to load word pointed to by hl into hl 
9836			 
9836			loadhlptrtohl: 
9836			 
9836 d5				push de 
9837 5e				ld e, (hl) 
9838 23				inc hl 
9839 56				ld d, (hl) 
983a eb				ex de, hl 
983b d1				pop de 
983c			 
983c c9				ret 
983d			 
983d			 
983d			 
983d			 
983d			 
983d			; push a number held in HL onto the data stack 
983d			; entry point for pushing a value when already in hl used in function above 
983d			 
983d			forth_push_numhl: 
983d			 
983d e5				push hl    ; save value to push 
983e			 
983e			if DEBUG_FORTH_PUSH 
983e				; see if disabled 
983e			 
983e			 
983e f5				push af 
983f 3a d7 e4			ld a, (os_view_disable) 
9842 fe 2a			cp '*' 
9844 28 34			jr z, .pskip2 
9846 e5				push hl 
9847 e5			push hl 
9848 cd 3c 88			call clear_display 
984b e1			pop hl 
984c 7c				ld a,h 
984d 21 eb e7			ld hl, os_word_scratch 
9850 cd 6a 8d			call hexout 
9853 e1				pop hl 
9854 7d				ld a,l 
9855 21 ed e7			ld hl, os_word_scratch+2 
9858 cd 6a 8d			call hexout 
985b			 
985b 21 ef e7			ld hl, os_word_scratch+4 
985e 3e 00			ld a,0 
9860 77				ld (hl),a 
9861 11 eb e7			ld de,os_word_scratch 
9864 3e 14				ld a, display_row_2 
9866 cd 4f 88				call str_at_display 
9869 11 8d c4			ld de, .push_num 
986c 3e 00			ld a, display_row_1 
986e			 
986e cd 4f 88				call str_at_display 
9871			 
9871			 
9871 cd 5f 88			call update_display 
9874 cd ea 87			call delay1s 
9877 cd ea 87			call delay1s 
987a			.pskip2:  
987a			 
987a f1				pop af 
987b			endif	 
987b			 
987b			 
987b				FORTH_DSP_NEXT 
987b cd cc 97			call macro_forth_dsp_next 
987e				endm 
# End of macro FORTH_DSP_NEXT
987e			 
987e 2a 93 ec			ld hl, (cli_data_sp) 
9881			 
9881				; save item type 
9881 3e 02			ld a,  DS_TYPE_INUM 
9883 77				ld (hl), a 
9884 23				inc hl 
9885			 
9885				; get word off stack 
9885 d1				pop de 
9886 7b				ld a,e 
9887 77				ld (hl), a 
9888 23				inc hl 
9889 7a				ld a,d 
988a 77				ld (hl), a 
988b			 
988b			if DEBUG_FORTH_PUSH 
988b 2b				dec hl 
988c 2b				dec hl 
988d 2b				dec hl 
988e						DMARK "PH5" 
988e f5				push af  
988f 3a a3 98			ld a, (.dmark)  
9892 32 c0 ee			ld (debug_mark),a  
9895 3a a4 98			ld a, (.dmark+1)  
9898 32 c1 ee			ld (debug_mark+1),a  
989b 3a a5 98			ld a, (.dmark+2)  
989e 32 c2 ee			ld (debug_mark+2),a  
98a1 18 03			jr .pastdmark  
98a3 ..			.dmark: db "PH5"  
98a6 f1			.pastdmark: pop af  
98a7			endm  
# End of macro DMARK
98a7				CALLMONITOR 
98a7 cd b0 92			call break_point_state  
98aa				endm  
# End of macro CALLMONITOR
98aa			endif	 
98aa			 
98aa c9				ret 
98ab			 
98ab			 
98ab			; Push a string to stack pointed to by hl 
98ab			 
98ab			forth_push_str: 
98ab			 
98ab			if DEBUG_FORTH_PUSH 
98ab						DMARK "PSQ" 
98ab f5				push af  
98ac 3a c0 98			ld a, (.dmark)  
98af 32 c0 ee			ld (debug_mark),a  
98b2 3a c1 98			ld a, (.dmark+1)  
98b5 32 c1 ee			ld (debug_mark+1),a  
98b8 3a c2 98			ld a, (.dmark+2)  
98bb 32 c2 ee			ld (debug_mark+2),a  
98be 18 03			jr .pastdmark  
98c0 ..			.dmark: db "PSQ"  
98c3 f1			.pastdmark: pop af  
98c4			endm  
# End of macro DMARK
98c4				CALLMONITOR 
98c4 cd b0 92			call break_point_state  
98c7				endm  
# End of macro CALLMONITOR
98c7			endif	 
98c7			    
98c7 e5				push hl 
98c8 e5				push hl 
98c9			 
98c9			;	ld a, 0   ; find end of string 
98c9 cd c7 8e			call strlenz 
98cc			if DEBUG_FORTH_PUSH 
98cc						DMARK "PQ2" 
98cc f5				push af  
98cd 3a e1 98			ld a, (.dmark)  
98d0 32 c0 ee			ld (debug_mark),a  
98d3 3a e2 98			ld a, (.dmark+1)  
98d6 32 c1 ee			ld (debug_mark+1),a  
98d9 3a e3 98			ld a, (.dmark+2)  
98dc 32 c2 ee			ld (debug_mark+2),a  
98df 18 03			jr .pastdmark  
98e1 ..			.dmark: db "PQ2"  
98e4 f1			.pastdmark: pop af  
98e5			endm  
# End of macro DMARK
98e5				CALLMONITOR 
98e5 cd b0 92			call break_point_state  
98e8				endm  
# End of macro CALLMONITOR
98e8			endif	 
98e8 eb				ex de, hl 
98e9 e1				pop hl   ; get ptr to start of string 
98ea			if DEBUG_FORTH_PUSH 
98ea						DMARK "PQ3" 
98ea f5				push af  
98eb 3a ff 98			ld a, (.dmark)  
98ee 32 c0 ee			ld (debug_mark),a  
98f1 3a 00 99			ld a, (.dmark+1)  
98f4 32 c1 ee			ld (debug_mark+1),a  
98f7 3a 01 99			ld a, (.dmark+2)  
98fa 32 c2 ee			ld (debug_mark+2),a  
98fd 18 03			jr .pastdmark  
98ff ..			.dmark: db "PQ3"  
9902 f1			.pastdmark: pop af  
9903			endm  
# End of macro DMARK
9903				CALLMONITOR 
9903 cd b0 92			call break_point_state  
9906				endm  
# End of macro CALLMONITOR
9906			endif	 
9906 19				add hl,de 
9907			if DEBUG_FORTH_PUSH 
9907						DMARK "PQE" 
9907 f5				push af  
9908 3a 1c 99			ld a, (.dmark)  
990b 32 c0 ee			ld (debug_mark),a  
990e 3a 1d 99			ld a, (.dmark+1)  
9911 32 c1 ee			ld (debug_mark+1),a  
9914 3a 1e 99			ld a, (.dmark+2)  
9917 32 c2 ee			ld (debug_mark+2),a  
991a 18 03			jr .pastdmark  
991c ..			.dmark: db "PQE"  
991f f1			.pastdmark: pop af  
9920			endm  
# End of macro DMARK
9920				CALLMONITOR 
9920 cd b0 92			call break_point_state  
9923				endm  
# End of macro CALLMONITOR
9923			endif	 
9923			 
9923 2b				dec hl    ; see if there is an optional trailing double quote 
9924 7e				ld a,(hl) 
9925 fe 22			cp '"' 
9927 20 03			jr nz, .strnoq 
9929 3e 00			ld a, 0      ; get rid of double quote 
992b 77				ld (hl), a 
992c 23			.strnoq: inc hl 
992d			 
992d 3e 00			ld a, 0 
992f 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9930			 
9930 13				inc de ; add one for the type string 
9931 13				inc de ; add one for null term??? 
9932			 
9932				; tos is get string pointer again 
9932				; de contains space to allocate 
9932				 
9932 d5				push de 
9933			 
9933 eb				ex de, hl 
9934			 
9934				;push af 
9934			 
9934			if DEBUG_FORTH_PUSH 
9934						DMARK "PHm" 
9934 f5				push af  
9935 3a 49 99			ld a, (.dmark)  
9938 32 c0 ee			ld (debug_mark),a  
993b 3a 4a 99			ld a, (.dmark+1)  
993e 32 c1 ee			ld (debug_mark+1),a  
9941 3a 4b 99			ld a, (.dmark+2)  
9944 32 c2 ee			ld (debug_mark+2),a  
9947 18 03			jr .pastdmark  
9949 ..			.dmark: db "PHm"  
994c f1			.pastdmark: pop af  
994d			endm  
# End of macro DMARK
994d				CALLMONITOR 
994d cd b0 92			call break_point_state  
9950				endm  
# End of macro CALLMONITOR
9950			endif	 
9950 cd 30 8f			call malloc	; on ret hl now contains allocated memory 
9953				if DEBUG_FORTH_MALLOC_GUARD 
9953 cc e5 c4				call z,malloc_error 
9956				endif 
9956			 
9956				 
9956 c1				pop bc    ; get length 
9957 d1				pop de   ;  get string start    
9958			 
9958				; hl has destination from malloc 
9958			 
9958 eb				ex de, hl    ; prep for ldir 
9959			 
9959 d5				push de   ; save malloc area for DSP later 
995a				;push hl   ; save malloc area for DSP later 
995a			 
995a			if DEBUG_FORTH_PUSH 
995a						DMARK "PHc" 
995a f5				push af  
995b 3a 6f 99			ld a, (.dmark)  
995e 32 c0 ee			ld (debug_mark),a  
9961 3a 70 99			ld a, (.dmark+1)  
9964 32 c1 ee			ld (debug_mark+1),a  
9967 3a 71 99			ld a, (.dmark+2)  
996a 32 c2 ee			ld (debug_mark+2),a  
996d 18 03			jr .pastdmark  
996f ..			.dmark: db "PHc"  
9972 f1			.pastdmark: pop af  
9973			endm  
# End of macro DMARK
9973				CALLMONITOR 
9973 cd b0 92			call break_point_state  
9976				endm  
# End of macro CALLMONITOR
9976			endif	 
9976			 
9976			 
9976 ed b0			ldir 
9978			 
9978			 
9978				; push malloc to data stack     macro?????  
9978			 
9978				FORTH_DSP_NEXT 
9978 cd cc 97			call macro_forth_dsp_next 
997b				endm 
# End of macro FORTH_DSP_NEXT
997b			 
997b				; save value and type 
997b			 
997b 2a 93 ec			ld hl, (cli_data_sp) 
997e			 
997e				; save item type 
997e 3e 01			ld a,  DS_TYPE_STR 
9980 77				ld (hl), a 
9981 23				inc hl 
9982			 
9982				; get malloc word off stack 
9982 d1				pop de 
9983 73				ld (hl), e 
9984 23				inc hl 
9985 72				ld (hl), d 
9986			 
9986			 
9986			 
9986			if DEBUG_FORTH_PUSH 
9986 2a 93 ec			ld hl, (cli_data_sp) 
9989						DMARK "PHS" 
9989 f5				push af  
998a 3a 9e 99			ld a, (.dmark)  
998d 32 c0 ee			ld (debug_mark),a  
9990 3a 9f 99			ld a, (.dmark+1)  
9993 32 c1 ee			ld (debug_mark+1),a  
9996 3a a0 99			ld a, (.dmark+2)  
9999 32 c2 ee			ld (debug_mark+2),a  
999c 18 03			jr .pastdmark  
999e ..			.dmark: db "PHS"  
99a1 f1			.pastdmark: pop af  
99a2			endm  
# End of macro DMARK
99a2				CALLMONITOR 
99a2 cd b0 92			call break_point_state  
99a5				endm  
# End of macro CALLMONITOR
99a5			;	ex de,hl 
99a5			endif	 
99a5				; in case of spaces, skip the ptr past the copied string 
99a5				;pop af 
99a5				;ld (cli_origptr),hl 
99a5			 
99a5 c9				ret 
99a6			 
99a6			 
99a6			 
99a6			; TODO ascii push input onto stack given hl to start of input 
99a6			 
99a6			; identify type 
99a6			; if starts with a " then a string 
99a6			; otherwise it is a number 
99a6			;  
99a6			; if a string 
99a6			;     scan for ending " to get length of string to malloc for + 1 
99a6			;     malloc 
99a6			;     put pointer to string on stack first byte flags as string 
99a6			; 
99a6			; else a number 
99a6			;    look for number format identifier 
99a6			;    $xx hex 
99a6			;    %xxxxx bin 
99a6			;    xxxxx decimal 
99a6			;    convert number to 16bit word.  
99a6			;    malloc word + 1 with flag to identiy as num 
99a6			;    put pointer to number on stack 
99a6			;   
99a6			;  
99a6			  
99a6			forth_apush: 
99a6				; kernel push 
99a6			 
99a6			if DEBUG_FORTH_PUSH 
99a6						DMARK "PSH" 
99a6 f5				push af  
99a7 3a bb 99			ld a, (.dmark)  
99aa 32 c0 ee			ld (debug_mark),a  
99ad 3a bc 99			ld a, (.dmark+1)  
99b0 32 c1 ee			ld (debug_mark+1),a  
99b3 3a bd 99			ld a, (.dmark+2)  
99b6 32 c2 ee			ld (debug_mark+2),a  
99b9 18 03			jr .pastdmark  
99bb ..			.dmark: db "PSH"  
99be f1			.pastdmark: pop af  
99bf			endm  
# End of macro DMARK
99bf				CALLMONITOR 
99bf cd b0 92			call break_point_state  
99c2				endm  
# End of macro CALLMONITOR
99c2			endif	 
99c2				; identify input type 
99c2			 
99c2 7e				ld a,(hl) 
99c3 fe 22			cp '"' 
99c5 28 0a			jr z, .fapstr 
99c7 fe 24			cp '$' 
99c9 ca f1 99			jp z, .faphex 
99cc fe 25			cp '%' 
99ce ca d9 99			jp z, .fapbin 
99d1			;	cp 'b' 
99d1			;	jp z, .fabin 
99d1				; else decimal 
99d1			 
99d1				; TODO do decimal conversion 
99d1				; decimal is stored as a 16bit word 
99d1			 
99d1				; by default everything is a string if type is not detected 
99d1			.fapstr: ; 
99d1 fe 22			cp '"' 
99d3 20 01			jr nz, .strnoqu 
99d5 23				inc hl 
99d6			.strnoqu: 
99d6 c3 ab 98			jp forth_push_str 
99d9			 
99d9			 
99d9			 
99d9			.fapbin:    ; push a binary string.  
99d9 11 00 00			ld de, 0   ; hold a 16bit value 
99dc			 
99dc 23			.fapbinshift:	inc hl  
99dd 7e				ld a,(hl) 
99de fe 00			cp 0     ; done scanning  
99e0 28 0b			jr z, .fapbdone  	; got it in HL so push  
99e2			 
99e2				; left shift de 
99e2 eb				ex de, hl	 
99e3 29				add hl, hl 
99e4			 
99e4				; is 1 
99e4 fe 31			cp '1' 
99e6 20 02			jr nz, .binzero 
99e8 cb 4d			bit 1, l 
99ea			.binzero: 
99ea eb				ex de, hl	 ; save current de 
99eb 18 ef			jr .fapbinshift 
99ed			 
99ed			.fapbdone: 
99ed eb				ex de, hl 
99ee c3 3d 98			jp forth_push_numhl 
99f1			 
99f1			 
99f1			.faphex:   ; hex is always stored as a 16bit word 
99f1				; skip number prefix 
99f1 23				inc hl 
99f2				; turn ascii into number 
99f2 cd 20 8e			call get_word_hl	; ret 16bit word in hl 
99f5			 
99f5 c3 3d 98			jp forth_push_numhl 
99f8			 
99f8 00				 nop 
99f9			 
99f9			.fabin:   ; TODO bin conversion 
99f9			 
99f9			 
99f9 c9				ret 
99fa			 
99fa			 
99fa			; get either a string ptr or a 16bit word from the data stack 
99fa			 
99fa			FORTH_DSP: macro 
99fa				call macro_forth_dsp 
99fa				endm 
99fa			 
99fa			macro_forth_dsp: 
99fa				; data stack pointer points to current word on tos 
99fa			 
99fa 2a 93 ec			ld hl,(cli_data_sp) 
99fd			 
99fd				if DEBUG_FORTH_PUSH 
99fd						DMARK "DSP" 
99fd f5				push af  
99fe 3a 12 9a			ld a, (.dmark)  
9a01 32 c0 ee			ld (debug_mark),a  
9a04 3a 13 9a			ld a, (.dmark+1)  
9a07 32 c1 ee			ld (debug_mark+1),a  
9a0a 3a 14 9a			ld a, (.dmark+2)  
9a0d 32 c2 ee			ld (debug_mark+2),a  
9a10 18 03			jr .pastdmark  
9a12 ..			.dmark: db "DSP"  
9a15 f1			.pastdmark: pop af  
9a16			endm  
# End of macro DMARK
9a16			 
9a16 cd 1a c5				call display_data_sp 
9a19				;call break_point_state 
9a19				;rst 030h 
9a19				CALLMONITOR 
9a19 cd b0 92			call break_point_state  
9a1c				endm  
# End of macro CALLMONITOR
9a1c				endif 
9a1c			 
9a1c c9				ret 
9a1d			 
9a1d			; return hl to start of value on stack 
9a1d			 
9a1d			FORTH_DSP_VALUE: macro 
9a1d				call macro_forth_dsp_value 
9a1d				endm 
9a1d			 
9a1d			macro_forth_dsp_value: 
9a1d			 
9a1d				FORTH_DSP 
9a1d cd fa 99			call macro_forth_dsp 
9a20				endm 
# End of macro FORTH_DSP
9a20			 
9a20 d5				push de 
9a21			 
9a21 23				inc hl ; skip type 
9a22			 
9a22 5e				ld e, (hl) 
9a23 23				inc hl 
9a24 56				ld d, (hl) 
9a25 eb				ex de,hl  
9a26			 
9a26 d1				pop de 
9a27			 
9a27 c9				ret 
9a28			 
9a28			; return hl to start of value to second item on stack 
9a28			 
9a28			FORTH_DSP_VALUEM1: macro 
9a28				call macro_forth_dsp_value_m1 
9a28				endm 
9a28			 
9a28			macro_forth_dsp_value_m1: 
9a28			 
9a28				FORTH_DSP 
9a28 cd fa 99			call macro_forth_dsp 
9a2b				endm 
# End of macro FORTH_DSP
9a2b			 
9a2b 2b				dec hl 
9a2c 2b				dec hl 
9a2d			;	dec hl 
9a2d			 
9a2d d5				push de 
9a2e			 
9a2e 5e				ld e, (hl) 
9a2f 23				inc hl 
9a30 56				ld d, (hl) 
9a31 eb				ex de,hl  
9a32			 
9a32 d1				pop de 
9a33			 
9a33 c9				ret 
9a34			 
9a34				 
9a34			 
9a34			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9a34			 
9a34			FORTH_DSP_POP: macro 
9a34				call macro_forth_dsp_pop 
9a34				endm 
9a34			 
9a34			 
9a34			; get the tos data type 
9a34			 
9a34			FORTH_DSP_TYPE:   macro 
9a34			 
9a34				;FORTH_DSP_VALUE 
9a34				FORTH_DSP 
9a34				 
9a34				; hl points to value 
9a34				; check type 
9a34			 
9a34				ld a,(hl) 
9a34			 
9a34				endm 
9a34			 
9a34			; load the tos value into hl 
9a34			 
9a34			 
9a34			FORTH_DSP_VALUEHL:  macro 
9a34				call macro_dsp_valuehl 
9a34				endm 
9a34			 
9a34			 
9a34			 
9a34			macro_dsp_valuehl: 
9a34				FORTH_DSP_VALUE 
9a34 cd 1d 9a			call macro_forth_dsp_value 
9a37				endm 
# End of macro FORTH_DSP_VALUE
9a37			 
9a37				;FORTH_ERR_TOS_NOTNUM 
9a37			 
9a37				;inc hl   ; skip type id 
9a37			 
9a37			;	push de 
9a37			; 
9a37			;	ld e, (hl) 
9a37			;	inc hl 
9a37			;	ld d, (hl) 
9a37			;	ex de,hl  
9a37			 
9a37			;	pop de 
9a37			 
9a37				if DEBUG_FORTH_PUSH 
9a37						DMARK "DVL" 
9a37 f5				push af  
9a38 3a 4c 9a			ld a, (.dmark)  
9a3b 32 c0 ee			ld (debug_mark),a  
9a3e 3a 4d 9a			ld a, (.dmark+1)  
9a41 32 c1 ee			ld (debug_mark+1),a  
9a44 3a 4e 9a			ld a, (.dmark+2)  
9a47 32 c2 ee			ld (debug_mark+2),a  
9a4a 18 03			jr .pastdmark  
9a4c ..			.dmark: db "DVL"  
9a4f f1			.pastdmark: pop af  
9a50			endm  
# End of macro DMARK
9a50				CALLMONITOR 
9a50 cd b0 92			call break_point_state  
9a53				endm  
# End of macro CALLMONITOR
9a53				endif 
9a53 c9				ret 
9a54			 
9a54			forth_apushstrhl:      
9a54				; push of string requires use of cli_origptr 
9a54				; bodge use 
9a54			 
9a54				; get current cli_origptr, save, update with temp pointer  
9a54 ed 5b af ec		ld de, (cli_origptr) 
9a58 22 af ec			ld (cli_origptr), hl 
9a5b d5				push de 
9a5c cd a6 99			call forth_apush 
9a5f d1				pop de 
9a60 ed 53 af ec		ld (cli_origptr), de 
9a64 c9			        ret	 
9a65			 
9a65			 
9a65			; increase loop stack pointer and save hl to it 
9a65				 
9a65			FORTH_LOOP_NEXT: macro 
9a65				call macro_forth_loop_next 
9a65				;nop 
9a65				endm 
9a65			 
9a65			macro_forth_loop_next: 
9a65				if DEBUG_FORTH_STACK_GUARD 
9a65 cd 7f d5				call check_stacks 
9a68				endif 
9a68 e5				push hl 
9a69 d5				push de 
9a6a eb				ex de,hl 
9a6b 2a 95 ec			ld hl,(cli_loop_sp) 
9a6e 23				inc hl 
9a6f 23				inc hl 
9a70					if DEBUG_FORTH_WORDS 
9a70						DMARK "LNX" 
9a70 f5				push af  
9a71 3a 85 9a			ld a, (.dmark)  
9a74 32 c0 ee			ld (debug_mark),a  
9a77 3a 86 9a			ld a, (.dmark+1)  
9a7a 32 c1 ee			ld (debug_mark+1),a  
9a7d 3a 87 9a			ld a, (.dmark+2)  
9a80 32 c2 ee			ld (debug_mark+2),a  
9a83 18 03			jr .pastdmark  
9a85 ..			.dmark: db "LNX"  
9a88 f1			.pastdmark: pop af  
9a89			endm  
# End of macro DMARK
9a89						CALLMONITOR 
9a89 cd b0 92			call break_point_state  
9a8c				endm  
# End of macro CALLMONITOR
9a8c					endif 
9a8c 22 95 ec			ld (cli_loop_sp),hl 
9a8f 73				ld (hl), e 
9a90 23				inc hl 
9a91 72				ld (hl), d 
9a92 d1				pop de    ; been reversed so save a swap on restore 
9a93 e1				pop hl 
9a94				if DEBUG_FORTH_STACK_GUARD 
9a94 cd 7f d5				call check_stacks 
9a97				endif 
9a97 c9				ret 
9a98			 
9a98			; get current ret stack pointer and save to hl  
9a98				 
9a98			FORTH_LOOP_TOS: macro 
9a98				call macro_forth_loop_tos 
9a98				endm 
9a98			 
9a98			macro_forth_loop_tos: 
9a98 d5				push de 
9a99 2a 95 ec			ld hl,(cli_loop_sp) 
9a9c 5e				ld e, (hl) 
9a9d 23				inc hl 
9a9e 56				ld d, (hl) 
9a9f eb				ex de, hl 
9aa0 d1				pop de 
9aa1 c9				ret 
9aa2			 
9aa2			; pop loop stack pointer 
9aa2				 
9aa2			FORTH_LOOP_POP: macro 
9aa2				call macro_forth_loop_pop 
9aa2				endm 
9aa2			 
9aa2			 
9aa2			macro_forth_loop_pop: 
9aa2				if DEBUG_FORTH_STACK_GUARD 
9aa2					DMARK "LPP" 
9aa2 f5				push af  
9aa3 3a b7 9a			ld a, (.dmark)  
9aa6 32 c0 ee			ld (debug_mark),a  
9aa9 3a b8 9a			ld a, (.dmark+1)  
9aac 32 c1 ee			ld (debug_mark+1),a  
9aaf 3a b9 9a			ld a, (.dmark+2)  
9ab2 32 c2 ee			ld (debug_mark+2),a  
9ab5 18 03			jr .pastdmark  
9ab7 ..			.dmark: db "LPP"  
9aba f1			.pastdmark: pop af  
9abb			endm  
# End of macro DMARK
9abb cd 7f d5				call check_stacks 
9abe					FORTH_CHK_LOOP_UNDER 
9abe e5				push hl 
9abf d5				push de 
9ac0 2a 95 ec			ld hl,(cli_loop_sp) 
9ac3 11 4f eb			ld de, cli_loop_stack 
9ac6 cd 87 8a			call cmp16 
9ac9 da 99 d6			jp c, fault_loop_under 
9acc d1				pop de 
9acd e1				pop hl 
9ace				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9ace				endif 
9ace e5				push hl 
9acf 2a 95 ec			ld hl,(cli_loop_sp) 
9ad2 2b				dec hl 
9ad3 2b				dec hl 
9ad4 22 95 ec			ld (cli_loop_sp), hl 
9ad7				; TODO do stack underflow checks 
9ad7 e1				pop hl 
9ad8				if DEBUG_FORTH_STACK_GUARD 
9ad8 cd 7f d5				call check_stacks 
9adb					FORTH_CHK_LOOP_UNDER 
9adb e5				push hl 
9adc d5				push de 
9add 2a 95 ec			ld hl,(cli_loop_sp) 
9ae0 11 4f eb			ld de, cli_loop_stack 
9ae3 cd 87 8a			call cmp16 
9ae6 da 99 d6			jp c, fault_loop_under 
9ae9 d1				pop de 
9aea e1				pop hl 
9aeb				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9aeb				endif 
9aeb c9				ret 
9aec			 
9aec			macro_forth_dsp_pop: 
9aec			 
9aec e5				push hl 
9aed			 
9aed				; release malloc data 
9aed			 
9aed				if DEBUG_FORTH_STACK_GUARD 
9aed cd 7f d5				call check_stacks 
9af0					FORTH_CHK_DSP_UNDER 
9af0 e5				push hl 
9af1 d5				push de 
9af2 2a 93 ec			ld hl,(cli_data_sp) 
9af5 11 4d ea			ld de, cli_data_stack 
9af8 cd 87 8a			call cmp16 
9afb da 8d d6			jp c, fault_dsp_under 
9afe d1				pop de 
9aff e1				pop hl 
9b00				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b00				endif 
9b00				;ld hl,(cli_data_sp) 
9b00			if DEBUG_FORTH_DOT 
9b00				DMARK "DPP" 
9b00				CALLMONITOR 
9b00			endif	 
9b00			 
9b00			 
9b00			if FORTH_ENABLE_DSPPOPFREE 
9b00			 
9b00				FORTH_DSP 
9b00 cd fa 99			call macro_forth_dsp 
9b03				endm 
# End of macro FORTH_DSP
9b03			 
9b03 7e				ld a, (hl) 
9b04 fe 01			cp DS_TYPE_STR 
9b06 20 07			jr nz, .skippopfree 
9b08			 
9b08				FORTH_DSP_VALUEHL 
9b08 cd 34 9a			call macro_dsp_valuehl 
9b0b				endm 
# End of macro FORTH_DSP_VALUEHL
9b0b 00				nop 
9b0c			if DEBUG_FORTH_DOT 
9b0c				DMARK "DPf" 
9b0c				CALLMONITOR 
9b0c			endif	 
9b0c cd fa 8f			call free 
9b0f			.skippopfree: 
9b0f				 
9b0f			 
9b0f			endif 
9b0f			 
9b0f			if DEBUG_FORTH_DOT_KEY 
9b0f				DMARK "DP2" 
9b0f				CALLMONITOR 
9b0f			endif	 
9b0f			 
9b0f				; move pointer down 
9b0f			 
9b0f 2a 93 ec			ld hl,(cli_data_sp) 
9b12 2b				dec hl 
9b13 2b				dec hl 
9b14			; PARSEV5 
9b14 2b				dec hl 
9b15 22 93 ec			ld (cli_data_sp), hl 
9b18			 
9b18				if DEBUG_FORTH_STACK_GUARD 
9b18 cd 7f d5				call check_stacks 
9b1b					FORTH_CHK_DSP_UNDER 
9b1b e5				push hl 
9b1c d5				push de 
9b1d 2a 93 ec			ld hl,(cli_data_sp) 
9b20 11 4d ea			ld de, cli_data_stack 
9b23 cd 87 8a			call cmp16 
9b26 da 8d d6			jp c, fault_dsp_under 
9b29 d1				pop de 
9b2a e1				pop hl 
9b2b				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b2b				endif 
9b2b			 
9b2b e1				pop hl 
9b2c			 
9b2c c9				ret 
9b2d			 
9b2d			getwordathl: 
9b2d				; hl points to an address 
9b2d				; load hl with the word at that address 
9b2d			 
9b2d d5				push de 
9b2e			 
9b2e 5e				ld e, (hl) 
9b2f 23				inc hl 
9b30 56				ld d, (hl) 
9b31 eb				ex de, hl 
9b32			 
9b32 d1				pop de 
9b33 c9				ret 
9b34			 
9b34			 
9b34			 
9b34			 
9b34			 
9b34			; eof 
9b34			 
# End of file forth_stackopsv5.asm
9b34			endif 
9b34			 
9b34			user_word_eol:  
9b34				; hl contains the pointer to where to create a linked list item from the end 
9b34				; of the user dict to continue on at the system word dict 
9b34				 
9b34				; poke the stub of the word list linked list to repoint to rom words 
9b34			 
9b34				; stub format 
9b34				; db   word id 
9b34				; dw    link to next word 
9b34			        ; db char length of token 
9b34				; db string + 0 term 
9b34				; db exec code....  
9b34			 
9b34 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9b36 77				ld (hl), a		; word id 
9b37 23				inc hl 
9b38			 
9b38 11 fe 9c			ld de, sysdict 
9b3b 73				ld (hl), e		; next word link ie system dict 
9b3c 23				inc hl 
9b3d 72				ld (hl), d		; next word link ie system dict 
9b3e 23				inc hl	 
9b3f			 
9b3f			;	ld (hl), sysdict		; next word link ie system dict 
9b3f			;	inc hl 
9b3f			;	inc hl 
9b3f			 
9b3f			;	inc hl 
9b3f			;	inc hl 
9b3f			 
9b3f 3e 02			ld a, 2			; word length is 0 
9b41 77				ld (hl), a	 
9b42 23				inc hl 
9b43			 
9b43 3e 7e			ld a, '~'			; word length is 0 
9b45 77				ld (hl), a	 
9b46 23				inc hl 
9b47 3e 00			ld a, 0			; save empty word 
9b49 77				ld (hl), a 
9b4a			 
9b4a c9				ret 
9b4b			 
9b4b				 
9b4b			 
9b4b			forthexec_cleanup: 
9b4b				FORTH_RSP_POP 
9b4b cd 05 98			call macro_forth_rsp_pop 
9b4e				endm 
# End of macro FORTH_RSP_POP
9b4e c9				ret 
9b4f			 
9b4f			forth_call_hl: 
9b4f				; taking hl 
9b4f e5				push hl 
9b50 c9				ret 
9b51			 
9b51			; this is called to reset Forth system but keep existing uwords etc 
9b51			 
9b51			forth_warmstart: 
9b51				; setup stack over/under flow checks 
9b51				if DEBUG_FORTH_STACK_GUARD 
9b51 cd 65 d5				call chk_stk_init 
9b54				endif 
9b54			 
9b54				; init stack pointers  - * these stacks go upwards *  
9b54 21 51 ec			ld hl, cli_ret_stack 
9b57 22 97 ec			ld (cli_ret_sp), hl	 
9b5a				; set bottom of stack 
9b5a 3e 00			ld a,0 
9b5c 77				ld (hl),a 
9b5d 23				inc hl 
9b5e 77				ld (hl),a 
9b5f			 
9b5f 21 4d ea			ld hl, cli_data_stack 
9b62 22 93 ec			ld (cli_data_sp), hl	 
9b65				; set bottom of stack 
9b65 3e 00			ld a,0 
9b67 77				ld (hl),a 
9b68 23				inc hl 
9b69 77				ld (hl),a 
9b6a			 
9b6a 21 4f eb			ld hl, cli_loop_stack 
9b6d 22 95 ec			ld (cli_loop_sp), hl	 
9b70				; set bottom of stack 
9b70 3e 00			ld a,0 
9b72 77				ld (hl),a 
9b73 23				inc hl 
9b74 77				ld (hl),a 
9b75			 
9b75				; init extent of current open file 
9b75			 
9b75 3e 00			ld a, 0 
9b77 32 e2 ec			ld (store_openext), a 
9b7a			 
9b7a c9				ret 
9b7b			 
9b7b			 
9b7b			; Cold Start - this is called to setup the whole Forth system 
9b7b			 
9b7b			forth_init: 
9b7b			 
9b7b				; setup stack over/under flow checks 
9b7b			 
9b7b			;	if DEBUG_FORTH_STACK_GUARD 
9b7b			;		call chk_stk_init 
9b7b			;	endif 
9b7b			 
9b7b				; enable auto display updates (slow.....) 
9b7b			 
9b7b 3e 01			ld a, 1 
9b7d 32 ad ec			ld (cli_autodisplay), a 
9b80			 
9b80			 
9b80			 
9b80				; show start up screen 
9b80			 
9b80 cd 3c 88			call clear_display 
9b83			 
9b83 3e 00			ld a,0 
9b85 32 cf ec			ld (f_cursor_ptr), a 
9b88			 
9b88				; set start of word list in start of ram - for use when creating user words 
9b88			 
9b88 21 30 d8			ld hl, baseram 
9b8b 22 e3 e7			ld (os_last_new_uword), hl 
9b8e cd 34 9b			call user_word_eol 
9b91				 
9b91			;		call display_data_sp 
9b91			;		call next_page_prompt 
9b91			 
9b91			 
9b91			 
9b91			 
9b91 c9				ret 
9b92			 
9b92 .. 00		.bootforth: db " Forth Kernel Init ",0 
9ba6			 
9ba6			; TODO push to stack 
9ba6			 
9ba6			;  
9ba6			 
9ba6			if FORTH_PARSEV2 
9ba6			 
9ba6			 
9ba6				include "forth_parserv2.asm" 
9ba6			 
9ba6			endif 
9ba6			 
9ba6			 
9ba6			; parse cli version 1 
9ba6			 
9ba6			if FORTH_PARSEV1 
9ba6			 
9ba6			 
9ba6			 
9ba6			      include "forth_parserv1.asm" 
9ba6			endif 
9ba6				 
9ba6			if FORTH_PARSEV3 
9ba6			 
9ba6			 
9ba6			 
9ba6			      include "forth_parserv3.asm" 
9ba6				include "forth_wordsv3.asm" 
9ba6			endif 
9ba6			 
9ba6			if FORTH_PARSEV4 
9ba6			 
9ba6			 
9ba6			 
9ba6			      include "forth_parserv4.asm" 
9ba6				include "forth_wordsv4.asm" 
9ba6			endif 
9ba6			 
9ba6			if FORTH_PARSEV5 
9ba6			 
9ba6			 
9ba6			 
9ba6			      include "forth_parserv5.asm" 
9ba6			 
9ba6			 
9ba6			; A better parser without using malloc and string copies all over the place.  
9ba6			; Exec in situ should be faster 
9ba6			 
9ba6			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9ba6			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9ba6			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9ba6			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9ba6			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9ba6			WORD_SYS_END: equ 0   ; Opcode for all user words 
9ba6			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9ba6			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9ba6			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9ba6			 
9ba6			; Core word preamble macro 
9ba6			 
9ba6			CWHEAD:   macro nxtword opcode lit len opflags 
9ba6				db WORD_SYS_CORE+opcode             
9ba6				; internal op code number 
9ba6				dw nxtword            
9ba6				; link to next dict word block 
9ba6				db len + 1 
9ba6				; literal length of dict word inc zero term 
9ba6				db lit,0              
9ba6				; literal dict word 
9ba6			        ; TODO db opflags        
9ba6				endm 
9ba6			 
9ba6			 
9ba6			NEXTW: macro  
9ba6				jp macro_next 
9ba6				endm 
9ba6			 
9ba6			macro_next: 
9ba6			if DEBUG_FORTH_PARSE_KEY 
9ba6				DMARK "NXT" 
9ba6				CALLMONITOR 
9ba6			endif	 
9ba6			;	inc hl  ; skip token null term  
9ba6 ed 4b b1 ec		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9baa ed 5b af ec		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9bae 2a e7 e7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9bb1			if DEBUG_FORTH_PARSE_KEY 
9bb1				DMARK "}AA" 
9bb1				CALLMONITOR 
9bb1			endif	 
9bb1 c3 b4 9c			jp execnext 
9bb4				;jp exec1 
9bb4			       
9bb4			 
9bb4			 
9bb4			; Another go at the parser to compile  
9bb4			 
9bb4			 
9bb4			; TODO rework parser to change all of the string words to byte tokens 
9bb4			; TODO do a search for  
9bb4			 
9bb4			; TODO first run normal parser to zero term sections 
9bb4			; TODO for each word do a token look up to get the op code 
9bb4			; TODO need some means to flag to the exec that this is a byte code form    
9bb4			 
9bb4			 
9bb4			forthcompile: 
9bb4			 
9bb4			; 
9bb4			; line parse: 
9bb4			;       parse raw input buffer 
9bb4			;       tokenise the words 
9bb4			;       malloc new copy (for looping etc) 
9bb4			;       copy to malloc + current pc in line to start of string and add line term 
9bb4			;       save on new rsp 
9bb4			; 
9bb4			 
9bb4			; hl to point to the line to tokenise 
9bb4			 
9bb4			;	push hl 
9bb4 22 e7 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9bb7			 
9bb7			;	ld a,0		; string term on input 
9bb7			;	call strlent 
9bb7			 
9bb7			;	ld (os_tok_len), hl	 ; save string length 
9bb7			 
9bb7			;if DEBUG_FORTH_TOK 
9bb7			;	ex de,hl		 
9bb7			;endif 
9bb7			 
9bb7			;	pop hl 		; get back string pointer 
9bb7			 
9bb7			if DEBUG_FORTH_TOK 
9bb7						DMARK "TOc" 
9bb7				CALLMONITOR 
9bb7			endif 
9bb7 7e			.cptoken2:    ld a,(hl) 
9bb8 23				inc hl 
9bb9 fe 7f			cp FORTH_END_BUFFER 
9bbb 28 29			jr z, .cptokendone2 
9bbd fe 00			cp 0 
9bbf 28 25			jr z, .cptokendone2 
9bc1 fe 22			cp '"' 
9bc3 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9bc5 fe 20			cp ' ' 
9bc7 20 ee			jr nz,  .cptoken2 
9bc9			 
9bc9			; TODO consume comments held between ( and ) 
9bc9			 
9bc9				; we have a space so change to zero term for dict match later 
9bc9 2b				dec hl 
9bca 3e 00			ld a,0 
9bcc 77				ld (hl), a 
9bcd 23				inc hl 
9bce 18 e7			jr .cptoken2 
9bd0				 
9bd0			 
9bd0			.cptokenstr2: 
9bd0				; skip all white space until either eol (because forgot to term) or end double quote 
9bd0			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9bd0				;inc hl ; skip current double quote 
9bd0 7e				ld a,(hl) 
9bd1 23				inc hl 
9bd2 fe 22			cp '"' 
9bd4 28 e1			jr z, .cptoken2 
9bd6 fe 7f			cp FORTH_END_BUFFER 
9bd8 28 0c			jr z, .cptokendone2 
9bda fe 00			cp 0 
9bdc 28 08			jr z, .cptokendone2 
9bde fe 20			cp ' ' 
9be0 28 02			jr z, .cptmp2 
9be2 18 ec			jr .cptokenstr2 
9be4			 
9be4			.cptmp2:	; we have a space so change to zero term for dict match later 
9be4				;dec hl 
9be4				;ld a,"-"	; TODO remove this when working 
9be4				;ld (hl), a 
9be4				;inc hl 
9be4 18 ea			jr .cptokenstr2 
9be6			 
9be6			.cptokendone2: 
9be6				;inc hl 
9be6 3e 7f			ld a, FORTH_END_BUFFER 
9be8 77				ld (hl),a 
9be9 23				inc hl 
9bea 3e 21			ld a, '!' 
9bec 77				ld (hl),a 
9bed			 
9bed 2a e7 e7			ld hl,(os_tok_ptr) 
9bf0			         
9bf0			if DEBUG_FORTH_TOK 
9bf0						DMARK "Tc1" 
9bf0				CALLMONITOR 
9bf0			endif 
9bf0			 
9bf0				; push exec string to top of return stack 
9bf0				FORTH_RSP_NEXT 
9bf0 cd e4 97			call macro_forth_rsp_next 
9bf3				endm 
# End of macro FORTH_RSP_NEXT
9bf3 c9				ret 
9bf4			 
9bf4			; Another go at the parser need to simplify the process 
9bf4			 
9bf4			forthparse: 
9bf4			 
9bf4			; 
9bf4			; line parse: 
9bf4			;       parse raw input buffer 
9bf4			;       tokenise the words 
9bf4			;       malloc new copy (for looping etc) 
9bf4			;       copy to malloc + current pc in line to start of string and add line term 
9bf4			;       save on new rsp 
9bf4			; 
9bf4			 
9bf4			; hl to point to the line to tokenise 
9bf4			 
9bf4			;	push hl 
9bf4 22 e7 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9bf7			 
9bf7			;	ld a,0		; string term on input 
9bf7			;	call strlent 
9bf7			 
9bf7			;	ld (os_tok_len), hl	 ; save string length 
9bf7			 
9bf7			;if DEBUG_FORTH_TOK 
9bf7			;	ex de,hl		 
9bf7			;endif 
9bf7			 
9bf7			;	pop hl 		; get back string pointer 
9bf7			 
9bf7			if DEBUG_FORTH_TOK 
9bf7						DMARK "TOK" 
9bf7				CALLMONITOR 
9bf7			endif 
9bf7 7e			.ptoken2:    ld a,(hl) 
9bf8 23				inc hl 
9bf9 fe 7f			cp FORTH_END_BUFFER 
9bfb 28 29			jr z, .ptokendone2 
9bfd fe 00			cp 0 
9bff 28 25			jr z, .ptokendone2 
9c01 fe 22			cp '"' 
9c03 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9c05 fe 20			cp ' ' 
9c07 20 ee			jr nz,  .ptoken2 
9c09			 
9c09			; TODO consume comments held between ( and ) 
9c09			 
9c09				; we have a space so change to zero term for dict match later 
9c09 2b				dec hl 
9c0a 3e 00			ld a,0 
9c0c 77				ld (hl), a 
9c0d 23				inc hl 
9c0e 18 e7			jr .ptoken2 
9c10				 
9c10			 
9c10			.ptokenstr2: 
9c10				; skip all white space until either eol (because forgot to term) or end double quote 
9c10			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c10				;inc hl ; skip current double quote 
9c10 7e				ld a,(hl) 
9c11 23				inc hl 
9c12 fe 22			cp '"' 
9c14 28 e1			jr z, .ptoken2 
9c16 fe 7f			cp FORTH_END_BUFFER 
9c18 28 0c			jr z, .ptokendone2 
9c1a fe 00			cp 0 
9c1c 28 08			jr z, .ptokendone2 
9c1e fe 20			cp ' ' 
9c20 28 02			jr z, .ptmp2 
9c22 18 ec			jr .ptokenstr2 
9c24			 
9c24			.ptmp2:	; we have a space so change to zero term for dict match later 
9c24				;dec hl 
9c24				;ld a,"-"	; TODO remove this when working 
9c24				;ld (hl), a 
9c24				;inc hl 
9c24 18 ea			jr .ptokenstr2 
9c26			 
9c26			.ptokendone2: 
9c26				;inc hl 
9c26 3e 7f			ld a, FORTH_END_BUFFER 
9c28 77				ld (hl),a 
9c29 23				inc hl 
9c2a 3e 21			ld a, '!' 
9c2c 77				ld (hl),a 
9c2d			 
9c2d 2a e7 e7			ld hl,(os_tok_ptr) 
9c30			         
9c30			if DEBUG_FORTH_TOK 
9c30						DMARK "TK1" 
9c30				CALLMONITOR 
9c30			endif 
9c30			 
9c30				; push exec string to top of return stack 
9c30				FORTH_RSP_NEXT 
9c30 cd e4 97			call macro_forth_rsp_next 
9c33				endm 
# End of macro FORTH_RSP_NEXT
9c33 c9				ret 
9c34			 
9c34			; 
9c34			;	; malloc size + buffer pointer + if is loop flag 
9c34			;	ld hl,(os_tok_len) 		 ; get string length 
9c34			; 
9c34			;	ld a,l 
9c34			; 
9c34			;	cp 0			; we dont want to use a null string 
9c34			;	ret z 
9c34			; 
9c34			;;	add 3    ; prefix malloc with buffer for current word ptr 
9c34			; 
9c34			;	add 5     ; TODO when certain not over writing memory remove 
9c34			; 
9c34			;		 
9c34			; 
9c34			;if DEBUG_FORTH_TOK 
9c34			;			DMARK "TKE" 
9c34			;	CALLMONITOR 
9c34			;endif 
9c34			; 
9c34			;	ld l,a 
9c34			;	ld h,0 
9c34			;;	push hl   ; save required space for the copy later 
9c34			;	call malloc 
9c34			;if DEBUG_FORTH_TOK 
9c34			;			DMARK "TKM" 
9c34			;	CALLMONITOR 
9c34			;endif 
9c34			;	if DEBUG_FORTH_MALLOC_GUARD 
9c34			;		push af 
9c34			;		call ishlzero 
9c34			;;		ld a, l 
9c34			;;		add h 
9c34			;;		cp 0 
9c34			;		pop af 
9c34			;		 
9c34			;		call z,malloc_error 
9c34			;	endif 
9c34			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9c34			; 
9c34			; 
9c34			;if DEBUG_FORTH_TOK 
9c34			;			DMARK "TKR" 
9c34			;	CALLMONITOR 
9c34			;endif 
9c34			; 
9c34			;	FORTH_RSP_NEXT 
9c34			; 
9c34			;	;inc hl	 ; go past current buffer pointer 
9c34			;	;inc hl 
9c34			;	;inc hl   ; and past if loop flag 
9c34			;		; TODO Need to set flag  
9c34			; 
9c34			;	 
9c34			;	 
9c34			;	ex de,hl	; malloc is dest 
9c34			;	ld hl, (os_tok_len) 
9c34			;;	pop bc 
9c34			;	ld c, l                
9c34			;	ld b,0 
9c34			;	ld hl, (os_tok_ptr) 
9c34			; 
9c34			;if DEBUG_FORTH_TOK 
9c34			;			DMARK "TKT" 
9c34			;	CALLMONITOR 
9c34			;endif 
9c34			; 
9c34			;	; do str cpy 
9c34			; 
9c34			;	ldir      ; copy byte in hl to de 
9c34			; 
9c34			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9c34			; 
9c34			;if DEBUG_FORTH_TOK 
9c34			; 
9c34			;			DMARK "TKY" 
9c34			;	CALLMONITOR 
9c34			;endif 
9c34			;	;ld a,0 
9c34			;	;ld a,FORTH_END_BUFFER 
9c34			;	ex de, hl 
9c34			;	;dec hl			 ; go back over the space delim at the end of word 
9c34			;	;ld (hl),a 
9c34			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9c34			;	ld a,FORTH_END_BUFFER 
9c34			;	ld (hl),a 
9c34			;	inc hl 
9c34			;	ld a,FORTH_END_BUFFER 
9c34			;	ld (hl),a 
9c34			; 
9c34			;	; init the malloc area data 
9c34			;	; set pc for in current area 
9c34			;	;ld hl, (os_tok_malloc) 
9c34			;	;inc hl 
9c34			;	;inc hl 
9c34			;	;inc hl 
9c34			;	;ex de,hl 
9c34			;	;ld hl, (os_tok_malloc) 
9c34			;	;ld (hl),e 
9c34			;	;inc hl 
9c34			;	;ld (hl),d 
9c34			; 
9c34			; 
9c34			;	ld hl,(os_tok_malloc) 
9c34			;if DEBUG_FORTH_PARSE_KEY 
9c34			;			DMARK "TKU" 
9c34			;	CALLMONITOR 
9c34			;endif 
9c34			; 
9c34			;	ret 
9c34			 
9c34			forthexec: 
9c34			 
9c34			; line exec: 
9c34			; forth parser 
9c34			 
9c34			; 
9c34			;       get current exec line on rsp 
9c34			 
9c34				FORTH_RSP_TOS 
9c34 cd fb 97			call macro_forth_rsp_tos 
9c37				endm 
# End of macro FORTH_RSP_TOS
9c37			 
9c37			;       restore current pc - hl points to malloc of data 
9c37			 
9c37				;ld e, (hl) 
9c37				;inc hl 
9c37				;ld d, (hl) 
9c37				;ex de,hl 
9c37			 
9c37			 
9c37			exec1: 
9c37 22 e7 e7			ld (os_tok_ptr), hl 
9c3a			 
9c3a				; copy our PC to working vars  
9c3a 22 b1 ec			ld (cli_ptr), hl 
9c3d 22 af ec			ld (cli_origptr), hl 
9c40			 
9c40 7e				ld a,(hl) 
9c41 fe 7f			cp FORTH_END_BUFFER 
9c43 c8				ret z 
9c44			 
9c44				; skip any nulls 
9c44			 
9c44 fe 00			cp 0 
9c46 20 03			jr nz, .execword 
9c48 23				inc hl 
9c49 18 ec			jr exec1 
9c4b			 
9c4b			 
9c4b			.execword: 
9c4b			 
9c4b			 
9c4b			 
9c4b			if DEBUG_FORTH_PARSE_KEY 
9c4b						DMARK "KYQ" 
9c4b				CALLMONITOR 
9c4b			endif 
9c4b			;       while at start of word: 
9c4b			; get start of dict (in user area first) 
9c4b			 
9c4b 21 30 d8		ld hl, baseram 
9c4e			;ld hl, sysdict 
9c4e 22 b3 ec		ld (cli_nextword),hl 
9c51			;           match word at pc 
9c51			;           exec word 
9c51			;           or push to dsp 
9c51			;           forward to next token 
9c51			;           if line term pop rsp and exit 
9c51			;        
9c51			 
9c51			if DEBUG_FORTH_PARSE_KEY 
9c51						DMARK "KYq" 
9c51				CALLMONITOR 
9c51			endif 
9c51			 
9c51			; 
9c51			; word comp 
9c51			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9c51			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9c51			;    move to start of word  
9c51			;    compare word to cli_token 
9c51			 
9c51			.execpnword:	; HL at start of a word in the dictionary to check 
9c51			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9c51			;	ld (cli_ptr), hl 
9c51			 
9c51 2a b3 ec			ld hl,(cli_nextword) 
9c54			 
9c54 cd f7 9c			call forth_tok_next 
9c57			; tok next start here 
9c57			;	; TODO skip compiled symbol for now 
9c57			;	inc hl 
9c57			; 
9c57			;	; save pointer to next word 
9c57			; 
9c57			;	; hl now points to the address of the next word pointer  
9c57			;	ld e, (hl) 
9c57			;	inc hl 
9c57			;	ld d, (hl) 
9c57			;	inc l 
9c57			; 
9c57			;	ex de,hl 
9c57			;if DEBUG_FORTH_PARSE_NEXTWORD 
9c57			;	push bc 
9c57			;	ld bc, (cli_nextword) 
9c57			;			DMARK "NXW" 
9c57			;	CALLMONITOR 
9c57			;	pop bc 
9c57			;endif 
9c57			; tok next end here 
9c57 22 b3 ec			ld (cli_nextword), hl     ; save for next check if no match on this word 
9c5a eb				ex de, hl 
9c5b			 
9c5b			 
9c5b				; save the pointer of the current token - 1 to check against 
9c5b				 
9c5b 22 b7 ec			ld (cli_token), hl   
9c5e				; TODO maybe remove below save if no debug 
9c5e				; save token string ptr for any debug later 
9c5e 23				inc hl  
9c5f 22 b9 ec			ld (cli_origtoken), hl 
9c62 2b				dec hl 
9c63				; save pointer to the start of the next dictionay word 
9c63 7e				ld a,(hl)   ; get string length 
9c64 47				ld b,a 
9c65			.execpnwordinc:  
9c65 23				inc hl 
9c66 10 fd			djnz .execpnwordinc 
9c68 22 b5 ec			ld (cli_execword), hl      ; save start of this words code 
9c6b			 
9c6b				; now check the word token against the string being parsed 
9c6b			 
9c6b 2a b7 ec			ld hl,(cli_token) 
9c6e 23				inc hl     ; skip string length (use zero term instead to end) 
9c6f 22 b7 ec			ld (cli_token), hl 
9c72			 
9c72			if DEBUG_FORTH_PARSE_KEY 
9c72						DMARK "KY2" 
9c72			endif 
9c72			if DEBUG_FORTH_PARSE_EXEC 
9c72				; see if disabled 
9c72			 
9c72				ld a, (os_view_disable) 
9c72				cp '*' 
9c72				jr z, .skip 
9c72			 
9c72				push hl 
9c72				push hl 
9c72				call clear_display 
9c72				ld de, .compword 
9c72				ld a, display_row_1 
9c72				call str_at_display 
9c72				pop de 
9c72				ld a, display_row_2 
9c72				call str_at_display 
9c72				ld hl,(cli_ptr) 
9c72				ld a,(hl) 
9c72			        ld hl, os_word_scratch 
9c72				ld (hl),a 
9c72				ld a,0 
9c72				inc hl 
9c72				ld (hl),a 	 
9c72				ld de, os_word_scratch 
9c72				ld a, display_row_2+10 
9c72				call str_at_display 
9c72				call update_display 
9c72				ld a, 100 
9c72				call aDelayInMS 
9c72				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9c72				call delay250ms 
9c72				endif 
9c72				pop hl 
9c72			.skip:  
9c72			endif	 
9c72			.execpnchar:    ; compare char between token and string to parse 
9c72			 
9c72			if DEBUG_FORTH_PARSE_KEY 
9c72						DMARK "Ky3" 
9c72			endif 
9c72			if DEBUG_FORTH_PARSE_EXEC 
9c72				; see if disabled 
9c72			 
9c72				ld a, (os_view_disable) 
9c72				cp '*' 
9c72				jr z, .skip2 
9c72			 
9c72			;	call clear_display 
9c72			ld hl,(cli_token) 
9c72			ld a,(hl) 
9c72			ld (os_word_scratch),a 
9c72				ld hl,(cli_ptr) 
9c72			ld a,(hl) 
9c72				ld (os_word_scratch+1),a 
9c72				ld a,0 
9c72				ld (os_word_scratch+2),a 
9c72				ld de,os_word_scratch 
9c72				ld a,display_row_4 
9c72				call str_at_display 
9c72				call update_display 
9c72			.skip2:  
9c72			endif 
9c72 2a b7 ec			ld hl,(cli_token) 
9c75 7e				ld a, (hl)	 ; char in word token 
9c76 23				inc hl 		; move to next char 
9c77 22 b7 ec			ld (cli_token), hl ; and save it 
9c7a 47				ld b,a 
9c7b			 
9c7b 2a b1 ec			ld hl,(cli_ptr) ;	get the char from the string to parse 
9c7e 7e				ld a,(hl) 
9c7f 23				inc hl 
9c80 22 b1 ec			ld (cli_ptr), hl		; move to next char 
9c83 cd be 8e			call toUpper 		; make sure the input string matches case 
9c86			 
9c86			if DEBUG_FORTH_PARSE 
9c86			endif 
9c86			 
9c86				; input stream end of token is a space so get rid of it 
9c86			 
9c86			;	cp ' ' 
9c86			;	jr nz, .pnskipspace 
9c86			; 
9c86			;	ld a, 0		; make same term as word token term 
9c86			; 
9c86			;.pnskipspace: 
9c86			 
9c86			if DEBUG_FORTH_PARSE_KEY 
9c86						DMARK "KY7" 
9c86			endif 
9c86 b8				cp b 
9c87 c2 9d 9c			jp nz, .execpnskipword	 ; no match so move to next word 
9c8a				 
9c8a			;    if same 
9c8a			;       scan for string terms 0 for token and 32 for input 
9c8a			 
9c8a				 
9c8a			if DEBUG_FORTH_PARSE_KEY 
9c8a						DMARK "KY8" 
9c8a			endif 
9c8a			 
9c8a 80				add b			 
9c8b fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9c8d							; TODO need to make sure last word in zero term string is accounted for 
9c8d 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9c8f			 
9c8f			 
9c8f				; at end of both strings so both are exact match 
9c8f			 
9c8f			;       skip ptr for next word 
9c8f			 
9c8f 2a b1 ec			ld hl,(cli_ptr) 	; at input string term 
9c92 23				inc hl			 ; at next char 
9c93 22 b1 ec			ld (cli_ptr), hl     ; save for next round of the parser 
9c96 22 af ec			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9c99				 
9c99				 
9c99			if DEBUG_FORTH_PARSE_KEY 
9c99						DMARK "KY3" 
9c99			endif 
9c99			 
9c99			 
9c99			 
9c99			;       exec code block 
9c99			if DEBUG_FORTH_JP 
9c99				call clear_display 
9c99				call update_display 
9c99				call delay1s 
9c99				ld hl, (cli_execword)     ; save for next check if no match on this word 
9c99				ld a,h 
9c99				ld hl, os_word_scratch 
9c99				call hexout 
9c99				ld hl, (cli_execword)     ; save for next check if no match on this word 
9c99				ld a,l 
9c99				ld hl, os_word_scratch+2 
9c99				call hexout 
9c99				ld hl, os_word_scratch+4 
9c99				ld a,0 
9c99				ld (hl),a 
9c99				ld de,os_word_scratch 
9c99				call str_at_display 
9c99					ld a, display_row_2 
9c99					call str_at_display 
9c99				ld de, (cli_origtoken) 
9c99				ld a, display_row_1+10 
9c99					call str_at_display 
9c99			 
9c99				ld a,display_row_1 
9c99				ld de, .foundword 
9c99				ld a, display_row_3 
9c99				call str_at_display 
9c99				call update_display 
9c99				call delay1s 
9c99				call delay1s 
9c99				call delay1s 
9c99			endif 
9c99			 
9c99			if DEBUG_FORTH_PARSE_KEY 
9c99						DMARK "KYj" 
9c99			endif 
9c99				; TODO save the word pointer in this exec 
9c99			 
9c99 2a b5 ec			ld hl,(cli_execword) 
9c9c e9				jp (hl) 
9c9d			 
9c9d			 
9c9d			;    if not same 
9c9d			;	scan for zero term 
9c9d			;	get ptr for next word 
9c9d			;	goto word comp 
9c9d			 
9c9d			.execpnskipword:	; get pointer to next word 
9c9d 2a b3 ec			ld hl,(cli_nextword) 
9ca0			 
9ca0 7e				ld a,(hl) 
9ca1 fe 00			cp WORD_SYS_END 
9ca3			;	cp 0 
9ca3 28 09			jr z, .execendofdict			 ; at end of words 
9ca5			 
9ca5			if DEBUG_FORTH_PARSE_KEY 
9ca5						DMARK "KY4" 
9ca5			endif 
9ca5			if DEBUG_FORTH_PARSE_EXEC 
9ca5			 
9ca5				; see if disabled 
9ca5			 
9ca5				ld a, (os_view_disable) 
9ca5				cp '*' 
9ca5				jr z, .noskip 
9ca5			 
9ca5			 
9ca5				ld de, .nowordfound 
9ca5				ld a, display_row_3 
9ca5				call str_at_display 
9ca5				call update_display 
9ca5				ld a, 100 
9ca5				call aDelayInMS 
9ca5				 
9ca5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9ca5					call delay250ms 
9ca5				endif 
9ca5			.noskip:  
9ca5			 
9ca5			endif	 
9ca5			 
9ca5 2a af ec			ld hl,(cli_origptr) 
9ca8 22 b1 ec			ld (cli_ptr),hl 
9cab			 
9cab			if DEBUG_FORTH_PARSE_KEY 
9cab						DMARK "KY5" 
9cab			endif 
9cab c3 51 9c			jp .execpnword			; else go to next word 
9cae			 
9cae			.execendofdict:  
9cae			 
9cae			if DEBUG_FORTH_PARSE_KEY 
9cae						DMARK "KYe" 
9cae			endif 
9cae			if DEBUG_FORTH_PARSE_EXEC 
9cae				; see if disabled 
9cae			 
9cae				ld a, (os_view_disable) 
9cae				cp '*' 
9cae				jr z, .ispskip 
9cae			 
9cae				call clear_display 
9cae				call update_display 
9cae				call delay1s 
9cae				ld de, (cli_origptr) 
9cae				ld a, display_row_1 
9cae				call str_at_display 
9cae				 
9cae				ld de, .enddict 
9cae				ld a, display_row_3 
9cae				call str_at_display 
9cae				call update_display 
9cae				ld a, 100 
9cae				call aDelayInMS 
9cae				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9cae				call delay1s 
9cae				call delay1s 
9cae				call delay1s 
9cae				endif 
9cae			.ispskip:  
9cae				 
9cae			endif	 
9cae			 
9cae			 
9cae			 
9cae				; if the word is not a keyword then must be a literal so push it to stack 
9cae			 
9cae			; push token to stack to end of word 
9cae			 
9cae				STACKFRAME ON $1efe $2f9f 
9cae				if DEBUG_STACK_IMB 
9cae					if ON 
9cae						exx 
9cae						ld de, $1efe 
9cae						ld a, d 
9cae						ld hl, curframe 
9cae						call hexout 
9cae						ld a, e 
9cae						ld hl, curframe+2 
9cae						call hexout 
9cae						ld hl, $1efe 
9cae						push hl 
9cae						ld hl, $2f9f 
9cae						push hl 
9cae						exx 
9cae					endif 
9cae				endif 
9cae			endm 
# End of macro STACKFRAME
9cae			 
9cae 2a e7 e7		ld hl,(os_tok_ptr) 
9cb1 cd a6 99		call forth_apush 
9cb4			 
9cb4				STACKFRAMECHK ON $1efe $2f9f 
9cb4				if DEBUG_STACK_IMB 
9cb4					if ON 
9cb4						exx 
9cb4						ld hl, $2f9f 
9cb4						pop de   ; $2f9f 
9cb4						call cmp16 
9cb4						jr nz, .spnosame 
9cb4						ld hl, $1efe 
9cb4						pop de   ; $1efe 
9cb4						call cmp16 
9cb4						jr z, .spfrsame 
9cb4						.spnosame: call showsperror 
9cb4						.spfrsame: nop 
9cb4						exx 
9cb4					endif 
9cb4				endif 
9cb4			endm 
# End of macro STACKFRAMECHK
9cb4			 
9cb4			execnext: 
9cb4			 
9cb4			if DEBUG_FORTH_PARSE_KEY 
9cb4						DMARK "KY>" 
9cb4			endif 
9cb4			; move past token to next word 
9cb4			 
9cb4 2a e7 e7		ld hl, (os_tok_ptr) 
9cb7 3e 00		ld a, 0 
9cb9 01 ff 00		ld bc, 255     ; input buffer size 
9cbc ed b1		cpir 
9cbe			 
9cbe			if DEBUG_FORTH_PARSE_KEY 
9cbe						DMARK "KY!" 
9cbe				CALLMONITOR 
9cbe			endif	 
9cbe			; TODO this might place hl on the null, so will need to forward on??? 
9cbe			;inc hl   ; see if this gets onto the next item 
9cbe			 
9cbe			 
9cbe			; TODO pass a pointer to the buffer to push 
9cbe			; TODO call function to push 
9cbe			 
9cbe			; look for end of input 
9cbe			 
9cbe			;inc hl 
9cbe			;ld a,(hl) 
9cbe			;cp FORTH_END_BUFFER 
9cbe			;ret z 
9cbe			 
9cbe			 
9cbe c3 37 9c		jp exec1 
9cc1			 
9cc1			 
9cc1			 
9cc1			 
9cc1			 
9cc1			 
9cc1			 
9cc1			 
9cc1			 
9cc1			findnexttok: 
9cc1			 
9cc1				; hl is pointer to move 
9cc1				; de is the token to locate 
9cc1			 
9cc1					if DEBUG_FORTH 
9cc1						DMARK "NTK" 
9cc1						CALLMONITOR 
9cc1					endif 
9cc1 d5				push de 
9cc2			 
9cc2			.fnt1:	 
9cc2				; find first char of token to locate 
9cc2			 
9cc2 1a				ld a, (de) 
9cc3 4f				ld c,a 
9cc4 7e				ld a,(hl) 
9cc5 cd be 8e			call toUpper 
9cc8					if DEBUG_FORTH 
9cc8						DMARK "NT1" 
9cc8						CALLMONITOR 
9cc8					endif 
9cc8 b9				cp c 
9cc9			 
9cc9 28 03			jr z, .fnt2cmpmorefirst	 
9ccb			 
9ccb				; first char not found move to next char 
9ccb			 
9ccb 23				inc hl 
9ccc 18 f4			jr .fnt1 
9cce			 
9cce			.fnt2cmpmorefirst:	 
9cce				; first char of token found.  
9cce			 
9cce e5				push hl     ; save start of token just in case it is the right one 
9ccf d9				exx 
9cd0 e1				pop hl        ; save it to hl' 
9cd1 d9				exx 
9cd2			 
9cd2			 
9cd2			.fnt2cmpmore:	 
9cd2				; compare the rest 
9cd2				 
9cd2 23				inc hl 
9cd3 13				inc de 
9cd4				 
9cd4 1a				ld a, (de) 
9cd5 4f				ld c,a 
9cd6 7e				ld a,(hl) 
9cd7 cd be 8e			call toUpper 
9cda			 
9cda					if DEBUG_FORTH 
9cda						DMARK "NT2" 
9cda						CALLMONITOR 
9cda					endif 
9cda				; c has the token to find char 
9cda				; a has the mem to scan char 
9cda			 
9cda b9				cp c 
9cdb 28 04			jr z,.fntmatch1 
9cdd			 
9cdd				; they are not the same 
9cdd			 
9cdd					if DEBUG_FORTH 
9cdd						DMARK "NT3" 
9cdd						CALLMONITOR 
9cdd					endif 
9cdd d1				pop de	; reset de token to look for 
9cde d5				push de 
9cdf 18 e1			jr .fnt1 
9ce1				 
9ce1			.fntmatch1: 
9ce1			 
9ce1				; is the same char a null which means we might have a full hit? 
9ce1					if DEBUG_FORTH 
9ce1						DMARK "NT4" 
9ce1						CALLMONITOR 
9ce1					endif 
9ce1			 
9ce1 fe 00			cp 0 
9ce3 28 0b			jr z, .fntmatchyes 
9ce5			 
9ce5				; are we at the end of the token to find? 
9ce5			 
9ce5					if DEBUG_FORTH 
9ce5						DMARK "NT5" 
9ce5						CALLMONITOR 
9ce5					endif 
9ce5 3e 00			ld a, 0 
9ce7 b9				cp c 
9ce8			 
9ce8 c2 d2 9c			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9ceb			 
9ceb					if DEBUG_FORTH 
9ceb						DMARK "NT6" 
9ceb						CALLMONITOR 
9ceb					endif 
9ceb				; token to find is exhusted but no match to stream 
9ceb			 
9ceb				; restore tok pointer and continue on 
9ceb d1				pop de 
9cec d5				push de 
9ced c3 c2 9c			jp .fnt1 
9cf0			 
9cf0			 
9cf0			.fntmatchyes: 
9cf0			 
9cf0				; hl now contains the end of the found token 
9cf0			 
9cf0				; get rid of saved token pointer to find 
9cf0			 
9cf0 d1				pop de 
9cf1			 
9cf1					if DEBUG_FORTH 
9cf1						DMARK "NT9" 
9cf1						CALLMONITOR 
9cf1					endif 
9cf1			 
9cf1				; hl will be on the null term so forward on 
9cf1			 
9cf1				; get back the saved start of the token 
9cf1			 
9cf1 d9				exx 
9cf2 e5				push hl     ; save start of token just in case it is the right one 
9cf3 d9				exx 
9cf4 e1				pop hl        ; save it to hl 
9cf5			 
9cf5 c9				ret 
9cf6			 
9cf6			 
9cf6			; LIST needs to find a specific token   
9cf6			; FORGET needs to find a spefici token 
9cf6			 
9cf6			; SAVE needs to find all tokens by flag 
9cf6			; WORDS just needs to scan through all  by flag 
9cf6			; UWORDS needs to scan through all by flag 
9cf6			 
9cf6			 
9cf6			; given hl as pointer to start of dict look up string 
9cf6			; return hl as pointer to start of word block 
9cf6			; or 0 if not found 
9cf6			 
9cf6			forth_find_tok: 
9cf6 c9				ret 
9cf7			 
9cf7			; given hl as pointer to dict structure 
9cf7			; move to the next dict block structure 
9cf7			 
9cf7			forth_tok_next: 
9cf7				; hl now points to the address of the next word pointer  
9cf7				; TODO skip compiled symbol for now 
9cf7			;	push de 
9cf7 23				inc hl 
9cf8 5e				ld e, (hl) 
9cf9 23				inc hl 
9cfa 56				ld d, (hl) 
9cfb 23				inc hl 
9cfc			 
9cfc eb				ex de,hl 
9cfd			if DEBUG_FORTH_PARSE_NEXTWORD 
9cfd				push bc 
9cfd				ld bc, (cli_nextword) 
9cfd						DMARK "NXW" 
9cfd				CALLMONITOR 
9cfd				pop bc 
9cfd			endif 
9cfd			;	pop de	 
9cfd c9				ret 
9cfe			 
9cfe			 
9cfe			 
9cfe			; eof 
# End of file forth_parserv5.asm
9cfe				include "forth_wordsv4.asm" 
9cfe			 
9cfe			; the core word dictionary v4 
9cfe			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9cfe			 
9cfe			; this is a linked list for each of the system words used 
9cfe			; user defined words will follow the same format but will be in ram 
9cfe			 
9cfe			 
9cfe			; 
9cfe			; 
9cfe			; define linked list: 
9cfe			; 
9cfe			; 1. compiled byte op code 
9cfe			; 2. len of text word 
9cfe			; 3. text word 
9cfe			; 4. ptr to next dictionary word 
9cfe			; 5. asm, calls etc for the word 
9cfe			; 
9cfe			;  if 1 == 0 then last word in dict  
9cfe			;   
9cfe			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9cfe			;  
9cfe			;  
9cfe			; create basic standard set of words 
9cfe			; 
9cfe			;  
9cfe			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9cfe			; 2DUP 2DROP 2SWAP  
9cfe			; @ C@ - get byte  
9cfe			; ! C! - store byte 
9cfe			; 0< true if less than zero 
9cfe			; 0= true if zero 
9cfe			; < >  
9cfe			; = true if same 
9cfe			; variables 
9cfe			 
9cfe			 
9cfe			; Hardware specific words I may need 
9cfe			; 
9cfe			; IN OUT  
9cfe			; calls to key util functions 
9cfe			; calls to hardward abstraction stuff 
9cfe			; easy control of frame buffers and lcd i/o 
9cfe			; keyboard  
9cfe			 
9cfe			 
9cfe			;DICT: macro 
9cfe			; op_code, len, word, next 
9cfe			;    word: 
9cfe			;    db op_code 
9cfe			;    ds word zero term 
9cfe			;    dw next 
9cfe			;    endm 
9cfe			 
9cfe			 
9cfe			 
9cfe			 
9cfe			; op code 1 is a flag for user define words which are to be handled differently 
9cfe			 
9cfe			 
9cfe			; 
9cfe			; 
9cfe			;    TODO on entry to a word this should be the expected environment 
9cfe			;    hl - tos value if number then held, if string this is the ptr 
9cfe			;    de -  
9cfe			 
9cfe			 
9cfe			; opcode ranges 
9cfe			; 0 - end of word dict 
9cfe			; 255 - user define words 
9cfe			 
9cfe			sysdict: 
9cfe			include "forth_opcodes.asm" 
9cfe			; op codes for forth keywords 
9cfe			; free to use code 0  
9cfe				OPCODE_HEAP: equ  1 
9cfe				OPCODE_EXEC: equ 2 
9cfe				OPCODE_DUP: equ 3 
9cfe				OPCODE_SWAP: equ 4 
9cfe				OPCODE_COLN: equ 5 
9cfe				OPCODE_SCOLN: equ 6 
9cfe				OPCODE_DROP: equ 7 
9cfe				OPCODE_DUP2: equ 8 
9cfe				OPCODE_DROP2: equ 9 
9cfe				OPCODE_SWAP2: equ 10 
9cfe				OPCODE_AT: equ 11 
9cfe				OPCODE_CAT: equ 12 
9cfe				OPCODE_BANG: equ 13 
9cfe				OPCODE_CBANG: equ 14 
9cfe				OPCODE_SCALL: equ 15 
9cfe				OPCODE_DEPTH: equ 16 
9cfe				OPCODE_OVER: equ 17 
9cfe				OPCODE_PAUSE: equ 18 
9cfe				OPCODE_PAUSES: equ 19 
9cfe				OPCODE_ROT: equ 20 
9cfe			;free to reuse	OPCODE_WORDS: equ 21 
9cfe			        OPCODE_NOT: equ 21 
9cfe				OPCODE_UWORDS: equ 22 
9cfe				OPCODE_BP: equ 23 
9cfe				OPCODE_MONITOR: equ 24  
9cfe				OPCODE_MALLOC: equ 25 
9cfe				OPCODE_FREE: equ 26 
9cfe				OPCODE_LIST: equ 27 
9cfe				OPCODE_FORGET: equ 28 
9cfe				OPCODE_NOP: equ 29 
9cfe				OPCODE_COMO: equ 30 
9cfe				OPCODE_COMC: equ 31 
9cfe			;free to reuse	OPCODE_ENDCORE: equ 32 
9cfe				OPCODE_AFTERSOUND: equ 33 
9cfe				OPCODE_GP2: equ 34 
9cfe				OPCODE_GP3: equ 35 
9cfe				OPCODE_GP4: equ 36 
9cfe				OPCODE_SIN: equ 37 
9cfe				OPCODE_SOUT: equ 38 
9cfe				OPCODE_SPIO: equ 39 
9cfe				OPCODE_SPICEH: equ 40 
9cfe				OPCODE_SPIOb: equ 41 
9cfe				OPCODE_SPII: equ 42 
9cfe				OPCODE_SESEL: equ 43 
9cfe				OPCODE_CARTDEV: equ 44 
9cfe			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9cfe				OPCODE_FB: equ 46 
9cfe				OPCODE_EMIT: equ 47 
9cfe				OPCODE_DOTH: equ 48 
9cfe				OPCODE_DOTF: equ 49 
9cfe				OPCODE_DOT: equ 50 
9cfe				OPCODE_CLS: equ 51 
9cfe				OPCODE_DRAW: equ 52 
9cfe				OPCODE_DUMP: equ 53 
9cfe				OPCODE_CDUMP: equ 54 
9cfe				OPCODE_DAT: equ 55 
9cfe				OPCODE_HOME: equ 56 
9cfe				OPCODE_SPACE: equ 57 
9cfe				OPCODE_SPACES: equ 58 
9cfe				OPCODE_SCROLL: equ 59 
9cfe				OPCODE_ATQ: equ 60 
9cfe				OPCODE_AUTODSP: equ 61 
9cfe				OPCODE_MENU: equ 62 
9cfe			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9cfe				OPCODE_THEN: equ 64 
9cfe				OPCODE_ELSE: equ 65 
9cfe				OPCODE_DO: equ 66 
9cfe				OPCODE_LOOP: equ 67 
9cfe				OPCODE_I: equ 68 
9cfe				OPCODE_DLOOP: equ 69  
9cfe				OPCODE_REPEAT: equ 70  
9cfe				OPCODE_UNTIL: equ 71 
9cfe				OPCODE_ENDFLOW: equ 72 
9cfe				OPCODE_WAITK: equ 73 
9cfe				OPCODE_ACCEPT: equ 74 
9cfe				OPCODE_EDIT: equ 75 
9cfe			;free to reuse	OPCODE_ENDKEY: equ 76 
9cfe				OPCODE_LZERO: equ 77 
9cfe				OPCODE_TZERO: equ 78 
9cfe				OPCODE_LESS: equ 79 
9cfe				OPCODE_GT: equ 80 
9cfe				OPCODE_EQUAL: equ 81  
9cfe			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9cfe				OPCODE_NEG: equ 83 
9cfe				OPCODE_DIV: equ 84 
9cfe				OPCODE_MUL: equ 85 
9cfe				OPCODE_MIN: equ 86 
9cfe				OPCODE_MAX: equ 87 
9cfe				OPCODE_RND16: equ 88 
9cfe				OPCODE_RND8: equ 89 
9cfe				OPCODE_RND: equ 90 
9cfe			;free to reuse	OPCODE_ENDMATHS: equ 91  
9cfe				OPCODE_BYNAME: equ 92 
9cfe				OPCODE_DIR: equ 93 
9cfe				OPCODE_SAVE: equ 94 
9cfe				OPCODE_LOAD: equ 95 
9cfe				OPCODE_BSAVE: equ 96 
9cfe				OPCODE_BLOAD: equ 97 
9cfe				OPCODE_SEO: equ 98  
9cfe				OPCODE_SEI: equ 99 
9cfe				OPCODE_SFREE: equ 100 
9cfe				OPCODE_SIZE: equ 101 
9cfe				OPCODE_CREATE: equ 102 
9cfe				OPCODE_APPEND: equ 103 
9cfe				OPCODE_SDEL: equ 104 
9cfe				OPCODE_OPEN: equ 105 
9cfe				OPCODE_READ: equ 106 
9cfe				OPCODE_EOF: equ 106 
9cfe				OPCODE_FORMAT: equ 107 
9cfe				OPCODE_LABEL: equ 108 
9cfe				OPCODE_LABELS: equ 109 
9cfe			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9cfe				OPCODE_UPPER: equ 111 
9cfe				OPCODE_LOWER: equ 112 
9cfe				OPCODE_SUBSTR: equ 113 
9cfe				OPCODE_LEFT: equ 114 
9cfe				OPCODE_RIGHT: equ 115 
9cfe				OPCODE_STR2NUM: equ 116 
9cfe				OPCODE_NUM2STR: equ 117 
9cfe				OPCODE_CONCAT: equ 118 
9cfe				OPCODE_FIND: equ 119 
9cfe				OPCODE_LEN: equ 120 
9cfe				OPCODE_CHAR: equ 121 
9cfe			; free to reuse	OPCODE_STRLEN: equ 122 
9cfe			; free to reuse	OPCODE_ENDSTR: equ 123 
9cfe				OPCODE_V0S: equ 124 
9cfe				OPCODE_V0Q: equ 125 
9cfe				OPCODE_V1S: equ 126 
9cfe				OPCODE_V1Q: equ 127 
9cfe				OPCODE_V2S: equ 128 
9cfe				OPCODE_V2Q: equ 129 
9cfe				OPCODE_V3S: equ 130 
9cfe				OPCODE_V3Q: equ 131 
9cfe			;free to reuse	OPCODE_END: equ 132 
9cfe				OPCODE_ZDUP: equ 133 
9cfe			 
9cfe			; eof 
# End of file forth_opcodes.asm
9cfe			 
9cfe			include "forth_words_core.asm" 
9cfe			 
9cfe			; | ## Core Words 
9cfe			 
9cfe			;if MALLOC_4 
9cfe			 
9cfe			.HEAP: 
9cfe				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9cfe 15				db WORD_SYS_CORE+OPCODE_HEAP             
9cff 3d 9d			dw .EXEC            
9d01 05				db 4 + 1 
9d02 .. 00			db "HEAP",0              
9d07				endm 
# End of macro CWHEAD
9d07			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9d07			; | | u1 - Current number of bytes in the heap 
9d07			; | | u2 - Remaining bytes left on the heap 
9d07			; | |  
9d07			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9d07			 
9d07			 
9d07					if DEBUG_FORTH_WORDS_KEY 
9d07						DMARK "HEP" 
9d07 f5				push af  
9d08 3a 1c 9d			ld a, (.dmark)  
9d0b 32 c0 ee			ld (debug_mark),a  
9d0e 3a 1d 9d			ld a, (.dmark+1)  
9d11 32 c1 ee			ld (debug_mark+1),a  
9d14 3a 1e 9d			ld a, (.dmark+2)  
9d17 32 c2 ee			ld (debug_mark+2),a  
9d1a 18 03			jr .pastdmark  
9d1c ..			.dmark: db "HEP"  
9d1f f1			.pastdmark: pop af  
9d20			endm  
# End of macro DMARK
9d20						CALLMONITOR 
9d20 cd b0 92			call break_point_state  
9d23				endm  
# End of macro CALLMONITOR
9d23					endif 
9d23 2a 3a d8				ld hl, (free_list )      
9d26 11 3f d8				ld de, heap_start 
9d29			 
9d29 ed 52				sbc hl, de  
9d2b			 
9d2b cd 3d 98				call forth_push_numhl 
9d2e			 
9d2e			 
9d2e ed 5b 3a d8			ld de, (free_list )      
9d32 21 cc e4				ld hl, heap_end 
9d35			 
9d35 ed 52				sbc hl, de 
9d37			 
9d37 cd 3d 98				call forth_push_numhl 
9d3a					 
9d3a			 
9d3a					 
9d3a			 
9d3a			 
9d3a			 
9d3a					NEXTW 
9d3a c3 a6 9b			jp macro_next 
9d3d				endm 
# End of macro NEXTW
9d3d			;endif 
9d3d			 
9d3d			.EXEC: 
9d3d				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9d3d 16				db WORD_SYS_CORE+OPCODE_EXEC             
9d3e d9 9d			dw .STKEXEC            
9d40 05				db 4 + 1 
9d41 .. 00			db "EXEC",0              
9d46				endm 
# End of macro CWHEAD
9d46			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
9d46			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9d46			; | | 
9d46			; | |   
9d46				STACKFRAME OFF $5efe $5f9f 
9d46				if DEBUG_STACK_IMB 
9d46					if OFF 
9d46						exx 
9d46						ld de, $5efe 
9d46						ld a, d 
9d46						ld hl, curframe 
9d46						call hexout 
9d46						ld a, e 
9d46						ld hl, curframe+2 
9d46						call hexout 
9d46						ld hl, $5efe 
9d46						push hl 
9d46						ld hl, $5f9f 
9d46						push hl 
9d46						exx 
9d46					endif 
9d46				endif 
9d46			endm 
# End of macro STACKFRAME
9d46			 
9d46					if DEBUG_FORTH_WORDS_KEY 
9d46						DMARK "EXE" 
9d46 f5				push af  
9d47 3a 5b 9d			ld a, (.dmark)  
9d4a 32 c0 ee			ld (debug_mark),a  
9d4d 3a 5c 9d			ld a, (.dmark+1)  
9d50 32 c1 ee			ld (debug_mark+1),a  
9d53 3a 5d 9d			ld a, (.dmark+2)  
9d56 32 c2 ee			ld (debug_mark+2),a  
9d59 18 03			jr .pastdmark  
9d5b ..			.dmark: db "EXE"  
9d5e f1			.pastdmark: pop af  
9d5f			endm  
# End of macro DMARK
9d5f						CALLMONITOR 
9d5f cd b0 92			call break_point_state  
9d62				endm  
# End of macro CALLMONITOR
9d62					endif 
9d62			 
9d62				FORTH_DSP_VALUEHL 
9d62 cd 34 9a			call macro_dsp_valuehl 
9d65				endm 
# End of macro FORTH_DSP_VALUEHL
9d65			 
9d65				FORTH_DSP_POP 
9d65 cd ec 9a			call macro_forth_dsp_pop 
9d68				endm 
# End of macro FORTH_DSP_POP
9d68			 
9d68					if DEBUG_FORTH_WORDS 
9d68						DMARK "EX1" 
9d68 f5				push af  
9d69 3a 7d 9d			ld a, (.dmark)  
9d6c 32 c0 ee			ld (debug_mark),a  
9d6f 3a 7e 9d			ld a, (.dmark+1)  
9d72 32 c1 ee			ld (debug_mark+1),a  
9d75 3a 7f 9d			ld a, (.dmark+2)  
9d78 32 c2 ee			ld (debug_mark+2),a  
9d7b 18 03			jr .pastdmark  
9d7d ..			.dmark: db "EX1"  
9d80 f1			.pastdmark: pop af  
9d81			endm  
# End of macro DMARK
9d81						CALLMONITOR 
9d81 cd b0 92			call break_point_state  
9d84				endm  
# End of macro CALLMONITOR
9d84					endif 
9d84			;	ld e,(hl) 
9d84			;	inc hl 
9d84			;	ld d,(hl) 
9d84			;	ex de,hl 
9d84			 
9d84			;		if DEBUG_FORTH_WORDS 
9d84			;			DMARK "EX2" 
9d84			;			CALLMONITOR 
9d84			;		endif 
9d84 e5				push hl 
9d85			 
9d85				;ld a, 0 
9d85				;ld a, FORTH_END_BUFFER 
9d85 cd c7 8e			call strlenz 
9d88 23				inc hl   ; include zero term to copy 
9d89 23				inc hl   ; include term 
9d8a 23				inc hl   ; include term 
9d8b 06 00			ld b,0 
9d8d 4d				ld c,l 
9d8e e1				pop hl 
9d8f 11 e5 e5			ld de, execscratch 
9d92					if DEBUG_FORTH_WORDS 
9d92						DMARK "EX3" 
9d92 f5				push af  
9d93 3a a7 9d			ld a, (.dmark)  
9d96 32 c0 ee			ld (debug_mark),a  
9d99 3a a8 9d			ld a, (.dmark+1)  
9d9c 32 c1 ee			ld (debug_mark+1),a  
9d9f 3a a9 9d			ld a, (.dmark+2)  
9da2 32 c2 ee			ld (debug_mark+2),a  
9da5 18 03			jr .pastdmark  
9da7 ..			.dmark: db "EX3"  
9daa f1			.pastdmark: pop af  
9dab			endm  
# End of macro DMARK
9dab						CALLMONITOR 
9dab cd b0 92			call break_point_state  
9dae				endm  
# End of macro CALLMONITOR
9dae					endif 
9dae ed b0			ldir 
9db0			 
9db0			 
9db0 21 e5 e5			ld hl, execscratch 
9db3			 
9db3					if DEBUG_FORTH_WORDS 
9db3						DMARK "EXe" 
9db3 f5				push af  
9db4 3a c8 9d			ld a, (.dmark)  
9db7 32 c0 ee			ld (debug_mark),a  
9dba 3a c9 9d			ld a, (.dmark+1)  
9dbd 32 c1 ee			ld (debug_mark+1),a  
9dc0 3a ca 9d			ld a, (.dmark+2)  
9dc3 32 c2 ee			ld (debug_mark+2),a  
9dc6 18 03			jr .pastdmark  
9dc8 ..			.dmark: db "EXe"  
9dcb f1			.pastdmark: pop af  
9dcc			endm  
# End of macro DMARK
9dcc						CALLMONITOR 
9dcc cd b0 92			call break_point_state  
9dcf				endm  
# End of macro CALLMONITOR
9dcf					endif 
9dcf			 
9dcf cd f4 9b			call forthparse 
9dd2 cd 34 9c			call forthexec 
9dd5			;	call forthexec_cleanup 
9dd5			;	call forthparse 
9dd5			;	call forthexec 
9dd5			 
9dd5				STACKFRAMECHK OFF $5efe $5f9f 
9dd5				if DEBUG_STACK_IMB 
9dd5					if OFF 
9dd5						exx 
9dd5						ld hl, $5f9f 
9dd5						pop de   ; $5f9f 
9dd5						call cmp16 
9dd5						jr nz, .spnosame 
9dd5						ld hl, $5efe 
9dd5						pop de   ; $5efe 
9dd5						call cmp16 
9dd5						jr z, .spfrsame 
9dd5						.spnosame: call showsperror 
9dd5						.spfrsame: nop 
9dd5						exx 
9dd5					endif 
9dd5				endif 
9dd5			endm 
# End of macro STACKFRAMECHK
9dd5			 
9dd5				; an immediate word so no need to process any more words 
9dd5 c9				ret 
9dd6				NEXTW 
9dd6 c3 a6 9b			jp macro_next 
9dd9				endm 
# End of macro NEXTW
9dd9			 
9dd9			; dead code - old version  
9dd9			;	FORTH_RSP_NEXT 
9dd9			 
9dd9			;  
9dd9			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9dd9			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9dd9			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9dd9			;	push hl 
9dd9			;	push de 
9dd9			;	push bc 
9dd9			; 
9dd9			; 
9dd9			;		if DEBUG_FORTH_WORDS_KEY 
9dd9			;			DMARK "EXR" 
9dd9			;			CALLMONITOR 
9dd9			;		endif 
9dd9			; 
9dd9			; 
9dd9			; 
9dd9			;	;v5 FORTH_DSP_VALUE 
9dd9			;	FORTH_DSP_VALUEHL 
9dd9			; 
9dd9			;	; TODO do string type checks 
9dd9			; 
9dd9			;;v5	inc hl   ; skip type 
9dd9			; 
9dd9			;	push hl  ; source code  
9dd9			;		if DEBUG_FORTH_WORDS 
9dd9			;			DMARK "EX1" 
9dd9			;			CALLMONITOR 
9dd9			;		endif 
9dd9			;	ld a, 0 
9dd9			;	call strlent 
9dd9			; 
9dd9			;	inc hl 
9dd9			;	inc hl 
9dd9			;	inc hl 
9dd9			;	inc hl 
9dd9			; 
9dd9			;	push hl    ; size 
9dd9			; 
9dd9			;		if DEBUG_FORTH_WORDS 
9dd9			;			DMARK "EX2" 
9dd9			;			CALLMONITOR 
9dd9			;		endif 
9dd9			;	call malloc 
9dd9			; 
9dd9			;	ex de, hl    ; de now contains malloc area 
9dd9			;	pop bc   	; get byte count 
9dd9			;	pop hl      ; get string to copy 
9dd9			; 
9dd9			;	push de     ; save malloc for free later 
9dd9			; 
9dd9			;		if DEBUG_FORTH_WORDS 
9dd9			;			DMARK "EX3" 
9dd9			;			CALLMONITOR 
9dd9			;		endif 
9dd9			;	ldir       ; duplicate string 
9dd9			; 
9dd9			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9dd9			;	 
9dd9			;	; TODO fix the parse would be better than this...  
9dd9			;	ex de, hl 
9dd9			;	dec hl 
9dd9			;	ld a, 0 
9dd9			;	ld (hl), a 
9dd9			;	dec hl 
9dd9			;	ld a, ' ' 
9dd9			;	ld (hl), a 
9dd9			;	dec hl 
9dd9			;	ld (hl), a 
9dd9			; 
9dd9			;	dec hl 
9dd9			;	ld (hl), a 
9dd9			; 
9dd9			; 
9dd9			;	FORTH_DSP_POP  
9dd9			; 
9dd9			;	pop hl     
9dd9			;	push hl    ; save malloc area 
9dd9			; 
9dd9			;		if DEBUG_FORTH_WORDS 
9dd9			;			DMARK "EX4" 
9dd9			;			CALLMONITOR 
9dd9			;		endif 
9dd9			; 
9dd9			;	call forthparse 
9dd9			;	call forthexec 
9dd9			;	 
9dd9			;	pop hl 
9dd9			;	if DEBUG_FORTH_WORDS 
9dd9			;		DMARK "EX5" 
9dd9			;		CALLMONITOR 
9dd9			;	endif 
9dd9			; 
9dd9			;	if FORTH_ENABLE_FREE 
9dd9			;	call free 
9dd9			;	endif 
9dd9			; 
9dd9			;	if DEBUG_FORTH_WORDS 
9dd9			;		DMARK "EX6" 
9dd9			;		CALLMONITOR 
9dd9			;	endif 
9dd9			; 
9dd9			;	pop bc 
9dd9			;	pop de 
9dd9			;	pop hl 
9dd9			;;	FORTH_RSP_POP	  
9dd9			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9dd9			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9dd9			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9dd9			; 
9dd9			;	if DEBUG_FORTH_WORDS 
9dd9			;		DMARK "EX7" 
9dd9			;		CALLMONITOR 
9dd9			;	endif 
9dd9			;	NEXTW 
9dd9			 
9dd9			.STKEXEC: 
9dd9				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9dd9 3f				db WORD_SYS_CORE+43             
9dda 21 9f			dw .ZDUP            
9ddc 08				db 7 + 1 
9ddd .. 00			db "STKEXEC",0              
9de5				endm 
# End of macro CWHEAD
9de5			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
9de5			 
9de5			 
9de5					if DEBUG_FORTH_WORDS_KEY 
9de5						DMARK "STX" 
9de5 f5				push af  
9de6 3a fa 9d			ld a, (.dmark)  
9de9 32 c0 ee			ld (debug_mark),a  
9dec 3a fb 9d			ld a, (.dmark+1)  
9def 32 c1 ee			ld (debug_mark+1),a  
9df2 3a fc 9d			ld a, (.dmark+2)  
9df5 32 c2 ee			ld (debug_mark+2),a  
9df8 18 03			jr .pastdmark  
9dfa ..			.dmark: db "STX"  
9dfd f1			.pastdmark: pop af  
9dfe			endm  
# End of macro DMARK
9dfe						CALLMONITOR 
9dfe cd b0 92			call break_point_state  
9e01				endm  
# End of macro CALLMONITOR
9e01					endif 
9e01			 
9e01				FORTH_DSP_VALUEHL 
9e01 cd 34 9a			call macro_dsp_valuehl 
9e04				endm 
# End of macro FORTH_DSP_VALUEHL
9e04			 
9e04 22 e9 ec			ld (store_tmp1), hl    ; count 
9e07			 
9e07				FORTH_DSP_POP 
9e07 cd ec 9a			call macro_forth_dsp_pop 
9e0a				endm 
# End of macro FORTH_DSP_POP
9e0a			.stkexec1: 
9e0a 2a e9 ec			ld hl, (store_tmp1)   ; count 
9e0d 3e 00			ld a, 0 
9e0f bd				cp l 
9e10 c8				ret z 
9e11			 
9e11 2b				dec hl 
9e12 22 e9 ec			ld (store_tmp1), hl    ; count 
9e15				 
9e15				FORTH_DSP_VALUEHL 
9e15 cd 34 9a			call macro_dsp_valuehl 
9e18				endm 
# End of macro FORTH_DSP_VALUEHL
9e18 e5				push hl 
9e19				 
9e19					if DEBUG_FORTH_WORDS 
9e19						DMARK "EXp" 
9e19 f5				push af  
9e1a 3a 2e 9e			ld a, (.dmark)  
9e1d 32 c0 ee			ld (debug_mark),a  
9e20 3a 2f 9e			ld a, (.dmark+1)  
9e23 32 c1 ee			ld (debug_mark+1),a  
9e26 3a 30 9e			ld a, (.dmark+2)  
9e29 32 c2 ee			ld (debug_mark+2),a  
9e2c 18 03			jr .pastdmark  
9e2e ..			.dmark: db "EXp"  
9e31 f1			.pastdmark: pop af  
9e32			endm  
# End of macro DMARK
9e32						CALLMONITOR 
9e32 cd b0 92			call break_point_state  
9e35				endm  
# End of macro CALLMONITOR
9e35					endif 
9e35				FORTH_DSP_POP 
9e35 cd ec 9a			call macro_forth_dsp_pop 
9e38				endm 
# End of macro FORTH_DSP_POP
9e38			 
9e38 cd c7 8e			call strlenz 
9e3b 23				inc hl   ; include zero term to copy 
9e3c 23				inc hl   ; include zero term to copy 
9e3d 23				inc hl   ; include zero term to copy 
9e3e 06 00			ld b,0 
9e40 4d				ld c,l 
9e41 e1				pop hl 
9e42 11 e5 e5			ld de, execscratch 
9e45					if DEBUG_FORTH_WORDS 
9e45						DMARK "EX3" 
9e45 f5				push af  
9e46 3a 5a 9e			ld a, (.dmark)  
9e49 32 c0 ee			ld (debug_mark),a  
9e4c 3a 5b 9e			ld a, (.dmark+1)  
9e4f 32 c1 ee			ld (debug_mark+1),a  
9e52 3a 5c 9e			ld a, (.dmark+2)  
9e55 32 c2 ee			ld (debug_mark+2),a  
9e58 18 03			jr .pastdmark  
9e5a ..			.dmark: db "EX3"  
9e5d f1			.pastdmark: pop af  
9e5e			endm  
# End of macro DMARK
9e5e						CALLMONITOR 
9e5e cd b0 92			call break_point_state  
9e61				endm  
# End of macro CALLMONITOR
9e61					endif 
9e61 ed b0			ldir 
9e63			 
9e63			 
9e63 21 e5 e5			ld hl, execscratch 
9e66			 
9e66					if DEBUG_FORTH_WORDS 
9e66						DMARK "EXP" 
9e66 f5				push af  
9e67 3a 7b 9e			ld a, (.dmark)  
9e6a 32 c0 ee			ld (debug_mark),a  
9e6d 3a 7c 9e			ld a, (.dmark+1)  
9e70 32 c1 ee			ld (debug_mark+1),a  
9e73 3a 7d 9e			ld a, (.dmark+2)  
9e76 32 c2 ee			ld (debug_mark+2),a  
9e79 18 03			jr .pastdmark  
9e7b ..			.dmark: db "EXP"  
9e7e f1			.pastdmark: pop af  
9e7f			endm  
# End of macro DMARK
9e7f						CALLMONITOR 
9e7f cd b0 92			call break_point_state  
9e82				endm  
# End of macro CALLMONITOR
9e82					endif 
9e82			 
9e82 cd f4 9b			call forthparse 
9e85 21 e5 e5			ld hl, execscratch 
9e88					if DEBUG_FORTH_WORDS 
9e88						DMARK "EXx" 
9e88 f5				push af  
9e89 3a 9d 9e			ld a, (.dmark)  
9e8c 32 c0 ee			ld (debug_mark),a  
9e8f 3a 9e 9e			ld a, (.dmark+1)  
9e92 32 c1 ee			ld (debug_mark+1),a  
9e95 3a 9f 9e			ld a, (.dmark+2)  
9e98 32 c2 ee			ld (debug_mark+2),a  
9e9b 18 03			jr .pastdmark  
9e9d ..			.dmark: db "EXx"  
9ea0 f1			.pastdmark: pop af  
9ea1			endm  
# End of macro DMARK
9ea1						CALLMONITOR 
9ea1 cd b0 92			call break_point_state  
9ea4				endm  
# End of macro CALLMONITOR
9ea4					endif 
9ea4 cd 34 9c			call forthexec 
9ea7			 
9ea7 c3 0a 9e			jp .stkexec1 
9eaa			 
9eaa c9				ret 
9eab			 
9eab			 
9eab			.DUP: 
9eab				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9eab 17				db WORD_SYS_CORE+OPCODE_DUP             
9eac 21 9f			dw .ZDUP            
9eae 04				db 3 + 1 
9eaf .. 00			db "DUP",0              
9eb3				endm 
# End of macro CWHEAD
9eb3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9eb3			 
9eb3					if DEBUG_FORTH_WORDS_KEY 
9eb3						DMARK "DUP" 
9eb3 f5				push af  
9eb4 3a c8 9e			ld a, (.dmark)  
9eb7 32 c0 ee			ld (debug_mark),a  
9eba 3a c9 9e			ld a, (.dmark+1)  
9ebd 32 c1 ee			ld (debug_mark+1),a  
9ec0 3a ca 9e			ld a, (.dmark+2)  
9ec3 32 c2 ee			ld (debug_mark+2),a  
9ec6 18 03			jr .pastdmark  
9ec8 ..			.dmark: db "DUP"  
9ecb f1			.pastdmark: pop af  
9ecc			endm  
# End of macro DMARK
9ecc						CALLMONITOR 
9ecc cd b0 92			call break_point_state  
9ecf				endm  
# End of macro CALLMONITOR
9ecf					endif 
9ecf			 
9ecf					FORTH_DSP 
9ecf cd fa 99			call macro_forth_dsp 
9ed2				endm 
# End of macro FORTH_DSP
9ed2			 
9ed2 7e					ld a, (HL) 
9ed3 fe 01				cp DS_TYPE_STR 
9ed5 20 25				jr nz, .dupinum 
9ed7			 
9ed7					; push another string 
9ed7			 
9ed7					FORTH_DSP_VALUEHL     		 
9ed7 cd 34 9a			call macro_dsp_valuehl 
9eda				endm 
# End of macro FORTH_DSP_VALUEHL
9eda			 
9eda				if DEBUG_FORTH_WORDS 
9eda					DMARK "DUs" 
9eda f5				push af  
9edb 3a ef 9e			ld a, (.dmark)  
9ede 32 c0 ee			ld (debug_mark),a  
9ee1 3a f0 9e			ld a, (.dmark+1)  
9ee4 32 c1 ee			ld (debug_mark+1),a  
9ee7 3a f1 9e			ld a, (.dmark+2)  
9eea 32 c2 ee			ld (debug_mark+2),a  
9eed 18 03			jr .pastdmark  
9eef ..			.dmark: db "DUs"  
9ef2 f1			.pastdmark: pop af  
9ef3			endm  
# End of macro DMARK
9ef3					CALLMONITOR 
9ef3 cd b0 92			call break_point_state  
9ef6				endm  
# End of macro CALLMONITOR
9ef6				endif 
9ef6 cd ab 98				call forth_push_str 
9ef9			 
9ef9					NEXTW 
9ef9 c3 a6 9b			jp macro_next 
9efc				endm 
# End of macro NEXTW
9efc			 
9efc			 
9efc			.dupinum: 
9efc					 
9efc			 
9efc			 
9efc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9efc cd 34 9a			call macro_dsp_valuehl 
9eff				endm 
# End of macro FORTH_DSP_VALUEHL
9eff			 
9eff				; TODO add floating point number detection 
9eff			 
9eff				if DEBUG_FORTH_WORDS 
9eff					DMARK "DUi" 
9eff f5				push af  
9f00 3a 14 9f			ld a, (.dmark)  
9f03 32 c0 ee			ld (debug_mark),a  
9f06 3a 15 9f			ld a, (.dmark+1)  
9f09 32 c1 ee			ld (debug_mark+1),a  
9f0c 3a 16 9f			ld a, (.dmark+2)  
9f0f 32 c2 ee			ld (debug_mark+2),a  
9f12 18 03			jr .pastdmark  
9f14 ..			.dmark: db "DUi"  
9f17 f1			.pastdmark: pop af  
9f18			endm  
# End of macro DMARK
9f18					CALLMONITOR 
9f18 cd b0 92			call break_point_state  
9f1b				endm  
# End of macro CALLMONITOR
9f1b				endif 
9f1b			 
9f1b cd 3d 98				call forth_push_numhl 
9f1e					NEXTW 
9f1e c3 a6 9b			jp macro_next 
9f21				endm 
# End of macro NEXTW
9f21			.ZDUP: 
9f21				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9f21 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9f22 59 9f			dw .SWAP            
9f24 05				db 4 + 1 
9f25 .. 00			db "?DUP",0              
9f2a				endm 
# End of macro CWHEAD
9f2a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9f2a			 
9f2a					if DEBUG_FORTH_WORDS_KEY 
9f2a						DMARK "qDU" 
9f2a f5				push af  
9f2b 3a 3f 9f			ld a, (.dmark)  
9f2e 32 c0 ee			ld (debug_mark),a  
9f31 3a 40 9f			ld a, (.dmark+1)  
9f34 32 c1 ee			ld (debug_mark+1),a  
9f37 3a 41 9f			ld a, (.dmark+2)  
9f3a 32 c2 ee			ld (debug_mark+2),a  
9f3d 18 03			jr .pastdmark  
9f3f ..			.dmark: db "qDU"  
9f42 f1			.pastdmark: pop af  
9f43			endm  
# End of macro DMARK
9f43						CALLMONITOR 
9f43 cd b0 92			call break_point_state  
9f46				endm  
# End of macro CALLMONITOR
9f46					endif 
9f46					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f46 cd 34 9a			call macro_dsp_valuehl 
9f49				endm 
# End of macro FORTH_DSP_VALUEHL
9f49			 
9f49 e5					push hl 
9f4a			 
9f4a					; is it a zero? 
9f4a			 
9f4a 3e 00				ld a, 0 
9f4c 84					add h 
9f4d 85					add l 
9f4e			 
9f4e e1					pop hl 
9f4f			 
9f4f fe 00				cp 0 
9f51 28 03				jr z, .dup2orig 
9f53			 
9f53			 
9f53 cd 3d 98				call forth_push_numhl 
9f56			 
9f56			 
9f56				; TODO add floating point number detection 
9f56			 
9f56			.dup2orig: 
9f56			 
9f56					NEXTW 
9f56 c3 a6 9b			jp macro_next 
9f59				endm 
# End of macro NEXTW
9f59			.SWAP: 
9f59				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9f59 18				db WORD_SYS_CORE+OPCODE_SWAP             
9f5a 98 9f			dw .COLN            
9f5c 05				db 4 + 1 
9f5d .. 00			db "SWAP",0              
9f62				endm 
# End of macro CWHEAD
9f62			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9f62					if DEBUG_FORTH_WORDS_KEY 
9f62						DMARK "SWP" 
9f62 f5				push af  
9f63 3a 77 9f			ld a, (.dmark)  
9f66 32 c0 ee			ld (debug_mark),a  
9f69 3a 78 9f			ld a, (.dmark+1)  
9f6c 32 c1 ee			ld (debug_mark+1),a  
9f6f 3a 79 9f			ld a, (.dmark+2)  
9f72 32 c2 ee			ld (debug_mark+2),a  
9f75 18 03			jr .pastdmark  
9f77 ..			.dmark: db "SWP"  
9f7a f1			.pastdmark: pop af  
9f7b			endm  
# End of macro DMARK
9f7b						CALLMONITOR 
9f7b cd b0 92			call break_point_state  
9f7e				endm  
# End of macro CALLMONITOR
9f7e					endif 
9f7e			 
9f7e					FORTH_DSP_VALUEHL 
9f7e cd 34 9a			call macro_dsp_valuehl 
9f81				endm 
# End of macro FORTH_DSP_VALUEHL
9f81 e5					push hl     ; w2 
9f82			 
9f82					FORTH_DSP_POP 
9f82 cd ec 9a			call macro_forth_dsp_pop 
9f85				endm 
# End of macro FORTH_DSP_POP
9f85			 
9f85					FORTH_DSP_VALUEHL 
9f85 cd 34 9a			call macro_dsp_valuehl 
9f88				endm 
# End of macro FORTH_DSP_VALUEHL
9f88			 
9f88					FORTH_DSP_POP 
9f88 cd ec 9a			call macro_forth_dsp_pop 
9f8b				endm 
# End of macro FORTH_DSP_POP
9f8b			 
9f8b d1					pop de     ; w2	, hl = w1 
9f8c			 
9f8c eb					ex de, hl 
9f8d d5					push de 
9f8e			 
9f8e cd 3d 98				call forth_push_numhl 
9f91			 
9f91 e1					pop hl 
9f92			 
9f92 cd 3d 98				call forth_push_numhl 
9f95					 
9f95			 
9f95					NEXTW 
9f95 c3 a6 9b			jp macro_next 
9f98				endm 
# End of macro NEXTW
9f98			.COLN: 
9f98				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9f98 19				db WORD_SYS_CORE+OPCODE_COLN             
9f99 24 a1			dw .SCOLN            
9f9b 02				db 1 + 1 
9f9c .. 00			db ":",0              
9f9e				endm 
# End of macro CWHEAD
9f9e			; | : ( -- )         Create new word | DONE 
9f9e			 
9f9e					if DEBUG_FORTH_WORDS_KEY 
9f9e						DMARK "CLN" 
9f9e f5				push af  
9f9f 3a b3 9f			ld a, (.dmark)  
9fa2 32 c0 ee			ld (debug_mark),a  
9fa5 3a b4 9f			ld a, (.dmark+1)  
9fa8 32 c1 ee			ld (debug_mark+1),a  
9fab 3a b5 9f			ld a, (.dmark+2)  
9fae 32 c2 ee			ld (debug_mark+2),a  
9fb1 18 03			jr .pastdmark  
9fb3 ..			.dmark: db "CLN"  
9fb6 f1			.pastdmark: pop af  
9fb7			endm  
# End of macro DMARK
9fb7						CALLMONITOR 
9fb7 cd b0 92			call break_point_state  
9fba				endm  
# End of macro CALLMONITOR
9fba					endif 
9fba				STACKFRAME OFF $8efe $989f 
9fba				if DEBUG_STACK_IMB 
9fba					if OFF 
9fba						exx 
9fba						ld de, $8efe 
9fba						ld a, d 
9fba						ld hl, curframe 
9fba						call hexout 
9fba						ld a, e 
9fba						ld hl, curframe+2 
9fba						call hexout 
9fba						ld hl, $8efe 
9fba						push hl 
9fba						ld hl, $989f 
9fba						push hl 
9fba						exx 
9fba					endif 
9fba				endif 
9fba			endm 
# End of macro STACKFRAME
9fba				; get parser buffer length  of new word 
9fba			 
9fba				 
9fba			 
9fba					; move tok past this to start of name defintition 
9fba					; TODO get word to define 
9fba					; TODO Move past word token 
9fba					; TODO get length of string up to the ';' 
9fba			 
9fba 2a e7 e7			ld hl, (os_tok_ptr) 
9fbd 23				inc hl 
9fbe 23				inc hl 
9fbf			 
9fbf 3e 3b			ld a, ';' 
9fc1 cd d2 8e			call strlent 
9fc4			 
9fc4 7d				ld a,l 
9fc5 32 e2 e4			ld (os_new_parse_len), a 
9fc8			 
9fc8			 
9fc8			if DEBUG_FORTH_UWORD 
9fc8 ed 5b e7 e7		ld de, (os_tok_ptr) 
9fcc						DMARK ":01" 
9fcc f5				push af  
9fcd 3a e1 9f			ld a, (.dmark)  
9fd0 32 c0 ee			ld (debug_mark),a  
9fd3 3a e2 9f			ld a, (.dmark+1)  
9fd6 32 c1 ee			ld (debug_mark+1),a  
9fd9 3a e3 9f			ld a, (.dmark+2)  
9fdc 32 c2 ee			ld (debug_mark+2),a  
9fdf 18 03			jr .pastdmark  
9fe1 ..			.dmark: db ":01"  
9fe4 f1			.pastdmark: pop af  
9fe5			endm  
# End of macro DMARK
9fe5				CALLMONITOR 
9fe5 cd b0 92			call break_point_state  
9fe8				endm  
# End of macro CALLMONITOR
9fe8			endif 
9fe8			 
9fe8			; 
9fe8			;  new word memory layout: 
9fe8			;  
9fe8			;    : adg 6666 ;  
9fe8			; 
9fe8			;    db   1     ; user defined word  
9fe8 23				inc hl    
9fe9			;    dw   sysdict 
9fe9 23				inc hl 
9fea 23				inc hl 
9feb			;    db <word len>+1 (for null) 
9feb 23				inc hl 
9fec			;    db .... <word> 
9fec			; 
9fec			 
9fec 23				inc hl    ; some extras for the word preamble before the above 
9fed 23				inc hl 
9fee 23				inc hl 
9fef 23				inc hl 
9ff0 23				inc hl 
9ff1 23				inc hl 
9ff2 23				inc hl  
9ff3 23				inc hl 
9ff4 23				inc hl 
9ff5 23				inc hl 
9ff6 23				inc hl 
9ff7 23				inc hl 
9ff8 23				inc hl 
9ff9 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9ffa			;       exec word buffer 
9ffa			;	<ptr word>   
9ffa 23				inc hl 
9ffb 23				inc hl 
9ffc			;       <word list><null term> 7F final term 
9ffc			 
9ffc			 
9ffc			if DEBUG_FORTH_UWORD 
9ffc						DMARK ":02" 
9ffc f5				push af  
9ffd 3a 11 a0			ld a, (.dmark)  
a000 32 c0 ee			ld (debug_mark),a  
a003 3a 12 a0			ld a, (.dmark+1)  
a006 32 c1 ee			ld (debug_mark+1),a  
a009 3a 13 a0			ld a, (.dmark+2)  
a00c 32 c2 ee			ld (debug_mark+2),a  
a00f 18 03			jr .pastdmark  
a011 ..			.dmark: db ":02"  
a014 f1			.pastdmark: pop af  
a015			endm  
# End of macro DMARK
a015				CALLMONITOR 
a015 cd b0 92			call break_point_state  
a018				endm  
# End of macro CALLMONITOR
a018			endif 
a018			 
a018				 
a018					; malloc the size 
a018			 
a018 cd 30 8f				call malloc 
a01b 22 e4 e4				ld (os_new_malloc), hl     ; save malloc start 
a01e			 
a01e			;    db   1     ; user defined word  
a01e 3e 01				ld a, WORD_SYS_UWORD  
a020 77					ld (hl), a 
a021				 
a021 23				inc hl    
a022			;    dw   sysdict 
a022 11 fe 9c			ld de, sysdict       ; continue on with the scan to the system dict 
a025 73				ld (hl), e 
a026 23				inc hl 
a027 72				ld (hl), d 
a028 23				inc hl 
a029			 
a029			 
a029			;    Setup dict word 
a029			 
a029 23				inc hl 
a02a 22 de e4			ld (os_new_work_ptr), hl     ; save start of dict word  
a02d			 
a02d				; 1. get length of dict word 
a02d			 
a02d			 
a02d 2a e7 e7			ld hl, (os_tok_ptr) 
a030 23				inc hl 
a031 23				inc hl    ; position to start of dict word 
a032 3e 00			ld a, 0 
a034 cd d2 8e			call strlent 
a037			 
a037			 
a037 23				inc hl    ; to include null??? 
a038			 
a038				; write length of dict word 
a038			 
a038 ed 5b de e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a03c 1b				dec de 
a03d eb				ex de, hl 
a03e 73				ld (hl), e 
a03f eb				ex de, hl 
a040			 
a040				 
a040			 
a040				; copy  
a040 4d				ld c, l 
a041 06 00			ld b, 0 
a043 ed 5b de e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a047 2a e7 e7			ld hl, (os_tok_ptr) 
a04a 23				inc hl 
a04b 23				inc hl    ; position to start of dict word 
a04c				 
a04c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a04c				 
a04c				; TODO need to convert word to upper case 
a04c			 
a04c			ucasetok:	 
a04c 7e				ld a,(hl) 
a04d cd be 8e			call toUpper 
a050 77				ld (hl),a 
a051 ed a0			ldi 
a053 f2 4c a0		 	jp p, ucasetok 
a056			 
a056			 
a056			 
a056				; de now points to start of where the word body code should be placed 
a056 ed 53 de e4		ld (os_new_work_ptr), de 
a05a				; hl now points to the words to throw at forthexec which needs to be copied 
a05a 22 dc e4			ld (os_new_src_ptr), hl 
a05d			 
a05d				; TODO add 'call to forthexec' 
a05d			 
a05d			if DEBUG_FORTH_UWORD 
a05d c5				push bc 
a05e ed 4b e4 e4		ld bc, (os_new_malloc) 
a062						DMARK ":0x" 
a062 f5				push af  
a063 3a 77 a0			ld a, (.dmark)  
a066 32 c0 ee			ld (debug_mark),a  
a069 3a 78 a0			ld a, (.dmark+1)  
a06c 32 c1 ee			ld (debug_mark+1),a  
a06f 3a 79 a0			ld a, (.dmark+2)  
a072 32 c2 ee			ld (debug_mark+2),a  
a075 18 03			jr .pastdmark  
a077 ..			.dmark: db ":0x"  
a07a f1			.pastdmark: pop af  
a07b			endm  
# End of macro DMARK
a07b				CALLMONITOR 
a07b cd b0 92			call break_point_state  
a07e				endm  
# End of macro CALLMONITOR
a07e c1				pop bc 
a07f			endif 
a07f			 
a07f			 
a07f				; create word preamble which should be: 
a07f			 
a07f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a07f			 
a07f				;    ld hl, <word code> 
a07f				;    jp user_exec 
a07f			        ;    <word code bytes> 
a07f			 
a07f			 
a07f			;	inc de     ; TODO ??? or are we already past the word's null 
a07f eb				ex de, hl 
a080			 
a080 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a082			 
a082 23				inc hl 
a083 22 d8 e4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a086 23				inc hl 
a087			 
a087 23				inc hl 
a088 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a08a			 
a08a 01 13 c4			ld bc, user_exec 
a08d 23				inc hl 
a08e 71				ld (hl), c     ; poke address of user_exec 
a08f 23				inc hl 
a090 70				ld (hl), b     
a091			 ; 
a091			;	inc hl 
a091			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a091			; 
a091			; 
a091			;	ld bc, macro_forth_rsp_next 
a091			;	inc hl 
a091			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a091			;	inc hl 
a091			;	ld (hl), b     
a091			 ; 
a091			;	inc hl 
a091			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a091			; 
a091			; 
a091			;	inc hl 
a091			;	ld bc, forthexec 
a091			;	ld (hl), c     ; poke address of forthexec 
a091			;	inc hl 
a091			;	ld (hl), b      
a091			; 
a091			;	inc hl 
a091			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a091			; 
a091			;	ld bc, user_dict_next 
a091			;	inc hl 
a091			;	ld (hl), c     ; poke address of forthexec 
a091			;	inc hl 
a091			;	ld (hl), b      
a091			 
a091				; hl is now where we need to copy the word byte data to save this 
a091			 
a091 23				inc hl 
a092 22 da e4			ld (os_new_exec), hl 
a095				 
a095				; copy definition 
a095			 
a095 eb				ex de, hl 
a096			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a096			;	inc de    ; skip the PC for this parse 
a096 3a e2 e4			ld a, (os_new_parse_len) 
a099 4f				ld c, a 
a09a 06 00			ld b, 0 
a09c ed b0			ldir		 ; copy defintion 
a09e			 
a09e			 
a09e				; poke the address of where the new word bytes live for forthexec 
a09e			 
a09e 2a d8 e4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a0a1			 
a0a1 ed 5b da e4		ld de, (os_new_exec)      
a0a5				 
a0a5 73				ld (hl), e 
a0a6 23				inc hl 
a0a7 72				ld (hl), d 
a0a8			 
a0a8					; TODO copy last user dict word next link to this word 
a0a8					; TODO update last user dict word to point to this word 
a0a8			; 
a0a8			; hl f923 de 812a ; bc 811a 
a0a8			 
a0a8			if DEBUG_FORTH_UWORD 
a0a8 c5				push bc 
a0a9 ed 4b e4 e4		ld bc, (os_new_malloc) 
a0ad						DMARK ":0A" 
a0ad f5				push af  
a0ae 3a c2 a0			ld a, (.dmark)  
a0b1 32 c0 ee			ld (debug_mark),a  
a0b4 3a c3 a0			ld a, (.dmark+1)  
a0b7 32 c1 ee			ld (debug_mark+1),a  
a0ba 3a c4 a0			ld a, (.dmark+2)  
a0bd 32 c2 ee			ld (debug_mark+2),a  
a0c0 18 03			jr .pastdmark  
a0c2 ..			.dmark: db ":0A"  
a0c5 f1			.pastdmark: pop af  
a0c6			endm  
# End of macro DMARK
a0c6				CALLMONITOR 
a0c6 cd b0 92			call break_point_state  
a0c9				endm  
# End of macro CALLMONITOR
a0c9 c1				pop bc 
a0ca			endif 
a0ca			if DEBUG_FORTH_UWORD 
a0ca c5				push bc 
a0cb ed 4b e4 e4		ld bc, (os_new_malloc) 
a0cf 03				inc bc 
a0d0 03				inc bc 
a0d1 03				inc bc 
a0d2 03				inc bc 
a0d3 03				inc bc 
a0d4 03				inc bc 
a0d5 03				inc bc 
a0d6 03				inc bc 
a0d7			 
a0d7						DMARK ":0B" 
a0d7 f5				push af  
a0d8 3a ec a0			ld a, (.dmark)  
a0db 32 c0 ee			ld (debug_mark),a  
a0de 3a ed a0			ld a, (.dmark+1)  
a0e1 32 c1 ee			ld (debug_mark+1),a  
a0e4 3a ee a0			ld a, (.dmark+2)  
a0e7 32 c2 ee			ld (debug_mark+2),a  
a0ea 18 03			jr .pastdmark  
a0ec ..			.dmark: db ":0B"  
a0ef f1			.pastdmark: pop af  
a0f0			endm  
# End of macro DMARK
a0f0				CALLMONITOR 
a0f0 cd b0 92			call break_point_state  
a0f3				endm  
# End of macro CALLMONITOR
a0f3 c1				pop bc 
a0f4			endif 
a0f4			 
a0f4			; update word dict linked list for new word 
a0f4			 
a0f4			 
a0f4 2a e3 e7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a0f7 23			inc hl     ; move to next work linked list ptr 
a0f8			 
a0f8 ed 5b e4 e4	ld de, (os_new_malloc)		 ; new next word 
a0fc 73			ld (hl), e 
a0fd 23			inc hl 
a0fe 72			ld (hl), d 
a0ff			 
a0ff			if DEBUG_FORTH_UWORD 
a0ff ed 4b e3 e7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a103			endif 
a103			 
a103 ed 53 e3 e7	ld (os_last_new_uword), de      ; update last new uword ptr 
a107			 
a107			 
a107			if DEBUG_FORTH_UWORD 
a107						DMARK ":0+" 
a107 f5				push af  
a108 3a 1c a1			ld a, (.dmark)  
a10b 32 c0 ee			ld (debug_mark),a  
a10e 3a 1d a1			ld a, (.dmark+1)  
a111 32 c1 ee			ld (debug_mark+1),a  
a114 3a 1e a1			ld a, (.dmark+2)  
a117 32 c2 ee			ld (debug_mark+2),a  
a11a 18 03			jr .pastdmark  
a11c ..			.dmark: db ":0+"  
a11f f1			.pastdmark: pop af  
a120			endm  
# End of macro DMARK
a120				CALLMONITOR 
a120 cd b0 92			call break_point_state  
a123				endm  
# End of macro CALLMONITOR
a123			endif 
a123			 
a123				STACKFRAMECHK OFF $8efe $989f 
a123				if DEBUG_STACK_IMB 
a123					if OFF 
a123						exx 
a123						ld hl, $989f 
a123						pop de   ; $989f 
a123						call cmp16 
a123						jr nz, .spnosame 
a123						ld hl, $8efe 
a123						pop de   ; $8efe 
a123						call cmp16 
a123						jr z, .spfrsame 
a123						.spnosame: call showsperror 
a123						.spfrsame: nop 
a123						exx 
a123					endif 
a123				endif 
a123			endm 
# End of macro STACKFRAMECHK
a123			 
a123 c9			ret    ; dont process any remaining parser tokens as they form new word 
a124			 
a124			 
a124			 
a124			 
a124			;		NEXT 
a124			.SCOLN: 
a124			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a124 06				db OPCODE_SCOLN 
a125 70 a1			dw .DROP 
a127 02				db 2 
a128 .. 00			db ";",0           
a12a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a12a					if DEBUG_FORTH_WORDS_KEY 
a12a						DMARK "SCN" 
a12a f5				push af  
a12b 3a 3f a1			ld a, (.dmark)  
a12e 32 c0 ee			ld (debug_mark),a  
a131 3a 40 a1			ld a, (.dmark+1)  
a134 32 c1 ee			ld (debug_mark+1),a  
a137 3a 41 a1			ld a, (.dmark+2)  
a13a 32 c2 ee			ld (debug_mark+2),a  
a13d 18 03			jr .pastdmark  
a13f ..			.dmark: db "SCN"  
a142 f1			.pastdmark: pop af  
a143			endm  
# End of macro DMARK
a143						CALLMONITOR 
a143 cd b0 92			call break_point_state  
a146				endm  
# End of macro CALLMONITOR
a146					endif 
a146					FORTH_RSP_TOS 
a146 cd fb 97			call macro_forth_rsp_tos 
a149				endm 
# End of macro FORTH_RSP_TOS
a149 e5					push hl 
a14a					FORTH_RSP_POP 
a14a cd 05 98			call macro_forth_rsp_pop 
a14d				endm 
# End of macro FORTH_RSP_POP
a14d e1					pop hl 
a14e			;		ex de,hl 
a14e 22 e7 e7				ld (os_tok_ptr),hl 
a151			 
a151			if DEBUG_FORTH_UWORD 
a151						DMARK "SCL" 
a151 f5				push af  
a152 3a 66 a1			ld a, (.dmark)  
a155 32 c0 ee			ld (debug_mark),a  
a158 3a 67 a1			ld a, (.dmark+1)  
a15b 32 c1 ee			ld (debug_mark+1),a  
a15e 3a 68 a1			ld a, (.dmark+2)  
a161 32 c2 ee			ld (debug_mark+2),a  
a164 18 03			jr .pastdmark  
a166 ..			.dmark: db "SCL"  
a169 f1			.pastdmark: pop af  
a16a			endm  
# End of macro DMARK
a16a				CALLMONITOR 
a16a cd b0 92			call break_point_state  
a16d				endm  
# End of macro CALLMONITOR
a16d			endif 
a16d					NEXTW 
a16d c3 a6 9b			jp macro_next 
a170				endm 
# End of macro NEXTW
a170			 
a170			.DROP: 
a170				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a170 1b				db WORD_SYS_CORE+OPCODE_DROP             
a171 9b a1			dw .DUP2            
a173 05				db 4 + 1 
a174 .. 00			db "DROP",0              
a179				endm 
# End of macro CWHEAD
a179			; | DROP ( w -- )   drop the TOS item   | DONE 
a179					if DEBUG_FORTH_WORDS_KEY 
a179						DMARK "DRP" 
a179 f5				push af  
a17a 3a 8e a1			ld a, (.dmark)  
a17d 32 c0 ee			ld (debug_mark),a  
a180 3a 8f a1			ld a, (.dmark+1)  
a183 32 c1 ee			ld (debug_mark+1),a  
a186 3a 90 a1			ld a, (.dmark+2)  
a189 32 c2 ee			ld (debug_mark+2),a  
a18c 18 03			jr .pastdmark  
a18e ..			.dmark: db "DRP"  
a191 f1			.pastdmark: pop af  
a192			endm  
# End of macro DMARK
a192						CALLMONITOR 
a192 cd b0 92			call break_point_state  
a195				endm  
# End of macro CALLMONITOR
a195					endif 
a195					FORTH_DSP_POP 
a195 cd ec 9a			call macro_forth_dsp_pop 
a198				endm 
# End of macro FORTH_DSP_POP
a198					NEXTW 
a198 c3 a6 9b			jp macro_next 
a19b				endm 
# End of macro NEXTW
a19b			.DUP2: 
a19b				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a19b 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a19c e0 a1			dw .DROP2            
a19e 05				db 4 + 1 
a19f .. 00			db "2DUP",0              
a1a4				endm 
# End of macro CWHEAD
a1a4			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a1a4					if DEBUG_FORTH_WORDS_KEY 
a1a4						DMARK "2DU" 
a1a4 f5				push af  
a1a5 3a b9 a1			ld a, (.dmark)  
a1a8 32 c0 ee			ld (debug_mark),a  
a1ab 3a ba a1			ld a, (.dmark+1)  
a1ae 32 c1 ee			ld (debug_mark+1),a  
a1b1 3a bb a1			ld a, (.dmark+2)  
a1b4 32 c2 ee			ld (debug_mark+2),a  
a1b7 18 03			jr .pastdmark  
a1b9 ..			.dmark: db "2DU"  
a1bc f1			.pastdmark: pop af  
a1bd			endm  
# End of macro DMARK
a1bd						CALLMONITOR 
a1bd cd b0 92			call break_point_state  
a1c0				endm  
# End of macro CALLMONITOR
a1c0					endif 
a1c0					FORTH_DSP_VALUEHL 
a1c0 cd 34 9a			call macro_dsp_valuehl 
a1c3				endm 
# End of macro FORTH_DSP_VALUEHL
a1c3 e5					push hl      ; 2 
a1c4			 
a1c4					FORTH_DSP_POP 
a1c4 cd ec 9a			call macro_forth_dsp_pop 
a1c7				endm 
# End of macro FORTH_DSP_POP
a1c7					 
a1c7					FORTH_DSP_VALUEHL 
a1c7 cd 34 9a			call macro_dsp_valuehl 
a1ca				endm 
# End of macro FORTH_DSP_VALUEHL
a1ca			;		push hl      ; 1 
a1ca			 
a1ca					FORTH_DSP_POP 
a1ca cd ec 9a			call macro_forth_dsp_pop 
a1cd				endm 
# End of macro FORTH_DSP_POP
a1cd			 
a1cd			;		pop hl       ; 1 
a1cd d1					pop de       ; 2 
a1ce			 
a1ce cd 3d 98				call forth_push_numhl 
a1d1 eb					ex de, hl 
a1d2 cd 3d 98				call forth_push_numhl 
a1d5			 
a1d5					 
a1d5 eb					ex de, hl 
a1d6			 
a1d6 cd 3d 98				call forth_push_numhl 
a1d9 eb					ex de, hl 
a1da cd 3d 98				call forth_push_numhl 
a1dd			 
a1dd			 
a1dd					NEXTW 
a1dd c3 a6 9b			jp macro_next 
a1e0				endm 
# End of macro NEXTW
a1e0			.DROP2: 
a1e0				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a1e0 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a1e1 0f a2			dw .SWAP2            
a1e3 06				db 5 + 1 
a1e4 .. 00			db "2DROP",0              
a1ea				endm 
# End of macro CWHEAD
a1ea			; | 2DROP ( w w -- )    Double drop | DONE 
a1ea					if DEBUG_FORTH_WORDS_KEY 
a1ea						DMARK "2DR" 
a1ea f5				push af  
a1eb 3a ff a1			ld a, (.dmark)  
a1ee 32 c0 ee			ld (debug_mark),a  
a1f1 3a 00 a2			ld a, (.dmark+1)  
a1f4 32 c1 ee			ld (debug_mark+1),a  
a1f7 3a 01 a2			ld a, (.dmark+2)  
a1fa 32 c2 ee			ld (debug_mark+2),a  
a1fd 18 03			jr .pastdmark  
a1ff ..			.dmark: db "2DR"  
a202 f1			.pastdmark: pop af  
a203			endm  
# End of macro DMARK
a203						CALLMONITOR 
a203 cd b0 92			call break_point_state  
a206				endm  
# End of macro CALLMONITOR
a206					endif 
a206					FORTH_DSP_POP 
a206 cd ec 9a			call macro_forth_dsp_pop 
a209				endm 
# End of macro FORTH_DSP_POP
a209					FORTH_DSP_POP 
a209 cd ec 9a			call macro_forth_dsp_pop 
a20c				endm 
# End of macro FORTH_DSP_POP
a20c					NEXTW 
a20c c3 a6 9b			jp macro_next 
a20f				endm 
# End of macro NEXTW
a20f			.SWAP2: 
a20f				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a20f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a210 38 a2			dw .AT            
a212 06				db 5 + 1 
a213 .. 00			db "2SWAP",0              
a219				endm 
# End of macro CWHEAD
a219			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a219					if DEBUG_FORTH_WORDS_KEY 
a219						DMARK "2SW" 
a219 f5				push af  
a21a 3a 2e a2			ld a, (.dmark)  
a21d 32 c0 ee			ld (debug_mark),a  
a220 3a 2f a2			ld a, (.dmark+1)  
a223 32 c1 ee			ld (debug_mark+1),a  
a226 3a 30 a2			ld a, (.dmark+2)  
a229 32 c2 ee			ld (debug_mark+2),a  
a22c 18 03			jr .pastdmark  
a22e ..			.dmark: db "2SW"  
a231 f1			.pastdmark: pop af  
a232			endm  
# End of macro DMARK
a232						CALLMONITOR 
a232 cd b0 92			call break_point_state  
a235				endm  
# End of macro CALLMONITOR
a235					endif 
a235					NEXTW 
a235 c3 a6 9b			jp macro_next 
a238				endm 
# End of macro NEXTW
a238			.AT: 
a238				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a238 1f				db WORD_SYS_CORE+OPCODE_AT             
a239 6a a2			dw .CAT            
a23b 02				db 1 + 1 
a23c .. 00			db "@",0              
a23e				endm 
# End of macro CWHEAD
a23e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a23e			 
a23e					if DEBUG_FORTH_WORDS_KEY 
a23e						DMARK "AT." 
a23e f5				push af  
a23f 3a 53 a2			ld a, (.dmark)  
a242 32 c0 ee			ld (debug_mark),a  
a245 3a 54 a2			ld a, (.dmark+1)  
a248 32 c1 ee			ld (debug_mark+1),a  
a24b 3a 55 a2			ld a, (.dmark+2)  
a24e 32 c2 ee			ld (debug_mark+2),a  
a251 18 03			jr .pastdmark  
a253 ..			.dmark: db "AT."  
a256 f1			.pastdmark: pop af  
a257			endm  
# End of macro DMARK
a257						CALLMONITOR 
a257 cd b0 92			call break_point_state  
a25a				endm  
# End of macro CALLMONITOR
a25a					endif 
a25a			.getbyteat:	 
a25a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a25a cd 34 9a			call macro_dsp_valuehl 
a25d				endm 
# End of macro FORTH_DSP_VALUEHL
a25d					 
a25d			;		push hl 
a25d				 
a25d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a25d cd ec 9a			call macro_forth_dsp_pop 
a260				endm 
# End of macro FORTH_DSP_POP
a260			 
a260			;		pop hl 
a260			 
a260 7e					ld a, (hl) 
a261			 
a261 6f					ld l, a 
a262 26 00				ld h, 0 
a264 cd 3d 98				call forth_push_numhl 
a267			 
a267					NEXTW 
a267 c3 a6 9b			jp macro_next 
a26a				endm 
# End of macro NEXTW
a26a			.CAT: 
a26a				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a26a 20				db WORD_SYS_CORE+OPCODE_CAT             
a26b 93 a2			dw .BANG            
a26d 03				db 2 + 1 
a26e .. 00			db "C@",0              
a271				endm 
# End of macro CWHEAD
a271			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a271					if DEBUG_FORTH_WORDS_KEY 
a271						DMARK "CAA" 
a271 f5				push af  
a272 3a 86 a2			ld a, (.dmark)  
a275 32 c0 ee			ld (debug_mark),a  
a278 3a 87 a2			ld a, (.dmark+1)  
a27b 32 c1 ee			ld (debug_mark+1),a  
a27e 3a 88 a2			ld a, (.dmark+2)  
a281 32 c2 ee			ld (debug_mark+2),a  
a284 18 03			jr .pastdmark  
a286 ..			.dmark: db "CAA"  
a289 f1			.pastdmark: pop af  
a28a			endm  
# End of macro DMARK
a28a						CALLMONITOR 
a28a cd b0 92			call break_point_state  
a28d				endm  
# End of macro CALLMONITOR
a28d					endif 
a28d c3 5a a2				jp .getbyteat 
a290					NEXTW 
a290 c3 a6 9b			jp macro_next 
a293				endm 
# End of macro NEXTW
a293			.BANG: 
a293				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a293 21				db WORD_SYS_CORE+OPCODE_BANG             
a294 c9 a2			dw .CBANG            
a296 02				db 1 + 1 
a297 .. 00			db "!",0              
a299				endm 
# End of macro CWHEAD
a299			; | ! ( x w -- ) Store x at address w      | DONE 
a299					if DEBUG_FORTH_WORDS_KEY 
a299						DMARK "BNG" 
a299 f5				push af  
a29a 3a ae a2			ld a, (.dmark)  
a29d 32 c0 ee			ld (debug_mark),a  
a2a0 3a af a2			ld a, (.dmark+1)  
a2a3 32 c1 ee			ld (debug_mark+1),a  
a2a6 3a b0 a2			ld a, (.dmark+2)  
a2a9 32 c2 ee			ld (debug_mark+2),a  
a2ac 18 03			jr .pastdmark  
a2ae ..			.dmark: db "BNG"  
a2b1 f1			.pastdmark: pop af  
a2b2			endm  
# End of macro DMARK
a2b2						CALLMONITOR 
a2b2 cd b0 92			call break_point_state  
a2b5				endm  
# End of macro CALLMONITOR
a2b5					endif 
a2b5			 
a2b5			.storebyteat:		 
a2b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2b5 cd 34 9a			call macro_dsp_valuehl 
a2b8				endm 
# End of macro FORTH_DSP_VALUEHL
a2b8					 
a2b8 e5					push hl 
a2b9				 
a2b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2b9 cd ec 9a			call macro_forth_dsp_pop 
a2bc				endm 
# End of macro FORTH_DSP_POP
a2bc			 
a2bc					; get byte to poke 
a2bc			 
a2bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2bc cd 34 9a			call macro_dsp_valuehl 
a2bf				endm 
# End of macro FORTH_DSP_VALUEHL
a2bf e5					push hl 
a2c0			 
a2c0			 
a2c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2c0 cd ec 9a			call macro_forth_dsp_pop 
a2c3				endm 
# End of macro FORTH_DSP_POP
a2c3			 
a2c3			 
a2c3 d1					pop de 
a2c4 e1					pop hl 
a2c5			 
a2c5 73					ld (hl),e 
a2c6			 
a2c6			 
a2c6					NEXTW 
a2c6 c3 a6 9b			jp macro_next 
a2c9				endm 
# End of macro NEXTW
a2c9			.CBANG: 
a2c9				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a2c9 22				db WORD_SYS_CORE+OPCODE_CBANG             
a2ca f2 a2			dw .SCALL            
a2cc 03				db 2 + 1 
a2cd .. 00			db "C!",0              
a2d0				endm 
# End of macro CWHEAD
a2d0			; | C!  ( x w -- ) Store x at address w  | DONE 
a2d0					if DEBUG_FORTH_WORDS_KEY 
a2d0						DMARK "CBA" 
a2d0 f5				push af  
a2d1 3a e5 a2			ld a, (.dmark)  
a2d4 32 c0 ee			ld (debug_mark),a  
a2d7 3a e6 a2			ld a, (.dmark+1)  
a2da 32 c1 ee			ld (debug_mark+1),a  
a2dd 3a e7 a2			ld a, (.dmark+2)  
a2e0 32 c2 ee			ld (debug_mark+2),a  
a2e3 18 03			jr .pastdmark  
a2e5 ..			.dmark: db "CBA"  
a2e8 f1			.pastdmark: pop af  
a2e9			endm  
# End of macro DMARK
a2e9						CALLMONITOR 
a2e9 cd b0 92			call break_point_state  
a2ec				endm  
# End of macro CALLMONITOR
a2ec					endif 
a2ec c3 b5 a2				jp .storebyteat 
a2ef					NEXTW 
a2ef c3 a6 9b			jp macro_next 
a2f2				endm 
# End of macro NEXTW
a2f2			.SCALL: 
a2f2				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a2f2 23				db WORD_SYS_CORE+OPCODE_SCALL             
a2f3 26 a3			dw .DEPTH            
a2f5 05				db 4 + 1 
a2f6 .. 00			db "CALL",0              
a2fb				endm 
# End of macro CWHEAD
a2fb			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a2fb					if DEBUG_FORTH_WORDS_KEY 
a2fb						DMARK "CLL" 
a2fb f5				push af  
a2fc 3a 10 a3			ld a, (.dmark)  
a2ff 32 c0 ee			ld (debug_mark),a  
a302 3a 11 a3			ld a, (.dmark+1)  
a305 32 c1 ee			ld (debug_mark+1),a  
a308 3a 12 a3			ld a, (.dmark+2)  
a30b 32 c2 ee			ld (debug_mark+2),a  
a30e 18 03			jr .pastdmark  
a310 ..			.dmark: db "CLL"  
a313 f1			.pastdmark: pop af  
a314			endm  
# End of macro DMARK
a314						CALLMONITOR 
a314 cd b0 92			call break_point_state  
a317				endm  
# End of macro CALLMONITOR
a317					endif 
a317			 
a317					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a317 cd 34 9a			call macro_dsp_valuehl 
a31a				endm 
# End of macro FORTH_DSP_VALUEHL
a31a			 
a31a			;		push hl 
a31a			 
a31a					; destroy value TOS 
a31a			 
a31a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a31a cd ec 9a			call macro_forth_dsp_pop 
a31d				endm 
# End of macro FORTH_DSP_POP
a31d			 
a31d						 
a31d			;		pop hl 
a31d			 
a31d					; how to do a call with hl???? save SP? 
a31d cd 4f 9b				call forth_call_hl 
a320			 
a320			 
a320					; TODO push value back onto stack for another op etc 
a320			 
a320 cd 3d 98				call forth_push_numhl 
a323					NEXTW 
a323 c3 a6 9b			jp macro_next 
a326				endm 
# End of macro NEXTW
a326			.DEPTH: 
a326				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a326 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a327 63 a3			dw .OVER            
a329 06				db 5 + 1 
a32a .. 00			db "DEPTH",0              
a330				endm 
# End of macro CWHEAD
a330			; | DEPTH ( -- u ) Push count of stack | DONE 
a330					; take current TOS and remove from base value div by two to get count 
a330					if DEBUG_FORTH_WORDS_KEY 
a330						DMARK "DEP" 
a330 f5				push af  
a331 3a 45 a3			ld a, (.dmark)  
a334 32 c0 ee			ld (debug_mark),a  
a337 3a 46 a3			ld a, (.dmark+1)  
a33a 32 c1 ee			ld (debug_mark+1),a  
a33d 3a 47 a3			ld a, (.dmark+2)  
a340 32 c2 ee			ld (debug_mark+2),a  
a343 18 03			jr .pastdmark  
a345 ..			.dmark: db "DEP"  
a348 f1			.pastdmark: pop af  
a349			endm  
# End of macro DMARK
a349						CALLMONITOR 
a349 cd b0 92			call break_point_state  
a34c				endm  
# End of macro CALLMONITOR
a34c					endif 
a34c			 
a34c			 
a34c 2a 93 ec			ld hl, (cli_data_sp) 
a34f 11 4d ea			ld de, cli_data_stack 
a352 ed 52			sbc hl,de 
a354				 
a354				; div by size of stack item 
a354			 
a354 5d				ld e,l 
a355 0e 03			ld c, 3 
a357 cd f9 89			call Div8 
a35a			 
a35a 6f				ld l,a 
a35b 26 00			ld h,0 
a35d			 
a35d				;srl h 
a35d				;rr l 
a35d			 
a35d cd 3d 98				call forth_push_numhl 
a360					NEXTW 
a360 c3 a6 9b			jp macro_next 
a363				endm 
# End of macro NEXTW
a363			.OVER: 
a363				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a363 42				db WORD_SYS_CORE+46             
a364 aa a3			dw .PAUSE            
a366 05				db 4 + 1 
a367 .. 00			db "OVER",0              
a36c				endm 
# End of macro CWHEAD
a36c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a36c					if DEBUG_FORTH_WORDS_KEY 
a36c						DMARK "OVR" 
a36c f5				push af  
a36d 3a 81 a3			ld a, (.dmark)  
a370 32 c0 ee			ld (debug_mark),a  
a373 3a 82 a3			ld a, (.dmark+1)  
a376 32 c1 ee			ld (debug_mark+1),a  
a379 3a 83 a3			ld a, (.dmark+2)  
a37c 32 c2 ee			ld (debug_mark+2),a  
a37f 18 03			jr .pastdmark  
a381 ..			.dmark: db "OVR"  
a384 f1			.pastdmark: pop af  
a385			endm  
# End of macro DMARK
a385						CALLMONITOR 
a385 cd b0 92			call break_point_state  
a388				endm  
# End of macro CALLMONITOR
a388					endif 
a388			 
a388					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a388 cd 34 9a			call macro_dsp_valuehl 
a38b				endm 
# End of macro FORTH_DSP_VALUEHL
a38b e5					push hl    ; n2 
a38c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a38c cd ec 9a			call macro_forth_dsp_pop 
a38f				endm 
# End of macro FORTH_DSP_POP
a38f			 
a38f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a38f cd 34 9a			call macro_dsp_valuehl 
a392				endm 
# End of macro FORTH_DSP_VALUEHL
a392 e5					push hl    ; n1 
a393					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a393 cd ec 9a			call macro_forth_dsp_pop 
a396				endm 
# End of macro FORTH_DSP_POP
a396			 
a396 d1					pop de     ; n1 
a397 e1					pop hl     ; n2 
a398			 
a398 d5					push de 
a399 e5					push hl 
a39a d5					push de 
a39b			 
a39b					; push back  
a39b			 
a39b e1					pop hl 
a39c cd 3d 98				call forth_push_numhl 
a39f e1					pop hl 
a3a0 cd 3d 98				call forth_push_numhl 
a3a3 e1					pop hl 
a3a4 cd 3d 98				call forth_push_numhl 
a3a7					NEXTW 
a3a7 c3 a6 9b			jp macro_next 
a3aa				endm 
# End of macro NEXTW
a3aa			 
a3aa			.PAUSE: 
a3aa				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a3aa 43				db WORD_SYS_CORE+47             
a3ab df a3			dw .PAUSES            
a3ad 08				db 7 + 1 
a3ae .. 00			db "PAUSEMS",0              
a3b6				endm 
# End of macro CWHEAD
a3b6			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a3b6					if DEBUG_FORTH_WORDS_KEY 
a3b6						DMARK "PMS" 
a3b6 f5				push af  
a3b7 3a cb a3			ld a, (.dmark)  
a3ba 32 c0 ee			ld (debug_mark),a  
a3bd 3a cc a3			ld a, (.dmark+1)  
a3c0 32 c1 ee			ld (debug_mark+1),a  
a3c3 3a cd a3			ld a, (.dmark+2)  
a3c6 32 c2 ee			ld (debug_mark+2),a  
a3c9 18 03			jr .pastdmark  
a3cb ..			.dmark: db "PMS"  
a3ce f1			.pastdmark: pop af  
a3cf			endm  
# End of macro DMARK
a3cf						CALLMONITOR 
a3cf cd b0 92			call break_point_state  
a3d2				endm  
# End of macro CALLMONITOR
a3d2					endif 
a3d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3d2 cd 34 9a			call macro_dsp_valuehl 
a3d5				endm 
# End of macro FORTH_DSP_VALUEHL
a3d5			;		push hl    ; n2 
a3d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3d5 cd ec 9a			call macro_forth_dsp_pop 
a3d8				endm 
# End of macro FORTH_DSP_POP
a3d8			;		pop hl 
a3d8			 
a3d8 7d					ld a, l 
a3d9 cd cf 87				call aDelayInMS 
a3dc				       NEXTW 
a3dc c3 a6 9b			jp macro_next 
a3df				endm 
# End of macro NEXTW
a3df			.PAUSES:  
a3df				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a3df 44				db WORD_SYS_CORE+48             
a3e0 4e a4			dw .ROT            
a3e2 06				db 5 + 1 
a3e3 .. 00			db "PAUSE",0              
a3e9				endm 
# End of macro CWHEAD
a3e9			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a3e9					if DEBUG_FORTH_WORDS_KEY 
a3e9						DMARK "PAU" 
a3e9 f5				push af  
a3ea 3a fe a3			ld a, (.dmark)  
a3ed 32 c0 ee			ld (debug_mark),a  
a3f0 3a ff a3			ld a, (.dmark+1)  
a3f3 32 c1 ee			ld (debug_mark+1),a  
a3f6 3a 00 a4			ld a, (.dmark+2)  
a3f9 32 c2 ee			ld (debug_mark+2),a  
a3fc 18 03			jr .pastdmark  
a3fe ..			.dmark: db "PAU"  
a401 f1			.pastdmark: pop af  
a402			endm  
# End of macro DMARK
a402						CALLMONITOR 
a402 cd b0 92			call break_point_state  
a405				endm  
# End of macro CALLMONITOR
a405					endif 
a405					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a405 cd 34 9a			call macro_dsp_valuehl 
a408				endm 
# End of macro FORTH_DSP_VALUEHL
a408			;		push hl    ; n2 
a408					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a408 cd ec 9a			call macro_forth_dsp_pop 
a40b				endm 
# End of macro FORTH_DSP_POP
a40b			;		pop hl 
a40b 45					ld b, l 
a40c					if DEBUG_FORTH_WORDS 
a40c						DMARK "PAU" 
a40c f5				push af  
a40d 3a 21 a4			ld a, (.dmark)  
a410 32 c0 ee			ld (debug_mark),a  
a413 3a 22 a4			ld a, (.dmark+1)  
a416 32 c1 ee			ld (debug_mark+1),a  
a419 3a 23 a4			ld a, (.dmark+2)  
a41c 32 c2 ee			ld (debug_mark+2),a  
a41f 18 03			jr .pastdmark  
a421 ..			.dmark: db "PAU"  
a424 f1			.pastdmark: pop af  
a425			endm  
# End of macro DMARK
a425						CALLMONITOR 
a425 cd b0 92			call break_point_state  
a428				endm  
# End of macro CALLMONITOR
a428					endif 
a428 c5			.pauses1:	push bc 
a429 cd ea 87				call delay1s 
a42c c1					pop bc 
a42d					if DEBUG_FORTH_WORDS 
a42d						DMARK "PA1" 
a42d f5				push af  
a42e 3a 42 a4			ld a, (.dmark)  
a431 32 c0 ee			ld (debug_mark),a  
a434 3a 43 a4			ld a, (.dmark+1)  
a437 32 c1 ee			ld (debug_mark+1),a  
a43a 3a 44 a4			ld a, (.dmark+2)  
a43d 32 c2 ee			ld (debug_mark+2),a  
a440 18 03			jr .pastdmark  
a442 ..			.dmark: db "PA1"  
a445 f1			.pastdmark: pop af  
a446			endm  
# End of macro DMARK
a446						CALLMONITOR 
a446 cd b0 92			call break_point_state  
a449				endm  
# End of macro CALLMONITOR
a449					endif 
a449 10 dd				djnz .pauses1 
a44b			 
a44b				       NEXTW 
a44b c3 a6 9b			jp macro_next 
a44e				endm 
# End of macro NEXTW
a44e			.ROT: 
a44e				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a44e 45				db WORD_SYS_CORE+49             
a44f 9c a4			dw .UWORDS            
a451 04				db 3 + 1 
a452 .. 00			db "ROT",0              
a456				endm 
# End of macro CWHEAD
a456			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a456					if DEBUG_FORTH_WORDS_KEY 
a456						DMARK "ROT" 
a456 f5				push af  
a457 3a 6b a4			ld a, (.dmark)  
a45a 32 c0 ee			ld (debug_mark),a  
a45d 3a 6c a4			ld a, (.dmark+1)  
a460 32 c1 ee			ld (debug_mark+1),a  
a463 3a 6d a4			ld a, (.dmark+2)  
a466 32 c2 ee			ld (debug_mark+2),a  
a469 18 03			jr .pastdmark  
a46b ..			.dmark: db "ROT"  
a46e f1			.pastdmark: pop af  
a46f			endm  
# End of macro DMARK
a46f						CALLMONITOR 
a46f cd b0 92			call break_point_state  
a472				endm  
# End of macro CALLMONITOR
a472					endif 
a472			 
a472					FORTH_DSP_VALUEHL 
a472 cd 34 9a			call macro_dsp_valuehl 
a475				endm 
# End of macro FORTH_DSP_VALUEHL
a475 e5					push hl    ; u3  
a476			 
a476					FORTH_DSP_POP 
a476 cd ec 9a			call macro_forth_dsp_pop 
a479				endm 
# End of macro FORTH_DSP_POP
a479			   
a479					FORTH_DSP_VALUEHL 
a479 cd 34 9a			call macro_dsp_valuehl 
a47c				endm 
# End of macro FORTH_DSP_VALUEHL
a47c e5					push hl     ; u2 
a47d			 
a47d					FORTH_DSP_POP 
a47d cd ec 9a			call macro_forth_dsp_pop 
a480				endm 
# End of macro FORTH_DSP_POP
a480			 
a480					FORTH_DSP_VALUEHL 
a480 cd 34 9a			call macro_dsp_valuehl 
a483				endm 
# End of macro FORTH_DSP_VALUEHL
a483 e5					push hl     ; u1 
a484			 
a484					FORTH_DSP_POP 
a484 cd ec 9a			call macro_forth_dsp_pop 
a487				endm 
# End of macro FORTH_DSP_POP
a487			 
a487 c1					pop bc      ; u1 
a488 e1					pop hl      ; u2 
a489 d1					pop de      ; u3 
a48a			 
a48a			 
a48a c5					push bc 
a48b d5					push de 
a48c e5					push hl 
a48d			 
a48d			 
a48d e1					pop hl 
a48e cd 3d 98				call forth_push_numhl 
a491			 
a491 e1					pop hl 
a492 cd 3d 98				call forth_push_numhl 
a495			 
a495 e1					pop hl 
a496 cd 3d 98				call forth_push_numhl 
a499					 
a499			 
a499			 
a499			 
a499			 
a499			 
a499				       NEXTW 
a499 c3 a6 9b			jp macro_next 
a49c				endm 
# End of macro NEXTW
a49c			 
a49c			.UWORDS: 
a49c				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a49c 50				db WORD_SYS_CORE+60             
a49d 5e a5			dw .BP            
a49f 07				db 6 + 1 
a4a0 .. 00			db "UWORDS",0              
a4a7				endm 
# End of macro CWHEAD
a4a7			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a4a7			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a4a7			; | | Following the count are the individual words. 
a4a7			; | | 
a4a7			; | | e.g. UWORDS 
a4a7			; | | BOX DIRLIST 2 
a4a7			; | |  
a4a7			; | | Can be used to save the words to storage via: 
a4a7			; | | UWORDS $01 DO $01 APPEND LOOP 
a4a7				if DEBUG_FORTH_WORDS_KEY 
a4a7					DMARK "UWR" 
a4a7 f5				push af  
a4a8 3a bc a4			ld a, (.dmark)  
a4ab 32 c0 ee			ld (debug_mark),a  
a4ae 3a bd a4			ld a, (.dmark+1)  
a4b1 32 c1 ee			ld (debug_mark+1),a  
a4b4 3a be a4			ld a, (.dmark+2)  
a4b7 32 c2 ee			ld (debug_mark+2),a  
a4ba 18 03			jr .pastdmark  
a4bc ..			.dmark: db "UWR"  
a4bf f1			.pastdmark: pop af  
a4c0			endm  
# End of macro DMARK
a4c0					CALLMONITOR 
a4c0 cd b0 92			call break_point_state  
a4c3				endm  
# End of macro CALLMONITOR
a4c3				endif 
a4c3 21 30 d8				ld hl, baseram 
a4c6					;ld hl, baseusermem 
a4c6 01 00 00				ld bc, 0    ; start a counter 
a4c9			 
a4c9				; skip dict stub 
a4c9			 
a4c9 cd f7 9c				call forth_tok_next 
a4cc			 
a4cc			 
a4cc			; while we have words to look for 
a4cc			 
a4cc 7e			.douscan:	ld a, (hl)      
a4cd				if DEBUG_FORTH_WORDS 
a4cd					DMARK "UWs" 
a4cd f5				push af  
a4ce 3a e2 a4			ld a, (.dmark)  
a4d1 32 c0 ee			ld (debug_mark),a  
a4d4 3a e3 a4			ld a, (.dmark+1)  
a4d7 32 c1 ee			ld (debug_mark+1),a  
a4da 3a e4 a4			ld a, (.dmark+2)  
a4dd 32 c2 ee			ld (debug_mark+2),a  
a4e0 18 03			jr .pastdmark  
a4e2 ..			.dmark: db "UWs"  
a4e5 f1			.pastdmark: pop af  
a4e6			endm  
# End of macro DMARK
a4e6					CALLMONITOR 
a4e6 cd b0 92			call break_point_state  
a4e9				endm  
# End of macro CALLMONITOR
a4e9				endif 
a4e9 fe 00				cp WORD_SYS_END 
a4eb 28 4d				jr z, .udone 
a4ed fe 01				cp WORD_SYS_UWORD 
a4ef 20 44				jr nz, .nuword 
a4f1			 
a4f1				if DEBUG_FORTH_WORDS 
a4f1					DMARK "UWu" 
a4f1 f5				push af  
a4f2 3a 06 a5			ld a, (.dmark)  
a4f5 32 c0 ee			ld (debug_mark),a  
a4f8 3a 07 a5			ld a, (.dmark+1)  
a4fb 32 c1 ee			ld (debug_mark+1),a  
a4fe 3a 08 a5			ld a, (.dmark+2)  
a501 32 c2 ee			ld (debug_mark+2),a  
a504 18 03			jr .pastdmark  
a506 ..			.dmark: db "UWu"  
a509 f1			.pastdmark: pop af  
a50a			endm  
# End of macro DMARK
a50a					CALLMONITOR 
a50a cd b0 92			call break_point_state  
a50d				endm  
# End of macro CALLMONITOR
a50d				endif 
a50d					; we have a uword so push its name to the stack 
a50d			 
a50d e5				   	push hl  ; save so we can move to next dict block 
a50e			 
a50e					; skip opcode 
a50e 23					inc hl  
a50f					; skip next ptr 
a50f 23					inc hl  
a510 23					inc hl 
a511					; skip len 
a511 23					inc hl 
a512				if DEBUG_FORTH_WORDS 
a512					DMARK "UWt" 
a512 f5				push af  
a513 3a 27 a5			ld a, (.dmark)  
a516 32 c0 ee			ld (debug_mark),a  
a519 3a 28 a5			ld a, (.dmark+1)  
a51c 32 c1 ee			ld (debug_mark+1),a  
a51f 3a 29 a5			ld a, (.dmark+2)  
a522 32 c2 ee			ld (debug_mark+2),a  
a525 18 03			jr .pastdmark  
a527 ..			.dmark: db "UWt"  
a52a f1			.pastdmark: pop af  
a52b			endm  
# End of macro DMARK
a52b					CALLMONITOR 
a52b cd b0 92			call break_point_state  
a52e				endm  
# End of macro CALLMONITOR
a52e				endif 
a52e 03					inc bc 
a52f			 
a52f c5					push bc 
a530 cd ab 98				call forth_push_str 
a533 c1					pop bc 
a534			 
a534 e1					pop hl 	 
a535			 
a535 cd f7 9c		.nuword:	call forth_tok_next 
a538 18 92				jr .douscan  
a53a			 
a53a			.udone:		 ; push count of uwords found 
a53a c5					push bc 
a53b e1					pop hl 
a53c			 
a53c				if DEBUG_FORTH_WORDS 
a53c					DMARK "UWc" 
a53c f5				push af  
a53d 3a 51 a5			ld a, (.dmark)  
a540 32 c0 ee			ld (debug_mark),a  
a543 3a 52 a5			ld a, (.dmark+1)  
a546 32 c1 ee			ld (debug_mark+1),a  
a549 3a 53 a5			ld a, (.dmark+2)  
a54c 32 c2 ee			ld (debug_mark+2),a  
a54f 18 03			jr .pastdmark  
a551 ..			.dmark: db "UWc"  
a554 f1			.pastdmark: pop af  
a555			endm  
# End of macro DMARK
a555					CALLMONITOR 
a555 cd b0 92			call break_point_state  
a558				endm  
# End of macro CALLMONITOR
a558				endif 
a558 cd 3d 98				call forth_push_numhl 
a55b			 
a55b			 
a55b				       NEXTW 
a55b c3 a6 9b			jp macro_next 
a55e				endm 
# End of macro NEXTW
a55e			 
a55e			.BP: 
a55e				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a55e 54				db WORD_SYS_CORE+64             
a55f 94 a5			dw .MONITOR            
a561 03				db 2 + 1 
a562 .. 00			db "BP",0              
a565				endm 
# End of macro CWHEAD
a565			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a565			; | | $00 Will enable the break points within specific code paths 
a565			; | | $01 Will disable break points 
a565			; | |  
a565			; | | By default break points are off. Either the above can be used to enable them 
a565			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a565			; | | and on release of the pressed key a message will be disaplayed to notify 
a565			; | | that break points are enabled. Pressing any key will then continue boot process. 
a565					; get byte count 
a565					if DEBUG_FORTH_WORDS_KEY 
a565						DMARK "BP." 
a565 f5				push af  
a566 3a 7a a5			ld a, (.dmark)  
a569 32 c0 ee			ld (debug_mark),a  
a56c 3a 7b a5			ld a, (.dmark+1)  
a56f 32 c1 ee			ld (debug_mark+1),a  
a572 3a 7c a5			ld a, (.dmark+2)  
a575 32 c2 ee			ld (debug_mark+2),a  
a578 18 03			jr .pastdmark  
a57a ..			.dmark: db "BP."  
a57d f1			.pastdmark: pop af  
a57e			endm  
# End of macro DMARK
a57e						CALLMONITOR 
a57e cd b0 92			call break_point_state  
a581				endm  
# End of macro CALLMONITOR
a581					endif 
a581			 
a581					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a581 cd 34 9a			call macro_dsp_valuehl 
a584				endm 
# End of macro FORTH_DSP_VALUEHL
a584			 
a584			;		push hl 
a584			 
a584					; destroy value TOS 
a584			 
a584					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a584 cd ec 9a			call macro_forth_dsp_pop 
a587				endm 
# End of macro FORTH_DSP_POP
a587			 
a587			;		pop hl 
a587			 
a587 3e 00				ld a,0 
a589 bd					cp l 
a58a 28 02				jr z, .bpset 
a58c 3e 2a				ld a, '*' 
a58e			 
a58e 32 d7 e4		.bpset:		ld (os_view_disable), a 
a591			 
a591			 
a591					NEXTW 
a591 c3 a6 9b			jp macro_next 
a594				endm 
# End of macro NEXTW
a594			 
a594			 
a594			.MONITOR: 
a594				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a594 55				db WORD_SYS_CORE+65             
a595 c7 a5			dw .MALLOC            
a597 08				db 7 + 1 
a598 .. 00			db "MONITOR",0              
a5a0				endm 
# End of macro CWHEAD
a5a0			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a5a0			; | | At start the current various registers will be displayed with contents. 
a5a0			; | | Top right corner will show the most recent debug marker seen. 
a5a0			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a5a0			; | | and the return stack pointer (RSP). 
a5a0			; | | Pressing: 
a5a0			; | |    1 - Initial screen 
a5a0			; | |    2 - Display a data dump of HL 
a5a0			; | |    3 - Display a data dump of DE 
a5a0			; | |    4 - Display a data dump of BC 
a5a0			; | |    5 - Display a data dump of HL 
a5a0			; | |    6 - Display a data dump of DSP 
a5a0			; | |    7 - Display a data dump of RSP 
a5a0			; | |    8 - Display a data dump of what is at DSP 
a5a0			; | |    9 - Display a data dump of what is at RSP 
a5a0			; | |    0 - Exit monitor and continue running. This will also enable break points 
a5a0			; | |    * - Disable break points 
a5a0			; | |    # - Enter traditional monitor mode 
a5a0			; | | 
a5a0			; | | Monitor Mode 
a5a0			; | | ------------ 
a5a0			; | | A prompt of '>' will be shown for various commands: 
a5a0			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a5a0			; | |    C - Continue display a data dump from the last set address 
a5a0			; | |    M xxxx - Set start of memory edit at address xx 
a5a0			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a5a0			; | |    Q - Return to previous 
a5a0					if DEBUG_FORTH_WORDS_KEY 
a5a0						DMARK "MON" 
a5a0 f5				push af  
a5a1 3a b5 a5			ld a, (.dmark)  
a5a4 32 c0 ee			ld (debug_mark),a  
a5a7 3a b6 a5			ld a, (.dmark+1)  
a5aa 32 c1 ee			ld (debug_mark+1),a  
a5ad 3a b7 a5			ld a, (.dmark+2)  
a5b0 32 c2 ee			ld (debug_mark+2),a  
a5b3 18 03			jr .pastdmark  
a5b5 ..			.dmark: db "MON"  
a5b8 f1			.pastdmark: pop af  
a5b9			endm  
# End of macro DMARK
a5b9						CALLMONITOR 
a5b9 cd b0 92			call break_point_state  
a5bc				endm  
# End of macro CALLMONITOR
a5bc					endif 
a5bc 3e 00				ld a, 0 
a5be 32 d7 e4				ld (os_view_disable), a 
a5c1			 
a5c1					CALLMONITOR 
a5c1 cd b0 92			call break_point_state  
a5c4				endm  
# End of macro CALLMONITOR
a5c4			 
a5c4			;	call monitor 
a5c4			 
a5c4					NEXTW 
a5c4 c3 a6 9b			jp macro_next 
a5c7				endm 
# End of macro NEXTW
a5c7			 
a5c7			 
a5c7			.MALLOC: 
a5c7				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a5c7 56				db WORD_SYS_CORE+66             
a5c8 f0 a5			dw .MALLOC2            
a5ca 06				db 5 + 1 
a5cb .. 00			db "ALLOT",0              
a5d1				endm 
# End of macro CWHEAD
a5d1			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a5d1					if DEBUG_FORTH_WORDS_KEY 
a5d1						DMARK "ALL" 
a5d1 f5				push af  
a5d2 3a e6 a5			ld a, (.dmark)  
a5d5 32 c0 ee			ld (debug_mark),a  
a5d8 3a e7 a5			ld a, (.dmark+1)  
a5db 32 c1 ee			ld (debug_mark+1),a  
a5de 3a e8 a5			ld a, (.dmark+2)  
a5e1 32 c2 ee			ld (debug_mark+2),a  
a5e4 18 03			jr .pastdmark  
a5e6 ..			.dmark: db "ALL"  
a5e9 f1			.pastdmark: pop af  
a5ea			endm  
# End of macro DMARK
a5ea						CALLMONITOR 
a5ea cd b0 92			call break_point_state  
a5ed				endm  
# End of macro CALLMONITOR
a5ed					endif 
a5ed c3 17 a6				jp .mallocc 
a5f0			.MALLOC2: 
a5f0				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a5f0 56				db WORD_SYS_CORE+66             
a5f1 2e a6			dw .FREE            
a5f3 07				db 6 + 1 
a5f4 .. 00			db "MALLOC",0              
a5fb				endm 
# End of macro CWHEAD
a5fb			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a5fb					; get byte count 
a5fb					if DEBUG_FORTH_WORDS_KEY 
a5fb						DMARK "MAL" 
a5fb f5				push af  
a5fc 3a 10 a6			ld a, (.dmark)  
a5ff 32 c0 ee			ld (debug_mark),a  
a602 3a 11 a6			ld a, (.dmark+1)  
a605 32 c1 ee			ld (debug_mark+1),a  
a608 3a 12 a6			ld a, (.dmark+2)  
a60b 32 c2 ee			ld (debug_mark+2),a  
a60e 18 03			jr .pastdmark  
a610 ..			.dmark: db "MAL"  
a613 f1			.pastdmark: pop af  
a614			endm  
# End of macro DMARK
a614						CALLMONITOR 
a614 cd b0 92			call break_point_state  
a617				endm  
# End of macro CALLMONITOR
a617					endif 
a617			.mallocc: 
a617					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a617 cd 34 9a			call macro_dsp_valuehl 
a61a				endm 
# End of macro FORTH_DSP_VALUEHL
a61a			 
a61a			;		push hl 
a61a			 
a61a					; destroy value TOS 
a61a			 
a61a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a61a cd ec 9a			call macro_forth_dsp_pop 
a61d				endm 
# End of macro FORTH_DSP_POP
a61d			 
a61d			;		pop hl 
a61d cd 30 8f				call malloc 
a620				if DEBUG_FORTH_MALLOC_GUARD 
a620 f5					push af 
a621 cd 92 8a				call ishlzero 
a624			;		ld a, l 
a624			;		add h 
a624			;		cp 0 
a624 f1					pop af 
a625					 
a625 cc e5 c4				call z,malloc_error 
a628				endif 
a628			 
a628 cd 3d 98				call forth_push_numhl 
a62b					NEXTW 
a62b c3 a6 9b			jp macro_next 
a62e				endm 
# End of macro NEXTW
a62e			 
a62e			.FREE: 
a62e				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a62e 57				db WORD_SYS_CORE+67             
a62f 5f a6			dw .LIST            
a631 05				db 4 + 1 
a632 .. 00			db "FREE",0              
a637				endm 
# End of macro CWHEAD
a637			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a637					if DEBUG_FORTH_WORDS_KEY 
a637						DMARK "FRE" 
a637 f5				push af  
a638 3a 4c a6			ld a, (.dmark)  
a63b 32 c0 ee			ld (debug_mark),a  
a63e 3a 4d a6			ld a, (.dmark+1)  
a641 32 c1 ee			ld (debug_mark+1),a  
a644 3a 4e a6			ld a, (.dmark+2)  
a647 32 c2 ee			ld (debug_mark+2),a  
a64a 18 03			jr .pastdmark  
a64c ..			.dmark: db "FRE"  
a64f f1			.pastdmark: pop af  
a650			endm  
# End of macro DMARK
a650						CALLMONITOR 
a650 cd b0 92			call break_point_state  
a653				endm  
# End of macro CALLMONITOR
a653					endif 
a653					; get address 
a653			 
a653					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a653 cd 34 9a			call macro_dsp_valuehl 
a656				endm 
# End of macro FORTH_DSP_VALUEHL
a656			 
a656			;		push hl 
a656			 
a656					; destroy value TOS 
a656			 
a656					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a656 cd ec 9a			call macro_forth_dsp_pop 
a659				endm 
# End of macro FORTH_DSP_POP
a659			 
a659			;		pop hl 
a659			if FORTH_ENABLE_MALLOCFREE 
a659 cd fa 8f				call free 
a65c			endif 
a65c					NEXTW 
a65c c3 a6 9b			jp macro_next 
a65f				endm 
# End of macro NEXTW
a65f			.LIST: 
a65f				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a65f 5c				db WORD_SYS_CORE+72             
a660 22 a8			dw .FORGET            
a662 05				db 4 + 1 
a663 .. 00			db "LIST",0              
a668				endm 
# End of macro CWHEAD
a668			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a668			; | | The quoted word must be in upper case. 
a668				if DEBUG_FORTH_WORDS_KEY 
a668					DMARK "LST" 
a668 f5				push af  
a669 3a 7d a6			ld a, (.dmark)  
a66c 32 c0 ee			ld (debug_mark),a  
a66f 3a 7e a6			ld a, (.dmark+1)  
a672 32 c1 ee			ld (debug_mark+1),a  
a675 3a 7f a6			ld a, (.dmark+2)  
a678 32 c2 ee			ld (debug_mark+2),a  
a67b 18 03			jr .pastdmark  
a67d ..			.dmark: db "LST"  
a680 f1			.pastdmark: pop af  
a681			endm  
# End of macro DMARK
a681					CALLMONITOR 
a681 cd b0 92			call break_point_state  
a684				endm  
# End of macro CALLMONITOR
a684				endif 
a684			 
a684					FORTH_DSP_VALUEHL 
a684 cd 34 9a			call macro_dsp_valuehl 
a687				endm 
# End of macro FORTH_DSP_VALUEHL
a687			 
a687 e5					push hl 
a688 c1					pop bc 
a689			 
a689			; Start format of scratch string 
a689			 
a689 21 e6 e4				ld hl, scratch 
a68c			 
a68c 3e 3a				ld a, ':' 
a68e 77					ld (hl),a 
a68f 23					inc hl 
a690 3e 20				ld a, ' ' 
a692 77					ld (hl), a 
a693			 
a693					; Get ptr to the word we need to look up 
a693			 
a693			;		FORTH_DSP_VALUEHL 
a693					;v5 FORTH_DSP_VALUE 
a693				; TODO type check 
a693			;		inc hl    ; Skip type check  
a693			;		push hl 
a693			;		ex de, hl    ; put into DE 
a693			 
a693			 
a693 21 30 d8				ld hl, baseram 
a696					;ld hl, baseusermem 
a696			 
a696 e5			push hl   ; sacreifical push 
a697			 
a697			.ldouscanm: 
a697 e1				pop hl 
a698			.ldouscan: 
a698				if DEBUG_FORTH_WORDS 
a698					DMARK "LSs" 
a698 f5				push af  
a699 3a ad a6			ld a, (.dmark)  
a69c 32 c0 ee			ld (debug_mark),a  
a69f 3a ae a6			ld a, (.dmark+1)  
a6a2 32 c1 ee			ld (debug_mark+1),a  
a6a5 3a af a6			ld a, (.dmark+2)  
a6a8 32 c2 ee			ld (debug_mark+2),a  
a6ab 18 03			jr .pastdmark  
a6ad ..			.dmark: db "LSs"  
a6b0 f1			.pastdmark: pop af  
a6b1			endm  
# End of macro DMARK
a6b1					CALLMONITOR 
a6b1 cd b0 92			call break_point_state  
a6b4				endm  
# End of macro CALLMONITOR
a6b4				endif 
a6b4				; skip dict stub 
a6b4 cd f7 9c				call forth_tok_next 
a6b7			 
a6b7			 
a6b7			; while we have words to look for 
a6b7			 
a6b7 7e				ld a, (hl)      
a6b8				if DEBUG_FORTH_WORDS 
a6b8					DMARK "LSk" 
a6b8 f5				push af  
a6b9 3a cd a6			ld a, (.dmark)  
a6bc 32 c0 ee			ld (debug_mark),a  
a6bf 3a ce a6			ld a, (.dmark+1)  
a6c2 32 c1 ee			ld (debug_mark+1),a  
a6c5 3a cf a6			ld a, (.dmark+2)  
a6c8 32 c2 ee			ld (debug_mark+2),a  
a6cb 18 03			jr .pastdmark  
a6cd ..			.dmark: db "LSk"  
a6d0 f1			.pastdmark: pop af  
a6d1			endm  
# End of macro DMARK
a6d1					CALLMONITOR 
a6d1 cd b0 92			call break_point_state  
a6d4				endm  
# End of macro CALLMONITOR
a6d4				endif 
a6d4 fe 00				cp WORD_SYS_END 
a6d6 ca 09 a8				jp z, .lunotfound 
a6d9 fe 01				cp WORD_SYS_UWORD 
a6db c2 98 a6				jp nz, .ldouscan 
a6de			 
a6de				if DEBUG_FORTH_WORDS 
a6de					DMARK "LSu" 
a6de f5				push af  
a6df 3a f3 a6			ld a, (.dmark)  
a6e2 32 c0 ee			ld (debug_mark),a  
a6e5 3a f4 a6			ld a, (.dmark+1)  
a6e8 32 c1 ee			ld (debug_mark+1),a  
a6eb 3a f5 a6			ld a, (.dmark+2)  
a6ee 32 c2 ee			ld (debug_mark+2),a  
a6f1 18 03			jr .pastdmark  
a6f3 ..			.dmark: db "LSu"  
a6f6 f1			.pastdmark: pop af  
a6f7			endm  
# End of macro DMARK
a6f7					CALLMONITOR 
a6f7 cd b0 92			call break_point_state  
a6fa				endm  
# End of macro CALLMONITOR
a6fa				endif 
a6fa			 
a6fa					; found a uword but is it the one we want... 
a6fa			 
a6fa c5					push bc     ; uword to find is on bc 
a6fb d1					pop de 
a6fc			 
a6fc e5					push hl  ; to save the ptr 
a6fd			 
a6fd					; skip opcode 
a6fd 23					inc hl  
a6fe					; skip next ptr 
a6fe 23					inc hl  
a6ff 23					inc hl 
a700					; skip len 
a700 23					inc hl 
a701			 
a701				if DEBUG_FORTH_WORDS 
a701					DMARK "LSc" 
a701 f5				push af  
a702 3a 16 a7			ld a, (.dmark)  
a705 32 c0 ee			ld (debug_mark),a  
a708 3a 17 a7			ld a, (.dmark+1)  
a70b 32 c1 ee			ld (debug_mark+1),a  
a70e 3a 18 a7			ld a, (.dmark+2)  
a711 32 c2 ee			ld (debug_mark+2),a  
a714 18 03			jr .pastdmark  
a716 ..			.dmark: db "LSc"  
a719 f1			.pastdmark: pop af  
a71a			endm  
# End of macro DMARK
a71a					CALLMONITOR 
a71a cd b0 92			call break_point_state  
a71d				endm  
# End of macro CALLMONITOR
a71d				endif 
a71d cd ff 8e				call strcmp 
a720 c2 97 a6				jp nz, .ldouscanm 
a723				 
a723			 
a723			 
a723					; we have a uword so push its name to the stack 
a723			 
a723			;	   	push hl  ; save so we can move to next dict block 
a723 e1			pop hl 
a724			 
a724				if DEBUG_FORTH_WORDS 
a724					DMARK "LSm" 
a724 f5				push af  
a725 3a 39 a7			ld a, (.dmark)  
a728 32 c0 ee			ld (debug_mark),a  
a72b 3a 3a a7			ld a, (.dmark+1)  
a72e 32 c1 ee			ld (debug_mark+1),a  
a731 3a 3b a7			ld a, (.dmark+2)  
a734 32 c2 ee			ld (debug_mark+2),a  
a737 18 03			jr .pastdmark  
a739 ..			.dmark: db "LSm"  
a73c f1			.pastdmark: pop af  
a73d			endm  
# End of macro DMARK
a73d					CALLMONITOR 
a73d cd b0 92			call break_point_state  
a740				endm  
# End of macro CALLMONITOR
a740				endif 
a740			 
a740					; skip opcode 
a740 23					inc hl  
a741					; skip next ptr 
a741 23					inc hl  
a742 23					inc hl 
a743					; skip len 
a743 7e					ld a, (hl)   ; save length to add 
a744				if DEBUG_FORTH_WORDS 
a744					DMARK "LS2" 
a744 f5				push af  
a745 3a 59 a7			ld a, (.dmark)  
a748 32 c0 ee			ld (debug_mark),a  
a74b 3a 5a a7			ld a, (.dmark+1)  
a74e 32 c1 ee			ld (debug_mark+1),a  
a751 3a 5b a7			ld a, (.dmark+2)  
a754 32 c2 ee			ld (debug_mark+2),a  
a757 18 03			jr .pastdmark  
a759 ..			.dmark: db "LS2"  
a75c f1			.pastdmark: pop af  
a75d			endm  
# End of macro DMARK
a75d					CALLMONITOR 
a75d cd b0 92			call break_point_state  
a760				endm  
# End of macro CALLMONITOR
a760				endif 
a760			 
a760					; save this location 
a760				 
a760 e5					push hl 
a761			 
a761 23					inc hl 
a762 11 e8 e4				ld de, scratch+2 
a765 4f					ld c, a 
a766 06 00				ld b, 0 
a768			 
a768				if DEBUG_FORTH_WORDS 
a768					DMARK "LSn" 
a768 f5				push af  
a769 3a 7d a7			ld a, (.dmark)  
a76c 32 c0 ee			ld (debug_mark),a  
a76f 3a 7e a7			ld a, (.dmark+1)  
a772 32 c1 ee			ld (debug_mark+1),a  
a775 3a 7f a7			ld a, (.dmark+2)  
a778 32 c2 ee			ld (debug_mark+2),a  
a77b 18 03			jr .pastdmark  
a77d ..			.dmark: db "LSn"  
a780 f1			.pastdmark: pop af  
a781			endm  
# End of macro DMARK
a781					CALLMONITOR 
a781 cd b0 92			call break_point_state  
a784				endm  
# End of macro CALLMONITOR
a784				endif 
a784			 
a784					; copy uword name to scratch 
a784			 
a784 ed b0				ldir 
a786			 
a786 1b					dec de 
a787 3e 20				ld a, ' '    ; change null to space 
a789 12					ld (de), a 
a78a			 
a78a 13					inc de 
a78b			 
a78b d5					push de 
a78c c1					pop bc     ; move scratch pointer to end of word name and save it 
a78d			 
a78d e1					pop hl 
a78e 7e					ld a, (hl) 
a78f					;inc hl 
a78f					; skip word string 
a78f cd 69 8a				call addatohl 
a792			 
a792 23					inc hl 
a793			 
a793				if DEBUG_FORTH_WORDS 
a793					DMARK "LS3" 
a793 f5				push af  
a794 3a a8 a7			ld a, (.dmark)  
a797 32 c0 ee			ld (debug_mark),a  
a79a 3a a9 a7			ld a, (.dmark+1)  
a79d 32 c1 ee			ld (debug_mark+1),a  
a7a0 3a aa a7			ld a, (.dmark+2)  
a7a3 32 c2 ee			ld (debug_mark+2),a  
a7a6 18 03			jr .pastdmark  
a7a8 ..			.dmark: db "LS3"  
a7ab f1			.pastdmark: pop af  
a7ac			endm  
# End of macro DMARK
a7ac					CALLMONITOR 
a7ac cd b0 92			call break_point_state  
a7af				endm  
# End of macro CALLMONITOR
a7af				endif 
a7af					; should now be at the start of the machine code to setup the eval of the uword 
a7af					; now locate the ptr to the string defintion 
a7af			 
a7af					; skip ld hl, 
a7af					; then load the ptr 
a7af			 
a7af 23					inc hl 
a7b0 5e					ld e, (hl) 
a7b1 23					inc hl 
a7b2 56					ld d, (hl) 
a7b3 eb					ex de, hl 
a7b4			 
a7b4			 
a7b4				if DEBUG_FORTH_WORDS 
a7b4					DMARK "LSt" 
a7b4 f5				push af  
a7b5 3a c9 a7			ld a, (.dmark)  
a7b8 32 c0 ee			ld (debug_mark),a  
a7bb 3a ca a7			ld a, (.dmark+1)  
a7be 32 c1 ee			ld (debug_mark+1),a  
a7c1 3a cb a7			ld a, (.dmark+2)  
a7c4 32 c2 ee			ld (debug_mark+2),a  
a7c7 18 03			jr .pastdmark  
a7c9 ..			.dmark: db "LSt"  
a7cc f1			.pastdmark: pop af  
a7cd			endm  
# End of macro DMARK
a7cd					CALLMONITOR 
a7cd cd b0 92			call break_point_state  
a7d0				endm  
# End of macro CALLMONITOR
a7d0				endif 
a7d0			 
a7d0			; cant push right now due to tokenised strings  
a7d0			 
a7d0			; get the destination of where to copy this definition to. 
a7d0			 
a7d0 c5					push bc 
a7d1 d1					pop de 
a7d2			 
a7d2 7e			.listl:         ld a,(hl) 
a7d3 fe 00				cp 0 
a7d5 28 09				jr z, .lreplsp     ; replace zero with space 
a7d7 fe 7f				cp FORTH_END_BUFFER 
a7d9 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a7db				 
a7db					; just copy this char as is then 
a7db			 
a7db 12					ld (de), a 
a7dc			 
a7dc 23			.listnxt:	inc hl 
a7dd 13					inc de 
a7de 18 f2				jr .listl 
a7e0			 
a7e0 3e 20		.lreplsp:	ld a,' ' 
a7e2 12					ld (de), a 
a7e3 18 f7				jr .listnxt 
a7e5			 
a7e5			; close up uword def 
a7e5			 
a7e5			.listdone: 
a7e5 3e 00				ld a, 0 
a7e7 12					ld (de), a 
a7e8			 
a7e8			; now have def so clean up and push to stack 
a7e8			 
a7e8 21 e6 e4				ld hl, scratch 
a7eb				if DEBUG_FORTH_WORDS 
a7eb					DMARK "Ltp" 
a7eb f5				push af  
a7ec 3a 00 a8			ld a, (.dmark)  
a7ef 32 c0 ee			ld (debug_mark),a  
a7f2 3a 01 a8			ld a, (.dmark+1)  
a7f5 32 c1 ee			ld (debug_mark+1),a  
a7f8 3a 02 a8			ld a, (.dmark+2)  
a7fb 32 c2 ee			ld (debug_mark+2),a  
a7fe 18 03			jr .pastdmark  
a800 ..			.dmark: db "Ltp"  
a803 f1			.pastdmark: pop af  
a804			endm  
# End of macro DMARK
a804					CALLMONITOR 
a804 cd b0 92			call break_point_state  
a807				endm  
# End of macro CALLMONITOR
a807				endif 
a807			 
a807 18 06			jr .listpush 
a809			 
a809			;.lnuword:	pop hl 
a809			;		call forth_tok_next 
a809			;		jp .ldouscan  
a809			 
a809			.lunotfound:		  
a809			 
a809			 
a809					 
a809					FORTH_DSP_POP 
a809 cd ec 9a			call macro_forth_dsp_pop 
a80c				endm 
# End of macro FORTH_DSP_POP
a80c 21 15 a8				ld hl, .luno 
a80f						 
a80f			 
a80f			.listpush: 
a80f cd ab 98				call forth_push_str 
a812			 
a812			 
a812			 
a812					NEXTW 
a812 c3 a6 9b			jp macro_next 
a815				endm 
# End of macro NEXTW
a815			 
a815 .. 00		.luno:    db "Not found",0 
a81f			 
a81f			 
a81f			 
a81f			 
a81f			 
a81f			;		push hl   ; save pointer to start of uword def string 
a81f			; 
a81f			;; look for FORTH_EOL_LINE 
a81f			;		ld a, FORTH_END_BUFFER 
a81f			;		call strlent 
a81f			; 
a81f			;		inc hl		 ; space for coln def 
a81f			;		inc hl 
a81f			;		inc hl          ; space for terms 
a81f			;		inc hl 
a81f			; 
a81f			;		ld a, 20   ; TODO get actual length 
a81f			;		call addatohl    ; include a random amount of room for the uword name 
a81f			; 
a81f			;		 
a81f			;	if DEBUG_FORTH_WORDS 
a81f			;		DMARK "Lt1" 
a81f			;		CALLMONITOR 
a81f			;	endif 
a81f			;		 
a81f			; 
a81f			;; malloc space for the string because we cant change it 
a81f			; 
a81f			;		call malloc 
a81f			;	if DEBUG_FORTH_MALLOC_GUARD 
a81f			;		push af 
a81f			;		call ishlzero 
a81f			;		pop af 
a81f			;		 
a81f			;		call z,malloc_error 
a81f			;	endif 
a81f			; 
a81f			;	if DEBUG_FORTH_WORDS 
a81f			;		DMARK "Lt2" 
a81f			;		CALLMONITOR 
a81f			;	endif 
a81f			;		pop de 
a81f			;		push hl    ; push the malloc to release later 
a81f			;		push hl   ;  push back a copy for the later stack push 
a81f			;		 
a81f			;; copy the string swapping out the zero terms for spaces 
a81f			; 
a81f			;		; de has our source 
a81f			;		; hl has our dest 
a81f			; 
a81f			;; add the coln def 
a81f			; 
a81f			;		ld a, ':' 
a81f			;		ld (hl), a 
a81f			;		inc hl 
a81f			;		ld a, ' ' 
a81f			;		ld (hl), a 
a81f			;		inc hl 
a81f			; 
a81f			;; add the uname word 
a81f			;		push de   ; save our string for now 
a81f			;		ex de, hl 
a81f			; 
a81f			;		FORTH_DSP_VALUE 
a81f			;		;v5 FORTH_DSP_VALUE 
a81f			; 
a81f			;		inc hl   ; skip type but we know by now this is OK 
a81f			; 
a81f			;.luword:	ld a,(hl) 
a81f			;		cp 0 
a81f			;		jr z, .luword2 
a81f			;		ld (de), a 
a81f			;		inc de 
a81f			;		inc hl 
a81f			;		jr .luword 
a81f			; 
a81f			;.luword2:	ld a, ' ' 
a81f			;		ld (de), a 
a81f			;;		inc hl 
a81f			;;		inc de 
a81f			;;		ld (de), a 
a81f			;;		inc hl 
a81f			;		inc de 
a81f			; 
a81f			;		ex de, hl 
a81f			;		pop de 
a81f			;		 
a81f			;		 
a81f			; 
a81f			;; detoken that string and copy it 
a81f			; 
a81f			;	if DEBUG_FORTH_WORDS 
a81f			;		DMARK "Lt2" 
a81f			;		CALLMONITOR 
a81f			;	endif 
a81f			;.ldetok:	ld a, (de) 
a81f			;		cp FORTH_END_BUFFER 
a81f			;		jr z, .ldetokend 
a81f			;		; swap out any zero term for space 
a81f			;		cp 0 
a81f			;		jr nz, .ldetoknext 
a81f			;		ld a, ' ' 
a81f			; 
a81f			;	if DEBUG_FORTH_WORDS 
a81f			;		DMARK "LtS" 
a81f			;		CALLMONITOR 
a81f			;	endif 
a81f			;.ldetoknext:	ld (hl), a 
a81f			;		inc de 
a81f			;		inc hl 
a81f			;		jr .ldetok 
a81f			; 
a81f			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a81f			;		ld (hl), a  
a81f			; 
a81f			;; free that temp malloc 
a81f			; 
a81f			;		pop hl    
a81f			; 
a81f			;	if DEBUG_FORTH_WORDS 
a81f			;		DMARK "Lt4" 
a81f			;		CALLMONITOR 
a81f			;	endif 
a81f			;		call forth_apushstrhl 
a81f			; 
a81f			;		; get rid of temp malloc area 
a81f			; 
a81f			;		pop hl 
a81f			;		call free 
a81f			; 
a81f			;		jr .ludone 
a81f			; 
a81f			;.lnuword:	pop hl 
a81f			;		call forth_tok_next 
a81f			;		jp .ldouscan  
a81f			; 
a81f			;.ludone:		 pop hl 
a81f			; 
a81f					NEXTW 
a81f c3 a6 9b			jp macro_next 
a822				endm 
# End of macro NEXTW
a822			 
a822			.FORGET: 
a822				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a822 5d				db WORD_SYS_CORE+73             
a823 9b a8			dw .NOP            
a825 07				db 6 + 1 
a826 .. 00			db "FORGET",0              
a82d				endm 
# End of macro CWHEAD
a82d			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a82d			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a82d			; | |  
a82d			; | | e.g. "MORE" forget 
a82d					if DEBUG_FORTH_WORDS_KEY 
a82d						DMARK "FRG" 
a82d f5				push af  
a82e 3a 42 a8			ld a, (.dmark)  
a831 32 c0 ee			ld (debug_mark),a  
a834 3a 43 a8			ld a, (.dmark+1)  
a837 32 c1 ee			ld (debug_mark+1),a  
a83a 3a 44 a8			ld a, (.dmark+2)  
a83d 32 c2 ee			ld (debug_mark+2),a  
a840 18 03			jr .pastdmark  
a842 ..			.dmark: db "FRG"  
a845 f1			.pastdmark: pop af  
a846			endm  
# End of macro DMARK
a846						CALLMONITOR 
a846 cd b0 92			call break_point_state  
a849				endm  
# End of macro CALLMONITOR
a849					endif 
a849			 
a849				; find uword 
a849			        ; update start of word with "_" 
a849				; replace uword with deleted flag 
a849			 
a849			 
a849			;	if DEBUG_FORTH_WORDS 
a849			;		DMARK "FOG" 
a849			;		CALLMONITOR 
a849			;	endif 
a849			 
a849			 
a849					; Get ptr to the word we need to look up 
a849			 
a849					FORTH_DSP_VALUEHL 
a849 cd 34 9a			call macro_dsp_valuehl 
a84c				endm 
# End of macro FORTH_DSP_VALUEHL
a84c					;v5 FORTH_DSP_VALUE 
a84c				; TODO type check 
a84c			;		inc hl    ; Skip type check  
a84c e5					push hl 
a84d c1					pop bc 
a84e			;		ex de, hl    ; put into DE 
a84e			 
a84e			 
a84e 21 30 d8				ld hl, baseram 
a851					;ld hl, baseusermem 
a851			 
a851				; skip dict stub 
a851			;	call forth_tok_next 
a851 e5			push hl   ; sacreifical push 
a852			 
a852			.fldouscanm: 
a852 e1				pop hl 
a853			.fldouscan: 
a853			;	if DEBUG_FORTH_WORDS 
a853			;		DMARK "LSs" 
a853			;		CALLMONITOR 
a853			;	endif 
a853				; skip dict stub 
a853 cd f7 9c				call forth_tok_next 
a856			 
a856			 
a856			; while we have words to look for 
a856			 
a856 7e				ld a, (hl)      
a857			;	if DEBUG_FORTH_WORDS 
a857			;		DMARK "LSk" 
a857			;		CALLMONITOR 
a857			;	endif 
a857 fe 00				cp WORD_SYS_END 
a859 ca 95 a8				jp z, .flunotfound 
a85c fe 01				cp WORD_SYS_UWORD 
a85e c2 53 a8				jp nz, .fldouscan 
a861			 
a861			;	if DEBUG_FORTH_WORDS 
a861			;		DMARK "LSu" 
a861			;		CALLMONITOR 
a861			;	endif 
a861			 
a861					; found a uword but is it the one we want... 
a861			 
a861 c5					push bc     ; uword to find is on bc 
a862 d1					pop de 
a863			 
a863 e5					push hl  ; to save the ptr 
a864			 
a864					; skip opcode 
a864 23					inc hl  
a865					; skip next ptr 
a865 23					inc hl  
a866 23					inc hl 
a867					; skip len 
a867 23					inc hl 
a868			 
a868			;	if DEBUG_FORTH_WORDS 
a868			;		DMARK "LSc" 
a868			;		CALLMONITOR 
a868			;	endif 
a868 cd ff 8e				call strcmp 
a86b c2 52 a8				jp nz, .fldouscanm 
a86e			; 
a86e			; 
a86e			;; while we have words to look for 
a86e			; 
a86e			;.fdouscan:	ld a, (hl)      
a86e			;	if DEBUG_FORTH_WORDS 
a86e			;		DMARK "LSs" 
a86e			;		CALLMONITOR 
a86e			;	endif 
a86e			;		cp WORD_SYS_END 
a86e			;		jp z, .fudone 
a86e			;		cp WORD_SYS_UWORD 
a86e			;		jp nz, .fnuword 
a86e			; 
a86e			;	if DEBUG_FORTH_WORDS 
a86e			;		DMARK "FGu" 
a86e			;		CALLMONITOR 
a86e			;	endif 
a86e			; 
a86e			;		; found a uword but is it the one we want... 
a86e			; 
a86e			; 
a86e			;	        pop de   ; get back the dsp name 
a86e			;		push de 
a86e			; 
a86e			;		push hl  ; to save the ptr 
a86e			; 
a86e			;		; skip opcode 
a86e			;		inc hl  
a86e			;		; skip next ptr 
a86e			;		inc hl  
a86e			;		inc hl 
a86e			;		; skip len 
a86e			;		inc hl 
a86e			; 
a86e			;	if DEBUG_FORTH_WORDS 
a86e			;		DMARK "FGc" 
a86e			;		CALLMONITOR 
a86e			;	endif 
a86e			;		call strcmp 
a86e			;		jp nz, .fnuword 
a86e			 
a86e			 
a86e e1			pop hl 
a86f			 
a86f				 
a86f				if DEBUG_FORTH_WORDS 
a86f					DMARK "FGm" 
a86f f5				push af  
a870 3a 84 a8			ld a, (.dmark)  
a873 32 c0 ee			ld (debug_mark),a  
a876 3a 85 a8			ld a, (.dmark+1)  
a879 32 c1 ee			ld (debug_mark+1),a  
a87c 3a 86 a8			ld a, (.dmark+2)  
a87f 32 c2 ee			ld (debug_mark+2),a  
a882 18 03			jr .pastdmark  
a884 ..			.dmark: db "FGm"  
a887 f1			.pastdmark: pop af  
a888			endm  
# End of macro DMARK
a888					CALLMONITOR 
a888 cd b0 92			call break_point_state  
a88b				endm  
# End of macro CALLMONITOR
a88b				endif 
a88b			 
a88b			 
a88b			 
a88b					; we have a uword so push its name to the stack 
a88b			 
a88b			;	   	push hl  ; save so we can move to next dict block 
a88b			;pop hl 
a88b			 
a88b					; update opcode to deleted 
a88b 3e 03				ld a, WORD_SYS_DELETED 
a88d 77					ld (hl), a 
a88e			 
a88e 23					inc hl  
a88f					; skip next ptr 
a88f 23					inc hl  
a890 23					inc hl 
a891					; skip len 
a891 23					inc hl 
a892			 
a892					; TODO change parser to skip deleted words but for now mark it out 
a892 3e 5f				ld a, "_" 
a894 77					ld  (hl),a 
a895			 
a895			;		jr .fudone 
a895			; 
a895			;.fnuword:	pop hl 
a895			;		call forth_tok_next 
a895			;		jp .fdouscan  
a895			 
a895			.flunotfound:		  
a895			 
a895			 
a895					 
a895					FORTH_DSP_POP 
a895 cd ec 9a			call macro_forth_dsp_pop 
a898				endm 
# End of macro FORTH_DSP_POP
a898			;		ld hl, .luno 
a898			;.fudone:		 pop hl 
a898					NEXTW 
a898 c3 a6 9b			jp macro_next 
a89b				endm 
# End of macro NEXTW
a89b			.NOP: 
a89b				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a89b 61				db WORD_SYS_CORE+77             
a89c c2 a8			dw .COMO            
a89e 04				db 3 + 1 
a89f .. 00			db "NOP",0              
a8a3				endm 
# End of macro CWHEAD
a8a3			; | NOP (  --  ) Do nothing | DONE 
a8a3					if DEBUG_FORTH_WORDS_KEY 
a8a3						DMARK "NOP" 
a8a3 f5				push af  
a8a4 3a b8 a8			ld a, (.dmark)  
a8a7 32 c0 ee			ld (debug_mark),a  
a8aa 3a b9 a8			ld a, (.dmark+1)  
a8ad 32 c1 ee			ld (debug_mark+1),a  
a8b0 3a ba a8			ld a, (.dmark+2)  
a8b3 32 c2 ee			ld (debug_mark+2),a  
a8b6 18 03			jr .pastdmark  
a8b8 ..			.dmark: db "NOP"  
a8bb f1			.pastdmark: pop af  
a8bc			endm  
# End of macro DMARK
a8bc						CALLMONITOR 
a8bc cd b0 92			call break_point_state  
a8bf				endm  
# End of macro CALLMONITOR
a8bf					endif 
a8bf				       NEXTW 
a8bf c3 a6 9b			jp macro_next 
a8c2				endm 
# End of macro NEXTW
a8c2			.COMO: 
a8c2				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a8c2 6e				db WORD_SYS_CORE+90             
a8c3 14 a9			dw .COMC            
a8c5 02				db 1 + 1 
a8c6 .. 00			db "(",0              
a8c8				endm 
# End of macro CWHEAD
a8c8			; | ( ( -- )  Start of comment | DONE 
a8c8			 
a8c8			 
a8c8 2a e7 e7				ld hl, ( os_tok_ptr) 
a8cb 11 0f a9			ld de, .closepar 
a8ce					 
a8ce					if DEBUG_FORTH_WORDS 
a8ce						DMARK ").." 
a8ce f5				push af  
a8cf 3a e3 a8			ld a, (.dmark)  
a8d2 32 c0 ee			ld (debug_mark),a  
a8d5 3a e4 a8			ld a, (.dmark+1)  
a8d8 32 c1 ee			ld (debug_mark+1),a  
a8db 3a e5 a8			ld a, (.dmark+2)  
a8de 32 c2 ee			ld (debug_mark+2),a  
a8e1 18 03			jr .pastdmark  
a8e3 ..			.dmark: db ").."  
a8e6 f1			.pastdmark: pop af  
a8e7			endm  
# End of macro DMARK
a8e7						CALLMONITOR 
a8e7 cd b0 92			call break_point_state  
a8ea				endm  
# End of macro CALLMONITOR
a8ea					endif 
a8ea cd c1 9c			call findnexttok  
a8ed			 
a8ed					if DEBUG_FORTH_WORDS 
a8ed						DMARK "IF5" 
a8ed f5				push af  
a8ee 3a 02 a9			ld a, (.dmark)  
a8f1 32 c0 ee			ld (debug_mark),a  
a8f4 3a 03 a9			ld a, (.dmark+1)  
a8f7 32 c1 ee			ld (debug_mark+1),a  
a8fa 3a 04 a9			ld a, (.dmark+2)  
a8fd 32 c2 ee			ld (debug_mark+2),a  
a900 18 03			jr .pastdmark  
a902 ..			.dmark: db "IF5"  
a905 f1			.pastdmark: pop af  
a906			endm  
# End of macro DMARK
a906						CALLMONITOR 
a906 cd b0 92			call break_point_state  
a909				endm  
# End of macro CALLMONITOR
a909					endif 
a909				; replace below with ) exec using tok_ptr 
a909 22 e7 e7			ld (os_tok_ptr), hl 
a90c c3 37 9c			jp exec1 
a90f			 
a90f .. 00			.closepar:   db ")",0 
a911			 
a911				       NEXTW 
a911 c3 a6 9b			jp macro_next 
a914				endm 
# End of macro NEXTW
a914			.COMC: 
a914				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a914 6f				db WORD_SYS_CORE+91             
a915 1d a9			dw .SCRATCH            
a917 02				db 1 + 1 
a918 .. 00			db ")",0              
a91a				endm 
# End of macro CWHEAD
a91a			; | ) ( -- )  End of comment |  DONE  
a91a				       NEXTW 
a91a c3 a6 9b			jp macro_next 
a91d				endm 
# End of macro NEXTW
a91d			 
a91d			.SCRATCH: 
a91d				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a91d 6f				db WORD_SYS_CORE+91             
a91e 58 a9			dw .INC            
a920 08				db 7 + 1 
a921 .. 00			db "SCRATCH",0              
a929				endm 
# End of macro CWHEAD
a929			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a929			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a929			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a929			; | |  
a929			; | | e.g.    : score $00 scratch ; 
a929			; | |  
a929			; | | $00 score ! 
a929			; | | $01 score +! 
a929			; | |  
a929			; | | e.g.   : varword $0a scratch ;  
a929			; | | 
a929			; | | $8000 varword ! 
a929					if DEBUG_FORTH_WORDS_KEY 
a929						DMARK "SCR" 
a929 f5				push af  
a92a 3a 3e a9			ld a, (.dmark)  
a92d 32 c0 ee			ld (debug_mark),a  
a930 3a 3f a9			ld a, (.dmark+1)  
a933 32 c1 ee			ld (debug_mark+1),a  
a936 3a 40 a9			ld a, (.dmark+2)  
a939 32 c2 ee			ld (debug_mark+2),a  
a93c 18 03			jr .pastdmark  
a93e ..			.dmark: db "SCR"  
a941 f1			.pastdmark: pop af  
a942			endm  
# End of macro DMARK
a942						CALLMONITOR 
a942 cd b0 92			call break_point_state  
a945				endm  
# End of macro CALLMONITOR
a945					endif 
a945			 
a945					FORTH_DSP_VALUEHL 
a945 cd 34 9a			call macro_dsp_valuehl 
a948				endm 
# End of macro FORTH_DSP_VALUEHL
a948				 
a948					FORTH_DSP_POP 
a948 cd ec 9a			call macro_forth_dsp_pop 
a94b				endm 
# End of macro FORTH_DSP_POP
a94b			 
a94b 7d					ld a, l 
a94c 21 0b ea				ld hl, os_var_array 
a94f cd 69 8a				call addatohl 
a952			 
a952 cd 3d 98				call forth_push_numhl 
a955			 
a955				       NEXTW 
a955 c3 a6 9b			jp macro_next 
a958				endm 
# End of macro NEXTW
a958			 
a958			.INC: 
a958				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a958 6f				db WORD_SYS_CORE+91             
a959 ac a9			dw .DEC            
a95b 03				db 2 + 1 
a95c .. 00			db "+!",0              
a95f				endm 
# End of macro CWHEAD
a95f			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a95f					if DEBUG_FORTH_WORDS_KEY 
a95f						DMARK "+s_" 
a95f f5				push af  
a960 3a 74 a9			ld a, (.dmark)  
a963 32 c0 ee			ld (debug_mark),a  
a966 3a 75 a9			ld a, (.dmark+1)  
a969 32 c1 ee			ld (debug_mark+1),a  
a96c 3a 76 a9			ld a, (.dmark+2)  
a96f 32 c2 ee			ld (debug_mark+2),a  
a972 18 03			jr .pastdmark  
a974 ..			.dmark: db "+s_"  
a977 f1			.pastdmark: pop af  
a978			endm  
# End of macro DMARK
a978						CALLMONITOR 
a978 cd b0 92			call break_point_state  
a97b				endm  
# End of macro CALLMONITOR
a97b					endif 
a97b			 
a97b					FORTH_DSP_VALUEHL 
a97b cd 34 9a			call macro_dsp_valuehl 
a97e				endm 
# End of macro FORTH_DSP_VALUEHL
a97e			 
a97e e5					push hl   ; save address 
a97f			 
a97f					FORTH_DSP_POP 
a97f cd ec 9a			call macro_forth_dsp_pop 
a982				endm 
# End of macro FORTH_DSP_POP
a982			 
a982					FORTH_DSP_VALUEHL 
a982 cd 34 9a			call macro_dsp_valuehl 
a985				endm 
# End of macro FORTH_DSP_VALUEHL
a985			 
a985					FORTH_DSP_POP 
a985 cd ec 9a			call macro_forth_dsp_pop 
a988				endm 
# End of macro FORTH_DSP_POP
a988			 
a988					; hl contains value to add to byte at a 
a988				 
a988 eb					ex de, hl 
a989			 
a989 e1					pop hl 
a98a			 
a98a					if DEBUG_FORTH_WORDS 
a98a						DMARK "INC" 
a98a f5				push af  
a98b 3a 9f a9			ld a, (.dmark)  
a98e 32 c0 ee			ld (debug_mark),a  
a991 3a a0 a9			ld a, (.dmark+1)  
a994 32 c1 ee			ld (debug_mark+1),a  
a997 3a a1 a9			ld a, (.dmark+2)  
a99a 32 c2 ee			ld (debug_mark+2),a  
a99d 18 03			jr .pastdmark  
a99f ..			.dmark: db "INC"  
a9a2 f1			.pastdmark: pop af  
a9a3			endm  
# End of macro DMARK
a9a3						CALLMONITOR 
a9a3 cd b0 92			call break_point_state  
a9a6				endm  
# End of macro CALLMONITOR
a9a6					endif 
a9a6			 
a9a6 7e					ld a,(hl) 
a9a7 83					add e 
a9a8 77					ld (hl),a 
a9a9			 
a9a9			 
a9a9			 
a9a9				       NEXTW 
a9a9 c3 a6 9b			jp macro_next 
a9ac				endm 
# End of macro NEXTW
a9ac			 
a9ac			.DEC: 
a9ac				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a9ac 6f				db WORD_SYS_CORE+91             
a9ad fd a9			dw .INC2            
a9af 03				db 2 + 1 
a9b0 .. 00			db "-!",0              
a9b3				endm 
# End of macro CWHEAD
a9b3			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a9b3					if DEBUG_FORTH_WORDS_KEY 
a9b3						DMARK "-s_" 
a9b3 f5				push af  
a9b4 3a c8 a9			ld a, (.dmark)  
a9b7 32 c0 ee			ld (debug_mark),a  
a9ba 3a c9 a9			ld a, (.dmark+1)  
a9bd 32 c1 ee			ld (debug_mark+1),a  
a9c0 3a ca a9			ld a, (.dmark+2)  
a9c3 32 c2 ee			ld (debug_mark+2),a  
a9c6 18 03			jr .pastdmark  
a9c8 ..			.dmark: db "-s_"  
a9cb f1			.pastdmark: pop af  
a9cc			endm  
# End of macro DMARK
a9cc						CALLMONITOR 
a9cc cd b0 92			call break_point_state  
a9cf				endm  
# End of macro CALLMONITOR
a9cf					endif 
a9cf			 
a9cf					FORTH_DSP_VALUEHL 
a9cf cd 34 9a			call macro_dsp_valuehl 
a9d2				endm 
# End of macro FORTH_DSP_VALUEHL
a9d2			 
a9d2 e5					push hl   ; save address 
a9d3			 
a9d3					FORTH_DSP_POP 
a9d3 cd ec 9a			call macro_forth_dsp_pop 
a9d6				endm 
# End of macro FORTH_DSP_POP
a9d6			 
a9d6					FORTH_DSP_VALUEHL 
a9d6 cd 34 9a			call macro_dsp_valuehl 
a9d9				endm 
# End of macro FORTH_DSP_VALUEHL
a9d9			 
a9d9					; hl contains value to add to byte at a 
a9d9				 
a9d9 eb					ex de, hl 
a9da			 
a9da e1					pop hl 
a9db			 
a9db					if DEBUG_FORTH_WORDS 
a9db						DMARK "DEC" 
a9db f5				push af  
a9dc 3a f0 a9			ld a, (.dmark)  
a9df 32 c0 ee			ld (debug_mark),a  
a9e2 3a f1 a9			ld a, (.dmark+1)  
a9e5 32 c1 ee			ld (debug_mark+1),a  
a9e8 3a f2 a9			ld a, (.dmark+2)  
a9eb 32 c2 ee			ld (debug_mark+2),a  
a9ee 18 03			jr .pastdmark  
a9f0 ..			.dmark: db "DEC"  
a9f3 f1			.pastdmark: pop af  
a9f4			endm  
# End of macro DMARK
a9f4						CALLMONITOR 
a9f4 cd b0 92			call break_point_state  
a9f7				endm  
# End of macro CALLMONITOR
a9f7					endif 
a9f7			 
a9f7 7e					ld a,(hl) 
a9f8 93					sub e 
a9f9 77					ld (hl),a 
a9fa			 
a9fa			 
a9fa			 
a9fa				       NEXTW 
a9fa c3 a6 9b			jp macro_next 
a9fd				endm 
# End of macro NEXTW
a9fd			 
a9fd			.INC2: 
a9fd				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a9fd 6f				db WORD_SYS_CORE+91             
a9fe a7 aa			dw .DEC2            
aa00 04				db 3 + 1 
aa01 .. 00			db "+2!",0              
aa05				endm 
# End of macro CWHEAD
aa05			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
aa05			 
aa05					if DEBUG_FORTH_WORDS_KEY 
aa05						DMARK "+2s" 
aa05 f5				push af  
aa06 3a 1a aa			ld a, (.dmark)  
aa09 32 c0 ee			ld (debug_mark),a  
aa0c 3a 1b aa			ld a, (.dmark+1)  
aa0f 32 c1 ee			ld (debug_mark+1),a  
aa12 3a 1c aa			ld a, (.dmark+2)  
aa15 32 c2 ee			ld (debug_mark+2),a  
aa18 18 03			jr .pastdmark  
aa1a ..			.dmark: db "+2s"  
aa1d f1			.pastdmark: pop af  
aa1e			endm  
# End of macro DMARK
aa1e						CALLMONITOR 
aa1e cd b0 92			call break_point_state  
aa21				endm  
# End of macro CALLMONITOR
aa21					endif 
aa21			 
aa21					; Address 
aa21			 
aa21					FORTH_DSP_VALUEHL 
aa21 cd 34 9a			call macro_dsp_valuehl 
aa24				endm 
# End of macro FORTH_DSP_VALUEHL
aa24			 
aa24 e5					push hl    ; save address 
aa25			 
aa25					; load content into de 
aa25			 
aa25 5e					ld e,(hl) 
aa26 23					inc hl 
aa27 56					ld d, (hl) 
aa28			 
aa28					if DEBUG_FORTH_WORDS 
aa28						DMARK "+2a" 
aa28 f5				push af  
aa29 3a 3d aa			ld a, (.dmark)  
aa2c 32 c0 ee			ld (debug_mark),a  
aa2f 3a 3e aa			ld a, (.dmark+1)  
aa32 32 c1 ee			ld (debug_mark+1),a  
aa35 3a 3f aa			ld a, (.dmark+2)  
aa38 32 c2 ee			ld (debug_mark+2),a  
aa3b 18 03			jr .pastdmark  
aa3d ..			.dmark: db "+2a"  
aa40 f1			.pastdmark: pop af  
aa41			endm  
# End of macro DMARK
aa41						CALLMONITOR 
aa41 cd b0 92			call break_point_state  
aa44				endm  
# End of macro CALLMONITOR
aa44					endif 
aa44			 
aa44					FORTH_DSP_POP 
aa44 cd ec 9a			call macro_forth_dsp_pop 
aa47				endm 
# End of macro FORTH_DSP_POP
aa47			 
aa47					; Get value to add 
aa47			 
aa47					FORTH_DSP_VALUE 
aa47 cd 1d 9a			call macro_forth_dsp_value 
aa4a				endm 
# End of macro FORTH_DSP_VALUE
aa4a			 
aa4a					if DEBUG_FORTH_WORDS 
aa4a						DMARK "+2v" 
aa4a f5				push af  
aa4b 3a 5f aa			ld a, (.dmark)  
aa4e 32 c0 ee			ld (debug_mark),a  
aa51 3a 60 aa			ld a, (.dmark+1)  
aa54 32 c1 ee			ld (debug_mark+1),a  
aa57 3a 61 aa			ld a, (.dmark+2)  
aa5a 32 c2 ee			ld (debug_mark+2),a  
aa5d 18 03			jr .pastdmark  
aa5f ..			.dmark: db "+2v"  
aa62 f1			.pastdmark: pop af  
aa63			endm  
# End of macro DMARK
aa63						CALLMONITOR 
aa63 cd b0 92			call break_point_state  
aa66				endm  
# End of macro CALLMONITOR
aa66					endif 
aa66			 
aa66 19					add hl, de 
aa67			 
aa67					if DEBUG_FORTH_WORDS 
aa67						DMARK "+2+" 
aa67 f5				push af  
aa68 3a 7c aa			ld a, (.dmark)  
aa6b 32 c0 ee			ld (debug_mark),a  
aa6e 3a 7d aa			ld a, (.dmark+1)  
aa71 32 c1 ee			ld (debug_mark+1),a  
aa74 3a 7e aa			ld a, (.dmark+2)  
aa77 32 c2 ee			ld (debug_mark+2),a  
aa7a 18 03			jr .pastdmark  
aa7c ..			.dmark: db "+2+"  
aa7f f1			.pastdmark: pop af  
aa80			endm  
# End of macro DMARK
aa80						CALLMONITOR 
aa80 cd b0 92			call break_point_state  
aa83				endm  
# End of macro CALLMONITOR
aa83					endif 
aa83			 
aa83					; move result to de 
aa83			 
aa83 eb					ex de, hl 
aa84			 
aa84					; Address 
aa84			 
aa84 e1					pop hl 
aa85			 
aa85					; save it back 
aa85			 
aa85 73					ld (hl), e 
aa86 23					inc hl 
aa87 72					ld (hl), d 
aa88			 
aa88					if DEBUG_FORTH_WORDS 
aa88						DMARK "+2e" 
aa88 f5				push af  
aa89 3a 9d aa			ld a, (.dmark)  
aa8c 32 c0 ee			ld (debug_mark),a  
aa8f 3a 9e aa			ld a, (.dmark+1)  
aa92 32 c1 ee			ld (debug_mark+1),a  
aa95 3a 9f aa			ld a, (.dmark+2)  
aa98 32 c2 ee			ld (debug_mark+2),a  
aa9b 18 03			jr .pastdmark  
aa9d ..			.dmark: db "+2e"  
aaa0 f1			.pastdmark: pop af  
aaa1			endm  
# End of macro DMARK
aaa1						CALLMONITOR 
aaa1 cd b0 92			call break_point_state  
aaa4				endm  
# End of macro CALLMONITOR
aaa4					endif 
aaa4			 
aaa4			 
aaa4			 
aaa4			 
aaa4			 
aaa4				       NEXTW 
aaa4 c3 a6 9b			jp macro_next 
aaa7				endm 
# End of macro NEXTW
aaa7			 
aaa7			.DEC2: 
aaa7				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aaa7 6f				db WORD_SYS_CORE+91             
aaa8 53 ab			dw .GET2            
aaaa 04				db 3 + 1 
aaab .. 00			db "-2!",0              
aaaf				endm 
# End of macro CWHEAD
aaaf			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
aaaf			 
aaaf			 
aaaf					if DEBUG_FORTH_WORDS_KEY 
aaaf						DMARK "-2s" 
aaaf f5				push af  
aab0 3a c4 aa			ld a, (.dmark)  
aab3 32 c0 ee			ld (debug_mark),a  
aab6 3a c5 aa			ld a, (.dmark+1)  
aab9 32 c1 ee			ld (debug_mark+1),a  
aabc 3a c6 aa			ld a, (.dmark+2)  
aabf 32 c2 ee			ld (debug_mark+2),a  
aac2 18 03			jr .pastdmark  
aac4 ..			.dmark: db "-2s"  
aac7 f1			.pastdmark: pop af  
aac8			endm  
# End of macro DMARK
aac8						CALLMONITOR 
aac8 cd b0 92			call break_point_state  
aacb				endm  
# End of macro CALLMONITOR
aacb					endif 
aacb			 
aacb					; Address 
aacb			 
aacb					FORTH_DSP_VALUEHL 
aacb cd 34 9a			call macro_dsp_valuehl 
aace				endm 
# End of macro FORTH_DSP_VALUEHL
aace			 
aace e5					push hl    ; save address 
aacf			 
aacf					; load content into de 
aacf			 
aacf 5e					ld e,(hl) 
aad0 23					inc hl 
aad1 56					ld d, (hl) 
aad2			 
aad2					if DEBUG_FORTH_WORDS 
aad2						DMARK "-2a" 
aad2 f5				push af  
aad3 3a e7 aa			ld a, (.dmark)  
aad6 32 c0 ee			ld (debug_mark),a  
aad9 3a e8 aa			ld a, (.dmark+1)  
aadc 32 c1 ee			ld (debug_mark+1),a  
aadf 3a e9 aa			ld a, (.dmark+2)  
aae2 32 c2 ee			ld (debug_mark+2),a  
aae5 18 03			jr .pastdmark  
aae7 ..			.dmark: db "-2a"  
aaea f1			.pastdmark: pop af  
aaeb			endm  
# End of macro DMARK
aaeb						CALLMONITOR 
aaeb cd b0 92			call break_point_state  
aaee				endm  
# End of macro CALLMONITOR
aaee					endif 
aaee			 
aaee					FORTH_DSP_POP 
aaee cd ec 9a			call macro_forth_dsp_pop 
aaf1				endm 
# End of macro FORTH_DSP_POP
aaf1			 
aaf1					; Get value to remove 
aaf1			 
aaf1					FORTH_DSP_VALUE 
aaf1 cd 1d 9a			call macro_forth_dsp_value 
aaf4				endm 
# End of macro FORTH_DSP_VALUE
aaf4			 
aaf4					if DEBUG_FORTH_WORDS 
aaf4						DMARK "-2v" 
aaf4 f5				push af  
aaf5 3a 09 ab			ld a, (.dmark)  
aaf8 32 c0 ee			ld (debug_mark),a  
aafb 3a 0a ab			ld a, (.dmark+1)  
aafe 32 c1 ee			ld (debug_mark+1),a  
ab01 3a 0b ab			ld a, (.dmark+2)  
ab04 32 c2 ee			ld (debug_mark+2),a  
ab07 18 03			jr .pastdmark  
ab09 ..			.dmark: db "-2v"  
ab0c f1			.pastdmark: pop af  
ab0d			endm  
# End of macro DMARK
ab0d						CALLMONITOR 
ab0d cd b0 92			call break_point_state  
ab10				endm  
# End of macro CALLMONITOR
ab10					endif 
ab10			 
ab10 eb					ex de, hl 
ab11 ed 52				sbc hl, de 
ab13			 
ab13					if DEBUG_FORTH_WORDS 
ab13						DMARK "-2d" 
ab13 f5				push af  
ab14 3a 28 ab			ld a, (.dmark)  
ab17 32 c0 ee			ld (debug_mark),a  
ab1a 3a 29 ab			ld a, (.dmark+1)  
ab1d 32 c1 ee			ld (debug_mark+1),a  
ab20 3a 2a ab			ld a, (.dmark+2)  
ab23 32 c2 ee			ld (debug_mark+2),a  
ab26 18 03			jr .pastdmark  
ab28 ..			.dmark: db "-2d"  
ab2b f1			.pastdmark: pop af  
ab2c			endm  
# End of macro DMARK
ab2c						CALLMONITOR 
ab2c cd b0 92			call break_point_state  
ab2f				endm  
# End of macro CALLMONITOR
ab2f					endif 
ab2f			 
ab2f					; move result to de 
ab2f			 
ab2f eb					ex de, hl 
ab30			 
ab30					; Address 
ab30			 
ab30 e1					pop hl 
ab31			 
ab31					; save it back 
ab31			 
ab31 73					ld (hl), e 
ab32 23					inc hl 
ab33 72					ld (hl), d 
ab34			 
ab34					if DEBUG_FORTH_WORDS 
ab34						DMARK "-2e" 
ab34 f5				push af  
ab35 3a 49 ab			ld a, (.dmark)  
ab38 32 c0 ee			ld (debug_mark),a  
ab3b 3a 4a ab			ld a, (.dmark+1)  
ab3e 32 c1 ee			ld (debug_mark+1),a  
ab41 3a 4b ab			ld a, (.dmark+2)  
ab44 32 c2 ee			ld (debug_mark+2),a  
ab47 18 03			jr .pastdmark  
ab49 ..			.dmark: db "-2e"  
ab4c f1			.pastdmark: pop af  
ab4d			endm  
# End of macro DMARK
ab4d						CALLMONITOR 
ab4d cd b0 92			call break_point_state  
ab50				endm  
# End of macro CALLMONITOR
ab50					endif 
ab50			 
ab50			 
ab50			 
ab50			 
ab50			 
ab50				       NEXTW 
ab50 c3 a6 9b			jp macro_next 
ab53				endm 
# End of macro NEXTW
ab53			.GET2: 
ab53				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ab53 6f				db WORD_SYS_CORE+91             
ab54 83 ab			dw .BANG2            
ab56 03				db 2 + 1 
ab57 .. 00			db "2@",0              
ab5a				endm 
# End of macro CWHEAD
ab5a			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ab5a					if DEBUG_FORTH_WORDS_KEY 
ab5a						DMARK "2A_" 
ab5a f5				push af  
ab5b 3a 6f ab			ld a, (.dmark)  
ab5e 32 c0 ee			ld (debug_mark),a  
ab61 3a 70 ab			ld a, (.dmark+1)  
ab64 32 c1 ee			ld (debug_mark+1),a  
ab67 3a 71 ab			ld a, (.dmark+2)  
ab6a 32 c2 ee			ld (debug_mark+2),a  
ab6d 18 03			jr .pastdmark  
ab6f ..			.dmark: db "2A_"  
ab72 f1			.pastdmark: pop af  
ab73			endm  
# End of macro DMARK
ab73						CALLMONITOR 
ab73 cd b0 92			call break_point_state  
ab76				endm  
# End of macro CALLMONITOR
ab76					endif 
ab76			 
ab76					FORTH_DSP_VALUEHL 
ab76 cd 34 9a			call macro_dsp_valuehl 
ab79				endm 
# End of macro FORTH_DSP_VALUEHL
ab79			 
ab79 5e					ld e, (hl) 
ab7a 23					inc hl 
ab7b 56					ld d, (hl) 
ab7c			 
ab7c eb					ex de, hl 
ab7d			 
ab7d cd 3d 98				call forth_push_numhl 
ab80			 
ab80				       NEXTW 
ab80 c3 a6 9b			jp macro_next 
ab83				endm 
# End of macro NEXTW
ab83			.BANG2: 
ab83				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ab83 6f				db WORD_SYS_CORE+91             
ab84 bb ab			dw .CONFIG            
ab86 03				db 2 + 1 
ab87 .. 00			db "2!",0              
ab8a				endm 
# End of macro CWHEAD
ab8a			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ab8a					if DEBUG_FORTH_WORDS_KEY 
ab8a						DMARK "2S_" 
ab8a f5				push af  
ab8b 3a 9f ab			ld a, (.dmark)  
ab8e 32 c0 ee			ld (debug_mark),a  
ab91 3a a0 ab			ld a, (.dmark+1)  
ab94 32 c1 ee			ld (debug_mark+1),a  
ab97 3a a1 ab			ld a, (.dmark+2)  
ab9a 32 c2 ee			ld (debug_mark+2),a  
ab9d 18 03			jr .pastdmark  
ab9f ..			.dmark: db "2S_"  
aba2 f1			.pastdmark: pop af  
aba3			endm  
# End of macro DMARK
aba3						CALLMONITOR 
aba3 cd b0 92			call break_point_state  
aba6				endm  
# End of macro CALLMONITOR
aba6					endif 
aba6			 
aba6					FORTH_DSP_VALUEHL 
aba6 cd 34 9a			call macro_dsp_valuehl 
aba9				endm 
# End of macro FORTH_DSP_VALUEHL
aba9			 
aba9 e5					push hl   ; save address 
abaa			 
abaa			 
abaa					FORTH_DSP_POP 
abaa cd ec 9a			call macro_forth_dsp_pop 
abad				endm 
# End of macro FORTH_DSP_POP
abad			 
abad					 
abad					FORTH_DSP_VALUEHL 
abad cd 34 9a			call macro_dsp_valuehl 
abb0				endm 
# End of macro FORTH_DSP_VALUEHL
abb0			 
abb0					FORTH_DSP_POP 
abb0 cd ec 9a			call macro_forth_dsp_pop 
abb3				endm 
# End of macro FORTH_DSP_POP
abb3			 
abb3 eb					ex de, hl    ; value now in de 
abb4			 
abb4 e1					pop hl 
abb5			 
abb5 73					ld (hl), e 
abb6			 
abb6 23					inc hl 
abb7			 
abb7 72					ld (hl), d 
abb8			 
abb8			 
abb8				       NEXTW 
abb8 c3 a6 9b			jp macro_next 
abbb				endm 
# End of macro NEXTW
abbb			.CONFIG: 
abbb				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
abbb 6f				db WORD_SYS_CORE+91             
abbc cc ab			dw .ENDCORE            
abbe 07				db 6 + 1 
abbf .. 00			db "CONFIG",0              
abc6				endm 
# End of macro CWHEAD
abc6			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
abc6			 
abc6 cd c9 90				call config 
abc9					NEXTW 
abc9 c3 a6 9b			jp macro_next 
abcc				endm 
# End of macro NEXTW
abcc			.ENDCORE: 
abcc			 
abcc			; eof 
abcc			 
abcc			 
# End of file forth_words_core.asm
abcc			include "forth_words_flow.asm" 
abcc			 
abcc			; | ## Program Flow Words 
abcc			 
abcc			.IF: 
abcc				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
abcc 1e				db WORD_SYS_CORE+10             
abcd c1 ac			dw .THEN            
abcf 03				db 2 + 1 
abd0 .. 00			db "IF",0              
abd3				endm 
# End of macro CWHEAD
abd3			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
abd3			; 
abd3					if DEBUG_FORTH_WORDS_KEY 
abd3						DMARK "IF." 
abd3 f5				push af  
abd4 3a e8 ab			ld a, (.dmark)  
abd7 32 c0 ee			ld (debug_mark),a  
abda 3a e9 ab			ld a, (.dmark+1)  
abdd 32 c1 ee			ld (debug_mark+1),a  
abe0 3a ea ab			ld a, (.dmark+2)  
abe3 32 c2 ee			ld (debug_mark+2),a  
abe6 18 03			jr .pastdmark  
abe8 ..			.dmark: db "IF."  
abeb f1			.pastdmark: pop af  
abec			endm  
# End of macro DMARK
abec						CALLMONITOR 
abec cd b0 92			call break_point_state  
abef				endm  
# End of macro CALLMONITOR
abef					endif 
abef			; eval TOS 
abef			 
abef				FORTH_DSP_VALUEHL 
abef cd 34 9a			call macro_dsp_valuehl 
abf2				endm 
# End of macro FORTH_DSP_VALUEHL
abf2			 
abf2			;	push hl 
abf2				FORTH_DSP_POP 
abf2 cd ec 9a			call macro_forth_dsp_pop 
abf5				endm 
# End of macro FORTH_DSP_POP
abf5			;	pop hl 
abf5			 
abf5					if DEBUG_FORTH_WORDS 
abf5						DMARK "IF1" 
abf5 f5				push af  
abf6 3a 0a ac			ld a, (.dmark)  
abf9 32 c0 ee			ld (debug_mark),a  
abfc 3a 0b ac			ld a, (.dmark+1)  
abff 32 c1 ee			ld (debug_mark+1),a  
ac02 3a 0c ac			ld a, (.dmark+2)  
ac05 32 c2 ee			ld (debug_mark+2),a  
ac08 18 03			jr .pastdmark  
ac0a ..			.dmark: db "IF1"  
ac0d f1			.pastdmark: pop af  
ac0e			endm  
# End of macro DMARK
ac0e						CALLMONITOR 
ac0e cd b0 92			call break_point_state  
ac11				endm  
# End of macro CALLMONITOR
ac11					endif 
ac11 b7				or a        ; clear carry flag 
ac12 11 00 00			ld de, 0 
ac15 eb				ex de,hl 
ac16 ed 52			sbc hl, de 
ac18 c2 a2 ac			jp nz, .iftrue 
ac1b			 
ac1b					if DEBUG_FORTH_WORDS 
ac1b						DMARK "IF2" 
ac1b f5				push af  
ac1c 3a 30 ac			ld a, (.dmark)  
ac1f 32 c0 ee			ld (debug_mark),a  
ac22 3a 31 ac			ld a, (.dmark+1)  
ac25 32 c1 ee			ld (debug_mark+1),a  
ac28 3a 32 ac			ld a, (.dmark+2)  
ac2b 32 c2 ee			ld (debug_mark+2),a  
ac2e 18 03			jr .pastdmark  
ac30 ..			.dmark: db "IF2"  
ac33 f1			.pastdmark: pop af  
ac34			endm  
# End of macro DMARK
ac34						CALLMONITOR 
ac34 cd b0 92			call break_point_state  
ac37				endm  
# End of macro CALLMONITOR
ac37					endif 
ac37			 
ac37			; if not true then skip to THEN 
ac37			 
ac37				; TODO get tok_ptr 
ac37				; TODO consume toks until we get to THEN 
ac37			 
ac37 2a e7 e7			ld hl, (os_tok_ptr) 
ac3a					if DEBUG_FORTH_WORDS 
ac3a						DMARK "IF3" 
ac3a f5				push af  
ac3b 3a 4f ac			ld a, (.dmark)  
ac3e 32 c0 ee			ld (debug_mark),a  
ac41 3a 50 ac			ld a, (.dmark+1)  
ac44 32 c1 ee			ld (debug_mark+1),a  
ac47 3a 51 ac			ld a, (.dmark+2)  
ac4a 32 c2 ee			ld (debug_mark+2),a  
ac4d 18 03			jr .pastdmark  
ac4f ..			.dmark: db "IF3"  
ac52 f1			.pastdmark: pop af  
ac53			endm  
# End of macro DMARK
ac53						CALLMONITOR 
ac53 cd b0 92			call break_point_state  
ac56				endm  
# End of macro CALLMONITOR
ac56						 
ac56					endif 
ac56 11 9d ac			ld de, .ifthen 
ac59					if DEBUG_FORTH_WORDS 
ac59						DMARK "IF4" 
ac59 f5				push af  
ac5a 3a 6e ac			ld a, (.dmark)  
ac5d 32 c0 ee			ld (debug_mark),a  
ac60 3a 6f ac			ld a, (.dmark+1)  
ac63 32 c1 ee			ld (debug_mark+1),a  
ac66 3a 70 ac			ld a, (.dmark+2)  
ac69 32 c2 ee			ld (debug_mark+2),a  
ac6c 18 03			jr .pastdmark  
ac6e ..			.dmark: db "IF4"  
ac71 f1			.pastdmark: pop af  
ac72			endm  
# End of macro DMARK
ac72						CALLMONITOR 
ac72 cd b0 92			call break_point_state  
ac75				endm  
# End of macro CALLMONITOR
ac75					endif 
ac75 cd c1 9c			call findnexttok  
ac78			 
ac78					if DEBUG_FORTH_WORDS 
ac78						DMARK "IF5" 
ac78 f5				push af  
ac79 3a 8d ac			ld a, (.dmark)  
ac7c 32 c0 ee			ld (debug_mark),a  
ac7f 3a 8e ac			ld a, (.dmark+1)  
ac82 32 c1 ee			ld (debug_mark+1),a  
ac85 3a 8f ac			ld a, (.dmark+2)  
ac88 32 c2 ee			ld (debug_mark+2),a  
ac8b 18 03			jr .pastdmark  
ac8d ..			.dmark: db "IF5"  
ac90 f1			.pastdmark: pop af  
ac91			endm  
# End of macro DMARK
ac91						CALLMONITOR 
ac91 cd b0 92			call break_point_state  
ac94				endm  
# End of macro CALLMONITOR
ac94					endif 
ac94				; TODO replace below with ; exec using tok_ptr 
ac94 22 e7 e7			ld (os_tok_ptr), hl 
ac97 c3 37 9c			jp exec1 
ac9a				NEXTW 
ac9a c3 a6 9b			jp macro_next 
ac9d				endm 
# End of macro NEXTW
ac9d			 
ac9d .. 00		.ifthen:  db "THEN",0 
aca2			 
aca2			.iftrue:		 
aca2				; Exec next words normally 
aca2			 
aca2				; if true then exec following IF as normal 
aca2					if DEBUG_FORTH_WORDS 
aca2						DMARK "IFT" 
aca2 f5				push af  
aca3 3a b7 ac			ld a, (.dmark)  
aca6 32 c0 ee			ld (debug_mark),a  
aca9 3a b8 ac			ld a, (.dmark+1)  
acac 32 c1 ee			ld (debug_mark+1),a  
acaf 3a b9 ac			ld a, (.dmark+2)  
acb2 32 c2 ee			ld (debug_mark+2),a  
acb5 18 03			jr .pastdmark  
acb7 ..			.dmark: db "IFT"  
acba f1			.pastdmark: pop af  
acbb			endm  
# End of macro DMARK
acbb						CALLMONITOR 
acbb cd b0 92			call break_point_state  
acbe				endm  
# End of macro CALLMONITOR
acbe					endif 
acbe			 
acbe					NEXTW 
acbe c3 a6 9b			jp macro_next 
acc1				endm 
# End of macro NEXTW
acc1			.THEN: 
acc1				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
acc1 1f				db WORD_SYS_CORE+11             
acc2 e9 ac			dw .ELSE            
acc4 05				db 4 + 1 
acc5 .. 00			db "THEN",0              
acca				endm 
# End of macro CWHEAD
acca			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
acca					if DEBUG_FORTH_WORDS_KEY 
acca						DMARK "THN" 
acca f5				push af  
accb 3a df ac			ld a, (.dmark)  
acce 32 c0 ee			ld (debug_mark),a  
acd1 3a e0 ac			ld a, (.dmark+1)  
acd4 32 c1 ee			ld (debug_mark+1),a  
acd7 3a e1 ac			ld a, (.dmark+2)  
acda 32 c2 ee			ld (debug_mark+2),a  
acdd 18 03			jr .pastdmark  
acdf ..			.dmark: db "THN"  
ace2 f1			.pastdmark: pop af  
ace3			endm  
# End of macro DMARK
ace3						CALLMONITOR 
ace3 cd b0 92			call break_point_state  
ace6				endm  
# End of macro CALLMONITOR
ace6					endif 
ace6					NEXTW 
ace6 c3 a6 9b			jp macro_next 
ace9				endm 
# End of macro NEXTW
ace9			.ELSE: 
ace9				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ace9 20				db WORD_SYS_CORE+12             
acea 11 ad			dw .DO            
acec 03				db 2 + 1 
aced .. 00			db "ELSE",0              
acf2				endm 
# End of macro CWHEAD
acf2			; | ELSE ( -- ) Not supported - does nothing | TODO 
acf2			 
acf2					if DEBUG_FORTH_WORDS_KEY 
acf2						DMARK "ELS" 
acf2 f5				push af  
acf3 3a 07 ad			ld a, (.dmark)  
acf6 32 c0 ee			ld (debug_mark),a  
acf9 3a 08 ad			ld a, (.dmark+1)  
acfc 32 c1 ee			ld (debug_mark+1),a  
acff 3a 09 ad			ld a, (.dmark+2)  
ad02 32 c2 ee			ld (debug_mark+2),a  
ad05 18 03			jr .pastdmark  
ad07 ..			.dmark: db "ELS"  
ad0a f1			.pastdmark: pop af  
ad0b			endm  
# End of macro DMARK
ad0b						CALLMONITOR 
ad0b cd b0 92			call break_point_state  
ad0e				endm  
# End of macro CALLMONITOR
ad0e					endif 
ad0e			 
ad0e			 
ad0e					NEXTW 
ad0e c3 a6 9b			jp macro_next 
ad11				endm 
# End of macro NEXTW
ad11			.DO: 
ad11				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ad11 21				db WORD_SYS_CORE+13             
ad12 38 ae			dw .LOOP            
ad14 03				db 2 + 1 
ad15 .. 00			db "DO",0              
ad18				endm 
# End of macro CWHEAD
ad18			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ad18			 
ad18					if DEBUG_FORTH_WORDS_KEY 
ad18						DMARK "DO." 
ad18 f5				push af  
ad19 3a 2d ad			ld a, (.dmark)  
ad1c 32 c0 ee			ld (debug_mark),a  
ad1f 3a 2e ad			ld a, (.dmark+1)  
ad22 32 c1 ee			ld (debug_mark+1),a  
ad25 3a 2f ad			ld a, (.dmark+2)  
ad28 32 c2 ee			ld (debug_mark+2),a  
ad2b 18 03			jr .pastdmark  
ad2d ..			.dmark: db "DO."  
ad30 f1			.pastdmark: pop af  
ad31			endm  
# End of macro DMARK
ad31						CALLMONITOR 
ad31 cd b0 92			call break_point_state  
ad34				endm  
# End of macro CALLMONITOR
ad34					endif 
ad34			;  push pc to rsp stack past the DO 
ad34			 
ad34 2a e7 e7				ld hl, (os_tok_ptr) 
ad37 23					inc hl   ; D 
ad38 23					inc hl  ; O 
ad39 23					inc hl   ; null 
ad3a					if DEBUG_FORTH_WORDS 
ad3a						DMARK "DO2" 
ad3a f5				push af  
ad3b 3a 4f ad			ld a, (.dmark)  
ad3e 32 c0 ee			ld (debug_mark),a  
ad41 3a 50 ad			ld a, (.dmark+1)  
ad44 32 c1 ee			ld (debug_mark+1),a  
ad47 3a 51 ad			ld a, (.dmark+2)  
ad4a 32 c2 ee			ld (debug_mark+2),a  
ad4d 18 03			jr .pastdmark  
ad4f ..			.dmark: db "DO2"  
ad52 f1			.pastdmark: pop af  
ad53			endm  
# End of macro DMARK
ad53						CALLMONITOR 
ad53 cd b0 92			call break_point_state  
ad56				endm  
# End of macro CALLMONITOR
ad56					endif 
ad56					FORTH_RSP_NEXT 
ad56 cd e4 97			call macro_forth_rsp_next 
ad59				endm 
# End of macro FORTH_RSP_NEXT
ad59					if DEBUG_FORTH_WORDS 
ad59						DMARK "DO3" 
ad59 f5				push af  
ad5a 3a 6e ad			ld a, (.dmark)  
ad5d 32 c0 ee			ld (debug_mark),a  
ad60 3a 6f ad			ld a, (.dmark+1)  
ad63 32 c1 ee			ld (debug_mark+1),a  
ad66 3a 70 ad			ld a, (.dmark+2)  
ad69 32 c2 ee			ld (debug_mark+2),a  
ad6c 18 03			jr .pastdmark  
ad6e ..			.dmark: db "DO3"  
ad71 f1			.pastdmark: pop af  
ad72			endm  
# End of macro DMARK
ad72						CALLMONITOR 
ad72 cd b0 92			call break_point_state  
ad75				endm  
# End of macro CALLMONITOR
ad75					endif 
ad75			 
ad75					;if DEBUG_FORTH_WORDS 
ad75				;		push hl 
ad75			;		endif  
ad75			 
ad75			; get counters from data stack 
ad75			 
ad75			 
ad75					FORTH_DSP_VALUEHL 
ad75 cd 34 9a			call macro_dsp_valuehl 
ad78				endm 
# End of macro FORTH_DSP_VALUEHL
ad78 e5					push hl		 ; hl now has starting counter which needs to be tos 
ad79			 
ad79					if DEBUG_FORTH_WORDS 
ad79						DMARK "DO4" 
ad79 f5				push af  
ad7a 3a 8e ad			ld a, (.dmark)  
ad7d 32 c0 ee			ld (debug_mark),a  
ad80 3a 8f ad			ld a, (.dmark+1)  
ad83 32 c1 ee			ld (debug_mark+1),a  
ad86 3a 90 ad			ld a, (.dmark+2)  
ad89 32 c2 ee			ld (debug_mark+2),a  
ad8c 18 03			jr .pastdmark  
ad8e ..			.dmark: db "DO4"  
ad91 f1			.pastdmark: pop af  
ad92			endm  
# End of macro DMARK
ad92						CALLMONITOR 
ad92 cd b0 92			call break_point_state  
ad95				endm  
# End of macro CALLMONITOR
ad95					endif 
ad95					FORTH_DSP_POP 
ad95 cd ec 9a			call macro_forth_dsp_pop 
ad98				endm 
# End of macro FORTH_DSP_POP
ad98			 
ad98					if DEBUG_FORTH_WORDS 
ad98						DMARK "DO5" 
ad98 f5				push af  
ad99 3a ad ad			ld a, (.dmark)  
ad9c 32 c0 ee			ld (debug_mark),a  
ad9f 3a ae ad			ld a, (.dmark+1)  
ada2 32 c1 ee			ld (debug_mark+1),a  
ada5 3a af ad			ld a, (.dmark+2)  
ada8 32 c2 ee			ld (debug_mark+2),a  
adab 18 03			jr .pastdmark  
adad ..			.dmark: db "DO5"  
adb0 f1			.pastdmark: pop af  
adb1			endm  
# End of macro DMARK
adb1						CALLMONITOR 
adb1 cd b0 92			call break_point_state  
adb4				endm  
# End of macro CALLMONITOR
adb4					endif 
adb4			 
adb4					FORTH_DSP_VALUEHL 
adb4 cd 34 9a			call macro_dsp_valuehl 
adb7				endm 
# End of macro FORTH_DSP_VALUEHL
adb7			;		push hl		 ; hl now has starting limit counter 
adb7			 
adb7					if DEBUG_FORTH_WORDS 
adb7						DMARK "DO6" 
adb7 f5				push af  
adb8 3a cc ad			ld a, (.dmark)  
adbb 32 c0 ee			ld (debug_mark),a  
adbe 3a cd ad			ld a, (.dmark+1)  
adc1 32 c1 ee			ld (debug_mark+1),a  
adc4 3a ce ad			ld a, (.dmark+2)  
adc7 32 c2 ee			ld (debug_mark+2),a  
adca 18 03			jr .pastdmark  
adcc ..			.dmark: db "DO6"  
adcf f1			.pastdmark: pop af  
add0			endm  
# End of macro DMARK
add0						CALLMONITOR 
add0 cd b0 92			call break_point_state  
add3				endm  
# End of macro CALLMONITOR
add3					endif 
add3					FORTH_DSP_POP 
add3 cd ec 9a			call macro_forth_dsp_pop 
add6				endm 
# End of macro FORTH_DSP_POP
add6			 
add6			; put counters on the loop stack 
add6			 
add6			;		pop hl			 ; limit counter 
add6 d1					pop de			; start counter 
add7			 
add7					; push limit counter 
add7			 
add7					if DEBUG_FORTH_WORDS 
add7						DMARK "DO7" 
add7 f5				push af  
add8 3a ec ad			ld a, (.dmark)  
addb 32 c0 ee			ld (debug_mark),a  
adde 3a ed ad			ld a, (.dmark+1)  
ade1 32 c1 ee			ld (debug_mark+1),a  
ade4 3a ee ad			ld a, (.dmark+2)  
ade7 32 c2 ee			ld (debug_mark+2),a  
adea 18 03			jr .pastdmark  
adec ..			.dmark: db "DO7"  
adef f1			.pastdmark: pop af  
adf0			endm  
# End of macro DMARK
adf0						CALLMONITOR 
adf0 cd b0 92			call break_point_state  
adf3				endm  
# End of macro CALLMONITOR
adf3					endif 
adf3					FORTH_LOOP_NEXT 
adf3 cd 65 9a			call macro_forth_loop_next 
adf6				endm 
# End of macro FORTH_LOOP_NEXT
adf6			 
adf6					; push start counter 
adf6			 
adf6 eb					ex de, hl 
adf7					if DEBUG_FORTH_WORDS 
adf7						DMARK "DO7" 
adf7 f5				push af  
adf8 3a 0c ae			ld a, (.dmark)  
adfb 32 c0 ee			ld (debug_mark),a  
adfe 3a 0d ae			ld a, (.dmark+1)  
ae01 32 c1 ee			ld (debug_mark+1),a  
ae04 3a 0e ae			ld a, (.dmark+2)  
ae07 32 c2 ee			ld (debug_mark+2),a  
ae0a 18 03			jr .pastdmark  
ae0c ..			.dmark: db "DO7"  
ae0f f1			.pastdmark: pop af  
ae10			endm  
# End of macro DMARK
ae10						CALLMONITOR 
ae10 cd b0 92			call break_point_state  
ae13				endm  
# End of macro CALLMONITOR
ae13					endif 
ae13					FORTH_LOOP_NEXT 
ae13 cd 65 9a			call macro_forth_loop_next 
ae16				endm 
# End of macro FORTH_LOOP_NEXT
ae16			 
ae16			 
ae16					; init first round of I counter 
ae16			 
ae16 22 0b e8				ld (os_current_i), hl 
ae19			 
ae19					if DEBUG_FORTH_WORDS 
ae19						DMARK "DO8" 
ae19 f5				push af  
ae1a 3a 2e ae			ld a, (.dmark)  
ae1d 32 c0 ee			ld (debug_mark),a  
ae20 3a 2f ae			ld a, (.dmark+1)  
ae23 32 c1 ee			ld (debug_mark+1),a  
ae26 3a 30 ae			ld a, (.dmark+2)  
ae29 32 c2 ee			ld (debug_mark+2),a  
ae2c 18 03			jr .pastdmark  
ae2e ..			.dmark: db "DO8"  
ae31 f1			.pastdmark: pop af  
ae32			endm  
# End of macro DMARK
ae32						CALLMONITOR 
ae32 cd b0 92			call break_point_state  
ae35				endm  
# End of macro CALLMONITOR
ae35					endif 
ae35			 
ae35					NEXTW 
ae35 c3 a6 9b			jp macro_next 
ae38				endm 
# End of macro NEXTW
ae38			.LOOP: 
ae38				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ae38 22				db WORD_SYS_CORE+14             
ae39 50 af			dw .I            
ae3b 05				db 4 + 1 
ae3c .. 00			db "LOOP",0              
ae41				endm 
# End of macro CWHEAD
ae41			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ae41			 
ae41				; pop tos as current loop count to hl 
ae41			 
ae41				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ae41			 
ae41				FORTH_LOOP_TOS 
ae41 cd 98 9a			call macro_forth_loop_tos 
ae44				endm 
# End of macro FORTH_LOOP_TOS
ae44 e5				push hl 
ae45			 
ae45					if DEBUG_FORTH_WORDS_KEY 
ae45						DMARK "LOP" 
ae45 f5				push af  
ae46 3a 5a ae			ld a, (.dmark)  
ae49 32 c0 ee			ld (debug_mark),a  
ae4c 3a 5b ae			ld a, (.dmark+1)  
ae4f 32 c1 ee			ld (debug_mark+1),a  
ae52 3a 5c ae			ld a, (.dmark+2)  
ae55 32 c2 ee			ld (debug_mark+2),a  
ae58 18 03			jr .pastdmark  
ae5a ..			.dmark: db "LOP"  
ae5d f1			.pastdmark: pop af  
ae5e			endm  
# End of macro DMARK
ae5e						CALLMONITOR 
ae5e cd b0 92			call break_point_state  
ae61				endm  
# End of macro CALLMONITOR
ae61					endif 
ae61				; next item on the stack is the limit. get it 
ae61			 
ae61			 
ae61				FORTH_LOOP_POP 
ae61 cd a2 9a			call macro_forth_loop_pop 
ae64				endm 
# End of macro FORTH_LOOP_POP
ae64			 
ae64				FORTH_LOOP_TOS 
ae64 cd 98 9a			call macro_forth_loop_tos 
ae67				endm 
# End of macro FORTH_LOOP_TOS
ae67			 
ae67 d1				pop de		 ; de = i, hl = limit 
ae68			 
ae68					if DEBUG_FORTH_WORDS 
ae68						DMARK "LP1" 
ae68 f5				push af  
ae69 3a 7d ae			ld a, (.dmark)  
ae6c 32 c0 ee			ld (debug_mark),a  
ae6f 3a 7e ae			ld a, (.dmark+1)  
ae72 32 c1 ee			ld (debug_mark+1),a  
ae75 3a 7f ae			ld a, (.dmark+2)  
ae78 32 c2 ee			ld (debug_mark+2),a  
ae7b 18 03			jr .pastdmark  
ae7d ..			.dmark: db "LP1"  
ae80 f1			.pastdmark: pop af  
ae81			endm  
# End of macro DMARK
ae81						CALLMONITOR 
ae81 cd b0 92			call break_point_state  
ae84				endm  
# End of macro CALLMONITOR
ae84					endif 
ae84			 
ae84				; go back to previous word 
ae84			 
ae84 d5				push de    ; save I for inc later 
ae85			 
ae85			 
ae85				; get limit 
ae85				;  is I at limit? 
ae85			 
ae85			 
ae85					if DEBUG_FORTH_WORDS 
ae85						DMARK "LP1" 
ae85 f5				push af  
ae86 3a 9a ae			ld a, (.dmark)  
ae89 32 c0 ee			ld (debug_mark),a  
ae8c 3a 9b ae			ld a, (.dmark+1)  
ae8f 32 c1 ee			ld (debug_mark+1),a  
ae92 3a 9c ae			ld a, (.dmark+2)  
ae95 32 c2 ee			ld (debug_mark+2),a  
ae98 18 03			jr .pastdmark  
ae9a ..			.dmark: db "LP1"  
ae9d f1			.pastdmark: pop af  
ae9e			endm  
# End of macro DMARK
ae9e						CALLMONITOR 
ae9e cd b0 92			call break_point_state  
aea1				endm  
# End of macro CALLMONITOR
aea1					endif 
aea1			 
aea1 ed 52			sbc hl, de 
aea3			 
aea3			 
aea3				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
aea3			 
aea3 20 26				jr nz, .loopnotdone 
aea5			 
aea5 e1				pop hl   ; get rid of saved I 
aea6				FORTH_LOOP_POP     ; get rid of limit 
aea6 cd a2 9a			call macro_forth_loop_pop 
aea9				endm 
# End of macro FORTH_LOOP_POP
aea9			 
aea9				FORTH_RSP_POP     ; get rid of DO ptr 
aea9 cd 05 98			call macro_forth_rsp_pop 
aeac				endm 
# End of macro FORTH_RSP_POP
aeac			 
aeac			if DEBUG_FORTH_WORDS 
aeac						DMARK "LP>" 
aeac f5				push af  
aead 3a c1 ae			ld a, (.dmark)  
aeb0 32 c0 ee			ld (debug_mark),a  
aeb3 3a c2 ae			ld a, (.dmark+1)  
aeb6 32 c1 ee			ld (debug_mark+1),a  
aeb9 3a c3 ae			ld a, (.dmark+2)  
aebc 32 c2 ee			ld (debug_mark+2),a  
aebf 18 03			jr .pastdmark  
aec1 ..			.dmark: db "LP>"  
aec4 f1			.pastdmark: pop af  
aec5			endm  
# End of macro DMARK
aec5				CALLMONITOR 
aec5 cd b0 92			call break_point_state  
aec8				endm  
# End of macro CALLMONITOR
aec8			endif 
aec8			 
aec8					NEXTW 
aec8 c3 a6 9b			jp macro_next 
aecb				endm 
# End of macro NEXTW
aecb				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
aecb			 
aecb			.loopnotdone: 
aecb			 
aecb e1				pop hl    ; get I 
aecc 23				inc hl 
aecd			 
aecd			   	; save new I 
aecd			 
aecd			 
aecd					; set I counter 
aecd			 
aecd 22 0b e8				ld (os_current_i), hl 
aed0			 
aed0					if DEBUG_FORTH_WORDS 
aed0						DMARK "LPN" 
aed0 f5				push af  
aed1 3a e5 ae			ld a, (.dmark)  
aed4 32 c0 ee			ld (debug_mark),a  
aed7 3a e6 ae			ld a, (.dmark+1)  
aeda 32 c1 ee			ld (debug_mark+1),a  
aedd 3a e7 ae			ld a, (.dmark+2)  
aee0 32 c2 ee			ld (debug_mark+2),a  
aee3 18 03			jr .pastdmark  
aee5 ..			.dmark: db "LPN"  
aee8 f1			.pastdmark: pop af  
aee9			endm  
# End of macro DMARK
aee9					CALLMONITOR 
aee9 cd b0 92			call break_point_state  
aeec				endm  
# End of macro CALLMONITOR
aeec					endif 
aeec					 
aeec				FORTH_LOOP_NEXT 
aeec cd 65 9a			call macro_forth_loop_next 
aeef				endm 
# End of macro FORTH_LOOP_NEXT
aeef			 
aeef			 
aeef					if DEBUG_FORTH_WORDS 
aeef eb						ex de,hl 
aef0					endif 
aef0			 
aef0			;	; get DO ptr 
aef0			; 
aef0					if DEBUG_FORTH_WORDS 
aef0						DMARK "LP7" 
aef0 f5				push af  
aef1 3a 05 af			ld a, (.dmark)  
aef4 32 c0 ee			ld (debug_mark),a  
aef7 3a 06 af			ld a, (.dmark+1)  
aefa 32 c1 ee			ld (debug_mark+1),a  
aefd 3a 07 af			ld a, (.dmark+2)  
af00 32 c2 ee			ld (debug_mark+2),a  
af03 18 03			jr .pastdmark  
af05 ..			.dmark: db "LP7"  
af08 f1			.pastdmark: pop af  
af09			endm  
# End of macro DMARK
af09					CALLMONITOR 
af09 cd b0 92			call break_point_state  
af0c				endm  
# End of macro CALLMONITOR
af0c					endif 
af0c				FORTH_RSP_TOS 
af0c cd fb 97			call macro_forth_rsp_tos 
af0f				endm 
# End of macro FORTH_RSP_TOS
af0f			 
af0f					if DEBUG_FORTH_WORDS 
af0f						DMARK "LP8" 
af0f f5				push af  
af10 3a 24 af			ld a, (.dmark)  
af13 32 c0 ee			ld (debug_mark),a  
af16 3a 25 af			ld a, (.dmark+1)  
af19 32 c1 ee			ld (debug_mark+1),a  
af1c 3a 26 af			ld a, (.dmark+2)  
af1f 32 c2 ee			ld (debug_mark+2),a  
af22 18 03			jr .pastdmark  
af24 ..			.dmark: db "LP8"  
af27 f1			.pastdmark: pop af  
af28			endm  
# End of macro DMARK
af28					CALLMONITOR 
af28 cd b0 92			call break_point_state  
af2b				endm  
# End of macro CALLMONITOR
af2b					endif 
af2b				;push hl 
af2b			 
af2b				; not going to DO any more 
af2b				; get rid of the RSP pointer as DO will add it back in 
af2b				;FORTH_RSP_POP 
af2b				;pop hl 
af2b			 
af2b				;ld hl,(cli_ret_sp) 
af2b				;ld e, (hl) 
af2b				;inc hl 
af2b				;ld d, (hl) 
af2b				;ex de,hl 
af2b 22 e7 e7			ld (os_tok_ptr), hl 
af2e					if DEBUG_FORTH_WORDS 
af2e						DMARK "LP<" 
af2e f5				push af  
af2f 3a 43 af			ld a, (.dmark)  
af32 32 c0 ee			ld (debug_mark),a  
af35 3a 44 af			ld a, (.dmark+1)  
af38 32 c1 ee			ld (debug_mark+1),a  
af3b 3a 45 af			ld a, (.dmark+2)  
af3e 32 c2 ee			ld (debug_mark+2),a  
af41 18 03			jr .pastdmark  
af43 ..			.dmark: db "LP<"  
af46 f1			.pastdmark: pop af  
af47			endm  
# End of macro DMARK
af47					CALLMONITOR 
af47 cd b0 92			call break_point_state  
af4a				endm  
# End of macro CALLMONITOR
af4a				endif 
af4a c3 37 9c			jp exec1 
af4d			 
af4d					 
af4d			 
af4d			 
af4d					NEXTW 
af4d c3 a6 9b			jp macro_next 
af50				endm 
# End of macro NEXTW
af50			.I:  
af50			 
af50				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
af50 5e				db WORD_SYS_CORE+74             
af51 7b af			dw .DLOOP            
af53 02				db 1 + 1 
af54 .. 00			db "I",0              
af56				endm 
# End of macro CWHEAD
af56			; | I ( -- ) Current loop counter | DONE 
af56					if DEBUG_FORTH_WORDS_KEY 
af56						DMARK "I.." 
af56 f5				push af  
af57 3a 6b af			ld a, (.dmark)  
af5a 32 c0 ee			ld (debug_mark),a  
af5d 3a 6c af			ld a, (.dmark+1)  
af60 32 c1 ee			ld (debug_mark+1),a  
af63 3a 6d af			ld a, (.dmark+2)  
af66 32 c2 ee			ld (debug_mark+2),a  
af69 18 03			jr .pastdmark  
af6b ..			.dmark: db "I.."  
af6e f1			.pastdmark: pop af  
af6f			endm  
# End of macro DMARK
af6f						CALLMONITOR 
af6f cd b0 92			call break_point_state  
af72				endm  
# End of macro CALLMONITOR
af72					endif 
af72			 
af72 2a 0b e8				ld hl,(os_current_i) 
af75 cd 3d 98				call forth_push_numhl 
af78			 
af78					NEXTW 
af78 c3 a6 9b			jp macro_next 
af7b				endm 
# End of macro NEXTW
af7b			.DLOOP: 
af7b				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
af7b 5f				db WORD_SYS_CORE+75             
af7c 5c b0			dw .REPEAT            
af7e 06				db 5 + 1 
af7f .. 00			db "-LOOP",0              
af85				endm 
# End of macro CWHEAD
af85			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
af85				; pop tos as current loop count to hl 
af85					if DEBUG_FORTH_WORDS_KEY 
af85						DMARK "-LP" 
af85 f5				push af  
af86 3a 9a af			ld a, (.dmark)  
af89 32 c0 ee			ld (debug_mark),a  
af8c 3a 9b af			ld a, (.dmark+1)  
af8f 32 c1 ee			ld (debug_mark+1),a  
af92 3a 9c af			ld a, (.dmark+2)  
af95 32 c2 ee			ld (debug_mark+2),a  
af98 18 03			jr .pastdmark  
af9a ..			.dmark: db "-LP"  
af9d f1			.pastdmark: pop af  
af9e			endm  
# End of macro DMARK
af9e						CALLMONITOR 
af9e cd b0 92			call break_point_state  
afa1				endm  
# End of macro CALLMONITOR
afa1					endif 
afa1			 
afa1				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
afa1			 
afa1				FORTH_LOOP_TOS 
afa1 cd 98 9a			call macro_forth_loop_tos 
afa4				endm 
# End of macro FORTH_LOOP_TOS
afa4 e5				push hl 
afa5			 
afa5					if DEBUG_FORTH_WORDS 
afa5						DMARK "-LP" 
afa5 f5				push af  
afa6 3a ba af			ld a, (.dmark)  
afa9 32 c0 ee			ld (debug_mark),a  
afac 3a bb af			ld a, (.dmark+1)  
afaf 32 c1 ee			ld (debug_mark+1),a  
afb2 3a bc af			ld a, (.dmark+2)  
afb5 32 c2 ee			ld (debug_mark+2),a  
afb8 18 03			jr .pastdmark  
afba ..			.dmark: db "-LP"  
afbd f1			.pastdmark: pop af  
afbe			endm  
# End of macro DMARK
afbe						CALLMONITOR 
afbe cd b0 92			call break_point_state  
afc1				endm  
# End of macro CALLMONITOR
afc1					endif 
afc1				; next item on the stack is the limit. get it 
afc1			 
afc1			 
afc1				FORTH_LOOP_POP 
afc1 cd a2 9a			call macro_forth_loop_pop 
afc4				endm 
# End of macro FORTH_LOOP_POP
afc4			 
afc4				FORTH_LOOP_TOS 
afc4 cd 98 9a			call macro_forth_loop_tos 
afc7				endm 
# End of macro FORTH_LOOP_TOS
afc7			 
afc7 d1				pop de		 ; de = i, hl = limit 
afc8			 
afc8					if DEBUG_FORTH_WORDS 
afc8						DMARK "-L1" 
afc8 f5				push af  
afc9 3a dd af			ld a, (.dmark)  
afcc 32 c0 ee			ld (debug_mark),a  
afcf 3a de af			ld a, (.dmark+1)  
afd2 32 c1 ee			ld (debug_mark+1),a  
afd5 3a df af			ld a, (.dmark+2)  
afd8 32 c2 ee			ld (debug_mark+2),a  
afdb 18 03			jr .pastdmark  
afdd ..			.dmark: db "-L1"  
afe0 f1			.pastdmark: pop af  
afe1			endm  
# End of macro DMARK
afe1						CALLMONITOR 
afe1 cd b0 92			call break_point_state  
afe4				endm  
# End of macro CALLMONITOR
afe4					endif 
afe4			 
afe4				; go back to previous word 
afe4			 
afe4 d5				push de    ; save I for inc later 
afe5			 
afe5			 
afe5				; get limit 
afe5				;  is I at limit? 
afe5			 
afe5			 
afe5					if DEBUG_FORTH_WORDS 
afe5						DMARK "-L1" 
afe5 f5				push af  
afe6 3a fa af			ld a, (.dmark)  
afe9 32 c0 ee			ld (debug_mark),a  
afec 3a fb af			ld a, (.dmark+1)  
afef 32 c1 ee			ld (debug_mark+1),a  
aff2 3a fc af			ld a, (.dmark+2)  
aff5 32 c2 ee			ld (debug_mark+2),a  
aff8 18 03			jr .pastdmark  
affa ..			.dmark: db "-L1"  
affd f1			.pastdmark: pop af  
affe			endm  
# End of macro DMARK
affe						CALLMONITOR 
affe cd b0 92			call break_point_state  
b001				endm  
# End of macro CALLMONITOR
b001					endif 
b001			 
b001 ed 52			sbc hl, de 
b003			 
b003			 
b003				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b003			 
b003 20 26				jr nz, .mloopnotdone 
b005			 
b005 e1				pop hl   ; get rid of saved I 
b006				FORTH_LOOP_POP     ; get rid of limit 
b006 cd a2 9a			call macro_forth_loop_pop 
b009				endm 
# End of macro FORTH_LOOP_POP
b009			 
b009				FORTH_RSP_POP     ; get rid of DO ptr 
b009 cd 05 98			call macro_forth_rsp_pop 
b00c				endm 
# End of macro FORTH_RSP_POP
b00c			 
b00c			if DEBUG_FORTH_WORDS 
b00c						DMARK "-L>" 
b00c f5				push af  
b00d 3a 21 b0			ld a, (.dmark)  
b010 32 c0 ee			ld (debug_mark),a  
b013 3a 22 b0			ld a, (.dmark+1)  
b016 32 c1 ee			ld (debug_mark+1),a  
b019 3a 23 b0			ld a, (.dmark+2)  
b01c 32 c2 ee			ld (debug_mark+2),a  
b01f 18 03			jr .pastdmark  
b021 ..			.dmark: db "-L>"  
b024 f1			.pastdmark: pop af  
b025			endm  
# End of macro DMARK
b025				CALLMONITOR 
b025 cd b0 92			call break_point_state  
b028				endm  
# End of macro CALLMONITOR
b028			endif 
b028			 
b028					NEXTW 
b028 c3 a6 9b			jp macro_next 
b02b				endm 
# End of macro NEXTW
b02b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b02b			 
b02b			.mloopnotdone: 
b02b			 
b02b e1				pop hl    ; get I 
b02c 2b				dec hl 
b02d			 
b02d			   	; save new I 
b02d			 
b02d			 
b02d					; set I counter 
b02d			 
b02d 22 0b e8				ld (os_current_i), hl 
b030			 
b030					 
b030				FORTH_LOOP_NEXT 
b030 cd 65 9a			call macro_forth_loop_next 
b033				endm 
# End of macro FORTH_LOOP_NEXT
b033			 
b033			 
b033					if DEBUG_FORTH_WORDS 
b033 eb						ex de,hl 
b034					endif 
b034			 
b034			;	; get DO ptr 
b034			; 
b034				FORTH_RSP_TOS 
b034 cd fb 97			call macro_forth_rsp_tos 
b037				endm 
# End of macro FORTH_RSP_TOS
b037			 
b037				;push hl 
b037			 
b037				; not going to DO any more 
b037				; get rid of the RSP pointer as DO will add it back in 
b037				;FORTH_RSP_POP 
b037				;pop hl 
b037			 
b037			 
b037 22 e7 e7			ld (os_tok_ptr), hl 
b03a					if DEBUG_FORTH_WORDS 
b03a						DMARK "-L<" 
b03a f5				push af  
b03b 3a 4f b0			ld a, (.dmark)  
b03e 32 c0 ee			ld (debug_mark),a  
b041 3a 50 b0			ld a, (.dmark+1)  
b044 32 c1 ee			ld (debug_mark+1),a  
b047 3a 51 b0			ld a, (.dmark+2)  
b04a 32 c2 ee			ld (debug_mark+2),a  
b04d 18 03			jr .pastdmark  
b04f ..			.dmark: db "-L<"  
b052 f1			.pastdmark: pop af  
b053			endm  
# End of macro DMARK
b053					CALLMONITOR 
b053 cd b0 92			call break_point_state  
b056				endm  
# End of macro CALLMONITOR
b056				endif 
b056 c3 37 9c			jp exec1 
b059			 
b059					 
b059			 
b059			 
b059			 
b059				NEXTW 
b059 c3 a6 9b			jp macro_next 
b05c				endm 
# End of macro NEXTW
b05c			 
b05c			 
b05c			 
b05c			 
b05c			.REPEAT: 
b05c				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b05c 71				db WORD_SYS_CORE+93             
b05d af b0			dw .UNTIL            
b05f 06				db 5 + 1 
b060 .. 00			db "REPEAT",0              
b067				endm 
# End of macro CWHEAD
b067			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b067			;  push pc to rsp stack past the REPEAT 
b067					if DEBUG_FORTH_WORDS_KEY 
b067						DMARK "REP" 
b067 f5				push af  
b068 3a 7c b0			ld a, (.dmark)  
b06b 32 c0 ee			ld (debug_mark),a  
b06e 3a 7d b0			ld a, (.dmark+1)  
b071 32 c1 ee			ld (debug_mark+1),a  
b074 3a 7e b0			ld a, (.dmark+2)  
b077 32 c2 ee			ld (debug_mark+2),a  
b07a 18 03			jr .pastdmark  
b07c ..			.dmark: db "REP"  
b07f f1			.pastdmark: pop af  
b080			endm  
# End of macro DMARK
b080						CALLMONITOR 
b080 cd b0 92			call break_point_state  
b083				endm  
# End of macro CALLMONITOR
b083					endif 
b083			 
b083 2a e7 e7				ld hl, (os_tok_ptr) 
b086 23					inc hl   ; R 
b087 23					inc hl  ; E 
b088 23					inc hl   ; P 
b089 23					inc hl   ; E 
b08a 23					inc hl   ; A 
b08b 23					inc hl   ; T 
b08c 23					inc hl   ; zero 
b08d					FORTH_RSP_NEXT 
b08d cd e4 97			call macro_forth_rsp_next 
b090				endm 
# End of macro FORTH_RSP_NEXT
b090			 
b090			 
b090					if DEBUG_FORTH_WORDS 
b090						DMARK "REP" 
b090 f5				push af  
b091 3a a5 b0			ld a, (.dmark)  
b094 32 c0 ee			ld (debug_mark),a  
b097 3a a6 b0			ld a, (.dmark+1)  
b09a 32 c1 ee			ld (debug_mark+1),a  
b09d 3a a7 b0			ld a, (.dmark+2)  
b0a0 32 c2 ee			ld (debug_mark+2),a  
b0a3 18 03			jr .pastdmark  
b0a5 ..			.dmark: db "REP"  
b0a8 f1			.pastdmark: pop af  
b0a9			endm  
# End of macro DMARK
b0a9						;pop bc    ; TODO BUG ?????? what is this for???? 
b0a9						CALLMONITOR 
b0a9 cd b0 92			call break_point_state  
b0ac				endm  
# End of macro CALLMONITOR
b0ac					endif 
b0ac			 
b0ac					NEXTW 
b0ac c3 a6 9b			jp macro_next 
b0af				endm 
# End of macro NEXTW
b0af			;	       NEXTW 
b0af			 
b0af			.UNTIL: 
b0af				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b0af 72				db WORD_SYS_CORE+94             
b0b0 46 b1			dw .ENDFLOW            
b0b2 06				db 5 + 1 
b0b3 .. 00			db "UNTIL",0              
b0b9				endm 
# End of macro CWHEAD
b0b9			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b0b9			 
b0b9				; pop tos as check 
b0b9			 
b0b9				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b0b9			 
b0b9				FORTH_DSP_VALUEHL 
b0b9 cd 34 9a			call macro_dsp_valuehl 
b0bc				endm 
# End of macro FORTH_DSP_VALUEHL
b0bc			 
b0bc					if DEBUG_FORTH_WORDS_KEY 
b0bc						DMARK "UNT" 
b0bc f5				push af  
b0bd 3a d1 b0			ld a, (.dmark)  
b0c0 32 c0 ee			ld (debug_mark),a  
b0c3 3a d2 b0			ld a, (.dmark+1)  
b0c6 32 c1 ee			ld (debug_mark+1),a  
b0c9 3a d3 b0			ld a, (.dmark+2)  
b0cc 32 c2 ee			ld (debug_mark+2),a  
b0cf 18 03			jr .pastdmark  
b0d1 ..			.dmark: db "UNT"  
b0d4 f1			.pastdmark: pop af  
b0d5			endm  
# End of macro DMARK
b0d5						CALLMONITOR 
b0d5 cd b0 92			call break_point_state  
b0d8				endm  
# End of macro CALLMONITOR
b0d8					endif 
b0d8			 
b0d8			;	push hl 
b0d8				FORTH_DSP_POP 
b0d8 cd ec 9a			call macro_forth_dsp_pop 
b0db				endm 
# End of macro FORTH_DSP_POP
b0db			 
b0db			;	pop hl 
b0db			 
b0db				; test if true 
b0db			 
b0db cd 92 8a			call ishlzero 
b0de			;	ld a,l 
b0de			;	add h 
b0de			; 
b0de			;	cp 0 
b0de			 
b0de 20 3e			jr nz, .untilnotdone 
b0e0			 
b0e0					if DEBUG_FORTH_WORDS 
b0e0						DMARK "UNf" 
b0e0 f5				push af  
b0e1 3a f5 b0			ld a, (.dmark)  
b0e4 32 c0 ee			ld (debug_mark),a  
b0e7 3a f6 b0			ld a, (.dmark+1)  
b0ea 32 c1 ee			ld (debug_mark+1),a  
b0ed 3a f7 b0			ld a, (.dmark+2)  
b0f0 32 c2 ee			ld (debug_mark+2),a  
b0f3 18 03			jr .pastdmark  
b0f5 ..			.dmark: db "UNf"  
b0f8 f1			.pastdmark: pop af  
b0f9			endm  
# End of macro DMARK
b0f9						CALLMONITOR 
b0f9 cd b0 92			call break_point_state  
b0fc				endm  
# End of macro CALLMONITOR
b0fc					endif 
b0fc			 
b0fc			 
b0fc			 
b0fc				FORTH_RSP_POP     ; get rid of DO ptr 
b0fc cd 05 98			call macro_forth_rsp_pop 
b0ff				endm 
# End of macro FORTH_RSP_POP
b0ff			 
b0ff			if DEBUG_FORTH_WORDS 
b0ff						DMARK "UN>" 
b0ff f5				push af  
b100 3a 14 b1			ld a, (.dmark)  
b103 32 c0 ee			ld (debug_mark),a  
b106 3a 15 b1			ld a, (.dmark+1)  
b109 32 c1 ee			ld (debug_mark+1),a  
b10c 3a 16 b1			ld a, (.dmark+2)  
b10f 32 c2 ee			ld (debug_mark+2),a  
b112 18 03			jr .pastdmark  
b114 ..			.dmark: db "UN>"  
b117 f1			.pastdmark: pop af  
b118			endm  
# End of macro DMARK
b118				CALLMONITOR 
b118 cd b0 92			call break_point_state  
b11b				endm  
# End of macro CALLMONITOR
b11b			endif 
b11b			 
b11b					NEXTW 
b11b c3 a6 9b			jp macro_next 
b11e				endm 
# End of macro NEXTW
b11e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b11e			 
b11e			.untilnotdone: 
b11e			 
b11e			 
b11e			;	; get DO ptr 
b11e			; 
b11e				FORTH_RSP_TOS 
b11e cd fb 97			call macro_forth_rsp_tos 
b121				endm 
# End of macro FORTH_RSP_TOS
b121			 
b121				;push hl 
b121			 
b121				; not going to DO any more 
b121				; get rid of the RSP pointer as DO will add it back in 
b121				;FORTH_RSP_POP 
b121				;pop hl 
b121			 
b121			 
b121 22 e7 e7			ld (os_tok_ptr), hl 
b124					if DEBUG_FORTH_WORDS 
b124						DMARK "UN<" 
b124 f5				push af  
b125 3a 39 b1			ld a, (.dmark)  
b128 32 c0 ee			ld (debug_mark),a  
b12b 3a 3a b1			ld a, (.dmark+1)  
b12e 32 c1 ee			ld (debug_mark+1),a  
b131 3a 3b b1			ld a, (.dmark+2)  
b134 32 c2 ee			ld (debug_mark+2),a  
b137 18 03			jr .pastdmark  
b139 ..			.dmark: db "UN<"  
b13c f1			.pastdmark: pop af  
b13d			endm  
# End of macro DMARK
b13d					CALLMONITOR 
b13d cd b0 92			call break_point_state  
b140				endm  
# End of macro CALLMONITOR
b140				endif 
b140 c3 37 9c			jp exec1 
b143			 
b143					 
b143			 
b143			 
b143					NEXTW 
b143 c3 a6 9b			jp macro_next 
b146				endm 
# End of macro NEXTW
b146			 
b146			 
b146			.ENDFLOW: 
b146			 
b146			; eof 
b146			 
# End of file forth_words_flow.asm
b146			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b146			include "forth_words_logic.asm" 
b146			 
b146			; | ## Logic Words 
b146			 
b146			.NOT: 
b146				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b146 2d				db WORD_SYS_CORE+25             
b147 8e b1			dw .IS            
b149 04				db 3 + 1 
b14a .. 00			db "NOT",0              
b14e				endm 
# End of macro CWHEAD
b14e			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b14e					if DEBUG_FORTH_WORDS_KEY 
b14e						DMARK "NOT" 
b14e f5				push af  
b14f 3a 63 b1			ld a, (.dmark)  
b152 32 c0 ee			ld (debug_mark),a  
b155 3a 64 b1			ld a, (.dmark+1)  
b158 32 c1 ee			ld (debug_mark+1),a  
b15b 3a 65 b1			ld a, (.dmark+2)  
b15e 32 c2 ee			ld (debug_mark+2),a  
b161 18 03			jr .pastdmark  
b163 ..			.dmark: db "NOT"  
b166 f1			.pastdmark: pop af  
b167			endm  
# End of macro DMARK
b167						CALLMONITOR 
b167 cd b0 92			call break_point_state  
b16a				endm  
# End of macro CALLMONITOR
b16a					endif 
b16a					FORTH_DSP 
b16a cd fa 99			call macro_forth_dsp 
b16d				endm 
# End of macro FORTH_DSP
b16d 7e					ld a,(hl)	; get type of value on TOS 
b16e fe 02				cp DS_TYPE_INUM  
b170 28 03				jr z, .noti 
b172					NEXTW 
b172 c3 a6 9b			jp macro_next 
b175				endm 
# End of macro NEXTW
b175			.noti:          FORTH_DSP_VALUEHL 
b175 cd 34 9a			call macro_dsp_valuehl 
b178				endm 
# End of macro FORTH_DSP_VALUEHL
b178			;		push hl 
b178					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b178 cd ec 9a			call macro_forth_dsp_pop 
b17b				endm 
# End of macro FORTH_DSP_POP
b17b			;		pop hl 
b17b 3e 00				ld a,0 
b17d bd					cp l 
b17e 28 04				jr z, .not2t 
b180 2e 00				ld l, 0 
b182 18 02				jr .notip 
b184			 
b184 2e ff		.not2t:		ld l, 255 
b186			 
b186 26 00		.notip:		ld h, 0	 
b188			 
b188 cd 3d 98				call forth_push_numhl 
b18b					NEXTW 
b18b c3 a6 9b			jp macro_next 
b18e				endm 
# End of macro NEXTW
b18e			 
b18e			.IS: 
b18e				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b18e 2d				db WORD_SYS_CORE+25             
b18f b4 b1			dw .LZERO            
b191 03				db 2 + 1 
b192 .. 00			db "IS",0              
b195				endm 
# End of macro CWHEAD
b195			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b195					if DEBUG_FORTH_WORDS_KEY 
b195						DMARK "IS." 
b195 f5				push af  
b196 3a aa b1			ld a, (.dmark)  
b199 32 c0 ee			ld (debug_mark),a  
b19c 3a ab b1			ld a, (.dmark+1)  
b19f 32 c1 ee			ld (debug_mark+1),a  
b1a2 3a ac b1			ld a, (.dmark+2)  
b1a5 32 c2 ee			ld (debug_mark+2),a  
b1a8 18 03			jr .pastdmark  
b1aa ..			.dmark: db "IS."  
b1ad f1			.pastdmark: pop af  
b1ae			endm  
# End of macro DMARK
b1ae						CALLMONITOR 
b1ae cd b0 92			call break_point_state  
b1b1				endm  
# End of macro CALLMONITOR
b1b1					endif 
b1b1					NEXTW 
b1b1 c3 a6 9b			jp macro_next 
b1b4				endm 
# End of macro NEXTW
b1b4			.LZERO: 
b1b4				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b1b4 2d				db WORD_SYS_CORE+25             
b1b5 be b1			dw .TZERO            
b1b7 03				db 2 + 1 
b1b8 .. 00			db "0<",0              
b1bb				endm 
# End of macro CWHEAD
b1bb			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b1bb					NEXTW 
b1bb c3 a6 9b			jp macro_next 
b1be				endm 
# End of macro NEXTW
b1be			.TZERO: 
b1be				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b1be 2e				db WORD_SYS_CORE+26             
b1bf 05 b2			dw .LESS            
b1c1 03				db 2 + 1 
b1c2 .. 00			db "0=",0              
b1c5				endm 
# End of macro CWHEAD
b1c5			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b1c5				; TODO add floating point number detection 
b1c5					;v5 FORTH_DSP_VALUE 
b1c5					if DEBUG_FORTH_WORDS_KEY 
b1c5						DMARK "0=." 
b1c5 f5				push af  
b1c6 3a da b1			ld a, (.dmark)  
b1c9 32 c0 ee			ld (debug_mark),a  
b1cc 3a db b1			ld a, (.dmark+1)  
b1cf 32 c1 ee			ld (debug_mark+1),a  
b1d2 3a dc b1			ld a, (.dmark+2)  
b1d5 32 c2 ee			ld (debug_mark+2),a  
b1d8 18 03			jr .pastdmark  
b1da ..			.dmark: db "0=."  
b1dd f1			.pastdmark: pop af  
b1de			endm  
# End of macro DMARK
b1de						CALLMONITOR 
b1de cd b0 92			call break_point_state  
b1e1				endm  
# End of macro CALLMONITOR
b1e1					endif 
b1e1					FORTH_DSP 
b1e1 cd fa 99			call macro_forth_dsp 
b1e4				endm 
# End of macro FORTH_DSP
b1e4 7e					ld a,(hl)	; get type of value on TOS 
b1e5 fe 02				cp DS_TYPE_INUM  
b1e7 28 00				jr z, .tz_inum 
b1e9			 
b1e9				if FORTH_ENABLE_FLOATMATH 
b1e9					jr .tz_done 
b1e9			 
b1e9				endif 
b1e9					 
b1e9			 
b1e9			.tz_inum: 
b1e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1e9 cd 34 9a			call macro_dsp_valuehl 
b1ec				endm 
# End of macro FORTH_DSP_VALUEHL
b1ec			 
b1ec			;		push hl 
b1ec			 
b1ec					; destroy value TOS 
b1ec			 
b1ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1ec cd ec 9a			call macro_forth_dsp_pop 
b1ef				endm 
# End of macro FORTH_DSP_POP
b1ef			 
b1ef			;		pop hl 
b1ef			 
b1ef 3e 00				ld a,0 
b1f1			 
b1f1 bd					cp l 
b1f2 20 08				jr nz, .tz_notzero 
b1f4			 
b1f4 bc					cp h 
b1f5			 
b1f5 20 05				jr nz, .tz_notzero 
b1f7			 
b1f7			 
b1f7 21 01 00				ld hl, FORTH_TRUE 
b1fa 18 03				jr .tz_done 
b1fc			 
b1fc 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b1ff			 
b1ff					; push value back onto stack for another op etc 
b1ff			 
b1ff			.tz_done: 
b1ff cd 3d 98				call forth_push_numhl 
b202			 
b202					NEXTW 
b202 c3 a6 9b			jp macro_next 
b205				endm 
# End of macro NEXTW
b205			.LESS: 
b205				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b205 2f				db WORD_SYS_CORE+27             
b206 6e b2			dw .GT            
b208 02				db 1 + 1 
b209 .. 00			db "<",0              
b20b				endm 
# End of macro CWHEAD
b20b			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b20b				; TODO add floating point number detection 
b20b					if DEBUG_FORTH_WORDS_KEY 
b20b						DMARK "LES" 
b20b f5				push af  
b20c 3a 20 b2			ld a, (.dmark)  
b20f 32 c0 ee			ld (debug_mark),a  
b212 3a 21 b2			ld a, (.dmark+1)  
b215 32 c1 ee			ld (debug_mark+1),a  
b218 3a 22 b2			ld a, (.dmark+2)  
b21b 32 c2 ee			ld (debug_mark+2),a  
b21e 18 03			jr .pastdmark  
b220 ..			.dmark: db "LES"  
b223 f1			.pastdmark: pop af  
b224			endm  
# End of macro DMARK
b224						CALLMONITOR 
b224 cd b0 92			call break_point_state  
b227				endm  
# End of macro CALLMONITOR
b227					endif 
b227					FORTH_DSP 
b227 cd fa 99			call macro_forth_dsp 
b22a				endm 
# End of macro FORTH_DSP
b22a					;v5 FORTH_DSP_VALUE 
b22a 7e					ld a,(hl)	; get type of value on TOS 
b22b fe 02				cp DS_TYPE_INUM  
b22d 28 00				jr z, .less_inum 
b22f			 
b22f				if FORTH_ENABLE_FLOATMATH 
b22f					jr .less_done 
b22f			 
b22f				endif 
b22f					 
b22f			 
b22f			.less_inum: 
b22f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b22f cd 34 9a			call macro_dsp_valuehl 
b232				endm 
# End of macro FORTH_DSP_VALUEHL
b232			 
b232 e5					push hl  ; u2 
b233			 
b233					; destroy value TOS 
b233			 
b233					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b233 cd ec 9a			call macro_forth_dsp_pop 
b236				endm 
# End of macro FORTH_DSP_POP
b236			 
b236			 
b236					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b236 cd 34 9a			call macro_dsp_valuehl 
b239				endm 
# End of macro FORTH_DSP_VALUEHL
b239			 
b239 e5					push hl    ; u1 
b23a			 
b23a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b23a cd ec 9a			call macro_forth_dsp_pop 
b23d				endm 
# End of macro FORTH_DSP_POP
b23d			 
b23d			 
b23d b7			 or a      ;clear carry flag 
b23e 01 00 00		 ld bc, FORTH_FALSE 
b241 e1			  pop hl    ; u1 
b242 d1			  pop de    ; u2 
b243 ed 52		  sbc hl,de 
b245 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b247			 
b247 01 01 00		 ld bc, FORTH_TRUE 
b24a			.lscont:  
b24a c5					push bc 
b24b e1					pop hl 
b24c			 
b24c					if DEBUG_FORTH_WORDS 
b24c						DMARK "LT1" 
b24c f5				push af  
b24d 3a 61 b2			ld a, (.dmark)  
b250 32 c0 ee			ld (debug_mark),a  
b253 3a 62 b2			ld a, (.dmark+1)  
b256 32 c1 ee			ld (debug_mark+1),a  
b259 3a 63 b2			ld a, (.dmark+2)  
b25c 32 c2 ee			ld (debug_mark+2),a  
b25f 18 03			jr .pastdmark  
b261 ..			.dmark: db "LT1"  
b264 f1			.pastdmark: pop af  
b265			endm  
# End of macro DMARK
b265						CALLMONITOR 
b265 cd b0 92			call break_point_state  
b268				endm  
# End of macro CALLMONITOR
b268					endif 
b268 cd 3d 98				call forth_push_numhl 
b26b			 
b26b					NEXTW 
b26b c3 a6 9b			jp macro_next 
b26e				endm 
# End of macro NEXTW
b26e			.GT: 
b26e				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b26e 30				db WORD_SYS_CORE+28             
b26f d7 b2			dw .EQUAL            
b271 02				db 1 + 1 
b272 .. 00			db ">",0              
b274				endm 
# End of macro CWHEAD
b274			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b274				; TODO add floating point number detection 
b274					if DEBUG_FORTH_WORDS_KEY 
b274						DMARK "GRT" 
b274 f5				push af  
b275 3a 89 b2			ld a, (.dmark)  
b278 32 c0 ee			ld (debug_mark),a  
b27b 3a 8a b2			ld a, (.dmark+1)  
b27e 32 c1 ee			ld (debug_mark+1),a  
b281 3a 8b b2			ld a, (.dmark+2)  
b284 32 c2 ee			ld (debug_mark+2),a  
b287 18 03			jr .pastdmark  
b289 ..			.dmark: db "GRT"  
b28c f1			.pastdmark: pop af  
b28d			endm  
# End of macro DMARK
b28d						CALLMONITOR 
b28d cd b0 92			call break_point_state  
b290				endm  
# End of macro CALLMONITOR
b290					endif 
b290					FORTH_DSP 
b290 cd fa 99			call macro_forth_dsp 
b293				endm 
# End of macro FORTH_DSP
b293					;FORTH_DSP_VALUE 
b293 7e					ld a,(hl)	; get type of value on TOS 
b294 fe 02				cp DS_TYPE_INUM  
b296 28 00				jr z, .gt_inum 
b298			 
b298				if FORTH_ENABLE_FLOATMATH 
b298					jr .gt_done 
b298			 
b298				endif 
b298					 
b298			 
b298			.gt_inum: 
b298					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b298 cd 34 9a			call macro_dsp_valuehl 
b29b				endm 
# End of macro FORTH_DSP_VALUEHL
b29b			 
b29b e5					push hl  ; u2 
b29c			 
b29c					; destroy value TOS 
b29c			 
b29c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b29c cd ec 9a			call macro_forth_dsp_pop 
b29f				endm 
# End of macro FORTH_DSP_POP
b29f			 
b29f			 
b29f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b29f cd 34 9a			call macro_dsp_valuehl 
b2a2				endm 
# End of macro FORTH_DSP_VALUEHL
b2a2			 
b2a2 e5					push hl    ; u1 
b2a3			 
b2a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2a3 cd ec 9a			call macro_forth_dsp_pop 
b2a6				endm 
# End of macro FORTH_DSP_POP
b2a6			 
b2a6			 
b2a6 b7			 or a      ;clear carry flag 
b2a7 01 00 00		 ld bc, FORTH_FALSE 
b2aa e1			  pop hl    ; u1 
b2ab d1			  pop de    ; u2 
b2ac ed 52		  sbc hl,de 
b2ae 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b2b0			 
b2b0 01 01 00		 ld bc, FORTH_TRUE 
b2b3			.gtcont:  
b2b3 c5					push bc 
b2b4 e1					pop hl 
b2b5			 
b2b5					if DEBUG_FORTH_WORDS 
b2b5						DMARK "GT1" 
b2b5 f5				push af  
b2b6 3a ca b2			ld a, (.dmark)  
b2b9 32 c0 ee			ld (debug_mark),a  
b2bc 3a cb b2			ld a, (.dmark+1)  
b2bf 32 c1 ee			ld (debug_mark+1),a  
b2c2 3a cc b2			ld a, (.dmark+2)  
b2c5 32 c2 ee			ld (debug_mark+2),a  
b2c8 18 03			jr .pastdmark  
b2ca ..			.dmark: db "GT1"  
b2cd f1			.pastdmark: pop af  
b2ce			endm  
# End of macro DMARK
b2ce						CALLMONITOR 
b2ce cd b0 92			call break_point_state  
b2d1				endm  
# End of macro CALLMONITOR
b2d1					endif 
b2d1 cd 3d 98				call forth_push_numhl 
b2d4			 
b2d4					NEXTW 
b2d4 c3 a6 9b			jp macro_next 
b2d7				endm 
# End of macro NEXTW
b2d7			.EQUAL: 
b2d7				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b2d7 31				db WORD_SYS_CORE+29             
b2d8 42 b3			dw .ENDLOGIC            
b2da 02				db 1 + 1 
b2db .. 00			db "=",0              
b2dd				endm 
# End of macro CWHEAD
b2dd			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b2dd				; TODO add floating point number detection 
b2dd					if DEBUG_FORTH_WORDS_KEY 
b2dd						DMARK "EQ." 
b2dd f5				push af  
b2de 3a f2 b2			ld a, (.dmark)  
b2e1 32 c0 ee			ld (debug_mark),a  
b2e4 3a f3 b2			ld a, (.dmark+1)  
b2e7 32 c1 ee			ld (debug_mark+1),a  
b2ea 3a f4 b2			ld a, (.dmark+2)  
b2ed 32 c2 ee			ld (debug_mark+2),a  
b2f0 18 03			jr .pastdmark  
b2f2 ..			.dmark: db "EQ."  
b2f5 f1			.pastdmark: pop af  
b2f6			endm  
# End of macro DMARK
b2f6						CALLMONITOR 
b2f6 cd b0 92			call break_point_state  
b2f9				endm  
# End of macro CALLMONITOR
b2f9					endif 
b2f9					FORTH_DSP 
b2f9 cd fa 99			call macro_forth_dsp 
b2fc				endm 
# End of macro FORTH_DSP
b2fc					;v5 FORTH_DSP_VALUE 
b2fc 7e					ld a,(hl)	; get type of value on TOS 
b2fd fe 02				cp DS_TYPE_INUM  
b2ff 28 00				jr z, .eq_inum 
b301			 
b301				if FORTH_ENABLE_FLOATMATH 
b301					jr .eq_done 
b301			 
b301				endif 
b301					 
b301			 
b301			.eq_inum: 
b301					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b301 cd 34 9a			call macro_dsp_valuehl 
b304				endm 
# End of macro FORTH_DSP_VALUEHL
b304			 
b304 e5					push hl 
b305			 
b305					; destroy value TOS 
b305			 
b305					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b305 cd ec 9a			call macro_forth_dsp_pop 
b308				endm 
# End of macro FORTH_DSP_POP
b308			 
b308			 
b308					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b308 cd 34 9a			call macro_dsp_valuehl 
b30b				endm 
# End of macro FORTH_DSP_VALUEHL
b30b			 
b30b					; one value on hl get other one back 
b30b			 
b30b e5					push hl 
b30c			 
b30c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b30c cd ec 9a			call macro_forth_dsp_pop 
b30f				endm 
# End of macro FORTH_DSP_POP
b30f			 
b30f 0e 00				ld c, FORTH_FALSE 
b311			 
b311 e1					pop hl 
b312 d1					pop de 
b313			 
b313 7b					ld a, e 
b314 bd					cp l 
b315			 
b315 20 06				jr nz, .eq_done 
b317			 
b317 7a					ld a, d 
b318 bc					cp h 
b319			 
b319 20 02				jr nz, .eq_done 
b31b			 
b31b 0e 01				ld c, FORTH_TRUE 
b31d					 
b31d			 
b31d			 
b31d			.eq_done: 
b31d			 
b31d					; TODO push value back onto stack for another op etc 
b31d			 
b31d 26 00				ld h, 0 
b31f 69					ld l, c 
b320					if DEBUG_FORTH_WORDS 
b320						DMARK "EQ1" 
b320 f5				push af  
b321 3a 35 b3			ld a, (.dmark)  
b324 32 c0 ee			ld (debug_mark),a  
b327 3a 36 b3			ld a, (.dmark+1)  
b32a 32 c1 ee			ld (debug_mark+1),a  
b32d 3a 37 b3			ld a, (.dmark+2)  
b330 32 c2 ee			ld (debug_mark+2),a  
b333 18 03			jr .pastdmark  
b335 ..			.dmark: db "EQ1"  
b338 f1			.pastdmark: pop af  
b339			endm  
# End of macro DMARK
b339						CALLMONITOR 
b339 cd b0 92			call break_point_state  
b33c				endm  
# End of macro CALLMONITOR
b33c					endif 
b33c cd 3d 98				call forth_push_numhl 
b33f			 
b33f					NEXTW 
b33f c3 a6 9b			jp macro_next 
b342				endm 
# End of macro NEXTW
b342			 
b342			 
b342			.ENDLOGIC: 
b342			; eof 
b342			 
b342			 
# End of file forth_words_logic.asm
b342			include "forth_words_maths.asm" 
b342			 
b342			; | ## Maths Words 
b342			 
b342			.PLUS:	 
b342				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b342 15				db WORD_SYS_CORE+1             
b343 84 b3			dw .NEG            
b345 02				db 1 + 1 
b346 .. 00			db "+",0              
b348				endm 
# End of macro CWHEAD
b348			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b348					if DEBUG_FORTH_WORDS_KEY 
b348						DMARK "PLU" 
b348 f5				push af  
b349 3a 5d b3			ld a, (.dmark)  
b34c 32 c0 ee			ld (debug_mark),a  
b34f 3a 5e b3			ld a, (.dmark+1)  
b352 32 c1 ee			ld (debug_mark+1),a  
b355 3a 5f b3			ld a, (.dmark+2)  
b358 32 c2 ee			ld (debug_mark+2),a  
b35b 18 03			jr .pastdmark  
b35d ..			.dmark: db "PLU"  
b360 f1			.pastdmark: pop af  
b361			endm  
# End of macro DMARK
b361						CALLMONITOR 
b361 cd b0 92			call break_point_state  
b364				endm  
# End of macro CALLMONITOR
b364					endif 
b364					; add top two values and push back result 
b364			 
b364					;for v5 FORTH_DSP_VALUE 
b364					FORTH_DSP 
b364 cd fa 99			call macro_forth_dsp 
b367				endm 
# End of macro FORTH_DSP
b367 7e					ld a,(hl)	; get type of value on TOS 
b368 fe 02				cp DS_TYPE_INUM  
b36a 28 03				jr z, .dot_inum 
b36c			 
b36c					NEXTW 
b36c c3 a6 9b			jp macro_next 
b36f				endm 
# End of macro NEXTW
b36f			 
b36f			; float maths 
b36f			 
b36f				if FORTH_ENABLE_FLOATMATH 
b36f						inc hl      ; now at start of numeric as string 
b36f			 
b36f					if DEBUG_FORTH_MATHS 
b36f						DMARK "ADD" 
b36f				CALLMONITOR 
b36f					endif 
b36f			 
b36f					;ld ix, hl 
b36f					call CON 
b36f			 
b36f			 
b36f					push hl 
b36f					 
b36f					 
b36f			 
b36f						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b36f			 
b36f					; get next number 
b36f			 
b36f						FORTH_DSP_VALUE 
b36f			 
b36f						inc hl      ; now at start of numeric as string 
b36f			 
b36f					;ld ix, hl 
b36f					call CON 
b36f			 
b36f					push hl 
b36f			 
b36f			 
b36f						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b36f			 
b36f						; TODO do add 
b36f			 
b36f						call IADD 
b36f			 
b36f						; TODO get result back as ascii 
b36f			 
b36f						; TODO push result  
b36f			 
b36f			 
b36f			 
b36f						jr .dot_done 
b36f				endif 
b36f			 
b36f			.dot_inum: 
b36f			 
b36f			 
b36f					if DEBUG_FORTH_DOT 
b36f						DMARK "+IT" 
b36f				CALLMONITOR 
b36f					endif 
b36f			 
b36f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b36f cd 34 9a			call macro_dsp_valuehl 
b372				endm 
# End of macro FORTH_DSP_VALUEHL
b372			 
b372				; TODO add floating point number detection 
b372			 
b372 e5					push hl 
b373			 
b373					; destroy value TOS 
b373			 
b373					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b373 cd ec 9a			call macro_forth_dsp_pop 
b376				endm 
# End of macro FORTH_DSP_POP
b376			 
b376			 
b376					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b376 cd 34 9a			call macro_dsp_valuehl 
b379				endm 
# End of macro FORTH_DSP_VALUEHL
b379			 
b379					; one value on hl get other one back 
b379			 
b379 d1					pop de 
b37a			 
b37a					; do the add 
b37a			 
b37a 19					add hl,de 
b37b			 
b37b					; save it 
b37b			 
b37b			;		push hl	 
b37b			 
b37b					; 
b37b			 
b37b					; destroy value TOS 
b37b			 
b37b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b37b cd ec 9a			call macro_forth_dsp_pop 
b37e				endm 
# End of macro FORTH_DSP_POP
b37e			 
b37e					; TODO push value back onto stack for another op etc 
b37e			 
b37e			;		pop hl 
b37e			 
b37e			.dot_done: 
b37e cd 3d 98				call forth_push_numhl 
b381			 
b381					NEXTW 
b381 c3 a6 9b			jp macro_next 
b384				endm 
# End of macro NEXTW
b384			.NEG: 
b384			 
b384				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b384 17				db WORD_SYS_CORE+3             
b385 c7 b3			dw .DIV            
b387 02				db 1 + 1 
b388 .. 00			db "-",0              
b38a				endm 
# End of macro CWHEAD
b38a			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b38a					if DEBUG_FORTH_WORDS_KEY 
b38a						DMARK "SUB" 
b38a f5				push af  
b38b 3a 9f b3			ld a, (.dmark)  
b38e 32 c0 ee			ld (debug_mark),a  
b391 3a a0 b3			ld a, (.dmark+1)  
b394 32 c1 ee			ld (debug_mark+1),a  
b397 3a a1 b3			ld a, (.dmark+2)  
b39a 32 c2 ee			ld (debug_mark+2),a  
b39d 18 03			jr .pastdmark  
b39f ..			.dmark: db "SUB"  
b3a2 f1			.pastdmark: pop af  
b3a3			endm  
# End of macro DMARK
b3a3						CALLMONITOR 
b3a3 cd b0 92			call break_point_state  
b3a6				endm  
# End of macro CALLMONITOR
b3a6					endif 
b3a6			 
b3a6			 
b3a6				; TODO add floating point number detection 
b3a6					; v5 FORTH_DSP_VALUE 
b3a6					FORTH_DSP 
b3a6 cd fa 99			call macro_forth_dsp 
b3a9				endm 
# End of macro FORTH_DSP
b3a9 7e					ld a,(hl)	; get type of value on TOS 
b3aa fe 02				cp DS_TYPE_INUM  
b3ac 28 03				jr z, .neg_inum 
b3ae			 
b3ae					NEXTW 
b3ae c3 a6 9b			jp macro_next 
b3b1				endm 
# End of macro NEXTW
b3b1			 
b3b1			; float maths 
b3b1			 
b3b1				if FORTH_ENABLE_FLOATMATH 
b3b1					jr .neg_done 
b3b1			 
b3b1				endif 
b3b1					 
b3b1			 
b3b1			.neg_inum: 
b3b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3b1 cd 34 9a			call macro_dsp_valuehl 
b3b4				endm 
# End of macro FORTH_DSP_VALUEHL
b3b4			 
b3b4 e5					push hl 
b3b5			 
b3b5					; destroy value TOS 
b3b5			 
b3b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3b5 cd ec 9a			call macro_forth_dsp_pop 
b3b8				endm 
# End of macro FORTH_DSP_POP
b3b8			 
b3b8			 
b3b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3b8 cd 34 9a			call macro_dsp_valuehl 
b3bb				endm 
# End of macro FORTH_DSP_VALUEHL
b3bb			 
b3bb					; one value on hl get other one back 
b3bb			 
b3bb d1					pop de 
b3bc			 
b3bc					; do the sub 
b3bc			;		ex de, hl 
b3bc			 
b3bc ed 52				sbc hl,de 
b3be			 
b3be					; save it 
b3be			 
b3be			;		push hl	 
b3be			 
b3be					; 
b3be			 
b3be					; destroy value TOS 
b3be			 
b3be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3be cd ec 9a			call macro_forth_dsp_pop 
b3c1				endm 
# End of macro FORTH_DSP_POP
b3c1			 
b3c1					; TODO push value back onto stack for another op etc 
b3c1			 
b3c1			;		pop hl 
b3c1			 
b3c1 cd 3d 98				call forth_push_numhl 
b3c4			.neg_done: 
b3c4			 
b3c4					NEXTW 
b3c4 c3 a6 9b			jp macro_next 
b3c7				endm 
# End of macro NEXTW
b3c7			.DIV: 
b3c7				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b3c7 18				db WORD_SYS_CORE+4             
b3c8 14 b4			dw .MUL            
b3ca 02				db 1 + 1 
b3cb .. 00			db "/",0              
b3cd				endm 
# End of macro CWHEAD
b3cd			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b3cd					if DEBUG_FORTH_WORDS_KEY 
b3cd						DMARK "DIV" 
b3cd f5				push af  
b3ce 3a e2 b3			ld a, (.dmark)  
b3d1 32 c0 ee			ld (debug_mark),a  
b3d4 3a e3 b3			ld a, (.dmark+1)  
b3d7 32 c1 ee			ld (debug_mark+1),a  
b3da 3a e4 b3			ld a, (.dmark+2)  
b3dd 32 c2 ee			ld (debug_mark+2),a  
b3e0 18 03			jr .pastdmark  
b3e2 ..			.dmark: db "DIV"  
b3e5 f1			.pastdmark: pop af  
b3e6			endm  
# End of macro DMARK
b3e6						CALLMONITOR 
b3e6 cd b0 92			call break_point_state  
b3e9				endm  
# End of macro CALLMONITOR
b3e9					endif 
b3e9				; TODO add floating point number detection 
b3e9					; v5 FORTH_DSP_VALUE 
b3e9					FORTH_DSP 
b3e9 cd fa 99			call macro_forth_dsp 
b3ec				endm 
# End of macro FORTH_DSP
b3ec 7e					ld a,(hl)	; get type of value on TOS 
b3ed fe 02				cp DS_TYPE_INUM  
b3ef 28 03				jr z, .div_inum 
b3f1			 
b3f1				if FORTH_ENABLE_FLOATMATH 
b3f1					jr .div_done 
b3f1			 
b3f1				endif 
b3f1					NEXTW 
b3f1 c3 a6 9b			jp macro_next 
b3f4				endm 
# End of macro NEXTW
b3f4			.div_inum: 
b3f4			 
b3f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3f4 cd 34 9a			call macro_dsp_valuehl 
b3f7				endm 
# End of macro FORTH_DSP_VALUEHL
b3f7			 
b3f7 e5					push hl    ; to go to bc 
b3f8			 
b3f8					; destroy value TOS 
b3f8			 
b3f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3f8 cd ec 9a			call macro_forth_dsp_pop 
b3fb				endm 
# End of macro FORTH_DSP_POP
b3fb			 
b3fb			 
b3fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3fb cd 34 9a			call macro_dsp_valuehl 
b3fe				endm 
# End of macro FORTH_DSP_VALUEHL
b3fe			 
b3fe					; hl to go to de 
b3fe			 
b3fe e5					push hl 
b3ff			 
b3ff c1					pop bc 
b400 d1					pop de		 
b401			 
b401			 
b401					if DEBUG_FORTH_MATHS 
b401						DMARK "DIV" 
b401				CALLMONITOR 
b401					endif 
b401					; one value on hl but move to a get other one back 
b401			 
b401			        
b401 cd c6 89			call Div16 
b404			 
b404			;	push af	 
b404 e5				push hl 
b405 c5				push bc 
b406			 
b406					if DEBUG_FORTH_MATHS 
b406						DMARK "DI1" 
b406				CALLMONITOR 
b406					endif 
b406			 
b406					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b406 cd ec 9a			call macro_forth_dsp_pop 
b409				endm 
# End of macro FORTH_DSP_POP
b409			 
b409			 
b409			 
b409 e1					pop hl    ; result 
b40a			 
b40a cd 3d 98				call forth_push_numhl 
b40d			 
b40d e1					pop hl    ; reminder 
b40e			;		ld h,0 
b40e			;		ld l,d 
b40e			 
b40e cd 3d 98				call forth_push_numhl 
b411			.div_done: 
b411					NEXTW 
b411 c3 a6 9b			jp macro_next 
b414				endm 
# End of macro NEXTW
b414			.MUL: 
b414				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b414 19				db WORD_SYS_CORE+5             
b415 59 b4			dw .MIN            
b417 02				db 1 + 1 
b418 .. 00			db "*",0              
b41a				endm 
# End of macro CWHEAD
b41a			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b41a				; TODO add floating point number detection 
b41a					if DEBUG_FORTH_WORDS_KEY 
b41a						DMARK "MUL" 
b41a f5				push af  
b41b 3a 2f b4			ld a, (.dmark)  
b41e 32 c0 ee			ld (debug_mark),a  
b421 3a 30 b4			ld a, (.dmark+1)  
b424 32 c1 ee			ld (debug_mark+1),a  
b427 3a 31 b4			ld a, (.dmark+2)  
b42a 32 c2 ee			ld (debug_mark+2),a  
b42d 18 03			jr .pastdmark  
b42f ..			.dmark: db "MUL"  
b432 f1			.pastdmark: pop af  
b433			endm  
# End of macro DMARK
b433						CALLMONITOR 
b433 cd b0 92			call break_point_state  
b436				endm  
# End of macro CALLMONITOR
b436					endif 
b436					FORTH_DSP 
b436 cd fa 99			call macro_forth_dsp 
b439				endm 
# End of macro FORTH_DSP
b439					; v5 FORTH_DSP_VALUE 
b439 7e					ld a,(hl)	; get type of value on TOS 
b43a fe 02				cp DS_TYPE_INUM  
b43c 28 03				jr z, .mul_inum 
b43e			 
b43e				if FORTH_ENABLE_FLOATMATH 
b43e					jr .mul_done 
b43e			 
b43e				endif 
b43e			 
b43e					NEXTW 
b43e c3 a6 9b			jp macro_next 
b441				endm 
# End of macro NEXTW
b441			.mul_inum:	 
b441			 
b441					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b441 cd 34 9a			call macro_dsp_valuehl 
b444				endm 
# End of macro FORTH_DSP_VALUEHL
b444			 
b444 e5					push hl 
b445			 
b445					; destroy value TOS 
b445			 
b445					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b445 cd ec 9a			call macro_forth_dsp_pop 
b448				endm 
# End of macro FORTH_DSP_POP
b448			 
b448			 
b448					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b448 cd 34 9a			call macro_dsp_valuehl 
b44b				endm 
# End of macro FORTH_DSP_VALUEHL
b44b			 
b44b					; one value on hl but move to a get other one back 
b44b			 
b44b 7d					ld a, l 
b44c			 
b44c d1					pop de 
b44d			 
b44d					; do the mull 
b44d			;		ex de, hl 
b44d			 
b44d cd ec 89				call Mult16 
b450					; save it 
b450			 
b450			;		push hl	 
b450			 
b450					; 
b450			 
b450					; destroy value TOS 
b450			 
b450					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b450 cd ec 9a			call macro_forth_dsp_pop 
b453				endm 
# End of macro FORTH_DSP_POP
b453			 
b453					; TODO push value back onto stack for another op etc 
b453			 
b453			;		pop hl 
b453			 
b453 cd 3d 98				call forth_push_numhl 
b456			 
b456			.mul_done: 
b456					NEXTW 
b456 c3 a6 9b			jp macro_next 
b459				endm 
# End of macro NEXTW
b459			 
b459			 
b459			 
b459			 
b459			.MIN: 
b459				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b459 49				db WORD_SYS_CORE+53             
b45a da b4			dw .MAX            
b45c 04				db 3 + 1 
b45d .. 00			db "MIN",0              
b461				endm 
# End of macro CWHEAD
b461			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b461					if DEBUG_FORTH_WORDS_KEY 
b461						DMARK "MIN" 
b461 f5				push af  
b462 3a 76 b4			ld a, (.dmark)  
b465 32 c0 ee			ld (debug_mark),a  
b468 3a 77 b4			ld a, (.dmark+1)  
b46b 32 c1 ee			ld (debug_mark+1),a  
b46e 3a 78 b4			ld a, (.dmark+2)  
b471 32 c2 ee			ld (debug_mark+2),a  
b474 18 03			jr .pastdmark  
b476 ..			.dmark: db "MIN"  
b479 f1			.pastdmark: pop af  
b47a			endm  
# End of macro DMARK
b47a						CALLMONITOR 
b47a cd b0 92			call break_point_state  
b47d				endm  
# End of macro CALLMONITOR
b47d					endif 
b47d					; get u2 
b47d			 
b47d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b47d cd 34 9a			call macro_dsp_valuehl 
b480				endm 
# End of macro FORTH_DSP_VALUEHL
b480			 
b480 e5					push hl   ; u2 
b481			 
b481					; destroy value TOS 
b481			 
b481					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b481 cd ec 9a			call macro_forth_dsp_pop 
b484				endm 
# End of macro FORTH_DSP_POP
b484			 
b484					; get u1 
b484			 
b484					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b484 cd 34 9a			call macro_dsp_valuehl 
b487				endm 
# End of macro FORTH_DSP_VALUEHL
b487			 
b487 e5					push hl  ; u1 
b488			 
b488					; destroy value TOS 
b488			 
b488					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b488 cd ec 9a			call macro_forth_dsp_pop 
b48b				endm 
# End of macro FORTH_DSP_POP
b48b			 
b48b b7			 or a      ;clear carry flag 
b48c e1			  pop hl    ; u1 
b48d d1			  pop de    ; u2 
b48e e5				push hl   ; saved in case hl is lowest 
b48f ed 52		  sbc hl,de 
b491 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b493			 
b493 e1				pop hl 
b494					if DEBUG_FORTH_WORDS 
b494						DMARK "MIN" 
b494 f5				push af  
b495 3a a9 b4			ld a, (.dmark)  
b498 32 c0 ee			ld (debug_mark),a  
b49b 3a aa b4			ld a, (.dmark+1)  
b49e 32 c1 ee			ld (debug_mark+1),a  
b4a1 3a ab b4			ld a, (.dmark+2)  
b4a4 32 c2 ee			ld (debug_mark+2),a  
b4a7 18 03			jr .pastdmark  
b4a9 ..			.dmark: db "MIN"  
b4ac f1			.pastdmark: pop af  
b4ad			endm  
# End of macro DMARK
b4ad						CALLMONITOR 
b4ad cd b0 92			call break_point_state  
b4b0				endm  
# End of macro CALLMONITOR
b4b0					endif 
b4b0 cd 3d 98				call forth_push_numhl 
b4b3			 
b4b3				       NEXTW 
b4b3 c3 a6 9b			jp macro_next 
b4b6				endm 
# End of macro NEXTW
b4b6			 
b4b6			.mincont:  
b4b6 c1				pop bc   ; tidy up 
b4b7 eb				ex de , hl  
b4b8					if DEBUG_FORTH_WORDS 
b4b8						DMARK "MI1" 
b4b8 f5				push af  
b4b9 3a cd b4			ld a, (.dmark)  
b4bc 32 c0 ee			ld (debug_mark),a  
b4bf 3a ce b4			ld a, (.dmark+1)  
b4c2 32 c1 ee			ld (debug_mark+1),a  
b4c5 3a cf b4			ld a, (.dmark+2)  
b4c8 32 c2 ee			ld (debug_mark+2),a  
b4cb 18 03			jr .pastdmark  
b4cd ..			.dmark: db "MI1"  
b4d0 f1			.pastdmark: pop af  
b4d1			endm  
# End of macro DMARK
b4d1						CALLMONITOR 
b4d1 cd b0 92			call break_point_state  
b4d4				endm  
# End of macro CALLMONITOR
b4d4					endif 
b4d4 cd 3d 98				call forth_push_numhl 
b4d7			 
b4d7				       NEXTW 
b4d7 c3 a6 9b			jp macro_next 
b4da				endm 
# End of macro NEXTW
b4da			.MAX: 
b4da				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b4da 4a				db WORD_SYS_CORE+54             
b4db 5b b5			dw .RND16            
b4dd 04				db 3 + 1 
b4de .. 00			db "MAX",0              
b4e2				endm 
# End of macro CWHEAD
b4e2			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b4e2					if DEBUG_FORTH_WORDS_KEY 
b4e2						DMARK "MAX" 
b4e2 f5				push af  
b4e3 3a f7 b4			ld a, (.dmark)  
b4e6 32 c0 ee			ld (debug_mark),a  
b4e9 3a f8 b4			ld a, (.dmark+1)  
b4ec 32 c1 ee			ld (debug_mark+1),a  
b4ef 3a f9 b4			ld a, (.dmark+2)  
b4f2 32 c2 ee			ld (debug_mark+2),a  
b4f5 18 03			jr .pastdmark  
b4f7 ..			.dmark: db "MAX"  
b4fa f1			.pastdmark: pop af  
b4fb			endm  
# End of macro DMARK
b4fb						CALLMONITOR 
b4fb cd b0 92			call break_point_state  
b4fe				endm  
# End of macro CALLMONITOR
b4fe					endif 
b4fe					; get u2 
b4fe			 
b4fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4fe cd 34 9a			call macro_dsp_valuehl 
b501				endm 
# End of macro FORTH_DSP_VALUEHL
b501			 
b501 e5					push hl   ; u2 
b502			 
b502					; destroy value TOS 
b502			 
b502					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b502 cd ec 9a			call macro_forth_dsp_pop 
b505				endm 
# End of macro FORTH_DSP_POP
b505			 
b505					; get u1 
b505			 
b505					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b505 cd 34 9a			call macro_dsp_valuehl 
b508				endm 
# End of macro FORTH_DSP_VALUEHL
b508			 
b508 e5					push hl  ; u1 
b509			 
b509					; destroy value TOS 
b509			 
b509					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b509 cd ec 9a			call macro_forth_dsp_pop 
b50c				endm 
# End of macro FORTH_DSP_POP
b50c			 
b50c b7			 or a      ;clear carry flag 
b50d e1			  pop hl    ; u1 
b50e d1			  pop de    ; u2 
b50f e5				push hl   ; saved in case hl is lowest 
b510 ed 52		  sbc hl,de 
b512 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b514			 
b514 e1				pop hl 
b515					if DEBUG_FORTH_WORDS 
b515						DMARK "MAX" 
b515 f5				push af  
b516 3a 2a b5			ld a, (.dmark)  
b519 32 c0 ee			ld (debug_mark),a  
b51c 3a 2b b5			ld a, (.dmark+1)  
b51f 32 c1 ee			ld (debug_mark+1),a  
b522 3a 2c b5			ld a, (.dmark+2)  
b525 32 c2 ee			ld (debug_mark+2),a  
b528 18 03			jr .pastdmark  
b52a ..			.dmark: db "MAX"  
b52d f1			.pastdmark: pop af  
b52e			endm  
# End of macro DMARK
b52e						CALLMONITOR 
b52e cd b0 92			call break_point_state  
b531				endm  
# End of macro CALLMONITOR
b531					endif 
b531 cd 3d 98				call forth_push_numhl 
b534			 
b534				       NEXTW 
b534 c3 a6 9b			jp macro_next 
b537				endm 
# End of macro NEXTW
b537			 
b537			.maxcont:  
b537 c1				pop bc   ; tidy up 
b538 eb				ex de , hl  
b539					if DEBUG_FORTH_WORDS 
b539						DMARK "MA1" 
b539 f5				push af  
b53a 3a 4e b5			ld a, (.dmark)  
b53d 32 c0 ee			ld (debug_mark),a  
b540 3a 4f b5			ld a, (.dmark+1)  
b543 32 c1 ee			ld (debug_mark+1),a  
b546 3a 50 b5			ld a, (.dmark+2)  
b549 32 c2 ee			ld (debug_mark+2),a  
b54c 18 03			jr .pastdmark  
b54e ..			.dmark: db "MA1"  
b551 f1			.pastdmark: pop af  
b552			endm  
# End of macro DMARK
b552						CALLMONITOR 
b552 cd b0 92			call break_point_state  
b555				endm  
# End of macro CALLMONITOR
b555					endif 
b555 cd 3d 98				call forth_push_numhl 
b558				       NEXTW 
b558 c3 a6 9b			jp macro_next 
b55b				endm 
# End of macro NEXTW
b55b			 
b55b			.RND16: 
b55b				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b55b 4e				db WORD_SYS_CORE+58             
b55c 8a b5			dw .RND8            
b55e 06				db 5 + 1 
b55f .. 00			db "RND16",0              
b565				endm 
# End of macro CWHEAD
b565			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b565					if DEBUG_FORTH_WORDS_KEY 
b565						DMARK "R16" 
b565 f5				push af  
b566 3a 7a b5			ld a, (.dmark)  
b569 32 c0 ee			ld (debug_mark),a  
b56c 3a 7b b5			ld a, (.dmark+1)  
b56f 32 c1 ee			ld (debug_mark+1),a  
b572 3a 7c b5			ld a, (.dmark+2)  
b575 32 c2 ee			ld (debug_mark+2),a  
b578 18 03			jr .pastdmark  
b57a ..			.dmark: db "R16"  
b57d f1			.pastdmark: pop af  
b57e			endm  
# End of macro DMARK
b57e						CALLMONITOR 
b57e cd b0 92			call break_point_state  
b581				endm  
# End of macro CALLMONITOR
b581					endif 
b581 cd 90 89				call prng16  
b584 cd 3d 98				call forth_push_numhl 
b587				       NEXTW 
b587 c3 a6 9b			jp macro_next 
b58a				endm 
# End of macro NEXTW
b58a			.RND8: 
b58a				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b58a 60				db WORD_SYS_CORE+76             
b58b bf b5			dw .RND            
b58d 05				db 4 + 1 
b58e .. 00			db "RND8",0              
b593				endm 
# End of macro CWHEAD
b593			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b593					if DEBUG_FORTH_WORDS_KEY 
b593						DMARK "RN8" 
b593 f5				push af  
b594 3a a8 b5			ld a, (.dmark)  
b597 32 c0 ee			ld (debug_mark),a  
b59a 3a a9 b5			ld a, (.dmark+1)  
b59d 32 c1 ee			ld (debug_mark+1),a  
b5a0 3a aa b5			ld a, (.dmark+2)  
b5a3 32 c2 ee			ld (debug_mark+2),a  
b5a6 18 03			jr .pastdmark  
b5a8 ..			.dmark: db "RN8"  
b5ab f1			.pastdmark: pop af  
b5ac			endm  
# End of macro DMARK
b5ac						CALLMONITOR 
b5ac cd b0 92			call break_point_state  
b5af				endm  
# End of macro CALLMONITOR
b5af					endif 
b5af 2a 41 ed				ld hl,(xrandc) 
b5b2 23					inc hl 
b5b3 cd aa 89				call xrnd 
b5b6 6f					ld l,a	 
b5b7 26 00				ld h,0 
b5b9 cd 3d 98				call forth_push_numhl 
b5bc				       NEXTW 
b5bc c3 a6 9b			jp macro_next 
b5bf				endm 
# End of macro NEXTW
b5bf			.RND: 
b5bf				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b5bf 60				db WORD_SYS_CORE+76             
b5c0 c5 b6			dw .ENDMATHS            
b5c2 04				db 3 + 1 
b5c3 .. 00			db "RND",0              
b5c7				endm 
# End of macro CWHEAD
b5c7			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b5c7			 
b5c7					if DEBUG_FORTH_WORDS_KEY 
b5c7						DMARK "RND" 
b5c7 f5				push af  
b5c8 3a dc b5			ld a, (.dmark)  
b5cb 32 c0 ee			ld (debug_mark),a  
b5ce 3a dd b5			ld a, (.dmark+1)  
b5d1 32 c1 ee			ld (debug_mark+1),a  
b5d4 3a de b5			ld a, (.dmark+2)  
b5d7 32 c2 ee			ld (debug_mark+2),a  
b5da 18 03			jr .pastdmark  
b5dc ..			.dmark: db "RND"  
b5df f1			.pastdmark: pop af  
b5e0			endm  
# End of macro DMARK
b5e0						CALLMONITOR 
b5e0 cd b0 92			call break_point_state  
b5e3				endm  
# End of macro CALLMONITOR
b5e3					endif 
b5e3					 
b5e3					FORTH_DSP_VALUEHL    ; upper range 
b5e3 cd 34 9a			call macro_dsp_valuehl 
b5e6				endm 
# End of macro FORTH_DSP_VALUEHL
b5e6			 
b5e6 22 45 ed				ld (LFSRSeed), hl	 
b5e9			 
b5e9					if DEBUG_FORTH_WORDS 
b5e9						DMARK "RN1" 
b5e9 f5				push af  
b5ea 3a fe b5			ld a, (.dmark)  
b5ed 32 c0 ee			ld (debug_mark),a  
b5f0 3a ff b5			ld a, (.dmark+1)  
b5f3 32 c1 ee			ld (debug_mark+1),a  
b5f6 3a 00 b6			ld a, (.dmark+2)  
b5f9 32 c2 ee			ld (debug_mark+2),a  
b5fc 18 03			jr .pastdmark  
b5fe ..			.dmark: db "RN1"  
b601 f1			.pastdmark: pop af  
b602			endm  
# End of macro DMARK
b602						CALLMONITOR 
b602 cd b0 92			call break_point_state  
b605				endm  
# End of macro CALLMONITOR
b605					endif 
b605					FORTH_DSP_POP 
b605 cd ec 9a			call macro_forth_dsp_pop 
b608				endm 
# End of macro FORTH_DSP_POP
b608			 
b608					FORTH_DSP_VALUEHL    ; low range 
b608 cd 34 9a			call macro_dsp_valuehl 
b60b				endm 
# End of macro FORTH_DSP_VALUEHL
b60b			 
b60b					if DEBUG_FORTH_WORDS 
b60b						DMARK "RN2" 
b60b f5				push af  
b60c 3a 20 b6			ld a, (.dmark)  
b60f 32 c0 ee			ld (debug_mark),a  
b612 3a 21 b6			ld a, (.dmark+1)  
b615 32 c1 ee			ld (debug_mark+1),a  
b618 3a 22 b6			ld a, (.dmark+2)  
b61b 32 c2 ee			ld (debug_mark+2),a  
b61e 18 03			jr .pastdmark  
b620 ..			.dmark: db "RN2"  
b623 f1			.pastdmark: pop af  
b624			endm  
# End of macro DMARK
b624						CALLMONITOR 
b624 cd b0 92			call break_point_state  
b627				endm  
# End of macro CALLMONITOR
b627					endif 
b627 22 47 ed				ld (LFSRSeed+2), hl 
b62a			 
b62a					FORTH_DSP_POP 
b62a cd ec 9a			call macro_forth_dsp_pop 
b62d				endm 
# End of macro FORTH_DSP_POP
b62d			 
b62d e5					push hl 
b62e			 
b62e e1			.inrange:	pop hl 
b62f cd 90 89				call prng16  
b632					if DEBUG_FORTH_WORDS 
b632						DMARK "RN3" 
b632 f5				push af  
b633 3a 47 b6			ld a, (.dmark)  
b636 32 c0 ee			ld (debug_mark),a  
b639 3a 48 b6			ld a, (.dmark+1)  
b63c 32 c1 ee			ld (debug_mark+1),a  
b63f 3a 49 b6			ld a, (.dmark+2)  
b642 32 c2 ee			ld (debug_mark+2),a  
b645 18 03			jr .pastdmark  
b647 ..			.dmark: db "RN3"  
b64a f1			.pastdmark: pop af  
b64b			endm  
# End of macro DMARK
b64b						CALLMONITOR 
b64b cd b0 92			call break_point_state  
b64e				endm  
# End of macro CALLMONITOR
b64e					endif 
b64e					 
b64e					; if the range is 8bit knock out the high byte 
b64e			 
b64e ed 5b 45 ed			ld de, (LFSRSeed)     ; check high level 
b652			 
b652 3e 00				ld a, 0 
b654 ba					cp d  
b655 20 1e				jr nz, .hirange 
b657 26 00				ld h, 0   ; knock it down to 8bit 
b659			 
b659					if DEBUG_FORTH_WORDS 
b659						DMARK "RNk" 
b659 f5				push af  
b65a 3a 6e b6			ld a, (.dmark)  
b65d 32 c0 ee			ld (debug_mark),a  
b660 3a 6f b6			ld a, (.dmark+1)  
b663 32 c1 ee			ld (debug_mark+1),a  
b666 3a 70 b6			ld a, (.dmark+2)  
b669 32 c2 ee			ld (debug_mark+2),a  
b66c 18 03			jr .pastdmark  
b66e ..			.dmark: db "RNk"  
b671 f1			.pastdmark: pop af  
b672			endm  
# End of macro DMARK
b672						CALLMONITOR 
b672 cd b0 92			call break_point_state  
b675				endm  
# End of macro CALLMONITOR
b675					endif 
b675			.hirange:   
b675 e5					push hl  
b676 b7					or a  
b677 ed 52		                sbc hl, de 
b679			 
b679					;call cmp16 
b679			 
b679 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b67b e1					pop hl 
b67c e5					push hl 
b67d			 
b67d					if DEBUG_FORTH_WORDS 
b67d						DMARK "RN4" 
b67d f5				push af  
b67e 3a 92 b6			ld a, (.dmark)  
b681 32 c0 ee			ld (debug_mark),a  
b684 3a 93 b6			ld a, (.dmark+1)  
b687 32 c1 ee			ld (debug_mark+1),a  
b68a 3a 94 b6			ld a, (.dmark+2)  
b68d 32 c2 ee			ld (debug_mark+2),a  
b690 18 03			jr .pastdmark  
b692 ..			.dmark: db "RN4"  
b695 f1			.pastdmark: pop af  
b696			endm  
# End of macro DMARK
b696						CALLMONITOR 
b696 cd b0 92			call break_point_state  
b699				endm  
# End of macro CALLMONITOR
b699					endif 
b699 ed 5b 47 ed			ld de, (LFSRSeed+2)   ; check low range 
b69d					;call cmp16 
b69d				 
b69d b7					or a  
b69e ed 52		                sbc hl, de 
b6a0 38 8c				jr c, .inrange 
b6a2			 
b6a2 e1					pop hl 
b6a3					 
b6a3					if DEBUG_FORTH_WORDS 
b6a3						DMARK "RNd" 
b6a3 f5				push af  
b6a4 3a b8 b6			ld a, (.dmark)  
b6a7 32 c0 ee			ld (debug_mark),a  
b6aa 3a b9 b6			ld a, (.dmark+1)  
b6ad 32 c1 ee			ld (debug_mark+1),a  
b6b0 3a ba b6			ld a, (.dmark+2)  
b6b3 32 c2 ee			ld (debug_mark+2),a  
b6b6 18 03			jr .pastdmark  
b6b8 ..			.dmark: db "RNd"  
b6bb f1			.pastdmark: pop af  
b6bc			endm  
# End of macro DMARK
b6bc						CALLMONITOR 
b6bc cd b0 92			call break_point_state  
b6bf				endm  
# End of macro CALLMONITOR
b6bf					endif 
b6bf			 
b6bf			 
b6bf cd 3d 98				call forth_push_numhl 
b6c2				       NEXTW 
b6c2 c3 a6 9b			jp macro_next 
b6c5				endm 
# End of macro NEXTW
b6c5			 
b6c5			.ENDMATHS: 
b6c5			 
b6c5			; eof 
b6c5			 
# End of file forth_words_maths.asm
b6c5			include "forth_words_display.asm" 
b6c5			 
b6c5			; | ## Display Words 
b6c5			 
b6c5			.ATP: 
b6c5				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b6c5 62				db WORD_SYS_CORE+78             
b6c6 3c b7			dw .FB            
b6c8 04				db 3 + 1 
b6c9 .. 00			db "AT?",0              
b6cd				endm 
# End of macro CWHEAD
b6cd			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b6cd					if DEBUG_FORTH_WORDS_KEY 
b6cd						DMARK "AT?" 
b6cd f5				push af  
b6ce 3a e2 b6			ld a, (.dmark)  
b6d1 32 c0 ee			ld (debug_mark),a  
b6d4 3a e3 b6			ld a, (.dmark+1)  
b6d7 32 c1 ee			ld (debug_mark+1),a  
b6da 3a e4 b6			ld a, (.dmark+2)  
b6dd 32 c2 ee			ld (debug_mark+2),a  
b6e0 18 03			jr .pastdmark  
b6e2 ..			.dmark: db "AT?"  
b6e5 f1			.pastdmark: pop af  
b6e6			endm  
# End of macro DMARK
b6e6						CALLMONITOR 
b6e6 cd b0 92			call break_point_state  
b6e9				endm  
# End of macro CALLMONITOR
b6e9					endif 
b6e9 3a cf ec				ld a, (f_cursor_ptr) 
b6ec			 
b6ec			if DEBUG_FORTH_WORDS 
b6ec				DMARK "AT?" 
b6ec f5				push af  
b6ed 3a 01 b7			ld a, (.dmark)  
b6f0 32 c0 ee			ld (debug_mark),a  
b6f3 3a 02 b7			ld a, (.dmark+1)  
b6f6 32 c1 ee			ld (debug_mark+1),a  
b6f9 3a 03 b7			ld a, (.dmark+2)  
b6fc 32 c2 ee			ld (debug_mark+2),a  
b6ff 18 03			jr .pastdmark  
b701 ..			.dmark: db "AT?"  
b704 f1			.pastdmark: pop af  
b705			endm  
# End of macro DMARK
b705				CALLMONITOR 
b705 cd b0 92			call break_point_state  
b708				endm  
# End of macro CALLMONITOR
b708			endif	 
b708					; count the number of rows 
b708			 
b708 06 00				ld b, 0 
b70a 4f			.atpr:		ld c, a    ; save in case we go below zero 
b70b d6 14				sub display_cols 
b70d f2 13 b7				jp p, .atprunder 
b710 04					inc b 
b711 18 f7				jr .atpr 
b713			.atprunder:	 
b713			if DEBUG_FORTH_WORDS 
b713				DMARK "A?2" 
b713 f5				push af  
b714 3a 28 b7			ld a, (.dmark)  
b717 32 c0 ee			ld (debug_mark),a  
b71a 3a 29 b7			ld a, (.dmark+1)  
b71d 32 c1 ee			ld (debug_mark+1),a  
b720 3a 2a b7			ld a, (.dmark+2)  
b723 32 c2 ee			ld (debug_mark+2),a  
b726 18 03			jr .pastdmark  
b728 ..			.dmark: db "A?2"  
b72b f1			.pastdmark: pop af  
b72c			endm  
# End of macro DMARK
b72c				CALLMONITOR 
b72c cd b0 92			call break_point_state  
b72f				endm  
# End of macro CALLMONITOR
b72f			endif	 
b72f 26 00				ld h, 0 
b731 69					ld l, c 
b732 cd 3d 98				call forth_push_numhl 
b735 68					ld l, b  
b736 cd 3d 98				call forth_push_numhl 
b739			 
b739			 
b739				NEXTW 
b739 c3 a6 9b			jp macro_next 
b73c				endm 
# End of macro NEXTW
b73c			 
b73c			.FB: 
b73c				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b73c 1b				db WORD_SYS_CORE+7             
b73d 8a b7			dw .EMIT            
b73f 03				db 2 + 1 
b740 .. 00			db "FB",0              
b743				endm 
# End of macro CWHEAD
b743			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b743			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b743			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b743			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b743					if DEBUG_FORTH_WORDS_KEY 
b743						DMARK "FB." 
b743 f5				push af  
b744 3a 58 b7			ld a, (.dmark)  
b747 32 c0 ee			ld (debug_mark),a  
b74a 3a 59 b7			ld a, (.dmark+1)  
b74d 32 c1 ee			ld (debug_mark+1),a  
b750 3a 5a b7			ld a, (.dmark+2)  
b753 32 c2 ee			ld (debug_mark+2),a  
b756 18 03			jr .pastdmark  
b758 ..			.dmark: db "FB."  
b75b f1			.pastdmark: pop af  
b75c			endm  
# End of macro DMARK
b75c						CALLMONITOR 
b75c cd b0 92			call break_point_state  
b75f				endm  
# End of macro CALLMONITOR
b75f					endif 
b75f			 
b75f					FORTH_DSP_VALUEHL 
b75f cd 34 9a			call macro_dsp_valuehl 
b762				endm 
# End of macro FORTH_DSP_VALUEHL
b762			 
b762 7d					ld a, l 
b763 fe 01				cp 1 
b765 20 05				jr nz, .fbn1 
b767 21 05 ee				ld hl, display_fb1 
b76a 18 15				jr .fbset 
b76c fe 02		.fbn1:		cp 2 
b76e 20 05				jr nz, .fbn2 
b770 21 63 ed				ld hl, display_fb2 
b773 18 0c				jr .fbset 
b775 fe 03		.fbn2:		cp 3 
b777 20 05				jr nz, .fbn3 
b779 21 b4 ed				ld hl, display_fb3 
b77c 18 03				jr .fbset 
b77e			.fbn3:		 ; if invalid number select first 
b77e 21 05 ee				ld hl, display_fb1 
b781 22 61 ed		.fbset:		ld (display_fb_active), hl 
b784			 
b784					FORTH_DSP_POP 
b784 cd ec 9a			call macro_forth_dsp_pop 
b787				endm 
# End of macro FORTH_DSP_POP
b787			 
b787					NEXTW 
b787 c3 a6 9b			jp macro_next 
b78a				endm 
# End of macro NEXTW
b78a			 
b78a			 
b78a			.EMIT: 
b78a				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b78a 1b				db WORD_SYS_CORE+7             
b78b db b7			dw .DOTH            
b78d 05				db 4 + 1 
b78e .. 00			db "EMIT",0              
b793				endm 
# End of macro CWHEAD
b793			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b793					; get value off TOS and display it 
b793			 
b793					if DEBUG_FORTH_WORDS_KEY 
b793						DMARK "EMT" 
b793 f5				push af  
b794 3a a8 b7			ld a, (.dmark)  
b797 32 c0 ee			ld (debug_mark),a  
b79a 3a a9 b7			ld a, (.dmark+1)  
b79d 32 c1 ee			ld (debug_mark+1),a  
b7a0 3a aa b7			ld a, (.dmark+2)  
b7a3 32 c2 ee			ld (debug_mark+2),a  
b7a6 18 03			jr .pastdmark  
b7a8 ..			.dmark: db "EMT"  
b7ab f1			.pastdmark: pop af  
b7ac			endm  
# End of macro DMARK
b7ac						CALLMONITOR 
b7ac cd b0 92			call break_point_state  
b7af				endm  
# End of macro CALLMONITOR
b7af					endif 
b7af			 
b7af					FORTH_DSP_VALUEHL 
b7af cd 34 9a			call macro_dsp_valuehl 
b7b2				endm 
# End of macro FORTH_DSP_VALUEHL
b7b2			 
b7b2 7d					ld a,l 
b7b3			 
b7b3					; TODO write to display 
b7b3			 
b7b3 32 e4 e6				ld (os_input), a 
b7b6 3e 00				ld a, 0 
b7b8 32 e5 e6				ld (os_input+1), a 
b7bb					 
b7bb 3a cf ec				ld a, (f_cursor_ptr) 
b7be 11 e4 e6				ld de, os_input 
b7c1 cd 4f 88				call str_at_display 
b7c4			 
b7c4			 
b7c4 3a ad ec				ld a,(cli_autodisplay) 
b7c7 fe 00				cp 0 
b7c9 28 03				jr z, .enoupdate 
b7cb cd 5f 88						call update_display 
b7ce					.enoupdate: 
b7ce			 
b7ce 3a cf ec				ld a, (f_cursor_ptr) 
b7d1 3c					inc a 
b7d2 32 cf ec				ld (f_cursor_ptr), a   ; save new pos 
b7d5			 
b7d5			 
b7d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7d5 cd ec 9a			call macro_forth_dsp_pop 
b7d8				endm 
# End of macro FORTH_DSP_POP
b7d8			  
b7d8			 
b7d8					NEXTW 
b7d8 c3 a6 9b			jp macro_next 
b7db				endm 
# End of macro NEXTW
b7db			.DOTH: 
b7db				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b7db 1c				db WORD_SYS_CORE+8             
b7dc 0b b8			dw .DOTF            
b7de 03				db 2 + 1 
b7df .. 00			db ".-",0              
b7e2				endm 
# End of macro CWHEAD
b7e2			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b7e2					; get value off TOS and display it 
b7e2					if DEBUG_FORTH_WORDS_KEY 
b7e2						DMARK "DTD" 
b7e2 f5				push af  
b7e3 3a f7 b7			ld a, (.dmark)  
b7e6 32 c0 ee			ld (debug_mark),a  
b7e9 3a f8 b7			ld a, (.dmark+1)  
b7ec 32 c1 ee			ld (debug_mark+1),a  
b7ef 3a f9 b7			ld a, (.dmark+2)  
b7f2 32 c2 ee			ld (debug_mark+2),a  
b7f5 18 03			jr .pastdmark  
b7f7 ..			.dmark: db "DTD"  
b7fa f1			.pastdmark: pop af  
b7fb			endm  
# End of macro DMARK
b7fb						CALLMONITOR 
b7fb cd b0 92			call break_point_state  
b7fe				endm  
# End of macro CALLMONITOR
b7fe					endif 
b7fe 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b800 3e 00			ld a, 0 
b802 32 ae ec			ld (cli_mvdot), a 
b805 c3 62 b8			jp .dotgo 
b808				NEXTW 
b808 c3 a6 9b			jp macro_next 
b80b				endm 
# End of macro NEXTW
b80b			.DOTF: 
b80b				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b80b 1c				db WORD_SYS_CORE+8             
b80c 39 b8			dw .DOT            
b80e 03				db 2 + 1 
b80f .. 00			db ".>",0              
b812				endm 
# End of macro CWHEAD
b812			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b812					; get value off TOS and display it 
b812			        ; TODO BUG adds extra spaces 
b812			        ; TODO BUG handle numerics? 
b812					if DEBUG_FORTH_WORDS_KEY 
b812						DMARK "DTC" 
b812 f5				push af  
b813 3a 27 b8			ld a, (.dmark)  
b816 32 c0 ee			ld (debug_mark),a  
b819 3a 28 b8			ld a, (.dmark+1)  
b81c 32 c1 ee			ld (debug_mark+1),a  
b81f 3a 29 b8			ld a, (.dmark+2)  
b822 32 c2 ee			ld (debug_mark+2),a  
b825 18 03			jr .pastdmark  
b827 ..			.dmark: db "DTC"  
b82a f1			.pastdmark: pop af  
b82b			endm  
# End of macro DMARK
b82b						CALLMONITOR 
b82b cd b0 92			call break_point_state  
b82e				endm  
# End of macro CALLMONITOR
b82e					endif 
b82e 3e 01			ld a, 1 
b830 32 ae ec			ld (cli_mvdot), a 
b833 c3 62 b8			jp .dotgo 
b836				NEXTW 
b836 c3 a6 9b			jp macro_next 
b839				endm 
# End of macro NEXTW
b839			 
b839			.DOT: 
b839				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b839 1c				db WORD_SYS_CORE+8             
b83a c5 b8			dw .CLS            
b83c 02				db 1 + 1 
b83d .. 00			db ".",0              
b83f				endm 
# End of macro CWHEAD
b83f			        ; | . ( u -- ) Display TOS | DONE 
b83f					; get value off TOS and display it 
b83f			 
b83f					if DEBUG_FORTH_WORDS_KEY 
b83f						DMARK "DOT" 
b83f f5				push af  
b840 3a 54 b8			ld a, (.dmark)  
b843 32 c0 ee			ld (debug_mark),a  
b846 3a 55 b8			ld a, (.dmark+1)  
b849 32 c1 ee			ld (debug_mark+1),a  
b84c 3a 56 b8			ld a, (.dmark+2)  
b84f 32 c2 ee			ld (debug_mark+2),a  
b852 18 03			jr .pastdmark  
b854 ..			.dmark: db "DOT"  
b857 f1			.pastdmark: pop af  
b858			endm  
# End of macro DMARK
b858						CALLMONITOR 
b858 cd b0 92			call break_point_state  
b85b				endm  
# End of macro CALLMONITOR
b85b					endif 
b85b 3e 00			ld a, 0 
b85d 32 ae ec			ld (cli_mvdot), a 
b860 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b862				 
b862			 
b862			.dotgo: 
b862			 
b862			; move up type to on stack for parserv5 
b862					FORTH_DSP 
b862 cd fa 99			call macro_forth_dsp 
b865				endm 
# End of macro FORTH_DSP
b865				;FORTH_DSP_VALUE  
b865			 
b865			if DEBUG_FORTH_DOT 
b865				DMARK "DOT" 
b865				CALLMONITOR 
b865			endif	 
b865			;		.print: 
b865			 
b865 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b866 23				inc hl   ; position to the actual value 
b867 fe 01			cp DS_TYPE_STR 
b869 20 06			jr nz, .dotnum1  
b86b			 
b86b			; display string 
b86b				FORTH_DSP_VALUE  
b86b cd 1d 9a			call macro_forth_dsp_value 
b86e				endm 
# End of macro FORTH_DSP_VALUE
b86e eb				ex de,hl 
b86f 18 11			jr .dotwrite 
b871			 
b871			.dotnum1: 
b871 fe 02			cp DS_TYPE_INUM 
b873 20 0c			jr nz, .dotflot 
b875			 
b875			 
b875			; display number 
b875			 
b875			;	push hl 
b875			;	call clear_display 
b875			;	pop hl 
b875			 
b875 5e				ld e, (hl) 
b876 23				inc hl 
b877 56				ld d, (hl) 
b878 21 e6 e4			ld hl, scratch 
b87b			if DEBUG_FORTH_DOT 
b87b				DMARK "DT1" 
b87b				CALLMONITOR 
b87b			endif	 
b87b			 
b87b cd 76 8e			call uitoa_16 
b87e eb				ex de,hl 
b87f			 
b87f			if DEBUG_FORTH_DOT 
b87f				DMARK "DT2" 
b87f				CALLMONITOR 
b87f			endif	 
b87f			 
b87f			;	ld de, os_word_scratch 
b87f 18 01			jr .dotwrite 
b881			 
b881 00			.dotflot:   nop 
b882			; TODO print floating point number 
b882			 
b882			.dotwrite:		 
b882			 
b882					; if c is set then set all '-' to spaces 
b882					; need to also take into account .>  
b882			 
b882 3e 01				ld a, 1 
b884 b9					cp c 
b885 20 13				jr nz, .nodashswap 
b887			 
b887					; DE has the string to write, working with HL 
b887			 
b887 06 ff				ld b, 255 
b889 d5					push de 
b88a e1					pop hl 
b88b			 
b88b			if DEBUG_FORTH_DOT 
b88b				DMARK "DT-" 
b88b				CALLMONITOR 
b88b			endif	 
b88b 7e			.dashscan:	ld a, (hl) 
b88c fe 00				cp 0 
b88e 28 0a				jr z, .nodashswap 
b890 fe 2d				cp '-' 
b892 20 03				jr nz, .dashskip 
b894 3e 20				ld a, ' ' 
b896 77					ld (hl), a 
b897 23			.dashskip:	inc hl 
b898			if DEBUG_FORTH_DOT 
b898				DMARK "D-2" 
b898				CALLMONITOR 
b898			endif	 
b898 10 f1				djnz .dashscan 
b89a			 
b89a			if DEBUG_FORTH_DOT 
b89a				DMARK "D-1" 
b89a				CALLMONITOR 
b89a			endif	 
b89a			 
b89a			.nodashswap: 
b89a			 
b89a e5					push hl   ; save string start in case we need to advance print 
b89b			 
b89b 3a cf ec				ld a, (f_cursor_ptr) 
b89e cd 4f 88				call str_at_display 
b8a1 3a ad ec				ld a,(cli_autodisplay) 
b8a4 fe 00				cp 0 
b8a6 28 03				jr z, .noupdate 
b8a8 cd 5f 88						call update_display 
b8ab					.noupdate: 
b8ab			 
b8ab			 
b8ab					; see if we need to advance the print position 
b8ab			 
b8ab e1					pop hl   ; get back string 
b8ac			 
b8ac 3a ae ec				ld a, (cli_mvdot) 
b8af			if DEBUG_FORTH_DOT 
b8af					ld e,a 
b8af				DMARK "D>1" 
b8af				CALLMONITOR 
b8af			endif	 
b8af fe 00				cp 0 
b8b1 28 0c				jr z, .noadv 
b8b3					; yes, lets advance the print position 
b8b3 3e 00				ld a, 0 
b8b5 cd d2 8e				call strlent 
b8b8 3a cf ec				ld a, (f_cursor_ptr) 
b8bb 85					add a,l 
b8bc					;call addatohl 
b8bc					;ld a, l 
b8bc 32 cf ec				ld (f_cursor_ptr), a   ; save new pos 
b8bf			 
b8bf			if DEBUG_FORTH_DOT 
b8bf				DMARK "D->" 
b8bf				CALLMONITOR 
b8bf			endif	 
b8bf			 
b8bf			.noadv:	 
b8bf			 
b8bf					if DEBUG_FORTH_DOT_WAIT 
b8bf							call next_page_prompt 
b8bf					endif	 
b8bf			; TODO this pop off the stack causes a crash. i dont know why 
b8bf			 
b8bf			 
b8bf			if DEBUG_FORTH_DOT 
b8bf				DMARK "DTh" 
b8bf				CALLMONITOR 
b8bf			endif	 
b8bf			 
b8bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8bf cd ec 9a			call macro_forth_dsp_pop 
b8c2				endm 
# End of macro FORTH_DSP_POP
b8c2			 
b8c2			if DEBUG_FORTH_DOT 
b8c2				DMARK "DTi" 
b8c2				CALLMONITOR 
b8c2			endif	 
b8c2			 
b8c2			 
b8c2					NEXTW 
b8c2 c3 a6 9b			jp macro_next 
b8c5				endm 
# End of macro NEXTW
b8c5			 
b8c5			.CLS: 
b8c5				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b8c5 35				db WORD_SYS_CORE+33             
b8c6 f2 b8			dw .DRAW            
b8c8 04				db 3 + 1 
b8c9 .. 00			db "CLS",0              
b8cd				endm 
# End of macro CWHEAD
b8cd			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b8cd					if DEBUG_FORTH_WORDS_KEY 
b8cd						DMARK "CLS" 
b8cd f5				push af  
b8ce 3a e2 b8			ld a, (.dmark)  
b8d1 32 c0 ee			ld (debug_mark),a  
b8d4 3a e3 b8			ld a, (.dmark+1)  
b8d7 32 c1 ee			ld (debug_mark+1),a  
b8da 3a e4 b8			ld a, (.dmark+2)  
b8dd 32 c2 ee			ld (debug_mark+2),a  
b8e0 18 03			jr .pastdmark  
b8e2 ..			.dmark: db "CLS"  
b8e5 f1			.pastdmark: pop af  
b8e6			endm  
# End of macro DMARK
b8e6						CALLMONITOR 
b8e6 cd b0 92			call break_point_state  
b8e9				endm  
# End of macro CALLMONITOR
b8e9					endif 
b8e9 cd 3c 88				call clear_display 
b8ec c3 00 ba				jp .home		; and home cursor 
b8ef					NEXTW 
b8ef c3 a6 9b			jp macro_next 
b8f2				endm 
# End of macro NEXTW
b8f2			 
b8f2			.DRAW: 
b8f2				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b8f2 36				db WORD_SYS_CORE+34             
b8f3 1d b9			dw .DUMP            
b8f5 05				db 4 + 1 
b8f6 .. 00			db "DRAW",0              
b8fb				endm 
# End of macro CWHEAD
b8fb			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b8fb					if DEBUG_FORTH_WORDS_KEY 
b8fb						DMARK "DRW" 
b8fb f5				push af  
b8fc 3a 10 b9			ld a, (.dmark)  
b8ff 32 c0 ee			ld (debug_mark),a  
b902 3a 11 b9			ld a, (.dmark+1)  
b905 32 c1 ee			ld (debug_mark+1),a  
b908 3a 12 b9			ld a, (.dmark+2)  
b90b 32 c2 ee			ld (debug_mark+2),a  
b90e 18 03			jr .pastdmark  
b910 ..			.dmark: db "DRW"  
b913 f1			.pastdmark: pop af  
b914			endm  
# End of macro DMARK
b914						CALLMONITOR 
b914 cd b0 92			call break_point_state  
b917				endm  
# End of macro CALLMONITOR
b917					endif 
b917 cd 5f 88				call update_display 
b91a					NEXTW 
b91a c3 a6 9b			jp macro_next 
b91d				endm 
# End of macro NEXTW
b91d			 
b91d			.DUMP: 
b91d				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b91d 37				db WORD_SYS_CORE+35             
b91e 55 b9			dw .CDUMP            
b920 05				db 4 + 1 
b921 .. 00			db "DUMP",0              
b926				endm 
# End of macro CWHEAD
b926			; | DUMP ( x -- ) With address x display dump   | DONE 
b926			; TODO pop address to use off of the stack 
b926					if DEBUG_FORTH_WORDS_KEY 
b926						DMARK "DUM" 
b926 f5				push af  
b927 3a 3b b9			ld a, (.dmark)  
b92a 32 c0 ee			ld (debug_mark),a  
b92d 3a 3c b9			ld a, (.dmark+1)  
b930 32 c1 ee			ld (debug_mark+1),a  
b933 3a 3d b9			ld a, (.dmark+2)  
b936 32 c2 ee			ld (debug_mark+2),a  
b939 18 03			jr .pastdmark  
b93b ..			.dmark: db "DUM"  
b93e f1			.pastdmark: pop af  
b93f			endm  
# End of macro DMARK
b93f						CALLMONITOR 
b93f cd b0 92			call break_point_state  
b942				endm  
# End of macro CALLMONITOR
b942					endif 
b942 cd 3c 88				call clear_display 
b945			 
b945					; get address 
b945			 
b945					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b945 cd 34 9a			call macro_dsp_valuehl 
b948				endm 
# End of macro FORTH_DSP_VALUEHL
b948				 
b948					; save it for cdump 
b948			 
b948 22 09 e8				ld (os_cur_ptr),hl 
b94b			 
b94b					; destroy value TOS 
b94b			 
b94b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b94b cd ec 9a			call macro_forth_dsp_pop 
b94e				endm 
# End of macro FORTH_DSP_POP
b94e			 
b94e cd bd 96				call dumpcont	; skip old style of param parsing	 
b951 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b952					NEXTW 
b952 c3 a6 9b			jp macro_next 
b955				endm 
# End of macro NEXTW
b955			.CDUMP: 
b955				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b955 38				db WORD_SYS_CORE+36             
b956 85 b9			dw .DAT            
b958 06				db 5 + 1 
b959 .. 00			db "CDUMP",0              
b95f				endm 
# End of macro CWHEAD
b95f			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b95f					if DEBUG_FORTH_WORDS_KEY 
b95f						DMARK "CDP" 
b95f f5				push af  
b960 3a 74 b9			ld a, (.dmark)  
b963 32 c0 ee			ld (debug_mark),a  
b966 3a 75 b9			ld a, (.dmark+1)  
b969 32 c1 ee			ld (debug_mark+1),a  
b96c 3a 76 b9			ld a, (.dmark+2)  
b96f 32 c2 ee			ld (debug_mark+2),a  
b972 18 03			jr .pastdmark  
b974 ..			.dmark: db "CDP"  
b977 f1			.pastdmark: pop af  
b978			endm  
# End of macro DMARK
b978						CALLMONITOR 
b978 cd b0 92			call break_point_state  
b97b				endm  
# End of macro CALLMONITOR
b97b					endif 
b97b cd 3c 88				call clear_display 
b97e cd bd 96				call dumpcont	 
b981 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b982					NEXTW 
b982 c3 a6 9b			jp macro_next 
b985				endm 
# End of macro NEXTW
b985			 
b985			 
b985			 
b985			 
b985			.DAT: 
b985				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b985 3d				db WORD_SYS_CORE+41             
b986 db b9			dw .HOME            
b988 03				db 2 + 1 
b989 .. 00			db "AT",0              
b98c				endm 
# End of macro CWHEAD
b98c			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b98c					if DEBUG_FORTH_WORDS_KEY 
b98c						DMARK "AT." 
b98c f5				push af  
b98d 3a a1 b9			ld a, (.dmark)  
b990 32 c0 ee			ld (debug_mark),a  
b993 3a a2 b9			ld a, (.dmark+1)  
b996 32 c1 ee			ld (debug_mark+1),a  
b999 3a a3 b9			ld a, (.dmark+2)  
b99c 32 c2 ee			ld (debug_mark+2),a  
b99f 18 03			jr .pastdmark  
b9a1 ..			.dmark: db "AT."  
b9a4 f1			.pastdmark: pop af  
b9a5			endm  
# End of macro DMARK
b9a5						CALLMONITOR 
b9a5 cd b0 92			call break_point_state  
b9a8				endm  
# End of macro CALLMONITOR
b9a8					endif 
b9a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9a8 cd 34 9a			call macro_dsp_valuehl 
b9ab				endm 
# End of macro FORTH_DSP_VALUEHL
b9ab			 
b9ab			 
b9ab					; TODO save cursor row 
b9ab 7d					ld a,l 
b9ac fe 02				cp 2 
b9ae 20 04				jr nz, .crow3 
b9b0 3e 14				ld a, display_row_2 
b9b2 18 12				jr .ccol1 
b9b4 fe 03		.crow3:		cp 3 
b9b6 20 04				jr nz, .crow4 
b9b8 3e 28				ld a, display_row_3 
b9ba 18 0a				jr .ccol1 
b9bc fe 04		.crow4:		cp 4 
b9be 20 04				jr nz, .crow1 
b9c0 3e 3c				ld a, display_row_4 
b9c2 18 02				jr .ccol1 
b9c4 3e 00		.crow1:		ld a,display_row_1 
b9c6 f5			.ccol1:		push af			; got row offset 
b9c7 6f					ld l,a 
b9c8 26 00				ld h,0 
b9ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9ca cd ec 9a			call macro_forth_dsp_pop 
b9cd				endm 
# End of macro FORTH_DSP_POP
b9cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9cd cd 34 9a			call macro_dsp_valuehl 
b9d0				endm 
# End of macro FORTH_DSP_VALUEHL
b9d0					; TODO save cursor col 
b9d0 f1					pop af 
b9d1 85					add l		; add col offset 
b9d2 32 cf ec				ld (f_cursor_ptr), a 
b9d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9d5 cd ec 9a			call macro_forth_dsp_pop 
b9d8				endm 
# End of macro FORTH_DSP_POP
b9d8			 
b9d8					; calculate  
b9d8			 
b9d8					NEXTW 
b9d8 c3 a6 9b			jp macro_next 
b9db				endm 
# End of macro NEXTW
b9db			 
b9db			 
b9db			.HOME: 
b9db				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b9db 41				db WORD_SYS_CORE+45             
b9dc 08 ba			dw .SPACE            
b9de 05				db 4 + 1 
b9df .. 00			db "HOME",0              
b9e4				endm 
# End of macro CWHEAD
b9e4			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b9e4					if DEBUG_FORTH_WORDS_KEY 
b9e4						DMARK "HOM" 
b9e4 f5				push af  
b9e5 3a f9 b9			ld a, (.dmark)  
b9e8 32 c0 ee			ld (debug_mark),a  
b9eb 3a fa b9			ld a, (.dmark+1)  
b9ee 32 c1 ee			ld (debug_mark+1),a  
b9f1 3a fb b9			ld a, (.dmark+2)  
b9f4 32 c2 ee			ld (debug_mark+2),a  
b9f7 18 03			jr .pastdmark  
b9f9 ..			.dmark: db "HOM"  
b9fc f1			.pastdmark: pop af  
b9fd			endm  
# End of macro DMARK
b9fd						CALLMONITOR 
b9fd cd b0 92			call break_point_state  
ba00				endm  
# End of macro CALLMONITOR
ba00					endif 
ba00 3e 00		.home:		ld a, 0		; and home cursor 
ba02 32 cf ec				ld (f_cursor_ptr), a 
ba05					NEXTW 
ba05 c3 a6 9b			jp macro_next 
ba08				endm 
# End of macro NEXTW
ba08			 
ba08			 
ba08			.SPACE: 
ba08				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
ba08 46				db WORD_SYS_CORE+50             
ba09 36 ba			dw .SPACES            
ba0b 03				db 2 + 1 
ba0c .. 00			db "BL",0              
ba0f				endm 
# End of macro CWHEAD
ba0f			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
ba0f					if DEBUG_FORTH_WORDS_KEY 
ba0f						DMARK "BL." 
ba0f f5				push af  
ba10 3a 24 ba			ld a, (.dmark)  
ba13 32 c0 ee			ld (debug_mark),a  
ba16 3a 25 ba			ld a, (.dmark+1)  
ba19 32 c1 ee			ld (debug_mark+1),a  
ba1c 3a 26 ba			ld a, (.dmark+2)  
ba1f 32 c2 ee			ld (debug_mark+2),a  
ba22 18 03			jr .pastdmark  
ba24 ..			.dmark: db "BL."  
ba27 f1			.pastdmark: pop af  
ba28			endm  
# End of macro DMARK
ba28						CALLMONITOR 
ba28 cd b0 92			call break_point_state  
ba2b				endm  
# End of macro CALLMONITOR
ba2b					endif 
ba2b 21 34 ba				ld hl, .blstr 
ba2e cd ab 98				call forth_push_str 
ba31					 
ba31				       NEXTW 
ba31 c3 a6 9b			jp macro_next 
ba34				endm 
# End of macro NEXTW
ba34			 
ba34 .. 00		.blstr: db " ", 0 
ba36			 
ba36			.SPACES: 
ba36				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
ba36 47				db WORD_SYS_CORE+51             
ba37 d1 ba			dw .SCROLL            
ba39 07				db 6 + 1 
ba3a .. 00			db "SPACES",0              
ba41				endm 
# End of macro CWHEAD
ba41			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
ba41					if DEBUG_FORTH_WORDS_KEY 
ba41						DMARK "SPS" 
ba41 f5				push af  
ba42 3a 56 ba			ld a, (.dmark)  
ba45 32 c0 ee			ld (debug_mark),a  
ba48 3a 57 ba			ld a, (.dmark+1)  
ba4b 32 c1 ee			ld (debug_mark+1),a  
ba4e 3a 58 ba			ld a, (.dmark+2)  
ba51 32 c2 ee			ld (debug_mark+2),a  
ba54 18 03			jr .pastdmark  
ba56 ..			.dmark: db "SPS"  
ba59 f1			.pastdmark: pop af  
ba5a			endm  
# End of macro DMARK
ba5a						CALLMONITOR 
ba5a cd b0 92			call break_point_state  
ba5d				endm  
# End of macro CALLMONITOR
ba5d					endif 
ba5d			 
ba5d			 
ba5d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba5d cd 34 9a			call macro_dsp_valuehl 
ba60				endm 
# End of macro FORTH_DSP_VALUEHL
ba60			 
ba60			;		push hl    ; u 
ba60					if DEBUG_FORTH_WORDS 
ba60						DMARK "SPA" 
ba60 f5				push af  
ba61 3a 75 ba			ld a, (.dmark)  
ba64 32 c0 ee			ld (debug_mark),a  
ba67 3a 76 ba			ld a, (.dmark+1)  
ba6a 32 c1 ee			ld (debug_mark+1),a  
ba6d 3a 77 ba			ld a, (.dmark+2)  
ba70 32 c2 ee			ld (debug_mark+2),a  
ba73 18 03			jr .pastdmark  
ba75 ..			.dmark: db "SPA"  
ba78 f1			.pastdmark: pop af  
ba79			endm  
# End of macro DMARK
ba79						CALLMONITOR 
ba79 cd b0 92			call break_point_state  
ba7c				endm  
# End of macro CALLMONITOR
ba7c					endif 
ba7c			 
ba7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba7c cd ec 9a			call macro_forth_dsp_pop 
ba7f				endm 
# End of macro FORTH_DSP_POP
ba7f			;		pop hl 
ba7f 4d					ld c, l 
ba80 06 00				ld b, 0 
ba82 21 e6 e4				ld hl, scratch  
ba85			 
ba85					if DEBUG_FORTH_WORDS 
ba85						DMARK "SP2" 
ba85 f5				push af  
ba86 3a 9a ba			ld a, (.dmark)  
ba89 32 c0 ee			ld (debug_mark),a  
ba8c 3a 9b ba			ld a, (.dmark+1)  
ba8f 32 c1 ee			ld (debug_mark+1),a  
ba92 3a 9c ba			ld a, (.dmark+2)  
ba95 32 c2 ee			ld (debug_mark+2),a  
ba98 18 03			jr .pastdmark  
ba9a ..			.dmark: db "SP2"  
ba9d f1			.pastdmark: pop af  
ba9e			endm  
# End of macro DMARK
ba9e						CALLMONITOR 
ba9e cd b0 92			call break_point_state  
baa1				endm  
# End of macro CALLMONITOR
baa1					endif 
baa1 3e 20				ld a, ' ' 
baa3 c5			.spaces1:	push bc 
baa4 77					ld (hl),a 
baa5 23					inc hl 
baa6 c1					pop bc 
baa7 10 fa				djnz .spaces1 
baa9 3e 00				ld a,0 
baab 77					ld (hl),a 
baac 21 e6 e4				ld hl, scratch 
baaf					if DEBUG_FORTH_WORDS 
baaf						DMARK "SP3" 
baaf f5				push af  
bab0 3a c4 ba			ld a, (.dmark)  
bab3 32 c0 ee			ld (debug_mark),a  
bab6 3a c5 ba			ld a, (.dmark+1)  
bab9 32 c1 ee			ld (debug_mark+1),a  
babc 3a c6 ba			ld a, (.dmark+2)  
babf 32 c2 ee			ld (debug_mark+2),a  
bac2 18 03			jr .pastdmark  
bac4 ..			.dmark: db "SP3"  
bac7 f1			.pastdmark: pop af  
bac8			endm  
# End of macro DMARK
bac8						CALLMONITOR 
bac8 cd b0 92			call break_point_state  
bacb				endm  
# End of macro CALLMONITOR
bacb					endif 
bacb cd a6 99				call forth_apush 
bace			 
bace				       NEXTW 
bace c3 a6 9b			jp macro_next 
bad1				endm 
# End of macro NEXTW
bad1			 
bad1			 
bad1			 
bad1			.SCROLL: 
bad1				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bad1 53				db WORD_SYS_CORE+63             
bad2 fe ba			dw .SCROLLD            
bad4 07				db 6 + 1 
bad5 .. 00			db "SCROLL",0              
badc				endm 
# End of macro CWHEAD
badc			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
badc					if DEBUG_FORTH_WORDS_KEY 
badc						DMARK "SCR" 
badc f5				push af  
badd 3a f1 ba			ld a, (.dmark)  
bae0 32 c0 ee			ld (debug_mark),a  
bae3 3a f2 ba			ld a, (.dmark+1)  
bae6 32 c1 ee			ld (debug_mark+1),a  
bae9 3a f3 ba			ld a, (.dmark+2)  
baec 32 c2 ee			ld (debug_mark+2),a  
baef 18 03			jr .pastdmark  
baf1 ..			.dmark: db "SCR"  
baf4 f1			.pastdmark: pop af  
baf5			endm  
# End of macro DMARK
baf5						CALLMONITOR 
baf5 cd b0 92			call break_point_state  
baf8				endm  
# End of macro CALLMONITOR
baf8					endif 
baf8			 
baf8 cd fe 87			call scroll_up 
bafb			;	call update_display 
bafb			 
bafb					NEXTW 
bafb c3 a6 9b			jp macro_next 
bafe				endm 
# End of macro NEXTW
bafe			 
bafe			 
bafe			 
bafe			;		; get dir 
bafe			; 
bafe			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bafe			; 
bafe			;		push hl 
bafe			; 
bafe			;		; destroy value TOS 
bafe			; 
bafe			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bafe			; 
bafe			;		; get count 
bafe			; 
bafe			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bafe			; 
bafe			;		push hl 
bafe			; 
bafe			;		; destroy value TOS 
bafe			; 
bafe			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bafe			; 
bafe			;		; one value on hl get other one back 
bafe			; 
bafe			;		pop bc    ; count 
bafe			; 
bafe			;		pop de   ; dir 
bafe			; 
bafe			; 
bafe			;		ld b, c 
bafe			; 
bafe			;.scrolldir:     push bc 
bafe			;		push de 
bafe			; 
bafe			;		ld a, 0 
bafe			;		cp e 
bafe			;		jr z, .scrollup  
bafe			;		call scroll_down 
bafe			;		jr .scrollnext 
bafe			;.scrollup:	call scroll_up 
bafe			; 
bafe			;		 
bafe			;.scrollnext: 
bafe			;		pop de 
bafe			;		pop bc 
bafe			;		djnz .scrolldir 
bafe			; 
bafe			; 
bafe			; 
bafe			; 
bafe			; 
bafe			;		NEXTW 
bafe			 
bafe			.SCROLLD: 
bafe				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bafe 53				db WORD_SYS_CORE+63             
baff 2c bb			dw .ATQ            
bb01 08				db 7 + 1 
bb02 .. 00			db "SCROLLD",0              
bb0a				endm 
# End of macro CWHEAD
bb0a			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bb0a					if DEBUG_FORTH_WORDS_KEY 
bb0a						DMARK "SCD" 
bb0a f5				push af  
bb0b 3a 1f bb			ld a, (.dmark)  
bb0e 32 c0 ee			ld (debug_mark),a  
bb11 3a 20 bb			ld a, (.dmark+1)  
bb14 32 c1 ee			ld (debug_mark+1),a  
bb17 3a 21 bb			ld a, (.dmark+2)  
bb1a 32 c2 ee			ld (debug_mark+2),a  
bb1d 18 03			jr .pastdmark  
bb1f ..			.dmark: db "SCD"  
bb22 f1			.pastdmark: pop af  
bb23			endm  
# End of macro DMARK
bb23						CALLMONITOR 
bb23 cd b0 92			call break_point_state  
bb26				endm  
# End of macro CALLMONITOR
bb26					endif 
bb26			 
bb26 cd 22 88			call scroll_down 
bb29			;	call update_display 
bb29			 
bb29					NEXTW 
bb29 c3 a6 9b			jp macro_next 
bb2c				endm 
# End of macro NEXTW
bb2c			 
bb2c			 
bb2c			.ATQ: 
bb2c				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bb2c 62				db WORD_SYS_CORE+78             
bb2d 8a bb			dw .AUTODSP            
bb2f 04				db 3 + 1 
bb30 .. 00			db "AT@",0              
bb34				endm 
# End of macro CWHEAD
bb34			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bb34					if DEBUG_FORTH_WORDS_KEY 
bb34						DMARK "ATA" 
bb34 f5				push af  
bb35 3a 49 bb			ld a, (.dmark)  
bb38 32 c0 ee			ld (debug_mark),a  
bb3b 3a 4a bb			ld a, (.dmark+1)  
bb3e 32 c1 ee			ld (debug_mark+1),a  
bb41 3a 4b bb			ld a, (.dmark+2)  
bb44 32 c2 ee			ld (debug_mark+2),a  
bb47 18 03			jr .pastdmark  
bb49 ..			.dmark: db "ATA"  
bb4c f1			.pastdmark: pop af  
bb4d			endm  
# End of macro DMARK
bb4d						CALLMONITOR 
bb4d cd b0 92			call break_point_state  
bb50				endm  
# End of macro CALLMONITOR
bb50					endif 
bb50			 
bb50			 
bb50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb50 cd 34 9a			call macro_dsp_valuehl 
bb53				endm 
# End of macro FORTH_DSP_VALUEHL
bb53			 
bb53					; TODO save cursor row 
bb53 7d					ld a,l 
bb54 fe 02				cp 2 
bb56 20 04				jr nz, .crow3aq 
bb58 3e 14				ld a, display_row_2 
bb5a 18 12				jr .ccol1aq 
bb5c fe 03		.crow3aq:		cp 3 
bb5e 20 04				jr nz, .crow4aq 
bb60 3e 28				ld a, display_row_3 
bb62 18 0a				jr .ccol1aq 
bb64 fe 04		.crow4aq:		cp 4 
bb66 20 04				jr nz, .crow1aq 
bb68 3e 3c				ld a, display_row_4 
bb6a 18 02				jr .ccol1aq 
bb6c 3e 00		.crow1aq:		ld a,display_row_1 
bb6e f5			.ccol1aq:		push af			; got row offset 
bb6f 6f					ld l,a 
bb70 26 00				ld h,0 
bb72					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb72 cd ec 9a			call macro_forth_dsp_pop 
bb75				endm 
# End of macro FORTH_DSP_POP
bb75					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb75 cd 34 9a			call macro_dsp_valuehl 
bb78				endm 
# End of macro FORTH_DSP_VALUEHL
bb78					; TODO save cursor col 
bb78 f1					pop af 
bb79 85					add l		; add col offset 
bb7a			 
bb7a					; add current frame buffer address 
bb7a 2a 61 ed				ld hl, (display_fb_active) 
bb7d cd 69 8a				call addatohl 
bb80			 
bb80			 
bb80			 
bb80			 
bb80					; get char frame buffer location offset in hl 
bb80			 
bb80 7e					ld a,(hl) 
bb81 26 00				ld h, 0 
bb83 6f					ld l, a 
bb84			 
bb84 cd 3d 98				call forth_push_numhl 
bb87			 
bb87			 
bb87					NEXTW 
bb87 c3 a6 9b			jp macro_next 
bb8a				endm 
# End of macro NEXTW
bb8a			 
bb8a			.AUTODSP: 
bb8a				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bb8a 63				db WORD_SYS_CORE+79             
bb8b a0 bb			dw .MENU            
bb8d 05				db 4 + 1 
bb8e .. 00			db "ADSP",0              
bb93				endm 
# End of macro CWHEAD
bb93			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bb93			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bb93			 
bb93					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb93 cd 34 9a			call macro_dsp_valuehl 
bb96				endm 
# End of macro FORTH_DSP_VALUEHL
bb96			 
bb96			;		push hl 
bb96			 
bb96					; destroy value TOS 
bb96			 
bb96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb96 cd ec 9a			call macro_forth_dsp_pop 
bb99				endm 
# End of macro FORTH_DSP_POP
bb99			 
bb99			;		pop hl 
bb99			 
bb99 7d					ld a,l 
bb9a 32 ad ec				ld (cli_autodisplay), a 
bb9d				       NEXTW 
bb9d c3 a6 9b			jp macro_next 
bba0				endm 
# End of macro NEXTW
bba0			 
bba0			.MENU: 
bba0				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bba0 70				db WORD_SYS_CORE+92             
bba1 49 bc			dw .ENDDISPLAY            
bba3 05				db 4 + 1 
bba4 .. 00			db "MENU",0              
bba9				endm 
# End of macro CWHEAD
bba9			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bba9			 
bba9			;		; get number of items on the stack 
bba9			; 
bba9				 
bba9					FORTH_DSP_VALUEHL 
bba9 cd 34 9a			call macro_dsp_valuehl 
bbac				endm 
# End of macro FORTH_DSP_VALUEHL
bbac				 
bbac					if DEBUG_FORTH_WORDS_KEY 
bbac						DMARK "MNU" 
bbac f5				push af  
bbad 3a c1 bb			ld a, (.dmark)  
bbb0 32 c0 ee			ld (debug_mark),a  
bbb3 3a c2 bb			ld a, (.dmark+1)  
bbb6 32 c1 ee			ld (debug_mark+1),a  
bbb9 3a c3 bb			ld a, (.dmark+2)  
bbbc 32 c2 ee			ld (debug_mark+2),a  
bbbf 18 03			jr .pastdmark  
bbc1 ..			.dmark: db "MNU"  
bbc4 f1			.pastdmark: pop af  
bbc5			endm  
# End of macro DMARK
bbc5						CALLMONITOR 
bbc5 cd b0 92			call break_point_state  
bbc8				endm  
# End of macro CALLMONITOR
bbc8					endif 
bbc8			 
bbc8 45					ld b, l	 
bbc9 05					dec b 
bbca			 
bbca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bbca cd ec 9a			call macro_forth_dsp_pop 
bbcd				endm 
# End of macro FORTH_DSP_POP
bbcd			 
bbcd			 
bbcd					; go directly through the stack to pluck out the string pointers and build an array 
bbcd			 
bbcd			;		FORTH_DSP 
bbcd			 
bbcd					; hl contains top most stack item 
bbcd				 
bbcd 11 e6 e4				ld de, scratch 
bbd0			 
bbd0			.mbuild: 
bbd0			 
bbd0					FORTH_DSP_VALUEHL 
bbd0 cd 34 9a			call macro_dsp_valuehl 
bbd3				endm 
# End of macro FORTH_DSP_VALUEHL
bbd3			 
bbd3					if DEBUG_FORTH_WORDS 
bbd3						DMARK "MN3" 
bbd3 f5				push af  
bbd4 3a e8 bb			ld a, (.dmark)  
bbd7 32 c0 ee			ld (debug_mark),a  
bbda 3a e9 bb			ld a, (.dmark+1)  
bbdd 32 c1 ee			ld (debug_mark+1),a  
bbe0 3a ea bb			ld a, (.dmark+2)  
bbe3 32 c2 ee			ld (debug_mark+2),a  
bbe6 18 03			jr .pastdmark  
bbe8 ..			.dmark: db "MN3"  
bbeb f1			.pastdmark: pop af  
bbec			endm  
# End of macro DMARK
bbec						CALLMONITOR 
bbec cd b0 92			call break_point_state  
bbef				endm  
# End of macro CALLMONITOR
bbef					endif 
bbef eb					ex de, hl 
bbf0 73					ld (hl), e 
bbf1 23					inc hl 
bbf2 72					ld (hl), d 
bbf3 23					inc hl 
bbf4 eb					ex de, hl 
bbf5			 
bbf5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bbf5 cd ec 9a			call macro_forth_dsp_pop 
bbf8				endm 
# End of macro FORTH_DSP_POP
bbf8			 
bbf8 10 d6				djnz .mbuild 
bbfa			 
bbfa					; done add term 
bbfa			 
bbfa eb					ex de, hl 
bbfb 36 00				ld (hl), 0 
bbfd 23					inc hl 
bbfe 36 00				ld (hl), 0 
bc00			 
bc00				 
bc00					 
bc00 21 e6 e4				ld hl, scratch 
bc03			 
bc03					if DEBUG_FORTH_WORDS 
bc03						DMARK "MNx" 
bc03 f5				push af  
bc04 3a 18 bc			ld a, (.dmark)  
bc07 32 c0 ee			ld (debug_mark),a  
bc0a 3a 19 bc			ld a, (.dmark+1)  
bc0d 32 c1 ee			ld (debug_mark+1),a  
bc10 3a 1a bc			ld a, (.dmark+2)  
bc13 32 c2 ee			ld (debug_mark+2),a  
bc16 18 03			jr .pastdmark  
bc18 ..			.dmark: db "MNx"  
bc1b f1			.pastdmark: pop af  
bc1c			endm  
# End of macro DMARK
bc1c						CALLMONITOR 
bc1c cd b0 92			call break_point_state  
bc1f				endm  
# End of macro CALLMONITOR
bc1f					endif 
bc1f			 
bc1f			 
bc1f			 
bc1f 3e 00				ld a, 0 
bc21 cd 6d 88				call menu 
bc24			 
bc24			 
bc24 6f					ld l, a 
bc25 26 00				ld h, 0 
bc27			 
bc27					if DEBUG_FORTH_WORDS 
bc27						DMARK "MNr" 
bc27 f5				push af  
bc28 3a 3c bc			ld a, (.dmark)  
bc2b 32 c0 ee			ld (debug_mark),a  
bc2e 3a 3d bc			ld a, (.dmark+1)  
bc31 32 c1 ee			ld (debug_mark+1),a  
bc34 3a 3e bc			ld a, (.dmark+2)  
bc37 32 c2 ee			ld (debug_mark+2),a  
bc3a 18 03			jr .pastdmark  
bc3c ..			.dmark: db "MNr"  
bc3f f1			.pastdmark: pop af  
bc40			endm  
# End of macro DMARK
bc40						CALLMONITOR 
bc40 cd b0 92			call break_point_state  
bc43				endm  
# End of macro CALLMONITOR
bc43					endif 
bc43			 
bc43 cd 3d 98				call forth_push_numhl 
bc46			 
bc46			 
bc46			 
bc46			 
bc46				       NEXTW 
bc46 c3 a6 9b			jp macro_next 
bc49				endm 
# End of macro NEXTW
bc49			 
bc49			 
bc49			.ENDDISPLAY: 
bc49			 
bc49			; eof 
# End of file forth_words_display.asm
bc49			include "forth_words_str.asm" 
bc49			 
bc49			; | ## String Words 
bc49			 
bc49			.PTR:   
bc49			 
bc49				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bc49 48				db WORD_SYS_CORE+52             
bc4a 76 bc			dw .STYPE            
bc4c 04				db 3 + 1 
bc4d .. 00			db "PTR",0              
bc51				endm 
# End of macro CWHEAD
bc51			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bc51			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bc51			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bc51			 
bc51					if DEBUG_FORTH_WORDS_KEY 
bc51						DMARK "PTR" 
bc51 f5				push af  
bc52 3a 66 bc			ld a, (.dmark)  
bc55 32 c0 ee			ld (debug_mark),a  
bc58 3a 67 bc			ld a, (.dmark+1)  
bc5b 32 c1 ee			ld (debug_mark+1),a  
bc5e 3a 68 bc			ld a, (.dmark+2)  
bc61 32 c2 ee			ld (debug_mark+2),a  
bc64 18 03			jr .pastdmark  
bc66 ..			.dmark: db "PTR"  
bc69 f1			.pastdmark: pop af  
bc6a			endm  
# End of macro DMARK
bc6a						CALLMONITOR 
bc6a cd b0 92			call break_point_state  
bc6d				endm  
# End of macro CALLMONITOR
bc6d					endif 
bc6d					FORTH_DSP_VALUEHL 
bc6d cd 34 9a			call macro_dsp_valuehl 
bc70				endm 
# End of macro FORTH_DSP_VALUEHL
bc70 cd 3d 98				call forth_push_numhl 
bc73			 
bc73			 
bc73					NEXTW 
bc73 c3 a6 9b			jp macro_next 
bc76				endm 
# End of macro NEXTW
bc76			.STYPE: 
bc76				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bc76 48				db WORD_SYS_CORE+52             
bc77 c5 bc			dw .UPPER            
bc79 06				db 5 + 1 
bc7a .. 00			db "STYPE",0              
bc80				endm 
# End of macro CWHEAD
bc80			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bc80					if DEBUG_FORTH_WORDS_KEY 
bc80						DMARK "STY" 
bc80 f5				push af  
bc81 3a 95 bc			ld a, (.dmark)  
bc84 32 c0 ee			ld (debug_mark),a  
bc87 3a 96 bc			ld a, (.dmark+1)  
bc8a 32 c1 ee			ld (debug_mark+1),a  
bc8d 3a 97 bc			ld a, (.dmark+2)  
bc90 32 c2 ee			ld (debug_mark+2),a  
bc93 18 03			jr .pastdmark  
bc95 ..			.dmark: db "STY"  
bc98 f1			.pastdmark: pop af  
bc99			endm  
# End of macro DMARK
bc99						CALLMONITOR 
bc99 cd b0 92			call break_point_state  
bc9c				endm  
# End of macro CALLMONITOR
bc9c					endif 
bc9c					FORTH_DSP 
bc9c cd fa 99			call macro_forth_dsp 
bc9f				endm 
# End of macro FORTH_DSP
bc9f					;v5 FORTH_DSP_VALUE 
bc9f			 
bc9f 7e					ld a, (hl) 
bca0			 
bca0 f5					push af 
bca1			 
bca1			; Dont destroy TOS		FORTH_DSP_POP 
bca1			 
bca1 f1					pop af 
bca2			 
bca2 fe 01				cp DS_TYPE_STR 
bca4 28 09				jr z, .typestr 
bca6			 
bca6 fe 02				cp DS_TYPE_INUM 
bca8 28 0a				jr z, .typeinum 
bcaa			 
bcaa 21 c3 bc				ld hl, .tna 
bcad 18 0a				jr .tpush 
bcaf			 
bcaf 21 bf bc		.typestr:	ld hl, .tstr 
bcb2 18 05				jr .tpush 
bcb4 21 c1 bc		.typeinum:	ld hl, .tinum 
bcb7 18 00				jr .tpush 
bcb9			 
bcb9			.tpush: 
bcb9			 
bcb9 cd ab 98				call forth_push_str 
bcbc			 
bcbc					NEXTW 
bcbc c3 a6 9b			jp macro_next 
bcbf				endm 
# End of macro NEXTW
bcbf .. 00		.tstr:	db "s",0 
bcc1 .. 00		.tinum:  db "i",0 
bcc3 .. 00		.tna:   db "?", 0 
bcc5			 
bcc5			 
bcc5			.UPPER: 
bcc5				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bcc5 48				db WORD_SYS_CORE+52             
bcc6 00 bd			dw .LOWER            
bcc8 06				db 5 + 1 
bcc9 .. 00			db "UPPER",0              
bccf				endm 
# End of macro CWHEAD
bccf			; | UPPER ( s -- s ) Upper case string s  | DONE 
bccf					if DEBUG_FORTH_WORDS_KEY 
bccf						DMARK "UPR" 
bccf f5				push af  
bcd0 3a e4 bc			ld a, (.dmark)  
bcd3 32 c0 ee			ld (debug_mark),a  
bcd6 3a e5 bc			ld a, (.dmark+1)  
bcd9 32 c1 ee			ld (debug_mark+1),a  
bcdc 3a e6 bc			ld a, (.dmark+2)  
bcdf 32 c2 ee			ld (debug_mark+2),a  
bce2 18 03			jr .pastdmark  
bce4 ..			.dmark: db "UPR"  
bce7 f1			.pastdmark: pop af  
bce8			endm  
# End of macro DMARK
bce8						CALLMONITOR 
bce8 cd b0 92			call break_point_state  
bceb				endm  
# End of macro CALLMONITOR
bceb					endif 
bceb			 
bceb					FORTH_DSP 
bceb cd fa 99			call macro_forth_dsp 
bcee				endm 
# End of macro FORTH_DSP
bcee					 
bcee			; TODO check is string type 
bcee			 
bcee					FORTH_DSP_VALUEHL 
bcee cd 34 9a			call macro_dsp_valuehl 
bcf1				endm 
# End of macro FORTH_DSP_VALUEHL
bcf1			; get pointer to string in hl 
bcf1			 
bcf1 7e			.toup:		ld a, (hl) 
bcf2 fe 00				cp 0 
bcf4 28 07				jr z, .toupdone 
bcf6			 
bcf6 cd d6 8d				call to_upper 
bcf9			 
bcf9 77					ld (hl), a 
bcfa 23					inc hl 
bcfb 18 f4				jr .toup 
bcfd			 
bcfd					 
bcfd			 
bcfd			 
bcfd			; for each char convert to upper 
bcfd					 
bcfd			.toupdone: 
bcfd			 
bcfd			 
bcfd					NEXTW 
bcfd c3 a6 9b			jp macro_next 
bd00				endm 
# End of macro NEXTW
bd00			.LOWER: 
bd00				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bd00 48				db WORD_SYS_CORE+52             
bd01 3b bd			dw .TCASE            
bd03 06				db 5 + 1 
bd04 .. 00			db "LOWER",0              
bd0a				endm 
# End of macro CWHEAD
bd0a			; | LOWER ( s -- s ) Lower case string s  | DONE 
bd0a					if DEBUG_FORTH_WORDS_KEY 
bd0a						DMARK "LWR" 
bd0a f5				push af  
bd0b 3a 1f bd			ld a, (.dmark)  
bd0e 32 c0 ee			ld (debug_mark),a  
bd11 3a 20 bd			ld a, (.dmark+1)  
bd14 32 c1 ee			ld (debug_mark+1),a  
bd17 3a 21 bd			ld a, (.dmark+2)  
bd1a 32 c2 ee			ld (debug_mark+2),a  
bd1d 18 03			jr .pastdmark  
bd1f ..			.dmark: db "LWR"  
bd22 f1			.pastdmark: pop af  
bd23			endm  
# End of macro DMARK
bd23						CALLMONITOR 
bd23 cd b0 92			call break_point_state  
bd26				endm  
# End of macro CALLMONITOR
bd26					endif 
bd26			 
bd26					FORTH_DSP 
bd26 cd fa 99			call macro_forth_dsp 
bd29				endm 
# End of macro FORTH_DSP
bd29					 
bd29			; TODO check is string type 
bd29			 
bd29					FORTH_DSP_VALUEHL 
bd29 cd 34 9a			call macro_dsp_valuehl 
bd2c				endm 
# End of macro FORTH_DSP_VALUEHL
bd2c			; get pointer to string in hl 
bd2c			 
bd2c 7e			.tolow:		ld a, (hl) 
bd2d fe 00				cp 0 
bd2f 28 07				jr z, .tolowdone 
bd31			 
bd31 cd df 8d				call to_lower 
bd34			 
bd34 77					ld (hl), a 
bd35 23					inc hl 
bd36 18 f4				jr .tolow 
bd38			 
bd38					 
bd38			 
bd38			 
bd38			; for each char convert to low 
bd38					 
bd38			.tolowdone: 
bd38					NEXTW 
bd38 c3 a6 9b			jp macro_next 
bd3b				endm 
# End of macro NEXTW
bd3b			.TCASE: 
bd3b				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bd3b 48				db WORD_SYS_CORE+52             
bd3c 71 be			dw .SUBSTR            
bd3e 06				db 5 + 1 
bd3f .. 00			db "TCASE",0              
bd45				endm 
# End of macro CWHEAD
bd45			; | TCASE ( s -- s ) Title case string s  | DONE 
bd45					if DEBUG_FORTH_WORDS_KEY 
bd45						DMARK "TCS" 
bd45 f5				push af  
bd46 3a 5a bd			ld a, (.dmark)  
bd49 32 c0 ee			ld (debug_mark),a  
bd4c 3a 5b bd			ld a, (.dmark+1)  
bd4f 32 c1 ee			ld (debug_mark+1),a  
bd52 3a 5c bd			ld a, (.dmark+2)  
bd55 32 c2 ee			ld (debug_mark+2),a  
bd58 18 03			jr .pastdmark  
bd5a ..			.dmark: db "TCS"  
bd5d f1			.pastdmark: pop af  
bd5e			endm  
# End of macro DMARK
bd5e						CALLMONITOR 
bd5e cd b0 92			call break_point_state  
bd61				endm  
# End of macro CALLMONITOR
bd61					endif 
bd61			 
bd61					FORTH_DSP 
bd61 cd fa 99			call macro_forth_dsp 
bd64				endm 
# End of macro FORTH_DSP
bd64					 
bd64			; TODO check is string type 
bd64			 
bd64					FORTH_DSP_VALUEHL 
bd64 cd 34 9a			call macro_dsp_valuehl 
bd67				endm 
# End of macro FORTH_DSP_VALUEHL
bd67			; get pointer to string in hl 
bd67			 
bd67					if DEBUG_FORTH_WORDS 
bd67						DMARK "TC1" 
bd67 f5				push af  
bd68 3a 7c bd			ld a, (.dmark)  
bd6b 32 c0 ee			ld (debug_mark),a  
bd6e 3a 7d bd			ld a, (.dmark+1)  
bd71 32 c1 ee			ld (debug_mark+1),a  
bd74 3a 7e bd			ld a, (.dmark+2)  
bd77 32 c2 ee			ld (debug_mark+2),a  
bd7a 18 03			jr .pastdmark  
bd7c ..			.dmark: db "TC1"  
bd7f f1			.pastdmark: pop af  
bd80			endm  
# End of macro DMARK
bd80						CALLMONITOR 
bd80 cd b0 92			call break_point_state  
bd83				endm  
# End of macro CALLMONITOR
bd83					endif 
bd83			 
bd83					; first time in turn to upper case first char 
bd83			 
bd83 7e					ld a, (hl) 
bd84 c3 0e be				jp .totsiptou 
bd87			 
bd87			 
bd87 7e			.tot:		ld a, (hl) 
bd88 fe 00				cp 0 
bd8a ca 52 be				jp z, .totdone 
bd8d			 
bd8d					if DEBUG_FORTH_WORDS 
bd8d						DMARK "TC2" 
bd8d f5				push af  
bd8e 3a a2 bd			ld a, (.dmark)  
bd91 32 c0 ee			ld (debug_mark),a  
bd94 3a a3 bd			ld a, (.dmark+1)  
bd97 32 c1 ee			ld (debug_mark+1),a  
bd9a 3a a4 bd			ld a, (.dmark+2)  
bd9d 32 c2 ee			ld (debug_mark+2),a  
bda0 18 03			jr .pastdmark  
bda2 ..			.dmark: db "TC2"  
bda5 f1			.pastdmark: pop af  
bda6			endm  
# End of macro DMARK
bda6						CALLMONITOR 
bda6 cd b0 92			call break_point_state  
bda9				endm  
# End of macro CALLMONITOR
bda9					endif 
bda9					; check to see if current char is a space 
bda9			 
bda9 fe 20				cp ' ' 
bdab 28 21				jr z, .totsp 
bdad cd df 8d				call to_lower 
bdb0					if DEBUG_FORTH_WORDS 
bdb0						DMARK "TC3" 
bdb0 f5				push af  
bdb1 3a c5 bd			ld a, (.dmark)  
bdb4 32 c0 ee			ld (debug_mark),a  
bdb7 3a c6 bd			ld a, (.dmark+1)  
bdba 32 c1 ee			ld (debug_mark+1),a  
bdbd 3a c7 bd			ld a, (.dmark+2)  
bdc0 32 c2 ee			ld (debug_mark+2),a  
bdc3 18 03			jr .pastdmark  
bdc5 ..			.dmark: db "TC3"  
bdc8 f1			.pastdmark: pop af  
bdc9			endm  
# End of macro DMARK
bdc9						CALLMONITOR 
bdc9 cd b0 92			call break_point_state  
bdcc				endm  
# End of macro CALLMONITOR
bdcc					endif 
bdcc 18 63				jr .totnxt 
bdce			 
bdce			.totsp:         ; on a space, find next char which should be upper 
bdce			 
bdce					if DEBUG_FORTH_WORDS 
bdce						DMARK "TC4" 
bdce f5				push af  
bdcf 3a e3 bd			ld a, (.dmark)  
bdd2 32 c0 ee			ld (debug_mark),a  
bdd5 3a e4 bd			ld a, (.dmark+1)  
bdd8 32 c1 ee			ld (debug_mark+1),a  
bddb 3a e5 bd			ld a, (.dmark+2)  
bdde 32 c2 ee			ld (debug_mark+2),a  
bde1 18 03			jr .pastdmark  
bde3 ..			.dmark: db "TC4"  
bde6 f1			.pastdmark: pop af  
bde7			endm  
# End of macro DMARK
bde7						CALLMONITOR 
bde7 cd b0 92			call break_point_state  
bdea				endm  
# End of macro CALLMONITOR
bdea					endif 
bdea					;; 
bdea			 
bdea fe 20				cp ' ' 
bdec 20 20				jr nz, .totsiptou 
bdee 23					inc hl 
bdef 7e					ld a, (hl) 
bdf0					if DEBUG_FORTH_WORDS 
bdf0						DMARK "TC5" 
bdf0 f5				push af  
bdf1 3a 05 be			ld a, (.dmark)  
bdf4 32 c0 ee			ld (debug_mark),a  
bdf7 3a 06 be			ld a, (.dmark+1)  
bdfa 32 c1 ee			ld (debug_mark+1),a  
bdfd 3a 07 be			ld a, (.dmark+2)  
be00 32 c2 ee			ld (debug_mark+2),a  
be03 18 03			jr .pastdmark  
be05 ..			.dmark: db "TC5"  
be08 f1			.pastdmark: pop af  
be09			endm  
# End of macro DMARK
be09						CALLMONITOR 
be09 cd b0 92			call break_point_state  
be0c				endm  
# End of macro CALLMONITOR
be0c					endif 
be0c 18 c0				jr .totsp 
be0e fe 00		.totsiptou:    cp 0 
be10 28 40				jr z, .totdone 
be12					; not space and not zero term so upper case it 
be12 cd d6 8d				call to_upper 
be15			 
be15					if DEBUG_FORTH_WORDS 
be15						DMARK "TC6" 
be15 f5				push af  
be16 3a 2a be			ld a, (.dmark)  
be19 32 c0 ee			ld (debug_mark),a  
be1c 3a 2b be			ld a, (.dmark+1)  
be1f 32 c1 ee			ld (debug_mark+1),a  
be22 3a 2c be			ld a, (.dmark+2)  
be25 32 c2 ee			ld (debug_mark+2),a  
be28 18 03			jr .pastdmark  
be2a ..			.dmark: db "TC6"  
be2d f1			.pastdmark: pop af  
be2e			endm  
# End of macro DMARK
be2e						CALLMONITOR 
be2e cd b0 92			call break_point_state  
be31				endm  
# End of macro CALLMONITOR
be31					endif 
be31			 
be31			 
be31			.totnxt: 
be31			 
be31 77					ld (hl), a 
be32 23					inc hl 
be33					if DEBUG_FORTH_WORDS 
be33						DMARK "TC7" 
be33 f5				push af  
be34 3a 48 be			ld a, (.dmark)  
be37 32 c0 ee			ld (debug_mark),a  
be3a 3a 49 be			ld a, (.dmark+1)  
be3d 32 c1 ee			ld (debug_mark+1),a  
be40 3a 4a be			ld a, (.dmark+2)  
be43 32 c2 ee			ld (debug_mark+2),a  
be46 18 03			jr .pastdmark  
be48 ..			.dmark: db "TC7"  
be4b f1			.pastdmark: pop af  
be4c			endm  
# End of macro DMARK
be4c						CALLMONITOR 
be4c cd b0 92			call break_point_state  
be4f				endm  
# End of macro CALLMONITOR
be4f					endif 
be4f c3 87 bd				jp .tot 
be52			 
be52					 
be52			 
be52			 
be52			; for each char convert to low 
be52					 
be52			.totdone: 
be52					if DEBUG_FORTH_WORDS 
be52						DMARK "TCd" 
be52 f5				push af  
be53 3a 67 be			ld a, (.dmark)  
be56 32 c0 ee			ld (debug_mark),a  
be59 3a 68 be			ld a, (.dmark+1)  
be5c 32 c1 ee			ld (debug_mark+1),a  
be5f 3a 69 be			ld a, (.dmark+2)  
be62 32 c2 ee			ld (debug_mark+2),a  
be65 18 03			jr .pastdmark  
be67 ..			.dmark: db "TCd"  
be6a f1			.pastdmark: pop af  
be6b			endm  
# End of macro DMARK
be6b						CALLMONITOR 
be6b cd b0 92			call break_point_state  
be6e				endm  
# End of macro CALLMONITOR
be6e					endif 
be6e					NEXTW 
be6e c3 a6 9b			jp macro_next 
be71				endm 
# End of macro NEXTW
be71			 
be71			.SUBSTR: 
be71				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
be71 48				db WORD_SYS_CORE+52             
be72 cf be			dw .LEFT            
be74 07				db 6 + 1 
be75 .. 00			db "SUBSTR",0              
be7c				endm 
# End of macro CWHEAD
be7c			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
be7c			 
be7c					if DEBUG_FORTH_WORDS_KEY 
be7c						DMARK "SST" 
be7c f5				push af  
be7d 3a 91 be			ld a, (.dmark)  
be80 32 c0 ee			ld (debug_mark),a  
be83 3a 92 be			ld a, (.dmark+1)  
be86 32 c1 ee			ld (debug_mark+1),a  
be89 3a 93 be			ld a, (.dmark+2)  
be8c 32 c2 ee			ld (debug_mark+2),a  
be8f 18 03			jr .pastdmark  
be91 ..			.dmark: db "SST"  
be94 f1			.pastdmark: pop af  
be95			endm  
# End of macro DMARK
be95						CALLMONITOR 
be95 cd b0 92			call break_point_state  
be98				endm  
# End of macro CALLMONITOR
be98					endif 
be98			; TODO check string type 
be98					FORTH_DSP_VALUEHL 
be98 cd 34 9a			call macro_dsp_valuehl 
be9b				endm 
# End of macro FORTH_DSP_VALUEHL
be9b			 
be9b e5					push hl      ; string length 
be9c			 
be9c					FORTH_DSP_POP 
be9c cd ec 9a			call macro_forth_dsp_pop 
be9f				endm 
# End of macro FORTH_DSP_POP
be9f			 
be9f					FORTH_DSP_VALUEHL 
be9f cd 34 9a			call macro_dsp_valuehl 
bea2				endm 
# End of macro FORTH_DSP_VALUEHL
bea2			 
bea2 e5					push hl     ; start char 
bea3			 
bea3					FORTH_DSP_POP 
bea3 cd ec 9a			call macro_forth_dsp_pop 
bea6				endm 
# End of macro FORTH_DSP_POP
bea6			 
bea6			 
bea6					FORTH_DSP_VALUE 
bea6 cd 1d 9a			call macro_forth_dsp_value 
bea9				endm 
# End of macro FORTH_DSP_VALUE
bea9			 
bea9 d1					pop de    ; get start post offset 
beaa			 
beaa 19					add hl, de    ; starting offset 
beab			 
beab c1					pop bc 
beac c5					push bc      ; grab size of string 
bead			 
bead e5					push hl    ; save string start  
beae			 
beae 26 00				ld h, 0 
beb0 69					ld l, c 
beb1 23					inc hl 
beb2 23					inc hl 
beb3			 
beb3 cd 30 8f				call malloc 
beb6				if DEBUG_FORTH_MALLOC_GUARD 
beb6 cc e5 c4				call z,malloc_error 
beb9				endif 
beb9			 
beb9 eb					ex de, hl      ; save malloc area for string copy 
beba e1					pop hl    ; get back source 
bebb c1					pop bc    ; get length of string back 
bebc			 
bebc d5					push de    ; save malloc area for after we push 
bebd ed b0				ldir     ; copy substr 
bebf			 
bebf			 
bebf eb					ex de, hl 
bec0 3e 00				ld a, 0 
bec2 77					ld (hl), a   ; term substr 
bec3			 
bec3					 
bec3 e1					pop hl    ; get malloc so we can push it 
bec4 e5					push hl   ; save so we can free it afterwards 
bec5			 
bec5 cd ab 98				call forth_push_str 
bec8			 
bec8 e1					pop hl 
bec9 cd fa 8f				call free 
becc			 
becc					 
becc					 
becc			 
becc			 
becc					NEXTW 
becc c3 a6 9b			jp macro_next 
becf				endm 
# End of macro NEXTW
becf			 
becf			.LEFT: 
becf				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
becf 48				db WORD_SYS_CORE+52             
bed0 f7 be			dw .RIGHT            
bed2 05				db 4 + 1 
bed3 .. 00			db "LEFT",0              
bed8				endm 
# End of macro CWHEAD
bed8			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
bed8					if DEBUG_FORTH_WORDS_KEY 
bed8						DMARK "LEF" 
bed8 f5				push af  
bed9 3a ed be			ld a, (.dmark)  
bedc 32 c0 ee			ld (debug_mark),a  
bedf 3a ee be			ld a, (.dmark+1)  
bee2 32 c1 ee			ld (debug_mark+1),a  
bee5 3a ef be			ld a, (.dmark+2)  
bee8 32 c2 ee			ld (debug_mark+2),a  
beeb 18 03			jr .pastdmark  
beed ..			.dmark: db "LEF"  
bef0 f1			.pastdmark: pop af  
bef1			endm  
# End of macro DMARK
bef1						CALLMONITOR 
bef1 cd b0 92			call break_point_state  
bef4				endm  
# End of macro CALLMONITOR
bef4					endif 
bef4			 
bef4					NEXTW 
bef4 c3 a6 9b			jp macro_next 
bef7				endm 
# End of macro NEXTW
bef7			.RIGHT: 
bef7				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
bef7 48				db WORD_SYS_CORE+52             
bef8 20 bf			dw .STR2NUM            
befa 06				db 5 + 1 
befb .. 00			db "RIGHT",0              
bf01				endm 
# End of macro CWHEAD
bf01			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
bf01					if DEBUG_FORTH_WORDS_KEY 
bf01						DMARK "RIG" 
bf01 f5				push af  
bf02 3a 16 bf			ld a, (.dmark)  
bf05 32 c0 ee			ld (debug_mark),a  
bf08 3a 17 bf			ld a, (.dmark+1)  
bf0b 32 c1 ee			ld (debug_mark+1),a  
bf0e 3a 18 bf			ld a, (.dmark+2)  
bf11 32 c2 ee			ld (debug_mark+2),a  
bf14 18 03			jr .pastdmark  
bf16 ..			.dmark: db "RIG"  
bf19 f1			.pastdmark: pop af  
bf1a			endm  
# End of macro DMARK
bf1a						CALLMONITOR 
bf1a cd b0 92			call break_point_state  
bf1d				endm  
# End of macro CALLMONITOR
bf1d					endif 
bf1d			 
bf1d					NEXTW 
bf1d c3 a6 9b			jp macro_next 
bf20				endm 
# End of macro NEXTW
bf20			 
bf20			 
bf20			.STR2NUM: 
bf20				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
bf20 48				db WORD_SYS_CORE+52             
bf21 ac bf			dw .NUM2STR            
bf23 08				db 7 + 1 
bf24 .. 00			db "STR2NUM",0              
bf2c				endm 
# End of macro CWHEAD
bf2c			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
bf2c			 
bf2c			 
bf2c			; TODO STR type check to do 
bf2c					if DEBUG_FORTH_WORDS_KEY 
bf2c						DMARK "S2N" 
bf2c f5				push af  
bf2d 3a 41 bf			ld a, (.dmark)  
bf30 32 c0 ee			ld (debug_mark),a  
bf33 3a 42 bf			ld a, (.dmark+1)  
bf36 32 c1 ee			ld (debug_mark+1),a  
bf39 3a 43 bf			ld a, (.dmark+2)  
bf3c 32 c2 ee			ld (debug_mark+2),a  
bf3f 18 03			jr .pastdmark  
bf41 ..			.dmark: db "S2N"  
bf44 f1			.pastdmark: pop af  
bf45			endm  
# End of macro DMARK
bf45						CALLMONITOR 
bf45 cd b0 92			call break_point_state  
bf48				endm  
# End of macro CALLMONITOR
bf48					endif 
bf48			 
bf48					;FORTH_DSP 
bf48					FORTH_DSP_VALUE 
bf48 cd 1d 9a			call macro_forth_dsp_value 
bf4b				endm 
# End of macro FORTH_DSP_VALUE
bf4b					;inc hl 
bf4b			 
bf4b eb					ex de, hl 
bf4c					if DEBUG_FORTH_WORDS 
bf4c						DMARK "S2a" 
bf4c f5				push af  
bf4d 3a 61 bf			ld a, (.dmark)  
bf50 32 c0 ee			ld (debug_mark),a  
bf53 3a 62 bf			ld a, (.dmark+1)  
bf56 32 c1 ee			ld (debug_mark+1),a  
bf59 3a 63 bf			ld a, (.dmark+2)  
bf5c 32 c2 ee			ld (debug_mark+2),a  
bf5f 18 03			jr .pastdmark  
bf61 ..			.dmark: db "S2a"  
bf64 f1			.pastdmark: pop af  
bf65			endm  
# End of macro DMARK
bf65						CALLMONITOR 
bf65 cd b0 92			call break_point_state  
bf68				endm  
# End of macro CALLMONITOR
bf68					endif 
bf68 cd 5e 8e				call string_to_uint16 
bf6b			 
bf6b					if DEBUG_FORTH_WORDS 
bf6b						DMARK "S2b" 
bf6b f5				push af  
bf6c 3a 80 bf			ld a, (.dmark)  
bf6f 32 c0 ee			ld (debug_mark),a  
bf72 3a 81 bf			ld a, (.dmark+1)  
bf75 32 c1 ee			ld (debug_mark+1),a  
bf78 3a 82 bf			ld a, (.dmark+2)  
bf7b 32 c2 ee			ld (debug_mark+2),a  
bf7e 18 03			jr .pastdmark  
bf80 ..			.dmark: db "S2b"  
bf83 f1			.pastdmark: pop af  
bf84			endm  
# End of macro DMARK
bf84						CALLMONITOR 
bf84 cd b0 92			call break_point_state  
bf87				endm  
# End of macro CALLMONITOR
bf87					endif 
bf87			;		push hl 
bf87					FORTH_DSP_POP 
bf87 cd ec 9a			call macro_forth_dsp_pop 
bf8a				endm 
# End of macro FORTH_DSP_POP
bf8a			;		pop hl 
bf8a					 
bf8a					if DEBUG_FORTH_WORDS 
bf8a						DMARK "S2b" 
bf8a f5				push af  
bf8b 3a 9f bf			ld a, (.dmark)  
bf8e 32 c0 ee			ld (debug_mark),a  
bf91 3a a0 bf			ld a, (.dmark+1)  
bf94 32 c1 ee			ld (debug_mark+1),a  
bf97 3a a1 bf			ld a, (.dmark+2)  
bf9a 32 c2 ee			ld (debug_mark+2),a  
bf9d 18 03			jr .pastdmark  
bf9f ..			.dmark: db "S2b"  
bfa2 f1			.pastdmark: pop af  
bfa3			endm  
# End of macro DMARK
bfa3						CALLMONITOR 
bfa3 cd b0 92			call break_point_state  
bfa6				endm  
# End of macro CALLMONITOR
bfa6					endif 
bfa6 cd 3d 98				call forth_push_numhl	 
bfa9			 
bfa9				 
bfa9				       NEXTW 
bfa9 c3 a6 9b			jp macro_next 
bfac				endm 
# End of macro NEXTW
bfac			.NUM2STR: 
bfac				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
bfac 48				db WORD_SYS_CORE+52             
bfad bb bf			dw .CONCAT            
bfaf 08				db 7 + 1 
bfb0 .. 00			db "NUM2STR",0              
bfb8				endm 
# End of macro CWHEAD
bfb8			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
bfb8			 
bfb8			;		; malloc a string to target 
bfb8			;		ld hl, 10     ; TODO max string size should be fine 
bfb8			;		call malloc 
bfb8			;		push hl    ; save malloc location 
bfb8			; 
bfb8			; 
bfb8			;; TODO check int type 
bfb8			;		FORTH_DSP_VALUEHL 
bfb8			;		ld a, l 
bfb8			;		call DispAToASCII   
bfb8			;;TODO need to chage above call to dump into string 
bfb8			; 
bfb8			; 
bfb8			 
bfb8				       NEXTW 
bfb8 c3 a6 9b			jp macro_next 
bfbb				endm 
# End of macro NEXTW
bfbb			 
bfbb			.CONCAT: 
bfbb				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
bfbb 48				db WORD_SYS_CORE+52             
bfbc 6e c0			dw .FIND            
bfbe 07				db 6 + 1 
bfbf .. 00			db "CONCAT",0              
bfc6				endm 
# End of macro CWHEAD
bfc6			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
bfc6			 
bfc6			; TODO check string type 
bfc6			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
bfc6			 
bfc6					if DEBUG_FORTH_WORDS_KEY 
bfc6						DMARK "CON" 
bfc6 f5				push af  
bfc7 3a db bf			ld a, (.dmark)  
bfca 32 c0 ee			ld (debug_mark),a  
bfcd 3a dc bf			ld a, (.dmark+1)  
bfd0 32 c1 ee			ld (debug_mark+1),a  
bfd3 3a dd bf			ld a, (.dmark+2)  
bfd6 32 c2 ee			ld (debug_mark+2),a  
bfd9 18 03			jr .pastdmark  
bfdb ..			.dmark: db "CON"  
bfde f1			.pastdmark: pop af  
bfdf			endm  
# End of macro DMARK
bfdf						CALLMONITOR 
bfdf cd b0 92			call break_point_state  
bfe2				endm  
# End of macro CALLMONITOR
bfe2					endif 
bfe2			 
bfe2			 
bfe2					FORTH_DSP_VALUE 
bfe2 cd 1d 9a			call macro_forth_dsp_value 
bfe5				endm 
# End of macro FORTH_DSP_VALUE
bfe5 e5					push hl   ; s2 
bfe6			 
bfe6					FORTH_DSP_POP 
bfe6 cd ec 9a			call macro_forth_dsp_pop 
bfe9				endm 
# End of macro FORTH_DSP_POP
bfe9			 
bfe9					FORTH_DSP_VALUE 
bfe9 cd 1d 9a			call macro_forth_dsp_value 
bfec				endm 
# End of macro FORTH_DSP_VALUE
bfec			 
bfec e5					push hl   ; s1 
bfed			 
bfed					FORTH_DSP_POP 
bfed cd ec 9a			call macro_forth_dsp_pop 
bff0				endm 
# End of macro FORTH_DSP_POP
bff0					 
bff0			 
bff0					; copy s1 
bff0			 
bff0				 
bff0					; save ptr 
bff0 e1					pop hl  
bff1 e5					push hl 
bff2 3e 00				ld a, 0 
bff4 cd d2 8e				call strlent 
bff7					;inc hl    ; zer0 
bff7 06 00				ld b, 0 
bff9 4d					ld c, l 
bffa e1					pop hl		 
bffb 11 e6 e4				ld de, scratch	 
bffe					if DEBUG_FORTH_WORDS 
bffe						DMARK "CO1" 
bffe f5				push af  
bfff 3a 13 c0			ld a, (.dmark)  
c002 32 c0 ee			ld (debug_mark),a  
c005 3a 14 c0			ld a, (.dmark+1)  
c008 32 c1 ee			ld (debug_mark+1),a  
c00b 3a 15 c0			ld a, (.dmark+2)  
c00e 32 c2 ee			ld (debug_mark+2),a  
c011 18 03			jr .pastdmark  
c013 ..			.dmark: db "CO1"  
c016 f1			.pastdmark: pop af  
c017			endm  
# End of macro DMARK
c017						CALLMONITOR 
c017 cd b0 92			call break_point_state  
c01a				endm  
# End of macro CALLMONITOR
c01a					endif 
c01a ed b0				ldir 
c01c			 
c01c e1					pop hl 
c01d e5					push hl 
c01e d5					push de 
c01f			 
c01f			 
c01f 3e 00				ld a, 0 
c021 cd d2 8e				call strlent 
c024 23					inc hl    ; zer0 
c025 23					inc hl 
c026 06 00				ld b, 0 
c028 4d					ld c, l 
c029 d1					pop de 
c02a e1					pop hl		 
c02b					if DEBUG_FORTH_WORDS 
c02b						DMARK "CO2" 
c02b f5				push af  
c02c 3a 40 c0			ld a, (.dmark)  
c02f 32 c0 ee			ld (debug_mark),a  
c032 3a 41 c0			ld a, (.dmark+1)  
c035 32 c1 ee			ld (debug_mark+1),a  
c038 3a 42 c0			ld a, (.dmark+2)  
c03b 32 c2 ee			ld (debug_mark+2),a  
c03e 18 03			jr .pastdmark  
c040 ..			.dmark: db "CO2"  
c043 f1			.pastdmark: pop af  
c044			endm  
# End of macro DMARK
c044						CALLMONITOR 
c044 cd b0 92			call break_point_state  
c047				endm  
# End of macro CALLMONITOR
c047					endif 
c047 ed b0				ldir 
c049			 
c049			 
c049			 
c049 21 e6 e4				ld hl, scratch 
c04c					if DEBUG_FORTH_WORDS 
c04c						DMARK "CO5" 
c04c f5				push af  
c04d 3a 61 c0			ld a, (.dmark)  
c050 32 c0 ee			ld (debug_mark),a  
c053 3a 62 c0			ld a, (.dmark+1)  
c056 32 c1 ee			ld (debug_mark+1),a  
c059 3a 63 c0			ld a, (.dmark+2)  
c05c 32 c2 ee			ld (debug_mark+2),a  
c05f 18 03			jr .pastdmark  
c061 ..			.dmark: db "CO5"  
c064 f1			.pastdmark: pop af  
c065			endm  
# End of macro DMARK
c065						CALLMONITOR 
c065 cd b0 92			call break_point_state  
c068				endm  
# End of macro CALLMONITOR
c068					endif 
c068			 
c068 cd ab 98				call forth_push_str 
c06b			 
c06b			 
c06b			 
c06b			 
c06b				       NEXTW 
c06b c3 a6 9b			jp macro_next 
c06e				endm 
# End of macro NEXTW
c06e			 
c06e			 
c06e			.FIND: 
c06e				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c06e 4b				db WORD_SYS_CORE+55             
c06f 2c c1			dw .LEN            
c071 05				db 4 + 1 
c072 .. 00			db "FIND",0              
c077				endm 
# End of macro CWHEAD
c077			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c077			 
c077					if DEBUG_FORTH_WORDS_KEY 
c077						DMARK "FND" 
c077 f5				push af  
c078 3a 8c c0			ld a, (.dmark)  
c07b 32 c0 ee			ld (debug_mark),a  
c07e 3a 8d c0			ld a, (.dmark+1)  
c081 32 c1 ee			ld (debug_mark+1),a  
c084 3a 8e c0			ld a, (.dmark+2)  
c087 32 c2 ee			ld (debug_mark+2),a  
c08a 18 03			jr .pastdmark  
c08c ..			.dmark: db "FND"  
c08f f1			.pastdmark: pop af  
c090			endm  
# End of macro DMARK
c090						CALLMONITOR 
c090 cd b0 92			call break_point_state  
c093				endm  
# End of macro CALLMONITOR
c093					endif 
c093			 
c093			; TODO check string type 
c093					FORTH_DSP_VALUE 
c093 cd 1d 9a			call macro_forth_dsp_value 
c096				endm 
# End of macro FORTH_DSP_VALUE
c096			 
c096 e5					push hl    
c097 7e					ld a,(hl)    ; char to find   
c098			; TODO change char to substr 
c098			 
c098 f5					push af 
c099					 
c099			 
c099			 
c099					if DEBUG_FORTH_WORDS 
c099						DMARK "FN1" 
c099 f5				push af  
c09a 3a ae c0			ld a, (.dmark)  
c09d 32 c0 ee			ld (debug_mark),a  
c0a0 3a af c0			ld a, (.dmark+1)  
c0a3 32 c1 ee			ld (debug_mark+1),a  
c0a6 3a b0 c0			ld a, (.dmark+2)  
c0a9 32 c2 ee			ld (debug_mark+2),a  
c0ac 18 03			jr .pastdmark  
c0ae ..			.dmark: db "FN1"  
c0b1 f1			.pastdmark: pop af  
c0b2			endm  
# End of macro DMARK
c0b2						CALLMONITOR 
c0b2 cd b0 92			call break_point_state  
c0b5				endm  
# End of macro CALLMONITOR
c0b5					endif 
c0b5			 
c0b5					FORTH_DSP_POP 
c0b5 cd ec 9a			call macro_forth_dsp_pop 
c0b8				endm 
# End of macro FORTH_DSP_POP
c0b8			 
c0b8					; string to search 
c0b8			 
c0b8					FORTH_DSP_VALUE 
c0b8 cd 1d 9a			call macro_forth_dsp_value 
c0bb				endm 
# End of macro FORTH_DSP_VALUE
c0bb			 
c0bb d1					pop de  ; d is char to find  
c0bc			 
c0bc					if DEBUG_FORTH_WORDS 
c0bc						DMARK "FN2" 
c0bc f5				push af  
c0bd 3a d1 c0			ld a, (.dmark)  
c0c0 32 c0 ee			ld (debug_mark),a  
c0c3 3a d2 c0			ld a, (.dmark+1)  
c0c6 32 c1 ee			ld (debug_mark+1),a  
c0c9 3a d3 c0			ld a, (.dmark+2)  
c0cc 32 c2 ee			ld (debug_mark+2),a  
c0cf 18 03			jr .pastdmark  
c0d1 ..			.dmark: db "FN2"  
c0d4 f1			.pastdmark: pop af  
c0d5			endm  
# End of macro DMARK
c0d5						CALLMONITOR 
c0d5 cd b0 92			call break_point_state  
c0d8				endm  
# End of macro CALLMONITOR
c0d8					endif 
c0d8					 
c0d8 01 00 00				ld bc, 0 
c0db 7e			.findchar:      ld a,(hl) 
c0dc fe 00				cp 0   		 
c0de 28 27				jr z, .finddone     
c0e0 ba					cp d 
c0e1 28 20				jr z, .foundchar 
c0e3 03					inc bc 
c0e4 23					inc hl 
c0e5					if DEBUG_FORTH_WORDS 
c0e5						DMARK "FN3" 
c0e5 f5				push af  
c0e6 3a fa c0			ld a, (.dmark)  
c0e9 32 c0 ee			ld (debug_mark),a  
c0ec 3a fb c0			ld a, (.dmark+1)  
c0ef 32 c1 ee			ld (debug_mark+1),a  
c0f2 3a fc c0			ld a, (.dmark+2)  
c0f5 32 c2 ee			ld (debug_mark+2),a  
c0f8 18 03			jr .pastdmark  
c0fa ..			.dmark: db "FN3"  
c0fd f1			.pastdmark: pop af  
c0fe			endm  
# End of macro DMARK
c0fe						CALLMONITOR 
c0fe cd b0 92			call break_point_state  
c101				endm  
# End of macro CALLMONITOR
c101					endif 
c101 18 d8				jr .findchar 
c103			 
c103			 
c103 c5			.foundchar:	push bc 
c104 e1					pop hl 
c105 18 03				jr .findexit 
c107			 
c107			 
c107							 
c107			 
c107			.finddone:     ; got to end of string with no find 
c107 21 00 00				ld hl, 0 
c10a			.findexit: 
c10a			 
c10a					if DEBUG_FORTH_WORDS 
c10a						DMARK "FNd" 
c10a f5				push af  
c10b 3a 1f c1			ld a, (.dmark)  
c10e 32 c0 ee			ld (debug_mark),a  
c111 3a 20 c1			ld a, (.dmark+1)  
c114 32 c1 ee			ld (debug_mark+1),a  
c117 3a 21 c1			ld a, (.dmark+2)  
c11a 32 c2 ee			ld (debug_mark+2),a  
c11d 18 03			jr .pastdmark  
c11f ..			.dmark: db "FNd"  
c122 f1			.pastdmark: pop af  
c123			endm  
# End of macro DMARK
c123						CALLMONITOR 
c123 cd b0 92			call break_point_state  
c126				endm  
# End of macro CALLMONITOR
c126					endif 
c126 cd 3d 98			call forth_push_numhl 
c129			 
c129				       NEXTW 
c129 c3 a6 9b			jp macro_next 
c12c				endm 
# End of macro NEXTW
c12c			 
c12c			.LEN: 
c12c				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c12c 4c				db WORD_SYS_CORE+56             
c12d 61 c1			dw .CHAR            
c12f 06				db 5 + 1 
c130 .. 00			db "COUNT",0              
c136				endm 
# End of macro CWHEAD
c136			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c136			 
c136					if DEBUG_FORTH_WORDS_KEY 
c136						DMARK "CNT" 
c136 f5				push af  
c137 3a 4b c1			ld a, (.dmark)  
c13a 32 c0 ee			ld (debug_mark),a  
c13d 3a 4c c1			ld a, (.dmark+1)  
c140 32 c1 ee			ld (debug_mark+1),a  
c143 3a 4d c1			ld a, (.dmark+2)  
c146 32 c2 ee			ld (debug_mark+2),a  
c149 18 03			jr .pastdmark  
c14b ..			.dmark: db "CNT"  
c14e f1			.pastdmark: pop af  
c14f			endm  
# End of macro DMARK
c14f						CALLMONITOR 
c14f cd b0 92			call break_point_state  
c152				endm  
# End of macro CALLMONITOR
c152					endif 
c152			; TODO check string type 
c152					FORTH_DSP 
c152 cd fa 99			call macro_forth_dsp 
c155				endm 
# End of macro FORTH_DSP
c155					;v5FORTH_DSP_VALUE 
c155			 
c155 23					inc hl 
c156			 
c156 3e 00				ld a, 0 
c158 cd d2 8e				call strlent 
c15b			 
c15b cd 3d 98				call forth_push_numhl 
c15e			 
c15e			 
c15e			 
c15e				       NEXTW 
c15e c3 a6 9b			jp macro_next 
c161				endm 
# End of macro NEXTW
c161			.CHAR: 
c161				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c161 4d				db WORD_SYS_CORE+57             
c162 97 c1			dw .ENDSTR            
c164 05				db 4 + 1 
c165 .. 00			db "CHAR",0              
c16a				endm 
# End of macro CWHEAD
c16a			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c16a					if DEBUG_FORTH_WORDS_KEY 
c16a						DMARK "CHR" 
c16a f5				push af  
c16b 3a 7f c1			ld a, (.dmark)  
c16e 32 c0 ee			ld (debug_mark),a  
c171 3a 80 c1			ld a, (.dmark+1)  
c174 32 c1 ee			ld (debug_mark+1),a  
c177 3a 81 c1			ld a, (.dmark+2)  
c17a 32 c2 ee			ld (debug_mark+2),a  
c17d 18 03			jr .pastdmark  
c17f ..			.dmark: db "CHR"  
c182 f1			.pastdmark: pop af  
c183			endm  
# End of macro DMARK
c183						CALLMONITOR 
c183 cd b0 92			call break_point_state  
c186				endm  
# End of macro CALLMONITOR
c186					endif 
c186					FORTH_DSP 
c186 cd fa 99			call macro_forth_dsp 
c189				endm 
# End of macro FORTH_DSP
c189					;v5 FORTH_DSP_VALUE 
c189 23					inc hl      ; now at start of numeric as string 
c18a			 
c18a			;		push hl 
c18a			 
c18a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c18a cd ec 9a			call macro_forth_dsp_pop 
c18d				endm 
# End of macro FORTH_DSP_POP
c18d			 
c18d			;		pop hl 
c18d			 
c18d					; push the content of a onto the stack as a value 
c18d			 
c18d 7e					ld a,(hl)   ; get char 
c18e 26 00				ld h,0 
c190 6f					ld l,a 
c191 cd 3d 98				call forth_push_numhl 
c194			 
c194				       NEXTW 
c194 c3 a6 9b			jp macro_next 
c197				endm 
# End of macro NEXTW
c197			 
c197			 
c197			 
c197			 
c197			.ENDSTR: 
c197			; eof 
c197			 
# End of file forth_words_str.asm
c197			include "forth_words_key.asm" 
c197			 
c197			; | ## Keyboard Words 
c197			 
c197			.KEY: 
c197				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c197 3e				db WORD_SYS_CORE+42             
c198 c7 c1			dw .WAITK            
c19a 04				db 3 + 1 
c19b .. 00			db "KEY",0              
c19f				endm 
# End of macro CWHEAD
c19f			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c19f			 
c19f					if DEBUG_FORTH_WORDS_KEY 
c19f						DMARK "KEY" 
c19f f5				push af  
c1a0 3a b4 c1			ld a, (.dmark)  
c1a3 32 c0 ee			ld (debug_mark),a  
c1a6 3a b5 c1			ld a, (.dmark+1)  
c1a9 32 c1 ee			ld (debug_mark+1),a  
c1ac 3a b6 c1			ld a, (.dmark+2)  
c1af 32 c2 ee			ld (debug_mark+2),a  
c1b2 18 03			jr .pastdmark  
c1b4 ..			.dmark: db "KEY"  
c1b7 f1			.pastdmark: pop af  
c1b8			endm  
# End of macro DMARK
c1b8						CALLMONITOR 
c1b8 cd b0 92			call break_point_state  
c1bb				endm  
# End of macro CALLMONITOR
c1bb					endif 
c1bb			; TODO currently waits 
c1bb cd 21 d8				call cin 
c1be					;call cin_wait 
c1be 6f					ld l, a 
c1bf 26 00				ld h, 0 
c1c1 cd 3d 98				call forth_push_numhl 
c1c4					NEXTW 
c1c4 c3 a6 9b			jp macro_next 
c1c7				endm 
# End of macro NEXTW
c1c7			.WAITK: 
c1c7				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c1c7 3f				db WORD_SYS_CORE+43             
c1c8 f9 c1			dw .ACCEPT            
c1ca 06				db 5 + 1 
c1cb .. 00			db "WAITK",0              
c1d1				endm 
# End of macro CWHEAD
c1d1			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c1d1					if DEBUG_FORTH_WORDS_KEY 
c1d1						DMARK "WAI" 
c1d1 f5				push af  
c1d2 3a e6 c1			ld a, (.dmark)  
c1d5 32 c0 ee			ld (debug_mark),a  
c1d8 3a e7 c1			ld a, (.dmark+1)  
c1db 32 c1 ee			ld (debug_mark+1),a  
c1de 3a e8 c1			ld a, (.dmark+2)  
c1e1 32 c2 ee			ld (debug_mark+2),a  
c1e4 18 03			jr .pastdmark  
c1e6 ..			.dmark: db "WAI"  
c1e9 f1			.pastdmark: pop af  
c1ea			endm  
# End of macro DMARK
c1ea						CALLMONITOR 
c1ea cd b0 92			call break_point_state  
c1ed				endm  
# End of macro CALLMONITOR
c1ed					endif 
c1ed cd 1b d8				call cin_wait 
c1f0 6f					ld l, a 
c1f1 26 00				ld h, 0 
c1f3 cd 3d 98				call forth_push_numhl 
c1f6					NEXTW 
c1f6 c3 a6 9b			jp macro_next 
c1f9				endm 
# End of macro NEXTW
c1f9			.ACCEPT: 
c1f9				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c1f9 40				db WORD_SYS_CORE+44             
c1fa 57 c2			dw .EDIT            
c1fc 07				db 6 + 1 
c1fd .. 00			db "ACCEPT",0              
c204				endm 
# End of macro CWHEAD
c204			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c204					; TODO crashes on push 
c204					if DEBUG_FORTH_WORDS_KEY 
c204						DMARK "ACC" 
c204 f5				push af  
c205 3a 19 c2			ld a, (.dmark)  
c208 32 c0 ee			ld (debug_mark),a  
c20b 3a 1a c2			ld a, (.dmark+1)  
c20e 32 c1 ee			ld (debug_mark+1),a  
c211 3a 1b c2			ld a, (.dmark+2)  
c214 32 c2 ee			ld (debug_mark+2),a  
c217 18 03			jr .pastdmark  
c219 ..			.dmark: db "ACC"  
c21c f1			.pastdmark: pop af  
c21d			endm  
# End of macro DMARK
c21d						CALLMONITOR 
c21d cd b0 92			call break_point_state  
c220				endm  
# End of macro CALLMONITOR
c220					endif 
c220 21 e4 e6				ld hl, os_input 
c223 3e 00				ld a, 0 
c225 77					ld (hl),a 
c226 3a cf ec				ld a,(f_cursor_ptr) 
c229 16 64				ld d, 100 
c22b 0e 00				ld c, 0 
c22d 1e 28				ld e, 40 
c22f cd 96 8a				call input_str 
c232					; TODO perhaps do a type check and wrap in quotes if not a number 
c232 21 e4 e6				ld hl, os_input 
c235					if DEBUG_FORTH_WORDS 
c235						DMARK "AC1" 
c235 f5				push af  
c236 3a 4a c2			ld a, (.dmark)  
c239 32 c0 ee			ld (debug_mark),a  
c23c 3a 4b c2			ld a, (.dmark+1)  
c23f 32 c1 ee			ld (debug_mark+1),a  
c242 3a 4c c2			ld a, (.dmark+2)  
c245 32 c2 ee			ld (debug_mark+2),a  
c248 18 03			jr .pastdmark  
c24a ..			.dmark: db "AC1"  
c24d f1			.pastdmark: pop af  
c24e			endm  
# End of macro DMARK
c24e						CALLMONITOR 
c24e cd b0 92			call break_point_state  
c251				endm  
# End of macro CALLMONITOR
c251					endif 
c251 cd ab 98				call forth_push_str 
c254					NEXTW 
c254 c3 a6 9b			jp macro_next 
c257				endm 
# End of macro NEXTW
c257			 
c257			.EDIT: 
c257				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c257 40				db WORD_SYS_CORE+44             
c258 e0 c2			dw .ENDKEY            
c25a 05				db 4 + 1 
c25b .. 00			db "EDIT",0              
c260				endm 
# End of macro CWHEAD
c260			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c260			 
c260					; TODO does not copy from stack 
c260					if DEBUG_FORTH_WORDS_KEY 
c260						DMARK "EDT" 
c260 f5				push af  
c261 3a 75 c2			ld a, (.dmark)  
c264 32 c0 ee			ld (debug_mark),a  
c267 3a 76 c2			ld a, (.dmark+1)  
c26a 32 c1 ee			ld (debug_mark+1),a  
c26d 3a 77 c2			ld a, (.dmark+2)  
c270 32 c2 ee			ld (debug_mark+2),a  
c273 18 03			jr .pastdmark  
c275 ..			.dmark: db "EDT"  
c278 f1			.pastdmark: pop af  
c279			endm  
# End of macro DMARK
c279						CALLMONITOR 
c279 cd b0 92			call break_point_state  
c27c				endm  
# End of macro CALLMONITOR
c27c					endif 
c27c			 
c27c					FORTH_DSP 
c27c cd fa 99			call macro_forth_dsp 
c27f				endm 
# End of macro FORTH_DSP
c27f					;v5 FORTH_DSP_VALUE 
c27f 23					inc hl    ; TODO do type check 
c280			 
c280 e5					push hl 
c281 3e 00				ld a, 0 
c283 cd d2 8e				call strlent 
c286 23					inc hl 
c287			 
c287 06 00				ld b, 0 
c289 4d					ld c, l 
c28a			 
c28a e1					pop hl 
c28b 11 e4 e6				ld de, os_input 
c28e					if DEBUG_FORTH_WORDS_KEY 
c28e						DMARK "EDc" 
c28e f5				push af  
c28f 3a a3 c2			ld a, (.dmark)  
c292 32 c0 ee			ld (debug_mark),a  
c295 3a a4 c2			ld a, (.dmark+1)  
c298 32 c1 ee			ld (debug_mark+1),a  
c29b 3a a5 c2			ld a, (.dmark+2)  
c29e 32 c2 ee			ld (debug_mark+2),a  
c2a1 18 03			jr .pastdmark  
c2a3 ..			.dmark: db "EDc"  
c2a6 f1			.pastdmark: pop af  
c2a7			endm  
# End of macro DMARK
c2a7						CALLMONITOR 
c2a7 cd b0 92			call break_point_state  
c2aa				endm  
# End of macro CALLMONITOR
c2aa					endif 
c2aa ed b0				ldir 
c2ac			 
c2ac			 
c2ac 21 e4 e6				ld hl, os_input 
c2af					;ld a, 0 
c2af					;ld (hl),a 
c2af 3a cf ec				ld a,(f_cursor_ptr) 
c2b2 16 64				ld d, 100 
c2b4 0e 00				ld c, 0 
c2b6 1e 28				ld e, 40 
c2b8 cd 96 8a				call input_str 
c2bb					; TODO perhaps do a type check and wrap in quotes if not a number 
c2bb 21 e4 e6				ld hl, os_input 
c2be					if DEBUG_FORTH_WORDS 
c2be						DMARK "ED1" 
c2be f5				push af  
c2bf 3a d3 c2			ld a, (.dmark)  
c2c2 32 c0 ee			ld (debug_mark),a  
c2c5 3a d4 c2			ld a, (.dmark+1)  
c2c8 32 c1 ee			ld (debug_mark+1),a  
c2cb 3a d5 c2			ld a, (.dmark+2)  
c2ce 32 c2 ee			ld (debug_mark+2),a  
c2d1 18 03			jr .pastdmark  
c2d3 ..			.dmark: db "ED1"  
c2d6 f1			.pastdmark: pop af  
c2d7			endm  
# End of macro DMARK
c2d7						CALLMONITOR 
c2d7 cd b0 92			call break_point_state  
c2da				endm  
# End of macro CALLMONITOR
c2da					endif 
c2da cd ab 98				call forth_push_str 
c2dd					NEXTW 
c2dd c3 a6 9b			jp macro_next 
c2e0				endm 
# End of macro NEXTW
c2e0			 
c2e0			 
c2e0			 
c2e0			.ENDKEY: 
c2e0			; eof 
c2e0			 
# End of file forth_words_key.asm
c2e0			 
c2e0			if STORAGE_SE 
c2e0			   	include "forth_words_storage.asm" 
c2e0			endif 
c2e0				include "forth_words_device.asm" 
c2e0			; Device related words 
c2e0			 
c2e0			; | ## Device Words 
c2e0			 
c2e0			if SOUND_ENABLE 
c2e0			.NOTE: 
c2e0				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c2e0			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c2e0					if DEBUG_FORTH_WORDS_KEY 
c2e0						DMARK "NTE" 
c2e0						CALLMONITOR 
c2e0					endif 
c2e0			 
c2e0				 
c2e0			 
c2e0					NEXTW 
c2e0			.AFTERSOUND: 
c2e0			endif 
c2e0			 
c2e0			 
c2e0			USE_GPIO: equ 0 
c2e0			 
c2e0			if USE_GPIO 
c2e0			.GP1: 
c2e0				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c2e0			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c2e0					NEXTW 
c2e0			.GP2: 
c2e0				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c2e0			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c2e0			 
c2e0					NEXTW 
c2e0			 
c2e0			.GP3: 
c2e0				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c2e0			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c2e0			 
c2e0					NEXTW 
c2e0			 
c2e0			.GP4: 
c2e0				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c2e0			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c2e0			 
c2e0					NEXTW 
c2e0			.SIN: 
c2e0			 
c2e0			 
c2e0			endif 
c2e0			 
c2e0			 
c2e0				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c2e0 33				db WORD_SYS_CORE+31             
c2e1 15 c3			dw .SOUT            
c2e3 03				db 2 + 1 
c2e4 .. 00			db "IN",0              
c2e7				endm 
# End of macro CWHEAD
c2e7			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c2e7					if DEBUG_FORTH_WORDS_KEY 
c2e7						DMARK "IN." 
c2e7 f5				push af  
c2e8 3a fc c2			ld a, (.dmark)  
c2eb 32 c0 ee			ld (debug_mark),a  
c2ee 3a fd c2			ld a, (.dmark+1)  
c2f1 32 c1 ee			ld (debug_mark+1),a  
c2f4 3a fe c2			ld a, (.dmark+2)  
c2f7 32 c2 ee			ld (debug_mark+2),a  
c2fa 18 03			jr .pastdmark  
c2fc ..			.dmark: db "IN."  
c2ff f1			.pastdmark: pop af  
c300			endm  
# End of macro DMARK
c300						CALLMONITOR 
c300 cd b0 92			call break_point_state  
c303				endm  
# End of macro CALLMONITOR
c303					endif 
c303					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c303 cd 34 9a			call macro_dsp_valuehl 
c306				endm 
# End of macro FORTH_DSP_VALUEHL
c306			 
c306 e5					push hl 
c307			 
c307					; destroy value TOS 
c307			 
c307					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c307 cd ec 9a			call macro_forth_dsp_pop 
c30a				endm 
# End of macro FORTH_DSP_POP
c30a			 
c30a					; one value on hl get other one back 
c30a			 
c30a c1					pop bc 
c30b			 
c30b					; do the sub 
c30b			;		ex de, hl 
c30b			 
c30b ed 68				in l,(c) 
c30d			 
c30d					; save it 
c30d			 
c30d 26 00				ld h,0 
c30f			 
c30f					; TODO push value back onto stack for another op etc 
c30f			 
c30f cd 3d 98				call forth_push_numhl 
c312					NEXTW 
c312 c3 a6 9b			jp macro_next 
c315				endm 
# End of macro NEXTW
c315			.SOUT: 
c315				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c315 34				db WORD_SYS_CORE+32             
c316 68 c3			dw .SPIO            
c318 04				db 3 + 1 
c319 .. 00			db "OUT",0              
c31d				endm 
# End of macro CWHEAD
c31d			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c31d					if DEBUG_FORTH_WORDS_KEY 
c31d						DMARK "OUT" 
c31d f5				push af  
c31e 3a 32 c3			ld a, (.dmark)  
c321 32 c0 ee			ld (debug_mark),a  
c324 3a 33 c3			ld a, (.dmark+1)  
c327 32 c1 ee			ld (debug_mark+1),a  
c32a 3a 34 c3			ld a, (.dmark+2)  
c32d 32 c2 ee			ld (debug_mark+2),a  
c330 18 03			jr .pastdmark  
c332 ..			.dmark: db "OUT"  
c335 f1			.pastdmark: pop af  
c336			endm  
# End of macro DMARK
c336						CALLMONITOR 
c336 cd b0 92			call break_point_state  
c339				endm  
# End of macro CALLMONITOR
c339					endif 
c339			 
c339					; get port 
c339			 
c339					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c339 cd 34 9a			call macro_dsp_valuehl 
c33c				endm 
# End of macro FORTH_DSP_VALUEHL
c33c			 
c33c e5					push hl 
c33d			 
c33d					; destroy value TOS 
c33d			 
c33d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c33d cd ec 9a			call macro_forth_dsp_pop 
c340				endm 
# End of macro FORTH_DSP_POP
c340			 
c340					; get byte to send 
c340			 
c340					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c340 cd 34 9a			call macro_dsp_valuehl 
c343				endm 
# End of macro FORTH_DSP_VALUEHL
c343			 
c343			;		push hl 
c343			 
c343					; destroy value TOS 
c343			 
c343					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c343 cd ec 9a			call macro_forth_dsp_pop 
c346				endm 
# End of macro FORTH_DSP_POP
c346			 
c346					; one value on hl get other one back 
c346			 
c346			;		pop hl 
c346			 
c346 c1					pop bc 
c347			 
c347					if DEBUG_FORTH_WORDS 
c347						DMARK "OUT" 
c347 f5				push af  
c348 3a 5c c3			ld a, (.dmark)  
c34b 32 c0 ee			ld (debug_mark),a  
c34e 3a 5d c3			ld a, (.dmark+1)  
c351 32 c1 ee			ld (debug_mark+1),a  
c354 3a 5e c3			ld a, (.dmark+2)  
c357 32 c2 ee			ld (debug_mark+2),a  
c35a 18 03			jr .pastdmark  
c35c ..			.dmark: db "OUT"  
c35f f1			.pastdmark: pop af  
c360			endm  
# End of macro DMARK
c360						CALLMONITOR 
c360 cd b0 92			call break_point_state  
c363				endm  
# End of macro CALLMONITOR
c363					endif 
c363			 
c363 ed 69				out (c), l 
c365			 
c365					NEXTW 
c365 c3 a6 9b			jp macro_next 
c368				endm 
# End of macro NEXTW
c368			 
c368			 
c368			.SPIO: 
c368			 
c368			if STORAGE_SE 
c368				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c368			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c368			 
c368					call spi_ce_low 
c368			    NEXTW 
c368			 
c368			.SPICEH: 
c368				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c368			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c368			 
c368					call spi_ce_high 
c368			    NEXTW 
c368			 
c368			 
c368			.SPIOb: 
c368			 
c368				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c368			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c368			 
c368					; get port 
c368			 
c368			 
c368					; get byte to send 
c368			 
c368					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c368			 
c368			;		push hl    ; u1  
c368			 
c368					; destroy value TOS 
c368			 
c368					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c368			 
c368					; one value on hl get other one back 
c368			 
c368			;		pop hl   ; u2 - addr 
c368			 
c368					; TODO Send SPI byte 
c368			 
c368					ld a, l 
c368					call spi_send_byte 
c368			 
c368					NEXTW 
c368			 
c368			.SPII: 
c368				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c368			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c368			 
c368					; TODO Get SPI byte 
c368			 
c368					call spi_read_byte 
c368			 
c368					ld h, 0 
c368					ld l, a 
c368					call forth_push_numhl 
c368			 
c368					NEXTW 
c368			 
c368			 
c368			 
c368			.SESEL: 
c368				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c368			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c368					if DEBUG_FORTH_WORDS_KEY 
c368						DMARK "BNK" 
c368						CALLMONITOR 
c368					endif 
c368			 
c368					ld a, 255 
c368					ld (spi_cartdev), a 
c368			 
c368					; get bank 
c368			 
c368					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c368			 
c368			;		push hl 
c368			 
c368					; destroy value TOS 
c368			 
c368					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c368			 
c368					; one value on hl get other one back 
c368			 
c368			;		pop hl 
c368			 
c368			 
c368					ld c, SPI_CE_HIGH 
c368					ld b, '0'    ; human readable bank number 
c368			 
c368					ld a, l 
c368			 
c368					if DEBUG_FORTH_WORDS 
c368						DMARK "BNK" 
c368						CALLMONITOR 
c368					endif 
c368			 
c368					; active low 
c368			 
c368					cp 0 
c368					jr z, .bset 
c368					cp 1 
c368					jr nz, .b2 
c368					res 0, c 
c368					ld b, '1'    ; human readable bank number 
c368			.b2:		cp 2 
c368					jr nz, .b3 
c368					res 1, c 
c368					ld b, '2'    ; human readable bank number 
c368			.b3:		cp 3 
c368					jr nz, .b4 
c368					res 2, c 
c368					ld b, '3'    ; human readable bank number 
c368			.b4:		cp 4 
c368					jr nz, .b5 
c368					res 3, c 
c368					ld b, '4'    ; human readable bank number 
c368			.b5:		cp 5 
c368					jr nz, .bset 
c368					res 4, c 
c368					ld b, '5'    ; human readable bank number 
c368			 
c368			.bset: 
c368					ld a, c 
c368					ld (spi_device),a 
c368					ld a, b 
c368					ld (spi_device_id),a 
c368					if DEBUG_FORTH_WORDS 
c368						DMARK "BN2" 
c368						CALLMONITOR 
c368					endif 
c368			 
c368					NEXTW 
c368			 
c368			.CARTDEV: 
c368				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c368			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c368					if DEBUG_FORTH_WORDS_KEY 
c368						DMARK "CDV" 
c368						CALLMONITOR 
c368					endif 
c368			 
c368					; disable se storage bank selection 
c368			 
c368					ld a, SPI_CE_HIGH		; ce high 
c368					ld (spi_device), a 
c368			 
c368					; get bank 
c368			 
c368					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c368			 
c368			;		push hl 
c368			 
c368					; destroy value TOS 
c368			 
c368					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c368			 
c368					; one value on hl get other one back 
c368			 
c368			;		pop hl 
c368			 
c368					; active low 
c368			 
c368					ld c, 255 
c368			 
c368					ld a, l 
c368					if DEBUG_FORTH_WORDS 
c368						DMARK "CDV" 
c368						CALLMONITOR 
c368					endif 
c368					cp 0 
c368					jr z, .cset 
c368					cp 1 
c368					jr nz, .c2 
c368					res 0, c 
c368			.c2:		cp 2 
c368					jr nz, .c3 
c368					res 1, c 
c368			.c3:		cp 3 
c368					jr nz, .c4 
c368					res 2, c 
c368			.c4:		cp 4 
c368					jr nz, .c5 
c368					res 3, c 
c368			.c5:		cp 5 
c368					jr nz, .c6 
c368					res 4, c 
c368			.c6:		cp 6 
c368					jr nz, .c7 
c368					res 5, c 
c368			.c7:		cp 7 
c368					jr nz, .c8 
c368					res 6, c 
c368			.c8:		cp 8 
c368					jr nz, .cset 
c368					res 7, c 
c368			.cset:		ld a, c 
c368					ld (spi_cartdev),a 
c368			 
c368					if DEBUG_FORTH_WORDS 
c368						DMARK "CD2" 
c368						CALLMONITOR 
c368					endif 
c368					NEXTW 
c368			endif 
c368			 
c368			.ENDDEVICE: 
c368			; eof 
c368			 
# End of file forth_words_device.asm
c368			 
c368			; var handler 
c368			 
c368			 
c368			.VARS: 
c368				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c368 78				db WORD_SYS_CORE+100             
c369 80 c3			dw .V0Q            
c36b 04				db 3 + 1 
c36c .. 00			db "V0!",0              
c370				endm 
# End of macro CWHEAD
c370			;| V0! ( u1 -- )  Store value to v0  | DONE 
c370			 
c370					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c370 cd 34 9a			call macro_dsp_valuehl 
c373				endm 
# End of macro FORTH_DSP_VALUEHL
c373			 
c373 11 99 ec				ld de, cli_var_array 
c376			 
c376 eb					ex de, hl 
c377 73					ld (hl), e 
c378 23					inc hl 
c379 72					ld (hl), d 
c37a			 
c37a					; destroy value TOS 
c37a			 
c37a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c37a cd ec 9a			call macro_forth_dsp_pop 
c37d				endm 
# End of macro FORTH_DSP_POP
c37d			 
c37d				       NEXTW 
c37d c3 a6 9b			jp macro_next 
c380				endm 
# End of macro NEXTW
c380			.V0Q: 
c380				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c380 79				db WORD_SYS_CORE+101             
c381 91 c3			dw .V1S            
c383 04				db 3 + 1 
c384 .. 00			db "V0@",0              
c388				endm 
# End of macro CWHEAD
c388			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c388 2a 99 ec				ld hl, (cli_var_array) 
c38b cd 3d 98				call forth_push_numhl 
c38e			 
c38e				       NEXTW 
c38e c3 a6 9b			jp macro_next 
c391				endm 
# End of macro NEXTW
c391			.V1S: 
c391				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c391 7a				db WORD_SYS_CORE+102             
c392 a9 c3			dw .V1Q            
c394 04				db 3 + 1 
c395 .. 00			db "V1!",0              
c399				endm 
# End of macro CWHEAD
c399			;| V1! ( u1 -- )  Store value to v1 | DONE 
c399					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c399 cd 34 9a			call macro_dsp_valuehl 
c39c				endm 
# End of macro FORTH_DSP_VALUEHL
c39c			 
c39c 11 9b ec				ld de, cli_var_array+2 
c39f				 
c39f eb					ex de, hl 
c3a0 73					ld (hl), e 
c3a1 23					inc hl 
c3a2 72					ld (hl), d 
c3a3			 
c3a3					; destroy value TOS 
c3a3			 
c3a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3a3 cd ec 9a			call macro_forth_dsp_pop 
c3a6				endm 
# End of macro FORTH_DSP_POP
c3a6				       NEXTW 
c3a6 c3 a6 9b			jp macro_next 
c3a9				endm 
# End of macro NEXTW
c3a9			.V1Q: 
c3a9				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c3a9 7b				db WORD_SYS_CORE+103             
c3aa ba c3			dw .V2S            
c3ac 04				db 3 + 1 
c3ad .. 00			db "V1@",0              
c3b1				endm 
# End of macro CWHEAD
c3b1			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c3b1 2a 9b ec				ld hl, (cli_var_array+2) 
c3b4 cd 3d 98				call forth_push_numhl 
c3b7				       NEXTW 
c3b7 c3 a6 9b			jp macro_next 
c3ba				endm 
# End of macro NEXTW
c3ba			.V2S: 
c3ba				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c3ba 7c				db WORD_SYS_CORE+104             
c3bb d2 c3			dw .V2Q            
c3bd 04				db 3 + 1 
c3be .. 00			db "V2!",0              
c3c2				endm 
# End of macro CWHEAD
c3c2			;| V2! ( u1 -- )  Store value to v2 | DONE 
c3c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3c2 cd 34 9a			call macro_dsp_valuehl 
c3c5				endm 
# End of macro FORTH_DSP_VALUEHL
c3c5			 
c3c5 11 9d ec				ld de, cli_var_array+4 
c3c8				 
c3c8 eb					ex de, hl 
c3c9 73					ld (hl), e 
c3ca 23					inc hl 
c3cb 72					ld (hl), d 
c3cc			 
c3cc					; destroy value TOS 
c3cc			 
c3cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3cc cd ec 9a			call macro_forth_dsp_pop 
c3cf				endm 
# End of macro FORTH_DSP_POP
c3cf				       NEXTW 
c3cf c3 a6 9b			jp macro_next 
c3d2				endm 
# End of macro NEXTW
c3d2			.V2Q: 
c3d2				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c3d2 7d				db WORD_SYS_CORE+105             
c3d3 e3 c3			dw .V3S            
c3d5 04				db 3 + 1 
c3d6 .. 00			db "V2@",0              
c3da				endm 
# End of macro CWHEAD
c3da			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c3da 2a 9d ec				ld hl, (cli_var_array+4) 
c3dd cd 3d 98				call forth_push_numhl 
c3e0				       NEXTW 
c3e0 c3 a6 9b			jp macro_next 
c3e3				endm 
# End of macro NEXTW
c3e3			.V3S: 
c3e3				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c3e3 7c				db WORD_SYS_CORE+104             
c3e4 fb c3			dw .V3Q            
c3e6 04				db 3 + 1 
c3e7 .. 00			db "V3!",0              
c3eb				endm 
# End of macro CWHEAD
c3eb			;| V3! ( u1 -- )  Store value to v3 | DONE 
c3eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3eb cd 34 9a			call macro_dsp_valuehl 
c3ee				endm 
# End of macro FORTH_DSP_VALUEHL
c3ee			 
c3ee 11 9f ec				ld de, cli_var_array+6 
c3f1				 
c3f1 eb					ex de, hl 
c3f2 73					ld (hl), e 
c3f3 23					inc hl 
c3f4 72					ld (hl), d 
c3f5			 
c3f5					; destroy value TOS 
c3f5			 
c3f5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3f5 cd ec 9a			call macro_forth_dsp_pop 
c3f8				endm 
# End of macro FORTH_DSP_POP
c3f8				       NEXTW 
c3f8 c3 a6 9b			jp macro_next 
c3fb				endm 
# End of macro NEXTW
c3fb			.V3Q: 
c3fb				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c3fb 7d				db WORD_SYS_CORE+105             
c3fc 0c c4			dw .END            
c3fe 04				db 3 + 1 
c3ff .. 00			db "V3@",0              
c403				endm 
# End of macro CWHEAD
c403			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c403 2a 9f ec				ld hl, (cli_var_array+6) 
c406 cd 3d 98				call forth_push_numhl 
c409				       NEXTW 
c409 c3 a6 9b			jp macro_next 
c40c				endm 
# End of macro NEXTW
c40c			 
c40c			 
c40c			 
c40c			 
c40c			 
c40c			; end of dict marker 
c40c			 
c40c 00			.END:    db WORD_SYS_END 
c40d 00 00			dw 0 
c40f 00				db 0 
c410			 
c410			; use to jp here for user dict words to save on macro expansion  
c410			 
c410			user_dict_next: 
c410				NEXTW 
c410 c3 a6 9b			jp macro_next 
c413				endm 
# End of macro NEXTW
c413			 
c413			 
c413			user_exec: 
c413				;    ld hl, <word code> 
c413				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c413				;    call forthexec 
c413				;    jp user_dict_next   (NEXT) 
c413			        ;    <word code bytes> 
c413 eb				ex de, hl 
c414 2a e7 e7			ld hl,(os_tok_ptr) 
c417				 
c417				FORTH_RSP_NEXT 
c417 cd e4 97			call macro_forth_rsp_next 
c41a				endm 
# End of macro FORTH_RSP_NEXT
c41a			 
c41a			if DEBUG_FORTH_UWORD 
c41a						DMARK "UEX" 
c41a f5				push af  
c41b 3a 2f c4			ld a, (.dmark)  
c41e 32 c0 ee			ld (debug_mark),a  
c421 3a 30 c4			ld a, (.dmark+1)  
c424 32 c1 ee			ld (debug_mark+1),a  
c427 3a 31 c4			ld a, (.dmark+2)  
c42a 32 c2 ee			ld (debug_mark+2),a  
c42d 18 03			jr .pastdmark  
c42f ..			.dmark: db "UEX"  
c432 f1			.pastdmark: pop af  
c433			endm  
# End of macro DMARK
c433				CALLMONITOR 
c433 cd b0 92			call break_point_state  
c436				endm  
# End of macro CALLMONITOR
c436			endif 
c436			 
c436			 
c436			 
c436 eb				ex de, hl 
c437 22 e7 e7			ld (os_tok_ptr), hl 
c43a				 
c43a				; Don't use next - Skips the first word in uword. 
c43a			 
c43a c3 37 9c			jp exec1 
c43d			;	NEXT 
c43d			 
c43d			 
c43d			; eof 
# End of file forth_wordsv4.asm
c43d			endif 
c43d			;;;;;;;;;;;;;; Debug code 
c43d			 
c43d			 
c43d			;if DEBUG_FORTH_PARSE 
c43d .. 00		.nowordfound: db "No match",0 
c446 .. 00		.compword:	db "Comparing word ",0 
c456 .. 00		.nextwordat:	db "Next word at",0 
c463 .. 00		.charmatch:	db "Char match",0 
c46e			;endif 
c46e			if DEBUG_FORTH_JP 
c46e			.foundword:	db "Word match. Exec..",0 
c46e			endif 
c46e			;if DEBUG_FORTH_PUSH 
c46e .. 00		.enddict:	db "Dict end. Push.",0 
c47e .. 00		.push_str:	db "Pushing string",0 
c48d .. 00		.push_num:	db "Pushing number",0 
c49c .. 00		.data_sp:	db "SP:",0 
c4a0 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c4b2 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c4c4 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c4d6			;endif 
c4d6			;if DEBUG_FORTH_MALLOC 
c4d6 .. 00		.push_malloc:	db "Malloc address",0 
c4e5			;endif 
c4e5			 
c4e5			 
c4e5			 
c4e5			; display malloc address and current data stack pointer  
c4e5			 
c4e5			malloc_error: 
c4e5 d5				push de 
c4e6 f5				push af 
c4e7 e5				push hl 
c4e8 cd 3c 88			call clear_display 
c4eb 11 0d c5			ld de, .mallocerr 
c4ee 3e 00			ld a,0 
c4f0			;	ld de,os_word_scratch 
c4f0 cd 4f 88			call str_at_display 
c4f3 3e 11			ld a, display_row_1+17 
c4f5 11 c0 ee			ld de, debug_mark 
c4f8 cd 4f 88			call str_at_display 
c4fb cd 5f 88			call update_display 
c4fe				;call break_point_state 
c4fe cd 1b d8			call cin_wait 
c501			 
c501 3e 20			ld a, ' ' 
c503 32 d7 e4			ld (os_view_disable), a 
c506 e1				pop hl 
c507 f1				pop af 
c508 d1				pop de	 
c509				CALLMONITOR 
c509 cd b0 92			call break_point_state  
c50c				endm  
# End of macro CALLMONITOR
c50c c9				ret 
c50d			 
c50d .. 00		.mallocerr: 	db "Malloc Error",0 
c51a			;if DEBUG_FORTH_PUSH 
c51a			display_data_sp: 
c51a f5				push af 
c51b			 
c51b				; see if disabled 
c51b			 
c51b 3a d7 e4			ld a, (os_view_disable) 
c51e fe 2a			cp '*' 
c520 28 67			jr z, .skipdsp 
c522			 
c522 e5				push hl 
c523 e5				push hl 
c524 e5			push hl 
c525 cd 3c 88			call clear_display 
c528 e1			pop hl 
c529 7c				ld a,h 
c52a 21 eb e7			ld hl, os_word_scratch 
c52d cd 6a 8d			call hexout 
c530 e1				pop hl 
c531 7d				ld a,l 
c532 21 ed e7			ld hl, os_word_scratch+2 
c535 cd 6a 8d			call hexout 
c538 21 ef e7			ld hl, os_word_scratch+4 
c53b 3e 00			ld a,0 
c53d 77				ld (hl),a 
c53e 11 eb e7			ld de,os_word_scratch 
c541 3e 14				ld a, display_row_2 
c543 cd 4f 88				call str_at_display 
c546 11 a0 c4			ld de, .wordinhl 
c549 3e 00			ld a, display_row_1 
c54b			 
c54b cd 4f 88				call str_at_display 
c54e 11 c0 ee			ld de, debug_mark 
c551 3e 11			ld a, display_row_1+17 
c553			 
c553 cd 4f 88				call str_at_display 
c556			 
c556				; display current data stack pointer 
c556 11 9c c4			ld de,.data_sp 
c559 3e 1c				ld a, display_row_2 + 8 
c55b cd 4f 88				call str_at_display 
c55e			 
c55e 2a 93 ec			ld hl,(cli_data_sp) 
c561 e5				push hl 
c562 7c				ld a,h 
c563 21 eb e7			ld hl, os_word_scratch 
c566 cd 6a 8d			call hexout 
c569 e1				pop hl 
c56a 7d				ld a,l 
c56b 21 ed e7			ld hl, os_word_scratch+2 
c56e cd 6a 8d			call hexout 
c571 21 ef e7			ld hl, os_word_scratch+4 
c574 3e 00			ld a,0 
c576 77				ld (hl),a 
c577 11 eb e7			ld de,os_word_scratch 
c57a 3e 1f				ld a, display_row_2 + 11 
c57c cd 4f 88				call str_at_display 
c57f			 
c57f			 
c57f cd 5f 88			call update_display 
c582 cd ea 87			call delay1s 
c585 cd ea 87			call delay1s 
c588 e1				pop hl 
c589			.skipdsp: 
c589 f1				pop af 
c58a c9				ret 
c58b			 
c58b			display_data_malloc: 
c58b			 
c58b f5				push af 
c58c e5				push hl 
c58d e5				push hl 
c58e e5			push hl 
c58f cd 3c 88			call clear_display 
c592 e1			pop hl 
c593 7c				ld a,h 
c594 21 eb e7			ld hl, os_word_scratch 
c597 cd 6a 8d			call hexout 
c59a e1				pop hl 
c59b 7d				ld a,l 
c59c 21 ed e7			ld hl, os_word_scratch+2 
c59f cd 6a 8d			call hexout 
c5a2 21 ef e7			ld hl, os_word_scratch+4 
c5a5 3e 00			ld a,0 
c5a7 77				ld (hl),a 
c5a8 11 eb e7			ld de,os_word_scratch 
c5ab 3e 14				ld a, display_row_2 
c5ad cd 4f 88				call str_at_display 
c5b0 11 d6 c4			ld de, .push_malloc 
c5b3 3e 00			ld a, display_row_1 
c5b5			 
c5b5 cd 4f 88				call str_at_display 
c5b8			 
c5b8				; display current data stack pointer 
c5b8 11 9c c4			ld de,.data_sp 
c5bb 3e 1c				ld a, display_row_2 + 8 
c5bd cd 4f 88				call str_at_display 
c5c0			 
c5c0 2a 93 ec			ld hl,(cli_data_sp) 
c5c3 e5				push hl 
c5c4 7c				ld a,h 
c5c5 21 eb e7			ld hl, os_word_scratch 
c5c8 cd 6a 8d			call hexout 
c5cb e1				pop hl 
c5cc 7d				ld a,l 
c5cd 21 ed e7			ld hl, os_word_scratch+2 
c5d0 cd 6a 8d			call hexout 
c5d3 21 ef e7			ld hl, os_word_scratch+4 
c5d6 3e 00			ld a,0 
c5d8 77				ld (hl),a 
c5d9 11 eb e7			ld de,os_word_scratch 
c5dc 3e 1f				ld a, display_row_2 + 11 
c5de cd 4f 88				call str_at_display 
c5e1			 
c5e1 cd 5f 88			call update_display 
c5e4 cd ea 87			call delay1s 
c5e7 cd ea 87			call delay1s 
c5ea e1				pop hl 
c5eb f1				pop af 
c5ec c9				ret 
c5ed			;endif 
c5ed			 
c5ed			include "forth_autostart.asm" 
c5ed			; list of commands to perform at system start up 
c5ed			 
c5ed			startcmds: 
c5ed			;	dw test11 
c5ed			;	dw test12 
c5ed			;	dw test13 
c5ed			;	dw test14 
c5ed			;	dw test15 
c5ed			;	dw test16 
c5ed			;	dw test17 
c5ed			;	dw ifthtest1 
c5ed			;	dw ifthtest2 
c5ed			;	dw ifthtest3 
c5ed			;	dw mmtest1 
c5ed			;	dw mmtest2 
c5ed			;	dw mmtest3 
c5ed			;	dw mmtest4 
c5ed			;	dw mmtest5 
c5ed			;	dw mmtest6 
c5ed			;	dw iftest1 
c5ed			;	dw iftest2 
c5ed			;	dw iftest3 
c5ed			;	dw looptest1 
c5ed			;	dw looptest2 
c5ed			;	dw test1 
c5ed			;	dw test2 
c5ed			;	dw test3 
c5ed			;	dw test4 
c5ed			;	dw game2r 
c5ed			;	dw game2b1 
c5ed			;	dw game2b2 
c5ed			 
c5ed				; start up words that are actually useful 
c5ed			 
c5ed 4b c6			dw clrstack 
c5ef 7e c6			dw type 
c5f1 3f c8			dw stest 
c5f3 a2 c6			dw strncpy 
c5f5 e0 c7			dw list 
c5f7 03 c7			dw start1 
c5f9 15 c7			dw start2 
c5fb			;	dw start3 
c5fb 28 c7			dw start3b 
c5fd 80 c7			dw start3c 
c5ff			 
c5ff				; (unit) testing words 
c5ff			 
c5ff b6 c8			dw mtesta 
c601 6b c9			dw mtestb 
c603 0e ca			dw mtestc 
c605 c3 ca			dw mtestd 
c607 67 cb			dw mteste 
c609			 
c609				; demo/game words 
c609			 
c609 73 d2		        dw game3w 
c60b a1 d2		        dw game3p 
c60d bf d2		        dw game3sc 
c60f f0 d2		        dw game3vsi 
c611 1c d3		        dw game3vs 
c613				 
c613 66 d0			dw game2b 
c615 d4 d0			dw game2bf 
c617 1e d1			dw game2mba 
c619 b4 d1			dw game2mbas 
c61b f6 d1			dw game2mb 
c61d			 
c61d 27 cd			dw game1 
c61f 38 cd			dw game1a 
c621 9a cd			dw game1b 
c623 cf cd			dw game1c 
c625 05 ce			dw game1d 
c627 36 ce			dw game1s 
c629 4a ce			dw game1t 
c62b 5f ce			dw game1f 
c62d 93 ce			dw game1z 
c62f d7 ce			dw game1zz 
c631			 
c631 1d cc			dw test5 
c633 55 cc			dw test6 
c635 8d cc			dw test7 
c637 a1 cc			dw test8 
c639 cd cc			dw test9 
c63b e3 cc			dw test10 
c63d				 
c63d ae cf		        dw ssv5 
c63f 92 cf		        dw ssv4 
c641 76 cf		        dw ssv3 
c643 40 cf		        dw ssv2 
c645 c7 cf		        dw ssv1 
c647 0f d0		        dw ssv1cpm 
c649			;	dw keyup 
c649			;	dw keydown 
c649			;	dw keyleft 
c649			;	dw keyright 
c649			;	dw 	keyf1 
c649			;	dw keyf2 
c649			;	dw keyf3 
c649			;	dw keyf4 
c649			;	dw keyf5 
c649			;	dw keyf6 
c649			;	dw keyf7 
c649			;	dw keyf8 
c649			;	dw keyf9 
c649			;	dw keyf10 
c649			;	dw keyf11 
c649			;	dw keyf12 
c649			;	dw keytab 
c649			;	dw keycr 
c649			;	dw keyhome 
c649			;	dw keyend 
c649			;	dw keybs 
c649 00 00			db 0, 0	 
c64b			 
c64b			 
c64b			; clear stack  
c64b			 
c64b .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c67e			 
c67e			; type ( addr count - ) 
c67e .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c6a2			 
c6a2			; some direct memory words 
c6a2			; strncpy ( len t f -- t ) 
c6a2			 
c6a2 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c703			 
c703 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c715 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c728			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c728 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c780 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c7e0			 
c7e0			 
c7e0			; a handy word to list items on the stack 
c7e0			 
c7e0 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c83f			 
c83f			 
c83f			; test stack  
c83f			; rnd8 stest 
c83f			 
c83f .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c8b6			 
c8b6			; random malloc and free cycles 
c8b6			 
c8b6 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c96b			 
c96b			; fixed malloc and free cycles 
c96b			 
c96b .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
ca0e			 
ca0e			; fixed double string push and drop cycle  
ca0e			 
ca0e .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
cac3			 
cac3			; consistent fixed string push and drop cycle  
cac3			 
cac3 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cb67			 
cb67 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cc1d			 
cc1d			;test1:		db ": aa 1 2 3 ;", 0 
cc1d			;test2:     	db "111 aa 888 999",0 
cc1d			;test3:     	db ": bb 77 ;",0 
cc1d			;test4:     	db "$02 $01 do i . loop bb",0 
cc1d			 
cc1d .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cc55 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cc8d .. 00		test7:     	db ": box hline vline ;",0 
cca1 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cccd .. 00		test9:     	db ": sw $01 adsp world ;",0 
cce3 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cd08 .. 00		test11:     	db "hello create .",0 
cd17 .. 00		test12:     	db "hello2 create .",0 
cd27			 
cd27			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cd27			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cd27			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cd27			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cd27			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cd27			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cd27			 
cd27			;iftest1:     	db "$0001 IF cls .",0 
cd27			;iftest2:     	db "$0000 IF cls .",0 
cd27			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cd27			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cd27			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cd27			 
cd27			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cd27			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cd27			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cd27			 
cd27			 
cd27			 
cd27			; a small guess the number game 
cd27			 
cd27 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cd38 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
cd9a			 
cd9a .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
cdcf .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
ce05 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
ce36 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
ce4a .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
ce5f .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
ce93 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
ced7			 
ced7			; Using 'ga' save a high score across multiple runs using external storage 
ced7			 
ced7 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
cf40			 
cf40			 
cf40			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
cf40			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
cf40			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
cf40			 
cf40			; simple screen saver to test code memory reuse to destruction 
cf40			 
cf40 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
cf76 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
cf92 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
cfae .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
cfc7 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d00f .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d066			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d066			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d066			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d066			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d066			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d066			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d066			 
d066			 
d066			 
d066			; minesweeper/battleship finding game 
d066			; draws a game board of random ship/mine positions 
d066			; user enters coords to see if it hits on 
d066			; game ends when all are hit 
d066			; when hit or miss says how many may be in the area 
d066			 
d066			; setup the game board and then hide it 
d066 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d0d4 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d11e			; prompt for where to target 
d11e .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d1b4 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d1d9			; TODO see if the entered coords hits or misses pushes char hit of miss 
d1d9 .. 00		game2mbht:      db ": mbckht nop ;",0 
d1e8 .. 00		game2mbms:      db ": mbcms nop ;",0 
d1f6			; TODO how many might be near by 
d1f6 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d273			 
d273			; Game 3 
d273			 
d273			; Vert scroller ski game - avoid the trees! 
d273			 
d273			; v0 score (ie turns) 
d273			; v1 player pos 
d273			; v2 left wall 
d273			; v3 right wall 
d273			 
d273			; Draw side walls randomly 
d273			 
d273 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d2a1			 
d2a1			; Draw player 
d2a1 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d2bf			 
d2bf			; TODO Get Key 
d2bf			 
d2bf			; TODO Move left right 
d2bf			 
d2bf			; scroll and move walls a bit 
d2bf			 
d2bf .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d2f0			 
d2f0			; main game loop 
d2f0			 
d2f0 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d31c .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d35b			 
d35b			; key board defs 
d35b			 
d35b .. 00		keyup:       db ": keyup $05 ;",0 
d369 .. 00		keydown:       db ": keydown $0a ;",0 
d379 .. 00		keyleft:       db ": keyleft $0b ;",0 
d389 .. 00		keyright:       db ": keyright $0c ;",0 
d39a .. 00		keyf1:       db ": keyf1 $10 ;",0 
d3a8 .. 00		keyf2:       db ": keyf2 $11 ;",0 
d3b6 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d3c4 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d3d2 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d3e0 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d3ee .. 00		keyf7:       db ": keyf7 $16 ;",0 
d3fc .. 00		keyf8:       db ": keyf8 $17 ;",0 
d40a .. 00		keyf9:       db ": keyf9 $18 ;",0 
d418 .. 00		keyf10:       db ": keyf10 $19 ;",0 
d427 .. 00		keyf11:       db ": keyf11 $1a ;",0 
d436 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d445			 
d445 .. 00		keytab:       db ": keytab $09 ;",0 
d454 .. 00		keycr:       db ": keycr $0d ;",0 
d462 .. 00		keyhome:       db ": keyhome $0e ;",0 
d472 .. 00		keyend:       db ": keyend $0f ;",0 
d481 .. 00		keybs:       db ": keybs $08 ;",0 
d48f			 
d48f			   
d48f			 
d48f			 
d48f			 
d48f			; eof 
# End of file forth_autostart.asm
d48f			 
d48f .. 00		sprompt1: db "Startup load...",0 
d49f .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d4b5			 
d4b5			forth_startup: 
d4b5 21 ed c5			ld hl, startcmds 
d4b8 3e 00			ld a, 0 
d4ba 32 0c e9			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d4bd			 
d4bd e5			.start1:	push hl 
d4be cd 3c 88			call clear_display 
d4c1 11 8f d4			ld de, sprompt1 
d4c4 3e 00		        ld a, display_row_1 
d4c6 cd 4f 88			call str_at_display 
d4c9 11 9f d4			ld de, sprompt2 
d4cc 3e 14		        ld a, display_row_2 
d4ce cd 4f 88			call str_at_display 
d4d1 e1				pop hl 
d4d2 e5				push hl 
d4d3 5e				ld e,(hl) 
d4d4 23				inc hl 
d4d5 56				ld d,(hl) 
d4d6 3e 28		        ld a, display_row_3 
d4d8 cd 4f 88			call str_at_display 
d4db cd 5f 88			call update_display 
d4de			 
d4de			 
d4de 3a 0c e9			ld a, (os_last_cmd) 
d4e1 fe 00			cp 0 
d4e3 28 05			jr z, .startprompt 
d4e5 cd de 87			call delay250ms 
d4e8 18 24			jr .startdo 
d4ea				 
d4ea				 
d4ea			 
d4ea			.startprompt: 
d4ea			 
d4ea 3e 4f			ld a,display_row_4 + display_cols - 1 
d4ec 11 b3 97		        ld de, endprg 
d4ef cd 4f 88			call str_at_display 
d4f2 cd 5f 88			call update_display 
d4f5 cd ea 87			call delay1s 
d4f8 cd 1b d8			call cin_wait 
d4fb						 
d4fb fe 2a			cp '*' 
d4fd 28 5e			jr z, .startupend1 
d4ff fe 23			cp '#' 
d501 20 07			jr nz, .startno 
d503 3e 01			ld a, 1 
d505 32 0c e9			ld (os_last_cmd),a 
d508 18 04			jr .startdo 
d50a fe 31		.startno:	cp '1' 
d50c 28 3a			jr z,.startnxt  
d50e			 
d50e				; exec startup line 
d50e			.startdo:	 
d50e e1				pop hl 
d50f e5				push hl 
d510				 
d510 5e				ld e,(hl) 
d511 23				inc hl 
d512 56				ld d,(hl) 
d513 eb				ex de,hl 
d514			 
d514 e5				push hl 
d515			 
d515 3e 00			ld a, 0 
d517				;ld a, FORTH_END_BUFFER 
d517 cd d2 8e			call strlent 
d51a 23				inc hl   ; include zero term to copy 
d51b 06 00			ld b,0 
d51d 4d				ld c,l 
d51e e1				pop hl 
d51f 11 e6 e4			ld de, scratch 
d522 ed b0			ldir 
d524			 
d524			 
d524 21 e6 e4			ld hl, scratch 
d527 cd f4 9b			call forthparse 
d52a cd 34 9c			call forthexec 
d52d cd 4b 9b			call forthexec_cleanup 
d530			 
d530 3e 3c			ld a, display_row_4 
d532 11 57 95			ld de, endprog 
d535			 
d535 cd 5f 88			call update_display		 
d538			 
d538 3a 0c e9			ld a, (os_last_cmd) 
d53b fe 00			cp 0 
d53d 20 09			jr nz, .startnxt 
d53f cd b5 97			call next_page_prompt 
d542 cd 3c 88		        call clear_display 
d545 cd 5f 88			call update_display		 
d548			 
d548				; move onto next startup line? 
d548			.startnxt: 
d548			 
d548 cd de 87			call delay250ms 
d54b e1				pop hl 
d54c			 
d54c 23				inc hl 
d54d 23				inc hl 
d54e			 
d54e e5				push hl 
d54f 5e				ld e, (hl) 
d550 23				inc hl 
d551 56				ld d, (hl) 
d552 e1				pop hl 
d553				; TODO replace 0 test 
d553			 
d553 eb				ex de, hl 
d554 cd 92 8a			call ishlzero 
d557			;	ld a,e 
d557			;	add d 
d557			;	cp 0    ; any left to do? 
d557 eb				ex de, hl 
d558 c2 bd d4			jp nz, .start1 
d55b 18 01			jr .startupend 
d55d			 
d55d e1			.startupend1: pop hl 
d55e			.startupend: 
d55e			 
d55e cd 3c 88			call clear_display 
d561 cd 5f 88			call update_display 
d564 c9				ret 
d565			 
d565			 
d565			; stack over and underflow checks 
d565			 
d565			; init the words to detect the under/overflow 
d565			 
d565			chk_stk_init: 
d565				; a vague random number to check so we dont get any "lucky" hits 
d565 3e 2d			ld a, 45 
d567 6f				ld l, a 
d568 00				nop 
d569 3e 17			ld a, 23 
d56b 67				ld h, a 
d56c			 
d56c 22 cd e4			ld (chk_word), hl     ; the word we need to check against 
d56f			 
d56f			;	ld (chk_stund), hl	; stack points.... 
d56f 22 00 ef			ld (chk_stovr), hl 
d572 22 91 ec			ld (chk_ret_und), hl 
d575 22 4f ec			ld (chk_ret_ovr), hl 
d578 22 4d eb			ld (chk_loop_ovr), hl 
d57b 22 4b ea			ld (chk_data_ovr), hl 
d57e c9				ret 
d57f				 
d57f			check_stacks: 
d57f				; check all stack words 
d57f			 
d57f e5				push hl 
d580 d5				push de 
d581			 
d581			;	ld de,(chk_word) 
d581			;	ld hl, (chk_stund)	; stack points.... 
d581			;	if DEBUG_STK_FAULT 
d581			;		DMARK "FAa" 
d581			;		CALLMONITOR 
d581			;	endif 
d581			;	call cmp16 
d581			;	jp z, .chk_faulta 
d581			; 
d581			;	ld de, sfaultsu 
d581			;	jp .chk_fault 
d581			 
d581 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d584 ed 5b cd e4		ld de,(chk_word) 
d588				if DEBUG_STK_FAULT 
d588					DMARK "FAb" 
d588					CALLMONITOR 
d588				endif 
d588 cd 87 8a			call cmp16 
d58b 28 06			jr z, .chk_fault1 
d58d 11 2e d6			ld de, sfaultso 
d590 c3 e2 d5			jp .chk_fault 
d593			.chk_fault1:  
d593 2a 91 ec			ld hl, (chk_ret_und) 
d596 ed 5b cd e4		ld de,(chk_word) 
d59a				if DEBUG_STK_FAULT 
d59a					DMARK "FAU" 
d59a					CALLMONITOR 
d59a				endif 
d59a cd 87 8a			call cmp16 
d59d ca a6 d5			jp z, .chk_fault2 
d5a0 11 3e d6			ld de, sfaultru 
d5a3 c3 e2 d5			jp .chk_fault 
d5a6			.chk_fault2:  
d5a6 2a 4f ec			ld hl, (chk_ret_ovr) 
d5a9 ed 5b cd e4		ld de,(chk_word) 
d5ad				if DEBUG_STK_FAULT 
d5ad					DMARK "FA1" 
d5ad					CALLMONITOR 
d5ad				endif 
d5ad cd 87 8a			call cmp16 
d5b0 ca b9 d5			jp z, .chk_fault3 
d5b3 11 4c d6			ld de, sfaultro 
d5b6 c3 e2 d5			jp .chk_fault 
d5b9			.chk_fault3:  
d5b9 2a 4d eb			ld hl, (chk_loop_ovr) 
d5bc ed 5b cd e4		ld de,(chk_word) 
d5c0				if DEBUG_STK_FAULT 
d5c0					DMARK "FA2" 
d5c0					CALLMONITOR 
d5c0				endif 
d5c0 cd 87 8a			call cmp16 
d5c3 ca cc d5			jp z, .chk_fault4 
d5c6 11 66 d6			ld de, sfaultlo 
d5c9 c3 e2 d5			jp .chk_fault 
d5cc			.chk_fault4:  
d5cc 2a 4b ea			ld hl, (chk_data_ovr) 
d5cf ed 5b cd e4		ld de,(chk_word) 
d5d3				if DEBUG_STK_FAULT 
d5d3					DMARK "FA3" 
d5d3					CALLMONITOR 
d5d3				endif 
d5d3 cd 87 8a			call cmp16 
d5d6 ca df d5			jp z, .chk_fault5 
d5d9 11 80 d6			ld de, sfaultdo 
d5dc c3 e2 d5			jp .chk_fault 
d5df			 
d5df			 
d5df			.chk_fault5:  
d5df d1				pop de 
d5e0 e1				pop hl 
d5e1			 
d5e1 c9				ret 
d5e2			 
d5e2 cd 3c 88		.chk_fault: 	call clear_display 
d5e5 3e 14				ld a, display_row_2 
d5e7 cd 4f 88				call str_at_display 
d5ea 11 10 d6				   ld de, .stackfault 
d5ed 3e 00				ld a, display_row_1 
d5ef cd 4f 88				call str_at_display 
d5f2 11 c0 ee				    ld de, debug_mark 
d5f5 3e 11				ld a, display_row_1+17 
d5f7 cd 4f 88				call str_at_display 
d5fa cd 5f 88				call update_display 
d5fd			 
d5fd				; prompt before entering montior for investigating issue 
d5fd			 
d5fd 3e 3c			ld a, display_row_4 
d5ff 11 57 95			ld de, endprog 
d602			 
d602 cd 5f 88			call update_display		 
d605			 
d605 cd b5 97			call next_page_prompt 
d608			 
d608 d1				pop de 
d609 e1				pop hl 
d60a cd ab 95				call monitor 
d60d c3 a5 94				jp warmstart 
d610					;jp 0 
d610					;halt 
d610			 
d610			 
d610			 
d610 .. 00		.stackfault: 	db "Stack fault:",0 
d61d			 
d61d .. 00		sfaultsu: 	db	"Stack under flow",0 
d62e .. 00		sfaultso: 	db	"Stack over flow",0 
d63e .. 00		sfaultru:	db "RTS underflow",0 
d64c .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d666 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d680 .. 00		sfaultdo:	db "DTS overflow", 0 
d68d			 
d68d			 
d68d			fault_dsp_under: 
d68d 11 9f d6			ld de, .dsp_under 
d690 c3 4f d7			jp .show_fault 
d693			 
d693			fault_rsp_under: 
d693 11 ad d6			ld de, .rsp_under 
d696 c3 4f d7			jp .show_fault 
d699			fault_loop_under: 
d699 11 bb d6			ld de, .loop_under 
d69c c3 4f d7			jp .show_fault 
d69f			 
d69f .. 00		.dsp_under: db "DSP Underflow",0 
d6ad .. 00		.rsp_under: db "RSP Underflow",0 
d6bb .. 00		.loop_under: db "LOOP Underflow",0 
d6ca			 
d6ca			 
d6ca d5			type_faultn: 	push de 
d6cb e5					push hl 
d6cc cd 3c 88				call clear_display 
d6cf 11 f6 d6				   ld de, .typefaultn 
d6d2 3e 00				ld a, display_row_1 
d6d4 cd 4f 88				call str_at_display 
d6d7 11 c0 ee				    ld de, debug_mark 
d6da 3e 11				ld a, display_row_1+17 
d6dc cd 4f 88				call str_at_display 
d6df cd 5f 88				call update_display 
d6e2			 
d6e2				; prompt before entering montior for investigating issue 
d6e2			 
d6e2 3e 3c			ld a, display_row_4 
d6e4 11 57 95			ld de, endprog 
d6e7			 
d6e7 cd 5f 88			call update_display		 
d6ea			 
d6ea cd b5 97			call next_page_prompt 
d6ed			 
d6ed e5					push hl 
d6ee d5					push de 
d6ef cd ab 95				call monitor 
d6f2 c3 a5 94				jp warmstart 
d6f5 76					halt 
d6f6			 
d6f6			 
d6f6 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d70d			 
d70d d5			type_faults: 	push de 
d70e e5					push hl 
d70f cd 3c 88				call clear_display 
d712 11 38 d7				   ld de, .typefaults 
d715 3e 00				ld a, display_row_1 
d717 cd 4f 88				call str_at_display 
d71a 11 c0 ee				    ld de, debug_mark 
d71d 3e 11				ld a, display_row_1+17 
d71f cd 4f 88				call str_at_display 
d722 cd 5f 88				call update_display 
d725			 
d725				; prompt before entering montior for investigating issue 
d725			 
d725 3e 3c			ld a, display_row_4 
d727 11 57 95			ld de, endprog 
d72a			 
d72a cd 5f 88			call update_display		 
d72d			 
d72d cd b5 97			call next_page_prompt 
d730			 
d730 e1					pop hl 
d731 d1					pop de 
d732 cd ab 95				call monitor 
d735 c3 a5 94				jp warmstart 
d738			 
d738			 
d738 .. 00		.typefaults: db "STR Type Expected TOS!",0 
d74f			 
d74f			.show_fault: 	 
d74f d5					push de 
d750 cd 3c 88				call clear_display 
d753 d1					pop de 
d754 3e 00				ld a, display_row_1 
d756 cd 4f 88				call str_at_display 
d759 11 c0 ee				    ld de, debug_mark 
d75c 3e 11				ld a, display_row_1+17 
d75e cd 4f 88				call str_at_display 
d761 cd 5f 88				call update_display 
d764			 
d764				; prompt before entering montior for investigating issue 
d764			 
d764 3e 3c			ld a, display_row_4 
d766 11 57 95			ld de, endprog 
d769			 
d769 cd 5f 88			call update_display		 
d76c			 
d76c cd b5 97			call next_page_prompt 
d76f			 
d76f e1					pop hl 
d770 d1					pop de 
d771 cd ab 95				call monitor 
d774			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d774			; TODO Make optional fault restart to cli or warm boot? 
d774					;jp warmstart 
d774 c3 fd 94				jp cli 
d777 76					halt 
d778			; eof 
# End of file forth_kernel.asm
d778			;include "nascombasic.asm" 
d778			 
d778			 
d778			; find out where the code ends if loaded into RAM (for SC114) 
d778			;endofcode:  
d778			;	nop 
d778			 
d778			 
d778			; eof 
d778			 
# End of file main.asm
d778			;include "firmware_lcd_4x20.asm" 
d778			;include "firmware_key_4x4.asm" 
d778			include "firmware_serial_display.asm" 
d778			 
d778			; Serial display interface for SC114 
d778			 
d778			 
d778			display_row_1: equ 0 
d778			display_row_2: equ display_row_1+display_cols 
d778			display_row_3: equ display_row_2 + display_cols 
d778			display_row_4: equ display_row_3 + display_cols 
d778			 
d778			kLCDWidth:  EQU display_cols             ;Width in characters 
d778			kLCD_Line1: EQU 0x00  
d778			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d778			; E1 
d778			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d778			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d778			 
d778			lcd_init: 
d778				; no init as handled by the SCM bios 
d778 c9				ret 
d779			 
d779			 
d779			; low level functions for direct screen writes 
d779			 
d779			; output char at pos? 
d779			fLCD_Str: 
d779			        ;out (SC114_SIO_1_OUT),a 
d779 c5				push bc 
d77a 0e 02			ld c, $02 
d77c f7				rst $30 
d77d c1				pop bc 
d77e c9				ret 
d77f			 
d77f			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d77f			fLCD_Pos: 
d77f				; use ASCII escape to position 
d77f			        ;out (SC114_SIO_1_OUT),a 
d77f c5				push bc 
d780 0e 02			ld c, $02 
d782 f7				rst $30 
d783 c1				pop bc 
d784			 
d784 c9				ret 
d785			 
d785			; output char at pos 
d785			fLCD_Data: 
d785			      ;  out (SC114_SIO_1_OUT),a 
d785 c5				push bc 
d786 0e 02			ld c, $02 
d788 f7				rst $30 
d789 c1				pop bc 
d78a			 
d78a c9				ret 
d78b			 
d78b			; ascii cls  
d78b			 
d78b 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d78f			 
d78f			; write the frame buffer given in hl to hardware  
d78f			write_display: 
d78f			 
d78f			API: equ 0 
d78f			 
d78f			if API 
d78f				push bc 
d78f				ld b, 4 
d78f			 
d78f			        ld (display_write_tmp), hl 	  
d78f			 
d78f				; clear and home cursor 
d78f			 
d78f				ld c, 6 
d78f				ld de, .cls 
d78f				rst $30 
d78f			 
d78f			 
d78f			.writeln: 
d78f			 
d78f				ld de, (display_write_tmp) 
d78f				ld c, 6 
d78f				rst $30 
d78f				ld c, 7 
d78f				rst $30 
d78f			 
d78f				ld hl, (display_write_tmp) 
d78f				ld de, display_cols 
d78f				add hl,de 
d78f				ld (display_write_tmp),hl 
d78f			 
d78f				djnz  .writeln 
d78f			 
d78f				pop bc 
d78f			 
d78f			 
d78f				ret 
d78f			endif 
d78f e5				push hl 
d790 c5				push bc 
d791 d5				push de 
d792			 
d792			;	ld c, 2 
d792			;	;ld de, .cls 
d792			;	ld a, 27 
d792			;	rst $30 
d792			;	ld c, 2 
d792			;	;ld de, .cls 
d792			;	ld a, '[' 
d792			;	rst $30 
d792			; 
d792			;	ld c, 2 
d792			;	;ld de, .cls 
d792			;	ld a, 'H' 
d792			;	rst $30 
d792			; 
d792			 
d792 0e 02			ld c, 2 
d794				;ld de, .cls 
d794 3e 1b			ld a, 27 
d796 f7				rst $30 
d797			 
d797			 
d797 0e 02			ld c, 2 
d799				;ld de, .cls 
d799 3e 5b			ld a, '[' 
d79b f7				rst $30 
d79c 0e 02			ld c, 2 
d79e				;ld de, .cls 
d79e 3e 32			ld a, '2' 
d7a0 f7				rst $30 
d7a1 0e 02			ld c, 2 
d7a3				;ld de, .cls 
d7a3 3e 4a			ld a, 'J' 
d7a5 f7				rst $30 
d7a6 d1				pop de 
d7a7 c1				pop bc 
d7a8 e1				pop hl 
d7a9			 
d7a9			 
d7a9 22 5e ed		        ld (display_write_tmp), hl 	  
d7ac 3e 00			ld a, kLCD_Line1 
d7ae			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d7ae 06 14			ld b, display_cols 
d7b0 ed 5b 5e ed		ld de, (display_write_tmp) 
d7b4 cd 12 d8			call write_len_string 
d7b7				 
d7b7			 
d7b7 e5			push hl 
d7b8 d5			push de 
d7b9 c5			push bc 
d7ba 0e 07			ld c, 7 
d7bc f7				rst $30 
d7bd c1			pop bc 
d7be d1			pop de 
d7bf e1			pop hl 
d7c0			 
d7c0				 
d7c0 2a 5e ed			ld hl, (display_write_tmp) 
d7c3 11 14 00			ld de, display_cols 
d7c6 19				add hl,de 
d7c7 22 5e ed			ld (display_write_tmp),hl 
d7ca			 
d7ca				 
d7ca 3e 14			ld a, kLCD_Line2 
d7cc			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d7cc 06 14			ld b, display_cols 
d7ce ed 5b 5e ed		ld de, (display_write_tmp) 
d7d2 cd 12 d8			call write_len_string 
d7d5				 
d7d5 2a 5e ed			ld hl, (display_write_tmp) 
d7d8 11 14 00			ld de, display_cols 
d7db 19				add hl,de 
d7dc 22 5e ed			ld (display_write_tmp),hl 
d7df			 
d7df e5			push hl 
d7e0 d5			push de 
d7e1 c5			push bc 
d7e2 0e 07			ld c, 7 
d7e4 f7				rst $30 
d7e5 c1			pop bc 
d7e6 d1			pop de 
d7e7 e1			pop hl 
d7e8			 
d7e8				 
d7e8 3e 28			ld a, kLCD_Line3 
d7ea			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d7ea 06 14			ld b, display_cols 
d7ec ed 5b 5e ed		ld de, (display_write_tmp) 
d7f0 cd 12 d8			call write_len_string 
d7f3				 
d7f3 2a 5e ed			ld hl, (display_write_tmp) 
d7f6 11 14 00			ld de, display_cols 
d7f9 19				add hl,de 
d7fa 22 5e ed			ld (display_write_tmp),hl 
d7fd			 
d7fd e5			push hl 
d7fe d5			push de 
d7ff c5			push bc 
d800 0e 07			ld c, 7 
d802 f7				rst $30 
d803 c1			pop bc 
d804 d1			pop de 
d805 e1			pop hl 
d806			 
d806				 
d806 3e 3c			ld a, kLCD_Line4 
d808			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d808 06 14			ld b, display_cols 
d80a ed 5b 5e ed		ld de, (display_write_tmp) 
d80e cd 12 d8			call write_len_string 
d811 c9					ret 
d812			 
d812			 
d812				; write out a fixed length string given in b from de 
d812			 
d812 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d813 cd 85 d7		            CALL fLCD_Data      ;Write character to display 
d816 13				inc de 
d817 10 f9			djnz write_len_string 
d819 c9				ret 
d81a			 
d81a			 
d81a			; eof 
# End of file firmware_serial_display.asm
d81a			include "firmware_key_serial.asm" 
d81a			; Serial keyboard interface for SC114 
d81a			 
d81a			key_init: 
d81a				; no init as handled by the SCM bios 
d81a c9				ret 
d81b			 
d81b			 
d81b			cin_wait: 
d81b			;	ld a, 0 
d81b			;	ret 
d81b			 
d81b				;in a,(SC114_SIO_1_IN) 
d81b			        ; Use SCM API to get from whatever console device we are using 
d81b c5				push bc 
d81c 0e 01			ld c, $01 
d81e f7				rst $30 
d81f c1				pop bc 
d820 c9				ret 
d821			 
d821			cin: 
d821			 
d821			 
d821 c5				push bc 
d822			 
d822				; any key waiting to process? 
d822 0e 03			ld c, $03 
d824 f7				rst $30 
d825 28 05			jr z, .cin_skip 
d827			 
d827				; yep, get it 
d827			 
d827 0e 01			ld c, $01 
d829 f7				rst $30 
d82a c1				pop bc 
d82b c9				ret 
d82c			.cin_skip: 
d82c 3e 00			ld a, 0 
d82e c1				pop bc 
d82f c9				ret 
d830			 
d830			 
d830			 
d830			 
# End of file firmware_key_serial.asm
d830			 
d830			baseram:  
d830			endofcode: 
d830 00				nop 
d831			 
d831			heap_start: equ baseram+15  ; Starting address of heap 
d831			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d831			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d831			; 
d831			 
# End of file os_mini_sc114.asm
d831
