# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 4e 19			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 offsets for settings  
0003			  
0003			; if set then skip prompt for start up and accept all  
0003			  
0003			STORE_0_QUICKSTART: equ $25  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0003			  
0003			hardware_config: equ key_face_held - 10  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_config - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003				  
0003			  
0003					;ld a, 0  
0003					;ld (hardware_diag), a  
0003			  
0003					; clear all the buffers  
0003			  
0003 21 13 fa				ld hl, display_fb1  
0006 22 cf f8				ld (display_fb_active), hl  
0009			  
0009 cd d0 0a				call clear_display  
000c			  
000c 21 d1 f8				ld hl, display_fb2  
000f 22 cf f8				ld (display_fb_active), hl  
0012			  
0012 cd d0 0a				call clear_display  
0015			  
0015					; init primary frame buffer area  
0015 21 b4 fa				ld hl, display_fb0  
0018 22 cf f8				ld (display_fb_active), hl  
001b			  
001b cd d0 0a				call clear_display  
001e			  
001e			  
001e cd ee 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0021			  
0021 cd 85 68			call key_init  
0024 cd a2 01			call storage_init  
0027			  
0027				; setup malloc functions  
0027			  
0027				if MALLOC_1  
0027 cd a7 11				call  heap_init  
002a				endif  
002a				if MALLOC_4  
002a					call  heap_init  
002a				endif  
002a			  
002a				; init sound hardware if present  
002a			  
002a				if SOUND_ENABLE  
002a cd 64 13				call sound_init  
002d				endif  
002d			  
002d				; lcd test sequence  
002d					  
002d cd f3 0a			call update_display  
0030 cd 4d 0a			call delay1s  
0033 3e 2b			ld a,'+'  
0035 cd d5 0a			call fill_display  
0038 cd f3 0a			call update_display  
003b cd 4d 0a			call delay1s  
003e 3e 2a			ld a,'*'  
0040 cd d5 0a			call fill_display  
0043 cd f3 0a			call update_display  
0046 cd 4d 0a			call delay1s  
0049 3e 2d			ld a,'-'  
004b cd d5 0a			call fill_display  
004e cd f3 0a			call update_display  
0051 cd 4d 0a			call delay1s  
0054			  
0054			; boot splash screen  
0054			if display_cols == 20	  
0054			        ld a, display_row_1    
0054			else  
0054 3e 0a		        ld a, display_row_1 +10   
0056			endif  
0056 11 81 18			ld de, prom_bootmsg  
0059 cd e3 0a			call str_at_display  
005c cd f3 0a			call update_display  
005f			  
005f			  
005f cd 4d 0a			call delay1s  
0062 cd 4d 0a			call delay1s  
0065			if display_cols == 20	  
0065			            LD   A, display_row_3+2  
0065			else  
0065 3e 5c		            LD   A, display_row_3+12  
0067			endif  
0067 11 96 18			ld de, prom_bootmsg1  
006a cd e3 0a			call str_at_display  
006d cd f3 0a			call update_display  
0070 cd 4d 0a			call delay1s  
0073 cd 4d 0a			call delay1s  
0076			  
0076			;	ld a, display_row_4+3  
0076			;	ld de, bootmsg2  
0076			;	call str_at_display  
0076			;	call update_display  
0076			;	call delay1s  
0076			;	call delay1s  
0076			  
0076			; debug mark setup  
0076			  
0076 3e 5f		ld a, '_'  
0078 32 6e fb		ld (debug_mark),a  
007b 32 6f fb		ld (debug_mark+1),a  
007e 32 70 fb		ld (debug_mark+2),a  
0081 3e 00		ld a,0  
0083 32 71 fb		ld (debug_mark+3),a  
0086			  
0086 c9					ret  
0087			  
0087			  
0087			;bootmsg2:	db "Firmware v0.1",0  
0087			  
0087			; a 4x20 lcd  
0087			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
0087			  
0087			;if display_cols == 20  
0087			;	include "firmware_lcd_4x20.asm"  
0087			;endif  
0087			  
0087			;if display_cols == 40  
0087			;	include "firmware_lcd_4x40.asm"  
0087			;endif  
0087			  
0087			;  
0087			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
0087			; TODO abstract the bit bang video out interface for dual display  
0087			; TODO wire video out to tx pin on rc2014 bus  
0087			  
0087			; must supply cin, and cin_wait for low level hardware abstraction   
0087			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
0087			; test scancode  
0087			  
0087			;;;;;  
0087			;;;  
0087			; Moved out to mini and maxi versions  
0087			;  
0087			; include "firmware_key_4x4.asm"  
0087			; using existing 4 wire x 4 resistor array for input  
0087			;include "firmware_key_4x10.asm"  
0087			; need to mod the board for 5 rows due to resistor array  
0087			;include "firmware_key_5x10.asm"  
0087			  
0087			; storage hardware interface  
0087			  
0087			; use microchip serial eeprom for storage  
0087			  
0087			  
0087			if STORAGE_SE  
0087				include "firmware_spi.asm"  
0087			; my spi protocol (used by storage) 
0087			 
0087			; SPI pins 
0087			 
0087			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
0087			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
0087			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
0087			 
0087			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
0087			; chip pin 4 gnd 
0087			 
0087			 
0087			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
0087			SPI_CE1: equ 1      ;    port a1 pin 14  
0087			SPI_CE2: equ 2      ;    port a2 pin pin 13 
0087			SPI_CE3: equ 3      ; port    a3 pin pin 12 
0087			SPI_CE4: equ 4      ; port a4     pin 10 
0087			 
0087			; active low AND masks 
0087			 
0087			;SPI_CE0_MASK: equ    255-1 
0087			;SPI_CE1_MASK: equ   255-2 
0087			;SPI_CE2_MASK: equ   255-4 
0087			;SPI_CE3_MASK: equ   255-8 
0087			;SPI_CE4_MASK: equ   255-16 
0087			SPI_CE_HIGH:  equ 255 
0087			 
0087			 
0087			 
0087			 
0087			; TODO store port id for spi device ie dev c 
0087			; TODO store pin for SO 
0087			; TODO store pin for SI 
0087			; TODO store pin for SCLK 
0087			 
0087			; 
0087			 
0087			; ensure that spi bus is in a stable state with default pins  
0087			 
0087			se_stable_spi:   
0087			 
0087				 ; set DI high, CE high , SCLK low 
0087				;ld a, SPI_DI | SPI_CE0 
0087 3e 07			ld a, SPI_DI  
0089 cd 5d 01			call spi_ce_high 
008c d3 80			 out (storage_adata),a 
008e 32 40 f8			ld (spi_portbyte),a 
0091			 
0091				if DEBUG_SPI 
0091					push hl 
0091					ld l, a 
0091					DMARK "SPI" 
0091					CALLMONITOR 
0091					pop hl 
0091				endif 
0091 c9				ret 
0092			 
0092			; byte to send in a 
0092			 
0092			spi_send_byte: 
0092				; save byte to send for bit mask shift out 
0092 4f			        ld c,a 
0093 3a 40 f8			ld a,(spi_portbyte) 
0096				  
0096				; clock out	each bit of the byte msb first 
0096			 
0096 06 08			ld b, 8 
0098			.ssb1: 
0098				; clear so bit  
0098 cb bf			res SPI_DI, a 
009a cb 11			rl c 
009c				; if bit 7 is set then carry is set 
009c 30 02			jr nc, .ssb2 
009e cb ff			set SPI_DI,a 
00a0			.ssb2:  ; output bit to ensure it is stable 
00a0 d3 80			out (storage_adata),a 
00a2 00				nop 
00a3				; clock bit high 
00a3 cb ef			set SPI_SCLK,a 
00a5 d3 80			out (storage_adata),a 
00a7 00				nop 
00a8				; then low 
00a8 cb af			res SPI_SCLK,a 
00aa d3 80			out (storage_adata),a 
00ac 00				nop 
00ad 10 e9			djnz .ssb1 
00af			 
00af 32 40 f8			ld (spi_portbyte),a 
00b2 c9				ret 
00b3			 
00b3			; TODO low level get byte into A on spi 
00b3			 
00b3			spi_read_byte:  
00b3			 
00b3				; save byte to send for bit mask shift out 
00b3 0e 00		    ld c,0 
00b5 3a 40 f8			ld a,(spi_portbyte) 
00b8				  
00b8				; clock out	each bit of the byte msb first 
00b8			 
00b8			 
00b8				; clock bit high 
00b8 cb ef			set SPI_SCLK,a 
00ba d3 80			out (storage_adata),a 
00bc 00				nop 
00bd			 
00bd			    ; read DO  
00bd			 
00bd cb f9		    set 7,c 
00bf db 80			in a,(storage_adata) 
00c1 cb 77		    bit SPI_DO,a 
00c3 20 02		    jr nz, .b7 
00c5 cb b9		    res 7,c 
00c7			.b7: 
00c7				; then low 
00c7 cb af			res SPI_SCLK,a 
00c9 d3 80			out (storage_adata),a 
00cb 00				nop 
00cc			     
00cc			 
00cc				; clock bit high 
00cc cb ef			set SPI_SCLK,a 
00ce d3 80			out (storage_adata),a 
00d0 00				nop 
00d1			 
00d1			    ; read DO  
00d1			 
00d1 cb f1		    set 6,c 
00d3 db 80			in a,(storage_adata) 
00d5 cb 77		    bit SPI_DO,a 
00d7 20 02		    jr nz, .b6 
00d9 cb b1		    res 6,c 
00db			.b6: 
00db				; then low 
00db cb af			res SPI_SCLK,a 
00dd d3 80			out (storage_adata),a 
00df 00				nop 
00e0			 
00e0				; clock bit high 
00e0 cb ef			set SPI_SCLK,a 
00e2 d3 80			out (storage_adata),a 
00e4 00				nop 
00e5			 
00e5			 
00e5			    ; read DO  
00e5			 
00e5 cb e9		    set 5,c 
00e7 db 80			in a,(storage_adata) 
00e9 cb 77		    bit SPI_DO,a 
00eb 20 02		    jr nz, .b5 
00ed cb a9		    res 5,c 
00ef			.b5: 
00ef				; then low 
00ef cb af			res SPI_SCLK,a 
00f1 d3 80			out (storage_adata),a 
00f3 00				nop 
00f4				; clock bit high 
00f4 cb ef			set SPI_SCLK,a 
00f6 d3 80			out (storage_adata),a 
00f8 00				nop 
00f9			 
00f9			    ; read DO  
00f9			 
00f9 cb e1		    set 4,c 
00fb db 80			in a,(storage_adata) 
00fd cb 77		    bit SPI_DO,a 
00ff 20 02		    jr nz, .b4 
0101 cb a1		    res 4,c 
0103			.b4: 
0103				; then low 
0103 cb af			res SPI_SCLK,a 
0105 d3 80			out (storage_adata),a 
0107 00				nop 
0108				; clock bit high 
0108 cb ef			set SPI_SCLK,a 
010a d3 80			out (storage_adata),a 
010c 00				nop 
010d			 
010d			    ; read DO  
010d			 
010d cb d9		    set 3,c 
010f db 80			in a,(storage_adata) 
0111 cb 77		    bit SPI_DO,a 
0113 20 02		    jr nz, .b3 
0115 cb 99		    res 3,c 
0117			.b3: 
0117				; then low 
0117 cb af			res SPI_SCLK,a 
0119 d3 80			out (storage_adata),a 
011b 00				nop 
011c				; clock bit high 
011c cb ef			set SPI_SCLK,a 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121			 
0121			    ; read DO  
0121			 
0121 cb d1		    set 2,c 
0123 db 80			in a,(storage_adata) 
0125 cb 77		    bit SPI_DO,a 
0127 20 02		    jr nz, .b2 
0129 cb 91		    res 2,c 
012b			.b2: 
012b				; then low 
012b cb af			res SPI_SCLK,a 
012d d3 80			out (storage_adata),a 
012f 00				nop 
0130				; clock bit high 
0130 cb ef			set SPI_SCLK,a 
0132 d3 80			out (storage_adata),a 
0134 00				nop 
0135			 
0135			    ; read DO  
0135			 
0135 cb c9		    set 1,c 
0137 db 80			in a,(storage_adata) 
0139 cb 77		    bit SPI_DO,a 
013b 20 02		    jr nz, .b1 
013d cb 89		    res 1,c 
013f			.b1: 
013f				; then low 
013f cb af			res SPI_SCLK,a 
0141 d3 80			out (storage_adata),a 
0143 00				nop 
0144				; clock bit high 
0144 cb ef			set SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149			 
0149			    ; read DO  
0149			 
0149 cb c1		    set 0,c 
014b db 80			in a,(storage_adata) 
014d cb 77		    bit SPI_DO,a 
014f 20 02		    jr nz, .b0 
0151 cb 81		    res 0,c 
0153			.b0: 
0153				; then low 
0153 cb af			res SPI_SCLK,a 
0155 d3 80			out (storage_adata),a 
0157 00				nop 
0158			 
0158			 
0158 32 40 f8			ld (spi_portbyte),a 
015b			 
015b			    ; return byte 
015b 79			    ld a,c 
015c			 
015c			 
015c c9				ret 
015d			 
015d			 
015d			 
015d			spi_ce_high: 
015d			 
015d				if DEBUG_SPI_HARD_CE0 
015d			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
015d					ret 
015d			 
015d				endif 
015d			 
015d			 
015d f5				push af 
015e			 
015e				; send direct ce to port b 
015e 3e ff			ld a, 255 
0160 d3 81			out (storage_bdata), a 
0162			 
0162 f1				pop af 
0163			 
0163				; for port a that shares with spi lines AND the mask 
0163			  
0163				if DEBUG_SPI 
0163					push hl 
0163					ld h, a 
0163				endif 
0163			;	ld c, SPI_CE_HIGH 
0163			;	and c 
0163 cb c7			set SPI_CE0, a 
0165 cb cf			set SPI_CE1, a 
0167 cb d7			set SPI_CE2, a 
0169 cb df			set SPI_CE3, a 
016b cb e7			set SPI_CE4, a 
016d			 
016d				if DEBUG_SPI 
016d					ld l, a 
016d					DMARK "CEh" 
016d					CALLMONITOR 
016d					pop hl 
016d				endif 
016d c9				ret 
016e			 
016e			 
016e			spi_ce_low: 
016e			 
016e				if DEBUG_SPI_HARD_CE0 
016e			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
016e					ret 
016e			 
016e				endif 
016e			 
016e c5				push bc 
016f f5				push af 
0170			 
0170				; send direct ce to port b 
0170 3a 42 f8			ld a, (spi_cartdev) 
0173 d3 81			out (storage_bdata), a 
0175			 
0175			 
0175			 
0175				; for port a that shares with spi lines AND the mask 
0175			 
0175 3a 3f f8			ld a, (spi_device)  
0178 4f				ld c, a 
0179			 
0179 f1				pop af 
017a			 
017a				; detect CEx 
017a			 
017a				if DEBUG_SPI 
017a					push hl 
017a					ld h, a 
017a				endif 
017a			 
017a cb 41			bit SPI_CE0, c 
017c 20 04			jr nz, .cel1 
017e cb 87			res SPI_CE0, a 
0180 18 1e			jr .celn 
0182			.cel1: 
0182 cb 49			bit SPI_CE1, c 
0184 20 04			jr nz, .cel2 
0186 cb 8f			res SPI_CE1, a 
0188 18 16			jr .celn 
018a			.cel2: 
018a cb 51			bit SPI_CE2, c 
018c 20 04			jr nz, .cel3 
018e cb 97			res SPI_CE2, a 
0190 18 0e			jr .celn 
0192			.cel3: 
0192 cb 59			bit SPI_CE3, c 
0194 20 04			jr nz, .cel4 
0196 cb 9f			res SPI_CE3, a 
0198 18 06			jr .celn 
019a			.cel4: 
019a cb 61			bit SPI_CE4, c 
019c 20 02			jr nz, .celn 
019e cb a7			res SPI_CE4, a 
01a0			.celn: 
01a0			 
01a0			 
01a0			 
01a0			;	add c 
01a0			 
01a0				if DEBUG_SPI 
01a0					ld l, a 
01a0					DMARK "CEl" 
01a0					CALLMONITOR 
01a0					pop hl 
01a0				endif 
01a0 c1				pop bc 
01a1 c9				ret 
01a2			 
01a2			 
01a2			 
01a2			; eof 
01a2			 
01a2			 
01a2			 
01a2			 
01a2			 
# End of file firmware_spi.asm
01a2				include "firmware_seeprom.asm"  
01a2			; 
01a2			; persisent storage interface via microchip serial eeprom 
01a2			 
01a2			; port a pio 2 
01a2			; pa 7 - si 
01a2			; pa 6 - sclk  
01a2			; pa 5 - so 
01a2			; pa 4 - cs 
01a2			; pa 3 - cs 
01a2			; pa 2 - cs 
01a2			; pa 1 - cs 
01a2			; pa 0 - cs 
01a2			; 
01a2			; TODO get block 
01a2			; TODO save block 
01a2			; TODO load file 
01a2			; TODO save file 
01a2			; TODO get dir  
01a2			 
01a2			;  
01a2			storage_adata: equ Device_C    ; device c port a - onboard storage 
01a2			storage_actl: equ Device_C+2     ; device c port a 
01a2			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01a2			storage_bctl: equ Device_C+3     ; device c port b 
01a2			 
01a2			 
01a2			; TODO move these to hardware driver file 
01a2			 
01a2			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01a2			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01a2			; storage bank file system format 
01a2			; 
01a2			; first page of bank: 
01a2			; 	addr 0 - status check 
01a2			;       addr 1 - write protect flag 
01a2			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01a2			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01a2			;         TODO see if scanning whole of for available next file id is fast enough 
01a2			;	addr 4 > zero term string of bank label 
01a2			; 
01a2			;        
01a2			;  
01a2			; first page of any file: 
01a2			;      byte 0 - file id  
01a2			;      byte 1-17 - fixed file name  
01a2			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01a2			; 
01a2			; other pages of any file: 
01a2			;      byte 0 - file id 
01a2			;      byte 1> - file data 
01a2			; 
01a2			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01a2			;  
01a2			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01a2			 
01a2			 
01a2			;storage_so_bit: 5 
01a2			;storage_si_bit: 7 
01a2			;storage_sclk_bit: 6 
01a2			  
01a2			 
01a2			; init storage pio 
01a2			 
01a2			storage_init: 
01a2			 
01a2 3e cf		            LD   A, 11001111b 
01a4 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01a6 3e 00		            LD   A, 00000000b 
01a8 cb f7			set SPI_DO,a 
01aa			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01aa d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01ac			 
01ac 3e cf		            LD   A, 11001111b 
01ae d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01b0 3e 00		            LD   A, 00000000b 
01b2 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01b4			 
01b4				; set all external spi devices off 
01b4 3e 00			ld a, 0 
01b6 32 3f f8			ld (spi_device), a 
01b9 32 42 f8			ld (spi_cartdev), a 
01bc			 
01bc					; ensure the spi bus is in a default stable state 
01bc cd 87 00				call se_stable_spi 
01bf			 
01bf			; TODO scan spi bus and gather which storage banks are present 
01bf			 
01bf			; populate store_bank_active  
01bf			; for each ce line activate and attempt to write first byte of bank and read back 
01bf			; if zero is returned then bank is empty 
01bf			;   
01bf			; 
01bf			 
01bf					; init file extent cache to save on slow reads 
01bf			 
01bf			;	ld hl, store_filecache 
01bf			;	ld de, 0 
01bf			;	ld hl,(de)	 
01bf			 
01bf			 
01bf c9			    ret 
01c0			 
01c0			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01c0			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01c0			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01c0			 
01c0			; INSTRUCTION SET 
01c0			; READ 0000 0011 Read data from memory array beginning at selected address 
01c0			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01c0			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01c0			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01c0			; RDSR 0000 0101 Read STATUS register 
01c0			; WRSR 0000 0001 Write STATUS register 
01c0			; PE 0100 0010 Page Erase – erase one page in memory array 
01c0			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01c0			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01c0			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01c0			 
01c0			; TODO send byte steam for page without setting the address for every single byte 
01c0			; TODO read byte  
01c0			 
01c0			; byte in a 
01c0			; address in hl  
01c0			se_writebyte: 
01c0			        
01c0			    ;   ld c, a 
01c0 f5			        push af 
01c1 e5			        push hl 
01c2			 
01c2			    ; initi write mode 
01c2			    ; 
01c2			    ;CS low 
01c2			 
01c2 3a 40 f8		       ld a,(spi_portbyte) 
01c5 cd 6e 01			call spi_ce_low 
01c8			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01c8 d3 80		       out (storage_adata),a 
01ca 32 40 f8		       ld (spi_portbyte), a 
01cd			 
01cd			    ;clock out wren instruction 
01cd			 
01cd 3e 06		    ld a, store_wren_ins 
01cf cd 92 00		    call spi_send_byte  
01d2			 
01d2			    ;cs high to enable write latch 
01d2			 
01d2 3a 40 f8		       ld a,(spi_portbyte) 
01d5 cd 5d 01			call spi_ce_high 
01d8			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01d8 d3 80		       out (storage_adata),a 
01da 32 40 f8		       ld (spi_portbyte), a 
01dd			 
01dd 00				nop 
01de			    ; 
01de			    ; intial write data 
01de			    ; 
01de			    ; cs low 
01de			     
01de 3a 40 f8		       ld a,(spi_portbyte) 
01e1 cd 6e 01			call spi_ce_low 
01e4			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01e4 d3 80		       out (storage_adata),a 
01e6 32 40 f8		       ld (spi_portbyte), a 
01e9			 
01e9			    ; clock out write instruction 
01e9			     
01e9 3e 02		    ld a, store_write_ins  
01eb cd 92 00		    call spi_send_byte  
01ee			 
01ee			    ; clock out address (depending on address size) 
01ee			     
01ee e1			    pop hl 
01ef 7c			    ld a,h    ; address out msb first 
01f0 cd 92 00		    call spi_send_byte  
01f3 7d			    ld a,l 
01f4 cd 92 00		    call spi_send_byte  
01f7			 
01f7			    ; clock out byte(s) for page 
01f7			 
01f7 f1			    pop af 
01f8 cd 92 00		    call spi_send_byte  
01fb			 
01fb			    ; end write with ce high 
01fb 3a 40 f8		       ld a,(spi_portbyte) 
01fe			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
01fe cd 5d 01			call spi_ce_high 
0201 d3 80		       out (storage_adata),a 
0203 32 40 f8		       ld (spi_portbyte), a 
0206			 
0206				; pause for internal write cycle 
0206 3e 0a			ld a, 10 
0208 cd 32 0a			call aDelayInMS 
020b c9			    ret 
020c			 
020c			; buffer to write in de 
020c			; address in hl  
020c			se_writepage: 
020c			        
020c			    ;   ld c, a 
020c d5				push de 
020d e5			        push hl 
020e			 
020e			    ; initi write mode 
020e			    ; 
020e			    ;CS low 
020e			 
020e 3a 40 f8		       ld a,(spi_portbyte) 
0211 cd 6e 01			call spi_ce_low 
0214			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0214 d3 80		       out (storage_adata),a 
0216 32 40 f8		       ld (spi_portbyte), a 
0219			 
0219			    ;clock out wren instruction 
0219			 
0219 3e 06		    ld a, store_wren_ins 
021b cd 92 00		    call spi_send_byte  
021e			 
021e			    ;cs high to enable write latch 
021e			 
021e 3a 40 f8		       ld a,(spi_portbyte) 
0221 cd 5d 01			call spi_ce_high 
0224			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0224 d3 80		       out (storage_adata),a 
0226 32 40 f8		       ld (spi_portbyte), a 
0229			 
0229 00				nop 
022a			    ; 
022a			    ; intial write data 
022a			    ; 
022a			    ; cs low 
022a			     
022a 3a 40 f8		       ld a,(spi_portbyte) 
022d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022d cd 6e 01			call spi_ce_low 
0230 d3 80		       out (storage_adata),a 
0232 32 40 f8		       ld (spi_portbyte), a 
0235			 
0235			    ; clock out write instruction 
0235			     
0235 3e 02		    ld a, store_write_ins  
0237 cd 92 00		    call spi_send_byte  
023a			 
023a			    ; clock out address (depending on address size) 
023a			     
023a e1			    pop hl 
023b 7c			    ld a,h    ; address out msb first 
023c cd 92 00		    call spi_send_byte  
023f 7d			    ld a,l 
0240 cd 92 00		    call spi_send_byte  
0243			 
0243			    ; clock out byte(s) for page 
0243			 
0243 e1				pop hl 
0244 06 40			ld b, STORE_BLOCK_PHY 
0246			.bytewrite: 
0246			 
0246 7e				ld a,(hl) 
0247 e5			    push hl 
0248 c5				push bc 
0249 cd 92 00		    call spi_send_byte  
024c c1				pop bc 
024d e1				pop hl 
024e			 
024e			    ; end write with ce high 
024e 3a 40 f8		       ld a,(spi_portbyte) 
0251 cd 5d 01			call spi_ce_high 
0254			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0254 d3 80		       out (storage_adata),a 
0256 32 40 f8		       ld (spi_portbyte), a 
0259			 
0259 23				inc hl 
025a 10 ea			djnz .bytewrite 
025c			 
025c				; pause for internal write cycle 
025c 3e 64			ld a, 100 
025e cd 32 0a			call aDelayInMS 
0261 c9			    ret 
0262			; returns byte in a 
0262			; address in hl  
0262			se_readbyte: 
0262 d5				push de 
0263 c5				push bc 
0264			 
0264			    ;   ld c, a 
0264 e5			        push hl 
0265			 
0265			    ; initi write mode 
0265			    ; 
0265			    ;CS low 
0265			 
0265 3a 40 f8		       ld a,(spi_portbyte) 
0268 cd 6e 01			call spi_ce_low 
026b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
026b d3 80		       out (storage_adata),a 
026d 32 40 f8		       ld (spi_portbyte), a 
0270			 
0270			    ;clock out wren instruction 
0270			 
0270 3e 03		    ld a, store_read_ins 
0272 cd 92 00		    call spi_send_byte  
0275			 
0275			 
0275			    ; clock out address (depending on address size) 
0275			     
0275 e1			    pop hl 
0276 7c			    ld a,h    ; address out msb first 
0277 cd 92 00		    call spi_send_byte  
027a 7d			    ld a,l 
027b cd 92 00		    call spi_send_byte  
027e			 
027e			    ; clock in byte(s) for page 
027e			 
027e cd b3 00		    call spi_read_byte  
0281 f5				push af 
0282			 
0282			    ; end write with ce high 
0282 3a 40 f8		       ld a,(spi_portbyte) 
0285			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0285 cd 5d 01			call spi_ce_high 
0288 d3 80		       out (storage_adata),a 
028a 32 40 f8		       ld (spi_portbyte), a 
028d			 
028d f1				pop af 
028e			 
028e c1				pop bc 
028f d1				pop de 
0290			 
0290 c9			    ret 
0291			 
0291			if DEBUG_STORESE 
0291			 
0291			storageput:  
0291			 
0291			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
0291			 
0291 21 16 ee			ld hl,scratch+2 
0294 cd bb 10			call get_word_hl 
0297			 
0297				; stuff it here for the moment as it will be overwritten later anyway 
0297			 
0297 22 37 f1			ld (os_cur_ptr),hl	 
029a			 
029a			 
029a			; get pointer to start of string 
029a			 
029a 21 1b ee			ld hl, scratch+7 
029d			 
029d			; loop writing char of string to eeprom 
029d			 
029d 7e			.writestr:	ld a,(hl) 
029e fe 00				cp 0 
02a0 28 12				jr z, .wsdone		; done writing 
02a2 e5					push hl 
02a3 2a 37 f1				ld hl,(os_cur_ptr) 
02a6 cd c0 01				call se_writebyte 
02a9			 
02a9 2a 37 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02ac 23					inc hl 
02ad 22 37 f1				ld (os_cur_ptr),hl 
02b0			 
02b0					; restore string pointer and get next char 
02b0			 
02b0 e1					pop hl 
02b1 23					inc hl 
02b2 18 e9				jr .writestr 
02b4			 
02b4			 
02b4			 
02b4			.wsdone: 
02b4			 
02b4			 
02b4			; when done load first page into a buffer  
02b4			 
02b4 21 00 80				ld hl,08000h		; start in ram 
02b7 22 37 f1				ld (os_cur_ptr),hl 
02ba 21 00 00				ld hl, 0		 ; start of page 
02bd 22 3c ee				ld (scratch+40),hl	; hang on to it 
02c0			 
02c0 06 80				ld b, 128		; actually get more then one page 
02c2 c5			.wsload:	push bc 
02c3 2a 3c ee				ld hl,(scratch+40) 
02c6 e5					push hl 
02c7 cd 62 02				call se_readbyte 
02ca			 
02ca					; a now as the byte 
02ca			 
02ca 2a 37 f1				ld hl,(os_cur_ptr) 
02cd 77					ld (hl),a 
02ce					; inc next buffer area 
02ce 23					inc hl 
02cf 22 37 f1				ld (os_cur_ptr),hl 
02d2			 
02d2					; get eeprom position, inc and save for next round 
02d2 e1					pop hl		 
02d3 23					inc hl 
02d4 22 3c ee				ld (scratch+40),hl 
02d7 c1					pop bc 
02d8 10 e8				djnz .wsload 
02da			 
02da			; set 'd' pointer to start of buffer 
02da			 
02da 21 00 80				ld hl,08000h 
02dd 22 37 f1				ld (os_cur_ptr),hl 
02e0			 
02e0			 
02e0 c9			ret 
02e1			 
02e1			 
02e1 c9			storageread: ret 
02e2			 
02e2			 
02e2			 
02e2			 
02e2			 
02e2			 
02e2			endif 
02e2			 
02e2			 
02e2			 
# End of file firmware_seeprom.asm
02e2			else  
02e2			   ; create some stubs for the labels  
02e2			se_readbyte: ret  
02e2			se_writebyte: ret  
02e2			storage_init: ret  
02e2			  
02e2			endif  
02e2			  
02e2			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02e2			;include "firmware_cf.asm"  
02e2			  
02e2			; load up high level storage hardward abstractions  
02e2			include "firmware_storage.asm"  
02e2			 
02e2			; persisent storage hardware abstraction layer  
02e2			 
02e2			 
02e2			 
02e2			; Block 0 on storage is a config state 
02e2			 
02e2			 
02e2			 
02e2			; TODO add read phy block and write phy block functions 
02e2			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02e2			 
02e2			; Abstraction layer  
02e2			 
02e2			; Logocial block size is same size as physical size - using tape concept 
02e2			 
02e2			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02e2			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02e2			 
02e2			 
02e2			 
02e2			; Filesystem layout (Logical layout) 
02e2			; 
02e2			; Block 0 - Bank config  
02e2			; 
02e2			;      Byte - 0 file id counter 
02e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02e2			;      Byte - 3-20 zero terminated bank label 
02e2			; 
02e2			; Block 1 > File storage 
02e2			; 
02e2			;      Byte 0 file id    - block 0 file details 
02e2			;      Byte 1 block id - block 0 is file  
02e2			;            Byte 2-15 - File name 
02e2			; 
02e2			;       - to end of block data 
02e2			; 
02e2			 
02e2			 
02e2			; Read Block 
02e2			; ---------- 
02e2			; 
02e2			; With current bank 
02e2			;  
02e2			; Get block number to read 
02e2			; Load physical blocks starting at start block into buffer 
02e2			 
02e2			; de points to buffer to use 
02e2			; hl holds logical block number  
02e2			 
02e2			storage_read_block: 
02e2			 
02e2				; TODO bank selection 
02e2			 
02e2				; for each of the physical blocks read it into the buffer 
02e2 06 40			ld b, STORE_BLOCK_PHY 
02e4			 
02e4				if DEBUG_STORESE 
02e4 d5					push de 
02e5				endif 
02e5				 
02e5			.rl1:    
02e5			 
02e5				; read physical block at hl into de 
02e5			        ; increment hl and de to next read position on exit 
02e5			 
02e5 e5				push hl 
02e6 d5				push de	 
02e7 c5				push bc 
02e8			;	if DEBUG_STORESE 
02e8			;		push af 
02e8			;		ld a, 'R' 
02e8			;		ld (debug_mark),a 
02e8			;		pop af 
02e8			;		CALLMONITOR 
02e8			;	endif 
02e8 cd 62 02			call se_readbyte 
02eb			;	if DEBUG_STORESE 
02eb			;		ld a,(spi_portbyte) 
02eb			;		ld l, a 
02eb			;		push af 
02eb			;		ld a, '1' 
02eb			;		ld (debug_mark),a 
02eb			;		pop af 
02eb			;		CALLMONITOR 
02eb			;	endif 
02eb c1				pop bc 
02ec d1				pop de 
02ed e1				pop hl 
02ee 12				ld (de),a 
02ef 23				inc hl 
02f0 13				inc de 
02f1			 
02f1			;	if DEBUG_STORESE 
02f1			;		push af 
02f1			;		ld a, 'r' 
02f1			;		ld (debug_mark),a 
02f1			;		pop af 
02f1			;		CALLMONITOR 
02f1			;	endif 
02f1			 
02f1 10 f2			djnz .rl1 
02f3			 
02f3				if DEBUG_STORESE 
02f3					DMARK "SRB" 
02f3 f5				push af  
02f4 3a 08 03			ld a, (.dmark)  
02f7 32 6e fb			ld (debug_mark),a  
02fa 3a 09 03			ld a, (.dmark+1)  
02fd 32 6f fb			ld (debug_mark+1),a  
0300 3a 0a 03			ld a, (.dmark+2)  
0303 32 70 fb			ld (debug_mark+2),a  
0306 18 03			jr .pastdmark  
0308 ..			.dmark: db "SRB"  
030b f1			.pastdmark: pop af  
030c			endm  
# End of macro DMARK
030c d1					pop de 
030d			; 
030d			;		push af 
030d			;		ld a, 'R' 
030d			;		ld (debug_mark),a 
030d			;		pop af 
030d					CALLMONITOR 
030d cd ab 16			call break_point_state  
0310				endm  
# End of macro CALLMONITOR
0310				endif 
0310 c9				ret	 
0311				 
0311			 
0311			; File Size 
0311			; --------- 
0311			; 
0311			;   hl file id 
0311			; 
0311			;  returns in hl the number of blocks 
0311			 
0311			storage_file_size: 
0311 5d				ld e, l 
0312 16 00			ld d, 0 
0314 21 40 00			ld hl, STORE_BLOCK_PHY 
0317					if DEBUG_FORTH_WORDS 
0317						DMARK "SIZ" 
0317 f5				push af  
0318 3a 2c 03			ld a, (.dmark)  
031b 32 6e fb			ld (debug_mark),a  
031e 3a 2d 03			ld a, (.dmark+1)  
0321 32 6f fb			ld (debug_mark+1),a  
0324 3a 2e 03			ld a, (.dmark+2)  
0327 32 70 fb			ld (debug_mark+2),a  
032a 18 03			jr .pastdmark  
032c ..			.dmark: db "SIZ"  
032f f1			.pastdmark: pop af  
0330			endm  
# End of macro DMARK
0330						CALLMONITOR 
0330 cd ab 16			call break_point_state  
0333				endm  
# End of macro CALLMONITOR
0333					endif 
0333 cd 15 06			call storage_findnextid 
0336			 
0336 cd 2d 0d			call ishlzero 
0339			;	ld a, l 
0339			;	add h 
0339			;	cp 0 
0339 c8				ret z			; block not found so EOF 
033a			 
033a 11 59 f8			ld de, store_page 
033d cd e2 02			call storage_read_block 
0340			 
0340 3a 5b f8			ld a, (store_page+2)	 ; get extent count 
0343 6f				ld l, a 
0344 26 00			ld h, 0 
0346 c9			 	ret 
0347			 
0347			 
0347			; Write Block 
0347			; ----------- 
0347			; 
0347			; With current bank 
0347			;  
0347			; Get block number to write 
0347			; Write physical blocks starting at start block from buffer 
0347			  
0347			storage_write_block: 
0347				; TODO bank selection 
0347			 
0347				; for each of the physical blocks read it into the buffer 
0347 06 40			ld b, STORE_BLOCK_PHY 
0349			 
0349				if DEBUG_STORESE 
0349					DMARK "SWB" 
0349 f5				push af  
034a 3a 5e 03			ld a, (.dmark)  
034d 32 6e fb			ld (debug_mark),a  
0350 3a 5f 03			ld a, (.dmark+1)  
0353 32 6f fb			ld (debug_mark+1),a  
0356 3a 60 03			ld a, (.dmark+2)  
0359 32 70 fb			ld (debug_mark+2),a  
035c 18 03			jr .pastdmark  
035e ..			.dmark: db "SWB"  
0361 f1			.pastdmark: pop af  
0362			endm  
# End of macro DMARK
0362			 
0362					;push af 
0362					;ld a, 'W' 
0362					;ld (debug_mark),a 
0362					;pop af 
0362					CALLMONITOR 
0362 cd ab 16			call break_point_state  
0365				endm  
# End of macro CALLMONITOR
0365				endif 
0365			 
0365			; might not be working 
0365			;	call se_writepage 
0365			 
0365			;	ret 
0365			; 
0365			 
0365			 
0365			 
0365			.wl1:    
0365			 
0365				; read physical block at hl into de 
0365			        ; increment hl and de to next read position on exit 
0365			 
0365 e5				push hl 
0366 d5				push de	 
0367 c5				push bc 
0368 1a				ld a,(de) 
0369				;if DEBUG_STORESE 
0369			;		push af 
0369			;		ld a, 'W' 
0369			;		ld (debug_mark),a 
0369			;		pop af 
0369			;		CALLMONITOR 
0369			;	endif 
0369 cd c0 01			call se_writebyte 
036c			;	call delay250ms 
036c 00				nop 
036d 00				nop 
036e 00				nop 
036f			;	if DEBUG_STORESE 
036f			;		push af 
036f			;		ld a, 'w' 
036f			;		ld (debug_mark),a 
036f			;		pop af 
036f			;		CALLMONITOR 
036f			;	endif 
036f c1				pop bc 
0370 d1				pop de 
0371 e1				pop hl 
0372 23				inc hl 
0373 13				inc de 
0374			 
0374			 
0374 10 ef			djnz .wl1 
0376			 
0376				if DEBUG_STORESE 
0376					DMARK "SW2" 
0376 f5				push af  
0377 3a 8b 03			ld a, (.dmark)  
037a 32 6e fb			ld (debug_mark),a  
037d 3a 8c 03			ld a, (.dmark+1)  
0380 32 6f fb			ld (debug_mark+1),a  
0383 3a 8d 03			ld a, (.dmark+2)  
0386 32 70 fb			ld (debug_mark+2),a  
0389 18 03			jr .pastdmark  
038b ..			.dmark: db "SW2"  
038e f1			.pastdmark: pop af  
038f			endm  
# End of macro DMARK
038f			 
038f					;push af 
038f					;ld a, 'W' 
038f					;ld (debug_mark),a 
038f					;pop af 
038f					CALLMONITOR 
038f cd ab 16			call break_point_state  
0392				endm  
# End of macro CALLMONITOR
0392				endif 
0392 c9				ret	 
0393			 
0393			; Init bank 
0393			; --------- 
0393			; 
0393			; With current bank 
0393			; 
0393			; Setup block 0 config 
0393			;     Set 0 file id counter 
0393			;     Set formatted byte pattern 
0393			;     Zero out bank label 
0393			;      
0393			; For every logical block write 0-1 byte as null 
0393			 
0393			storage_get_block_0: 
0393			 
0393				; TODO check presence 
0393			 
0393				; get block 0 config 
0393			 
0393 21 00 00			ld hl, 0 
0396 11 59 f8			ld de, store_page 
0399 cd e2 02			call storage_read_block 
039c			 
039c				if DEBUG_STORESE 
039c					DMARK "SB0" 
039c f5				push af  
039d 3a b1 03			ld a, (.dmark)  
03a0 32 6e fb			ld (debug_mark),a  
03a3 3a b2 03			ld a, (.dmark+1)  
03a6 32 6f fb			ld (debug_mark+1),a  
03a9 3a b3 03			ld a, (.dmark+2)  
03ac 32 70 fb			ld (debug_mark+2),a  
03af 18 03			jr .pastdmark  
03b1 ..			.dmark: db "SB0"  
03b4 f1			.pastdmark: pop af  
03b5			endm  
# End of macro DMARK
03b5 11 59 f8				ld de, store_page 
03b8			;		push af 
03b8			;		ld a, 'i' 
03b8			;		ld (debug_mark),a 
03b8			;		pop af 
03b8					CALLMONITOR 
03b8 cd ab 16			call break_point_state  
03bb				endm  
# End of macro CALLMONITOR
03bb				endif 
03bb			 
03bb				; is this area formatted? 
03bb			 
03bb			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03bb 2a 5a f8			ld hl, (store_page+1) 
03be 3e 80			ld a,0x80 
03c0 bd				cp l 
03c1 20 22			jr nz, .ininotformatted 
03c3				; do a double check 
03c3 3e 27			ld a, 0x27 
03c5 bc				cp h 
03c6 20 1d			jr nz, .ininotformatted 
03c8			 
03c8				; formatted then 
03c8			 
03c8				if DEBUG_STORESE 
03c8					DMARK "SB1" 
03c8 f5				push af  
03c9 3a dd 03			ld a, (.dmark)  
03cc 32 6e fb			ld (debug_mark),a  
03cf 3a de 03			ld a, (.dmark+1)  
03d2 32 6f fb			ld (debug_mark+1),a  
03d5 3a df 03			ld a, (.dmark+2)  
03d8 32 70 fb			ld (debug_mark+2),a  
03db 18 03			jr .pastdmark  
03dd ..			.dmark: db "SB1"  
03e0 f1			.pastdmark: pop af  
03e1			endm  
# End of macro DMARK
03e1					;push af 
03e1					;ld a, 'I' 
03e1					;ld (debug_mark),a 
03e1					;pop af 
03e1					CALLMONITOR 
03e1 cd ab 16			call break_point_state  
03e4				endm  
# End of macro CALLMONITOR
03e4				endif 
03e4 c9				ret 
03e5			 
03e5			.ininotformatted: 
03e5				; bank not formatted so poke various bits to make sure 
03e5			 
03e5				if DEBUG_STORESE 
03e5					DMARK "SB2" 
03e5 f5				push af  
03e6 3a fa 03			ld a, (.dmark)  
03e9 32 6e fb			ld (debug_mark),a  
03ec 3a fb 03			ld a, (.dmark+1)  
03ef 32 6f fb			ld (debug_mark+1),a  
03f2 3a fc 03			ld a, (.dmark+2)  
03f5 32 70 fb			ld (debug_mark+2),a  
03f8 18 03			jr .pastdmark  
03fa ..			.dmark: db "SB2"  
03fd f1			.pastdmark: pop af  
03fe			endm  
# End of macro DMARK
03fe					;push af 
03fe					;ld a, 'f' 
03fe					;ld (debug_mark),a 
03fe					;pop af 
03fe					CALLMONITOR 
03fe cd ab 16			call break_point_state  
0401				endm  
# End of macro CALLMONITOR
0401				endif 
0401			 
0401 cd 10 0a			call storage_clear_page 
0404			 
0404 21 59 f8			ld hl, store_page 
0407 3e 00			ld a, 0 
0409				 
0409 77				ld (hl),a   ; reset file counter 
040a			 
040a 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
040d 22 5a f8		 	ld (store_page+1), hl	 
0410			 
0410				; set default label 
0410			 
0410 21 ac 04			ld hl, .defaultbanklabl 
0413 11 5c f8		 	ld de, store_page+3 
0416 01 0f 00			ld bc, 15 
0419 ed b0			ldir 
041b			 
041b				; Append the current bank id 
041b 21 65 f8			ld hl, store_page+3+9 
041e 3a 3e f8			ld a, (spi_device_id) 
0421 77				ld (hl), a 
0422			 
0422				; save default page 0 
0422			 
0422 21 00 00			ld hl, 0 
0425 11 59 f8			ld de, store_page 
0428				if DEBUG_STORESE 
0428					DMARK "SB3" 
0428 f5				push af  
0429 3a 3d 04			ld a, (.dmark)  
042c 32 6e fb			ld (debug_mark),a  
042f 3a 3e 04			ld a, (.dmark+1)  
0432 32 6f fb			ld (debug_mark+1),a  
0435 3a 3f 04			ld a, (.dmark+2)  
0438 32 70 fb			ld (debug_mark+2),a  
043b 18 03			jr .pastdmark  
043d ..			.dmark: db "SB3"  
0440 f1			.pastdmark: pop af  
0441			endm  
# End of macro DMARK
0441			;		push af 
0441			;		ld a, 'F' 
0441			;		ld (debug_mark),a 
0441			;		pop af 
0441					CALLMONITOR 
0441 cd ab 16			call break_point_state  
0444				endm  
# End of macro CALLMONITOR
0444				endif 
0444 cd 47 03			call storage_write_block 
0447				if DEBUG_STORESE 
0447					DMARK "SB4" 
0447 f5				push af  
0448 3a 5c 04			ld a, (.dmark)  
044b 32 6e fb			ld (debug_mark),a  
044e 3a 5d 04			ld a, (.dmark+1)  
0451 32 6f fb			ld (debug_mark+1),a  
0454 3a 5e 04			ld a, (.dmark+2)  
0457 32 70 fb			ld (debug_mark+2),a  
045a 18 03			jr .pastdmark  
045c ..			.dmark: db "SB4"  
045f f1			.pastdmark: pop af  
0460			endm  
# End of macro DMARK
0460			;		push af 
0460			;		ld a, '>' 
0460			;		ld (debug_mark),a 
0460			;		pop af 
0460					CALLMONITOR 
0460 cd ab 16			call break_point_state  
0463				endm  
# End of macro CALLMONITOR
0463				endif 
0463			 
0463 00				nop 
0464 00				nop 
0465 00				nop 
0466			 
0466				; now set 0 in every page to mark as a free block 
0466			 
0466 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0468 21 40 00			ld hl, STORE_BLOCK_PHY 
046b			 
046b 3e 00		.setmark1:   	ld a,0 
046d e5					push hl 
046e c5					push bc 
046f cd c0 01				call se_writebyte 
0472 3e 0a			ld a, 10 
0474 cd 32 0a			call aDelayInMS 
0477 23				inc hl 
0478 cd c0 01				call se_writebyte 
047b 3e 0a			ld a, 10 
047d cd 32 0a			call aDelayInMS 
0480 2b				dec hl 
0481 c1					pop bc 
0482 e1					pop hl 
0483 3e 40				ld a, STORE_BLOCK_PHY 
0485 cd 04 0d				call addatohl 
0488 10 e1				djnz .setmark1 
048a			 
048a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048c 3e 00		.setmark2:   	ld a,0 
048e e5					push hl 
048f c5					push bc 
0490 cd c0 01				call se_writebyte 
0493 3e 0a			ld a, 10 
0495 cd 32 0a			call aDelayInMS 
0498 23				inc hl 
0499 cd c0 01				call se_writebyte 
049c 3e 0a			ld a, 10 
049e cd 32 0a			call aDelayInMS 
04a1 2b				dec hl 
04a2 c1					pop bc 
04a3 e1					pop hl 
04a4 3e 40				ld a, STORE_BLOCK_PHY 
04a6 cd 04 0d				call addatohl 
04a9 10 e1				djnz .setmark2 
04ab			 
04ab					 
04ab			 
04ab			 
04ab c9				ret 
04ac			 
04ac			 
04ac			 
04ac			 
04ac .. 00		.defaultbanklabl:   db "BankLabel_",0 
04b7			 
04b7			 
04b7			 
04b7			; Label Bank 
04b7			; ---------- 
04b7			; 
04b7			; With current bank 
04b7			; Read block 0 
04b7			; Set label 
04b7			; Write block 0 
04b7			 
04b7			; label str pointer in hl 
04b7			 
04b7			storage_label:     
04b7			 
04b7				if DEBUG_STORESE 
04b7					DMARK "LBL" 
04b7 f5				push af  
04b8 3a cc 04			ld a, (.dmark)  
04bb 32 6e fb			ld (debug_mark),a  
04be 3a cd 04			ld a, (.dmark+1)  
04c1 32 6f fb			ld (debug_mark+1),a  
04c4 3a ce 04			ld a, (.dmark+2)  
04c7 32 70 fb			ld (debug_mark+2),a  
04ca 18 03			jr .pastdmark  
04cc ..			.dmark: db "LBL"  
04cf f1			.pastdmark: pop af  
04d0			endm  
# End of macro DMARK
04d0					CALLMONITOR 
04d0 cd ab 16			call break_point_state  
04d3				endm  
# End of macro CALLMONITOR
04d3				endif 
04d3			 
04d3 e5				push hl 
04d4			 
04d4 cd 93 03			call storage_get_block_0 
04d7			 
04d7				; set default label 
04d7			 
04d7 e1				pop hl 
04d8			 
04d8 11 5c f8		 	ld de, store_page+3 
04db 01 0f 00			ld bc, 15 
04de				if DEBUG_STORESE 
04de					DMARK "LB3" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 6e fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 6f fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 70 fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LB3"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd ab 16			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa ed b0			ldir 
04fc				; save default page 0 
04fc			 
04fc 21 00 00			ld hl, 0 
04ff 11 59 f8			ld de, store_page 
0502				if DEBUG_STORESE 
0502					DMARK "LBW" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 6e fb			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 6f fb			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 70 fb			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "LBW"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					CALLMONITOR 
051b cd ab 16			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e cd 47 03			call storage_write_block 
0521			 
0521 c9				ret 
0522			 
0522			 
0522			 
0522			; Read Block 0 - Config 
0522			; --------------------- 
0522			; 
0522			; With current bank 
0522			; Call presence test 
0522			;    If not present format/init bank  
0522			; Read block 0  
0522			;  
0522			 
0522			 
0522			; Dir 
0522			; --- 
0522			; 
0522			; With current bank 
0522			; Load Block 0 Config 
0522			; Get max file id number 
0522			; For each logical block 
0522			;    Read block read byte 2 
0522			;      if first block of file 
0522			;         Display file name 
0522			;         Display type flags for file 
0522			;        
0522			 
0522			; moving to words as this requires stack control 
0522			 
0522			 
0522			; Delete File 
0522			; ----------- 
0522			; 
0522			; With current bank 
0522			; 
0522			; Load Block 0 Config 
0522			; Get max file id number 
0522			; For each logical block 
0522			;    Read block file id 
0522			;      If first block of file and dont have file id 
0522			;         if file to delete 
0522			;         Save file id 
0522			;         Null file id 
0522			;         Write this block back 
0522			;      If file id is one saved 
0522			;         Null file id 
0522			;         Write this block back 
0522			 
0522			 
0522			.se_done: 
0522 e1				pop hl 
0523 c9				ret 
0524			 
0524			storage_erase: 
0524			 
0524				; hl contains the file id 
0524			 
0524 5d				ld e, l 
0525 16 00			ld d, 0 
0527 21 40 00			ld hl, STORE_BLOCK_PHY 
052a					if DEBUG_FORTH_WORDS 
052a						DMARK "ERA" 
052a f5				push af  
052b 3a 3f 05			ld a, (.dmark)  
052e 32 6e fb			ld (debug_mark),a  
0531 3a 40 05			ld a, (.dmark+1)  
0534 32 6f fb			ld (debug_mark+1),a  
0537 3a 41 05			ld a, (.dmark+2)  
053a 32 70 fb			ld (debug_mark+2),a  
053d 18 03			jr .pastdmark  
053f ..			.dmark: db "ERA"  
0542 f1			.pastdmark: pop af  
0543			endm  
# End of macro DMARK
0543						CALLMONITOR 
0543 cd ab 16			call break_point_state  
0546				endm  
# End of macro CALLMONITOR
0546					endif 
0546 cd 15 06			call storage_findnextid 
0549 cd 2d 0d			call ishlzero 
054c c8				ret z 
054d			 
054d e5				push hl 
054e			 
054e				; TODO check file not found 
054e			 
054e 11 59 f8			ld de, store_page 
0551 cd e2 02			call storage_read_block 
0554			 
0554 cd 2d 0d			call ishlzero 
0557 ca 22 05			jp z,.se_done 
055a			 
055a					if DEBUG_FORTH_WORDS 
055a						DMARK "ER1" 
055a f5				push af  
055b 3a 6f 05			ld a, (.dmark)  
055e 32 6e fb			ld (debug_mark),a  
0561 3a 70 05			ld a, (.dmark+1)  
0564 32 6f fb			ld (debug_mark+1),a  
0567 3a 71 05			ld a, (.dmark+2)  
056a 32 70 fb			ld (debug_mark+2),a  
056d 18 03			jr .pastdmark  
056f ..			.dmark: db "ER1"  
0572 f1			.pastdmark: pop af  
0573			endm  
# End of macro DMARK
0573						CALLMONITOR 
0573 cd ab 16			call break_point_state  
0576				endm  
# End of macro CALLMONITOR
0576					endif 
0576 3a 59 f8			ld a, (store_page)	; get file id 
0579 32 52 f8			ld (store_tmpid), a 
057c			 
057c 3a 5b f8			ld a, (store_page+2)    ; get count of extends 
057f 32 51 f8			ld (store_tmpext), a 
0582			 
0582				; wipe file header 
0582			 
0582 e1				pop hl 
0583 3e 00			ld a, 0 
0585 32 59 f8			ld (store_page), a 
0588 32 5a f8			ld (store_page+1),a 
058b 11 59 f8			ld de, store_page 
058e					if DEBUG_FORTH_WORDS 
058e						DMARK "ER2" 
058e f5				push af  
058f 3a a3 05			ld a, (.dmark)  
0592 32 6e fb			ld (debug_mark),a  
0595 3a a4 05			ld a, (.dmark+1)  
0598 32 6f fb			ld (debug_mark+1),a  
059b 3a a5 05			ld a, (.dmark+2)  
059e 32 70 fb			ld (debug_mark+2),a  
05a1 18 03			jr .pastdmark  
05a3 ..			.dmark: db "ER2"  
05a6 f1			.pastdmark: pop af  
05a7			endm  
# End of macro DMARK
05a7						CALLMONITOR 
05a7 cd ab 16			call break_point_state  
05aa				endm  
# End of macro CALLMONITOR
05aa					endif 
05aa cd 47 03			call storage_write_block 
05ad			 
05ad			 
05ad				; wipe file extents 
05ad			 
05ad 3a 51 f8			ld a, (store_tmpext) 
05b0 47				ld b, a 
05b1			 
05b1			.eraext:	  
05b1 c5				push bc 
05b2			 
05b2 21 40 00			ld hl, STORE_BLOCK_PHY 
05b5 3a 52 f8			ld a,(store_tmpid) 
05b8 5f				ld e, a 
05b9 50				ld d, b	 
05ba					if DEBUG_FORTH_WORDS 
05ba						DMARK "ER3" 
05ba f5				push af  
05bb 3a cf 05			ld a, (.dmark)  
05be 32 6e fb			ld (debug_mark),a  
05c1 3a d0 05			ld a, (.dmark+1)  
05c4 32 6f fb			ld (debug_mark+1),a  
05c7 3a d1 05			ld a, (.dmark+2)  
05ca 32 70 fb			ld (debug_mark+2),a  
05cd 18 03			jr .pastdmark  
05cf ..			.dmark: db "ER3"  
05d2 f1			.pastdmark: pop af  
05d3			endm  
# End of macro DMARK
05d3						CALLMONITOR 
05d3 cd ab 16			call break_point_state  
05d6				endm  
# End of macro CALLMONITOR
05d6					endif 
05d6 cd 15 06			call storage_findnextid 
05d9 cd 2d 0d			call ishlzero 
05dc ca 22 05			jp z,.se_done 
05df			 
05df e5				push hl 
05e0 11 59 f8			ld de, store_page 
05e3 cd e2 02			call storage_read_block 
05e6			 
05e6				; free block	 
05e6			 
05e6 3e 00			ld a, 0 
05e8 32 59 f8			ld (store_page), a 
05eb 32 5a f8			ld (store_page+1),a 
05ee 11 59 f8			ld de, store_page 
05f1 e1				pop hl 
05f2					if DEBUG_FORTH_WORDS 
05f2						DMARK "ER4" 
05f2 f5				push af  
05f3 3a 07 06			ld a, (.dmark)  
05f6 32 6e fb			ld (debug_mark),a  
05f9 3a 08 06			ld a, (.dmark+1)  
05fc 32 6f fb			ld (debug_mark+1),a  
05ff 3a 09 06			ld a, (.dmark+2)  
0602 32 70 fb			ld (debug_mark+2),a  
0605 18 03			jr .pastdmark  
0607 ..			.dmark: db "ER4"  
060a f1			.pastdmark: pop af  
060b			endm  
# End of macro DMARK
060b						CALLMONITOR 
060b cd ab 16			call break_point_state  
060e				endm  
# End of macro CALLMONITOR
060e					endif 
060e cd 47 03			call storage_write_block 
0611			 
0611 c1				pop bc 
0612 10 9d			djnz .eraext 
0614			 
0614 c9				ret 
0615			 
0615			 
0615			; Find Free Block 
0615			; --------------- 
0615			; 
0615			; With current bank 
0615			;  
0615			; From given starting logical block 
0615			;    Read block  
0615			;    If no file id 
0615			;         Return block id 
0615			 
0615			 
0615			; hl starting page number 
0615			; hl contains free page number or zero if no pages free 
0615			; e contains the file id to locate 
0615			; d contains the block number 
0615			 
0615			; TODO change to find file id and use zero for free block 
0615			 
0615			storage_findnextid: 
0615			 
0615				; now locate first 0 page to mark as a free block 
0615			 
0615 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0617			;	ld hl, STORE_BLOCK_PHY 
0617			 
0617					if DEBUG_FORTH_WORDS 
0617					DMARK "FNI" 
0617 f5				push af  
0618 3a 2c 06			ld a, (.dmark)  
061b 32 6e fb			ld (debug_mark),a  
061e 3a 2d 06			ld a, (.dmark+1)  
0621 32 6f fb			ld (debug_mark+1),a  
0624 3a 2e 06			ld a, (.dmark+2)  
0627 32 70 fb			ld (debug_mark+2),a  
062a 18 03			jr .pastdmark  
062c ..			.dmark: db "FNI"  
062f f1			.pastdmark: pop af  
0630			endm  
# End of macro DMARK
0630						CALLMONITOR 
0630 cd ab 16			call break_point_state  
0633				endm  
# End of macro CALLMONITOR
0633					endif 
0633			.ff1:   	 
0633 e5					push hl 
0634 c5					push bc 
0635 d5					push de 
0636 cd 62 02				call se_readbyte 
0639 5f					ld e,a 
063a 23					inc hl 
063b cd 62 02				call se_readbyte 
063e 57					ld d, a 
063f e1					pop hl 
0640 e5					push hl 
0641 cd 22 0d				call cmp16 
0644 28 49				jr z, .fffound 
0646			 
0646 d1					pop de 
0647 c1					pop bc 
0648 e1					pop hl 
0649			 
0649					; is found? 
0649					;cp e 
0649					;ret z 
0649			 
0649 3e 40				ld a, STORE_BLOCK_PHY 
064b cd 04 0d				call addatohl 
064e 10 e3				djnz .ff1 
0650			 
0650 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0652			.ff2:   	 
0652			 
0652 e5					push hl 
0653 c5					push bc 
0654 d5					push de 
0655 cd 62 02				call se_readbyte 
0658 5f					ld e,a 
0659 23					inc hl 
065a cd 62 02				call se_readbyte 
065d 57					ld d, a 
065e			 
065e e1					pop hl 
065f e5					push hl 
0660 cd 22 0d				call cmp16 
0663 28 2a				jr z, .fffound 
0665			 
0665 d1					pop de 
0666 c1					pop bc 
0667 e1					pop hl 
0668					; is found? 
0668					;cp e 
0668					;ret z 
0668			 
0668 3e 40				ld a, STORE_BLOCK_PHY 
066a cd 04 0d				call addatohl 
066d 10 e3				djnz .ff2 
066f			 
066f			 
066f					if DEBUG_FORTH_WORDS 
066f					DMARK "FN-" 
066f f5				push af  
0670 3a 84 06			ld a, (.dmark)  
0673 32 6e fb			ld (debug_mark),a  
0676 3a 85 06			ld a, (.dmark+1)  
0679 32 6f fb			ld (debug_mark+1),a  
067c 3a 86 06			ld a, (.dmark+2)  
067f 32 70 fb			ld (debug_mark+2),a  
0682 18 03			jr .pastdmark  
0684 ..			.dmark: db "FN-"  
0687 f1			.pastdmark: pop af  
0688			endm  
# End of macro DMARK
0688					;	push af 
0688					;	ld a, 'n' 
0688					;	ld (debug_mark),a 
0688					;	pop af 
0688						CALLMONITOR 
0688 cd ab 16			call break_point_state  
068b				endm  
# End of macro CALLMONITOR
068b					endif 
068b				; no free marks! 
068b 21 00 00				ld hl, 0 
068e c9				ret 
068f			.fffound: 
068f				 
068f			 
068f d1					pop de 
0690 c1					pop bc 
0691 e1					pop hl 
0692					if DEBUG_FORTH_WORDS 
0692					DMARK "FNF" 
0692 f5				push af  
0693 3a a7 06			ld a, (.dmark)  
0696 32 6e fb			ld (debug_mark),a  
0699 3a a8 06			ld a, (.dmark+1)  
069c 32 6f fb			ld (debug_mark+1),a  
069f 3a a9 06			ld a, (.dmark+2)  
06a2 32 70 fb			ld (debug_mark+2),a  
06a5 18 03			jr .pastdmark  
06a7 ..			.dmark: db "FNF"  
06aa f1			.pastdmark: pop af  
06ab			endm  
# End of macro DMARK
06ab					;	push af 
06ab					;	ld a, 'n' 
06ab					;	ld (debug_mark),a 
06ab					;	pop af 
06ab						CALLMONITOR 
06ab cd ab 16			call break_point_state  
06ae				endm  
# End of macro CALLMONITOR
06ae					endif 
06ae c9				ret 
06af			 
06af			 
06af			 
06af			; Free Space 
06af			; ---------- 
06af			; 
06af			; With current bank 
06af			; 
06af			; Set block count to zero 
06af			; Starting with first logical block 
06af			;      Find free block  
06af			;      If block id given, increment block count 
06af			; 
06af			;  
06af			 
06af			 
06af			; hl contains count of free blocks 
06af			 
06af			storage_freeblocks: 
06af			 
06af				; now locate first 0 page to mark as a free block 
06af			 
06af 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06b1 21 40 00			ld hl, STORE_BLOCK_PHY 
06b4 11 00 00			ld de, 0 
06b7			 
06b7			.fb1:   	 
06b7 e5					push hl 
06b8 c5					push bc 
06b9 d5					push de 
06ba cd 62 02				call se_readbyte 
06bd d1					pop de 
06be c1					pop bc 
06bf e1					pop hl 
06c0			 
06c0					; is free? 
06c0 fe 00				cp 0 
06c2 20 01				jr nz, .ff1cont 
06c4 13					inc de 
06c5			 
06c5			.ff1cont: 
06c5			 
06c5			 
06c5 3e 40				ld a, STORE_BLOCK_PHY 
06c7 cd 04 0d				call addatohl 
06ca 10 eb				djnz .fb1 
06cc			 
06cc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06ce			.fb2:   	 
06ce e5					push hl 
06cf c5					push bc 
06d0 d5					push de 
06d1 cd 62 02				call se_readbyte 
06d4 d1					pop de 
06d5 c1					pop bc 
06d6 e1					pop hl 
06d7			 
06d7					; is free? 
06d7 fe 00				cp 0 
06d9 20 01				jr nz, .ff2cont 
06db 13					inc de 
06dc			 
06dc			.ff2cont: 
06dc			 
06dc 3e 40				ld a, STORE_BLOCK_PHY 
06de cd 04 0d				call addatohl 
06e1 10 eb				djnz .fb2 
06e3			 
06e3 eb				ex de, hl 
06e4 c9				ret 
06e5			 
06e5			; Get File ID 
06e5			; ----------- 
06e5			; 
06e5			; With current bank 
06e5			;  
06e5			; Load Block 0 Config 
06e5			; Get max file id number 
06e5			; For each logical block 
06e5			;    Read block file id 
06e5			;      If first block of file and dont have file id 
06e5			;         if file get id and exit 
06e5			 
06e5			 
06e5			 
06e5			 
06e5			; Create File 
06e5			; ----------- 
06e5			; 
06e5			; With current bank  
06e5			; Load Block 0 Config 
06e5			; Get max file id number 
06e5			; Increment file id number 
06e5			; Save Config 
06e5			; Find free block 
06e5			; Set buffer with file name and file id 
06e5			; Write buffer to free block  
06e5			 
06e5			 
06e5			; hl point to file name 
06e5			; hl returns file id 
06e5			 
06e5			; file format: 
06e5			; byte 0 - file id 
06e5			; byte 1 - extent number 
06e5			; byte 2-> data 
06e5			 
06e5			; format for extent number 0: 
06e5			; 
06e5			; byte 0 - file id 
06e5			; byte 1 - extent 0 
06e5			; byte 2 - extent count 
06e5			; byte 3 -> file name and meta data 
06e5			 
06e5			 
06e5			storage_create: 
06e5				if DEBUG_STORESE 
06e5					DMARK "SCR" 
06e5 f5				push af  
06e6 3a fa 06			ld a, (.dmark)  
06e9 32 6e fb			ld (debug_mark),a  
06ec 3a fb 06			ld a, (.dmark+1)  
06ef 32 6f fb			ld (debug_mark+1),a  
06f2 3a fc 06			ld a, (.dmark+2)  
06f5 32 70 fb			ld (debug_mark+2),a  
06f8 18 03			jr .pastdmark  
06fa ..			.dmark: db "SCR"  
06fd f1			.pastdmark: pop af  
06fe			endm  
# End of macro DMARK
06fe					CALLMONITOR 
06fe cd ab 16			call break_point_state  
0701				endm  
# End of macro CALLMONITOR
0701				endif 
0701			 
0701 e5				push hl		; save file name pointer 
0702			 
0702 cd 93 03			call storage_get_block_0 
0705			 
0705 3a 59 f8			ld a,(store_page)	; get current file id 
0708 3c				inc a 
0709 32 59 f8			ld (store_page),a 
070c				 
070c 32 52 f8			ld (store_tmpid),a			; save id 
070f			 
070f 21 00 00			ld hl, 0 
0712 11 59 f8			ld de, store_page 
0715				if DEBUG_STORESE 
0715					DMARK "SCw" 
0715 f5				push af  
0716 3a 2a 07			ld a, (.dmark)  
0719 32 6e fb			ld (debug_mark),a  
071c 3a 2b 07			ld a, (.dmark+1)  
071f 32 6f fb			ld (debug_mark+1),a  
0722 3a 2c 07			ld a, (.dmark+2)  
0725 32 70 fb			ld (debug_mark+2),a  
0728 18 03			jr .pastdmark  
072a ..			.dmark: db "SCw"  
072d f1			.pastdmark: pop af  
072e			endm  
# End of macro DMARK
072e					CALLMONITOR 
072e cd ab 16			call break_point_state  
0731				endm  
# End of macro CALLMONITOR
0731				endif 
0731 cd 47 03			call storage_write_block	 ; save update 
0734			 
0734				if DEBUG_STORESE 
0734 11 59 f8				ld de, store_page 
0737					DMARK "SCC" 
0737 f5				push af  
0738 3a 4c 07			ld a, (.dmark)  
073b 32 6e fb			ld (debug_mark),a  
073e 3a 4d 07			ld a, (.dmark+1)  
0741 32 6f fb			ld (debug_mark+1),a  
0744 3a 4e 07			ld a, (.dmark+2)  
0747 32 70 fb			ld (debug_mark+2),a  
074a 18 03			jr .pastdmark  
074c ..			.dmark: db "SCC"  
074f f1			.pastdmark: pop af  
0750			endm  
# End of macro DMARK
0750					CALLMONITOR 
0750 cd ab 16			call break_point_state  
0753				endm  
# End of macro CALLMONITOR
0753				endif 
0753				;  
0753				 
0753 21 40 00			ld hl, STORE_BLOCK_PHY 
0756 11 00 00			ld de, 0 
0759 cd 15 06			call storage_findnextid 
075c			 
075c 22 43 f8			ld (store_tmppageid), hl    ; save page to use  
075f			 
075f				; TODO detect 0 = no spare blocks 
075f			 
075f				; hl now contains the free page to use for the file header page 
075f			 
075f				if DEBUG_STORESE 
075f				DMARK "SCF" 
075f f5				push af  
0760 3a 74 07			ld a, (.dmark)  
0763 32 6e fb			ld (debug_mark),a  
0766 3a 75 07			ld a, (.dmark+1)  
0769 32 6f fb			ld (debug_mark+1),a  
076c 3a 76 07			ld a, (.dmark+2)  
076f 32 70 fb			ld (debug_mark+2),a  
0772 18 03			jr .pastdmark  
0774 ..			.dmark: db "SCF"  
0777 f1			.pastdmark: pop af  
0778			endm  
# End of macro DMARK
0778					CALLMONITOR 
0778 cd ab 16			call break_point_state  
077b				endm  
# End of macro CALLMONITOR
077b				endif 
077b			 
077b 22 43 f8			ld (store_tmppageid), hl 
077e				 
077e 3a 52 f8			ld a,(store_tmpid)    ; get file id 
0781			;	ld a, (store_filecache)			; save to cache 
0781			 
0781 32 59 f8			ld (store_page),a    ; set page id 
0784 3e 00			ld a, 0			 ; extent 0 is file header 
0786 32 5a f8			ld (store_page+1), a   ; set file extent 
0789			 
0789 32 5b f8			ld (store_page+2), a   ; extent count for the file 
078c			 
078c			;	inc hl 		; init block 0 of file 
078c			;	inc hl   		; skip file and extent id 
078c			 ;       ld a, 0 
078c			;	ld (hl),a 
078c			;	ld a, (store_filecache+1)  	; save to cache 
078c			 
078c			;	inc hl    ; file name 
078c				 
078c				 
078c 11 5c f8			ld de, store_page+3    ; get buffer for term string to use as file name 
078f				if DEBUG_STORESE 
078f					DMARK "SCc" 
078f f5				push af  
0790 3a a4 07			ld a, (.dmark)  
0793 32 6e fb			ld (debug_mark),a  
0796 3a a5 07			ld a, (.dmark+1)  
0799 32 6f fb			ld (debug_mark+1),a  
079c 3a a6 07			ld a, (.dmark+2)  
079f 32 70 fb			ld (debug_mark+2),a  
07a2 18 03			jr .pastdmark  
07a4 ..			.dmark: db "SCc"  
07a7 f1			.pastdmark: pop af  
07a8			endm  
# End of macro DMARK
07a8					CALLMONITOR 
07a8 cd ab 16			call break_point_state  
07ab				endm  
# End of macro CALLMONITOR
07ab				endif 
07ab e1				pop hl    ; get zero term string 
07ac e5				push hl 
07ad 3e 00			ld a, 0 
07af cd 6d 11			call strlent 
07b2 23				inc hl   ; cover zero term 
07b3 06 00			ld b,0 
07b5 4d				ld c,l 
07b6 e1				pop hl 
07b7				;ex de, hl 
07b7				if DEBUG_STORESE 
07b7					DMARK "SCa" 
07b7 f5				push af  
07b8 3a cc 07			ld a, (.dmark)  
07bb 32 6e fb			ld (debug_mark),a  
07be 3a cd 07			ld a, (.dmark+1)  
07c1 32 6f fb			ld (debug_mark+1),a  
07c4 3a ce 07			ld a, (.dmark+2)  
07c7 32 70 fb			ld (debug_mark+2),a  
07ca 18 03			jr .pastdmark  
07cc ..			.dmark: db "SCa"  
07cf f1			.pastdmark: pop af  
07d0			endm  
# End of macro DMARK
07d0					;push af 
07d0					;ld a, 'a' 
07d0					;ld (debug_mark),a 
07d0					;pop af 
07d0					CALLMONITOR 
07d0 cd ab 16			call break_point_state  
07d3				endm  
# End of macro CALLMONITOR
07d3				endif 
07d3 ed b0			ldir    ; copy zero term string 
07d5				if DEBUG_STORESE 
07d5					DMARK "SCA" 
07d5 f5				push af  
07d6 3a ea 07			ld a, (.dmark)  
07d9 32 6e fb			ld (debug_mark),a  
07dc 3a eb 07			ld a, (.dmark+1)  
07df 32 6f fb			ld (debug_mark+1),a  
07e2 3a ec 07			ld a, (.dmark+2)  
07e5 32 70 fb			ld (debug_mark+2),a  
07e8 18 03			jr .pastdmark  
07ea ..			.dmark: db "SCA"  
07ed f1			.pastdmark: pop af  
07ee			endm  
# End of macro DMARK
07ee					CALLMONITOR 
07ee cd ab 16			call break_point_state  
07f1				endm  
# End of macro CALLMONITOR
07f1				endif 
07f1			 
07f1				; write file header page 
07f1			 
07f1 2a 43 f8			ld hl,(store_tmppageid) 
07f4 11 59 f8			ld de, store_page 
07f7				if DEBUG_STORESE 
07f7					DMARK "SCb" 
07f7 f5				push af  
07f8 3a 0c 08			ld a, (.dmark)  
07fb 32 6e fb			ld (debug_mark),a  
07fe 3a 0d 08			ld a, (.dmark+1)  
0801 32 6f fb			ld (debug_mark+1),a  
0804 3a 0e 08			ld a, (.dmark+2)  
0807 32 70 fb			ld (debug_mark+2),a  
080a 18 03			jr .pastdmark  
080c ..			.dmark: db "SCb"  
080f f1			.pastdmark: pop af  
0810			endm  
# End of macro DMARK
0810					;push af 
0810					;ld a, 'b' 
0810					;ld (debug_mark),a 
0810					;pop af 
0810					CALLMONITOR 
0810 cd ab 16			call break_point_state  
0813				endm  
# End of macro CALLMONITOR
0813				endif 
0813 cd 47 03			call storage_write_block 
0816			 
0816 3a 52 f8			ld a, (store_tmpid) 
0819 6f				ld l, a 
081a 26 00			ld h,0 
081c				if DEBUG_STORESE 
081c					DMARK "SCz" 
081c f5				push af  
081d 3a 31 08			ld a, (.dmark)  
0820 32 6e fb			ld (debug_mark),a  
0823 3a 32 08			ld a, (.dmark+1)  
0826 32 6f fb			ld (debug_mark+1),a  
0829 3a 33 08			ld a, (.dmark+2)  
082c 32 70 fb			ld (debug_mark+2),a  
082f 18 03			jr .pastdmark  
0831 ..			.dmark: db "SCz"  
0834 f1			.pastdmark: pop af  
0835			endm  
# End of macro DMARK
0835					CALLMONITOR 
0835 cd ab 16			call break_point_state  
0838				endm  
# End of macro CALLMONITOR
0838				endif 
0838 c9				ret 
0839				 
0839			 
0839			 
0839			; 
0839			; Read File 
0839			; 
0839			; h - file id to locate 
0839			; l - extent to locate 
0839			; de - pointer to string to read into 
0839			; 
0839			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0839			 
0839			.sr_fail: 
0839 d1				pop de 
083a c9				ret 
083b			 
083b			storage_read: 
083b d5				push de 
083c			 
083c			; TODO BUG the above push is it popped before the RET Z? 
083c			 
083c			; TODO how to handle multiple part blocks 
083c			 
083c				; locate file extent to read 
083c			 
083c 5c				ld e, h 
083d 55				ld d, l 
083e 21 40 00			ld hl, STORE_BLOCK_PHY 
0841				if DEBUG_STORESE 
0841					DMARK "SRE" 
0841 f5				push af  
0842 3a 56 08			ld a, (.dmark)  
0845 32 6e fb			ld (debug_mark),a  
0848 3a 57 08			ld a, (.dmark+1)  
084b 32 6f fb			ld (debug_mark+1),a  
084e 3a 58 08			ld a, (.dmark+2)  
0851 32 70 fb			ld (debug_mark+2),a  
0854 18 03			jr .pastdmark  
0856 ..			.dmark: db "SRE"  
0859 f1			.pastdmark: pop af  
085a			endm  
# End of macro DMARK
085a					CALLMONITOR 
085a cd ab 16			call break_point_state  
085d				endm  
# End of macro CALLMONITOR
085d				endif 
085d cd 15 06			call storage_findnextid 
0860			 
0860				if DEBUG_STORESE 
0860					DMARK "SRf" 
0860 f5				push af  
0861 3a 75 08			ld a, (.dmark)  
0864 32 6e fb			ld (debug_mark),a  
0867 3a 76 08			ld a, (.dmark+1)  
086a 32 6f fb			ld (debug_mark+1),a  
086d 3a 77 08			ld a, (.dmark+2)  
0870 32 70 fb			ld (debug_mark+2),a  
0873 18 03			jr .pastdmark  
0875 ..			.dmark: db "SRf"  
0878 f1			.pastdmark: pop af  
0879			endm  
# End of macro DMARK
0879					CALLMONITOR 
0879 cd ab 16			call break_point_state  
087c				endm  
# End of macro CALLMONITOR
087c				endif 
087c cd 2d 0d			call ishlzero 
087f			;	ld a, l 
087f			;	add h 
087f			;	cp 0 
087f 28 b8			jr z,.sr_fail			; block not found so EOF 
0881			 
0881				; hl contains page number to load 
0881 d1				pop de   ; get storage 
0882 d5				push de 
0883				if DEBUG_STORESE 
0883					DMARK "SRg" 
0883 f5				push af  
0884 3a 98 08			ld a, (.dmark)  
0887 32 6e fb			ld (debug_mark),a  
088a 3a 99 08			ld a, (.dmark+1)  
088d 32 6f fb			ld (debug_mark+1),a  
0890 3a 9a 08			ld a, (.dmark+2)  
0893 32 70 fb			ld (debug_mark+2),a  
0896 18 03			jr .pastdmark  
0898 ..			.dmark: db "SRg"  
089b f1			.pastdmark: pop af  
089c			endm  
# End of macro DMARK
089c					CALLMONITOR 
089c cd ab 16			call break_point_state  
089f				endm  
# End of macro CALLMONITOR
089f				endif 
089f cd e2 02			call storage_read_block 
08a2			 
08a2			 
08a2			; TODO if block has no zeros then need to read next block  
08a2			 
08a2			 
08a2					 
08a2 e1				pop hl 		 ; return start of data to show as not EOF 
08a3 23				inc hl   ; past file id 
08a4 23				inc hl   ; past ext 
08a5				if DEBUG_STORESE 
08a5					DMARK "SRe" 
08a5 f5				push af  
08a6 3a ba 08			ld a, (.dmark)  
08a9 32 6e fb			ld (debug_mark),a  
08ac 3a bb 08			ld a, (.dmark+1)  
08af 32 6f fb			ld (debug_mark+1),a  
08b2 3a bc 08			ld a, (.dmark+2)  
08b5 32 70 fb			ld (debug_mark+2),a  
08b8 18 03			jr .pastdmark  
08ba ..			.dmark: db "SRe"  
08bd f1			.pastdmark: pop af  
08be			endm  
# End of macro DMARK
08be					CALLMONITOR 
08be cd ab 16			call break_point_state  
08c1				endm  
# End of macro CALLMONITOR
08c1				endif 
08c1 c9					ret 
08c2			 
08c2			 
08c2			 
08c2			; 
08c2			; Append File 
08c2			; 
08c2			; hl - file id to locate 
08c2			; de - pointer to (multi block) string to write 
08c2			 
08c2			.sa_notfound: 
08c2 d1				pop de 
08c3 c9				ret 
08c4			 
08c4			 
08c4			storage_append: 
08c4				; hl -  file id to append to 
08c4				; de - string to append 
08c4			 
08c4 d5				push de 
08c5				 
08c5				if DEBUG_STORESE 
08c5					DMARK "AP1" 
08c5 f5				push af  
08c6 3a da 08			ld a, (.dmark)  
08c9 32 6e fb			ld (debug_mark),a  
08cc 3a db 08			ld a, (.dmark+1)  
08cf 32 6f fb			ld (debug_mark+1),a  
08d2 3a dc 08			ld a, (.dmark+2)  
08d5 32 70 fb			ld (debug_mark+2),a  
08d8 18 03			jr .pastdmark  
08da ..			.dmark: db "AP1"  
08dd f1			.pastdmark: pop af  
08de			endm  
# End of macro DMARK
08de					CALLMONITOR 
08de cd ab 16			call break_point_state  
08e1				endm  
# End of macro CALLMONITOR
08e1				endif 
08e1			 
08e1 7d				ld a, l 
08e2 32 52 f8			ld (store_tmpid), a 
08e5			 
08e5				; get file header  
08e5			 
08e5 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08e7 3a 52 f8			ld a, (store_tmpid) 
08ea 5f				ld e, a 
08eb			 
08eb 21 40 00				ld hl, STORE_BLOCK_PHY 
08ee cd 15 06				call storage_findnextid 
08f1			 
08f1 cd 2d 0d			call ishlzero 
08f4 28 cc			jr z, .sa_notfound 
08f6			 
08f6 22 43 f8			ld (store_tmppageid), hl 
08f9			 
08f9				; TODO handle file id not found 
08f9			 
08f9				if DEBUG_STORESE 
08f9					DMARK "AP2" 
08f9 f5				push af  
08fa 3a 0e 09			ld a, (.dmark)  
08fd 32 6e fb			ld (debug_mark),a  
0900 3a 0f 09			ld a, (.dmark+1)  
0903 32 6f fb			ld (debug_mark+1),a  
0906 3a 10 09			ld a, (.dmark+2)  
0909 32 70 fb			ld (debug_mark+2),a  
090c 18 03			jr .pastdmark  
090e ..			.dmark: db "AP2"  
0911 f1			.pastdmark: pop af  
0912			endm  
# End of macro DMARK
0912					CALLMONITOR 
0912 cd ab 16			call break_point_state  
0915				endm  
# End of macro CALLMONITOR
0915				endif 
0915			 
0915				; update file extent count 
0915			 
0915 11 59 f8			ld de, store_page 
0918			 
0918 cd e2 02			call storage_read_block 
091b			 
091b				if DEBUG_STORESE 
091b					DMARK "AP3" 
091b f5				push af  
091c 3a 30 09			ld a, (.dmark)  
091f 32 6e fb			ld (debug_mark),a  
0922 3a 31 09			ld a, (.dmark+1)  
0925 32 6f fb			ld (debug_mark+1),a  
0928 3a 32 09			ld a, (.dmark+2)  
092b 32 70 fb			ld (debug_mark+2),a  
092e 18 03			jr .pastdmark  
0930 ..			.dmark: db "AP3"  
0933 f1			.pastdmark: pop af  
0934			endm  
# End of macro DMARK
0934					CALLMONITOR 
0934 cd ab 16			call break_point_state  
0937				endm  
# End of macro CALLMONITOR
0937				endif 
0937			;	ld (store_tmppageid), hl 
0937			 
0937 3a 5b f8			ld a, (store_page+2) 
093a 3c				inc a 
093b 32 5b f8			ld (store_page+2), a 
093e 32 51 f8			ld (store_tmpext), a 
0941				 
0941				if DEBUG_STORESE 
0941					DMARK "AP3" 
0941 f5				push af  
0942 3a 56 09			ld a, (.dmark)  
0945 32 6e fb			ld (debug_mark),a  
0948 3a 57 09			ld a, (.dmark+1)  
094b 32 6f fb			ld (debug_mark+1),a  
094e 3a 58 09			ld a, (.dmark+2)  
0951 32 70 fb			ld (debug_mark+2),a  
0954 18 03			jr .pastdmark  
0956 ..			.dmark: db "AP3"  
0959 f1			.pastdmark: pop af  
095a			endm  
# End of macro DMARK
095a					CALLMONITOR 
095a cd ab 16			call break_point_state  
095d				endm  
# End of macro CALLMONITOR
095d				endif 
095d 2a 43 f8			ld hl, (store_tmppageid) 
0960 11 59 f8			ld de, store_page 
0963 cd 47 03			call storage_write_block 
0966			 
0966				; find free block 
0966			 
0966 11 00 00			ld de, 0			 ; file extent to locate 
0969			 
0969 21 40 00				ld hl, STORE_BLOCK_PHY 
096c cd 15 06				call storage_findnextid 
096f cd 2d 0d			call ishlzero 
0972 ca c2 08			jp z, .sa_notfound 
0975			 
0975					; TODO handle no space left 
0975					 
0975 22 43 f8				ld (store_tmppageid), hl 
0978			 
0978				if DEBUG_STORESE 
0978					DMARK "AP4" 
0978 f5				push af  
0979 3a 8d 09			ld a, (.dmark)  
097c 32 6e fb			ld (debug_mark),a  
097f 3a 8e 09			ld a, (.dmark+1)  
0982 32 6f fb			ld (debug_mark+1),a  
0985 3a 8f 09			ld a, (.dmark+2)  
0988 32 70 fb			ld (debug_mark+2),a  
098b 18 03			jr .pastdmark  
098d ..			.dmark: db "AP4"  
0990 f1			.pastdmark: pop af  
0991			endm  
# End of macro DMARK
0991					CALLMONITOR 
0991 cd ab 16			call break_point_state  
0994				endm  
# End of macro CALLMONITOR
0994				endif 
0994					; init the buffer with zeros so we can id if the buffer is full or not 
0994			 
0994 e5					push hl 
0995 c5					push bc 
0996			 
0996 21 59 f8				ld hl, store_page 
0999 06 40				ld b, STORE_BLOCK_PHY 
099b 3e 00				ld a, 0 
099d 77			.zeroblock:	ld (hl), a 
099e 23					inc hl 
099f 10 fc				djnz .zeroblock 
09a1			 
09a1 c1					pop bc 
09a2 e1					pop hl 
09a3			 
09a3					; construct block 
09a3			 
09a3 3a 52 f8				ld a, (store_tmpid) 
09a6 32 59 f8				ld (store_page), a   ; file id 
09a9 3a 51 f8				ld a, (store_tmpext)   ; extent for this block 
09ac 32 5a f8				ld (store_page+1), a 
09af			 
09af e1					pop hl    ; get string to write 
09b0 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09b2 11 5b f8				ld de, store_page+2 
09b5			 
09b5				if DEBUG_STORESE 
09b5					DMARK "AP5" 
09b5 f5				push af  
09b6 3a ca 09			ld a, (.dmark)  
09b9 32 6e fb			ld (debug_mark),a  
09bc 3a cb 09			ld a, (.dmark+1)  
09bf 32 6f fb			ld (debug_mark+1),a  
09c2 3a cc 09			ld a, (.dmark+2)  
09c5 32 70 fb			ld (debug_mark+2),a  
09c8 18 03			jr .pastdmark  
09ca ..			.dmark: db "AP5"  
09cd f1			.pastdmark: pop af  
09ce			endm  
# End of macro DMARK
09ce					CALLMONITOR 
09ce cd ab 16			call break_point_state  
09d1				endm  
# End of macro CALLMONITOR
09d1				endif 
09d1			 
09d1			 
09d1			 
09d1					; fill buffer with data until end of string or full block 
09d1			 
09d1 7e			.appd:		ld a, (hl) 
09d2 12					ld (de), a 
09d3 fe 00				cp 0 
09d5 28 04				jr z, .appdone 
09d7 23					inc hl 
09d8 13					inc de 
09d9 10 f6				djnz .appd 
09db			 
09db e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09dc f5					push af   		; save last byte dumped 
09dd			 
09dd			 
09dd 2a 43 f8			ld hl, (store_tmppageid) 
09e0 11 59 f8			ld de, store_page 
09e3				if DEBUG_STORESE 
09e3					DMARK "AP6" 
09e3 f5				push af  
09e4 3a f8 09			ld a, (.dmark)  
09e7 32 6e fb			ld (debug_mark),a  
09ea 3a f9 09			ld a, (.dmark+1)  
09ed 32 6f fb			ld (debug_mark+1),a  
09f0 3a fa 09			ld a, (.dmark+2)  
09f3 32 70 fb			ld (debug_mark+2),a  
09f6 18 03			jr .pastdmark  
09f8 ..			.dmark: db "AP6"  
09fb f1			.pastdmark: pop af  
09fc			endm  
# End of macro DMARK
09fc					CALLMONITOR 
09fc cd ab 16			call break_point_state  
09ff				endm  
# End of macro CALLMONITOR
09ff				endif 
09ff cd 47 03				call storage_write_block 
0a02			 
0a02			 
0a02				; was that a full block of data written? 
0a02				; any more to write out? 
0a02			 
0a02				; if yes then set vars and jump to start of function again 
0a02			 
0a02 f1					pop af 
0a03 d1					pop de 
0a04			 
0a04 fe 00				cp 0		 ; no, string was fully written 
0a06 c8					ret z 
0a07			 
0a07					; setup vars for next cycle 
0a07			 
0a07 3a 52 f8				ld a, (store_tmpid) 
0a0a 6f					ld l, a 
0a0b 26 00				ld h, 0 
0a0d			 
0a0d c3 c4 08			 	jp storage_append	 ; yes, need to write out some more 
0a10			 
0a10			 
0a10			 
0a10			 
0a10			 
0a10			 
0a10			 
0a10			if DEBUG_STORECF 
0a10			storageput:	 
0a10					ret 
0a10			storageread: 
0a10					ld hl, store_page 
0a10					ld b, 200 
0a10					ld a,0 
0a10			.src:		ld (hl),a 
0a10					inc hl 
0a10					djnz .src 
0a10					 
0a10			 
0a10					ld de, 0 
0a10					ld bc, 1 
0a10					ld hl, store_page 
0a10					call cfRead 
0a10			 
0a10				call cfGetError 
0a10				ld hl,scratch 
0a10				call hexout 
0a10				ld hl, scratch+2 
0a10				ld a, 0 
0a10				ld (hl),a 
0a10				ld de, scratch 
0a10				ld a,display_row_1 
0a10				call str_at_display 
0a10				call update_display 
0a10			 
0a10					ld hl, store_page 
0a10					ld (os_cur_ptr),hl 
0a10			 
0a10					ret 
0a10			endif 
0a10			 
0a10			 
0a10			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a10			 
0a10			storage_clear_page: 
0a10 e5				push hl 
0a11 d5				push de 
0a12 c5				push bc 
0a13 21 59 f8			ld hl, store_page 
0a16 3e 00			ld a, 0 
0a18 77				ld (hl), a 
0a19			 
0a19 11 5a f8			ld de, store_page+1 
0a1c 01 40 00			ld bc, STORE_BLOCK_PHY 
0a1f			 
0a1f ed b0			ldir 
0a21				 
0a21 c1				pop bc 
0a22 d1				pop de 
0a23 e1				pop hl 
0a24 c9				ret 
0a25			 
0a25			; eof 
# End of file firmware_storage.asm
0a25			  
0a25			; support routines for above hardware abstraction layer  
0a25			  
0a25			include "firmware_general.asm"        ; general support functions  
0a25			 
0a25			; word look up 
0a25			 
0a25			; in 
0a25			; a is the index 
0a25			; hl is pointer start of array 
0a25			; 
0a25			; returns 
0a25			; hl to the word 
0a25			; 
0a25			 
0a25			table_lookup:  
0a25 d5					push de 
0a26 eb					ex de, hl 
0a27			 
0a27 6f					ld l, a 
0a28 26 00				ld h, 0 
0a2a 29					add hl, hl 
0a2b 19					add hl, de 
0a2c 7e					ld a, (hl) 
0a2d 23					inc hl 
0a2e 66					ld h,(hl) 
0a2f 6f					ld l, a 
0a30			 
0a30 d1					pop de 
0a31 c9					ret 
0a32			 
0a32			; Delay loops 
0a32			 
0a32			 
0a32			 
0a32			aDelayInMS: 
0a32 c5				push bc 
0a33 47				ld b,a 
0a34			msdelay: 
0a34 c5				push bc 
0a35				 
0a35			 
0a35 01 41 00			ld bc,041h 
0a38 cd 50 0a			call delayloop 
0a3b c1				pop bc 
0a3c 05				dec b 
0a3d 20 f5			jr nz,msdelay 
0a3f			 
0a3f			;if CPU_CLOCK_8MHZ 
0a3f			;msdelay8: 
0a3f			;	push bc 
0a3f			;	 
0a3f			; 
0a3f			;	ld bc,041h 
0a3f			;	call delayloop 
0a3f			;	pop bc 
0a3f			;	dec b 
0a3f			;	jr nz,msdelay8 
0a3f			;endif 
0a3f			 
0a3f			 
0a3f c1				pop bc 
0a40 c9				ret 
0a41			 
0a41			 
0a41			delay250ms: 
0a41				;push de 
0a41 01 00 40			ld bc, 04000h 
0a44 c3 50 0a			jp delayloop 
0a47			delay500ms: 
0a47				;push de 
0a47 01 00 80			ld bc, 08000h 
0a4a c3 50 0a			jp delayloop 
0a4d			delay1s: 
0a4d				;push bc 
0a4d			   ; Clobbers A, d and e 
0a4d 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a50			delayloop: 
0a50 c5			    push bc 
0a51			 
0a51			if BASE_CPM 
0a51				ld bc, CPM_DELAY_TUNE 
0a51			.cpmloop: 
0a51				push bc 
0a51			 
0a51			endif 
0a51			 
0a51			 
0a51			 
0a51			delayloopi: 
0a51			;	push bc 
0a51			;.dl: 
0a51 cb 47		    bit     0,a    	; 8 
0a53 cb 47		    bit     0,a    	; 8 
0a55 cb 47		    bit     0,a    	; 8 
0a57 e6 ff		    and     255  	; 7 
0a59 0b			    dec     bc      	; 6 
0a5a 79			    ld      a,c     	; 4 
0a5b b0			    or      b     	; 4 
0a5c c2 51 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a5f			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a5f				;pop de 
0a5f			;pop bc 
0a5f			 
0a5f			if BASE_CPM 
0a5f				pop bc 
0a5f				 
0a5f			    dec     bc      	; 6 
0a5f			    ld      a,c     	; 4 
0a5f			    or      b     	; 4 
0a5f			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a5f				 
0a5f			 
0a5f			endif 
0a5f			;if CPU_CLOCK_8MHZ 
0a5f			;    pop bc 
0a5f			;    push bc 
0a5f			;.dl8: 
0a5f			;    bit     0,a    	; 8 
0a5f			;    bit     0,a    	; 8 
0a5f			;    bit     0,a    	; 8 
0a5f			;    and     255  	; 7 
0a5f			;    dec     bc      	; 6 
0a5f			;    ld      a,c     	; 4 
0a5f			;    or      b     	; 4 
0a5f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a5f			;endif 
0a5f			 
0a5f			;if CPU_CLOCK_10MHZ 
0a5f			;    pop bc 
0a5f			;    push bc 
0a5f			;.dl8: 
0a5f			;    bit     0,a    	; 8 
0a5f			;    bit     0,a    	; 8 
0a5f			;    bit     0,a    	; 8 
0a5f			;    and     255  	; 7 
0a5f			;    dec     bc      	; 6 
0a5f			;    ld      a,c     	; 4 
0a5f			;    or      b     	; 4 
0a5f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a5f			;endif 
0a5f c1			    pop bc 
0a60			 
0a60 c9				ret 
0a61			 
0a61			 
0a61			 
0a61			; eof 
# End of file firmware_general.asm
0a61			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a61			; display routines that use the physical hardware abstraction layer 
0a61			 
0a61			 
0a61			; information window 
0a61			 
0a61			; pass hl with 1st string to display 
0a61			; pass de with 2nd string to display 
0a61			 
0a61			info_panel: 
0a61 e5				push hl 
0a62			 
0a62 2a cf f8			ld hl, (display_fb_active) 
0a65 e5				push hl    ; future de destination 
0a66 21 b4 fa				ld hl, display_fb0 
0a69 22 cf f8				ld (display_fb_active), hl 
0a6c			 
0a6c			;	call clear_display 
0a6c			 
0a6c				if BASE_CPM 
0a6c				ld a, '.' 
0a6c				else 
0a6c 3e a5			ld a, 165 
0a6e				endif 
0a6e cd d5 0a			call fill_display 
0a71			 
0a71			 
0a71 3e 55			ld a, display_row_3 + 5 
0a73 cd e3 0a			call str_at_display 
0a76			 
0a76 e1				pop hl 
0a77 d1				pop de 
0a78			 
0a78 e5				push hl 
0a79			 
0a79			 
0a79 3e 2d			ld a, display_row_2 + 5 
0a7b cd e3 0a			call str_at_display 
0a7e			 
0a7e			 
0a7e cd f3 0a			call update_display 
0a81 cd 80 1c			call next_page_prompt 
0a84 cd d0 0a			call clear_display 
0a87			 
0a87				 
0a87 21 13 fa				ld hl, display_fb1 
0a8a 22 cf f8				ld (display_fb_active), hl 
0a8d cd f3 0a			call update_display 
0a90			 
0a90 e1				pop hl 
0a91			 
0a91 c9				ret 
0a92			 
0a92			 
0a92			 
0a92			 
0a92			; TODO windowing? 
0a92			 
0a92			; TODO scroll line up 
0a92			 
0a92			scroll_up: 
0a92			 
0a92 e5				push hl 
0a93 d5				push de 
0a94 c5				push bc 
0a95			 
0a95				; get frame buffer  
0a95			 
0a95 2a cf f8			ld hl, (display_fb_active) 
0a98 e5				push hl    ; future de destination 
0a99			 
0a99 11 28 00			ld  de, display_cols 
0a9c 19				add hl, de 
0a9d			 
0a9d d1				pop de 
0a9e			 
0a9e				;ex de, hl 
0a9e 01 9f 00			ld bc, display_fb_len -1  
0aa1			;if DEBUG_FORTH_WORDS 
0aa1			;	DMARK "SCL" 
0aa1			;	CALLMONITOR 
0aa1			;endif	 
0aa1 ed b0			ldir 
0aa3			 
0aa3				; wipe bottom row 
0aa3			 
0aa3			 
0aa3 2a cf f8			ld hl, (display_fb_active) 
0aa6 11 a0 00			ld de, display_cols*display_rows 
0aa9 19				add hl, de 
0aaa 06 28			ld b, display_cols 
0aac 3e 20			ld a, ' ' 
0aae			.scwipe: 
0aae 77				ld (hl), a 
0aaf 2b				dec hl 
0ab0 10 fc			djnz .scwipe 
0ab2			 
0ab2				;pop hl 
0ab2			 
0ab2 c1				pop bc 
0ab3 d1				pop de 
0ab4 e1				pop hl 
0ab5			 
0ab5 c9				ret 
0ab6			 
0ab6			 
0ab6			;scroll_upo: 
0ab6			;	ld de, display_row_1 
0ab6			 ;	ld hl, display_row_2 
0ab6			;	ld bc, display_cols 
0ab6			;	ldir 
0ab6			;	ld de, display_row_2 
0ab6			 ;	ld hl, display_row_3 
0ab6			;	ld bc, display_cols 
0ab6			;	ldir 
0ab6			;	ld de, display_row_3 
0ab6			 ;	ld hl, display_row_4 
0ab6			;	ld bc, display_cols 
0ab6			;	ldir 
0ab6			 
0ab6			; TODO clear row 4 
0ab6			 
0ab6			;	ret 
0ab6			 
0ab6				 
0ab6			scroll_down: 
0ab6			 
0ab6 e5				push hl 
0ab7 d5				push de 
0ab8 c5				push bc 
0ab9			 
0ab9				; get frame buffer  
0ab9			 
0ab9 2a cf f8			ld hl, (display_fb_active) 
0abc			 
0abc 11 9f 00			ld de, display_fb_len - 1 
0abf 19				add hl, de 
0ac0			 
0ac0 e5			push hl    ; future de destination 
0ac1			 
0ac1 11 28 00			ld  de, display_cols 
0ac4 ed 52			sbc hl, de 
0ac6			 
0ac6			 
0ac6 d1				pop de 
0ac7			 
0ac7			;	ex de, hl 
0ac7 01 9f 00			ld bc, display_fb_len -1  
0aca			 
0aca			 
0aca				 
0aca			 
0aca ed b0			ldir 
0acc			 
0acc				; wipe bottom row 
0acc			 
0acc			 
0acc			;	ld hl, (display_fb_active) 
0acc			;;	ld de, display_cols*display_rows 
0acc			;;	add hl, de 
0acc			;	ld b, display_cols 
0acc			;	ld a, ' ' 
0acc			;.scwiped: 
0acc			;	ld (hl), a 
0acc			;	dec hl 
0acc			;	djnz .scwiped 
0acc			 
0acc				;pop hl 
0acc			 
0acc c1				pop bc 
0acd d1				pop de 
0ace e1				pop hl 
0acf			 
0acf c9				ret 
0ad0			;scroll_down: 
0ad0			;	ld de, display_row_4 
0ad0			;	ld hl, display_row_3 
0ad0			;	ld bc, display_cols 
0ad0			;	ldir 
0ad0			;	ld de, display_row_3 
0ad0			; 	ld hl, display_row_2 
0ad0			;	ld bc, display_cols 
0ad0			;	ldir 
0ad0			;	ld de, display_row_2 
0ad0			;	ld hl, display_row_1 
0ad0			;	ld bc, display_cols 
0ad0			;	ldir 
0ad0			;;; TODO clear row 1 
0ad0			;	ret 
0ad0			 
0ad0			 
0ad0			 
0ad0			 
0ad0			 
0ad0			; clear active frame buffer 
0ad0			 
0ad0			clear_display: 
0ad0 3e 20			ld a, ' ' 
0ad2 c3 d5 0a			jp fill_display 
0ad5			 
0ad5			; fill active frame buffer with a char in A 
0ad5			 
0ad5			fill_display: 
0ad5 06 a0			ld b,display_fb_len 
0ad7 2a cf f8			ld hl, (display_fb_active) 
0ada 77			.fd1:	ld (hl),a 
0adb 23				inc hl 
0adc 10 fc			djnz .fd1 
0ade 23				inc hl 
0adf 3e 00			ld a,0 
0ae1 77				ld (hl),a 
0ae2			 
0ae2			 
0ae2 c9				ret 
0ae3			; Write string (DE) at pos (A) to active frame buffer 
0ae3			 
0ae3 2a cf f8		str_at_display:    ld hl,(display_fb_active) 
0ae6 06 00					ld b,0 
0ae8 4f					ld c,a 
0ae9 09					add hl,bc 
0aea 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0aeb b7			            OR   A              ;Null terminator? 
0aec c8			            RET  Z              ;Yes, so finished 
0aed 77					ld (hl),a 
0aee 23				inc hl 
0aef 13			            INC  DE             ;Point to next character 
0af0 18 f8		            JR   .sad1     ;Repeat 
0af2 c9					ret 
0af3			 
0af3			; using current frame buffer write to physical display 
0af3			 
0af3			update_display: 
0af3 e5				push hl 
0af4 2a cf f8			ld hl, (display_fb_active) 
0af7 cd 1a 66			call write_display 
0afa e1				pop hl 
0afb c9				ret 
0afc			 
0afc			; TODO scrolling 
0afc			 
0afc			 
0afc			; move cursor right one char 
0afc			cursor_right: 
0afc			 
0afc				; TODO shift right 
0afc				; TODO if beyond max col 
0afc				; TODO       cursor_next_line 
0afc			 
0afc c9				ret 
0afd			 
0afd			 
0afd			cursor_next_line: 
0afd				; TODO first char 
0afd				; TODO line down 
0afd				; TODO if past last row 
0afd				; TODO    scroll up 
0afd			 
0afd c9				ret 
0afe			 
0afe			cursor_left: 
0afe				; TODO shift left 
0afe				; TODO if beyond left  
0afe				; TODO     cursor prev line 
0afe				 
0afe c9				ret 
0aff			 
0aff			cursor_prev_line: 
0aff				; TODO last char 
0aff				; TODO line up 
0aff				; TODO if past first row 
0aff				; TODO   scroll down 
0aff			 
0aff c9				ret 
0b00			 
0b00			 
0b00			cout: 
0b00				; A - char 
0b00 c9				ret 
0b01			 
0b01			 
0b01			; Display a menu and allow item selection (optional toggle items) 
0b01			; 
0b01			; format: 
0b01			; hl pointer to word array with zero term for items 
0b01			; e.g.    db item1 
0b01			;         db .... 
0b01			;         db 0 
0b01			; 
0b01			; a = starting menu item  
0b01			; 
0b01			; de = pointer item toggle array   (todo) 
0b01			; 
0b01			; returns item selected in a 1-... 
0b01			; returns 0 if back button pressed 
0b01			; 
0b01			; NOTE: Uses system frame buffer to display 
0b01			; 
0b01			; LEFT, Q = go back 
0b01			; RIGHT, SPACE, CR = select 
0b01			; UP, A - Up 
0b01			; DOWN, Z - Down 
0b01			 
0b01			 
0b01			 
0b01			 
0b01			 
0b01			menu: 
0b01			 
0b01					; keep array pointer 
0b01			 
0b01 22 57 f8				ld (store_tmp1), hl 
0b04 32 55 f8				ld (store_tmp2), a 
0b07			 
0b07					; check for key bounce 
0b07			 
0b07			if BASE_KEV 
0b07			 
0b07 cd 65 69		.mbounce:	call cin 
0b0a fe 00				cp 0 
0b0c 20 f9				jr nz, .mbounce 
0b0e			endif 
0b0e					; for ease use ex 
0b0e			 
0b0e					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b0e 21 b4 fa				ld hl, display_fb0 
0b11 22 cf f8				ld (display_fb_active), hl 
0b14			 
0b14 cd d0 0a		.mloop:		call clear_display 
0b17 cd f3 0a				call update_display 
0b1a			 
0b1a					; draw selection id '>' at 1 
0b1a			 
0b1a					; init start of list display 
0b1a			 
0b1a 3e 05				ld a, 5 
0b1c 32 53 f8				ld (store_tmp3), a   ; display row count 
0b1f 3a 55 f8				ld a,( store_tmp2) 
0b22 32 56 f8				ld (store_tmp2+1), a   ; display item count 
0b25			 
0b25					 
0b25			.mitem:	 
0b25			 
0b25			 
0b25 3a 56 f8				ld a,(store_tmp2+1) 
0b28 6f					ld l, a 
0b29 26 00				ld h, 0 
0b2b 29					add hl, hl 
0b2c ed 5b 57 f8			ld de, (store_tmp1) 
0b30 19					add hl, de 
0b31 7e					ld a, (hl) 
0b32 23					inc hl 
0b33 66					ld h,(hl) 
0b34 6f					ld l, a 
0b35			 
0b35 cd 2d 0d				call ishlzero 
0b38 28 1a				jr z, .mdone 
0b3a			 
0b3a eb					ex de, hl 
0b3b 3a 53 f8				ld a, (store_tmp3) 
0b3e cd e3 0a				call str_at_display 
0b41					 
0b41			 
0b41					; next item 
0b41 3a 56 f8				ld a, (store_tmp2+1) 
0b44 3c					inc a 
0b45 32 56 f8				ld (store_tmp2+1), a   ; display item count 
0b48			 
0b48			 		; next row 
0b48			 
0b48 3a 53 f8				ld a, (store_tmp3) 
0b4b c6 28				add display_cols 
0b4d 32 53 f8				ld (store_tmp3), a 
0b50			 
0b50					; at end of screen? 
0b50			 
0b50 fe 10				cp display_rows*4 
0b52 20 d1				jr nz, .mitem 
0b54			 
0b54			 
0b54			.mdone: 
0b54 cd 2d 0d				call ishlzero 
0b57 28 08				jr z, .nodn 
0b59			 
0b59 3e 78				ld a, display_row_4 
0b5b 11 da 0b				ld de, .mdown 
0b5e cd e3 0a				call str_at_display 
0b61			 
0b61					; draw options to fill the screens with active item on line 1 
0b61					; if current option is 2 or more then display ^ in top 
0b61			 
0b61 3a 55 f8		.nodn:		ld a, (store_tmp2) 
0b64 fe 00				cp 0 
0b66 28 08				jr z, .noup 
0b68			 
0b68 3e 00				ld a, 0 
0b6a 11 d8 0b				ld de, .mup 
0b6d cd e3 0a				call str_at_display 
0b70			 
0b70 3e 02		.noup:		ld a, 2 
0b72 11 d6 0b				ld de, .msel 
0b75 cd e3 0a				call str_at_display 
0b78			 
0b78					; if current option + 1 is not null then display V in bottom 
0b78					; get key 
0b78 cd f3 0a				call update_display 
0b7b			 
0b7b			 
0b7b					; handle key 
0b7b			 
0b7b cd 54 69				call cin_wait 
0b7e			 
0b7e fe 05				cp KEY_UP 
0b80 28 2b				jr z, .mgoup 
0b82 fe 61				cp 'a' 
0b84 28 27				jr z, .mgoup 
0b86 fe 0a				cp KEY_DOWN 
0b88 28 32				jr z, .mgod 
0b8a fe 7a				cp 'z' 
0b8c 28 2e				jr z, .mgod 
0b8e fe 20				cp ' ' 
0b90 28 34				jr z, .goend 
0b92 fe 0c				cp KEY_RIGHT 
0b94 28 30				jr z, .goend 
0b96 fe 0d				cp KEY_CR 
0b98 28 2c				jr z, .goend 
0b9a fe 71				cp 'q' 
0b9c 28 0b				jr z, .goback 
0b9e			 
0b9e fe 0b				cp KEY_LEFT 
0ba0 28 07				jr z, .goback 
0ba2 fe 08				cp KEY_BS 
0ba4 28 03				jr z, .goback 
0ba6 c3 14 0b				jp .mloop 
0ba9			 
0ba9			.goback: 
0ba9 3e 00			ld a, 0 
0bab 18 1d			jr .goend2 
0bad			 
0bad				; move up one 
0bad			.mgoup: 
0bad 3a 55 f8				ld a, (store_tmp2) 
0bb0 fe 00				cp 0 
0bb2 ca 14 0b				jp z, .mloop 
0bb5 3d					dec a 
0bb6 32 55 f8				ld (store_tmp2), a 
0bb9 c3 14 0b				jp .mloop 
0bbc			 
0bbc				; move down one 
0bbc			.mgod: 
0bbc 3a 55 f8				ld a, (store_tmp2) 
0bbf 3c					inc a 
0bc0 32 55 f8				ld (store_tmp2), a 
0bc3 c3 14 0b				jp .mloop 
0bc6			 
0bc6			 
0bc6			.goend: 
0bc6					; get selected item number 
0bc6			 
0bc6 3a 55 f8				ld a, (store_tmp2) 
0bc9 3c					inc a 
0bca			 
0bca			.goend2: 
0bca f5					push af 
0bcb			 
0bcb					; restore active fb 
0bcb					; TODO BUG assumes fb1 
0bcb			 
0bcb 21 13 fa				ld hl, display_fb1 
0bce 22 cf f8				ld (display_fb_active), hl 
0bd1			 
0bd1					; restore main regs 
0bd1			 
0bd1			 
0bd1 cd f3 0a				call update_display 
0bd4			 
0bd4 f1					pop af 
0bd5			 
0bd5 c9				ret 
0bd6			 
0bd6 .. 00		.msel:   db ">",0 
0bd8 .. 00		.mup:   db "^",0 
0bda .. 00		.mdown:   db "v",0 
0bdc			 
0bdc			 
0bdc			; eof 
0bdc			 
# End of file firmware_display.asm
0bdc			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bdc			; random number generators 
0bdc			 
0bdc			 
0bdc			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bdc			 
0bdc			 
0bdc			;-----> Generate a random number 
0bdc			; output a=answer 0<=a<=255 
0bdc			; all registers are preserved except: af 
0bdc			random: 
0bdc e5			        push    hl 
0bdd d5			        push    de 
0bde 2a b1 f8		        ld      hl,(randData) 
0be1 ed 5f		        ld      a,r 
0be3 57			        ld      d,a 
0be4 5e			        ld      e,(hl) 
0be5 19			        add     hl,de 
0be6 85			        add     a,l 
0be7 ac			        xor     h 
0be8 22 b1 f8		        ld      (randData),hl 
0beb d1			        pop     de 
0bec e1			        pop     hl 
0bed c9			        ret 
0bee			 
0bee			 
0bee			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bee			 
0bee			 
0bee			 
0bee			;------LFSR------ 
0bee			;James Montelongo 
0bee			;optimized by Spencer Putt 
0bee			;out: 
0bee			; a = 8 bit random number 
0bee			RandLFSR: 
0bee 21 b7 f8		        ld hl,LFSRSeed+4 
0bf1 5e			        ld e,(hl) 
0bf2 23			        inc hl 
0bf3 56			        ld d,(hl) 
0bf4 23			        inc hl 
0bf5 4e			        ld c,(hl) 
0bf6 23			        inc hl 
0bf7 7e			        ld a,(hl) 
0bf8 47			        ld b,a 
0bf9 cb 13		        rl e  
0bfb cb 12			rl d 
0bfd cb 11		        rl c  
0bff 17				rla 
0c00 cb 13		        rl e  
0c02 cb 12			rl d 
0c04 cb 11		        rl c  
0c06 17				rla 
0c07 cb 13		        rl e  
0c09 cb 12			rl d 
0c0b cb 11		        rl c  
0c0d 17				rla 
0c0e 67			        ld h,a 
0c0f cb 13		        rl e  
0c11 cb 12			rl d 
0c13 cb 11		        rl c  
0c15 17				rla 
0c16 a8			        xor b 
0c17 cb 13		        rl e  
0c19 cb 12			rl d 
0c1b ac			        xor h 
0c1c a9			        xor c 
0c1d aa			        xor d 
0c1e 21 b9 f8		        ld hl,LFSRSeed+6 
0c21 11 ba f8		        ld de,LFSRSeed+7 
0c24 01 07 00		        ld bc,7 
0c27 ed b8		        lddr 
0c29 12			        ld (de),a 
0c2a c9			        ret 
0c2b			 
0c2b			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c2b			 
0c2b			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c2b			 
0c2b			 
0c2b			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c2b			 
0c2b			prng16: 
0c2b			;Inputs: 
0c2b			;   (seed1) contains a 16-bit seed value 
0c2b			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c2b			;Outputs: 
0c2b			;   HL is the result 
0c2b			;   BC is the result of the LCG, so not that great of quality 
0c2b			;   DE is preserved 
0c2b			;Destroys: 
0c2b			;   AF 
0c2b			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c2b			;160cc 
0c2b			;26 bytes 
0c2b 2a ab f8		    ld hl,(seed1) 
0c2e 44			    ld b,h 
0c2f 4d			    ld c,l 
0c30 29			    add hl,hl 
0c31 29			    add hl,hl 
0c32 2c			    inc l 
0c33 09			    add hl,bc 
0c34 22 ab f8		    ld (seed1),hl 
0c37 2a a9 f8		    ld hl,(seed2) 
0c3a 29			    add hl,hl 
0c3b 9f			    sbc a,a 
0c3c e6 2d		    and %00101101 
0c3e ad			    xor l 
0c3f 6f			    ld l,a 
0c40 22 a9 f8		    ld (seed2),hl 
0c43 09			    add hl,bc 
0c44 c9			    ret 
0c45			 
0c45			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c45			 
0c45			rand32: 
0c45			;Inputs: 
0c45			;   (seed1_0) holds the lower 16 bits of the first seed 
0c45			;   (seed1_1) holds the upper 16 bits of the first seed 
0c45			;   (seed2_0) holds the lower 16 bits of the second seed 
0c45			;   (seed2_1) holds the upper 16 bits of the second seed 
0c45			;   **NOTE: seed2 must be non-zero 
0c45			;Outputs: 
0c45			;   HL is the result 
0c45			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c45			;Destroys: 
0c45			;   AF 
0c45			;Tested and passes all CAcert tests 
0c45			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c45			;it has a period of 18,446,744,069,414,584,320 
0c45			;roughly 18.4 quintillion. 
0c45			;LFSR taps: 0,2,6,7  = 11000101 
0c45			;291cc 
0c45			;seed1_0=$+1 
0c45			;    ld hl,12345 
0c45			;seed1_1=$+1 
0c45			;    ld de,6789 
0c45			;    ld b,h 
0c45			;    ld c,l 
0c45			;    add hl,hl \ rl e \ rl d 
0c45			;    add hl,hl \ rl e \ rl d 
0c45			;    inc l 
0c45			;    add hl,bc 
0c45			;    ld (seed1_0),hl 
0c45			;    ld hl,(seed1_1) 
0c45			;    adc hl,de 
0c45			;    ld (seed1_1),hl 
0c45			;    ex de,hl 
0c45			;seed2_0=$+1 
0c45			;    ld hl,9876 
0c45			;seed2_1=$+1 
0c45			;    ld bc,54321 
0c45			;    add hl,hl \ rl c \ rl b 
0c45			;    ld (seed2_1),bc 
0c45			;    sbc a,a 
0c45			;    and %11000101 
0c45			;    xor l 
0c45			;    ld l,a 
0c45			;    ld (seed2_0),hl 
0c45			;    ex de,hl 
0c45			;    add hl,bc 
0c45			;    ret 
0c45			; 
0c45			 
0c45			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c45			; 20 bytes, 86 cycles (excluding ret) 
0c45			 
0c45			; returns   hl = pseudorandom number 
0c45			; corrupts   a 
0c45			 
0c45			; generates 16-bit pseudorandom numbers with a period of 65535 
0c45			; using the xorshift method: 
0c45			 
0c45			; hl ^= hl << 7 
0c45			; hl ^= hl >> 9 
0c45			; hl ^= hl << 8 
0c45			 
0c45			; some alternative shift triplets which also perform well are: 
0c45			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c45			 
0c45			;  org 32768 
0c45			 
0c45			xrnd: 
0c45 2a af f8		  ld hl,(xrandc)       ; seed must not be 0 
0c48 3e 00		  ld a,0 
0c4a bd			  cp l 
0c4b 20 02		  jr nz, .xrnd1 
0c4d 2e 01		  ld l, 1 
0c4f			.xrnd1: 
0c4f			 
0c4f 7c			  ld a,h 
0c50 1f			  rra 
0c51 7d			  ld a,l 
0c52 1f			  rra 
0c53 ac			  xor h 
0c54 67			  ld h,a 
0c55 7d			  ld a,l 
0c56 1f			  rra 
0c57 7c			  ld a,h 
0c58 1f			  rra 
0c59 ad			  xor l 
0c5a 6f			  ld l,a 
0c5b ac			  xor h 
0c5c 67			  ld h,a 
0c5d			 
0c5d 22 af f8		  ld (xrandc),hl 
0c60			 
0c60 c9			  ret 
0c61			;  
0c61			 
0c61			 
0c61			;;;; int maths 
0c61			 
0c61			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c61			; Divide 16-bit values (with 16-bit result) 
0c61			; In: Divide BC by divider DE 
0c61			; Out: BC = result, HL = rest 
0c61			; 
0c61			Div16: 
0c61 21 00 00		    ld hl,0 
0c64 78			    ld a,b 
0c65 06 08		    ld b,8 
0c67			Div16_Loop1: 
0c67 17			    rla 
0c68 ed 6a		    adc hl,hl 
0c6a ed 52		    sbc hl,de 
0c6c 30 01		    jr nc,Div16_NoAdd1 
0c6e 19			    add hl,de 
0c6f			Div16_NoAdd1: 
0c6f 10 f6		    djnz Div16_Loop1 
0c71 17			    rla 
0c72 2f			    cpl 
0c73 47			    ld b,a 
0c74 79			    ld a,c 
0c75 48			    ld c,b 
0c76 06 08		    ld b,8 
0c78			Div16_Loop2: 
0c78 17			    rla 
0c79 ed 6a		    adc hl,hl 
0c7b ed 52		    sbc hl,de 
0c7d 30 01		    jr nc,Div16_NoAdd2 
0c7f 19			    add hl,de 
0c80			Div16_NoAdd2: 
0c80 10 f6		    djnz Div16_Loop2 
0c82 17			    rla 
0c83 2f			    cpl 
0c84 41			    ld b,c 
0c85 4f			    ld c,a 
0c86 c9			ret 
0c87			 
0c87			 
0c87			;http://z80-heaven.wikidot.com/math 
0c87			; 
0c87			;Inputs: 
0c87			;     DE and A are factors 
0c87			;Outputs: 
0c87			;     A is not changed 
0c87			;     B is 0 
0c87			;     C is not changed 
0c87			;     DE is not changed 
0c87			;     HL is the product 
0c87			;Time: 
0c87			;     342+6x 
0c87			; 
0c87			Mult16: 
0c87			 
0c87 06 08		     ld b,8          ;7           7 
0c89 21 00 00		     ld hl,0         ;10         10 
0c8c 29			       add hl,hl     ;11*8       88 
0c8d 07			       rlca          ;4*8        32 
0c8e 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c90 19			         add hl,de   ;--         -- 
0c91 10 f9		       djnz $-5      ;13*7+8     99 
0c93 c9			ret 
0c94			 
0c94			; 
0c94			; Square root of 16-bit value 
0c94			; In:  HL = value 
0c94			; Out:  D = result (rounded down) 
0c94			; 
0c94			;Sqr16: 
0c94			;    ld de,#0040 
0c94			;    ld a,l 
0c94			;    ld l,h 
0c94			;    ld h,d 
0c94			;    or a 
0c94			;    ld b,8 
0c94			;Sqr16_Loop: 
0c94			;    sbc hl,de 
0c94			;    jr nc,Sqr16_Skip 
0c94			;    add hl,de 
0c94			;Sqr16_Skip: 
0c94			;    ccf 
0c94			;    rl d 
0c94			;    add a,a 
0c94			;    adc hl,hl 
0c94			;    add a,a 
0c94			;    adc hl,hl 
0c94			;    djnz Sqr16_Loop 
0c94			;    ret 
0c94			; 
0c94			; 
0c94			; Divide 8-bit values 
0c94			; In: Divide E by divider C 
0c94			; Out: A = result, B = rest 
0c94			; 
0c94			Div8: 
0c94 af			    xor a 
0c95 06 08		    ld b,8 
0c97			Div8_Loop: 
0c97 cb 13		    rl e 
0c99 17			    rla 
0c9a 91			    sub c 
0c9b 30 01		    jr nc,Div8_NoAdd 
0c9d 81			    add a,c 
0c9e			Div8_NoAdd: 
0c9e 10 f7		    djnz Div8_Loop 
0ca0 47			    ld b,a 
0ca1 7b			    ld a,e 
0ca2 17			    rla 
0ca3 2f			    cpl 
0ca4 c9			    ret 
0ca5			 
0ca5			; 
0ca5			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ca5			; In: Multiply A with DE 
0ca5			; Out: HL = result 
0ca5			; 
0ca5			Mult12U: 
0ca5 2e 00		    ld l,0 
0ca7 87			    add a,a 
0ca8 30 01		    jr nc,Mult12U_NoAdd0 
0caa 19			    add hl,de 
0cab			Mult12U_NoAdd0: 
0cab 29			    add hl,hl 
0cac 87			    add a,a 
0cad 30 01		    jr nc,Mult12U_NoAdd1 
0caf 19			    add hl,de 
0cb0			Mult12U_NoAdd1: 
0cb0 29			    add hl,hl 
0cb1 87			    add a,a 
0cb2 30 01		    jr nc,Mult12U_NoAdd2 
0cb4 19			    add hl,de 
0cb5			Mult12U_NoAdd2: 
0cb5 29			    add hl,hl 
0cb6 87			    add a,a 
0cb7 30 01		    jr nc,Mult12U_NoAdd3 
0cb9 19			    add hl,de 
0cba			Mult12U_NoAdd3: 
0cba 29			    add hl,hl 
0cbb 87			    add a,a 
0cbc 30 01		    jr nc,Mult12U_NoAdd4 
0cbe 19			    add hl,de 
0cbf			Mult12U_NoAdd4: 
0cbf 29			    add hl,hl 
0cc0 87			    add a,a 
0cc1 30 01		    jr nc,Mult12U_NoAdd5 
0cc3 19			    add hl,de 
0cc4			Mult12U_NoAdd5: 
0cc4 29			    add hl,hl 
0cc5 87			    add a,a 
0cc6 30 01		    jr nc,Mult12U_NoAdd6 
0cc8 19			    add hl,de 
0cc9			Mult12U_NoAdd6: 
0cc9 29			    add hl,hl 
0cca 87			    add a,a 
0ccb d0			    ret nc 
0ccc 19			    add hl,de 
0ccd c9			    ret 
0cce			 
0cce			; 
0cce			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cce			; In: Multiply A with DE 
0cce			;      Put lowest value in A for most efficient calculation 
0cce			; Out: HL = result 
0cce			; 
0cce			Mult12R: 
0cce 21 00 00		    ld hl,0 
0cd1			Mult12R_Loop: 
0cd1 cb 3f		    srl a 
0cd3 30 01		    jr nc,Mult12R_NoAdd 
0cd5 19			    add hl,de 
0cd6			Mult12R_NoAdd: 
0cd6 cb 23		    sla e 
0cd8 cb 12		    rl d 
0cda b7			    or a 
0cdb c2 d1 0c		    jp nz,Mult12R_Loop 
0cde c9			    ret 
0cdf			 
0cdf			; 
0cdf			; Multiply 16-bit values (with 32-bit result) 
0cdf			; In: Multiply BC with DE 
0cdf			; Out: BCHL = result 
0cdf			; 
0cdf			Mult32: 
0cdf 79			    ld a,c 
0ce0 48			    ld c,b 
0ce1 21 00 00		    ld hl,0 
0ce4 06 10		    ld b,16 
0ce6			Mult32_Loop: 
0ce6 29			    add hl,hl 
0ce7 17			    rla 
0ce8 cb 11		    rl c 
0cea 30 07		    jr nc,Mult32_NoAdd 
0cec 19			    add hl,de 
0ced ce 00		    adc a,0 
0cef d2 f3 0c		    jp nc,Mult32_NoAdd 
0cf2 0c			    inc c 
0cf3			Mult32_NoAdd: 
0cf3 10 f1		    djnz Mult32_Loop 
0cf5 41			    ld b,c 
0cf6 4f			    ld c,a 
0cf7 c9			    ret 
0cf8			 
0cf8			 
0cf8			 
0cf8			; 
0cf8			; Multiply 8-bit values 
0cf8			; In:  Multiply H with E 
0cf8			; Out: HL = result 
0cf8			; 
0cf8			Mult8: 
0cf8 16 00		    ld d,0 
0cfa 6a			    ld l,d 
0cfb 06 08		    ld b,8 
0cfd			Mult8_Loop: 
0cfd 29			    add hl,hl 
0cfe 30 01		    jr nc,Mult8_NoAdd 
0d00 19			    add hl,de 
0d01			Mult8_NoAdd: 
0d01 10 fa		    djnz Mult8_Loop 
0d03 c9			    ret 
0d04			 
0d04			 
0d04			 
0d04			 
0d04			 
0d04			 
0d04			 
0d04			 
0d04			;;http://z80-heaven.wikidot.com/math 
0d04			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d04			; 
0d04			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d04			;     ld a,16        ;7 
0d04			;     ld hl,0        ;10 
0d04			;     jp $+5         ;10 
0d04			;.DivLoop: 
0d04			;       add hl,bc    ;-- 
0d04			;       dec a        ;64 
0d04			;       jr z,.DivLoopEnd        ;86 
0d04			; 
0d04			;       sla e        ;128 
0d04			;       rl d         ;128 
0d04			;       adc hl,hl    ;240 
0d04			;       sbc hl,bc    ;240 
0d04			;       jr nc,.DivLoop ;23|21 
0d04			;       inc e        ;-- 
0d04			;       jp .DivLoop+1 
0d04			; 
0d04			;.DivLoopEnd: 
0d04			 
0d04			;HL_Div_C: 
0d04			;Inputs: 
0d04			;     HL is the numerator 
0d04			;     C is the denominator 
0d04			;Outputs: 
0d04			;     A is the remainder 
0d04			;     B is 0 
0d04			;     C is not changed 
0d04			;     DE is not changed 
0d04			;     HL is the quotient 
0d04			; 
0d04			;       ld b,16 
0d04			;       xor a 
0d04			;         add hl,hl 
0d04			;         rla 
0d04			;         cp c 
0d04			;         jr c,$+4 
0d04			;           inc l 
0d04			;           sub c 
0d04			;         djnz $-7 
0d04			 
0d04			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d04			 
0d04			addatohl: 
0d04 85			    add   a, l    ; A = A+L 
0d05 6f			    ld    l, a    ; L = A+L 
0d06 8c			    adc   a, h    ; A = A+L+H+carry 
0d07 95			    sub   l       ; A = H+carry 
0d08 67			    ld    h, a    ; H = H+carry 
0d09 c9			ret 
0d0a			 
0d0a			addatode: 
0d0a 83			    add   a, e    ; A = A+L 
0d0b 5f			    ld    e, a    ; L = A+L 
0d0c 8a			    adc   a, d    ; A = A+L+H+carry 
0d0d 93			    sub   e       ; A = H+carry 
0d0e 57			    ld    d, a    ; H = H+carry 
0d0f c9			ret 
0d10			 
0d10			 
0d10			addatobc: 
0d10 81			    add   a, c    ; A = A+L 
0d11 4f			    ld    c, a    ; L = A+L 
0d12 88			    adc   a, b    ; A = A+L+H+carry 
0d13 91			    sub   c       ; A = H+carry 
0d14 47			    ld    b, a    ; H = H+carry 
0d15 c9			ret 
0d16			 
0d16			subafromhl: 
0d16			   ; If A=0 do nothing 
0d16			    ; Otherwise flip A's sign. Since 
0d16			    ; the upper byte becomes -1, also 
0d16			    ; substract 1 from H. 
0d16 ed 44		    neg 
0d18 ca 21 0d		    jp    z, Skip 
0d1b 25			    dec   h 
0d1c			     
0d1c			    ; Now add the low byte as usual 
0d1c			    ; Two's complement takes care of 
0d1c			    ; ensuring the result is correct 
0d1c 85			    add   a, l 
0d1d 6f			    ld    l, a 
0d1e 8c			    adc   a, h 
0d1f 95			    sub   l 
0d20 67			    ld    h, a 
0d21			Skip: 
0d21 c9				ret 
0d22			 
0d22			 
0d22			; compare hl and de 
0d22			; returns:  
0d22			; if hl = de, z=1, s=0, c0=0 
0d22			; if hl > de, z=0, s=0, c=0 
0d22			; if hl < de, z=0, s=1, c=1 
0d22			cmp16:	 
0d22 b7				or a 
0d23 ed 52			sbc hl,de 
0d25 e0				ret po 
0d26 7c				ld a,h 
0d27 1f				rra 
0d28 ee 40			xor 01000000B 
0d2a 37				scf 
0d2b 8f				adc a,a 
0d2c c9				ret 
0d2d			 
0d2d			 
0d2d			; test if hl contains zero   - A is destroyed 
0d2d			 
0d2d			ishlzero:    
0d2d b7				or a     ; reset flags 
0d2e 7c				ld a, h 
0d2f b5				or l        	 
0d30			 
0d30 c9				ret 
0d31			 
0d31			 
0d31			 
0d31			 
0d31			if FORTH_ENABLE_FLOATMATH 
0d31			;include "float/bbcmath.z80" 
0d31			include "float/lpfpcalc.asm" 
0d31			endif 
0d31			 
0d31			 
0d31			; eof 
0d31			 
# End of file firmware_maths.asm
0d31			include "firmware_strings.asm"   ; string handling  
0d31			 
0d31			 
0d31			; TODO string len 
0d31			; input text string, end on cr with zero term 
0d31			; a offset into frame buffer to start prompt 
0d31			; d is max length 
0d31			; e is display size TODO 
0d31			; c is current cursor position 
0d31			; hl is ptr to where string will be stored 
0d31			 
0d31			 
0d31			; TODO check limit of buffer for new inserts 
0d31			; TODO check insert does not push beyond buffer 
0d31			; TODO scroll in a limited display area 
0d31			; TODO scroll whole screen on page wrap 
0d31			 
0d31			 
0d31			; TODO handle KEY_PREVWORD 
0d31			; TODO handle KEY_NEXTWORD 
0d31			; TODO handle KEY_HOME 
0d31			; TODO handle KEY_END 
0d31			; TODO use LCD cursor? 
0d31			 
0d31 32 67 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d34 81					add c 
0d35 32 65 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d38 22 6a fb				ld (input_start), hl     ; save ptr to buffer 
0d3b 79					ld a, c 
0d3c cd 04 0d				call addatohl 
0d3f 22 6c fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d42 7a					ld a,d 
0d43 32 69 fb			        ld (input_size), a       ; save length of input area 
0d46 79					ld a, c 
0d47 32 58 fb				ld (input_cursor),a      ; init cursor start position  
0d4a 7b					ld a,e 
0d4b 32 68 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d4e					 
0d4e					 
0d4e			 
0d4e			;		ld a,(input_ptr) 
0d4e			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d4e			 
0d4e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d4e					; init cursor shape if not set by the cin routines 
0d4e 21 c7 f8				ld hl, cursor_shape 
0d51 3e ff				ld a, 255 
0d53 77					ld (hl), a 
0d54 23					inc hl 
0d55 3e 00				ld a, 0 
0d57 77					ld (hl), a 
0d58			 
0d58 3e 0f				ld a, CUR_BLINK_RATE 
0d5a 32 63 fb				ld (input_cur_flash), a 
0d5d 3e 01				ld a, 1 
0d5f 32 62 fb				ld (input_cur_onoff),a 
0d62			 
0d62			;	if DEBUG_INPUT 
0d62			;		push af 
0d62			;		ld a, 'I' 
0d62			;		ld (debug_mark),a 
0d62			;		pop af 
0d62			;		CALLMONITOR 
0d62			;	endif 
0d62			.is1:		; main entry loop 
0d62			 
0d62			 
0d62			 
0d62					; pause 1ms 
0d62			 
0d62 3e 01				ld a, 1 
0d64 cd 32 0a				call aDelayInMS 
0d67			 
0d67					; dec flash counter 
0d67 3a 63 fb				ld a, (input_cur_flash) 
0d6a 3d					dec a 
0d6b 32 63 fb				ld (input_cur_flash), a 
0d6e fe 00				cp 0 
0d70 20 0d				jr nz, .nochgstate 
0d72			 
0d72			 
0d72					; change state 
0d72 3a 62 fb				ld a,(input_cur_onoff) 
0d75 ed 44				neg 
0d77 32 62 fb				ld (input_cur_onoff),a 
0d7a			 
0d7a			 
0d7a					; reset on change of state 
0d7a 3e 0f				ld a, CUR_BLINK_RATE 
0d7c 32 63 fb				ld (input_cur_flash), a 
0d7f			 
0d7f			.nochgstate: 
0d7f					 
0d7f					 
0d7f			 
0d7f					; display cursor  
0d7f			 
0d7f			;		ld hl, (input_start) 
0d7f			;		ld a, (input_cursor) 
0d7f			;		call addatohl 
0d7f			 
0d7f					; get char under cursor and replace with cursor 
0d7f 2a 6c fb		ld hl, (input_ptr) 
0d82			;		ld a, (hl) 
0d82			;		ld (input_under_cursor),a 
0d82			;		ld a, '_' 
0d82			;		ld (hl), a 
0d82			 
0d82					; display string 
0d82			 
0d82 ed 5b 6a fb			ld de, (input_start) 
0d86 3a 67 fb				ld a, (input_at_pos) 
0d89 cd e3 0a				call str_at_display 
0d8c			;	        call update_display 
0d8c			 
0d8c					; find place to put the cursor 
0d8c			;		add h 
0d8c			;		ld l, display_row_1 
0d8c			;		sub l 
0d8c			; (input_at_pos) 
0d8c					;ld c, a 
0d8c			;		ld a, (input_cursor) 
0d8c			;		ld l, (input_at_pos) 
0d8c			;		;ld b, h 
0d8c			;		add l 
0d8c			;		ld (input_at_cursor),a 
0d8c					;ld l,h 
0d8c			 
0d8c			;		ld h, 0 
0d8c			;		ld l,(input_at_pos) 
0d8c			;		ld a, (input_cursor) 
0d8c			;		call addatohl 
0d8c			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d8c			;		call subafromhl 
0d8c			;		ld a,l 
0d8c			;		ld (input_at_cursor), a 
0d8c			 
0d8c				if DEBUG_INPUT 
0d8c					ld a, (hardware_diag) 
0d8c					cp 0 
0d8c					jr z, .skip_input_diag 
0d8c			 
0d8c					ld a,(input_at_pos) 
0d8c					ld hl, LFSRSeed 
0d8c					call hexout 
0d8c					ld a, (input_cursor) 
0d8c					ld hl, LFSRSeed+2 
0d8c					call hexout 
0d8c					ld a,(input_at_cursor) 
0d8c					ld hl, LFSRSeed+4 
0d8c					call hexout 
0d8c			 
0d8c					ld a,(input_cur_onoff) 
0d8c					ld hl, LFSRSeed+6 
0d8c					call hexout 
0d8c			 
0d8c					ld a,(input_cur_flash) 
0d8c					ld hl, LFSRSeed+8 
0d8c					call hexout 
0d8c			 
0d8c					ld a,(input_len) 
0d8c					ld hl, LFSRSeed+10 
0d8c					call hexout 
0d8c					ld hl, LFSRSeed+12 
0d8c					ld a, 0 
0d8c					ld (hl),a 
0d8c					ld a, display_row_4 
0d8c					ld de, LFSRSeed 
0d8c					call str_at_display 
0d8c					.skip_input_diag: 
0d8c				endif 
0d8c			 
0d8c					; decide on if we are showing the cursor this time round 
0d8c			 
0d8c 3a 62 fb				ld a, (input_cur_onoff) 
0d8f fe ff				cp 255 
0d91 28 13				jr z, .skipcur 
0d93			 
0d93			 
0d93 3a 65 fb				ld a,(input_at_cursor) 
0d96 11 c7 f8				ld de, cursor_shape 
0d99 cd e3 0a				call str_at_display 
0d9c			 
0d9c					; save length of current input string 
0d9c 2a 6a fb				ld hl, (input_start) 
0d9f cd 62 11				call strlenz 
0da2 7d					ld a,l 
0da3 32 5d fb				ld (input_len),a 
0da6			 
0da6			.skipcur: 
0da6			 
0da6 cd f3 0a			        call update_display 
0da9					 
0da9			 
0da9			 
0da9					; wait 
0da9				 
0da9					; TODO loop without wait to flash the cursor and char under cursor	 
0da9 cd 65 69				call cin    ; _wait 
0dac			 
0dac fe 00				cp 0 
0dae ca 62 0d				jp z, .is1 
0db1			 
0db1					; get ptr to char to input into 
0db1			 
0db1 4f					ld c,a 
0db2 2a 6a fb				ld hl, (input_start) 
0db5 3a 58 fb				ld a, (input_cursor) 
0db8 cd 04 0d				call addatohl 
0dbb 22 6c fb				ld (input_ptr), hl 
0dbe 79					ld a,c 
0dbf			 
0dbf					; replace char under cursor 
0dbf			 
0dbf			;		ld hl, (input_ptr) 
0dbf			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dbf			;		ld (hl), a 
0dbf			 
0dbf			;	if DEBUG_INPUT 
0dbf			;		push af 
0dbf			;		ld a, 'i' 
0dbf			;		ld (debug_mark),a 
0dbf			;		pop af 
0dbf			;		CALLMONITOR 
0dbf			;	endif 
0dbf fe 0e				cp KEY_HOME 
0dc1 20 0e				jr nz, .iske 
0dc3			 
0dc3 3a 67 fb				ld a, (input_at_pos) 
0dc6 32 65 fb				ld (input_at_cursor),a 
0dc9 3e 00				ld a, 0 
0dcb 32 58 fb				ld (input_cursor), a 
0dce c3 62 0d				jp .is1 
0dd1					 
0dd1 fe 0f		.iske:		cp KEY_END 
0dd3 20 03				jr nz, .isknw 
0dd5 c3 62 0d				jp .is1 
0dd8			 
0dd8 fe 06		.isknw:		cp KEY_NEXTWORD 
0dda 20 1b				jr nz, .iskpw 
0ddc			 
0ddc 2a 6c fb		.isknwm:	ld hl, (input_ptr) 
0ddf 7e					ld a,(hl)	 
0de0 fe 00				cp 0 
0de2 ca 62 0d				jp z, .is1    ; end of string 
0de5 fe 20				cp ' ' 
0de7 ca 62 0d				jp z, .is1    ; end of word 
0dea 23					inc hl 
0deb 22 6c fb				ld (input_ptr), hl 
0dee 3a 65 fb				ld a, (input_at_cursor) 
0df1 3c					inc a 
0df2 32 65 fb				ld (input_at_cursor), a 
0df5 18 e5				jr .isknwm 
0df7			 
0df7 fe 07		.iskpw:		cp KEY_PREVWORD 
0df9 20 1b				jr nz, .iskl 
0dfb			.iskpwm:	 
0dfb 2a 6c fb				ld hl, (input_ptr) 
0dfe 7e					ld a,(hl)	 
0dff fe 00				cp 0  
0e01 ca 62 0d				jp z, .is1    ; end of string 
0e04 fe 20				cp ' ' 
0e06 ca 62 0d				jp z, .is1    ; end of word 
0e09 2b					dec hl 
0e0a 22 6c fb				ld (input_ptr), hl 
0e0d 3a 65 fb				ld a, (input_at_cursor) 
0e10 3d					dec a 
0e11 32 65 fb				ld (input_at_cursor), a 
0e14 18 e5				jr .iskpwm 
0e16			 
0e16			 
0e16 fe 0b		.iskl:		cp KEY_LEFT 
0e18 20 27				jr nz, .isk1 
0e1a			 
0e1a 3a 58 fb				ld a, (input_cursor) 
0e1d			 
0e1d fe 00				cp 0 
0e1f ca 62 0d				jp z, .is1 		; at start of line to ignore  
0e22			 
0e22 3d					dec  a 		; TODO check underflow 
0e23 32 58 fb				ld (input_cursor), a 
0e26			 
0e26 2a 6c fb				ld hl, (input_ptr) 
0e29 2b					dec hl 
0e2a 22 6c fb				ld (input_ptr), hl 
0e2d					 
0e2d 3a 65 fb				ld a, (input_at_cursor) 
0e30 3d					dec a 
0e31 32 65 fb				ld (input_at_cursor), a 
0e34			 
0e34 3e 01				ld a, 1		; show cursor moving 
0e36 32 62 fb				ld (input_cur_onoff),a 
0e39 3e 0f				ld a, CUR_BLINK_RATE 
0e3b 32 63 fb				ld (input_cur_flash), a 
0e3e			 
0e3e c3 62 0d				jp .is1 
0e41			 
0e41 fe 0c		.isk1:		cp KEY_RIGHT 
0e43 20 2a				jr nz, .isk2 
0e45			 
0e45 3a 5d fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e48 5f					ld e,a 
0e49 3a 58 fb				ld a, (input_cursor) 
0e4c bb					cp e 
0e4d ca 62 0d				jp z, .is1		; at the end of string so dont go right 
0e50			 
0e50 3c					inc  a 		; TODO check overflow 
0e51 32 58 fb				ld (input_cursor), a 
0e54			 
0e54 3a 65 fb				ld a, (input_at_cursor) 
0e57 3c					inc a 
0e58 32 65 fb				ld (input_at_cursor), a 
0e5b			 
0e5b 2a 6c fb				ld hl, (input_ptr) 
0e5e 23					inc hl 
0e5f 22 6c fb				ld (input_ptr), hl 
0e62			 
0e62 3e 01				ld a, 1		; show cursor moving 
0e64 32 62 fb				ld (input_cur_onoff),a 
0e67 3e 0f				ld a, CUR_BLINK_RATE 
0e69 32 63 fb				ld (input_cur_flash), a 
0e6c			 
0e6c c3 62 0d				jp .is1 
0e6f			 
0e6f fe 05		.isk2:		cp KEY_UP 
0e71			 
0e71 20 26				jr nz, .isk3 
0e73			 
0e73					; swap last command with the current on 
0e73			 
0e73					; move cursor to start of string 
0e73 2a 6a fb				ld hl, (input_start) 
0e76 22 6c fb				ld (input_ptr), hl 
0e79			 
0e79 3a 67 fb				ld a, (input_at_pos) 
0e7c 32 65 fb				ld (input_at_cursor), a 
0e7f			 
0e7f 3e 00				ld a, 0 
0e81 32 58 fb				ld (input_cursor), a 
0e84					 
0e84					; swap input and last command buffers 
0e84			 
0e84 21 3b f1				ld hl, os_cli_cmd 
0e87 11 3a f2				ld de, os_last_cmd 
0e8a 06 ff				ld b, 255 
0e8c 7e			.swap1:		ld a, (hl) 
0e8d 4f					ld c,a 
0e8e 1a					ld a, (de) 
0e8f 77					ld (hl), a 
0e90 79					ld a,c 
0e91 12					ld (de),a 
0e92 23					inc hl 
0e93 13					inc de 
0e94 10 f6				djnz .swap1 
0e96			 
0e96			 
0e96			 
0e96			 
0e96			 
0e96 c3 62 0d				jp .is1 
0e99			 
0e99 fe 08		.isk3:		cp KEY_BS 
0e9b 20 3c				jr nz, .isk4 
0e9d			 
0e9d 3a 58 fb				ld a, (input_cursor) 
0ea0			 
0ea0 fe 00				cp 0 
0ea2 ca 62 0d				jp z, .is1 		; at start of line to ignore  
0ea5			 
0ea5 3d					dec  a 		; TODO check underflow 
0ea6 32 58 fb				ld (input_cursor), a 
0ea9			 
0ea9					; hl is source 
0ea9					; de needs to be source - 1 
0ea9			 
0ea9			;		ld a, 0 
0ea9			;		dec hl 
0ea9			;		ld (hl), a 
0ea9			 
0ea9 2a 6c fb				ld hl, (input_ptr) 
0eac 2b					dec hl 
0ead 22 6c fb				ld (input_ptr), hl 
0eb0			 
0eb0					; shift all data 
0eb0			 
0eb0 e5					push hl 
0eb1 23					inc hl 
0eb2 d1					pop de 
0eb3 3a 5d fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0eb6 4f					ld c,a 
0eb7 06 00				ld b,0 
0eb9 ed b0				ldir  
0ebb			 
0ebb			 
0ebb			 
0ebb			 
0ebb 3a 65 fb				ld a, (input_at_cursor) 
0ebe 3d					dec a 
0ebf 32 65 fb				ld (input_at_cursor), a 
0ec2			 
0ec2			 
0ec2 3e 01				ld a, 1		; show cursor moving 
0ec4 32 62 fb				ld (input_cur_onoff),a 
0ec7 3e 0f				ld a, CUR_BLINK_RATE 
0ec9 32 63 fb				ld (input_cur_flash), a 
0ecc			 
0ecc					; remove char 
0ecc 3a 65 fb				ld a, (input_at_cursor) 
0ecf 3c					inc a 
0ed0 11 5a 0f				ld de,.iblank 
0ed3 cd e3 0a				call str_at_display 
0ed6			 
0ed6 c3 62 0d				jp .is1 
0ed9			 
0ed9 fe 0d		.isk4:		cp KEY_CR 
0edb 28 6c				jr z, .endinput 
0edd			 
0edd					; else add the key press to the end 
0edd			 
0edd 4f					ld c, a			; save key pressed 
0ede			 
0ede 7e					ld a,(hl)		; get what is currently under char 
0edf			 
0edf fe 00				cp 0			; we are at the end of the string 
0ee1 20 2f				jr nz, .onchar 
0ee3					 
0ee3					; add a char to the end of the string 
0ee3				 
0ee3 71					ld (hl),c 
0ee4 23					inc hl 
0ee5			;		ld a,' ' 
0ee5			;		ld (hl),a 
0ee5			;		inc hl 
0ee5 3e 00				ld a,0 
0ee7 77					ld (hl),a 
0ee8 2b					dec hl 
0ee9			 
0ee9 3a 58 fb				ld a, (input_cursor) 
0eec 3c					inc a				; TODO check max string length and scroll  
0eed 32 58 fb				ld (input_cursor), a		; inc cursor pos 
0ef0							 
0ef0 3a 65 fb				ld a, (input_at_cursor) 
0ef3 3c					inc a 
0ef4 32 65 fb				ld (input_at_cursor), a 
0ef7			 
0ef7 2a 6c fb				ld hl, (input_ptr) 
0efa 23					inc hl 
0efb 22 6c fb				ld (input_ptr), hl 
0efe			 
0efe 2a 6c fb				ld hl, (input_ptr) 
0f01 23					inc hl 
0f02 22 6c fb				ld (input_ptr), hl 
0f05			;	if DEBUG_INPUT 
0f05			;		push af 
0f05			;		ld a, '+' 
0f05			;		ld (debug_mark),a 
0f05			;		pop af 
0f05			;		CALLMONITOR 
0f05			;	endif 
0f05 3e 01				ld a, 1		; show cursor moving 
0f07 32 62 fb				ld (input_cur_onoff),a 
0f0a 3e 0f				ld a, CUR_BLINK_RATE 
0f0c 32 63 fb				ld (input_cur_flash), a 
0f0f c3 62 0d				jp .is1 
0f12					 
0f12			 
0f12			 
0f12					; if on a char then insert 
0f12			.onchar: 
0f12			 
0f12					; TODO over flow check: make sure insert does not blow out buffer 
0f12			 
0f12					; need to do some maths to use lddr 
0f12			 
0f12 e5					push hl   ; save char pos 
0f13 c5					push bc 
0f14			 
0f14 2a 6a fb				ld hl, (input_start) 
0f17 3a 5d fb				ld a, (input_len) 
0f1a cd 04 0d				call addatohl  		; end of string 
0f1d 23					inc hl 
0f1e 23					inc hl		; past zero term 
0f1f e5					push hl 
0f20 23					inc hl 
0f21 e5					push hl  
0f22			 
0f22								; start and end of lddr set, now how much to move? 
0f22			 
0f22							 
0f22 3a 58 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f25 47					ld b,a 
0f26 3a 5d fb				ld a,(input_len) 
0f29 5f					ld e,a 
0f2a 90					sub b 
0f2b 3c					inc a		;?? 
0f2c 3c					inc a		;?? 
0f2d 3c					inc a		;?? 
0f2e			 
0f2e 06 00				ld b,0 
0f30 4f					ld c,a 
0f31			 
0f31				if DEBUG_INPUT 
0f31					push af 
0f31					ld a, 'i' 
0f31					ld (debug_mark),a 
0f31					pop af 
0f31			;		CALLMONITOR 
0f31				endif 
0f31 d1					pop de 
0f32 e1					pop hl 
0f33				if DEBUG_INPUT 
0f33					push af 
0f33					ld a, 'I' 
0f33					ld (debug_mark),a 
0f33					pop af 
0f33			;		CALLMONITOR 
0f33				endif 
0f33 ed b8				lddr 
0f35				 
0f35			 
0f35			 
0f35					; TODO have a key for insert/overwrite mode???? 
0f35 c1					pop bc 
0f36 e1					pop hl 
0f37 71					ld (hl), c		; otherwise overwrite current char 
0f38					 
0f38			 
0f38			 
0f38			 
0f38 3a 58 fb				ld a, (input_cursor) 
0f3b 3c					inc  a 		; TODO check overflow 
0f3c 32 58 fb				ld (input_cursor), a 
0f3f			 
0f3f 3a 65 fb				ld a, (input_at_cursor) 
0f42 3c					inc a 
0f43 32 65 fb				ld (input_at_cursor), a 
0f46			 
0f46 c3 62 0d				jp .is1 
0f49			 
0f49			.endinput:	; TODO look for end of string 
0f49			 
0f49					; add trailing space for end of token 
0f49			 
0f49 2a 6a fb				ld hl, (input_start) 
0f4c 3a 5d fb				ld a,(input_len) 
0f4f cd 04 0d				call addatohl 
0f52 3e 20				ld a, ' ' 
0f54 77					ld (hl),a 
0f55					; TODO eof of parse marker 
0f55			 
0f55 23					inc hl 
0f56 3e 00				ld a, 0 
0f58 77					ld (hl),a 
0f59			 
0f59			 
0f59 c9					ret 
0f5a			 
0f5a .. 00		.iblank: db " ",0 
0f5c			 
0f5c			 
0f5c 32 67 fb		input_str_prev:	ld (input_at_pos), a 
0f5f 22 6a fb				ld (input_start), hl 
0f62 3e 01				ld a,1			; add cursor 
0f64 77					ld (hl),a 
0f65 23					inc hl 
0f66 3e 00				ld a,0 
0f68 77					ld (hl),a 
0f69 22 6c fb				ld (input_ptr), hl 
0f6c 7a					ld a,d 
0f6d 32 69 fb				ld (input_size), a 
0f70 3e 00				ld a,0 
0f72 32 58 fb				ld (input_cursor),a 
0f75			.instr1:	 
0f75			 
0f75					; TODO do block cursor 
0f75					; TODO switch cursor depending on the modifer key 
0f75			 
0f75					; update cursor shape change on key hold 
0f75			 
0f75 2a 6c fb				ld hl, (input_ptr) 
0f78 2b					dec hl 
0f79 3a c7 f8				ld a,(cursor_shape) 
0f7c 77					ld (hl), a 
0f7d			 
0f7d					; display entered text 
0f7d 3a 67 fb				ld a,(input_at_pos) 
0f80 cd 29 67		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f83 ed 5b 6a fb	            	LD   de, (input_start) 
0f87 cd 4b 67		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8a			 
0f8a cd 65 69				call cin 
0f8d fe 00				cp 0 
0f8f 28 e4				jr z, .instr1 
0f91			 
0f91					; proecess keyboard controls first 
0f91			 
0f91 2a 6c fb				ld hl,(input_ptr) 
0f94			 
0f94 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f96 28 5a				jr z, .instrcr 
0f98			 
0f98 fe 08				cp KEY_BS 	; back space 
0f9a 20 0f				jr nz, .instr2 
0f9c					; process back space 
0f9c			 
0f9c					; TODO stop back space if at start of string 
0f9c 2b					dec hl 
0f9d 2b					dec hl ; to over write cursor 
0f9e 3a c7 f8				ld a,(cursor_shape) 
0fa1					;ld a,0 
0fa1 77					ld (hl),a 
0fa2 23					inc hl 
0fa3 3e 20				ld a," " 
0fa5 77					ld (hl),a 
0fa6 22 6c fb				ld (input_ptr),hl 
0fa9					 
0fa9			 
0fa9 18 ca				jr .instr1 
0fab			 
0fab fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0fad 20 06				jr nz, .instr3 
0faf 2b					dec hl 
0fb0 22 6c fb				ld (input_ptr),hl 
0fb3 18 c0				jr .instr1 
0fb5				 
0fb5 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fb7 20 06				jr nz, .instr4 
0fb9 23					inc hl 
0fba 22 6c fb				ld (input_ptr),hl 
0fbd 18 b6				jr .instr1 
0fbf			 
0fbf fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc1 20 06				jr nz, .instr5 
0fc3 2b					dec hl 
0fc4 22 6c fb				ld (input_ptr),hl 
0fc7 18 ac				jr .instr1 
0fc9			 
0fc9 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fcb 20 06				jr nz, .instr6 
0fcd 2b					dec hl 
0fce 22 6c fb				ld (input_ptr),hl 
0fd1 18 a2				jr .instr1 
0fd3 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fd5 20 0b				jr nz, .instrnew 
0fd7			 
0fd7 21 14 ee			ld hl, scratch 
0fda 11 3a f2			ld de, os_last_cmd 
0fdd cd fb 0f			call strcpy 
0fe0 18 93				jr .instr1 
0fe2			 
0fe2			 
0fe2			.instrnew:	; no special key pressed to see if we have room to store it 
0fe2			 
0fe2					; TODO do string size test 
0fe2			 
0fe2 2b					dec hl ; to over write cursor 
0fe3 77					ld (hl),a 
0fe4 23					inc hl 
0fe5 3a c7 f8				ld a,(cursor_shape) 
0fe8 77					ld (hl),a 
0fe9 23					inc hl 
0fea 3e 00				ld a,0 
0fec 77					ld (hl),a 
0fed			 
0fed 22 6c fb				ld (input_ptr),hl 
0ff0					 
0ff0 18 83				jr .instr1 
0ff2 2b			.instrcr:	dec hl		; remove cursor 
0ff3 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ff5 77					ld (hl),a 
0ff6 23					inc hl 
0ff7 3e 00				ld a,0 
0ff9 77					ld (hl),a 
0ffa			 
0ffa			 
0ffa					; if at end of line scroll up    
0ffa					; TODO detecting only end of line 4 for scroll up  
0ffa			 
0ffa					;ld   
0ffa			 
0ffa c9					ret 
0ffb			 
0ffb			 
0ffb			; strcpy hl = dest, de source 
0ffb			 
0ffb 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ffc b7			            OR   A              ;Null terminator? 
0ffd c8			            RET  Z              ;Yes, so finished 
0ffe 1a					ld a,(de) 
0fff 77					ld (hl),a 
1000 13			            INC  DE             ;Point to next character 
1001 23					inc hl 
1002 18 f7		            JR   strcpy       ;Repeat 
1004 c9					ret 
1005			 
1005			 
1005			; TODO string_at  
1005			; pass string which starts with lcd offset address and then null term string 
1005			 
1005			; TODO string to dec 
1005			; TODO string to hex 
1005			; TODO byte to string hex 
1005			; TODO byte to string dec 
1005			 
1005			 
1005			 
1005			; from z80uartmonitor 
1005			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1005			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1005			; pass hl for where to put the text 
1005			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1005 c5			hexout:	PUSH BC 
1006 f5					PUSH AF 
1007 47					LD B, A 
1008					; Upper nybble 
1008 cb 3f				SRL A 
100a cb 3f				SRL A 
100c cb 3f				SRL A 
100e cb 3f				SRL A 
1010 cd 20 10				CALL tohex 
1013 77					ld (hl),a 
1014 23					inc hl	 
1015					 
1015					; Lower nybble 
1015 78					LD A, B 
1016 e6 0f				AND 0FH 
1018 cd 20 10				CALL tohex 
101b 77					ld (hl),a 
101c 23					inc hl	 
101d					 
101d f1					POP AF 
101e c1					POP BC 
101f c9					RET 
1020					 
1020			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1020			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1020			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1020			tohex: 
1020 e5					PUSH HL 
1021 d5					PUSH DE 
1022 16 00				LD D, 0 
1024 5f					LD E, A 
1025 21 2d 10				LD HL, .DATA 
1028 19					ADD HL, DE 
1029 7e					LD A, (HL) 
102a d1					POP DE 
102b e1					POP HL 
102c c9					RET 
102d			 
102d			.DATA: 
102d 30					DEFB	30h	; 0 
102e 31					DEFB	31h	; 1 
102f 32					DEFB	32h	; 2 
1030 33					DEFB	33h	; 3 
1031 34					DEFB	34h	; 4 
1032 35					DEFB	35h	; 5 
1033 36					DEFB	36h	; 6 
1034 37					DEFB	37h	; 7 
1035 38					DEFB	38h	; 8 
1036 39					DEFB	39h	; 9 
1037 41					DEFB	41h	; A 
1038 42					DEFB	42h	; B 
1039 43					DEFB	43h	; C 
103a 44					DEFB	44h	; D 
103b 45					DEFB	45h	; E 
103c 46					DEFB	46h	; F 
103d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103d			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
103d			;;    subtract $30, if result > 9 then subtract $7 more 
103d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103d			atohex: 
103d d6 30				SUB $30 
103f fe 0a				CP 10 
1041 f8					RET M		; If result negative it was 0-9 so we're done 
1042 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1044 c9					RET		 
1045			 
1045			 
1045			 
1045			 
1045			; Get 2 ASCII characters as hex byte from pointer in hl 
1045			 
1045			BYTERD: 
1045 16 00			LD	D,00h		;Set up 
1047 cd 4f 10			CALL	HEXCON		;Get byte and convert to hex 
104a 87				ADD	A,A		;First nibble so 
104b 87				ADD	A,A		;multiply by 16 
104c 87				ADD	A,A		; 
104d 87				ADD	A,A		; 
104e 57				LD	D,A		;Save hi nibble in D 
104f			HEXCON: 
104f 7e				ld a, (hl)		;Get next chr 
1050 23				inc hl 
1051 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1053 fe 0a			CP	00Ah		;Is it 0-9 ? 
1055 38 02			JR	C,NALPHA	;If so miss next bit 
1057 d6 07			SUB	007h		;Else convert alpha 
1059			NALPHA: 
1059 b2				OR	D		;Add hi nibble back 
105a c9				RET			; 
105b			 
105b			 
105b			; 
105b			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
105b			; Since the routines get_byte and therefore get_nibble are called, only valid 
105b			; characters (0-9a-f) are accepted. 
105b			; 
105b			;get_word        push    af 
105b			;                call    get_byte        ; Get the upper byte 
105b			;                ld      h, a 
105b			;                call    get_byte        ; Get the lower byte 
105b			;                ld      l, a 
105b			;                pop     af 
105b			;                ret 
105b			; 
105b			; Get a byte in hexadecimal notation. The result is returned in A. Since 
105b			; the routine get_nibble is used only valid characters are accepted - the  
105b			; input routine only accepts characters 0-9a-f. 
105b			; 
105b c5			get_byte:        push    bc              ; Save contents of B (and C) 
105c 7e					ld a,(hl) 
105d 23					inc hl 
105e cd 83 10		                call    nibble2val      ; Get upper nibble 
1061 cb 07		                rlc     a 
1063 cb 07		                rlc     a 
1065 cb 07		                rlc     a 
1067 cb 07		                rlc     a 
1069 47			                ld      b, a            ; Save upper four bits 
106a 7e					ld a,(hl) 
106b cd 83 10		                call    nibble2val      ; Get lower nibble 
106e b0			                or      b               ; Combine both nibbles 
106f c1			                pop     bc              ; Restore B (and C) 
1070 c9			                ret 
1071			; 
1071			; Get a hexadecimal digit from the serial line. This routine blocks until 
1071			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1071			; to the serial line interface. The lower 4 bits of A contain the value of  
1071			; that particular digit. 
1071			; 
1071			;get_nibble      ld a,(hl)           ; Read a character 
1071			;                call    to_upper        ; Convert to upper case 
1071			;                call    is_hex          ; Was it a hex digit? 
1071			;                jr      nc, get_nibble  ; No, get another character 
1071			 ;               call    nibble2val      ; Convert nibble to value 
1071			 ;               call    print_nibble 
1071			 ;               ret 
1071			; 
1071			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1071			; A valid hexadecimal digit is denoted by a set C flag. 
1071			; 
1071			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1071			;                ret     nc              ; Yes 
1071			;                cp      '0'             ; Less than '0'? 
1071			;                jr      nc, is_hex_1    ; No, continue 
1071			;                ccf                     ; Complement carry (i.e. clear it) 
1071			;                ret 
1071			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1071			;                ret     c               ; Yes 
1071			;                cp      'A'             ; Less than 'A'? 
1071			;                jr      nc, is_hex_2    ; No, continue 
1071			;                ccf                     ; Yes - clear carry and return 
1071			;                ret 
1071			;is_hex_2        scf                     ; Set carry 
1071			;                ret 
1071			; 
1071			; Convert a single character contained in A to upper case: 
1071			; 
1071 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1073 d8			                ret     c 
1074 fe 7b		                cp      'z' + 1         ; > 'z'? 
1076 d0			                ret     nc              ; Nothing to do, either 
1077 e6 5f		                and     $5f             ; Convert to upper case 
1079 c9			                ret 
107a			 
107a			 
107a			to_lower: 
107a			 
107a			   ; if char is in [A-Z] make it lower case 
107a			 
107a			   ; enter : a = char 
107a			   ; exit  : a = lower case char 
107a			   ; uses  : af 
107a			 
107a fe 41		   cp 'A' 
107c d8			   ret c 
107d			    
107d fe 5b		   cp 'Z'+1 
107f d0			   ret nc 
1080			    
1080 f6 20		   or $20 
1082 c9			   ret 
1083			 
1083			; 
1083			; Expects a hexadecimal digit (upper case!) in A and returns the 
1083			; corresponding value in A. 
1083			; 
1083 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1085 38 02		                jr      c, nibble2val_1 ; Yes 
1087 d6 07		                sub     7               ; Adjust for A-F 
1089 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
108b e6 0f		                and     $f              ; Only return lower 4 bits 
108d c9			                ret 
108e			; 
108e			; Print_nibble prints a single hex nibble which is contained in the lower  
108e			; four bits of A: 
108e			; 
108e			;print_nibble    push    af              ; We won't destroy the contents of A 
108e			;                and     $f              ; Just in case... 
108e			;                add     a, '0'             ; If we have a digit we are done here. 
108e			;                cp      '9' + 1         ; Is the result > 9? 
108e			;                jr      c, print_nibble_1 
108e			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
108e			;print_nibble_1  call    putc            ; Print the nibble and 
108e			;                pop     af              ; restore the original value of A 
108e			;                ret 
108e			;; 
108e			;; Send a CR/LF pair: 
108e			; 
108e			;crlf            push    af 
108e			;                ld      a, cr 
108e			;                call    putc 
108e			;                ld      a, lf 
108e			;                call    putc 
108e			;                pop     af 
108e			;                ret 
108e			; 
108e			; Print_word prints the four hex digits of a word to the serial line. The  
108e			; word is expected to be in HL. 
108e			; 
108e			;print_word      push    hl 
108e			;                push    af 
108e			;                ld      a, h 
108e			;                call    print_byte 
108e			;                ld      a, l 
108e			;                call    print_byte 
108e			;                pop     af 
108e			;                pop     hl 
108e			;                ret 
108e			; 
108e			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
108e			; The byte to be printed is expected to be in A. 
108e			; 
108e			;print_byte      push    af              ; Save the contents of the registers 
108e			;                push    bc 
108e			;                ld      b, a 
108e			;                rrca 
108e			;                rrca 
108e			;                rrca 
108e			;                rrca 
108e			;                call    print_nibble    ; Print high nibble 
108e			;                ld      a, b 
108e			;                call    print_nibble    ; Print low nibble 
108e			;                pop     bc              ; Restore original register contents 
108e			;                pop     af 
108e			;                ret 
108e			 
108e			 
108e			 
108e			 
108e			 
108e			fourehexhl:  
108e 7e				ld a,(hl) 
108f cd 3d 10			call atohex 
1092 cb 3f				SRL A 
1094 cb 3f				SRL A 
1096 cb 3f				SRL A 
1098 cb 3f				SRL A 
109a 47				ld b, a 
109b 23				inc hl 
109c 7e				ld a,(hl) 
109d 23				inc hl 
109e cd 3d 10			call atohex 
10a1 80				add b 
10a2 57				ld d,a 
10a3 7e				ld a,(hl) 
10a4 cd 3d 10			call atohex 
10a7 cb 3f				SRL A 
10a9 cb 3f				SRL A 
10ab cb 3f				SRL A 
10ad cb 3f				SRL A 
10af 47				ld b, a 
10b0 23				inc hl 
10b1 7e				ld a,(hl) 
10b2 23				inc hl 
10b3 cd 3d 10			call atohex 
10b6 80				add b 
10b7 5f				ld e, a 
10b8 d5				push de 
10b9 e1				pop hl 
10ba c9				ret 
10bb			 
10bb			; pass hl. returns z set if the byte at hl is a digit 
10bb			;isdigithl:  
10bb			;	push bc 
10bb			;	ld a,(hl) 
10bb			;	cp ':' 
10bb			;	jr nc, .isdf 		; > 
10bb			;	cp '0' 
10bb			;	jr c, .isdf		; < 
10bb			; 
10bb			;	; TODO find a better way to set z 
10bb			; 
10bb			;	ld b,a 
10bb			;	cp b 
10bb			;	pop bc 
10bb			;	ret 
10bb			; 
10bb			;.isdf:	; not digit so clear z 
10bb			; 
10bb			;	; TODO find a better way to unset z 
10bb			; 
10bb			;	ld b,a 
10bb			;	inc b 
10bb			;	cp b 
10bb			; 
10bb			;	pop bc 
10bb			;	ret 
10bb				 
10bb				 
10bb			 
10bb			 
10bb			; pass hl as the four byte address to load 
10bb			 
10bb			get_word_hl:  
10bb e5				push hl 
10bc cd 5b 10			call get_byte 
10bf				 
10bf 47				ld b, a 
10c0			 
10c0 e1				pop hl 
10c1 23				inc hl 
10c2 23				inc hl 
10c3			 
10c3			; TODO not able to handle a-f  
10c3 7e				ld a,(hl) 
10c4			;	;cp ':' 
10c4			;	cp 'g' 
10c4			;	jr nc, .single_byte_hl 		; > 
10c4			;	cp 'G' 
10c4			;	jr nc, .single_byte_hl 		; > 
10c4			;	cp '0' 
10c4			;	jr c, .single_byte_hl		; < 
10c4			 
10c4				;call isdigithl 
10c4 fe 00			cp 0 
10c6 28 06			jr z, .single_byte_hl 
10c8			 
10c8			.getwhln:   ; hex word so get next byte 
10c8			 
10c8 cd 5b 10			call get_byte 
10cb 6f				ld l, a 
10cc 60				ld h,b 
10cd c9				ret 
10ce 68			.single_byte_hl:   ld l,b 
10cf 26 00				ld h,0 
10d1 c9					ret 
10d2			 
10d2			 
10d2			 
10d2			 
10d2 21 1f 1a			ld hl,asc+1 
10d5			;	ld a, (hl) 
10d5			;	call nibble2val 
10d5 cd 5b 10			call get_byte 
10d8			 
10d8			;	call fourehexhl 
10d8 32 48 ee			ld (scratch+52),a 
10db				 
10db 21 46 ee			ld hl,scratch+50 
10de 22 37 f1			ld (os_cur_ptr),hl 
10e1			 
10e1 c9				ret 
10e2			 
10e2			 
10e2			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e2			 
10e2			; Decimal Unsigned Version 
10e2			 
10e2			;Number in a to decimal ASCII 
10e2			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e2			;Example: display a=56 as "056" 
10e2			;input: a = number 
10e2			;Output: a=0,value of a in the screen 
10e2			;destroys af,bc (don't know about hl and de) 
10e2			DispAToASCII: 
10e2 0e 9c			ld	c,-100 
10e4 cd ee 10			call	.Na1 
10e7 0e f6			ld	c,-10 
10e9 cd ee 10			call	.Na1 
10ec 0e ff			ld	c,-1 
10ee 06 2f		.Na1:	ld	b,'0'-1 
10f0 04			.Na2:	inc	b 
10f1 81				add	a,c 
10f2 38 fc			jr	c,.Na2 
10f4 91				sub	c		;works as add 100/10/1 
10f5 f5				push af		;safer than ld c,a 
10f6 78				ld	a,b		;char is in b 
10f7			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f7 f1				pop af		;safer than ld a,c 
10f8 c9				ret 
10f9			 
10f9			; Decimal Signed Version 
10f9			 
10f9			; DispA 
10f9			; -------------------------------------------------------------- 
10f9			; Converts a signed integer value to a zero-terminated ASCII 
10f9			; string representative of that value (using radix 10). 
10f9			; -------------------------------------------------------------- 
10f9			; INPUTS: 
10f9			;     HL     Value to convert (two's complement integer). 
10f9			;     DE     Base address of string destination. (pointer). 
10f9			; -------------------------------------------------------------- 
10f9			; OUTPUTS: 
10f9			;     None 
10f9			; -------------------------------------------------------------- 
10f9			; REGISTERS/MEMORY DESTROYED 
10f9			; AF HL 
10f9			; -------------------------------------------------------------- 
10f9			 
10f9			;DispHLToASCII: 
10f9			;   push    de 
10f9			;   push    bc 
10f9			; 
10f9			;; Detect sign of HL. 
10f9			;    bit    7, h 
10f9			;    jr     z, ._DoConvert 
10f9			; 
10f9			;; HL is negative. Output '-' to string and negate HL. 
10f9			;    ld     a, '-' 
10f9			;    ld     (de), a 
10f9			;    inc    de 
10f9			; 
10f9			;; Negate HL (using two's complement) 
10f9			;    xor    a 
10f9			;    sub    l 
10f9			;    ld     l, a 
10f9			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10f9			;    sbc    a, h 
10f9			;    ld     h, a 
10f9			; 
10f9			;; Convert HL to digit characters 
10f9			;._DoConvert: 
10f9			;    ld     b, 0     ; B will count character length of number 
10f9			;-   ld     a, 10 
10f9			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10f9			;    push   af 
10f9			;    inc    b 
10f9			;    ld     a, h 
10f9			;    or     l 
10f9			;    jr     nz, - 
10f9			; 
10f9			;; Retrieve digits from stack 
10f9			;-   pop    af 
10f9			;    or     $30 
10f9			;    ld     (de), a 
10f9			;    inc    de 
10f9			;    djnz   - 
10f9			; 
10f9			;; Terminate string with NULL 
10f9			;    xor    a 
10f9			;    ld     (de), a 
10f9			; 
10f9			;    pop    bc 
10f9			;    pop    de 
10f9			;    ret 
10f9			 
10f9			;Comments 
10f9			; 
10f9			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10f9			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10f9			;    Note that the output string will not be fixed-width. 
10f9			; 
10f9			;Example Usage 
10f9			; 
10f9			;    ld    hl, -1004 
10f9			;    ld    de, OP1 
10f9			;    call  DispA 
10f9			;    ld    hl, OP1 
10f9			;    syscall  PutS 
10f9			 
10f9			 
10f9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10f9			 
10f9			 
10f9			;Converts an ASCII string to an unsigned 16-bit integer 
10f9			;Quits when it reaches a non-decimal digit 
10f9			 
10f9			string_to_uint16: 
10f9			atoui_16: 
10f9			;Input: 
10f9			;     DE points to the string 
10f9			;Outputs: 
10f9			;     HL is the result 
10f9			;     A is the 8-bit value of the number 
10f9			;     DE points to the byte after the number 
10f9			;Destroys: 
10f9			;     BC 
10f9			;       if the string is non-empty, BC is HL/10 
10f9			;Size:  24 bytes 
10f9			;Speed: 42+d(104+{0,9}) 
10f9			;       d is the number of digits in the number 
10f9			;       max is 640 cycles for a 5 digit number 
10f9			;Assuming no leading zeros: 
10f9			;1 digit:  146cc 
10f9			;2 digit:  250cc 
10f9			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10f9			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10f9			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10f9			;avg: 544.81158447265625cc (544+13297/16384) 
10f9			;=============================================================== 
10f9 21 00 00		  ld hl,0 
10fc			.u16a: 
10fc 1a			  ld a,(de) 
10fd d6 30		  sub 30h 
10ff fe 0a		  cp 10 
1101 d0			  ret nc 
1102 13			  inc de 
1103 44			  ld b,h 
1104 4d			  ld c,l 
1105 29			  add hl,hl 
1106 29			  add hl,hl 
1107 09			  add hl,bc 
1108 29			  add hl,hl 
1109 85			  add a,l 
110a 6f			  ld l,a 
110b 30 ef		  jr nc,.u16a 
110d 24			  inc h 
110e c3 fc 10		  jp .u16a 
1111			 
1111			 
1111			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1111			 
1111			;written by Zeda 
1111			;Converts a 16-bit unsigned integer to an ASCII string. 
1111			 
1111			uitoa_16: 
1111			;Input: 
1111			;   DE is the number to convert 
1111			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1111			;Output: 
1111			;   HL points to the null-terminated ASCII string 
1111			;      NOTE: This isn't necessarily the same as the input HL. 
1111 d5			  push de 
1112 c5			  push bc 
1113 f5			  push af 
1114 eb			  ex de,hl 
1115			 
1115 01 f0 d8		  ld bc,-10000 
1118 3e 2f		  ld a,'0'-1 
111a 3c			  inc a 
111b 09			  add hl,bc  
111c 38 fc		   jr c,$-2 
111e 12			  ld (de),a 
111f 13			  inc de 
1120			 
1120 01 e8 03		  ld bc,1000 
1123 3e 3a		  ld a,'9'+1 
1125 3d			  dec a  
1126 09			  add hl,bc  
1127 30 fc		   jr nc,$-2 
1129 12			  ld (de),a 
112a 13			  inc de 
112b			 
112b 01 9c ff		  ld bc,-100 
112e 3e 2f		  ld a,'0'-1 
1130 3c			  inc a  
1131 09			  add hl,bc  
1132 38 fc		   jr c,$-2 
1134 12			  ld (de),a 
1135 13			  inc de 
1136			 
1136 7d			  ld a,l 
1137 26 3a		  ld h,'9'+1 
1139 25			  dec h  
113a c6 0a		  add a,10  
113c 30 fb		   jr nc,$-3 
113e c6 30		  add a,'0' 
1140 eb			  ex de,hl 
1141 72			  ld (hl),d 
1142 23			  inc hl 
1143 77			  ld (hl),a 
1144 23			  inc hl 
1145 36 00		  ld (hl),0 
1147			 
1147			;Now strip the leading zeros 
1147 0e fa		  ld c,-6 
1149 09			  add hl,bc 
114a 3e 30		  ld a,'0' 
114c 23			  inc hl  
114d be			  cp (hl)  
114e 28 fc		  jr z,$-2 
1150			 
1150			;Make sure that the string is non-empty! 
1150 7e			  ld a,(hl) 
1151 b7			  or a 
1152 20 01		  jr nz,.atoub 
1154 2b			  dec hl 
1155			.atoub: 
1155			 
1155 f1			  pop af 
1156 c1			  pop bc 
1157 d1			  pop de 
1158 c9			  ret 
1159			 
1159			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1159			 
1159			toUpper: 
1159			;A is the char. 
1159			;If A is a lowercase letter, this sets it to the matching uppercase 
1159			;18cc or 30cc or 41cc 
1159			;avg: 26.75cc 
1159 fe 61		  cp 'a' 
115b d8			  ret c 
115c fe 7b		  cp 'z'+1 
115e d0			  ret nc 
115f d6 20		  sub 'a'-'A' 
1161 c9			  ret 
1162			 
1162			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1162			 
1162			; String Length 
1162			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1162			 
1162			; Get the length of the null-terminated string starting at $8000 hl 
1162			;    LD     HL, $8000 
1162			 
1162			strlenz: 
1162			 
1162 af			    XOR    A               ; Zero is the value we are looking for. 
1163 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1164 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1165			                           ; 65, 536 bytes (the entire addressable memory space). 
1165 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1167			 
1167			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1167 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1168 6f			    LD     L, A             ; number of bytes 
1169 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
116b 2b			    DEC    HL              ; Compensate for null. 
116c c9				ret 
116d			 
116d			; Get the length of the A terminated string starting at $8000 hl 
116d			;    LD     HL, $8000 
116d			 
116d			strlent: 
116d			 
116d			                  ; A is the value we are looking for. 
116d 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
116f 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1171			                           ; 65, 536 bytes (the entire addressable memory space). 
1171 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1173			 
1173			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1173 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1175 2e 00		    LD     L, 0             ; number of bytes 
1177 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1179 2b			    DEC    HL              ; Compensate for null. 
117a c9				ret 
117b			 
117b			 
117b			;Comparing Strings 
117b			 
117b			;IN    HL     Address of string1. 
117b			;      DE     Address of string2. 
117b			 
117b			; doc given but wrong??? 
117b			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
117b			;      carry  Set if string1 > string2, reset if string1 <= string2. 
117b			; tested 
117b			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
117b			 
117b			strcmp_old: 
117b e5			    PUSH   HL 
117c d5			    PUSH   DE 
117d			 
117d 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
117e be			    CP     (HL)            ; (want to minimize work). 
117f 38 01		    JR     C, Str1IsBigger 
1181 7e			    LD     A, (HL) 
1182			 
1182			Str1IsBigger: 
1182 4f			    LD     C, A             ; Put length in BC 
1183 06 00		    LD     B, 0 
1185 13			    INC    DE              ; Increment pointers to meat of string. 
1186 23			    INC    HL 
1187			 
1187			CmpLoop: 
1187 1a			    LD     A, (DE)          ; Compare bytes. 
1188 ed a1		    CPI 
118a 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
118c 13			    INC    DE              ; Update pointer. 
118d ea 87 11		    JP     PE, CmpLoop 
1190			 
1190 d1			    POP    DE 
1191 e1			    POP    HL 
1192 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1193 be			    CP     (HL) 
1194 c9			    RET 
1195			 
1195			NoMatch: 
1195 2b			    DEC    HL 
1196 be			    CP     (HL)            ; Compare again to affect carry. 
1197 d1			    POP    DE 
1198 e1			    POP    HL 
1199 c9			    RET 
119a			 
119a			;; test strmp 
119a			; 
119a			;ld de, .str1 
119a			;ld hl, .str2 
119a			;call strcmp 
119a			;jr z, .z1 
119a			;;this 
119a			;	if DEBUG_FORTH_WORDS 
119a			;		DMARK "NZ1" 
119a			;		CALLMONITOR 
119a			;	endif 
119a			;.z1: 
119a			; 
119a			;	if DEBUG_FORTH_WORDS 
119a			;		DMARK "ZZ1" 
119a			;		CALLMONITOR 
119a			;	endif 
119a			; 
119a			;ld de, .str1 
119a			;ld hl, .str1 
119a			;call strcmp 
119a			;jr z, .z2 
119a			;;this 
119a			;	if DEBUG_FORTH_WORDS 
119a			;		DMARK "NZ2" 
119a			;		CALLMONITOR 
119a			;	endif 
119a			;.z2: 
119a			; 
119a			;	if DEBUG_FORTH_WORDS 
119a			;		DMARK "ZZ2" 
119a			;		CALLMONITOR 
119a			;	endif 
119a			; 
119a			;ld de, .str1 
119a			;ld hl, .str2 
119a			;call strcmp 
119a			;jr c, .c1 
119a			; 
119a			;	if DEBUG_FORTH_WORDS 
119a			;		DMARK "Nc1" 
119a			;		CALLMONITOR 
119a			;	endif 
119a			;.c1: 
119a			;;this 
119a			;	if DEBUG_FORTH_WORDS 
119a			;		DMARK "cc1" 
119a			;		CALLMONITOR 
119a			;	endif 
119a			; 
119a			;ld de, .str1 
119a			;ld hl, .str1 
119a			;call strcmp 
119a			;jr c, .c2 
119a			;;this 
119a			;	if DEBUG_FORTH_WORDS 
119a			;		DMARK "Nc2" 
119a			;		CALLMONITOR 
119a			;	endif 
119a			;.c2: 
119a			; 
119a			;	if DEBUG_FORTH_WORDS 
119a			;		DMARK "cc2" 
119a			;		CALLMONITOR 
119a			;	endif 
119a			;	NEXTW 
119a			;.str1:   db "string1",0 
119a			;.str2:   db "string2",0 
119a			 
119a			; only care about direct match or not 
119a			; hl and de strings 
119a			; zero set if the same 
119a			 
119a			strcmp: 
119a 1a				ld a, (de) 
119b be				cp (hl) 
119c 28 02			jr z, .ssame 
119e b7				or a 
119f c9				ret 
11a0			 
11a0			.ssame:  
11a0 fe 00			cp 0 
11a2 c8				ret z 
11a3			 
11a3 23				inc hl 
11a4 13				inc de 
11a5 18 f3			jr strcmp 
11a7				 
11a7				 
11a7			 
11a7			 
11a7			 
11a7			 
11a7			; eof 
11a7			 
11a7			 
11a7			 
11a7			 
11a7			 
11a7			 
# End of file firmware_strings.asm
11a7			include "firmware_memory.asm"   ; malloc and free  
11a7			 
11a7			if DEBUG_FORTH_MALLOC_HIGH 
11a7			.mallocsize: db "Wants malloc >256",0 
11a7			.mallocasize: db "MALLOC gives >256",0 
11a7			.malloczero: db "MALLOC gives zero",0 
11a7			 
11a7			malloc_guard_zerolen: 
11a7				push hl 
11a7				push de 
11a7				push af 
11a7			 
11a7				ld de, 0 
11a7			        call cmp16 
11a7				jr nz, .lowalloz 
11a7			 
11a7				push hl 
11a7				push de 
11a7					ld hl, display_fb0 
11a7					ld (display_fb_active), hl 
11a7				call clear_display 
11a7				ld a, 0 
11a7				ld de, .malloczero 
11a7				call str_at_display 
11a7				call update_display 
11a7				call delay1s 
11a7				call delay1s 
11a7				ld a, 0 
11a7				ld (os_view_disable), a 
11a7			 
11a7				pop de 
11a7				pop hl 
11a7			 
11a7				 
11a7			 
11a7				CALLMONITOR 
11a7			.lowalloz: 
11a7			 
11a7			 
11a7				pop af 
11a7				pop de 
11a7				pop hl 
11a7			ret 
11a7			 
11a7			malloc_guard_entry: 
11a7				push hl 
11a7				push de 
11a7				push af 
11a7			 
11a7			 	or a      ;clear carry flag 
11a7				push hl 
11a7				ld de, 255 
11a7				sbc hl, de 
11a7				jr c, .lowalloc 
11a7			 
11a7				push de 
11a7					ld hl, display_fb0 
11a7					ld (display_fb_active), hl 
11a7				call clear_display 
11a7				ld a, 0 
11a7				ld de, .mallocsize 
11a7				call str_at_display 
11a7				call update_display 
11a7				call delay1s 
11a7				call delay1s 
11a7				ld a, 0 
11a7				ld (os_view_disable), a 
11a7			 
11a7				pop de 
11a7				pop hl 
11a7			 
11a7				 
11a7			 
11a7				CALLMONITOR 
11a7				jr .lowdone 
11a7			.lowalloc: 
11a7			 
11a7			 
11a7				pop hl 
11a7			.lowdone:	pop af 
11a7				pop de 
11a7				pop hl 
11a7			ret 
11a7			 
11a7			malloc_guard_exit: 
11a7				push hl 
11a7				push de 
11a7				push af 
11a7			 
11a7			 	or a      ;clear carry flag 
11a7				push hl 
11a7				ld de, 255 
11a7				sbc hl, de 
11a7				jr c, .lowallocx 
11a7			 
11a7				push de 
11a7					ld hl, display_fb0 
11a7					ld (display_fb_active), hl 
11a7				call clear_display 
11a7				ld a, 0 
11a7				ld de, .mallocasize 
11a7				call str_at_display 
11a7				call update_display 
11a7				call delay1s 
11a7				call delay1s 
11a7				ld a, 0 
11a7				ld (os_view_disable), a 
11a7				pop de 
11a7				pop hl 
11a7			 
11a7				CALLMONITOR 
11a7				jr .lowdonex 
11a7			.lowallocx: 
11a7			 
11a7				pop hl 
11a7			.lowdonex:	pop af 
11a7				pop de 
11a7				pop hl 
11a7			ret 
11a7			endif 
11a7			 
11a7			if MALLOC_2 
11a7			; Z80 Malloc and Free Functions 
11a7			 
11a7			; Malloc Function: 
11a7			; Input: 
11a7			;   HL: Size of block to allocate 
11a7			; Output: 
11a7			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a7			 
11a7			malloc: 
11a7				 
11a7			if DEBUG_FORTH_MALLOC_HIGH 
11a7			call malloc_guard_entry 
11a7			endif 
11a7			 
11a7			 
11a7			 
11a7			 
11a7					if DEBUG_FORTH_MALLOC 
11a7						DMARK "mal" 
11a7						CALLMONITOR 
11a7					endif 
11a7			    push af            ; Save AF register 
11a7			    ld a, l            ; Load low byte of size into A 
11a7			    or h               ; Check if size is zero 
11a7			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11a7			 
11a7			    ; Allocate memory 
11a7			    ld hl, (heap_start) ; Load start of heap into HL 
11a7					if DEBUG_FORTH_MALLOC 
11a7						DMARK "ma1" 
11a7						CALLMONITOR 
11a7					endif 
11a7			    call malloc_internal ; Call internal malloc function 
11a7			    pop af             ; Restore AF register 
11a7			if DEBUG_FORTH_MALLOC_HIGH 
11a7			call malloc_guard_exit 
11a7			call malloc_guard_zerolen 
11a7			endif 
11a7			    ret                ; Return 
11a7			 
11a7			; Free Function: 
11a7			; Input: 
11a7			;   HL: Pointer to memory block to free 
11a7			; Output: 
11a7			;   None 
11a7			 
11a7			free: 
11a7			    push af            ; Save AF register 
11a7			    ld a, l            ; Load low byte of pointer into A 
11a7			    or h               ; Check if pointer is NULL 
11a7			    jp z, free_exit    ; If pointer is NULL, exit 
11a7			 
11a7			    ; Free memory 
11a7			    ld hl, (heap_start) ; Load start of heap into HL 
11a7			    call free_internal  ; Call internal free function 
11a7			    pop af             ; Restore AF register 
11a7			    ret                ; Return 
11a7			 
11a7			; Internal Malloc Function: 
11a7			; Input: 
11a7			;   HL: Size of block to allocate 
11a7			; Output: 
11a7			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a7			 
11a7			malloc_internal: 
11a7			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11a7			    add hl, bc         ; Add management overhead to requested size 
11a7			    ex de, hl          ; Save total size in DE, and keep it in HL 
11a7					if DEBUG_FORTH_MALLOC 
11a7						DMARK "ma2" 
11a7						CALLMONITOR 
11a7					endif 
11a7			 
11a7			    ; Search for free memory block 
11a7			    ld de, (heap_end)  ; Load end of heap into DE 
11a7			    ld bc, 0           ; Initialize counter 
11a7			 
11a7					if DEBUG_FORTH_MALLOC 
11a7						DMARK "ma2" 
11a7						CALLMONITOR 
11a7					endif 
11a7			malloc_search_loop: 
11a7			    ; Check if current block is free 
11a7			    ld a, (hl)         ; Load current block's status (free or used) 
11a7			    cp 0               ; Compare with zero (free) 
11a7			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11a7			 
11a7			    ; Check if current block is large enough 
11a7			    ld a, (hl+1)       ; Load high byte of block size 
11a7			    cp l               ; Compare with low byte of requested size 
11a7			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11a7			 
11a7			    ld a, (hl+2)       ; Load low byte of block size 
11a7			    cp h               ; Compare with high byte of requested size 
11a7			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11a7			 
11a7			    ; Mark block as used 
11a7			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11a7			 
11a7			    ; Calculate remaining space in block 
11a7			    ld bc, 0           ; Clear BC 
11a7			    add hl, bc         ; Increment HL to point to start of data block 
11a7			    add hl, de         ; HL = HL + DE (total size) 
11a7			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11a7			    add hl, bc         ; Add management overhead to start of data block 
11a7			 
11a7			    ; Save pointer to allocated block in HL 
11a7			if DEBUG_FORTH_MALLOC_HIGH 
11a7						DMARK "ma5" 
11a7			call malloc_guard_exit 
11a7			call malloc_guard_zerolen 
11a7			endif 
11a7			    ret 
11a7			 
11a7			malloc_skip_block_check: 
11a7			    ; Move to the next block 
11a7			    ld bc, 3           ; Size of management overhead 
11a7			    add hl, bc         ; Move to the next block 
11a7			    inc de             ; Increment counter 
11a7			 
11a7			    ; Check if we have reached the end of heap 
11a7			    ld a, e            ; Load low byte of heap end address 
11a7			    cp (hl)            ; Compare with low byte of current address 
11a7			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11a7			    ld a, d            ; Load high byte of heap end address 
11a7			    cp 0               ; Check if it's zero (end of memory) 
11a7			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11a7			 
11a7			    ; If we reached here, allocation failed 
11a7			    xor a              ; Set result to NULL 
11a7			if DEBUG_FORTH_MALLOC_HIGH 
11a7						DMARK "ma6" 
11a7			call malloc_guard_exit 
11a7			call malloc_guard_zerolen 
11a7			endif 
11a7			    ret 
11a7			malloc_exit: 
11a7			if DEBUG_FORTH_MALLOC_HIGH 
11a7						DMARK "ma7" 
11a7			call malloc_guard_exit 
11a7			call malloc_guard_zerolen 
11a7			endif 
11a7			    ret 
11a7			 
11a7			; Internal Free Function: 
11a7			; Input: 
11a7			;   HL: Pointer to memory block to free 
11a7			; Output: 
11a7			;   None 
11a7			 
11a7			free_internal: 
11a7			    ld de, (heap_start) ; Load start of heap into DE 
11a7			    ld bc, 0            ; Initialize counter 
11a7			 
11a7			free_search_loop: 
11a7			    ; Check if current block contains the pointer 
11a7			    ld a, l             ; Load low byte of pointer 
11a7			    cp (hl+1)           ; Compare with high byte of current block's address 
11a7			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a7			    ld a, h             ; Load high byte of pointer 
11a7			    cp (hl+2)           ; Compare with low byte of current block's address 
11a7			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a7			 
11a7			    ; Mark block as free 
11a7			    ld (hl), 0          ; Set status byte to indicate free block 
11a7			    ret                 ; Return 
11a7			 
11a7			free_skip_block_check: 
11a7			    ; Move to the next block 
11a7			    ld bc, 3            ; Size of management overhead 
11a7			    add hl, bc          ; Move to the next block 
11a7			    inc de              ; Increment counter 
11a7			 
11a7			    ; Check if we have reached the end of heap 
11a7			    ld a, e             ; Load low byte of heap end address 
11a7			    cp (hl)             ; Compare with low byte of current address 
11a7			    jr nz, free_search_loop  ; If not equal, continue searching 
11a7			    ld a, d             ; Load high byte of heap end address 
11a7			    cp 0                ; Check if it's zero (end of memory) 
11a7			    jr nz, free_search_loop  ; If not zero, continue searching 
11a7			 
11a7			    ; If we reached here, pointer is not found in heap 
11a7			    ret 
11a7			 
11a7			free_exit: 
11a7			    ret                 ; Return 
11a7			 
11a7			; Define heap start and end addresses 
11a7			;heap_start:    .dw 0xC000   ; Start of heap 
11a7			;heap_end:      .dw 0xE000   ; End of heap 
11a7			 
11a7			endif 
11a7			 
11a7			 
11a7			if MALLOC_1 
11a7			 
11a7			 
11a7			 
11a7			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11a7			 
11a7			;moved to firmware.asm 
11a7			;heap_start        .equ  0x9000      ; Starting address of heap 
11a7			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11a7			 
11a7			;      .org 0 
11a7			;      jp    main 
11a7			 
11a7			 
11a7			;      .org  0x100 
11a7			;main: 
11a7			;      ld    HL, 0x8100 
11a7			;      ld    SP, HL 
11a7			; 
11a7			;      call  heap_init 
11a7			; 
11a7			;      ; Make some allocations 
11a7			;      ld    HL, 12 
11a7			;      call  malloc            ; Allocates 0x9004 
11a7			; 
11a7			;      ld    HL, 12 
11a7			;      call  malloc            ; Allocates 0x9014 
11a7			; 
11a7			;      ld    HL, 12 
11a7			;      call  malloc            ; Allocates 0x9024 
11a7			; 
11a7			;      ; Free some allocations 
11a7			;      ld    HL, 0x9014 
11a7			;      call  free 
11a7			; 
11a7			;      ld    HL, 0x9004 
11a7			;      call  free 
11a7			; 
11a7			;      ld    HL, 0x9024 
11a7			;      call  free 
11a7			; 
11a7			; 
11a7			;      halt 
11a7			 
11a7			 
11a7			;------------------------------------------------------------------------------ 
11a7			;     heap_init                                                               : 
11a7			;                                                                             : 
11a7			; Description                                                                 : 
11a7			;     Initialise the heap and make it ready for malloc and free operations.   : 
11a7			;                                                                             : 
11a7			;     The heap is maintained as a linked list, starting with an initial       : 
11a7			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11a7			;     the first free block in the heap. Each block then points to the next    : 
11a7			;     free block within the heap, and the free list ends at the first block   : 
11a7			;     with a null pointer to the next free block.                             : 
11a7			;                                                                             : 
11a7			; Parameters                                                                  : 
11a7			;     Inputs are compile-time only. Two defines which specify the starting    : 
11a7			;     address of the heap and its size are required, along with a memory      : 
11a7			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11a7			;     principally stores a pointer to the first free block in the heap.       : 
11a7			;                                                                             : 
11a7			; Returns                                                                     : 
11a7			;     Nothing                                                                 : 
11a7			;------------------------------------------------------------------------------ 
11a7			heap_init: 
11a7 e5			      push  HL 
11a8			 
11a8			      ; Initialise free list struct 
11a8 21 0e 80		      ld    HL, heap_start 
11ab 22 0a 80		      ld    (free_list), HL 
11ae 21 00 00		      ld    HL, 0 
11b1 22 0c 80		      ld    (free_list+2), HL 
11b4			 
11b4			      ; Insert first free block at bottom of heap, consumes entire heap 
11b4 21 f6 ed		      ld    HL, heap_start+heap_size-4 
11b7 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11ba 21 e8 6d		      ld    HL, heap_size-4 
11bd 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c0			 
11c0			      ; Insert end of free list block at top of heap - two null words will 
11c0			      ; terminate the free list 
11c0 21 00 00		      ld    HL, 0 
11c3 22 f8 ed		      ld    (heap_start+heap_size-2), HL 
11c6 22 f6 ed		      ld    (heap_start+heap_size-4), HL 
11c9			 
11c9 e1			      pop   HL 
11ca			 
11ca c9			      ret 
11cb			 
11cb			 
11cb			;------------------------------------------------------------------------------ 
11cb			;     malloc                                                                  : 
11cb			;                                                                             : 
11cb			; Description                                                                 : 
11cb			;     Allocates the wanted space from the heap and returns the address of the : 
11cb			;     first useable byte of the allocation.                                   : 
11cb			;                                                                             : 
11cb			;     Allocations can happen in one of two ways:                              : 
11cb			;                                                                             : 
11cb			;     1. A free block may be found which is the exact size wanted. In this    : 
11cb			;        case the block is removed from the free list and retuedn to the      : 
11cb			;        caller.                                                              : 
11cb			;     2. A free block may be found which is larger than the size wanted. In   : 
11cb			;        this case, the larger block is split into two. The first portion of  : 
11cb			;        this block will become the requested space by the malloc call and    : 
11cb			;        is returned to the caller. The second portion becomes a new free     : 
11cb			;        block, and the free list is adjusted to maintain continuity via this : 
11cb			;        newly created block.                                                 : 
11cb			;                                                                             : 
11cb			;     malloc does not set any initial value in the allocated space, the       : 
11cb			;     caller is required to do this as required.                              : 
11cb			;                                                                             : 
11cb			;     This implementation of malloc uses the stack exclusively, and is        : 
11cb			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11cb			;     advisable to disable interrupts before calling malloc, and recommended  : 
11cb			;     to avoid the use of malloc inside ISRs in general.                      : 
11cb			;                                                                             : 
11cb			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11cb			;                                                                             : 
11cb			; Parameters                                                                  : 
11cb			;     HL  Number of bytes wanted                                              : 
11cb			;                                                                             : 
11cb			; Returns                                                                     : 
11cb			;     HL  Address of the first useable byte of the allocation                 : 
11cb			;                                                                             : 
11cb			; Flags                                                                       : 
11cb			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11cb			;                                                                             : 
11cb			; Stack frame                                                                 : 
11cb			;       |             |                                                       : 
11cb			;       +-------------+                                                       : 
11cb			;       |     BC      |                                                       : 
11cb			;       +-------------+                                                       : 
11cb			;       |     DE      |                                                       : 
11cb			;       +-------------+                                                       : 
11cb			;       |     IX      |                                                       : 
11cb			;       +-------------+                                                       : 
11cb			;       |  prev_free  |                                                       : 
11cb			;   +4  +-------------+                                                       : 
11cb			;       |  this_free  |                                                       : 
11cb			;   +2  +-------------+                                                       : 
11cb			;       |  next_free  |                                                       : 
11cb			;   +0  +-------------+                                                       : 
11cb			;       |             |                                                       : 
11cb			;                                                                             : 
11cb			;------------------------------------------------------------------------------ 
11cb			 
11cb			 
11cb			;malloc: 
11cb			; 
11cb			;	SAVESP ON 1 
11cb			; 
11cb			;	call malloc_code 
11cb			; 
11cb			;	CHECKSP ON 1 
11cb			;	ret 
11cb			 
11cb			 
11cb			malloc: 
11cb c5			      push  BC 
11cc d5			      push  DE 
11cd dd e5		      push  IX 
11cf			if DEBUG_FORTH_MALLOC_HIGH 
11cf			call malloc_guard_entry 
11cf			endif 
11cf			 
11cf					if DEBUG_FORTH_MALLOC 
11cf						DMARK "mal" 
11cf						CALLMONITOR 
11cf					endif 
11cf 7c			      ld    A, H                    ; Exit if no space requested 
11d0 b5			      or    L 
11d1 ca 90 12		      jp    Z, malloc_early_exit 
11d4			 
11d4			;inc hl 
11d4			;inc hl 
11d4			;inc hl 
11d4			; 
11d4			;inc hl 
11d4			;inc hl 
11d4			;inc hl 
11d4			;inc hl 
11d4			;inc hl 
11d4			;inc hl 
11d4			;inc hl 
11d4			;inc hl 
11d4			;inc hl 
11d4			 
11d4			 
11d4			 
11d4			 
11d4					if DEBUG_FORTH_MALLOC 
11d4						DMARK "maA" 
11d4						CALLMONITOR 
11d4					endif 
11d4			      ; Set up stack frame 
11d4 eb			      ex    DE, HL 
11d5 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11d8 39			      add   HL, SP 
11d9 f9			      ld    SP, HL 
11da dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11de dd 39		      add   IX, SP 
11e0			 
11e0			      ; Setup initial state 
11e0 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e3 19			      add   HL, DE 
11e4			 
11e4 44			      ld    B, H                    ; Move want to BC 
11e5 4d			      ld    C, L 
11e6			 
11e6 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11e9 dd 75 04		      ld    (IX+4), L 
11ec dd 74 05		      ld    (IX+5), H 
11ef			 
11ef 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f0 23			      inc   HL 
11f1 56			      ld    D, (HL) 
11f2 dd 73 02		      ld    (IX+2), E 
11f5 dd 72 03		      ld    (IX+3), D 
11f8 eb			      ex    DE, HL                  ; this_free ptr into HL 
11f9			 
11f9					if DEBUG_FORTH_MALLOC 
11f9						DMARK "maB" 
11f9						CALLMONITOR 
11f9					endif 
11f9			      ; Loop through free block list to find some space 
11f9			malloc_find_space: 
11f9 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11fa 23			      inc   HL 
11fb 56			      ld    D, (HL) 
11fc			 
11fc 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11fd b3			      or    E 
11fe ca 8a 12		      jp    Z, malloc_no_space 
1201			 
1201 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1204 dd 72 01		      ld    (IX+1), D 
1207			 
1207			      ; Does this block have enough space to make the allocation? 
1207 23			      inc   HL                      ; Load free block size into DE 
1208 5e			      ld    E, (HL) 
1209 23			      inc   HL 
120a 56			      ld    D, (HL) 
120b			 
120b eb			      ex    DE, HL                  ; Check size of block against want 
120c b7			      or    A                       ; Ensure carry flag clear 
120d ed 42		      sbc   HL, BC 
120f e5			      push  HL                      ; Store the result for later (new block size) 
1210			 
1210 ca 5f 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1213 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1215			 
1215			      ; this_free block is not big enough, setup ptrs to test next free block 
1215 e1			      pop   HL                      ; Discard previous result 
1216			 
1216 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1219 dd 66 03		      ld    H, (IX+3) 
121c dd 75 04		      ld    (IX+4), L 
121f dd 74 05		      ld    (IX+5), H 
1222			 
1222 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1225 dd 66 01		      ld    H, (IX+1) 
1228 dd 75 02		      ld    (IX+2), L 
122b dd 74 03		      ld    (IX+3), H 
122e			 
122e					if DEBUG_FORTH_MALLOC 
122e						DMARK "MA>" 
122e						CALLMONITOR 
122e					endif 
122e 18 c9		      jr    malloc_find_space 
1230			 
1230			      ; split a bigger block into two - requested size and remaining size 
1230			malloc_alloc_split: 
1230					if DEBUG_FORTH_MALLOC 
1230						DMARK "MAs" 
1230						CALLMONITOR 
1230					endif 
1230 eb			      ex    DE, HL                  ; Calculate address of new free block 
1231 2b			      dec   HL 
1232 2b			      dec   HL 
1233 2b			      dec   HL 
1234 09			      add   HL, BC 
1235			 
1235			      ; Create a new block and point it at next_free 
1235 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1238 dd 56 01		      ld    D, (IX+1) 
123b			 
123b 73			      ld    (HL), E                 ; Store next_free ptr into new block 
123c 23			      inc   HL 
123d 72			      ld    (HL), D 
123e			 
123e d1			      pop   DE                      ; Store size of new block into new block 
123f 23			      inc   HL 
1240 73			      ld    (HL), E 
1241 23			      inc   HL 
1242 72			      ld    (HL), D 
1243			 
1243			      ; Update this_free ptr to point to new block 
1243 2b			      dec   HL 
1244 2b			      dec   HL 
1245 2b			      dec   HL 
1246			 
1246 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1249 dd 56 03		      ld    D, (IX+3) 
124c			 
124c dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
124f dd 74 03		      ld    (IX+3), H 
1252			 
1252			      ; Modify this_free block to be allocation 
1252 eb			      ex    DE, HL 
1253 af			      xor   A                       ; Null the next block ptr of allocated block 
1254 77			      ld    (HL), A 
1255 23			      inc   HL 
1256 77			      ld    (HL), A 
1257			 
1257 23			      inc   HL                      ; Store want size into allocated block 
1258 71			      ld    (HL), C 
1259 23			      inc   HL 
125a 70			      ld    (HL), B 
125b 23			      inc   HL 
125c e5			      push  HL                      ; Address of allocation to return 
125d			 
125d 18 19		      jr    malloc_update_links 
125f			 
125f			malloc_alloc_fit: 
125f e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1260			 
1260					if DEBUG_FORTH_MALLOC 
1260						DMARK "MAf" 
1260						CALLMONITOR 
1260					endif 
1260			      ; Modify this_free block to be allocation 
1260 eb			      ex    DE, HL 
1261 2b			      dec   HL 
1262 2b			      dec   HL 
1263 2b			      dec   HL 
1264			 
1264 af			      xor   A                       ; Null the next block ptr of allocated block 
1265 77			      ld    (HL), A 
1266 23			      inc   HL 
1267 77			      ld    (HL), A 
1268			 
1268 23			      inc   HL                      ; Store address of allocation to return 
1269 23			      inc   HL 
126a 23			      inc   HL 
126b e5			      push  HL 
126c			 
126c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126c dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
126f dd 66 01		      ld    H, (IX+1) 
1272			 
1272 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1275 dd 74 03		      ld    (IX+3), H 
1278			 
1278			 
1278			malloc_update_links: 
1278			      ; Update prev_free ptr to point to this_free 
1278 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
127b dd 66 05		      ld    H, (IX+5) 
127e			 
127e dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1281 dd 56 03		      ld    D, (IX+3) 
1284			 
1284 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1285 23			      inc   HL 
1286 72			      ld    (HL), D 
1287			 
1287					if DEBUG_FORTH_MALLOC 
1287						DMARK "Mul" 
1287						CALLMONITOR 
1287					endif 
1287			      ; Clear the Z flag to indicate successful allocation 
1287 7a			      ld    A, D 
1288 b3			      or    E 
1289			 
1289 d1			      pop   DE                      ; Address of allocation 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "MAu" 
128a						CALLMONITOR 
128a					endif 
128a			 
128a			malloc_no_space: 
128a 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
128d 39			      add   HL, SP 
128e f9			      ld    SP, HL 
128f			 
128f eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1290					if DEBUG_FORTH_MALLOC 
1290						DMARK "MAN" 
1290						CALLMONITOR 
1290					endif 
1290			 
1290			malloc_early_exit: 
1290					if DEBUG_FORTH_MALLOC 
1290						DMARK "MAx" 
1290						CALLMONITOR 
1290					endif 
1290 dd e1		      pop   IX 
1292 d1			      pop   DE 
1293 c1			      pop   BC 
1294			 
1294			if DEBUG_FORTH_MALLOC_HIGH 
1294			call malloc_guard_exit 
1294			call malloc_guard_zerolen 
1294			endif 
1294 c9			      ret 
1295			 
1295			 
1295			;------------------------------------------------------------------------------ 
1295			;     free                                                                    : 
1295			;                                                                             : 
1295			; Description                                                                 : 
1295			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1295			;     returned by malloc, otherwise the behaviour is undefined.               : 
1295			;                                                                             : 
1295			;     Where possible, directly adjacent free blocks will be merged together   : 
1295			;     into larger blocks to help ensure that the heap does not become         : 
1295			;     excessively fragmented.                                                 : 
1295			;                                                                             : 
1295			;     free does not clear or set any other value into the freed space, and    : 
1295			;     therefore its contents may be visible through subsequent malloc's. The  : 
1295			;     caller should clear the freed space as required.                        : 
1295			;                                                                             : 
1295			;     This implementation of free uses the stack exclusively, and is          : 
1295			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1295			;     advisable to disable interrupts before calling free, and recommended    : 
1295			;     to avoid the use of free inside ISRs in general.                        : 
1295			;                                                                             : 
1295			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1295			;                                                                             : 
1295			; Parameters                                                                  : 
1295			;     HL  Pointer to address of first byte of allocation to be freed          : 
1295			;                                                                             : 
1295			; Returns                                                                     : 
1295			;     Nothing                                                                 : 
1295			;                                                                             : 
1295			; Stack frame                                                                 : 
1295			;       |             |                                                       : 
1295			;       +-------------+                                                       : 
1295			;       |     BC      |                                                       : 
1295			;       +-------------+                                                       : 
1295			;       |     DE      |                                                       : 
1295			;       +-------------+                                                       : 
1295			;       |     IX      |                                                       : 
1295			;       +-------------+                                                       : 
1295			;       |  prev_free  |                                                       : 
1295			;   +2  +-------------+                                                       : 
1295			;       |  next_free  |                                                       : 
1295			;   +0  +-------------+                                                       : 
1295			;       |             |                                                       : 
1295			;                                                                             : 
1295			;------------------------------------------------------------------------------ 
1295			free: 
1295 c5			      push  BC 
1296 d5			      push  DE 
1297 dd e5		      push  IX 
1299			 
1299 7c			      ld    A, H                    ; Exit if ptr is null 
129a b5			      or    L 
129b ca 5f 13		      jp    Z, free_early_exit 
129e			 
129e			      ; Set up stack frame 
129e eb			      ex    DE, HL 
129f 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a2 39			      add   HL, SP 
12a3 f9			      ld    SP, HL 
12a4 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12a8 dd 39		      add   IX, SP 
12aa			 
12aa			      ; The address in HL points to the start of the useable allocated space, 
12aa			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12aa			      ; address of the block itself. 
12aa eb			      ex    DE, HL 
12ab 11 fc ff		      ld    DE, -4 
12ae 19			      add   HL, DE 
12af			 
12af			      ; An allocated block must have a null next block pointer in it 
12af 7e			      ld    A, (HL) 
12b0 23			      inc   HL 
12b1 b6			      or    (HL) 
12b2 c2 5a 13		      jp    NZ, free_done 
12b5			 
12b5 2b			      dec   HL 
12b6			 
12b6 44			      ld    B, H                    ; Copy HL to BC 
12b7 4d			      ld    C, L 
12b8			 
12b8			      ; Loop through the free list to find the first block with an address 
12b8			      ; higher than the block being freed 
12b8 21 0a 80		      ld    HL, free_list 
12bb			 
12bb			free_find_higher_block: 
12bb 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12bc 23			      inc   HL 
12bd 56			      ld    D, (HL) 
12be 2b			      dec   HL 
12bf			 
12bf dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c2 dd 72 01		      ld    (IX+1), D 
12c5 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12c8 dd 74 03		      ld    (IX+3), H 
12cb			 
12cb 78			      ld    A, B                    ; Check if DE is greater than BC 
12cc ba			      cp    D                       ; Compare MSB first 
12cd 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12cf 30 04		      jr    NC, free_find_higher_block_skip 
12d1 79			      ld    A, C 
12d2 bb			      cp    E                       ; Then compare LSB 
12d3 38 08		      jr    C, free_found_higher_block 
12d5			 
12d5			free_find_higher_block_skip: 
12d5 7a			      ld    A, D                    ; Reached the end of the free list? 
12d6 b3			      or    E 
12d7 ca 5a 13		      jp    Z, free_done 
12da			 
12da eb			      ex    DE, HL 
12db			 
12db 18 de		      jr    free_find_higher_block 
12dd			 
12dd			free_found_higher_block: 
12dd			      ; Insert freed block between prev and next free blocks 
12dd 71			      ld    (HL), C                 ; Point prev free block to freed block 
12de 23			      inc   HL 
12df 70			      ld    (HL), B 
12e0			 
12e0 60			      ld    H, B                    ; Point freed block at next free block 
12e1 69			      ld    L, C 
12e2 73			      ld    (HL), E 
12e3 23			      inc   HL 
12e4 72			      ld    (HL), D 
12e5			 
12e5			      ; Check if the freed block is adjacent to the next free block 
12e5 23			      inc   HL                      ; Load size of freed block into HL 
12e6 5e			      ld    E, (HL) 
12e7 23			      inc   HL 
12e8 56			      ld    D, (HL) 
12e9 eb			      ex    DE, HL 
12ea			 
12ea 09			      add   HL, BC                  ; Add addr of freed block and its size 
12eb			 
12eb dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12ee dd 56 01		      ld    D, (IX+1) 
12f1			 
12f1 b7			      or    A                       ; Clear the carry flag 
12f2 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f4 20 22		      jr    NZ, free_check_adjacent_to_prev 
12f6			 
12f6			      ; Freed block is adjacent to next, merge into one bigger block 
12f6 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12f7 5e			      ld    E, (HL) 
12f8 23			      inc   HL 
12f9 56			      ld    D, (HL) 
12fa e5			      push  HL                      ; Save ptr to next block for later 
12fb			 
12fb 60			      ld    H, B                    ; Store ptr from next block into freed block 
12fc 69			      ld    L, C 
12fd 73			      ld    (HL), E 
12fe 23			      inc   HL 
12ff 72			      ld    (HL), D 
1300			 
1300 e1			      pop   HL                      ; Restore ptr to next block 
1301 23			      inc   HL                      ; Load size of next block into DE 
1302 5e			      ld    E, (HL) 
1303 23			      inc   HL 
1304 56			      ld    D, (HL) 
1305 d5			      push  DE                      ; Save next block size for later 
1306			 
1306 60			      ld    H, B                    ; Load size of freed block into HL 
1307 69			      ld    L, C 
1308 23			      inc   HL 
1309 23			      inc   HL 
130a 5e			      ld    E, (HL) 
130b 23			      inc   HL 
130c 56			      ld    D, (HL) 
130d eb			      ex    DE, HL 
130e			 
130e d1			      pop   DE                      ; Restore size of next block 
130f 19			      add   HL, DE                  ; Add sizes of both blocks 
1310 eb			      ex    DE, HL 
1311			 
1311 60			      ld    H, B                    ; Store new bigger size into freed block 
1312 69			      ld    L, C 
1313 23			      inc   HL 
1314 23			      inc   HL 
1315 73			      ld    (HL), E 
1316 23			      inc   HL 
1317 72			      ld    (HL), D 
1318			 
1318			free_check_adjacent_to_prev: 
1318			      ; Check if the freed block is adjacent to the prev free block 
1318 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
131b dd 66 03		      ld    H, (IX+3) 
131e			 
131e 23			      inc   HL                      ; Size of prev free block into DE 
131f 23			      inc   HL 
1320 5e			      ld    E, (HL) 
1321 23			      inc   HL 
1322 56			      ld    D, (HL) 
1323 2b			      dec   HL 
1324 2b			      dec   HL 
1325 2b			      dec   HL 
1326			 
1326 19			      add   HL, DE                  ; Add prev block addr and size 
1327			 
1327 b7			      or    A                       ; Clear the carry flag 
1328 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132a 20 2e		      jr    NZ, free_done 
132c			 
132c			      ; Freed block is adjacent to prev, merge into one bigger block 
132c 60			      ld    H, B                    ; Load next ptr from freed block into DE 
132d 69			      ld    L, C 
132e 5e			      ld    E, (HL) 
132f 23			      inc   HL 
1330 56			      ld    D, (HL) 
1331 e5			      push  HL                      ; Save freed block ptr for later 
1332			 
1332 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1335 dd 66 03		      ld    H, (IX+3) 
1338 73			      ld    (HL), E 
1339 23			      inc   HL 
133a 72			      ld    (HL), D 
133b			 
133b e1			      pop   HL                      ; Restore freed block ptr 
133c 23			      inc   HL                      ; Load size of freed block into DE 
133d 5e			      ld    E, (HL) 
133e 23			      inc   HL 
133f 56			      ld    D, (HL) 
1340 d5			      push  DE                      ; Save freed block size for later 
1341			 
1341 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1344 dd 66 03		      ld    H, (IX+3) 
1347 23			      inc   HL 
1348 23			      inc   HL 
1349 5e			      ld    E, (HL) 
134a 23			      inc   HL 
134b 56			      ld    D, (HL) 
134c			 
134c e1			      pop   HL                      ; Add sizes of both blocks 
134d 19			      add   HL, DE 
134e eb			      ex    DE, HL 
134f			 
134f dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1352 dd 66 03		      ld    H, (IX+3) 
1355 23			      inc   HL 
1356 23			      inc   HL 
1357 73			      ld    (HL), E 
1358 23			      inc   HL 
1359 72			      ld    (HL), D 
135a			 
135a			free_done: 
135a 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
135d 39			      add   HL, SP 
135e f9			      ld    SP, HL 
135f			 
135f			free_early_exit: 
135f dd e1		      pop   IX 
1361 d1			      pop   DE 
1362 c1			      pop   BC 
1363			 
1363 c9			      ret 
1364			 
1364			; moved to firmware.asm 
1364			; 
1364			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1364			;                  .dw   0 
1364			 
1364			 
1364			endif 
1364			 
1364			 
1364			if MALLOC_3 
1364			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1364			;heap_start        .equ  0x9000      ; Starting address of heap 
1364			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1364			; 
1364			 ;     .org 0 
1364			  ;    jp    main 
1364			; 
1364			; 
1364			 ;     .org  0x100 
1364			;main: 
1364			 ;     ld    HL, 0x8100 
1364			  ;    ld    SP, HL 
1364			; 
1364			;      call  heap_init 
1364			 
1364			      ; Make some allocations 
1364			;      ld    HL, 12 
1364			;      call  malloc            ; Allocates 0x9004 
1364			; 
1364			 ;     ld    HL, 12 
1364			;      call  malloc            ; Allocates 0x9014 
1364			 
1364			;      ld    HL, 12 
1364			;      call  malloc            ; Allocates 0x9024 
1364			 
1364			      ; Free some allocations 
1364			;      ld    HL, 0x9014 
1364			;      call  free 
1364			 
1364			;      ld    HL, 0x9004 
1364			;      call  free 
1364			; 
1364			;      ld    HL, 0x9024 
1364			;      call  free 
1364			 
1364			 
1364			 ;     halt 
1364			 
1364			 
1364			;------------------------------------------------------------------------------ 
1364			;     heap_init                                                               : 
1364			;                                                                             : 
1364			; Description                                                                 : 
1364			;     Initialise the heap and make it ready for malloc and free operations.   : 
1364			;                                                                             : 
1364			;     The heap is maintained as a linked list, starting with an initial       : 
1364			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1364			;     the first free block in the heap. Each block then points to the next    : 
1364			;     free block within the heap, and the free list ends at the first block   : 
1364			;     with a null pointer to the next free block.                             : 
1364			;                                                                             : 
1364			; Parameters                                                                  : 
1364			;     Inputs are compile-time only. Two defines which specify the starting    : 
1364			;     address of the heap and its size are required, along with a memory      : 
1364			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1364			;     principally stores a pointer to the first free block in the heap.       : 
1364			;                                                                             : 
1364			; Returns                                                                     : 
1364			;     Nothing                                                                 : 
1364			;------------------------------------------------------------------------------ 
1364			heap_init: 
1364			      push  HL 
1364			 
1364			      ; Initialise free list struct 
1364			      ld    HL, heap_start 
1364			      ld    (free_list), HL 
1364			      ld    HL, 0 
1364			      ld    (free_list+2), HL 
1364			 
1364			      ; Insert first free block at bottom of heap, consumes entire heap 
1364			      ld    HL, heap_start+heap_size-4 
1364			      ld    (heap_start), HL        ; Next block (end of free list) 
1364			      ld    HL, heap_size-4 
1364			      ld    (heap_start+2), HL      ; Block size 
1364			 
1364			      ; Insert end of free list block at top of heap - two null words will 
1364			      ; terminate the free list 
1364			      ld    HL, 0 
1364			      ld    (heap_start+heap_size-2), HL 
1364			      ld    (heap_start+heap_size-4), HL 
1364			 
1364			      pop   HL 
1364			 
1364			      ret 
1364			 
1364			 
1364			;------------------------------------------------------------------------------ 
1364			;     malloc                                                                  : 
1364			;                                                                             : 
1364			; Description                                                                 : 
1364			;     Allocates the wanted space from the heap and returns the address of the : 
1364			;     first useable byte of the allocation.                                   : 
1364			;                                                                             : 
1364			;     Allocations can happen in one of two ways:                              : 
1364			;                                                                             : 
1364			;     1. A free block may be found which is the exact size wanted. In this    : 
1364			;        case the block is removed from the free list and retuedn to the      : 
1364			;        caller.                                                              : 
1364			;     2. A free block may be found which is larger than the size wanted. In   : 
1364			;        this case, the larger block is split into two. The first portion of  : 
1364			;        this block will become the requested space by the malloc call and    : 
1364			;        is returned to the caller. The second portion becomes a new free     : 
1364			;        block, and the free list is adjusted to maintain continuity via this : 
1364			;        newly created block.                                                 : 
1364			;                                                                             : 
1364			;     malloc does not set any initial value in the allocated space, the       : 
1364			;     caller is required to do this as required.                              : 
1364			;                                                                             : 
1364			;     This implementation of malloc uses the stack exclusively, and is        : 
1364			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1364			;     advisable to disable interrupts before calling malloc, and recommended  : 
1364			;     to avoid the use of malloc inside ISRs in general.                      : 
1364			;                                                                             : 
1364			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1364			;                                                                             : 
1364			; Parameters                                                                  : 
1364			;     HL  Number of bytes wanted                                              : 
1364			;                                                                             : 
1364			; Returns                                                                     : 
1364			;     HL  Address of the first useable byte of the allocation                 : 
1364			;                                                                             : 
1364			; Flags                                                                       : 
1364			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1364			;                                                                             : 
1364			; Stack frame                                                                 : 
1364			;       |             |                                                       : 
1364			;       +-------------+                                                       : 
1364			;       |     BC      |                                                       : 
1364			;       +-------------+                                                       : 
1364			;       |     DE      |                                                       : 
1364			;       +-------------+                                                       : 
1364			;       |     IX      |                                                       : 
1364			;       +-------------+                                                       : 
1364			;       |  prev_free  |                                                       : 
1364			;   +4  +-------------+                                                       : 
1364			;       |  this_free  |                                                       : 
1364			;   +2  +-------------+                                                       : 
1364			;       |  next_free  |                                                       : 
1364			;   +0  +-------------+                                                       : 
1364			;       |             |                                                       : 
1364			;                                                                             : 
1364			;------------------------------------------------------------------------------ 
1364			malloc: 
1364			      push  BC 
1364			      push  DE 
1364			      push  IX 
1364			 
1364			      ld    A, H                    ; Exit if no space requested 
1364			      or    L 
1364			      jp    Z, malloc_early_exit 
1364			 
1364			      ; Set up stack frame 
1364			      ex    DE, HL 
1364			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1364			      add   HL, SP 
1364			      ld    SP, HL 
1364			      ld    IX, 0                   ; Use IX as a frame pointer 
1364			      add   IX, SP 
1364			 
1364			      ; Setup initial state 
1364			      ld    HL, 4                   ; want must also include space used by block struct 
1364			      add   HL, DE 
1364			 
1364			      ld    B, H                    ; Move want to BC 
1364			      ld    C, L 
1364			 
1364			      ld    HL, free_list           ; Store prev_free ptr to stack 
1364			      ld    (IX+4), L 
1364			      ld    (IX+5), H 
1364			 
1364			      ld    E, (HL)                 ; Store this_free ptr to stack 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			      ld    (IX+2), E 
1364			      ld    (IX+3), D 
1364			      ex    DE, HL                  ; this_free ptr into HL 
1364			 
1364			      ; Loop through free block list to find some space 
1364			malloc_find_space: 
1364			      ld    E, (HL)                 ; Load next_free ptr into DE 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			 
1364			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1364			      or    E 
1364			      jp    Z, malloc_no_space 
1364			 
1364			      ld    (IX+0), E               ; Store next_free ptr to stack 
1364			      ld    (IX+1), D 
1364			 
1364			      ; Does this block have enough space to make the allocation? 
1364			      inc   HL                      ; Load free block size into DE 
1364			      ld    E, (HL) 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			 
1364			      ex    DE, HL                  ; Check size of block against want 
1364			      or    A                       ; Ensure carry flag clear 
1364			      sbc   HL, BC 
1364			      push  HL                      ; Store the result for later (new block size) 
1364			 
1364			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1364			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1364			 
1364			      ; this_free block is not big enough, setup ptrs to test next free block 
1364			      pop   HL                      ; Discard previous result 
1364			 
1364			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1364			      ld    H, (IX+3) 
1364			      ld    (IX+4), L 
1364			      ld    (IX+5), H 
1364			 
1364			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1364			      ld    H, (IX+1) 
1364			      ld    (IX+2), L 
1364			      ld    (IX+3), H 
1364			 
1364			      jr    malloc_find_space 
1364			 
1364			      ; split a bigger block into two - requested size and remaining size 
1364			malloc_alloc_split: 
1364			      ex    DE, HL                  ; Calculate address of new free block 
1364			      dec   HL 
1364			      dec   HL 
1364			      dec   HL 
1364			      add   HL, BC 
1364			 
1364			      ; Create a new block and point it at next_free 
1364			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1364			      ld    D, (IX+1) 
1364			 
1364			      ld    (HL), E                 ; Store next_free ptr into new block 
1364			      inc   HL 
1364			      ld    (HL), D 
1364			 
1364			      pop   DE                      ; Store size of new block into new block 
1364			      inc   HL 
1364			      ld    (HL), E 
1364			      inc   HL 
1364			      ld    (HL), D 
1364			 
1364			      ; Update this_free ptr to point to new block 
1364			      dec   HL 
1364			      dec   HL 
1364			      dec   HL 
1364			 
1364			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1364			      ld    D, (IX+3) 
1364			 
1364			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1364			      ld    (IX+3), H 
1364			 
1364			      ; Modify this_free block to be allocation 
1364			      ex    DE, HL 
1364			      xor   A                       ; Null the next block ptr of allocated block 
1364			      ld    (HL), A 
1364			      inc   HL 
1364			      ld    (HL), A 
1364			 
1364			      inc   HL                      ; Store want size into allocated block 
1364			      ld    (HL), C 
1364			      inc   HL 
1364			      ld    (HL), B 
1364			      inc   HL 
1364			      push  HL                      ; Address of allocation to return 
1364			 
1364			      jr    malloc_update_links 
1364			 
1364			malloc_alloc_fit: 
1364			      pop   HL                      ; Dont need new block size, want is exact fit 
1364			 
1364			      ; Modify this_free block to be allocation 
1364			      ex    DE, HL 
1364			      dec   HL 
1364			      dec   HL 
1364			      dec   HL 
1364			 
1364			      xor   A                       ; Null the next block ptr of allocated block 
1364			      ld    (HL), A 
1364			      inc   HL 
1364			      ld    (HL), A 
1364			 
1364			      inc   HL                      ; Store address of allocation to return 
1364			      inc   HL 
1364			      inc   HL 
1364			      push  HL 
1364			 
1364			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1364			      ld    L, (IX+0)               ; next_free to HL 
1364			      ld    H, (IX+1) 
1364			 
1364			      ld    (IX+2), L               ; HL to this_free 
1364			      ld    (IX+3), H 
1364			 
1364			 
1364			malloc_update_links: 
1364			      ; Update prev_free ptr to point to this_free 
1364			      ld    L, (IX+4)               ; prev_free ptr to HL 
1364			      ld    H, (IX+5) 
1364			 
1364			      ld    E, (IX+2)               ; this_free ptr to DE 
1364			      ld    D, (IX+3) 
1364			 
1364			      ld    (HL), E                 ; this_free ptr into prev_free 
1364			      inc   HL 
1364			      ld    (HL), D 
1364			 
1364			      ; Clear the Z flag to indicate successful allocation 
1364			      ld    A, D 
1364			      or    E 
1364			 
1364			      pop   DE                      ; Address of allocation 
1364			 
1364			malloc_no_space: 
1364			      ld    HL, 6                   ; Clean up stack frame 
1364			      add   HL, SP 
1364			      ld    SP, HL 
1364			 
1364			      ex    DE, HL                  ; Alloc addr into HL for return 
1364			 
1364			malloc_early_exit: 
1364			      pop   IX 
1364			      pop   DE 
1364			      pop   BC 
1364			 
1364			      ret 
1364			 
1364			 
1364			;------------------------------------------------------------------------------ 
1364			;     free                                                                    : 
1364			;                                                                             : 
1364			; Description                                                                 : 
1364			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1364			;     returned by malloc, otherwise the behaviour is undefined.               : 
1364			;                                                                             : 
1364			;     Where possible, directly adjacent free blocks will be merged together   : 
1364			;     into larger blocks to help ensure that the heap does not become         : 
1364			;     excessively fragmented.                                                 : 
1364			;                                                                             : 
1364			;     free does not clear or set any other value into the freed space, and    : 
1364			;     therefore its contents may be visible through subsequent malloc's. The  : 
1364			;     caller should clear the freed space as required.                        : 
1364			;                                                                             : 
1364			;     This implementation of free uses the stack exclusively, and is          : 
1364			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1364			;     advisable to disable interrupts before calling free, and recommended    : 
1364			;     to avoid the use of free inside ISRs in general.                        : 
1364			;                                                                             : 
1364			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1364			;                                                                             : 
1364			; Parameters                                                                  : 
1364			;     HL  Pointer to address of first byte of allocation to be freed          : 
1364			;                                                                             : 
1364			; Returns                                                                     : 
1364			;     Nothing                                                                 : 
1364			;                                                                             : 
1364			; Stack frame                                                                 : 
1364			;       |             |                                                       : 
1364			;       +-------------+                                                       : 
1364			;       |     BC      |                                                       : 
1364			;       +-------------+                                                       : 
1364			;       |     DE      |                                                       : 
1364			;       +-------------+                                                       : 
1364			;       |     IX      |                                                       : 
1364			;       +-------------+                                                       : 
1364			;       |  prev_free  |                                                       : 
1364			;   +2  +-------------+                                                       : 
1364			;       |  next_free  |                                                       : 
1364			;   +0  +-------------+                                                       : 
1364			;       |             |                                                       : 
1364			;                                                                             : 
1364			;------------------------------------------------------------------------------ 
1364			free: 
1364			      push  BC 
1364			      push  DE 
1364			      push  IX 
1364			 
1364			      ld    A, H                    ; Exit if ptr is null 
1364			      or    L 
1364			      jp    Z, free_early_exit 
1364			 
1364			      ; Set up stack frame 
1364			      ex    DE, HL 
1364			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1364			      add   HL, SP 
1364			      ld    SP, HL 
1364			      ld    IX, 0                   ; Use IX as a frame pointer 
1364			      add   IX, SP 
1364			 
1364			      ; The address in HL points to the start of the useable allocated space, 
1364			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1364			      ; address of the block itself. 
1364			      ex    DE, HL 
1364			      ld    DE, -4 
1364			      add   HL, DE 
1364			 
1364			      ; An allocated block must have a null next block pointer in it 
1364			      ld    A, (HL) 
1364			      inc   HL 
1364			      or    (HL) 
1364			      jp    NZ, free_done 
1364			 
1364			      dec   HL 
1364			 
1364			      ld    B, H                    ; Copy HL to BC 
1364			      ld    C, L 
1364			 
1364			      ; Loop through the free list to find the first block with an address 
1364			      ; higher than the block being freed 
1364			      ld    HL, free_list 
1364			 
1364			free_find_higher_block: 
1364			      ld    E, (HL)                 ; Load next ptr from free block 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			      dec   HL 
1364			 
1364			      ld    (IX+0), E               ; Save ptr to next free block 
1364			      ld    (IX+1), D 
1364			      ld    (IX+2), L               ; Save ptr to prev free block 
1364			      ld    (IX+3), H 
1364			 
1364			      ld    A, B                    ; Check if DE is greater than BC 
1364			      cp    D                       ; Compare MSB first 
1364			      jr    Z, $+4                  ; MSB the same, compare LSB 
1364			      jr    NC, free_find_higher_block_skip 
1364			      ld    A, C 
1364			      cp    E                       ; Then compare LSB 
1364			      jr    C, free_found_higher_block 
1364			 
1364			free_find_higher_block_skip: 
1364			      ld    A, D                    ; Reached the end of the free list? 
1364			      or    E 
1364			      jp    Z, free_done 
1364			 
1364			      ex    DE, HL 
1364			 
1364			      jr    free_find_higher_block 
1364			 
1364			free_found_higher_block: 
1364			      ; Insert freed block between prev and next free blocks 
1364			      ld    (HL), C                 ; Point prev free block to freed block 
1364			      inc   HL 
1364			      ld    (HL), B 
1364			 
1364			      ld    H, B                    ; Point freed block at next free block 
1364			      ld    L, C 
1364			      ld    (HL), E 
1364			      inc   HL 
1364			      ld    (HL), D 
1364			 
1364			      ; Check if the freed block is adjacent to the next free block 
1364			      inc   HL                      ; Load size of freed block into HL 
1364			      ld    E, (HL) 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			      ex    DE, HL 
1364			 
1364			      add   HL, BC                  ; Add addr of freed block and its size 
1364			 
1364			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1364			      ld    D, (IX+1) 
1364			 
1364			      or    A                       ; Clear the carry flag 
1364			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1364			      jr    NZ, free_check_adjacent_to_prev 
1364			 
1364			      ; Freed block is adjacent to next, merge into one bigger block 
1364			      ex    DE, HL                  ; Load next ptr from next block into DE 
1364			      ld    E, (HL) 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			      push  HL                      ; Save ptr to next block for later 
1364			 
1364			      ld    H, B                    ; Store ptr from next block into freed block 
1364			      ld    L, C 
1364			      ld    (HL), E 
1364			      inc   HL 
1364			      ld    (HL), D 
1364			 
1364			      pop   HL                      ; Restore ptr to next block 
1364			      inc   HL                      ; Load size of next block into DE 
1364			      ld    E, (HL) 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			      push  DE                      ; Save next block size for later 
1364			 
1364			      ld    H, B                    ; Load size of freed block into HL 
1364			      ld    L, C 
1364			      inc   HL 
1364			      inc   HL 
1364			      ld    E, (HL) 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			      ex    DE, HL 
1364			 
1364			      pop   DE                      ; Restore size of next block 
1364			      add   HL, DE                  ; Add sizes of both blocks 
1364			      ex    DE, HL 
1364			 
1364			      ld    H, B                    ; Store new bigger size into freed block 
1364			      ld    L, C 
1364			      inc   HL 
1364			      inc   HL 
1364			      ld    (HL), E 
1364			      inc   HL 
1364			      ld    (HL), D 
1364			 
1364			free_check_adjacent_to_prev: 
1364			      ; Check if the freed block is adjacent to the prev free block 
1364			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1364			      ld    H, (IX+3) 
1364			 
1364			      inc   HL                      ; Size of prev free block into DE 
1364			      inc   HL 
1364			      ld    E, (HL) 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			      dec   HL 
1364			      dec   HL 
1364			      dec   HL 
1364			 
1364			      add   HL, DE                  ; Add prev block addr and size 
1364			 
1364			      or    A                       ; Clear the carry flag 
1364			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1364			      jr    NZ, free_done 
1364			 
1364			      ; Freed block is adjacent to prev, merge into one bigger block 
1364			      ld    H, B                    ; Load next ptr from freed block into DE 
1364			      ld    L, C 
1364			      ld    E, (HL) 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			      push  HL                      ; Save freed block ptr for later 
1364			 
1364			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1364			      ld    H, (IX+3) 
1364			      ld    (HL), E 
1364			      inc   HL 
1364			      ld    (HL), D 
1364			 
1364			      pop   HL                      ; Restore freed block ptr 
1364			      inc   HL                      ; Load size of freed block into DE 
1364			      ld    E, (HL) 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			      push  DE                      ; Save freed block size for later 
1364			 
1364			      ld    L, (IX+2)               ; Load size of prev block into DE 
1364			      ld    H, (IX+3) 
1364			      inc   HL 
1364			      inc   HL 
1364			      ld    E, (HL) 
1364			      inc   HL 
1364			      ld    D, (HL) 
1364			 
1364			      pop   HL                      ; Add sizes of both blocks 
1364			      add   HL, DE 
1364			      ex    DE, HL 
1364			 
1364			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1364			      ld    H, (IX+3) 
1364			      inc   HL 
1364			      inc   HL 
1364			      ld    (HL), E 
1364			      inc   HL 
1364			      ld    (HL), D 
1364			 
1364			free_done: 
1364			      ld    HL, 4                   ; Clean up stack frame 
1364			      add   HL, SP 
1364			      ld    SP, HL 
1364			 
1364			free_early_exit: 
1364			      pop   IX 
1364			      pop   DE 
1364			      pop   BC 
1364			 
1364			      ret 
1364			 
1364			 
1364			;      .org 0x8000 
1364			; 
1364			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1364			 ;                 .dw   0 
1364			 
1364			endif 
1364			 
1364			 
1364			if MALLOC_4 
1364			 
1364			; My memory allocation code. Very very simple.... 
1364			; allocate space under 250 chars 
1364			 
1364			heap_init: 
1364				; init start of heap as zero 
1364				;  
1364			 
1364				ld hl, heap_start 
1364				ld a, 0 
1364				ld (hl), a      ; empty block 
1364				inc hl 
1364				ld a, 0 
1364				ld (hl), a      ; length of block 
1364				; write end of list 
1364				inc hl 
1364				ld a,(hl) 
1364				inc hl 
1364				ld a,(hl) 
1364				 
1364			 
1364				; init some malloc vars 
1364			 
1364				ld hl, 0 
1364				ld (free_list), hl       ; store last malloc location 
1364			 
1364				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1364				ld a, 0 
1364				ld (hl), a 
1364			 
1364			 
1364				ld hl, heap_start 
1364				;  
1364				  
1364				ret 
1364			 
1364			 
1364			;    free block marker 
1364			;    requested size  
1364			;    pointer to next block 
1364			;    .... 
1364			;    next block marker 
1364			 
1364			 
1364			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1364			; 
1364			 
1364			 
1364			malloc:  
1364				push de 
1364				push bc 
1364				push af 
1364			 
1364				; hl space required 
1364				 
1364				ld c, l    ; hold space   (TODO only a max of 255) 
1364			 
1364			;	inc c     ; TODO BUG need to fix memory leak on push str 
1364			;	inc c 
1364			;	inc c 
1364			;	inc c 
1364			;	inc c 
1364			;	inc c 
1364			;	inc c 
1364			 
1364			 
1364			 
1364				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1364			 
1364				ld a, (free_list+3) 
1364				cp 0 
1364				jr z, .contheap 
1364			 
1364				ld hl, (free_list)     ; get last alloc 
1364					if DEBUG_FORTH_MALLOC_INT 
1364						DMARK "mrs" 
1364						CALLMONITOR 
1364					endif 
1364				jr .startalloc 
1364			 
1364			.contheap: 
1364				ld hl, heap_start 
1364			 
1364			.startalloc: 
1364			 
1364					if DEBUG_FORTH_MALLOC_INT 
1364						DMARK "mym" 
1364						CALLMONITOR 
1364					endif 
1364			.findblock: 
1364					if DEBUG_FORTH_MALLOC_INT 
1364						DMARK "mmf" 
1364						CALLMONITOR 
1364					endif 
1364			 
1364				ld a,(hl)  
1364				; if byte is zero then clear to use 
1364			 
1364				cp 0 
1364				jr z, .foundemptyblock 
1364			 
1364				; if byte is not clear 
1364				;     then byte is offset to next block 
1364			 
1364				inc hl 
1364				ld a, (hl) ; get size 
1364			.nextblock:	inc hl 
1364					ld e, (hl) 
1364					inc hl 
1364					ld d, (hl) 
1364					ex de, hl 
1364			;	inc hl  ; move past the store space 
1364			;	inc hl  ; move past zero index  
1364			 
1364				; TODO detect no more space 
1364			 
1364				push hl 
1364				ld de, heap_end 
1364				call cmp16 
1364				pop hl 
1364				jr nc, .nospace 
1364			 
1364				jr .findblock 
1364			 
1364			.nospace: ld hl, 0 
1364				jp .exit 
1364			 
1364			 
1364			.foundemptyblock:	 
1364					if DEBUG_FORTH_MALLOC_INT 
1364						DMARK "mme" 
1364						CALLMONITOR 
1364					endif 
1364			 
1364			; TODO has block enough space if reusing??? 
1364			 
1364				;  
1364			 
1364			; see if this block has been previously used 
1364				inc hl 
1364				ld a, (hl) 
1364				dec hl 
1364				cp 0 
1364				jr z, .newblock 
1364			 
1364					if DEBUG_FORTH_MALLOC_INT 
1364						DMARK "meR" 
1364						CALLMONITOR 
1364					endif 
1364			 
1364			; no reusing previously allocated block 
1364			 
1364			; is it smaller than previously used? 
1364				 
1364				inc hl    ; move to size 
1364				ld a, c 
1364				sub (hl)        ; we want c < (hl) 
1364				dec hl    ; move back to marker 
1364			        jr z, .findblock 
1364			 
1364				; update with the new size which should be lower 
1364			 
1364			        ;inc  hl   ; negate next move. move back to size  
1364			 
1364			.newblock: 
1364				; need to be at marker here 
1364			 
1364					if DEBUG_FORTH_MALLOC_INT 
1364						DMARK "meN" 
1364						CALLMONITOR 
1364					endif 
1364			 
1364			 
1364				ld a, c 
1364			 
1364				ld (free_list+3), a	 ; flag resume from last malloc  
1364				ld (free_list), hl    ; save out last location 
1364			 
1364			 
1364				;inc a     ; space for length byte 
1364				ld (hl), a     ; save block in use marker 
1364			 
1364				inc hl   ; move to space marker 
1364				ld (hl), a    ; save new space 
1364			 
1364				inc hl   ; move to start of allocated area 
1364				 
1364			;	push hl     ; save where we are - 1  
1364			 
1364			;	inc hl  ; move past zero index  
1364				; skip space to set down new marker 
1364			 
1364				; provide some extra space for now 
1364			 
1364				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1364				inc a 
1364				inc a 
1364			 
1364				push hl   ; save where we are in the node block 
1364			 
1364				call addatohl 
1364			 
1364				; write linked list point 
1364			 
1364				pop de     ; get our node position 
1364				ex de, hl 
1364			 
1364				ld (hl), e 
1364				inc hl 
1364				ld (hl), d 
1364			 
1364				inc hl 
1364			 
1364				; now at start of allocated data so save pointer 
1364			 
1364				push hl 
1364			 
1364				; jump to position of next node and setup empty header in DE 
1364			 
1364				ex de, hl 
1364			 
1364			;	inc hl ; move past end of block 
1364			 
1364				ld a, 0 
1364				ld (hl), a   ; empty marker 
1364				inc hl 
1364				ld (hl), a   ; size 
1364				inc hl  
1364				ld (hl), a   ; ptr 
1364				inc hl 
1364				ld (hl), a   ; ptr 
1364			 
1364			 
1364				pop hl 
1364			 
1364					if DEBUG_FORTH_MALLOC_INT 
1364						DMARK "mmr" 
1364						CALLMONITOR 
1364					endif 
1364			 
1364			.exit: 
1364				pop af 
1364				pop bc 
1364				pop de  
1364				ret 
1364			 
1364			 
1364			 
1364			 
1364			free:  
1364				push hl 
1364				push af 
1364				; get address in hl 
1364			 
1364					if DEBUG_FORTH_MALLOC_INT 
1364						DMARK "fre" 
1364						CALLMONITOR 
1364					endif 
1364				; data is at hl - move to block count 
1364				dec hl 
1364				dec hl    ; get past pointer 
1364				dec hl 
1364			 
1364				ld a, (hl)    ; need this for a validation check 
1364			 
1364				dec hl    ; move to block marker 
1364			 
1364				; now check that the block count and block marker are the same  
1364			        ; this checks that we are on a malloc node and not random memory 
1364			        ; OK a faint chance this could be a problem but rare - famous last words! 
1364			 
1364				ld c, a 
1364				ld a, (hl)    
1364			 
1364				cp c 
1364				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1364			 
1364				; yes good chance we are on a malloc node 
1364			 
1364				ld a, 0      
1364				ld (hl), a   ; mark as free 
1364			 
1364				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1364			 
1364			.freeignore:  
1364			 
1364				pop af 
1364				pop hl 
1364			 
1364				ret 
1364			 
1364			 
1364			 
1364			endif 
1364			 
1364			; eof 
# End of file firmware_memory.asm
1364			  
1364			; device C  
1364			if SOUND_ENABLE  
1364				include "firmware_sound.asm"  
1364			; Sound abstraction layer 
1364			 
1364			; support different sound chips through common interface 
1364			 
1364			SOUND_DEVICE_AY: equ 0 
1364			 
1364			SOUND_DEVICE: equ Device_A 
1364			 
1364			 
1364			 
1364			if SOUND_DEVICE_AY 
1364				include "firmware_sound_ay38910.asm" 
1364			else 
1364				include "firmware_sound_sn76489an.asm" 
1364			 
1364			; Device support for SN76489AN sound chip 
1364			 
1364			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1364			; http://danceswithferrets.org/geekblog/?p=93 
1364			; https://www.smspower.org/Development/SN76489 
1364			 
1364			; D0 [ 3] 
1364			; D1 [ 2] 
1364			; D2 [ 1] 
1364			; D3 [15] 
1364			; D4 [13] 
1364			; D5 [12] 
1364			; D6 [11] 
1364			; D7 [10] 
1364			; /WE [ 5] 
1364			; CLK [14] 
1364			; /OE [ 6] 
1364			; AUDIO [ 7] 
1364			; GND 8 
1364			; +5 16 
1364			; 
1364			 
1364			; Write sequence: 
1364			; CE low 
1364			; Data bus 
1364			; WE low then high 
1364			; 32 clock cycles / 8ns write time at 4mhz 
1364			; 
1364			; https://github.com/jblang/SN76489 
1364			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1364			; Tried: 
1364			; 
1364			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1364			; 
1364			; Connected WE to OR too 
1364			;  
1364			; That enabled the clock when required 
1364			; However still random bus corruption. Need further investigation 
1364			 
1364			 
1364			SOUND_LATCH: equ 10000000B 
1364			SOUND_DATA: equ 0B 
1364			SOUND_CH0:  equ 0B    ; Tone 
1364			SOUND_CH1: equ 0100000B        ; Tone 
1364			SOUND_CH2: equ 1000000B   ; Tone 
1364			SOUND_CH3: equ 1100000B    ; Noise 
1364			SOUND_VOL: equ 10000B 
1364			SOUND_TONE: equ 0B 
1364			 
1364			 
1364			sound_init: 
1364 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
1366 cd 7b 13			call note_send_byte 
1369 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
136b cd 7b 13			call note_send_byte 
136e cd 41 0a			call delay250ms 
1371 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1373 cd 7b 13			call note_send_byte 
1376 cd 41 0a			call delay250ms 
1379 c9				ret 
137a			 
137a			; Play a note 
137a			; h = note 
137a			; l = duration 
137a			; a = channel 
137a			 
137a			 
137a			;  frequ = clock / ( 2 x reg valu x 32 )  
137a			 
137a			note:  
137a				 
137a			 
137a c9				ret 
137b			 
137b			note_send_byte: 
137b				; byte in a 
137b			 
137b				; we high 
137b d3 40			out (Device_B), a 
137d			;	ld a, 1 
137d			;	call aDelayInMS 
137d 00				nop  
137e 00				nop  
137f 00				nop  
1380 00				nop  
1381				; we low 
1381 d3 40			out (Device_B), a 
1383			;	ld a, 1 
1383			;	call aDelayInMS 
1383 00				nop  
1384 00				nop  
1385 00				nop  
1386 00				nop  
1387				; we high 
1387 d3 40			out (Device_B), a 
1389			;	ld a, 1 
1389			;	call aDelayInMS 
1389 00				nop  
138a 00				nop  
138b 00				nop  
138c 00				nop  
138d			 
138d			 
138d c9				ret 
138e			 
138e			;void SilenceAllChannels() 
138e			;{ 
138e			;  SendByte(0x9f); 
138e			;  SendByte(0xbf); 
138e			;  SendByte(0xdf); 
138e			;  SendByte(0xff); 
138e			;} 
138e			 
138e			 
138e			; eof 
138e			 
# End of file firmware_sound_sn76489an.asm
138e			endif 
138e			 
138e			 
138e			; Abstraction entry points 
138e			 
138e			; init  
138e			 
138e			; sound_init in specific hardware files 
138e			 
138e			; Play a note 
138e			; h = note 
138e			; l = duration 
138e			; a = channel 
138e			 
138e			;note:     
138e			;	ret 
138e			 
138e			 
138e			 
138e			 
138e			; eof 
138e			 
# End of file firmware_sound.asm
138e			endif  
138e			  
138e			include "firmware_diags.asm"  
138e			; Hardware diags menu 
138e			 
138e			 
138e			config: 
138e			 
138e 3e 00			ld a, 0 
1390 21 be 13			ld hl, .configmn 
1393 cd 01 0b			call menu 
1396			 
1396 fe 00			cp 0 
1398 c8				ret z 
1399			 
1399 fe 01			cp 1 
139b cc 97 14			call z, .savetostore 
139e			 
139e fe 02			cp 2 
13a0 cc e5 13			call z, .selautoload 
13a3 fe 03			cp 3 
13a5 cc ce 13			call z, .disautoload 
13a8 fe 04			cp 4 
13aa cc 95 14			call z, .selbank 
13ad fe 05			cp 5 
13af cc 72 15			call z, .debug_tog 
13b2 fe 06			cp 6 
13b4 cc b5 16			call z, .bpsgo 
13b7 fe 07			cp 7 
13b9 cc 98 15			call z, hardware_diags 
13bc			 
13bc 18 d0			jr config 
13be			 
13be			.configmn: 
13be a6 18			dw prom_c3 
13c0 bd 18			dw prom_c2 
13c2 d2 18			dw prom_c2a 
13c4 e8 18			dw prom_c2b 
13c6			;	dw prom_c4 
13c6 05 19			dw prom_m4 
13c8 20 19			dw prom_m4b 
13ca 28 19			dw prom_c1 
13cc 00 00			dw 0 
13ce				 
13ce			 
13ce			 
13ce			 
13ce			.disautoload: 
13ce				if STORAGE_SE 
13ce 3e fe			ld a, $fe      ; bit 0 clear 
13d0 32 3f f8			ld (spi_device), a 
13d3			 
13d3 cd 93 03			call storage_get_block_0 
13d6			 
13d6 3e 00			ld a, 0 
13d8 32 7a f8			ld (store_page+STORE_0_AUTOFILE), a 
13db			 
13db 21 00 00				ld hl, 0 
13de 11 59 f8				ld de, store_page 
13e1 cd 47 03			call storage_write_block	 ; save update 
13e4				else 
13e4			 
13e4				ld hl, prom_notav 
13e4				ld de, prom_empty 
13e4				call info_panel 
13e4				endif 
13e4			 
13e4			 
13e4 c9				ret 
13e5			 
13e5			 
13e5			 
13e5			; Select auto start 
13e5			 
13e5			.selautoload: 
13e5			 
13e5				 
13e5				if STORAGE_SE 
13e5			 
13e5 cd bc 14				call config_dir 
13e8 21 14 ee			        ld hl, scratch 
13eb 3e 00				ld a, 0 
13ed cd 01 0b				call menu 
13f0			 
13f0 fe 00				cp 0 
13f2 c8					ret z 
13f3			 
13f3 3d					dec a 
13f4			 
13f4			 
13f4					; locate menu option 
13f4			 
13f4 21 14 ee				ld hl, scratch 
13f7 cd 25 0a				call table_lookup 
13fa			 
13fa					if DEBUG_FORTH_WORDS 
13fa						DMARK "ALl" 
13fa f5				push af  
13fb 3a 0f 14			ld a, (.dmark)  
13fe 32 6e fb			ld (debug_mark),a  
1401 3a 10 14			ld a, (.dmark+1)  
1404 32 6f fb			ld (debug_mark+1),a  
1407 3a 11 14			ld a, (.dmark+2)  
140a 32 70 fb			ld (debug_mark+2),a  
140d 18 03			jr .pastdmark  
140f ..			.dmark: db "ALl"  
1412 f1			.pastdmark: pop af  
1413			endm  
# End of macro DMARK
1413						CALLMONITOR 
1413 cd ab 16			call break_point_state  
1416				endm  
# End of macro CALLMONITOR
1416					endif 
1416					; with the pointer to the menu it, the byte following the zero term is the file id 
1416			 
1416 3e 00				ld a, 0 
1418 01 32 00				ld bc, 50   ; max of bytes to look at 
141b ed b1				cpir  
141d			 
141d					if DEBUG_FORTH_WORDS 
141d						DMARK "ALb" 
141d f5				push af  
141e 3a 32 14			ld a, (.dmark)  
1421 32 6e fb			ld (debug_mark),a  
1424 3a 33 14			ld a, (.dmark+1)  
1427 32 6f fb			ld (debug_mark+1),a  
142a 3a 34 14			ld a, (.dmark+2)  
142d 32 70 fb			ld (debug_mark+2),a  
1430 18 03			jr .pastdmark  
1432 ..			.dmark: db "ALb"  
1435 f1			.pastdmark: pop af  
1436			endm  
# End of macro DMARK
1436						CALLMONITOR 
1436 cd ab 16			call break_point_state  
1439				endm  
# End of macro CALLMONITOR
1439					endif 
1439					;inc hl 
1439			 
1439 7e					ld a, (hl)   ; file id 
143a					 
143a				        ; save bank and file ids 
143a			 
143a f5					push af 
143b			 
143b			; TODO need to save to block 0 on bank 1	 
143b			 
143b cd 93 03				call storage_get_block_0 
143e			 
143e					if DEBUG_FORTH_WORDS 
143e						DMARK "AL0" 
143e f5				push af  
143f 3a 53 14			ld a, (.dmark)  
1442 32 6e fb			ld (debug_mark),a  
1445 3a 54 14			ld a, (.dmark+1)  
1448 32 6f fb			ld (debug_mark+1),a  
144b 3a 55 14			ld a, (.dmark+2)  
144e 32 70 fb			ld (debug_mark+2),a  
1451 18 03			jr .pastdmark  
1453 ..			.dmark: db "AL0"  
1456 f1			.pastdmark: pop af  
1457			endm  
# End of macro DMARK
1457						CALLMONITOR 
1457 cd ab 16			call break_point_state  
145a				endm  
# End of macro CALLMONITOR
145a					endif 
145a f1					pop af 
145b			 
145b 32 7d f8				ld (store_page+STORE_0_FILERUN),a 
145e					 
145e					; save bank id 
145e			 
145e 3a 3f f8				ld a,(spi_device) 
1461 32 7c f8				ld (store_page+STORE_0_BANKRUN),a 
1464			 
1464					; enable auto run of store file 
1464			 
1464 3e 01				ld a, 1 
1466 32 7a f8				ld (store_page+STORE_0_AUTOFILE),a 
1469			 
1469					; save buffer 
1469			 
1469 21 00 00				ld hl, 0 
146c 11 59 f8				ld de, store_page 
146f					if DEBUG_FORTH_WORDS 
146f						DMARK "ALw" 
146f f5				push af  
1470 3a 84 14			ld a, (.dmark)  
1473 32 6e fb			ld (debug_mark),a  
1476 3a 85 14			ld a, (.dmark+1)  
1479 32 6f fb			ld (debug_mark+1),a  
147c 3a 86 14			ld a, (.dmark+2)  
147f 32 70 fb			ld (debug_mark+2),a  
1482 18 03			jr .pastdmark  
1484 ..			.dmark: db "ALw"  
1487 f1			.pastdmark: pop af  
1488			endm  
# End of macro DMARK
1488						CALLMONITOR 
1488 cd ab 16			call break_point_state  
148b				endm  
# End of macro CALLMONITOR
148b					endif 
148b cd 47 03			call storage_write_block	 ; save update 
148e			  
148e			 
148e			 
148e			 
148e 21 14 ee				ld hl, scratch 
1491 cd a9 14				call config_fdir 
1494			 
1494				else 
1494			 
1494				ld hl, prom_notav 
1494				ld de, prom_empty 
1494				call info_panel 
1494			 
1494				endif 
1494 c9				ret 
1495			 
1495			 
1495			 
1495			; Select storage bank 
1495			 
1495			.selbank: 
1495			 
1495				if STORAGE_SE 
1495				else 
1495			 
1495				ld hl, prom_notav 
1495				ld de, prom_empty 
1495				call info_panel 
1495				endif 
1495				 
1495 c9				ret 
1496			 
1496			if STORAGE_SE 
1496			 
1496			.config_ldir:   
1496				; Load storage bank labels into menu array 
1496			 
1496				 
1496			 
1496			 
1496 c9				ret 
1497			 
1497			 
1497			endif 
1497			 
1497			 
1497			; Save user words to storage 
1497			 
1497			.savetostore: 
1497			 
1497				if STORAGE_SE 
1497			 
1497 cd bc 14				call config_dir 
149a 21 14 ee			        ld hl, scratch 
149d 3e 00				ld a, 0 
149f cd 01 0b				call menu 
14a2					 
14a2 21 14 ee				ld hl, scratch 
14a5 cd a9 14				call config_fdir 
14a8			 
14a8				else 
14a8			 
14a8				ld hl, prom_notav 
14a8				ld de, prom_empty 
14a8				call info_panel 
14a8			 
14a8				endif 
14a8			 
14a8 c9				ret 
14a9			 
14a9			 
14a9			 
14a9			if STORAGE_SE 
14a9			 
14a9			config_fdir: 
14a9				; using the scratch dir go through and release the memory allocated for each string 
14a9				 
14a9 21 14 ee			ld hl, scratch 
14ac 5e			.cfdir:	ld e,(hl) 
14ad 23				inc hl 
14ae 56				ld d,(hl) 
14af 23				inc hl 
14b0			 
14b0 eb				ex de, hl 
14b1 cd 2d 0d			call ishlzero 
14b4 c8				ret z     ; return on null pointer 
14b5 cd 95 12			call free 
14b8 eb				ex de, hl 
14b9 18 f1			jr .cfdir 
14bb			 
14bb			 
14bb c9				ret 
14bc			 
14bc			 
14bc			config_dir: 
14bc			 
14bc				; for the config menus that need to build a directory of storage call this routine 
14bc				; it will construct a menu in scratch to pass to menu 
14bc			 
14bc				; open storage device 
14bc			 
14bc				; execute DIR to build a list of files and their ids into scratch in menu format 
14bc				; once the menu has finished then will need to call config_fdir to release the strings 
14bc				 
14bc				; c = number items 
14bc			 
14bc				 
14bc cd 93 03			call storage_get_block_0 
14bf			 
14bf 21 59 f8			ld hl, store_page     ; get current id count 
14c2 46				ld b, (hl) 
14c3 0e 00			ld c, 0    ; count of files   
14c5			 
14c5			 
14c5 21 14 ee			ld hl, scratch 
14c8 22 55 f8			ld (store_tmp2), hl    ; location to poke strings 
14cb			 
14cb				; check for empty drive 
14cb			 
14cb 3e 00			ld a, 0 
14cd b8				cp b 
14ce ca 68 15			jp z, .dirdone 
14d1			 
14d1				 
14d1					if DEBUG_FORTH_WORDS 
14d1						DMARK "Cdc" 
14d1 f5				push af  
14d2 3a e6 14			ld a, (.dmark)  
14d5 32 6e fb			ld (debug_mark),a  
14d8 3a e7 14			ld a, (.dmark+1)  
14db 32 6f fb			ld (debug_mark+1),a  
14de 3a e8 14			ld a, (.dmark+2)  
14e1 32 70 fb			ld (debug_mark+2),a  
14e4 18 03			jr .pastdmark  
14e6 ..			.dmark: db "Cdc"  
14e9 f1			.pastdmark: pop af  
14ea			endm  
# End of macro DMARK
14ea						CALLMONITOR 
14ea cd ab 16			call break_point_state  
14ed				endm  
# End of macro CALLMONITOR
14ed					endif 
14ed			 
14ed			 
14ed			.diritem:	 
14ed c5				push bc 
14ee				; for each of the current ids do a search for them and if found push to stack 
14ee			 
14ee 21 40 00				ld hl, STORE_BLOCK_PHY 
14f1 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
14f3 58					ld e,b 
14f4			 
14f4 cd 15 06				call storage_findnextid 
14f7			 
14f7			 
14f7					; if found hl will be non zero 
14f7			 
14f7 cd 2d 0d				call ishlzero 
14fa 28 69				jr z, .dirnotfound 
14fc			 
14fc					; increase count 
14fc			 
14fc c1					pop bc	 
14fd 0c					inc c 
14fe c5					push bc 
14ff					 
14ff			 
14ff					; get file header and push the file name 
14ff			 
14ff 11 59 f8				ld de, store_page 
1502 cd e2 02				call storage_read_block 
1505			 
1505					; push file id to stack 
1505				 
1505 3a 59 f8				ld a, (store_page) 
1508 26 00				ld h, 0 
150a 6f					ld l, a 
150b			 
150b					;call forth_push_numhl 
150b					; TODO store id 
150b			 
150b e5					push hl 
150c			 
150c					; push extent count to stack  
150c				 
150c 21 5c f8				ld hl, store_page+3 
150f			 
150f					; get file name length 
150f			 
150f cd 62 11				call strlenz   
1512			 
1512 23					inc hl   ; cover zero term 
1513 23					inc hl  ; stick the id at the end of the area 
1514			 
1514 e5					push hl 
1515 c1					pop bc    ; move length to bc 
1516			 
1516 cd cb 11				call malloc 
1519			 
1519					; TODO save malloc area to scratch 
1519			 
1519 eb					ex de, hl 
151a 2a 55 f8				ld hl, (store_tmp2) 
151d 73					ld (hl), e 
151e 23					inc hl 
151f 72					ld (hl), d 
1520 23					inc hl 
1521 22 55 f8				ld (store_tmp2), hl 
1524			 
1524					 
1524			 
1524					;pop hl   ; get source 
1524			;		ex de, hl    ; swap aronund	 
1524			 
1524 21 5c f8				ld hl, store_page+3 
1527					if DEBUG_FORTH_WORDS 
1527						DMARK "CFd" 
1527 f5				push af  
1528 3a 3c 15			ld a, (.dmark)  
152b 32 6e fb			ld (debug_mark),a  
152e 3a 3d 15			ld a, (.dmark+1)  
1531 32 6f fb			ld (debug_mark+1),a  
1534 3a 3e 15			ld a, (.dmark+2)  
1537 32 70 fb			ld (debug_mark+2),a  
153a 18 03			jr .pastdmark  
153c ..			.dmark: db "CFd"  
153f f1			.pastdmark: pop af  
1540			endm  
# End of macro DMARK
1540						CALLMONITOR 
1540 cd ab 16			call break_point_state  
1543				endm  
# End of macro CALLMONITOR
1543					endif 
1543 ed b0				ldir 
1545			 
1545					; de is past string, move back one and store id 
1545					 
1545 1b					dec de 
1546			 
1546					; store file id 
1546			 
1546 e1					pop hl 
1547 eb					ex de,hl 
1548 73					ld (hl), e 
1549			 
1549					if DEBUG_FORTH_WORDS 
1549						DMARK "Cdi" 
1549 f5				push af  
154a 3a 5e 15			ld a, (.dmark)  
154d 32 6e fb			ld (debug_mark),a  
1550 3a 5f 15			ld a, (.dmark+1)  
1553 32 6f fb			ld (debug_mark+1),a  
1556 3a 60 15			ld a, (.dmark+2)  
1559 32 70 fb			ld (debug_mark+2),a  
155c 18 03			jr .pastdmark  
155e ..			.dmark: db "Cdi"  
1561 f1			.pastdmark: pop af  
1562			endm  
# End of macro DMARK
1562						CALLMONITOR 
1562 cd ab 16			call break_point_state  
1565				endm  
# End of macro CALLMONITOR
1565					endif 
1565					 
1565			.dirnotfound: 
1565 c1					pop bc     
1566 10 85				djnz .diritem 
1568				 
1568			.dirdone:	 
1568			 
1568 3e 00				ld a, 0 
156a 2a 55 f8				ld hl, (store_tmp2) 
156d 77					ld (hl), a 
156e 23					inc hl 
156f 77					ld (hl), a 
1570 23					inc hl 
1571					; push a count of the dir items found 
1571			 
1571			;		ld h, 0 
1571			;		ld l, c 
1571			 
1571 c9				ret 
1572			 
1572			endif 
1572			 
1572			 
1572			; Settings 
1572			; Run  
1572			 
1572			 
1572			 
1572			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1572			;;hd_menu2:   db "        2: Editor",0   
1572			;hd_menu2:   db "        2: Editor       6: Menu",0   
1572			;hd_menu3:   db "        3: Storage",0 
1572			;hd_menu4:   db "0=quit  4: Debug",0 
1572			;hd_don:     db "ON",0 
1572			;hd_doff:     db "OFF",0 
1572			; 
1572			; 
1572			; 
1572			;hardware_diags_old:       
1572			; 
1572			;.diagmenu: 
1572			;	call clear_display 
1572			;	ld a, display_row_1 
1572			;	ld de, hd_menu1 
1572			;	call str_at_display 
1572			; 
1572			;	ld a, display_row_2 
1572			;	ld de, hd_menu2 
1572			;	call str_at_display 
1572			; 
1572			;	ld a, display_row_3 
1572			;	ld de, hd_menu3 
1572			;	call str_at_display 
1572			; 
1572			;	ld a,  display_row_4 
1572			;	ld de, hd_menu4 
1572			;	call str_at_display 
1572			; 
1572			;	; display debug state 
1572			; 
1572			;	ld de, hd_don 
1572			;	ld a, (os_view_disable) 
1572			;	cp 0 
1572			;	jr z, .distog 
1572			;	ld de, hd_doff 
1572			;.distog: ld a, display_row_4+17 
1572			;	call str_at_display 
1572			; 
1572			;	call update_display 
1572			; 
1572			;	call cin_wait 
1572			; 
1572			; 
1572			; 
1572			;	cp '4' 
1572			;	jr nz, .diagn1 
1572			; 
1572			;	; debug toggle 
1572			; 
1572			;	ld a, (os_view_disable) 
1572			;	ld b, '*' 
1572			;	cp 0 
1572			;	jr z, .debtog 
1572			;	ld b, 0 
1572			;.debtog:	 
1572			;	ld a,b 
1572			;	ld (os_view_disable),a 
1572			; 
1572			;.diagn1: cp '0' 
1572			;	 ret z 
1572			; 
1572			;;	cp '1' 
1572			;;       jp z, matrix	 
1572			;;   TODO keyboard matrix test 
1572			; 
1572			;	cp '2' 
1572			;	jp z, .diagedit 
1572			; 
1572			;;	cp '6' 
1572			;;	jp z, .menutest 
1572			;;if ENABLE_BASIC 
1572			;;	cp '6' 
1572			;;	jp z, basic 
1572			;;endif 
1572			 ; 
1572			;	jp .diagmenu 
1572			; 
1572			; 
1572			;	ret 
1572			 
1572			 
1572			.debug_tog: 
1572 21 b9 15			ld hl, .menudebug 
1575				 
1575 3a 05 ee			ld a, (os_view_disable) 
1578 fe 2a			cp '*' 
157a 20 04			jr nz,.tdon  
157c 3e 01			ld a, 1 
157e 18 02			jr .tog1 
1580 3e 00		.tdon: ld a, 0 
1582			 
1582			.tog1: 
1582 cd 01 0b			call menu 
1585 fe 00			cp 0 
1587 c8				ret z 
1588 fe 01			cp 1    ; disable debug 
158a 28 04			jr z, .dtog0 
158c 3e 2a			ld a, '*' 
158e 18 02			jr .dtogset 
1590 3e 00		.dtog0: ld a, 0 
1592 32 05 ee		.dtogset:  ld (os_view_disable), a 
1595 c3 72 15			jp .debug_tog 
1598			 
1598			 
1598			hardware_diags:       
1598			 
1598			.diagm: 
1598 21 ab 15			ld hl, .menuitems 
159b 3e 00			ld a, 0 
159d cd 01 0b			call menu 
15a0			 
15a0 fe 00		         cp 0 
15a2 c8				 ret z 
15a3			 
15a3 fe 02			cp 2 
15a5 ca 04 16			jp z, .diagedit 
15a8			 
15a8			;	cp '6' 
15a8			;	jp z, .menutest 
15a8			;if ENABLE_BASIC 
15a8			;	cp '6' 
15a8			;	jp z, basic 
15a8			;endif 
15a8			  
15a8 c3 98 15			jp .diagm 
15ab			 
15ab				 
15ab bf 15		.menuitems:   	dw .m1 
15ad ca 15				dw .m2 
15af d1 15				dw .m3 
15b1 d9 15				dw .m5 
15b3 df 15				dw .m5a 
15b5 e8 15				dw .m5b 
15b7 00 00				dw 0 
15b9			 
15b9			.menudebug: 
15b9 f1 15				dw .m6 
15bb fa 15				dw .m7 
15bd 00 00				dw 0 
15bf			 
15bf .. 00		.m1:   db "Key Matrix",0 
15ca .. 00		.m2:   db "Editor",0 
15d1 .. 00		.m3:   db "Storage",0 
15d9 .. 00		.m5:   db "Sound",0 
15df .. 00		.m5a:  db "RAM Test",0 
15e8 .. 00		.m5b:  db "LCD Test",0 
15f1			 
15f1 .. 00		.m6:   db "Debug ON",0 
15fa .. 00		.m7:   db "Debug OFF",0 
1604			 
1604			; debug editor 
1604			 
1604			.diagedit: 
1604			 
1604 21 14 ee			ld hl, scratch 
1607			;	ld bc, 250 
1607			;	ldir 
1607				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1607 3e 00			ld a, 0 
1609 77				ld (hl), a 
160a 23				inc hl 
160b 77				ld (hl), a 
160c 23				inc hl 
160d 77				ld (hl), a 
160e			 
160e cd d0 0a		        call clear_display 
1611 cd f3 0a			call update_display 
1614				;ld a, 1 
1614				;ld (hardware_diag), a 
1614			.diloop: 
1614 3e 00			ld a, display_row_1 
1616 0e 00			ld c, 0 
1618 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
161a 1e 28			ld e, 40 
161c			 
161c 21 14 ee			ld hl, scratch	 
161f cd 31 0d			call input_str 
1622			 
1622 3e 28			ld a, display_row_2 
1624 11 14 ee			ld de, scratch 
1627 cd e3 0a			call str_at_display 
162a cd f3 0a			call update_display 
162d			 
162d c3 14 16			jp .diloop 
1630			 
1630			 
1630			; pass word in hl 
1630			; a has display location 
1630			display_word_at: 
1630 f5				push af 
1631 e5				push hl 
1632 7c				ld a,h 
1633 21 19 f1			ld hl, os_word_scratch 
1636 cd 05 10			call hexout 
1639 e1				pop hl 
163a 7d				ld a,l 
163b 21 1b f1			ld hl, os_word_scratch+2 
163e cd 05 10			call hexout 
1641 21 1d f1			ld hl, os_word_scratch+4 
1644 3e 00			ld a,0 
1646 77				ld (hl),a 
1647 11 19 f1			ld de,os_word_scratch 
164a f1				pop af 
164b cd e3 0a				call str_at_display 
164e c9				ret 
164f			 
164f			display_ptr_state: 
164f			 
164f				; to restore afterwards 
164f			 
164f d5				push de 
1650 c5				push bc 
1651 e5				push hl 
1652 f5				push af 
1653			 
1653				; for use in here 
1653			 
1653			;	push bc 
1653			;	push de 
1653			;	push hl 
1653			;	push af 
1653			 
1653 cd d0 0a			call clear_display 
1656			 
1656 11 29 18			ld de, .ptrstate 
1659 3e 00			ld a, display_row_1 
165b cd e3 0a			call str_at_display 
165e			 
165e				; display debug step 
165e			 
165e			 
165e 11 6e fb			ld de, debug_mark 
1661 3e 26			ld a, display_row_1+display_cols-2 
1663 cd e3 0a			call str_at_display 
1666			 
1666				; display a 
1666 11 33 18			ld de, .ptrcliptr 
1669 3e 28			ld a, display_row_2 
166b cd e3 0a			call str_at_display 
166e			 
166e f1				pop af 
166f 2a 1f f8			ld hl,(cli_ptr) 
1672 3e 30			ld a, display_row_2+8 
1674 cd 30 16			call display_word_at 
1677			 
1677			 
1677				; display hl 
1677			 
1677			 
1677 11 3b 18			ld de, .ptrclioptr 
167a 3e 32			ld a, display_row_2+10 
167c cd e3 0a			call str_at_display 
167f			; 
167f			;	pop hl 
167f 3e 35			ld a, display_row_2+13 
1681 2a 1d f8			ld hl,(cli_origptr) 
1684 cd 30 16			call display_word_at 
1687			; 
1687			;	 
1687			;	; display de 
1687			 
1687			;	ld de, .regstatede 
1687			;	ld a, display_row_3 
1687			;	call str_at_display 
1687			 
1687			;	pop de 
1687			;	ld h,d 
1687			;	ld l, e 
1687			;	ld a, display_row_3+3 
1687			;	call display_word_at 
1687			 
1687			 
1687				; display bc 
1687			 
1687			;	ld de, .regstatebc 
1687			;	ld a, display_row_3+10 
1687			;	call str_at_display 
1687			 
1687			;	pop bc 
1687			;	ld h,b 
1687			;	ld l, c 
1687			;	ld a, display_row_3+13 
1687			;	call display_word_at 
1687			 
1687			 
1687				; display dsp 
1687			 
1687			;	ld de, .regstatedsp 
1687			;	ld a, display_row_4 
1687			;	call str_at_display 
1687			 
1687				 
1687			;	ld hl,(cli_data_sp) 
1687			;	ld a, display_row_4+4 
1687			;	call display_word_at 
1687			 
1687				; display rsp 
1687			 
1687 11 6a 18			ld de, .regstatersp 
168a 3e 82			ld a, display_row_4+10 
168c cd e3 0a			call str_at_display 
168f			 
168f				 
168f 2a 05 f8			ld hl,(cli_ret_sp) 
1692 3e 86			ld a, display_row_4+14 
1694 cd 30 16			call display_word_at 
1697			 
1697 cd f3 0a			call update_display 
169a			 
169a cd 4d 0a			call delay1s 
169d cd 4d 0a			call delay1s 
16a0 cd 4d 0a			call delay1s 
16a3			 
16a3			 
16a3 cd 80 1c			call next_page_prompt 
16a6			 
16a6				; restore  
16a6			 
16a6 f1				pop af 
16a7 e1				pop hl 
16a8 c1				pop bc 
16a9 d1				pop de 
16aa c9				ret 
16ab			 
16ab			break_point_state: 
16ab f5				push af 
16ac			 
16ac				; see if disabled 
16ac			 
16ac 3a 05 ee			ld a, (os_view_disable) 
16af fe 2a			cp '*' 
16b1 20 02			jr nz, .bpsgo 
16b3 f1				pop af 
16b4 c9				ret 
16b5			 
16b5			.bpsgo: 
16b5 f1				pop af 
16b6 f5				push af 
16b7 22 01 ee			ld (os_view_hl), hl 
16ba ed 53 ff ed		ld (os_view_de), de 
16be ed 43 fd ed		ld (os_view_bc), bc 
16c2 e5				push hl 
16c3 6f				ld l, a 
16c4 26 00			ld h, 0 
16c6 22 03 ee			ld (os_view_af),hl 
16c9			 
16c9 21 b4 fa				ld hl, display_fb0 
16cc 22 cf f8				ld (display_fb_active), hl 
16cf e1				pop hl	 
16d0			 
16d0 3e 31			ld a, '1' 
16d2 fe 2a		.bps1:  cp '*' 
16d4 20 03			jr nz, .bps1b 
16d6 32 05 ee			ld (os_view_disable),a 
16d9 fe 31		.bps1b:  cp '1' 
16db 20 14			jr nz, .bps2 
16dd			 
16dd				; display reg 
16dd			 
16dd				 
16dd			 
16dd 3a 03 ee			ld a, (os_view_af) 
16e0 2a 01 ee			ld hl, (os_view_hl) 
16e3 ed 5b ff ed		ld de, (os_view_de) 
16e7 ed 4b fd ed		ld bc, (os_view_bc) 
16eb cd 85 17			call display_reg_state 
16ee c3 71 17			jp .bpschk 
16f1			 
16f1 fe 32		.bps2:  cp '2' 
16f3 20 08			jr nz, .bps3 
16f5				 
16f5				; display hl 
16f5 2a 01 ee			ld hl, (os_view_hl) 
16f8 cd 6f 18			call display_dump_at_hl 
16fb			 
16fb 18 74			jr .bpschk 
16fd			 
16fd fe 33		.bps3:  cp '3' 
16ff 20 08			jr nz, .bps4 
1701			 
1701			        ; display de 
1701 2a ff ed			ld hl, (os_view_de) 
1704 cd 6f 18			call display_dump_at_hl 
1707			 
1707 18 68			jr .bpschk 
1709 fe 34		.bps4:  cp '4' 
170b 20 08			jr nz, .bps5 
170d			 
170d			        ; display bc 
170d 2a fd ed			ld hl, (os_view_bc) 
1710 cd 6f 18			call display_dump_at_hl 
1713			 
1713 18 5c			jr .bpschk 
1715 fe 35		.bps5:  cp '5' 
1717 20 08		        jr nz, .bps7 
1719			 
1719				; display cur ptr 
1719 2a 1f f8			ld hl, (cli_ptr) 
171c cd 6f 18			call display_dump_at_hl 
171f			 
171f 18 50			jr .bpschk 
1721 fe 36		.bps7:  cp '6' 
1723 20 08			jr nz, .bps8b 
1725				 
1725				; display cur orig ptr 
1725 2a 1d f8			ld hl, (cli_origptr) 
1728 cd 6f 18			call display_dump_at_hl 
172b 18 44			jr .bpschk 
172d fe 37		.bps8b:  cp '7' 
172f 20 08			jr nz, .bps9 
1731				 
1731				; display dsp 
1731 2a 01 f8			ld hl, (cli_data_sp) 
1734 cd 6f 18			call display_dump_at_hl 
1737			 
1737 18 38			jr .bpschk 
1739 fe 39		.bps9:  cp '9' 
173b 20 05			jr nz, .bps8c 
173d				 
173d				; display SP 
173d			;	ld hl, sp 
173d cd 6f 18			call display_dump_at_hl 
1740			 
1740 18 2f			jr .bpschk 
1742 fe 38		.bps8c:  cp '8' 
1744 20 08			jr nz, .bps8d 
1746				 
1746				; display rsp 
1746 2a 05 f8			ld hl, (cli_ret_sp) 
1749 cd 6f 18			call display_dump_at_hl 
174c			 
174c 18 23			jr .bpschk 
174e fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1750 20 05			jr nz, .bps8 
1752 cd 76 1a			call monitor 
1755			 
1755 18 1a			jr .bpschk 
1757 fe 30		.bps8:  cp '0' 
1759 20 16			jr nz, .bpschk 
175b			 
175b 21 13 fa				ld hl, display_fb1 
175e 22 cf f8				ld (display_fb_active), hl 
1761 cd f3 0a				call update_display 
1764			 
1764				;ld a, (os_view_af) 
1764 2a 01 ee			ld hl, (os_view_hl) 
1767 ed 5b ff ed		ld de, (os_view_de) 
176b ed 4b fd ed		ld bc, (os_view_bc) 
176f f1				pop af 
1770 c9				ret 
1771			 
1771			.bpschk:   
1771 cd 4d 0a			call delay1s 
1774 3e 9f		ld a,display_row_4 + display_cols - 1 
1776 11 7e 1c		        ld de, endprg 
1779 cd e3 0a			call str_at_display 
177c cd f3 0a			call update_display 
177f cd 54 69			call cin_wait 
1782			 
1782 c3 d2 16			jp .bps1 
1785			 
1785			 
1785			display_reg_state: 
1785			 
1785				; to restore afterwards 
1785			 
1785 d5				push de 
1786 c5				push bc 
1787 e5				push hl 
1788 f5				push af 
1789			 
1789				; for use in here 
1789			 
1789 c5				push bc 
178a d5				push de 
178b e5				push hl 
178c f5				push af 
178d			 
178d cd d0 0a			call clear_display 
1790			 
1790 11 45 18			ld de, .regstate 
1793 3e 00			ld a, display_row_1 
1795 cd e3 0a			call str_at_display 
1798			 
1798				; display debug step 
1798			 
1798			 
1798 11 6e fb			ld de, debug_mark 
179b 3e 25			ld a, display_row_1+display_cols-3 
179d cd e3 0a			call str_at_display 
17a0			 
17a0				; display a 
17a0 11 61 18			ld de, .regstatea 
17a3 3e 28			ld a, display_row_2 
17a5 cd e3 0a			call str_at_display 
17a8			 
17a8 e1				pop hl 
17a9			;	ld h,0 
17a9			;	ld l, a 
17a9 3e 2b			ld a, display_row_2+3 
17ab cd 30 16			call display_word_at 
17ae			 
17ae			 
17ae				; display hl 
17ae			 
17ae			 
17ae 11 55 18			ld de, .regstatehl 
17b1 3e 32			ld a, display_row_2+10 
17b3 cd e3 0a			call str_at_display 
17b6			 
17b6 e1				pop hl 
17b7 3e 35			ld a, display_row_2+13 
17b9 cd 30 16			call display_word_at 
17bc			 
17bc				 
17bc				; display de 
17bc			 
17bc 11 59 18			ld de, .regstatede 
17bf 3e 50			ld a, display_row_3 
17c1 cd e3 0a			call str_at_display 
17c4			 
17c4 e1				pop hl 
17c5			;	ld h,d 
17c5			;	ld l, e 
17c5 3e 53			ld a, display_row_3+3 
17c7 cd 30 16			call display_word_at 
17ca			 
17ca			 
17ca				; display bc 
17ca			 
17ca 11 5d 18			ld de, .regstatebc 
17cd 3e 5a			ld a, display_row_3+10 
17cf cd e3 0a			call str_at_display 
17d2			 
17d2 e1				pop hl 
17d3			;	ld h,b 
17d3			;	ld l, c 
17d3 3e 5d			ld a, display_row_3+13 
17d5 cd 30 16			call display_word_at 
17d8			 
17d8			 
17d8				; display dsp 
17d8			 
17d8 11 65 18			ld de, .regstatedsp 
17db 3e 78			ld a, display_row_4 
17dd cd e3 0a			call str_at_display 
17e0			 
17e0				 
17e0 2a 01 f8			ld hl,(cli_data_sp) 
17e3 3e 7c			ld a, display_row_4+4 
17e5 cd 30 16			call display_word_at 
17e8			 
17e8				; display rsp 
17e8			 
17e8 11 6a 18			ld de, .regstatersp 
17eb 3e 82			ld a, display_row_4+10 
17ed cd e3 0a			call str_at_display 
17f0			 
17f0				 
17f0 2a 05 f8			ld hl,(cli_ret_sp) 
17f3 3e 86			ld a, display_row_4+14 
17f5 cd 30 16			call display_word_at 
17f8			 
17f8 cd f3 0a			call update_display 
17fb			 
17fb			;	call delay1s 
17fb			;	call delay1s 
17fb			;	call delay1s 
17fb			 
17fb			 
17fb			;	call next_page_prompt 
17fb			 
17fb				; restore  
17fb			 
17fb f1				pop af 
17fc e1				pop hl 
17fd c1				pop bc 
17fe d1				pop de 
17ff c9				ret 
1800			 
1800 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1814 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1829 .. 00		.ptrstate:	db "Ptr State",0 
1833 .. 00		.ptrcliptr:     db "cli_ptr",0 
183b .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1845 .. 00		.regstate:	db "Reg State (1/0)",0 
1855 .. 00		.regstatehl:	db "HL:",0 
1859 .. 00		.regstatede:	db "DE:",0 
185d .. 00		.regstatebc:	db "BC:",0 
1861 .. 00		.regstatea:	db "A :",0 
1865 .. 00		.regstatedsp:	db "DSP:",0 
186a .. 00		.regstatersp:	db "RSP:",0 
186f			 
186f			display_dump_at_hl: 
186f e5				push hl 
1870 d5				push de 
1871 c5				push bc 
1872 f5				push af 
1873			 
1873 22 37 f1			ld (os_cur_ptr),hl	 
1876 cd d0 0a			call clear_display 
1879 cd 88 1b			call dumpcont 
187c			;	call delay1s 
187c			;	call next_page_prompt 
187c			 
187c			 
187c f1				pop af 
187d c1				pop bc 
187e d1				pop de 
187f e1				pop hl 
1880 c9				ret 
1881			 
1881			;if ENABLE_BASIC 
1881			;	include "nascombasic.asm" 
1881			;	basic: 
1881			;	include "forth/FORTH.ASM" 
1881			;endif 
1881			 
1881			; eof 
1881			 
1881			 
# End of file firmware_diags.asm
1881			  
1881			include "firmware_prompts.asm"  
1881			; Prompts  
1881			 
1881			; boot messages 
1881			 
1881 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.5",0 
1896 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
18a6			 
18a6			 
18a6			; config menus 
18a6			 
18a6 .. 00		prom_c3: db "Add Dictionary To File",0 
18bd .. 00		prom_c2: db "Select Autoload File",0 
18d2 .. 00		prom_c2a: db "Disable Autoload File", 0 
18e8 .. 00		prom_c2b: db "Select Storage Bank",0 
18fc .. 00		prom_c4: db "Settings",0 
1905 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1920 .. 00		prom_m4b:   db "Monitor",0 
1928 .. 00		prom_c1: db "Hardware Diags",0 
1937			 
1937			 
1937 .. 00		prom_notav:    db "Feature not available",0 
194d .. 00		prom_empty:    db "",0 
194e			 
194e			; eof 
194e			 
# End of file firmware_prompts.asm
194e			  
194e			  
194e			; eof  
194e			  
# End of file firmware.asm
194e			 
194e			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
194e			;if BASE_KEV  
194e			;baseram: equ 08000h 
194e			;endif 
194e			 
194e			;if BASE_SC114 
194e			;baseram:     equ    endofcode 
194e			;endif 
194e			 
194e			 
194e			; start system 
194e			 
194e			coldstart: 
194e				; set sp 
194e				; di/ei 
194e			 
194e f3				di 
194f 31 fd ff			ld sp, tos 
1952			;	ei 
1952			 
1952			 
1952				; disable breakpoint by default 
1952			 
1952 3e 2a			ld a,'*' 
1954 32 05 ee			ld (os_view_disable),a 
1957			 
1957				; init hardware 
1957			 
1957				; init keyboard and screen hardware 
1957			 
1957 cd 03 00			call hardware_init 
195a			 
195a			 
195a				; detect if any keys are held down to enable breakpoints at start up 
195a			 
195a cd 65 69			call cin  
195d fe 00			cp 0 
195f 28 03			jr z, .nokeys 
1961			 
1961				;call hardware_diags 
1961 cd 8e 13			call config 
1964			 
1964			;	ld de, .bpen 
1964			;	ld a, display_row_4 
1964			;	call str_at_display 
1964			;	call update_display 
1964			; 
1964			;	ld a,0 
1964			;	ld (os_view_disable),a 
1964			; 
1964			;.bpwait: 
1964			;	call cin 
1964			;	cp 0 
1964			;	jr z, .bpwait 
1964			;	jr .nokeys 
1964			; 
1964			; 
1964			;.bpen:  db "Break points enabled!",0 
1964			 
1964			 
1964			 
1964			 
1964			 
1964			 
1964			.nokeys: 
1964			 
1964			 
1964				 
1964			 
1964			;jp  testkey 
1964			 
1964			;call storage_get_block_0 
1964			; 
1964			;ld hl, 0 
1964			;ld de, store_page 
1964			;call storage_read_block 
1964			 
1964				 
1964			;ld hl, 10 
1964			;ld de, store_page 
1964			;call storage_read_block 
1964			 
1964			 
1964			 
1964			 
1964			 
1964			;stop:	nop 
1964			;	jp stop 
1964			 
1964			 
1964			 
1964			main: 
1964 cd d0 0a			call clear_display 
1967 cd f3 0a			call update_display 
196a			 
196a			 
196a			 
196a			;	call testlcd 
196a			 
196a			 
196a			 
196a cd 46 20			call forth_init 
196d			 
196d			 
196d			warmstart: 
196d cd 1c 20			call forth_warmstart 
1970			 
1970				; run startup word load 
1970			        ; TODO prevent this running at warmstart after crash  
1970			 
1970				if STARTUP_ENABLE 
1970					if STORAGE_SE 
1970 cd f3 64					call forth_autoload 
1973					endif 
1973 cd 02 62				call forth_startup 
1976			 
1976			 
1976				endif 
1976			 
1976				; show free memory after boot 
1976 11 10 1a			ld de, freeram 
1979 3e 00			ld a, display_row_1 
197b cd e3 0a			call str_at_display 
197e			 
197e			; Or use heap_size word???? 
197e 21 fa ed			ld hl, heap_end 
1981 11 0e 80			ld de, heap_start 
1984 ed 52			sbc hl, de 
1986 e5				push hl 
1987 7c				ld a,h	         	 
1988 21 19 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
198b cd 05 10			call hexout 
198e e1			   	pop hl 
198f			 
198f 7d				ld a,l 
1990 21 1b f1			ld hl, os_word_scratch+2 
1993 cd 05 10			call hexout 
1996 21 1d f1			ld hl, os_word_scratch+4 
1999 3e 00			ld a, 0 
199b 77				ld (hl),a 
199c 11 19 f1			ld de, os_word_scratch 
199f 3e 0d			ld a, display_row_1 + 13 
19a1 cd e3 0a			call str_at_display 
19a4 cd f3 0a			call update_display 
19a7			 
19a7			 
19a7				;call demo 
19a7			 
19a7			 
19a7				; init scratch input area for cli commands 
19a7			 
19a7 21 3b f1			ld hl, os_cli_cmd 
19aa 3e 00			ld a,0 
19ac 77				ld (hl),a 
19ad 23				inc hl 
19ae 77				ld (hl),a 
19af			 
19af 3e 00			ld a,0 
19b1 32 3a f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
19b4			 
19b4 32 37 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
19b7 32 38 f1			ld (os_cur_ptr+1),a	 
19ba			 
19ba 32 19 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
19bd 32 1a f1			ld (os_word_scratch+1),a	 
19c0				 
19c0			 
19c0				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19c0 21 3b f1			ld hl, os_cli_cmd 
19c3			 
19c3 3e 00			ld a, 0		 ; init cli input 
19c5 77				ld (hl), a 
19c6 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
19c8			cli: 
19c8				; show cli prompt 
19c8				;push af 
19c8				;ld a, 0 
19c8				;ld de, prompt 
19c8				;call str_at_display 
19c8			 
19c8				;call update_display 
19c8				;pop af 
19c8				;inc a 
19c8				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
19c8 0e 00			ld c, 0 
19ca 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19cc 1e 28			ld e, 40 
19ce			 
19ce 21 3b f1			ld hl, os_cli_cmd 
19d1			 
19d1				STACKFRAME OFF $fefe $9f9f 
19d1				if DEBUG_STACK_IMB 
19d1					if OFF 
19d1						exx 
19d1						ld de, $fefe 
19d1						ld a, d 
19d1						ld hl, curframe 
19d1						call hexout 
19d1						ld a, e 
19d1						ld hl, curframe+2 
19d1						call hexout 
19d1						ld hl, $fefe 
19d1						push hl 
19d1						ld hl, $9f9f 
19d1						push hl 
19d1						exx 
19d1					endif 
19d1				endif 
19d1			endm 
# End of macro STACKFRAME
19d1			 
19d1 cd 31 0d			call input_str 
19d4			 
19d4				STACKFRAMECHK OFF $fefe $9f9f 
19d4				if DEBUG_STACK_IMB 
19d4					if OFF 
19d4						exx 
19d4						ld hl, $9f9f 
19d4						pop de   ; $9f9f 
19d4						call cmp16 
19d4						jr nz, .spnosame 
19d4						ld hl, $fefe 
19d4						pop de   ; $fefe 
19d4						call cmp16 
19d4						jr z, .spfrsame 
19d4						.spnosame: call showsperror 
19d4						.spfrsame: nop 
19d4						exx 
19d4					endif 
19d4				endif 
19d4			endm 
# End of macro STACKFRAMECHK
19d4			 
19d4				; copy input to last command 
19d4			 
19d4 21 3b f1			ld hl, os_cli_cmd 
19d7 11 3a f2			ld de, os_last_cmd 
19da 01 ff 00			ld bc, 255 
19dd ed b0			ldir 
19df			 
19df				; wipe current buffer 
19df			 
19df			;	ld a, 0 
19df			;	ld hl, os_cli_cmd 
19df			;	ld de, os_cli_cmd+1 
19df			;	ld bc, 254 
19df			;	ldir 
19df				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
19df			;	call strcpy 
19df			;	ld a, 0 
19df			;	ld (hl), a 
19df			;	inc hl 
19df			;	ld (hl), a 
19df			;	inc hl 
19df			;	ld (hl), a 
19df			 
19df				; switch frame buffer to program  
19df			 
19df 21 13 fa				ld hl, display_fb1 
19e2 22 cf f8				ld (display_fb_active), hl 
19e5			 
19e5			;	nop 
19e5				STACKFRAME ON $fbfe $8f9f 
19e5				if DEBUG_STACK_IMB 
19e5					if ON 
19e5						exx 
19e5						ld de, $fbfe 
19e5						ld a, d 
19e5						ld hl, curframe 
19e5						call hexout 
19e5						ld a, e 
19e5						ld hl, curframe+2 
19e5						call hexout 
19e5						ld hl, $fbfe 
19e5						push hl 
19e5						ld hl, $8f9f 
19e5						push hl 
19e5						exx 
19e5					endif 
19e5				endif 
19e5			endm 
# End of macro STACKFRAME
19e5				; first time into the parser so pass over the current scratch pad 
19e5 21 3b f1			ld hl,os_cli_cmd 
19e8				; tokenise the entered statement(s) in HL 
19e8 cd bf 20			call forthparse 
19eb			        ; exec forth statements in top of return stack 
19eb cd ff 20			call forthexec 
19ee				;call forthexec_cleanup 
19ee			;	call parsenext 
19ee			 
19ee				STACKFRAMECHK ON $fbfe $8f9f 
19ee				if DEBUG_STACK_IMB 
19ee					if ON 
19ee						exx 
19ee						ld hl, $8f9f 
19ee						pop de   ; $8f9f 
19ee						call cmp16 
19ee						jr nz, .spnosame 
19ee						ld hl, $fbfe 
19ee						pop de   ; $fbfe 
19ee						call cmp16 
19ee						jr z, .spfrsame 
19ee						.spnosame: call showsperror 
19ee						.spfrsame: nop 
19ee						exx 
19ee					endif 
19ee				endif 
19ee			endm 
# End of macro STACKFRAMECHK
19ee				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
19ee			 
19ee 3e 78			ld a, display_row_4 
19f0 11 22 1a			ld de, endprog 
19f3			 
19f3 cd f3 0a			call update_display		 
19f6			 
19f6 cd 80 1c			call next_page_prompt 
19f9			 
19f9				; switch frame buffer to cli 
19f9			 
19f9 21 b4 fa				ld hl, display_fb0 
19fc 22 cf f8				ld (display_fb_active), hl 
19ff			 
19ff			 
19ff cd d0 0a		        call clear_display 
1a02 cd f3 0a			call update_display		 
1a05			 
1a05 21 3b f1			ld hl, os_cli_cmd 
1a08			 
1a08 3e 00			ld a, 0		 ; init cli input 
1a0a 77				ld (hl), a 
1a0b			 
1a0b				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1a0b			 
1a0b				; now on last line 
1a0b			 
1a0b				; TODO scroll screen up 
1a0b			 
1a0b				; TODO instead just clear screen and place at top of screen 
1a0b			 
1a0b			;	ld a, 0 
1a0b			;	ld (f_cursor_ptr),a 
1a0b			 
1a0b				;call clear_display 
1a0b				;call update_display 
1a0b			 
1a0b				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a0b 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a0d c3 c8 19			jp cli 
1a10			 
1a10 .. 00		freeram: db "Free bytes: $",0 
1a1e ..			asc: db "1A2F" 
1a22 .. 00		endprog: db "End prog...",0 
1a2e			 
1a2e			testenter2:   
1a2e 21 46 ee			ld hl,scratch+50 
1a31 22 37 f1			ld (os_cur_ptr),hl 
1a34 c3 c8 19			jp cli 
1a37			 
1a37			testenter:  
1a37			 
1a37 21 1e 1a			ld hl,asc 
1a3a			;	ld a,(hl) 
1a3a			;	call nibble2val 
1a3a cd 5b 10			call get_byte 
1a3d			 
1a3d			 
1a3d			;	ld a,(hl) 
1a3d			;	call atohex 
1a3d			 
1a3d			;	call fourehexhl 
1a3d 32 46 ee			ld (scratch+50),a 
1a40			 
1a40			 
1a40			 
1a40 21 20 1a			ld hl,asc+2 
1a43			;	ld a, (hl) 
1a43			;	call nibble2val 
1a43 cd 5b 10			call get_byte 
1a46			 
1a46			;	call fourehexhl 
1a46 32 48 ee			ld (scratch+52),a 
1a49				 
1a49 21 46 ee			ld hl,scratch+50 
1a4c 22 37 f1			ld (os_cur_ptr),hl 
1a4f c3 c8 19			jp cli 
1a52			 
1a52			enter:	 
1a52 3a 18 ee			ld a,(scratch+4) 
1a55 fe 00			cp 0 
1a57 28 0c			jr z, .entercont 
1a59				; no, not a null term line so has an address to work out.... 
1a59			 
1a59 21 16 ee			ld hl,scratch+2 
1a5c cd bb 10			call get_word_hl 
1a5f			 
1a5f 22 37 f1			ld (os_cur_ptr),hl	 
1a62 c3 c8 19			jp cli 
1a65			 
1a65			 
1a65			.entercont:  
1a65			 
1a65 21 16 ee			ld hl, scratch+2 
1a68 cd 5b 10			call get_byte 
1a6b			 
1a6b 2a 37 f1		   	ld hl,(os_cur_ptr) 
1a6e 77					ld (hl),a 
1a6f 23					inc hl 
1a70 22 37 f1				ld (os_cur_ptr),hl 
1a73				 
1a73			; get byte  
1a73			 
1a73			 
1a73 c3 c8 19			jp cli 
1a76			 
1a76			 
1a76			; basic monitor support 
1a76			 
1a76			monitor: 
1a76				;  
1a76 cd d0 0a			call clear_display 
1a79 3e 00			ld a, 0 
1a7b 11 c3 1a			ld de, .monprompt 
1a7e cd e3 0a			call str_at_display 
1a81 cd f3 0a			call update_display 
1a84			 
1a84				; get a monitor command 
1a84			 
1a84 0e 00			ld c, 0     ; entry at top left 
1a86 16 64			ld d, 100   ; max buffer size 
1a88 1e 0f			ld e, 15    ; input scroll area 
1a8a 3e 00			ld a, 0     ; init string 
1a8c 21 12 f0			ld hl, os_input 
1a8f 77				ld (hl), a 
1a90 23				inc hl 
1a91 77				ld (hl), a 
1a92 21 12 f0			ld hl, os_input 
1a95 3e 01			ld a, 1     ; init string 
1a97 cd 31 0d			call input_str 
1a9a			 
1a9a cd d0 0a		        call clear_display 
1a9d cd f3 0a			call update_display		 
1aa0			 
1aa0 3a 12 f0			ld a, (os_input) 
1aa3 cd 59 11			call toUpper 
1aa6 fe 48		        cp 'H' 
1aa8 28 6f		        jr z, .monhelp 
1aaa fe 44			cp 'D'		; dump 
1aac ca 3a 1b			jp z, .mondump	 
1aaf fe 43			cp 'C'		; dump 
1ab1 ca 54 1b			jp z, .moncdump	 
1ab4 fe 4d			cp 'M'		; dump 
1ab6 ca c5 1a			jp z, .moneditstart 
1ab9 fe 55			cp 'U'		; dump 
1abb 28 14			jr z, .monedit	 
1abd fe 51			cp 'Q'		; dump 
1abf c8				ret z	 
1ac0			 
1ac0			 
1ac0				; TODO "S" to access symbol by name and not need the address 
1ac0				; TODO "F" to find a string in memory 
1ac0			 
1ac0 c3 76 1a			jp monitor 
1ac3			 
1ac3 .. 00		.monprompt: db ">", 0 
1ac5			 
1ac5			.moneditstart: 
1ac5				; get starting address 
1ac5			 
1ac5 21 14 f0			ld hl,os_input+2 
1ac8 cd bb 10			call get_word_hl 
1acb			 
1acb 22 37 f1			ld (os_cur_ptr),hl	 
1ace			 
1ace c3 76 1a			jp monitor 
1ad1			 
1ad1			.monedit: 
1ad1				; get byte to load 
1ad1			 
1ad1 21 14 f0			ld hl,os_input+2 
1ad4 cd 5b 10			call get_byte 
1ad7			 
1ad7				; get address to update 
1ad7 2a 37 f1			ld hl, (os_cur_ptr) 
1ada			 
1ada				; update byte 
1ada			 
1ada 77				ld (hl), a 
1adb			 
1adb				; move to next address and save it 
1adb			 
1adb 23				inc hl 
1adc 22 37 f1			ld (os_cur_ptr),hl	 
1adf			 
1adf c3 76 1a			jp monitor 
1ae2			 
1ae2			 
1ae2 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1af6 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1b12 .. 00		.monhelptext3:  db "Q-Quit",0 
1b19			        
1b19			.monhelp: 
1b19 3e 00			ld a, display_row_1 
1b1b 11 e2 1a		        ld de, .monhelptext1 
1b1e			 
1b1e cd e3 0a			call str_at_display 
1b21 3e 28			ld a, display_row_2 
1b23 11 f6 1a		        ld de, .monhelptext2 
1b26					 
1b26 cd e3 0a			call str_at_display 
1b29 3e 50			ld a, display_row_3 
1b2b 11 12 1b		        ld de, .monhelptext3 
1b2e					 
1b2e cd e3 0a			call str_at_display 
1b31 cd f3 0a			call update_display		 
1b34			 
1b34 cd 80 1c			call next_page_prompt 
1b37 c3 76 1a			jp monitor 
1b3a			 
1b3a			.mondump:    
1b3a 21 14 f0			ld hl,os_input+2 
1b3d cd bb 10			call get_word_hl 
1b40			 
1b40 22 37 f1			ld (os_cur_ptr),hl	 
1b43 cd 88 1b			call dumpcont 
1b46 3e 78			ld a, display_row_4 
1b48 11 22 1a			ld de, endprog 
1b4b			 
1b4b cd f3 0a			call update_display		 
1b4e			 
1b4e cd 80 1c			call next_page_prompt 
1b51 c3 76 1a			jp monitor 
1b54			.moncdump: 
1b54 cd 88 1b			call dumpcont 
1b57 3e 78			ld a, display_row_4 
1b59 11 22 1a			ld de, endprog 
1b5c			 
1b5c cd f3 0a			call update_display		 
1b5f			 
1b5f cd 80 1c			call next_page_prompt 
1b62 c3 76 1a			jp monitor 
1b65			 
1b65			 
1b65			; TODO symbol access  
1b65			 
1b65			.symbols:     ;; A list of symbols that can be called up  
1b65 b4 fa			dw display_fb0 
1b67 .. 00			db "fb0",0  
1b6b 59 f8		     	dw store_page 
1b6d .. 00			db "store_page",0 
1b78			 
1b78			 
1b78			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1b78			 
1b78 3a 15 ee			ld a,(scratch+1) 
1b7b fe 00			cp 0 
1b7d 28 09			jr z, dumpcont 
1b7f			 
1b7f				; no, not a null term line so has an address to work out.... 
1b7f			 
1b7f 21 16 ee			ld hl,scratch+2 
1b82 cd bb 10			call get_word_hl 
1b85			 
1b85 22 37 f1			ld (os_cur_ptr),hl	 
1b88			 
1b88			 
1b88			 
1b88			dumpcont: 
1b88			 
1b88				; dump bytes at ptr 
1b88			 
1b88			 
1b88 3e 00			ld a, display_row_1 
1b8a 2a cf f8			ld hl, (display_fb_active) 
1b8d cd 04 0d			call addatohl 
1b90 cd b8 1b			call .dumpbyterow 
1b93			 
1b93 3e 28			ld a, display_row_2 
1b95 2a cf f8			ld hl, (display_fb_active) 
1b98 cd 04 0d			call addatohl 
1b9b cd b8 1b			call .dumpbyterow 
1b9e			 
1b9e			 
1b9e 3e 50			ld a, display_row_3 
1ba0 2a cf f8			ld hl, (display_fb_active) 
1ba3 cd 04 0d			call addatohl 
1ba6 cd b8 1b			call .dumpbyterow 
1ba9			 
1ba9 3e 78			ld a, display_row_4 
1bab 2a cf f8			ld hl, (display_fb_active) 
1bae cd 04 0d			call addatohl 
1bb1 cd b8 1b			call .dumpbyterow 
1bb4			 
1bb4 cd f3 0a			call update_display 
1bb7			;		jp cli 
1bb7 c9				ret 
1bb8			 
1bb8			.dumpbyterow: 
1bb8			 
1bb8				;push af 
1bb8			 
1bb8 e5				push hl 
1bb9			 
1bb9				; calc where to poke the ascii 
1bb9			if display_cols == 20 
1bb9				ld a, 16 
1bb9			else 
1bb9 3e 1f			ld a, 31 
1bbb			endif 
1bbb			 
1bbb cd 04 0d			call addatohl 
1bbe 22 19 f1			ld (os_word_scratch),hl  		; save pos for later 
1bc1			 
1bc1			 
1bc1			; display decoding address 
1bc1 2a 37 f1		   	ld hl,(os_cur_ptr) 
1bc4			 
1bc4 7c				ld a,h 
1bc5 e1				pop hl 
1bc6 e5				push hl 
1bc7			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bc7 cd 05 10			call hexout 
1bca 2a 37 f1		   	ld hl,(os_cur_ptr) 
1bcd			 
1bcd 7d				ld a,l 
1bce e1				pop hl 
1bcf 23				inc hl 
1bd0 23				inc hl 
1bd1 e5				push hl 
1bd2			;	ld hl, os_word_scratch+2 
1bd2 cd 05 10			call hexout 
1bd5 e1				pop hl 
1bd6 23				inc hl 
1bd7 23				inc hl 
1bd8				;ld hl, os_word_scratch+4 
1bd8 3e 3a			ld a, ':' 
1bda 77				ld (hl),a 
1bdb 23				inc hl 
1bdc				;ld a, 0 
1bdc				;ld (hl),a 
1bdc				;ld de, os_word_scratch 
1bdc				;pop af 
1bdc				;push af 
1bdc			;		ld a, display_row_2 
1bdc			;		call str_at_display 
1bdc			;		call update_display 
1bdc			 
1bdc			 
1bdc			;pop af 
1bdc			;	add 5 
1bdc			 
1bdc			if display_cols == 20 
1bdc				ld b, 4 
1bdc			else 
1bdc 06 08			ld b, 8 
1bde			endif	 
1bde			 
1bde			.dumpbyte: 
1bde c5				push bc 
1bdf e5				push hl 
1be0			 
1be0			 
1be0 2a 37 f1		   	ld hl,(os_cur_ptr) 
1be3 7e					ld a,(hl) 
1be4			 
1be4					; poke the ascii to display 
1be4 2a 19 f1				ld hl,(os_word_scratch) 
1be7 77					ld (hl),a 
1be8 23					inc hl 
1be9 22 19 f1				ld (os_word_scratch),hl 
1bec			 
1bec					 
1bec			 
1bec			 
1bec e1					pop hl 
1bed e5					push hl 
1bee			 
1bee cd 05 10				call hexout 
1bf1			 
1bf1					 
1bf1 2a 37 f1		   	ld hl,(os_cur_ptr) 
1bf4 23				inc hl 
1bf5 22 37 f1		   	ld (os_cur_ptr),hl 
1bf8			 
1bf8 e1					pop hl 
1bf9 23					inc hl 
1bfa 23					inc hl 
1bfb 23					inc hl 
1bfc			 
1bfc			 
1bfc			 
1bfc					;ld a,0 
1bfc					;ld (os_word_scratch+2),a 
1bfc					;pop af 
1bfc					;push af 
1bfc			 
1bfc					;ld de, os_word_scratch 
1bfc					;call str_at_display 
1bfc			;		call update_display 
1bfc			;		pop af 
1bfc c1					pop bc 
1bfd c6 03				add 3 
1bff 10 dd			djnz .dumpbyte 
1c01			 
1c01				 
1c01			 
1c01 c9				ret 
1c02			 
1c02			jump:	 
1c02			 
1c02 21 16 ee			ld hl,scratch+2 
1c05 cd bb 10			call get_word_hl 
1c08				;ld hl,(scratch+2) 
1c08				;call fourehexhl 
1c08			 
1c08 22 37 f1			ld (os_cur_ptr),hl	 
1c0b			 
1c0b e9				jp (hl) 
1c0c			 
1c0c			 
1c0c			 
1c0c			; TODO implement a basic monitor mode to start with 
1c0c			 
1c0c			 
1c0c			 
1c0c			 
1c0c			 
1c0c			 
1c0c			 
1c0c			 
1c0c			 
1c0c			; testing and demo code during development 
1c0c			 
1c0c			 
1c0c .. 00		str1: db "Enter some text...",0 
1c1f .. 00		clear: db "                    ",0 
1c34			 
1c34			demo: 
1c34			 
1c34			 
1c34			 
1c34			;	call update_display 
1c34			 
1c34				; init scratch input area for testing 
1c34 21 14 ee			ld hl, scratch	 
1c37 3e 00			ld a,0 
1c39 77				ld (hl),a 
1c3a			 
1c3a			 
1c3a 3e 28		            LD   A, display_row_2 
1c3c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c3c 11 0c 1c		            LD   DE, str1 
1c3f cd e3 0a			call str_at_display 
1c42			 
1c42			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c42			cloop:	 
1c42 3e 50		            LD   A, display_row_3 
1c44			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c44 11 1f 1c		            LD   DE, clear 
1c47			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1c47 cd e3 0a				call str_at_display 
1c4a 3e 78			ld a, display_row_4 
1c4c 11 7c 1c			ld de, prompt 
1c4f			 
1c4f cd e3 0a				call str_at_display 
1c52 cd f3 0a			call update_display 
1c55			 
1c55 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c57 16 0a			ld d, 10 
1c59 21 14 ee			ld hl, scratch	 
1c5c cd 31 0d			call input_str 
1c5f			 
1c5f			;	call clear_display 
1c5f			;'	call update_display 
1c5f			 
1c5f 3e 00		            LD   A, display_row_1 
1c61			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c61 11 1f 1c		            LD   DE, clear 
1c64 cd e3 0a				call str_at_display 
1c67			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c67 3e 00		            LD   A, display_row_1 
1c69			;            CALL fLCD_Pos       ;Position cursor to location in A 
1c69 11 14 ee		            LD   DE, scratch 
1c6c			;            CALL fLCD_Str       ;Display string pointed to by DE 
1c6c cd e3 0a				call str_at_display 
1c6f cd f3 0a			call update_display 
1c72			 
1c72 3e 00				ld a,0 
1c74 21 14 ee			ld hl, scratch 
1c77 77				ld (hl),a 
1c78			 
1c78 00				nop 
1c79 c3 42 1c			jp cloop 
1c7c			 
1c7c			 
1c7c			 
1c7c			; OS Prompt 
1c7c			 
1c7c .. 00		prompt: db ">",0 
1c7e .. 00		endprg: db "?",0 
1c80			 
1c80			 
1c80			; handy next page prompt 
1c80			next_page_prompt: 
1c80 e5				push hl 
1c81 d5				push de 
1c82 f5				push af 
1c83 c5				push bc 
1c84			 
1c84 3e 9f			ld a,display_row_4 + display_cols - 1 
1c86 11 7e 1c		        ld de, endprg 
1c89 cd e3 0a			call str_at_display 
1c8c cd f3 0a			call update_display 
1c8f cd 54 69			call cin_wait 
1c92 c1				pop bc 
1c93 f1				pop af 
1c94 d1				pop de 
1c95 e1				pop hl 
1c96			 
1c96			 
1c96 c9				ret 
1c97			 
1c97			 
1c97			; forth parser 
1c97			 
1c97			; My forth kernel 
1c97			include "forth_kernel.asm" 
1c97			; 
1c97			; kernel to the forth OS 
1c97			 
1c97			DS_TYPE_STR: equ 1     ; string type 
1c97			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1c97			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1c97			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1c97			 
1c97			FORTH_PARSEV1: equ 0 
1c97			FORTH_PARSEV2: equ 0 
1c97			FORTH_PARSEV3: equ 0 
1c97			FORTH_PARSEV4: equ 0 
1c97			FORTH_PARSEV5: equ 1 
1c97			 
1c97			;if FORTH_PARSEV5 
1c97			;	FORTH_END_BUFFER: equ 0 
1c97			;else 
1c97			FORTH_END_BUFFER: equ 127 
1c97			;endif 
1c97			 
1c97			FORTH_TRUE: equ 1 
1c97			FORTH_FALSE: equ 0 
1c97			 
1c97			if FORTH_PARSEV4 
1c97			include "forth_stackops.asm" 
1c97			endif 
1c97			 
1c97			if FORTH_PARSEV5 
1c97			include "forth_stackopsv5.asm" 
1c97			 
1c97			; Stack operations for v5 parser on wards 
1c97			; * DATA stack 
1c97			; * LOOP stack 
1c97			; * RETURN stack 
1c97			 
1c97			 
1c97			 
1c97			FORTH_CHK_DSP_UNDER: macro 
1c97				push hl 
1c97				push de 
1c97				ld hl,(cli_data_sp) 
1c97				ld de, cli_data_stack 
1c97				call cmp16 
1c97				jp c, fault_dsp_under 
1c97				pop de 
1c97				pop hl 
1c97				endm 
1c97			 
1c97			 
1c97			FORTH_CHK_RSP_UNDER: macro 
1c97				push hl 
1c97				push de 
1c97				ld hl,(cli_ret_sp) 
1c97				ld de, cli_ret_stack 
1c97				call cmp16 
1c97				jp c, fault_rsp_under 
1c97				pop de 
1c97				pop hl 
1c97				endm 
1c97			 
1c97			FORTH_CHK_LOOP_UNDER: macro 
1c97				push hl 
1c97				push de 
1c97				ld hl,(cli_loop_sp) 
1c97				ld de, cli_loop_stack 
1c97				call cmp16 
1c97				jp c, fault_loop_under 
1c97				pop de 
1c97				pop hl 
1c97				endm 
1c97			 
1c97			FORTH_ERR_TOS_NOTSTR: macro 
1c97				; TOSO might need more for checks when used 
1c97				push af 
1c97				ld a,(hl) 
1c97				cp DS_TYPE_STR 
1c97				jp nz, type_faultn   
1c97				pop af 
1c97				endm 
1c97			 
1c97			FORTH_ERR_TOS_NOTNUM: macro 
1c97				push af 
1c97				ld a,(hl) 
1c97				cp DS_TYPE_INUM 
1c97				jp nz, type_faultn   
1c97				pop af 
1c97				endm 
1c97			 
1c97			 
1c97			; increase data stack pointer and save hl to it 
1c97				 
1c97			FORTH_DSP_NEXT: macro 
1c97				call macro_forth_dsp_next 
1c97				endm 
1c97			 
1c97			 
1c97			macro_forth_dsp_next: 
1c97				if DEBUG_FORTH_STACK_GUARD 
1c97 cd cc 62				call check_stacks 
1c9a				endif 
1c9a e5				push hl 
1c9b d5				push de 
1c9c eb				ex de,hl 
1c9d 2a 01 f8			ld hl,(cli_data_sp) 
1ca0 23				inc hl 
1ca1 23				inc hl 
1ca2			 
1ca2			; PARSEV5 
1ca2 23				inc hl 
1ca3 22 01 f8			ld (cli_data_sp),hl 
1ca6 73				ld (hl), e 
1ca7 23				inc hl 
1ca8 72				ld (hl), d 
1ca9 d1				pop de 
1caa e1				pop hl 
1cab				if DEBUG_FORTH_STACK_GUARD 
1cab cd cc 62				call check_stacks 
1cae				endif 
1cae c9				ret 
1caf			 
1caf			 
1caf			; increase ret stack pointer and save hl to it 
1caf				 
1caf			FORTH_RSP_NEXT: macro 
1caf				call macro_forth_rsp_next 
1caf				endm 
1caf			 
1caf			macro_forth_rsp_next: 
1caf				if DEBUG_FORTH_STACK_GUARD 
1caf cd cc 62				call check_stacks 
1cb2				endif 
1cb2 e5				push hl 
1cb3 d5				push de 
1cb4 eb				ex de,hl 
1cb5 2a 05 f8			ld hl,(cli_ret_sp) 
1cb8 23				inc hl 
1cb9 23				inc hl 
1cba 22 05 f8			ld (cli_ret_sp),hl 
1cbd 73				ld (hl), e 
1cbe 23				inc hl 
1cbf 72				ld (hl), d 
1cc0 d1				pop de 
1cc1 e1				pop hl 
1cc2				if DEBUG_FORTH_STACK_GUARD 
1cc2 cd cc 62				call check_stacks 
1cc5				endif 
1cc5 c9				ret 
1cc6			 
1cc6			; get current ret stack pointer and save to hl  
1cc6				 
1cc6			FORTH_RSP_TOS: macro 
1cc6				call macro_forth_rsp_tos 
1cc6				endm 
1cc6			 
1cc6			macro_forth_rsp_tos: 
1cc6				;push de 
1cc6 2a 05 f8			ld hl,(cli_ret_sp) 
1cc9 cd 01 1d			call loadhlptrtohl 
1ccc				;ld e, (hl) 
1ccc				;inc hl 
1ccc				;ld d, (hl) 
1ccc				;ex de, hl 
1ccc					if DEBUG_FORTH_WORDS 
1ccc			;			DMARK "RST" 
1ccc						CALLMONITOR 
1ccc cd ab 16			call break_point_state  
1ccf				endm  
# End of macro CALLMONITOR
1ccf					endif 
1ccf				;pop de 
1ccf c9				ret 
1cd0			 
1cd0			; pop ret stack pointer 
1cd0				 
1cd0			FORTH_RSP_POP: macro 
1cd0				call macro_forth_rsp_pop 
1cd0				endm 
1cd0			 
1cd0			 
1cd0			macro_forth_rsp_pop: 
1cd0				if DEBUG_FORTH_STACK_GUARD 
1cd0			;		DMARK "RPP" 
1cd0 cd cc 62				call check_stacks 
1cd3					FORTH_CHK_RSP_UNDER 
1cd3 e5				push hl 
1cd4 d5				push de 
1cd5 2a 05 f8			ld hl,(cli_ret_sp) 
1cd8 11 7f f7			ld de, cli_ret_stack 
1cdb cd 22 0d			call cmp16 
1cde da e0 63			jp c, fault_rsp_under 
1ce1 d1				pop de 
1ce2 e1				pop hl 
1ce3				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ce3				endif 
1ce3 e5				push hl 
1ce4 2a 05 f8			ld hl,(cli_ret_sp) 
1ce7			 
1ce7			 
1ce7				if FORTH_ENABLE_FREE 
1ce7			 
1ce7					; get pointer 
1ce7			 
1ce7					push de 
1ce7					push hl 
1ce7			 
1ce7					ld e, (hl) 
1ce7					inc hl 
1ce7					ld d, (hl) 
1ce7			 
1ce7					ex de, hl 
1ce7					call free 
1ce7			 
1ce7					pop hl 
1ce7					pop de 
1ce7			 
1ce7			 
1ce7				endif 
1ce7			 
1ce7			 
1ce7 2b				dec hl 
1ce8 2b				dec hl 
1ce9 22 05 f8			ld (cli_ret_sp), hl 
1cec				; do stack underflow checks 
1cec e1				pop hl 
1ced				if DEBUG_FORTH_STACK_GUARD 
1ced cd cc 62				call check_stacks 
1cf0					FORTH_CHK_RSP_UNDER 
1cf0 e5				push hl 
1cf1 d5				push de 
1cf2 2a 05 f8			ld hl,(cli_ret_sp) 
1cf5 11 7f f7			ld de, cli_ret_stack 
1cf8 cd 22 0d			call cmp16 
1cfb da e0 63			jp c, fault_rsp_under 
1cfe d1				pop de 
1cff e1				pop hl 
1d00				endm 
# End of macro FORTH_CHK_RSP_UNDER
1d00				endif 
1d00 c9				ret 
1d01			 
1d01			 
1d01			 
1d01			; routine to load word pointed to by hl into hl 
1d01			 
1d01			loadhlptrtohl: 
1d01			 
1d01 d5				push de 
1d02 5e				ld e, (hl) 
1d03 23				inc hl 
1d04 56				ld d, (hl) 
1d05 eb				ex de, hl 
1d06 d1				pop de 
1d07			 
1d07 c9				ret 
1d08			 
1d08			 
1d08			 
1d08			 
1d08			 
1d08			; push a number held in HL onto the data stack 
1d08			; entry point for pushing a value when already in hl used in function above 
1d08			 
1d08			forth_push_numhl: 
1d08			 
1d08 e5				push hl    ; save value to push 
1d09			 
1d09			if DEBUG_FORTH_PUSH 
1d09				; see if disabled 
1d09			 
1d09			 
1d09 f5				push af 
1d0a 3a 05 ee			ld a, (os_view_disable) 
1d0d fe 2a			cp '*' 
1d0f 28 34			jr z, .pskip2 
1d11 e5				push hl 
1d12 e5			push hl 
1d13 cd d0 0a			call clear_display 
1d16 e1			pop hl 
1d17 7c				ld a,h 
1d18 21 19 f1			ld hl, os_word_scratch 
1d1b cd 05 10			call hexout 
1d1e e1				pop hl 
1d1f 7d				ld a,l 
1d20 21 1b f1			ld hl, os_word_scratch+2 
1d23 cd 05 10			call hexout 
1d26			 
1d26 21 1d f1			ld hl, os_word_scratch+4 
1d29 3e 00			ld a,0 
1d2b 77				ld (hl),a 
1d2c 11 19 f1			ld de,os_word_scratch 
1d2f 3e 28				ld a, display_row_2 
1d31 cd e3 0a				call str_at_display 
1d34 11 da 51			ld de, .push_num 
1d37 3e 00			ld a, display_row_1 
1d39			 
1d39 cd e3 0a				call str_at_display 
1d3c			 
1d3c			 
1d3c cd f3 0a			call update_display 
1d3f cd 4d 0a			call delay1s 
1d42 cd 4d 0a			call delay1s 
1d45			.pskip2:  
1d45			 
1d45 f1				pop af 
1d46			endif	 
1d46			 
1d46			 
1d46				FORTH_DSP_NEXT 
1d46 cd 97 1c			call macro_forth_dsp_next 
1d49				endm 
# End of macro FORTH_DSP_NEXT
1d49			 
1d49 2a 01 f8			ld hl, (cli_data_sp) 
1d4c			 
1d4c				; save item type 
1d4c 3e 02			ld a,  DS_TYPE_INUM 
1d4e 77				ld (hl), a 
1d4f 23				inc hl 
1d50			 
1d50				; get word off stack 
1d50 d1				pop de 
1d51 7b				ld a,e 
1d52 77				ld (hl), a 
1d53 23				inc hl 
1d54 7a				ld a,d 
1d55 77				ld (hl), a 
1d56			 
1d56			if DEBUG_FORTH_PUSH 
1d56 2b				dec hl 
1d57 2b				dec hl 
1d58 2b				dec hl 
1d59						DMARK "PH5" 
1d59 f5				push af  
1d5a 3a 6e 1d			ld a, (.dmark)  
1d5d 32 6e fb			ld (debug_mark),a  
1d60 3a 6f 1d			ld a, (.dmark+1)  
1d63 32 6f fb			ld (debug_mark+1),a  
1d66 3a 70 1d			ld a, (.dmark+2)  
1d69 32 70 fb			ld (debug_mark+2),a  
1d6c 18 03			jr .pastdmark  
1d6e ..			.dmark: db "PH5"  
1d71 f1			.pastdmark: pop af  
1d72			endm  
# End of macro DMARK
1d72				CALLMONITOR 
1d72 cd ab 16			call break_point_state  
1d75				endm  
# End of macro CALLMONITOR
1d75			endif	 
1d75			 
1d75 c9				ret 
1d76			 
1d76			 
1d76			; Push a string to stack pointed to by hl 
1d76			 
1d76			forth_push_str: 
1d76			 
1d76			if DEBUG_FORTH_PUSH 
1d76						DMARK "PSQ" 
1d76 f5				push af  
1d77 3a 8b 1d			ld a, (.dmark)  
1d7a 32 6e fb			ld (debug_mark),a  
1d7d 3a 8c 1d			ld a, (.dmark+1)  
1d80 32 6f fb			ld (debug_mark+1),a  
1d83 3a 8d 1d			ld a, (.dmark+2)  
1d86 32 70 fb			ld (debug_mark+2),a  
1d89 18 03			jr .pastdmark  
1d8b ..			.dmark: db "PSQ"  
1d8e f1			.pastdmark: pop af  
1d8f			endm  
# End of macro DMARK
1d8f				CALLMONITOR 
1d8f cd ab 16			call break_point_state  
1d92				endm  
# End of macro CALLMONITOR
1d92			endif	 
1d92			    
1d92 e5				push hl 
1d93 e5				push hl 
1d94			 
1d94			;	ld a, 0   ; find end of string 
1d94 cd 62 11			call strlenz 
1d97			if DEBUG_FORTH_PUSH 
1d97						DMARK "PQ2" 
1d97 f5				push af  
1d98 3a ac 1d			ld a, (.dmark)  
1d9b 32 6e fb			ld (debug_mark),a  
1d9e 3a ad 1d			ld a, (.dmark+1)  
1da1 32 6f fb			ld (debug_mark+1),a  
1da4 3a ae 1d			ld a, (.dmark+2)  
1da7 32 70 fb			ld (debug_mark+2),a  
1daa 18 03			jr .pastdmark  
1dac ..			.dmark: db "PQ2"  
1daf f1			.pastdmark: pop af  
1db0			endm  
# End of macro DMARK
1db0				CALLMONITOR 
1db0 cd ab 16			call break_point_state  
1db3				endm  
# End of macro CALLMONITOR
1db3			endif	 
1db3 eb				ex de, hl 
1db4 e1				pop hl   ; get ptr to start of string 
1db5			if DEBUG_FORTH_PUSH 
1db5						DMARK "PQ3" 
1db5 f5				push af  
1db6 3a ca 1d			ld a, (.dmark)  
1db9 32 6e fb			ld (debug_mark),a  
1dbc 3a cb 1d			ld a, (.dmark+1)  
1dbf 32 6f fb			ld (debug_mark+1),a  
1dc2 3a cc 1d			ld a, (.dmark+2)  
1dc5 32 70 fb			ld (debug_mark+2),a  
1dc8 18 03			jr .pastdmark  
1dca ..			.dmark: db "PQ3"  
1dcd f1			.pastdmark: pop af  
1dce			endm  
# End of macro DMARK
1dce				CALLMONITOR 
1dce cd ab 16			call break_point_state  
1dd1				endm  
# End of macro CALLMONITOR
1dd1			endif	 
1dd1 19				add hl,de 
1dd2			if DEBUG_FORTH_PUSH 
1dd2						DMARK "PQE" 
1dd2 f5				push af  
1dd3 3a e7 1d			ld a, (.dmark)  
1dd6 32 6e fb			ld (debug_mark),a  
1dd9 3a e8 1d			ld a, (.dmark+1)  
1ddc 32 6f fb			ld (debug_mark+1),a  
1ddf 3a e9 1d			ld a, (.dmark+2)  
1de2 32 70 fb			ld (debug_mark+2),a  
1de5 18 03			jr .pastdmark  
1de7 ..			.dmark: db "PQE"  
1dea f1			.pastdmark: pop af  
1deb			endm  
# End of macro DMARK
1deb				CALLMONITOR 
1deb cd ab 16			call break_point_state  
1dee				endm  
# End of macro CALLMONITOR
1dee			endif	 
1dee			 
1dee 2b				dec hl    ; see if there is an optional trailing double quote 
1def 7e				ld a,(hl) 
1df0 fe 22			cp '"' 
1df2 20 03			jr nz, .strnoq 
1df4 3e 00			ld a, 0      ; get rid of double quote 
1df6 77				ld (hl), a 
1df7 23			.strnoq: inc hl 
1df8			 
1df8 3e 00			ld a, 0 
1dfa 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1dfb			 
1dfb 13				inc de ; add one for the type string 
1dfc 13				inc de ; add one for null term??? 
1dfd			 
1dfd				; tos is get string pointer again 
1dfd				; de contains space to allocate 
1dfd				 
1dfd d5				push de 
1dfe			 
1dfe eb				ex de, hl 
1dff			 
1dff				;push af 
1dff			 
1dff			if DEBUG_FORTH_PUSH 
1dff						DMARK "PHm" 
1dff f5				push af  
1e00 3a 14 1e			ld a, (.dmark)  
1e03 32 6e fb			ld (debug_mark),a  
1e06 3a 15 1e			ld a, (.dmark+1)  
1e09 32 6f fb			ld (debug_mark+1),a  
1e0c 3a 16 1e			ld a, (.dmark+2)  
1e0f 32 70 fb			ld (debug_mark+2),a  
1e12 18 03			jr .pastdmark  
1e14 ..			.dmark: db "PHm"  
1e17 f1			.pastdmark: pop af  
1e18			endm  
# End of macro DMARK
1e18				CALLMONITOR 
1e18 cd ab 16			call break_point_state  
1e1b				endm  
# End of macro CALLMONITOR
1e1b			endif	 
1e1b cd cb 11			call malloc	; on ret hl now contains allocated memory 
1e1e				if DEBUG_FORTH_MALLOC_GUARD 
1e1e cc 32 52				call z,malloc_error 
1e21				endif 
1e21			 
1e21				 
1e21 c1				pop bc    ; get length 
1e22 d1				pop de   ;  get string start    
1e23			 
1e23				; hl has destination from malloc 
1e23			 
1e23 eb				ex de, hl    ; prep for ldir 
1e24			 
1e24 d5				push de   ; save malloc area for DSP later 
1e25				;push hl   ; save malloc area for DSP later 
1e25			 
1e25			if DEBUG_FORTH_PUSH 
1e25						DMARK "PHc" 
1e25 f5				push af  
1e26 3a 3a 1e			ld a, (.dmark)  
1e29 32 6e fb			ld (debug_mark),a  
1e2c 3a 3b 1e			ld a, (.dmark+1)  
1e2f 32 6f fb			ld (debug_mark+1),a  
1e32 3a 3c 1e			ld a, (.dmark+2)  
1e35 32 70 fb			ld (debug_mark+2),a  
1e38 18 03			jr .pastdmark  
1e3a ..			.dmark: db "PHc"  
1e3d f1			.pastdmark: pop af  
1e3e			endm  
# End of macro DMARK
1e3e				CALLMONITOR 
1e3e cd ab 16			call break_point_state  
1e41				endm  
# End of macro CALLMONITOR
1e41			endif	 
1e41			 
1e41			 
1e41 ed b0			ldir 
1e43			 
1e43			 
1e43				; push malloc to data stack     macro?????  
1e43			 
1e43				FORTH_DSP_NEXT 
1e43 cd 97 1c			call macro_forth_dsp_next 
1e46				endm 
# End of macro FORTH_DSP_NEXT
1e46			 
1e46				; save value and type 
1e46			 
1e46 2a 01 f8			ld hl, (cli_data_sp) 
1e49			 
1e49				; save item type 
1e49 3e 01			ld a,  DS_TYPE_STR 
1e4b 77				ld (hl), a 
1e4c 23				inc hl 
1e4d			 
1e4d				; get malloc word off stack 
1e4d d1				pop de 
1e4e 73				ld (hl), e 
1e4f 23				inc hl 
1e50 72				ld (hl), d 
1e51			 
1e51			 
1e51			 
1e51			if DEBUG_FORTH_PUSH 
1e51 2a 01 f8			ld hl, (cli_data_sp) 
1e54						DMARK "PHS" 
1e54 f5				push af  
1e55 3a 69 1e			ld a, (.dmark)  
1e58 32 6e fb			ld (debug_mark),a  
1e5b 3a 6a 1e			ld a, (.dmark+1)  
1e5e 32 6f fb			ld (debug_mark+1),a  
1e61 3a 6b 1e			ld a, (.dmark+2)  
1e64 32 70 fb			ld (debug_mark+2),a  
1e67 18 03			jr .pastdmark  
1e69 ..			.dmark: db "PHS"  
1e6c f1			.pastdmark: pop af  
1e6d			endm  
# End of macro DMARK
1e6d				CALLMONITOR 
1e6d cd ab 16			call break_point_state  
1e70				endm  
# End of macro CALLMONITOR
1e70			;	ex de,hl 
1e70			endif	 
1e70				; in case of spaces, skip the ptr past the copied string 
1e70				;pop af 
1e70				;ld (cli_origptr),hl 
1e70			 
1e70 c9				ret 
1e71			 
1e71			 
1e71			 
1e71			; TODO ascii push input onto stack given hl to start of input 
1e71			 
1e71			; identify type 
1e71			; if starts with a " then a string 
1e71			; otherwise it is a number 
1e71			;  
1e71			; if a string 
1e71			;     scan for ending " to get length of string to malloc for + 1 
1e71			;     malloc 
1e71			;     put pointer to string on stack first byte flags as string 
1e71			; 
1e71			; else a number 
1e71			;    look for number format identifier 
1e71			;    $xx hex 
1e71			;    %xxxxx bin 
1e71			;    xxxxx decimal 
1e71			;    convert number to 16bit word.  
1e71			;    malloc word + 1 with flag to identiy as num 
1e71			;    put pointer to number on stack 
1e71			;   
1e71			;  
1e71			  
1e71			forth_apush: 
1e71				; kernel push 
1e71			 
1e71			if DEBUG_FORTH_PUSH 
1e71						DMARK "PSH" 
1e71 f5				push af  
1e72 3a 86 1e			ld a, (.dmark)  
1e75 32 6e fb			ld (debug_mark),a  
1e78 3a 87 1e			ld a, (.dmark+1)  
1e7b 32 6f fb			ld (debug_mark+1),a  
1e7e 3a 88 1e			ld a, (.dmark+2)  
1e81 32 70 fb			ld (debug_mark+2),a  
1e84 18 03			jr .pastdmark  
1e86 ..			.dmark: db "PSH"  
1e89 f1			.pastdmark: pop af  
1e8a			endm  
# End of macro DMARK
1e8a				CALLMONITOR 
1e8a cd ab 16			call break_point_state  
1e8d				endm  
# End of macro CALLMONITOR
1e8d			endif	 
1e8d				; identify input type 
1e8d			 
1e8d 7e				ld a,(hl) 
1e8e fe 22			cp '"' 
1e90 28 0a			jr z, .fapstr 
1e92 fe 24			cp '$' 
1e94 ca bc 1e			jp z, .faphex 
1e97 fe 25			cp '%' 
1e99 ca a4 1e			jp z, .fapbin 
1e9c			;	cp 'b' 
1e9c			;	jp z, .fabin 
1e9c				; else decimal 
1e9c			 
1e9c				; TODO do decimal conversion 
1e9c				; decimal is stored as a 16bit word 
1e9c			 
1e9c				; by default everything is a string if type is not detected 
1e9c			.fapstr: ; 
1e9c fe 22			cp '"' 
1e9e 20 01			jr nz, .strnoqu 
1ea0 23				inc hl 
1ea1			.strnoqu: 
1ea1 c3 76 1d			jp forth_push_str 
1ea4			 
1ea4			 
1ea4			 
1ea4			.fapbin:    ; push a binary string.  
1ea4 11 00 00			ld de, 0   ; hold a 16bit value 
1ea7			 
1ea7 23			.fapbinshift:	inc hl  
1ea8 7e				ld a,(hl) 
1ea9 fe 00			cp 0     ; done scanning  
1eab 28 0b			jr z, .fapbdone  	; got it in HL so push  
1ead			 
1ead				; left shift de 
1ead eb				ex de, hl	 
1eae 29				add hl, hl 
1eaf			 
1eaf				; is 1 
1eaf fe 31			cp '1' 
1eb1 20 02			jr nz, .binzero 
1eb3 cb 4d			bit 1, l 
1eb5			.binzero: 
1eb5 eb				ex de, hl	 ; save current de 
1eb6 18 ef			jr .fapbinshift 
1eb8			 
1eb8			.fapbdone: 
1eb8 eb				ex de, hl 
1eb9 c3 08 1d			jp forth_push_numhl 
1ebc			 
1ebc			 
1ebc			.faphex:   ; hex is always stored as a 16bit word 
1ebc				; skip number prefix 
1ebc 23				inc hl 
1ebd				; turn ascii into number 
1ebd cd bb 10			call get_word_hl	; ret 16bit word in hl 
1ec0			 
1ec0 c3 08 1d			jp forth_push_numhl 
1ec3			 
1ec3 00				 nop 
1ec4			 
1ec4			.fabin:   ; TODO bin conversion 
1ec4			 
1ec4			 
1ec4 c9				ret 
1ec5			 
1ec5			 
1ec5			; get either a string ptr or a 16bit word from the data stack 
1ec5			 
1ec5			FORTH_DSP: macro 
1ec5				call macro_forth_dsp 
1ec5				endm 
1ec5			 
1ec5			macro_forth_dsp: 
1ec5				; data stack pointer points to current word on tos 
1ec5			 
1ec5 2a 01 f8			ld hl,(cli_data_sp) 
1ec8			 
1ec8				if DEBUG_FORTH_PUSH 
1ec8						DMARK "DSP" 
1ec8 f5				push af  
1ec9 3a dd 1e			ld a, (.dmark)  
1ecc 32 6e fb			ld (debug_mark),a  
1ecf 3a de 1e			ld a, (.dmark+1)  
1ed2 32 6f fb			ld (debug_mark+1),a  
1ed5 3a df 1e			ld a, (.dmark+2)  
1ed8 32 70 fb			ld (debug_mark+2),a  
1edb 18 03			jr .pastdmark  
1edd ..			.dmark: db "DSP"  
1ee0 f1			.pastdmark: pop af  
1ee1			endm  
# End of macro DMARK
1ee1			 
1ee1 cd 67 52				call display_data_sp 
1ee4				;call break_point_state 
1ee4				;rst 030h 
1ee4				CALLMONITOR 
1ee4 cd ab 16			call break_point_state  
1ee7				endm  
# End of macro CALLMONITOR
1ee7				endif 
1ee7			 
1ee7 c9				ret 
1ee8			 
1ee8			; return hl to start of value on stack 
1ee8			 
1ee8			FORTH_DSP_VALUE: macro 
1ee8				call macro_forth_dsp_value 
1ee8				endm 
1ee8			 
1ee8			macro_forth_dsp_value: 
1ee8			 
1ee8				FORTH_DSP 
1ee8 cd c5 1e			call macro_forth_dsp 
1eeb				endm 
# End of macro FORTH_DSP
1eeb			 
1eeb d5				push de 
1eec			 
1eec 23				inc hl ; skip type 
1eed			 
1eed 5e				ld e, (hl) 
1eee 23				inc hl 
1eef 56				ld d, (hl) 
1ef0 eb				ex de,hl  
1ef1			 
1ef1 d1				pop de 
1ef2			 
1ef2 c9				ret 
1ef3			 
1ef3			; return hl to start of value to second item on stack 
1ef3			 
1ef3			FORTH_DSP_VALUEM1: macro 
1ef3				call macro_forth_dsp_value_m1 
1ef3				endm 
1ef3			 
1ef3			macro_forth_dsp_value_m1: 
1ef3			 
1ef3				FORTH_DSP 
1ef3 cd c5 1e			call macro_forth_dsp 
1ef6				endm 
# End of macro FORTH_DSP
1ef6			 
1ef6 2b				dec hl 
1ef7 2b				dec hl 
1ef8			;	dec hl 
1ef8			 
1ef8 d5				push de 
1ef9			 
1ef9 5e				ld e, (hl) 
1efa 23				inc hl 
1efb 56				ld d, (hl) 
1efc eb				ex de,hl  
1efd			 
1efd d1				pop de 
1efe			 
1efe c9				ret 
1eff			 
1eff				 
1eff			 
1eff			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1eff			 
1eff			FORTH_DSP_POP: macro 
1eff				call macro_forth_dsp_pop 
1eff				endm 
1eff			 
1eff			 
1eff			; get the tos data type 
1eff			 
1eff			FORTH_DSP_TYPE:   macro 
1eff			 
1eff				;FORTH_DSP_VALUE 
1eff				FORTH_DSP 
1eff				 
1eff				; hl points to value 
1eff				; check type 
1eff			 
1eff				ld a,(hl) 
1eff			 
1eff				endm 
1eff			 
1eff			; load the tos value into hl 
1eff			 
1eff			 
1eff			FORTH_DSP_VALUEHL:  macro 
1eff				call macro_dsp_valuehl 
1eff				endm 
1eff			 
1eff			 
1eff			 
1eff			macro_dsp_valuehl: 
1eff				FORTH_DSP_VALUE 
1eff cd e8 1e			call macro_forth_dsp_value 
1f02				endm 
# End of macro FORTH_DSP_VALUE
1f02			 
1f02				;FORTH_ERR_TOS_NOTNUM 
1f02			 
1f02				;inc hl   ; skip type id 
1f02			 
1f02			;	push de 
1f02			; 
1f02			;	ld e, (hl) 
1f02			;	inc hl 
1f02			;	ld d, (hl) 
1f02			;	ex de,hl  
1f02			 
1f02			;	pop de 
1f02			 
1f02				if DEBUG_FORTH_PUSH 
1f02						DMARK "DVL" 
1f02 f5				push af  
1f03 3a 17 1f			ld a, (.dmark)  
1f06 32 6e fb			ld (debug_mark),a  
1f09 3a 18 1f			ld a, (.dmark+1)  
1f0c 32 6f fb			ld (debug_mark+1),a  
1f0f 3a 19 1f			ld a, (.dmark+2)  
1f12 32 70 fb			ld (debug_mark+2),a  
1f15 18 03			jr .pastdmark  
1f17 ..			.dmark: db "DVL"  
1f1a f1			.pastdmark: pop af  
1f1b			endm  
# End of macro DMARK
1f1b				CALLMONITOR 
1f1b cd ab 16			call break_point_state  
1f1e				endm  
# End of macro CALLMONITOR
1f1e				endif 
1f1e c9				ret 
1f1f			 
1f1f			forth_apushstrhl:      
1f1f				; push of string requires use of cli_origptr 
1f1f				; bodge use 
1f1f			 
1f1f				; get current cli_origptr, save, update with temp pointer  
1f1f ed 5b 1d f8		ld de, (cli_origptr) 
1f23 22 1d f8			ld (cli_origptr), hl 
1f26 d5				push de 
1f27 cd 71 1e			call forth_apush 
1f2a d1				pop de 
1f2b ed 53 1d f8		ld (cli_origptr), de 
1f2f c9			        ret	 
1f30			 
1f30			 
1f30			; increase loop stack pointer and save hl to it 
1f30				 
1f30			FORTH_LOOP_NEXT: macro 
1f30				call macro_forth_loop_next 
1f30				;nop 
1f30				endm 
1f30			 
1f30			macro_forth_loop_next: 
1f30				if DEBUG_FORTH_STACK_GUARD 
1f30 cd cc 62				call check_stacks 
1f33				endif 
1f33 e5				push hl 
1f34 d5				push de 
1f35 eb				ex de,hl 
1f36 2a 03 f8			ld hl,(cli_loop_sp) 
1f39 23				inc hl 
1f3a 23				inc hl 
1f3b					if DEBUG_FORTH_WORDS 
1f3b						DMARK "LNX" 
1f3b f5				push af  
1f3c 3a 50 1f			ld a, (.dmark)  
1f3f 32 6e fb			ld (debug_mark),a  
1f42 3a 51 1f			ld a, (.dmark+1)  
1f45 32 6f fb			ld (debug_mark+1),a  
1f48 3a 52 1f			ld a, (.dmark+2)  
1f4b 32 70 fb			ld (debug_mark+2),a  
1f4e 18 03			jr .pastdmark  
1f50 ..			.dmark: db "LNX"  
1f53 f1			.pastdmark: pop af  
1f54			endm  
# End of macro DMARK
1f54						CALLMONITOR 
1f54 cd ab 16			call break_point_state  
1f57				endm  
# End of macro CALLMONITOR
1f57					endif 
1f57 22 03 f8			ld (cli_loop_sp),hl 
1f5a 73				ld (hl), e 
1f5b 23				inc hl 
1f5c 72				ld (hl), d 
1f5d d1				pop de    ; been reversed so save a swap on restore 
1f5e e1				pop hl 
1f5f				if DEBUG_FORTH_STACK_GUARD 
1f5f cd cc 62				call check_stacks 
1f62				endif 
1f62 c9				ret 
1f63			 
1f63			; get current ret stack pointer and save to hl  
1f63				 
1f63			FORTH_LOOP_TOS: macro 
1f63				call macro_forth_loop_tos 
1f63				endm 
1f63			 
1f63			macro_forth_loop_tos: 
1f63 d5				push de 
1f64 2a 03 f8			ld hl,(cli_loop_sp) 
1f67 5e				ld e, (hl) 
1f68 23				inc hl 
1f69 56				ld d, (hl) 
1f6a eb				ex de, hl 
1f6b d1				pop de 
1f6c c9				ret 
1f6d			 
1f6d			; pop loop stack pointer 
1f6d				 
1f6d			FORTH_LOOP_POP: macro 
1f6d				call macro_forth_loop_pop 
1f6d				endm 
1f6d			 
1f6d			 
1f6d			macro_forth_loop_pop: 
1f6d				if DEBUG_FORTH_STACK_GUARD 
1f6d					DMARK "LPP" 
1f6d f5				push af  
1f6e 3a 82 1f			ld a, (.dmark)  
1f71 32 6e fb			ld (debug_mark),a  
1f74 3a 83 1f			ld a, (.dmark+1)  
1f77 32 6f fb			ld (debug_mark+1),a  
1f7a 3a 84 1f			ld a, (.dmark+2)  
1f7d 32 70 fb			ld (debug_mark+2),a  
1f80 18 03			jr .pastdmark  
1f82 ..			.dmark: db "LPP"  
1f85 f1			.pastdmark: pop af  
1f86			endm  
# End of macro DMARK
1f86 cd cc 62				call check_stacks 
1f89					FORTH_CHK_LOOP_UNDER 
1f89 e5				push hl 
1f8a d5				push de 
1f8b 2a 03 f8			ld hl,(cli_loop_sp) 
1f8e 11 7d f5			ld de, cli_loop_stack 
1f91 cd 22 0d			call cmp16 
1f94 da e6 63			jp c, fault_loop_under 
1f97 d1				pop de 
1f98 e1				pop hl 
1f99				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f99				endif 
1f99 e5				push hl 
1f9a 2a 03 f8			ld hl,(cli_loop_sp) 
1f9d 2b				dec hl 
1f9e 2b				dec hl 
1f9f 22 03 f8			ld (cli_loop_sp), hl 
1fa2				; TODO do stack underflow checks 
1fa2 e1				pop hl 
1fa3				if DEBUG_FORTH_STACK_GUARD 
1fa3 cd cc 62				call check_stacks 
1fa6					FORTH_CHK_LOOP_UNDER 
1fa6 e5				push hl 
1fa7 d5				push de 
1fa8 2a 03 f8			ld hl,(cli_loop_sp) 
1fab 11 7d f5			ld de, cli_loop_stack 
1fae cd 22 0d			call cmp16 
1fb1 da e6 63			jp c, fault_loop_under 
1fb4 d1				pop de 
1fb5 e1				pop hl 
1fb6				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1fb6				endif 
1fb6 c9				ret 
1fb7			 
1fb7			macro_forth_dsp_pop: 
1fb7			 
1fb7 e5				push hl 
1fb8			 
1fb8				; release malloc data 
1fb8			 
1fb8				if DEBUG_FORTH_STACK_GUARD 
1fb8 cd cc 62				call check_stacks 
1fbb					FORTH_CHK_DSP_UNDER 
1fbb e5				push hl 
1fbc d5				push de 
1fbd 2a 01 f8			ld hl,(cli_data_sp) 
1fc0 11 7b f3			ld de, cli_data_stack 
1fc3 cd 22 0d			call cmp16 
1fc6 da da 63			jp c, fault_dsp_under 
1fc9 d1				pop de 
1fca e1				pop hl 
1fcb				endm 
# End of macro FORTH_CHK_DSP_UNDER
1fcb				endif 
1fcb				;ld hl,(cli_data_sp) 
1fcb			if DEBUG_FORTH_DOT 
1fcb				DMARK "DPP" 
1fcb				CALLMONITOR 
1fcb			endif	 
1fcb			 
1fcb			 
1fcb			if FORTH_ENABLE_DSPPOPFREE 
1fcb			 
1fcb				FORTH_DSP 
1fcb cd c5 1e			call macro_forth_dsp 
1fce				endm 
# End of macro FORTH_DSP
1fce			 
1fce 7e				ld a, (hl) 
1fcf fe 01			cp DS_TYPE_STR 
1fd1 20 07			jr nz, .skippopfree 
1fd3			 
1fd3				FORTH_DSP_VALUEHL 
1fd3 cd ff 1e			call macro_dsp_valuehl 
1fd6				endm 
# End of macro FORTH_DSP_VALUEHL
1fd6 00				nop 
1fd7			if DEBUG_FORTH_DOT 
1fd7				DMARK "DPf" 
1fd7				CALLMONITOR 
1fd7			endif	 
1fd7 cd 95 12			call free 
1fda			.skippopfree: 
1fda				 
1fda			 
1fda			endif 
1fda			 
1fda			if DEBUG_FORTH_DOT_KEY 
1fda				DMARK "DP2" 
1fda				CALLMONITOR 
1fda			endif	 
1fda			 
1fda				; move pointer down 
1fda			 
1fda 2a 01 f8			ld hl,(cli_data_sp) 
1fdd 2b				dec hl 
1fde 2b				dec hl 
1fdf			; PARSEV5 
1fdf 2b				dec hl 
1fe0 22 01 f8			ld (cli_data_sp), hl 
1fe3			 
1fe3				if DEBUG_FORTH_STACK_GUARD 
1fe3 cd cc 62				call check_stacks 
1fe6					FORTH_CHK_DSP_UNDER 
1fe6 e5				push hl 
1fe7 d5				push de 
1fe8 2a 01 f8			ld hl,(cli_data_sp) 
1feb 11 7b f3			ld de, cli_data_stack 
1fee cd 22 0d			call cmp16 
1ff1 da da 63			jp c, fault_dsp_under 
1ff4 d1				pop de 
1ff5 e1				pop hl 
1ff6				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ff6				endif 
1ff6			 
1ff6 e1				pop hl 
1ff7			 
1ff7 c9				ret 
1ff8			 
1ff8			getwordathl: 
1ff8				; hl points to an address 
1ff8				; load hl with the word at that address 
1ff8			 
1ff8 d5				push de 
1ff9			 
1ff9 5e				ld e, (hl) 
1ffa 23				inc hl 
1ffb 56				ld d, (hl) 
1ffc eb				ex de, hl 
1ffd			 
1ffd d1				pop de 
1ffe c9				ret 
1fff			 
1fff			 
1fff			 
1fff			 
1fff			 
1fff			; eof 
1fff			 
# End of file forth_stackopsv5.asm
1fff			endif 
1fff			 
1fff			user_word_eol:  
1fff				; hl contains the pointer to where to create a linked list item from the end 
1fff				; of the user dict to continue on at the system word dict 
1fff				 
1fff				; poke the stub of the word list linked list to repoint to rom words 
1fff			 
1fff				; stub format 
1fff				; db   word id 
1fff				; dw    link to next word 
1fff			        ; db char length of token 
1fff				; db string + 0 term 
1fff				; db exec code....  
1fff			 
1fff 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2001 77				ld (hl), a		; word id 
2002 23				inc hl 
2003			 
2003 11 c9 21			ld de, sysdict 
2006 73				ld (hl), e		; next word link ie system dict 
2007 23				inc hl 
2008 72				ld (hl), d		; next word link ie system dict 
2009 23				inc hl	 
200a			 
200a			;	ld (hl), sysdict		; next word link ie system dict 
200a			;	inc hl 
200a			;	inc hl 
200a			 
200a			;	inc hl 
200a			;	inc hl 
200a			 
200a 3e 02			ld a, 2			; word length is 0 
200c 77				ld (hl), a	 
200d 23				inc hl 
200e			 
200e 3e 7e			ld a, '~'			; word length is 0 
2010 77				ld (hl), a	 
2011 23				inc hl 
2012 3e 00			ld a, 0			; save empty word 
2014 77				ld (hl), a 
2015			 
2015 c9				ret 
2016			 
2016				 
2016			 
2016			forthexec_cleanup: 
2016				FORTH_RSP_POP 
2016 cd d0 1c			call macro_forth_rsp_pop 
2019				endm 
# End of macro FORTH_RSP_POP
2019 c9				ret 
201a			 
201a			forth_call_hl: 
201a				; taking hl 
201a e5				push hl 
201b c9				ret 
201c			 
201c			; this is called to reset Forth system but keep existing uwords etc 
201c			 
201c			forth_warmstart: 
201c				; setup stack over/under flow checks 
201c				if DEBUG_FORTH_STACK_GUARD 
201c cd b2 62				call chk_stk_init 
201f				endif 
201f			 
201f				; init stack pointers  - * these stacks go upwards *  
201f 21 7f f7			ld hl, cli_ret_stack 
2022 22 05 f8			ld (cli_ret_sp), hl	 
2025				; set bottom of stack 
2025 3e 00			ld a,0 
2027 77				ld (hl),a 
2028 23				inc hl 
2029 77				ld (hl),a 
202a			 
202a 21 7b f3			ld hl, cli_data_stack 
202d 22 01 f8			ld (cli_data_sp), hl	 
2030				; set bottom of stack 
2030 3e 00			ld a,0 
2032 77				ld (hl),a 
2033 23				inc hl 
2034 77				ld (hl),a 
2035			 
2035 21 7d f5			ld hl, cli_loop_stack 
2038 22 03 f8			ld (cli_loop_sp), hl	 
203b				; set bottom of stack 
203b 3e 00			ld a,0 
203d 77				ld (hl),a 
203e 23				inc hl 
203f 77				ld (hl),a 
2040			 
2040				; init extent of current open file 
2040			 
2040 3e 00			ld a, 0 
2042 32 50 f8			ld (store_openext), a 
2045			 
2045 c9				ret 
2046			 
2046			 
2046			; Cold Start - this is called to setup the whole Forth system 
2046			 
2046			forth_init: 
2046			 
2046				; setup stack over/under flow checks 
2046			 
2046			;	if DEBUG_FORTH_STACK_GUARD 
2046			;		call chk_stk_init 
2046			;	endif 
2046			 
2046				; enable auto display updates (slow.....) 
2046			 
2046 3e 01			ld a, 1 
2048 32 1b f8			ld (cli_autodisplay), a 
204b			 
204b			 
204b			 
204b				; show start up screen 
204b			 
204b cd d0 0a			call clear_display 
204e			 
204e 3e 00			ld a,0 
2050 32 3d f8			ld (f_cursor_ptr), a 
2053			 
2053				; set start of word list in start of ram - for use when creating user words 
2053			 
2053 21 00 80			ld hl, baseram 
2056 22 11 f1			ld (os_last_new_uword), hl 
2059 cd ff 1f			call user_word_eol 
205c				 
205c			;		call display_data_sp 
205c			;		call next_page_prompt 
205c			 
205c			 
205c			 
205c			 
205c c9				ret 
205d			 
205d .. 00		.bootforth: db " Forth Kernel Init ",0 
2071			 
2071			; TODO push to stack 
2071			 
2071			;  
2071			 
2071			if FORTH_PARSEV2 
2071			 
2071			 
2071				include "forth_parserv2.asm" 
2071			 
2071			endif 
2071			 
2071			 
2071			; parse cli version 1 
2071			 
2071			if FORTH_PARSEV1 
2071			 
2071			 
2071			 
2071			      include "forth_parserv1.asm" 
2071			endif 
2071				 
2071			if FORTH_PARSEV3 
2071			 
2071			 
2071			 
2071			      include "forth_parserv3.asm" 
2071				include "forth_wordsv3.asm" 
2071			endif 
2071			 
2071			if FORTH_PARSEV4 
2071			 
2071			 
2071			 
2071			      include "forth_parserv4.asm" 
2071				include "forth_wordsv4.asm" 
2071			endif 
2071			 
2071			if FORTH_PARSEV5 
2071			 
2071			 
2071			 
2071			      include "forth_parserv5.asm" 
2071			 
2071			 
2071			; A better parser without using malloc and string copies all over the place.  
2071			; Exec in situ should be faster 
2071			 
2071			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2071			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2071			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2071			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2071			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2071			WORD_SYS_END: equ 0   ; Opcode for all user words 
2071			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2071			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2071			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2071			 
2071			; Core word preamble macro 
2071			 
2071			CWHEAD:   macro nxtword opcode lit len opflags 
2071				db WORD_SYS_CORE+opcode             
2071				; internal op code number 
2071				dw nxtword            
2071				; link to next dict word block 
2071				db len + 1 
2071				; literal length of dict word inc zero term 
2071				db lit,0              
2071				; literal dict word 
2071			        ; TODO db opflags        
2071				endm 
2071			 
2071			 
2071			NEXTW: macro  
2071				jp macro_next 
2071				endm 
2071			 
2071			macro_next: 
2071			if DEBUG_FORTH_PARSE_KEY 
2071				DMARK "NXT" 
2071				CALLMONITOR 
2071			endif	 
2071			;	inc hl  ; skip token null term  
2071 ed 4b 1f f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2075 ed 5b 1d f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2079 2a 15 f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
207c			if DEBUG_FORTH_PARSE_KEY 
207c				DMARK "}AA" 
207c				CALLMONITOR 
207c			endif	 
207c c3 7f 21			jp execnext 
207f				;jp exec1 
207f			       
207f			 
207f			 
207f			; Another go at the parser to compile  
207f			 
207f			 
207f			; TODO rework parser to change all of the string words to byte tokens 
207f			; TODO do a search for  
207f			 
207f			; TODO first run normal parser to zero term sections 
207f			; TODO for each word do a token look up to get the op code 
207f			; TODO need some means to flag to the exec that this is a byte code form    
207f			 
207f			 
207f			forthcompile: 
207f			 
207f			; 
207f			; line parse: 
207f			;       parse raw input buffer 
207f			;       tokenise the words 
207f			;       malloc new copy (for looping etc) 
207f			;       copy to malloc + current pc in line to start of string and add line term 
207f			;       save on new rsp 
207f			; 
207f			 
207f			; hl to point to the line to tokenise 
207f			 
207f			;	push hl 
207f 22 15 f1			ld (os_tok_ptr), hl  ; save ptr to string 
2082			 
2082			;	ld a,0		; string term on input 
2082			;	call strlent 
2082			 
2082			;	ld (os_tok_len), hl	 ; save string length 
2082			 
2082			;if DEBUG_FORTH_TOK 
2082			;	ex de,hl		 
2082			;endif 
2082			 
2082			;	pop hl 		; get back string pointer 
2082			 
2082			if DEBUG_FORTH_TOK 
2082						DMARK "TOc" 
2082				CALLMONITOR 
2082			endif 
2082 7e			.cptoken2:    ld a,(hl) 
2083 23				inc hl 
2084 fe 7f			cp FORTH_END_BUFFER 
2086 28 29			jr z, .cptokendone2 
2088 fe 00			cp 0 
208a 28 25			jr z, .cptokendone2 
208c fe 22			cp '"' 
208e 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2090 fe 20			cp ' ' 
2092 20 ee			jr nz,  .cptoken2 
2094			 
2094			; TODO consume comments held between ( and ) 
2094			 
2094				; we have a space so change to zero term for dict match later 
2094 2b				dec hl 
2095 3e 00			ld a,0 
2097 77				ld (hl), a 
2098 23				inc hl 
2099 18 e7			jr .cptoken2 
209b				 
209b			 
209b			.cptokenstr2: 
209b				; skip all white space until either eol (because forgot to term) or end double quote 
209b			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
209b				;inc hl ; skip current double quote 
209b 7e				ld a,(hl) 
209c 23				inc hl 
209d fe 22			cp '"' 
209f 28 e1			jr z, .cptoken2 
20a1 fe 7f			cp FORTH_END_BUFFER 
20a3 28 0c			jr z, .cptokendone2 
20a5 fe 00			cp 0 
20a7 28 08			jr z, .cptokendone2 
20a9 fe 20			cp ' ' 
20ab 28 02			jr z, .cptmp2 
20ad 18 ec			jr .cptokenstr2 
20af			 
20af			.cptmp2:	; we have a space so change to zero term for dict match later 
20af				;dec hl 
20af				;ld a,"-"	; TODO remove this when working 
20af				;ld (hl), a 
20af				;inc hl 
20af 18 ea			jr .cptokenstr2 
20b1			 
20b1			.cptokendone2: 
20b1				;inc hl 
20b1 3e 7f			ld a, FORTH_END_BUFFER 
20b3 77				ld (hl),a 
20b4 23				inc hl 
20b5 3e 21			ld a, '!' 
20b7 77				ld (hl),a 
20b8			 
20b8 2a 15 f1			ld hl,(os_tok_ptr) 
20bb			         
20bb			if DEBUG_FORTH_TOK 
20bb						DMARK "Tc1" 
20bb				CALLMONITOR 
20bb			endif 
20bb			 
20bb				; push exec string to top of return stack 
20bb				FORTH_RSP_NEXT 
20bb cd af 1c			call macro_forth_rsp_next 
20be				endm 
# End of macro FORTH_RSP_NEXT
20be c9				ret 
20bf			 
20bf			; Another go at the parser need to simplify the process 
20bf			 
20bf			forthparse: 
20bf			 
20bf			; 
20bf			; line parse: 
20bf			;       parse raw input buffer 
20bf			;       tokenise the words 
20bf			;       malloc new copy (for looping etc) 
20bf			;       copy to malloc + current pc in line to start of string and add line term 
20bf			;       save on new rsp 
20bf			; 
20bf			 
20bf			; hl to point to the line to tokenise 
20bf			 
20bf			;	push hl 
20bf 22 15 f1			ld (os_tok_ptr), hl  ; save ptr to string 
20c2			 
20c2			;	ld a,0		; string term on input 
20c2			;	call strlent 
20c2			 
20c2			;	ld (os_tok_len), hl	 ; save string length 
20c2			 
20c2			;if DEBUG_FORTH_TOK 
20c2			;	ex de,hl		 
20c2			;endif 
20c2			 
20c2			;	pop hl 		; get back string pointer 
20c2			 
20c2			if DEBUG_FORTH_TOK 
20c2						DMARK "TOK" 
20c2				CALLMONITOR 
20c2			endif 
20c2 7e			.ptoken2:    ld a,(hl) 
20c3 23				inc hl 
20c4 fe 7f			cp FORTH_END_BUFFER 
20c6 28 29			jr z, .ptokendone2 
20c8 fe 00			cp 0 
20ca 28 25			jr z, .ptokendone2 
20cc fe 22			cp '"' 
20ce 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
20d0 fe 20			cp ' ' 
20d2 20 ee			jr nz,  .ptoken2 
20d4			 
20d4			; TODO consume comments held between ( and ) 
20d4			 
20d4				; we have a space so change to zero term for dict match later 
20d4 2b				dec hl 
20d5 3e 00			ld a,0 
20d7 77				ld (hl), a 
20d8 23				inc hl 
20d9 18 e7			jr .ptoken2 
20db				 
20db			 
20db			.ptokenstr2: 
20db				; skip all white space until either eol (because forgot to term) or end double quote 
20db			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
20db				;inc hl ; skip current double quote 
20db 7e				ld a,(hl) 
20dc 23				inc hl 
20dd fe 22			cp '"' 
20df 28 e1			jr z, .ptoken2 
20e1 fe 7f			cp FORTH_END_BUFFER 
20e3 28 0c			jr z, .ptokendone2 
20e5 fe 00			cp 0 
20e7 28 08			jr z, .ptokendone2 
20e9 fe 20			cp ' ' 
20eb 28 02			jr z, .ptmp2 
20ed 18 ec			jr .ptokenstr2 
20ef			 
20ef			.ptmp2:	; we have a space so change to zero term for dict match later 
20ef				;dec hl 
20ef				;ld a,"-"	; TODO remove this when working 
20ef				;ld (hl), a 
20ef				;inc hl 
20ef 18 ea			jr .ptokenstr2 
20f1			 
20f1			.ptokendone2: 
20f1				;inc hl 
20f1 3e 7f			ld a, FORTH_END_BUFFER 
20f3 77				ld (hl),a 
20f4 23				inc hl 
20f5 3e 21			ld a, '!' 
20f7 77				ld (hl),a 
20f8			 
20f8 2a 15 f1			ld hl,(os_tok_ptr) 
20fb			         
20fb			if DEBUG_FORTH_TOK 
20fb						DMARK "TK1" 
20fb				CALLMONITOR 
20fb			endif 
20fb			 
20fb				; push exec string to top of return stack 
20fb				FORTH_RSP_NEXT 
20fb cd af 1c			call macro_forth_rsp_next 
20fe				endm 
# End of macro FORTH_RSP_NEXT
20fe c9				ret 
20ff			 
20ff			; 
20ff			;	; malloc size + buffer pointer + if is loop flag 
20ff			;	ld hl,(os_tok_len) 		 ; get string length 
20ff			; 
20ff			;	ld a,l 
20ff			; 
20ff			;	cp 0			; we dont want to use a null string 
20ff			;	ret z 
20ff			; 
20ff			;;	add 3    ; prefix malloc with buffer for current word ptr 
20ff			; 
20ff			;	add 5     ; TODO when certain not over writing memory remove 
20ff			; 
20ff			;		 
20ff			; 
20ff			;if DEBUG_FORTH_TOK 
20ff			;			DMARK "TKE" 
20ff			;	CALLMONITOR 
20ff			;endif 
20ff			; 
20ff			;	ld l,a 
20ff			;	ld h,0 
20ff			;;	push hl   ; save required space for the copy later 
20ff			;	call malloc 
20ff			;if DEBUG_FORTH_TOK 
20ff			;			DMARK "TKM" 
20ff			;	CALLMONITOR 
20ff			;endif 
20ff			;	if DEBUG_FORTH_MALLOC_GUARD 
20ff			;		push af 
20ff			;		call ishlzero 
20ff			;;		ld a, l 
20ff			;;		add h 
20ff			;;		cp 0 
20ff			;		pop af 
20ff			;		 
20ff			;		call z,malloc_error 
20ff			;	endif 
20ff			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
20ff			; 
20ff			; 
20ff			;if DEBUG_FORTH_TOK 
20ff			;			DMARK "TKR" 
20ff			;	CALLMONITOR 
20ff			;endif 
20ff			; 
20ff			;	FORTH_RSP_NEXT 
20ff			; 
20ff			;	;inc hl	 ; go past current buffer pointer 
20ff			;	;inc hl 
20ff			;	;inc hl   ; and past if loop flag 
20ff			;		; TODO Need to set flag  
20ff			; 
20ff			;	 
20ff			;	 
20ff			;	ex de,hl	; malloc is dest 
20ff			;	ld hl, (os_tok_len) 
20ff			;;	pop bc 
20ff			;	ld c, l                
20ff			;	ld b,0 
20ff			;	ld hl, (os_tok_ptr) 
20ff			; 
20ff			;if DEBUG_FORTH_TOK 
20ff			;			DMARK "TKT" 
20ff			;	CALLMONITOR 
20ff			;endif 
20ff			; 
20ff			;	; do str cpy 
20ff			; 
20ff			;	ldir      ; copy byte in hl to de 
20ff			; 
20ff			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
20ff			; 
20ff			;if DEBUG_FORTH_TOK 
20ff			; 
20ff			;			DMARK "TKY" 
20ff			;	CALLMONITOR 
20ff			;endif 
20ff			;	;ld a,0 
20ff			;	;ld a,FORTH_END_BUFFER 
20ff			;	ex de, hl 
20ff			;	;dec hl			 ; go back over the space delim at the end of word 
20ff			;	;ld (hl),a 
20ff			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
20ff			;	ld a,FORTH_END_BUFFER 
20ff			;	ld (hl),a 
20ff			;	inc hl 
20ff			;	ld a,FORTH_END_BUFFER 
20ff			;	ld (hl),a 
20ff			; 
20ff			;	; init the malloc area data 
20ff			;	; set pc for in current area 
20ff			;	;ld hl, (os_tok_malloc) 
20ff			;	;inc hl 
20ff			;	;inc hl 
20ff			;	;inc hl 
20ff			;	;ex de,hl 
20ff			;	;ld hl, (os_tok_malloc) 
20ff			;	;ld (hl),e 
20ff			;	;inc hl 
20ff			;	;ld (hl),d 
20ff			; 
20ff			; 
20ff			;	ld hl,(os_tok_malloc) 
20ff			;if DEBUG_FORTH_PARSE_KEY 
20ff			;			DMARK "TKU" 
20ff			;	CALLMONITOR 
20ff			;endif 
20ff			; 
20ff			;	ret 
20ff			 
20ff			forthexec: 
20ff			 
20ff			; line exec: 
20ff			; forth parser 
20ff			 
20ff			; 
20ff			;       get current exec line on rsp 
20ff			 
20ff				FORTH_RSP_TOS 
20ff cd c6 1c			call macro_forth_rsp_tos 
2102				endm 
# End of macro FORTH_RSP_TOS
2102			 
2102			;       restore current pc - hl points to malloc of data 
2102			 
2102				;ld e, (hl) 
2102				;inc hl 
2102				;ld d, (hl) 
2102				;ex de,hl 
2102			 
2102			 
2102			exec1: 
2102 22 15 f1			ld (os_tok_ptr), hl 
2105			 
2105				; copy our PC to working vars  
2105 22 1f f8			ld (cli_ptr), hl 
2108 22 1d f8			ld (cli_origptr), hl 
210b			 
210b 7e				ld a,(hl) 
210c fe 7f			cp FORTH_END_BUFFER 
210e c8				ret z 
210f			 
210f				; skip any nulls 
210f			 
210f fe 00			cp 0 
2111 20 03			jr nz, .execword 
2113 23				inc hl 
2114 18 ec			jr exec1 
2116			 
2116			 
2116			.execword: 
2116			 
2116			 
2116			 
2116			if DEBUG_FORTH_PARSE_KEY 
2116						DMARK "KYQ" 
2116				CALLMONITOR 
2116			endif 
2116			;       while at start of word: 
2116			; get start of dict (in user area first) 
2116			 
2116 21 00 80		ld hl, baseram 
2119			;ld hl, sysdict 
2119 22 21 f8		ld (cli_nextword),hl 
211c			;           match word at pc 
211c			;           exec word 
211c			;           or push to dsp 
211c			;           forward to next token 
211c			;           if line term pop rsp and exit 
211c			;        
211c			 
211c			if DEBUG_FORTH_PARSE_KEY 
211c						DMARK "KYq" 
211c				CALLMONITOR 
211c			endif 
211c			 
211c			; 
211c			; word comp 
211c			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
211c			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
211c			;    move to start of word  
211c			;    compare word to cli_token 
211c			 
211c			.execpnword:	; HL at start of a word in the dictionary to check 
211c			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
211c			;	ld (cli_ptr), hl 
211c			 
211c 2a 21 f8			ld hl,(cli_nextword) 
211f			 
211f cd c2 21			call forth_tok_next 
2122			; tok next start here 
2122			;	; TODO skip compiled symbol for now 
2122			;	inc hl 
2122			; 
2122			;	; save pointer to next word 
2122			; 
2122			;	; hl now points to the address of the next word pointer  
2122			;	ld e, (hl) 
2122			;	inc hl 
2122			;	ld d, (hl) 
2122			;	inc l 
2122			; 
2122			;	ex de,hl 
2122			;if DEBUG_FORTH_PARSE_NEXTWORD 
2122			;	push bc 
2122			;	ld bc, (cli_nextword) 
2122			;			DMARK "NXW" 
2122			;	CALLMONITOR 
2122			;	pop bc 
2122			;endif 
2122			; tok next end here 
2122 22 21 f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
2125 eb				ex de, hl 
2126			 
2126			 
2126				; save the pointer of the current token - 1 to check against 
2126				 
2126 22 25 f8			ld (cli_token), hl   
2129				; TODO maybe remove below save if no debug 
2129				; save token string ptr for any debug later 
2129 23				inc hl  
212a 22 27 f8			ld (cli_origtoken), hl 
212d 2b				dec hl 
212e				; save pointer to the start of the next dictionay word 
212e 7e				ld a,(hl)   ; get string length 
212f 47				ld b,a 
2130			.execpnwordinc:  
2130 23				inc hl 
2131 10 fd			djnz .execpnwordinc 
2133 22 23 f8			ld (cli_execword), hl      ; save start of this words code 
2136			 
2136				; now check the word token against the string being parsed 
2136			 
2136 2a 25 f8			ld hl,(cli_token) 
2139 23				inc hl     ; skip string length (use zero term instead to end) 
213a 22 25 f8			ld (cli_token), hl 
213d			 
213d			if DEBUG_FORTH_PARSE_KEY 
213d						DMARK "KY2" 
213d			endif 
213d			if DEBUG_FORTH_PARSE_EXEC 
213d				; see if disabled 
213d			 
213d				ld a, (os_view_disable) 
213d				cp '*' 
213d				jr z, .skip 
213d			 
213d				push hl 
213d				push hl 
213d				call clear_display 
213d				ld de, .compword 
213d				ld a, display_row_1 
213d				call str_at_display 
213d				pop de 
213d				ld a, display_row_2 
213d				call str_at_display 
213d				ld hl,(cli_ptr) 
213d				ld a,(hl) 
213d			        ld hl, os_word_scratch 
213d				ld (hl),a 
213d				ld a,0 
213d				inc hl 
213d				ld (hl),a 	 
213d				ld de, os_word_scratch 
213d				ld a, display_row_2+10 
213d				call str_at_display 
213d				call update_display 
213d				ld a, 100 
213d				call aDelayInMS 
213d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
213d				call delay250ms 
213d				endif 
213d				pop hl 
213d			.skip:  
213d			endif	 
213d			.execpnchar:    ; compare char between token and string to parse 
213d			 
213d			if DEBUG_FORTH_PARSE_KEY 
213d						DMARK "Ky3" 
213d			endif 
213d			if DEBUG_FORTH_PARSE_EXEC 
213d				; see if disabled 
213d			 
213d				ld a, (os_view_disable) 
213d				cp '*' 
213d				jr z, .skip2 
213d			 
213d			;	call clear_display 
213d			ld hl,(cli_token) 
213d			ld a,(hl) 
213d			ld (os_word_scratch),a 
213d				ld hl,(cli_ptr) 
213d			ld a,(hl) 
213d				ld (os_word_scratch+1),a 
213d				ld a,0 
213d				ld (os_word_scratch+2),a 
213d				ld de,os_word_scratch 
213d				ld a,display_row_4 
213d				call str_at_display 
213d				call update_display 
213d			.skip2:  
213d			endif 
213d 2a 25 f8			ld hl,(cli_token) 
2140 7e				ld a, (hl)	 ; char in word token 
2141 23				inc hl 		; move to next char 
2142 22 25 f8			ld (cli_token), hl ; and save it 
2145 47				ld b,a 
2146			 
2146 2a 1f f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
2149 7e				ld a,(hl) 
214a 23				inc hl 
214b 22 1f f8			ld (cli_ptr), hl		; move to next char 
214e cd 59 11			call toUpper 		; make sure the input string matches case 
2151			 
2151			if DEBUG_FORTH_PARSE 
2151			endif 
2151			 
2151				; input stream end of token is a space so get rid of it 
2151			 
2151			;	cp ' ' 
2151			;	jr nz, .pnskipspace 
2151			; 
2151			;	ld a, 0		; make same term as word token term 
2151			; 
2151			;.pnskipspace: 
2151			 
2151			if DEBUG_FORTH_PARSE_KEY 
2151						DMARK "KY7" 
2151			endif 
2151 b8				cp b 
2152 c2 68 21			jp nz, .execpnskipword	 ; no match so move to next word 
2155				 
2155			;    if same 
2155			;       scan for string terms 0 for token and 32 for input 
2155			 
2155				 
2155			if DEBUG_FORTH_PARSE_KEY 
2155						DMARK "KY8" 
2155			endif 
2155			 
2155 80				add b			 
2156 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2158							; TODO need to make sure last word in zero term string is accounted for 
2158 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
215a			 
215a			 
215a				; at end of both strings so both are exact match 
215a			 
215a			;       skip ptr for next word 
215a			 
215a 2a 1f f8			ld hl,(cli_ptr) 	; at input string term 
215d 23				inc hl			 ; at next char 
215e 22 1f f8			ld (cli_ptr), hl     ; save for next round of the parser 
2161 22 1d f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2164				 
2164				 
2164			if DEBUG_FORTH_PARSE_KEY 
2164						DMARK "KY3" 
2164			endif 
2164			 
2164			 
2164			 
2164			;       exec code block 
2164			if DEBUG_FORTH_JP 
2164				call clear_display 
2164				call update_display 
2164				call delay1s 
2164				ld hl, (cli_execword)     ; save for next check if no match on this word 
2164				ld a,h 
2164				ld hl, os_word_scratch 
2164				call hexout 
2164				ld hl, (cli_execword)     ; save for next check if no match on this word 
2164				ld a,l 
2164				ld hl, os_word_scratch+2 
2164				call hexout 
2164				ld hl, os_word_scratch+4 
2164				ld a,0 
2164				ld (hl),a 
2164				ld de,os_word_scratch 
2164				call str_at_display 
2164					ld a, display_row_2 
2164					call str_at_display 
2164				ld de, (cli_origtoken) 
2164				ld a, display_row_1+10 
2164					call str_at_display 
2164			 
2164				ld a,display_row_1 
2164				ld de, .foundword 
2164				ld a, display_row_3 
2164				call str_at_display 
2164				call update_display 
2164				call delay1s 
2164				call delay1s 
2164				call delay1s 
2164			endif 
2164			 
2164			if DEBUG_FORTH_PARSE_KEY 
2164						DMARK "KYj" 
2164			endif 
2164				; TODO save the word pointer in this exec 
2164			 
2164 2a 23 f8			ld hl,(cli_execword) 
2167 e9				jp (hl) 
2168			 
2168			 
2168			;    if not same 
2168			;	scan for zero term 
2168			;	get ptr for next word 
2168			;	goto word comp 
2168			 
2168			.execpnskipword:	; get pointer to next word 
2168 2a 21 f8			ld hl,(cli_nextword) 
216b			 
216b 7e				ld a,(hl) 
216c fe 00			cp WORD_SYS_END 
216e			;	cp 0 
216e 28 09			jr z, .execendofdict			 ; at end of words 
2170			 
2170			if DEBUG_FORTH_PARSE_KEY 
2170						DMARK "KY4" 
2170			endif 
2170			if DEBUG_FORTH_PARSE_EXEC 
2170			 
2170				; see if disabled 
2170			 
2170				ld a, (os_view_disable) 
2170				cp '*' 
2170				jr z, .noskip 
2170			 
2170			 
2170				ld de, .nowordfound 
2170				ld a, display_row_3 
2170				call str_at_display 
2170				call update_display 
2170				ld a, 100 
2170				call aDelayInMS 
2170				 
2170				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2170					call delay250ms 
2170				endif 
2170			.noskip:  
2170			 
2170			endif	 
2170			 
2170 2a 1d f8			ld hl,(cli_origptr) 
2173 22 1f f8			ld (cli_ptr),hl 
2176			 
2176			if DEBUG_FORTH_PARSE_KEY 
2176						DMARK "KY5" 
2176			endif 
2176 c3 1c 21			jp .execpnword			; else go to next word 
2179			 
2179			.execendofdict:  
2179			 
2179			if DEBUG_FORTH_PARSE_KEY 
2179						DMARK "KYe" 
2179			endif 
2179			if DEBUG_FORTH_PARSE_EXEC 
2179				; see if disabled 
2179			 
2179				ld a, (os_view_disable) 
2179				cp '*' 
2179				jr z, .ispskip 
2179			 
2179				call clear_display 
2179				call update_display 
2179				call delay1s 
2179				ld de, (cli_origptr) 
2179				ld a, display_row_1 
2179				call str_at_display 
2179				 
2179				ld de, .enddict 
2179				ld a, display_row_3 
2179				call str_at_display 
2179				call update_display 
2179				ld a, 100 
2179				call aDelayInMS 
2179				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2179				call delay1s 
2179				call delay1s 
2179				call delay1s 
2179				endif 
2179			.ispskip:  
2179				 
2179			endif	 
2179			 
2179			 
2179			 
2179				; if the word is not a keyword then must be a literal so push it to stack 
2179			 
2179			; push token to stack to end of word 
2179			 
2179				STACKFRAME ON $1efe $2f9f 
2179				if DEBUG_STACK_IMB 
2179					if ON 
2179						exx 
2179						ld de, $1efe 
2179						ld a, d 
2179						ld hl, curframe 
2179						call hexout 
2179						ld a, e 
2179						ld hl, curframe+2 
2179						call hexout 
2179						ld hl, $1efe 
2179						push hl 
2179						ld hl, $2f9f 
2179						push hl 
2179						exx 
2179					endif 
2179				endif 
2179			endm 
# End of macro STACKFRAME
2179			 
2179 2a 15 f1		ld hl,(os_tok_ptr) 
217c cd 71 1e		call forth_apush 
217f			 
217f				STACKFRAMECHK ON $1efe $2f9f 
217f				if DEBUG_STACK_IMB 
217f					if ON 
217f						exx 
217f						ld hl, $2f9f 
217f						pop de   ; $2f9f 
217f						call cmp16 
217f						jr nz, .spnosame 
217f						ld hl, $1efe 
217f						pop de   ; $1efe 
217f						call cmp16 
217f						jr z, .spfrsame 
217f						.spnosame: call showsperror 
217f						.spfrsame: nop 
217f						exx 
217f					endif 
217f				endif 
217f			endm 
# End of macro STACKFRAMECHK
217f			 
217f			execnext: 
217f			 
217f			if DEBUG_FORTH_PARSE_KEY 
217f						DMARK "KY>" 
217f			endif 
217f			; move past token to next word 
217f			 
217f 2a 15 f1		ld hl, (os_tok_ptr) 
2182 3e 00		ld a, 0 
2184 01 ff 00		ld bc, 255     ; input buffer size 
2187 ed b1		cpir 
2189			 
2189			if DEBUG_FORTH_PARSE_KEY 
2189						DMARK "KY!" 
2189				CALLMONITOR 
2189			endif	 
2189			; TODO this might place hl on the null, so will need to forward on??? 
2189			;inc hl   ; see if this gets onto the next item 
2189			 
2189			 
2189			; TODO pass a pointer to the buffer to push 
2189			; TODO call function to push 
2189			 
2189			; look for end of input 
2189			 
2189			;inc hl 
2189			;ld a,(hl) 
2189			;cp FORTH_END_BUFFER 
2189			;ret z 
2189			 
2189			 
2189 c3 02 21		jp exec1 
218c			 
218c			 
218c			 
218c			 
218c			 
218c			 
218c			 
218c			 
218c			 
218c			findnexttok: 
218c			 
218c				; hl is pointer to move 
218c				; de is the token to locate 
218c			 
218c					if DEBUG_FORTH 
218c						DMARK "NTK" 
218c						CALLMONITOR 
218c					endif 
218c d5				push de 
218d			 
218d			.fnt1:	 
218d				; find first char of token to locate 
218d			 
218d 1a				ld a, (de) 
218e 4f				ld c,a 
218f 7e				ld a,(hl) 
2190 cd 59 11			call toUpper 
2193					if DEBUG_FORTH 
2193						DMARK "NT1" 
2193						CALLMONITOR 
2193					endif 
2193 b9				cp c 
2194			 
2194 28 03			jr z, .fnt2cmpmorefirst	 
2196			 
2196				; first char not found move to next char 
2196			 
2196 23				inc hl 
2197 18 f4			jr .fnt1 
2199			 
2199			.fnt2cmpmorefirst:	 
2199				; first char of token found.  
2199			 
2199 e5				push hl     ; save start of token just in case it is the right one 
219a d9				exx 
219b e1				pop hl        ; save it to hl' 
219c d9				exx 
219d			 
219d			 
219d			.fnt2cmpmore:	 
219d				; compare the rest 
219d				 
219d 23				inc hl 
219e 13				inc de 
219f				 
219f 1a				ld a, (de) 
21a0 4f				ld c,a 
21a1 7e				ld a,(hl) 
21a2 cd 59 11			call toUpper 
21a5			 
21a5					if DEBUG_FORTH 
21a5						DMARK "NT2" 
21a5						CALLMONITOR 
21a5					endif 
21a5				; c has the token to find char 
21a5				; a has the mem to scan char 
21a5			 
21a5 b9				cp c 
21a6 28 04			jr z,.fntmatch1 
21a8			 
21a8				; they are not the same 
21a8			 
21a8					if DEBUG_FORTH 
21a8						DMARK "NT3" 
21a8						CALLMONITOR 
21a8					endif 
21a8 d1				pop de	; reset de token to look for 
21a9 d5				push de 
21aa 18 e1			jr .fnt1 
21ac				 
21ac			.fntmatch1: 
21ac			 
21ac				; is the same char a null which means we might have a full hit? 
21ac					if DEBUG_FORTH 
21ac						DMARK "NT4" 
21ac						CALLMONITOR 
21ac					endif 
21ac			 
21ac fe 00			cp 0 
21ae 28 0b			jr z, .fntmatchyes 
21b0			 
21b0				; are we at the end of the token to find? 
21b0			 
21b0					if DEBUG_FORTH 
21b0						DMARK "NT5" 
21b0						CALLMONITOR 
21b0					endif 
21b0 3e 00			ld a, 0 
21b2 b9				cp c 
21b3			 
21b3 c2 9d 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
21b6			 
21b6					if DEBUG_FORTH 
21b6						DMARK "NT6" 
21b6						CALLMONITOR 
21b6					endif 
21b6				; token to find is exhusted but no match to stream 
21b6			 
21b6				; restore tok pointer and continue on 
21b6 d1				pop de 
21b7 d5				push de 
21b8 c3 8d 21			jp .fnt1 
21bb			 
21bb			 
21bb			.fntmatchyes: 
21bb			 
21bb				; hl now contains the end of the found token 
21bb			 
21bb				; get rid of saved token pointer to find 
21bb			 
21bb d1				pop de 
21bc			 
21bc					if DEBUG_FORTH 
21bc						DMARK "NT9" 
21bc						CALLMONITOR 
21bc					endif 
21bc			 
21bc				; hl will be on the null term so forward on 
21bc			 
21bc				; get back the saved start of the token 
21bc			 
21bc d9				exx 
21bd e5				push hl     ; save start of token just in case it is the right one 
21be d9				exx 
21bf e1				pop hl        ; save it to hl 
21c0			 
21c0 c9				ret 
21c1			 
21c1			 
21c1			; LIST needs to find a specific token   
21c1			; FORGET needs to find a spefici token 
21c1			 
21c1			; SAVE needs to find all tokens by flag 
21c1			; WORDS just needs to scan through all  by flag 
21c1			; UWORDS needs to scan through all by flag 
21c1			 
21c1			 
21c1			; given hl as pointer to start of dict look up string 
21c1			; return hl as pointer to start of word block 
21c1			; or 0 if not found 
21c1			 
21c1			forth_find_tok: 
21c1 c9				ret 
21c2			 
21c2			; given hl as pointer to dict structure 
21c2			; move to the next dict block structure 
21c2			 
21c2			forth_tok_next: 
21c2				; hl now points to the address of the next word pointer  
21c2				; TODO skip compiled symbol for now 
21c2			;	push de 
21c2 23				inc hl 
21c3 5e				ld e, (hl) 
21c4 23				inc hl 
21c5 56				ld d, (hl) 
21c6 23				inc hl 
21c7			 
21c7 eb				ex de,hl 
21c8			if DEBUG_FORTH_PARSE_NEXTWORD 
21c8				push bc 
21c8				ld bc, (cli_nextword) 
21c8						DMARK "NXW" 
21c8				CALLMONITOR 
21c8				pop bc 
21c8			endif 
21c8			;	pop de	 
21c8 c9				ret 
21c9			 
21c9			 
21c9			 
21c9			; eof 
# End of file forth_parserv5.asm
21c9				include "forth_wordsv4.asm" 
21c9			 
21c9			; the core word dictionary v4 
21c9			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
21c9			 
21c9			; this is a linked list for each of the system words used 
21c9			; user defined words will follow the same format but will be in ram 
21c9			 
21c9			 
21c9			; 
21c9			; 
21c9			; define linked list: 
21c9			; 
21c9			; 1. compiled byte op code 
21c9			; 2. len of text word 
21c9			; 3. text word 
21c9			; 4. ptr to next dictionary word 
21c9			; 5. asm, calls etc for the word 
21c9			; 
21c9			;  if 1 == 0 then last word in dict  
21c9			;   
21c9			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
21c9			;  
21c9			;  
21c9			; create basic standard set of words 
21c9			; 
21c9			;  
21c9			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
21c9			; 2DUP 2DROP 2SWAP  
21c9			; @ C@ - get byte  
21c9			; ! C! - store byte 
21c9			; 0< true if less than zero 
21c9			; 0= true if zero 
21c9			; < >  
21c9			; = true if same 
21c9			; variables 
21c9			 
21c9			 
21c9			; Hardware specific words I may need 
21c9			; 
21c9			; IN OUT  
21c9			; calls to key util functions 
21c9			; calls to hardward abstraction stuff 
21c9			; easy control of frame buffers and lcd i/o 
21c9			; keyboard  
21c9			 
21c9			 
21c9			;DICT: macro 
21c9			; op_code, len, word, next 
21c9			;    word: 
21c9			;    db op_code 
21c9			;    ds word zero term 
21c9			;    dw next 
21c9			;    endm 
21c9			 
21c9			 
21c9			 
21c9			 
21c9			; op code 1 is a flag for user define words which are to be handled differently 
21c9			 
21c9			 
21c9			; 
21c9			; 
21c9			;    TODO on entry to a word this should be the expected environment 
21c9			;    hl - tos value if number then held, if string this is the ptr 
21c9			;    de -  
21c9			 
21c9			 
21c9			; opcode ranges 
21c9			; 0 - end of word dict 
21c9			; 255 - user define words 
21c9			 
21c9			sysdict: 
21c9			include "forth_opcodes.asm" 
21c9			; op codes for forth keywords 
21c9			; free to use code 0  
21c9				OPCODE_HEAP: equ  1 
21c9				OPCODE_EXEC: equ 2 
21c9				OPCODE_DUP: equ 3 
21c9				OPCODE_SWAP: equ 4 
21c9				OPCODE_COLN: equ 5 
21c9				OPCODE_SCOLN: equ 6 
21c9				OPCODE_DROP: equ 7 
21c9				OPCODE_DUP2: equ 8 
21c9				OPCODE_DROP2: equ 9 
21c9				OPCODE_SWAP2: equ 10 
21c9				OPCODE_AT: equ 11 
21c9				OPCODE_CAT: equ 12 
21c9				OPCODE_BANG: equ 13 
21c9				OPCODE_CBANG: equ 14 
21c9				OPCODE_SCALL: equ 15 
21c9				OPCODE_DEPTH: equ 16 
21c9				OPCODE_OVER: equ 17 
21c9				OPCODE_PAUSE: equ 18 
21c9				OPCODE_PAUSES: equ 19 
21c9				OPCODE_ROT: equ 20 
21c9			;free to reuse	OPCODE_WORDS: equ 21 
21c9			        OPCODE_NOT: equ 21 
21c9				OPCODE_UWORDS: equ 22 
21c9				OPCODE_BP: equ 23 
21c9				OPCODE_MONITOR: equ 24  
21c9				OPCODE_MALLOC: equ 25 
21c9				OPCODE_FREE: equ 26 
21c9				OPCODE_LIST: equ 27 
21c9				OPCODE_FORGET: equ 28 
21c9				OPCODE_NOP: equ 29 
21c9				OPCODE_COMO: equ 30 
21c9				OPCODE_COMC: equ 31 
21c9			;free to reuse	OPCODE_ENDCORE: equ 32 
21c9				OPCODE_AFTERSOUND: equ 33 
21c9				OPCODE_GP2: equ 34 
21c9				OPCODE_GP3: equ 35 
21c9				OPCODE_GP4: equ 36 
21c9				OPCODE_SIN: equ 37 
21c9				OPCODE_SOUT: equ 38 
21c9				OPCODE_SPIO: equ 39 
21c9				OPCODE_SPICEH: equ 40 
21c9				OPCODE_SPIOb: equ 41 
21c9				OPCODE_SPII: equ 42 
21c9				OPCODE_SESEL: equ 43 
21c9				OPCODE_CARTDEV: equ 44 
21c9			; free to reuse	OPCODE_ENDDEVICE: equ 45 
21c9				OPCODE_FB: equ 46 
21c9				OPCODE_EMIT: equ 47 
21c9				OPCODE_DOTH: equ 48 
21c9				OPCODE_DOTF: equ 49 
21c9				OPCODE_DOT: equ 50 
21c9				OPCODE_CLS: equ 51 
21c9				OPCODE_DRAW: equ 52 
21c9				OPCODE_DUMP: equ 53 
21c9				OPCODE_CDUMP: equ 54 
21c9				OPCODE_DAT: equ 55 
21c9				OPCODE_HOME: equ 56 
21c9				OPCODE_SPACE: equ 57 
21c9				OPCODE_SPACES: equ 58 
21c9				OPCODE_SCROLL: equ 59 
21c9				OPCODE_ATQ: equ 60 
21c9				OPCODE_AUTODSP: equ 61 
21c9				OPCODE_MENU: equ 62 
21c9			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
21c9				OPCODE_THEN: equ 64 
21c9				OPCODE_ELSE: equ 65 
21c9				OPCODE_DO: equ 66 
21c9				OPCODE_LOOP: equ 67 
21c9				OPCODE_I: equ 68 
21c9				OPCODE_DLOOP: equ 69  
21c9				OPCODE_REPEAT: equ 70  
21c9				OPCODE_UNTIL: equ 71 
21c9				OPCODE_ENDFLOW: equ 72 
21c9				OPCODE_WAITK: equ 73 
21c9				OPCODE_ACCEPT: equ 74 
21c9				OPCODE_EDIT: equ 75 
21c9			;free to reuse	OPCODE_ENDKEY: equ 76 
21c9				OPCODE_LZERO: equ 77 
21c9				OPCODE_TZERO: equ 78 
21c9				OPCODE_LESS: equ 79 
21c9				OPCODE_GT: equ 80 
21c9				OPCODE_EQUAL: equ 81  
21c9			;free to reuse	OPCODE_ENDLOGIC: equ 82 
21c9				OPCODE_NEG: equ 83 
21c9				OPCODE_DIV: equ 84 
21c9				OPCODE_MUL: equ 85 
21c9				OPCODE_MIN: equ 86 
21c9				OPCODE_MAX: equ 87 
21c9				OPCODE_RND16: equ 88 
21c9				OPCODE_RND8: equ 89 
21c9				OPCODE_RND: equ 90 
21c9			;free to reuse	OPCODE_ENDMATHS: equ 91  
21c9				OPCODE_BYNAME: equ 92 
21c9				OPCODE_DIR: equ 93 
21c9				OPCODE_SAVE: equ 94 
21c9				OPCODE_LOAD: equ 95 
21c9				OPCODE_BSAVE: equ 96 
21c9				OPCODE_BLOAD: equ 97 
21c9				OPCODE_SEO: equ 98  
21c9				OPCODE_SEI: equ 99 
21c9				OPCODE_SFREE: equ 100 
21c9				OPCODE_SIZE: equ 101 
21c9				OPCODE_CREATE: equ 102 
21c9				OPCODE_APPEND: equ 103 
21c9				OPCODE_SDEL: equ 104 
21c9				OPCODE_OPEN: equ 105 
21c9				OPCODE_READ: equ 106 
21c9				OPCODE_EOF: equ 106 
21c9				OPCODE_FORMAT: equ 107 
21c9				OPCODE_LABEL: equ 108 
21c9				OPCODE_LABELS: equ 109 
21c9			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
21c9				OPCODE_UPPER: equ 111 
21c9				OPCODE_LOWER: equ 112 
21c9				OPCODE_SUBSTR: equ 113 
21c9				OPCODE_LEFT: equ 114 
21c9				OPCODE_RIGHT: equ 115 
21c9				OPCODE_STR2NUM: equ 116 
21c9				OPCODE_NUM2STR: equ 117 
21c9				OPCODE_CONCAT: equ 118 
21c9				OPCODE_FIND: equ 119 
21c9				OPCODE_LEN: equ 120 
21c9				OPCODE_CHAR: equ 121 
21c9			; free to reuse	OPCODE_STRLEN: equ 122 
21c9			; free to reuse	OPCODE_ENDSTR: equ 123 
21c9				OPCODE_V0S: equ 124 
21c9				OPCODE_V0Q: equ 125 
21c9				OPCODE_V1S: equ 126 
21c9				OPCODE_V1Q: equ 127 
21c9				OPCODE_V2S: equ 128 
21c9				OPCODE_V2Q: equ 129 
21c9				OPCODE_V3S: equ 130 
21c9				OPCODE_V3Q: equ 131 
21c9			;free to reuse	OPCODE_END: equ 132 
21c9				OPCODE_ZDUP: equ 133 
21c9			 
21c9			; eof 
# End of file forth_opcodes.asm
21c9			 
21c9			include "forth_words_core.asm" 
21c9			 
21c9			; | ## Core Words 
21c9			 
21c9			;if MALLOC_4 
21c9			 
21c9			.HEAP: 
21c9				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
21c9 15				db WORD_SYS_CORE+OPCODE_HEAP             
21ca 08 22			dw .EXEC            
21cc 05				db 4 + 1 
21cd .. 00			db "HEAP",0              
21d2				endm 
# End of macro CWHEAD
21d2			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
21d2			; | | u1 - Current number of bytes in the heap 
21d2			; | | u2 - Remaining bytes left on the heap 
21d2			; | |  
21d2			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
21d2			 
21d2			 
21d2					if DEBUG_FORTH_WORDS_KEY 
21d2						DMARK "HEP" 
21d2 f5				push af  
21d3 3a e7 21			ld a, (.dmark)  
21d6 32 6e fb			ld (debug_mark),a  
21d9 3a e8 21			ld a, (.dmark+1)  
21dc 32 6f fb			ld (debug_mark+1),a  
21df 3a e9 21			ld a, (.dmark+2)  
21e2 32 70 fb			ld (debug_mark+2),a  
21e5 18 03			jr .pastdmark  
21e7 ..			.dmark: db "HEP"  
21ea f1			.pastdmark: pop af  
21eb			endm  
# End of macro DMARK
21eb						CALLMONITOR 
21eb cd ab 16			call break_point_state  
21ee				endm  
# End of macro CALLMONITOR
21ee					endif 
21ee 2a 0a 80				ld hl, (free_list )      
21f1 11 0e 80				ld de, heap_start 
21f4			 
21f4 ed 52				sbc hl, de  
21f6			 
21f6 cd 08 1d				call forth_push_numhl 
21f9			 
21f9			 
21f9 ed 5b 0a 80			ld de, (free_list )      
21fd 21 fa ed				ld hl, heap_end 
2200			 
2200 ed 52				sbc hl, de 
2202			 
2202 cd 08 1d				call forth_push_numhl 
2205					 
2205			 
2205					 
2205			 
2205			 
2205			 
2205					NEXTW 
2205 c3 71 20			jp macro_next 
2208				endm 
# End of macro NEXTW
2208			;endif 
2208			 
2208			.EXEC: 
2208			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2208			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2208			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2208			;; > > 
2208			;; > >   
2208			;	STACKFRAME OFF $5efe $5f9f 
2208			; 
2208			;		if DEBUG_FORTH_WORDS_KEY 
2208			;			DMARK "EXE" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			; 
2208			;	FORTH_DSP_VALUEHL 
2208			; 
2208			;	FORTH_DSP_POP 
2208			; 
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EX1" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			;;	ld e,(hl) 
2208			;;	inc hl 
2208			;;	ld d,(hl) 
2208			;;	ex de,hl 
2208			; 
2208			;;		if DEBUG_FORTH_WORDS 
2208			;;			DMARK "EX2" 
2208			;;			CALLMONITOR 
2208			;;		endif 
2208			;	push hl 
2208			; 
2208			;	;ld a, 0 
2208			;	;ld a, FORTH_END_BUFFER 
2208			;	call strlenz 
2208			;	inc hl   ; include zero term to copy 
2208			;	inc hl   ; include term 
2208			;	inc hl   ; include term 
2208			;	ld b,0 
2208			;	ld c,l 
2208			;	pop hl 
2208			;	ld de, execscratch 
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EX3" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			;	ldir 
2208			; 
2208			; 
2208			;	ld hl, execscratch 
2208			; 
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EXe" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			; 
2208			;	call forthparse 
2208			;	call forthexec 
2208			;;	call forthexec_cleanup 
2208			;;	call forthparse 
2208			;;	call forthexec 
2208			; 
2208			;	STACKFRAMECHK OFF $5efe $5f9f 
2208			; 
2208			;	; an immediate word so no need to process any more words 
2208			;	ret 
2208			;	NEXTW 
2208			 
2208			; dead code - old version  
2208			;	FORTH_RSP_NEXT 
2208			 
2208			;  
2208			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2208			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2208			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2208			;	push hl 
2208			;	push de 
2208			;	push bc 
2208			; 
2208			; 
2208			;		if DEBUG_FORTH_WORDS_KEY 
2208			;			DMARK "EXR" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			; 
2208			; 
2208			; 
2208			;	;v5 FORTH_DSP_VALUE 
2208			;	FORTH_DSP_VALUEHL 
2208			; 
2208			;	; TODO do string type checks 
2208			; 
2208			;;v5	inc hl   ; skip type 
2208			; 
2208			;	push hl  ; source code  
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EX1" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			;	ld a, 0 
2208			;	call strlent 
2208			; 
2208			;	inc hl 
2208			;	inc hl 
2208			;	inc hl 
2208			;	inc hl 
2208			; 
2208			;	push hl    ; size 
2208			; 
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EX2" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			;	call malloc 
2208			; 
2208			;	ex de, hl    ; de now contains malloc area 
2208			;	pop bc   	; get byte count 
2208			;	pop hl      ; get string to copy 
2208			; 
2208			;	push de     ; save malloc for free later 
2208			; 
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EX3" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			;	ldir       ; duplicate string 
2208			; 
2208			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2208			;	 
2208			;	; TODO fix the parse would be better than this...  
2208			;	ex de, hl 
2208			;	dec hl 
2208			;	ld a, 0 
2208			;	ld (hl), a 
2208			;	dec hl 
2208			;	ld a, ' ' 
2208			;	ld (hl), a 
2208			;	dec hl 
2208			;	ld (hl), a 
2208			; 
2208			;	dec hl 
2208			;	ld (hl), a 
2208			; 
2208			; 
2208			;	FORTH_DSP_POP  
2208			; 
2208			;	pop hl     
2208			;	push hl    ; save malloc area 
2208			; 
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EX4" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			; 
2208			;	call forthparse 
2208			;	call forthexec 
2208			;	 
2208			;	pop hl 
2208			;	if DEBUG_FORTH_WORDS 
2208			;		DMARK "EX5" 
2208			;		CALLMONITOR 
2208			;	endif 
2208			; 
2208			;	if FORTH_ENABLE_FREE 
2208			;	call free 
2208			;	endif 
2208			; 
2208			;	if DEBUG_FORTH_WORDS 
2208			;		DMARK "EX6" 
2208			;		CALLMONITOR 
2208			;	endif 
2208			; 
2208			;	pop bc 
2208			;	pop de 
2208			;	pop hl 
2208			;;	FORTH_RSP_POP	  
2208			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2208			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2208			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2208			; 
2208			;	if DEBUG_FORTH_WORDS 
2208			;		DMARK "EX7" 
2208			;		CALLMONITOR 
2208			;	endif 
2208			;	NEXTW 
2208			 
2208			;.STKEXEC: 
2208			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2208			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2208			; 
2208			; 
2208			;		if DEBUG_FORTH_WORDS_KEY 
2208			;			DMARK "STX" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			; 
2208			;	FORTH_DSP_VALUEHL 
2208			; 
2208			;	ld (store_tmp1), hl    ; count 
2208			; 
2208			;	FORTH_DSP_POP 
2208			;.stkexec1: 
2208			;	ld hl, (store_tmp1)   ; count 
2208			;	ld a, 0 
2208			;	cp l 
2208			;	ret z 
2208			; 
2208			;	dec hl 
2208			;	ld (store_tmp1), hl    ; count 
2208			;	 
2208			;	FORTH_DSP_VALUEHL 
2208			;	push hl 
2208			;	 
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EXp" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			;	FORTH_DSP_POP 
2208			; 
2208			;	call strlenz 
2208			;	inc hl   ; include zero term to copy 
2208			;	inc hl   ; include zero term to copy 
2208			;	inc hl   ; include zero term to copy 
2208			;	ld b,0 
2208			;	ld c,l 
2208			;	pop hl 
2208			;	ld de, execscratch 
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EX3" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			;	ldir 
2208			; 
2208			; 
2208			;	ld hl, execscratch 
2208			; 
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EXP" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			; 
2208			;	call forthparse 
2208			;	ld hl, execscratch 
2208			;		if DEBUG_FORTH_WORDS 
2208			;			DMARK "EXx" 
2208			;			CALLMONITOR 
2208			;		endif 
2208			;	call forthexec 
2208			; 
2208			;	jp .stkexec1 
2208			; 
2208			;	ret 
2208			 
2208			 
2208			.DUP: 
2208				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2208 17				db WORD_SYS_CORE+OPCODE_DUP             
2209 7e 22			dw .ZDUP            
220b 04				db 3 + 1 
220c .. 00			db "DUP",0              
2210				endm 
# End of macro CWHEAD
2210			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2210			 
2210					if DEBUG_FORTH_WORDS_KEY 
2210						DMARK "DUP" 
2210 f5				push af  
2211 3a 25 22			ld a, (.dmark)  
2214 32 6e fb			ld (debug_mark),a  
2217 3a 26 22			ld a, (.dmark+1)  
221a 32 6f fb			ld (debug_mark+1),a  
221d 3a 27 22			ld a, (.dmark+2)  
2220 32 70 fb			ld (debug_mark+2),a  
2223 18 03			jr .pastdmark  
2225 ..			.dmark: db "DUP"  
2228 f1			.pastdmark: pop af  
2229			endm  
# End of macro DMARK
2229						CALLMONITOR 
2229 cd ab 16			call break_point_state  
222c				endm  
# End of macro CALLMONITOR
222c					endif 
222c			 
222c					FORTH_DSP 
222c cd c5 1e			call macro_forth_dsp 
222f				endm 
# End of macro FORTH_DSP
222f			 
222f 7e					ld a, (HL) 
2230 fe 01				cp DS_TYPE_STR 
2232 20 25				jr nz, .dupinum 
2234			 
2234					; push another string 
2234			 
2234					FORTH_DSP_VALUEHL     		 
2234 cd ff 1e			call macro_dsp_valuehl 
2237				endm 
# End of macro FORTH_DSP_VALUEHL
2237			 
2237				if DEBUG_FORTH_WORDS 
2237					DMARK "DUs" 
2237 f5				push af  
2238 3a 4c 22			ld a, (.dmark)  
223b 32 6e fb			ld (debug_mark),a  
223e 3a 4d 22			ld a, (.dmark+1)  
2241 32 6f fb			ld (debug_mark+1),a  
2244 3a 4e 22			ld a, (.dmark+2)  
2247 32 70 fb			ld (debug_mark+2),a  
224a 18 03			jr .pastdmark  
224c ..			.dmark: db "DUs"  
224f f1			.pastdmark: pop af  
2250			endm  
# End of macro DMARK
2250					CALLMONITOR 
2250 cd ab 16			call break_point_state  
2253				endm  
# End of macro CALLMONITOR
2253				endif 
2253 cd 76 1d				call forth_push_str 
2256			 
2256					NEXTW 
2256 c3 71 20			jp macro_next 
2259				endm 
# End of macro NEXTW
2259			 
2259			 
2259			.dupinum: 
2259					 
2259			 
2259			 
2259					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2259 cd ff 1e			call macro_dsp_valuehl 
225c				endm 
# End of macro FORTH_DSP_VALUEHL
225c			 
225c				; TODO add floating point number detection 
225c			 
225c				if DEBUG_FORTH_WORDS 
225c					DMARK "DUi" 
225c f5				push af  
225d 3a 71 22			ld a, (.dmark)  
2260 32 6e fb			ld (debug_mark),a  
2263 3a 72 22			ld a, (.dmark+1)  
2266 32 6f fb			ld (debug_mark+1),a  
2269 3a 73 22			ld a, (.dmark+2)  
226c 32 70 fb			ld (debug_mark+2),a  
226f 18 03			jr .pastdmark  
2271 ..			.dmark: db "DUi"  
2274 f1			.pastdmark: pop af  
2275			endm  
# End of macro DMARK
2275					CALLMONITOR 
2275 cd ab 16			call break_point_state  
2278				endm  
# End of macro CALLMONITOR
2278				endif 
2278			 
2278 cd 08 1d				call forth_push_numhl 
227b					NEXTW 
227b c3 71 20			jp macro_next 
227e				endm 
# End of macro NEXTW
227e			.ZDUP: 
227e				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
227e 99				db WORD_SYS_CORE+OPCODE_ZDUP             
227f b6 22			dw .SWAP            
2281 05				db 4 + 1 
2282 .. 00			db "?DUP",0              
2287				endm 
# End of macro CWHEAD
2287			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2287			 
2287					if DEBUG_FORTH_WORDS_KEY 
2287						DMARK "qDU" 
2287 f5				push af  
2288 3a 9c 22			ld a, (.dmark)  
228b 32 6e fb			ld (debug_mark),a  
228e 3a 9d 22			ld a, (.dmark+1)  
2291 32 6f fb			ld (debug_mark+1),a  
2294 3a 9e 22			ld a, (.dmark+2)  
2297 32 70 fb			ld (debug_mark+2),a  
229a 18 03			jr .pastdmark  
229c ..			.dmark: db "qDU"  
229f f1			.pastdmark: pop af  
22a0			endm  
# End of macro DMARK
22a0						CALLMONITOR 
22a0 cd ab 16			call break_point_state  
22a3				endm  
# End of macro CALLMONITOR
22a3					endif 
22a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22a3 cd ff 1e			call macro_dsp_valuehl 
22a6				endm 
# End of macro FORTH_DSP_VALUEHL
22a6			 
22a6 e5					push hl 
22a7			 
22a7					; is it a zero? 
22a7			 
22a7 3e 00				ld a, 0 
22a9 84					add h 
22aa 85					add l 
22ab			 
22ab e1					pop hl 
22ac			 
22ac fe 00				cp 0 
22ae 28 03				jr z, .dup2orig 
22b0			 
22b0			 
22b0 cd 08 1d				call forth_push_numhl 
22b3			 
22b3			 
22b3				; TODO add floating point number detection 
22b3			 
22b3			.dup2orig: 
22b3			 
22b3					NEXTW 
22b3 c3 71 20			jp macro_next 
22b6				endm 
# End of macro NEXTW
22b6			.SWAP: 
22b6				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
22b6 18				db WORD_SYS_CORE+OPCODE_SWAP             
22b7 f5 22			dw .COLN            
22b9 05				db 4 + 1 
22ba .. 00			db "SWAP",0              
22bf				endm 
# End of macro CWHEAD
22bf			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
22bf					if DEBUG_FORTH_WORDS_KEY 
22bf						DMARK "SWP" 
22bf f5				push af  
22c0 3a d4 22			ld a, (.dmark)  
22c3 32 6e fb			ld (debug_mark),a  
22c6 3a d5 22			ld a, (.dmark+1)  
22c9 32 6f fb			ld (debug_mark+1),a  
22cc 3a d6 22			ld a, (.dmark+2)  
22cf 32 70 fb			ld (debug_mark+2),a  
22d2 18 03			jr .pastdmark  
22d4 ..			.dmark: db "SWP"  
22d7 f1			.pastdmark: pop af  
22d8			endm  
# End of macro DMARK
22d8						CALLMONITOR 
22d8 cd ab 16			call break_point_state  
22db				endm  
# End of macro CALLMONITOR
22db					endif 
22db			 
22db					FORTH_DSP_VALUEHL 
22db cd ff 1e			call macro_dsp_valuehl 
22de				endm 
# End of macro FORTH_DSP_VALUEHL
22de e5					push hl     ; w2 
22df			 
22df					FORTH_DSP_POP 
22df cd b7 1f			call macro_forth_dsp_pop 
22e2				endm 
# End of macro FORTH_DSP_POP
22e2			 
22e2					FORTH_DSP_VALUEHL 
22e2 cd ff 1e			call macro_dsp_valuehl 
22e5				endm 
# End of macro FORTH_DSP_VALUEHL
22e5			 
22e5					FORTH_DSP_POP 
22e5 cd b7 1f			call macro_forth_dsp_pop 
22e8				endm 
# End of macro FORTH_DSP_POP
22e8			 
22e8 d1					pop de     ; w2	, hl = w1 
22e9			 
22e9 eb					ex de, hl 
22ea d5					push de 
22eb			 
22eb cd 08 1d				call forth_push_numhl 
22ee			 
22ee e1					pop hl 
22ef			 
22ef cd 08 1d				call forth_push_numhl 
22f2					 
22f2			 
22f2					NEXTW 
22f2 c3 71 20			jp macro_next 
22f5				endm 
# End of macro NEXTW
22f5			.COLN: 
22f5				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
22f5 19				db WORD_SYS_CORE+OPCODE_COLN             
22f6 81 24			dw .SCOLN            
22f8 02				db 1 + 1 
22f9 .. 00			db ":",0              
22fb				endm 
# End of macro CWHEAD
22fb			; | : ( -- )         Create new word | DONE 
22fb			 
22fb					if DEBUG_FORTH_WORDS_KEY 
22fb						DMARK "CLN" 
22fb f5				push af  
22fc 3a 10 23			ld a, (.dmark)  
22ff 32 6e fb			ld (debug_mark),a  
2302 3a 11 23			ld a, (.dmark+1)  
2305 32 6f fb			ld (debug_mark+1),a  
2308 3a 12 23			ld a, (.dmark+2)  
230b 32 70 fb			ld (debug_mark+2),a  
230e 18 03			jr .pastdmark  
2310 ..			.dmark: db "CLN"  
2313 f1			.pastdmark: pop af  
2314			endm  
# End of macro DMARK
2314						CALLMONITOR 
2314 cd ab 16			call break_point_state  
2317				endm  
# End of macro CALLMONITOR
2317					endif 
2317				STACKFRAME OFF $8efe $989f 
2317				if DEBUG_STACK_IMB 
2317					if OFF 
2317						exx 
2317						ld de, $8efe 
2317						ld a, d 
2317						ld hl, curframe 
2317						call hexout 
2317						ld a, e 
2317						ld hl, curframe+2 
2317						call hexout 
2317						ld hl, $8efe 
2317						push hl 
2317						ld hl, $989f 
2317						push hl 
2317						exx 
2317					endif 
2317				endif 
2317			endm 
# End of macro STACKFRAME
2317				; get parser buffer length  of new word 
2317			 
2317				 
2317			 
2317					; move tok past this to start of name defintition 
2317					; TODO get word to define 
2317					; TODO Move past word token 
2317					; TODO get length of string up to the ';' 
2317			 
2317 2a 15 f1			ld hl, (os_tok_ptr) 
231a 23				inc hl 
231b 23				inc hl 
231c			 
231c 3e 3b			ld a, ';' 
231e cd 6d 11			call strlent 
2321			 
2321 7d				ld a,l 
2322 32 10 ee			ld (os_new_parse_len), a 
2325			 
2325			 
2325			if DEBUG_FORTH_UWORD 
2325 ed 5b 15 f1		ld de, (os_tok_ptr) 
2329						DMARK ":01" 
2329 f5				push af  
232a 3a 3e 23			ld a, (.dmark)  
232d 32 6e fb			ld (debug_mark),a  
2330 3a 3f 23			ld a, (.dmark+1)  
2333 32 6f fb			ld (debug_mark+1),a  
2336 3a 40 23			ld a, (.dmark+2)  
2339 32 70 fb			ld (debug_mark+2),a  
233c 18 03			jr .pastdmark  
233e ..			.dmark: db ":01"  
2341 f1			.pastdmark: pop af  
2342			endm  
# End of macro DMARK
2342				CALLMONITOR 
2342 cd ab 16			call break_point_state  
2345				endm  
# End of macro CALLMONITOR
2345			endif 
2345			 
2345			; 
2345			;  new word memory layout: 
2345			;  
2345			;    : adg 6666 ;  
2345			; 
2345			;    db   1     ; user defined word  
2345 23				inc hl    
2346			;    dw   sysdict 
2346 23				inc hl 
2347 23				inc hl 
2348			;    db <word len>+1 (for null) 
2348 23				inc hl 
2349			;    db .... <word> 
2349			; 
2349			 
2349 23				inc hl    ; some extras for the word preamble before the above 
234a 23				inc hl 
234b 23				inc hl 
234c 23				inc hl 
234d 23				inc hl 
234e 23				inc hl 
234f 23				inc hl  
2350 23				inc hl 
2351 23				inc hl 
2352 23				inc hl 
2353 23				inc hl 
2354 23				inc hl 
2355 23				inc hl 
2356 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2357			;       exec word buffer 
2357			;	<ptr word>   
2357 23				inc hl 
2358 23				inc hl 
2359			;       <word list><null term> 7F final term 
2359			 
2359			 
2359			if DEBUG_FORTH_UWORD 
2359						DMARK ":02" 
2359 f5				push af  
235a 3a 6e 23			ld a, (.dmark)  
235d 32 6e fb			ld (debug_mark),a  
2360 3a 6f 23			ld a, (.dmark+1)  
2363 32 6f fb			ld (debug_mark+1),a  
2366 3a 70 23			ld a, (.dmark+2)  
2369 32 70 fb			ld (debug_mark+2),a  
236c 18 03			jr .pastdmark  
236e ..			.dmark: db ":02"  
2371 f1			.pastdmark: pop af  
2372			endm  
# End of macro DMARK
2372				CALLMONITOR 
2372 cd ab 16			call break_point_state  
2375				endm  
# End of macro CALLMONITOR
2375			endif 
2375			 
2375				 
2375					; malloc the size 
2375			 
2375 cd cb 11				call malloc 
2378 22 12 ee				ld (os_new_malloc), hl     ; save malloc start 
237b			 
237b			;    db   1     ; user defined word  
237b 3e 01				ld a, WORD_SYS_UWORD  
237d 77					ld (hl), a 
237e				 
237e 23				inc hl    
237f			;    dw   sysdict 
237f 11 c9 21			ld de, sysdict       ; continue on with the scan to the system dict 
2382 73				ld (hl), e 
2383 23				inc hl 
2384 72				ld (hl), d 
2385 23				inc hl 
2386			 
2386			 
2386			;    Setup dict word 
2386			 
2386 23				inc hl 
2387 22 0c ee			ld (os_new_work_ptr), hl     ; save start of dict word  
238a			 
238a				; 1. get length of dict word 
238a			 
238a			 
238a 2a 15 f1			ld hl, (os_tok_ptr) 
238d 23				inc hl 
238e 23				inc hl    ; position to start of dict word 
238f 3e 00			ld a, 0 
2391 cd 6d 11			call strlent 
2394			 
2394			 
2394 23				inc hl    ; to include null??? 
2395			 
2395				; write length of dict word 
2395			 
2395 ed 5b 0c ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2399 1b				dec de 
239a eb				ex de, hl 
239b 73				ld (hl), e 
239c eb				ex de, hl 
239d			 
239d				 
239d			 
239d				; copy  
239d 4d				ld c, l 
239e 06 00			ld b, 0 
23a0 ed 5b 0c ee		ld de, (os_new_work_ptr)   ; get dest for copy of word 
23a4 2a 15 f1			ld hl, (os_tok_ptr) 
23a7 23				inc hl 
23a8 23				inc hl    ; position to start of dict word 
23a9				 
23a9			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
23a9				 
23a9				; TODO need to convert word to upper case 
23a9			 
23a9			ucasetok:	 
23a9 7e				ld a,(hl) 
23aa cd 59 11			call toUpper 
23ad 77				ld (hl),a 
23ae ed a0			ldi 
23b0 f2 a9 23		 	jp p, ucasetok 
23b3			 
23b3			 
23b3			 
23b3				; de now points to start of where the word body code should be placed 
23b3 ed 53 0c ee		ld (os_new_work_ptr), de 
23b7				; hl now points to the words to throw at forthexec which needs to be copied 
23b7 22 0a ee			ld (os_new_src_ptr), hl 
23ba			 
23ba				; TODO add 'call to forthexec' 
23ba			 
23ba			if DEBUG_FORTH_UWORD 
23ba c5				push bc 
23bb ed 4b 12 ee		ld bc, (os_new_malloc) 
23bf						DMARK ":0x" 
23bf f5				push af  
23c0 3a d4 23			ld a, (.dmark)  
23c3 32 6e fb			ld (debug_mark),a  
23c6 3a d5 23			ld a, (.dmark+1)  
23c9 32 6f fb			ld (debug_mark+1),a  
23cc 3a d6 23			ld a, (.dmark+2)  
23cf 32 70 fb			ld (debug_mark+2),a  
23d2 18 03			jr .pastdmark  
23d4 ..			.dmark: db ":0x"  
23d7 f1			.pastdmark: pop af  
23d8			endm  
# End of macro DMARK
23d8				CALLMONITOR 
23d8 cd ab 16			call break_point_state  
23db				endm  
# End of macro CALLMONITOR
23db c1				pop bc 
23dc			endif 
23dc			 
23dc			 
23dc				; create word preamble which should be: 
23dc			 
23dc			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
23dc			 
23dc				;    ld hl, <word code> 
23dc				;    jp user_exec 
23dc			        ;    <word code bytes> 
23dc			 
23dc			 
23dc			;	inc de     ; TODO ??? or are we already past the word's null 
23dc eb				ex de, hl 
23dd			 
23dd 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
23df			 
23df 23				inc hl 
23e0 22 06 ee			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
23e3 23				inc hl 
23e4			 
23e4 23				inc hl 
23e5 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
23e7			 
23e7 01 60 51			ld bc, user_exec 
23ea 23				inc hl 
23eb 71				ld (hl), c     ; poke address of user_exec 
23ec 23				inc hl 
23ed 70				ld (hl), b     
23ee			 ; 
23ee			;	inc hl 
23ee			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23ee			; 
23ee			; 
23ee			;	ld bc, macro_forth_rsp_next 
23ee			;	inc hl 
23ee			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
23ee			;	inc hl 
23ee			;	ld (hl), b     
23ee			 ; 
23ee			;	inc hl 
23ee			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
23ee			; 
23ee			; 
23ee			;	inc hl 
23ee			;	ld bc, forthexec 
23ee			;	ld (hl), c     ; poke address of forthexec 
23ee			;	inc hl 
23ee			;	ld (hl), b      
23ee			; 
23ee			;	inc hl 
23ee			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
23ee			; 
23ee			;	ld bc, user_dict_next 
23ee			;	inc hl 
23ee			;	ld (hl), c     ; poke address of forthexec 
23ee			;	inc hl 
23ee			;	ld (hl), b      
23ee			 
23ee				; hl is now where we need to copy the word byte data to save this 
23ee			 
23ee 23				inc hl 
23ef 22 08 ee			ld (os_new_exec), hl 
23f2				 
23f2				; copy definition 
23f2			 
23f2 eb				ex de, hl 
23f3			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
23f3			;	inc de    ; skip the PC for this parse 
23f3 3a 10 ee			ld a, (os_new_parse_len) 
23f6 4f				ld c, a 
23f7 06 00			ld b, 0 
23f9 ed b0			ldir		 ; copy defintion 
23fb			 
23fb			 
23fb				; poke the address of where the new word bytes live for forthexec 
23fb			 
23fb 2a 06 ee			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
23fe			 
23fe ed 5b 08 ee		ld de, (os_new_exec)      
2402				 
2402 73				ld (hl), e 
2403 23				inc hl 
2404 72				ld (hl), d 
2405			 
2405					; TODO copy last user dict word next link to this word 
2405					; TODO update last user dict word to point to this word 
2405			; 
2405			; hl f923 de 812a ; bc 811a 
2405			 
2405			if DEBUG_FORTH_UWORD 
2405 c5				push bc 
2406 ed 4b 12 ee		ld bc, (os_new_malloc) 
240a						DMARK ":0A" 
240a f5				push af  
240b 3a 1f 24			ld a, (.dmark)  
240e 32 6e fb			ld (debug_mark),a  
2411 3a 20 24			ld a, (.dmark+1)  
2414 32 6f fb			ld (debug_mark+1),a  
2417 3a 21 24			ld a, (.dmark+2)  
241a 32 70 fb			ld (debug_mark+2),a  
241d 18 03			jr .pastdmark  
241f ..			.dmark: db ":0A"  
2422 f1			.pastdmark: pop af  
2423			endm  
# End of macro DMARK
2423				CALLMONITOR 
2423 cd ab 16			call break_point_state  
2426				endm  
# End of macro CALLMONITOR
2426 c1				pop bc 
2427			endif 
2427			if DEBUG_FORTH_UWORD 
2427 c5				push bc 
2428 ed 4b 12 ee		ld bc, (os_new_malloc) 
242c 03				inc bc 
242d 03				inc bc 
242e 03				inc bc 
242f 03				inc bc 
2430 03				inc bc 
2431 03				inc bc 
2432 03				inc bc 
2433 03				inc bc 
2434			 
2434						DMARK ":0B" 
2434 f5				push af  
2435 3a 49 24			ld a, (.dmark)  
2438 32 6e fb			ld (debug_mark),a  
243b 3a 4a 24			ld a, (.dmark+1)  
243e 32 6f fb			ld (debug_mark+1),a  
2441 3a 4b 24			ld a, (.dmark+2)  
2444 32 70 fb			ld (debug_mark+2),a  
2447 18 03			jr .pastdmark  
2449 ..			.dmark: db ":0B"  
244c f1			.pastdmark: pop af  
244d			endm  
# End of macro DMARK
244d				CALLMONITOR 
244d cd ab 16			call break_point_state  
2450				endm  
# End of macro CALLMONITOR
2450 c1				pop bc 
2451			endif 
2451			 
2451			; update word dict linked list for new word 
2451			 
2451			 
2451 2a 11 f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2454 23			inc hl     ; move to next work linked list ptr 
2455			 
2455 ed 5b 12 ee	ld de, (os_new_malloc)		 ; new next word 
2459 73			ld (hl), e 
245a 23			inc hl 
245b 72			ld (hl), d 
245c			 
245c			if DEBUG_FORTH_UWORD 
245c ed 4b 11 f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2460			endif 
2460			 
2460 ed 53 11 f1	ld (os_last_new_uword), de      ; update last new uword ptr 
2464			 
2464			 
2464			if DEBUG_FORTH_UWORD 
2464						DMARK ":0+" 
2464 f5				push af  
2465 3a 79 24			ld a, (.dmark)  
2468 32 6e fb			ld (debug_mark),a  
246b 3a 7a 24			ld a, (.dmark+1)  
246e 32 6f fb			ld (debug_mark+1),a  
2471 3a 7b 24			ld a, (.dmark+2)  
2474 32 70 fb			ld (debug_mark+2),a  
2477 18 03			jr .pastdmark  
2479 ..			.dmark: db ":0+"  
247c f1			.pastdmark: pop af  
247d			endm  
# End of macro DMARK
247d				CALLMONITOR 
247d cd ab 16			call break_point_state  
2480				endm  
# End of macro CALLMONITOR
2480			endif 
2480			 
2480				STACKFRAMECHK OFF $8efe $989f 
2480				if DEBUG_STACK_IMB 
2480					if OFF 
2480						exx 
2480						ld hl, $989f 
2480						pop de   ; $989f 
2480						call cmp16 
2480						jr nz, .spnosame 
2480						ld hl, $8efe 
2480						pop de   ; $8efe 
2480						call cmp16 
2480						jr z, .spfrsame 
2480						.spnosame: call showsperror 
2480						.spfrsame: nop 
2480						exx 
2480					endif 
2480				endif 
2480			endm 
# End of macro STACKFRAMECHK
2480			 
2480 c9			ret    ; dont process any remaining parser tokens as they form new word 
2481			 
2481			 
2481			 
2481			 
2481			;		NEXT 
2481			.SCOLN: 
2481			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2481 06				db OPCODE_SCOLN 
2482 cd 24			dw .DROP 
2484 02				db 2 
2485 .. 00			db ";",0           
2487			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2487					if DEBUG_FORTH_WORDS_KEY 
2487						DMARK "SCN" 
2487 f5				push af  
2488 3a 9c 24			ld a, (.dmark)  
248b 32 6e fb			ld (debug_mark),a  
248e 3a 9d 24			ld a, (.dmark+1)  
2491 32 6f fb			ld (debug_mark+1),a  
2494 3a 9e 24			ld a, (.dmark+2)  
2497 32 70 fb			ld (debug_mark+2),a  
249a 18 03			jr .pastdmark  
249c ..			.dmark: db "SCN"  
249f f1			.pastdmark: pop af  
24a0			endm  
# End of macro DMARK
24a0						CALLMONITOR 
24a0 cd ab 16			call break_point_state  
24a3				endm  
# End of macro CALLMONITOR
24a3					endif 
24a3					FORTH_RSP_TOS 
24a3 cd c6 1c			call macro_forth_rsp_tos 
24a6				endm 
# End of macro FORTH_RSP_TOS
24a6 e5					push hl 
24a7					FORTH_RSP_POP 
24a7 cd d0 1c			call macro_forth_rsp_pop 
24aa				endm 
# End of macro FORTH_RSP_POP
24aa e1					pop hl 
24ab			;		ex de,hl 
24ab 22 15 f1				ld (os_tok_ptr),hl 
24ae			 
24ae			if DEBUG_FORTH_UWORD 
24ae						DMARK "SCL" 
24ae f5				push af  
24af 3a c3 24			ld a, (.dmark)  
24b2 32 6e fb			ld (debug_mark),a  
24b5 3a c4 24			ld a, (.dmark+1)  
24b8 32 6f fb			ld (debug_mark+1),a  
24bb 3a c5 24			ld a, (.dmark+2)  
24be 32 70 fb			ld (debug_mark+2),a  
24c1 18 03			jr .pastdmark  
24c3 ..			.dmark: db "SCL"  
24c6 f1			.pastdmark: pop af  
24c7			endm  
# End of macro DMARK
24c7				CALLMONITOR 
24c7 cd ab 16			call break_point_state  
24ca				endm  
# End of macro CALLMONITOR
24ca			endif 
24ca					NEXTW 
24ca c3 71 20			jp macro_next 
24cd				endm 
# End of macro NEXTW
24cd			 
24cd			.DROP: 
24cd				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
24cd 1b				db WORD_SYS_CORE+OPCODE_DROP             
24ce f8 24			dw .DUP2            
24d0 05				db 4 + 1 
24d1 .. 00			db "DROP",0              
24d6				endm 
# End of macro CWHEAD
24d6			; | DROP ( w -- )   drop the TOS item   | DONE 
24d6					if DEBUG_FORTH_WORDS_KEY 
24d6						DMARK "DRP" 
24d6 f5				push af  
24d7 3a eb 24			ld a, (.dmark)  
24da 32 6e fb			ld (debug_mark),a  
24dd 3a ec 24			ld a, (.dmark+1)  
24e0 32 6f fb			ld (debug_mark+1),a  
24e3 3a ed 24			ld a, (.dmark+2)  
24e6 32 70 fb			ld (debug_mark+2),a  
24e9 18 03			jr .pastdmark  
24eb ..			.dmark: db "DRP"  
24ee f1			.pastdmark: pop af  
24ef			endm  
# End of macro DMARK
24ef						CALLMONITOR 
24ef cd ab 16			call break_point_state  
24f2				endm  
# End of macro CALLMONITOR
24f2					endif 
24f2					FORTH_DSP_POP 
24f2 cd b7 1f			call macro_forth_dsp_pop 
24f5				endm 
# End of macro FORTH_DSP_POP
24f5					NEXTW 
24f5 c3 71 20			jp macro_next 
24f8				endm 
# End of macro NEXTW
24f8			.DUP2: 
24f8				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
24f8 1c				db WORD_SYS_CORE+OPCODE_DUP2             
24f9 3d 25			dw .DROP2            
24fb 05				db 4 + 1 
24fc .. 00			db "2DUP",0              
2501				endm 
# End of macro CWHEAD
2501			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2501					if DEBUG_FORTH_WORDS_KEY 
2501						DMARK "2DU" 
2501 f5				push af  
2502 3a 16 25			ld a, (.dmark)  
2505 32 6e fb			ld (debug_mark),a  
2508 3a 17 25			ld a, (.dmark+1)  
250b 32 6f fb			ld (debug_mark+1),a  
250e 3a 18 25			ld a, (.dmark+2)  
2511 32 70 fb			ld (debug_mark+2),a  
2514 18 03			jr .pastdmark  
2516 ..			.dmark: db "2DU"  
2519 f1			.pastdmark: pop af  
251a			endm  
# End of macro DMARK
251a						CALLMONITOR 
251a cd ab 16			call break_point_state  
251d				endm  
# End of macro CALLMONITOR
251d					endif 
251d					FORTH_DSP_VALUEHL 
251d cd ff 1e			call macro_dsp_valuehl 
2520				endm 
# End of macro FORTH_DSP_VALUEHL
2520 e5					push hl      ; 2 
2521			 
2521					FORTH_DSP_POP 
2521 cd b7 1f			call macro_forth_dsp_pop 
2524				endm 
# End of macro FORTH_DSP_POP
2524					 
2524					FORTH_DSP_VALUEHL 
2524 cd ff 1e			call macro_dsp_valuehl 
2527				endm 
# End of macro FORTH_DSP_VALUEHL
2527			;		push hl      ; 1 
2527			 
2527					FORTH_DSP_POP 
2527 cd b7 1f			call macro_forth_dsp_pop 
252a				endm 
# End of macro FORTH_DSP_POP
252a			 
252a			;		pop hl       ; 1 
252a d1					pop de       ; 2 
252b			 
252b cd 08 1d				call forth_push_numhl 
252e eb					ex de, hl 
252f cd 08 1d				call forth_push_numhl 
2532			 
2532					 
2532 eb					ex de, hl 
2533			 
2533 cd 08 1d				call forth_push_numhl 
2536 eb					ex de, hl 
2537 cd 08 1d				call forth_push_numhl 
253a			 
253a			 
253a					NEXTW 
253a c3 71 20			jp macro_next 
253d				endm 
# End of macro NEXTW
253d			.DROP2: 
253d				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
253d 1d				db WORD_SYS_CORE+OPCODE_DROP2             
253e 6c 25			dw .SWAP2            
2540 06				db 5 + 1 
2541 .. 00			db "2DROP",0              
2547				endm 
# End of macro CWHEAD
2547			; | 2DROP ( w w -- )    Double drop | DONE 
2547					if DEBUG_FORTH_WORDS_KEY 
2547						DMARK "2DR" 
2547 f5				push af  
2548 3a 5c 25			ld a, (.dmark)  
254b 32 6e fb			ld (debug_mark),a  
254e 3a 5d 25			ld a, (.dmark+1)  
2551 32 6f fb			ld (debug_mark+1),a  
2554 3a 5e 25			ld a, (.dmark+2)  
2557 32 70 fb			ld (debug_mark+2),a  
255a 18 03			jr .pastdmark  
255c ..			.dmark: db "2DR"  
255f f1			.pastdmark: pop af  
2560			endm  
# End of macro DMARK
2560						CALLMONITOR 
2560 cd ab 16			call break_point_state  
2563				endm  
# End of macro CALLMONITOR
2563					endif 
2563					FORTH_DSP_POP 
2563 cd b7 1f			call macro_forth_dsp_pop 
2566				endm 
# End of macro FORTH_DSP_POP
2566					FORTH_DSP_POP 
2566 cd b7 1f			call macro_forth_dsp_pop 
2569				endm 
# End of macro FORTH_DSP_POP
2569					NEXTW 
2569 c3 71 20			jp macro_next 
256c				endm 
# End of macro NEXTW
256c			.SWAP2: 
256c				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
256c 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
256d 95 25			dw .AT            
256f 06				db 5 + 1 
2570 .. 00			db "2SWAP",0              
2576				endm 
# End of macro CWHEAD
2576			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2576					if DEBUG_FORTH_WORDS_KEY 
2576						DMARK "2SW" 
2576 f5				push af  
2577 3a 8b 25			ld a, (.dmark)  
257a 32 6e fb			ld (debug_mark),a  
257d 3a 8c 25			ld a, (.dmark+1)  
2580 32 6f fb			ld (debug_mark+1),a  
2583 3a 8d 25			ld a, (.dmark+2)  
2586 32 70 fb			ld (debug_mark+2),a  
2589 18 03			jr .pastdmark  
258b ..			.dmark: db "2SW"  
258e f1			.pastdmark: pop af  
258f			endm  
# End of macro DMARK
258f						CALLMONITOR 
258f cd ab 16			call break_point_state  
2592				endm  
# End of macro CALLMONITOR
2592					endif 
2592					NEXTW 
2592 c3 71 20			jp macro_next 
2595				endm 
# End of macro NEXTW
2595			.AT: 
2595				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2595 1f				db WORD_SYS_CORE+OPCODE_AT             
2596 c7 25			dw .CAT            
2598 02				db 1 + 1 
2599 .. 00			db "@",0              
259b				endm 
# End of macro CWHEAD
259b			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
259b			 
259b					if DEBUG_FORTH_WORDS_KEY 
259b						DMARK "AT." 
259b f5				push af  
259c 3a b0 25			ld a, (.dmark)  
259f 32 6e fb			ld (debug_mark),a  
25a2 3a b1 25			ld a, (.dmark+1)  
25a5 32 6f fb			ld (debug_mark+1),a  
25a8 3a b2 25			ld a, (.dmark+2)  
25ab 32 70 fb			ld (debug_mark+2),a  
25ae 18 03			jr .pastdmark  
25b0 ..			.dmark: db "AT."  
25b3 f1			.pastdmark: pop af  
25b4			endm  
# End of macro DMARK
25b4						CALLMONITOR 
25b4 cd ab 16			call break_point_state  
25b7				endm  
# End of macro CALLMONITOR
25b7					endif 
25b7			.getbyteat:	 
25b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25b7 cd ff 1e			call macro_dsp_valuehl 
25ba				endm 
# End of macro FORTH_DSP_VALUEHL
25ba					 
25ba			;		push hl 
25ba				 
25ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ba cd b7 1f			call macro_forth_dsp_pop 
25bd				endm 
# End of macro FORTH_DSP_POP
25bd			 
25bd			;		pop hl 
25bd			 
25bd 7e					ld a, (hl) 
25be			 
25be 6f					ld l, a 
25bf 26 00				ld h, 0 
25c1 cd 08 1d				call forth_push_numhl 
25c4			 
25c4					NEXTW 
25c4 c3 71 20			jp macro_next 
25c7				endm 
# End of macro NEXTW
25c7			.CAT: 
25c7				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
25c7 20				db WORD_SYS_CORE+OPCODE_CAT             
25c8 f0 25			dw .BANG            
25ca 03				db 2 + 1 
25cb .. 00			db "C@",0              
25ce				endm 
# End of macro CWHEAD
25ce			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
25ce					if DEBUG_FORTH_WORDS_KEY 
25ce						DMARK "CAA" 
25ce f5				push af  
25cf 3a e3 25			ld a, (.dmark)  
25d2 32 6e fb			ld (debug_mark),a  
25d5 3a e4 25			ld a, (.dmark+1)  
25d8 32 6f fb			ld (debug_mark+1),a  
25db 3a e5 25			ld a, (.dmark+2)  
25de 32 70 fb			ld (debug_mark+2),a  
25e1 18 03			jr .pastdmark  
25e3 ..			.dmark: db "CAA"  
25e6 f1			.pastdmark: pop af  
25e7			endm  
# End of macro DMARK
25e7						CALLMONITOR 
25e7 cd ab 16			call break_point_state  
25ea				endm  
# End of macro CALLMONITOR
25ea					endif 
25ea c3 b7 25				jp .getbyteat 
25ed					NEXTW 
25ed c3 71 20			jp macro_next 
25f0				endm 
# End of macro NEXTW
25f0			.BANG: 
25f0				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
25f0 21				db WORD_SYS_CORE+OPCODE_BANG             
25f1 26 26			dw .CBANG            
25f3 02				db 1 + 1 
25f4 .. 00			db "!",0              
25f6				endm 
# End of macro CWHEAD
25f6			; | ! ( x w -- ) Store x at address w      | DONE 
25f6					if DEBUG_FORTH_WORDS_KEY 
25f6						DMARK "BNG" 
25f6 f5				push af  
25f7 3a 0b 26			ld a, (.dmark)  
25fa 32 6e fb			ld (debug_mark),a  
25fd 3a 0c 26			ld a, (.dmark+1)  
2600 32 6f fb			ld (debug_mark+1),a  
2603 3a 0d 26			ld a, (.dmark+2)  
2606 32 70 fb			ld (debug_mark+2),a  
2609 18 03			jr .pastdmark  
260b ..			.dmark: db "BNG"  
260e f1			.pastdmark: pop af  
260f			endm  
# End of macro DMARK
260f						CALLMONITOR 
260f cd ab 16			call break_point_state  
2612				endm  
# End of macro CALLMONITOR
2612					endif 
2612			 
2612			.storebyteat:		 
2612					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2612 cd ff 1e			call macro_dsp_valuehl 
2615				endm 
# End of macro FORTH_DSP_VALUEHL
2615					 
2615 e5					push hl 
2616				 
2616					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2616 cd b7 1f			call macro_forth_dsp_pop 
2619				endm 
# End of macro FORTH_DSP_POP
2619			 
2619					; get byte to poke 
2619			 
2619					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2619 cd ff 1e			call macro_dsp_valuehl 
261c				endm 
# End of macro FORTH_DSP_VALUEHL
261c e5					push hl 
261d			 
261d			 
261d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
261d cd b7 1f			call macro_forth_dsp_pop 
2620				endm 
# End of macro FORTH_DSP_POP
2620			 
2620			 
2620 d1					pop de 
2621 e1					pop hl 
2622			 
2622 73					ld (hl),e 
2623			 
2623			 
2623					NEXTW 
2623 c3 71 20			jp macro_next 
2626				endm 
# End of macro NEXTW
2626			.CBANG: 
2626				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2626 22				db WORD_SYS_CORE+OPCODE_CBANG             
2627 4f 26			dw .SCALL            
2629 03				db 2 + 1 
262a .. 00			db "C!",0              
262d				endm 
# End of macro CWHEAD
262d			; | C!  ( x w -- ) Store x at address w  | DONE 
262d					if DEBUG_FORTH_WORDS_KEY 
262d						DMARK "CBA" 
262d f5				push af  
262e 3a 42 26			ld a, (.dmark)  
2631 32 6e fb			ld (debug_mark),a  
2634 3a 43 26			ld a, (.dmark+1)  
2637 32 6f fb			ld (debug_mark+1),a  
263a 3a 44 26			ld a, (.dmark+2)  
263d 32 70 fb			ld (debug_mark+2),a  
2640 18 03			jr .pastdmark  
2642 ..			.dmark: db "CBA"  
2645 f1			.pastdmark: pop af  
2646			endm  
# End of macro DMARK
2646						CALLMONITOR 
2646 cd ab 16			call break_point_state  
2649				endm  
# End of macro CALLMONITOR
2649					endif 
2649 c3 12 26				jp .storebyteat 
264c					NEXTW 
264c c3 71 20			jp macro_next 
264f				endm 
# End of macro NEXTW
264f			.SCALL: 
264f				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
264f 23				db WORD_SYS_CORE+OPCODE_SCALL             
2650 83 26			dw .DEPTH            
2652 05				db 4 + 1 
2653 .. 00			db "CALL",0              
2658				endm 
# End of macro CWHEAD
2658			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2658					if DEBUG_FORTH_WORDS_KEY 
2658						DMARK "CLL" 
2658 f5				push af  
2659 3a 6d 26			ld a, (.dmark)  
265c 32 6e fb			ld (debug_mark),a  
265f 3a 6e 26			ld a, (.dmark+1)  
2662 32 6f fb			ld (debug_mark+1),a  
2665 3a 6f 26			ld a, (.dmark+2)  
2668 32 70 fb			ld (debug_mark+2),a  
266b 18 03			jr .pastdmark  
266d ..			.dmark: db "CLL"  
2670 f1			.pastdmark: pop af  
2671			endm  
# End of macro DMARK
2671						CALLMONITOR 
2671 cd ab 16			call break_point_state  
2674				endm  
# End of macro CALLMONITOR
2674					endif 
2674			 
2674					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2674 cd ff 1e			call macro_dsp_valuehl 
2677				endm 
# End of macro FORTH_DSP_VALUEHL
2677			 
2677			;		push hl 
2677			 
2677					; destroy value TOS 
2677			 
2677					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2677 cd b7 1f			call macro_forth_dsp_pop 
267a				endm 
# End of macro FORTH_DSP_POP
267a			 
267a						 
267a			;		pop hl 
267a			 
267a					; how to do a call with hl???? save SP? 
267a cd 1a 20				call forth_call_hl 
267d			 
267d			 
267d					; TODO push value back onto stack for another op etc 
267d			 
267d cd 08 1d				call forth_push_numhl 
2680					NEXTW 
2680 c3 71 20			jp macro_next 
2683				endm 
# End of macro NEXTW
2683			.DEPTH: 
2683				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2683 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2684 c0 26			dw .OVER            
2686 06				db 5 + 1 
2687 .. 00			db "DEPTH",0              
268d				endm 
# End of macro CWHEAD
268d			; | DEPTH ( -- u ) Push count of stack | DONE 
268d					; take current TOS and remove from base value div by two to get count 
268d					if DEBUG_FORTH_WORDS_KEY 
268d						DMARK "DEP" 
268d f5				push af  
268e 3a a2 26			ld a, (.dmark)  
2691 32 6e fb			ld (debug_mark),a  
2694 3a a3 26			ld a, (.dmark+1)  
2697 32 6f fb			ld (debug_mark+1),a  
269a 3a a4 26			ld a, (.dmark+2)  
269d 32 70 fb			ld (debug_mark+2),a  
26a0 18 03			jr .pastdmark  
26a2 ..			.dmark: db "DEP"  
26a5 f1			.pastdmark: pop af  
26a6			endm  
# End of macro DMARK
26a6						CALLMONITOR 
26a6 cd ab 16			call break_point_state  
26a9				endm  
# End of macro CALLMONITOR
26a9					endif 
26a9			 
26a9			 
26a9 2a 01 f8			ld hl, (cli_data_sp) 
26ac 11 7b f3			ld de, cli_data_stack 
26af ed 52			sbc hl,de 
26b1				 
26b1				; div by size of stack item 
26b1			 
26b1 5d				ld e,l 
26b2 0e 03			ld c, 3 
26b4 cd 94 0c			call Div8 
26b7			 
26b7 6f				ld l,a 
26b8 26 00			ld h,0 
26ba			 
26ba				;srl h 
26ba				;rr l 
26ba			 
26ba cd 08 1d				call forth_push_numhl 
26bd					NEXTW 
26bd c3 71 20			jp macro_next 
26c0				endm 
# End of macro NEXTW
26c0			.OVER: 
26c0				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
26c0 42				db WORD_SYS_CORE+46             
26c1 07 27			dw .PAUSE            
26c3 05				db 4 + 1 
26c4 .. 00			db "OVER",0              
26c9				endm 
# End of macro CWHEAD
26c9			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
26c9					if DEBUG_FORTH_WORDS_KEY 
26c9						DMARK "OVR" 
26c9 f5				push af  
26ca 3a de 26			ld a, (.dmark)  
26cd 32 6e fb			ld (debug_mark),a  
26d0 3a df 26			ld a, (.dmark+1)  
26d3 32 6f fb			ld (debug_mark+1),a  
26d6 3a e0 26			ld a, (.dmark+2)  
26d9 32 70 fb			ld (debug_mark+2),a  
26dc 18 03			jr .pastdmark  
26de ..			.dmark: db "OVR"  
26e1 f1			.pastdmark: pop af  
26e2			endm  
# End of macro DMARK
26e2						CALLMONITOR 
26e2 cd ab 16			call break_point_state  
26e5				endm  
# End of macro CALLMONITOR
26e5					endif 
26e5			 
26e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e5 cd ff 1e			call macro_dsp_valuehl 
26e8				endm 
# End of macro FORTH_DSP_VALUEHL
26e8 e5					push hl    ; n2 
26e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26e9 cd b7 1f			call macro_forth_dsp_pop 
26ec				endm 
# End of macro FORTH_DSP_POP
26ec			 
26ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26ec cd ff 1e			call macro_dsp_valuehl 
26ef				endm 
# End of macro FORTH_DSP_VALUEHL
26ef e5					push hl    ; n1 
26f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f0 cd b7 1f			call macro_forth_dsp_pop 
26f3				endm 
# End of macro FORTH_DSP_POP
26f3			 
26f3 d1					pop de     ; n1 
26f4 e1					pop hl     ; n2 
26f5			 
26f5 d5					push de 
26f6 e5					push hl 
26f7 d5					push de 
26f8			 
26f8					; push back  
26f8			 
26f8 e1					pop hl 
26f9 cd 08 1d				call forth_push_numhl 
26fc e1					pop hl 
26fd cd 08 1d				call forth_push_numhl 
2700 e1					pop hl 
2701 cd 08 1d				call forth_push_numhl 
2704					NEXTW 
2704 c3 71 20			jp macro_next 
2707				endm 
# End of macro NEXTW
2707			 
2707			.PAUSE: 
2707				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2707 43				db WORD_SYS_CORE+47             
2708 3c 27			dw .PAUSES            
270a 08				db 7 + 1 
270b .. 00			db "PAUSEMS",0              
2713				endm 
# End of macro CWHEAD
2713			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2713					if DEBUG_FORTH_WORDS_KEY 
2713						DMARK "PMS" 
2713 f5				push af  
2714 3a 28 27			ld a, (.dmark)  
2717 32 6e fb			ld (debug_mark),a  
271a 3a 29 27			ld a, (.dmark+1)  
271d 32 6f fb			ld (debug_mark+1),a  
2720 3a 2a 27			ld a, (.dmark+2)  
2723 32 70 fb			ld (debug_mark+2),a  
2726 18 03			jr .pastdmark  
2728 ..			.dmark: db "PMS"  
272b f1			.pastdmark: pop af  
272c			endm  
# End of macro DMARK
272c						CALLMONITOR 
272c cd ab 16			call break_point_state  
272f				endm  
# End of macro CALLMONITOR
272f					endif 
272f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
272f cd ff 1e			call macro_dsp_valuehl 
2732				endm 
# End of macro FORTH_DSP_VALUEHL
2732			;		push hl    ; n2 
2732					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2732 cd b7 1f			call macro_forth_dsp_pop 
2735				endm 
# End of macro FORTH_DSP_POP
2735			;		pop hl 
2735			 
2735 7d					ld a, l 
2736 cd 32 0a				call aDelayInMS 
2739				       NEXTW 
2739 c3 71 20			jp macro_next 
273c				endm 
# End of macro NEXTW
273c			.PAUSES:  
273c				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
273c 44				db WORD_SYS_CORE+48             
273d ab 27			dw .ROT            
273f 06				db 5 + 1 
2740 .. 00			db "PAUSE",0              
2746				endm 
# End of macro CWHEAD
2746			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2746					if DEBUG_FORTH_WORDS_KEY 
2746						DMARK "PAU" 
2746 f5				push af  
2747 3a 5b 27			ld a, (.dmark)  
274a 32 6e fb			ld (debug_mark),a  
274d 3a 5c 27			ld a, (.dmark+1)  
2750 32 6f fb			ld (debug_mark+1),a  
2753 3a 5d 27			ld a, (.dmark+2)  
2756 32 70 fb			ld (debug_mark+2),a  
2759 18 03			jr .pastdmark  
275b ..			.dmark: db "PAU"  
275e f1			.pastdmark: pop af  
275f			endm  
# End of macro DMARK
275f						CALLMONITOR 
275f cd ab 16			call break_point_state  
2762				endm  
# End of macro CALLMONITOR
2762					endif 
2762					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2762 cd ff 1e			call macro_dsp_valuehl 
2765				endm 
# End of macro FORTH_DSP_VALUEHL
2765			;		push hl    ; n2 
2765					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2765 cd b7 1f			call macro_forth_dsp_pop 
2768				endm 
# End of macro FORTH_DSP_POP
2768			;		pop hl 
2768 45					ld b, l 
2769					if DEBUG_FORTH_WORDS 
2769						DMARK "PAU" 
2769 f5				push af  
276a 3a 7e 27			ld a, (.dmark)  
276d 32 6e fb			ld (debug_mark),a  
2770 3a 7f 27			ld a, (.dmark+1)  
2773 32 6f fb			ld (debug_mark+1),a  
2776 3a 80 27			ld a, (.dmark+2)  
2779 32 70 fb			ld (debug_mark+2),a  
277c 18 03			jr .pastdmark  
277e ..			.dmark: db "PAU"  
2781 f1			.pastdmark: pop af  
2782			endm  
# End of macro DMARK
2782						CALLMONITOR 
2782 cd ab 16			call break_point_state  
2785				endm  
# End of macro CALLMONITOR
2785					endif 
2785 c5			.pauses1:	push bc 
2786 cd 4d 0a				call delay1s 
2789 c1					pop bc 
278a					if DEBUG_FORTH_WORDS 
278a						DMARK "PA1" 
278a f5				push af  
278b 3a 9f 27			ld a, (.dmark)  
278e 32 6e fb			ld (debug_mark),a  
2791 3a a0 27			ld a, (.dmark+1)  
2794 32 6f fb			ld (debug_mark+1),a  
2797 3a a1 27			ld a, (.dmark+2)  
279a 32 70 fb			ld (debug_mark+2),a  
279d 18 03			jr .pastdmark  
279f ..			.dmark: db "PA1"  
27a2 f1			.pastdmark: pop af  
27a3			endm  
# End of macro DMARK
27a3						CALLMONITOR 
27a3 cd ab 16			call break_point_state  
27a6				endm  
# End of macro CALLMONITOR
27a6					endif 
27a6 10 dd				djnz .pauses1 
27a8			 
27a8				       NEXTW 
27a8 c3 71 20			jp macro_next 
27ab				endm 
# End of macro NEXTW
27ab			.ROT: 
27ab				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
27ab 45				db WORD_SYS_CORE+49             
27ac f9 27			dw .UWORDS            
27ae 04				db 3 + 1 
27af .. 00			db "ROT",0              
27b3				endm 
# End of macro CWHEAD
27b3			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
27b3					if DEBUG_FORTH_WORDS_KEY 
27b3						DMARK "ROT" 
27b3 f5				push af  
27b4 3a c8 27			ld a, (.dmark)  
27b7 32 6e fb			ld (debug_mark),a  
27ba 3a c9 27			ld a, (.dmark+1)  
27bd 32 6f fb			ld (debug_mark+1),a  
27c0 3a ca 27			ld a, (.dmark+2)  
27c3 32 70 fb			ld (debug_mark+2),a  
27c6 18 03			jr .pastdmark  
27c8 ..			.dmark: db "ROT"  
27cb f1			.pastdmark: pop af  
27cc			endm  
# End of macro DMARK
27cc						CALLMONITOR 
27cc cd ab 16			call break_point_state  
27cf				endm  
# End of macro CALLMONITOR
27cf					endif 
27cf			 
27cf					FORTH_DSP_VALUEHL 
27cf cd ff 1e			call macro_dsp_valuehl 
27d2				endm 
# End of macro FORTH_DSP_VALUEHL
27d2 e5					push hl    ; u3  
27d3			 
27d3					FORTH_DSP_POP 
27d3 cd b7 1f			call macro_forth_dsp_pop 
27d6				endm 
# End of macro FORTH_DSP_POP
27d6			   
27d6					FORTH_DSP_VALUEHL 
27d6 cd ff 1e			call macro_dsp_valuehl 
27d9				endm 
# End of macro FORTH_DSP_VALUEHL
27d9 e5					push hl     ; u2 
27da			 
27da					FORTH_DSP_POP 
27da cd b7 1f			call macro_forth_dsp_pop 
27dd				endm 
# End of macro FORTH_DSP_POP
27dd			 
27dd					FORTH_DSP_VALUEHL 
27dd cd ff 1e			call macro_dsp_valuehl 
27e0				endm 
# End of macro FORTH_DSP_VALUEHL
27e0 e5					push hl     ; u1 
27e1			 
27e1					FORTH_DSP_POP 
27e1 cd b7 1f			call macro_forth_dsp_pop 
27e4				endm 
# End of macro FORTH_DSP_POP
27e4			 
27e4 c1					pop bc      ; u1 
27e5 e1					pop hl      ; u2 
27e6 d1					pop de      ; u3 
27e7			 
27e7			 
27e7 c5					push bc 
27e8 d5					push de 
27e9 e5					push hl 
27ea			 
27ea			 
27ea e1					pop hl 
27eb cd 08 1d				call forth_push_numhl 
27ee			 
27ee e1					pop hl 
27ef cd 08 1d				call forth_push_numhl 
27f2			 
27f2 e1					pop hl 
27f3 cd 08 1d				call forth_push_numhl 
27f6					 
27f6			 
27f6			 
27f6			 
27f6			 
27f6			 
27f6				       NEXTW 
27f6 c3 71 20			jp macro_next 
27f9				endm 
# End of macro NEXTW
27f9			 
27f9			.UWORDS: 
27f9				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
27f9 50				db WORD_SYS_CORE+60             
27fa bb 28			dw .BP            
27fc 07				db 6 + 1 
27fd .. 00			db "UWORDS",0              
2804				endm 
# End of macro CWHEAD
2804			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2804			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2804			; | | Following the count are the individual words. 
2804			; | | 
2804			; | | e.g. UWORDS 
2804			; | | BOX DIRLIST 2 
2804			; | |  
2804			; | | Can be used to save the words to storage via: 
2804			; | | UWORDS $01 DO $01 APPEND LOOP 
2804				if DEBUG_FORTH_WORDS_KEY 
2804					DMARK "UWR" 
2804 f5				push af  
2805 3a 19 28			ld a, (.dmark)  
2808 32 6e fb			ld (debug_mark),a  
280b 3a 1a 28			ld a, (.dmark+1)  
280e 32 6f fb			ld (debug_mark+1),a  
2811 3a 1b 28			ld a, (.dmark+2)  
2814 32 70 fb			ld (debug_mark+2),a  
2817 18 03			jr .pastdmark  
2819 ..			.dmark: db "UWR"  
281c f1			.pastdmark: pop af  
281d			endm  
# End of macro DMARK
281d					CALLMONITOR 
281d cd ab 16			call break_point_state  
2820				endm  
# End of macro CALLMONITOR
2820				endif 
2820 21 00 80				ld hl, baseram 
2823					;ld hl, baseusermem 
2823 01 00 00				ld bc, 0    ; start a counter 
2826			 
2826				; skip dict stub 
2826			 
2826 cd c2 21				call forth_tok_next 
2829			 
2829			 
2829			; while we have words to look for 
2829			 
2829 7e			.douscan:	ld a, (hl)      
282a				if DEBUG_FORTH_WORDS 
282a					DMARK "UWs" 
282a f5				push af  
282b 3a 3f 28			ld a, (.dmark)  
282e 32 6e fb			ld (debug_mark),a  
2831 3a 40 28			ld a, (.dmark+1)  
2834 32 6f fb			ld (debug_mark+1),a  
2837 3a 41 28			ld a, (.dmark+2)  
283a 32 70 fb			ld (debug_mark+2),a  
283d 18 03			jr .pastdmark  
283f ..			.dmark: db "UWs"  
2842 f1			.pastdmark: pop af  
2843			endm  
# End of macro DMARK
2843					CALLMONITOR 
2843 cd ab 16			call break_point_state  
2846				endm  
# End of macro CALLMONITOR
2846				endif 
2846 fe 00				cp WORD_SYS_END 
2848 28 4d				jr z, .udone 
284a fe 01				cp WORD_SYS_UWORD 
284c 20 44				jr nz, .nuword 
284e			 
284e				if DEBUG_FORTH_WORDS 
284e					DMARK "UWu" 
284e f5				push af  
284f 3a 63 28			ld a, (.dmark)  
2852 32 6e fb			ld (debug_mark),a  
2855 3a 64 28			ld a, (.dmark+1)  
2858 32 6f fb			ld (debug_mark+1),a  
285b 3a 65 28			ld a, (.dmark+2)  
285e 32 70 fb			ld (debug_mark+2),a  
2861 18 03			jr .pastdmark  
2863 ..			.dmark: db "UWu"  
2866 f1			.pastdmark: pop af  
2867			endm  
# End of macro DMARK
2867					CALLMONITOR 
2867 cd ab 16			call break_point_state  
286a				endm  
# End of macro CALLMONITOR
286a				endif 
286a					; we have a uword so push its name to the stack 
286a			 
286a e5				   	push hl  ; save so we can move to next dict block 
286b			 
286b					; skip opcode 
286b 23					inc hl  
286c					; skip next ptr 
286c 23					inc hl  
286d 23					inc hl 
286e					; skip len 
286e 23					inc hl 
286f				if DEBUG_FORTH_WORDS 
286f					DMARK "UWt" 
286f f5				push af  
2870 3a 84 28			ld a, (.dmark)  
2873 32 6e fb			ld (debug_mark),a  
2876 3a 85 28			ld a, (.dmark+1)  
2879 32 6f fb			ld (debug_mark+1),a  
287c 3a 86 28			ld a, (.dmark+2)  
287f 32 70 fb			ld (debug_mark+2),a  
2882 18 03			jr .pastdmark  
2884 ..			.dmark: db "UWt"  
2887 f1			.pastdmark: pop af  
2888			endm  
# End of macro DMARK
2888					CALLMONITOR 
2888 cd ab 16			call break_point_state  
288b				endm  
# End of macro CALLMONITOR
288b				endif 
288b 03					inc bc 
288c			 
288c c5					push bc 
288d cd 76 1d				call forth_push_str 
2890 c1					pop bc 
2891			 
2891 e1					pop hl 	 
2892			 
2892 cd c2 21		.nuword:	call forth_tok_next 
2895 18 92				jr .douscan  
2897			 
2897			.udone:		 ; push count of uwords found 
2897 c5					push bc 
2898 e1					pop hl 
2899			 
2899				if DEBUG_FORTH_WORDS 
2899					DMARK "UWc" 
2899 f5				push af  
289a 3a ae 28			ld a, (.dmark)  
289d 32 6e fb			ld (debug_mark),a  
28a0 3a af 28			ld a, (.dmark+1)  
28a3 32 6f fb			ld (debug_mark+1),a  
28a6 3a b0 28			ld a, (.dmark+2)  
28a9 32 70 fb			ld (debug_mark+2),a  
28ac 18 03			jr .pastdmark  
28ae ..			.dmark: db "UWc"  
28b1 f1			.pastdmark: pop af  
28b2			endm  
# End of macro DMARK
28b2					CALLMONITOR 
28b2 cd ab 16			call break_point_state  
28b5				endm  
# End of macro CALLMONITOR
28b5				endif 
28b5 cd 08 1d				call forth_push_numhl 
28b8			 
28b8			 
28b8				       NEXTW 
28b8 c3 71 20			jp macro_next 
28bb				endm 
# End of macro NEXTW
28bb			 
28bb			.BP: 
28bb				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
28bb 54				db WORD_SYS_CORE+64             
28bc f1 28			dw .MONITOR            
28be 03				db 2 + 1 
28bf .. 00			db "BP",0              
28c2				endm 
# End of macro CWHEAD
28c2			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
28c2			; | | $00 Will enable the break points within specific code paths 
28c2			; | | $01 Will disable break points 
28c2			; | |  
28c2			; | | By default break points are off. Either the above can be used to enable them 
28c2			; | | or if a key is held down during start up the spashscreen will appear to freeze 
28c2			; | | and on release of the pressed key a message will be disaplayed to notify 
28c2			; | | that break points are enabled. Pressing any key will then continue boot process. 
28c2					; get byte count 
28c2					if DEBUG_FORTH_WORDS_KEY 
28c2						DMARK "BP." 
28c2 f5				push af  
28c3 3a d7 28			ld a, (.dmark)  
28c6 32 6e fb			ld (debug_mark),a  
28c9 3a d8 28			ld a, (.dmark+1)  
28cc 32 6f fb			ld (debug_mark+1),a  
28cf 3a d9 28			ld a, (.dmark+2)  
28d2 32 70 fb			ld (debug_mark+2),a  
28d5 18 03			jr .pastdmark  
28d7 ..			.dmark: db "BP."  
28da f1			.pastdmark: pop af  
28db			endm  
# End of macro DMARK
28db						CALLMONITOR 
28db cd ab 16			call break_point_state  
28de				endm  
# End of macro CALLMONITOR
28de					endif 
28de			 
28de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28de cd ff 1e			call macro_dsp_valuehl 
28e1				endm 
# End of macro FORTH_DSP_VALUEHL
28e1			 
28e1			;		push hl 
28e1			 
28e1					; destroy value TOS 
28e1			 
28e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28e1 cd b7 1f			call macro_forth_dsp_pop 
28e4				endm 
# End of macro FORTH_DSP_POP
28e4			 
28e4			;		pop hl 
28e4			 
28e4 3e 00				ld a,0 
28e6 bd					cp l 
28e7 28 02				jr z, .bpset 
28e9 3e 2a				ld a, '*' 
28eb			 
28eb 32 05 ee		.bpset:		ld (os_view_disable), a 
28ee			 
28ee			 
28ee					NEXTW 
28ee c3 71 20			jp macro_next 
28f1				endm 
# End of macro NEXTW
28f1			 
28f1			 
28f1			.MONITOR: 
28f1				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
28f1 55				db WORD_SYS_CORE+65             
28f2 24 29			dw .MALLOC            
28f4 08				db 7 + 1 
28f5 .. 00			db "MONITOR",0              
28fd				endm 
# End of macro CWHEAD
28fd			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
28fd			; | | At start the current various registers will be displayed with contents. 
28fd			; | | Top right corner will show the most recent debug marker seen. 
28fd			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
28fd			; | | and the return stack pointer (RSP). 
28fd			; | | Pressing: 
28fd			; | |    1 - Initial screen 
28fd			; | |    2 - Display a data dump of HL 
28fd			; | |    3 - Display a data dump of DE 
28fd			; | |    4 - Display a data dump of BC 
28fd			; | |    5 - Display a data dump of HL 
28fd			; | |    6 - Display a data dump of DSP 
28fd			; | |    7 - Display a data dump of RSP 
28fd			; | |    8 - Display a data dump of what is at DSP 
28fd			; | |    9 - Display a data dump of what is at RSP 
28fd			; | |    0 - Exit monitor and continue running. This will also enable break points 
28fd			; | |    * - Disable break points 
28fd			; | |    # - Enter traditional monitor mode 
28fd			; | | 
28fd			; | | Monitor Mode 
28fd			; | | ------------ 
28fd			; | | A prompt of '>' will be shown for various commands: 
28fd			; | |    D xxxx - Display a data dump starting from hex address xxxx 
28fd			; | |    C - Continue display a data dump from the last set address 
28fd			; | |    M xxxx - Set start of memory edit at address xx 
28fd			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
28fd			; | |    Q - Return to previous 
28fd					if DEBUG_FORTH_WORDS_KEY 
28fd						DMARK "MON" 
28fd f5				push af  
28fe 3a 12 29			ld a, (.dmark)  
2901 32 6e fb			ld (debug_mark),a  
2904 3a 13 29			ld a, (.dmark+1)  
2907 32 6f fb			ld (debug_mark+1),a  
290a 3a 14 29			ld a, (.dmark+2)  
290d 32 70 fb			ld (debug_mark+2),a  
2910 18 03			jr .pastdmark  
2912 ..			.dmark: db "MON"  
2915 f1			.pastdmark: pop af  
2916			endm  
# End of macro DMARK
2916						CALLMONITOR 
2916 cd ab 16			call break_point_state  
2919				endm  
# End of macro CALLMONITOR
2919					endif 
2919 3e 00				ld a, 0 
291b 32 05 ee				ld (os_view_disable), a 
291e			 
291e					CALLMONITOR 
291e cd ab 16			call break_point_state  
2921				endm  
# End of macro CALLMONITOR
2921			 
2921			;	call monitor 
2921			 
2921					NEXTW 
2921 c3 71 20			jp macro_next 
2924				endm 
# End of macro NEXTW
2924			 
2924			 
2924			.MALLOC: 
2924				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2924 56				db WORD_SYS_CORE+66             
2925 4d 29			dw .MALLOC2            
2927 06				db 5 + 1 
2928 .. 00			db "ALLOT",0              
292e				endm 
# End of macro CWHEAD
292e			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
292e					if DEBUG_FORTH_WORDS_KEY 
292e						DMARK "ALL" 
292e f5				push af  
292f 3a 43 29			ld a, (.dmark)  
2932 32 6e fb			ld (debug_mark),a  
2935 3a 44 29			ld a, (.dmark+1)  
2938 32 6f fb			ld (debug_mark+1),a  
293b 3a 45 29			ld a, (.dmark+2)  
293e 32 70 fb			ld (debug_mark+2),a  
2941 18 03			jr .pastdmark  
2943 ..			.dmark: db "ALL"  
2946 f1			.pastdmark: pop af  
2947			endm  
# End of macro DMARK
2947						CALLMONITOR 
2947 cd ab 16			call break_point_state  
294a				endm  
# End of macro CALLMONITOR
294a					endif 
294a c3 74 29				jp .mallocc 
294d			.MALLOC2: 
294d				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
294d 56				db WORD_SYS_CORE+66             
294e 8b 29			dw .FREE            
2950 07				db 6 + 1 
2951 .. 00			db "MALLOC",0              
2958				endm 
# End of macro CWHEAD
2958			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2958					; get byte count 
2958					if DEBUG_FORTH_WORDS_KEY 
2958						DMARK "MAL" 
2958 f5				push af  
2959 3a 6d 29			ld a, (.dmark)  
295c 32 6e fb			ld (debug_mark),a  
295f 3a 6e 29			ld a, (.dmark+1)  
2962 32 6f fb			ld (debug_mark+1),a  
2965 3a 6f 29			ld a, (.dmark+2)  
2968 32 70 fb			ld (debug_mark+2),a  
296b 18 03			jr .pastdmark  
296d ..			.dmark: db "MAL"  
2970 f1			.pastdmark: pop af  
2971			endm  
# End of macro DMARK
2971						CALLMONITOR 
2971 cd ab 16			call break_point_state  
2974				endm  
# End of macro CALLMONITOR
2974					endif 
2974			.mallocc: 
2974					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2974 cd ff 1e			call macro_dsp_valuehl 
2977				endm 
# End of macro FORTH_DSP_VALUEHL
2977			 
2977			;		push hl 
2977			 
2977					; destroy value TOS 
2977			 
2977					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2977 cd b7 1f			call macro_forth_dsp_pop 
297a				endm 
# End of macro FORTH_DSP_POP
297a			 
297a			;		pop hl 
297a cd cb 11				call malloc 
297d				if DEBUG_FORTH_MALLOC_GUARD 
297d f5					push af 
297e cd 2d 0d				call ishlzero 
2981			;		ld a, l 
2981			;		add h 
2981			;		cp 0 
2981 f1					pop af 
2982					 
2982 cc 32 52				call z,malloc_error 
2985				endif 
2985			 
2985 cd 08 1d				call forth_push_numhl 
2988					NEXTW 
2988 c3 71 20			jp macro_next 
298b				endm 
# End of macro NEXTW
298b			 
298b			.FREE: 
298b				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
298b 57				db WORD_SYS_CORE+67             
298c bc 29			dw .LIST            
298e 05				db 4 + 1 
298f .. 00			db "FREE",0              
2994				endm 
# End of macro CWHEAD
2994			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2994					if DEBUG_FORTH_WORDS_KEY 
2994						DMARK "FRE" 
2994 f5				push af  
2995 3a a9 29			ld a, (.dmark)  
2998 32 6e fb			ld (debug_mark),a  
299b 3a aa 29			ld a, (.dmark+1)  
299e 32 6f fb			ld (debug_mark+1),a  
29a1 3a ab 29			ld a, (.dmark+2)  
29a4 32 70 fb			ld (debug_mark+2),a  
29a7 18 03			jr .pastdmark  
29a9 ..			.dmark: db "FRE"  
29ac f1			.pastdmark: pop af  
29ad			endm  
# End of macro DMARK
29ad						CALLMONITOR 
29ad cd ab 16			call break_point_state  
29b0				endm  
# End of macro CALLMONITOR
29b0					endif 
29b0					; get address 
29b0			 
29b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29b0 cd ff 1e			call macro_dsp_valuehl 
29b3				endm 
# End of macro FORTH_DSP_VALUEHL
29b3			 
29b3			;		push hl 
29b3			 
29b3					; destroy value TOS 
29b3			 
29b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29b3 cd b7 1f			call macro_forth_dsp_pop 
29b6				endm 
# End of macro FORTH_DSP_POP
29b6			 
29b6			;		pop hl 
29b6			if FORTH_ENABLE_MALLOCFREE 
29b6 cd 95 12				call free 
29b9			endif 
29b9					NEXTW 
29b9 c3 71 20			jp macro_next 
29bc				endm 
# End of macro NEXTW
29bc			.LIST: 
29bc				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
29bc 5c				db WORD_SYS_CORE+72             
29bd aa 2b			dw .FORGET            
29bf 05				db 4 + 1 
29c0 .. 00			db "LIST",0              
29c5				endm 
# End of macro CWHEAD
29c5			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
29c5			; | | The quoted word must be in upper case. 
29c5				if DEBUG_FORTH_WORDS_KEY 
29c5					DMARK "LST" 
29c5 f5				push af  
29c6 3a da 29			ld a, (.dmark)  
29c9 32 6e fb			ld (debug_mark),a  
29cc 3a db 29			ld a, (.dmark+1)  
29cf 32 6f fb			ld (debug_mark+1),a  
29d2 3a dc 29			ld a, (.dmark+2)  
29d5 32 70 fb			ld (debug_mark+2),a  
29d8 18 03			jr .pastdmark  
29da ..			.dmark: db "LST"  
29dd f1			.pastdmark: pop af  
29de			endm  
# End of macro DMARK
29de					CALLMONITOR 
29de cd ab 16			call break_point_state  
29e1				endm  
# End of macro CALLMONITOR
29e1				endif 
29e1			 
29e1					FORTH_DSP_VALUEHL 
29e1 cd ff 1e			call macro_dsp_valuehl 
29e4				endm 
# End of macro FORTH_DSP_VALUEHL
29e4			 
29e4 e5					push hl 
29e5					FORTH_DSP_POP 
29e5 cd b7 1f			call macro_forth_dsp_pop 
29e8				endm 
# End of macro FORTH_DSP_POP
29e8 c1					pop bc 
29e9			 
29e9			; Start format of scratch string 
29e9			 
29e9 21 14 ee				ld hl, scratch 
29ec			 
29ec 3e 3a				ld a, ':' 
29ee 77					ld (hl),a 
29ef 23					inc hl 
29f0 3e 20				ld a, ' ' 
29f2 77					ld (hl), a 
29f3			 
29f3					; Get ptr to the word we need to look up 
29f3			 
29f3			;		FORTH_DSP_VALUEHL 
29f3					;v5 FORTH_DSP_VALUE 
29f3				; TODO type check 
29f3			;		inc hl    ; Skip type check  
29f3			;		push hl 
29f3			;		ex de, hl    ; put into DE 
29f3			 
29f3			 
29f3 21 00 80				ld hl, baseram 
29f6					;ld hl, baseusermem 
29f6			 
29f6 e5			push hl   ; sacreifical push 
29f7			 
29f7			.ldouscanm: 
29f7 e1				pop hl 
29f8			.ldouscan: 
29f8				if DEBUG_FORTH_WORDS 
29f8					DMARK "LSs" 
29f8 f5				push af  
29f9 3a 0d 2a			ld a, (.dmark)  
29fc 32 6e fb			ld (debug_mark),a  
29ff 3a 0e 2a			ld a, (.dmark+1)  
2a02 32 6f fb			ld (debug_mark+1),a  
2a05 3a 0f 2a			ld a, (.dmark+2)  
2a08 32 70 fb			ld (debug_mark+2),a  
2a0b 18 03			jr .pastdmark  
2a0d ..			.dmark: db "LSs"  
2a10 f1			.pastdmark: pop af  
2a11			endm  
# End of macro DMARK
2a11					CALLMONITOR 
2a11 cd ab 16			call break_point_state  
2a14				endm  
# End of macro CALLMONITOR
2a14				endif 
2a14				; skip dict stub 
2a14 cd c2 21				call forth_tok_next 
2a17			 
2a17			 
2a17			; while we have words to look for 
2a17			 
2a17 7e				ld a, (hl)      
2a18				if DEBUG_FORTH_WORDS 
2a18					DMARK "LSk" 
2a18 f5				push af  
2a19 3a 2d 2a			ld a, (.dmark)  
2a1c 32 6e fb			ld (debug_mark),a  
2a1f 3a 2e 2a			ld a, (.dmark+1)  
2a22 32 6f fb			ld (debug_mark+1),a  
2a25 3a 2f 2a			ld a, (.dmark+2)  
2a28 32 70 fb			ld (debug_mark+2),a  
2a2b 18 03			jr .pastdmark  
2a2d ..			.dmark: db "LSk"  
2a30 f1			.pastdmark: pop af  
2a31			endm  
# End of macro DMARK
2a31					CALLMONITOR 
2a31 cd ab 16			call break_point_state  
2a34				endm  
# End of macro CALLMONITOR
2a34				endif 
2a34					;cp WORD_SYS_END 
2a34					;jp z, .lunotfound 
2a34			 
2a34					; if we hit non uwords then gone too far 
2a34 fe 01				cp WORD_SYS_UWORD 
2a36 c2 66 2b				jp nz, .lunotfound 
2a39			 
2a39				if DEBUG_FORTH_WORDS 
2a39					DMARK "LSu" 
2a39 f5				push af  
2a3a 3a 4e 2a			ld a, (.dmark)  
2a3d 32 6e fb			ld (debug_mark),a  
2a40 3a 4f 2a			ld a, (.dmark+1)  
2a43 32 6f fb			ld (debug_mark+1),a  
2a46 3a 50 2a			ld a, (.dmark+2)  
2a49 32 70 fb			ld (debug_mark+2),a  
2a4c 18 03			jr .pastdmark  
2a4e ..			.dmark: db "LSu"  
2a51 f1			.pastdmark: pop af  
2a52			endm  
# End of macro DMARK
2a52					CALLMONITOR 
2a52 cd ab 16			call break_point_state  
2a55				endm  
# End of macro CALLMONITOR
2a55				endif 
2a55			 
2a55					; found a uword but is it the one we want... 
2a55			 
2a55 c5					push bc     ; uword to find is on bc 
2a56 d1					pop de 
2a57			 
2a57 e5					push hl  ; to save the ptr 
2a58			 
2a58					; skip opcode 
2a58 23					inc hl  
2a59					; skip next ptr 
2a59 23					inc hl  
2a5a 23					inc hl 
2a5b					; skip len 
2a5b 23					inc hl 
2a5c			 
2a5c				if DEBUG_FORTH_WORDS 
2a5c					DMARK "LSc" 
2a5c f5				push af  
2a5d 3a 71 2a			ld a, (.dmark)  
2a60 32 6e fb			ld (debug_mark),a  
2a63 3a 72 2a			ld a, (.dmark+1)  
2a66 32 6f fb			ld (debug_mark+1),a  
2a69 3a 73 2a			ld a, (.dmark+2)  
2a6c 32 70 fb			ld (debug_mark+2),a  
2a6f 18 03			jr .pastdmark  
2a71 ..			.dmark: db "LSc"  
2a74 f1			.pastdmark: pop af  
2a75			endm  
# End of macro DMARK
2a75					CALLMONITOR 
2a75 cd ab 16			call break_point_state  
2a78				endm  
# End of macro CALLMONITOR
2a78				endif 
2a78 cd 9a 11				call strcmp 
2a7b c2 f7 29				jp nz, .ldouscanm 
2a7e				 
2a7e			 
2a7e			 
2a7e					; we have a uword so push its name to the stack 
2a7e			 
2a7e			;	   	push hl  ; save so we can move to next dict block 
2a7e e1			pop hl 
2a7f			 
2a7f				if DEBUG_FORTH_WORDS 
2a7f					DMARK "LSm" 
2a7f f5				push af  
2a80 3a 94 2a			ld a, (.dmark)  
2a83 32 6e fb			ld (debug_mark),a  
2a86 3a 95 2a			ld a, (.dmark+1)  
2a89 32 6f fb			ld (debug_mark+1),a  
2a8c 3a 96 2a			ld a, (.dmark+2)  
2a8f 32 70 fb			ld (debug_mark+2),a  
2a92 18 03			jr .pastdmark  
2a94 ..			.dmark: db "LSm"  
2a97 f1			.pastdmark: pop af  
2a98			endm  
# End of macro DMARK
2a98					CALLMONITOR 
2a98 cd ab 16			call break_point_state  
2a9b				endm  
# End of macro CALLMONITOR
2a9b				endif 
2a9b			 
2a9b					; skip opcode 
2a9b 23					inc hl  
2a9c					; skip next ptr 
2a9c 23					inc hl  
2a9d 23					inc hl 
2a9e					; skip len 
2a9e 7e					ld a, (hl)   ; save length to add 
2a9f				if DEBUG_FORTH_WORDS 
2a9f					DMARK "LS2" 
2a9f f5				push af  
2aa0 3a b4 2a			ld a, (.dmark)  
2aa3 32 6e fb			ld (debug_mark),a  
2aa6 3a b5 2a			ld a, (.dmark+1)  
2aa9 32 6f fb			ld (debug_mark+1),a  
2aac 3a b6 2a			ld a, (.dmark+2)  
2aaf 32 70 fb			ld (debug_mark+2),a  
2ab2 18 03			jr .pastdmark  
2ab4 ..			.dmark: db "LS2"  
2ab7 f1			.pastdmark: pop af  
2ab8			endm  
# End of macro DMARK
2ab8					CALLMONITOR 
2ab8 cd ab 16			call break_point_state  
2abb				endm  
# End of macro CALLMONITOR
2abb				endif 
2abb			 
2abb					; save this location 
2abb				 
2abb e5					push hl 
2abc			 
2abc 23					inc hl 
2abd 11 16 ee				ld de, scratch+2 
2ac0 4f					ld c, a 
2ac1 06 00				ld b, 0 
2ac3			 
2ac3				if DEBUG_FORTH_WORDS 
2ac3					DMARK "LSn" 
2ac3 f5				push af  
2ac4 3a d8 2a			ld a, (.dmark)  
2ac7 32 6e fb			ld (debug_mark),a  
2aca 3a d9 2a			ld a, (.dmark+1)  
2acd 32 6f fb			ld (debug_mark+1),a  
2ad0 3a da 2a			ld a, (.dmark+2)  
2ad3 32 70 fb			ld (debug_mark+2),a  
2ad6 18 03			jr .pastdmark  
2ad8 ..			.dmark: db "LSn"  
2adb f1			.pastdmark: pop af  
2adc			endm  
# End of macro DMARK
2adc					CALLMONITOR 
2adc cd ab 16			call break_point_state  
2adf				endm  
# End of macro CALLMONITOR
2adf				endif 
2adf			 
2adf					; copy uword name to scratch 
2adf			 
2adf ed b0				ldir 
2ae1			 
2ae1 1b					dec de 
2ae2 3e 20				ld a, ' '    ; change null to space 
2ae4 12					ld (de), a 
2ae5			 
2ae5 13					inc de 
2ae6			 
2ae6 d5					push de 
2ae7 c1					pop bc     ; move scratch pointer to end of word name and save it 
2ae8			 
2ae8 e1					pop hl 
2ae9 7e					ld a, (hl) 
2aea					;inc hl 
2aea					; skip word string 
2aea cd 04 0d				call addatohl 
2aed			 
2aed 23					inc hl 
2aee			 
2aee				if DEBUG_FORTH_WORDS 
2aee					DMARK "LS3" 
2aee f5				push af  
2aef 3a 03 2b			ld a, (.dmark)  
2af2 32 6e fb			ld (debug_mark),a  
2af5 3a 04 2b			ld a, (.dmark+1)  
2af8 32 6f fb			ld (debug_mark+1),a  
2afb 3a 05 2b			ld a, (.dmark+2)  
2afe 32 70 fb			ld (debug_mark+2),a  
2b01 18 03			jr .pastdmark  
2b03 ..			.dmark: db "LS3"  
2b06 f1			.pastdmark: pop af  
2b07			endm  
# End of macro DMARK
2b07					CALLMONITOR 
2b07 cd ab 16			call break_point_state  
2b0a				endm  
# End of macro CALLMONITOR
2b0a				endif 
2b0a					; should now be at the start of the machine code to setup the eval of the uword 
2b0a					; now locate the ptr to the string defintion 
2b0a			 
2b0a					; skip ld hl, 
2b0a					; then load the ptr 
2b0a			; TODO use get from hl ptr 
2b0a 23					inc hl 
2b0b 5e					ld e, (hl) 
2b0c 23					inc hl 
2b0d 56					ld d, (hl) 
2b0e eb					ex de, hl 
2b0f			 
2b0f			 
2b0f				if DEBUG_FORTH_WORDS 
2b0f					DMARK "LSt" 
2b0f f5				push af  
2b10 3a 24 2b			ld a, (.dmark)  
2b13 32 6e fb			ld (debug_mark),a  
2b16 3a 25 2b			ld a, (.dmark+1)  
2b19 32 6f fb			ld (debug_mark+1),a  
2b1c 3a 26 2b			ld a, (.dmark+2)  
2b1f 32 70 fb			ld (debug_mark+2),a  
2b22 18 03			jr .pastdmark  
2b24 ..			.dmark: db "LSt"  
2b27 f1			.pastdmark: pop af  
2b28			endm  
# End of macro DMARK
2b28					CALLMONITOR 
2b28 cd ab 16			call break_point_state  
2b2b				endm  
# End of macro CALLMONITOR
2b2b				endif 
2b2b			 
2b2b			; cant push right now due to tokenised strings  
2b2b			 
2b2b			; get the destination of where to copy this definition to. 
2b2b			 
2b2b c5					push bc 
2b2c d1					pop de 
2b2d			 
2b2d 7e			.listl:         ld a,(hl) 
2b2e fe 00				cp 0 
2b30 28 09				jr z, .lreplsp     ; replace zero with space 
2b32					;cp FORTH_END_BUFFER 
2b32 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2b34 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b36				 
2b36					; just copy this char as is then 
2b36			 
2b36 12					ld (de), a 
2b37			 
2b37 23			.listnxt:	inc hl 
2b38 13					inc de 
2b39 18 f2				jr .listl 
2b3b			 
2b3b 3e 20		.lreplsp:	ld a,' ' 
2b3d 12					ld (de), a 
2b3e 18 f7				jr .listnxt 
2b40			 
2b40			; close up uword def 
2b40			 
2b40			.listdone: 
2b40 12					ld (de), a 
2b41 13					inc de 
2b42 3e 00				ld a, 0 
2b44 12					ld (de), a 
2b45			 
2b45			; now have def so clean up and push to stack 
2b45			 
2b45 21 14 ee				ld hl, scratch 
2b48				if DEBUG_FORTH_WORDS 
2b48					DMARK "Ltp" 
2b48 f5				push af  
2b49 3a 5d 2b			ld a, (.dmark)  
2b4c 32 6e fb			ld (debug_mark),a  
2b4f 3a 5e 2b			ld a, (.dmark+1)  
2b52 32 6f fb			ld (debug_mark+1),a  
2b55 3a 5f 2b			ld a, (.dmark+2)  
2b58 32 70 fb			ld (debug_mark+2),a  
2b5b 18 03			jr .pastdmark  
2b5d ..			.dmark: db "Ltp"  
2b60 f1			.pastdmark: pop af  
2b61			endm  
# End of macro DMARK
2b61					CALLMONITOR 
2b61 cd ab 16			call break_point_state  
2b64				endm  
# End of macro CALLMONITOR
2b64				endif 
2b64			 
2b64 18 1f			jr .listpush 
2b66			 
2b66			;.lnuword:	pop hl 
2b66			;		call forth_tok_next 
2b66			;		jp .ldouscan  
2b66			 
2b66			.lunotfound:		  
2b66			 
2b66				if DEBUG_FORTH_WORDS 
2b66					DMARK "LSn" 
2b66 f5				push af  
2b67 3a 7b 2b			ld a, (.dmark)  
2b6a 32 6e fb			ld (debug_mark),a  
2b6d 3a 7c 2b			ld a, (.dmark+1)  
2b70 32 6f fb			ld (debug_mark+1),a  
2b73 3a 7d 2b			ld a, (.dmark+2)  
2b76 32 70 fb			ld (debug_mark+2),a  
2b79 18 03			jr .pastdmark  
2b7b ..			.dmark: db "LSn"  
2b7e f1			.pastdmark: pop af  
2b7f			endm  
# End of macro DMARK
2b7f					CALLMONITOR 
2b7f cd ab 16			call break_point_state  
2b82				endm  
# End of macro CALLMONITOR
2b82				endif 
2b82			 
2b82					 
2b82			;		FORTH_DSP_POP 
2b82			;		ld hl, .luno 
2b82			 
2b82					NEXTW			 
2b82 c3 71 20			jp macro_next 
2b85				endm 
# End of macro NEXTW
2b85			 
2b85			.listpush: 
2b85				if DEBUG_FORTH_WORDS 
2b85					DMARK "LS>" 
2b85 f5				push af  
2b86 3a 9a 2b			ld a, (.dmark)  
2b89 32 6e fb			ld (debug_mark),a  
2b8c 3a 9b 2b			ld a, (.dmark+1)  
2b8f 32 6f fb			ld (debug_mark+1),a  
2b92 3a 9c 2b			ld a, (.dmark+2)  
2b95 32 70 fb			ld (debug_mark+2),a  
2b98 18 03			jr .pastdmark  
2b9a ..			.dmark: db "LS>"  
2b9d f1			.pastdmark: pop af  
2b9e			endm  
# End of macro DMARK
2b9e					CALLMONITOR 
2b9e cd ab 16			call break_point_state  
2ba1				endm  
# End of macro CALLMONITOR
2ba1				endif 
2ba1 cd 76 1d				call forth_push_str 
2ba4			 
2ba4			 
2ba4			 
2ba4					NEXTW 
2ba4 c3 71 20			jp macro_next 
2ba7				endm 
# End of macro NEXTW
2ba7			 
2ba7			;.luno:    db "Word not found",0 
2ba7			 
2ba7			 
2ba7			 
2ba7			 
2ba7			 
2ba7			;		push hl   ; save pointer to start of uword def string 
2ba7			; 
2ba7			;; look for FORTH_EOL_LINE 
2ba7			;		ld a, FORTH_END_BUFFER 
2ba7			;		call strlent 
2ba7			; 
2ba7			;		inc hl		 ; space for coln def 
2ba7			;		inc hl 
2ba7			;		inc hl          ; space for terms 
2ba7			;		inc hl 
2ba7			; 
2ba7			;		ld a, 20   ; TODO get actual length 
2ba7			;		call addatohl    ; include a random amount of room for the uword name 
2ba7			; 
2ba7			;		 
2ba7			;	if DEBUG_FORTH_WORDS 
2ba7			;		DMARK "Lt1" 
2ba7			;		CALLMONITOR 
2ba7			;	endif 
2ba7			;		 
2ba7			; 
2ba7			;; malloc space for the string because we cant change it 
2ba7			; 
2ba7			;		call malloc 
2ba7			;	if DEBUG_FORTH_MALLOC_GUARD 
2ba7			;		push af 
2ba7			;		call ishlzero 
2ba7			;		pop af 
2ba7			;		 
2ba7			;		call z,malloc_error 
2ba7			;	endif 
2ba7			; 
2ba7			;	if DEBUG_FORTH_WORDS 
2ba7			;		DMARK "Lt2" 
2ba7			;		CALLMONITOR 
2ba7			;	endif 
2ba7			;		pop de 
2ba7			;		push hl    ; push the malloc to release later 
2ba7			;		push hl   ;  push back a copy for the later stack push 
2ba7			;		 
2ba7			;; copy the string swapping out the zero terms for spaces 
2ba7			; 
2ba7			;		; de has our source 
2ba7			;		; hl has our dest 
2ba7			; 
2ba7			;; add the coln def 
2ba7			; 
2ba7			;		ld a, ':' 
2ba7			;		ld (hl), a 
2ba7			;		inc hl 
2ba7			;		ld a, ' ' 
2ba7			;		ld (hl), a 
2ba7			;		inc hl 
2ba7			; 
2ba7			;; add the uname word 
2ba7			;		push de   ; save our string for now 
2ba7			;		ex de, hl 
2ba7			; 
2ba7			;		FORTH_DSP_VALUE 
2ba7			;		;v5 FORTH_DSP_VALUE 
2ba7			; 
2ba7			;		inc hl   ; skip type but we know by now this is OK 
2ba7			; 
2ba7			;.luword:	ld a,(hl) 
2ba7			;		cp 0 
2ba7			;		jr z, .luword2 
2ba7			;		ld (de), a 
2ba7			;		inc de 
2ba7			;		inc hl 
2ba7			;		jr .luword 
2ba7			; 
2ba7			;.luword2:	ld a, ' ' 
2ba7			;		ld (de), a 
2ba7			;;		inc hl 
2ba7			;;		inc de 
2ba7			;;		ld (de), a 
2ba7			;;		inc hl 
2ba7			;		inc de 
2ba7			; 
2ba7			;		ex de, hl 
2ba7			;		pop de 
2ba7			;		 
2ba7			;		 
2ba7			; 
2ba7			;; detoken that string and copy it 
2ba7			; 
2ba7			;	if DEBUG_FORTH_WORDS 
2ba7			;		DMARK "Lt2" 
2ba7			;		CALLMONITOR 
2ba7			;	endif 
2ba7			;.ldetok:	ld a, (de) 
2ba7			;		cp FORTH_END_BUFFER 
2ba7			;		jr z, .ldetokend 
2ba7			;		; swap out any zero term for space 
2ba7			;		cp 0 
2ba7			;		jr nz, .ldetoknext 
2ba7			;		ld a, ' ' 
2ba7			; 
2ba7			;	if DEBUG_FORTH_WORDS 
2ba7			;		DMARK "LtS" 
2ba7			;		CALLMONITOR 
2ba7			;	endif 
2ba7			;.ldetoknext:	ld (hl), a 
2ba7			;		inc de 
2ba7			;		inc hl 
2ba7			;		jr .ldetok 
2ba7			; 
2ba7			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2ba7			;		ld (hl), a  
2ba7			; 
2ba7			;; free that temp malloc 
2ba7			; 
2ba7			;		pop hl    
2ba7			; 
2ba7			;	if DEBUG_FORTH_WORDS 
2ba7			;		DMARK "Lt4" 
2ba7			;		CALLMONITOR 
2ba7			;	endif 
2ba7			;		call forth_apushstrhl 
2ba7			; 
2ba7			;		; get rid of temp malloc area 
2ba7			; 
2ba7			;		pop hl 
2ba7			;		call free 
2ba7			; 
2ba7			;		jr .ludone 
2ba7			; 
2ba7			;.lnuword:	pop hl 
2ba7			;		call forth_tok_next 
2ba7			;		jp .ldouscan  
2ba7			; 
2ba7			;.ludone:		 pop hl 
2ba7			; 
2ba7					NEXTW 
2ba7 c3 71 20			jp macro_next 
2baa				endm 
# End of macro NEXTW
2baa			 
2baa			.FORGET: 
2baa				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2baa 5d				db WORD_SYS_CORE+73             
2bab 23 2c			dw .NOP            
2bad 07				db 6 + 1 
2bae .. 00			db "FORGET",0              
2bb5				endm 
# End of macro CWHEAD
2bb5			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2bb5			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2bb5			; | |  
2bb5			; | | e.g. "MORE" forget 
2bb5					if DEBUG_FORTH_WORDS_KEY 
2bb5						DMARK "FRG" 
2bb5 f5				push af  
2bb6 3a ca 2b			ld a, (.dmark)  
2bb9 32 6e fb			ld (debug_mark),a  
2bbc 3a cb 2b			ld a, (.dmark+1)  
2bbf 32 6f fb			ld (debug_mark+1),a  
2bc2 3a cc 2b			ld a, (.dmark+2)  
2bc5 32 70 fb			ld (debug_mark+2),a  
2bc8 18 03			jr .pastdmark  
2bca ..			.dmark: db "FRG"  
2bcd f1			.pastdmark: pop af  
2bce			endm  
# End of macro DMARK
2bce						CALLMONITOR 
2bce cd ab 16			call break_point_state  
2bd1				endm  
# End of macro CALLMONITOR
2bd1					endif 
2bd1			 
2bd1				; find uword 
2bd1			        ; update start of word with "_" 
2bd1				; replace uword with deleted flag 
2bd1			 
2bd1			 
2bd1			;	if DEBUG_FORTH_WORDS 
2bd1			;		DMARK "FOG" 
2bd1			;		CALLMONITOR 
2bd1			;	endif 
2bd1			 
2bd1			 
2bd1					; Get ptr to the word we need to look up 
2bd1			 
2bd1					FORTH_DSP_VALUEHL 
2bd1 cd ff 1e			call macro_dsp_valuehl 
2bd4				endm 
# End of macro FORTH_DSP_VALUEHL
2bd4					;v5 FORTH_DSP_VALUE 
2bd4				; TODO type check 
2bd4			;		inc hl    ; Skip type check  
2bd4 e5					push hl 
2bd5 c1					pop bc 
2bd6			;		ex de, hl    ; put into DE 
2bd6			 
2bd6			 
2bd6 21 00 80				ld hl, baseram 
2bd9					;ld hl, baseusermem 
2bd9			 
2bd9				; skip dict stub 
2bd9			;	call forth_tok_next 
2bd9 e5			push hl   ; sacreifical push 
2bda			 
2bda			.fldouscanm: 
2bda e1				pop hl 
2bdb			.fldouscan: 
2bdb			;	if DEBUG_FORTH_WORDS 
2bdb			;		DMARK "LSs" 
2bdb			;		CALLMONITOR 
2bdb			;	endif 
2bdb				; skip dict stub 
2bdb cd c2 21				call forth_tok_next 
2bde			 
2bde			 
2bde			; while we have words to look for 
2bde			 
2bde 7e				ld a, (hl)      
2bdf			;	if DEBUG_FORTH_WORDS 
2bdf			;		DMARK "LSk" 
2bdf			;		CALLMONITOR 
2bdf			;	endif 
2bdf fe 00				cp WORD_SYS_END 
2be1 ca 1d 2c				jp z, .flunotfound 
2be4 fe 01				cp WORD_SYS_UWORD 
2be6 c2 db 2b				jp nz, .fldouscan 
2be9			 
2be9			;	if DEBUG_FORTH_WORDS 
2be9			;		DMARK "LSu" 
2be9			;		CALLMONITOR 
2be9			;	endif 
2be9			 
2be9					; found a uword but is it the one we want... 
2be9			 
2be9 c5					push bc     ; uword to find is on bc 
2bea d1					pop de 
2beb			 
2beb e5					push hl  ; to save the ptr 
2bec			 
2bec					; skip opcode 
2bec 23					inc hl  
2bed					; skip next ptr 
2bed 23					inc hl  
2bee 23					inc hl 
2bef					; skip len 
2bef 23					inc hl 
2bf0			 
2bf0			;	if DEBUG_FORTH_WORDS 
2bf0			;		DMARK "LSc" 
2bf0			;		CALLMONITOR 
2bf0			;	endif 
2bf0 cd 9a 11				call strcmp 
2bf3 c2 da 2b				jp nz, .fldouscanm 
2bf6			; 
2bf6			; 
2bf6			;; while we have words to look for 
2bf6			; 
2bf6			;.fdouscan:	ld a, (hl)      
2bf6			;	if DEBUG_FORTH_WORDS 
2bf6			;		DMARK "LSs" 
2bf6			;		CALLMONITOR 
2bf6			;	endif 
2bf6			;		cp WORD_SYS_END 
2bf6			;		jp z, .fudone 
2bf6			;		cp WORD_SYS_UWORD 
2bf6			;		jp nz, .fnuword 
2bf6			; 
2bf6			;	if DEBUG_FORTH_WORDS 
2bf6			;		DMARK "FGu" 
2bf6			;		CALLMONITOR 
2bf6			;	endif 
2bf6			; 
2bf6			;		; found a uword but is it the one we want... 
2bf6			; 
2bf6			; 
2bf6			;	        pop de   ; get back the dsp name 
2bf6			;		push de 
2bf6			; 
2bf6			;		push hl  ; to save the ptr 
2bf6			; 
2bf6			;		; skip opcode 
2bf6			;		inc hl  
2bf6			;		; skip next ptr 
2bf6			;		inc hl  
2bf6			;		inc hl 
2bf6			;		; skip len 
2bf6			;		inc hl 
2bf6			; 
2bf6			;	if DEBUG_FORTH_WORDS 
2bf6			;		DMARK "FGc" 
2bf6			;		CALLMONITOR 
2bf6			;	endif 
2bf6			;		call strcmp 
2bf6			;		jp nz, .fnuword 
2bf6			 
2bf6			 
2bf6 e1			pop hl 
2bf7			 
2bf7				 
2bf7				if DEBUG_FORTH_WORDS 
2bf7					DMARK "FGm" 
2bf7 f5				push af  
2bf8 3a 0c 2c			ld a, (.dmark)  
2bfb 32 6e fb			ld (debug_mark),a  
2bfe 3a 0d 2c			ld a, (.dmark+1)  
2c01 32 6f fb			ld (debug_mark+1),a  
2c04 3a 0e 2c			ld a, (.dmark+2)  
2c07 32 70 fb			ld (debug_mark+2),a  
2c0a 18 03			jr .pastdmark  
2c0c ..			.dmark: db "FGm"  
2c0f f1			.pastdmark: pop af  
2c10			endm  
# End of macro DMARK
2c10					CALLMONITOR 
2c10 cd ab 16			call break_point_state  
2c13				endm  
# End of macro CALLMONITOR
2c13				endif 
2c13			 
2c13			 
2c13			 
2c13					; we have a uword so push its name to the stack 
2c13			 
2c13			;	   	push hl  ; save so we can move to next dict block 
2c13			;pop hl 
2c13			 
2c13					; update opcode to deleted 
2c13 3e 03				ld a, WORD_SYS_DELETED 
2c15 77					ld (hl), a 
2c16			 
2c16 23					inc hl  
2c17					; skip next ptr 
2c17 23					inc hl  
2c18 23					inc hl 
2c19					; skip len 
2c19 23					inc hl 
2c1a			 
2c1a					; TODO change parser to skip deleted words but for now mark it out 
2c1a 3e 5f				ld a, "_" 
2c1c 77					ld  (hl),a 
2c1d			 
2c1d			;		jr .fudone 
2c1d			; 
2c1d			;.fnuword:	pop hl 
2c1d			;		call forth_tok_next 
2c1d			;		jp .fdouscan  
2c1d			 
2c1d			.flunotfound:		  
2c1d			 
2c1d			 
2c1d					 
2c1d					FORTH_DSP_POP 
2c1d cd b7 1f			call macro_forth_dsp_pop 
2c20				endm 
# End of macro FORTH_DSP_POP
2c20			;		ld hl, .luno 
2c20			;.fudone:		 pop hl 
2c20					NEXTW 
2c20 c3 71 20			jp macro_next 
2c23				endm 
# End of macro NEXTW
2c23			.NOP: 
2c23				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2c23 61				db WORD_SYS_CORE+77             
2c24 4a 2c			dw .COMO            
2c26 04				db 3 + 1 
2c27 .. 00			db "NOP",0              
2c2b				endm 
# End of macro CWHEAD
2c2b			; | NOP (  --  ) Do nothing | DONE 
2c2b					if DEBUG_FORTH_WORDS_KEY 
2c2b						DMARK "NOP" 
2c2b f5				push af  
2c2c 3a 40 2c			ld a, (.dmark)  
2c2f 32 6e fb			ld (debug_mark),a  
2c32 3a 41 2c			ld a, (.dmark+1)  
2c35 32 6f fb			ld (debug_mark+1),a  
2c38 3a 42 2c			ld a, (.dmark+2)  
2c3b 32 70 fb			ld (debug_mark+2),a  
2c3e 18 03			jr .pastdmark  
2c40 ..			.dmark: db "NOP"  
2c43 f1			.pastdmark: pop af  
2c44			endm  
# End of macro DMARK
2c44						CALLMONITOR 
2c44 cd ab 16			call break_point_state  
2c47				endm  
# End of macro CALLMONITOR
2c47					endif 
2c47				       NEXTW 
2c47 c3 71 20			jp macro_next 
2c4a				endm 
# End of macro NEXTW
2c4a			.COMO: 
2c4a				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c4a 6e				db WORD_SYS_CORE+90             
2c4b 9c 2c			dw .COMC            
2c4d 02				db 1 + 1 
2c4e .. 00			db "(",0              
2c50				endm 
# End of macro CWHEAD
2c50			; | ( ( -- )  Start of comment | DONE 
2c50			 
2c50			 
2c50 2a 15 f1				ld hl, ( os_tok_ptr) 
2c53 11 97 2c			ld de, .closepar 
2c56					 
2c56					if DEBUG_FORTH_WORDS 
2c56						DMARK ").." 
2c56 f5				push af  
2c57 3a 6b 2c			ld a, (.dmark)  
2c5a 32 6e fb			ld (debug_mark),a  
2c5d 3a 6c 2c			ld a, (.dmark+1)  
2c60 32 6f fb			ld (debug_mark+1),a  
2c63 3a 6d 2c			ld a, (.dmark+2)  
2c66 32 70 fb			ld (debug_mark+2),a  
2c69 18 03			jr .pastdmark  
2c6b ..			.dmark: db ").."  
2c6e f1			.pastdmark: pop af  
2c6f			endm  
# End of macro DMARK
2c6f						CALLMONITOR 
2c6f cd ab 16			call break_point_state  
2c72				endm  
# End of macro CALLMONITOR
2c72					endif 
2c72 cd 8c 21			call findnexttok  
2c75			 
2c75					if DEBUG_FORTH_WORDS 
2c75						DMARK "IF5" 
2c75 f5				push af  
2c76 3a 8a 2c			ld a, (.dmark)  
2c79 32 6e fb			ld (debug_mark),a  
2c7c 3a 8b 2c			ld a, (.dmark+1)  
2c7f 32 6f fb			ld (debug_mark+1),a  
2c82 3a 8c 2c			ld a, (.dmark+2)  
2c85 32 70 fb			ld (debug_mark+2),a  
2c88 18 03			jr .pastdmark  
2c8a ..			.dmark: db "IF5"  
2c8d f1			.pastdmark: pop af  
2c8e			endm  
# End of macro DMARK
2c8e						CALLMONITOR 
2c8e cd ab 16			call break_point_state  
2c91				endm  
# End of macro CALLMONITOR
2c91					endif 
2c91				; replace below with ) exec using tok_ptr 
2c91 22 15 f1			ld (os_tok_ptr), hl 
2c94 c3 02 21			jp exec1 
2c97			 
2c97 .. 00			.closepar:   db ")",0 
2c99			 
2c99				       NEXTW 
2c99 c3 71 20			jp macro_next 
2c9c				endm 
# End of macro NEXTW
2c9c			.COMC: 
2c9c				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c9c 6f				db WORD_SYS_CORE+91             
2c9d a5 2c			dw .SCRATCH            
2c9f 02				db 1 + 1 
2ca0 .. 00			db ")",0              
2ca2				endm 
# End of macro CWHEAD
2ca2			; | ) ( -- )  End of comment |  DONE  
2ca2				       NEXTW 
2ca2 c3 71 20			jp macro_next 
2ca5				endm 
# End of macro NEXTW
2ca5			 
2ca5			.SCRATCH: 
2ca5				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2ca5 6f				db WORD_SYS_CORE+91             
2ca6 e0 2c			dw .INC            
2ca8 08				db 7 + 1 
2ca9 .. 00			db "SCRATCH",0              
2cb1				endm 
# End of macro CWHEAD
2cb1			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2cb1			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2cb1			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2cb1			; | |  
2cb1			; | | e.g.    : score $00 scratch ; 
2cb1			; | |  
2cb1			; | | $00 score ! 
2cb1			; | | $01 score +! 
2cb1			; | |  
2cb1			; | | e.g.   : varword $0a scratch ;  
2cb1			; | | 
2cb1			; | | $8000 varword ! 
2cb1					if DEBUG_FORTH_WORDS_KEY 
2cb1						DMARK "SCR" 
2cb1 f5				push af  
2cb2 3a c6 2c			ld a, (.dmark)  
2cb5 32 6e fb			ld (debug_mark),a  
2cb8 3a c7 2c			ld a, (.dmark+1)  
2cbb 32 6f fb			ld (debug_mark+1),a  
2cbe 3a c8 2c			ld a, (.dmark+2)  
2cc1 32 70 fb			ld (debug_mark+2),a  
2cc4 18 03			jr .pastdmark  
2cc6 ..			.dmark: db "SCR"  
2cc9 f1			.pastdmark: pop af  
2cca			endm  
# End of macro DMARK
2cca						CALLMONITOR 
2cca cd ab 16			call break_point_state  
2ccd				endm  
# End of macro CALLMONITOR
2ccd					endif 
2ccd			 
2ccd					FORTH_DSP_VALUEHL 
2ccd cd ff 1e			call macro_dsp_valuehl 
2cd0				endm 
# End of macro FORTH_DSP_VALUEHL
2cd0				 
2cd0					FORTH_DSP_POP 
2cd0 cd b7 1f			call macro_forth_dsp_pop 
2cd3				endm 
# End of macro FORTH_DSP_POP
2cd3			 
2cd3 7d					ld a, l 
2cd4 21 39 f3				ld hl, os_var_array 
2cd7 cd 04 0d				call addatohl 
2cda			 
2cda cd 08 1d				call forth_push_numhl 
2cdd			 
2cdd				       NEXTW 
2cdd c3 71 20			jp macro_next 
2ce0				endm 
# End of macro NEXTW
2ce0			 
2ce0			.INC: 
2ce0				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ce0 6f				db WORD_SYS_CORE+91             
2ce1 34 2d			dw .DEC            
2ce3 03				db 2 + 1 
2ce4 .. 00			db "+!",0              
2ce7				endm 
# End of macro CWHEAD
2ce7			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2ce7					if DEBUG_FORTH_WORDS_KEY 
2ce7						DMARK "+s_" 
2ce7 f5				push af  
2ce8 3a fc 2c			ld a, (.dmark)  
2ceb 32 6e fb			ld (debug_mark),a  
2cee 3a fd 2c			ld a, (.dmark+1)  
2cf1 32 6f fb			ld (debug_mark+1),a  
2cf4 3a fe 2c			ld a, (.dmark+2)  
2cf7 32 70 fb			ld (debug_mark+2),a  
2cfa 18 03			jr .pastdmark  
2cfc ..			.dmark: db "+s_"  
2cff f1			.pastdmark: pop af  
2d00			endm  
# End of macro DMARK
2d00						CALLMONITOR 
2d00 cd ab 16			call break_point_state  
2d03				endm  
# End of macro CALLMONITOR
2d03					endif 
2d03			 
2d03					FORTH_DSP_VALUEHL 
2d03 cd ff 1e			call macro_dsp_valuehl 
2d06				endm 
# End of macro FORTH_DSP_VALUEHL
2d06			 
2d06 e5					push hl   ; save address 
2d07			 
2d07					FORTH_DSP_POP 
2d07 cd b7 1f			call macro_forth_dsp_pop 
2d0a				endm 
# End of macro FORTH_DSP_POP
2d0a			 
2d0a					FORTH_DSP_VALUEHL 
2d0a cd ff 1e			call macro_dsp_valuehl 
2d0d				endm 
# End of macro FORTH_DSP_VALUEHL
2d0d			 
2d0d					FORTH_DSP_POP 
2d0d cd b7 1f			call macro_forth_dsp_pop 
2d10				endm 
# End of macro FORTH_DSP_POP
2d10			 
2d10					; hl contains value to add to byte at a 
2d10				 
2d10 eb					ex de, hl 
2d11			 
2d11 e1					pop hl 
2d12			 
2d12					if DEBUG_FORTH_WORDS 
2d12						DMARK "INC" 
2d12 f5				push af  
2d13 3a 27 2d			ld a, (.dmark)  
2d16 32 6e fb			ld (debug_mark),a  
2d19 3a 28 2d			ld a, (.dmark+1)  
2d1c 32 6f fb			ld (debug_mark+1),a  
2d1f 3a 29 2d			ld a, (.dmark+2)  
2d22 32 70 fb			ld (debug_mark+2),a  
2d25 18 03			jr .pastdmark  
2d27 ..			.dmark: db "INC"  
2d2a f1			.pastdmark: pop af  
2d2b			endm  
# End of macro DMARK
2d2b						CALLMONITOR 
2d2b cd ab 16			call break_point_state  
2d2e				endm  
# End of macro CALLMONITOR
2d2e					endif 
2d2e			 
2d2e 7e					ld a,(hl) 
2d2f 83					add e 
2d30 77					ld (hl),a 
2d31			 
2d31			 
2d31			 
2d31				       NEXTW 
2d31 c3 71 20			jp macro_next 
2d34				endm 
# End of macro NEXTW
2d34			 
2d34			.DEC: 
2d34				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d34 6f				db WORD_SYS_CORE+91             
2d35 85 2d			dw .INC2            
2d37 03				db 2 + 1 
2d38 .. 00			db "-!",0              
2d3b				endm 
# End of macro CWHEAD
2d3b			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d3b					if DEBUG_FORTH_WORDS_KEY 
2d3b						DMARK "-s_" 
2d3b f5				push af  
2d3c 3a 50 2d			ld a, (.dmark)  
2d3f 32 6e fb			ld (debug_mark),a  
2d42 3a 51 2d			ld a, (.dmark+1)  
2d45 32 6f fb			ld (debug_mark+1),a  
2d48 3a 52 2d			ld a, (.dmark+2)  
2d4b 32 70 fb			ld (debug_mark+2),a  
2d4e 18 03			jr .pastdmark  
2d50 ..			.dmark: db "-s_"  
2d53 f1			.pastdmark: pop af  
2d54			endm  
# End of macro DMARK
2d54						CALLMONITOR 
2d54 cd ab 16			call break_point_state  
2d57				endm  
# End of macro CALLMONITOR
2d57					endif 
2d57			 
2d57					FORTH_DSP_VALUEHL 
2d57 cd ff 1e			call macro_dsp_valuehl 
2d5a				endm 
# End of macro FORTH_DSP_VALUEHL
2d5a			 
2d5a e5					push hl   ; save address 
2d5b			 
2d5b					FORTH_DSP_POP 
2d5b cd b7 1f			call macro_forth_dsp_pop 
2d5e				endm 
# End of macro FORTH_DSP_POP
2d5e			 
2d5e					FORTH_DSP_VALUEHL 
2d5e cd ff 1e			call macro_dsp_valuehl 
2d61				endm 
# End of macro FORTH_DSP_VALUEHL
2d61			 
2d61					; hl contains value to add to byte at a 
2d61				 
2d61 eb					ex de, hl 
2d62			 
2d62 e1					pop hl 
2d63			 
2d63					if DEBUG_FORTH_WORDS 
2d63						DMARK "DEC" 
2d63 f5				push af  
2d64 3a 78 2d			ld a, (.dmark)  
2d67 32 6e fb			ld (debug_mark),a  
2d6a 3a 79 2d			ld a, (.dmark+1)  
2d6d 32 6f fb			ld (debug_mark+1),a  
2d70 3a 7a 2d			ld a, (.dmark+2)  
2d73 32 70 fb			ld (debug_mark+2),a  
2d76 18 03			jr .pastdmark  
2d78 ..			.dmark: db "DEC"  
2d7b f1			.pastdmark: pop af  
2d7c			endm  
# End of macro DMARK
2d7c						CALLMONITOR 
2d7c cd ab 16			call break_point_state  
2d7f				endm  
# End of macro CALLMONITOR
2d7f					endif 
2d7f			 
2d7f 7e					ld a,(hl) 
2d80 93					sub e 
2d81 77					ld (hl),a 
2d82			 
2d82			 
2d82			 
2d82				       NEXTW 
2d82 c3 71 20			jp macro_next 
2d85				endm 
# End of macro NEXTW
2d85			 
2d85			.INC2: 
2d85				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d85 6f				db WORD_SYS_CORE+91             
2d86 2f 2e			dw .DEC2            
2d88 04				db 3 + 1 
2d89 .. 00			db "+2!",0              
2d8d				endm 
# End of macro CWHEAD
2d8d			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d8d			 
2d8d					if DEBUG_FORTH_WORDS_KEY 
2d8d						DMARK "+2s" 
2d8d f5				push af  
2d8e 3a a2 2d			ld a, (.dmark)  
2d91 32 6e fb			ld (debug_mark),a  
2d94 3a a3 2d			ld a, (.dmark+1)  
2d97 32 6f fb			ld (debug_mark+1),a  
2d9a 3a a4 2d			ld a, (.dmark+2)  
2d9d 32 70 fb			ld (debug_mark+2),a  
2da0 18 03			jr .pastdmark  
2da2 ..			.dmark: db "+2s"  
2da5 f1			.pastdmark: pop af  
2da6			endm  
# End of macro DMARK
2da6						CALLMONITOR 
2da6 cd ab 16			call break_point_state  
2da9				endm  
# End of macro CALLMONITOR
2da9					endif 
2da9			 
2da9					; Address 
2da9			 
2da9					FORTH_DSP_VALUEHL 
2da9 cd ff 1e			call macro_dsp_valuehl 
2dac				endm 
# End of macro FORTH_DSP_VALUEHL
2dac			 
2dac e5					push hl    ; save address 
2dad			 
2dad					; load content into de 
2dad			 
2dad 5e					ld e,(hl) 
2dae 23					inc hl 
2daf 56					ld d, (hl) 
2db0			 
2db0					if DEBUG_FORTH_WORDS 
2db0						DMARK "+2a" 
2db0 f5				push af  
2db1 3a c5 2d			ld a, (.dmark)  
2db4 32 6e fb			ld (debug_mark),a  
2db7 3a c6 2d			ld a, (.dmark+1)  
2dba 32 6f fb			ld (debug_mark+1),a  
2dbd 3a c7 2d			ld a, (.dmark+2)  
2dc0 32 70 fb			ld (debug_mark+2),a  
2dc3 18 03			jr .pastdmark  
2dc5 ..			.dmark: db "+2a"  
2dc8 f1			.pastdmark: pop af  
2dc9			endm  
# End of macro DMARK
2dc9						CALLMONITOR 
2dc9 cd ab 16			call break_point_state  
2dcc				endm  
# End of macro CALLMONITOR
2dcc					endif 
2dcc			 
2dcc					FORTH_DSP_POP 
2dcc cd b7 1f			call macro_forth_dsp_pop 
2dcf				endm 
# End of macro FORTH_DSP_POP
2dcf			 
2dcf					; Get value to add 
2dcf			 
2dcf					FORTH_DSP_VALUE 
2dcf cd e8 1e			call macro_forth_dsp_value 
2dd2				endm 
# End of macro FORTH_DSP_VALUE
2dd2			 
2dd2					if DEBUG_FORTH_WORDS 
2dd2						DMARK "+2v" 
2dd2 f5				push af  
2dd3 3a e7 2d			ld a, (.dmark)  
2dd6 32 6e fb			ld (debug_mark),a  
2dd9 3a e8 2d			ld a, (.dmark+1)  
2ddc 32 6f fb			ld (debug_mark+1),a  
2ddf 3a e9 2d			ld a, (.dmark+2)  
2de2 32 70 fb			ld (debug_mark+2),a  
2de5 18 03			jr .pastdmark  
2de7 ..			.dmark: db "+2v"  
2dea f1			.pastdmark: pop af  
2deb			endm  
# End of macro DMARK
2deb						CALLMONITOR 
2deb cd ab 16			call break_point_state  
2dee				endm  
# End of macro CALLMONITOR
2dee					endif 
2dee			 
2dee 19					add hl, de 
2def			 
2def					if DEBUG_FORTH_WORDS 
2def						DMARK "+2+" 
2def f5				push af  
2df0 3a 04 2e			ld a, (.dmark)  
2df3 32 6e fb			ld (debug_mark),a  
2df6 3a 05 2e			ld a, (.dmark+1)  
2df9 32 6f fb			ld (debug_mark+1),a  
2dfc 3a 06 2e			ld a, (.dmark+2)  
2dff 32 70 fb			ld (debug_mark+2),a  
2e02 18 03			jr .pastdmark  
2e04 ..			.dmark: db "+2+"  
2e07 f1			.pastdmark: pop af  
2e08			endm  
# End of macro DMARK
2e08						CALLMONITOR 
2e08 cd ab 16			call break_point_state  
2e0b				endm  
# End of macro CALLMONITOR
2e0b					endif 
2e0b			 
2e0b					; move result to de 
2e0b			 
2e0b eb					ex de, hl 
2e0c			 
2e0c					; Address 
2e0c			 
2e0c e1					pop hl 
2e0d			 
2e0d					; save it back 
2e0d			 
2e0d 73					ld (hl), e 
2e0e 23					inc hl 
2e0f 72					ld (hl), d 
2e10			 
2e10					if DEBUG_FORTH_WORDS 
2e10						DMARK "+2e" 
2e10 f5				push af  
2e11 3a 25 2e			ld a, (.dmark)  
2e14 32 6e fb			ld (debug_mark),a  
2e17 3a 26 2e			ld a, (.dmark+1)  
2e1a 32 6f fb			ld (debug_mark+1),a  
2e1d 3a 27 2e			ld a, (.dmark+2)  
2e20 32 70 fb			ld (debug_mark+2),a  
2e23 18 03			jr .pastdmark  
2e25 ..			.dmark: db "+2e"  
2e28 f1			.pastdmark: pop af  
2e29			endm  
# End of macro DMARK
2e29						CALLMONITOR 
2e29 cd ab 16			call break_point_state  
2e2c				endm  
# End of macro CALLMONITOR
2e2c					endif 
2e2c			 
2e2c			 
2e2c			 
2e2c			 
2e2c			 
2e2c				       NEXTW 
2e2c c3 71 20			jp macro_next 
2e2f				endm 
# End of macro NEXTW
2e2f			 
2e2f			.DEC2: 
2e2f				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e2f 6f				db WORD_SYS_CORE+91             
2e30 db 2e			dw .GET2            
2e32 04				db 3 + 1 
2e33 .. 00			db "-2!",0              
2e37				endm 
# End of macro CWHEAD
2e37			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e37			 
2e37			 
2e37					if DEBUG_FORTH_WORDS_KEY 
2e37						DMARK "-2s" 
2e37 f5				push af  
2e38 3a 4c 2e			ld a, (.dmark)  
2e3b 32 6e fb			ld (debug_mark),a  
2e3e 3a 4d 2e			ld a, (.dmark+1)  
2e41 32 6f fb			ld (debug_mark+1),a  
2e44 3a 4e 2e			ld a, (.dmark+2)  
2e47 32 70 fb			ld (debug_mark+2),a  
2e4a 18 03			jr .pastdmark  
2e4c ..			.dmark: db "-2s"  
2e4f f1			.pastdmark: pop af  
2e50			endm  
# End of macro DMARK
2e50						CALLMONITOR 
2e50 cd ab 16			call break_point_state  
2e53				endm  
# End of macro CALLMONITOR
2e53					endif 
2e53			 
2e53					; Address 
2e53			 
2e53					FORTH_DSP_VALUEHL 
2e53 cd ff 1e			call macro_dsp_valuehl 
2e56				endm 
# End of macro FORTH_DSP_VALUEHL
2e56			 
2e56 e5					push hl    ; save address 
2e57			 
2e57					; load content into de 
2e57			 
2e57 5e					ld e,(hl) 
2e58 23					inc hl 
2e59 56					ld d, (hl) 
2e5a			 
2e5a					if DEBUG_FORTH_WORDS 
2e5a						DMARK "-2a" 
2e5a f5				push af  
2e5b 3a 6f 2e			ld a, (.dmark)  
2e5e 32 6e fb			ld (debug_mark),a  
2e61 3a 70 2e			ld a, (.dmark+1)  
2e64 32 6f fb			ld (debug_mark+1),a  
2e67 3a 71 2e			ld a, (.dmark+2)  
2e6a 32 70 fb			ld (debug_mark+2),a  
2e6d 18 03			jr .pastdmark  
2e6f ..			.dmark: db "-2a"  
2e72 f1			.pastdmark: pop af  
2e73			endm  
# End of macro DMARK
2e73						CALLMONITOR 
2e73 cd ab 16			call break_point_state  
2e76				endm  
# End of macro CALLMONITOR
2e76					endif 
2e76			 
2e76					FORTH_DSP_POP 
2e76 cd b7 1f			call macro_forth_dsp_pop 
2e79				endm 
# End of macro FORTH_DSP_POP
2e79			 
2e79					; Get value to remove 
2e79			 
2e79					FORTH_DSP_VALUE 
2e79 cd e8 1e			call macro_forth_dsp_value 
2e7c				endm 
# End of macro FORTH_DSP_VALUE
2e7c			 
2e7c					if DEBUG_FORTH_WORDS 
2e7c						DMARK "-2v" 
2e7c f5				push af  
2e7d 3a 91 2e			ld a, (.dmark)  
2e80 32 6e fb			ld (debug_mark),a  
2e83 3a 92 2e			ld a, (.dmark+1)  
2e86 32 6f fb			ld (debug_mark+1),a  
2e89 3a 93 2e			ld a, (.dmark+2)  
2e8c 32 70 fb			ld (debug_mark+2),a  
2e8f 18 03			jr .pastdmark  
2e91 ..			.dmark: db "-2v"  
2e94 f1			.pastdmark: pop af  
2e95			endm  
# End of macro DMARK
2e95						CALLMONITOR 
2e95 cd ab 16			call break_point_state  
2e98				endm  
# End of macro CALLMONITOR
2e98					endif 
2e98			 
2e98 eb					ex de, hl 
2e99 ed 52				sbc hl, de 
2e9b			 
2e9b					if DEBUG_FORTH_WORDS 
2e9b						DMARK "-2d" 
2e9b f5				push af  
2e9c 3a b0 2e			ld a, (.dmark)  
2e9f 32 6e fb			ld (debug_mark),a  
2ea2 3a b1 2e			ld a, (.dmark+1)  
2ea5 32 6f fb			ld (debug_mark+1),a  
2ea8 3a b2 2e			ld a, (.dmark+2)  
2eab 32 70 fb			ld (debug_mark+2),a  
2eae 18 03			jr .pastdmark  
2eb0 ..			.dmark: db "-2d"  
2eb3 f1			.pastdmark: pop af  
2eb4			endm  
# End of macro DMARK
2eb4						CALLMONITOR 
2eb4 cd ab 16			call break_point_state  
2eb7				endm  
# End of macro CALLMONITOR
2eb7					endif 
2eb7			 
2eb7					; move result to de 
2eb7			 
2eb7 eb					ex de, hl 
2eb8			 
2eb8					; Address 
2eb8			 
2eb8 e1					pop hl 
2eb9			 
2eb9					; save it back 
2eb9			 
2eb9 73					ld (hl), e 
2eba 23					inc hl 
2ebb 72					ld (hl), d 
2ebc			 
2ebc					if DEBUG_FORTH_WORDS 
2ebc						DMARK "-2e" 
2ebc f5				push af  
2ebd 3a d1 2e			ld a, (.dmark)  
2ec0 32 6e fb			ld (debug_mark),a  
2ec3 3a d2 2e			ld a, (.dmark+1)  
2ec6 32 6f fb			ld (debug_mark+1),a  
2ec9 3a d3 2e			ld a, (.dmark+2)  
2ecc 32 70 fb			ld (debug_mark+2),a  
2ecf 18 03			jr .pastdmark  
2ed1 ..			.dmark: db "-2e"  
2ed4 f1			.pastdmark: pop af  
2ed5			endm  
# End of macro DMARK
2ed5						CALLMONITOR 
2ed5 cd ab 16			call break_point_state  
2ed8				endm  
# End of macro CALLMONITOR
2ed8					endif 
2ed8			 
2ed8			 
2ed8			 
2ed8			 
2ed8			 
2ed8				       NEXTW 
2ed8 c3 71 20			jp macro_next 
2edb				endm 
# End of macro NEXTW
2edb			.GET2: 
2edb				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2edb 6f				db WORD_SYS_CORE+91             
2edc 0b 2f			dw .BANG2            
2ede 03				db 2 + 1 
2edf .. 00			db "2@",0              
2ee2				endm 
# End of macro CWHEAD
2ee2			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2ee2					if DEBUG_FORTH_WORDS_KEY 
2ee2						DMARK "2A_" 
2ee2 f5				push af  
2ee3 3a f7 2e			ld a, (.dmark)  
2ee6 32 6e fb			ld (debug_mark),a  
2ee9 3a f8 2e			ld a, (.dmark+1)  
2eec 32 6f fb			ld (debug_mark+1),a  
2eef 3a f9 2e			ld a, (.dmark+2)  
2ef2 32 70 fb			ld (debug_mark+2),a  
2ef5 18 03			jr .pastdmark  
2ef7 ..			.dmark: db "2A_"  
2efa f1			.pastdmark: pop af  
2efb			endm  
# End of macro DMARK
2efb						CALLMONITOR 
2efb cd ab 16			call break_point_state  
2efe				endm  
# End of macro CALLMONITOR
2efe					endif 
2efe			 
2efe					FORTH_DSP_VALUEHL 
2efe cd ff 1e			call macro_dsp_valuehl 
2f01				endm 
# End of macro FORTH_DSP_VALUEHL
2f01			 
2f01 5e					ld e, (hl) 
2f02 23					inc hl 
2f03 56					ld d, (hl) 
2f04			 
2f04 eb					ex de, hl 
2f05			 
2f05 cd 08 1d				call forth_push_numhl 
2f08			 
2f08				       NEXTW 
2f08 c3 71 20			jp macro_next 
2f0b				endm 
# End of macro NEXTW
2f0b			.BANG2: 
2f0b				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2f0b 6f				db WORD_SYS_CORE+91             
2f0c 43 2f			dw .CONFIG            
2f0e 03				db 2 + 1 
2f0f .. 00			db "2!",0              
2f12				endm 
# End of macro CWHEAD
2f12			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2f12					if DEBUG_FORTH_WORDS_KEY 
2f12						DMARK "2S_" 
2f12 f5				push af  
2f13 3a 27 2f			ld a, (.dmark)  
2f16 32 6e fb			ld (debug_mark),a  
2f19 3a 28 2f			ld a, (.dmark+1)  
2f1c 32 6f fb			ld (debug_mark+1),a  
2f1f 3a 29 2f			ld a, (.dmark+2)  
2f22 32 70 fb			ld (debug_mark+2),a  
2f25 18 03			jr .pastdmark  
2f27 ..			.dmark: db "2S_"  
2f2a f1			.pastdmark: pop af  
2f2b			endm  
# End of macro DMARK
2f2b						CALLMONITOR 
2f2b cd ab 16			call break_point_state  
2f2e				endm  
# End of macro CALLMONITOR
2f2e					endif 
2f2e			 
2f2e					FORTH_DSP_VALUEHL 
2f2e cd ff 1e			call macro_dsp_valuehl 
2f31				endm 
# End of macro FORTH_DSP_VALUEHL
2f31			 
2f31 e5					push hl   ; save address 
2f32			 
2f32			 
2f32					FORTH_DSP_POP 
2f32 cd b7 1f			call macro_forth_dsp_pop 
2f35				endm 
# End of macro FORTH_DSP_POP
2f35			 
2f35					 
2f35					FORTH_DSP_VALUEHL 
2f35 cd ff 1e			call macro_dsp_valuehl 
2f38				endm 
# End of macro FORTH_DSP_VALUEHL
2f38			 
2f38					FORTH_DSP_POP 
2f38 cd b7 1f			call macro_forth_dsp_pop 
2f3b				endm 
# End of macro FORTH_DSP_POP
2f3b			 
2f3b eb					ex de, hl    ; value now in de 
2f3c			 
2f3c e1					pop hl 
2f3d			 
2f3d 73					ld (hl), e 
2f3e			 
2f3e 23					inc hl 
2f3f			 
2f3f 72					ld (hl), d 
2f40			 
2f40			 
2f40				       NEXTW 
2f40 c3 71 20			jp macro_next 
2f43				endm 
# End of macro NEXTW
2f43			.CONFIG: 
2f43				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f43 6f				db WORD_SYS_CORE+91             
2f44 54 2f			dw .ENDCORE            
2f46 07				db 6 + 1 
2f47 .. 00			db "CONFIG",0              
2f4e				endm 
# End of macro CWHEAD
2f4e			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2f4e			 
2f4e cd 8e 13				call config 
2f51					NEXTW 
2f51 c3 71 20			jp macro_next 
2f54				endm 
# End of macro NEXTW
2f54			.ENDCORE: 
2f54			 
2f54			; eof 
2f54			 
2f54			 
# End of file forth_words_core.asm
2f54			include "forth_words_flow.asm" 
2f54			 
2f54			; | ## Program Flow Words 
2f54			 
2f54			.IF: 
2f54				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f54 1e				db WORD_SYS_CORE+10             
2f55 49 30			dw .THEN            
2f57 03				db 2 + 1 
2f58 .. 00			db "IF",0              
2f5b				endm 
# End of macro CWHEAD
2f5b			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f5b			; 
2f5b					if DEBUG_FORTH_WORDS_KEY 
2f5b						DMARK "IF." 
2f5b f5				push af  
2f5c 3a 70 2f			ld a, (.dmark)  
2f5f 32 6e fb			ld (debug_mark),a  
2f62 3a 71 2f			ld a, (.dmark+1)  
2f65 32 6f fb			ld (debug_mark+1),a  
2f68 3a 72 2f			ld a, (.dmark+2)  
2f6b 32 70 fb			ld (debug_mark+2),a  
2f6e 18 03			jr .pastdmark  
2f70 ..			.dmark: db "IF."  
2f73 f1			.pastdmark: pop af  
2f74			endm  
# End of macro DMARK
2f74						CALLMONITOR 
2f74 cd ab 16			call break_point_state  
2f77				endm  
# End of macro CALLMONITOR
2f77					endif 
2f77			; eval TOS 
2f77			 
2f77				FORTH_DSP_VALUEHL 
2f77 cd ff 1e			call macro_dsp_valuehl 
2f7a				endm 
# End of macro FORTH_DSP_VALUEHL
2f7a			 
2f7a			;	push hl 
2f7a				FORTH_DSP_POP 
2f7a cd b7 1f			call macro_forth_dsp_pop 
2f7d				endm 
# End of macro FORTH_DSP_POP
2f7d			;	pop hl 
2f7d			 
2f7d					if DEBUG_FORTH_WORDS 
2f7d						DMARK "IF1" 
2f7d f5				push af  
2f7e 3a 92 2f			ld a, (.dmark)  
2f81 32 6e fb			ld (debug_mark),a  
2f84 3a 93 2f			ld a, (.dmark+1)  
2f87 32 6f fb			ld (debug_mark+1),a  
2f8a 3a 94 2f			ld a, (.dmark+2)  
2f8d 32 70 fb			ld (debug_mark+2),a  
2f90 18 03			jr .pastdmark  
2f92 ..			.dmark: db "IF1"  
2f95 f1			.pastdmark: pop af  
2f96			endm  
# End of macro DMARK
2f96						CALLMONITOR 
2f96 cd ab 16			call break_point_state  
2f99				endm  
# End of macro CALLMONITOR
2f99					endif 
2f99 b7				or a        ; clear carry flag 
2f9a 11 00 00			ld de, 0 
2f9d eb				ex de,hl 
2f9e ed 52			sbc hl, de 
2fa0 c2 2a 30			jp nz, .iftrue 
2fa3			 
2fa3					if DEBUG_FORTH_WORDS 
2fa3						DMARK "IF2" 
2fa3 f5				push af  
2fa4 3a b8 2f			ld a, (.dmark)  
2fa7 32 6e fb			ld (debug_mark),a  
2faa 3a b9 2f			ld a, (.dmark+1)  
2fad 32 6f fb			ld (debug_mark+1),a  
2fb0 3a ba 2f			ld a, (.dmark+2)  
2fb3 32 70 fb			ld (debug_mark+2),a  
2fb6 18 03			jr .pastdmark  
2fb8 ..			.dmark: db "IF2"  
2fbb f1			.pastdmark: pop af  
2fbc			endm  
# End of macro DMARK
2fbc						CALLMONITOR 
2fbc cd ab 16			call break_point_state  
2fbf				endm  
# End of macro CALLMONITOR
2fbf					endif 
2fbf			 
2fbf			; if not true then skip to THEN 
2fbf			 
2fbf				; TODO get tok_ptr 
2fbf				; TODO consume toks until we get to THEN 
2fbf			 
2fbf 2a 15 f1			ld hl, (os_tok_ptr) 
2fc2					if DEBUG_FORTH_WORDS 
2fc2						DMARK "IF3" 
2fc2 f5				push af  
2fc3 3a d7 2f			ld a, (.dmark)  
2fc6 32 6e fb			ld (debug_mark),a  
2fc9 3a d8 2f			ld a, (.dmark+1)  
2fcc 32 6f fb			ld (debug_mark+1),a  
2fcf 3a d9 2f			ld a, (.dmark+2)  
2fd2 32 70 fb			ld (debug_mark+2),a  
2fd5 18 03			jr .pastdmark  
2fd7 ..			.dmark: db "IF3"  
2fda f1			.pastdmark: pop af  
2fdb			endm  
# End of macro DMARK
2fdb						CALLMONITOR 
2fdb cd ab 16			call break_point_state  
2fde				endm  
# End of macro CALLMONITOR
2fde						 
2fde					endif 
2fde 11 25 30			ld de, .ifthen 
2fe1					if DEBUG_FORTH_WORDS 
2fe1						DMARK "IF4" 
2fe1 f5				push af  
2fe2 3a f6 2f			ld a, (.dmark)  
2fe5 32 6e fb			ld (debug_mark),a  
2fe8 3a f7 2f			ld a, (.dmark+1)  
2feb 32 6f fb			ld (debug_mark+1),a  
2fee 3a f8 2f			ld a, (.dmark+2)  
2ff1 32 70 fb			ld (debug_mark+2),a  
2ff4 18 03			jr .pastdmark  
2ff6 ..			.dmark: db "IF4"  
2ff9 f1			.pastdmark: pop af  
2ffa			endm  
# End of macro DMARK
2ffa						CALLMONITOR 
2ffa cd ab 16			call break_point_state  
2ffd				endm  
# End of macro CALLMONITOR
2ffd					endif 
2ffd cd 8c 21			call findnexttok  
3000			 
3000					if DEBUG_FORTH_WORDS 
3000						DMARK "IF5" 
3000 f5				push af  
3001 3a 15 30			ld a, (.dmark)  
3004 32 6e fb			ld (debug_mark),a  
3007 3a 16 30			ld a, (.dmark+1)  
300a 32 6f fb			ld (debug_mark+1),a  
300d 3a 17 30			ld a, (.dmark+2)  
3010 32 70 fb			ld (debug_mark+2),a  
3013 18 03			jr .pastdmark  
3015 ..			.dmark: db "IF5"  
3018 f1			.pastdmark: pop af  
3019			endm  
# End of macro DMARK
3019						CALLMONITOR 
3019 cd ab 16			call break_point_state  
301c				endm  
# End of macro CALLMONITOR
301c					endif 
301c				; TODO replace below with ; exec using tok_ptr 
301c 22 15 f1			ld (os_tok_ptr), hl 
301f c3 02 21			jp exec1 
3022				NEXTW 
3022 c3 71 20			jp macro_next 
3025				endm 
# End of macro NEXTW
3025			 
3025 .. 00		.ifthen:  db "THEN",0 
302a			 
302a			.iftrue:		 
302a				; Exec next words normally 
302a			 
302a				; if true then exec following IF as normal 
302a					if DEBUG_FORTH_WORDS 
302a						DMARK "IFT" 
302a f5				push af  
302b 3a 3f 30			ld a, (.dmark)  
302e 32 6e fb			ld (debug_mark),a  
3031 3a 40 30			ld a, (.dmark+1)  
3034 32 6f fb			ld (debug_mark+1),a  
3037 3a 41 30			ld a, (.dmark+2)  
303a 32 70 fb			ld (debug_mark+2),a  
303d 18 03			jr .pastdmark  
303f ..			.dmark: db "IFT"  
3042 f1			.pastdmark: pop af  
3043			endm  
# End of macro DMARK
3043						CALLMONITOR 
3043 cd ab 16			call break_point_state  
3046				endm  
# End of macro CALLMONITOR
3046					endif 
3046			 
3046					NEXTW 
3046 c3 71 20			jp macro_next 
3049				endm 
# End of macro NEXTW
3049			.THEN: 
3049				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3049 1f				db WORD_SYS_CORE+11             
304a 71 30			dw .ELSE            
304c 05				db 4 + 1 
304d .. 00			db "THEN",0              
3052				endm 
# End of macro CWHEAD
3052			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3052					if DEBUG_FORTH_WORDS_KEY 
3052						DMARK "THN" 
3052 f5				push af  
3053 3a 67 30			ld a, (.dmark)  
3056 32 6e fb			ld (debug_mark),a  
3059 3a 68 30			ld a, (.dmark+1)  
305c 32 6f fb			ld (debug_mark+1),a  
305f 3a 69 30			ld a, (.dmark+2)  
3062 32 70 fb			ld (debug_mark+2),a  
3065 18 03			jr .pastdmark  
3067 ..			.dmark: db "THN"  
306a f1			.pastdmark: pop af  
306b			endm  
# End of macro DMARK
306b						CALLMONITOR 
306b cd ab 16			call break_point_state  
306e				endm  
# End of macro CALLMONITOR
306e					endif 
306e					NEXTW 
306e c3 71 20			jp macro_next 
3071				endm 
# End of macro NEXTW
3071			.ELSE: 
3071				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3071 20				db WORD_SYS_CORE+12             
3072 99 30			dw .DO            
3074 03				db 2 + 1 
3075 .. 00			db "ELSE",0              
307a				endm 
# End of macro CWHEAD
307a			; | ELSE ( -- ) Not supported - does nothing | TODO 
307a			 
307a					if DEBUG_FORTH_WORDS_KEY 
307a						DMARK "ELS" 
307a f5				push af  
307b 3a 8f 30			ld a, (.dmark)  
307e 32 6e fb			ld (debug_mark),a  
3081 3a 90 30			ld a, (.dmark+1)  
3084 32 6f fb			ld (debug_mark+1),a  
3087 3a 91 30			ld a, (.dmark+2)  
308a 32 70 fb			ld (debug_mark+2),a  
308d 18 03			jr .pastdmark  
308f ..			.dmark: db "ELS"  
3092 f1			.pastdmark: pop af  
3093			endm  
# End of macro DMARK
3093						CALLMONITOR 
3093 cd ab 16			call break_point_state  
3096				endm  
# End of macro CALLMONITOR
3096					endif 
3096			 
3096			 
3096					NEXTW 
3096 c3 71 20			jp macro_next 
3099				endm 
# End of macro NEXTW
3099			.DO: 
3099				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3099 21				db WORD_SYS_CORE+13             
309a c0 31			dw .LOOP            
309c 03				db 2 + 1 
309d .. 00			db "DO",0              
30a0				endm 
# End of macro CWHEAD
30a0			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
30a0			 
30a0					if DEBUG_FORTH_WORDS_KEY 
30a0						DMARK "DO." 
30a0 f5				push af  
30a1 3a b5 30			ld a, (.dmark)  
30a4 32 6e fb			ld (debug_mark),a  
30a7 3a b6 30			ld a, (.dmark+1)  
30aa 32 6f fb			ld (debug_mark+1),a  
30ad 3a b7 30			ld a, (.dmark+2)  
30b0 32 70 fb			ld (debug_mark+2),a  
30b3 18 03			jr .pastdmark  
30b5 ..			.dmark: db "DO."  
30b8 f1			.pastdmark: pop af  
30b9			endm  
# End of macro DMARK
30b9						CALLMONITOR 
30b9 cd ab 16			call break_point_state  
30bc				endm  
# End of macro CALLMONITOR
30bc					endif 
30bc			;  push pc to rsp stack past the DO 
30bc			 
30bc 2a 15 f1				ld hl, (os_tok_ptr) 
30bf 23					inc hl   ; D 
30c0 23					inc hl  ; O 
30c1 23					inc hl   ; null 
30c2					if DEBUG_FORTH_WORDS 
30c2						DMARK "DO2" 
30c2 f5				push af  
30c3 3a d7 30			ld a, (.dmark)  
30c6 32 6e fb			ld (debug_mark),a  
30c9 3a d8 30			ld a, (.dmark+1)  
30cc 32 6f fb			ld (debug_mark+1),a  
30cf 3a d9 30			ld a, (.dmark+2)  
30d2 32 70 fb			ld (debug_mark+2),a  
30d5 18 03			jr .pastdmark  
30d7 ..			.dmark: db "DO2"  
30da f1			.pastdmark: pop af  
30db			endm  
# End of macro DMARK
30db						CALLMONITOR 
30db cd ab 16			call break_point_state  
30de				endm  
# End of macro CALLMONITOR
30de					endif 
30de					FORTH_RSP_NEXT 
30de cd af 1c			call macro_forth_rsp_next 
30e1				endm 
# End of macro FORTH_RSP_NEXT
30e1					if DEBUG_FORTH_WORDS 
30e1						DMARK "DO3" 
30e1 f5				push af  
30e2 3a f6 30			ld a, (.dmark)  
30e5 32 6e fb			ld (debug_mark),a  
30e8 3a f7 30			ld a, (.dmark+1)  
30eb 32 6f fb			ld (debug_mark+1),a  
30ee 3a f8 30			ld a, (.dmark+2)  
30f1 32 70 fb			ld (debug_mark+2),a  
30f4 18 03			jr .pastdmark  
30f6 ..			.dmark: db "DO3"  
30f9 f1			.pastdmark: pop af  
30fa			endm  
# End of macro DMARK
30fa						CALLMONITOR 
30fa cd ab 16			call break_point_state  
30fd				endm  
# End of macro CALLMONITOR
30fd					endif 
30fd			 
30fd					;if DEBUG_FORTH_WORDS 
30fd				;		push hl 
30fd			;		endif  
30fd			 
30fd			; get counters from data stack 
30fd			 
30fd			 
30fd					FORTH_DSP_VALUEHL 
30fd cd ff 1e			call macro_dsp_valuehl 
3100				endm 
# End of macro FORTH_DSP_VALUEHL
3100 e5					push hl		 ; hl now has starting counter which needs to be tos 
3101			 
3101					if DEBUG_FORTH_WORDS 
3101						DMARK "DO4" 
3101 f5				push af  
3102 3a 16 31			ld a, (.dmark)  
3105 32 6e fb			ld (debug_mark),a  
3108 3a 17 31			ld a, (.dmark+1)  
310b 32 6f fb			ld (debug_mark+1),a  
310e 3a 18 31			ld a, (.dmark+2)  
3111 32 70 fb			ld (debug_mark+2),a  
3114 18 03			jr .pastdmark  
3116 ..			.dmark: db "DO4"  
3119 f1			.pastdmark: pop af  
311a			endm  
# End of macro DMARK
311a						CALLMONITOR 
311a cd ab 16			call break_point_state  
311d				endm  
# End of macro CALLMONITOR
311d					endif 
311d					FORTH_DSP_POP 
311d cd b7 1f			call macro_forth_dsp_pop 
3120				endm 
# End of macro FORTH_DSP_POP
3120			 
3120					if DEBUG_FORTH_WORDS 
3120						DMARK "DO5" 
3120 f5				push af  
3121 3a 35 31			ld a, (.dmark)  
3124 32 6e fb			ld (debug_mark),a  
3127 3a 36 31			ld a, (.dmark+1)  
312a 32 6f fb			ld (debug_mark+1),a  
312d 3a 37 31			ld a, (.dmark+2)  
3130 32 70 fb			ld (debug_mark+2),a  
3133 18 03			jr .pastdmark  
3135 ..			.dmark: db "DO5"  
3138 f1			.pastdmark: pop af  
3139			endm  
# End of macro DMARK
3139						CALLMONITOR 
3139 cd ab 16			call break_point_state  
313c				endm  
# End of macro CALLMONITOR
313c					endif 
313c			 
313c					FORTH_DSP_VALUEHL 
313c cd ff 1e			call macro_dsp_valuehl 
313f				endm 
# End of macro FORTH_DSP_VALUEHL
313f			;		push hl		 ; hl now has starting limit counter 
313f			 
313f					if DEBUG_FORTH_WORDS 
313f						DMARK "DO6" 
313f f5				push af  
3140 3a 54 31			ld a, (.dmark)  
3143 32 6e fb			ld (debug_mark),a  
3146 3a 55 31			ld a, (.dmark+1)  
3149 32 6f fb			ld (debug_mark+1),a  
314c 3a 56 31			ld a, (.dmark+2)  
314f 32 70 fb			ld (debug_mark+2),a  
3152 18 03			jr .pastdmark  
3154 ..			.dmark: db "DO6"  
3157 f1			.pastdmark: pop af  
3158			endm  
# End of macro DMARK
3158						CALLMONITOR 
3158 cd ab 16			call break_point_state  
315b				endm  
# End of macro CALLMONITOR
315b					endif 
315b					FORTH_DSP_POP 
315b cd b7 1f			call macro_forth_dsp_pop 
315e				endm 
# End of macro FORTH_DSP_POP
315e			 
315e			; put counters on the loop stack 
315e			 
315e			;		pop hl			 ; limit counter 
315e d1					pop de			; start counter 
315f			 
315f					; push limit counter 
315f			 
315f					if DEBUG_FORTH_WORDS 
315f						DMARK "DO7" 
315f f5				push af  
3160 3a 74 31			ld a, (.dmark)  
3163 32 6e fb			ld (debug_mark),a  
3166 3a 75 31			ld a, (.dmark+1)  
3169 32 6f fb			ld (debug_mark+1),a  
316c 3a 76 31			ld a, (.dmark+2)  
316f 32 70 fb			ld (debug_mark+2),a  
3172 18 03			jr .pastdmark  
3174 ..			.dmark: db "DO7"  
3177 f1			.pastdmark: pop af  
3178			endm  
# End of macro DMARK
3178						CALLMONITOR 
3178 cd ab 16			call break_point_state  
317b				endm  
# End of macro CALLMONITOR
317b					endif 
317b					FORTH_LOOP_NEXT 
317b cd 30 1f			call macro_forth_loop_next 
317e				endm 
# End of macro FORTH_LOOP_NEXT
317e			 
317e					; push start counter 
317e			 
317e eb					ex de, hl 
317f					if DEBUG_FORTH_WORDS 
317f						DMARK "DO7" 
317f f5				push af  
3180 3a 94 31			ld a, (.dmark)  
3183 32 6e fb			ld (debug_mark),a  
3186 3a 95 31			ld a, (.dmark+1)  
3189 32 6f fb			ld (debug_mark+1),a  
318c 3a 96 31			ld a, (.dmark+2)  
318f 32 70 fb			ld (debug_mark+2),a  
3192 18 03			jr .pastdmark  
3194 ..			.dmark: db "DO7"  
3197 f1			.pastdmark: pop af  
3198			endm  
# End of macro DMARK
3198						CALLMONITOR 
3198 cd ab 16			call break_point_state  
319b				endm  
# End of macro CALLMONITOR
319b					endif 
319b					FORTH_LOOP_NEXT 
319b cd 30 1f			call macro_forth_loop_next 
319e				endm 
# End of macro FORTH_LOOP_NEXT
319e			 
319e			 
319e					; init first round of I counter 
319e			 
319e 22 39 f1				ld (os_current_i), hl 
31a1			 
31a1					if DEBUG_FORTH_WORDS 
31a1						DMARK "DO8" 
31a1 f5				push af  
31a2 3a b6 31			ld a, (.dmark)  
31a5 32 6e fb			ld (debug_mark),a  
31a8 3a b7 31			ld a, (.dmark+1)  
31ab 32 6f fb			ld (debug_mark+1),a  
31ae 3a b8 31			ld a, (.dmark+2)  
31b1 32 70 fb			ld (debug_mark+2),a  
31b4 18 03			jr .pastdmark  
31b6 ..			.dmark: db "DO8"  
31b9 f1			.pastdmark: pop af  
31ba			endm  
# End of macro DMARK
31ba						CALLMONITOR 
31ba cd ab 16			call break_point_state  
31bd				endm  
# End of macro CALLMONITOR
31bd					endif 
31bd			 
31bd					NEXTW 
31bd c3 71 20			jp macro_next 
31c0				endm 
# End of macro NEXTW
31c0			.LOOP: 
31c0				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31c0 22				db WORD_SYS_CORE+14             
31c1 d8 32			dw .I            
31c3 05				db 4 + 1 
31c4 .. 00			db "LOOP",0              
31c9				endm 
# End of macro CWHEAD
31c9			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31c9			 
31c9				; pop tos as current loop count to hl 
31c9			 
31c9				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31c9			 
31c9				FORTH_LOOP_TOS 
31c9 cd 63 1f			call macro_forth_loop_tos 
31cc				endm 
# End of macro FORTH_LOOP_TOS
31cc e5				push hl 
31cd			 
31cd					if DEBUG_FORTH_WORDS_KEY 
31cd						DMARK "LOP" 
31cd f5				push af  
31ce 3a e2 31			ld a, (.dmark)  
31d1 32 6e fb			ld (debug_mark),a  
31d4 3a e3 31			ld a, (.dmark+1)  
31d7 32 6f fb			ld (debug_mark+1),a  
31da 3a e4 31			ld a, (.dmark+2)  
31dd 32 70 fb			ld (debug_mark+2),a  
31e0 18 03			jr .pastdmark  
31e2 ..			.dmark: db "LOP"  
31e5 f1			.pastdmark: pop af  
31e6			endm  
# End of macro DMARK
31e6						CALLMONITOR 
31e6 cd ab 16			call break_point_state  
31e9				endm  
# End of macro CALLMONITOR
31e9					endif 
31e9				; next item on the stack is the limit. get it 
31e9			 
31e9			 
31e9				FORTH_LOOP_POP 
31e9 cd 6d 1f			call macro_forth_loop_pop 
31ec				endm 
# End of macro FORTH_LOOP_POP
31ec			 
31ec				FORTH_LOOP_TOS 
31ec cd 63 1f			call macro_forth_loop_tos 
31ef				endm 
# End of macro FORTH_LOOP_TOS
31ef			 
31ef d1				pop de		 ; de = i, hl = limit 
31f0			 
31f0					if DEBUG_FORTH_WORDS 
31f0						DMARK "LP1" 
31f0 f5				push af  
31f1 3a 05 32			ld a, (.dmark)  
31f4 32 6e fb			ld (debug_mark),a  
31f7 3a 06 32			ld a, (.dmark+1)  
31fa 32 6f fb			ld (debug_mark+1),a  
31fd 3a 07 32			ld a, (.dmark+2)  
3200 32 70 fb			ld (debug_mark+2),a  
3203 18 03			jr .pastdmark  
3205 ..			.dmark: db "LP1"  
3208 f1			.pastdmark: pop af  
3209			endm  
# End of macro DMARK
3209						CALLMONITOR 
3209 cd ab 16			call break_point_state  
320c				endm  
# End of macro CALLMONITOR
320c					endif 
320c			 
320c				; go back to previous word 
320c			 
320c d5				push de    ; save I for inc later 
320d			 
320d			 
320d				; get limit 
320d				;  is I at limit? 
320d			 
320d			 
320d					if DEBUG_FORTH_WORDS 
320d						DMARK "LP1" 
320d f5				push af  
320e 3a 22 32			ld a, (.dmark)  
3211 32 6e fb			ld (debug_mark),a  
3214 3a 23 32			ld a, (.dmark+1)  
3217 32 6f fb			ld (debug_mark+1),a  
321a 3a 24 32			ld a, (.dmark+2)  
321d 32 70 fb			ld (debug_mark+2),a  
3220 18 03			jr .pastdmark  
3222 ..			.dmark: db "LP1"  
3225 f1			.pastdmark: pop af  
3226			endm  
# End of macro DMARK
3226						CALLMONITOR 
3226 cd ab 16			call break_point_state  
3229				endm  
# End of macro CALLMONITOR
3229					endif 
3229			 
3229 ed 52			sbc hl, de 
322b			 
322b			 
322b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
322b			 
322b 20 26				jr nz, .loopnotdone 
322d			 
322d e1				pop hl   ; get rid of saved I 
322e				FORTH_LOOP_POP     ; get rid of limit 
322e cd 6d 1f			call macro_forth_loop_pop 
3231				endm 
# End of macro FORTH_LOOP_POP
3231			 
3231				FORTH_RSP_POP     ; get rid of DO ptr 
3231 cd d0 1c			call macro_forth_rsp_pop 
3234				endm 
# End of macro FORTH_RSP_POP
3234			 
3234			if DEBUG_FORTH_WORDS 
3234						DMARK "LP>" 
3234 f5				push af  
3235 3a 49 32			ld a, (.dmark)  
3238 32 6e fb			ld (debug_mark),a  
323b 3a 4a 32			ld a, (.dmark+1)  
323e 32 6f fb			ld (debug_mark+1),a  
3241 3a 4b 32			ld a, (.dmark+2)  
3244 32 70 fb			ld (debug_mark+2),a  
3247 18 03			jr .pastdmark  
3249 ..			.dmark: db "LP>"  
324c f1			.pastdmark: pop af  
324d			endm  
# End of macro DMARK
324d				CALLMONITOR 
324d cd ab 16			call break_point_state  
3250				endm  
# End of macro CALLMONITOR
3250			endif 
3250			 
3250					NEXTW 
3250 c3 71 20			jp macro_next 
3253				endm 
# End of macro NEXTW
3253				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3253			 
3253			.loopnotdone: 
3253			 
3253 e1				pop hl    ; get I 
3254 23				inc hl 
3255			 
3255			   	; save new I 
3255			 
3255			 
3255					; set I counter 
3255			 
3255 22 39 f1				ld (os_current_i), hl 
3258			 
3258					if DEBUG_FORTH_WORDS 
3258						DMARK "LPN" 
3258 f5				push af  
3259 3a 6d 32			ld a, (.dmark)  
325c 32 6e fb			ld (debug_mark),a  
325f 3a 6e 32			ld a, (.dmark+1)  
3262 32 6f fb			ld (debug_mark+1),a  
3265 3a 6f 32			ld a, (.dmark+2)  
3268 32 70 fb			ld (debug_mark+2),a  
326b 18 03			jr .pastdmark  
326d ..			.dmark: db "LPN"  
3270 f1			.pastdmark: pop af  
3271			endm  
# End of macro DMARK
3271					CALLMONITOR 
3271 cd ab 16			call break_point_state  
3274				endm  
# End of macro CALLMONITOR
3274					endif 
3274					 
3274				FORTH_LOOP_NEXT 
3274 cd 30 1f			call macro_forth_loop_next 
3277				endm 
# End of macro FORTH_LOOP_NEXT
3277			 
3277			 
3277					if DEBUG_FORTH_WORDS 
3277 eb						ex de,hl 
3278					endif 
3278			 
3278			;	; get DO ptr 
3278			; 
3278					if DEBUG_FORTH_WORDS 
3278						DMARK "LP7" 
3278 f5				push af  
3279 3a 8d 32			ld a, (.dmark)  
327c 32 6e fb			ld (debug_mark),a  
327f 3a 8e 32			ld a, (.dmark+1)  
3282 32 6f fb			ld (debug_mark+1),a  
3285 3a 8f 32			ld a, (.dmark+2)  
3288 32 70 fb			ld (debug_mark+2),a  
328b 18 03			jr .pastdmark  
328d ..			.dmark: db "LP7"  
3290 f1			.pastdmark: pop af  
3291			endm  
# End of macro DMARK
3291					CALLMONITOR 
3291 cd ab 16			call break_point_state  
3294				endm  
# End of macro CALLMONITOR
3294					endif 
3294				FORTH_RSP_TOS 
3294 cd c6 1c			call macro_forth_rsp_tos 
3297				endm 
# End of macro FORTH_RSP_TOS
3297			 
3297					if DEBUG_FORTH_WORDS 
3297						DMARK "LP8" 
3297 f5				push af  
3298 3a ac 32			ld a, (.dmark)  
329b 32 6e fb			ld (debug_mark),a  
329e 3a ad 32			ld a, (.dmark+1)  
32a1 32 6f fb			ld (debug_mark+1),a  
32a4 3a ae 32			ld a, (.dmark+2)  
32a7 32 70 fb			ld (debug_mark+2),a  
32aa 18 03			jr .pastdmark  
32ac ..			.dmark: db "LP8"  
32af f1			.pastdmark: pop af  
32b0			endm  
# End of macro DMARK
32b0					CALLMONITOR 
32b0 cd ab 16			call break_point_state  
32b3				endm  
# End of macro CALLMONITOR
32b3					endif 
32b3				;push hl 
32b3			 
32b3				; not going to DO any more 
32b3				; get rid of the RSP pointer as DO will add it back in 
32b3				;FORTH_RSP_POP 
32b3				;pop hl 
32b3			 
32b3				;ld hl,(cli_ret_sp) 
32b3				;ld e, (hl) 
32b3				;inc hl 
32b3				;ld d, (hl) 
32b3				;ex de,hl 
32b3 22 15 f1			ld (os_tok_ptr), hl 
32b6					if DEBUG_FORTH_WORDS 
32b6						DMARK "LP<" 
32b6 f5				push af  
32b7 3a cb 32			ld a, (.dmark)  
32ba 32 6e fb			ld (debug_mark),a  
32bd 3a cc 32			ld a, (.dmark+1)  
32c0 32 6f fb			ld (debug_mark+1),a  
32c3 3a cd 32			ld a, (.dmark+2)  
32c6 32 70 fb			ld (debug_mark+2),a  
32c9 18 03			jr .pastdmark  
32cb ..			.dmark: db "LP<"  
32ce f1			.pastdmark: pop af  
32cf			endm  
# End of macro DMARK
32cf					CALLMONITOR 
32cf cd ab 16			call break_point_state  
32d2				endm  
# End of macro CALLMONITOR
32d2				endif 
32d2 c3 02 21			jp exec1 
32d5			 
32d5					 
32d5			 
32d5			 
32d5					NEXTW 
32d5 c3 71 20			jp macro_next 
32d8				endm 
# End of macro NEXTW
32d8			.I:  
32d8			 
32d8				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32d8 5e				db WORD_SYS_CORE+74             
32d9 03 33			dw .DLOOP            
32db 02				db 1 + 1 
32dc .. 00			db "I",0              
32de				endm 
# End of macro CWHEAD
32de			; | I ( -- ) Current loop counter | DONE 
32de					if DEBUG_FORTH_WORDS_KEY 
32de						DMARK "I.." 
32de f5				push af  
32df 3a f3 32			ld a, (.dmark)  
32e2 32 6e fb			ld (debug_mark),a  
32e5 3a f4 32			ld a, (.dmark+1)  
32e8 32 6f fb			ld (debug_mark+1),a  
32eb 3a f5 32			ld a, (.dmark+2)  
32ee 32 70 fb			ld (debug_mark+2),a  
32f1 18 03			jr .pastdmark  
32f3 ..			.dmark: db "I.."  
32f6 f1			.pastdmark: pop af  
32f7			endm  
# End of macro DMARK
32f7						CALLMONITOR 
32f7 cd ab 16			call break_point_state  
32fa				endm  
# End of macro CALLMONITOR
32fa					endif 
32fa			 
32fa 2a 39 f1				ld hl,(os_current_i) 
32fd cd 08 1d				call forth_push_numhl 
3300			 
3300					NEXTW 
3300 c3 71 20			jp macro_next 
3303				endm 
# End of macro NEXTW
3303			.DLOOP: 
3303				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3303 5f				db WORD_SYS_CORE+75             
3304 e4 33			dw .REPEAT            
3306 06				db 5 + 1 
3307 .. 00			db "-LOOP",0              
330d				endm 
# End of macro CWHEAD
330d			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
330d				; pop tos as current loop count to hl 
330d					if DEBUG_FORTH_WORDS_KEY 
330d						DMARK "-LP" 
330d f5				push af  
330e 3a 22 33			ld a, (.dmark)  
3311 32 6e fb			ld (debug_mark),a  
3314 3a 23 33			ld a, (.dmark+1)  
3317 32 6f fb			ld (debug_mark+1),a  
331a 3a 24 33			ld a, (.dmark+2)  
331d 32 70 fb			ld (debug_mark+2),a  
3320 18 03			jr .pastdmark  
3322 ..			.dmark: db "-LP"  
3325 f1			.pastdmark: pop af  
3326			endm  
# End of macro DMARK
3326						CALLMONITOR 
3326 cd ab 16			call break_point_state  
3329				endm  
# End of macro CALLMONITOR
3329					endif 
3329			 
3329				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3329			 
3329				FORTH_LOOP_TOS 
3329 cd 63 1f			call macro_forth_loop_tos 
332c				endm 
# End of macro FORTH_LOOP_TOS
332c e5				push hl 
332d			 
332d					if DEBUG_FORTH_WORDS 
332d						DMARK "-LP" 
332d f5				push af  
332e 3a 42 33			ld a, (.dmark)  
3331 32 6e fb			ld (debug_mark),a  
3334 3a 43 33			ld a, (.dmark+1)  
3337 32 6f fb			ld (debug_mark+1),a  
333a 3a 44 33			ld a, (.dmark+2)  
333d 32 70 fb			ld (debug_mark+2),a  
3340 18 03			jr .pastdmark  
3342 ..			.dmark: db "-LP"  
3345 f1			.pastdmark: pop af  
3346			endm  
# End of macro DMARK
3346						CALLMONITOR 
3346 cd ab 16			call break_point_state  
3349				endm  
# End of macro CALLMONITOR
3349					endif 
3349				; next item on the stack is the limit. get it 
3349			 
3349			 
3349				FORTH_LOOP_POP 
3349 cd 6d 1f			call macro_forth_loop_pop 
334c				endm 
# End of macro FORTH_LOOP_POP
334c			 
334c				FORTH_LOOP_TOS 
334c cd 63 1f			call macro_forth_loop_tos 
334f				endm 
# End of macro FORTH_LOOP_TOS
334f			 
334f d1				pop de		 ; de = i, hl = limit 
3350			 
3350					if DEBUG_FORTH_WORDS 
3350						DMARK "-L1" 
3350 f5				push af  
3351 3a 65 33			ld a, (.dmark)  
3354 32 6e fb			ld (debug_mark),a  
3357 3a 66 33			ld a, (.dmark+1)  
335a 32 6f fb			ld (debug_mark+1),a  
335d 3a 67 33			ld a, (.dmark+2)  
3360 32 70 fb			ld (debug_mark+2),a  
3363 18 03			jr .pastdmark  
3365 ..			.dmark: db "-L1"  
3368 f1			.pastdmark: pop af  
3369			endm  
# End of macro DMARK
3369						CALLMONITOR 
3369 cd ab 16			call break_point_state  
336c				endm  
# End of macro CALLMONITOR
336c					endif 
336c			 
336c				; go back to previous word 
336c			 
336c d5				push de    ; save I for inc later 
336d			 
336d			 
336d				; get limit 
336d				;  is I at limit? 
336d			 
336d			 
336d					if DEBUG_FORTH_WORDS 
336d						DMARK "-L1" 
336d f5				push af  
336e 3a 82 33			ld a, (.dmark)  
3371 32 6e fb			ld (debug_mark),a  
3374 3a 83 33			ld a, (.dmark+1)  
3377 32 6f fb			ld (debug_mark+1),a  
337a 3a 84 33			ld a, (.dmark+2)  
337d 32 70 fb			ld (debug_mark+2),a  
3380 18 03			jr .pastdmark  
3382 ..			.dmark: db "-L1"  
3385 f1			.pastdmark: pop af  
3386			endm  
# End of macro DMARK
3386						CALLMONITOR 
3386 cd ab 16			call break_point_state  
3389				endm  
# End of macro CALLMONITOR
3389					endif 
3389			 
3389 ed 52			sbc hl, de 
338b			 
338b			 
338b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
338b			 
338b 20 26				jr nz, .mloopnotdone 
338d			 
338d e1				pop hl   ; get rid of saved I 
338e				FORTH_LOOP_POP     ; get rid of limit 
338e cd 6d 1f			call macro_forth_loop_pop 
3391				endm 
# End of macro FORTH_LOOP_POP
3391			 
3391				FORTH_RSP_POP     ; get rid of DO ptr 
3391 cd d0 1c			call macro_forth_rsp_pop 
3394				endm 
# End of macro FORTH_RSP_POP
3394			 
3394			if DEBUG_FORTH_WORDS 
3394						DMARK "-L>" 
3394 f5				push af  
3395 3a a9 33			ld a, (.dmark)  
3398 32 6e fb			ld (debug_mark),a  
339b 3a aa 33			ld a, (.dmark+1)  
339e 32 6f fb			ld (debug_mark+1),a  
33a1 3a ab 33			ld a, (.dmark+2)  
33a4 32 70 fb			ld (debug_mark+2),a  
33a7 18 03			jr .pastdmark  
33a9 ..			.dmark: db "-L>"  
33ac f1			.pastdmark: pop af  
33ad			endm  
# End of macro DMARK
33ad				CALLMONITOR 
33ad cd ab 16			call break_point_state  
33b0				endm  
# End of macro CALLMONITOR
33b0			endif 
33b0			 
33b0					NEXTW 
33b0 c3 71 20			jp macro_next 
33b3				endm 
# End of macro NEXTW
33b3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33b3			 
33b3			.mloopnotdone: 
33b3			 
33b3 e1				pop hl    ; get I 
33b4 2b				dec hl 
33b5			 
33b5			   	; save new I 
33b5			 
33b5			 
33b5					; set I counter 
33b5			 
33b5 22 39 f1				ld (os_current_i), hl 
33b8			 
33b8					 
33b8				FORTH_LOOP_NEXT 
33b8 cd 30 1f			call macro_forth_loop_next 
33bb				endm 
# End of macro FORTH_LOOP_NEXT
33bb			 
33bb			 
33bb					if DEBUG_FORTH_WORDS 
33bb eb						ex de,hl 
33bc					endif 
33bc			 
33bc			;	; get DO ptr 
33bc			; 
33bc				FORTH_RSP_TOS 
33bc cd c6 1c			call macro_forth_rsp_tos 
33bf				endm 
# End of macro FORTH_RSP_TOS
33bf			 
33bf				;push hl 
33bf			 
33bf				; not going to DO any more 
33bf				; get rid of the RSP pointer as DO will add it back in 
33bf				;FORTH_RSP_POP 
33bf				;pop hl 
33bf			 
33bf			 
33bf 22 15 f1			ld (os_tok_ptr), hl 
33c2					if DEBUG_FORTH_WORDS 
33c2						DMARK "-L<" 
33c2 f5				push af  
33c3 3a d7 33			ld a, (.dmark)  
33c6 32 6e fb			ld (debug_mark),a  
33c9 3a d8 33			ld a, (.dmark+1)  
33cc 32 6f fb			ld (debug_mark+1),a  
33cf 3a d9 33			ld a, (.dmark+2)  
33d2 32 70 fb			ld (debug_mark+2),a  
33d5 18 03			jr .pastdmark  
33d7 ..			.dmark: db "-L<"  
33da f1			.pastdmark: pop af  
33db			endm  
# End of macro DMARK
33db					CALLMONITOR 
33db cd ab 16			call break_point_state  
33de				endm  
# End of macro CALLMONITOR
33de				endif 
33de c3 02 21			jp exec1 
33e1			 
33e1					 
33e1			 
33e1			 
33e1			 
33e1				NEXTW 
33e1 c3 71 20			jp macro_next 
33e4				endm 
# End of macro NEXTW
33e4			 
33e4			 
33e4			 
33e4			 
33e4			.REPEAT: 
33e4				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33e4 71				db WORD_SYS_CORE+93             
33e5 37 34			dw .UNTIL            
33e7 06				db 5 + 1 
33e8 .. 00			db "REPEAT",0              
33ef				endm 
# End of macro CWHEAD
33ef			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33ef			;  push pc to rsp stack past the REPEAT 
33ef					if DEBUG_FORTH_WORDS_KEY 
33ef						DMARK "REP" 
33ef f5				push af  
33f0 3a 04 34			ld a, (.dmark)  
33f3 32 6e fb			ld (debug_mark),a  
33f6 3a 05 34			ld a, (.dmark+1)  
33f9 32 6f fb			ld (debug_mark+1),a  
33fc 3a 06 34			ld a, (.dmark+2)  
33ff 32 70 fb			ld (debug_mark+2),a  
3402 18 03			jr .pastdmark  
3404 ..			.dmark: db "REP"  
3407 f1			.pastdmark: pop af  
3408			endm  
# End of macro DMARK
3408						CALLMONITOR 
3408 cd ab 16			call break_point_state  
340b				endm  
# End of macro CALLMONITOR
340b					endif 
340b			 
340b 2a 15 f1				ld hl, (os_tok_ptr) 
340e 23					inc hl   ; R 
340f 23					inc hl  ; E 
3410 23					inc hl   ; P 
3411 23					inc hl   ; E 
3412 23					inc hl   ; A 
3413 23					inc hl   ; T 
3414 23					inc hl   ; zero 
3415					FORTH_RSP_NEXT 
3415 cd af 1c			call macro_forth_rsp_next 
3418				endm 
# End of macro FORTH_RSP_NEXT
3418			 
3418			 
3418					if DEBUG_FORTH_WORDS 
3418						DMARK "REP" 
3418 f5				push af  
3419 3a 2d 34			ld a, (.dmark)  
341c 32 6e fb			ld (debug_mark),a  
341f 3a 2e 34			ld a, (.dmark+1)  
3422 32 6f fb			ld (debug_mark+1),a  
3425 3a 2f 34			ld a, (.dmark+2)  
3428 32 70 fb			ld (debug_mark+2),a  
342b 18 03			jr .pastdmark  
342d ..			.dmark: db "REP"  
3430 f1			.pastdmark: pop af  
3431			endm  
# End of macro DMARK
3431						;pop bc    ; TODO BUG ?????? what is this for???? 
3431						CALLMONITOR 
3431 cd ab 16			call break_point_state  
3434				endm  
# End of macro CALLMONITOR
3434					endif 
3434			 
3434					NEXTW 
3434 c3 71 20			jp macro_next 
3437				endm 
# End of macro NEXTW
3437			;	       NEXTW 
3437			 
3437			.UNTIL: 
3437				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3437 72				db WORD_SYS_CORE+94             
3438 ce 34			dw .ENDFLOW            
343a 06				db 5 + 1 
343b .. 00			db "UNTIL",0              
3441				endm 
# End of macro CWHEAD
3441			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3441			 
3441				; pop tos as check 
3441			 
3441				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3441			 
3441				FORTH_DSP_VALUEHL 
3441 cd ff 1e			call macro_dsp_valuehl 
3444				endm 
# End of macro FORTH_DSP_VALUEHL
3444			 
3444					if DEBUG_FORTH_WORDS_KEY 
3444						DMARK "UNT" 
3444 f5				push af  
3445 3a 59 34			ld a, (.dmark)  
3448 32 6e fb			ld (debug_mark),a  
344b 3a 5a 34			ld a, (.dmark+1)  
344e 32 6f fb			ld (debug_mark+1),a  
3451 3a 5b 34			ld a, (.dmark+2)  
3454 32 70 fb			ld (debug_mark+2),a  
3457 18 03			jr .pastdmark  
3459 ..			.dmark: db "UNT"  
345c f1			.pastdmark: pop af  
345d			endm  
# End of macro DMARK
345d						CALLMONITOR 
345d cd ab 16			call break_point_state  
3460				endm  
# End of macro CALLMONITOR
3460					endif 
3460			 
3460			;	push hl 
3460				FORTH_DSP_POP 
3460 cd b7 1f			call macro_forth_dsp_pop 
3463				endm 
# End of macro FORTH_DSP_POP
3463			 
3463			;	pop hl 
3463			 
3463				; test if true 
3463			 
3463 cd 2d 0d			call ishlzero 
3466			;	ld a,l 
3466			;	add h 
3466			; 
3466			;	cp 0 
3466			 
3466 20 3e			jr nz, .untilnotdone 
3468			 
3468					if DEBUG_FORTH_WORDS 
3468						DMARK "UNf" 
3468 f5				push af  
3469 3a 7d 34			ld a, (.dmark)  
346c 32 6e fb			ld (debug_mark),a  
346f 3a 7e 34			ld a, (.dmark+1)  
3472 32 6f fb			ld (debug_mark+1),a  
3475 3a 7f 34			ld a, (.dmark+2)  
3478 32 70 fb			ld (debug_mark+2),a  
347b 18 03			jr .pastdmark  
347d ..			.dmark: db "UNf"  
3480 f1			.pastdmark: pop af  
3481			endm  
# End of macro DMARK
3481						CALLMONITOR 
3481 cd ab 16			call break_point_state  
3484				endm  
# End of macro CALLMONITOR
3484					endif 
3484			 
3484			 
3484			 
3484				FORTH_RSP_POP     ; get rid of DO ptr 
3484 cd d0 1c			call macro_forth_rsp_pop 
3487				endm 
# End of macro FORTH_RSP_POP
3487			 
3487			if DEBUG_FORTH_WORDS 
3487						DMARK "UN>" 
3487 f5				push af  
3488 3a 9c 34			ld a, (.dmark)  
348b 32 6e fb			ld (debug_mark),a  
348e 3a 9d 34			ld a, (.dmark+1)  
3491 32 6f fb			ld (debug_mark+1),a  
3494 3a 9e 34			ld a, (.dmark+2)  
3497 32 70 fb			ld (debug_mark+2),a  
349a 18 03			jr .pastdmark  
349c ..			.dmark: db "UN>"  
349f f1			.pastdmark: pop af  
34a0			endm  
# End of macro DMARK
34a0				CALLMONITOR 
34a0 cd ab 16			call break_point_state  
34a3				endm  
# End of macro CALLMONITOR
34a3			endif 
34a3			 
34a3					NEXTW 
34a3 c3 71 20			jp macro_next 
34a6				endm 
# End of macro NEXTW
34a6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34a6			 
34a6			.untilnotdone: 
34a6			 
34a6			 
34a6			;	; get DO ptr 
34a6			; 
34a6				FORTH_RSP_TOS 
34a6 cd c6 1c			call macro_forth_rsp_tos 
34a9				endm 
# End of macro FORTH_RSP_TOS
34a9			 
34a9				;push hl 
34a9			 
34a9				; not going to DO any more 
34a9				; get rid of the RSP pointer as DO will add it back in 
34a9				;FORTH_RSP_POP 
34a9				;pop hl 
34a9			 
34a9			 
34a9 22 15 f1			ld (os_tok_ptr), hl 
34ac					if DEBUG_FORTH_WORDS 
34ac						DMARK "UN<" 
34ac f5				push af  
34ad 3a c1 34			ld a, (.dmark)  
34b0 32 6e fb			ld (debug_mark),a  
34b3 3a c2 34			ld a, (.dmark+1)  
34b6 32 6f fb			ld (debug_mark+1),a  
34b9 3a c3 34			ld a, (.dmark+2)  
34bc 32 70 fb			ld (debug_mark+2),a  
34bf 18 03			jr .pastdmark  
34c1 ..			.dmark: db "UN<"  
34c4 f1			.pastdmark: pop af  
34c5			endm  
# End of macro DMARK
34c5					CALLMONITOR 
34c5 cd ab 16			call break_point_state  
34c8				endm  
# End of macro CALLMONITOR
34c8				endif 
34c8 c3 02 21			jp exec1 
34cb			 
34cb					 
34cb			 
34cb			 
34cb					NEXTW 
34cb c3 71 20			jp macro_next 
34ce				endm 
# End of macro NEXTW
34ce			 
34ce			 
34ce			.ENDFLOW: 
34ce			 
34ce			; eof 
34ce			 
# End of file forth_words_flow.asm
34ce			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34ce			include "forth_words_logic.asm" 
34ce			 
34ce			; | ## Logic Words 
34ce			 
34ce			.NOT: 
34ce				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34ce 2d				db WORD_SYS_CORE+25             
34cf 16 35			dw .IS            
34d1 04				db 3 + 1 
34d2 .. 00			db "NOT",0              
34d6				endm 
# End of macro CWHEAD
34d6			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34d6					if DEBUG_FORTH_WORDS_KEY 
34d6						DMARK "NOT" 
34d6 f5				push af  
34d7 3a eb 34			ld a, (.dmark)  
34da 32 6e fb			ld (debug_mark),a  
34dd 3a ec 34			ld a, (.dmark+1)  
34e0 32 6f fb			ld (debug_mark+1),a  
34e3 3a ed 34			ld a, (.dmark+2)  
34e6 32 70 fb			ld (debug_mark+2),a  
34e9 18 03			jr .pastdmark  
34eb ..			.dmark: db "NOT"  
34ee f1			.pastdmark: pop af  
34ef			endm  
# End of macro DMARK
34ef						CALLMONITOR 
34ef cd ab 16			call break_point_state  
34f2				endm  
# End of macro CALLMONITOR
34f2					endif 
34f2					FORTH_DSP 
34f2 cd c5 1e			call macro_forth_dsp 
34f5				endm 
# End of macro FORTH_DSP
34f5 7e					ld a,(hl)	; get type of value on TOS 
34f6 fe 02				cp DS_TYPE_INUM  
34f8 28 03				jr z, .noti 
34fa					NEXTW 
34fa c3 71 20			jp macro_next 
34fd				endm 
# End of macro NEXTW
34fd			.noti:          FORTH_DSP_VALUEHL 
34fd cd ff 1e			call macro_dsp_valuehl 
3500				endm 
# End of macro FORTH_DSP_VALUEHL
3500			;		push hl 
3500					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3500 cd b7 1f			call macro_forth_dsp_pop 
3503				endm 
# End of macro FORTH_DSP_POP
3503			;		pop hl 
3503 3e 00				ld a,0 
3505 bd					cp l 
3506 28 04				jr z, .not2t 
3508 2e 00				ld l, 0 
350a 18 02				jr .notip 
350c			 
350c 2e ff		.not2t:		ld l, 255 
350e			 
350e 26 00		.notip:		ld h, 0	 
3510			 
3510 cd 08 1d				call forth_push_numhl 
3513					NEXTW 
3513 c3 71 20			jp macro_next 
3516				endm 
# End of macro NEXTW
3516			 
3516			.IS: 
3516				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3516 2d				db WORD_SYS_CORE+25             
3517 3c 35			dw .LZERO            
3519 03				db 2 + 1 
351a .. 00			db "IS",0              
351d				endm 
# End of macro CWHEAD
351d			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
351d					if DEBUG_FORTH_WORDS_KEY 
351d						DMARK "IS." 
351d f5				push af  
351e 3a 32 35			ld a, (.dmark)  
3521 32 6e fb			ld (debug_mark),a  
3524 3a 33 35			ld a, (.dmark+1)  
3527 32 6f fb			ld (debug_mark+1),a  
352a 3a 34 35			ld a, (.dmark+2)  
352d 32 70 fb			ld (debug_mark+2),a  
3530 18 03			jr .pastdmark  
3532 ..			.dmark: db "IS."  
3535 f1			.pastdmark: pop af  
3536			endm  
# End of macro DMARK
3536						CALLMONITOR 
3536 cd ab 16			call break_point_state  
3539				endm  
# End of macro CALLMONITOR
3539					endif 
3539					NEXTW 
3539 c3 71 20			jp macro_next 
353c				endm 
# End of macro NEXTW
353c			.LZERO: 
353c				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
353c 2d				db WORD_SYS_CORE+25             
353d 46 35			dw .TZERO            
353f 03				db 2 + 1 
3540 .. 00			db "0<",0              
3543				endm 
# End of macro CWHEAD
3543			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3543					NEXTW 
3543 c3 71 20			jp macro_next 
3546				endm 
# End of macro NEXTW
3546			.TZERO: 
3546				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3546 2e				db WORD_SYS_CORE+26             
3547 8d 35			dw .LESS            
3549 03				db 2 + 1 
354a .. 00			db "0=",0              
354d				endm 
# End of macro CWHEAD
354d			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
354d				; TODO add floating point number detection 
354d					;v5 FORTH_DSP_VALUE 
354d					if DEBUG_FORTH_WORDS_KEY 
354d						DMARK "0=." 
354d f5				push af  
354e 3a 62 35			ld a, (.dmark)  
3551 32 6e fb			ld (debug_mark),a  
3554 3a 63 35			ld a, (.dmark+1)  
3557 32 6f fb			ld (debug_mark+1),a  
355a 3a 64 35			ld a, (.dmark+2)  
355d 32 70 fb			ld (debug_mark+2),a  
3560 18 03			jr .pastdmark  
3562 ..			.dmark: db "0=."  
3565 f1			.pastdmark: pop af  
3566			endm  
# End of macro DMARK
3566						CALLMONITOR 
3566 cd ab 16			call break_point_state  
3569				endm  
# End of macro CALLMONITOR
3569					endif 
3569					FORTH_DSP 
3569 cd c5 1e			call macro_forth_dsp 
356c				endm 
# End of macro FORTH_DSP
356c 7e					ld a,(hl)	; get type of value on TOS 
356d fe 02				cp DS_TYPE_INUM  
356f 28 00				jr z, .tz_inum 
3571			 
3571				if FORTH_ENABLE_FLOATMATH 
3571					jr .tz_done 
3571			 
3571				endif 
3571					 
3571			 
3571			.tz_inum: 
3571					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3571 cd ff 1e			call macro_dsp_valuehl 
3574				endm 
# End of macro FORTH_DSP_VALUEHL
3574			 
3574			;		push hl 
3574			 
3574					; destroy value TOS 
3574			 
3574					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3574 cd b7 1f			call macro_forth_dsp_pop 
3577				endm 
# End of macro FORTH_DSP_POP
3577			 
3577			;		pop hl 
3577			 
3577 3e 00				ld a,0 
3579			 
3579 bd					cp l 
357a 20 08				jr nz, .tz_notzero 
357c			 
357c bc					cp h 
357d			 
357d 20 05				jr nz, .tz_notzero 
357f			 
357f			 
357f 21 01 00				ld hl, FORTH_TRUE 
3582 18 03				jr .tz_done 
3584			 
3584 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3587			 
3587					; push value back onto stack for another op etc 
3587			 
3587			.tz_done: 
3587 cd 08 1d				call forth_push_numhl 
358a			 
358a					NEXTW 
358a c3 71 20			jp macro_next 
358d				endm 
# End of macro NEXTW
358d			.LESS: 
358d				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
358d 2f				db WORD_SYS_CORE+27             
358e f6 35			dw .GT            
3590 02				db 1 + 1 
3591 .. 00			db "<",0              
3593				endm 
# End of macro CWHEAD
3593			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3593				; TODO add floating point number detection 
3593					if DEBUG_FORTH_WORDS_KEY 
3593						DMARK "LES" 
3593 f5				push af  
3594 3a a8 35			ld a, (.dmark)  
3597 32 6e fb			ld (debug_mark),a  
359a 3a a9 35			ld a, (.dmark+1)  
359d 32 6f fb			ld (debug_mark+1),a  
35a0 3a aa 35			ld a, (.dmark+2)  
35a3 32 70 fb			ld (debug_mark+2),a  
35a6 18 03			jr .pastdmark  
35a8 ..			.dmark: db "LES"  
35ab f1			.pastdmark: pop af  
35ac			endm  
# End of macro DMARK
35ac						CALLMONITOR 
35ac cd ab 16			call break_point_state  
35af				endm  
# End of macro CALLMONITOR
35af					endif 
35af					FORTH_DSP 
35af cd c5 1e			call macro_forth_dsp 
35b2				endm 
# End of macro FORTH_DSP
35b2					;v5 FORTH_DSP_VALUE 
35b2 7e					ld a,(hl)	; get type of value on TOS 
35b3 fe 02				cp DS_TYPE_INUM  
35b5 28 00				jr z, .less_inum 
35b7			 
35b7				if FORTH_ENABLE_FLOATMATH 
35b7					jr .less_done 
35b7			 
35b7				endif 
35b7					 
35b7			 
35b7			.less_inum: 
35b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35b7 cd ff 1e			call macro_dsp_valuehl 
35ba				endm 
# End of macro FORTH_DSP_VALUEHL
35ba			 
35ba e5					push hl  ; u2 
35bb			 
35bb					; destroy value TOS 
35bb			 
35bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35bb cd b7 1f			call macro_forth_dsp_pop 
35be				endm 
# End of macro FORTH_DSP_POP
35be			 
35be			 
35be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35be cd ff 1e			call macro_dsp_valuehl 
35c1				endm 
# End of macro FORTH_DSP_VALUEHL
35c1			 
35c1 e5					push hl    ; u1 
35c2			 
35c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35c2 cd b7 1f			call macro_forth_dsp_pop 
35c5				endm 
# End of macro FORTH_DSP_POP
35c5			 
35c5			 
35c5 b7			 or a      ;clear carry flag 
35c6 01 00 00		 ld bc, FORTH_FALSE 
35c9 e1			  pop hl    ; u1 
35ca d1			  pop de    ; u2 
35cb ed 52		  sbc hl,de 
35cd 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35cf			 
35cf 01 01 00		 ld bc, FORTH_TRUE 
35d2			.lscont:  
35d2 c5					push bc 
35d3 e1					pop hl 
35d4			 
35d4					if DEBUG_FORTH_WORDS 
35d4						DMARK "LT1" 
35d4 f5				push af  
35d5 3a e9 35			ld a, (.dmark)  
35d8 32 6e fb			ld (debug_mark),a  
35db 3a ea 35			ld a, (.dmark+1)  
35de 32 6f fb			ld (debug_mark+1),a  
35e1 3a eb 35			ld a, (.dmark+2)  
35e4 32 70 fb			ld (debug_mark+2),a  
35e7 18 03			jr .pastdmark  
35e9 ..			.dmark: db "LT1"  
35ec f1			.pastdmark: pop af  
35ed			endm  
# End of macro DMARK
35ed						CALLMONITOR 
35ed cd ab 16			call break_point_state  
35f0				endm  
# End of macro CALLMONITOR
35f0					endif 
35f0 cd 08 1d				call forth_push_numhl 
35f3			 
35f3					NEXTW 
35f3 c3 71 20			jp macro_next 
35f6				endm 
# End of macro NEXTW
35f6			.GT: 
35f6				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35f6 30				db WORD_SYS_CORE+28             
35f7 5f 36			dw .EQUAL            
35f9 02				db 1 + 1 
35fa .. 00			db ">",0              
35fc				endm 
# End of macro CWHEAD
35fc			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35fc				; TODO add floating point number detection 
35fc					if DEBUG_FORTH_WORDS_KEY 
35fc						DMARK "GRT" 
35fc f5				push af  
35fd 3a 11 36			ld a, (.dmark)  
3600 32 6e fb			ld (debug_mark),a  
3603 3a 12 36			ld a, (.dmark+1)  
3606 32 6f fb			ld (debug_mark+1),a  
3609 3a 13 36			ld a, (.dmark+2)  
360c 32 70 fb			ld (debug_mark+2),a  
360f 18 03			jr .pastdmark  
3611 ..			.dmark: db "GRT"  
3614 f1			.pastdmark: pop af  
3615			endm  
# End of macro DMARK
3615						CALLMONITOR 
3615 cd ab 16			call break_point_state  
3618				endm  
# End of macro CALLMONITOR
3618					endif 
3618					FORTH_DSP 
3618 cd c5 1e			call macro_forth_dsp 
361b				endm 
# End of macro FORTH_DSP
361b					;FORTH_DSP_VALUE 
361b 7e					ld a,(hl)	; get type of value on TOS 
361c fe 02				cp DS_TYPE_INUM  
361e 28 00				jr z, .gt_inum 
3620			 
3620				if FORTH_ENABLE_FLOATMATH 
3620					jr .gt_done 
3620			 
3620				endif 
3620					 
3620			 
3620			.gt_inum: 
3620					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3620 cd ff 1e			call macro_dsp_valuehl 
3623				endm 
# End of macro FORTH_DSP_VALUEHL
3623			 
3623 e5					push hl  ; u2 
3624			 
3624					; destroy value TOS 
3624			 
3624					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3624 cd b7 1f			call macro_forth_dsp_pop 
3627				endm 
# End of macro FORTH_DSP_POP
3627			 
3627			 
3627					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3627 cd ff 1e			call macro_dsp_valuehl 
362a				endm 
# End of macro FORTH_DSP_VALUEHL
362a			 
362a e5					push hl    ; u1 
362b			 
362b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
362b cd b7 1f			call macro_forth_dsp_pop 
362e				endm 
# End of macro FORTH_DSP_POP
362e			 
362e			 
362e b7			 or a      ;clear carry flag 
362f 01 00 00		 ld bc, FORTH_FALSE 
3632 e1			  pop hl    ; u1 
3633 d1			  pop de    ; u2 
3634 ed 52		  sbc hl,de 
3636 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3638			 
3638 01 01 00		 ld bc, FORTH_TRUE 
363b			.gtcont:  
363b c5					push bc 
363c e1					pop hl 
363d			 
363d					if DEBUG_FORTH_WORDS 
363d						DMARK "GT1" 
363d f5				push af  
363e 3a 52 36			ld a, (.dmark)  
3641 32 6e fb			ld (debug_mark),a  
3644 3a 53 36			ld a, (.dmark+1)  
3647 32 6f fb			ld (debug_mark+1),a  
364a 3a 54 36			ld a, (.dmark+2)  
364d 32 70 fb			ld (debug_mark+2),a  
3650 18 03			jr .pastdmark  
3652 ..			.dmark: db "GT1"  
3655 f1			.pastdmark: pop af  
3656			endm  
# End of macro DMARK
3656						CALLMONITOR 
3656 cd ab 16			call break_point_state  
3659				endm  
# End of macro CALLMONITOR
3659					endif 
3659 cd 08 1d				call forth_push_numhl 
365c			 
365c					NEXTW 
365c c3 71 20			jp macro_next 
365f				endm 
# End of macro NEXTW
365f			.EQUAL: 
365f				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
365f 31				db WORD_SYS_CORE+29             
3660 ca 36			dw .ENDLOGIC            
3662 02				db 1 + 1 
3663 .. 00			db "=",0              
3665				endm 
# End of macro CWHEAD
3665			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3665				; TODO add floating point number detection 
3665					if DEBUG_FORTH_WORDS_KEY 
3665						DMARK "EQ." 
3665 f5				push af  
3666 3a 7a 36			ld a, (.dmark)  
3669 32 6e fb			ld (debug_mark),a  
366c 3a 7b 36			ld a, (.dmark+1)  
366f 32 6f fb			ld (debug_mark+1),a  
3672 3a 7c 36			ld a, (.dmark+2)  
3675 32 70 fb			ld (debug_mark+2),a  
3678 18 03			jr .pastdmark  
367a ..			.dmark: db "EQ."  
367d f1			.pastdmark: pop af  
367e			endm  
# End of macro DMARK
367e						CALLMONITOR 
367e cd ab 16			call break_point_state  
3681				endm  
# End of macro CALLMONITOR
3681					endif 
3681					FORTH_DSP 
3681 cd c5 1e			call macro_forth_dsp 
3684				endm 
# End of macro FORTH_DSP
3684					;v5 FORTH_DSP_VALUE 
3684 7e					ld a,(hl)	; get type of value on TOS 
3685 fe 02				cp DS_TYPE_INUM  
3687 28 00				jr z, .eq_inum 
3689			 
3689				if FORTH_ENABLE_FLOATMATH 
3689					jr .eq_done 
3689			 
3689				endif 
3689					 
3689			 
3689			.eq_inum: 
3689					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3689 cd ff 1e			call macro_dsp_valuehl 
368c				endm 
# End of macro FORTH_DSP_VALUEHL
368c			 
368c e5					push hl 
368d			 
368d					; destroy value TOS 
368d			 
368d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
368d cd b7 1f			call macro_forth_dsp_pop 
3690				endm 
# End of macro FORTH_DSP_POP
3690			 
3690			 
3690					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3690 cd ff 1e			call macro_dsp_valuehl 
3693				endm 
# End of macro FORTH_DSP_VALUEHL
3693			 
3693					; one value on hl get other one back 
3693			 
3693 e5					push hl 
3694			 
3694					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3694 cd b7 1f			call macro_forth_dsp_pop 
3697				endm 
# End of macro FORTH_DSP_POP
3697			 
3697 0e 00				ld c, FORTH_FALSE 
3699			 
3699 e1					pop hl 
369a d1					pop de 
369b			 
369b 7b					ld a, e 
369c bd					cp l 
369d			 
369d 20 06				jr nz, .eq_done 
369f			 
369f 7a					ld a, d 
36a0 bc					cp h 
36a1			 
36a1 20 02				jr nz, .eq_done 
36a3			 
36a3 0e 01				ld c, FORTH_TRUE 
36a5					 
36a5			 
36a5			 
36a5			.eq_done: 
36a5			 
36a5					; TODO push value back onto stack for another op etc 
36a5			 
36a5 26 00				ld h, 0 
36a7 69					ld l, c 
36a8					if DEBUG_FORTH_WORDS 
36a8						DMARK "EQ1" 
36a8 f5				push af  
36a9 3a bd 36			ld a, (.dmark)  
36ac 32 6e fb			ld (debug_mark),a  
36af 3a be 36			ld a, (.dmark+1)  
36b2 32 6f fb			ld (debug_mark+1),a  
36b5 3a bf 36			ld a, (.dmark+2)  
36b8 32 70 fb			ld (debug_mark+2),a  
36bb 18 03			jr .pastdmark  
36bd ..			.dmark: db "EQ1"  
36c0 f1			.pastdmark: pop af  
36c1			endm  
# End of macro DMARK
36c1						CALLMONITOR 
36c1 cd ab 16			call break_point_state  
36c4				endm  
# End of macro CALLMONITOR
36c4					endif 
36c4 cd 08 1d				call forth_push_numhl 
36c7			 
36c7					NEXTW 
36c7 c3 71 20			jp macro_next 
36ca				endm 
# End of macro NEXTW
36ca			 
36ca			 
36ca			.ENDLOGIC: 
36ca			; eof 
36ca			 
36ca			 
# End of file forth_words_logic.asm
36ca			include "forth_words_maths.asm" 
36ca			 
36ca			; | ## Maths Words 
36ca			 
36ca			.PLUS:	 
36ca				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36ca 15				db WORD_SYS_CORE+1             
36cb 0c 37			dw .NEG            
36cd 02				db 1 + 1 
36ce .. 00			db "+",0              
36d0				endm 
# End of macro CWHEAD
36d0			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36d0					if DEBUG_FORTH_WORDS_KEY 
36d0						DMARK "PLU" 
36d0 f5				push af  
36d1 3a e5 36			ld a, (.dmark)  
36d4 32 6e fb			ld (debug_mark),a  
36d7 3a e6 36			ld a, (.dmark+1)  
36da 32 6f fb			ld (debug_mark+1),a  
36dd 3a e7 36			ld a, (.dmark+2)  
36e0 32 70 fb			ld (debug_mark+2),a  
36e3 18 03			jr .pastdmark  
36e5 ..			.dmark: db "PLU"  
36e8 f1			.pastdmark: pop af  
36e9			endm  
# End of macro DMARK
36e9						CALLMONITOR 
36e9 cd ab 16			call break_point_state  
36ec				endm  
# End of macro CALLMONITOR
36ec					endif 
36ec					; add top two values and push back result 
36ec			 
36ec					;for v5 FORTH_DSP_VALUE 
36ec					FORTH_DSP 
36ec cd c5 1e			call macro_forth_dsp 
36ef				endm 
# End of macro FORTH_DSP
36ef 7e					ld a,(hl)	; get type of value on TOS 
36f0 fe 02				cp DS_TYPE_INUM  
36f2 28 03				jr z, .dot_inum 
36f4			 
36f4					NEXTW 
36f4 c3 71 20			jp macro_next 
36f7				endm 
# End of macro NEXTW
36f7			 
36f7			; float maths 
36f7			 
36f7				if FORTH_ENABLE_FLOATMATH 
36f7						inc hl      ; now at start of numeric as string 
36f7			 
36f7					if DEBUG_FORTH_MATHS 
36f7						DMARK "ADD" 
36f7				CALLMONITOR 
36f7					endif 
36f7			 
36f7					;ld ix, hl 
36f7					call CON 
36f7			 
36f7			 
36f7					push hl 
36f7					 
36f7					 
36f7			 
36f7						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36f7			 
36f7					; get next number 
36f7			 
36f7						FORTH_DSP_VALUE 
36f7			 
36f7						inc hl      ; now at start of numeric as string 
36f7			 
36f7					;ld ix, hl 
36f7					call CON 
36f7			 
36f7					push hl 
36f7			 
36f7			 
36f7						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f7			 
36f7						; TODO do add 
36f7			 
36f7						call IADD 
36f7			 
36f7						; TODO get result back as ascii 
36f7			 
36f7						; TODO push result  
36f7			 
36f7			 
36f7			 
36f7						jr .dot_done 
36f7				endif 
36f7			 
36f7			.dot_inum: 
36f7			 
36f7			 
36f7					if DEBUG_FORTH_DOT 
36f7						DMARK "+IT" 
36f7				CALLMONITOR 
36f7					endif 
36f7			 
36f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f7 cd ff 1e			call macro_dsp_valuehl 
36fa				endm 
# End of macro FORTH_DSP_VALUEHL
36fa			 
36fa				; TODO add floating point number detection 
36fa			 
36fa e5					push hl 
36fb			 
36fb					; destroy value TOS 
36fb			 
36fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fb cd b7 1f			call macro_forth_dsp_pop 
36fe				endm 
# End of macro FORTH_DSP_POP
36fe			 
36fe			 
36fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36fe cd ff 1e			call macro_dsp_valuehl 
3701				endm 
# End of macro FORTH_DSP_VALUEHL
3701			 
3701					; one value on hl get other one back 
3701			 
3701 d1					pop de 
3702			 
3702					; do the add 
3702			 
3702 19					add hl,de 
3703			 
3703					; save it 
3703			 
3703			;		push hl	 
3703			 
3703					; 
3703			 
3703					; destroy value TOS 
3703			 
3703					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3703 cd b7 1f			call macro_forth_dsp_pop 
3706				endm 
# End of macro FORTH_DSP_POP
3706			 
3706					; TODO push value back onto stack for another op etc 
3706			 
3706			;		pop hl 
3706			 
3706			.dot_done: 
3706 cd 08 1d				call forth_push_numhl 
3709			 
3709					NEXTW 
3709 c3 71 20			jp macro_next 
370c				endm 
# End of macro NEXTW
370c			.NEG: 
370c			 
370c				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
370c 17				db WORD_SYS_CORE+3             
370d 4f 37			dw .DIV            
370f 02				db 1 + 1 
3710 .. 00			db "-",0              
3712				endm 
# End of macro CWHEAD
3712			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3712					if DEBUG_FORTH_WORDS_KEY 
3712						DMARK "SUB" 
3712 f5				push af  
3713 3a 27 37			ld a, (.dmark)  
3716 32 6e fb			ld (debug_mark),a  
3719 3a 28 37			ld a, (.dmark+1)  
371c 32 6f fb			ld (debug_mark+1),a  
371f 3a 29 37			ld a, (.dmark+2)  
3722 32 70 fb			ld (debug_mark+2),a  
3725 18 03			jr .pastdmark  
3727 ..			.dmark: db "SUB"  
372a f1			.pastdmark: pop af  
372b			endm  
# End of macro DMARK
372b						CALLMONITOR 
372b cd ab 16			call break_point_state  
372e				endm  
# End of macro CALLMONITOR
372e					endif 
372e			 
372e			 
372e				; TODO add floating point number detection 
372e					; v5 FORTH_DSP_VALUE 
372e					FORTH_DSP 
372e cd c5 1e			call macro_forth_dsp 
3731				endm 
# End of macro FORTH_DSP
3731 7e					ld a,(hl)	; get type of value on TOS 
3732 fe 02				cp DS_TYPE_INUM  
3734 28 03				jr z, .neg_inum 
3736			 
3736					NEXTW 
3736 c3 71 20			jp macro_next 
3739				endm 
# End of macro NEXTW
3739			 
3739			; float maths 
3739			 
3739				if FORTH_ENABLE_FLOATMATH 
3739					jr .neg_done 
3739			 
3739				endif 
3739					 
3739			 
3739			.neg_inum: 
3739					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3739 cd ff 1e			call macro_dsp_valuehl 
373c				endm 
# End of macro FORTH_DSP_VALUEHL
373c			 
373c e5					push hl 
373d			 
373d					; destroy value TOS 
373d			 
373d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373d cd b7 1f			call macro_forth_dsp_pop 
3740				endm 
# End of macro FORTH_DSP_POP
3740			 
3740			 
3740					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3740 cd ff 1e			call macro_dsp_valuehl 
3743				endm 
# End of macro FORTH_DSP_VALUEHL
3743			 
3743					; one value on hl get other one back 
3743			 
3743 d1					pop de 
3744			 
3744					; do the sub 
3744			;		ex de, hl 
3744			 
3744 ed 52				sbc hl,de 
3746			 
3746					; save it 
3746			 
3746			;		push hl	 
3746			 
3746					; 
3746			 
3746					; destroy value TOS 
3746			 
3746					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3746 cd b7 1f			call macro_forth_dsp_pop 
3749				endm 
# End of macro FORTH_DSP_POP
3749			 
3749					; TODO push value back onto stack for another op etc 
3749			 
3749			;		pop hl 
3749			 
3749 cd 08 1d				call forth_push_numhl 
374c			.neg_done: 
374c			 
374c					NEXTW 
374c c3 71 20			jp macro_next 
374f				endm 
# End of macro NEXTW
374f			.DIV: 
374f				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
374f 18				db WORD_SYS_CORE+4             
3750 9c 37			dw .MUL            
3752 02				db 1 + 1 
3753 .. 00			db "/",0              
3755				endm 
# End of macro CWHEAD
3755			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3755					if DEBUG_FORTH_WORDS_KEY 
3755						DMARK "DIV" 
3755 f5				push af  
3756 3a 6a 37			ld a, (.dmark)  
3759 32 6e fb			ld (debug_mark),a  
375c 3a 6b 37			ld a, (.dmark+1)  
375f 32 6f fb			ld (debug_mark+1),a  
3762 3a 6c 37			ld a, (.dmark+2)  
3765 32 70 fb			ld (debug_mark+2),a  
3768 18 03			jr .pastdmark  
376a ..			.dmark: db "DIV"  
376d f1			.pastdmark: pop af  
376e			endm  
# End of macro DMARK
376e						CALLMONITOR 
376e cd ab 16			call break_point_state  
3771				endm  
# End of macro CALLMONITOR
3771					endif 
3771				; TODO add floating point number detection 
3771					; v5 FORTH_DSP_VALUE 
3771					FORTH_DSP 
3771 cd c5 1e			call macro_forth_dsp 
3774				endm 
# End of macro FORTH_DSP
3774 7e					ld a,(hl)	; get type of value on TOS 
3775 fe 02				cp DS_TYPE_INUM  
3777 28 03				jr z, .div_inum 
3779			 
3779				if FORTH_ENABLE_FLOATMATH 
3779					jr .div_done 
3779			 
3779				endif 
3779					NEXTW 
3779 c3 71 20			jp macro_next 
377c				endm 
# End of macro NEXTW
377c			.div_inum: 
377c			 
377c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377c cd ff 1e			call macro_dsp_valuehl 
377f				endm 
# End of macro FORTH_DSP_VALUEHL
377f			 
377f e5					push hl    ; to go to bc 
3780			 
3780					; destroy value TOS 
3780			 
3780					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3780 cd b7 1f			call macro_forth_dsp_pop 
3783				endm 
# End of macro FORTH_DSP_POP
3783			 
3783			 
3783					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3783 cd ff 1e			call macro_dsp_valuehl 
3786				endm 
# End of macro FORTH_DSP_VALUEHL
3786			 
3786					; hl to go to de 
3786			 
3786 e5					push hl 
3787			 
3787 c1					pop bc 
3788 d1					pop de		 
3789			 
3789			 
3789					if DEBUG_FORTH_MATHS 
3789						DMARK "DIV" 
3789				CALLMONITOR 
3789					endif 
3789					; one value on hl but move to a get other one back 
3789			 
3789			        
3789 cd 61 0c			call Div16 
378c			 
378c			;	push af	 
378c e5				push hl 
378d c5				push bc 
378e			 
378e					if DEBUG_FORTH_MATHS 
378e						DMARK "DI1" 
378e				CALLMONITOR 
378e					endif 
378e			 
378e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378e cd b7 1f			call macro_forth_dsp_pop 
3791				endm 
# End of macro FORTH_DSP_POP
3791			 
3791			 
3791			 
3791 e1					pop hl    ; result 
3792			 
3792 cd 08 1d				call forth_push_numhl 
3795			 
3795 e1					pop hl    ; reminder 
3796			;		ld h,0 
3796			;		ld l,d 
3796			 
3796 cd 08 1d				call forth_push_numhl 
3799			.div_done: 
3799					NEXTW 
3799 c3 71 20			jp macro_next 
379c				endm 
# End of macro NEXTW
379c			.MUL: 
379c				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
379c 19				db WORD_SYS_CORE+5             
379d e1 37			dw .MIN            
379f 02				db 1 + 1 
37a0 .. 00			db "*",0              
37a2				endm 
# End of macro CWHEAD
37a2			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37a2				; TODO add floating point number detection 
37a2					if DEBUG_FORTH_WORDS_KEY 
37a2						DMARK "MUL" 
37a2 f5				push af  
37a3 3a b7 37			ld a, (.dmark)  
37a6 32 6e fb			ld (debug_mark),a  
37a9 3a b8 37			ld a, (.dmark+1)  
37ac 32 6f fb			ld (debug_mark+1),a  
37af 3a b9 37			ld a, (.dmark+2)  
37b2 32 70 fb			ld (debug_mark+2),a  
37b5 18 03			jr .pastdmark  
37b7 ..			.dmark: db "MUL"  
37ba f1			.pastdmark: pop af  
37bb			endm  
# End of macro DMARK
37bb						CALLMONITOR 
37bb cd ab 16			call break_point_state  
37be				endm  
# End of macro CALLMONITOR
37be					endif 
37be					FORTH_DSP 
37be cd c5 1e			call macro_forth_dsp 
37c1				endm 
# End of macro FORTH_DSP
37c1					; v5 FORTH_DSP_VALUE 
37c1 7e					ld a,(hl)	; get type of value on TOS 
37c2 fe 02				cp DS_TYPE_INUM  
37c4 28 03				jr z, .mul_inum 
37c6			 
37c6				if FORTH_ENABLE_FLOATMATH 
37c6					jr .mul_done 
37c6			 
37c6				endif 
37c6			 
37c6					NEXTW 
37c6 c3 71 20			jp macro_next 
37c9				endm 
# End of macro NEXTW
37c9			.mul_inum:	 
37c9			 
37c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37c9 cd ff 1e			call macro_dsp_valuehl 
37cc				endm 
# End of macro FORTH_DSP_VALUEHL
37cc			 
37cc e5					push hl 
37cd			 
37cd					; destroy value TOS 
37cd			 
37cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37cd cd b7 1f			call macro_forth_dsp_pop 
37d0				endm 
# End of macro FORTH_DSP_POP
37d0			 
37d0			 
37d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d0 cd ff 1e			call macro_dsp_valuehl 
37d3				endm 
# End of macro FORTH_DSP_VALUEHL
37d3			 
37d3					; one value on hl but move to a get other one back 
37d3			 
37d3 7d					ld a, l 
37d4			 
37d4 d1					pop de 
37d5			 
37d5					; do the mull 
37d5			;		ex de, hl 
37d5			 
37d5 cd 87 0c				call Mult16 
37d8					; save it 
37d8			 
37d8			;		push hl	 
37d8			 
37d8					; 
37d8			 
37d8					; destroy value TOS 
37d8			 
37d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d8 cd b7 1f			call macro_forth_dsp_pop 
37db				endm 
# End of macro FORTH_DSP_POP
37db			 
37db					; TODO push value back onto stack for another op etc 
37db			 
37db			;		pop hl 
37db			 
37db cd 08 1d				call forth_push_numhl 
37de			 
37de			.mul_done: 
37de					NEXTW 
37de c3 71 20			jp macro_next 
37e1				endm 
# End of macro NEXTW
37e1			 
37e1			 
37e1			 
37e1			 
37e1			.MIN: 
37e1				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37e1 49				db WORD_SYS_CORE+53             
37e2 62 38			dw .MAX            
37e4 04				db 3 + 1 
37e5 .. 00			db "MIN",0              
37e9				endm 
# End of macro CWHEAD
37e9			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37e9					if DEBUG_FORTH_WORDS_KEY 
37e9						DMARK "MIN" 
37e9 f5				push af  
37ea 3a fe 37			ld a, (.dmark)  
37ed 32 6e fb			ld (debug_mark),a  
37f0 3a ff 37			ld a, (.dmark+1)  
37f3 32 6f fb			ld (debug_mark+1),a  
37f6 3a 00 38			ld a, (.dmark+2)  
37f9 32 70 fb			ld (debug_mark+2),a  
37fc 18 03			jr .pastdmark  
37fe ..			.dmark: db "MIN"  
3801 f1			.pastdmark: pop af  
3802			endm  
# End of macro DMARK
3802						CALLMONITOR 
3802 cd ab 16			call break_point_state  
3805				endm  
# End of macro CALLMONITOR
3805					endif 
3805					; get u2 
3805			 
3805					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3805 cd ff 1e			call macro_dsp_valuehl 
3808				endm 
# End of macro FORTH_DSP_VALUEHL
3808			 
3808 e5					push hl   ; u2 
3809			 
3809					; destroy value TOS 
3809			 
3809					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3809 cd b7 1f			call macro_forth_dsp_pop 
380c				endm 
# End of macro FORTH_DSP_POP
380c			 
380c					; get u1 
380c			 
380c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380c cd ff 1e			call macro_dsp_valuehl 
380f				endm 
# End of macro FORTH_DSP_VALUEHL
380f			 
380f e5					push hl  ; u1 
3810			 
3810					; destroy value TOS 
3810			 
3810					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3810 cd b7 1f			call macro_forth_dsp_pop 
3813				endm 
# End of macro FORTH_DSP_POP
3813			 
3813 b7			 or a      ;clear carry flag 
3814 e1			  pop hl    ; u1 
3815 d1			  pop de    ; u2 
3816 e5				push hl   ; saved in case hl is lowest 
3817 ed 52		  sbc hl,de 
3819 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
381b			 
381b e1				pop hl 
381c					if DEBUG_FORTH_WORDS 
381c						DMARK "MIN" 
381c f5				push af  
381d 3a 31 38			ld a, (.dmark)  
3820 32 6e fb			ld (debug_mark),a  
3823 3a 32 38			ld a, (.dmark+1)  
3826 32 6f fb			ld (debug_mark+1),a  
3829 3a 33 38			ld a, (.dmark+2)  
382c 32 70 fb			ld (debug_mark+2),a  
382f 18 03			jr .pastdmark  
3831 ..			.dmark: db "MIN"  
3834 f1			.pastdmark: pop af  
3835			endm  
# End of macro DMARK
3835						CALLMONITOR 
3835 cd ab 16			call break_point_state  
3838				endm  
# End of macro CALLMONITOR
3838					endif 
3838 cd 08 1d				call forth_push_numhl 
383b			 
383b				       NEXTW 
383b c3 71 20			jp macro_next 
383e				endm 
# End of macro NEXTW
383e			 
383e			.mincont:  
383e c1				pop bc   ; tidy up 
383f eb				ex de , hl  
3840					if DEBUG_FORTH_WORDS 
3840						DMARK "MI1" 
3840 f5				push af  
3841 3a 55 38			ld a, (.dmark)  
3844 32 6e fb			ld (debug_mark),a  
3847 3a 56 38			ld a, (.dmark+1)  
384a 32 6f fb			ld (debug_mark+1),a  
384d 3a 57 38			ld a, (.dmark+2)  
3850 32 70 fb			ld (debug_mark+2),a  
3853 18 03			jr .pastdmark  
3855 ..			.dmark: db "MI1"  
3858 f1			.pastdmark: pop af  
3859			endm  
# End of macro DMARK
3859						CALLMONITOR 
3859 cd ab 16			call break_point_state  
385c				endm  
# End of macro CALLMONITOR
385c					endif 
385c cd 08 1d				call forth_push_numhl 
385f			 
385f				       NEXTW 
385f c3 71 20			jp macro_next 
3862				endm 
# End of macro NEXTW
3862			.MAX: 
3862				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3862 4a				db WORD_SYS_CORE+54             
3863 e3 38			dw .RND16            
3865 04				db 3 + 1 
3866 .. 00			db "MAX",0              
386a				endm 
# End of macro CWHEAD
386a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
386a					if DEBUG_FORTH_WORDS_KEY 
386a						DMARK "MAX" 
386a f5				push af  
386b 3a 7f 38			ld a, (.dmark)  
386e 32 6e fb			ld (debug_mark),a  
3871 3a 80 38			ld a, (.dmark+1)  
3874 32 6f fb			ld (debug_mark+1),a  
3877 3a 81 38			ld a, (.dmark+2)  
387a 32 70 fb			ld (debug_mark+2),a  
387d 18 03			jr .pastdmark  
387f ..			.dmark: db "MAX"  
3882 f1			.pastdmark: pop af  
3883			endm  
# End of macro DMARK
3883						CALLMONITOR 
3883 cd ab 16			call break_point_state  
3886				endm  
# End of macro CALLMONITOR
3886					endif 
3886					; get u2 
3886			 
3886					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3886 cd ff 1e			call macro_dsp_valuehl 
3889				endm 
# End of macro FORTH_DSP_VALUEHL
3889			 
3889 e5					push hl   ; u2 
388a			 
388a					; destroy value TOS 
388a			 
388a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
388a cd b7 1f			call macro_forth_dsp_pop 
388d				endm 
# End of macro FORTH_DSP_POP
388d			 
388d					; get u1 
388d			 
388d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
388d cd ff 1e			call macro_dsp_valuehl 
3890				endm 
# End of macro FORTH_DSP_VALUEHL
3890			 
3890 e5					push hl  ; u1 
3891			 
3891					; destroy value TOS 
3891			 
3891					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3891 cd b7 1f			call macro_forth_dsp_pop 
3894				endm 
# End of macro FORTH_DSP_POP
3894			 
3894 b7			 or a      ;clear carry flag 
3895 e1			  pop hl    ; u1 
3896 d1			  pop de    ; u2 
3897 e5				push hl   ; saved in case hl is lowest 
3898 ed 52		  sbc hl,de 
389a 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
389c			 
389c e1				pop hl 
389d					if DEBUG_FORTH_WORDS 
389d						DMARK "MAX" 
389d f5				push af  
389e 3a b2 38			ld a, (.dmark)  
38a1 32 6e fb			ld (debug_mark),a  
38a4 3a b3 38			ld a, (.dmark+1)  
38a7 32 6f fb			ld (debug_mark+1),a  
38aa 3a b4 38			ld a, (.dmark+2)  
38ad 32 70 fb			ld (debug_mark+2),a  
38b0 18 03			jr .pastdmark  
38b2 ..			.dmark: db "MAX"  
38b5 f1			.pastdmark: pop af  
38b6			endm  
# End of macro DMARK
38b6						CALLMONITOR 
38b6 cd ab 16			call break_point_state  
38b9				endm  
# End of macro CALLMONITOR
38b9					endif 
38b9 cd 08 1d				call forth_push_numhl 
38bc			 
38bc				       NEXTW 
38bc c3 71 20			jp macro_next 
38bf				endm 
# End of macro NEXTW
38bf			 
38bf			.maxcont:  
38bf c1				pop bc   ; tidy up 
38c0 eb				ex de , hl  
38c1					if DEBUG_FORTH_WORDS 
38c1						DMARK "MA1" 
38c1 f5				push af  
38c2 3a d6 38			ld a, (.dmark)  
38c5 32 6e fb			ld (debug_mark),a  
38c8 3a d7 38			ld a, (.dmark+1)  
38cb 32 6f fb			ld (debug_mark+1),a  
38ce 3a d8 38			ld a, (.dmark+2)  
38d1 32 70 fb			ld (debug_mark+2),a  
38d4 18 03			jr .pastdmark  
38d6 ..			.dmark: db "MA1"  
38d9 f1			.pastdmark: pop af  
38da			endm  
# End of macro DMARK
38da						CALLMONITOR 
38da cd ab 16			call break_point_state  
38dd				endm  
# End of macro CALLMONITOR
38dd					endif 
38dd cd 08 1d				call forth_push_numhl 
38e0				       NEXTW 
38e0 c3 71 20			jp macro_next 
38e3				endm 
# End of macro NEXTW
38e3			 
38e3			.RND16: 
38e3				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38e3 4e				db WORD_SYS_CORE+58             
38e4 12 39			dw .RND8            
38e6 06				db 5 + 1 
38e7 .. 00			db "RND16",0              
38ed				endm 
# End of macro CWHEAD
38ed			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38ed					if DEBUG_FORTH_WORDS_KEY 
38ed						DMARK "R16" 
38ed f5				push af  
38ee 3a 02 39			ld a, (.dmark)  
38f1 32 6e fb			ld (debug_mark),a  
38f4 3a 03 39			ld a, (.dmark+1)  
38f7 32 6f fb			ld (debug_mark+1),a  
38fa 3a 04 39			ld a, (.dmark+2)  
38fd 32 70 fb			ld (debug_mark+2),a  
3900 18 03			jr .pastdmark  
3902 ..			.dmark: db "R16"  
3905 f1			.pastdmark: pop af  
3906			endm  
# End of macro DMARK
3906						CALLMONITOR 
3906 cd ab 16			call break_point_state  
3909				endm  
# End of macro CALLMONITOR
3909					endif 
3909 cd 2b 0c				call prng16  
390c cd 08 1d				call forth_push_numhl 
390f				       NEXTW 
390f c3 71 20			jp macro_next 
3912				endm 
# End of macro NEXTW
3912			.RND8: 
3912				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3912 60				db WORD_SYS_CORE+76             
3913 47 39			dw .RND            
3915 05				db 4 + 1 
3916 .. 00			db "RND8",0              
391b				endm 
# End of macro CWHEAD
391b			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
391b					if DEBUG_FORTH_WORDS_KEY 
391b						DMARK "RN8" 
391b f5				push af  
391c 3a 30 39			ld a, (.dmark)  
391f 32 6e fb			ld (debug_mark),a  
3922 3a 31 39			ld a, (.dmark+1)  
3925 32 6f fb			ld (debug_mark+1),a  
3928 3a 32 39			ld a, (.dmark+2)  
392b 32 70 fb			ld (debug_mark+2),a  
392e 18 03			jr .pastdmark  
3930 ..			.dmark: db "RN8"  
3933 f1			.pastdmark: pop af  
3934			endm  
# End of macro DMARK
3934						CALLMONITOR 
3934 cd ab 16			call break_point_state  
3937				endm  
# End of macro CALLMONITOR
3937					endif 
3937 2a af f8				ld hl,(xrandc) 
393a 23					inc hl 
393b cd 45 0c				call xrnd 
393e 6f					ld l,a	 
393f 26 00				ld h,0 
3941 cd 08 1d				call forth_push_numhl 
3944				       NEXTW 
3944 c3 71 20			jp macro_next 
3947				endm 
# End of macro NEXTW
3947			.RND: 
3947				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3947 60				db WORD_SYS_CORE+76             
3948 4d 3a			dw .ENDMATHS            
394a 04				db 3 + 1 
394b .. 00			db "RND",0              
394f				endm 
# End of macro CWHEAD
394f			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
394f			 
394f					if DEBUG_FORTH_WORDS_KEY 
394f						DMARK "RND" 
394f f5				push af  
3950 3a 64 39			ld a, (.dmark)  
3953 32 6e fb			ld (debug_mark),a  
3956 3a 65 39			ld a, (.dmark+1)  
3959 32 6f fb			ld (debug_mark+1),a  
395c 3a 66 39			ld a, (.dmark+2)  
395f 32 70 fb			ld (debug_mark+2),a  
3962 18 03			jr .pastdmark  
3964 ..			.dmark: db "RND"  
3967 f1			.pastdmark: pop af  
3968			endm  
# End of macro DMARK
3968						CALLMONITOR 
3968 cd ab 16			call break_point_state  
396b				endm  
# End of macro CALLMONITOR
396b					endif 
396b					 
396b					FORTH_DSP_VALUEHL    ; upper range 
396b cd ff 1e			call macro_dsp_valuehl 
396e				endm 
# End of macro FORTH_DSP_VALUEHL
396e			 
396e 22 b3 f8				ld (LFSRSeed), hl	 
3971			 
3971					if DEBUG_FORTH_WORDS 
3971						DMARK "RN1" 
3971 f5				push af  
3972 3a 86 39			ld a, (.dmark)  
3975 32 6e fb			ld (debug_mark),a  
3978 3a 87 39			ld a, (.dmark+1)  
397b 32 6f fb			ld (debug_mark+1),a  
397e 3a 88 39			ld a, (.dmark+2)  
3981 32 70 fb			ld (debug_mark+2),a  
3984 18 03			jr .pastdmark  
3986 ..			.dmark: db "RN1"  
3989 f1			.pastdmark: pop af  
398a			endm  
# End of macro DMARK
398a						CALLMONITOR 
398a cd ab 16			call break_point_state  
398d				endm  
# End of macro CALLMONITOR
398d					endif 
398d					FORTH_DSP_POP 
398d cd b7 1f			call macro_forth_dsp_pop 
3990				endm 
# End of macro FORTH_DSP_POP
3990			 
3990					FORTH_DSP_VALUEHL    ; low range 
3990 cd ff 1e			call macro_dsp_valuehl 
3993				endm 
# End of macro FORTH_DSP_VALUEHL
3993			 
3993					if DEBUG_FORTH_WORDS 
3993						DMARK "RN2" 
3993 f5				push af  
3994 3a a8 39			ld a, (.dmark)  
3997 32 6e fb			ld (debug_mark),a  
399a 3a a9 39			ld a, (.dmark+1)  
399d 32 6f fb			ld (debug_mark+1),a  
39a0 3a aa 39			ld a, (.dmark+2)  
39a3 32 70 fb			ld (debug_mark+2),a  
39a6 18 03			jr .pastdmark  
39a8 ..			.dmark: db "RN2"  
39ab f1			.pastdmark: pop af  
39ac			endm  
# End of macro DMARK
39ac						CALLMONITOR 
39ac cd ab 16			call break_point_state  
39af				endm  
# End of macro CALLMONITOR
39af					endif 
39af 22 b5 f8				ld (LFSRSeed+2), hl 
39b2			 
39b2					FORTH_DSP_POP 
39b2 cd b7 1f			call macro_forth_dsp_pop 
39b5				endm 
# End of macro FORTH_DSP_POP
39b5			 
39b5 e5					push hl 
39b6			 
39b6 e1			.inrange:	pop hl 
39b7 cd 2b 0c				call prng16  
39ba					if DEBUG_FORTH_WORDS 
39ba						DMARK "RN3" 
39ba f5				push af  
39bb 3a cf 39			ld a, (.dmark)  
39be 32 6e fb			ld (debug_mark),a  
39c1 3a d0 39			ld a, (.dmark+1)  
39c4 32 6f fb			ld (debug_mark+1),a  
39c7 3a d1 39			ld a, (.dmark+2)  
39ca 32 70 fb			ld (debug_mark+2),a  
39cd 18 03			jr .pastdmark  
39cf ..			.dmark: db "RN3"  
39d2 f1			.pastdmark: pop af  
39d3			endm  
# End of macro DMARK
39d3						CALLMONITOR 
39d3 cd ab 16			call break_point_state  
39d6				endm  
# End of macro CALLMONITOR
39d6					endif 
39d6					 
39d6					; if the range is 8bit knock out the high byte 
39d6			 
39d6 ed 5b b3 f8			ld de, (LFSRSeed)     ; check high level 
39da			 
39da 3e 00				ld a, 0 
39dc ba					cp d  
39dd 20 1e				jr nz, .hirange 
39df 26 00				ld h, 0   ; knock it down to 8bit 
39e1			 
39e1					if DEBUG_FORTH_WORDS 
39e1						DMARK "RNk" 
39e1 f5				push af  
39e2 3a f6 39			ld a, (.dmark)  
39e5 32 6e fb			ld (debug_mark),a  
39e8 3a f7 39			ld a, (.dmark+1)  
39eb 32 6f fb			ld (debug_mark+1),a  
39ee 3a f8 39			ld a, (.dmark+2)  
39f1 32 70 fb			ld (debug_mark+2),a  
39f4 18 03			jr .pastdmark  
39f6 ..			.dmark: db "RNk"  
39f9 f1			.pastdmark: pop af  
39fa			endm  
# End of macro DMARK
39fa						CALLMONITOR 
39fa cd ab 16			call break_point_state  
39fd				endm  
# End of macro CALLMONITOR
39fd					endif 
39fd			.hirange:   
39fd e5					push hl  
39fe b7					or a  
39ff ed 52		                sbc hl, de 
3a01			 
3a01					;call cmp16 
3a01			 
3a01 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a03 e1					pop hl 
3a04 e5					push hl 
3a05			 
3a05					if DEBUG_FORTH_WORDS 
3a05						DMARK "RN4" 
3a05 f5				push af  
3a06 3a 1a 3a			ld a, (.dmark)  
3a09 32 6e fb			ld (debug_mark),a  
3a0c 3a 1b 3a			ld a, (.dmark+1)  
3a0f 32 6f fb			ld (debug_mark+1),a  
3a12 3a 1c 3a			ld a, (.dmark+2)  
3a15 32 70 fb			ld (debug_mark+2),a  
3a18 18 03			jr .pastdmark  
3a1a ..			.dmark: db "RN4"  
3a1d f1			.pastdmark: pop af  
3a1e			endm  
# End of macro DMARK
3a1e						CALLMONITOR 
3a1e cd ab 16			call break_point_state  
3a21				endm  
# End of macro CALLMONITOR
3a21					endif 
3a21 ed 5b b5 f8			ld de, (LFSRSeed+2)   ; check low range 
3a25					;call cmp16 
3a25				 
3a25 b7					or a  
3a26 ed 52		                sbc hl, de 
3a28 38 8c				jr c, .inrange 
3a2a			 
3a2a e1					pop hl 
3a2b					 
3a2b					if DEBUG_FORTH_WORDS 
3a2b						DMARK "RNd" 
3a2b f5				push af  
3a2c 3a 40 3a			ld a, (.dmark)  
3a2f 32 6e fb			ld (debug_mark),a  
3a32 3a 41 3a			ld a, (.dmark+1)  
3a35 32 6f fb			ld (debug_mark+1),a  
3a38 3a 42 3a			ld a, (.dmark+2)  
3a3b 32 70 fb			ld (debug_mark+2),a  
3a3e 18 03			jr .pastdmark  
3a40 ..			.dmark: db "RNd"  
3a43 f1			.pastdmark: pop af  
3a44			endm  
# End of macro DMARK
3a44						CALLMONITOR 
3a44 cd ab 16			call break_point_state  
3a47				endm  
# End of macro CALLMONITOR
3a47					endif 
3a47			 
3a47			 
3a47 cd 08 1d				call forth_push_numhl 
3a4a				       NEXTW 
3a4a c3 71 20			jp macro_next 
3a4d				endm 
# End of macro NEXTW
3a4d			 
3a4d			.ENDMATHS: 
3a4d			 
3a4d			; eof 
3a4d			 
# End of file forth_words_maths.asm
3a4d			include "forth_words_display.asm" 
3a4d			 
3a4d			; | ## Display Words 
3a4d			 
3a4d			.INFO: 
3a4d			 
3a4d				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a4d 62				db WORD_SYS_CORE+78             
3a4e 6a 3a			dw .ATP            
3a50 05				db 4 + 1 
3a51 .. 00			db "INFO",0              
3a56				endm 
# End of macro CWHEAD
3a56			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a56					FORTH_DSP_VALUEHL 
3a56 cd ff 1e			call macro_dsp_valuehl 
3a59				endm 
# End of macro FORTH_DSP_VALUEHL
3a59			 
3a59					FORTH_DSP_POP 
3a59 cd b7 1f			call macro_forth_dsp_pop 
3a5c				endm 
# End of macro FORTH_DSP_POP
3a5c			 
3a5c e5					push hl 
3a5d			 
3a5d					FORTH_DSP_VALUEHL 
3a5d cd ff 1e			call macro_dsp_valuehl 
3a60				endm 
# End of macro FORTH_DSP_VALUEHL
3a60			 
3a60					FORTH_DSP_POP 
3a60 cd b7 1f			call macro_forth_dsp_pop 
3a63				endm 
# End of macro FORTH_DSP_POP
3a63			 
3a63 d1					pop de 
3a64			 
3a64 cd 61 0a				call info_panel 
3a67			 
3a67			 
3a67					NEXTW 
3a67 c3 71 20			jp macro_next 
3a6a				endm 
# End of macro NEXTW
3a6a			.ATP: 
3a6a				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a6a 62				db WORD_SYS_CORE+78             
3a6b e1 3a			dw .FB            
3a6d 04				db 3 + 1 
3a6e .. 00			db "AT?",0              
3a72				endm 
# End of macro CWHEAD
3a72			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a72					if DEBUG_FORTH_WORDS_KEY 
3a72						DMARK "AT?" 
3a72 f5				push af  
3a73 3a 87 3a			ld a, (.dmark)  
3a76 32 6e fb			ld (debug_mark),a  
3a79 3a 88 3a			ld a, (.dmark+1)  
3a7c 32 6f fb			ld (debug_mark+1),a  
3a7f 3a 89 3a			ld a, (.dmark+2)  
3a82 32 70 fb			ld (debug_mark+2),a  
3a85 18 03			jr .pastdmark  
3a87 ..			.dmark: db "AT?"  
3a8a f1			.pastdmark: pop af  
3a8b			endm  
# End of macro DMARK
3a8b						CALLMONITOR 
3a8b cd ab 16			call break_point_state  
3a8e				endm  
# End of macro CALLMONITOR
3a8e					endif 
3a8e 3a 3d f8				ld a, (f_cursor_ptr) 
3a91			 
3a91			if DEBUG_FORTH_WORDS 
3a91				DMARK "AT?" 
3a91 f5				push af  
3a92 3a a6 3a			ld a, (.dmark)  
3a95 32 6e fb			ld (debug_mark),a  
3a98 3a a7 3a			ld a, (.dmark+1)  
3a9b 32 6f fb			ld (debug_mark+1),a  
3a9e 3a a8 3a			ld a, (.dmark+2)  
3aa1 32 70 fb			ld (debug_mark+2),a  
3aa4 18 03			jr .pastdmark  
3aa6 ..			.dmark: db "AT?"  
3aa9 f1			.pastdmark: pop af  
3aaa			endm  
# End of macro DMARK
3aaa				CALLMONITOR 
3aaa cd ab 16			call break_point_state  
3aad				endm  
# End of macro CALLMONITOR
3aad			endif	 
3aad					; count the number of rows 
3aad			 
3aad 06 00				ld b, 0 
3aaf 4f			.atpr:		ld c, a    ; save in case we go below zero 
3ab0 d6 28				sub display_cols 
3ab2 f2 b8 3a				jp p, .atprunder 
3ab5 04					inc b 
3ab6 18 f7				jr .atpr 
3ab8			.atprunder:	 
3ab8			if DEBUG_FORTH_WORDS 
3ab8				DMARK "A?2" 
3ab8 f5				push af  
3ab9 3a cd 3a			ld a, (.dmark)  
3abc 32 6e fb			ld (debug_mark),a  
3abf 3a ce 3a			ld a, (.dmark+1)  
3ac2 32 6f fb			ld (debug_mark+1),a  
3ac5 3a cf 3a			ld a, (.dmark+2)  
3ac8 32 70 fb			ld (debug_mark+2),a  
3acb 18 03			jr .pastdmark  
3acd ..			.dmark: db "A?2"  
3ad0 f1			.pastdmark: pop af  
3ad1			endm  
# End of macro DMARK
3ad1				CALLMONITOR 
3ad1 cd ab 16			call break_point_state  
3ad4				endm  
# End of macro CALLMONITOR
3ad4			endif	 
3ad4 26 00				ld h, 0 
3ad6 69					ld l, c 
3ad7 cd 08 1d				call forth_push_numhl 
3ada 68					ld l, b  
3adb cd 08 1d				call forth_push_numhl 
3ade			 
3ade			 
3ade				NEXTW 
3ade c3 71 20			jp macro_next 
3ae1				endm 
# End of macro NEXTW
3ae1			 
3ae1			.FB: 
3ae1				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3ae1 1b				db WORD_SYS_CORE+7             
3ae2 2f 3b			dw .EMIT            
3ae4 03				db 2 + 1 
3ae5 .. 00			db "FB",0              
3ae8				endm 
# End of macro CWHEAD
3ae8			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ae8			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ae8			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ae8			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ae8					if DEBUG_FORTH_WORDS_KEY 
3ae8						DMARK "FB." 
3ae8 f5				push af  
3ae9 3a fd 3a			ld a, (.dmark)  
3aec 32 6e fb			ld (debug_mark),a  
3aef 3a fe 3a			ld a, (.dmark+1)  
3af2 32 6f fb			ld (debug_mark+1),a  
3af5 3a ff 3a			ld a, (.dmark+2)  
3af8 32 70 fb			ld (debug_mark+2),a  
3afb 18 03			jr .pastdmark  
3afd ..			.dmark: db "FB."  
3b00 f1			.pastdmark: pop af  
3b01			endm  
# End of macro DMARK
3b01						CALLMONITOR 
3b01 cd ab 16			call break_point_state  
3b04				endm  
# End of macro CALLMONITOR
3b04					endif 
3b04			 
3b04					FORTH_DSP_VALUEHL 
3b04 cd ff 1e			call macro_dsp_valuehl 
3b07				endm 
# End of macro FORTH_DSP_VALUEHL
3b07			 
3b07 7d					ld a, l 
3b08 fe 01				cp 1 
3b0a 20 05				jr nz, .fbn1 
3b0c 21 13 fa				ld hl, display_fb1 
3b0f 18 15				jr .fbset 
3b11 fe 02		.fbn1:		cp 2 
3b13 20 05				jr nz, .fbn2 
3b15 21 d1 f8				ld hl, display_fb2 
3b18 18 0c				jr .fbset 
3b1a fe 03		.fbn2:		cp 3 
3b1c 20 05				jr nz, .fbn3 
3b1e 21 72 f9				ld hl, display_fb3 
3b21 18 03				jr .fbset 
3b23			.fbn3:		 ; if invalid number select first 
3b23 21 13 fa				ld hl, display_fb1 
3b26 22 cf f8		.fbset:		ld (display_fb_active), hl 
3b29			 
3b29					FORTH_DSP_POP 
3b29 cd b7 1f			call macro_forth_dsp_pop 
3b2c				endm 
# End of macro FORTH_DSP_POP
3b2c			 
3b2c					NEXTW 
3b2c c3 71 20			jp macro_next 
3b2f				endm 
# End of macro NEXTW
3b2f			 
3b2f			 
3b2f			.EMIT: 
3b2f				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b2f 1b				db WORD_SYS_CORE+7             
3b30 80 3b			dw .DOTH            
3b32 05				db 4 + 1 
3b33 .. 00			db "EMIT",0              
3b38				endm 
# End of macro CWHEAD
3b38			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b38					; get value off TOS and display it 
3b38			 
3b38					if DEBUG_FORTH_WORDS_KEY 
3b38						DMARK "EMT" 
3b38 f5				push af  
3b39 3a 4d 3b			ld a, (.dmark)  
3b3c 32 6e fb			ld (debug_mark),a  
3b3f 3a 4e 3b			ld a, (.dmark+1)  
3b42 32 6f fb			ld (debug_mark+1),a  
3b45 3a 4f 3b			ld a, (.dmark+2)  
3b48 32 70 fb			ld (debug_mark+2),a  
3b4b 18 03			jr .pastdmark  
3b4d ..			.dmark: db "EMT"  
3b50 f1			.pastdmark: pop af  
3b51			endm  
# End of macro DMARK
3b51						CALLMONITOR 
3b51 cd ab 16			call break_point_state  
3b54				endm  
# End of macro CALLMONITOR
3b54					endif 
3b54			 
3b54					FORTH_DSP_VALUEHL 
3b54 cd ff 1e			call macro_dsp_valuehl 
3b57				endm 
# End of macro FORTH_DSP_VALUEHL
3b57			 
3b57 7d					ld a,l 
3b58			 
3b58					; TODO write to display 
3b58			 
3b58 32 12 f0				ld (os_input), a 
3b5b 3e 00				ld a, 0 
3b5d 32 13 f0				ld (os_input+1), a 
3b60					 
3b60 3a 3d f8				ld a, (f_cursor_ptr) 
3b63 11 12 f0				ld de, os_input 
3b66 cd e3 0a				call str_at_display 
3b69			 
3b69			 
3b69 3a 1b f8				ld a,(cli_autodisplay) 
3b6c fe 00				cp 0 
3b6e 28 03				jr z, .enoupdate 
3b70 cd f3 0a						call update_display 
3b73					.enoupdate: 
3b73			 
3b73 3a 3d f8				ld a, (f_cursor_ptr) 
3b76 3c					inc a 
3b77 32 3d f8				ld (f_cursor_ptr), a   ; save new pos 
3b7a			 
3b7a			 
3b7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b7a cd b7 1f			call macro_forth_dsp_pop 
3b7d				endm 
# End of macro FORTH_DSP_POP
3b7d			  
3b7d			 
3b7d					NEXTW 
3b7d c3 71 20			jp macro_next 
3b80				endm 
# End of macro NEXTW
3b80			.DOTH: 
3b80				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b80 1c				db WORD_SYS_CORE+8             
3b81 b0 3b			dw .DOTF            
3b83 03				db 2 + 1 
3b84 .. 00			db ".-",0              
3b87				endm 
# End of macro CWHEAD
3b87			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b87					; get value off TOS and display it 
3b87					if DEBUG_FORTH_WORDS_KEY 
3b87						DMARK "DTD" 
3b87 f5				push af  
3b88 3a 9c 3b			ld a, (.dmark)  
3b8b 32 6e fb			ld (debug_mark),a  
3b8e 3a 9d 3b			ld a, (.dmark+1)  
3b91 32 6f fb			ld (debug_mark+1),a  
3b94 3a 9e 3b			ld a, (.dmark+2)  
3b97 32 70 fb			ld (debug_mark+2),a  
3b9a 18 03			jr .pastdmark  
3b9c ..			.dmark: db "DTD"  
3b9f f1			.pastdmark: pop af  
3ba0			endm  
# End of macro DMARK
3ba0						CALLMONITOR 
3ba0 cd ab 16			call break_point_state  
3ba3				endm  
# End of macro CALLMONITOR
3ba3					endif 
3ba3 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ba5 3e 00			ld a, 0 
3ba7 32 1c f8			ld (cli_mvdot), a 
3baa c3 07 3c			jp .dotgo 
3bad				NEXTW 
3bad c3 71 20			jp macro_next 
3bb0				endm 
# End of macro NEXTW
3bb0			.DOTF: 
3bb0				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bb0 1c				db WORD_SYS_CORE+8             
3bb1 de 3b			dw .DOT            
3bb3 03				db 2 + 1 
3bb4 .. 00			db ".>",0              
3bb7				endm 
# End of macro CWHEAD
3bb7			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3bb7					; get value off TOS and display it 
3bb7			        ; TODO BUG adds extra spaces 
3bb7			        ; TODO BUG handle numerics? 
3bb7					if DEBUG_FORTH_WORDS_KEY 
3bb7						DMARK "DTC" 
3bb7 f5				push af  
3bb8 3a cc 3b			ld a, (.dmark)  
3bbb 32 6e fb			ld (debug_mark),a  
3bbe 3a cd 3b			ld a, (.dmark+1)  
3bc1 32 6f fb			ld (debug_mark+1),a  
3bc4 3a ce 3b			ld a, (.dmark+2)  
3bc7 32 70 fb			ld (debug_mark+2),a  
3bca 18 03			jr .pastdmark  
3bcc ..			.dmark: db "DTC"  
3bcf f1			.pastdmark: pop af  
3bd0			endm  
# End of macro DMARK
3bd0						CALLMONITOR 
3bd0 cd ab 16			call break_point_state  
3bd3				endm  
# End of macro CALLMONITOR
3bd3					endif 
3bd3 3e 01			ld a, 1 
3bd5 32 1c f8			ld (cli_mvdot), a 
3bd8 c3 07 3c			jp .dotgo 
3bdb				NEXTW 
3bdb c3 71 20			jp macro_next 
3bde				endm 
# End of macro NEXTW
3bde			 
3bde			.DOT: 
3bde				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bde 1c				db WORD_SYS_CORE+8             
3bdf 6a 3c			dw .CLS            
3be1 02				db 1 + 1 
3be2 .. 00			db ".",0              
3be4				endm 
# End of macro CWHEAD
3be4			        ; | . ( u -- ) Display TOS | DONE 
3be4					; get value off TOS and display it 
3be4			 
3be4					if DEBUG_FORTH_WORDS_KEY 
3be4						DMARK "DOT" 
3be4 f5				push af  
3be5 3a f9 3b			ld a, (.dmark)  
3be8 32 6e fb			ld (debug_mark),a  
3beb 3a fa 3b			ld a, (.dmark+1)  
3bee 32 6f fb			ld (debug_mark+1),a  
3bf1 3a fb 3b			ld a, (.dmark+2)  
3bf4 32 70 fb			ld (debug_mark+2),a  
3bf7 18 03			jr .pastdmark  
3bf9 ..			.dmark: db "DOT"  
3bfc f1			.pastdmark: pop af  
3bfd			endm  
# End of macro DMARK
3bfd						CALLMONITOR 
3bfd cd ab 16			call break_point_state  
3c00				endm  
# End of macro CALLMONITOR
3c00					endif 
3c00 3e 00			ld a, 0 
3c02 32 1c f8			ld (cli_mvdot), a 
3c05 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c07				 
3c07			 
3c07			.dotgo: 
3c07			 
3c07			; move up type to on stack for parserv5 
3c07					FORTH_DSP 
3c07 cd c5 1e			call macro_forth_dsp 
3c0a				endm 
# End of macro FORTH_DSP
3c0a				;FORTH_DSP_VALUE  
3c0a			 
3c0a			if DEBUG_FORTH_DOT 
3c0a				DMARK "DOT" 
3c0a				CALLMONITOR 
3c0a			endif	 
3c0a			;		.print: 
3c0a			 
3c0a 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c0b 23				inc hl   ; position to the actual value 
3c0c fe 01			cp DS_TYPE_STR 
3c0e 20 06			jr nz, .dotnum1  
3c10			 
3c10			; display string 
3c10				FORTH_DSP_VALUE  
3c10 cd e8 1e			call macro_forth_dsp_value 
3c13				endm 
# End of macro FORTH_DSP_VALUE
3c13 eb				ex de,hl 
3c14 18 11			jr .dotwrite 
3c16			 
3c16			.dotnum1: 
3c16 fe 02			cp DS_TYPE_INUM 
3c18 20 0c			jr nz, .dotflot 
3c1a			 
3c1a			 
3c1a			; display number 
3c1a			 
3c1a			;	push hl 
3c1a			;	call clear_display 
3c1a			;	pop hl 
3c1a			 
3c1a 5e				ld e, (hl) 
3c1b 23				inc hl 
3c1c 56				ld d, (hl) 
3c1d 21 14 ee			ld hl, scratch 
3c20			if DEBUG_FORTH_DOT 
3c20				DMARK "DT1" 
3c20				CALLMONITOR 
3c20			endif	 
3c20			 
3c20 cd 11 11			call uitoa_16 
3c23 eb				ex de,hl 
3c24			 
3c24			if DEBUG_FORTH_DOT 
3c24				DMARK "DT2" 
3c24				CALLMONITOR 
3c24			endif	 
3c24			 
3c24			;	ld de, os_word_scratch 
3c24 18 01			jr .dotwrite 
3c26			 
3c26 00			.dotflot:   nop 
3c27			; TODO print floating point number 
3c27			 
3c27			.dotwrite:		 
3c27			 
3c27					; if c is set then set all '-' to spaces 
3c27					; need to also take into account .>  
3c27			 
3c27 3e 01				ld a, 1 
3c29 b9					cp c 
3c2a 20 13				jr nz, .nodashswap 
3c2c			 
3c2c					; DE has the string to write, working with HL 
3c2c			 
3c2c 06 ff				ld b, 255 
3c2e d5					push de 
3c2f e1					pop hl 
3c30			 
3c30			if DEBUG_FORTH_DOT 
3c30				DMARK "DT-" 
3c30				CALLMONITOR 
3c30			endif	 
3c30 7e			.dashscan:	ld a, (hl) 
3c31 fe 00				cp 0 
3c33 28 0a				jr z, .nodashswap 
3c35 fe 2d				cp '-' 
3c37 20 03				jr nz, .dashskip 
3c39 3e 20				ld a, ' ' 
3c3b 77					ld (hl), a 
3c3c 23			.dashskip:	inc hl 
3c3d			if DEBUG_FORTH_DOT 
3c3d				DMARK "D-2" 
3c3d				CALLMONITOR 
3c3d			endif	 
3c3d 10 f1				djnz .dashscan 
3c3f			 
3c3f			if DEBUG_FORTH_DOT 
3c3f				DMARK "D-1" 
3c3f				CALLMONITOR 
3c3f			endif	 
3c3f			 
3c3f			.nodashswap: 
3c3f			 
3c3f e5					push hl   ; save string start in case we need to advance print 
3c40			 
3c40 3a 3d f8				ld a, (f_cursor_ptr) 
3c43 cd e3 0a				call str_at_display 
3c46 3a 1b f8				ld a,(cli_autodisplay) 
3c49 fe 00				cp 0 
3c4b 28 03				jr z, .noupdate 
3c4d cd f3 0a						call update_display 
3c50					.noupdate: 
3c50			 
3c50			 
3c50					; see if we need to advance the print position 
3c50			 
3c50 e1					pop hl   ; get back string 
3c51			 
3c51 3a 1c f8				ld a, (cli_mvdot) 
3c54			if DEBUG_FORTH_DOT 
3c54					ld e,a 
3c54				DMARK "D>1" 
3c54				CALLMONITOR 
3c54			endif	 
3c54 fe 00				cp 0 
3c56 28 0c				jr z, .noadv 
3c58					; yes, lets advance the print position 
3c58 3e 00				ld a, 0 
3c5a cd 6d 11				call strlent 
3c5d 3a 3d f8				ld a, (f_cursor_ptr) 
3c60 85					add a,l 
3c61					;call addatohl 
3c61					;ld a, l 
3c61 32 3d f8				ld (f_cursor_ptr), a   ; save new pos 
3c64			 
3c64			if DEBUG_FORTH_DOT 
3c64				DMARK "D->" 
3c64				CALLMONITOR 
3c64			endif	 
3c64			 
3c64			.noadv:	 
3c64			 
3c64					if DEBUG_FORTH_DOT_WAIT 
3c64							call next_page_prompt 
3c64					endif	 
3c64			; TODO this pop off the stack causes a crash. i dont know why 
3c64			 
3c64			 
3c64			if DEBUG_FORTH_DOT 
3c64				DMARK "DTh" 
3c64				CALLMONITOR 
3c64			endif	 
3c64			 
3c64					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c64 cd b7 1f			call macro_forth_dsp_pop 
3c67				endm 
# End of macro FORTH_DSP_POP
3c67			 
3c67			if DEBUG_FORTH_DOT 
3c67				DMARK "DTi" 
3c67				CALLMONITOR 
3c67			endif	 
3c67			 
3c67			 
3c67					NEXTW 
3c67 c3 71 20			jp macro_next 
3c6a				endm 
# End of macro NEXTW
3c6a			 
3c6a			.CLS: 
3c6a				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c6a 35				db WORD_SYS_CORE+33             
3c6b 97 3c			dw .DRAW            
3c6d 04				db 3 + 1 
3c6e .. 00			db "CLS",0              
3c72				endm 
# End of macro CWHEAD
3c72			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c72					if DEBUG_FORTH_WORDS_KEY 
3c72						DMARK "CLS" 
3c72 f5				push af  
3c73 3a 87 3c			ld a, (.dmark)  
3c76 32 6e fb			ld (debug_mark),a  
3c79 3a 88 3c			ld a, (.dmark+1)  
3c7c 32 6f fb			ld (debug_mark+1),a  
3c7f 3a 89 3c			ld a, (.dmark+2)  
3c82 32 70 fb			ld (debug_mark+2),a  
3c85 18 03			jr .pastdmark  
3c87 ..			.dmark: db "CLS"  
3c8a f1			.pastdmark: pop af  
3c8b			endm  
# End of macro DMARK
3c8b						CALLMONITOR 
3c8b cd ab 16			call break_point_state  
3c8e				endm  
# End of macro CALLMONITOR
3c8e					endif 
3c8e cd d0 0a				call clear_display 
3c91 c3 a5 3d				jp .home		; and home cursor 
3c94					NEXTW 
3c94 c3 71 20			jp macro_next 
3c97				endm 
# End of macro NEXTW
3c97			 
3c97			.DRAW: 
3c97				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3c97 36				db WORD_SYS_CORE+34             
3c98 c2 3c			dw .DUMP            
3c9a 05				db 4 + 1 
3c9b .. 00			db "DRAW",0              
3ca0				endm 
# End of macro CWHEAD
3ca0			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3ca0					if DEBUG_FORTH_WORDS_KEY 
3ca0						DMARK "DRW" 
3ca0 f5				push af  
3ca1 3a b5 3c			ld a, (.dmark)  
3ca4 32 6e fb			ld (debug_mark),a  
3ca7 3a b6 3c			ld a, (.dmark+1)  
3caa 32 6f fb			ld (debug_mark+1),a  
3cad 3a b7 3c			ld a, (.dmark+2)  
3cb0 32 70 fb			ld (debug_mark+2),a  
3cb3 18 03			jr .pastdmark  
3cb5 ..			.dmark: db "DRW"  
3cb8 f1			.pastdmark: pop af  
3cb9			endm  
# End of macro DMARK
3cb9						CALLMONITOR 
3cb9 cd ab 16			call break_point_state  
3cbc				endm  
# End of macro CALLMONITOR
3cbc					endif 
3cbc cd f3 0a				call update_display 
3cbf					NEXTW 
3cbf c3 71 20			jp macro_next 
3cc2				endm 
# End of macro NEXTW
3cc2			 
3cc2			.DUMP: 
3cc2				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3cc2 37				db WORD_SYS_CORE+35             
3cc3 fa 3c			dw .CDUMP            
3cc5 05				db 4 + 1 
3cc6 .. 00			db "DUMP",0              
3ccb				endm 
# End of macro CWHEAD
3ccb			; | DUMP ( x -- ) With address x display dump   | DONE 
3ccb			; TODO pop address to use off of the stack 
3ccb					if DEBUG_FORTH_WORDS_KEY 
3ccb						DMARK "DUM" 
3ccb f5				push af  
3ccc 3a e0 3c			ld a, (.dmark)  
3ccf 32 6e fb			ld (debug_mark),a  
3cd2 3a e1 3c			ld a, (.dmark+1)  
3cd5 32 6f fb			ld (debug_mark+1),a  
3cd8 3a e2 3c			ld a, (.dmark+2)  
3cdb 32 70 fb			ld (debug_mark+2),a  
3cde 18 03			jr .pastdmark  
3ce0 ..			.dmark: db "DUM"  
3ce3 f1			.pastdmark: pop af  
3ce4			endm  
# End of macro DMARK
3ce4						CALLMONITOR 
3ce4 cd ab 16			call break_point_state  
3ce7				endm  
# End of macro CALLMONITOR
3ce7					endif 
3ce7 cd d0 0a				call clear_display 
3cea			 
3cea					; get address 
3cea			 
3cea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cea cd ff 1e			call macro_dsp_valuehl 
3ced				endm 
# End of macro FORTH_DSP_VALUEHL
3ced				 
3ced					; save it for cdump 
3ced			 
3ced 22 37 f1				ld (os_cur_ptr),hl 
3cf0			 
3cf0					; destroy value TOS 
3cf0			 
3cf0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cf0 cd b7 1f			call macro_forth_dsp_pop 
3cf3				endm 
# End of macro FORTH_DSP_POP
3cf3			 
3cf3 cd 88 1b				call dumpcont	; skip old style of param parsing	 
3cf6 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3cf7					NEXTW 
3cf7 c3 71 20			jp macro_next 
3cfa				endm 
# End of macro NEXTW
3cfa			.CDUMP: 
3cfa				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3cfa 38				db WORD_SYS_CORE+36             
3cfb 2a 3d			dw .DAT            
3cfd 06				db 5 + 1 
3cfe .. 00			db "CDUMP",0              
3d04				endm 
# End of macro CWHEAD
3d04			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3d04					if DEBUG_FORTH_WORDS_KEY 
3d04						DMARK "CDP" 
3d04 f5				push af  
3d05 3a 19 3d			ld a, (.dmark)  
3d08 32 6e fb			ld (debug_mark),a  
3d0b 3a 1a 3d			ld a, (.dmark+1)  
3d0e 32 6f fb			ld (debug_mark+1),a  
3d11 3a 1b 3d			ld a, (.dmark+2)  
3d14 32 70 fb			ld (debug_mark+2),a  
3d17 18 03			jr .pastdmark  
3d19 ..			.dmark: db "CDP"  
3d1c f1			.pastdmark: pop af  
3d1d			endm  
# End of macro DMARK
3d1d						CALLMONITOR 
3d1d cd ab 16			call break_point_state  
3d20				endm  
# End of macro CALLMONITOR
3d20					endif 
3d20 cd d0 0a				call clear_display 
3d23 cd 88 1b				call dumpcont	 
3d26 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3d27					NEXTW 
3d27 c3 71 20			jp macro_next 
3d2a				endm 
# End of macro NEXTW
3d2a			 
3d2a			 
3d2a			 
3d2a			 
3d2a			.DAT: 
3d2a				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3d2a 3d				db WORD_SYS_CORE+41             
3d2b 80 3d			dw .HOME            
3d2d 03				db 2 + 1 
3d2e .. 00			db "AT",0              
3d31				endm 
# End of macro CWHEAD
3d31			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3d31					if DEBUG_FORTH_WORDS_KEY 
3d31						DMARK "AT." 
3d31 f5				push af  
3d32 3a 46 3d			ld a, (.dmark)  
3d35 32 6e fb			ld (debug_mark),a  
3d38 3a 47 3d			ld a, (.dmark+1)  
3d3b 32 6f fb			ld (debug_mark+1),a  
3d3e 3a 48 3d			ld a, (.dmark+2)  
3d41 32 70 fb			ld (debug_mark+2),a  
3d44 18 03			jr .pastdmark  
3d46 ..			.dmark: db "AT."  
3d49 f1			.pastdmark: pop af  
3d4a			endm  
# End of macro DMARK
3d4a						CALLMONITOR 
3d4a cd ab 16			call break_point_state  
3d4d				endm  
# End of macro CALLMONITOR
3d4d					endif 
3d4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d4d cd ff 1e			call macro_dsp_valuehl 
3d50				endm 
# End of macro FORTH_DSP_VALUEHL
3d50			 
3d50			 
3d50					; TODO save cursor row 
3d50 7d					ld a,l 
3d51 fe 02				cp 2 
3d53 20 04				jr nz, .crow3 
3d55 3e 28				ld a, display_row_2 
3d57 18 12				jr .ccol1 
3d59 fe 03		.crow3:		cp 3 
3d5b 20 04				jr nz, .crow4 
3d5d 3e 50				ld a, display_row_3 
3d5f 18 0a				jr .ccol1 
3d61 fe 04		.crow4:		cp 4 
3d63 20 04				jr nz, .crow1 
3d65 3e 78				ld a, display_row_4 
3d67 18 02				jr .ccol1 
3d69 3e 00		.crow1:		ld a,display_row_1 
3d6b f5			.ccol1:		push af			; got row offset 
3d6c 6f					ld l,a 
3d6d 26 00				ld h,0 
3d6f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d6f cd b7 1f			call macro_forth_dsp_pop 
3d72				endm 
# End of macro FORTH_DSP_POP
3d72					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d72 cd ff 1e			call macro_dsp_valuehl 
3d75				endm 
# End of macro FORTH_DSP_VALUEHL
3d75					; TODO save cursor col 
3d75 f1					pop af 
3d76 85					add l		; add col offset 
3d77 32 3d f8				ld (f_cursor_ptr), a 
3d7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d7a cd b7 1f			call macro_forth_dsp_pop 
3d7d				endm 
# End of macro FORTH_DSP_POP
3d7d			 
3d7d					; calculate  
3d7d			 
3d7d					NEXTW 
3d7d c3 71 20			jp macro_next 
3d80				endm 
# End of macro NEXTW
3d80			 
3d80			 
3d80			.HOME: 
3d80				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d80 41				db WORD_SYS_CORE+45             
3d81 ad 3d			dw .SPACE            
3d83 05				db 4 + 1 
3d84 .. 00			db "HOME",0              
3d89				endm 
# End of macro CWHEAD
3d89			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d89					if DEBUG_FORTH_WORDS_KEY 
3d89						DMARK "HOM" 
3d89 f5				push af  
3d8a 3a 9e 3d			ld a, (.dmark)  
3d8d 32 6e fb			ld (debug_mark),a  
3d90 3a 9f 3d			ld a, (.dmark+1)  
3d93 32 6f fb			ld (debug_mark+1),a  
3d96 3a a0 3d			ld a, (.dmark+2)  
3d99 32 70 fb			ld (debug_mark+2),a  
3d9c 18 03			jr .pastdmark  
3d9e ..			.dmark: db "HOM"  
3da1 f1			.pastdmark: pop af  
3da2			endm  
# End of macro DMARK
3da2						CALLMONITOR 
3da2 cd ab 16			call break_point_state  
3da5				endm  
# End of macro CALLMONITOR
3da5					endif 
3da5 3e 00		.home:		ld a, 0		; and home cursor 
3da7 32 3d f8				ld (f_cursor_ptr), a 
3daa					NEXTW 
3daa c3 71 20			jp macro_next 
3dad				endm 
# End of macro NEXTW
3dad			 
3dad			 
3dad			.SPACE: 
3dad				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3dad 46				db WORD_SYS_CORE+50             
3dae db 3d			dw .SPACES            
3db0 03				db 2 + 1 
3db1 .. 00			db "BL",0              
3db4				endm 
# End of macro CWHEAD
3db4			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3db4					if DEBUG_FORTH_WORDS_KEY 
3db4						DMARK "BL." 
3db4 f5				push af  
3db5 3a c9 3d			ld a, (.dmark)  
3db8 32 6e fb			ld (debug_mark),a  
3dbb 3a ca 3d			ld a, (.dmark+1)  
3dbe 32 6f fb			ld (debug_mark+1),a  
3dc1 3a cb 3d			ld a, (.dmark+2)  
3dc4 32 70 fb			ld (debug_mark+2),a  
3dc7 18 03			jr .pastdmark  
3dc9 ..			.dmark: db "BL."  
3dcc f1			.pastdmark: pop af  
3dcd			endm  
# End of macro DMARK
3dcd						CALLMONITOR 
3dcd cd ab 16			call break_point_state  
3dd0				endm  
# End of macro CALLMONITOR
3dd0					endif 
3dd0 21 d9 3d				ld hl, .blstr 
3dd3 cd 76 1d				call forth_push_str 
3dd6					 
3dd6				       NEXTW 
3dd6 c3 71 20			jp macro_next 
3dd9				endm 
# End of macro NEXTW
3dd9			 
3dd9 .. 00		.blstr: db " ", 0 
3ddb			 
3ddb			.SPACES: 
3ddb				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3ddb 47				db WORD_SYS_CORE+51             
3ddc 76 3e			dw .SCROLL            
3dde 07				db 6 + 1 
3ddf .. 00			db "SPACES",0              
3de6				endm 
# End of macro CWHEAD
3de6			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3de6					if DEBUG_FORTH_WORDS_KEY 
3de6						DMARK "SPS" 
3de6 f5				push af  
3de7 3a fb 3d			ld a, (.dmark)  
3dea 32 6e fb			ld (debug_mark),a  
3ded 3a fc 3d			ld a, (.dmark+1)  
3df0 32 6f fb			ld (debug_mark+1),a  
3df3 3a fd 3d			ld a, (.dmark+2)  
3df6 32 70 fb			ld (debug_mark+2),a  
3df9 18 03			jr .pastdmark  
3dfb ..			.dmark: db "SPS"  
3dfe f1			.pastdmark: pop af  
3dff			endm  
# End of macro DMARK
3dff						CALLMONITOR 
3dff cd ab 16			call break_point_state  
3e02				endm  
# End of macro CALLMONITOR
3e02					endif 
3e02			 
3e02			 
3e02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e02 cd ff 1e			call macro_dsp_valuehl 
3e05				endm 
# End of macro FORTH_DSP_VALUEHL
3e05			 
3e05			;		push hl    ; u 
3e05					if DEBUG_FORTH_WORDS 
3e05						DMARK "SPA" 
3e05 f5				push af  
3e06 3a 1a 3e			ld a, (.dmark)  
3e09 32 6e fb			ld (debug_mark),a  
3e0c 3a 1b 3e			ld a, (.dmark+1)  
3e0f 32 6f fb			ld (debug_mark+1),a  
3e12 3a 1c 3e			ld a, (.dmark+2)  
3e15 32 70 fb			ld (debug_mark+2),a  
3e18 18 03			jr .pastdmark  
3e1a ..			.dmark: db "SPA"  
3e1d f1			.pastdmark: pop af  
3e1e			endm  
# End of macro DMARK
3e1e						CALLMONITOR 
3e1e cd ab 16			call break_point_state  
3e21				endm  
# End of macro CALLMONITOR
3e21					endif 
3e21			 
3e21					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e21 cd b7 1f			call macro_forth_dsp_pop 
3e24				endm 
# End of macro FORTH_DSP_POP
3e24			;		pop hl 
3e24 4d					ld c, l 
3e25 06 00				ld b, 0 
3e27 21 14 ee				ld hl, scratch  
3e2a			 
3e2a					if DEBUG_FORTH_WORDS 
3e2a						DMARK "SP2" 
3e2a f5				push af  
3e2b 3a 3f 3e			ld a, (.dmark)  
3e2e 32 6e fb			ld (debug_mark),a  
3e31 3a 40 3e			ld a, (.dmark+1)  
3e34 32 6f fb			ld (debug_mark+1),a  
3e37 3a 41 3e			ld a, (.dmark+2)  
3e3a 32 70 fb			ld (debug_mark+2),a  
3e3d 18 03			jr .pastdmark  
3e3f ..			.dmark: db "SP2"  
3e42 f1			.pastdmark: pop af  
3e43			endm  
# End of macro DMARK
3e43						CALLMONITOR 
3e43 cd ab 16			call break_point_state  
3e46				endm  
# End of macro CALLMONITOR
3e46					endif 
3e46 3e 20				ld a, ' ' 
3e48 c5			.spaces1:	push bc 
3e49 77					ld (hl),a 
3e4a 23					inc hl 
3e4b c1					pop bc 
3e4c 10 fa				djnz .spaces1 
3e4e 3e 00				ld a,0 
3e50 77					ld (hl),a 
3e51 21 14 ee				ld hl, scratch 
3e54					if DEBUG_FORTH_WORDS 
3e54						DMARK "SP3" 
3e54 f5				push af  
3e55 3a 69 3e			ld a, (.dmark)  
3e58 32 6e fb			ld (debug_mark),a  
3e5b 3a 6a 3e			ld a, (.dmark+1)  
3e5e 32 6f fb			ld (debug_mark+1),a  
3e61 3a 6b 3e			ld a, (.dmark+2)  
3e64 32 70 fb			ld (debug_mark+2),a  
3e67 18 03			jr .pastdmark  
3e69 ..			.dmark: db "SP3"  
3e6c f1			.pastdmark: pop af  
3e6d			endm  
# End of macro DMARK
3e6d						CALLMONITOR 
3e6d cd ab 16			call break_point_state  
3e70				endm  
# End of macro CALLMONITOR
3e70					endif 
3e70 cd 71 1e				call forth_apush 
3e73			 
3e73				       NEXTW 
3e73 c3 71 20			jp macro_next 
3e76				endm 
# End of macro NEXTW
3e76			 
3e76			 
3e76			 
3e76			.SCROLL: 
3e76				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e76 53				db WORD_SYS_CORE+63             
3e77 a3 3e			dw .SCROLLD            
3e79 07				db 6 + 1 
3e7a .. 00			db "SCROLL",0              
3e81				endm 
# End of macro CWHEAD
3e81			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e81					if DEBUG_FORTH_WORDS_KEY 
3e81						DMARK "SCR" 
3e81 f5				push af  
3e82 3a 96 3e			ld a, (.dmark)  
3e85 32 6e fb			ld (debug_mark),a  
3e88 3a 97 3e			ld a, (.dmark+1)  
3e8b 32 6f fb			ld (debug_mark+1),a  
3e8e 3a 98 3e			ld a, (.dmark+2)  
3e91 32 70 fb			ld (debug_mark+2),a  
3e94 18 03			jr .pastdmark  
3e96 ..			.dmark: db "SCR"  
3e99 f1			.pastdmark: pop af  
3e9a			endm  
# End of macro DMARK
3e9a						CALLMONITOR 
3e9a cd ab 16			call break_point_state  
3e9d				endm  
# End of macro CALLMONITOR
3e9d					endif 
3e9d			 
3e9d cd 92 0a			call scroll_up 
3ea0			;	call update_display 
3ea0			 
3ea0					NEXTW 
3ea0 c3 71 20			jp macro_next 
3ea3				endm 
# End of macro NEXTW
3ea3			 
3ea3			 
3ea3			 
3ea3			;		; get dir 
3ea3			; 
3ea3			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ea3			; 
3ea3			;		push hl 
3ea3			; 
3ea3			;		; destroy value TOS 
3ea3			; 
3ea3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ea3			; 
3ea3			;		; get count 
3ea3			; 
3ea3			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ea3			; 
3ea3			;		push hl 
3ea3			; 
3ea3			;		; destroy value TOS 
3ea3			; 
3ea3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ea3			; 
3ea3			;		; one value on hl get other one back 
3ea3			; 
3ea3			;		pop bc    ; count 
3ea3			; 
3ea3			;		pop de   ; dir 
3ea3			; 
3ea3			; 
3ea3			;		ld b, c 
3ea3			; 
3ea3			;.scrolldir:     push bc 
3ea3			;		push de 
3ea3			; 
3ea3			;		ld a, 0 
3ea3			;		cp e 
3ea3			;		jr z, .scrollup  
3ea3			;		call scroll_down 
3ea3			;		jr .scrollnext 
3ea3			;.scrollup:	call scroll_up 
3ea3			; 
3ea3			;		 
3ea3			;.scrollnext: 
3ea3			;		pop de 
3ea3			;		pop bc 
3ea3			;		djnz .scrolldir 
3ea3			; 
3ea3			; 
3ea3			; 
3ea3			; 
3ea3			; 
3ea3			;		NEXTW 
3ea3			 
3ea3			.SCROLLD: 
3ea3				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3ea3 53				db WORD_SYS_CORE+63             
3ea4 d1 3e			dw .ATQ            
3ea6 08				db 7 + 1 
3ea7 .. 00			db "SCROLLD",0              
3eaf				endm 
# End of macro CWHEAD
3eaf			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3eaf					if DEBUG_FORTH_WORDS_KEY 
3eaf						DMARK "SCD" 
3eaf f5				push af  
3eb0 3a c4 3e			ld a, (.dmark)  
3eb3 32 6e fb			ld (debug_mark),a  
3eb6 3a c5 3e			ld a, (.dmark+1)  
3eb9 32 6f fb			ld (debug_mark+1),a  
3ebc 3a c6 3e			ld a, (.dmark+2)  
3ebf 32 70 fb			ld (debug_mark+2),a  
3ec2 18 03			jr .pastdmark  
3ec4 ..			.dmark: db "SCD"  
3ec7 f1			.pastdmark: pop af  
3ec8			endm  
# End of macro DMARK
3ec8						CALLMONITOR 
3ec8 cd ab 16			call break_point_state  
3ecb				endm  
# End of macro CALLMONITOR
3ecb					endif 
3ecb			 
3ecb cd b6 0a			call scroll_down 
3ece			;	call update_display 
3ece			 
3ece					NEXTW 
3ece c3 71 20			jp macro_next 
3ed1				endm 
# End of macro NEXTW
3ed1			 
3ed1			 
3ed1			.ATQ: 
3ed1				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ed1 62				db WORD_SYS_CORE+78             
3ed2 2f 3f			dw .AUTODSP            
3ed4 04				db 3 + 1 
3ed5 .. 00			db "AT@",0              
3ed9				endm 
# End of macro CWHEAD
3ed9			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3ed9					if DEBUG_FORTH_WORDS_KEY 
3ed9						DMARK "ATA" 
3ed9 f5				push af  
3eda 3a ee 3e			ld a, (.dmark)  
3edd 32 6e fb			ld (debug_mark),a  
3ee0 3a ef 3e			ld a, (.dmark+1)  
3ee3 32 6f fb			ld (debug_mark+1),a  
3ee6 3a f0 3e			ld a, (.dmark+2)  
3ee9 32 70 fb			ld (debug_mark+2),a  
3eec 18 03			jr .pastdmark  
3eee ..			.dmark: db "ATA"  
3ef1 f1			.pastdmark: pop af  
3ef2			endm  
# End of macro DMARK
3ef2						CALLMONITOR 
3ef2 cd ab 16			call break_point_state  
3ef5				endm  
# End of macro CALLMONITOR
3ef5					endif 
3ef5			 
3ef5			 
3ef5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ef5 cd ff 1e			call macro_dsp_valuehl 
3ef8				endm 
# End of macro FORTH_DSP_VALUEHL
3ef8			 
3ef8					; TODO save cursor row 
3ef8 7d					ld a,l 
3ef9 fe 02				cp 2 
3efb 20 04				jr nz, .crow3aq 
3efd 3e 28				ld a, display_row_2 
3eff 18 12				jr .ccol1aq 
3f01 fe 03		.crow3aq:		cp 3 
3f03 20 04				jr nz, .crow4aq 
3f05 3e 50				ld a, display_row_3 
3f07 18 0a				jr .ccol1aq 
3f09 fe 04		.crow4aq:		cp 4 
3f0b 20 04				jr nz, .crow1aq 
3f0d 3e 78				ld a, display_row_4 
3f0f 18 02				jr .ccol1aq 
3f11 3e 00		.crow1aq:		ld a,display_row_1 
3f13 f5			.ccol1aq:		push af			; got row offset 
3f14 6f					ld l,a 
3f15 26 00				ld h,0 
3f17					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f17 cd b7 1f			call macro_forth_dsp_pop 
3f1a				endm 
# End of macro FORTH_DSP_POP
3f1a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f1a cd ff 1e			call macro_dsp_valuehl 
3f1d				endm 
# End of macro FORTH_DSP_VALUEHL
3f1d					; TODO save cursor col 
3f1d f1					pop af 
3f1e 85					add l		; add col offset 
3f1f			 
3f1f					; add current frame buffer address 
3f1f 2a cf f8				ld hl, (display_fb_active) 
3f22 cd 04 0d				call addatohl 
3f25			 
3f25			 
3f25			 
3f25			 
3f25					; get char frame buffer location offset in hl 
3f25			 
3f25 7e					ld a,(hl) 
3f26 26 00				ld h, 0 
3f28 6f					ld l, a 
3f29			 
3f29 cd 08 1d				call forth_push_numhl 
3f2c			 
3f2c			 
3f2c					NEXTW 
3f2c c3 71 20			jp macro_next 
3f2f				endm 
# End of macro NEXTW
3f2f			 
3f2f			.AUTODSP: 
3f2f				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3f2f 63				db WORD_SYS_CORE+79             
3f30 45 3f			dw .MENU            
3f32 05				db 4 + 1 
3f33 .. 00			db "ADSP",0              
3f38				endm 
# End of macro CWHEAD
3f38			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3f38			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3f38			 
3f38					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f38 cd ff 1e			call macro_dsp_valuehl 
3f3b				endm 
# End of macro FORTH_DSP_VALUEHL
3f3b			 
3f3b			;		push hl 
3f3b			 
3f3b					; destroy value TOS 
3f3b			 
3f3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f3b cd b7 1f			call macro_forth_dsp_pop 
3f3e				endm 
# End of macro FORTH_DSP_POP
3f3e			 
3f3e			;		pop hl 
3f3e			 
3f3e 7d					ld a,l 
3f3f 32 1b f8				ld (cli_autodisplay), a 
3f42				       NEXTW 
3f42 c3 71 20			jp macro_next 
3f45				endm 
# End of macro NEXTW
3f45			 
3f45			.MENU: 
3f45				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f45 70				db WORD_SYS_CORE+92             
3f46 ee 3f			dw .ENDDISPLAY            
3f48 05				db 4 + 1 
3f49 .. 00			db "MENU",0              
3f4e				endm 
# End of macro CWHEAD
3f4e			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f4e			 
3f4e			;		; get number of items on the stack 
3f4e			; 
3f4e				 
3f4e					FORTH_DSP_VALUEHL 
3f4e cd ff 1e			call macro_dsp_valuehl 
3f51				endm 
# End of macro FORTH_DSP_VALUEHL
3f51				 
3f51					if DEBUG_FORTH_WORDS_KEY 
3f51						DMARK "MNU" 
3f51 f5				push af  
3f52 3a 66 3f			ld a, (.dmark)  
3f55 32 6e fb			ld (debug_mark),a  
3f58 3a 67 3f			ld a, (.dmark+1)  
3f5b 32 6f fb			ld (debug_mark+1),a  
3f5e 3a 68 3f			ld a, (.dmark+2)  
3f61 32 70 fb			ld (debug_mark+2),a  
3f64 18 03			jr .pastdmark  
3f66 ..			.dmark: db "MNU"  
3f69 f1			.pastdmark: pop af  
3f6a			endm  
# End of macro DMARK
3f6a						CALLMONITOR 
3f6a cd ab 16			call break_point_state  
3f6d				endm  
# End of macro CALLMONITOR
3f6d					endif 
3f6d			 
3f6d 45					ld b, l	 
3f6e 05					dec b 
3f6f			 
3f6f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f6f cd b7 1f			call macro_forth_dsp_pop 
3f72				endm 
# End of macro FORTH_DSP_POP
3f72			 
3f72			 
3f72					; go directly through the stack to pluck out the string pointers and build an array 
3f72			 
3f72			;		FORTH_DSP 
3f72			 
3f72					; hl contains top most stack item 
3f72				 
3f72 11 14 ee				ld de, scratch 
3f75			 
3f75			.mbuild: 
3f75			 
3f75					FORTH_DSP_VALUEHL 
3f75 cd ff 1e			call macro_dsp_valuehl 
3f78				endm 
# End of macro FORTH_DSP_VALUEHL
3f78			 
3f78					if DEBUG_FORTH_WORDS 
3f78						DMARK "MN3" 
3f78 f5				push af  
3f79 3a 8d 3f			ld a, (.dmark)  
3f7c 32 6e fb			ld (debug_mark),a  
3f7f 3a 8e 3f			ld a, (.dmark+1)  
3f82 32 6f fb			ld (debug_mark+1),a  
3f85 3a 8f 3f			ld a, (.dmark+2)  
3f88 32 70 fb			ld (debug_mark+2),a  
3f8b 18 03			jr .pastdmark  
3f8d ..			.dmark: db "MN3"  
3f90 f1			.pastdmark: pop af  
3f91			endm  
# End of macro DMARK
3f91						CALLMONITOR 
3f91 cd ab 16			call break_point_state  
3f94				endm  
# End of macro CALLMONITOR
3f94					endif 
3f94 eb					ex de, hl 
3f95 73					ld (hl), e 
3f96 23					inc hl 
3f97 72					ld (hl), d 
3f98 23					inc hl 
3f99 eb					ex de, hl 
3f9a			 
3f9a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f9a cd b7 1f			call macro_forth_dsp_pop 
3f9d				endm 
# End of macro FORTH_DSP_POP
3f9d			 
3f9d 10 d6				djnz .mbuild 
3f9f			 
3f9f					; done add term 
3f9f			 
3f9f eb					ex de, hl 
3fa0 36 00				ld (hl), 0 
3fa2 23					inc hl 
3fa3 36 00				ld (hl), 0 
3fa5			 
3fa5				 
3fa5					 
3fa5 21 14 ee				ld hl, scratch 
3fa8			 
3fa8					if DEBUG_FORTH_WORDS 
3fa8						DMARK "MNx" 
3fa8 f5				push af  
3fa9 3a bd 3f			ld a, (.dmark)  
3fac 32 6e fb			ld (debug_mark),a  
3faf 3a be 3f			ld a, (.dmark+1)  
3fb2 32 6f fb			ld (debug_mark+1),a  
3fb5 3a bf 3f			ld a, (.dmark+2)  
3fb8 32 70 fb			ld (debug_mark+2),a  
3fbb 18 03			jr .pastdmark  
3fbd ..			.dmark: db "MNx"  
3fc0 f1			.pastdmark: pop af  
3fc1			endm  
# End of macro DMARK
3fc1						CALLMONITOR 
3fc1 cd ab 16			call break_point_state  
3fc4				endm  
# End of macro CALLMONITOR
3fc4					endif 
3fc4			 
3fc4			 
3fc4			 
3fc4 3e 00				ld a, 0 
3fc6 cd 01 0b				call menu 
3fc9			 
3fc9			 
3fc9 6f					ld l, a 
3fca 26 00				ld h, 0 
3fcc			 
3fcc					if DEBUG_FORTH_WORDS 
3fcc						DMARK "MNr" 
3fcc f5				push af  
3fcd 3a e1 3f			ld a, (.dmark)  
3fd0 32 6e fb			ld (debug_mark),a  
3fd3 3a e2 3f			ld a, (.dmark+1)  
3fd6 32 6f fb			ld (debug_mark+1),a  
3fd9 3a e3 3f			ld a, (.dmark+2)  
3fdc 32 70 fb			ld (debug_mark+2),a  
3fdf 18 03			jr .pastdmark  
3fe1 ..			.dmark: db "MNr"  
3fe4 f1			.pastdmark: pop af  
3fe5			endm  
# End of macro DMARK
3fe5						CALLMONITOR 
3fe5 cd ab 16			call break_point_state  
3fe8				endm  
# End of macro CALLMONITOR
3fe8					endif 
3fe8			 
3fe8 cd 08 1d				call forth_push_numhl 
3feb			 
3feb			 
3feb			 
3feb			 
3feb				       NEXTW 
3feb c3 71 20			jp macro_next 
3fee				endm 
# End of macro NEXTW
3fee			 
3fee			 
3fee			.ENDDISPLAY: 
3fee			 
3fee			; eof 
# End of file forth_words_display.asm
3fee			include "forth_words_str.asm" 
3fee			 
3fee			; | ## String Words 
3fee			 
3fee			.PTR:   
3fee			 
3fee				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3fee 48				db WORD_SYS_CORE+52             
3fef 1b 40			dw .STYPE            
3ff1 04				db 3 + 1 
3ff2 .. 00			db "PTR",0              
3ff6				endm 
# End of macro CWHEAD
3ff6			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3ff6			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3ff6			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3ff6			 
3ff6					if DEBUG_FORTH_WORDS_KEY 
3ff6						DMARK "PTR" 
3ff6 f5				push af  
3ff7 3a 0b 40			ld a, (.dmark)  
3ffa 32 6e fb			ld (debug_mark),a  
3ffd 3a 0c 40			ld a, (.dmark+1)  
4000 32 6f fb			ld (debug_mark+1),a  
4003 3a 0d 40			ld a, (.dmark+2)  
4006 32 70 fb			ld (debug_mark+2),a  
4009 18 03			jr .pastdmark  
400b ..			.dmark: db "PTR"  
400e f1			.pastdmark: pop af  
400f			endm  
# End of macro DMARK
400f						CALLMONITOR 
400f cd ab 16			call break_point_state  
4012				endm  
# End of macro CALLMONITOR
4012					endif 
4012					FORTH_DSP_VALUEHL 
4012 cd ff 1e			call macro_dsp_valuehl 
4015				endm 
# End of macro FORTH_DSP_VALUEHL
4015 cd 08 1d				call forth_push_numhl 
4018			 
4018			 
4018					NEXTW 
4018 c3 71 20			jp macro_next 
401b				endm 
# End of macro NEXTW
401b			.STYPE: 
401b				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
401b 48				db WORD_SYS_CORE+52             
401c 6a 40			dw .UPPER            
401e 06				db 5 + 1 
401f .. 00			db "STYPE",0              
4025				endm 
# End of macro CWHEAD
4025			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4025					if DEBUG_FORTH_WORDS_KEY 
4025						DMARK "STY" 
4025 f5				push af  
4026 3a 3a 40			ld a, (.dmark)  
4029 32 6e fb			ld (debug_mark),a  
402c 3a 3b 40			ld a, (.dmark+1)  
402f 32 6f fb			ld (debug_mark+1),a  
4032 3a 3c 40			ld a, (.dmark+2)  
4035 32 70 fb			ld (debug_mark+2),a  
4038 18 03			jr .pastdmark  
403a ..			.dmark: db "STY"  
403d f1			.pastdmark: pop af  
403e			endm  
# End of macro DMARK
403e						CALLMONITOR 
403e cd ab 16			call break_point_state  
4041				endm  
# End of macro CALLMONITOR
4041					endif 
4041					FORTH_DSP 
4041 cd c5 1e			call macro_forth_dsp 
4044				endm 
# End of macro FORTH_DSP
4044					;v5 FORTH_DSP_VALUE 
4044			 
4044 7e					ld a, (hl) 
4045			 
4045 f5					push af 
4046			 
4046			; Dont destroy TOS		FORTH_DSP_POP 
4046			 
4046 f1					pop af 
4047			 
4047 fe 01				cp DS_TYPE_STR 
4049 28 09				jr z, .typestr 
404b			 
404b fe 02				cp DS_TYPE_INUM 
404d 28 0a				jr z, .typeinum 
404f			 
404f 21 68 40				ld hl, .tna 
4052 18 0a				jr .tpush 
4054			 
4054 21 64 40		.typestr:	ld hl, .tstr 
4057 18 05				jr .tpush 
4059 21 66 40		.typeinum:	ld hl, .tinum 
405c 18 00				jr .tpush 
405e			 
405e			.tpush: 
405e			 
405e cd 76 1d				call forth_push_str 
4061			 
4061					NEXTW 
4061 c3 71 20			jp macro_next 
4064				endm 
# End of macro NEXTW
4064 .. 00		.tstr:	db "s",0 
4066 .. 00		.tinum:  db "i",0 
4068 .. 00		.tna:   db "?", 0 
406a			 
406a			 
406a			.UPPER: 
406a				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
406a 48				db WORD_SYS_CORE+52             
406b a5 40			dw .LOWER            
406d 06				db 5 + 1 
406e .. 00			db "UPPER",0              
4074				endm 
# End of macro CWHEAD
4074			; | UPPER ( s -- s ) Upper case string s  | DONE 
4074					if DEBUG_FORTH_WORDS_KEY 
4074						DMARK "UPR" 
4074 f5				push af  
4075 3a 89 40			ld a, (.dmark)  
4078 32 6e fb			ld (debug_mark),a  
407b 3a 8a 40			ld a, (.dmark+1)  
407e 32 6f fb			ld (debug_mark+1),a  
4081 3a 8b 40			ld a, (.dmark+2)  
4084 32 70 fb			ld (debug_mark+2),a  
4087 18 03			jr .pastdmark  
4089 ..			.dmark: db "UPR"  
408c f1			.pastdmark: pop af  
408d			endm  
# End of macro DMARK
408d						CALLMONITOR 
408d cd ab 16			call break_point_state  
4090				endm  
# End of macro CALLMONITOR
4090					endif 
4090			 
4090					FORTH_DSP 
4090 cd c5 1e			call macro_forth_dsp 
4093				endm 
# End of macro FORTH_DSP
4093					 
4093			; TODO check is string type 
4093			 
4093					FORTH_DSP_VALUEHL 
4093 cd ff 1e			call macro_dsp_valuehl 
4096				endm 
# End of macro FORTH_DSP_VALUEHL
4096			; get pointer to string in hl 
4096			 
4096 7e			.toup:		ld a, (hl) 
4097 fe 00				cp 0 
4099 28 07				jr z, .toupdone 
409b			 
409b cd 71 10				call to_upper 
409e			 
409e 77					ld (hl), a 
409f 23					inc hl 
40a0 18 f4				jr .toup 
40a2			 
40a2					 
40a2			 
40a2			 
40a2			; for each char convert to upper 
40a2					 
40a2			.toupdone: 
40a2			 
40a2			 
40a2					NEXTW 
40a2 c3 71 20			jp macro_next 
40a5				endm 
# End of macro NEXTW
40a5			.LOWER: 
40a5				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
40a5 48				db WORD_SYS_CORE+52             
40a6 e0 40			dw .TCASE            
40a8 06				db 5 + 1 
40a9 .. 00			db "LOWER",0              
40af				endm 
# End of macro CWHEAD
40af			; | LOWER ( s -- s ) Lower case string s  | DONE 
40af					if DEBUG_FORTH_WORDS_KEY 
40af						DMARK "LWR" 
40af f5				push af  
40b0 3a c4 40			ld a, (.dmark)  
40b3 32 6e fb			ld (debug_mark),a  
40b6 3a c5 40			ld a, (.dmark+1)  
40b9 32 6f fb			ld (debug_mark+1),a  
40bc 3a c6 40			ld a, (.dmark+2)  
40bf 32 70 fb			ld (debug_mark+2),a  
40c2 18 03			jr .pastdmark  
40c4 ..			.dmark: db "LWR"  
40c7 f1			.pastdmark: pop af  
40c8			endm  
# End of macro DMARK
40c8						CALLMONITOR 
40c8 cd ab 16			call break_point_state  
40cb				endm  
# End of macro CALLMONITOR
40cb					endif 
40cb			 
40cb					FORTH_DSP 
40cb cd c5 1e			call macro_forth_dsp 
40ce				endm 
# End of macro FORTH_DSP
40ce					 
40ce			; TODO check is string type 
40ce			 
40ce					FORTH_DSP_VALUEHL 
40ce cd ff 1e			call macro_dsp_valuehl 
40d1				endm 
# End of macro FORTH_DSP_VALUEHL
40d1			; get pointer to string in hl 
40d1			 
40d1 7e			.tolow:		ld a, (hl) 
40d2 fe 00				cp 0 
40d4 28 07				jr z, .tolowdone 
40d6			 
40d6 cd 7a 10				call to_lower 
40d9			 
40d9 77					ld (hl), a 
40da 23					inc hl 
40db 18 f4				jr .tolow 
40dd			 
40dd					 
40dd			 
40dd			 
40dd			; for each char convert to low 
40dd					 
40dd			.tolowdone: 
40dd					NEXTW 
40dd c3 71 20			jp macro_next 
40e0				endm 
# End of macro NEXTW
40e0			.TCASE: 
40e0				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40e0 48				db WORD_SYS_CORE+52             
40e1 16 42			dw .SUBSTR            
40e3 06				db 5 + 1 
40e4 .. 00			db "TCASE",0              
40ea				endm 
# End of macro CWHEAD
40ea			; | TCASE ( s -- s ) Title case string s  | DONE 
40ea					if DEBUG_FORTH_WORDS_KEY 
40ea						DMARK "TCS" 
40ea f5				push af  
40eb 3a ff 40			ld a, (.dmark)  
40ee 32 6e fb			ld (debug_mark),a  
40f1 3a 00 41			ld a, (.dmark+1)  
40f4 32 6f fb			ld (debug_mark+1),a  
40f7 3a 01 41			ld a, (.dmark+2)  
40fa 32 70 fb			ld (debug_mark+2),a  
40fd 18 03			jr .pastdmark  
40ff ..			.dmark: db "TCS"  
4102 f1			.pastdmark: pop af  
4103			endm  
# End of macro DMARK
4103						CALLMONITOR 
4103 cd ab 16			call break_point_state  
4106				endm  
# End of macro CALLMONITOR
4106					endif 
4106			 
4106					FORTH_DSP 
4106 cd c5 1e			call macro_forth_dsp 
4109				endm 
# End of macro FORTH_DSP
4109					 
4109			; TODO check is string type 
4109			 
4109					FORTH_DSP_VALUEHL 
4109 cd ff 1e			call macro_dsp_valuehl 
410c				endm 
# End of macro FORTH_DSP_VALUEHL
410c			; get pointer to string in hl 
410c			 
410c					if DEBUG_FORTH_WORDS 
410c						DMARK "TC1" 
410c f5				push af  
410d 3a 21 41			ld a, (.dmark)  
4110 32 6e fb			ld (debug_mark),a  
4113 3a 22 41			ld a, (.dmark+1)  
4116 32 6f fb			ld (debug_mark+1),a  
4119 3a 23 41			ld a, (.dmark+2)  
411c 32 70 fb			ld (debug_mark+2),a  
411f 18 03			jr .pastdmark  
4121 ..			.dmark: db "TC1"  
4124 f1			.pastdmark: pop af  
4125			endm  
# End of macro DMARK
4125						CALLMONITOR 
4125 cd ab 16			call break_point_state  
4128				endm  
# End of macro CALLMONITOR
4128					endif 
4128			 
4128					; first time in turn to upper case first char 
4128			 
4128 7e					ld a, (hl) 
4129 c3 b3 41				jp .totsiptou 
412c			 
412c			 
412c 7e			.tot:		ld a, (hl) 
412d fe 00				cp 0 
412f ca f7 41				jp z, .totdone 
4132			 
4132					if DEBUG_FORTH_WORDS 
4132						DMARK "TC2" 
4132 f5				push af  
4133 3a 47 41			ld a, (.dmark)  
4136 32 6e fb			ld (debug_mark),a  
4139 3a 48 41			ld a, (.dmark+1)  
413c 32 6f fb			ld (debug_mark+1),a  
413f 3a 49 41			ld a, (.dmark+2)  
4142 32 70 fb			ld (debug_mark+2),a  
4145 18 03			jr .pastdmark  
4147 ..			.dmark: db "TC2"  
414a f1			.pastdmark: pop af  
414b			endm  
# End of macro DMARK
414b						CALLMONITOR 
414b cd ab 16			call break_point_state  
414e				endm  
# End of macro CALLMONITOR
414e					endif 
414e					; check to see if current char is a space 
414e			 
414e fe 20				cp ' ' 
4150 28 21				jr z, .totsp 
4152 cd 7a 10				call to_lower 
4155					if DEBUG_FORTH_WORDS 
4155						DMARK "TC3" 
4155 f5				push af  
4156 3a 6a 41			ld a, (.dmark)  
4159 32 6e fb			ld (debug_mark),a  
415c 3a 6b 41			ld a, (.dmark+1)  
415f 32 6f fb			ld (debug_mark+1),a  
4162 3a 6c 41			ld a, (.dmark+2)  
4165 32 70 fb			ld (debug_mark+2),a  
4168 18 03			jr .pastdmark  
416a ..			.dmark: db "TC3"  
416d f1			.pastdmark: pop af  
416e			endm  
# End of macro DMARK
416e						CALLMONITOR 
416e cd ab 16			call break_point_state  
4171				endm  
# End of macro CALLMONITOR
4171					endif 
4171 18 63				jr .totnxt 
4173			 
4173			.totsp:         ; on a space, find next char which should be upper 
4173			 
4173					if DEBUG_FORTH_WORDS 
4173						DMARK "TC4" 
4173 f5				push af  
4174 3a 88 41			ld a, (.dmark)  
4177 32 6e fb			ld (debug_mark),a  
417a 3a 89 41			ld a, (.dmark+1)  
417d 32 6f fb			ld (debug_mark+1),a  
4180 3a 8a 41			ld a, (.dmark+2)  
4183 32 70 fb			ld (debug_mark+2),a  
4186 18 03			jr .pastdmark  
4188 ..			.dmark: db "TC4"  
418b f1			.pastdmark: pop af  
418c			endm  
# End of macro DMARK
418c						CALLMONITOR 
418c cd ab 16			call break_point_state  
418f				endm  
# End of macro CALLMONITOR
418f					endif 
418f					;; 
418f			 
418f fe 20				cp ' ' 
4191 20 20				jr nz, .totsiptou 
4193 23					inc hl 
4194 7e					ld a, (hl) 
4195					if DEBUG_FORTH_WORDS 
4195						DMARK "TC5" 
4195 f5				push af  
4196 3a aa 41			ld a, (.dmark)  
4199 32 6e fb			ld (debug_mark),a  
419c 3a ab 41			ld a, (.dmark+1)  
419f 32 6f fb			ld (debug_mark+1),a  
41a2 3a ac 41			ld a, (.dmark+2)  
41a5 32 70 fb			ld (debug_mark+2),a  
41a8 18 03			jr .pastdmark  
41aa ..			.dmark: db "TC5"  
41ad f1			.pastdmark: pop af  
41ae			endm  
# End of macro DMARK
41ae						CALLMONITOR 
41ae cd ab 16			call break_point_state  
41b1				endm  
# End of macro CALLMONITOR
41b1					endif 
41b1 18 c0				jr .totsp 
41b3 fe 00		.totsiptou:    cp 0 
41b5 28 40				jr z, .totdone 
41b7					; not space and not zero term so upper case it 
41b7 cd 71 10				call to_upper 
41ba			 
41ba					if DEBUG_FORTH_WORDS 
41ba						DMARK "TC6" 
41ba f5				push af  
41bb 3a cf 41			ld a, (.dmark)  
41be 32 6e fb			ld (debug_mark),a  
41c1 3a d0 41			ld a, (.dmark+1)  
41c4 32 6f fb			ld (debug_mark+1),a  
41c7 3a d1 41			ld a, (.dmark+2)  
41ca 32 70 fb			ld (debug_mark+2),a  
41cd 18 03			jr .pastdmark  
41cf ..			.dmark: db "TC6"  
41d2 f1			.pastdmark: pop af  
41d3			endm  
# End of macro DMARK
41d3						CALLMONITOR 
41d3 cd ab 16			call break_point_state  
41d6				endm  
# End of macro CALLMONITOR
41d6					endif 
41d6			 
41d6			 
41d6			.totnxt: 
41d6			 
41d6 77					ld (hl), a 
41d7 23					inc hl 
41d8					if DEBUG_FORTH_WORDS 
41d8						DMARK "TC7" 
41d8 f5				push af  
41d9 3a ed 41			ld a, (.dmark)  
41dc 32 6e fb			ld (debug_mark),a  
41df 3a ee 41			ld a, (.dmark+1)  
41e2 32 6f fb			ld (debug_mark+1),a  
41e5 3a ef 41			ld a, (.dmark+2)  
41e8 32 70 fb			ld (debug_mark+2),a  
41eb 18 03			jr .pastdmark  
41ed ..			.dmark: db "TC7"  
41f0 f1			.pastdmark: pop af  
41f1			endm  
# End of macro DMARK
41f1						CALLMONITOR 
41f1 cd ab 16			call break_point_state  
41f4				endm  
# End of macro CALLMONITOR
41f4					endif 
41f4 c3 2c 41				jp .tot 
41f7			 
41f7					 
41f7			 
41f7			 
41f7			; for each char convert to low 
41f7					 
41f7			.totdone: 
41f7					if DEBUG_FORTH_WORDS 
41f7						DMARK "TCd" 
41f7 f5				push af  
41f8 3a 0c 42			ld a, (.dmark)  
41fb 32 6e fb			ld (debug_mark),a  
41fe 3a 0d 42			ld a, (.dmark+1)  
4201 32 6f fb			ld (debug_mark+1),a  
4204 3a 0e 42			ld a, (.dmark+2)  
4207 32 70 fb			ld (debug_mark+2),a  
420a 18 03			jr .pastdmark  
420c ..			.dmark: db "TCd"  
420f f1			.pastdmark: pop af  
4210			endm  
# End of macro DMARK
4210						CALLMONITOR 
4210 cd ab 16			call break_point_state  
4213				endm  
# End of macro CALLMONITOR
4213					endif 
4213					NEXTW 
4213 c3 71 20			jp macro_next 
4216				endm 
# End of macro NEXTW
4216			 
4216			.SUBSTR: 
4216				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4216 48				db WORD_SYS_CORE+52             
4217 74 42			dw .LEFT            
4219 07				db 6 + 1 
421a .. 00			db "SUBSTR",0              
4221				endm 
# End of macro CWHEAD
4221			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4221			 
4221					if DEBUG_FORTH_WORDS_KEY 
4221						DMARK "SST" 
4221 f5				push af  
4222 3a 36 42			ld a, (.dmark)  
4225 32 6e fb			ld (debug_mark),a  
4228 3a 37 42			ld a, (.dmark+1)  
422b 32 6f fb			ld (debug_mark+1),a  
422e 3a 38 42			ld a, (.dmark+2)  
4231 32 70 fb			ld (debug_mark+2),a  
4234 18 03			jr .pastdmark  
4236 ..			.dmark: db "SST"  
4239 f1			.pastdmark: pop af  
423a			endm  
# End of macro DMARK
423a						CALLMONITOR 
423a cd ab 16			call break_point_state  
423d				endm  
# End of macro CALLMONITOR
423d					endif 
423d			; TODO check string type 
423d					FORTH_DSP_VALUEHL 
423d cd ff 1e			call macro_dsp_valuehl 
4240				endm 
# End of macro FORTH_DSP_VALUEHL
4240			 
4240 e5					push hl      ; string length 
4241			 
4241					FORTH_DSP_POP 
4241 cd b7 1f			call macro_forth_dsp_pop 
4244				endm 
# End of macro FORTH_DSP_POP
4244			 
4244					FORTH_DSP_VALUEHL 
4244 cd ff 1e			call macro_dsp_valuehl 
4247				endm 
# End of macro FORTH_DSP_VALUEHL
4247			 
4247 e5					push hl     ; start char 
4248			 
4248					FORTH_DSP_POP 
4248 cd b7 1f			call macro_forth_dsp_pop 
424b				endm 
# End of macro FORTH_DSP_POP
424b			 
424b			 
424b					FORTH_DSP_VALUE 
424b cd e8 1e			call macro_forth_dsp_value 
424e				endm 
# End of macro FORTH_DSP_VALUE
424e			 
424e d1					pop de    ; get start post offset 
424f			 
424f 19					add hl, de    ; starting offset 
4250			 
4250 c1					pop bc 
4251 c5					push bc      ; grab size of string 
4252			 
4252 e5					push hl    ; save string start  
4253			 
4253 26 00				ld h, 0 
4255 69					ld l, c 
4256 23					inc hl 
4257 23					inc hl 
4258			 
4258 cd cb 11				call malloc 
425b				if DEBUG_FORTH_MALLOC_GUARD 
425b cc 32 52				call z,malloc_error 
425e				endif 
425e			 
425e eb					ex de, hl      ; save malloc area for string copy 
425f e1					pop hl    ; get back source 
4260 c1					pop bc    ; get length of string back 
4261			 
4261 d5					push de    ; save malloc area for after we push 
4262 ed b0				ldir     ; copy substr 
4264			 
4264			 
4264 eb					ex de, hl 
4265 3e 00				ld a, 0 
4267 77					ld (hl), a   ; term substr 
4268			 
4268					 
4268 e1					pop hl    ; get malloc so we can push it 
4269 e5					push hl   ; save so we can free it afterwards 
426a			 
426a cd 76 1d				call forth_push_str 
426d			 
426d e1					pop hl 
426e cd 95 12				call free 
4271			 
4271					 
4271					 
4271			 
4271			 
4271					NEXTW 
4271 c3 71 20			jp macro_next 
4274				endm 
# End of macro NEXTW
4274			 
4274			.LEFT: 
4274				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4274 48				db WORD_SYS_CORE+52             
4275 9c 42			dw .RIGHT            
4277 05				db 4 + 1 
4278 .. 00			db "LEFT",0              
427d				endm 
# End of macro CWHEAD
427d			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
427d					if DEBUG_FORTH_WORDS_KEY 
427d						DMARK "LEF" 
427d f5				push af  
427e 3a 92 42			ld a, (.dmark)  
4281 32 6e fb			ld (debug_mark),a  
4284 3a 93 42			ld a, (.dmark+1)  
4287 32 6f fb			ld (debug_mark+1),a  
428a 3a 94 42			ld a, (.dmark+2)  
428d 32 70 fb			ld (debug_mark+2),a  
4290 18 03			jr .pastdmark  
4292 ..			.dmark: db "LEF"  
4295 f1			.pastdmark: pop af  
4296			endm  
# End of macro DMARK
4296						CALLMONITOR 
4296 cd ab 16			call break_point_state  
4299				endm  
# End of macro CALLMONITOR
4299					endif 
4299			 
4299					NEXTW 
4299 c3 71 20			jp macro_next 
429c				endm 
# End of macro NEXTW
429c			.RIGHT: 
429c				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
429c 48				db WORD_SYS_CORE+52             
429d c5 42			dw .STR2NUM            
429f 06				db 5 + 1 
42a0 .. 00			db "RIGHT",0              
42a6				endm 
# End of macro CWHEAD
42a6			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
42a6					if DEBUG_FORTH_WORDS_KEY 
42a6						DMARK "RIG" 
42a6 f5				push af  
42a7 3a bb 42			ld a, (.dmark)  
42aa 32 6e fb			ld (debug_mark),a  
42ad 3a bc 42			ld a, (.dmark+1)  
42b0 32 6f fb			ld (debug_mark+1),a  
42b3 3a bd 42			ld a, (.dmark+2)  
42b6 32 70 fb			ld (debug_mark+2),a  
42b9 18 03			jr .pastdmark  
42bb ..			.dmark: db "RIG"  
42be f1			.pastdmark: pop af  
42bf			endm  
# End of macro DMARK
42bf						CALLMONITOR 
42bf cd ab 16			call break_point_state  
42c2				endm  
# End of macro CALLMONITOR
42c2					endif 
42c2			 
42c2					NEXTW 
42c2 c3 71 20			jp macro_next 
42c5				endm 
# End of macro NEXTW
42c5			 
42c5			 
42c5			.STR2NUM: 
42c5				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
42c5 48				db WORD_SYS_CORE+52             
42c6 51 43			dw .NUM2STR            
42c8 08				db 7 + 1 
42c9 .. 00			db "STR2NUM",0              
42d1				endm 
# End of macro CWHEAD
42d1			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
42d1			 
42d1			 
42d1			; TODO STR type check to do 
42d1					if DEBUG_FORTH_WORDS_KEY 
42d1						DMARK "S2N" 
42d1 f5				push af  
42d2 3a e6 42			ld a, (.dmark)  
42d5 32 6e fb			ld (debug_mark),a  
42d8 3a e7 42			ld a, (.dmark+1)  
42db 32 6f fb			ld (debug_mark+1),a  
42de 3a e8 42			ld a, (.dmark+2)  
42e1 32 70 fb			ld (debug_mark+2),a  
42e4 18 03			jr .pastdmark  
42e6 ..			.dmark: db "S2N"  
42e9 f1			.pastdmark: pop af  
42ea			endm  
# End of macro DMARK
42ea						CALLMONITOR 
42ea cd ab 16			call break_point_state  
42ed				endm  
# End of macro CALLMONITOR
42ed					endif 
42ed			 
42ed					;FORTH_DSP 
42ed					FORTH_DSP_VALUE 
42ed cd e8 1e			call macro_forth_dsp_value 
42f0				endm 
# End of macro FORTH_DSP_VALUE
42f0					;inc hl 
42f0			 
42f0 eb					ex de, hl 
42f1					if DEBUG_FORTH_WORDS 
42f1						DMARK "S2a" 
42f1 f5				push af  
42f2 3a 06 43			ld a, (.dmark)  
42f5 32 6e fb			ld (debug_mark),a  
42f8 3a 07 43			ld a, (.dmark+1)  
42fb 32 6f fb			ld (debug_mark+1),a  
42fe 3a 08 43			ld a, (.dmark+2)  
4301 32 70 fb			ld (debug_mark+2),a  
4304 18 03			jr .pastdmark  
4306 ..			.dmark: db "S2a"  
4309 f1			.pastdmark: pop af  
430a			endm  
# End of macro DMARK
430a						CALLMONITOR 
430a cd ab 16			call break_point_state  
430d				endm  
# End of macro CALLMONITOR
430d					endif 
430d cd f9 10				call string_to_uint16 
4310			 
4310					if DEBUG_FORTH_WORDS 
4310						DMARK "S2b" 
4310 f5				push af  
4311 3a 25 43			ld a, (.dmark)  
4314 32 6e fb			ld (debug_mark),a  
4317 3a 26 43			ld a, (.dmark+1)  
431a 32 6f fb			ld (debug_mark+1),a  
431d 3a 27 43			ld a, (.dmark+2)  
4320 32 70 fb			ld (debug_mark+2),a  
4323 18 03			jr .pastdmark  
4325 ..			.dmark: db "S2b"  
4328 f1			.pastdmark: pop af  
4329			endm  
# End of macro DMARK
4329						CALLMONITOR 
4329 cd ab 16			call break_point_state  
432c				endm  
# End of macro CALLMONITOR
432c					endif 
432c			;		push hl 
432c					FORTH_DSP_POP 
432c cd b7 1f			call macro_forth_dsp_pop 
432f				endm 
# End of macro FORTH_DSP_POP
432f			;		pop hl 
432f					 
432f					if DEBUG_FORTH_WORDS 
432f						DMARK "S2b" 
432f f5				push af  
4330 3a 44 43			ld a, (.dmark)  
4333 32 6e fb			ld (debug_mark),a  
4336 3a 45 43			ld a, (.dmark+1)  
4339 32 6f fb			ld (debug_mark+1),a  
433c 3a 46 43			ld a, (.dmark+2)  
433f 32 70 fb			ld (debug_mark+2),a  
4342 18 03			jr .pastdmark  
4344 ..			.dmark: db "S2b"  
4347 f1			.pastdmark: pop af  
4348			endm  
# End of macro DMARK
4348						CALLMONITOR 
4348 cd ab 16			call break_point_state  
434b				endm  
# End of macro CALLMONITOR
434b					endif 
434b cd 08 1d				call forth_push_numhl	 
434e			 
434e				 
434e				       NEXTW 
434e c3 71 20			jp macro_next 
4351				endm 
# End of macro NEXTW
4351			.NUM2STR: 
4351				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4351 48				db WORD_SYS_CORE+52             
4352 60 43			dw .CONCAT            
4354 08				db 7 + 1 
4355 .. 00			db "NUM2STR",0              
435d				endm 
# End of macro CWHEAD
435d			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
435d			 
435d			;		; malloc a string to target 
435d			;		ld hl, 10     ; TODO max string size should be fine 
435d			;		call malloc 
435d			;		push hl    ; save malloc location 
435d			; 
435d			; 
435d			;; TODO check int type 
435d			;		FORTH_DSP_VALUEHL 
435d			;		ld a, l 
435d			;		call DispAToASCII   
435d			;;TODO need to chage above call to dump into string 
435d			; 
435d			; 
435d			 
435d				       NEXTW 
435d c3 71 20			jp macro_next 
4360				endm 
# End of macro NEXTW
4360			 
4360			.CONCAT: 
4360				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4360 48				db WORD_SYS_CORE+52             
4361 13 44			dw .FIND            
4363 07				db 6 + 1 
4364 .. 00			db "CONCAT",0              
436b				endm 
# End of macro CWHEAD
436b			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
436b			 
436b			; TODO check string type 
436b			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
436b			 
436b					if DEBUG_FORTH_WORDS_KEY 
436b						DMARK "CON" 
436b f5				push af  
436c 3a 80 43			ld a, (.dmark)  
436f 32 6e fb			ld (debug_mark),a  
4372 3a 81 43			ld a, (.dmark+1)  
4375 32 6f fb			ld (debug_mark+1),a  
4378 3a 82 43			ld a, (.dmark+2)  
437b 32 70 fb			ld (debug_mark+2),a  
437e 18 03			jr .pastdmark  
4380 ..			.dmark: db "CON"  
4383 f1			.pastdmark: pop af  
4384			endm  
# End of macro DMARK
4384						CALLMONITOR 
4384 cd ab 16			call break_point_state  
4387				endm  
# End of macro CALLMONITOR
4387					endif 
4387			 
4387			 
4387					FORTH_DSP_VALUE 
4387 cd e8 1e			call macro_forth_dsp_value 
438a				endm 
# End of macro FORTH_DSP_VALUE
438a e5					push hl   ; s2 
438b			 
438b					FORTH_DSP_POP 
438b cd b7 1f			call macro_forth_dsp_pop 
438e				endm 
# End of macro FORTH_DSP_POP
438e			 
438e					FORTH_DSP_VALUE 
438e cd e8 1e			call macro_forth_dsp_value 
4391				endm 
# End of macro FORTH_DSP_VALUE
4391			 
4391 e5					push hl   ; s1 
4392			 
4392					FORTH_DSP_POP 
4392 cd b7 1f			call macro_forth_dsp_pop 
4395				endm 
# End of macro FORTH_DSP_POP
4395					 
4395			 
4395					; copy s1 
4395			 
4395				 
4395					; save ptr 
4395 e1					pop hl  
4396 e5					push hl 
4397 3e 00				ld a, 0 
4399 cd 6d 11				call strlent 
439c					;inc hl    ; zer0 
439c 06 00				ld b, 0 
439e 4d					ld c, l 
439f e1					pop hl		 
43a0 11 14 ee				ld de, scratch	 
43a3					if DEBUG_FORTH_WORDS 
43a3						DMARK "CO1" 
43a3 f5				push af  
43a4 3a b8 43			ld a, (.dmark)  
43a7 32 6e fb			ld (debug_mark),a  
43aa 3a b9 43			ld a, (.dmark+1)  
43ad 32 6f fb			ld (debug_mark+1),a  
43b0 3a ba 43			ld a, (.dmark+2)  
43b3 32 70 fb			ld (debug_mark+2),a  
43b6 18 03			jr .pastdmark  
43b8 ..			.dmark: db "CO1"  
43bb f1			.pastdmark: pop af  
43bc			endm  
# End of macro DMARK
43bc						CALLMONITOR 
43bc cd ab 16			call break_point_state  
43bf				endm  
# End of macro CALLMONITOR
43bf					endif 
43bf ed b0				ldir 
43c1			 
43c1 e1					pop hl 
43c2 e5					push hl 
43c3 d5					push de 
43c4			 
43c4			 
43c4 3e 00				ld a, 0 
43c6 cd 6d 11				call strlent 
43c9 23					inc hl    ; zer0 
43ca 23					inc hl 
43cb 06 00				ld b, 0 
43cd 4d					ld c, l 
43ce d1					pop de 
43cf e1					pop hl		 
43d0					if DEBUG_FORTH_WORDS 
43d0						DMARK "CO2" 
43d0 f5				push af  
43d1 3a e5 43			ld a, (.dmark)  
43d4 32 6e fb			ld (debug_mark),a  
43d7 3a e6 43			ld a, (.dmark+1)  
43da 32 6f fb			ld (debug_mark+1),a  
43dd 3a e7 43			ld a, (.dmark+2)  
43e0 32 70 fb			ld (debug_mark+2),a  
43e3 18 03			jr .pastdmark  
43e5 ..			.dmark: db "CO2"  
43e8 f1			.pastdmark: pop af  
43e9			endm  
# End of macro DMARK
43e9						CALLMONITOR 
43e9 cd ab 16			call break_point_state  
43ec				endm  
# End of macro CALLMONITOR
43ec					endif 
43ec ed b0				ldir 
43ee			 
43ee			 
43ee			 
43ee 21 14 ee				ld hl, scratch 
43f1					if DEBUG_FORTH_WORDS 
43f1						DMARK "CO5" 
43f1 f5				push af  
43f2 3a 06 44			ld a, (.dmark)  
43f5 32 6e fb			ld (debug_mark),a  
43f8 3a 07 44			ld a, (.dmark+1)  
43fb 32 6f fb			ld (debug_mark+1),a  
43fe 3a 08 44			ld a, (.dmark+2)  
4401 32 70 fb			ld (debug_mark+2),a  
4404 18 03			jr .pastdmark  
4406 ..			.dmark: db "CO5"  
4409 f1			.pastdmark: pop af  
440a			endm  
# End of macro DMARK
440a						CALLMONITOR 
440a cd ab 16			call break_point_state  
440d				endm  
# End of macro CALLMONITOR
440d					endif 
440d			 
440d cd 76 1d				call forth_push_str 
4410			 
4410			 
4410			 
4410			 
4410				       NEXTW 
4410 c3 71 20			jp macro_next 
4413				endm 
# End of macro NEXTW
4413			 
4413			 
4413			.FIND: 
4413				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4413 4b				db WORD_SYS_CORE+55             
4414 d1 44			dw .LEN            
4416 05				db 4 + 1 
4417 .. 00			db "FIND",0              
441c				endm 
# End of macro CWHEAD
441c			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
441c			 
441c					if DEBUG_FORTH_WORDS_KEY 
441c						DMARK "FND" 
441c f5				push af  
441d 3a 31 44			ld a, (.dmark)  
4420 32 6e fb			ld (debug_mark),a  
4423 3a 32 44			ld a, (.dmark+1)  
4426 32 6f fb			ld (debug_mark+1),a  
4429 3a 33 44			ld a, (.dmark+2)  
442c 32 70 fb			ld (debug_mark+2),a  
442f 18 03			jr .pastdmark  
4431 ..			.dmark: db "FND"  
4434 f1			.pastdmark: pop af  
4435			endm  
# End of macro DMARK
4435						CALLMONITOR 
4435 cd ab 16			call break_point_state  
4438				endm  
# End of macro CALLMONITOR
4438					endif 
4438			 
4438			; TODO check string type 
4438					FORTH_DSP_VALUE 
4438 cd e8 1e			call macro_forth_dsp_value 
443b				endm 
# End of macro FORTH_DSP_VALUE
443b			 
443b e5					push hl    
443c 7e					ld a,(hl)    ; char to find   
443d			; TODO change char to substr 
443d			 
443d f5					push af 
443e					 
443e			 
443e			 
443e					if DEBUG_FORTH_WORDS 
443e						DMARK "FN1" 
443e f5				push af  
443f 3a 53 44			ld a, (.dmark)  
4442 32 6e fb			ld (debug_mark),a  
4445 3a 54 44			ld a, (.dmark+1)  
4448 32 6f fb			ld (debug_mark+1),a  
444b 3a 55 44			ld a, (.dmark+2)  
444e 32 70 fb			ld (debug_mark+2),a  
4451 18 03			jr .pastdmark  
4453 ..			.dmark: db "FN1"  
4456 f1			.pastdmark: pop af  
4457			endm  
# End of macro DMARK
4457						CALLMONITOR 
4457 cd ab 16			call break_point_state  
445a				endm  
# End of macro CALLMONITOR
445a					endif 
445a			 
445a					FORTH_DSP_POP 
445a cd b7 1f			call macro_forth_dsp_pop 
445d				endm 
# End of macro FORTH_DSP_POP
445d			 
445d					; string to search 
445d			 
445d					FORTH_DSP_VALUE 
445d cd e8 1e			call macro_forth_dsp_value 
4460				endm 
# End of macro FORTH_DSP_VALUE
4460			 
4460 d1					pop de  ; d is char to find  
4461			 
4461					if DEBUG_FORTH_WORDS 
4461						DMARK "FN2" 
4461 f5				push af  
4462 3a 76 44			ld a, (.dmark)  
4465 32 6e fb			ld (debug_mark),a  
4468 3a 77 44			ld a, (.dmark+1)  
446b 32 6f fb			ld (debug_mark+1),a  
446e 3a 78 44			ld a, (.dmark+2)  
4471 32 70 fb			ld (debug_mark+2),a  
4474 18 03			jr .pastdmark  
4476 ..			.dmark: db "FN2"  
4479 f1			.pastdmark: pop af  
447a			endm  
# End of macro DMARK
447a						CALLMONITOR 
447a cd ab 16			call break_point_state  
447d				endm  
# End of macro CALLMONITOR
447d					endif 
447d					 
447d 01 00 00				ld bc, 0 
4480 7e			.findchar:      ld a,(hl) 
4481 fe 00				cp 0   		 
4483 28 27				jr z, .finddone     
4485 ba					cp d 
4486 28 20				jr z, .foundchar 
4488 03					inc bc 
4489 23					inc hl 
448a					if DEBUG_FORTH_WORDS 
448a						DMARK "FN3" 
448a f5				push af  
448b 3a 9f 44			ld a, (.dmark)  
448e 32 6e fb			ld (debug_mark),a  
4491 3a a0 44			ld a, (.dmark+1)  
4494 32 6f fb			ld (debug_mark+1),a  
4497 3a a1 44			ld a, (.dmark+2)  
449a 32 70 fb			ld (debug_mark+2),a  
449d 18 03			jr .pastdmark  
449f ..			.dmark: db "FN3"  
44a2 f1			.pastdmark: pop af  
44a3			endm  
# End of macro DMARK
44a3						CALLMONITOR 
44a3 cd ab 16			call break_point_state  
44a6				endm  
# End of macro CALLMONITOR
44a6					endif 
44a6 18 d8				jr .findchar 
44a8			 
44a8			 
44a8 c5			.foundchar:	push bc 
44a9 e1					pop hl 
44aa 18 03				jr .findexit 
44ac			 
44ac			 
44ac							 
44ac			 
44ac			.finddone:     ; got to end of string with no find 
44ac 21 00 00				ld hl, 0 
44af			.findexit: 
44af			 
44af					if DEBUG_FORTH_WORDS 
44af						DMARK "FNd" 
44af f5				push af  
44b0 3a c4 44			ld a, (.dmark)  
44b3 32 6e fb			ld (debug_mark),a  
44b6 3a c5 44			ld a, (.dmark+1)  
44b9 32 6f fb			ld (debug_mark+1),a  
44bc 3a c6 44			ld a, (.dmark+2)  
44bf 32 70 fb			ld (debug_mark+2),a  
44c2 18 03			jr .pastdmark  
44c4 ..			.dmark: db "FNd"  
44c7 f1			.pastdmark: pop af  
44c8			endm  
# End of macro DMARK
44c8						CALLMONITOR 
44c8 cd ab 16			call break_point_state  
44cb				endm  
# End of macro CALLMONITOR
44cb					endif 
44cb cd 08 1d			call forth_push_numhl 
44ce			 
44ce				       NEXTW 
44ce c3 71 20			jp macro_next 
44d1				endm 
# End of macro NEXTW
44d1			 
44d1			.LEN: 
44d1				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
44d1 4c				db WORD_SYS_CORE+56             
44d2 06 45			dw .CHAR            
44d4 06				db 5 + 1 
44d5 .. 00			db "COUNT",0              
44db				endm 
# End of macro CWHEAD
44db			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
44db			 
44db					if DEBUG_FORTH_WORDS_KEY 
44db						DMARK "CNT" 
44db f5				push af  
44dc 3a f0 44			ld a, (.dmark)  
44df 32 6e fb			ld (debug_mark),a  
44e2 3a f1 44			ld a, (.dmark+1)  
44e5 32 6f fb			ld (debug_mark+1),a  
44e8 3a f2 44			ld a, (.dmark+2)  
44eb 32 70 fb			ld (debug_mark+2),a  
44ee 18 03			jr .pastdmark  
44f0 ..			.dmark: db "CNT"  
44f3 f1			.pastdmark: pop af  
44f4			endm  
# End of macro DMARK
44f4						CALLMONITOR 
44f4 cd ab 16			call break_point_state  
44f7				endm  
# End of macro CALLMONITOR
44f7					endif 
44f7			; TODO check string type 
44f7					FORTH_DSP 
44f7 cd c5 1e			call macro_forth_dsp 
44fa				endm 
# End of macro FORTH_DSP
44fa					;v5FORTH_DSP_VALUE 
44fa			 
44fa 23					inc hl 
44fb			 
44fb 3e 00				ld a, 0 
44fd cd 6d 11				call strlent 
4500			 
4500 cd 08 1d				call forth_push_numhl 
4503			 
4503			 
4503			 
4503				       NEXTW 
4503 c3 71 20			jp macro_next 
4506				endm 
# End of macro NEXTW
4506			.CHAR: 
4506				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
4506 4d				db WORD_SYS_CORE+57             
4507 3c 45			dw .ENDSTR            
4509 05				db 4 + 1 
450a .. 00			db "CHAR",0              
450f				endm 
# End of macro CWHEAD
450f			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
450f					if DEBUG_FORTH_WORDS_KEY 
450f						DMARK "CHR" 
450f f5				push af  
4510 3a 24 45			ld a, (.dmark)  
4513 32 6e fb			ld (debug_mark),a  
4516 3a 25 45			ld a, (.dmark+1)  
4519 32 6f fb			ld (debug_mark+1),a  
451c 3a 26 45			ld a, (.dmark+2)  
451f 32 70 fb			ld (debug_mark+2),a  
4522 18 03			jr .pastdmark  
4524 ..			.dmark: db "CHR"  
4527 f1			.pastdmark: pop af  
4528			endm  
# End of macro DMARK
4528						CALLMONITOR 
4528 cd ab 16			call break_point_state  
452b				endm  
# End of macro CALLMONITOR
452b					endif 
452b					FORTH_DSP 
452b cd c5 1e			call macro_forth_dsp 
452e				endm 
# End of macro FORTH_DSP
452e					;v5 FORTH_DSP_VALUE 
452e 23					inc hl      ; now at start of numeric as string 
452f			 
452f			;		push hl 
452f			 
452f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
452f cd b7 1f			call macro_forth_dsp_pop 
4532				endm 
# End of macro FORTH_DSP_POP
4532			 
4532			;		pop hl 
4532			 
4532					; push the content of a onto the stack as a value 
4532			 
4532 7e					ld a,(hl)   ; get char 
4533 26 00				ld h,0 
4535 6f					ld l,a 
4536 cd 08 1d				call forth_push_numhl 
4539			 
4539				       NEXTW 
4539 c3 71 20			jp macro_next 
453c				endm 
# End of macro NEXTW
453c			 
453c			 
453c			 
453c			 
453c			.ENDSTR: 
453c			; eof 
453c			 
# End of file forth_words_str.asm
453c			include "forth_words_key.asm" 
453c			 
453c			; | ## Keyboard Words 
453c			 
453c			.KEY: 
453c				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
453c 3e				db WORD_SYS_CORE+42             
453d 6c 45			dw .WAITK            
453f 04				db 3 + 1 
4540 .. 00			db "KEY",0              
4544				endm 
# End of macro CWHEAD
4544			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4544			 
4544					if DEBUG_FORTH_WORDS_KEY 
4544						DMARK "KEY" 
4544 f5				push af  
4545 3a 59 45			ld a, (.dmark)  
4548 32 6e fb			ld (debug_mark),a  
454b 3a 5a 45			ld a, (.dmark+1)  
454e 32 6f fb			ld (debug_mark+1),a  
4551 3a 5b 45			ld a, (.dmark+2)  
4554 32 70 fb			ld (debug_mark+2),a  
4557 18 03			jr .pastdmark  
4559 ..			.dmark: db "KEY"  
455c f1			.pastdmark: pop af  
455d			endm  
# End of macro DMARK
455d						CALLMONITOR 
455d cd ab 16			call break_point_state  
4560				endm  
# End of macro CALLMONITOR
4560					endif 
4560			; TODO currently waits 
4560 cd 65 69				call cin 
4563					;call cin_wait 
4563 6f					ld l, a 
4564 26 00				ld h, 0 
4566 cd 08 1d				call forth_push_numhl 
4569					NEXTW 
4569 c3 71 20			jp macro_next 
456c				endm 
# End of macro NEXTW
456c			.WAITK: 
456c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
456c 3f				db WORD_SYS_CORE+43             
456d 9e 45			dw .ACCEPT            
456f 06				db 5 + 1 
4570 .. 00			db "WAITK",0              
4576				endm 
# End of macro CWHEAD
4576			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4576					if DEBUG_FORTH_WORDS_KEY 
4576						DMARK "WAI" 
4576 f5				push af  
4577 3a 8b 45			ld a, (.dmark)  
457a 32 6e fb			ld (debug_mark),a  
457d 3a 8c 45			ld a, (.dmark+1)  
4580 32 6f fb			ld (debug_mark+1),a  
4583 3a 8d 45			ld a, (.dmark+2)  
4586 32 70 fb			ld (debug_mark+2),a  
4589 18 03			jr .pastdmark  
458b ..			.dmark: db "WAI"  
458e f1			.pastdmark: pop af  
458f			endm  
# End of macro DMARK
458f						CALLMONITOR 
458f cd ab 16			call break_point_state  
4592				endm  
# End of macro CALLMONITOR
4592					endif 
4592 cd 54 69				call cin_wait 
4595 6f					ld l, a 
4596 26 00				ld h, 0 
4598 cd 08 1d				call forth_push_numhl 
459b					NEXTW 
459b c3 71 20			jp macro_next 
459e				endm 
# End of macro NEXTW
459e			.ACCEPT: 
459e				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
459e 40				db WORD_SYS_CORE+44             
459f fc 45			dw .EDIT            
45a1 07				db 6 + 1 
45a2 .. 00			db "ACCEPT",0              
45a9				endm 
# End of macro CWHEAD
45a9			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
45a9					; TODO crashes on push 
45a9					if DEBUG_FORTH_WORDS_KEY 
45a9						DMARK "ACC" 
45a9 f5				push af  
45aa 3a be 45			ld a, (.dmark)  
45ad 32 6e fb			ld (debug_mark),a  
45b0 3a bf 45			ld a, (.dmark+1)  
45b3 32 6f fb			ld (debug_mark+1),a  
45b6 3a c0 45			ld a, (.dmark+2)  
45b9 32 70 fb			ld (debug_mark+2),a  
45bc 18 03			jr .pastdmark  
45be ..			.dmark: db "ACC"  
45c1 f1			.pastdmark: pop af  
45c2			endm  
# End of macro DMARK
45c2						CALLMONITOR 
45c2 cd ab 16			call break_point_state  
45c5				endm  
# End of macro CALLMONITOR
45c5					endif 
45c5 21 12 f0				ld hl, os_input 
45c8 3e 00				ld a, 0 
45ca 77					ld (hl),a 
45cb 3a 3d f8				ld a,(f_cursor_ptr) 
45ce 16 64				ld d, 100 
45d0 0e 00				ld c, 0 
45d2 1e 28				ld e, 40 
45d4 cd 31 0d				call input_str 
45d7					; TODO perhaps do a type check and wrap in quotes if not a number 
45d7 21 12 f0				ld hl, os_input 
45da					if DEBUG_FORTH_WORDS 
45da						DMARK "AC1" 
45da f5				push af  
45db 3a ef 45			ld a, (.dmark)  
45de 32 6e fb			ld (debug_mark),a  
45e1 3a f0 45			ld a, (.dmark+1)  
45e4 32 6f fb			ld (debug_mark+1),a  
45e7 3a f1 45			ld a, (.dmark+2)  
45ea 32 70 fb			ld (debug_mark+2),a  
45ed 18 03			jr .pastdmark  
45ef ..			.dmark: db "AC1"  
45f2 f1			.pastdmark: pop af  
45f3			endm  
# End of macro DMARK
45f3						CALLMONITOR 
45f3 cd ab 16			call break_point_state  
45f6				endm  
# End of macro CALLMONITOR
45f6					endif 
45f6 cd 76 1d				call forth_push_str 
45f9					NEXTW 
45f9 c3 71 20			jp macro_next 
45fc				endm 
# End of macro NEXTW
45fc			 
45fc			.EDIT: 
45fc				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
45fc 40				db WORD_SYS_CORE+44             
45fd 9e 46			dw .ENDKEY            
45ff 05				db 4 + 1 
4600 .. 00			db "EDIT",0              
4605				endm 
# End of macro CWHEAD
4605			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4605			 
4605					; TODO does not copy from stack 
4605					if DEBUG_FORTH_WORDS_KEY 
4605						DMARK "EDT" 
4605 f5				push af  
4606 3a 1a 46			ld a, (.dmark)  
4609 32 6e fb			ld (debug_mark),a  
460c 3a 1b 46			ld a, (.dmark+1)  
460f 32 6f fb			ld (debug_mark+1),a  
4612 3a 1c 46			ld a, (.dmark+2)  
4615 32 70 fb			ld (debug_mark+2),a  
4618 18 03			jr .pastdmark  
461a ..			.dmark: db "EDT"  
461d f1			.pastdmark: pop af  
461e			endm  
# End of macro DMARK
461e						CALLMONITOR 
461e cd ab 16			call break_point_state  
4621				endm  
# End of macro CALLMONITOR
4621					endif 
4621			 
4621					;FORTH_DSP 
4621					FORTH_DSP_VALUEHL 
4621 cd ff 1e			call macro_dsp_valuehl 
4624				endm 
# End of macro FORTH_DSP_VALUEHL
4624			;		inc hl    ; TODO do type check 
4624			 
4624			;		call get_word_hl 
4624 e5					push hl 
4625					if DEBUG_FORTH_WORDS 
4625						DMARK "EDp" 
4625 f5				push af  
4626 3a 3a 46			ld a, (.dmark)  
4629 32 6e fb			ld (debug_mark),a  
462c 3a 3b 46			ld a, (.dmark+1)  
462f 32 6f fb			ld (debug_mark+1),a  
4632 3a 3c 46			ld a, (.dmark+2)  
4635 32 70 fb			ld (debug_mark+2),a  
4638 18 03			jr .pastdmark  
463a ..			.dmark: db "EDp"  
463d f1			.pastdmark: pop af  
463e			endm  
# End of macro DMARK
463e						CALLMONITOR 
463e cd ab 16			call break_point_state  
4641				endm  
# End of macro CALLMONITOR
4641					endif 
4641				;	ld a, 0 
4641 cd 62 11				call strlenz 
4644 23					inc hl 
4645			 
4645 06 00				ld b, 0 
4647 4d					ld c, l 
4648			 
4648 e1					pop hl 
4649 11 12 f0				ld de, os_input 
464c					if DEBUG_FORTH_WORDS_KEY 
464c						DMARK "EDc" 
464c f5				push af  
464d 3a 61 46			ld a, (.dmark)  
4650 32 6e fb			ld (debug_mark),a  
4653 3a 62 46			ld a, (.dmark+1)  
4656 32 6f fb			ld (debug_mark+1),a  
4659 3a 63 46			ld a, (.dmark+2)  
465c 32 70 fb			ld (debug_mark+2),a  
465f 18 03			jr .pastdmark  
4661 ..			.dmark: db "EDc"  
4664 f1			.pastdmark: pop af  
4665			endm  
# End of macro DMARK
4665						CALLMONITOR 
4665 cd ab 16			call break_point_state  
4668				endm  
# End of macro CALLMONITOR
4668					endif 
4668 ed b0				ldir 
466a			 
466a			 
466a 21 12 f0				ld hl, os_input 
466d					;ld a, 0 
466d					;ld (hl),a 
466d 3a 3d f8				ld a,(f_cursor_ptr) 
4670 16 64				ld d, 100 
4672 0e 00				ld c, 0 
4674 1e 28				ld e, 40 
4676 cd 31 0d				call input_str 
4679					; TODO perhaps do a type check and wrap in quotes if not a number 
4679 21 12 f0				ld hl, os_input 
467c					if DEBUG_FORTH_WORDS 
467c						DMARK "ED1" 
467c f5				push af  
467d 3a 91 46			ld a, (.dmark)  
4680 32 6e fb			ld (debug_mark),a  
4683 3a 92 46			ld a, (.dmark+1)  
4686 32 6f fb			ld (debug_mark+1),a  
4689 3a 93 46			ld a, (.dmark+2)  
468c 32 70 fb			ld (debug_mark+2),a  
468f 18 03			jr .pastdmark  
4691 ..			.dmark: db "ED1"  
4694 f1			.pastdmark: pop af  
4695			endm  
# End of macro DMARK
4695						CALLMONITOR 
4695 cd ab 16			call break_point_state  
4698				endm  
# End of macro CALLMONITOR
4698					endif 
4698 cd 76 1d				call forth_push_str 
469b					NEXTW 
469b c3 71 20			jp macro_next 
469e				endm 
# End of macro NEXTW
469e			 
469e			 
469e			 
469e			.ENDKEY: 
469e			; eof 
469e			 
# End of file forth_words_key.asm
469e			 
469e			if STORAGE_SE 
469e			   	include "forth_words_storage.asm" 
469e			 
469e			; | ## Fixed Storage Words 
469e			 
469e			 
469e			.BREAD: 
469e			  
469e				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
469e 3a				db WORD_SYS_CORE+38             
469f 21 47			dw .BWRITE            
46a1 06				db 5 + 1 
46a2 .. 00			db "BREAD",0              
46a8				endm 
# End of macro CWHEAD
46a8			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
46a8				 
46a8					if DEBUG_FORTH_WORDS_KEY 
46a8						DMARK "BRD" 
46a8 f5				push af  
46a9 3a bd 46			ld a, (.dmark)  
46ac 32 6e fb			ld (debug_mark),a  
46af 3a be 46			ld a, (.dmark+1)  
46b2 32 6f fb			ld (debug_mark+1),a  
46b5 3a bf 46			ld a, (.dmark+2)  
46b8 32 70 fb			ld (debug_mark+2),a  
46bb 18 03			jr .pastdmark  
46bd ..			.dmark: db "BRD"  
46c0 f1			.pastdmark: pop af  
46c1			endm  
# End of macro DMARK
46c1						CALLMONITOR 
46c1 cd ab 16			call break_point_state  
46c4				endm  
# End of macro CALLMONITOR
46c4					endif 
46c4			 
46c4				FORTH_DSP_VALUEHL 
46c4 cd ff 1e			call macro_dsp_valuehl 
46c7				endm 
# End of macro FORTH_DSP_VALUEHL
46c7			 
46c7				FORTH_DSP_POP 
46c7 cd b7 1f			call macro_forth_dsp_pop 
46ca				endm 
# End of macro FORTH_DSP_POP
46ca			 
46ca				; calc block address 
46ca			 
46ca eb				ex de, hl 
46cb 3e 40			ld a, STORE_BLOCK_PHY 
46cd cd 87 0c			call Mult16 
46d0			 
46d0			 
46d0 11 59 f8			ld de, store_page 
46d3			 
46d3					if DEBUG_FORTH_WORDS 
46d3						DMARK "BR1" 
46d3 f5				push af  
46d4 3a e8 46			ld a, (.dmark)  
46d7 32 6e fb			ld (debug_mark),a  
46da 3a e9 46			ld a, (.dmark+1)  
46dd 32 6f fb			ld (debug_mark+1),a  
46e0 3a ea 46			ld a, (.dmark+2)  
46e3 32 70 fb			ld (debug_mark+2),a  
46e6 18 03			jr .pastdmark  
46e8 ..			.dmark: db "BR1"  
46eb f1			.pastdmark: pop af  
46ec			endm  
# End of macro DMARK
46ec						CALLMONITOR 
46ec cd ab 16			call break_point_state  
46ef				endm  
# End of macro CALLMONITOR
46ef					endif 
46ef			 
46ef cd e2 02			call storage_read_block 
46f2			 
46f2 cd 2d 0d			call ishlzero 
46f5 20 05			jr nz, .brfound 
46f7			 
46f7 cd 08 1d			call forth_push_numhl 
46fa 18 22			jr .brdone 
46fc			 
46fc			 
46fc			.brfound: 
46fc 21 5b f8		        ld hl, store_page+2 
46ff			 
46ff					if DEBUG_FORTH_WORDS 
46ff						DMARK "BR2" 
46ff f5				push af  
4700 3a 14 47			ld a, (.dmark)  
4703 32 6e fb			ld (debug_mark),a  
4706 3a 15 47			ld a, (.dmark+1)  
4709 32 6f fb			ld (debug_mark+1),a  
470c 3a 16 47			ld a, (.dmark+2)  
470f 32 70 fb			ld (debug_mark+2),a  
4712 18 03			jr .pastdmark  
4714 ..			.dmark: db "BR2"  
4717 f1			.pastdmark: pop af  
4718			endm  
# End of macro DMARK
4718						CALLMONITOR 
4718 cd ab 16			call break_point_state  
471b				endm  
# End of macro CALLMONITOR
471b					endif 
471b			 
471b cd 76 1d			call forth_push_str 
471e			 
471e			 
471e			.brdone: 
471e			 
471e					NEXTW 
471e c3 71 20			jp macro_next 
4721				endm 
# End of macro NEXTW
4721			.BWRITE: 
4721				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4721 3a				db WORD_SYS_CORE+38             
4722 b6 47			dw .BUPD            
4724 07				db 6 + 1 
4725 .. 00			db "BWRITE",0              
472c				endm 
# End of macro CWHEAD
472c			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
472c			 
472c					if DEBUG_FORTH_WORDS_KEY 
472c						DMARK "BWR" 
472c f5				push af  
472d 3a 41 47			ld a, (.dmark)  
4730 32 6e fb			ld (debug_mark),a  
4733 3a 42 47			ld a, (.dmark+1)  
4736 32 6f fb			ld (debug_mark+1),a  
4739 3a 43 47			ld a, (.dmark+2)  
473c 32 70 fb			ld (debug_mark+2),a  
473f 18 03			jr .pastdmark  
4741 ..			.dmark: db "BWR"  
4744 f1			.pastdmark: pop af  
4745			endm  
# End of macro DMARK
4745						CALLMONITOR 
4745 cd ab 16			call break_point_state  
4748				endm  
# End of macro CALLMONITOR
4748					endif 
4748			 
4748				FORTH_DSP_VALUEHL 
4748 cd ff 1e			call macro_dsp_valuehl 
474b				endm 
# End of macro FORTH_DSP_VALUEHL
474b			 
474b				; calc block address 
474b			 
474b eb				ex de, hl 
474c 3e 40			ld a, STORE_BLOCK_PHY 
474e cd 87 0c			call Mult16 
4751			 
4751 e5				push hl         ; address 
4752			 
4752				FORTH_DSP_POP 
4752 cd b7 1f			call macro_forth_dsp_pop 
4755				endm 
# End of macro FORTH_DSP_POP
4755			 
4755				FORTH_DSP_VALUEHL 
4755 cd ff 1e			call macro_dsp_valuehl 
4758				endm 
# End of macro FORTH_DSP_VALUEHL
4758			 
4758				FORTH_DSP_POP 
4758 cd b7 1f			call macro_forth_dsp_pop 
475b				endm 
# End of macro FORTH_DSP_POP
475b			 
475b cd 10 0a			call storage_clear_page 
475e			 
475e				; copy string to store page 
475e			 
475e e5				push hl     ; save string address 
475f			 
475f 3e 00			ld a, 0 
4761 cd 6d 11			call strlent 
4764			 
4764 23				inc hl 
4765			 
4765 4d				ld c, l 
4766 06 00			ld b, 0 
4768			 
4768 e1				pop hl 
4769 11 5b f8			ld de, store_page + 2 
476c					if DEBUG_FORTH_WORDS 
476c						DMARK "BW1" 
476c f5				push af  
476d 3a 81 47			ld a, (.dmark)  
4770 32 6e fb			ld (debug_mark),a  
4773 3a 82 47			ld a, (.dmark+1)  
4776 32 6f fb			ld (debug_mark+1),a  
4779 3a 83 47			ld a, (.dmark+2)  
477c 32 70 fb			ld (debug_mark+2),a  
477f 18 03			jr .pastdmark  
4781 ..			.dmark: db "BW1"  
4784 f1			.pastdmark: pop af  
4785			endm  
# End of macro DMARK
4785						CALLMONITOR 
4785 cd ab 16			call break_point_state  
4788				endm  
# End of macro CALLMONITOR
4788					endif 
4788 ed b0			ldir 
478a			 
478a			 
478a				; poke the start of the block with flags to prevent high level file ops hitting the block 
478a			 
478a 21 ff ff			ld hl, $ffff 
478d			 
478d 22 59 f8			ld (store_page), hl	 
4790				 
4790 e1				pop hl    ; get address 
4791 11 59 f8			ld de, store_page 
4794			 
4794					if DEBUG_FORTH_WORDS 
4794						DMARK "BW2" 
4794 f5				push af  
4795 3a a9 47			ld a, (.dmark)  
4798 32 6e fb			ld (debug_mark),a  
479b 3a aa 47			ld a, (.dmark+1)  
479e 32 6f fb			ld (debug_mark+1),a  
47a1 3a ab 47			ld a, (.dmark+2)  
47a4 32 70 fb			ld (debug_mark+2),a  
47a7 18 03			jr .pastdmark  
47a9 ..			.dmark: db "BW2"  
47ac f1			.pastdmark: pop af  
47ad			endm  
# End of macro DMARK
47ad						CALLMONITOR 
47ad cd ab 16			call break_point_state  
47b0				endm  
# End of macro CALLMONITOR
47b0					endif 
47b0			 
47b0 cd 47 03			call storage_write_block 
47b3			 
47b3					NEXTW 
47b3 c3 71 20			jp macro_next 
47b6				endm 
# End of macro NEXTW
47b6			 
47b6			.BUPD: 
47b6				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
47b6 3a				db WORD_SYS_CORE+38             
47b7 0c 48			dw .BYID            
47b9 05				db 4 + 1 
47ba .. 00			db "BUPD",0              
47bf				endm 
# End of macro CWHEAD
47bf			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
47bf			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
47bf			; | | or completely different file system structure. 
47bf			 
47bf					if DEBUG_FORTH_WORDS_KEY 
47bf						DMARK "BUD" 
47bf f5				push af  
47c0 3a d4 47			ld a, (.dmark)  
47c3 32 6e fb			ld (debug_mark),a  
47c6 3a d5 47			ld a, (.dmark+1)  
47c9 32 6f fb			ld (debug_mark+1),a  
47cc 3a d6 47			ld a, (.dmark+2)  
47cf 32 70 fb			ld (debug_mark+2),a  
47d2 18 03			jr .pastdmark  
47d4 ..			.dmark: db "BUD"  
47d7 f1			.pastdmark: pop af  
47d8			endm  
# End of macro DMARK
47d8						CALLMONITOR 
47d8 cd ab 16			call break_point_state  
47db				endm  
# End of macro CALLMONITOR
47db					endif 
47db			 
47db				FORTH_DSP_VALUEHL 
47db cd ff 1e			call macro_dsp_valuehl 
47de				endm 
# End of macro FORTH_DSP_VALUEHL
47de			 
47de				; calc block address 
47de			 
47de eb				ex de, hl 
47df 3e 40			ld a, STORE_BLOCK_PHY 
47e1 cd 87 0c			call Mult16 
47e4			 
47e4				FORTH_DSP_POP 
47e4 cd b7 1f			call macro_forth_dsp_pop 
47e7				endm 
# End of macro FORTH_DSP_POP
47e7			 
47e7			 
47e7 11 59 f8			ld de, store_page 
47ea			 
47ea					if DEBUG_FORTH_WORDS 
47ea						DMARK "BUe" 
47ea f5				push af  
47eb 3a ff 47			ld a, (.dmark)  
47ee 32 6e fb			ld (debug_mark),a  
47f1 3a 00 48			ld a, (.dmark+1)  
47f4 32 6f fb			ld (debug_mark+1),a  
47f7 3a 01 48			ld a, (.dmark+2)  
47fa 32 70 fb			ld (debug_mark+2),a  
47fd 18 03			jr .pastdmark  
47ff ..			.dmark: db "BUe"  
4802 f1			.pastdmark: pop af  
4803			endm  
# End of macro DMARK
4803						CALLMONITOR 
4803 cd ab 16			call break_point_state  
4806				endm  
# End of macro CALLMONITOR
4806					endif 
4806			 
4806 cd 47 03			call storage_write_block 
4809			 
4809					NEXTW 
4809 c3 71 20			jp macro_next 
480c				endm 
# End of macro NEXTW
480c			 
480c			.BYID: 
480c			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
480c			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
480c			; 
480c			;		 
480c			;		if DEBUG_FORTH_WORDS_KEY 
480c			;			DMARK "BYID" 
480c			;			CALLMONITOR 
480c			;		endif 
480c			; 
480c			;		; get direct address 
480c			; 
480c			;		FORTH_DSP_VALUEHL 
480c			; 
480c			;		FORTH_DSP_POP 
480c			; 
480c			;	; calc block address 
480c			; 
480c			;	ex de, hl 
480c			;	ld a, STORE_BLOCK_PHY 
480c			;	call Mult16 
480c			;	;	do BREAD with number as param 
480c			;	; push the file name	 
480c			;	ld de, store_page 
480c			;	call storage_read_block 
480c			 ;       ld hl, store_page+2 
480c			; 
480c			; 
480c			;		NEXTW 
480c			;.BYNAME: 
480c			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
480c			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
480c			;		NEXTW 
480c			; 
480c			.DIR: 
480c				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
480c 3a				db WORD_SYS_CORE+38             
480d 10 49			dw .SAVE            
480f 04				db 3 + 1 
4810 .. 00			db "DIR",0              
4814				endm 
# End of macro CWHEAD
4814			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4814			 
4814					if DEBUG_FORTH_WORDS_KEY 
4814						DMARK "DIR" 
4814 f5				push af  
4815 3a 29 48			ld a, (.dmark)  
4818 32 6e fb			ld (debug_mark),a  
481b 3a 2a 48			ld a, (.dmark+1)  
481e 32 6f fb			ld (debug_mark+1),a  
4821 3a 2b 48			ld a, (.dmark+2)  
4824 32 70 fb			ld (debug_mark+2),a  
4827 18 03			jr .pastdmark  
4829 ..			.dmark: db "DIR"  
482c f1			.pastdmark: pop af  
482d			endm  
# End of macro DMARK
482d						CALLMONITOR 
482d cd ab 16			call break_point_state  
4830				endm  
# End of macro CALLMONITOR
4830					endif 
4830 cd 93 03			call storage_get_block_0 
4833			 
4833 21 59 f8			ld hl, store_page     ; get current id count 
4836 46				ld b, (hl) 
4837 0e 00			ld c, 0    ; count of files   
4839					if DEBUG_FORTH_WORDS 
4839						DMARK "DI1" 
4839 f5				push af  
483a 3a 4e 48			ld a, (.dmark)  
483d 32 6e fb			ld (debug_mark),a  
4840 3a 4f 48			ld a, (.dmark+1)  
4843 32 6f fb			ld (debug_mark+1),a  
4846 3a 50 48			ld a, (.dmark+2)  
4849 32 70 fb			ld (debug_mark+2),a  
484c 18 03			jr .pastdmark  
484e ..			.dmark: db "DI1"  
4851 f1			.pastdmark: pop af  
4852			endm  
# End of macro DMARK
4852						CALLMONITOR 
4852 cd ab 16			call break_point_state  
4855				endm  
# End of macro CALLMONITOR
4855					endif 
4855			 
4855				; check for empty drive 
4855			 
4855 3e 00			ld a, 0 
4857 b8				cp b 
4858 ca c6 48			jp z, .dirdone 
485b			 
485b				; for each of the current ids do a search for them and if found push to stack 
485b			 
485b c5			.diritem:	push bc 
485c 21 40 00				ld hl, STORE_BLOCK_PHY 
485f 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4861 58					ld e,b 
4862			 
4862			;		if DEBUG_FORTH_WORDS 
4862			;			DMARK "DI2" 
4862			;			CALLMONITOR 
4862			;		endif 
4862			 
4862 cd 15 06				call storage_findnextid 
4865			 
4865			;		if DEBUG_FORTH_WORDS 
4865			;			DMARK "DI3" 
4865			;			CALLMONITOR 
4865			;		endif 
4865			 
4865					; if found hl will be non zero 
4865			 
4865 cd 2d 0d				call ishlzero 
4868			;		ld a, l 
4868			;		add h 
4868			; 
4868			;		cp 0 
4868 28 59				jr z, .dirnotfound 
486a			 
486a					; increase count 
486a			 
486a c1					pop bc	 
486b 0c					inc c 
486c c5					push bc 
486d					 
486d			 
486d					; get file header and push the file name 
486d			 
486d 11 59 f8				ld de, store_page 
4870 cd e2 02				call storage_read_block 
4873			 
4873					; push file id to stack 
4873				 
4873 3a 59 f8				ld a, (store_page) 
4876 26 00				ld h, 0 
4878 6f					ld l, a 
4879 cd 08 1d				call forth_push_numhl 
487c			 
487c					; push extent count to stack  
487c				 
487c 3a 5b f8				ld a, (store_page+2) 
487f 26 00				ld h, 0 
4881 6f					ld l, a 
4882 cd 08 1d				call forth_push_numhl 
4885			 
4885					; push file name 
4885			 
4885 21 5c f8				ld hl, store_page+3 
4888					if DEBUG_FORTH_WORDS 
4888						DMARK "DI5" 
4888 f5				push af  
4889 3a 9d 48			ld a, (.dmark)  
488c 32 6e fb			ld (debug_mark),a  
488f 3a 9e 48			ld a, (.dmark+1)  
4892 32 6f fb			ld (debug_mark+1),a  
4895 3a 9f 48			ld a, (.dmark+2)  
4898 32 70 fb			ld (debug_mark+2),a  
489b 18 03			jr .pastdmark  
489d ..			.dmark: db "DI5"  
48a0 f1			.pastdmark: pop af  
48a1			endm  
# End of macro DMARK
48a1						CALLMONITOR 
48a1 cd ab 16			call break_point_state  
48a4				endm  
# End of macro CALLMONITOR
48a4					endif 
48a4 cd 76 1d				call forth_push_str 
48a7					if DEBUG_FORTH_WORDS 
48a7						DMARK "DI6" 
48a7 f5				push af  
48a8 3a bc 48			ld a, (.dmark)  
48ab 32 6e fb			ld (debug_mark),a  
48ae 3a bd 48			ld a, (.dmark+1)  
48b1 32 6f fb			ld (debug_mark+1),a  
48b4 3a be 48			ld a, (.dmark+2)  
48b7 32 70 fb			ld (debug_mark+2),a  
48ba 18 03			jr .pastdmark  
48bc ..			.dmark: db "DI6"  
48bf f1			.pastdmark: pop af  
48c0			endm  
# End of macro DMARK
48c0						CALLMONITOR 
48c0 cd ab 16			call break_point_state  
48c3				endm  
# End of macro CALLMONITOR
48c3					endif 
48c3			.dirnotfound: 
48c3 c1					pop bc     
48c4 10 95				djnz .diritem 
48c6				 
48c6			.dirdone:	 
48c6					if DEBUG_FORTH_WORDS 
48c6						DMARK "DI7" 
48c6 f5				push af  
48c7 3a db 48			ld a, (.dmark)  
48ca 32 6e fb			ld (debug_mark),a  
48cd 3a dc 48			ld a, (.dmark+1)  
48d0 32 6f fb			ld (debug_mark+1),a  
48d3 3a dd 48			ld a, (.dmark+2)  
48d6 32 70 fb			ld (debug_mark+2),a  
48d9 18 03			jr .pastdmark  
48db ..			.dmark: db "DI7"  
48de f1			.pastdmark: pop af  
48df			endm  
# End of macro DMARK
48df						CALLMONITOR 
48df cd ab 16			call break_point_state  
48e2				endm  
# End of macro CALLMONITOR
48e2					endif 
48e2			 
48e2					; push a count of the dir items found 
48e2			 
48e2 26 00				ld h, 0 
48e4 69					ld l, c 
48e5 cd 08 1d				call forth_push_numhl 
48e8			 
48e8					; push the bank label 
48e8			 
48e8 cd 93 03				call storage_get_block_0 
48eb			 
48eb				 
48eb 21 5c f8		 		ld hl, store_page+3 
48ee			 
48ee					if DEBUG_FORTH_WORDS 
48ee						DMARK "DI8" 
48ee f5				push af  
48ef 3a 03 49			ld a, (.dmark)  
48f2 32 6e fb			ld (debug_mark),a  
48f5 3a 04 49			ld a, (.dmark+1)  
48f8 32 6f fb			ld (debug_mark+1),a  
48fb 3a 05 49			ld a, (.dmark+2)  
48fe 32 70 fb			ld (debug_mark+2),a  
4901 18 03			jr .pastdmark  
4903 ..			.dmark: db "DI8"  
4906 f1			.pastdmark: pop af  
4907			endm  
# End of macro DMARK
4907						CALLMONITOR 
4907 cd ab 16			call break_point_state  
490a				endm  
# End of macro CALLMONITOR
490a					endif 
490a cd 76 1d				call forth_push_str 
490d			 
490d			 
490d				 
490d					NEXTW 
490d c3 71 20			jp macro_next 
4910				endm 
# End of macro NEXTW
4910			.SAVE: 
4910			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4910			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4910			;		NEXTW 
4910			;.LOAD: 
4910			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4910			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4910			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4910			;; > > The LOAD command can not be used in any user words or compound lines. 
4910			; 
4910			;		; store_openext use it. If zero it is EOF 
4910			; 
4910			;		; read block from current stream id 
4910			;		; if the block does not contain zero term keep reading blocks until zero found 
4910			;		; push the block to stack 
4910			;		; save the block id to stream 
4910			; 
4910			; 
4910			;		FORTH_DSP_VALUEHL 
4910			; 
4910			;;		push hl 
4910			; 
4910			;	if DEBUG_STORESE 
4910			;		DMARK "LOA" 
4910			;		CALLMONITOR 
4910			;	endif 
4910			;		FORTH_DSP_POP 
4910			; 
4910			;;		pop hl 
4910			; 
4910			;		ld h, l 
4910			;		ld l, 0 
4910			; 
4910			;		push hl     ; stack holds current file id and extent to work with 
4910			; 
4910			; 
4910			;		ld de, store_page      ; get block zero of file 
4910			;	if DEBUG_STORESE 
4910			;		DMARK "LO0" 
4910			;		CALLMONITOR 
4910			;	endif 
4910			;		call storage_read 
4910			; 
4910			;		ld a, (store_page+2)    ; max extents for this file 
4910			;		ld  (store_openmaxext),a   ; get our limit 
4910			; 
4910			;	if DEBUG_STORESE 
4910			;		DMARK "LOE" 
4910			;		CALLMONITOR 
4910			;	endif 
4910			; 
4910			;; TODO dont know why max extents are not present 
4910			;;		cp 0 
4910			;;		jp z, .loadeof     ; dont read past eof 
4910			; 
4910			;;		ld a, 1   ; start from the head of the file 
4910			; 
4910			;.loadline:	pop hl 
4910			;		inc hl 
4910			;		ld  a, (store_openmaxext)   ; get our limit 
4910			;	if DEBUG_STORESE 
4910			;		DMARK "LOx" 
4910			;		CALLMONITOR 
4910			;	endif 
4910			;		inc a 
4910			;		cp l 
4910			;		jp z, .loadeof 
4910			;		push hl    ; save current extent 
4910			; 
4910			;		ld de, store_page 
4910			; 
4910			;	if DEBUG_STORESE 
4910			;		DMARK "LO1" 
4910			;		CALLMONITOR 
4910			;	endif 
4910			;		call storage_read 
4910			; 
4910			;	if DEBUG_STORESE 
4910			;		DMARK "LO2" 
4910			;		CALLMONITOR 
4910			;	endif 
4910			;	call ishlzero 
4910			;	ld a, l 
4910			;	add h 
4910			;	cp 0 
4910			;	jr z, .loadeof 
4910			; 
4910			;	; not eof so hl should point to data to exec 
4910			; 
4910			;	; will need to add the FORTH_END_BUFFER flag 
4910			 ; 
4910			;	ld hl, store_page+2 
4910			;	ld bc, 255 
4910			;	ld a, 0 
4910			;	cpir 
4910			;	if DEBUG_STORESE 
4910			;		DMARK "LOt" 
4910			;		CALLMONITOR 
4910			;	endif 
4910			;	dec hl 
4910			;	ld a, ' ' 
4910			;	ld (hl), a 
4910			;	inc hl 
4910			;	ld (hl), a 
4910			;	inc hl 
4910			;	ld (hl), a 
4910			;	inc hl 
4910			;	ld a, FORTH_END_BUFFER 
4910			;	ld (hl), a 
4910			; 
4910			;	; TODO handle more than a single block read 
4910			; 
4910			; 
4910			;	ld hl, store_page+2 
4910			; 
4910			;	ld (os_tok_ptr), hl 
4910			; 
4910			;	if DEBUG_STORESE 
4910			;		DMARK "LO3" 
4910			;		CALLMONITOR 
4910			;	endif 
4910			; 
4910			;	call forthparse 
4910			;	call forthexec 
4910			;	call forthexec_cleanup 
4910			; 
4910			;	; go to next extent 
4910			; 
4910			;	; get next block  or mark as eof 
4910			;	jp .loadline 
4910			; 
4910			; 
4910			; 
4910			;	       NEXTW 
4910			;.loadeof:	ld a, 0 
4910			;		ld (store_openext), a 
4910			; 
4910			;	if DEBUG_STORESE 
4910			;		DMARK "LOF" 
4910			;		CALLMONITOR 
4910			;	endif 
4910			;		ret 
4910			;		;NEXTW 
4910			;.BSAVE:   
4910			; 
4910			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4910			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4910			;		NEXTW 
4910			;.BLOAD: 
4910			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4910			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4910			;		NEXTW 
4910			;;;; counter gap 
4910			 
4910			 
4910			.SEO: 
4910				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4910 64				db WORD_SYS_CORE+80             
4911 2f 49			dw .SEI            
4913 04				db 3 + 1 
4914 .. 00			db "SEO",0              
4918				endm 
# End of macro CWHEAD
4918			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4918			 
4918					; get port 
4918			 
4918					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4918 cd ff 1e			call macro_dsp_valuehl 
491b				endm 
# End of macro FORTH_DSP_VALUEHL
491b			 
491b e5					push hl    ; u2 - byte 
491c			 
491c					; destroy value TOS 
491c			 
491c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
491c cd b7 1f			call macro_forth_dsp_pop 
491f				endm 
# End of macro FORTH_DSP_POP
491f			 
491f					; get byte to send 
491f			 
491f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
491f cd ff 1e			call macro_dsp_valuehl 
4922				endm 
# End of macro FORTH_DSP_VALUEHL
4922			 
4922 e5					push hl    ; u1 - addr 
4923			 
4923					; destroy value TOS 
4923			 
4923					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4923 cd b7 1f			call macro_forth_dsp_pop 
4926				endm 
# End of macro FORTH_DSP_POP
4926			 
4926					; one value on hl get other one back 
4926			 
4926 d1					pop de   ; u1 - byte 
4927			 
4927 e1					pop hl   ; u2 - addr 
4928			 
4928					; TODO Send SPI byte 
4928			 
4928			 
4928 7b					ld a, e 
4929 cd c0 01				call se_writebyte 
492c			 
492c					 
492c			 
492c					NEXTW 
492c c3 71 20			jp macro_next 
492f				endm 
# End of macro NEXTW
492f			 
492f			.SEI: 
492f				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
492f 65				db WORD_SYS_CORE+81             
4930 49 49			dw .SFREE            
4932 04				db 3 + 1 
4933 .. 00			db "SEI",0              
4937				endm 
# End of macro CWHEAD
4937			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4937			 
4937					; get port 
4937			 
4937					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4937 cd ff 1e			call macro_dsp_valuehl 
493a				endm 
# End of macro FORTH_DSP_VALUEHL
493a			 
493a			;		push hl 
493a			 
493a					; destroy value TOS 
493a			 
493a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
493a cd b7 1f			call macro_forth_dsp_pop 
493d				endm 
# End of macro FORTH_DSP_POP
493d			 
493d					; one value on hl get other one back 
493d			 
493d			;		pop hl 
493d			 
493d			 
493d					; TODO Get SPI byte 
493d			 
493d cd 62 02				call se_readbyte 
4940			 
4940 26 00				ld h, 0 
4942 6f					ld l, a 
4943 cd 08 1d				call forth_push_numhl 
4946			 
4946					NEXTW 
4946 c3 71 20			jp macro_next 
4949				endm 
# End of macro NEXTW
4949			 
4949			.SFREE: 
4949				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4949 67				db WORD_SYS_CORE+83             
494a 78 49			dw .SIZE            
494c 06				db 5 + 1 
494d .. 00			db "FFREE",0              
4953				endm 
# End of macro CWHEAD
4953			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4953					if DEBUG_FORTH_WORDS_KEY 
4953						DMARK "FFR" 
4953 f5				push af  
4954 3a 68 49			ld a, (.dmark)  
4957 32 6e fb			ld (debug_mark),a  
495a 3a 69 49			ld a, (.dmark+1)  
495d 32 6f fb			ld (debug_mark+1),a  
4960 3a 6a 49			ld a, (.dmark+2)  
4963 32 70 fb			ld (debug_mark+2),a  
4966 18 03			jr .pastdmark  
4968 ..			.dmark: db "FFR"  
496b f1			.pastdmark: pop af  
496c			endm  
# End of macro DMARK
496c						CALLMONITOR 
496c cd ab 16			call break_point_state  
496f				endm  
# End of macro CALLMONITOR
496f					endif 
496f			 
496f cd af 06				call storage_freeblocks 
4972			 
4972 cd 08 1d				call forth_push_numhl 
4975			 
4975				       NEXTW 
4975 c3 71 20			jp macro_next 
4978				endm 
# End of macro NEXTW
4978			.SIZE: 
4978				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4978 67				db WORD_SYS_CORE+83             
4979 ac 49			dw .CREATE            
497b 05				db 4 + 1 
497c .. 00			db "SIZE",0              
4981				endm 
# End of macro CWHEAD
4981			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4981					if DEBUG_FORTH_WORDS_KEY 
4981						DMARK "SIZ" 
4981 f5				push af  
4982 3a 96 49			ld a, (.dmark)  
4985 32 6e fb			ld (debug_mark),a  
4988 3a 97 49			ld a, (.dmark+1)  
498b 32 6f fb			ld (debug_mark+1),a  
498e 3a 98 49			ld a, (.dmark+2)  
4991 32 70 fb			ld (debug_mark+2),a  
4994 18 03			jr .pastdmark  
4996 ..			.dmark: db "SIZ"  
4999 f1			.pastdmark: pop af  
499a			endm  
# End of macro DMARK
499a						CALLMONITOR 
499a cd ab 16			call break_point_state  
499d				endm  
# End of macro CALLMONITOR
499d					endif 
499d			 
499d					FORTH_DSP_VALUEHL 
499d cd ff 1e			call macro_dsp_valuehl 
49a0				endm 
# End of macro FORTH_DSP_VALUEHL
49a0			;		push hl 
49a0					FORTH_DSP_POP 
49a0 cd b7 1f			call macro_forth_dsp_pop 
49a3				endm 
# End of macro FORTH_DSP_POP
49a3			;		pop hl 
49a3 cd 11 03				call storage_file_size 
49a6			 
49a6 cd 08 1d				call forth_push_numhl 
49a9			  
49a9			 
49a9				       NEXTW 
49a9 c3 71 20			jp macro_next 
49ac				endm 
# End of macro NEXTW
49ac			 
49ac			.CREATE: 
49ac				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
49ac 68				db WORD_SYS_CORE+84             
49ad 1a 4a			dw .APPEND            
49af 07				db 6 + 1 
49b0 .. 00			db "CREATE",0              
49b7				endm 
# End of macro CWHEAD
49b7			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
49b7			; | | e.g.  
49b7			; | | TestProgram CREATE 
49b7			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
49b7			; | |  
49b7			; | | Max file IDs are 255. 
49b7			; | |  
49b7					 
49b7					if DEBUG_FORTH_WORDS_KEY 
49b7						DMARK "CRT" 
49b7 f5				push af  
49b8 3a cc 49			ld a, (.dmark)  
49bb 32 6e fb			ld (debug_mark),a  
49be 3a cd 49			ld a, (.dmark+1)  
49c1 32 6f fb			ld (debug_mark+1),a  
49c4 3a ce 49			ld a, (.dmark+2)  
49c7 32 70 fb			ld (debug_mark+2),a  
49ca 18 03			jr .pastdmark  
49cc ..			.dmark: db "CRT"  
49cf f1			.pastdmark: pop af  
49d0			endm  
# End of macro DMARK
49d0						CALLMONITOR 
49d0 cd ab 16			call break_point_state  
49d3				endm  
# End of macro CALLMONITOR
49d3					endif 
49d3			;		call storage_get_block_0 
49d3			 
49d3					; TODO pop hl 
49d3			 
49d3					;v5 FORTH_DSP_VALUE 
49d3					FORTH_DSP_VALUE 
49d3 cd e8 1e			call macro_forth_dsp_value 
49d6				endm 
# End of macro FORTH_DSP_VALUE
49d6			 
49d6				if DEBUG_STORESE 
49d6					DMARK "CR1" 
49d6 f5				push af  
49d7 3a eb 49			ld a, (.dmark)  
49da 32 6e fb			ld (debug_mark),a  
49dd 3a ec 49			ld a, (.dmark+1)  
49e0 32 6f fb			ld (debug_mark+1),a  
49e3 3a ed 49			ld a, (.dmark+2)  
49e6 32 70 fb			ld (debug_mark+2),a  
49e9 18 03			jr .pastdmark  
49eb ..			.dmark: db "CR1"  
49ee f1			.pastdmark: pop af  
49ef			endm  
# End of macro DMARK
49ef					CALLMONITOR 
49ef cd ab 16			call break_point_state  
49f2				endm  
# End of macro CALLMONITOR
49f2				endif 
49f2			;		push hl 
49f2			;		FORTH_DSP_POP 
49f2			;		pop hl 
49f2			 
49f2			;		inc hl   ; move past the type marker 
49f2			 
49f2 cd e5 06				call storage_create 
49f5			 
49f5				if DEBUG_STORESE 
49f5					DMARK "CT1" 
49f5 f5				push af  
49f6 3a 0a 4a			ld a, (.dmark)  
49f9 32 6e fb			ld (debug_mark),a  
49fc 3a 0b 4a			ld a, (.dmark+1)  
49ff 32 6f fb			ld (debug_mark+1),a  
4a02 3a 0c 4a			ld a, (.dmark+2)  
4a05 32 70 fb			ld (debug_mark+2),a  
4a08 18 03			jr .pastdmark  
4a0a ..			.dmark: db "CT1"  
4a0d f1			.pastdmark: pop af  
4a0e			endm  
# End of macro DMARK
4a0e					CALLMONITOR 
4a0e cd ab 16			call break_point_state  
4a11				endm  
# End of macro CALLMONITOR
4a11				endif 
4a11			;		push hl 
4a11					FORTH_DSP_POP 
4a11 cd b7 1f			call macro_forth_dsp_pop 
4a14				endm 
# End of macro FORTH_DSP_POP
4a14			;		pop hl 
4a14					; push file id to stack 
4a14 cd 08 1d				call forth_push_numhl 
4a17			 
4a17			 
4a17			 
4a17				       NEXTW 
4a17 c3 71 20			jp macro_next 
4a1a				endm 
# End of macro NEXTW
4a1a			 
4a1a			.APPEND: 
4a1a				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4a1a 69				db WORD_SYS_CORE+85             
4a1b ab 4a			dw .SDEL            
4a1d 07				db 6 + 1 
4a1e .. 00			db "APPEND",0              
4a25				endm 
# End of macro CWHEAD
4a25			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4a25			; | | e.g. 
4a25			; | | Test CREATE      -> $01 
4a25			; | | "A string to add to file" $01 APPEND 
4a25			; | |  
4a25			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4a25					if DEBUG_FORTH_WORDS_KEY 
4a25						DMARK "APP" 
4a25 f5				push af  
4a26 3a 3a 4a			ld a, (.dmark)  
4a29 32 6e fb			ld (debug_mark),a  
4a2c 3a 3b 4a			ld a, (.dmark+1)  
4a2f 32 6f fb			ld (debug_mark+1),a  
4a32 3a 3c 4a			ld a, (.dmark+2)  
4a35 32 70 fb			ld (debug_mark+2),a  
4a38 18 03			jr .pastdmark  
4a3a ..			.dmark: db "APP"  
4a3d f1			.pastdmark: pop af  
4a3e			endm  
# End of macro DMARK
4a3e						CALLMONITOR 
4a3e cd ab 16			call break_point_state  
4a41				endm  
# End of macro CALLMONITOR
4a41					endif 
4a41			 
4a41					FORTH_DSP_VALUEHL 
4a41 cd ff 1e			call macro_dsp_valuehl 
4a44				endm 
# End of macro FORTH_DSP_VALUEHL
4a44 e5					push hl 	; save file id 
4a45			 
4a45				if DEBUG_STORESE 
4a45					DMARK "AP1" 
4a45 f5				push af  
4a46 3a 5a 4a			ld a, (.dmark)  
4a49 32 6e fb			ld (debug_mark),a  
4a4c 3a 5b 4a			ld a, (.dmark+1)  
4a4f 32 6f fb			ld (debug_mark+1),a  
4a52 3a 5c 4a			ld a, (.dmark+2)  
4a55 32 70 fb			ld (debug_mark+2),a  
4a58 18 03			jr .pastdmark  
4a5a ..			.dmark: db "AP1"  
4a5d f1			.pastdmark: pop af  
4a5e			endm  
# End of macro DMARK
4a5e					CALLMONITOR 
4a5e cd ab 16			call break_point_state  
4a61				endm  
# End of macro CALLMONITOR
4a61				endif 
4a61					FORTH_DSP_POP 
4a61 cd b7 1f			call macro_forth_dsp_pop 
4a64				endm 
# End of macro FORTH_DSP_POP
4a64			 
4a64					FORTH_DSP_VALUEHL 
4a64 cd ff 1e			call macro_dsp_valuehl 
4a67				endm 
# End of macro FORTH_DSP_VALUEHL
4a67					;v5 FORTH_DSP_VALUE 
4a67 e5					push hl 	; save ptr to string to save 
4a68			 
4a68				if DEBUG_STORESE 
4a68					DMARK "AP1" 
4a68 f5				push af  
4a69 3a 7d 4a			ld a, (.dmark)  
4a6c 32 6e fb			ld (debug_mark),a  
4a6f 3a 7e 4a			ld a, (.dmark+1)  
4a72 32 6f fb			ld (debug_mark+1),a  
4a75 3a 7f 4a			ld a, (.dmark+2)  
4a78 32 70 fb			ld (debug_mark+2),a  
4a7b 18 03			jr .pastdmark  
4a7d ..			.dmark: db "AP1"  
4a80 f1			.pastdmark: pop af  
4a81			endm  
# End of macro DMARK
4a81					CALLMONITOR 
4a81 cd ab 16			call break_point_state  
4a84				endm  
# End of macro CALLMONITOR
4a84				endif 
4a84					FORTH_DSP_POP 
4a84 cd b7 1f			call macro_forth_dsp_pop 
4a87				endm 
# End of macro FORTH_DSP_POP
4a87			 
4a87 d1					pop de 
4a88 e1					pop hl 
4a89				if DEBUG_STORESE 
4a89					DMARK "AP2" 
4a89 f5				push af  
4a8a 3a 9e 4a			ld a, (.dmark)  
4a8d 32 6e fb			ld (debug_mark),a  
4a90 3a 9f 4a			ld a, (.dmark+1)  
4a93 32 6f fb			ld (debug_mark+1),a  
4a96 3a a0 4a			ld a, (.dmark+2)  
4a99 32 70 fb			ld (debug_mark+2),a  
4a9c 18 03			jr .pastdmark  
4a9e ..			.dmark: db "AP2"  
4aa1 f1			.pastdmark: pop af  
4aa2			endm  
# End of macro DMARK
4aa2					CALLMONITOR 
4aa2 cd ab 16			call break_point_state  
4aa5				endm  
# End of macro CALLMONITOR
4aa5				endif 
4aa5					;inc de ; skip var type indicator 
4aa5			 
4aa5					; TODO how to append numerics???? 
4aa5			 
4aa5 cd c4 08				call storage_append		 
4aa8			 
4aa8				       NEXTW 
4aa8 c3 71 20			jp macro_next 
4aab				endm 
# End of macro NEXTW
4aab			.SDEL: 
4aab				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4aab 6a				db WORD_SYS_CORE+86             
4aac f7 4a			dw .OPEN            
4aae 05				db 4 + 1 
4aaf .. 00			db "ERA",0              
4ab3				endm 
# End of macro CWHEAD
4ab3			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4ab3					FORTH_DSP_VALUEHL 
4ab3 cd ff 1e			call macro_dsp_valuehl 
4ab6				endm 
# End of macro FORTH_DSP_VALUEHL
4ab6			;		push hl 	; save file id 
4ab6			 
4ab6					if DEBUG_FORTH_WORDS_KEY 
4ab6						DMARK "ERA" 
4ab6 f5				push af  
4ab7 3a cb 4a			ld a, (.dmark)  
4aba 32 6e fb			ld (debug_mark),a  
4abd 3a cc 4a			ld a, (.dmark+1)  
4ac0 32 6f fb			ld (debug_mark+1),a  
4ac3 3a cd 4a			ld a, (.dmark+2)  
4ac6 32 70 fb			ld (debug_mark+2),a  
4ac9 18 03			jr .pastdmark  
4acb ..			.dmark: db "ERA"  
4ace f1			.pastdmark: pop af  
4acf			endm  
# End of macro DMARK
4acf						CALLMONITOR 
4acf cd ab 16			call break_point_state  
4ad2				endm  
# End of macro CALLMONITOR
4ad2					endif 
4ad2				if DEBUG_STORESE 
4ad2					DMARK "ER1" 
4ad2 f5				push af  
4ad3 3a e7 4a			ld a, (.dmark)  
4ad6 32 6e fb			ld (debug_mark),a  
4ad9 3a e8 4a			ld a, (.dmark+1)  
4adc 32 6f fb			ld (debug_mark+1),a  
4adf 3a e9 4a			ld a, (.dmark+2)  
4ae2 32 70 fb			ld (debug_mark+2),a  
4ae5 18 03			jr .pastdmark  
4ae7 ..			.dmark: db "ER1"  
4aea f1			.pastdmark: pop af  
4aeb			endm  
# End of macro DMARK
4aeb					CALLMONITOR 
4aeb cd ab 16			call break_point_state  
4aee				endm  
# End of macro CALLMONITOR
4aee				endif 
4aee					FORTH_DSP_POP 
4aee cd b7 1f			call macro_forth_dsp_pop 
4af1				endm 
# End of macro FORTH_DSP_POP
4af1			 
4af1			;		pop hl 
4af1			 
4af1 cd 24 05				call storage_erase 
4af4				       NEXTW 
4af4 c3 71 20			jp macro_next 
4af7				endm 
# End of macro NEXTW
4af7			 
4af7			.OPEN: 
4af7				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4af7 6b				db WORD_SYS_CORE+87             
4af8 87 4b			dw .READ            
4afa 05				db 4 + 1 
4afb .. 00			db "OPEN",0              
4b00				endm 
# End of macro CWHEAD
4b00			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4b00			; | | e.g. 
4b00			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b00			; | | 
4b00			; | | Will return with 255 blocks if the file does not exist 
4b00			 
4b00					if DEBUG_FORTH_WORDS_KEY 
4b00						DMARK "OPN" 
4b00 f5				push af  
4b01 3a 15 4b			ld a, (.dmark)  
4b04 32 6e fb			ld (debug_mark),a  
4b07 3a 16 4b			ld a, (.dmark+1)  
4b0a 32 6f fb			ld (debug_mark+1),a  
4b0d 3a 17 4b			ld a, (.dmark+2)  
4b10 32 70 fb			ld (debug_mark+2),a  
4b13 18 03			jr .pastdmark  
4b15 ..			.dmark: db "OPN"  
4b18 f1			.pastdmark: pop af  
4b19			endm  
# End of macro DMARK
4b19						CALLMONITOR 
4b19 cd ab 16			call break_point_state  
4b1c				endm  
# End of macro CALLMONITOR
4b1c					endif 
4b1c					; TODO handle multiple file opens 
4b1c			 
4b1c 3e 01			       	ld a, 1 
4b1e 32 50 f8				ld (store_openext), a 
4b21			 
4b21					; get max extents for this file 
4b21				 
4b21								 
4b21					FORTH_DSP_VALUEHL 
4b21 cd ff 1e			call macro_dsp_valuehl 
4b24				endm 
# End of macro FORTH_DSP_VALUEHL
4b24			 
4b24 65					ld h, l 
4b25 2e 00				ld l, 0 
4b27			 
4b27				if DEBUG_STORESE 
4b27					DMARK "OPN" 
4b27 f5				push af  
4b28 3a 3c 4b			ld a, (.dmark)  
4b2b 32 6e fb			ld (debug_mark),a  
4b2e 3a 3d 4b			ld a, (.dmark+1)  
4b31 32 6f fb			ld (debug_mark+1),a  
4b34 3a 3e 4b			ld a, (.dmark+2)  
4b37 32 70 fb			ld (debug_mark+2),a  
4b3a 18 03			jr .pastdmark  
4b3c ..			.dmark: db "OPN"  
4b3f f1			.pastdmark: pop af  
4b40			endm  
# End of macro DMARK
4b40					CALLMONITOR 
4b40 cd ab 16			call break_point_state  
4b43				endm  
# End of macro CALLMONITOR
4b43				endif 
4b43			;		push hl 
4b43					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b43 cd b7 1f			call macro_forth_dsp_pop 
4b46				endm 
# End of macro FORTH_DSP_POP
4b46			;		pop hl 
4b46						 
4b46 11 59 f8				ld de, store_page      ; get block zero of file 
4b49 cd 3b 08				call storage_read 
4b4c cd 2d 0d			call ishlzero 
4b4f 20 04			jr nz, .opfound 
4b51			 
4b51				; file does not exist so indicate with 255 extents in use 
4b51			 
4b51 3e ff			ld a, 255 
4b53 18 29			jr .skipopeneof 
4b55			 
4b55			 
4b55			.opfound: 
4b55			 
4b55			 
4b55 3a 5b f8				ld a, (store_page+2)    ; max extents for this file 
4b58 32 4f f8				ld  (store_openmaxext), a   ; get our limit and push 
4b5b					 
4b5b				if DEBUG_STORESE 
4b5b					DMARK "OPx" 
4b5b f5				push af  
4b5c 3a 70 4b			ld a, (.dmark)  
4b5f 32 6e fb			ld (debug_mark),a  
4b62 3a 71 4b			ld a, (.dmark+1)  
4b65 32 6f fb			ld (debug_mark+1),a  
4b68 3a 72 4b			ld a, (.dmark+2)  
4b6b 32 70 fb			ld (debug_mark+2),a  
4b6e 18 03			jr .pastdmark  
4b70 ..			.dmark: db "OPx"  
4b73 f1			.pastdmark: pop af  
4b74			endm  
# End of macro DMARK
4b74					CALLMONITOR 
4b74 cd ab 16			call break_point_state  
4b77				endm  
# End of macro CALLMONITOR
4b77				endif 
4b77 fe 00				cp 0 
4b79 20 03				jr nz, .skipopeneof 
4b7b					; have opened an empty file 
4b7b					 
4b7b 32 50 f8				ld (store_openext), a 
4b7e			 
4b7e			.skipopeneof: 
4b7e			 
4b7e 6f					ld l, a 
4b7f 26 00				ld h, 0 
4b81 cd 08 1d				call forth_push_numhl 
4b84			 
4b84			 
4b84				       NEXTW 
4b84 c3 71 20			jp macro_next 
4b87				endm 
# End of macro NEXTW
4b87			.READ: 
4b87				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b87 6c				db WORD_SYS_CORE+88             
4b88 ce 4c			dw .EOF            
4b8a 05				db 4 + 1 
4b8b .. 00			db "READ",0              
4b90				endm 
# End of macro CWHEAD
4b90			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b90			; | | e.g. 
4b90			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b90			 
4b90					if DEBUG_FORTH_WORDS_KEY 
4b90						DMARK "REA" 
4b90 f5				push af  
4b91 3a a5 4b			ld a, (.dmark)  
4b94 32 6e fb			ld (debug_mark),a  
4b97 3a a6 4b			ld a, (.dmark+1)  
4b9a 32 6f fb			ld (debug_mark+1),a  
4b9d 3a a7 4b			ld a, (.dmark+2)  
4ba0 32 70 fb			ld (debug_mark+2),a  
4ba3 18 03			jr .pastdmark  
4ba5 ..			.dmark: db "REA"  
4ba8 f1			.pastdmark: pop af  
4ba9			endm  
# End of macro DMARK
4ba9						CALLMONITOR 
4ba9 cd ab 16			call break_point_state  
4bac				endm  
# End of macro CALLMONITOR
4bac					endif 
4bac					; store_openext use it. If zero it is EOF 
4bac			 
4bac					; read block from current stream id 
4bac					; if the block does not contain zero term keep reading blocks until zero found 
4bac					; push the block to stack 
4bac					; save the block id to stream 
4bac			 
4bac			 
4bac					FORTH_DSP_VALUEHL 
4bac cd ff 1e			call macro_dsp_valuehl 
4baf				endm 
# End of macro FORTH_DSP_VALUEHL
4baf			 
4baf			;		push hl 
4baf			 
4baf				if DEBUG_STORESE 
4baf					DMARK "REA" 
4baf f5				push af  
4bb0 3a c4 4b			ld a, (.dmark)  
4bb3 32 6e fb			ld (debug_mark),a  
4bb6 3a c5 4b			ld a, (.dmark+1)  
4bb9 32 6f fb			ld (debug_mark+1),a  
4bbc 3a c6 4b			ld a, (.dmark+2)  
4bbf 32 70 fb			ld (debug_mark+2),a  
4bc2 18 03			jr .pastdmark  
4bc4 ..			.dmark: db "REA"  
4bc7 f1			.pastdmark: pop af  
4bc8			endm  
# End of macro DMARK
4bc8					CALLMONITOR 
4bc8 cd ab 16			call break_point_state  
4bcb				endm  
# End of macro CALLMONITOR
4bcb				endif 
4bcb					FORTH_DSP_POP 
4bcb cd b7 1f			call macro_forth_dsp_pop 
4bce				endm 
# End of macro FORTH_DSP_POP
4bce			 
4bce			;		pop hl 
4bce				 
4bce 65					ld h,l 
4bcf			 
4bcf 3a 50 f8				ld a, (store_openext) 
4bd2 6f					ld l, a 
4bd3					 
4bd3 fe 00				cp 0 
4bd5 ca a0 4c				jp z, .ateof     ; dont read past eof 
4bd8			 
4bd8			 
4bd8 11 59 f8				ld de, store_page 
4bdb				if DEBUG_STORESE 
4bdb					DMARK "RE1" 
4bdb f5				push af  
4bdc 3a f0 4b			ld a, (.dmark)  
4bdf 32 6e fb			ld (debug_mark),a  
4be2 3a f1 4b			ld a, (.dmark+1)  
4be5 32 6f fb			ld (debug_mark+1),a  
4be8 3a f2 4b			ld a, (.dmark+2)  
4beb 32 70 fb			ld (debug_mark+2),a  
4bee 18 03			jr .pastdmark  
4bf0 ..			.dmark: db "RE1"  
4bf3 f1			.pastdmark: pop af  
4bf4			endm  
# End of macro DMARK
4bf4					CALLMONITOR 
4bf4 cd ab 16			call break_point_state  
4bf7				endm  
# End of macro CALLMONITOR
4bf7				endif 
4bf7 cd 3b 08				call storage_read 
4bfa			 
4bfa				if DEBUG_STORESE 
4bfa					DMARK "RE2" 
4bfa f5				push af  
4bfb 3a 0f 4c			ld a, (.dmark)  
4bfe 32 6e fb			ld (debug_mark),a  
4c01 3a 10 4c			ld a, (.dmark+1)  
4c04 32 6f fb			ld (debug_mark+1),a  
4c07 3a 11 4c			ld a, (.dmark+2)  
4c0a 32 70 fb			ld (debug_mark+2),a  
4c0d 18 03			jr .pastdmark  
4c0f ..			.dmark: db "RE2"  
4c12 f1			.pastdmark: pop af  
4c13			endm  
# End of macro DMARK
4c13					CALLMONITOR 
4c13 cd ab 16			call break_point_state  
4c16				endm  
# End of macro CALLMONITOR
4c16				endif 
4c16 cd 2d 0d			call ishlzero 
4c19			;	ld a, l 
4c19			;	add h 
4c19			;	cp 0 
4c19 ca a6 4c			jp z, .readeof 
4c1c			 
4c1c				; not eof so hl should point to data to push to stack 
4c1c			 
4c1c				if DEBUG_STORESE 
4c1c					DMARK "RE3" 
4c1c f5				push af  
4c1d 3a 31 4c			ld a, (.dmark)  
4c20 32 6e fb			ld (debug_mark),a  
4c23 3a 32 4c			ld a, (.dmark+1)  
4c26 32 6f fb			ld (debug_mark+1),a  
4c29 3a 33 4c			ld a, (.dmark+2)  
4c2c 32 70 fb			ld (debug_mark+2),a  
4c2f 18 03			jr .pastdmark  
4c31 ..			.dmark: db "RE3"  
4c34 f1			.pastdmark: pop af  
4c35			endm  
# End of macro DMARK
4c35					CALLMONITOR 
4c35 cd ab 16			call break_point_state  
4c38				endm  
# End of macro CALLMONITOR
4c38				endif 
4c38 cd 76 1d			call forth_push_str 
4c3b			 
4c3b				if DEBUG_STORESE 
4c3b					DMARK "RE4" 
4c3b f5				push af  
4c3c 3a 50 4c			ld a, (.dmark)  
4c3f 32 6e fb			ld (debug_mark),a  
4c42 3a 51 4c			ld a, (.dmark+1)  
4c45 32 6f fb			ld (debug_mark+1),a  
4c48 3a 52 4c			ld a, (.dmark+2)  
4c4b 32 70 fb			ld (debug_mark+2),a  
4c4e 18 03			jr .pastdmark  
4c50 ..			.dmark: db "RE4"  
4c53 f1			.pastdmark: pop af  
4c54			endm  
# End of macro DMARK
4c54					CALLMONITOR 
4c54 cd ab 16			call break_point_state  
4c57				endm  
# End of macro CALLMONITOR
4c57				endif 
4c57				; get next block  or mark as eof 
4c57			 
4c57 3a 4f f8			ld a, (store_openmaxext)   ; get our limit 
4c5a 4f				ld c, a	 
4c5b 3a 50 f8			ld a, (store_openext) 
4c5e			 
4c5e				if DEBUG_STORESE 
4c5e					DMARK "RE5" 
4c5e f5				push af  
4c5f 3a 73 4c			ld a, (.dmark)  
4c62 32 6e fb			ld (debug_mark),a  
4c65 3a 74 4c			ld a, (.dmark+1)  
4c68 32 6f fb			ld (debug_mark+1),a  
4c6b 3a 75 4c			ld a, (.dmark+2)  
4c6e 32 70 fb			ld (debug_mark+2),a  
4c71 18 03			jr .pastdmark  
4c73 ..			.dmark: db "RE5"  
4c76 f1			.pastdmark: pop af  
4c77			endm  
# End of macro DMARK
4c77					CALLMONITOR 
4c77 cd ab 16			call break_point_state  
4c7a				endm  
# End of macro CALLMONITOR
4c7a				endif 
4c7a b9				cp c 
4c7b 28 29			jr z, .readeof     ; at last extent 
4c7d			 
4c7d 3c					inc a 
4c7e 32 50 f8				ld (store_openext), a 
4c81			 
4c81				if DEBUG_STORESE 
4c81					DMARK "RE6" 
4c81 f5				push af  
4c82 3a 96 4c			ld a, (.dmark)  
4c85 32 6e fb			ld (debug_mark),a  
4c88 3a 97 4c			ld a, (.dmark+1)  
4c8b 32 6f fb			ld (debug_mark+1),a  
4c8e 3a 98 4c			ld a, (.dmark+2)  
4c91 32 70 fb			ld (debug_mark+2),a  
4c94 18 03			jr .pastdmark  
4c96 ..			.dmark: db "RE6"  
4c99 f1			.pastdmark: pop af  
4c9a			endm  
# End of macro DMARK
4c9a					CALLMONITOR 
4c9a cd ab 16			call break_point_state  
4c9d				endm  
# End of macro CALLMONITOR
4c9d				endif 
4c9d			 
4c9d			 
4c9d				       NEXTW 
4c9d c3 71 20			jp macro_next 
4ca0				endm 
# End of macro NEXTW
4ca0			.ateof: 
4ca0 21 ca 4c				ld hl, .showeof 
4ca3 cd 76 1d				call forth_push_str 
4ca6 3e 00		.readeof:	ld a, 0 
4ca8 32 50 f8				ld (store_openext), a 
4cab			 
4cab					 
4cab				if DEBUG_STORESE 
4cab					DMARK "REF" 
4cab f5				push af  
4cac 3a c0 4c			ld a, (.dmark)  
4caf 32 6e fb			ld (debug_mark),a  
4cb2 3a c1 4c			ld a, (.dmark+1)  
4cb5 32 6f fb			ld (debug_mark+1),a  
4cb8 3a c2 4c			ld a, (.dmark+2)  
4cbb 32 70 fb			ld (debug_mark+2),a  
4cbe 18 03			jr .pastdmark  
4cc0 ..			.dmark: db "REF"  
4cc3 f1			.pastdmark: pop af  
4cc4			endm  
# End of macro DMARK
4cc4					CALLMONITOR 
4cc4 cd ab 16			call break_point_state  
4cc7				endm  
# End of macro CALLMONITOR
4cc7				endif 
4cc7				       NEXTW 
4cc7 c3 71 20			jp macro_next 
4cca				endm 
# End of macro NEXTW
4cca			 
4cca .. 00		.showeof:   db "eof", 0 
4cce			 
4cce			 
4cce			.EOF: 
4cce				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4cce 6d				db WORD_SYS_CORE+89             
4ccf 0f 4d			dw .FORMAT            
4cd1 04				db 3 + 1 
4cd2 .. 00			db "EOF",0              
4cd6				endm 
# End of macro CWHEAD
4cd6			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4cd6			; | | e.g. 
4cd6			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4cd6					; TODO if current block id for stream is zero then push true else false 
4cd6			 
4cd6					if DEBUG_FORTH_WORDS_KEY 
4cd6						DMARK "EOF" 
4cd6 f5				push af  
4cd7 3a eb 4c			ld a, (.dmark)  
4cda 32 6e fb			ld (debug_mark),a  
4cdd 3a ec 4c			ld a, (.dmark+1)  
4ce0 32 6f fb			ld (debug_mark+1),a  
4ce3 3a ed 4c			ld a, (.dmark+2)  
4ce6 32 70 fb			ld (debug_mark+2),a  
4ce9 18 03			jr .pastdmark  
4ceb ..			.dmark: db "EOF"  
4cee f1			.pastdmark: pop af  
4cef			endm  
# End of macro DMARK
4cef						CALLMONITOR 
4cef cd ab 16			call break_point_state  
4cf2				endm  
# End of macro CALLMONITOR
4cf2					endif 
4cf2			 
4cf2					; TODO handlue multiple file streams 
4cf2			 
4cf2					FORTH_DSP_POP     ; for now just get rid of stream id 
4cf2 cd b7 1f			call macro_forth_dsp_pop 
4cf5				endm 
# End of macro FORTH_DSP_POP
4cf5			 
4cf5 2e 01				ld l, 1 
4cf7 3a 4f f8				ld a, (store_openmaxext) 
4cfa fe 00				cp 0 
4cfc 28 09				jr  z, .eofdone   ; empty file 
4cfe 3a 50 f8				ld a, (store_openext) 
4d01 fe 00				cp 0 
4d03 28 02				jr  z, .eofdone 
4d05 2e 00				ld l, 0 
4d07 26 00		.eofdone:	ld h, 0 
4d09 cd 08 1d				call forth_push_numhl 
4d0c			 
4d0c			 
4d0c				       NEXTW 
4d0c c3 71 20			jp macro_next 
4d0f				endm 
# End of macro NEXTW
4d0f			 
4d0f			.FORMAT: 
4d0f				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4d0f 6d				db WORD_SYS_CORE+89             
4d10 60 4d			dw .LABEL            
4d12 07				db 6 + 1 
4d13 .. 00			db "FORMAT",0              
4d1a				endm 
# End of macro CWHEAD
4d1a			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4d1a					; TODO if current block id for stream is zero then push true else false 
4d1a				 
4d1a				if DEBUG_STORESE 
4d1a					DMARK "FOR" 
4d1a f5				push af  
4d1b 3a 2f 4d			ld a, (.dmark)  
4d1e 32 6e fb			ld (debug_mark),a  
4d21 3a 30 4d			ld a, (.dmark+1)  
4d24 32 6f fb			ld (debug_mark+1),a  
4d27 3a 31 4d			ld a, (.dmark+2)  
4d2a 32 70 fb			ld (debug_mark+2),a  
4d2d 18 03			jr .pastdmark  
4d2f ..			.dmark: db "FOR"  
4d32 f1			.pastdmark: pop af  
4d33			endm  
# End of macro DMARK
4d33					CALLMONITOR 
4d33 cd ab 16			call break_point_state  
4d36				endm  
# End of macro CALLMONITOR
4d36				endif 
4d36					; Wipes the bank check flags to cause a reformat on next block 0 read 
4d36			 
4d36 21 01 00				ld hl, 1 
4d39 3e 00				ld a, 0 
4d3b cd c0 01				call se_writebyte 
4d3e			 
4d3e				if DEBUG_STORESE 
4d3e					DMARK "FO0" 
4d3e f5				push af  
4d3f 3a 53 4d			ld a, (.dmark)  
4d42 32 6e fb			ld (debug_mark),a  
4d45 3a 54 4d			ld a, (.dmark+1)  
4d48 32 6f fb			ld (debug_mark+1),a  
4d4b 3a 55 4d			ld a, (.dmark+2)  
4d4e 32 70 fb			ld (debug_mark+2),a  
4d51 18 03			jr .pastdmark  
4d53 ..			.dmark: db "FO0"  
4d56 f1			.pastdmark: pop af  
4d57			endm  
# End of macro DMARK
4d57					CALLMONITOR 
4d57 cd ab 16			call break_point_state  
4d5a				endm  
# End of macro CALLMONITOR
4d5a				endif 
4d5a					; force bank init 
4d5a			 
4d5a cd 93 03				call storage_get_block_0 
4d5d					 
4d5d				       NEXTW 
4d5d c3 71 20			jp macro_next 
4d60				endm 
# End of macro NEXTW
4d60			.LABEL: 
4d60				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d60 6d				db WORD_SYS_CORE+89             
4d61 ae 4d			dw .STOREPAGE            
4d63 06				db 5 + 1 
4d64 .. 00			db "LABEL",0              
4d6a				endm 
# End of macro CWHEAD
4d6a			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d6a					; TODO test to see if bank is selected 
4d6a				 
4d6a					if DEBUG_FORTH_WORDS_KEY 
4d6a						DMARK "LBL" 
4d6a f5				push af  
4d6b 3a 7f 4d			ld a, (.dmark)  
4d6e 32 6e fb			ld (debug_mark),a  
4d71 3a 80 4d			ld a, (.dmark+1)  
4d74 32 6f fb			ld (debug_mark+1),a  
4d77 3a 81 4d			ld a, (.dmark+2)  
4d7a 32 70 fb			ld (debug_mark+2),a  
4d7d 18 03			jr .pastdmark  
4d7f ..			.dmark: db "LBL"  
4d82 f1			.pastdmark: pop af  
4d83			endm  
# End of macro DMARK
4d83						CALLMONITOR 
4d83 cd ab 16			call break_point_state  
4d86				endm  
# End of macro CALLMONITOR
4d86					endif 
4d86			;	if DEBUG_STORESE 
4d86			;		DMARK "LBL" 
4d86			;		CALLMONITOR 
4d86			;	endif 
4d86					FORTH_DSP_VALUEHL 
4d86 cd ff 1e			call macro_dsp_valuehl 
4d89				endm 
# End of macro FORTH_DSP_VALUEHL
4d89					;v5FORTH_DSP_VALUE 
4d89					 
4d89			;		push hl 
4d89					FORTH_DSP_POP 
4d89 cd b7 1f			call macro_forth_dsp_pop 
4d8c				endm 
# End of macro FORTH_DSP_POP
4d8c			;		pop hl 
4d8c			 
4d8c			;v5		inc hl   ; move past the type marker 
4d8c			 
4d8c				if DEBUG_STORESE 
4d8c					DMARK "LBl" 
4d8c f5				push af  
4d8d 3a a1 4d			ld a, (.dmark)  
4d90 32 6e fb			ld (debug_mark),a  
4d93 3a a2 4d			ld a, (.dmark+1)  
4d96 32 6f fb			ld (debug_mark+1),a  
4d99 3a a3 4d			ld a, (.dmark+2)  
4d9c 32 70 fb			ld (debug_mark+2),a  
4d9f 18 03			jr .pastdmark  
4da1 ..			.dmark: db "LBl"  
4da4 f1			.pastdmark: pop af  
4da5			endm  
# End of macro DMARK
4da5					CALLMONITOR 
4da5 cd ab 16			call break_point_state  
4da8				endm  
# End of macro CALLMONITOR
4da8				endif 
4da8 cd b7 04				call storage_label 
4dab			 
4dab				       NEXTW 
4dab c3 71 20			jp macro_next 
4dae				endm 
# End of macro NEXTW
4dae			.STOREPAGE: 
4dae				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4dae 6d				db WORD_SYS_CORE+89             
4daf e1 4d			dw .LABELS            
4db1 0a				db 9 + 1 
4db2 .. 00			db "STOREPAGE",0              
4dbc				endm 
# End of macro CWHEAD
4dbc			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4dbc					; TODO test to see if bank is selected 
4dbc				 
4dbc					if DEBUG_FORTH_WORDS_KEY 
4dbc						DMARK "STP" 
4dbc f5				push af  
4dbd 3a d1 4d			ld a, (.dmark)  
4dc0 32 6e fb			ld (debug_mark),a  
4dc3 3a d2 4d			ld a, (.dmark+1)  
4dc6 32 6f fb			ld (debug_mark+1),a  
4dc9 3a d3 4d			ld a, (.dmark+2)  
4dcc 32 70 fb			ld (debug_mark+2),a  
4dcf 18 03			jr .pastdmark  
4dd1 ..			.dmark: db "STP"  
4dd4 f1			.pastdmark: pop af  
4dd5			endm  
# End of macro DMARK
4dd5						CALLMONITOR 
4dd5 cd ab 16			call break_point_state  
4dd8				endm  
# End of macro CALLMONITOR
4dd8					endif 
4dd8			;	if DEBUG_STORESE 
4dd8			;		DMARK "STP" 
4dd8			;		CALLMONITOR 
4dd8			;	endif 
4dd8			 
4dd8 21 59 f8			ld hl, store_page 
4ddb cd 08 1d			call forth_push_numhl 
4dde			 
4dde			 
4dde				       NEXTW 
4dde c3 71 20			jp macro_next 
4de1				endm 
# End of macro NEXTW
4de1			.LABELS: 
4de1				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4de1 6d				db WORD_SYS_CORE+89             
4de2 6b 4e			dw .ENDSTORAGE            
4de4 07				db 6 + 1 
4de5 .. 00			db "LABELS",0              
4dec				endm 
# End of macro CWHEAD
4dec			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4dec					;  
4dec			 
4dec					; save the current device selected to restore afterwards 
4dec				 
4dec 3a 3f f8				ld a, (spi_device) 
4def f5					push af 
4df0			 
4df0			 
4df0					; run through each of the banks 
4df0			 
4df0 21 01 00				ld hl, 1 
4df3 cd 08 1d				call forth_push_numhl 
4df6 3e ff				ld a, SPI_CE_HIGH 
4df8 cb 87				res SPI_CE0, a 
4dfa 32 3f f8				ld (spi_device), a 
4dfd cd 93 03				call storage_get_block_0 
4e00 21 5c f8				ld hl, store_page+3 
4e03 cd 76 1d				call forth_push_str 
4e06			 
4e06					 
4e06 21 02 00				ld hl, 2 
4e09 cd 08 1d				call forth_push_numhl 
4e0c 3e ff				ld a, SPI_CE_HIGH 
4e0e cb 8f				res SPI_CE1, a 
4e10 32 3f f8				ld (spi_device), a 
4e13 cd 93 03				call storage_get_block_0 
4e16 21 5c f8				ld hl, store_page+3 
4e19 cd 76 1d				call forth_push_str 
4e1c			 
4e1c					 
4e1c 21 03 00				ld hl, 3 
4e1f cd 08 1d				call forth_push_numhl 
4e22 3e ff				ld a, SPI_CE_HIGH 
4e24 cb 97				res SPI_CE2, a 
4e26 32 3f f8				ld (spi_device), a 
4e29 cd 93 03				call storage_get_block_0 
4e2c 21 5c f8				ld hl, store_page+3 
4e2f cd 76 1d				call forth_push_str 
4e32			 
4e32			 
4e32 21 04 00				ld hl, 4 
4e35 cd 08 1d				call forth_push_numhl 
4e38 3e ff				ld a, SPI_CE_HIGH 
4e3a cb 9f				res SPI_CE3, a 
4e3c 32 3f f8				ld (spi_device), a 
4e3f cd 93 03				call storage_get_block_0 
4e42 21 5c f8				ld hl, store_page+3 
4e45 cd 76 1d				call forth_push_str 
4e48			 
4e48					 
4e48			 
4e48 21 05 00				ld hl, 5 
4e4b cd 08 1d				call forth_push_numhl 
4e4e 3e ff				ld a, SPI_CE_HIGH 
4e50 cb a7				res SPI_CE4, a 
4e52 32 3f f8				ld (spi_device), a 
4e55 cd 93 03				call storage_get_block_0 
4e58 21 5c f8				ld hl, store_page+3 
4e5b cd 76 1d				call forth_push_str 
4e5e			 
4e5e					 
4e5e					; push fixed count of storage devices (on board) for now 
4e5e			 
4e5e 21 05 00				ld hl, 5 
4e61 cd 08 1d				call forth_push_numhl 
4e64			 
4e64					; restore selected device  
4e64				 
4e64 f1					pop af 
4e65 32 3f f8				ld (spi_device), a 
4e68			 
4e68				       NEXTW 
4e68 c3 71 20			jp macro_next 
4e6b				endm 
# End of macro NEXTW
4e6b			 
4e6b			.ENDSTORAGE: 
4e6b			; eof 
# End of file forth_words_storage.asm
4e6b			endif 
4e6b				include "forth_words_device.asm" 
4e6b			; Device related words 
4e6b			 
4e6b			; | ## Device Words 
4e6b			 
4e6b			if SOUND_ENABLE 
4e6b			.NOTE: 
4e6b				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e6b 33				db WORD_SYS_CORE+31             
4e6c 93 4e			dw .AFTERSOUND            
4e6e 05				db 4 + 1 
4e6f .. 00			db "NOTE",0              
4e74				endm 
# End of macro CWHEAD
4e74			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e74					if DEBUG_FORTH_WORDS_KEY 
4e74						DMARK "NTE" 
4e74 f5				push af  
4e75 3a 89 4e			ld a, (.dmark)  
4e78 32 6e fb			ld (debug_mark),a  
4e7b 3a 8a 4e			ld a, (.dmark+1)  
4e7e 32 6f fb			ld (debug_mark+1),a  
4e81 3a 8b 4e			ld a, (.dmark+2)  
4e84 32 70 fb			ld (debug_mark+2),a  
4e87 18 03			jr .pastdmark  
4e89 ..			.dmark: db "NTE"  
4e8c f1			.pastdmark: pop af  
4e8d			endm  
# End of macro DMARK
4e8d						CALLMONITOR 
4e8d cd ab 16			call break_point_state  
4e90				endm  
# End of macro CALLMONITOR
4e90					endif 
4e90			 
4e90				 
4e90			 
4e90					NEXTW 
4e90 c3 71 20			jp macro_next 
4e93				endm 
# End of macro NEXTW
4e93			.AFTERSOUND: 
4e93			endif 
4e93			 
4e93			 
4e93			USE_GPIO: equ 0 
4e93			 
4e93			if USE_GPIO 
4e93			.GP1: 
4e93				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e93			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e93					NEXTW 
4e93			.GP2: 
4e93				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e93			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e93			 
4e93					NEXTW 
4e93			 
4e93			.GP3: 
4e93				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e93			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e93			 
4e93					NEXTW 
4e93			 
4e93			.GP4: 
4e93				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e93			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e93			 
4e93					NEXTW 
4e93			.SIN: 
4e93			 
4e93			 
4e93			endif 
4e93			 
4e93			 
4e93				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e93 33				db WORD_SYS_CORE+31             
4e94 c8 4e			dw .SOUT            
4e96 03				db 2 + 1 
4e97 .. 00			db "IN",0              
4e9a				endm 
# End of macro CWHEAD
4e9a			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e9a					if DEBUG_FORTH_WORDS_KEY 
4e9a						DMARK "IN." 
4e9a f5				push af  
4e9b 3a af 4e			ld a, (.dmark)  
4e9e 32 6e fb			ld (debug_mark),a  
4ea1 3a b0 4e			ld a, (.dmark+1)  
4ea4 32 6f fb			ld (debug_mark+1),a  
4ea7 3a b1 4e			ld a, (.dmark+2)  
4eaa 32 70 fb			ld (debug_mark+2),a  
4ead 18 03			jr .pastdmark  
4eaf ..			.dmark: db "IN."  
4eb2 f1			.pastdmark: pop af  
4eb3			endm  
# End of macro DMARK
4eb3						CALLMONITOR 
4eb3 cd ab 16			call break_point_state  
4eb6				endm  
# End of macro CALLMONITOR
4eb6					endif 
4eb6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eb6 cd ff 1e			call macro_dsp_valuehl 
4eb9				endm 
# End of macro FORTH_DSP_VALUEHL
4eb9			 
4eb9 e5					push hl 
4eba			 
4eba					; destroy value TOS 
4eba			 
4eba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eba cd b7 1f			call macro_forth_dsp_pop 
4ebd				endm 
# End of macro FORTH_DSP_POP
4ebd			 
4ebd					; one value on hl get other one back 
4ebd			 
4ebd c1					pop bc 
4ebe			 
4ebe					; do the sub 
4ebe			;		ex de, hl 
4ebe			 
4ebe ed 68				in l,(c) 
4ec0			 
4ec0					; save it 
4ec0			 
4ec0 26 00				ld h,0 
4ec2			 
4ec2					; TODO push value back onto stack for another op etc 
4ec2			 
4ec2 cd 08 1d				call forth_push_numhl 
4ec5					NEXTW 
4ec5 c3 71 20			jp macro_next 
4ec8				endm 
# End of macro NEXTW
4ec8			.SOUT: 
4ec8				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4ec8 34				db WORD_SYS_CORE+32             
4ec9 1b 4f			dw .SPIO            
4ecb 04				db 3 + 1 
4ecc .. 00			db "OUT",0              
4ed0				endm 
# End of macro CWHEAD
4ed0			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ed0					if DEBUG_FORTH_WORDS_KEY 
4ed0						DMARK "OUT" 
4ed0 f5				push af  
4ed1 3a e5 4e			ld a, (.dmark)  
4ed4 32 6e fb			ld (debug_mark),a  
4ed7 3a e6 4e			ld a, (.dmark+1)  
4eda 32 6f fb			ld (debug_mark+1),a  
4edd 3a e7 4e			ld a, (.dmark+2)  
4ee0 32 70 fb			ld (debug_mark+2),a  
4ee3 18 03			jr .pastdmark  
4ee5 ..			.dmark: db "OUT"  
4ee8 f1			.pastdmark: pop af  
4ee9			endm  
# End of macro DMARK
4ee9						CALLMONITOR 
4ee9 cd ab 16			call break_point_state  
4eec				endm  
# End of macro CALLMONITOR
4eec					endif 
4eec			 
4eec					; get port 
4eec			 
4eec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eec cd ff 1e			call macro_dsp_valuehl 
4eef				endm 
# End of macro FORTH_DSP_VALUEHL
4eef			 
4eef e5					push hl 
4ef0			 
4ef0					; destroy value TOS 
4ef0			 
4ef0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ef0 cd b7 1f			call macro_forth_dsp_pop 
4ef3				endm 
# End of macro FORTH_DSP_POP
4ef3			 
4ef3					; get byte to send 
4ef3			 
4ef3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ef3 cd ff 1e			call macro_dsp_valuehl 
4ef6				endm 
# End of macro FORTH_DSP_VALUEHL
4ef6			 
4ef6			;		push hl 
4ef6			 
4ef6					; destroy value TOS 
4ef6			 
4ef6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ef6 cd b7 1f			call macro_forth_dsp_pop 
4ef9				endm 
# End of macro FORTH_DSP_POP
4ef9			 
4ef9					; one value on hl get other one back 
4ef9			 
4ef9			;		pop hl 
4ef9			 
4ef9 c1					pop bc 
4efa			 
4efa					if DEBUG_FORTH_WORDS 
4efa						DMARK "OUT" 
4efa f5				push af  
4efb 3a 0f 4f			ld a, (.dmark)  
4efe 32 6e fb			ld (debug_mark),a  
4f01 3a 10 4f			ld a, (.dmark+1)  
4f04 32 6f fb			ld (debug_mark+1),a  
4f07 3a 11 4f			ld a, (.dmark+2)  
4f0a 32 70 fb			ld (debug_mark+2),a  
4f0d 18 03			jr .pastdmark  
4f0f ..			.dmark: db "OUT"  
4f12 f1			.pastdmark: pop af  
4f13			endm  
# End of macro DMARK
4f13						CALLMONITOR 
4f13 cd ab 16			call break_point_state  
4f16				endm  
# End of macro CALLMONITOR
4f16					endif 
4f16			 
4f16 ed 69				out (c), l 
4f18			 
4f18					NEXTW 
4f18 c3 71 20			jp macro_next 
4f1b				endm 
# End of macro NEXTW
4f1b			 
4f1b			 
4f1b			.SPIO: 
4f1b			 
4f1b			if STORAGE_SE 
4f1b				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4f1b 51				db WORD_SYS_CORE+61             
4f1c 2c 4f			dw .SPICEH            
4f1e 07				db 6 + 1 
4f1f .. 00			db "SPICEL",0              
4f26				endm 
# End of macro CWHEAD
4f26			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4f26			 
4f26 cd 6e 01				call spi_ce_low 
4f29			    NEXTW 
4f29 c3 71 20			jp macro_next 
4f2c				endm 
# End of macro NEXTW
4f2c			 
4f2c			.SPICEH: 
4f2c				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4f2c 51				db WORD_SYS_CORE+61             
4f2d 3d 4f			dw .SPIOb            
4f2f 07				db 6 + 1 
4f30 .. 00			db "SPICEH",0              
4f37				endm 
# End of macro CWHEAD
4f37			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4f37			 
4f37 cd 5d 01				call spi_ce_high 
4f3a			    NEXTW 
4f3a c3 71 20			jp macro_next 
4f3d				endm 
# End of macro NEXTW
4f3d			 
4f3d			 
4f3d			.SPIOb: 
4f3d			 
4f3d				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4f3d 51				db WORD_SYS_CORE+61             
4f3e 53 4f			dw .SPII            
4f40 05				db 4 + 1 
4f41 .. 00			db "SPIO",0              
4f46				endm 
# End of macro CWHEAD
4f46			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4f46			 
4f46					; get port 
4f46			 
4f46			 
4f46					; get byte to send 
4f46			 
4f46					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f46 cd ff 1e			call macro_dsp_valuehl 
4f49				endm 
# End of macro FORTH_DSP_VALUEHL
4f49			 
4f49			;		push hl    ; u1  
4f49			 
4f49					; destroy value TOS 
4f49			 
4f49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f49 cd b7 1f			call macro_forth_dsp_pop 
4f4c				endm 
# End of macro FORTH_DSP_POP
4f4c			 
4f4c					; one value on hl get other one back 
4f4c			 
4f4c			;		pop hl   ; u2 - addr 
4f4c			 
4f4c					; TODO Send SPI byte 
4f4c			 
4f4c 7d					ld a, l 
4f4d cd 92 00				call spi_send_byte 
4f50			 
4f50					NEXTW 
4f50 c3 71 20			jp macro_next 
4f53				endm 
# End of macro NEXTW
4f53			 
4f53			.SPII: 
4f53				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4f53 52				db WORD_SYS_CORE+62             
4f54 68 4f			dw .SESEL            
4f56 06				db 5 + 1 
4f57 .. 00			db "SPII",0              
4f5c				endm 
# End of macro CWHEAD
4f5c			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f5c			 
4f5c					; TODO Get SPI byte 
4f5c			 
4f5c cd b3 00				call spi_read_byte 
4f5f			 
4f5f 26 00				ld h, 0 
4f61 6f					ld l, a 
4f62 cd 08 1d				call forth_push_numhl 
4f65			 
4f65					NEXTW 
4f65 c3 71 20			jp macro_next 
4f68				endm 
# End of macro NEXTW
4f68			 
4f68			 
4f68			 
4f68			.SESEL: 
4f68				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f68 66				db WORD_SYS_CORE+82             
4f69 0c 50			dw .CARTDEV            
4f6b 05				db 4 + 1 
4f6c .. 00			db "BANK",0              
4f71				endm 
# End of macro CWHEAD
4f71			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f71					if DEBUG_FORTH_WORDS_KEY 
4f71						DMARK "BNK" 
4f71 f5				push af  
4f72 3a 86 4f			ld a, (.dmark)  
4f75 32 6e fb			ld (debug_mark),a  
4f78 3a 87 4f			ld a, (.dmark+1)  
4f7b 32 6f fb			ld (debug_mark+1),a  
4f7e 3a 88 4f			ld a, (.dmark+2)  
4f81 32 70 fb			ld (debug_mark+2),a  
4f84 18 03			jr .pastdmark  
4f86 ..			.dmark: db "BNK"  
4f89 f1			.pastdmark: pop af  
4f8a			endm  
# End of macro DMARK
4f8a						CALLMONITOR 
4f8a cd ab 16			call break_point_state  
4f8d				endm  
# End of macro CALLMONITOR
4f8d					endif 
4f8d			 
4f8d 3e ff				ld a, 255 
4f8f 32 42 f8				ld (spi_cartdev), a 
4f92			 
4f92					; get bank 
4f92			 
4f92					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f92 cd ff 1e			call macro_dsp_valuehl 
4f95				endm 
# End of macro FORTH_DSP_VALUEHL
4f95			 
4f95			;		push hl 
4f95			 
4f95					; destroy value TOS 
4f95			 
4f95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f95 cd b7 1f			call macro_forth_dsp_pop 
4f98				endm 
# End of macro FORTH_DSP_POP
4f98			 
4f98					; one value on hl get other one back 
4f98			 
4f98			;		pop hl 
4f98			 
4f98			 
4f98 0e ff				ld c, SPI_CE_HIGH 
4f9a 06 30				ld b, '0'    ; human readable bank number 
4f9c			 
4f9c 7d					ld a, l 
4f9d			 
4f9d					if DEBUG_FORTH_WORDS 
4f9d						DMARK "BNK" 
4f9d f5				push af  
4f9e 3a b2 4f			ld a, (.dmark)  
4fa1 32 6e fb			ld (debug_mark),a  
4fa4 3a b3 4f			ld a, (.dmark+1)  
4fa7 32 6f fb			ld (debug_mark+1),a  
4faa 3a b4 4f			ld a, (.dmark+2)  
4fad 32 70 fb			ld (debug_mark+2),a  
4fb0 18 03			jr .pastdmark  
4fb2 ..			.dmark: db "BNK"  
4fb5 f1			.pastdmark: pop af  
4fb6			endm  
# End of macro DMARK
4fb6						CALLMONITOR 
4fb6 cd ab 16			call break_point_state  
4fb9				endm  
# End of macro CALLMONITOR
4fb9					endif 
4fb9			 
4fb9					; active low 
4fb9			 
4fb9 fe 00				cp 0 
4fbb 28 28				jr z, .bset 
4fbd fe 01				cp 1 
4fbf 20 04				jr nz, .b2 
4fc1 cb 81				res 0, c 
4fc3 06 31				ld b, '1'    ; human readable bank number 
4fc5 fe 02		.b2:		cp 2 
4fc7 20 04				jr nz, .b3 
4fc9 cb 89				res 1, c 
4fcb 06 32				ld b, '2'    ; human readable bank number 
4fcd fe 03		.b3:		cp 3 
4fcf 20 04				jr nz, .b4 
4fd1 cb 91				res 2, c 
4fd3 06 33				ld b, '3'    ; human readable bank number 
4fd5 fe 04		.b4:		cp 4 
4fd7 20 04				jr nz, .b5 
4fd9 cb 99				res 3, c 
4fdb 06 34				ld b, '4'    ; human readable bank number 
4fdd fe 05		.b5:		cp 5 
4fdf 20 04				jr nz, .bset 
4fe1 cb a1				res 4, c 
4fe3 06 35				ld b, '5'    ; human readable bank number 
4fe5			 
4fe5			.bset: 
4fe5 79					ld a, c 
4fe6 32 3f f8				ld (spi_device),a 
4fe9 78					ld a, b 
4fea 32 3e f8				ld (spi_device_id),a 
4fed					if DEBUG_FORTH_WORDS 
4fed						DMARK "BN2" 
4fed f5				push af  
4fee 3a 02 50			ld a, (.dmark)  
4ff1 32 6e fb			ld (debug_mark),a  
4ff4 3a 03 50			ld a, (.dmark+1)  
4ff7 32 6f fb			ld (debug_mark+1),a  
4ffa 3a 04 50			ld a, (.dmark+2)  
4ffd 32 70 fb			ld (debug_mark+2),a  
5000 18 03			jr .pastdmark  
5002 ..			.dmark: db "BN2"  
5005 f1			.pastdmark: pop af  
5006			endm  
# End of macro DMARK
5006						CALLMONITOR 
5006 cd ab 16			call break_point_state  
5009				endm  
# End of macro CALLMONITOR
5009					endif 
5009			 
5009					NEXTW 
5009 c3 71 20			jp macro_next 
500c				endm 
# End of macro NEXTW
500c			 
500c			.CARTDEV: 
500c				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
500c 66				db WORD_SYS_CORE+82             
500d b5 50			dw .ENDDEVICE            
500f 08				db 7 + 1 
5010 .. 00			db "CARTDEV",0              
5018				endm 
# End of macro CWHEAD
5018			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5018					if DEBUG_FORTH_WORDS_KEY 
5018						DMARK "CDV" 
5018 f5				push af  
5019 3a 2d 50			ld a, (.dmark)  
501c 32 6e fb			ld (debug_mark),a  
501f 3a 2e 50			ld a, (.dmark+1)  
5022 32 6f fb			ld (debug_mark+1),a  
5025 3a 2f 50			ld a, (.dmark+2)  
5028 32 70 fb			ld (debug_mark+2),a  
502b 18 03			jr .pastdmark  
502d ..			.dmark: db "CDV"  
5030 f1			.pastdmark: pop af  
5031			endm  
# End of macro DMARK
5031						CALLMONITOR 
5031 cd ab 16			call break_point_state  
5034				endm  
# End of macro CALLMONITOR
5034					endif 
5034			 
5034					; disable se storage bank selection 
5034			 
5034 3e ff				ld a, SPI_CE_HIGH		; ce high 
5036 32 3f f8				ld (spi_device), a 
5039			 
5039					; get bank 
5039			 
5039					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5039 cd ff 1e			call macro_dsp_valuehl 
503c				endm 
# End of macro FORTH_DSP_VALUEHL
503c			 
503c			;		push hl 
503c			 
503c					; destroy value TOS 
503c			 
503c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
503c cd b7 1f			call macro_forth_dsp_pop 
503f				endm 
# End of macro FORTH_DSP_POP
503f			 
503f					; one value on hl get other one back 
503f			 
503f			;		pop hl 
503f			 
503f					; active low 
503f			 
503f 0e ff				ld c, 255 
5041			 
5041 7d					ld a, l 
5042					if DEBUG_FORTH_WORDS 
5042						DMARK "CDV" 
5042 f5				push af  
5043 3a 57 50			ld a, (.dmark)  
5046 32 6e fb			ld (debug_mark),a  
5049 3a 58 50			ld a, (.dmark+1)  
504c 32 6f fb			ld (debug_mark+1),a  
504f 3a 59 50			ld a, (.dmark+2)  
5052 32 70 fb			ld (debug_mark+2),a  
5055 18 03			jr .pastdmark  
5057 ..			.dmark: db "CDV"  
505a f1			.pastdmark: pop af  
505b			endm  
# End of macro DMARK
505b						CALLMONITOR 
505b cd ab 16			call break_point_state  
505e				endm  
# End of macro CALLMONITOR
505e					endif 
505e fe 00				cp 0 
5060 28 30				jr z, .cset 
5062 fe 01				cp 1 
5064 20 02				jr nz, .c2 
5066 cb 81				res 0, c 
5068 fe 02		.c2:		cp 2 
506a 20 02				jr nz, .c3 
506c cb 89				res 1, c 
506e fe 03		.c3:		cp 3 
5070 20 02				jr nz, .c4 
5072 cb 91				res 2, c 
5074 fe 04		.c4:		cp 4 
5076 20 02				jr nz, .c5 
5078 cb 99				res 3, c 
507a fe 05		.c5:		cp 5 
507c 20 02				jr nz, .c6 
507e cb a1				res 4, c 
5080 fe 06		.c6:		cp 6 
5082 20 02				jr nz, .c7 
5084 cb a9				res 5, c 
5086 fe 07		.c7:		cp 7 
5088 20 02				jr nz, .c8 
508a cb b1				res 6, c 
508c fe 08		.c8:		cp 8 
508e 20 02				jr nz, .cset 
5090 cb b9				res 7, c 
5092 79			.cset:		ld a, c 
5093 32 42 f8				ld (spi_cartdev),a 
5096			 
5096					if DEBUG_FORTH_WORDS 
5096						DMARK "CD2" 
5096 f5				push af  
5097 3a ab 50			ld a, (.dmark)  
509a 32 6e fb			ld (debug_mark),a  
509d 3a ac 50			ld a, (.dmark+1)  
50a0 32 6f fb			ld (debug_mark+1),a  
50a3 3a ad 50			ld a, (.dmark+2)  
50a6 32 70 fb			ld (debug_mark+2),a  
50a9 18 03			jr .pastdmark  
50ab ..			.dmark: db "CD2"  
50ae f1			.pastdmark: pop af  
50af			endm  
# End of macro DMARK
50af						CALLMONITOR 
50af cd ab 16			call break_point_state  
50b2				endm  
# End of macro CALLMONITOR
50b2					endif 
50b2					NEXTW 
50b2 c3 71 20			jp macro_next 
50b5				endm 
# End of macro NEXTW
50b5			endif 
50b5			 
50b5			.ENDDEVICE: 
50b5			; eof 
50b5			 
# End of file forth_words_device.asm
50b5			 
50b5			; var handler 
50b5			 
50b5			 
50b5			.VARS: 
50b5				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
50b5 78				db WORD_SYS_CORE+100             
50b6 cd 50			dw .V0Q            
50b8 04				db 3 + 1 
50b9 .. 00			db "V0!",0              
50bd				endm 
# End of macro CWHEAD
50bd			;| V0! ( u1 -- )  Store value to v0  | DONE 
50bd			 
50bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50bd cd ff 1e			call macro_dsp_valuehl 
50c0				endm 
# End of macro FORTH_DSP_VALUEHL
50c0			 
50c0 11 07 f8				ld de, cli_var_array 
50c3			 
50c3 eb					ex de, hl 
50c4 73					ld (hl), e 
50c5 23					inc hl 
50c6 72					ld (hl), d 
50c7			 
50c7					; destroy value TOS 
50c7			 
50c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50c7 cd b7 1f			call macro_forth_dsp_pop 
50ca				endm 
# End of macro FORTH_DSP_POP
50ca			 
50ca				       NEXTW 
50ca c3 71 20			jp macro_next 
50cd				endm 
# End of macro NEXTW
50cd			.V0Q: 
50cd				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
50cd 79				db WORD_SYS_CORE+101             
50ce de 50			dw .V1S            
50d0 04				db 3 + 1 
50d1 .. 00			db "V0@",0              
50d5				endm 
# End of macro CWHEAD
50d5			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
50d5 2a 07 f8				ld hl, (cli_var_array) 
50d8 cd 08 1d				call forth_push_numhl 
50db			 
50db				       NEXTW 
50db c3 71 20			jp macro_next 
50de				endm 
# End of macro NEXTW
50de			.V1S: 
50de				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
50de 7a				db WORD_SYS_CORE+102             
50df f6 50			dw .V1Q            
50e1 04				db 3 + 1 
50e2 .. 00			db "V1!",0              
50e6				endm 
# End of macro CWHEAD
50e6			;| V1! ( u1 -- )  Store value to v1 | DONE 
50e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50e6 cd ff 1e			call macro_dsp_valuehl 
50e9				endm 
# End of macro FORTH_DSP_VALUEHL
50e9			 
50e9 11 09 f8				ld de, cli_var_array+2 
50ec				 
50ec eb					ex de, hl 
50ed 73					ld (hl), e 
50ee 23					inc hl 
50ef 72					ld (hl), d 
50f0			 
50f0					; destroy value TOS 
50f0			 
50f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50f0 cd b7 1f			call macro_forth_dsp_pop 
50f3				endm 
# End of macro FORTH_DSP_POP
50f3				       NEXTW 
50f3 c3 71 20			jp macro_next 
50f6				endm 
# End of macro NEXTW
50f6			.V1Q: 
50f6				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
50f6 7b				db WORD_SYS_CORE+103             
50f7 07 51			dw .V2S            
50f9 04				db 3 + 1 
50fa .. 00			db "V1@",0              
50fe				endm 
# End of macro CWHEAD
50fe			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
50fe 2a 09 f8				ld hl, (cli_var_array+2) 
5101 cd 08 1d				call forth_push_numhl 
5104				       NEXTW 
5104 c3 71 20			jp macro_next 
5107				endm 
# End of macro NEXTW
5107			.V2S: 
5107				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5107 7c				db WORD_SYS_CORE+104             
5108 1f 51			dw .V2Q            
510a 04				db 3 + 1 
510b .. 00			db "V2!",0              
510f				endm 
# End of macro CWHEAD
510f			;| V2! ( u1 -- )  Store value to v2 | DONE 
510f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
510f cd ff 1e			call macro_dsp_valuehl 
5112				endm 
# End of macro FORTH_DSP_VALUEHL
5112			 
5112 11 0b f8				ld de, cli_var_array+4 
5115				 
5115 eb					ex de, hl 
5116 73					ld (hl), e 
5117 23					inc hl 
5118 72					ld (hl), d 
5119			 
5119					; destroy value TOS 
5119			 
5119					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5119 cd b7 1f			call macro_forth_dsp_pop 
511c				endm 
# End of macro FORTH_DSP_POP
511c				       NEXTW 
511c c3 71 20			jp macro_next 
511f				endm 
# End of macro NEXTW
511f			.V2Q: 
511f				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
511f 7d				db WORD_SYS_CORE+105             
5120 30 51			dw .V3S            
5122 04				db 3 + 1 
5123 .. 00			db "V2@",0              
5127				endm 
# End of macro CWHEAD
5127			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5127 2a 0b f8				ld hl, (cli_var_array+4) 
512a cd 08 1d				call forth_push_numhl 
512d				       NEXTW 
512d c3 71 20			jp macro_next 
5130				endm 
# End of macro NEXTW
5130			.V3S: 
5130				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5130 7c				db WORD_SYS_CORE+104             
5131 48 51			dw .V3Q            
5133 04				db 3 + 1 
5134 .. 00			db "V3!",0              
5138				endm 
# End of macro CWHEAD
5138			;| V3! ( u1 -- )  Store value to v3 | DONE 
5138					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5138 cd ff 1e			call macro_dsp_valuehl 
513b				endm 
# End of macro FORTH_DSP_VALUEHL
513b			 
513b 11 0d f8				ld de, cli_var_array+6 
513e				 
513e eb					ex de, hl 
513f 73					ld (hl), e 
5140 23					inc hl 
5141 72					ld (hl), d 
5142			 
5142					; destroy value TOS 
5142			 
5142					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5142 cd b7 1f			call macro_forth_dsp_pop 
5145				endm 
# End of macro FORTH_DSP_POP
5145				       NEXTW 
5145 c3 71 20			jp macro_next 
5148				endm 
# End of macro NEXTW
5148			.V3Q: 
5148				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5148 7d				db WORD_SYS_CORE+105             
5149 59 51			dw .END            
514b 04				db 3 + 1 
514c .. 00			db "V3@",0              
5150				endm 
# End of macro CWHEAD
5150			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5150 2a 0d f8				ld hl, (cli_var_array+6) 
5153 cd 08 1d				call forth_push_numhl 
5156				       NEXTW 
5156 c3 71 20			jp macro_next 
5159				endm 
# End of macro NEXTW
5159			 
5159			 
5159			 
5159			 
5159			 
5159			; end of dict marker 
5159			 
5159 00			.END:    db WORD_SYS_END 
515a 00 00			dw 0 
515c 00				db 0 
515d			 
515d			; use to jp here for user dict words to save on macro expansion  
515d			 
515d			user_dict_next: 
515d				NEXTW 
515d c3 71 20			jp macro_next 
5160				endm 
# End of macro NEXTW
5160			 
5160			 
5160			user_exec: 
5160				;    ld hl, <word code> 
5160				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5160				;    call forthexec 
5160				;    jp user_dict_next   (NEXT) 
5160			        ;    <word code bytes> 
5160 eb				ex de, hl 
5161 2a 15 f1			ld hl,(os_tok_ptr) 
5164				 
5164				FORTH_RSP_NEXT 
5164 cd af 1c			call macro_forth_rsp_next 
5167				endm 
# End of macro FORTH_RSP_NEXT
5167			 
5167			if DEBUG_FORTH_UWORD 
5167						DMARK "UEX" 
5167 f5				push af  
5168 3a 7c 51			ld a, (.dmark)  
516b 32 6e fb			ld (debug_mark),a  
516e 3a 7d 51			ld a, (.dmark+1)  
5171 32 6f fb			ld (debug_mark+1),a  
5174 3a 7e 51			ld a, (.dmark+2)  
5177 32 70 fb			ld (debug_mark+2),a  
517a 18 03			jr .pastdmark  
517c ..			.dmark: db "UEX"  
517f f1			.pastdmark: pop af  
5180			endm  
# End of macro DMARK
5180				CALLMONITOR 
5180 cd ab 16			call break_point_state  
5183				endm  
# End of macro CALLMONITOR
5183			endif 
5183			 
5183			 
5183			 
5183 eb				ex de, hl 
5184 22 15 f1			ld (os_tok_ptr), hl 
5187				 
5187				; Don't use next - Skips the first word in uword. 
5187			 
5187 c3 02 21			jp exec1 
518a			;	NEXT 
518a			 
518a			 
518a			; eof 
# End of file forth_wordsv4.asm
518a			endif 
518a			;;;;;;;;;;;;;; Debug code 
518a			 
518a			 
518a			;if DEBUG_FORTH_PARSE 
518a .. 00		.nowordfound: db "No match",0 
5193 .. 00		.compword:	db "Comparing word ",0 
51a3 .. 00		.nextwordat:	db "Next word at",0 
51b0 .. 00		.charmatch:	db "Char match",0 
51bb			;endif 
51bb			if DEBUG_FORTH_JP 
51bb			.foundword:	db "Word match. Exec..",0 
51bb			endif 
51bb			;if DEBUG_FORTH_PUSH 
51bb .. 00		.enddict:	db "Dict end. Push.",0 
51cb .. 00		.push_str:	db "Pushing string",0 
51da .. 00		.push_num:	db "Pushing number",0 
51e9 .. 00		.data_sp:	db "SP:",0 
51ed .. 00		.wordinhl:	db "Word in HL (2/0):",0 
51ff .. 00		.wordinde:	db "Word in DE (3/0):",0 
5211 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5223			;endif 
5223			;if DEBUG_FORTH_MALLOC 
5223 .. 00		.push_malloc:	db "Malloc address",0 
5232			;endif 
5232			 
5232			 
5232			 
5232			; display malloc address and current data stack pointer  
5232			 
5232			malloc_error: 
5232 d5				push de 
5233 f5				push af 
5234 e5				push hl 
5235 cd d0 0a			call clear_display 
5238 11 5a 52			ld de, .mallocerr 
523b 3e 00			ld a,0 
523d			;	ld de,os_word_scratch 
523d cd e3 0a			call str_at_display 
5240 3e 11			ld a, display_row_1+17 
5242 11 6e fb			ld de, debug_mark 
5245 cd e3 0a			call str_at_display 
5248 cd f3 0a			call update_display 
524b				;call break_point_state 
524b cd 54 69			call cin_wait 
524e			 
524e 3e 20			ld a, ' ' 
5250 32 05 ee			ld (os_view_disable), a 
5253 e1				pop hl 
5254 f1				pop af 
5255 d1				pop de	 
5256				CALLMONITOR 
5256 cd ab 16			call break_point_state  
5259				endm  
# End of macro CALLMONITOR
5259 c9				ret 
525a			 
525a .. 00		.mallocerr: 	db "Malloc Error",0 
5267			;if DEBUG_FORTH_PUSH 
5267			display_data_sp: 
5267 f5				push af 
5268			 
5268				; see if disabled 
5268			 
5268 3a 05 ee			ld a, (os_view_disable) 
526b fe 2a			cp '*' 
526d 28 67			jr z, .skipdsp 
526f			 
526f e5				push hl 
5270 e5				push hl 
5271 e5			push hl 
5272 cd d0 0a			call clear_display 
5275 e1			pop hl 
5276 7c				ld a,h 
5277 21 19 f1			ld hl, os_word_scratch 
527a cd 05 10			call hexout 
527d e1				pop hl 
527e 7d				ld a,l 
527f 21 1b f1			ld hl, os_word_scratch+2 
5282 cd 05 10			call hexout 
5285 21 1d f1			ld hl, os_word_scratch+4 
5288 3e 00			ld a,0 
528a 77				ld (hl),a 
528b 11 19 f1			ld de,os_word_scratch 
528e 3e 28				ld a, display_row_2 
5290 cd e3 0a				call str_at_display 
5293 11 ed 51			ld de, .wordinhl 
5296 3e 00			ld a, display_row_1 
5298			 
5298 cd e3 0a				call str_at_display 
529b 11 6e fb			ld de, debug_mark 
529e 3e 11			ld a, display_row_1+17 
52a0			 
52a0 cd e3 0a				call str_at_display 
52a3			 
52a3				; display current data stack pointer 
52a3 11 e9 51			ld de,.data_sp 
52a6 3e 30				ld a, display_row_2 + 8 
52a8 cd e3 0a				call str_at_display 
52ab			 
52ab 2a 01 f8			ld hl,(cli_data_sp) 
52ae e5				push hl 
52af 7c				ld a,h 
52b0 21 19 f1			ld hl, os_word_scratch 
52b3 cd 05 10			call hexout 
52b6 e1				pop hl 
52b7 7d				ld a,l 
52b8 21 1b f1			ld hl, os_word_scratch+2 
52bb cd 05 10			call hexout 
52be 21 1d f1			ld hl, os_word_scratch+4 
52c1 3e 00			ld a,0 
52c3 77				ld (hl),a 
52c4 11 19 f1			ld de,os_word_scratch 
52c7 3e 33				ld a, display_row_2 + 11 
52c9 cd e3 0a				call str_at_display 
52cc			 
52cc			 
52cc cd f3 0a			call update_display 
52cf cd 4d 0a			call delay1s 
52d2 cd 4d 0a			call delay1s 
52d5 e1				pop hl 
52d6			.skipdsp: 
52d6 f1				pop af 
52d7 c9				ret 
52d8			 
52d8			display_data_malloc: 
52d8			 
52d8 f5				push af 
52d9 e5				push hl 
52da e5				push hl 
52db e5			push hl 
52dc cd d0 0a			call clear_display 
52df e1			pop hl 
52e0 7c				ld a,h 
52e1 21 19 f1			ld hl, os_word_scratch 
52e4 cd 05 10			call hexout 
52e7 e1				pop hl 
52e8 7d				ld a,l 
52e9 21 1b f1			ld hl, os_word_scratch+2 
52ec cd 05 10			call hexout 
52ef 21 1d f1			ld hl, os_word_scratch+4 
52f2 3e 00			ld a,0 
52f4 77				ld (hl),a 
52f5 11 19 f1			ld de,os_word_scratch 
52f8 3e 28				ld a, display_row_2 
52fa cd e3 0a				call str_at_display 
52fd 11 23 52			ld de, .push_malloc 
5300 3e 00			ld a, display_row_1 
5302			 
5302 cd e3 0a				call str_at_display 
5305			 
5305				; display current data stack pointer 
5305 11 e9 51			ld de,.data_sp 
5308 3e 30				ld a, display_row_2 + 8 
530a cd e3 0a				call str_at_display 
530d			 
530d 2a 01 f8			ld hl,(cli_data_sp) 
5310 e5				push hl 
5311 7c				ld a,h 
5312 21 19 f1			ld hl, os_word_scratch 
5315 cd 05 10			call hexout 
5318 e1				pop hl 
5319 7d				ld a,l 
531a 21 1b f1			ld hl, os_word_scratch+2 
531d cd 05 10			call hexout 
5320 21 1d f1			ld hl, os_word_scratch+4 
5323 3e 00			ld a,0 
5325 77				ld (hl),a 
5326 11 19 f1			ld de,os_word_scratch 
5329 3e 33				ld a, display_row_2 + 11 
532b cd e3 0a				call str_at_display 
532e			 
532e cd f3 0a			call update_display 
5331 cd 4d 0a			call delay1s 
5334 cd 4d 0a			call delay1s 
5337 e1				pop hl 
5338 f1				pop af 
5339 c9				ret 
533a			;endif 
533a			 
533a			include "forth_autostart.asm" 
533a			; list of commands to perform at system start up 
533a			 
533a			startcmds: 
533a			;	dw test11 
533a			;	dw test12 
533a			;	dw test13 
533a			;	dw test14 
533a			;	dw test15 
533a			;	dw test16 
533a			;	dw test17 
533a			;	dw ifthtest1 
533a			;	dw ifthtest2 
533a			;	dw ifthtest3 
533a			;	dw mmtest1 
533a			;	dw mmtest2 
533a			;	dw mmtest3 
533a			;	dw mmtest4 
533a			;	dw mmtest5 
533a			;	dw mmtest6 
533a			;	dw iftest1 
533a			;	dw iftest2 
533a			;	dw iftest3 
533a			;	dw looptest1 
533a			;	dw looptest2 
533a			;	dw test1 
533a			;	dw test2 
533a			;	dw test3 
533a			;	dw test4 
533a			;	dw game2r 
533a			;	dw game2b1 
533a			;	dw game2b2 
533a			 
533a				; start up words that are actually useful 
533a			 
533a 98 53			dw clrstack 
533c cb 53			dw type 
533e 8c 55			dw stest 
5340 ef 53			dw strncpy 
5342 2d 55			dw list 
5344 50 54			dw start1 
5346 62 54			dw start2 
5348			;	dw start3 
5348 75 54			dw start3b 
534a cd 54			dw start3c 
534c			 
534c				; (unit) testing words 
534c			 
534c 03 56			dw mtesta 
534e b8 56			dw mtestb 
5350 5b 57			dw mtestc 
5352 10 58			dw mtestd 
5354 b4 58			dw mteste 
5356			 
5356				; demo/game words 
5356			 
5356 c0 5f		        dw game3w 
5358 ee 5f		        dw game3p 
535a 0c 60		        dw game3sc 
535c 3d 60		        dw game3vsi 
535e 69 60		        dw game3vs 
5360				 
5360 b3 5d			dw game2b 
5362 21 5e			dw game2bf 
5364 6b 5e			dw game2mba 
5366 01 5f			dw game2mbas 
5368 43 5f			dw game2mb 
536a			 
536a 74 5a			dw game1 
536c 85 5a			dw game1a 
536e e7 5a			dw game1b 
5370 1c 5b			dw game1c 
5372 52 5b			dw game1d 
5374 83 5b			dw game1s 
5376 97 5b			dw game1t 
5378 ac 5b			dw game1f 
537a e0 5b			dw game1z 
537c 24 5c			dw game1zz 
537e			 
537e 6a 59			dw test5 
5380 a2 59			dw test6 
5382 da 59			dw test7 
5384 ee 59			dw test8 
5386 1a 5a			dw test9 
5388 30 5a			dw test10 
538a				 
538a fb 5c		        dw ssv5 
538c df 5c		        dw ssv4 
538e c3 5c		        dw ssv3 
5390 8d 5c		        dw ssv2 
5392 14 5d		        dw ssv1 
5394 5c 5d		        dw ssv1cpm 
5396			;	dw keyup 
5396			;	dw keydown 
5396			;	dw keyleft 
5396			;	dw keyright 
5396			;	dw 	keyf1 
5396			;	dw keyf2 
5396			;	dw keyf3 
5396			;	dw keyf4 
5396			;	dw keyf5 
5396			;	dw keyf6 
5396			;	dw keyf7 
5396			;	dw keyf8 
5396			;	dw keyf9 
5396			;	dw keyf10 
5396			;	dw keyf11 
5396			;	dw keyf12 
5396			;	dw keytab 
5396			;	dw keycr 
5396			;	dw keyhome 
5396			;	dw keyend 
5396			;	dw keybs 
5396 00 00			db 0, 0	 
5398			 
5398			 
5398			; clear stack  
5398			 
5398 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
53cb			 
53cb			; type ( addr count - ) 
53cb .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
53ef			 
53ef			; some direct memory words 
53ef			; strncpy ( len t f -- t ) 
53ef			 
53ef .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5450			 
5450 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5462 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5475			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5475 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
54cd .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
552d			 
552d			 
552d			; a handy word to list items on the stack 
552d			 
552d .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
558c			 
558c			 
558c			; test stack  
558c			; rnd8 stest 
558c			 
558c .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5603			 
5603			; random malloc and free cycles 
5603			 
5603 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56b8			 
56b8			; fixed malloc and free cycles 
56b8			 
56b8 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
575b			 
575b			; fixed double string push and drop cycle  
575b			 
575b .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5810			 
5810			; consistent fixed string push and drop cycle  
5810			 
5810 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58b4			 
58b4 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
596a			 
596a			;test1:		db ": aa 1 2 3 ;", 0 
596a			;test2:     	db "111 aa 888 999",0 
596a			;test3:     	db ": bb 77 ;",0 
596a			;test4:     	db "$02 $01 do i . loop bb",0 
596a			 
596a .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
59a2 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
59da .. 00		test7:     	db ": box hline vline ;",0 
59ee .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5a1a .. 00		test9:     	db ": sw $01 adsp world ;",0 
5a30 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a55 .. 00		test11:     	db "hello create .",0 
5a64 .. 00		test12:     	db "hello2 create .",0 
5a74			 
5a74			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a74			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a74			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a74			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a74			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a74			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a74			 
5a74			;iftest1:     	db "$0001 IF cls .",0 
5a74			;iftest2:     	db "$0000 IF cls .",0 
5a74			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a74			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a74			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a74			 
5a74			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a74			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a74			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a74			 
5a74			 
5a74			 
5a74			; a small guess the number game 
5a74			 
5a74 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a85 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5ae7			 
5ae7 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5b1c .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b52 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b83 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b97 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5bac .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5be0 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5c24			 
5c24			; Using 'ga' save a high score across multiple runs using external storage 
5c24			 
5c24 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c8d			 
5c8d			 
5c8d			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c8d			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c8d			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c8d			 
5c8d			; simple screen saver to test code memory reuse to destruction 
5c8d			 
5c8d .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5cc3 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5cdf .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5cfb .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5d14 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d5c .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5db3			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5db3			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5db3			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5db3			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5db3			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5db3			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5db3			 
5db3			 
5db3			 
5db3			; minesweeper/battleship finding game 
5db3			; draws a game board of random ship/mine positions 
5db3			; user enters coords to see if it hits on 
5db3			; game ends when all are hit 
5db3			; when hit or miss says how many may be in the area 
5db3			 
5db3			; setup the game board and then hide it 
5db3 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5e21 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e6b			; prompt for where to target 
5e6b .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5f01 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5f26			; TODO see if the entered coords hits or misses pushes char hit of miss 
5f26 .. 00		game2mbht:      db ": mbckht nop ;",0 
5f35 .. 00		game2mbms:      db ": mbcms nop ;",0 
5f43			; TODO how many might be near by 
5f43 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5fc0			 
5fc0			; Game 3 
5fc0			 
5fc0			; Vert scroller ski game - avoid the trees! 
5fc0			 
5fc0			; v0 score (ie turns) 
5fc0			; v1 player pos 
5fc0			; v2 left wall 
5fc0			; v3 right wall 
5fc0			 
5fc0			; Draw side walls randomly 
5fc0			 
5fc0 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5fee			 
5fee			; Draw player 
5fee .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
600c			 
600c			; TODO Get Key 
600c			 
600c			; TODO Move left right 
600c			 
600c			; scroll and move walls a bit 
600c			 
600c .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
603d			 
603d			; main game loop 
603d			 
603d .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6069 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
60a8			 
60a8			; key board defs 
60a8			 
60a8 .. 00		keyup:       db ": keyup $05 ;",0 
60b6 .. 00		keydown:       db ": keydown $0a ;",0 
60c6 .. 00		keyleft:       db ": keyleft $0b ;",0 
60d6 .. 00		keyright:       db ": keyright $0c ;",0 
60e7 .. 00		keyf1:       db ": keyf1 $10 ;",0 
60f5 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6103 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6111 .. 00		keyf4:       db ": keyf4 $13 ;",0 
611f .. 00		keyf5:       db ": keyf5 $14 ;",0 
612d .. 00		keyf6:       db ": keyf6 $15 ;",0 
613b .. 00		keyf7:       db ": keyf7 $16 ;",0 
6149 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6157 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6165 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6174 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6183 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6192			 
6192 .. 00		keytab:       db ": keytab $09 ;",0 
61a1 .. 00		keycr:       db ": keycr $0d ;",0 
61af .. 00		keyhome:       db ": keyhome $0e ;",0 
61bf .. 00		keyend:       db ": keyend $0f ;",0 
61ce .. 00		keybs:       db ": keybs $08 ;",0 
61dc			 
61dc			   
61dc			 
61dc			 
61dc			 
61dc			; eof 
# End of file forth_autostart.asm
61dc			 
61dc .. 00		sprompt1: db "Startup load...",0 
61ec .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6202			 
6202			 
6202			 
6202			 
6202			forth_startup: 
6202 21 3a 53			ld hl, startcmds 
6205 3e 00			ld a, 0 
6207 32 3a f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
620a			 
620a e5			.start1:	push hl 
620b cd d0 0a			call clear_display 
620e 11 dc 61			ld de, sprompt1 
6211 3e 00		        ld a, display_row_1 
6213 cd e3 0a			call str_at_display 
6216 11 ec 61			ld de, sprompt2 
6219 3e 28		        ld a, display_row_2 
621b cd e3 0a			call str_at_display 
621e e1				pop hl 
621f e5				push hl 
6220 5e				ld e,(hl) 
6221 23				inc hl 
6222 56				ld d,(hl) 
6223 3e 50		        ld a, display_row_3 
6225 cd e3 0a			call str_at_display 
6228 cd f3 0a			call update_display 
622b			 
622b			 
622b 3a 3a f2			ld a, (os_last_cmd) 
622e fe 00			cp 0 
6230 28 05			jr z, .startprompt 
6232 cd 41 0a			call delay250ms 
6235 18 24			jr .startdo 
6237				 
6237				 
6237			 
6237			.startprompt: 
6237			 
6237 3e 9f			ld a,display_row_4 + display_cols - 1 
6239 11 7e 1c		        ld de, endprg 
623c cd e3 0a			call str_at_display 
623f cd f3 0a			call update_display 
6242 cd 4d 0a			call delay1s 
6245 cd 54 69			call cin_wait 
6248						 
6248 fe 2a			cp '*' 
624a 28 5e			jr z, .startupend1 
624c fe 23			cp '#' 
624e 20 07			jr nz, .startno 
6250 3e 01			ld a, 1 
6252 32 3a f2			ld (os_last_cmd),a 
6255 18 04			jr .startdo 
6257 fe 31		.startno:	cp '1' 
6259 28 3a			jr z,.startnxt  
625b			 
625b				; exec startup line 
625b			.startdo:	 
625b e1				pop hl 
625c e5				push hl 
625d				 
625d 5e				ld e,(hl) 
625e 23				inc hl 
625f 56				ld d,(hl) 
6260 eb				ex de,hl 
6261			 
6261 e5				push hl 
6262			 
6262 3e 00			ld a, 0 
6264				;ld a, FORTH_END_BUFFER 
6264 cd 6d 11			call strlent 
6267 23				inc hl   ; include zero term to copy 
6268 06 00			ld b,0 
626a 4d				ld c,l 
626b e1				pop hl 
626c 11 14 ee			ld de, scratch 
626f ed b0			ldir 
6271			 
6271			 
6271 21 14 ee			ld hl, scratch 
6274 cd bf 20			call forthparse 
6277 cd ff 20			call forthexec 
627a cd 16 20			call forthexec_cleanup 
627d			 
627d 3e 78			ld a, display_row_4 
627f 11 22 1a			ld de, endprog 
6282			 
6282 cd f3 0a			call update_display		 
6285			 
6285 3a 3a f2			ld a, (os_last_cmd) 
6288 fe 00			cp 0 
628a 20 09			jr nz, .startnxt 
628c cd 80 1c			call next_page_prompt 
628f cd d0 0a		        call clear_display 
6292 cd f3 0a			call update_display		 
6295			 
6295				; move onto next startup line? 
6295			.startnxt: 
6295			 
6295 cd 41 0a			call delay250ms 
6298 e1				pop hl 
6299			 
6299 23				inc hl 
629a 23				inc hl 
629b			 
629b e5				push hl 
629c 5e				ld e, (hl) 
629d 23				inc hl 
629e 56				ld d, (hl) 
629f e1				pop hl 
62a0				; TODO replace 0 test 
62a0			 
62a0 eb				ex de, hl 
62a1 cd 2d 0d			call ishlzero 
62a4			;	ld a,e 
62a4			;	add d 
62a4			;	cp 0    ; any left to do? 
62a4 eb				ex de, hl 
62a5 c2 0a 62			jp nz, .start1 
62a8 18 01			jr .startupend 
62aa			 
62aa e1			.startupend1: pop hl 
62ab			.startupend: 
62ab			 
62ab cd d0 0a			call clear_display 
62ae cd f3 0a			call update_display 
62b1 c9				ret 
62b2			 
62b2			 
62b2			; stack over and underflow checks 
62b2			 
62b2			; init the words to detect the under/overflow 
62b2			 
62b2			chk_stk_init: 
62b2				; a vague random number to check so we dont get any "lucky" hits 
62b2 3e 2d			ld a, 45 
62b4 6f				ld l, a 
62b5 00				nop 
62b6 3e 17			ld a, 23 
62b8 67				ld h, a 
62b9			 
62b9 22 fb ed			ld (chk_word), hl     ; the word we need to check against 
62bc			 
62bc			;	ld (chk_stund), hl	; stack points.... 
62bc 22 fd fb			ld (chk_stovr), hl 
62bf 22 ff f7			ld (chk_ret_und), hl 
62c2 22 7d f7			ld (chk_ret_ovr), hl 
62c5 22 7b f5			ld (chk_loop_ovr), hl 
62c8 22 79 f3			ld (chk_data_ovr), hl 
62cb c9				ret 
62cc				 
62cc			check_stacks: 
62cc				; check all stack words 
62cc			 
62cc e5				push hl 
62cd d5				push de 
62ce			 
62ce			;	ld de,(chk_word) 
62ce			;	ld hl, (chk_stund)	; stack points.... 
62ce			;	if DEBUG_STK_FAULT 
62ce			;		DMARK "FAa" 
62ce			;		CALLMONITOR 
62ce			;	endif 
62ce			;	call cmp16 
62ce			;	jp z, .chk_faulta 
62ce			; 
62ce			;	ld de, sfaultsu 
62ce			;	jp .chk_fault 
62ce			 
62ce 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
62d1 ed 5b fb ed		ld de,(chk_word) 
62d5				if DEBUG_STK_FAULT 
62d5					DMARK "FAb" 
62d5					CALLMONITOR 
62d5				endif 
62d5 cd 22 0d			call cmp16 
62d8 28 06			jr z, .chk_fault1 
62da 11 7b 63			ld de, sfaultso 
62dd c3 2f 63			jp .chk_fault 
62e0			.chk_fault1:  
62e0 2a ff f7			ld hl, (chk_ret_und) 
62e3 ed 5b fb ed		ld de,(chk_word) 
62e7				if DEBUG_STK_FAULT 
62e7					DMARK "FAU" 
62e7					CALLMONITOR 
62e7				endif 
62e7 cd 22 0d			call cmp16 
62ea ca f3 62			jp z, .chk_fault2 
62ed 11 8b 63			ld de, sfaultru 
62f0 c3 2f 63			jp .chk_fault 
62f3			.chk_fault2:  
62f3 2a 7d f7			ld hl, (chk_ret_ovr) 
62f6 ed 5b fb ed		ld de,(chk_word) 
62fa				if DEBUG_STK_FAULT 
62fa					DMARK "FA1" 
62fa					CALLMONITOR 
62fa				endif 
62fa cd 22 0d			call cmp16 
62fd ca 06 63			jp z, .chk_fault3 
6300 11 99 63			ld de, sfaultro 
6303 c3 2f 63			jp .chk_fault 
6306			.chk_fault3:  
6306 2a 7b f5			ld hl, (chk_loop_ovr) 
6309 ed 5b fb ed		ld de,(chk_word) 
630d				if DEBUG_STK_FAULT 
630d					DMARK "FA2" 
630d					CALLMONITOR 
630d				endif 
630d cd 22 0d			call cmp16 
6310 ca 19 63			jp z, .chk_fault4 
6313 11 b3 63			ld de, sfaultlo 
6316 c3 2f 63			jp .chk_fault 
6319			.chk_fault4:  
6319 2a 79 f3			ld hl, (chk_data_ovr) 
631c ed 5b fb ed		ld de,(chk_word) 
6320				if DEBUG_STK_FAULT 
6320					DMARK "FA3" 
6320					CALLMONITOR 
6320				endif 
6320 cd 22 0d			call cmp16 
6323 ca 2c 63			jp z, .chk_fault5 
6326 11 cd 63			ld de, sfaultdo 
6329 c3 2f 63			jp .chk_fault 
632c			 
632c			 
632c			.chk_fault5:  
632c d1				pop de 
632d e1				pop hl 
632e			 
632e c9				ret 
632f			 
632f cd d0 0a		.chk_fault: 	call clear_display 
6332 3e 28				ld a, display_row_2 
6334 cd e3 0a				call str_at_display 
6337 11 5d 63				   ld de, .stackfault 
633a 3e 00				ld a, display_row_1 
633c cd e3 0a				call str_at_display 
633f 11 6e fb				    ld de, debug_mark 
6342 3e 11				ld a, display_row_1+17 
6344 cd e3 0a				call str_at_display 
6347 cd f3 0a				call update_display 
634a			 
634a				; prompt before entering montior for investigating issue 
634a			 
634a 3e 78			ld a, display_row_4 
634c 11 22 1a			ld de, endprog 
634f			 
634f cd f3 0a			call update_display		 
6352			 
6352 cd 80 1c			call next_page_prompt 
6355			 
6355 d1				pop de 
6356 e1				pop hl 
6357 cd 76 1a				call monitor 
635a c3 6d 19				jp warmstart 
635d					;jp 0 
635d					;halt 
635d			 
635d			 
635d			 
635d .. 00		.stackfault: 	db "Stack fault:",0 
636a			 
636a .. 00		sfaultsu: 	db	"Stack under flow",0 
637b .. 00		sfaultso: 	db	"Stack over flow",0 
638b .. 00		sfaultru:	db "RTS underflow",0 
6399 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
63b3 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
63cd .. 00		sfaultdo:	db "DTS overflow", 0 
63da			 
63da			 
63da			fault_dsp_under: 
63da 11 ec 63			ld de, .dsp_under 
63dd c3 9c 64			jp .show_fault 
63e0			 
63e0			fault_rsp_under: 
63e0 11 fa 63			ld de, .rsp_under 
63e3 c3 9c 64			jp .show_fault 
63e6			fault_loop_under: 
63e6 11 08 64			ld de, .loop_under 
63e9 c3 9c 64			jp .show_fault 
63ec			 
63ec .. 00		.dsp_under: db "DSP Underflow",0 
63fa .. 00		.rsp_under: db "RSP Underflow",0 
6408 .. 00		.loop_under: db "LOOP Underflow",0 
6417			 
6417			 
6417 d5			type_faultn: 	push de 
6418 e5					push hl 
6419 cd d0 0a				call clear_display 
641c 11 43 64				   ld de, .typefaultn 
641f 3e 00				ld a, display_row_1 
6421 cd e3 0a				call str_at_display 
6424 11 6e fb				    ld de, debug_mark 
6427 3e 11				ld a, display_row_1+17 
6429 cd e3 0a				call str_at_display 
642c cd f3 0a				call update_display 
642f			 
642f				; prompt before entering montior for investigating issue 
642f			 
642f 3e 78			ld a, display_row_4 
6431 11 22 1a			ld de, endprog 
6434			 
6434 cd f3 0a			call update_display		 
6437			 
6437 cd 80 1c			call next_page_prompt 
643a			 
643a e5					push hl 
643b d5					push de 
643c cd 76 1a				call monitor 
643f c3 6d 19				jp warmstart 
6442 76					halt 
6443			 
6443			 
6443 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
645a			 
645a d5			type_faults: 	push de 
645b e5					push hl 
645c cd d0 0a				call clear_display 
645f 11 85 64				   ld de, .typefaults 
6462 3e 00				ld a, display_row_1 
6464 cd e3 0a				call str_at_display 
6467 11 6e fb				    ld de, debug_mark 
646a 3e 11				ld a, display_row_1+17 
646c cd e3 0a				call str_at_display 
646f cd f3 0a				call update_display 
6472			 
6472				; prompt before entering montior for investigating issue 
6472			 
6472 3e 78			ld a, display_row_4 
6474 11 22 1a			ld de, endprog 
6477			 
6477 cd f3 0a			call update_display		 
647a			 
647a cd 80 1c			call next_page_prompt 
647d			 
647d e1					pop hl 
647e d1					pop de 
647f cd 76 1a				call monitor 
6482 c3 6d 19				jp warmstart 
6485			 
6485			 
6485 .. 00		.typefaults: db "STR Type Expected TOS!",0 
649c			 
649c			.show_fault: 	 
649c d5					push de 
649d cd d0 0a				call clear_display 
64a0 d1					pop de 
64a1 3e 00				ld a, display_row_1 
64a3 cd e3 0a				call str_at_display 
64a6 11 6e fb				    ld de, debug_mark 
64a9 3e 11				ld a, display_row_1+17 
64ab cd e3 0a				call str_at_display 
64ae cd f3 0a				call update_display 
64b1			 
64b1				; prompt before entering montior for investigating issue 
64b1			 
64b1 3e 78			ld a, display_row_4 
64b3 11 22 1a			ld de, endprog 
64b6			 
64b6 cd f3 0a			call update_display		 
64b9			 
64b9 cd 80 1c			call next_page_prompt 
64bc			 
64bc e1					pop hl 
64bd d1					pop de 
64be cd 76 1a				call monitor 
64c1			; do a dump to cli and not warmstart so we preserve all of the uwords.  
64c1			; TODO Make optional fault restart to cli or warm boot? 
64c1					;jp warmstart 
64c1 c3 c8 19				jp cli 
64c4 76					halt 
64c5			 
64c5			; handle the auto run of code from files in storage 
64c5			 
64c5			 
64c5			if STORAGE_SE 
64c5			 
64c5 .. 00		sprompt3: db "Loading from start-up file?:",0 
64e2 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
64f3			 
64f3			 
64f3			forth_autoload: 
64f3			 
64f3				; load block 0 of store 1 
64f3				 
64f3 3e fe			ld a, $fe      ; bit 0 clear 
64f5 32 3f f8			ld (spi_device), a 
64f8			 
64f8 cd 93 03			call storage_get_block_0 
64fb			 
64fb 3a 7a f8			ld a, (store_page+STORE_0_AUTOFILE) 
64fe			 
64fe fe 00			cp 0 
6500 c8				ret z     ; auto start not enabled 
6501			 
6501 cd d0 0a			call clear_display 
6504			 
6504				; set bank 
6504			 
6504 3a 7c f8				ld a, (store_page+STORE_0_BANKRUN) 
6507 32 3f f8				ld (spi_device), a 
650a			 
650a				; get file id to load from and get the file name to display 
650a			 
650a 3a 7d f8				ld a, (store_page+STORE_0_FILERUN) 
650d			 
650d 2e 00				ld l, 0 
650f 67					ld h, a 
6510 11 59 f8				ld de, store_page 
6513			 
6513					if DEBUG_FORTH_WORDS 
6513						DMARK "ASp" 
6513 f5				push af  
6514 3a 28 65			ld a, (.dmark)  
6517 32 6e fb			ld (debug_mark),a  
651a 3a 29 65			ld a, (.dmark+1)  
651d 32 6f fb			ld (debug_mark+1),a  
6520 3a 2a 65			ld a, (.dmark+2)  
6523 32 70 fb			ld (debug_mark+2),a  
6526 18 03			jr .pastdmark  
6528 ..			.dmark: db "ASp"  
652b f1			.pastdmark: pop af  
652c			endm  
# End of macro DMARK
652c						CALLMONITOR 
652c cd ab 16			call break_point_state  
652f				endm  
# End of macro CALLMONITOR
652f					endif 
652f cd 3b 08				call storage_read 
6532			 
6532					if DEBUG_FORTH_WORDS 
6532						DMARK "ASr" 
6532 f5				push af  
6533 3a 47 65			ld a, (.dmark)  
6536 32 6e fb			ld (debug_mark),a  
6539 3a 48 65			ld a, (.dmark+1)  
653c 32 6f fb			ld (debug_mark+1),a  
653f 3a 49 65			ld a, (.dmark+2)  
6542 32 70 fb			ld (debug_mark+2),a  
6545 18 03			jr .pastdmark  
6547 ..			.dmark: db "ASr"  
654a f1			.pastdmark: pop af  
654b			endm  
# End of macro DMARK
654b						CALLMONITOR 
654b cd ab 16			call break_point_state  
654e				endm  
# End of macro CALLMONITOR
654e					endif 
654e			 
654e cd 2d 0d				call ishlzero 
6551 c8					ret z             ; file not found 
6552			 
6552 3e 32				ld a, display_row_2 + 10 
6554 11 5c f8				ld de, store_page+3 
6557 cd e3 0a				call str_at_display 
655a				 
655a			; 
655a			 
655a 3e 05			ld a, display_row_1+5 
655c 11 c5 64			ld de, sprompt3 
655f cd e3 0a			call str_at_display 
6562 3e 5f			ld a, display_row_3+15 
6564 11 e2 64			ld de, sprompt4 
6567 cd e3 0a			call str_at_display 
656a			 
656a cd f3 0a			call update_display 
656d			 
656d cd 54 69			call cin_wait 
6570 fe 6e			cp 'n' 
6572 c8				ret z 
6573 fe 4e			cp 'N' 
6575 c8				ret z 
6576			 
6576 cd 4d 0a			call delay1s 
6579			 
6579 3a 5b f8			ld a, (store_page+2) 
657c 32 4f f8			ld (store_openmaxext), a    ; save count of ext 
657f 3e 01			ld a, 1  
6581 32 50 f8			ld (store_openext), a    ; save count of ext 
6584			 
6584			.autof:  
6584 6f				ld l , a 
6585				 
6585 3a 59 f8			ld a, (store_page) 
6588 67				ld h, a	 
6589 11 59 f8			ld de, store_page 
658c					if DEBUG_FORTH_WORDS 
658c						DMARK "ASl" 
658c f5				push af  
658d 3a a1 65			ld a, (.dmark)  
6590 32 6e fb			ld (debug_mark),a  
6593 3a a2 65			ld a, (.dmark+1)  
6596 32 6f fb			ld (debug_mark+1),a  
6599 3a a3 65			ld a, (.dmark+2)  
659c 32 70 fb			ld (debug_mark+2),a  
659f 18 03			jr .pastdmark  
65a1 ..			.dmark: db "ASl"  
65a4 f1			.pastdmark: pop af  
65a5			endm  
# End of macro DMARK
65a5						CALLMONITOR 
65a5 cd ab 16			call break_point_state  
65a8				endm  
# End of macro CALLMONITOR
65a8					endif 
65a8 cd 3b 08				call storage_read 
65ab cd 2d 0d			call ishlzero 
65ae c8				ret z 
65af			;	jr z, .autoend 
65af			 
65af					if DEBUG_FORTH_WORDS 
65af						DMARK "ASc" 
65af f5				push af  
65b0 3a c4 65			ld a, (.dmark)  
65b3 32 6e fb			ld (debug_mark),a  
65b6 3a c5 65			ld a, (.dmark+1)  
65b9 32 6f fb			ld (debug_mark+1),a  
65bc 3a c6 65			ld a, (.dmark+2)  
65bf 32 70 fb			ld (debug_mark+2),a  
65c2 18 03			jr .pastdmark  
65c4 ..			.dmark: db "ASc"  
65c7 f1			.pastdmark: pop af  
65c8			endm  
# End of macro DMARK
65c8						CALLMONITOR 
65c8 cd ab 16			call break_point_state  
65cb				endm  
# End of macro CALLMONITOR
65cb					endif 
65cb 11 5b f8			ld de, store_page+2 
65ce 3e 78			ld a, display_row_4 
65d0 cd e3 0a			call str_at_display 
65d3			 
65d3 cd f3 0a			call update_display 
65d6 cd 41 0a			call delay250ms 
65d9			 
65d9			 
65d9			 
65d9 21 5b f8			ld hl, store_page+2 
65dc cd bf 20			call forthparse 
65df cd ff 20			call forthexec 
65e2 cd 16 20			call forthexec_cleanup 
65e5			 
65e5				 
65e5 3a 50 f8			ld a, (store_openext) 
65e8 3c				inc a 
65e9 32 50 f8			ld (store_openext), a    ; save count of ext 
65ec			 
65ec 18 96			jr .autof 
65ee			;.autofdone: 
65ee			; 
65ee			;		if DEBUG_FORTH_WORDS 
65ee			;			DMARK "ASx" 
65ee			;			CALLMONITOR 
65ee			;		endif 
65ee			;;	call clear_display 
65ee			;	ret 
65ee			 
65ee			 
65ee			 
65ee			endif 
65ee			 
65ee			 
65ee			; eof 
# End of file forth_kernel.asm
65ee			;include "nascombasic.asm" 
65ee			 
65ee			 
65ee			; find out where the code ends if loaded into RAM (for SC114) 
65ee			;endofcode:  
65ee			;	nop 
65ee			 
65ee			 
65ee			; eof 
65ee			 
# End of file main.asm
65ee			include "firmware_lcd_4x40.asm" 
65ee			; **********************************************************************  
65ee			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
65ee			; **********************************************************************  
65ee			;  
65ee			; **  Written as a Small Computer Monitor App  
65ee			; **  www.scc.me.uk  
65ee			;  
65ee			; History  
65ee			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
65ee			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
65ee			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
65ee			;  
65ee			; **********************************************************************  
65ee			;  
65ee			; This program is an example of one of the methods of interfacing an   
65ee			; alphanumeric LCD module.   
65ee			;  
65ee			; In this example the display is connected to either a Z80 PIO or a   
65ee			; simple 8-bit output port.   
65ee			;  
65ee			; This interfacing method uses 4-bit data mode and uses time delays  
65ee			; rather than polling the display's ready status. As a result the   
65ee			; interface only requires 6 simple output lines:  
65ee			;   Output bit 0 = not used  
65ee			;   Output bit 1 = not used  
65ee			;   Output bit 2 = RS         High = data, Low = instruction  
65ee			;   Output bit 3 = E          Active high  
65ee			;   Output bit 4 = DB4  
65ee			;   Output bit 5 = DB5  
65ee			;   Output bit 6 = DB6  
65ee			;   Output bit 7 = DB7  
65ee			; Display's R/W is connected to 0v so it is always in write mode  
65ee			;  
65ee			; This set up should work with any system supporting the RC2014 bus  
65ee			  
65ee			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
65ee			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
65ee			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
65ee			;  
65ee			; **********************************************************************  
65ee			  
65ee			; Additonal for 4x40. E1 and E2 instead of just E   
65ee			; TODO swipe vidout signal on port a to activate E2  
65ee			  
65ee			; **********************************************************************  
65ee			; **  Constants  
65ee			; **********************************************************************  
65ee			; LCD constants required by LCD support module  
65ee			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
65ee			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
65ee			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
65ee			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
65ee			; TODO Decide which E is being set  
65ee			kLCDWidth:  EQU display_cols             ;Width in characters  
65ee			  
65ee			; **********************************************************************  
65ee			; **  Code library usage  
65ee			; **********************************************************************  
65ee			  
65ee			; send character to current cursor position  
65ee			; wraps and/or scrolls screen automatically  
65ee			  
65ee			  
65ee			  
65ee			lcd_init:  
65ee			  
65ee			; SCMonAPI functions used  
65ee			  
65ee			; Alphanumeric LCD functions used  
65ee			; no need to specify specific functions for this module  
65ee			  
65ee 3e cf		            LD   A, 11001111b  
65f0 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
65f2 3e 00		            LD   A, 00000000b  
65f4 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
65f6			  
65f6			; Initialise alphanumeric LCD module  
65f6 3e 00				ld a, 0  
65f8 32 ce f8				ld (display_lcde1e2), a  
65fb cd 7c 66		            CALL fLCD_Init      ;Initialise LCD module  
65fe 3e 01				ld a, 1  
6600 32 ce f8				ld (display_lcde1e2), a  
6603 cd 7c 66		            CALL fLCD_Init      ;Initialise LCD module  
6606			  
6606 c9				ret  
6607			  
6607			;  
6607			;;  
6607			; lcd functions  
6607			;  
6607			;  
6607			  
6607			; what is at cursor position   
6607			  
6607			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6607			;		call curptr  
6607			;		ret  
6607			  
6607			  
6607			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6607			  
6607			curptr:  
6607 c5				push bc  
6608 21 b4 fa			ld hl, display_fb0  
660b			cpr:	  
660b				; loop for cursor whole row  
660b 0e 28			ld c, display_cols  
660d 23			cpr1:	inc hl  
660e 0d				dec c  
660f 20 fc			jr nz, cpr1  
6611 05				dec b  
6612 20 f7			jr nz, cpr  
6614			  
6614				; add col	  
6614			  
6614 23			cpr2:	inc hl  
6615 1d				dec e  
6616 20 fc			jr nz, cpr2  
6618			  
6618 c1				pop bc  
6619 c9				ret  
661a				  
661a			  
661a			  
661a			  
661a			  
661a			; write the frame buffer given in hl to hardware   
661a 22 cc f8		write_display: ld (display_write_tmp), hl 	   
661d 3e 00			ld a, kLCD_Line1  
661f cd 29 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6622 06 28			ld b, display_cols  
6624 ed 5b cc f8		ld de, (display_write_tmp)  
6628 cd 74 66			call write_len_string  
662b				  
662b				  
662b 2a cc f8			ld hl, (display_write_tmp)  
662e 11 28 00			ld de, display_cols  
6631 19				add hl,de  
6632 22 cc f8			ld (display_write_tmp),hl  
6635			  
6635				  
6635 3e 28			ld a, kLCD_Line2  
6637 cd 29 67		            CALL fLCD_Pos       ;Position cursor to location in A  
663a 06 28			ld b, display_cols  
663c ed 5b cc f8		ld de, (display_write_tmp)  
6640 cd 74 66			call write_len_string  
6643				  
6643 2a cc f8			ld hl, (display_write_tmp)  
6646 11 28 00			ld de, display_cols  
6649 19				add hl,de  
664a 22 cc f8			ld (display_write_tmp),hl  
664d			  
664d				  
664d 3e 50			ld a, kLCD_Line3  
664f cd 29 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6652 06 28			ld b, display_cols  
6654 ed 5b cc f8		ld de, (display_write_tmp)  
6658 cd 74 66			call write_len_string  
665b				  
665b 2a cc f8			ld hl, (display_write_tmp)  
665e 11 28 00			ld de, display_cols  
6661 19				add hl,de  
6662 22 cc f8			ld (display_write_tmp),hl  
6665			  
6665				  
6665 3e 78			ld a, kLCD_Line4  
6667 cd 29 67		            CALL fLCD_Pos       ;Position cursor to location in A  
666a 06 28			ld b, display_cols  
666c ed 5b cc f8		ld de, (display_write_tmp)  
6670 cd 74 66			call write_len_string  
6673 c9					ret  
6674				  
6674				; write out a fixed length string given in b from de  
6674			  
6674 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6675 cd e1 66		            CALL fLCD_Data      ;Write character to display  
6678 13				inc de  
6679 10 f9			djnz write_len_string  
667b c9				ret  
667c			  
667c			; Some other things to do  
667c			;            LD   A, kLCD_Clear ;Display clear  
667c			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
667c			;            LD   A, kLCD_Under ;Display on with underscore cursor  
667c			;            LD   A, kLCD_On     ;Display on with no cursor  
667c			;            ;LD   A, kLCD_Off   ;Display off  
667c			;            CALL fLCD_Inst      ;Send instruction to display  
667c			;  
667c			;  
667c			;            halt  
667c			;  
667c			;  
667c			;MsgHello:   DB  "Hello World!",0  
667c			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
667c			  
667c			; Custom characters 5 pixels wide by 8 pixels high  
667c			; Up to 8 custom characters can be defined  
667c			;BitMaps:      
667c			;; Character 0x00 = Battery icon  
667c			;            DB  01110b  
667c			;            DB  11011b  
667c			;            DB  10001b  
667c			;            DB  10001b  
667c			;            DB  11111b  
667c			;            DB  11111b  
667c			;            DB  11111b  
667c			;            DB  11111b  
667c			;; Character 0x01 = Bluetooth icon  
667c			;            DB  01100b  
667c			;            DB  01010b  
667c			;            DB  11100b  
667c			;            DB  01000b  
667c			;            DB  11100b  
667c			;            DB  01010b  
667c			;            DB  01100b  
667c			;            DB  00000b  
667c			;  
667c			  
667c			  
667c			; **********************************************************************  
667c			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
667c			; **********************************************************************  
667c			;  
667c			; **  Written as a Small Computer Monitor App   
667c			; **  Version 0.1 SCC 2018-05-16  
667c			; **  www.scc.me.uk  
667c			;  
667c			; **********************************************************************  
667c			;  
667c			; This module provides support for alphanumeric LCD modules using with  
667c			; *  HD44780 (or compatible) controller  
667c			; *  5 x 7 pixel fonts  
667c			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
667c			; *  Interface via six digital outputs to the display (see below)  
667c			;  
667c			; LCD module pinout:  
667c			;   1  Vss   0v supply  
667c			;   2  Vdd   5v supply  
667c			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
667c			;   4  RS    High = data, Low = instruction  
667c			;   5  R/W   High = Read, Low = Write  
667c			;   6  E     Enable signal (active high)  
667c			;   7  DB0   Data bit 0  
667c			;   8  DB1   Data bit 1  
667c			;   9  DB2   Data bit 2  
667c			;  10  DB3   Data bit 3  
667c			;  11  DB4   Data bit 4  
667c			;  12  DB5   Data bit 5  
667c			;  13  DB6   Data bit 6  
667c			;  14  DB7   Data bit 7  
667c			;  15  A     Backlight anode (+)  
667c			;  16  K     Backlight cathode (-)  
667c			;  
667c			; This interfacing method uses 4-bit data mode and uses time delays  
667c			; rather than polling the display's ready status. As a result the   
667c			; interface only requires 6 simple output lines:  
667c			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
667c			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
667c			;   LCD DB4 = Microcomputer output port bit 4  
667c			;   LCD DB5 = Microcomputer output port bit 5  
667c			;   LCD DB6 = Microcomputer output port bit 6  
667c			;   LCD DB7 = Microcomputer output port bit 7  
667c			; Display's R/W is connected to 0v so it is always in write mode  
667c			; All 6 connections must be on the same port address <kLCDPrt>  
667c			; This method also allows a decent length of cable from micro to LCD  
667c			;  
667c			; **********************************************************************  
667c			;  
667c			; To include the code for any given function provided by this module,   
667c			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
667c			; the parent source file.  
667c			; For example:  #REQUIRES   uHexPrefix  
667c			;  
667c			; Also #INCLUDE this file at some point after the #REQUIRES statements  
667c			; in the parent source file.  
667c			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
667c			;  
667c			; These are the function names provided by this module:  
667c			; fLCD_Init                     ;Initialise LCD  
667c			; fLCD_Inst                     ;Send instruction to LCD  
667c			; fLCD_Data                     ;Send data byte to LCD  
667c			; fLCD_Pos                      ;Position cursor  
667c			; fLCD_Str                      ;Display string  
667c			; fLCD_Def                      ;Define custom character  
667c			;  
667c			; **********************************************************************  
667c			;  
667c			; Requires SCMonAPI.asm to also be included in the project  
667c			;  
667c			  
667c			  
667c			; **********************************************************************  
667c			; **  Constants  
667c			; **********************************************************************  
667c			  
667c			; Constants that must be defined externally  
667c			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
667c			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
667c			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
667c			;kLCDWidth: EQU 20             ;Width in characters  
667c			  
667c			; general line offsets in any frame buffer  
667c			  
667c			  
667c			display_row_1: equ 0  
667c			display_row_2: equ display_row_1+display_cols  
667c			display_row_3: equ display_row_2 + display_cols  
667c			display_row_4: equ display_row_3 + display_cols  
667c			;display_row_4_eol:   
667c			  
667c			  
667c			; Cursor position values for the start of each line  
667c			  
667c			; E  
667c			kLCD_Line1: EQU 0x00   
667c			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
667c			; E1  
667c			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
667c			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
667c			  
667c			; Instructions to send as A register to fLCD_Inst  
667c			kLCD_Clear: EQU 00000001b     ;LCD clear  
667c			kLCD_Off:   EQU 00001000b     ;LCD off  
667c			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
667c			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
667c			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
667c			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
667c			  
667c			; Constants used by this code module  
667c			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
667c			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
667c			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
667c			  
667c			  
667c			  
667c			; **********************************************************************  
667c			; **  LCD support functions  
667c			; **********************************************************************  
667c			  
667c			; Initialise alphanumeric LCD module  
667c			; LCD control register codes:  
667c			;   DL   0 = 4-bit mode        1 = 8-bit mode  
667c			;   N    0 = 1-line mode       1 = 2-line mode  
667c			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
667c			;   D    0 = Display off       1 = Display on  
667c			;   C    0 = Cursor off        1 = Cursor on  
667c			;   B    0 = Blinking off      1 = Blinking on  
667c			;   ID   0 = Decrement mode    1 = Increment mode  
667c			;   SH   0 = Entire shift off  1 = Entire shift on  
667c 3e 28		fLCD_Init:  LD   A, 40  
667e cd a3 67		            CALL LCDDelay       ;Delay 40ms after power up  
6681			; For reliable reset set 8-bit mode - 3 times  
6681 cd 73 67		            CALL WrFn8bit       ;Function = 8-bit mode  
6684 cd 73 67		            CALL WrFn8bit       ;Function = 8-bit mode  
6687 cd 73 67		            CALL WrFn8bit       ;Function = 8-bit mode  
668a			; Set 4-bit mode  
668a cd 6f 67		            CALL WrFn4bit       ;Function = 4-bit mode  
668d cd a1 67		            CALL LCDDelay1      ;Delay 37 us or more  
6690			; Function set  
6690 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6692 cd a5 66		            CALL fLCD_Inst      ;2 line, display on  
6695			; Display On/Off control  
6695 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6697 cd a5 66		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
669a			; Display Clear  
669a 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
669c cd a5 66		            CALL fLCD_Inst      ;Clear display  
669f			; Entry mode  
669f 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
66a1 cd a5 66		            CALL fLCD_Inst      ;Increment mode, shift off  
66a4			; Display module now initialised  
66a4 c9			            RET  
66a5			; ok to here  
66a5			  
66a5			; Write instruction to LCD  
66a5			;   On entry: A = Instruction byte to be written  
66a5			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66a5 f5			fLCD_Inst:  PUSH AF  
66a6 f5			            PUSH AF  
66a7 cd b9 66		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
66aa f1			            POP  AF  
66ab 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
66ac 17			            RLA  
66ad 17			            RLA  
66ae 17			            RLA  
66af cd b9 66		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
66b2 3e 02		            LD   A, 2  
66b4 cd a3 67		            CALL LCDDelay       ;Delay 2 ms to complete   
66b7 f1			            POP  AF  
66b8 c9			            RET  
66b9			Wr4bits:   
66b9 f5					push af  
66ba 3a ce f8				ld a, (display_lcde1e2)  
66bd fe 00				cp 0     ; e  
66bf 20 10				jr nz, .wea2	  
66c1 f1					pop af  
66c2 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
66c4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66c6 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
66c8 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
66ca d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66cc cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
66ce d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66d0 c9			            RET  
66d1 f1			.wea2:		pop af  
66d2 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
66d4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66d6 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
66d8 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
66da d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
66dc cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
66de d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
66e0 c9			            RET  
66e1			  
66e1			  
66e1			; Write data to LCD  
66e1			;   On entry: A = Data byte to be written  
66e1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
66e1 f5			fLCD_Data:  PUSH AF  
66e2 f5			            PUSH AF  
66e3 cd f5 66		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
66e6 f1			            POP  AF  
66e7 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
66e8 17			            RLA  
66e9 17			            RLA  
66ea 17			            RLA  
66eb cd f5 66		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
66ee 3e 96		            LD   A, 150  
66f0 3d			Wait:      DEC  A              ;Wait a while to allow data   
66f1 20 fd		            JR   NZ, Wait      ;  write to complete  
66f3 f1			            POP  AF  
66f4 c9			            RET  
66f5			Wr4bitsa:     
66f5 f5					push af  
66f6 3a ce f8				ld a, (display_lcde1e2)  
66f9 fe 00				cp 0     ; e1  
66fb 20 16				jr nz, .we2	  
66fd f1					pop af  
66fe e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6700 cb d7		            SET  kLCDBitRS, A  
6702 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6704 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
6706 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
6708 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
670a cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
670c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
670e cb 97		            RES  kLCDBitRS, A  
6710 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6712 c9			            RET  
6713 f1			.we2:		pop af  
6714 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6716 cb d7		            SET  kLCDBitRS, A  
6718 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
671a cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
671c cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
671e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6720 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
6722 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6724 cb 97		            RES  kLCDBitRS, A  
6726 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6728 c9			            RET  
6729			  
6729			  
6729			; Position cursor to specified location  
6729			;   On entry: A = Cursor position  
6729			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6729 f5			fLCD_Pos:   PUSH AF  
672a					; at this point set the E1 or E2 flag depending on position  
672a			  
672a c5					push bc  
672b			;		push af  
672b 06 00				ld b, 0  
672d 4f					ld c, a  
672e 3e 4f				ld a, kLCD_Line3-1  
6730 b7			 		or a      ;clear carry flag  
6731 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
6732 38 04				jr c, .pe1  
6734			  
6734					; E selection  
6734 cb 80				res 0, b         ; bit 0 unset e  
6736			;		pop af    ; before line 3 so recover orig pos  
6736			;		ld c, a    ; save for poking back  
6736 18 06				jr .peset	          
6738			.pe1:          	; E2 selection  
6738 cb c0				set 0, b         ; bit 0 set e1  
673a 79					ld a, c  
673b de 4f				sbc a, kLCD_Line3-1  
673d 4f					ld c, a	         ; save caculated offset  
673e			;		pop af     ; bin this original value now we have calculated form  
673e			  
673e			.peset:		; set bit  
673e 78					ld a, b  
673f 32 ce f8				ld (display_lcde1e2), a 	  
6742 79					ld a, c  
6743 c1					pop bc  
6744			  
6744 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6746 cd a5 66		            CALL fLCD_Inst      ;Write instruction to LCD  
6749 f1			            POP  AF  
674a c9			            RET  
674b			  
674b			  
674b			; Output text string to LCD  
674b			;   On entry: DE = Pointer to null terminated text string  
674b			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
674b 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
674c b7			            OR   A              ;Null terminator?  
674d c8			            RET  Z              ;Yes, so finished  
674e cd e1 66		            CALL fLCD_Data      ;Write character to display  
6751 13			            INC  DE             ;Point to next character  
6752 18 f7		            JR   fLCD_Str       ;Repeat  
6754 c9					ret  
6755			  
6755			; Define custom character  
6755			;   On entry: A = Character number (0 to 7)  
6755			;             DE = Pointer to character bitmap data  
6755			;   On exit:  A = Next character number  
6755			;             DE = Next location following bitmap  
6755			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6755			; Character is   
6755 c5			fLCD_Def:   PUSH BC  
6756 f5			            PUSH AF  
6757 07			            RLCA                ;Calculate location  
6758 07			            RLCA                ;  for bitmap data  
6759 07			            RLCA                ;  = 8 x CharacterNumber  
675a f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
675c cd a5 66		            CALL fLCD_Inst      ;Write instruction to LCD  
675f 06 00		            LD   B, 0  
6761 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6762 cd e1 66		            CALL fLCD_Data      ;Write byte to display  
6765 13			            INC  DE             ;Point to next byte  
6766 04			            INC  B              ;Count bytes  
6767 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6769 28 f6		            JR   Z, Loop       ;No, so repeat  
676b f1			            POP  AF  
676c 3c			            INC  A              ;Increment character number  
676d c1			            POP  BC  
676e c9			            RET  
676f			  
676f			  
676f			; **********************************************************************  
676f			; **  Private functions  
676f			; **********************************************************************  
676f			  
676f			; Write function to LCD  
676f			;   On entry: A = Function byte to be written  
676f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
676f 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6771 18 02		            JR   WrFunc  
6773 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6775 f5			WrFunc:     PUSH AF  
6776 f5					push af  
6777 3a ce f8				ld a, (display_lcde1e2)  
677a fe 00				cp 0     ; e1  
677c 20 0f				jr nz, .wfea2	  
677e f1					pop af  
677f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6781 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6783 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6785 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6787 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6789 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
678b 18 0d			jr .wfskip  
678d f1			.wfea2:		pop af  
678e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6790 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6792 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6794 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6796 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6798 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
679a 3e 05		.wfskip:            LD  A, 5  
679c cd a3 67		            CALL LCDDelay       ;Delay 5 ms to complete  
679f f1			            POP  AF  
67a0 c9			            RET  
67a1			  
67a1			  
67a1			; Delay in milliseconds  
67a1			;   On entry: A = Number of milliseconds delay  
67a1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
67a1 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
67a3 d5			LCDDelay:   PUSH DE  
67a4 5f			            LD   E, A           ;Delay by 'A' ms  
67a5 16 00		            LD   D, 0  
67a7 cd 32 0a		            CALL aDelayInMS  
67aa d1			            POP  DE  
67ab c9			            RET  
67ac			  
67ac			  
67ac			testlcd:  
67ac 3e 00			ld a, kLCD_Line1  
67ae cd 29 67			call fLCD_Pos  
67b1 06 28			ld b, 40  
67b3 11 e1 67			ld de, .ttext1  
67b6 cd 74 66			call write_len_string  
67b9			  
67b9 3e 28			ld a, kLCD_Line2  
67bb cd 29 67			call fLCD_Pos  
67be 06 28			ld b, 40  
67c0 11 0a 68			ld de, .ttext2  
67c3 cd 74 66			call write_len_string  
67c6 3e 50			ld a, kLCD_Line3  
67c8 cd 29 67			call fLCD_Pos  
67cb 06 28			ld b, 40  
67cd 11 33 68			ld de, .ttext3  
67d0 cd 74 66			call write_len_string  
67d3 3e 78			ld a, kLCD_Line4  
67d5 cd 29 67			call fLCD_Pos  
67d8 06 28			ld b, 40  
67da 11 5c 68			ld de, .ttext4  
67dd cd 74 66			call write_len_string  
67e0			  
67e0 76				halt  
67e1			  
67e1			  
67e1 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
680a .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
6833 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
685c .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6885			   
6885			  
6885			  
6885			; eof  
6885			  
# End of file firmware_lcd_4x40.asm
6885			;include "firmware_lcd_4x20.asm" 
6885			include "firmware_key_5x10.asm" 
6885			; 5 x 10 decade counter scanner  
6885			  
6885			  
6885			; TODO do cursor shape change for shift keys  
6885			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6885			  
6885			  
6885			; bit mask for each scan column and row for teing the matrix  
6885			  
6885			  
6885			key_init:  
6885			  
6885			; SCMonAPI functions used  
6885			  
6885			; Alphanumeric LCD functions used  
6885			; no need to specify specific functions for this module  
6885			  
6885			  
6885 3e cf		            LD   A, 11001111b  
6887 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6889			;            LD   A, 00000000b  
6889 3e 1f		            LD   A, 00011111b  
688b d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
688d			  
688d			  
688d				; TODO Configure cursor shapes  
688d			  
688d				; Load cursor shapes   
688d 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
688f 11 9f 68		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6892 06 02		            LD   B, 2           ;Number of characters to define  
6894 cd 55 67		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6897 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6899			  
6899 3e 01				ld a, 1  
689b 32 c7 f8			ld (cursor_shape),a  
689e c9				ret  
689f			  
689f			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
689f			; Up to 8 custom characters can be defined  
689f			.cursor_shapes:      
689f			;; Character 0x00 = Normal  
689f 1f			            DB  11111b  
68a0 1f			            DB  11111b  
68a1 1f			            DB  11111b  
68a2 1f			            DB  11111b  
68a3 1f			            DB  11111b  
68a4 1f			            DB  11111b  
68a5 1f			            DB  11111b  
68a6 1f			            DB  11111b  
68a7			;; Character 0x01 = Modifier  
68a7 1f			            DB  11111b  
68a8 1b			            DB  11011b  
68a9 1b			            DB  11011b  
68aa 1b			            DB  11011b  
68ab 1b			            DB  11011b  
68ac 1f			            DB  11111b  
68ad 1b			            DB  11011b  
68ae 1f			            DB  11111b  
68af			  
68af			  
68af			  
68af			  
68af			; Display custom character 0  
68af			;            LD   A, kLCD_Line1+14  
68af			;            CALL fLCD_Pos       ;Position cursor to location in A  
68af			;            LD   A, 0  
68af			;            CALL fLCD_Data      ;Write character in A at cursor  
68af			  
68af			; Display custom character 1  
68af			;            LD   A, kLCD_Line2+14  
68af			;            CALL fLCD_Pos      ;Position cursor to location in A  
68af			;            LD   A, 1  
68af			;            CALL fLCD_Data     ;Write character in A at cursor  
68af			  
68af			; keyboard scanning   
68af			  
68af			; character in from keyboard  
68af			  
68af			; mapping for the pcb layout  
68af			  
68af			.matrix_to_char:  
68af .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
68ba .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
68c5 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
68d0 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
68db .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
68e6			.matrix_to_shift:  
68e6			  
68e6 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
68f1 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
68fc 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6907 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
6912 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
691d			  
691d			.matrix_to_symbolshift:  
691d			  
691d fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6928 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
6933 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
693e			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
693e 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
6949 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6954			  
6954			  
6954			  
6954			; mapping for a simple straight through breadboard layout  
6954			  
6954			;.matrix_to_char:  
6954			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6954			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6954			;		db "asdfghjkl",KEY_CR,0  
6954			;		db "qwertyuiop",0  
6954			;		 db "1234567890",0  
6954			;.matrix_to_shift:  
6954			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6954			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6954			;		db "ASDFGHJKL",KEY_CR,0  
6954			;		db "QWERTYUIOP",0  
6954			;		 db "!",'"',"#$%^&*()",0  
6954			;.matrix_to_symbolshift:  
6954			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6954			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6954			;		db "_?*fghjk=",KEY_CR,0  
6954			;		db "-/+*[]{}@#",0  
6954			;		 db "1234567890",0  
6954			  
6954			;.matrix_to_char: db "D#0*C987B654A321"  
6954			  
6954			  
6954				  
6954			  
6954			; add cin and cin_wait  
6954			  
6954 cd 65 69		cin_wait: 	call cin  
6957						if DEBUG_KEYCINWAIT  
6957							push af  
6957							  
6957							ld hl,key_repeat_ct  
6957							ld (hl),a  
6957							inc hl  
6957							call hexout  
6957							ld hl,key_repeat_ct+3  
6957							ld a,0  
6957							ld (hl),a  
6957			  
6957							    LD   A, kLCD_Line1+11  
6957							    CALL fLCD_Pos       ;Position cursor to location in A  
6957							    LD   DE, key_repeat_ct  
6957							    ;LD   DE, MsgHello  
6957							    CALL fLCD_Str       ;Display string pointed to by DE  
6957			  
6957			  
6957			  
6957							pop af  
6957						endif  
6957 fe 00			cp 0  
6959 28 f9			jr z, cin_wait   ; block until key press  
695b			  
695b							if DEBUG_KEYCINWAIT  
695b								push af  
695b			  
695b								ld a, 'A'	  
695b								ld hl,key_repeat_ct  
695b								ld (hl),a  
695b								inc hl  
695b								ld a,0  
695b								ld (hl),a  
695b			  
695b								    LD   A, kLCD_Line2+11  
695b								    CALL fLCD_Pos       ;Position cursor to location in A  
695b								    LD   DE, key_repeat_ct  
695b								    ;LD   DE, MsgHello  
695b								    CALL fLCD_Str       ;Display string pointed to by DE  
695b			  
695b							call delay500ms  
695b			  
695b								pop af  
695b							endif  
695b f5				push af   ; save key pressed  
695c			  
695c			.cin_wait1:	  
695c							if DEBUG_KEYCINWAIT  
695c								push af  
695c			  
695c								ld a, 'b'	  
695c								ld hl,key_repeat_ct  
695c								ld (hl),a  
695c								inc hl  
695c								ld a,0  
695c								ld (hl),a  
695c			  
695c								    LD   A, kLCD_Line2+11  
695c								    CALL fLCD_Pos       ;Position cursor to location in A  
695c								    LD   DE, key_repeat_ct  
695c								    ;LD   DE, MsgHello  
695c								    CALL fLCD_Str       ;Display string pointed to by DE  
695c			  
695c			  
695c							call delay500ms  
695c			  
695c								pop af  
695c							endif  
695c			  
695c cd 65 69		call cin  
695f fe 00			cp 0  
6961 20 f9			jr nz, .cin_wait1  	; wait for key release  
6963			if DEBUG_KEYCINWAIT  
6963				push af  
6963			  
6963				ld a, '3'	  
6963				ld hl,key_repeat_ct  
6963				ld (hl),a  
6963				inc hl  
6963				ld a,0  
6963				ld (hl),a  
6963			  
6963			            LD   A, kLCD_Line2+11  
6963			            CALL fLCD_Pos       ;Position cursor to location in A  
6963			            LD   DE, key_repeat_ct  
6963			            ;LD   DE, MsgHello  
6963			            CALL fLCD_Str       ;Display string pointed to by DE  
6963			  
6963			  
6963			call delay500ms  
6963			  
6963				pop af  
6963			endif  
6963			  
6963 f1				pop af   ; get key  
6964 c9				ret  
6965			  
6965			  
6965 cd 79 69		cin: 	call .mtoc  
6968			  
6968			if DEBUG_KEYCIN  
6968				push af  
6968				  
6968				ld hl,key_repeat_ct  
6968				ld (hl),a  
6968				inc hl  
6968				call hexout  
6968				ld hl,key_repeat_ct+3  
6968				ld a,0  
6968				ld (hl),a  
6968			  
6968			            LD   A, kLCD_Line3+15  
6968			            CALL fLCD_Pos       ;Position cursor to location in A  
6968			            LD   DE, key_repeat_ct  
6968			            ;LD   DE, MsgHello  
6968			            CALL fLCD_Str       ;Display string pointed to by DE  
6968			  
6968			  
6968			call delay500ms  
6968			  
6968				pop af  
6968			endif  
6968			  
6968			  
6968				; no key held  
6968 fe 00			cp 0  
696a c8				ret z  
696b			  
696b			if DEBUG_KEYCIN  
696b				push af  
696b			  
696b				ld a, '1'	  
696b				ld hl,key_repeat_ct  
696b				ld (hl),a  
696b				inc hl  
696b				ld a,0  
696b				ld (hl),a  
696b			  
696b			            LD   A, kLCD_Line4+15  
696b			            CALL fLCD_Pos       ;Position cursor to location in A  
696b			            LD   DE, key_repeat_ct  
696b			            ;LD   DE, MsgHello  
696b			            CALL fLCD_Str       ;Display string pointed to by DE  
696b			  
696b			  
696b			call delay500ms  
696b			  
696b				pop af  
696b			endif  
696b			  
696b				; stop key bounce  
696b			  
696b 32 88 fb			ld (key_held),a		 ; save it  
696e 47				ld b, a  
696f			  
696f c5			.cina1:	push bc  
6970			if DEBUG_KEYCIN  
6970				push af  
6970			  
6970				ld hl,key_repeat_ct  
6970				inc hl  
6970				call hexout  
6970				ld hl,key_repeat_ct+3  
6970				ld a,0  
6970				ld (hl),a  
6970				ld hl,key_repeat_ct  
6970				ld a, '2'	  
6970				ld (hl),a  
6970			  
6970			            LD   A, kLCD_Line4+15  
6970			            CALL fLCD_Pos       ;Position cursor to location in A  
6970			            LD   DE, key_repeat_ct  
6970			            ;LD   DE, MsgHello  
6970			            CALL fLCD_Str       ;Display string pointed to by DE  
6970			  
6970				pop af  
6970			endif  
6970 cd 79 69			call .mtoc  
6973 c1				pop bc  
6974 b8				cp b  
6975 28 f8			jr z, .cina1  
6977 78				ld a,b		  
6978			if DEBUG_KEYCIN  
6978				push af  
6978			  
6978				ld hl,key_repeat_ct  
6978				inc hl  
6978				call hexout  
6978				ld hl,key_repeat_ct+3  
6978				ld a,0  
6978				ld (hl),a  
6978				ld hl,key_repeat_ct  
6978				ld a, '3'	  
6978				ld (hl),a  
6978			  
6978			            LD   A, kLCD_Line4+15  
6978			            CALL fLCD_Pos       ;Position cursor to location in A  
6978			            LD   DE, key_repeat_ct  
6978			            ;LD   DE, MsgHello  
6978			            CALL fLCD_Str       ;Display string pointed to by DE  
6978			  
6978				pop af  
6978			endif  
6978 c9				ret  
6979			  
6979			; detect keyboard modifier key press and apply new overlay to the face key held  
6979			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6979			  
6979			;.cin_map_modifier:   
6979			;	ld a, (hl)  
6979			;	and 255  
6979			;	ret NZ		; modifier key not flagged  
6979			;  
6979			;	; get key face  
6979			;  
6979			;	ld b,(key_face_held)  
6979			;  
6979			;	ld b, key_cols * key_rows  
6979			;  
6979			;	push de  
6979			;	pop hl  
6979			;  
6979			;.mmod1: ld a,(hl)   ; get map test  
6979			;	cp b  
6979			;	jr z, .mmod2  
6979			;  
6979			;  
6979			;  
6979			;.mmod2: inc hl    ;   
6979			;  
6979			;	  
6979			;  
6979			;	  
6979			;  
6979			;	ld hl,key_actual_pressed  
6979			;	ld (hl),a,  
6979			;	ret  
6979			  
6979			; map matrix key held to char on face of key  
6979			  
6979			.mtoc:  
6979			  
6979			; test decade counter strobes  
6979			  
6979			;.decadetest1:  
6979			  
6979			; reset counter  
6979			;ld a, 128  
6979			;out (portbdata),a  
6979			  
6979			  
6979			;ld b, 5  
6979			;.dec1:  
6979			;ld a, 0  
6979			;out (portbdata),a  
6979			;call delay1s  
6979			  
6979			;ld a, 32  
6979			;out (portbdata),a  
6979			;call delay1s  
6979			;call delay1s  
6979			;call delay1s  
6979			;  
6979			;ld a, 64+32  
6979			;out (portbdata),a  
6979			;call delay1s  
6979			;;djnz .dec1  
6979			;  
6979			;jp .decadetest1  
6979			  
6979			  
6979			  
6979			  
6979			  
6979			  
6979			  
6979			  
6979			  
6979			  
6979				; scan keyboard matrix and generate raw scan map  
6979 cd 0c 6a			call matrix  
697c			  
697c				; reuse c bit 0 left modifer button - ie shift  
697c			        ; reuse c bit 1 for right modifer button - ie symbol shift  
697c				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
697c			  
697c 0e 00			ld c, 0  
697e			  
697e				; TODO set flags for modifer key presses   
697e				; TODO do a search for modifer key...  
697e			  
697e				;ld hl,keyscan_table_row4  
697e 21 e7 fb			ld hl,keyscan_table_row2  
6981			  
6981 7e				ld a, (hl)  
6982 fe 23			cp '#'  
6984 20 07			jr nz, .nextmodcheck  
6986 cb c1			set 0, c  
6988 21 e6 68			ld hl, .matrix_to_shift  
698b 18 21			jr .dokeymap  
698d				; TODO for now igonre  
698d			.nextmodcheck:  
698d 21 dc fb			ld hl,keyscan_table_row3  
6990			  
6990 7e				ld a, (hl)  
6991 fe 23			cp '#'  
6993 20 07			jr nz, .nextmodcheck2  
6995 cb c9			set 1, c   
6997 21 1d 69			ld hl, .matrix_to_symbolshift  
699a 18 12			jr .dokeymap  
699c			.nextmodcheck2:  
699c 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
699f			  
699f 7e				ld a, (hl)  
69a0 fe 23			cp '#'  
69a2 20 07			jr nz, .donemodcheck  
69a4 cb c9			set 1, c   
69a6 21 e6 68			ld hl, .matrix_to_shift  
69a9 18 03			jr .dokeymap  
69ab			  
69ab				; no modifer found so just map to normal keys  
69ab				; get mtoc map matrix to respective keys  
69ab			;	ld hl, .matrix_to_char  
69ab			;	ld hl, .matrix_to_char  
69ab			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
69ab			;	ld a, KEY_SHIFT  
69ab			;	call findchar  
69ab			;  
69ab			;	; got offset to key modifer in b  
69ab			;  
69ab			;	ld hl,keyscan_table_row5  
69ab			;  
69ab			;	ld a,b  
69ab			;	call addatohl  
69ab			;	ld a,(hl)  
69ab			;  
69ab			;	cp '#'  
69ab			;	jr nz, .nextmodcheck  
69ab			;	set 0, c  
69ab			;	ld hl, .matrix_to_char  
69ab			;	jr .dokeymap  
69ab			;	; TODO for now igonre  
69ab			;.nextmodcheck:  
69ab			;	ld hl, .matrix_to_symbolshift  
69ab			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
69ab			;	ld a, KEY_SYMBOLSHIFT  
69ab			;	call findchar  
69ab			;  
69ab			;  
69ab			;	; got offset to key modifer in b  
69ab			;  
69ab			;	ld hl,keyscan_table_row5  
69ab			;  
69ab			;	ld a,b  
69ab			;	call addatohl  
69ab			;	ld a,(hl)  
69ab			;  
69ab			;	cp '#'  
69ab			;	jr nz, .donemodcheck  
69ab			;	set 1, c   
69ab			;	ld hl, .matrix_to_symbolshift  
69ab			;	jr .dokeymap  
69ab			  
69ab			  
69ab			  
69ab			.donemodcheck:  
69ab				; no modifer found so just map to normal keys  
69ab				; get mtoc map matrix to respective keys  
69ab 21 af 68			ld hl, .matrix_to_char  
69ae			  
69ae			.dokeymap:  
69ae				;ld (key_fa), c   
69ae cd c7 69			call .mapkeys  
69b1			  
69b1			  
69b1			if DEBUG_KEY  
69b1			  
69b1			; Display text on first line  
69b1			            LD   A, kLCD_Line1  
69b1			            CALL fLCD_Pos       ;Position cursor to location in A  
69b1			            LD   DE, keyscan_table_row1  
69b1			            ;LD   DE, MsgHello  
69b1			            CALL fLCD_Str       ;Display string pointed to by DE  
69b1			  
69b1			; Display text on second line  
69b1			            LD   A, kLCD_Line2  
69b1			            CALL fLCD_Pos       ;Position cursor to location in A  
69b1			            LD   DE, keyscan_table_row2  
69b1			            CALL fLCD_Str       ;Display string pointed to by DE  
69b1			            LD   A, kLCD_Line3  
69b1			            CALL fLCD_Pos       ;Position cursor to location in A  
69b1			            LD   DE, keyscan_table_row3  
69b1			            CALL fLCD_Str       ;Display string pointed to by DE  
69b1			            LD   A, kLCD_Line4  
69b1			            CALL fLCD_Pos       ;Position cursor to location in A  
69b1			            LD   DE, keyscan_table_row4  
69b1			            CALL fLCD_Str       ;Display string pointed to by DE  
69b1			            LD   A, kLCD_Line1+10  
69b1			            CALL fLCD_Pos       ;Position cursor to location in A  
69b1			            LD   DE, keyscan_table_row5  
69b1			            CALL fLCD_Str       ;Display string pointed to by DE  
69b1			  
69b1				;call delay250ms  
69b1			endif  
69b1			;	jp testkey  
69b1			  
69b1			; get first char reported  
69b1			  
69b1 21 c6 fb			ld hl,keyscan_table_row5  
69b4			  
69b4				;ld b, 46   ; 30 keys to remap + 8 nulls   
69b4 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
69b6			.findkey:  
69b6 7e				ld a,(hl)  
69b7 fe 00			cp 0  
69b9 28 04			jr z, .nextkey  
69bb fe 7e			cp KEY_MATRIX_NO_PRESS  
69bd 20 06			jr nz, .foundkey  
69bf			.nextkey:  
69bf 23				inc hl  
69c0 10 f4			djnz .findkey  
69c2 3e 00			ld a,0  
69c4 c9				ret  
69c5			.foundkey:  
69c5 7e				ld a,(hl)  
69c6 c9				ret  
69c7				  
69c7			  
69c7			; convert the raw key map given hl for destination key  
69c7			.mapkeys:  
69c7 11 c6 fb			ld de,keyscan_table_row5  
69ca			  
69ca 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
69cc			.remap:  
69cc 1a				ld a,(de)  
69cd fe 23			cp '#'  
69cf 20 02			jr nz, .remapnext  
69d1				;CALLMONITOR  
69d1 7e				ld a,(hl)  
69d2 12				ld (de),a  
69d3			  
69d3			  
69d3			  
69d3			.remapnext:  
69d3 23				inc hl  
69d4 13				inc de  
69d5 10 f5			djnz .remap  
69d7				  
69d7 c9				ret  
69d8			  
69d8			  
69d8			  
69d8			.mtocold2:  
69d8			  
69d8			;	; flag if key D is held down and remove from reporting  
69d8			;	ld bc, .key_map_fd    
69d8			;	ld hl, keyscan_table  
69d8			;	ld de, key_fd  
69d8			;	call .key_shift_hold  
69d8			;	cp 255  
69d8			;	jr z, .cinmap  
69d8			;	; flag if key C is held down and remove from reporting  
69d8			;	ld bc, .key_map_fc    
69d8			;	ld hl, keyscan_table+key_cols  
69d8			;	ld de, key_fc  
69d8			;	call .key_shift_hold  
69d8			;	cp 255  
69d8			;	jr z, .cinmap  
69d8			;	; flag if key B is held down and remove from reporting  
69d8			;	ld bc, .key_map_fb    
69d8			;	ld hl, keyscan_table+(key_cols*2)  
69d8			;	ld de, key_fb  
69d8			;	call .key_shift_hold  
69d8			;	cp 255  
69d8			;	jr z, .cinmap  
69d8			;	; flag if key A is held down and remove from reporting  
69d8			;	ld bc, .key_map_fa    
69d8			;	ld hl, keyscan_table+(key_cols*3)  
69d8			;	ld de, key_fa  
69d8			;	call .key_shift_hold  
69d8			;	cp 255  
69d8			;	jr z, .cinmap  
69d8			  
69d8 11 af 68			ld de, .matrix_to_char  
69db			  
69db			  
69db			.cinmap1:   
69db				if DEBUG_KEY  
69db			            LD   A, kLCD_Line4  
69db			            CALL fLCD_Pos       ;Position cursor to location in A  
69db					push de  
69db			            LD   DE, keyscan_table  
69db			            CALL fLCD_Str       ;Display string pointed to by DE  
69db					pop de  
69db				endif  
69db			  
69db				; scan key matrix table for any held key  
69db			  
69db				; de holds either the default matrix or one selected above  
69db			  
69db 21 93 fb			ld hl, keyscan_table  
69de 06 32			ld b,key_cols*key_rows  
69e0			  
69e0 7e			.cin11:	ld a,(hl)  
69e1 fe 23			cp '#'  
69e3 28 08			jr z, .cinhit1  
69e5 23				inc hl  
69e6 13				inc de  
69e7 05				dec b  
69e8 20 f6			jr nz, .cin11  
69ea				; no key found held  
69ea 3e 00			ld a,0  
69ec c9				ret  
69ed d5			.cinhit1: push de  
69ee e1				pop hl  
69ef 7e				ld a,(hl)  
69f0 c9				ret  
69f1			  
69f1			; flag a control key is held   
69f1			; hl is key pin, de is flag indicator  
69f1			  
69f1			.key_shift_hold1:  
69f1 c5				push bc  
69f2 3e 01			ld a, 1  
69f4 32 c7 f8			ld (cursor_shape),a  
69f7 06 00			ld b, 0  
69f9 7e				ld a, (hl)  
69fa fe 2e			cp '.'  
69fc 28 0a			jr z, .key_shift11  
69fe 06 ff			ld b, 255  
6a00 3e 2b			ld a, '+'    ; hide key from later scans  
6a02 77				ld (hl),a  
6a03 3e 02			ld a, 2  
6a05 32 c7 f8			ld (cursor_shape),a  
6a08			.key_shift11:  
6a08				; write flag indicator  
6a08 78				ld a,b  
6a09 12				ld (de),a  
6a0a			  
6a0a d1				pop de    ; de now holds the key map ptr  
6a0b c9				ret  
6a0c			  
6a0c				  
6a0c			  
6a0c			; scans keyboard matrix and flags key press in memory array	  
6a0c				  
6a0c			matrix:  
6a0c				;call matrix  
6a0c				; TODO optimise the code....  
6a0c			  
6a0c			  
6a0c			;ld hl, keyscan_table_row1  
6a0c			;ld de, keyscan_table_row1+1  
6a0c			;ld bc,46  
6a0c			;ld a,KEY_MATRIX_NO_PRESS  
6a0c			;ldir  
6a0c			  
6a0c			  
6a0c			  
6a0c			; reset counter  
6a0c 3e 80		ld a, 128  
6a0e d3 c1		out (portbdata),a  
6a10			  
6a10 06 0a		ld b, 10  
6a12 0e 00		ld c, 0       ; current clock toggle  
6a14			  
6a14			.colscan:  
6a14			  
6a14			; set current column  
6a14			; disable clock enable and set clock low  
6a14			  
6a14			;ld a, 0  
6a14			;out (portbdata),a  
6a14			  
6a14			; For each column scan for switches  
6a14			  
6a14 c5			push bc  
6a15 21 89 fb		ld hl, keyscan_scancol  
6a18 cd 21 6b		call .rowscan  
6a1b c1			pop bc  
6a1c			  
6a1c			  
6a1c			; get back current column  
6a1c			  
6a1c			; translate the row scan  
6a1c			  
6a1c			;   
6a1c			; row 1  
6a1c			  
6a1c 78			ld a,b  
6a1d			  
6a1d 21 fc fb		LD   hl, keyscan_table_row1+10  
6a20			  
6a20 cd 16 0d		call subafromhl  
6a23			;call addatohl  
6a23			  
6a23 11 89 fb		ld de, keyscan_scancol  
6a26			  
6a26 1a			ld a,(de)  
6a27 77			ld (hl),a  
6a28			  
6a28			  
6a28			  
6a28			  
6a28			; row 2  
6a28			  
6a28 78			ld a,b  
6a29			  
6a29 21 f1 fb		LD   hl, keyscan_table_row2+10  
6a2c			  
6a2c			;call addatohl  
6a2c cd 16 0d		call subafromhl  
6a2f			  
6a2f			  
6a2f 11 8a fb		ld de, keyscan_scancol+1  
6a32			  
6a32 1a			ld a,(de)  
6a33 77			ld (hl),a  
6a34			  
6a34			  
6a34			; row 3  
6a34			  
6a34 78			ld a,b  
6a35			  
6a35 21 e6 fb		LD   hl, keyscan_table_row3+10  
6a38			  
6a38			;call addatohl  
6a38 cd 16 0d		call subafromhl  
6a3b			  
6a3b 11 8b fb		ld de, keyscan_scancol+2  
6a3e			  
6a3e 1a			ld a,(de)  
6a3f 77			ld (hl),a  
6a40			  
6a40			  
6a40			  
6a40			; row 4  
6a40			  
6a40 78			ld a,b  
6a41			  
6a41 21 db fb		LD   hl, keyscan_table_row4+10  
6a44			  
6a44			;call addatohl  
6a44 cd 16 0d		call subafromhl  
6a47			  
6a47 11 8c fb		ld de, keyscan_scancol+3  
6a4a			  
6a4a 1a			ld a,(de)  
6a4b 77			ld (hl),a  
6a4c			  
6a4c			; row 5  
6a4c			  
6a4c 78			ld a,b  
6a4d			  
6a4d 21 d0 fb		LD   hl, keyscan_table_row5+10  
6a50			  
6a50			;call addatohl  
6a50 cd 16 0d		call subafromhl  
6a53			  
6a53 11 8d fb		ld de, keyscan_scancol+4  
6a56			  
6a56 1a			ld a,(de)  
6a57 77			ld (hl),a  
6a58			  
6a58			; handshake next column  
6a58			  
6a58			  
6a58 3e 40		ld a, 64  
6a5a d3 c1		out (portbdata),a  
6a5c			  
6a5c 3e 00		ld a, 0  
6a5e d3 c1		out (portbdata),a  
6a60			  
6a60			; toggle clk and move to next column  
6a60			;ld a, 64  
6a60			;cp c  
6a60			;  
6a60			;jr z, .coltoglow  
6a60			;ld c, a  
6a60			;jr .coltog  
6a60			;.coltoglow:  
6a60			;ld c, 0  
6a60			;.coltog:  
6a60			;ld a, c  
6a60			;out (portbdata),a  
6a60			  
6a60 10 b2		djnz .colscan  
6a62			  
6a62 3e 0a		ld a,10  
6a64 21 f2 fb		LD   hl, keyscan_table_row1  
6a67 cd 04 0d		call addatohl  
6a6a 3e 00		ld a, 0  
6a6c 77			ld (hl), a  
6a6d			  
6a6d			  
6a6d 3e 0a		ld a,10  
6a6f 21 e7 fb		LD   hl, keyscan_table_row2  
6a72 cd 04 0d		call addatohl  
6a75 3e 00		ld a, 0  
6a77 77			ld (hl), a  
6a78			  
6a78 3e 0a		ld a,10  
6a7a 21 dc fb		LD   hl, keyscan_table_row3  
6a7d cd 04 0d		call addatohl  
6a80 3e 00		ld a, 0  
6a82 77			ld (hl), a  
6a83			  
6a83 3e 0a		ld a,10  
6a85 21 d1 fb		LD   hl, keyscan_table_row4  
6a88 cd 04 0d		call addatohl  
6a8b 3e 00		ld a, 0  
6a8d 77			ld (hl), a  
6a8e			  
6a8e 3e 0a		ld a,10  
6a90 21 c6 fb		LD   hl, keyscan_table_row5  
6a93 cd 04 0d		call addatohl  
6a96 3e 00		ld a, 0  
6a98 77			ld (hl), a  
6a99			  
6a99			if DEBUG_KEY_MATRIX  
6a99			  
6a99			; Display text on first line  
6a99			            LD   A, kLCD_Line1  
6a99			            CALL fLCD_Pos       ;Position cursor to location in A  
6a99			            LD   DE, keyscan_table_row1  
6a99			            ;LD   DE, MsgHello  
6a99			            CALL fLCD_Str       ;Display string pointed to by DE  
6a99			  
6a99			; Display text on second line  
6a99			            LD   A, kLCD_Line2  
6a99			            CALL fLCD_Pos       ;Position cursor to location in A  
6a99			            LD   DE, keyscan_table_row2  
6a99			            CALL fLCD_Str       ;Display string pointed to by DE  
6a99			            LD   A, kLCD_Line3  
6a99			            CALL fLCD_Pos       ;Position cursor to location in A  
6a99			            LD   DE, keyscan_table_row3  
6a99			            CALL fLCD_Str       ;Display string pointed to by DE  
6a99			            LD   A, kLCD_Line4  
6a99			            CALL fLCD_Pos       ;Position cursor to location in A  
6a99			            LD   DE, keyscan_table_row4  
6a99			            CALL fLCD_Str       ;Display string pointed to by DE  
6a99			            LD   A, kLCD_Line4+10  
6a99			            CALL fLCD_Pos       ;Position cursor to location in A  
6a99			            LD   DE, keyscan_table_row5  
6a99			            CALL fLCD_Str       ;Display string pointed to by DE  
6a99			  
6a99			;call delay250ms  
6a99				jp matrix  
6a99			endif  
6a99 c9			ret  
6a9a			  
6a9a			; using decade counter....  
6a9a			  
6a9a			  
6a9a			; TODO reset decade counter to start of scan  
6a9a			  
6a9a			; reset 15  
6a9a			; clock 14  
6a9a			; ce 13  
6a9a			  
6a9a			; 1 - q5  
6a9a			; 2 - q1  
6a9a			; 3 - q0  
6a9a			; 4 - q2  
6a9a			; 5 - q6  
6a9a			; 6 - q7  
6a9a			; 7 - q3  
6a9a			; 8 - vss  
6a9a			; 9 - q8  
6a9a			; 10 - q4  
6a9a			; 11 - q9  
6a9a			; 12 - cout  
6a9a			; 16 - vdd  
6a9a			  
6a9a			; clock      ce       reset     output  
6a9a			; 0          x        0         n  
6a9a			; x          1        0         n  
6a9a			; x          x        1         q0  
6a9a			; rising     0        0         n+1  
6a9a			; falling    x        0         n  
6a9a			; x          rising   0         n  
6a9a			; 1          falling  0         x+1  
6a9a			;  
6a9a			; x = dont care, if n < 5 carry = 1 otherwise 0  
6a9a			  
6a9a			;   
6a9a			; reset   
6a9a			; 13=0, 14=0, 15=1 .. 15=0  
6a9a			;  
6a9a			; handshake line  
6a9a			; 14=1.... read line 14=0  
6a9a			  
6a9a			  
6a9a			  
6a9a			  
6a9a			  
6a9a			; TODO hand shake clock for next column scan  
6a9a			; TODO detect each row  
6a9a			  
6a9a			  
6a9a			  
6a9a			  
6a9a			; reset 128  
6a9a			; clock 64  
6a9a			; ce 32  
6a9a			  
6a9a			  
6a9a			.cyclestart:  
6a9a			  
6a9a			; reset counter  
6a9a 3e 80		ld a, 128  
6a9c d3 c1		out (portbdata),a  
6a9e			  
6a9e			; loop leds  
6a9e 06 0a		ld b,10  
6aa0			  
6aa0			.cycle1:  
6aa0 c5			push bc  
6aa1 3e 00		ld a, 0  
6aa3 d3 c1		out (portbdata),a  
6aa5 cd 41 0a		call delay250ms  
6aa8			  
6aa8 3e 40		ld a, 64  
6aaa d3 c1		out (portbdata),a  
6aac cd 41 0a		call delay250ms  
6aaf			  
6aaf 3e 00		ld a, 0  
6ab1 d3 c1		out (portbdata),a  
6ab3 cd 41 0a		call delay250ms  
6ab6			  
6ab6 c1			pop bc  
6ab7 10 e7		djnz .cycle1  
6ab9			  
6ab9			  
6ab9 18 df		jr .cyclestart  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			; map matrix key held to char on face of key  
6abb			  
6abb			;.mtocold:  
6abb			;  
6abb			;  
6abb			;; reset counter  
6abb			;ld a, 128  
6abb			;out (portbdata),a  
6abb			;  
6abb			;  
6abb			;; scan keyboard row 1  
6abb			;ld a, 0  
6abb			;out (portbdata),a  
6abb			;;ld a, 64  
6abb			;;out (portbdata),a  
6abb			;  
6abb			;  
6abb			;	ld a, 128  
6abb			;	ld hl, keyscan_table  
6abb			;	call .rowscan  
6abb			;  
6abb			;;ld a, 0  
6abb			;;out (portbdata),a  
6abb			;ld a, 64  
6abb			;out (portbdata),a  
6abb			;  
6abb			;	ld a, 64  
6abb			;	ld hl, keyscan_table+key_cols  
6abb			;	call .rowscan  
6abb			;  
6abb			;ld a, 0  
6abb			;out (portbdata),a  
6abb			;;ld a, 64  
6abb			;;out (portbdata),a  
6abb			;	ld a, 32  
6abb			;	ld hl, keyscan_table+(key_cols*2)  
6abb			;	call .rowscan  
6abb			;  
6abb			;  
6abb			;;ld a, 0  
6abb			;;out (portbdata),a  
6abb			;ld a, 64  
6abb			;out (portbdata),a  
6abb			;  
6abb			;	ld a, 16  
6abb			;	ld hl, keyscan_table+(key_cols*3)  
6abb			;	call .rowscan  
6abb			;  
6abb			;  
6abb			;	; flag if key D is held down and remove from reporting  
6abb			;	ld bc, .key_map_fd    
6abb			;	ld hl, keyscan_table  
6abb			;	ld de, key_fd  
6abb			;	call .key_shift_hold  
6abb			;	cp 255  
6abb			;	jr z, .cinmap  
6abb			;	; flag if key C is held down and remove from reporting  
6abb			;	ld bc, .key_map_fc    
6abb			;	ld hl, keyscan_table+key_cols  
6abb			;	ld de, key_fc  
6abb			;	call .key_shift_hold  
6abb			;	cp 255  
6abb			;	jr z, .cinmap  
6abb			;	; flag if key B is held down and remove from reporting  
6abb			;	ld bc, .key_map_fb    
6abb			;	ld hl, keyscan_table+(key_cols*2)  
6abb			;	ld de, key_fb  
6abb			;	call .key_shift_hold  
6abb			;	cp 255  
6abb			;	jr z, .cinmap  
6abb			;	; flag if key A is held down and remove from reporting  
6abb			;	ld bc, .key_map_fa    
6abb			;	ld hl, keyscan_table+(key_cols*3)  
6abb			;	ld de, key_fa  
6abb			;	call .key_shift_hold  
6abb			;	cp 255  
6abb			;	jr z, .cinmap  
6abb			;  
6abb			;	ld de, .matrix_to_char  
6abb			;  
6abb			;  
6abb			;.cinmap:   
6abb			;	if DEBUG_KEY  
6abb			;            LD   A, kLCD_Line4  
6abb			;            CALL fLCD_Pos       ;Position cursor to location in A  
6abb			;		push de  
6abb			;            LD   DE, keyscan_table  
6abb			;            CALL fLCD_Str       ;Display string pointed to by DE  
6abb			;		pop de  
6abb			;	endif  
6abb			  
6abb				; scan key matrix table for any held key  
6abb			  
6abb				; de holds either the default matrix or one selected above  
6abb			  
6abb			;	ld hl, keyscan_table  
6abb			;	ld b,key_cols*key_rows  
6abb			;  
6abb			;.cin1:	ld a,(hl)  
6abb			;	cp '#'  
6abb			;	jr z, .cinhit  
6abb			;	inc hl  
6abb			;	inc de  
6abb			;	dec b  
6abb			;	jr nz, .cin1  
6abb			;	; no key found held  
6abb			;	ld a,0  
6abb			;	ret  
6abb			;.cinhit: push de  
6abb			;	pop hl  
6abb			;	ld a,(hl)  
6abb			;	ret  
6abb			  
6abb			; flag a control key is held   
6abb			; hl is key pin, de is flag indicator  
6abb			  
6abb			;.key_shift_hold:  
6abb			;	push bc  
6abb			;	ld a, 1  
6abb			;	ld (cursor_shape),a  
6abb			;	ld b, 0  
6abb			;	ld a, (hl)  
6abb			;	cp '.'  
6abb			;	jr z, .key_shift1  
6abb			;	ld b, 255  
6abb			;	ld a, '+'    ; hide key from later scans  
6abb			;	ld (hl),a  
6abb			;	ld a, 2  
6abb			;	ld (cursor_shape),a  
6abb			;.key_shift1:  
6abb			;	; write flag indicator  
6abb			;	ld a,b  
6abb			;	ld (de),a  
6abb			;  
6abb			;	pop de    ; de now holds the key map ptr  
6abb			;	ret  
6abb			  
6abb				  
6abb				  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			;	push hl  
6abb			;	push de  
6abb			;	push bc  
6abb			;	call keyscan  
6abb			;	; map key matrix to ascii value of key face  
6abb			;  
6abb			;	ld hl, key_face_map  
6abb			;	ld de, keyscan_table  
6abb			;  
6abb			;	; get how many keys to look at  
6abb			;	ld b, keyscan_table_len  
6abb			;	  
6abb			;  
6abb			;	; at this stage fall out on first key hit  
6abb			;	; TODO handle multiple key press  
6abb			;  
6abb			;map1:	ld a,(hl)  
6abb			;	cp '#'  
6abb			;	jr z, keyhit  
6abb			;	inc hl  
6abb			;	inc de  
6abb			;	dec b  
6abb			;	jr nz, map1  
6abb			;nohit:	ld a, 0  
6abb			;	jr keydone  
6abb			;keyhit: push de  
6abb			;	pop hl  
6abb			;	ld a,(hl)  
6abb			;keydone:  
6abb			;	push bc  
6abb			;	push de  
6abb			; 	push hl  
6abb			;	ret   
6abb			;  
6abb			  
6abb			  
6abb			  
6abb			  
6abb			; scan physical key matrix  
6abb			  
6abb			  
6abb			;keyscan:  
6abb			;  
6abb			;; for each key_row use keyscanr bit mask for out  
6abb			;; then read in for keyscanc bitmask  
6abb			;; save result of row scan to keyscantable  
6abb			;  
6abb			;; scan keyboard row 1  
6abb			;  
6abb			;	ld b, key_rows  
6abb			;	ld hl, key_scanr  
6abb			;	ld de, keyscan_table  
6abb			;  
6abb			;rowloop:  
6abb			;  
6abb			;	ld a,(hl)		; out bit mask to energise keyboard row  
6abb			;	call rowscan  
6abb			;	inc hl  
6abb			;	dec b  
6abb			;	jr nz, rowloop  
6abb			;  
6abb			;	ret  
6abb			;  
6abb			;  
6abb			;; pass a out bitmask, b row number  
6abb			;arowscan:   
6abb			;	push bc  
6abb			;  
6abb			;	ld d, b  
6abb			;  
6abb			;	; calculate buffer location for this row  
6abb			;  
6abb			;	ld hl, keyscan_table	  
6abb			;kbufr:  ld e, key_cols  
6abb			;kbufc:	inc hl  
6abb			;	dec e  
6abb			;	jr nz, kbufc  
6abb			;	dec d  
6abb			;	jr nz, kbufr  
6abb			;  
6abb			;	; energise row and read columns  
6abb			;  
6abb			;	out (portbdata),a  
6abb			;	in a,(portbdata)  
6abb			;	ld c,a  
6abb			;  
6abb			;  
6abb			;	; save buffer loc  
6abb			;  
6abb			;	ld (keybufptr), hl  
6abb			;  
6abb			;	ld hl, key_scanc  
6abb			;	ld d, key_cols  
6abb			;  
6abb			;	; for each column check each bit mask  
6abb			;  
6abb			;colloop:  
6abb			;	  
6abb			;  
6abb			;	; reset flags for the row   
6abb			;  
6abb			;	ld b,'.'  
6abb			;	and (hl)  
6abb			;	jr z, maskskip  
6abb			;	ld b,'#'  
6abb			;maskskip:  
6abb			;	; save  key state  
6abb			;	push hl  
6abb			;	ld hl, (keybufptr)  
6abb			;	ld (hl), b  
6abb			;	inc hl  
6abb			;	ld (keybufptr), hl  
6abb			;  
6abb			;	; move to next bit mask  
6abb			;	pop hl  
6abb			;	inc hl  
6abb			;  
6abb			;	dec d  
6abb			;	jr nz, colloop  
6abb			;  
6abb			;	ret  
6abb			;  
6abb			;  
6abb			;;  
6abb			; lcd functions  
6abb			;  
6abb			;  
6abb			  
6abb			;if DEBUG_KEY_MATRIX  
6abb			  
6abb			; test function to display hardware view of matrix state  
6abb			  
6abb			matrixold:  
6abb			  
6abb			  
6abb			  
6abb			; reset counter  
6abb 3e 80		ld a, 128  
6abd d3 c1		out (portbdata),a  
6abf			; scan keyboard row 1  
6abf 3e 00		ld a, 0  
6ac1 d3 c1		out (portbdata),a  
6ac3			;ld a, 64  
6ac3			;out (portbdata),a  
6ac3 3e 80			ld a, 128  
6ac5 21 f2 fb			ld hl, keyscan_table_row1  
6ac8 cd 21 6b			call .rowscan  
6acb			  
6acb			;ld a, 0  
6acb			;out (portbdata),a  
6acb 3e 40		ld a, 64  
6acd d3 c1		out (portbdata),a  
6acf 3e 40			ld a, 64  
6ad1 21 e7 fb			ld hl, keyscan_table_row2  
6ad4 cd 21 6b			call .rowscan  
6ad7			  
6ad7 3e 00		ld a, 0  
6ad9 d3 c1		out (portbdata),a  
6adb			;ld a, 64  
6adb			;out (portbdata),a  
6adb 3e 20			ld a, 32  
6add 21 dc fb			ld hl, keyscan_table_row3  
6ae0 cd 21 6b			call .rowscan  
6ae3			  
6ae3			;ld a, 0  
6ae3			;out (portbdata),a  
6ae3 3e 40		ld a, 64  
6ae5 d3 c1		out (portbdata),a  
6ae7 3e 10			ld a, 16  
6ae9 21 d1 fb			ld hl, keyscan_table_row4  
6aec cd 21 6b			call .rowscan  
6aef			  
6aef			; Display text on first line  
6aef 3e 00		            LD   A, kLCD_Line1  
6af1 cd 29 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6af4 11 f2 fb		            LD   DE, keyscan_table_row1  
6af7			            ;LD   DE, MsgHello  
6af7 cd 4b 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6afa			  
6afa			; Display text on second line  
6afa 3e 28		            LD   A, kLCD_Line2  
6afc cd 29 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6aff 11 e7 fb		            LD   DE, keyscan_table_row2  
6b02 cd 4b 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6b05 3e 50		            LD   A, kLCD_Line3  
6b07 cd 29 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6b0a 11 dc fb		            LD   DE, keyscan_table_row3  
6b0d cd 4b 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6b10 3e 78		            LD   A, kLCD_Line4  
6b12 cd 29 67		            CALL fLCD_Pos       ;Position cursor to location in A  
6b15 11 d1 fb		            LD   DE, keyscan_table_row4  
6b18 cd 4b 67		            CALL fLCD_Str       ;Display string pointed to by DE  
6b1b			  
6b1b cd 41 0a			call delay250ms  
6b1e c3 0c 6a			jp matrix  
6b21			  
6b21			; pass de as row display flags  
6b21			.rowscan:   
6b21			;	out (portbdata),a  
6b21 db c1			in a,(portbdata)  
6b23 4f				ld c,a  
6b24				; reset flags for the row   
6b24 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b26 e6 01			and 1  
6b28 28 02			jr z, .p1on  
6b2a 06 23			ld b,'#'  
6b2c			.p1on:  
6b2c 70				ld (hl), b  
6b2d 23				inc hl  
6b2e			  
6b2e 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b30 79				ld a,c  
6b31 e6 02			and 2  
6b33			;	bit 0,a  
6b33 28 02			jr z, .p2on  
6b35 06 23			ld b,'#'  
6b37			.p2on:  
6b37 70				ld (hl), b  
6b38 23				inc hl  
6b39			;  
6b39 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b3b 79				ld a,c  
6b3c e6 04			and 4  
6b3e			;;	bit 0,a  
6b3e 28 02			jr z, .p3on  
6b40 06 23			ld b,'#'  
6b42			.p3on:  
6b42 70				ld (hl), b  
6b43 23				inc hl  
6b44			;;  
6b44 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b46			;;	bit 0,a  
6b46 79				ld a,c  
6b47 e6 08			and 8  
6b49 28 02			jr z, .p4on  
6b4b 06 23			ld b,'#'  
6b4d			.p4on:  
6b4d 70				ld (hl), b  
6b4e 23				inc hl  
6b4f			  
6b4f 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6b51			;;	bit 0,a  
6b51 79				ld a,c  
6b52 e6 10			and 16  
6b54 28 02			jr z, .p5on  
6b56 06 23			ld b,'#'  
6b58			.p5on:  
6b58 70				ld (hl), b  
6b59 23				inc hl  
6b5a			; zero term  
6b5a 06 00			ld b,0  
6b5c 70				ld (hl), b  
6b5d			  
6b5d c9			.rscandone: ret  
6b5e			  
6b5e			;addatohl:  
6b5e			;  
6b5e			 ;add   a, l    ; A = A+L  
6b5e			  ;  ld    l, a    ; L = A+L  
6b5e			   ; adc   a, h    ; A = A+L+H+carry  
6b5e			   ; sub   l       ; A = H+carry  
6b5e			   ; ld    h, a    ; H = H+carry  
6b5e			  
6b5e			;ret  
6b5e			; eof  
# End of file firmware_key_5x10.asm
6b5e			;include "firmware_key_4x10.asm" 
6b5e			 
6b5e			heap_size:    equ heap_end - heap_start 
6b5e			;eof 
# End of file os_mega.asm
6b5e
