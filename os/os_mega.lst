# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 34 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-09-05 22:22' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 d2 72			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			  
006c			debug_umark: equ debug_vector - 6  ; current user mark  
006c			debug_mark: equ debug_umark - 4    ; internal word debug points  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 45 fc				ld hl, display_fb1  
006f 22 01 fb				ld (display_fb_active), hl  
0072			  
0072 cd aa 0d				call clear_display  
0075			  
0075 21 03 fb				ld hl, display_fb2  
0078 22 01 fb				ld (display_fb_active), hl  
007b			  
007b cd aa 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 e6 fc				ld hl, display_fb0  
0081 22 01 fb				ld (display_fb_active), hl  
0084			  
0084 cd aa 0d				call clear_display  
0087			  
0087			  
0087 cd df 72				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd 76 75			call key_init  
008d cd 56 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 95 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd cd 0d			call update_display  
0096 cd ed 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd af 0d			call fill_display  
009e cd cd 0d			call update_display  
00a1 cd ed 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd af 0d			call fill_display  
00a9 cd cd 0d			call update_display  
00ac cd ed 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd af 0d			call fill_display  
00b4 cd cd 0d			call update_display  
00b7 cd ed 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 24 1b			ld de, prom_bootmsg  
00bf cd bd 0d			call str_at_display  
00c2 cd cd 0d			call update_display  
00c5			  
00c5			  
00c5 cd ed 0c			call delay1s  
00c8 cd ed 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 39 1b			ld de, prom_bootmsg1  
00d0 cd bd 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd bd 0d			call str_at_display  
00db			  
00db cd cd 0d			call update_display  
00de cd ed 0c			call delay1s  
00e1 cd ed 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 a0 fd		ld (debug_mark),a  
00e9 32 a1 fd		ld (debug_mark+1),a  
00ec 32 a2 fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 a3 fd		ld (debug_mark+3),a  
00f4 32 a4 fd		ld (debug_umark),a  
00f7			  
00f7 c9					ret  
00f8			  
00f8			  
00f8			;bootmsg2:	db "Firmware v0.1",0  
00f8			  
00f8			; a 4x20 lcd  
00f8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f8			  
00f8			;if display_cols == 20  
00f8			;	include "firmware_lcd_4x20.asm"  
00f8			;endif  
00f8			  
00f8			;if display_cols == 40  
00f8			;	include "firmware_lcd_4x40.asm"  
00f8			;endif  
00f8			  
00f8			;  
00f8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f8			; TODO abstract the bit bang video out interface for dual display  
00f8			; TODO wire video out to tx pin on rc2014 bus  
00f8			  
00f8			; must supply cin, and cin_wait for low level hardware abstraction   
00f8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f8			; test scancode  
00f8			  
00f8			;;;;;  
00f8			;;;  
00f8			; Moved out to mini and maxi versions  
00f8			;  
00f8			; include "firmware_key_4x4.asm"  
00f8			; using existing 4 wire x 4 resistor array for input  
00f8			;include "firmware_key_4x10.asm"  
00f8			; need to mod the board for 5 rows due to resistor array  
00f8			;include "firmware_key_5x10.asm"  
00f8			  
00f8			; storage hardware interface  
00f8			  
00f8			; use microchip serial eeprom for storage  
00f8			  
00f8			  
00f8			if STORAGE_SE  
00f8				include "firmware_spi.asm"  
00f8			; my spi protocol (used by storage) 
00f8			 
00f8			; SPI pins 
00f8			 
00f8			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f8			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f8			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f8			 
00f8			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f8			; chip pin 4 gnd 
00f8			 
00f8			 
00f8			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f8			SPI_CE1: equ 1      ;    port a1 pin 14  
00f8			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f8			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f8			SPI_CE4: equ 4      ; port a4     pin 10 
00f8			 
00f8			; active low AND masks 
00f8			 
00f8			;SPI_CE0_MASK: equ    255-1 
00f8			;SPI_CE1_MASK: equ   255-2 
00f8			;SPI_CE2_MASK: equ   255-4 
00f8			;SPI_CE3_MASK: equ   255-8 
00f8			;SPI_CE4_MASK: equ   255-16 
00f8			SPI_CE_HIGH:  equ 255 
00f8			 
00f8			 
00f8			 
00f8			;  Perform SCLK wait pulse 
00f8			 
00f8			spi_clk: 
00f8 f5				push af 
00f9 3a 99 f9			ld a, (spi_clktime) 
00fc fe 00			cp 0 
00fe 28 03			jr z, .scskip 
0100 cd d2 0c			call aDelayInMS 
0103			.scskip: 
0103 f1				pop af 
0104 c9				ret 
0105			 
0105			 
0105			 
0105			; TODO store port id for spi device ie dev c 
0105			; TODO store pin for SO 
0105			; TODO store pin for SI 
0105			; TODO store pin for SCLK 
0105			 
0105			; 
0105			 
0105			; ensure that spi bus is in a stable state with default pins  
0105			 
0105			se_stable_spi:   
0105			 
0105				 ; set DI high, CE high , SCLK low 
0105				;ld a, SPI_DI | SPI_CE0 
0105 3e 07			ld a, SPI_DI  
0107 cd 11 02			call spi_ce_high 
010a d3 80			 out (storage_adata),a 
010c 32 96 f9			ld (spi_portbyte),a 
010f			 
010f				if DEBUG_SPI 
010f					push hl 
010f					ld l, a 
010f					DMARK "SPI" 
010f					CALLMONITOR 
010f					pop hl 
010f				endif 
010f c9				ret 
0110			 
0110			; byte to send in a 
0110			 
0110			spi_send_byte: 
0110				; save byte to send for bit mask shift out 
0110 4f			        ld c,a 
0111 3a 96 f9			ld a,(spi_portbyte) 
0114				  
0114				; clock out	each bit of the byte msb first 
0114			 
0114 06 08			ld b, 8 
0116			.ssb1: 
0116				; clear so bit  
0116 cb bf			res SPI_DI, a 
0118 cb 11			rl c 
011a				; if bit 7 is set then carry is set 
011a 30 02			jr nc, .ssb2 
011c cb ff			set SPI_DI,a 
011e			.ssb2:  ; output bit to ensure it is stable 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126 cd f8 00			call spi_clk 
0129				; then low 
0129 cb af			res SPI_SCLK,a 
012b d3 80			out (storage_adata),a 
012d 00				nop 
012e cd f8 00			call spi_clk 
0131 10 e3			djnz .ssb1 
0133			 
0133 32 96 f9			ld (spi_portbyte),a 
0136 c9				ret 
0137			 
0137			; TODO low level get byte into A on spi 
0137			 
0137			spi_read_byte:  
0137			 
0137				; save byte to send for bit mask shift out 
0137 0e 00		    ld c,0 
0139 3a 96 f9			ld a,(spi_portbyte) 
013c				  
013c				; clock out	each bit of the byte msb first 
013c			 
013c			 
013c				; clock bit high 
013c cb ef			set SPI_SCLK,a 
013e d3 80			out (storage_adata),a 
0140 00				nop 
0141 cd f8 00			call spi_clk 
0144			 
0144			    ; read DO  
0144			 
0144 cb f9		    set 7,c 
0146 db 80			in a,(storage_adata) 
0148 cb 77		    bit SPI_DO,a 
014a 20 02		    jr nz, .b7 
014c cb b9		    res 7,c 
014e			.b7: 
014e				; then low 
014e cb af			res SPI_SCLK,a 
0150 d3 80			out (storage_adata),a 
0152 00				nop 
0153 cd f8 00			call spi_clk 
0156			     
0156			 
0156				; clock bit high 
0156 cb ef			set SPI_SCLK,a 
0158 d3 80			out (storage_adata),a 
015a 00				nop 
015b cd f8 00			call spi_clk 
015e			 
015e			    ; read DO  
015e			 
015e cb f1		    set 6,c 
0160 db 80			in a,(storage_adata) 
0162 cb 77		    bit SPI_DO,a 
0164 20 02		    jr nz, .b6 
0166 cb b1		    res 6,c 
0168			.b6: 
0168				; then low 
0168 cb af			res SPI_SCLK,a 
016a d3 80			out (storage_adata),a 
016c 00				nop 
016d cd f8 00			call spi_clk 
0170			 
0170				; clock bit high 
0170 cb ef			set SPI_SCLK,a 
0172 d3 80			out (storage_adata),a 
0174 00				nop 
0175 cd f8 00			call spi_clk 
0178			 
0178			 
0178			    ; read DO  
0178			 
0178 cb e9		    set 5,c 
017a db 80			in a,(storage_adata) 
017c cb 77		    bit SPI_DO,a 
017e 20 02		    jr nz, .b5 
0180 cb a9		    res 5,c 
0182			.b5: 
0182				; then low 
0182 cb af			res SPI_SCLK,a 
0184 d3 80			out (storage_adata),a 
0186 00				nop 
0187 cd f8 00			call spi_clk 
018a				; clock bit high 
018a cb ef			set SPI_SCLK,a 
018c d3 80			out (storage_adata),a 
018e 00				nop 
018f cd f8 00			call spi_clk 
0192			 
0192			    ; read DO  
0192			 
0192 cb e1		    set 4,c 
0194 db 80			in a,(storage_adata) 
0196 cb 77		    bit SPI_DO,a 
0198 20 02		    jr nz, .b4 
019a cb a1		    res 4,c 
019c			.b4: 
019c				; then low 
019c cb af			res SPI_SCLK,a 
019e d3 80			out (storage_adata),a 
01a0 00				nop 
01a1 cd f8 00			call spi_clk 
01a4				; clock bit high 
01a4 cb ef			set SPI_SCLK,a 
01a6 d3 80			out (storage_adata),a 
01a8 00				nop 
01a9 cd f8 00			call spi_clk 
01ac			 
01ac			    ; read DO  
01ac			 
01ac cb d9		    set 3,c 
01ae db 80			in a,(storage_adata) 
01b0 cb 77		    bit SPI_DO,a 
01b2 20 02		    jr nz, .b3 
01b4 cb 99		    res 3,c 
01b6			.b3: 
01b6				; then low 
01b6 cb af			res SPI_SCLK,a 
01b8 d3 80			out (storage_adata),a 
01ba 00				nop 
01bb cd f8 00			call spi_clk 
01be				; clock bit high 
01be cb ef			set SPI_SCLK,a 
01c0 d3 80			out (storage_adata),a 
01c2 00				nop 
01c3 cd f8 00			call spi_clk 
01c6			 
01c6			    ; read DO  
01c6			 
01c6 cb d1		    set 2,c 
01c8 db 80			in a,(storage_adata) 
01ca cb 77		    bit SPI_DO,a 
01cc 20 02		    jr nz, .b2 
01ce cb 91		    res 2,c 
01d0			.b2: 
01d0				; then low 
01d0 cb af			res SPI_SCLK,a 
01d2 d3 80			out (storage_adata),a 
01d4 00				nop 
01d5 cd f8 00			call spi_clk 
01d8				; clock bit high 
01d8 cb ef			set SPI_SCLK,a 
01da d3 80			out (storage_adata),a 
01dc 00				nop 
01dd cd f8 00			call spi_clk 
01e0			 
01e0			    ; read DO  
01e0			 
01e0 cb c9		    set 1,c 
01e2 db 80			in a,(storage_adata) 
01e4 cb 77		    bit SPI_DO,a 
01e6 20 02		    jr nz, .b1 
01e8 cb 89		    res 1,c 
01ea			.b1: 
01ea				; then low 
01ea cb af			res SPI_SCLK,a 
01ec d3 80			out (storage_adata),a 
01ee 00				nop 
01ef cd f8 00			call spi_clk 
01f2				; clock bit high 
01f2 cb ef			set SPI_SCLK,a 
01f4 d3 80			out (storage_adata),a 
01f6 00				nop 
01f7 cd f8 00			call spi_clk 
01fa			 
01fa			    ; read DO  
01fa			 
01fa cb c1		    set 0,c 
01fc db 80			in a,(storage_adata) 
01fe cb 77		    bit SPI_DO,a 
0200 20 02		    jr nz, .b0 
0202 cb 81		    res 0,c 
0204			.b0: 
0204				; then low 
0204 cb af			res SPI_SCLK,a 
0206 d3 80			out (storage_adata),a 
0208 00				nop 
0209 cd f8 00			call spi_clk 
020c			 
020c			 
020c 32 96 f9			ld (spi_portbyte),a 
020f			 
020f			    ; return byte 
020f 79			    ld a,c 
0210			 
0210			 
0210 c9				ret 
0211			 
0211			 
0211			 
0211			spi_ce_high: 
0211			 
0211				if DEBUG_SPI_HARD_CE0 
0211			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0211					ret 
0211			 
0211				endif 
0211			 
0211			 
0211 f5				push af 
0212			 
0212				; send direct ce to port b 
0212 3e ff			ld a, 255 
0214 d3 81			out (storage_bdata), a 
0216			 
0216 f1				pop af 
0217			 
0217				; for port a that shares with spi lines AND the mask 
0217			  
0217				if DEBUG_SPI 
0217					push hl 
0217					ld h, a 
0217				endif 
0217			;	ld c, SPI_CE_HIGH 
0217			;	and c 
0217 cb c7			set SPI_CE0, a 
0219 cb cf			set SPI_CE1, a 
021b cb d7			set SPI_CE2, a 
021d cb df			set SPI_CE3, a 
021f cb e7			set SPI_CE4, a 
0221			 
0221				if DEBUG_SPI 
0221					ld l, a 
0221					DMARK "CEh" 
0221					CALLMONITOR 
0221					pop hl 
0221				endif 
0221 c9				ret 
0222			 
0222			 
0222			spi_ce_low: 
0222			 
0222				if DEBUG_SPI_HARD_CE0 
0222			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0222					ret 
0222			 
0222				endif 
0222			 
0222 c5				push bc 
0223 f5				push af 
0224			 
0224				; send direct ce to port b 
0224 3a 98 f9			ld a, (spi_cartdev) 
0227 d3 81			out (storage_bdata), a 
0229			 
0229			 
0229			 
0229				; for port a that shares with spi lines AND the mask 
0229			 
0229 3a 95 f9			ld a, (spi_device)  
022c 4f				ld c, a 
022d			 
022d f1				pop af 
022e			 
022e				; detect CEx 
022e			 
022e				if DEBUG_SPI 
022e					push hl 
022e					ld h, a 
022e				endif 
022e			 
022e cb 41			bit SPI_CE0, c 
0230 20 04			jr nz, .cel1 
0232 cb 87			res SPI_CE0, a 
0234 18 1e			jr .celn 
0236			.cel1: 
0236 cb 49			bit SPI_CE1, c 
0238 20 04			jr nz, .cel2 
023a cb 8f			res SPI_CE1, a 
023c 18 16			jr .celn 
023e			.cel2: 
023e cb 51			bit SPI_CE2, c 
0240 20 04			jr nz, .cel3 
0242 cb 97			res SPI_CE2, a 
0244 18 0e			jr .celn 
0246			.cel3: 
0246 cb 59			bit SPI_CE3, c 
0248 20 04			jr nz, .cel4 
024a cb 9f			res SPI_CE3, a 
024c 18 06			jr .celn 
024e			.cel4: 
024e cb 61			bit SPI_CE4, c 
0250 20 02			jr nz, .celn 
0252 cb a7			res SPI_CE4, a 
0254			.celn: 
0254			 
0254			 
0254			 
0254			;	add c 
0254			 
0254				if DEBUG_SPI 
0254					ld l, a 
0254					DMARK "CEl" 
0254					CALLMONITOR 
0254					pop hl 
0254				endif 
0254 c1				pop bc 
0255 c9				ret 
0256			 
0256			 
0256			 
0256			; eof 
0256			 
0256			 
0256			 
0256			 
0256			 
# End of file firmware_spi.asm
0256				include "firmware_seeprom.asm"  
0256			; 
0256			; persisent storage interface via microchip serial eeprom 
0256			 
0256			; port a pio 2 
0256			; pa 7 - si 
0256			; pa 6 - sclk  
0256			; pa 5 - so 
0256			; pa 4 - cs 
0256			; pa 3 - cs 
0256			; pa 2 - cs 
0256			; pa 1 - cs 
0256			; pa 0 - cs 
0256			; 
0256			; TODO get block 
0256			; TODO save block 
0256			; TODO load file 
0256			; TODO save file 
0256			; TODO get dir  
0256			 
0256			;  
0256			storage_adata: equ Device_C    ; device c port a - onboard storage 
0256			storage_actl: equ Device_C+2     ; device c port a 
0256			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0256			storage_bctl: equ Device_C+3     ; device c port b 
0256			 
0256			 
0256			; TODO move these to hardware driver file 
0256			 
0256			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0256			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0256			; storage bank file system format 
0256			; 
0256			; first page of bank: 
0256			; 	addr 0 - status check 
0256			;       addr 1 - write protect flag 
0256			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0256			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0256			;         TODO see if scanning whole of for available next file id is fast enough 
0256			;	addr 4 > zero term string of bank label 
0256			; 
0256			;        
0256			;  
0256			; first page of any file: 
0256			;      byte 0 - file id  
0256			;      byte 1-17 - fixed file name  
0256			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0256			; 
0256			; other pages of any file: 
0256			;      byte 0 - file id 
0256			;      byte 1> - file data 
0256			; 
0256			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0256			;  
0256			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0256			 
0256			 
0256			;storage_so_bit: 5 
0256			;storage_si_bit: 7 
0256			;storage_sclk_bit: 6 
0256			  
0256			 
0256			; init storage pio 
0256			 
0256			storage_init: 
0256			 
0256			 
0256					; set default SPI clk pulse time as disabled 
0256			 
0256 3e 00				ld a, 0 
0258 32 99 f9				ld (spi_clktime), a 
025b			 
025b					; init hardware 
025b			 
025b 3e cf		            LD   A, 11001111b 
025d d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
025f 3e 00		            LD   A, 00000000b 
0261 cb f7			set SPI_DO,a 
0263			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0263 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0265			 
0265 3e cf		            LD   A, 11001111b 
0267 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0269 3e 00		            LD   A, 00000000b 
026b d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
026d			 
026d				; set all external spi devices off  
026d 3e ff			ld a, 255 
026f 32 95 f9			ld (spi_device), a 
0272 32 98 f9			ld (spi_cartdev), a 
0275			 
0275					; ensure the spi bus is in a default stable state 
0275 cd 05 01				call se_stable_spi 
0278			 
0278			; TODO scan spi bus and gather which storage banks are present 
0278			 
0278			; populate store_bank_active  
0278			; for each ce line activate and attempt to write first byte of bank and read back 
0278			; if zero is returned then bank is empty 
0278			;   
0278			; 
0278			 
0278					; init file extent cache to save on slow reads 
0278			 
0278			;	ld hl, store_filecache 
0278			;	ld de, 0 
0278			;	ld hl,(de)	 
0278			 
0278			 
0278 c9			    ret 
0279			 
0279			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0279			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0279			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0279			 
0279			; INSTRUCTION SET 
0279			; READ 0000 0011 Read data from memory array beginning at selected address 
0279			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0279			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0279			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0279			; RDSR 0000 0101 Read STATUS register 
0279			; WRSR 0000 0001 Write STATUS register 
0279			; PE 0100 0010 Page Erase – erase one page in memory array 
0279			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0279			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0279			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0279			 
0279			; TODO send byte steam for page without setting the address for every single byte 
0279			; TODO read byte  
0279			 
0279			; byte in a 
0279			; address in hl  
0279			se_writebyte: 
0279			        
0279			    ;   ld c, a 
0279 f5			        push af 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a 96 f9		       ld a,(spi_portbyte) 
027e cd 22 02			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 96 f9		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 06		    ld a, store_wren_ins 
0288 cd 10 01		    call spi_send_byte  
028b			 
028b			    ;cs high to enable write latch 
028b			 
028b 3a 96 f9		       ld a,(spi_portbyte) 
028e cd 11 02			call spi_ce_high 
0291			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0291 d3 80		       out (storage_adata),a 
0293 32 96 f9		       ld (spi_portbyte), a 
0296			 
0296 00				nop 
0297			    ; 
0297			    ; intial write data 
0297			    ; 
0297			    ; cs low 
0297			     
0297 3a 96 f9		       ld a,(spi_portbyte) 
029a cd 22 02			call spi_ce_low 
029d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
029d d3 80		       out (storage_adata),a 
029f 32 96 f9		       ld (spi_portbyte), a 
02a2			 
02a2			    ; clock out write instruction 
02a2			     
02a2 3e 02		    ld a, store_write_ins  
02a4 cd 10 01		    call spi_send_byte  
02a7			 
02a7			    ; clock out address (depending on address size) 
02a7			     
02a7 e1			    pop hl 
02a8 7c			    ld a,h    ; address out msb first 
02a9 cd 10 01		    call spi_send_byte  
02ac 7d			    ld a,l 
02ad cd 10 01		    call spi_send_byte  
02b0			 
02b0			    ; clock out byte(s) for page 
02b0			 
02b0 f1			    pop af 
02b1 cd 10 01		    call spi_send_byte  
02b4			 
02b4			    ; end write with ce high 
02b4 3a 96 f9		       ld a,(spi_portbyte) 
02b7			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b7 cd 11 02			call spi_ce_high 
02ba d3 80		       out (storage_adata),a 
02bc 32 96 f9		       ld (spi_portbyte), a 
02bf			 
02bf				; pause for internal write cycle 
02bf 3e 0a			ld a, 10 
02c1 cd d2 0c			call aDelayInMS 
02c4 c9			    ret 
02c5			 
02c5			; buffer to write in de 
02c5			; address in hl  
02c5			se_writepage: 
02c5			        
02c5			    ;   ld c, a 
02c5 d5				push de 
02c6 e5			        push hl 
02c7			 
02c7			    ; initi write mode 
02c7			    ; 
02c7			    ;CS low 
02c7			 
02c7 3a 96 f9		       ld a,(spi_portbyte) 
02ca cd 22 02			call spi_ce_low 
02cd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cd d3 80		       out (storage_adata),a 
02cf 32 96 f9		       ld (spi_portbyte), a 
02d2			 
02d2			    ;clock out wren instruction 
02d2			 
02d2 3e 06		    ld a, store_wren_ins 
02d4 cd 10 01		    call spi_send_byte  
02d7			 
02d7			    ;cs high to enable write latch 
02d7			 
02d7 3a 96 f9		       ld a,(spi_portbyte) 
02da cd 11 02			call spi_ce_high 
02dd			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02dd d3 80		       out (storage_adata),a 
02df 32 96 f9		       ld (spi_portbyte), a 
02e2			 
02e2 00				nop 
02e3			    ; 
02e3			    ; intial write data 
02e3			    ; 
02e3			    ; cs low 
02e3			     
02e3 3a 96 f9		       ld a,(spi_portbyte) 
02e6			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02e6 cd 22 02			call spi_ce_low 
02e9 d3 80		       out (storage_adata),a 
02eb 32 96 f9		       ld (spi_portbyte), a 
02ee			 
02ee			    ; clock out write instruction 
02ee			     
02ee 3e 02		    ld a, store_write_ins  
02f0 cd 10 01		    call spi_send_byte  
02f3			 
02f3			    ; clock out address (depending on address size) 
02f3			     
02f3 e1			    pop hl 
02f4 7c			    ld a,h    ; address out msb first 
02f5 cd 10 01		    call spi_send_byte  
02f8 7d			    ld a,l 
02f9 cd 10 01		    call spi_send_byte  
02fc			 
02fc			    ; clock out byte(s) for page 
02fc			 
02fc e1				pop hl 
02fd 06 40			ld b, STORE_BLOCK_PHY 
02ff			.bytewrite: 
02ff			 
02ff 7e				ld a,(hl) 
0300 e5			    push hl 
0301 c5				push bc 
0302 cd 10 01		    call spi_send_byte  
0305 c1				pop bc 
0306 e1				pop hl 
0307			 
0307			    ; end write with ce high 
0307 3a 96 f9		       ld a,(spi_portbyte) 
030a cd 11 02			call spi_ce_high 
030d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
030d d3 80		       out (storage_adata),a 
030f 32 96 f9		       ld (spi_portbyte), a 
0312			 
0312 23				inc hl 
0313 10 ea			djnz .bytewrite 
0315			 
0315				; pause for internal write cycle 
0315 3e 64			ld a, 100 
0317 cd d2 0c			call aDelayInMS 
031a c9			    ret 
031b			; returns byte in a 
031b			; address in hl  
031b			se_readbyte: 
031b d5				push de 
031c c5				push bc 
031d			 
031d			    ;   ld c, a 
031d e5			        push hl 
031e			 
031e			    ; initi write mode 
031e			    ; 
031e			    ;CS low 
031e			 
031e 3a 96 f9		       ld a,(spi_portbyte) 
0321 cd 22 02			call spi_ce_low 
0324			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0324 d3 80		       out (storage_adata),a 
0326 32 96 f9		       ld (spi_portbyte), a 
0329			 
0329			    ;clock out wren instruction 
0329			 
0329 3e 03		    ld a, store_read_ins 
032b cd 10 01		    call spi_send_byte  
032e			 
032e			 
032e			    ; clock out address (depending on address size) 
032e			     
032e e1			    pop hl 
032f 7c			    ld a,h    ; address out msb first 
0330 cd 10 01		    call spi_send_byte  
0333 7d			    ld a,l 
0334 cd 10 01		    call spi_send_byte  
0337			 
0337			    ; clock in byte(s) for page 
0337			 
0337 cd 37 01		    call spi_read_byte  
033a f5				push af 
033b			 
033b			    ; end write with ce high 
033b 3a 96 f9		       ld a,(spi_portbyte) 
033e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
033e cd 11 02			call spi_ce_high 
0341 d3 80		       out (storage_adata),a 
0343 32 96 f9		       ld (spi_portbyte), a 
0346			 
0346 f1				pop af 
0347			 
0347 c1				pop bc 
0348 d1				pop de 
0349			 
0349 c9			    ret 
034a			 
034a			if DEBUG_STORESE 
034a			 
034a			storageput:  
034a			 
034a			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
034a			 
034a 21 f8 f0			ld hl,scratch+2 
034d cd 9d 12			call get_word_hl 
0350			 
0350				; stuff it here for the moment as it will be overwritten later anyway 
0350			 
0350 22 19 f4			ld (os_cur_ptr),hl	 
0353			 
0353			 
0353			; get pointer to start of string 
0353			 
0353 21 fd f0			ld hl, scratch+7 
0356			 
0356			; loop writing char of string to eeprom 
0356			 
0356 7e			.writestr:	ld a,(hl) 
0357 fe 00				cp 0 
0359 28 12				jr z, .wsdone		; done writing 
035b e5					push hl 
035c 2a 19 f4				ld hl,(os_cur_ptr) 
035f cd 79 02				call se_writebyte 
0362			 
0362 2a 19 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0365 23					inc hl 
0366 22 19 f4				ld (os_cur_ptr),hl 
0369			 
0369					; restore string pointer and get next char 
0369			 
0369 e1					pop hl 
036a 23					inc hl 
036b 18 e9				jr .writestr 
036d			 
036d			 
036d			 
036d			.wsdone: 
036d			 
036d			 
036d			; when done load first page into a buffer  
036d			 
036d 21 00 80				ld hl,08000h		; start in ram 
0370 22 19 f4				ld (os_cur_ptr),hl 
0373 21 00 00				ld hl, 0		 ; start of page 
0376 22 1e f1				ld (scratch+40),hl	; hang on to it 
0379			 
0379 06 80				ld b, 128		; actually get more then one page 
037b c5			.wsload:	push bc 
037c 2a 1e f1				ld hl,(scratch+40) 
037f e5					push hl 
0380 cd 1b 03				call se_readbyte 
0383			 
0383					; a now as the byte 
0383			 
0383 2a 19 f4				ld hl,(os_cur_ptr) 
0386 77					ld (hl),a 
0387					; inc next buffer area 
0387 23					inc hl 
0388 22 19 f4				ld (os_cur_ptr),hl 
038b			 
038b					; get eeprom position, inc and save for next round 
038b e1					pop hl		 
038c 23					inc hl 
038d 22 1e f1				ld (scratch+40),hl 
0390 c1					pop bc 
0391 10 e8				djnz .wsload 
0393			 
0393			; set 'd' pointer to start of buffer 
0393			 
0393 21 00 80				ld hl,08000h 
0396 22 19 f4				ld (os_cur_ptr),hl 
0399			 
0399			 
0399 c9			ret 
039a			 
039a			 
039a c9			storageread: ret 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			endif 
039b			 
039b			 
039b			 
# End of file firmware_seeprom.asm
039b			else  
039b			   ; create some stubs for the labels  
039b			se_readbyte: ret  
039b			se_writebyte: ret  
039b			storage_init: ret  
039b			  
039b			endif  
039b			  
039b			; use cf card for storage - throwing timeout errors. Hardware or software?????  
039b			;include "firmware_cf.asm"  
039b			  
039b			; load up high level storage hardward abstractions  
039b			include "firmware_storage.asm"  
039b			 
039b			; persisent storage hardware abstraction layer  
039b			 
039b			 
039b			 
039b			; Block 0 on storage is a config state 
039b			 
039b			 
039b			 
039b			; TODO add read phy block and write phy block functions 
039b			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
039b			 
039b			; Abstraction layer  
039b			 
039b			; Logocial block size is same size as physical size - using tape concept 
039b			 
039b			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
039b			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
039b			 
039b			 
039b			 
039b			; Filesystem layout (Logical layout) 
039b			; 
039b			; Block 0 - Bank config  
039b			; 
039b			;      Byte - 0 file id counter 
039b			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
039b			;      Byte - 3-20 zero terminated bank label 
039b			; 
039b			; Block 1 > File storage 
039b			; 
039b			;      Byte 0 file id    - block 0 file details 
039b			;      Byte 1 block id - block 0 is file  
039b			;            Byte 2-15 - File name 
039b			; 
039b			;       - to end of block data 
039b			; 
039b			 
039b			; Get ID for the file named in pointer held HL 
039b			; Returns ID in HL = 255 if no file found 
039b			 
039b			storage_getid: 
039b			 
039b 22 a8 f9			ld (store_tmp1), hl 
039e			 
039e				if DEBUG_STORESE 
039e					DMARK "SGI" 
039e f5				push af  
039f 3a b3 03			ld a, (.dmark)  
03a2 32 a0 fd			ld (debug_mark),a  
03a5 3a b4 03			ld a, (.dmark+1)  
03a8 32 a1 fd			ld (debug_mark+1),a  
03ab 3a b5 03			ld a, (.dmark+2)  
03ae 32 a2 fd			ld (debug_mark+2),a  
03b1 18 03			jr .pastdmark  
03b3 ..			.dmark: db "SGI"  
03b6 f1			.pastdmark: pop af  
03b7			endm  
# End of macro DMARK
03b7					CALLMONITOR 
03b7 cd aa fd			call debug_vector  
03ba				endm  
# End of macro CALLMONITOR
03ba				endif 
03ba				; get block 0 and set counter for number of files to scan 
03ba			 
03ba cd 25 05			call storage_get_block_0 
03bd			 
03bd 3a af f9			ld a, (store_page) 
03c0 47				ld b, a 
03c1			 
03c1				; get extent 0 of each file id 
03c1			 
03c1				if DEBUG_STORESE 
03c1					DMARK "SGc" 
03c1 f5				push af  
03c2 3a d6 03			ld a, (.dmark)  
03c5 32 a0 fd			ld (debug_mark),a  
03c8 3a d7 03			ld a, (.dmark+1)  
03cb 32 a1 fd			ld (debug_mark+1),a  
03ce 3a d8 03			ld a, (.dmark+2)  
03d1 32 a2 fd			ld (debug_mark+2),a  
03d4 18 03			jr .pastdmark  
03d6 ..			.dmark: db "SGc"  
03d9 f1			.pastdmark: pop af  
03da			endm  
# End of macro DMARK
03da					CALLMONITOR 
03da cd aa fd			call debug_vector  
03dd				endm  
# End of macro CALLMONITOR
03dd				endif 
03dd 60			.getloop:	ld h, b 
03de 2e 00				ld l, 0 
03e0 c5					push bc 
03e1			 
03e1 11 af f9				ld de, store_page 
03e4				if DEBUG_STORESE 
03e4					DMARK "SGr" 
03e4 f5				push af  
03e5 3a f9 03			ld a, (.dmark)  
03e8 32 a0 fd			ld (debug_mark),a  
03eb 3a fa 03			ld a, (.dmark+1)  
03ee 32 a1 fd			ld (debug_mark+1),a  
03f1 3a fb 03			ld a, (.dmark+2)  
03f4 32 a2 fd			ld (debug_mark+2),a  
03f7 18 03			jr .pastdmark  
03f9 ..			.dmark: db "SGr"  
03fc f1			.pastdmark: pop af  
03fd			endm  
# End of macro DMARK
03fd					CALLMONITOR 
03fd cd aa fd			call debug_vector  
0400				endm  
# End of macro CALLMONITOR
0400				endif 
0400 cd cd 09				call storage_read 
0403 cd 07 10				call ishlzero 
0406 28 2d				jr z, .gap 
0408					 
0408					; have a file name read. Is it one we want. 
0408			 
0408 2a a8 f9				ld hl, (store_tmp1) 
040b 11 b2 f9				ld de, store_page+3   ; file name 
040e			 
040e				if DEBUG_STORESE 
040e					DMARK "SGc" 
040e f5				push af  
040f 3a 23 04			ld a, (.dmark)  
0412 32 a0 fd			ld (debug_mark),a  
0415 3a 24 04			ld a, (.dmark+1)  
0418 32 a1 fd			ld (debug_mark+1),a  
041b 3a 25 04			ld a, (.dmark+2)  
041e 32 a2 fd			ld (debug_mark+2),a  
0421 18 03			jr .pastdmark  
0423 ..			.dmark: db "SGc"  
0426 f1			.pastdmark: pop af  
0427			endm  
# End of macro DMARK
0427					CALLMONITOR 
0427 cd aa fd			call debug_vector  
042a				endm  
# End of macro CALLMONITOR
042a				endif 
042a cd 7c 13				call strcmp 
042d 20 06				jr nz, .gap   ; not this one 
042f			 
042f c1				        pop bc 
0430			 
0430 26 00				ld h, 0 
0432 68					ld l, b 
0433 18 22				jr .getdone 
0435						 
0435			 
0435			 
0435			 
0435			.gap: 
0435				if DEBUG_STORESE 
0435					DMARK "SGg" 
0435 f5				push af  
0436 3a 4a 04			ld a, (.dmark)  
0439 32 a0 fd			ld (debug_mark),a  
043c 3a 4b 04			ld a, (.dmark+1)  
043f 32 a1 fd			ld (debug_mark+1),a  
0442 3a 4c 04			ld a, (.dmark+2)  
0445 32 a2 fd			ld (debug_mark+2),a  
0448 18 03			jr .pastdmark  
044a ..			.dmark: db "SGg"  
044d f1			.pastdmark: pop af  
044e			endm  
# End of macro DMARK
044e					CALLMONITOR 
044e cd aa fd			call debug_vector  
0451				endm  
# End of macro CALLMONITOR
0451				endif 
0451			 
0451 c1					pop bc 
0452 10 89				djnz .getloop 
0454 21 ff 00				ld hl, 255 
0457			.getdone: 
0457			 
0457				if DEBUG_STORESE 
0457					DMARK "SGe" 
0457 f5				push af  
0458 3a 6c 04			ld a, (.dmark)  
045b 32 a0 fd			ld (debug_mark),a  
045e 3a 6d 04			ld a, (.dmark+1)  
0461 32 a1 fd			ld (debug_mark+1),a  
0464 3a 6e 04			ld a, (.dmark+2)  
0467 32 a2 fd			ld (debug_mark+2),a  
046a 18 03			jr .pastdmark  
046c ..			.dmark: db "SGe"  
046f f1			.pastdmark: pop af  
0470			endm  
# End of macro DMARK
0470					CALLMONITOR 
0470 cd aa fd			call debug_vector  
0473				endm  
# End of macro CALLMONITOR
0473				endif 
0473			 
0473 c9				ret 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			; Read Block 
0474			; ---------- 
0474			; 
0474			; With current bank 
0474			;  
0474			; Get block number to read 
0474			; Load physical blocks starting at start block into buffer 
0474			 
0474			; de points to buffer to use 
0474			; hl holds logical block number  
0474			 
0474			storage_read_block: 
0474			 
0474				; TODO bank selection 
0474			 
0474				; for each of the physical blocks read it into the buffer 
0474 06 40			ld b, STORE_BLOCK_PHY 
0476			 
0476				if DEBUG_STORESE 
0476 d5					push de 
0477				endif 
0477				 
0477			.rl1:    
0477			 
0477				; read physical block at hl into de 
0477			        ; increment hl and de to next read position on exit 
0477			 
0477 e5				push hl 
0478 d5				push de	 
0479 c5				push bc 
047a			;	if DEBUG_STORESE 
047a			;		push af 
047a			;		ld a, 'R' 
047a			;		ld (debug_mark),a 
047a			;		pop af 
047a			;		CALLMONITOR 
047a			;	endif 
047a cd 1b 03			call se_readbyte 
047d			;	if DEBUG_STORESE 
047d			;		ld a,(spi_portbyte) 
047d			;		ld l, a 
047d			;		push af 
047d			;		ld a, '1' 
047d			;		ld (debug_mark),a 
047d			;		pop af 
047d			;		CALLMONITOR 
047d			;	endif 
047d c1				pop bc 
047e d1				pop de 
047f e1				pop hl 
0480 12				ld (de),a 
0481 23				inc hl 
0482 13				inc de 
0483			 
0483			;	if DEBUG_STORESE 
0483			;		push af 
0483			;		ld a, 'r' 
0483			;		ld (debug_mark),a 
0483			;		pop af 
0483			;		CALLMONITOR 
0483			;	endif 
0483			 
0483 10 f2			djnz .rl1 
0485			 
0485				if DEBUG_STORESE 
0485					DMARK "SRB" 
0485 f5				push af  
0486 3a 9a 04			ld a, (.dmark)  
0489 32 a0 fd			ld (debug_mark),a  
048c 3a 9b 04			ld a, (.dmark+1)  
048f 32 a1 fd			ld (debug_mark+1),a  
0492 3a 9c 04			ld a, (.dmark+2)  
0495 32 a2 fd			ld (debug_mark+2),a  
0498 18 03			jr .pastdmark  
049a ..			.dmark: db "SRB"  
049d f1			.pastdmark: pop af  
049e			endm  
# End of macro DMARK
049e d1					pop de 
049f			; 
049f			;		push af 
049f			;		ld a, 'R' 
049f			;		ld (debug_mark),a 
049f			;		pop af 
049f					CALLMONITOR 
049f cd aa fd			call debug_vector  
04a2				endm  
# End of macro CALLMONITOR
04a2				endif 
04a2 c9				ret	 
04a3				 
04a3			 
04a3			; File Size 
04a3			; --------- 
04a3			; 
04a3			;   hl file id 
04a3			; 
04a3			;  returns in hl the number of blocks 
04a3			 
04a3			storage_file_size: 
04a3 5d				ld e, l 
04a4 16 00			ld d, 0 
04a6 21 40 00			ld hl, STORE_BLOCK_PHY 
04a9					if DEBUG_FORTH_WORDS 
04a9						DMARK "SIZ" 
04a9 f5				push af  
04aa 3a be 04			ld a, (.dmark)  
04ad 32 a0 fd			ld (debug_mark),a  
04b0 3a bf 04			ld a, (.dmark+1)  
04b3 32 a1 fd			ld (debug_mark+1),a  
04b6 3a c0 04			ld a, (.dmark+2)  
04b9 32 a2 fd			ld (debug_mark+2),a  
04bc 18 03			jr .pastdmark  
04be ..			.dmark: db "SIZ"  
04c1 f1			.pastdmark: pop af  
04c2			endm  
# End of macro DMARK
04c2						CALLMONITOR 
04c2 cd aa fd			call debug_vector  
04c5				endm  
# End of macro CALLMONITOR
04c5					endif 
04c5 cd a7 07			call storage_findnextid 
04c8			 
04c8 cd 07 10			call ishlzero 
04cb			;	ld a, l 
04cb			;	add h 
04cb			;	cp 0 
04cb c8				ret z			; block not found so EOF 
04cc			 
04cc 11 af f9			ld de, store_page 
04cf cd 74 04			call storage_read_block 
04d2			 
04d2 3a b1 f9			ld a, (store_page+2)	 ; get extent count 
04d5 6f				ld l, a 
04d6 26 00			ld h, 0 
04d8 c9			 	ret 
04d9			 
04d9			 
04d9			; Write Block 
04d9			; ----------- 
04d9			; 
04d9			; With current bank 
04d9			;  
04d9			; Get block number to write 
04d9			; Write physical blocks starting at start block from buffer 
04d9			  
04d9			storage_write_block: 
04d9				; TODO bank selection 
04d9			 
04d9				; for each of the physical blocks read it into the buffer 
04d9 06 40			ld b, STORE_BLOCK_PHY 
04db			 
04db				if DEBUG_STORESE 
04db					DMARK "SWB" 
04db f5				push af  
04dc 3a f0 04			ld a, (.dmark)  
04df 32 a0 fd			ld (debug_mark),a  
04e2 3a f1 04			ld a, (.dmark+1)  
04e5 32 a1 fd			ld (debug_mark+1),a  
04e8 3a f2 04			ld a, (.dmark+2)  
04eb 32 a2 fd			ld (debug_mark+2),a  
04ee 18 03			jr .pastdmark  
04f0 ..			.dmark: db "SWB"  
04f3 f1			.pastdmark: pop af  
04f4			endm  
# End of macro DMARK
04f4			 
04f4					;push af 
04f4					;ld a, 'W' 
04f4					;ld (debug_mark),a 
04f4					;pop af 
04f4					CALLMONITOR 
04f4 cd aa fd			call debug_vector  
04f7				endm  
# End of macro CALLMONITOR
04f7				endif 
04f7			 
04f7			; might not be working 
04f7			;	call se_writepage 
04f7			 
04f7			;	ret 
04f7			; 
04f7			 
04f7			 
04f7			 
04f7			.wl1:    
04f7			 
04f7				; read physical block at hl into de 
04f7			        ; increment hl and de to next read position on exit 
04f7			 
04f7 e5				push hl 
04f8 d5				push de	 
04f9 c5				push bc 
04fa 1a				ld a,(de) 
04fb				;if DEBUG_STORESE 
04fb			;		push af 
04fb			;		ld a, 'W' 
04fb			;		ld (debug_mark),a 
04fb			;		pop af 
04fb			;		CALLMONITOR 
04fb			;	endif 
04fb cd 79 02			call se_writebyte 
04fe			;	call delay250ms 
04fe 00				nop 
04ff 00				nop 
0500 00				nop 
0501			;	if DEBUG_STORESE 
0501			;		push af 
0501			;		ld a, 'w' 
0501			;		ld (debug_mark),a 
0501			;		pop af 
0501			;		CALLMONITOR 
0501			;	endif 
0501 c1				pop bc 
0502 d1				pop de 
0503 e1				pop hl 
0504 23				inc hl 
0505 13				inc de 
0506			 
0506			 
0506 10 ef			djnz .wl1 
0508			 
0508				if DEBUG_STORESE 
0508					DMARK "SW2" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 a0 fd			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 a1 fd			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 a2 fd			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "SW2"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521			 
0521					;push af 
0521					;ld a, 'W' 
0521					;ld (debug_mark),a 
0521					;pop af 
0521					CALLMONITOR 
0521 cd aa fd			call debug_vector  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 c9				ret	 
0525			 
0525			; Init bank 
0525			; --------- 
0525			; 
0525			; With current bank 
0525			; 
0525			; Setup block 0 config 
0525			;     Set 0 file id counter 
0525			;     Set formatted byte pattern 
0525			;     Zero out bank label 
0525			;      
0525			; For every logical block write 0-1 byte as null 
0525			 
0525			storage_get_block_0: 
0525			 
0525				; TODO check presence 
0525			 
0525				; get block 0 config 
0525			 
0525 21 00 00			ld hl, 0 
0528 11 af f9			ld de, store_page 
052b cd 74 04			call storage_read_block 
052e			 
052e				if DEBUG_STORESE 
052e					DMARK "SB0" 
052e f5				push af  
052f 3a 43 05			ld a, (.dmark)  
0532 32 a0 fd			ld (debug_mark),a  
0535 3a 44 05			ld a, (.dmark+1)  
0538 32 a1 fd			ld (debug_mark+1),a  
053b 3a 45 05			ld a, (.dmark+2)  
053e 32 a2 fd			ld (debug_mark+2),a  
0541 18 03			jr .pastdmark  
0543 ..			.dmark: db "SB0"  
0546 f1			.pastdmark: pop af  
0547			endm  
# End of macro DMARK
0547 11 af f9				ld de, store_page 
054a			;		push af 
054a			;		ld a, 'i' 
054a			;		ld (debug_mark),a 
054a			;		pop af 
054a					CALLMONITOR 
054a cd aa fd			call debug_vector  
054d				endm  
# End of macro CALLMONITOR
054d				endif 
054d			 
054d				; is this area formatted? 
054d			 
054d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
054d 2a b0 f9			ld hl, (store_page+1) 
0550 3e 80			ld a,0x80 
0552 bd				cp l 
0553 20 22			jr nz, .ininotformatted 
0555				; do a double check 
0555 3e 27			ld a, 0x27 
0557 bc				cp h 
0558 20 1d			jr nz, .ininotformatted 
055a			 
055a				; formatted then 
055a			 
055a				if DEBUG_STORESE 
055a					DMARK "SB1" 
055a f5				push af  
055b 3a 6f 05			ld a, (.dmark)  
055e 32 a0 fd			ld (debug_mark),a  
0561 3a 70 05			ld a, (.dmark+1)  
0564 32 a1 fd			ld (debug_mark+1),a  
0567 3a 71 05			ld a, (.dmark+2)  
056a 32 a2 fd			ld (debug_mark+2),a  
056d 18 03			jr .pastdmark  
056f ..			.dmark: db "SB1"  
0572 f1			.pastdmark: pop af  
0573			endm  
# End of macro DMARK
0573					;push af 
0573					;ld a, 'I' 
0573					;ld (debug_mark),a 
0573					;pop af 
0573					CALLMONITOR 
0573 cd aa fd			call debug_vector  
0576				endm  
# End of macro CALLMONITOR
0576				endif 
0576 c9				ret 
0577			 
0577			.ininotformatted: 
0577				; bank not formatted so poke various bits to make sure 
0577			 
0577				if DEBUG_STORESE 
0577					DMARK "SB2" 
0577 f5				push af  
0578 3a 8c 05			ld a, (.dmark)  
057b 32 a0 fd			ld (debug_mark),a  
057e 3a 8d 05			ld a, (.dmark+1)  
0581 32 a1 fd			ld (debug_mark+1),a  
0584 3a 8e 05			ld a, (.dmark+2)  
0587 32 a2 fd			ld (debug_mark+2),a  
058a 18 03			jr .pastdmark  
058c ..			.dmark: db "SB2"  
058f f1			.pastdmark: pop af  
0590			endm  
# End of macro DMARK
0590					;push af 
0590					;ld a, 'f' 
0590					;ld (debug_mark),a 
0590					;pop af 
0590					CALLMONITOR 
0590 cd aa fd			call debug_vector  
0593				endm  
# End of macro CALLMONITOR
0593				endif 
0593			 
0593 cd b0 0c			call storage_clear_page 
0596			 
0596 21 af f9			ld hl, store_page 
0599 3e 00			ld a, 0 
059b				 
059b 77				ld (hl),a   ; reset file counter 
059c			 
059c 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
059f 22 b0 f9		 	ld (store_page+1), hl	 
05a2			 
05a2				; set default label 
05a2			 
05a2 21 3e 06			ld hl, .defaultbanklabl 
05a5 11 b2 f9		 	ld de, store_page+3 
05a8 01 0f 00			ld bc, 15 
05ab ed b0			ldir 
05ad			 
05ad				; Append the current bank id 
05ad 21 bb f9			ld hl, store_page+3+9 
05b0 3a 94 f9			ld a, (spi_device_id) 
05b3 77				ld (hl), a 
05b4			 
05b4				; save default page 0 
05b4			 
05b4 21 00 00			ld hl, 0 
05b7 11 af f9			ld de, store_page 
05ba				if DEBUG_STORESE 
05ba					DMARK "SB3" 
05ba f5				push af  
05bb 3a cf 05			ld a, (.dmark)  
05be 32 a0 fd			ld (debug_mark),a  
05c1 3a d0 05			ld a, (.dmark+1)  
05c4 32 a1 fd			ld (debug_mark+1),a  
05c7 3a d1 05			ld a, (.dmark+2)  
05ca 32 a2 fd			ld (debug_mark+2),a  
05cd 18 03			jr .pastdmark  
05cf ..			.dmark: db "SB3"  
05d2 f1			.pastdmark: pop af  
05d3			endm  
# End of macro DMARK
05d3			;		push af 
05d3			;		ld a, 'F' 
05d3			;		ld (debug_mark),a 
05d3			;		pop af 
05d3					CALLMONITOR 
05d3 cd aa fd			call debug_vector  
05d6				endm  
# End of macro CALLMONITOR
05d6				endif 
05d6 cd d9 04			call storage_write_block 
05d9				if DEBUG_STORESE 
05d9					DMARK "SB4" 
05d9 f5				push af  
05da 3a ee 05			ld a, (.dmark)  
05dd 32 a0 fd			ld (debug_mark),a  
05e0 3a ef 05			ld a, (.dmark+1)  
05e3 32 a1 fd			ld (debug_mark+1),a  
05e6 3a f0 05			ld a, (.dmark+2)  
05e9 32 a2 fd			ld (debug_mark+2),a  
05ec 18 03			jr .pastdmark  
05ee ..			.dmark: db "SB4"  
05f1 f1			.pastdmark: pop af  
05f2			endm  
# End of macro DMARK
05f2			;		push af 
05f2			;		ld a, '>' 
05f2			;		ld (debug_mark),a 
05f2			;		pop af 
05f2					CALLMONITOR 
05f2 cd aa fd			call debug_vector  
05f5				endm  
# End of macro CALLMONITOR
05f5				endif 
05f5			 
05f5 00				nop 
05f6 00				nop 
05f7 00				nop 
05f8			 
05f8				; now set 0 in every page to mark as a free block 
05f8			 
05f8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05fa 21 40 00			ld hl, STORE_BLOCK_PHY 
05fd			 
05fd 3e 00		.setmark1:   	ld a,0 
05ff e5					push hl 
0600 c5					push bc 
0601 cd 79 02				call se_writebyte 
0604 3e 0a			ld a, 10 
0606 cd d2 0c			call aDelayInMS 
0609 23				inc hl 
060a cd 79 02				call se_writebyte 
060d 3e 0a			ld a, 10 
060f cd d2 0c			call aDelayInMS 
0612 2b				dec hl 
0613 c1					pop bc 
0614 e1					pop hl 
0615 3e 40				ld a, STORE_BLOCK_PHY 
0617 cd de 0f				call addatohl 
061a 10 e1				djnz .setmark1 
061c			 
061c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
061e 3e 00		.setmark2:   	ld a,0 
0620 e5					push hl 
0621 c5					push bc 
0622 cd 79 02				call se_writebyte 
0625 3e 0a			ld a, 10 
0627 cd d2 0c			call aDelayInMS 
062a 23				inc hl 
062b cd 79 02				call se_writebyte 
062e 3e 0a			ld a, 10 
0630 cd d2 0c			call aDelayInMS 
0633 2b				dec hl 
0634 c1					pop bc 
0635 e1					pop hl 
0636 3e 40				ld a, STORE_BLOCK_PHY 
0638 cd de 0f				call addatohl 
063b 10 e1				djnz .setmark2 
063d			 
063d					 
063d			 
063d			 
063d c9				ret 
063e			 
063e			 
063e			 
063e			 
063e .. 00		.defaultbanklabl:   db "BankLabel_",0 
0649			 
0649			 
0649			 
0649			; Label Bank 
0649			; ---------- 
0649			; 
0649			; With current bank 
0649			; Read block 0 
0649			; Set label 
0649			; Write block 0 
0649			 
0649			; label str pointer in hl 
0649			 
0649			storage_label:     
0649			 
0649				if DEBUG_STORESE 
0649					DMARK "LBL" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 a0 fd			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 a1 fd			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 a2 fd			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "LBL"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662					CALLMONITOR 
0662 cd aa fd			call debug_vector  
0665				endm  
# End of macro CALLMONITOR
0665				endif 
0665			 
0665 e5				push hl 
0666			 
0666 cd 25 05			call storage_get_block_0 
0669			 
0669				; set default label 
0669			 
0669 e1				pop hl 
066a			 
066a 11 b2 f9		 	ld de, store_page+3 
066d 01 0f 00			ld bc, 15 
0670				if DEBUG_STORESE 
0670					DMARK "LB3" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 a0 fd			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 a1 fd			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 a2 fd			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "LB3"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd aa fd			call debug_vector  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c ed b0			ldir 
068e				; save default page 0 
068e			 
068e 21 00 00			ld hl, 0 
0691 11 af f9			ld de, store_page 
0694				if DEBUG_STORESE 
0694					DMARK "LBW" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 a0 fd			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 a1 fd			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 a2 fd			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "LBW"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad					CALLMONITOR 
06ad cd aa fd			call debug_vector  
06b0				endm  
# End of macro CALLMONITOR
06b0				endif 
06b0 cd d9 04			call storage_write_block 
06b3			 
06b3 c9				ret 
06b4			 
06b4			 
06b4			 
06b4			; Read Block 0 - Config 
06b4			; --------------------- 
06b4			; 
06b4			; With current bank 
06b4			; Call presence test 
06b4			;    If not present format/init bank  
06b4			; Read block 0  
06b4			;  
06b4			 
06b4			 
06b4			; Dir 
06b4			; --- 
06b4			; 
06b4			; With current bank 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block read byte 2 
06b4			;      if first block of file 
06b4			;         Display file name 
06b4			;         Display type flags for file 
06b4			;        
06b4			 
06b4			; moving to words as this requires stack control 
06b4			 
06b4			 
06b4			; Delete File 
06b4			; ----------- 
06b4			; 
06b4			; With current bank 
06b4			; 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block file id 
06b4			;      If first block of file and dont have file id 
06b4			;         if file to delete 
06b4			;         Save file id 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			;      If file id is one saved 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			 
06b4			 
06b4			.se_done: 
06b4 e1				pop hl 
06b5 c9				ret 
06b6			 
06b6			storage_erase: 
06b6			 
06b6				; hl contains the file id 
06b6			 
06b6 5d				ld e, l 
06b7 16 00			ld d, 0 
06b9 21 40 00			ld hl, STORE_BLOCK_PHY 
06bc					if DEBUG_FORTH_WORDS 
06bc						DMARK "ERA" 
06bc f5				push af  
06bd 3a d1 06			ld a, (.dmark)  
06c0 32 a0 fd			ld (debug_mark),a  
06c3 3a d2 06			ld a, (.dmark+1)  
06c6 32 a1 fd			ld (debug_mark+1),a  
06c9 3a d3 06			ld a, (.dmark+2)  
06cc 32 a2 fd			ld (debug_mark+2),a  
06cf 18 03			jr .pastdmark  
06d1 ..			.dmark: db "ERA"  
06d4 f1			.pastdmark: pop af  
06d5			endm  
# End of macro DMARK
06d5						CALLMONITOR 
06d5 cd aa fd			call debug_vector  
06d8				endm  
# End of macro CALLMONITOR
06d8					endif 
06d8 cd a7 07			call storage_findnextid 
06db cd 07 10			call ishlzero 
06de c8				ret z 
06df			 
06df e5				push hl 
06e0			 
06e0				; TODO check file not found 
06e0			 
06e0 11 af f9			ld de, store_page 
06e3 cd 74 04			call storage_read_block 
06e6			 
06e6 cd 07 10			call ishlzero 
06e9 ca b4 06			jp z,.se_done 
06ec			 
06ec					if DEBUG_FORTH_WORDS 
06ec						DMARK "ER1" 
06ec f5				push af  
06ed 3a 01 07			ld a, (.dmark)  
06f0 32 a0 fd			ld (debug_mark),a  
06f3 3a 02 07			ld a, (.dmark+1)  
06f6 32 a1 fd			ld (debug_mark+1),a  
06f9 3a 03 07			ld a, (.dmark+2)  
06fc 32 a2 fd			ld (debug_mark+2),a  
06ff 18 03			jr .pastdmark  
0701 ..			.dmark: db "ER1"  
0704 f1			.pastdmark: pop af  
0705			endm  
# End of macro DMARK
0705						CALLMONITOR 
0705 cd aa fd			call debug_vector  
0708				endm  
# End of macro CALLMONITOR
0708					endif 
0708 3a af f9			ld a, (store_page)	; get file id 
070b 32 a3 f9			ld (store_tmpid), a 
070e			 
070e 3a b1 f9			ld a, (store_page+2)    ; get count of extends 
0711 32 a2 f9			ld (store_tmpext), a 
0714			 
0714				; wipe file header 
0714			 
0714 e1				pop hl 
0715 3e 00			ld a, 0 
0717 32 af f9			ld (store_page), a 
071a 32 b0 f9			ld (store_page+1),a 
071d 11 af f9			ld de, store_page 
0720					if DEBUG_FORTH_WORDS 
0720						DMARK "ER2" 
0720 f5				push af  
0721 3a 35 07			ld a, (.dmark)  
0724 32 a0 fd			ld (debug_mark),a  
0727 3a 36 07			ld a, (.dmark+1)  
072a 32 a1 fd			ld (debug_mark+1),a  
072d 3a 37 07			ld a, (.dmark+2)  
0730 32 a2 fd			ld (debug_mark+2),a  
0733 18 03			jr .pastdmark  
0735 ..			.dmark: db "ER2"  
0738 f1			.pastdmark: pop af  
0739			endm  
# End of macro DMARK
0739						CALLMONITOR 
0739 cd aa fd			call debug_vector  
073c				endm  
# End of macro CALLMONITOR
073c					endif 
073c cd d9 04			call storage_write_block 
073f			 
073f			 
073f				; wipe file extents 
073f			 
073f 3a a2 f9			ld a, (store_tmpext) 
0742 47				ld b, a 
0743			 
0743			.eraext:	  
0743 c5				push bc 
0744			 
0744 21 40 00			ld hl, STORE_BLOCK_PHY 
0747 3a a3 f9			ld a,(store_tmpid) 
074a 5f				ld e, a 
074b 50				ld d, b	 
074c					if DEBUG_FORTH_WORDS 
074c						DMARK "ER3" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 a0 fd			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 a1 fd			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 a2 fd			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "ER3"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765						CALLMONITOR 
0765 cd aa fd			call debug_vector  
0768				endm  
# End of macro CALLMONITOR
0768					endif 
0768 cd a7 07			call storage_findnextid 
076b cd 07 10			call ishlzero 
076e ca b4 06			jp z,.se_done 
0771			 
0771 e5				push hl 
0772 11 af f9			ld de, store_page 
0775 cd 74 04			call storage_read_block 
0778			 
0778				; free block	 
0778			 
0778 3e 00			ld a, 0 
077a 32 af f9			ld (store_page), a 
077d 32 b0 f9			ld (store_page+1),a 
0780 11 af f9			ld de, store_page 
0783 e1				pop hl 
0784					if DEBUG_FORTH_WORDS 
0784						DMARK "ER4" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 a0 fd			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 a1 fd			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 a2 fd			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "ER4"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d						CALLMONITOR 
079d cd aa fd			call debug_vector  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 cd d9 04			call storage_write_block 
07a3			 
07a3 c1				pop bc 
07a4 10 9d			djnz .eraext 
07a6			 
07a6 c9				ret 
07a7			 
07a7			 
07a7			; Find Free Block 
07a7			; --------------- 
07a7			; 
07a7			; With current bank 
07a7			;  
07a7			; From given starting logical block 
07a7			;    Read block  
07a7			;    If no file id 
07a7			;         Return block id 
07a7			 
07a7			 
07a7			; hl starting page number 
07a7			; hl contains free page number or zero if no pages free 
07a7			; e contains the file id to locate 
07a7			; d contains the block number 
07a7			 
07a7			; TODO change to find file id and use zero for free block 
07a7			 
07a7			storage_findnextid: 
07a7			 
07a7				; now locate first 0 page to mark as a free block 
07a7			 
07a7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a9			;	ld hl, STORE_BLOCK_PHY 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FNI" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 a0 fd			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 a1 fd			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 a2 fd			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FNI"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2						CALLMONITOR 
07c2 cd aa fd			call debug_vector  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5			.ff1:   	 
07c5 e5					push hl 
07c6 c5					push bc 
07c7 d5					push de 
07c8 cd 1b 03				call se_readbyte 
07cb 5f					ld e,a 
07cc 23					inc hl 
07cd cd 1b 03				call se_readbyte 
07d0 57					ld d, a 
07d1 e1					pop hl 
07d2 e5					push hl 
07d3 cd fc 0f				call cmp16 
07d6 28 49				jr z, .fffound 
07d8			 
07d8 d1					pop de 
07d9 c1					pop bc 
07da e1					pop hl 
07db			 
07db					; is found? 
07db					;cp e 
07db					;ret z 
07db			 
07db 3e 40				ld a, STORE_BLOCK_PHY 
07dd cd de 0f				call addatohl 
07e0 10 e3				djnz .ff1 
07e2			 
07e2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e4			.ff2:   	 
07e4			 
07e4 e5					push hl 
07e5 c5					push bc 
07e6 d5					push de 
07e7 cd 1b 03				call se_readbyte 
07ea 5f					ld e,a 
07eb 23					inc hl 
07ec cd 1b 03				call se_readbyte 
07ef 57					ld d, a 
07f0			 
07f0 e1					pop hl 
07f1 e5					push hl 
07f2 cd fc 0f				call cmp16 
07f5 28 2a				jr z, .fffound 
07f7			 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa					; is found? 
07fa					;cp e 
07fa					;ret z 
07fa			 
07fa 3e 40				ld a, STORE_BLOCK_PHY 
07fc cd de 0f				call addatohl 
07ff 10 e3				djnz .ff2 
0801			 
0801			 
0801					if DEBUG_FORTH_WORDS 
0801					DMARK "FN-" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 a0 fd			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 a1 fd			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 a2 fd			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "FN-"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					;	push af 
081a					;	ld a, 'n' 
081a					;	ld (debug_mark),a 
081a					;	pop af 
081a						CALLMONITOR 
081a cd aa fd			call debug_vector  
081d				endm  
# End of macro CALLMONITOR
081d					endif 
081d				; no free marks! 
081d 21 00 00				ld hl, 0 
0820 c9				ret 
0821			.fffound: 
0821				 
0821			 
0821 d1					pop de 
0822 c1					pop bc 
0823 e1					pop hl 
0824					if DEBUG_FORTH_WORDS 
0824					DMARK "FNF" 
0824 f5				push af  
0825 3a 39 08			ld a, (.dmark)  
0828 32 a0 fd			ld (debug_mark),a  
082b 3a 3a 08			ld a, (.dmark+1)  
082e 32 a1 fd			ld (debug_mark+1),a  
0831 3a 3b 08			ld a, (.dmark+2)  
0834 32 a2 fd			ld (debug_mark+2),a  
0837 18 03			jr .pastdmark  
0839 ..			.dmark: db "FNF"  
083c f1			.pastdmark: pop af  
083d			endm  
# End of macro DMARK
083d					;	push af 
083d					;	ld a, 'n' 
083d					;	ld (debug_mark),a 
083d					;	pop af 
083d						CALLMONITOR 
083d cd aa fd			call debug_vector  
0840				endm  
# End of macro CALLMONITOR
0840					endif 
0840 c9				ret 
0841			 
0841			 
0841			 
0841			; Free Space 
0841			; ---------- 
0841			; 
0841			; With current bank 
0841			; 
0841			; Set block count to zero 
0841			; Starting with first logical block 
0841			;      Find free block  
0841			;      If block id given, increment block count 
0841			; 
0841			;  
0841			 
0841			 
0841			; hl contains count of free blocks 
0841			 
0841			storage_freeblocks: 
0841			 
0841				; now locate first 0 page to mark as a free block 
0841			 
0841 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0843 21 40 00			ld hl, STORE_BLOCK_PHY 
0846 11 00 00			ld de, 0 
0849			 
0849			.fb1:   	 
0849 e5					push hl 
084a c5					push bc 
084b d5					push de 
084c cd 1b 03				call se_readbyte 
084f d1					pop de 
0850 c1					pop bc 
0851 e1					pop hl 
0852			 
0852					; is free? 
0852 fe 00				cp 0 
0854 20 01				jr nz, .ff1cont 
0856 13					inc de 
0857			 
0857			.ff1cont: 
0857			 
0857			 
0857 3e 40				ld a, STORE_BLOCK_PHY 
0859 cd de 0f				call addatohl 
085c 10 eb				djnz .fb1 
085e			 
085e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0860			.fb2:   	 
0860 e5					push hl 
0861 c5					push bc 
0862 d5					push de 
0863 cd 1b 03				call se_readbyte 
0866 d1					pop de 
0867 c1					pop bc 
0868 e1					pop hl 
0869			 
0869					; is free? 
0869 fe 00				cp 0 
086b 20 01				jr nz, .ff2cont 
086d 13					inc de 
086e			 
086e			.ff2cont: 
086e			 
086e 3e 40				ld a, STORE_BLOCK_PHY 
0870 cd de 0f				call addatohl 
0873 10 eb				djnz .fb2 
0875			 
0875 eb				ex de, hl 
0876 c9				ret 
0877			 
0877			; Get File ID 
0877			; ----------- 
0877			; 
0877			; With current bank 
0877			;  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; For each logical block 
0877			;    Read block file id 
0877			;      If first block of file and dont have file id 
0877			;         if file get id and exit 
0877			 
0877			 
0877			 
0877			 
0877			; Create File 
0877			; ----------- 
0877			; 
0877			; With current bank  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; Increment file id number 
0877			; Save Config 
0877			; Find free block 
0877			; Set buffer with file name and file id 
0877			; Write buffer to free block  
0877			 
0877			 
0877			; hl point to file name 
0877			; hl returns file id 
0877			 
0877			; file format: 
0877			; byte 0 - file id 
0877			; byte 1 - extent number 
0877			; byte 2-> data 
0877			 
0877			; format for extent number 0: 
0877			; 
0877			; byte 0 - file id 
0877			; byte 1 - extent 0 
0877			; byte 2 - extent count 
0877			; byte 3 -> file name and meta data 
0877			 
0877			 
0877			storage_create: 
0877				if DEBUG_STORESE 
0877					DMARK "SCR" 
0877 f5				push af  
0878 3a 8c 08			ld a, (.dmark)  
087b 32 a0 fd			ld (debug_mark),a  
087e 3a 8d 08			ld a, (.dmark+1)  
0881 32 a1 fd			ld (debug_mark+1),a  
0884 3a 8e 08			ld a, (.dmark+2)  
0887 32 a2 fd			ld (debug_mark+2),a  
088a 18 03			jr .pastdmark  
088c ..			.dmark: db "SCR"  
088f f1			.pastdmark: pop af  
0890			endm  
# End of macro DMARK
0890					CALLMONITOR 
0890 cd aa fd			call debug_vector  
0893				endm  
# End of macro CALLMONITOR
0893				endif 
0893			 
0893 e5				push hl		; save file name pointer 
0894			 
0894 cd 25 05			call storage_get_block_0 
0897			 
0897 3a af f9			ld a,(store_page)	; get current file id 
089a 3c				inc a 
089b 32 af f9			ld (store_page),a 
089e				 
089e 32 a3 f9			ld (store_tmpid),a			; save id 
08a1			 
08a1 21 00 00			ld hl, 0 
08a4 11 af f9			ld de, store_page 
08a7				if DEBUG_STORESE 
08a7					DMARK "SCw" 
08a7 f5				push af  
08a8 3a bc 08			ld a, (.dmark)  
08ab 32 a0 fd			ld (debug_mark),a  
08ae 3a bd 08			ld a, (.dmark+1)  
08b1 32 a1 fd			ld (debug_mark+1),a  
08b4 3a be 08			ld a, (.dmark+2)  
08b7 32 a2 fd			ld (debug_mark+2),a  
08ba 18 03			jr .pastdmark  
08bc ..			.dmark: db "SCw"  
08bf f1			.pastdmark: pop af  
08c0			endm  
# End of macro DMARK
08c0					CALLMONITOR 
08c0 cd aa fd			call debug_vector  
08c3				endm  
# End of macro CALLMONITOR
08c3				endif 
08c3 cd d9 04			call storage_write_block	 ; save update 
08c6			 
08c6				if DEBUG_STORESE 
08c6 11 af f9				ld de, store_page 
08c9					DMARK "SCC" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 a0 fd			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 a1 fd			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 a2 fd			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCC"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd aa fd			call debug_vector  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5				;  
08e5				 
08e5 21 40 00			ld hl, STORE_BLOCK_PHY 
08e8 11 00 00			ld de, 0 
08eb cd a7 07			call storage_findnextid 
08ee			 
08ee 22 9a f9			ld (store_tmppageid), hl    ; save page to use  
08f1			 
08f1				; TODO detect 0 = no spare blocks 
08f1			 
08f1				; hl now contains the free page to use for the file header page 
08f1			 
08f1				if DEBUG_STORESE 
08f1				DMARK "SCF" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 a0 fd			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 a1 fd			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 a2 fd			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCF"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					CALLMONITOR 
090a cd aa fd			call debug_vector  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d			 
090d 22 9a f9			ld (store_tmppageid), hl 
0910				 
0910 3a a3 f9			ld a,(store_tmpid)    ; get file id 
0913			;	ld a, (store_filecache)			; save to cache 
0913			 
0913 32 af f9			ld (store_page),a    ; set page id 
0916 3e 00			ld a, 0			 ; extent 0 is file header 
0918 32 b0 f9			ld (store_page+1), a   ; set file extent 
091b			 
091b 32 b1 f9			ld (store_page+2), a   ; extent count for the file 
091e			 
091e			;	inc hl 		; init block 0 of file 
091e			;	inc hl   		; skip file and extent id 
091e			 ;       ld a, 0 
091e			;	ld (hl),a 
091e			;	ld a, (store_filecache+1)  	; save to cache 
091e			 
091e			;	inc hl    ; file name 
091e				 
091e				 
091e 11 b2 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0921				if DEBUG_STORESE 
0921					DMARK "SCc" 
0921 f5				push af  
0922 3a 36 09			ld a, (.dmark)  
0925 32 a0 fd			ld (debug_mark),a  
0928 3a 37 09			ld a, (.dmark+1)  
092b 32 a1 fd			ld (debug_mark+1),a  
092e 3a 38 09			ld a, (.dmark+2)  
0931 32 a2 fd			ld (debug_mark+2),a  
0934 18 03			jr .pastdmark  
0936 ..			.dmark: db "SCc"  
0939 f1			.pastdmark: pop af  
093a			endm  
# End of macro DMARK
093a					CALLMONITOR 
093a cd aa fd			call debug_vector  
093d				endm  
# End of macro CALLMONITOR
093d				endif 
093d e1				pop hl    ; get zero term string 
093e e5				push hl 
093f 3e 00			ld a, 0 
0941 cd 4f 13			call strlent 
0944 23				inc hl   ; cover zero term 
0945 06 00			ld b,0 
0947 4d				ld c,l 
0948 e1				pop hl 
0949				;ex de, hl 
0949				if DEBUG_STORESE 
0949					DMARK "SCa" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 a0 fd			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 a1 fd			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 a2 fd			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SCa"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					;push af 
0962					;ld a, 'a' 
0962					;ld (debug_mark),a 
0962					;pop af 
0962					CALLMONITOR 
0962 cd aa fd			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 ed b0			ldir    ; copy zero term string 
0967				if DEBUG_STORESE 
0967					DMARK "SCA" 
0967 f5				push af  
0968 3a 7c 09			ld a, (.dmark)  
096b 32 a0 fd			ld (debug_mark),a  
096e 3a 7d 09			ld a, (.dmark+1)  
0971 32 a1 fd			ld (debug_mark+1),a  
0974 3a 7e 09			ld a, (.dmark+2)  
0977 32 a2 fd			ld (debug_mark+2),a  
097a 18 03			jr .pastdmark  
097c ..			.dmark: db "SCA"  
097f f1			.pastdmark: pop af  
0980			endm  
# End of macro DMARK
0980					CALLMONITOR 
0980 cd aa fd			call debug_vector  
0983				endm  
# End of macro CALLMONITOR
0983				endif 
0983			 
0983				; write file header page 
0983			 
0983 2a 9a f9			ld hl,(store_tmppageid) 
0986 11 af f9			ld de, store_page 
0989				if DEBUG_STORESE 
0989					DMARK "SCb" 
0989 f5				push af  
098a 3a 9e 09			ld a, (.dmark)  
098d 32 a0 fd			ld (debug_mark),a  
0990 3a 9f 09			ld a, (.dmark+1)  
0993 32 a1 fd			ld (debug_mark+1),a  
0996 3a a0 09			ld a, (.dmark+2)  
0999 32 a2 fd			ld (debug_mark+2),a  
099c 18 03			jr .pastdmark  
099e ..			.dmark: db "SCb"  
09a1 f1			.pastdmark: pop af  
09a2			endm  
# End of macro DMARK
09a2					;push af 
09a2					;ld a, 'b' 
09a2					;ld (debug_mark),a 
09a2					;pop af 
09a2					CALLMONITOR 
09a2 cd aa fd			call debug_vector  
09a5				endm  
# End of macro CALLMONITOR
09a5				endif 
09a5 cd d9 04			call storage_write_block 
09a8			 
09a8 3a a3 f9			ld a, (store_tmpid) 
09ab 6f				ld l, a 
09ac 26 00			ld h,0 
09ae				if DEBUG_STORESE 
09ae					DMARK "SCz" 
09ae f5				push af  
09af 3a c3 09			ld a, (.dmark)  
09b2 32 a0 fd			ld (debug_mark),a  
09b5 3a c4 09			ld a, (.dmark+1)  
09b8 32 a1 fd			ld (debug_mark+1),a  
09bb 3a c5 09			ld a, (.dmark+2)  
09be 32 a2 fd			ld (debug_mark+2),a  
09c1 18 03			jr .pastdmark  
09c3 ..			.dmark: db "SCz"  
09c6 f1			.pastdmark: pop af  
09c7			endm  
# End of macro DMARK
09c7					CALLMONITOR 
09c7 cd aa fd			call debug_vector  
09ca				endm  
# End of macro CALLMONITOR
09ca				endif 
09ca c9				ret 
09cb				 
09cb			 
09cb			 
09cb			; 
09cb			; Read File 
09cb			; 
09cb			; h - file id to locate 
09cb			; l - extent to locate 
09cb			; de - pointer to string to read into 
09cb			; 
09cb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09cb			 
09cb			.sr_fail: 
09cb d1				pop de 
09cc c9				ret 
09cd			 
09cd			storage_read: 
09cd			 
09cd			 
09cd d5				push de 
09ce			 
09ce			; TODO BUG the above push is it popped before the RET Z? 
09ce			 
09ce			; TODO how to handle multiple part blocks 
09ce			 
09ce				; locate file extent to read 
09ce			 
09ce 5c				ld e, h 
09cf 55				ld d, l 
09d0			 
09d0			.srext: 
09d0 22 ad f9			ld (store_readptr), hl     ; save the current extent to load 
09d3 ed 53 ab f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09d7			 
09d7 21 40 00			ld hl, STORE_BLOCK_PHY 
09da				if DEBUG_STORESE 
09da					DMARK "sre" 
09da f5				push af  
09db 3a ef 09			ld a, (.dmark)  
09de 32 a0 fd			ld (debug_mark),a  
09e1 3a f0 09			ld a, (.dmark+1)  
09e4 32 a1 fd			ld (debug_mark+1),a  
09e7 3a f1 09			ld a, (.dmark+2)  
09ea 32 a2 fd			ld (debug_mark+2),a  
09ed 18 03			jr .pastdmark  
09ef ..			.dmark: db "sre"  
09f2 f1			.pastdmark: pop af  
09f3			endm  
# End of macro DMARK
09f3					CALLMONITOR 
09f3 cd aa fd			call debug_vector  
09f6				endm  
# End of macro CALLMONITOR
09f6				endif 
09f6 cd a7 07			call storage_findnextid 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srf" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 a0 fd			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 a1 fd			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 a2 fd			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srf"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd aa fd			call debug_vector  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15 cd 07 10			call ishlzero 
0a18			;	ld a, l 
0a18			;	add h 
0a18			;	cp 0 
0a18 28 b1			jr z,.sr_fail			; block not found so EOF 
0a1a			 
0a1a				; save current address for use by higher level words etc 
0a1a			 
0a1a 22 a0 f9			ld (store_openaddr),hl 
0a1d			 
0a1d			 
0a1d				; hl contains page number to load 
0a1d d1				pop de   ; get storage 
0a1e ed 53 ab f9		ld (store_readbuf), de     ; current buffer to load in to 
0a22 d5				push de 
0a23				if DEBUG_STORESE 
0a23					DMARK "srg" 
0a23 f5				push af  
0a24 3a 38 0a			ld a, (.dmark)  
0a27 32 a0 fd			ld (debug_mark),a  
0a2a 3a 39 0a			ld a, (.dmark+1)  
0a2d 32 a1 fd			ld (debug_mark+1),a  
0a30 3a 3a 0a			ld a, (.dmark+2)  
0a33 32 a2 fd			ld (debug_mark+2),a  
0a36 18 03			jr .pastdmark  
0a38 ..			.dmark: db "srg"  
0a3b f1			.pastdmark: pop af  
0a3c			endm  
# End of macro DMARK
0a3c					CALLMONITOR 
0a3c cd aa fd			call debug_vector  
0a3f				endm  
# End of macro CALLMONITOR
0a3f				endif 
0a3f cd 74 04			call storage_read_block 
0a42			 
0a42				; if this a continuation read??? 
0a42			 
0a42 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a45			 
0a45 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a47 cd de 0f			call addatohl 
0a4a 7e				ld a,(hl) 
0a4b fe 00			cp 0 
0a4d 28 02			jr z, .markiscont 
0a4f 3e ff			ld a, 255 
0a51			 
0a51			.markiscont: 
0a51 32 a2 f9			ld (store_readcont), a 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "srC" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 a0 fd			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 a1 fd			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 a2 fd			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "srC"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd aa fd			call debug_vector  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70				; only short reads enabled 
0a70			 
0a70 3a aa f9			ld a, (store_longread) 
0a73 fe 00			cp 0 
0a75 ca 42 0b			jp z, .readdone 
0a78			 
0a78			; TODO if block has no zeros then need to read next block  
0a78			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a78			; check last byte of physical block. 
0a78			; if not zero then the next block needs to be loaded 
0a78			 
0a78			 
0a78 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a7b			 
0a7b 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a7d cd de 0f			call addatohl 
0a80				;dec hl 
0a80 7e				ld a,(hl) 
0a81				if DEBUG_STORESE 
0a81					DMARK "sr?" 
0a81 f5				push af  
0a82 3a 96 0a			ld a, (.dmark)  
0a85 32 a0 fd			ld (debug_mark),a  
0a88 3a 97 0a			ld a, (.dmark+1)  
0a8b 32 a1 fd			ld (debug_mark+1),a  
0a8e 3a 98 0a			ld a, (.dmark+2)  
0a91 32 a2 fd			ld (debug_mark+2),a  
0a94 18 03			jr .pastdmark  
0a96 ..			.dmark: db "sr?"  
0a99 f1			.pastdmark: pop af  
0a9a			endm  
# End of macro DMARK
0a9a					CALLMONITOR 
0a9a cd aa fd			call debug_vector  
0a9d				endm  
# End of macro CALLMONITOR
0a9d				endif 
0a9d fe 00			cp 0 
0a9f ca 42 0b			jp z, .readdone 
0aa2			 
0aa2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0aa2			 
0aa2 23				inc hl 
0aa3			 
0aa3 22 ab f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0aa6			 
0aa6 ed 5b ad f9		ld de, (store_readptr)     ; save the current extent to load 
0aaa			 
0aaa eb				ex de, hl 
0aab			 
0aab				; next ext 
0aab			 
0aab 23				inc hl 
0aac 22 ad f9			ld  (store_readptr), hl     ; save the current extent to load 
0aaf			 
0aaf				if DEBUG_STORESE 
0aaf					DMARK "sF2" 
0aaf f5				push af  
0ab0 3a c4 0a			ld a, (.dmark)  
0ab3 32 a0 fd			ld (debug_mark),a  
0ab6 3a c5 0a			ld a, (.dmark+1)  
0ab9 32 a1 fd			ld (debug_mark+1),a  
0abc 3a c6 0a			ld a, (.dmark+2)  
0abf 32 a2 fd			ld (debug_mark+2),a  
0ac2 18 03			jr .pastdmark  
0ac4 ..			.dmark: db "sF2"  
0ac7 f1			.pastdmark: pop af  
0ac8			endm  
# End of macro DMARK
0ac8					CALLMONITOR 
0ac8 cd aa fd			call debug_vector  
0acb				endm  
# End of macro CALLMONITOR
0acb				endif 
0acb			 
0acb				; get and load block 
0acb			 
0acb cd a7 07			call storage_findnextid 
0ace			 
0ace				if DEBUG_STORESE 
0ace					DMARK "sf2" 
0ace f5				push af  
0acf 3a e3 0a			ld a, (.dmark)  
0ad2 32 a0 fd			ld (debug_mark),a  
0ad5 3a e4 0a			ld a, (.dmark+1)  
0ad8 32 a1 fd			ld (debug_mark+1),a  
0adb 3a e5 0a			ld a, (.dmark+2)  
0ade 32 a2 fd			ld (debug_mark+2),a  
0ae1 18 03			jr .pastdmark  
0ae3 ..			.dmark: db "sf2"  
0ae6 f1			.pastdmark: pop af  
0ae7			endm  
# End of macro DMARK
0ae7					CALLMONITOR 
0ae7 cd aa fd			call debug_vector  
0aea				endm  
# End of macro CALLMONITOR
0aea				endif 
0aea cd 07 10			call ishlzero 
0aed			;	ld a, l 
0aed			;	add h 
0aed			;	cp 0 
0aed ca cb 09			jp z,.sr_fail			; block not found so EOF 
0af0				 
0af0				; save current address for use by higher level words etc 
0af0			 
0af0 22 a0 f9			ld (store_openaddr),hl 
0af3			 
0af3 cd 74 04			call storage_read_block 
0af6			 
0af6				; on a continuation block, we now have the file id and ext in the middle of the block 
0af6				; we need to pull everything back  
0af6			 
0af6 ed 5b ab f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0afa 2a ab f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0afd 23				inc hl 
0afe 23				inc hl     ; skip id and ext 
0aff 01 40 00			ld bc, STORE_BLOCK_PHY 
0b02				if DEBUG_STORESE 
0b02					DMARK "SR<" 
0b02 f5				push af  
0b03 3a 17 0b			ld a, (.dmark)  
0b06 32 a0 fd			ld (debug_mark),a  
0b09 3a 18 0b			ld a, (.dmark+1)  
0b0c 32 a1 fd			ld (debug_mark+1),a  
0b0f 3a 19 0b			ld a, (.dmark+2)  
0b12 32 a2 fd			ld (debug_mark+2),a  
0b15 18 03			jr .pastdmark  
0b17 ..			.dmark: db "SR<"  
0b1a f1			.pastdmark: pop af  
0b1b			endm  
# End of macro DMARK
0b1b					CALLMONITOR 
0b1b cd aa fd			call debug_vector  
0b1e				endm  
# End of macro CALLMONITOR
0b1e				endif 
0b1e ed b0			ldir     ; copy data 
0b20			 
0b20				; move the pointer back and pretend we have a full buffer for next recheck 
0b20			 
0b20 1b				dec de 
0b21 1b				dec de 
0b22			 
0b22			; TODO do pop below now short circuit loop????? 
0b22 c1				pop bc     ; get rid of spare de on stack 
0b23				if DEBUG_STORESE 
0b23					DMARK "SR>" 
0b23 f5				push af  
0b24 3a 38 0b			ld a, (.dmark)  
0b27 32 a0 fd			ld (debug_mark),a  
0b2a 3a 39 0b			ld a, (.dmark+1)  
0b2d 32 a1 fd			ld (debug_mark+1),a  
0b30 3a 3a 0b			ld a, (.dmark+2)  
0b33 32 a2 fd			ld (debug_mark+2),a  
0b36 18 03			jr .pastdmark  
0b38 ..			.dmark: db "SR>"  
0b3b f1			.pastdmark: pop af  
0b3c			endm  
# End of macro DMARK
0b3c					CALLMONITOR 
0b3c cd aa fd			call debug_vector  
0b3f				endm  
# End of macro CALLMONITOR
0b3f				endif 
0b3f c3 d0 09			jp .srext 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			.readdone:		 
0b42 e1				pop hl 		 ; return start of data to show as not EOF 
0b43 23				inc hl   ; past file id 
0b44 23				inc hl   ; past ext 
0b45				if DEBUG_STORESE 
0b45					DMARK "SRe" 
0b45 f5				push af  
0b46 3a 5a 0b			ld a, (.dmark)  
0b49 32 a0 fd			ld (debug_mark),a  
0b4c 3a 5b 0b			ld a, (.dmark+1)  
0b4f 32 a1 fd			ld (debug_mark+1),a  
0b52 3a 5c 0b			ld a, (.dmark+2)  
0b55 32 a2 fd			ld (debug_mark+2),a  
0b58 18 03			jr .pastdmark  
0b5a ..			.dmark: db "SRe"  
0b5d f1			.pastdmark: pop af  
0b5e			endm  
# End of macro DMARK
0b5e					CALLMONITOR 
0b5e cd aa fd			call debug_vector  
0b61				endm  
# End of macro CALLMONITOR
0b61				endif 
0b61 c9					ret 
0b62			 
0b62			 
0b62			 
0b62			; 
0b62			; Append File 
0b62			; 
0b62			; hl - file id to locate 
0b62			; de - pointer to (multi block) string to write 
0b62			 
0b62			.sa_notfound: 
0b62 d1				pop de 
0b63 c9				ret 
0b64			 
0b64			 
0b64			storage_append: 
0b64				; hl -  file id to append to 
0b64				; de - string to append 
0b64			 
0b64 d5				push de 
0b65				 
0b65				if DEBUG_STORESE 
0b65					DMARK "AP1" 
0b65 f5				push af  
0b66 3a 7a 0b			ld a, (.dmark)  
0b69 32 a0 fd			ld (debug_mark),a  
0b6c 3a 7b 0b			ld a, (.dmark+1)  
0b6f 32 a1 fd			ld (debug_mark+1),a  
0b72 3a 7c 0b			ld a, (.dmark+2)  
0b75 32 a2 fd			ld (debug_mark+2),a  
0b78 18 03			jr .pastdmark  
0b7a ..			.dmark: db "AP1"  
0b7d f1			.pastdmark: pop af  
0b7e			endm  
# End of macro DMARK
0b7e					CALLMONITOR 
0b7e cd aa fd			call debug_vector  
0b81				endm  
# End of macro CALLMONITOR
0b81				endif 
0b81			 
0b81 7d				ld a, l 
0b82 32 a3 f9			ld (store_tmpid), a 
0b85			 
0b85				; get file header  
0b85			 
0b85 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b87 3a a3 f9			ld a, (store_tmpid) 
0b8a 5f				ld e, a 
0b8b			 
0b8b 21 40 00				ld hl, STORE_BLOCK_PHY 
0b8e cd a7 07				call storage_findnextid 
0b91			 
0b91 cd 07 10			call ishlzero 
0b94 28 cc			jr z, .sa_notfound 
0b96			 
0b96 22 9a f9			ld (store_tmppageid), hl 
0b99			 
0b99				; TODO handle file id not found 
0b99			 
0b99				if DEBUG_STORESE 
0b99					DMARK "AP2" 
0b99 f5				push af  
0b9a 3a ae 0b			ld a, (.dmark)  
0b9d 32 a0 fd			ld (debug_mark),a  
0ba0 3a af 0b			ld a, (.dmark+1)  
0ba3 32 a1 fd			ld (debug_mark+1),a  
0ba6 3a b0 0b			ld a, (.dmark+2)  
0ba9 32 a2 fd			ld (debug_mark+2),a  
0bac 18 03			jr .pastdmark  
0bae ..			.dmark: db "AP2"  
0bb1 f1			.pastdmark: pop af  
0bb2			endm  
# End of macro DMARK
0bb2					CALLMONITOR 
0bb2 cd aa fd			call debug_vector  
0bb5				endm  
# End of macro CALLMONITOR
0bb5				endif 
0bb5			 
0bb5				; update file extent count 
0bb5			 
0bb5 11 af f9			ld de, store_page 
0bb8			 
0bb8 cd 74 04			call storage_read_block 
0bbb			 
0bbb				if DEBUG_STORESE 
0bbb					DMARK "AP3" 
0bbb f5				push af  
0bbc 3a d0 0b			ld a, (.dmark)  
0bbf 32 a0 fd			ld (debug_mark),a  
0bc2 3a d1 0b			ld a, (.dmark+1)  
0bc5 32 a1 fd			ld (debug_mark+1),a  
0bc8 3a d2 0b			ld a, (.dmark+2)  
0bcb 32 a2 fd			ld (debug_mark+2),a  
0bce 18 03			jr .pastdmark  
0bd0 ..			.dmark: db "AP3"  
0bd3 f1			.pastdmark: pop af  
0bd4			endm  
# End of macro DMARK
0bd4					CALLMONITOR 
0bd4 cd aa fd			call debug_vector  
0bd7				endm  
# End of macro CALLMONITOR
0bd7				endif 
0bd7			;	ld (store_tmppageid), hl 
0bd7			 
0bd7 3a b1 f9			ld a, (store_page+2) 
0bda 3c				inc a 
0bdb 32 b1 f9			ld (store_page+2), a 
0bde 32 a2 f9			ld (store_tmpext), a 
0be1				 
0be1				if DEBUG_STORESE 
0be1					DMARK "AP3" 
0be1 f5				push af  
0be2 3a f6 0b			ld a, (.dmark)  
0be5 32 a0 fd			ld (debug_mark),a  
0be8 3a f7 0b			ld a, (.dmark+1)  
0beb 32 a1 fd			ld (debug_mark+1),a  
0bee 3a f8 0b			ld a, (.dmark+2)  
0bf1 32 a2 fd			ld (debug_mark+2),a  
0bf4 18 03			jr .pastdmark  
0bf6 ..			.dmark: db "AP3"  
0bf9 f1			.pastdmark: pop af  
0bfa			endm  
# End of macro DMARK
0bfa					CALLMONITOR 
0bfa cd aa fd			call debug_vector  
0bfd				endm  
# End of macro CALLMONITOR
0bfd				endif 
0bfd 2a 9a f9			ld hl, (store_tmppageid) 
0c00 11 af f9			ld de, store_page 
0c03 cd d9 04			call storage_write_block 
0c06			 
0c06				; find free block 
0c06			 
0c06 11 00 00			ld de, 0			 ; file extent to locate 
0c09			 
0c09 21 40 00				ld hl, STORE_BLOCK_PHY 
0c0c cd a7 07				call storage_findnextid 
0c0f cd 07 10			call ishlzero 
0c12 ca 62 0b			jp z, .sa_notfound 
0c15			 
0c15					; TODO handle no space left 
0c15					 
0c15 22 9a f9				ld (store_tmppageid), hl 
0c18			 
0c18				if DEBUG_STORESE 
0c18					DMARK "AP4" 
0c18 f5				push af  
0c19 3a 2d 0c			ld a, (.dmark)  
0c1c 32 a0 fd			ld (debug_mark),a  
0c1f 3a 2e 0c			ld a, (.dmark+1)  
0c22 32 a1 fd			ld (debug_mark+1),a  
0c25 3a 2f 0c			ld a, (.dmark+2)  
0c28 32 a2 fd			ld (debug_mark+2),a  
0c2b 18 03			jr .pastdmark  
0c2d ..			.dmark: db "AP4"  
0c30 f1			.pastdmark: pop af  
0c31			endm  
# End of macro DMARK
0c31					CALLMONITOR 
0c31 cd aa fd			call debug_vector  
0c34				endm  
# End of macro CALLMONITOR
0c34				endif 
0c34					; init the buffer with zeros so we can id if the buffer is full or not 
0c34			 
0c34 e5					push hl 
0c35 c5					push bc 
0c36			 
0c36 21 af f9				ld hl, store_page 
0c39 06 40				ld b, STORE_BLOCK_PHY 
0c3b 3e 00				ld a, 0 
0c3d 77			.zeroblock:	ld (hl), a 
0c3e 23					inc hl 
0c3f 10 fc				djnz .zeroblock 
0c41			 
0c41 c1					pop bc 
0c42 e1					pop hl 
0c43			 
0c43					; construct block 
0c43			 
0c43 3a a3 f9				ld a, (store_tmpid) 
0c46 32 af f9				ld (store_page), a   ; file id 
0c49 3a a2 f9				ld a, (store_tmpext)   ; extent for this block 
0c4c 32 b0 f9				ld (store_page+1), a 
0c4f			 
0c4f e1					pop hl    ; get string to write 
0c50 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c52 11 b1 f9				ld de, store_page+2 
0c55			 
0c55				if DEBUG_STORESE 
0c55					DMARK "AP5" 
0c55 f5				push af  
0c56 3a 6a 0c			ld a, (.dmark)  
0c59 32 a0 fd			ld (debug_mark),a  
0c5c 3a 6b 0c			ld a, (.dmark+1)  
0c5f 32 a1 fd			ld (debug_mark+1),a  
0c62 3a 6c 0c			ld a, (.dmark+2)  
0c65 32 a2 fd			ld (debug_mark+2),a  
0c68 18 03			jr .pastdmark  
0c6a ..			.dmark: db "AP5"  
0c6d f1			.pastdmark: pop af  
0c6e			endm  
# End of macro DMARK
0c6e					CALLMONITOR 
0c6e cd aa fd			call debug_vector  
0c71				endm  
# End of macro CALLMONITOR
0c71				endif 
0c71			 
0c71			 
0c71			 
0c71					; fill buffer with data until end of string or full block 
0c71			 
0c71 7e			.appd:		ld a, (hl) 
0c72 12					ld (de), a 
0c73 fe 00				cp 0 
0c75 28 04				jr z, .appdone 
0c77 23					inc hl 
0c78 13					inc de 
0c79 10 f6				djnz .appd 
0c7b			 
0c7b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c7c f5					push af   		; save last byte dumped 
0c7d			 
0c7d			 
0c7d 2a 9a f9			ld hl, (store_tmppageid) 
0c80 11 af f9			ld de, store_page 
0c83				if DEBUG_STORESE 
0c83					DMARK "AP6" 
0c83 f5				push af  
0c84 3a 98 0c			ld a, (.dmark)  
0c87 32 a0 fd			ld (debug_mark),a  
0c8a 3a 99 0c			ld a, (.dmark+1)  
0c8d 32 a1 fd			ld (debug_mark+1),a  
0c90 3a 9a 0c			ld a, (.dmark+2)  
0c93 32 a2 fd			ld (debug_mark+2),a  
0c96 18 03			jr .pastdmark  
0c98 ..			.dmark: db "AP6"  
0c9b f1			.pastdmark: pop af  
0c9c			endm  
# End of macro DMARK
0c9c					CALLMONITOR 
0c9c cd aa fd			call debug_vector  
0c9f				endm  
# End of macro CALLMONITOR
0c9f				endif 
0c9f cd d9 04				call storage_write_block 
0ca2			 
0ca2			 
0ca2				; was that a full block of data written? 
0ca2				; any more to write out? 
0ca2			 
0ca2				; if yes then set vars and jump to start of function again 
0ca2			 
0ca2 f1					pop af 
0ca3 d1					pop de 
0ca4			 
0ca4 fe 00				cp 0		 ; no, string was fully written 
0ca6 c8					ret z 
0ca7			 
0ca7					; setup vars for next cycle 
0ca7			 
0ca7 3a a3 f9				ld a, (store_tmpid) 
0caa 6f					ld l, a 
0cab 26 00				ld h, 0 
0cad			 
0cad c3 64 0b			 	jp storage_append	 ; yes, need to write out some more 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			if DEBUG_STORECF 
0cb0			storageput:	 
0cb0					ret 
0cb0			storageread: 
0cb0					ld hl, store_page 
0cb0					ld b, 200 
0cb0					ld a,0 
0cb0			.src:		ld (hl),a 
0cb0					inc hl 
0cb0					djnz .src 
0cb0					 
0cb0			 
0cb0					ld de, 0 
0cb0					ld bc, 1 
0cb0					ld hl, store_page 
0cb0					call cfRead 
0cb0			 
0cb0				call cfGetError 
0cb0				ld hl,scratch 
0cb0				call hexout 
0cb0				ld hl, scratch+2 
0cb0				ld a, 0 
0cb0				ld (hl),a 
0cb0				ld de, scratch 
0cb0				ld a,display_row_1 
0cb0				call str_at_display 
0cb0				call update_display 
0cb0			 
0cb0					ld hl, store_page 
0cb0					ld (os_cur_ptr),hl 
0cb0			 
0cb0					ret 
0cb0			endif 
0cb0			 
0cb0			 
0cb0			; Clear out the main buffer store (used to remove junk before writing a new block) 
0cb0			 
0cb0			storage_clear_page: 
0cb0 e5				push hl 
0cb1 d5				push de 
0cb2 c5				push bc 
0cb3 21 af f9			ld hl, store_page 
0cb6 3e 00			ld a, 0 
0cb8 77				ld (hl), a 
0cb9			 
0cb9 11 b0 f9			ld de, store_page+1 
0cbc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cbf			 
0cbf ed b0			ldir 
0cc1				 
0cc1 c1				pop bc 
0cc2 d1				pop de 
0cc3 e1				pop hl 
0cc4 c9				ret 
0cc5			 
0cc5			; eof 
# End of file firmware_storage.asm
0cc5			  
0cc5			; support routines for above hardware abstraction layer  
0cc5			  
0cc5			include "firmware_general.asm"        ; general support functions  
0cc5			 
0cc5			; word look up 
0cc5			 
0cc5			; in 
0cc5			; a is the index 
0cc5			; hl is pointer start of array 
0cc5			; 
0cc5			; returns 
0cc5			; hl to the word 
0cc5			; 
0cc5			 
0cc5			table_lookup:  
0cc5 d5					push de 
0cc6 eb					ex de, hl 
0cc7			 
0cc7 6f					ld l, a 
0cc8 26 00				ld h, 0 
0cca 29					add hl, hl 
0ccb 19					add hl, de 
0ccc 7e					ld a, (hl) 
0ccd 23					inc hl 
0cce 66					ld h,(hl) 
0ccf 6f					ld l, a 
0cd0			 
0cd0 d1					pop de 
0cd1 c9					ret 
0cd2			 
0cd2			; Delay loops 
0cd2			 
0cd2			 
0cd2			 
0cd2			aDelayInMS: 
0cd2 c5				push bc 
0cd3 47				ld b,a 
0cd4			msdelay: 
0cd4 c5				push bc 
0cd5				 
0cd5			 
0cd5 01 41 00			ld bc,041h 
0cd8 cd f0 0c			call delayloop 
0cdb c1				pop bc 
0cdc 05				dec b 
0cdd 20 f5			jr nz,msdelay 
0cdf			 
0cdf			;if CPU_CLOCK_8MHZ 
0cdf			;msdelay8: 
0cdf			;	push bc 
0cdf			;	 
0cdf			; 
0cdf			;	ld bc,041h 
0cdf			;	call delayloop 
0cdf			;	pop bc 
0cdf			;	dec b 
0cdf			;	jr nz,msdelay8 
0cdf			;endif 
0cdf			 
0cdf			 
0cdf c1				pop bc 
0ce0 c9				ret 
0ce1			 
0ce1			 
0ce1			delay250ms: 
0ce1				;push de 
0ce1 01 00 40			ld bc, 04000h 
0ce4 c3 f0 0c			jp delayloop 
0ce7			delay500ms: 
0ce7				;push de 
0ce7 01 00 80			ld bc, 08000h 
0cea c3 f0 0c			jp delayloop 
0ced			delay1s: 
0ced				;push bc 
0ced			   ; Clobbers A, d and e 
0ced 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0cf0			delayloop: 
0cf0 c5			    push bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				ld bc, CPM_DELAY_TUNE 
0cf1			.cpmloop: 
0cf1				push bc 
0cf1			 
0cf1			endif 
0cf1			 
0cf1			 
0cf1			 
0cf1			delayloopi: 
0cf1			;	push bc 
0cf1			;.dl: 
0cf1 cb 47		    bit     0,a    	; 8 
0cf3 cb 47		    bit     0,a    	; 8 
0cf5 cb 47		    bit     0,a    	; 8 
0cf7 e6 ff		    and     255  	; 7 
0cf9 0b			    dec     bc      	; 6 
0cfa 79			    ld      a,c     	; 4 
0cfb b0			    or      b     	; 4 
0cfc c2 f1 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cff			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cff				;pop de 
0cff			;pop bc 
0cff			 
0cff			if BASE_CPM 
0cff				pop bc 
0cff				 
0cff			    dec     bc      	; 6 
0cff			    ld      a,c     	; 4 
0cff			    or      b     	; 4 
0cff			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cff				 
0cff			 
0cff			endif 
0cff			;if CPU_CLOCK_8MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff			 
0cff			;if CPU_CLOCK_10MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff c1			    pop bc 
0d00			 
0d00 c9				ret 
0d01			 
0d01			 
0d01			 
0d01			; eof 
# End of file firmware_general.asm
0d01			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0d01			; display routines that use the physical hardware abstraction layer 
0d01			 
0d01			 
0d01			; Display an activity indicator 
0d01			; Each call returns the new char pointed to in hl 
0d01			 
0d01			active: 
0d01 3a fb fa			ld a, (display_active) 
0d04 fe 06			cp 6 
0d06			 
0d06 20 02			jr nz, .sne 
0d08				; gone past the last one reset sequence 
0d08 3e ff			ld a, 255 
0d0a			 
0d0a			.sne:   
0d0a				; get the next char in seq 
0d0a 3c				inc a 
0d0b 32 fb fa			ld (display_active), a 
0d0e			 
0d0e				; look up the string in the table 
0d0e 21 25 0d			ld hl, actseq 
0d11 cb 27			sla a 
0d13 cd de 0f			call addatohl 
0d16 cd ba 23			call loadwordinhl 
0d19			 
0d19				; forth will write the to string when pushing so move from rom to ram 
0d19			 
0d19 11 fc fa			ld de, display_active+1 
0d1c 01 02 00			ld bc, 2 
0d1f ed b0			ldir 
0d21			 
0d21 21 fc fa			ld hl, display_active+1 
0d24 c9				ret 
0d25				 
0d25				 
0d25			 
0d25			 
0d25			;db "|/-\|-\" 
0d25			 
0d25			actseq: 
0d25			 
0d25 33 0d		dw spin0 
0d27 35 0d		dw spin1 
0d29 37 0d		dw spin2 
0d2b 39 0d		dw spin3 
0d2d 37 0d		dw spin2 
0d2f 35 0d		dw spin1 
0d31 33 0d		dw spin0 
0d33			 
0d33 .. 00		spin0: db " ", 0 
0d35 .. 00		spin1: db "-", 0 
0d37 .. 00		spin2: db "+", 0 
0d39 .. 00		spin3: db "#", 0 
0d3b			 
0d3b			 
0d3b			; information window 
0d3b			 
0d3b			; pass hl with 1st string to display 
0d3b			; pass de with 2nd string to display 
0d3b			 
0d3b			info_panel: 
0d3b e5				push hl 
0d3c			 
0d3c 2a 01 fb			ld hl, (display_fb_active) 
0d3f e5				push hl    ; future de destination 
0d40 21 e6 fc				ld hl, display_fb0 
0d43 22 01 fb				ld (display_fb_active), hl 
0d46			 
0d46			;	call clear_display 
0d46			 
0d46				if BASE_CPM 
0d46				ld a, '.' 
0d46				else 
0d46 3e a5			ld a, 165 
0d48				endif 
0d48 cd af 0d			call fill_display 
0d4b			 
0d4b			 
0d4b 3e 55			ld a, display_row_3 + 5 
0d4d cd bd 0d			call str_at_display 
0d50			 
0d50 e1				pop hl 
0d51 d1				pop de 
0d52			 
0d52 e5				push hl 
0d53			 
0d53			 
0d53 3e 2d			ld a, display_row_2 + 5 
0d55 cd bd 0d			call str_at_display 
0d58			 
0d58			 
0d58 cd cd 0d			call update_display 
0d5b cd c0 1f			call next_page_prompt 
0d5e cd aa 0d			call clear_display 
0d61			 
0d61				 
0d61 21 45 fc				ld hl, display_fb1 
0d64 22 01 fb				ld (display_fb_active), hl 
0d67 cd cd 0d			call update_display 
0d6a			 
0d6a e1				pop hl 
0d6b			 
0d6b c9				ret 
0d6c			 
0d6c			 
0d6c			 
0d6c			 
0d6c			; TODO windowing? 
0d6c			 
0d6c			; TODO scroll line up 
0d6c			 
0d6c			scroll_up: 
0d6c			 
0d6c e5				push hl 
0d6d d5				push de 
0d6e c5				push bc 
0d6f			 
0d6f				; get frame buffer  
0d6f			 
0d6f 2a 01 fb			ld hl, (display_fb_active) 
0d72 e5				push hl    ; future de destination 
0d73			 
0d73 11 28 00			ld  de, display_cols 
0d76 19				add hl, de 
0d77			 
0d77 d1				pop de 
0d78			 
0d78				;ex de, hl 
0d78 01 9f 00			ld bc, display_fb_len -1  
0d7b			;if DEBUG_FORTH_WORDS 
0d7b			;	DMARK "SCL" 
0d7b			;	CALLMONITOR 
0d7b			;endif	 
0d7b ed b0			ldir 
0d7d			 
0d7d				; wipe bottom row 
0d7d			 
0d7d			 
0d7d 2a 01 fb			ld hl, (display_fb_active) 
0d80 11 a0 00			ld de, display_cols*display_rows 
0d83 19				add hl, de 
0d84 06 28			ld b, display_cols 
0d86 3e 20			ld a, ' ' 
0d88			.scwipe: 
0d88 77				ld (hl), a 
0d89 2b				dec hl 
0d8a 10 fc			djnz .scwipe 
0d8c			 
0d8c				;pop hl 
0d8c			 
0d8c c1				pop bc 
0d8d d1				pop de 
0d8e e1				pop hl 
0d8f			 
0d8f c9				ret 
0d90			 
0d90			 
0d90			;scroll_upo: 
0d90			;	ld de, display_row_1 
0d90			 ;	ld hl, display_row_2 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_2 
0d90			 ;	ld hl, display_row_3 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_3 
0d90			 ;	ld hl, display_row_4 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			 
0d90			; TODO clear row 4 
0d90			 
0d90			;	ret 
0d90			 
0d90				 
0d90			scroll_down: 
0d90			 
0d90 e5				push hl 
0d91 d5				push de 
0d92 c5				push bc 
0d93			 
0d93				; get frame buffer  
0d93			 
0d93 2a 01 fb			ld hl, (display_fb_active) 
0d96			 
0d96 11 9f 00			ld de, display_fb_len - 1 
0d99 19				add hl, de 
0d9a			 
0d9a e5			push hl    ; future de destination 
0d9b			 
0d9b 11 28 00			ld  de, display_cols 
0d9e ed 52			sbc hl, de 
0da0			 
0da0			 
0da0 d1				pop de 
0da1			 
0da1			;	ex de, hl 
0da1 01 9f 00			ld bc, display_fb_len -1  
0da4			 
0da4			 
0da4				 
0da4			 
0da4 ed b0			ldir 
0da6			 
0da6				; wipe bottom row 
0da6			 
0da6			 
0da6			;	ld hl, (display_fb_active) 
0da6			;;	ld de, display_cols*display_rows 
0da6			;;	add hl, de 
0da6			;	ld b, display_cols 
0da6			;	ld a, ' ' 
0da6			;.scwiped: 
0da6			;	ld (hl), a 
0da6			;	dec hl 
0da6			;	djnz .scwiped 
0da6			 
0da6				;pop hl 
0da6			 
0da6 c1				pop bc 
0da7 d1				pop de 
0da8 e1				pop hl 
0da9			 
0da9 c9				ret 
0daa			;scroll_down: 
0daa			;	ld de, display_row_4 
0daa			;	ld hl, display_row_3 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_3 
0daa			; 	ld hl, display_row_2 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_2 
0daa			;	ld hl, display_row_1 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;;; TODO clear row 1 
0daa			;	ret 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			; clear active frame buffer 
0daa			 
0daa			clear_display: 
0daa 3e 20			ld a, ' ' 
0dac c3 af 0d			jp fill_display 
0daf			 
0daf			; fill active frame buffer with a char in A 
0daf			 
0daf			fill_display: 
0daf 06 a0			ld b,display_fb_len 
0db1 2a 01 fb			ld hl, (display_fb_active) 
0db4 77			.fd1:	ld (hl),a 
0db5 23				inc hl 
0db6 10 fc			djnz .fd1 
0db8 23				inc hl 
0db9 3e 00			ld a,0 
0dbb 77				ld (hl),a 
0dbc			 
0dbc			 
0dbc c9				ret 
0dbd			; Write string (DE) at pos (A) to active frame buffer 
0dbd			 
0dbd 2a 01 fb		str_at_display:    ld hl,(display_fb_active) 
0dc0 06 00					ld b,0 
0dc2 4f					ld c,a 
0dc3 09					add hl,bc 
0dc4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0dc5 b7			            OR   A              ;Null terminator? 
0dc6 c8			            RET  Z              ;Yes, so finished 
0dc7 77					ld (hl),a 
0dc8 23				inc hl 
0dc9 13			            INC  DE             ;Point to next character 
0dca 18 f8		            JR   .sad1     ;Repeat 
0dcc c9					ret 
0dcd			 
0dcd			; using current frame buffer write to physical display 
0dcd			 
0dcd			update_display: 
0dcd e5				push hl 
0dce 2a 01 fb			ld hl, (display_fb_active) 
0dd1 cd 0b 73			call write_display 
0dd4 e1				pop hl 
0dd5 c9				ret 
0dd6			 
0dd6			; TODO scrolling 
0dd6			 
0dd6			 
0dd6			; move cursor right one char 
0dd6			cursor_right: 
0dd6			 
0dd6				; TODO shift right 
0dd6				; TODO if beyond max col 
0dd6				; TODO       cursor_next_line 
0dd6			 
0dd6 c9				ret 
0dd7			 
0dd7			 
0dd7			cursor_next_line: 
0dd7				; TODO first char 
0dd7				; TODO line down 
0dd7				; TODO if past last row 
0dd7				; TODO    scroll up 
0dd7			 
0dd7 c9				ret 
0dd8			 
0dd8			cursor_left: 
0dd8				; TODO shift left 
0dd8				; TODO if beyond left  
0dd8				; TODO     cursor prev line 
0dd8				 
0dd8 c9				ret 
0dd9			 
0dd9			cursor_prev_line: 
0dd9				; TODO last char 
0dd9				; TODO line up 
0dd9				; TODO if past first row 
0dd9				; TODO   scroll down 
0dd9			 
0dd9 c9				ret 
0dda			 
0dda			 
0dda			cout: 
0dda				; A - char 
0dda c9				ret 
0ddb			 
0ddb			 
0ddb			; Display a menu and allow item selection (optional toggle items) 
0ddb			; 
0ddb			; format: 
0ddb			; hl pointer to word array with zero term for items 
0ddb			; e.g.    db item1 
0ddb			;         db .... 
0ddb			;         db 0 
0ddb			; 
0ddb			; a = starting menu item  
0ddb			; 
0ddb			; de = pointer item toggle array   (todo) 
0ddb			; 
0ddb			; returns item selected in a 1-... 
0ddb			; returns 0 if back button pressed 
0ddb			; 
0ddb			; NOTE: Uses system frame buffer to display 
0ddb			; 
0ddb			; LEFT, Q = go back 
0ddb			; RIGHT, SPACE, CR = select 
0ddb			; UP, A - Up 
0ddb			; DOWN, Z - Down 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			menu: 
0ddb			 
0ddb					; keep array pointer 
0ddb			 
0ddb 22 a8 f9				ld (store_tmp1), hl 
0dde 32 a6 f9				ld (store_tmp2), a 
0de1			 
0de1					; check for key bounce 
0de1			 
0de1			if BASE_KEV 
0de1			 
0de1 cd 56 76		.mbounce:	call cin 
0de4 fe 00				cp 0 
0de6 20 f9				jr nz, .mbounce 
0de8			endif 
0de8					; for ease use ex 
0de8			 
0de8					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0de8 21 e6 fc				ld hl, display_fb0 
0deb 22 01 fb				ld (display_fb_active), hl 
0dee			 
0dee cd aa 0d		.mloop:		call clear_display 
0df1 cd cd 0d				call update_display 
0df4			 
0df4					; draw selection id '>' at 1 
0df4			 
0df4					; init start of list display 
0df4			 
0df4 3e 05				ld a, 5 
0df6 32 a4 f9				ld (store_tmp3), a   ; display row count 
0df9 3a a6 f9				ld a,( store_tmp2) 
0dfc 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0dff			 
0dff					 
0dff			.mitem:	 
0dff			 
0dff			 
0dff 3a a7 f9				ld a,(store_tmp2+1) 
0e02 6f					ld l, a 
0e03 26 00				ld h, 0 
0e05 29					add hl, hl 
0e06 ed 5b a8 f9			ld de, (store_tmp1) 
0e0a 19					add hl, de 
0e0b 7e					ld a, (hl) 
0e0c 23					inc hl 
0e0d 66					ld h,(hl) 
0e0e 6f					ld l, a 
0e0f			 
0e0f cd 07 10				call ishlzero 
0e12 28 1a				jr z, .mdone 
0e14			 
0e14 eb					ex de, hl 
0e15 3a a4 f9				ld a, (store_tmp3) 
0e18 cd bd 0d				call str_at_display 
0e1b					 
0e1b			 
0e1b					; next item 
0e1b 3a a7 f9				ld a, (store_tmp2+1) 
0e1e 3c					inc a 
0e1f 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0e22			 
0e22			 		; next row 
0e22			 
0e22 3a a4 f9				ld a, (store_tmp3) 
0e25 c6 28				add display_cols 
0e27 32 a4 f9				ld (store_tmp3), a 
0e2a			 
0e2a					; at end of screen? 
0e2a			 
0e2a fe 10				cp display_rows*4 
0e2c 20 d1				jr nz, .mitem 
0e2e			 
0e2e			 
0e2e			.mdone: 
0e2e cd 07 10				call ishlzero 
0e31 28 08				jr z, .nodn 
0e33			 
0e33 3e 78				ld a, display_row_4 
0e35 11 b4 0e				ld de, .mdown 
0e38 cd bd 0d				call str_at_display 
0e3b			 
0e3b					; draw options to fill the screens with active item on line 1 
0e3b					; if current option is 2 or more then display ^ in top 
0e3b			 
0e3b 3a a6 f9		.nodn:		ld a, (store_tmp2) 
0e3e fe 00				cp 0 
0e40 28 08				jr z, .noup 
0e42			 
0e42 3e 00				ld a, 0 
0e44 11 b2 0e				ld de, .mup 
0e47 cd bd 0d				call str_at_display 
0e4a			 
0e4a 3e 02		.noup:		ld a, 2 
0e4c 11 b0 0e				ld de, .msel 
0e4f cd bd 0d				call str_at_display 
0e52			 
0e52					; if current option + 1 is not null then display V in bottom 
0e52					; get key 
0e52 cd cd 0d				call update_display 
0e55			 
0e55			 
0e55					; handle key 
0e55			 
0e55 cd 45 76				call cin_wait 
0e58			 
0e58 fe 05				cp KEY_UP 
0e5a 28 2b				jr z, .mgoup 
0e5c fe 61				cp 'a' 
0e5e 28 27				jr z, .mgoup 
0e60 fe 0a				cp KEY_DOWN 
0e62 28 32				jr z, .mgod 
0e64 fe 7a				cp 'z' 
0e66 28 2e				jr z, .mgod 
0e68 fe 20				cp ' ' 
0e6a 28 34				jr z, .goend 
0e6c fe 0c				cp KEY_RIGHT 
0e6e 28 30				jr z, .goend 
0e70 fe 0d				cp KEY_CR 
0e72 28 2c				jr z, .goend 
0e74 fe 71				cp 'q' 
0e76 28 0b				jr z, .goback 
0e78			 
0e78 fe 0b				cp KEY_LEFT 
0e7a 28 07				jr z, .goback 
0e7c fe 08				cp KEY_BS 
0e7e 28 03				jr z, .goback 
0e80 c3 ee 0d				jp .mloop 
0e83			 
0e83			.goback: 
0e83 3e 00			ld a, 0 
0e85 18 1d			jr .goend2 
0e87			 
0e87				; move up one 
0e87			.mgoup: 
0e87 3a a6 f9				ld a, (store_tmp2) 
0e8a fe 00				cp 0 
0e8c ca ee 0d				jp z, .mloop 
0e8f 3d					dec a 
0e90 32 a6 f9				ld (store_tmp2), a 
0e93 c3 ee 0d				jp .mloop 
0e96			 
0e96				; move down one 
0e96			.mgod: 
0e96 3a a6 f9				ld a, (store_tmp2) 
0e99 3c					inc a 
0e9a 32 a6 f9				ld (store_tmp2), a 
0e9d c3 ee 0d				jp .mloop 
0ea0			 
0ea0			 
0ea0			.goend: 
0ea0					; get selected item number 
0ea0			 
0ea0 3a a6 f9				ld a, (store_tmp2) 
0ea3 3c					inc a 
0ea4			 
0ea4			.goend2: 
0ea4 f5					push af 
0ea5			 
0ea5					; restore active fb 
0ea5					; TODO BUG assumes fb1 
0ea5			 
0ea5 21 45 fc				ld hl, display_fb1 
0ea8 22 01 fb				ld (display_fb_active), hl 
0eab			 
0eab					; restore main regs 
0eab			 
0eab			 
0eab cd cd 0d				call update_display 
0eae			 
0eae f1					pop af 
0eaf			 
0eaf c9				ret 
0eb0			 
0eb0 .. 00		.msel:   db ">",0 
0eb2 .. 00		.mup:   db "^",0 
0eb4 .. 00		.mdown:   db "v",0 
0eb6			 
0eb6			 
0eb6			; eof 
0eb6			 
# End of file firmware_display.asm
0eb6			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0eb6			; random number generators 
0eb6			 
0eb6			 
0eb6			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0eb6			 
0eb6			 
0eb6			;-----> Generate a random number 
0eb6			; output a=answer 0<=a<=255 
0eb6			; all registers are preserved except: af 
0eb6			random: 
0eb6 e5			        push    hl 
0eb7 d5			        push    de 
0eb8 2a e0 fa		        ld      hl,(randData) 
0ebb ed 5f		        ld      a,r 
0ebd 57			        ld      d,a 
0ebe 5e			        ld      e,(hl) 
0ebf 19			        add     hl,de 
0ec0 85			        add     a,l 
0ec1 ac			        xor     h 
0ec2 22 e0 fa		        ld      (randData),hl 
0ec5 d1			        pop     de 
0ec6 e1			        pop     hl 
0ec7 c9			        ret 
0ec8			 
0ec8			 
0ec8			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ec8			 
0ec8			 
0ec8			 
0ec8			;------LFSR------ 
0ec8			;James Montelongo 
0ec8			;optimized by Spencer Putt 
0ec8			;out: 
0ec8			; a = 8 bit random number 
0ec8			RandLFSR: 
0ec8 21 e6 fa		        ld hl,LFSRSeed+4 
0ecb 5e			        ld e,(hl) 
0ecc 23			        inc hl 
0ecd 56			        ld d,(hl) 
0ece 23			        inc hl 
0ecf 4e			        ld c,(hl) 
0ed0 23			        inc hl 
0ed1 7e			        ld a,(hl) 
0ed2 47			        ld b,a 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 cb 13		        rl e  
0ee3 cb 12			rl d 
0ee5 cb 11		        rl c  
0ee7 17				rla 
0ee8 67			        ld h,a 
0ee9 cb 13		        rl e  
0eeb cb 12			rl d 
0eed cb 11		        rl c  
0eef 17				rla 
0ef0 a8			        xor b 
0ef1 cb 13		        rl e  
0ef3 cb 12			rl d 
0ef5 ac			        xor h 
0ef6 a9			        xor c 
0ef7 aa			        xor d 
0ef8 21 e8 fa		        ld hl,LFSRSeed+6 
0efb 11 e9 fa		        ld de,LFSRSeed+7 
0efe 01 07 00		        ld bc,7 
0f01 ed b8		        lddr 
0f03 12			        ld (de),a 
0f04 c9			        ret 
0f05			 
0f05			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0f05			 
0f05			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0f05			 
0f05			 
0f05			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0f05			 
0f05			prng16: 
0f05			;Inputs: 
0f05			;   (seed1) contains a 16-bit seed value 
0f05			;   (seed2) contains a NON-ZERO 16-bit seed value 
0f05			;Outputs: 
0f05			;   HL is the result 
0f05			;   BC is the result of the LCG, so not that great of quality 
0f05			;   DE is preserved 
0f05			;Destroys: 
0f05			;   AF 
0f05			;cycle: 4,294,901,760 (almost 4.3 billion) 
0f05			;160cc 
0f05			;26 bytes 
0f05 2a da fa		    ld hl,(seed1) 
0f08 44			    ld b,h 
0f09 4d			    ld c,l 
0f0a 29			    add hl,hl 
0f0b 29			    add hl,hl 
0f0c 2c			    inc l 
0f0d 09			    add hl,bc 
0f0e 22 da fa		    ld (seed1),hl 
0f11 2a d8 fa		    ld hl,(seed2) 
0f14 29			    add hl,hl 
0f15 9f			    sbc a,a 
0f16 e6 2d		    and %00101101 
0f18 ad			    xor l 
0f19 6f			    ld l,a 
0f1a 22 d8 fa		    ld (seed2),hl 
0f1d 09			    add hl,bc 
0f1e c9			    ret 
0f1f			 
0f1f			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f1f			 
0f1f			rand32: 
0f1f			;Inputs: 
0f1f			;   (seed1_0) holds the lower 16 bits of the first seed 
0f1f			;   (seed1_1) holds the upper 16 bits of the first seed 
0f1f			;   (seed2_0) holds the lower 16 bits of the second seed 
0f1f			;   (seed2_1) holds the upper 16 bits of the second seed 
0f1f			;   **NOTE: seed2 must be non-zero 
0f1f			;Outputs: 
0f1f			;   HL is the result 
0f1f			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f1f			;Destroys: 
0f1f			;   AF 
0f1f			;Tested and passes all CAcert tests 
0f1f			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f1f			;it has a period of 18,446,744,069,414,584,320 
0f1f			;roughly 18.4 quintillion. 
0f1f			;LFSR taps: 0,2,6,7  = 11000101 
0f1f			;291cc 
0f1f			;seed1_0=$+1 
0f1f			;    ld hl,12345 
0f1f			;seed1_1=$+1 
0f1f			;    ld de,6789 
0f1f			;    ld b,h 
0f1f			;    ld c,l 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    inc l 
0f1f			;    add hl,bc 
0f1f			;    ld (seed1_0),hl 
0f1f			;    ld hl,(seed1_1) 
0f1f			;    adc hl,de 
0f1f			;    ld (seed1_1),hl 
0f1f			;    ex de,hl 
0f1f			;seed2_0=$+1 
0f1f			;    ld hl,9876 
0f1f			;seed2_1=$+1 
0f1f			;    ld bc,54321 
0f1f			;    add hl,hl \ rl c \ rl b 
0f1f			;    ld (seed2_1),bc 
0f1f			;    sbc a,a 
0f1f			;    and %11000101 
0f1f			;    xor l 
0f1f			;    ld l,a 
0f1f			;    ld (seed2_0),hl 
0f1f			;    ex de,hl 
0f1f			;    add hl,bc 
0f1f			;    ret 
0f1f			; 
0f1f			 
0f1f			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f1f			; 20 bytes, 86 cycles (excluding ret) 
0f1f			 
0f1f			; returns   hl = pseudorandom number 
0f1f			; corrupts   a 
0f1f			 
0f1f			; generates 16-bit pseudorandom numbers with a period of 65535 
0f1f			; using the xorshift method: 
0f1f			 
0f1f			; hl ^= hl << 7 
0f1f			; hl ^= hl >> 9 
0f1f			; hl ^= hl << 8 
0f1f			 
0f1f			; some alternative shift triplets which also perform well are: 
0f1f			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f1f			 
0f1f			;  org 32768 
0f1f			 
0f1f			xrnd: 
0f1f 2a de fa		  ld hl,(xrandc)       ; seed must not be 0 
0f22 3e 00		  ld a,0 
0f24 bd			  cp l 
0f25 20 02		  jr nz, .xrnd1 
0f27 2e 01		  ld l, 1 
0f29			.xrnd1: 
0f29			 
0f29 7c			  ld a,h 
0f2a 1f			  rra 
0f2b 7d			  ld a,l 
0f2c 1f			  rra 
0f2d ac			  xor h 
0f2e 67			  ld h,a 
0f2f 7d			  ld a,l 
0f30 1f			  rra 
0f31 7c			  ld a,h 
0f32 1f			  rra 
0f33 ad			  xor l 
0f34 6f			  ld l,a 
0f35 ac			  xor h 
0f36 67			  ld h,a 
0f37			 
0f37 22 de fa		  ld (xrandc),hl 
0f3a			 
0f3a c9			  ret 
0f3b			;  
0f3b			 
0f3b			 
0f3b			;;;; int maths 
0f3b			 
0f3b			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f3b			; Divide 16-bit values (with 16-bit result) 
0f3b			; In: Divide BC by divider DE 
0f3b			; Out: BC = result, HL = rest 
0f3b			; 
0f3b			Div16: 
0f3b 21 00 00		    ld hl,0 
0f3e 78			    ld a,b 
0f3f 06 08		    ld b,8 
0f41			Div16_Loop1: 
0f41 17			    rla 
0f42 ed 6a		    adc hl,hl 
0f44 ed 52		    sbc hl,de 
0f46 30 01		    jr nc,Div16_NoAdd1 
0f48 19			    add hl,de 
0f49			Div16_NoAdd1: 
0f49 10 f6		    djnz Div16_Loop1 
0f4b 17			    rla 
0f4c 2f			    cpl 
0f4d 47			    ld b,a 
0f4e 79			    ld a,c 
0f4f 48			    ld c,b 
0f50 06 08		    ld b,8 
0f52			Div16_Loop2: 
0f52 17			    rla 
0f53 ed 6a		    adc hl,hl 
0f55 ed 52		    sbc hl,de 
0f57 30 01		    jr nc,Div16_NoAdd2 
0f59 19			    add hl,de 
0f5a			Div16_NoAdd2: 
0f5a 10 f6		    djnz Div16_Loop2 
0f5c 17			    rla 
0f5d 2f			    cpl 
0f5e 41			    ld b,c 
0f5f 4f			    ld c,a 
0f60 c9			ret 
0f61			 
0f61			 
0f61			;http://z80-heaven.wikidot.com/math 
0f61			; 
0f61			;Inputs: 
0f61			;     DE and A are factors 
0f61			;Outputs: 
0f61			;     A is not changed 
0f61			;     B is 0 
0f61			;     C is not changed 
0f61			;     DE is not changed 
0f61			;     HL is the product 
0f61			;Time: 
0f61			;     342+6x 
0f61			; 
0f61			Mult16: 
0f61			 
0f61 06 08		     ld b,8          ;7           7 
0f63 21 00 00		     ld hl,0         ;10         10 
0f66 29			       add hl,hl     ;11*8       88 
0f67 07			       rlca          ;4*8        32 
0f68 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f6a 19			         add hl,de   ;--         -- 
0f6b 10 f9		       djnz $-5      ;13*7+8     99 
0f6d c9			ret 
0f6e			 
0f6e			; 
0f6e			; Square root of 16-bit value 
0f6e			; In:  HL = value 
0f6e			; Out:  D = result (rounded down) 
0f6e			; 
0f6e			;Sqr16: 
0f6e			;    ld de,#0040 
0f6e			;    ld a,l 
0f6e			;    ld l,h 
0f6e			;    ld h,d 
0f6e			;    or a 
0f6e			;    ld b,8 
0f6e			;Sqr16_Loop: 
0f6e			;    sbc hl,de 
0f6e			;    jr nc,Sqr16_Skip 
0f6e			;    add hl,de 
0f6e			;Sqr16_Skip: 
0f6e			;    ccf 
0f6e			;    rl d 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    djnz Sqr16_Loop 
0f6e			;    ret 
0f6e			; 
0f6e			; 
0f6e			; Divide 8-bit values 
0f6e			; In: Divide E by divider C 
0f6e			; Out: A = result, B = rest 
0f6e			; 
0f6e			Div8: 
0f6e af			    xor a 
0f6f 06 08		    ld b,8 
0f71			Div8_Loop: 
0f71 cb 13		    rl e 
0f73 17			    rla 
0f74 91			    sub c 
0f75 30 01		    jr nc,Div8_NoAdd 
0f77 81			    add a,c 
0f78			Div8_NoAdd: 
0f78 10 f7		    djnz Div8_Loop 
0f7a 47			    ld b,a 
0f7b 7b			    ld a,e 
0f7c 17			    rla 
0f7d 2f			    cpl 
0f7e c9			    ret 
0f7f			 
0f7f			; 
0f7f			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f7f			; In: Multiply A with DE 
0f7f			; Out: HL = result 
0f7f			; 
0f7f			Mult12U: 
0f7f 2e 00		    ld l,0 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd0 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd0: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd1 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd1: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd2 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd2: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd3 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd3: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 30 01		    jr nc,Mult12U_NoAdd4 
0f98 19			    add hl,de 
0f99			Mult12U_NoAdd4: 
0f99 29			    add hl,hl 
0f9a 87			    add a,a 
0f9b 30 01		    jr nc,Mult12U_NoAdd5 
0f9d 19			    add hl,de 
0f9e			Mult12U_NoAdd5: 
0f9e 29			    add hl,hl 
0f9f 87			    add a,a 
0fa0 30 01		    jr nc,Mult12U_NoAdd6 
0fa2 19			    add hl,de 
0fa3			Mult12U_NoAdd6: 
0fa3 29			    add hl,hl 
0fa4 87			    add a,a 
0fa5 d0			    ret nc 
0fa6 19			    add hl,de 
0fa7 c9			    ret 
0fa8			 
0fa8			; 
0fa8			; Multiply 8-bit value with a 16-bit value (right rotating) 
0fa8			; In: Multiply A with DE 
0fa8			;      Put lowest value in A for most efficient calculation 
0fa8			; Out: HL = result 
0fa8			; 
0fa8			Mult12R: 
0fa8 21 00 00		    ld hl,0 
0fab			Mult12R_Loop: 
0fab cb 3f		    srl a 
0fad 30 01		    jr nc,Mult12R_NoAdd 
0faf 19			    add hl,de 
0fb0			Mult12R_NoAdd: 
0fb0 cb 23		    sla e 
0fb2 cb 12		    rl d 
0fb4 b7			    or a 
0fb5 c2 ab 0f		    jp nz,Mult12R_Loop 
0fb8 c9			    ret 
0fb9			 
0fb9			; 
0fb9			; Multiply 16-bit values (with 32-bit result) 
0fb9			; In: Multiply BC with DE 
0fb9			; Out: BCHL = result 
0fb9			; 
0fb9			Mult32: 
0fb9 79			    ld a,c 
0fba 48			    ld c,b 
0fbb 21 00 00		    ld hl,0 
0fbe 06 10		    ld b,16 
0fc0			Mult32_Loop: 
0fc0 29			    add hl,hl 
0fc1 17			    rla 
0fc2 cb 11		    rl c 
0fc4 30 07		    jr nc,Mult32_NoAdd 
0fc6 19			    add hl,de 
0fc7 ce 00		    adc a,0 
0fc9 d2 cd 0f		    jp nc,Mult32_NoAdd 
0fcc 0c			    inc c 
0fcd			Mult32_NoAdd: 
0fcd 10 f1		    djnz Mult32_Loop 
0fcf 41			    ld b,c 
0fd0 4f			    ld c,a 
0fd1 c9			    ret 
0fd2			 
0fd2			 
0fd2			 
0fd2			; 
0fd2			; Multiply 8-bit values 
0fd2			; In:  Multiply H with E 
0fd2			; Out: HL = result 
0fd2			; 
0fd2			Mult8: 
0fd2 16 00		    ld d,0 
0fd4 6a			    ld l,d 
0fd5 06 08		    ld b,8 
0fd7			Mult8_Loop: 
0fd7 29			    add hl,hl 
0fd8 30 01		    jr nc,Mult8_NoAdd 
0fda 19			    add hl,de 
0fdb			Mult8_NoAdd: 
0fdb 10 fa		    djnz Mult8_Loop 
0fdd c9			    ret 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			;;http://z80-heaven.wikidot.com/math 
0fde			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fde			; 
0fde			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fde			;     ld a,16        ;7 
0fde			;     ld hl,0        ;10 
0fde			;     jp $+5         ;10 
0fde			;.DivLoop: 
0fde			;       add hl,bc    ;-- 
0fde			;       dec a        ;64 
0fde			;       jr z,.DivLoopEnd        ;86 
0fde			; 
0fde			;       sla e        ;128 
0fde			;       rl d         ;128 
0fde			;       adc hl,hl    ;240 
0fde			;       sbc hl,bc    ;240 
0fde			;       jr nc,.DivLoop ;23|21 
0fde			;       inc e        ;-- 
0fde			;       jp .DivLoop+1 
0fde			; 
0fde			;.DivLoopEnd: 
0fde			 
0fde			;HL_Div_C: 
0fde			;Inputs: 
0fde			;     HL is the numerator 
0fde			;     C is the denominator 
0fde			;Outputs: 
0fde			;     A is the remainder 
0fde			;     B is 0 
0fde			;     C is not changed 
0fde			;     DE is not changed 
0fde			;     HL is the quotient 
0fde			; 
0fde			;       ld b,16 
0fde			;       xor a 
0fde			;         add hl,hl 
0fde			;         rla 
0fde			;         cp c 
0fde			;         jr c,$+4 
0fde			;           inc l 
0fde			;           sub c 
0fde			;         djnz $-7 
0fde			 
0fde			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fde			 
0fde			addatohl: 
0fde 85			    add   a, l    ; A = A+L 
0fdf 6f			    ld    l, a    ; L = A+L 
0fe0 8c			    adc   a, h    ; A = A+L+H+carry 
0fe1 95			    sub   l       ; A = H+carry 
0fe2 67			    ld    h, a    ; H = H+carry 
0fe3 c9			ret 
0fe4			 
0fe4			addatode: 
0fe4 83			    add   a, e    ; A = A+L 
0fe5 5f			    ld    e, a    ; L = A+L 
0fe6 8a			    adc   a, d    ; A = A+L+H+carry 
0fe7 93			    sub   e       ; A = H+carry 
0fe8 57			    ld    d, a    ; H = H+carry 
0fe9 c9			ret 
0fea			 
0fea			 
0fea			addatobc: 
0fea 81			    add   a, c    ; A = A+L 
0feb 4f			    ld    c, a    ; L = A+L 
0fec 88			    adc   a, b    ; A = A+L+H+carry 
0fed 91			    sub   c       ; A = H+carry 
0fee 47			    ld    b, a    ; H = H+carry 
0fef c9			ret 
0ff0			 
0ff0			subafromhl: 
0ff0			   ; If A=0 do nothing 
0ff0			    ; Otherwise flip A's sign. Since 
0ff0			    ; the upper byte becomes -1, also 
0ff0			    ; substract 1 from H. 
0ff0 ed 44		    neg 
0ff2 ca fb 0f		    jp    z, Skip 
0ff5 25			    dec   h 
0ff6			     
0ff6			    ; Now add the low byte as usual 
0ff6			    ; Two's complement takes care of 
0ff6			    ; ensuring the result is correct 
0ff6 85			    add   a, l 
0ff7 6f			    ld    l, a 
0ff8 8c			    adc   a, h 
0ff9 95			    sub   l 
0ffa 67			    ld    h, a 
0ffb			Skip: 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			; compare hl and de 
0ffc			; returns:  
0ffc			; if hl = de, z=1, s=0, c0=0 
0ffc			; if hl > de, z=0, s=0, c=0 
0ffc			; if hl < de, z=0, s=1, c=1 
0ffc			cmp16:	 
0ffc b7				or a 
0ffd ed 52			sbc hl,de 
0fff e0				ret po 
1000 7c				ld a,h 
1001 1f				rra 
1002 ee 40			xor 01000000B 
1004 37				scf 
1005 8f				adc a,a 
1006 c9				ret 
1007			 
1007			 
1007			; test if hl contains zero   - A is destroyed 
1007			 
1007			ishlzero:    
1007 b7				or a     ; reset flags 
1008 7c				ld a, h 
1009 b5				or l        	 
100a			 
100a c9				ret 
100b			 
100b			 
100b			 
100b			 
100b			if FORTH_ENABLE_FLOATMATH 
100b			;include "float/bbcmath.z80" 
100b			include "float/lpfpcalc.asm" 
100b			endif 
100b			 
100b			 
100b			; eof 
100b			 
# End of file firmware_maths.asm
100b			include "firmware_strings.asm"   ; string handling  
100b			 
100b			 
100b			; TODO string len 
100b			; input text string, end on cr with zero term 
100b			; a offset into frame buffer to start prompt 
100b			; d is max length 
100b			; e is display size TODO 
100b			; c is current cursor position 
100b			; hl is ptr to where string will be stored and edited directly 
100b			 
100b			 
100b			; TODO check limit of buffer for new inserts 
100b			; TODO check insert does not push beyond buffer 
100b			; TODO scroll in a limited display area 
100b			; TODO scroll whole screen on page wrap 
100b			 
100b			 
100b			; TODO use LCD cursor? 
100b			 
100b			EDIT_V1: equ 0 
100b			EDIT_V2: equ 1 
100b			 
100b			 
100b			 
100b			if EDIT_V2 
100b			input_str: 
100b			 
100b 32 99 fd			    	ld (input_at_pos),a      ; save display position to start 
100e			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
100e 22 9c fd				ld (input_start), hl     ; save ptr to buffer 
1011			;		ld a, c 
1011			;		call addatohl 
1011			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1011 7a					ld a,d 
1012 32 9b fd			        ld (input_size), a       ; save length of input area 
1015 79					ld a, c 
1016 32 8a fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
1019 7b					ld a,e 
101a 32 9a fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101d			 
101d			 
101d					; add a trailing space to make screen refresh nicer 
101d			 
101d					;ld hl, (input_start) 
101d					;push hl 
101d					;ld a, 0 
101d					;call strlent 
101d					;ld a, l 
101d					;pop hl 
101d					;call addatohl 
101d					;dec hl 
101d					;ld a, ' ' 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld a, 0 
101d					;ld (hl), a 
101d			 
101d			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101d					; init cursor shape if not set by the cin routines 
101d 21 f6 fa				ld hl, cursor_shape 
1020			if BASE_KEV 
1020 3e ff				ld a, 255 
1022			else 
1022					ld a, '#' 
1022			endif 
1022 77					ld (hl), a 
1023 23					inc hl 
1024 3e 00				ld a, 0 
1026 77					ld (hl), a 
1027			 
1027 3e 09				ld a, CUR_BLINK_RATE 
1029 32 95 fd				ld (input_cur_flash), a 
102c 3e 01				ld a, 1 
102e 32 94 fd				ld (input_cur_onoff),a 
1031			.inmain:	 
1031			 
1031 cd 59 11				call input_disp_ref 
1034			 
1034					; save current length of string 
1034			 
1034 2a 9c fd				ld hl, (input_start) 
1037 3e 00				ld a, 0 
1039 cd 4f 13				call strlent 
103c 7d					ld a,l 
103d 32 8f fd				ld (input_len), a 
1040			 
1040					;call input_disp_oncur 
1040			 
1040					; display current state of input buffer 
1040			 
1040					; clean any backspace chars 
1040			 
1040 3e 20				ld a, " " 
1042 32 f6 f0				ld (scratch),a 
1045 3e 00				ld a, 0 
1047 32 f7 f0				ld (scratch+1),a 
104a 3a 99 fd				ld a,(input_at_pos) 
104d 85					add l 
104e 11 f6 f0				ld de, scratch 
1051 cd bd 0d				call str_at_display 
1054			 
1054					; pause 1ms 
1054			 
1054 3e 01				ld a, 1 
1056 cd d2 0c				call aDelayInMS 
1059			 
1059			; display cursor if visible on this cycle 
1059			 
1059					; dec flash counter 
1059 3a 95 fd				ld a, (input_cur_flash) 
105c 3d					dec a 
105d 32 95 fd				ld (input_cur_flash), a 
1060 fe 00				cp 0 
1062 20 0d				jr nz, .inochgstate 
1064			 
1064			 
1064					; reset on change of state 
1064 3e 09				ld a, CUR_BLINK_RATE 
1066 32 95 fd				ld (input_cur_flash), a 
1069			 
1069					; change state 
1069 3a 94 fd				ld a,(input_cur_onoff) 
106c ed 44				neg 
106e 32 94 fd				ld (input_cur_onoff),a 
1071			 
1071			 
1071			 
1071			 
1071					; TODO is cursor visible? 
1071					; TODO if so then over write the char at curspos pos with the cursor shape 
1071			 
1071								 
1071			 
1071			.inochgstate: 
1071 3a 94 fd				ld a,(input_cur_onoff) 
1074 fe ff				cp 255 
1076 28 0e				jr z, .skipcursor 
1078 3a 99 fd				ld a, (input_at_pos) 
107b 47					ld b, a 
107c 3a 8a fd				ld a, (input_cursor) 
107f 80					add b 
1080 11 f6 fa				ld de, cursor_shape 
1083					 
1083 cd bd 0d				call str_at_display 
1086			 
1086			.skipcursor: 
1086				if DEBUG_INPUTV2 
1086			 
1086					ld a,(input_at_pos) 
1086					ld hl, LFSRSeed 
1086					call hexout 
1086					ld a, (input_cursor) 
1086					ld hl, LFSRSeed+2 
1086					call hexout 
1086					ld a,(input_size) 
1086					ld hl, LFSRSeed+4 
1086					call hexout 
1086			 
1086					ld a,(input_cur_onoff) 
1086					ld hl, LFSRSeed+6 
1086					call hexout 
1086			 
1086					ld a,(input_cur_flash) 
1086					ld hl, LFSRSeed+8 
1086					call hexout 
1086			 
1086					ld a,(input_len) 
1086					ld hl, LFSRSeed+10 
1086					call hexout 
1086					ld hl, LFSRSeed+12 
1086					ld a, 0 
1086					ld (hl),a 
1086					ld a, display_row_4 
1086					ld de, LFSRSeed 
1086					call str_at_display 
1086				endif 
1086 cd cd 0d				call update_display 
1089			 
1089					; TODO keyboard processing 
1089			 
1089			if BASE_CPM 
1089					call cin_wait 
1089			else 
1089 cd 56 76				call cin    ; _wait 
108c			endif 
108c fe 00				cp 0 
108e ca 31 10				jp z, .inmain 
1091			 
1091 fe 0b				cp KEY_LEFT    ; cursor left 
1093 ca 4b 11				jp z, input_left 
1096				 
1096 fe 0c				cp KEY_RIGHT      ; cursor right 
1098 ca 52 11				jp z, input_right 
109b			 
109b fe 0d				cp KEY_CR 
109d c8					ret z 
109e			 
109e fe 08				cp KEY_BS 
10a0 ca c0 11				jp z, input_delchar 
10a3			 
10a3 fe 06				cp KEY_NEXTWORD 
10a5 ca cc 10				jp z, input_nxtword 
10a8			 
10a8 fe 07				cp KEY_PREVWORD 
10aa ca f3 10				jp z, input_prvword 
10ad			 
10ad fe 0e				cp KEY_HOME    ; jump to start of line 
10af 20 08				jr nz, .ikh 
10b1 3e 00				ld a, 0 
10b3 32 8a fd				ld (input_cursor), a 
10b6 ca 31 10				jp z, .inmain 
10b9			.ikh: 
10b9			 
10b9 fe 0f				cp KEY_END     ; jump to end of line 
10bb 20 09				jr nz, .ike 
10bd 3a 8f fd				ld a, (input_len) 
10c0 32 8a fd				ld (input_cursor),a 
10c3 ca 31 10				jp z, .inmain 
10c6			.ike: 
10c6 fe 05			        cp KEY_UP      ; recall last command 
10c8 c8					ret z 
10c9			;jr nz, .irec 
10c9			; TODO next word 
10c9			; TODO prev word 
10c9			;  
10c9			; 
10c9			;	ld hl, scratch 
10c9			;	ld de, os_last_cmd 
10c9			;	call strcpy 
10c9			;		jp  .inmain 
10c9			.irec: 
10c9			;		jr .instr1 
10c9			 
10c9			 
10c9			 
10c9					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
10c9			 
10c9			; TODO return if any special keys are given 
10c9			;		ld l, a 
10c9			;		ld a, 28 ; KEY_F12   ; 27 
10c9			;		sub l 
10c9			;		ret m 
10c9			;		ld a, l 
10c9					; if no special key then insert as a char 
10c9			 
10c9 c3 92 11				jp input_inschr 
10cc			 
10cc				 
10cc			input_nxtword: 
10cc				; jump to start next word after the cursor 
10cc			 
10cc			.insknwn:	 
10cc cd 88 11				call input_curptr	 
10cf 7e					ld a,(hl)	 
10d0 fe 00				cp 0 
10d2 ca 31 10				jp z, .inmain    ; end of string 
10d5			 
10d5			; if we are on a word, then move off of it 
10d5			 
10d5 fe 20				cp ' ' 
10d7 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10d9 21 8a fd				ld hl, input_cursor 
10dc 34					inc (hl) 
10dd 18 ed				jr .insknwn 
10df			 
10df			.inspace: 
10df			 
10df cd 88 11				call input_curptr	 
10e2 7e					ld a,(hl)	 
10e3 fe 00				cp 0 
10e5 ca 31 10				jp z, .inmain    ; end of string 
10e8			 
10e8			; if we are on a word, then move off of it 
10e8			 
10e8 fe 20				cp ' ' 
10ea c2 31 10				jp nz, .inmain     ; we are on non space so at next word 
10ed 21 8a fd				ld hl, input_cursor 
10f0 34					inc (hl) 
10f1 18 ec				jr .inspace 
10f3			 
10f3			 
10f3			 
10f3			 
10f3			input_prvword: 
10f3				; jump to the start of previous word before the cursor 
10f3			 
10f3			; where are we to start with currently? 
10f3			 
10f3 cd 88 11				call input_curptr	 
10f6 7e					ld a, (hl) 
10f7 fe 20				cp ' ' 
10f9 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10fb			 
10fb			 
10fb			 
10fb			.inskpwn:	 
10fb 3a 8a fd				ld a,(input_cursor) 
10fe fe 00				cp 0 
1100 ca 31 10				jp z, .inmain    ; start of string 
1103			 
1103			;if we are on a word, then move off of it 
1103			 
1103 cd 88 11				call input_curptr	 
1106 7e					ld a, (hl) 
1107 fe 20				cp ' ' 
1109 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
110b					;jp z, .inmain    ; start of string 
110b 21 8a fd				ld hl, input_cursor 
110e 35					dec (hl) 
110f 18 ea				jr .inskpwn 
1111			.iwstart: 
1111 21 8a fd				ld hl, input_cursor 
1114 34					inc (hl) 
1115 c3 31 10				jp .inmain 
1118					 
1118			 
1118			.inspacep: 
1118			 
1118					;jp .inmain    ; start of string 
1118			 
1118			 
1118			 
1118 3a 8a fd				ld a,(input_cursor) 
111b fe 00				cp 0 
111d ca 31 10				jp z, .inmain    ; start of string 
1120			 
1120			; if we are on a word, then move off of it 
1120			 
1120 cd 88 11				call input_curptr	 
1123 7e					ld a, (hl) 
1124 fe 20				cp ' ' 
1126 c2 2f 11				jp nz, .incharp     ; we are on non space so at end of prev word 
1129 21 8a fd				ld hl, input_cursor 
112c 35					dec (hl) 
112d 18 e9				jr .inspacep 
112f			 
112f			 
112f			.incharp:	 
112f					; eat the word to get to the start 
112f 3a 8a fd				ld a,(input_cursor) 
1132 fe 00				cp 0 
1134 ca 31 10				jp z, .inmain    ; start of string 
1137			 
1137			; if we are on a word, then move off of it 
1137			 
1137 cd 88 11				call input_curptr	 
113a 7e					ld a, (hl) 
113b fe 20				cp ' ' 
113d 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
113f 21 8a fd				ld hl, input_cursor 
1142 35					dec (hl) 
1143 18 ea				jr .incharp 
1145			.ipwordst: 
1145					; at space before the prev word so reposition over it 
1145 21 8a fd				ld hl, input_cursor 
1148 34					inc (hl) 
1149 18 b0				jr .inskpwn 
114b					 
114b			 
114b			 
114b			input_left: 
114b				; move cursor left 
114b 21 8a fd			ld hl, input_cursor 
114e 35				dec (hl) 
114f			;	cp 0 
114f			;	jp z, .inmain    ; ignore left as at the start of the string 
114f c3 31 10			jp .inmain 
1152			 
1152			input_right: 
1152				; move cursor right 
1152				 
1152				;ld a, (input_size) 
1152				;ld b, a 
1152 21 8a fd			ld hl, input_cursor 
1155 34				inc (hl) 
1156				;dec b 
1156				;cp 0 
1156				;jp z, .inmain   ; ignore as at end of the string buffer 
1156				;ld a, b 
1156				;inc a 
1156				;ld (input_cursor), a 
1156 c3 31 10			jp .inmain 
1159			 
1159			 
1159			 
1159			input_disp_ref: 
1159				; display the text from start of buffer (ie full refresh) 
1159 3a 99 fd			ld a, (input_at_pos) 
115c 2a 9c fd			ld hl,(input_start) 
115f eb				ex de, hl 
1160 cd bd 0d			call str_at_display  
1163 c9				ret 
1164			input_disp_oncur: 
1164				; display the text from cursor position to end of buffer 
1164				; TODO position start of string at cursor position on screen 
1164				; TODO draw from that point on 
1164 3a 8a fd			ld a, (input_cursor) 
1167 47				ld b, a 
1168 3a 99 fd			ld a, (input_at_pos) 
116b 80				add b 
116c 48				ld c, b     ; save a 
116d 78				ld a, b     ; inc string start for cursor 
116e 2a 9c fd			ld hl,(input_start) 
1171 cd de 0f			call addatohl 
1174 eb				ex de, hl 
1175 79				ld a, c 
1176 cd bd 0d			call str_at_display  
1179 c9				ret 
117a			 
117a			input_nxtw: 
117a				; Find next word 
117a c9				ret 
117b			 
117b			input_prvw: 
117b				; Find previous word 
117b c9				ret 
117c			 
117c			input_lenrem:   
117c				; Calculate the length of string remaining from current cursor 
117c				; position to end of buffer (exc null term) 
117c				 
117c 3a 8a fd			ld a, (input_cursor) 
117f 4f				ld c, a 
1180 3a 9b fd			ld a, (input_size) 
1183 91				sub c 
1184 06 00			ld b, 0 
1186 0d				dec c 
1187 c9				ret	 
1188			 
1188			input_curptr: 
1188				; calc address of the character under the cursor 
1188				 
1188 2a 9c fd			ld hl, (input_start) 
118b 3a 8a fd			ld a, (input_cursor) 
118e cd de 0f			call addatohl 
1191 c9				ret 
1192			 
1192			input_inschr: 
1192				; Insert char at cursor position 
1192 f5				push af   ; save char 
1193				;call input_lenrem    ; get bc length of remaining string 
1193			 
1193				 
1193 cd 88 11			call input_curptr 
1196			;	ld hl, (input_start) 
1196			;	ld a, (input_cursor) 
1196			;	call addatohl 
1196				;push hl   ; save to come back to 
1196			 
1196				; shift everything up one to end of buffer 
1196			 
1196				;push hl 
1196				;dec de 
1196				;inc de 
1196			;	ldir 
1196				 
1196				;pop hl 
1196			 
1196				; are we adding to the end of line? 
1196			 
1196 3a 8a fd			ld a, (input_cursor) 
1199 47				ld b, a 
119a 3a 8f fd			ld a, (input_len) 
119d b8				cp b 
119e 20 09			jr nz, .insmid   ; no, insert in middle of text 
11a0			 
11a0				; tack on the end of the line 
11a0 f1				pop af 
11a1 77				ld (hl), a   ; save new char 
11a2 23				inc hl 
11a3 3e 00			ld a, 0 
11a5 77				ld (hl), a 
11a6 c3 52 11			jp input_right 
11a9				 
11a9			.insmid: 
11a9				; hl has insertion point so move everything up one to allow for insertion 
11a9				;call input_shiftright 
11a9 f1				pop af 
11aa			 
11aa			.shufinsmid: 
11aa 47				ld b, a     ; b contains new char, c prev char at this position  
11ab 7e				ld a, (hl) 
11ac			 
11ac fe 00			cp 0    ; at end of string need to then dump new char and add term 
11ae 28 07			jr z, .endinsmid 
11b0 4f				ld c, a 
11b1 78				ld a, b 
11b2 77				ld (hl), a 
11b3 23				inc hl 
11b4 79				ld a, c 
11b5 18 f3			jr .shufinsmid 
11b7				 
11b7			 
11b7			 
11b7			 
11b7			.endinsmid: 
11b7 78				ld a, b 
11b8 77				ld (hl), a 
11b9 23				inc hl 
11ba 3e 00			ld a, 0 
11bc 77				ld (hl), a 
11bd			 
11bd			 
11bd			;	ld (hl), a   ; save new char 
11bd			 
11bd c3 52 11			jp input_right 
11c0			 
11c0			;input_shiftright: 
11c0			;	; shift text right at cursor, hl has shift start 
11c0			;	push hl 
11c0			;	push de 
11c0			;	push bc 
11c0			; 
11c0			; 
11c0			;	; move to end of string past zero term 
11c0			;	ld hl,(input_start) 
11c0			;	ld a, (input_len) 
11c0			;	call addatohl 
11c0			;	inc hl 
11c0			;;	inc hl 
11c0			;;	inc hl 
11c0			;	ld a, 0 
11c0			;	ld (hl), a 
11c0			;;	dec hl 
11c0			;	 
11c0			;;	ld (hl), a 
11c0			;;	dec hl 
11c0			; 
11c0			;	push hl 
11c0			;	pop de 
11c0			;	inc de 
11c0			;	 
11c0			; 
11c0			;;	ld hl,(input_start) 
11c0			;;	ld a, (input_cursor) 
11c0			;;	call addatohl 
11c0			; 
11c0			; 
11c0			;	; calc how many bytes from cursor pos to end of string we need to shift 
11c0			;	call input_lenrem    ; get bc length of remaining string 
11c0			;	;ld a, (input_cursor) 
11c0			;	;ld c, a 
11c0			;	ld a, (input_len) 
11c0			;	cp 2 
11c0			;	jr z, .iskipzero	 
11c0			;	;sub c 
11c0			;	;inc a 
11c0			;	;ld c, a 
11c0			;	;ld b, 0 
11c0			;	inc c 
11c0			;	inc c 
11c0			;	; move data 
11c0			;	lddr 
11c0			;.iskipzero: 
11c0			; 
11c0			;	pop bc 
11c0			;	pop de 
11c0			;	pop hl 
11c0			;	ret	 
11c0			 
11c0			input_delchar: 
11c0				; Delete char at cursor position 
11c0 cd 7c 11			call input_lenrem    ; get bc length of remaining string 
11c3 2a 9c fd			ld hl, (input_start) 
11c6 3a 8a fd			ld a, (input_cursor) 
11c9 cd de 0f			call addatohl 
11cc			 
11cc e5				push hl 
11cd d1				pop de 
11ce 1b				dec de 
11cf			 
11cf			.dl:	 
11cf ed a0			ldi  
11d1 7e				ld a, (hl) 
11d2 fe 00			cp 0 
11d4 28 02			jr z, .dldone 
11d6 18 f7			jr .dl 
11d8			.dldone: 
11d8 ed a0			ldi 
11da			 
11da c3 4b 11			jp input_left 
11dd			 
11dd			 
11dd			endif 
11dd			 
11dd			 
11dd			 
11dd			if EDIT_V1 
11dd			input_str: 
11dd			 
11dd				    	ld (input_at_pos),a      ; save display position to start 
11dd					add c 
11dd					ld (input_at_cursor),a	; save draw pos of cursor 
11dd					ld (input_start), hl     ; save ptr to buffer 
11dd					ld a, c 
11dd					call addatohl 
11dd					ld (input_ptr), hl     ; save ptr to point under the cursor 
11dd					ld a,d 
11dd				        ld (input_size), a       ; save length of input area 
11dd					ld a, c 
11dd					ld (input_cursor),a      ; init cursor start position  
11dd					ld a,e 
11dd				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11dd					 
11dd					 
11dd			 
11dd			;		ld a,(input_ptr) 
11dd			;		ld (input_under_cursor),a 	; save what is under the cursor 
11dd			 
11dd			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11dd					; init cursor shape if not set by the cin routines 
11dd					ld hl, cursor_shape 
11dd			if BASE_KEV 
11dd					ld a, 255 
11dd			else 
11dd					ld a, '#' 
11dd			endif 
11dd					ld (hl), a 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl), a 
11dd			 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					ld a, 1 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'I' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd			.is1:		; main entry loop 
11dd			 
11dd			 
11dd			 
11dd					; pause 1ms 
11dd			 
11dd					ld a, 1 
11dd					call aDelayInMS 
11dd			 
11dd					; dec flash counter 
11dd					ld a, (input_cur_flash) 
11dd					dec a 
11dd					ld (input_cur_flash), a 
11dd					cp 0 
11dd					jr nz, .nochgstate 
11dd			 
11dd			 
11dd					; change state 
11dd					ld a,(input_cur_onoff) 
11dd					neg 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			 
11dd					; reset on change of state 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd			.nochgstate: 
11dd					 
11dd					 
11dd			 
11dd					; display cursor  
11dd			 
11dd			;		ld hl, (input_start) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			 
11dd					; get char under cursor and replace with cursor 
11dd			ld hl, (input_ptr) 
11dd			;		ld a, (hl) 
11dd			;		ld (input_under_cursor),a 
11dd			;		ld a, '_' 
11dd			;		ld (hl), a 
11dd			 
11dd					; display string 
11dd			 
11dd					ld de, (input_start) 
11dd					ld a, (input_at_pos) 
11dd					call str_at_display 
11dd			;	        call update_display 
11dd			 
11dd					; find place to put the cursor 
11dd			;		add h 
11dd			;		ld l, display_row_1 
11dd			;		sub l 
11dd			; (input_at_pos) 
11dd					;ld c, a 
11dd			;		ld a, (input_cursor) 
11dd			;		ld l, (input_at_pos) 
11dd			;		;ld b, h 
11dd			;		add l 
11dd			;		ld (input_at_cursor),a 
11dd					;ld l,h 
11dd			 
11dd			;		ld h, 0 
11dd			;		ld l,(input_at_pos) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11dd			;		call subafromhl 
11dd			;		ld a,l 
11dd			;		ld (input_at_cursor), a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					ld a, (hardware_diag) 
11dd					cp 0 
11dd					jr z, .skip_input_diag 
11dd			 
11dd					ld a,(input_at_pos) 
11dd					ld hl, LFSRSeed 
11dd					call hexout 
11dd					ld a, (input_cursor) 
11dd					ld hl, LFSRSeed+2 
11dd					call hexout 
11dd					ld a,(input_at_cursor) 
11dd					ld hl, LFSRSeed+4 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_onoff) 
11dd					ld hl, LFSRSeed+6 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_flash) 
11dd					ld hl, LFSRSeed+8 
11dd					call hexout 
11dd			 
11dd					ld a,(input_len) 
11dd					ld hl, LFSRSeed+10 
11dd					call hexout 
11dd					ld hl, LFSRSeed+12 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd					ld a, display_row_4 
11dd					ld de, LFSRSeed 
11dd					call str_at_display 
11dd					.skip_input_diag: 
11dd				endif 
11dd			 
11dd					; decide on if we are showing the cursor this time round 
11dd			 
11dd					ld a, (input_cur_onoff) 
11dd					cp 255 
11dd					jr z, .skipcur 
11dd			 
11dd			 
11dd					ld a,(input_at_cursor) 
11dd					ld de, cursor_shape 
11dd					call str_at_display 
11dd			 
11dd					; save length of current input string 
11dd					ld hl, (input_start) 
11dd					ld a, 0 
11dd					call strlent 
11dd					ld a,l 
11dd					ld (input_len),a 
11dd			 
11dd			.skipcur: 
11dd			 
11dd				        call update_display 
11dd					 
11dd			 
11dd			 
11dd					; wait 
11dd				 
11dd					; TODO loop without wait to flash the cursor and char under cursor	 
11dd					call cin    ; _wait 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 
11dd			 
11dd					; get ptr to char to input into 
11dd			 
11dd					ld c,a 
11dd					ld hl, (input_start) 
11dd					ld a, (input_cursor) 
11dd					call addatohl 
11dd					ld (input_ptr), hl 
11dd					ld a,c 
11dd			 
11dd					; replace char under cursor 
11dd			 
11dd			;		ld hl, (input_ptr) 
11dd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11dd			;		ld (hl), a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'i' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					cp KEY_HOME 
11dd					jr nz, .iske 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor),a 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					jp .is1 
11dd					 
11dd			.iske:		cp KEY_END 
11dd					jr nz, .isknw 
11dd					jp .is1 
11dd			 
11dd			.isknw:		cp KEY_NEXTWORD 
11dd					jr nz, .iskpw 
11dd			 
11dd			.isknwm:	ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0 
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd					jr .isknwm 
11dd			 
11dd			.iskpw:		cp KEY_PREVWORD 
11dd					jr nz, .iskl 
11dd			.iskpwm:	 
11dd					ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0  
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd					jr .iskpwm 
11dd			 
11dd			 
11dd			.iskl:		cp KEY_LEFT 
11dd					jr nz, .isk1 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk1:		cp KEY_RIGHT 
11dd					jr nz, .isk2 
11dd			 
11dd					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11dd					ld e,a 
11dd					ld a, (input_cursor) 
11dd					cp e 
11dd					jp z, .is1		; at the end of string so dont go right 
11dd			 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk2:		cp KEY_UP 
11dd			 
11dd					jr nz, .isk3 
11dd			 
11dd					; swap last command with the current on 
11dd			 
11dd					; move cursor to start of string 
11dd					ld hl, (input_start) 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					 
11dd					; swap input and last command buffers 
11dd			 
11dd					ld hl, os_cli_cmd 
11dd					ld de, os_last_cmd 
11dd					ld b, 255 
11dd			.swap1:		ld a, (hl) 
11dd					ld c,a 
11dd					ld a, (de) 
11dd					ld (hl), a 
11dd					ld a,c 
11dd					ld (de),a 
11dd					inc hl 
11dd					inc de 
11dd					djnz .swap1 
11dd			 
11dd			 
11dd			 
11dd			 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk3:		cp KEY_BS 
11dd					jr nz, .isk4 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					; hl is source 
11dd					; de needs to be source - 1 
11dd			 
11dd			;		ld a, 0 
11dd			;		dec hl 
11dd			;		ld (hl), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					; shift all data 
11dd			 
11dd					push hl 
11dd					inc hl 
11dd					pop de 
11dd					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11dd					ld c,a 
11dd					ld b,0 
11dd					ldir  
11dd			 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					; remove char 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld de,.iblank 
11dd					call str_at_display 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk4:		cp KEY_CR 
11dd					jr z, .endinput 
11dd			 
11dd					; else add the key press to the end 
11dd			 
11dd					ld c, a			; save key pressed 
11dd			 
11dd					ld a,(hl)		; get what is currently under char 
11dd			 
11dd					cp 0			; we are at the end of the string 
11dd					jr nz, .onchar 
11dd					 
11dd					; add a char to the end of the string 
11dd				 
11dd					ld (hl),c 
11dd					inc hl 
11dd			;		ld a,' ' 
11dd			;		ld (hl),a 
11dd			;		inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					dec hl 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc a				; TODO check max string length and scroll  
11dd					ld (input_cursor), a		; inc cursor pos 
11dd							 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, '+' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					jp .is1 
11dd					 
11dd			 
11dd			 
11dd					; if on a char then insert 
11dd			.onchar: 
11dd			 
11dd					; TODO over flow check: make sure insert does not blow out buffer 
11dd			 
11dd					; need to do some maths to use lddr 
11dd			 
11dd					push hl   ; save char pos 
11dd					push bc 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a, (input_len) 
11dd					call addatohl  		; end of string 
11dd					inc hl 
11dd					inc hl		; past zero term 
11dd					push hl 
11dd					inc hl 
11dd					push hl  
11dd			 
11dd								; start and end of lddr set, now how much to move? 
11dd			 
11dd							 
11dd					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11dd					ld b,a 
11dd					ld a,(input_len) 
11dd					ld e,a 
11dd					sub b 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd			 
11dd					ld b,0 
11dd					ld c,a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'i' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					pop de 
11dd					pop hl 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'I' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					lddr 
11dd				 
11dd			 
11dd			 
11dd					; TODO have a key for insert/overwrite mode???? 
11dd					pop bc 
11dd					pop hl 
11dd					ld (hl), c		; otherwise overwrite current char 
11dd					 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.endinput:	; TODO look for end of string 
11dd			 
11dd					; add trailing space for end of token 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a,(input_len) 
11dd					call addatohl 
11dd					ld a, ' ' 
11dd					ld (hl),a 
11dd					; TODO eof of parse marker 
11dd			 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					ret 
11dd			 
11dd			.iblank: db " ",0 
11dd			 
11dd			 
11dd			input_str_prev:	ld (input_at_pos), a 
11dd					ld (input_start), hl 
11dd					ld a,1			; add cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					ld (input_ptr), hl 
11dd					ld a,d 
11dd					ld (input_size), a 
11dd					ld a,0 
11dd					ld (input_cursor),a 
11dd			.instr1:	 
11dd			 
11dd					; TODO do block cursor 
11dd					; TODO switch cursor depending on the modifer key 
11dd			 
11dd					; update cursor shape change on key hold 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl), a 
11dd			 
11dd					; display entered text 
11dd					ld a,(input_at_pos) 
11dd			            	CALL fLCD_Pos       ;Position cursor to location in A 
11dd			            	LD   de, (input_start) 
11dd			            	CALL fLCD_Str       ;Display string pointed to by DE 
11dd			 
11dd					call cin 
11dd					cp 0 
11dd					jr z, .instr1 
11dd			 
11dd					; proecess keyboard controls first 
11dd			 
11dd					ld hl,(input_ptr) 
11dd			 
11dd					cp KEY_CR	 ; pressing enter ends input 
11dd					jr z, .instrcr 
11dd			 
11dd					cp KEY_BS 	; back space 
11dd					jr nz, .instr2 
11dd					; process back space 
11dd			 
11dd					; TODO stop back space if at start of string 
11dd					dec hl 
11dd					dec hl ; to over write cursor 
11dd					ld a,(cursor_shape) 
11dd					;ld a,0 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a," " 
11dd					ld (hl),a 
11dd					ld (input_ptr),hl 
11dd					 
11dd			 
11dd					jr .instr1 
11dd			 
11dd			.instr2:	cp KEY_LEFT    ; cursor left 
11dd					jr nz, .instr3 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd				 
11dd			.instr3:	cp KEY_RIGHT      ; cursor right 
11dd					jr nz, .instr4 
11dd					inc hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr4:	cp KEY_HOME    ; jump to start of line 
11dd					jr nz, .instr5 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr5:	cp KEY_END     ; jump to end of line 
11dd					jr nz, .instr6 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			.instr6:        cp KEY_UP      ; recall last command 
11dd					jr nz, .instrnew 
11dd			 
11dd				ld hl, scratch 
11dd				ld de, os_last_cmd 
11dd				call strcpy 
11dd					jr .instr1 
11dd			 
11dd			 
11dd			.instrnew:	; no special key pressed to see if we have room to store it 
11dd			 
11dd					; TODO do string size test 
11dd			 
11dd					dec hl ; to over write cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd					ld (input_ptr),hl 
11dd					 
11dd					jr .instr1 
11dd			.instrcr:	dec hl		; remove cursor 
11dd					ld a,' '	; TODO add a trailing space for safety 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					; if at end of line scroll up    
11dd					; TODO detecting only end of line 4 for scroll up  
11dd			 
11dd					;ld   
11dd			 
11dd					ret 
11dd			 
11dd			 
11dd			endif 
11dd			; strcpy hl = dest, de source 
11dd			 
11dd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11de b7			            OR   A              ;Null terminator? 
11df c8			            RET  Z              ;Yes, so finished 
11e0 1a					ld a,(de) 
11e1 77					ld (hl),a 
11e2 13			            INC  DE             ;Point to next character 
11e3 23					inc hl 
11e4 18 f7		            JR   strcpy       ;Repeat 
11e6 c9					ret 
11e7			 
11e7			 
11e7			; TODO string_at  
11e7			; pass string which starts with lcd offset address and then null term string 
11e7			 
11e7			; TODO string to dec 
11e7			; TODO string to hex 
11e7			; TODO byte to string hex 
11e7			; TODO byte to string dec 
11e7			 
11e7			 
11e7			 
11e7			; from z80uartmonitor 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11e7			; pass hl for where to put the text 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7 c5			hexout:	PUSH BC 
11e8 f5					PUSH AF 
11e9 47					LD B, A 
11ea					; Upper nybble 
11ea cb 3f				SRL A 
11ec cb 3f				SRL A 
11ee cb 3f				SRL A 
11f0 cb 3f				SRL A 
11f2 cd 02 12				CALL tohex 
11f5 77					ld (hl),a 
11f6 23					inc hl	 
11f7					 
11f7					; Lower nybble 
11f7 78					LD A, B 
11f8 e6 0f				AND 0FH 
11fa cd 02 12				CALL tohex 
11fd 77					ld (hl),a 
11fe 23					inc hl	 
11ff					 
11ff f1					POP AF 
1200 c1					POP BC 
1201 c9					RET 
1202					 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			tohex: 
1202 e5					PUSH HL 
1203 d5					PUSH DE 
1204 16 00				LD D, 0 
1206 5f					LD E, A 
1207 21 0f 12				LD HL, .DATA 
120a 19					ADD HL, DE 
120b 7e					LD A, (HL) 
120c d1					POP DE 
120d e1					POP HL 
120e c9					RET 
120f			 
120f			.DATA: 
120f 30					DEFB	30h	; 0 
1210 31					DEFB	31h	; 1 
1211 32					DEFB	32h	; 2 
1212 33					DEFB	33h	; 3 
1213 34					DEFB	34h	; 4 
1214 35					DEFB	35h	; 5 
1215 36					DEFB	36h	; 6 
1216 37					DEFB	37h	; 7 
1217 38					DEFB	38h	; 8 
1218 39					DEFB	39h	; 9 
1219 41					DEFB	41h	; A 
121a 42					DEFB	42h	; B 
121b 43					DEFB	43h	; C 
121c 44					DEFB	44h	; D 
121d 45					DEFB	45h	; E 
121e 46					DEFB	46h	; F 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
121f			;;    subtract $30, if result > 9 then subtract $7 more 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			atohex: 
121f d6 30				SUB $30 
1221 fe 0a				CP 10 
1223 f8					RET M		; If result negative it was 0-9 so we're done 
1224 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1226 c9					RET		 
1227			 
1227			 
1227			 
1227			 
1227			; Get 2 ASCII characters as hex byte from pointer in hl 
1227			 
1227			BYTERD: 
1227 16 00			LD	D,00h		;Set up 
1229 cd 31 12			CALL	HEXCON		;Get byte and convert to hex 
122c 87				ADD	A,A		;First nibble so 
122d 87				ADD	A,A		;multiply by 16 
122e 87				ADD	A,A		; 
122f 87				ADD	A,A		; 
1230 57				LD	D,A		;Save hi nibble in D 
1231			HEXCON: 
1231 7e				ld a, (hl)		;Get next chr 
1232 23				inc hl 
1233 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1235 fe 0a			CP	00Ah		;Is it 0-9 ? 
1237 38 02			JR	C,NALPHA	;If so miss next bit 
1239 d6 07			SUB	007h		;Else convert alpha 
123b			NALPHA: 
123b b2				OR	D		;Add hi nibble back 
123c c9				RET			; 
123d			 
123d			 
123d			; 
123d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
123d			; Since the routines get_byte and therefore get_nibble are called, only valid 
123d			; characters (0-9a-f) are accepted. 
123d			; 
123d			;get_word        push    af 
123d			;                call    get_byte        ; Get the upper byte 
123d			;                ld      h, a 
123d			;                call    get_byte        ; Get the lower byte 
123d			;                ld      l, a 
123d			;                pop     af 
123d			;                ret 
123d			; 
123d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
123d			; the routine get_nibble is used only valid characters are accepted - the  
123d			; input routine only accepts characters 0-9a-f. 
123d			; 
123d c5			get_byte:        push    bc              ; Save contents of B (and C) 
123e 7e					ld a,(hl) 
123f 23					inc hl 
1240 cd 65 12		                call    nibble2val      ; Get upper nibble 
1243 cb 07		                rlc     a 
1245 cb 07		                rlc     a 
1247 cb 07		                rlc     a 
1249 cb 07		                rlc     a 
124b 47			                ld      b, a            ; Save upper four bits 
124c 7e					ld a,(hl) 
124d cd 65 12		                call    nibble2val      ; Get lower nibble 
1250 b0			                or      b               ; Combine both nibbles 
1251 c1			                pop     bc              ; Restore B (and C) 
1252 c9			                ret 
1253			; 
1253			; Get a hexadecimal digit from the serial line. This routine blocks until 
1253			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1253			; to the serial line interface. The lower 4 bits of A contain the value of  
1253			; that particular digit. 
1253			; 
1253			;get_nibble      ld a,(hl)           ; Read a character 
1253			;                call    to_upper        ; Convert to upper case 
1253			;                call    is_hex          ; Was it a hex digit? 
1253			;                jr      nc, get_nibble  ; No, get another character 
1253			 ;               call    nibble2val      ; Convert nibble to value 
1253			 ;               call    print_nibble 
1253			 ;               ret 
1253			; 
1253			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1253			; A valid hexadecimal digit is denoted by a set C flag. 
1253			; 
1253			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1253			;                ret     nc              ; Yes 
1253			;                cp      '0'             ; Less than '0'? 
1253			;                jr      nc, is_hex_1    ; No, continue 
1253			;                ccf                     ; Complement carry (i.e. clear it) 
1253			;                ret 
1253			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1253			;                ret     c               ; Yes 
1253			;                cp      'A'             ; Less than 'A'? 
1253			;                jr      nc, is_hex_2    ; No, continue 
1253			;                ccf                     ; Yes - clear carry and return 
1253			;                ret 
1253			;is_hex_2        scf                     ; Set carry 
1253			;                ret 
1253			; 
1253			; Convert a single character contained in A to upper case: 
1253			; 
1253 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1255 d8			                ret     c 
1256 fe 7b		                cp      'z' + 1         ; > 'z'? 
1258 d0			                ret     nc              ; Nothing to do, either 
1259 e6 5f		                and     $5f             ; Convert to upper case 
125b c9			                ret 
125c			 
125c			 
125c			to_lower: 
125c			 
125c			   ; if char is in [A-Z] make it lower case 
125c			 
125c			   ; enter : a = char 
125c			   ; exit  : a = lower case char 
125c			   ; uses  : af 
125c			 
125c fe 41		   cp 'A' 
125e d8			   ret c 
125f			    
125f fe 5b		   cp 'Z'+1 
1261 d0			   ret nc 
1262			    
1262 f6 20		   or $20 
1264 c9			   ret 
1265			 
1265			; 
1265			; Expects a hexadecimal digit (upper case!) in A and returns the 
1265			; corresponding value in A. 
1265			; 
1265 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1267 38 02		                jr      c, nibble2val_1 ; Yes 
1269 d6 07		                sub     7               ; Adjust for A-F 
126b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
126d e6 0f		                and     $f              ; Only return lower 4 bits 
126f c9			                ret 
1270			; 
1270			; Print_nibble prints a single hex nibble which is contained in the lower  
1270			; four bits of A: 
1270			; 
1270			;print_nibble    push    af              ; We won't destroy the contents of A 
1270			;                and     $f              ; Just in case... 
1270			;                add     a, '0'             ; If we have a digit we are done here. 
1270			;                cp      '9' + 1         ; Is the result > 9? 
1270			;                jr      c, print_nibble_1 
1270			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1270			;print_nibble_1  call    putc            ; Print the nibble and 
1270			;                pop     af              ; restore the original value of A 
1270			;                ret 
1270			;; 
1270			;; Send a CR/LF pair: 
1270			; 
1270			;crlf            push    af 
1270			;                ld      a, cr 
1270			;                call    putc 
1270			;                ld      a, lf 
1270			;                call    putc 
1270			;                pop     af 
1270			;                ret 
1270			; 
1270			; Print_word prints the four hex digits of a word to the serial line. The  
1270			; word is expected to be in HL. 
1270			; 
1270			;print_word      push    hl 
1270			;                push    af 
1270			;                ld      a, h 
1270			;                call    print_byte 
1270			;                ld      a, l 
1270			;                call    print_byte 
1270			;                pop     af 
1270			;                pop     hl 
1270			;                ret 
1270			; 
1270			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1270			; The byte to be printed is expected to be in A. 
1270			; 
1270			;print_byte      push    af              ; Save the contents of the registers 
1270			;                push    bc 
1270			;                ld      b, a 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                call    print_nibble    ; Print high nibble 
1270			;                ld      a, b 
1270			;                call    print_nibble    ; Print low nibble 
1270			;                pop     bc              ; Restore original register contents 
1270			;                pop     af 
1270			;                ret 
1270			 
1270			 
1270			 
1270			 
1270			 
1270			fourehexhl:  
1270 7e				ld a,(hl) 
1271 cd 1f 12			call atohex 
1274 cb 3f				SRL A 
1276 cb 3f				SRL A 
1278 cb 3f				SRL A 
127a cb 3f				SRL A 
127c 47				ld b, a 
127d 23				inc hl 
127e 7e				ld a,(hl) 
127f 23				inc hl 
1280 cd 1f 12			call atohex 
1283 80				add b 
1284 57				ld d,a 
1285 7e				ld a,(hl) 
1286 cd 1f 12			call atohex 
1289 cb 3f				SRL A 
128b cb 3f				SRL A 
128d cb 3f				SRL A 
128f cb 3f				SRL A 
1291 47				ld b, a 
1292 23				inc hl 
1293 7e				ld a,(hl) 
1294 23				inc hl 
1295 cd 1f 12			call atohex 
1298 80				add b 
1299 5f				ld e, a 
129a d5				push de 
129b e1				pop hl 
129c c9				ret 
129d			 
129d			; pass hl. returns z set if the byte at hl is a digit 
129d			;isdigithl:  
129d			;	push bc 
129d			;	ld a,(hl) 
129d			;	cp ':' 
129d			;	jr nc, .isdf 		; > 
129d			;	cp '0' 
129d			;	jr c, .isdf		; < 
129d			; 
129d			;	; TODO find a better way to set z 
129d			; 
129d			;	ld b,a 
129d			;	cp b 
129d			;	pop bc 
129d			;	ret 
129d			; 
129d			;.isdf:	; not digit so clear z 
129d			; 
129d			;	; TODO find a better way to unset z 
129d			; 
129d			;	ld b,a 
129d			;	inc b 
129d			;	cp b 
129d			; 
129d			;	pop bc 
129d			;	ret 
129d				 
129d				 
129d			 
129d			 
129d			; pass hl as the four byte address to load 
129d			 
129d			get_word_hl:  
129d e5				push hl 
129e cd 3d 12			call get_byte 
12a1				 
12a1 47				ld b, a 
12a2			 
12a2 e1				pop hl 
12a3 23				inc hl 
12a4 23				inc hl 
12a5			 
12a5			; TODO not able to handle a-f  
12a5 7e				ld a,(hl) 
12a6			;	;cp ':' 
12a6			;	cp 'g' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp 'G' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp '0' 
12a6			;	jr c, .single_byte_hl		; < 
12a6			 
12a6				;call isdigithl 
12a6 fe 00			cp 0 
12a8 28 06			jr z, .single_byte_hl 
12aa			 
12aa			.getwhln:   ; hex word so get next byte 
12aa			 
12aa cd 3d 12			call get_byte 
12ad 6f				ld l, a 
12ae 60				ld h,b 
12af c9				ret 
12b0 68			.single_byte_hl:   ld l,b 
12b1 26 00				ld h,0 
12b3 c9					ret 
12b4			 
12b4			 
12b4			 
12b4			 
12b4 21 23 1d			ld hl,asc+1 
12b7			;	ld a, (hl) 
12b7			;	call nibble2val 
12b7 cd 3d 12			call get_byte 
12ba			 
12ba			;	call fourehexhl 
12ba 32 2a f1			ld (scratch+52),a 
12bd				 
12bd 21 28 f1			ld hl,scratch+50 
12c0 22 19 f4			ld (os_cur_ptr),hl 
12c3			 
12c3 c9				ret 
12c4			 
12c4			 
12c4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12c4			 
12c4			; Decimal Unsigned Version 
12c4			 
12c4			;Number in a to decimal ASCII 
12c4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12c4			;Example: display a=56 as "056" 
12c4			;input: a = number 
12c4			;Output: a=0,value of a in the screen 
12c4			;destroys af,bc (don't know about hl and de) 
12c4			DispAToASCII: 
12c4 0e 9c			ld	c,-100 
12c6 cd d0 12			call	.Na1 
12c9 0e f6			ld	c,-10 
12cb cd d0 12			call	.Na1 
12ce 0e ff			ld	c,-1 
12d0 06 2f		.Na1:	ld	b,'0'-1 
12d2 04			.Na2:	inc	b 
12d3 81				add	a,c 
12d4 38 fc			jr	c,.Na2 
12d6 91				sub	c		;works as add 100/10/1 
12d7 f5				push af		;safer than ld c,a 
12d8 78				ld	a,b		;char is in b 
12d9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12d9 f1				pop af		;safer than ld a,c 
12da c9				ret 
12db			 
12db			; Decimal Signed Version 
12db			 
12db			; DispA 
12db			; -------------------------------------------------------------- 
12db			; Converts a signed integer value to a zero-terminated ASCII 
12db			; string representative of that value (using radix 10). 
12db			; -------------------------------------------------------------- 
12db			; INPUTS: 
12db			;     HL     Value to convert (two's complement integer). 
12db			;     DE     Base address of string destination. (pointer). 
12db			; -------------------------------------------------------------- 
12db			; OUTPUTS: 
12db			;     None 
12db			; -------------------------------------------------------------- 
12db			; REGISTERS/MEMORY DESTROYED 
12db			; AF HL 
12db			; -------------------------------------------------------------- 
12db			 
12db			;DispHLToASCII: 
12db			;   push    de 
12db			;   push    bc 
12db			; 
12db			;; Detect sign of HL. 
12db			;    bit    7, h 
12db			;    jr     z, ._DoConvert 
12db			; 
12db			;; HL is negative. Output '-' to string and negate HL. 
12db			;    ld     a, '-' 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			; 
12db			;; Negate HL (using two's complement) 
12db			;    xor    a 
12db			;    sub    l 
12db			;    ld     l, a 
12db			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12db			;    sbc    a, h 
12db			;    ld     h, a 
12db			; 
12db			;; Convert HL to digit characters 
12db			;._DoConvert: 
12db			;    ld     b, 0     ; B will count character length of number 
12db			;-   ld     a, 10 
12db			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12db			;    push   af 
12db			;    inc    b 
12db			;    ld     a, h 
12db			;    or     l 
12db			;    jr     nz, - 
12db			; 
12db			;; Retrieve digits from stack 
12db			;-   pop    af 
12db			;    or     $30 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			;    djnz   - 
12db			; 
12db			;; Terminate string with NULL 
12db			;    xor    a 
12db			;    ld     (de), a 
12db			; 
12db			;    pop    bc 
12db			;    pop    de 
12db			;    ret 
12db			 
12db			;Comments 
12db			; 
12db			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12db			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12db			;    Note that the output string will not be fixed-width. 
12db			; 
12db			;Example Usage 
12db			; 
12db			;    ld    hl, -1004 
12db			;    ld    de, OP1 
12db			;    call  DispA 
12db			;    ld    hl, OP1 
12db			;    syscall  PutS 
12db			 
12db			 
12db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12db			 
12db			 
12db			;Converts an ASCII string to an unsigned 16-bit integer 
12db			;Quits when it reaches a non-decimal digit 
12db			 
12db			string_to_uint16: 
12db			atoui_16: 
12db			;Input: 
12db			;     DE points to the string 
12db			;Outputs: 
12db			;     HL is the result 
12db			;     A is the 8-bit value of the number 
12db			;     DE points to the byte after the number 
12db			;Destroys: 
12db			;     BC 
12db			;       if the string is non-empty, BC is HL/10 
12db			;Size:  24 bytes 
12db			;Speed: 42+d(104+{0,9}) 
12db			;       d is the number of digits in the number 
12db			;       max is 640 cycles for a 5 digit number 
12db			;Assuming no leading zeros: 
12db			;1 digit:  146cc 
12db			;2 digit:  250cc 
12db			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12db			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12db			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12db			;avg: 544.81158447265625cc (544+13297/16384) 
12db			;=============================================================== 
12db 21 00 00		  ld hl,0 
12de			.u16a: 
12de 1a			  ld a,(de) 
12df d6 30		  sub 30h 
12e1 fe 0a		  cp 10 
12e3 d0			  ret nc 
12e4 13			  inc de 
12e5 44			  ld b,h 
12e6 4d			  ld c,l 
12e7 29			  add hl,hl 
12e8 29			  add hl,hl 
12e9 09			  add hl,bc 
12ea 29			  add hl,hl 
12eb 85			  add a,l 
12ec 6f			  ld l,a 
12ed 30 ef		  jr nc,.u16a 
12ef 24			  inc h 
12f0 c3 de 12		  jp .u16a 
12f3			 
12f3			 
12f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f3			 
12f3			;written by Zeda 
12f3			;Converts a 16-bit unsigned integer to an ASCII string. 
12f3			 
12f3			uitoa_16: 
12f3			;Input: 
12f3			;   DE is the number to convert 
12f3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12f3			;Output: 
12f3			;   HL points to the null-terminated ASCII string 
12f3			;      NOTE: This isn't necessarily the same as the input HL. 
12f3 d5			  push de 
12f4 c5			  push bc 
12f5 f5			  push af 
12f6 eb			  ex de,hl 
12f7			 
12f7 01 f0 d8		  ld bc,-10000 
12fa 3e 2f		  ld a,'0'-1 
12fc 3c			  inc a 
12fd 09			  add hl,bc  
12fe 38 fc		   jr c,$-2 
1300 12			  ld (de),a 
1301 13			  inc de 
1302			 
1302 01 e8 03		  ld bc,1000 
1305 3e 3a		  ld a,'9'+1 
1307 3d			  dec a  
1308 09			  add hl,bc  
1309 30 fc		   jr nc,$-2 
130b 12			  ld (de),a 
130c 13			  inc de 
130d			 
130d 01 9c ff		  ld bc,-100 
1310 3e 2f		  ld a,'0'-1 
1312 3c			  inc a  
1313 09			  add hl,bc  
1314 38 fc		   jr c,$-2 
1316 12			  ld (de),a 
1317 13			  inc de 
1318			 
1318 7d			  ld a,l 
1319 26 3a		  ld h,'9'+1 
131b 25			  dec h  
131c c6 0a		  add a,10  
131e 30 fb		   jr nc,$-3 
1320 c6 30		  add a,'0' 
1322 eb			  ex de,hl 
1323 72			  ld (hl),d 
1324 23			  inc hl 
1325 77			  ld (hl),a 
1326 23			  inc hl 
1327 36 00		  ld (hl),0 
1329			 
1329			;Now strip the leading zeros 
1329 0e fa		  ld c,-6 
132b 09			  add hl,bc 
132c 3e 30		  ld a,'0' 
132e 23			  inc hl  
132f be			  cp (hl)  
1330 28 fc		  jr z,$-2 
1332			 
1332			;Make sure that the string is non-empty! 
1332 7e			  ld a,(hl) 
1333 b7			  or a 
1334 20 01		  jr nz,.atoub 
1336 2b			  dec hl 
1337			.atoub: 
1337			 
1337 f1			  pop af 
1338 c1			  pop bc 
1339 d1			  pop de 
133a c9			  ret 
133b			 
133b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
133b			 
133b			toUpper: 
133b			;A is the char. 
133b			;If A is a lowercase letter, this sets it to the matching uppercase 
133b			;18cc or 30cc or 41cc 
133b			;avg: 26.75cc 
133b fe 61		  cp 'a' 
133d d8			  ret c 
133e fe 7b		  cp 'z'+1 
1340 d0			  ret nc 
1341 d6 20		  sub 'a'-'A' 
1343 c9			  ret 
1344			 
1344			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1344			 
1344			; String Length 
1344			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1344			 
1344			; Get the length of the null-terminated string starting at $8000 hl 
1344			;    LD     HL, $8000 
1344			 
1344			strlenz: 
1344			 
1344 af			    XOR    A               ; Zero is the value we are looking for. 
1345 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1346 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1347			                           ; 65, 536 bytes (the entire addressable memory space). 
1347 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1349			 
1349			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1349 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
134a 6f			    LD     L, A             ; number of bytes 
134b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134d 2b			    DEC    HL              ; Compensate for null. 
134e c9				ret 
134f			 
134f			; Get the length of the A terminated string starting at $8000 hl 
134f			;    LD     HL, $8000 
134f			 
134f			strlent: 
134f			 
134f			                  ; A is the value we are looking for. 
134f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1351 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1353			                           ; 65, 536 bytes (the entire addressable memory space). 
1353 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1355			 
1355			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1355 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1357 2e 00		    LD     L, 0             ; number of bytes 
1359 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
135b 2b			    DEC    HL              ; Compensate for null. 
135c c9				ret 
135d			 
135d			 
135d			;Comparing Strings 
135d			 
135d			;IN    HL     Address of string1. 
135d			;      DE     Address of string2. 
135d			 
135d			; doc given but wrong??? 
135d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
135d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
135d			; tested 
135d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
135d			 
135d			strcmp_old: 
135d e5			    PUSH   HL 
135e d5			    PUSH   DE 
135f			 
135f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1360 be			    CP     (HL)            ; (want to minimize work). 
1361 38 01		    JR     C, Str1IsBigger 
1363 7e			    LD     A, (HL) 
1364			 
1364			Str1IsBigger: 
1364 4f			    LD     C, A             ; Put length in BC 
1365 06 00		    LD     B, 0 
1367 13			    INC    DE              ; Increment pointers to meat of string. 
1368 23			    INC    HL 
1369			 
1369			CmpLoop: 
1369 1a			    LD     A, (DE)          ; Compare bytes. 
136a ed a1		    CPI 
136c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
136e 13			    INC    DE              ; Update pointer. 
136f ea 69 13		    JP     PE, CmpLoop 
1372			 
1372 d1			    POP    DE 
1373 e1			    POP    HL 
1374 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1375 be			    CP     (HL) 
1376 c9			    RET 
1377			 
1377			NoMatch: 
1377 2b			    DEC    HL 
1378 be			    CP     (HL)            ; Compare again to affect carry. 
1379 d1			    POP    DE 
137a e1			    POP    HL 
137b c9			    RET 
137c			 
137c			;; test strmp 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr z, .z1 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z1: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr z, .z2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr c, .c1 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c1: 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr c, .c2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;	NEXTW 
137c			;.str1:   db "string1",0 
137c			;.str2:   db "string2",0 
137c			 
137c			; only care about direct match or not 
137c			; hl and de strings 
137c			; zero set if the same 
137c			 
137c			strcmp: 
137c 1a				ld a, (de) 
137d be				cp (hl) 
137e 28 02			jr z, .ssame 
1380 b7				or a 
1381 c9				ret 
1382			 
1382			.ssame:  
1382 fe 00			cp 0 
1384 c8				ret z 
1385			 
1385 23				inc hl 
1386 13				inc de 
1387 18 f3			jr strcmp 
1389				 
1389				 
1389			 
1389			;Copyright (c) 2014, Luke Maurits 
1389			;All rights reserved. 
1389			; 
1389			;Redistribution and use in source and binary forms, with or without 
1389			;modification, are permitted provided that the following conditions are met: 
1389			; 
1389			;* Redistributions of source code must retain the above copyright notice, this 
1389			;  list of conditions and the following disclaimer. 
1389			; 
1389			;* Redistributions in binary form must reproduce the above copyright notice, 
1389			;  this list of conditions and the following disclaimer in the documentation 
1389			;  and/or other materials provided with the distribution. 
1389			; 
1389			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1389			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1389			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1389			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1389			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1389			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1389			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1389			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1389			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1389			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1389			 
1389			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1389			 
1389			StrictStrCmp: 
1389				; Load next chars of each string 
1389 1a				ld a, (de) 
138a 47				ld b, a 
138b 7e				ld a, (hl) 
138c				; Compare 
138c b8				cp b 
138d				; Return non-zero if chars don't match 
138d c0				ret nz 
138e				; Check for end of both strings 
138e fe 00			cp "\0" 
1390				; Return if strings have ended 
1390 c8				ret z 
1391				; Otherwise, advance to next chars 
1391 23				inc hl 
1392 13				inc de 
1393 18 f4			jr StrictStrCmp 
1395			 
1395			;end 
1395			; eof 
1395			 
1395			 
1395			 
1395			 
1395			 
1395			 
# End of file firmware_strings.asm
1395			include "firmware_memory.asm"   ; malloc and free  
1395			 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			.mallocsize: db "Wants malloc >256",0 
1395			.mallocasize: db "MALLOC gives >256",0 
1395			.malloczero: db "MALLOC gives zero",0 
1395			 
1395			malloc_guard_zerolen: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395				ld de, 0 
1395			        call cmp16 
1395				jr nz, .lowalloz 
1395			 
1395				push hl 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .malloczero 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395				call bp_on 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395			.lowalloz: 
1395			 
1395			 
1395				pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_entry: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowalloc 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocsize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395				jr .lowdone 
1395			.lowalloc: 
1395			 
1395			 
1395				pop hl 
1395			.lowdone:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_exit: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowallocx 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocasize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395				pop de 
1395				pop hl 
1395			 
1395				CALLMONITOR 
1395				jr .lowdonex 
1395			.lowallocx: 
1395			 
1395				pop hl 
1395			.lowdonex:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			endif 
1395			 
1395			if MALLOC_2 
1395			; Z80 Malloc and Free Functions 
1395			 
1395			; Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc: 
1395				 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_entry 
1395			endif 
1395			 
1395			 
1395			 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "mal" 
1395						CALLMONITOR 
1395					endif 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of size into A 
1395			    or h               ; Check if size is zero 
1395			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1395			 
1395			    ; Allocate memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma1" 
1395						CALLMONITOR 
1395					endif 
1395			    call malloc_internal ; Call internal malloc function 
1395			    pop af             ; Restore AF register 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret                ; Return 
1395			 
1395			; Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free: 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of pointer into A 
1395			    or h               ; Check if pointer is NULL 
1395			    jp z, free_exit    ; If pointer is NULL, exit 
1395			 
1395			    ; Free memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395			    call free_internal  ; Call internal free function 
1395			    pop af             ; Restore AF register 
1395			    ret                ; Return 
1395			 
1395			; Internal Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc_internal: 
1395			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to requested size 
1395			    ex de, hl          ; Save total size in DE, and keep it in HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			 
1395			    ; Search for free memory block 
1395			    ld de, (heap_end)  ; Load end of heap into DE 
1395			    ld bc, 0           ; Initialize counter 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			malloc_search_loop: 
1395			    ; Check if current block is free 
1395			    ld a, (hl)         ; Load current block's status (free or used) 
1395			    cp 0               ; Compare with zero (free) 
1395			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1395			 
1395			    ; Check if current block is large enough 
1395			    ld a, (hl+1)       ; Load high byte of block size 
1395			    cp l               ; Compare with low byte of requested size 
1395			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1395			 
1395			    ld a, (hl+2)       ; Load low byte of block size 
1395			    cp h               ; Compare with high byte of requested size 
1395			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1395			 
1395			    ; Mark block as used 
1395			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1395			 
1395			    ; Calculate remaining space in block 
1395			    ld bc, 0           ; Clear BC 
1395			    add hl, bc         ; Increment HL to point to start of data block 
1395			    add hl, de         ; HL = HL + DE (total size) 
1395			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to start of data block 
1395			 
1395			    ; Save pointer to allocated block in HL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma5" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			malloc_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3           ; Size of management overhead 
1395			    add hl, bc         ; Move to the next block 
1395			    inc de             ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e            ; Load low byte of heap end address 
1395			    cp (hl)            ; Compare with low byte of current address 
1395			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1395			    ld a, d            ; Load high byte of heap end address 
1395			    cp 0               ; Check if it's zero (end of memory) 
1395			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, allocation failed 
1395			    xor a              ; Set result to NULL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma6" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			malloc_exit: 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma7" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			; Internal Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free_internal: 
1395			    ld de, (heap_start) ; Load start of heap into DE 
1395			    ld bc, 0            ; Initialize counter 
1395			 
1395			free_search_loop: 
1395			    ; Check if current block contains the pointer 
1395			    ld a, l             ; Load low byte of pointer 
1395			    cp (hl+1)           ; Compare with high byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			    ld a, h             ; Load high byte of pointer 
1395			    cp (hl+2)           ; Compare with low byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			 
1395			    ; Mark block as free 
1395			    ld (hl), 0          ; Set status byte to indicate free block 
1395			    ret                 ; Return 
1395			 
1395			free_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3            ; Size of management overhead 
1395			    add hl, bc          ; Move to the next block 
1395			    inc de              ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e             ; Load low byte of heap end address 
1395			    cp (hl)             ; Compare with low byte of current address 
1395			    jr nz, free_search_loop  ; If not equal, continue searching 
1395			    ld a, d             ; Load high byte of heap end address 
1395			    cp 0                ; Check if it's zero (end of memory) 
1395			    jr nz, free_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, pointer is not found in heap 
1395			    ret 
1395			 
1395			free_exit: 
1395			    ret                 ; Return 
1395			 
1395			; Define heap start and end addresses 
1395			;heap_start:    .dw 0xC000   ; Start of heap 
1395			;heap_end:      .dw 0xE000   ; End of heap 
1395			 
1395			endif 
1395			 
1395			 
1395			if MALLOC_1 
1395			 
1395			 
1395			 
1395			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1395			 
1395			;moved to firmware.asm 
1395			;heap_start        .equ  0x9000      ; Starting address of heap 
1395			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1395			 
1395			;      .org 0 
1395			;      jp    main 
1395			 
1395			 
1395			;      .org  0x100 
1395			;main: 
1395			;      ld    HL, 0x8100 
1395			;      ld    SP, HL 
1395			; 
1395			;      call  heap_init 
1395			; 
1395			;      ; Make some allocations 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9004 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9014 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9024 
1395			; 
1395			;      ; Free some allocations 
1395			;      ld    HL, 0x9014 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9004 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9024 
1395			;      call  free 
1395			; 
1395			; 
1395			;      halt 
1395			 
1395			 
1395			;------------------------------------------------------------------------------ 
1395			;     heap_init                                                               : 
1395			;                                                                             : 
1395			; Description                                                                 : 
1395			;     Initialise the heap and make it ready for malloc and free operations.   : 
1395			;                                                                             : 
1395			;     The heap is maintained as a linked list, starting with an initial       : 
1395			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1395			;     the first free block in the heap. Each block then points to the next    : 
1395			;     free block within the heap, and the free list ends at the first block   : 
1395			;     with a null pointer to the next free block.                             : 
1395			;                                                                             : 
1395			; Parameters                                                                  : 
1395			;     Inputs are compile-time only. Two defines which specify the starting    : 
1395			;     address of the heap and its size are required, along with a memory      : 
1395			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1395			;     principally stores a pointer to the first free block in the heap.       : 
1395			;                                                                             : 
1395			; Returns                                                                     : 
1395			;     Nothing                                                                 : 
1395			;------------------------------------------------------------------------------ 
1395			heap_init: 
1395 e5			      push  HL 
1396			 
1396			      ; Initialise free list struct 
1396 21 0e 80		      ld    HL, heap_start 
1399 22 0a 80		      ld    (free_list), HL 
139c 21 00 00		      ld    HL, 0 
139f 22 0c 80		      ld    (free_list+2), HL 
13a2			 
13a2			      ; Insert first free block at bottom of heap, consumes entire heap 
13a2 21 cd f0		      ld    HL, heap_start+heap_size-4 
13a5 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13a8 21 bf 70		      ld    HL, heap_size-4 
13ab 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13ae			 
13ae			      ; Insert end of free list block at top of heap - two null words will 
13ae			      ; terminate the free list 
13ae 21 00 00		      ld    HL, 0 
13b1 22 cf f0		      ld    (heap_start+heap_size-2), HL 
13b4 22 cd f0		      ld    (heap_start+heap_size-4), HL 
13b7			 
13b7 e1			      pop   HL 
13b8			 
13b8 c9			      ret 
13b9			 
13b9			 
13b9			;------------------------------------------------------------------------------ 
13b9			;     malloc                                                                  : 
13b9			;                                                                             : 
13b9			; Description                                                                 : 
13b9			;     Allocates the wanted space from the heap and returns the address of the : 
13b9			;     first useable byte of the allocation.                                   : 
13b9			;                                                                             : 
13b9			;     Allocations can happen in one of two ways:                              : 
13b9			;                                                                             : 
13b9			;     1. A free block may be found which is the exact size wanted. In this    : 
13b9			;        case the block is removed from the free list and retuedn to the      : 
13b9			;        caller.                                                              : 
13b9			;     2. A free block may be found which is larger than the size wanted. In   : 
13b9			;        this case, the larger block is split into two. The first portion of  : 
13b9			;        this block will become the requested space by the malloc call and    : 
13b9			;        is returned to the caller. The second portion becomes a new free     : 
13b9			;        block, and the free list is adjusted to maintain continuity via this : 
13b9			;        newly created block.                                                 : 
13b9			;                                                                             : 
13b9			;     malloc does not set any initial value in the allocated space, the       : 
13b9			;     caller is required to do this as required.                              : 
13b9			;                                                                             : 
13b9			;     This implementation of malloc uses the stack exclusively, and is        : 
13b9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13b9			;     advisable to disable interrupts before calling malloc, and recommended  : 
13b9			;     to avoid the use of malloc inside ISRs in general.                      : 
13b9			;                                                                             : 
13b9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13b9			;                                                                             : 
13b9			; Parameters                                                                  : 
13b9			;     HL  Number of bytes wanted                                              : 
13b9			;                                                                             : 
13b9			; Returns                                                                     : 
13b9			;     HL  Address of the first useable byte of the allocation                 : 
13b9			;                                                                             : 
13b9			; Flags                                                                       : 
13b9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13b9			;                                                                             : 
13b9			; Stack frame                                                                 : 
13b9			;       |             |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     BC      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     DE      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     IX      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |  prev_free  |                                                       : 
13b9			;   +4  +-------------+                                                       : 
13b9			;       |  this_free  |                                                       : 
13b9			;   +2  +-------------+                                                       : 
13b9			;       |  next_free  |                                                       : 
13b9			;   +0  +-------------+                                                       : 
13b9			;       |             |                                                       : 
13b9			;                                                                             : 
13b9			;------------------------------------------------------------------------------ 
13b9			 
13b9			 
13b9			;malloc: 
13b9			; 
13b9			;	SAVESP ON 1 
13b9			; 
13b9			;	call malloc_code 
13b9			; 
13b9			;	CHECKSP ON 1 
13b9			;	ret 
13b9			 
13b9			 
13b9			malloc: 
13b9 c5			      push  BC 
13ba d5			      push  DE 
13bb dd e5		      push  IX 
13bd			if DEBUG_FORTH_MALLOC_HIGH 
13bd			call malloc_guard_entry 
13bd			endif 
13bd			 
13bd					if DEBUG_FORTH_MALLOC 
13bd						DMARK "mal" 
13bd						CALLMONITOR 
13bd					endif 
13bd 7c			      ld    A, H                    ; Exit if no space requested 
13be b5			      or    L 
13bf ca 7e 14		      jp    Z, malloc_early_exit 
13c2			 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			; 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			 
13c2			 
13c2			 
13c2			 
13c2					if DEBUG_FORTH_MALLOC 
13c2						DMARK "maA" 
13c2						CALLMONITOR 
13c2					endif 
13c2			      ; Set up stack frame 
13c2 eb			      ex    DE, HL 
13c3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13c6 39			      add   HL, SP 
13c7 f9			      ld    SP, HL 
13c8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13cc dd 39		      add   IX, SP 
13ce			 
13ce			      ; Setup initial state 
13ce 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13d1 19			      add   HL, DE 
13d2			 
13d2 44			      ld    B, H                    ; Move want to BC 
13d3 4d			      ld    C, L 
13d4			 
13d4 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13d7 dd 75 04		      ld    (IX+4), L 
13da dd 74 05		      ld    (IX+5), H 
13dd			 
13dd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13de 23			      inc   HL 
13df 56			      ld    D, (HL) 
13e0 dd 73 02		      ld    (IX+2), E 
13e3 dd 72 03		      ld    (IX+3), D 
13e6 eb			      ex    DE, HL                  ; this_free ptr into HL 
13e7			 
13e7					if DEBUG_FORTH_MALLOC 
13e7						DMARK "maB" 
13e7						CALLMONITOR 
13e7					endif 
13e7			      ; Loop through free block list to find some space 
13e7			malloc_find_space: 
13e7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13e8 23			      inc   HL 
13e9 56			      ld    D, (HL) 
13ea			 
13ea 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13eb b3			      or    E 
13ec ca 78 14		      jp    Z, malloc_no_space 
13ef			 
13ef dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13f2 dd 72 01		      ld    (IX+1), D 
13f5			 
13f5			      ; Does this block have enough space to make the allocation? 
13f5 23			      inc   HL                      ; Load free block size into DE 
13f6 5e			      ld    E, (HL) 
13f7 23			      inc   HL 
13f8 56			      ld    D, (HL) 
13f9			 
13f9 eb			      ex    DE, HL                  ; Check size of block against want 
13fa b7			      or    A                       ; Ensure carry flag clear 
13fb ed 42		      sbc   HL, BC 
13fd e5			      push  HL                      ; Store the result for later (new block size) 
13fe			 
13fe ca 4d 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1401 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1403			 
1403			      ; this_free block is not big enough, setup ptrs to test next free block 
1403 e1			      pop   HL                      ; Discard previous result 
1404			 
1404 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1407 dd 66 03		      ld    H, (IX+3) 
140a dd 75 04		      ld    (IX+4), L 
140d dd 74 05		      ld    (IX+5), H 
1410			 
1410 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1413 dd 66 01		      ld    H, (IX+1) 
1416 dd 75 02		      ld    (IX+2), L 
1419 dd 74 03		      ld    (IX+3), H 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "MA>" 
141c						CALLMONITOR 
141c					endif 
141c 18 c9		      jr    malloc_find_space 
141e			 
141e			      ; split a bigger block into two - requested size and remaining size 
141e			malloc_alloc_split: 
141e					if DEBUG_FORTH_MALLOC 
141e						DMARK "MAs" 
141e						CALLMONITOR 
141e					endif 
141e eb			      ex    DE, HL                  ; Calculate address of new free block 
141f 2b			      dec   HL 
1420 2b			      dec   HL 
1421 2b			      dec   HL 
1422 09			      add   HL, BC 
1423			 
1423			      ; Create a new block and point it at next_free 
1423 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1426 dd 56 01		      ld    D, (IX+1) 
1429			 
1429 73			      ld    (HL), E                 ; Store next_free ptr into new block 
142a 23			      inc   HL 
142b 72			      ld    (HL), D 
142c			 
142c d1			      pop   DE                      ; Store size of new block into new block 
142d 23			      inc   HL 
142e 73			      ld    (HL), E 
142f 23			      inc   HL 
1430 72			      ld    (HL), D 
1431			 
1431			      ; Update this_free ptr to point to new block 
1431 2b			      dec   HL 
1432 2b			      dec   HL 
1433 2b			      dec   HL 
1434			 
1434 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1437 dd 56 03		      ld    D, (IX+3) 
143a			 
143a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143d dd 74 03		      ld    (IX+3), H 
1440			 
1440			      ; Modify this_free block to be allocation 
1440 eb			      ex    DE, HL 
1441 af			      xor   A                       ; Null the next block ptr of allocated block 
1442 77			      ld    (HL), A 
1443 23			      inc   HL 
1444 77			      ld    (HL), A 
1445			 
1445 23			      inc   HL                      ; Store want size into allocated block 
1446 71			      ld    (HL), C 
1447 23			      inc   HL 
1448 70			      ld    (HL), B 
1449 23			      inc   HL 
144a e5			      push  HL                      ; Address of allocation to return 
144b			 
144b 18 19		      jr    malloc_update_links 
144d			 
144d			malloc_alloc_fit: 
144d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
144e			 
144e					if DEBUG_FORTH_MALLOC 
144e						DMARK "MAf" 
144e						CALLMONITOR 
144e					endif 
144e			      ; Modify this_free block to be allocation 
144e eb			      ex    DE, HL 
144f 2b			      dec   HL 
1450 2b			      dec   HL 
1451 2b			      dec   HL 
1452			 
1452 af			      xor   A                       ; Null the next block ptr of allocated block 
1453 77			      ld    (HL), A 
1454 23			      inc   HL 
1455 77			      ld    (HL), A 
1456			 
1456 23			      inc   HL                      ; Store address of allocation to return 
1457 23			      inc   HL 
1458 23			      inc   HL 
1459 e5			      push  HL 
145a			 
145a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
145a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
145d dd 66 01		      ld    H, (IX+1) 
1460			 
1460 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1463 dd 74 03		      ld    (IX+3), H 
1466			 
1466			 
1466			malloc_update_links: 
1466			      ; Update prev_free ptr to point to this_free 
1466 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1469 dd 66 05		      ld    H, (IX+5) 
146c			 
146c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
146f dd 56 03		      ld    D, (IX+3) 
1472			 
1472 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1473 23			      inc   HL 
1474 72			      ld    (HL), D 
1475			 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "Mul" 
1475						CALLMONITOR 
1475					endif 
1475			      ; Clear the Z flag to indicate successful allocation 
1475 7a			      ld    A, D 
1476 b3			      or    E 
1477			 
1477 d1			      pop   DE                      ; Address of allocation 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAu" 
1478						CALLMONITOR 
1478					endif 
1478			 
1478			malloc_no_space: 
1478 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
147b 39			      add   HL, SP 
147c f9			      ld    SP, HL 
147d			 
147d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAN" 
147e						CALLMONITOR 
147e					endif 
147e			 
147e			malloc_early_exit: 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAx" 
147e						CALLMONITOR 
147e					endif 
147e dd e1		      pop   IX 
1480 d1			      pop   DE 
1481 c1			      pop   BC 
1482			 
1482			if DEBUG_FORTH_MALLOC_HIGH 
1482			call malloc_guard_exit 
1482			call malloc_guard_zerolen 
1482			endif 
1482 c9			      ret 
1483			 
1483			 
1483			;------------------------------------------------------------------------------ 
1483			;     free                                                                    : 
1483			;                                                                             : 
1483			; Description                                                                 : 
1483			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1483			;     returned by malloc, otherwise the behaviour is undefined.               : 
1483			;                                                                             : 
1483			;     Where possible, directly adjacent free blocks will be merged together   : 
1483			;     into larger blocks to help ensure that the heap does not become         : 
1483			;     excessively fragmented.                                                 : 
1483			;                                                                             : 
1483			;     free does not clear or set any other value into the freed space, and    : 
1483			;     therefore its contents may be visible through subsequent malloc's. The  : 
1483			;     caller should clear the freed space as required.                        : 
1483			;                                                                             : 
1483			;     This implementation of free uses the stack exclusively, and is          : 
1483			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1483			;     advisable to disable interrupts before calling free, and recommended    : 
1483			;     to avoid the use of free inside ISRs in general.                        : 
1483			;                                                                             : 
1483			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1483			;                                                                             : 
1483			; Parameters                                                                  : 
1483			;     HL  Pointer to address of first byte of allocation to be freed          : 
1483			;                                                                             : 
1483			; Returns                                                                     : 
1483			;     Nothing                                                                 : 
1483			;                                                                             : 
1483			; Stack frame                                                                 : 
1483			;       |             |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     BC      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     DE      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     IX      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |  prev_free  |                                                       : 
1483			;   +2  +-------------+                                                       : 
1483			;       |  next_free  |                                                       : 
1483			;   +0  +-------------+                                                       : 
1483			;       |             |                                                       : 
1483			;                                                                             : 
1483			;------------------------------------------------------------------------------ 
1483			free: 
1483 c5			      push  BC 
1484 d5			      push  DE 
1485 dd e5		      push  IX 
1487			 
1487 7c			      ld    A, H                    ; Exit if ptr is null 
1488 b5			      or    L 
1489 ca 4d 15		      jp    Z, free_early_exit 
148c			 
148c			      ; Set up stack frame 
148c eb			      ex    DE, HL 
148d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1490 39			      add   HL, SP 
1491 f9			      ld    SP, HL 
1492 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1496 dd 39		      add   IX, SP 
1498			 
1498			      ; The address in HL points to the start of the useable allocated space, 
1498			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1498			      ; address of the block itself. 
1498 eb			      ex    DE, HL 
1499 11 fc ff		      ld    DE, -4 
149c 19			      add   HL, DE 
149d			 
149d			      ; An allocated block must have a null next block pointer in it 
149d 7e			      ld    A, (HL) 
149e 23			      inc   HL 
149f b6			      or    (HL) 
14a0 c2 48 15		      jp    NZ, free_done 
14a3			 
14a3 2b			      dec   HL 
14a4			 
14a4 44			      ld    B, H                    ; Copy HL to BC 
14a5 4d			      ld    C, L 
14a6			 
14a6			      ; Loop through the free list to find the first block with an address 
14a6			      ; higher than the block being freed 
14a6 21 0a 80		      ld    HL, free_list 
14a9			 
14a9			free_find_higher_block: 
14a9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14aa 23			      inc   HL 
14ab 56			      ld    D, (HL) 
14ac 2b			      dec   HL 
14ad			 
14ad dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14b0 dd 72 01		      ld    (IX+1), D 
14b3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14b6 dd 74 03		      ld    (IX+3), H 
14b9			 
14b9 78			      ld    A, B                    ; Check if DE is greater than BC 
14ba ba			      cp    D                       ; Compare MSB first 
14bb 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14bd 30 04		      jr    NC, free_find_higher_block_skip 
14bf 79			      ld    A, C 
14c0 bb			      cp    E                       ; Then compare LSB 
14c1 38 08		      jr    C, free_found_higher_block 
14c3			 
14c3			free_find_higher_block_skip: 
14c3 7a			      ld    A, D                    ; Reached the end of the free list? 
14c4 b3			      or    E 
14c5 ca 48 15		      jp    Z, free_done 
14c8			 
14c8 eb			      ex    DE, HL 
14c9			 
14c9 18 de		      jr    free_find_higher_block 
14cb			 
14cb			free_found_higher_block: 
14cb			      ; Insert freed block between prev and next free blocks 
14cb 71			      ld    (HL), C                 ; Point prev free block to freed block 
14cc 23			      inc   HL 
14cd 70			      ld    (HL), B 
14ce			 
14ce 60			      ld    H, B                    ; Point freed block at next free block 
14cf 69			      ld    L, C 
14d0 73			      ld    (HL), E 
14d1 23			      inc   HL 
14d2 72			      ld    (HL), D 
14d3			 
14d3			      ; Check if the freed block is adjacent to the next free block 
14d3 23			      inc   HL                      ; Load size of freed block into HL 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7 eb			      ex    DE, HL 
14d8			 
14d8 09			      add   HL, BC                  ; Add addr of freed block and its size 
14d9			 
14d9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14dc dd 56 01		      ld    D, (IX+1) 
14df			 
14df b7			      or    A                       ; Clear the carry flag 
14e0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14e2 20 22		      jr    NZ, free_check_adjacent_to_prev 
14e4			 
14e4			      ; Freed block is adjacent to next, merge into one bigger block 
14e4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14e5 5e			      ld    E, (HL) 
14e6 23			      inc   HL 
14e7 56			      ld    D, (HL) 
14e8 e5			      push  HL                      ; Save ptr to next block for later 
14e9			 
14e9 60			      ld    H, B                    ; Store ptr from next block into freed block 
14ea 69			      ld    L, C 
14eb 73			      ld    (HL), E 
14ec 23			      inc   HL 
14ed 72			      ld    (HL), D 
14ee			 
14ee e1			      pop   HL                      ; Restore ptr to next block 
14ef 23			      inc   HL                      ; Load size of next block into DE 
14f0 5e			      ld    E, (HL) 
14f1 23			      inc   HL 
14f2 56			      ld    D, (HL) 
14f3 d5			      push  DE                      ; Save next block size for later 
14f4			 
14f4 60			      ld    H, B                    ; Load size of freed block into HL 
14f5 69			      ld    L, C 
14f6 23			      inc   HL 
14f7 23			      inc   HL 
14f8 5e			      ld    E, (HL) 
14f9 23			      inc   HL 
14fa 56			      ld    D, (HL) 
14fb eb			      ex    DE, HL 
14fc			 
14fc d1			      pop   DE                      ; Restore size of next block 
14fd 19			      add   HL, DE                  ; Add sizes of both blocks 
14fe eb			      ex    DE, HL 
14ff			 
14ff 60			      ld    H, B                    ; Store new bigger size into freed block 
1500 69			      ld    L, C 
1501 23			      inc   HL 
1502 23			      inc   HL 
1503 73			      ld    (HL), E 
1504 23			      inc   HL 
1505 72			      ld    (HL), D 
1506			 
1506			free_check_adjacent_to_prev: 
1506			      ; Check if the freed block is adjacent to the prev free block 
1506 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1509 dd 66 03		      ld    H, (IX+3) 
150c			 
150c 23			      inc   HL                      ; Size of prev free block into DE 
150d 23			      inc   HL 
150e 5e			      ld    E, (HL) 
150f 23			      inc   HL 
1510 56			      ld    D, (HL) 
1511 2b			      dec   HL 
1512 2b			      dec   HL 
1513 2b			      dec   HL 
1514			 
1514 19			      add   HL, DE                  ; Add prev block addr and size 
1515			 
1515 b7			      or    A                       ; Clear the carry flag 
1516 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1518 20 2e		      jr    NZ, free_done 
151a			 
151a			      ; Freed block is adjacent to prev, merge into one bigger block 
151a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
151b 69			      ld    L, C 
151c 5e			      ld    E, (HL) 
151d 23			      inc   HL 
151e 56			      ld    D, (HL) 
151f e5			      push  HL                      ; Save freed block ptr for later 
1520			 
1520 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1523 dd 66 03		      ld    H, (IX+3) 
1526 73			      ld    (HL), E 
1527 23			      inc   HL 
1528 72			      ld    (HL), D 
1529			 
1529 e1			      pop   HL                      ; Restore freed block ptr 
152a 23			      inc   HL                      ; Load size of freed block into DE 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e d5			      push  DE                      ; Save freed block size for later 
152f			 
152f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1532 dd 66 03		      ld    H, (IX+3) 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 5e			      ld    E, (HL) 
1538 23			      inc   HL 
1539 56			      ld    D, (HL) 
153a			 
153a e1			      pop   HL                      ; Add sizes of both blocks 
153b 19			      add   HL, DE 
153c eb			      ex    DE, HL 
153d			 
153d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1540 dd 66 03		      ld    H, (IX+3) 
1543 23			      inc   HL 
1544 23			      inc   HL 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548			free_done: 
1548 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
154b 39			      add   HL, SP 
154c f9			      ld    SP, HL 
154d			 
154d			free_early_exit: 
154d dd e1		      pop   IX 
154f d1			      pop   DE 
1550 c1			      pop   BC 
1551			 
1551 c9			      ret 
1552			 
1552			; moved to firmware.asm 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			;                  .dw   0 
1552			 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_3 
1552			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1552			;heap_start        .equ  0x9000      ; Starting address of heap 
1552			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1552			; 
1552			 ;     .org 0 
1552			  ;    jp    main 
1552			; 
1552			; 
1552			 ;     .org  0x100 
1552			;main: 
1552			 ;     ld    HL, 0x8100 
1552			  ;    ld    SP, HL 
1552			; 
1552			;      call  heap_init 
1552			 
1552			      ; Make some allocations 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9004 
1552			; 
1552			 ;     ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9014 
1552			 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9024 
1552			 
1552			      ; Free some allocations 
1552			;      ld    HL, 0x9014 
1552			;      call  free 
1552			 
1552			;      ld    HL, 0x9004 
1552			;      call  free 
1552			; 
1552			;      ld    HL, 0x9024 
1552			;      call  free 
1552			 
1552			 
1552			 ;     halt 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     heap_init                                                               : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Initialise the heap and make it ready for malloc and free operations.   : 
1552			;                                                                             : 
1552			;     The heap is maintained as a linked list, starting with an initial       : 
1552			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1552			;     the first free block in the heap. Each block then points to the next    : 
1552			;     free block within the heap, and the free list ends at the first block   : 
1552			;     with a null pointer to the next free block.                             : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     Inputs are compile-time only. Two defines which specify the starting    : 
1552			;     address of the heap and its size are required, along with a memory      : 
1552			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1552			;     principally stores a pointer to the first free block in the heap.       : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;------------------------------------------------------------------------------ 
1552			heap_init: 
1552			      push  HL 
1552			 
1552			      ; Initialise free list struct 
1552			      ld    HL, heap_start 
1552			      ld    (free_list), HL 
1552			      ld    HL, 0 
1552			      ld    (free_list+2), HL 
1552			 
1552			      ; Insert first free block at bottom of heap, consumes entire heap 
1552			      ld    HL, heap_start+heap_size-4 
1552			      ld    (heap_start), HL        ; Next block (end of free list) 
1552			      ld    HL, heap_size-4 
1552			      ld    (heap_start+2), HL      ; Block size 
1552			 
1552			      ; Insert end of free list block at top of heap - two null words will 
1552			      ; terminate the free list 
1552			      ld    HL, 0 
1552			      ld    (heap_start+heap_size-2), HL 
1552			      ld    (heap_start+heap_size-4), HL 
1552			 
1552			      pop   HL 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     malloc                                                                  : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Allocates the wanted space from the heap and returns the address of the : 
1552			;     first useable byte of the allocation.                                   : 
1552			;                                                                             : 
1552			;     Allocations can happen in one of two ways:                              : 
1552			;                                                                             : 
1552			;     1. A free block may be found which is the exact size wanted. In this    : 
1552			;        case the block is removed from the free list and retuedn to the      : 
1552			;        caller.                                                              : 
1552			;     2. A free block may be found which is larger than the size wanted. In   : 
1552			;        this case, the larger block is split into two. The first portion of  : 
1552			;        this block will become the requested space by the malloc call and    : 
1552			;        is returned to the caller. The second portion becomes a new free     : 
1552			;        block, and the free list is adjusted to maintain continuity via this : 
1552			;        newly created block.                                                 : 
1552			;                                                                             : 
1552			;     malloc does not set any initial value in the allocated space, the       : 
1552			;     caller is required to do this as required.                              : 
1552			;                                                                             : 
1552			;     This implementation of malloc uses the stack exclusively, and is        : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling malloc, and recommended  : 
1552			;     to avoid the use of malloc inside ISRs in general.                      : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Number of bytes wanted                                              : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     HL  Address of the first useable byte of the allocation                 : 
1552			;                                                                             : 
1552			; Flags                                                                       : 
1552			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +4  +-------------+                                                       : 
1552			;       |  this_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			malloc: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if no space requested 
1552			      or    L 
1552			      jp    Z, malloc_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; Setup initial state 
1552			      ld    HL, 4                   ; want must also include space used by block struct 
1552			      add   HL, DE 
1552			 
1552			      ld    B, H                    ; Move want to BC 
1552			      ld    C, L 
1552			 
1552			      ld    HL, free_list           ; Store prev_free ptr to stack 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    E, (HL)                 ; Store this_free ptr to stack 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ld    (IX+2), E 
1552			      ld    (IX+3), D 
1552			      ex    DE, HL                  ; this_free ptr into HL 
1552			 
1552			      ; Loop through free block list to find some space 
1552			malloc_find_space: 
1552			      ld    E, (HL)                 ; Load next_free ptr into DE 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1552			      or    E 
1552			      jp    Z, malloc_no_space 
1552			 
1552			      ld    (IX+0), E               ; Store next_free ptr to stack 
1552			      ld    (IX+1), D 
1552			 
1552			      ; Does this block have enough space to make the allocation? 
1552			      inc   HL                      ; Load free block size into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ex    DE, HL                  ; Check size of block against want 
1552			      or    A                       ; Ensure carry flag clear 
1552			      sbc   HL, BC 
1552			      push  HL                      ; Store the result for later (new block size) 
1552			 
1552			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1552			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1552			 
1552			      ; this_free block is not big enough, setup ptrs to test next free block 
1552			      pop   HL                      ; Discard previous result 
1552			 
1552			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1552			      ld    H, (IX+3) 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1552			      ld    H, (IX+1) 
1552			      ld    (IX+2), L 
1552			      ld    (IX+3), H 
1552			 
1552			      jr    malloc_find_space 
1552			 
1552			      ; split a bigger block into two - requested size and remaining size 
1552			malloc_alloc_split: 
1552			      ex    DE, HL                  ; Calculate address of new free block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      add   HL, BC 
1552			 
1552			      ; Create a new block and point it at next_free 
1552			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      ld    (HL), E                 ; Store next_free ptr into new block 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   DE                      ; Store size of new block into new block 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Update this_free ptr to point to new block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1552			      ld    (IX+3), H 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store want size into allocated block 
1552			      ld    (HL), C 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			      inc   HL 
1552			      push  HL                      ; Address of allocation to return 
1552			 
1552			      jr    malloc_update_links 
1552			 
1552			malloc_alloc_fit: 
1552			      pop   HL                      ; Dont need new block size, want is exact fit 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store address of allocation to return 
1552			      inc   HL 
1552			      inc   HL 
1552			      push  HL 
1552			 
1552			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1552			      ld    L, (IX+0)               ; next_free to HL 
1552			      ld    H, (IX+1) 
1552			 
1552			      ld    (IX+2), L               ; HL to this_free 
1552			      ld    (IX+3), H 
1552			 
1552			 
1552			malloc_update_links: 
1552			      ; Update prev_free ptr to point to this_free 
1552			      ld    L, (IX+4)               ; prev_free ptr to HL 
1552			      ld    H, (IX+5) 
1552			 
1552			      ld    E, (IX+2)               ; this_free ptr to DE 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (HL), E                 ; this_free ptr into prev_free 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Clear the Z flag to indicate successful allocation 
1552			      ld    A, D 
1552			      or    E 
1552			 
1552			      pop   DE                      ; Address of allocation 
1552			 
1552			malloc_no_space: 
1552			      ld    HL, 6                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			      ex    DE, HL                  ; Alloc addr into HL for return 
1552			 
1552			malloc_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     free                                                                    : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1552			;     returned by malloc, otherwise the behaviour is undefined.               : 
1552			;                                                                             : 
1552			;     Where possible, directly adjacent free blocks will be merged together   : 
1552			;     into larger blocks to help ensure that the heap does not become         : 
1552			;     excessively fragmented.                                                 : 
1552			;                                                                             : 
1552			;     free does not clear or set any other value into the freed space, and    : 
1552			;     therefore its contents may be visible through subsequent malloc's. The  : 
1552			;     caller should clear the freed space as required.                        : 
1552			;                                                                             : 
1552			;     This implementation of free uses the stack exclusively, and is          : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling free, and recommended    : 
1552			;     to avoid the use of free inside ISRs in general.                        : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Pointer to address of first byte of allocation to be freed          : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			free: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if ptr is null 
1552			      or    L 
1552			      jp    Z, free_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; The address in HL points to the start of the useable allocated space, 
1552			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1552			      ; address of the block itself. 
1552			      ex    DE, HL 
1552			      ld    DE, -4 
1552			      add   HL, DE 
1552			 
1552			      ; An allocated block must have a null next block pointer in it 
1552			      ld    A, (HL) 
1552			      inc   HL 
1552			      or    (HL) 
1552			      jp    NZ, free_done 
1552			 
1552			      dec   HL 
1552			 
1552			      ld    B, H                    ; Copy HL to BC 
1552			      ld    C, L 
1552			 
1552			      ; Loop through the free list to find the first block with an address 
1552			      ; higher than the block being freed 
1552			      ld    HL, free_list 
1552			 
1552			free_find_higher_block: 
1552			      ld    E, (HL)                 ; Load next ptr from free block 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			 
1552			      ld    (IX+0), E               ; Save ptr to next free block 
1552			      ld    (IX+1), D 
1552			      ld    (IX+2), L               ; Save ptr to prev free block 
1552			      ld    (IX+3), H 
1552			 
1552			      ld    A, B                    ; Check if DE is greater than BC 
1552			      cp    D                       ; Compare MSB first 
1552			      jr    Z, $+4                  ; MSB the same, compare LSB 
1552			      jr    NC, free_find_higher_block_skip 
1552			      ld    A, C 
1552			      cp    E                       ; Then compare LSB 
1552			      jr    C, free_found_higher_block 
1552			 
1552			free_find_higher_block_skip: 
1552			      ld    A, D                    ; Reached the end of the free list? 
1552			      or    E 
1552			      jp    Z, free_done 
1552			 
1552			      ex    DE, HL 
1552			 
1552			      jr    free_find_higher_block 
1552			 
1552			free_found_higher_block: 
1552			      ; Insert freed block between prev and next free blocks 
1552			      ld    (HL), C                 ; Point prev free block to freed block 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			 
1552			      ld    H, B                    ; Point freed block at next free block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Check if the freed block is adjacent to the next free block 
1552			      inc   HL                      ; Load size of freed block into HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      add   HL, BC                  ; Add addr of freed block and its size 
1552			 
1552			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_check_adjacent_to_prev 
1552			 
1552			      ; Freed block is adjacent to next, merge into one bigger block 
1552			      ex    DE, HL                  ; Load next ptr from next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save ptr to next block for later 
1552			 
1552			      ld    H, B                    ; Store ptr from next block into freed block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore ptr to next block 
1552			      inc   HL                      ; Load size of next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save next block size for later 
1552			 
1552			      ld    H, B                    ; Load size of freed block into HL 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      pop   DE                      ; Restore size of next block 
1552			      add   HL, DE                  ; Add sizes of both blocks 
1552			      ex    DE, HL 
1552			 
1552			      ld    H, B                    ; Store new bigger size into freed block 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_check_adjacent_to_prev: 
1552			      ; Check if the freed block is adjacent to the prev free block 
1552			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1552			      ld    H, (IX+3) 
1552			 
1552			      inc   HL                      ; Size of prev free block into DE 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      add   HL, DE                  ; Add prev block addr and size 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_done 
1552			 
1552			      ; Freed block is adjacent to prev, merge into one bigger block 
1552			      ld    H, B                    ; Load next ptr from freed block into DE 
1552			      ld    L, C 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save freed block ptr for later 
1552			 
1552			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1552			      ld    H, (IX+3) 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore freed block ptr 
1552			      inc   HL                      ; Load size of freed block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save freed block size for later 
1552			 
1552			      ld    L, (IX+2)               ; Load size of prev block into DE 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      pop   HL                      ; Add sizes of both blocks 
1552			      add   HL, DE 
1552			      ex    DE, HL 
1552			 
1552			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_done: 
1552			      ld    HL, 4                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			free_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;      .org 0x8000 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			 ;                 .dw   0 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_4 
1552			 
1552			; My memory allocation code. Very very simple.... 
1552			; allocate space under 250 chars 
1552			 
1552			heap_init: 
1552				; init start of heap as zero 
1552				;  
1552			 
1552				ld hl, heap_start 
1552				ld a, 0 
1552				ld (hl), a      ; empty block 
1552				inc hl 
1552				ld a, 0 
1552				ld (hl), a      ; length of block 
1552				; write end of list 
1552				inc hl 
1552				ld a,(hl) 
1552				inc hl 
1552				ld a,(hl) 
1552				 
1552			 
1552				; init some malloc vars 
1552			 
1552				ld hl, 0 
1552				ld (free_list), hl       ; store last malloc location 
1552			 
1552				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1552				ld a, 0 
1552				ld (hl), a 
1552			 
1552			 
1552				ld hl, heap_start 
1552				;  
1552				  
1552				ret 
1552			 
1552			 
1552			;    free block marker 
1552			;    requested size  
1552			;    pointer to next block 
1552			;    .... 
1552			;    next block marker 
1552			 
1552			 
1552			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1552			; 
1552			 
1552			 
1552			malloc:  
1552				push de 
1552				push bc 
1552				push af 
1552			 
1552				; hl space required 
1552				 
1552				ld c, l    ; hold space   (TODO only a max of 255) 
1552			 
1552			;	inc c     ; TODO BUG need to fix memory leak on push str 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			 
1552			 
1552			 
1552				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1552			 
1552				ld a, (free_list+3) 
1552				cp 0 
1552				jr z, .contheap 
1552			 
1552				ld hl, (free_list)     ; get last alloc 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mrs" 
1552						CALLMONITOR 
1552					endif 
1552				jr .startalloc 
1552			 
1552			.contheap: 
1552				ld hl, heap_start 
1552			 
1552			.startalloc: 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mym" 
1552						CALLMONITOR 
1552					endif 
1552			.findblock: 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmf" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552				ld a,(hl)  
1552				; if byte is zero then clear to use 
1552			 
1552				cp 0 
1552				jr z, .foundemptyblock 
1552			 
1552				; if byte is not clear 
1552				;     then byte is offset to next block 
1552			 
1552				inc hl 
1552				ld a, (hl) ; get size 
1552			.nextblock:	inc hl 
1552					ld e, (hl) 
1552					inc hl 
1552					ld d, (hl) 
1552					ex de, hl 
1552			;	inc hl  ; move past the store space 
1552			;	inc hl  ; move past zero index  
1552			 
1552				; TODO detect no more space 
1552			 
1552				push hl 
1552				ld de, heap_end 
1552				call cmp16 
1552				pop hl 
1552				jr nc, .nospace 
1552			 
1552				jr .findblock 
1552			 
1552			.nospace: ld hl, 0 
1552				jp .exit 
1552			 
1552			 
1552			.foundemptyblock:	 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mme" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; TODO has block enough space if reusing??? 
1552			 
1552				;  
1552			 
1552			; see if this block has been previously used 
1552				inc hl 
1552				ld a, (hl) 
1552				dec hl 
1552				cp 0 
1552				jr z, .newblock 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meR" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; no reusing previously allocated block 
1552			 
1552			; is it smaller than previously used? 
1552				 
1552				inc hl    ; move to size 
1552				ld a, c 
1552				sub (hl)        ; we want c < (hl) 
1552				dec hl    ; move back to marker 
1552			        jr z, .findblock 
1552			 
1552				; update with the new size which should be lower 
1552			 
1552			        ;inc  hl   ; negate next move. move back to size  
1552			 
1552			.newblock: 
1552				; need to be at marker here 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meN" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			 
1552				ld a, c 
1552			 
1552				ld (free_list+3), a	 ; flag resume from last malloc  
1552				ld (free_list), hl    ; save out last location 
1552			 
1552			 
1552				;inc a     ; space for length byte 
1552				ld (hl), a     ; save block in use marker 
1552			 
1552				inc hl   ; move to space marker 
1552				ld (hl), a    ; save new space 
1552			 
1552				inc hl   ; move to start of allocated area 
1552				 
1552			;	push hl     ; save where we are - 1  
1552			 
1552			;	inc hl  ; move past zero index  
1552				; skip space to set down new marker 
1552			 
1552				; provide some extra space for now 
1552			 
1552				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1552				inc a 
1552				inc a 
1552			 
1552				push hl   ; save where we are in the node block 
1552			 
1552				call addatohl 
1552			 
1552				; write linked list point 
1552			 
1552				pop de     ; get our node position 
1552				ex de, hl 
1552			 
1552				ld (hl), e 
1552				inc hl 
1552				ld (hl), d 
1552			 
1552				inc hl 
1552			 
1552				; now at start of allocated data so save pointer 
1552			 
1552				push hl 
1552			 
1552				; jump to position of next node and setup empty header in DE 
1552			 
1552				ex de, hl 
1552			 
1552			;	inc hl ; move past end of block 
1552			 
1552				ld a, 0 
1552				ld (hl), a   ; empty marker 
1552				inc hl 
1552				ld (hl), a   ; size 
1552				inc hl  
1552				ld (hl), a   ; ptr 
1552				inc hl 
1552				ld (hl), a   ; ptr 
1552			 
1552			 
1552				pop hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmr" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			.exit: 
1552				pop af 
1552				pop bc 
1552				pop de  
1552				ret 
1552			 
1552			 
1552			 
1552			 
1552			free:  
1552				push hl 
1552				push af 
1552				; get address in hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "fre" 
1552						CALLMONITOR 
1552					endif 
1552				; data is at hl - move to block count 
1552				dec hl 
1552				dec hl    ; get past pointer 
1552				dec hl 
1552			 
1552				ld a, (hl)    ; need this for a validation check 
1552			 
1552				dec hl    ; move to block marker 
1552			 
1552				; now check that the block count and block marker are the same  
1552			        ; this checks that we are on a malloc node and not random memory 
1552			        ; OK a faint chance this could be a problem but rare - famous last words! 
1552			 
1552				ld c, a 
1552				ld a, (hl)    
1552			 
1552				cp c 
1552				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1552			 
1552				; yes good chance we are on a malloc node 
1552			 
1552				ld a, 0      
1552				ld (hl), a   ; mark as free 
1552			 
1552				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1552			 
1552			.freeignore:  
1552			 
1552				pop af 
1552				pop hl 
1552			 
1552				ret 
1552			 
1552			 
1552			 
1552			endif 
1552			 
1552			; eof 
# End of file firmware_memory.asm
1552			  
1552			; device C  
1552			; Now handled by SPI  
1552			;if SOUND_ENABLE  
1552			;	include "firmware_sound.asm"  
1552			;endif  
1552			  
1552			include "firmware_diags.asm"  
1552			; Hardware diags menu 
1552			 
1552			 
1552			config: 
1552			 
1552 3e 00			ld a, 0 
1554 21 7d 15			ld hl, .configmn 
1557 cd db 0d			call menu 
155a			 
155a fe 00			cp 0 
155c c8				ret z 
155d			 
155d			;	cp 1 
155d			;	call z, .savetostore 
155d			 
155d fe 01			cp 1 
155f			if STARTUP_V1 
155f				call z, .selautoload 
155f			endif 
155f			 
155f			if STARTUP_V2 
155f cc 8b 15			call z, .enautoload 
1562			endif 
1562 fe 02			cp 2 
1564 cc a2 15			call z, .disautoload 
1567			;	cp 3 
1567			;	call z, .selbank 
1567 fe 03			cp 3 
1569 cc 0d 18			call z, .debug_tog 
156c fe 04			cp 4 
156e cc 5b 19			call z, .bpsgo 
1571 fe 05			cp 5 
1573 cc 36 18			call z, hardware_diags 
1576			if STARTUP_V2 
1576 fe 06			cp 6 
1578 cc ce 15			call z, create_startup 
157b			endif 
157b 18 d5			jr config 
157d			 
157d			.configmn: 
157d			;	dw prom_c3 
157d 49 1b			dw prom_c2 
157f 5f 1b			dw prom_c2a 
1581			;	dw prom_c2b 
1581			;	dw prom_c4 
1581 d6 1b			dw prom_m4 
1583 f1 1b			dw prom_m4b 
1585 f9 1b			dw prom_c1 
1587			if STARTUP_V2 
1587 08 1c			dw prom_c9 
1589			endif 
1589 00 00			dw 0 
158b				 
158b			 
158b			if STARTUP_V2 
158b			.enautoload: 
158b				if STORAGE_SE 
158b 3e fe			ld a, $fe      ; bit 0 clear 
158d 32 95 f9			ld (spi_device), a 
1590			 
1590 cd 25 05			call storage_get_block_0 
1593			 
1593 3e 01			ld a, 1 
1595 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
1598			 
1598 21 00 00				ld hl, 0 
159b 11 af f9				ld de, store_page 
159e cd d9 04			call storage_write_block	 ; save update 
15a1				else 
15a1			 
15a1				ld hl, prom_notav 
15a1				ld de, prom_empty 
15a1				call info_panel 
15a1				endif 
15a1			 
15a1			 
15a1 c9				ret 
15a2			endif 
15a2			 
15a2			.disautoload: 
15a2				if STORAGE_SE 
15a2 3e fe			ld a, $fe      ; bit 0 clear 
15a4 32 95 f9			ld (spi_device), a 
15a7			 
15a7 cd 25 05			call storage_get_block_0 
15aa			 
15aa 3e 00			ld a, 0 
15ac 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
15af			 
15af 21 00 00				ld hl, 0 
15b2 11 af f9				ld de, store_page 
15b5 cd d9 04			call storage_write_block	 ; save update 
15b8				else 
15b8			 
15b8				ld hl, prom_notav 
15b8				ld de, prom_empty 
15b8				call info_panel 
15b8				endif 
15b8			 
15b8			 
15b8 c9				ret 
15b9			 
15b9			if STARTUP_V1 
15b9			 
15b9			; Select auto start 
15b9			 
15b9			.selautoload: 
15b9			 
15b9				 
15b9				if STORAGE_SE 
15b9			 
15b9					call config_dir 
15b9				        ld hl, scratch 
15b9					ld a, 0 
15b9					call menu 
15b9			 
15b9					cp 0 
15b9					ret z 
15b9			 
15b9					dec a 
15b9			 
15b9			 
15b9					; locate menu option 
15b9			 
15b9					ld hl, scratch 
15b9					call table_lookup 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALl" 
15b9						CALLMONITOR 
15b9					endif 
15b9					; with the pointer to the menu it, the byte following the zero term is the file id 
15b9			 
15b9					ld a, 0 
15b9					ld bc, 50   ; max of bytes to look at 
15b9					cpir  
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALb" 
15b9						CALLMONITOR 
15b9					endif 
15b9					;inc hl 
15b9			 
15b9					ld a, (hl)   ; file id 
15b9					 
15b9				        ; save bank and file ids 
15b9			 
15b9					push af 
15b9			 
15b9			; TODO need to save to block 0 on bank 1	 
15b9			 
15b9					call storage_get_block_0 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "AL0" 
15b9						CALLMONITOR 
15b9					endif 
15b9					pop af 
15b9			 
15b9					ld (store_page+STORE_0_FILERUN),a 
15b9					 
15b9					; save bank id 
15b9			 
15b9					ld a,(spi_device) 
15b9					ld (store_page+STORE_0_BANKRUN),a 
15b9			 
15b9					; enable auto run of store file 
15b9			 
15b9					ld a, 1 
15b9					ld (store_page+STORE_0_AUTOFILE),a 
15b9			 
15b9					; save buffer 
15b9			 
15b9					ld hl, 0 
15b9					ld de, store_page 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALw" 
15b9						CALLMONITOR 
15b9					endif 
15b9				call storage_write_block	 ; save update 
15b9			  
15b9			 
15b9			 
15b9			 
15b9					ld hl, scratch 
15b9					call config_fdir 
15b9			 
15b9				else 
15b9			 
15b9				ld hl, prom_notav 
15b9				ld de, prom_empty 
15b9				call info_panel 
15b9			 
15b9				endif 
15b9				ret 
15b9			endif 
15b9			 
15b9			 
15b9			; Select storage bank 
15b9			 
15b9			.selbank: 
15b9			 
15b9			;	if STORAGE_SE 
15b9			;	else 
15b9			 
15b9 21 1d 1c			ld hl, prom_notav 
15bc 11 33 1c			ld de, prom_empty 
15bf cd 3b 0d			call info_panel 
15c2			;	endif 
15c2				 
15c2 c9				ret 
15c3			 
15c3			if STORAGE_SE 
15c3			 
15c3			.config_ldir:   
15c3				; Load storage bank labels into menu array 
15c3			 
15c3				 
15c3			 
15c3			 
15c3 c9				ret 
15c4			 
15c4			 
15c4			endif 
15c4			 
15c4			 
15c4			; Save user words to storage 
15c4			 
15c4			.savetostore: 
15c4			 
15c4			;	if STORAGE_SE 
15c4			; 
15c4			;		call config_dir 
15c4			;	        ld hl, scratch 
15c4			;		ld a, 0 
15c4			;		call menu 
15c4			;		 
15c4			;		ld hl, scratch 
15c4			;		call config_fdir 
15c4			; 
15c4			;	else 
15c4			 
15c4 21 1d 1c			ld hl, prom_notav 
15c7 11 33 1c			ld de, prom_empty 
15ca cd 3b 0d			call info_panel 
15cd			 
15cd			;	endif 
15cd			 
15cd c9				ret 
15ce			 
15ce			if STARTUP_V2 
15ce			 
15ce			create_startup: 
15ce			 
15ce 3e 00			ld a, 0 
15d0 21 32 17			ld hl, .crstart 
15d3 cd db 0d			call menu 
15d6			 
15d6 fe 00			cp 0 
15d8 c8				ret z 
15d9			 
15d9 fe 01			cp 1 
15db cc 17 16			call z, .genlsword 
15de fe 02			cp 2 
15e0 cc 21 16			call z, .genedword 
15e3			 
15e3 fe 03			cp 3 
15e5 cc 2b 16			call z, .gendemword 
15e8			 
15e8 fe 04			cp 4 
15ea cc 35 16			call z, .genutlword 
15ed fe 05			cp 5 
15ef cc 3f 16			call z, .genspiword 
15f2 fe 06			cp 6 
15f4 cc 49 16			call z, .genkeyword 
15f7 fe 07			cp 7 
15f9 cc 0d 16			call z, .gensoundword 
15fc fe 08			cp 8 
15fe cc 03 16			call z, .genhwword 
1601 18 cb			jr create_startup 
1603			 
1603			.genhwword: 
1603 21 c0 1b			ld hl, crs_hw 
1606 11 96 16			ld de, .hwworddef 
1609 cd 53 16			call .genfile 
160c c9				ret 
160d			.gensoundword: 
160d 21 b4 1b			ld hl, crs_sound 
1610 11 a4 16			ld de, .soundworddef 
1613 cd 53 16			call .genfile 
1616 c9				ret 
1617			.genlsword: 
1617 21 76 1b			ld hl, crs_s1 
161a 11 ca 16			ld de, .lsworddef 
161d cd 53 16			call .genfile 
1620 c9				ret 
1621			 
1621			.genedword: 
1621 11 ce 16			ld de, .edworddef 
1624 21 7f 1b			ld hl, crs_s2 
1627 cd 53 16			call .genfile 
162a c9				ret 
162b			 
162b			.gendemword: 
162b 11 d6 16			ld de, .demoworddef 
162e 21 88 1b			ld hl, crs_s3 
1631 cd 53 16			call .genfile 
1634 c9				ret 
1635			 
1635			.genutlword: 
1635 21 94 1b			ld hl, crs_s4 
1638 11 b8 16			ld de, .utilwordef 
163b cd 53 16			call .genfile 
163e c9				ret 
163f			.genspiword: 
163f 21 9b 1b			ld hl, crs_s5 
1642 11 f8 16			ld de, .spiworddef 
1645 cd 53 16			call .genfile 
1648 c9				ret 
1649			.genkeyword: 
1649 21 a5 1b			ld hl, crs_s6 
164c 11 06 17			ld de, .keyworddef 
164f cd 53 16			call .genfile 
1652 c9				ret 
1653			 
1653			; hl - points to file name 
1653			; de - points to strings to add to file 
1653			 
1653			.genfile: 
1653 e5				push hl 
1654 d5				push de 
1655			 
1655 cd aa 0d			call clear_display 
1658 3e 00			ld a, display_row_1 
165a 11 85 16			ld de, .genfiletxt 
165d cd bd 0d			call str_at_display 
1660 cd cd 0d			call update_display 
1663			 
1663 d1				pop de 
1664 e1				pop hl 
1665			 
1665			 
1665 d5				push de 
1666 cd 77 08			call storage_create 
1669				; id in hl 
1669 d1				pop de   ; table of strings to add 
166a			 
166a			.genloop: 
166a			 
166a e5				push hl ; save id for next time around 
166b d5				push de ; save de for next time around 
166c			 
166c eb				ex de, hl 
166d cd ba 23			call loadwordinhl 
1670 eb				ex de, hl 
1671			 
1671				; need hl to be the id 
1671				; need de to be the string ptr 
1671				 
1671 cd 64 0b			call storage_append 
1674			 
1674 d1				pop de 
1675 e1				pop hl 
1676			 
1676 13				inc de 
1677 13				inc de 
1678			 
1678 1a				ld a,(de) 
1679 fe 00			cp 0 
167b 20 ed			jr nz, .genloop 
167d 13				inc de 
167e 1a				ld a, (de) 
167f 1b				dec de 
1680 fe 00			cp 0 
1682 20 e6			jr nz, .genloop	 
1684			 
1684 c9				ret 
1685			 
1685 .. 00		.genfiletxt:  db "Creating file...",0 
1696			 
1696			.hwworddef: 
1696 95 68			dw test5 
1698 cd 68			dw test6 
169a 05 69			dw test7 
169c 19 69			dw test8 
169e 45 69			dw test9 
16a0 5b 69			dw test10 
16a2 00 00			dw 0 
16a4			 
16a4			.soundworddef: 
16a4 80 69			dw sound1 
16a6 a4 69			dw sound2 
16a8 d4 69			dw sound3 
16aa f9 69			dw sound4 
16ac 06 6a			dw sound5 
16ae 13 6a			dw sound6 
16b0 20 6a			dw sound7 
16b2 2d 6a			dw sound8 
16b4 45 6a			dw sound9 
16b6 00 00			dw 0 
16b8			 
16b8			.utilwordef: 
16b8 bb 66			dw strncpy 
16ba 96 66			dw type 
16bc 18 68			dw tuck 
16be 62 66			dw clrstack 
16c0 1b 66			dw longread 
16c2 1c 67			dw start1 
16c4 2c 67			dw start2 
16c6			; duplicated 
16c6			;	dw start3b 
16c6			;	dw start3c 
16c6 2b 68			dw list 
16c8 00 00			dw 0 
16ca			 
16ca			.lsworddef: 
16ca 3d 67			dw start3b 
16cc 00 00			dw 0 
16ce			 
16ce			.edworddef: 
16ce 7a 62			dw edit1 
16d0 9b 62			dw edit2 
16d2 d0 62			dw edit3 
16d4 00 00			dw 0 
16d6			 
16d6			.demoworddef: 
16d6 5c 6a			dw game1 
16d8 6d 6a			dw game1a 
16da cf 6a			dw game1b 
16dc 04 6b			dw game1c 
16de 3a 6b			dw game1d 
16e0 6b 6b			dw game1s 
16e2 7f 6b			dw game1t 
16e4 94 6b			dw game1f 
16e6 c8 6b			dw game1z 
16e8 0c 6c			dw game1zz 
16ea 75 6c			dw ssv2 
16ec ab 6c			dw ssv3 
16ee c7 6c			dw ssv4 
16f0 e3 6c			dw ssv5 
16f2 fc 6c			dw ssv1 
16f4 44 6d			dw ssv1cpm	 
16f6			;	dw game2b 
16f6			;	dw game2bf 
16f6			;	dw game2mba 
16f6			;	dw game2mbas	 
16f6			;	dw game2mbht 
16f6			;	dw game2mbms 
16f6			;	dw game2mb 
16f6			;	dw game3w 
16f6			;	dw game3p 
16f6			;	dw game3sc 
16f6			;	dw game3vsi 
16f6			;	dw game3vs 
16f6 00 00			dw 0 
16f8			 
16f8			 
16f8			.spiworddef: 
16f8			 
16f8 08 63		    dw spi1 
16fa 61 63		    dw spi2 
16fc 95 63		    dw spi2b 
16fe 19 64		    dw spi3 
1700 c3 63		    dw spi4 
1702 ec 63		    dw spi5 
1704			;    dw spi6 
1704			;    dw spi7 
1704			 
1704			;    dw spi8 
1704			;    dw spi9 
1704			;    dw spi10 
1704 00 00		    dw 0 
1706			 
1706			.keyworddef: 
1706			 
1706 9b 6d			dw keyup 
1708 a9 6d			dw keydown 
170a b9 6d			dw keyleft 
170c c9 6d			dw keyright 
170e da 6d			dw 	keyf1 
1710 e8 6d			dw keyf2 
1712 f6 6d			dw keyf3 
1714 04 6e			dw keyf4 
1716 12 6e			dw keyf5 
1718 20 6e			dw keyf6 
171a 2e 6e			dw keyf7 
171c 3c 6e			dw keyf8 
171e 4a 6e			dw keyf9 
1720 58 6e			dw keyf10 
1722 67 6e			dw keyf11 
1724 76 6e			dw keyf12 
1726 85 6e			dw keytab 
1728 94 6e			dw keycr 
172a a2 6e			dw keyhome 
172c b2 6e			dw keyend 
172e c1 6e			dw keybs 
1730 00 00			dw 0 
1732			 
1732			.crstart: 
1732 76 1b			dw crs_s1 
1734 7f 1b			dw crs_s2 
1736 88 1b			dw crs_s3 
1738 94 1b			dw crs_s4 
173a 9b 1b			dw crs_s5 
173c a5 1b			dw crs_s6 
173e b4 1b			dw crs_sound 
1740 c0 1b			dw crs_hw 
1742 00 00			dw 0 
1744			 
1744			endif 
1744			 
1744			 
1744			if STORAGE_SE 
1744			 
1744			config_fdir: 
1744				; using the scratch dir go through and release the memory allocated for each string 
1744				 
1744 21 f6 f0			ld hl, scratch 
1747 5e			.cfdir:	ld e,(hl) 
1748 23				inc hl 
1749 56				ld d,(hl) 
174a 23				inc hl 
174b			 
174b eb				ex de, hl 
174c cd 07 10			call ishlzero 
174f c8				ret z     ; return on null pointer 
1750 cd 83 14			call free 
1753 eb				ex de, hl 
1754 18 f1			jr .cfdir 
1756			 
1756			 
1756 c9				ret 
1757			 
1757			 
1757			config_dir: 
1757			 
1757				; for the config menus that need to build a directory of storage call this routine 
1757				; it will construct a menu in scratch to pass to menu 
1757			 
1757				; open storage device 
1757			 
1757				; execute DIR to build a list of files and their ids into scratch in menu format 
1757				; once the menu has finished then will need to call config_fdir to release the strings 
1757				 
1757				; c = number items 
1757			 
1757				 
1757 cd 25 05			call storage_get_block_0 
175a			 
175a 21 af f9			ld hl, store_page     ; get current id count 
175d 46				ld b, (hl) 
175e 0e 00			ld c, 0    ; count of files   
1760			 
1760			 
1760 21 f6 f0			ld hl, scratch 
1763 22 a6 f9			ld (store_tmp2), hl    ; location to poke strings 
1766			 
1766				; check for empty drive 
1766			 
1766 3e 00			ld a, 0 
1768 b8				cp b 
1769 ca 03 18			jp z, .dirdone 
176c			 
176c				 
176c					if DEBUG_FORTH_WORDS 
176c						DMARK "Cdc" 
176c f5				push af  
176d 3a 81 17			ld a, (.dmark)  
1770 32 a0 fd			ld (debug_mark),a  
1773 3a 82 17			ld a, (.dmark+1)  
1776 32 a1 fd			ld (debug_mark+1),a  
1779 3a 83 17			ld a, (.dmark+2)  
177c 32 a2 fd			ld (debug_mark+2),a  
177f 18 03			jr .pastdmark  
1781 ..			.dmark: db "Cdc"  
1784 f1			.pastdmark: pop af  
1785			endm  
# End of macro DMARK
1785						CALLMONITOR 
1785 cd aa fd			call debug_vector  
1788				endm  
# End of macro CALLMONITOR
1788					endif 
1788			 
1788			 
1788			.diritem:	 
1788 c5				push bc 
1789				; for each of the current ids do a search for them and if found push to stack 
1789			 
1789 21 40 00				ld hl, STORE_BLOCK_PHY 
178c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
178e 58					ld e,b 
178f			 
178f cd a7 07				call storage_findnextid 
1792			 
1792			 
1792					; if found hl will be non zero 
1792			 
1792 cd 07 10				call ishlzero 
1795 28 69				jr z, .dirnotfound 
1797			 
1797					; increase count 
1797			 
1797 c1					pop bc	 
1798 0c					inc c 
1799 c5					push bc 
179a					 
179a			 
179a					; get file header and push the file name 
179a			 
179a 11 af f9				ld de, store_page 
179d cd 74 04				call storage_read_block 
17a0			 
17a0					; push file id to stack 
17a0				 
17a0 3a af f9				ld a, (store_page) 
17a3 26 00				ld h, 0 
17a5 6f					ld l, a 
17a6			 
17a6					;call forth_push_numhl 
17a6					; TODO store id 
17a6			 
17a6 e5					push hl 
17a7			 
17a7					; push extent count to stack  
17a7				 
17a7 21 b2 f9				ld hl, store_page+3 
17aa			 
17aa					; get file name length 
17aa			 
17aa cd 44 13				call strlenz   
17ad			 
17ad 23					inc hl   ; cover zero term 
17ae 23					inc hl  ; stick the id at the end of the area 
17af			 
17af e5					push hl 
17b0 c1					pop bc    ; move length to bc 
17b1			 
17b1 cd b9 13				call malloc 
17b4			 
17b4					; TODO save malloc area to scratch 
17b4			 
17b4 eb					ex de, hl 
17b5 2a a6 f9				ld hl, (store_tmp2) 
17b8 73					ld (hl), e 
17b9 23					inc hl 
17ba 72					ld (hl), d 
17bb 23					inc hl 
17bc 22 a6 f9				ld (store_tmp2), hl 
17bf			 
17bf					 
17bf			 
17bf					;pop hl   ; get source 
17bf			;		ex de, hl    ; swap aronund	 
17bf			 
17bf 21 b2 f9				ld hl, store_page+3 
17c2					if DEBUG_FORTH_WORDS 
17c2						DMARK "CFd" 
17c2 f5				push af  
17c3 3a d7 17			ld a, (.dmark)  
17c6 32 a0 fd			ld (debug_mark),a  
17c9 3a d8 17			ld a, (.dmark+1)  
17cc 32 a1 fd			ld (debug_mark+1),a  
17cf 3a d9 17			ld a, (.dmark+2)  
17d2 32 a2 fd			ld (debug_mark+2),a  
17d5 18 03			jr .pastdmark  
17d7 ..			.dmark: db "CFd"  
17da f1			.pastdmark: pop af  
17db			endm  
# End of macro DMARK
17db						CALLMONITOR 
17db cd aa fd			call debug_vector  
17de				endm  
# End of macro CALLMONITOR
17de					endif 
17de ed b0				ldir 
17e0			 
17e0					; de is past string, move back one and store id 
17e0					 
17e0 1b					dec de 
17e1			 
17e1					; store file id 
17e1			 
17e1 e1					pop hl 
17e2 eb					ex de,hl 
17e3 73					ld (hl), e 
17e4			 
17e4					if DEBUG_FORTH_WORDS 
17e4						DMARK "Cdi" 
17e4 f5				push af  
17e5 3a f9 17			ld a, (.dmark)  
17e8 32 a0 fd			ld (debug_mark),a  
17eb 3a fa 17			ld a, (.dmark+1)  
17ee 32 a1 fd			ld (debug_mark+1),a  
17f1 3a fb 17			ld a, (.dmark+2)  
17f4 32 a2 fd			ld (debug_mark+2),a  
17f7 18 03			jr .pastdmark  
17f9 ..			.dmark: db "Cdi"  
17fc f1			.pastdmark: pop af  
17fd			endm  
# End of macro DMARK
17fd						CALLMONITOR 
17fd cd aa fd			call debug_vector  
1800				endm  
# End of macro CALLMONITOR
1800					endif 
1800					 
1800			.dirnotfound: 
1800 c1					pop bc     
1801 10 85				djnz .diritem 
1803				 
1803			.dirdone:	 
1803			 
1803 3e 00				ld a, 0 
1805 2a a6 f9				ld hl, (store_tmp2) 
1808 77					ld (hl), a 
1809 23					inc hl 
180a 77					ld (hl), a 
180b 23					inc hl 
180c					; push a count of the dir items found 
180c			 
180c			;		ld h, 0 
180c			;		ld l, c 
180c			 
180c c9				ret 
180d			 
180d			endif 
180d			 
180d			 
180d			; Settings 
180d			; Run  
180d			 
180d			 
180d			 
180d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
180d			;;hd_menu2:   db "        2: Editor",0   
180d			;hd_menu2:   db "        2: Editor       6: Menu",0   
180d			;hd_menu3:   db "        3: Storage",0 
180d			;hd_menu4:   db "0=quit  4: Debug",0 
180d			;hd_don:     db "ON",0 
180d			;hd_doff:     db "OFF",0 
180d			; 
180d			; 
180d			; 
180d			;hardware_diags_old:       
180d			; 
180d			;.diagmenu: 
180d			;	call clear_display 
180d			;	ld a, display_row_1 
180d			;	ld de, hd_menu1 
180d			;	call str_at_display 
180d			; 
180d			;	ld a, display_row_2 
180d			;	ld de, hd_menu2 
180d			;	call str_at_display 
180d			; 
180d			;	ld a, display_row_3 
180d			;	ld de, hd_menu3 
180d			;	call str_at_display 
180d			; 
180d			;	ld a,  display_row_4 
180d			;	ld de, hd_menu4 
180d			;	call str_at_display 
180d			; 
180d			;	; display debug state 
180d			; 
180d			;	ld de, hd_don 
180d			;	ld a, (os_view_disable) 
180d			;	cp 0 
180d			;	jr z, .distog 
180d			;	ld de, hd_doff 
180d			;.distog: ld a, display_row_4+17 
180d			;	call str_at_display 
180d			; 
180d			;	call update_display 
180d			; 
180d			;	call cin_wait 
180d			; 
180d			; 
180d			; 
180d			;	cp '4' 
180d			;	jr nz, .diagn1 
180d			; 
180d			;	; debug toggle 
180d			; 
180d			;	ld a, (os_view_disable) 
180d			;	ld b, '*' 
180d			;	cp 0 
180d			;	jr z, .debtog 
180d			;	ld b, 0 
180d			;.debtog:	 
180d			;	ld a,b 
180d			;	ld (os_view_disable),a 
180d			; 
180d			;.diagn1: cp '0' 
180d			;	 ret z 
180d			; 
180d			;;	cp '1' 
180d			;;       jp z, matrix	 
180d			;;   TODO keyboard matrix test 
180d			; 
180d			;	cp '2' 
180d			;	jp z, .diagedit 
180d			; 
180d			;;	cp '6' 
180d			;;	jp z, .menutest 
180d			;;if ENABLE_BASIC 
180d			;;	cp '6' 
180d			;;	jp z, basic 
180d			;;endif 
180d			 ; 
180d			;	jp .diagmenu 
180d			; 
180d			; 
180d			;	ret 
180d			 
180d			 
180d			.debug_tog: 
180d 21 57 18			ld hl, .menudebug 
1810				 
1810			;	ld a, (os_view_disable) 
1810			;	cp '*' 
1810 3a aa fd			ld a,(debug_vector) 
1813 fe c9			cp $C9   ; RET 
1815 20 04			jr nz,.tdon  
1817 3e 01			ld a, 1 
1819 18 02			jr .tog1 
181b 3e 00		.tdon: ld a, 0 
181d			 
181d			.tog1: 
181d cd db 0d			call menu 
1820 fe 00			cp 0 
1822 c8				ret z 
1823 fe 01			cp 1    ; disable debug 
1825 28 04			jr z, .dtog0 
1827 3e 2a			ld a, '*' 
1829 18 05			jr .dtogset 
182b			.dtog0:  
182b				;ld a, 0 
182b cd 49 19			call bp_on 
182e 18 dd			jr .debug_tog 
1830			.dtogset:  
1830				; ld (os_view_disable), a 
1830 cd 55 19			call bp_off 
1833 c3 0d 18			jp .debug_tog 
1836			 
1836			 
1836			hardware_diags:       
1836			 
1836			.diagm: 
1836 21 49 18			ld hl, .menuitems 
1839 3e 00			ld a, 0 
183b cd db 0d			call menu 
183e			 
183e fe 00		         cp 0 
1840 c8				 ret z 
1841			 
1841 fe 02			cp 2 
1843 ca a2 18			jp z, .diagedit 
1846			 
1846			;	cp '6' 
1846			;	jp z, .menutest 
1846			;if ENABLE_BASIC 
1846			;	cp '6' 
1846			;	jp z, basic 
1846			;endif 
1846			  
1846 c3 36 18			jp .diagm 
1849			 
1849				 
1849 5d 18		.menuitems:   	dw .m1 
184b 68 18				dw .m2 
184d 6f 18				dw .m3 
184f 77 18				dw .m5 
1851 7d 18				dw .m5a 
1853 86 18				dw .m5b 
1855 00 00				dw 0 
1857			 
1857			.menudebug: 
1857 8f 18				dw .m6 
1859 98 18				dw .m7 
185b 00 00				dw 0 
185d			 
185d .. 00		.m1:   db "Key Matrix",0 
1868 .. 00		.m2:   db "Editor",0 
186f .. 00		.m3:   db "Storage",0 
1877 .. 00		.m5:   db "Sound",0 
187d .. 00		.m5a:  db "RAM Test",0 
1886 .. 00		.m5b:  db "LCD Test",0 
188f			 
188f .. 00		.m6:   db "Debug ON",0 
1898 .. 00		.m7:   db "Debug OFF",0 
18a2			 
18a2			; debug editor 
18a2			 
18a2			.diagedit: 
18a2			 
18a2 21 f6 f0			ld hl, scratch 
18a5			;	ld bc, 250 
18a5			;	ldir 
18a5				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18a5 3e 00			ld a, 0 
18a7 77				ld (hl), a 
18a8 23				inc hl 
18a9 77				ld (hl), a 
18aa 23				inc hl 
18ab 77				ld (hl), a 
18ac			 
18ac cd aa 0d		        call clear_display 
18af cd cd 0d			call update_display 
18b2				;ld a, 1 
18b2				;ld (hardware_diag), a 
18b2			.diloop: 
18b2 3e 00			ld a, display_row_1 
18b4 0e 00			ld c, 0 
18b6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18b8 1e 28			ld e, 40 
18ba			 
18ba 21 f6 f0			ld hl, scratch	 
18bd cd 0b 10			call input_str 
18c0			 
18c0 3e 28			ld a, display_row_2 
18c2 11 f6 f0			ld de, scratch 
18c5 cd bd 0d			call str_at_display 
18c8 cd cd 0d			call update_display 
18cb			 
18cb c3 b2 18			jp .diloop 
18ce			 
18ce			 
18ce			; pass word in hl 
18ce			; a has display location 
18ce			display_word_at: 
18ce f5				push af 
18cf e5				push hl 
18d0 7c				ld a,h 
18d1 21 fb f3			ld hl, os_word_scratch 
18d4 cd e7 11			call hexout 
18d7 e1				pop hl 
18d8 7d				ld a,l 
18d9 21 fd f3			ld hl, os_word_scratch+2 
18dc cd e7 11			call hexout 
18df 21 ff f3			ld hl, os_word_scratch+4 
18e2 3e 00			ld a,0 
18e4 77				ld (hl),a 
18e5 11 fb f3			ld de,os_word_scratch 
18e8 f1				pop af 
18e9 cd bd 0d				call str_at_display 
18ec c9				ret 
18ed			 
18ed			display_ptr_state: 
18ed			 
18ed				; to restore afterwards 
18ed			 
18ed d5				push de 
18ee c5				push bc 
18ef e5				push hl 
18f0 f5				push af 
18f1			 
18f1				; for use in here 
18f1			 
18f1			;	push bc 
18f1			;	push de 
18f1			;	push hl 
18f1			;	push af 
18f1			 
18f1 cd aa 0d			call clear_display 
18f4			 
18f4 11 cc 1a			ld de, .ptrstate 
18f7 3e 00			ld a, display_row_1 
18f9 cd bd 0d			call str_at_display 
18fc			 
18fc				; display debug step 
18fc			 
18fc			 
18fc 11 a0 fd			ld de, debug_mark 
18ff 3e 26			ld a, display_row_1+display_cols-2 
1901 cd bd 0d			call str_at_display 
1904			 
1904				; display a 
1904 11 d6 1a			ld de, .ptrcliptr 
1907 3e 28			ld a, display_row_2 
1909 cd bd 0d			call str_at_display 
190c			 
190c f1				pop af 
190d 2a 75 f9			ld hl,(cli_ptr) 
1910 3e 30			ld a, display_row_2+8 
1912 cd ce 18			call display_word_at 
1915			 
1915			 
1915				; display hl 
1915			 
1915			 
1915 11 de 1a			ld de, .ptrclioptr 
1918 3e 32			ld a, display_row_2+10 
191a cd bd 0d			call str_at_display 
191d			; 
191d			;	pop hl 
191d 3e 35			ld a, display_row_2+13 
191f 2a 73 f9			ld hl,(cli_origptr) 
1922 cd ce 18			call display_word_at 
1925			; 
1925			;	 
1925			;	; display de 
1925			 
1925			;	ld de, .regstatede 
1925			;	ld a, display_row_3 
1925			;	call str_at_display 
1925			 
1925			;	pop de 
1925			;	ld h,d 
1925			;	ld l, e 
1925			;	ld a, display_row_3+3 
1925			;	call display_word_at 
1925			 
1925			 
1925				; display bc 
1925			 
1925			;	ld de, .regstatebc 
1925			;	ld a, display_row_3+10 
1925			;	call str_at_display 
1925			 
1925			;	pop bc 
1925			;	ld h,b 
1925			;	ld l, c 
1925			;	ld a, display_row_3+13 
1925			;	call display_word_at 
1925			 
1925			 
1925				; display dsp 
1925			 
1925			;	ld de, .regstatedsp 
1925			;	ld a, display_row_4 
1925			;	call str_at_display 
1925			 
1925				 
1925			;	ld hl,(cli_data_sp) 
1925			;	ld a, display_row_4+4 
1925			;	call display_word_at 
1925			 
1925				; display rsp 
1925			 
1925 11 0d 1b			ld de, .regstatersp 
1928 3e 82			ld a, display_row_4+10 
192a cd bd 0d			call str_at_display 
192d			 
192d				 
192d 2a 27 f9			ld hl,(cli_ret_sp) 
1930 3e 86			ld a, display_row_4+14 
1932 cd ce 18			call display_word_at 
1935			 
1935 cd cd 0d			call update_display 
1938			 
1938 cd ed 0c			call delay1s 
193b cd ed 0c			call delay1s 
193e cd ed 0c			call delay1s 
1941			 
1941			 
1941 cd c0 1f			call next_page_prompt 
1944			 
1944				; restore  
1944			 
1944 f1				pop af 
1945 e1				pop hl 
1946 c1				pop bc 
1947 d1				pop de 
1948 c9				ret 
1949			 
1949			; Update the break point vector so that the user can hook a new routine 
1949			 
1949			bp_on: 
1949 3e c3			ld a, $c3    ; JP 
194b 32 aa fd			ld (debug_vector), a 
194e 21 5b 19			ld hl, break_point_state 
1951 22 ab fd			ld (debug_vector+1), hl 
1954 c9				ret 
1955			 
1955			bp_off: 
1955 3e c9			ld a, $c9    ; RET 
1957 32 aa fd			ld (debug_vector), a 
195a c9				ret 
195b			 
195b			 
195b			break_point_state: 
195b			;	push af 
195b			; 
195b			;	; see if disabled 
195b			; 
195b			;	ld a, (os_view_disable) 
195b			;	cp '*' 
195b			;	jr nz, .bpsgo 
195b			;	pop af 
195b			;	ret 
195b			 
195b			.bpsgo: 
195b			;	pop af 
195b f5				push af 
195c 22 d8 f0			ld (os_view_hl), hl 
195f ed 53 d6 f0		ld (os_view_de), de 
1963 ed 43 d4 f0		ld (os_view_bc), bc 
1967 e5				push hl 
1968 6f				ld l, a 
1969 26 00			ld h, 0 
196b 22 da f0			ld (os_view_af),hl 
196e			 
196e 21 e6 fc				ld hl, display_fb0 
1971 22 01 fb				ld (display_fb_active), hl 
1974 e1				pop hl	 
1975			 
1975 3e 31			ld a, '1' 
1977 fe 2a		.bps1:  cp '*' 
1979 cc 55 19			call z, bp_off 
197c			;	jr nz, .bps1b 
197c			;	ld (os_view_disable),a 
197c fe 31		.bps1b:  cp '1' 
197e 20 14			jr nz, .bps2 
1980			 
1980				; display reg 
1980			 
1980				 
1980			 
1980 3a da f0			ld a, (os_view_af) 
1983 2a d8 f0			ld hl, (os_view_hl) 
1986 ed 5b d6 f0		ld de, (os_view_de) 
198a ed 4b d4 f0		ld bc, (os_view_bc) 
198e cd 28 1a			call display_reg_state 
1991 c3 14 1a			jp .bpschk 
1994			 
1994 fe 32		.bps2:  cp '2' 
1996 20 08			jr nz, .bps3 
1998				 
1998				; display hl 
1998 2a d8 f0			ld hl, (os_view_hl) 
199b cd 12 1b			call display_dump_at_hl 
199e			 
199e 18 74			jr .bpschk 
19a0			 
19a0 fe 33		.bps3:  cp '3' 
19a2 20 08			jr nz, .bps4 
19a4			 
19a4			        ; display de 
19a4 2a d6 f0			ld hl, (os_view_de) 
19a7 cd 12 1b			call display_dump_at_hl 
19aa			 
19aa 18 68			jr .bpschk 
19ac fe 34		.bps4:  cp '4' 
19ae 20 08			jr nz, .bps5 
19b0			 
19b0			        ; display bc 
19b0 2a d4 f0			ld hl, (os_view_bc) 
19b3 cd 12 1b			call display_dump_at_hl 
19b6			 
19b6 18 5c			jr .bpschk 
19b8 fe 35		.bps5:  cp '5' 
19ba 20 08		        jr nz, .bps7 
19bc			 
19bc				; display cur ptr 
19bc 2a 75 f9			ld hl, (cli_ptr) 
19bf cd 12 1b			call display_dump_at_hl 
19c2			 
19c2 18 50			jr .bpschk 
19c4 fe 36		.bps7:  cp '6' 
19c6 20 08			jr nz, .bps8b 
19c8				 
19c8				; display cur orig ptr 
19c8 2a 73 f9			ld hl, (cli_origptr) 
19cb cd 12 1b			call display_dump_at_hl 
19ce 18 44			jr .bpschk 
19d0 fe 37		.bps8b:  cp '7' 
19d2 20 08			jr nz, .bps9 
19d4				 
19d4				; display dsp 
19d4 2a 23 f9			ld hl, (cli_data_sp) 
19d7 cd 12 1b			call display_dump_at_hl 
19da			 
19da 18 38			jr .bpschk 
19dc fe 39		.bps9:  cp '9' 
19de 20 05			jr nz, .bps8c 
19e0				 
19e0				; display SP 
19e0			;	ld hl, sp 
19e0 cd 12 1b			call display_dump_at_hl 
19e3			 
19e3 18 2f			jr .bpschk 
19e5 fe 38		.bps8c:  cp '8' 
19e7 20 08			jr nz, .bps8d 
19e9				 
19e9				; display rsp 
19e9 2a 27 f9			ld hl, (cli_ret_sp) 
19ec cd 12 1b			call display_dump_at_hl 
19ef			 
19ef 18 23			jr .bpschk 
19f1 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
19f3 20 05			jr nz, .bps8 
19f5 cd 7a 1d			call monitor 
19f8			 
19f8 18 1a			jr .bpschk 
19fa fe 30		.bps8:  cp '0' 
19fc 20 16			jr nz, .bpschk 
19fe			 
19fe 21 45 fc				ld hl, display_fb1 
1a01 22 01 fb				ld (display_fb_active), hl 
1a04 cd cd 0d				call update_display 
1a07			 
1a07				;ld a, (os_view_af) 
1a07 2a d8 f0			ld hl, (os_view_hl) 
1a0a ed 5b d6 f0		ld de, (os_view_de) 
1a0e ed 4b d4 f0		ld bc, (os_view_bc) 
1a12 f1				pop af 
1a13 c9				ret 
1a14			 
1a14			.bpschk:   
1a14 cd ed 0c			call delay1s 
1a17 3e 9f		ld a,display_row_4 + display_cols - 1 
1a19 11 be 1f		        ld de, endprg 
1a1c cd bd 0d			call str_at_display 
1a1f cd cd 0d			call update_display 
1a22 cd 45 76			call cin_wait 
1a25			 
1a25 c3 77 19			jp .bps1 
1a28			 
1a28			 
1a28			display_reg_state: 
1a28			 
1a28				; to restore afterwards 
1a28			 
1a28 d5				push de 
1a29 c5				push bc 
1a2a e5				push hl 
1a2b f5				push af 
1a2c			 
1a2c				; for use in here 
1a2c			 
1a2c c5				push bc 
1a2d d5				push de 
1a2e e5				push hl 
1a2f f5				push af 
1a30			 
1a30 cd aa 0d			call clear_display 
1a33			 
1a33 11 e8 1a			ld de, .regstate 
1a36 3e 00			ld a, display_row_1 
1a38 cd bd 0d			call str_at_display 
1a3b			 
1a3b				; display debug step 
1a3b			 
1a3b			 
1a3b 11 a0 fd			ld de, debug_mark 
1a3e 3e 25			ld a, display_row_1+display_cols-3 
1a40 cd bd 0d			call str_at_display 
1a43			 
1a43				; display a 
1a43 11 04 1b			ld de, .regstatea 
1a46 3e 28			ld a, display_row_2 
1a48 cd bd 0d			call str_at_display 
1a4b			 
1a4b e1				pop hl 
1a4c			;	ld h,0 
1a4c			;	ld l, a 
1a4c 3e 2b			ld a, display_row_2+3 
1a4e cd ce 18			call display_word_at 
1a51			 
1a51			 
1a51				; display hl 
1a51			 
1a51			 
1a51 11 f8 1a			ld de, .regstatehl 
1a54 3e 32			ld a, display_row_2+10 
1a56 cd bd 0d			call str_at_display 
1a59			 
1a59 e1				pop hl 
1a5a 3e 35			ld a, display_row_2+13 
1a5c cd ce 18			call display_word_at 
1a5f			 
1a5f				 
1a5f				; display de 
1a5f			 
1a5f 11 fc 1a			ld de, .regstatede 
1a62 3e 50			ld a, display_row_3 
1a64 cd bd 0d			call str_at_display 
1a67			 
1a67 e1				pop hl 
1a68			;	ld h,d 
1a68			;	ld l, e 
1a68 3e 53			ld a, display_row_3+3 
1a6a cd ce 18			call display_word_at 
1a6d			 
1a6d			 
1a6d				; display bc 
1a6d			 
1a6d 11 00 1b			ld de, .regstatebc 
1a70 3e 5a			ld a, display_row_3+10 
1a72 cd bd 0d			call str_at_display 
1a75			 
1a75 e1				pop hl 
1a76			;	ld h,b 
1a76			;	ld l, c 
1a76 3e 5d			ld a, display_row_3+13 
1a78 cd ce 18			call display_word_at 
1a7b			 
1a7b			 
1a7b				; display dsp 
1a7b			 
1a7b 11 08 1b			ld de, .regstatedsp 
1a7e 3e 78			ld a, display_row_4 
1a80 cd bd 0d			call str_at_display 
1a83			 
1a83				 
1a83 2a 23 f9			ld hl,(cli_data_sp) 
1a86 3e 7c			ld a, display_row_4+4 
1a88 cd ce 18			call display_word_at 
1a8b			 
1a8b				; display rsp 
1a8b			 
1a8b 11 0d 1b			ld de, .regstatersp 
1a8e 3e 82			ld a, display_row_4+10 
1a90 cd bd 0d			call str_at_display 
1a93			 
1a93				 
1a93 2a 27 f9			ld hl,(cli_ret_sp) 
1a96 3e 86			ld a, display_row_4+14 
1a98 cd ce 18			call display_word_at 
1a9b			 
1a9b cd cd 0d			call update_display 
1a9e			 
1a9e			;	call delay1s 
1a9e			;	call delay1s 
1a9e			;	call delay1s 
1a9e			 
1a9e			 
1a9e			;	call next_page_prompt 
1a9e			 
1a9e				; restore  
1a9e			 
1a9e f1				pop af 
1a9f e1				pop hl 
1aa0 c1				pop bc 
1aa1 d1				pop de 
1aa2 c9				ret 
1aa3			 
1aa3 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ab7 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1acc .. 00		.ptrstate:	db "Ptr State",0 
1ad6 .. 00		.ptrcliptr:     db "cli_ptr",0 
1ade .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1ae8 .. 00		.regstate:	db "Reg State (1/0)",0 
1af8 .. 00		.regstatehl:	db "HL:",0 
1afc .. 00		.regstatede:	db "DE:",0 
1b00 .. 00		.regstatebc:	db "BC:",0 
1b04 .. 00		.regstatea:	db "A :",0 
1b08 .. 00		.regstatedsp:	db "DSP:",0 
1b0d .. 00		.regstatersp:	db "RSP:",0 
1b12			 
1b12			display_dump_at_hl: 
1b12 e5				push hl 
1b13 d5				push de 
1b14 c5				push bc 
1b15 f5				push af 
1b16			 
1b16 22 19 f4			ld (os_cur_ptr),hl	 
1b19 cd aa 0d			call clear_display 
1b1c cd c8 1e			call dumpcont 
1b1f			;	call delay1s 
1b1f			;	call next_page_prompt 
1b1f			 
1b1f			 
1b1f f1				pop af 
1b20 c1				pop bc 
1b21 d1				pop de 
1b22 e1				pop hl 
1b23 c9				ret 
1b24			 
1b24			;if ENABLE_BASIC 
1b24			;	include "nascombasic.asm" 
1b24			;	basic: 
1b24			;	include "forth/FORTH.ASM" 
1b24			;endif 
1b24			 
1b24			; eof 
1b24			 
1b24			 
# End of file firmware_diags.asm
1b24			  
1b24			include "firmware_prompts.asm"  
1b24			; Prompts  
1b24			 
1b24			; boot messages 
1b24			 
1b24 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b39 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b49			 
1b49			 
1b49			; config menus 
1b49			 
1b49			;prom_c3: db "Add Dictionary To File",0 
1b49			 
1b49			if STARTUP_V1 
1b49			prom_c2: db "Select Autoload File",0 
1b49			prom_c2a: db "Disable Autoload File", 0 
1b49			endif 
1b49			 
1b49			if STARTUP_V2 
1b49 .. 00		prom_c2: db "Enable Autoload Files",0 
1b5f .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b76			 
1b76 .. 00		crs_s1: db "*ls-word", 0 
1b7f .. 00		crs_s2: db "*ed-word", 0 
1b88 .. 00		crs_s3: db "*Demo-Games", 0 
1b94 .. 00		crs_s4: db "*Utils", 0 
1b9b .. 00		crs_s5: db "*SPI-Util", 0 
1ba5 .. 00		crs_s6: db "*Key-Constants", 0 
1bb4 .. 00		crs_sound: db "*Sound-Util", 0 
1bc0 .. 00		crs_hw: db "*Hello-World",0 
1bcd			 
1bcd			 
1bcd			 
1bcd			endif 
1bcd			;prom_c2b: db "Select Storage Bank",0 
1bcd .. 00		prom_c4: db "Settings",0 
1bd6 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1bf1 .. 00		prom_m4b:   db "Monitor",0 
1bf9 .. 00		prom_c1: db "Hardware Diags",0 
1c08			 
1c08			 
1c08			if STARTUP_V2 
1c08 .. 00		prom_c9: db "Create Startup Files",0 
1c1d			endif 
1c1d			 
1c1d .. 00		prom_notav:    db "Feature not available",0 
1c33 .. 00		prom_empty:    db "",0 
1c34			 
1c34			; eof 
1c34			 
# End of file firmware_prompts.asm
1c34			  
1c34			  
1c34			; eof  
1c34			  
# End of file firmware.asm
1c34			 
1c34			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c34			;if BASE_KEV  
1c34			;baseram: equ 08000h 
1c34			;endif 
1c34			 
1c34			;if BASE_SC114 
1c34			;baseram:     equ    endofcode 
1c34			;endif 
1c34			 
1c34			 
1c34			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c34			 
1c34			; start system 
1c34			 
1c34			coldstart: 
1c34				; set sp 
1c34				; di/ei 
1c34			 
1c34 f3				di 
1c35 31 fd ff			ld sp, tos 
1c38 cd cc 72			call init_nmi 
1c3b			;	ei 
1c3b			 
1c3b				; init spinner 
1c3b 3e 00			ld a,0 
1c3d 32 fb fa			ld (display_active), a 
1c40			 
1c40				; disable breakpoint by default 
1c40			 
1c40				;ld a,'*' 
1c40			;	ld a,' ' 
1c40			;	ld (os_view_disable),a 
1c40			 
1c40				; set break point vector as new break point on or off 
1c40 cd 55 19			call bp_off 
1c43			 
1c43				; init hardware 
1c43			 
1c43				; init keyboard and screen hardware 
1c43			 
1c43 cd 6c 00			call hardware_init 
1c46			 
1c46			 
1c46 cd ed 0c			call delay1s 
1c49 3e 58			ld a, display_row_3+8 
1c4b 11 03 00			ld de, buildtime 
1c4e cd bd 0d			call str_at_display 
1c51 cd cd 0d			call update_display 
1c54			 
1c54 cd ed 0c			call delay1s 
1c57 cd ed 0c			call delay1s 
1c5a cd ed 0c			call delay1s 
1c5d			 
1c5d				; detect if any keys are held down to enable breakpoints at start up 
1c5d			 
1c5d cd 56 76			call cin  
1c60 fe 00			cp 0 
1c62 28 03			jr z, .nokeys 
1c64			 
1c64				;call hardware_diags 
1c64 cd 52 15			call config 
1c67			 
1c67			;	ld de, .bpen 
1c67			;	ld a, display_row_4 
1c67			;	call str_at_display 
1c67			;	call update_display 
1c67			; 
1c67			;	ld a,0 
1c67			;	ld (os_view_disable),a 
1c67			; 
1c67			;.bpwait: 
1c67			;	call cin 
1c67			;	cp 0 
1c67			;	jr z, .bpwait 
1c67			;	jr .nokeys 
1c67			; 
1c67			; 
1c67			;.bpen:  db "Break points enabled!",0 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			.nokeys: 
1c67			 
1c67			 
1c67				 
1c67			 
1c67			;jp  testkey 
1c67			 
1c67			;call storage_get_block_0 
1c67			; 
1c67			;ld hl, 0 
1c67			;ld de, store_page 
1c67			;call storage_read_block 
1c67			 
1c67				 
1c67			;ld hl, 10 
1c67			;ld de, store_page 
1c67			;call storage_read_block 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			;stop:	nop 
1c67			;	jp stop 
1c67			 
1c67			 
1c67			 
1c67			main: 
1c67 cd aa 0d			call clear_display 
1c6a cd cd 0d			call update_display 
1c6d			 
1c6d			 
1c6d			 
1c6d			;	call testlcd 
1c6d			 
1c6d			 
1c6d			 
1c6d cd 08 24			call forth_init 
1c70			 
1c70			 
1c70			warmstart: 
1c70 cd de 23			call forth_warmstart 
1c73			 
1c73				; run startup word load 
1c73			        ; TODO prevent this running at warmstart after crash  
1c73			 
1c73				if STARTUP_ENABLE 
1c73			 
1c73					if STARTUP_V1 
1c73			 
1c73						if STORAGE_SE 
1c73							call forth_autoload 
1c73						endif 
1c73						call forth_startup 
1c73					endif 
1c73			 
1c73					if STARTUP_V2 
1c73			 
1c73						if STORAGE_SE 
1c73 cd fa 70						call forth_autoload 
1c76						else 
1c76							call forth_startup 
1c76						endif 
1c76			 
1c76			 
1c76					endif 
1c76			 
1c76				endif 
1c76			 
1c76			warmstart_afterauto: 
1c76			 
1c76				; show free memory after boot 
1c76 11 15 1d			ld de, freeram 
1c79 3e 00			ld a, display_row_1 
1c7b cd bd 0d			call str_at_display 
1c7e			 
1c7e				; get current heap start after loading any uwords 
1c7e			 
1c7e				;ld de, (os_last_new_uword) 
1c7e				;ex de, hl 
1c7e			 
1c7e			; Or use heap_size word???? 
1c7e				;ld hl, heap_end 
1c7e				;ld hl, heap_size 
1c7e				;ld de, topusermem 
1c7e				;ld de, heap_start 
1c7e ed 5b 0a 80			ld de, (free_list )      
1c82 21 d1 f0				ld hl, heap_end 
1c85 ed 52			sbc hl, de 
1c87				;push hl 
1c87				;ld a,h	         	 
1c87				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c87				;call hexout 
1c87			   	;pop hl 
1c87			; 
1c87			;	ld a,l 
1c87			;	ld hl, os_word_scratch+2 
1c87			;	call hexout 
1c87			;	ld hl, os_word_scratch+4 
1c87			;	ld a, 0 
1c87			;	ld (hl),a 
1c87 eb				ex de, hl 
1c88 21 fb f3			ld hl, os_word_scratch 
1c8b cd f3 12			call uitoa_16 
1c8e			 
1c8e			 
1c8e 11 fb f3			ld de, os_word_scratch 
1c91 3e 0d			ld a, display_row_1 + 13 
1c93 cd bd 0d			call str_at_display 
1c96 cd cd 0d			call update_display 
1c99			 
1c99			 
1c99				;call demo 
1c99			 
1c99			 
1c99				; init scratch input area for cli commands 
1c99			 
1c99 21 1d f4			ld hl, os_cli_cmd 
1c9c 3e 00			ld a,0 
1c9e 77				ld (hl),a 
1c9f 23				inc hl 
1ca0 77				ld (hl),a 
1ca1			 
1ca1 3e 00			ld a,0 
1ca3 32 1c f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1ca6			 
1ca6 32 19 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1ca9 32 1a f4			ld (os_cur_ptr+1),a	 
1cac			 
1cac 32 fb f3			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1caf 32 fc f3			ld (os_word_scratch+1),a	 
1cb2				 
1cb2			 
1cb2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cb2 21 1d f4			ld hl, os_cli_cmd 
1cb5			 
1cb5 3e 00			ld a, 0		 ; init cli input 
1cb7 77				ld (hl), a 
1cb8 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cba			cli: 
1cba				; show cli prompt 
1cba				;push af 
1cba				;ld a, 0 
1cba				;ld de, prompt 
1cba				;call str_at_display 
1cba			 
1cba				;call update_display 
1cba				;pop af 
1cba				;inc a 
1cba				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1cba			 
1cba			.lastrecall: 
1cba			 
1cba 0e 00			ld c, 0 
1cbc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cbe 1e 28			ld e, 40 
1cc0			 
1cc0 21 1d f4			ld hl, os_cli_cmd 
1cc3			 
1cc3				STACKFRAME OFF $fefe $9f9f 
1cc3				if DEBUG_STACK_IMB 
1cc3					if OFF 
1cc3						exx 
1cc3						ld de, $fefe 
1cc3						ld a, d 
1cc3						ld hl, curframe 
1cc3						call hexout 
1cc3						ld a, e 
1cc3						ld hl, curframe+2 
1cc3						call hexout 
1cc3						ld hl, $fefe 
1cc3						push hl 
1cc3						ld hl, $9f9f 
1cc3						push hl 
1cc3						exx 
1cc3					endif 
1cc3				endif 
1cc3			endm 
# End of macro STACKFRAME
1cc3			 
1cc3 cd 0b 10			call input_str 
1cc6			 
1cc6				STACKFRAMECHK OFF $fefe $9f9f 
1cc6				if DEBUG_STACK_IMB 
1cc6					if OFF 
1cc6						exx 
1cc6						ld hl, $9f9f 
1cc6						pop de   ; $9f9f 
1cc6						call cmp16 
1cc6						jr nz, .spnosame 
1cc6						ld hl, $fefe 
1cc6						pop de   ; $fefe 
1cc6						call cmp16 
1cc6						jr z, .spfrsame 
1cc6						.spnosame: call showsperror 
1cc6						.spfrsame: nop 
1cc6						exx 
1cc6					endif 
1cc6				endif 
1cc6			endm 
# End of macro STACKFRAMECHK
1cc6			 
1cc6			 
1cc6				; check to see if last line recall has been requested 
1cc6			 
1cc6			if EDIT_V2 
1cc6 fe 05			cp KEY_UP 
1cc8 20 0f			jr nz, .noexecline 
1cca			 
1cca 11 1d f4			ld de, os_cli_cmd 
1ccd 21 1c f5			ld hl, os_last_cmd 
1cd0 01 ff 00			ld bc, 255 
1cd3 ed b0			ldir 
1cd5 3e 00			ld a, 0 
1cd7 18 e1			jr .lastrecall 
1cd9			endif 
1cd9			 
1cd9			.noexecline: 
1cd9				; no so exec the line		 
1cd9			 
1cd9				; copy input to last command 
1cd9			 
1cd9 21 1d f4			ld hl, os_cli_cmd 
1cdc 11 1c f5			ld de, os_last_cmd 
1cdf 01 ff 00			ld bc, 255 
1ce2 ed b0			ldir 
1ce4			 
1ce4				; wipe current buffer 
1ce4			 
1ce4			;	ld a, 0 
1ce4			;	ld hl, os_cli_cmd 
1ce4			;	ld de, os_cli_cmd+1 
1ce4			;	ld bc, 254 
1ce4			;	ldir 
1ce4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ce4			;	call strcpy 
1ce4			;	ld a, 0 
1ce4			;	ld (hl), a 
1ce4			;	inc hl 
1ce4			;	ld (hl), a 
1ce4			;	inc hl 
1ce4			;	ld (hl), a 
1ce4			 
1ce4				; switch frame buffer to program  
1ce4			 
1ce4 21 45 fc				ld hl, display_fb1 
1ce7 22 01 fb				ld (display_fb_active), hl 
1cea			 
1cea			;	nop 
1cea				STACKFRAME ON $fbfe $8f9f 
1cea				if DEBUG_STACK_IMB 
1cea					if ON 
1cea						exx 
1cea						ld de, $fbfe 
1cea						ld a, d 
1cea						ld hl, curframe 
1cea						call hexout 
1cea						ld a, e 
1cea						ld hl, curframe+2 
1cea						call hexout 
1cea						ld hl, $fbfe 
1cea						push hl 
1cea						ld hl, $8f9f 
1cea						push hl 
1cea						exx 
1cea					endif 
1cea				endif 
1cea			endm 
# End of macro STACKFRAME
1cea				; first time into the parser so pass over the current scratch pad 
1cea 21 1d f4			ld hl,os_cli_cmd 
1ced				; tokenise the entered statement(s) in HL 
1ced cd 82 24			call forthparse 
1cf0			        ; exec forth statements in top of return stack 
1cf0 cd be 24			call forthexec 
1cf3				;call forthexec_cleanup 
1cf3			;	call parsenext 
1cf3			 
1cf3				STACKFRAMECHK ON $fbfe $8f9f 
1cf3				if DEBUG_STACK_IMB 
1cf3					if ON 
1cf3						exx 
1cf3						ld hl, $8f9f 
1cf3						pop de   ; $8f9f 
1cf3						call cmp16 
1cf3						jr nz, .spnosame 
1cf3						ld hl, $fbfe 
1cf3						pop de   ; $fbfe 
1cf3						call cmp16 
1cf3						jr z, .spfrsame 
1cf3						.spnosame: call showsperror 
1cf3						.spfrsame: nop 
1cf3						exx 
1cf3					endif 
1cf3				endif 
1cf3			endm 
# End of macro STACKFRAMECHK
1cf3				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1cf3			 
1cf3 3e 78			ld a, display_row_4 
1cf5 11 26 1d			ld de, endprog 
1cf8			 
1cf8 cd cd 0d			call update_display		 
1cfb			 
1cfb cd c0 1f			call next_page_prompt 
1cfe			 
1cfe				; switch frame buffer to cli 
1cfe			 
1cfe 21 e6 fc				ld hl, display_fb0 
1d01 22 01 fb				ld (display_fb_active), hl 
1d04			 
1d04			 
1d04 cd aa 0d		        call clear_display 
1d07 cd cd 0d			call update_display		 
1d0a			 
1d0a 21 1d f4			ld hl, os_cli_cmd 
1d0d			 
1d0d 3e 00			ld a, 0		 ; init cli input 
1d0f 77				ld (hl), a 
1d10			 
1d10				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d10			 
1d10				; now on last line 
1d10			 
1d10				; TODO scroll screen up 
1d10			 
1d10				; TODO instead just clear screen and place at top of screen 
1d10			 
1d10			;	ld a, 0 
1d10			;	ld (f_cursor_ptr),a 
1d10			 
1d10				;call clear_display 
1d10				;call update_display 
1d10			 
1d10				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d10 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d12 c3 ba 1c			jp cli 
1d15			 
1d15 .. 00		freeram: db "Free bytes: ",0 
1d22 ..			asc: db "1A2F" 
1d26 .. 00		endprog: db "End prog...",0 
1d32			 
1d32			testenter2:   
1d32 21 28 f1			ld hl,scratch+50 
1d35 22 19 f4			ld (os_cur_ptr),hl 
1d38 c3 ba 1c			jp cli 
1d3b			 
1d3b			testenter:  
1d3b			 
1d3b 21 22 1d			ld hl,asc 
1d3e			;	ld a,(hl) 
1d3e			;	call nibble2val 
1d3e cd 3d 12			call get_byte 
1d41			 
1d41			 
1d41			;	ld a,(hl) 
1d41			;	call atohex 
1d41			 
1d41			;	call fourehexhl 
1d41 32 28 f1			ld (scratch+50),a 
1d44			 
1d44			 
1d44			 
1d44 21 24 1d			ld hl,asc+2 
1d47			;	ld a, (hl) 
1d47			;	call nibble2val 
1d47 cd 3d 12			call get_byte 
1d4a			 
1d4a			;	call fourehexhl 
1d4a 32 2a f1			ld (scratch+52),a 
1d4d				 
1d4d 21 28 f1			ld hl,scratch+50 
1d50 22 19 f4			ld (os_cur_ptr),hl 
1d53 c3 ba 1c			jp cli 
1d56			 
1d56			enter:	 
1d56 3a fa f0			ld a,(scratch+4) 
1d59 fe 00			cp 0 
1d5b 28 0c			jr z, .entercont 
1d5d				; no, not a null term line so has an address to work out.... 
1d5d			 
1d5d 21 f8 f0			ld hl,scratch+2 
1d60 cd 9d 12			call get_word_hl 
1d63			 
1d63 22 19 f4			ld (os_cur_ptr),hl	 
1d66 c3 ba 1c			jp cli 
1d69			 
1d69			 
1d69			.entercont:  
1d69			 
1d69 21 f8 f0			ld hl, scratch+2 
1d6c cd 3d 12			call get_byte 
1d6f			 
1d6f 2a 19 f4		   	ld hl,(os_cur_ptr) 
1d72 77					ld (hl),a 
1d73 23					inc hl 
1d74 22 19 f4				ld (os_cur_ptr),hl 
1d77				 
1d77			; get byte  
1d77			 
1d77			 
1d77 c3 ba 1c			jp cli 
1d7a			 
1d7a			 
1d7a			; basic monitor support 
1d7a			 
1d7a			monitor: 
1d7a				;  
1d7a cd aa 0d			call clear_display 
1d7d 3e 00			ld a, 0 
1d7f 11 d3 1d			ld de, .monprompt 
1d82 cd bd 0d			call str_at_display 
1d85 cd cd 0d			call update_display 
1d88			 
1d88				; get a monitor command 
1d88			 
1d88 0e 00			ld c, 0     ; entry at top left 
1d8a 16 64			ld d, 100   ; max buffer size 
1d8c 1e 0f			ld e, 15    ; input scroll area 
1d8e 3e 00			ld a, 0     ; init string 
1d90 21 f4 f2			ld hl, os_input 
1d93 77				ld (hl), a 
1d94 23				inc hl 
1d95 77				ld (hl), a 
1d96 21 f4 f2			ld hl, os_input 
1d99 3e 01			ld a, 1     ; init string 
1d9b cd 0b 10			call input_str 
1d9e			 
1d9e cd aa 0d		        call clear_display 
1da1 cd cd 0d			call update_display		 
1da4			 
1da4 3a f4 f2			ld a, (os_input) 
1da7 cd 3b 13			call toUpper 
1daa fe 48		        cp 'H' 
1dac ca 47 1e		        jp z, .monhelp 
1daf fe 44			cp 'D'		; dump 
1db1 ca 7a 1e			jp z, .mondump	 
1db4 fe 43			cp 'C'		; dump 
1db6 ca 94 1e			jp z, .moncdump	 
1db9 fe 4d			cp 'M'		; dump 
1dbb ca d5 1d			jp z, .moneditstart 
1dbe fe 55			cp 'U'		; dump 
1dc0 ca e1 1d			jp z, .monedit	 
1dc3 fe 47			cp 'G'		; dump 
1dc5 ca 70 1e			jp z, .monjump 
1dc8 fe 42			cp 'B'		; forth breakpoint 
1dca cc 5b 19			call z, break_point_state 
1dcd fe 51			cp 'Q'		; dump 
1dcf c8				ret z	 
1dd0			 
1dd0			 
1dd0				; TODO "S" to access symbol by name and not need the address 
1dd0				; TODO "F" to find a string in memory 
1dd0			 
1dd0 c3 7a 1d			jp monitor 
1dd3			 
1dd3 .. 00		.monprompt: db ">", 0 
1dd5			 
1dd5			.moneditstart: 
1dd5				; get starting address 
1dd5			 
1dd5 21 f6 f2			ld hl,os_input+2 
1dd8 cd 9d 12			call get_word_hl 
1ddb			 
1ddb 22 19 f4			ld (os_cur_ptr),hl	 
1dde			 
1dde c3 7a 1d			jp monitor 
1de1			 
1de1			.monedit: 
1de1				; get byte to load 
1de1			 
1de1 21 f6 f2			ld hl,os_input+2 
1de4 cd 3d 12			call get_byte 
1de7			 
1de7				; get address to update 
1de7 2a 19 f4			ld hl, (os_cur_ptr) 
1dea			 
1dea				; update byte 
1dea			 
1dea 77				ld (hl), a 
1deb			 
1deb				; move to next address and save it 
1deb			 
1deb 23				inc hl 
1dec 22 19 f4			ld (os_cur_ptr),hl	 
1def			 
1def c3 7a 1d			jp monitor 
1df2			 
1df2			 
1df2 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1e06 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e22 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1e40 .. 00		.monhelptext4:  db "Q-Quit",0 
1e47			        
1e47			.monhelp: 
1e47 3e 00			ld a, display_row_1 
1e49 11 f2 1d		        ld de, .monhelptext1 
1e4c			 
1e4c cd bd 0d			call str_at_display 
1e4f 3e 28			ld a, display_row_2 
1e51 11 06 1e		        ld de, .monhelptext2 
1e54					 
1e54 cd bd 0d			call str_at_display 
1e57 3e 50			ld a, display_row_3 
1e59 11 22 1e		        ld de, .monhelptext3 
1e5c					 
1e5c cd bd 0d			call str_at_display 
1e5f 3e 78			ld a, display_row_4 
1e61 11 40 1e		        ld de, .monhelptext4 
1e64 cd bd 0d			call str_at_display 
1e67			 
1e67 cd cd 0d			call update_display		 
1e6a			 
1e6a cd c0 1f			call next_page_prompt 
1e6d c3 7a 1d			jp monitor 
1e70			 
1e70			.monjump:    
1e70 21 f6 f2			ld hl,os_input+2 
1e73 cd 9d 12			call get_word_hl 
1e76			 
1e76 e9				jp (hl) 
1e77 c3 7a 1d			jp monitor 
1e7a			 
1e7a			.mondump:    
1e7a 21 f6 f2			ld hl,os_input+2 
1e7d cd 9d 12			call get_word_hl 
1e80			 
1e80 22 19 f4			ld (os_cur_ptr),hl	 
1e83 cd c8 1e			call dumpcont 
1e86 3e 78			ld a, display_row_4 
1e88 11 26 1d			ld de, endprog 
1e8b			 
1e8b cd cd 0d			call update_display		 
1e8e			 
1e8e cd c0 1f			call next_page_prompt 
1e91 c3 7a 1d			jp monitor 
1e94			.moncdump: 
1e94 cd c8 1e			call dumpcont 
1e97 3e 78			ld a, display_row_4 
1e99 11 26 1d			ld de, endprog 
1e9c			 
1e9c cd cd 0d			call update_display		 
1e9f			 
1e9f cd c0 1f			call next_page_prompt 
1ea2 c3 7a 1d			jp monitor 
1ea5			 
1ea5			 
1ea5			; TODO symbol access  
1ea5			 
1ea5			.symbols:     ;; A list of symbols that can be called up  
1ea5 e6 fc			dw display_fb0 
1ea7 .. 00			db "fb0",0  
1eab af f9		     	dw store_page 
1ead .. 00			db "store_page",0 
1eb8			 
1eb8			 
1eb8			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1eb8			 
1eb8 3a f7 f0			ld a,(scratch+1) 
1ebb fe 00			cp 0 
1ebd 28 09			jr z, dumpcont 
1ebf			 
1ebf				; no, not a null term line so has an address to work out.... 
1ebf			 
1ebf 21 f8 f0			ld hl,scratch+2 
1ec2 cd 9d 12			call get_word_hl 
1ec5			 
1ec5 22 19 f4			ld (os_cur_ptr),hl	 
1ec8			 
1ec8			 
1ec8			 
1ec8			dumpcont: 
1ec8			 
1ec8				; dump bytes at ptr 
1ec8			 
1ec8			 
1ec8 3e 00			ld a, display_row_1 
1eca 2a 01 fb			ld hl, (display_fb_active) 
1ecd cd de 0f			call addatohl 
1ed0 cd f8 1e			call .dumpbyterow 
1ed3			 
1ed3 3e 28			ld a, display_row_2 
1ed5 2a 01 fb			ld hl, (display_fb_active) 
1ed8 cd de 0f			call addatohl 
1edb cd f8 1e			call .dumpbyterow 
1ede			 
1ede			 
1ede 3e 50			ld a, display_row_3 
1ee0 2a 01 fb			ld hl, (display_fb_active) 
1ee3 cd de 0f			call addatohl 
1ee6 cd f8 1e			call .dumpbyterow 
1ee9			 
1ee9 3e 78			ld a, display_row_4 
1eeb 2a 01 fb			ld hl, (display_fb_active) 
1eee cd de 0f			call addatohl 
1ef1 cd f8 1e			call .dumpbyterow 
1ef4			 
1ef4 cd cd 0d			call update_display 
1ef7			;		jp cli 
1ef7 c9				ret 
1ef8			 
1ef8			.dumpbyterow: 
1ef8			 
1ef8				;push af 
1ef8			 
1ef8 e5				push hl 
1ef9			 
1ef9				; calc where to poke the ascii 
1ef9			if display_cols == 20 
1ef9				ld a, 16 
1ef9			else 
1ef9 3e 1f			ld a, 31 
1efb			endif 
1efb			 
1efb cd de 0f			call addatohl 
1efe 22 fb f3			ld (os_word_scratch),hl  		; save pos for later 
1f01			 
1f01			 
1f01			; display decoding address 
1f01 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f04			 
1f04 7c				ld a,h 
1f05 e1				pop hl 
1f06 e5				push hl 
1f07			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f07 cd e7 11			call hexout 
1f0a 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f0d			 
1f0d 7d				ld a,l 
1f0e e1				pop hl 
1f0f 23				inc hl 
1f10 23				inc hl 
1f11 e5				push hl 
1f12			;	ld hl, os_word_scratch+2 
1f12 cd e7 11			call hexout 
1f15 e1				pop hl 
1f16 23				inc hl 
1f17 23				inc hl 
1f18				;ld hl, os_word_scratch+4 
1f18 3e 3a			ld a, ':' 
1f1a 77				ld (hl),a 
1f1b 23				inc hl 
1f1c				;ld a, 0 
1f1c				;ld (hl),a 
1f1c				;ld de, os_word_scratch 
1f1c				;pop af 
1f1c				;push af 
1f1c			;		ld a, display_row_2 
1f1c			;		call str_at_display 
1f1c			;		call update_display 
1f1c			 
1f1c			 
1f1c			;pop af 
1f1c			;	add 5 
1f1c			 
1f1c			if display_cols == 20 
1f1c				ld b, 4 
1f1c			else 
1f1c 06 08			ld b, 8 
1f1e			endif	 
1f1e			 
1f1e			.dumpbyte: 
1f1e c5				push bc 
1f1f e5				push hl 
1f20			 
1f20			 
1f20 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f23 7e					ld a,(hl) 
1f24			 
1f24					; poke the ascii to display 
1f24 2a fb f3				ld hl,(os_word_scratch) 
1f27 77					ld (hl),a 
1f28 23					inc hl 
1f29 22 fb f3				ld (os_word_scratch),hl 
1f2c			 
1f2c					 
1f2c			 
1f2c			 
1f2c e1					pop hl 
1f2d e5					push hl 
1f2e			 
1f2e cd e7 11				call hexout 
1f31			 
1f31					 
1f31 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f34 23				inc hl 
1f35 22 19 f4		   	ld (os_cur_ptr),hl 
1f38			 
1f38 e1					pop hl 
1f39 23					inc hl 
1f3a 23					inc hl 
1f3b 23					inc hl 
1f3c			 
1f3c			 
1f3c			 
1f3c					;ld a,0 
1f3c					;ld (os_word_scratch+2),a 
1f3c					;pop af 
1f3c					;push af 
1f3c			 
1f3c					;ld de, os_word_scratch 
1f3c					;call str_at_display 
1f3c			;		call update_display 
1f3c			;		pop af 
1f3c c1					pop bc 
1f3d c6 03				add 3 
1f3f 10 dd			djnz .dumpbyte 
1f41			 
1f41				 
1f41			 
1f41 c9				ret 
1f42			 
1f42			jump:	 
1f42			 
1f42 21 f8 f0			ld hl,scratch+2 
1f45 cd 9d 12			call get_word_hl 
1f48				;ld hl,(scratch+2) 
1f48				;call fourehexhl 
1f48			 
1f48 22 19 f4			ld (os_cur_ptr),hl	 
1f4b			 
1f4b e9				jp (hl) 
1f4c			 
1f4c			 
1f4c			 
1f4c			; TODO implement a basic monitor mode to start with 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			; testing and demo code during development 
1f4c			 
1f4c			 
1f4c .. 00		str1: db "Enter some text...",0 
1f5f .. 00		clear: db "                    ",0 
1f74			 
1f74			demo: 
1f74			 
1f74			 
1f74			 
1f74			;	call update_display 
1f74			 
1f74				; init scratch input area for testing 
1f74 21 f6 f0			ld hl, scratch	 
1f77 3e 00			ld a,0 
1f79 77				ld (hl),a 
1f7a			 
1f7a			 
1f7a 3e 28		            LD   A, display_row_2 
1f7c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f7c 11 4c 1f		            LD   DE, str1 
1f7f cd bd 0d			call str_at_display 
1f82			 
1f82			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f82			cloop:	 
1f82 3e 50		            LD   A, display_row_3 
1f84			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f84 11 5f 1f		            LD   DE, clear 
1f87			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f87 cd bd 0d				call str_at_display 
1f8a 3e 78			ld a, display_row_4 
1f8c 11 bc 1f			ld de, prompt 
1f8f			 
1f8f cd bd 0d				call str_at_display 
1f92 cd cd 0d			call update_display 
1f95			 
1f95 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f97 16 0a			ld d, 10 
1f99 21 f6 f0			ld hl, scratch	 
1f9c cd 0b 10			call input_str 
1f9f			 
1f9f			;	call clear_display 
1f9f			;'	call update_display 
1f9f			 
1f9f 3e 00		            LD   A, display_row_1 
1fa1			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa1 11 5f 1f		            LD   DE, clear 
1fa4 cd bd 0d				call str_at_display 
1fa7			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fa7 3e 00		            LD   A, display_row_1 
1fa9			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa9 11 f6 f0		            LD   DE, scratch 
1fac			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fac cd bd 0d				call str_at_display 
1faf cd cd 0d			call update_display 
1fb2			 
1fb2 3e 00				ld a,0 
1fb4 21 f6 f0			ld hl, scratch 
1fb7 77				ld (hl),a 
1fb8			 
1fb8 00				nop 
1fb9 c3 82 1f			jp cloop 
1fbc			 
1fbc			 
1fbc			 
1fbc			; OS Prompt 
1fbc			 
1fbc .. 00		prompt: db ">",0 
1fbe .. 00		endprg: db "?",0 
1fc0			 
1fc0			 
1fc0			; handy next page prompt 
1fc0			next_page_prompt: 
1fc0 e5				push hl 
1fc1 d5				push de 
1fc2 f5				push af 
1fc3 c5				push bc 
1fc4			 
1fc4 3e 9f			ld a,display_row_4 + display_cols - 1 
1fc6 11 be 1f		        ld de, endprg 
1fc9 cd bd 0d			call str_at_display 
1fcc cd cd 0d			call update_display 
1fcf cd 45 76			call cin_wait 
1fd2 c1				pop bc 
1fd3 f1				pop af 
1fd4 d1				pop de 
1fd5 e1				pop hl 
1fd6			 
1fd6			 
1fd6 c9				ret 
1fd7			 
1fd7			 
1fd7			; forth parser 
1fd7			 
1fd7			; My forth kernel 
1fd7			include "forth_kernel.asm" 
1fd7			; 
1fd7			; kernel to the forth OS 
1fd7			 
1fd7			DS_TYPE_STR: equ 1     ; string type 
1fd7			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fd7			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fd7			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fd7			 
1fd7			FORTH_PARSEV1: equ 0 
1fd7			FORTH_PARSEV2: equ 0 
1fd7			FORTH_PARSEV3: equ 0 
1fd7			FORTH_PARSEV4: equ 0 
1fd7			FORTH_PARSEV5: equ 0 
1fd7			FORTH_PARSEV6: equ 1 
1fd7			 
1fd7			;if FORTH_PARSEV5 
1fd7			;	FORTH_END_BUFFER: equ 0 
1fd7			;else 
1fd7			FORTH_END_BUFFER: equ 127 
1fd7			;endif 
1fd7			 
1fd7			FORTH_TRUE: equ 1 
1fd7			FORTH_FALSE: equ 0 
1fd7			 
1fd7			if FORTH_PARSEV4 
1fd7			include "forth_stackops.asm" 
1fd7			endif 
1fd7			 
1fd7			if FORTH_PARSEV5 
1fd7			include "forth_stackopsv5.asm" 
1fd7			endif 
1fd7			 
1fd7			if FORTH_PARSEV6 
1fd7			include "forth_stackopsv5.asm" 
1fd7			 
1fd7			; Stack operations for v5 parser on wards 
1fd7			; * DATA stack 
1fd7			; * LOOP stack 
1fd7			; * RETURN stack 
1fd7			 
1fd7			 
1fd7			 
1fd7			FORTH_CHK_DSP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_data_sp) 
1fd7				ld de, cli_data_stack 
1fd7				call cmp16 
1fd7				jp c, fault_dsp_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			FORTH_CHK_RSP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_ret_sp) 
1fd7				ld de, cli_ret_stack 
1fd7				call cmp16 
1fd7				jp c, fault_rsp_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			FORTH_CHK_LOOP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_loop_sp) 
1fd7				ld de, cli_loop_stack 
1fd7				call cmp16 
1fd7				jp c, fault_loop_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			FORTH_ERR_TOS_NOTSTR: macro 
1fd7				; TOSO might need more for checks when used 
1fd7				push af 
1fd7				ld a,(hl) 
1fd7				cp DS_TYPE_STR 
1fd7				jp nz, type_faultn   
1fd7				pop af 
1fd7				endm 
1fd7			 
1fd7			FORTH_ERR_TOS_NOTNUM: macro 
1fd7				push af 
1fd7				ld a,(hl) 
1fd7				cp DS_TYPE_INUM 
1fd7				jp nz, type_faultn   
1fd7				pop af 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			; increase data stack pointer and save hl to it 
1fd7				 
1fd7			FORTH_DSP_NEXT: macro 
1fd7				call macro_forth_dsp_next 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			macro_forth_dsp_next: 
1fd7				if DEBUG_FORTH_STACK_GUARD 
1fd7 cd e9 6e				call check_stacks 
1fda				endif 
1fda e5				push hl 
1fdb d5				push de 
1fdc eb				ex de,hl 
1fdd 2a 23 f9			ld hl,(cli_data_sp) 
1fe0 23				inc hl 
1fe1 23				inc hl 
1fe2			 
1fe2			; PARSEV5 
1fe2 23				inc hl 
1fe3 22 23 f9			ld (cli_data_sp),hl 
1fe6 73				ld (hl), e 
1fe7 23				inc hl 
1fe8 72				ld (hl), d 
1fe9 d1				pop de 
1fea e1				pop hl 
1feb				if DEBUG_FORTH_STACK_GUARD 
1feb cd e9 6e				call check_stacks 
1fee				endif 
1fee c9				ret 
1fef			 
1fef			 
1fef			; increase ret stack pointer and save hl to it 
1fef				 
1fef			FORTH_RSP_NEXT: macro 
1fef				call macro_forth_rsp_next 
1fef				endm 
1fef			 
1fef			macro_forth_rsp_next: 
1fef				if DEBUG_FORTH_STACK_GUARD 
1fef cd e9 6e				call check_stacks 
1ff2				endif 
1ff2 e5				push hl 
1ff3 d5				push de 
1ff4 eb				ex de,hl 
1ff5 2a 27 f9			ld hl,(cli_ret_sp) 
1ff8 23				inc hl 
1ff9 23				inc hl 
1ffa 22 27 f9			ld (cli_ret_sp),hl 
1ffd 73				ld (hl), e 
1ffe 23				inc hl 
1fff 72				ld (hl), d 
2000 d1				pop de 
2001 e1				pop hl 
2002				if DEBUG_FORTH_STACK_GUARD 
2002 cd e9 6e				call check_stacks 
2005				endif 
2005 c9				ret 
2006			 
2006			; get current ret stack pointer and save to hl  
2006				 
2006			FORTH_RSP_TOS: macro 
2006				call macro_forth_rsp_tos 
2006				endm 
2006			 
2006			macro_forth_rsp_tos: 
2006				;push de 
2006 2a 27 f9			ld hl,(cli_ret_sp) 
2009 cd 41 20			call loadhlptrtohl 
200c				;ld e, (hl) 
200c				;inc hl 
200c				;ld d, (hl) 
200c				;ex de, hl 
200c					if DEBUG_FORTH_WORDS 
200c			;			DMARK "RST" 
200c						CALLMONITOR 
200c cd aa fd			call debug_vector  
200f				endm  
# End of macro CALLMONITOR
200f					endif 
200f				;pop de 
200f c9				ret 
2010			 
2010			; pop ret stack pointer 
2010				 
2010			FORTH_RSP_POP: macro 
2010				call macro_forth_rsp_pop 
2010				endm 
2010			 
2010			 
2010			macro_forth_rsp_pop: 
2010				if DEBUG_FORTH_STACK_GUARD 
2010			;		DMARK "RPP" 
2010 cd e9 6e				call check_stacks 
2013					FORTH_CHK_RSP_UNDER 
2013 e5				push hl 
2014 d5				push de 
2015 2a 27 f9			ld hl,(cli_ret_sp) 
2018 11 e1 f8			ld de, cli_ret_stack 
201b cd fc 0f			call cmp16 
201e da 00 70			jp c, fault_rsp_under 
2021 d1				pop de 
2022 e1				pop hl 
2023				endm 
# End of macro FORTH_CHK_RSP_UNDER
2023				endif 
2023 e5				push hl 
2024 2a 27 f9			ld hl,(cli_ret_sp) 
2027			 
2027			 
2027				if FORTH_ENABLE_FREE 
2027			 
2027					; get pointer 
2027			 
2027					push de 
2027					push hl 
2027			 
2027					ld e, (hl) 
2027					inc hl 
2027					ld d, (hl) 
2027			 
2027					ex de, hl 
2027					call free 
2027			 
2027					pop hl 
2027					pop de 
2027			 
2027			 
2027				endif 
2027			 
2027			 
2027 2b				dec hl 
2028 2b				dec hl 
2029 22 27 f9			ld (cli_ret_sp), hl 
202c				; do stack underflow checks 
202c e1				pop hl 
202d				if DEBUG_FORTH_STACK_GUARD 
202d cd e9 6e				call check_stacks 
2030					FORTH_CHK_RSP_UNDER 
2030 e5				push hl 
2031 d5				push de 
2032 2a 27 f9			ld hl,(cli_ret_sp) 
2035 11 e1 f8			ld de, cli_ret_stack 
2038 cd fc 0f			call cmp16 
203b da 00 70			jp c, fault_rsp_under 
203e d1				pop de 
203f e1				pop hl 
2040				endm 
# End of macro FORTH_CHK_RSP_UNDER
2040				endif 
2040 c9				ret 
2041			 
2041			 
2041			 
2041			; routine to load word pointed to by hl into hl 
2041			 
2041			loadhlptrtohl: 
2041			 
2041 d5				push de 
2042 5e				ld e, (hl) 
2043 23				inc hl 
2044 56				ld d, (hl) 
2045 eb				ex de, hl 
2046 d1				pop de 
2047			 
2047 c9				ret 
2048			 
2048			 
2048			 
2048			 
2048			 
2048			; push a number held in HL onto the data stack 
2048			; entry point for pushing a value when already in hl used in function above 
2048			 
2048			forth_push_numhl: 
2048			 
2048 e5				push hl    ; save value to push 
2049			 
2049			if DEBUG_FORTH_PUSH 
2049				; see if disabled 
2049			 
2049			 
2049 f5				push af 
204a 3a aa fd			ld a,(debug_vector) 
204d fe c9			cp $c9   ; ret 
204f			;	ld a, (os_view_disable) 
204f			;	cp '*' 
204f 28 34			jr z, .pskip2 
2051 e5				push hl 
2052 e5			push hl 
2053 cd aa 0d			call clear_display 
2056 e1			pop hl 
2057 7c				ld a,h 
2058 21 fb f3			ld hl, os_word_scratch 
205b cd e7 11			call hexout 
205e e1				pop hl 
205f 7d				ld a,l 
2060 21 fd f3			ld hl, os_word_scratch+2 
2063 cd e7 11			call hexout 
2066			 
2066 21 ff f3			ld hl, os_word_scratch+4 
2069 3e 00			ld a,0 
206b 77				ld (hl),a 
206c 11 fb f3			ld de,os_word_scratch 
206f 3e 28				ld a, display_row_2 
2071 cd bd 0d				call str_at_display 
2074 11 e2 60			ld de, .push_num 
2077 3e 00			ld a, display_row_1 
2079			 
2079 cd bd 0d				call str_at_display 
207c			 
207c			 
207c cd cd 0d			call update_display 
207f cd ed 0c			call delay1s 
2082 cd ed 0c			call delay1s 
2085			.pskip2:  
2085			 
2085 f1				pop af 
2086			endif	 
2086			 
2086			 
2086				FORTH_DSP_NEXT 
2086 cd d7 1f			call macro_forth_dsp_next 
2089				endm 
# End of macro FORTH_DSP_NEXT
2089			 
2089 2a 23 f9			ld hl, (cli_data_sp) 
208c			 
208c				; save item type 
208c 3e 02			ld a,  DS_TYPE_INUM 
208e 77				ld (hl), a 
208f 23				inc hl 
2090			 
2090				; get word off stack 
2090 d1				pop de 
2091 7b				ld a,e 
2092 77				ld (hl), a 
2093 23				inc hl 
2094 7a				ld a,d 
2095 77				ld (hl), a 
2096			 
2096			if DEBUG_FORTH_PUSH 
2096 2b				dec hl 
2097 2b				dec hl 
2098 2b				dec hl 
2099						DMARK "PH5" 
2099 f5				push af  
209a 3a ae 20			ld a, (.dmark)  
209d 32 a0 fd			ld (debug_mark),a  
20a0 3a af 20			ld a, (.dmark+1)  
20a3 32 a1 fd			ld (debug_mark+1),a  
20a6 3a b0 20			ld a, (.dmark+2)  
20a9 32 a2 fd			ld (debug_mark+2),a  
20ac 18 03			jr .pastdmark  
20ae ..			.dmark: db "PH5"  
20b1 f1			.pastdmark: pop af  
20b2			endm  
# End of macro DMARK
20b2				CALLMONITOR 
20b2 cd aa fd			call debug_vector  
20b5				endm  
# End of macro CALLMONITOR
20b5			endif	 
20b5			 
20b5 c9				ret 
20b6			 
20b6			 
20b6			; Push a string to stack pointed to by hl 
20b6			 
20b6			forth_push_str: 
20b6			 
20b6			if DEBUG_FORTH_PUSH 
20b6						DMARK "PSQ" 
20b6 f5				push af  
20b7 3a cb 20			ld a, (.dmark)  
20ba 32 a0 fd			ld (debug_mark),a  
20bd 3a cc 20			ld a, (.dmark+1)  
20c0 32 a1 fd			ld (debug_mark+1),a  
20c3 3a cd 20			ld a, (.dmark+2)  
20c6 32 a2 fd			ld (debug_mark+2),a  
20c9 18 03			jr .pastdmark  
20cb ..			.dmark: db "PSQ"  
20ce f1			.pastdmark: pop af  
20cf			endm  
# End of macro DMARK
20cf				CALLMONITOR 
20cf cd aa fd			call debug_vector  
20d2				endm  
# End of macro CALLMONITOR
20d2			endif	 
20d2			 
20d2			 
20d2			    
20d2 e5				push hl 
20d3 e5				push hl 
20d4			 
20d4			;	ld a, 0   ; find end of string 
20d4 cd 44 13			call strlenz 
20d7			if DEBUG_FORTH_PUSH 
20d7						DMARK "PQ2" 
20d7 f5				push af  
20d8 3a ec 20			ld a, (.dmark)  
20db 32 a0 fd			ld (debug_mark),a  
20de 3a ed 20			ld a, (.dmark+1)  
20e1 32 a1 fd			ld (debug_mark+1),a  
20e4 3a ee 20			ld a, (.dmark+2)  
20e7 32 a2 fd			ld (debug_mark+2),a  
20ea 18 03			jr .pastdmark  
20ec ..			.dmark: db "PQ2"  
20ef f1			.pastdmark: pop af  
20f0			endm  
# End of macro DMARK
20f0				CALLMONITOR 
20f0 cd aa fd			call debug_vector  
20f3				endm  
# End of macro CALLMONITOR
20f3			endif	 
20f3 eb				ex de, hl 
20f4 e1				pop hl   ; get ptr to start of string 
20f5			if DEBUG_FORTH_PUSH 
20f5						DMARK "PQ3" 
20f5 f5				push af  
20f6 3a 0a 21			ld a, (.dmark)  
20f9 32 a0 fd			ld (debug_mark),a  
20fc 3a 0b 21			ld a, (.dmark+1)  
20ff 32 a1 fd			ld (debug_mark+1),a  
2102 3a 0c 21			ld a, (.dmark+2)  
2105 32 a2 fd			ld (debug_mark+2),a  
2108 18 03			jr .pastdmark  
210a ..			.dmark: db "PQ3"  
210d f1			.pastdmark: pop af  
210e			endm  
# End of macro DMARK
210e				CALLMONITOR 
210e cd aa fd			call debug_vector  
2111				endm  
# End of macro CALLMONITOR
2111			endif	 
2111 19				add hl,de 
2112			if DEBUG_FORTH_PUSH 
2112						DMARK "PQE" 
2112 f5				push af  
2113 3a 27 21			ld a, (.dmark)  
2116 32 a0 fd			ld (debug_mark),a  
2119 3a 28 21			ld a, (.dmark+1)  
211c 32 a1 fd			ld (debug_mark+1),a  
211f 3a 29 21			ld a, (.dmark+2)  
2122 32 a2 fd			ld (debug_mark+2),a  
2125 18 03			jr .pastdmark  
2127 ..			.dmark: db "PQE"  
212a f1			.pastdmark: pop af  
212b			endm  
# End of macro DMARK
212b				CALLMONITOR 
212b cd aa fd			call debug_vector  
212e				endm  
# End of macro CALLMONITOR
212e			endif	 
212e			 
212e 2b				dec hl    ; see if there is an optional trailing double quote 
212f 7e				ld a,(hl) 
2130 fe 22			cp '"' 
2132 20 03			jr nz, .strnoq 
2134 3e 00			ld a, 0      ; get rid of double quote 
2136 77				ld (hl), a 
2137 23			.strnoq: inc hl 
2138			 
2138 3e 00			ld a, 0 
213a 77				ld (hl), a     ; add null term and get rid of trailing double quote 
213b			 
213b 13				inc de ; add one for the type string 
213c 13				inc de ; add one for null term??? 
213d			 
213d				; tos is get string pointer again 
213d				; de contains space to allocate 
213d				 
213d d5				push de 
213e			 
213e eb				ex de, hl 
213f			 
213f				;push af 
213f			 
213f			if DEBUG_FORTH_PUSH 
213f						DMARK "PHm" 
213f f5				push af  
2140 3a 54 21			ld a, (.dmark)  
2143 32 a0 fd			ld (debug_mark),a  
2146 3a 55 21			ld a, (.dmark+1)  
2149 32 a1 fd			ld (debug_mark+1),a  
214c 3a 56 21			ld a, (.dmark+2)  
214f 32 a2 fd			ld (debug_mark+2),a  
2152 18 03			jr .pastdmark  
2154 ..			.dmark: db "PHm"  
2157 f1			.pastdmark: pop af  
2158			endm  
# End of macro DMARK
2158				CALLMONITOR 
2158 cd aa fd			call debug_vector  
215b				endm  
# End of macro CALLMONITOR
215b			endif	 
215b cd b9 13			call malloc	; on ret hl now contains allocated memory 
215e				if DEBUG_FORTH_MALLOC_GUARD 
215e cc 3a 61				call z,malloc_error 
2161				endif 
2161			 
2161				 
2161 c1				pop bc    ; get length 
2162 d1				pop de   ;  get string start    
2163			 
2163				; hl has destination from malloc 
2163			 
2163 eb				ex de, hl    ; prep for ldir 
2164			 
2164 d5				push de   ; save malloc area for DSP later 
2165				;push hl   ; save malloc area for DSP later 
2165			 
2165			if DEBUG_FORTH_PUSH 
2165						DMARK "PHc" 
2165 f5				push af  
2166 3a 7a 21			ld a, (.dmark)  
2169 32 a0 fd			ld (debug_mark),a  
216c 3a 7b 21			ld a, (.dmark+1)  
216f 32 a1 fd			ld (debug_mark+1),a  
2172 3a 7c 21			ld a, (.dmark+2)  
2175 32 a2 fd			ld (debug_mark+2),a  
2178 18 03			jr .pastdmark  
217a ..			.dmark: db "PHc"  
217d f1			.pastdmark: pop af  
217e			endm  
# End of macro DMARK
217e				CALLMONITOR 
217e cd aa fd			call debug_vector  
2181				endm  
# End of macro CALLMONITOR
2181			endif	 
2181			 
2181			 
2181 ed b0			ldir 
2183			 
2183			 
2183				; push malloc to data stack     macro?????  
2183			 
2183				FORTH_DSP_NEXT 
2183 cd d7 1f			call macro_forth_dsp_next 
2186				endm 
# End of macro FORTH_DSP_NEXT
2186			 
2186				; save value and type 
2186			 
2186 2a 23 f9			ld hl, (cli_data_sp) 
2189			 
2189				; save item type 
2189 3e 01			ld a,  DS_TYPE_STR 
218b 77				ld (hl), a 
218c 23				inc hl 
218d			 
218d				; get malloc word off stack 
218d d1				pop de 
218e 73				ld (hl), e 
218f 23				inc hl 
2190 72				ld (hl), d 
2191			 
2191			 
2191			 
2191			if DEBUG_FORTH_PUSH 
2191 2a 23 f9			ld hl, (cli_data_sp) 
2194						DMARK "PHS" 
2194 f5				push af  
2195 3a a9 21			ld a, (.dmark)  
2198 32 a0 fd			ld (debug_mark),a  
219b 3a aa 21			ld a, (.dmark+1)  
219e 32 a1 fd			ld (debug_mark+1),a  
21a1 3a ab 21			ld a, (.dmark+2)  
21a4 32 a2 fd			ld (debug_mark+2),a  
21a7 18 03			jr .pastdmark  
21a9 ..			.dmark: db "PHS"  
21ac f1			.pastdmark: pop af  
21ad			endm  
# End of macro DMARK
21ad				CALLMONITOR 
21ad cd aa fd			call debug_vector  
21b0				endm  
# End of macro CALLMONITOR
21b0			;	ex de,hl 
21b0			endif	 
21b0				; in case of spaces, skip the ptr past the copied string 
21b0				;pop af 
21b0				;ld (cli_origptr),hl 
21b0			 
21b0 c9				ret 
21b1			 
21b1			 
21b1			 
21b1			; TODO ascii push input onto stack given hl to start of input 
21b1			 
21b1			; identify type 
21b1			; if starts with a " then a string 
21b1			; otherwise it is a number 
21b1			;  
21b1			; if a string 
21b1			;     scan for ending " to get length of string to malloc for + 1 
21b1			;     malloc 
21b1			;     put pointer to string on stack first byte flags as string 
21b1			; 
21b1			; else a number 
21b1			;    look for number format identifier 
21b1			;    $xx hex 
21b1			;    %xxxxx bin 
21b1			;    xxxxx decimal 
21b1			;    convert number to 16bit word.  
21b1			;    malloc word + 1 with flag to identiy as num 
21b1			;    put pointer to number on stack 
21b1			;   
21b1			;  
21b1			  
21b1			forth_apush: 
21b1				; kernel push 
21b1			 
21b1			if DEBUG_FORTH_PUSH 
21b1						DMARK "PSH" 
21b1 f5				push af  
21b2 3a c6 21			ld a, (.dmark)  
21b5 32 a0 fd			ld (debug_mark),a  
21b8 3a c7 21			ld a, (.dmark+1)  
21bb 32 a1 fd			ld (debug_mark+1),a  
21be 3a c8 21			ld a, (.dmark+2)  
21c1 32 a2 fd			ld (debug_mark+2),a  
21c4 18 03			jr .pastdmark  
21c6 ..			.dmark: db "PSH"  
21c9 f1			.pastdmark: pop af  
21ca			endm  
# End of macro DMARK
21ca				CALLMONITOR 
21ca cd aa fd			call debug_vector  
21cd				endm  
# End of macro CALLMONITOR
21cd			endif	 
21cd				; identify input type 
21cd			 
21cd 7e				ld a,(hl) 
21ce			 
21ce fe 23			cp '#' 
21d0 ca 0a 22			jp z, .fapdec 
21d3			 
21d3			 
21d3 fe 22			cp '"' 
21d5 28 0a			jr z, .fapstr 
21d7 fe 24			cp '$' 
21d9 ca 01 22			jp z, .faphex 
21dc fe 25			cp '%' 
21de ca e9 21			jp z, .fapbin 
21e1			;	cp 'b' 
21e1			;	jp z, .fabin 
21e1				; else decimal 
21e1			 
21e1				; TODO do decimal conversion 
21e1				; decimal is stored as a 16bit word 
21e1			 
21e1				; by default everything is a string if type is not detected 
21e1			.fapstr: ; 
21e1 fe 22			cp '"' 
21e3 20 01			jr nz, .strnoqu 
21e5 23				inc hl 
21e6			.strnoqu: 
21e6 c3 b6 20			jp forth_push_str 
21e9			 
21e9			 
21e9			 
21e9			.fapbin:    ; push a binary string.  
21e9 11 00 00			ld de, 0   ; hold a 16bit value 
21ec			 
21ec 23			.fapbinshift:	inc hl  
21ed 7e				ld a,(hl) 
21ee fe 00			cp 0     ; done scanning  
21f0 28 0b			jr z, .fapbdone  	; got it in HL so push  
21f2			 
21f2				; left shift de 
21f2 eb				ex de, hl	 
21f3 29				add hl, hl 
21f4			 
21f4				; is 1 
21f4 fe 31			cp '1' 
21f6 20 02			jr nz, .binzero 
21f8 cb 4d			bit 1, l 
21fa			.binzero: 
21fa eb				ex de, hl	 ; save current de 
21fb 18 ef			jr .fapbinshift 
21fd			 
21fd			.fapbdone: 
21fd eb				ex de, hl 
21fe c3 48 20			jp forth_push_numhl 
2201			 
2201			 
2201			.faphex:   ; hex is always stored as a 16bit word 
2201				; skip number prefix 
2201 23				inc hl 
2202				; turn ascii into number 
2202 cd 9d 12			call get_word_hl	; ret 16bit word in hl 
2205			 
2205 c3 48 20			jp forth_push_numhl 
2208			 
2208 00				 nop 
2209			 
2209			.fabin:   ; TODO bin conversion 
2209			 
2209			 
2209 c9				ret 
220a			.fapdec:	 
220a				; string to dec conversion 
220a 23				inc hl 
220b eb				ex de, hl 
220c cd db 12			call string_to_uint16 
220f c3 48 20			jp forth_push_numhl 
2212 c9				ret 
2213				 
2213			;atoui_16: 
2213			 
2213			; get either a string ptr or a 16bit word from the data stack 
2213			 
2213			FORTH_DSP: macro 
2213				call macro_forth_dsp 
2213				endm 
2213			 
2213			macro_forth_dsp: 
2213				; data stack pointer points to current word on tos 
2213			 
2213 2a 23 f9			ld hl,(cli_data_sp) 
2216			 
2216				if DEBUG_FORTH_PUSH 
2216						DMARK "DSP" 
2216 f5				push af  
2217 3a 2b 22			ld a, (.dmark)  
221a 32 a0 fd			ld (debug_mark),a  
221d 3a 2c 22			ld a, (.dmark+1)  
2220 32 a1 fd			ld (debug_mark+1),a  
2223 3a 2d 22			ld a, (.dmark+2)  
2226 32 a2 fd			ld (debug_mark+2),a  
2229 18 03			jr .pastdmark  
222b ..			.dmark: db "DSP"  
222e f1			.pastdmark: pop af  
222f			endm  
# End of macro DMARK
222f			 
222f cd 6d 61				call display_data_sp 
2232				;call break_point_state 
2232				;rst 030h 
2232				CALLMONITOR 
2232 cd aa fd			call debug_vector  
2235				endm  
# End of macro CALLMONITOR
2235				endif 
2235			 
2235 c9				ret 
2236			 
2236			; return hl to start of value on stack 
2236			 
2236			FORTH_DSP_VALUE: macro 
2236				call macro_forth_dsp_value 
2236				endm 
2236			 
2236			macro_forth_dsp_value: 
2236			 
2236				FORTH_DSP 
2236 cd 13 22			call macro_forth_dsp 
2239				endm 
# End of macro FORTH_DSP
2239			 
2239 d5				push de 
223a			 
223a 23				inc hl ; skip type 
223b			 
223b 5e				ld e, (hl) 
223c 23				inc hl 
223d 56				ld d, (hl) 
223e eb				ex de,hl  
223f			 
223f d1				pop de 
2240			 
2240 c9				ret 
2241			 
2241			; return hl to start of value to second item on stack 
2241			 
2241			FORTH_DSP_VALUEM1: macro 
2241				call macro_forth_dsp_value_m1 
2241				endm 
2241			 
2241			macro_forth_dsp_value_m1: 
2241			 
2241				FORTH_DSP 
2241 cd 13 22			call macro_forth_dsp 
2244				endm 
# End of macro FORTH_DSP
2244			 
2244 2b				dec hl 
2245 2b				dec hl 
2246			;	dec hl 
2246			 
2246 d5				push de 
2247			 
2247 5e				ld e, (hl) 
2248 23				inc hl 
2249 56				ld d, (hl) 
224a eb				ex de,hl  
224b			 
224b d1				pop de 
224c			 
224c c9				ret 
224d			 
224d				 
224d			 
224d			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
224d			 
224d			FORTH_DSP_POP: macro 
224d				call macro_forth_dsp_pop 
224d				endm 
224d			 
224d			 
224d			; get the tos data type 
224d			 
224d			FORTH_DSP_TYPE:   macro 
224d			 
224d				;FORTH_DSP_VALUE 
224d				FORTH_DSP 
224d				 
224d				; hl points to value 
224d				; check type 
224d			 
224d				ld a,(hl) 
224d			 
224d				endm 
224d			 
224d			; load the tos value into hl 
224d			 
224d			 
224d			FORTH_DSP_VALUEHL:  macro 
224d				call macro_dsp_valuehl 
224d				endm 
224d			 
224d			 
224d			 
224d			macro_dsp_valuehl: 
224d				FORTH_DSP_VALUE 
224d cd 36 22			call macro_forth_dsp_value 
2250				endm 
# End of macro FORTH_DSP_VALUE
2250			 
2250				;FORTH_ERR_TOS_NOTNUM 
2250			 
2250				;inc hl   ; skip type id 
2250			 
2250			;	push de 
2250			; 
2250			;	ld e, (hl) 
2250			;	inc hl 
2250			;	ld d, (hl) 
2250			;	ex de,hl  
2250			 
2250			;	pop de 
2250			 
2250				if DEBUG_FORTH_PUSH 
2250						DMARK "DVL" 
2250 f5				push af  
2251 3a 65 22			ld a, (.dmark)  
2254 32 a0 fd			ld (debug_mark),a  
2257 3a 66 22			ld a, (.dmark+1)  
225a 32 a1 fd			ld (debug_mark+1),a  
225d 3a 67 22			ld a, (.dmark+2)  
2260 32 a2 fd			ld (debug_mark+2),a  
2263 18 03			jr .pastdmark  
2265 ..			.dmark: db "DVL"  
2268 f1			.pastdmark: pop af  
2269			endm  
# End of macro DMARK
2269				CALLMONITOR 
2269 cd aa fd			call debug_vector  
226c				endm  
# End of macro CALLMONITOR
226c				endif 
226c c9				ret 
226d			 
226d			forth_apushstrhl:      
226d				; push of string requires use of cli_origptr 
226d				; bodge use 
226d			 
226d				; get current cli_origptr, save, update with temp pointer  
226d ed 5b 73 f9		ld de, (cli_origptr) 
2271 22 73 f9			ld (cli_origptr), hl 
2274 d5				push de 
2275 cd b1 21			call forth_apush 
2278 d1				pop de 
2279 ed 53 73 f9		ld (cli_origptr), de 
227d c9			        ret	 
227e			 
227e			 
227e			; increase loop stack pointer and save hl to it 
227e				 
227e			FORTH_LOOP_NEXT: macro 
227e				call macro_forth_loop_next 
227e				;nop 
227e				endm 
227e			 
227e			macro_forth_loop_next: 
227e				if DEBUG_FORTH_STACK_GUARD 
227e cd e9 6e				call check_stacks 
2281				endif 
2281 e5				push hl 
2282 d5				push de 
2283 eb				ex de,hl 
2284 2a 25 f9			ld hl,(cli_loop_sp) 
2287 23				inc hl 
2288 23				inc hl 
2289					if DEBUG_FORTH_WORDS 
2289						DMARK "LNX" 
2289 f5				push af  
228a 3a 9e 22			ld a, (.dmark)  
228d 32 a0 fd			ld (debug_mark),a  
2290 3a 9f 22			ld a, (.dmark+1)  
2293 32 a1 fd			ld (debug_mark+1),a  
2296 3a a0 22			ld a, (.dmark+2)  
2299 32 a2 fd			ld (debug_mark+2),a  
229c 18 03			jr .pastdmark  
229e ..			.dmark: db "LNX"  
22a1 f1			.pastdmark: pop af  
22a2			endm  
# End of macro DMARK
22a2						CALLMONITOR 
22a2 cd aa fd			call debug_vector  
22a5				endm  
# End of macro CALLMONITOR
22a5					endif 
22a5 22 25 f9			ld (cli_loop_sp),hl 
22a8 73				ld (hl), e 
22a9 23				inc hl 
22aa 72				ld (hl), d 
22ab d1				pop de    ; been reversed so save a swap on restore 
22ac e1				pop hl 
22ad				if DEBUG_FORTH_STACK_GUARD 
22ad cd e9 6e				call check_stacks 
22b0				endif 
22b0 c9				ret 
22b1			 
22b1			; get current ret stack pointer and save to hl  
22b1				 
22b1			FORTH_LOOP_TOS: macro 
22b1				call macro_forth_loop_tos 
22b1				endm 
22b1			 
22b1			macro_forth_loop_tos: 
22b1 d5				push de 
22b2 2a 25 f9			ld hl,(cli_loop_sp) 
22b5 5e				ld e, (hl) 
22b6 23				inc hl 
22b7 56				ld d, (hl) 
22b8 eb				ex de, hl 
22b9 d1				pop de 
22ba c9				ret 
22bb			 
22bb			; pop loop stack pointer 
22bb				 
22bb			FORTH_LOOP_POP: macro 
22bb				call macro_forth_loop_pop 
22bb				endm 
22bb			 
22bb			 
22bb			macro_forth_loop_pop: 
22bb				if DEBUG_FORTH_STACK_GUARD 
22bb					DMARK "LPP" 
22bb f5				push af  
22bc 3a d0 22			ld a, (.dmark)  
22bf 32 a0 fd			ld (debug_mark),a  
22c2 3a d1 22			ld a, (.dmark+1)  
22c5 32 a1 fd			ld (debug_mark+1),a  
22c8 3a d2 22			ld a, (.dmark+2)  
22cb 32 a2 fd			ld (debug_mark+2),a  
22ce 18 03			jr .pastdmark  
22d0 ..			.dmark: db "LPP"  
22d3 f1			.pastdmark: pop af  
22d4			endm  
# End of macro DMARK
22d4 cd e9 6e				call check_stacks 
22d7					FORTH_CHK_LOOP_UNDER 
22d7 e5				push hl 
22d8 d5				push de 
22d9 2a 25 f9			ld hl,(cli_loop_sp) 
22dc 11 5f f8			ld de, cli_loop_stack 
22df cd fc 0f			call cmp16 
22e2 da 06 70			jp c, fault_loop_under 
22e5 d1				pop de 
22e6 e1				pop hl 
22e7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22e7				endif 
22e7 e5				push hl 
22e8 2a 25 f9			ld hl,(cli_loop_sp) 
22eb 2b				dec hl 
22ec 2b				dec hl 
22ed 22 25 f9			ld (cli_loop_sp), hl 
22f0				; TODO do stack underflow checks 
22f0 e1				pop hl 
22f1				if DEBUG_FORTH_STACK_GUARD 
22f1 cd e9 6e				call check_stacks 
22f4					FORTH_CHK_LOOP_UNDER 
22f4 e5				push hl 
22f5 d5				push de 
22f6 2a 25 f9			ld hl,(cli_loop_sp) 
22f9 11 5f f8			ld de, cli_loop_stack 
22fc cd fc 0f			call cmp16 
22ff da 06 70			jp c, fault_loop_under 
2302 d1				pop de 
2303 e1				pop hl 
2304				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2304				endif 
2304 c9				ret 
2305			 
2305			macro_forth_dsp_pop: 
2305			 
2305 e5				push hl 
2306			 
2306				; release malloc data 
2306			 
2306				if DEBUG_FORTH_STACK_GUARD 
2306 cd e9 6e				call check_stacks 
2309					FORTH_CHK_DSP_UNDER 
2309 e5				push hl 
230a d5				push de 
230b 2a 23 f9			ld hl,(cli_data_sp) 
230e 11 5d f6			ld de, cli_data_stack 
2311 cd fc 0f			call cmp16 
2314 da fa 6f			jp c, fault_dsp_under 
2317 d1				pop de 
2318 e1				pop hl 
2319				endm 
# End of macro FORTH_CHK_DSP_UNDER
2319				endif 
2319				;ld hl,(cli_data_sp) 
2319			if DEBUG_FORTH_DOT 
2319				DMARK "DPP" 
2319 f5				push af  
231a 3a 2e 23			ld a, (.dmark)  
231d 32 a0 fd			ld (debug_mark),a  
2320 3a 2f 23			ld a, (.dmark+1)  
2323 32 a1 fd			ld (debug_mark+1),a  
2326 3a 30 23			ld a, (.dmark+2)  
2329 32 a2 fd			ld (debug_mark+2),a  
232c 18 03			jr .pastdmark  
232e ..			.dmark: db "DPP"  
2331 f1			.pastdmark: pop af  
2332			endm  
# End of macro DMARK
2332				CALLMONITOR 
2332 cd aa fd			call debug_vector  
2335				endm  
# End of macro CALLMONITOR
2335			endif	 
2335			 
2335			 
2335			if FORTH_ENABLE_DSPPOPFREE 
2335			 
2335				FORTH_DSP 
2335 cd 13 22			call macro_forth_dsp 
2338				endm 
# End of macro FORTH_DSP
2338			 
2338 7e				ld a, (hl) 
2339 fe 01			cp DS_TYPE_STR 
233b 20 22			jr nz, .skippopfree 
233d			 
233d				FORTH_DSP_VALUEHL 
233d cd 4d 22			call macro_dsp_valuehl 
2340				endm 
# End of macro FORTH_DSP_VALUEHL
2340			;	nop 
2340			if DEBUG_FORTH_DOT 
2340				DMARK "DPf" 
2340 f5				push af  
2341 3a 55 23			ld a, (.dmark)  
2344 32 a0 fd			ld (debug_mark),a  
2347 3a 56 23			ld a, (.dmark+1)  
234a 32 a1 fd			ld (debug_mark+1),a  
234d 3a 57 23			ld a, (.dmark+2)  
2350 32 a2 fd			ld (debug_mark+2),a  
2353 18 03			jr .pastdmark  
2355 ..			.dmark: db "DPf"  
2358 f1			.pastdmark: pop af  
2359			endm  
# End of macro DMARK
2359				CALLMONITOR 
2359 cd aa fd			call debug_vector  
235c				endm  
# End of macro CALLMONITOR
235c			endif	 
235c cd 83 14			call free 
235f			.skippopfree: 
235f				 
235f			 
235f			endif 
235f			 
235f			if DEBUG_FORTH_DOT_KEY 
235f				DMARK "DP2" 
235f				CALLMONITOR 
235f			endif	 
235f			 
235f				; move pointer down 
235f			 
235f 2a 23 f9			ld hl,(cli_data_sp) 
2362 2b				dec hl 
2363 2b				dec hl 
2364			; PARSEV5 
2364 2b				dec hl 
2365 22 23 f9			ld (cli_data_sp), hl 
2368			 
2368				if DEBUG_FORTH_STACK_GUARD 
2368 cd e9 6e				call check_stacks 
236b					FORTH_CHK_DSP_UNDER 
236b e5				push hl 
236c d5				push de 
236d 2a 23 f9			ld hl,(cli_data_sp) 
2370 11 5d f6			ld de, cli_data_stack 
2373 cd fc 0f			call cmp16 
2376 da fa 6f			jp c, fault_dsp_under 
2379 d1				pop de 
237a e1				pop hl 
237b				endm 
# End of macro FORTH_CHK_DSP_UNDER
237b				endif 
237b			 
237b e1				pop hl 
237c			 
237c c9				ret 
237d			 
237d			getwordathl: 
237d				; hl points to an address 
237d				; load hl with the word at that address 
237d			 
237d d5				push de 
237e			 
237e 5e				ld e, (hl) 
237f 23				inc hl 
2380 56				ld d, (hl) 
2381 eb				ex de, hl 
2382			 
2382 d1				pop de 
2383 c9				ret 
2384			 
2384			 
2384			; functions to manuplite stack pointers 
2384			 
2384			; generate fragment to set hl to be pointer to a stack item 
2384			 
2384			FORTH_DSP_PTR: macro  x 
2384				ld hl,(cli_data_sp) 
2384				ld de, x * 3 
2384				sbc hl, de 
2384				endm 
2384			 
2384			 
2384			 
2384			; copy point in hl to stack tmp storage slots 1-4 
2384			hltostack1: 
2384 11 f3 f0			ld de, os_stack_1  
2387 c3 b2 23			jp hltostackmv 
238a			 
238a			hltostack2:  
238a 11 f0 f0			ld de, os_stack_2 
238d c3 b2 23			jp hltostackmv 
2390			 
2390			hltostack3:  
2390 11 ed f0			ld de, os_stack_3 
2393 c3 b2 23			jp hltostackmv 
2396			 
2396			hltostack4:  
2396 11 ea f0			ld de, os_stack_4  
2399 c3 b2 23			jp hltostackmv 
239c			 
239c			; copy to point in hl from stack tmp storage slots 1-4 
239c			hlfromstack1: 
239c 11 f3 f0			ld de, os_stack_1 
239f c3 b1 23			jp hlfromsttackmv 
23a2			 
23a2			hlfromstack2:  
23a2 11 f0 f0			ld de, os_stack_2 
23a5 c3 b1 23			jp hlfromsttackmv 
23a8			 
23a8			hlfromstack3:  
23a8 11 ed f0			ld de, os_stack_3 
23ab c3 b1 23			jp hlfromsttackmv 
23ae			 
23ae			hlfromstack4:  
23ae 11 ea f0			ld de, os_stack_4 
23b1			 
23b1			hlfromsttackmv: 
23b1 eb				ex de, hl 
23b2			 
23b2			hltostackmv: 
23b2			 
23b2				; do stack move 
23b2 c5				push bc 
23b3 01 03 00			ld bc, 3 
23b6 ed b0			ldir  
23b8 c1				pop bc	 
23b9 c9				ret 
23ba			 
23ba			; eof 
23ba			 
# End of file forth_stackopsv5.asm
23ba			endif 
23ba			loadwordinhl:	 
23ba			 
23ba d5				push de 
23bb			 
23bb 5e				ld e, (hl) 
23bc 23				inc hl 
23bd 56				ld d, (hl) 
23be eb				ex de,hl  
23bf			 
23bf d1				pop de 
23c0			 
23c0 c9				ret 
23c1			 
23c1			user_word_eol:  
23c1				; hl contains the pointer to where to create a linked list item from the end 
23c1				; of the user dict to continue on at the system word dict 
23c1				 
23c1				; poke the stub of the word list linked list to repoint to rom words 
23c1			 
23c1				; stub format 
23c1				; db   word id 
23c1				; dw    link to next word 
23c1			        ; db char length of token 
23c1				; db string + 0 term 
23c1				; db exec code....  
23c1			 
23c1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
23c3 77				ld (hl), a		; word id 
23c4 23				inc hl 
23c5			 
23c5 11 7c 25			ld de, sysdict 
23c8 73				ld (hl), e		; next word link ie system dict 
23c9 23				inc hl 
23ca 72				ld (hl), d		; next word link ie system dict 
23cb 23				inc hl	 
23cc			 
23cc			;	ld (hl), sysdict		; next word link ie system dict 
23cc			;	inc hl 
23cc			;	inc hl 
23cc			 
23cc			;	inc hl 
23cc			;	inc hl 
23cc			 
23cc 3e 02			ld a, 2			; word length is 0 
23ce 77				ld (hl), a	 
23cf 23				inc hl 
23d0			 
23d0 3e 7e			ld a, '~'			; word length is 0 
23d2 77				ld (hl), a	 
23d3 23				inc hl 
23d4 3e 00			ld a, 0			; save empty word 
23d6 77				ld (hl), a 
23d7			 
23d7 c9				ret 
23d8			 
23d8				 
23d8			 
23d8			forthexec_cleanup: 
23d8				FORTH_RSP_POP 
23d8 cd 10 20			call macro_forth_rsp_pop 
23db				endm 
# End of macro FORTH_RSP_POP
23db c9				ret 
23dc			 
23dc			forth_call_hl: 
23dc				; taking hl 
23dc e5				push hl 
23dd c9				ret 
23de			 
23de			; this is called to reset Forth system but keep existing uwords etc 
23de			 
23de			forth_warmstart: 
23de				; setup stack over/under flow checks 
23de				if DEBUG_FORTH_STACK_GUARD 
23de cd cf 6e				call chk_stk_init 
23e1				endif 
23e1			 
23e1				; init stack pointers  - * these stacks go upwards *  
23e1 21 e1 f8			ld hl, cli_ret_stack 
23e4 22 27 f9			ld (cli_ret_sp), hl	 
23e7				; set bottom of stack 
23e7 3e 00			ld a,0 
23e9 77				ld (hl),a 
23ea 23				inc hl 
23eb 77				ld (hl),a 
23ec			 
23ec 21 5d f6			ld hl, cli_data_stack 
23ef 22 23 f9			ld (cli_data_sp), hl	 
23f2				; set bottom of stack 
23f2 3e 00			ld a,0 
23f4 77				ld (hl),a 
23f5 23				inc hl 
23f6 77				ld (hl),a 
23f7			 
23f7 21 5f f8			ld hl, cli_loop_stack 
23fa 22 25 f9			ld (cli_loop_sp), hl	 
23fd				; set bottom of stack 
23fd 3e 00			ld a,0 
23ff 77				ld (hl),a 
2400 23				inc hl 
2401 77				ld (hl),a 
2402			 
2402				; init extent of current open file 
2402			 
2402 3e 00			ld a, 0 
2404 32 9f f9			ld (store_openext), a 
2407			 
2407 c9				ret 
2408			 
2408			 
2408			 
2408			; Cold Start - this is called to setup the whole Forth system 
2408			 
2408			forth_init: 
2408			 
2408				; setup stack over/under flow checks 
2408			 
2408			;	if DEBUG_FORTH_STACK_GUARD 
2408			;		call chk_stk_init 
2408			;	endif 
2408			 
2408				; enable auto display updates (slow.....) 
2408			 
2408 3e 01			ld a, 1 
240a 32 71 f9			ld (cli_autodisplay), a 
240d			 
240d				; if storage is in use disable long reads for now 
240d 3e 00			ld a, 0 
240f 32 aa f9			ld (store_longread), a 
2412			 
2412			 
2412				; show start up screen 
2412			 
2412 cd aa 0d			call clear_display 
2415			 
2415 3e 00			ld a,0 
2417 32 93 f9			ld (f_cursor_ptr), a 
241a			 
241a				; set start of word list in start of ram - for use when creating user words 
241a			 
241a 21 00 80			ld hl, baseram 
241d 22 f3 f3			ld (os_last_new_uword), hl 
2420 cd c1 23			call user_word_eol 
2423				 
2423			;		call display_data_sp 
2423			;		call next_page_prompt 
2423			 
2423			 
2423			 
2423			 
2423 c9				ret 
2424			 
2424 .. 00		.bootforth: db " Forth Kernel Init ",0 
2438			 
2438			; TODO push to stack 
2438			 
2438			;  
2438			 
2438			if FORTH_PARSEV2 
2438			 
2438			 
2438				include "forth_parserv2.asm" 
2438			 
2438			endif 
2438			 
2438			 
2438			; parse cli version 1 
2438			 
2438			if FORTH_PARSEV1 
2438			 
2438			 
2438			 
2438			      include "forth_parserv1.asm" 
2438			endif 
2438				 
2438			if FORTH_PARSEV3 
2438			      include "forth_parserv3.asm" 
2438				include "forth_wordsv3.asm" 
2438			endif 
2438			 
2438			if FORTH_PARSEV4 
2438			      include "forth_parserv4.asm" 
2438				include "forth_wordsv4.asm" 
2438			endif 
2438			 
2438			if FORTH_PARSEV5 
2438			      include "forth_parserv5.asm" 
2438				include "forth_wordsv4.asm" 
2438			endif 
2438			 
2438			if FORTH_PARSEV6 
2438			      include "forth_parserv6.asm" 
2438			 
2438			 
2438			; A better parser without using malloc and string copies all over the place.  
2438			; Exec in situ should be faster 
2438			 
2438			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2438			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2438			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2438			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2438			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2438			WORD_SYS_END: equ 0   ; Opcode for all user words 
2438			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2438			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2438			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2438			 
2438			; Core word preamble macro 
2438			 
2438			CWHEAD:   macro nxtword opcode lit len opflags 
2438				db WORD_SYS_CORE+opcode             
2438				; internal op code number 
2438				dw nxtword            
2438				; link to next dict word block 
2438				db len + 1 
2438				; literal length of dict word inc zero term 
2438				db lit,0              
2438				; literal dict word 
2438			        ; TODO db opflags        
2438				endm 
2438			 
2438			 
2438			NEXTW: macro  
2438				jp macro_next 
2438				endm 
2438			 
2438			macro_next: 
2438			if DEBUG_FORTH_PARSE_EXEC 
2438				DMARK "NXT" 
2438				CALLMONITOR 
2438			endif	 
2438			;	inc hl  ; skip token null term  
2438 ed 4b 75 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
243c ed 5b 73 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2440 2a f7 f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2443			if DEBUG_FORTH_PARSE_EXEC 
2443				DMARK "}AA" 
2443				CALLMONITOR 
2443			endif	 
2443 c3 32 25			jp execnext 
2446				;jp exec1 
2446			       
2446			 
2446			 
2446			; Another go at the parser to compile  
2446			 
2446			 
2446			; TODO rework parser to change all of the string words to byte tokens 
2446			; TODO do a search for  
2446			 
2446			; TODO first run normal parser to zero term sections 
2446			; TODO for each word do a token look up to get the op code 
2446			; TODO need some means to flag to the exec that this is a byte code form    
2446			 
2446			 
2446			forthcompile: 
2446			 
2446			; 
2446			; line parse: 
2446			;       parse raw input buffer 
2446			;       tokenise the words 
2446			;       malloc new copy (for looping etc) 
2446			;       copy to malloc + current pc in line to start of string and add line term 
2446			;       save on new rsp 
2446			; 
2446			 
2446			; hl to point to the line to tokenise 
2446			 
2446			;	push hl 
2446 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2449			 
2449			;	ld a,0		; string term on input 
2449			;	call strlent 
2449			 
2449			;	ld (os_tok_len), hl	 ; save string length 
2449			 
2449			;if DEBUG_FORTH_TOK 
2449			;	ex de,hl		 
2449			;endif 
2449			 
2449			;	pop hl 		; get back string pointer 
2449			 
2449			if DEBUG_FORTH_TOK 
2449						DMARK "TOc" 
2449				CALLMONITOR 
2449			endif 
2449 7e			.cptoken2:    ld a,(hl) 
244a 23				inc hl 
244b fe 7f			cp FORTH_END_BUFFER 
244d 28 29			jr z, .cptokendone2 
244f fe 00			cp 0 
2451 28 25			jr z, .cptokendone2 
2453 fe 22			cp '"' 
2455 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2457 fe 20			cp ' ' 
2459 20 ee			jr nz,  .cptoken2 
245b			 
245b			; TODO consume comments held between ( and ) 
245b			 
245b				; we have a space so change to zero term for dict match later 
245b 2b				dec hl 
245c 3e 00			ld a,0 
245e 77				ld (hl), a 
245f 23				inc hl 
2460 18 e7			jr .cptoken2 
2462				 
2462			 
2462			.cptokenstr2: 
2462				; skip all white space until either eol (because forgot to term) or end double quote 
2462			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2462				;inc hl ; skip current double quote 
2462 7e				ld a,(hl) 
2463 23				inc hl 
2464 fe 22			cp '"' 
2466 28 e1			jr z, .cptoken2 
2468 fe 7f			cp FORTH_END_BUFFER 
246a 28 0c			jr z, .cptokendone2 
246c fe 00			cp 0 
246e 28 08			jr z, .cptokendone2 
2470 fe 20			cp ' ' 
2472 28 02			jr z, .cptmp2 
2474 18 ec			jr .cptokenstr2 
2476			 
2476			.cptmp2:	; we have a space so change to zero term for dict match later 
2476				;dec hl 
2476				;ld a,"-"	; TODO remove this when working 
2476				;ld (hl), a 
2476				;inc hl 
2476 18 ea			jr .cptokenstr2 
2478			 
2478			.cptokendone2: 
2478				;inc hl 
2478 3e 7f			ld a, FORTH_END_BUFFER 
247a 77				ld (hl),a 
247b			;	inc hl 
247b			;	ld a, '!' 
247b			;	ld (hl),a 
247b			 
247b 2a f7 f3			ld hl,(os_tok_ptr) 
247e			         
247e			if DEBUG_FORTH_TOK 
247e						DMARK "Tc1" 
247e				CALLMONITOR 
247e			endif 
247e			 
247e				; push exec string to top of return stack 
247e				FORTH_RSP_NEXT 
247e cd ef 1f			call macro_forth_rsp_next 
2481				endm 
# End of macro FORTH_RSP_NEXT
2481 c9				ret 
2482			 
2482			; Another go at the parser need to simplify the process 
2482			 
2482			forthparse: 
2482			 
2482			; 
2482			; line parse: 
2482			;       parse raw input buffer 
2482			;       tokenise the words 
2482			;       malloc new copy (for looping etc) 
2482			;       copy to malloc + current pc in line to start of string and add line term 
2482			;       save on new rsp 
2482			; 
2482			 
2482			; hl to point to the line to tokenise 
2482			 
2482			;	push hl 
2482 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
2485			 
2485			;	ld a,0		; string term on input 
2485			;	call strlent 
2485			 
2485			;	ld (os_tok_len), hl	 ; save string length 
2485			 
2485			;if DEBUG_FORTH_TOK 
2485			;	ex de,hl		 
2485			;endif 
2485			 
2485			;	pop hl 		; get back string pointer 
2485			 
2485			if DEBUG_FORTH_TOK 
2485						DMARK "TOK" 
2485				CALLMONITOR 
2485			endif 
2485 7e			.ptoken2:    ld a,(hl) 
2486 23				inc hl 
2487 fe 7f			cp FORTH_END_BUFFER 
2489 28 29			jr z, .ptokendone2 
248b fe 00			cp 0 
248d 28 25			jr z, .ptokendone2 
248f fe 22			cp '"' 
2491 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2493 fe 20			cp ' ' 
2495 20 ee			jr nz,  .ptoken2 
2497			 
2497			; TODO consume comments held between ( and ) 
2497			 
2497				; we have a space so change to zero term for dict match later 
2497 2b				dec hl 
2498 3e 00			ld a,0 
249a 77				ld (hl), a 
249b 23				inc hl 
249c 18 e7			jr .ptoken2 
249e				 
249e			 
249e			.ptokenstr2: 
249e				; skip all white space until either eol (because forgot to term) or end double quote 
249e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
249e				;inc hl ; skip current double quote 
249e 7e				ld a,(hl) 
249f 23				inc hl 
24a0 fe 22			cp '"' 
24a2 28 e1			jr z, .ptoken2 
24a4 fe 7f			cp FORTH_END_BUFFER 
24a6 28 0c			jr z, .ptokendone2 
24a8 fe 00			cp 0 
24aa 28 08			jr z, .ptokendone2 
24ac fe 20			cp ' ' 
24ae 28 02			jr z, .ptmp2 
24b0 18 ec			jr .ptokenstr2 
24b2			 
24b2			.ptmp2:	; we have a space so change to zero term for dict match later 
24b2				;dec hl 
24b2				;ld a,"-"	; TODO remove this when working 
24b2				;ld (hl), a 
24b2				;inc hl 
24b2 18 ea			jr .ptokenstr2 
24b4			 
24b4			.ptokendone2: 
24b4				;inc hl 
24b4 3e 7f			ld a, FORTH_END_BUFFER 
24b6 77				ld (hl),a 
24b7			;	inc hl 
24b7			;	ld a, '!' 
24b7			;	ld (hl),a 
24b7			 
24b7 2a f7 f3			ld hl,(os_tok_ptr) 
24ba			         
24ba			if DEBUG_FORTH_TOK 
24ba						DMARK "TK1" 
24ba				CALLMONITOR 
24ba			endif 
24ba			 
24ba				; push exec string to top of return stack 
24ba				FORTH_RSP_NEXT 
24ba cd ef 1f			call macro_forth_rsp_next 
24bd				endm 
# End of macro FORTH_RSP_NEXT
24bd c9				ret 
24be			 
24be			; 
24be			;	; malloc size + buffer pointer + if is loop flag 
24be			;	ld hl,(os_tok_len) 		 ; get string length 
24be			; 
24be			;	ld a,l 
24be			; 
24be			;	cp 0			; we dont want to use a null string 
24be			;	ret z 
24be			; 
24be			;;	add 3    ; prefix malloc with buffer for current word ptr 
24be			; 
24be			;	add 5     ; TODO when certain not over writing memory remove 
24be			; 
24be			;		 
24be			; 
24be			;if DEBUG_FORTH_TOK 
24be			;			DMARK "TKE" 
24be			;	CALLMONITOR 
24be			;endif 
24be			; 
24be			;	ld l,a 
24be			;	ld h,0 
24be			;;	push hl   ; save required space for the copy later 
24be			;	call malloc 
24be			;if DEBUG_FORTH_TOK 
24be			;			DMARK "TKM" 
24be			;	CALLMONITOR 
24be			;endif 
24be			;	if DEBUG_FORTH_MALLOC_GUARD 
24be			;		push af 
24be			;		call ishlzero 
24be			;;		ld a, l 
24be			;;		add h 
24be			;;		cp 0 
24be			;		pop af 
24be			;		 
24be			;		call z,malloc_error 
24be			;	endif 
24be			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
24be			; 
24be			; 
24be			;if DEBUG_FORTH_TOK 
24be			;			DMARK "TKR" 
24be			;	CALLMONITOR 
24be			;endif 
24be			; 
24be			;	FORTH_RSP_NEXT 
24be			; 
24be			;	;inc hl	 ; go past current buffer pointer 
24be			;	;inc hl 
24be			;	;inc hl   ; and past if loop flag 
24be			;		; TODO Need to set flag  
24be			; 
24be			;	 
24be			;	 
24be			;	ex de,hl	; malloc is dest 
24be			;	ld hl, (os_tok_len) 
24be			;;	pop bc 
24be			;	ld c, l                
24be			;	ld b,0 
24be			;	ld hl, (os_tok_ptr) 
24be			; 
24be			;if DEBUG_FORTH_TOK 
24be			;			DMARK "TKT" 
24be			;	CALLMONITOR 
24be			;endif 
24be			; 
24be			;	; do str cpy 
24be			; 
24be			;	ldir      ; copy byte in hl to de 
24be			; 
24be			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
24be			; 
24be			;if DEBUG_FORTH_TOK 
24be			; 
24be			;			DMARK "TKY" 
24be			;	CALLMONITOR 
24be			;endif 
24be			;	;ld a,0 
24be			;	;ld a,FORTH_END_BUFFER 
24be			;	ex de, hl 
24be			;	;dec hl			 ; go back over the space delim at the end of word 
24be			;	;ld (hl),a 
24be			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
24be			;	ld a,FORTH_END_BUFFER 
24be			;	ld (hl),a 
24be			;	inc hl 
24be			;	ld a,FORTH_END_BUFFER 
24be			;	ld (hl),a 
24be			; 
24be			;	; init the malloc area data 
24be			;	; set pc for in current area 
24be			;	;ld hl, (os_tok_malloc) 
24be			;	;inc hl 
24be			;	;inc hl 
24be			;	;inc hl 
24be			;	;ex de,hl 
24be			;	;ld hl, (os_tok_malloc) 
24be			;	;ld (hl),e 
24be			;	;inc hl 
24be			;	;ld (hl),d 
24be			; 
24be			; 
24be			;	ld hl,(os_tok_malloc) 
24be			;if DEBUG_FORTH_PARSE_KEY 
24be			;			DMARK "TKU" 
24be			;	CALLMONITOR 
24be			;endif 
24be			; 
24be			;	ret 
24be			 
24be			forthexec: 
24be			 
24be			; line exec: 
24be			; forth parser 
24be			 
24be			; 
24be			;       get current exec line on rsp 
24be			 
24be				FORTH_RSP_TOS 
24be cd 06 20			call macro_forth_rsp_tos 
24c1				endm 
# End of macro FORTH_RSP_TOS
24c1			 
24c1			;       restore current pc - hl points to malloc of data 
24c1			 
24c1				;ld e, (hl) 
24c1				;inc hl 
24c1				;ld d, (hl) 
24c1				;ex de,hl 
24c1			 
24c1			 
24c1			exec1: 
24c1 22 f7 f3			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
24c4			 
24c4				; copy our PC to working vars  
24c4 22 75 f9			ld (cli_ptr), hl                    ; here 
24c7 22 73 f9			ld (cli_origptr), hl                ; here 
24ca			 
24ca 7e				ld a,(hl)                           ; here make hl be the ram ptr 
24cb fe 7f			cp FORTH_END_BUFFER 
24cd c8				ret z 
24ce			 
24ce				; skip any nulls 
24ce			 
24ce fe 00			cp 0 
24d0 20 03			jr nz, .execword 
24d2 23				inc hl 
24d3 18 ec			jr exec1 
24d5			 
24d5			 
24d5			.execword: 
24d5			 
24d5			 
24d5			 
24d5			if DEBUG_FORTH_PARSE_EXEC 
24d5						DMARK "KYQ" 
24d5				CALLMONITOR 
24d5			endif 
24d5			;       while at start of word: 
24d5			; get start of dict (in user area first) 
24d5			 
24d5 21 00 80		ld hl, baseram 
24d8			;ld hl, sysdict 
24d8 22 77 f9		ld (cli_nextword),hl                            ; here do we need to do this? 
24db			;           match word at pc 
24db			;           exec word 
24db			;           or push to dsp 
24db			;           forward to next token 
24db			;           if line term pop rsp and exit 
24db			;        
24db			 
24db			if DEBUG_FORTH_PARSE_EXEC 
24db						DMARK "KYq" 
24db				CALLMONITOR 
24db			endif 
24db			 
24db			; 
24db			; word comp 
24db			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
24db			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
24db			;    move to start of word  
24db			;    compare word to cli_token 
24db			 
24db			.execpnword:	; HL at start of a word in the dictionary to check 
24db			 
24db 2a 77 f9			ld hl,(cli_nextword)                  ; here remove the need to store???? 
24de			 
24de cd 75 25			call forth_tok_next 
24e1			; tok next end here 
24e1 22 77 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
24e4 eb				ex de, hl 
24e5			 
24e5			 
24e5				; save the pointer of the current token - 1 to check against 
24e5				 
24e5 22 7b f9			ld (cli_token), hl   
24e8				; TODO maybe remove below save if no debug 
24e8				; save token string ptr for any debug later 
24e8 23				inc hl  
24e9 22 7d f9			ld (cli_origtoken), hl 
24ec 2b				dec hl 
24ed				; save pointer to the start of the next dictionay word 
24ed 7e				ld a,(hl)   ; get string length 
24ee 47				ld b,a 
24ef			.execpnwordinc:  
24ef 23				inc hl 
24f0 10 fd			djnz .execpnwordinc 
24f2 22 79 f9			ld (cli_execword), hl      ; save start of this words code 
24f5			 
24f5				; now check the word token against the string being parsed 
24f5			 
24f5 2a 7b f9			ld hl,(cli_token) 
24f8 23				inc hl     ; skip string length (use zero term instead to end) 
24f9				;ld (cli_token), hl 
24f9			 
24f9			.execpnchar:    ; compare char between token and string to parse 
24f9			 
24f9			 
24f9				;ld hl, (cli_token)     ; the dict word  
24f9 ed 5b 75 f9		ld de, (cli_ptr)     ; cli to parse 
24fd			 
24fd			 
24fd			.execpncharl:    ; compare char between token and string to parse (loop) 
24fd			 
24fd 1a				ld a,(de) 
24fe cd 3b 13			call toUpper 		; make sure the input string matches case 
2501 be				cp (hl) 
2502			 
2502 c2 1b 25			jp nz, .execpnskipword	 ; no match so move to next word 
2505				 
2505			;    if same 
2505			;       scan for string terms 0 for token and 32 for input 
2505 46				ld b,(hl) 
2506 80				add b			 
2507 23				inc hl 
2508 13				inc de 
2509 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
250b							; TODO need to make sure last word in zero term string is accounted for 
250b 20 f0			jr nz, .execpncharl 		 ; not at end of strings yet 
250d			 
250d			 
250d				; at end of both strings so both are exact match 
250d			 
250d			;       skip ptr for next word 
250d			 
250d 2a 75 f9			ld hl,(cli_ptr) 	; at input string term 
2510 23				inc hl			 ; at next char 
2511 22 75 f9			ld (cli_ptr), hl     ; save for next round of the parser 
2514 22 73 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2517				 
2517				 
2517			 
2517			 
2517			 
2517			;       exec code block 
2517			if DEBUG_FORTH_JP 
2517				call clear_display 
2517				call update_display 
2517				call delay1s 
2517				ld hl, (cli_execword)     ; save for next check if no match on this word 
2517				ld a,h 
2517				ld hl, os_word_scratch 
2517				call hexout 
2517				ld hl, (cli_execword)     ; save for next check if no match on this word 
2517				ld a,l 
2517				ld hl, os_word_scratch+2 
2517				call hexout 
2517				ld hl, os_word_scratch+4 
2517				ld a,0 
2517				ld (hl),a 
2517				ld de,os_word_scratch 
2517				call str_at_display 
2517					ld a, display_row_2 
2517					call str_at_display 
2517				ld de, (cli_origtoken) 
2517				ld a, display_row_1+10 
2517					call str_at_display 
2517			 
2517				ld a,display_row_1 
2517				ld de, .foundword 
2517				ld a, display_row_3 
2517				call str_at_display 
2517				call update_display 
2517				call delay1s 
2517				call delay1s 
2517				call delay1s 
2517			endif 
2517			 
2517			if DEBUG_FORTH_PARSE_EXEC 
2517						DMARK "KYj" 
2517			endif 
2517				; TODO save the word pointer in this exec 
2517			 
2517 2a 79 f9			ld hl,(cli_execword) 
251a e9				jp (hl) 
251b			 
251b			 
251b			;    if not same 
251b			;	scan for zero term 
251b			;	get ptr for next word 
251b			;	goto word comp 
251b			 
251b			.execpnskipword:	; get pointer to next word 
251b 2a 77 f9			ld hl,(cli_nextword) 
251e			 
251e 7e				ld a,(hl) 
251f fe 00			cp WORD_SYS_END 
2521			;	cp 0 
2521 28 09			jr z, .execendofdict			 ; at end of words 
2523			 
2523			if DEBUG_FORTH_PARSE_EXEC 
2523						DMARK "KY4" 
2523			endif 
2523			if DEBUG_FORTH_PARSE_EXEC 
2523			 
2523				; see if disabled 
2523			 
2523			;	ld a, (os_view_disable) 
2523			;	cp '*' 
2523				ld a,(debug_vector) 
2523				cp $c9   ; RET 
2523				jr z, .noskip 
2523			 
2523			 
2523				ld de, .nowordfound 
2523				ld a, display_row_3 
2523				call str_at_display 
2523				call update_display 
2523				ld a, 100 
2523				call aDelayInMS 
2523				 
2523				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2523					call delay250ms 
2523				endif 
2523			.noskip:  
2523			 
2523			endif	 
2523			 
2523 2a 73 f9			ld hl,(cli_origptr) 
2526 22 75 f9			ld (cli_ptr),hl 
2529			 
2529			if DEBUG_FORTH_PARSE_EXEC 
2529						DMARK "KY5" 
2529			endif 
2529 c3 db 24			jp .execpnword			; else go to next word 
252c			 
252c			.execendofdict:  
252c			 
252c			if DEBUG_FORTH_PARSE_EXEC 
252c						DMARK "KYe" 
252c			endif 
252c			if DEBUG_FORTH_PARSE_EXEC 
252c				; see if disabled 
252c			 
252c			;	ld a, (os_view_disable) 
252c			;	cp '*' 
252c				ld a,(debug_vector) 
252c				cp $c9   ; ret 
252c				jr z, .ispskip 
252c			 
252c				call clear_display 
252c				call update_display 
252c				call delay1s 
252c				ld de, (cli_origptr) 
252c				ld a, display_row_1 
252c				call str_at_display 
252c				 
252c				ld de, .enddict 
252c				ld a, display_row_3 
252c				call str_at_display 
252c				call update_display 
252c				ld a, 100 
252c				call aDelayInMS 
252c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
252c				call delay1s 
252c				call delay1s 
252c				call delay1s 
252c				endif 
252c			.ispskip:  
252c				 
252c			endif	 
252c			 
252c			 
252c			 
252c				; if the word is not a keyword then must be a literal so push it to stack 
252c			 
252c			; push token to stack to end of word 
252c			 
252c				STACKFRAME ON $1efe $2f9f 
252c				if DEBUG_STACK_IMB 
252c					if ON 
252c						exx 
252c						ld de, $1efe 
252c						ld a, d 
252c						ld hl, curframe 
252c						call hexout 
252c						ld a, e 
252c						ld hl, curframe+2 
252c						call hexout 
252c						ld hl, $1efe 
252c						push hl 
252c						ld hl, $2f9f 
252c						push hl 
252c						exx 
252c					endif 
252c				endif 
252c			endm 
# End of macro STACKFRAME
252c			 
252c 2a f7 f3		ld hl,(os_tok_ptr) 
252f cd b1 21		call forth_apush 
2532			 
2532				STACKFRAMECHK ON $1efe $2f9f 
2532				if DEBUG_STACK_IMB 
2532					if ON 
2532						exx 
2532						ld hl, $2f9f 
2532						pop de   ; $2f9f 
2532						call cmp16 
2532						jr nz, .spnosame 
2532						ld hl, $1efe 
2532						pop de   ; $1efe 
2532						call cmp16 
2532						jr z, .spfrsame 
2532						.spnosame: call showsperror 
2532						.spfrsame: nop 
2532						exx 
2532					endif 
2532				endif 
2532			endm 
# End of macro STACKFRAMECHK
2532			 
2532			execnext: 
2532			 
2532			if DEBUG_FORTH_PARSE_EXEC 
2532						DMARK "KY>" 
2532			endif 
2532			; move past token to next word 
2532			 
2532 2a f7 f3		ld hl, (os_tok_ptr) 
2535 3e 00		ld a, 0 
2537 01 ff 00		ld bc, 255     ; input buffer size 
253a ed b1		cpir 
253c			 
253c			if DEBUG_FORTH_PARSE_EXEC 
253c						DMARK "KY!" 
253c				CALLMONITOR 
253c			endif	 
253c			; TODO this might place hl on the null, so will need to forward on??? 
253c			;inc hl   ; see if this gets onto the next item 
253c			 
253c			 
253c			; TODO pass a pointer to the buffer to push 
253c			; TODO call function to push 
253c			 
253c			; look for end of input 
253c			 
253c			;inc hl 
253c			;ld a,(hl) 
253c			;cp FORTH_END_BUFFER 
253c			;ret z 
253c			 
253c			 
253c c3 c1 24		jp exec1 
253f			 
253f			 
253f			 
253f			 
253f			 
253f			 
253f			 
253f			 
253f			 
253f			findnexttok: 
253f			 
253f				; hl is pointer to move 
253f				; de is the token to locate 
253f			 
253f					if DEBUG_FORTH 
253f						DMARK "NTK" 
253f						CALLMONITOR 
253f					endif 
253f d5				push de 
2540			 
2540			.fnt1:	 
2540				; find first char of token to locate 
2540			 
2540 1a				ld a, (de) 
2541 4f				ld c,a 
2542 7e				ld a,(hl) 
2543 cd 3b 13			call toUpper 
2546					if DEBUG_FORTH 
2546						DMARK "NT1" 
2546						CALLMONITOR 
2546					endif 
2546 b9				cp c 
2547			 
2547 28 03			jr z, .fnt2cmpmorefirst	 
2549			 
2549				; first char not found move to next char 
2549			 
2549 23				inc hl 
254a 18 f4			jr .fnt1 
254c			 
254c			.fnt2cmpmorefirst:	 
254c				; first char of token found.  
254c			 
254c e5				push hl     ; save start of token just in case it is the right one 
254d d9				exx 
254e e1				pop hl        ; save it to hl' 
254f d9				exx 
2550			 
2550			 
2550			.fnt2cmpmore:	 
2550				; compare the rest 
2550				 
2550 23				inc hl 
2551 13				inc de 
2552				 
2552 1a				ld a, (de) 
2553 4f				ld c,a 
2554 7e				ld a,(hl) 
2555 cd 3b 13			call toUpper 
2558			 
2558					if DEBUG_FORTH 
2558						DMARK "NT2" 
2558						CALLMONITOR 
2558					endif 
2558				; c has the token to find char 
2558				; a has the mem to scan char 
2558			 
2558 b9				cp c 
2559 28 04			jr z,.fntmatch1 
255b			 
255b				; they are not the same 
255b			 
255b					if DEBUG_FORTH 
255b						DMARK "NT3" 
255b						CALLMONITOR 
255b					endif 
255b d1				pop de	; reset de token to look for 
255c d5				push de 
255d 18 e1			jr .fnt1 
255f				 
255f			.fntmatch1: 
255f			 
255f				; is the same char a null which means we might have a full hit? 
255f					if DEBUG_FORTH 
255f						DMARK "NT4" 
255f						CALLMONITOR 
255f					endif 
255f			 
255f fe 00			cp 0 
2561 28 0b			jr z, .fntmatchyes 
2563			 
2563				; are we at the end of the token to find? 
2563			 
2563					if DEBUG_FORTH 
2563						DMARK "NT5" 
2563						CALLMONITOR 
2563					endif 
2563 3e 00			ld a, 0 
2565 b9				cp c 
2566			 
2566 c2 50 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2569			 
2569					if DEBUG_FORTH 
2569						DMARK "NT6" 
2569						CALLMONITOR 
2569					endif 
2569				; token to find is exhusted but no match to stream 
2569			 
2569				; restore tok pointer and continue on 
2569 d1				pop de 
256a d5				push de 
256b c3 40 25			jp .fnt1 
256e			 
256e			 
256e			.fntmatchyes: 
256e			 
256e				; hl now contains the end of the found token 
256e			 
256e				; get rid of saved token pointer to find 
256e			 
256e d1				pop de 
256f			 
256f					if DEBUG_FORTH 
256f						DMARK "NT9" 
256f						CALLMONITOR 
256f					endif 
256f			 
256f				; hl will be on the null term so forward on 
256f			 
256f				; get back the saved start of the token 
256f			 
256f d9				exx 
2570 e5				push hl     ; save start of token just in case it is the right one 
2571 d9				exx 
2572 e1				pop hl        ; save it to hl 
2573			 
2573 c9				ret 
2574			 
2574			 
2574			; LIST needs to find a specific token   
2574			; FORGET needs to find a spefici token 
2574			 
2574			; SAVE needs to find all tokens by flag 
2574			; WORDS just needs to scan through all  by flag 
2574			; UWORDS needs to scan through all by flag 
2574			 
2574			 
2574			; given hl as pointer to start of dict look up string 
2574			; return hl as pointer to start of word block 
2574			; or 0 if not found 
2574			 
2574			forth_find_tok: 
2574 c9				ret 
2575			 
2575			; given hl as pointer to dict structure 
2575			; move to the next dict block structure 
2575			 
2575			forth_tok_next: 
2575				; hl now points to the address of the next word pointer  
2575				; TODO skip compiled symbol for now 
2575			;	push de 
2575 23				inc hl 
2576 5e				ld e, (hl) 
2577 23				inc hl 
2578 56				ld d, (hl) 
2579 23				inc hl 
257a			 
257a eb				ex de,hl 
257b			if DEBUG_FORTH_PARSE_NEXTWORD 
257b				push bc 
257b				ld bc, (cli_nextword) 
257b						DMARK "NXW" 
257b				CALLMONITOR 
257b				pop bc 
257b			endif 
257b			;	pop de	 
257b c9				ret 
257c			 
257c			 
257c			 
257c			; eof 
# End of file forth_parserv6.asm
257c				include "forth_wordsv4.asm" 
257c			 
257c			; the core word dictionary v4 
257c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
257c			 
257c			; this is a linked list for each of the system words used 
257c			; user defined words will follow the same format but will be in ram 
257c			 
257c			 
257c			; 
257c			; 
257c			; define linked list: 
257c			; 
257c			; 1. compiled byte op code 
257c			; 2. len of text word 
257c			; 3. text word 
257c			; 4. ptr to next dictionary word 
257c			; 5. asm, calls etc for the word 
257c			; 
257c			;  if 1 == 0 then last word in dict  
257c			;   
257c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
257c			;  
257c			;  
257c			; create basic standard set of words 
257c			; 
257c			;  
257c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
257c			; 2DUP 2DROP 2SWAP  
257c			; @ C@ - get byte  
257c			; ! C! - store byte 
257c			; 0< true if less than zero 
257c			; 0= true if zero 
257c			; < >  
257c			; = true if same 
257c			; variables 
257c			 
257c			 
257c			; Hardware specific words I may need 
257c			; 
257c			; IN OUT  
257c			; calls to key util functions 
257c			; calls to hardward abstraction stuff 
257c			; easy control of frame buffers and lcd i/o 
257c			; keyboard  
257c			 
257c			 
257c			;DICT: macro 
257c			; op_code, len, word, next 
257c			;    word: 
257c			;    db op_code 
257c			;    ds word zero term 
257c			;    dw next 
257c			;    endm 
257c			 
257c			 
257c			 
257c			 
257c			; op code 1 is a flag for user define words which are to be handled differently 
257c			 
257c			 
257c			; 
257c			; 
257c			;    TODO on entry to a word this should be the expected environment 
257c			;    hl - tos value if number then held, if string this is the ptr 
257c			;    de -  
257c			 
257c			 
257c			; opcode ranges 
257c			; 0 - end of word dict 
257c			; 255 - user define words 
257c			 
257c			sysdict: 
257c			include "forth_opcodes.asm" 
257c			; op codes for forth keywords 
257c			 
257c			; Changing use of opcodes to flag is the word exists in compiled form or not.  
257c			; This provides a means to compile uwords if required for higher performance 
257c			; by avoiding the use of the keyword parser and just jumping directly to the code 
257c			; Actually there is already a flag for if the code exists as binary thinking about it... 
257c			 
257c			 
257c			 
257c			 
257c			 
257c			; free to use code 0  
257c				OPCODE_HEAP: equ  1 
257c				OPCODE_EXEC: equ 2 
257c				OPCODE_DUP: equ 3 
257c				OPCODE_SWAP: equ 4 
257c				OPCODE_COLN: equ 5 
257c				OPCODE_SCOLN: equ 6 
257c				OPCODE_DROP: equ 7 
257c				OPCODE_DUP2: equ 8 
257c				OPCODE_DROP2: equ 9 
257c				OPCODE_SWAP2: equ 10 
257c				OPCODE_AT: equ 11 
257c				OPCODE_CAT: equ 12 
257c				OPCODE_BANG: equ 13 
257c				OPCODE_CBANG: equ 14 
257c				OPCODE_SCALL: equ 15 
257c				OPCODE_DEPTH: equ 16 
257c				OPCODE_OVER: equ 17 
257c				OPCODE_PAUSE: equ 18 
257c				OPCODE_PAUSES: equ 19 
257c				OPCODE_ROT: equ 20 
257c			;free to reuse	OPCODE_WORDS: equ 21 
257c			        OPCODE_NOT: equ 21 
257c				OPCODE_UWORDS: equ 22 
257c				OPCODE_BP: equ 23 
257c				OPCODE_MONITOR: equ 24  
257c				OPCODE_MALLOC: equ 25 
257c				OPCODE_FREE: equ 26 
257c				OPCODE_LIST: equ 27 
257c				OPCODE_FORGET: equ 28 
257c				OPCODE_NOP: equ 29 
257c				OPCODE_COMO: equ 30 
257c				OPCODE_COMC: equ 31 
257c			;free to reuse	OPCODE_ENDCORE: equ 32 
257c				OPCODE_AFTERSOUND: equ 33 
257c				OPCODE_GP2: equ 34 
257c				OPCODE_GP3: equ 35 
257c				OPCODE_GP4: equ 36 
257c				OPCODE_SIN: equ 37 
257c				OPCODE_SOUT: equ 38 
257c				OPCODE_SPIO: equ 39 
257c				OPCODE_SPICEH: equ 40 
257c				OPCODE_SPIOb: equ 41 
257c				OPCODE_SPII: equ 42 
257c				OPCODE_SESEL: equ 43 
257c				OPCODE_CARTDEV: equ 44 
257c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
257c				OPCODE_FB: equ 46 
257c				OPCODE_EMIT: equ 47 
257c				OPCODE_DOTH: equ 48 
257c				OPCODE_DOTF: equ 49 
257c				OPCODE_DOT: equ 50 
257c				OPCODE_CLS: equ 51 
257c				OPCODE_DRAW: equ 52 
257c				OPCODE_DUMP: equ 53 
257c				OPCODE_CDUMP: equ 54 
257c				OPCODE_DAT: equ 55 
257c				OPCODE_HOME: equ 56 
257c				OPCODE_SPACE: equ 57 
257c				OPCODE_SPACES: equ 58 
257c				OPCODE_SCROLL: equ 59 
257c				OPCODE_ATQ: equ 60 
257c				OPCODE_AUTODSP: equ 61 
257c				OPCODE_MENU: equ 62 
257c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
257c				OPCODE_THEN: equ 64 
257c				OPCODE_ELSE: equ 65 
257c				OPCODE_DO: equ 66 
257c				OPCODE_LOOP: equ 67 
257c				OPCODE_I: equ 68 
257c				OPCODE_DLOOP: equ 69  
257c				OPCODE_REPEAT: equ 70  
257c				OPCODE_UNTIL: equ 71 
257c				OPCODE_ENDFLOW: equ 72 
257c				OPCODE_WAITK: equ 73 
257c				OPCODE_ACCEPT: equ 74 
257c				OPCODE_EDIT: equ 75 
257c			;free to reuse	OPCODE_ENDKEY: equ 76 
257c				OPCODE_LZERO: equ 77 
257c				OPCODE_TZERO: equ 78 
257c				OPCODE_LESS: equ 79 
257c				OPCODE_GT: equ 80 
257c				OPCODE_EQUAL: equ 81  
257c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
257c				OPCODE_NEG: equ 83 
257c				OPCODE_DIV: equ 84 
257c				OPCODE_MUL: equ 85 
257c				OPCODE_MIN: equ 86 
257c				OPCODE_MAX: equ 87 
257c				OPCODE_RND16: equ 88 
257c				OPCODE_RND8: equ 89 
257c				OPCODE_RND: equ 90 
257c			;free to reuse	OPCODE_ENDMATHS: equ 91  
257c				OPCODE_BYNAME: equ 92 
257c				OPCODE_DIR: equ 93 
257c				OPCODE_SAVE: equ 94 
257c				OPCODE_LOAD: equ 95 
257c				OPCODE_BSAVE: equ 96 
257c				OPCODE_BLOAD: equ 97 
257c				OPCODE_SEO: equ 98  
257c				OPCODE_SEI: equ 99 
257c				OPCODE_SFREE: equ 100 
257c				OPCODE_SIZE: equ 101 
257c				OPCODE_CREATE: equ 102 
257c				OPCODE_APPEND: equ 103 
257c				OPCODE_SDEL: equ 104 
257c				OPCODE_OPEN: equ 105 
257c				OPCODE_READ: equ 106 
257c				OPCODE_EOF: equ 106 
257c				OPCODE_FORMAT: equ 107 
257c				OPCODE_LABEL: equ 108 
257c				OPCODE_LABELS: equ 109 
257c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
257c				OPCODE_UPPER: equ 111 
257c				OPCODE_LOWER: equ 112 
257c				OPCODE_SUBSTR: equ 113 
257c				OPCODE_LEFT: equ 114 
257c				OPCODE_RIGHT: equ 115 
257c				OPCODE_STR2NUM: equ 116 
257c				OPCODE_NUM2STR: equ 117 
257c				OPCODE_CONCAT: equ 118 
257c				OPCODE_FIND: equ 119 
257c				OPCODE_LEN: equ 120 
257c				OPCODE_CHAR: equ 121 
257c			; free to reuse	OPCODE_STRLEN: equ 122 
257c			; free to reuse	OPCODE_ENDSTR: equ 123 
257c				OPCODE_V0S: equ 124 
257c				OPCODE_V0Q: equ 125 
257c				OPCODE_V1S: equ 126 
257c				OPCODE_V1Q: equ 127 
257c				OPCODE_V2S: equ 128 
257c				OPCODE_V2Q: equ 129 
257c				OPCODE_V3S: equ 130 
257c				OPCODE_V3Q: equ 131 
257c			;free to reuse	OPCODE_END: equ 132 
257c				OPCODE_ZDUP: equ 133 
257c			 
257c			; eof 
# End of file forth_opcodes.asm
257c			 
257c			include "forth_words_core.asm" 
257c			 
257c			; | ## Core Words 
257c			 
257c			;if MALLOC_4 
257c			 
257c			.HEAP: 
257c			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
257c 15				db WORD_SYS_CORE+OPCODE_HEAP             
257d bb 25			dw .EXEC            
257f 05				db 4 + 1 
2580 .. 00			db "HEAP",0              
2585				endm 
# End of macro CWHEAD
2585			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2585			; | | u1 - Current number of bytes in the heap 
2585			; | | u2 - Remaining bytes left on the heap 
2585			; | |  
2585			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2585			 
2585			 
2585				if DEBUG_FORTH_WORDS_KEY 
2585					DMARK "HEP" 
2585 f5				push af  
2586 3a 9a 25			ld a, (.dmark)  
2589 32 a0 fd			ld (debug_mark),a  
258c 3a 9b 25			ld a, (.dmark+1)  
258f 32 a1 fd			ld (debug_mark+1),a  
2592 3a 9c 25			ld a, (.dmark+2)  
2595 32 a2 fd			ld (debug_mark+2),a  
2598 18 03			jr .pastdmark  
259a ..			.dmark: db "HEP"  
259d f1			.pastdmark: pop af  
259e			endm  
# End of macro DMARK
259e					CALLMONITOR 
259e cd aa fd			call debug_vector  
25a1				endm  
# End of macro CALLMONITOR
25a1				endif 
25a1 2a 0a 80			ld hl, (free_list )      
25a4 11 0e 80			ld de, heap_start 
25a7			 
25a7 ed 52			sbc hl, de  
25a9			 
25a9 cd 48 20			call forth_push_numhl 
25ac			 
25ac			 
25ac ed 5b 0a 80		ld de, (free_list )      
25b0 21 d1 f0			ld hl, heap_end 
25b3			 
25b3 ed 52			sbc hl, de 
25b5			 
25b5 cd 48 20			call forth_push_numhl 
25b8				 
25b8			 
25b8				 
25b8			 
25b8			 
25b8			 
25b8				NEXTW 
25b8 c3 38 24			jp macro_next 
25bb				endm 
# End of macro NEXTW
25bb			;endif 
25bb			 
25bb			.EXEC: 
25bb			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
25bb			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
25bb			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
25bb			;; > > 
25bb			;; > >   
25bb			;	STACKFRAME OFF $5efe $5f9f 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS_KEY 
25bb			;			DMARK "EXE" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			;	FORTH_DSP_VALUEHL 
25bb			; 
25bb			;	FORTH_DSP_POP 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX1" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;;	ld e,(hl) 
25bb			;;	inc hl 
25bb			;;	ld d,(hl) 
25bb			;;	ex de,hl 
25bb			; 
25bb			;;		if DEBUG_FORTH_WORDS 
25bb			;;			DMARK "EX2" 
25bb			;;			CALLMONITOR 
25bb			;;		endif 
25bb			;	push hl 
25bb			; 
25bb			;	;ld a, 0 
25bb			;	;ld a, FORTH_END_BUFFER 
25bb			;	call strlenz 
25bb			;	inc hl   ; include zero term to copy 
25bb			;	inc hl   ; include term 
25bb			;	inc hl   ; include term 
25bb			;	ld b,0 
25bb			;	ld c,l 
25bb			;	pop hl 
25bb			;	ld de, execscratch 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX3" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	ldir 
25bb			; 
25bb			; 
25bb			;	ld hl, execscratch 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EXe" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			;	call forthparse 
25bb			;	call forthexec 
25bb			;;	call forthexec_cleanup 
25bb			;;	call forthparse 
25bb			;;	call forthexec 
25bb			; 
25bb			;	STACKFRAMECHK OFF $5efe $5f9f 
25bb			; 
25bb			;	; an immediate word so no need to process any more words 
25bb			;	ret 
25bb			;	NEXTW 
25bb			 
25bb			; dead code - old version  
25bb			;	FORTH_RSP_NEXT 
25bb			 
25bb			;  
25bb			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
25bb			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
25bb			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
25bb			;	push hl 
25bb			;	push de 
25bb			;	push bc 
25bb			; 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS_KEY 
25bb			;			DMARK "EXR" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			; 
25bb			; 
25bb			;	;v5 FORTH_DSP_VALUE 
25bb			;	FORTH_DSP_VALUEHL 
25bb			; 
25bb			;	; TODO do string type checks 
25bb			; 
25bb			;;v5	inc hl   ; skip type 
25bb			; 
25bb			;	push hl  ; source code  
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX1" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	ld a, 0 
25bb			;	call strlent 
25bb			; 
25bb			;	inc hl 
25bb			;	inc hl 
25bb			;	inc hl 
25bb			;	inc hl 
25bb			; 
25bb			;	push hl    ; size 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX2" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	call malloc 
25bb			; 
25bb			;	ex de, hl    ; de now contains malloc area 
25bb			;	pop bc   	; get byte count 
25bb			;	pop hl      ; get string to copy 
25bb			; 
25bb			;	push de     ; save malloc for free later 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX3" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	ldir       ; duplicate string 
25bb			; 
25bb			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
25bb			;	 
25bb			;	; TODO fix the parse would be better than this...  
25bb			;	ex de, hl 
25bb			;	dec hl 
25bb			;	ld a, 0 
25bb			;	ld (hl), a 
25bb			;	dec hl 
25bb			;	ld a, ' ' 
25bb			;	ld (hl), a 
25bb			;	dec hl 
25bb			;	ld (hl), a 
25bb			; 
25bb			;	dec hl 
25bb			;	ld (hl), a 
25bb			; 
25bb			; 
25bb			;	FORTH_DSP_POP  
25bb			; 
25bb			;	pop hl     
25bb			;	push hl    ; save malloc area 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX4" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			;	call forthparse 
25bb			;	call forthexec 
25bb			;	 
25bb			;	pop hl 
25bb			;	if DEBUG_FORTH_WORDS 
25bb			;		DMARK "EX5" 
25bb			;		CALLMONITOR 
25bb			;	endif 
25bb			; 
25bb			;	if FORTH_ENABLE_FREE 
25bb			;	call free 
25bb			;	endif 
25bb			; 
25bb			;	if DEBUG_FORTH_WORDS 
25bb			;		DMARK "EX6" 
25bb			;		CALLMONITOR 
25bb			;	endif 
25bb			; 
25bb			;	pop bc 
25bb			;	pop de 
25bb			;	pop hl 
25bb			;;	FORTH_RSP_POP	  
25bb			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
25bb			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
25bb			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
25bb			; 
25bb			;	if DEBUG_FORTH_WORDS 
25bb			;		DMARK "EX7" 
25bb			;		CALLMONITOR 
25bb			;	endif 
25bb			;	NEXTW 
25bb			 
25bb			;.STKEXEC: 
25bb			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
25bb			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
25bb			; 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS_KEY 
25bb			;			DMARK "STX" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			;	FORTH_DSP_VALUEHL 
25bb			; 
25bb			;	ld (store_tmp1), hl    ; count 
25bb			; 
25bb			;	FORTH_DSP_POP 
25bb			;.stkexec1: 
25bb			;	ld hl, (store_tmp1)   ; count 
25bb			;	ld a, 0 
25bb			;	cp l 
25bb			;	ret z 
25bb			; 
25bb			;	dec hl 
25bb			;	ld (store_tmp1), hl    ; count 
25bb			;	 
25bb			;	FORTH_DSP_VALUEHL 
25bb			;	push hl 
25bb			;	 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EXp" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	FORTH_DSP_POP 
25bb			; 
25bb			;	call strlenz 
25bb			;	inc hl   ; include zero term to copy 
25bb			;	inc hl   ; include zero term to copy 
25bb			;	inc hl   ; include zero term to copy 
25bb			;	ld b,0 
25bb			;	ld c,l 
25bb			;	pop hl 
25bb			;	ld de, execscratch 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EX3" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	ldir 
25bb			; 
25bb			; 
25bb			;	ld hl, execscratch 
25bb			; 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EXP" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			; 
25bb			;	call forthparse 
25bb			;	ld hl, execscratch 
25bb			;		if DEBUG_FORTH_WORDS 
25bb			;			DMARK "EXx" 
25bb			;			CALLMONITOR 
25bb			;		endif 
25bb			;	call forthexec 
25bb			; 
25bb			;	jp .stkexec1 
25bb			; 
25bb			;	ret 
25bb			 
25bb			 
25bb			.DUP: 
25bb			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
25bb 17				db WORD_SYS_CORE+OPCODE_DUP             
25bc 31 26			dw .ZDUP            
25be 04				db 3 + 1 
25bf .. 00			db "DUP",0              
25c3				endm 
# End of macro CWHEAD
25c3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
25c3			 
25c3				if DEBUG_FORTH_WORDS_KEY 
25c3					DMARK "DUP" 
25c3 f5				push af  
25c4 3a d8 25			ld a, (.dmark)  
25c7 32 a0 fd			ld (debug_mark),a  
25ca 3a d9 25			ld a, (.dmark+1)  
25cd 32 a1 fd			ld (debug_mark+1),a  
25d0 3a da 25			ld a, (.dmark+2)  
25d3 32 a2 fd			ld (debug_mark+2),a  
25d6 18 03			jr .pastdmark  
25d8 ..			.dmark: db "DUP"  
25db f1			.pastdmark: pop af  
25dc			endm  
# End of macro DMARK
25dc					CALLMONITOR 
25dc cd aa fd			call debug_vector  
25df				endm  
# End of macro CALLMONITOR
25df				endif 
25df			 
25df				FORTH_DSP 
25df cd 13 22			call macro_forth_dsp 
25e2				endm 
# End of macro FORTH_DSP
25e2			 
25e2 7e				ld a, (HL) 
25e3 fe 01			cp DS_TYPE_STR 
25e5 20 25			jr nz, .dupinum 
25e7			 
25e7				; push another string 
25e7			 
25e7				FORTH_DSP_VALUEHL     		 
25e7 cd 4d 22			call macro_dsp_valuehl 
25ea				endm 
# End of macro FORTH_DSP_VALUEHL
25ea			 
25ea			if DEBUG_FORTH_WORDS 
25ea				DMARK "DUs" 
25ea f5				push af  
25eb 3a ff 25			ld a, (.dmark)  
25ee 32 a0 fd			ld (debug_mark),a  
25f1 3a 00 26			ld a, (.dmark+1)  
25f4 32 a1 fd			ld (debug_mark+1),a  
25f7 3a 01 26			ld a, (.dmark+2)  
25fa 32 a2 fd			ld (debug_mark+2),a  
25fd 18 03			jr .pastdmark  
25ff ..			.dmark: db "DUs"  
2602 f1			.pastdmark: pop af  
2603			endm  
# End of macro DMARK
2603				CALLMONITOR 
2603 cd aa fd			call debug_vector  
2606				endm  
# End of macro CALLMONITOR
2606			endif 
2606 cd b6 20			call forth_push_str 
2609			 
2609				NEXTW 
2609 c3 38 24			jp macro_next 
260c				endm 
# End of macro NEXTW
260c			 
260c			 
260c			.dupinum: 
260c				 
260c			 
260c			 
260c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
260c cd 4d 22			call macro_dsp_valuehl 
260f				endm 
# End of macro FORTH_DSP_VALUEHL
260f			 
260f			; TODO add floating point number detection 
260f			 
260f			if DEBUG_FORTH_WORDS 
260f				DMARK "DUi" 
260f f5				push af  
2610 3a 24 26			ld a, (.dmark)  
2613 32 a0 fd			ld (debug_mark),a  
2616 3a 25 26			ld a, (.dmark+1)  
2619 32 a1 fd			ld (debug_mark+1),a  
261c 3a 26 26			ld a, (.dmark+2)  
261f 32 a2 fd			ld (debug_mark+2),a  
2622 18 03			jr .pastdmark  
2624 ..			.dmark: db "DUi"  
2627 f1			.pastdmark: pop af  
2628			endm  
# End of macro DMARK
2628				CALLMONITOR 
2628 cd aa fd			call debug_vector  
262b				endm  
# End of macro CALLMONITOR
262b			endif 
262b			 
262b cd 48 20			call forth_push_numhl 
262e				NEXTW 
262e c3 38 24			jp macro_next 
2631				endm 
# End of macro NEXTW
2631			.ZDUP: 
2631			CWHEAD .LSHIFT OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2631 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2632 69 26			dw .LSHIFT            
2634 05				db 4 + 1 
2635 .. 00			db "?DUP",0              
263a				endm 
# End of macro CWHEAD
263a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
263a			 
263a				if DEBUG_FORTH_WORDS_KEY 
263a					DMARK "qDU" 
263a f5				push af  
263b 3a 4f 26			ld a, (.dmark)  
263e 32 a0 fd			ld (debug_mark),a  
2641 3a 50 26			ld a, (.dmark+1)  
2644 32 a1 fd			ld (debug_mark+1),a  
2647 3a 51 26			ld a, (.dmark+2)  
264a 32 a2 fd			ld (debug_mark+2),a  
264d 18 03			jr .pastdmark  
264f ..			.dmark: db "qDU"  
2652 f1			.pastdmark: pop af  
2653			endm  
# End of macro DMARK
2653					CALLMONITOR 
2653 cd aa fd			call debug_vector  
2656				endm  
# End of macro CALLMONITOR
2656				endif 
2656				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2656 cd 4d 22			call macro_dsp_valuehl 
2659				endm 
# End of macro FORTH_DSP_VALUEHL
2659			 
2659 e5				push hl 
265a			 
265a				; is it a zero? 
265a			 
265a 3e 00			ld a, 0 
265c 84				add h 
265d 85				add l 
265e			 
265e e1				pop hl 
265f			 
265f fe 00			cp 0 
2661 28 03			jr z, .dup2orig 
2663			 
2663			 
2663 cd 48 20			call forth_push_numhl 
2666			 
2666			 
2666			; TODO add floating point number detection 
2666			 
2666			.dup2orig: 
2666			 
2666				NEXTW 
2666 c3 38 24			jp macro_next 
2669				endm 
# End of macro NEXTW
2669			.LSHIFT: 
2669			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
2669 99				db WORD_SYS_CORE+OPCODE_ZDUP             
266a 9d 26			dw .RSHIFT            
266c 07				db 6 + 1 
266d .. 00			db "LSHIFT",0              
2674				endm 
# End of macro CWHEAD
2674			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
2674				if DEBUG_FORTH_WORDS_KEY 
2674					DMARK "LSH" 
2674 f5				push af  
2675 3a 89 26			ld a, (.dmark)  
2678 32 a0 fd			ld (debug_mark),a  
267b 3a 8a 26			ld a, (.dmark+1)  
267e 32 a1 fd			ld (debug_mark+1),a  
2681 3a 8b 26			ld a, (.dmark+2)  
2684 32 a2 fd			ld (debug_mark+2),a  
2687 18 03			jr .pastdmark  
2689 ..			.dmark: db "LSH"  
268c f1			.pastdmark: pop af  
268d			endm  
# End of macro DMARK
268d					CALLMONITOR 
268d cd aa fd			call debug_vector  
2690				endm  
# End of macro CALLMONITOR
2690				endif 
2690				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2690 cd 4d 22			call macro_dsp_valuehl 
2693				endm 
# End of macro FORTH_DSP_VALUEHL
2693				FORTH_DSP_POP 
2693 cd 05 23			call macro_forth_dsp_pop 
2696				endm 
# End of macro FORTH_DSP_POP
2696			 
2696 29				add hl, hl 
2697 cd 48 20			call forth_push_numhl 
269a				NEXTW 
269a c3 38 24			jp macro_next 
269d				endm 
# End of macro NEXTW
269d			.RSHIFT: 
269d			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
269d 99				db WORD_SYS_CORE+OPCODE_ZDUP             
269e d4 26			dw .SWAP            
26a0 07				db 6 + 1 
26a1 .. 00			db "RSHIFT",0              
26a8				endm 
# End of macro CWHEAD
26a8			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
26a8				if DEBUG_FORTH_WORDS_KEY 
26a8					DMARK "RSH" 
26a8 f5				push af  
26a9 3a bd 26			ld a, (.dmark)  
26ac 32 a0 fd			ld (debug_mark),a  
26af 3a be 26			ld a, (.dmark+1)  
26b2 32 a1 fd			ld (debug_mark+1),a  
26b5 3a bf 26			ld a, (.dmark+2)  
26b8 32 a2 fd			ld (debug_mark+2),a  
26bb 18 03			jr .pastdmark  
26bd ..			.dmark: db "RSH"  
26c0 f1			.pastdmark: pop af  
26c1			endm  
# End of macro DMARK
26c1					CALLMONITOR 
26c1 cd aa fd			call debug_vector  
26c4				endm  
# End of macro CALLMONITOR
26c4				endif 
26c4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c4 cd 4d 22			call macro_dsp_valuehl 
26c7				endm 
# End of macro FORTH_DSP_VALUEHL
26c7				FORTH_DSP_POP 
26c7 cd 05 23			call macro_forth_dsp_pop 
26ca				endm 
# End of macro FORTH_DSP_POP
26ca cb 3c			srl h 
26cc cb 1d			rr l 
26ce cd 48 20			call forth_push_numhl 
26d1				NEXTW 
26d1 c3 38 24			jp macro_next 
26d4				endm 
# End of macro NEXTW
26d4			.SWAP: 
26d4			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26d4 18				db WORD_SYS_CORE+OPCODE_SWAP             
26d5 28 27			dw .COLN            
26d7 05				db 4 + 1 
26d8 .. 00			db "SWAP",0              
26dd				endm 
# End of macro CWHEAD
26dd			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
26dd				if DEBUG_FORTH_WORDS_KEY 
26dd					DMARK "SWP" 
26dd f5				push af  
26de 3a f2 26			ld a, (.dmark)  
26e1 32 a0 fd			ld (debug_mark),a  
26e4 3a f3 26			ld a, (.dmark+1)  
26e7 32 a1 fd			ld (debug_mark+1),a  
26ea 3a f4 26			ld a, (.dmark+2)  
26ed 32 a2 fd			ld (debug_mark+2),a  
26f0 18 03			jr .pastdmark  
26f2 ..			.dmark: db "SWP"  
26f5 f1			.pastdmark: pop af  
26f6			endm  
# End of macro DMARK
26f6					CALLMONITOR 
26f6 cd aa fd			call debug_vector  
26f9				endm  
# End of macro CALLMONITOR
26f9				endif 
26f9			 
26f9			; DONE Use os stack swap memory 
26f9			 
26f9				FORTH_DSP_PTR 0     ; TOS 
26f9 2a 23 f9			ld hl,(cli_data_sp) 
26fc 11 00 00			ld de, 0 * 3 
26ff ed 52			sbc hl, de 
2701				endm 
# End of macro FORTH_DSP_PTR
2701 cd 84 23			call hltostack1 
2704			  
2704				FORTH_DSP_PTR 1     ; TOS 
2704 2a 23 f9			ld hl,(cli_data_sp) 
2707 11 03 00			ld de, 1 * 3 
270a ed 52			sbc hl, de 
270c				endm 
# End of macro FORTH_DSP_PTR
270c cd 8a 23			call hltostack2 
270f			 
270f				FORTH_DSP_PTR 0     ; TOS 
270f 2a 23 f9			ld hl,(cli_data_sp) 
2712 11 00 00			ld de, 0 * 3 
2715 ed 52			sbc hl, de 
2717				endm 
# End of macro FORTH_DSP_PTR
2717 cd a2 23			call hlfromstack2 
271a			 
271a				FORTH_DSP_PTR 1     ; TOS 
271a 2a 23 f9			ld hl,(cli_data_sp) 
271d 11 03 00			ld de, 1 * 3 
2720 ed 52			sbc hl, de 
2722				endm 
# End of macro FORTH_DSP_PTR
2722 cd 9c 23			call hlfromstack1 
2725			;	FORTH_DSP_VALUEHL 
2725			;	push hl     ; w2 
2725			; 
2725			;	FORTH_DSP_POP 
2725			; 
2725			;	FORTH_DSP_VALUEHL 
2725			; 
2725			;	FORTH_DSP_POP 
2725			; 
2725			;	pop de     ; w2	, hl = w1 
2725			; 
2725			;	ex de, hl 
2725			;	push de 
2725			; 
2725			;	call forth_push_numhl 
2725			; 
2725			;	pop hl 
2725			; 
2725			;	call forth_push_numhl 
2725				 
2725			 
2725				NEXTW 
2725 c3 38 24			jp macro_next 
2728				endm 
# End of macro NEXTW
2728			.COLN: 
2728			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2728 19				db WORD_SYS_CORE+OPCODE_COLN             
2729 b4 28			dw .SCOLN            
272b 02				db 1 + 1 
272c .. 00			db ":",0              
272e				endm 
# End of macro CWHEAD
272e			; | : ( -- )         Create new word | DONE 
272e			 
272e				if DEBUG_FORTH_WORDS_KEY 
272e					DMARK "CLN" 
272e f5				push af  
272f 3a 43 27			ld a, (.dmark)  
2732 32 a0 fd			ld (debug_mark),a  
2735 3a 44 27			ld a, (.dmark+1)  
2738 32 a1 fd			ld (debug_mark+1),a  
273b 3a 45 27			ld a, (.dmark+2)  
273e 32 a2 fd			ld (debug_mark+2),a  
2741 18 03			jr .pastdmark  
2743 ..			.dmark: db "CLN"  
2746 f1			.pastdmark: pop af  
2747			endm  
# End of macro DMARK
2747					CALLMONITOR 
2747 cd aa fd			call debug_vector  
274a				endm  
# End of macro CALLMONITOR
274a				endif 
274a			STACKFRAME OFF $8efe $989f 
274a				if DEBUG_STACK_IMB 
274a					if OFF 
274a						exx 
274a						ld de, $8efe 
274a						ld a, d 
274a						ld hl, curframe 
274a						call hexout 
274a						ld a, e 
274a						ld hl, curframe+2 
274a						call hexout 
274a						ld hl, $8efe 
274a						push hl 
274a						ld hl, $989f 
274a						push hl 
274a						exx 
274a					endif 
274a				endif 
274a			endm 
# End of macro STACKFRAME
274a			; get parser buffer length  of new word 
274a			 
274a			 
274a			 
274a				; move tok past this to start of name defintition 
274a				; TODO get word to define 
274a				; TODO Move past word token 
274a				; TODO get length of string up to the ';' 
274a			 
274a 2a f7 f3		ld hl, (os_tok_ptr) 
274d 23			inc hl 
274e 23			inc hl 
274f			 
274f 3e 3b		ld a, ';' 
2751 cd 4f 13		call strlent 
2754			 
2754 7d			ld a,l 
2755 32 e6 f0		ld (os_new_parse_len), a 
2758			 
2758			 
2758			if DEBUG_FORTH_UWORD 
2758 ed 5b f7 f3	ld de, (os_tok_ptr) 
275c					DMARK ":01" 
275c f5				push af  
275d 3a 71 27			ld a, (.dmark)  
2760 32 a0 fd			ld (debug_mark),a  
2763 3a 72 27			ld a, (.dmark+1)  
2766 32 a1 fd			ld (debug_mark+1),a  
2769 3a 73 27			ld a, (.dmark+2)  
276c 32 a2 fd			ld (debug_mark+2),a  
276f 18 03			jr .pastdmark  
2771 ..			.dmark: db ":01"  
2774 f1			.pastdmark: pop af  
2775			endm  
# End of macro DMARK
2775			CALLMONITOR 
2775 cd aa fd			call debug_vector  
2778				endm  
# End of macro CALLMONITOR
2778			endif 
2778			 
2778			; 
2778			;  new word memory layout: 
2778			;  
2778			;    : adg 6666 ;  
2778			; 
2778			;    db   1     ; user defined word  
2778 23			inc hl    
2779			;    dw   sysdict 
2779 23			inc hl 
277a 23			inc hl 
277b			;    db <word len>+1 (for null) 
277b 23			inc hl 
277c			;    db .... <word> 
277c			; 
277c			 
277c 23			inc hl    ; some extras for the word preamble before the above 
277d 23			inc hl 
277e 23			inc hl 
277f 23			inc hl 
2780 23			inc hl 
2781 23			inc hl 
2782 23			inc hl  
2783 23			inc hl 
2784 23			inc hl 
2785 23			inc hl 
2786 23			inc hl 
2787 23			inc hl 
2788 23			inc hl 
2789 23			inc hl     ; TODO how many do we really need?     maybe only 6 
278a			;       exec word buffer 
278a			;	<ptr word>   
278a 23			inc hl 
278b 23			inc hl 
278c			;       <word list><null term> 7F final term 
278c			 
278c			 
278c			if DEBUG_FORTH_UWORD 
278c					DMARK ":02" 
278c f5				push af  
278d 3a a1 27			ld a, (.dmark)  
2790 32 a0 fd			ld (debug_mark),a  
2793 3a a2 27			ld a, (.dmark+1)  
2796 32 a1 fd			ld (debug_mark+1),a  
2799 3a a3 27			ld a, (.dmark+2)  
279c 32 a2 fd			ld (debug_mark+2),a  
279f 18 03			jr .pastdmark  
27a1 ..			.dmark: db ":02"  
27a4 f1			.pastdmark: pop af  
27a5			endm  
# End of macro DMARK
27a5			CALLMONITOR 
27a5 cd aa fd			call debug_vector  
27a8				endm  
# End of macro CALLMONITOR
27a8			endif 
27a8			 
27a8			 
27a8				; malloc the size 
27a8			 
27a8 cd b9 13			call malloc 
27ab 22 e8 f0			ld (os_new_malloc), hl     ; save malloc start 
27ae			 
27ae			;    db   1     ; user defined word  
27ae 3e 01			ld a, WORD_SYS_UWORD  
27b0 77				ld (hl), a 
27b1			 
27b1 23			inc hl    
27b2			;    dw   sysdict 
27b2 11 7c 25		ld de, sysdict       ; continue on with the scan to the system dict 
27b5 73			ld (hl), e 
27b6 23			inc hl 
27b7 72			ld (hl), d 
27b8 23			inc hl 
27b9			 
27b9			 
27b9			;    Setup dict word 
27b9			 
27b9 23			inc hl 
27ba 22 e2 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
27bd			 
27bd			; 1. get length of dict word 
27bd			 
27bd			 
27bd 2a f7 f3		ld hl, (os_tok_ptr) 
27c0 23			inc hl 
27c1 23			inc hl    ; position to start of dict word 
27c2 3e 00		ld a, 0 
27c4 cd 4f 13		call strlent 
27c7			 
27c7			 
27c7 23			inc hl    ; to include null??? 
27c8			 
27c8			; write length of dict word 
27c8			 
27c8 ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27cc 1b			dec de 
27cd eb			ex de, hl 
27ce 73			ld (hl), e 
27cf eb			ex de, hl 
27d0			 
27d0			 
27d0			 
27d0			; copy  
27d0 4d			ld c, l 
27d1 06 00		ld b, 0 
27d3 ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27d7 2a f7 f3		ld hl, (os_tok_ptr) 
27da 23			inc hl 
27db 23			inc hl    ; position to start of dict word 
27dc			 
27dc			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27dc			 
27dc			; TODO need to convert word to upper case 
27dc			 
27dc			ucasetok:	 
27dc 7e			ld a,(hl) 
27dd cd 3b 13		call toUpper 
27e0 77			ld (hl),a 
27e1 ed a0		ldi 
27e3 f2 dc 27		jp p, ucasetok 
27e6			 
27e6			 
27e6			 
27e6			; de now points to start of where the word body code should be placed 
27e6 ed 53 e2 f0	ld (os_new_work_ptr), de 
27ea			; hl now points to the words to throw at forthexec which needs to be copied 
27ea 22 e0 f0		ld (os_new_src_ptr), hl 
27ed			 
27ed			; TODO add 'call to forthexec' 
27ed			 
27ed			if DEBUG_FORTH_UWORD 
27ed c5			push bc 
27ee ed 4b e8 f0	ld bc, (os_new_malloc) 
27f2					DMARK ":0x" 
27f2 f5				push af  
27f3 3a 07 28			ld a, (.dmark)  
27f6 32 a0 fd			ld (debug_mark),a  
27f9 3a 08 28			ld a, (.dmark+1)  
27fc 32 a1 fd			ld (debug_mark+1),a  
27ff 3a 09 28			ld a, (.dmark+2)  
2802 32 a2 fd			ld (debug_mark+2),a  
2805 18 03			jr .pastdmark  
2807 ..			.dmark: db ":0x"  
280a f1			.pastdmark: pop af  
280b			endm  
# End of macro DMARK
280b			CALLMONITOR 
280b cd aa fd			call debug_vector  
280e				endm  
# End of macro CALLMONITOR
280e c1			pop bc 
280f			endif 
280f			 
280f			 
280f			; create word preamble which should be: 
280f			 
280f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
280f			 
280f			;    ld hl, <word code> 
280f			;    jp user_exec 
280f			;    <word code bytes> 
280f			 
280f			 
280f			;	inc de     ; TODO ??? or are we already past the word's null 
280f eb			ex de, hl 
2810			 
2810 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2812			 
2812 23			inc hl 
2813 22 dc f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2816 23			inc hl 
2817			 
2817 23			inc hl 
2818 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
281a			 
281a 01 68 60		ld bc, user_exec 
281d 23			inc hl 
281e 71			ld (hl), c     ; poke address of user_exec 
281f 23			inc hl 
2820 70			ld (hl), b     
2821			; 
2821			;	inc hl 
2821			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2821			; 
2821			; 
2821			;	ld bc, macro_forth_rsp_next 
2821			;	inc hl 
2821			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2821			;	inc hl 
2821			;	ld (hl), b     
2821			; 
2821			;	inc hl 
2821			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2821			; 
2821			; 
2821			;	inc hl 
2821			;	ld bc, forthexec 
2821			;	ld (hl), c     ; poke address of forthexec 
2821			;	inc hl 
2821			;	ld (hl), b      
2821			; 
2821			;	inc hl 
2821			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2821			; 
2821			;	ld bc, user_dict_next 
2821			;	inc hl 
2821			;	ld (hl), c     ; poke address of forthexec 
2821			;	inc hl 
2821			;	ld (hl), b      
2821			 
2821			; hl is now where we need to copy the word byte data to save this 
2821			 
2821 23			inc hl 
2822 22 de f0		ld (os_new_exec), hl 
2825			 
2825			; copy definition 
2825			 
2825 eb			ex de, hl 
2826			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2826			;	inc de    ; skip the PC for this parse 
2826 3a e6 f0		ld a, (os_new_parse_len) 
2829 4f			ld c, a 
282a 06 00		ld b, 0 
282c ed b0		ldir		 ; copy defintion 
282e			 
282e			 
282e			; poke the address of where the new word bytes live for forthexec 
282e			 
282e 2a dc f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2831			 
2831 ed 5b de f0	ld de, (os_new_exec)      
2835			 
2835 73			ld (hl), e 
2836 23			inc hl 
2837 72			ld (hl), d 
2838			 
2838				; TODO copy last user dict word next link to this word 
2838				; TODO update last user dict word to point to this word 
2838			; 
2838			; hl f923 de 812a ; bc 811a 
2838			 
2838			if DEBUG_FORTH_UWORD 
2838 c5			push bc 
2839 ed 4b e8 f0	ld bc, (os_new_malloc) 
283d					DMARK ":0A" 
283d f5				push af  
283e 3a 52 28			ld a, (.dmark)  
2841 32 a0 fd			ld (debug_mark),a  
2844 3a 53 28			ld a, (.dmark+1)  
2847 32 a1 fd			ld (debug_mark+1),a  
284a 3a 54 28			ld a, (.dmark+2)  
284d 32 a2 fd			ld (debug_mark+2),a  
2850 18 03			jr .pastdmark  
2852 ..			.dmark: db ":0A"  
2855 f1			.pastdmark: pop af  
2856			endm  
# End of macro DMARK
2856			CALLMONITOR 
2856 cd aa fd			call debug_vector  
2859				endm  
# End of macro CALLMONITOR
2859 c1			pop bc 
285a			endif 
285a			if DEBUG_FORTH_UWORD 
285a c5			push bc 
285b ed 4b e8 f0	ld bc, (os_new_malloc) 
285f 03			inc bc 
2860 03			inc bc 
2861 03			inc bc 
2862 03			inc bc 
2863 03			inc bc 
2864 03			inc bc 
2865 03			inc bc 
2866 03			inc bc 
2867			 
2867					DMARK ":0B" 
2867 f5				push af  
2868 3a 7c 28			ld a, (.dmark)  
286b 32 a0 fd			ld (debug_mark),a  
286e 3a 7d 28			ld a, (.dmark+1)  
2871 32 a1 fd			ld (debug_mark+1),a  
2874 3a 7e 28			ld a, (.dmark+2)  
2877 32 a2 fd			ld (debug_mark+2),a  
287a 18 03			jr .pastdmark  
287c ..			.dmark: db ":0B"  
287f f1			.pastdmark: pop af  
2880			endm  
# End of macro DMARK
2880			CALLMONITOR 
2880 cd aa fd			call debug_vector  
2883				endm  
# End of macro CALLMONITOR
2883 c1			pop bc 
2884			endif 
2884			 
2884			; update word dict linked list for new word 
2884			 
2884			 
2884 2a f3 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2887 23			inc hl     ; move to next work linked list ptr 
2888			 
2888 ed 5b e8 f0	ld de, (os_new_malloc)		 ; new next word 
288c 73			ld (hl), e 
288d 23			inc hl 
288e 72			ld (hl), d 
288f			 
288f			if DEBUG_FORTH_UWORD 
288f ed 4b f3 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2893			endif 
2893			 
2893 ed 53 f3 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
2897			 
2897			 
2897			if DEBUG_FORTH_UWORD 
2897					DMARK ":0+" 
2897 f5				push af  
2898 3a ac 28			ld a, (.dmark)  
289b 32 a0 fd			ld (debug_mark),a  
289e 3a ad 28			ld a, (.dmark+1)  
28a1 32 a1 fd			ld (debug_mark+1),a  
28a4 3a ae 28			ld a, (.dmark+2)  
28a7 32 a2 fd			ld (debug_mark+2),a  
28aa 18 03			jr .pastdmark  
28ac ..			.dmark: db ":0+"  
28af f1			.pastdmark: pop af  
28b0			endm  
# End of macro DMARK
28b0			CALLMONITOR 
28b0 cd aa fd			call debug_vector  
28b3				endm  
# End of macro CALLMONITOR
28b3			endif 
28b3			 
28b3			STACKFRAMECHK OFF $8efe $989f 
28b3				if DEBUG_STACK_IMB 
28b3					if OFF 
28b3						exx 
28b3						ld hl, $989f 
28b3						pop de   ; $989f 
28b3						call cmp16 
28b3						jr nz, .spnosame 
28b3						ld hl, $8efe 
28b3						pop de   ; $8efe 
28b3						call cmp16 
28b3						jr z, .spfrsame 
28b3						.spnosame: call showsperror 
28b3						.spfrsame: nop 
28b3						exx 
28b3					endif 
28b3				endif 
28b3			endm 
# End of macro STACKFRAMECHK
28b3			 
28b3 c9			ret    ; dont process any remaining parser tokens as they form new word 
28b4			 
28b4			 
28b4			 
28b4			 
28b4			;		NEXT 
28b4			.SCOLN: 
28b4			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28b4 06			db OPCODE_SCOLN 
28b5 00 29		dw .DROP 
28b7 02			db 2 
28b8 .. 00		db ";",0           
28ba			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28ba				if DEBUG_FORTH_WORDS_KEY 
28ba					DMARK "SCN" 
28ba f5				push af  
28bb 3a cf 28			ld a, (.dmark)  
28be 32 a0 fd			ld (debug_mark),a  
28c1 3a d0 28			ld a, (.dmark+1)  
28c4 32 a1 fd			ld (debug_mark+1),a  
28c7 3a d1 28			ld a, (.dmark+2)  
28ca 32 a2 fd			ld (debug_mark+2),a  
28cd 18 03			jr .pastdmark  
28cf ..			.dmark: db "SCN"  
28d2 f1			.pastdmark: pop af  
28d3			endm  
# End of macro DMARK
28d3					CALLMONITOR 
28d3 cd aa fd			call debug_vector  
28d6				endm  
# End of macro CALLMONITOR
28d6				endif 
28d6				FORTH_RSP_TOS 
28d6 cd 06 20			call macro_forth_rsp_tos 
28d9				endm 
# End of macro FORTH_RSP_TOS
28d9 e5				push hl 
28da				FORTH_RSP_POP 
28da cd 10 20			call macro_forth_rsp_pop 
28dd				endm 
# End of macro FORTH_RSP_POP
28dd e1				pop hl 
28de			;		ex de,hl 
28de 22 f7 f3			ld (os_tok_ptr),hl 
28e1			 
28e1			if DEBUG_FORTH_UWORD 
28e1					DMARK "SCL" 
28e1 f5				push af  
28e2 3a f6 28			ld a, (.dmark)  
28e5 32 a0 fd			ld (debug_mark),a  
28e8 3a f7 28			ld a, (.dmark+1)  
28eb 32 a1 fd			ld (debug_mark+1),a  
28ee 3a f8 28			ld a, (.dmark+2)  
28f1 32 a2 fd			ld (debug_mark+2),a  
28f4 18 03			jr .pastdmark  
28f6 ..			.dmark: db "SCL"  
28f9 f1			.pastdmark: pop af  
28fa			endm  
# End of macro DMARK
28fa			CALLMONITOR 
28fa cd aa fd			call debug_vector  
28fd				endm  
# End of macro CALLMONITOR
28fd			endif 
28fd				NEXTW 
28fd c3 38 24			jp macro_next 
2900				endm 
# End of macro NEXTW
2900			 
2900			.DROP: 
2900			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2900 1b				db WORD_SYS_CORE+OPCODE_DROP             
2901 2b 29			dw .DUP2            
2903 05				db 4 + 1 
2904 .. 00			db "DROP",0              
2909				endm 
# End of macro CWHEAD
2909			; | DROP ( w -- )   drop the TOS item   | DONE 
2909				if DEBUG_FORTH_WORDS_KEY 
2909					DMARK "DRP" 
2909 f5				push af  
290a 3a 1e 29			ld a, (.dmark)  
290d 32 a0 fd			ld (debug_mark),a  
2910 3a 1f 29			ld a, (.dmark+1)  
2913 32 a1 fd			ld (debug_mark+1),a  
2916 3a 20 29			ld a, (.dmark+2)  
2919 32 a2 fd			ld (debug_mark+2),a  
291c 18 03			jr .pastdmark  
291e ..			.dmark: db "DRP"  
2921 f1			.pastdmark: pop af  
2922			endm  
# End of macro DMARK
2922					CALLMONITOR 
2922 cd aa fd			call debug_vector  
2925				endm  
# End of macro CALLMONITOR
2925				endif 
2925				FORTH_DSP_POP 
2925 cd 05 23			call macro_forth_dsp_pop 
2928				endm 
# End of macro FORTH_DSP_POP
2928				NEXTW 
2928 c3 38 24			jp macro_next 
292b				endm 
# End of macro NEXTW
292b			.DUP2: 
292b			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
292b 1c				db WORD_SYS_CORE+OPCODE_DUP2             
292c 70 29			dw .DROP2            
292e 05				db 4 + 1 
292f .. 00			db "2DUP",0              
2934				endm 
# End of macro CWHEAD
2934			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
2934				if DEBUG_FORTH_WORDS_KEY 
2934					DMARK "2DU" 
2934 f5				push af  
2935 3a 49 29			ld a, (.dmark)  
2938 32 a0 fd			ld (debug_mark),a  
293b 3a 4a 29			ld a, (.dmark+1)  
293e 32 a1 fd			ld (debug_mark+1),a  
2941 3a 4b 29			ld a, (.dmark+2)  
2944 32 a2 fd			ld (debug_mark+2),a  
2947 18 03			jr .pastdmark  
2949 ..			.dmark: db "2DU"  
294c f1			.pastdmark: pop af  
294d			endm  
# End of macro DMARK
294d					CALLMONITOR 
294d cd aa fd			call debug_vector  
2950				endm  
# End of macro CALLMONITOR
2950				endif 
2950				FORTH_DSP_VALUEHL 
2950 cd 4d 22			call macro_dsp_valuehl 
2953				endm 
# End of macro FORTH_DSP_VALUEHL
2953 e5				push hl      ; 2 
2954			 
2954				FORTH_DSP_POP 
2954 cd 05 23			call macro_forth_dsp_pop 
2957				endm 
# End of macro FORTH_DSP_POP
2957				 
2957				FORTH_DSP_VALUEHL 
2957 cd 4d 22			call macro_dsp_valuehl 
295a				endm 
# End of macro FORTH_DSP_VALUEHL
295a			;		push hl      ; 1 
295a			 
295a				FORTH_DSP_POP 
295a cd 05 23			call macro_forth_dsp_pop 
295d				endm 
# End of macro FORTH_DSP_POP
295d			 
295d			;		pop hl       ; 1 
295d d1				pop de       ; 2 
295e			 
295e cd 48 20			call forth_push_numhl 
2961 eb				ex de, hl 
2962 cd 48 20			call forth_push_numhl 
2965			 
2965				 
2965 eb				ex de, hl 
2966			 
2966 cd 48 20			call forth_push_numhl 
2969 eb				ex de, hl 
296a cd 48 20			call forth_push_numhl 
296d			 
296d			 
296d				NEXTW 
296d c3 38 24			jp macro_next 
2970				endm 
# End of macro NEXTW
2970			.DROP2: 
2970			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2970 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2971 9f 29			dw .PICK            
2973 06				db 5 + 1 
2974 .. 00			db "2DROP",0              
297a				endm 
# End of macro CWHEAD
297a			; | 2DROP ( w w -- )    Double drop | DONE 
297a				if DEBUG_FORTH_WORDS_KEY 
297a					DMARK "2DR" 
297a f5				push af  
297b 3a 8f 29			ld a, (.dmark)  
297e 32 a0 fd			ld (debug_mark),a  
2981 3a 90 29			ld a, (.dmark+1)  
2984 32 a1 fd			ld (debug_mark+1),a  
2987 3a 91 29			ld a, (.dmark+2)  
298a 32 a2 fd			ld (debug_mark+2),a  
298d 18 03			jr .pastdmark  
298f ..			.dmark: db "2DR"  
2992 f1			.pastdmark: pop af  
2993			endm  
# End of macro DMARK
2993					CALLMONITOR 
2993 cd aa fd			call debug_vector  
2996				endm  
# End of macro CALLMONITOR
2996				endif 
2996				FORTH_DSP_POP 
2996 cd 05 23			call macro_forth_dsp_pop 
2999				endm 
# End of macro FORTH_DSP_POP
2999				FORTH_DSP_POP 
2999 cd 05 23			call macro_forth_dsp_pop 
299c				endm 
# End of macro FORTH_DSP_POP
299c				NEXTW 
299c c3 38 24			jp macro_next 
299f				endm 
# End of macro NEXTW
299f			.PICK: 
299f			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
299f 77				db WORD_SYS_CORE+99             
29a0 39 2a			dw .SWAP2            
29a2 05				db 4 + 1 
29a3 .. 00			db "PICK",0              
29a8				endm 
# End of macro CWHEAD
29a8			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | TODO 
29a8				if DEBUG_FORTH_WORDS_KEY 
29a8					DMARK "PIK" 
29a8 f5				push af  
29a9 3a bd 29			ld a, (.dmark)  
29ac 32 a0 fd			ld (debug_mark),a  
29af 3a be 29			ld a, (.dmark+1)  
29b2 32 a1 fd			ld (debug_mark+1),a  
29b5 3a bf 29			ld a, (.dmark+2)  
29b8 32 a2 fd			ld (debug_mark+2),a  
29bb 18 03			jr .pastdmark  
29bd ..			.dmark: db "PIK"  
29c0 f1			.pastdmark: pop af  
29c1			endm  
# End of macro DMARK
29c1					CALLMONITOR 
29c1 cd aa fd			call debug_vector  
29c4				endm  
# End of macro CALLMONITOR
29c4				endif 
29c4			 
29c4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29c4 cd 4d 22			call macro_dsp_valuehl 
29c7				endm 
# End of macro FORTH_DSP_VALUEHL
29c7				 
29c7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c7 cd 05 23			call macro_forth_dsp_pop 
29ca				endm 
# End of macro FORTH_DSP_POP
29ca			 
29ca				; init from TOS 
29ca e5				push hl 
29cb				FORTH_DSP 
29cb cd 13 22			call macro_forth_dsp 
29ce				endm 
# End of macro FORTH_DSP
29ce			;	ld hl, cli_data_sp 
29ce				if DEBUG_FORTH_WORDS 
29ce					DMARK "PK1" 
29ce f5				push af  
29cf 3a e3 29			ld a, (.dmark)  
29d2 32 a0 fd			ld (debug_mark),a  
29d5 3a e4 29			ld a, (.dmark+1)  
29d8 32 a1 fd			ld (debug_mark+1),a  
29db 3a e5 29			ld a, (.dmark+2)  
29de 32 a2 fd			ld (debug_mark+2),a  
29e1 18 03			jr .pastdmark  
29e3 ..			.dmark: db "PK1"  
29e6 f1			.pastdmark: pop af  
29e7			endm  
# End of macro DMARK
29e7					CALLMONITOR 
29e7 cd aa fd			call debug_vector  
29ea				endm  
# End of macro CALLMONITOR
29ea				endif 
29ea c1				pop bc 
29eb 41				ld b,c 
29ec 3e 00			ld a, 0 
29ee b8				cp b 
29ef 28 21			jr z, .pdone	 
29f1			.pkl: 
29f1 2b				dec hl 
29f2 2b				dec hl 
29f3 2b				dec hl 
29f4			 
29f4				if DEBUG_FORTH_WORDS 
29f4					DMARK "PKl" 
29f4 f5				push af  
29f5 3a 09 2a			ld a, (.dmark)  
29f8 32 a0 fd			ld (debug_mark),a  
29fb 3a 0a 2a			ld a, (.dmark+1)  
29fe 32 a1 fd			ld (debug_mark+1),a  
2a01 3a 0b 2a			ld a, (.dmark+2)  
2a04 32 a2 fd			ld (debug_mark+2),a  
2a07 18 03			jr .pastdmark  
2a09 ..			.dmark: db "PKl"  
2a0c f1			.pastdmark: pop af  
2a0d			endm  
# End of macro DMARK
2a0d					CALLMONITOR 
2a0d cd aa fd			call debug_vector  
2a10				endm  
# End of macro CALLMONITOR
2a10				endif 
2a10 10 df			djnz .pkl 
2a12			.pdone: 
2a12				 
2a12				; TODO do type check with correct push 
2a12			 
2a12 23				inc hl 
2a13				;call loadwordinhl 
2a13 5e				ld e, (hl) 
2a14 23				inc hl 
2a15 56				ld d, (hl) 
2a16 eb				ex de,hl 
2a17				if DEBUG_FORTH_WORDS 
2a17					DMARK "PKp" 
2a17 f5				push af  
2a18 3a 2c 2a			ld a, (.dmark)  
2a1b 32 a0 fd			ld (debug_mark),a  
2a1e 3a 2d 2a			ld a, (.dmark+1)  
2a21 32 a1 fd			ld (debug_mark+1),a  
2a24 3a 2e 2a			ld a, (.dmark+2)  
2a27 32 a2 fd			ld (debug_mark+2),a  
2a2a 18 03			jr .pastdmark  
2a2c ..			.dmark: db "PKp"  
2a2f f1			.pastdmark: pop af  
2a30			endm  
# End of macro DMARK
2a30					CALLMONITOR 
2a30 cd aa fd			call debug_vector  
2a33				endm  
# End of macro CALLMONITOR
2a33				endif 
2a33 cd 48 20			call forth_push_numhl 
2a36			 
2a36				NEXTW 
2a36 c3 38 24			jp macro_next 
2a39				endm 
# End of macro NEXTW
2a39			.SWAP2: 
2a39			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2a39 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2a3a ba 2a			dw .AT            
2a3c 06				db 5 + 1 
2a3d .. 00			db "2SWAP",0              
2a43				endm 
# End of macro CWHEAD
2a43			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2a43				if DEBUG_FORTH_WORDS_KEY 
2a43					DMARK "2SW" 
2a43 f5				push af  
2a44 3a 58 2a			ld a, (.dmark)  
2a47 32 a0 fd			ld (debug_mark),a  
2a4a 3a 59 2a			ld a, (.dmark+1)  
2a4d 32 a1 fd			ld (debug_mark+1),a  
2a50 3a 5a 2a			ld a, (.dmark+2)  
2a53 32 a2 fd			ld (debug_mark+2),a  
2a56 18 03			jr .pastdmark  
2a58 ..			.dmark: db "2SW"  
2a5b f1			.pastdmark: pop af  
2a5c			endm  
# End of macro DMARK
2a5c					CALLMONITOR 
2a5c cd aa fd			call debug_vector  
2a5f				endm  
# End of macro CALLMONITOR
2a5f				endif 
2a5f			; TODO Use os stack swap memory 
2a5f			 
2a5f				FORTH_DSP_PTR 0     ; TOS    w4 
2a5f 2a 23 f9			ld hl,(cli_data_sp) 
2a62 11 00 00			ld de, 0 * 3 
2a65 ed 52			sbc hl, de 
2a67				endm 
# End of macro FORTH_DSP_PTR
2a67 cd 84 23			call hltostack1 
2a6a			  
2a6a				FORTH_DSP_PTR 1     ; TOS    w3 
2a6a 2a 23 f9			ld hl,(cli_data_sp) 
2a6d 11 03 00			ld de, 1 * 3 
2a70 ed 52			sbc hl, de 
2a72				endm 
# End of macro FORTH_DSP_PTR
2a72 cd 8a 23			call hltostack2 
2a75			 
2a75			 
2a75			 
2a75				FORTH_DSP_PTR 2     ; TOS    w2 
2a75 2a 23 f9			ld hl,(cli_data_sp) 
2a78 11 06 00			ld de, 2 * 3 
2a7b ed 52			sbc hl, de 
2a7d				endm 
# End of macro FORTH_DSP_PTR
2a7d cd 90 23			call hltostack3 
2a80			 
2a80				FORTH_DSP_PTR 3     ; TOS   w1 
2a80 2a 23 f9			ld hl,(cli_data_sp) 
2a83 11 09 00			ld de, 3 * 3 
2a86 ed 52			sbc hl, de 
2a88				endm 
# End of macro FORTH_DSP_PTR
2a88 cd 96 23			call hltostack4 
2a8b			 
2a8b			 
2a8b			 
2a8b			 
2a8b				FORTH_DSP_PTR 0     ; TOS 
2a8b 2a 23 f9			ld hl,(cli_data_sp) 
2a8e 11 00 00			ld de, 0 * 3 
2a91 ed 52			sbc hl, de 
2a93				endm 
# End of macro FORTH_DSP_PTR
2a93 cd a8 23			call hlfromstack3 
2a96			 
2a96				FORTH_DSP_PTR 1     ; TOS 
2a96 2a 23 f9			ld hl,(cli_data_sp) 
2a99 11 03 00			ld de, 1 * 3 
2a9c ed 52			sbc hl, de 
2a9e				endm 
# End of macro FORTH_DSP_PTR
2a9e cd ae 23			call hlfromstack4 
2aa1			 
2aa1			 
2aa1			 
2aa1				FORTH_DSP_PTR 2     ; TOS 
2aa1 2a 23 f9			ld hl,(cli_data_sp) 
2aa4 11 06 00			ld de, 2 * 3 
2aa7 ed 52			sbc hl, de 
2aa9				endm 
# End of macro FORTH_DSP_PTR
2aa9 cd 9c 23			call hlfromstack1 
2aac			 
2aac				FORTH_DSP_PTR 3     ; TOS 
2aac 2a 23 f9			ld hl,(cli_data_sp) 
2aaf 11 09 00			ld de, 3 * 3 
2ab2 ed 52			sbc hl, de 
2ab4				endm 
# End of macro FORTH_DSP_PTR
2ab4 cd a2 23			call hlfromstack2 
2ab7			 
2ab7				NEXTW 
2ab7 c3 38 24			jp macro_next 
2aba				endm 
# End of macro NEXTW
2aba			.AT: 
2aba			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2aba 1f				db WORD_SYS_CORE+OPCODE_AT             
2abb ec 2a			dw .CAT            
2abd 02				db 1 + 1 
2abe .. 00			db "@",0              
2ac0				endm 
# End of macro CWHEAD
2ac0			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2ac0			 
2ac0				if DEBUG_FORTH_WORDS_KEY 
2ac0					DMARK "AT." 
2ac0 f5				push af  
2ac1 3a d5 2a			ld a, (.dmark)  
2ac4 32 a0 fd			ld (debug_mark),a  
2ac7 3a d6 2a			ld a, (.dmark+1)  
2aca 32 a1 fd			ld (debug_mark+1),a  
2acd 3a d7 2a			ld a, (.dmark+2)  
2ad0 32 a2 fd			ld (debug_mark+2),a  
2ad3 18 03			jr .pastdmark  
2ad5 ..			.dmark: db "AT."  
2ad8 f1			.pastdmark: pop af  
2ad9			endm  
# End of macro DMARK
2ad9					CALLMONITOR 
2ad9 cd aa fd			call debug_vector  
2adc				endm  
# End of macro CALLMONITOR
2adc				endif 
2adc			.getbyteat:	 
2adc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2adc cd 4d 22			call macro_dsp_valuehl 
2adf				endm 
# End of macro FORTH_DSP_VALUEHL
2adf				 
2adf			;		push hl 
2adf			 
2adf				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2adf cd 05 23			call macro_forth_dsp_pop 
2ae2				endm 
# End of macro FORTH_DSP_POP
2ae2			 
2ae2			;		pop hl 
2ae2			 
2ae2 7e				ld a, (hl) 
2ae3			 
2ae3 6f				ld l, a 
2ae4 26 00			ld h, 0 
2ae6 cd 48 20			call forth_push_numhl 
2ae9			 
2ae9				NEXTW 
2ae9 c3 38 24			jp macro_next 
2aec				endm 
# End of macro NEXTW
2aec			.CAT: 
2aec			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2aec 20				db WORD_SYS_CORE+OPCODE_CAT             
2aed 15 2b			dw .BANG            
2aef 03				db 2 + 1 
2af0 .. 00			db "C@",0              
2af3				endm 
# End of macro CWHEAD
2af3			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2af3				if DEBUG_FORTH_WORDS_KEY 
2af3					DMARK "CAA" 
2af3 f5				push af  
2af4 3a 08 2b			ld a, (.dmark)  
2af7 32 a0 fd			ld (debug_mark),a  
2afa 3a 09 2b			ld a, (.dmark+1)  
2afd 32 a1 fd			ld (debug_mark+1),a  
2b00 3a 0a 2b			ld a, (.dmark+2)  
2b03 32 a2 fd			ld (debug_mark+2),a  
2b06 18 03			jr .pastdmark  
2b08 ..			.dmark: db "CAA"  
2b0b f1			.pastdmark: pop af  
2b0c			endm  
# End of macro DMARK
2b0c					CALLMONITOR 
2b0c cd aa fd			call debug_vector  
2b0f				endm  
# End of macro CALLMONITOR
2b0f				endif 
2b0f c3 dc 2a			jp .getbyteat 
2b12				NEXTW 
2b12 c3 38 24			jp macro_next 
2b15				endm 
# End of macro NEXTW
2b15			.BANG: 
2b15			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2b15 21				db WORD_SYS_CORE+OPCODE_BANG             
2b16 4b 2b			dw .CBANG            
2b18 02				db 1 + 1 
2b19 .. 00			db "!",0              
2b1b				endm 
# End of macro CWHEAD
2b1b			; | ! ( x w -- ) Store x at address w      | DONE 
2b1b				if DEBUG_FORTH_WORDS_KEY 
2b1b					DMARK "BNG" 
2b1b f5				push af  
2b1c 3a 30 2b			ld a, (.dmark)  
2b1f 32 a0 fd			ld (debug_mark),a  
2b22 3a 31 2b			ld a, (.dmark+1)  
2b25 32 a1 fd			ld (debug_mark+1),a  
2b28 3a 32 2b			ld a, (.dmark+2)  
2b2b 32 a2 fd			ld (debug_mark+2),a  
2b2e 18 03			jr .pastdmark  
2b30 ..			.dmark: db "BNG"  
2b33 f1			.pastdmark: pop af  
2b34			endm  
# End of macro DMARK
2b34					CALLMONITOR 
2b34 cd aa fd			call debug_vector  
2b37				endm  
# End of macro CALLMONITOR
2b37				endif 
2b37			 
2b37			.storebyteat:		 
2b37				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b37 cd 4d 22			call macro_dsp_valuehl 
2b3a				endm 
# End of macro FORTH_DSP_VALUEHL
2b3a				 
2b3a e5				push hl 
2b3b			 
2b3b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b3b cd 05 23			call macro_forth_dsp_pop 
2b3e				endm 
# End of macro FORTH_DSP_POP
2b3e			 
2b3e				; get byte to poke 
2b3e			 
2b3e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b3e cd 4d 22			call macro_dsp_valuehl 
2b41				endm 
# End of macro FORTH_DSP_VALUEHL
2b41 e5				push hl 
2b42			 
2b42			 
2b42				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b42 cd 05 23			call macro_forth_dsp_pop 
2b45				endm 
# End of macro FORTH_DSP_POP
2b45			 
2b45			 
2b45 d1				pop de 
2b46 e1				pop hl 
2b47			 
2b47 73				ld (hl),e 
2b48			 
2b48			 
2b48				NEXTW 
2b48 c3 38 24			jp macro_next 
2b4b				endm 
# End of macro NEXTW
2b4b			.CBANG: 
2b4b			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2b4b 22				db WORD_SYS_CORE+OPCODE_CBANG             
2b4c 74 2b			dw .SCALL            
2b4e 03				db 2 + 1 
2b4f .. 00			db "C!",0              
2b52				endm 
# End of macro CWHEAD
2b52			; | C!  ( x w -- ) Store x at address w  | DONE 
2b52				if DEBUG_FORTH_WORDS_KEY 
2b52					DMARK "CBA" 
2b52 f5				push af  
2b53 3a 67 2b			ld a, (.dmark)  
2b56 32 a0 fd			ld (debug_mark),a  
2b59 3a 68 2b			ld a, (.dmark+1)  
2b5c 32 a1 fd			ld (debug_mark+1),a  
2b5f 3a 69 2b			ld a, (.dmark+2)  
2b62 32 a2 fd			ld (debug_mark+2),a  
2b65 18 03			jr .pastdmark  
2b67 ..			.dmark: db "CBA"  
2b6a f1			.pastdmark: pop af  
2b6b			endm  
# End of macro DMARK
2b6b					CALLMONITOR 
2b6b cd aa fd			call debug_vector  
2b6e				endm  
# End of macro CALLMONITOR
2b6e				endif 
2b6e c3 37 2b			jp .storebyteat 
2b71				NEXTW 
2b71 c3 38 24			jp macro_next 
2b74				endm 
# End of macro NEXTW
2b74			.SCALL: 
2b74			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2b74 23				db WORD_SYS_CORE+OPCODE_SCALL             
2b75 a8 2b			dw .DEPTH            
2b77 05				db 4 + 1 
2b78 .. 00			db "CALL",0              
2b7d				endm 
# End of macro CWHEAD
2b7d			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2b7d				if DEBUG_FORTH_WORDS_KEY 
2b7d					DMARK "CLL" 
2b7d f5				push af  
2b7e 3a 92 2b			ld a, (.dmark)  
2b81 32 a0 fd			ld (debug_mark),a  
2b84 3a 93 2b			ld a, (.dmark+1)  
2b87 32 a1 fd			ld (debug_mark+1),a  
2b8a 3a 94 2b			ld a, (.dmark+2)  
2b8d 32 a2 fd			ld (debug_mark+2),a  
2b90 18 03			jr .pastdmark  
2b92 ..			.dmark: db "CLL"  
2b95 f1			.pastdmark: pop af  
2b96			endm  
# End of macro DMARK
2b96					CALLMONITOR 
2b96 cd aa fd			call debug_vector  
2b99				endm  
# End of macro CALLMONITOR
2b99				endif 
2b99			 
2b99				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b99 cd 4d 22			call macro_dsp_valuehl 
2b9c				endm 
# End of macro FORTH_DSP_VALUEHL
2b9c			 
2b9c			;		push hl 
2b9c			 
2b9c				; destroy value TOS 
2b9c			 
2b9c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b9c cd 05 23			call macro_forth_dsp_pop 
2b9f				endm 
# End of macro FORTH_DSP_POP
2b9f			 
2b9f					 
2b9f			;		pop hl 
2b9f			 
2b9f				; how to do a call with hl???? save SP? 
2b9f cd dc 23			call forth_call_hl 
2ba2			 
2ba2			 
2ba2				; TODO push value back onto stack for another op etc 
2ba2			 
2ba2 cd 48 20			call forth_push_numhl 
2ba5				NEXTW 
2ba5 c3 38 24			jp macro_next 
2ba8				endm 
# End of macro NEXTW
2ba8			.DEPTH: 
2ba8			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2ba8 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2ba9 e5 2b			dw .OVER            
2bab 06				db 5 + 1 
2bac .. 00			db "DEPTH",0              
2bb2				endm 
# End of macro CWHEAD
2bb2			; | DEPTH ( -- u ) Push count of stack | DONE 
2bb2				; take current TOS and remove from base value div by two to get count 
2bb2				if DEBUG_FORTH_WORDS_KEY 
2bb2					DMARK "DEP" 
2bb2 f5				push af  
2bb3 3a c7 2b			ld a, (.dmark)  
2bb6 32 a0 fd			ld (debug_mark),a  
2bb9 3a c8 2b			ld a, (.dmark+1)  
2bbc 32 a1 fd			ld (debug_mark+1),a  
2bbf 3a c9 2b			ld a, (.dmark+2)  
2bc2 32 a2 fd			ld (debug_mark+2),a  
2bc5 18 03			jr .pastdmark  
2bc7 ..			.dmark: db "DEP"  
2bca f1			.pastdmark: pop af  
2bcb			endm  
# End of macro DMARK
2bcb					CALLMONITOR 
2bcb cd aa fd			call debug_vector  
2bce				endm  
# End of macro CALLMONITOR
2bce				endif 
2bce			 
2bce			 
2bce 2a 23 f9		ld hl, (cli_data_sp) 
2bd1 11 5d f6		ld de, cli_data_stack 
2bd4 ed 52		sbc hl,de 
2bd6			 
2bd6			; div by size of stack item 
2bd6			 
2bd6 5d			ld e,l 
2bd7 0e 03		ld c, 3 
2bd9 cd 6e 0f		call Div8 
2bdc			 
2bdc 6f			ld l,a 
2bdd 26 00		ld h,0 
2bdf			 
2bdf			;srl h 
2bdf			;rr l 
2bdf			 
2bdf cd 48 20			call forth_push_numhl 
2be2				NEXTW 
2be2 c3 38 24			jp macro_next 
2be5				endm 
# End of macro NEXTW
2be5			.OVER: 
2be5			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2be5 42				db WORD_SYS_CORE+46             
2be6 2c 2c			dw .PAUSE            
2be8 05				db 4 + 1 
2be9 .. 00			db "OVER",0              
2bee				endm 
# End of macro CWHEAD
2bee			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | TOFIX 
2bee				if DEBUG_FORTH_WORDS_KEY 
2bee					DMARK "OVR" 
2bee f5				push af  
2bef 3a 03 2c			ld a, (.dmark)  
2bf2 32 a0 fd			ld (debug_mark),a  
2bf5 3a 04 2c			ld a, (.dmark+1)  
2bf8 32 a1 fd			ld (debug_mark+1),a  
2bfb 3a 05 2c			ld a, (.dmark+2)  
2bfe 32 a2 fd			ld (debug_mark+2),a  
2c01 18 03			jr .pastdmark  
2c03 ..			.dmark: db "OVR"  
2c06 f1			.pastdmark: pop af  
2c07			endm  
# End of macro DMARK
2c07					CALLMONITOR 
2c07 cd aa fd			call debug_vector  
2c0a				endm  
# End of macro CALLMONITOR
2c0a				endif 
2c0a			 
2c0a			; TODO Use os stack swap memory 
2c0a			 
2c0a				; work out what type we are looking at 
2c0a			 
2c0a				FORTH_DSP_PTR 1 
2c0a 2a 23 f9			ld hl,(cli_data_sp) 
2c0d 11 03 00			ld de, 1 * 3 
2c10 ed 52			sbc hl, de 
2c12				endm 
# End of macro FORTH_DSP_PTR
2c12			 
2c12 7e				ld a, (hl) 
2c13				 
2c13 f5				push af 
2c14				; whatever the type lets get the pointer or word 
2c14 23				inc hl 
2c15			;; 
2c15			 
2c15				; type check now to decide on how to push  
2c15			 
2c15 cd ba 23			call loadwordinhl 
2c18 f1				pop af 
2c19 fe 01			cp DS_TYPE_STR 
2c1b 28 06			jr z, .ovstr 
2c1d			 
2c1d				; we have a numeric so load the word and push 
2c1d			;	ld e, (hl) 
2c1d			;	inc hl 
2c1d			;	ld d, (hl) 
2c1d			;	ex de, hl 
2c1d cd 48 20			call forth_push_numhl 
2c20				NEXTW 
2c20 c3 38 24			jp macro_next 
2c23				endm 
# End of macro NEXTW
2c23			 
2c23			.ovstr: 
2c23				; ok, a string so get the pointer and push as a string 
2c23			 
2c23			;	call loadwordinhl 
2c23 cd b6 20			call forth_push_str 
2c26				NEXTW 
2c26 c3 38 24			jp macro_next 
2c29				endm 
# End of macro NEXTW
2c29			 
2c29			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c29			;	push hl    ; n2 
2c29			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c29			; 
2c29			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c29			;	push hl    ; n1 
2c29			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c29			; 
2c29			;	pop de     ; n1 
2c29			;	pop hl     ; n2 
2c29			; 
2c29			;	push de 
2c29			;	push hl 
2c29			;	push de 
2c29			 
2c29				; push back  
2c29			 
2c29			;	pop hl 
2c29			;	call forth_push_numhl 
2c29			;	pop hl 
2c29			;	call forth_push_numhl 
2c29			;	pop hl 
2c29			;	call forth_push_numhl 
2c29				NEXTW 
2c29 c3 38 24			jp macro_next 
2c2c				endm 
# End of macro NEXTW
2c2c			 
2c2c			.PAUSE: 
2c2c			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2c2c 43				db WORD_SYS_CORE+47             
2c2d 61 2c			dw .PAUSES            
2c2f 08				db 7 + 1 
2c30 .. 00			db "PAUSEMS",0              
2c38				endm 
# End of macro CWHEAD
2c38			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2c38				if DEBUG_FORTH_WORDS_KEY 
2c38					DMARK "PMS" 
2c38 f5				push af  
2c39 3a 4d 2c			ld a, (.dmark)  
2c3c 32 a0 fd			ld (debug_mark),a  
2c3f 3a 4e 2c			ld a, (.dmark+1)  
2c42 32 a1 fd			ld (debug_mark+1),a  
2c45 3a 4f 2c			ld a, (.dmark+2)  
2c48 32 a2 fd			ld (debug_mark+2),a  
2c4b 18 03			jr .pastdmark  
2c4d ..			.dmark: db "PMS"  
2c50 f1			.pastdmark: pop af  
2c51			endm  
# End of macro DMARK
2c51					CALLMONITOR 
2c51 cd aa fd			call debug_vector  
2c54				endm  
# End of macro CALLMONITOR
2c54				endif 
2c54				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c54 cd 4d 22			call macro_dsp_valuehl 
2c57				endm 
# End of macro FORTH_DSP_VALUEHL
2c57			;		push hl    ; n2 
2c57				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c57 cd 05 23			call macro_forth_dsp_pop 
2c5a				endm 
# End of macro FORTH_DSP_POP
2c5a			;		pop hl 
2c5a			 
2c5a 7d				ld a, l 
2c5b cd d2 0c			call aDelayInMS 
2c5e			       NEXTW 
2c5e c3 38 24			jp macro_next 
2c61				endm 
# End of macro NEXTW
2c61			.PAUSES:  
2c61			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2c61 44				db WORD_SYS_CORE+48             
2c62 d0 2c			dw .ROT            
2c64 06				db 5 + 1 
2c65 .. 00			db "PAUSE",0              
2c6b				endm 
# End of macro CWHEAD
2c6b			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2c6b				if DEBUG_FORTH_WORDS_KEY 
2c6b					DMARK "PAU" 
2c6b f5				push af  
2c6c 3a 80 2c			ld a, (.dmark)  
2c6f 32 a0 fd			ld (debug_mark),a  
2c72 3a 81 2c			ld a, (.dmark+1)  
2c75 32 a1 fd			ld (debug_mark+1),a  
2c78 3a 82 2c			ld a, (.dmark+2)  
2c7b 32 a2 fd			ld (debug_mark+2),a  
2c7e 18 03			jr .pastdmark  
2c80 ..			.dmark: db "PAU"  
2c83 f1			.pastdmark: pop af  
2c84			endm  
# End of macro DMARK
2c84					CALLMONITOR 
2c84 cd aa fd			call debug_vector  
2c87				endm  
# End of macro CALLMONITOR
2c87				endif 
2c87				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c87 cd 4d 22			call macro_dsp_valuehl 
2c8a				endm 
# End of macro FORTH_DSP_VALUEHL
2c8a			;		push hl    ; n2 
2c8a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c8a cd 05 23			call macro_forth_dsp_pop 
2c8d				endm 
# End of macro FORTH_DSP_POP
2c8d			;		pop hl 
2c8d 45				ld b, l 
2c8e				if DEBUG_FORTH_WORDS 
2c8e					DMARK "PAU" 
2c8e f5				push af  
2c8f 3a a3 2c			ld a, (.dmark)  
2c92 32 a0 fd			ld (debug_mark),a  
2c95 3a a4 2c			ld a, (.dmark+1)  
2c98 32 a1 fd			ld (debug_mark+1),a  
2c9b 3a a5 2c			ld a, (.dmark+2)  
2c9e 32 a2 fd			ld (debug_mark+2),a  
2ca1 18 03			jr .pastdmark  
2ca3 ..			.dmark: db "PAU"  
2ca6 f1			.pastdmark: pop af  
2ca7			endm  
# End of macro DMARK
2ca7					CALLMONITOR 
2ca7 cd aa fd			call debug_vector  
2caa				endm  
# End of macro CALLMONITOR
2caa				endif 
2caa c5			.pauses1:	push bc 
2cab cd ed 0c			call delay1s 
2cae c1				pop bc 
2caf				if DEBUG_FORTH_WORDS 
2caf					DMARK "PA1" 
2caf f5				push af  
2cb0 3a c4 2c			ld a, (.dmark)  
2cb3 32 a0 fd			ld (debug_mark),a  
2cb6 3a c5 2c			ld a, (.dmark+1)  
2cb9 32 a1 fd			ld (debug_mark+1),a  
2cbc 3a c6 2c			ld a, (.dmark+2)  
2cbf 32 a2 fd			ld (debug_mark+2),a  
2cc2 18 03			jr .pastdmark  
2cc4 ..			.dmark: db "PA1"  
2cc7 f1			.pastdmark: pop af  
2cc8			endm  
# End of macro DMARK
2cc8					CALLMONITOR 
2cc8 cd aa fd			call debug_vector  
2ccb				endm  
# End of macro CALLMONITOR
2ccb				endif 
2ccb 10 dd			djnz .pauses1 
2ccd			 
2ccd			       NEXTW 
2ccd c3 38 24			jp macro_next 
2cd0				endm 
# End of macro NEXTW
2cd0			.ROT: 
2cd0			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2cd0 45				db WORD_SYS_CORE+49             
2cd1 39 2d			dw .UWORDS            
2cd3 04				db 3 + 1 
2cd4 .. 00			db "ROT",0              
2cd8				endm 
# End of macro CWHEAD
2cd8			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | TOFIX 
2cd8				if DEBUG_FORTH_WORDS_KEY 
2cd8					DMARK "ROT" 
2cd8 f5				push af  
2cd9 3a ed 2c			ld a, (.dmark)  
2cdc 32 a0 fd			ld (debug_mark),a  
2cdf 3a ee 2c			ld a, (.dmark+1)  
2ce2 32 a1 fd			ld (debug_mark+1),a  
2ce5 3a ef 2c			ld a, (.dmark+2)  
2ce8 32 a2 fd			ld (debug_mark+2),a  
2ceb 18 03			jr .pastdmark  
2ced ..			.dmark: db "ROT"  
2cf0 f1			.pastdmark: pop af  
2cf1			endm  
# End of macro DMARK
2cf1					CALLMONITOR 
2cf1 cd aa fd			call debug_vector  
2cf4				endm  
# End of macro CALLMONITOR
2cf4				endif 
2cf4			 
2cf4			; DONE Use os stack swap memory 
2cf4			 
2cf4				FORTH_DSP_PTR 0     ; u3 
2cf4 2a 23 f9			ld hl,(cli_data_sp) 
2cf7 11 00 00			ld de, 0 * 3 
2cfa ed 52			sbc hl, de 
2cfc				endm 
# End of macro FORTH_DSP_PTR
2cfc cd 84 23			call hltostack1     
2cff			  
2cff				FORTH_DSP_PTR 1     ; u2 
2cff 2a 23 f9			ld hl,(cli_data_sp) 
2d02 11 03 00			ld de, 1 * 3 
2d05 ed 52			sbc hl, de 
2d07				endm 
# End of macro FORTH_DSP_PTR
2d07 cd 8a 23			call hltostack2      
2d0a			 
2d0a				FORTH_DSP_PTR 2     ; u1 
2d0a 2a 23 f9			ld hl,(cli_data_sp) 
2d0d 11 06 00			ld de, 2 * 3 
2d10 ed 52			sbc hl, de 
2d12				endm 
# End of macro FORTH_DSP_PTR
2d12 cd 90 23			call hltostack3 
2d15			 
2d15			 
2d15				FORTH_DSP_PTR 0     ;  
2d15 2a 23 f9			ld hl,(cli_data_sp) 
2d18 11 00 00			ld de, 0 * 3 
2d1b ed 52			sbc hl, de 
2d1d				endm 
# End of macro FORTH_DSP_PTR
2d1d cd a8 23			call hlfromstack3 
2d20			 
2d20				FORTH_DSP_PTR 1     ; TOS 
2d20 2a 23 f9			ld hl,(cli_data_sp) 
2d23 11 03 00			ld de, 1 * 3 
2d26 ed 52			sbc hl, de 
2d28				endm 
# End of macro FORTH_DSP_PTR
2d28 cd 9c 23			call hlfromstack1 
2d2b			 
2d2b				FORTH_DSP_PTR 2     ; TOS 
2d2b 2a 23 f9			ld hl,(cli_data_sp) 
2d2e 11 06 00			ld de, 2 * 3 
2d31 ed 52			sbc hl, de 
2d33				endm 
# End of macro FORTH_DSP_PTR
2d33 cd a2 23			call hlfromstack2 
2d36			 
2d36			 
2d36			;	FORTH_DSP_VALUEHL 
2d36			;	push hl    ; u3  
2d36			; 
2d36			;	FORTH_DSP_POP 
2d36			; 
2d36			;	FORTH_DSP_VALUEHL 
2d36			;	push hl     ; u2 
2d36			; 
2d36			;	FORTH_DSP_POP 
2d36			; 
2d36			;	FORTH_DSP_VALUEHL 
2d36			;	push hl     ; u1 
2d36			; 
2d36			;	FORTH_DSP_POP 
2d36			; 
2d36			;	pop bc      ; u1 
2d36			;	pop hl      ; u2 
2d36			;	pop de      ; u3 
2d36			; 
2d36			; 
2d36			;	push bc 
2d36			;	push de 
2d36			;	push hl 
2d36			; 
2d36			; 
2d36			;	pop hl 
2d36			;	call forth_push_numhl 
2d36			; 
2d36			;	pop hl 
2d36			;	call forth_push_numhl 
2d36			; 
2d36			;	pop hl 
2d36			;	call forth_push_numhl 
2d36				 
2d36			 
2d36			 
2d36			 
2d36			 
2d36			 
2d36			       NEXTW 
2d36 c3 38 24			jp macro_next 
2d39				endm 
# End of macro NEXTW
2d39			 
2d39			.UWORDS: 
2d39			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2d39 50				db WORD_SYS_CORE+60             
2d3a fb 2d			dw .BP            
2d3c 07				db 6 + 1 
2d3d .. 00			db "UWORDS",0              
2d44				endm 
# End of macro CWHEAD
2d44			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2d44			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2d44			; | | Following the count are the individual words. 
2d44			; | | 
2d44			; | | e.g. UWORDS 
2d44			; | | BOX DIRLIST 2 
2d44			; | |  
2d44			; | | Can be used to save the words to storage via: 
2d44			; | | UWORDS $01 DO $01 APPEND LOOP 
2d44			if DEBUG_FORTH_WORDS_KEY 
2d44				DMARK "UWR" 
2d44 f5				push af  
2d45 3a 59 2d			ld a, (.dmark)  
2d48 32 a0 fd			ld (debug_mark),a  
2d4b 3a 5a 2d			ld a, (.dmark+1)  
2d4e 32 a1 fd			ld (debug_mark+1),a  
2d51 3a 5b 2d			ld a, (.dmark+2)  
2d54 32 a2 fd			ld (debug_mark+2),a  
2d57 18 03			jr .pastdmark  
2d59 ..			.dmark: db "UWR"  
2d5c f1			.pastdmark: pop af  
2d5d			endm  
# End of macro DMARK
2d5d				CALLMONITOR 
2d5d cd aa fd			call debug_vector  
2d60				endm  
# End of macro CALLMONITOR
2d60			endif 
2d60 21 00 80			ld hl, baseram 
2d63				;ld hl, baseusermem 
2d63 01 00 00			ld bc, 0    ; start a counter 
2d66			 
2d66			; skip dict stub 
2d66			 
2d66 cd 75 25			call forth_tok_next 
2d69			 
2d69			 
2d69			; while we have words to look for 
2d69			 
2d69 7e			.douscan:	ld a, (hl)      
2d6a			if DEBUG_FORTH_WORDS 
2d6a				DMARK "UWs" 
2d6a f5				push af  
2d6b 3a 7f 2d			ld a, (.dmark)  
2d6e 32 a0 fd			ld (debug_mark),a  
2d71 3a 80 2d			ld a, (.dmark+1)  
2d74 32 a1 fd			ld (debug_mark+1),a  
2d77 3a 81 2d			ld a, (.dmark+2)  
2d7a 32 a2 fd			ld (debug_mark+2),a  
2d7d 18 03			jr .pastdmark  
2d7f ..			.dmark: db "UWs"  
2d82 f1			.pastdmark: pop af  
2d83			endm  
# End of macro DMARK
2d83				CALLMONITOR 
2d83 cd aa fd			call debug_vector  
2d86				endm  
# End of macro CALLMONITOR
2d86			endif 
2d86 fe 00			cp WORD_SYS_END 
2d88 28 4d			jr z, .udone 
2d8a fe 01			cp WORD_SYS_UWORD 
2d8c 20 44			jr nz, .nuword 
2d8e			 
2d8e			if DEBUG_FORTH_WORDS 
2d8e				DMARK "UWu" 
2d8e f5				push af  
2d8f 3a a3 2d			ld a, (.dmark)  
2d92 32 a0 fd			ld (debug_mark),a  
2d95 3a a4 2d			ld a, (.dmark+1)  
2d98 32 a1 fd			ld (debug_mark+1),a  
2d9b 3a a5 2d			ld a, (.dmark+2)  
2d9e 32 a2 fd			ld (debug_mark+2),a  
2da1 18 03			jr .pastdmark  
2da3 ..			.dmark: db "UWu"  
2da6 f1			.pastdmark: pop af  
2da7			endm  
# End of macro DMARK
2da7				CALLMONITOR 
2da7 cd aa fd			call debug_vector  
2daa				endm  
# End of macro CALLMONITOR
2daa			endif 
2daa				; we have a uword so push its name to the stack 
2daa			 
2daa e5				push hl  ; save so we can move to next dict block 
2dab			 
2dab				; skip opcode 
2dab 23				inc hl  
2dac				; skip next ptr 
2dac 23				inc hl  
2dad 23				inc hl 
2dae				; skip len 
2dae 23				inc hl 
2daf			if DEBUG_FORTH_WORDS 
2daf				DMARK "UWt" 
2daf f5				push af  
2db0 3a c4 2d			ld a, (.dmark)  
2db3 32 a0 fd			ld (debug_mark),a  
2db6 3a c5 2d			ld a, (.dmark+1)  
2db9 32 a1 fd			ld (debug_mark+1),a  
2dbc 3a c6 2d			ld a, (.dmark+2)  
2dbf 32 a2 fd			ld (debug_mark+2),a  
2dc2 18 03			jr .pastdmark  
2dc4 ..			.dmark: db "UWt"  
2dc7 f1			.pastdmark: pop af  
2dc8			endm  
# End of macro DMARK
2dc8				CALLMONITOR 
2dc8 cd aa fd			call debug_vector  
2dcb				endm  
# End of macro CALLMONITOR
2dcb			endif 
2dcb 03				inc bc 
2dcc			 
2dcc c5				push bc 
2dcd cd b6 20			call forth_push_str 
2dd0 c1				pop bc 
2dd1			 
2dd1 e1				pop hl 	 
2dd2			 
2dd2 cd 75 25		.nuword:	call forth_tok_next 
2dd5 18 92			jr .douscan  
2dd7			 
2dd7			.udone:		 ; push count of uwords found 
2dd7 c5				push bc 
2dd8 e1				pop hl 
2dd9			 
2dd9			if DEBUG_FORTH_WORDS 
2dd9				DMARK "UWc" 
2dd9 f5				push af  
2dda 3a ee 2d			ld a, (.dmark)  
2ddd 32 a0 fd			ld (debug_mark),a  
2de0 3a ef 2d			ld a, (.dmark+1)  
2de3 32 a1 fd			ld (debug_mark+1),a  
2de6 3a f0 2d			ld a, (.dmark+2)  
2de9 32 a2 fd			ld (debug_mark+2),a  
2dec 18 03			jr .pastdmark  
2dee ..			.dmark: db "UWc"  
2df1 f1			.pastdmark: pop af  
2df2			endm  
# End of macro DMARK
2df2				CALLMONITOR 
2df2 cd aa fd			call debug_vector  
2df5				endm  
# End of macro CALLMONITOR
2df5			endif 
2df5 cd 48 20			call forth_push_numhl 
2df8			 
2df8			 
2df8			       NEXTW 
2df8 c3 38 24			jp macro_next 
2dfb				endm 
# End of macro NEXTW
2dfb			 
2dfb			.BP: 
2dfb			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2dfb 54				db WORD_SYS_CORE+64             
2dfc 35 2e			dw .MONITOR            
2dfe 03				db 2 + 1 
2dff .. 00			db "BP",0              
2e02				endm 
# End of macro CWHEAD
2e02			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2e02			; | | $00 Will enable the break points within specific code paths 
2e02			; | | $01 Will disable break points 
2e02			; | |  
2e02			; | | By default break points are off. Either the above can be used to enable them 
2e02			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2e02			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2e02			; | | can disable break points. Exiting will then continue boot process. 
2e02				; get byte count 
2e02				if DEBUG_FORTH_WORDS_KEY 
2e02					DMARK "BP." 
2e02 f5				push af  
2e03 3a 17 2e			ld a, (.dmark)  
2e06 32 a0 fd			ld (debug_mark),a  
2e09 3a 18 2e			ld a, (.dmark+1)  
2e0c 32 a1 fd			ld (debug_mark+1),a  
2e0f 3a 19 2e			ld a, (.dmark+2)  
2e12 32 a2 fd			ld (debug_mark+2),a  
2e15 18 03			jr .pastdmark  
2e17 ..			.dmark: db "BP."  
2e1a f1			.pastdmark: pop af  
2e1b			endm  
# End of macro DMARK
2e1b					CALLMONITOR 
2e1b cd aa fd			call debug_vector  
2e1e				endm  
# End of macro CALLMONITOR
2e1e				endif 
2e1e			 
2e1e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e1e cd 4d 22			call macro_dsp_valuehl 
2e21				endm 
# End of macro FORTH_DSP_VALUEHL
2e21			 
2e21			;		push hl 
2e21			 
2e21				; destroy value TOS 
2e21			 
2e21				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e21 cd 05 23			call macro_forth_dsp_pop 
2e24				endm 
# End of macro FORTH_DSP_POP
2e24			 
2e24			;		pop hl 
2e24			 
2e24 3e 00			ld a,0 
2e26 bd				cp l 
2e27 28 06			jr z, .bpset 
2e29			;		ld a, '*' 
2e29 cd 55 19			call bp_off 
2e2c				NEXTW 
2e2c c3 38 24			jp macro_next 
2e2f				endm 
# End of macro NEXTW
2e2f			 
2e2f			.bpset:	 
2e2f				;	ld (os_view_disable), a 
2e2f cd 49 19			call bp_on 
2e32			 
2e32			 
2e32				NEXTW 
2e32 c3 38 24			jp macro_next 
2e35				endm 
# End of macro NEXTW
2e35			 
2e35			 
2e35			.MONITOR: 
2e35			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2e35 55				db WORD_SYS_CORE+65             
2e36 66 2e			dw .MALLOC            
2e38 08				db 7 + 1 
2e39 .. 00			db "MONITOR",0              
2e41				endm 
# End of macro CWHEAD
2e41			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2e41			; | | At start the current various registers will be displayed with contents. 
2e41			; | | Top right corner will show the most recent debug marker seen. 
2e41			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2e41			; | | and the return stack pointer (RSP). 
2e41			; | | Pressing: 
2e41			; | |    1 - Initial screen 
2e41			; | |    2 - Display a data dump of HL 
2e41			; | |    3 - Display a data dump of DE 
2e41			; | |    4 - Display a data dump of BC 
2e41			; | |    5 - Display a data dump of HL 
2e41			; | |    6 - Display a data dump of DSP 
2e41			; | |    7 - Display a data dump of RSP 
2e41			; | |    8 - Display a data dump of what is at DSP 
2e41			; | |    9 - Display a data dump of what is at RSP 
2e41			; | |    0 - Exit monitor and continue running. This will also enable break points 
2e41			; | |    * - Disable break points 
2e41			; | |    # - Enter traditional monitor mode 
2e41			; | | 
2e41			; | | Monitor Mode 
2e41			; | | ------------ 
2e41			; | | A prompt of '>' will be shown for various commands: 
2e41			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2e41			; | |    C - Continue display a data dump from the last set address 
2e41			; | |    M xxxx - Set start of memory edit at address xx 
2e41			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2e41			; | |    G xxxx - Exec code at specific address 
2e41			; | |    Q - Return to previous 
2e41				if DEBUG_FORTH_WORDS_KEY 
2e41					DMARK "MON" 
2e41 f5				push af  
2e42 3a 56 2e			ld a, (.dmark)  
2e45 32 a0 fd			ld (debug_mark),a  
2e48 3a 57 2e			ld a, (.dmark+1)  
2e4b 32 a1 fd			ld (debug_mark+1),a  
2e4e 3a 58 2e			ld a, (.dmark+2)  
2e51 32 a2 fd			ld (debug_mark+2),a  
2e54 18 03			jr .pastdmark  
2e56 ..			.dmark: db "MON"  
2e59 f1			.pastdmark: pop af  
2e5a			endm  
# End of macro DMARK
2e5a					CALLMONITOR 
2e5a cd aa fd			call debug_vector  
2e5d				endm  
# End of macro CALLMONITOR
2e5d				endif 
2e5d			;		ld a, 0 
2e5d			;		ld (os_view_disable), a 
2e5d cd 49 19			call bp_on 
2e60			 
2e60				CALLMONITOR 
2e60 cd aa fd			call debug_vector  
2e63				endm  
# End of macro CALLMONITOR
2e63			 
2e63			;	call monitor 
2e63			 
2e63				NEXTW 
2e63 c3 38 24			jp macro_next 
2e66				endm 
# End of macro NEXTW
2e66			 
2e66			 
2e66			.MALLOC: 
2e66			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2e66 56				db WORD_SYS_CORE+66             
2e67 8f 2e			dw .MALLOC2            
2e69 06				db 5 + 1 
2e6a .. 00			db "ALLOT",0              
2e70				endm 
# End of macro CWHEAD
2e70			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2e70				if DEBUG_FORTH_WORDS_KEY 
2e70					DMARK "ALL" 
2e70 f5				push af  
2e71 3a 85 2e			ld a, (.dmark)  
2e74 32 a0 fd			ld (debug_mark),a  
2e77 3a 86 2e			ld a, (.dmark+1)  
2e7a 32 a1 fd			ld (debug_mark+1),a  
2e7d 3a 87 2e			ld a, (.dmark+2)  
2e80 32 a2 fd			ld (debug_mark+2),a  
2e83 18 03			jr .pastdmark  
2e85 ..			.dmark: db "ALL"  
2e88 f1			.pastdmark: pop af  
2e89			endm  
# End of macro DMARK
2e89					CALLMONITOR 
2e89 cd aa fd			call debug_vector  
2e8c				endm  
# End of macro CALLMONITOR
2e8c				endif 
2e8c c3 b6 2e			jp .mallocc 
2e8f			.MALLOC2: 
2e8f			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2e8f 56				db WORD_SYS_CORE+66             
2e90 cd 2e			dw .FREE            
2e92 07				db 6 + 1 
2e93 .. 00			db "MALLOC",0              
2e9a				endm 
# End of macro CWHEAD
2e9a			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2e9a				; get byte count 
2e9a				if DEBUG_FORTH_WORDS_KEY 
2e9a					DMARK "MAL" 
2e9a f5				push af  
2e9b 3a af 2e			ld a, (.dmark)  
2e9e 32 a0 fd			ld (debug_mark),a  
2ea1 3a b0 2e			ld a, (.dmark+1)  
2ea4 32 a1 fd			ld (debug_mark+1),a  
2ea7 3a b1 2e			ld a, (.dmark+2)  
2eaa 32 a2 fd			ld (debug_mark+2),a  
2ead 18 03			jr .pastdmark  
2eaf ..			.dmark: db "MAL"  
2eb2 f1			.pastdmark: pop af  
2eb3			endm  
# End of macro DMARK
2eb3					CALLMONITOR 
2eb3 cd aa fd			call debug_vector  
2eb6				endm  
# End of macro CALLMONITOR
2eb6				endif 
2eb6			.mallocc: 
2eb6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2eb6 cd 4d 22			call macro_dsp_valuehl 
2eb9				endm 
# End of macro FORTH_DSP_VALUEHL
2eb9			 
2eb9			;		push hl 
2eb9			 
2eb9				; destroy value TOS 
2eb9			 
2eb9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2eb9 cd 05 23			call macro_forth_dsp_pop 
2ebc				endm 
# End of macro FORTH_DSP_POP
2ebc			 
2ebc			;		pop hl 
2ebc cd b9 13			call malloc 
2ebf			if DEBUG_FORTH_MALLOC_GUARD 
2ebf f5				push af 
2ec0 cd 07 10			call ishlzero 
2ec3			;		ld a, l 
2ec3			;		add h 
2ec3			;		cp 0 
2ec3 f1				pop af 
2ec4				 
2ec4 cc 3a 61			call z,malloc_error 
2ec7			endif 
2ec7			 
2ec7 cd 48 20			call forth_push_numhl 
2eca				NEXTW 
2eca c3 38 24			jp macro_next 
2ecd				endm 
# End of macro NEXTW
2ecd			 
2ecd			.FREE: 
2ecd			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2ecd 57				db WORD_SYS_CORE+67             
2ece fe 2e			dw .LIST            
2ed0 05				db 4 + 1 
2ed1 .. 00			db "FREE",0              
2ed6				endm 
# End of macro CWHEAD
2ed6			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2ed6				if DEBUG_FORTH_WORDS_KEY 
2ed6					DMARK "FRE" 
2ed6 f5				push af  
2ed7 3a eb 2e			ld a, (.dmark)  
2eda 32 a0 fd			ld (debug_mark),a  
2edd 3a ec 2e			ld a, (.dmark+1)  
2ee0 32 a1 fd			ld (debug_mark+1),a  
2ee3 3a ed 2e			ld a, (.dmark+2)  
2ee6 32 a2 fd			ld (debug_mark+2),a  
2ee9 18 03			jr .pastdmark  
2eeb ..			.dmark: db "FRE"  
2eee f1			.pastdmark: pop af  
2eef			endm  
# End of macro DMARK
2eef					CALLMONITOR 
2eef cd aa fd			call debug_vector  
2ef2				endm  
# End of macro CALLMONITOR
2ef2				endif 
2ef2				; get address 
2ef2			 
2ef2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ef2 cd 4d 22			call macro_dsp_valuehl 
2ef5				endm 
# End of macro FORTH_DSP_VALUEHL
2ef5			 
2ef5			;		push hl 
2ef5			 
2ef5				; destroy value TOS 
2ef5			 
2ef5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ef5 cd 05 23			call macro_forth_dsp_pop 
2ef8				endm 
# End of macro FORTH_DSP_POP
2ef8			 
2ef8			;		pop hl 
2ef8			if FORTH_ENABLE_MALLOCFREE 
2ef8 cd 83 14			call free 
2efb			endif 
2efb				NEXTW 
2efb c3 38 24			jp macro_next 
2efe				endm 
# End of macro NEXTW
2efe			.LIST: 
2efe			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2efe 5c				db WORD_SYS_CORE+72             
2eff fa 30			dw .FORGET            
2f01 05				db 4 + 1 
2f02 .. 00			db "LIST",0              
2f07				endm 
# End of macro CWHEAD
2f07			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2f07			; | | The quoted word must be in upper case. 
2f07			if DEBUG_FORTH_WORDS_KEY 
2f07				DMARK "LST" 
2f07 f5				push af  
2f08 3a 1c 2f			ld a, (.dmark)  
2f0b 32 a0 fd			ld (debug_mark),a  
2f0e 3a 1d 2f			ld a, (.dmark+1)  
2f11 32 a1 fd			ld (debug_mark+1),a  
2f14 3a 1e 2f			ld a, (.dmark+2)  
2f17 32 a2 fd			ld (debug_mark+2),a  
2f1a 18 03			jr .pastdmark  
2f1c ..			.dmark: db "LST"  
2f1f f1			.pastdmark: pop af  
2f20			endm  
# End of macro DMARK
2f20				CALLMONITOR 
2f20 cd aa fd			call debug_vector  
2f23				endm  
# End of macro CALLMONITOR
2f23			endif 
2f23			 
2f23				FORTH_DSP_VALUEHL 
2f23 cd 4d 22			call macro_dsp_valuehl 
2f26				endm 
# End of macro FORTH_DSP_VALUEHL
2f26			 
2f26 e5				push hl 
2f27				FORTH_DSP_POP 
2f27 cd 05 23			call macro_forth_dsp_pop 
2f2a				endm 
# End of macro FORTH_DSP_POP
2f2a c1				pop bc 
2f2b			 
2f2b			; Start format of scratch string 
2f2b			 
2f2b 21 f6 f0			ld hl, scratch 
2f2e			 
2f2e 3e 3a			ld a, ':' 
2f30 77				ld (hl),a 
2f31 23				inc hl 
2f32 3e 20			ld a, ' ' 
2f34 77				ld (hl), a 
2f35			 
2f35				; Get ptr to the word we need to look up 
2f35			 
2f35			;		FORTH_DSP_VALUEHL 
2f35				;v5 FORTH_DSP_VALUE 
2f35			; TODO type check 
2f35			;		inc hl    ; Skip type check  
2f35			;		push hl 
2f35			;		ex de, hl    ; put into DE 
2f35			 
2f35			 
2f35 21 00 80			ld hl, baseram 
2f38				;ld hl, baseusermem 
2f38			 
2f38 e5			push hl   ; sacreifical push 
2f39			 
2f39			.ldouscanm: 
2f39 e1			pop hl 
2f3a			.ldouscan: 
2f3a			if DEBUG_FORTH_WORDS 
2f3a				DMARK "LSs" 
2f3a f5				push af  
2f3b 3a 4f 2f			ld a, (.dmark)  
2f3e 32 a0 fd			ld (debug_mark),a  
2f41 3a 50 2f			ld a, (.dmark+1)  
2f44 32 a1 fd			ld (debug_mark+1),a  
2f47 3a 51 2f			ld a, (.dmark+2)  
2f4a 32 a2 fd			ld (debug_mark+2),a  
2f4d 18 03			jr .pastdmark  
2f4f ..			.dmark: db "LSs"  
2f52 f1			.pastdmark: pop af  
2f53			endm  
# End of macro DMARK
2f53				CALLMONITOR 
2f53 cd aa fd			call debug_vector  
2f56				endm  
# End of macro CALLMONITOR
2f56			endif 
2f56			; skip dict stub 
2f56 cd 75 25			call forth_tok_next 
2f59			 
2f59			 
2f59			; while we have words to look for 
2f59			 
2f59 7e			ld a, (hl)      
2f5a			if DEBUG_FORTH_WORDS 
2f5a				DMARK "LSk" 
2f5a f5				push af  
2f5b 3a 6f 2f			ld a, (.dmark)  
2f5e 32 a0 fd			ld (debug_mark),a  
2f61 3a 70 2f			ld a, (.dmark+1)  
2f64 32 a1 fd			ld (debug_mark+1),a  
2f67 3a 71 2f			ld a, (.dmark+2)  
2f6a 32 a2 fd			ld (debug_mark+2),a  
2f6d 18 03			jr .pastdmark  
2f6f ..			.dmark: db "LSk"  
2f72 f1			.pastdmark: pop af  
2f73			endm  
# End of macro DMARK
2f73				CALLMONITOR 
2f73 cd aa fd			call debug_vector  
2f76				endm  
# End of macro CALLMONITOR
2f76			endif 
2f76				;cp WORD_SYS_END 
2f76				;jp z, .lunotfound 
2f76			 
2f76					; if we hit non uwords then gone too far 
2f76 fe 01				cp WORD_SYS_UWORD 
2f78 c2 b6 30				jp nz, .lunotfound 
2f7b			 
2f7b				if DEBUG_FORTH_WORDS 
2f7b					DMARK "LSu" 
2f7b f5				push af  
2f7c 3a 90 2f			ld a, (.dmark)  
2f7f 32 a0 fd			ld (debug_mark),a  
2f82 3a 91 2f			ld a, (.dmark+1)  
2f85 32 a1 fd			ld (debug_mark+1),a  
2f88 3a 92 2f			ld a, (.dmark+2)  
2f8b 32 a2 fd			ld (debug_mark+2),a  
2f8e 18 03			jr .pastdmark  
2f90 ..			.dmark: db "LSu"  
2f93 f1			.pastdmark: pop af  
2f94			endm  
# End of macro DMARK
2f94					CALLMONITOR 
2f94 cd aa fd			call debug_vector  
2f97				endm  
# End of macro CALLMONITOR
2f97				endif 
2f97			 
2f97					; found a uword but is it the one we want... 
2f97			 
2f97 c5					push bc     ; uword to find is on bc 
2f98 d1					pop de 
2f99			 
2f99 e5					push hl  ; to save the ptr 
2f9a			 
2f9a					; skip opcode 
2f9a 23					inc hl  
2f9b					; skip next ptr 
2f9b 23					inc hl  
2f9c 23					inc hl 
2f9d					; skip len 
2f9d 23					inc hl 
2f9e			 
2f9e				if DEBUG_FORTH_WORDS 
2f9e					DMARK "LSc" 
2f9e f5				push af  
2f9f 3a b3 2f			ld a, (.dmark)  
2fa2 32 a0 fd			ld (debug_mark),a  
2fa5 3a b4 2f			ld a, (.dmark+1)  
2fa8 32 a1 fd			ld (debug_mark+1),a  
2fab 3a b5 2f			ld a, (.dmark+2)  
2fae 32 a2 fd			ld (debug_mark+2),a  
2fb1 18 03			jr .pastdmark  
2fb3 ..			.dmark: db "LSc"  
2fb6 f1			.pastdmark: pop af  
2fb7			endm  
# End of macro DMARK
2fb7					CALLMONITOR 
2fb7 cd aa fd			call debug_vector  
2fba				endm  
# End of macro CALLMONITOR
2fba				endif 
2fba			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2fba			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2fba			; Nope that has gone the other way. It needs to be exact not on first zero 
2fba			;		call strcmp 
2fba c5					push bc 
2fbb cd 89 13				call StrictStrCmp 
2fbe c1					pop bc 
2fbf c2 39 2f				jp nz, .ldouscanm 
2fc2				 
2fc2			 
2fc2			 
2fc2					; we have a uword so push its name to the stack 
2fc2			 
2fc2			;	   	push hl  ; save so we can move to next dict block 
2fc2 e1			pop hl 
2fc3			 
2fc3				if DEBUG_FORTH_WORDS 
2fc3					DMARK "LSm" 
2fc3 f5				push af  
2fc4 3a d8 2f			ld a, (.dmark)  
2fc7 32 a0 fd			ld (debug_mark),a  
2fca 3a d9 2f			ld a, (.dmark+1)  
2fcd 32 a1 fd			ld (debug_mark+1),a  
2fd0 3a da 2f			ld a, (.dmark+2)  
2fd3 32 a2 fd			ld (debug_mark+2),a  
2fd6 18 03			jr .pastdmark  
2fd8 ..			.dmark: db "LSm"  
2fdb f1			.pastdmark: pop af  
2fdc			endm  
# End of macro DMARK
2fdc					CALLMONITOR 
2fdc cd aa fd			call debug_vector  
2fdf				endm  
# End of macro CALLMONITOR
2fdf				endif 
2fdf			 
2fdf					; skip opcode 
2fdf 23					inc hl  
2fe0					; skip next ptr 
2fe0 23					inc hl  
2fe1 23					inc hl 
2fe2					; skip len 
2fe2 7e					ld a, (hl)   ; save length to add 
2fe3				if DEBUG_FORTH_WORDS 
2fe3					DMARK "LS2" 
2fe3 f5				push af  
2fe4 3a f8 2f			ld a, (.dmark)  
2fe7 32 a0 fd			ld (debug_mark),a  
2fea 3a f9 2f			ld a, (.dmark+1)  
2fed 32 a1 fd			ld (debug_mark+1),a  
2ff0 3a fa 2f			ld a, (.dmark+2)  
2ff3 32 a2 fd			ld (debug_mark+2),a  
2ff6 18 03			jr .pastdmark  
2ff8 ..			.dmark: db "LS2"  
2ffb f1			.pastdmark: pop af  
2ffc			endm  
# End of macro DMARK
2ffc					CALLMONITOR 
2ffc cd aa fd			call debug_vector  
2fff				endm  
# End of macro CALLMONITOR
2fff				endif 
2fff			 
2fff					; save this location 
2fff				 
2fff e5					push hl 
3000			 
3000 23					inc hl 
3001 11 f8 f0				ld de, scratch+2 
3004 4f					ld c, a 
3005 06 00				ld b, 0 
3007			 
3007				if DEBUG_FORTH_WORDS 
3007					DMARK "LSn" 
3007 f5				push af  
3008 3a 1c 30			ld a, (.dmark)  
300b 32 a0 fd			ld (debug_mark),a  
300e 3a 1d 30			ld a, (.dmark+1)  
3011 32 a1 fd			ld (debug_mark+1),a  
3014 3a 1e 30			ld a, (.dmark+2)  
3017 32 a2 fd			ld (debug_mark+2),a  
301a 18 03			jr .pastdmark  
301c ..			.dmark: db "LSn"  
301f f1			.pastdmark: pop af  
3020			endm  
# End of macro DMARK
3020					CALLMONITOR 
3020 cd aa fd			call debug_vector  
3023				endm  
# End of macro CALLMONITOR
3023				endif 
3023			 
3023					; copy uword name to scratch 
3023			 
3023			;		ldir 
3023			.licplw:	; copy uword name to scratch converting to lower case as we go 
3023 ed a0				ldi 
3025 1b					dec de 
3026 1a					ld a, (de) 
3027 cd 5c 12				call to_lower 
302a 12					ld (de),a 
302b 13					inc de 
302c 3e 00				ld a, 0 
302e b9					cp c 
302f 20 f2				jr nz, .licplw 
3031			 
3031			 
3031			 
3031 1b					dec de 
3032 3e 20				ld a, ' '    ; change null to space 
3034 12					ld (de), a 
3035			 
3035 13					inc de 
3036			 
3036 d5					push de 
3037 c1					pop bc     ; move scratch pointer to end of word name and save it 
3038			 
3038 e1					pop hl 
3039 7e					ld a, (hl) 
303a					;inc hl 
303a					; skip word string 
303a cd de 0f				call addatohl 
303d			 
303d 23					inc hl 
303e			 
303e				if DEBUG_FORTH_WORDS 
303e					DMARK "LS3" 
303e f5				push af  
303f 3a 53 30			ld a, (.dmark)  
3042 32 a0 fd			ld (debug_mark),a  
3045 3a 54 30			ld a, (.dmark+1)  
3048 32 a1 fd			ld (debug_mark+1),a  
304b 3a 55 30			ld a, (.dmark+2)  
304e 32 a2 fd			ld (debug_mark+2),a  
3051 18 03			jr .pastdmark  
3053 ..			.dmark: db "LS3"  
3056 f1			.pastdmark: pop af  
3057			endm  
# End of macro DMARK
3057					CALLMONITOR 
3057 cd aa fd			call debug_vector  
305a				endm  
# End of macro CALLMONITOR
305a				endif 
305a					; should now be at the start of the machine code to setup the eval of the uword 
305a					; now locate the ptr to the string defintion 
305a			 
305a					; skip ld hl, 
305a					; then load the ptr 
305a			; TODO use get from hl ptr 
305a 23					inc hl 
305b 5e					ld e, (hl) 
305c 23					inc hl 
305d 56					ld d, (hl) 
305e eb					ex de, hl 
305f			 
305f			 
305f				if DEBUG_FORTH_WORDS 
305f					DMARK "LSt" 
305f f5				push af  
3060 3a 74 30			ld a, (.dmark)  
3063 32 a0 fd			ld (debug_mark),a  
3066 3a 75 30			ld a, (.dmark+1)  
3069 32 a1 fd			ld (debug_mark+1),a  
306c 3a 76 30			ld a, (.dmark+2)  
306f 32 a2 fd			ld (debug_mark+2),a  
3072 18 03			jr .pastdmark  
3074 ..			.dmark: db "LSt"  
3077 f1			.pastdmark: pop af  
3078			endm  
# End of macro DMARK
3078					CALLMONITOR 
3078 cd aa fd			call debug_vector  
307b				endm  
# End of macro CALLMONITOR
307b				endif 
307b			 
307b			; cant push right now due to tokenised strings  
307b			 
307b			; get the destination of where to copy this definition to. 
307b			 
307b c5					push bc 
307c d1					pop de 
307d			 
307d 7e			.listl:         ld a,(hl) 
307e fe 00				cp 0 
3080 28 09				jr z, .lreplsp     ; replace zero with space 
3082					;cp FORTH_END_BUFFER 
3082 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
3084 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
3086				 
3086					; just copy this char as is then 
3086			 
3086 12					ld (de), a 
3087			 
3087 23			.listnxt:	inc hl 
3088 13					inc de 
3089 18 f2				jr .listl 
308b			 
308b 3e 20		.lreplsp:	ld a,' ' 
308d 12					ld (de), a 
308e 18 f7				jr .listnxt 
3090			 
3090			; close up uword def 
3090			 
3090			.listdone: 
3090 12					ld (de), a 
3091 13					inc de 
3092 3e 00				ld a, 0 
3094 12					ld (de), a 
3095			 
3095			; now have def so clean up and push to stack 
3095			 
3095 21 f6 f0				ld hl, scratch 
3098				if DEBUG_FORTH_WORDS 
3098					DMARK "Ltp" 
3098 f5				push af  
3099 3a ad 30			ld a, (.dmark)  
309c 32 a0 fd			ld (debug_mark),a  
309f 3a ae 30			ld a, (.dmark+1)  
30a2 32 a1 fd			ld (debug_mark+1),a  
30a5 3a af 30			ld a, (.dmark+2)  
30a8 32 a2 fd			ld (debug_mark+2),a  
30ab 18 03			jr .pastdmark  
30ad ..			.dmark: db "Ltp"  
30b0 f1			.pastdmark: pop af  
30b1			endm  
# End of macro DMARK
30b1					CALLMONITOR 
30b1 cd aa fd			call debug_vector  
30b4				endm  
# End of macro CALLMONITOR
30b4				endif 
30b4			 
30b4 18 1f			jr .listpush 
30b6			 
30b6			;.lnuword:	pop hl 
30b6			;		call forth_tok_next 
30b6			;		jp .ldouscan  
30b6			 
30b6			.lunotfound:		  
30b6			 
30b6				if DEBUG_FORTH_WORDS 
30b6					DMARK "LSn" 
30b6 f5				push af  
30b7 3a cb 30			ld a, (.dmark)  
30ba 32 a0 fd			ld (debug_mark),a  
30bd 3a cc 30			ld a, (.dmark+1)  
30c0 32 a1 fd			ld (debug_mark+1),a  
30c3 3a cd 30			ld a, (.dmark+2)  
30c6 32 a2 fd			ld (debug_mark+2),a  
30c9 18 03			jr .pastdmark  
30cb ..			.dmark: db "LSn"  
30ce f1			.pastdmark: pop af  
30cf			endm  
# End of macro DMARK
30cf					CALLMONITOR 
30cf cd aa fd			call debug_vector  
30d2				endm  
# End of macro CALLMONITOR
30d2				endif 
30d2			 
30d2					 
30d2			;		FORTH_DSP_POP 
30d2			;		ld hl, .luno 
30d2			 
30d2					NEXTW			 
30d2 c3 38 24			jp macro_next 
30d5				endm 
# End of macro NEXTW
30d5			 
30d5			.listpush: 
30d5				if DEBUG_FORTH_WORDS 
30d5					DMARK "LS>" 
30d5 f5				push af  
30d6 3a ea 30			ld a, (.dmark)  
30d9 32 a0 fd			ld (debug_mark),a  
30dc 3a eb 30			ld a, (.dmark+1)  
30df 32 a1 fd			ld (debug_mark+1),a  
30e2 3a ec 30			ld a, (.dmark+2)  
30e5 32 a2 fd			ld (debug_mark+2),a  
30e8 18 03			jr .pastdmark  
30ea ..			.dmark: db "LS>"  
30ed f1			.pastdmark: pop af  
30ee			endm  
# End of macro DMARK
30ee					CALLMONITOR 
30ee cd aa fd			call debug_vector  
30f1				endm  
# End of macro CALLMONITOR
30f1				endif 
30f1 cd b6 20				call forth_push_str 
30f4			 
30f4			 
30f4			 
30f4					NEXTW 
30f4 c3 38 24			jp macro_next 
30f7				endm 
# End of macro NEXTW
30f7			 
30f7			;.luno:    db "Word not found",0 
30f7			 
30f7			 
30f7			 
30f7			 
30f7			 
30f7			;		push hl   ; save pointer to start of uword def string 
30f7			; 
30f7			;; look for FORTH_EOL_LINE 
30f7			;		ld a, FORTH_END_BUFFER 
30f7			;		call strlent 
30f7			; 
30f7			;		inc hl		 ; space for coln def 
30f7			;		inc hl 
30f7			;		inc hl          ; space for terms 
30f7			;		inc hl 
30f7			; 
30f7			;		ld a, 20   ; TODO get actual length 
30f7			;		call addatohl    ; include a random amount of room for the uword name 
30f7			; 
30f7			;		 
30f7			;	if DEBUG_FORTH_WORDS 
30f7			;		DMARK "Lt1" 
30f7			;		CALLMONITOR 
30f7			;	endif 
30f7			;		 
30f7			; 
30f7			;; malloc space for the string because we cant change it 
30f7			; 
30f7			;		call malloc 
30f7			;	if DEBUG_FORTH_MALLOC_GUARD 
30f7			;		push af 
30f7			;		call ishlzero 
30f7			;		pop af 
30f7			;		 
30f7			;		call z,malloc_error 
30f7			;	endif 
30f7			; 
30f7			;	if DEBUG_FORTH_WORDS 
30f7			;		DMARK "Lt2" 
30f7			;		CALLMONITOR 
30f7			;	endif 
30f7			;		pop de 
30f7			;		push hl    ; push the malloc to release later 
30f7			;		push hl   ;  push back a copy for the later stack push 
30f7			;		 
30f7			;; copy the string swapping out the zero terms for spaces 
30f7			; 
30f7			;		; de has our source 
30f7			;		; hl has our dest 
30f7			; 
30f7			;; add the coln def 
30f7			; 
30f7			;		ld a, ':' 
30f7			;		ld (hl), a 
30f7			;		inc hl 
30f7			;		ld a, ' ' 
30f7			;		ld (hl), a 
30f7			;		inc hl 
30f7			; 
30f7			;; add the uname word 
30f7			;		push de   ; save our string for now 
30f7			;		ex de, hl 
30f7			; 
30f7			;		FORTH_DSP_VALUE 
30f7			;		;v5 FORTH_DSP_VALUE 
30f7			; 
30f7			;		inc hl   ; skip type but we know by now this is OK 
30f7			; 
30f7			;.luword:	ld a,(hl) 
30f7			;		cp 0 
30f7			;		jr z, .luword2 
30f7			;		ld (de), a 
30f7			;		inc de 
30f7			;		inc hl 
30f7			;		jr .luword 
30f7			; 
30f7			;.luword2:	ld a, ' ' 
30f7			;		ld (de), a 
30f7			;;		inc hl 
30f7			;;		inc de 
30f7			;;		ld (de), a 
30f7			;;		inc hl 
30f7			;		inc de 
30f7			; 
30f7			;		ex de, hl 
30f7			;		pop de 
30f7			;		 
30f7			;		 
30f7			; 
30f7			;; detoken that string and copy it 
30f7			; 
30f7			;	if DEBUG_FORTH_WORDS 
30f7			;		DMARK "Lt2" 
30f7			;		CALLMONITOR 
30f7			;	endif 
30f7			;.ldetok:	ld a, (de) 
30f7			;		cp FORTH_END_BUFFER 
30f7			;		jr z, .ldetokend 
30f7			;		; swap out any zero term for space 
30f7			;		cp 0 
30f7			;		jr nz, .ldetoknext 
30f7			;		ld a, ' ' 
30f7			; 
30f7			;	if DEBUG_FORTH_WORDS 
30f7			;		DMARK "LtS" 
30f7			;		CALLMONITOR 
30f7			;	endif 
30f7			;.ldetoknext:	ld (hl), a 
30f7			;		inc de 
30f7			;		inc hl 
30f7			;		jr .ldetok 
30f7			; 
30f7			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
30f7			;		ld (hl), a  
30f7			; 
30f7			;; free that temp malloc 
30f7			; 
30f7			;		pop hl    
30f7			; 
30f7			;	if DEBUG_FORTH_WORDS 
30f7			;		DMARK "Lt4" 
30f7			;		CALLMONITOR 
30f7			;	endif 
30f7			;		call forth_apushstrhl 
30f7			; 
30f7			;		; get rid of temp malloc area 
30f7			; 
30f7			;		pop hl 
30f7			;		call free 
30f7			; 
30f7			;		jr .ludone 
30f7			; 
30f7			;.lnuword:	pop hl 
30f7			;		call forth_tok_next 
30f7			;		jp .ldouscan  
30f7			; 
30f7			;.ludone:		 pop hl 
30f7			; 
30f7					NEXTW 
30f7 c3 38 24			jp macro_next 
30fa				endm 
# End of macro NEXTW
30fa			 
30fa			.FORGET: 
30fa				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
30fa 5d				db WORD_SYS_CORE+73             
30fb 73 31			dw .NOP            
30fd 07				db 6 + 1 
30fe .. 00			db "FORGET",0              
3105				endm 
# End of macro CWHEAD
3105			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
3105			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
3105			; | |  
3105			; | | e.g. "MORE" forget 
3105					if DEBUG_FORTH_WORDS_KEY 
3105						DMARK "FRG" 
3105 f5				push af  
3106 3a 1a 31			ld a, (.dmark)  
3109 32 a0 fd			ld (debug_mark),a  
310c 3a 1b 31			ld a, (.dmark+1)  
310f 32 a1 fd			ld (debug_mark+1),a  
3112 3a 1c 31			ld a, (.dmark+2)  
3115 32 a2 fd			ld (debug_mark+2),a  
3118 18 03			jr .pastdmark  
311a ..			.dmark: db "FRG"  
311d f1			.pastdmark: pop af  
311e			endm  
# End of macro DMARK
311e						CALLMONITOR 
311e cd aa fd			call debug_vector  
3121				endm  
# End of macro CALLMONITOR
3121					endif 
3121			 
3121				; find uword 
3121			        ; update start of word with "_" 
3121				; replace uword with deleted flag 
3121			 
3121			 
3121			;	if DEBUG_FORTH_WORDS 
3121			;		DMARK "FOG" 
3121			;		CALLMONITOR 
3121			;	endif 
3121			 
3121			 
3121					; Get ptr to the word we need to look up 
3121			 
3121					FORTH_DSP_VALUEHL 
3121 cd 4d 22			call macro_dsp_valuehl 
3124				endm 
# End of macro FORTH_DSP_VALUEHL
3124					;v5 FORTH_DSP_VALUE 
3124				; TODO type check 
3124			;		inc hl    ; Skip type check  
3124 e5					push hl 
3125 c1					pop bc 
3126			;		ex de, hl    ; put into DE 
3126			 
3126			 
3126 21 00 80				ld hl, baseram 
3129					;ld hl, baseusermem 
3129			 
3129				; skip dict stub 
3129			;	call forth_tok_next 
3129 e5			push hl   ; sacreifical push 
312a			 
312a			.fldouscanm: 
312a e1				pop hl 
312b			.fldouscan: 
312b			;	if DEBUG_FORTH_WORDS 
312b			;		DMARK "LSs" 
312b			;		CALLMONITOR 
312b			;	endif 
312b				; skip dict stub 
312b cd 75 25				call forth_tok_next 
312e			 
312e			 
312e			; while we have words to look for 
312e			 
312e 7e				ld a, (hl)      
312f			;	if DEBUG_FORTH_WORDS 
312f			;		DMARK "LSk" 
312f			;		CALLMONITOR 
312f			;	endif 
312f fe 00				cp WORD_SYS_END 
3131 ca 6d 31				jp z, .flunotfound 
3134 fe 01				cp WORD_SYS_UWORD 
3136 c2 2b 31				jp nz, .fldouscan 
3139			 
3139			;	if DEBUG_FORTH_WORDS 
3139			;		DMARK "LSu" 
3139			;		CALLMONITOR 
3139			;	endif 
3139			 
3139					; found a uword but is it the one we want... 
3139			 
3139 c5					push bc     ; uword to find is on bc 
313a d1					pop de 
313b			 
313b e5					push hl  ; to save the ptr 
313c			 
313c					; skip opcode 
313c 23					inc hl  
313d					; skip next ptr 
313d 23					inc hl  
313e 23					inc hl 
313f					; skip len 
313f 23					inc hl 
3140			 
3140			;	if DEBUG_FORTH_WORDS 
3140			;		DMARK "LSc" 
3140			;		CALLMONITOR 
3140			;	endif 
3140 cd 7c 13				call strcmp 
3143 c2 2a 31				jp nz, .fldouscanm 
3146			; 
3146			; 
3146			;; while we have words to look for 
3146			; 
3146			;.fdouscan:	ld a, (hl)      
3146			;	if DEBUG_FORTH_WORDS 
3146			;		DMARK "LSs" 
3146			;		CALLMONITOR 
3146			;	endif 
3146			;		cp WORD_SYS_END 
3146			;		jp z, .fudone 
3146			;		cp WORD_SYS_UWORD 
3146			;		jp nz, .fnuword 
3146			; 
3146			;	if DEBUG_FORTH_WORDS 
3146			;		DMARK "FGu" 
3146			;		CALLMONITOR 
3146			;	endif 
3146			; 
3146			;		; found a uword but is it the one we want... 
3146			; 
3146			; 
3146			;	        pop de   ; get back the dsp name 
3146			;		push de 
3146			; 
3146			;		push hl  ; to save the ptr 
3146			; 
3146			;		; skip opcode 
3146			;		inc hl  
3146			;		; skip next ptr 
3146			;		inc hl  
3146			;		inc hl 
3146			;		; skip len 
3146			;		inc hl 
3146			; 
3146			;	if DEBUG_FORTH_WORDS 
3146			;		DMARK "FGc" 
3146			;		CALLMONITOR 
3146			;	endif 
3146			;		call strcmp 
3146			;		jp nz, .fnuword 
3146			 
3146			 
3146 e1			pop hl 
3147			 
3147				 
3147				if DEBUG_FORTH_WORDS 
3147					DMARK "FGm" 
3147 f5				push af  
3148 3a 5c 31			ld a, (.dmark)  
314b 32 a0 fd			ld (debug_mark),a  
314e 3a 5d 31			ld a, (.dmark+1)  
3151 32 a1 fd			ld (debug_mark+1),a  
3154 3a 5e 31			ld a, (.dmark+2)  
3157 32 a2 fd			ld (debug_mark+2),a  
315a 18 03			jr .pastdmark  
315c ..			.dmark: db "FGm"  
315f f1			.pastdmark: pop af  
3160			endm  
# End of macro DMARK
3160					CALLMONITOR 
3160 cd aa fd			call debug_vector  
3163				endm  
# End of macro CALLMONITOR
3163				endif 
3163			 
3163			 
3163			 
3163					; we have a uword so push its name to the stack 
3163			 
3163			;	   	push hl  ; save so we can move to next dict block 
3163			;pop hl 
3163			 
3163					; update opcode to deleted 
3163 3e 03				ld a, WORD_SYS_DELETED 
3165 77					ld (hl), a 
3166			 
3166 23					inc hl  
3167					; skip next ptr 
3167 23					inc hl  
3168 23					inc hl 
3169					; skip len 
3169 23					inc hl 
316a			 
316a					; TODO change parser to skip deleted words but for now mark it out 
316a 3e 5f				ld a, "_" 
316c 77					ld  (hl),a 
316d			 
316d			;		jr .fudone 
316d			; 
316d			;.fnuword:	pop hl 
316d			;		call forth_tok_next 
316d			;		jp .fdouscan  
316d			 
316d			.flunotfound:		  
316d			 
316d			 
316d					 
316d					FORTH_DSP_POP 
316d cd 05 23			call macro_forth_dsp_pop 
3170				endm 
# End of macro FORTH_DSP_POP
3170			;		ld hl, .luno 
3170			;.fudone:		 pop hl 
3170					NEXTW 
3170 c3 38 24			jp macro_next 
3173				endm 
# End of macro NEXTW
3173			.NOP: 
3173				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3173 61				db WORD_SYS_CORE+77             
3174 9a 31			dw .COMO            
3176 04				db 3 + 1 
3177 .. 00			db "NOP",0              
317b				endm 
# End of macro CWHEAD
317b			; | NOP (  --  ) Do nothing | DONE 
317b					if DEBUG_FORTH_WORDS_KEY 
317b						DMARK "NOP" 
317b f5				push af  
317c 3a 90 31			ld a, (.dmark)  
317f 32 a0 fd			ld (debug_mark),a  
3182 3a 91 31			ld a, (.dmark+1)  
3185 32 a1 fd			ld (debug_mark+1),a  
3188 3a 92 31			ld a, (.dmark+2)  
318b 32 a2 fd			ld (debug_mark+2),a  
318e 18 03			jr .pastdmark  
3190 ..			.dmark: db "NOP"  
3193 f1			.pastdmark: pop af  
3194			endm  
# End of macro DMARK
3194						CALLMONITOR 
3194 cd aa fd			call debug_vector  
3197				endm  
# End of macro CALLMONITOR
3197					endif 
3197				       NEXTW 
3197 c3 38 24			jp macro_next 
319a				endm 
# End of macro NEXTW
319a			.COMO: 
319a				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
319a 6e				db WORD_SYS_CORE+90             
319b ec 31			dw .COMC            
319d 02				db 1 + 1 
319e .. 00			db "(",0              
31a0				endm 
# End of macro CWHEAD
31a0			; | ( ( -- )  Start of comment | DONE 
31a0			 
31a0			 
31a0 2a f7 f3				ld hl, ( os_tok_ptr) 
31a3 11 e7 31			ld de, .closepar 
31a6					 
31a6					if DEBUG_FORTH_WORDS 
31a6						DMARK ").." 
31a6 f5				push af  
31a7 3a bb 31			ld a, (.dmark)  
31aa 32 a0 fd			ld (debug_mark),a  
31ad 3a bc 31			ld a, (.dmark+1)  
31b0 32 a1 fd			ld (debug_mark+1),a  
31b3 3a bd 31			ld a, (.dmark+2)  
31b6 32 a2 fd			ld (debug_mark+2),a  
31b9 18 03			jr .pastdmark  
31bb ..			.dmark: db ").."  
31be f1			.pastdmark: pop af  
31bf			endm  
# End of macro DMARK
31bf						CALLMONITOR 
31bf cd aa fd			call debug_vector  
31c2				endm  
# End of macro CALLMONITOR
31c2					endif 
31c2 cd 3f 25			call findnexttok  
31c5			 
31c5					if DEBUG_FORTH_WORDS 
31c5						DMARK "IF5" 
31c5 f5				push af  
31c6 3a da 31			ld a, (.dmark)  
31c9 32 a0 fd			ld (debug_mark),a  
31cc 3a db 31			ld a, (.dmark+1)  
31cf 32 a1 fd			ld (debug_mark+1),a  
31d2 3a dc 31			ld a, (.dmark+2)  
31d5 32 a2 fd			ld (debug_mark+2),a  
31d8 18 03			jr .pastdmark  
31da ..			.dmark: db "IF5"  
31dd f1			.pastdmark: pop af  
31de			endm  
# End of macro DMARK
31de						CALLMONITOR 
31de cd aa fd			call debug_vector  
31e1				endm  
# End of macro CALLMONITOR
31e1					endif 
31e1				; replace below with ) exec using tok_ptr 
31e1 22 f7 f3			ld (os_tok_ptr), hl 
31e4 c3 c1 24			jp exec1 
31e7			 
31e7 .. 00			.closepar:   db ")",0 
31e9			 
31e9				       NEXTW 
31e9 c3 38 24			jp macro_next 
31ec				endm 
# End of macro NEXTW
31ec			.COMC: 
31ec				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
31ec 6f				db WORD_SYS_CORE+91             
31ed f5 31			dw .SCRATCH            
31ef 02				db 1 + 1 
31f0 .. 00			db ")",0              
31f2				endm 
# End of macro CWHEAD
31f2			; | ) ( -- )  End of comment |  DONE  
31f2				       NEXTW 
31f2 c3 38 24			jp macro_next 
31f5				endm 
# End of macro NEXTW
31f5			 
31f5			.SCRATCH: 
31f5				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
31f5 6f				db WORD_SYS_CORE+91             
31f6 30 32			dw .INC            
31f8 08				db 7 + 1 
31f9 .. 00			db "SCRATCH",0              
3201				endm 
# End of macro CWHEAD
3201			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3201			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3201			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3201			; | |  
3201			; | | e.g.    : score $00 scratch ; 
3201			; | |  
3201			; | | $00 score ! 
3201			; | | $01 score +! 
3201			; | |  
3201			; | | e.g.   : varword $0a scratch ;  
3201			; | | 
3201			; | | $8000 varword ! 
3201					if DEBUG_FORTH_WORDS_KEY 
3201						DMARK "SCR" 
3201 f5				push af  
3202 3a 16 32			ld a, (.dmark)  
3205 32 a0 fd			ld (debug_mark),a  
3208 3a 17 32			ld a, (.dmark+1)  
320b 32 a1 fd			ld (debug_mark+1),a  
320e 3a 18 32			ld a, (.dmark+2)  
3211 32 a2 fd			ld (debug_mark+2),a  
3214 18 03			jr .pastdmark  
3216 ..			.dmark: db "SCR"  
3219 f1			.pastdmark: pop af  
321a			endm  
# End of macro DMARK
321a						CALLMONITOR 
321a cd aa fd			call debug_vector  
321d				endm  
# End of macro CALLMONITOR
321d					endif 
321d			 
321d					FORTH_DSP_VALUEHL 
321d cd 4d 22			call macro_dsp_valuehl 
3220				endm 
# End of macro FORTH_DSP_VALUEHL
3220				 
3220					FORTH_DSP_POP 
3220 cd 05 23			call macro_forth_dsp_pop 
3223				endm 
# End of macro FORTH_DSP_POP
3223			 
3223 7d					ld a, l 
3224 21 1b f6				ld hl, os_var_array 
3227 cd de 0f				call addatohl 
322a			 
322a cd 48 20				call forth_push_numhl 
322d			 
322d				       NEXTW 
322d c3 38 24			jp macro_next 
3230				endm 
# End of macro NEXTW
3230			 
3230			.INC: 
3230				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3230 6f				db WORD_SYS_CORE+91             
3231 86 32			dw .DEC            
3233 03				db 2 + 1 
3234 .. 00			db "+!",0              
3237				endm 
# End of macro CWHEAD
3237			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3237					if DEBUG_FORTH_WORDS_KEY 
3237						DMARK "+s_" 
3237 f5				push af  
3238 3a 4c 32			ld a, (.dmark)  
323b 32 a0 fd			ld (debug_mark),a  
323e 3a 4d 32			ld a, (.dmark+1)  
3241 32 a1 fd			ld (debug_mark+1),a  
3244 3a 4e 32			ld a, (.dmark+2)  
3247 32 a2 fd			ld (debug_mark+2),a  
324a 18 03			jr .pastdmark  
324c ..			.dmark: db "+s_"  
324f f1			.pastdmark: pop af  
3250			endm  
# End of macro DMARK
3250						CALLMONITOR 
3250 cd aa fd			call debug_vector  
3253				endm  
# End of macro CALLMONITOR
3253					endif 
3253			 
3253					FORTH_DSP_VALUEHL 
3253 cd 4d 22			call macro_dsp_valuehl 
3256				endm 
# End of macro FORTH_DSP_VALUEHL
3256			 
3256 e5					push hl   ; save address 
3257			 
3257					FORTH_DSP_POP 
3257 cd 05 23			call macro_forth_dsp_pop 
325a				endm 
# End of macro FORTH_DSP_POP
325a			 
325a					FORTH_DSP_VALUEHL 
325a cd 4d 22			call macro_dsp_valuehl 
325d				endm 
# End of macro FORTH_DSP_VALUEHL
325d			 
325d e5					push hl 
325e					FORTH_DSP_POP 
325e cd 05 23			call macro_forth_dsp_pop 
3261				endm 
# End of macro FORTH_DSP_POP
3261 e1					pop hl 
3262			 
3262					; hl contains value to add to byte at a 
3262				 
3262 eb					ex de, hl 
3263			 
3263 e1					pop hl 
3264			 
3264					if DEBUG_FORTH_WORDS 
3264						DMARK "INC" 
3264 f5				push af  
3265 3a 79 32			ld a, (.dmark)  
3268 32 a0 fd			ld (debug_mark),a  
326b 3a 7a 32			ld a, (.dmark+1)  
326e 32 a1 fd			ld (debug_mark+1),a  
3271 3a 7b 32			ld a, (.dmark+2)  
3274 32 a2 fd			ld (debug_mark+2),a  
3277 18 03			jr .pastdmark  
3279 ..			.dmark: db "INC"  
327c f1			.pastdmark: pop af  
327d			endm  
# End of macro DMARK
327d						CALLMONITOR 
327d cd aa fd			call debug_vector  
3280				endm  
# End of macro CALLMONITOR
3280					endif 
3280			 
3280 7e					ld a,(hl) 
3281 83					add e 
3282 77					ld (hl),a 
3283			 
3283			 
3283			 
3283				       NEXTW 
3283 c3 38 24			jp macro_next 
3286				endm 
# End of macro NEXTW
3286			 
3286			.DEC: 
3286				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3286 6f				db WORD_SYS_CORE+91             
3287 da 32			dw .INC2            
3289 03				db 2 + 1 
328a .. 00			db "-!",0              
328d				endm 
# End of macro CWHEAD
328d			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
328d					if DEBUG_FORTH_WORDS_KEY 
328d						DMARK "-s_" 
328d f5				push af  
328e 3a a2 32			ld a, (.dmark)  
3291 32 a0 fd			ld (debug_mark),a  
3294 3a a3 32			ld a, (.dmark+1)  
3297 32 a1 fd			ld (debug_mark+1),a  
329a 3a a4 32			ld a, (.dmark+2)  
329d 32 a2 fd			ld (debug_mark+2),a  
32a0 18 03			jr .pastdmark  
32a2 ..			.dmark: db "-s_"  
32a5 f1			.pastdmark: pop af  
32a6			endm  
# End of macro DMARK
32a6						CALLMONITOR 
32a6 cd aa fd			call debug_vector  
32a9				endm  
# End of macro CALLMONITOR
32a9					endif 
32a9			 
32a9					FORTH_DSP_VALUEHL 
32a9 cd 4d 22			call macro_dsp_valuehl 
32ac				endm 
# End of macro FORTH_DSP_VALUEHL
32ac			 
32ac e5					push hl   ; save address 
32ad			 
32ad					FORTH_DSP_POP 
32ad cd 05 23			call macro_forth_dsp_pop 
32b0				endm 
# End of macro FORTH_DSP_POP
32b0			 
32b0					FORTH_DSP_VALUEHL 
32b0 cd 4d 22			call macro_dsp_valuehl 
32b3				endm 
# End of macro FORTH_DSP_VALUEHL
32b3			 
32b3					; hl contains value to add to byte at a 
32b3				 
32b3 eb					ex de, hl 
32b4			 
32b4 e1					pop hl 
32b5			 
32b5					if DEBUG_FORTH_WORDS 
32b5						DMARK "DEC" 
32b5 f5				push af  
32b6 3a ca 32			ld a, (.dmark)  
32b9 32 a0 fd			ld (debug_mark),a  
32bc 3a cb 32			ld a, (.dmark+1)  
32bf 32 a1 fd			ld (debug_mark+1),a  
32c2 3a cc 32			ld a, (.dmark+2)  
32c5 32 a2 fd			ld (debug_mark+2),a  
32c8 18 03			jr .pastdmark  
32ca ..			.dmark: db "DEC"  
32cd f1			.pastdmark: pop af  
32ce			endm  
# End of macro DMARK
32ce						CALLMONITOR 
32ce cd aa fd			call debug_vector  
32d1				endm  
# End of macro CALLMONITOR
32d1					endif 
32d1			 
32d1 7e					ld a,(hl) 
32d2 93					sub e 
32d3 77					ld (hl),a 
32d4			 
32d4			 
32d4					FORTH_DSP_POP 
32d4 cd 05 23			call macro_forth_dsp_pop 
32d7				endm 
# End of macro FORTH_DSP_POP
32d7			 
32d7				       NEXTW 
32d7 c3 38 24			jp macro_next 
32da				endm 
# End of macro NEXTW
32da			 
32da			.INC2: 
32da				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
32da 6f				db WORD_SYS_CORE+91             
32db 87 33			dw .DEC2            
32dd 04				db 3 + 1 
32de .. 00			db "+2!",0              
32e2				endm 
# End of macro CWHEAD
32e2			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
32e2			 
32e2					if DEBUG_FORTH_WORDS_KEY 
32e2						DMARK "+2s" 
32e2 f5				push af  
32e3 3a f7 32			ld a, (.dmark)  
32e6 32 a0 fd			ld (debug_mark),a  
32e9 3a f8 32			ld a, (.dmark+1)  
32ec 32 a1 fd			ld (debug_mark+1),a  
32ef 3a f9 32			ld a, (.dmark+2)  
32f2 32 a2 fd			ld (debug_mark+2),a  
32f5 18 03			jr .pastdmark  
32f7 ..			.dmark: db "+2s"  
32fa f1			.pastdmark: pop af  
32fb			endm  
# End of macro DMARK
32fb						CALLMONITOR 
32fb cd aa fd			call debug_vector  
32fe				endm  
# End of macro CALLMONITOR
32fe					endif 
32fe			 
32fe					; Address 
32fe			 
32fe					FORTH_DSP_VALUEHL 
32fe cd 4d 22			call macro_dsp_valuehl 
3301				endm 
# End of macro FORTH_DSP_VALUEHL
3301			 
3301 e5					push hl    ; save address 
3302			 
3302					; load content into de 
3302			 
3302 5e					ld e,(hl) 
3303 23					inc hl 
3304 56					ld d, (hl) 
3305			 
3305					if DEBUG_FORTH_WORDS 
3305						DMARK "+2a" 
3305 f5				push af  
3306 3a 1a 33			ld a, (.dmark)  
3309 32 a0 fd			ld (debug_mark),a  
330c 3a 1b 33			ld a, (.dmark+1)  
330f 32 a1 fd			ld (debug_mark+1),a  
3312 3a 1c 33			ld a, (.dmark+2)  
3315 32 a2 fd			ld (debug_mark+2),a  
3318 18 03			jr .pastdmark  
331a ..			.dmark: db "+2a"  
331d f1			.pastdmark: pop af  
331e			endm  
# End of macro DMARK
331e						CALLMONITOR 
331e cd aa fd			call debug_vector  
3321				endm  
# End of macro CALLMONITOR
3321					endif 
3321			 
3321					FORTH_DSP_POP 
3321 cd 05 23			call macro_forth_dsp_pop 
3324				endm 
# End of macro FORTH_DSP_POP
3324			 
3324					; Get value to add 
3324			 
3324					FORTH_DSP_VALUE 
3324 cd 36 22			call macro_forth_dsp_value 
3327				endm 
# End of macro FORTH_DSP_VALUE
3327			 
3327					if DEBUG_FORTH_WORDS 
3327						DMARK "+2v" 
3327 f5				push af  
3328 3a 3c 33			ld a, (.dmark)  
332b 32 a0 fd			ld (debug_mark),a  
332e 3a 3d 33			ld a, (.dmark+1)  
3331 32 a1 fd			ld (debug_mark+1),a  
3334 3a 3e 33			ld a, (.dmark+2)  
3337 32 a2 fd			ld (debug_mark+2),a  
333a 18 03			jr .pastdmark  
333c ..			.dmark: db "+2v"  
333f f1			.pastdmark: pop af  
3340			endm  
# End of macro DMARK
3340						CALLMONITOR 
3340 cd aa fd			call debug_vector  
3343				endm  
# End of macro CALLMONITOR
3343					endif 
3343			 
3343 19					add hl, de 
3344			 
3344					if DEBUG_FORTH_WORDS 
3344						DMARK "+2+" 
3344 f5				push af  
3345 3a 59 33			ld a, (.dmark)  
3348 32 a0 fd			ld (debug_mark),a  
334b 3a 5a 33			ld a, (.dmark+1)  
334e 32 a1 fd			ld (debug_mark+1),a  
3351 3a 5b 33			ld a, (.dmark+2)  
3354 32 a2 fd			ld (debug_mark+2),a  
3357 18 03			jr .pastdmark  
3359 ..			.dmark: db "+2+"  
335c f1			.pastdmark: pop af  
335d			endm  
# End of macro DMARK
335d						CALLMONITOR 
335d cd aa fd			call debug_vector  
3360				endm  
# End of macro CALLMONITOR
3360					endif 
3360			 
3360					; move result to de 
3360			 
3360 eb					ex de, hl 
3361			 
3361					; Address 
3361			 
3361 e1					pop hl 
3362			 
3362					; save it back 
3362			 
3362 73					ld (hl), e 
3363 23					inc hl 
3364 72					ld (hl), d 
3365			 
3365					if DEBUG_FORTH_WORDS 
3365						DMARK "+2e" 
3365 f5				push af  
3366 3a 7a 33			ld a, (.dmark)  
3369 32 a0 fd			ld (debug_mark),a  
336c 3a 7b 33			ld a, (.dmark+1)  
336f 32 a1 fd			ld (debug_mark+1),a  
3372 3a 7c 33			ld a, (.dmark+2)  
3375 32 a2 fd			ld (debug_mark+2),a  
3378 18 03			jr .pastdmark  
337a ..			.dmark: db "+2e"  
337d f1			.pastdmark: pop af  
337e			endm  
# End of macro DMARK
337e						CALLMONITOR 
337e cd aa fd			call debug_vector  
3381				endm  
# End of macro CALLMONITOR
3381					endif 
3381			 
3381			 
3381			 
3381					FORTH_DSP_POP 
3381 cd 05 23			call macro_forth_dsp_pop 
3384				endm 
# End of macro FORTH_DSP_POP
3384			 
3384			 
3384				       NEXTW 
3384 c3 38 24			jp macro_next 
3387				endm 
# End of macro NEXTW
3387			 
3387			.DEC2: 
3387				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3387 6f				db WORD_SYS_CORE+91             
3388 36 34			dw .GET2            
338a 04				db 3 + 1 
338b .. 00			db "-2!",0              
338f				endm 
# End of macro CWHEAD
338f			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
338f			 
338f			 
338f					if DEBUG_FORTH_WORDS_KEY 
338f						DMARK "-2s" 
338f f5				push af  
3390 3a a4 33			ld a, (.dmark)  
3393 32 a0 fd			ld (debug_mark),a  
3396 3a a5 33			ld a, (.dmark+1)  
3399 32 a1 fd			ld (debug_mark+1),a  
339c 3a a6 33			ld a, (.dmark+2)  
339f 32 a2 fd			ld (debug_mark+2),a  
33a2 18 03			jr .pastdmark  
33a4 ..			.dmark: db "-2s"  
33a7 f1			.pastdmark: pop af  
33a8			endm  
# End of macro DMARK
33a8						CALLMONITOR 
33a8 cd aa fd			call debug_vector  
33ab				endm  
# End of macro CALLMONITOR
33ab					endif 
33ab			 
33ab					; Address 
33ab			 
33ab					FORTH_DSP_VALUEHL 
33ab cd 4d 22			call macro_dsp_valuehl 
33ae				endm 
# End of macro FORTH_DSP_VALUEHL
33ae			 
33ae e5					push hl    ; save address 
33af			 
33af					; load content into de 
33af			 
33af 5e					ld e,(hl) 
33b0 23					inc hl 
33b1 56					ld d, (hl) 
33b2			 
33b2					if DEBUG_FORTH_WORDS 
33b2						DMARK "-2a" 
33b2 f5				push af  
33b3 3a c7 33			ld a, (.dmark)  
33b6 32 a0 fd			ld (debug_mark),a  
33b9 3a c8 33			ld a, (.dmark+1)  
33bc 32 a1 fd			ld (debug_mark+1),a  
33bf 3a c9 33			ld a, (.dmark+2)  
33c2 32 a2 fd			ld (debug_mark+2),a  
33c5 18 03			jr .pastdmark  
33c7 ..			.dmark: db "-2a"  
33ca f1			.pastdmark: pop af  
33cb			endm  
# End of macro DMARK
33cb						CALLMONITOR 
33cb cd aa fd			call debug_vector  
33ce				endm  
# End of macro CALLMONITOR
33ce					endif 
33ce			 
33ce					FORTH_DSP_POP 
33ce cd 05 23			call macro_forth_dsp_pop 
33d1				endm 
# End of macro FORTH_DSP_POP
33d1			 
33d1					; Get value to remove 
33d1			 
33d1					FORTH_DSP_VALUE 
33d1 cd 36 22			call macro_forth_dsp_value 
33d4				endm 
# End of macro FORTH_DSP_VALUE
33d4			 
33d4					if DEBUG_FORTH_WORDS 
33d4						DMARK "-2v" 
33d4 f5				push af  
33d5 3a e9 33			ld a, (.dmark)  
33d8 32 a0 fd			ld (debug_mark),a  
33db 3a ea 33			ld a, (.dmark+1)  
33de 32 a1 fd			ld (debug_mark+1),a  
33e1 3a eb 33			ld a, (.dmark+2)  
33e4 32 a2 fd			ld (debug_mark+2),a  
33e7 18 03			jr .pastdmark  
33e9 ..			.dmark: db "-2v"  
33ec f1			.pastdmark: pop af  
33ed			endm  
# End of macro DMARK
33ed						CALLMONITOR 
33ed cd aa fd			call debug_vector  
33f0				endm  
# End of macro CALLMONITOR
33f0					endif 
33f0			 
33f0 eb					ex de, hl 
33f1 ed 52				sbc hl, de 
33f3			 
33f3					if DEBUG_FORTH_WORDS 
33f3						DMARK "-2d" 
33f3 f5				push af  
33f4 3a 08 34			ld a, (.dmark)  
33f7 32 a0 fd			ld (debug_mark),a  
33fa 3a 09 34			ld a, (.dmark+1)  
33fd 32 a1 fd			ld (debug_mark+1),a  
3400 3a 0a 34			ld a, (.dmark+2)  
3403 32 a2 fd			ld (debug_mark+2),a  
3406 18 03			jr .pastdmark  
3408 ..			.dmark: db "-2d"  
340b f1			.pastdmark: pop af  
340c			endm  
# End of macro DMARK
340c						CALLMONITOR 
340c cd aa fd			call debug_vector  
340f				endm  
# End of macro CALLMONITOR
340f					endif 
340f			 
340f					; move result to de 
340f			 
340f eb					ex de, hl 
3410			 
3410					; Address 
3410			 
3410 e1					pop hl 
3411			 
3411					; save it back 
3411			 
3411 73					ld (hl), e 
3412 23					inc hl 
3413 72					ld (hl), d 
3414			 
3414					if DEBUG_FORTH_WORDS 
3414						DMARK "-2e" 
3414 f5				push af  
3415 3a 29 34			ld a, (.dmark)  
3418 32 a0 fd			ld (debug_mark),a  
341b 3a 2a 34			ld a, (.dmark+1)  
341e 32 a1 fd			ld (debug_mark+1),a  
3421 3a 2b 34			ld a, (.dmark+2)  
3424 32 a2 fd			ld (debug_mark+2),a  
3427 18 03			jr .pastdmark  
3429 ..			.dmark: db "-2e"  
342c f1			.pastdmark: pop af  
342d			endm  
# End of macro DMARK
342d						CALLMONITOR 
342d cd aa fd			call debug_vector  
3430				endm  
# End of macro CALLMONITOR
3430					endif 
3430			 
3430			 
3430					FORTH_DSP_POP 
3430 cd 05 23			call macro_forth_dsp_pop 
3433				endm 
# End of macro FORTH_DSP_POP
3433			 
3433			 
3433			 
3433				       NEXTW 
3433 c3 38 24			jp macro_next 
3436				endm 
# End of macro NEXTW
3436			.GET2: 
3436				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3436 6f				db WORD_SYS_CORE+91             
3437 6b 34			dw .BANG2            
3439 03				db 2 + 1 
343a .. 00			db "2@",0              
343d				endm 
# End of macro CWHEAD
343d			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
343d					if DEBUG_FORTH_WORDS_KEY 
343d						DMARK "2A_" 
343d f5				push af  
343e 3a 52 34			ld a, (.dmark)  
3441 32 a0 fd			ld (debug_mark),a  
3444 3a 53 34			ld a, (.dmark+1)  
3447 32 a1 fd			ld (debug_mark+1),a  
344a 3a 54 34			ld a, (.dmark+2)  
344d 32 a2 fd			ld (debug_mark+2),a  
3450 18 03			jr .pastdmark  
3452 ..			.dmark: db "2A_"  
3455 f1			.pastdmark: pop af  
3456			endm  
# End of macro DMARK
3456						CALLMONITOR 
3456 cd aa fd			call debug_vector  
3459				endm  
# End of macro CALLMONITOR
3459					endif 
3459			 
3459					FORTH_DSP_VALUEHL 
3459 cd 4d 22			call macro_dsp_valuehl 
345c				endm 
# End of macro FORTH_DSP_VALUEHL
345c			 
345c e5					push hl   ; save address 
345d			 
345d					FORTH_DSP_POP 
345d cd 05 23			call macro_forth_dsp_pop 
3460				endm 
# End of macro FORTH_DSP_POP
3460			 
3460 e1					pop hl 
3461			 
3461 5e					ld e, (hl) 
3462 23					inc hl 
3463 56					ld d, (hl) 
3464			 
3464 eb					ex de, hl 
3465			 
3465 cd 48 20				call forth_push_numhl 
3468			 
3468				       NEXTW 
3468 c3 38 24			jp macro_next 
346b				endm 
# End of macro NEXTW
346b			.BANG2: 
346b				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
346b 6f				db WORD_SYS_CORE+91             
346c a3 34			dw .CONFIG            
346e 03				db 2 + 1 
346f .. 00			db "2!",0              
3472				endm 
# End of macro CWHEAD
3472			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3472					if DEBUG_FORTH_WORDS_KEY 
3472						DMARK "2S_" 
3472 f5				push af  
3473 3a 87 34			ld a, (.dmark)  
3476 32 a0 fd			ld (debug_mark),a  
3479 3a 88 34			ld a, (.dmark+1)  
347c 32 a1 fd			ld (debug_mark+1),a  
347f 3a 89 34			ld a, (.dmark+2)  
3482 32 a2 fd			ld (debug_mark+2),a  
3485 18 03			jr .pastdmark  
3487 ..			.dmark: db "2S_"  
348a f1			.pastdmark: pop af  
348b			endm  
# End of macro DMARK
348b						CALLMONITOR 
348b cd aa fd			call debug_vector  
348e				endm  
# End of macro CALLMONITOR
348e					endif 
348e			 
348e					FORTH_DSP_VALUEHL 
348e cd 4d 22			call macro_dsp_valuehl 
3491				endm 
# End of macro FORTH_DSP_VALUEHL
3491			 
3491 e5					push hl   ; save address 
3492			 
3492			 
3492					FORTH_DSP_POP 
3492 cd 05 23			call macro_forth_dsp_pop 
3495				endm 
# End of macro FORTH_DSP_POP
3495			 
3495					 
3495					FORTH_DSP_VALUEHL 
3495 cd 4d 22			call macro_dsp_valuehl 
3498				endm 
# End of macro FORTH_DSP_VALUEHL
3498			 
3498					FORTH_DSP_POP 
3498 cd 05 23			call macro_forth_dsp_pop 
349b				endm 
# End of macro FORTH_DSP_POP
349b			 
349b eb					ex de, hl    ; value now in de 
349c			 
349c e1					pop hl 
349d			 
349d 73					ld (hl), e 
349e			 
349e 23					inc hl 
349f			 
349f 72					ld (hl), d 
34a0			 
34a0			 
34a0				       NEXTW 
34a0 c3 38 24			jp macro_next 
34a3				endm 
# End of macro NEXTW
34a3			.CONFIG: 
34a3				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
34a3 6f				db WORD_SYS_CORE+91             
34a4 b4 34			dw .ADTOS            
34a6 07				db 6 + 1 
34a7 .. 00			db "CONFIG",0              
34ae				endm 
# End of macro CWHEAD
34ae			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
34ae			 
34ae cd 52 15				call config 
34b1					NEXTW 
34b1 c3 38 24			jp macro_next 
34b4				endm 
# End of macro NEXTW
34b4			 
34b4			.ADTOS: 
34b4				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
34b4 6f				db WORD_SYS_CORE+91             
34b5 ca 34			dw .SBTOS            
34b7 03				db 2 + 1 
34b8 .. 00			db "1+",0              
34bb				endm 
# End of macro CWHEAD
34bb			; | 1+ ( u -- u )  Increment value on TOS | DONE 
34bb			 
34bb					FORTH_DSP_VALUEHL 
34bb cd 4d 22			call macro_dsp_valuehl 
34be				endm 
# End of macro FORTH_DSP_VALUEHL
34be e5					push hl 
34bf			 
34bf					FORTH_DSP_POP 
34bf cd 05 23			call macro_forth_dsp_pop 
34c2				endm 
# End of macro FORTH_DSP_POP
34c2 e1					pop hl 
34c3			 
34c3 23					inc hl 
34c4 cd 48 20				call forth_push_numhl 
34c7					 
34c7					NEXTW 
34c7 c3 38 24			jp macro_next 
34ca				endm 
# End of macro NEXTW
34ca			.SBTOS: 
34ca				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
34ca 6f				db WORD_SYS_CORE+91             
34cb e0 34			dw .ADSTORE            
34cd 03				db 2 + 1 
34ce .. 00			db "1-",0              
34d1				endm 
# End of macro CWHEAD
34d1			; | 1- ( u -- u )  Decrement value on TOS | DONE 
34d1			 
34d1					FORTH_DSP_VALUEHL 
34d1 cd 4d 22			call macro_dsp_valuehl 
34d4				endm 
# End of macro FORTH_DSP_VALUEHL
34d4 e5					push hl 
34d5			 
34d5					FORTH_DSP_POP 
34d5 cd 05 23			call macro_forth_dsp_pop 
34d8				endm 
# End of macro FORTH_DSP_POP
34d8 e1					pop hl 
34d9			 
34d9 2b					dec hl 
34da cd 48 20				call forth_push_numhl 
34dd					 
34dd					NEXTW 
34dd c3 38 24			jp macro_next 
34e0				endm 
# End of macro NEXTW
34e0			.ADSTORE: 
34e0				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
34e0 6f				db WORD_SYS_CORE+91             
34e1 f6 34			dw .ADWSTORE            
34e3 04				db 3 + 1 
34e4 .. 00			db "1+!",0              
34e8				endm 
# End of macro CWHEAD
34e8			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
34e8			 
34e8					FORTH_DSP_VALUEHL 
34e8 cd 4d 22			call macro_dsp_valuehl 
34eb				endm 
# End of macro FORTH_DSP_VALUEHL
34eb e5					push hl 
34ec			 
34ec					FORTH_DSP_POP 
34ec cd 05 23			call macro_forth_dsp_pop 
34ef				endm 
# End of macro FORTH_DSP_POP
34ef e1					pop hl 
34f0			 
34f0 7e					ld a, (hl) 
34f1 3c					inc a 
34f2 77					ld (hl), a 
34f3					 
34f3					NEXTW 
34f3 c3 38 24			jp macro_next 
34f6				endm 
# End of macro NEXTW
34f6			.ADWSTORE: 
34f6				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
34f6 6f				db WORD_SYS_CORE+91             
34f7 14 35			dw .SBSTORE            
34f9 05				db 4 + 1 
34fa .. 00			db "1+2!",0              
34ff				endm 
# End of macro CWHEAD
34ff			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
34ff			 
34ff					FORTH_DSP_VALUEHL 
34ff cd 4d 22			call macro_dsp_valuehl 
3502				endm 
# End of macro FORTH_DSP_VALUEHL
3502 e5					push hl 
3503			 
3503					FORTH_DSP_POP 
3503 cd 05 23			call macro_forth_dsp_pop 
3506				endm 
# End of macro FORTH_DSP_POP
3506 e1					pop hl 
3507			 
3507 e5					push hl 
3508			 
3508 cd ba 23				call loadwordinhl 
350b 23					inc hl 
350c			 
350c d1					pop de 
350d eb					ex de, hl 
350e 73					ld (hl), e 
350f 23					inc hl 
3510 72					ld (hl), d 
3511					 
3511					NEXTW 
3511 c3 38 24			jp macro_next 
3514				endm 
# End of macro NEXTW
3514			.SBSTORE: 
3514				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3514 6f				db WORD_SYS_CORE+91             
3515 2a 35			dw .SBWSTORE            
3517 04				db 3 + 1 
3518 .. 00			db "1-!",0              
351c				endm 
# End of macro CWHEAD
351c			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
351c			 
351c					FORTH_DSP_VALUEHL 
351c cd 4d 22			call macro_dsp_valuehl 
351f				endm 
# End of macro FORTH_DSP_VALUEHL
351f e5					push hl 
3520			 
3520					FORTH_DSP_POP 
3520 cd 05 23			call macro_forth_dsp_pop 
3523				endm 
# End of macro FORTH_DSP_POP
3523 e1					pop hl 
3524			 
3524 7e					ld a, (hl) 
3525 3d					dec a 
3526 77					ld (hl), a 
3527					 
3527					NEXTW 
3527 c3 38 24			jp macro_next 
352a				endm 
# End of macro NEXTW
352a			.SBWSTORE: 
352a				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
352a 6f				db WORD_SYS_CORE+91             
352b 48 35			dw .ENDCORE            
352d 05				db 4 + 1 
352e .. 00			db "1-2!",0              
3533				endm 
# End of macro CWHEAD
3533			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3533			 
3533					FORTH_DSP_VALUEHL 
3533 cd 4d 22			call macro_dsp_valuehl 
3536				endm 
# End of macro FORTH_DSP_VALUEHL
3536 e5					push hl 
3537			 
3537					FORTH_DSP_POP 
3537 cd 05 23			call macro_forth_dsp_pop 
353a				endm 
# End of macro FORTH_DSP_POP
353a e1					pop hl 
353b			 
353b e5					push hl 
353c			 
353c cd ba 23				call loadwordinhl 
353f 2b					dec hl 
3540			 
3540 d1					pop de 
3541 eb					ex de, hl 
3542 73					ld (hl), e 
3543 23					inc hl 
3544 72					ld (hl), d 
3545					 
3545					NEXTW 
3545 c3 38 24			jp macro_next 
3548				endm 
# End of macro NEXTW
3548			.ENDCORE: 
3548			 
3548			; eof 
3548			 
3548			 
# End of file forth_words_core.asm
3548			include "forth_words_flow.asm" 
3548			 
3548			; | ## Program Flow Words 
3548			 
3548			.IF: 
3548				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3548 1e				db WORD_SYS_CORE+10             
3549 3d 36			dw .THEN            
354b 03				db 2 + 1 
354c .. 00			db "IF",0              
354f				endm 
# End of macro CWHEAD
354f			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
354f			; 
354f					if DEBUG_FORTH_WORDS_KEY 
354f						DMARK "IF." 
354f f5				push af  
3550 3a 64 35			ld a, (.dmark)  
3553 32 a0 fd			ld (debug_mark),a  
3556 3a 65 35			ld a, (.dmark+1)  
3559 32 a1 fd			ld (debug_mark+1),a  
355c 3a 66 35			ld a, (.dmark+2)  
355f 32 a2 fd			ld (debug_mark+2),a  
3562 18 03			jr .pastdmark  
3564 ..			.dmark: db "IF."  
3567 f1			.pastdmark: pop af  
3568			endm  
# End of macro DMARK
3568						CALLMONITOR 
3568 cd aa fd			call debug_vector  
356b				endm  
# End of macro CALLMONITOR
356b					endif 
356b			; eval TOS 
356b			 
356b				FORTH_DSP_VALUEHL 
356b cd 4d 22			call macro_dsp_valuehl 
356e				endm 
# End of macro FORTH_DSP_VALUEHL
356e			 
356e			;	push hl 
356e				FORTH_DSP_POP 
356e cd 05 23			call macro_forth_dsp_pop 
3571				endm 
# End of macro FORTH_DSP_POP
3571			;	pop hl 
3571			 
3571					if DEBUG_FORTH_WORDS 
3571						DMARK "IF1" 
3571 f5				push af  
3572 3a 86 35			ld a, (.dmark)  
3575 32 a0 fd			ld (debug_mark),a  
3578 3a 87 35			ld a, (.dmark+1)  
357b 32 a1 fd			ld (debug_mark+1),a  
357e 3a 88 35			ld a, (.dmark+2)  
3581 32 a2 fd			ld (debug_mark+2),a  
3584 18 03			jr .pastdmark  
3586 ..			.dmark: db "IF1"  
3589 f1			.pastdmark: pop af  
358a			endm  
# End of macro DMARK
358a						CALLMONITOR 
358a cd aa fd			call debug_vector  
358d				endm  
# End of macro CALLMONITOR
358d					endif 
358d b7				or a        ; clear carry flag 
358e 11 00 00			ld de, 0 
3591 eb				ex de,hl 
3592 ed 52			sbc hl, de 
3594 c2 1e 36			jp nz, .iftrue 
3597			 
3597					if DEBUG_FORTH_WORDS 
3597						DMARK "IF2" 
3597 f5				push af  
3598 3a ac 35			ld a, (.dmark)  
359b 32 a0 fd			ld (debug_mark),a  
359e 3a ad 35			ld a, (.dmark+1)  
35a1 32 a1 fd			ld (debug_mark+1),a  
35a4 3a ae 35			ld a, (.dmark+2)  
35a7 32 a2 fd			ld (debug_mark+2),a  
35aa 18 03			jr .pastdmark  
35ac ..			.dmark: db "IF2"  
35af f1			.pastdmark: pop af  
35b0			endm  
# End of macro DMARK
35b0						CALLMONITOR 
35b0 cd aa fd			call debug_vector  
35b3				endm  
# End of macro CALLMONITOR
35b3					endif 
35b3			 
35b3			; if not true then skip to THEN 
35b3			 
35b3				; TODO get tok_ptr 
35b3				; TODO consume toks until we get to THEN 
35b3			 
35b3 2a f7 f3			ld hl, (os_tok_ptr) 
35b6					if DEBUG_FORTH_WORDS 
35b6						DMARK "IF3" 
35b6 f5				push af  
35b7 3a cb 35			ld a, (.dmark)  
35ba 32 a0 fd			ld (debug_mark),a  
35bd 3a cc 35			ld a, (.dmark+1)  
35c0 32 a1 fd			ld (debug_mark+1),a  
35c3 3a cd 35			ld a, (.dmark+2)  
35c6 32 a2 fd			ld (debug_mark+2),a  
35c9 18 03			jr .pastdmark  
35cb ..			.dmark: db "IF3"  
35ce f1			.pastdmark: pop af  
35cf			endm  
# End of macro DMARK
35cf						CALLMONITOR 
35cf cd aa fd			call debug_vector  
35d2				endm  
# End of macro CALLMONITOR
35d2						 
35d2					endif 
35d2 11 19 36			ld de, .ifthen 
35d5					if DEBUG_FORTH_WORDS 
35d5						DMARK "IF4" 
35d5 f5				push af  
35d6 3a ea 35			ld a, (.dmark)  
35d9 32 a0 fd			ld (debug_mark),a  
35dc 3a eb 35			ld a, (.dmark+1)  
35df 32 a1 fd			ld (debug_mark+1),a  
35e2 3a ec 35			ld a, (.dmark+2)  
35e5 32 a2 fd			ld (debug_mark+2),a  
35e8 18 03			jr .pastdmark  
35ea ..			.dmark: db "IF4"  
35ed f1			.pastdmark: pop af  
35ee			endm  
# End of macro DMARK
35ee						CALLMONITOR 
35ee cd aa fd			call debug_vector  
35f1				endm  
# End of macro CALLMONITOR
35f1					endif 
35f1 cd 3f 25			call findnexttok  
35f4			 
35f4					if DEBUG_FORTH_WORDS 
35f4						DMARK "IF5" 
35f4 f5				push af  
35f5 3a 09 36			ld a, (.dmark)  
35f8 32 a0 fd			ld (debug_mark),a  
35fb 3a 0a 36			ld a, (.dmark+1)  
35fe 32 a1 fd			ld (debug_mark+1),a  
3601 3a 0b 36			ld a, (.dmark+2)  
3604 32 a2 fd			ld (debug_mark+2),a  
3607 18 03			jr .pastdmark  
3609 ..			.dmark: db "IF5"  
360c f1			.pastdmark: pop af  
360d			endm  
# End of macro DMARK
360d						CALLMONITOR 
360d cd aa fd			call debug_vector  
3610				endm  
# End of macro CALLMONITOR
3610					endif 
3610				; TODO replace below with ; exec using tok_ptr 
3610 22 f7 f3			ld (os_tok_ptr), hl 
3613 c3 c1 24			jp exec1 
3616				NEXTW 
3616 c3 38 24			jp macro_next 
3619				endm 
# End of macro NEXTW
3619			 
3619 .. 00		.ifthen:  db "THEN",0 
361e			 
361e			.iftrue:		 
361e				; Exec next words normally 
361e			 
361e				; if true then exec following IF as normal 
361e					if DEBUG_FORTH_WORDS 
361e						DMARK "IFT" 
361e f5				push af  
361f 3a 33 36			ld a, (.dmark)  
3622 32 a0 fd			ld (debug_mark),a  
3625 3a 34 36			ld a, (.dmark+1)  
3628 32 a1 fd			ld (debug_mark+1),a  
362b 3a 35 36			ld a, (.dmark+2)  
362e 32 a2 fd			ld (debug_mark+2),a  
3631 18 03			jr .pastdmark  
3633 ..			.dmark: db "IFT"  
3636 f1			.pastdmark: pop af  
3637			endm  
# End of macro DMARK
3637						CALLMONITOR 
3637 cd aa fd			call debug_vector  
363a				endm  
# End of macro CALLMONITOR
363a					endif 
363a			 
363a					NEXTW 
363a c3 38 24			jp macro_next 
363d				endm 
# End of macro NEXTW
363d			.THEN: 
363d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
363d 1f				db WORD_SYS_CORE+11             
363e 65 36			dw .ELSE            
3640 05				db 4 + 1 
3641 .. 00			db "THEN",0              
3646				endm 
# End of macro CWHEAD
3646			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3646					if DEBUG_FORTH_WORDS_KEY 
3646						DMARK "THN" 
3646 f5				push af  
3647 3a 5b 36			ld a, (.dmark)  
364a 32 a0 fd			ld (debug_mark),a  
364d 3a 5c 36			ld a, (.dmark+1)  
3650 32 a1 fd			ld (debug_mark+1),a  
3653 3a 5d 36			ld a, (.dmark+2)  
3656 32 a2 fd			ld (debug_mark+2),a  
3659 18 03			jr .pastdmark  
365b ..			.dmark: db "THN"  
365e f1			.pastdmark: pop af  
365f			endm  
# End of macro DMARK
365f						CALLMONITOR 
365f cd aa fd			call debug_vector  
3662				endm  
# End of macro CALLMONITOR
3662					endif 
3662					NEXTW 
3662 c3 38 24			jp macro_next 
3665				endm 
# End of macro NEXTW
3665			.ELSE: 
3665				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3665 20				db WORD_SYS_CORE+12             
3666 8d 36			dw .DO            
3668 03				db 2 + 1 
3669 .. 00			db "ELSE",0              
366e				endm 
# End of macro CWHEAD
366e			; | ELSE ( -- ) Not supported - does nothing | TODO 
366e			 
366e					if DEBUG_FORTH_WORDS_KEY 
366e						DMARK "ELS" 
366e f5				push af  
366f 3a 83 36			ld a, (.dmark)  
3672 32 a0 fd			ld (debug_mark),a  
3675 3a 84 36			ld a, (.dmark+1)  
3678 32 a1 fd			ld (debug_mark+1),a  
367b 3a 85 36			ld a, (.dmark+2)  
367e 32 a2 fd			ld (debug_mark+2),a  
3681 18 03			jr .pastdmark  
3683 ..			.dmark: db "ELS"  
3686 f1			.pastdmark: pop af  
3687			endm  
# End of macro DMARK
3687						CALLMONITOR 
3687 cd aa fd			call debug_vector  
368a				endm  
# End of macro CALLMONITOR
368a					endif 
368a			 
368a			 
368a					NEXTW 
368a c3 38 24			jp macro_next 
368d				endm 
# End of macro NEXTW
368d			.DO: 
368d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
368d 21				db WORD_SYS_CORE+13             
368e b4 37			dw .LOOP            
3690 03				db 2 + 1 
3691 .. 00			db "DO",0              
3694				endm 
# End of macro CWHEAD
3694			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3694			 
3694					if DEBUG_FORTH_WORDS_KEY 
3694						DMARK "DO." 
3694 f5				push af  
3695 3a a9 36			ld a, (.dmark)  
3698 32 a0 fd			ld (debug_mark),a  
369b 3a aa 36			ld a, (.dmark+1)  
369e 32 a1 fd			ld (debug_mark+1),a  
36a1 3a ab 36			ld a, (.dmark+2)  
36a4 32 a2 fd			ld (debug_mark+2),a  
36a7 18 03			jr .pastdmark  
36a9 ..			.dmark: db "DO."  
36ac f1			.pastdmark: pop af  
36ad			endm  
# End of macro DMARK
36ad						CALLMONITOR 
36ad cd aa fd			call debug_vector  
36b0				endm  
# End of macro CALLMONITOR
36b0					endif 
36b0			;  push pc to rsp stack past the DO 
36b0			 
36b0 2a f7 f3				ld hl, (os_tok_ptr) 
36b3 23					inc hl   ; D 
36b4 23					inc hl  ; O 
36b5 23					inc hl   ; null 
36b6					if DEBUG_FORTH_WORDS 
36b6						DMARK "DO2" 
36b6 f5				push af  
36b7 3a cb 36			ld a, (.dmark)  
36ba 32 a0 fd			ld (debug_mark),a  
36bd 3a cc 36			ld a, (.dmark+1)  
36c0 32 a1 fd			ld (debug_mark+1),a  
36c3 3a cd 36			ld a, (.dmark+2)  
36c6 32 a2 fd			ld (debug_mark+2),a  
36c9 18 03			jr .pastdmark  
36cb ..			.dmark: db "DO2"  
36ce f1			.pastdmark: pop af  
36cf			endm  
# End of macro DMARK
36cf						CALLMONITOR 
36cf cd aa fd			call debug_vector  
36d2				endm  
# End of macro CALLMONITOR
36d2					endif 
36d2					FORTH_RSP_NEXT 
36d2 cd ef 1f			call macro_forth_rsp_next 
36d5				endm 
# End of macro FORTH_RSP_NEXT
36d5					if DEBUG_FORTH_WORDS 
36d5						DMARK "DO3" 
36d5 f5				push af  
36d6 3a ea 36			ld a, (.dmark)  
36d9 32 a0 fd			ld (debug_mark),a  
36dc 3a eb 36			ld a, (.dmark+1)  
36df 32 a1 fd			ld (debug_mark+1),a  
36e2 3a ec 36			ld a, (.dmark+2)  
36e5 32 a2 fd			ld (debug_mark+2),a  
36e8 18 03			jr .pastdmark  
36ea ..			.dmark: db "DO3"  
36ed f1			.pastdmark: pop af  
36ee			endm  
# End of macro DMARK
36ee						CALLMONITOR 
36ee cd aa fd			call debug_vector  
36f1				endm  
# End of macro CALLMONITOR
36f1					endif 
36f1			 
36f1					;if DEBUG_FORTH_WORDS 
36f1				;		push hl 
36f1			;		endif  
36f1			 
36f1			; get counters from data stack 
36f1			 
36f1			 
36f1					FORTH_DSP_VALUEHL 
36f1 cd 4d 22			call macro_dsp_valuehl 
36f4				endm 
# End of macro FORTH_DSP_VALUEHL
36f4 e5					push hl		 ; hl now has starting counter which needs to be tos 
36f5			 
36f5					if DEBUG_FORTH_WORDS 
36f5						DMARK "DO4" 
36f5 f5				push af  
36f6 3a 0a 37			ld a, (.dmark)  
36f9 32 a0 fd			ld (debug_mark),a  
36fc 3a 0b 37			ld a, (.dmark+1)  
36ff 32 a1 fd			ld (debug_mark+1),a  
3702 3a 0c 37			ld a, (.dmark+2)  
3705 32 a2 fd			ld (debug_mark+2),a  
3708 18 03			jr .pastdmark  
370a ..			.dmark: db "DO4"  
370d f1			.pastdmark: pop af  
370e			endm  
# End of macro DMARK
370e						CALLMONITOR 
370e cd aa fd			call debug_vector  
3711				endm  
# End of macro CALLMONITOR
3711					endif 
3711					FORTH_DSP_POP 
3711 cd 05 23			call macro_forth_dsp_pop 
3714				endm 
# End of macro FORTH_DSP_POP
3714			 
3714					if DEBUG_FORTH_WORDS 
3714						DMARK "DO5" 
3714 f5				push af  
3715 3a 29 37			ld a, (.dmark)  
3718 32 a0 fd			ld (debug_mark),a  
371b 3a 2a 37			ld a, (.dmark+1)  
371e 32 a1 fd			ld (debug_mark+1),a  
3721 3a 2b 37			ld a, (.dmark+2)  
3724 32 a2 fd			ld (debug_mark+2),a  
3727 18 03			jr .pastdmark  
3729 ..			.dmark: db "DO5"  
372c f1			.pastdmark: pop af  
372d			endm  
# End of macro DMARK
372d						CALLMONITOR 
372d cd aa fd			call debug_vector  
3730				endm  
# End of macro CALLMONITOR
3730					endif 
3730			 
3730					FORTH_DSP_VALUEHL 
3730 cd 4d 22			call macro_dsp_valuehl 
3733				endm 
# End of macro FORTH_DSP_VALUEHL
3733			;		push hl		 ; hl now has starting limit counter 
3733			 
3733					if DEBUG_FORTH_WORDS 
3733						DMARK "DO6" 
3733 f5				push af  
3734 3a 48 37			ld a, (.dmark)  
3737 32 a0 fd			ld (debug_mark),a  
373a 3a 49 37			ld a, (.dmark+1)  
373d 32 a1 fd			ld (debug_mark+1),a  
3740 3a 4a 37			ld a, (.dmark+2)  
3743 32 a2 fd			ld (debug_mark+2),a  
3746 18 03			jr .pastdmark  
3748 ..			.dmark: db "DO6"  
374b f1			.pastdmark: pop af  
374c			endm  
# End of macro DMARK
374c						CALLMONITOR 
374c cd aa fd			call debug_vector  
374f				endm  
# End of macro CALLMONITOR
374f					endif 
374f					FORTH_DSP_POP 
374f cd 05 23			call macro_forth_dsp_pop 
3752				endm 
# End of macro FORTH_DSP_POP
3752			 
3752			; put counters on the loop stack 
3752			 
3752			;		pop hl			 ; limit counter 
3752 d1					pop de			; start counter 
3753			 
3753					; push limit counter 
3753			 
3753					if DEBUG_FORTH_WORDS 
3753						DMARK "DO7" 
3753 f5				push af  
3754 3a 68 37			ld a, (.dmark)  
3757 32 a0 fd			ld (debug_mark),a  
375a 3a 69 37			ld a, (.dmark+1)  
375d 32 a1 fd			ld (debug_mark+1),a  
3760 3a 6a 37			ld a, (.dmark+2)  
3763 32 a2 fd			ld (debug_mark+2),a  
3766 18 03			jr .pastdmark  
3768 ..			.dmark: db "DO7"  
376b f1			.pastdmark: pop af  
376c			endm  
# End of macro DMARK
376c						CALLMONITOR 
376c cd aa fd			call debug_vector  
376f				endm  
# End of macro CALLMONITOR
376f					endif 
376f					FORTH_LOOP_NEXT 
376f cd 7e 22			call macro_forth_loop_next 
3772				endm 
# End of macro FORTH_LOOP_NEXT
3772			 
3772					; push start counter 
3772			 
3772 eb					ex de, hl 
3773					if DEBUG_FORTH_WORDS 
3773						DMARK "DO7" 
3773 f5				push af  
3774 3a 88 37			ld a, (.dmark)  
3777 32 a0 fd			ld (debug_mark),a  
377a 3a 89 37			ld a, (.dmark+1)  
377d 32 a1 fd			ld (debug_mark+1),a  
3780 3a 8a 37			ld a, (.dmark+2)  
3783 32 a2 fd			ld (debug_mark+2),a  
3786 18 03			jr .pastdmark  
3788 ..			.dmark: db "DO7"  
378b f1			.pastdmark: pop af  
378c			endm  
# End of macro DMARK
378c						CALLMONITOR 
378c cd aa fd			call debug_vector  
378f				endm  
# End of macro CALLMONITOR
378f					endif 
378f					FORTH_LOOP_NEXT 
378f cd 7e 22			call macro_forth_loop_next 
3792				endm 
# End of macro FORTH_LOOP_NEXT
3792			 
3792			 
3792					; init first round of I counter 
3792			 
3792 22 1b f4				ld (os_current_i), hl 
3795			 
3795					if DEBUG_FORTH_WORDS 
3795						DMARK "DO8" 
3795 f5				push af  
3796 3a aa 37			ld a, (.dmark)  
3799 32 a0 fd			ld (debug_mark),a  
379c 3a ab 37			ld a, (.dmark+1)  
379f 32 a1 fd			ld (debug_mark+1),a  
37a2 3a ac 37			ld a, (.dmark+2)  
37a5 32 a2 fd			ld (debug_mark+2),a  
37a8 18 03			jr .pastdmark  
37aa ..			.dmark: db "DO8"  
37ad f1			.pastdmark: pop af  
37ae			endm  
# End of macro DMARK
37ae						CALLMONITOR 
37ae cd aa fd			call debug_vector  
37b1				endm  
# End of macro CALLMONITOR
37b1					endif 
37b1			 
37b1					NEXTW 
37b1 c3 38 24			jp macro_next 
37b4				endm 
# End of macro NEXTW
37b4			.LOOP: 
37b4				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
37b4 22				db WORD_SYS_CORE+14             
37b5 cc 38			dw .I            
37b7 05				db 4 + 1 
37b8 .. 00			db "LOOP",0              
37bd				endm 
# End of macro CWHEAD
37bd			; | LOOP ( -- ) Increment and test loop counter  | DONE 
37bd			 
37bd				; pop tos as current loop count to hl 
37bd			 
37bd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
37bd			 
37bd				FORTH_LOOP_TOS 
37bd cd b1 22			call macro_forth_loop_tos 
37c0				endm 
# End of macro FORTH_LOOP_TOS
37c0 e5				push hl 
37c1			 
37c1					if DEBUG_FORTH_WORDS_KEY 
37c1						DMARK "LOP" 
37c1 f5				push af  
37c2 3a d6 37			ld a, (.dmark)  
37c5 32 a0 fd			ld (debug_mark),a  
37c8 3a d7 37			ld a, (.dmark+1)  
37cb 32 a1 fd			ld (debug_mark+1),a  
37ce 3a d8 37			ld a, (.dmark+2)  
37d1 32 a2 fd			ld (debug_mark+2),a  
37d4 18 03			jr .pastdmark  
37d6 ..			.dmark: db "LOP"  
37d9 f1			.pastdmark: pop af  
37da			endm  
# End of macro DMARK
37da						CALLMONITOR 
37da cd aa fd			call debug_vector  
37dd				endm  
# End of macro CALLMONITOR
37dd					endif 
37dd				; next item on the stack is the limit. get it 
37dd			 
37dd			 
37dd				FORTH_LOOP_POP 
37dd cd bb 22			call macro_forth_loop_pop 
37e0				endm 
# End of macro FORTH_LOOP_POP
37e0			 
37e0				FORTH_LOOP_TOS 
37e0 cd b1 22			call macro_forth_loop_tos 
37e3				endm 
# End of macro FORTH_LOOP_TOS
37e3			 
37e3 d1				pop de		 ; de = i, hl = limit 
37e4			 
37e4					if DEBUG_FORTH_WORDS 
37e4						DMARK "LP1" 
37e4 f5				push af  
37e5 3a f9 37			ld a, (.dmark)  
37e8 32 a0 fd			ld (debug_mark),a  
37eb 3a fa 37			ld a, (.dmark+1)  
37ee 32 a1 fd			ld (debug_mark+1),a  
37f1 3a fb 37			ld a, (.dmark+2)  
37f4 32 a2 fd			ld (debug_mark+2),a  
37f7 18 03			jr .pastdmark  
37f9 ..			.dmark: db "LP1"  
37fc f1			.pastdmark: pop af  
37fd			endm  
# End of macro DMARK
37fd						CALLMONITOR 
37fd cd aa fd			call debug_vector  
3800				endm  
# End of macro CALLMONITOR
3800					endif 
3800			 
3800				; go back to previous word 
3800			 
3800 d5				push de    ; save I for inc later 
3801			 
3801			 
3801				; get limit 
3801				;  is I at limit? 
3801			 
3801			 
3801					if DEBUG_FORTH_WORDS 
3801						DMARK "LP1" 
3801 f5				push af  
3802 3a 16 38			ld a, (.dmark)  
3805 32 a0 fd			ld (debug_mark),a  
3808 3a 17 38			ld a, (.dmark+1)  
380b 32 a1 fd			ld (debug_mark+1),a  
380e 3a 18 38			ld a, (.dmark+2)  
3811 32 a2 fd			ld (debug_mark+2),a  
3814 18 03			jr .pastdmark  
3816 ..			.dmark: db "LP1"  
3819 f1			.pastdmark: pop af  
381a			endm  
# End of macro DMARK
381a						CALLMONITOR 
381a cd aa fd			call debug_vector  
381d				endm  
# End of macro CALLMONITOR
381d					endif 
381d			 
381d ed 52			sbc hl, de 
381f			 
381f			 
381f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
381f			 
381f 20 26				jr nz, .loopnotdone 
3821			 
3821 e1				pop hl   ; get rid of saved I 
3822				FORTH_LOOP_POP     ; get rid of limit 
3822 cd bb 22			call macro_forth_loop_pop 
3825				endm 
# End of macro FORTH_LOOP_POP
3825			 
3825				FORTH_RSP_POP     ; get rid of DO ptr 
3825 cd 10 20			call macro_forth_rsp_pop 
3828				endm 
# End of macro FORTH_RSP_POP
3828			 
3828			if DEBUG_FORTH_WORDS 
3828						DMARK "LP>" 
3828 f5				push af  
3829 3a 3d 38			ld a, (.dmark)  
382c 32 a0 fd			ld (debug_mark),a  
382f 3a 3e 38			ld a, (.dmark+1)  
3832 32 a1 fd			ld (debug_mark+1),a  
3835 3a 3f 38			ld a, (.dmark+2)  
3838 32 a2 fd			ld (debug_mark+2),a  
383b 18 03			jr .pastdmark  
383d ..			.dmark: db "LP>"  
3840 f1			.pastdmark: pop af  
3841			endm  
# End of macro DMARK
3841				CALLMONITOR 
3841 cd aa fd			call debug_vector  
3844				endm  
# End of macro CALLMONITOR
3844			endif 
3844			 
3844					NEXTW 
3844 c3 38 24			jp macro_next 
3847				endm 
# End of macro NEXTW
3847				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3847			 
3847			.loopnotdone: 
3847			 
3847 e1				pop hl    ; get I 
3848 23				inc hl 
3849			 
3849			   	; save new I 
3849			 
3849			 
3849					; set I counter 
3849			 
3849 22 1b f4				ld (os_current_i), hl 
384c			 
384c					if DEBUG_FORTH_WORDS 
384c						DMARK "LPN" 
384c f5				push af  
384d 3a 61 38			ld a, (.dmark)  
3850 32 a0 fd			ld (debug_mark),a  
3853 3a 62 38			ld a, (.dmark+1)  
3856 32 a1 fd			ld (debug_mark+1),a  
3859 3a 63 38			ld a, (.dmark+2)  
385c 32 a2 fd			ld (debug_mark+2),a  
385f 18 03			jr .pastdmark  
3861 ..			.dmark: db "LPN"  
3864 f1			.pastdmark: pop af  
3865			endm  
# End of macro DMARK
3865					CALLMONITOR 
3865 cd aa fd			call debug_vector  
3868				endm  
# End of macro CALLMONITOR
3868					endif 
3868					 
3868				FORTH_LOOP_NEXT 
3868 cd 7e 22			call macro_forth_loop_next 
386b				endm 
# End of macro FORTH_LOOP_NEXT
386b			 
386b			 
386b					if DEBUG_FORTH_WORDS 
386b eb						ex de,hl 
386c					endif 
386c			 
386c			;	; get DO ptr 
386c			; 
386c					if DEBUG_FORTH_WORDS 
386c						DMARK "LP7" 
386c f5				push af  
386d 3a 81 38			ld a, (.dmark)  
3870 32 a0 fd			ld (debug_mark),a  
3873 3a 82 38			ld a, (.dmark+1)  
3876 32 a1 fd			ld (debug_mark+1),a  
3879 3a 83 38			ld a, (.dmark+2)  
387c 32 a2 fd			ld (debug_mark+2),a  
387f 18 03			jr .pastdmark  
3881 ..			.dmark: db "LP7"  
3884 f1			.pastdmark: pop af  
3885			endm  
# End of macro DMARK
3885					CALLMONITOR 
3885 cd aa fd			call debug_vector  
3888				endm  
# End of macro CALLMONITOR
3888					endif 
3888				FORTH_RSP_TOS 
3888 cd 06 20			call macro_forth_rsp_tos 
388b				endm 
# End of macro FORTH_RSP_TOS
388b			 
388b					if DEBUG_FORTH_WORDS 
388b						DMARK "LP8" 
388b f5				push af  
388c 3a a0 38			ld a, (.dmark)  
388f 32 a0 fd			ld (debug_mark),a  
3892 3a a1 38			ld a, (.dmark+1)  
3895 32 a1 fd			ld (debug_mark+1),a  
3898 3a a2 38			ld a, (.dmark+2)  
389b 32 a2 fd			ld (debug_mark+2),a  
389e 18 03			jr .pastdmark  
38a0 ..			.dmark: db "LP8"  
38a3 f1			.pastdmark: pop af  
38a4			endm  
# End of macro DMARK
38a4					CALLMONITOR 
38a4 cd aa fd			call debug_vector  
38a7				endm  
# End of macro CALLMONITOR
38a7					endif 
38a7				;push hl 
38a7			 
38a7				; not going to DO any more 
38a7				; get rid of the RSP pointer as DO will add it back in 
38a7				;FORTH_RSP_POP 
38a7				;pop hl 
38a7			 
38a7				;ld hl,(cli_ret_sp) 
38a7				;ld e, (hl) 
38a7				;inc hl 
38a7				;ld d, (hl) 
38a7				;ex de,hl 
38a7 22 f7 f3			ld (os_tok_ptr), hl 
38aa					if DEBUG_FORTH_WORDS 
38aa						DMARK "LP<" 
38aa f5				push af  
38ab 3a bf 38			ld a, (.dmark)  
38ae 32 a0 fd			ld (debug_mark),a  
38b1 3a c0 38			ld a, (.dmark+1)  
38b4 32 a1 fd			ld (debug_mark+1),a  
38b7 3a c1 38			ld a, (.dmark+2)  
38ba 32 a2 fd			ld (debug_mark+2),a  
38bd 18 03			jr .pastdmark  
38bf ..			.dmark: db "LP<"  
38c2 f1			.pastdmark: pop af  
38c3			endm  
# End of macro DMARK
38c3					CALLMONITOR 
38c3 cd aa fd			call debug_vector  
38c6				endm  
# End of macro CALLMONITOR
38c6				endif 
38c6 c3 c1 24			jp exec1 
38c9			 
38c9					 
38c9			 
38c9			 
38c9					NEXTW 
38c9 c3 38 24			jp macro_next 
38cc				endm 
# End of macro NEXTW
38cc			.I:  
38cc			 
38cc				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
38cc 5e				db WORD_SYS_CORE+74             
38cd f7 38			dw .DLOOP            
38cf 02				db 1 + 1 
38d0 .. 00			db "I",0              
38d2				endm 
# End of macro CWHEAD
38d2			; | I ( -- ) Current loop counter | DONE 
38d2					if DEBUG_FORTH_WORDS_KEY 
38d2						DMARK "I.." 
38d2 f5				push af  
38d3 3a e7 38			ld a, (.dmark)  
38d6 32 a0 fd			ld (debug_mark),a  
38d9 3a e8 38			ld a, (.dmark+1)  
38dc 32 a1 fd			ld (debug_mark+1),a  
38df 3a e9 38			ld a, (.dmark+2)  
38e2 32 a2 fd			ld (debug_mark+2),a  
38e5 18 03			jr .pastdmark  
38e7 ..			.dmark: db "I.."  
38ea f1			.pastdmark: pop af  
38eb			endm  
# End of macro DMARK
38eb						CALLMONITOR 
38eb cd aa fd			call debug_vector  
38ee				endm  
# End of macro CALLMONITOR
38ee					endif 
38ee			 
38ee 2a 1b f4				ld hl,(os_current_i) 
38f1 cd 48 20				call forth_push_numhl 
38f4			 
38f4					NEXTW 
38f4 c3 38 24			jp macro_next 
38f7				endm 
# End of macro NEXTW
38f7			.DLOOP: 
38f7				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
38f7 5f				db WORD_SYS_CORE+75             
38f8 d8 39			dw .REPEAT            
38fa 06				db 5 + 1 
38fb .. 00			db "-LOOP",0              
3901				endm 
# End of macro CWHEAD
3901			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3901				; pop tos as current loop count to hl 
3901					if DEBUG_FORTH_WORDS_KEY 
3901						DMARK "-LP" 
3901 f5				push af  
3902 3a 16 39			ld a, (.dmark)  
3905 32 a0 fd			ld (debug_mark),a  
3908 3a 17 39			ld a, (.dmark+1)  
390b 32 a1 fd			ld (debug_mark+1),a  
390e 3a 18 39			ld a, (.dmark+2)  
3911 32 a2 fd			ld (debug_mark+2),a  
3914 18 03			jr .pastdmark  
3916 ..			.dmark: db "-LP"  
3919 f1			.pastdmark: pop af  
391a			endm  
# End of macro DMARK
391a						CALLMONITOR 
391a cd aa fd			call debug_vector  
391d				endm  
# End of macro CALLMONITOR
391d					endif 
391d			 
391d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
391d			 
391d				FORTH_LOOP_TOS 
391d cd b1 22			call macro_forth_loop_tos 
3920				endm 
# End of macro FORTH_LOOP_TOS
3920 e5				push hl 
3921			 
3921					if DEBUG_FORTH_WORDS 
3921						DMARK "-LP" 
3921 f5				push af  
3922 3a 36 39			ld a, (.dmark)  
3925 32 a0 fd			ld (debug_mark),a  
3928 3a 37 39			ld a, (.dmark+1)  
392b 32 a1 fd			ld (debug_mark+1),a  
392e 3a 38 39			ld a, (.dmark+2)  
3931 32 a2 fd			ld (debug_mark+2),a  
3934 18 03			jr .pastdmark  
3936 ..			.dmark: db "-LP"  
3939 f1			.pastdmark: pop af  
393a			endm  
# End of macro DMARK
393a						CALLMONITOR 
393a cd aa fd			call debug_vector  
393d				endm  
# End of macro CALLMONITOR
393d					endif 
393d				; next item on the stack is the limit. get it 
393d			 
393d			 
393d				FORTH_LOOP_POP 
393d cd bb 22			call macro_forth_loop_pop 
3940				endm 
# End of macro FORTH_LOOP_POP
3940			 
3940				FORTH_LOOP_TOS 
3940 cd b1 22			call macro_forth_loop_tos 
3943				endm 
# End of macro FORTH_LOOP_TOS
3943			 
3943 d1				pop de		 ; de = i, hl = limit 
3944			 
3944					if DEBUG_FORTH_WORDS 
3944						DMARK "-L1" 
3944 f5				push af  
3945 3a 59 39			ld a, (.dmark)  
3948 32 a0 fd			ld (debug_mark),a  
394b 3a 5a 39			ld a, (.dmark+1)  
394e 32 a1 fd			ld (debug_mark+1),a  
3951 3a 5b 39			ld a, (.dmark+2)  
3954 32 a2 fd			ld (debug_mark+2),a  
3957 18 03			jr .pastdmark  
3959 ..			.dmark: db "-L1"  
395c f1			.pastdmark: pop af  
395d			endm  
# End of macro DMARK
395d						CALLMONITOR 
395d cd aa fd			call debug_vector  
3960				endm  
# End of macro CALLMONITOR
3960					endif 
3960			 
3960				; go back to previous word 
3960			 
3960 d5				push de    ; save I for inc later 
3961			 
3961			 
3961				; get limit 
3961				;  is I at limit? 
3961			 
3961			 
3961					if DEBUG_FORTH_WORDS 
3961						DMARK "-L1" 
3961 f5				push af  
3962 3a 76 39			ld a, (.dmark)  
3965 32 a0 fd			ld (debug_mark),a  
3968 3a 77 39			ld a, (.dmark+1)  
396b 32 a1 fd			ld (debug_mark+1),a  
396e 3a 78 39			ld a, (.dmark+2)  
3971 32 a2 fd			ld (debug_mark+2),a  
3974 18 03			jr .pastdmark  
3976 ..			.dmark: db "-L1"  
3979 f1			.pastdmark: pop af  
397a			endm  
# End of macro DMARK
397a						CALLMONITOR 
397a cd aa fd			call debug_vector  
397d				endm  
# End of macro CALLMONITOR
397d					endif 
397d			 
397d ed 52			sbc hl, de 
397f			 
397f			 
397f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
397f			 
397f 20 26				jr nz, .mloopnotdone 
3981			 
3981 e1				pop hl   ; get rid of saved I 
3982				FORTH_LOOP_POP     ; get rid of limit 
3982 cd bb 22			call macro_forth_loop_pop 
3985				endm 
# End of macro FORTH_LOOP_POP
3985			 
3985				FORTH_RSP_POP     ; get rid of DO ptr 
3985 cd 10 20			call macro_forth_rsp_pop 
3988				endm 
# End of macro FORTH_RSP_POP
3988			 
3988			if DEBUG_FORTH_WORDS 
3988						DMARK "-L>" 
3988 f5				push af  
3989 3a 9d 39			ld a, (.dmark)  
398c 32 a0 fd			ld (debug_mark),a  
398f 3a 9e 39			ld a, (.dmark+1)  
3992 32 a1 fd			ld (debug_mark+1),a  
3995 3a 9f 39			ld a, (.dmark+2)  
3998 32 a2 fd			ld (debug_mark+2),a  
399b 18 03			jr .pastdmark  
399d ..			.dmark: db "-L>"  
39a0 f1			.pastdmark: pop af  
39a1			endm  
# End of macro DMARK
39a1				CALLMONITOR 
39a1 cd aa fd			call debug_vector  
39a4				endm  
# End of macro CALLMONITOR
39a4			endif 
39a4			 
39a4					NEXTW 
39a4 c3 38 24			jp macro_next 
39a7				endm 
# End of macro NEXTW
39a7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
39a7			 
39a7			.mloopnotdone: 
39a7			 
39a7 e1				pop hl    ; get I 
39a8 2b				dec hl 
39a9			 
39a9			   	; save new I 
39a9			 
39a9			 
39a9					; set I counter 
39a9			 
39a9 22 1b f4				ld (os_current_i), hl 
39ac			 
39ac					 
39ac				FORTH_LOOP_NEXT 
39ac cd 7e 22			call macro_forth_loop_next 
39af				endm 
# End of macro FORTH_LOOP_NEXT
39af			 
39af			 
39af					if DEBUG_FORTH_WORDS 
39af eb						ex de,hl 
39b0					endif 
39b0			 
39b0			;	; get DO ptr 
39b0			; 
39b0				FORTH_RSP_TOS 
39b0 cd 06 20			call macro_forth_rsp_tos 
39b3				endm 
# End of macro FORTH_RSP_TOS
39b3			 
39b3				;push hl 
39b3			 
39b3				; not going to DO any more 
39b3				; get rid of the RSP pointer as DO will add it back in 
39b3				;FORTH_RSP_POP 
39b3				;pop hl 
39b3			 
39b3			 
39b3 22 f7 f3			ld (os_tok_ptr), hl 
39b6					if DEBUG_FORTH_WORDS 
39b6						DMARK "-L<" 
39b6 f5				push af  
39b7 3a cb 39			ld a, (.dmark)  
39ba 32 a0 fd			ld (debug_mark),a  
39bd 3a cc 39			ld a, (.dmark+1)  
39c0 32 a1 fd			ld (debug_mark+1),a  
39c3 3a cd 39			ld a, (.dmark+2)  
39c6 32 a2 fd			ld (debug_mark+2),a  
39c9 18 03			jr .pastdmark  
39cb ..			.dmark: db "-L<"  
39ce f1			.pastdmark: pop af  
39cf			endm  
# End of macro DMARK
39cf					CALLMONITOR 
39cf cd aa fd			call debug_vector  
39d2				endm  
# End of macro CALLMONITOR
39d2				endif 
39d2 c3 c1 24			jp exec1 
39d5			 
39d5					 
39d5			 
39d5			 
39d5			 
39d5				NEXTW 
39d5 c3 38 24			jp macro_next 
39d8				endm 
# End of macro NEXTW
39d8			 
39d8			 
39d8			 
39d8			 
39d8			.REPEAT: 
39d8				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
39d8 71				db WORD_SYS_CORE+93             
39d9 2b 3a			dw .UNTIL            
39db 06				db 5 + 1 
39dc .. 00			db "REPEAT",0              
39e3				endm 
# End of macro CWHEAD
39e3			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
39e3			;  push pc to rsp stack past the REPEAT 
39e3					if DEBUG_FORTH_WORDS_KEY 
39e3						DMARK "REP" 
39e3 f5				push af  
39e4 3a f8 39			ld a, (.dmark)  
39e7 32 a0 fd			ld (debug_mark),a  
39ea 3a f9 39			ld a, (.dmark+1)  
39ed 32 a1 fd			ld (debug_mark+1),a  
39f0 3a fa 39			ld a, (.dmark+2)  
39f3 32 a2 fd			ld (debug_mark+2),a  
39f6 18 03			jr .pastdmark  
39f8 ..			.dmark: db "REP"  
39fb f1			.pastdmark: pop af  
39fc			endm  
# End of macro DMARK
39fc						CALLMONITOR 
39fc cd aa fd			call debug_vector  
39ff				endm  
# End of macro CALLMONITOR
39ff					endif 
39ff			 
39ff 2a f7 f3				ld hl, (os_tok_ptr) 
3a02 23					inc hl   ; R 
3a03 23					inc hl  ; E 
3a04 23					inc hl   ; P 
3a05 23					inc hl   ; E 
3a06 23					inc hl   ; A 
3a07 23					inc hl   ; T 
3a08 23					inc hl   ; zero 
3a09					FORTH_RSP_NEXT 
3a09 cd ef 1f			call macro_forth_rsp_next 
3a0c				endm 
# End of macro FORTH_RSP_NEXT
3a0c			 
3a0c			 
3a0c					if DEBUG_FORTH_WORDS 
3a0c						DMARK "REP" 
3a0c f5				push af  
3a0d 3a 21 3a			ld a, (.dmark)  
3a10 32 a0 fd			ld (debug_mark),a  
3a13 3a 22 3a			ld a, (.dmark+1)  
3a16 32 a1 fd			ld (debug_mark+1),a  
3a19 3a 23 3a			ld a, (.dmark+2)  
3a1c 32 a2 fd			ld (debug_mark+2),a  
3a1f 18 03			jr .pastdmark  
3a21 ..			.dmark: db "REP"  
3a24 f1			.pastdmark: pop af  
3a25			endm  
# End of macro DMARK
3a25						;pop bc    ; TODO BUG ?????? what is this for???? 
3a25						CALLMONITOR 
3a25 cd aa fd			call debug_vector  
3a28				endm  
# End of macro CALLMONITOR
3a28					endif 
3a28			 
3a28					NEXTW 
3a28 c3 38 24			jp macro_next 
3a2b				endm 
# End of macro NEXTW
3a2b			;	       NEXTW 
3a2b			 
3a2b			.UNTIL: 
3a2b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3a2b 72				db WORD_SYS_CORE+94             
3a2c c2 3a			dw .ENDFLOW            
3a2e 06				db 5 + 1 
3a2f .. 00			db "UNTIL",0              
3a35				endm 
# End of macro CWHEAD
3a35			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3a35			 
3a35				; pop tos as check 
3a35			 
3a35				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3a35			 
3a35				FORTH_DSP_VALUEHL 
3a35 cd 4d 22			call macro_dsp_valuehl 
3a38				endm 
# End of macro FORTH_DSP_VALUEHL
3a38			 
3a38					if DEBUG_FORTH_WORDS_KEY 
3a38						DMARK "UNT" 
3a38 f5				push af  
3a39 3a 4d 3a			ld a, (.dmark)  
3a3c 32 a0 fd			ld (debug_mark),a  
3a3f 3a 4e 3a			ld a, (.dmark+1)  
3a42 32 a1 fd			ld (debug_mark+1),a  
3a45 3a 4f 3a			ld a, (.dmark+2)  
3a48 32 a2 fd			ld (debug_mark+2),a  
3a4b 18 03			jr .pastdmark  
3a4d ..			.dmark: db "UNT"  
3a50 f1			.pastdmark: pop af  
3a51			endm  
# End of macro DMARK
3a51						CALLMONITOR 
3a51 cd aa fd			call debug_vector  
3a54				endm  
# End of macro CALLMONITOR
3a54					endif 
3a54			 
3a54			;	push hl 
3a54				FORTH_DSP_POP 
3a54 cd 05 23			call macro_forth_dsp_pop 
3a57				endm 
# End of macro FORTH_DSP_POP
3a57			 
3a57			;	pop hl 
3a57			 
3a57				; test if true 
3a57			 
3a57 cd 07 10			call ishlzero 
3a5a			;	ld a,l 
3a5a			;	add h 
3a5a			; 
3a5a			;	cp 0 
3a5a			 
3a5a 20 3e			jr nz, .untilnotdone 
3a5c			 
3a5c					if DEBUG_FORTH_WORDS 
3a5c						DMARK "UNf" 
3a5c f5				push af  
3a5d 3a 71 3a			ld a, (.dmark)  
3a60 32 a0 fd			ld (debug_mark),a  
3a63 3a 72 3a			ld a, (.dmark+1)  
3a66 32 a1 fd			ld (debug_mark+1),a  
3a69 3a 73 3a			ld a, (.dmark+2)  
3a6c 32 a2 fd			ld (debug_mark+2),a  
3a6f 18 03			jr .pastdmark  
3a71 ..			.dmark: db "UNf"  
3a74 f1			.pastdmark: pop af  
3a75			endm  
# End of macro DMARK
3a75						CALLMONITOR 
3a75 cd aa fd			call debug_vector  
3a78				endm  
# End of macro CALLMONITOR
3a78					endif 
3a78			 
3a78			 
3a78			 
3a78				FORTH_RSP_POP     ; get rid of DO ptr 
3a78 cd 10 20			call macro_forth_rsp_pop 
3a7b				endm 
# End of macro FORTH_RSP_POP
3a7b			 
3a7b			if DEBUG_FORTH_WORDS 
3a7b						DMARK "UN>" 
3a7b f5				push af  
3a7c 3a 90 3a			ld a, (.dmark)  
3a7f 32 a0 fd			ld (debug_mark),a  
3a82 3a 91 3a			ld a, (.dmark+1)  
3a85 32 a1 fd			ld (debug_mark+1),a  
3a88 3a 92 3a			ld a, (.dmark+2)  
3a8b 32 a2 fd			ld (debug_mark+2),a  
3a8e 18 03			jr .pastdmark  
3a90 ..			.dmark: db "UN>"  
3a93 f1			.pastdmark: pop af  
3a94			endm  
# End of macro DMARK
3a94				CALLMONITOR 
3a94 cd aa fd			call debug_vector  
3a97				endm  
# End of macro CALLMONITOR
3a97			endif 
3a97			 
3a97					NEXTW 
3a97 c3 38 24			jp macro_next 
3a9a				endm 
# End of macro NEXTW
3a9a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3a9a			 
3a9a			.untilnotdone: 
3a9a			 
3a9a			 
3a9a			;	; get DO ptr 
3a9a			; 
3a9a				FORTH_RSP_TOS 
3a9a cd 06 20			call macro_forth_rsp_tos 
3a9d				endm 
# End of macro FORTH_RSP_TOS
3a9d			 
3a9d				;push hl 
3a9d			 
3a9d				; not going to DO any more 
3a9d				; get rid of the RSP pointer as DO will add it back in 
3a9d				;FORTH_RSP_POP 
3a9d				;pop hl 
3a9d			 
3a9d			 
3a9d 22 f7 f3			ld (os_tok_ptr), hl 
3aa0					if DEBUG_FORTH_WORDS 
3aa0						DMARK "UN<" 
3aa0 f5				push af  
3aa1 3a b5 3a			ld a, (.dmark)  
3aa4 32 a0 fd			ld (debug_mark),a  
3aa7 3a b6 3a			ld a, (.dmark+1)  
3aaa 32 a1 fd			ld (debug_mark+1),a  
3aad 3a b7 3a			ld a, (.dmark+2)  
3ab0 32 a2 fd			ld (debug_mark+2),a  
3ab3 18 03			jr .pastdmark  
3ab5 ..			.dmark: db "UN<"  
3ab8 f1			.pastdmark: pop af  
3ab9			endm  
# End of macro DMARK
3ab9					CALLMONITOR 
3ab9 cd aa fd			call debug_vector  
3abc				endm  
# End of macro CALLMONITOR
3abc				endif 
3abc c3 c1 24			jp exec1 
3abf			 
3abf					 
3abf			 
3abf			 
3abf					NEXTW 
3abf c3 38 24			jp macro_next 
3ac2				endm 
# End of macro NEXTW
3ac2			 
3ac2			 
3ac2			.ENDFLOW: 
3ac2			 
3ac2			; eof 
3ac2			 
# End of file forth_words_flow.asm
3ac2			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3ac2			include "forth_words_logic.asm" 
3ac2			 
3ac2			; | ## Logic Words 
3ac2			 
3ac2			.NOT: 
3ac2				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3ac2 2d				db WORD_SYS_CORE+25             
3ac3 0a 3b			dw .IS            
3ac5 04				db 3 + 1 
3ac6 .. 00			db "NOT",0              
3aca				endm 
# End of macro CWHEAD
3aca			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3aca					if DEBUG_FORTH_WORDS_KEY 
3aca						DMARK "NOT" 
3aca f5				push af  
3acb 3a df 3a			ld a, (.dmark)  
3ace 32 a0 fd			ld (debug_mark),a  
3ad1 3a e0 3a			ld a, (.dmark+1)  
3ad4 32 a1 fd			ld (debug_mark+1),a  
3ad7 3a e1 3a			ld a, (.dmark+2)  
3ada 32 a2 fd			ld (debug_mark+2),a  
3add 18 03			jr .pastdmark  
3adf ..			.dmark: db "NOT"  
3ae2 f1			.pastdmark: pop af  
3ae3			endm  
# End of macro DMARK
3ae3						CALLMONITOR 
3ae3 cd aa fd			call debug_vector  
3ae6				endm  
# End of macro CALLMONITOR
3ae6					endif 
3ae6					FORTH_DSP 
3ae6 cd 13 22			call macro_forth_dsp 
3ae9				endm 
# End of macro FORTH_DSP
3ae9 7e					ld a,(hl)	; get type of value on TOS 
3aea fe 02				cp DS_TYPE_INUM  
3aec 28 03				jr z, .noti 
3aee					NEXTW 
3aee c3 38 24			jp macro_next 
3af1				endm 
# End of macro NEXTW
3af1			.noti:          FORTH_DSP_VALUEHL 
3af1 cd 4d 22			call macro_dsp_valuehl 
3af4				endm 
# End of macro FORTH_DSP_VALUEHL
3af4			;		push hl 
3af4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3af4 cd 05 23			call macro_forth_dsp_pop 
3af7				endm 
# End of macro FORTH_DSP_POP
3af7			;		pop hl 
3af7 3e 00				ld a,0 
3af9 bd					cp l 
3afa 28 04				jr z, .not2t 
3afc 2e 00				ld l, 0 
3afe 18 02				jr .notip 
3b00			 
3b00 2e ff		.not2t:		ld l, 255 
3b02			 
3b02 26 00		.notip:		ld h, 0	 
3b04			 
3b04 cd 48 20				call forth_push_numhl 
3b07					NEXTW 
3b07 c3 38 24			jp macro_next 
3b0a				endm 
# End of macro NEXTW
3b0a			 
3b0a			.IS: 
3b0a				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3b0a 2d				db WORD_SYS_CORE+25             
3b0b 30 3b			dw .LZERO            
3b0d 03				db 2 + 1 
3b0e .. 00			db "IS",0              
3b11				endm 
# End of macro CWHEAD
3b11			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3b11					if DEBUG_FORTH_WORDS_KEY 
3b11						DMARK "IS." 
3b11 f5				push af  
3b12 3a 26 3b			ld a, (.dmark)  
3b15 32 a0 fd			ld (debug_mark),a  
3b18 3a 27 3b			ld a, (.dmark+1)  
3b1b 32 a1 fd			ld (debug_mark+1),a  
3b1e 3a 28 3b			ld a, (.dmark+2)  
3b21 32 a2 fd			ld (debug_mark+2),a  
3b24 18 03			jr .pastdmark  
3b26 ..			.dmark: db "IS."  
3b29 f1			.pastdmark: pop af  
3b2a			endm  
# End of macro DMARK
3b2a						CALLMONITOR 
3b2a cd aa fd			call debug_vector  
3b2d				endm  
# End of macro CALLMONITOR
3b2d					endif 
3b2d					NEXTW 
3b2d c3 38 24			jp macro_next 
3b30				endm 
# End of macro NEXTW
3b30			.LZERO: 
3b30				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3b30 2d				db WORD_SYS_CORE+25             
3b31 3a 3b			dw .TZERO            
3b33 03				db 2 + 1 
3b34 .. 00			db "0<",0              
3b37				endm 
# End of macro CWHEAD
3b37			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3b37					NEXTW 
3b37 c3 38 24			jp macro_next 
3b3a				endm 
# End of macro NEXTW
3b3a			.TZERO: 
3b3a				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3b3a 2e				db WORD_SYS_CORE+26             
3b3b 81 3b			dw .LESS            
3b3d 03				db 2 + 1 
3b3e .. 00			db "0=",0              
3b41				endm 
# End of macro CWHEAD
3b41			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3b41				; TODO add floating point number detection 
3b41					;v5 FORTH_DSP_VALUE 
3b41					if DEBUG_FORTH_WORDS_KEY 
3b41						DMARK "0=." 
3b41 f5				push af  
3b42 3a 56 3b			ld a, (.dmark)  
3b45 32 a0 fd			ld (debug_mark),a  
3b48 3a 57 3b			ld a, (.dmark+1)  
3b4b 32 a1 fd			ld (debug_mark+1),a  
3b4e 3a 58 3b			ld a, (.dmark+2)  
3b51 32 a2 fd			ld (debug_mark+2),a  
3b54 18 03			jr .pastdmark  
3b56 ..			.dmark: db "0=."  
3b59 f1			.pastdmark: pop af  
3b5a			endm  
# End of macro DMARK
3b5a						CALLMONITOR 
3b5a cd aa fd			call debug_vector  
3b5d				endm  
# End of macro CALLMONITOR
3b5d					endif 
3b5d					FORTH_DSP 
3b5d cd 13 22			call macro_forth_dsp 
3b60				endm 
# End of macro FORTH_DSP
3b60 7e					ld a,(hl)	; get type of value on TOS 
3b61 fe 02				cp DS_TYPE_INUM  
3b63 28 00				jr z, .tz_inum 
3b65			 
3b65				if FORTH_ENABLE_FLOATMATH 
3b65					jr .tz_done 
3b65			 
3b65				endif 
3b65					 
3b65			 
3b65			.tz_inum: 
3b65					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b65 cd 4d 22			call macro_dsp_valuehl 
3b68				endm 
# End of macro FORTH_DSP_VALUEHL
3b68			 
3b68			;		push hl 
3b68			 
3b68					; destroy value TOS 
3b68			 
3b68					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b68 cd 05 23			call macro_forth_dsp_pop 
3b6b				endm 
# End of macro FORTH_DSP_POP
3b6b			 
3b6b			;		pop hl 
3b6b			 
3b6b 3e 00				ld a,0 
3b6d			 
3b6d bd					cp l 
3b6e 20 08				jr nz, .tz_notzero 
3b70			 
3b70 bc					cp h 
3b71			 
3b71 20 05				jr nz, .tz_notzero 
3b73			 
3b73			 
3b73 21 01 00				ld hl, FORTH_TRUE 
3b76 18 03				jr .tz_done 
3b78			 
3b78 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3b7b			 
3b7b					; push value back onto stack for another op etc 
3b7b			 
3b7b			.tz_done: 
3b7b cd 48 20				call forth_push_numhl 
3b7e			 
3b7e					NEXTW 
3b7e c3 38 24			jp macro_next 
3b81				endm 
# End of macro NEXTW
3b81			.LESS: 
3b81				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3b81 2f				db WORD_SYS_CORE+27             
3b82 ea 3b			dw .GT            
3b84 02				db 1 + 1 
3b85 .. 00			db "<",0              
3b87				endm 
# End of macro CWHEAD
3b87			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3b87				; TODO add floating point number detection 
3b87					if DEBUG_FORTH_WORDS_KEY 
3b87						DMARK "LES" 
3b87 f5				push af  
3b88 3a 9c 3b			ld a, (.dmark)  
3b8b 32 a0 fd			ld (debug_mark),a  
3b8e 3a 9d 3b			ld a, (.dmark+1)  
3b91 32 a1 fd			ld (debug_mark+1),a  
3b94 3a 9e 3b			ld a, (.dmark+2)  
3b97 32 a2 fd			ld (debug_mark+2),a  
3b9a 18 03			jr .pastdmark  
3b9c ..			.dmark: db "LES"  
3b9f f1			.pastdmark: pop af  
3ba0			endm  
# End of macro DMARK
3ba0						CALLMONITOR 
3ba0 cd aa fd			call debug_vector  
3ba3				endm  
# End of macro CALLMONITOR
3ba3					endif 
3ba3					FORTH_DSP 
3ba3 cd 13 22			call macro_forth_dsp 
3ba6				endm 
# End of macro FORTH_DSP
3ba6					;v5 FORTH_DSP_VALUE 
3ba6 7e					ld a,(hl)	; get type of value on TOS 
3ba7 fe 02				cp DS_TYPE_INUM  
3ba9 28 00				jr z, .less_inum 
3bab			 
3bab				if FORTH_ENABLE_FLOATMATH 
3bab					jr .less_done 
3bab			 
3bab				endif 
3bab					 
3bab			 
3bab			.less_inum: 
3bab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bab cd 4d 22			call macro_dsp_valuehl 
3bae				endm 
# End of macro FORTH_DSP_VALUEHL
3bae			 
3bae e5					push hl  ; u2 
3baf			 
3baf					; destroy value TOS 
3baf			 
3baf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3baf cd 05 23			call macro_forth_dsp_pop 
3bb2				endm 
# End of macro FORTH_DSP_POP
3bb2			 
3bb2			 
3bb2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bb2 cd 4d 22			call macro_dsp_valuehl 
3bb5				endm 
# End of macro FORTH_DSP_VALUEHL
3bb5			 
3bb5 e5					push hl    ; u1 
3bb6			 
3bb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb6 cd 05 23			call macro_forth_dsp_pop 
3bb9				endm 
# End of macro FORTH_DSP_POP
3bb9			 
3bb9			 
3bb9 b7			 or a      ;clear carry flag 
3bba 01 00 00		 ld bc, FORTH_FALSE 
3bbd e1			  pop hl    ; u1 
3bbe d1			  pop de    ; u2 
3bbf ed 52		  sbc hl,de 
3bc1 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3bc3			 
3bc3 01 01 00		 ld bc, FORTH_TRUE 
3bc6			.lscont:  
3bc6 c5					push bc 
3bc7 e1					pop hl 
3bc8			 
3bc8					if DEBUG_FORTH_WORDS 
3bc8						DMARK "LT1" 
3bc8 f5				push af  
3bc9 3a dd 3b			ld a, (.dmark)  
3bcc 32 a0 fd			ld (debug_mark),a  
3bcf 3a de 3b			ld a, (.dmark+1)  
3bd2 32 a1 fd			ld (debug_mark+1),a  
3bd5 3a df 3b			ld a, (.dmark+2)  
3bd8 32 a2 fd			ld (debug_mark+2),a  
3bdb 18 03			jr .pastdmark  
3bdd ..			.dmark: db "LT1"  
3be0 f1			.pastdmark: pop af  
3be1			endm  
# End of macro DMARK
3be1						CALLMONITOR 
3be1 cd aa fd			call debug_vector  
3be4				endm  
# End of macro CALLMONITOR
3be4					endif 
3be4 cd 48 20				call forth_push_numhl 
3be7			 
3be7					NEXTW 
3be7 c3 38 24			jp macro_next 
3bea				endm 
# End of macro NEXTW
3bea			.GT: 
3bea				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3bea 30				db WORD_SYS_CORE+28             
3beb 53 3c			dw .EQUAL            
3bed 02				db 1 + 1 
3bee .. 00			db ">",0              
3bf0				endm 
# End of macro CWHEAD
3bf0			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3bf0				; TODO add floating point number detection 
3bf0					if DEBUG_FORTH_WORDS_KEY 
3bf0						DMARK "GRT" 
3bf0 f5				push af  
3bf1 3a 05 3c			ld a, (.dmark)  
3bf4 32 a0 fd			ld (debug_mark),a  
3bf7 3a 06 3c			ld a, (.dmark+1)  
3bfa 32 a1 fd			ld (debug_mark+1),a  
3bfd 3a 07 3c			ld a, (.dmark+2)  
3c00 32 a2 fd			ld (debug_mark+2),a  
3c03 18 03			jr .pastdmark  
3c05 ..			.dmark: db "GRT"  
3c08 f1			.pastdmark: pop af  
3c09			endm  
# End of macro DMARK
3c09						CALLMONITOR 
3c09 cd aa fd			call debug_vector  
3c0c				endm  
# End of macro CALLMONITOR
3c0c					endif 
3c0c					FORTH_DSP 
3c0c cd 13 22			call macro_forth_dsp 
3c0f				endm 
# End of macro FORTH_DSP
3c0f					;FORTH_DSP_VALUE 
3c0f 7e					ld a,(hl)	; get type of value on TOS 
3c10 fe 02				cp DS_TYPE_INUM  
3c12 28 00				jr z, .gt_inum 
3c14			 
3c14				if FORTH_ENABLE_FLOATMATH 
3c14					jr .gt_done 
3c14			 
3c14				endif 
3c14					 
3c14			 
3c14			.gt_inum: 
3c14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c14 cd 4d 22			call macro_dsp_valuehl 
3c17				endm 
# End of macro FORTH_DSP_VALUEHL
3c17			 
3c17 e5					push hl  ; u2 
3c18			 
3c18					; destroy value TOS 
3c18			 
3c18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c18 cd 05 23			call macro_forth_dsp_pop 
3c1b				endm 
# End of macro FORTH_DSP_POP
3c1b			 
3c1b			 
3c1b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c1b cd 4d 22			call macro_dsp_valuehl 
3c1e				endm 
# End of macro FORTH_DSP_VALUEHL
3c1e			 
3c1e e5					push hl    ; u1 
3c1f			 
3c1f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c1f cd 05 23			call macro_forth_dsp_pop 
3c22				endm 
# End of macro FORTH_DSP_POP
3c22			 
3c22			 
3c22 b7			 or a      ;clear carry flag 
3c23 01 00 00		 ld bc, FORTH_FALSE 
3c26 e1			  pop hl    ; u1 
3c27 d1			  pop de    ; u2 
3c28 ed 52		  sbc hl,de 
3c2a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3c2c			 
3c2c 01 01 00		 ld bc, FORTH_TRUE 
3c2f			.gtcont:  
3c2f c5					push bc 
3c30 e1					pop hl 
3c31			 
3c31					if DEBUG_FORTH_WORDS 
3c31						DMARK "GT1" 
3c31 f5				push af  
3c32 3a 46 3c			ld a, (.dmark)  
3c35 32 a0 fd			ld (debug_mark),a  
3c38 3a 47 3c			ld a, (.dmark+1)  
3c3b 32 a1 fd			ld (debug_mark+1),a  
3c3e 3a 48 3c			ld a, (.dmark+2)  
3c41 32 a2 fd			ld (debug_mark+2),a  
3c44 18 03			jr .pastdmark  
3c46 ..			.dmark: db "GT1"  
3c49 f1			.pastdmark: pop af  
3c4a			endm  
# End of macro DMARK
3c4a						CALLMONITOR 
3c4a cd aa fd			call debug_vector  
3c4d				endm  
# End of macro CALLMONITOR
3c4d					endif 
3c4d cd 48 20				call forth_push_numhl 
3c50			 
3c50					NEXTW 
3c50 c3 38 24			jp macro_next 
3c53				endm 
# End of macro NEXTW
3c53			.EQUAL: 
3c53				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3c53 31				db WORD_SYS_CORE+29             
3c54 be 3c			dw .ENDLOGIC            
3c56 02				db 1 + 1 
3c57 .. 00			db "=",0              
3c59				endm 
# End of macro CWHEAD
3c59			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3c59				; TODO add floating point number detection 
3c59					if DEBUG_FORTH_WORDS_KEY 
3c59						DMARK "EQ." 
3c59 f5				push af  
3c5a 3a 6e 3c			ld a, (.dmark)  
3c5d 32 a0 fd			ld (debug_mark),a  
3c60 3a 6f 3c			ld a, (.dmark+1)  
3c63 32 a1 fd			ld (debug_mark+1),a  
3c66 3a 70 3c			ld a, (.dmark+2)  
3c69 32 a2 fd			ld (debug_mark+2),a  
3c6c 18 03			jr .pastdmark  
3c6e ..			.dmark: db "EQ."  
3c71 f1			.pastdmark: pop af  
3c72			endm  
# End of macro DMARK
3c72						CALLMONITOR 
3c72 cd aa fd			call debug_vector  
3c75				endm  
# End of macro CALLMONITOR
3c75					endif 
3c75					FORTH_DSP 
3c75 cd 13 22			call macro_forth_dsp 
3c78				endm 
# End of macro FORTH_DSP
3c78					;v5 FORTH_DSP_VALUE 
3c78 7e					ld a,(hl)	; get type of value on TOS 
3c79 fe 02				cp DS_TYPE_INUM  
3c7b 28 00				jr z, .eq_inum 
3c7d			 
3c7d				if FORTH_ENABLE_FLOATMATH 
3c7d					jr .eq_done 
3c7d			 
3c7d				endif 
3c7d					 
3c7d			 
3c7d			.eq_inum: 
3c7d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c7d cd 4d 22			call macro_dsp_valuehl 
3c80				endm 
# End of macro FORTH_DSP_VALUEHL
3c80			 
3c80 e5					push hl 
3c81			 
3c81					; destroy value TOS 
3c81			 
3c81					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c81 cd 05 23			call macro_forth_dsp_pop 
3c84				endm 
# End of macro FORTH_DSP_POP
3c84			 
3c84			 
3c84					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c84 cd 4d 22			call macro_dsp_valuehl 
3c87				endm 
# End of macro FORTH_DSP_VALUEHL
3c87			 
3c87					; one value on hl get other one back 
3c87			 
3c87 e5					push hl 
3c88			 
3c88					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c88 cd 05 23			call macro_forth_dsp_pop 
3c8b				endm 
# End of macro FORTH_DSP_POP
3c8b			 
3c8b 0e 00				ld c, FORTH_FALSE 
3c8d			 
3c8d e1					pop hl 
3c8e d1					pop de 
3c8f			 
3c8f 7b					ld a, e 
3c90 bd					cp l 
3c91			 
3c91 20 06				jr nz, .eq_done 
3c93			 
3c93 7a					ld a, d 
3c94 bc					cp h 
3c95			 
3c95 20 02				jr nz, .eq_done 
3c97			 
3c97 0e 01				ld c, FORTH_TRUE 
3c99					 
3c99			 
3c99			 
3c99			.eq_done: 
3c99			 
3c99					; TODO push value back onto stack for another op etc 
3c99			 
3c99 26 00				ld h, 0 
3c9b 69					ld l, c 
3c9c					if DEBUG_FORTH_WORDS 
3c9c						DMARK "EQ1" 
3c9c f5				push af  
3c9d 3a b1 3c			ld a, (.dmark)  
3ca0 32 a0 fd			ld (debug_mark),a  
3ca3 3a b2 3c			ld a, (.dmark+1)  
3ca6 32 a1 fd			ld (debug_mark+1),a  
3ca9 3a b3 3c			ld a, (.dmark+2)  
3cac 32 a2 fd			ld (debug_mark+2),a  
3caf 18 03			jr .pastdmark  
3cb1 ..			.dmark: db "EQ1"  
3cb4 f1			.pastdmark: pop af  
3cb5			endm  
# End of macro DMARK
3cb5						CALLMONITOR 
3cb5 cd aa fd			call debug_vector  
3cb8				endm  
# End of macro CALLMONITOR
3cb8					endif 
3cb8 cd 48 20				call forth_push_numhl 
3cbb			 
3cbb					NEXTW 
3cbb c3 38 24			jp macro_next 
3cbe				endm 
# End of macro NEXTW
3cbe			 
3cbe			 
3cbe			.ENDLOGIC: 
3cbe			; eof 
3cbe			 
3cbe			 
# End of file forth_words_logic.asm
3cbe			include "forth_words_maths.asm" 
3cbe			 
3cbe			; | ## Maths Words 
3cbe			 
3cbe			.PLUS:	 
3cbe				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3cbe 15				db WORD_SYS_CORE+1             
3cbf 1c 3d			dw .NEG            
3cc1 02				db 1 + 1 
3cc2 .. 00			db "+",0              
3cc4				endm 
# End of macro CWHEAD
3cc4			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3cc4					if DEBUG_FORTH_WORDS_KEY 
3cc4						DMARK "PLU" 
3cc4 f5				push af  
3cc5 3a d9 3c			ld a, (.dmark)  
3cc8 32 a0 fd			ld (debug_mark),a  
3ccb 3a da 3c			ld a, (.dmark+1)  
3cce 32 a1 fd			ld (debug_mark+1),a  
3cd1 3a db 3c			ld a, (.dmark+2)  
3cd4 32 a2 fd			ld (debug_mark+2),a  
3cd7 18 03			jr .pastdmark  
3cd9 ..			.dmark: db "PLU"  
3cdc f1			.pastdmark: pop af  
3cdd			endm  
# End of macro DMARK
3cdd						CALLMONITOR 
3cdd cd aa fd			call debug_vector  
3ce0				endm  
# End of macro CALLMONITOR
3ce0					endif 
3ce0					; add top two values and push back result 
3ce0			 
3ce0					;for v5 FORTH_DSP_VALUE 
3ce0					FORTH_DSP 
3ce0 cd 13 22			call macro_forth_dsp 
3ce3				endm 
# End of macro FORTH_DSP
3ce3 7e					ld a,(hl)	; get type of value on TOS 
3ce4 fe 02				cp DS_TYPE_INUM  
3ce6 28 03				jr z, .dot_inum 
3ce8			 
3ce8					NEXTW 
3ce8 c3 38 24			jp macro_next 
3ceb				endm 
# End of macro NEXTW
3ceb			 
3ceb			; float maths 
3ceb			 
3ceb				if FORTH_ENABLE_FLOATMATH 
3ceb						inc hl      ; now at start of numeric as string 
3ceb			 
3ceb					if DEBUG_FORTH_MATHS 
3ceb						DMARK "ADD" 
3ceb				CALLMONITOR 
3ceb					endif 
3ceb			 
3ceb					;ld ix, hl 
3ceb					call CON 
3ceb			 
3ceb			 
3ceb					push hl 
3ceb					 
3ceb					 
3ceb			 
3ceb						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3ceb			 
3ceb					; get next number 
3ceb			 
3ceb						FORTH_DSP_VALUE 
3ceb			 
3ceb						inc hl      ; now at start of numeric as string 
3ceb			 
3ceb					;ld ix, hl 
3ceb					call CON 
3ceb			 
3ceb					push hl 
3ceb			 
3ceb			 
3ceb						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ceb			 
3ceb						; TODO do add 
3ceb			 
3ceb						call IADD 
3ceb			 
3ceb						; TODO get result back as ascii 
3ceb			 
3ceb						; TODO push result  
3ceb			 
3ceb			 
3ceb			 
3ceb						jr .dot_done 
3ceb				endif 
3ceb			 
3ceb			.dot_inum: 
3ceb			 
3ceb			 
3ceb					if DEBUG_FORTH_DOT 
3ceb						DMARK "+IT" 
3ceb f5				push af  
3cec 3a 00 3d			ld a, (.dmark)  
3cef 32 a0 fd			ld (debug_mark),a  
3cf2 3a 01 3d			ld a, (.dmark+1)  
3cf5 32 a1 fd			ld (debug_mark+1),a  
3cf8 3a 02 3d			ld a, (.dmark+2)  
3cfb 32 a2 fd			ld (debug_mark+2),a  
3cfe 18 03			jr .pastdmark  
3d00 ..			.dmark: db "+IT"  
3d03 f1			.pastdmark: pop af  
3d04			endm  
# End of macro DMARK
3d04				CALLMONITOR 
3d04 cd aa fd			call debug_vector  
3d07				endm  
# End of macro CALLMONITOR
3d07					endif 
3d07			 
3d07					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d07 cd 4d 22			call macro_dsp_valuehl 
3d0a				endm 
# End of macro FORTH_DSP_VALUEHL
3d0a			 
3d0a				; TODO add floating point number detection 
3d0a			 
3d0a e5					push hl 
3d0b			 
3d0b					; destroy value TOS 
3d0b			 
3d0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d0b cd 05 23			call macro_forth_dsp_pop 
3d0e				endm 
# End of macro FORTH_DSP_POP
3d0e			 
3d0e			 
3d0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d0e cd 4d 22			call macro_dsp_valuehl 
3d11				endm 
# End of macro FORTH_DSP_VALUEHL
3d11			 
3d11					; one value on hl get other one back 
3d11			 
3d11 d1					pop de 
3d12			 
3d12					; do the add 
3d12			 
3d12 19					add hl,de 
3d13			 
3d13					; save it 
3d13			 
3d13			;		push hl	 
3d13			 
3d13					; 
3d13			 
3d13					; destroy value TOS 
3d13			 
3d13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d13 cd 05 23			call macro_forth_dsp_pop 
3d16				endm 
# End of macro FORTH_DSP_POP
3d16			 
3d16					; TODO push value back onto stack for another op etc 
3d16			 
3d16			;		pop hl 
3d16			 
3d16			.dot_done: 
3d16 cd 48 20				call forth_push_numhl 
3d19			 
3d19					NEXTW 
3d19 c3 38 24			jp macro_next 
3d1c				endm 
# End of macro NEXTW
3d1c			.NEG: 
3d1c			 
3d1c				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3d1c 17				db WORD_SYS_CORE+3             
3d1d 5f 3d			dw .DIV            
3d1f 02				db 1 + 1 
3d20 .. 00			db "-",0              
3d22				endm 
# End of macro CWHEAD
3d22			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3d22					if DEBUG_FORTH_WORDS_KEY 
3d22						DMARK "SUB" 
3d22 f5				push af  
3d23 3a 37 3d			ld a, (.dmark)  
3d26 32 a0 fd			ld (debug_mark),a  
3d29 3a 38 3d			ld a, (.dmark+1)  
3d2c 32 a1 fd			ld (debug_mark+1),a  
3d2f 3a 39 3d			ld a, (.dmark+2)  
3d32 32 a2 fd			ld (debug_mark+2),a  
3d35 18 03			jr .pastdmark  
3d37 ..			.dmark: db "SUB"  
3d3a f1			.pastdmark: pop af  
3d3b			endm  
# End of macro DMARK
3d3b						CALLMONITOR 
3d3b cd aa fd			call debug_vector  
3d3e				endm  
# End of macro CALLMONITOR
3d3e					endif 
3d3e			 
3d3e			 
3d3e				; TODO add floating point number detection 
3d3e					; v5 FORTH_DSP_VALUE 
3d3e					FORTH_DSP 
3d3e cd 13 22			call macro_forth_dsp 
3d41				endm 
# End of macro FORTH_DSP
3d41 7e					ld a,(hl)	; get type of value on TOS 
3d42 fe 02				cp DS_TYPE_INUM  
3d44 28 03				jr z, .neg_inum 
3d46			 
3d46					NEXTW 
3d46 c3 38 24			jp macro_next 
3d49				endm 
# End of macro NEXTW
3d49			 
3d49			; float maths 
3d49			 
3d49				if FORTH_ENABLE_FLOATMATH 
3d49					jr .neg_done 
3d49			 
3d49				endif 
3d49					 
3d49			 
3d49			.neg_inum: 
3d49					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d49 cd 4d 22			call macro_dsp_valuehl 
3d4c				endm 
# End of macro FORTH_DSP_VALUEHL
3d4c			 
3d4c e5					push hl 
3d4d			 
3d4d					; destroy value TOS 
3d4d			 
3d4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d4d cd 05 23			call macro_forth_dsp_pop 
3d50				endm 
# End of macro FORTH_DSP_POP
3d50			 
3d50			 
3d50					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d50 cd 4d 22			call macro_dsp_valuehl 
3d53				endm 
# End of macro FORTH_DSP_VALUEHL
3d53			 
3d53					; one value on hl get other one back 
3d53			 
3d53 d1					pop de 
3d54			 
3d54					; do the sub 
3d54			;		ex de, hl 
3d54			 
3d54 ed 52				sbc hl,de 
3d56			 
3d56					; save it 
3d56			 
3d56			;		push hl	 
3d56			 
3d56					; 
3d56			 
3d56					; destroy value TOS 
3d56			 
3d56					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d56 cd 05 23			call macro_forth_dsp_pop 
3d59				endm 
# End of macro FORTH_DSP_POP
3d59			 
3d59					; TODO push value back onto stack for another op etc 
3d59			 
3d59			;		pop hl 
3d59			 
3d59 cd 48 20				call forth_push_numhl 
3d5c			.neg_done: 
3d5c			 
3d5c					NEXTW 
3d5c c3 38 24			jp macro_next 
3d5f				endm 
# End of macro NEXTW
3d5f			.DIV: 
3d5f				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3d5f 18				db WORD_SYS_CORE+4             
3d60 ac 3d			dw .MUL            
3d62 02				db 1 + 1 
3d63 .. 00			db "/",0              
3d65				endm 
# End of macro CWHEAD
3d65			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3d65					if DEBUG_FORTH_WORDS_KEY 
3d65						DMARK "DIV" 
3d65 f5				push af  
3d66 3a 7a 3d			ld a, (.dmark)  
3d69 32 a0 fd			ld (debug_mark),a  
3d6c 3a 7b 3d			ld a, (.dmark+1)  
3d6f 32 a1 fd			ld (debug_mark+1),a  
3d72 3a 7c 3d			ld a, (.dmark+2)  
3d75 32 a2 fd			ld (debug_mark+2),a  
3d78 18 03			jr .pastdmark  
3d7a ..			.dmark: db "DIV"  
3d7d f1			.pastdmark: pop af  
3d7e			endm  
# End of macro DMARK
3d7e						CALLMONITOR 
3d7e cd aa fd			call debug_vector  
3d81				endm  
# End of macro CALLMONITOR
3d81					endif 
3d81				; TODO add floating point number detection 
3d81					; v5 FORTH_DSP_VALUE 
3d81					FORTH_DSP 
3d81 cd 13 22			call macro_forth_dsp 
3d84				endm 
# End of macro FORTH_DSP
3d84 7e					ld a,(hl)	; get type of value on TOS 
3d85 fe 02				cp DS_TYPE_INUM  
3d87 28 03				jr z, .div_inum 
3d89			 
3d89				if FORTH_ENABLE_FLOATMATH 
3d89					jr .div_done 
3d89			 
3d89				endif 
3d89					NEXTW 
3d89 c3 38 24			jp macro_next 
3d8c				endm 
# End of macro NEXTW
3d8c			.div_inum: 
3d8c			 
3d8c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d8c cd 4d 22			call macro_dsp_valuehl 
3d8f				endm 
# End of macro FORTH_DSP_VALUEHL
3d8f			 
3d8f e5					push hl    ; to go to bc 
3d90			 
3d90					; destroy value TOS 
3d90			 
3d90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d90 cd 05 23			call macro_forth_dsp_pop 
3d93				endm 
# End of macro FORTH_DSP_POP
3d93			 
3d93			 
3d93					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d93 cd 4d 22			call macro_dsp_valuehl 
3d96				endm 
# End of macro FORTH_DSP_VALUEHL
3d96			 
3d96					; hl to go to de 
3d96			 
3d96 e5					push hl 
3d97			 
3d97 c1					pop bc 
3d98 d1					pop de		 
3d99			 
3d99			 
3d99					if DEBUG_FORTH_MATHS 
3d99						DMARK "DIV" 
3d99				CALLMONITOR 
3d99					endif 
3d99					; one value on hl but move to a get other one back 
3d99			 
3d99			        
3d99 cd 3b 0f			call Div16 
3d9c			 
3d9c			;	push af	 
3d9c e5				push hl 
3d9d c5				push bc 
3d9e			 
3d9e					if DEBUG_FORTH_MATHS 
3d9e						DMARK "DI1" 
3d9e				CALLMONITOR 
3d9e					endif 
3d9e			 
3d9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d9e cd 05 23			call macro_forth_dsp_pop 
3da1				endm 
# End of macro FORTH_DSP_POP
3da1			 
3da1			 
3da1			 
3da1 e1					pop hl    ; result 
3da2			 
3da2 cd 48 20				call forth_push_numhl 
3da5			 
3da5 e1					pop hl    ; reminder 
3da6			;		ld h,0 
3da6			;		ld l,d 
3da6			 
3da6 cd 48 20				call forth_push_numhl 
3da9			.div_done: 
3da9					NEXTW 
3da9 c3 38 24			jp macro_next 
3dac				endm 
# End of macro NEXTW
3dac			.MUL: 
3dac				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3dac 19				db WORD_SYS_CORE+5             
3dad f1 3d			dw .MIN            
3daf 02				db 1 + 1 
3db0 .. 00			db "*",0              
3db2				endm 
# End of macro CWHEAD
3db2			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3db2				; TODO add floating point number detection 
3db2					if DEBUG_FORTH_WORDS_KEY 
3db2						DMARK "MUL" 
3db2 f5				push af  
3db3 3a c7 3d			ld a, (.dmark)  
3db6 32 a0 fd			ld (debug_mark),a  
3db9 3a c8 3d			ld a, (.dmark+1)  
3dbc 32 a1 fd			ld (debug_mark+1),a  
3dbf 3a c9 3d			ld a, (.dmark+2)  
3dc2 32 a2 fd			ld (debug_mark+2),a  
3dc5 18 03			jr .pastdmark  
3dc7 ..			.dmark: db "MUL"  
3dca f1			.pastdmark: pop af  
3dcb			endm  
# End of macro DMARK
3dcb						CALLMONITOR 
3dcb cd aa fd			call debug_vector  
3dce				endm  
# End of macro CALLMONITOR
3dce					endif 
3dce					FORTH_DSP 
3dce cd 13 22			call macro_forth_dsp 
3dd1				endm 
# End of macro FORTH_DSP
3dd1					; v5 FORTH_DSP_VALUE 
3dd1 7e					ld a,(hl)	; get type of value on TOS 
3dd2 fe 02				cp DS_TYPE_INUM  
3dd4 28 03				jr z, .mul_inum 
3dd6			 
3dd6				if FORTH_ENABLE_FLOATMATH 
3dd6					jr .mul_done 
3dd6			 
3dd6				endif 
3dd6			 
3dd6					NEXTW 
3dd6 c3 38 24			jp macro_next 
3dd9				endm 
# End of macro NEXTW
3dd9			.mul_inum:	 
3dd9			 
3dd9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dd9 cd 4d 22			call macro_dsp_valuehl 
3ddc				endm 
# End of macro FORTH_DSP_VALUEHL
3ddc			 
3ddc e5					push hl 
3ddd			 
3ddd					; destroy value TOS 
3ddd			 
3ddd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ddd cd 05 23			call macro_forth_dsp_pop 
3de0				endm 
# End of macro FORTH_DSP_POP
3de0			 
3de0			 
3de0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3de0 cd 4d 22			call macro_dsp_valuehl 
3de3				endm 
# End of macro FORTH_DSP_VALUEHL
3de3			 
3de3					; one value on hl but move to a get other one back 
3de3			 
3de3 7d					ld a, l 
3de4			 
3de4 d1					pop de 
3de5			 
3de5					; do the mull 
3de5			;		ex de, hl 
3de5			 
3de5 cd 61 0f				call Mult16 
3de8					; save it 
3de8			 
3de8			;		push hl	 
3de8			 
3de8					; 
3de8			 
3de8					; destroy value TOS 
3de8			 
3de8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de8 cd 05 23			call macro_forth_dsp_pop 
3deb				endm 
# End of macro FORTH_DSP_POP
3deb			 
3deb					; TODO push value back onto stack for another op etc 
3deb			 
3deb			;		pop hl 
3deb			 
3deb cd 48 20				call forth_push_numhl 
3dee			 
3dee			.mul_done: 
3dee					NEXTW 
3dee c3 38 24			jp macro_next 
3df1				endm 
# End of macro NEXTW
3df1			 
3df1			 
3df1			 
3df1			 
3df1			.MIN: 
3df1				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3df1 49				db WORD_SYS_CORE+53             
3df2 72 3e			dw .MAX            
3df4 04				db 3 + 1 
3df5 .. 00			db "MIN",0              
3df9				endm 
# End of macro CWHEAD
3df9			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3df9					if DEBUG_FORTH_WORDS_KEY 
3df9						DMARK "MIN" 
3df9 f5				push af  
3dfa 3a 0e 3e			ld a, (.dmark)  
3dfd 32 a0 fd			ld (debug_mark),a  
3e00 3a 0f 3e			ld a, (.dmark+1)  
3e03 32 a1 fd			ld (debug_mark+1),a  
3e06 3a 10 3e			ld a, (.dmark+2)  
3e09 32 a2 fd			ld (debug_mark+2),a  
3e0c 18 03			jr .pastdmark  
3e0e ..			.dmark: db "MIN"  
3e11 f1			.pastdmark: pop af  
3e12			endm  
# End of macro DMARK
3e12						CALLMONITOR 
3e12 cd aa fd			call debug_vector  
3e15				endm  
# End of macro CALLMONITOR
3e15					endif 
3e15					; get u2 
3e15			 
3e15					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e15 cd 4d 22			call macro_dsp_valuehl 
3e18				endm 
# End of macro FORTH_DSP_VALUEHL
3e18			 
3e18 e5					push hl   ; u2 
3e19			 
3e19					; destroy value TOS 
3e19			 
3e19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e19 cd 05 23			call macro_forth_dsp_pop 
3e1c				endm 
# End of macro FORTH_DSP_POP
3e1c			 
3e1c					; get u1 
3e1c			 
3e1c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e1c cd 4d 22			call macro_dsp_valuehl 
3e1f				endm 
# End of macro FORTH_DSP_VALUEHL
3e1f			 
3e1f e5					push hl  ; u1 
3e20			 
3e20					; destroy value TOS 
3e20			 
3e20					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e20 cd 05 23			call macro_forth_dsp_pop 
3e23				endm 
# End of macro FORTH_DSP_POP
3e23			 
3e23 b7			 or a      ;clear carry flag 
3e24 e1			  pop hl    ; u1 
3e25 d1			  pop de    ; u2 
3e26 e5				push hl   ; saved in case hl is lowest 
3e27 ed 52		  sbc hl,de 
3e29 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3e2b			 
3e2b e1				pop hl 
3e2c					if DEBUG_FORTH_WORDS 
3e2c						DMARK "MIN" 
3e2c f5				push af  
3e2d 3a 41 3e			ld a, (.dmark)  
3e30 32 a0 fd			ld (debug_mark),a  
3e33 3a 42 3e			ld a, (.dmark+1)  
3e36 32 a1 fd			ld (debug_mark+1),a  
3e39 3a 43 3e			ld a, (.dmark+2)  
3e3c 32 a2 fd			ld (debug_mark+2),a  
3e3f 18 03			jr .pastdmark  
3e41 ..			.dmark: db "MIN"  
3e44 f1			.pastdmark: pop af  
3e45			endm  
# End of macro DMARK
3e45						CALLMONITOR 
3e45 cd aa fd			call debug_vector  
3e48				endm  
# End of macro CALLMONITOR
3e48					endif 
3e48 cd 48 20				call forth_push_numhl 
3e4b			 
3e4b				       NEXTW 
3e4b c3 38 24			jp macro_next 
3e4e				endm 
# End of macro NEXTW
3e4e			 
3e4e			.mincont:  
3e4e c1				pop bc   ; tidy up 
3e4f eb				ex de , hl  
3e50					if DEBUG_FORTH_WORDS 
3e50						DMARK "MI1" 
3e50 f5				push af  
3e51 3a 65 3e			ld a, (.dmark)  
3e54 32 a0 fd			ld (debug_mark),a  
3e57 3a 66 3e			ld a, (.dmark+1)  
3e5a 32 a1 fd			ld (debug_mark+1),a  
3e5d 3a 67 3e			ld a, (.dmark+2)  
3e60 32 a2 fd			ld (debug_mark+2),a  
3e63 18 03			jr .pastdmark  
3e65 ..			.dmark: db "MI1"  
3e68 f1			.pastdmark: pop af  
3e69			endm  
# End of macro DMARK
3e69						CALLMONITOR 
3e69 cd aa fd			call debug_vector  
3e6c				endm  
# End of macro CALLMONITOR
3e6c					endif 
3e6c cd 48 20				call forth_push_numhl 
3e6f			 
3e6f				       NEXTW 
3e6f c3 38 24			jp macro_next 
3e72				endm 
# End of macro NEXTW
3e72			.MAX: 
3e72				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3e72 4a				db WORD_SYS_CORE+54             
3e73 f3 3e			dw .RND16            
3e75 04				db 3 + 1 
3e76 .. 00			db "MAX",0              
3e7a				endm 
# End of macro CWHEAD
3e7a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3e7a					if DEBUG_FORTH_WORDS_KEY 
3e7a						DMARK "MAX" 
3e7a f5				push af  
3e7b 3a 8f 3e			ld a, (.dmark)  
3e7e 32 a0 fd			ld (debug_mark),a  
3e81 3a 90 3e			ld a, (.dmark+1)  
3e84 32 a1 fd			ld (debug_mark+1),a  
3e87 3a 91 3e			ld a, (.dmark+2)  
3e8a 32 a2 fd			ld (debug_mark+2),a  
3e8d 18 03			jr .pastdmark  
3e8f ..			.dmark: db "MAX"  
3e92 f1			.pastdmark: pop af  
3e93			endm  
# End of macro DMARK
3e93						CALLMONITOR 
3e93 cd aa fd			call debug_vector  
3e96				endm  
# End of macro CALLMONITOR
3e96					endif 
3e96					; get u2 
3e96			 
3e96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e96 cd 4d 22			call macro_dsp_valuehl 
3e99				endm 
# End of macro FORTH_DSP_VALUEHL
3e99			 
3e99 e5					push hl   ; u2 
3e9a			 
3e9a					; destroy value TOS 
3e9a			 
3e9a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9a cd 05 23			call macro_forth_dsp_pop 
3e9d				endm 
# End of macro FORTH_DSP_POP
3e9d			 
3e9d					; get u1 
3e9d			 
3e9d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e9d cd 4d 22			call macro_dsp_valuehl 
3ea0				endm 
# End of macro FORTH_DSP_VALUEHL
3ea0			 
3ea0 e5					push hl  ; u1 
3ea1			 
3ea1					; destroy value TOS 
3ea1			 
3ea1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ea1 cd 05 23			call macro_forth_dsp_pop 
3ea4				endm 
# End of macro FORTH_DSP_POP
3ea4			 
3ea4 b7			 or a      ;clear carry flag 
3ea5 e1			  pop hl    ; u1 
3ea6 d1			  pop de    ; u2 
3ea7 e5				push hl   ; saved in case hl is lowest 
3ea8 ed 52		  sbc hl,de 
3eaa 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3eac			 
3eac e1				pop hl 
3ead					if DEBUG_FORTH_WORDS 
3ead						DMARK "MAX" 
3ead f5				push af  
3eae 3a c2 3e			ld a, (.dmark)  
3eb1 32 a0 fd			ld (debug_mark),a  
3eb4 3a c3 3e			ld a, (.dmark+1)  
3eb7 32 a1 fd			ld (debug_mark+1),a  
3eba 3a c4 3e			ld a, (.dmark+2)  
3ebd 32 a2 fd			ld (debug_mark+2),a  
3ec0 18 03			jr .pastdmark  
3ec2 ..			.dmark: db "MAX"  
3ec5 f1			.pastdmark: pop af  
3ec6			endm  
# End of macro DMARK
3ec6						CALLMONITOR 
3ec6 cd aa fd			call debug_vector  
3ec9				endm  
# End of macro CALLMONITOR
3ec9					endif 
3ec9 cd 48 20				call forth_push_numhl 
3ecc			 
3ecc				       NEXTW 
3ecc c3 38 24			jp macro_next 
3ecf				endm 
# End of macro NEXTW
3ecf			 
3ecf			.maxcont:  
3ecf c1				pop bc   ; tidy up 
3ed0 eb				ex de , hl  
3ed1					if DEBUG_FORTH_WORDS 
3ed1						DMARK "MA1" 
3ed1 f5				push af  
3ed2 3a e6 3e			ld a, (.dmark)  
3ed5 32 a0 fd			ld (debug_mark),a  
3ed8 3a e7 3e			ld a, (.dmark+1)  
3edb 32 a1 fd			ld (debug_mark+1),a  
3ede 3a e8 3e			ld a, (.dmark+2)  
3ee1 32 a2 fd			ld (debug_mark+2),a  
3ee4 18 03			jr .pastdmark  
3ee6 ..			.dmark: db "MA1"  
3ee9 f1			.pastdmark: pop af  
3eea			endm  
# End of macro DMARK
3eea						CALLMONITOR 
3eea cd aa fd			call debug_vector  
3eed				endm  
# End of macro CALLMONITOR
3eed					endif 
3eed cd 48 20				call forth_push_numhl 
3ef0				       NEXTW 
3ef0 c3 38 24			jp macro_next 
3ef3				endm 
# End of macro NEXTW
3ef3			 
3ef3			.RND16: 
3ef3				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3ef3 4e				db WORD_SYS_CORE+58             
3ef4 22 3f			dw .RND8            
3ef6 06				db 5 + 1 
3ef7 .. 00			db "RND16",0              
3efd				endm 
# End of macro CWHEAD
3efd			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3efd					if DEBUG_FORTH_WORDS_KEY 
3efd						DMARK "R16" 
3efd f5				push af  
3efe 3a 12 3f			ld a, (.dmark)  
3f01 32 a0 fd			ld (debug_mark),a  
3f04 3a 13 3f			ld a, (.dmark+1)  
3f07 32 a1 fd			ld (debug_mark+1),a  
3f0a 3a 14 3f			ld a, (.dmark+2)  
3f0d 32 a2 fd			ld (debug_mark+2),a  
3f10 18 03			jr .pastdmark  
3f12 ..			.dmark: db "R16"  
3f15 f1			.pastdmark: pop af  
3f16			endm  
# End of macro DMARK
3f16						CALLMONITOR 
3f16 cd aa fd			call debug_vector  
3f19				endm  
# End of macro CALLMONITOR
3f19					endif 
3f19 cd 05 0f				call prng16  
3f1c cd 48 20				call forth_push_numhl 
3f1f				       NEXTW 
3f1f c3 38 24			jp macro_next 
3f22				endm 
# End of macro NEXTW
3f22			.RND8: 
3f22				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3f22 60				db WORD_SYS_CORE+76             
3f23 57 3f			dw .RND            
3f25 05				db 4 + 1 
3f26 .. 00			db "RND8",0              
3f2b				endm 
# End of macro CWHEAD
3f2b			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3f2b					if DEBUG_FORTH_WORDS_KEY 
3f2b						DMARK "RN8" 
3f2b f5				push af  
3f2c 3a 40 3f			ld a, (.dmark)  
3f2f 32 a0 fd			ld (debug_mark),a  
3f32 3a 41 3f			ld a, (.dmark+1)  
3f35 32 a1 fd			ld (debug_mark+1),a  
3f38 3a 42 3f			ld a, (.dmark+2)  
3f3b 32 a2 fd			ld (debug_mark+2),a  
3f3e 18 03			jr .pastdmark  
3f40 ..			.dmark: db "RN8"  
3f43 f1			.pastdmark: pop af  
3f44			endm  
# End of macro DMARK
3f44						CALLMONITOR 
3f44 cd aa fd			call debug_vector  
3f47				endm  
# End of macro CALLMONITOR
3f47					endif 
3f47 2a de fa				ld hl,(xrandc) 
3f4a 23					inc hl 
3f4b cd 1f 0f				call xrnd 
3f4e 6f					ld l,a	 
3f4f 26 00				ld h,0 
3f51 cd 48 20				call forth_push_numhl 
3f54				       NEXTW 
3f54 c3 38 24			jp macro_next 
3f57				endm 
# End of macro NEXTW
3f57			.RND: 
3f57				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3f57 60				db WORD_SYS_CORE+76             
3f58 5d 40			dw .ENDMATHS            
3f5a 04				db 3 + 1 
3f5b .. 00			db "RND",0              
3f5f				endm 
# End of macro CWHEAD
3f5f			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3f5f			 
3f5f					if DEBUG_FORTH_WORDS_KEY 
3f5f						DMARK "RND" 
3f5f f5				push af  
3f60 3a 74 3f			ld a, (.dmark)  
3f63 32 a0 fd			ld (debug_mark),a  
3f66 3a 75 3f			ld a, (.dmark+1)  
3f69 32 a1 fd			ld (debug_mark+1),a  
3f6c 3a 76 3f			ld a, (.dmark+2)  
3f6f 32 a2 fd			ld (debug_mark+2),a  
3f72 18 03			jr .pastdmark  
3f74 ..			.dmark: db "RND"  
3f77 f1			.pastdmark: pop af  
3f78			endm  
# End of macro DMARK
3f78						CALLMONITOR 
3f78 cd aa fd			call debug_vector  
3f7b				endm  
# End of macro CALLMONITOR
3f7b					endif 
3f7b					 
3f7b					FORTH_DSP_VALUEHL    ; upper range 
3f7b cd 4d 22			call macro_dsp_valuehl 
3f7e				endm 
# End of macro FORTH_DSP_VALUEHL
3f7e			 
3f7e 22 e2 fa				ld (LFSRSeed), hl	 
3f81			 
3f81					if DEBUG_FORTH_WORDS 
3f81						DMARK "RN1" 
3f81 f5				push af  
3f82 3a 96 3f			ld a, (.dmark)  
3f85 32 a0 fd			ld (debug_mark),a  
3f88 3a 97 3f			ld a, (.dmark+1)  
3f8b 32 a1 fd			ld (debug_mark+1),a  
3f8e 3a 98 3f			ld a, (.dmark+2)  
3f91 32 a2 fd			ld (debug_mark+2),a  
3f94 18 03			jr .pastdmark  
3f96 ..			.dmark: db "RN1"  
3f99 f1			.pastdmark: pop af  
3f9a			endm  
# End of macro DMARK
3f9a						CALLMONITOR 
3f9a cd aa fd			call debug_vector  
3f9d				endm  
# End of macro CALLMONITOR
3f9d					endif 
3f9d					FORTH_DSP_POP 
3f9d cd 05 23			call macro_forth_dsp_pop 
3fa0				endm 
# End of macro FORTH_DSP_POP
3fa0			 
3fa0					FORTH_DSP_VALUEHL    ; low range 
3fa0 cd 4d 22			call macro_dsp_valuehl 
3fa3				endm 
# End of macro FORTH_DSP_VALUEHL
3fa3			 
3fa3					if DEBUG_FORTH_WORDS 
3fa3						DMARK "RN2" 
3fa3 f5				push af  
3fa4 3a b8 3f			ld a, (.dmark)  
3fa7 32 a0 fd			ld (debug_mark),a  
3faa 3a b9 3f			ld a, (.dmark+1)  
3fad 32 a1 fd			ld (debug_mark+1),a  
3fb0 3a ba 3f			ld a, (.dmark+2)  
3fb3 32 a2 fd			ld (debug_mark+2),a  
3fb6 18 03			jr .pastdmark  
3fb8 ..			.dmark: db "RN2"  
3fbb f1			.pastdmark: pop af  
3fbc			endm  
# End of macro DMARK
3fbc						CALLMONITOR 
3fbc cd aa fd			call debug_vector  
3fbf				endm  
# End of macro CALLMONITOR
3fbf					endif 
3fbf 22 e4 fa				ld (LFSRSeed+2), hl 
3fc2			 
3fc2					FORTH_DSP_POP 
3fc2 cd 05 23			call macro_forth_dsp_pop 
3fc5				endm 
# End of macro FORTH_DSP_POP
3fc5			 
3fc5 e5					push hl 
3fc6			 
3fc6 e1			.inrange:	pop hl 
3fc7 cd 05 0f				call prng16  
3fca					if DEBUG_FORTH_WORDS 
3fca						DMARK "RN3" 
3fca f5				push af  
3fcb 3a df 3f			ld a, (.dmark)  
3fce 32 a0 fd			ld (debug_mark),a  
3fd1 3a e0 3f			ld a, (.dmark+1)  
3fd4 32 a1 fd			ld (debug_mark+1),a  
3fd7 3a e1 3f			ld a, (.dmark+2)  
3fda 32 a2 fd			ld (debug_mark+2),a  
3fdd 18 03			jr .pastdmark  
3fdf ..			.dmark: db "RN3"  
3fe2 f1			.pastdmark: pop af  
3fe3			endm  
# End of macro DMARK
3fe3						CALLMONITOR 
3fe3 cd aa fd			call debug_vector  
3fe6				endm  
# End of macro CALLMONITOR
3fe6					endif 
3fe6					 
3fe6					; if the range is 8bit knock out the high byte 
3fe6			 
3fe6 ed 5b e2 fa			ld de, (LFSRSeed)     ; check high level 
3fea			 
3fea 3e 00				ld a, 0 
3fec ba					cp d  
3fed 20 1e				jr nz, .hirange 
3fef 26 00				ld h, 0   ; knock it down to 8bit 
3ff1			 
3ff1					if DEBUG_FORTH_WORDS 
3ff1						DMARK "RNk" 
3ff1 f5				push af  
3ff2 3a 06 40			ld a, (.dmark)  
3ff5 32 a0 fd			ld (debug_mark),a  
3ff8 3a 07 40			ld a, (.dmark+1)  
3ffb 32 a1 fd			ld (debug_mark+1),a  
3ffe 3a 08 40			ld a, (.dmark+2)  
4001 32 a2 fd			ld (debug_mark+2),a  
4004 18 03			jr .pastdmark  
4006 ..			.dmark: db "RNk"  
4009 f1			.pastdmark: pop af  
400a			endm  
# End of macro DMARK
400a						CALLMONITOR 
400a cd aa fd			call debug_vector  
400d				endm  
# End of macro CALLMONITOR
400d					endif 
400d			.hirange:   
400d e5					push hl  
400e b7					or a  
400f ed 52		                sbc hl, de 
4011			 
4011					;call cmp16 
4011			 
4011 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
4013 e1					pop hl 
4014 e5					push hl 
4015			 
4015					if DEBUG_FORTH_WORDS 
4015						DMARK "RN4" 
4015 f5				push af  
4016 3a 2a 40			ld a, (.dmark)  
4019 32 a0 fd			ld (debug_mark),a  
401c 3a 2b 40			ld a, (.dmark+1)  
401f 32 a1 fd			ld (debug_mark+1),a  
4022 3a 2c 40			ld a, (.dmark+2)  
4025 32 a2 fd			ld (debug_mark+2),a  
4028 18 03			jr .pastdmark  
402a ..			.dmark: db "RN4"  
402d f1			.pastdmark: pop af  
402e			endm  
# End of macro DMARK
402e						CALLMONITOR 
402e cd aa fd			call debug_vector  
4031				endm  
# End of macro CALLMONITOR
4031					endif 
4031 ed 5b e4 fa			ld de, (LFSRSeed+2)   ; check low range 
4035					;call cmp16 
4035				 
4035 b7					or a  
4036 ed 52		                sbc hl, de 
4038 38 8c				jr c, .inrange 
403a			 
403a e1					pop hl 
403b					 
403b					if DEBUG_FORTH_WORDS 
403b						DMARK "RNd" 
403b f5				push af  
403c 3a 50 40			ld a, (.dmark)  
403f 32 a0 fd			ld (debug_mark),a  
4042 3a 51 40			ld a, (.dmark+1)  
4045 32 a1 fd			ld (debug_mark+1),a  
4048 3a 52 40			ld a, (.dmark+2)  
404b 32 a2 fd			ld (debug_mark+2),a  
404e 18 03			jr .pastdmark  
4050 ..			.dmark: db "RNd"  
4053 f1			.pastdmark: pop af  
4054			endm  
# End of macro DMARK
4054						CALLMONITOR 
4054 cd aa fd			call debug_vector  
4057				endm  
# End of macro CALLMONITOR
4057					endif 
4057			 
4057			 
4057 cd 48 20				call forth_push_numhl 
405a				       NEXTW 
405a c3 38 24			jp macro_next 
405d				endm 
# End of macro NEXTW
405d			 
405d			.ENDMATHS: 
405d			 
405d			; eof 
405d			 
# End of file forth_words_maths.asm
405d			include "forth_words_display.asm" 
405d			 
405d			; | ## Display Words 
405d			 
405d			.ACT: 
405d			 
405d				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
405d 62				db WORD_SYS_CORE+78             
405e a9 40			dw .INFO            
4060 07				db 6 + 1 
4061 .. 00			db "ACTIVE",0              
4068				endm 
# End of macro CWHEAD
4068			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
4068			;  
4068			; | | To display a pulsing activity indicator in a processing loop do this... 
4068			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
4068			 
4068					if DEBUG_FORTH_WORDS_KEY 
4068						DMARK "ACT" 
4068 f5				push af  
4069 3a 7d 40			ld a, (.dmark)  
406c 32 a0 fd			ld (debug_mark),a  
406f 3a 7e 40			ld a, (.dmark+1)  
4072 32 a1 fd			ld (debug_mark+1),a  
4075 3a 7f 40			ld a, (.dmark+2)  
4078 32 a2 fd			ld (debug_mark+2),a  
407b 18 03			jr .pastdmark  
407d ..			.dmark: db "ACT"  
4080 f1			.pastdmark: pop af  
4081			endm  
# End of macro DMARK
4081						CALLMONITOR 
4081 cd aa fd			call debug_vector  
4084				endm  
# End of macro CALLMONITOR
4084					endif 
4084 cd 01 0d				call active 
4087					if DEBUG_FORTH_WORDS 
4087						DMARK "ACp" 
4087 f5				push af  
4088 3a 9c 40			ld a, (.dmark)  
408b 32 a0 fd			ld (debug_mark),a  
408e 3a 9d 40			ld a, (.dmark+1)  
4091 32 a1 fd			ld (debug_mark+1),a  
4094 3a 9e 40			ld a, (.dmark+2)  
4097 32 a2 fd			ld (debug_mark+2),a  
409a 18 03			jr .pastdmark  
409c ..			.dmark: db "ACp"  
409f f1			.pastdmark: pop af  
40a0			endm  
# End of macro DMARK
40a0						CALLMONITOR 
40a0 cd aa fd			call debug_vector  
40a3				endm  
# End of macro CALLMONITOR
40a3					endif 
40a3 cd b6 20				call forth_push_str 
40a6			 
40a6					NEXTW 
40a6 c3 38 24			jp macro_next 
40a9				endm 
# End of macro NEXTW
40a9			.INFO: 
40a9			 
40a9				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
40a9 62				db WORD_SYS_CORE+78             
40aa c6 40			dw .ATP            
40ac 05				db 4 + 1 
40ad .. 00			db "INFO",0              
40b2				endm 
# End of macro CWHEAD
40b2			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
40b2					FORTH_DSP_VALUEHL 
40b2 cd 4d 22			call macro_dsp_valuehl 
40b5				endm 
# End of macro FORTH_DSP_VALUEHL
40b5			 
40b5					FORTH_DSP_POP 
40b5 cd 05 23			call macro_forth_dsp_pop 
40b8				endm 
# End of macro FORTH_DSP_POP
40b8			 
40b8 e5					push hl 
40b9			 
40b9					FORTH_DSP_VALUEHL 
40b9 cd 4d 22			call macro_dsp_valuehl 
40bc				endm 
# End of macro FORTH_DSP_VALUEHL
40bc			 
40bc					FORTH_DSP_POP 
40bc cd 05 23			call macro_forth_dsp_pop 
40bf				endm 
# End of macro FORTH_DSP_POP
40bf			 
40bf d1					pop de 
40c0			 
40c0 cd 3b 0d				call info_panel 
40c3			 
40c3			 
40c3					NEXTW 
40c3 c3 38 24			jp macro_next 
40c6				endm 
# End of macro NEXTW
40c6			.ATP: 
40c6				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
40c6 62				db WORD_SYS_CORE+78             
40c7 3d 41			dw .FB            
40c9 04				db 3 + 1 
40ca .. 00			db "AT?",0              
40ce				endm 
# End of macro CWHEAD
40ce			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
40ce					if DEBUG_FORTH_WORDS_KEY 
40ce						DMARK "AT?" 
40ce f5				push af  
40cf 3a e3 40			ld a, (.dmark)  
40d2 32 a0 fd			ld (debug_mark),a  
40d5 3a e4 40			ld a, (.dmark+1)  
40d8 32 a1 fd			ld (debug_mark+1),a  
40db 3a e5 40			ld a, (.dmark+2)  
40de 32 a2 fd			ld (debug_mark+2),a  
40e1 18 03			jr .pastdmark  
40e3 ..			.dmark: db "AT?"  
40e6 f1			.pastdmark: pop af  
40e7			endm  
# End of macro DMARK
40e7						CALLMONITOR 
40e7 cd aa fd			call debug_vector  
40ea				endm  
# End of macro CALLMONITOR
40ea					endif 
40ea 3a 93 f9				ld a, (f_cursor_ptr) 
40ed			 
40ed			if DEBUG_FORTH_WORDS 
40ed				DMARK "AT?" 
40ed f5				push af  
40ee 3a 02 41			ld a, (.dmark)  
40f1 32 a0 fd			ld (debug_mark),a  
40f4 3a 03 41			ld a, (.dmark+1)  
40f7 32 a1 fd			ld (debug_mark+1),a  
40fa 3a 04 41			ld a, (.dmark+2)  
40fd 32 a2 fd			ld (debug_mark+2),a  
4100 18 03			jr .pastdmark  
4102 ..			.dmark: db "AT?"  
4105 f1			.pastdmark: pop af  
4106			endm  
# End of macro DMARK
4106				CALLMONITOR 
4106 cd aa fd			call debug_vector  
4109				endm  
# End of macro CALLMONITOR
4109			endif	 
4109					; count the number of rows 
4109			 
4109 06 00				ld b, 0 
410b 4f			.atpr:		ld c, a    ; save in case we go below zero 
410c d6 28				sub display_cols 
410e f2 14 41				jp p, .atprunder 
4111 04					inc b 
4112 18 f7				jr .atpr 
4114			.atprunder:	 
4114			if DEBUG_FORTH_WORDS 
4114				DMARK "A?2" 
4114 f5				push af  
4115 3a 29 41			ld a, (.dmark)  
4118 32 a0 fd			ld (debug_mark),a  
411b 3a 2a 41			ld a, (.dmark+1)  
411e 32 a1 fd			ld (debug_mark+1),a  
4121 3a 2b 41			ld a, (.dmark+2)  
4124 32 a2 fd			ld (debug_mark+2),a  
4127 18 03			jr .pastdmark  
4129 ..			.dmark: db "A?2"  
412c f1			.pastdmark: pop af  
412d			endm  
# End of macro DMARK
412d				CALLMONITOR 
412d cd aa fd			call debug_vector  
4130				endm  
# End of macro CALLMONITOR
4130			endif	 
4130 26 00				ld h, 0 
4132 69					ld l, c 
4133 cd 48 20				call forth_push_numhl 
4136 68					ld l, b  
4137 cd 48 20				call forth_push_numhl 
413a			 
413a			 
413a				NEXTW 
413a c3 38 24			jp macro_next 
413d				endm 
# End of macro NEXTW
413d			 
413d			.FB: 
413d				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
413d 1b				db WORD_SYS_CORE+7             
413e 8b 41			dw .EMIT            
4140 03				db 2 + 1 
4141 .. 00			db "FB",0              
4144				endm 
# End of macro CWHEAD
4144			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
4144			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
4144			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
4144			; | | If automatic display is off then updates will not be shown until DRAW is used. 
4144					if DEBUG_FORTH_WORDS_KEY 
4144						DMARK "FB." 
4144 f5				push af  
4145 3a 59 41			ld a, (.dmark)  
4148 32 a0 fd			ld (debug_mark),a  
414b 3a 5a 41			ld a, (.dmark+1)  
414e 32 a1 fd			ld (debug_mark+1),a  
4151 3a 5b 41			ld a, (.dmark+2)  
4154 32 a2 fd			ld (debug_mark+2),a  
4157 18 03			jr .pastdmark  
4159 ..			.dmark: db "FB."  
415c f1			.pastdmark: pop af  
415d			endm  
# End of macro DMARK
415d						CALLMONITOR 
415d cd aa fd			call debug_vector  
4160				endm  
# End of macro CALLMONITOR
4160					endif 
4160			 
4160					FORTH_DSP_VALUEHL 
4160 cd 4d 22			call macro_dsp_valuehl 
4163				endm 
# End of macro FORTH_DSP_VALUEHL
4163			 
4163 7d					ld a, l 
4164 fe 01				cp 1 
4166 20 05				jr nz, .fbn1 
4168 21 45 fc				ld hl, display_fb1 
416b 18 15				jr .fbset 
416d fe 02		.fbn1:		cp 2 
416f 20 05				jr nz, .fbn2 
4171 21 03 fb				ld hl, display_fb2 
4174 18 0c				jr .fbset 
4176 fe 03		.fbn2:		cp 3 
4178 20 05				jr nz, .fbn3 
417a 21 a4 fb				ld hl, display_fb3 
417d 18 03				jr .fbset 
417f			.fbn3:		 ; if invalid number select first 
417f 21 45 fc				ld hl, display_fb1 
4182 22 01 fb		.fbset:		ld (display_fb_active), hl 
4185			 
4185					FORTH_DSP_POP 
4185 cd 05 23			call macro_forth_dsp_pop 
4188				endm 
# End of macro FORTH_DSP_POP
4188			 
4188					NEXTW 
4188 c3 38 24			jp macro_next 
418b				endm 
# End of macro NEXTW
418b			 
418b			 
418b			.EMIT: 
418b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
418b 1b				db WORD_SYS_CORE+7             
418c dc 41			dw .DOTH            
418e 05				db 4 + 1 
418f .. 00			db "EMIT",0              
4194				endm 
# End of macro CWHEAD
4194			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
4194					; get value off TOS and display it 
4194			 
4194					if DEBUG_FORTH_WORDS_KEY 
4194						DMARK "EMT" 
4194 f5				push af  
4195 3a a9 41			ld a, (.dmark)  
4198 32 a0 fd			ld (debug_mark),a  
419b 3a aa 41			ld a, (.dmark+1)  
419e 32 a1 fd			ld (debug_mark+1),a  
41a1 3a ab 41			ld a, (.dmark+2)  
41a4 32 a2 fd			ld (debug_mark+2),a  
41a7 18 03			jr .pastdmark  
41a9 ..			.dmark: db "EMT"  
41ac f1			.pastdmark: pop af  
41ad			endm  
# End of macro DMARK
41ad						CALLMONITOR 
41ad cd aa fd			call debug_vector  
41b0				endm  
# End of macro CALLMONITOR
41b0					endif 
41b0			 
41b0					FORTH_DSP_VALUEHL 
41b0 cd 4d 22			call macro_dsp_valuehl 
41b3				endm 
# End of macro FORTH_DSP_VALUEHL
41b3			 
41b3 7d					ld a,l 
41b4			 
41b4					; TODO write to display 
41b4			 
41b4 32 f4 f2				ld (os_input), a 
41b7 3e 00				ld a, 0 
41b9 32 f5 f2				ld (os_input+1), a 
41bc					 
41bc 3a 93 f9				ld a, (f_cursor_ptr) 
41bf 11 f4 f2				ld de, os_input 
41c2 cd bd 0d				call str_at_display 
41c5			 
41c5			 
41c5 3a 71 f9				ld a,(cli_autodisplay) 
41c8 fe 00				cp 0 
41ca 28 03				jr z, .enoupdate 
41cc cd cd 0d						call update_display 
41cf					.enoupdate: 
41cf			 
41cf 3a 93 f9				ld a, (f_cursor_ptr) 
41d2 3c					inc a 
41d3 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
41d6			 
41d6			 
41d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41d6 cd 05 23			call macro_forth_dsp_pop 
41d9				endm 
# End of macro FORTH_DSP_POP
41d9			  
41d9			 
41d9					NEXTW 
41d9 c3 38 24			jp macro_next 
41dc				endm 
# End of macro NEXTW
41dc			.DOTH: 
41dc				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
41dc 1c				db WORD_SYS_CORE+8             
41dd 0c 42			dw .DOTF            
41df 03				db 2 + 1 
41e0 .. 00			db ".-",0              
41e3				endm 
# End of macro CWHEAD
41e3			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
41e3					; get value off TOS and display it 
41e3					if DEBUG_FORTH_WORDS_KEY 
41e3						DMARK "DTD" 
41e3 f5				push af  
41e4 3a f8 41			ld a, (.dmark)  
41e7 32 a0 fd			ld (debug_mark),a  
41ea 3a f9 41			ld a, (.dmark+1)  
41ed 32 a1 fd			ld (debug_mark+1),a  
41f0 3a fa 41			ld a, (.dmark+2)  
41f3 32 a2 fd			ld (debug_mark+2),a  
41f6 18 03			jr .pastdmark  
41f8 ..			.dmark: db "DTD"  
41fb f1			.pastdmark: pop af  
41fc			endm  
# End of macro DMARK
41fc						CALLMONITOR 
41fc cd aa fd			call debug_vector  
41ff				endm  
# End of macro CALLMONITOR
41ff					endif 
41ff 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
4201 3e 00			ld a, 0 
4203 32 72 f9			ld (cli_mvdot), a 
4206 c3 63 42			jp .dotgo 
4209				NEXTW 
4209 c3 38 24			jp macro_next 
420c				endm 
# End of macro NEXTW
420c			.DOTF: 
420c				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
420c 1c				db WORD_SYS_CORE+8             
420d 3a 42			dw .DOT            
420f 03				db 2 + 1 
4210 .. 00			db ".>",0              
4213				endm 
# End of macro CWHEAD
4213			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4213					; get value off TOS and display it 
4213			        ; TODO BUG adds extra spaces 
4213			        ; TODO BUG handle numerics? 
4213					if DEBUG_FORTH_WORDS_KEY 
4213						DMARK "DTC" 
4213 f5				push af  
4214 3a 28 42			ld a, (.dmark)  
4217 32 a0 fd			ld (debug_mark),a  
421a 3a 29 42			ld a, (.dmark+1)  
421d 32 a1 fd			ld (debug_mark+1),a  
4220 3a 2a 42			ld a, (.dmark+2)  
4223 32 a2 fd			ld (debug_mark+2),a  
4226 18 03			jr .pastdmark  
4228 ..			.dmark: db "DTC"  
422b f1			.pastdmark: pop af  
422c			endm  
# End of macro DMARK
422c						CALLMONITOR 
422c cd aa fd			call debug_vector  
422f				endm  
# End of macro CALLMONITOR
422f					endif 
422f 3e 01			ld a, 1 
4231 32 72 f9			ld (cli_mvdot), a 
4234 c3 63 42			jp .dotgo 
4237				NEXTW 
4237 c3 38 24			jp macro_next 
423a				endm 
# End of macro NEXTW
423a			 
423a			.DOT: 
423a				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
423a 1c				db WORD_SYS_CORE+8             
423b 16 44			dw .CLS            
423d 02				db 1 + 1 
423e .. 00			db ".",0              
4240				endm 
# End of macro CWHEAD
4240			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4240					; get value off TOS and display it 
4240			 
4240					if DEBUG_FORTH_WORDS_KEY 
4240						DMARK "DOT" 
4240 f5				push af  
4241 3a 55 42			ld a, (.dmark)  
4244 32 a0 fd			ld (debug_mark),a  
4247 3a 56 42			ld a, (.dmark+1)  
424a 32 a1 fd			ld (debug_mark+1),a  
424d 3a 57 42			ld a, (.dmark+2)  
4250 32 a2 fd			ld (debug_mark+2),a  
4253 18 03			jr .pastdmark  
4255 ..			.dmark: db "DOT"  
4258 f1			.pastdmark: pop af  
4259			endm  
# End of macro DMARK
4259						CALLMONITOR 
4259 cd aa fd			call debug_vector  
425c				endm  
# End of macro CALLMONITOR
425c					endif 
425c 3e 00			ld a, 0 
425e 32 72 f9			ld (cli_mvdot), a 
4261 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4263				 
4263			 
4263			.dotgo: 
4263			 
4263			; move up type to on stack for parserv5 
4263					FORTH_DSP 
4263 cd 13 22			call macro_forth_dsp 
4266				endm 
# End of macro FORTH_DSP
4266				;FORTH_DSP_VALUE  
4266			 
4266			if DEBUG_FORTH_DOT 
4266				DMARK "DOT" 
4266 f5				push af  
4267 3a 7b 42			ld a, (.dmark)  
426a 32 a0 fd			ld (debug_mark),a  
426d 3a 7c 42			ld a, (.dmark+1)  
4270 32 a1 fd			ld (debug_mark+1),a  
4273 3a 7d 42			ld a, (.dmark+2)  
4276 32 a2 fd			ld (debug_mark+2),a  
4279 18 03			jr .pastdmark  
427b ..			.dmark: db "DOT"  
427e f1			.pastdmark: pop af  
427f			endm  
# End of macro DMARK
427f				CALLMONITOR 
427f cd aa fd			call debug_vector  
4282				endm  
# End of macro CALLMONITOR
4282			endif	 
4282			;		.print: 
4282			 
4282 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4283 23				inc hl   ; position to the actual value 
4284 fe 01			cp DS_TYPE_STR 
4286 20 06			jr nz, .dotnum1  
4288			 
4288			; display string 
4288				FORTH_DSP_VALUE  
4288 cd 36 22			call macro_forth_dsp_value 
428b				endm 
# End of macro FORTH_DSP_VALUE
428b eb				ex de,hl 
428c 18 49			jr .dotwrite 
428e			 
428e			.dotnum1: 
428e fe 02			cp DS_TYPE_INUM 
4290 20 44			jr nz, .dotflot 
4292			 
4292			 
4292			; display number 
4292			 
4292			;	push hl 
4292			;	call clear_display 
4292			;	pop hl 
4292			 
4292 5e				ld e, (hl) 
4293 23				inc hl 
4294 56				ld d, (hl) 
4295 21 f6 f0			ld hl, scratch 
4298			if DEBUG_FORTH_DOT 
4298				DMARK "DT1" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 a0 fd			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 a1 fd			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 a2 fd			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "DT1"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1				CALLMONITOR 
42b1 cd aa fd			call debug_vector  
42b4				endm  
# End of macro CALLMONITOR
42b4			endif	 
42b4			 
42b4 cd f3 12			call uitoa_16 
42b7 eb				ex de,hl 
42b8			 
42b8			if DEBUG_FORTH_DOT 
42b8				DMARK "DT2" 
42b8 f5				push af  
42b9 3a cd 42			ld a, (.dmark)  
42bc 32 a0 fd			ld (debug_mark),a  
42bf 3a ce 42			ld a, (.dmark+1)  
42c2 32 a1 fd			ld (debug_mark+1),a  
42c5 3a cf 42			ld a, (.dmark+2)  
42c8 32 a2 fd			ld (debug_mark+2),a  
42cb 18 03			jr .pastdmark  
42cd ..			.dmark: db "DT2"  
42d0 f1			.pastdmark: pop af  
42d1			endm  
# End of macro DMARK
42d1				CALLMONITOR 
42d1 cd aa fd			call debug_vector  
42d4				endm  
# End of macro CALLMONITOR
42d4			endif	 
42d4			 
42d4			;	ld de, os_word_scratch 
42d4 18 01			jr .dotwrite 
42d6			 
42d6 00			.dotflot:   nop 
42d7			; TODO print floating point number 
42d7			 
42d7			.dotwrite:		 
42d7			 
42d7					; if c is set then set all '-' to spaces 
42d7					; need to also take into account .>  
42d7			 
42d7 3e 01				ld a, 1 
42d9 b9					cp c 
42da 20 67				jr nz, .nodashswap 
42dc			 
42dc					; DE has the string to write, working with HL 
42dc			 
42dc 06 ff				ld b, 255 
42de d5					push de 
42df e1					pop hl 
42e0			 
42e0			if DEBUG_FORTH_DOT 
42e0				DMARK "DT-" 
42e0 f5				push af  
42e1 3a f5 42			ld a, (.dmark)  
42e4 32 a0 fd			ld (debug_mark),a  
42e7 3a f6 42			ld a, (.dmark+1)  
42ea 32 a1 fd			ld (debug_mark+1),a  
42ed 3a f7 42			ld a, (.dmark+2)  
42f0 32 a2 fd			ld (debug_mark+2),a  
42f3 18 03			jr .pastdmark  
42f5 ..			.dmark: db "DT-"  
42f8 f1			.pastdmark: pop af  
42f9			endm  
# End of macro DMARK
42f9				CALLMONITOR 
42f9 cd aa fd			call debug_vector  
42fc				endm  
# End of macro CALLMONITOR
42fc			endif	 
42fc 7e			.dashscan:	ld a, (hl) 
42fd fe 00				cp 0 
42ff 28 42				jr z, .nodashswap 
4301 fe 2d				cp '-' 
4303 20 03				jr nz, .dashskip 
4305 3e 20				ld a, ' ' 
4307 77					ld (hl), a 
4308 23			.dashskip:	inc hl 
4309			if DEBUG_FORTH_DOT 
4309				DMARK "D-2" 
4309 f5				push af  
430a 3a 1e 43			ld a, (.dmark)  
430d 32 a0 fd			ld (debug_mark),a  
4310 3a 1f 43			ld a, (.dmark+1)  
4313 32 a1 fd			ld (debug_mark+1),a  
4316 3a 20 43			ld a, (.dmark+2)  
4319 32 a2 fd			ld (debug_mark+2),a  
431c 18 03			jr .pastdmark  
431e ..			.dmark: db "D-2"  
4321 f1			.pastdmark: pop af  
4322			endm  
# End of macro DMARK
4322				CALLMONITOR 
4322 cd aa fd			call debug_vector  
4325				endm  
# End of macro CALLMONITOR
4325			endif	 
4325 10 d5				djnz .dashscan 
4327			 
4327			if DEBUG_FORTH_DOT 
4327				DMARK "D-1" 
4327 f5				push af  
4328 3a 3c 43			ld a, (.dmark)  
432b 32 a0 fd			ld (debug_mark),a  
432e 3a 3d 43			ld a, (.dmark+1)  
4331 32 a1 fd			ld (debug_mark+1),a  
4334 3a 3e 43			ld a, (.dmark+2)  
4337 32 a2 fd			ld (debug_mark+2),a  
433a 18 03			jr .pastdmark  
433c ..			.dmark: db "D-1"  
433f f1			.pastdmark: pop af  
4340			endm  
# End of macro DMARK
4340				CALLMONITOR 
4340 cd aa fd			call debug_vector  
4343				endm  
# End of macro CALLMONITOR
4343			endif	 
4343			 
4343			.nodashswap: 
4343			 
4343			if DEBUG_FORTH_DOT 
4343				DMARK "D-o" 
4343 f5				push af  
4344 3a 58 43			ld a, (.dmark)  
4347 32 a0 fd			ld (debug_mark),a  
434a 3a 59 43			ld a, (.dmark+1)  
434d 32 a1 fd			ld (debug_mark+1),a  
4350 3a 5a 43			ld a, (.dmark+2)  
4353 32 a2 fd			ld (debug_mark+2),a  
4356 18 03			jr .pastdmark  
4358 ..			.dmark: db "D-o"  
435b f1			.pastdmark: pop af  
435c			endm  
# End of macro DMARK
435c				CALLMONITOR 
435c cd aa fd			call debug_vector  
435f				endm  
# End of macro CALLMONITOR
435f			endif	 
435f			 
435f d5					push de   ; save string start in case we need to advance print 
4360			 
4360 3a 93 f9				ld a, (f_cursor_ptr) 
4363 cd bd 0d				call str_at_display 
4366 3a 71 f9				ld a,(cli_autodisplay) 
4369 fe 00				cp 0 
436b 28 03				jr z, .noupdate 
436d cd cd 0d						call update_display 
4370					.noupdate: 
4370			 
4370			 
4370					; see if we need to advance the print position 
4370			 
4370 e1					pop hl   ; get back string 
4371			;		ex de,hl 
4371			 
4371 3a 72 f9				ld a, (cli_mvdot) 
4374			if DEBUG_FORTH_DOT 
4374			;		ld e,a 
4374				DMARK "D>1" 
4374 f5				push af  
4375 3a 89 43			ld a, (.dmark)  
4378 32 a0 fd			ld (debug_mark),a  
437b 3a 8a 43			ld a, (.dmark+1)  
437e 32 a1 fd			ld (debug_mark+1),a  
4381 3a 8b 43			ld a, (.dmark+2)  
4384 32 a2 fd			ld (debug_mark+2),a  
4387 18 03			jr .pastdmark  
4389 ..			.dmark: db "D>1"  
438c f1			.pastdmark: pop af  
438d			endm  
# End of macro DMARK
438d				CALLMONITOR 
438d cd aa fd			call debug_vector  
4390				endm  
# End of macro CALLMONITOR
4390			endif	 
4390 fe 00				cp 0 
4392 28 44				jr z, .noadv 
4394					; yes, lets advance the print position 
4394 3e 00				ld a, 0 
4396 cd 4f 13				call strlent 
4399			if DEBUG_FORTH_DOT 
4399				DMARK "D-?" 
4399 f5				push af  
439a 3a ae 43			ld a, (.dmark)  
439d 32 a0 fd			ld (debug_mark),a  
43a0 3a af 43			ld a, (.dmark+1)  
43a3 32 a1 fd			ld (debug_mark+1),a  
43a6 3a b0 43			ld a, (.dmark+2)  
43a9 32 a2 fd			ld (debug_mark+2),a  
43ac 18 03			jr .pastdmark  
43ae ..			.dmark: db "D-?"  
43b1 f1			.pastdmark: pop af  
43b2			endm  
# End of macro DMARK
43b2				CALLMONITOR 
43b2 cd aa fd			call debug_vector  
43b5				endm  
# End of macro CALLMONITOR
43b5			endif	 
43b5 3a 93 f9				ld a, (f_cursor_ptr) 
43b8 85					add a,l 
43b9					;call addatohl 
43b9					;ld a, l 
43b9 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
43bc			 
43bc			if DEBUG_FORTH_DOT 
43bc				DMARK "D->" 
43bc f5				push af  
43bd 3a d1 43			ld a, (.dmark)  
43c0 32 a0 fd			ld (debug_mark),a  
43c3 3a d2 43			ld a, (.dmark+1)  
43c6 32 a1 fd			ld (debug_mark+1),a  
43c9 3a d3 43			ld a, (.dmark+2)  
43cc 32 a2 fd			ld (debug_mark+2),a  
43cf 18 03			jr .pastdmark  
43d1 ..			.dmark: db "D->"  
43d4 f1			.pastdmark: pop af  
43d5			endm  
# End of macro DMARK
43d5				CALLMONITOR 
43d5 cd aa fd			call debug_vector  
43d8				endm  
# End of macro CALLMONITOR
43d8			endif	 
43d8			 
43d8			.noadv:	 
43d8			 
43d8					if DEBUG_FORTH_DOT_WAIT 
43d8							call next_page_prompt 
43d8					endif	 
43d8			; TODO this pop off the stack causes a crash. i dont know why 
43d8			 
43d8			 
43d8			if DEBUG_FORTH_DOT 
43d8				DMARK "DTh" 
43d8 f5				push af  
43d9 3a ed 43			ld a, (.dmark)  
43dc 32 a0 fd			ld (debug_mark),a  
43df 3a ee 43			ld a, (.dmark+1)  
43e2 32 a1 fd			ld (debug_mark+1),a  
43e5 3a ef 43			ld a, (.dmark+2)  
43e8 32 a2 fd			ld (debug_mark+2),a  
43eb 18 03			jr .pastdmark  
43ed ..			.dmark: db "DTh"  
43f0 f1			.pastdmark: pop af  
43f1			endm  
# End of macro DMARK
43f1				CALLMONITOR 
43f1 cd aa fd			call debug_vector  
43f4				endm  
# End of macro CALLMONITOR
43f4			endif	 
43f4			 
43f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43f4 cd 05 23			call macro_forth_dsp_pop 
43f7				endm 
# End of macro FORTH_DSP_POP
43f7			 
43f7			if DEBUG_FORTH_DOT 
43f7				DMARK "DTi" 
43f7 f5				push af  
43f8 3a 0c 44			ld a, (.dmark)  
43fb 32 a0 fd			ld (debug_mark),a  
43fe 3a 0d 44			ld a, (.dmark+1)  
4401 32 a1 fd			ld (debug_mark+1),a  
4404 3a 0e 44			ld a, (.dmark+2)  
4407 32 a2 fd			ld (debug_mark+2),a  
440a 18 03			jr .pastdmark  
440c ..			.dmark: db "DTi"  
440f f1			.pastdmark: pop af  
4410			endm  
# End of macro DMARK
4410				CALLMONITOR 
4410 cd aa fd			call debug_vector  
4413				endm  
# End of macro CALLMONITOR
4413			endif	 
4413			 
4413			 
4413					NEXTW 
4413 c3 38 24			jp macro_next 
4416				endm 
# End of macro NEXTW
4416			 
4416			.CLS: 
4416				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4416 35				db WORD_SYS_CORE+33             
4417 43 44			dw .DRAW            
4419 04				db 3 + 1 
441a .. 00			db "CLS",0              
441e				endm 
# End of macro CWHEAD
441e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
441e					if DEBUG_FORTH_WORDS_KEY 
441e						DMARK "CLS" 
441e f5				push af  
441f 3a 33 44			ld a, (.dmark)  
4422 32 a0 fd			ld (debug_mark),a  
4425 3a 34 44			ld a, (.dmark+1)  
4428 32 a1 fd			ld (debug_mark+1),a  
442b 3a 35 44			ld a, (.dmark+2)  
442e 32 a2 fd			ld (debug_mark+2),a  
4431 18 03			jr .pastdmark  
4433 ..			.dmark: db "CLS"  
4436 f1			.pastdmark: pop af  
4437			endm  
# End of macro DMARK
4437						CALLMONITOR 
4437 cd aa fd			call debug_vector  
443a				endm  
# End of macro CALLMONITOR
443a					endif 
443a cd aa 0d				call clear_display 
443d c3 51 45				jp .home		; and home cursor 
4440					NEXTW 
4440 c3 38 24			jp macro_next 
4443				endm 
# End of macro NEXTW
4443			 
4443			.DRAW: 
4443				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4443 36				db WORD_SYS_CORE+34             
4444 6e 44			dw .DUMP            
4446 05				db 4 + 1 
4447 .. 00			db "DRAW",0              
444c				endm 
# End of macro CWHEAD
444c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
444c					if DEBUG_FORTH_WORDS_KEY 
444c						DMARK "DRW" 
444c f5				push af  
444d 3a 61 44			ld a, (.dmark)  
4450 32 a0 fd			ld (debug_mark),a  
4453 3a 62 44			ld a, (.dmark+1)  
4456 32 a1 fd			ld (debug_mark+1),a  
4459 3a 63 44			ld a, (.dmark+2)  
445c 32 a2 fd			ld (debug_mark+2),a  
445f 18 03			jr .pastdmark  
4461 ..			.dmark: db "DRW"  
4464 f1			.pastdmark: pop af  
4465			endm  
# End of macro DMARK
4465						CALLMONITOR 
4465 cd aa fd			call debug_vector  
4468				endm  
# End of macro CALLMONITOR
4468					endif 
4468 cd cd 0d				call update_display 
446b					NEXTW 
446b c3 38 24			jp macro_next 
446e				endm 
# End of macro NEXTW
446e			 
446e			.DUMP: 
446e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
446e 37				db WORD_SYS_CORE+35             
446f a6 44			dw .CDUMP            
4471 05				db 4 + 1 
4472 .. 00			db "DUMP",0              
4477				endm 
# End of macro CWHEAD
4477			; | DUMP ( x -- ) With address x display dump   | DONE 
4477			; TODO pop address to use off of the stack 
4477					if DEBUG_FORTH_WORDS_KEY 
4477						DMARK "DUM" 
4477 f5				push af  
4478 3a 8c 44			ld a, (.dmark)  
447b 32 a0 fd			ld (debug_mark),a  
447e 3a 8d 44			ld a, (.dmark+1)  
4481 32 a1 fd			ld (debug_mark+1),a  
4484 3a 8e 44			ld a, (.dmark+2)  
4487 32 a2 fd			ld (debug_mark+2),a  
448a 18 03			jr .pastdmark  
448c ..			.dmark: db "DUM"  
448f f1			.pastdmark: pop af  
4490			endm  
# End of macro DMARK
4490						CALLMONITOR 
4490 cd aa fd			call debug_vector  
4493				endm  
# End of macro CALLMONITOR
4493					endif 
4493 cd aa 0d				call clear_display 
4496			 
4496					; get address 
4496			 
4496					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4496 cd 4d 22			call macro_dsp_valuehl 
4499				endm 
# End of macro FORTH_DSP_VALUEHL
4499				 
4499					; save it for cdump 
4499			 
4499 22 19 f4				ld (os_cur_ptr),hl 
449c			 
449c					; destroy value TOS 
449c			 
449c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
449c cd 05 23			call macro_forth_dsp_pop 
449f				endm 
# End of macro FORTH_DSP_POP
449f			 
449f cd c8 1e				call dumpcont	; skip old style of param parsing	 
44a2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
44a3					NEXTW 
44a3 c3 38 24			jp macro_next 
44a6				endm 
# End of macro NEXTW
44a6			.CDUMP: 
44a6				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
44a6 38				db WORD_SYS_CORE+36             
44a7 d6 44			dw .DAT            
44a9 06				db 5 + 1 
44aa .. 00			db "CDUMP",0              
44b0				endm 
# End of macro CWHEAD
44b0			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
44b0					if DEBUG_FORTH_WORDS_KEY 
44b0						DMARK "CDP" 
44b0 f5				push af  
44b1 3a c5 44			ld a, (.dmark)  
44b4 32 a0 fd			ld (debug_mark),a  
44b7 3a c6 44			ld a, (.dmark+1)  
44ba 32 a1 fd			ld (debug_mark+1),a  
44bd 3a c7 44			ld a, (.dmark+2)  
44c0 32 a2 fd			ld (debug_mark+2),a  
44c3 18 03			jr .pastdmark  
44c5 ..			.dmark: db "CDP"  
44c8 f1			.pastdmark: pop af  
44c9			endm  
# End of macro DMARK
44c9						CALLMONITOR 
44c9 cd aa fd			call debug_vector  
44cc				endm  
# End of macro CALLMONITOR
44cc					endif 
44cc cd aa 0d				call clear_display 
44cf cd c8 1e				call dumpcont	 
44d2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
44d3					NEXTW 
44d3 c3 38 24			jp macro_next 
44d6				endm 
# End of macro NEXTW
44d6			 
44d6			 
44d6			 
44d6			 
44d6			.DAT: 
44d6				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
44d6 3d				db WORD_SYS_CORE+41             
44d7 2c 45			dw .HOME            
44d9 03				db 2 + 1 
44da .. 00			db "AT",0              
44dd				endm 
# End of macro CWHEAD
44dd			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
44dd					if DEBUG_FORTH_WORDS_KEY 
44dd						DMARK "AT." 
44dd f5				push af  
44de 3a f2 44			ld a, (.dmark)  
44e1 32 a0 fd			ld (debug_mark),a  
44e4 3a f3 44			ld a, (.dmark+1)  
44e7 32 a1 fd			ld (debug_mark+1),a  
44ea 3a f4 44			ld a, (.dmark+2)  
44ed 32 a2 fd			ld (debug_mark+2),a  
44f0 18 03			jr .pastdmark  
44f2 ..			.dmark: db "AT."  
44f5 f1			.pastdmark: pop af  
44f6			endm  
# End of macro DMARK
44f6						CALLMONITOR 
44f6 cd aa fd			call debug_vector  
44f9				endm  
# End of macro CALLMONITOR
44f9					endif 
44f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44f9 cd 4d 22			call macro_dsp_valuehl 
44fc				endm 
# End of macro FORTH_DSP_VALUEHL
44fc			 
44fc			 
44fc					; TODO save cursor row 
44fc 7d					ld a,l 
44fd fe 02				cp 2 
44ff 20 04				jr nz, .crow3 
4501 3e 28				ld a, display_row_2 
4503 18 12				jr .ccol1 
4505 fe 03		.crow3:		cp 3 
4507 20 04				jr nz, .crow4 
4509 3e 50				ld a, display_row_3 
450b 18 0a				jr .ccol1 
450d fe 04		.crow4:		cp 4 
450f 20 04				jr nz, .crow1 
4511 3e 78				ld a, display_row_4 
4513 18 02				jr .ccol1 
4515 3e 00		.crow1:		ld a,display_row_1 
4517 f5			.ccol1:		push af			; got row offset 
4518 6f					ld l,a 
4519 26 00				ld h,0 
451b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
451b cd 05 23			call macro_forth_dsp_pop 
451e				endm 
# End of macro FORTH_DSP_POP
451e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
451e cd 4d 22			call macro_dsp_valuehl 
4521				endm 
# End of macro FORTH_DSP_VALUEHL
4521					; TODO save cursor col 
4521 f1					pop af 
4522 85					add l		; add col offset 
4523 32 93 f9				ld (f_cursor_ptr), a 
4526					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4526 cd 05 23			call macro_forth_dsp_pop 
4529				endm 
# End of macro FORTH_DSP_POP
4529			 
4529					; calculate  
4529			 
4529					NEXTW 
4529 c3 38 24			jp macro_next 
452c				endm 
# End of macro NEXTW
452c			 
452c			 
452c			.HOME: 
452c				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
452c 41				db WORD_SYS_CORE+45             
452d 59 45			dw .CR            
452f 05				db 4 + 1 
4530 .. 00			db "HOME",0              
4535				endm 
# End of macro CWHEAD
4535			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4535					if DEBUG_FORTH_WORDS_KEY 
4535						DMARK "HOM" 
4535 f5				push af  
4536 3a 4a 45			ld a, (.dmark)  
4539 32 a0 fd			ld (debug_mark),a  
453c 3a 4b 45			ld a, (.dmark+1)  
453f 32 a1 fd			ld (debug_mark+1),a  
4542 3a 4c 45			ld a, (.dmark+2)  
4545 32 a2 fd			ld (debug_mark+2),a  
4548 18 03			jr .pastdmark  
454a ..			.dmark: db "HOM"  
454d f1			.pastdmark: pop af  
454e			endm  
# End of macro DMARK
454e						CALLMONITOR 
454e cd aa fd			call debug_vector  
4551				endm  
# End of macro CALLMONITOR
4551					endif 
4551 3e 00		.home:		ld a, 0		; and home cursor 
4553 32 93 f9				ld (f_cursor_ptr), a 
4556					NEXTW 
4556 c3 38 24			jp macro_next 
4559				endm 
# End of macro NEXTW
4559			 
4559			 
4559			.CR: 
4559				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
4559 46				db WORD_SYS_CORE+50             
455a 94 45			dw .SPACE            
455c 03				db 2 + 1 
455d .. 00			db "CR",0              
4560				endm 
# End of macro CWHEAD
4560			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4560					if DEBUG_FORTH_WORDS_KEY 
4560						DMARK "CR." 
4560 f5				push af  
4561 3a 75 45			ld a, (.dmark)  
4564 32 a0 fd			ld (debug_mark),a  
4567 3a 76 45			ld a, (.dmark+1)  
456a 32 a1 fd			ld (debug_mark+1),a  
456d 3a 77 45			ld a, (.dmark+2)  
4570 32 a2 fd			ld (debug_mark+2),a  
4573 18 03			jr .pastdmark  
4575 ..			.dmark: db "CR."  
4578 f1			.pastdmark: pop af  
4579			endm  
# End of macro DMARK
4579						CALLMONITOR 
4579 cd aa fd			call debug_vector  
457c				endm  
# End of macro CALLMONITOR
457c					endif 
457c 3e 0d				ld a, 13 
457e 32 f6 f0				ld (scratch),a 
4581 3e 0a				ld a, 10 
4583 32 f7 f0				ld (scratch+1),a 
4586 3e 00				ld a, 0 
4588 32 f8 f0				ld (scratch+2),a 
458b 21 f6 f0				ld hl, scratch 
458e cd b6 20				call forth_push_str 
4591					 
4591				       NEXTW 
4591 c3 38 24			jp macro_next 
4594				endm 
# End of macro NEXTW
4594			.SPACE: 
4594				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4594 46				db WORD_SYS_CORE+50             
4595 ca 45			dw .SPACES            
4597 03				db 2 + 1 
4598 .. 00			db "BL",0              
459b				endm 
# End of macro CWHEAD
459b			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
459b					if DEBUG_FORTH_WORDS_KEY 
459b						DMARK "BL." 
459b f5				push af  
459c 3a b0 45			ld a, (.dmark)  
459f 32 a0 fd			ld (debug_mark),a  
45a2 3a b1 45			ld a, (.dmark+1)  
45a5 32 a1 fd			ld (debug_mark+1),a  
45a8 3a b2 45			ld a, (.dmark+2)  
45ab 32 a2 fd			ld (debug_mark+2),a  
45ae 18 03			jr .pastdmark  
45b0 ..			.dmark: db "BL."  
45b3 f1			.pastdmark: pop af  
45b4			endm  
# End of macro DMARK
45b4						CALLMONITOR 
45b4 cd aa fd			call debug_vector  
45b7				endm  
# End of macro CALLMONITOR
45b7					endif 
45b7 3e 20				ld a, " " 
45b9 32 f6 f0				ld (scratch),a 
45bc 3e 00				ld a, 0 
45be 32 f7 f0				ld (scratch+1),a 
45c1 21 f6 f0				ld hl, scratch 
45c4 cd b6 20				call forth_push_str 
45c7					 
45c7				       NEXTW 
45c7 c3 38 24			jp macro_next 
45ca				endm 
# End of macro NEXTW
45ca			 
45ca			;.blstr: db " ", 0 
45ca			 
45ca			.SPACES: 
45ca				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
45ca 47				db WORD_SYS_CORE+51             
45cb 65 46			dw .SCROLL            
45cd 07				db 6 + 1 
45ce .. 00			db "SPACES",0              
45d5				endm 
# End of macro CWHEAD
45d5			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
45d5					if DEBUG_FORTH_WORDS_KEY 
45d5						DMARK "SPS" 
45d5 f5				push af  
45d6 3a ea 45			ld a, (.dmark)  
45d9 32 a0 fd			ld (debug_mark),a  
45dc 3a eb 45			ld a, (.dmark+1)  
45df 32 a1 fd			ld (debug_mark+1),a  
45e2 3a ec 45			ld a, (.dmark+2)  
45e5 32 a2 fd			ld (debug_mark+2),a  
45e8 18 03			jr .pastdmark  
45ea ..			.dmark: db "SPS"  
45ed f1			.pastdmark: pop af  
45ee			endm  
# End of macro DMARK
45ee						CALLMONITOR 
45ee cd aa fd			call debug_vector  
45f1				endm  
# End of macro CALLMONITOR
45f1					endif 
45f1			 
45f1			 
45f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45f1 cd 4d 22			call macro_dsp_valuehl 
45f4				endm 
# End of macro FORTH_DSP_VALUEHL
45f4			 
45f4 e5					push hl    ; u 
45f5					if DEBUG_FORTH_WORDS 
45f5						DMARK "SPA" 
45f5 f5				push af  
45f6 3a 0a 46			ld a, (.dmark)  
45f9 32 a0 fd			ld (debug_mark),a  
45fc 3a 0b 46			ld a, (.dmark+1)  
45ff 32 a1 fd			ld (debug_mark+1),a  
4602 3a 0c 46			ld a, (.dmark+2)  
4605 32 a2 fd			ld (debug_mark+2),a  
4608 18 03			jr .pastdmark  
460a ..			.dmark: db "SPA"  
460d f1			.pastdmark: pop af  
460e			endm  
# End of macro DMARK
460e						CALLMONITOR 
460e cd aa fd			call debug_vector  
4611				endm  
# End of macro CALLMONITOR
4611					endif 
4611			 
4611					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4611 cd 05 23			call macro_forth_dsp_pop 
4614				endm 
# End of macro FORTH_DSP_POP
4614 e1					pop hl 
4615 0e 00				ld c, 0 
4617 45					ld b, l 
4618 21 f6 f0				ld hl, scratch  
461b			 
461b					if DEBUG_FORTH_WORDS 
461b						DMARK "SP2" 
461b f5				push af  
461c 3a 30 46			ld a, (.dmark)  
461f 32 a0 fd			ld (debug_mark),a  
4622 3a 31 46			ld a, (.dmark+1)  
4625 32 a1 fd			ld (debug_mark+1),a  
4628 3a 32 46			ld a, (.dmark+2)  
462b 32 a2 fd			ld (debug_mark+2),a  
462e 18 03			jr .pastdmark  
4630 ..			.dmark: db "SP2"  
4633 f1			.pastdmark: pop af  
4634			endm  
# End of macro DMARK
4634						CALLMONITOR 
4634 cd aa fd			call debug_vector  
4637				endm  
# End of macro CALLMONITOR
4637					endif 
4637 3e 20				ld a, ' ' 
4639			.spaces1:	 
4639 77					ld (hl),a 
463a 23					inc hl 
463b					 
463b 10 fc				djnz .spaces1 
463d 3e 00				ld a,0 
463f 77					ld (hl),a 
4640 21 f6 f0				ld hl, scratch 
4643					if DEBUG_FORTH_WORDS 
4643						DMARK "SP3" 
4643 f5				push af  
4644 3a 58 46			ld a, (.dmark)  
4647 32 a0 fd			ld (debug_mark),a  
464a 3a 59 46			ld a, (.dmark+1)  
464d 32 a1 fd			ld (debug_mark+1),a  
4650 3a 5a 46			ld a, (.dmark+2)  
4653 32 a2 fd			ld (debug_mark+2),a  
4656 18 03			jr .pastdmark  
4658 ..			.dmark: db "SP3"  
465b f1			.pastdmark: pop af  
465c			endm  
# End of macro DMARK
465c						CALLMONITOR 
465c cd aa fd			call debug_vector  
465f				endm  
# End of macro CALLMONITOR
465f					endif 
465f cd b6 20				call forth_push_str 
4662			 
4662				       NEXTW 
4662 c3 38 24			jp macro_next 
4665				endm 
# End of macro NEXTW
4665			 
4665			 
4665			 
4665			.SCROLL: 
4665				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4665 53				db WORD_SYS_CORE+63             
4666 92 46			dw .SCROLLD            
4668 07				db 6 + 1 
4669 .. 00			db "SCROLL",0              
4670				endm 
# End of macro CWHEAD
4670			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4670					if DEBUG_FORTH_WORDS_KEY 
4670						DMARK "SCR" 
4670 f5				push af  
4671 3a 85 46			ld a, (.dmark)  
4674 32 a0 fd			ld (debug_mark),a  
4677 3a 86 46			ld a, (.dmark+1)  
467a 32 a1 fd			ld (debug_mark+1),a  
467d 3a 87 46			ld a, (.dmark+2)  
4680 32 a2 fd			ld (debug_mark+2),a  
4683 18 03			jr .pastdmark  
4685 ..			.dmark: db "SCR"  
4688 f1			.pastdmark: pop af  
4689			endm  
# End of macro DMARK
4689						CALLMONITOR 
4689 cd aa fd			call debug_vector  
468c				endm  
# End of macro CALLMONITOR
468c					endif 
468c			 
468c cd 6c 0d			call scroll_up 
468f			;	call update_display 
468f			 
468f					NEXTW 
468f c3 38 24			jp macro_next 
4692				endm 
# End of macro NEXTW
4692			 
4692			 
4692			 
4692			;		; get dir 
4692			; 
4692			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4692			; 
4692			;		push hl 
4692			; 
4692			;		; destroy value TOS 
4692			; 
4692			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4692			; 
4692			;		; get count 
4692			; 
4692			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4692			; 
4692			;		push hl 
4692			; 
4692			;		; destroy value TOS 
4692			; 
4692			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4692			; 
4692			;		; one value on hl get other one back 
4692			; 
4692			;		pop bc    ; count 
4692			; 
4692			;		pop de   ; dir 
4692			; 
4692			; 
4692			;		ld b, c 
4692			; 
4692			;.scrolldir:     push bc 
4692			;		push de 
4692			; 
4692			;		ld a, 0 
4692			;		cp e 
4692			;		jr z, .scrollup  
4692			;		call scroll_down 
4692			;		jr .scrollnext 
4692			;.scrollup:	call scroll_up 
4692			; 
4692			;		 
4692			;.scrollnext: 
4692			;		pop de 
4692			;		pop bc 
4692			;		djnz .scrolldir 
4692			; 
4692			; 
4692			; 
4692			; 
4692			; 
4692			;		NEXTW 
4692			 
4692			.SCROLLD: 
4692				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4692 53				db WORD_SYS_CORE+63             
4693 c0 46			dw .ATQ            
4695 08				db 7 + 1 
4696 .. 00			db "SCROLLD",0              
469e				endm 
# End of macro CWHEAD
469e			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
469e					if DEBUG_FORTH_WORDS_KEY 
469e						DMARK "SCD" 
469e f5				push af  
469f 3a b3 46			ld a, (.dmark)  
46a2 32 a0 fd			ld (debug_mark),a  
46a5 3a b4 46			ld a, (.dmark+1)  
46a8 32 a1 fd			ld (debug_mark+1),a  
46ab 3a b5 46			ld a, (.dmark+2)  
46ae 32 a2 fd			ld (debug_mark+2),a  
46b1 18 03			jr .pastdmark  
46b3 ..			.dmark: db "SCD"  
46b6 f1			.pastdmark: pop af  
46b7			endm  
# End of macro DMARK
46b7						CALLMONITOR 
46b7 cd aa fd			call debug_vector  
46ba				endm  
# End of macro CALLMONITOR
46ba					endif 
46ba			 
46ba cd 90 0d			call scroll_down 
46bd			;	call update_display 
46bd			 
46bd					NEXTW 
46bd c3 38 24			jp macro_next 
46c0				endm 
# End of macro NEXTW
46c0			 
46c0			 
46c0			.ATQ: 
46c0				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
46c0 62				db WORD_SYS_CORE+78             
46c1 1e 47			dw .AUTODSP            
46c3 04				db 3 + 1 
46c4 .. 00			db "AT@",0              
46c8				endm 
# End of macro CWHEAD
46c8			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
46c8					if DEBUG_FORTH_WORDS_KEY 
46c8						DMARK "ATA" 
46c8 f5				push af  
46c9 3a dd 46			ld a, (.dmark)  
46cc 32 a0 fd			ld (debug_mark),a  
46cf 3a de 46			ld a, (.dmark+1)  
46d2 32 a1 fd			ld (debug_mark+1),a  
46d5 3a df 46			ld a, (.dmark+2)  
46d8 32 a2 fd			ld (debug_mark+2),a  
46db 18 03			jr .pastdmark  
46dd ..			.dmark: db "ATA"  
46e0 f1			.pastdmark: pop af  
46e1			endm  
# End of macro DMARK
46e1						CALLMONITOR 
46e1 cd aa fd			call debug_vector  
46e4				endm  
# End of macro CALLMONITOR
46e4					endif 
46e4			 
46e4			 
46e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46e4 cd 4d 22			call macro_dsp_valuehl 
46e7				endm 
# End of macro FORTH_DSP_VALUEHL
46e7			 
46e7					; TODO save cursor row 
46e7 7d					ld a,l 
46e8 fe 02				cp 2 
46ea 20 04				jr nz, .crow3aq 
46ec 3e 28				ld a, display_row_2 
46ee 18 12				jr .ccol1aq 
46f0 fe 03		.crow3aq:		cp 3 
46f2 20 04				jr nz, .crow4aq 
46f4 3e 50				ld a, display_row_3 
46f6 18 0a				jr .ccol1aq 
46f8 fe 04		.crow4aq:		cp 4 
46fa 20 04				jr nz, .crow1aq 
46fc 3e 78				ld a, display_row_4 
46fe 18 02				jr .ccol1aq 
4700 3e 00		.crow1aq:		ld a,display_row_1 
4702 f5			.ccol1aq:		push af			; got row offset 
4703 6f					ld l,a 
4704 26 00				ld h,0 
4706					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4706 cd 05 23			call macro_forth_dsp_pop 
4709				endm 
# End of macro FORTH_DSP_POP
4709					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4709 cd 4d 22			call macro_dsp_valuehl 
470c				endm 
# End of macro FORTH_DSP_VALUEHL
470c					; TODO save cursor col 
470c f1					pop af 
470d 85					add l		; add col offset 
470e			 
470e					; add current frame buffer address 
470e 2a 01 fb				ld hl, (display_fb_active) 
4711 cd de 0f				call addatohl 
4714			 
4714			 
4714			 
4714			 
4714					; get char frame buffer location offset in hl 
4714			 
4714 7e					ld a,(hl) 
4715 26 00				ld h, 0 
4717 6f					ld l, a 
4718			 
4718 cd 48 20				call forth_push_numhl 
471b			 
471b			 
471b					NEXTW 
471b c3 38 24			jp macro_next 
471e				endm 
# End of macro NEXTW
471e			 
471e			.AUTODSP: 
471e				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
471e 63				db WORD_SYS_CORE+79             
471f 34 47			dw .MENU            
4721 05				db 4 + 1 
4722 .. 00			db "ADSP",0              
4727				endm 
# End of macro CWHEAD
4727			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4727			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4727			 
4727					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4727 cd 4d 22			call macro_dsp_valuehl 
472a				endm 
# End of macro FORTH_DSP_VALUEHL
472a			 
472a			;		push hl 
472a			 
472a					; destroy value TOS 
472a			 
472a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
472a cd 05 23			call macro_forth_dsp_pop 
472d				endm 
# End of macro FORTH_DSP_POP
472d			 
472d			;		pop hl 
472d			 
472d 7d					ld a,l 
472e 32 71 f9				ld (cli_autodisplay), a 
4731				       NEXTW 
4731 c3 38 24			jp macro_next 
4734				endm 
# End of macro NEXTW
4734			 
4734			.MENU: 
4734				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4734 70				db WORD_SYS_CORE+92             
4735 dd 47			dw .ENDDISPLAY            
4737 05				db 4 + 1 
4738 .. 00			db "MENU",0              
473d				endm 
# End of macro CWHEAD
473d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
473d			 
473d			;		; get number of items on the stack 
473d			; 
473d				 
473d					FORTH_DSP_VALUEHL 
473d cd 4d 22			call macro_dsp_valuehl 
4740				endm 
# End of macro FORTH_DSP_VALUEHL
4740				 
4740					if DEBUG_FORTH_WORDS_KEY 
4740						DMARK "MNU" 
4740 f5				push af  
4741 3a 55 47			ld a, (.dmark)  
4744 32 a0 fd			ld (debug_mark),a  
4747 3a 56 47			ld a, (.dmark+1)  
474a 32 a1 fd			ld (debug_mark+1),a  
474d 3a 57 47			ld a, (.dmark+2)  
4750 32 a2 fd			ld (debug_mark+2),a  
4753 18 03			jr .pastdmark  
4755 ..			.dmark: db "MNU"  
4758 f1			.pastdmark: pop af  
4759			endm  
# End of macro DMARK
4759						CALLMONITOR 
4759 cd aa fd			call debug_vector  
475c				endm  
# End of macro CALLMONITOR
475c					endif 
475c			 
475c 45					ld b, l	 
475d 05					dec b 
475e			 
475e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
475e cd 05 23			call macro_forth_dsp_pop 
4761				endm 
# End of macro FORTH_DSP_POP
4761			 
4761			 
4761					; go directly through the stack to pluck out the string pointers and build an array 
4761			 
4761			;		FORTH_DSP 
4761			 
4761					; hl contains top most stack item 
4761				 
4761 11 f6 f0				ld de, scratch 
4764			 
4764			.mbuild: 
4764			 
4764					FORTH_DSP_VALUEHL 
4764 cd 4d 22			call macro_dsp_valuehl 
4767				endm 
# End of macro FORTH_DSP_VALUEHL
4767			 
4767					if DEBUG_FORTH_WORDS 
4767						DMARK "MN3" 
4767 f5				push af  
4768 3a 7c 47			ld a, (.dmark)  
476b 32 a0 fd			ld (debug_mark),a  
476e 3a 7d 47			ld a, (.dmark+1)  
4771 32 a1 fd			ld (debug_mark+1),a  
4774 3a 7e 47			ld a, (.dmark+2)  
4777 32 a2 fd			ld (debug_mark+2),a  
477a 18 03			jr .pastdmark  
477c ..			.dmark: db "MN3"  
477f f1			.pastdmark: pop af  
4780			endm  
# End of macro DMARK
4780						CALLMONITOR 
4780 cd aa fd			call debug_vector  
4783				endm  
# End of macro CALLMONITOR
4783					endif 
4783 eb					ex de, hl 
4784 73					ld (hl), e 
4785 23					inc hl 
4786 72					ld (hl), d 
4787 23					inc hl 
4788 eb					ex de, hl 
4789			 
4789					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4789 cd 05 23			call macro_forth_dsp_pop 
478c				endm 
# End of macro FORTH_DSP_POP
478c			 
478c 10 d6				djnz .mbuild 
478e			 
478e					; done add term 
478e			 
478e eb					ex de, hl 
478f 36 00				ld (hl), 0 
4791 23					inc hl 
4792 36 00				ld (hl), 0 
4794			 
4794				 
4794					 
4794 21 f6 f0				ld hl, scratch 
4797			 
4797					if DEBUG_FORTH_WORDS 
4797						DMARK "MNx" 
4797 f5				push af  
4798 3a ac 47			ld a, (.dmark)  
479b 32 a0 fd			ld (debug_mark),a  
479e 3a ad 47			ld a, (.dmark+1)  
47a1 32 a1 fd			ld (debug_mark+1),a  
47a4 3a ae 47			ld a, (.dmark+2)  
47a7 32 a2 fd			ld (debug_mark+2),a  
47aa 18 03			jr .pastdmark  
47ac ..			.dmark: db "MNx"  
47af f1			.pastdmark: pop af  
47b0			endm  
# End of macro DMARK
47b0						CALLMONITOR 
47b0 cd aa fd			call debug_vector  
47b3				endm  
# End of macro CALLMONITOR
47b3					endif 
47b3			 
47b3			 
47b3			 
47b3 3e 00				ld a, 0 
47b5 cd db 0d				call menu 
47b8			 
47b8			 
47b8 6f					ld l, a 
47b9 26 00				ld h, 0 
47bb			 
47bb					if DEBUG_FORTH_WORDS 
47bb						DMARK "MNr" 
47bb f5				push af  
47bc 3a d0 47			ld a, (.dmark)  
47bf 32 a0 fd			ld (debug_mark),a  
47c2 3a d1 47			ld a, (.dmark+1)  
47c5 32 a1 fd			ld (debug_mark+1),a  
47c8 3a d2 47			ld a, (.dmark+2)  
47cb 32 a2 fd			ld (debug_mark+2),a  
47ce 18 03			jr .pastdmark  
47d0 ..			.dmark: db "MNr"  
47d3 f1			.pastdmark: pop af  
47d4			endm  
# End of macro DMARK
47d4						CALLMONITOR 
47d4 cd aa fd			call debug_vector  
47d7				endm  
# End of macro CALLMONITOR
47d7					endif 
47d7			 
47d7 cd 48 20				call forth_push_numhl 
47da			 
47da			 
47da			 
47da			 
47da				       NEXTW 
47da c3 38 24			jp macro_next 
47dd				endm 
# End of macro NEXTW
47dd			 
47dd			 
47dd			.ENDDISPLAY: 
47dd			 
47dd			; eof 
# End of file forth_words_display.asm
47dd			include "forth_words_str.asm" 
47dd			 
47dd			; | ## String Words 
47dd			 
47dd			.SPLIT:   
47dd			 
47dd				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
47dd 48				db WORD_SYS_CORE+52             
47de d2 48			dw .PTR            
47e0 06				db 5 + 1 
47e1 .. 00			db "SPLIT",0              
47e7				endm 
# End of macro CWHEAD
47e7			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
47e7					if DEBUG_FORTH_WORDS_KEY 
47e7						DMARK "SPT" 
47e7 f5				push af  
47e8 3a fc 47			ld a, (.dmark)  
47eb 32 a0 fd			ld (debug_mark),a  
47ee 3a fd 47			ld a, (.dmark+1)  
47f1 32 a1 fd			ld (debug_mark+1),a  
47f4 3a fe 47			ld a, (.dmark+2)  
47f7 32 a2 fd			ld (debug_mark+2),a  
47fa 18 03			jr .pastdmark  
47fc ..			.dmark: db "SPT"  
47ff f1			.pastdmark: pop af  
4800			endm  
# End of macro DMARK
4800						CALLMONITOR 
4800 cd aa fd			call debug_vector  
4803				endm  
# End of macro CALLMONITOR
4803					endif 
4803			 
4803					; get delim 
4803					FORTH_DSP_VALUEHL 
4803 cd 4d 22			call macro_dsp_valuehl 
4806				endm 
# End of macro FORTH_DSP_VALUEHL
4806			 
4806					FORTH_DSP_POP 
4806 cd 05 23			call macro_forth_dsp_pop 
4809				endm 
# End of macro FORTH_DSP_POP
4809					 
4809			 
4809 45					ld b, l    ; move delim to b 
480a 0e 01				ld c, 1   ; count of poritions 
480c			 
480c c5					push bc 
480d			 
480d					if DEBUG_FORTH_WORDS 
480d						DMARK "SPa" 
480d f5				push af  
480e 3a 22 48			ld a, (.dmark)  
4811 32 a0 fd			ld (debug_mark),a  
4814 3a 23 48			ld a, (.dmark+1)  
4817 32 a1 fd			ld (debug_mark+1),a  
481a 3a 24 48			ld a, (.dmark+2)  
481d 32 a2 fd			ld (debug_mark+2),a  
4820 18 03			jr .pastdmark  
4822 ..			.dmark: db "SPa"  
4825 f1			.pastdmark: pop af  
4826			endm  
# End of macro DMARK
4826						CALLMONITOR 
4826 cd aa fd			call debug_vector  
4829				endm  
# End of macro CALLMONITOR
4829					endif 
4829					; get pointer to string to chop up 
4829					FORTH_DSP_VALUEHL 
4829 cd 4d 22			call macro_dsp_valuehl 
482c				endm 
# End of macro FORTH_DSP_VALUEHL
482c			 
482c			;		push hl 
482c 11 f6 f0				ld de, scratch 
482f			.spllop: 
482f c1					pop bc 
4830 c5					push bc 
4831			;		pop hl 
4831					if DEBUG_FORTH_WORDS 
4831						DMARK "SPl" 
4831 f5				push af  
4832 3a 46 48			ld a, (.dmark)  
4835 32 a0 fd			ld (debug_mark),a  
4838 3a 47 48			ld a, (.dmark+1)  
483b 32 a1 fd			ld (debug_mark+1),a  
483e 3a 48 48			ld a, (.dmark+2)  
4841 32 a2 fd			ld (debug_mark+2),a  
4844 18 03			jr .pastdmark  
4846 ..			.dmark: db "SPl"  
4849 f1			.pastdmark: pop af  
484a			endm  
# End of macro DMARK
484a						CALLMONITOR 
484a cd aa fd			call debug_vector  
484d				endm  
# End of macro CALLMONITOR
484d					endif 
484d 7e					ld a, (hl) 
484e b8					cp b 
484f 28 08				jr z, .splnxt 
4851 fe 00				cp 0 
4853 28 34				jr z, .splend 
4855 ed a0				ldi 
4857 18 d6				jr .spllop 
4859			 
4859					; hit dlim 
4859			 
4859			.splnxt: 
4859					if DEBUG_FORTH_WORDS 
4859						DMARK "SPx" 
4859 f5				push af  
485a 3a 6e 48			ld a, (.dmark)  
485d 32 a0 fd			ld (debug_mark),a  
4860 3a 6f 48			ld a, (.dmark+1)  
4863 32 a1 fd			ld (debug_mark+1),a  
4866 3a 70 48			ld a, (.dmark+2)  
4869 32 a2 fd			ld (debug_mark+2),a  
486c 18 03			jr .pastdmark  
486e ..			.dmark: db "SPx"  
4871 f1			.pastdmark: pop af  
4872			endm  
# End of macro DMARK
4872						CALLMONITOR 
4872 cd aa fd			call debug_vector  
4875				endm  
# End of macro CALLMONITOR
4875					endif 
4875 3e 00				ld a, 0 
4877 12					ld (de), a 
4878					;ex de, hl 
4878 e5					push hl 
4879 21 f6 f0				ld hl, scratch 
487c cd b6 20				call forth_push_str 
487f e1					pop hl 
4880					;ex de, hl 
4880 23					inc hl 
4881 c1					pop bc 
4882 0c					inc c 
4883 c5					push bc 
4884 11 f6 f0				ld de, scratch 
4887 18 a6				jr .spllop 
4889			 
4889			.splend:		 
4889					if DEBUG_FORTH_WORDS 
4889						DMARK "SPe" 
4889 f5				push af  
488a 3a 9e 48			ld a, (.dmark)  
488d 32 a0 fd			ld (debug_mark),a  
4890 3a 9f 48			ld a, (.dmark+1)  
4893 32 a1 fd			ld (debug_mark+1),a  
4896 3a a0 48			ld a, (.dmark+2)  
4899 32 a2 fd			ld (debug_mark+2),a  
489c 18 03			jr .pastdmark  
489e ..			.dmark: db "SPe"  
48a1 f1			.pastdmark: pop af  
48a2			endm  
# End of macro DMARK
48a2						CALLMONITOR 
48a2 cd aa fd			call debug_vector  
48a5				endm  
# End of macro CALLMONITOR
48a5					endif 
48a5 12					ld (de), a 
48a6 eb					ex de, hl 
48a7			;		push hl 
48a7 21 f6 f0				ld hl, scratch 
48aa cd b6 20				call forth_push_str 
48ad					 
48ad					if DEBUG_FORTH_WORDS 
48ad						DMARK "SPc" 
48ad f5				push af  
48ae 3a c2 48			ld a, (.dmark)  
48b1 32 a0 fd			ld (debug_mark),a  
48b4 3a c3 48			ld a, (.dmark+1)  
48b7 32 a1 fd			ld (debug_mark+1),a  
48ba 3a c4 48			ld a, (.dmark+2)  
48bd 32 a2 fd			ld (debug_mark+2),a  
48c0 18 03			jr .pastdmark  
48c2 ..			.dmark: db "SPc"  
48c5 f1			.pastdmark: pop af  
48c6			endm  
# End of macro DMARK
48c6						CALLMONITOR 
48c6 cd aa fd			call debug_vector  
48c9				endm  
# End of macro CALLMONITOR
48c9					endif 
48c9			 
48c9 e1					pop hl    ; get counter from bc which has been push 
48ca 26 00				ld h, 0 
48cc			;		ld l, c 
48cc cd 48 20				call forth_push_numhl 
48cf			 
48cf			 
48cf				NEXTW 
48cf c3 38 24			jp macro_next 
48d2				endm 
# End of macro NEXTW
48d2			.PTR:   
48d2			 
48d2				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
48d2 48				db WORD_SYS_CORE+52             
48d3 ff 48			dw .STYPE            
48d5 04				db 3 + 1 
48d6 .. 00			db "PTR",0              
48da				endm 
# End of macro CWHEAD
48da			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
48da			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
48da			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
48da			 
48da					if DEBUG_FORTH_WORDS_KEY 
48da						DMARK "PTR" 
48da f5				push af  
48db 3a ef 48			ld a, (.dmark)  
48de 32 a0 fd			ld (debug_mark),a  
48e1 3a f0 48			ld a, (.dmark+1)  
48e4 32 a1 fd			ld (debug_mark+1),a  
48e7 3a f1 48			ld a, (.dmark+2)  
48ea 32 a2 fd			ld (debug_mark+2),a  
48ed 18 03			jr .pastdmark  
48ef ..			.dmark: db "PTR"  
48f2 f1			.pastdmark: pop af  
48f3			endm  
# End of macro DMARK
48f3						CALLMONITOR 
48f3 cd aa fd			call debug_vector  
48f6				endm  
# End of macro CALLMONITOR
48f6					endif 
48f6					FORTH_DSP_VALUEHL 
48f6 cd 4d 22			call macro_dsp_valuehl 
48f9				endm 
# End of macro FORTH_DSP_VALUEHL
48f9 cd 48 20				call forth_push_numhl 
48fc			 
48fc			 
48fc					NEXTW 
48fc c3 38 24			jp macro_next 
48ff				endm 
# End of macro NEXTW
48ff			.STYPE: 
48ff				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
48ff 48				db WORD_SYS_CORE+52             
4900 4e 49			dw .UPPER            
4902 06				db 5 + 1 
4903 .. 00			db "STYPE",0              
4909				endm 
# End of macro CWHEAD
4909			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4909					if DEBUG_FORTH_WORDS_KEY 
4909						DMARK "STY" 
4909 f5				push af  
490a 3a 1e 49			ld a, (.dmark)  
490d 32 a0 fd			ld (debug_mark),a  
4910 3a 1f 49			ld a, (.dmark+1)  
4913 32 a1 fd			ld (debug_mark+1),a  
4916 3a 20 49			ld a, (.dmark+2)  
4919 32 a2 fd			ld (debug_mark+2),a  
491c 18 03			jr .pastdmark  
491e ..			.dmark: db "STY"  
4921 f1			.pastdmark: pop af  
4922			endm  
# End of macro DMARK
4922						CALLMONITOR 
4922 cd aa fd			call debug_vector  
4925				endm  
# End of macro CALLMONITOR
4925					endif 
4925					FORTH_DSP 
4925 cd 13 22			call macro_forth_dsp 
4928				endm 
# End of macro FORTH_DSP
4928					;v5 FORTH_DSP_VALUE 
4928			 
4928 7e					ld a, (hl) 
4929			 
4929 f5					push af 
492a			 
492a			; Dont destroy TOS		FORTH_DSP_POP 
492a			 
492a f1					pop af 
492b			 
492b fe 01				cp DS_TYPE_STR 
492d 28 09				jr z, .typestr 
492f			 
492f fe 02				cp DS_TYPE_INUM 
4931 28 0a				jr z, .typeinum 
4933			 
4933 21 4c 49				ld hl, .tna 
4936 18 0a				jr .tpush 
4938			 
4938 21 48 49		.typestr:	ld hl, .tstr 
493b 18 05				jr .tpush 
493d 21 4a 49		.typeinum:	ld hl, .tinum 
4940 18 00				jr .tpush 
4942			 
4942			.tpush: 
4942			 
4942 cd b6 20				call forth_push_str 
4945			 
4945					NEXTW 
4945 c3 38 24			jp macro_next 
4948				endm 
# End of macro NEXTW
4948 .. 00		.tstr:	db "s",0 
494a .. 00		.tinum:  db "i",0 
494c .. 00		.tna:   db "?", 0 
494e			 
494e			 
494e			.UPPER: 
494e				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
494e 48				db WORD_SYS_CORE+52             
494f 89 49			dw .LOWER            
4951 06				db 5 + 1 
4952 .. 00			db "UPPER",0              
4958				endm 
# End of macro CWHEAD
4958			; | UPPER ( s -- s ) Upper case string s  | DONE 
4958					if DEBUG_FORTH_WORDS_KEY 
4958						DMARK "UPR" 
4958 f5				push af  
4959 3a 6d 49			ld a, (.dmark)  
495c 32 a0 fd			ld (debug_mark),a  
495f 3a 6e 49			ld a, (.dmark+1)  
4962 32 a1 fd			ld (debug_mark+1),a  
4965 3a 6f 49			ld a, (.dmark+2)  
4968 32 a2 fd			ld (debug_mark+2),a  
496b 18 03			jr .pastdmark  
496d ..			.dmark: db "UPR"  
4970 f1			.pastdmark: pop af  
4971			endm  
# End of macro DMARK
4971						CALLMONITOR 
4971 cd aa fd			call debug_vector  
4974				endm  
# End of macro CALLMONITOR
4974					endif 
4974			 
4974					FORTH_DSP 
4974 cd 13 22			call macro_forth_dsp 
4977				endm 
# End of macro FORTH_DSP
4977					 
4977			; TODO check is string type 
4977			 
4977					FORTH_DSP_VALUEHL 
4977 cd 4d 22			call macro_dsp_valuehl 
497a				endm 
# End of macro FORTH_DSP_VALUEHL
497a			; get pointer to string in hl 
497a			 
497a 7e			.toup:		ld a, (hl) 
497b fe 00				cp 0 
497d 28 07				jr z, .toupdone 
497f			 
497f cd 53 12				call to_upper 
4982			 
4982 77					ld (hl), a 
4983 23					inc hl 
4984 18 f4				jr .toup 
4986			 
4986					 
4986			 
4986			 
4986			; for each char convert to upper 
4986					 
4986			.toupdone: 
4986			 
4986			 
4986					NEXTW 
4986 c3 38 24			jp macro_next 
4989				endm 
# End of macro NEXTW
4989			.LOWER: 
4989				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4989 48				db WORD_SYS_CORE+52             
498a c4 49			dw .TCASE            
498c 06				db 5 + 1 
498d .. 00			db "LOWER",0              
4993				endm 
# End of macro CWHEAD
4993			; | LOWER ( s -- s ) Lower case string s  | DONE 
4993					if DEBUG_FORTH_WORDS_KEY 
4993						DMARK "LWR" 
4993 f5				push af  
4994 3a a8 49			ld a, (.dmark)  
4997 32 a0 fd			ld (debug_mark),a  
499a 3a a9 49			ld a, (.dmark+1)  
499d 32 a1 fd			ld (debug_mark+1),a  
49a0 3a aa 49			ld a, (.dmark+2)  
49a3 32 a2 fd			ld (debug_mark+2),a  
49a6 18 03			jr .pastdmark  
49a8 ..			.dmark: db "LWR"  
49ab f1			.pastdmark: pop af  
49ac			endm  
# End of macro DMARK
49ac						CALLMONITOR 
49ac cd aa fd			call debug_vector  
49af				endm  
# End of macro CALLMONITOR
49af					endif 
49af			 
49af					FORTH_DSP 
49af cd 13 22			call macro_forth_dsp 
49b2				endm 
# End of macro FORTH_DSP
49b2					 
49b2			; TODO check is string type 
49b2			 
49b2					FORTH_DSP_VALUEHL 
49b2 cd 4d 22			call macro_dsp_valuehl 
49b5				endm 
# End of macro FORTH_DSP_VALUEHL
49b5			; get pointer to string in hl 
49b5			 
49b5 7e			.tolow:		ld a, (hl) 
49b6 fe 00				cp 0 
49b8 28 07				jr z, .tolowdone 
49ba			 
49ba cd 5c 12				call to_lower 
49bd			 
49bd 77					ld (hl), a 
49be 23					inc hl 
49bf 18 f4				jr .tolow 
49c1			 
49c1					 
49c1			 
49c1			 
49c1			; for each char convert to low 
49c1					 
49c1			.tolowdone: 
49c1					NEXTW 
49c1 c3 38 24			jp macro_next 
49c4				endm 
# End of macro NEXTW
49c4			.TCASE: 
49c4				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
49c4 48				db WORD_SYS_CORE+52             
49c5 fa 4a			dw .SUBSTR            
49c7 06				db 5 + 1 
49c8 .. 00			db "TCASE",0              
49ce				endm 
# End of macro CWHEAD
49ce			; | TCASE ( s -- s ) Title case string s  | DONE 
49ce					if DEBUG_FORTH_WORDS_KEY 
49ce						DMARK "TCS" 
49ce f5				push af  
49cf 3a e3 49			ld a, (.dmark)  
49d2 32 a0 fd			ld (debug_mark),a  
49d5 3a e4 49			ld a, (.dmark+1)  
49d8 32 a1 fd			ld (debug_mark+1),a  
49db 3a e5 49			ld a, (.dmark+2)  
49de 32 a2 fd			ld (debug_mark+2),a  
49e1 18 03			jr .pastdmark  
49e3 ..			.dmark: db "TCS"  
49e6 f1			.pastdmark: pop af  
49e7			endm  
# End of macro DMARK
49e7						CALLMONITOR 
49e7 cd aa fd			call debug_vector  
49ea				endm  
# End of macro CALLMONITOR
49ea					endif 
49ea			 
49ea					FORTH_DSP 
49ea cd 13 22			call macro_forth_dsp 
49ed				endm 
# End of macro FORTH_DSP
49ed					 
49ed			; TODO check is string type 
49ed			 
49ed					FORTH_DSP_VALUEHL 
49ed cd 4d 22			call macro_dsp_valuehl 
49f0				endm 
# End of macro FORTH_DSP_VALUEHL
49f0			; get pointer to string in hl 
49f0			 
49f0					if DEBUG_FORTH_WORDS 
49f0						DMARK "TC1" 
49f0 f5				push af  
49f1 3a 05 4a			ld a, (.dmark)  
49f4 32 a0 fd			ld (debug_mark),a  
49f7 3a 06 4a			ld a, (.dmark+1)  
49fa 32 a1 fd			ld (debug_mark+1),a  
49fd 3a 07 4a			ld a, (.dmark+2)  
4a00 32 a2 fd			ld (debug_mark+2),a  
4a03 18 03			jr .pastdmark  
4a05 ..			.dmark: db "TC1"  
4a08 f1			.pastdmark: pop af  
4a09			endm  
# End of macro DMARK
4a09						CALLMONITOR 
4a09 cd aa fd			call debug_vector  
4a0c				endm  
# End of macro CALLMONITOR
4a0c					endif 
4a0c			 
4a0c					; first time in turn to upper case first char 
4a0c			 
4a0c 7e					ld a, (hl) 
4a0d c3 97 4a				jp .totsiptou 
4a10			 
4a10			 
4a10 7e			.tot:		ld a, (hl) 
4a11 fe 00				cp 0 
4a13 ca db 4a				jp z, .totdone 
4a16			 
4a16					if DEBUG_FORTH_WORDS 
4a16						DMARK "TC2" 
4a16 f5				push af  
4a17 3a 2b 4a			ld a, (.dmark)  
4a1a 32 a0 fd			ld (debug_mark),a  
4a1d 3a 2c 4a			ld a, (.dmark+1)  
4a20 32 a1 fd			ld (debug_mark+1),a  
4a23 3a 2d 4a			ld a, (.dmark+2)  
4a26 32 a2 fd			ld (debug_mark+2),a  
4a29 18 03			jr .pastdmark  
4a2b ..			.dmark: db "TC2"  
4a2e f1			.pastdmark: pop af  
4a2f			endm  
# End of macro DMARK
4a2f						CALLMONITOR 
4a2f cd aa fd			call debug_vector  
4a32				endm  
# End of macro CALLMONITOR
4a32					endif 
4a32					; check to see if current char is a space 
4a32			 
4a32 fe 20				cp ' ' 
4a34 28 21				jr z, .totsp 
4a36 cd 5c 12				call to_lower 
4a39					if DEBUG_FORTH_WORDS 
4a39						DMARK "TC3" 
4a39 f5				push af  
4a3a 3a 4e 4a			ld a, (.dmark)  
4a3d 32 a0 fd			ld (debug_mark),a  
4a40 3a 4f 4a			ld a, (.dmark+1)  
4a43 32 a1 fd			ld (debug_mark+1),a  
4a46 3a 50 4a			ld a, (.dmark+2)  
4a49 32 a2 fd			ld (debug_mark+2),a  
4a4c 18 03			jr .pastdmark  
4a4e ..			.dmark: db "TC3"  
4a51 f1			.pastdmark: pop af  
4a52			endm  
# End of macro DMARK
4a52						CALLMONITOR 
4a52 cd aa fd			call debug_vector  
4a55				endm  
# End of macro CALLMONITOR
4a55					endif 
4a55 18 63				jr .totnxt 
4a57			 
4a57			.totsp:         ; on a space, find next char which should be upper 
4a57			 
4a57					if DEBUG_FORTH_WORDS 
4a57						DMARK "TC4" 
4a57 f5				push af  
4a58 3a 6c 4a			ld a, (.dmark)  
4a5b 32 a0 fd			ld (debug_mark),a  
4a5e 3a 6d 4a			ld a, (.dmark+1)  
4a61 32 a1 fd			ld (debug_mark+1),a  
4a64 3a 6e 4a			ld a, (.dmark+2)  
4a67 32 a2 fd			ld (debug_mark+2),a  
4a6a 18 03			jr .pastdmark  
4a6c ..			.dmark: db "TC4"  
4a6f f1			.pastdmark: pop af  
4a70			endm  
# End of macro DMARK
4a70						CALLMONITOR 
4a70 cd aa fd			call debug_vector  
4a73				endm  
# End of macro CALLMONITOR
4a73					endif 
4a73					;; 
4a73			 
4a73 fe 20				cp ' ' 
4a75 20 20				jr nz, .totsiptou 
4a77 23					inc hl 
4a78 7e					ld a, (hl) 
4a79					if DEBUG_FORTH_WORDS 
4a79						DMARK "TC5" 
4a79 f5				push af  
4a7a 3a 8e 4a			ld a, (.dmark)  
4a7d 32 a0 fd			ld (debug_mark),a  
4a80 3a 8f 4a			ld a, (.dmark+1)  
4a83 32 a1 fd			ld (debug_mark+1),a  
4a86 3a 90 4a			ld a, (.dmark+2)  
4a89 32 a2 fd			ld (debug_mark+2),a  
4a8c 18 03			jr .pastdmark  
4a8e ..			.dmark: db "TC5"  
4a91 f1			.pastdmark: pop af  
4a92			endm  
# End of macro DMARK
4a92						CALLMONITOR 
4a92 cd aa fd			call debug_vector  
4a95				endm  
# End of macro CALLMONITOR
4a95					endif 
4a95 18 c0				jr .totsp 
4a97 fe 00		.totsiptou:    cp 0 
4a99 28 40				jr z, .totdone 
4a9b					; not space and not zero term so upper case it 
4a9b cd 53 12				call to_upper 
4a9e			 
4a9e					if DEBUG_FORTH_WORDS 
4a9e						DMARK "TC6" 
4a9e f5				push af  
4a9f 3a b3 4a			ld a, (.dmark)  
4aa2 32 a0 fd			ld (debug_mark),a  
4aa5 3a b4 4a			ld a, (.dmark+1)  
4aa8 32 a1 fd			ld (debug_mark+1),a  
4aab 3a b5 4a			ld a, (.dmark+2)  
4aae 32 a2 fd			ld (debug_mark+2),a  
4ab1 18 03			jr .pastdmark  
4ab3 ..			.dmark: db "TC6"  
4ab6 f1			.pastdmark: pop af  
4ab7			endm  
# End of macro DMARK
4ab7						CALLMONITOR 
4ab7 cd aa fd			call debug_vector  
4aba				endm  
# End of macro CALLMONITOR
4aba					endif 
4aba			 
4aba			 
4aba			.totnxt: 
4aba			 
4aba 77					ld (hl), a 
4abb 23					inc hl 
4abc					if DEBUG_FORTH_WORDS 
4abc						DMARK "TC7" 
4abc f5				push af  
4abd 3a d1 4a			ld a, (.dmark)  
4ac0 32 a0 fd			ld (debug_mark),a  
4ac3 3a d2 4a			ld a, (.dmark+1)  
4ac6 32 a1 fd			ld (debug_mark+1),a  
4ac9 3a d3 4a			ld a, (.dmark+2)  
4acc 32 a2 fd			ld (debug_mark+2),a  
4acf 18 03			jr .pastdmark  
4ad1 ..			.dmark: db "TC7"  
4ad4 f1			.pastdmark: pop af  
4ad5			endm  
# End of macro DMARK
4ad5						CALLMONITOR 
4ad5 cd aa fd			call debug_vector  
4ad8				endm  
# End of macro CALLMONITOR
4ad8					endif 
4ad8 c3 10 4a				jp .tot 
4adb			 
4adb					 
4adb			 
4adb			 
4adb			; for each char convert to low 
4adb					 
4adb			.totdone: 
4adb					if DEBUG_FORTH_WORDS 
4adb						DMARK "TCd" 
4adb f5				push af  
4adc 3a f0 4a			ld a, (.dmark)  
4adf 32 a0 fd			ld (debug_mark),a  
4ae2 3a f1 4a			ld a, (.dmark+1)  
4ae5 32 a1 fd			ld (debug_mark+1),a  
4ae8 3a f2 4a			ld a, (.dmark+2)  
4aeb 32 a2 fd			ld (debug_mark+2),a  
4aee 18 03			jr .pastdmark  
4af0 ..			.dmark: db "TCd"  
4af3 f1			.pastdmark: pop af  
4af4			endm  
# End of macro DMARK
4af4						CALLMONITOR 
4af4 cd aa fd			call debug_vector  
4af7				endm  
# End of macro CALLMONITOR
4af7					endif 
4af7					NEXTW 
4af7 c3 38 24			jp macro_next 
4afa				endm 
# End of macro NEXTW
4afa			 
4afa			.SUBSTR: 
4afa				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4afa 48				db WORD_SYS_CORE+52             
4afb 58 4b			dw .LEFT            
4afd 07				db 6 + 1 
4afe .. 00			db "SUBSTR",0              
4b05				endm 
# End of macro CWHEAD
4b05			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4b05			 
4b05					if DEBUG_FORTH_WORDS_KEY 
4b05						DMARK "SST" 
4b05 f5				push af  
4b06 3a 1a 4b			ld a, (.dmark)  
4b09 32 a0 fd			ld (debug_mark),a  
4b0c 3a 1b 4b			ld a, (.dmark+1)  
4b0f 32 a1 fd			ld (debug_mark+1),a  
4b12 3a 1c 4b			ld a, (.dmark+2)  
4b15 32 a2 fd			ld (debug_mark+2),a  
4b18 18 03			jr .pastdmark  
4b1a ..			.dmark: db "SST"  
4b1d f1			.pastdmark: pop af  
4b1e			endm  
# End of macro DMARK
4b1e						CALLMONITOR 
4b1e cd aa fd			call debug_vector  
4b21				endm  
# End of macro CALLMONITOR
4b21					endif 
4b21			; TODO check string type 
4b21					FORTH_DSP_VALUEHL 
4b21 cd 4d 22			call macro_dsp_valuehl 
4b24				endm 
# End of macro FORTH_DSP_VALUEHL
4b24			 
4b24 e5					push hl      ; string length 
4b25			 
4b25					FORTH_DSP_POP 
4b25 cd 05 23			call macro_forth_dsp_pop 
4b28				endm 
# End of macro FORTH_DSP_POP
4b28			 
4b28					FORTH_DSP_VALUEHL 
4b28 cd 4d 22			call macro_dsp_valuehl 
4b2b				endm 
# End of macro FORTH_DSP_VALUEHL
4b2b			 
4b2b e5					push hl     ; start char 
4b2c			 
4b2c					FORTH_DSP_POP 
4b2c cd 05 23			call macro_forth_dsp_pop 
4b2f				endm 
# End of macro FORTH_DSP_POP
4b2f			 
4b2f			 
4b2f					FORTH_DSP_VALUE 
4b2f cd 36 22			call macro_forth_dsp_value 
4b32				endm 
# End of macro FORTH_DSP_VALUE
4b32			 
4b32 d1					pop de    ; get start post offset 
4b33			 
4b33 19					add hl, de    ; starting offset 
4b34			 
4b34 c1					pop bc 
4b35 c5					push bc      ; grab size of string 
4b36			 
4b36 e5					push hl    ; save string start  
4b37			 
4b37 26 00				ld h, 0 
4b39 69					ld l, c 
4b3a 23					inc hl 
4b3b 23					inc hl 
4b3c			 
4b3c cd b9 13				call malloc 
4b3f				if DEBUG_FORTH_MALLOC_GUARD 
4b3f cc 3a 61				call z,malloc_error 
4b42				endif 
4b42			 
4b42 eb					ex de, hl      ; save malloc area for string copy 
4b43 e1					pop hl    ; get back source 
4b44 c1					pop bc    ; get length of string back 
4b45			 
4b45 d5					push de    ; save malloc area for after we push 
4b46 ed b0				ldir     ; copy substr 
4b48			 
4b48			 
4b48 eb					ex de, hl 
4b49 3e 00				ld a, 0 
4b4b 77					ld (hl), a   ; term substr 
4b4c			 
4b4c					 
4b4c e1					pop hl    ; get malloc so we can push it 
4b4d e5					push hl   ; save so we can free it afterwards 
4b4e			 
4b4e cd b6 20				call forth_push_str 
4b51			 
4b51 e1					pop hl 
4b52 cd 83 14				call free 
4b55			 
4b55					 
4b55					 
4b55			 
4b55			 
4b55					NEXTW 
4b55 c3 38 24			jp macro_next 
4b58				endm 
# End of macro NEXTW
4b58			 
4b58			.LEFT: 
4b58				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4b58 48				db WORD_SYS_CORE+52             
4b59 80 4b			dw .RIGHT            
4b5b 05				db 4 + 1 
4b5c .. 00			db "LEFT",0              
4b61				endm 
# End of macro CWHEAD
4b61			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4b61					if DEBUG_FORTH_WORDS_KEY 
4b61						DMARK "LEF" 
4b61 f5				push af  
4b62 3a 76 4b			ld a, (.dmark)  
4b65 32 a0 fd			ld (debug_mark),a  
4b68 3a 77 4b			ld a, (.dmark+1)  
4b6b 32 a1 fd			ld (debug_mark+1),a  
4b6e 3a 78 4b			ld a, (.dmark+2)  
4b71 32 a2 fd			ld (debug_mark+2),a  
4b74 18 03			jr .pastdmark  
4b76 ..			.dmark: db "LEF"  
4b79 f1			.pastdmark: pop af  
4b7a			endm  
# End of macro DMARK
4b7a						CALLMONITOR 
4b7a cd aa fd			call debug_vector  
4b7d				endm  
# End of macro CALLMONITOR
4b7d					endif 
4b7d			 
4b7d					NEXTW 
4b7d c3 38 24			jp macro_next 
4b80				endm 
# End of macro NEXTW
4b80			.RIGHT: 
4b80				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4b80 48				db WORD_SYS_CORE+52             
4b81 a9 4b			dw .STR2NUM            
4b83 06				db 5 + 1 
4b84 .. 00			db "RIGHT",0              
4b8a				endm 
# End of macro CWHEAD
4b8a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4b8a					if DEBUG_FORTH_WORDS_KEY 
4b8a						DMARK "RIG" 
4b8a f5				push af  
4b8b 3a 9f 4b			ld a, (.dmark)  
4b8e 32 a0 fd			ld (debug_mark),a  
4b91 3a a0 4b			ld a, (.dmark+1)  
4b94 32 a1 fd			ld (debug_mark+1),a  
4b97 3a a1 4b			ld a, (.dmark+2)  
4b9a 32 a2 fd			ld (debug_mark+2),a  
4b9d 18 03			jr .pastdmark  
4b9f ..			.dmark: db "RIG"  
4ba2 f1			.pastdmark: pop af  
4ba3			endm  
# End of macro DMARK
4ba3						CALLMONITOR 
4ba3 cd aa fd			call debug_vector  
4ba6				endm  
# End of macro CALLMONITOR
4ba6					endif 
4ba6			 
4ba6					NEXTW 
4ba6 c3 38 24			jp macro_next 
4ba9				endm 
# End of macro NEXTW
4ba9			 
4ba9			 
4ba9			.STR2NUM: 
4ba9				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4ba9 48				db WORD_SYS_CORE+52             
4baa 35 4c			dw .NUM2STR            
4bac 08				db 7 + 1 
4bad .. 00			db "STR2NUM",0              
4bb5				endm 
# End of macro CWHEAD
4bb5			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4bb5			 
4bb5			 
4bb5			; TODO STR type check to do 
4bb5					if DEBUG_FORTH_WORDS_KEY 
4bb5						DMARK "S2N" 
4bb5 f5				push af  
4bb6 3a ca 4b			ld a, (.dmark)  
4bb9 32 a0 fd			ld (debug_mark),a  
4bbc 3a cb 4b			ld a, (.dmark+1)  
4bbf 32 a1 fd			ld (debug_mark+1),a  
4bc2 3a cc 4b			ld a, (.dmark+2)  
4bc5 32 a2 fd			ld (debug_mark+2),a  
4bc8 18 03			jr .pastdmark  
4bca ..			.dmark: db "S2N"  
4bcd f1			.pastdmark: pop af  
4bce			endm  
# End of macro DMARK
4bce						CALLMONITOR 
4bce cd aa fd			call debug_vector  
4bd1				endm  
# End of macro CALLMONITOR
4bd1					endif 
4bd1			 
4bd1					;FORTH_DSP 
4bd1					FORTH_DSP_VALUE 
4bd1 cd 36 22			call macro_forth_dsp_value 
4bd4				endm 
# End of macro FORTH_DSP_VALUE
4bd4					;inc hl 
4bd4			 
4bd4 eb					ex de, hl 
4bd5					if DEBUG_FORTH_WORDS 
4bd5						DMARK "S2a" 
4bd5 f5				push af  
4bd6 3a ea 4b			ld a, (.dmark)  
4bd9 32 a0 fd			ld (debug_mark),a  
4bdc 3a eb 4b			ld a, (.dmark+1)  
4bdf 32 a1 fd			ld (debug_mark+1),a  
4be2 3a ec 4b			ld a, (.dmark+2)  
4be5 32 a2 fd			ld (debug_mark+2),a  
4be8 18 03			jr .pastdmark  
4bea ..			.dmark: db "S2a"  
4bed f1			.pastdmark: pop af  
4bee			endm  
# End of macro DMARK
4bee						CALLMONITOR 
4bee cd aa fd			call debug_vector  
4bf1				endm  
# End of macro CALLMONITOR
4bf1					endif 
4bf1 cd db 12				call string_to_uint16 
4bf4			 
4bf4					if DEBUG_FORTH_WORDS 
4bf4						DMARK "S2b" 
4bf4 f5				push af  
4bf5 3a 09 4c			ld a, (.dmark)  
4bf8 32 a0 fd			ld (debug_mark),a  
4bfb 3a 0a 4c			ld a, (.dmark+1)  
4bfe 32 a1 fd			ld (debug_mark+1),a  
4c01 3a 0b 4c			ld a, (.dmark+2)  
4c04 32 a2 fd			ld (debug_mark+2),a  
4c07 18 03			jr .pastdmark  
4c09 ..			.dmark: db "S2b"  
4c0c f1			.pastdmark: pop af  
4c0d			endm  
# End of macro DMARK
4c0d						CALLMONITOR 
4c0d cd aa fd			call debug_vector  
4c10				endm  
# End of macro CALLMONITOR
4c10					endif 
4c10			;		push hl 
4c10					FORTH_DSP_POP 
4c10 cd 05 23			call macro_forth_dsp_pop 
4c13				endm 
# End of macro FORTH_DSP_POP
4c13			;		pop hl 
4c13					 
4c13					if DEBUG_FORTH_WORDS 
4c13						DMARK "S2b" 
4c13 f5				push af  
4c14 3a 28 4c			ld a, (.dmark)  
4c17 32 a0 fd			ld (debug_mark),a  
4c1a 3a 29 4c			ld a, (.dmark+1)  
4c1d 32 a1 fd			ld (debug_mark+1),a  
4c20 3a 2a 4c			ld a, (.dmark+2)  
4c23 32 a2 fd			ld (debug_mark+2),a  
4c26 18 03			jr .pastdmark  
4c28 ..			.dmark: db "S2b"  
4c2b f1			.pastdmark: pop af  
4c2c			endm  
# End of macro DMARK
4c2c						CALLMONITOR 
4c2c cd aa fd			call debug_vector  
4c2f				endm  
# End of macro CALLMONITOR
4c2f					endif 
4c2f cd 48 20				call forth_push_numhl	 
4c32			 
4c32				 
4c32				       NEXTW 
4c32 c3 38 24			jp macro_next 
4c35				endm 
# End of macro NEXTW
4c35			.NUM2STR: 
4c35				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4c35 48				db WORD_SYS_CORE+52             
4c36 c7 4c			dw .CONCAT            
4c38 08				db 7 + 1 
4c39 .. 00			db "NUM2STR",0              
4c41				endm 
# End of macro CWHEAD
4c41			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
4c41			 
4c41			;		; malloc a string to target 
4c41			;		ld hl, 10     ; TODO max string size should be fine 
4c41			;		call malloc 
4c41			;		push hl    ; save malloc location 
4c41			; 
4c41			; 
4c41			;; TODO check int type 
4c41					if DEBUG_FORTH_WORDS_KEY 
4c41						DMARK "N2S" 
4c41 f5				push af  
4c42 3a 56 4c			ld a, (.dmark)  
4c45 32 a0 fd			ld (debug_mark),a  
4c48 3a 57 4c			ld a, (.dmark+1)  
4c4b 32 a1 fd			ld (debug_mark+1),a  
4c4e 3a 58 4c			ld a, (.dmark+2)  
4c51 32 a2 fd			ld (debug_mark+2),a  
4c54 18 03			jr .pastdmark  
4c56 ..			.dmark: db "N2S"  
4c59 f1			.pastdmark: pop af  
4c5a			endm  
# End of macro DMARK
4c5a						CALLMONITOR 
4c5a cd aa fd			call debug_vector  
4c5d				endm  
# End of macro CALLMONITOR
4c5d					endif 
4c5d			 
4c5d					FORTH_DSP_VALUEHL 
4c5d cd 4d 22			call macro_dsp_valuehl 
4c60				endm 
# End of macro FORTH_DSP_VALUEHL
4c60			 
4c60					if DEBUG_FORTH_WORDS 
4c60						DMARK "NS1" 
4c60 f5				push af  
4c61 3a 75 4c			ld a, (.dmark)  
4c64 32 a0 fd			ld (debug_mark),a  
4c67 3a 76 4c			ld a, (.dmark+1)  
4c6a 32 a1 fd			ld (debug_mark+1),a  
4c6d 3a 77 4c			ld a, (.dmark+2)  
4c70 32 a2 fd			ld (debug_mark+2),a  
4c73 18 03			jr .pastdmark  
4c75 ..			.dmark: db "NS1"  
4c78 f1			.pastdmark: pop af  
4c79			endm  
# End of macro DMARK
4c79						CALLMONITOR 
4c79 cd aa fd			call debug_vector  
4c7c				endm  
# End of macro CALLMONITOR
4c7c					endif 
4c7c					FORTH_DSP_POP 
4c7c cd 05 23			call macro_forth_dsp_pop 
4c7f				endm 
# End of macro FORTH_DSP_POP
4c7f			 
4c7f eb					ex de, hl 
4c80 21 f6 f0				ld hl, scratch 
4c83					if DEBUG_FORTH_WORDS 
4c83						DMARK "NS2" 
4c83 f5				push af  
4c84 3a 98 4c			ld a, (.dmark)  
4c87 32 a0 fd			ld (debug_mark),a  
4c8a 3a 99 4c			ld a, (.dmark+1)  
4c8d 32 a1 fd			ld (debug_mark+1),a  
4c90 3a 9a 4c			ld a, (.dmark+2)  
4c93 32 a2 fd			ld (debug_mark+2),a  
4c96 18 03			jr .pastdmark  
4c98 ..			.dmark: db "NS2"  
4c9b f1			.pastdmark: pop af  
4c9c			endm  
# End of macro DMARK
4c9c						CALLMONITOR 
4c9c cd aa fd			call debug_vector  
4c9f				endm  
# End of macro CALLMONITOR
4c9f					endif 
4c9f cd f3 12				call uitoa_16 
4ca2 21 f6 f0				ld hl, scratch 
4ca5					if DEBUG_FORTH_WORDS 
4ca5						DMARK "NS3" 
4ca5 f5				push af  
4ca6 3a ba 4c			ld a, (.dmark)  
4ca9 32 a0 fd			ld (debug_mark),a  
4cac 3a bb 4c			ld a, (.dmark+1)  
4caf 32 a1 fd			ld (debug_mark+1),a  
4cb2 3a bc 4c			ld a, (.dmark+2)  
4cb5 32 a2 fd			ld (debug_mark+2),a  
4cb8 18 03			jr .pastdmark  
4cba ..			.dmark: db "NS3"  
4cbd f1			.pastdmark: pop af  
4cbe			endm  
# End of macro DMARK
4cbe						CALLMONITOR 
4cbe cd aa fd			call debug_vector  
4cc1				endm  
# End of macro CALLMONITOR
4cc1					endif 
4cc1 cd b6 20				call forth_push_str 
4cc4			;		ld a, l 
4cc4			;		call DispAToASCII   
4cc4			;;TODO need to chage above call to dump into string 
4cc4			; 
4cc4			; 
4cc4			 
4cc4				       NEXTW 
4cc4 c3 38 24			jp macro_next 
4cc7				endm 
# End of macro NEXTW
4cc7			 
4cc7			.CONCAT: 
4cc7				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4cc7 48				db WORD_SYS_CORE+52             
4cc8 7a 4d			dw .FIND            
4cca 07				db 6 + 1 
4ccb .. 00			db "CONCAT",0              
4cd2				endm 
# End of macro CWHEAD
4cd2			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4cd2			 
4cd2			; TODO check string type 
4cd2			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4cd2			 
4cd2					if DEBUG_FORTH_WORDS_KEY 
4cd2						DMARK "CON" 
4cd2 f5				push af  
4cd3 3a e7 4c			ld a, (.dmark)  
4cd6 32 a0 fd			ld (debug_mark),a  
4cd9 3a e8 4c			ld a, (.dmark+1)  
4cdc 32 a1 fd			ld (debug_mark+1),a  
4cdf 3a e9 4c			ld a, (.dmark+2)  
4ce2 32 a2 fd			ld (debug_mark+2),a  
4ce5 18 03			jr .pastdmark  
4ce7 ..			.dmark: db "CON"  
4cea f1			.pastdmark: pop af  
4ceb			endm  
# End of macro DMARK
4ceb						CALLMONITOR 
4ceb cd aa fd			call debug_vector  
4cee				endm  
# End of macro CALLMONITOR
4cee					endif 
4cee			 
4cee			 
4cee					FORTH_DSP_VALUE 
4cee cd 36 22			call macro_forth_dsp_value 
4cf1				endm 
# End of macro FORTH_DSP_VALUE
4cf1 e5					push hl   ; s2 
4cf2			 
4cf2					FORTH_DSP_POP 
4cf2 cd 05 23			call macro_forth_dsp_pop 
4cf5				endm 
# End of macro FORTH_DSP_POP
4cf5			 
4cf5					FORTH_DSP_VALUE 
4cf5 cd 36 22			call macro_forth_dsp_value 
4cf8				endm 
# End of macro FORTH_DSP_VALUE
4cf8			 
4cf8 e5					push hl   ; s1 
4cf9			 
4cf9					FORTH_DSP_POP 
4cf9 cd 05 23			call macro_forth_dsp_pop 
4cfc				endm 
# End of macro FORTH_DSP_POP
4cfc					 
4cfc			 
4cfc					; copy s1 
4cfc			 
4cfc				 
4cfc					; save ptr 
4cfc e1					pop hl  
4cfd e5					push hl 
4cfe 3e 00				ld a, 0 
4d00 cd 4f 13				call strlent 
4d03					;inc hl    ; zer0 
4d03 06 00				ld b, 0 
4d05 4d					ld c, l 
4d06 e1					pop hl		 
4d07 11 f6 f0				ld de, scratch	 
4d0a					if DEBUG_FORTH_WORDS 
4d0a						DMARK "CO1" 
4d0a f5				push af  
4d0b 3a 1f 4d			ld a, (.dmark)  
4d0e 32 a0 fd			ld (debug_mark),a  
4d11 3a 20 4d			ld a, (.dmark+1)  
4d14 32 a1 fd			ld (debug_mark+1),a  
4d17 3a 21 4d			ld a, (.dmark+2)  
4d1a 32 a2 fd			ld (debug_mark+2),a  
4d1d 18 03			jr .pastdmark  
4d1f ..			.dmark: db "CO1"  
4d22 f1			.pastdmark: pop af  
4d23			endm  
# End of macro DMARK
4d23						CALLMONITOR 
4d23 cd aa fd			call debug_vector  
4d26				endm  
# End of macro CALLMONITOR
4d26					endif 
4d26 ed b0				ldir 
4d28			 
4d28 e1					pop hl 
4d29 e5					push hl 
4d2a d5					push de 
4d2b			 
4d2b			 
4d2b 3e 00				ld a, 0 
4d2d cd 4f 13				call strlent 
4d30 23					inc hl    ; zer0 
4d31 23					inc hl 
4d32 06 00				ld b, 0 
4d34 4d					ld c, l 
4d35 d1					pop de 
4d36 e1					pop hl		 
4d37					if DEBUG_FORTH_WORDS 
4d37						DMARK "CO2" 
4d37 f5				push af  
4d38 3a 4c 4d			ld a, (.dmark)  
4d3b 32 a0 fd			ld (debug_mark),a  
4d3e 3a 4d 4d			ld a, (.dmark+1)  
4d41 32 a1 fd			ld (debug_mark+1),a  
4d44 3a 4e 4d			ld a, (.dmark+2)  
4d47 32 a2 fd			ld (debug_mark+2),a  
4d4a 18 03			jr .pastdmark  
4d4c ..			.dmark: db "CO2"  
4d4f f1			.pastdmark: pop af  
4d50			endm  
# End of macro DMARK
4d50						CALLMONITOR 
4d50 cd aa fd			call debug_vector  
4d53				endm  
# End of macro CALLMONITOR
4d53					endif 
4d53 ed b0				ldir 
4d55			 
4d55			 
4d55			 
4d55 21 f6 f0				ld hl, scratch 
4d58					if DEBUG_FORTH_WORDS 
4d58						DMARK "CO5" 
4d58 f5				push af  
4d59 3a 6d 4d			ld a, (.dmark)  
4d5c 32 a0 fd			ld (debug_mark),a  
4d5f 3a 6e 4d			ld a, (.dmark+1)  
4d62 32 a1 fd			ld (debug_mark+1),a  
4d65 3a 6f 4d			ld a, (.dmark+2)  
4d68 32 a2 fd			ld (debug_mark+2),a  
4d6b 18 03			jr .pastdmark  
4d6d ..			.dmark: db "CO5"  
4d70 f1			.pastdmark: pop af  
4d71			endm  
# End of macro DMARK
4d71						CALLMONITOR 
4d71 cd aa fd			call debug_vector  
4d74				endm  
# End of macro CALLMONITOR
4d74					endif 
4d74			 
4d74 cd b6 20				call forth_push_str 
4d77			 
4d77			 
4d77			 
4d77			 
4d77				       NEXTW 
4d77 c3 38 24			jp macro_next 
4d7a				endm 
# End of macro NEXTW
4d7a			 
4d7a			 
4d7a			.FIND: 
4d7a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4d7a 4b				db WORD_SYS_CORE+55             
4d7b 38 4e			dw .LEN            
4d7d 05				db 4 + 1 
4d7e .. 00			db "FIND",0              
4d83				endm 
# End of macro CWHEAD
4d83			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4d83			 
4d83					if DEBUG_FORTH_WORDS_KEY 
4d83						DMARK "FND" 
4d83 f5				push af  
4d84 3a 98 4d			ld a, (.dmark)  
4d87 32 a0 fd			ld (debug_mark),a  
4d8a 3a 99 4d			ld a, (.dmark+1)  
4d8d 32 a1 fd			ld (debug_mark+1),a  
4d90 3a 9a 4d			ld a, (.dmark+2)  
4d93 32 a2 fd			ld (debug_mark+2),a  
4d96 18 03			jr .pastdmark  
4d98 ..			.dmark: db "FND"  
4d9b f1			.pastdmark: pop af  
4d9c			endm  
# End of macro DMARK
4d9c						CALLMONITOR 
4d9c cd aa fd			call debug_vector  
4d9f				endm  
# End of macro CALLMONITOR
4d9f					endif 
4d9f			 
4d9f			; TODO check string type 
4d9f					FORTH_DSP_VALUE 
4d9f cd 36 22			call macro_forth_dsp_value 
4da2				endm 
# End of macro FORTH_DSP_VALUE
4da2			 
4da2 e5					push hl    
4da3 7e					ld a,(hl)    ; char to find   
4da4			; TODO change char to substr 
4da4			 
4da4 f5					push af 
4da5					 
4da5			 
4da5			 
4da5					if DEBUG_FORTH_WORDS 
4da5						DMARK "FN1" 
4da5 f5				push af  
4da6 3a ba 4d			ld a, (.dmark)  
4da9 32 a0 fd			ld (debug_mark),a  
4dac 3a bb 4d			ld a, (.dmark+1)  
4daf 32 a1 fd			ld (debug_mark+1),a  
4db2 3a bc 4d			ld a, (.dmark+2)  
4db5 32 a2 fd			ld (debug_mark+2),a  
4db8 18 03			jr .pastdmark  
4dba ..			.dmark: db "FN1"  
4dbd f1			.pastdmark: pop af  
4dbe			endm  
# End of macro DMARK
4dbe						CALLMONITOR 
4dbe cd aa fd			call debug_vector  
4dc1				endm  
# End of macro CALLMONITOR
4dc1					endif 
4dc1			 
4dc1					FORTH_DSP_POP 
4dc1 cd 05 23			call macro_forth_dsp_pop 
4dc4				endm 
# End of macro FORTH_DSP_POP
4dc4			 
4dc4					; string to search 
4dc4			 
4dc4					FORTH_DSP_VALUE 
4dc4 cd 36 22			call macro_forth_dsp_value 
4dc7				endm 
# End of macro FORTH_DSP_VALUE
4dc7			 
4dc7 d1					pop de  ; d is char to find  
4dc8			 
4dc8					if DEBUG_FORTH_WORDS 
4dc8						DMARK "FN2" 
4dc8 f5				push af  
4dc9 3a dd 4d			ld a, (.dmark)  
4dcc 32 a0 fd			ld (debug_mark),a  
4dcf 3a de 4d			ld a, (.dmark+1)  
4dd2 32 a1 fd			ld (debug_mark+1),a  
4dd5 3a df 4d			ld a, (.dmark+2)  
4dd8 32 a2 fd			ld (debug_mark+2),a  
4ddb 18 03			jr .pastdmark  
4ddd ..			.dmark: db "FN2"  
4de0 f1			.pastdmark: pop af  
4de1			endm  
# End of macro DMARK
4de1						CALLMONITOR 
4de1 cd aa fd			call debug_vector  
4de4				endm  
# End of macro CALLMONITOR
4de4					endif 
4de4					 
4de4 01 00 00				ld bc, 0 
4de7 7e			.findchar:      ld a,(hl) 
4de8 fe 00				cp 0   		 
4dea 28 27				jr z, .finddone     
4dec ba					cp d 
4ded 28 20				jr z, .foundchar 
4def 03					inc bc 
4df0 23					inc hl 
4df1					if DEBUG_FORTH_WORDS 
4df1						DMARK "FN3" 
4df1 f5				push af  
4df2 3a 06 4e			ld a, (.dmark)  
4df5 32 a0 fd			ld (debug_mark),a  
4df8 3a 07 4e			ld a, (.dmark+1)  
4dfb 32 a1 fd			ld (debug_mark+1),a  
4dfe 3a 08 4e			ld a, (.dmark+2)  
4e01 32 a2 fd			ld (debug_mark+2),a  
4e04 18 03			jr .pastdmark  
4e06 ..			.dmark: db "FN3"  
4e09 f1			.pastdmark: pop af  
4e0a			endm  
# End of macro DMARK
4e0a						CALLMONITOR 
4e0a cd aa fd			call debug_vector  
4e0d				endm  
# End of macro CALLMONITOR
4e0d					endif 
4e0d 18 d8				jr .findchar 
4e0f			 
4e0f			 
4e0f c5			.foundchar:	push bc 
4e10 e1					pop hl 
4e11 18 03				jr .findexit 
4e13			 
4e13			 
4e13							 
4e13			 
4e13			.finddone:     ; got to end of string with no find 
4e13 21 00 00				ld hl, 0 
4e16			.findexit: 
4e16			 
4e16					if DEBUG_FORTH_WORDS 
4e16						DMARK "FNd" 
4e16 f5				push af  
4e17 3a 2b 4e			ld a, (.dmark)  
4e1a 32 a0 fd			ld (debug_mark),a  
4e1d 3a 2c 4e			ld a, (.dmark+1)  
4e20 32 a1 fd			ld (debug_mark+1),a  
4e23 3a 2d 4e			ld a, (.dmark+2)  
4e26 32 a2 fd			ld (debug_mark+2),a  
4e29 18 03			jr .pastdmark  
4e2b ..			.dmark: db "FNd"  
4e2e f1			.pastdmark: pop af  
4e2f			endm  
# End of macro DMARK
4e2f						CALLMONITOR 
4e2f cd aa fd			call debug_vector  
4e32				endm  
# End of macro CALLMONITOR
4e32					endif 
4e32 cd 48 20			call forth_push_numhl 
4e35			 
4e35				       NEXTW 
4e35 c3 38 24			jp macro_next 
4e38				endm 
# End of macro NEXTW
4e38			 
4e38			.LEN: 
4e38				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4e38 4c				db WORD_SYS_CORE+56             
4e39 a2 4e			dw .ASC            
4e3b 06				db 5 + 1 
4e3c .. 00			db "COUNT",0              
4e42				endm 
# End of macro CWHEAD
4e42			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4e42			 
4e42					if DEBUG_FORTH_WORDS_KEY 
4e42						DMARK "CNT" 
4e42 f5				push af  
4e43 3a 57 4e			ld a, (.dmark)  
4e46 32 a0 fd			ld (debug_mark),a  
4e49 3a 58 4e			ld a, (.dmark+1)  
4e4c 32 a1 fd			ld (debug_mark+1),a  
4e4f 3a 59 4e			ld a, (.dmark+2)  
4e52 32 a2 fd			ld (debug_mark+2),a  
4e55 18 03			jr .pastdmark  
4e57 ..			.dmark: db "CNT"  
4e5a f1			.pastdmark: pop af  
4e5b			endm  
# End of macro DMARK
4e5b						CALLMONITOR 
4e5b cd aa fd			call debug_vector  
4e5e				endm  
# End of macro CALLMONITOR
4e5e					endif 
4e5e			; TODO check string type 
4e5e					FORTH_DSP_VALUE 
4e5e cd 36 22			call macro_forth_dsp_value 
4e61				endm 
# End of macro FORTH_DSP_VALUE
4e61			 
4e61			 
4e61					if DEBUG_FORTH_WORDS 
4e61						DMARK "CN?" 
4e61 f5				push af  
4e62 3a 76 4e			ld a, (.dmark)  
4e65 32 a0 fd			ld (debug_mark),a  
4e68 3a 77 4e			ld a, (.dmark+1)  
4e6b 32 a1 fd			ld (debug_mark+1),a  
4e6e 3a 78 4e			ld a, (.dmark+2)  
4e71 32 a2 fd			ld (debug_mark+2),a  
4e74 18 03			jr .pastdmark  
4e76 ..			.dmark: db "CN?"  
4e79 f1			.pastdmark: pop af  
4e7a			endm  
# End of macro DMARK
4e7a						CALLMONITOR 
4e7a cd aa fd			call debug_vector  
4e7d				endm  
# End of macro CALLMONITOR
4e7d					endif 
4e7d cd 44 13				call strlenz 
4e80					if DEBUG_FORTH_WORDS 
4e80						DMARK "CNl" 
4e80 f5				push af  
4e81 3a 95 4e			ld a, (.dmark)  
4e84 32 a0 fd			ld (debug_mark),a  
4e87 3a 96 4e			ld a, (.dmark+1)  
4e8a 32 a1 fd			ld (debug_mark+1),a  
4e8d 3a 97 4e			ld a, (.dmark+2)  
4e90 32 a2 fd			ld (debug_mark+2),a  
4e93 18 03			jr .pastdmark  
4e95 ..			.dmark: db "CNl"  
4e98 f1			.pastdmark: pop af  
4e99			endm  
# End of macro DMARK
4e99						CALLMONITOR 
4e99 cd aa fd			call debug_vector  
4e9c				endm  
# End of macro CALLMONITOR
4e9c					endif 
4e9c			 
4e9c cd 48 20				call forth_push_numhl 
4e9f			 
4e9f			 
4e9f			 
4e9f				       NEXTW 
4e9f c3 38 24			jp macro_next 
4ea2				endm 
# End of macro NEXTW
4ea2			.ASC: 
4ea2				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4ea2 4d				db WORD_SYS_CORE+57             
4ea3 10 4f			dw .CHR            
4ea5 04				db 3 + 1 
4ea6 .. 00			db "ASC",0              
4eaa				endm 
# End of macro CWHEAD
4eaa			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4eaa					if DEBUG_FORTH_WORDS_KEY 
4eaa						DMARK "ASC" 
4eaa f5				push af  
4eab 3a bf 4e			ld a, (.dmark)  
4eae 32 a0 fd			ld (debug_mark),a  
4eb1 3a c0 4e			ld a, (.dmark+1)  
4eb4 32 a1 fd			ld (debug_mark+1),a  
4eb7 3a c1 4e			ld a, (.dmark+2)  
4eba 32 a2 fd			ld (debug_mark+2),a  
4ebd 18 03			jr .pastdmark  
4ebf ..			.dmark: db "ASC"  
4ec2 f1			.pastdmark: pop af  
4ec3			endm  
# End of macro DMARK
4ec3						CALLMONITOR 
4ec3 cd aa fd			call debug_vector  
4ec6				endm  
# End of macro CALLMONITOR
4ec6					endif 
4ec6					FORTH_DSP_VALUE 
4ec6 cd 36 22			call macro_forth_dsp_value 
4ec9				endm 
# End of macro FORTH_DSP_VALUE
4ec9					;v5 FORTH_DSP_VALUE 
4ec9			;		inc hl      ; now at start of numeric as string 
4ec9			 
4ec9 e5					push hl 
4eca			 
4eca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eca cd 05 23			call macro_forth_dsp_pop 
4ecd				endm 
# End of macro FORTH_DSP_POP
4ecd			 
4ecd e1					pop hl 
4ece			 
4ece					if DEBUG_FORTH_WORDS 
4ece						DMARK "AS1" 
4ece f5				push af  
4ecf 3a e3 4e			ld a, (.dmark)  
4ed2 32 a0 fd			ld (debug_mark),a  
4ed5 3a e4 4e			ld a, (.dmark+1)  
4ed8 32 a1 fd			ld (debug_mark+1),a  
4edb 3a e5 4e			ld a, (.dmark+2)  
4ede 32 a2 fd			ld (debug_mark+2),a  
4ee1 18 03			jr .pastdmark  
4ee3 ..			.dmark: db "AS1"  
4ee6 f1			.pastdmark: pop af  
4ee7			endm  
# End of macro DMARK
4ee7						CALLMONITOR 
4ee7 cd aa fd			call debug_vector  
4eea				endm  
# End of macro CALLMONITOR
4eea					endif 
4eea					; push the content of a onto the stack as a value 
4eea			 
4eea 7e					ld a,(hl)   ; get char 
4eeb 26 00				ld h,0 
4eed 6f					ld l,a 
4eee					if DEBUG_FORTH_WORDS 
4eee						DMARK "AS2" 
4eee f5				push af  
4eef 3a 03 4f			ld a, (.dmark)  
4ef2 32 a0 fd			ld (debug_mark),a  
4ef5 3a 04 4f			ld a, (.dmark+1)  
4ef8 32 a1 fd			ld (debug_mark+1),a  
4efb 3a 05 4f			ld a, (.dmark+2)  
4efe 32 a2 fd			ld (debug_mark+2),a  
4f01 18 03			jr .pastdmark  
4f03 ..			.dmark: db "AS2"  
4f06 f1			.pastdmark: pop af  
4f07			endm  
# End of macro DMARK
4f07						CALLMONITOR 
4f07 cd aa fd			call debug_vector  
4f0a				endm  
# End of macro CALLMONITOR
4f0a					endif 
4f0a cd 48 20				call forth_push_numhl 
4f0d			 
4f0d				       NEXTW 
4f0d c3 38 24			jp macro_next 
4f10				endm 
# End of macro NEXTW
4f10			 
4f10			.CHR: 
4f10				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4f10 4d				db WORD_SYS_CORE+57             
4f11 4c 4f			dw .ENDSTR            
4f13 04				db 3 + 1 
4f14 .. 00			db "CHR",0              
4f18				endm 
# End of macro CWHEAD
4f18			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4f18					if DEBUG_FORTH_WORDS_KEY 
4f18						DMARK "CHR" 
4f18 f5				push af  
4f19 3a 2d 4f			ld a, (.dmark)  
4f1c 32 a0 fd			ld (debug_mark),a  
4f1f 3a 2e 4f			ld a, (.dmark+1)  
4f22 32 a1 fd			ld (debug_mark+1),a  
4f25 3a 2f 4f			ld a, (.dmark+2)  
4f28 32 a2 fd			ld (debug_mark+2),a  
4f2b 18 03			jr .pastdmark  
4f2d ..			.dmark: db "CHR"  
4f30 f1			.pastdmark: pop af  
4f31			endm  
# End of macro DMARK
4f31						CALLMONITOR 
4f31 cd aa fd			call debug_vector  
4f34				endm  
# End of macro CALLMONITOR
4f34					endif 
4f34					FORTH_DSP_VALUEHL 
4f34 cd 4d 22			call macro_dsp_valuehl 
4f37				endm 
# End of macro FORTH_DSP_VALUEHL
4f37			 
4f37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f37 cd 05 23			call macro_forth_dsp_pop 
4f3a				endm 
# End of macro FORTH_DSP_POP
4f3a			 
4f3a					; save asci byte as a zero term string and push string 
4f3a			 
4f3a 7d					ld a,l 
4f3b 32 f6 f0				ld (scratch), a 
4f3e			 
4f3e 3e 00				ld a, 0 
4f40 32 f7 f0				ld (scratch+1), a 
4f43			 
4f43 21 f6 f0				ld hl, scratch 
4f46 cd b6 20				call forth_push_str 
4f49			 
4f49			 
4f49				       NEXTW 
4f49 c3 38 24			jp macro_next 
4f4c				endm 
# End of macro NEXTW
4f4c			 
4f4c			 
4f4c			 
4f4c			 
4f4c			.ENDSTR: 
4f4c			; eof 
4f4c			 
# End of file forth_words_str.asm
4f4c			include "forth_words_key.asm" 
4f4c			 
4f4c			; | ## Keyboard Words 
4f4c			 
4f4c			.KEY: 
4f4c				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
4f4c 3e				db WORD_SYS_CORE+42             
4f4d 7c 4f			dw .KEYDB            
4f4f 04				db 3 + 1 
4f50 .. 00			db "KEY",0              
4f54				endm 
# End of macro CWHEAD
4f54			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4f54			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4f54			; | | Can use something like this to process: 
4f54			; | | > repeat active . key ?dup if emit then #1 until  
4f54			 
4f54					if DEBUG_FORTH_WORDS_KEY 
4f54						DMARK "KEY" 
4f54 f5				push af  
4f55 3a 69 4f			ld a, (.dmark)  
4f58 32 a0 fd			ld (debug_mark),a  
4f5b 3a 6a 4f			ld a, (.dmark+1)  
4f5e 32 a1 fd			ld (debug_mark+1),a  
4f61 3a 6b 4f			ld a, (.dmark+2)  
4f64 32 a2 fd			ld (debug_mark+2),a  
4f67 18 03			jr .pastdmark  
4f69 ..			.dmark: db "KEY"  
4f6c f1			.pastdmark: pop af  
4f6d			endm  
# End of macro DMARK
4f6d						CALLMONITOR 
4f6d cd aa fd			call debug_vector  
4f70				endm  
# End of macro CALLMONITOR
4f70					endif 
4f70			; TODO currently waits 
4f70 cd 6a 76				call cinndb 
4f73					;call cin_wait 
4f73 6f					ld l, a 
4f74 26 00				ld h, 0 
4f76 cd 48 20				call forth_push_numhl 
4f79					NEXTW 
4f79 c3 38 24			jp macro_next 
4f7c				endm 
# End of macro NEXTW
4f7c			.KEYDB: 
4f7c				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
4f7c 3e				db WORD_SYS_CORE+42             
4f7d ae 4f			dw .WAITK            
4f7f 06				db 5 + 1 
4f80 .. 00			db "KEYDB",0              
4f86				endm 
# End of macro CWHEAD
4f86			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
4f86			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4f86			; | | Can use something like this to process: 
4f86			; | | > repeat active . key ?dup if emit then #1 until  
4f86			 
4f86					if DEBUG_FORTH_WORDS_KEY 
4f86						DMARK "KEB" 
4f86 f5				push af  
4f87 3a 9b 4f			ld a, (.dmark)  
4f8a 32 a0 fd			ld (debug_mark),a  
4f8d 3a 9c 4f			ld a, (.dmark+1)  
4f90 32 a1 fd			ld (debug_mark+1),a  
4f93 3a 9d 4f			ld a, (.dmark+2)  
4f96 32 a2 fd			ld (debug_mark+2),a  
4f99 18 03			jr .pastdmark  
4f9b ..			.dmark: db "KEB"  
4f9e f1			.pastdmark: pop af  
4f9f			endm  
# End of macro DMARK
4f9f						CALLMONITOR 
4f9f cd aa fd			call debug_vector  
4fa2				endm  
# End of macro CALLMONITOR
4fa2					endif 
4fa2			; TODO currently waits 
4fa2 cd 56 76				call cin 
4fa5					;call cin_wait 
4fa5 6f					ld l, a 
4fa6 26 00				ld h, 0 
4fa8 cd 48 20				call forth_push_numhl 
4fab					NEXTW 
4fab c3 38 24			jp macro_next 
4fae				endm 
# End of macro NEXTW
4fae			.WAITK: 
4fae				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4fae 3f				db WORD_SYS_CORE+43             
4faf e0 4f			dw .ACCEPT            
4fb1 06				db 5 + 1 
4fb2 .. 00			db "WAITK",0              
4fb8				endm 
# End of macro CWHEAD
4fb8			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4fb8					if DEBUG_FORTH_WORDS_KEY 
4fb8						DMARK "WAI" 
4fb8 f5				push af  
4fb9 3a cd 4f			ld a, (.dmark)  
4fbc 32 a0 fd			ld (debug_mark),a  
4fbf 3a ce 4f			ld a, (.dmark+1)  
4fc2 32 a1 fd			ld (debug_mark+1),a  
4fc5 3a cf 4f			ld a, (.dmark+2)  
4fc8 32 a2 fd			ld (debug_mark+2),a  
4fcb 18 03			jr .pastdmark  
4fcd ..			.dmark: db "WAI"  
4fd0 f1			.pastdmark: pop af  
4fd1			endm  
# End of macro DMARK
4fd1						CALLMONITOR 
4fd1 cd aa fd			call debug_vector  
4fd4				endm  
# End of macro CALLMONITOR
4fd4					endif 
4fd4 cd 45 76				call cin_wait 
4fd7 6f					ld l, a 
4fd8 26 00				ld h, 0 
4fda cd 48 20				call forth_push_numhl 
4fdd					NEXTW 
4fdd c3 38 24			jp macro_next 
4fe0				endm 
# End of macro NEXTW
4fe0			.ACCEPT: 
4fe0				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4fe0 40				db WORD_SYS_CORE+44             
4fe1 3e 50			dw .EDIT            
4fe3 07				db 6 + 1 
4fe4 .. 00			db "ACCEPT",0              
4feb				endm 
# End of macro CWHEAD
4feb			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4feb					; TODO crashes on push 
4feb					if DEBUG_FORTH_WORDS_KEY 
4feb						DMARK "ACC" 
4feb f5				push af  
4fec 3a 00 50			ld a, (.dmark)  
4fef 32 a0 fd			ld (debug_mark),a  
4ff2 3a 01 50			ld a, (.dmark+1)  
4ff5 32 a1 fd			ld (debug_mark+1),a  
4ff8 3a 02 50			ld a, (.dmark+2)  
4ffb 32 a2 fd			ld (debug_mark+2),a  
4ffe 18 03			jr .pastdmark  
5000 ..			.dmark: db "ACC"  
5003 f1			.pastdmark: pop af  
5004			endm  
# End of macro DMARK
5004						CALLMONITOR 
5004 cd aa fd			call debug_vector  
5007				endm  
# End of macro CALLMONITOR
5007					endif 
5007 21 f4 f2				ld hl, os_input 
500a 3e 00				ld a, 0 
500c 77					ld (hl),a 
500d 3a 93 f9				ld a,(f_cursor_ptr) 
5010 16 64				ld d, 100 
5012 0e 00				ld c, 0 
5014 1e 28				ld e, 40 
5016 cd 0b 10				call input_str 
5019					; TODO perhaps do a type check and wrap in quotes if not a number 
5019 21 f4 f2				ld hl, os_input 
501c					if DEBUG_FORTH_WORDS 
501c						DMARK "AC1" 
501c f5				push af  
501d 3a 31 50			ld a, (.dmark)  
5020 32 a0 fd			ld (debug_mark),a  
5023 3a 32 50			ld a, (.dmark+1)  
5026 32 a1 fd			ld (debug_mark+1),a  
5029 3a 33 50			ld a, (.dmark+2)  
502c 32 a2 fd			ld (debug_mark+2),a  
502f 18 03			jr .pastdmark  
5031 ..			.dmark: db "AC1"  
5034 f1			.pastdmark: pop af  
5035			endm  
# End of macro DMARK
5035						CALLMONITOR 
5035 cd aa fd			call debug_vector  
5038				endm  
# End of macro CALLMONITOR
5038					endif 
5038 cd b6 20				call forth_push_str 
503b					NEXTW 
503b c3 38 24			jp macro_next 
503e				endm 
# End of macro NEXTW
503e			 
503e			.EDIT: 
503e				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
503e 40				db WORD_SYS_CORE+44             
503f e0 50			dw .DEDIT            
5041 05				db 4 + 1 
5042 .. 00			db "EDIT",0              
5047				endm 
# End of macro CWHEAD
5047			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
5047			 
5047					; TODO does not copy from stack 
5047					if DEBUG_FORTH_WORDS_KEY 
5047						DMARK "EDT" 
5047 f5				push af  
5048 3a 5c 50			ld a, (.dmark)  
504b 32 a0 fd			ld (debug_mark),a  
504e 3a 5d 50			ld a, (.dmark+1)  
5051 32 a1 fd			ld (debug_mark+1),a  
5054 3a 5e 50			ld a, (.dmark+2)  
5057 32 a2 fd			ld (debug_mark+2),a  
505a 18 03			jr .pastdmark  
505c ..			.dmark: db "EDT"  
505f f1			.pastdmark: pop af  
5060			endm  
# End of macro DMARK
5060						CALLMONITOR 
5060 cd aa fd			call debug_vector  
5063				endm  
# End of macro CALLMONITOR
5063					endif 
5063			 
5063					;FORTH_DSP 
5063					FORTH_DSP_VALUEHL 
5063 cd 4d 22			call macro_dsp_valuehl 
5066				endm 
# End of macro FORTH_DSP_VALUEHL
5066			;		inc hl    ; TODO do type check 
5066			 
5066			;		call get_word_hl 
5066 e5					push hl 
5067					if DEBUG_FORTH_WORDS 
5067						DMARK "EDp" 
5067 f5				push af  
5068 3a 7c 50			ld a, (.dmark)  
506b 32 a0 fd			ld (debug_mark),a  
506e 3a 7d 50			ld a, (.dmark+1)  
5071 32 a1 fd			ld (debug_mark+1),a  
5074 3a 7e 50			ld a, (.dmark+2)  
5077 32 a2 fd			ld (debug_mark+2),a  
507a 18 03			jr .pastdmark  
507c ..			.dmark: db "EDp"  
507f f1			.pastdmark: pop af  
5080			endm  
# End of macro DMARK
5080						CALLMONITOR 
5080 cd aa fd			call debug_vector  
5083				endm  
# End of macro CALLMONITOR
5083					endif 
5083				;	ld a, 0 
5083 cd 44 13				call strlenz 
5086 23					inc hl 
5087			 
5087 06 00				ld b, 0 
5089 4d					ld c, l 
508a			 
508a e1					pop hl 
508b 11 f4 f2				ld de, os_input 
508e					if DEBUG_FORTH_WORDS_KEY 
508e						DMARK "EDc" 
508e f5				push af  
508f 3a a3 50			ld a, (.dmark)  
5092 32 a0 fd			ld (debug_mark),a  
5095 3a a4 50			ld a, (.dmark+1)  
5098 32 a1 fd			ld (debug_mark+1),a  
509b 3a a5 50			ld a, (.dmark+2)  
509e 32 a2 fd			ld (debug_mark+2),a  
50a1 18 03			jr .pastdmark  
50a3 ..			.dmark: db "EDc"  
50a6 f1			.pastdmark: pop af  
50a7			endm  
# End of macro DMARK
50a7						CALLMONITOR 
50a7 cd aa fd			call debug_vector  
50aa				endm  
# End of macro CALLMONITOR
50aa					endif 
50aa ed b0				ldir 
50ac			 
50ac			 
50ac 21 f4 f2				ld hl, os_input 
50af					;ld a, 0 
50af					;ld (hl),a 
50af 3a 93 f9				ld a,(f_cursor_ptr) 
50b2 16 64				ld d, 100 
50b4 0e 00				ld c, 0 
50b6 1e 28				ld e, 40 
50b8 cd 0b 10				call input_str 
50bb					; TODO perhaps do a type check and wrap in quotes if not a number 
50bb 21 f4 f2				ld hl, os_input 
50be					if DEBUG_FORTH_WORDS 
50be						DMARK "ED1" 
50be f5				push af  
50bf 3a d3 50			ld a, (.dmark)  
50c2 32 a0 fd			ld (debug_mark),a  
50c5 3a d4 50			ld a, (.dmark+1)  
50c8 32 a1 fd			ld (debug_mark+1),a  
50cb 3a d5 50			ld a, (.dmark+2)  
50ce 32 a2 fd			ld (debug_mark+2),a  
50d1 18 03			jr .pastdmark  
50d3 ..			.dmark: db "ED1"  
50d6 f1			.pastdmark: pop af  
50d7			endm  
# End of macro DMARK
50d7						CALLMONITOR 
50d7 cd aa fd			call debug_vector  
50da				endm  
# End of macro CALLMONITOR
50da					endif 
50da cd b6 20				call forth_push_str 
50dd					NEXTW 
50dd c3 38 24			jp macro_next 
50e0				endm 
# End of macro NEXTW
50e0			 
50e0			.DEDIT: 
50e0				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
50e0 40				db WORD_SYS_CORE+44             
50e1 42 51			dw .ENDKEY            
50e3 06				db 5 + 1 
50e4 .. 00			db "DEDIT",0              
50ea				endm 
# End of macro CWHEAD
50ea			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
50ea			 
50ea					; TODO does not copy from stack 
50ea					if DEBUG_FORTH_WORDS_KEY 
50ea						DMARK "DED" 
50ea f5				push af  
50eb 3a ff 50			ld a, (.dmark)  
50ee 32 a0 fd			ld (debug_mark),a  
50f1 3a 00 51			ld a, (.dmark+1)  
50f4 32 a1 fd			ld (debug_mark+1),a  
50f7 3a 01 51			ld a, (.dmark+2)  
50fa 32 a2 fd			ld (debug_mark+2),a  
50fd 18 03			jr .pastdmark  
50ff ..			.dmark: db "DED"  
5102 f1			.pastdmark: pop af  
5103			endm  
# End of macro DMARK
5103						CALLMONITOR 
5103 cd aa fd			call debug_vector  
5106				endm  
# End of macro CALLMONITOR
5106					endif 
5106			 
5106					;FORTH_DSP 
5106					FORTH_DSP_VALUEHL 
5106 cd 4d 22			call macro_dsp_valuehl 
5109				endm 
# End of macro FORTH_DSP_VALUEHL
5109			;		inc hl    ; TODO do type check 
5109			 
5109			;		call get_word_hl 
5109 e5					push hl 
510a e5					push hl 
510b					FORTH_DSP_POP 
510b cd 05 23			call macro_forth_dsp_pop 
510e				endm 
# End of macro FORTH_DSP_POP
510e e1					pop hl 
510f					if DEBUG_FORTH_WORDS 
510f						DMARK "EDp" 
510f f5				push af  
5110 3a 24 51			ld a, (.dmark)  
5113 32 a0 fd			ld (debug_mark),a  
5116 3a 25 51			ld a, (.dmark+1)  
5119 32 a1 fd			ld (debug_mark+1),a  
511c 3a 26 51			ld a, (.dmark+2)  
511f 32 a2 fd			ld (debug_mark+2),a  
5122 18 03			jr .pastdmark  
5124 ..			.dmark: db "EDp"  
5127 f1			.pastdmark: pop af  
5128			endm  
# End of macro DMARK
5128						CALLMONITOR 
5128 cd aa fd			call debug_vector  
512b				endm  
# End of macro CALLMONITOR
512b					endif 
512b				;	ld a, 0 
512b cd 44 13				call strlenz 
512e 23					inc hl 
512f			 
512f 06 00				ld b, 0 
5131 4d					ld c, l 
5132			 
5132 e1					pop hl 
5133			 
5133					;ld a, 0 
5133					;ld (hl),a 
5133 3a 93 f9				ld a,(f_cursor_ptr) 
5136 16 64				ld d, 100 
5138 0e 00				ld c, 0 
513a 1e 28				ld e, 40 
513c cd 0b 10				call input_str 
513f					; TODO perhaps do a type check and wrap in quotes if not a number 
513f					NEXTW 
513f c3 38 24			jp macro_next 
5142				endm 
# End of macro NEXTW
5142			 
5142			 
5142			.ENDKEY: 
5142			; eof 
5142			 
# End of file forth_words_key.asm
5142			include "forth_words_const.asm" 
5142			 
5142			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
5142			 
5142			 
5142			.SPITIME: 
5142				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
5142 77				db WORD_SYS_CORE+99             
5143 57 51			dw .VA            
5145 08				db 7 + 1 
5146 .. 00			db "SPITIME",0              
514e				endm 
# End of macro CWHEAD
514e			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
514e			; 
514e			; | | If using BANK devices then leave as is. 
514e			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
514e			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
514e			 
514e 21 99 f9				ld hl, spi_clktime  
5151 cd 48 20				call forth_push_numhl 
5154			 
5154					NEXTW 
5154 c3 38 24			jp macro_next 
5157				endm 
# End of macro NEXTW
5157			 
5157			 
5157			.VA: 
5157				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
5157 77				db WORD_SYS_CORE+99             
5158 67 51			dw .SYMBOL            
515a 03				db 2 + 1 
515b .. 00			db "VA",0              
515e				endm 
# End of macro CWHEAD
515e			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
515e 21 5d f9				ld hl, cli_var_array 
5161 cd 48 20				call forth_push_numhl 
5164			 
5164					NEXTW 
5164 c3 38 24			jp macro_next 
5167				endm 
# End of macro NEXTW
5167			 
5167			.SYMBOL: 
5167				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
5167 77				db WORD_SYS_CORE+99             
5168 71 52			dw .ENDCONST            
516a 07				db 6 + 1 
516b .. 00			db "SYMBOL",0              
5172				endm 
# End of macro CWHEAD
5172			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
5172			; | 
5172			; | | The value is the number reference and the final address is pushed to stack 
5172			 
5172			; | | ``` 
5172			; | | dw sym_table 
5172			; | | dw nmi_vector 
5172			; | | dw cli_autodisplay 
5172			; | | dw cli_data_sp 
5172			; | | dw cli_data_stack 
5172			; | | dw cli_loop_sp 
5172			; | | dw cli_loop_stack 
5172			; | | dw cli_var_array 
5172			; | | dw cursor_col 
5172			; | | dw cursor_ptr 
5172			; | | ; 10 
5172			; | | dw cursor_row 
5172			; | | dw debug_mark 
5172			; | | dw display_fb0 
5172			; | | dw display_fb1 
5172			; | | dw display_fb2 
5172			; | | dw display_fb3 
5172			; | | dw display_fb_active 
5172			; | | dw execscratch 
5172			; | | dw f_cursor_ptr 
5172			; | | dw hardware_word 
5172			; | | ;20 
5172			; | | dw input_at_cursor 
5172			; | | dw input_at_pos 
5172			; | | dw input_cur_flash 
5172			; | | dw input_cur_onoff 
5172			; | | dw input_cursor 
5172			; | | dw input_display_size 
5172			; | | dw input_len 
5172			; | | dw input_ptr 
5172			; | | dw input_size 
5172			; | | dw input_start 
5172			; | | ; 30 
5172			; | | dw input_str 
5172			; | | dw input_under_cursor 
5172			; | | dw os_cli_cmd 
5172			; | | dw os_cur_ptr 
5172			; | | dw os_current_i 
5172			; | | dw os_input 
5172			; | | dw os_last_cmd 
5172			; | | dw os_last_new_uword 
5172			; | | dw debug_vector 
5172			; | | dw os_view_hl 
5172			; | | ;40 
5172			; | | dw os_word_scratch 
5172			; | | dw portbctl 
5172			; | | dw portbdata 
5172			; | | dw spi_cartdev 
5172			; | | dw spi_cartdev2 
5172			; | | dw spi_clktime 
5172			; | | dw spi_device 
5172			; | | dw spi_device_id 
5172			; | | dw spi_portbyte 
5172			; | | dw stackstore 
5172			; | | ; 50 
5172			; | | if STORAGE_SE 
5172			; | | dw storage_actl 
5172			; | | dw storage_adata 
5172			; | | else 
5172			; | | dw 0 
5172			; | | dw 0 
5172			; | | endif 
5172			; | | dw storage_append 
5172			; | | if STORAGE_SE 
5172			; | | dw storage_bctl 
5172			; | | else 
5172			; | | dw 0 
5172			; | | endif 
5172			; | | dw store_bank_active 
5172			; | | dw store_filecache 
5172			; | | dw store_longread 
5172			; | | dw store_openaddr 
5172			; | | dw store_openext 
5172			; | | dw store_openmaxext 
5172			; | | ; 60 
5172			; | | dw store_page 
5172			; | | dw store_readbuf 
5172			; | | dw store_readcont 
5172			; | | dw store_readptr 
5172			; | | dw store_tmpext 
5172			; | | dw store_tmpid 
5172			; | | dw store_tmppageid 
5172			; | | dw malloc 
5172			; | | dw free 
5172			; | | dw cin 
5172			; | | ; 70 
5172			; | | dw cin_wait 
5172			; | | dw forth_push_numhl 
5172			; | | dw forth_push_str 
5172			; | | ``` 
5172			 
5172					if DEBUG_FORTH_WORDS_KEY 
5172						DMARK "SYM" 
5172 f5				push af  
5173 3a 87 51			ld a, (.dmark)  
5176 32 a0 fd			ld (debug_mark),a  
5179 3a 88 51			ld a, (.dmark+1)  
517c 32 a1 fd			ld (debug_mark+1),a  
517f 3a 89 51			ld a, (.dmark+2)  
5182 32 a2 fd			ld (debug_mark+2),a  
5185 18 03			jr .pastdmark  
5187 ..			.dmark: db "SYM"  
518a f1			.pastdmark: pop af  
518b			endm  
# End of macro DMARK
518b						CALLMONITOR 
518b cd aa fd			call debug_vector  
518e				endm  
# End of macro CALLMONITOR
518e					endif 
518e			 
518e					FORTH_DSP_VALUEHL 
518e cd 4d 22			call macro_dsp_valuehl 
5191				endm 
# End of macro FORTH_DSP_VALUEHL
5191			 
5191 7d					ld a, l     
5192			 
5192			 
5192					if DEBUG_FORTH_WORDS 
5192						DMARK "SY1" 
5192 f5				push af  
5193 3a a7 51			ld a, (.dmark)  
5196 32 a0 fd			ld (debug_mark),a  
5199 3a a8 51			ld a, (.dmark+1)  
519c 32 a1 fd			ld (debug_mark+1),a  
519f 3a a9 51			ld a, (.dmark+2)  
51a2 32 a2 fd			ld (debug_mark+2),a  
51a5 18 03			jr .pastdmark  
51a7 ..			.dmark: db "SY1"  
51aa f1			.pastdmark: pop af  
51ab			endm  
# End of macro DMARK
51ab						CALLMONITOR 
51ab cd aa fd			call debug_vector  
51ae				endm  
# End of macro CALLMONITOR
51ae					endif 
51ae					 
51ae f5					push af	 
51af					FORTH_DSP_POP 
51af cd 05 23			call macro_forth_dsp_pop 
51b2				endm 
# End of macro FORTH_DSP_POP
51b2 f1					pop af 
51b3			 
51b3 cb 27				sla a  
51b5				 
51b5					 
51b5					if DEBUG_FORTH_WORDS 
51b5						DMARK "SY" 
51b5 f5				push af  
51b6 3a ca 51			ld a, (.dmark)  
51b9 32 a0 fd			ld (debug_mark),a  
51bc 3a cb 51			ld a, (.dmark+1)  
51bf 32 a1 fd			ld (debug_mark+1),a  
51c2 3a cc 51			ld a, (.dmark+2)  
51c5 32 a2 fd			ld (debug_mark+2),a  
51c8 18 02			jr .pastdmark  
51ca ..			.dmark: db "SY"  
51cc f1			.pastdmark: pop af  
51cd			endm  
# End of macro DMARK
51cd						CALLMONITOR 
51cd cd aa fd			call debug_vector  
51d0				endm  
# End of macro CALLMONITOR
51d0					endif 
51d0			 
51d0 21 df 51				ld hl, sym_table 
51d3 cd de 0f				call addatohl 
51d6 cd ba 23				call loadwordinhl 
51d9 cd 48 20				call forth_push_numhl 
51dc			 
51dc			 
51dc				       NEXTW 
51dc c3 38 24			jp macro_next 
51df				endm 
# End of macro NEXTW
51df			 
51df			sym_table: 
51df			 
51df			; 0 
51df df 51		dw sym_table 
51e1 ad fd		dw nmi_vector 
51e3 71 f9		dw cli_autodisplay 
51e5 23 f9		dw cli_data_sp 
51e7 5d f6		dw cli_data_stack 
51e9 25 f9		dw cli_loop_sp 
51eb 5f f8		dw cli_loop_stack 
51ed 5d f9		dw cli_var_array 
51ef fa fa		dw cursor_col 
51f1 f8 fa		dw cursor_ptr 
51f3			; 10 
51f3 f9 fa		dw cursor_row 
51f5 a0 fd		dw debug_mark 
51f7 e6 fc		dw display_fb0 
51f9 45 fc		dw display_fb1 
51fb 03 fb		dw display_fb2 
51fd a4 fb		dw display_fb3 
51ff 01 fb		dw display_fb_active 
5201 f5 f1		dw execscratch 
5203 93 f9		dw f_cursor_ptr 
5205 b0 fd		dw hardware_word 
5207			;20 
5207 97 fd		dw input_at_cursor 
5209 99 fd		dw input_at_pos 
520b 95 fd		dw input_cur_flash 
520d 94 fd		dw input_cur_onoff 
520f 8a fd		dw input_cursor 
5211 9a fd		dw input_display_size 
5213 8f fd		dw input_len 
5215 9e fd		dw input_ptr 
5217 9b fd		dw input_size 
5219 9c fd		dw input_start 
521b			; 30 
521b 0b 10		dw input_str 
521d 98 fd		dw input_under_cursor 
521f 1d f4		dw os_cli_cmd 
5221 19 f4		dw os_cur_ptr 
5223 1b f4		dw os_current_i 
5225 f4 f2		dw os_input 
5227 1c f5		dw os_last_cmd 
5229 f3 f3		dw os_last_new_uword 
522b aa fd		dw debug_vector 
522d d8 f0		dw os_view_hl 
522f			;40 
522f fb f3		dw os_word_scratch 
5231 c3 00		dw portbctl 
5233 c1 00		dw portbdata 
5235 98 f9		dw spi_cartdev 
5237 97 f9		dw spi_cartdev2 
5239 99 f9		dw spi_clktime 
523b 95 f9		dw spi_device 
523d 94 f9		dw spi_device_id 
523f 96 f9		dw spi_portbyte 
5241 dc fa		dw stackstore 
5243			; 50 
5243			if STORAGE_SE 
5243 82 00		dw storage_actl 
5245 80 00		dw storage_adata 
5247			else 
5247			dw 0 
5247			dw 0 
5247			endif 
5247 64 0b		dw storage_append 
5249			if STORAGE_SE 
5249 83 00		dw storage_bctl 
524b			else 
524b			dw 0 
524b			endif 
524b c8 fa		dw store_bank_active 
524d 9c f9		dw store_filecache 
524f aa f9		dw store_longread 
5251 a0 f9		dw store_openaddr 
5253 9f f9		dw store_openext 
5255 9e f9		dw store_openmaxext 
5257			; 60 
5257 af f9		dw store_page 
5259 ab f9		dw store_readbuf 
525b a2 f9		dw store_readcont 
525d ad f9		dw store_readptr 
525f a2 f9		dw store_tmpext 
5261 a3 f9		dw store_tmpid 
5263 9a f9		dw store_tmppageid 
5265 b9 13		dw malloc 
5267 83 14		dw free 
5269 56 76		dw cin 
526b			; 70 
526b 45 76		dw cin_wait 
526d 48 20		dw forth_push_numhl 
526f b6 20		dw forth_push_str 
5271			 
5271			 
5271			.ENDCONST: 
5271			 
5271			; eof 
5271			 
5271			 
# End of file forth_words_const.asm
5271			 
5271			if STORAGE_SE 
5271			   	include "forth_words_storage.asm" 
5271			 
5271			; | ## Fixed Storage Words 
5271			 
5271			.RENAME: 
5271			  
5271				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
5271 3a				db WORD_SYS_CORE+38             
5272 67 53			dw .RECORD            
5274 07				db 6 + 1 
5275 .. 00			db "RENAME",0              
527c				endm 
# End of macro CWHEAD
527c			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
527c			; | | > [!NOTE] 
527c			; | | > Compatible with PicoSPINet  
527c					if DEBUG_FORTH_WORDS_KEY 
527c						DMARK "REN" 
527c f5				push af  
527d 3a 91 52			ld a, (.dmark)  
5280 32 a0 fd			ld (debug_mark),a  
5283 3a 92 52			ld a, (.dmark+1)  
5286 32 a1 fd			ld (debug_mark+1),a  
5289 3a 93 52			ld a, (.dmark+2)  
528c 32 a2 fd			ld (debug_mark+2),a  
528f 18 03			jr .pastdmark  
5291 ..			.dmark: db "REN"  
5294 f1			.pastdmark: pop af  
5295			endm  
# End of macro DMARK
5295						CALLMONITOR 
5295 cd aa fd			call debug_vector  
5298				endm  
# End of macro CALLMONITOR
5298					endif 
5298			 
5298			 
5298					; preserve some internal vars used by other file handing routines 
5298			 
5298 2a a0 f9				ld hl, (store_openaddr) 
529b e5					push hl 
529c 3a a2 f9				ld a, (store_readcont) 
529f f5					push af 
52a0			 
52a0					FORTH_DSP_VALUEHL 
52a0 cd 4d 22			call macro_dsp_valuehl 
52a3				endm 
# End of macro FORTH_DSP_VALUEHL
52a3			 
52a3					; move ext and id around for the file header 
52a3			 
52a3 65					ld h, l 
52a4 2e 00				ld l, 0 
52a6			 
52a6 e5					push hl    ; id 
52a7			 
52a7					FORTH_DSP_POP 
52a7 cd 05 23			call macro_forth_dsp_pop 
52aa				endm 
# End of macro FORTH_DSP_POP
52aa			 
52aa					; Locate the file header 
52aa			 
52aa e1					pop hl 
52ab e5					push hl 
52ac 11 af f9				ld de, store_page      ; get block zero of file 
52af					if DEBUG_FORTH_WORDS 
52af						DMARK "REr" 
52af f5				push af  
52b0 3a c4 52			ld a, (.dmark)  
52b3 32 a0 fd			ld (debug_mark),a  
52b6 3a c5 52			ld a, (.dmark+1)  
52b9 32 a1 fd			ld (debug_mark+1),a  
52bc 3a c6 52			ld a, (.dmark+2)  
52bf 32 a2 fd			ld (debug_mark+2),a  
52c2 18 03			jr .pastdmark  
52c4 ..			.dmark: db "REr"  
52c7 f1			.pastdmark: pop af  
52c8			endm  
# End of macro DMARK
52c8						CALLMONITOR 
52c8 cd aa fd			call debug_vector  
52cb				endm  
# End of macro CALLMONITOR
52cb					endif 
52cb cd cd 09				call storage_read 
52ce			 
52ce cd 07 10			call ishlzero 
52d1 20 05			jr nz, .rnfound 
52d3			 
52d3				; file does not exist so indicate with 255 extents in use 
52d3			 
52d3 3e ff			ld a, 255 
52d5 e1				pop hl ; clear dup hl 
52d6 18 7b			jr .skiprneof 
52d8			 
52d8			 
52d8			.rnfound: 
52d8					; file found so rename 
52d8			 
52d8					FORTH_DSP_VALUEHL 
52d8 cd 4d 22			call macro_dsp_valuehl 
52db				endm 
# End of macro FORTH_DSP_VALUEHL
52db			 
52db e5				push hl 
52dc 3e 00			ld a, 0 
52de cd 4f 13			call strlent 
52e1 23				inc hl   ; cover zero term 
52e2 06 00			ld b,0 
52e4 4d				ld c,l 
52e5 e1				pop hl 
52e6 11 b2 f9				ld de, store_page + 3 
52e9 ed b0				ldir 
52eb			 
52eb 11 af f9				ld de, store_page 
52ee					if DEBUG_FORTH_WORDS 
52ee						DMARK "RER" 
52ee f5				push af  
52ef 3a 03 53			ld a, (.dmark)  
52f2 32 a0 fd			ld (debug_mark),a  
52f5 3a 04 53			ld a, (.dmark+1)  
52f8 32 a1 fd			ld (debug_mark+1),a  
52fb 3a 05 53			ld a, (.dmark+2)  
52fe 32 a2 fd			ld (debug_mark+2),a  
5301 18 03			jr .pastdmark  
5303 ..			.dmark: db "RER"  
5306 f1			.pastdmark: pop af  
5307			endm  
# End of macro DMARK
5307						CALLMONITOR 
5307 cd aa fd			call debug_vector  
530a				endm  
# End of macro CALLMONITOR
530a					endif 
530a			 
530a e1					pop hl    ; get orig file id and mangle it for find id 
530b 55					ld d, l 
530c 5c					ld e, h 
530d			 
530d 21 00 00				ld hl, 0 
5310					if DEBUG_FORTH_WORDS 
5310						DMARK "REf" 
5310 f5				push af  
5311 3a 25 53			ld a, (.dmark)  
5314 32 a0 fd			ld (debug_mark),a  
5317 3a 26 53			ld a, (.dmark+1)  
531a 32 a1 fd			ld (debug_mark+1),a  
531d 3a 27 53			ld a, (.dmark+2)  
5320 32 a2 fd			ld (debug_mark+2),a  
5323 18 03			jr .pastdmark  
5325 ..			.dmark: db "REf"  
5328 f1			.pastdmark: pop af  
5329			endm  
# End of macro DMARK
5329						CALLMONITOR 
5329 cd aa fd			call debug_vector  
532c				endm  
# End of macro CALLMONITOR
532c					endif 
532c cd a7 07				call storage_findnextid 
532f 11 af f9				ld de, store_page 
5332					if DEBUG_FORTH_WORDS 
5332						DMARK "REw" 
5332 f5				push af  
5333 3a 47 53			ld a, (.dmark)  
5336 32 a0 fd			ld (debug_mark),a  
5339 3a 48 53			ld a, (.dmark+1)  
533c 32 a1 fd			ld (debug_mark+1),a  
533f 3a 49 53			ld a, (.dmark+2)  
5342 32 a2 fd			ld (debug_mark+2),a  
5345 18 03			jr .pastdmark  
5347 ..			.dmark: db "REw"  
534a f1			.pastdmark: pop af  
534b			endm  
# End of macro DMARK
534b						CALLMONITOR 
534b cd aa fd			call debug_vector  
534e				endm  
# End of macro CALLMONITOR
534e					endif 
534e cd d9 04				call storage_write_block 
5351			 
5351 3e 00				ld a, 0 
5353			.skiprneof: 
5353					; drop file name 
5353					FORTH_DSP_POP 
5353 cd 05 23			call macro_forth_dsp_pop 
5356				endm 
# End of macro FORTH_DSP_POP
5356			 
5356 6f					ld l, a 
5357 26 00				ld h, 0 
5359 cd 48 20				call forth_push_numhl 
535c			 
535c			 
535c f1					pop af 
535d 32 a2 f9				ld (store_readcont),a 
5360 e1					pop hl 
5361 22 a0 f9				ld (store_openaddr), hl 
5364						 
5364				NEXTW 
5364 c3 38 24			jp macro_next 
5367				endm 
# End of macro NEXTW
5367			.RECORD: 
5367			  
5367				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
5367 3a				db WORD_SYS_CORE+38             
5368 0b 54			dw .BREAD            
536a 07				db 6 + 1 
536b .. 00			db "RECORD",0              
5372				endm 
# End of macro CWHEAD
5372			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
5372			; | | > [!NOTE] 
5372			; | | > Compatible with PicoSPINet  
5372			 
5372					if DEBUG_FORTH_WORDS_KEY 
5372						DMARK "REC" 
5372 f5				push af  
5373 3a 87 53			ld a, (.dmark)  
5376 32 a0 fd			ld (debug_mark),a  
5379 3a 88 53			ld a, (.dmark+1)  
537c 32 a1 fd			ld (debug_mark+1),a  
537f 3a 89 53			ld a, (.dmark+2)  
5382 32 a2 fd			ld (debug_mark+2),a  
5385 18 03			jr .pastdmark  
5387 ..			.dmark: db "REC"  
538a f1			.pastdmark: pop af  
538b			endm  
# End of macro DMARK
538b						CALLMONITOR 
538b cd aa fd			call debug_vector  
538e				endm  
# End of macro CALLMONITOR
538e					endif 
538e			 
538e					FORTH_DSP_VALUEHL 
538e cd 4d 22			call macro_dsp_valuehl 
5391				endm 
# End of macro FORTH_DSP_VALUEHL
5391			 
5391 e5					push hl    ; id 
5392			 
5392					FORTH_DSP_POP 
5392 cd 05 23			call macro_forth_dsp_pop 
5395				endm 
# End of macro FORTH_DSP_POP
5395			 
5395					FORTH_DSP_VALUEHL 
5395 cd 4d 22			call macro_dsp_valuehl 
5398				endm 
# End of macro FORTH_DSP_VALUEHL
5398			 
5398					FORTH_DSP_POP 
5398 cd 05 23			call macro_forth_dsp_pop 
539b				endm 
# End of macro FORTH_DSP_POP
539b			 
539b d1					pop de     ; get file id 
539c			 
539c					; e = file id 
539c					; l = file extent 
539c			 
539c			 
539c					; construct request to access file extent 
539c			 
539c			;		ld a, e 
539c 63					ld h, e 
539d					 
539d					 
539d					 
539d			 
539d					; e has id 
539d			 
539d 11 af f9			ld de, store_page 
53a0					if DEBUG_FORTH_WORDS 
53a0						DMARK "REr" 
53a0 f5				push af  
53a1 3a b5 53			ld a, (.dmark)  
53a4 32 a0 fd			ld (debug_mark),a  
53a7 3a b6 53			ld a, (.dmark+1)  
53aa 32 a1 fd			ld (debug_mark+1),a  
53ad 3a b7 53			ld a, (.dmark+2)  
53b0 32 a2 fd			ld (debug_mark+2),a  
53b3 18 03			jr .pastdmark  
53b5 ..			.dmark: db "REr"  
53b8 f1			.pastdmark: pop af  
53b9			endm  
# End of macro DMARK
53b9						CALLMONITOR 
53b9 cd aa fd			call debug_vector  
53bc				endm  
# End of macro CALLMONITOR
53bc					endif 
53bc cd cd 09				call storage_read 
53bf cd 07 10			call ishlzero 
53c2 28 22			jr z, .recnotfound 
53c4			 
53c4			 
53c4					if DEBUG_FORTH_WORDS 
53c4						DMARK "REe" 
53c4 f5				push af  
53c5 3a d9 53			ld a, (.dmark)  
53c8 32 a0 fd			ld (debug_mark),a  
53cb 3a da 53			ld a, (.dmark+1)  
53ce 32 a1 fd			ld (debug_mark+1),a  
53d1 3a db 53			ld a, (.dmark+2)  
53d4 32 a2 fd			ld (debug_mark+2),a  
53d7 18 03			jr .pastdmark  
53d9 ..			.dmark: db "REe"  
53dc f1			.pastdmark: pop af  
53dd			endm  
# End of macro DMARK
53dd						CALLMONITOR 
53dd cd aa fd			call debug_vector  
53e0				endm  
# End of macro CALLMONITOR
53e0					endif 
53e0 cd b6 20			call forth_push_str 
53e3			 
53e3					NEXTW 
53e3 c3 38 24			jp macro_next 
53e6				endm 
# End of macro NEXTW
53e6			 
53e6			.recnotfound: 
53e6					if DEBUG_FORTH_WORDS 
53e6						DMARK "REf" 
53e6 f5				push af  
53e7 3a fb 53			ld a, (.dmark)  
53ea 32 a0 fd			ld (debug_mark),a  
53ed 3a fc 53			ld a, (.dmark+1)  
53f0 32 a1 fd			ld (debug_mark+1),a  
53f3 3a fd 53			ld a, (.dmark+2)  
53f6 32 a2 fd			ld (debug_mark+2),a  
53f9 18 03			jr .pastdmark  
53fb ..			.dmark: db "REf"  
53fe f1			.pastdmark: pop af  
53ff			endm  
# End of macro DMARK
53ff						CALLMONITOR 
53ff cd aa fd			call debug_vector  
5402				endm  
# End of macro CALLMONITOR
5402					endif 
5402 21 ff 00			ld hl, 255 
5405 cd 48 20			call forth_push_numhl 
5408				NEXTW 
5408 c3 38 24			jp macro_next 
540b				endm 
# End of macro NEXTW
540b			 
540b			 
540b			.BREAD: 
540b			  
540b				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
540b 3a				db WORD_SYS_CORE+38             
540c 8e 54			dw .BWRITE            
540e 06				db 5 + 1 
540f .. 00			db "BREAD",0              
5415				endm 
# End of macro CWHEAD
5415			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5415			; | | > [!NOTE] 
5415			; | | > Compatible with PicoSPINet  
5415				 
5415					if DEBUG_FORTH_WORDS_KEY 
5415						DMARK "BRD" 
5415 f5				push af  
5416 3a 2a 54			ld a, (.dmark)  
5419 32 a0 fd			ld (debug_mark),a  
541c 3a 2b 54			ld a, (.dmark+1)  
541f 32 a1 fd			ld (debug_mark+1),a  
5422 3a 2c 54			ld a, (.dmark+2)  
5425 32 a2 fd			ld (debug_mark+2),a  
5428 18 03			jr .pastdmark  
542a ..			.dmark: db "BRD"  
542d f1			.pastdmark: pop af  
542e			endm  
# End of macro DMARK
542e						CALLMONITOR 
542e cd aa fd			call debug_vector  
5431				endm  
# End of macro CALLMONITOR
5431					endif 
5431			 
5431				FORTH_DSP_VALUEHL 
5431 cd 4d 22			call macro_dsp_valuehl 
5434				endm 
# End of macro FORTH_DSP_VALUEHL
5434			 
5434				FORTH_DSP_POP 
5434 cd 05 23			call macro_forth_dsp_pop 
5437				endm 
# End of macro FORTH_DSP_POP
5437			 
5437				; calc block address 
5437			 
5437 eb				ex de, hl 
5438 3e 40			ld a, STORE_BLOCK_PHY 
543a cd 61 0f			call Mult16 
543d			 
543d			 
543d 11 af f9			ld de, store_page 
5440			 
5440					if DEBUG_FORTH_WORDS 
5440						DMARK "BR1" 
5440 f5				push af  
5441 3a 55 54			ld a, (.dmark)  
5444 32 a0 fd			ld (debug_mark),a  
5447 3a 56 54			ld a, (.dmark+1)  
544a 32 a1 fd			ld (debug_mark+1),a  
544d 3a 57 54			ld a, (.dmark+2)  
5450 32 a2 fd			ld (debug_mark+2),a  
5453 18 03			jr .pastdmark  
5455 ..			.dmark: db "BR1"  
5458 f1			.pastdmark: pop af  
5459			endm  
# End of macro DMARK
5459						CALLMONITOR 
5459 cd aa fd			call debug_vector  
545c				endm  
# End of macro CALLMONITOR
545c					endif 
545c			 
545c cd 74 04			call storage_read_block 
545f			 
545f cd 07 10			call ishlzero 
5462 20 05			jr nz, .brfound 
5464			 
5464 cd 48 20			call forth_push_numhl 
5467 18 22			jr .brdone 
5469			 
5469			 
5469			.brfound: 
5469 21 b1 f9		        ld hl, store_page+2 
546c			 
546c					if DEBUG_FORTH_WORDS 
546c						DMARK "BR2" 
546c f5				push af  
546d 3a 81 54			ld a, (.dmark)  
5470 32 a0 fd			ld (debug_mark),a  
5473 3a 82 54			ld a, (.dmark+1)  
5476 32 a1 fd			ld (debug_mark+1),a  
5479 3a 83 54			ld a, (.dmark+2)  
547c 32 a2 fd			ld (debug_mark+2),a  
547f 18 03			jr .pastdmark  
5481 ..			.dmark: db "BR2"  
5484 f1			.pastdmark: pop af  
5485			endm  
# End of macro DMARK
5485						CALLMONITOR 
5485 cd aa fd			call debug_vector  
5488				endm  
# End of macro CALLMONITOR
5488					endif 
5488			 
5488 cd b6 20			call forth_push_str 
548b			 
548b			 
548b			.brdone: 
548b			 
548b					NEXTW 
548b c3 38 24			jp macro_next 
548e				endm 
# End of macro NEXTW
548e			.BWRITE: 
548e				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
548e 3a				db WORD_SYS_CORE+38             
548f 23 55			dw .BUPD            
5491 07				db 6 + 1 
5492 .. 00			db "BWRITE",0              
5499				endm 
# End of macro CWHEAD
5499			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5499			; | | > [!NOTE] 
5499			; | | > Compatible with PicoSPINet  
5499			 
5499					if DEBUG_FORTH_WORDS_KEY 
5499						DMARK "BWR" 
5499 f5				push af  
549a 3a ae 54			ld a, (.dmark)  
549d 32 a0 fd			ld (debug_mark),a  
54a0 3a af 54			ld a, (.dmark+1)  
54a3 32 a1 fd			ld (debug_mark+1),a  
54a6 3a b0 54			ld a, (.dmark+2)  
54a9 32 a2 fd			ld (debug_mark+2),a  
54ac 18 03			jr .pastdmark  
54ae ..			.dmark: db "BWR"  
54b1 f1			.pastdmark: pop af  
54b2			endm  
# End of macro DMARK
54b2						CALLMONITOR 
54b2 cd aa fd			call debug_vector  
54b5				endm  
# End of macro CALLMONITOR
54b5					endif 
54b5			 
54b5				FORTH_DSP_VALUEHL 
54b5 cd 4d 22			call macro_dsp_valuehl 
54b8				endm 
# End of macro FORTH_DSP_VALUEHL
54b8			 
54b8				; calc block address 
54b8			 
54b8 eb				ex de, hl 
54b9 3e 40			ld a, STORE_BLOCK_PHY 
54bb cd 61 0f			call Mult16 
54be			 
54be e5				push hl         ; address 
54bf			 
54bf				FORTH_DSP_POP 
54bf cd 05 23			call macro_forth_dsp_pop 
54c2				endm 
# End of macro FORTH_DSP_POP
54c2			 
54c2				FORTH_DSP_VALUEHL 
54c2 cd 4d 22			call macro_dsp_valuehl 
54c5				endm 
# End of macro FORTH_DSP_VALUEHL
54c5			 
54c5				FORTH_DSP_POP 
54c5 cd 05 23			call macro_forth_dsp_pop 
54c8				endm 
# End of macro FORTH_DSP_POP
54c8			 
54c8 cd b0 0c			call storage_clear_page 
54cb			 
54cb				; copy string to store page 
54cb			 
54cb e5				push hl     ; save string address 
54cc			 
54cc 3e 00			ld a, 0 
54ce cd 4f 13			call strlent 
54d1			 
54d1 23				inc hl 
54d2			 
54d2 4d				ld c, l 
54d3 06 00			ld b, 0 
54d5			 
54d5 e1				pop hl 
54d6 11 b1 f9			ld de, store_page + 2 
54d9					if DEBUG_FORTH_WORDS 
54d9						DMARK "BW1" 
54d9 f5				push af  
54da 3a ee 54			ld a, (.dmark)  
54dd 32 a0 fd			ld (debug_mark),a  
54e0 3a ef 54			ld a, (.dmark+1)  
54e3 32 a1 fd			ld (debug_mark+1),a  
54e6 3a f0 54			ld a, (.dmark+2)  
54e9 32 a2 fd			ld (debug_mark+2),a  
54ec 18 03			jr .pastdmark  
54ee ..			.dmark: db "BW1"  
54f1 f1			.pastdmark: pop af  
54f2			endm  
# End of macro DMARK
54f2						CALLMONITOR 
54f2 cd aa fd			call debug_vector  
54f5				endm  
# End of macro CALLMONITOR
54f5					endif 
54f5 ed b0			ldir 
54f7			 
54f7			 
54f7				; poke the start of the block with flags to prevent high level file ops hitting the block 
54f7			 
54f7 21 ff ff			ld hl, $ffff 
54fa			 
54fa 22 af f9			ld (store_page), hl	 
54fd				 
54fd e1				pop hl    ; get address 
54fe 11 af f9			ld de, store_page 
5501			 
5501					if DEBUG_FORTH_WORDS 
5501						DMARK "BW2" 
5501 f5				push af  
5502 3a 16 55			ld a, (.dmark)  
5505 32 a0 fd			ld (debug_mark),a  
5508 3a 17 55			ld a, (.dmark+1)  
550b 32 a1 fd			ld (debug_mark+1),a  
550e 3a 18 55			ld a, (.dmark+2)  
5511 32 a2 fd			ld (debug_mark+2),a  
5514 18 03			jr .pastdmark  
5516 ..			.dmark: db "BW2"  
5519 f1			.pastdmark: pop af  
551a			endm  
# End of macro DMARK
551a						CALLMONITOR 
551a cd aa fd			call debug_vector  
551d				endm  
# End of macro CALLMONITOR
551d					endif 
551d			 
551d cd d9 04			call storage_write_block 
5520			 
5520					NEXTW 
5520 c3 38 24			jp macro_next 
5523				endm 
# End of macro NEXTW
5523			 
5523			.BUPD: 
5523				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
5523 3a				db WORD_SYS_CORE+38             
5524 79 55			dw .BYID            
5526 05				db 4 + 1 
5527 .. 00			db "BUPD",0              
552c				endm 
# End of macro CWHEAD
552c			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
552c			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
552c			; | | or completely different file system structure. 
552c			; | | > [!NOTE] 
552c			; | | > Compatible with PicoSPINet  
552c			 
552c					if DEBUG_FORTH_WORDS_KEY 
552c						DMARK "BUD" 
552c f5				push af  
552d 3a 41 55			ld a, (.dmark)  
5530 32 a0 fd			ld (debug_mark),a  
5533 3a 42 55			ld a, (.dmark+1)  
5536 32 a1 fd			ld (debug_mark+1),a  
5539 3a 43 55			ld a, (.dmark+2)  
553c 32 a2 fd			ld (debug_mark+2),a  
553f 18 03			jr .pastdmark  
5541 ..			.dmark: db "BUD"  
5544 f1			.pastdmark: pop af  
5545			endm  
# End of macro DMARK
5545						CALLMONITOR 
5545 cd aa fd			call debug_vector  
5548				endm  
# End of macro CALLMONITOR
5548					endif 
5548			 
5548				FORTH_DSP_VALUEHL 
5548 cd 4d 22			call macro_dsp_valuehl 
554b				endm 
# End of macro FORTH_DSP_VALUEHL
554b			 
554b				; calc block address 
554b			 
554b eb				ex de, hl 
554c 3e 40			ld a, STORE_BLOCK_PHY 
554e cd 61 0f			call Mult16 
5551			 
5551				FORTH_DSP_POP 
5551 cd 05 23			call macro_forth_dsp_pop 
5554				endm 
# End of macro FORTH_DSP_POP
5554			 
5554			 
5554 11 af f9			ld de, store_page 
5557			 
5557					if DEBUG_FORTH_WORDS 
5557						DMARK "BUe" 
5557 f5				push af  
5558 3a 6c 55			ld a, (.dmark)  
555b 32 a0 fd			ld (debug_mark),a  
555e 3a 6d 55			ld a, (.dmark+1)  
5561 32 a1 fd			ld (debug_mark+1),a  
5564 3a 6e 55			ld a, (.dmark+2)  
5567 32 a2 fd			ld (debug_mark+2),a  
556a 18 03			jr .pastdmark  
556c ..			.dmark: db "BUe"  
556f f1			.pastdmark: pop af  
5570			endm  
# End of macro DMARK
5570						CALLMONITOR 
5570 cd aa fd			call debug_vector  
5573				endm  
# End of macro CALLMONITOR
5573					endif 
5573			 
5573 cd d9 04			call storage_write_block 
5576			 
5576					NEXTW 
5576 c3 38 24			jp macro_next 
5579				endm 
# End of macro NEXTW
5579			 
5579			.BYID: 
5579			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5579			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5579			; 
5579			;		 
5579			;		if DEBUG_FORTH_WORDS_KEY 
5579			;			DMARK "BYID" 
5579			;			CALLMONITOR 
5579			;		endif 
5579			; 
5579			;		; get direct address 
5579			; 
5579			;		FORTH_DSP_VALUEHL 
5579			; 
5579			;		FORTH_DSP_POP 
5579			; 
5579			;	; calc block address 
5579			; 
5579			;	ex de, hl 
5579			;	ld a, STORE_BLOCK_PHY 
5579			;	call Mult16 
5579			;	;	do BREAD with number as param 
5579			;	; push the file name	 
5579			;	ld de, store_page 
5579			;	call storage_read_block 
5579			 ;       ld hl, store_page+2 
5579			; 
5579			; 
5579			;		NEXTW 
5579			;.BYNAME: 
5579				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5579 3a				db WORD_SYS_CORE+38             
557a 92 55			dw .DIR            
557c 06				db 5 + 1 
557d .. 00			db "GETID",0              
5583				endm 
# End of macro CWHEAD
5583			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
5583			; | | > [!NOTE] 
5583			; | | > Compatible with PicoSPINet  
5583			 
5583					; get pointer to file name to seek 
5583			 
5583					FORTH_DSP_VALUEHL 
5583 cd 4d 22			call macro_dsp_valuehl 
5586				endm 
# End of macro FORTH_DSP_VALUEHL
5586			 
5586			 
5586 cd 9b 03				call storage_getid  
5589			 
5589					FORTH_DSP_POP 
5589 cd 05 23			call macro_forth_dsp_pop 
558c				endm 
# End of macro FORTH_DSP_POP
558c			 
558c cd 48 20				call forth_push_numhl 
558f			 
558f					NEXTW 
558f c3 38 24			jp macro_next 
5592				endm 
# End of macro NEXTW
5592			; 
5592			.DIR: 
5592				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
5592 3a				db WORD_SYS_CORE+38             
5593 96 56			dw .SAVE            
5595 04				db 3 + 1 
5596 .. 00			db "DIR",0              
559a				endm 
# End of macro CWHEAD
559a			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
559a			; | | > [!NOTE] 
559a			; | | > Compatible with PicoSPINet  
559a			 
559a					if DEBUG_FORTH_WORDS_KEY 
559a						DMARK "DIR" 
559a f5				push af  
559b 3a af 55			ld a, (.dmark)  
559e 32 a0 fd			ld (debug_mark),a  
55a1 3a b0 55			ld a, (.dmark+1)  
55a4 32 a1 fd			ld (debug_mark+1),a  
55a7 3a b1 55			ld a, (.dmark+2)  
55aa 32 a2 fd			ld (debug_mark+2),a  
55ad 18 03			jr .pastdmark  
55af ..			.dmark: db "DIR"  
55b2 f1			.pastdmark: pop af  
55b3			endm  
# End of macro DMARK
55b3						CALLMONITOR 
55b3 cd aa fd			call debug_vector  
55b6				endm  
# End of macro CALLMONITOR
55b6					endif 
55b6 cd 25 05			call storage_get_block_0 
55b9			 
55b9 21 af f9			ld hl, store_page     ; get current id count 
55bc 46				ld b, (hl) 
55bd 0e 00			ld c, 0    ; count of files   
55bf					if DEBUG_FORTH_WORDS 
55bf						DMARK "DI1" 
55bf f5				push af  
55c0 3a d4 55			ld a, (.dmark)  
55c3 32 a0 fd			ld (debug_mark),a  
55c6 3a d5 55			ld a, (.dmark+1)  
55c9 32 a1 fd			ld (debug_mark+1),a  
55cc 3a d6 55			ld a, (.dmark+2)  
55cf 32 a2 fd			ld (debug_mark+2),a  
55d2 18 03			jr .pastdmark  
55d4 ..			.dmark: db "DI1"  
55d7 f1			.pastdmark: pop af  
55d8			endm  
# End of macro DMARK
55d8						CALLMONITOR 
55d8 cd aa fd			call debug_vector  
55db				endm  
# End of macro CALLMONITOR
55db					endif 
55db			 
55db				; check for empty drive 
55db			 
55db 3e 00			ld a, 0 
55dd b8				cp b 
55de ca 4c 56			jp z, .dirdone 
55e1			 
55e1				; for each of the current ids do a search for them and if found push to stack 
55e1			 
55e1 c5			.diritem:	push bc 
55e2 21 40 00				ld hl, STORE_BLOCK_PHY 
55e5 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
55e7 58					ld e,b 
55e8			 
55e8			;		if DEBUG_FORTH_WORDS 
55e8			;			DMARK "DI2" 
55e8			;			CALLMONITOR 
55e8			;		endif 
55e8			 
55e8 cd a7 07				call storage_findnextid 
55eb			 
55eb			;		if DEBUG_FORTH_WORDS 
55eb			;			DMARK "DI3" 
55eb			;			CALLMONITOR 
55eb			;		endif 
55eb			 
55eb					; if found hl will be non zero 
55eb			 
55eb cd 07 10				call ishlzero 
55ee			;		ld a, l 
55ee			;		add h 
55ee			; 
55ee			;		cp 0 
55ee 28 59				jr z, .dirnotfound 
55f0			 
55f0					; increase count 
55f0			 
55f0 c1					pop bc	 
55f1 0c					inc c 
55f2 c5					push bc 
55f3					 
55f3			 
55f3					; get file header and push the file name 
55f3			 
55f3 11 af f9				ld de, store_page 
55f6 cd 74 04				call storage_read_block 
55f9			 
55f9					; push file id to stack 
55f9				 
55f9 3a af f9				ld a, (store_page) 
55fc 26 00				ld h, 0 
55fe 6f					ld l, a 
55ff cd 48 20				call forth_push_numhl 
5602			 
5602					; push extent count to stack  
5602				 
5602 3a b1 f9				ld a, (store_page+2) 
5605 26 00				ld h, 0 
5607 6f					ld l, a 
5608 cd 48 20				call forth_push_numhl 
560b			 
560b					; push file name 
560b			 
560b 21 b2 f9				ld hl, store_page+3 
560e					if DEBUG_FORTH_WORDS 
560e						DMARK "DI5" 
560e f5				push af  
560f 3a 23 56			ld a, (.dmark)  
5612 32 a0 fd			ld (debug_mark),a  
5615 3a 24 56			ld a, (.dmark+1)  
5618 32 a1 fd			ld (debug_mark+1),a  
561b 3a 25 56			ld a, (.dmark+2)  
561e 32 a2 fd			ld (debug_mark+2),a  
5621 18 03			jr .pastdmark  
5623 ..			.dmark: db "DI5"  
5626 f1			.pastdmark: pop af  
5627			endm  
# End of macro DMARK
5627						CALLMONITOR 
5627 cd aa fd			call debug_vector  
562a				endm  
# End of macro CALLMONITOR
562a					endif 
562a cd b6 20				call forth_push_str 
562d					if DEBUG_FORTH_WORDS 
562d						DMARK "DI6" 
562d f5				push af  
562e 3a 42 56			ld a, (.dmark)  
5631 32 a0 fd			ld (debug_mark),a  
5634 3a 43 56			ld a, (.dmark+1)  
5637 32 a1 fd			ld (debug_mark+1),a  
563a 3a 44 56			ld a, (.dmark+2)  
563d 32 a2 fd			ld (debug_mark+2),a  
5640 18 03			jr .pastdmark  
5642 ..			.dmark: db "DI6"  
5645 f1			.pastdmark: pop af  
5646			endm  
# End of macro DMARK
5646						CALLMONITOR 
5646 cd aa fd			call debug_vector  
5649				endm  
# End of macro CALLMONITOR
5649					endif 
5649			.dirnotfound: 
5649 c1					pop bc     
564a 10 95				djnz .diritem 
564c				 
564c			.dirdone:	 
564c					if DEBUG_FORTH_WORDS 
564c						DMARK "DI7" 
564c f5				push af  
564d 3a 61 56			ld a, (.dmark)  
5650 32 a0 fd			ld (debug_mark),a  
5653 3a 62 56			ld a, (.dmark+1)  
5656 32 a1 fd			ld (debug_mark+1),a  
5659 3a 63 56			ld a, (.dmark+2)  
565c 32 a2 fd			ld (debug_mark+2),a  
565f 18 03			jr .pastdmark  
5661 ..			.dmark: db "DI7"  
5664 f1			.pastdmark: pop af  
5665			endm  
# End of macro DMARK
5665						CALLMONITOR 
5665 cd aa fd			call debug_vector  
5668				endm  
# End of macro CALLMONITOR
5668					endif 
5668			 
5668					; push a count of the dir items found 
5668			 
5668 26 00				ld h, 0 
566a 69					ld l, c 
566b cd 48 20				call forth_push_numhl 
566e			 
566e					; push the bank label 
566e			 
566e cd 25 05				call storage_get_block_0 
5671			 
5671				 
5671 21 b2 f9		 		ld hl, store_page+3 
5674			 
5674					if DEBUG_FORTH_WORDS 
5674						DMARK "DI8" 
5674 f5				push af  
5675 3a 89 56			ld a, (.dmark)  
5678 32 a0 fd			ld (debug_mark),a  
567b 3a 8a 56			ld a, (.dmark+1)  
567e 32 a1 fd			ld (debug_mark+1),a  
5681 3a 8b 56			ld a, (.dmark+2)  
5684 32 a2 fd			ld (debug_mark+2),a  
5687 18 03			jr .pastdmark  
5689 ..			.dmark: db "DI8"  
568c f1			.pastdmark: pop af  
568d			endm  
# End of macro DMARK
568d						CALLMONITOR 
568d cd aa fd			call debug_vector  
5690				endm  
# End of macro CALLMONITOR
5690					endif 
5690 cd b6 20				call forth_push_str 
5693			 
5693			 
5693				 
5693					NEXTW 
5693 c3 38 24			jp macro_next 
5696				endm 
# End of macro NEXTW
5696			.SAVE: 
5696			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5696			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5696			;		NEXTW 
5696			;.LOAD: 
5696			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5696			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5696			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5696			;; > > The LOAD command can not be used in any user words or compound lines. 
5696			; 
5696			;		; store_openext use it. If zero it is EOF 
5696			; 
5696			;		; read block from current stream id 
5696			;		; if the block does not contain zero term keep reading blocks until zero found 
5696			;		; push the block to stack 
5696			;		; save the block id to stream 
5696			; 
5696			; 
5696			;		FORTH_DSP_VALUEHL 
5696			; 
5696			;;		push hl 
5696			; 
5696			;	if DEBUG_STORESE 
5696			;		DMARK "LOA" 
5696			;		CALLMONITOR 
5696			;	endif 
5696			;		FORTH_DSP_POP 
5696			; 
5696			;;		pop hl 
5696			; 
5696			;		ld h, l 
5696			;		ld l, 0 
5696			; 
5696			;		push hl     ; stack holds current file id and extent to work with 
5696			; 
5696			; 
5696			;		ld de, store_page      ; get block zero of file 
5696			;	if DEBUG_STORESE 
5696			;		DMARK "LO0" 
5696			;		CALLMONITOR 
5696			;	endif 
5696			;		call storage_read 
5696			; 
5696			;		ld a, (store_page+2)    ; max extents for this file 
5696			;		ld  (store_openmaxext),a   ; get our limit 
5696			; 
5696			;	if DEBUG_STORESE 
5696			;		DMARK "LOE" 
5696			;		CALLMONITOR 
5696			;	endif 
5696			; 
5696			;; TODO dont know why max extents are not present 
5696			;;		cp 0 
5696			;;		jp z, .loadeof     ; dont read past eof 
5696			; 
5696			;;		ld a, 1   ; start from the head of the file 
5696			; 
5696			;.loadline:	pop hl 
5696			;		inc hl 
5696			;		ld  a, (store_openmaxext)   ; get our limit 
5696			;	if DEBUG_STORESE 
5696			;		DMARK "LOx" 
5696			;		CALLMONITOR 
5696			;	endif 
5696			;		inc a 
5696			;		cp l 
5696			;		jp z, .loadeof 
5696			;		push hl    ; save current extent 
5696			; 
5696			;		ld de, store_page 
5696			; 
5696			;	if DEBUG_STORESE 
5696			;		DMARK "LO1" 
5696			;		CALLMONITOR 
5696			;	endif 
5696			;		call storage_read 
5696			; 
5696			;	if DEBUG_STORESE 
5696			;		DMARK "LO2" 
5696			;		CALLMONITOR 
5696			;	endif 
5696			;	call ishlzero 
5696			;	ld a, l 
5696			;	add h 
5696			;	cp 0 
5696			;	jr z, .loadeof 
5696			; 
5696			;	; not eof so hl should point to data to exec 
5696			; 
5696			;	; will need to add the FORTH_END_BUFFER flag 
5696			 ; 
5696			;	ld hl, store_page+2 
5696			;	ld bc, 255 
5696			;	ld a, 0 
5696			;	cpir 
5696			;	if DEBUG_STORESE 
5696			;		DMARK "LOt" 
5696			;		CALLMONITOR 
5696			;	endif 
5696			;	dec hl 
5696			;	ld a, ' ' 
5696			;	ld (hl), a 
5696			;	inc hl 
5696			;	ld (hl), a 
5696			;	inc hl 
5696			;	ld (hl), a 
5696			;	inc hl 
5696			;	ld a, FORTH_END_BUFFER 
5696			;	ld (hl), a 
5696			; 
5696			;	; TODO handle more than a single block read 
5696			; 
5696			; 
5696			;	ld hl, store_page+2 
5696			; 
5696			;	ld (os_tok_ptr), hl 
5696			; 
5696			;	if DEBUG_STORESE 
5696			;		DMARK "LO3" 
5696			;		CALLMONITOR 
5696			;	endif 
5696			; 
5696			;	call forthparse 
5696			;	call forthexec 
5696			;	call forthexec_cleanup 
5696			; 
5696			;	; go to next extent 
5696			; 
5696			;	; get next block  or mark as eof 
5696			;	jp .loadline 
5696			; 
5696			; 
5696			; 
5696			;	       NEXTW 
5696			;.loadeof:	ld a, 0 
5696			;		ld (store_openext), a 
5696			; 
5696			;	if DEBUG_STORESE 
5696			;		DMARK "LOF" 
5696			;		CALLMONITOR 
5696			;	endif 
5696			;		ret 
5696			;		;NEXTW 
5696			;.BSAVE:   
5696			; 
5696			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5696			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5696			;		NEXTW 
5696			;.BLOAD: 
5696			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5696			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5696			;		NEXTW 
5696			;;;; counter gap 
5696			 
5696			 
5696			.SEO: 
5696				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5696 64				db WORD_SYS_CORE+80             
5697 b5 56			dw .SEI            
5699 04				db 3 + 1 
569a .. 00			db "SEO",0              
569e				endm 
# End of macro CWHEAD
569e			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
569e			 
569e					; get port 
569e			 
569e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
569e cd 4d 22			call macro_dsp_valuehl 
56a1				endm 
# End of macro FORTH_DSP_VALUEHL
56a1			 
56a1 e5					push hl    ; u2 - byte 
56a2			 
56a2					; destroy value TOS 
56a2			 
56a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
56a2 cd 05 23			call macro_forth_dsp_pop 
56a5				endm 
# End of macro FORTH_DSP_POP
56a5			 
56a5					; get byte to send 
56a5			 
56a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
56a5 cd 4d 22			call macro_dsp_valuehl 
56a8				endm 
# End of macro FORTH_DSP_VALUEHL
56a8			 
56a8 e5					push hl    ; u1 - addr 
56a9			 
56a9					; destroy value TOS 
56a9			 
56a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
56a9 cd 05 23			call macro_forth_dsp_pop 
56ac				endm 
# End of macro FORTH_DSP_POP
56ac			 
56ac					; one value on hl get other one back 
56ac			 
56ac d1					pop de   ; u1 - byte 
56ad			 
56ad e1					pop hl   ; u2 - addr 
56ae			 
56ae					; TODO Send SPI byte 
56ae			 
56ae			 
56ae 7b					ld a, e 
56af cd 79 02				call se_writebyte 
56b2			 
56b2					 
56b2			 
56b2					NEXTW 
56b2 c3 38 24			jp macro_next 
56b5				endm 
# End of macro NEXTW
56b5			 
56b5			.SEI: 
56b5				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
56b5 65				db WORD_SYS_CORE+81             
56b6 cf 56			dw .SFREE            
56b8 04				db 3 + 1 
56b9 .. 00			db "SEI",0              
56bd				endm 
# End of macro CWHEAD
56bd			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
56bd			 
56bd					; get port 
56bd			 
56bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
56bd cd 4d 22			call macro_dsp_valuehl 
56c0				endm 
# End of macro FORTH_DSP_VALUEHL
56c0			 
56c0			;		push hl 
56c0			 
56c0					; destroy value TOS 
56c0			 
56c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
56c0 cd 05 23			call macro_forth_dsp_pop 
56c3				endm 
# End of macro FORTH_DSP_POP
56c3			 
56c3					; one value on hl get other one back 
56c3			 
56c3			;		pop hl 
56c3			 
56c3			 
56c3					; TODO Get SPI byte 
56c3			 
56c3 cd 1b 03				call se_readbyte 
56c6			 
56c6 26 00				ld h, 0 
56c8 6f					ld l, a 
56c9 cd 48 20				call forth_push_numhl 
56cc			 
56cc					NEXTW 
56cc c3 38 24			jp macro_next 
56cf				endm 
# End of macro NEXTW
56cf			 
56cf			.SFREE: 
56cf				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
56cf 67				db WORD_SYS_CORE+83             
56d0 fe 56			dw .SIZE            
56d2 06				db 5 + 1 
56d3 .. 00			db "FFREE",0              
56d9				endm 
# End of macro CWHEAD
56d9			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
56d9			; | | > [!NOTE] 
56d9			; | | > Compatible with PicoSPINet  
56d9					if DEBUG_FORTH_WORDS_KEY 
56d9						DMARK "FFR" 
56d9 f5				push af  
56da 3a ee 56			ld a, (.dmark)  
56dd 32 a0 fd			ld (debug_mark),a  
56e0 3a ef 56			ld a, (.dmark+1)  
56e3 32 a1 fd			ld (debug_mark+1),a  
56e6 3a f0 56			ld a, (.dmark+2)  
56e9 32 a2 fd			ld (debug_mark+2),a  
56ec 18 03			jr .pastdmark  
56ee ..			.dmark: db "FFR"  
56f1 f1			.pastdmark: pop af  
56f2			endm  
# End of macro DMARK
56f2						CALLMONITOR 
56f2 cd aa fd			call debug_vector  
56f5				endm  
# End of macro CALLMONITOR
56f5					endif 
56f5			 
56f5 cd 41 08				call storage_freeblocks 
56f8			 
56f8 cd 48 20				call forth_push_numhl 
56fb			 
56fb				       NEXTW 
56fb c3 38 24			jp macro_next 
56fe				endm 
# End of macro NEXTW
56fe			.SIZE: 
56fe				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
56fe 67				db WORD_SYS_CORE+83             
56ff 32 57			dw .CREATE            
5701 05				db 4 + 1 
5702 .. 00			db "SIZE",0              
5707				endm 
# End of macro CWHEAD
5707			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5707			; | | > [!NOTE] 
5707			; | | > Compatible with PicoSPINet  
5707					if DEBUG_FORTH_WORDS_KEY 
5707						DMARK "SIZ" 
5707 f5				push af  
5708 3a 1c 57			ld a, (.dmark)  
570b 32 a0 fd			ld (debug_mark),a  
570e 3a 1d 57			ld a, (.dmark+1)  
5711 32 a1 fd			ld (debug_mark+1),a  
5714 3a 1e 57			ld a, (.dmark+2)  
5717 32 a2 fd			ld (debug_mark+2),a  
571a 18 03			jr .pastdmark  
571c ..			.dmark: db "SIZ"  
571f f1			.pastdmark: pop af  
5720			endm  
# End of macro DMARK
5720						CALLMONITOR 
5720 cd aa fd			call debug_vector  
5723				endm  
# End of macro CALLMONITOR
5723					endif 
5723			 
5723					FORTH_DSP_VALUEHL 
5723 cd 4d 22			call macro_dsp_valuehl 
5726				endm 
# End of macro FORTH_DSP_VALUEHL
5726			;		push hl 
5726					FORTH_DSP_POP 
5726 cd 05 23			call macro_forth_dsp_pop 
5729				endm 
# End of macro FORTH_DSP_POP
5729			;		pop hl 
5729 cd a3 04				call storage_file_size 
572c			 
572c cd 48 20				call forth_push_numhl 
572f			  
572f			 
572f				       NEXTW 
572f c3 38 24			jp macro_next 
5732				endm 
# End of macro NEXTW
5732			 
5732			.CREATE: 
5732				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5732 68				db WORD_SYS_CORE+84             
5733 a0 57			dw .APPEND            
5735 07				db 6 + 1 
5736 .. 00			db "CREATE",0              
573d				endm 
# End of macro CWHEAD
573d			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
573d			; | | e.g.  
573d			; | | TestProgram CREATE 
573d			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
573d			; | |  
573d			; | | Max file IDs are 255. 
573d			; | |  
573d			; | | > [!NOTE] 
573d			; | | > Compatible with PicoSPINet  
573d					 
573d					if DEBUG_FORTH_WORDS_KEY 
573d						DMARK "CRT" 
573d f5				push af  
573e 3a 52 57			ld a, (.dmark)  
5741 32 a0 fd			ld (debug_mark),a  
5744 3a 53 57			ld a, (.dmark+1)  
5747 32 a1 fd			ld (debug_mark+1),a  
574a 3a 54 57			ld a, (.dmark+2)  
574d 32 a2 fd			ld (debug_mark+2),a  
5750 18 03			jr .pastdmark  
5752 ..			.dmark: db "CRT"  
5755 f1			.pastdmark: pop af  
5756			endm  
# End of macro DMARK
5756						CALLMONITOR 
5756 cd aa fd			call debug_vector  
5759				endm  
# End of macro CALLMONITOR
5759					endif 
5759			;		call storage_get_block_0 
5759			 
5759					; TODO pop hl 
5759			 
5759					;v5 FORTH_DSP_VALUE 
5759					FORTH_DSP_VALUE 
5759 cd 36 22			call macro_forth_dsp_value 
575c				endm 
# End of macro FORTH_DSP_VALUE
575c			 
575c				if DEBUG_STORESE 
575c					DMARK "CR1" 
575c f5				push af  
575d 3a 71 57			ld a, (.dmark)  
5760 32 a0 fd			ld (debug_mark),a  
5763 3a 72 57			ld a, (.dmark+1)  
5766 32 a1 fd			ld (debug_mark+1),a  
5769 3a 73 57			ld a, (.dmark+2)  
576c 32 a2 fd			ld (debug_mark+2),a  
576f 18 03			jr .pastdmark  
5771 ..			.dmark: db "CR1"  
5774 f1			.pastdmark: pop af  
5775			endm  
# End of macro DMARK
5775					CALLMONITOR 
5775 cd aa fd			call debug_vector  
5778				endm  
# End of macro CALLMONITOR
5778				endif 
5778			;		push hl 
5778			;		FORTH_DSP_POP 
5778			;		pop hl 
5778			 
5778			;		inc hl   ; move past the type marker 
5778			 
5778 cd 77 08				call storage_create 
577b			 
577b				if DEBUG_STORESE 
577b					DMARK "CT1" 
577b f5				push af  
577c 3a 90 57			ld a, (.dmark)  
577f 32 a0 fd			ld (debug_mark),a  
5782 3a 91 57			ld a, (.dmark+1)  
5785 32 a1 fd			ld (debug_mark+1),a  
5788 3a 92 57			ld a, (.dmark+2)  
578b 32 a2 fd			ld (debug_mark+2),a  
578e 18 03			jr .pastdmark  
5790 ..			.dmark: db "CT1"  
5793 f1			.pastdmark: pop af  
5794			endm  
# End of macro DMARK
5794					CALLMONITOR 
5794 cd aa fd			call debug_vector  
5797				endm  
# End of macro CALLMONITOR
5797				endif 
5797			;		push hl 
5797					FORTH_DSP_POP 
5797 cd 05 23			call macro_forth_dsp_pop 
579a				endm 
# End of macro FORTH_DSP_POP
579a			;		pop hl 
579a					; push file id to stack 
579a cd 48 20				call forth_push_numhl 
579d			 
579d			 
579d			 
579d				       NEXTW 
579d c3 38 24			jp macro_next 
57a0				endm 
# End of macro NEXTW
57a0			 
57a0			.APPEND: 
57a0				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
57a0 69				db WORD_SYS_CORE+85             
57a1 31 58			dw .SDEL            
57a3 07				db 6 + 1 
57a4 .. 00			db "APPEND",0              
57ab				endm 
# End of macro CWHEAD
57ab			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
57ab			; | | e.g. 
57ab			; | | Test CREATE      -> $01 
57ab			; | | "A string to add to file" $01 APPEND 
57ab			; | |  
57ab			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
57ab			; | | > [!NOTE] 
57ab			; | | > Compatible with PicoSPINet  
57ab					if DEBUG_FORTH_WORDS_KEY 
57ab						DMARK "APP" 
57ab f5				push af  
57ac 3a c0 57			ld a, (.dmark)  
57af 32 a0 fd			ld (debug_mark),a  
57b2 3a c1 57			ld a, (.dmark+1)  
57b5 32 a1 fd			ld (debug_mark+1),a  
57b8 3a c2 57			ld a, (.dmark+2)  
57bb 32 a2 fd			ld (debug_mark+2),a  
57be 18 03			jr .pastdmark  
57c0 ..			.dmark: db "APP"  
57c3 f1			.pastdmark: pop af  
57c4			endm  
# End of macro DMARK
57c4						CALLMONITOR 
57c4 cd aa fd			call debug_vector  
57c7				endm  
# End of macro CALLMONITOR
57c7					endif 
57c7			 
57c7					FORTH_DSP_VALUEHL 
57c7 cd 4d 22			call macro_dsp_valuehl 
57ca				endm 
# End of macro FORTH_DSP_VALUEHL
57ca e5					push hl 	; save file id 
57cb			 
57cb				if DEBUG_STORESE 
57cb					DMARK "AP1" 
57cb f5				push af  
57cc 3a e0 57			ld a, (.dmark)  
57cf 32 a0 fd			ld (debug_mark),a  
57d2 3a e1 57			ld a, (.dmark+1)  
57d5 32 a1 fd			ld (debug_mark+1),a  
57d8 3a e2 57			ld a, (.dmark+2)  
57db 32 a2 fd			ld (debug_mark+2),a  
57de 18 03			jr .pastdmark  
57e0 ..			.dmark: db "AP1"  
57e3 f1			.pastdmark: pop af  
57e4			endm  
# End of macro DMARK
57e4					CALLMONITOR 
57e4 cd aa fd			call debug_vector  
57e7				endm  
# End of macro CALLMONITOR
57e7				endif 
57e7					FORTH_DSP_POP 
57e7 cd 05 23			call macro_forth_dsp_pop 
57ea				endm 
# End of macro FORTH_DSP_POP
57ea			 
57ea					FORTH_DSP_VALUEHL 
57ea cd 4d 22			call macro_dsp_valuehl 
57ed				endm 
# End of macro FORTH_DSP_VALUEHL
57ed					;v5 FORTH_DSP_VALUE 
57ed e5					push hl 	; save ptr to string to save 
57ee			 
57ee				if DEBUG_STORESE 
57ee					DMARK "AP1" 
57ee f5				push af  
57ef 3a 03 58			ld a, (.dmark)  
57f2 32 a0 fd			ld (debug_mark),a  
57f5 3a 04 58			ld a, (.dmark+1)  
57f8 32 a1 fd			ld (debug_mark+1),a  
57fb 3a 05 58			ld a, (.dmark+2)  
57fe 32 a2 fd			ld (debug_mark+2),a  
5801 18 03			jr .pastdmark  
5803 ..			.dmark: db "AP1"  
5806 f1			.pastdmark: pop af  
5807			endm  
# End of macro DMARK
5807					CALLMONITOR 
5807 cd aa fd			call debug_vector  
580a				endm  
# End of macro CALLMONITOR
580a				endif 
580a					FORTH_DSP_POP 
580a cd 05 23			call macro_forth_dsp_pop 
580d				endm 
# End of macro FORTH_DSP_POP
580d			 
580d d1					pop de 
580e e1					pop hl 
580f				if DEBUG_STORESE 
580f					DMARK "AP2" 
580f f5				push af  
5810 3a 24 58			ld a, (.dmark)  
5813 32 a0 fd			ld (debug_mark),a  
5816 3a 25 58			ld a, (.dmark+1)  
5819 32 a1 fd			ld (debug_mark+1),a  
581c 3a 26 58			ld a, (.dmark+2)  
581f 32 a2 fd			ld (debug_mark+2),a  
5822 18 03			jr .pastdmark  
5824 ..			.dmark: db "AP2"  
5827 f1			.pastdmark: pop af  
5828			endm  
# End of macro DMARK
5828					CALLMONITOR 
5828 cd aa fd			call debug_vector  
582b				endm  
# End of macro CALLMONITOR
582b				endif 
582b					;inc de ; skip var type indicator 
582b			 
582b					; TODO how to append numerics???? 
582b			 
582b cd 64 0b				call storage_append		 
582e			 
582e				       NEXTW 
582e c3 38 24			jp macro_next 
5831				endm 
# End of macro NEXTW
5831			.SDEL: 
5831				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5831 6a				db WORD_SYS_CORE+86             
5832 7d 58			dw .OPEN            
5834 05				db 4 + 1 
5835 .. 00			db "ERA",0              
5839				endm 
# End of macro CWHEAD
5839			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5839			; | | > [!NOTE] 
5839			; | | > Compatible with PicoSPINet  
5839					FORTH_DSP_VALUEHL 
5839 cd 4d 22			call macro_dsp_valuehl 
583c				endm 
# End of macro FORTH_DSP_VALUEHL
583c			;		push hl 	; save file id 
583c			 
583c					if DEBUG_FORTH_WORDS_KEY 
583c						DMARK "ERA" 
583c f5				push af  
583d 3a 51 58			ld a, (.dmark)  
5840 32 a0 fd			ld (debug_mark),a  
5843 3a 52 58			ld a, (.dmark+1)  
5846 32 a1 fd			ld (debug_mark+1),a  
5849 3a 53 58			ld a, (.dmark+2)  
584c 32 a2 fd			ld (debug_mark+2),a  
584f 18 03			jr .pastdmark  
5851 ..			.dmark: db "ERA"  
5854 f1			.pastdmark: pop af  
5855			endm  
# End of macro DMARK
5855						CALLMONITOR 
5855 cd aa fd			call debug_vector  
5858				endm  
# End of macro CALLMONITOR
5858					endif 
5858				if DEBUG_STORESE 
5858					DMARK "ER1" 
5858 f5				push af  
5859 3a 6d 58			ld a, (.dmark)  
585c 32 a0 fd			ld (debug_mark),a  
585f 3a 6e 58			ld a, (.dmark+1)  
5862 32 a1 fd			ld (debug_mark+1),a  
5865 3a 6f 58			ld a, (.dmark+2)  
5868 32 a2 fd			ld (debug_mark+2),a  
586b 18 03			jr .pastdmark  
586d ..			.dmark: db "ER1"  
5870 f1			.pastdmark: pop af  
5871			endm  
# End of macro DMARK
5871					CALLMONITOR 
5871 cd aa fd			call debug_vector  
5874				endm  
# End of macro CALLMONITOR
5874				endif 
5874					FORTH_DSP_POP 
5874 cd 05 23			call macro_forth_dsp_pop 
5877				endm 
# End of macro FORTH_DSP_POP
5877			 
5877			;		pop hl 
5877			 
5877 cd b6 06				call storage_erase 
587a				       NEXTW 
587a c3 38 24			jp macro_next 
587d				endm 
# End of macro NEXTW
587d			 
587d			.OPEN: 
587d				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
587d 6b				db WORD_SYS_CORE+87             
587e 11 59			dw .READ            
5880 05				db 4 + 1 
5881 .. 00			db "OPEN",0              
5886				endm 
# End of macro CWHEAD
5886			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5886			; | | e.g. 
5886			; | | $01 OPEN $01 DO $01 READ . LOOP 
5886			; | | 
5886			; | | Will return with 255 blocks if the file does not exist 
5886			; | | > [!NOTE] 
5886			; | | > Compatible with PicoSPINet  
5886			 
5886					if DEBUG_FORTH_WORDS_KEY 
5886						DMARK "OPN" 
5886 f5				push af  
5887 3a 9b 58			ld a, (.dmark)  
588a 32 a0 fd			ld (debug_mark),a  
588d 3a 9c 58			ld a, (.dmark+1)  
5890 32 a1 fd			ld (debug_mark+1),a  
5893 3a 9d 58			ld a, (.dmark+2)  
5896 32 a2 fd			ld (debug_mark+2),a  
5899 18 03			jr .pastdmark  
589b ..			.dmark: db "OPN"  
589e f1			.pastdmark: pop af  
589f			endm  
# End of macro DMARK
589f						CALLMONITOR 
589f cd aa fd			call debug_vector  
58a2				endm  
# End of macro CALLMONITOR
58a2					endif 
58a2					; TODO handle multiple file opens 
58a2			 
58a2 3e 01			       	ld a, 1 
58a4 32 9f f9				ld (store_openext), a 
58a7			 
58a7					; get max extents for this file 
58a7				 
58a7								 
58a7					FORTH_DSP_VALUEHL 
58a7 cd 4d 22			call macro_dsp_valuehl 
58aa				endm 
# End of macro FORTH_DSP_VALUEHL
58aa			 
58aa 65					ld h, l 
58ab 2e 00				ld l, 0 
58ad			 
58ad					; store file id 
58ad			 
58ad 7c					ld a, h 
58ae 32 9c f9				ld (store_filecache), a 
58b1			 
58b1				if DEBUG_STORESE 
58b1					DMARK "OPN" 
58b1 f5				push af  
58b2 3a c6 58			ld a, (.dmark)  
58b5 32 a0 fd			ld (debug_mark),a  
58b8 3a c7 58			ld a, (.dmark+1)  
58bb 32 a1 fd			ld (debug_mark+1),a  
58be 3a c8 58			ld a, (.dmark+2)  
58c1 32 a2 fd			ld (debug_mark+2),a  
58c4 18 03			jr .pastdmark  
58c6 ..			.dmark: db "OPN"  
58c9 f1			.pastdmark: pop af  
58ca			endm  
# End of macro DMARK
58ca					CALLMONITOR 
58ca cd aa fd			call debug_vector  
58cd				endm  
# End of macro CALLMONITOR
58cd				endif 
58cd			;		push hl 
58cd					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
58cd cd 05 23			call macro_forth_dsp_pop 
58d0				endm 
# End of macro FORTH_DSP_POP
58d0			;		pop hl 
58d0						 
58d0 11 af f9				ld de, store_page      ; get block zero of file 
58d3 cd cd 09				call storage_read 
58d6 cd 07 10			call ishlzero 
58d9 20 04			jr nz, .opfound 
58db			 
58db				; file does not exist so indicate with 255 extents in use 
58db			 
58db 3e ff			ld a, 255 
58dd 18 29			jr .skipopeneof 
58df			 
58df			 
58df			.opfound: 
58df			 
58df			 
58df 3a b1 f9				ld a, (store_page+2)    ; max extents for this file 
58e2 32 9e f9				ld  (store_openmaxext), a   ; get our limit and push 
58e5					 
58e5				if DEBUG_STORESE 
58e5					DMARK "OPx" 
58e5 f5				push af  
58e6 3a fa 58			ld a, (.dmark)  
58e9 32 a0 fd			ld (debug_mark),a  
58ec 3a fb 58			ld a, (.dmark+1)  
58ef 32 a1 fd			ld (debug_mark+1),a  
58f2 3a fc 58			ld a, (.dmark+2)  
58f5 32 a2 fd			ld (debug_mark+2),a  
58f8 18 03			jr .pastdmark  
58fa ..			.dmark: db "OPx"  
58fd f1			.pastdmark: pop af  
58fe			endm  
# End of macro DMARK
58fe					CALLMONITOR 
58fe cd aa fd			call debug_vector  
5901				endm  
# End of macro CALLMONITOR
5901				endif 
5901 fe 00				cp 0 
5903 20 03				jr nz, .skipopeneof 
5905					; have opened an empty file 
5905					 
5905 32 9f f9				ld (store_openext), a 
5908			 
5908			.skipopeneof: 
5908			 
5908 6f					ld l, a 
5909 26 00				ld h, 0 
590b cd 48 20				call forth_push_numhl 
590e			 
590e			 
590e				       NEXTW 
590e c3 38 24			jp macro_next 
5911				endm 
# End of macro NEXTW
5911			.READ: 
5911				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5911 6c				db WORD_SYS_CORE+88             
5912 3b 5a			dw .EOF            
5914 05				db 4 + 1 
5915 .. 00			db "READ",0              
591a				endm 
# End of macro CWHEAD
591a			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
591a			; | | e.g. 
591a			; | | $01 OPEN $01 DO READ . LOOP 
591a			; | | 
591a			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
591a			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
591a			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
591a			; | | two bytes contain the file id and extent. 
591a			; | |  
591a			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
591a			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
591a			; | | > [!NOTE] 
591a			; | | > Compatible with PicoSPINet  
591a			 
591a					if DEBUG_FORTH_WORDS_KEY 
591a						DMARK "REA" 
591a f5				push af  
591b 3a 2f 59			ld a, (.dmark)  
591e 32 a0 fd			ld (debug_mark),a  
5921 3a 30 59			ld a, (.dmark+1)  
5924 32 a1 fd			ld (debug_mark+1),a  
5927 3a 31 59			ld a, (.dmark+2)  
592a 32 a2 fd			ld (debug_mark+2),a  
592d 18 03			jr .pastdmark  
592f ..			.dmark: db "REA"  
5932 f1			.pastdmark: pop af  
5933			endm  
# End of macro DMARK
5933						CALLMONITOR 
5933 cd aa fd			call debug_vector  
5936				endm  
# End of macro CALLMONITOR
5936					endif 
5936					; store_openext use it. If zero it is EOF 
5936			 
5936					; read block from current stream id 
5936					; if the block does not contain zero term keep reading blocks until zero found 
5936					; push the block to stack 
5936					; save the block id to stream 
5936			 
5936			 
5936 cd 68 5a				call .testeof 
5939 3e 01				ld a, 1 
593b bd					cp l 
593c ca 17 5a				jp z, .ateof 
593f			 
593f			 
593f			;		FORTH_DSP_VALUEHL 
593f			 
593f			;		push hl 
593f			 
593f			;	if DEBUG_STORESE 
593f			;		DMARK "REA" 
593f			;		CALLMONITOR 
593f			;	endif 
593f			;		FORTH_DSP_POP 
593f			 
593f			;		pop hl 
593f				 
593f 3a 9c f9				ld a, (store_filecache) 
5942 67					ld h,a 
5943			 
5943 3a 9f f9				ld a, (store_openext) 
5946 6f					ld l, a 
5947					 
5947 fe 00				cp 0 
5949 ca 17 5a				jp z, .ateof     ; dont read past eof 
594c			 
594c cd b0 0c				call storage_clear_page 
594f			 
594f 11 af f9				ld de, store_page 
5952				if DEBUG_STORESE 
5952					DMARK "RE1" 
5952 f5				push af  
5953 3a 67 59			ld a, (.dmark)  
5956 32 a0 fd			ld (debug_mark),a  
5959 3a 68 59			ld a, (.dmark+1)  
595c 32 a1 fd			ld (debug_mark+1),a  
595f 3a 69 59			ld a, (.dmark+2)  
5962 32 a2 fd			ld (debug_mark+2),a  
5965 18 03			jr .pastdmark  
5967 ..			.dmark: db "RE1"  
596a f1			.pastdmark: pop af  
596b			endm  
# End of macro DMARK
596b					CALLMONITOR 
596b cd aa fd			call debug_vector  
596e				endm  
# End of macro CALLMONITOR
596e				endif 
596e cd cd 09				call storage_read 
5971			 
5971				if DEBUG_STORESE 
5971					DMARK "RE2" 
5971 f5				push af  
5972 3a 86 59			ld a, (.dmark)  
5975 32 a0 fd			ld (debug_mark),a  
5978 3a 87 59			ld a, (.dmark+1)  
597b 32 a1 fd			ld (debug_mark+1),a  
597e 3a 88 59			ld a, (.dmark+2)  
5981 32 a2 fd			ld (debug_mark+2),a  
5984 18 03			jr .pastdmark  
5986 ..			.dmark: db "RE2"  
5989 f1			.pastdmark: pop af  
598a			endm  
# End of macro DMARK
598a					CALLMONITOR 
598a cd aa fd			call debug_vector  
598d				endm  
# End of macro CALLMONITOR
598d				endif 
598d cd 07 10			call ishlzero 
5990			;	ld a, l 
5990			;	add h 
5990			;	cp 0 
5990 ca 17 5a			jp z, .readeof 
5993			 
5993				; not eof so hl should point to data to push to stack 
5993			 
5993				if DEBUG_STORESE 
5993					DMARK "RE3" 
5993 f5				push af  
5994 3a a8 59			ld a, (.dmark)  
5997 32 a0 fd			ld (debug_mark),a  
599a 3a a9 59			ld a, (.dmark+1)  
599d 32 a1 fd			ld (debug_mark+1),a  
59a0 3a aa 59			ld a, (.dmark+2)  
59a3 32 a2 fd			ld (debug_mark+2),a  
59a6 18 03			jr .pastdmark  
59a8 ..			.dmark: db "RE3"  
59ab f1			.pastdmark: pop af  
59ac			endm  
# End of macro DMARK
59ac					CALLMONITOR 
59ac cd aa fd			call debug_vector  
59af				endm  
# End of macro CALLMONITOR
59af				endif 
59af cd b6 20			call forth_push_str 
59b2			 
59b2				if DEBUG_STORESE 
59b2					DMARK "RE4" 
59b2 f5				push af  
59b3 3a c7 59			ld a, (.dmark)  
59b6 32 a0 fd			ld (debug_mark),a  
59b9 3a c8 59			ld a, (.dmark+1)  
59bc 32 a1 fd			ld (debug_mark+1),a  
59bf 3a c9 59			ld a, (.dmark+2)  
59c2 32 a2 fd			ld (debug_mark+2),a  
59c5 18 03			jr .pastdmark  
59c7 ..			.dmark: db "RE4"  
59ca f1			.pastdmark: pop af  
59cb			endm  
# End of macro DMARK
59cb					CALLMONITOR 
59cb cd aa fd			call debug_vector  
59ce				endm  
# End of macro CALLMONITOR
59ce				endif 
59ce				; get next block  or mark as eof 
59ce			 
59ce 3a 9e f9			ld a, (store_openmaxext)   ; get our limit 
59d1 4f				ld c, a	 
59d2 3a 9f f9			ld a, (store_openext) 
59d5			 
59d5				if DEBUG_STORESE 
59d5					DMARK "RE5" 
59d5 f5				push af  
59d6 3a ea 59			ld a, (.dmark)  
59d9 32 a0 fd			ld (debug_mark),a  
59dc 3a eb 59			ld a, (.dmark+1)  
59df 32 a1 fd			ld (debug_mark+1),a  
59e2 3a ec 59			ld a, (.dmark+2)  
59e5 32 a2 fd			ld (debug_mark+2),a  
59e8 18 03			jr .pastdmark  
59ea ..			.dmark: db "RE5"  
59ed f1			.pastdmark: pop af  
59ee			endm  
# End of macro DMARK
59ee					CALLMONITOR 
59ee cd aa fd			call debug_vector  
59f1				endm  
# End of macro CALLMONITOR
59f1				endif 
59f1 b9				cp c 
59f2 28 23			jr z, .readeof     ; at last extent 
59f4			 
59f4 3c					inc a 
59f5 32 9f f9				ld (store_openext), a 
59f8			 
59f8				if DEBUG_STORESE 
59f8					DMARK "RE6" 
59f8 f5				push af  
59f9 3a 0d 5a			ld a, (.dmark)  
59fc 32 a0 fd			ld (debug_mark),a  
59ff 3a 0e 5a			ld a, (.dmark+1)  
5a02 32 a1 fd			ld (debug_mark+1),a  
5a05 3a 0f 5a			ld a, (.dmark+2)  
5a08 32 a2 fd			ld (debug_mark+2),a  
5a0b 18 03			jr .pastdmark  
5a0d ..			.dmark: db "RE6"  
5a10 f1			.pastdmark: pop af  
5a11			endm  
# End of macro DMARK
5a11					CALLMONITOR 
5a11 cd aa fd			call debug_vector  
5a14				endm  
# End of macro CALLMONITOR
5a14				endif 
5a14			 
5a14			 
5a14				       NEXTW 
5a14 c3 38 24			jp macro_next 
5a17				endm 
# End of macro NEXTW
5a17			.ateof: 
5a17				;	ld hl, .showeof 
5a17				;	call forth_push_str 
5a17 3e 00		.readeof:	ld a, 0 
5a19 32 9f f9				ld (store_openext), a 
5a1c			 
5a1c					 
5a1c				if DEBUG_STORESE 
5a1c					DMARK "REF" 
5a1c f5				push af  
5a1d 3a 31 5a			ld a, (.dmark)  
5a20 32 a0 fd			ld (debug_mark),a  
5a23 3a 32 5a			ld a, (.dmark+1)  
5a26 32 a1 fd			ld (debug_mark+1),a  
5a29 3a 33 5a			ld a, (.dmark+2)  
5a2c 32 a2 fd			ld (debug_mark+2),a  
5a2f 18 03			jr .pastdmark  
5a31 ..			.dmark: db "REF"  
5a34 f1			.pastdmark: pop af  
5a35			endm  
# End of macro DMARK
5a35					CALLMONITOR 
5a35 cd aa fd			call debug_vector  
5a38				endm  
# End of macro CALLMONITOR
5a38				endif 
5a38				       NEXTW 
5a38 c3 38 24			jp macro_next 
5a3b				endm 
# End of macro NEXTW
5a3b			 
5a3b			;.showeof:   db "eof", 0 
5a3b			 
5a3b			 
5a3b			.EOF: 
5a3b				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5a3b 6d				db WORD_SYS_CORE+89             
5a3c 7d 5a			dw .FORMAT            
5a3e 04				db 3 + 1 
5a3f .. 00			db "EOF",0              
5a43				endm 
# End of macro CWHEAD
5a43			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5a43			; | | e.g. 
5a43			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5a43			; | | > [!NOTE] 
5a43			; | | > Compatible with PicoSPINet  
5a43					; TODO if current block id for stream is zero then push true else false 
5a43			 
5a43					if DEBUG_FORTH_WORDS_KEY 
5a43						DMARK "EOF" 
5a43 f5				push af  
5a44 3a 58 5a			ld a, (.dmark)  
5a47 32 a0 fd			ld (debug_mark),a  
5a4a 3a 59 5a			ld a, (.dmark+1)  
5a4d 32 a1 fd			ld (debug_mark+1),a  
5a50 3a 5a 5a			ld a, (.dmark+2)  
5a53 32 a2 fd			ld (debug_mark+2),a  
5a56 18 03			jr .pastdmark  
5a58 ..			.dmark: db "EOF"  
5a5b f1			.pastdmark: pop af  
5a5c			endm  
# End of macro DMARK
5a5c						CALLMONITOR 
5a5c cd aa fd			call debug_vector  
5a5f				endm  
# End of macro CALLMONITOR
5a5f					endif 
5a5f			 
5a5f					; TODO handlue multiple file streams 
5a5f			 
5a5f			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5a5f cd 68 5a				call .testeof 
5a62 cd 48 20				call forth_push_numhl 
5a65			 
5a65			 
5a65				       NEXTW 
5a65 c3 38 24			jp macro_next 
5a68				endm 
# End of macro NEXTW
5a68			 
5a68			.testeof: 
5a68 2e 01				ld l, 1 
5a6a 3a 9e f9				ld a, (store_openmaxext) 
5a6d fe 00				cp 0 
5a6f 28 09				jr  z, .eofdone   ; empty file 
5a71 3a 9f f9				ld a, (store_openext) 
5a74 fe 00				cp 0 
5a76 28 02				jr  z, .eofdone 
5a78 2e 00				ld l, 0 
5a7a 26 00		.eofdone:	ld h, 0 
5a7c c9					ret 
5a7d			 
5a7d			 
5a7d			 
5a7d			 
5a7d			.FORMAT: 
5a7d				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5a7d 6d				db WORD_SYS_CORE+89             
5a7e ce 5a			dw .LABEL            
5a80 07				db 6 + 1 
5a81 .. 00			db "FORMAT",0              
5a88				endm 
# End of macro CWHEAD
5a88			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5a88			; | | > [!NOTE] 
5a88			; | | > Compatible with PicoSPINet  
5a88					; TODO if current block id for stream is zero then push true else false 
5a88				 
5a88				if DEBUG_STORESE 
5a88					DMARK "FOR" 
5a88 f5				push af  
5a89 3a 9d 5a			ld a, (.dmark)  
5a8c 32 a0 fd			ld (debug_mark),a  
5a8f 3a 9e 5a			ld a, (.dmark+1)  
5a92 32 a1 fd			ld (debug_mark+1),a  
5a95 3a 9f 5a			ld a, (.dmark+2)  
5a98 32 a2 fd			ld (debug_mark+2),a  
5a9b 18 03			jr .pastdmark  
5a9d ..			.dmark: db "FOR"  
5aa0 f1			.pastdmark: pop af  
5aa1			endm  
# End of macro DMARK
5aa1					CALLMONITOR 
5aa1 cd aa fd			call debug_vector  
5aa4				endm  
# End of macro CALLMONITOR
5aa4				endif 
5aa4					; Wipes the bank check flags to cause a reformat on next block 0 read 
5aa4			 
5aa4 21 01 00				ld hl, 1 
5aa7 3e 00				ld a, 0 
5aa9 cd 79 02				call se_writebyte 
5aac			 
5aac				if DEBUG_STORESE 
5aac					DMARK "FO0" 
5aac f5				push af  
5aad 3a c1 5a			ld a, (.dmark)  
5ab0 32 a0 fd			ld (debug_mark),a  
5ab3 3a c2 5a			ld a, (.dmark+1)  
5ab6 32 a1 fd			ld (debug_mark+1),a  
5ab9 3a c3 5a			ld a, (.dmark+2)  
5abc 32 a2 fd			ld (debug_mark+2),a  
5abf 18 03			jr .pastdmark  
5ac1 ..			.dmark: db "FO0"  
5ac4 f1			.pastdmark: pop af  
5ac5			endm  
# End of macro DMARK
5ac5					CALLMONITOR 
5ac5 cd aa fd			call debug_vector  
5ac8				endm  
# End of macro CALLMONITOR
5ac8				endif 
5ac8					; force bank init 
5ac8			 
5ac8 cd 25 05				call storage_get_block_0 
5acb					 
5acb				       NEXTW 
5acb c3 38 24			jp macro_next 
5ace				endm 
# End of macro NEXTW
5ace			.LABEL: 
5ace				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5ace 6d				db WORD_SYS_CORE+89             
5acf 1c 5b			dw .STOREPAGE            
5ad1 06				db 5 + 1 
5ad2 .. 00			db "LABEL",0              
5ad8				endm 
# End of macro CWHEAD
5ad8			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5ad8			; | | > [!NOTE] 
5ad8			; | | > Compatible with PicoSPINet  
5ad8					; TODO test to see if bank is selected 
5ad8				 
5ad8					if DEBUG_FORTH_WORDS_KEY 
5ad8						DMARK "LBL" 
5ad8 f5				push af  
5ad9 3a ed 5a			ld a, (.dmark)  
5adc 32 a0 fd			ld (debug_mark),a  
5adf 3a ee 5a			ld a, (.dmark+1)  
5ae2 32 a1 fd			ld (debug_mark+1),a  
5ae5 3a ef 5a			ld a, (.dmark+2)  
5ae8 32 a2 fd			ld (debug_mark+2),a  
5aeb 18 03			jr .pastdmark  
5aed ..			.dmark: db "LBL"  
5af0 f1			.pastdmark: pop af  
5af1			endm  
# End of macro DMARK
5af1						CALLMONITOR 
5af1 cd aa fd			call debug_vector  
5af4				endm  
# End of macro CALLMONITOR
5af4					endif 
5af4			;	if DEBUG_STORESE 
5af4			;		DMARK "LBL" 
5af4			;		CALLMONITOR 
5af4			;	endif 
5af4					FORTH_DSP_VALUEHL 
5af4 cd 4d 22			call macro_dsp_valuehl 
5af7				endm 
# End of macro FORTH_DSP_VALUEHL
5af7					;v5FORTH_DSP_VALUE 
5af7					 
5af7			;		push hl 
5af7					FORTH_DSP_POP 
5af7 cd 05 23			call macro_forth_dsp_pop 
5afa				endm 
# End of macro FORTH_DSP_POP
5afa			;		pop hl 
5afa			 
5afa			;v5		inc hl   ; move past the type marker 
5afa			 
5afa				if DEBUG_STORESE 
5afa					DMARK "LBl" 
5afa f5				push af  
5afb 3a 0f 5b			ld a, (.dmark)  
5afe 32 a0 fd			ld (debug_mark),a  
5b01 3a 10 5b			ld a, (.dmark+1)  
5b04 32 a1 fd			ld (debug_mark+1),a  
5b07 3a 11 5b			ld a, (.dmark+2)  
5b0a 32 a2 fd			ld (debug_mark+2),a  
5b0d 18 03			jr .pastdmark  
5b0f ..			.dmark: db "LBl"  
5b12 f1			.pastdmark: pop af  
5b13			endm  
# End of macro DMARK
5b13					CALLMONITOR 
5b13 cd aa fd			call debug_vector  
5b16				endm  
# End of macro CALLMONITOR
5b16				endif 
5b16 cd 49 06				call storage_label 
5b19			 
5b19				       NEXTW 
5b19 c3 38 24			jp macro_next 
5b1c				endm 
# End of macro NEXTW
5b1c			.STOREPAGE: 
5b1c				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5b1c 6d				db WORD_SYS_CORE+89             
5b1d 4f 5b			dw .LABELS            
5b1f 0a				db 9 + 1 
5b20 .. 00			db "STOREPAGE",0              
5b2a				endm 
# End of macro CWHEAD
5b2a			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5b2a			; | | > [!NOTE] 
5b2a			; | | > Compatible with PicoSPINet  
5b2a					; TODO test to see if bank is selected 
5b2a				 
5b2a					if DEBUG_FORTH_WORDS_KEY 
5b2a						DMARK "STP" 
5b2a f5				push af  
5b2b 3a 3f 5b			ld a, (.dmark)  
5b2e 32 a0 fd			ld (debug_mark),a  
5b31 3a 40 5b			ld a, (.dmark+1)  
5b34 32 a1 fd			ld (debug_mark+1),a  
5b37 3a 41 5b			ld a, (.dmark+2)  
5b3a 32 a2 fd			ld (debug_mark+2),a  
5b3d 18 03			jr .pastdmark  
5b3f ..			.dmark: db "STP"  
5b42 f1			.pastdmark: pop af  
5b43			endm  
# End of macro DMARK
5b43						CALLMONITOR 
5b43 cd aa fd			call debug_vector  
5b46				endm  
# End of macro CALLMONITOR
5b46					endif 
5b46			;	if DEBUG_STORESE 
5b46			;		DMARK "STP" 
5b46			;		CALLMONITOR 
5b46			;	endif 
5b46			 
5b46 21 af f9			ld hl, store_page 
5b49 cd 48 20			call forth_push_numhl 
5b4c			 
5b4c			 
5b4c				       NEXTW 
5b4c c3 38 24			jp macro_next 
5b4f				endm 
# End of macro NEXTW
5b4f			.LABELS: 
5b4f				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5b4f 6d				db WORD_SYS_CORE+89             
5b50 d9 5b			dw .SCONST1            
5b52 07				db 6 + 1 
5b53 .. 00			db "LABELS",0              
5b5a				endm 
# End of macro CWHEAD
5b5a			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5b5a			; | | > [!CAUTION] 
5b5a			; | | > *NOT* Compatible with PicoSPINet  
5b5a					;  
5b5a			 
5b5a					; save the current device selected to restore afterwards 
5b5a				 
5b5a 3a 95 f9				ld a, (spi_device) 
5b5d f5					push af 
5b5e			 
5b5e			 
5b5e					; run through each of the banks 
5b5e			 
5b5e 21 01 00				ld hl, 1 
5b61 cd 48 20				call forth_push_numhl 
5b64 3e ff				ld a, SPI_CE_HIGH 
5b66 cb 87				res SPI_CE0, a 
5b68 32 95 f9				ld (spi_device), a 
5b6b cd 25 05				call storage_get_block_0 
5b6e 21 b2 f9				ld hl, store_page+3 
5b71 cd b6 20				call forth_push_str 
5b74			 
5b74					 
5b74 21 02 00				ld hl, 2 
5b77 cd 48 20				call forth_push_numhl 
5b7a 3e ff				ld a, SPI_CE_HIGH 
5b7c cb 8f				res SPI_CE1, a 
5b7e 32 95 f9				ld (spi_device), a 
5b81 cd 25 05				call storage_get_block_0 
5b84 21 b2 f9				ld hl, store_page+3 
5b87 cd b6 20				call forth_push_str 
5b8a			 
5b8a					 
5b8a 21 03 00				ld hl, 3 
5b8d cd 48 20				call forth_push_numhl 
5b90 3e ff				ld a, SPI_CE_HIGH 
5b92 cb 97				res SPI_CE2, a 
5b94 32 95 f9				ld (spi_device), a 
5b97 cd 25 05				call storage_get_block_0 
5b9a 21 b2 f9				ld hl, store_page+3 
5b9d cd b6 20				call forth_push_str 
5ba0			 
5ba0			 
5ba0 21 04 00				ld hl, 4 
5ba3 cd 48 20				call forth_push_numhl 
5ba6 3e ff				ld a, SPI_CE_HIGH 
5ba8 cb 9f				res SPI_CE3, a 
5baa 32 95 f9				ld (spi_device), a 
5bad cd 25 05				call storage_get_block_0 
5bb0 21 b2 f9				ld hl, store_page+3 
5bb3 cd b6 20				call forth_push_str 
5bb6			 
5bb6					 
5bb6			 
5bb6 21 05 00				ld hl, 5 
5bb9 cd 48 20				call forth_push_numhl 
5bbc 3e ff				ld a, SPI_CE_HIGH 
5bbe cb a7				res SPI_CE4, a 
5bc0 32 95 f9				ld (spi_device), a 
5bc3 cd 25 05				call storage_get_block_0 
5bc6 21 b2 f9				ld hl, store_page+3 
5bc9 cd b6 20				call forth_push_str 
5bcc			 
5bcc					 
5bcc					; push fixed count of storage devices (on board) for now 
5bcc			 
5bcc 21 05 00				ld hl, 5 
5bcf cd 48 20				call forth_push_numhl 
5bd2			 
5bd2					; restore selected device  
5bd2				 
5bd2 f1					pop af 
5bd3 32 95 f9				ld (spi_device), a 
5bd6			 
5bd6				       NEXTW 
5bd6 c3 38 24			jp macro_next 
5bd9				endm 
# End of macro NEXTW
5bd9			 
5bd9			.SCONST1: 
5bd9				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5bd9 6d				db WORD_SYS_CORE+89             
5bda f0 5b			dw .SCONST2            
5bdc 07				db 6 + 1 
5bdd .. 00			db "FILEID",0              
5be4				endm 
# End of macro CWHEAD
5be4			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5be4			; | | > [!NOTE] 
5be4			; | | > Compatible with PicoSPINet  
5be4 3a 9c f9				ld a, (store_filecache) 
5be7 26 00				ld h, 0 
5be9 6f					ld l, a 
5bea cd 48 20				call forth_push_numhl 
5bed					NEXTW 
5bed c3 38 24			jp macro_next 
5bf0				endm 
# End of macro NEXTW
5bf0			.SCONST2: 
5bf0				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5bf0 6d				db WORD_SYS_CORE+89             
5bf1 08 5c			dw .SCONST3            
5bf3 08				db 7 + 1 
5bf4 .. 00			db "FILEEXT",0              
5bfc				endm 
# End of macro CWHEAD
5bfc			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5bfc			; | | > [!NOTE] 
5bfc			; | | > Compatible with PicoSPINet  
5bfc 3a 9f f9				ld a, (store_openext) 
5bff 26 00				ld h, 0 
5c01 6f					ld l, a 
5c02 cd 48 20				call forth_push_numhl 
5c05					NEXTW 
5c05 c3 38 24			jp macro_next 
5c08				endm 
# End of macro NEXTW
5c08			.SCONST3: 
5c08				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5c08 6d				db WORD_SYS_CORE+89             
5c09 20 5c			dw .SCONST4            
5c0b 08				db 7 + 1 
5c0c .. 00			db "FILEMAX",0              
5c14				endm 
# End of macro CWHEAD
5c14			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5c14			; | | > [!NOTE] 
5c14			; | | > Compatible with PicoSPINet  
5c14 3a 9e f9				ld a, (store_openmaxext) 
5c17 26 00				ld h, 0 
5c19 6f					ld l, a 
5c1a cd 48 20				call forth_push_numhl 
5c1d					NEXTW 
5c1d c3 38 24			jp macro_next 
5c20				endm 
# End of macro NEXTW
5c20			.SCONST4: 
5c20				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5c20 6d				db WORD_SYS_CORE+89             
5c21 36 5c			dw .SCONST5            
5c23 09				db 8 + 1 
5c24 .. 00			db "FILEADDR",0              
5c2d				endm 
# End of macro CWHEAD
5c2d			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5c2d			; | | > [!NOTE] 
5c2d			; | | > Compatible with PicoSPINet  
5c2d 2a a0 f9				ld hl, (store_openaddr) 
5c30 cd 48 20				call forth_push_numhl 
5c33					NEXTW 
5c33 c3 38 24			jp macro_next 
5c36				endm 
# End of macro NEXTW
5c36			.SCONST5: 
5c36				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5c36 6d				db WORD_SYS_CORE+89             
5c37 57 5c			dw .SCONST6            
5c39 09				db 8 + 1 
5c3a .. 00			db "FILEPAGE",0              
5c43				endm 
# End of macro CWHEAD
5c43			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
5c43			; | | > [!NOTE] 
5c43			; | | > Compatible with PicoSPINet  
5c43 2a a0 f9				ld hl, (store_openaddr) 
5c46 e5					push hl 
5c47 c1					pop bc 
5c48 16 00				ld d, 0 
5c4a 1e 40				ld e, STORE_BLOCK_PHY 
5c4c cd 3b 0f				call Div16 
5c4f c5					push bc 
5c50 e1					pop hl 
5c51 cd 48 20				call forth_push_numhl 
5c54					NEXTW 
5c54 c3 38 24			jp macro_next 
5c57				endm 
# End of macro NEXTW
5c57			.SCONST6: 
5c57				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5c57 6d				db WORD_SYS_CORE+89             
5c58 70 5c			dw .ENDSTORAGE            
5c5a 09				db 8 + 1 
5c5b .. 00			db "READCONT",0              
5c64				endm 
# End of macro CWHEAD
5c64			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5c64			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5c64			; | | a further read should, if applicable, be CONCAT to the previous read. 
5c64			; | | > [!NOTE] 
5c64			; | | > Compatible with PicoSPINet  
5c64 3a a2 f9				ld a, (store_readcont) 
5c67 26 00				ld h, 0 
5c69 6f					ld l, a 
5c6a cd 48 20				call forth_push_numhl 
5c6d					NEXTW 
5c6d c3 38 24			jp macro_next 
5c70				endm 
# End of macro NEXTW
5c70			.ENDSTORAGE: 
5c70			; eof 
# End of file forth_words_storage.asm
5c70			endif 
5c70				include "forth_words_device.asm" 
5c70			; Device related words 
5c70			 
5c70			; | ## Device Words 
5c70			 
5c70			;if SOUND_ENABLE 
5c70			;.NOTE: 
5c70			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5c70			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
5c70			;		if DEBUG_FORTH_WORDS_KEY 
5c70			;			DMARK "NTE" 
5c70			;			CALLMONITOR 
5c70			;		endif 
5c70			; 
5c70			;	 
5c70			; 
5c70			;		NEXTW 
5c70			;.AFTERSOUND: 
5c70			;endif 
5c70			 
5c70			 
5c70			USE_GPIO: equ 0 
5c70			 
5c70			if USE_GPIO 
5c70			.GP1: 
5c70				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5c70			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
5c70					NEXTW 
5c70			.GP2: 
5c70				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5c70			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
5c70			 
5c70					NEXTW 
5c70			 
5c70			.GP3: 
5c70				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5c70			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
5c70			 
5c70					NEXTW 
5c70			 
5c70			.GP4: 
5c70				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5c70			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
5c70			 
5c70					NEXTW 
5c70			.SIN: 
5c70			 
5c70			 
5c70			endif 
5c70			 
5c70			 
5c70				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5c70 33				db WORD_SYS_CORE+31             
5c71 a5 5c			dw .SOUT            
5c73 03				db 2 + 1 
5c74 .. 00			db "IN",0              
5c77				endm 
# End of macro CWHEAD
5c77			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5c77					if DEBUG_FORTH_WORDS_KEY 
5c77						DMARK "IN." 
5c77 f5				push af  
5c78 3a 8c 5c			ld a, (.dmark)  
5c7b 32 a0 fd			ld (debug_mark),a  
5c7e 3a 8d 5c			ld a, (.dmark+1)  
5c81 32 a1 fd			ld (debug_mark+1),a  
5c84 3a 8e 5c			ld a, (.dmark+2)  
5c87 32 a2 fd			ld (debug_mark+2),a  
5c8a 18 03			jr .pastdmark  
5c8c ..			.dmark: db "IN."  
5c8f f1			.pastdmark: pop af  
5c90			endm  
# End of macro DMARK
5c90						CALLMONITOR 
5c90 cd aa fd			call debug_vector  
5c93				endm  
# End of macro CALLMONITOR
5c93					endif 
5c93					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c93 cd 4d 22			call macro_dsp_valuehl 
5c96				endm 
# End of macro FORTH_DSP_VALUEHL
5c96			 
5c96 e5					push hl 
5c97			 
5c97					; destroy value TOS 
5c97			 
5c97					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c97 cd 05 23			call macro_forth_dsp_pop 
5c9a				endm 
# End of macro FORTH_DSP_POP
5c9a			 
5c9a					; one value on hl get other one back 
5c9a			 
5c9a c1					pop bc 
5c9b			 
5c9b					; do the sub 
5c9b			;		ex de, hl 
5c9b			 
5c9b ed 68				in l,(c) 
5c9d			 
5c9d					; save it 
5c9d			 
5c9d 26 00				ld h,0 
5c9f			 
5c9f					; TODO push value back onto stack for another op etc 
5c9f			 
5c9f cd 48 20				call forth_push_numhl 
5ca2					NEXTW 
5ca2 c3 38 24			jp macro_next 
5ca5				endm 
# End of macro NEXTW
5ca5			.SOUT: 
5ca5				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5ca5 34				db WORD_SYS_CORE+32             
5ca6 f8 5c			dw .SPIO            
5ca8 04				db 3 + 1 
5ca9 .. 00			db "OUT",0              
5cad				endm 
# End of macro CWHEAD
5cad			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5cad					if DEBUG_FORTH_WORDS_KEY 
5cad						DMARK "OUT" 
5cad f5				push af  
5cae 3a c2 5c			ld a, (.dmark)  
5cb1 32 a0 fd			ld (debug_mark),a  
5cb4 3a c3 5c			ld a, (.dmark+1)  
5cb7 32 a1 fd			ld (debug_mark+1),a  
5cba 3a c4 5c			ld a, (.dmark+2)  
5cbd 32 a2 fd			ld (debug_mark+2),a  
5cc0 18 03			jr .pastdmark  
5cc2 ..			.dmark: db "OUT"  
5cc5 f1			.pastdmark: pop af  
5cc6			endm  
# End of macro DMARK
5cc6						CALLMONITOR 
5cc6 cd aa fd			call debug_vector  
5cc9				endm  
# End of macro CALLMONITOR
5cc9					endif 
5cc9			 
5cc9					; get port 
5cc9			 
5cc9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cc9 cd 4d 22			call macro_dsp_valuehl 
5ccc				endm 
# End of macro FORTH_DSP_VALUEHL
5ccc			 
5ccc e5					push hl 
5ccd			 
5ccd					; destroy value TOS 
5ccd			 
5ccd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ccd cd 05 23			call macro_forth_dsp_pop 
5cd0				endm 
# End of macro FORTH_DSP_POP
5cd0			 
5cd0					; get byte to send 
5cd0			 
5cd0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cd0 cd 4d 22			call macro_dsp_valuehl 
5cd3				endm 
# End of macro FORTH_DSP_VALUEHL
5cd3			 
5cd3			;		push hl 
5cd3			 
5cd3					; destroy value TOS 
5cd3			 
5cd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cd3 cd 05 23			call macro_forth_dsp_pop 
5cd6				endm 
# End of macro FORTH_DSP_POP
5cd6			 
5cd6					; one value on hl get other one back 
5cd6			 
5cd6			;		pop hl 
5cd6			 
5cd6 c1					pop bc 
5cd7			 
5cd7					if DEBUG_FORTH_WORDS 
5cd7						DMARK "OUT" 
5cd7 f5				push af  
5cd8 3a ec 5c			ld a, (.dmark)  
5cdb 32 a0 fd			ld (debug_mark),a  
5cde 3a ed 5c			ld a, (.dmark+1)  
5ce1 32 a1 fd			ld (debug_mark+1),a  
5ce4 3a ee 5c			ld a, (.dmark+2)  
5ce7 32 a2 fd			ld (debug_mark+2),a  
5cea 18 03			jr .pastdmark  
5cec ..			.dmark: db "OUT"  
5cef f1			.pastdmark: pop af  
5cf0			endm  
# End of macro DMARK
5cf0						CALLMONITOR 
5cf0 cd aa fd			call debug_vector  
5cf3				endm  
# End of macro CALLMONITOR
5cf3					endif 
5cf3			 
5cf3 ed 69				out (c), l 
5cf5			 
5cf5					NEXTW 
5cf5 c3 38 24			jp macro_next 
5cf8				endm 
# End of macro NEXTW
5cf8			 
5cf8			 
5cf8			.SPIO: 
5cf8			 
5cf8			if STORAGE_SE 
5cf8				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5cf8 51				db WORD_SYS_CORE+61             
5cf9 09 5d			dw .SPICEH            
5cfb 07				db 6 + 1 
5cfc .. 00			db "SPICEL",0              
5d03				endm 
# End of macro CWHEAD
5d03			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5d03			 
5d03 cd 22 02				call spi_ce_low 
5d06			    NEXTW 
5d06 c3 38 24			jp macro_next 
5d09				endm 
# End of macro NEXTW
5d09			 
5d09			.SPICEH: 
5d09				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5d09 51				db WORD_SYS_CORE+61             
5d0a 1a 5d			dw .SPIOb            
5d0c 07				db 6 + 1 
5d0d .. 00			db "SPICEH",0              
5d14				endm 
# End of macro CWHEAD
5d14			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5d14			 
5d14 cd 11 02				call spi_ce_high 
5d17			    NEXTW 
5d17 c3 38 24			jp macro_next 
5d1a				endm 
# End of macro NEXTW
5d1a			 
5d1a			 
5d1a			.SPIOb: 
5d1a			 
5d1a				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5d1a 51				db WORD_SYS_CORE+61             
5d1b 4c 5d			dw .SPII            
5d1d 05				db 4 + 1 
5d1e .. 00			db "SPIO",0              
5d23				endm 
# End of macro CWHEAD
5d23			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5d23			 
5d23					if DEBUG_FORTH_WORDS_KEY 
5d23						DMARK "SPo" 
5d23 f5				push af  
5d24 3a 38 5d			ld a, (.dmark)  
5d27 32 a0 fd			ld (debug_mark),a  
5d2a 3a 39 5d			ld a, (.dmark+1)  
5d2d 32 a1 fd			ld (debug_mark+1),a  
5d30 3a 3a 5d			ld a, (.dmark+2)  
5d33 32 a2 fd			ld (debug_mark+2),a  
5d36 18 03			jr .pastdmark  
5d38 ..			.dmark: db "SPo"  
5d3b f1			.pastdmark: pop af  
5d3c			endm  
# End of macro DMARK
5d3c						CALLMONITOR 
5d3c cd aa fd			call debug_vector  
5d3f				endm  
# End of macro CALLMONITOR
5d3f					endif 
5d3f					; get port 
5d3f			 
5d3f			 
5d3f					; get byte to send 
5d3f			 
5d3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d3f cd 4d 22			call macro_dsp_valuehl 
5d42				endm 
# End of macro FORTH_DSP_VALUEHL
5d42			 
5d42			;		push hl    ; u1  
5d42			 
5d42					; destroy value TOS 
5d42			 
5d42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d42 cd 05 23			call macro_forth_dsp_pop 
5d45				endm 
# End of macro FORTH_DSP_POP
5d45			 
5d45					; one value on hl get other one back 
5d45			 
5d45			;		pop hl   ; u2 - addr 
5d45			 
5d45					; TODO Send SPI byte 
5d45			 
5d45			;		push hl 
5d45			;		call spi_ce_low 
5d45			;		pop hl 
5d45 7d					ld a, l 
5d46 cd 10 01				call spi_send_byte 
5d49			;		call spi_ce_high 
5d49			 
5d49					NEXTW 
5d49 c3 38 24			jp macro_next 
5d4c				endm 
# End of macro NEXTW
5d4c			 
5d4c			.SPII: 
5d4c				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5d4c 52				db WORD_SYS_CORE+62             
5d4d b5 5d			dw .SESEL            
5d4f 06				db 5 + 1 
5d50 .. 00			db "SPII",0              
5d55				endm 
# End of macro CWHEAD
5d55			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5d55					if DEBUG_FORTH_WORDS_KEY 
5d55						DMARK "SPi" 
5d55 f5				push af  
5d56 3a 6a 5d			ld a, (.dmark)  
5d59 32 a0 fd			ld (debug_mark),a  
5d5c 3a 6b 5d			ld a, (.dmark+1)  
5d5f 32 a1 fd			ld (debug_mark+1),a  
5d62 3a 6c 5d			ld a, (.dmark+2)  
5d65 32 a2 fd			ld (debug_mark+2),a  
5d68 18 03			jr .pastdmark  
5d6a ..			.dmark: db "SPi"  
5d6d f1			.pastdmark: pop af  
5d6e			endm  
# End of macro DMARK
5d6e						CALLMONITOR 
5d6e cd aa fd			call debug_vector  
5d71				endm  
# End of macro CALLMONITOR
5d71					endif 
5d71			 
5d71					; TODO Get SPI byte 
5d71			 
5d71 cd 37 01				call spi_read_byte 
5d74			 
5d74					if DEBUG_FORTH_WORDS 
5d74						DMARK "Si2" 
5d74 f5				push af  
5d75 3a 89 5d			ld a, (.dmark)  
5d78 32 a0 fd			ld (debug_mark),a  
5d7b 3a 8a 5d			ld a, (.dmark+1)  
5d7e 32 a1 fd			ld (debug_mark+1),a  
5d81 3a 8b 5d			ld a, (.dmark+2)  
5d84 32 a2 fd			ld (debug_mark+2),a  
5d87 18 03			jr .pastdmark  
5d89 ..			.dmark: db "Si2"  
5d8c f1			.pastdmark: pop af  
5d8d			endm  
# End of macro DMARK
5d8d						CALLMONITOR 
5d8d cd aa fd			call debug_vector  
5d90				endm  
# End of macro CALLMONITOR
5d90					endif 
5d90 26 00				ld h, 0 
5d92 6f					ld l, a 
5d93					if DEBUG_FORTH_WORDS 
5d93						DMARK "Si3" 
5d93 f5				push af  
5d94 3a a8 5d			ld a, (.dmark)  
5d97 32 a0 fd			ld (debug_mark),a  
5d9a 3a a9 5d			ld a, (.dmark+1)  
5d9d 32 a1 fd			ld (debug_mark+1),a  
5da0 3a aa 5d			ld a, (.dmark+2)  
5da3 32 a2 fd			ld (debug_mark+2),a  
5da6 18 03			jr .pastdmark  
5da8 ..			.dmark: db "Si3"  
5dab f1			.pastdmark: pop af  
5dac			endm  
# End of macro DMARK
5dac						CALLMONITOR 
5dac cd aa fd			call debug_vector  
5daf				endm  
# End of macro CALLMONITOR
5daf					endif 
5daf cd 48 20				call forth_push_numhl 
5db2			 
5db2					NEXTW 
5db2 c3 38 24			jp macro_next 
5db5				endm 
# End of macro NEXTW
5db5			 
5db5			 
5db5			 
5db5			.SESEL: 
5db5				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5db5 66				db WORD_SYS_CORE+82             
5db6 5e 5e			dw .CARTDEV            
5db8 05				db 4 + 1 
5db9 .. 00			db "BANK",0              
5dbe				endm 
# End of macro CWHEAD
5dbe			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5dbe					if DEBUG_FORTH_WORDS_KEY 
5dbe						DMARK "BNK" 
5dbe f5				push af  
5dbf 3a d3 5d			ld a, (.dmark)  
5dc2 32 a0 fd			ld (debug_mark),a  
5dc5 3a d4 5d			ld a, (.dmark+1)  
5dc8 32 a1 fd			ld (debug_mark+1),a  
5dcb 3a d5 5d			ld a, (.dmark+2)  
5dce 32 a2 fd			ld (debug_mark+2),a  
5dd1 18 03			jr .pastdmark  
5dd3 ..			.dmark: db "BNK"  
5dd6 f1			.pastdmark: pop af  
5dd7			endm  
# End of macro DMARK
5dd7						CALLMONITOR 
5dd7 cd aa fd			call debug_vector  
5dda				endm  
# End of macro CALLMONITOR
5dda					endif 
5dda			 
5dda 3e ff				ld a, 255 
5ddc 32 98 f9				ld (spi_cartdev), a 
5ddf			 
5ddf					; get bank 
5ddf			 
5ddf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ddf cd 4d 22			call macro_dsp_valuehl 
5de2				endm 
# End of macro FORTH_DSP_VALUEHL
5de2			 
5de2			;		push hl 
5de2			 
5de2					; destroy value TOS 
5de2			 
5de2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5de2 cd 05 23			call macro_forth_dsp_pop 
5de5				endm 
# End of macro FORTH_DSP_POP
5de5			 
5de5					; one value on hl get other one back 
5de5			 
5de5			;		pop hl 
5de5			 
5de5			 
5de5 0e ff				ld c, SPI_CE_HIGH 
5de7 06 30				ld b, '0'    ; human readable bank number 
5de9			 
5de9 7d					ld a, l 
5dea			 
5dea					if DEBUG_FORTH_WORDS 
5dea						DMARK "BNK" 
5dea f5				push af  
5deb 3a ff 5d			ld a, (.dmark)  
5dee 32 a0 fd			ld (debug_mark),a  
5df1 3a 00 5e			ld a, (.dmark+1)  
5df4 32 a1 fd			ld (debug_mark+1),a  
5df7 3a 01 5e			ld a, (.dmark+2)  
5dfa 32 a2 fd			ld (debug_mark+2),a  
5dfd 18 03			jr .pastdmark  
5dff ..			.dmark: db "BNK"  
5e02 f1			.pastdmark: pop af  
5e03			endm  
# End of macro DMARK
5e03						CALLMONITOR 
5e03 cd aa fd			call debug_vector  
5e06				endm  
# End of macro CALLMONITOR
5e06					endif 
5e06			 
5e06					; active low 
5e06			 
5e06 fe 00				cp 0 
5e08 28 28				jr z, .bset 
5e0a fe 01				cp 1 
5e0c 20 04				jr nz, .b2 
5e0e cb 81				res 0, c 
5e10 06 31				ld b, '1'    ; human readable bank number 
5e12 fe 02		.b2:		cp 2 
5e14 20 04				jr nz, .b3 
5e16 cb 89				res 1, c 
5e18 06 32				ld b, '2'    ; human readable bank number 
5e1a fe 03		.b3:		cp 3 
5e1c 20 04				jr nz, .b4 
5e1e cb 91				res 2, c 
5e20 06 33				ld b, '3'    ; human readable bank number 
5e22 fe 04		.b4:		cp 4 
5e24 20 04				jr nz, .b5 
5e26 cb 99				res 3, c 
5e28 06 34				ld b, '4'    ; human readable bank number 
5e2a fe 05		.b5:		cp 5 
5e2c 20 04				jr nz, .bset 
5e2e cb a1				res 4, c 
5e30 06 35				ld b, '5'    ; human readable bank number 
5e32			 
5e32			.bset: 
5e32 79					ld a, c 
5e33 32 95 f9				ld (spi_device),a 
5e36 78					ld a, b 
5e37 32 94 f9				ld (spi_device_id),a 
5e3a					if DEBUG_FORTH_WORDS 
5e3a						DMARK "BN2" 
5e3a f5				push af  
5e3b 3a 4f 5e			ld a, (.dmark)  
5e3e 32 a0 fd			ld (debug_mark),a  
5e41 3a 50 5e			ld a, (.dmark+1)  
5e44 32 a1 fd			ld (debug_mark+1),a  
5e47 3a 51 5e			ld a, (.dmark+2)  
5e4a 32 a2 fd			ld (debug_mark+2),a  
5e4d 18 03			jr .pastdmark  
5e4f ..			.dmark: db "BN2"  
5e52 f1			.pastdmark: pop af  
5e53			endm  
# End of macro DMARK
5e53						CALLMONITOR 
5e53 cd aa fd			call debug_vector  
5e56				endm  
# End of macro CALLMONITOR
5e56					endif 
5e56			 
5e56					; set default SPI clk pulse time as disabled for BANK use 
5e56			 
5e56 3e 00				ld a, 0 
5e58 32 99 f9				ld (spi_clktime), a 
5e5b			 
5e5b					NEXTW 
5e5b c3 38 24			jp macro_next 
5e5e				endm 
# End of macro NEXTW
5e5e			 
5e5e			.CARTDEV: 
5e5e				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5e5e 66				db WORD_SYS_CORE+82             
5e5f 0c 5f			dw .ENDDEVICE            
5e61 08				db 7 + 1 
5e62 .. 00			db "CARTDEV",0              
5e6a				endm 
# End of macro CWHEAD
5e6a			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5e6a					if DEBUG_FORTH_WORDS_KEY 
5e6a						DMARK "CDV" 
5e6a f5				push af  
5e6b 3a 7f 5e			ld a, (.dmark)  
5e6e 32 a0 fd			ld (debug_mark),a  
5e71 3a 80 5e			ld a, (.dmark+1)  
5e74 32 a1 fd			ld (debug_mark+1),a  
5e77 3a 81 5e			ld a, (.dmark+2)  
5e7a 32 a2 fd			ld (debug_mark+2),a  
5e7d 18 03			jr .pastdmark  
5e7f ..			.dmark: db "CDV"  
5e82 f1			.pastdmark: pop af  
5e83			endm  
# End of macro DMARK
5e83						CALLMONITOR 
5e83 cd aa fd			call debug_vector  
5e86				endm  
# End of macro CALLMONITOR
5e86					endif 
5e86			 
5e86					; disable se storage bank selection 
5e86			 
5e86 3e ff				ld a, SPI_CE_HIGH		; ce high 
5e88 32 95 f9				ld (spi_device), a 
5e8b			 
5e8b					; get bank 
5e8b			 
5e8b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5e8b cd 4d 22			call macro_dsp_valuehl 
5e8e				endm 
# End of macro FORTH_DSP_VALUEHL
5e8e			 
5e8e			;		push hl 
5e8e			 
5e8e					; destroy value TOS 
5e8e			 
5e8e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5e8e cd 05 23			call macro_forth_dsp_pop 
5e91				endm 
# End of macro FORTH_DSP_POP
5e91			 
5e91					; one value on hl get other one back 
5e91			 
5e91			;		pop hl 
5e91			 
5e91					; active low 
5e91			 
5e91 0e ff				ld c, 255 
5e93			 
5e93 7d					ld a, l 
5e94					if DEBUG_FORTH_WORDS 
5e94						DMARK "CDV" 
5e94 f5				push af  
5e95 3a a9 5e			ld a, (.dmark)  
5e98 32 a0 fd			ld (debug_mark),a  
5e9b 3a aa 5e			ld a, (.dmark+1)  
5e9e 32 a1 fd			ld (debug_mark+1),a  
5ea1 3a ab 5e			ld a, (.dmark+2)  
5ea4 32 a2 fd			ld (debug_mark+2),a  
5ea7 18 03			jr .pastdmark  
5ea9 ..			.dmark: db "CDV"  
5eac f1			.pastdmark: pop af  
5ead			endm  
# End of macro DMARK
5ead						CALLMONITOR 
5ead cd aa fd			call debug_vector  
5eb0				endm  
# End of macro CALLMONITOR
5eb0					endif 
5eb0 fe 00				cp 0 
5eb2 28 30				jr z, .cset 
5eb4 fe 01				cp 1 
5eb6 20 02				jr nz, .c2 
5eb8 cb 81				res 0, c 
5eba fe 02		.c2:		cp 2 
5ebc 20 02				jr nz, .c3 
5ebe cb 89				res 1, c 
5ec0 fe 03		.c3:		cp 3 
5ec2 20 02				jr nz, .c4 
5ec4 cb 91				res 2, c 
5ec6 fe 04		.c4:		cp 4 
5ec8 20 02				jr nz, .c5 
5eca cb 99				res 3, c 
5ecc fe 05		.c5:		cp 5 
5ece 20 02				jr nz, .c6 
5ed0 cb a1				res 4, c 
5ed2 fe 06		.c6:		cp 6 
5ed4 20 02				jr nz, .c7 
5ed6 cb a9				res 5, c 
5ed8 fe 07		.c7:		cp 7 
5eda 20 02				jr nz, .c8 
5edc cb b1				res 6, c 
5ede fe 08		.c8:		cp 8 
5ee0 20 02				jr nz, .cset 
5ee2 cb b9				res 7, c 
5ee4 79			.cset:		ld a, c 
5ee5 32 98 f9				ld (spi_cartdev),a 
5ee8			 
5ee8					if DEBUG_FORTH_WORDS 
5ee8						DMARK "CD2" 
5ee8 f5				push af  
5ee9 3a fd 5e			ld a, (.dmark)  
5eec 32 a0 fd			ld (debug_mark),a  
5eef 3a fe 5e			ld a, (.dmark+1)  
5ef2 32 a1 fd			ld (debug_mark+1),a  
5ef5 3a ff 5e			ld a, (.dmark+2)  
5ef8 32 a2 fd			ld (debug_mark+2),a  
5efb 18 03			jr .pastdmark  
5efd ..			.dmark: db "CD2"  
5f00 f1			.pastdmark: pop af  
5f01			endm  
# End of macro DMARK
5f01						CALLMONITOR 
5f01 cd aa fd			call debug_vector  
5f04				endm  
# End of macro CALLMONITOR
5f04					endif 
5f04			 
5f04					; set default SPI clk pulse time as 10ms for CARTDEV use 
5f04			 
5f04 3e 0a				ld a, $0a 
5f06 32 99 f9				ld (spi_clktime), a 
5f09					NEXTW 
5f09 c3 38 24			jp macro_next 
5f0c				endm 
# End of macro NEXTW
5f0c			endif 
5f0c			 
5f0c			.ENDDEVICE: 
5f0c			; eof 
5f0c			 
# End of file forth_words_device.asm
5f0c			 
5f0c			; var handler 
5f0c			 
5f0c			 
5f0c			.VARS: 
5f0c				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5f0c 77				db WORD_SYS_CORE+99             
5f0d bd 5f			dw .V0            
5f0f 04				db 3 + 1 
5f10 .. 00			db "VAR",0              
5f14				endm 
# End of macro CWHEAD
5f14			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5f14			;| 
5f14			;| The variable name should consist of a single letter. e.g. "a" 
5f14			;! If a full string is passed then only the first char is looked at 
5f14			;| Any other char could exceed bounds checks!  
5f14			 
5f14					if DEBUG_FORTH_WORDS_KEY 
5f14						DMARK "VAR" 
5f14 f5				push af  
5f15 3a 29 5f			ld a, (.dmark)  
5f18 32 a0 fd			ld (debug_mark),a  
5f1b 3a 2a 5f			ld a, (.dmark+1)  
5f1e 32 a1 fd			ld (debug_mark+1),a  
5f21 3a 2b 5f			ld a, (.dmark+2)  
5f24 32 a2 fd			ld (debug_mark+2),a  
5f27 18 03			jr .pastdmark  
5f29 ..			.dmark: db "VAR"  
5f2c f1			.pastdmark: pop af  
5f2d			endm  
# End of macro DMARK
5f2d						CALLMONITOR 
5f2d cd aa fd			call debug_vector  
5f30				endm  
# End of macro CALLMONITOR
5f30					endif 
5f30			 
5f30					FORTH_DSP_VALUEHL 
5f30 cd 4d 22			call macro_dsp_valuehl 
5f33				endm 
# End of macro FORTH_DSP_VALUEHL
5f33			 
5f33 7e					ld a, (hl)    ; get first char on of the string 
5f34			 
5f34			 
5f34					if DEBUG_FORTH_WORDS 
5f34						DMARK "VR1" 
5f34 f5				push af  
5f35 3a 49 5f			ld a, (.dmark)  
5f38 32 a0 fd			ld (debug_mark),a  
5f3b 3a 4a 5f			ld a, (.dmark+1)  
5f3e 32 a1 fd			ld (debug_mark+1),a  
5f41 3a 4b 5f			ld a, (.dmark+2)  
5f44 32 a2 fd			ld (debug_mark+2),a  
5f47 18 03			jr .pastdmark  
5f49 ..			.dmark: db "VR1"  
5f4c f1			.pastdmark: pop af  
5f4d			endm  
# End of macro DMARK
5f4d						CALLMONITOR 
5f4d cd aa fd			call debug_vector  
5f50				endm  
# End of macro CALLMONITOR
5f50					endif 
5f50					 
5f50 f5					push af	 
5f51					FORTH_DSP_POP 
5f51 cd 05 23			call macro_forth_dsp_pop 
5f54				endm 
# End of macro FORTH_DSP_POP
5f54 f1					pop af 
5f55			 
5f55					; convert to upper 
5f55			 
5f55 cd 53 12				call to_upper 
5f58					if DEBUG_FORTH_WORDS 
5f58						DMARK "Vaa" 
5f58 f5				push af  
5f59 3a 6d 5f			ld a, (.dmark)  
5f5c 32 a0 fd			ld (debug_mark),a  
5f5f 3a 6e 5f			ld a, (.dmark+1)  
5f62 32 a1 fd			ld (debug_mark+1),a  
5f65 3a 6f 5f			ld a, (.dmark+2)  
5f68 32 a2 fd			ld (debug_mark+2),a  
5f6b 18 03			jr .pastdmark  
5f6d ..			.dmark: db "Vaa"  
5f70 f1			.pastdmark: pop af  
5f71			endm  
# End of macro DMARK
5f71						CALLMONITOR 
5f71 cd aa fd			call debug_vector  
5f74				endm  
# End of macro CALLMONITOR
5f74					endif 
5f74 06 41				ld b, 'A' 
5f76 90					sub b			; set offset 
5f77					if DEBUG_FORTH_WORDS 
5f77						DMARK "Vbb" 
5f77 f5				push af  
5f78 3a 8c 5f			ld a, (.dmark)  
5f7b 32 a0 fd			ld (debug_mark),a  
5f7e 3a 8d 5f			ld a, (.dmark+1)  
5f81 32 a1 fd			ld (debug_mark+1),a  
5f84 3a 8e 5f			ld a, (.dmark+2)  
5f87 32 a2 fd			ld (debug_mark+2),a  
5f8a 18 03			jr .pastdmark  
5f8c ..			.dmark: db "Vbb"  
5f8f f1			.pastdmark: pop af  
5f90			endm  
# End of macro DMARK
5f90						CALLMONITOR 
5f90 cd aa fd			call debug_vector  
5f93				endm  
# End of macro CALLMONITOR
5f93					endif 
5f93 cb 27				sla a  
5f95				 
5f95					 
5f95					if DEBUG_FORTH_WORDS 
5f95						DMARK "VR2" 
5f95 f5				push af  
5f96 3a aa 5f			ld a, (.dmark)  
5f99 32 a0 fd			ld (debug_mark),a  
5f9c 3a ab 5f			ld a, (.dmark+1)  
5f9f 32 a1 fd			ld (debug_mark+1),a  
5fa2 3a ac 5f			ld a, (.dmark+2)  
5fa5 32 a2 fd			ld (debug_mark+2),a  
5fa8 18 03			jr .pastdmark  
5faa ..			.dmark: db "VR2"  
5fad f1			.pastdmark: pop af  
5fae			endm  
# End of macro DMARK
5fae						CALLMONITOR 
5fae cd aa fd			call debug_vector  
5fb1				endm  
# End of macro CALLMONITOR
5fb1					endif 
5fb1			 
5fb1 21 29 f9				ld hl, cli_var_array2 
5fb4 cd de 0f				call addatohl 
5fb7 cd 48 20				call forth_push_numhl 
5fba			 
5fba			 
5fba				       NEXTW 
5fba c3 38 24			jp macro_next 
5fbd				endm 
# End of macro NEXTW
5fbd			.V0: 
5fbd				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5fbd 78				db WORD_SYS_CORE+100             
5fbe d5 5f			dw .V0Q            
5fc0 04				db 3 + 1 
5fc1 .. 00			db "V0!",0              
5fc5				endm 
# End of macro CWHEAD
5fc5			;| V0! ( u1 -- )  Store value to v0  | DONE 
5fc5			 
5fc5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5fc5 cd 4d 22			call macro_dsp_valuehl 
5fc8				endm 
# End of macro FORTH_DSP_VALUEHL
5fc8			 
5fc8 11 5d f9				ld de, cli_var_array 
5fcb			 
5fcb eb					ex de, hl 
5fcc 73					ld (hl), e 
5fcd 23					inc hl 
5fce 72					ld (hl), d 
5fcf			 
5fcf					; destroy value TOS 
5fcf			 
5fcf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5fcf cd 05 23			call macro_forth_dsp_pop 
5fd2				endm 
# End of macro FORTH_DSP_POP
5fd2			 
5fd2				       NEXTW 
5fd2 c3 38 24			jp macro_next 
5fd5				endm 
# End of macro NEXTW
5fd5			.V0Q: 
5fd5				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5fd5 79				db WORD_SYS_CORE+101             
5fd6 e6 5f			dw .V1S            
5fd8 04				db 3 + 1 
5fd9 .. 00			db "V0@",0              
5fdd				endm 
# End of macro CWHEAD
5fdd			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5fdd 2a 5d f9				ld hl, (cli_var_array) 
5fe0 cd 48 20				call forth_push_numhl 
5fe3			 
5fe3				       NEXTW 
5fe3 c3 38 24			jp macro_next 
5fe6				endm 
# End of macro NEXTW
5fe6			.V1S: 
5fe6				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5fe6 7a				db WORD_SYS_CORE+102             
5fe7 fe 5f			dw .V1Q            
5fe9 04				db 3 + 1 
5fea .. 00			db "V1!",0              
5fee				endm 
# End of macro CWHEAD
5fee			;| V1! ( u1 -- )  Store value to v1 | DONE 
5fee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5fee cd 4d 22			call macro_dsp_valuehl 
5ff1				endm 
# End of macro FORTH_DSP_VALUEHL
5ff1			 
5ff1 11 5f f9				ld de, cli_var_array+2 
5ff4				 
5ff4 eb					ex de, hl 
5ff5 73					ld (hl), e 
5ff6 23					inc hl 
5ff7 72					ld (hl), d 
5ff8			 
5ff8					; destroy value TOS 
5ff8			 
5ff8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ff8 cd 05 23			call macro_forth_dsp_pop 
5ffb				endm 
# End of macro FORTH_DSP_POP
5ffb				       NEXTW 
5ffb c3 38 24			jp macro_next 
5ffe				endm 
# End of macro NEXTW
5ffe			.V1Q: 
5ffe				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5ffe 7b				db WORD_SYS_CORE+103             
5fff 0f 60			dw .V2S            
6001 04				db 3 + 1 
6002 .. 00			db "V1@",0              
6006				endm 
# End of macro CWHEAD
6006			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
6006 2a 5f f9				ld hl, (cli_var_array+2) 
6009 cd 48 20				call forth_push_numhl 
600c				       NEXTW 
600c c3 38 24			jp macro_next 
600f				endm 
# End of macro NEXTW
600f			.V2S: 
600f				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
600f 7c				db WORD_SYS_CORE+104             
6010 27 60			dw .V2Q            
6012 04				db 3 + 1 
6013 .. 00			db "V2!",0              
6017				endm 
# End of macro CWHEAD
6017			;| V2! ( u1 -- )  Store value to v2 | DONE 
6017					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6017 cd 4d 22			call macro_dsp_valuehl 
601a				endm 
# End of macro FORTH_DSP_VALUEHL
601a			 
601a 11 61 f9				ld de, cli_var_array+4 
601d				 
601d eb					ex de, hl 
601e 73					ld (hl), e 
601f 23					inc hl 
6020 72					ld (hl), d 
6021			 
6021					; destroy value TOS 
6021			 
6021					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6021 cd 05 23			call macro_forth_dsp_pop 
6024				endm 
# End of macro FORTH_DSP_POP
6024				       NEXTW 
6024 c3 38 24			jp macro_next 
6027				endm 
# End of macro NEXTW
6027			.V2Q: 
6027				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
6027 7d				db WORD_SYS_CORE+105             
6028 38 60			dw .V3S            
602a 04				db 3 + 1 
602b .. 00			db "V2@",0              
602f				endm 
# End of macro CWHEAD
602f			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
602f 2a 61 f9				ld hl, (cli_var_array+4) 
6032 cd 48 20				call forth_push_numhl 
6035				       NEXTW 
6035 c3 38 24			jp macro_next 
6038				endm 
# End of macro NEXTW
6038			.V3S: 
6038				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
6038 7c				db WORD_SYS_CORE+104             
6039 50 60			dw .V3Q            
603b 04				db 3 + 1 
603c .. 00			db "V3!",0              
6040				endm 
# End of macro CWHEAD
6040			;| V3! ( u1 -- )  Store value to v3 | DONE 
6040					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6040 cd 4d 22			call macro_dsp_valuehl 
6043				endm 
# End of macro FORTH_DSP_VALUEHL
6043			 
6043 11 63 f9				ld de, cli_var_array+6 
6046				 
6046 eb					ex de, hl 
6047 73					ld (hl), e 
6048 23					inc hl 
6049 72					ld (hl), d 
604a			 
604a					; destroy value TOS 
604a			 
604a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
604a cd 05 23			call macro_forth_dsp_pop 
604d				endm 
# End of macro FORTH_DSP_POP
604d				       NEXTW 
604d c3 38 24			jp macro_next 
6050				endm 
# End of macro NEXTW
6050			.V3Q: 
6050				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
6050 7d				db WORD_SYS_CORE+105             
6051 61 60			dw .END            
6053 04				db 3 + 1 
6054 .. 00			db "V3@",0              
6058				endm 
# End of macro CWHEAD
6058			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
6058 2a 63 f9				ld hl, (cli_var_array+6) 
605b cd 48 20				call forth_push_numhl 
605e				       NEXTW 
605e c3 38 24			jp macro_next 
6061				endm 
# End of macro NEXTW
6061			 
6061			 
6061			 
6061			 
6061			 
6061			; end of dict marker 
6061			 
6061 00			.END:    db WORD_SYS_END 
6062 00 00			dw 0 
6064 00				db 0 
6065			 
6065			; use to jp here for user dict words to save on macro expansion  
6065			 
6065			user_dict_next: 
6065				NEXTW 
6065 c3 38 24			jp macro_next 
6068				endm 
# End of macro NEXTW
6068			 
6068			 
6068			user_exec: 
6068				;    ld hl, <word code> 
6068				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
6068				;    call forthexec 
6068				;    jp user_dict_next   (NEXT) 
6068			        ;    <word code bytes> 
6068 eb				ex de, hl 
6069 2a f7 f3			ld hl,(os_tok_ptr) 
606c				 
606c				FORTH_RSP_NEXT 
606c cd ef 1f			call macro_forth_rsp_next 
606f				endm 
# End of macro FORTH_RSP_NEXT
606f			 
606f			if DEBUG_FORTH_UWORD 
606f						DMARK "UEX" 
606f f5				push af  
6070 3a 84 60			ld a, (.dmark)  
6073 32 a0 fd			ld (debug_mark),a  
6076 3a 85 60			ld a, (.dmark+1)  
6079 32 a1 fd			ld (debug_mark+1),a  
607c 3a 86 60			ld a, (.dmark+2)  
607f 32 a2 fd			ld (debug_mark+2),a  
6082 18 03			jr .pastdmark  
6084 ..			.dmark: db "UEX"  
6087 f1			.pastdmark: pop af  
6088			endm  
# End of macro DMARK
6088				CALLMONITOR 
6088 cd aa fd			call debug_vector  
608b				endm  
# End of macro CALLMONITOR
608b			endif 
608b			 
608b			 
608b			 
608b eb				ex de, hl 
608c 22 f7 f3			ld (os_tok_ptr), hl 
608f				 
608f				; Don't use next - Skips the first word in uword. 
608f			 
608f c3 c1 24			jp exec1 
6092			;	NEXT 
6092			 
6092			 
6092			; eof 
# End of file forth_wordsv4.asm
6092			endif 
6092			;;;;;;;;;;;;;; Debug code 
6092			 
6092			 
6092			;if DEBUG_FORTH_PARSE 
6092 .. 00		.nowordfound: db "No match",0 
609b .. 00		.compword:	db "Comparing word ",0 
60ab .. 00		.nextwordat:	db "Next word at",0 
60b8 .. 00		.charmatch:	db "Char match",0 
60c3			;endif 
60c3			if DEBUG_FORTH_JP 
60c3			.foundword:	db "Word match. Exec..",0 
60c3			endif 
60c3			;if DEBUG_FORTH_PUSH 
60c3 .. 00		.enddict:	db "Dict end. Push.",0 
60d3 .. 00		.push_str:	db "Pushing string",0 
60e2 .. 00		.push_num:	db "Pushing number",0 
60f1 .. 00		.data_sp:	db "SP:",0 
60f5 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
6107 .. 00		.wordinde:	db "Word in DE (3/0):",0 
6119 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
612b			;endif 
612b			;if DEBUG_FORTH_MALLOC 
612b .. 00		.push_malloc:	db "Malloc address",0 
613a			;endif 
613a			 
613a			 
613a			 
613a			; display malloc address and current data stack pointer  
613a			 
613a			malloc_error: 
613a d5				push de 
613b f5				push af 
613c e5				push hl 
613d cd aa 0d			call clear_display 
6140 11 60 61			ld de, .mallocerr 
6143 3e 00			ld a,0 
6145			;	ld de,os_word_scratch 
6145 cd bd 0d			call str_at_display 
6148 3e 11			ld a, display_row_1+17 
614a 11 a0 fd			ld de, debug_mark 
614d cd bd 0d			call str_at_display 
6150 cd cd 0d			call update_display 
6153				;call break_point_state 
6153 cd 45 76			call cin_wait 
6156			 
6156			;	ld a, ' ' 
6156			;	ld (os_view_disable), a 
6156 cd 49 19			call bp_on 
6159 e1				pop hl 
615a f1				pop af 
615b d1				pop de	 
615c				CALLMONITOR 
615c cd aa fd			call debug_vector  
615f				endm  
# End of macro CALLMONITOR
615f c9				ret 
6160			 
6160 .. 00		.mallocerr: 	db "Malloc Error",0 
616d			;if DEBUG_FORTH_PUSH 
616d			display_data_sp: 
616d f5				push af 
616e			 
616e				; see if disabled 
616e			 
616e			 
616e 3a aa fd			ld a, (debug_vector) 
6171 fe c9			cp $C9  ; RET 
6173				;ld a, (os_view_disable) 
6173				;cp '*' 
6173 28 67			jr z, .skipdsp 
6175			 
6175 e5				push hl 
6176 e5				push hl 
6177 e5			push hl 
6178 cd aa 0d			call clear_display 
617b e1			pop hl 
617c 7c				ld a,h 
617d 21 fb f3			ld hl, os_word_scratch 
6180 cd e7 11			call hexout 
6183 e1				pop hl 
6184 7d				ld a,l 
6185 21 fd f3			ld hl, os_word_scratch+2 
6188 cd e7 11			call hexout 
618b 21 ff f3			ld hl, os_word_scratch+4 
618e 3e 00			ld a,0 
6190 77				ld (hl),a 
6191 11 fb f3			ld de,os_word_scratch 
6194 3e 28				ld a, display_row_2 
6196 cd bd 0d				call str_at_display 
6199 11 f5 60			ld de, .wordinhl 
619c 3e 00			ld a, display_row_1 
619e			 
619e cd bd 0d				call str_at_display 
61a1 11 a0 fd			ld de, debug_mark 
61a4 3e 11			ld a, display_row_1+17 
61a6			 
61a6 cd bd 0d				call str_at_display 
61a9			 
61a9				; display current data stack pointer 
61a9 11 f1 60			ld de,.data_sp 
61ac 3e 30				ld a, display_row_2 + 8 
61ae cd bd 0d				call str_at_display 
61b1			 
61b1 2a 23 f9			ld hl,(cli_data_sp) 
61b4 e5				push hl 
61b5 7c				ld a,h 
61b6 21 fb f3			ld hl, os_word_scratch 
61b9 cd e7 11			call hexout 
61bc e1				pop hl 
61bd 7d				ld a,l 
61be 21 fd f3			ld hl, os_word_scratch+2 
61c1 cd e7 11			call hexout 
61c4 21 ff f3			ld hl, os_word_scratch+4 
61c7 3e 00			ld a,0 
61c9 77				ld (hl),a 
61ca 11 fb f3			ld de,os_word_scratch 
61cd 3e 33				ld a, display_row_2 + 11 
61cf cd bd 0d				call str_at_display 
61d2			 
61d2			 
61d2 cd cd 0d			call update_display 
61d5 cd ed 0c			call delay1s 
61d8 cd ed 0c			call delay1s 
61db e1				pop hl 
61dc			.skipdsp: 
61dc f1				pop af 
61dd c9				ret 
61de			 
61de			display_data_malloc: 
61de			 
61de f5				push af 
61df e5				push hl 
61e0 e5				push hl 
61e1 e5			push hl 
61e2 cd aa 0d			call clear_display 
61e5 e1			pop hl 
61e6 7c				ld a,h 
61e7 21 fb f3			ld hl, os_word_scratch 
61ea cd e7 11			call hexout 
61ed e1				pop hl 
61ee 7d				ld a,l 
61ef 21 fd f3			ld hl, os_word_scratch+2 
61f2 cd e7 11			call hexout 
61f5 21 ff f3			ld hl, os_word_scratch+4 
61f8 3e 00			ld a,0 
61fa 77				ld (hl),a 
61fb 11 fb f3			ld de,os_word_scratch 
61fe 3e 28				ld a, display_row_2 
6200 cd bd 0d				call str_at_display 
6203 11 2b 61			ld de, .push_malloc 
6206 3e 00			ld a, display_row_1 
6208			 
6208 cd bd 0d				call str_at_display 
620b			 
620b				; display current data stack pointer 
620b 11 f1 60			ld de,.data_sp 
620e 3e 30				ld a, display_row_2 + 8 
6210 cd bd 0d				call str_at_display 
6213			 
6213 2a 23 f9			ld hl,(cli_data_sp) 
6216 e5				push hl 
6217 7c				ld a,h 
6218 21 fb f3			ld hl, os_word_scratch 
621b cd e7 11			call hexout 
621e e1				pop hl 
621f 7d				ld a,l 
6220 21 fd f3			ld hl, os_word_scratch+2 
6223 cd e7 11			call hexout 
6226 21 ff f3			ld hl, os_word_scratch+4 
6229 3e 00			ld a,0 
622b 77				ld (hl),a 
622c 11 fb f3			ld de,os_word_scratch 
622f 3e 33				ld a, display_row_2 + 11 
6231 cd bd 0d				call str_at_display 
6234			 
6234 cd cd 0d			call update_display 
6237 cd ed 0c			call delay1s 
623a cd ed 0c			call delay1s 
623d e1				pop hl 
623e f1				pop af 
623f c9				ret 
6240			;endif 
6240			 
6240			include "forth_autostart.asm" 
6240			; list of commands to perform at system start up 
6240			 
6240			startcmds: 
6240			;	dw test11 
6240			;	dw test12 
6240			;	dw test13 
6240			;	dw test14 
6240			;	dw test15 
6240			;	dw test16 
6240			;	dw test17 
6240			;	dw ifthtest1 
6240			;	dw ifthtest2 
6240			;	dw ifthtest3 
6240			;	dw mmtest1 
6240			;	dw mmtest2 
6240			;	dw mmtest3 
6240			;	dw mmtest4 
6240			;	dw mmtest5 
6240			;	dw mmtest6 
6240			;	dw iftest1 
6240			;	dw iftest2 
6240			;	dw iftest3 
6240			;	dw looptest1 
6240			;	dw looptest2 
6240			;	dw test1 
6240			;	dw test2 
6240			;	dw test3 
6240			;	dw test4 
6240			;	dw game2r 
6240			;	dw game2b1 
6240			;	dw game2b2 
6240			 
6240				; start up words that are actually useful 
6240			 
6240			;    dw spi1 
6240			;    dw spi2 
6240			;    dw spi3 
6240			;    dw spi4 
6240			;    dw spi5 
6240			;    dw spi6 
6240			;    dw spi7 
6240			; 
6240			;    dw spi8 
6240			;    dw spi9 
6240			;    dw spi10 
6240			 
6240			; file editor 
6240			;	dw edit1 
6240			;	dw edit2 
6240			;	dw edit3 
6240			 
6240			;	dw longread 
6240 62 66			dw clrstack 
6242 96 66			dw type 
6244			;	dw stest 
6244 bb 66			dw strncpy 
6246 2b 68			dw list 
6248 1c 67			dw start1 
624a 2c 67			dw start2 
624c			;	dw start3 
624c			;	dw start3b 
624c			;	dw start3c 
624c			 
624c				; (unit) testing words 
624c			 
624c			;	dw mtesta 
624c			;	dw mtestb 
624c			;	dw mtestc 
624c			;	dw mtestd 
624c			;	dw mteste 
624c			 
624c				; demo/game words 
624c			 
624c			;        dw game3w 
624c			;        dw game3p 
624c			;        dw game3sc 
624c			;        dw game3vsi 
624c			;        dw game3vs 
624c				 
624c			;	dw game2b 
624c			;	dw game2bf 
624c			;	dw game2mba 
624c			;	dw game2mbas 
624c			;	dw game2mb 
624c			 
624c 5c 6a			dw game1 
624e 6d 6a			dw game1a 
6250 cf 6a			dw game1b 
6252 04 6b			dw game1c 
6254 3a 6b			dw game1d 
6256 6b 6b			dw game1s 
6258 7f 6b			dw game1t 
625a 94 6b			dw game1f 
625c c8 6b			dw game1z 
625e 0c 6c			dw game1zz 
6260			 
6260 95 68			dw test5 
6262 cd 68			dw test6 
6264 05 69			dw test7 
6266 19 69			dw test8 
6268 45 69			dw test9 
626a 5b 69			dw test10 
626c				 
626c e3 6c		        dw ssv5 
626e c7 6c		        dw ssv4 
6270 ab 6c		        dw ssv3 
6272 75 6c		        dw ssv2 
6274 fc 6c		        dw ssv1 
6276 44 6d		        dw ssv1cpm 
6278			;	dw keyup 
6278			;	dw keydown 
6278			;	dw keyleft 
6278			;	dw keyright 
6278			;	dw 	keyf1 
6278			;	dw keyf2 
6278			;	dw keyf3 
6278			;	dw keyf4 
6278			;	dw keyf5 
6278			;	dw keyf6 
6278			;	dw keyf7 
6278			;	dw keyf8 
6278			;	dw keyf9 
6278			;	dw keyf10 
6278			;	dw keyf11 
6278			;	dw keyf12 
6278			;	dw keytab 
6278			;	dw keycr 
6278			;	dw keyhome 
6278			;	dw keyend 
6278			;	dw keybs 
6278 00 00			db 0, 0	 
627a			 
627a			 
627a			; File Editor 
627a			 
627a			; ( id - ) use 'e' to edit the displayed line 
627a .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
629b .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
62d0			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
62d0 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
6308			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
6308			 
6308			; SPI Net support words 
6308			 
6308			; v0! = node to send to 
6308			; ( str count - ) 
6308 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6361			 
6361			; spiputc ( char node - ) 
6361 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
6395			; spiputc ( u node - ) 
6395 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
63c3			 
63c3			; spigetc ( - n ) 
63c3 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
63ec			 
63ec			; getnode ( - n ) 
63ec .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
6419			 
6419			; ( str node - )  
6419 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
647f			; store string ( str i - ) 
647f			 
647f			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
647f .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
64d4			 
64d4			; get string ( addr i -  )    TO FIX 
64d4			 
64d4 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
652c			 
652c			 
652c			; NETCHAT (TODO) 
652c			; Program to allow two nodes to chat with eachother 
652c			; 
652c			; v0 - target node 
652c			;  
652c			; accept input at 0,0 
652c			; if input is string send spitype to target node 
652c			; starting at row 2,0 , while spigetchr is not zero ->  
652c			; 
652c			; 
652c			; TODO add paging of get request 
652c			 
652c			; ( node - ) 
652c .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
654b .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
65a3 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
661b			 
661b			 
661b			; Long read of currently open file 
661b .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6662			 
6662			; clear stack  
6662			 
6662 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
6696			 
6696			; type ( addr count - ) 
6696 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
66bb			 
66bb			; some direct memory words 
66bb			; strncpy ( len t f -- t ) 
66bb			 
66bb .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
671c			 
671c .. 00		start1:     	db ": bpon $00 bp ;",0 
672c .. 00		start2:     	db ": bpoff $01 bp ;",0 
673d .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
67b8 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6818			 
6818 .. 00		tuck:         db ": tuck swap over ;", 0 
682b			 
682b			; a handy word to list items on the stack 
682b			 
682b .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6895			 
6895			 
6895			; test stack  
6895			; rnd8 stest 
6895			 
6895			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6895			 
6895			; random malloc and free cycles 
6895			 
6895			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6895			 
6895			; fixed malloc and free cycles 
6895			 
6895			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6895			 
6895			; fixed double string push and drop cycle  
6895			 
6895			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6895			 
6895			; consistent fixed string push and drop cycle  
6895			 
6895			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6895			 
6895			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6895			 
6895			;test1:		db ": aa 1 2 3 ;", 0 
6895			;test2:     	db "111 aa 888 999",0 
6895			;test3:     	db ": bb 77 ;",0 
6895			;test4:     	db "$02 $01 do i . loop bb",0 
6895			 
6895 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
68cd .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6905 .. 00		test7:     	db ": box hline vline ;",0 
6919 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6945 .. 00		test9:     	db ": sw $01 adsp world ;",0 
695b .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6980			;test11:     	db "hello create .",0 
6980			;test12:     	db "hello2 create .",0 
6980			 
6980			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6980			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6980			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6980			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6980			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6980			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6980			 
6980			;iftest1:     	db "$0001 IF cls .",0 
6980			;iftest2:     	db "$0000 IF cls .",0 
6980			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6980			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6980			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6980			 
6980			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6980			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6980			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6980			 
6980			 
6980 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
69a4 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
69d4 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
69f9 .. 00		sound4: db ": cha $00 ; ",0 
6a06 .. 00		sound5: db ": chb $20 ; ",0 
6a13 .. 00		sound6: db ": chc $40 ; ",0 
6a20 .. 00		sound7: db ": chd $60 ; ",0 
6a2d .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6a45 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6a5c			 
6a5c			 
6a5c			 
6a5c			 
6a5c			; a small guess the number game 
6a5c			 
6a5c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6a6d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6acf			 
6acf .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6b04 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6b3a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6b6b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6b7f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6b94 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6bc8 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6c0c			 
6c0c			; Using 'ga' save a high score across multiple runs using external storage 
6c0c			 
6c0c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6c75			 
6c75			 
6c75			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6c75			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6c75			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6c75			 
6c75			; simple screen saver to test code memory reuse to destruction 
6c75			 
6c75 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6cab .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6cc7 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6ce3 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6cfc .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6d44 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6d9b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6d9b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6d9b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6d9b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6d9b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6d9b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6d9b			 
6d9b			 
6d9b			 
6d9b			; minesweeper/battleship finding game 
6d9b			; draws a game board of random ship/mine positions 
6d9b			; user enters coords to see if it hits on 
6d9b			; game ends when all are hit 
6d9b			; when hit or miss says how many may be in the area 
6d9b			 
6d9b			; setup the game board and then hide it 
6d9b			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6d9b			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6d9b			;; prompt for where to target 
6d9b			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6d9b			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6d9b			;; TODO see if the entered coords hits or misses pushes char hit of miss 
6d9b			;game2mbht:      db ": mbckht nop ;",0 
6d9b			;game2mbms:      db ": mbcms nop ;",0 
6d9b			; TODO how many might be near by 
6d9b			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6d9b			 
6d9b			; Game 3 
6d9b			 
6d9b			; Vert scroller ski game - avoid the trees! 
6d9b			 
6d9b			; v0 score (ie turns) 
6d9b			; v1 player pos 
6d9b			; v2 left wall 
6d9b			; v3 right wall 
6d9b			 
6d9b			; Draw side walls randomly 
6d9b			 
6d9b			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6d9b			 
6d9b			; Draw player 
6d9b			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6d9b			 
6d9b			; TODO Get Key 
6d9b			 
6d9b			; TODO Move left right 
6d9b			 
6d9b			; scroll and move walls a bit 
6d9b			 
6d9b			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6d9b			 
6d9b			; main game loop 
6d9b			 
6d9b			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6d9b			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6d9b			 
6d9b			; key board defs 
6d9b			 
6d9b .. 00		keyup:       db ": keyup $05 ;",0 
6da9 .. 00		keydown:       db ": keydown $0a ;",0 
6db9 .. 00		keyleft:       db ": keyleft $0b ;",0 
6dc9 .. 00		keyright:       db ": keyright $0c ;",0 
6dda .. 00		keyf1:       db ": keyf1 $10 ;",0 
6de8 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6df6 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6e04 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6e12 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6e20 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6e2e .. 00		keyf7:       db ": keyf7 $16 ;",0 
6e3c .. 00		keyf8:       db ": keyf8 $17 ;",0 
6e4a .. 00		keyf9:       db ": keyf9 $18 ;",0 
6e58 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6e67 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6e76 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6e85			 
6e85 .. 00		keytab:       db ": keytab $09 ;",0 
6e94 .. 00		keycr:       db ": keycr $0d ;",0 
6ea2 .. 00		keyhome:       db ": keyhome $0e ;",0 
6eb2 .. 00		keyend:       db ": keyend $0f ;",0 
6ec1 .. 00		keybs:       db ": keybs $08 ;",0 
6ecf			 
6ecf			   
6ecf			 
6ecf			 
6ecf			 
6ecf			; eof 
# End of file forth_autostart.asm
6ecf			 
6ecf			 
6ecf			 
6ecf			; stack over and underflow checks 
6ecf			 
6ecf			; init the words to detect the under/overflow 
6ecf			 
6ecf			chk_stk_init: 
6ecf				; a vague random number to check so we dont get any "lucky" hits 
6ecf 3e 2d			ld a, 45 
6ed1 6f				ld l, a 
6ed2 00				nop 
6ed3 3e 17			ld a, 23 
6ed5 67				ld h, a 
6ed6			 
6ed6 22 d2 f0			ld (chk_word), hl     ; the word we need to check against 
6ed9			 
6ed9			;	ld (chk_stund), hl	; stack points.... 
6ed9 22 3b fe			ld (chk_stovr), hl 
6edc 22 21 f9			ld (chk_ret_und), hl 
6edf 22 df f8			ld (chk_ret_ovr), hl 
6ee2 22 5d f8			ld (chk_loop_ovr), hl 
6ee5 22 5b f6			ld (chk_data_ovr), hl 
6ee8 c9				ret 
6ee9				 
6ee9			check_stacks: 
6ee9				; check all stack words 
6ee9			 
6ee9 e5				push hl 
6eea d5				push de 
6eeb			 
6eeb			;	ld de,(chk_word) 
6eeb			;	ld hl, (chk_stund)	; stack points.... 
6eeb			;	if DEBUG_STK_FAULT 
6eeb			;		DMARK "FAa" 
6eeb			;		CALLMONITOR 
6eeb			;	endif 
6eeb			;	call cmp16 
6eeb			;	jp z, .chk_faulta 
6eeb			; 
6eeb			;	ld de, sfaultsu 
6eeb			;	jp .chk_fault 
6eeb			 
6eeb 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
6eee ed 5b d2 f0		ld de,(chk_word) 
6ef2				if DEBUG_STK_FAULT 
6ef2					DMARK "FAb" 
6ef2					CALLMONITOR 
6ef2				endif 
6ef2 cd fc 0f			call cmp16 
6ef5 28 06			jr z, .chk_fault1 
6ef7 11 9b 6f			ld de, sfaultso 
6efa c3 4c 6f			jp .chk_fault 
6efd			.chk_fault1:  
6efd 2a 21 f9			ld hl, (chk_ret_und) 
6f00 ed 5b d2 f0		ld de,(chk_word) 
6f04				if DEBUG_STK_FAULT 
6f04					DMARK "FAU" 
6f04					CALLMONITOR 
6f04				endif 
6f04 cd fc 0f			call cmp16 
6f07 ca 10 6f			jp z, .chk_fault2 
6f0a 11 ab 6f			ld de, sfaultru 
6f0d c3 4c 6f			jp .chk_fault 
6f10			.chk_fault2:  
6f10 2a df f8			ld hl, (chk_ret_ovr) 
6f13 ed 5b d2 f0		ld de,(chk_word) 
6f17				if DEBUG_STK_FAULT 
6f17					DMARK "FA1" 
6f17					CALLMONITOR 
6f17				endif 
6f17 cd fc 0f			call cmp16 
6f1a ca 23 6f			jp z, .chk_fault3 
6f1d 11 b9 6f			ld de, sfaultro 
6f20 c3 4c 6f			jp .chk_fault 
6f23			.chk_fault3:  
6f23 2a 5d f8			ld hl, (chk_loop_ovr) 
6f26 ed 5b d2 f0		ld de,(chk_word) 
6f2a				if DEBUG_STK_FAULT 
6f2a					DMARK "FA2" 
6f2a					CALLMONITOR 
6f2a				endif 
6f2a cd fc 0f			call cmp16 
6f2d ca 36 6f			jp z, .chk_fault4 
6f30 11 d3 6f			ld de, sfaultlo 
6f33 c3 4c 6f			jp .chk_fault 
6f36			.chk_fault4:  
6f36 2a 5b f6			ld hl, (chk_data_ovr) 
6f39 ed 5b d2 f0		ld de,(chk_word) 
6f3d				if DEBUG_STK_FAULT 
6f3d					DMARK "FA3" 
6f3d					CALLMONITOR 
6f3d				endif 
6f3d cd fc 0f			call cmp16 
6f40 ca 49 6f			jp z, .chk_fault5 
6f43 11 ed 6f			ld de, sfaultdo 
6f46 c3 4c 6f			jp .chk_fault 
6f49			 
6f49			 
6f49			.chk_fault5:  
6f49 d1				pop de 
6f4a e1				pop hl 
6f4b			 
6f4b c9				ret 
6f4c			 
6f4c cd aa 0d		.chk_fault: 	call clear_display 
6f4f 3e 28				ld a, display_row_2 
6f51 cd bd 0d				call str_at_display 
6f54 11 7d 6f				   ld de, .stackfault 
6f57 3e 00				ld a, display_row_1 
6f59 cd bd 0d				call str_at_display 
6f5c 11 a0 fd				    ld de, debug_mark 
6f5f 3e 11				ld a, display_row_1+17 
6f61 cd bd 0d				call str_at_display 
6f64 cd cd 0d				call update_display 
6f67			 
6f67				; prompt before entering montior for investigating issue 
6f67			 
6f67 3e 78			ld a, display_row_4 
6f69 11 26 1d			ld de, endprog 
6f6c			 
6f6c cd cd 0d			call update_display		 
6f6f			 
6f6f cd c0 1f			call next_page_prompt 
6f72			 
6f72 d1				pop de 
6f73 e1				pop hl 
6f74 cd 7a 1d				call monitor 
6f77 cd de 23				call forth_warmstart 
6f7a c3 76 1c				jp warmstart_afterauto 
6f7d					;jp 0 
6f7d					;halt 
6f7d			 
6f7d			 
6f7d			 
6f7d .. 00		.stackfault: 	db "Stack fault:",0 
6f8a			 
6f8a .. 00		sfaultsu: 	db	"Stack under flow",0 
6f9b .. 00		sfaultso: 	db	"Stack over flow",0 
6fab .. 00		sfaultru:	db "RTS underflow",0 
6fb9 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6fd3 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6fed .. 00		sfaultdo:	db "DTS overflow", 0 
6ffa			 
6ffa			 
6ffa			fault_dsp_under: 
6ffa 11 0c 70			ld de, .dsp_under 
6ffd c3 c2 70			jp .show_fault 
7000			 
7000			fault_rsp_under: 
7000 11 1a 70			ld de, .rsp_under 
7003 c3 c2 70			jp .show_fault 
7006			fault_loop_under: 
7006 11 28 70			ld de, .loop_under 
7009 c3 c2 70			jp .show_fault 
700c			 
700c .. 00		.dsp_under: db "DSP Underflow",0 
701a .. 00		.rsp_under: db "RSP Underflow",0 
7028 .. 00		.loop_under: db "LOOP Underflow",0 
7037			 
7037			 
7037 d5			type_faultn: 	push de 
7038 e5					push hl 
7039 cd aa 0d				call clear_display 
703c 11 66 70				   ld de, .typefaultn 
703f 3e 00				ld a, display_row_1 
7041 cd bd 0d				call str_at_display 
7044 11 a0 fd				    ld de, debug_mark 
7047 3e 11				ld a, display_row_1+17 
7049 cd bd 0d				call str_at_display 
704c cd cd 0d				call update_display 
704f			 
704f				; prompt before entering montior for investigating issue 
704f			 
704f 3e 78			ld a, display_row_4 
7051 11 26 1d			ld de, endprog 
7054			 
7054 cd cd 0d			call update_display		 
7057			 
7057 cd c0 1f			call next_page_prompt 
705a			 
705a e5					push hl 
705b d5					push de 
705c cd 7a 1d				call monitor 
705f cd de 23				call forth_warmstart 
7062 c3 76 1c				jp warmstart_afterauto 
7065 76					halt 
7066			 
7066			 
7066 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
707d			 
707d d5			type_faults: 	push de 
707e e5					push hl 
707f cd aa 0d				call clear_display 
7082 11 ab 70				   ld de, .typefaults 
7085 3e 00				ld a, display_row_1 
7087 cd bd 0d				call str_at_display 
708a 11 a0 fd				    ld de, debug_mark 
708d 3e 11				ld a, display_row_1+17 
708f cd bd 0d				call str_at_display 
7092 cd cd 0d				call update_display 
7095			 
7095				; prompt before entering montior for investigating issue 
7095			 
7095 3e 78			ld a, display_row_4 
7097 11 26 1d			ld de, endprog 
709a			 
709a cd cd 0d			call update_display		 
709d			 
709d cd c0 1f			call next_page_prompt 
70a0			 
70a0 e1					pop hl 
70a1 d1					pop de 
70a2 cd 7a 1d				call monitor 
70a5 cd de 23				call forth_warmstart 
70a8 c3 76 1c				jp warmstart_afterauto 
70ab			 
70ab			 
70ab .. 00		.typefaults: db "STR Type Expected TOS!",0 
70c2			 
70c2			.show_fault: 	 
70c2 d5					push de 
70c3 cd aa 0d				call clear_display 
70c6 d1					pop de 
70c7 3e 00				ld a, display_row_1 
70c9 cd bd 0d				call str_at_display 
70cc 11 a0 fd				    ld de, debug_mark 
70cf 3e 11				ld a, display_row_1+17 
70d1 cd bd 0d				call str_at_display 
70d4 cd cd 0d				call update_display 
70d7			 
70d7				; prompt before entering montior for investigating issue 
70d7			 
70d7 3e 78			ld a, display_row_4 
70d9 11 26 1d			ld de, endprog 
70dc			 
70dc cd cd 0d			call update_display		 
70df			 
70df cd c0 1f			call next_page_prompt 
70e2			 
70e2 e1					pop hl 
70e3 d1					pop de 
70e4 cd 7a 1d				call monitor 
70e7			; do a dump to cli and not warmstart so we preserve all of the uwords.  
70e7			; TODO Make optional fault restart to cli or warm boot? 
70e7					;jp warmstart 
70e7 c3 ba 1c				jp cli 
70ea 76					halt 
70eb			 
70eb			 
70eb			; handle the auto run of code from files in storage 
70eb			 
70eb			 
70eb			include "forth_startup.asm" 
70eb			; Which startup method to use? 
70eb			; 
70eb			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
70eb			; followed by loading of a list of scripts in eeprom 
70eb			 
70eb			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
70eb			; from eeprom 
70eb			 
70eb			; Select with define in main stubs 
70eb			 
70eb			if STARTUP_V1 
70eb				include "forth_startupv1.asm" 
70eb			endif 
70eb			if STARTUP_V2 
70eb				include "forth_startupv2.asm" 
70eb			; Version 2 of the startup  
70eb			;  
70eb			; Auto load any files in bank 1 that start with a '*' 
70eb			; If no se storage then revert to using eprom 
70eb			 
70eb			 
70eb			if STORAGE_SE = 0 
70eb			 
70eb			sprompt1: db "Startup load...",0 
70eb			sprompt2: db "Run? 1=No *=End #=All",0 
70eb			 
70eb			 
70eb			 
70eb			 
70eb			forth_startup: 
70eb				ld hl, startcmds 
70eb				ld a, 0 
70eb				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
70eb			 
70eb			.start1:	push hl 
70eb				call clear_display 
70eb				ld de, sprompt1 
70eb			        ld a, display_row_1 
70eb				call str_at_display 
70eb				ld de, sprompt2 
70eb			        ld a, display_row_2 
70eb				call str_at_display 
70eb				pop hl 
70eb				push hl 
70eb				ld e,(hl) 
70eb				inc hl 
70eb				ld d,(hl) 
70eb			        ld a, display_row_3 
70eb				call str_at_display 
70eb				call update_display 
70eb			 
70eb			 
70eb				ld a, (os_last_cmd) 
70eb				cp 0 
70eb				jr z, .startprompt 
70eb				call delay250ms 
70eb				jr .startdo 
70eb				 
70eb				 
70eb			 
70eb			.startprompt: 
70eb			 
70eb				ld a,display_row_4 + display_cols - 1 
70eb			        ld de, endprg 
70eb				call str_at_display 
70eb				call update_display 
70eb				call delay1s 
70eb				call cin_wait 
70eb						 
70eb				cp '*' 
70eb				jr z, .startupend1 
70eb				cp '#' 
70eb				jr nz, .startno 
70eb				ld a, 1 
70eb				ld (os_last_cmd),a 
70eb				jr .startdo 
70eb			.startno:	cp '1' 
70eb				jr z,.startnxt  
70eb			 
70eb				; exec startup line 
70eb			.startdo:	 
70eb				pop hl 
70eb				push hl 
70eb				 
70eb				ld e,(hl) 
70eb				inc hl 
70eb				ld d,(hl) 
70eb				ex de,hl 
70eb			 
70eb				push hl 
70eb			 
70eb				ld a, 0 
70eb				;ld a, FORTH_END_BUFFER 
70eb				call strlent 
70eb				inc hl   ; include zero term to copy 
70eb				ld b,0 
70eb				ld c,l 
70eb				pop hl 
70eb				ld de, scratch 
70eb				ldir 
70eb			 
70eb			 
70eb				ld hl, scratch 
70eb				call forthparse 
70eb				call forthexec 
70eb				call forthexec_cleanup 
70eb			 
70eb				ld a, display_row_4 
70eb				ld de, endprog 
70eb			 
70eb				call update_display		 
70eb			 
70eb				ld a, (os_last_cmd) 
70eb				cp 0 
70eb				jr nz, .startnxt 
70eb				call next_page_prompt 
70eb			        call clear_display 
70eb				call update_display		 
70eb			 
70eb				; move onto next startup line? 
70eb			.startnxt: 
70eb			 
70eb				call delay250ms 
70eb				pop hl 
70eb			 
70eb				inc hl 
70eb				inc hl 
70eb			 
70eb				push hl 
70eb				ld e, (hl) 
70eb				inc hl 
70eb				ld d, (hl) 
70eb				pop hl 
70eb				; TODO replace 0 test 
70eb			 
70eb				ex de, hl 
70eb				call ishlzero 
70eb			;	ld a,e 
70eb			;	add d 
70eb			;	cp 0    ; any left to do? 
70eb				ex de, hl 
70eb				jp nz, .start1 
70eb				jr .startupend 
70eb			 
70eb			.startupend1: pop hl 
70eb			.startupend: 
70eb			 
70eb				call clear_display 
70eb				call update_display 
70eb				ret 
70eb			endif 
70eb			 
70eb			 
70eb			if STORAGE_SE 
70eb			 
70eb			;sprompt3: db "Loading from start-up file:",0 
70eb .. 00		sprompt3: db "  Searching...",0 
70fa			;sprompt4: db "(Any key to stop)",0 
70fa			 
70fa			 
70fa			forth_autoload: 
70fa			 
70fa				; load block 0 of store 1 
70fa				 
70fa 3e fe			ld a, $fe      ; bit 0 clear 
70fc 32 95 f9			ld (spi_device), a 
70ff			 
70ff cd 25 05			call storage_get_block_0 
7102			 
7102 3a d0 f9			ld a, (store_page+STORE_0_AUTOFILE) 
7105			 
7105 fe 00			cp 0 
7107 c8				ret z     ; auto start not enabled 
7108			 
7108 cd aa 0d			call clear_display 
710b			 
710b				; set bank 
710b			 
710b 3a d2 f9				ld a, (store_page+STORE_0_BANKRUN) 
710e 32 95 f9				ld (spi_device), a 
7111			 
7111			 
7111				; generate a directory of bank 1 and search for flagged files 
7111			 
7111					if DEBUG_FORTH_WORDS_KEY 
7111						DMARK "DIR" 
7111 f5				push af  
7112 3a 26 71			ld a, (.dmark)  
7115 32 a0 fd			ld (debug_mark),a  
7118 3a 27 71			ld a, (.dmark+1)  
711b 32 a1 fd			ld (debug_mark+1),a  
711e 3a 28 71			ld a, (.dmark+2)  
7121 32 a2 fd			ld (debug_mark+2),a  
7124 18 03			jr .pastdmark  
7126 ..			.dmark: db "DIR"  
7129 f1			.pastdmark: pop af  
712a			endm  
# End of macro DMARK
712a						CALLMONITOR 
712a cd aa fd			call debug_vector  
712d				endm  
# End of macro CALLMONITOR
712d					endif 
712d			 
712d cd 25 05			call storage_get_block_0 
7130			 
7130 21 af f9			ld hl, store_page     ; get current id count 
7133 46				ld b, (hl) 
7134 0e 00			ld c, 0    ; count of files   
7136					if DEBUG_FORTH_WORDS 
7136						DMARK "DI1" 
7136 f5				push af  
7137 3a 4b 71			ld a, (.dmark)  
713a 32 a0 fd			ld (debug_mark),a  
713d 3a 4c 71			ld a, (.dmark+1)  
7140 32 a1 fd			ld (debug_mark+1),a  
7143 3a 4d 71			ld a, (.dmark+2)  
7146 32 a2 fd			ld (debug_mark+2),a  
7149 18 03			jr .pastdmark  
714b ..			.dmark: db "DI1"  
714e f1			.pastdmark: pop af  
714f			endm  
# End of macro DMARK
714f						CALLMONITOR 
714f cd aa fd			call debug_vector  
7152				endm  
# End of macro CALLMONITOR
7152					endif 
7152			 
7152				; check for empty drive 
7152			 
7152 3e 00			ld a, 0 
7154 b8				cp b 
7155 ca a2 71			jp z, .dirdone 
7158			 
7158				; for each of the current ids do a search for them and if found push to stack 
7158			 
7158 c5			.diritem:	push bc 
7159 21 40 00				ld hl, STORE_BLOCK_PHY 
715c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
715e 58					ld e,b 
715f			 
715f d5					push de 
7160 e5					push hl 
7161 cd aa 0d			call clear_display 
7164 3e 32			ld a, display_row_2 + 10 
7166 11 eb 70			ld de, sprompt3 
7169 cd bd 0d			call str_at_display 
716c cd 01 0d			call active 
716f eb				ex de, hl 
7170 3e 2f			ld a, display_row_2 + 7 
7172 cd bd 0d			call str_at_display 
7175 cd cd 0d			call update_display 
7178 e1				pop hl 
7179 d1				pop de 
717a			 
717a			;		if DEBUG_FORTH_WORDS 
717a			;			DMARK "DI2" 
717a			;			CALLMONITOR 
717a			;		endif 
717a			 
717a cd a7 07				call storage_findnextid 
717d			 
717d			;		if DEBUG_FORTH_WORDS 
717d			;			DMARK "DI3" 
717d			;			CALLMONITOR 
717d			;		endif 
717d			 
717d					; if found hl will be non zero 
717d			 
717d cd 07 10				call ishlzero 
7180			;		ld a, l 
7180			;		add h 
7180			; 
7180			;		cp 0 
7180 28 1d				jr z, .dirnotfound 
7182			 
7182					; increase count 
7182			 
7182 c1					pop bc	 
7183 0c					inc c 
7184 c5					push bc 
7185					 
7185			 
7185					; get file header and push the file name 
7185			 
7185 11 af f9				ld de, store_page 
7188 cd 74 04				call storage_read_block 
718b			 
718b					; push file id to stack 
718b				 
718b			 
718b					; is this a file we want to run? 
718b			 
718b 21 b2 f9				ld hl, store_page+3 
718e 7e					ld a,(hl) 
718f fe 2a				cp '*' 
7191 20 0c				jr nz,  .dirnotfound 
7193					 
7193			 
7193			 
7193 3a af f9				ld a, (store_page) 
7196 d5					push de 
7197 e5					push hl 
7198 c5					push bc 
7199 cd c5 71				call .autorunf 
719c c1					pop bc 
719d e1					pop hl 
719e d1					pop de 
719f			 
719f			 
719f			 
719f				; save this extent 
719f			 
719f					; push file name 
719f			;display file name to run 
719f			 
719f			;		ld hl, store_page+3 
719f			;		if DEBUG_FORTH_WORDS 
719f			;			DMARK "DI5" 
719f			;			CALLMONITOR 
719f			;		endif 
719f			; 
719f			;		 
719f			; 
719f			;		call forth_push_str 
719f			;		if DEBUG_FORTH_WORDS 
719f			;			DMARK "DI6" 
719f			;			CALLMONITOR 
719f			;		endif 
719f			.dirnotfound: 
719f c1					pop bc     
71a0 10 b6				djnz .diritem 
71a2				 
71a2			.dirdone:	 
71a2					if DEBUG_FORTH_WORDS 
71a2						DMARK "DI7" 
71a2 f5				push af  
71a3 3a b7 71			ld a, (.dmark)  
71a6 32 a0 fd			ld (debug_mark),a  
71a9 3a b8 71			ld a, (.dmark+1)  
71ac 32 a1 fd			ld (debug_mark+1),a  
71af 3a b9 71			ld a, (.dmark+2)  
71b2 32 a2 fd			ld (debug_mark+2),a  
71b5 18 03			jr .pastdmark  
71b7 ..			.dmark: db "DI7"  
71ba f1			.pastdmark: pop af  
71bb			endm  
# End of macro DMARK
71bb						CALLMONITOR 
71bb cd aa fd			call debug_vector  
71be				endm  
# End of macro CALLMONITOR
71be					endif 
71be			 
71be cd aa 0d				call clear_display 
71c1 cd cd 0d				call update_display 
71c4			 
71c4 c9					ret 
71c5			 
71c5			 
71c5			 
71c5			 
71c5			 
71c5			.autorunf: 
71c5			 
71c5			 
71c5				; get file id to load from and get the file name to display 
71c5			 
71c5			;		ld a, (store_page+STORE_0_FILERUN) 
71c5			 
71c5 2e 00				ld l, 0 
71c7 67					ld h, a 
71c8 11 af f9				ld de, store_page 
71cb			 
71cb					if DEBUG_FORTH_WORDS 
71cb						DMARK "ASp" 
71cb f5				push af  
71cc 3a e0 71			ld a, (.dmark)  
71cf 32 a0 fd			ld (debug_mark),a  
71d2 3a e1 71			ld a, (.dmark+1)  
71d5 32 a1 fd			ld (debug_mark+1),a  
71d8 3a e2 71			ld a, (.dmark+2)  
71db 32 a2 fd			ld (debug_mark+2),a  
71de 18 03			jr .pastdmark  
71e0 ..			.dmark: db "ASp"  
71e3 f1			.pastdmark: pop af  
71e4			endm  
# End of macro DMARK
71e4						CALLMONITOR 
71e4 cd aa fd			call debug_vector  
71e7				endm  
# End of macro CALLMONITOR
71e7					endif 
71e7 cd cd 09				call storage_read 
71ea			 
71ea					if DEBUG_FORTH_WORDS 
71ea						DMARK "ASr" 
71ea f5				push af  
71eb 3a ff 71			ld a, (.dmark)  
71ee 32 a0 fd			ld (debug_mark),a  
71f1 3a 00 72			ld a, (.dmark+1)  
71f4 32 a1 fd			ld (debug_mark+1),a  
71f7 3a 01 72			ld a, (.dmark+2)  
71fa 32 a2 fd			ld (debug_mark+2),a  
71fd 18 03			jr .pastdmark  
71ff ..			.dmark: db "ASr"  
7202 f1			.pastdmark: pop af  
7203			endm  
# End of macro DMARK
7203						CALLMONITOR 
7203 cd aa fd			call debug_vector  
7206				endm  
# End of macro CALLMONITOR
7206					endif 
7206			 
7206 cd 07 10				call ishlzero 
7209 c8					ret z             ; file not found 
720a			 
720a					; display file name we are loading 
720a			 
720a cd aa 0d				call clear_display 
720d			 
720d 3e 32				ld a, display_row_2 + 10 
720f 11 b2 f9				ld de, store_page+3 
7212 cd bd 0d				call str_at_display 
7215				 
7215			; 
7215			 
7215			;	ld a, display_row_1+5 
7215			;	ld de, sprompt3 
7215			;	call str_at_display 
7215			;	ld a, display_row_2+7 
7215			;	call active 
7215			;	ex de, hl 
7215			;;	ld de, sprompt4 
7215			;	call str_at_display 
7215			; 
7215 cd cd 0d			call update_display 
7218			 
7218			;	call cin_wait 
7218			;	cp 'n' 
7218			;	ret z 
7218			;	cp 'N' 
7218			;	ret z 
7218			 
7218			;	call delay1s 
7218			 
7218 3a b1 f9			ld a, (store_page+2) 
721b 32 9e f9			ld (store_openmaxext), a    ; save count of ext 
721e 3e 01			ld a, 1  
7220 32 9f f9			ld (store_openext), a    ; save count of ext 
7223			 
7223			.autof: 
7223				; begin to read a line from file 
7223			 
7223 21 1d f4			ld hl, os_cli_cmd 
7226 22 1b f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
7229			  
7229			.readext: 
7229 3a 9f f9			ld a, (store_openext) 
722c 6f				ld l , a 
722d				 
722d 3a af f9			ld a, (store_page) 
7230 67				ld h, a	 
7231 11 af f9			ld de, store_page 
7234					if DEBUG_FORTH_WORDS 
7234						DMARK "ASl" 
7234 f5				push af  
7235 3a 49 72			ld a, (.dmark)  
7238 32 a0 fd			ld (debug_mark),a  
723b 3a 4a 72			ld a, (.dmark+1)  
723e 32 a1 fd			ld (debug_mark+1),a  
7241 3a 4b 72			ld a, (.dmark+2)  
7244 32 a2 fd			ld (debug_mark+2),a  
7247 18 03			jr .pastdmark  
7249 ..			.dmark: db "ASl"  
724c f1			.pastdmark: pop af  
724d			endm  
# End of macro DMARK
724d						CALLMONITOR 
724d cd aa fd			call debug_vector  
7250				endm  
# End of macro CALLMONITOR
7250					endif 
7250 cd cd 09				call storage_read 
7253 cd 07 10			call ishlzero 
7256 c8				ret z 
7257			 
7257			; TODO copy to exec buffer 
7257			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7257			 
7257				; copy the record buffer to the cli buffer 
7257			 
7257 ed 5b 1b f6		ld de, (os_var_array) 
725b 21 b1 f9			ld hl, store_page+2 
725e			;	ex de, hl 
725e 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
7261 ed b0			ldir 
7263 ed 53 1b f6		ld (os_var_array), de 
7267				 
7267 3a 9f f9			ld a, (store_openext) 
726a 3c				inc a 
726b 32 9f f9			ld (store_openext), a    ; save count of ext 
726e			 
726e			 
726e			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
726e				 
726e 3a a2 f9			ld a, (store_readcont) 
7271 fe 00			cp 0 
7273 20 b4			jr nz, .readext 
7275			 
7275			;	jr z, .autoend 
7275			 
7275					if DEBUG_FORTH_WORDS 
7275						DMARK "ASc" 
7275 f5				push af  
7276 3a 8a 72			ld a, (.dmark)  
7279 32 a0 fd			ld (debug_mark),a  
727c 3a 8b 72			ld a, (.dmark+1)  
727f 32 a1 fd			ld (debug_mark+1),a  
7282 3a 8c 72			ld a, (.dmark+2)  
7285 32 a2 fd			ld (debug_mark+2),a  
7288 18 03			jr .pastdmark  
728a ..			.dmark: db "ASc"  
728d f1			.pastdmark: pop af  
728e			endm  
# End of macro DMARK
728e						CALLMONITOR 
728e cd aa fd			call debug_vector  
7291				endm  
# End of macro CALLMONITOR
7291					endif 
7291 e5				push hl	 
7292 d5				push de 
7293 cd 01 0d			call active 
7296 eb				ex de, hl 
7297 3e 2f			ld a, display_row_2 + 7 
7299 cd bd 0d			call str_at_display 
729c			 
729c cd cd 0d			call update_display 
729f d1				pop de  
72a0 e1				pop hl 
72a1			;	call delay250ms 
72a1			 
72a1			 
72a1			 
72a1			 
72a1			.autoexec: 
72a1			 
72a1			 
72a1 21 1d f4			ld hl, os_cli_cmd 
72a4					if DEBUG_FORTH_WORDS 
72a4						DMARK "ASx" 
72a4 f5				push af  
72a5 3a b9 72			ld a, (.dmark)  
72a8 32 a0 fd			ld (debug_mark),a  
72ab 3a ba 72			ld a, (.dmark+1)  
72ae 32 a1 fd			ld (debug_mark+1),a  
72b1 3a bb 72			ld a, (.dmark+2)  
72b4 32 a2 fd			ld (debug_mark+2),a  
72b7 18 03			jr .pastdmark  
72b9 ..			.dmark: db "ASx"  
72bc f1			.pastdmark: pop af  
72bd			endm  
# End of macro DMARK
72bd						CALLMONITOR 
72bd cd aa fd			call debug_vector  
72c0				endm  
# End of macro CALLMONITOR
72c0					endif 
72c0 cd 82 24			call forthparse 
72c3 cd be 24			call forthexec 
72c6 cd d8 23			call forthexec_cleanup 
72c9			 
72c9			 
72c9			 
72c9 c3 23 72			jp .autof 
72cc			;.autofdone: 
72cc			; 
72cc			;		if DEBUG_FORTH_WORDS 
72cc			;			DMARK "ASx" 
72cc			;			CALLMONITOR 
72cc			;		endif 
72cc			;;	call clear_display 
72cc			;	ret 
72cc			 
72cc			 
72cc			 
72cc			endif 
# End of file forth_startupv2.asm
72cc			endif 
72cc			 
# End of file forth_startup.asm
72cc			 
72cc			; eof 
# End of file forth_kernel.asm
72cc			;include "nascombasic.asm" 
72cc			 
72cc			 
72cc			; find out where the code ends if loaded into RAM (for SC114) 
72cc			;endofcode:  
72cc			;	nop 
72cc			 
72cc			 
72cc			; jump to nmi vector 
72cc			 
72cc			init_nmi: 
72cc 3e c9			ld a, $c9   ; RET 
72ce 32 ad fd			ld (nmi_vector), a 
72d1 c9				ret 
72d2			nmi: 
72d2 e5				push hl 
72d3 d5				push de 
72d4 c5				push bc 
72d5 f5				push af 
72d6 cd ad fd			call nmi_vector 
72d9 f5				push af 
72da c5				push bc 
72db d5				push de 
72dc e5				push hl 
72dd ed 4d			reti 
72df			 
72df			 
72df			; eof 
72df			 
# End of file main.asm
72df			include "firmware_lcd_4x40.asm" 
72df			; **********************************************************************  
72df			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
72df			; **********************************************************************  
72df			;  
72df			; **  Written as a Small Computer Monitor App  
72df			; **  www.scc.me.uk  
72df			;  
72df			; History  
72df			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
72df			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
72df			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
72df			;  
72df			; **********************************************************************  
72df			;  
72df			; This program is an example of one of the methods of interfacing an   
72df			; alphanumeric LCD module.   
72df			;  
72df			; In this example the display is connected to either a Z80 PIO or a   
72df			; simple 8-bit output port.   
72df			;  
72df			; This interfacing method uses 4-bit data mode and uses time delays  
72df			; rather than polling the display's ready status. As a result the   
72df			; interface only requires 6 simple output lines:  
72df			;   Output bit 0 = not used  
72df			;   Output bit 1 = not used  
72df			;   Output bit 2 = RS         High = data, Low = instruction  
72df			;   Output bit 3 = E          Active high  
72df			;   Output bit 4 = DB4  
72df			;   Output bit 5 = DB5  
72df			;   Output bit 6 = DB6  
72df			;   Output bit 7 = DB7  
72df			; Display's R/W is connected to 0v so it is always in write mode  
72df			;  
72df			; This set up should work with any system supporting the RC2014 bus  
72df			  
72df			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
72df			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
72df			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
72df			;  
72df			; **********************************************************************  
72df			  
72df			; Additonal for 4x40. E1 and E2 instead of just E   
72df			; TODO swipe vidout signal on port a to activate E2  
72df			  
72df			; **********************************************************************  
72df			; **  Constants  
72df			; **********************************************************************  
72df			; LCD constants required by LCD support module  
72df			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
72df			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
72df			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
72df			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
72df			; TODO Decide which E is being set  
72df			kLCDWidth:  EQU display_cols             ;Width in characters  
72df			  
72df			; **********************************************************************  
72df			; **  Code library usage  
72df			; **********************************************************************  
72df			  
72df			; send character to current cursor position  
72df			; wraps and/or scrolls screen automatically  
72df			  
72df			  
72df			  
72df			lcd_init:  
72df			  
72df			; SCMonAPI functions used  
72df			  
72df			; Alphanumeric LCD functions used  
72df			; no need to specify specific functions for this module  
72df			  
72df 3e cf		            LD   A, 11001111b  
72e1 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
72e3 3e 00		            LD   A, 00000000b  
72e5 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
72e7			  
72e7			; Initialise alphanumeric LCD module  
72e7 3e 00				ld a, 0  
72e9 32 00 fb				ld (display_lcde1e2), a  
72ec cd 6d 73		            CALL fLCD_Init      ;Initialise LCD module  
72ef 3e 01				ld a, 1  
72f1 32 00 fb				ld (display_lcde1e2), a  
72f4 cd 6d 73		            CALL fLCD_Init      ;Initialise LCD module  
72f7			  
72f7 c9				ret  
72f8			  
72f8			;  
72f8			;;  
72f8			; lcd functions  
72f8			;  
72f8			;  
72f8			  
72f8			; what is at cursor position   
72f8			  
72f8			;get_cursor:	ld de, (cursor_row)   ;  row + col  
72f8			;		call curptr  
72f8			;		ret  
72f8			  
72f8			  
72f8			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
72f8			  
72f8			curptr:  
72f8 c5				push bc  
72f9 21 e6 fc			ld hl, display_fb0  
72fc			cpr:	  
72fc				; loop for cursor whole row  
72fc 0e 28			ld c, display_cols  
72fe 23			cpr1:	inc hl  
72ff 0d				dec c  
7300 20 fc			jr nz, cpr1  
7302 05				dec b  
7303 20 f7			jr nz, cpr  
7305			  
7305				; add col	  
7305			  
7305 23			cpr2:	inc hl  
7306 1d				dec e  
7307 20 fc			jr nz, cpr2  
7309			  
7309 c1				pop bc  
730a c9				ret  
730b				  
730b			  
730b			  
730b			  
730b			  
730b			; write the frame buffer given in hl to hardware   
730b 22 fe fa		write_display: ld (display_write_tmp), hl 	   
730e 3e 00			ld a, kLCD_Line1  
7310 cd 1a 74		            CALL fLCD_Pos       ;Position cursor to location in A  
7313 06 28			ld b, display_cols  
7315 ed 5b fe fa		ld de, (display_write_tmp)  
7319 cd 65 73			call write_len_string  
731c				  
731c				  
731c 2a fe fa			ld hl, (display_write_tmp)  
731f 11 28 00			ld de, display_cols  
7322 19				add hl,de  
7323 22 fe fa			ld (display_write_tmp),hl  
7326			  
7326				  
7326 3e 28			ld a, kLCD_Line2  
7328 cd 1a 74		            CALL fLCD_Pos       ;Position cursor to location in A  
732b 06 28			ld b, display_cols  
732d ed 5b fe fa		ld de, (display_write_tmp)  
7331 cd 65 73			call write_len_string  
7334				  
7334 2a fe fa			ld hl, (display_write_tmp)  
7337 11 28 00			ld de, display_cols  
733a 19				add hl,de  
733b 22 fe fa			ld (display_write_tmp),hl  
733e			  
733e				  
733e 3e 50			ld a, kLCD_Line3  
7340 cd 1a 74		            CALL fLCD_Pos       ;Position cursor to location in A  
7343 06 28			ld b, display_cols  
7345 ed 5b fe fa		ld de, (display_write_tmp)  
7349 cd 65 73			call write_len_string  
734c				  
734c 2a fe fa			ld hl, (display_write_tmp)  
734f 11 28 00			ld de, display_cols  
7352 19				add hl,de  
7353 22 fe fa			ld (display_write_tmp),hl  
7356			  
7356				  
7356 3e 78			ld a, kLCD_Line4  
7358 cd 1a 74		            CALL fLCD_Pos       ;Position cursor to location in A  
735b 06 28			ld b, display_cols  
735d ed 5b fe fa		ld de, (display_write_tmp)  
7361 cd 65 73			call write_len_string  
7364 c9					ret  
7365				  
7365				; write out a fixed length string given in b from de  
7365			  
7365 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
7366 cd d2 73		            CALL fLCD_Data      ;Write character to display  
7369 13				inc de  
736a 10 f9			djnz write_len_string  
736c c9				ret  
736d			  
736d			; Some other things to do  
736d			;            LD   A, kLCD_Clear ;Display clear  
736d			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
736d			;            LD   A, kLCD_Under ;Display on with underscore cursor  
736d			;            LD   A, kLCD_On     ;Display on with no cursor  
736d			;            ;LD   A, kLCD_Off   ;Display off  
736d			;            CALL fLCD_Inst      ;Send instruction to display  
736d			;  
736d			;  
736d			;            halt  
736d			;  
736d			;  
736d			;MsgHello:   DB  "Hello World!",0  
736d			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
736d			  
736d			; Custom characters 5 pixels wide by 8 pixels high  
736d			; Up to 8 custom characters can be defined  
736d			;BitMaps:      
736d			;; Character 0x00 = Battery icon  
736d			;            DB  01110b  
736d			;            DB  11011b  
736d			;            DB  10001b  
736d			;            DB  10001b  
736d			;            DB  11111b  
736d			;            DB  11111b  
736d			;            DB  11111b  
736d			;            DB  11111b  
736d			;; Character 0x01 = Bluetooth icon  
736d			;            DB  01100b  
736d			;            DB  01010b  
736d			;            DB  11100b  
736d			;            DB  01000b  
736d			;            DB  11100b  
736d			;            DB  01010b  
736d			;            DB  01100b  
736d			;            DB  00000b  
736d			;  
736d			  
736d			  
736d			; **********************************************************************  
736d			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
736d			; **********************************************************************  
736d			;  
736d			; **  Written as a Small Computer Monitor App   
736d			; **  Version 0.1 SCC 2018-05-16  
736d			; **  www.scc.me.uk  
736d			;  
736d			; **********************************************************************  
736d			;  
736d			; This module provides support for alphanumeric LCD modules using with  
736d			; *  HD44780 (or compatible) controller  
736d			; *  5 x 7 pixel fonts  
736d			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
736d			; *  Interface via six digital outputs to the display (see below)  
736d			;  
736d			; LCD module pinout:  
736d			;   1  Vss   0v supply  
736d			;   2  Vdd   5v supply  
736d			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
736d			;   4  RS    High = data, Low = instruction  
736d			;   5  R/W   High = Read, Low = Write  
736d			;   6  E     Enable signal (active high)  
736d			;   7  DB0   Data bit 0  
736d			;   8  DB1   Data bit 1  
736d			;   9  DB2   Data bit 2  
736d			;  10  DB3   Data bit 3  
736d			;  11  DB4   Data bit 4  
736d			;  12  DB5   Data bit 5  
736d			;  13  DB6   Data bit 6  
736d			;  14  DB7   Data bit 7  
736d			;  15  A     Backlight anode (+)  
736d			;  16  K     Backlight cathode (-)  
736d			;  
736d			; This interfacing method uses 4-bit data mode and uses time delays  
736d			; rather than polling the display's ready status. As a result the   
736d			; interface only requires 6 simple output lines:  
736d			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
736d			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
736d			;   LCD DB4 = Microcomputer output port bit 4  
736d			;   LCD DB5 = Microcomputer output port bit 5  
736d			;   LCD DB6 = Microcomputer output port bit 6  
736d			;   LCD DB7 = Microcomputer output port bit 7  
736d			; Display's R/W is connected to 0v so it is always in write mode  
736d			; All 6 connections must be on the same port address <kLCDPrt>  
736d			; This method also allows a decent length of cable from micro to LCD  
736d			;  
736d			; **********************************************************************  
736d			;  
736d			; To include the code for any given function provided by this module,   
736d			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
736d			; the parent source file.  
736d			; For example:  #REQUIRES   uHexPrefix  
736d			;  
736d			; Also #INCLUDE this file at some point after the #REQUIRES statements  
736d			; in the parent source file.  
736d			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
736d			;  
736d			; These are the function names provided by this module:  
736d			; fLCD_Init                     ;Initialise LCD  
736d			; fLCD_Inst                     ;Send instruction to LCD  
736d			; fLCD_Data                     ;Send data byte to LCD  
736d			; fLCD_Pos                      ;Position cursor  
736d			; fLCD_Str                      ;Display string  
736d			; fLCD_Def                      ;Define custom character  
736d			;  
736d			; **********************************************************************  
736d			;  
736d			; Requires SCMonAPI.asm to also be included in the project  
736d			;  
736d			  
736d			  
736d			; **********************************************************************  
736d			; **  Constants  
736d			; **********************************************************************  
736d			  
736d			; Constants that must be defined externally  
736d			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
736d			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
736d			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
736d			;kLCDWidth: EQU 20             ;Width in characters  
736d			  
736d			; general line offsets in any frame buffer  
736d			  
736d			  
736d			display_row_1: equ 0  
736d			display_row_2: equ display_row_1+display_cols  
736d			display_row_3: equ display_row_2 + display_cols  
736d			display_row_4: equ display_row_3 + display_cols  
736d			;display_row_4_eol:   
736d			  
736d			  
736d			; Cursor position values for the start of each line  
736d			  
736d			; E  
736d			kLCD_Line1: EQU 0x00   
736d			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
736d			; E1  
736d			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
736d			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
736d			  
736d			; Instructions to send as A register to fLCD_Inst  
736d			kLCD_Clear: EQU 00000001b     ;LCD clear  
736d			kLCD_Off:   EQU 00001000b     ;LCD off  
736d			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
736d			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
736d			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
736d			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
736d			  
736d			; Constants used by this code module  
736d			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
736d			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
736d			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
736d			  
736d			  
736d			  
736d			; **********************************************************************  
736d			; **  LCD support functions  
736d			; **********************************************************************  
736d			  
736d			; Initialise alphanumeric LCD module  
736d			; LCD control register codes:  
736d			;   DL   0 = 4-bit mode        1 = 8-bit mode  
736d			;   N    0 = 1-line mode       1 = 2-line mode  
736d			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
736d			;   D    0 = Display off       1 = Display on  
736d			;   C    0 = Cursor off        1 = Cursor on  
736d			;   B    0 = Blinking off      1 = Blinking on  
736d			;   ID   0 = Decrement mode    1 = Increment mode  
736d			;   SH   0 = Entire shift off  1 = Entire shift on  
736d 3e 28		fLCD_Init:  LD   A, 40  
736f cd 94 74		            CALL LCDDelay       ;Delay 40ms after power up  
7372			; For reliable reset set 8-bit mode - 3 times  
7372 cd 64 74		            CALL WrFn8bit       ;Function = 8-bit mode  
7375 cd 64 74		            CALL WrFn8bit       ;Function = 8-bit mode  
7378 cd 64 74		            CALL WrFn8bit       ;Function = 8-bit mode  
737b			; Set 4-bit mode  
737b cd 60 74		            CALL WrFn4bit       ;Function = 4-bit mode  
737e cd 92 74		            CALL LCDDelay1      ;Delay 37 us or more  
7381			; Function set  
7381 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7383 cd 96 73		            CALL fLCD_Inst      ;2 line, display on  
7386			; Display On/Off control  
7386 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7388 cd 96 73		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
738b			; Display Clear  
738b 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
738d cd 96 73		            CALL fLCD_Inst      ;Clear display  
7390			; Entry mode  
7390 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7392 cd 96 73		            CALL fLCD_Inst      ;Increment mode, shift off  
7395			; Display module now initialised  
7395 c9			            RET  
7396			; ok to here  
7396			  
7396			; Write instruction to LCD  
7396			;   On entry: A = Instruction byte to be written  
7396			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7396 f5			fLCD_Inst:  PUSH AF  
7397 f5			            PUSH AF  
7398 cd aa 73		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
739b f1			            POP  AF  
739c 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
739d 17			            RLA  
739e 17			            RLA  
739f 17			            RLA  
73a0 cd aa 73		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
73a3 3e 02		            LD   A, 2  
73a5 cd 94 74		            CALL LCDDelay       ;Delay 2 ms to complete   
73a8 f1			            POP  AF  
73a9 c9			            RET  
73aa			Wr4bits:   
73aa f5					push af  
73ab 3a 00 fb				ld a, (display_lcde1e2)  
73ae fe 00				cp 0     ; e  
73b0 20 10				jr nz, .wea2	  
73b2 f1					pop af  
73b3 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
73b5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
73b7 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
73b9 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
73bb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
73bd cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
73bf d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
73c1 c9			            RET  
73c2 f1			.wea2:		pop af  
73c3 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
73c5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
73c7 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
73c9 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
73cb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
73cd cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
73cf d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
73d1 c9			            RET  
73d2			  
73d2			  
73d2			; Write data to LCD  
73d2			;   On entry: A = Data byte to be written  
73d2			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
73d2 f5			fLCD_Data:  PUSH AF  
73d3 f5			            PUSH AF  
73d4 cd e6 73		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
73d7 f1			            POP  AF  
73d8 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
73d9 17			            RLA  
73da 17			            RLA  
73db 17			            RLA  
73dc cd e6 73		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
73df 3e 96		            LD   A, 150  
73e1 3d			Wait:      DEC  A              ;Wait a while to allow data   
73e2 20 fd		            JR   NZ, Wait      ;  write to complete  
73e4 f1			            POP  AF  
73e5 c9			            RET  
73e6			Wr4bitsa:     
73e6 f5					push af  
73e7 3a 00 fb				ld a, (display_lcde1e2)  
73ea fe 00				cp 0     ; e1  
73ec 20 16				jr nz, .we2	  
73ee f1					pop af  
73ef e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
73f1 cb d7		            SET  kLCDBitRS, A  
73f3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
73f5 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
73f7 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
73f9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
73fb cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
73fd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
73ff cb 97		            RES  kLCDBitRS, A  
7401 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7403 c9			            RET  
7404 f1			.we2:		pop af  
7405 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7407 cb d7		            SET  kLCDBitRS, A  
7409 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
740b cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
740d cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
740f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7411 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7413 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7415 cb 97		            RES  kLCDBitRS, A  
7417 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7419 c9			            RET  
741a			  
741a			  
741a			; Position cursor to specified location  
741a			;   On entry: A = Cursor position  
741a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
741a f5			fLCD_Pos:   PUSH AF  
741b					; at this point set the E1 or E2 flag depending on position  
741b			  
741b c5					push bc  
741c			;		push af  
741c 06 00				ld b, 0  
741e 4f					ld c, a  
741f 3e 4f				ld a, kLCD_Line3-1  
7421 b7			 		or a      ;clear carry flag  
7422 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
7423 38 04				jr c, .pe1  
7425			  
7425					; E selection  
7425 cb 80				res 0, b         ; bit 0 unset e  
7427			;		pop af    ; before line 3 so recover orig pos  
7427			;		ld c, a    ; save for poking back  
7427 18 06				jr .peset	          
7429			.pe1:          	; E2 selection  
7429 cb c0				set 0, b         ; bit 0 set e1  
742b 79					ld a, c  
742c de 4f				sbc a, kLCD_Line3-1  
742e 4f					ld c, a	         ; save caculated offset  
742f			;		pop af     ; bin this original value now we have calculated form  
742f			  
742f			.peset:		; set bit  
742f 78					ld a, b  
7430 32 00 fb				ld (display_lcde1e2), a 	  
7433 79					ld a, c  
7434 c1					pop bc  
7435			  
7435 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7437 cd 96 73		            CALL fLCD_Inst      ;Write instruction to LCD  
743a f1			            POP  AF  
743b c9			            RET  
743c			  
743c			  
743c			; Output text string to LCD  
743c			;   On entry: DE = Pointer to null terminated text string  
743c			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
743c 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
743d b7			            OR   A              ;Null terminator?  
743e c8			            RET  Z              ;Yes, so finished  
743f cd d2 73		            CALL fLCD_Data      ;Write character to display  
7442 13			            INC  DE             ;Point to next character  
7443 18 f7		            JR   fLCD_Str       ;Repeat  
7445 c9					ret  
7446			  
7446			; Define custom character  
7446			;   On entry: A = Character number (0 to 7)  
7446			;             DE = Pointer to character bitmap data  
7446			;   On exit:  A = Next character number  
7446			;             DE = Next location following bitmap  
7446			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7446			; Character is   
7446 c5			fLCD_Def:   PUSH BC  
7447 f5			            PUSH AF  
7448 07			            RLCA                ;Calculate location  
7449 07			            RLCA                ;  for bitmap data  
744a 07			            RLCA                ;  = 8 x CharacterNumber  
744b f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
744d cd 96 73		            CALL fLCD_Inst      ;Write instruction to LCD  
7450 06 00		            LD   B, 0  
7452 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
7453 cd d2 73		            CALL fLCD_Data      ;Write byte to display  
7456 13			            INC  DE             ;Point to next byte  
7457 04			            INC  B              ;Count bytes  
7458 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
745a 28 f6		            JR   Z, Loop       ;No, so repeat  
745c f1			            POP  AF  
745d 3c			            INC  A              ;Increment character number  
745e c1			            POP  BC  
745f c9			            RET  
7460			  
7460			  
7460			; **********************************************************************  
7460			; **  Private functions  
7460			; **********************************************************************  
7460			  
7460			; Write function to LCD  
7460			;   On entry: A = Function byte to be written  
7460			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7460 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7462 18 02		            JR   WrFunc  
7464 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
7466 f5			WrFunc:     PUSH AF  
7467 f5					push af  
7468 3a 00 fb				ld a, (display_lcde1e2)  
746b fe 00				cp 0     ; e1  
746d 20 0f				jr nz, .wfea2	  
746f f1					pop af  
7470 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7472 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
7474 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7476 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7478 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
747a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
747c 18 0d			jr .wfskip  
747e f1			.wfea2:		pop af  
747f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7481 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7483 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7485 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7487 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7489 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
748b 3e 05		.wfskip:            LD  A, 5  
748d cd 94 74		            CALL LCDDelay       ;Delay 5 ms to complete  
7490 f1			            POP  AF  
7491 c9			            RET  
7492			  
7492			  
7492			; Delay in milliseconds  
7492			;   On entry: A = Number of milliseconds delay  
7492			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7492 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7494 d5			LCDDelay:   PUSH DE  
7495 5f			            LD   E, A           ;Delay by 'A' ms  
7496 16 00		            LD   D, 0  
7498 cd d2 0c		            CALL aDelayInMS  
749b d1			            POP  DE  
749c c9			            RET  
749d			  
749d			  
749d			testlcd:  
749d 3e 00			ld a, kLCD_Line1  
749f cd 1a 74			call fLCD_Pos  
74a2 06 28			ld b, 40  
74a4 11 d2 74			ld de, .ttext1  
74a7 cd 65 73			call write_len_string  
74aa			  
74aa 3e 28			ld a, kLCD_Line2  
74ac cd 1a 74			call fLCD_Pos  
74af 06 28			ld b, 40  
74b1 11 fb 74			ld de, .ttext2  
74b4 cd 65 73			call write_len_string  
74b7 3e 50			ld a, kLCD_Line3  
74b9 cd 1a 74			call fLCD_Pos  
74bc 06 28			ld b, 40  
74be 11 24 75			ld de, .ttext3  
74c1 cd 65 73			call write_len_string  
74c4 3e 78			ld a, kLCD_Line4  
74c6 cd 1a 74			call fLCD_Pos  
74c9 06 28			ld b, 40  
74cb 11 4d 75			ld de, .ttext4  
74ce cd 65 73			call write_len_string  
74d1			  
74d1 76				halt  
74d2			  
74d2			  
74d2 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
74fb .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7524 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
754d .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
7576			   
7576			  
7576			  
7576			; eof  
7576			  
# End of file firmware_lcd_4x40.asm
7576			;include "firmware_lcd_4x20.asm" 
7576			include "firmware_key_5x10.asm" 
7576			; 5 x 10 decade counter scanner  
7576			  
7576			  
7576			; TODO do cursor shape change for shift keys  
7576			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
7576			  
7576			  
7576			; bit mask for each scan column and row for teing the matrix  
7576			  
7576			  
7576			key_init:  
7576			  
7576			; SCMonAPI functions used  
7576			  
7576			; Alphanumeric LCD functions used  
7576			; no need to specify specific functions for this module  
7576			  
7576			  
7576 3e cf		            LD   A, 11001111b  
7578 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
757a			;            LD   A, 00000000b  
757a 3e 1f		            LD   A, 00011111b  
757c d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
757e			  
757e			  
757e				; TODO Configure cursor shapes  
757e			  
757e				; Load cursor shapes   
757e 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7580 11 90 75		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7583 06 02		            LD   B, 2           ;Number of characters to define  
7585 cd 46 74		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7588 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
758a			  
758a 3e 01				ld a, 1  
758c 32 f6 fa			ld (cursor_shape),a  
758f c9				ret  
7590			  
7590			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7590			; Up to 8 custom characters can be defined  
7590			.cursor_shapes:      
7590			;; Character 0x00 = Normal  
7590 1f			            DB  11111b  
7591 1f			            DB  11111b  
7592 1f			            DB  11111b  
7593 1f			            DB  11111b  
7594 1f			            DB  11111b  
7595 1f			            DB  11111b  
7596 1f			            DB  11111b  
7597 1f			            DB  11111b  
7598			;; Character 0x01 = Modifier  
7598 1f			            DB  11111b  
7599 1b			            DB  11011b  
759a 1b			            DB  11011b  
759b 1b			            DB  11011b  
759c 1b			            DB  11011b  
759d 1f			            DB  11111b  
759e 1b			            DB  11011b  
759f 1f			            DB  11111b  
75a0			  
75a0			  
75a0			  
75a0			  
75a0			; Display custom character 0  
75a0			;            LD   A, kLCD_Line1+14  
75a0			;            CALL fLCD_Pos       ;Position cursor to location in A  
75a0			;            LD   A, 0  
75a0			;            CALL fLCD_Data      ;Write character in A at cursor  
75a0			  
75a0			; Display custom character 1  
75a0			;            LD   A, kLCD_Line2+14  
75a0			;            CALL fLCD_Pos      ;Position cursor to location in A  
75a0			;            LD   A, 1  
75a0			;            CALL fLCD_Data     ;Write character in A at cursor  
75a0			  
75a0			; keyboard scanning   
75a0			  
75a0			; character in from keyboard  
75a0			  
75a0			; mapping for the pcb layout  
75a0			  
75a0			.matrix_to_char:  
75a0 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
75ab .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
75b6 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
75c1 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
75cc .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
75d7			.matrix_to_shift:  
75d7			  
75d7 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
75e2 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
75ed 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
75f8 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7603 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
760e			  
760e			.matrix_to_symbolshift:  
760e			  
760e fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7619 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7624 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
762f			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
762f 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
763a .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7645			  
7645			  
7645			  
7645			; mapping for a simple straight through breadboard layout  
7645			  
7645			;.matrix_to_char:  
7645			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7645			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7645			;		db "asdfghjkl",KEY_CR,0  
7645			;		db "qwertyuiop",0  
7645			;		 db "1234567890",0  
7645			;.matrix_to_shift:  
7645			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7645			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7645			;		db "ASDFGHJKL",KEY_CR,0  
7645			;		db "QWERTYUIOP",0  
7645			;		 db "!",'"',"#$%^&*()",0  
7645			;.matrix_to_symbolshift:  
7645			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7645			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7645			;		db "_?*fghjk=",KEY_CR,0  
7645			;		db "-/+*[]{}@#",0  
7645			;		 db "1234567890",0  
7645			  
7645			;.matrix_to_char: db "D#0*C987B654A321"  
7645			  
7645			  
7645				  
7645			  
7645			; add cin and cin_wait  
7645			  
7645 cd 56 76		cin_wait: 	call cin  
7648						if DEBUG_KEYCINWAIT  
7648							push af  
7648							  
7648							ld hl,key_repeat_ct  
7648							ld (hl),a  
7648							inc hl  
7648							call hexout  
7648							ld hl,key_repeat_ct+3  
7648							ld a,0  
7648							ld (hl),a  
7648			  
7648							    LD   A, kLCD_Line1+11  
7648							    CALL fLCD_Pos       ;Position cursor to location in A  
7648							    LD   DE, key_repeat_ct  
7648							    ;LD   DE, MsgHello  
7648							    CALL fLCD_Str       ;Display string pointed to by DE  
7648			  
7648			  
7648			  
7648							pop af  
7648						endif  
7648 fe 00			cp 0  
764a 28 f9			jr z, cin_wait   ; block until key press  
764c			  
764c							if DEBUG_KEYCINWAIT  
764c								push af  
764c			  
764c								ld a, 'A'	  
764c								ld hl,key_repeat_ct  
764c								ld (hl),a  
764c								inc hl  
764c								ld a,0  
764c								ld (hl),a  
764c			  
764c								    LD   A, kLCD_Line2+11  
764c								    CALL fLCD_Pos       ;Position cursor to location in A  
764c								    LD   DE, key_repeat_ct  
764c								    ;LD   DE, MsgHello  
764c								    CALL fLCD_Str       ;Display string pointed to by DE  
764c			  
764c							call delay500ms  
764c			  
764c								pop af  
764c							endif  
764c f5				push af   ; save key pressed  
764d			  
764d			.cin_wait1:	  
764d							if DEBUG_KEYCINWAIT  
764d								push af  
764d			  
764d								ld a, 'b'	  
764d								ld hl,key_repeat_ct  
764d								ld (hl),a  
764d								inc hl  
764d								ld a,0  
764d								ld (hl),a  
764d			  
764d								    LD   A, kLCD_Line2+11  
764d								    CALL fLCD_Pos       ;Position cursor to location in A  
764d								    LD   DE, key_repeat_ct  
764d								    ;LD   DE, MsgHello  
764d								    CALL fLCD_Str       ;Display string pointed to by DE  
764d			  
764d			  
764d							call delay500ms  
764d			  
764d								pop af  
764d							endif  
764d			  
764d cd 56 76		call cin  
7650 fe 00			cp 0  
7652 20 f9			jr nz, .cin_wait1  	; wait for key release  
7654			if DEBUG_KEYCINWAIT  
7654				push af  
7654			  
7654				ld a, '3'	  
7654				ld hl,key_repeat_ct  
7654				ld (hl),a  
7654				inc hl  
7654				ld a,0  
7654				ld (hl),a  
7654			  
7654			            LD   A, kLCD_Line2+11  
7654			            CALL fLCD_Pos       ;Position cursor to location in A  
7654			            LD   DE, key_repeat_ct  
7654			            ;LD   DE, MsgHello  
7654			            CALL fLCD_Str       ;Display string pointed to by DE  
7654			  
7654			  
7654			call delay500ms  
7654			  
7654				pop af  
7654			endif  
7654			  
7654 f1				pop af   ; get key  
7655 c9				ret  
7656			  
7656			  
7656			; cin - key non-blocking except for keybounce release  
7656			  
7656 cd 74 76		cin: 	call .mtoc  
7659			  
7659			if DEBUG_KEYCIN  
7659				push af  
7659				  
7659				ld hl,key_repeat_ct  
7659				ld (hl),a  
7659				inc hl  
7659				call hexout  
7659				ld hl,key_repeat_ct+3  
7659				ld a,0  
7659				ld (hl),a  
7659			  
7659			            LD   A, kLCD_Line3+15  
7659			            CALL fLCD_Pos       ;Position cursor to location in A  
7659			            LD   DE, key_repeat_ct  
7659			            ;LD   DE, MsgHello  
7659			            CALL fLCD_Str       ;Display string pointed to by DE  
7659			  
7659			  
7659			call delay500ms  
7659			  
7659				pop af  
7659			endif  
7659			  
7659			  
7659				; no key held  
7659 fe 00			cp 0  
765b c8				ret z  
765c			  
765c			if DEBUG_KEYCIN  
765c				push af  
765c			  
765c				ld a, '1'	  
765c				ld hl,key_repeat_ct  
765c				ld (hl),a  
765c				inc hl  
765c				ld a,0  
765c				ld (hl),a  
765c			  
765c			            LD   A, kLCD_Line4+15  
765c			            CALL fLCD_Pos       ;Position cursor to location in A  
765c			            LD   DE, key_repeat_ct  
765c			            ;LD   DE, MsgHello  
765c			            CALL fLCD_Str       ;Display string pointed to by DE  
765c			  
765c			  
765c			call delay500ms  
765c			  
765c				pop af  
765c			endif  
765c			  
765c				; stop key bounce  
765c			  
765c 32 c6 fd			ld (key_held),a		 ; save it  
765f 47				ld b, a  
7660			  
7660 c5			.cina1:	push bc  
7661			if DEBUG_KEYCIN  
7661				push af  
7661			  
7661				ld hl,key_repeat_ct  
7661				inc hl  
7661				call hexout  
7661				ld hl,key_repeat_ct+3  
7661				ld a,0  
7661				ld (hl),a  
7661				ld hl,key_repeat_ct  
7661				ld a, '2'	  
7661				ld (hl),a  
7661			  
7661			            LD   A, kLCD_Line4+15  
7661			            CALL fLCD_Pos       ;Position cursor to location in A  
7661			            LD   DE, key_repeat_ct  
7661			            ;LD   DE, MsgHello  
7661			            CALL fLCD_Str       ;Display string pointed to by DE  
7661			  
7661				pop af  
7661			endif  
7661 cd 74 76			call .mtoc  
7664 c1				pop bc  
7665 b8				cp b  
7666 28 f8			jr z, .cina1  
7668 78				ld a,b		  
7669			if DEBUG_KEYCIN  
7669				push af  
7669			  
7669				ld hl,key_repeat_ct  
7669				inc hl  
7669				call hexout  
7669				ld hl,key_repeat_ct+3  
7669				ld a,0  
7669				ld (hl),a  
7669				ld hl,key_repeat_ct  
7669				ld a, '3'	  
7669				ld (hl),a  
7669			  
7669			            LD   A, kLCD_Line4+15  
7669			            CALL fLCD_Pos       ;Position cursor to location in A  
7669			            LD   DE, key_repeat_ct  
7669			            ;LD   DE, MsgHello  
7669			            CALL fLCD_Str       ;Display string pointed to by DE  
7669			  
7669				pop af  
7669			endif  
7669 c9				ret  
766a			  
766a			; cinndb - key non-blocking without keybounce release  
766a			  
766a cd 74 76		cinndb: 	call .mtoc  
766d			  
766d			if DEBUG_KEYCIN  
766d				push af  
766d				  
766d				ld hl,key_repeat_ct  
766d				ld (hl),a  
766d				inc hl  
766d				call hexout  
766d				ld hl,key_repeat_ct+3  
766d				ld a,0  
766d				ld (hl),a  
766d			  
766d			            LD   A, kLCD_Line3+15  
766d			            CALL fLCD_Pos       ;Position cursor to location in A  
766d			            LD   DE, key_repeat_ct  
766d			            ;LD   DE, MsgHello  
766d			            CALL fLCD_Str       ;Display string pointed to by DE  
766d			  
766d			  
766d			call delay500ms  
766d			  
766d				pop af  
766d			endif  
766d			  
766d			  
766d				; no key held  
766d fe 00			cp 0  
766f c8				ret z  
7670			  
7670			if DEBUG_KEYCIN  
7670				push af  
7670			  
7670				ld a, '1'	  
7670				ld hl,key_repeat_ct  
7670				ld (hl),a  
7670				inc hl  
7670				ld a,0  
7670				ld (hl),a  
7670			  
7670			            LD   A, kLCD_Line4+15  
7670			            CALL fLCD_Pos       ;Position cursor to location in A  
7670			            LD   DE, key_repeat_ct  
7670			            ;LD   DE, MsgHello  
7670			            CALL fLCD_Str       ;Display string pointed to by DE  
7670			  
7670			  
7670			call delay500ms  
7670			  
7670				pop af  
7670			endif  
7670			  
7670 32 c6 fd			ld (key_held),a		 ; save it  
7673			  
7673			if DEBUG_KEYCIN  
7673				push af  
7673			  
7673				ld hl,key_repeat_ct  
7673				inc hl  
7673				call hexout  
7673				ld hl,key_repeat_ct+3  
7673				ld a,0  
7673				ld (hl),a  
7673				ld hl,key_repeat_ct  
7673				ld a, '3'	  
7673				ld (hl),a  
7673			  
7673			            LD   A, kLCD_Line4+15  
7673			            CALL fLCD_Pos       ;Position cursor to location in A  
7673			            LD   DE, key_repeat_ct  
7673			            ;LD   DE, MsgHello  
7673			            CALL fLCD_Str       ;Display string pointed to by DE  
7673			  
7673				pop af  
7673			endif  
7673 c9				ret  
7674			; detect keyboard modifier key press and apply new overlay to the face key held  
7674			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7674			  
7674			;.cin_map_modifier:   
7674			;	ld a, (hl)  
7674			;	and 255  
7674			;	ret NZ		; modifier key not flagged  
7674			;  
7674			;	; get key face  
7674			;  
7674			;	ld b,(key_face_held)  
7674			;  
7674			;	ld b, key_cols * key_rows  
7674			;  
7674			;	push de  
7674			;	pop hl  
7674			;  
7674			;.mmod1: ld a,(hl)   ; get map test  
7674			;	cp b  
7674			;	jr z, .mmod2  
7674			;  
7674			;  
7674			;  
7674			;.mmod2: inc hl    ;   
7674			;  
7674			;	  
7674			;  
7674			;	  
7674			;  
7674			;	ld hl,key_actual_pressed  
7674			;	ld (hl),a,  
7674			;	ret  
7674			  
7674			; map matrix key held to char on face of key  
7674			  
7674			.mtoc:  
7674			  
7674			; test decade counter strobes  
7674			  
7674			;.decadetest1:  
7674			  
7674			; reset counter  
7674			;ld a, 128  
7674			;out (portbdata),a  
7674			  
7674			  
7674			;ld b, 5  
7674			;.dec1:  
7674			;ld a, 0  
7674			;out (portbdata),a  
7674			;call delay1s  
7674			  
7674			;ld a, 32  
7674			;out (portbdata),a  
7674			;call delay1s  
7674			;call delay1s  
7674			;call delay1s  
7674			;  
7674			;ld a, 64+32  
7674			;out (portbdata),a  
7674			;call delay1s  
7674			;;djnz .dec1  
7674			;  
7674			;jp .decadetest1  
7674			  
7674			  
7674			  
7674			  
7674			  
7674			  
7674			  
7674			  
7674			  
7674			  
7674				; scan keyboard matrix and generate raw scan map  
7674 cd 07 77			call matrix  
7677			  
7677				; reuse c bit 0 left modifer button - ie shift  
7677			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7677				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7677			  
7677 0e 00			ld c, 0  
7679			  
7679				; TODO set flags for modifer key presses   
7679				; TODO do a search for modifer key...  
7679			  
7679				;ld hl,keyscan_table_row4  
7679 21 25 fe			ld hl,keyscan_table_row2  
767c			  
767c 7e				ld a, (hl)  
767d fe 23			cp '#'  
767f 20 07			jr nz, .nextmodcheck  
7681 cb c1			set 0, c  
7683 21 d7 75			ld hl, .matrix_to_shift  
7686 18 21			jr .dokeymap  
7688				; TODO for now igonre  
7688			.nextmodcheck:  
7688 21 1a fe			ld hl,keyscan_table_row3  
768b			  
768b 7e				ld a, (hl)  
768c fe 23			cp '#'  
768e 20 07			jr nz, .nextmodcheck2  
7690 cb c9			set 1, c   
7692 21 0e 76			ld hl, .matrix_to_symbolshift  
7695 18 12			jr .dokeymap  
7697			.nextmodcheck2:  
7697 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
769a			  
769a 7e				ld a, (hl)  
769b fe 23			cp '#'  
769d 20 07			jr nz, .donemodcheck  
769f cb c9			set 1, c   
76a1 21 d7 75			ld hl, .matrix_to_shift  
76a4 18 03			jr .dokeymap  
76a6			  
76a6				; no modifer found so just map to normal keys  
76a6				; get mtoc map matrix to respective keys  
76a6			;	ld hl, .matrix_to_char  
76a6			;	ld hl, .matrix_to_char  
76a6			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
76a6			;	ld a, KEY_SHIFT  
76a6			;	call findchar  
76a6			;  
76a6			;	; got offset to key modifer in b  
76a6			;  
76a6			;	ld hl,keyscan_table_row5  
76a6			;  
76a6			;	ld a,b  
76a6			;	call addatohl  
76a6			;	ld a,(hl)  
76a6			;  
76a6			;	cp '#'  
76a6			;	jr nz, .nextmodcheck  
76a6			;	set 0, c  
76a6			;	ld hl, .matrix_to_char  
76a6			;	jr .dokeymap  
76a6			;	; TODO for now igonre  
76a6			;.nextmodcheck:  
76a6			;	ld hl, .matrix_to_symbolshift  
76a6			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
76a6			;	ld a, KEY_SYMBOLSHIFT  
76a6			;	call findchar  
76a6			;  
76a6			;  
76a6			;	; got offset to key modifer in b  
76a6			;  
76a6			;	ld hl,keyscan_table_row5  
76a6			;  
76a6			;	ld a,b  
76a6			;	call addatohl  
76a6			;	ld a,(hl)  
76a6			;  
76a6			;	cp '#'  
76a6			;	jr nz, .donemodcheck  
76a6			;	set 1, c   
76a6			;	ld hl, .matrix_to_symbolshift  
76a6			;	jr .dokeymap  
76a6			  
76a6			  
76a6			  
76a6			.donemodcheck:  
76a6				; no modifer found so just map to normal keys  
76a6				; get mtoc map matrix to respective keys  
76a6 21 a0 75			ld hl, .matrix_to_char  
76a9			  
76a9			.dokeymap:  
76a9				;ld (key_fa), c   
76a9 cd c2 76			call .mapkeys  
76ac			  
76ac			  
76ac			if DEBUG_KEY  
76ac			  
76ac			; Display text on first line  
76ac			            LD   A, kLCD_Line1  
76ac			            CALL fLCD_Pos       ;Position cursor to location in A  
76ac			            LD   DE, keyscan_table_row1  
76ac			            ;LD   DE, MsgHello  
76ac			            CALL fLCD_Str       ;Display string pointed to by DE  
76ac			  
76ac			; Display text on second line  
76ac			            LD   A, kLCD_Line2  
76ac			            CALL fLCD_Pos       ;Position cursor to location in A  
76ac			            LD   DE, keyscan_table_row2  
76ac			            CALL fLCD_Str       ;Display string pointed to by DE  
76ac			            LD   A, kLCD_Line3  
76ac			            CALL fLCD_Pos       ;Position cursor to location in A  
76ac			            LD   DE, keyscan_table_row3  
76ac			            CALL fLCD_Str       ;Display string pointed to by DE  
76ac			            LD   A, kLCD_Line4  
76ac			            CALL fLCD_Pos       ;Position cursor to location in A  
76ac			            LD   DE, keyscan_table_row4  
76ac			            CALL fLCD_Str       ;Display string pointed to by DE  
76ac			            LD   A, kLCD_Line1+10  
76ac			            CALL fLCD_Pos       ;Position cursor to location in A  
76ac			            LD   DE, keyscan_table_row5  
76ac			            CALL fLCD_Str       ;Display string pointed to by DE  
76ac			  
76ac				;call delay250ms  
76ac			endif  
76ac			;	jp testkey  
76ac			  
76ac			; get first char reported  
76ac			  
76ac 21 04 fe			ld hl,keyscan_table_row5  
76af			  
76af				;ld b, 46   ; 30 keys to remap + 8 nulls   
76af 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
76b1			.findkey:  
76b1 7e				ld a,(hl)  
76b2 fe 00			cp 0  
76b4 28 04			jr z, .nextkey  
76b6 fe 7e			cp KEY_MATRIX_NO_PRESS  
76b8 20 06			jr nz, .foundkey  
76ba			.nextkey:  
76ba 23				inc hl  
76bb 10 f4			djnz .findkey  
76bd 3e 00			ld a,0  
76bf c9				ret  
76c0			.foundkey:  
76c0 7e				ld a,(hl)  
76c1 c9				ret  
76c2				  
76c2			  
76c2			; convert the raw key map given hl for destination key  
76c2			.mapkeys:  
76c2 11 04 fe			ld de,keyscan_table_row5  
76c5			  
76c5 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
76c7			.remap:  
76c7 1a				ld a,(de)  
76c8 fe 23			cp '#'  
76ca 20 02			jr nz, .remapnext  
76cc				;CALLMONITOR  
76cc 7e				ld a,(hl)  
76cd 12				ld (de),a  
76ce			  
76ce			  
76ce			  
76ce			.remapnext:  
76ce 23				inc hl  
76cf 13				inc de  
76d0 10 f5			djnz .remap  
76d2				  
76d2 c9				ret  
76d3			  
76d3			  
76d3			  
76d3			.mtocold2:  
76d3			  
76d3			;	; flag if key D is held down and remove from reporting  
76d3			;	ld bc, .key_map_fd    
76d3			;	ld hl, keyscan_table  
76d3			;	ld de, key_fd  
76d3			;	call .key_shift_hold  
76d3			;	cp 255  
76d3			;	jr z, .cinmap  
76d3			;	; flag if key C is held down and remove from reporting  
76d3			;	ld bc, .key_map_fc    
76d3			;	ld hl, keyscan_table+key_cols  
76d3			;	ld de, key_fc  
76d3			;	call .key_shift_hold  
76d3			;	cp 255  
76d3			;	jr z, .cinmap  
76d3			;	; flag if key B is held down and remove from reporting  
76d3			;	ld bc, .key_map_fb    
76d3			;	ld hl, keyscan_table+(key_cols*2)  
76d3			;	ld de, key_fb  
76d3			;	call .key_shift_hold  
76d3			;	cp 255  
76d3			;	jr z, .cinmap  
76d3			;	; flag if key A is held down and remove from reporting  
76d3			;	ld bc, .key_map_fa    
76d3			;	ld hl, keyscan_table+(key_cols*3)  
76d3			;	ld de, key_fa  
76d3			;	call .key_shift_hold  
76d3			;	cp 255  
76d3			;	jr z, .cinmap  
76d3			  
76d3 11 a0 75			ld de, .matrix_to_char  
76d6			  
76d6			  
76d6			.cinmap1:   
76d6				if DEBUG_KEY  
76d6			            LD   A, kLCD_Line4  
76d6			            CALL fLCD_Pos       ;Position cursor to location in A  
76d6					push de  
76d6			            LD   DE, keyscan_table  
76d6			            CALL fLCD_Str       ;Display string pointed to by DE  
76d6					pop de  
76d6				endif  
76d6			  
76d6				; scan key matrix table for any held key  
76d6			  
76d6				; de holds either the default matrix or one selected above  
76d6			  
76d6 21 d1 fd			ld hl, keyscan_table  
76d9 06 32			ld b,key_cols*key_rows  
76db			  
76db 7e			.cin11:	ld a,(hl)  
76dc fe 23			cp '#'  
76de 28 08			jr z, .cinhit1  
76e0 23				inc hl  
76e1 13				inc de  
76e2 05				dec b  
76e3 20 f6			jr nz, .cin11  
76e5				; no key found held  
76e5 3e 00			ld a,0  
76e7 c9				ret  
76e8 d5			.cinhit1: push de  
76e9 e1				pop hl  
76ea 7e				ld a,(hl)  
76eb c9				ret  
76ec			  
76ec			; flag a control key is held   
76ec			; hl is key pin, de is flag indicator  
76ec			  
76ec			.key_shift_hold1:  
76ec c5				push bc  
76ed 3e 01			ld a, 1  
76ef 32 f6 fa			ld (cursor_shape),a  
76f2 06 00			ld b, 0  
76f4 7e				ld a, (hl)  
76f5 fe 2e			cp '.'  
76f7 28 0a			jr z, .key_shift11  
76f9 06 ff			ld b, 255  
76fb 3e 2b			ld a, '+'    ; hide key from later scans  
76fd 77				ld (hl),a  
76fe 3e 02			ld a, 2  
7700 32 f6 fa			ld (cursor_shape),a  
7703			.key_shift11:  
7703				; write flag indicator  
7703 78				ld a,b  
7704 12				ld (de),a  
7705			  
7705 d1				pop de    ; de now holds the key map ptr  
7706 c9				ret  
7707			  
7707				  
7707			  
7707			; scans keyboard matrix and flags key press in memory array	  
7707				  
7707			matrix:  
7707				;call matrix  
7707				; TODO optimise the code....  
7707			  
7707			  
7707			;ld hl, keyscan_table_row1  
7707			;ld de, keyscan_table_row1+1  
7707			;ld bc,46  
7707			;ld a,KEY_MATRIX_NO_PRESS  
7707			;ldir  
7707			  
7707			  
7707			  
7707			; reset counter  
7707 3e 80		ld a, 128  
7709 d3 c1		out (portbdata),a  
770b			  
770b 06 0a		ld b, 10  
770d 0e 00		ld c, 0       ; current clock toggle  
770f			  
770f			.colscan:  
770f			  
770f			; set current column  
770f			; disable clock enable and set clock low  
770f			  
770f			;ld a, 0  
770f			;out (portbdata),a  
770f			  
770f			; For each column scan for switches  
770f			  
770f c5			push bc  
7710 21 c7 fd		ld hl, keyscan_scancol  
7713 cd 1c 78		call .rowscan  
7716 c1			pop bc  
7717			  
7717			  
7717			; get back current column  
7717			  
7717			; translate the row scan  
7717			  
7717			;   
7717			; row 1  
7717			  
7717 78			ld a,b  
7718			  
7718 21 3a fe		LD   hl, keyscan_table_row1+10  
771b			  
771b cd f0 0f		call subafromhl  
771e			;call addatohl  
771e			  
771e 11 c7 fd		ld de, keyscan_scancol  
7721			  
7721 1a			ld a,(de)  
7722 77			ld (hl),a  
7723			  
7723			  
7723			  
7723			  
7723			; row 2  
7723			  
7723 78			ld a,b  
7724			  
7724 21 2f fe		LD   hl, keyscan_table_row2+10  
7727			  
7727			;call addatohl  
7727 cd f0 0f		call subafromhl  
772a			  
772a			  
772a 11 c8 fd		ld de, keyscan_scancol+1  
772d			  
772d 1a			ld a,(de)  
772e 77			ld (hl),a  
772f			  
772f			  
772f			; row 3  
772f			  
772f 78			ld a,b  
7730			  
7730 21 24 fe		LD   hl, keyscan_table_row3+10  
7733			  
7733			;call addatohl  
7733 cd f0 0f		call subafromhl  
7736			  
7736 11 c9 fd		ld de, keyscan_scancol+2  
7739			  
7739 1a			ld a,(de)  
773a 77			ld (hl),a  
773b			  
773b			  
773b			  
773b			; row 4  
773b			  
773b 78			ld a,b  
773c			  
773c 21 19 fe		LD   hl, keyscan_table_row4+10  
773f			  
773f			;call addatohl  
773f cd f0 0f		call subafromhl  
7742			  
7742 11 ca fd		ld de, keyscan_scancol+3  
7745			  
7745 1a			ld a,(de)  
7746 77			ld (hl),a  
7747			  
7747			; row 5  
7747			  
7747 78			ld a,b  
7748			  
7748 21 0e fe		LD   hl, keyscan_table_row5+10  
774b			  
774b			;call addatohl  
774b cd f0 0f		call subafromhl  
774e			  
774e 11 cb fd		ld de, keyscan_scancol+4  
7751			  
7751 1a			ld a,(de)  
7752 77			ld (hl),a  
7753			  
7753			; handshake next column  
7753			  
7753			  
7753 3e 40		ld a, 64  
7755 d3 c1		out (portbdata),a  
7757			  
7757 3e 00		ld a, 0  
7759 d3 c1		out (portbdata),a  
775b			  
775b			; toggle clk and move to next column  
775b			;ld a, 64  
775b			;cp c  
775b			;  
775b			;jr z, .coltoglow  
775b			;ld c, a  
775b			;jr .coltog  
775b			;.coltoglow:  
775b			;ld c, 0  
775b			;.coltog:  
775b			;ld a, c  
775b			;out (portbdata),a  
775b			  
775b 10 b2		djnz .colscan  
775d			  
775d 3e 0a		ld a,10  
775f 21 30 fe		LD   hl, keyscan_table_row1  
7762 cd de 0f		call addatohl  
7765 3e 00		ld a, 0  
7767 77			ld (hl), a  
7768			  
7768			  
7768 3e 0a		ld a,10  
776a 21 25 fe		LD   hl, keyscan_table_row2  
776d cd de 0f		call addatohl  
7770 3e 00		ld a, 0  
7772 77			ld (hl), a  
7773			  
7773 3e 0a		ld a,10  
7775 21 1a fe		LD   hl, keyscan_table_row3  
7778 cd de 0f		call addatohl  
777b 3e 00		ld a, 0  
777d 77			ld (hl), a  
777e			  
777e 3e 0a		ld a,10  
7780 21 0f fe		LD   hl, keyscan_table_row4  
7783 cd de 0f		call addatohl  
7786 3e 00		ld a, 0  
7788 77			ld (hl), a  
7789			  
7789 3e 0a		ld a,10  
778b 21 04 fe		LD   hl, keyscan_table_row5  
778e cd de 0f		call addatohl  
7791 3e 00		ld a, 0  
7793 77			ld (hl), a  
7794			  
7794			if DEBUG_KEY_MATRIX  
7794			  
7794			; Display text on first line  
7794			            LD   A, kLCD_Line1  
7794			            CALL fLCD_Pos       ;Position cursor to location in A  
7794			            LD   DE, keyscan_table_row1  
7794			            ;LD   DE, MsgHello  
7794			            CALL fLCD_Str       ;Display string pointed to by DE  
7794			  
7794			; Display text on second line  
7794			            LD   A, kLCD_Line2  
7794			            CALL fLCD_Pos       ;Position cursor to location in A  
7794			            LD   DE, keyscan_table_row2  
7794			            CALL fLCD_Str       ;Display string pointed to by DE  
7794			            LD   A, kLCD_Line3  
7794			            CALL fLCD_Pos       ;Position cursor to location in A  
7794			            LD   DE, keyscan_table_row3  
7794			            CALL fLCD_Str       ;Display string pointed to by DE  
7794			            LD   A, kLCD_Line4  
7794			            CALL fLCD_Pos       ;Position cursor to location in A  
7794			            LD   DE, keyscan_table_row4  
7794			            CALL fLCD_Str       ;Display string pointed to by DE  
7794			            LD   A, kLCD_Line4+10  
7794			            CALL fLCD_Pos       ;Position cursor to location in A  
7794			            LD   DE, keyscan_table_row5  
7794			            CALL fLCD_Str       ;Display string pointed to by DE  
7794			  
7794			;call delay250ms  
7794				jp matrix  
7794			endif  
7794 c9			ret  
7795			  
7795			; using decade counter....  
7795			  
7795			  
7795			; TODO reset decade counter to start of scan  
7795			  
7795			; reset 15  
7795			; clock 14  
7795			; ce 13  
7795			  
7795			; 1 - q5  
7795			; 2 - q1  
7795			; 3 - q0  
7795			; 4 - q2  
7795			; 5 - q6  
7795			; 6 - q7  
7795			; 7 - q3  
7795			; 8 - vss  
7795			; 9 - q8  
7795			; 10 - q4  
7795			; 11 - q9  
7795			; 12 - cout  
7795			; 16 - vdd  
7795			  
7795			; clock      ce       reset     output  
7795			; 0          x        0         n  
7795			; x          1        0         n  
7795			; x          x        1         q0  
7795			; rising     0        0         n+1  
7795			; falling    x        0         n  
7795			; x          rising   0         n  
7795			; 1          falling  0         x+1  
7795			;  
7795			; x = dont care, if n < 5 carry = 1 otherwise 0  
7795			  
7795			;   
7795			; reset   
7795			; 13=0, 14=0, 15=1 .. 15=0  
7795			;  
7795			; handshake line  
7795			; 14=1.... read line 14=0  
7795			  
7795			  
7795			  
7795			  
7795			  
7795			; TODO hand shake clock for next column scan  
7795			; TODO detect each row  
7795			  
7795			  
7795			  
7795			  
7795			; reset 128  
7795			; clock 64  
7795			; ce 32  
7795			  
7795			  
7795			.cyclestart:  
7795			  
7795			; reset counter  
7795 3e 80		ld a, 128  
7797 d3 c1		out (portbdata),a  
7799			  
7799			; loop leds  
7799 06 0a		ld b,10  
779b			  
779b			.cycle1:  
779b c5			push bc  
779c 3e 00		ld a, 0  
779e d3 c1		out (portbdata),a  
77a0 cd e1 0c		call delay250ms  
77a3			  
77a3 3e 40		ld a, 64  
77a5 d3 c1		out (portbdata),a  
77a7 cd e1 0c		call delay250ms  
77aa			  
77aa 3e 00		ld a, 0  
77ac d3 c1		out (portbdata),a  
77ae cd e1 0c		call delay250ms  
77b1			  
77b1 c1			pop bc  
77b2 10 e7		djnz .cycle1  
77b4			  
77b4			  
77b4 18 df		jr .cyclestart  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			; map matrix key held to char on face of key  
77b6			  
77b6			;.mtocold:  
77b6			;  
77b6			;  
77b6			;; reset counter  
77b6			;ld a, 128  
77b6			;out (portbdata),a  
77b6			;  
77b6			;  
77b6			;; scan keyboard row 1  
77b6			;ld a, 0  
77b6			;out (portbdata),a  
77b6			;;ld a, 64  
77b6			;;out (portbdata),a  
77b6			;  
77b6			;  
77b6			;	ld a, 128  
77b6			;	ld hl, keyscan_table  
77b6			;	call .rowscan  
77b6			;  
77b6			;;ld a, 0  
77b6			;;out (portbdata),a  
77b6			;ld a, 64  
77b6			;out (portbdata),a  
77b6			;  
77b6			;	ld a, 64  
77b6			;	ld hl, keyscan_table+key_cols  
77b6			;	call .rowscan  
77b6			;  
77b6			;ld a, 0  
77b6			;out (portbdata),a  
77b6			;;ld a, 64  
77b6			;;out (portbdata),a  
77b6			;	ld a, 32  
77b6			;	ld hl, keyscan_table+(key_cols*2)  
77b6			;	call .rowscan  
77b6			;  
77b6			;  
77b6			;;ld a, 0  
77b6			;;out (portbdata),a  
77b6			;ld a, 64  
77b6			;out (portbdata),a  
77b6			;  
77b6			;	ld a, 16  
77b6			;	ld hl, keyscan_table+(key_cols*3)  
77b6			;	call .rowscan  
77b6			;  
77b6			;  
77b6			;	; flag if key D is held down and remove from reporting  
77b6			;	ld bc, .key_map_fd    
77b6			;	ld hl, keyscan_table  
77b6			;	ld de, key_fd  
77b6			;	call .key_shift_hold  
77b6			;	cp 255  
77b6			;	jr z, .cinmap  
77b6			;	; flag if key C is held down and remove from reporting  
77b6			;	ld bc, .key_map_fc    
77b6			;	ld hl, keyscan_table+key_cols  
77b6			;	ld de, key_fc  
77b6			;	call .key_shift_hold  
77b6			;	cp 255  
77b6			;	jr z, .cinmap  
77b6			;	; flag if key B is held down and remove from reporting  
77b6			;	ld bc, .key_map_fb    
77b6			;	ld hl, keyscan_table+(key_cols*2)  
77b6			;	ld de, key_fb  
77b6			;	call .key_shift_hold  
77b6			;	cp 255  
77b6			;	jr z, .cinmap  
77b6			;	; flag if key A is held down and remove from reporting  
77b6			;	ld bc, .key_map_fa    
77b6			;	ld hl, keyscan_table+(key_cols*3)  
77b6			;	ld de, key_fa  
77b6			;	call .key_shift_hold  
77b6			;	cp 255  
77b6			;	jr z, .cinmap  
77b6			;  
77b6			;	ld de, .matrix_to_char  
77b6			;  
77b6			;  
77b6			;.cinmap:   
77b6			;	if DEBUG_KEY  
77b6			;            LD   A, kLCD_Line4  
77b6			;            CALL fLCD_Pos       ;Position cursor to location in A  
77b6			;		push de  
77b6			;            LD   DE, keyscan_table  
77b6			;            CALL fLCD_Str       ;Display string pointed to by DE  
77b6			;		pop de  
77b6			;	endif  
77b6			  
77b6				; scan key matrix table for any held key  
77b6			  
77b6				; de holds either the default matrix or one selected above  
77b6			  
77b6			;	ld hl, keyscan_table  
77b6			;	ld b,key_cols*key_rows  
77b6			;  
77b6			;.cin1:	ld a,(hl)  
77b6			;	cp '#'  
77b6			;	jr z, .cinhit  
77b6			;	inc hl  
77b6			;	inc de  
77b6			;	dec b  
77b6			;	jr nz, .cin1  
77b6			;	; no key found held  
77b6			;	ld a,0  
77b6			;	ret  
77b6			;.cinhit: push de  
77b6			;	pop hl  
77b6			;	ld a,(hl)  
77b6			;	ret  
77b6			  
77b6			; flag a control key is held   
77b6			; hl is key pin, de is flag indicator  
77b6			  
77b6			;.key_shift_hold:  
77b6			;	push bc  
77b6			;	ld a, 1  
77b6			;	ld (cursor_shape),a  
77b6			;	ld b, 0  
77b6			;	ld a, (hl)  
77b6			;	cp '.'  
77b6			;	jr z, .key_shift1  
77b6			;	ld b, 255  
77b6			;	ld a, '+'    ; hide key from later scans  
77b6			;	ld (hl),a  
77b6			;	ld a, 2  
77b6			;	ld (cursor_shape),a  
77b6			;.key_shift1:  
77b6			;	; write flag indicator  
77b6			;	ld a,b  
77b6			;	ld (de),a  
77b6			;  
77b6			;	pop de    ; de now holds the key map ptr  
77b6			;	ret  
77b6			  
77b6				  
77b6				  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			;	push hl  
77b6			;	push de  
77b6			;	push bc  
77b6			;	call keyscan  
77b6			;	; map key matrix to ascii value of key face  
77b6			;  
77b6			;	ld hl, key_face_map  
77b6			;	ld de, keyscan_table  
77b6			;  
77b6			;	; get how many keys to look at  
77b6			;	ld b, keyscan_table_len  
77b6			;	  
77b6			;  
77b6			;	; at this stage fall out on first key hit  
77b6			;	; TODO handle multiple key press  
77b6			;  
77b6			;map1:	ld a,(hl)  
77b6			;	cp '#'  
77b6			;	jr z, keyhit  
77b6			;	inc hl  
77b6			;	inc de  
77b6			;	dec b  
77b6			;	jr nz, map1  
77b6			;nohit:	ld a, 0  
77b6			;	jr keydone  
77b6			;keyhit: push de  
77b6			;	pop hl  
77b6			;	ld a,(hl)  
77b6			;keydone:  
77b6			;	push bc  
77b6			;	push de  
77b6			; 	push hl  
77b6			;	ret   
77b6			;  
77b6			  
77b6			  
77b6			  
77b6			  
77b6			; scan physical key matrix  
77b6			  
77b6			  
77b6			;keyscan:  
77b6			;  
77b6			;; for each key_row use keyscanr bit mask for out  
77b6			;; then read in for keyscanc bitmask  
77b6			;; save result of row scan to keyscantable  
77b6			;  
77b6			;; scan keyboard row 1  
77b6			;  
77b6			;	ld b, key_rows  
77b6			;	ld hl, key_scanr  
77b6			;	ld de, keyscan_table  
77b6			;  
77b6			;rowloop:  
77b6			;  
77b6			;	ld a,(hl)		; out bit mask to energise keyboard row  
77b6			;	call rowscan  
77b6			;	inc hl  
77b6			;	dec b  
77b6			;	jr nz, rowloop  
77b6			;  
77b6			;	ret  
77b6			;  
77b6			;  
77b6			;; pass a out bitmask, b row number  
77b6			;arowscan:   
77b6			;	push bc  
77b6			;  
77b6			;	ld d, b  
77b6			;  
77b6			;	; calculate buffer location for this row  
77b6			;  
77b6			;	ld hl, keyscan_table	  
77b6			;kbufr:  ld e, key_cols  
77b6			;kbufc:	inc hl  
77b6			;	dec e  
77b6			;	jr nz, kbufc  
77b6			;	dec d  
77b6			;	jr nz, kbufr  
77b6			;  
77b6			;	; energise row and read columns  
77b6			;  
77b6			;	out (portbdata),a  
77b6			;	in a,(portbdata)  
77b6			;	ld c,a  
77b6			;  
77b6			;  
77b6			;	; save buffer loc  
77b6			;  
77b6			;	ld (keybufptr), hl  
77b6			;  
77b6			;	ld hl, key_scanc  
77b6			;	ld d, key_cols  
77b6			;  
77b6			;	; for each column check each bit mask  
77b6			;  
77b6			;colloop:  
77b6			;	  
77b6			;  
77b6			;	; reset flags for the row   
77b6			;  
77b6			;	ld b,'.'  
77b6			;	and (hl)  
77b6			;	jr z, maskskip  
77b6			;	ld b,'#'  
77b6			;maskskip:  
77b6			;	; save  key state  
77b6			;	push hl  
77b6			;	ld hl, (keybufptr)  
77b6			;	ld (hl), b  
77b6			;	inc hl  
77b6			;	ld (keybufptr), hl  
77b6			;  
77b6			;	; move to next bit mask  
77b6			;	pop hl  
77b6			;	inc hl  
77b6			;  
77b6			;	dec d  
77b6			;	jr nz, colloop  
77b6			;  
77b6			;	ret  
77b6			;  
77b6			;  
77b6			;;  
77b6			; lcd functions  
77b6			;  
77b6			;  
77b6			  
77b6			;if DEBUG_KEY_MATRIX  
77b6			  
77b6			; test function to display hardware view of matrix state  
77b6			  
77b6			matrixold:  
77b6			  
77b6			  
77b6			  
77b6			; reset counter  
77b6 3e 80		ld a, 128  
77b8 d3 c1		out (portbdata),a  
77ba			; scan keyboard row 1  
77ba 3e 00		ld a, 0  
77bc d3 c1		out (portbdata),a  
77be			;ld a, 64  
77be			;out (portbdata),a  
77be 3e 80			ld a, 128  
77c0 21 30 fe			ld hl, keyscan_table_row1  
77c3 cd 1c 78			call .rowscan  
77c6			  
77c6			;ld a, 0  
77c6			;out (portbdata),a  
77c6 3e 40		ld a, 64  
77c8 d3 c1		out (portbdata),a  
77ca 3e 40			ld a, 64  
77cc 21 25 fe			ld hl, keyscan_table_row2  
77cf cd 1c 78			call .rowscan  
77d2			  
77d2 3e 00		ld a, 0  
77d4 d3 c1		out (portbdata),a  
77d6			;ld a, 64  
77d6			;out (portbdata),a  
77d6 3e 20			ld a, 32  
77d8 21 1a fe			ld hl, keyscan_table_row3  
77db cd 1c 78			call .rowscan  
77de			  
77de			;ld a, 0  
77de			;out (portbdata),a  
77de 3e 40		ld a, 64  
77e0 d3 c1		out (portbdata),a  
77e2 3e 10			ld a, 16  
77e4 21 0f fe			ld hl, keyscan_table_row4  
77e7 cd 1c 78			call .rowscan  
77ea			  
77ea			; Display text on first line  
77ea 3e 00		            LD   A, kLCD_Line1  
77ec cd 1a 74		            CALL fLCD_Pos       ;Position cursor to location in A  
77ef 11 30 fe		            LD   DE, keyscan_table_row1  
77f2			            ;LD   DE, MsgHello  
77f2 cd 3c 74		            CALL fLCD_Str       ;Display string pointed to by DE  
77f5			  
77f5			; Display text on second line  
77f5 3e 28		            LD   A, kLCD_Line2  
77f7 cd 1a 74		            CALL fLCD_Pos       ;Position cursor to location in A  
77fa 11 25 fe		            LD   DE, keyscan_table_row2  
77fd cd 3c 74		            CALL fLCD_Str       ;Display string pointed to by DE  
7800 3e 50		            LD   A, kLCD_Line3  
7802 cd 1a 74		            CALL fLCD_Pos       ;Position cursor to location in A  
7805 11 1a fe		            LD   DE, keyscan_table_row3  
7808 cd 3c 74		            CALL fLCD_Str       ;Display string pointed to by DE  
780b 3e 78		            LD   A, kLCD_Line4  
780d cd 1a 74		            CALL fLCD_Pos       ;Position cursor to location in A  
7810 11 0f fe		            LD   DE, keyscan_table_row4  
7813 cd 3c 74		            CALL fLCD_Str       ;Display string pointed to by DE  
7816			  
7816 cd e1 0c			call delay250ms  
7819 c3 07 77			jp matrix  
781c			  
781c			; pass de as row display flags  
781c			.rowscan:   
781c			;	out (portbdata),a  
781c db c1			in a,(portbdata)  
781e 4f				ld c,a  
781f				; reset flags for the row   
781f 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7821 e6 01			and 1  
7823 28 02			jr z, .p1on  
7825 06 23			ld b,'#'  
7827			.p1on:  
7827 70				ld (hl), b  
7828 23				inc hl  
7829			  
7829 06 7e			ld b,KEY_MATRIX_NO_PRESS  
782b 79				ld a,c  
782c e6 02			and 2  
782e			;	bit 0,a  
782e 28 02			jr z, .p2on  
7830 06 23			ld b,'#'  
7832			.p2on:  
7832 70				ld (hl), b  
7833 23				inc hl  
7834			;  
7834 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7836 79				ld a,c  
7837 e6 04			and 4  
7839			;;	bit 0,a  
7839 28 02			jr z, .p3on  
783b 06 23			ld b,'#'  
783d			.p3on:  
783d 70				ld (hl), b  
783e 23				inc hl  
783f			;;  
783f 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7841			;;	bit 0,a  
7841 79				ld a,c  
7842 e6 08			and 8  
7844 28 02			jr z, .p4on  
7846 06 23			ld b,'#'  
7848			.p4on:  
7848 70				ld (hl), b  
7849 23				inc hl  
784a			  
784a 06 7e			ld b,KEY_MATRIX_NO_PRESS  
784c			;;	bit 0,a  
784c 79				ld a,c  
784d e6 10			and 16  
784f 28 02			jr z, .p5on  
7851 06 23			ld b,'#'  
7853			.p5on:  
7853 70				ld (hl), b  
7854 23				inc hl  
7855			; zero term  
7855 06 00			ld b,0  
7857 70				ld (hl), b  
7858			  
7858 c9			.rscandone: ret  
7859			  
7859			;addatohl:  
7859			;  
7859			 ;add   a, l    ; A = A+L  
7859			  ;  ld    l, a    ; L = A+L  
7859			   ; adc   a, h    ; A = A+L+H+carry  
7859			   ; sub   l       ; A = H+carry  
7859			   ; ld    h, a    ; H = H+carry  
7859			  
7859			;ret  
7859			; eof  
# End of file firmware_key_5x10.asm
7859			;include "firmware_key_4x10.asm" 
7859			 
7859			heap_size:    equ heap_end - heap_start 
7859			;eof 
# End of file os_mega.asm
7859
