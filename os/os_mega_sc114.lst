# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 b8 95			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 ..			buildtime: db   "Build: " 
800a					include "romtimestamp.asm" 
800a ..			db '2025-09-09 19:06' 
# End of file romtimestamp.asm
801a 00				   db 0 
801b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
801f			 
801f			 
801f			 
801f			;        nop  
801f			;        nop 
801f			;;	org 05h		; null out bdos call 
801f			; 
801f			;        nop  
801f			;        nop  
801f			;        nop 
801f			;;	org 08h 
801f			;;; 
801f			;;	jp cin		; rst 8 - char in 
801f			;;; 
801f			; 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;        nop 
801f			;	org 010h 
801f			;; 
801f			;	jp cout		; rest 010h  - char out 
801f			;; 
801f			;	org 01bh   
801f			; 
801f			;	;jp  		; rst 01bh   - write string to display 
801f			;	jp str_at_display 
801f			; 
801f			; 
801f			;	org 020h 
801f			; 
801f			;	; jp		 ; rst 020h - read char at screen location 
801f			; 
801f			;	org 028h 
801f			 
801f				; jp		 ; rst 028h  - storage i/o 
801f			 
801f			; 	org 030h 
801f			;	jp break_point_state 
801f			  
801f			; $30  
801f			; org 038h 
801f			; $38 
801f			 
801f			; TODO any more important entry points to add to jump table for easier coding use? 
801f			 
801f			if BASE_KEV = 1  
801f			 
801f				; need to be at $66 for nmi support 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255,0,255,0,255 
801f				db 0,255 
801f				jp nmi 
801f			endif 
801f			 
801f			include "firmware.asm" 
801f			  
801f			; main constants (used here and in firmware)  
801f			  
801f			; TODO have page 0 of storage as bios  
801f			  
801f			Device_A: equ 0h  
801f			Device_B: equ 040h          ; Sound  
801f			  
801f			if BASE_KEV  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_SC114  
801f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			; TODO fixup for CPM  
801f			Device_C: equ 080h          ; Storage and ext cart devices  
801f			endif  
801f			  
801f			Device_D: equ 0c0h             ; Keyboard and LCD  
801f			  
801f			; Odd specific debug points for testing hardware dev  
801f			  
801f			;if DEBUG_LEVEL0  
801f			;	include "debug_level0.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL1  
801f			;	include "debug_level1.asm"  
801f			;endif  
801f			;if DEBUG_LEVEL2  
801f			;	include "debug_level2.asm"  
801f			;endif  
801f			  
801f			  
801f			CALLMONITOR: macro  
801f			;	call break_point_state  
801f			; now use the break point debug vector  
801f				call debug_vector  
801f				endm  
801f			  
801f			MALLOC_1: equ 1        ; from dk88   
801f			MALLOC_2: equ 0           ; broke  
801f			MALLOC_3: equ 0           ; really broke  
801f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801f			  
801f			if BASE_KEV   
801f			;stacksize: equ 256  
801f			; each stack entry is three bytes (type + word)  
801f			stacksize: equ 3*150  
801f			  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 512  
801f			endif  
801f			if BASE_SC114  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			if BASE_CPM  
801f			;tos:	equ 0f000h  
801f			stacksize: equ 256  
801f			STACK_RET_SIZE: equ 64  
801f			STACK_LOOP_SIZE: equ 128  
801f			STACK_DATA_SIZE: equ 256  
801f			endif  
801f			  
801f			;if STORAGE_SE == 0  
801f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801f			;endif  
801f			  
801f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801f			  
801f			STORE_0_AUTORUN: equ $20  
801f			  
801f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801f			  
801f			STORE_0_AUTOFILE: equ $21  
801f			STORE_0_BANKRUN: equ $23  
801f			STORE_0_FILERUN: equ $24  
801f			  
801f			; Block 0 offsets for settings  
801f			  
801f			; if set then skip prompt for start up and accept all  
801f			  
801f			STORE_0_QUICKSTART: equ $25  
801f			  
801f			; Blocks where directory table is held  
801f			  
801f			; Reducing the number of entries increases the max file size  
801f			  
801f			;STORE_DIR_START: equ 1  
801f			;STORE_DIR_END: equ 33  
801f			  
801f			; Blocks from where file data is stored  
801f			  
801f			;STORE_DATA_START: equ STORE_DIR_END + 1  
801f			  
801f			; Block indicators (<32 are data files)  
801f			  
801f			;STORE_BLOCK_CFG: equ $8f       ; config block  
801f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801f			;STORE_BLOCK_FREE: equ $85       ; data block free  
801f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801f			  
801f			  
801f			  
801f			; Directory entry flags  
801f			  
801f			;STORE_DIR_FREE: equ 0  
801f			;STORE_DIR_FILE:  equ 1  
801f			  
801f			; Structure offsets to directory entries  
801f			;STORE_DE_FLAG: equ 0  
801f			;STORE_DE_MAXEXT: equ 1  
801f			;STORE_DE_FILENAME: equ 2  
801f			  
801f			; Structure offsets to block 0  
801f			  
801f			;STORE_BK0_ISFOR: equ 1  
801f			;STORE_BK0_LABEL: equ 3  
801f			  
801f			; memory allocation   
801f			  
801f			chk_stund: equ tos+2           ; underflow check word  
801f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801f			  
801f			; keyscan table needs rows x cols buffer  
801f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801f			  
801f			keyscan_table_row1: equ chk_stovr -key_cols-1  
801f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801f			keyscan_scancol: equ keyscan_table-key_cols  
801f			;keyscan_table_len: equ key_rows*key_cols  
801f			;keybufptr: equ keyscan_table - 2  
801f			;keysymbol: equ keybufptr - 1  
801f			key_held: equ keyscan_scancol-1	; currently held  
801f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801f			key_fa: equ key_repeat_ct -1 ;  
801f			key_fb: equ key_fa -1 ;  
801f			key_fc: equ key_fb -1 ;  
801f			key_fd: equ key_fc -1 ;  
801f			key_face_held: equ key_fd - 1   
801f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801f			  
801f			hardware_config: equ key_face_held - 10  
801f			  
801f			; hardware config switches  
801f			; TODO add bitmasks on includes for hardware  
801f			; high byte for expansion ids  
801f			;     0000 0000  no card inserted  
801f			;     0000 0001  storage card inserted  
801f			;     0000 0010  spi sd card active  
801f			  
801f			;       
801f			; low byte:  
801f			;     0000 0001   4x4 keypad  
801f			;     0000 0010   full keyboard  
801f			;     0000 0011   spi/ext keyboard  
801f			;     0000 0100   20x4 lcd  
801f			;     0000 1000   40x4 lcd  
801f			;     0000 1100   spi/ext display  
801f			;     0001 0000   ide interface available  
801f			  
801f			hardware_word: equ hardware_config - 2  
801f			  
801f			; debug marker - optional display of debug point on the debug screens  
801f			  
801f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801f			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
801f			  
801f			debug_umark: equ parse_vector - 6  ; current user mark  
801f			debug_mark: equ debug_umark - 4    ; internal word debug points  
801f			  
801f			; input_str vars  
801f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801f			input_size: equ input_start -1  ; number of chars  
801f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801f			input_len: equ input_cur_onoff - 5 ; length of current input  
801f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801f			  
801f			; cursor blink rate  
801f			CUR_BLINK_RATE: equ $09  
801f			;CUR_BLINK_RATE: equ 15  
801f			  
801f			key_actual_pressed: equ input_cursor - 1   
801f			key_symbol: equ key_actual_pressed - 1   
801f			key_shift: equ key_symbol - 1   
801f			  
801f			; Display allocation  
801f			  
801f			;display_rows: equ 4     ; move out to mini and mega files  
801f			;display_cols: equ 20  
801f			  
801f			display_fb_len: equ display_rows*display_cols  
801f			  
801f			; primary frame buffer     
801f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801f			; working frame buffers  
801f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801f			display_fb3: equ  display_fb1-display_fb_len - 1  
801f			display_fb2: equ  display_fb3-display_fb_len - 1  
801f			;  
801f			; pointer to active frame buffer  
801f			display_fb_active: equ display_fb2 - 2  
801f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801f			display_write_tmp: equ display_lcde1e2 - 2  
801f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801f			  
801f			;  
801f			  
801f			;; can load into de directory  
801f			cursor_col: equ display_active-1  
801f			cursor_row: equ cursor_col-1  
801f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801f			  
801f			; maths vars  
801f			  
801f			LFSRSeed: equ cursor_shape -20   
801f			randData: equ LFSRSeed - 2  
801f			xrandc: equ randData - 2  
801f			stackstore: equ xrandc - 2  
801f			seed1: equ  stackstore -2   
801f			seed2: equ seed1 - 2  
801f			  
801f			; cf storage vars  
801f			  
801f			iErrorNum:  equ seed2-1         ;Error number  
801f			iErrorReg:  equ iErrorNum -1              ;Error register  
801f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801f			  
801f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801f			  
801f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801f			  
801f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801f			store_tmpid: equ store_tmp3 - 1		; page temp id  
801f			store_tmpext: equ store_tmpid - 1		; file extent temp  
801f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801f			;  
801f			; spi vars  
801f			  
801f			  
801f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801f			spi_device_id: equ spi_device - 1    ; human readable bank number  
801f			  
801f			;;;;; forth cli params  
801f			  
801f			; TODO use a different frame buffer for forth???  
801f			  
801f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801f			  
801f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801f			  
801f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801f			  
801f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801f			  
801f			; os/forth token vars  
801f			  
801f			os_last_cmd: equ os_var_array-255  
801f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801f			os_current_i: equ os_cli_cmd-2  
801f			os_cur_ptr: equ os_current_i-2  
801f			os_word_scratch: equ os_cur_ptr-30  
801f			os_tok_len: equ os_word_scratch - 2  
801f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801f			os_tok_malloc: equ os_tok_ptr - 2  
801f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801f			execscratch: equ os_input-255        ; exec cmd eval buffer  
801f			scratch: equ execscratch-255  
801f			  
801f			os_stack_1: equ scratch - 3       ; stack holding area 1  
801f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
801f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
801f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
801f			  
801f			  
801f			; temp locations for new word processing to save on adding more   
801f			  
801f			os_new_malloc: equ os_stack_4-2  
801f			os_new_parse_len: equ os_new_malloc - 2  
801f			os_new_word_len: equ os_new_parse_len - 2  
801f			os_new_work_ptr: equ os_new_word_len - 2  
801f			os_new_src_ptr: equ os_new_work_ptr - 2  
801f			os_new_exec: equ os_new_src_ptr - 2  
801f			os_new_exec_ptr: equ os_new_exec - 2  
801f			  
801f			; resume memory alloocations....  
801f			  
801f			;os_view_disable: equ os_new_exec_ptr - 1  
801f			os_view_af: equ os_new_exec_ptr - 2  
801f			os_view_hl: equ os_view_af -2  
801f			os_view_de: equ os_view_hl - 2  
801f			os_view_bc: equ os_view_de - 2  
801f			  
801f			; stack checksum word  
801f			if DEBUG_STACK_IMB  
801f				curframe: equ  os_view_de - 5  
801f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			else  
801f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801f			endif  
801f			  
801f			; with data stack could see memory filled with junk. need some memory management   
801f			; malloc and free entry points added  
801f			  
801f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			;heap_end: equ free_list-1  ; Starting address of heap  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			  
801f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801f			heap_end: equ chk_word-1  ; Starting address of heap  
801f			  
801f			  
801f			;if BASE_KEV   
801f			;heap_start: equ 0800eh  ; Starting address of heap  
801f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;heap_start: equ baseram+15  ; Starting address of heap  
801f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801f			;endif  
801f			  
801f			  
801f			;;;;  
801f			  
801f			  
801f			; change below to point to last memory alloc above  
801f			topusermem:  equ   heap_start  
801f			  
801f			;if BASE_KEV   
801f			;baseusermem: equ 08000h  
801f			;endif  
801f			  
801f			;if BASE_SC114  
801f			;;aseusermem:     equ    12  
801f			;baseusermem:     equ    prompt  
801f			;;baseusermem:     equ    endofcode  
801f			;endif  
801f			  
801f			  
801f			; **********************************************************************  
801f			; **  Constants  
801f			; **********************************************************************  
801f			  
801f			; Constants used by this code module  
801f			kDataReg:   EQU Device_D           ;PIO port A data register  
801f			kContReg:   EQU Device_D+2           ;PIO port A control register  
801f			  
801f			  
801f			portbdata:  equ Device_D+1    ; port b data  
801f			portbctl:   equ Device_D+3    ; port b control  
801f			  
801f			  
801f			;KEY_SHIFT:   equ 5  
801f			;KEY_SYMBOLSHIFT:  equ 6  
801f			  
801f			KEY_SHIFTLOCK: equ 4  
801f			  
801f			  
801f			KEY_UP: equ 5  
801f			KEY_NEXTWORD: equ 6  
801f			KEY_PREVWORD: equ 7  
801f			KEY_BS: equ 8  
801f			KEY_TAB:  equ 9  
801f			KEY_DOWN: equ 10  
801f			KEY_LEFT: equ 11  
801f			KEY_RIGHT: equ 12  
801f			KEY_CR:   equ 13  
801f			KEY_HOME: equ 14  
801f			KEY_END: equ 15  
801f			  
801f			KEY_F1: equ 16  
801f			KEY_F2: equ 17  
801f			KEY_F3: equ 18  
801f			KEY_F4: equ 19  
801f			  
801f			KEY_F5: equ 20  
801f			KEY_F6: equ 21  
801f			KEY_F7: equ 22  
801f			KEY_F8: equ 23  
801f			  
801f			KEY_F9: equ 24  
801f			KEY_F10: equ 25  
801f			KEY_F11: equ 26  
801f			KEY_F12: equ 27  
801f			  
801f			;if DEBUG_KEY  
801f			;	KEY_MATRIX_NO_PRESS: equ '.'  
801f			;	KEY_SHIFT:   equ '.'  
801f			;	KEY_SYMBOLSHIFT:  equ '.'  
801f			;else  
801f				KEY_SHIFT:   equ '~'  
801f				KEY_SYMBOLSHIFT:  equ '~'  
801f				KEY_MATRIX_NO_PRESS: equ '~'  
801f			;endi  
801f			  
801f			  
801f			  
801f			  
801f			; Macro to make adding debug marks easier  
801f			  
801f			DMARK: macro str  
801f				push af  
801f				ld a, (.dmark)  
801f				ld (debug_mark),a  
801f				ld a, (.dmark+1)  
801f				ld (debug_mark+1),a  
801f				ld a, (.dmark+2)  
801f				ld (debug_mark+2),a  
801f				jr .pastdmark  
801f			.dmark: db str  
801f			.pastdmark: pop af  
801f			  
801f			endm  
801f			  
801f			  
801f			; macro to detect for stack imbalances  
801f			  
801f			include "stackimbal.asm"  
801f			; Macro and code to detect stock imbalances 
801f			 
801f			SPPUSH: equ 0 
801f			 
801f			; Add a stack frame which can be checked before return 
801f			 
801f			STACKFRAME: macro onoff frame1 frame2 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f						exx 
801f			 
801f						ld de, frame1 
801f						ld a, d 
801f						ld hl, curframe 
801f						call hexout 
801f						ld a, e 
801f						ld hl, curframe+2 
801f						call hexout 
801f			  
801f						ld hl, frame1 
801f						push hl 
801f						ld hl, frame2 
801f						push hl 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			endm 
801f			 
801f			STACKFRAMECHK: macro onoff frame1 frame2 
801f			 
801f					 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						exx 
801f						; check stack frame SP 
801f			 
801f						ld hl, frame2 
801f						pop de   ; frame2 
801f			 
801f						call cmp16 
801f						jr nz, .spnosame 
801f						 
801f			 
801f						ld hl, frame1 
801f						pop de   ; frame1 
801f			 
801f						call cmp16 
801f						jr z, .spfrsame 
801f			 
801f						.spnosame: call showsperror 
801f			 
801f						.spfrsame: nop 
801f			 
801f						exx 
801f					endif 
801f					 
801f				endif 
801f			 
801f			 
801f			endm 
801f			 
801f			 
801f			; for a sub routine, wrap SP collection and comparisons 
801f			 
801f			; Usage: 
801f			; 
801f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801f			 
801f			SAVESP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f						; save current SP 
801f			 
801f						ld (store_sp+(storeword*4)), sp 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			CHECKSP: macro onoff storeword 
801f			 
801f				if DEBUG_STACK_IMB 
801f					if onoff 
801f			 
801f						; save SP after last save 
801f				 
801f						ld (store_sp+(storeword*4)+2), sp 
801f			 
801f						push hl 
801f						ld hl, store_sp+(storeword*4) 
801f						call check_stack_sp  
801f						pop hl 
801f			 
801f			 
801f					endif 
801f					 
801f				endif 
801f			 
801f			endm 
801f			 
801f			if DEBUG_STACK_IMB 
801f			 
801f			check_stack_sp: 
801f					push de 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					push de 
801f			 
801f			 
801f					ld e, (hl) 
801f					inc hl 
801f					ld d, (hl) 
801f					inc hl 
801f			 
801f					pop hl 
801f			 
801f			 
801f					; check to see if the same 
801f			 
801f					call cmp16 
801f					jr z, .spsame 
801f			 
801f					; not same 
801f			 
801f					call showsperror 
801f			.spsame: 
801f			 
801f					pop de 
801f			 
801f					ret 
801f			 
801f			.sperr:  db "Stack imbalance",0 
801f			 
801f			 
801f			showsperror: 
801f			 
801f			 
801f				push hl 
801f				push af 
801f				push de 
801f				call clear_display 
801f				ld de, .sperr 
801f				ld a,0 
801f			;	ld de,os_word_scratch 
801f				call str_at_display 
801f				ld a, display_row_1+17 
801f				ld de, debug_mark 
801f				call str_at_display 
801f				ld a, 0 
801f				ld (curframe+4),a 
801f				ld hl, curframe 
801f				ld de, os_word_scratch 
801f				ld a, display_row_4 
801f				call str_at_display 
801f				call update_display 
801f				;call break_point_state 
801f				call cin_wait 
801f			 
801f			;	ld a, ' ' 
801f			;	ld (os_view_disable), a 
801f				call bp_on 
801f				pop de	 
801f				pop af 
801f				pop hl 
801f				CALLMONITOR 
801f				ret 
801f			 
801f			endif 
801f			 
801f			 
801f			 
801f			; eof 
# End of file stackimbal.asm
801f			  
801f			;TODO macro to calc col and row offset into screen  
801f			  
801f			  
801f			  
801f			hardware_init:  
801f			  
801f				  
801f			  
801f					;ld a, 0  
801f					;ld (hardware_diag), a  
801f			  
801f					; clear all the buffers  
801f			  
801f 21 07 ed				ld hl, display_fb1  
8022 22 c3 eb				ld (display_fb_active), hl  
8025			  
8025 cd ac 8a				call clear_display  
8028			  
8028 21 c5 eb				ld hl, display_fb2  
802b 22 c3 eb				ld (display_fb_active), hl  
802e			  
802e cd ac 8a				call clear_display  
8031			  
8031					; init primary frame buffer area  
8031 21 a8 ed				ld hl, display_fb0  
8034 22 c3 eb				ld (display_fb_active), hl  
8037			  
8037 cd ac 8a				call clear_display  
803a			  
803a			  
803a cd dd e2				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803d			  
803d cd 7f e3			call key_init  
8040 cd ad 80			call storage_init  
8043			  
8043				; setup malloc functions  
8043			  
8043				if MALLOC_1  
8043 cd 7e 90				call  heap_init  
8046				endif  
8046				if MALLOC_4  
8046					call  heap_init  
8046				endif  
8046			  
8046				; init sound hardware if present  
8046			  
8046				if SOUND_ENABLE  
8046					call sound_init  
8046				endif  
8046			  
8046				; lcd test sequence  
8046					  
8046 cd ce 8a			call update_display  
8049 cd f0 89			call delay1s  
804c 3e 2b			ld a,'+'  
804e cd b1 8a			call fill_display  
8051 cd ce 8a			call update_display  
8054 cd f0 89			call delay1s  
8057 3e 2a			ld a,'*'  
8059 cd b1 8a			call fill_display  
805c cd ce 8a			call update_display  
805f cd f0 89			call delay1s  
8062 3e 2d			ld a,'-'  
8064 cd b1 8a			call fill_display  
8067 cd ce 8a			call update_display  
806a cd f0 89			call delay1s  
806d			  
806d			; boot splash screen  
806d			if display_cols == 20	  
806d			        ld a, display_row_1    
806d			else  
806d 3e 0a		        ld a, display_row_1 +10   
806f			endif  
806f 11 25 95			ld de, prom_bootmsg  
8072 cd be 8a			call str_at_display  
8075 cd ce 8a			call update_display  
8078			  
8078			  
8078 cd f0 89			call delay1s  
807b cd f0 89			call delay1s  
807e			if display_cols == 20	  
807e			            LD   A, display_row_3+2  
807e			else  
807e 3e 5c		            LD   A, display_row_3+12  
8080			endif  
8080 11 3a 95			ld de, prom_bootmsg1  
8083 cd be 8a			call str_at_display  
8086			; display debug level  
8086 3e 78		            LD   A, display_row_4  
8088 11 1b 80			ld de, debuglevel  
808b cd be 8a			call str_at_display  
808e			  
808e cd ce 8a			call update_display  
8091 cd f0 89			call delay1s  
8094 cd f0 89			call delay1s  
8097			  
8097			;	ld a, display_row_4+3  
8097			;	ld de, bootmsg2  
8097			;	call str_at_display  
8097			;	call update_display  
8097			;	call delay1s  
8097			;	call delay1s  
8097			  
8097			; debug mark setup  
8097			  
8097 3e 5f		ld a, '_'  
8099 32 62 ee		ld (debug_mark),a  
809c 32 63 ee		ld (debug_mark+1),a  
809f 32 64 ee		ld (debug_mark+2),a  
80a2 3e 00		ld a,0  
80a4 32 65 ee		ld (debug_mark+3),a  
80a7 32 66 ee		ld (debug_umark),a  
80aa			  
80aa c9					ret  
80ab			  
80ab			  
80ab			;bootmsg2:	db "Firmware v0.1",0  
80ab			  
80ab			; a 4x20 lcd  
80ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ab			  
80ab			;if display_cols == 20  
80ab			;	include "firmware_lcd_4x20.asm"  
80ab			;endif  
80ab			  
80ab			;if display_cols == 40  
80ab			;	include "firmware_lcd_4x40.asm"  
80ab			;endif  
80ab			  
80ab			;  
80ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ab			; TODO abstract the bit bang video out interface for dual display  
80ab			; TODO wire video out to tx pin on rc2014 bus  
80ab			  
80ab			; must supply cin, and cin_wait for low level hardware abstraction   
80ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ab			; test scancode  
80ab			  
80ab			;;;;;  
80ab			;;;  
80ab			; Moved out to mini and maxi versions  
80ab			;  
80ab			; include "firmware_key_4x4.asm"  
80ab			; using existing 4 wire x 4 resistor array for input  
80ab			;include "firmware_key_4x10.asm"  
80ab			; need to mod the board for 5 rows due to resistor array  
80ab			;include "firmware_key_5x10.asm"  
80ab			  
80ab			; storage hardware interface  
80ab			  
80ab			; use microchip serial eeprom for storage  
80ab			  
80ab			  
80ab			if STORAGE_SE  
80ab				include "firmware_spi.asm"  
80ab				include "firmware_seeprom.asm"  
80ab			else  
80ab			   ; create some stubs for the labels  
80ab c9			se_readbyte: ret  
80ac c9			se_writebyte: ret  
80ad c9			storage_init: ret  
80ae			  
80ae			endif  
80ae			  
80ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80ae			;include "firmware_cf.asm"  
80ae			  
80ae			; load up high level storage hardward abstractions  
80ae			include "firmware_storage.asm"  
80ae			 
80ae			; persisent storage hardware abstraction layer  
80ae			 
80ae			 
80ae			 
80ae			; Block 0 on storage is a config state 
80ae			 
80ae			 
80ae			 
80ae			; TODO add read phy block and write phy block functions 
80ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80ae			 
80ae			; Abstraction layer  
80ae			 
80ae			; Logocial block size is same size as physical size - using tape concept 
80ae			 
80ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80ae			 
80ae			 
80ae			 
80ae			; Filesystem layout (Logical layout) 
80ae			; 
80ae			; Block 0 - Bank config  
80ae			; 
80ae			;      Byte - 0 file id counter 
80ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80ae			;      Byte - 3-20 zero terminated bank label 
80ae			; 
80ae			; Block 1 > File storage 
80ae			; 
80ae			;      Byte 0 file id    - block 0 file details 
80ae			;      Byte 1 block id - block 0 is file  
80ae			;            Byte 2-15 - File name 
80ae			; 
80ae			;       - to end of block data 
80ae			; 
80ae			 
80ae			; Get ID for the file named in pointer held HL 
80ae			; Returns ID in HL = 255 if no file found 
80ae			 
80ae			storage_getid: 
80ae			 
80ae 22 6a ea			ld (store_tmp1), hl 
80b1			 
80b1				if DEBUG_STORESE 
80b1					DMARK "SGI" 
80b1 f5				push af  
80b2 3a c6 80			ld a, (.dmark)  
80b5 32 62 ee			ld (debug_mark),a  
80b8 3a c7 80			ld a, (.dmark+1)  
80bb 32 63 ee			ld (debug_mark+1),a  
80be 3a c8 80			ld a, (.dmark+2)  
80c1 32 64 ee			ld (debug_mark+2),a  
80c4 18 03			jr .pastdmark  
80c6 ..			.dmark: db "SGI"  
80c9 f1			.pastdmark: pop af  
80ca			endm  
# End of macro DMARK
80ca					CALLMONITOR 
80ca cd 6f ee			call debug_vector  
80cd				endm  
# End of macro CALLMONITOR
80cd				endif 
80cd				; get block 0 and set counter for number of files to scan 
80cd			 
80cd cd 35 82			call storage_get_block_0 
80d0			 
80d0 3a 71 ea			ld a, (store_page) 
80d3 47				ld b, a 
80d4			 
80d4				; get extent 0 of each file id 
80d4			 
80d4				if DEBUG_STORESE 
80d4					DMARK "SGc" 
80d4 f5				push af  
80d5 3a e9 80			ld a, (.dmark)  
80d8 32 62 ee			ld (debug_mark),a  
80db 3a ea 80			ld a, (.dmark+1)  
80de 32 63 ee			ld (debug_mark+1),a  
80e1 3a eb 80			ld a, (.dmark+2)  
80e4 32 64 ee			ld (debug_mark+2),a  
80e7 18 03			jr .pastdmark  
80e9 ..			.dmark: db "SGc"  
80ec f1			.pastdmark: pop af  
80ed			endm  
# End of macro DMARK
80ed					CALLMONITOR 
80ed cd 6f ee			call debug_vector  
80f0				endm  
# End of macro CALLMONITOR
80f0				endif 
80f0 60			.getloop:	ld h, b 
80f1 2e 00				ld l, 0 
80f3 c5					push bc 
80f4			 
80f4 11 71 ea				ld de, store_page 
80f7				if DEBUG_STORESE 
80f7					DMARK "SGr" 
80f7 f5				push af  
80f8 3a 0c 81			ld a, (.dmark)  
80fb 32 62 ee			ld (debug_mark),a  
80fe 3a 0d 81			ld a, (.dmark+1)  
8101 32 63 ee			ld (debug_mark+1),a  
8104 3a 0e 81			ld a, (.dmark+2)  
8107 32 64 ee			ld (debug_mark+2),a  
810a 18 03			jr .pastdmark  
810c ..			.dmark: db "SGr"  
810f f1			.pastdmark: pop af  
8110			endm  
# End of macro DMARK
8110					CALLMONITOR 
8110 cd 6f ee			call debug_vector  
8113				endm  
# End of macro CALLMONITOR
8113				endif 
8113 cd d7 86				call storage_read 
8116 cd ff 8c				call ishlzero 
8119 28 2d				jr z, .gap 
811b					 
811b					; have a file name read. Is it one we want. 
811b			 
811b 2a 6a ea				ld hl, (store_tmp1) 
811e 11 74 ea				ld de, store_page+3   ; file name 
8121			 
8121				if DEBUG_STORESE 
8121					DMARK "SGc" 
8121 f5				push af  
8122 3a 36 81			ld a, (.dmark)  
8125 32 62 ee			ld (debug_mark),a  
8128 3a 37 81			ld a, (.dmark+1)  
812b 32 63 ee			ld (debug_mark+1),a  
812e 3a 38 81			ld a, (.dmark+2)  
8131 32 64 ee			ld (debug_mark+2),a  
8134 18 03			jr .pastdmark  
8136 ..			.dmark: db "SGc"  
8139 f1			.pastdmark: pop af  
813a			endm  
# End of macro DMARK
813a					CALLMONITOR 
813a cd 6f ee			call debug_vector  
813d				endm  
# End of macro CALLMONITOR
813d				endif 
813d cd 66 90				call strcmp 
8140 20 06				jr nz, .gap   ; not this one 
8142			 
8142 c1				        pop bc 
8143			 
8143 26 00				ld h, 0 
8145 68					ld l, b 
8146 18 22				jr .getdone 
8148						 
8148			 
8148			 
8148			 
8148			.gap: 
8148				if DEBUG_STORESE 
8148					DMARK "SGg" 
8148 f5				push af  
8149 3a 5d 81			ld a, (.dmark)  
814c 32 62 ee			ld (debug_mark),a  
814f 3a 5e 81			ld a, (.dmark+1)  
8152 32 63 ee			ld (debug_mark+1),a  
8155 3a 5f 81			ld a, (.dmark+2)  
8158 32 64 ee			ld (debug_mark+2),a  
815b 18 03			jr .pastdmark  
815d ..			.dmark: db "SGg"  
8160 f1			.pastdmark: pop af  
8161			endm  
# End of macro DMARK
8161					CALLMONITOR 
8161 cd 6f ee			call debug_vector  
8164				endm  
# End of macro CALLMONITOR
8164				endif 
8164			 
8164 c1					pop bc 
8165 10 89				djnz .getloop 
8167 21 ff 00				ld hl, 255 
816a			.getdone: 
816a			 
816a				if DEBUG_STORESE 
816a					DMARK "SGe" 
816a f5				push af  
816b 3a 7f 81			ld a, (.dmark)  
816e 32 62 ee			ld (debug_mark),a  
8171 3a 80 81			ld a, (.dmark+1)  
8174 32 63 ee			ld (debug_mark+1),a  
8177 3a 81 81			ld a, (.dmark+2)  
817a 32 64 ee			ld (debug_mark+2),a  
817d 18 03			jr .pastdmark  
817f ..			.dmark: db "SGe"  
8182 f1			.pastdmark: pop af  
8183			endm  
# End of macro DMARK
8183					CALLMONITOR 
8183 cd 6f ee			call debug_vector  
8186				endm  
# End of macro CALLMONITOR
8186				endif 
8186			 
8186 c9				ret 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			 
8187			; Read Block 
8187			; ---------- 
8187			; 
8187			; With current bank 
8187			;  
8187			; Get block number to read 
8187			; Load physical blocks starting at start block into buffer 
8187			 
8187			; de points to buffer to use 
8187			; hl holds logical block number  
8187			 
8187			storage_read_block: 
8187			 
8187				; TODO bank selection 
8187			 
8187				; for each of the physical blocks read it into the buffer 
8187 06 40			ld b, STORE_BLOCK_PHY 
8189			 
8189				if DEBUG_STORESE 
8189 d5					push de 
818a				endif 
818a				 
818a			.rl1:    
818a			 
818a				; read physical block at hl into de 
818a			        ; increment hl and de to next read position on exit 
818a			 
818a e5				push hl 
818b d5				push de	 
818c c5				push bc 
818d			;	if DEBUG_STORESE 
818d			;		push af 
818d			;		ld a, 'R' 
818d			;		ld (debug_mark),a 
818d			;		pop af 
818d			;		CALLMONITOR 
818d			;	endif 
818d cd ab 80			call se_readbyte 
8190			;	if DEBUG_STORESE 
8190			;		ld a,(spi_portbyte) 
8190			;		ld l, a 
8190			;		push af 
8190			;		ld a, '1' 
8190			;		ld (debug_mark),a 
8190			;		pop af 
8190			;		CALLMONITOR 
8190			;	endif 
8190 c1				pop bc 
8191 d1				pop de 
8192 e1				pop hl 
8193 12				ld (de),a 
8194 23				inc hl 
8195 13				inc de 
8196			 
8196			;	if DEBUG_STORESE 
8196			;		push af 
8196			;		ld a, 'r' 
8196			;		ld (debug_mark),a 
8196			;		pop af 
8196			;		CALLMONITOR 
8196			;	endif 
8196			 
8196 10 f2			djnz .rl1 
8198			 
8198				if DEBUG_STORESE 
8198					DMARK "SRB" 
8198 f5				push af  
8199 3a ad 81			ld a, (.dmark)  
819c 32 62 ee			ld (debug_mark),a  
819f 3a ae 81			ld a, (.dmark+1)  
81a2 32 63 ee			ld (debug_mark+1),a  
81a5 3a af 81			ld a, (.dmark+2)  
81a8 32 64 ee			ld (debug_mark+2),a  
81ab 18 03			jr .pastdmark  
81ad ..			.dmark: db "SRB"  
81b0 f1			.pastdmark: pop af  
81b1			endm  
# End of macro DMARK
81b1 d1					pop de 
81b2			; 
81b2			;		push af 
81b2			;		ld a, 'R' 
81b2			;		ld (debug_mark),a 
81b2			;		pop af 
81b2					CALLMONITOR 
81b2 cd 6f ee			call debug_vector  
81b5				endm  
# End of macro CALLMONITOR
81b5				endif 
81b5 c9				ret	 
81b6				 
81b6			 
81b6			; File Size 
81b6			; --------- 
81b6			; 
81b6			;   hl file id 
81b6			; 
81b6			;  returns in hl the number of blocks 
81b6			 
81b6			storage_file_size: 
81b6 5d				ld e, l 
81b7 16 00			ld d, 0 
81b9 21 40 00			ld hl, STORE_BLOCK_PHY 
81bc					if DEBUG_FORTH_WORDS 
81bc						DMARK "SIZ" 
81bc f5				push af  
81bd 3a d1 81			ld a, (.dmark)  
81c0 32 62 ee			ld (debug_mark),a  
81c3 3a d2 81			ld a, (.dmark+1)  
81c6 32 63 ee			ld (debug_mark+1),a  
81c9 3a d3 81			ld a, (.dmark+2)  
81cc 32 64 ee			ld (debug_mark+2),a  
81cf 18 03			jr .pastdmark  
81d1 ..			.dmark: db "SIZ"  
81d4 f1			.pastdmark: pop af  
81d5			endm  
# End of macro DMARK
81d5						CALLMONITOR 
81d5 cd 6f ee			call debug_vector  
81d8				endm  
# End of macro CALLMONITOR
81d8					endif 
81d8 cd b3 84			call storage_findnextid 
81db			 
81db cd ff 8c			call ishlzero 
81de			;	ld a, l 
81de			;	add h 
81de			;	cp 0 
81de c8				ret z			; block not found so EOF 
81df			 
81df 11 71 ea			ld de, store_page 
81e2 cd 87 81			call storage_read_block 
81e5			 
81e5 3a 73 ea			ld a, (store_page+2)	 ; get extent count 
81e8 6f				ld l, a 
81e9 26 00			ld h, 0 
81eb c9			 	ret 
81ec			 
81ec			 
81ec			; Write Block 
81ec			; ----------- 
81ec			; 
81ec			; With current bank 
81ec			;  
81ec			; Get block number to write 
81ec			; Write physical blocks starting at start block from buffer 
81ec			  
81ec			storage_write_block: 
81ec				; TODO bank selection 
81ec			 
81ec				; for each of the physical blocks read it into the buffer 
81ec 06 40			ld b, STORE_BLOCK_PHY 
81ee			 
81ee				if DEBUG_STORESE 
81ee					DMARK "SWB" 
81ee f5				push af  
81ef 3a 03 82			ld a, (.dmark)  
81f2 32 62 ee			ld (debug_mark),a  
81f5 3a 04 82			ld a, (.dmark+1)  
81f8 32 63 ee			ld (debug_mark+1),a  
81fb 3a 05 82			ld a, (.dmark+2)  
81fe 32 64 ee			ld (debug_mark+2),a  
8201 18 03			jr .pastdmark  
8203 ..			.dmark: db "SWB"  
8206 f1			.pastdmark: pop af  
8207			endm  
# End of macro DMARK
8207			 
8207					;push af 
8207					;ld a, 'W' 
8207					;ld (debug_mark),a 
8207					;pop af 
8207					CALLMONITOR 
8207 cd 6f ee			call debug_vector  
820a				endm  
# End of macro CALLMONITOR
820a				endif 
820a			 
820a			; might not be working 
820a			;	call se_writepage 
820a			 
820a			;	ret 
820a			; 
820a			 
820a			 
820a			 
820a			.wl1:    
820a			 
820a				; read physical block at hl into de 
820a			        ; increment hl and de to next read position on exit 
820a			 
820a e5				push hl 
820b d5				push de	 
820c c5				push bc 
820d 1a				ld a,(de) 
820e				;if DEBUG_STORESE 
820e			;		push af 
820e			;		ld a, 'W' 
820e			;		ld (debug_mark),a 
820e			;		pop af 
820e			;		CALLMONITOR 
820e			;	endif 
820e cd ac 80			call se_writebyte 
8211			;	call delay250ms 
8211			;	nop 
8211			;	nop 
8211			;	nop 
8211			;	if DEBUG_STORESE 
8211			;		push af 
8211			;		ld a, 'w' 
8211			;		ld (debug_mark),a 
8211			;		pop af 
8211			;		CALLMONITOR 
8211			;	endif 
8211 c1				pop bc 
8212 d1				pop de 
8213 e1				pop hl 
8214 23				inc hl 
8215 13				inc de 
8216			 
8216			 
8216 10 f2			djnz .wl1 
8218			 
8218				if DEBUG_STORESE 
8218					DMARK "SW2" 
8218 f5				push af  
8219 3a 2d 82			ld a, (.dmark)  
821c 32 62 ee			ld (debug_mark),a  
821f 3a 2e 82			ld a, (.dmark+1)  
8222 32 63 ee			ld (debug_mark+1),a  
8225 3a 2f 82			ld a, (.dmark+2)  
8228 32 64 ee			ld (debug_mark+2),a  
822b 18 03			jr .pastdmark  
822d ..			.dmark: db "SW2"  
8230 f1			.pastdmark: pop af  
8231			endm  
# End of macro DMARK
8231			 
8231					;push af 
8231					;ld a, 'W' 
8231					;ld (debug_mark),a 
8231					;pop af 
8231					CALLMONITOR 
8231 cd 6f ee			call debug_vector  
8234				endm  
# End of macro CALLMONITOR
8234				endif 
8234 c9				ret	 
8235			 
8235			; Init bank 
8235			; --------- 
8235			; 
8235			; With current bank 
8235			; 
8235			; Setup block 0 config 
8235			;     Set 0 file id counter 
8235			;     Set formatted byte pattern 
8235			;     Zero out bank label 
8235			;      
8235			; For every logical block write 0-1 byte as null 
8235			 
8235			storage_get_block_0: 
8235			 
8235				; TODO check presence 
8235			 
8235				; get block 0 config 
8235			 
8235 21 00 00			ld hl, 0 
8238 11 71 ea			ld de, store_page 
823b cd 87 81			call storage_read_block 
823e			 
823e				if DEBUG_STORESE 
823e					DMARK "SB0" 
823e f5				push af  
823f 3a 53 82			ld a, (.dmark)  
8242 32 62 ee			ld (debug_mark),a  
8245 3a 54 82			ld a, (.dmark+1)  
8248 32 63 ee			ld (debug_mark+1),a  
824b 3a 55 82			ld a, (.dmark+2)  
824e 32 64 ee			ld (debug_mark+2),a  
8251 18 03			jr .pastdmark  
8253 ..			.dmark: db "SB0"  
8256 f1			.pastdmark: pop af  
8257			endm  
# End of macro DMARK
8257 11 71 ea				ld de, store_page 
825a			;		push af 
825a			;		ld a, 'i' 
825a			;		ld (debug_mark),a 
825a			;		pop af 
825a					CALLMONITOR 
825a cd 6f ee			call debug_vector  
825d				endm  
# End of macro CALLMONITOR
825d				endif 
825d			 
825d				; is this area formatted? 
825d			 
825d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
825d 2a 72 ea			ld hl, (store_page+1) 
8260 3e 80			ld a,0x80 
8262 bd				cp l 
8263 20 22			jr nz, .ininotformatted 
8265				; do a double check 
8265 3e 27			ld a, 0x27 
8267 bc				cp h 
8268 20 1d			jr nz, .ininotformatted 
826a			 
826a				; formatted then 
826a			 
826a				if DEBUG_STORESE 
826a					DMARK "SB1" 
826a f5				push af  
826b 3a 7f 82			ld a, (.dmark)  
826e 32 62 ee			ld (debug_mark),a  
8271 3a 80 82			ld a, (.dmark+1)  
8274 32 63 ee			ld (debug_mark+1),a  
8277 3a 81 82			ld a, (.dmark+2)  
827a 32 64 ee			ld (debug_mark+2),a  
827d 18 03			jr .pastdmark  
827f ..			.dmark: db "SB1"  
8282 f1			.pastdmark: pop af  
8283			endm  
# End of macro DMARK
8283					;push af 
8283					;ld a, 'I' 
8283					;ld (debug_mark),a 
8283					;pop af 
8283					CALLMONITOR 
8283 cd 6f ee			call debug_vector  
8286				endm  
# End of macro CALLMONITOR
8286				endif 
8286 c9				ret 
8287			 
8287			.ininotformatted: 
8287				; bank not formatted so poke various bits to make sure 
8287			 
8287				if DEBUG_STORESE 
8287					DMARK "SB2" 
8287 f5				push af  
8288 3a 9c 82			ld a, (.dmark)  
828b 32 62 ee			ld (debug_mark),a  
828e 3a 9d 82			ld a, (.dmark+1)  
8291 32 63 ee			ld (debug_mark+1),a  
8294 3a 9e 82			ld a, (.dmark+2)  
8297 32 64 ee			ld (debug_mark+2),a  
829a 18 03			jr .pastdmark  
829c ..			.dmark: db "SB2"  
829f f1			.pastdmark: pop af  
82a0			endm  
# End of macro DMARK
82a0					;push af 
82a0					;ld a, 'f' 
82a0					;ld (debug_mark),a 
82a0					;pop af 
82a0					CALLMONITOR 
82a0 cd 6f ee			call debug_vector  
82a3				endm  
# End of macro CALLMONITOR
82a3				endif 
82a3			 
82a3 cd b4 89			call storage_clear_page 
82a6			 
82a6 21 71 ea			ld hl, store_page 
82a9			;	ld a, 0 
82a9				 
82a9 36 00			ld (hl),0   ; reset file counter 
82ab			 
82ab 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82ae 22 72 ea		 	ld (store_page+1), hl	 
82b1			 
82b1				; set default label 
82b1			 
82b1 21 4a 83			ld hl, .defaultbanklabl 
82b4 11 74 ea		 	ld de, store_page+3 
82b7 01 0f 00			ld bc, 15 
82ba ed b0			ldir 
82bc			 
82bc				; Append the current bank id 
82bc 21 7d ea			ld hl, store_page+3+9 
82bf 3a 56 ea			ld a, (spi_device_id) 
82c2 77				ld (hl), a 
82c3			 
82c3				; save default page 0 
82c3			 
82c3 21 00 00			ld hl, 0 
82c6 11 71 ea			ld de, store_page 
82c9				if DEBUG_STORESE 
82c9					DMARK "SB3" 
82c9 f5				push af  
82ca 3a de 82			ld a, (.dmark)  
82cd 32 62 ee			ld (debug_mark),a  
82d0 3a df 82			ld a, (.dmark+1)  
82d3 32 63 ee			ld (debug_mark+1),a  
82d6 3a e0 82			ld a, (.dmark+2)  
82d9 32 64 ee			ld (debug_mark+2),a  
82dc 18 03			jr .pastdmark  
82de ..			.dmark: db "SB3"  
82e1 f1			.pastdmark: pop af  
82e2			endm  
# End of macro DMARK
82e2			;		push af 
82e2			;		ld a, 'F' 
82e2			;		ld (debug_mark),a 
82e2			;		pop af 
82e2					CALLMONITOR 
82e2 cd 6f ee			call debug_vector  
82e5				endm  
# End of macro CALLMONITOR
82e5				endif 
82e5 cd ec 81			call storage_write_block 
82e8				if DEBUG_STORESE 
82e8					DMARK "SB4" 
82e8 f5				push af  
82e9 3a fd 82			ld a, (.dmark)  
82ec 32 62 ee			ld (debug_mark),a  
82ef 3a fe 82			ld a, (.dmark+1)  
82f2 32 63 ee			ld (debug_mark+1),a  
82f5 3a ff 82			ld a, (.dmark+2)  
82f8 32 64 ee			ld (debug_mark+2),a  
82fb 18 03			jr .pastdmark  
82fd ..			.dmark: db "SB4"  
8300 f1			.pastdmark: pop af  
8301			endm  
# End of macro DMARK
8301			;		push af 
8301			;		ld a, '>' 
8301			;		ld (debug_mark),a 
8301			;		pop af 
8301					CALLMONITOR 
8301 cd 6f ee			call debug_vector  
8304				endm  
# End of macro CALLMONITOR
8304				endif 
8304			 
8304			;	nop 
8304			;	nop 
8304			;	nop 
8304			 
8304				; now set 0 in every page to mark as a free block 
8304			 
8304 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8306 21 40 00			ld hl, STORE_BLOCK_PHY 
8309			 
8309 3e 00		.setmark1:   	ld a,0 
830b e5					push hl 
830c c5					push bc 
830d cd ac 80				call se_writebyte 
8310 3e 0a			ld a, 10 
8312 cd d5 89			call aDelayInMS 
8315 23				inc hl 
8316 cd ac 80				call se_writebyte 
8319 3e 0a			ld a, 10 
831b cd d5 89			call aDelayInMS 
831e 2b				dec hl 
831f c1					pop bc 
8320 e1					pop hl 
8321 3e 40				ld a, STORE_BLOCK_PHY 
8323 cd d6 8c				call addatohl 
8326 10 e1				djnz .setmark1 
8328			 
8328 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
832a 3e 00		.setmark2:   	ld a,0 
832c e5					push hl 
832d c5					push bc 
832e cd ac 80				call se_writebyte 
8331 3e 0a			ld a, 10 
8333 cd d5 89			call aDelayInMS 
8336 23				inc hl 
8337 cd ac 80				call se_writebyte 
833a 3e 0a			ld a, 10 
833c cd d5 89			call aDelayInMS 
833f 2b				dec hl 
8340 c1					pop bc 
8341 e1					pop hl 
8342 3e 40				ld a, STORE_BLOCK_PHY 
8344 cd d6 8c				call addatohl 
8347 10 e1				djnz .setmark2 
8349			 
8349					 
8349			 
8349			 
8349 c9				ret 
834a			 
834a			 
834a			 
834a			 
834a .. 00		.defaultbanklabl:   db "BankLabel_",0 
8355			 
8355			 
8355			 
8355			; Label Bank 
8355			; ---------- 
8355			; 
8355			; With current bank 
8355			; Read block 0 
8355			; Set label 
8355			; Write block 0 
8355			 
8355			; label str pointer in hl 
8355			 
8355			storage_label:     
8355			 
8355				if DEBUG_STORESE 
8355					DMARK "LBL" 
8355 f5				push af  
8356 3a 6a 83			ld a, (.dmark)  
8359 32 62 ee			ld (debug_mark),a  
835c 3a 6b 83			ld a, (.dmark+1)  
835f 32 63 ee			ld (debug_mark+1),a  
8362 3a 6c 83			ld a, (.dmark+2)  
8365 32 64 ee			ld (debug_mark+2),a  
8368 18 03			jr .pastdmark  
836a ..			.dmark: db "LBL"  
836d f1			.pastdmark: pop af  
836e			endm  
# End of macro DMARK
836e					CALLMONITOR 
836e cd 6f ee			call debug_vector  
8371				endm  
# End of macro CALLMONITOR
8371				endif 
8371			 
8371 e5				push hl 
8372			 
8372 cd 35 82			call storage_get_block_0 
8375			 
8375				; set default label 
8375			 
8375 e1				pop hl 
8376			 
8376 11 74 ea		 	ld de, store_page+3 
8379 01 0f 00			ld bc, 15 
837c				if DEBUG_STORESE 
837c					DMARK "LB3" 
837c f5				push af  
837d 3a 91 83			ld a, (.dmark)  
8380 32 62 ee			ld (debug_mark),a  
8383 3a 92 83			ld a, (.dmark+1)  
8386 32 63 ee			ld (debug_mark+1),a  
8389 3a 93 83			ld a, (.dmark+2)  
838c 32 64 ee			ld (debug_mark+2),a  
838f 18 03			jr .pastdmark  
8391 ..			.dmark: db "LB3"  
8394 f1			.pastdmark: pop af  
8395			endm  
# End of macro DMARK
8395					CALLMONITOR 
8395 cd 6f ee			call debug_vector  
8398				endm  
# End of macro CALLMONITOR
8398				endif 
8398 ed b0			ldir 
839a				; save default page 0 
839a			 
839a 21 00 00			ld hl, 0 
839d 11 71 ea			ld de, store_page 
83a0				if DEBUG_STORESE 
83a0					DMARK "LBW" 
83a0 f5				push af  
83a1 3a b5 83			ld a, (.dmark)  
83a4 32 62 ee			ld (debug_mark),a  
83a7 3a b6 83			ld a, (.dmark+1)  
83aa 32 63 ee			ld (debug_mark+1),a  
83ad 3a b7 83			ld a, (.dmark+2)  
83b0 32 64 ee			ld (debug_mark+2),a  
83b3 18 03			jr .pastdmark  
83b5 ..			.dmark: db "LBW"  
83b8 f1			.pastdmark: pop af  
83b9			endm  
# End of macro DMARK
83b9					CALLMONITOR 
83b9 cd 6f ee			call debug_vector  
83bc				endm  
# End of macro CALLMONITOR
83bc				endif 
83bc cd ec 81			call storage_write_block 
83bf			 
83bf c9				ret 
83c0			 
83c0			 
83c0			 
83c0			; Read Block 0 - Config 
83c0			; --------------------- 
83c0			; 
83c0			; With current bank 
83c0			; Call presence test 
83c0			;    If not present format/init bank  
83c0			; Read block 0  
83c0			;  
83c0			 
83c0			 
83c0			; Dir 
83c0			; --- 
83c0			; 
83c0			; With current bank 
83c0			; Load Block 0 Config 
83c0			; Get max file id number 
83c0			; For each logical block 
83c0			;    Read block read byte 2 
83c0			;      if first block of file 
83c0			;         Display file name 
83c0			;         Display type flags for file 
83c0			;        
83c0			 
83c0			; moving to words as this requires stack control 
83c0			 
83c0			 
83c0			; Delete File 
83c0			; ----------- 
83c0			; 
83c0			; With current bank 
83c0			; 
83c0			; Load Block 0 Config 
83c0			; Get max file id number 
83c0			; For each logical block 
83c0			;    Read block file id 
83c0			;      If first block of file and dont have file id 
83c0			;         if file to delete 
83c0			;         Save file id 
83c0			;         Null file id 
83c0			;         Write this block back 
83c0			;      If file id is one saved 
83c0			;         Null file id 
83c0			;         Write this block back 
83c0			 
83c0			 
83c0			.se_done: 
83c0 e1				pop hl 
83c1 c9				ret 
83c2			 
83c2			storage_erase: 
83c2			 
83c2				; hl contains the file id 
83c2			 
83c2 5d				ld e, l 
83c3 16 00			ld d, 0 
83c5 21 40 00			ld hl, STORE_BLOCK_PHY 
83c8					if DEBUG_FORTH_WORDS 
83c8						DMARK "ERA" 
83c8 f5				push af  
83c9 3a dd 83			ld a, (.dmark)  
83cc 32 62 ee			ld (debug_mark),a  
83cf 3a de 83			ld a, (.dmark+1)  
83d2 32 63 ee			ld (debug_mark+1),a  
83d5 3a df 83			ld a, (.dmark+2)  
83d8 32 64 ee			ld (debug_mark+2),a  
83db 18 03			jr .pastdmark  
83dd ..			.dmark: db "ERA"  
83e0 f1			.pastdmark: pop af  
83e1			endm  
# End of macro DMARK
83e1						CALLMONITOR 
83e1 cd 6f ee			call debug_vector  
83e4				endm  
# End of macro CALLMONITOR
83e4					endif 
83e4 cd b3 84			call storage_findnextid 
83e7 cd ff 8c			call ishlzero 
83ea c8				ret z 
83eb			 
83eb e5				push hl 
83ec			 
83ec				; TODO check file not found 
83ec			 
83ec 11 71 ea			ld de, store_page 
83ef cd 87 81			call storage_read_block 
83f2			 
83f2 cd ff 8c			call ishlzero 
83f5 ca c0 83			jp z,.se_done 
83f8			 
83f8					if DEBUG_FORTH_WORDS 
83f8						DMARK "ER1" 
83f8 f5				push af  
83f9 3a 0d 84			ld a, (.dmark)  
83fc 32 62 ee			ld (debug_mark),a  
83ff 3a 0e 84			ld a, (.dmark+1)  
8402 32 63 ee			ld (debug_mark+1),a  
8405 3a 0f 84			ld a, (.dmark+2)  
8408 32 64 ee			ld (debug_mark+2),a  
840b 18 03			jr .pastdmark  
840d ..			.dmark: db "ER1"  
8410 f1			.pastdmark: pop af  
8411			endm  
# End of macro DMARK
8411						CALLMONITOR 
8411 cd 6f ee			call debug_vector  
8414				endm  
# End of macro CALLMONITOR
8414					endif 
8414 3a 71 ea			ld a, (store_page)	; get file id 
8417 32 65 ea			ld (store_tmpid), a 
841a			 
841a 3a 73 ea			ld a, (store_page+2)    ; get count of extends 
841d 32 64 ea			ld (store_tmpext), a 
8420			 
8420				; wipe file header 
8420			 
8420 e1				pop hl 
8421 3e 00			ld a, 0 
8423 32 71 ea			ld (store_page), a 
8426 32 72 ea			ld (store_page+1),a 
8429 11 71 ea			ld de, store_page 
842c					if DEBUG_FORTH_WORDS 
842c						DMARK "ER2" 
842c f5				push af  
842d 3a 41 84			ld a, (.dmark)  
8430 32 62 ee			ld (debug_mark),a  
8433 3a 42 84			ld a, (.dmark+1)  
8436 32 63 ee			ld (debug_mark+1),a  
8439 3a 43 84			ld a, (.dmark+2)  
843c 32 64 ee			ld (debug_mark+2),a  
843f 18 03			jr .pastdmark  
8441 ..			.dmark: db "ER2"  
8444 f1			.pastdmark: pop af  
8445			endm  
# End of macro DMARK
8445						CALLMONITOR 
8445 cd 6f ee			call debug_vector  
8448				endm  
# End of macro CALLMONITOR
8448					endif 
8448 cd ec 81			call storage_write_block 
844b			 
844b			 
844b				; wipe file extents 
844b			 
844b 3a 64 ea			ld a, (store_tmpext) 
844e 47				ld b, a 
844f			 
844f			.eraext:	  
844f c5				push bc 
8450			 
8450 21 40 00			ld hl, STORE_BLOCK_PHY 
8453 3a 65 ea			ld a,(store_tmpid) 
8456 5f				ld e, a 
8457 50				ld d, b	 
8458					if DEBUG_FORTH_WORDS 
8458						DMARK "ER3" 
8458 f5				push af  
8459 3a 6d 84			ld a, (.dmark)  
845c 32 62 ee			ld (debug_mark),a  
845f 3a 6e 84			ld a, (.dmark+1)  
8462 32 63 ee			ld (debug_mark+1),a  
8465 3a 6f 84			ld a, (.dmark+2)  
8468 32 64 ee			ld (debug_mark+2),a  
846b 18 03			jr .pastdmark  
846d ..			.dmark: db "ER3"  
8470 f1			.pastdmark: pop af  
8471			endm  
# End of macro DMARK
8471						CALLMONITOR 
8471 cd 6f ee			call debug_vector  
8474				endm  
# End of macro CALLMONITOR
8474					endif 
8474 cd b3 84			call storage_findnextid 
8477 cd ff 8c			call ishlzero 
847a ca c0 83			jp z,.se_done 
847d			 
847d e5				push hl 
847e 11 71 ea			ld de, store_page 
8481 cd 87 81			call storage_read_block 
8484			 
8484				; free block	 
8484			 
8484 3e 00			ld a, 0 
8486 32 71 ea			ld (store_page), a 
8489 32 72 ea			ld (store_page+1),a 
848c 11 71 ea			ld de, store_page 
848f e1				pop hl 
8490					if DEBUG_FORTH_WORDS 
8490						DMARK "ER4" 
8490 f5				push af  
8491 3a a5 84			ld a, (.dmark)  
8494 32 62 ee			ld (debug_mark),a  
8497 3a a6 84			ld a, (.dmark+1)  
849a 32 63 ee			ld (debug_mark+1),a  
849d 3a a7 84			ld a, (.dmark+2)  
84a0 32 64 ee			ld (debug_mark+2),a  
84a3 18 03			jr .pastdmark  
84a5 ..			.dmark: db "ER4"  
84a8 f1			.pastdmark: pop af  
84a9			endm  
# End of macro DMARK
84a9						CALLMONITOR 
84a9 cd 6f ee			call debug_vector  
84ac				endm  
# End of macro CALLMONITOR
84ac					endif 
84ac cd ec 81			call storage_write_block 
84af			 
84af c1				pop bc 
84b0 10 9d			djnz .eraext 
84b2			 
84b2 c9				ret 
84b3			 
84b3			 
84b3			; Find Free Block 
84b3			; --------------- 
84b3			; 
84b3			; With current bank 
84b3			;  
84b3			; From given starting logical block 
84b3			;    Read block  
84b3			;    If no file id 
84b3			;         Return block id 
84b3			 
84b3			 
84b3			; hl starting page number 
84b3			; hl contains free page number or zero if no pages free 
84b3			; e contains the file id to locate 
84b3			; d contains the block number 
84b3			 
84b3			; TODO change to find file id and use zero for free block 
84b3			 
84b3			storage_findnextid: 
84b3			 
84b3				; now locate first 0 page to mark as a free block 
84b3			 
84b3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84b5			;	ld hl, STORE_BLOCK_PHY 
84b5			 
84b5					if DEBUG_FORTH_WORDS 
84b5					DMARK "FNI" 
84b5 f5				push af  
84b6 3a ca 84			ld a, (.dmark)  
84b9 32 62 ee			ld (debug_mark),a  
84bc 3a cb 84			ld a, (.dmark+1)  
84bf 32 63 ee			ld (debug_mark+1),a  
84c2 3a cc 84			ld a, (.dmark+2)  
84c5 32 64 ee			ld (debug_mark+2),a  
84c8 18 03			jr .pastdmark  
84ca ..			.dmark: db "FNI"  
84cd f1			.pastdmark: pop af  
84ce			endm  
# End of macro DMARK
84ce						CALLMONITOR 
84ce cd 6f ee			call debug_vector  
84d1				endm  
# End of macro CALLMONITOR
84d1					endif 
84d1			.ff1:   	 
84d1 e5					push hl 
84d2 c5					push bc 
84d3 d5					push de 
84d4 cd ab 80				call se_readbyte 
84d7 5f					ld e,a 
84d8 23					inc hl 
84d9 cd ab 80				call se_readbyte 
84dc 57					ld d, a 
84dd e1					pop hl 
84de e5					push hl 
84df cd f4 8c				call cmp16 
84e2 28 49				jr z, .fffound 
84e4			 
84e4 d1					pop de 
84e5 c1					pop bc 
84e6 e1					pop hl 
84e7			 
84e7					; is found? 
84e7					;cp e 
84e7					;ret z 
84e7			 
84e7 3e 40				ld a, STORE_BLOCK_PHY 
84e9 cd d6 8c				call addatohl 
84ec 10 e3				djnz .ff1 
84ee			 
84ee 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84f0			.ff2:   	 
84f0			 
84f0 e5					push hl 
84f1 c5					push bc 
84f2 d5					push de 
84f3 cd ab 80				call se_readbyte 
84f6 5f					ld e,a 
84f7 23					inc hl 
84f8 cd ab 80				call se_readbyte 
84fb 57					ld d, a 
84fc			 
84fc e1					pop hl 
84fd e5					push hl 
84fe cd f4 8c				call cmp16 
8501 28 2a				jr z, .fffound 
8503			 
8503 d1					pop de 
8504 c1					pop bc 
8505 e1					pop hl 
8506					; is found? 
8506					;cp e 
8506					;ret z 
8506			 
8506 3e 40				ld a, STORE_BLOCK_PHY 
8508 cd d6 8c				call addatohl 
850b 10 e3				djnz .ff2 
850d			 
850d			 
850d					if DEBUG_FORTH_WORDS 
850d					DMARK "FN-" 
850d f5				push af  
850e 3a 22 85			ld a, (.dmark)  
8511 32 62 ee			ld (debug_mark),a  
8514 3a 23 85			ld a, (.dmark+1)  
8517 32 63 ee			ld (debug_mark+1),a  
851a 3a 24 85			ld a, (.dmark+2)  
851d 32 64 ee			ld (debug_mark+2),a  
8520 18 03			jr .pastdmark  
8522 ..			.dmark: db "FN-"  
8525 f1			.pastdmark: pop af  
8526			endm  
# End of macro DMARK
8526					;	push af 
8526					;	ld a, 'n' 
8526					;	ld (debug_mark),a 
8526					;	pop af 
8526						CALLMONITOR 
8526 cd 6f ee			call debug_vector  
8529				endm  
# End of macro CALLMONITOR
8529					endif 
8529				; no free marks! 
8529 21 00 00				ld hl, 0 
852c c9				ret 
852d			.fffound: 
852d				 
852d			 
852d d1					pop de 
852e c1					pop bc 
852f e1					pop hl 
8530					if DEBUG_FORTH_WORDS 
8530					DMARK "FNF" 
8530 f5				push af  
8531 3a 45 85			ld a, (.dmark)  
8534 32 62 ee			ld (debug_mark),a  
8537 3a 46 85			ld a, (.dmark+1)  
853a 32 63 ee			ld (debug_mark+1),a  
853d 3a 47 85			ld a, (.dmark+2)  
8540 32 64 ee			ld (debug_mark+2),a  
8543 18 03			jr .pastdmark  
8545 ..			.dmark: db "FNF"  
8548 f1			.pastdmark: pop af  
8549			endm  
# End of macro DMARK
8549					;	push af 
8549					;	ld a, 'n' 
8549					;	ld (debug_mark),a 
8549					;	pop af 
8549						CALLMONITOR 
8549 cd 6f ee			call debug_vector  
854c				endm  
# End of macro CALLMONITOR
854c					endif 
854c c9				ret 
854d			 
854d			 
854d			 
854d			; Free Space 
854d			; ---------- 
854d			; 
854d			; With current bank 
854d			; 
854d			; Set block count to zero 
854d			; Starting with first logical block 
854d			;      Find free block  
854d			;      If block id given, increment block count 
854d			; 
854d			;  
854d			 
854d			 
854d			; hl contains count of free blocks 
854d			 
854d			storage_freeblocks: 
854d			 
854d				; now locate first 0 page to mark as a free block 
854d			 
854d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
854f 21 40 00			ld hl, STORE_BLOCK_PHY 
8552 11 00 00			ld de, 0 
8555			 
8555			.fb1:   	 
8555 e5					push hl 
8556 c5					push bc 
8557 d5					push de 
8558 cd ab 80				call se_readbyte 
855b d1					pop de 
855c c1					pop bc 
855d e1					pop hl 
855e			 
855e					; is free? 
855e			;		cp 0 
855e b7					or a 
855f 20 01				jr nz, .ff1cont 
8561 13					inc de 
8562			 
8562			.ff1cont: 
8562			 
8562			 
8562 3e 40				ld a, STORE_BLOCK_PHY 
8564 cd d6 8c				call addatohl 
8567 10 ec				djnz .fb1 
8569			 
8569 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
856b			.fb2:   	 
856b e5					push hl 
856c c5					push bc 
856d d5					push de 
856e cd ab 80				call se_readbyte 
8571 d1					pop de 
8572 c1					pop bc 
8573 e1					pop hl 
8574			 
8574					; is free? 
8574			;		cp 0 
8574 b7					or a 
8575 20 01				jr nz, .ff2cont 
8577 13					inc de 
8578			 
8578			.ff2cont: 
8578			 
8578 3e 40				ld a, STORE_BLOCK_PHY 
857a cd d6 8c				call addatohl 
857d 10 ec				djnz .fb2 
857f			 
857f eb				ex de, hl 
8580 c9				ret 
8581			 
8581			; Get File ID 
8581			; ----------- 
8581			; 
8581			; With current bank 
8581			;  
8581			; Load Block 0 Config 
8581			; Get max file id number 
8581			; For each logical block 
8581			;    Read block file id 
8581			;      If first block of file and dont have file id 
8581			;         if file get id and exit 
8581			 
8581			 
8581			 
8581			 
8581			; Create File 
8581			; ----------- 
8581			; 
8581			; With current bank  
8581			; Load Block 0 Config 
8581			; Get max file id number 
8581			; Increment file id number 
8581			; Save Config 
8581			; Find free block 
8581			; Set buffer with file name and file id 
8581			; Write buffer to free block  
8581			 
8581			 
8581			; hl point to file name 
8581			; hl returns file id 
8581			 
8581			; file format: 
8581			; byte 0 - file id 
8581			; byte 1 - extent number 
8581			; byte 2-> data 
8581			 
8581			; format for extent number 0: 
8581			; 
8581			; byte 0 - file id 
8581			; byte 1 - extent 0 
8581			; byte 2 - extent count 
8581			; byte 3 -> file name and meta data 
8581			 
8581			 
8581			storage_create: 
8581				if DEBUG_STORESE 
8581					DMARK "SCR" 
8581 f5				push af  
8582 3a 96 85			ld a, (.dmark)  
8585 32 62 ee			ld (debug_mark),a  
8588 3a 97 85			ld a, (.dmark+1)  
858b 32 63 ee			ld (debug_mark+1),a  
858e 3a 98 85			ld a, (.dmark+2)  
8591 32 64 ee			ld (debug_mark+2),a  
8594 18 03			jr .pastdmark  
8596 ..			.dmark: db "SCR"  
8599 f1			.pastdmark: pop af  
859a			endm  
# End of macro DMARK
859a					CALLMONITOR 
859a cd 6f ee			call debug_vector  
859d				endm  
# End of macro CALLMONITOR
859d				endif 
859d			 
859d e5				push hl		; save file name pointer 
859e			 
859e cd 35 82			call storage_get_block_0 
85a1			 
85a1 3a 71 ea			ld a,(store_page)	; get current file id 
85a4 3c				inc a 
85a5 32 71 ea			ld (store_page),a 
85a8				 
85a8 32 65 ea			ld (store_tmpid),a			; save id 
85ab			 
85ab 21 00 00			ld hl, 0 
85ae 11 71 ea			ld de, store_page 
85b1				if DEBUG_STORESE 
85b1					DMARK "SCw" 
85b1 f5				push af  
85b2 3a c6 85			ld a, (.dmark)  
85b5 32 62 ee			ld (debug_mark),a  
85b8 3a c7 85			ld a, (.dmark+1)  
85bb 32 63 ee			ld (debug_mark+1),a  
85be 3a c8 85			ld a, (.dmark+2)  
85c1 32 64 ee			ld (debug_mark+2),a  
85c4 18 03			jr .pastdmark  
85c6 ..			.dmark: db "SCw"  
85c9 f1			.pastdmark: pop af  
85ca			endm  
# End of macro DMARK
85ca					CALLMONITOR 
85ca cd 6f ee			call debug_vector  
85cd				endm  
# End of macro CALLMONITOR
85cd				endif 
85cd cd ec 81			call storage_write_block	 ; save update 
85d0			 
85d0				if DEBUG_STORESE 
85d0 11 71 ea				ld de, store_page 
85d3					DMARK "SCC" 
85d3 f5				push af  
85d4 3a e8 85			ld a, (.dmark)  
85d7 32 62 ee			ld (debug_mark),a  
85da 3a e9 85			ld a, (.dmark+1)  
85dd 32 63 ee			ld (debug_mark+1),a  
85e0 3a ea 85			ld a, (.dmark+2)  
85e3 32 64 ee			ld (debug_mark+2),a  
85e6 18 03			jr .pastdmark  
85e8 ..			.dmark: db "SCC"  
85eb f1			.pastdmark: pop af  
85ec			endm  
# End of macro DMARK
85ec					CALLMONITOR 
85ec cd 6f ee			call debug_vector  
85ef				endm  
# End of macro CALLMONITOR
85ef				endif 
85ef				;  
85ef				 
85ef 21 40 00			ld hl, STORE_BLOCK_PHY 
85f2 11 00 00			ld de, 0 
85f5 cd b3 84			call storage_findnextid 
85f8			 
85f8 22 5c ea			ld (store_tmppageid), hl    ; save page to use  
85fb			 
85fb				; TODO detect 0 = no spare blocks 
85fb			 
85fb				; hl now contains the free page to use for the file header page 
85fb			 
85fb				if DEBUG_STORESE 
85fb				DMARK "SCF" 
85fb f5				push af  
85fc 3a 10 86			ld a, (.dmark)  
85ff 32 62 ee			ld (debug_mark),a  
8602 3a 11 86			ld a, (.dmark+1)  
8605 32 63 ee			ld (debug_mark+1),a  
8608 3a 12 86			ld a, (.dmark+2)  
860b 32 64 ee			ld (debug_mark+2),a  
860e 18 03			jr .pastdmark  
8610 ..			.dmark: db "SCF"  
8613 f1			.pastdmark: pop af  
8614			endm  
# End of macro DMARK
8614					CALLMONITOR 
8614 cd 6f ee			call debug_vector  
8617				endm  
# End of macro CALLMONITOR
8617				endif 
8617			 
8617 22 5c ea			ld (store_tmppageid), hl 
861a				 
861a 3a 65 ea			ld a,(store_tmpid)    ; get file id 
861d			;	ld a, (store_filecache)			; save to cache 
861d			 
861d 32 71 ea			ld (store_page),a    ; set page id 
8620 3e 00			ld a, 0			 ; extent 0 is file header 
8622 32 72 ea			ld (store_page+1), a   ; set file extent 
8625			 
8625 32 73 ea			ld (store_page+2), a   ; extent count for the file 
8628			 
8628			;	inc hl 		; init block 0 of file 
8628			;	inc hl   		; skip file and extent id 
8628			 ;       ld a, 0 
8628			;	ld (hl),a 
8628			;	ld a, (store_filecache+1)  	; save to cache 
8628			 
8628			;	inc hl    ; file name 
8628				 
8628				 
8628 11 74 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
862b				if DEBUG_STORESE 
862b					DMARK "SCc" 
862b f5				push af  
862c 3a 40 86			ld a, (.dmark)  
862f 32 62 ee			ld (debug_mark),a  
8632 3a 41 86			ld a, (.dmark+1)  
8635 32 63 ee			ld (debug_mark+1),a  
8638 3a 42 86			ld a, (.dmark+2)  
863b 32 64 ee			ld (debug_mark+2),a  
863e 18 03			jr .pastdmark  
8640 ..			.dmark: db "SCc"  
8643 f1			.pastdmark: pop af  
8644			endm  
# End of macro DMARK
8644					CALLMONITOR 
8644 cd 6f ee			call debug_vector  
8647				endm  
# End of macro CALLMONITOR
8647				endif 
8647 e1				pop hl    ; get zero term string 
8648 e5				push hl 
8649 3e 00			ld a, 0 
864b cd 39 90			call strlent 
864e 23				inc hl   ; cover zero term 
864f 06 00			ld b,0 
8651 4d				ld c,l 
8652 e1				pop hl 
8653				;ex de, hl 
8653				if DEBUG_STORESE 
8653					DMARK "SCa" 
8653 f5				push af  
8654 3a 68 86			ld a, (.dmark)  
8657 32 62 ee			ld (debug_mark),a  
865a 3a 69 86			ld a, (.dmark+1)  
865d 32 63 ee			ld (debug_mark+1),a  
8660 3a 6a 86			ld a, (.dmark+2)  
8663 32 64 ee			ld (debug_mark+2),a  
8666 18 03			jr .pastdmark  
8668 ..			.dmark: db "SCa"  
866b f1			.pastdmark: pop af  
866c			endm  
# End of macro DMARK
866c					;push af 
866c					;ld a, 'a' 
866c					;ld (debug_mark),a 
866c					;pop af 
866c					CALLMONITOR 
866c cd 6f ee			call debug_vector  
866f				endm  
# End of macro CALLMONITOR
866f				endif 
866f ed b0			ldir    ; copy zero term string 
8671				if DEBUG_STORESE 
8671					DMARK "SCA" 
8671 f5				push af  
8672 3a 86 86			ld a, (.dmark)  
8675 32 62 ee			ld (debug_mark),a  
8678 3a 87 86			ld a, (.dmark+1)  
867b 32 63 ee			ld (debug_mark+1),a  
867e 3a 88 86			ld a, (.dmark+2)  
8681 32 64 ee			ld (debug_mark+2),a  
8684 18 03			jr .pastdmark  
8686 ..			.dmark: db "SCA"  
8689 f1			.pastdmark: pop af  
868a			endm  
# End of macro DMARK
868a					CALLMONITOR 
868a cd 6f ee			call debug_vector  
868d				endm  
# End of macro CALLMONITOR
868d				endif 
868d			 
868d				; write file header page 
868d			 
868d 2a 5c ea			ld hl,(store_tmppageid) 
8690 11 71 ea			ld de, store_page 
8693				if DEBUG_STORESE 
8693					DMARK "SCb" 
8693 f5				push af  
8694 3a a8 86			ld a, (.dmark)  
8697 32 62 ee			ld (debug_mark),a  
869a 3a a9 86			ld a, (.dmark+1)  
869d 32 63 ee			ld (debug_mark+1),a  
86a0 3a aa 86			ld a, (.dmark+2)  
86a3 32 64 ee			ld (debug_mark+2),a  
86a6 18 03			jr .pastdmark  
86a8 ..			.dmark: db "SCb"  
86ab f1			.pastdmark: pop af  
86ac			endm  
# End of macro DMARK
86ac					;push af 
86ac					;ld a, 'b' 
86ac					;ld (debug_mark),a 
86ac					;pop af 
86ac					CALLMONITOR 
86ac cd 6f ee			call debug_vector  
86af				endm  
# End of macro CALLMONITOR
86af				endif 
86af cd ec 81			call storage_write_block 
86b2			 
86b2 3a 65 ea			ld a, (store_tmpid) 
86b5 6f				ld l, a 
86b6 26 00			ld h,0 
86b8				if DEBUG_STORESE 
86b8					DMARK "SCz" 
86b8 f5				push af  
86b9 3a cd 86			ld a, (.dmark)  
86bc 32 62 ee			ld (debug_mark),a  
86bf 3a ce 86			ld a, (.dmark+1)  
86c2 32 63 ee			ld (debug_mark+1),a  
86c5 3a cf 86			ld a, (.dmark+2)  
86c8 32 64 ee			ld (debug_mark+2),a  
86cb 18 03			jr .pastdmark  
86cd ..			.dmark: db "SCz"  
86d0 f1			.pastdmark: pop af  
86d1			endm  
# End of macro DMARK
86d1					CALLMONITOR 
86d1 cd 6f ee			call debug_vector  
86d4				endm  
# End of macro CALLMONITOR
86d4				endif 
86d4 c9				ret 
86d5				 
86d5			 
86d5			 
86d5			; 
86d5			; Read File 
86d5			; 
86d5			; h - file id to locate 
86d5			; l - extent to locate 
86d5			; de - pointer to string to read into 
86d5			; 
86d5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d5			 
86d5			.sr_fail: 
86d5 d1				pop de 
86d6 c9				ret 
86d7			 
86d7			storage_read: 
86d7			 
86d7			 
86d7 d5				push de 
86d8			 
86d8			; TODO BUG the above push is it popped before the RET Z? 
86d8			 
86d8			; TODO how to handle multiple part blocks 
86d8			 
86d8				; locate file extent to read 
86d8			 
86d8 5c				ld e, h 
86d9 55				ld d, l 
86da			 
86da			.srext: 
86da 22 6f ea			ld (store_readptr), hl     ; save the current extent to load 
86dd ed 53 6d ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86e1			 
86e1 21 40 00			ld hl, STORE_BLOCK_PHY 
86e4				if DEBUG_STORESE 
86e4					DMARK "sre" 
86e4 f5				push af  
86e5 3a f9 86			ld a, (.dmark)  
86e8 32 62 ee			ld (debug_mark),a  
86eb 3a fa 86			ld a, (.dmark+1)  
86ee 32 63 ee			ld (debug_mark+1),a  
86f1 3a fb 86			ld a, (.dmark+2)  
86f4 32 64 ee			ld (debug_mark+2),a  
86f7 18 03			jr .pastdmark  
86f9 ..			.dmark: db "sre"  
86fc f1			.pastdmark: pop af  
86fd			endm  
# End of macro DMARK
86fd					CALLMONITOR 
86fd cd 6f ee			call debug_vector  
8700				endm  
# End of macro CALLMONITOR
8700				endif 
8700 cd b3 84			call storage_findnextid 
8703			 
8703				if DEBUG_STORESE 
8703					DMARK "srf" 
8703 f5				push af  
8704 3a 18 87			ld a, (.dmark)  
8707 32 62 ee			ld (debug_mark),a  
870a 3a 19 87			ld a, (.dmark+1)  
870d 32 63 ee			ld (debug_mark+1),a  
8710 3a 1a 87			ld a, (.dmark+2)  
8713 32 64 ee			ld (debug_mark+2),a  
8716 18 03			jr .pastdmark  
8718 ..			.dmark: db "srf"  
871b f1			.pastdmark: pop af  
871c			endm  
# End of macro DMARK
871c					CALLMONITOR 
871c cd 6f ee			call debug_vector  
871f				endm  
# End of macro CALLMONITOR
871f				endif 
871f cd ff 8c			call ishlzero 
8722			;	ld a, l 
8722			;	add h 
8722			;	cp 0 
8722 28 b1			jr z,.sr_fail			; block not found so EOF 
8724			 
8724				; save current address for use by higher level words etc 
8724			 
8724 22 62 ea			ld (store_openaddr),hl 
8727			 
8727			 
8727				; hl contains page number to load 
8727 d1				pop de   ; get storage 
8728 ed 53 6d ea		ld (store_readbuf), de     ; current buffer to load in to 
872c d5				push de 
872d				if DEBUG_STORESE 
872d					DMARK "srg" 
872d f5				push af  
872e 3a 42 87			ld a, (.dmark)  
8731 32 62 ee			ld (debug_mark),a  
8734 3a 43 87			ld a, (.dmark+1)  
8737 32 63 ee			ld (debug_mark+1),a  
873a 3a 44 87			ld a, (.dmark+2)  
873d 32 64 ee			ld (debug_mark+2),a  
8740 18 03			jr .pastdmark  
8742 ..			.dmark: db "srg"  
8745 f1			.pastdmark: pop af  
8746			endm  
# End of macro DMARK
8746					CALLMONITOR 
8746 cd 6f ee			call debug_vector  
8749				endm  
# End of macro CALLMONITOR
8749				endif 
8749 cd 87 81			call storage_read_block 
874c			 
874c				; if this a continuation read??? 
874c			 
874c 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874f			 
874f 3e 3f			ld a, STORE_BLOCK_PHY-1 
8751 cd d6 8c			call addatohl 
8754 7e				ld a,(hl) 
8755			;	cp 0 
8755 b7				or a 
8756 28 02			jr z, .markiscont 
8758 3e ff			ld a, 255 
875a			 
875a			.markiscont: 
875a 32 64 ea			ld (store_readcont), a 
875d			 
875d				if DEBUG_STORESE 
875d					DMARK "srC" 
875d f5				push af  
875e 3a 72 87			ld a, (.dmark)  
8761 32 62 ee			ld (debug_mark),a  
8764 3a 73 87			ld a, (.dmark+1)  
8767 32 63 ee			ld (debug_mark+1),a  
876a 3a 74 87			ld a, (.dmark+2)  
876d 32 64 ee			ld (debug_mark+2),a  
8770 18 03			jr .pastdmark  
8772 ..			.dmark: db "srC"  
8775 f1			.pastdmark: pop af  
8776			endm  
# End of macro DMARK
8776					CALLMONITOR 
8776 cd 6f ee			call debug_vector  
8779				endm  
# End of macro CALLMONITOR
8779				endif 
8779				; only short reads enabled 
8779			 
8779 3a 6c ea			ld a, (store_longread) 
877c			;	cp 0 
877c b7				or a 
877d ca 49 88			jp z, .readdone 
8780			 
8780			; TODO if block has no zeros then need to read next block  
8780			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
8780			; check last byte of physical block. 
8780			; if not zero then the next block needs to be loaded 
8780			 
8780			 
8780 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8783			 
8783 3e 3f			ld a, STORE_BLOCK_PHY-1 
8785 cd d6 8c			call addatohl 
8788				;dec hl 
8788 7e				ld a,(hl) 
8789				if DEBUG_STORESE 
8789					DMARK "sr?" 
8789 f5				push af  
878a 3a 9e 87			ld a, (.dmark)  
878d 32 62 ee			ld (debug_mark),a  
8790 3a 9f 87			ld a, (.dmark+1)  
8793 32 63 ee			ld (debug_mark+1),a  
8796 3a a0 87			ld a, (.dmark+2)  
8799 32 64 ee			ld (debug_mark+2),a  
879c 18 03			jr .pastdmark  
879e ..			.dmark: db "sr?"  
87a1 f1			.pastdmark: pop af  
87a2			endm  
# End of macro DMARK
87a2					CALLMONITOR 
87a2 cd 6f ee			call debug_vector  
87a5				endm  
# End of macro CALLMONITOR
87a5				endif 
87a5			;	cp 0 
87a5 b7				or a 
87a6 ca 49 88			jp z, .readdone 
87a9			 
87a9				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a9			 
87a9 23				inc hl 
87aa			 
87aa 22 6d ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ad			 
87ad ed 5b 6f ea		ld de, (store_readptr)     ; save the current extent to load 
87b1			 
87b1 eb				ex de, hl 
87b2			 
87b2				; next ext 
87b2			 
87b2 23				inc hl 
87b3 22 6f ea			ld  (store_readptr), hl     ; save the current extent to load 
87b6			 
87b6				if DEBUG_STORESE 
87b6					DMARK "sF2" 
87b6 f5				push af  
87b7 3a cb 87			ld a, (.dmark)  
87ba 32 62 ee			ld (debug_mark),a  
87bd 3a cc 87			ld a, (.dmark+1)  
87c0 32 63 ee			ld (debug_mark+1),a  
87c3 3a cd 87			ld a, (.dmark+2)  
87c6 32 64 ee			ld (debug_mark+2),a  
87c9 18 03			jr .pastdmark  
87cb ..			.dmark: db "sF2"  
87ce f1			.pastdmark: pop af  
87cf			endm  
# End of macro DMARK
87cf					CALLMONITOR 
87cf cd 6f ee			call debug_vector  
87d2				endm  
# End of macro CALLMONITOR
87d2				endif 
87d2			 
87d2				; get and load block 
87d2			 
87d2 cd b3 84			call storage_findnextid 
87d5			 
87d5				if DEBUG_STORESE 
87d5					DMARK "sf2" 
87d5 f5				push af  
87d6 3a ea 87			ld a, (.dmark)  
87d9 32 62 ee			ld (debug_mark),a  
87dc 3a eb 87			ld a, (.dmark+1)  
87df 32 63 ee			ld (debug_mark+1),a  
87e2 3a ec 87			ld a, (.dmark+2)  
87e5 32 64 ee			ld (debug_mark+2),a  
87e8 18 03			jr .pastdmark  
87ea ..			.dmark: db "sf2"  
87ed f1			.pastdmark: pop af  
87ee			endm  
# End of macro DMARK
87ee					CALLMONITOR 
87ee cd 6f ee			call debug_vector  
87f1				endm  
# End of macro CALLMONITOR
87f1				endif 
87f1 cd ff 8c			call ishlzero 
87f4			;	ld a, l 
87f4			;	add h 
87f4			;	cp 0 
87f4 ca d5 86			jp z,.sr_fail			; block not found so EOF 
87f7				 
87f7				; save current address for use by higher level words etc 
87f7			 
87f7 22 62 ea			ld (store_openaddr),hl 
87fa			 
87fa cd 87 81			call storage_read_block 
87fd			 
87fd				; on a continuation block, we now have the file id and ext in the middle of the block 
87fd				; we need to pull everything back  
87fd			 
87fd ed 5b 6d ea		ld de, (store_readbuf)     ; current buffer to nudge into 
8801 2a 6d ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8804 23				inc hl 
8805 23				inc hl     ; skip id and ext 
8806 01 40 00			ld bc, STORE_BLOCK_PHY 
8809				if DEBUG_STORESE 
8809					DMARK "SR<" 
8809 f5				push af  
880a 3a 1e 88			ld a, (.dmark)  
880d 32 62 ee			ld (debug_mark),a  
8810 3a 1f 88			ld a, (.dmark+1)  
8813 32 63 ee			ld (debug_mark+1),a  
8816 3a 20 88			ld a, (.dmark+2)  
8819 32 64 ee			ld (debug_mark+2),a  
881c 18 03			jr .pastdmark  
881e ..			.dmark: db "SR<"  
8821 f1			.pastdmark: pop af  
8822			endm  
# End of macro DMARK
8822					CALLMONITOR 
8822 cd 6f ee			call debug_vector  
8825				endm  
# End of macro CALLMONITOR
8825				endif 
8825 ed b0			ldir     ; copy data 
8827			 
8827				; move the pointer back and pretend we have a full buffer for next recheck 
8827			 
8827 1b				dec de 
8828 1b				dec de 
8829			 
8829			; TODO do pop below now short circuit loop????? 
8829 c1				pop bc     ; get rid of spare de on stack 
882a				if DEBUG_STORESE 
882a					DMARK "SR>" 
882a f5				push af  
882b 3a 3f 88			ld a, (.dmark)  
882e 32 62 ee			ld (debug_mark),a  
8831 3a 40 88			ld a, (.dmark+1)  
8834 32 63 ee			ld (debug_mark+1),a  
8837 3a 41 88			ld a, (.dmark+2)  
883a 32 64 ee			ld (debug_mark+2),a  
883d 18 03			jr .pastdmark  
883f ..			.dmark: db "SR>"  
8842 f1			.pastdmark: pop af  
8843			endm  
# End of macro DMARK
8843					CALLMONITOR 
8843 cd 6f ee			call debug_vector  
8846				endm  
# End of macro CALLMONITOR
8846				endif 
8846 c3 da 86			jp .srext 
8849			 
8849			 
8849			 
8849			 
8849			 
8849			.readdone:		 
8849 e1				pop hl 		 ; return start of data to show as not EOF 
884a 23				inc hl   ; past file id 
884b 23				inc hl   ; past ext 
884c				if DEBUG_STORESE 
884c					DMARK "SRe" 
884c f5				push af  
884d 3a 61 88			ld a, (.dmark)  
8850 32 62 ee			ld (debug_mark),a  
8853 3a 62 88			ld a, (.dmark+1)  
8856 32 63 ee			ld (debug_mark+1),a  
8859 3a 63 88			ld a, (.dmark+2)  
885c 32 64 ee			ld (debug_mark+2),a  
885f 18 03			jr .pastdmark  
8861 ..			.dmark: db "SRe"  
8864 f1			.pastdmark: pop af  
8865			endm  
# End of macro DMARK
8865					CALLMONITOR 
8865 cd 6f ee			call debug_vector  
8868				endm  
# End of macro CALLMONITOR
8868				endif 
8868 c9					ret 
8869			 
8869			 
8869			 
8869			; 
8869			; Append File 
8869			; 
8869			; hl - file id to locate 
8869			; de - pointer to (multi block) string to write 
8869			 
8869			.sa_notfound: 
8869 d1				pop de 
886a c9				ret 
886b			 
886b			 
886b			storage_append: 
886b				; hl -  file id to append to 
886b				; de - string to append 
886b			 
886b d5				push de 
886c				 
886c				if DEBUG_STORESE 
886c					DMARK "AP1" 
886c f5				push af  
886d 3a 81 88			ld a, (.dmark)  
8870 32 62 ee			ld (debug_mark),a  
8873 3a 82 88			ld a, (.dmark+1)  
8876 32 63 ee			ld (debug_mark+1),a  
8879 3a 83 88			ld a, (.dmark+2)  
887c 32 64 ee			ld (debug_mark+2),a  
887f 18 03			jr .pastdmark  
8881 ..			.dmark: db "AP1"  
8884 f1			.pastdmark: pop af  
8885			endm  
# End of macro DMARK
8885					CALLMONITOR 
8885 cd 6f ee			call debug_vector  
8888				endm  
# End of macro CALLMONITOR
8888				endif 
8888			 
8888 7d				ld a, l 
8889 32 65 ea			ld (store_tmpid), a 
888c			 
888c				; get file header  
888c			 
888c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888e 3a 65 ea			ld a, (store_tmpid) 
8891 5f				ld e, a 
8892			 
8892 21 40 00				ld hl, STORE_BLOCK_PHY 
8895 cd b3 84				call storage_findnextid 
8898			 
8898 cd ff 8c			call ishlzero 
889b 28 cc			jr z, .sa_notfound 
889d			 
889d 22 5c ea			ld (store_tmppageid), hl 
88a0			 
88a0				; TODO handle file id not found 
88a0			 
88a0				if DEBUG_STORESE 
88a0					DMARK "AP2" 
88a0 f5				push af  
88a1 3a b5 88			ld a, (.dmark)  
88a4 32 62 ee			ld (debug_mark),a  
88a7 3a b6 88			ld a, (.dmark+1)  
88aa 32 63 ee			ld (debug_mark+1),a  
88ad 3a b7 88			ld a, (.dmark+2)  
88b0 32 64 ee			ld (debug_mark+2),a  
88b3 18 03			jr .pastdmark  
88b5 ..			.dmark: db "AP2"  
88b8 f1			.pastdmark: pop af  
88b9			endm  
# End of macro DMARK
88b9					CALLMONITOR 
88b9 cd 6f ee			call debug_vector  
88bc				endm  
# End of macro CALLMONITOR
88bc				endif 
88bc			 
88bc				; update file extent count 
88bc			 
88bc 11 71 ea			ld de, store_page 
88bf			 
88bf cd 87 81			call storage_read_block 
88c2			 
88c2				if DEBUG_STORESE 
88c2					DMARK "AP3" 
88c2 f5				push af  
88c3 3a d7 88			ld a, (.dmark)  
88c6 32 62 ee			ld (debug_mark),a  
88c9 3a d8 88			ld a, (.dmark+1)  
88cc 32 63 ee			ld (debug_mark+1),a  
88cf 3a d9 88			ld a, (.dmark+2)  
88d2 32 64 ee			ld (debug_mark+2),a  
88d5 18 03			jr .pastdmark  
88d7 ..			.dmark: db "AP3"  
88da f1			.pastdmark: pop af  
88db			endm  
# End of macro DMARK
88db					CALLMONITOR 
88db cd 6f ee			call debug_vector  
88de				endm  
# End of macro CALLMONITOR
88de				endif 
88de			;	ld (store_tmppageid), hl 
88de			 
88de 3a 73 ea			ld a, (store_page+2) 
88e1 3c				inc a 
88e2 32 73 ea			ld (store_page+2), a 
88e5 32 64 ea			ld (store_tmpext), a 
88e8				 
88e8				if DEBUG_STORESE 
88e8					DMARK "AP3" 
88e8 f5				push af  
88e9 3a fd 88			ld a, (.dmark)  
88ec 32 62 ee			ld (debug_mark),a  
88ef 3a fe 88			ld a, (.dmark+1)  
88f2 32 63 ee			ld (debug_mark+1),a  
88f5 3a ff 88			ld a, (.dmark+2)  
88f8 32 64 ee			ld (debug_mark+2),a  
88fb 18 03			jr .pastdmark  
88fd ..			.dmark: db "AP3"  
8900 f1			.pastdmark: pop af  
8901			endm  
# End of macro DMARK
8901					CALLMONITOR 
8901 cd 6f ee			call debug_vector  
8904				endm  
# End of macro CALLMONITOR
8904				endif 
8904 2a 5c ea			ld hl, (store_tmppageid) 
8907 11 71 ea			ld de, store_page 
890a cd ec 81			call storage_write_block 
890d			 
890d				; find free block 
890d			 
890d 11 00 00			ld de, 0			 ; file extent to locate 
8910			 
8910 21 40 00				ld hl, STORE_BLOCK_PHY 
8913 cd b3 84				call storage_findnextid 
8916 cd ff 8c			call ishlzero 
8919 ca 69 88			jp z, .sa_notfound 
891c			 
891c					; TODO handle no space left 
891c					 
891c 22 5c ea				ld (store_tmppageid), hl 
891f			 
891f				if DEBUG_STORESE 
891f					DMARK "AP4" 
891f f5				push af  
8920 3a 34 89			ld a, (.dmark)  
8923 32 62 ee			ld (debug_mark),a  
8926 3a 35 89			ld a, (.dmark+1)  
8929 32 63 ee			ld (debug_mark+1),a  
892c 3a 36 89			ld a, (.dmark+2)  
892f 32 64 ee			ld (debug_mark+2),a  
8932 18 03			jr .pastdmark  
8934 ..			.dmark: db "AP4"  
8937 f1			.pastdmark: pop af  
8938			endm  
# End of macro DMARK
8938					CALLMONITOR 
8938 cd 6f ee			call debug_vector  
893b				endm  
# End of macro CALLMONITOR
893b				endif 
893b					; init the buffer with zeros so we can id if the buffer is full or not 
893b			 
893b e5					push hl 
893c c5					push bc 
893d			 
893d 21 71 ea				ld hl, store_page 
8940 06 40				ld b, STORE_BLOCK_PHY 
8942			;		ld a, 0 
8942 36 00		.zeroblock:	ld (hl), 0 
8944 23					inc hl 
8945 10 fb				djnz .zeroblock 
8947			 
8947 c1					pop bc 
8948 e1					pop hl 
8949			 
8949					; construct block 
8949			 
8949 3a 65 ea				ld a, (store_tmpid) 
894c 32 71 ea				ld (store_page), a   ; file id 
894f 3a 64 ea				ld a, (store_tmpext)   ; extent for this block 
8952 32 72 ea				ld (store_page+1), a 
8955			 
8955 e1					pop hl    ; get string to write 
8956 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8958 11 73 ea				ld de, store_page+2 
895b			 
895b				if DEBUG_STORESE 
895b					DMARK "AP5" 
895b f5				push af  
895c 3a 70 89			ld a, (.dmark)  
895f 32 62 ee			ld (debug_mark),a  
8962 3a 71 89			ld a, (.dmark+1)  
8965 32 63 ee			ld (debug_mark+1),a  
8968 3a 72 89			ld a, (.dmark+2)  
896b 32 64 ee			ld (debug_mark+2),a  
896e 18 03			jr .pastdmark  
8970 ..			.dmark: db "AP5"  
8973 f1			.pastdmark: pop af  
8974			endm  
# End of macro DMARK
8974					CALLMONITOR 
8974 cd 6f ee			call debug_vector  
8977				endm  
# End of macro CALLMONITOR
8977				endif 
8977			 
8977			 
8977			 
8977					; fill buffer with data until end of string or full block 
8977			 
8977 7e			.appd:		ld a, (hl) 
8978 12					ld (de), a 
8979			;		cp 0 
8979 b7					or a 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f7				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 5c ea			ld hl, (store_tmppageid) 
8985 11 71 ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 62 ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 63 ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 64 ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd 6f ee			call debug_vector  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd ec 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9					;cp 0		 ; no, string was fully written 
89a9 b7					or a 
89aa c8					ret z 
89ab			 
89ab					; setup vars for next cycle 
89ab			 
89ab 3a 65 ea				ld a, (store_tmpid) 
89ae 6f					ld l, a 
89af 26 00				ld h, 0 
89b1			 
89b1 c3 6b 88			 	jp storage_append	 ; yes, need to write out some more 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			 
89b4			if DEBUG_STORECF 
89b4			storageput:	 
89b4					ret 
89b4			storageread: 
89b4					ld hl, store_page 
89b4					ld b, 200 
89b4			;		ld a,0 
89b4			.src:		ld (hl),0 
89b4					inc hl 
89b4					djnz .src 
89b4					 
89b4			 
89b4					ld de, 0 
89b4					ld bc, 1 
89b4					ld hl, store_page 
89b4					call cfRead 
89b4			 
89b4				call cfGetError 
89b4				ld hl,scratch 
89b4				call hexout 
89b4				ld hl, scratch+2 
89b4			;	ld a, 0 
89b4				ld (hl),0 
89b4				ld de, scratch 
89b4				ld a,display_row_1 
89b4				call str_at_display 
89b4				call update_display 
89b4			 
89b4					ld hl, store_page 
89b4					ld (os_cur_ptr),hl 
89b4			 
89b4					ret 
89b4			endif 
89b4			 
89b4			 
89b4			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b4			 
89b4			storage_clear_page: 
89b4 e5				push hl 
89b5 d5				push de 
89b6 c5				push bc 
89b7 21 71 ea			ld hl, store_page 
89ba			;	ld a, 0 
89ba 36 00			ld (hl), 0 
89bc			 
89bc 11 72 ea			ld de, store_page+1 
89bf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c2			 
89c2 ed b0			ldir 
89c4				 
89c4 c1				pop bc 
89c5 d1				pop de 
89c6 e1				pop hl 
89c7 c9				ret 
89c8			 
89c8			; eof 
# End of file firmware_storage.asm
89c8			  
89c8			; support routines for above hardware abstraction layer  
89c8			  
89c8			include "firmware_general.asm"        ; general support functions  
89c8			 
89c8			; word look up 
89c8			 
89c8			; in 
89c8			; a is the index 
89c8			; hl is pointer start of array 
89c8			; 
89c8			; returns 
89c8			; hl to the word 
89c8			; 
89c8			 
89c8			table_lookup:  
89c8 d5					push de 
89c9 eb					ex de, hl 
89ca			 
89ca 6f					ld l, a 
89cb 26 00				ld h, 0 
89cd 29					add hl, hl 
89ce 19					add hl, de 
89cf 7e					ld a, (hl) 
89d0 23					inc hl 
89d1 66					ld h,(hl) 
89d2 6f					ld l, a 
89d3			 
89d3 d1					pop de 
89d4 c9					ret 
89d5			 
89d5			; Delay loops 
89d5			 
89d5			 
89d5			 
89d5			aDelayInMS: 
89d5 c5				push bc 
89d6 47				ld b,a 
89d7			msdelay: 
89d7 c5				push bc 
89d8				 
89d8			 
89d8 01 41 00			ld bc,041h 
89db cd f3 89			call delayloop 
89de c1				pop bc 
89df 05				dec b 
89e0 20 f5			jr nz,msdelay 
89e2			 
89e2			;if CPU_CLOCK_8MHZ 
89e2			;msdelay8: 
89e2			;	push bc 
89e2			;	 
89e2			; 
89e2			;	ld bc,041h 
89e2			;	call delayloop 
89e2			;	pop bc 
89e2			;	dec b 
89e2			;	jr nz,msdelay8 
89e2			;endif 
89e2			 
89e2			 
89e2 c1				pop bc 
89e3 c9				ret 
89e4			 
89e4			 
89e4			delay250ms: 
89e4				;push de 
89e4 01 00 40			ld bc, 04000h 
89e7 c3 f3 89			jp delayloop 
89ea			delay500ms: 
89ea				;push de 
89ea 01 00 80			ld bc, 08000h 
89ed c3 f3 89			jp delayloop 
89f0			delay1s: 
89f0				;push bc 
89f0			   ; Clobbers A, d and e 
89f0 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f3			delayloop: 
89f3 c5			    push bc 
89f4			 
89f4			if BASE_CPM 
89f4				ld bc, CPM_DELAY_TUNE 
89f4			.cpmloop: 
89f4				push bc 
89f4			 
89f4			endif 
89f4			 
89f4			 
89f4			 
89f4			delayloopi: 
89f4			;	push bc 
89f4			;.dl: 
89f4 cb 47		    bit     0,a    	; 8 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa e6 ff		    and     255  	; 7 
89fc 0b			    dec     bc      	; 6 
89fd 79			    ld      a,c     	; 4 
89fe b0			    or      b     	; 4 
89ff c2 f4 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a02			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a02				;pop de 
8a02			;pop bc 
8a02			 
8a02			if BASE_CPM 
8a02				pop bc 
8a02				 
8a02			    dec     bc      	; 6 
8a02			    ld      a,c     	; 4 
8a02			    or      b     	; 4 
8a02			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a02				 
8a02			 
8a02			endif 
8a02			;if CPU_CLOCK_8MHZ 
8a02			;    pop bc 
8a02			;    push bc 
8a02			;.dl8: 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    and     255  	; 7 
8a02			;    dec     bc      	; 6 
8a02			;    ld      a,c     	; 4 
8a02			;    or      b     	; 4 
8a02			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a02			;endif 
8a02			 
8a02			;if CPU_CLOCK_10MHZ 
8a02			;    pop bc 
8a02			;    push bc 
8a02			;.dl8: 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    bit     0,a    	; 8 
8a02			;    and     255  	; 7 
8a02			;    dec     bc      	; 6 
8a02			;    ld      a,c     	; 4 
8a02			;    or      b     	; 4 
8a02			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a02			;endif 
8a02 c1			    pop bc 
8a03			 
8a03 c9				ret 
8a04			 
8a04			 
8a04			 
8a04			; eof 
# End of file firmware_general.asm
8a04			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a04			; display routines that use the physical hardware abstraction layer 
8a04			 
8a04			 
8a04			; Display an activity indicator 
8a04			; Each call returns the new char pointed to in hl 
8a04			 
8a04			active: 
8a04 3a bd eb			ld a, (display_active) 
8a07 fe 06			cp 6 
8a09			 
8a09 20 02			jr nz, .sne 
8a0b				; gone past the last one reset sequence 
8a0b 3e ff			ld a, 255 
8a0d			 
8a0d			.sne:   
8a0d				; get the next char in seq 
8a0d 3c				inc a 
8a0e 32 bd eb			ld (display_active), a 
8a11			 
8a11				; look up the string in the table 
8a11 21 28 8a			ld hl, actseq 
8a14 cb 27			sla a 
8a16 cd d6 8c			call addatohl 
8a19 cd 34 9d			call loadwordinhl 
8a1c			 
8a1c				; forth will write the to string when pushing so move from rom to ram 
8a1c			 
8a1c 11 be eb			ld de, display_active+1 
8a1f 01 02 00			ld bc, 2 
8a22 ed b0			ldir 
8a24			 
8a24 21 be eb			ld hl, display_active+1 
8a27 c9				ret 
8a28				 
8a28				 
8a28			 
8a28			 
8a28			;db "|/-\|-\" 
8a28			 
8a28			actseq: 
8a28			 
8a28 36 8a		dw spin0 
8a2a 38 8a		dw spin1 
8a2c 3a 8a		dw spin2 
8a2e 3c 8a		dw spin3 
8a30 3a 8a		dw spin2 
8a32 38 8a		dw spin1 
8a34 36 8a		dw spin0 
8a36			 
8a36 .. 00		spin0: db " ", 0 
8a38 .. 00		spin1: db "-", 0 
8a3a .. 00		spin2: db "+", 0 
8a3c .. 00		spin3: db "#", 0 
8a3e			 
8a3e			 
8a3e			; information window 
8a3e			 
8a3e			; pass hl with 1st string to display 
8a3e			; pass de with 2nd string to display 
8a3e			 
8a3e			info_panel: 
8a3e e5				push hl 
8a3f			 
8a3f 2a c3 eb			ld hl, (display_fb_active) 
8a42 e5				push hl    ; future de destination 
8a43 21 a8 ed				ld hl, display_fb0 
8a46 22 c3 eb				ld (display_fb_active), hl 
8a49			 
8a49			;	call clear_display 
8a49			 
8a49				if BASE_CPM 
8a49				ld a, '.' 
8a49				else 
8a49 3e a5			ld a, 165 
8a4b				endif 
8a4b cd b1 8a			call fill_display 
8a4e			 
8a4e			 
8a4e 3e 55			ld a, display_row_3 + 5 
8a50 cd be 8a			call str_at_display 
8a53			 
8a53 e1				pop hl 
8a54 d1				pop de 
8a55			 
8a55 e5				push hl 
8a56			 
8a56			 
8a56 3e 2d			ld a, display_row_2 + 5 
8a58 cd be 8a			call str_at_display 
8a5b			 
8a5b			 
8a5b cd ce 8a			call update_display 
8a5e cd 43 99			call next_page_prompt 
8a61 cd ac 8a			call clear_display 
8a64			 
8a64				 
8a64 21 07 ed				ld hl, display_fb1 
8a67 22 c3 eb				ld (display_fb_active), hl 
8a6a cd ce 8a			call update_display 
8a6d			 
8a6d e1				pop hl 
8a6e			 
8a6e c9				ret 
8a6f			 
8a6f			 
8a6f			 
8a6f			 
8a6f			; TODO windowing? 
8a6f			 
8a6f			; TODO scroll line up 
8a6f			 
8a6f			scroll_up: 
8a6f			 
8a6f e5				push hl 
8a70 d5				push de 
8a71 c5				push bc 
8a72			 
8a72				; get frame buffer  
8a72			 
8a72 2a c3 eb			ld hl, (display_fb_active) 
8a75 e5				push hl    ; future de destination 
8a76			 
8a76 11 28 00			ld  de, display_cols 
8a79 19				add hl, de 
8a7a			 
8a7a d1				pop de 
8a7b			 
8a7b				;ex de, hl 
8a7b 01 9f 00			ld bc, display_fb_len -1  
8a7e			;if DEBUG_FORTH_WORDS 
8a7e			;	DMARK "SCL" 
8a7e			;	CALLMONITOR 
8a7e			;endif	 
8a7e ed b0			ldir 
8a80			 
8a80				; wipe bottom row 
8a80			 
8a80			 
8a80 2a c3 eb			ld hl, (display_fb_active) 
8a83 11 a0 00			ld de, display_cols*display_rows 
8a86 19				add hl, de 
8a87 06 28			ld b, display_cols 
8a89			;	ld a, ' ' 
8a89			.scwipe: 
8a89 36 20			ld (hl), ' ' 
8a8b 2b				dec hl 
8a8c 10 fb			djnz .scwipe 
8a8e			 
8a8e				;pop hl 
8a8e			 
8a8e c1				pop bc 
8a8f d1				pop de 
8a90 e1				pop hl 
8a91			 
8a91 c9				ret 
8a92			 
8a92			 
8a92			;scroll_upo: 
8a92			;	ld de, display_row_1 
8a92			 ;	ld hl, display_row_2 
8a92			;	ld bc, display_cols 
8a92			;	ldir 
8a92			;	ld de, display_row_2 
8a92			 ;	ld hl, display_row_3 
8a92			;	ld bc, display_cols 
8a92			;	ldir 
8a92			;	ld de, display_row_3 
8a92			 ;	ld hl, display_row_4 
8a92			;	ld bc, display_cols 
8a92			;	ldir 
8a92			 
8a92			; TODO clear row 4 
8a92			 
8a92			;	ret 
8a92			 
8a92				 
8a92			scroll_down: 
8a92			 
8a92 e5				push hl 
8a93 d5				push de 
8a94 c5				push bc 
8a95			 
8a95				; get frame buffer  
8a95			 
8a95 2a c3 eb			ld hl, (display_fb_active) 
8a98			 
8a98 11 9f 00			ld de, display_fb_len - 1 
8a9b 19				add hl, de 
8a9c			 
8a9c e5			push hl    ; future de destination 
8a9d			 
8a9d 11 28 00			ld  de, display_cols 
8aa0 ed 52			sbc hl, de 
8aa2			 
8aa2			 
8aa2 d1				pop de 
8aa3			 
8aa3			;	ex de, hl 
8aa3 01 9f 00			ld bc, display_fb_len -1  
8aa6			 
8aa6			 
8aa6				 
8aa6			 
8aa6 ed b0			ldir 
8aa8			 
8aa8				; wipe bottom row 
8aa8			 
8aa8			 
8aa8			;	ld hl, (display_fb_active) 
8aa8			;;	ld de, display_cols*display_rows 
8aa8			;;	add hl, de 
8aa8			;	ld b, display_cols 
8aa8			;	ld a, ' ' 
8aa8			;.scwiped: 
8aa8			;	ld (hl), a 
8aa8			;	dec hl 
8aa8			;	djnz .scwiped 
8aa8			 
8aa8				;pop hl 
8aa8			 
8aa8 c1				pop bc 
8aa9 d1				pop de 
8aaa e1				pop hl 
8aab			 
8aab c9				ret 
8aac			;scroll_down: 
8aac			;	ld de, display_row_4 
8aac			;	ld hl, display_row_3 
8aac			;	ld bc, display_cols 
8aac			;	ldir 
8aac			;	ld de, display_row_3 
8aac			; 	ld hl, display_row_2 
8aac			;	ld bc, display_cols 
8aac			;	ldir 
8aac			;	ld de, display_row_2 
8aac			;	ld hl, display_row_1 
8aac			;	ld bc, display_cols 
8aac			;	ldir 
8aac			;;; TODO clear row 1 
8aac			;	ret 
8aac			 
8aac			 
8aac			 
8aac			 
8aac			 
8aac			; clear active frame buffer 
8aac			 
8aac			clear_display: 
8aac 3e 20			ld a, ' ' 
8aae c3 b1 8a			jp fill_display 
8ab1			 
8ab1			; fill active frame buffer with a char in A 
8ab1			 
8ab1			fill_display: 
8ab1 06 a0			ld b,display_fb_len 
8ab3 2a c3 eb			ld hl, (display_fb_active) 
8ab6 77			.fd1:	ld (hl),a 
8ab7 23				inc hl 
8ab8 10 fc			djnz .fd1 
8aba 23				inc hl 
8abb			;	ld a,0 
8abb 36 00			ld (hl),0 
8abd			 
8abd			 
8abd c9				ret 
8abe			; Write string (DE) at pos (A) to active frame buffer 
8abe			 
8abe 2a c3 eb		str_at_display:    ld hl,(display_fb_active) 
8ac1 06 00					ld b,0 
8ac3 4f					ld c,a 
8ac4 09					add hl,bc 
8ac5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8ac6 b7			            OR   A              ;Null terminator? 
8ac7 c8			            RET  Z              ;Yes, so finished 
8ac8 77					ld (hl),a 
8ac9 23				inc hl 
8aca 13			            INC  DE             ;Point to next character 
8acb 18 f8		            JR   .sad1     ;Repeat 
8acd c9					ret 
8ace			 
8ace			; using current frame buffer write to physical display 
8ace			 
8ace			update_display: 
8ace e5				push hl 
8acf 2a c3 eb			ld hl, (display_fb_active) 
8ad2 cd f4 e2			call write_display 
8ad5 e1				pop hl 
8ad6 c9				ret 
8ad7			 
8ad7			; TODO scrolling 
8ad7			 
8ad7			 
8ad7			; move cursor right one char 
8ad7			cursor_right: 
8ad7			 
8ad7				; TODO shift right 
8ad7				; TODO if beyond max col 
8ad7				; TODO       cursor_next_line 
8ad7			 
8ad7 c9				ret 
8ad8			 
8ad8			 
8ad8			cursor_next_line: 
8ad8				; TODO first char 
8ad8				; TODO line down 
8ad8				; TODO if past last row 
8ad8				; TODO    scroll up 
8ad8			 
8ad8 c9				ret 
8ad9			 
8ad9			cursor_left: 
8ad9				; TODO shift left 
8ad9				; TODO if beyond left  
8ad9				; TODO     cursor prev line 
8ad9				 
8ad9 c9				ret 
8ada			 
8ada			cursor_prev_line: 
8ada				; TODO last char 
8ada				; TODO line up 
8ada				; TODO if past first row 
8ada				; TODO   scroll down 
8ada			 
8ada c9				ret 
8adb			 
8adb			 
8adb			cout: 
8adb				; A - char 
8adb c9				ret 
8adc			 
8adc			 
8adc			; Display a menu and allow item selection (optional toggle items) 
8adc			; 
8adc			; format: 
8adc			; hl pointer to word array with zero term for items 
8adc			; e.g.    db item1 
8adc			;         db .... 
8adc			;         db 0 
8adc			; 
8adc			; a = starting menu item  
8adc			; 
8adc			; de = pointer item toggle array   (todo) 
8adc			; 
8adc			; returns item selected in a 1-... 
8adc			; returns 0 if back button pressed 
8adc			; 
8adc			; NOTE: Uses system frame buffer to display 
8adc			; 
8adc			; LEFT, Q = go back 
8adc			; RIGHT, SPACE, CR = select 
8adc			; UP, A - Up 
8adc			; DOWN, Z - Down 
8adc			 
8adc			 
8adc			 
8adc			 
8adc			 
8adc			menu: 
8adc			 
8adc					; keep array pointer 
8adc			 
8adc 22 6a ea				ld (store_tmp1), hl 
8adf 32 68 ea				ld (store_tmp2), a 
8ae2			 
8ae2					; check for key bounce 
8ae2			 
8ae2			if BASE_KEV 
8ae2			 
8ae2			.mbounce:	call cin 
8ae2			;		cp 0 
8ae2					or a 
8ae2					jr nz, .mbounce 
8ae2			endif 
8ae2					; for ease use ex 
8ae2			 
8ae2					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae2 21 a8 ed				ld hl, display_fb0 
8ae5 22 c3 eb				ld (display_fb_active), hl 
8ae8			 
8ae8 cd ac 8a		.mloop:		call clear_display 
8aeb cd ce 8a				call update_display 
8aee			 
8aee					; draw selection id '>' at 1 
8aee			 
8aee					; init start of list display 
8aee			 
8aee 3e 05				ld a, 5 
8af0 32 66 ea				ld (store_tmp3), a   ; display row count 
8af3 3a 68 ea				ld a,( store_tmp2) 
8af6 32 69 ea				ld (store_tmp2+1), a   ; display item count 
8af9			 
8af9					 
8af9			.mitem:	 
8af9			 
8af9			 
8af9 3a 69 ea				ld a,(store_tmp2+1) 
8afc 6f					ld l, a 
8afd 26 00				ld h, 0 
8aff 29					add hl, hl 
8b00 ed 5b 6a ea			ld de, (store_tmp1) 
8b04 19					add hl, de 
8b05 7e					ld a, (hl) 
8b06 23					inc hl 
8b07 66					ld h,(hl) 
8b08 6f					ld l, a 
8b09			 
8b09 cd ff 8c				call ishlzero 
8b0c 28 1a				jr z, .mdone 
8b0e			 
8b0e eb					ex de, hl 
8b0f 3a 66 ea				ld a, (store_tmp3) 
8b12 cd be 8a				call str_at_display 
8b15					 
8b15			 
8b15					; next item 
8b15 3a 69 ea				ld a, (store_tmp2+1) 
8b18 3c					inc a 
8b19 32 69 ea				ld (store_tmp2+1), a   ; display item count 
8b1c			 
8b1c			 		; next row 
8b1c			 
8b1c 3a 66 ea				ld a, (store_tmp3) 
8b1f c6 28				add display_cols 
8b21 32 66 ea				ld (store_tmp3), a 
8b24			 
8b24					; at end of screen? 
8b24			 
8b24 fe 10				cp display_rows*4 
8b26 20 d1				jr nz, .mitem 
8b28			 
8b28			 
8b28			.mdone: 
8b28 cd ff 8c				call ishlzero 
8b2b 28 08				jr z, .nodn 
8b2d			 
8b2d 3e 78				ld a, display_row_4 
8b2f 11 ac 8b				ld de, .mdown 
8b32 cd be 8a				call str_at_display 
8b35			 
8b35					; draw options to fill the screens with active item on line 1 
8b35					; if current option is 2 or more then display ^ in top 
8b35			 
8b35 3a 68 ea		.nodn:		ld a, (store_tmp2) 
8b38			;		cp 0 
8b38 b7					or a 
8b39 28 08				jr z, .noup 
8b3b			 
8b3b 3e 00				ld a, 0 
8b3d 11 aa 8b				ld de, .mup 
8b40 cd be 8a				call str_at_display 
8b43			 
8b43 3e 02		.noup:		ld a, 2 
8b45 11 a8 8b				ld de, .msel 
8b48 cd be 8a				call str_at_display 
8b4b			 
8b4b					; if current option + 1 is not null then display V in bottom 
8b4b					; get key 
8b4b cd ce 8a				call update_display 
8b4e			 
8b4e			 
8b4e					; handle key 
8b4e			 
8b4e cd 80 e3				call cin_wait 
8b51			 
8b51 fe 05				cp KEY_UP 
8b53 28 2b				jr z, .mgoup 
8b55 fe 61				cp 'a' 
8b57 28 27				jr z, .mgoup 
8b59 fe 0a				cp KEY_DOWN 
8b5b 28 31				jr z, .mgod 
8b5d fe 7a				cp 'z' 
8b5f 28 2d				jr z, .mgod 
8b61 fe 20				cp ' ' 
8b63 28 33				jr z, .goend 
8b65 fe 0c				cp KEY_RIGHT 
8b67 28 2f				jr z, .goend 
8b69 fe 0d				cp KEY_CR 
8b6b 28 2b				jr z, .goend 
8b6d fe 71				cp 'q' 
8b6f 28 0b				jr z, .goback 
8b71			 
8b71 fe 0b				cp KEY_LEFT 
8b73 28 07				jr z, .goback 
8b75 fe 08				cp KEY_BS 
8b77 28 03				jr z, .goback 
8b79 c3 e8 8a				jp .mloop 
8b7c			 
8b7c			.goback: 
8b7c 3e 00			ld a, 0 
8b7e 18 1c			jr .goend2 
8b80			 
8b80				; move up one 
8b80			.mgoup: 
8b80 3a 68 ea				ld a, (store_tmp2) 
8b83			;		cp 0 
8b83 b7					or a 
8b84 ca e8 8a				jp z, .mloop 
8b87 3d					dec a 
8b88 32 68 ea				ld (store_tmp2), a 
8b8b c3 e8 8a				jp .mloop 
8b8e			 
8b8e				; move down one 
8b8e			.mgod: 
8b8e 3a 68 ea				ld a, (store_tmp2) 
8b91 3c					inc a 
8b92 32 68 ea				ld (store_tmp2), a 
8b95 c3 e8 8a				jp .mloop 
8b98			 
8b98			 
8b98			.goend: 
8b98					; get selected item number 
8b98			 
8b98 3a 68 ea				ld a, (store_tmp2) 
8b9b 3c					inc a 
8b9c			 
8b9c			.goend2: 
8b9c f5					push af 
8b9d			 
8b9d					; restore active fb 
8b9d					; TODO BUG assumes fb1 
8b9d			 
8b9d 21 07 ed				ld hl, display_fb1 
8ba0 22 c3 eb				ld (display_fb_active), hl 
8ba3			 
8ba3					; restore main regs 
8ba3			 
8ba3			 
8ba3 cd ce 8a				call update_display 
8ba6			 
8ba6 f1					pop af 
8ba7			 
8ba7 c9				ret 
8ba8			 
8ba8 .. 00		.msel:   db ">",0 
8baa .. 00		.mup:   db "^",0 
8bac .. 00		.mdown:   db "v",0 
8bae			 
8bae			 
8bae			; eof 
8bae			 
# End of file firmware_display.asm
8bae			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bae			; random number generators 
8bae			 
8bae			 
8bae			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bae			 
8bae			 
8bae			;-----> Generate a random number 
8bae			; output a=answer 0<=a<=255 
8bae			; all registers are preserved except: af 
8bae			random: 
8bae e5			        push    hl 
8baf d5			        push    de 
8bb0 2a a2 eb		        ld      hl,(randData) 
8bb3 ed 5f		        ld      a,r 
8bb5 57			        ld      d,a 
8bb6 5e			        ld      e,(hl) 
8bb7 19			        add     hl,de 
8bb8 85			        add     a,l 
8bb9 ac			        xor     h 
8bba 22 a2 eb		        ld      (randData),hl 
8bbd d1			        pop     de 
8bbe e1			        pop     hl 
8bbf c9			        ret 
8bc0			 
8bc0			 
8bc0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc0			 
8bc0			 
8bc0			 
8bc0			;------LFSR------ 
8bc0			;James Montelongo 
8bc0			;optimized by Spencer Putt 
8bc0			;out: 
8bc0			; a = 8 bit random number 
8bc0			RandLFSR: 
8bc0 21 a8 eb		        ld hl,LFSRSeed+4 
8bc3 5e			        ld e,(hl) 
8bc4 23			        inc hl 
8bc5 56			        ld d,(hl) 
8bc6 23			        inc hl 
8bc7 4e			        ld c,(hl) 
8bc8 23			        inc hl 
8bc9 7e			        ld a,(hl) 
8bca 47			        ld b,a 
8bcb cb 13		        rl e  
8bcd cb 12			rl d 
8bcf cb 11		        rl c  
8bd1 17				rla 
8bd2 cb 13		        rl e  
8bd4 cb 12			rl d 
8bd6 cb 11		        rl c  
8bd8 17				rla 
8bd9 cb 13		        rl e  
8bdb cb 12			rl d 
8bdd cb 11		        rl c  
8bdf 17				rla 
8be0 67			        ld h,a 
8be1 cb 13		        rl e  
8be3 cb 12			rl d 
8be5 cb 11		        rl c  
8be7 17				rla 
8be8 a8			        xor b 
8be9 cb 13		        rl e  
8beb cb 12			rl d 
8bed ac			        xor h 
8bee a9			        xor c 
8bef aa			        xor d 
8bf0 21 aa eb		        ld hl,LFSRSeed+6 
8bf3 11 ab eb		        ld de,LFSRSeed+7 
8bf6 01 07 00		        ld bc,7 
8bf9 ed b8		        lddr 
8bfb 12			        ld (de),a 
8bfc c9			        ret 
8bfd			 
8bfd			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8bfd			 
8bfd			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8bfd			 
8bfd			 
8bfd			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8bfd			 
8bfd			prng16: 
8bfd			;Inputs: 
8bfd			;   (seed1) contains a 16-bit seed value 
8bfd			;   (seed2) contains a NON-ZERO 16-bit seed value 
8bfd			;Outputs: 
8bfd			;   HL is the result 
8bfd			;   BC is the result of the LCG, so not that great of quality 
8bfd			;   DE is preserved 
8bfd			;Destroys: 
8bfd			;   AF 
8bfd			;cycle: 4,294,901,760 (almost 4.3 billion) 
8bfd			;160cc 
8bfd			;26 bytes 
8bfd 2a 9c eb		    ld hl,(seed1) 
8c00 44			    ld b,h 
8c01 4d			    ld c,l 
8c02 29			    add hl,hl 
8c03 29			    add hl,hl 
8c04 2c			    inc l 
8c05 09			    add hl,bc 
8c06 22 9c eb		    ld (seed1),hl 
8c09 2a 9a eb		    ld hl,(seed2) 
8c0c 29			    add hl,hl 
8c0d 9f			    sbc a,a 
8c0e e6 2d		    and %00101101 
8c10 ad			    xor l 
8c11 6f			    ld l,a 
8c12 22 9a eb		    ld (seed2),hl 
8c15 09			    add hl,bc 
8c16 c9			    ret 
8c17			 
8c17			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c17			 
8c17			rand32: 
8c17			;Inputs: 
8c17			;   (seed1_0) holds the lower 16 bits of the first seed 
8c17			;   (seed1_1) holds the upper 16 bits of the first seed 
8c17			;   (seed2_0) holds the lower 16 bits of the second seed 
8c17			;   (seed2_1) holds the upper 16 bits of the second seed 
8c17			;   **NOTE: seed2 must be non-zero 
8c17			;Outputs: 
8c17			;   HL is the result 
8c17			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c17			;Destroys: 
8c17			;   AF 
8c17			;Tested and passes all CAcert tests 
8c17			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c17			;it has a period of 18,446,744,069,414,584,320 
8c17			;roughly 18.4 quintillion. 
8c17			;LFSR taps: 0,2,6,7  = 11000101 
8c17			;291cc 
8c17			;seed1_0=$+1 
8c17			;    ld hl,12345 
8c17			;seed1_1=$+1 
8c17			;    ld de,6789 
8c17			;    ld b,h 
8c17			;    ld c,l 
8c17			;    add hl,hl \ rl e \ rl d 
8c17			;    add hl,hl \ rl e \ rl d 
8c17			;    inc l 
8c17			;    add hl,bc 
8c17			;    ld (seed1_0),hl 
8c17			;    ld hl,(seed1_1) 
8c17			;    adc hl,de 
8c17			;    ld (seed1_1),hl 
8c17			;    ex de,hl 
8c17			;seed2_0=$+1 
8c17			;    ld hl,9876 
8c17			;seed2_1=$+1 
8c17			;    ld bc,54321 
8c17			;    add hl,hl \ rl c \ rl b 
8c17			;    ld (seed2_1),bc 
8c17			;    sbc a,a 
8c17			;    and %11000101 
8c17			;    xor l 
8c17			;    ld l,a 
8c17			;    ld (seed2_0),hl 
8c17			;    ex de,hl 
8c17			;    add hl,bc 
8c17			;    ret 
8c17			; 
8c17			 
8c17			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c17			; 20 bytes, 86 cycles (excluding ret) 
8c17			 
8c17			; returns   hl = pseudorandom number 
8c17			; corrupts   a 
8c17			 
8c17			; generates 16-bit pseudorandom numbers with a period of 65535 
8c17			; using the xorshift method: 
8c17			 
8c17			; hl ^= hl << 7 
8c17			; hl ^= hl >> 9 
8c17			; hl ^= hl << 8 
8c17			 
8c17			; some alternative shift triplets which also perform well are: 
8c17			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c17			 
8c17			;  org 32768 
8c17			 
8c17			xrnd: 
8c17 2a a0 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c1a 3e 00		  ld a,0 
8c1c bd			  cp l 
8c1d 20 02		  jr nz, .xrnd1 
8c1f 2e 01		  ld l, 1 
8c21			.xrnd1: 
8c21			 
8c21 7c			  ld a,h 
8c22 1f			  rra 
8c23 7d			  ld a,l 
8c24 1f			  rra 
8c25 ac			  xor h 
8c26 67			  ld h,a 
8c27 7d			  ld a,l 
8c28 1f			  rra 
8c29 7c			  ld a,h 
8c2a 1f			  rra 
8c2b ad			  xor l 
8c2c 6f			  ld l,a 
8c2d ac			  xor h 
8c2e 67			  ld h,a 
8c2f			 
8c2f 22 a0 eb		  ld (xrandc),hl 
8c32			 
8c32 c9			  ret 
8c33			;  
8c33			 
8c33			 
8c33			;;;; int maths 
8c33			 
8c33			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c33			; Divide 16-bit values (with 16-bit result) 
8c33			; In: Divide BC by divider DE 
8c33			; Out: BC = result, HL = rest 
8c33			; 
8c33			Div16: 
8c33 21 00 00		    ld hl,0 
8c36 78			    ld a,b 
8c37 06 08		    ld b,8 
8c39			Div16_Loop1: 
8c39 17			    rla 
8c3a ed 6a		    adc hl,hl 
8c3c ed 52		    sbc hl,de 
8c3e 30 01		    jr nc,Div16_NoAdd1 
8c40 19			    add hl,de 
8c41			Div16_NoAdd1: 
8c41 10 f6		    djnz Div16_Loop1 
8c43 17			    rla 
8c44 2f			    cpl 
8c45 47			    ld b,a 
8c46 79			    ld a,c 
8c47 48			    ld c,b 
8c48 06 08		    ld b,8 
8c4a			Div16_Loop2: 
8c4a 17			    rla 
8c4b ed 6a		    adc hl,hl 
8c4d ed 52		    sbc hl,de 
8c4f 30 01		    jr nc,Div16_NoAdd2 
8c51 19			    add hl,de 
8c52			Div16_NoAdd2: 
8c52 10 f6		    djnz Div16_Loop2 
8c54 17			    rla 
8c55 2f			    cpl 
8c56 41			    ld b,c 
8c57 4f			    ld c,a 
8c58 c9			ret 
8c59			 
8c59			 
8c59			;http://z80-heaven.wikidot.com/math 
8c59			; 
8c59			;Inputs: 
8c59			;     DE and A are factors 
8c59			;Outputs: 
8c59			;     A is not changed 
8c59			;     B is 0 
8c59			;     C is not changed 
8c59			;     DE is not changed 
8c59			;     HL is the product 
8c59			;Time: 
8c59			;     342+6x 
8c59			; 
8c59			Mult16: 
8c59			 
8c59 06 08		     ld b,8          ;7           7 
8c5b 21 00 00		     ld hl,0         ;10         10 
8c5e 29			       add hl,hl     ;11*8       88 
8c5f 07			       rlca          ;4*8        32 
8c60 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c62 19			         add hl,de   ;--         -- 
8c63 10 f9		       djnz $-5      ;13*7+8     99 
8c65 c9			ret 
8c66			 
8c66			; 
8c66			; Square root of 16-bit value 
8c66			; In:  HL = value 
8c66			; Out:  D = result (rounded down) 
8c66			; 
8c66			;Sqr16: 
8c66			;    ld de,#0040 
8c66			;    ld a,l 
8c66			;    ld l,h 
8c66			;    ld h,d 
8c66			;    or a 
8c66			;    ld b,8 
8c66			;Sqr16_Loop: 
8c66			;    sbc hl,de 
8c66			;    jr nc,Sqr16_Skip 
8c66			;    add hl,de 
8c66			;Sqr16_Skip: 
8c66			;    ccf 
8c66			;    rl d 
8c66			;    add a,a 
8c66			;    adc hl,hl 
8c66			;    add a,a 
8c66			;    adc hl,hl 
8c66			;    djnz Sqr16_Loop 
8c66			;    ret 
8c66			; 
8c66			; 
8c66			; Divide 8-bit values 
8c66			; In: Divide E by divider C 
8c66			; Out: A = result, B = rest 
8c66			; 
8c66			Div8: 
8c66 af			    xor a 
8c67 06 08		    ld b,8 
8c69			Div8_Loop: 
8c69 cb 13		    rl e 
8c6b 17			    rla 
8c6c 91			    sub c 
8c6d 30 01		    jr nc,Div8_NoAdd 
8c6f 81			    add a,c 
8c70			Div8_NoAdd: 
8c70 10 f7		    djnz Div8_Loop 
8c72 47			    ld b,a 
8c73 7b			    ld a,e 
8c74 17			    rla 
8c75 2f			    cpl 
8c76 c9			    ret 
8c77			 
8c77			; 
8c77			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c77			; In: Multiply A with DE 
8c77			; Out: HL = result 
8c77			; 
8c77			Mult12U: 
8c77 2e 00		    ld l,0 
8c79 87			    add a,a 
8c7a 30 01		    jr nc,Mult12U_NoAdd0 
8c7c 19			    add hl,de 
8c7d			Mult12U_NoAdd0: 
8c7d 29			    add hl,hl 
8c7e 87			    add a,a 
8c7f 30 01		    jr nc,Mult12U_NoAdd1 
8c81 19			    add hl,de 
8c82			Mult12U_NoAdd1: 
8c82 29			    add hl,hl 
8c83 87			    add a,a 
8c84 30 01		    jr nc,Mult12U_NoAdd2 
8c86 19			    add hl,de 
8c87			Mult12U_NoAdd2: 
8c87 29			    add hl,hl 
8c88 87			    add a,a 
8c89 30 01		    jr nc,Mult12U_NoAdd3 
8c8b 19			    add hl,de 
8c8c			Mult12U_NoAdd3: 
8c8c 29			    add hl,hl 
8c8d 87			    add a,a 
8c8e 30 01		    jr nc,Mult12U_NoAdd4 
8c90 19			    add hl,de 
8c91			Mult12U_NoAdd4: 
8c91 29			    add hl,hl 
8c92 87			    add a,a 
8c93 30 01		    jr nc,Mult12U_NoAdd5 
8c95 19			    add hl,de 
8c96			Mult12U_NoAdd5: 
8c96 29			    add hl,hl 
8c97 87			    add a,a 
8c98 30 01		    jr nc,Mult12U_NoAdd6 
8c9a 19			    add hl,de 
8c9b			Mult12U_NoAdd6: 
8c9b 29			    add hl,hl 
8c9c 87			    add a,a 
8c9d d0			    ret nc 
8c9e 19			    add hl,de 
8c9f c9			    ret 
8ca0			 
8ca0			; 
8ca0			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca0			; In: Multiply A with DE 
8ca0			;      Put lowest value in A for most efficient calculation 
8ca0			; Out: HL = result 
8ca0			; 
8ca0			Mult12R: 
8ca0 21 00 00		    ld hl,0 
8ca3			Mult12R_Loop: 
8ca3 cb 3f		    srl a 
8ca5 30 01		    jr nc,Mult12R_NoAdd 
8ca7 19			    add hl,de 
8ca8			Mult12R_NoAdd: 
8ca8 cb 23		    sla e 
8caa cb 12		    rl d 
8cac b7			    or a 
8cad c2 a3 8c		    jp nz,Mult12R_Loop 
8cb0 c9			    ret 
8cb1			 
8cb1			; 
8cb1			; Multiply 16-bit values (with 32-bit result) 
8cb1			; In: Multiply BC with DE 
8cb1			; Out: BCHL = result 
8cb1			; 
8cb1			Mult32: 
8cb1 79			    ld a,c 
8cb2 48			    ld c,b 
8cb3 21 00 00		    ld hl,0 
8cb6 06 10		    ld b,16 
8cb8			Mult32_Loop: 
8cb8 29			    add hl,hl 
8cb9 17			    rla 
8cba cb 11		    rl c 
8cbc 30 07		    jr nc,Mult32_NoAdd 
8cbe 19			    add hl,de 
8cbf ce 00		    adc a,0 
8cc1 d2 c5 8c		    jp nc,Mult32_NoAdd 
8cc4 0c			    inc c 
8cc5			Mult32_NoAdd: 
8cc5 10 f1		    djnz Mult32_Loop 
8cc7 41			    ld b,c 
8cc8 4f			    ld c,a 
8cc9 c9			    ret 
8cca			 
8cca			 
8cca			 
8cca			; 
8cca			; Multiply 8-bit values 
8cca			; In:  Multiply H with E 
8cca			; Out: HL = result 
8cca			; 
8cca			Mult8: 
8cca 16 00		    ld d,0 
8ccc 6a			    ld l,d 
8ccd 06 08		    ld b,8 
8ccf			Mult8_Loop: 
8ccf 29			    add hl,hl 
8cd0 30 01		    jr nc,Mult8_NoAdd 
8cd2 19			    add hl,de 
8cd3			Mult8_NoAdd: 
8cd3 10 fa		    djnz Mult8_Loop 
8cd5 c9			    ret 
8cd6			 
8cd6			 
8cd6			 
8cd6			 
8cd6			 
8cd6			 
8cd6			 
8cd6			 
8cd6			;;http://z80-heaven.wikidot.com/math 
8cd6			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cd6			; 
8cd6			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cd6			;     ld a,16        ;7 
8cd6			;     ld hl,0        ;10 
8cd6			;     jp $+5         ;10 
8cd6			;.DivLoop: 
8cd6			;       add hl,bc    ;-- 
8cd6			;       dec a        ;64 
8cd6			;       jr z,.DivLoopEnd        ;86 
8cd6			; 
8cd6			;       sla e        ;128 
8cd6			;       rl d         ;128 
8cd6			;       adc hl,hl    ;240 
8cd6			;       sbc hl,bc    ;240 
8cd6			;       jr nc,.DivLoop ;23|21 
8cd6			;       inc e        ;-- 
8cd6			;       jp .DivLoop+1 
8cd6			; 
8cd6			;.DivLoopEnd: 
8cd6			 
8cd6			;HL_Div_C: 
8cd6			;Inputs: 
8cd6			;     HL is the numerator 
8cd6			;     C is the denominator 
8cd6			;Outputs: 
8cd6			;     A is the remainder 
8cd6			;     B is 0 
8cd6			;     C is not changed 
8cd6			;     DE is not changed 
8cd6			;     HL is the quotient 
8cd6			; 
8cd6			;       ld b,16 
8cd6			;       xor a 
8cd6			;         add hl,hl 
8cd6			;         rla 
8cd6			;         cp c 
8cd6			;         jr c,$+4 
8cd6			;           inc l 
8cd6			;           sub c 
8cd6			;         djnz $-7 
8cd6			 
8cd6			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cd6			 
8cd6			addatohl: 
8cd6 85			    add   a, l    ; A = A+L 
8cd7 6f			    ld    l, a    ; L = A+L 
8cd8 8c			    adc   a, h    ; A = A+L+H+carry 
8cd9 95			    sub   l       ; A = H+carry 
8cda 67			    ld    h, a    ; H = H+carry 
8cdb c9			ret 
8cdc			 
8cdc			addatode: 
8cdc 83			    add   a, e    ; A = A+L 
8cdd 5f			    ld    e, a    ; L = A+L 
8cde 8a			    adc   a, d    ; A = A+L+H+carry 
8cdf 93			    sub   e       ; A = H+carry 
8ce0 57			    ld    d, a    ; H = H+carry 
8ce1 c9			ret 
8ce2			 
8ce2			 
8ce2			addatobc: 
8ce2 81			    add   a, c    ; A = A+L 
8ce3 4f			    ld    c, a    ; L = A+L 
8ce4 88			    adc   a, b    ; A = A+L+H+carry 
8ce5 91			    sub   c       ; A = H+carry 
8ce6 47			    ld    b, a    ; H = H+carry 
8ce7 c9			ret 
8ce8			 
8ce8			subafromhl: 
8ce8			   ; If A=0 do nothing 
8ce8			    ; Otherwise flip A's sign. Since 
8ce8			    ; the upper byte becomes -1, also 
8ce8			    ; substract 1 from H. 
8ce8 ed 44		    neg 
8cea ca f3 8c		    jp    z, Skip 
8ced 25			    dec   h 
8cee			     
8cee			    ; Now add the low byte as usual 
8cee			    ; Two's complement takes care of 
8cee			    ; ensuring the result is correct 
8cee 85			    add   a, l 
8cef 6f			    ld    l, a 
8cf0 8c			    adc   a, h 
8cf1 95			    sub   l 
8cf2 67			    ld    h, a 
8cf3			Skip: 
8cf3 c9				ret 
8cf4			 
8cf4			 
8cf4			; compare hl and de 
8cf4			; returns:  
8cf4			; if hl = de, z=1, s=0, c0=0 
8cf4			; if hl > de, z=0, s=0, c=0 
8cf4			; if hl < de, z=0, s=1, c=1 
8cf4			cmp16:	 
8cf4 b7				or a 
8cf5 ed 52			sbc hl,de 
8cf7 e0				ret po 
8cf8 7c				ld a,h 
8cf9 1f				rra 
8cfa ee 40			xor 01000000B 
8cfc 37				scf 
8cfd 8f				adc a,a 
8cfe c9				ret 
8cff			 
8cff			 
8cff			; test if hl contains zero   - A is destroyed 
8cff			 
8cff			ishlzero:    
8cff b7				or a     ; reset flags 
8d00 7c				ld a, h 
8d01 b5				or l        	 
8d02			 
8d02 c9				ret 
8d03			 
8d03			 
8d03			 
8d03			 
8d03			if FORTH_ENABLE_FLOATMATH 
8d03			;include "float/bbcmath.z80" 
8d03			include "float/lpfpcalc.asm" 
8d03			endif 
8d03			 
8d03			 
8d03			; eof 
8d03			 
# End of file firmware_maths.asm
8d03			include "firmware_strings.asm"   ; string handling  
8d03			 
8d03			 
8d03			; TODO string len 
8d03			; input text string, end on cr with zero term 
8d03			; a offset into frame buffer to start prompt 
8d03			; d is max length 
8d03			; e is display size TODO 
8d03			; c is current cursor position 
8d03			; hl is ptr to where string will be stored and edited directly 
8d03			 
8d03			 
8d03			; TODO check limit of buffer for new inserts 
8d03			; TODO check insert does not push beyond buffer 
8d03			; TODO scroll in a limited display area 
8d03			; TODO scroll whole screen on page wrap 
8d03			 
8d03			 
8d03			; TODO use LCD cursor? 
8d03			 
8d03			EDIT_V1: equ 0 
8d03			EDIT_V2: equ 1 
8d03			 
8d03			 
8d03			 
8d03			if EDIT_V2 
8d03			input_str: 
8d03			 
8d03 32 5b ee			    	ld (input_at_pos),a      ; save display position to start 
8d06			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
8d06 22 5e ee				ld (input_start), hl     ; save ptr to buffer 
8d09			;		ld a, c 
8d09			;		call addatohl 
8d09			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
8d09 7a					ld a,d 
8d0a 32 5d ee			        ld (input_size), a       ; save length of input area 
8d0d 79					ld a, c 
8d0e 32 4c ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
8d11 7b					ld a,e 
8d12 32 5c ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d15			 
8d15			 
8d15					; add a trailing space to make screen refresh nicer 
8d15			 
8d15					;ld hl, (input_start) 
8d15					;push hl 
8d15					;ld a, 0 
8d15					;call strlent 
8d15					;ld a, l 
8d15					;pop hl 
8d15					;call addatohl 
8d15					;dec hl 
8d15					;ld a, ' ' 
8d15					;ld (hl), a 
8d15					;inc hl 
8d15					;ld (hl), a 
8d15					;inc hl 
8d15					;ld a, 0 
8d15					;ld (hl), a 
8d15			 
8d15			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d15					; init cursor shape if not set by the cin routines 
8d15 21 b8 eb				ld hl, cursor_shape 
8d18			if BASE_KEV 
8d18			;		ld a, 255 
8d18					ld (hl), 255 
8d18			else 
8d18					;ld a, '#' 
8d18 36 23				ld (hl), '#' 
8d1a			endif 
8d1a 23					inc hl 
8d1b			;		ld a, 0 
8d1b 36 00				ld (hl), 0 
8d1d			 
8d1d 3e 09				ld a, CUR_BLINK_RATE 
8d1f 32 57 ee				ld (input_cur_flash), a 
8d22 3e 01				ld a, 1 
8d24 32 56 ee				ld (input_cur_onoff),a 
8d27			.inmain:	 
8d27			 
8d27 cd 48 8e				call input_disp_ref 
8d2a			 
8d2a					; save current length of string 
8d2a			 
8d2a 2a 5e ee				ld hl, (input_start) 
8d2d 3e 00				ld a, 0 
8d2f cd 39 90				call strlent 
8d32 7d					ld a,l 
8d33 32 51 ee				ld (input_len), a 
8d36			 
8d36					;call input_disp_oncur 
8d36			 
8d36					; display current state of input buffer 
8d36			 
8d36					; clean any backspace chars 
8d36			 
8d36 3e 20				ld a, " " 
8d38 32 b8 e2				ld (scratch),a 
8d3b 3e 00				ld a, 0 
8d3d 32 b9 e2				ld (scratch+1),a 
8d40 3a 5b ee				ld a,(input_at_pos) 
8d43 85					add l 
8d44 11 b8 e2				ld de, scratch 
8d47 cd be 8a				call str_at_display 
8d4a			 
8d4a					; pause 1ms 
8d4a			 
8d4a 3e 01				ld a, 1 
8d4c cd d5 89				call aDelayInMS 
8d4f			 
8d4f			; display cursor if visible on this cycle 
8d4f			 
8d4f					; dec flash counter 
8d4f 3a 57 ee				ld a, (input_cur_flash) 
8d52 3d					dec a 
8d53 32 57 ee				ld (input_cur_flash), a 
8d56			;		cp 0 
8d56 b7					or a 
8d57 20 0d				jr nz, .inochgstate 
8d59			 
8d59			 
8d59					; reset on change of state 
8d59 3e 09				ld a, CUR_BLINK_RATE 
8d5b 32 57 ee				ld (input_cur_flash), a 
8d5e			 
8d5e					; change state 
8d5e 3a 56 ee				ld a,(input_cur_onoff) 
8d61 ed 44				neg 
8d63 32 56 ee				ld (input_cur_onoff),a 
8d66			 
8d66			 
8d66			 
8d66			 
8d66					; TODO is cursor visible? 
8d66					; TODO if so then over write the char at curspos pos with the cursor shape 
8d66			 
8d66								 
8d66			 
8d66			.inochgstate: 
8d66 3a 56 ee				ld a,(input_cur_onoff) 
8d69 fe ff				cp 255 
8d6b 28 0e				jr z, .skipcursor 
8d6d 3a 5b ee				ld a, (input_at_pos) 
8d70 47					ld b, a 
8d71 3a 4c ee				ld a, (input_cursor) 
8d74 80					add b 
8d75 11 b8 eb				ld de, cursor_shape 
8d78					 
8d78 cd be 8a				call str_at_display 
8d7b			 
8d7b			.skipcursor: 
8d7b				if DEBUG_INPUTV2 
8d7b			 
8d7b					ld a,(input_at_pos) 
8d7b					ld hl, LFSRSeed 
8d7b					call hexout 
8d7b					ld a, (input_cursor) 
8d7b					ld hl, LFSRSeed+2 
8d7b					call hexout 
8d7b					ld a,(input_size) 
8d7b					ld hl, LFSRSeed+4 
8d7b					call hexout 
8d7b			 
8d7b					ld a,(input_cur_onoff) 
8d7b					ld hl, LFSRSeed+6 
8d7b					call hexout 
8d7b			 
8d7b					ld a,(input_cur_flash) 
8d7b					ld hl, LFSRSeed+8 
8d7b					call hexout 
8d7b			 
8d7b					ld a,(input_len) 
8d7b					ld hl, LFSRSeed+10 
8d7b					call hexout 
8d7b					ld hl, LFSRSeed+12 
8d7b			;		ld a, 0 
8d7b					ld (hl),0 
8d7b					ld a, display_row_4 
8d7b					ld de, LFSRSeed 
8d7b					call str_at_display 
8d7b				endif 
8d7b cd ce 8a				call update_display 
8d7e			 
8d7e					; TODO keyboard processing 
8d7e			 
8d7e			if BASE_CPM 
8d7e					call cin_wait 
8d7e			else 
8d7e cd 86 e3				call cin    ; _wait 
8d81			endif 
8d81			;		cp 0 
8d81 b7					or a 
8d82 ca 27 8d				jp z, .inmain 
8d85			 
8d85 fe 0b				cp KEY_LEFT    ; cursor left 
8d87 ca 3a 8e				jp z, input_left 
8d8a				 
8d8a fe 0c				cp KEY_RIGHT      ; cursor right 
8d8c ca 41 8e				jp z, input_right 
8d8f			 
8d8f fe 0d				cp KEY_CR 
8d91 c8					ret z 
8d92			 
8d92 fe 08				cp KEY_BS 
8d94 ca ac 8e				jp z, input_delchar 
8d97			 
8d97 fe 06				cp KEY_NEXTWORD 
8d99 ca c0 8d				jp z, input_nxtword 
8d9c			 
8d9c fe 07				cp KEY_PREVWORD 
8d9e ca e5 8d				jp z, input_prvword 
8da1			 
8da1 fe 0e				cp KEY_HOME    ; jump to start of line 
8da3 20 08				jr nz, .ikh 
8da5 3e 00				ld a, 0 
8da7 32 4c ee				ld (input_cursor), a 
8daa ca 27 8d				jp z, .inmain 
8dad			.ikh: 
8dad			 
8dad fe 0f				cp KEY_END     ; jump to end of line 
8daf 20 09				jr nz, .ike 
8db1 3a 51 ee				ld a, (input_len) 
8db4 32 4c ee				ld (input_cursor),a 
8db7 ca 27 8d				jp z, .inmain 
8dba			.ike: 
8dba fe 05			        cp KEY_UP      ; recall last command 
8dbc c8					ret z 
8dbd			;jr nz, .irec 
8dbd			; TODO next word 
8dbd			; TODO prev word 
8dbd			;  
8dbd			; 
8dbd			;	ld hl, scratch 
8dbd			;	ld de, os_last_cmd 
8dbd			;	call strcpy 
8dbd			;		jp  .inmain 
8dbd			.irec: 
8dbd			;		jr .instr1 
8dbd			 
8dbd			 
8dbd			 
8dbd					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
8dbd			 
8dbd			; TODO return if any special keys are given 
8dbd			;		ld l, a 
8dbd			;		ld a, 28 ; KEY_F12   ; 27 
8dbd			;		sub l 
8dbd			;		ret m 
8dbd			;		ld a, l 
8dbd					; if no special key then insert as a char 
8dbd			 
8dbd c3 81 8e				jp input_inschr 
8dc0			 
8dc0				 
8dc0			input_nxtword: 
8dc0				; jump to start next word after the cursor 
8dc0			 
8dc0			.insknwn:	 
8dc0 cd 77 8e				call input_curptr	 
8dc3 7e					ld a,(hl)	 
8dc4			;		cp 0 
8dc4 b7					or a 
8dc5 ca 27 8d				jp z, .inmain    ; end of string 
8dc8			 
8dc8			; if we are on a word, then move off of it 
8dc8			 
8dc8 fe 20				cp ' ' 
8dca 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
8dcc 21 4c ee				ld hl, input_cursor 
8dcf 34					inc (hl) 
8dd0 18 ee				jr .insknwn 
8dd2			 
8dd2			.inspace: 
8dd2			 
8dd2 cd 77 8e				call input_curptr	 
8dd5 7e					ld a,(hl)	 
8dd6			;		cp 0 
8dd6 b7					or a 
8dd7 ca 27 8d				jp z, .inmain    ; end of string 
8dda			 
8dda			; if we are on a word, then move off of it 
8dda			 
8dda fe 20				cp ' ' 
8ddc c2 27 8d				jp nz, .inmain     ; we are on non space so at next word 
8ddf 21 4c ee				ld hl, input_cursor 
8de2 34					inc (hl) 
8de3 18 ed				jr .inspace 
8de5			 
8de5			 
8de5			 
8de5			 
8de5			input_prvword: 
8de5				; jump to the start of previous word before the cursor 
8de5			 
8de5			; where are we to start with currently? 
8de5			 
8de5 cd 77 8e				call input_curptr	 
8de8 7e					ld a, (hl) 
8de9 fe 20				cp ' ' 
8deb 28 1c				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
8ded			 
8ded			 
8ded			 
8ded			.inskpwn:	 
8ded 3a 4c ee				ld a,(input_cursor) 
8df0			;		cp 0 
8df0 b7					or a 
8df1 ca 27 8d				jp z, .inmain    ; start of string 
8df4			 
8df4			;if we are on a word, then move off of it 
8df4			 
8df4 cd 77 8e				call input_curptr	 
8df7 7e					ld a, (hl) 
8df8 fe 20				cp ' ' 
8dfa 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
8dfc					;jp z, .inmain    ; start of string 
8dfc 21 4c ee				ld hl, input_cursor 
8dff 35					dec (hl) 
8e00 18 eb				jr .inskpwn 
8e02			.iwstart: 
8e02 21 4c ee				ld hl, input_cursor 
8e05 34					inc (hl) 
8e06 c3 27 8d				jp .inmain 
8e09					 
8e09			 
8e09			.inspacep: 
8e09			 
8e09					;jp .inmain    ; start of string 
8e09			 
8e09			 
8e09			 
8e09 3a 4c ee				ld a,(input_cursor) 
8e0c			;		cp 0 
8e0c b7					or a 
8e0d ca 27 8d				jp z, .inmain    ; start of string 
8e10			 
8e10			; if we are on a word, then move off of it 
8e10			 
8e10 cd 77 8e				call input_curptr	 
8e13 7e					ld a, (hl) 
8e14 fe 20				cp ' ' 
8e16 c2 1f 8e				jp nz, .incharp     ; we are on non space so at end of prev word 
8e19 21 4c ee				ld hl, input_cursor 
8e1c 35					dec (hl) 
8e1d 18 ea				jr .inspacep 
8e1f			 
8e1f			 
8e1f			.incharp:	 
8e1f					; eat the word to get to the start 
8e1f 3a 4c ee				ld a,(input_cursor) 
8e22			;		cp 0 
8e22 b7					or a 
8e23 ca 27 8d				jp z, .inmain    ; start of string 
8e26			 
8e26			; if we are on a word, then move off of it 
8e26			 
8e26 cd 77 8e				call input_curptr	 
8e29 7e					ld a, (hl) 
8e2a fe 20				cp ' ' 
8e2c 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
8e2e 21 4c ee				ld hl, input_cursor 
8e31 35					dec (hl) 
8e32 18 eb				jr .incharp 
8e34			.ipwordst: 
8e34					; at space before the prev word so reposition over it 
8e34 21 4c ee				ld hl, input_cursor 
8e37 34					inc (hl) 
8e38 18 b3				jr .inskpwn 
8e3a					 
8e3a			 
8e3a			 
8e3a			input_left: 
8e3a				; move cursor left 
8e3a 21 4c ee			ld hl, input_cursor 
8e3d 35				dec (hl) 
8e3e			;	cp 0 
8e3e			;	jp z, .inmain    ; ignore left as at the start of the string 
8e3e c3 27 8d			jp .inmain 
8e41			 
8e41			input_right: 
8e41				; move cursor right 
8e41				 
8e41				;ld a, (input_size) 
8e41				;ld b, a 
8e41 21 4c ee			ld hl, input_cursor 
8e44 34				inc (hl) 
8e45				;dec b 
8e45				;cp 0 
8e45				;jp z, .inmain   ; ignore as at end of the string buffer 
8e45				;ld a, b 
8e45				;inc a 
8e45				;ld (input_cursor), a 
8e45 c3 27 8d			jp .inmain 
8e48			 
8e48			 
8e48			 
8e48			input_disp_ref: 
8e48				; display the text from start of buffer (ie full refresh) 
8e48 3a 5b ee			ld a, (input_at_pos) 
8e4b 2a 5e ee			ld hl,(input_start) 
8e4e eb				ex de, hl 
8e4f cd be 8a			call str_at_display  
8e52 c9				ret 
8e53			input_disp_oncur: 
8e53				; display the text from cursor position to end of buffer 
8e53				; TODO position start of string at cursor position on screen 
8e53				; TODO draw from that point on 
8e53 3a 4c ee			ld a, (input_cursor) 
8e56 47				ld b, a 
8e57 3a 5b ee			ld a, (input_at_pos) 
8e5a 80				add b 
8e5b 48				ld c, b     ; save a 
8e5c 78				ld a, b     ; inc string start for cursor 
8e5d 2a 5e ee			ld hl,(input_start) 
8e60 cd d6 8c			call addatohl 
8e63 eb				ex de, hl 
8e64 79				ld a, c 
8e65 cd be 8a			call str_at_display  
8e68 c9				ret 
8e69			 
8e69			input_nxtw: 
8e69				; Find next word 
8e69 c9				ret 
8e6a			 
8e6a			input_prvw: 
8e6a				; Find previous word 
8e6a c9				ret 
8e6b			 
8e6b			input_lenrem:   
8e6b				; Calculate the length of string remaining from current cursor 
8e6b				; position to end of buffer (exc null term) 
8e6b				 
8e6b 3a 4c ee			ld a, (input_cursor) 
8e6e 4f				ld c, a 
8e6f 3a 5d ee			ld a, (input_size) 
8e72 91				sub c 
8e73 06 00			ld b, 0 
8e75 0d				dec c 
8e76 c9				ret	 
8e77			 
8e77			input_curptr: 
8e77				; calc address of the character under the cursor 
8e77				 
8e77 2a 5e ee			ld hl, (input_start) 
8e7a 3a 4c ee			ld a, (input_cursor) 
8e7d cd d6 8c			call addatohl 
8e80 c9				ret 
8e81			 
8e81			input_inschr: 
8e81				; Insert char at cursor position 
8e81 f5				push af   ; save char 
8e82				;call input_lenrem    ; get bc length of remaining string 
8e82			 
8e82				 
8e82 cd 77 8e			call input_curptr 
8e85			;	ld hl, (input_start) 
8e85			;	ld a, (input_cursor) 
8e85			;	call addatohl 
8e85				;push hl   ; save to come back to 
8e85			 
8e85				; shift everything up one to end of buffer 
8e85			 
8e85				;push hl 
8e85				;dec de 
8e85				;inc de 
8e85			;	ldir 
8e85				 
8e85				;pop hl 
8e85			 
8e85				; are we adding to the end of line? 
8e85			 
8e85 3a 4c ee			ld a, (input_cursor) 
8e88 47				ld b, a 
8e89 3a 51 ee			ld a, (input_len) 
8e8c b8				cp b 
8e8d 20 08			jr nz, .insmid   ; no, insert in middle of text 
8e8f			 
8e8f				; tack on the end of the line 
8e8f f1				pop af 
8e90 77				ld (hl), a   ; save new char 
8e91 23				inc hl 
8e92			;	ld a, 0 
8e92 36 00			ld (hl), 0 
8e94 c3 41 8e			jp input_right 
8e97				 
8e97			.insmid: 
8e97				; hl has insertion point so move everything up one to allow for insertion 
8e97				;call input_shiftright 
8e97 f1				pop af 
8e98			 
8e98			.shufinsmid: 
8e98 47				ld b, a     ; b contains new char, c prev char at this position  
8e99 7e				ld a, (hl) 
8e9a			 
8e9a			;	cp 0    ; at end of string need to then dump new char and add term 
8e9a b7				or a 
8e9b 28 07			jr z, .endinsmid 
8e9d 4f				ld c, a 
8e9e 78				ld a, b 
8e9f 77				ld (hl), a 
8ea0 23				inc hl 
8ea1 79				ld a, c 
8ea2 18 f4			jr .shufinsmid 
8ea4				 
8ea4			 
8ea4			 
8ea4			 
8ea4			.endinsmid: 
8ea4 78				ld a, b 
8ea5 77				ld (hl), a 
8ea6 23				inc hl 
8ea7			;	ld a, 0 
8ea7 36 00			ld (hl), 0 
8ea9			 
8ea9			 
8ea9			;	ld (hl), a   ; save new char 
8ea9			 
8ea9 c3 41 8e			jp input_right 
8eac			 
8eac			;input_shiftright: 
8eac			;	; shift text right at cursor, hl has shift start 
8eac			;	push hl 
8eac			;	push de 
8eac			;	push bc 
8eac			; 
8eac			; 
8eac			;	; move to end of string past zero term 
8eac			;	ld hl,(input_start) 
8eac			;	ld a, (input_len) 
8eac			;	call addatohl 
8eac			;	inc hl 
8eac			;;	inc hl 
8eac			;;	inc hl 
8eac			;	ld a, 0 
8eac			;	ld (hl), a 
8eac			;;	dec hl 
8eac			;	 
8eac			;;	ld (hl), a 
8eac			;;	dec hl 
8eac			; 
8eac			;	push hl 
8eac			;	pop de 
8eac			;	inc de 
8eac			;	 
8eac			; 
8eac			;;	ld hl,(input_start) 
8eac			;;	ld a, (input_cursor) 
8eac			;;	call addatohl 
8eac			; 
8eac			; 
8eac			;	; calc how many bytes from cursor pos to end of string we need to shift 
8eac			;	call input_lenrem    ; get bc length of remaining string 
8eac			;	;ld a, (input_cursor) 
8eac			;	;ld c, a 
8eac			;	ld a, (input_len) 
8eac			;	cp 2 
8eac			;	jr z, .iskipzero	 
8eac			;	;sub c 
8eac			;	;inc a 
8eac			;	;ld c, a 
8eac			;	;ld b, 0 
8eac			;	inc c 
8eac			;	inc c 
8eac			;	; move data 
8eac			;	lddr 
8eac			;.iskipzero: 
8eac			; 
8eac			;	pop bc 
8eac			;	pop de 
8eac			;	pop hl 
8eac			;	ret	 
8eac			 
8eac			input_delchar: 
8eac				; Delete char at cursor position 
8eac cd 6b 8e			call input_lenrem    ; get bc length of remaining string 
8eaf 2a 5e ee			ld hl, (input_start) 
8eb2 3a 4c ee			ld a, (input_cursor) 
8eb5 cd d6 8c			call addatohl 
8eb8			 
8eb8 e5				push hl 
8eb9 d1				pop de 
8eba 1b				dec de 
8ebb			 
8ebb			.dl:	 
8ebb ed a0			ldi  
8ebd 7e				ld a, (hl) 
8ebe			;	cp 0 
8ebe b7				or a 
8ebf 28 02			jr z, .dldone 
8ec1 18 f8			jr .dl 
8ec3			.dldone: 
8ec3 ed a0			ldi 
8ec5			 
8ec5 c3 3a 8e			jp input_left 
8ec8			 
8ec8			 
8ec8			endif 
8ec8			 
8ec8			 
8ec8			 
8ec8			if EDIT_V1 
8ec8			input_str: 
8ec8			 
8ec8				    	ld (input_at_pos),a      ; save display position to start 
8ec8					add c 
8ec8					ld (input_at_cursor),a	; save draw pos of cursor 
8ec8					ld (input_start), hl     ; save ptr to buffer 
8ec8					ld a, c 
8ec8					call addatohl 
8ec8					ld (input_ptr), hl     ; save ptr to point under the cursor 
8ec8					ld a,d 
8ec8				        ld (input_size), a       ; save length of input area 
8ec8					ld a, c 
8ec8					ld (input_cursor),a      ; init cursor start position  
8ec8					ld a,e 
8ec8				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ec8					 
8ec8					 
8ec8			 
8ec8			;		ld a,(input_ptr) 
8ec8			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ec8			 
8ec8			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ec8					; init cursor shape if not set by the cin routines 
8ec8					ld hl, cursor_shape 
8ec8			if BASE_KEV 
8ec8					ld a, 255 
8ec8			else 
8ec8					ld a, '#' 
8ec8			endif 
8ec8					ld (hl), a 
8ec8					inc hl 
8ec8					ld a, 0 
8ec8					ld (hl), a 
8ec8			 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8					ld a, 1 
8ec8					ld (input_cur_onoff),a 
8ec8			 
8ec8			;	if DEBUG_INPUT 
8ec8			;		push af 
8ec8			;		ld a, 'I' 
8ec8			;		ld (debug_mark),a 
8ec8			;		pop af 
8ec8			;		CALLMONITOR 
8ec8			;	endif 
8ec8			.is1:		; main entry loop 
8ec8			 
8ec8			 
8ec8			 
8ec8					; pause 1ms 
8ec8			 
8ec8					ld a, 1 
8ec8					call aDelayInMS 
8ec8			 
8ec8					; dec flash counter 
8ec8					ld a, (input_cur_flash) 
8ec8					dec a 
8ec8					ld (input_cur_flash), a 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jr nz, .nochgstate 
8ec8			 
8ec8			 
8ec8					; change state 
8ec8					ld a,(input_cur_onoff) 
8ec8					neg 
8ec8					ld (input_cur_onoff),a 
8ec8			 
8ec8			 
8ec8					; reset on change of state 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8			 
8ec8			.nochgstate: 
8ec8					 
8ec8					 
8ec8			 
8ec8					; display cursor  
8ec8			 
8ec8			;		ld hl, (input_start) 
8ec8			;		ld a, (input_cursor) 
8ec8			;		call addatohl 
8ec8			 
8ec8					; get char under cursor and replace with cursor 
8ec8			ld hl, (input_ptr) 
8ec8			;		ld a, (hl) 
8ec8			;		ld (input_under_cursor),a 
8ec8			;		ld a, '_' 
8ec8			;		ld (hl), a 
8ec8			 
8ec8					; display string 
8ec8			 
8ec8					ld de, (input_start) 
8ec8					ld a, (input_at_pos) 
8ec8					call str_at_display 
8ec8			;	        call update_display 
8ec8			 
8ec8					; find place to put the cursor 
8ec8			;		add h 
8ec8			;		ld l, display_row_1 
8ec8			;		sub l 
8ec8			; (input_at_pos) 
8ec8					;ld c, a 
8ec8			;		ld a, (input_cursor) 
8ec8			;		ld l, (input_at_pos) 
8ec8			;		;ld b, h 
8ec8			;		add l 
8ec8			;		ld (input_at_cursor),a 
8ec8					;ld l,h 
8ec8			 
8ec8			;		ld h, 0 
8ec8			;		ld l,(input_at_pos) 
8ec8			;		ld a, (input_cursor) 
8ec8			;		call addatohl 
8ec8			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8ec8			;		call subafromhl 
8ec8			;		ld a,l 
8ec8			;		ld (input_at_cursor), a 
8ec8			 
8ec8				if DEBUG_INPUT 
8ec8					ld a, (hardware_diag) 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jr z, .skip_input_diag 
8ec8			 
8ec8					ld a,(input_at_pos) 
8ec8					ld hl, LFSRSeed 
8ec8					call hexout 
8ec8					ld a, (input_cursor) 
8ec8					ld hl, LFSRSeed+2 
8ec8					call hexout 
8ec8					ld a,(input_at_cursor) 
8ec8					ld hl, LFSRSeed+4 
8ec8					call hexout 
8ec8			 
8ec8					ld a,(input_cur_onoff) 
8ec8					ld hl, LFSRSeed+6 
8ec8					call hexout 
8ec8			 
8ec8					ld a,(input_cur_flash) 
8ec8					ld hl, LFSRSeed+8 
8ec8					call hexout 
8ec8			 
8ec8					ld a,(input_len) 
8ec8					ld hl, LFSRSeed+10 
8ec8					call hexout 
8ec8					ld hl, LFSRSeed+12 
8ec8					ld a, 0 
8ec8					ld (hl),a 
8ec8					ld a, display_row_4 
8ec8					ld de, LFSRSeed 
8ec8					call str_at_display 
8ec8					.skip_input_diag: 
8ec8				endif 
8ec8			 
8ec8					; decide on if we are showing the cursor this time round 
8ec8			 
8ec8					ld a, (input_cur_onoff) 
8ec8					cp 255 
8ec8					jr z, .skipcur 
8ec8			 
8ec8			 
8ec8					ld a,(input_at_cursor) 
8ec8					ld de, cursor_shape 
8ec8					call str_at_display 
8ec8			 
8ec8					; save length of current input string 
8ec8					ld hl, (input_start) 
8ec8					ld a, 0 
8ec8					call strlent 
8ec8					ld a,l 
8ec8					ld (input_len),a 
8ec8			 
8ec8			.skipcur: 
8ec8			 
8ec8				        call update_display 
8ec8					 
8ec8			 
8ec8			 
8ec8					; wait 
8ec8				 
8ec8					; TODO loop without wait to flash the cursor and char under cursor	 
8ec8					call cin    ; _wait 
8ec8			 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jp z, .is1 
8ec8			 
8ec8					; get ptr to char to input into 
8ec8			 
8ec8					ld c,a 
8ec8					ld hl, (input_start) 
8ec8					ld a, (input_cursor) 
8ec8					call addatohl 
8ec8					ld (input_ptr), hl 
8ec8					ld a,c 
8ec8			 
8ec8					; replace char under cursor 
8ec8			 
8ec8			;		ld hl, (input_ptr) 
8ec8			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8ec8			;		ld (hl), a 
8ec8			 
8ec8			;	if DEBUG_INPUT 
8ec8			;		push af 
8ec8			;		ld a, 'i' 
8ec8			;		ld (debug_mark),a 
8ec8			;		pop af 
8ec8			;		CALLMONITOR 
8ec8			;	endif 
8ec8					cp KEY_HOME 
8ec8					jr nz, .iske 
8ec8			 
8ec8					ld a, (input_at_pos) 
8ec8					ld (input_at_cursor),a 
8ec8					ld a, 0 
8ec8					ld (input_cursor), a 
8ec8					jp .is1 
8ec8					 
8ec8			.iske:		cp KEY_END 
8ec8					jr nz, .isknw 
8ec8					jp .is1 
8ec8			 
8ec8			.isknw:		cp KEY_NEXTWORD 
8ec8					jr nz, .iskpw 
8ec8			 
8ec8			.isknwm:	ld hl, (input_ptr) 
8ec8					ld a,(hl)	 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jp z, .is1    ; end of string 
8ec8					cp ' ' 
8ec8					jp z, .is1    ; end of word 
8ec8					inc hl 
8ec8					ld (input_ptr), hl 
8ec8					ld a, (input_at_cursor) 
8ec8					inc a 
8ec8					ld (input_at_cursor), a 
8ec8					jr .isknwm 
8ec8			 
8ec8			.iskpw:		cp KEY_PREVWORD 
8ec8					jr nz, .iskl 
8ec8			.iskpwm:	 
8ec8					ld hl, (input_ptr) 
8ec8					ld a,(hl)	 
8ec8			;		cp 0  
8ec8					or a 
8ec8					jp z, .is1    ; end of string 
8ec8					cp ' ' 
8ec8					jp z, .is1    ; end of word 
8ec8					dec hl 
8ec8					ld (input_ptr), hl 
8ec8					ld a, (input_at_cursor) 
8ec8					dec a 
8ec8					ld (input_at_cursor), a 
8ec8					jr .iskpwm 
8ec8			 
8ec8			 
8ec8			.iskl:		cp KEY_LEFT 
8ec8					jr nz, .isk1 
8ec8			 
8ec8					ld a, (input_cursor) 
8ec8			 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jp z, .is1 		; at start of line to ignore  
8ec8			 
8ec8					dec  a 		; TODO check underflow 
8ec8					ld (input_cursor), a 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					dec hl 
8ec8					ld (input_ptr), hl 
8ec8					 
8ec8					ld a, (input_at_cursor) 
8ec8					dec a 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8					ld a, 1		; show cursor moving 
8ec8					ld (input_cur_onoff),a 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8			 
8ec8					jp .is1 
8ec8			 
8ec8			.isk1:		cp KEY_RIGHT 
8ec8					jr nz, .isk2 
8ec8			 
8ec8					ld a,(input_len)		; TODO BUG why cant i load e direct? 
8ec8					ld e,a 
8ec8					ld a, (input_cursor) 
8ec8					cp e 
8ec8					jp z, .is1		; at the end of string so dont go right 
8ec8			 
8ec8					inc  a 		; TODO check overflow 
8ec8					ld (input_cursor), a 
8ec8			 
8ec8					ld a, (input_at_cursor) 
8ec8					inc a 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					inc hl 
8ec8					ld (input_ptr), hl 
8ec8			 
8ec8					ld a, 1		; show cursor moving 
8ec8					ld (input_cur_onoff),a 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8			 
8ec8					jp .is1 
8ec8			 
8ec8			.isk2:		cp KEY_UP 
8ec8			 
8ec8					jr nz, .isk3 
8ec8			 
8ec8					; swap last command with the current on 
8ec8			 
8ec8					; move cursor to start of string 
8ec8					ld hl, (input_start) 
8ec8					ld (input_ptr), hl 
8ec8			 
8ec8					ld a, (input_at_pos) 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8					ld a, 0 
8ec8					ld (input_cursor), a 
8ec8					 
8ec8					; swap input and last command buffers 
8ec8			 
8ec8					ld hl, os_cli_cmd 
8ec8					ld de, os_last_cmd 
8ec8					ld b, 255 
8ec8			.swap1:		ld a, (hl) 
8ec8					ld c,a 
8ec8					ld a, (de) 
8ec8					ld (hl), a 
8ec8					ld a,c 
8ec8					ld (de),a 
8ec8					inc hl 
8ec8					inc de 
8ec8					djnz .swap1 
8ec8			 
8ec8			 
8ec8			 
8ec8			 
8ec8			 
8ec8					jp .is1 
8ec8			 
8ec8			.isk3:		cp KEY_BS 
8ec8					jr nz, .isk4 
8ec8			 
8ec8					ld a, (input_cursor) 
8ec8			 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jp z, .is1 		; at start of line to ignore  
8ec8			 
8ec8					dec  a 		; TODO check underflow 
8ec8					ld (input_cursor), a 
8ec8			 
8ec8					; hl is source 
8ec8					; de needs to be source - 1 
8ec8			 
8ec8			;		ld a, 0 
8ec8			;		dec hl 
8ec8			;		ld (hl), a 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					dec hl 
8ec8					ld (input_ptr), hl 
8ec8			 
8ec8					; shift all data 
8ec8			 
8ec8					push hl 
8ec8					inc hl 
8ec8					pop de 
8ec8					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8ec8					ld c,a 
8ec8					ld b,0 
8ec8					ldir  
8ec8			 
8ec8			 
8ec8			 
8ec8			 
8ec8					ld a, (input_at_cursor) 
8ec8					dec a 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8			 
8ec8					ld a, 1		; show cursor moving 
8ec8					ld (input_cur_onoff),a 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8			 
8ec8					; remove char 
8ec8					ld a, (input_at_cursor) 
8ec8					inc a 
8ec8					ld de,.iblank 
8ec8					call str_at_display 
8ec8			 
8ec8					jp .is1 
8ec8			 
8ec8			.isk4:		cp KEY_CR 
8ec8					jr z, .endinput 
8ec8			 
8ec8					; else add the key press to the end 
8ec8			 
8ec8					ld c, a			; save key pressed 
8ec8			 
8ec8					ld a,(hl)		; get what is currently under char 
8ec8			 
8ec8			;		cp 0			; we are at the end of the string 
8ec8					or a 
8ec8					jr nz, .onchar 
8ec8					 
8ec8					; add a char to the end of the string 
8ec8				 
8ec8					ld (hl),c 
8ec8					inc hl 
8ec8			;		ld a,' ' 
8ec8			;		ld (hl),a 
8ec8			;		inc hl 
8ec8					ld a,0 
8ec8					ld (hl),a 
8ec8					dec hl 
8ec8			 
8ec8					ld a, (input_cursor) 
8ec8					inc a				; TODO check max string length and scroll  
8ec8					ld (input_cursor), a		; inc cursor pos 
8ec8							 
8ec8					ld a, (input_at_cursor) 
8ec8					inc a 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					inc hl 
8ec8					ld (input_ptr), hl 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					inc hl 
8ec8					ld (input_ptr), hl 
8ec8			;	if DEBUG_INPUT 
8ec8			;		push af 
8ec8			;		ld a, '+' 
8ec8			;		ld (debug_mark),a 
8ec8			;		pop af 
8ec8			;		CALLMONITOR 
8ec8			;	endif 
8ec8					ld a, 1		; show cursor moving 
8ec8					ld (input_cur_onoff),a 
8ec8					ld a, CUR_BLINK_RATE 
8ec8					ld (input_cur_flash), a 
8ec8					jp .is1 
8ec8					 
8ec8			 
8ec8			 
8ec8					; if on a char then insert 
8ec8			.onchar: 
8ec8			 
8ec8					; TODO over flow check: make sure insert does not blow out buffer 
8ec8			 
8ec8					; need to do some maths to use lddr 
8ec8			 
8ec8					push hl   ; save char pos 
8ec8					push bc 
8ec8			 
8ec8					ld hl, (input_start) 
8ec8					ld a, (input_len) 
8ec8					call addatohl  		; end of string 
8ec8					inc hl 
8ec8					inc hl		; past zero term 
8ec8					push hl 
8ec8					inc hl 
8ec8					push hl  
8ec8			 
8ec8								; start and end of lddr set, now how much to move? 
8ec8			 
8ec8							 
8ec8					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ec8					ld b,a 
8ec8					ld a,(input_len) 
8ec8					ld e,a 
8ec8					sub b 
8ec8					inc a		;?? 
8ec8					inc a		;?? 
8ec8					inc a		;?? 
8ec8			 
8ec8					ld b,0 
8ec8					ld c,a 
8ec8			 
8ec8				if DEBUG_INPUT 
8ec8					push af 
8ec8					ld a, 'i' 
8ec8					ld (debug_mark),a 
8ec8					pop af 
8ec8			;		CALLMONITOR 
8ec8				endif 
8ec8					pop de 
8ec8					pop hl 
8ec8				if DEBUG_INPUT 
8ec8					push af 
8ec8					ld a, 'I' 
8ec8					ld (debug_mark),a 
8ec8					pop af 
8ec8			;		CALLMONITOR 
8ec8				endif 
8ec8					lddr 
8ec8				 
8ec8			 
8ec8			 
8ec8					; TODO have a key for insert/overwrite mode???? 
8ec8					pop bc 
8ec8					pop hl 
8ec8					ld (hl), c		; otherwise overwrite current char 
8ec8					 
8ec8			 
8ec8			 
8ec8			 
8ec8					ld a, (input_cursor) 
8ec8					inc  a 		; TODO check overflow 
8ec8					ld (input_cursor), a 
8ec8			 
8ec8					ld a, (input_at_cursor) 
8ec8					inc a 
8ec8					ld (input_at_cursor), a 
8ec8			 
8ec8					jp .is1 
8ec8			 
8ec8			.endinput:	; TODO look for end of string 
8ec8			 
8ec8					; add trailing space for end of token 
8ec8			 
8ec8					ld hl, (input_start) 
8ec8					ld a,(input_len) 
8ec8					call addatohl 
8ec8					ld a, ' ' 
8ec8					ld (hl),a 
8ec8					; TODO eof of parse marker 
8ec8			 
8ec8					inc hl 
8ec8					ld a, 0 
8ec8					ld (hl),a 
8ec8			 
8ec8			 
8ec8					ret 
8ec8			 
8ec8			.iblank: db " ",0 
8ec8			 
8ec8			 
8ec8			input_str_prev:	ld (input_at_pos), a 
8ec8					ld (input_start), hl 
8ec8					ld a,1			; add cursor 
8ec8					ld (hl),a 
8ec8					inc hl 
8ec8					ld a,0 
8ec8					ld (hl),a 
8ec8					ld (input_ptr), hl 
8ec8					ld a,d 
8ec8					ld (input_size), a 
8ec8					ld a,0 
8ec8					ld (input_cursor),a 
8ec8			.instr1:	 
8ec8			 
8ec8					; TODO do block cursor 
8ec8					; TODO switch cursor depending on the modifer key 
8ec8			 
8ec8					; update cursor shape change on key hold 
8ec8			 
8ec8					ld hl, (input_ptr) 
8ec8					dec hl 
8ec8					ld a,(cursor_shape) 
8ec8					ld (hl), a 
8ec8			 
8ec8					; display entered text 
8ec8					ld a,(input_at_pos) 
8ec8			            	CALL fLCD_Pos       ;Position cursor to location in A 
8ec8			            	LD   de, (input_start) 
8ec8			            	CALL fLCD_Str       ;Display string pointed to by DE 
8ec8			 
8ec8					call cin 
8ec8			;		cp 0 
8ec8					or a 
8ec8					jr z, .instr1 
8ec8			 
8ec8					; proecess keyboard controls first 
8ec8			 
8ec8					ld hl,(input_ptr) 
8ec8			 
8ec8					cp KEY_CR	 ; pressing enter ends input 
8ec8					jr z, .instrcr 
8ec8			 
8ec8					cp KEY_BS 	; back space 
8ec8					jr nz, .instr2 
8ec8					; process back space 
8ec8			 
8ec8					; TODO stop back space if at start of string 
8ec8					dec hl 
8ec8					dec hl ; to over write cursor 
8ec8					ld a,(cursor_shape) 
8ec8					;ld a,0 
8ec8					ld (hl),a 
8ec8					inc hl 
8ec8					ld a," " 
8ec8					ld (hl),a 
8ec8					ld (input_ptr),hl 
8ec8					 
8ec8			 
8ec8					jr .instr1 
8ec8			 
8ec8			.instr2:	cp KEY_LEFT    ; cursor left 
8ec8					jr nz, .instr3 
8ec8					dec hl 
8ec8					ld (input_ptr),hl 
8ec8					jr .instr1 
8ec8				 
8ec8			.instr3:	cp KEY_RIGHT      ; cursor right 
8ec8					jr nz, .instr4 
8ec8					inc hl 
8ec8					ld (input_ptr),hl 
8ec8					jr .instr1 
8ec8			 
8ec8			.instr4:	cp KEY_HOME    ; jump to start of line 
8ec8					jr nz, .instr5 
8ec8					dec hl 
8ec8					ld (input_ptr),hl 
8ec8					jr .instr1 
8ec8			 
8ec8			.instr5:	cp KEY_END     ; jump to end of line 
8ec8					jr nz, .instr6 
8ec8					dec hl 
8ec8					ld (input_ptr),hl 
8ec8					jr .instr1 
8ec8			.instr6:        cp KEY_UP      ; recall last command 
8ec8					jr nz, .instrnew 
8ec8			 
8ec8				ld hl, scratch 
8ec8				ld de, os_last_cmd 
8ec8				call strcpy 
8ec8					jr .instr1 
8ec8			 
8ec8			 
8ec8			.instrnew:	; no special key pressed to see if we have room to store it 
8ec8			 
8ec8					; TODO do string size test 
8ec8			 
8ec8					dec hl ; to over write cursor 
8ec8					ld (hl),a 
8ec8					inc hl 
8ec8					ld a,(cursor_shape) 
8ec8					ld (hl),a 
8ec8					inc hl 
8ec8					ld a,0 
8ec8					ld (hl),a 
8ec8			 
8ec8					ld (input_ptr),hl 
8ec8					 
8ec8					jr .instr1 
8ec8			.instrcr:	dec hl		; remove cursor 
8ec8					ld a,' '	; TODO add a trailing space for safety 
8ec8					ld (hl),a 
8ec8					inc hl 
8ec8					ld a,0 
8ec8					ld (hl),a 
8ec8			 
8ec8			 
8ec8					; if at end of line scroll up    
8ec8					; TODO detecting only end of line 4 for scroll up  
8ec8			 
8ec8					;ld   
8ec8			 
8ec8					ret 
8ec8			 
8ec8			 
8ec8			endif 
8ec8			; strcpy hl = dest, de source 
8ec8			 
8ec8 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8ec9 b7			            OR   A              ;Null terminator? 
8eca c8			            RET  Z              ;Yes, so finished 
8ecb 1a					ld a,(de) 
8ecc 77					ld (hl),a 
8ecd 13			            INC  DE             ;Point to next character 
8ece 23					inc hl 
8ecf 18 f7		            JR   strcpy       ;Repeat 
8ed1 c9					ret 
8ed2			 
8ed2			 
8ed2			; TODO string_at  
8ed2			; pass string which starts with lcd offset address and then null term string 
8ed2			 
8ed2			; TODO string to dec 
8ed2			; TODO string to hex 
8ed2			; TODO byte to string hex 
8ed2			; TODO byte to string dec 
8ed2			 
8ed2			 
8ed2			 
8ed2			; from z80uartmonitor 
8ed2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ed2			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8ed2			; pass hl for where to put the text 
8ed2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ed2 c5			hexout:	PUSH BC 
8ed3 f5					PUSH AF 
8ed4 47					LD B, A 
8ed5					; Upper nybble 
8ed5 cb 3f				SRL A 
8ed7 cb 3f				SRL A 
8ed9 cb 3f				SRL A 
8edb cb 3f				SRL A 
8edd cd ed 8e				CALL tohex 
8ee0 77					ld (hl),a 
8ee1 23					inc hl	 
8ee2					 
8ee2					; Lower nybble 
8ee2 78					LD A, B 
8ee3 e6 0f				AND 0FH 
8ee5 cd ed 8e				CALL tohex 
8ee8 77					ld (hl),a 
8ee9 23					inc hl	 
8eea					 
8eea f1					POP AF 
8eeb c1					POP BC 
8eec c9					RET 
8eed					 
8eed			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8eed			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8eed			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8eed			tohex: 
8eed e5					PUSH HL 
8eee d5					PUSH DE 
8eef 16 00				LD D, 0 
8ef1 5f					LD E, A 
8ef2 21 fa 8e				LD HL, .DATA 
8ef5 19					ADD HL, DE 
8ef6 7e					LD A, (HL) 
8ef7 d1					POP DE 
8ef8 e1					POP HL 
8ef9 c9					RET 
8efa			 
8efa			.DATA: 
8efa 30					DEFB	30h	; 0 
8efb 31					DEFB	31h	; 1 
8efc 32					DEFB	32h	; 2 
8efd 33					DEFB	33h	; 3 
8efe 34					DEFB	34h	; 4 
8eff 35					DEFB	35h	; 5 
8f00 36					DEFB	36h	; 6 
8f01 37					DEFB	37h	; 7 
8f02 38					DEFB	38h	; 8 
8f03 39					DEFB	39h	; 9 
8f04 41					DEFB	41h	; A 
8f05 42					DEFB	42h	; B 
8f06 43					DEFB	43h	; C 
8f07 44					DEFB	44h	; D 
8f08 45					DEFB	45h	; E 
8f09 46					DEFB	46h	; F 
8f0a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f0a			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8f0a			;;    subtract $30, if result > 9 then subtract $7 more 
8f0a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8f0a			atohex: 
8f0a d6 30				SUB $30 
8f0c fe 0a				CP 10 
8f0e f8					RET M		; If result negative it was 0-9 so we're done 
8f0f d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8f11 c9					RET		 
8f12			 
8f12			 
8f12			 
8f12			 
8f12			; Get 2 ASCII characters as hex byte from pointer in hl 
8f12			 
8f12			BYTERD: 
8f12 16 00			LD	D,00h		;Set up 
8f14 cd 1c 8f			CALL	HEXCON		;Get byte and convert to hex 
8f17 87				ADD	A,A		;First nibble so 
8f18 87				ADD	A,A		;multiply by 16 
8f19 87				ADD	A,A		; 
8f1a 87				ADD	A,A		; 
8f1b 57				LD	D,A		;Save hi nibble in D 
8f1c			HEXCON: 
8f1c 7e				ld a, (hl)		;Get next chr 
8f1d 23				inc hl 
8f1e d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8f20 fe 0a			CP	00Ah		;Is it 0-9 ? 
8f22 38 02			JR	C,NALPHA	;If so miss next bit 
8f24 d6 07			SUB	007h		;Else convert alpha 
8f26			NALPHA: 
8f26 b2				OR	D		;Add hi nibble back 
8f27 c9				RET			; 
8f28			 
8f28			 
8f28			; 
8f28			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8f28			; Since the routines get_byte and therefore get_nibble are called, only valid 
8f28			; characters (0-9a-f) are accepted. 
8f28			; 
8f28			;get_word        push    af 
8f28			;                call    get_byte        ; Get the upper byte 
8f28			;                ld      h, a 
8f28			;                call    get_byte        ; Get the lower byte 
8f28			;                ld      l, a 
8f28			;                pop     af 
8f28			;                ret 
8f28			; 
8f28			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8f28			; the routine get_nibble is used only valid characters are accepted - the  
8f28			; input routine only accepts characters 0-9a-f. 
8f28			; 
8f28 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8f29 7e					ld a,(hl) 
8f2a 23					inc hl 
8f2b cd 50 8f		                call    nibble2val      ; Get upper nibble 
8f2e cb 07		                rlc     a 
8f30 cb 07		                rlc     a 
8f32 cb 07		                rlc     a 
8f34 cb 07		                rlc     a 
8f36 47			                ld      b, a            ; Save upper four bits 
8f37 7e					ld a,(hl) 
8f38 cd 50 8f		                call    nibble2val      ; Get lower nibble 
8f3b b0			                or      b               ; Combine both nibbles 
8f3c c1			                pop     bc              ; Restore B (and C) 
8f3d c9			                ret 
8f3e			; 
8f3e			; Get a hexadecimal digit from the serial line. This routine blocks until 
8f3e			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8f3e			; to the serial line interface. The lower 4 bits of A contain the value of  
8f3e			; that particular digit. 
8f3e			; 
8f3e			;get_nibble      ld a,(hl)           ; Read a character 
8f3e			;                call    to_upper        ; Convert to upper case 
8f3e			;                call    is_hex          ; Was it a hex digit? 
8f3e			;                jr      nc, get_nibble  ; No, get another character 
8f3e			 ;               call    nibble2val      ; Convert nibble to value 
8f3e			 ;               call    print_nibble 
8f3e			 ;               ret 
8f3e			; 
8f3e			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8f3e			; A valid hexadecimal digit is denoted by a set C flag. 
8f3e			; 
8f3e			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8f3e			;                ret     nc              ; Yes 
8f3e			;                cp      '0'             ; Less than '0'? 
8f3e			;                jr      nc, is_hex_1    ; No, continue 
8f3e			;                ccf                     ; Complement carry (i.e. clear it) 
8f3e			;                ret 
8f3e			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8f3e			;                ret     c               ; Yes 
8f3e			;                cp      'A'             ; Less than 'A'? 
8f3e			;                jr      nc, is_hex_2    ; No, continue 
8f3e			;                ccf                     ; Yes - clear carry and return 
8f3e			;                ret 
8f3e			;is_hex_2        scf                     ; Set carry 
8f3e			;                ret 
8f3e			; 
8f3e			; Convert a single character contained in A to upper case: 
8f3e			; 
8f3e fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8f40 d8			                ret     c 
8f41 fe 7b		                cp      'z' + 1         ; > 'z'? 
8f43 d0			                ret     nc              ; Nothing to do, either 
8f44 e6 5f		                and     $5f             ; Convert to upper case 
8f46 c9			                ret 
8f47			 
8f47			 
8f47			to_lower: 
8f47			 
8f47			   ; if char is in [A-Z] make it lower case 
8f47			 
8f47			   ; enter : a = char 
8f47			   ; exit  : a = lower case char 
8f47			   ; uses  : af 
8f47			 
8f47 fe 41		   cp 'A' 
8f49 d8			   ret c 
8f4a			    
8f4a fe 5b		   cp 'Z'+1 
8f4c d0			   ret nc 
8f4d			    
8f4d f6 20		   or $20 
8f4f c9			   ret 
8f50			 
8f50			; 
8f50			; Expects a hexadecimal digit (upper case!) in A and returns the 
8f50			; corresponding value in A. 
8f50			; 
8f50 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8f52 38 02		                jr      c, nibble2val_1 ; Yes 
8f54 d6 07		                sub     7               ; Adjust for A-F 
8f56 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8f58 e6 0f		                and     $f              ; Only return lower 4 bits 
8f5a c9			                ret 
8f5b			; 
8f5b			; Print_nibble prints a single hex nibble which is contained in the lower  
8f5b			; four bits of A: 
8f5b			; 
8f5b			;print_nibble    push    af              ; We won't destroy the contents of A 
8f5b			;                and     $f              ; Just in case... 
8f5b			;                add     a, '0'             ; If we have a digit we are done here. 
8f5b			;                cp      '9' + 1         ; Is the result > 9? 
8f5b			;                jr      c, print_nibble_1 
8f5b			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8f5b			;print_nibble_1  call    putc            ; Print the nibble and 
8f5b			;                pop     af              ; restore the original value of A 
8f5b			;                ret 
8f5b			;; 
8f5b			;; Send a CR/LF pair: 
8f5b			; 
8f5b			;crlf            push    af 
8f5b			;                ld      a, cr 
8f5b			;                call    putc 
8f5b			;                ld      a, lf 
8f5b			;                call    putc 
8f5b			;                pop     af 
8f5b			;                ret 
8f5b			; 
8f5b			; Print_word prints the four hex digits of a word to the serial line. The  
8f5b			; word is expected to be in HL. 
8f5b			; 
8f5b			;print_word      push    hl 
8f5b			;                push    af 
8f5b			;                ld      a, h 
8f5b			;                call    print_byte 
8f5b			;                ld      a, l 
8f5b			;                call    print_byte 
8f5b			;                pop     af 
8f5b			;                pop     hl 
8f5b			;                ret 
8f5b			; 
8f5b			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8f5b			; The byte to be printed is expected to be in A. 
8f5b			; 
8f5b			;print_byte      push    af              ; Save the contents of the registers 
8f5b			;                push    bc 
8f5b			;                ld      b, a 
8f5b			;                rrca 
8f5b			;                rrca 
8f5b			;                rrca 
8f5b			;                rrca 
8f5b			;                call    print_nibble    ; Print high nibble 
8f5b			;                ld      a, b 
8f5b			;                call    print_nibble    ; Print low nibble 
8f5b			;                pop     bc              ; Restore original register contents 
8f5b			;                pop     af 
8f5b			;                ret 
8f5b			 
8f5b			 
8f5b			 
8f5b			 
8f5b			 
8f5b			fourehexhl:  
8f5b 7e				ld a,(hl) 
8f5c cd 0a 8f			call atohex 
8f5f cb 3f				SRL A 
8f61 cb 3f				SRL A 
8f63 cb 3f				SRL A 
8f65 cb 3f				SRL A 
8f67 47				ld b, a 
8f68 23				inc hl 
8f69 7e				ld a,(hl) 
8f6a 23				inc hl 
8f6b cd 0a 8f			call atohex 
8f6e 80				add b 
8f6f 57				ld d,a 
8f70 7e				ld a,(hl) 
8f71 cd 0a 8f			call atohex 
8f74 cb 3f				SRL A 
8f76 cb 3f				SRL A 
8f78 cb 3f				SRL A 
8f7a cb 3f				SRL A 
8f7c 47				ld b, a 
8f7d 23				inc hl 
8f7e 7e				ld a,(hl) 
8f7f 23				inc hl 
8f80 cd 0a 8f			call atohex 
8f83 80				add b 
8f84 5f				ld e, a 
8f85 d5				push de 
8f86 e1				pop hl 
8f87 c9				ret 
8f88			 
8f88			; pass hl. returns z set if the byte at hl is a digit 
8f88			;isdigithl:  
8f88			;	push bc 
8f88			;	ld a,(hl) 
8f88			;	cp ':' 
8f88			;	jr nc, .isdf 		; > 
8f88			;	cp '0' 
8f88			;	jr c, .isdf		; < 
8f88			; 
8f88			;	; TODO find a better way to set z 
8f88			; 
8f88			;	ld b,a 
8f88			;	cp b 
8f88			;	pop bc 
8f88			;	ret 
8f88			; 
8f88			;.isdf:	; not digit so clear z 
8f88			; 
8f88			;	; TODO find a better way to unset z 
8f88			; 
8f88			;	ld b,a 
8f88			;	inc b 
8f88			;	cp b 
8f88			; 
8f88			;	pop bc 
8f88			;	ret 
8f88				 
8f88				 
8f88			 
8f88			 
8f88			; pass hl as the four byte address to load 
8f88			 
8f88			get_word_hl:  
8f88 e5				push hl 
8f89 cd 28 8f			call get_byte 
8f8c				 
8f8c 47				ld b, a 
8f8d			 
8f8d e1				pop hl 
8f8e 23				inc hl 
8f8f 23				inc hl 
8f90			 
8f90			; TODO not able to handle a-f  
8f90 7e				ld a,(hl) 
8f91			;	;cp ':' 
8f91			;	cp 'g' 
8f91			;	jr nc, .single_byte_hl 		; > 
8f91			;	cp 'G' 
8f91			;	jr nc, .single_byte_hl 		; > 
8f91			;	cp '0' 
8f91			;	jr c, .single_byte_hl		; < 
8f91			 
8f91				;call isdigithl 
8f91			;	cp 0 
8f91 b7				or a 
8f92 28 06			jr z, .single_byte_hl 
8f94			 
8f94			.getwhln:   ; hex word so get next byte 
8f94			 
8f94 cd 28 8f			call get_byte 
8f97 6f				ld l, a 
8f98 60				ld h,b 
8f99 c9				ret 
8f9a 68			.single_byte_hl:   ld l,b 
8f9b 26 00				ld h,0 
8f9d c9					ret 
8f9e			 
8f9e			 
8f9e			 
8f9e			 
8f9e 21 aa 96			ld hl,asc+1 
8fa1			;	ld a, (hl) 
8fa1			;	call nibble2val 
8fa1 cd 28 8f			call get_byte 
8fa4			 
8fa4			;	call fourehexhl 
8fa4 32 ec e2			ld (scratch+52),a 
8fa7				 
8fa7 21 ea e2			ld hl,scratch+50 
8faa 22 db e5			ld (os_cur_ptr),hl 
8fad			 
8fad c9				ret 
8fae			 
8fae			 
8fae			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8fae			 
8fae			; Decimal Unsigned Version 
8fae			 
8fae			;Number in a to decimal ASCII 
8fae			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8fae			;Example: display a=56 as "056" 
8fae			;input: a = number 
8fae			;Output: a=0,value of a in the screen 
8fae			;destroys af,bc (don't know about hl and de) 
8fae			DispAToASCII: 
8fae 0e 9c			ld	c,-100 
8fb0 cd ba 8f			call	.Na1 
8fb3 0e f6			ld	c,-10 
8fb5 cd ba 8f			call	.Na1 
8fb8 0e ff			ld	c,-1 
8fba 06 2f		.Na1:	ld	b,'0'-1 
8fbc 04			.Na2:	inc	b 
8fbd 81				add	a,c 
8fbe 38 fc			jr	c,.Na2 
8fc0 91				sub	c		;works as add 100/10/1 
8fc1 f5				push af		;safer than ld c,a 
8fc2 78				ld	a,b		;char is in b 
8fc3			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8fc3 f1				pop af		;safer than ld a,c 
8fc4 c9				ret 
8fc5			 
8fc5			; Decimal Signed Version 
8fc5			 
8fc5			; DispA 
8fc5			; -------------------------------------------------------------- 
8fc5			; Converts a signed integer value to a zero-terminated ASCII 
8fc5			; string representative of that value (using radix 10). 
8fc5			; -------------------------------------------------------------- 
8fc5			; INPUTS: 
8fc5			;     HL     Value to convert (two's complement integer). 
8fc5			;     DE     Base address of string destination. (pointer). 
8fc5			; -------------------------------------------------------------- 
8fc5			; OUTPUTS: 
8fc5			;     None 
8fc5			; -------------------------------------------------------------- 
8fc5			; REGISTERS/MEMORY DESTROYED 
8fc5			; AF HL 
8fc5			; -------------------------------------------------------------- 
8fc5			 
8fc5			;DispHLToASCII: 
8fc5			;   push    de 
8fc5			;   push    bc 
8fc5			; 
8fc5			;; Detect sign of HL. 
8fc5			;    bit    7, h 
8fc5			;    jr     z, ._DoConvert 
8fc5			; 
8fc5			;; HL is negative. Output '-' to string and negate HL. 
8fc5			;    ld     a, '-' 
8fc5			;    ld     (de), a 
8fc5			;    inc    de 
8fc5			; 
8fc5			;; Negate HL (using two's complement) 
8fc5			;    xor    a 
8fc5			;    sub    l 
8fc5			;    ld     l, a 
8fc5			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8fc5			;    sbc    a, h 
8fc5			;    ld     h, a 
8fc5			; 
8fc5			;; Convert HL to digit characters 
8fc5			;._DoConvert: 
8fc5			;    ld     b, 0     ; B will count character length of number 
8fc5			;-   ld     a, 10 
8fc5			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8fc5			;    push   af 
8fc5			;    inc    b 
8fc5			;    ld     a, h 
8fc5			;    or     l 
8fc5			;    jr     nz, - 
8fc5			; 
8fc5			;; Retrieve digits from stack 
8fc5			;-   pop    af 
8fc5			;    or     $30 
8fc5			;    ld     (de), a 
8fc5			;    inc    de 
8fc5			;    djnz   - 
8fc5			; 
8fc5			;; Terminate string with NULL 
8fc5			;    xor    a 
8fc5			;    ld     (de), a 
8fc5			; 
8fc5			;    pop    bc 
8fc5			;    pop    de 
8fc5			;    ret 
8fc5			 
8fc5			;Comments 
8fc5			; 
8fc5			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8fc5			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8fc5			;    Note that the output string will not be fixed-width. 
8fc5			; 
8fc5			;Example Usage 
8fc5			; 
8fc5			;    ld    hl, -1004 
8fc5			;    ld    de, OP1 
8fc5			;    call  DispA 
8fc5			;    ld    hl, OP1 
8fc5			;    syscall  PutS 
8fc5			 
8fc5			 
8fc5			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fc5			 
8fc5			 
8fc5			;Converts an ASCII string to an unsigned 16-bit integer 
8fc5			;Quits when it reaches a non-decimal digit 
8fc5			 
8fc5			string_to_uint16: 
8fc5			atoui_16: 
8fc5			;Input: 
8fc5			;     DE points to the string 
8fc5			;Outputs: 
8fc5			;     HL is the result 
8fc5			;     A is the 8-bit value of the number 
8fc5			;     DE points to the byte after the number 
8fc5			;Destroys: 
8fc5			;     BC 
8fc5			;       if the string is non-empty, BC is HL/10 
8fc5			;Size:  24 bytes 
8fc5			;Speed: 42+d(104+{0,9}) 
8fc5			;       d is the number of digits in the number 
8fc5			;       max is 640 cycles for a 5 digit number 
8fc5			;Assuming no leading zeros: 
8fc5			;1 digit:  146cc 
8fc5			;2 digit:  250cc 
8fc5			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8fc5			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8fc5			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8fc5			;avg: 544.81158447265625cc (544+13297/16384) 
8fc5			;=============================================================== 
8fc5 21 00 00		  ld hl,0 
8fc8			.u16a: 
8fc8 1a			  ld a,(de) 
8fc9 d6 30		  sub 30h 
8fcb fe 0a		  cp 10 
8fcd d0			  ret nc 
8fce 13			  inc de 
8fcf 44			  ld b,h 
8fd0 4d			  ld c,l 
8fd1 29			  add hl,hl 
8fd2 29			  add hl,hl 
8fd3 09			  add hl,bc 
8fd4 29			  add hl,hl 
8fd5 85			  add a,l 
8fd6 6f			  ld l,a 
8fd7 30 ef		  jr nc,.u16a 
8fd9 24			  inc h 
8fda c3 c8 8f		  jp .u16a 
8fdd			 
8fdd			 
8fdd			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8fdd			 
8fdd			;written by Zeda 
8fdd			;Converts a 16-bit unsigned integer to an ASCII string. 
8fdd			 
8fdd			uitoa_16: 
8fdd			;Input: 
8fdd			;   DE is the number to convert 
8fdd			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8fdd			;Output: 
8fdd			;   HL points to the null-terminated ASCII string 
8fdd			;      NOTE: This isn't necessarily the same as the input HL. 
8fdd d5			  push de 
8fde c5			  push bc 
8fdf f5			  push af 
8fe0 eb			  ex de,hl 
8fe1			 
8fe1 01 f0 d8		  ld bc,-10000 
8fe4 3e 2f		  ld a,'0'-1 
8fe6 3c			  inc a 
8fe7 09			  add hl,bc  
8fe8 38 fc		   jr c,$-2 
8fea 12			  ld (de),a 
8feb 13			  inc de 
8fec			 
8fec 01 e8 03		  ld bc,1000 
8fef 3e 3a		  ld a,'9'+1 
8ff1 3d			  dec a  
8ff2 09			  add hl,bc  
8ff3 30 fc		   jr nc,$-2 
8ff5 12			  ld (de),a 
8ff6 13			  inc de 
8ff7			 
8ff7 01 9c ff		  ld bc,-100 
8ffa 3e 2f		  ld a,'0'-1 
8ffc 3c			  inc a  
8ffd 09			  add hl,bc  
8ffe 38 fc		   jr c,$-2 
9000 12			  ld (de),a 
9001 13			  inc de 
9002			 
9002 7d			  ld a,l 
9003 26 3a		  ld h,'9'+1 
9005 25			  dec h  
9006 c6 0a		  add a,10  
9008 30 fb		   jr nc,$-3 
900a c6 30		  add a,'0' 
900c eb			  ex de,hl 
900d 72			  ld (hl),d 
900e 23			  inc hl 
900f 77			  ld (hl),a 
9010 23			  inc hl 
9011 36 00		  ld (hl),0 
9013			 
9013			;Now strip the leading zeros 
9013 0e fa		  ld c,-6 
9015 09			  add hl,bc 
9016 3e 30		  ld a,'0' 
9018 23			  inc hl  
9019 be			  cp (hl)  
901a 28 fc		  jr z,$-2 
901c			 
901c			;Make sure that the string is non-empty! 
901c 7e			  ld a,(hl) 
901d b7			  or a 
901e 20 01		  jr nz,.atoub 
9020 2b			  dec hl 
9021			.atoub: 
9021			 
9021 f1			  pop af 
9022 c1			  pop bc 
9023 d1			  pop de 
9024 c9			  ret 
9025			 
9025			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9025			 
9025			toUpper: 
9025			;A is the char. 
9025			;If A is a lowercase letter, this sets it to the matching uppercase 
9025			;18cc or 30cc or 41cc 
9025			;avg: 26.75cc 
9025 fe 61		  cp 'a' 
9027 d8			  ret c 
9028 fe 7b		  cp 'z'+1 
902a d0			  ret nc 
902b d6 20		  sub 'a'-'A' 
902d c9			  ret 
902e			 
902e			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
902e			 
902e			; String Length 
902e			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
902e			 
902e			; Get the length of the null-terminated string starting at $8000 hl 
902e			;    LD     HL, $8000 
902e			 
902e			strlenz: 
902e			 
902e af			    XOR    A               ; Zero is the value we are looking for. 
902f 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
9030 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
9031			                           ; 65, 536 bytes (the entire addressable memory space). 
9031 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
9033			 
9033			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
9033 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9034 6f			    LD     L, A             ; number of bytes 
9035 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9037 2b			    DEC    HL              ; Compensate for null. 
9038 c9				ret 
9039			 
9039			; Get the length of the A terminated string starting at $8000 hl 
9039			;    LD     HL, $8000 
9039			 
9039			strlent: 
9039			 
9039			                  ; A is the value we are looking for. 
9039 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
903b 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
903d			                           ; 65, 536 bytes (the entire addressable memory space). 
903d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
903f			 
903f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
903f 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
9041 2e 00		    LD     L, 0             ; number of bytes 
9043 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9045 2b			    DEC    HL              ; Compensate for null. 
9046 c9				ret 
9047			 
9047			 
9047			;Comparing Strings 
9047			 
9047			;IN    HL     Address of string1. 
9047			;      DE     Address of string2. 
9047			 
9047			; doc given but wrong??? 
9047			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9047			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9047			; tested 
9047			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9047			 
9047			strcmp_old: 
9047 e5			    PUSH   HL 
9048 d5			    PUSH   DE 
9049			 
9049 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
904a be			    CP     (HL)            ; (want to minimize work). 
904b 38 01		    JR     C, Str1IsBigger 
904d 7e			    LD     A, (HL) 
904e			 
904e			Str1IsBigger: 
904e 4f			    LD     C, A             ; Put length in BC 
904f 06 00		    LD     B, 0 
9051 13			    INC    DE              ; Increment pointers to meat of string. 
9052 23			    INC    HL 
9053			 
9053			CmpLoop: 
9053 1a			    LD     A, (DE)          ; Compare bytes. 
9054 ed a1		    CPI 
9056 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9058 13			    INC    DE              ; Update pointer. 
9059 ea 53 90		    JP     PE, CmpLoop 
905c			 
905c d1			    POP    DE 
905d e1			    POP    HL 
905e 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
905f be			    CP     (HL) 
9060 c9			    RET 
9061			 
9061			NoMatch: 
9061 2b			    DEC    HL 
9062 be			    CP     (HL)            ; Compare again to affect carry. 
9063 d1			    POP    DE 
9064 e1			    POP    HL 
9065 c9			    RET 
9066			 
9066			;; test strmp 
9066			; 
9066			;ld de, .str1 
9066			;ld hl, .str2 
9066			;call strcmp 
9066			;jr z, .z1 
9066			;;this 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "NZ1" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			;.z1: 
9066			; 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "ZZ1" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			; 
9066			;ld de, .str1 
9066			;ld hl, .str1 
9066			;call strcmp 
9066			;jr z, .z2 
9066			;;this 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "NZ2" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			;.z2: 
9066			; 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "ZZ2" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			; 
9066			;ld de, .str1 
9066			;ld hl, .str2 
9066			;call strcmp 
9066			;jr c, .c1 
9066			; 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "Nc1" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			;.c1: 
9066			;;this 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "cc1" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			; 
9066			;ld de, .str1 
9066			;ld hl, .str1 
9066			;call strcmp 
9066			;jr c, .c2 
9066			;;this 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "Nc2" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			;.c2: 
9066			; 
9066			;	if DEBUG_FORTH_WORDS 
9066			;		DMARK "cc2" 
9066			;		CALLMONITOR 
9066			;	endif 
9066			;	NEXTW 
9066			;.str1:   db "string1",0 
9066			;.str2:   db "string2",0 
9066			 
9066			; only care about direct match or not 
9066			; hl and de strings 
9066			; zero set if the same 
9066			 
9066			strcmp: 
9066 1a				ld a, (de) 
9067 be				cp (hl) 
9068 28 02			jr z, .ssame 
906a b7				or a 
906b c9				ret 
906c			 
906c			.ssame:  
906c			;	cp 0 
906c b7				or a 
906d c8				ret z 
906e			 
906e 23				inc hl 
906f 13				inc de 
9070 18 f4			jr strcmp 
9072				 
9072				 
9072			 
9072			;Copyright (c) 2014, Luke Maurits 
9072			;All rights reserved. 
9072			; 
9072			;Redistribution and use in source and binary forms, with or without 
9072			;modification, are permitted provided that the following conditions are met: 
9072			; 
9072			;* Redistributions of source code must retain the above copyright notice, this 
9072			;  list of conditions and the following disclaimer. 
9072			; 
9072			;* Redistributions in binary form must reproduce the above copyright notice, 
9072			;  this list of conditions and the following disclaimer in the documentation 
9072			;  and/or other materials provided with the distribution. 
9072			; 
9072			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
9072			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
9072			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
9072			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
9072			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
9072			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
9072			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
9072			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
9072			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
9072			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
9072			 
9072			; https://github.com/lmaurits/lm512/blob/master/string.z80 
9072			 
9072			StrictStrCmp: 
9072				; Load next chars of each string 
9072 1a				ld a, (de) 
9073 47				ld b, a 
9074 7e				ld a, (hl) 
9075				; Compare 
9075 b8				cp b 
9076				; Return non-zero if chars don't match 
9076 c0				ret nz 
9077				; Check for end of both strings 
9077 fe 00			cp "\0" 
9079				; Return if strings have ended 
9079 c8				ret z 
907a				; Otherwise, advance to next chars 
907a 23				inc hl 
907b 13				inc de 
907c 18 f4			jr StrictStrCmp 
907e			 
907e			;end 
907e			; eof 
907e			 
907e			 
907e			 
907e			 
907e			 
907e			 
# End of file firmware_strings.asm
907e			include "firmware_memory.asm"   ; malloc and free  
907e			 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e			.mallocsize: db "Wants malloc >256",0 
907e			.mallocasize: db "MALLOC gives >256",0 
907e			.malloczero: db "MALLOC gives zero",0 
907e			 
907e			malloc_guard_zerolen: 
907e				push hl 
907e				push de 
907e				push af 
907e			 
907e				ld de, 0 
907e			        call cmp16 
907e				jr nz, .lowalloz 
907e			 
907e				push hl 
907e				push de 
907e					ld hl, display_fb0 
907e					ld (display_fb_active), hl 
907e				call clear_display 
907e				ld a, 0 
907e				ld de, .malloczero 
907e				call str_at_display 
907e				call update_display 
907e				call delay1s 
907e				call delay1s 
907e				call bp_on 
907e			;	ld a, 0 
907e			;	ld (os_view_disable), a 
907e			 
907e				pop de 
907e				pop hl 
907e			 
907e				 
907e			 
907e				CALLMONITOR 
907e			.lowalloz: 
907e			 
907e			 
907e				pop af 
907e				pop de 
907e				pop hl 
907e			ret 
907e			 
907e			malloc_guard_entry: 
907e				push hl 
907e				push de 
907e				push af 
907e			 
907e			 	or a      ;clear carry flag 
907e				push hl 
907e				ld de, 255 
907e				sbc hl, de 
907e				jr c, .lowalloc 
907e			 
907e				push de 
907e					ld hl, display_fb0 
907e					ld (display_fb_active), hl 
907e				call clear_display 
907e				ld a, 0 
907e				ld de, .mallocsize 
907e				call str_at_display 
907e				call update_display 
907e				call delay1s 
907e				call delay1s 
907e			;	ld a, 0 
907e			;	ld (os_view_disable), a 
907e				call bp_on 
907e			 
907e				pop de 
907e				pop hl 
907e			 
907e				 
907e			 
907e				CALLMONITOR 
907e				jr .lowdone 
907e			.lowalloc: 
907e			 
907e			 
907e				pop hl 
907e			.lowdone:	pop af 
907e				pop de 
907e				pop hl 
907e			ret 
907e			 
907e			malloc_guard_exit: 
907e				push hl 
907e				push de 
907e				push af 
907e			 
907e			 	or a      ;clear carry flag 
907e				push hl 
907e				ld de, 255 
907e				sbc hl, de 
907e				jr c, .lowallocx 
907e			 
907e				push de 
907e					ld hl, display_fb0 
907e					ld (display_fb_active), hl 
907e				call clear_display 
907e				ld a, 0 
907e				ld de, .mallocasize 
907e				call str_at_display 
907e				call update_display 
907e				call delay1s 
907e				call delay1s 
907e			;	ld a, 0 
907e			;	ld (os_view_disable), a 
907e				call bp_on 
907e				pop de 
907e				pop hl 
907e			 
907e				CALLMONITOR 
907e				jr .lowdonex 
907e			.lowallocx: 
907e			 
907e				pop hl 
907e			.lowdonex:	pop af 
907e				pop de 
907e				pop hl 
907e			ret 
907e			endif 
907e			 
907e			if MALLOC_2 
907e			; Z80 Malloc and Free Functions 
907e			 
907e			; Malloc Function: 
907e			; Input: 
907e			;   HL: Size of block to allocate 
907e			; Output: 
907e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
907e			 
907e			malloc: 
907e				 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e			call malloc_guard_entry 
907e			endif 
907e			 
907e			 
907e			 
907e			 
907e					if DEBUG_FORTH_MALLOC 
907e						DMARK "mal" 
907e						CALLMONITOR 
907e					endif 
907e			    push af            ; Save AF register 
907e			    ld a, l            ; Load low byte of size into A 
907e			    or h               ; Check if size is zero 
907e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
907e			 
907e			    ; Allocate memory 
907e			    ld hl, (heap_start) ; Load start of heap into HL 
907e					if DEBUG_FORTH_MALLOC 
907e						DMARK "ma1" 
907e						CALLMONITOR 
907e					endif 
907e			    call malloc_internal ; Call internal malloc function 
907e			    pop af             ; Restore AF register 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e			call malloc_guard_exit 
907e			call malloc_guard_zerolen 
907e			endif 
907e			    ret                ; Return 
907e			 
907e			; Free Function: 
907e			; Input: 
907e			;   HL: Pointer to memory block to free 
907e			; Output: 
907e			;   None 
907e			 
907e			free: 
907e			    push af            ; Save AF register 
907e			    ld a, l            ; Load low byte of pointer into A 
907e			    or h               ; Check if pointer is NULL 
907e			    jp z, free_exit    ; If pointer is NULL, exit 
907e			 
907e			    ; Free memory 
907e			    ld hl, (heap_start) ; Load start of heap into HL 
907e			    call free_internal  ; Call internal free function 
907e			    pop af             ; Restore AF register 
907e			    ret                ; Return 
907e			 
907e			; Internal Malloc Function: 
907e			; Input: 
907e			;   HL: Size of block to allocate 
907e			; Output: 
907e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
907e			 
907e			malloc_internal: 
907e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
907e			    add hl, bc         ; Add management overhead to requested size 
907e			    ex de, hl          ; Save total size in DE, and keep it in HL 
907e					if DEBUG_FORTH_MALLOC 
907e						DMARK "ma2" 
907e						CALLMONITOR 
907e					endif 
907e			 
907e			    ; Search for free memory block 
907e			    ld de, (heap_end)  ; Load end of heap into DE 
907e			    ld bc, 0           ; Initialize counter 
907e			 
907e					if DEBUG_FORTH_MALLOC 
907e						DMARK "ma2" 
907e						CALLMONITOR 
907e					endif 
907e			malloc_search_loop: 
907e			    ; Check if current block is free 
907e			    ld a, (hl)         ; Load current block's status (free or used) 
907e			;    cp 0               ; Compare with zero (free) 
907e				or a 
907e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
907e			 
907e			    ; Check if current block is large enough 
907e			    ld a, (hl+1)       ; Load high byte of block size 
907e			    cp l               ; Compare with low byte of requested size 
907e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
907e			 
907e			    ld a, (hl+2)       ; Load low byte of block size 
907e			    cp h               ; Compare with high byte of requested size 
907e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
907e			 
907e			    ; Mark block as used 
907e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
907e			 
907e			    ; Calculate remaining space in block 
907e			    ld bc, 0           ; Clear BC 
907e			    add hl, bc         ; Increment HL to point to start of data block 
907e			    add hl, de         ; HL = HL + DE (total size) 
907e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
907e			    add hl, bc         ; Add management overhead to start of data block 
907e			 
907e			    ; Save pointer to allocated block in HL 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e						DMARK "ma5" 
907e			call malloc_guard_exit 
907e			call malloc_guard_zerolen 
907e			endif 
907e			    ret 
907e			 
907e			malloc_skip_block_check: 
907e			    ; Move to the next block 
907e			    ld bc, 3           ; Size of management overhead 
907e			    add hl, bc         ; Move to the next block 
907e			    inc de             ; Increment counter 
907e			 
907e			    ; Check if we have reached the end of heap 
907e			    ld a, e            ; Load low byte of heap end address 
907e			    cp (hl)            ; Compare with low byte of current address 
907e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
907e			    ld a, d            ; Load high byte of heap end address 
907e			;    cp 0               ; Check if it's zero (end of memory) 
907e				or a 
907e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
907e			 
907e			    ; If we reached here, allocation failed 
907e			    xor a              ; Set result to NULL 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e						DMARK "ma6" 
907e			call malloc_guard_exit 
907e			call malloc_guard_zerolen 
907e			endif 
907e			    ret 
907e			malloc_exit: 
907e			if DEBUG_FORTH_MALLOC_HIGH 
907e						DMARK "ma7" 
907e			call malloc_guard_exit 
907e			call malloc_guard_zerolen 
907e			endif 
907e			    ret 
907e			 
907e			; Internal Free Function: 
907e			; Input: 
907e			;   HL: Pointer to memory block to free 
907e			; Output: 
907e			;   None 
907e			 
907e			free_internal: 
907e			    ld de, (heap_start) ; Load start of heap into DE 
907e			    ld bc, 0            ; Initialize counter 
907e			 
907e			free_search_loop: 
907e			    ; Check if current block contains the pointer 
907e			    ld a, l             ; Load low byte of pointer 
907e			    cp (hl+1)           ; Compare with high byte of current block's address 
907e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
907e			    ld a, h             ; Load high byte of pointer 
907e			    cp (hl+2)           ; Compare with low byte of current block's address 
907e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
907e			 
907e			    ; Mark block as free 
907e			    ld (hl), 0          ; Set status byte to indicate free block 
907e			    ret                 ; Return 
907e			 
907e			free_skip_block_check: 
907e			    ; Move to the next block 
907e			    ld bc, 3            ; Size of management overhead 
907e			    add hl, bc          ; Move to the next block 
907e			    inc de              ; Increment counter 
907e			 
907e			    ; Check if we have reached the end of heap 
907e			    ld a, e             ; Load low byte of heap end address 
907e			    cp (hl)             ; Compare with low byte of current address 
907e			    jr nz, free_search_loop  ; If not equal, continue searching 
907e			    ld a, d             ; Load high byte of heap end address 
907e			;    cp 0                ; Check if it's zero (end of memory) 
907e				or a 
907e			    jr nz, free_search_loop  ; If not zero, continue searching 
907e			 
907e			    ; If we reached here, pointer is not found in heap 
907e			    ret 
907e			 
907e			free_exit: 
907e			    ret                 ; Return 
907e			 
907e			; Define heap start and end addresses 
907e			;heap_start:    .dw 0xC000   ; Start of heap 
907e			;heap_end:      .dw 0xE000   ; End of heap 
907e			 
907e			endif 
907e			 
907e			 
907e			if MALLOC_1 
907e			 
907e			 
907e			 
907e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
907e			 
907e			;moved to firmware.asm 
907e			;heap_start        .equ  0x9000      ; Starting address of heap 
907e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
907e			 
907e			;      .org 0 
907e			;      jp    main 
907e			 
907e			 
907e			;      .org  0x100 
907e			;main: 
907e			;      ld    HL, 0x8100 
907e			;      ld    SP, HL 
907e			; 
907e			;      call  heap_init 
907e			; 
907e			;      ; Make some allocations 
907e			;      ld    HL, 12 
907e			;      call  malloc            ; Allocates 0x9004 
907e			; 
907e			;      ld    HL, 12 
907e			;      call  malloc            ; Allocates 0x9014 
907e			; 
907e			;      ld    HL, 12 
907e			;      call  malloc            ; Allocates 0x9024 
907e			; 
907e			;      ; Free some allocations 
907e			;      ld    HL, 0x9014 
907e			;      call  free 
907e			; 
907e			;      ld    HL, 0x9004 
907e			;      call  free 
907e			; 
907e			;      ld    HL, 0x9024 
907e			;      call  free 
907e			; 
907e			; 
907e			;      halt 
907e			 
907e			 
907e			;------------------------------------------------------------------------------ 
907e			;     heap_init                                                               : 
907e			;                                                                             : 
907e			; Description                                                                 : 
907e			;     Initialise the heap and make it ready for malloc and free operations.   : 
907e			;                                                                             : 
907e			;     The heap is maintained as a linked list, starting with an initial       : 
907e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
907e			;     the first free block in the heap. Each block then points to the next    : 
907e			;     free block within the heap, and the free list ends at the first block   : 
907e			;     with a null pointer to the next free block.                             : 
907e			;                                                                             : 
907e			; Parameters                                                                  : 
907e			;     Inputs are compile-time only. Two defines which specify the starting    : 
907e			;     address of the heap and its size are required, along with a memory      : 
907e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
907e			;     principally stores a pointer to the first free block in the heap.       : 
907e			;                                                                             : 
907e			; Returns                                                                     : 
907e			;     Nothing                                                                 : 
907e			;------------------------------------------------------------------------------ 
907e			heap_init: 
907e e5			      push  HL 
907f			 
907f			      ; Initialise free list struct 
907f 21 a4 e3		      ld    HL, heap_start 
9082 22 9f e3		      ld    (free_list), HL 
9085 21 00 00		      ld    HL, 0 
9088 22 a1 e3		      ld    (free_list+2), HL 
908b			 
908b			      ; Insert first free block at bottom of heap, consumes entire heap 
908b 21 8f e2		      ld    HL, heap_start+heap_size-4 
908e 22 a4 e3		      ld    (heap_start), HL        ; Next block (end of free list) 
9091 21 eb fe		      ld    HL, heap_size-4 
9094 22 a6 e3		      ld    (heap_start+2), HL      ; Block size 
9097			 
9097			      ; Insert end of free list block at top of heap - two null words will 
9097			      ; terminate the free list 
9097 21 00 00		      ld    HL, 0 
909a 22 91 e2		      ld    (heap_start+heap_size-2), HL 
909d 22 8f e2		      ld    (heap_start+heap_size-4), HL 
90a0			 
90a0 e1			      pop   HL 
90a1			 
90a1 c9			      ret 
90a2			 
90a2			 
90a2			;------------------------------------------------------------------------------ 
90a2			;     malloc                                                                  : 
90a2			;                                                                             : 
90a2			; Description                                                                 : 
90a2			;     Allocates the wanted space from the heap and returns the address of the : 
90a2			;     first useable byte of the allocation.                                   : 
90a2			;                                                                             : 
90a2			;     Allocations can happen in one of two ways:                              : 
90a2			;                                                                             : 
90a2			;     1. A free block may be found which is the exact size wanted. In this    : 
90a2			;        case the block is removed from the free list and retuedn to the      : 
90a2			;        caller.                                                              : 
90a2			;     2. A free block may be found which is larger than the size wanted. In   : 
90a2			;        this case, the larger block is split into two. The first portion of  : 
90a2			;        this block will become the requested space by the malloc call and    : 
90a2			;        is returned to the caller. The second portion becomes a new free     : 
90a2			;        block, and the free list is adjusted to maintain continuity via this : 
90a2			;        newly created block.                                                 : 
90a2			;                                                                             : 
90a2			;     malloc does not set any initial value in the allocated space, the       : 
90a2			;     caller is required to do this as required.                              : 
90a2			;                                                                             : 
90a2			;     This implementation of malloc uses the stack exclusively, and is        : 
90a2			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
90a2			;     advisable to disable interrupts before calling malloc, and recommended  : 
90a2			;     to avoid the use of malloc inside ISRs in general.                      : 
90a2			;                                                                             : 
90a2			;     NOTE: heap_init must be called before malloc and free can be used.      : 
90a2			;                                                                             : 
90a2			; Parameters                                                                  : 
90a2			;     HL  Number of bytes wanted                                              : 
90a2			;                                                                             : 
90a2			; Returns                                                                     : 
90a2			;     HL  Address of the first useable byte of the allocation                 : 
90a2			;                                                                             : 
90a2			; Flags                                                                       : 
90a2			;     Z   Set if the allocation did not succeed, clear otherwise              : 
90a2			;                                                                             : 
90a2			; Stack frame                                                                 : 
90a2			;       |             |                                                       : 
90a2			;       +-------------+                                                       : 
90a2			;       |     BC      |                                                       : 
90a2			;       +-------------+                                                       : 
90a2			;       |     DE      |                                                       : 
90a2			;       +-------------+                                                       : 
90a2			;       |     IX      |                                                       : 
90a2			;       +-------------+                                                       : 
90a2			;       |  prev_free  |                                                       : 
90a2			;   +4  +-------------+                                                       : 
90a2			;       |  this_free  |                                                       : 
90a2			;   +2  +-------------+                                                       : 
90a2			;       |  next_free  |                                                       : 
90a2			;   +0  +-------------+                                                       : 
90a2			;       |             |                                                       : 
90a2			;                                                                             : 
90a2			;------------------------------------------------------------------------------ 
90a2			 
90a2			 
90a2			;malloc: 
90a2			; 
90a2			;	SAVESP ON 1 
90a2			; 
90a2			;	call malloc_code 
90a2			; 
90a2			;	CHECKSP ON 1 
90a2			;	ret 
90a2			 
90a2			 
90a2			malloc: 
90a2 c5			      push  BC 
90a3 d5			      push  DE 
90a4 dd e5		      push  IX 
90a6			if DEBUG_FORTH_MALLOC_HIGH 
90a6			call malloc_guard_entry 
90a6			endif 
90a6			 
90a6					if DEBUG_FORTH_MALLOC 
90a6						DMARK "mal" 
90a6						CALLMONITOR 
90a6					endif 
90a6 7c			      ld    A, H                    ; Exit if no space requested 
90a7 b5			      or    L 
90a8 ca 67 91		      jp    Z, malloc_early_exit 
90ab			 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			; 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			;inc hl 
90ab			 
90ab			 
90ab			 
90ab			 
90ab					if DEBUG_FORTH_MALLOC 
90ab						DMARK "maA" 
90ab						CALLMONITOR 
90ab					endif 
90ab			      ; Set up stack frame 
90ab eb			      ex    DE, HL 
90ac 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
90af 39			      add   HL, SP 
90b0 f9			      ld    SP, HL 
90b1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
90b5 dd 39		      add   IX, SP 
90b7			 
90b7			      ; Setup initial state 
90b7 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
90ba 19			      add   HL, DE 
90bb			 
90bb 44			      ld    B, H                    ; Move want to BC 
90bc 4d			      ld    C, L 
90bd			 
90bd 21 9f e3		      ld    HL, free_list           ; Store prev_free ptr to stack 
90c0 dd 75 04		      ld    (IX+4), L 
90c3 dd 74 05		      ld    (IX+5), H 
90c6			 
90c6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
90c7 23			      inc   HL 
90c8 56			      ld    D, (HL) 
90c9 dd 73 02		      ld    (IX+2), E 
90cc dd 72 03		      ld    (IX+3), D 
90cf eb			      ex    DE, HL                  ; this_free ptr into HL 
90d0			 
90d0					if DEBUG_FORTH_MALLOC 
90d0						DMARK "maB" 
90d0						CALLMONITOR 
90d0					endif 
90d0			      ; Loop through free block list to find some space 
90d0			malloc_find_space: 
90d0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
90d1 23			      inc   HL 
90d2 56			      ld    D, (HL) 
90d3			 
90d3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
90d4 b3			      or    E 
90d5 ca 61 91		      jp    Z, malloc_no_space 
90d8			 
90d8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
90db dd 72 01		      ld    (IX+1), D 
90de			 
90de			      ; Does this block have enough space to make the allocation? 
90de 23			      inc   HL                      ; Load free block size into DE 
90df 5e			      ld    E, (HL) 
90e0 23			      inc   HL 
90e1 56			      ld    D, (HL) 
90e2			 
90e2 eb			      ex    DE, HL                  ; Check size of block against want 
90e3 b7			      or    A                       ; Ensure carry flag clear 
90e4 ed 42		      sbc   HL, BC 
90e6 e5			      push  HL                      ; Store the result for later (new block size) 
90e7			 
90e7 ca 36 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
90ea 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
90ec			 
90ec			      ; this_free block is not big enough, setup ptrs to test next free block 
90ec e1			      pop   HL                      ; Discard previous result 
90ed			 
90ed dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
90f0 dd 66 03		      ld    H, (IX+3) 
90f3 dd 75 04		      ld    (IX+4), L 
90f6 dd 74 05		      ld    (IX+5), H 
90f9			 
90f9 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
90fc dd 66 01		      ld    H, (IX+1) 
90ff dd 75 02		      ld    (IX+2), L 
9102 dd 74 03		      ld    (IX+3), H 
9105			 
9105					if DEBUG_FORTH_MALLOC 
9105						DMARK "MA>" 
9105						CALLMONITOR 
9105					endif 
9105 18 c9		      jr    malloc_find_space 
9107			 
9107			      ; split a bigger block into two - requested size and remaining size 
9107			malloc_alloc_split: 
9107					if DEBUG_FORTH_MALLOC 
9107						DMARK "MAs" 
9107						CALLMONITOR 
9107					endif 
9107 eb			      ex    DE, HL                  ; Calculate address of new free block 
9108 2b			      dec   HL 
9109 2b			      dec   HL 
910a 2b			      dec   HL 
910b 09			      add   HL, BC 
910c			 
910c			      ; Create a new block and point it at next_free 
910c dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
910f dd 56 01		      ld    D, (IX+1) 
9112			 
9112 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9113 23			      inc   HL 
9114 72			      ld    (HL), D 
9115			 
9115 d1			      pop   DE                      ; Store size of new block into new block 
9116 23			      inc   HL 
9117 73			      ld    (HL), E 
9118 23			      inc   HL 
9119 72			      ld    (HL), D 
911a			 
911a			      ; Update this_free ptr to point to new block 
911a 2b			      dec   HL 
911b 2b			      dec   HL 
911c 2b			      dec   HL 
911d			 
911d dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9120 dd 56 03		      ld    D, (IX+3) 
9123			 
9123 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9126 dd 74 03		      ld    (IX+3), H 
9129			 
9129			      ; Modify this_free block to be allocation 
9129 eb			      ex    DE, HL 
912a af			      xor   A                       ; Null the next block ptr of allocated block 
912b 77			      ld    (HL), A 
912c 23			      inc   HL 
912d 77			      ld    (HL), A 
912e			 
912e 23			      inc   HL                      ; Store want size into allocated block 
912f 71			      ld    (HL), C 
9130 23			      inc   HL 
9131 70			      ld    (HL), B 
9132 23			      inc   HL 
9133 e5			      push  HL                      ; Address of allocation to return 
9134			 
9134 18 19		      jr    malloc_update_links 
9136			 
9136			malloc_alloc_fit: 
9136 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9137			 
9137					if DEBUG_FORTH_MALLOC 
9137						DMARK "MAf" 
9137						CALLMONITOR 
9137					endif 
9137			      ; Modify this_free block to be allocation 
9137 eb			      ex    DE, HL 
9138 2b			      dec   HL 
9139 2b			      dec   HL 
913a 2b			      dec   HL 
913b			 
913b af			      xor   A                       ; Null the next block ptr of allocated block 
913c 77			      ld    (HL), A 
913d 23			      inc   HL 
913e 77			      ld    (HL), A 
913f			 
913f 23			      inc   HL                      ; Store address of allocation to return 
9140 23			      inc   HL 
9141 23			      inc   HL 
9142 e5			      push  HL 
9143			 
9143			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9143 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9146 dd 66 01		      ld    H, (IX+1) 
9149			 
9149 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
914c dd 74 03		      ld    (IX+3), H 
914f			 
914f			 
914f			malloc_update_links: 
914f			      ; Update prev_free ptr to point to this_free 
914f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9152 dd 66 05		      ld    H, (IX+5) 
9155			 
9155 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9158 dd 56 03		      ld    D, (IX+3) 
915b			 
915b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
915c 23			      inc   HL 
915d 72			      ld    (HL), D 
915e			 
915e					if DEBUG_FORTH_MALLOC 
915e						DMARK "Mul" 
915e						CALLMONITOR 
915e					endif 
915e			      ; Clear the Z flag to indicate successful allocation 
915e 7a			      ld    A, D 
915f b3			      or    E 
9160			 
9160 d1			      pop   DE                      ; Address of allocation 
9161					if DEBUG_FORTH_MALLOC 
9161						DMARK "MAu" 
9161						CALLMONITOR 
9161					endif 
9161			 
9161			malloc_no_space: 
9161 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9164 39			      add   HL, SP 
9165 f9			      ld    SP, HL 
9166			 
9166 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9167					if DEBUG_FORTH_MALLOC 
9167						DMARK "MAN" 
9167						CALLMONITOR 
9167					endif 
9167			 
9167			malloc_early_exit: 
9167					if DEBUG_FORTH_MALLOC 
9167						DMARK "MAx" 
9167						CALLMONITOR 
9167					endif 
9167 dd e1		      pop   IX 
9169 d1			      pop   DE 
916a c1			      pop   BC 
916b			 
916b			if DEBUG_FORTH_MALLOC_HIGH 
916b			call malloc_guard_exit 
916b			call malloc_guard_zerolen 
916b			endif 
916b c9			      ret 
916c			 
916c			 
916c			;------------------------------------------------------------------------------ 
916c			;     free                                                                    : 
916c			;                                                                             : 
916c			; Description                                                                 : 
916c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
916c			;     returned by malloc, otherwise the behaviour is undefined.               : 
916c			;                                                                             : 
916c			;     Where possible, directly adjacent free blocks will be merged together   : 
916c			;     into larger blocks to help ensure that the heap does not become         : 
916c			;     excessively fragmented.                                                 : 
916c			;                                                                             : 
916c			;     free does not clear or set any other value into the freed space, and    : 
916c			;     therefore its contents may be visible through subsequent malloc's. The  : 
916c			;     caller should clear the freed space as required.                        : 
916c			;                                                                             : 
916c			;     This implementation of free uses the stack exclusively, and is          : 
916c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
916c			;     advisable to disable interrupts before calling free, and recommended    : 
916c			;     to avoid the use of free inside ISRs in general.                        : 
916c			;                                                                             : 
916c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
916c			;                                                                             : 
916c			; Parameters                                                                  : 
916c			;     HL  Pointer to address of first byte of allocation to be freed          : 
916c			;                                                                             : 
916c			; Returns                                                                     : 
916c			;     Nothing                                                                 : 
916c			;                                                                             : 
916c			; Stack frame                                                                 : 
916c			;       |             |                                                       : 
916c			;       +-------------+                                                       : 
916c			;       |     BC      |                                                       : 
916c			;       +-------------+                                                       : 
916c			;       |     DE      |                                                       : 
916c			;       +-------------+                                                       : 
916c			;       |     IX      |                                                       : 
916c			;       +-------------+                                                       : 
916c			;       |  prev_free  |                                                       : 
916c			;   +2  +-------------+                                                       : 
916c			;       |  next_free  |                                                       : 
916c			;   +0  +-------------+                                                       : 
916c			;       |             |                                                       : 
916c			;                                                                             : 
916c			;------------------------------------------------------------------------------ 
916c			free: 
916c c5			      push  BC 
916d d5			      push  DE 
916e dd e5		      push  IX 
9170			 
9170 7c			      ld    A, H                    ; Exit if ptr is null 
9171 b5			      or    L 
9172 ca 36 92		      jp    Z, free_early_exit 
9175			 
9175			      ; Set up stack frame 
9175 eb			      ex    DE, HL 
9176 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9179 39			      add   HL, SP 
917a f9			      ld    SP, HL 
917b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
917f dd 39		      add   IX, SP 
9181			 
9181			      ; The address in HL points to the start of the useable allocated space, 
9181			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9181			      ; address of the block itself. 
9181 eb			      ex    DE, HL 
9182 11 fc ff		      ld    DE, -4 
9185 19			      add   HL, DE 
9186			 
9186			      ; An allocated block must have a null next block pointer in it 
9186 7e			      ld    A, (HL) 
9187 23			      inc   HL 
9188 b6			      or    (HL) 
9189 c2 31 92		      jp    NZ, free_done 
918c			 
918c 2b			      dec   HL 
918d			 
918d 44			      ld    B, H                    ; Copy HL to BC 
918e 4d			      ld    C, L 
918f			 
918f			      ; Loop through the free list to find the first block with an address 
918f			      ; higher than the block being freed 
918f 21 9f e3		      ld    HL, free_list 
9192			 
9192			free_find_higher_block: 
9192 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9193 23			      inc   HL 
9194 56			      ld    D, (HL) 
9195 2b			      dec   HL 
9196			 
9196 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9199 dd 72 01		      ld    (IX+1), D 
919c dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
919f dd 74 03		      ld    (IX+3), H 
91a2			 
91a2 78			      ld    A, B                    ; Check if DE is greater than BC 
91a3 ba			      cp    D                       ; Compare MSB first 
91a4 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
91a6 30 04		      jr    NC, free_find_higher_block_skip 
91a8 79			      ld    A, C 
91a9 bb			      cp    E                       ; Then compare LSB 
91aa 38 08		      jr    C, free_found_higher_block 
91ac			 
91ac			free_find_higher_block_skip: 
91ac 7a			      ld    A, D                    ; Reached the end of the free list? 
91ad b3			      or    E 
91ae ca 31 92		      jp    Z, free_done 
91b1			 
91b1 eb			      ex    DE, HL 
91b2			 
91b2 18 de		      jr    free_find_higher_block 
91b4			 
91b4			free_found_higher_block: 
91b4			      ; Insert freed block between prev and next free blocks 
91b4 71			      ld    (HL), C                 ; Point prev free block to freed block 
91b5 23			      inc   HL 
91b6 70			      ld    (HL), B 
91b7			 
91b7 60			      ld    H, B                    ; Point freed block at next free block 
91b8 69			      ld    L, C 
91b9 73			      ld    (HL), E 
91ba 23			      inc   HL 
91bb 72			      ld    (HL), D 
91bc			 
91bc			      ; Check if the freed block is adjacent to the next free block 
91bc 23			      inc   HL                      ; Load size of freed block into HL 
91bd 5e			      ld    E, (HL) 
91be 23			      inc   HL 
91bf 56			      ld    D, (HL) 
91c0 eb			      ex    DE, HL 
91c1			 
91c1 09			      add   HL, BC                  ; Add addr of freed block and its size 
91c2			 
91c2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
91c5 dd 56 01		      ld    D, (IX+1) 
91c8			 
91c8 b7			      or    A                       ; Clear the carry flag 
91c9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
91cb 20 22		      jr    NZ, free_check_adjacent_to_prev 
91cd			 
91cd			      ; Freed block is adjacent to next, merge into one bigger block 
91cd eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
91ce 5e			      ld    E, (HL) 
91cf 23			      inc   HL 
91d0 56			      ld    D, (HL) 
91d1 e5			      push  HL                      ; Save ptr to next block for later 
91d2			 
91d2 60			      ld    H, B                    ; Store ptr from next block into freed block 
91d3 69			      ld    L, C 
91d4 73			      ld    (HL), E 
91d5 23			      inc   HL 
91d6 72			      ld    (HL), D 
91d7			 
91d7 e1			      pop   HL                      ; Restore ptr to next block 
91d8 23			      inc   HL                      ; Load size of next block into DE 
91d9 5e			      ld    E, (HL) 
91da 23			      inc   HL 
91db 56			      ld    D, (HL) 
91dc d5			      push  DE                      ; Save next block size for later 
91dd			 
91dd 60			      ld    H, B                    ; Load size of freed block into HL 
91de 69			      ld    L, C 
91df 23			      inc   HL 
91e0 23			      inc   HL 
91e1 5e			      ld    E, (HL) 
91e2 23			      inc   HL 
91e3 56			      ld    D, (HL) 
91e4 eb			      ex    DE, HL 
91e5			 
91e5 d1			      pop   DE                      ; Restore size of next block 
91e6 19			      add   HL, DE                  ; Add sizes of both blocks 
91e7 eb			      ex    DE, HL 
91e8			 
91e8 60			      ld    H, B                    ; Store new bigger size into freed block 
91e9 69			      ld    L, C 
91ea 23			      inc   HL 
91eb 23			      inc   HL 
91ec 73			      ld    (HL), E 
91ed 23			      inc   HL 
91ee 72			      ld    (HL), D 
91ef			 
91ef			free_check_adjacent_to_prev: 
91ef			      ; Check if the freed block is adjacent to the prev free block 
91ef dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
91f2 dd 66 03		      ld    H, (IX+3) 
91f5			 
91f5 23			      inc   HL                      ; Size of prev free block into DE 
91f6 23			      inc   HL 
91f7 5e			      ld    E, (HL) 
91f8 23			      inc   HL 
91f9 56			      ld    D, (HL) 
91fa 2b			      dec   HL 
91fb 2b			      dec   HL 
91fc 2b			      dec   HL 
91fd			 
91fd 19			      add   HL, DE                  ; Add prev block addr and size 
91fe			 
91fe b7			      or    A                       ; Clear the carry flag 
91ff ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9201 20 2e		      jr    NZ, free_done 
9203			 
9203			      ; Freed block is adjacent to prev, merge into one bigger block 
9203 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9204 69			      ld    L, C 
9205 5e			      ld    E, (HL) 
9206 23			      inc   HL 
9207 56			      ld    D, (HL) 
9208 e5			      push  HL                      ; Save freed block ptr for later 
9209			 
9209 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
920c dd 66 03		      ld    H, (IX+3) 
920f 73			      ld    (HL), E 
9210 23			      inc   HL 
9211 72			      ld    (HL), D 
9212			 
9212 e1			      pop   HL                      ; Restore freed block ptr 
9213 23			      inc   HL                      ; Load size of freed block into DE 
9214 5e			      ld    E, (HL) 
9215 23			      inc   HL 
9216 56			      ld    D, (HL) 
9217 d5			      push  DE                      ; Save freed block size for later 
9218			 
9218 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
921b dd 66 03		      ld    H, (IX+3) 
921e 23			      inc   HL 
921f 23			      inc   HL 
9220 5e			      ld    E, (HL) 
9221 23			      inc   HL 
9222 56			      ld    D, (HL) 
9223			 
9223 e1			      pop   HL                      ; Add sizes of both blocks 
9224 19			      add   HL, DE 
9225 eb			      ex    DE, HL 
9226			 
9226 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9229 dd 66 03		      ld    H, (IX+3) 
922c 23			      inc   HL 
922d 23			      inc   HL 
922e 73			      ld    (HL), E 
922f 23			      inc   HL 
9230 72			      ld    (HL), D 
9231			 
9231			free_done: 
9231 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9234 39			      add   HL, SP 
9235 f9			      ld    SP, HL 
9236			 
9236			free_early_exit: 
9236 dd e1		      pop   IX 
9238 d1			      pop   DE 
9239 c1			      pop   BC 
923a			 
923a c9			      ret 
923b			 
923b			; moved to firmware.asm 
923b			; 
923b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
923b			;                  .dw   0 
923b			 
923b			 
923b			endif 
923b			 
923b			 
923b			if MALLOC_3 
923b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
923b			;heap_start        .equ  0x9000      ; Starting address of heap 
923b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
923b			; 
923b			 ;     .org 0 
923b			  ;    jp    main 
923b			; 
923b			; 
923b			 ;     .org  0x100 
923b			;main: 
923b			 ;     ld    HL, 0x8100 
923b			  ;    ld    SP, HL 
923b			; 
923b			;      call  heap_init 
923b			 
923b			      ; Make some allocations 
923b			;      ld    HL, 12 
923b			;      call  malloc            ; Allocates 0x9004 
923b			; 
923b			 ;     ld    HL, 12 
923b			;      call  malloc            ; Allocates 0x9014 
923b			 
923b			;      ld    HL, 12 
923b			;      call  malloc            ; Allocates 0x9024 
923b			 
923b			      ; Free some allocations 
923b			;      ld    HL, 0x9014 
923b			;      call  free 
923b			 
923b			;      ld    HL, 0x9004 
923b			;      call  free 
923b			; 
923b			;      ld    HL, 0x9024 
923b			;      call  free 
923b			 
923b			 
923b			 ;     halt 
923b			 
923b			 
923b			;------------------------------------------------------------------------------ 
923b			;     heap_init                                                               : 
923b			;                                                                             : 
923b			; Description                                                                 : 
923b			;     Initialise the heap and make it ready for malloc and free operations.   : 
923b			;                                                                             : 
923b			;     The heap is maintained as a linked list, starting with an initial       : 
923b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
923b			;     the first free block in the heap. Each block then points to the next    : 
923b			;     free block within the heap, and the free list ends at the first block   : 
923b			;     with a null pointer to the next free block.                             : 
923b			;                                                                             : 
923b			; Parameters                                                                  : 
923b			;     Inputs are compile-time only. Two defines which specify the starting    : 
923b			;     address of the heap and its size are required, along with a memory      : 
923b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
923b			;     principally stores a pointer to the first free block in the heap.       : 
923b			;                                                                             : 
923b			; Returns                                                                     : 
923b			;     Nothing                                                                 : 
923b			;------------------------------------------------------------------------------ 
923b			heap_init: 
923b			      push  HL 
923b			 
923b			      ; Initialise free list struct 
923b			      ld    HL, heap_start 
923b			      ld    (free_list), HL 
923b			      ld    HL, 0 
923b			      ld    (free_list+2), HL 
923b			 
923b			      ; Insert first free block at bottom of heap, consumes entire heap 
923b			      ld    HL, heap_start+heap_size-4 
923b			      ld    (heap_start), HL        ; Next block (end of free list) 
923b			      ld    HL, heap_size-4 
923b			      ld    (heap_start+2), HL      ; Block size 
923b			 
923b			      ; Insert end of free list block at top of heap - two null words will 
923b			      ; terminate the free list 
923b			      ld    HL, 0 
923b			      ld    (heap_start+heap_size-2), HL 
923b			      ld    (heap_start+heap_size-4), HL 
923b			 
923b			      pop   HL 
923b			 
923b			      ret 
923b			 
923b			 
923b			;------------------------------------------------------------------------------ 
923b			;     malloc                                                                  : 
923b			;                                                                             : 
923b			; Description                                                                 : 
923b			;     Allocates the wanted space from the heap and returns the address of the : 
923b			;     first useable byte of the allocation.                                   : 
923b			;                                                                             : 
923b			;     Allocations can happen in one of two ways:                              : 
923b			;                                                                             : 
923b			;     1. A free block may be found which is the exact size wanted. In this    : 
923b			;        case the block is removed from the free list and retuedn to the      : 
923b			;        caller.                                                              : 
923b			;     2. A free block may be found which is larger than the size wanted. In   : 
923b			;        this case, the larger block is split into two. The first portion of  : 
923b			;        this block will become the requested space by the malloc call and    : 
923b			;        is returned to the caller. The second portion becomes a new free     : 
923b			;        block, and the free list is adjusted to maintain continuity via this : 
923b			;        newly created block.                                                 : 
923b			;                                                                             : 
923b			;     malloc does not set any initial value in the allocated space, the       : 
923b			;     caller is required to do this as required.                              : 
923b			;                                                                             : 
923b			;     This implementation of malloc uses the stack exclusively, and is        : 
923b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
923b			;     advisable to disable interrupts before calling malloc, and recommended  : 
923b			;     to avoid the use of malloc inside ISRs in general.                      : 
923b			;                                                                             : 
923b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
923b			;                                                                             : 
923b			; Parameters                                                                  : 
923b			;     HL  Number of bytes wanted                                              : 
923b			;                                                                             : 
923b			; Returns                                                                     : 
923b			;     HL  Address of the first useable byte of the allocation                 : 
923b			;                                                                             : 
923b			; Flags                                                                       : 
923b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
923b			;                                                                             : 
923b			; Stack frame                                                                 : 
923b			;       |             |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     BC      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     DE      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     IX      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |  prev_free  |                                                       : 
923b			;   +4  +-------------+                                                       : 
923b			;       |  this_free  |                                                       : 
923b			;   +2  +-------------+                                                       : 
923b			;       |  next_free  |                                                       : 
923b			;   +0  +-------------+                                                       : 
923b			;       |             |                                                       : 
923b			;                                                                             : 
923b			;------------------------------------------------------------------------------ 
923b			malloc: 
923b			      push  BC 
923b			      push  DE 
923b			      push  IX 
923b			 
923b			      ld    A, H                    ; Exit if no space requested 
923b			      or    L 
923b			      jp    Z, malloc_early_exit 
923b			 
923b			      ; Set up stack frame 
923b			      ex    DE, HL 
923b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
923b			      add   HL, SP 
923b			      ld    SP, HL 
923b			      ld    IX, 0                   ; Use IX as a frame pointer 
923b			      add   IX, SP 
923b			 
923b			      ; Setup initial state 
923b			      ld    HL, 4                   ; want must also include space used by block struct 
923b			      add   HL, DE 
923b			 
923b			      ld    B, H                    ; Move want to BC 
923b			      ld    C, L 
923b			 
923b			      ld    HL, free_list           ; Store prev_free ptr to stack 
923b			      ld    (IX+4), L 
923b			      ld    (IX+5), H 
923b			 
923b			      ld    E, (HL)                 ; Store this_free ptr to stack 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      ld    (IX+2), E 
923b			      ld    (IX+3), D 
923b			      ex    DE, HL                  ; this_free ptr into HL 
923b			 
923b			      ; Loop through free block list to find some space 
923b			malloc_find_space: 
923b			      ld    E, (HL)                 ; Load next_free ptr into DE 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			 
923b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
923b			      or    E 
923b			      jp    Z, malloc_no_space 
923b			 
923b			      ld    (IX+0), E               ; Store next_free ptr to stack 
923b			      ld    (IX+1), D 
923b			 
923b			      ; Does this block have enough space to make the allocation? 
923b			      inc   HL                      ; Load free block size into DE 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			 
923b			      ex    DE, HL                  ; Check size of block against want 
923b			      or    A                       ; Ensure carry flag clear 
923b			      sbc   HL, BC 
923b			      push  HL                      ; Store the result for later (new block size) 
923b			 
923b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
923b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
923b			 
923b			      ; this_free block is not big enough, setup ptrs to test next free block 
923b			      pop   HL                      ; Discard previous result 
923b			 
923b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
923b			      ld    H, (IX+3) 
923b			      ld    (IX+4), L 
923b			      ld    (IX+5), H 
923b			 
923b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
923b			      ld    H, (IX+1) 
923b			      ld    (IX+2), L 
923b			      ld    (IX+3), H 
923b			 
923b			      jr    malloc_find_space 
923b			 
923b			      ; split a bigger block into two - requested size and remaining size 
923b			malloc_alloc_split: 
923b			      ex    DE, HL                  ; Calculate address of new free block 
923b			      dec   HL 
923b			      dec   HL 
923b			      dec   HL 
923b			      add   HL, BC 
923b			 
923b			      ; Create a new block and point it at next_free 
923b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
923b			      ld    D, (IX+1) 
923b			 
923b			      ld    (HL), E                 ; Store next_free ptr into new block 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      pop   DE                      ; Store size of new block into new block 
923b			      inc   HL 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      ; Update this_free ptr to point to new block 
923b			      dec   HL 
923b			      dec   HL 
923b			      dec   HL 
923b			 
923b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
923b			      ld    D, (IX+3) 
923b			 
923b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
923b			      ld    (IX+3), H 
923b			 
923b			      ; Modify this_free block to be allocation 
923b			      ex    DE, HL 
923b			      xor   A                       ; Null the next block ptr of allocated block 
923b			      ld    (HL), A 
923b			      inc   HL 
923b			      ld    (HL), A 
923b			 
923b			      inc   HL                      ; Store want size into allocated block 
923b			      ld    (HL), C 
923b			      inc   HL 
923b			      ld    (HL), B 
923b			      inc   HL 
923b			      push  HL                      ; Address of allocation to return 
923b			 
923b			      jr    malloc_update_links 
923b			 
923b			malloc_alloc_fit: 
923b			      pop   HL                      ; Dont need new block size, want is exact fit 
923b			 
923b			      ; Modify this_free block to be allocation 
923b			      ex    DE, HL 
923b			      dec   HL 
923b			      dec   HL 
923b			      dec   HL 
923b			 
923b			      xor   A                       ; Null the next block ptr of allocated block 
923b			      ld    (HL), A 
923b			      inc   HL 
923b			      ld    (HL), A 
923b			 
923b			      inc   HL                      ; Store address of allocation to return 
923b			      inc   HL 
923b			      inc   HL 
923b			      push  HL 
923b			 
923b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
923b			      ld    L, (IX+0)               ; next_free to HL 
923b			      ld    H, (IX+1) 
923b			 
923b			      ld    (IX+2), L               ; HL to this_free 
923b			      ld    (IX+3), H 
923b			 
923b			 
923b			malloc_update_links: 
923b			      ; Update prev_free ptr to point to this_free 
923b			      ld    L, (IX+4)               ; prev_free ptr to HL 
923b			      ld    H, (IX+5) 
923b			 
923b			      ld    E, (IX+2)               ; this_free ptr to DE 
923b			      ld    D, (IX+3) 
923b			 
923b			      ld    (HL), E                 ; this_free ptr into prev_free 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      ; Clear the Z flag to indicate successful allocation 
923b			      ld    A, D 
923b			      or    E 
923b			 
923b			      pop   DE                      ; Address of allocation 
923b			 
923b			malloc_no_space: 
923b			      ld    HL, 6                   ; Clean up stack frame 
923b			      add   HL, SP 
923b			      ld    SP, HL 
923b			 
923b			      ex    DE, HL                  ; Alloc addr into HL for return 
923b			 
923b			malloc_early_exit: 
923b			      pop   IX 
923b			      pop   DE 
923b			      pop   BC 
923b			 
923b			      ret 
923b			 
923b			 
923b			;------------------------------------------------------------------------------ 
923b			;     free                                                                    : 
923b			;                                                                             : 
923b			; Description                                                                 : 
923b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
923b			;     returned by malloc, otherwise the behaviour is undefined.               : 
923b			;                                                                             : 
923b			;     Where possible, directly adjacent free blocks will be merged together   : 
923b			;     into larger blocks to help ensure that the heap does not become         : 
923b			;     excessively fragmented.                                                 : 
923b			;                                                                             : 
923b			;     free does not clear or set any other value into the freed space, and    : 
923b			;     therefore its contents may be visible through subsequent malloc's. The  : 
923b			;     caller should clear the freed space as required.                        : 
923b			;                                                                             : 
923b			;     This implementation of free uses the stack exclusively, and is          : 
923b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
923b			;     advisable to disable interrupts before calling free, and recommended    : 
923b			;     to avoid the use of free inside ISRs in general.                        : 
923b			;                                                                             : 
923b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
923b			;                                                                             : 
923b			; Parameters                                                                  : 
923b			;     HL  Pointer to address of first byte of allocation to be freed          : 
923b			;                                                                             : 
923b			; Returns                                                                     : 
923b			;     Nothing                                                                 : 
923b			;                                                                             : 
923b			; Stack frame                                                                 : 
923b			;       |             |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     BC      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     DE      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |     IX      |                                                       : 
923b			;       +-------------+                                                       : 
923b			;       |  prev_free  |                                                       : 
923b			;   +2  +-------------+                                                       : 
923b			;       |  next_free  |                                                       : 
923b			;   +0  +-------------+                                                       : 
923b			;       |             |                                                       : 
923b			;                                                                             : 
923b			;------------------------------------------------------------------------------ 
923b			free: 
923b			      push  BC 
923b			      push  DE 
923b			      push  IX 
923b			 
923b			      ld    A, H                    ; Exit if ptr is null 
923b			      or    L 
923b			      jp    Z, free_early_exit 
923b			 
923b			      ; Set up stack frame 
923b			      ex    DE, HL 
923b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
923b			      add   HL, SP 
923b			      ld    SP, HL 
923b			      ld    IX, 0                   ; Use IX as a frame pointer 
923b			      add   IX, SP 
923b			 
923b			      ; The address in HL points to the start of the useable allocated space, 
923b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
923b			      ; address of the block itself. 
923b			      ex    DE, HL 
923b			      ld    DE, -4 
923b			      add   HL, DE 
923b			 
923b			      ; An allocated block must have a null next block pointer in it 
923b			      ld    A, (HL) 
923b			      inc   HL 
923b			      or    (HL) 
923b			      jp    NZ, free_done 
923b			 
923b			      dec   HL 
923b			 
923b			      ld    B, H                    ; Copy HL to BC 
923b			      ld    C, L 
923b			 
923b			      ; Loop through the free list to find the first block with an address 
923b			      ; higher than the block being freed 
923b			      ld    HL, free_list 
923b			 
923b			free_find_higher_block: 
923b			      ld    E, (HL)                 ; Load next ptr from free block 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      dec   HL 
923b			 
923b			      ld    (IX+0), E               ; Save ptr to next free block 
923b			      ld    (IX+1), D 
923b			      ld    (IX+2), L               ; Save ptr to prev free block 
923b			      ld    (IX+3), H 
923b			 
923b			      ld    A, B                    ; Check if DE is greater than BC 
923b			      cp    D                       ; Compare MSB first 
923b			      jr    Z, $+4                  ; MSB the same, compare LSB 
923b			      jr    NC, free_find_higher_block_skip 
923b			      ld    A, C 
923b			      cp    E                       ; Then compare LSB 
923b			      jr    C, free_found_higher_block 
923b			 
923b			free_find_higher_block_skip: 
923b			      ld    A, D                    ; Reached the end of the free list? 
923b			      or    E 
923b			      jp    Z, free_done 
923b			 
923b			      ex    DE, HL 
923b			 
923b			      jr    free_find_higher_block 
923b			 
923b			free_found_higher_block: 
923b			      ; Insert freed block between prev and next free blocks 
923b			      ld    (HL), C                 ; Point prev free block to freed block 
923b			      inc   HL 
923b			      ld    (HL), B 
923b			 
923b			      ld    H, B                    ; Point freed block at next free block 
923b			      ld    L, C 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      ; Check if the freed block is adjacent to the next free block 
923b			      inc   HL                      ; Load size of freed block into HL 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      ex    DE, HL 
923b			 
923b			      add   HL, BC                  ; Add addr of freed block and its size 
923b			 
923b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
923b			      ld    D, (IX+1) 
923b			 
923b			      or    A                       ; Clear the carry flag 
923b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
923b			      jr    NZ, free_check_adjacent_to_prev 
923b			 
923b			      ; Freed block is adjacent to next, merge into one bigger block 
923b			      ex    DE, HL                  ; Load next ptr from next block into DE 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      push  HL                      ; Save ptr to next block for later 
923b			 
923b			      ld    H, B                    ; Store ptr from next block into freed block 
923b			      ld    L, C 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      pop   HL                      ; Restore ptr to next block 
923b			      inc   HL                      ; Load size of next block into DE 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      push  DE                      ; Save next block size for later 
923b			 
923b			      ld    H, B                    ; Load size of freed block into HL 
923b			      ld    L, C 
923b			      inc   HL 
923b			      inc   HL 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      ex    DE, HL 
923b			 
923b			      pop   DE                      ; Restore size of next block 
923b			      add   HL, DE                  ; Add sizes of both blocks 
923b			      ex    DE, HL 
923b			 
923b			      ld    H, B                    ; Store new bigger size into freed block 
923b			      ld    L, C 
923b			      inc   HL 
923b			      inc   HL 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			free_check_adjacent_to_prev: 
923b			      ; Check if the freed block is adjacent to the prev free block 
923b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
923b			      ld    H, (IX+3) 
923b			 
923b			      inc   HL                      ; Size of prev free block into DE 
923b			      inc   HL 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      dec   HL 
923b			      dec   HL 
923b			      dec   HL 
923b			 
923b			      add   HL, DE                  ; Add prev block addr and size 
923b			 
923b			      or    A                       ; Clear the carry flag 
923b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
923b			      jr    NZ, free_done 
923b			 
923b			      ; Freed block is adjacent to prev, merge into one bigger block 
923b			      ld    H, B                    ; Load next ptr from freed block into DE 
923b			      ld    L, C 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      push  HL                      ; Save freed block ptr for later 
923b			 
923b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
923b			      ld    H, (IX+3) 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			      pop   HL                      ; Restore freed block ptr 
923b			      inc   HL                      ; Load size of freed block into DE 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			      push  DE                      ; Save freed block size for later 
923b			 
923b			      ld    L, (IX+2)               ; Load size of prev block into DE 
923b			      ld    H, (IX+3) 
923b			      inc   HL 
923b			      inc   HL 
923b			      ld    E, (HL) 
923b			      inc   HL 
923b			      ld    D, (HL) 
923b			 
923b			      pop   HL                      ; Add sizes of both blocks 
923b			      add   HL, DE 
923b			      ex    DE, HL 
923b			 
923b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
923b			      ld    H, (IX+3) 
923b			      inc   HL 
923b			      inc   HL 
923b			      ld    (HL), E 
923b			      inc   HL 
923b			      ld    (HL), D 
923b			 
923b			free_done: 
923b			      ld    HL, 4                   ; Clean up stack frame 
923b			      add   HL, SP 
923b			      ld    SP, HL 
923b			 
923b			free_early_exit: 
923b			      pop   IX 
923b			      pop   DE 
923b			      pop   BC 
923b			 
923b			      ret 
923b			 
923b			 
923b			;      .org 0x8000 
923b			; 
923b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
923b			 ;                 .dw   0 
923b			 
923b			endif 
923b			 
923b			 
923b			if MALLOC_4 
923b			 
923b			; My memory allocation code. Very very simple.... 
923b			; allocate space under 250 chars 
923b			 
923b			heap_init: 
923b				; init start of heap as zero 
923b				;  
923b			 
923b				ld hl, heap_start 
923b			;	ld a, 0 
923b				ld (hl), 0      ; empty block 
923b				inc hl 
923b			;	ld a, 0 
923b				ld (hl), 0      ; length of block 
923b				; write end of list 
923b				inc hl 
923b				ld a,(hl) 
923b				inc hl 
923b				ld a,(hl) 
923b				 
923b			 
923b				; init some malloc vars 
923b			 
923b				ld hl, 0 
923b				ld (free_list), hl       ; store last malloc location 
923b			 
923b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
923b			;	ld a, 0 
923b				ld (hl), 0 
923b			 
923b			 
923b				ld hl, heap_start 
923b				;  
923b				  
923b				ret 
923b			 
923b			 
923b			;    free block marker 
923b			;    requested size  
923b			;    pointer to next block 
923b			;    .... 
923b			;    next block marker 
923b			 
923b			 
923b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
923b			; 
923b			 
923b			 
923b			malloc:  
923b				push de 
923b				push bc 
923b				push af 
923b			 
923b				; hl space required 
923b				 
923b				ld c, l    ; hold space   (TODO only a max of 255) 
923b			 
923b			;	inc c     ; TODO BUG need to fix memory leak on push str 
923b			;	inc c 
923b			;	inc c 
923b			;	inc c 
923b			;	inc c 
923b			;	inc c 
923b			;	inc c 
923b			 
923b			 
923b			 
923b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
923b			 
923b				ld a, (free_list+3) 
923b			;	cp 0 
923b				or a 
923b				jr z, .contheap 
923b			 
923b				ld hl, (free_list)     ; get last alloc 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "mrs" 
923b						CALLMONITOR 
923b					endif 
923b				jr .startalloc 
923b			 
923b			.contheap: 
923b				ld hl, heap_start 
923b			 
923b			.startalloc: 
923b			 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "mym" 
923b						CALLMONITOR 
923b					endif 
923b			.findblock: 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "mmf" 
923b						CALLMONITOR 
923b					endif 
923b			 
923b				ld a,(hl)  
923b				; if byte is zero then clear to use 
923b			 
923b			;	cp 0 
923b				or a 
923b				jr z, .foundemptyblock 
923b			 
923b				; if byte is not clear 
923b				;     then byte is offset to next block 
923b			 
923b				inc hl 
923b				ld a, (hl) ; get size 
923b			.nextblock:	inc hl 
923b					ld e, (hl) 
923b					inc hl 
923b					ld d, (hl) 
923b					ex de, hl 
923b			;	inc hl  ; move past the store space 
923b			;	inc hl  ; move past zero index  
923b			 
923b				; TODO detect no more space 
923b			 
923b				push hl 
923b				ld de, heap_end 
923b				call cmp16 
923b				pop hl 
923b				jr nc, .nospace 
923b			 
923b				jr .findblock 
923b			 
923b			.nospace: ld hl, 0 
923b				jp .exit 
923b			 
923b			 
923b			.foundemptyblock:	 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "mme" 
923b						CALLMONITOR 
923b					endif 
923b			 
923b			; TODO has block enough space if reusing??? 
923b			 
923b				;  
923b			 
923b			; see if this block has been previously used 
923b				inc hl 
923b				ld a, (hl) 
923b				dec hl 
923b			;	cp 0 
923b				or a 
923b				jr z, .newblock 
923b			 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "meR" 
923b						CALLMONITOR 
923b					endif 
923b			 
923b			; no reusing previously allocated block 
923b			 
923b			; is it smaller than previously used? 
923b				 
923b				inc hl    ; move to size 
923b				ld a, c 
923b				sub (hl)        ; we want c < (hl) 
923b				dec hl    ; move back to marker 
923b			        jr z, .findblock 
923b			 
923b				; update with the new size which should be lower 
923b			 
923b			        ;inc  hl   ; negate next move. move back to size  
923b			 
923b			.newblock: 
923b				; need to be at marker here 
923b			 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "meN" 
923b						CALLMONITOR 
923b					endif 
923b			 
923b			 
923b				ld a, c 
923b			 
923b				ld (free_list+3), a	 ; flag resume from last malloc  
923b				ld (free_list), hl    ; save out last location 
923b			 
923b			 
923b				;inc a     ; space for length byte 
923b				ld (hl), a     ; save block in use marker 
923b			 
923b				inc hl   ; move to space marker 
923b				ld (hl), a    ; save new space 
923b			 
923b				inc hl   ; move to start of allocated area 
923b				 
923b			;	push hl     ; save where we are - 1  
923b			 
923b			;	inc hl  ; move past zero index  
923b				; skip space to set down new marker 
923b			 
923b				; provide some extra space for now 
923b			 
923b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
923b				inc a 
923b				inc a 
923b			 
923b				push hl   ; save where we are in the node block 
923b			 
923b				call addatohl 
923b			 
923b				; write linked list point 
923b			 
923b				pop de     ; get our node position 
923b				ex de, hl 
923b			 
923b				ld (hl), e 
923b				inc hl 
923b				ld (hl), d 
923b			 
923b				inc hl 
923b			 
923b				; now at start of allocated data so save pointer 
923b			 
923b				push hl 
923b			 
923b				; jump to position of next node and setup empty header in DE 
923b			 
923b				ex de, hl 
923b			 
923b			;	inc hl ; move past end of block 
923b			 
923b			;	ld a, 0 
923b				ld (hl), 0   ; empty marker 
923b				inc hl 
923b				ld (hl), 0   ; size 
923b				inc hl  
923b				ld (hl), 0   ; ptr 
923b				inc hl 
923b				ld (hl), 0   ; ptr 
923b			 
923b			 
923b				pop hl 
923b			 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "mmr" 
923b						CALLMONITOR 
923b					endif 
923b			 
923b			.exit: 
923b				pop af 
923b				pop bc 
923b				pop de  
923b				ret 
923b			 
923b			 
923b			 
923b			 
923b			free:  
923b				push hl 
923b				push af 
923b				; get address in hl 
923b			 
923b					if DEBUG_FORTH_MALLOC_INT 
923b						DMARK "fre" 
923b						CALLMONITOR 
923b					endif 
923b				; data is at hl - move to block count 
923b				dec hl 
923b				dec hl    ; get past pointer 
923b				dec hl 
923b			 
923b				ld a, (hl)    ; need this for a validation check 
923b			 
923b				dec hl    ; move to block marker 
923b			 
923b				; now check that the block count and block marker are the same  
923b			        ; this checks that we are on a malloc node and not random memory 
923b			        ; OK a faint chance this could be a problem but rare - famous last words! 
923b			 
923b				ld c, a 
923b				ld a, (hl)    
923b			 
923b				cp c 
923b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
923b			 
923b				; yes good chance we are on a malloc node 
923b			 
923b			;	ld a, 0      
923b				ld (hl), 0   ; mark as free 
923b			 
923b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
923b			 
923b			.freeignore:  
923b			 
923b				pop af 
923b				pop hl 
923b			 
923b				ret 
923b			 
923b			 
923b			 
923b			endif 
923b			 
923b			; eof 
# End of file firmware_memory.asm
923b			  
923b			; device C  
923b			; Now handled by SPI  
923b			;if SOUND_ENABLE  
923b			;	include "firmware_sound.asm"  
923b			;endif  
923b			  
923b			include "firmware_diags.asm"  
923b			; Hardware diags menu 
923b			 
923b			 
923b			config: 
923b			 
923b 3e 00			ld a, 0 
923d 21 5c 92			ld hl, .configmn 
9240 cd dc 8a			call menu 
9243			 
9243 fe 00			cp 0 
9245 c8				ret z 
9246			 
9246			;	cp 1 
9246			;	call z, .savetostore 
9246			 
9246 fe 01			cp 1 
9248			if STARTUP_V1 
9248 cc 70 92			call z, .selautoload 
924b			endif 
924b			 
924b			if STARTUP_V2 
924b				call z, .enautoload 
924b			endif 
924b fe 02			cp 2 
924d cc 66 92			call z, .disautoload 
9250			;	cp 3 
9250			;	call z, .selbank 
9250 fe 03			cp 3 
9252 cc 8e 92			call z, .debug_tog 
9255 fe 04			cp 4 
9257 cc 5c 93			call z, .bpsgo 
925a			;	cp 5 
925a			;	call z, hardware_diags 
925a			if STARTUP_V2 
925a				cp 5 
925a				call z, create_startup 
925a			endif 
925a 18 df			jr config 
925c			 
925c			.configmn: 
925c			;	dw prom_c3 
925c 4a 95			dw prom_c2 
925e 5f 95			dw prom_c2a 
9260			;	dw prom_c2b 
9260			;	dw prom_c4 
9260 7e 95			dw prom_m4 
9262 99 95			dw prom_m4b 
9264			;	dw prom_c1 
9264			if STARTUP_V2 
9264				dw prom_c9 
9264			endif 
9264 00 00			dw 0 
9266				 
9266			 
9266			if STARTUP_V2 
9266			.enautoload: 
9266				if STORAGE_SE 
9266				ld a, $fe      ; bit 0 clear 
9266				ld (spi_device), a 
9266			 
9266				call storage_get_block_0 
9266			 
9266				ld a, 1 
9266				ld (store_page+STORE_0_AUTOFILE), a 
9266			 
9266					ld hl, 0 
9266					ld de, store_page 
9266				call storage_write_block	 ; save update 
9266				else 
9266			 
9266				ld hl, prom_notav 
9266				ld de, prom_empty 
9266				call info_panel 
9266				endif 
9266			 
9266			 
9266				ret 
9266			endif 
9266			 
9266			.disautoload: 
9266				if STORAGE_SE 
9266				ld a, $fe      ; bit 0 clear 
9266				ld (spi_device), a 
9266			 
9266				call storage_get_block_0 
9266			 
9266				ld a, 0 
9266				ld (store_page+STORE_0_AUTOFILE), a 
9266			 
9266					ld hl, 0 
9266					ld de, store_page 
9266				call storage_write_block	 ; save update 
9266				else 
9266			 
9266 21 a1 95			ld hl, prom_notav 
9269 11 b7 95			ld de, prom_empty 
926c cd 3e 8a			call info_panel 
926f				endif 
926f			 
926f			 
926f c9				ret 
9270			 
9270			if STARTUP_V1 
9270			 
9270			; Select auto start 
9270			 
9270			.selautoload: 
9270			 
9270				 
9270				if STORAGE_SE 
9270			 
9270					call config_dir 
9270				        ld hl, scratch 
9270					ld a, 0 
9270					call menu 
9270			 
9270					cp 0 
9270					ret z 
9270			 
9270					dec a 
9270			 
9270			 
9270					; locate menu option 
9270			 
9270					ld hl, scratch 
9270					call table_lookup 
9270			 
9270					if DEBUG_FORTH_WORDS 
9270						DMARK "ALl" 
9270						CALLMONITOR 
9270					endif 
9270					; with the pointer to the menu it, the byte following the zero term is the file id 
9270			 
9270					ld a, 0 
9270					ld bc, 50   ; max of bytes to look at 
9270					cpir  
9270			 
9270					if DEBUG_FORTH_WORDS 
9270						DMARK "ALb" 
9270						CALLMONITOR 
9270					endif 
9270					;inc hl 
9270			 
9270					ld a, (hl)   ; file id 
9270					 
9270				        ; save bank and file ids 
9270			 
9270					push af 
9270			 
9270			; TODO need to save to block 0 on bank 1	 
9270			 
9270					call storage_get_block_0 
9270			 
9270					if DEBUG_FORTH_WORDS 
9270						DMARK "AL0" 
9270						CALLMONITOR 
9270					endif 
9270					pop af 
9270			 
9270					ld (store_page+STORE_0_FILERUN),a 
9270					 
9270					; save bank id 
9270			 
9270					ld a,(spi_device) 
9270					ld (store_page+STORE_0_BANKRUN),a 
9270			 
9270					; enable auto run of store file 
9270			 
9270					ld a, 1 
9270					ld (store_page+STORE_0_AUTOFILE),a 
9270			 
9270					; save buffer 
9270			 
9270					ld hl, 0 
9270					ld de, store_page 
9270					if DEBUG_FORTH_WORDS 
9270						DMARK "ALw" 
9270						CALLMONITOR 
9270					endif 
9270				call storage_write_block	 ; save update 
9270			  
9270			 
9270			 
9270			 
9270					ld hl, scratch 
9270					call config_fdir 
9270			 
9270				else 
9270			 
9270 21 a1 95			ld hl, prom_notav 
9273 11 b7 95			ld de, prom_empty 
9276 cd 3e 8a			call info_panel 
9279			 
9279				endif 
9279 c9				ret 
927a			endif 
927a			 
927a			 
927a			; Select storage bank 
927a			 
927a			.selbank: 
927a			 
927a			;	if STORAGE_SE 
927a			;	else 
927a			 
927a 21 a1 95			ld hl, prom_notav 
927d 11 b7 95			ld de, prom_empty 
9280 cd 3e 8a			call info_panel 
9283			;	endif 
9283				 
9283 c9				ret 
9284			 
9284			if STORAGE_SE 
9284			 
9284			.config_ldir:   
9284				; Load storage bank labels into menu array 
9284			 
9284				 
9284			 
9284			 
9284				ret 
9284			 
9284			 
9284			endif 
9284			 
9284			 
9284			; Save user words to storage 
9284			 
9284			.savetostore: 
9284			 
9284			;	if STORAGE_SE 
9284			; 
9284			;		call config_dir 
9284			;	        ld hl, scratch 
9284			;		ld a, 0 
9284			;		call menu 
9284			;		 
9284			;		ld hl, scratch 
9284			;		call config_fdir 
9284			; 
9284			;	else 
9284			 
9284 21 a1 95			ld hl, prom_notav 
9287 11 b7 95			ld de, prom_empty 
928a cd 3e 8a			call info_panel 
928d			 
928d			;	endif 
928d			 
928d c9				ret 
928e			 
928e			if STARTUP_V2 
928e			 
928e			create_startup: 
928e			 
928e				ld a, 0 
928e				ld hl, .crstart 
928e				call menu 
928e			 
928e				cp 0 
928e				ret z 
928e			 
928e				cp 1 
928e				call z, .genlsword 
928e				cp 2 
928e				call z, .genedword 
928e			 
928e				cp 3 
928e				call z, .gendemword 
928e			 
928e				cp 4 
928e				call z, .genutlword 
928e				cp 5 
928e				call z, .genspiword 
928e				cp 6 
928e				call z, .genkeyword 
928e				cp 7 
928e				call z, .gensoundword 
928e				cp 8 
928e				call z, .genhwword 
928e				jr create_startup 
928e			 
928e			.genhwword: 
928e				ld hl, crs_hw 
928e				ld de, .hwworddef 
928e				call .genfile 
928e				ret 
928e			.gensoundword: 
928e				ld hl, crs_sound 
928e				ld de, .soundworddef 
928e				call .genfile 
928e				ret 
928e			.genlsword: 
928e				ld hl, crs_s1 
928e				ld de, .lsworddef 
928e				call .genfile 
928e				ret 
928e			 
928e			.genedword: 
928e				ld de, .edworddef 
928e				ld hl, crs_s2 
928e				call .genfile 
928e				ret 
928e			 
928e			.gendemword: 
928e				ld de, .demoworddef 
928e				ld hl, crs_s3 
928e				call .genfile 
928e				ret 
928e			 
928e			.genutlword: 
928e				ld hl, crs_s4 
928e				ld de, .utilwordef 
928e				call .genfile 
928e				ret 
928e			.genspiword: 
928e				ld hl, crs_s5 
928e				ld de, .spiworddef 
928e				call .genfile 
928e				ret 
928e			.genkeyword: 
928e				ld hl, crs_s6 
928e				ld de, .keyworddef 
928e				call .genfile 
928e				ret 
928e			 
928e			; hl - points to file name 
928e			; de - points to strings to add to file 
928e			 
928e			.genfile: 
928e				push hl 
928e				push de 
928e			 
928e				call clear_display 
928e				ld a, display_row_1 
928e				ld de, .genfiletxt 
928e				call str_at_display 
928e				call update_display 
928e			 
928e				pop de 
928e				pop hl 
928e			 
928e			 
928e				push de 
928e				call storage_create 
928e				; id in hl 
928e				pop de   ; table of strings to add 
928e			 
928e			.genloop: 
928e			 
928e				push hl ; save id for next time around 
928e				push de ; save de for next time around 
928e			 
928e				ex de, hl 
928e				call loadwordinhl 
928e				ex de, hl 
928e			 
928e				; need hl to be the id 
928e				; need de to be the string ptr 
928e				 
928e				call storage_append 
928e			 
928e				pop de 
928e				pop hl 
928e			 
928e				inc de 
928e				inc de 
928e			 
928e				ld a,(de) 
928e				cp 0 
928e				jr nz, .genloop 
928e				inc de 
928e				ld a, (de) 
928e				dec de 
928e				cp 0 
928e				jr nz, .genloop	 
928e			 
928e				ret 
928e			 
928e			.genfiletxt:  db "Creating file...",0 
928e			 
928e			.hwworddef: 
928e				dw test5 
928e				dw test6 
928e				dw test7 
928e				dw test8 
928e				dw test9 
928e				dw test10 
928e				dw 0 
928e			 
928e			.soundworddef: 
928e				dw sound1 
928e				dw sound2 
928e				dw sound3 
928e				dw sound4 
928e				dw sound5 
928e				dw sound6 
928e				dw sound7 
928e				dw sound8 
928e				dw sound9 
928e				dw 0 
928e			 
928e			.utilwordef: 
928e				dw strncpy 
928e				dw type 
928e				dw tuck 
928e				dw clrstack 
928e				dw longread 
928e				dw start1 
928e				dw start2 
928e			; duplicated 
928e			;	dw start3b 
928e			;	dw start3c 
928e				dw list 
928e				dw 0 
928e			 
928e			.lsworddef: 
928e				dw start3b 
928e				dw 0 
928e			 
928e			.edworddef: 
928e				dw edit1 
928e				dw edit2 
928e				dw edit3 
928e				dw 0 
928e			 
928e			.demoworddef: 
928e				dw game1 
928e				dw game1a 
928e				dw game1b 
928e				dw game1c 
928e				dw game1d 
928e				dw game1s 
928e				dw game1t 
928e				dw game1f 
928e				dw game1z 
928e				dw game1zz 
928e				dw ssv2 
928e				dw ssv3 
928e				dw ssv4 
928e				dw ssv5 
928e				dw ssv1 
928e				dw ssv1cpm	 
928e			;	dw game2b 
928e			;	dw game2bf 
928e			;	dw game2mba 
928e			;	dw game2mbas	 
928e			;	dw game2mbht 
928e			;	dw game2mbms 
928e			;	dw game2mb 
928e			;	dw game3w 
928e			;	dw game3p 
928e			;	dw game3sc 
928e			;	dw game3vsi 
928e			;	dw game3vs 
928e				dw 0 
928e			 
928e			 
928e			.spiworddef: 
928e			 
928e			    dw spi1 
928e			    dw spi2 
928e			    dw spi2b 
928e			    dw spi3 
928e			    dw spi4 
928e			    dw spi5 
928e			;    dw spi6 
928e			;    dw spi7 
928e			 
928e			;    dw spi8 
928e			;    dw spi9 
928e			;    dw spi10 
928e			    dw 0 
928e			 
928e			.keyworddef: 
928e			 
928e				dw keyup 
928e				dw keydown 
928e				dw keyleft 
928e				dw keyright 
928e				dw 	keyf1 
928e				dw keyf2 
928e				dw keyf3 
928e				dw keyf4 
928e				dw keyf5 
928e				dw keyf6 
928e				dw keyf7 
928e				dw keyf8 
928e				dw keyf9 
928e				dw keyf10 
928e				dw keyf11 
928e				dw keyf12 
928e				dw keytab 
928e				dw keycr 
928e				dw keyhome 
928e				dw keyend 
928e				dw keybs 
928e				dw 0 
928e			 
928e			.crstart: 
928e				dw crs_s1 
928e				dw crs_s2 
928e				dw crs_s3 
928e				dw crs_s4 
928e				dw crs_s5 
928e				dw crs_s6 
928e				dw crs_sound 
928e				dw crs_hw 
928e				dw 0 
928e			 
928e			endif 
928e			 
928e			 
928e			if STORAGE_SE 
928e			 
928e			config_fdir: 
928e				; using the scratch dir go through and release the memory allocated for each string 
928e				 
928e				ld hl, scratch 
928e			.cfdir:	ld e,(hl) 
928e				inc hl 
928e				ld d,(hl) 
928e				inc hl 
928e			 
928e				ex de, hl 
928e				call ishlzero 
928e				ret z     ; return on null pointer 
928e				call free 
928e				ex de, hl 
928e				jr .cfdir 
928e			 
928e			 
928e				ret 
928e			 
928e			 
928e			config_dir: 
928e			 
928e				; for the config menus that need to build a directory of storage call this routine 
928e				; it will construct a menu in scratch to pass to menu 
928e			 
928e				; open storage device 
928e			 
928e				; execute DIR to build a list of files and their ids into scratch in menu format 
928e				; once the menu has finished then will need to call config_fdir to release the strings 
928e				 
928e				; c = number items 
928e			 
928e				 
928e				call storage_get_block_0 
928e			 
928e				ld hl, store_page     ; get current id count 
928e				ld b, (hl) 
928e				ld c, 0    ; count of files   
928e			 
928e			 
928e				ld hl, scratch 
928e				ld (store_tmp2), hl    ; location to poke strings 
928e			 
928e				; check for empty drive 
928e			 
928e				ld a, 0 
928e				cp b 
928e				jp z, .dirdone 
928e			 
928e				 
928e					if DEBUG_FORTH_WORDS 
928e						DMARK "Cdc" 
928e						CALLMONITOR 
928e					endif 
928e			 
928e			 
928e			.diritem:	 
928e				push bc 
928e				; for each of the current ids do a search for them and if found push to stack 
928e			 
928e					ld hl, STORE_BLOCK_PHY 
928e					ld d, 0		 ; look for extent 0 of block id as this contains file name 
928e					ld e,b 
928e			 
928e					call storage_findnextid 
928e			 
928e			 
928e					; if found hl will be non zero 
928e			 
928e					call ishlzero 
928e					jr z, .dirnotfound 
928e			 
928e					; increase count 
928e			 
928e					pop bc	 
928e					inc c 
928e					push bc 
928e					 
928e			 
928e					; get file header and push the file name 
928e			 
928e					ld de, store_page 
928e					call storage_read_block 
928e			 
928e					; push file id to stack 
928e				 
928e					ld a, (store_page) 
928e					ld h, 0 
928e					ld l, a 
928e			 
928e					;call forth_push_numhl 
928e					; TODO store id 
928e			 
928e					push hl 
928e			 
928e					; push extent count to stack  
928e				 
928e					ld hl, store_page+3 
928e			 
928e					; get file name length 
928e			 
928e					call strlenz   
928e			 
928e					inc hl   ; cover zero term 
928e					inc hl  ; stick the id at the end of the area 
928e			 
928e					push hl 
928e					pop bc    ; move length to bc 
928e			 
928e					call malloc 
928e			 
928e					; TODO save malloc area to scratch 
928e			 
928e					ex de, hl 
928e					ld hl, (store_tmp2) 
928e					ld (hl), e 
928e					inc hl 
928e					ld (hl), d 
928e					inc hl 
928e					ld (store_tmp2), hl 
928e			 
928e					 
928e			 
928e					;pop hl   ; get source 
928e			;		ex de, hl    ; swap aronund	 
928e			 
928e					ld hl, store_page+3 
928e					if DEBUG_FORTH_WORDS 
928e						DMARK "CFd" 
928e						CALLMONITOR 
928e					endif 
928e					ldir 
928e			 
928e					; de is past string, move back one and store id 
928e					 
928e					dec de 
928e			 
928e					; store file id 
928e			 
928e					pop hl 
928e					ex de,hl 
928e					ld (hl), e 
928e			 
928e					if DEBUG_FORTH_WORDS 
928e						DMARK "Cdi" 
928e						CALLMONITOR 
928e					endif 
928e					 
928e			.dirnotfound: 
928e					pop bc     
928e					djnz .diritem 
928e				 
928e			.dirdone:	 
928e			 
928e			;		ld a, 0 
928e					ld hl, (store_tmp2) 
928e					ld (hl), 0 
928e					inc hl 
928e					ld (hl), 0 
928e					inc hl 
928e					; push a count of the dir items found 
928e			 
928e			;		ld h, 0 
928e			;		ld l, c 
928e			 
928e				ret 
928e			 
928e			endif 
928e			 
928e			 
928e			; Settings 
928e			; Run  
928e			 
928e			 
928e			 
928e			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
928e			;;hd_menu2:   db "        2: Editor",0   
928e			;hd_menu2:   db "        2: Editor       6: Menu",0   
928e			;hd_menu3:   db "        3: Storage",0 
928e			;hd_menu4:   db "0=quit  4: Debug",0 
928e			;hd_don:     db "ON",0 
928e			;hd_doff:     db "OFF",0 
928e			; 
928e			; 
928e			; 
928e			;hardware_diags_old:       
928e			; 
928e			;.diagmenu: 
928e			;	call clear_display 
928e			;	ld a, display_row_1 
928e			;	ld de, hd_menu1 
928e			;	call str_at_display 
928e			; 
928e			;	ld a, display_row_2 
928e			;	ld de, hd_menu2 
928e			;	call str_at_display 
928e			; 
928e			;	ld a, display_row_3 
928e			;	ld de, hd_menu3 
928e			;	call str_at_display 
928e			; 
928e			;	ld a,  display_row_4 
928e			;	ld de, hd_menu4 
928e			;	call str_at_display 
928e			; 
928e			;	; display debug state 
928e			; 
928e			;	ld de, hd_don 
928e			;	ld a, (os_view_disable) 
928e			;	cp 0 
928e			;	jr z, .distog 
928e			;	ld de, hd_doff 
928e			;.distog: ld a, display_row_4+17 
928e			;	call str_at_display 
928e			; 
928e			;	call update_display 
928e			; 
928e			;	call cin_wait 
928e			; 
928e			; 
928e			; 
928e			;	cp '4' 
928e			;	jr nz, .diagn1 
928e			; 
928e			;	; debug toggle 
928e			; 
928e			;	ld a, (os_view_disable) 
928e			;	ld b, '*' 
928e			;	cp 0 
928e			;	jr z, .debtog 
928e			;	ld b, 0 
928e			;.debtog:	 
928e			;	ld a,b 
928e			;	ld (os_view_disable),a 
928e			; 
928e			;.diagn1: cp '0' 
928e			;	 ret z 
928e			; 
928e			;;	cp '1' 
928e			;;       jp z, matrix	 
928e			;;   TODO keyboard matrix test 
928e			; 
928e			;	cp '2' 
928e			;	jp z, .diagedit 
928e			; 
928e			;;	cp '6' 
928e			;;	jp z, .menutest 
928e			;;if ENABLE_BASIC 
928e			;;	cp '6' 
928e			;;	jp z, basic 
928e			;;endif 
928e			 ; 
928e			;	jp .diagmenu 
928e			; 
928e			; 
928e			;	ret 
928e			 
928e			 
928e			.debug_tog: 
928e 21 b7 92			ld hl, .menudebug 
9291				 
9291			;	ld a, (os_view_disable) 
9291			;	cp '*' 
9291 3a 6f ee			ld a,(debug_vector) 
9294 fe c9			cp $C9   ; RET 
9296 20 04			jr nz,.tdon  
9298 3e 01			ld a, 1 
929a 18 02			jr .tog1 
929c 3e 00		.tdon: ld a, 0 
929e			 
929e			.tog1: 
929e cd dc 8a			call menu 
92a1 fe 00			cp 0 
92a3 c8				ret z 
92a4 fe 01			cp 1    ; disable debug 
92a6 28 04			jr z, .dtog0 
92a8 3e 2a			ld a, '*' 
92aa 18 05			jr .dtogset 
92ac			.dtog0:  
92ac				;ld a, 0 
92ac cd 4a 93			call bp_on 
92af 18 dd			jr .debug_tog 
92b1			.dtogset:  
92b1				; ld (os_view_disable), a 
92b1 cd 56 93			call bp_off 
92b4 c3 8e 92			jp .debug_tog 
92b7			 
92b7			 
92b7			.menudebug: 
92b7 bd 92				dw .m6 
92b9 c6 92				dw .m7 
92bb 00 00				dw 0 
92bd .. 00		.m6:   db "Debug ON",0 
92c6 .. 00		.m7:   db "Debug OFF",0 
92d0			;hardware_diags:       
92d0			 
92d0			ENABLE_HDIAGS: equ 0 
92d0			 
92d0			if ENABLE_HDIAGS 
92d0			.diagm: 
92d0				ld hl, .menuitems 
92d0				ld a, 0 
92d0				call menu 
92d0			 
92d0			         cp 0 
92d0				 ret z 
92d0			 
92d0				cp 2 
92d0				jp z, .diagedit 
92d0			 
92d0			;	cp '6' 
92d0			;	jp z, .menutest 
92d0			;if ENABLE_BASIC 
92d0			;	cp '6' 
92d0			;	jp z, basic 
92d0			;endif 
92d0			  
92d0				jp .diagm 
92d0			 
92d0				 
92d0			.menuitems:   	dw .m1 
92d0					dw .m2 
92d0					dw .m3 
92d0					dw .m5 
92d0					dw .m5a 
92d0					dw .m5b 
92d0					dw 0 
92d0			 
92d0			 
92d0			.m1:   db "Key Matrix",0 
92d0			.m2:   db "Editor",0 
92d0			.m3:   db "Storage",0 
92d0			.m5:   db "Sound",0 
92d0			.m5a:  db "RAM Test",0 
92d0			.m5b:  db "LCD Test",0 
92d0			 
92d0			 
92d0			; debug editor 
92d0			 
92d0			.diagedit: 
92d0			 
92d0				ld hl, scratch 
92d0			;	ld bc, 250 
92d0			;	ldir 
92d0				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
92d0			;	ld a, 0 
92d0				ld (hl), 0 
92d0				inc hl 
92d0				ld (hl), 0 
92d0				inc hl 
92d0				ld (hl), 0 
92d0			 
92d0			        call clear_display 
92d0				call update_display 
92d0				;ld a, 1 
92d0				;ld (hardware_diag), a 
92d0			.diloop: 
92d0				ld a, display_row_1 
92d0				ld c, 0 
92d0				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
92d0				ld e, 40 
92d0			 
92d0				ld hl, scratch	 
92d0				call input_str 
92d0			 
92d0				ld a, display_row_2 
92d0				ld de, scratch 
92d0				call str_at_display 
92d0				call update_display 
92d0			 
92d0				jp .diloop 
92d0			endif 
92d0			 
92d0			; pass word in hl 
92d0			; a has display location 
92d0			display_word_at: 
92d0 f5				push af 
92d1 e5				push hl 
92d2 7c				ld a,h 
92d3 21 bd e5			ld hl, os_word_scratch 
92d6 cd d2 8e			call hexout 
92d9 e1				pop hl 
92da 7d				ld a,l 
92db 21 bf e5			ld hl, os_word_scratch+2 
92de cd d2 8e			call hexout 
92e1 21 c1 e5			ld hl, os_word_scratch+4 
92e4			;	ld a,0 
92e4 36 00			ld (hl),0 
92e6 11 bd e5			ld de,os_word_scratch 
92e9 f1				pop af 
92ea cd be 8a				call str_at_display 
92ed c9				ret 
92ee			 
92ee			display_ptr_state: 
92ee			 
92ee				; to restore afterwards 
92ee			 
92ee d5				push de 
92ef c5				push bc 
92f0 e5				push hl 
92f1 f5				push af 
92f2			 
92f2				; for use in here 
92f2			 
92f2			;	push bc 
92f2			;	push de 
92f2			;	push hl 
92f2			;	push af 
92f2			 
92f2 cd ac 8a			call clear_display 
92f5			 
92f5 11 cd 94			ld de, .ptrstate 
92f8 3e 00			ld a, display_row_1 
92fa cd be 8a			call str_at_display 
92fd			 
92fd				; display debug step 
92fd			 
92fd			 
92fd 11 62 ee			ld de, debug_mark 
9300 3e 26			ld a, display_row_1+display_cols-2 
9302 cd be 8a			call str_at_display 
9305			 
9305				; display a 
9305 11 d7 94			ld de, .ptrcliptr 
9308 3e 28			ld a, display_row_2 
930a cd be 8a			call str_at_display 
930d			 
930d f1				pop af 
930e 2a 37 ea			ld hl,(cli_ptr) 
9311 3e 30			ld a, display_row_2+8 
9313 cd d0 92			call display_word_at 
9316			 
9316			 
9316				; display hl 
9316			 
9316			 
9316 11 df 94			ld de, .ptrclioptr 
9319 3e 32			ld a, display_row_2+10 
931b cd be 8a			call str_at_display 
931e			; 
931e			;	pop hl 
931e 3e 35			ld a, display_row_2+13 
9320 2a 35 ea			ld hl,(cli_origptr) 
9323 cd d0 92			call display_word_at 
9326			; 
9326			;	 
9326			;	; display de 
9326			 
9326			;	ld de, .regstatede 
9326			;	ld a, display_row_3 
9326			;	call str_at_display 
9326			 
9326			;	pop de 
9326			;	ld h,d 
9326			;	ld l, e 
9326			;	ld a, display_row_3+3 
9326			;	call display_word_at 
9326			 
9326			 
9326				; display bc 
9326			 
9326			;	ld de, .regstatebc 
9326			;	ld a, display_row_3+10 
9326			;	call str_at_display 
9326			 
9326			;	pop bc 
9326			;	ld h,b 
9326			;	ld l, c 
9326			;	ld a, display_row_3+13 
9326			;	call display_word_at 
9326			 
9326			 
9326				; display dsp 
9326			 
9326			;	ld de, .regstatedsp 
9326			;	ld a, display_row_4 
9326			;	call str_at_display 
9326			 
9326				 
9326			;	ld hl,(cli_data_sp) 
9326			;	ld a, display_row_4+4 
9326			;	call display_word_at 
9326			 
9326				; display rsp 
9326			 
9326 11 0e 95			ld de, .regstatersp 
9329 3e 82			ld a, display_row_4+10 
932b cd be 8a			call str_at_display 
932e			 
932e				 
932e 2a e9 e9			ld hl,(cli_ret_sp) 
9331 3e 86			ld a, display_row_4+14 
9333 cd d0 92			call display_word_at 
9336			 
9336 cd ce 8a			call update_display 
9339			 
9339 cd f0 89			call delay1s 
933c cd f0 89			call delay1s 
933f cd f0 89			call delay1s 
9342			 
9342			 
9342 cd 43 99			call next_page_prompt 
9345			 
9345				; restore  
9345			 
9345 f1				pop af 
9346 e1				pop hl 
9347 c1				pop bc 
9348 d1				pop de 
9349 c9				ret 
934a			 
934a			; Update the break point vector so that the user can hook a new routine 
934a			 
934a			bp_on: 
934a 3e c3			ld a, $c3    ; JP 
934c 32 6f ee			ld (debug_vector), a 
934f 21 5c 93			ld hl, break_point_state 
9352 22 70 ee			ld (debug_vector+1), hl 
9355 c9				ret 
9356			 
9356			bp_off: 
9356 3e c9			ld a, $c9    ; RET 
9358 32 6f ee			ld (debug_vector), a 
935b c9				ret 
935c			 
935c			 
935c			break_point_state: 
935c			;	push af 
935c			; 
935c			;	; see if disabled 
935c			; 
935c			;	ld a, (os_view_disable) 
935c			;	cp '*' 
935c			;	jr nz, .bpsgo 
935c			;	pop af 
935c			;	ret 
935c			 
935c			.bpsgo: 
935c			;	pop af 
935c f5				push af 
935d 22 9a e2			ld (os_view_hl), hl 
9360 ed 53 98 e2		ld (os_view_de), de 
9364 ed 43 96 e2		ld (os_view_bc), bc 
9368 e5				push hl 
9369 6f				ld l, a 
936a 26 00			ld h, 0 
936c 22 9c e2			ld (os_view_af),hl 
936f			 
936f 21 a8 ed				ld hl, display_fb0 
9372 22 c3 eb				ld (display_fb_active), hl 
9375 e1				pop hl	 
9376			 
9376 3e 31			ld a, '1' 
9378 fe 2a		.bps1:  cp '*' 
937a cc 56 93			call z, bp_off 
937d			;	jr nz, .bps1b 
937d			;	ld (os_view_disable),a 
937d fe 31		.bps1b:  cp '1' 
937f 20 14			jr nz, .bps2 
9381			 
9381				; display reg 
9381			 
9381				 
9381			 
9381 3a 9c e2			ld a, (os_view_af) 
9384 2a 9a e2			ld hl, (os_view_hl) 
9387 ed 5b 98 e2		ld de, (os_view_de) 
938b ed 4b 96 e2		ld bc, (os_view_bc) 
938f cd 29 94			call display_reg_state 
9392 c3 15 94			jp .bpschk 
9395			 
9395 fe 32		.bps2:  cp '2' 
9397 20 08			jr nz, .bps3 
9399				 
9399				; display hl 
9399 2a 9a e2			ld hl, (os_view_hl) 
939c cd 13 95			call display_dump_at_hl 
939f			 
939f 18 74			jr .bpschk 
93a1			 
93a1 fe 33		.bps3:  cp '3' 
93a3 20 08			jr nz, .bps4 
93a5			 
93a5			        ; display de 
93a5 2a 98 e2			ld hl, (os_view_de) 
93a8 cd 13 95			call display_dump_at_hl 
93ab			 
93ab 18 68			jr .bpschk 
93ad fe 34		.bps4:  cp '4' 
93af 20 08			jr nz, .bps5 
93b1			 
93b1			        ; display bc 
93b1 2a 96 e2			ld hl, (os_view_bc) 
93b4 cd 13 95			call display_dump_at_hl 
93b7			 
93b7 18 5c			jr .bpschk 
93b9 fe 35		.bps5:  cp '5' 
93bb 20 08		        jr nz, .bps7 
93bd			 
93bd				; display cur ptr 
93bd 2a 37 ea			ld hl, (cli_ptr) 
93c0 cd 13 95			call display_dump_at_hl 
93c3			 
93c3 18 50			jr .bpschk 
93c5 fe 36		.bps7:  cp '6' 
93c7 20 08			jr nz, .bps8b 
93c9				 
93c9				; display cur orig ptr 
93c9 2a 35 ea			ld hl, (cli_origptr) 
93cc cd 13 95			call display_dump_at_hl 
93cf 18 44			jr .bpschk 
93d1 fe 37		.bps8b:  cp '7' 
93d3 20 08			jr nz, .bps9 
93d5				 
93d5				; display dsp 
93d5 2a e5 e9			ld hl, (cli_data_sp) 
93d8 cd 13 95			call display_dump_at_hl 
93db			 
93db 18 38			jr .bpschk 
93dd fe 39		.bps9:  cp '9' 
93df 20 05			jr nz, .bps8c 
93e1				 
93e1				; display SP 
93e1			;	ld hl, sp 
93e1 cd 13 95			call display_dump_at_hl 
93e4			 
93e4 18 2f			jr .bpschk 
93e6 fe 38		.bps8c:  cp '8' 
93e8 20 08			jr nz, .bps8d 
93ea				 
93ea				; display rsp 
93ea 2a e9 e9			ld hl, (cli_ret_sp) 
93ed cd 13 95			call display_dump_at_hl 
93f0			 
93f0 18 23			jr .bpschk 
93f2 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
93f4 20 05			jr nz, .bps8 
93f6 cd 01 97			call monitor 
93f9			 
93f9 18 1a			jr .bpschk 
93fb fe 30		.bps8:  cp '0' 
93fd 20 16			jr nz, .bpschk 
93ff			 
93ff 21 07 ed				ld hl, display_fb1 
9402 22 c3 eb				ld (display_fb_active), hl 
9405 cd ce 8a				call update_display 
9408			 
9408				;ld a, (os_view_af) 
9408 2a 9a e2			ld hl, (os_view_hl) 
940b ed 5b 98 e2		ld de, (os_view_de) 
940f ed 4b 96 e2		ld bc, (os_view_bc) 
9413 f1				pop af 
9414 c9				ret 
9415			 
9415			.bpschk:   
9415 cd f0 89			call delay1s 
9418 3e 9f		ld a,display_row_4 + display_cols - 1 
941a 11 41 99		        ld de, endprg 
941d cd be 8a			call str_at_display 
9420 cd ce 8a			call update_display 
9423 cd 80 e3			call cin_wait 
9426			 
9426 c3 78 93			jp .bps1 
9429			 
9429			 
9429			display_reg_state: 
9429			 
9429				; to restore afterwards 
9429			 
9429 d5				push de 
942a c5				push bc 
942b e5				push hl 
942c f5				push af 
942d			 
942d				; for use in here 
942d			 
942d c5				push bc 
942e d5				push de 
942f e5				push hl 
9430 f5				push af 
9431			 
9431 cd ac 8a			call clear_display 
9434			 
9434 11 e9 94			ld de, .regstate 
9437 3e 00			ld a, display_row_1 
9439 cd be 8a			call str_at_display 
943c			 
943c				; display debug step 
943c			 
943c			 
943c 11 62 ee			ld de, debug_mark 
943f 3e 25			ld a, display_row_1+display_cols-3 
9441 cd be 8a			call str_at_display 
9444			 
9444				; display a 
9444 11 05 95			ld de, .regstatea 
9447 3e 28			ld a, display_row_2 
9449 cd be 8a			call str_at_display 
944c			 
944c e1				pop hl 
944d			;	ld h,0 
944d			;	ld l, a 
944d 3e 2b			ld a, display_row_2+3 
944f cd d0 92			call display_word_at 
9452			 
9452			 
9452				; display hl 
9452			 
9452			 
9452 11 f9 94			ld de, .regstatehl 
9455 3e 32			ld a, display_row_2+10 
9457 cd be 8a			call str_at_display 
945a			 
945a e1				pop hl 
945b 3e 35			ld a, display_row_2+13 
945d cd d0 92			call display_word_at 
9460			 
9460				 
9460				; display de 
9460			 
9460 11 fd 94			ld de, .regstatede 
9463 3e 50			ld a, display_row_3 
9465 cd be 8a			call str_at_display 
9468			 
9468 e1				pop hl 
9469			;	ld h,d 
9469			;	ld l, e 
9469 3e 53			ld a, display_row_3+3 
946b cd d0 92			call display_word_at 
946e			 
946e			 
946e				; display bc 
946e			 
946e 11 01 95			ld de, .regstatebc 
9471 3e 5a			ld a, display_row_3+10 
9473 cd be 8a			call str_at_display 
9476			 
9476 e1				pop hl 
9477			;	ld h,b 
9477			;	ld l, c 
9477 3e 5d			ld a, display_row_3+13 
9479 cd d0 92			call display_word_at 
947c			 
947c			 
947c				; display dsp 
947c			 
947c 11 09 95			ld de, .regstatedsp 
947f 3e 78			ld a, display_row_4 
9481 cd be 8a			call str_at_display 
9484			 
9484				 
9484 2a e5 e9			ld hl,(cli_data_sp) 
9487 3e 7c			ld a, display_row_4+4 
9489 cd d0 92			call display_word_at 
948c			 
948c				; display rsp 
948c			 
948c 11 0e 95			ld de, .regstatersp 
948f 3e 82			ld a, display_row_4+10 
9491 cd be 8a			call str_at_display 
9494			 
9494				 
9494 2a e9 e9			ld hl,(cli_ret_sp) 
9497 3e 86			ld a, display_row_4+14 
9499 cd d0 92			call display_word_at 
949c			 
949c cd ce 8a			call update_display 
949f			 
949f			;	call delay1s 
949f			;	call delay1s 
949f			;	call delay1s 
949f			 
949f			 
949f			;	call next_page_prompt 
949f			 
949f				; restore  
949f			 
949f f1				pop af 
94a0 e1				pop hl 
94a1 c1				pop bc 
94a2 d1				pop de 
94a3 c9				ret 
94a4			 
94a4 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
94b8 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
94cd .. 00		.ptrstate:	db "Ptr State",0 
94d7 .. 00		.ptrcliptr:     db "cli_ptr",0 
94df .. 00		.ptrclioptr:     db "cli_o_ptr",0 
94e9 .. 00		.regstate:	db "Reg State (1/0)",0 
94f9 .. 00		.regstatehl:	db "HL:",0 
94fd .. 00		.regstatede:	db "DE:",0 
9501 .. 00		.regstatebc:	db "BC:",0 
9505 .. 00		.regstatea:	db "A :",0 
9509 .. 00		.regstatedsp:	db "DSP:",0 
950e .. 00		.regstatersp:	db "RSP:",0 
9513			 
9513			display_dump_at_hl: 
9513 e5				push hl 
9514 d5				push de 
9515 c5				push bc 
9516 f5				push af 
9517			 
9517 22 db e5			ld (os_cur_ptr),hl	 
951a cd ac 8a			call clear_display 
951d cd 4f 98			call dumpcont 
9520			;	call delay1s 
9520			;	call next_page_prompt 
9520			 
9520			 
9520 f1				pop af 
9521 c1				pop bc 
9522 d1				pop de 
9523 e1				pop hl 
9524 c9				ret 
9525			 
9525			;if ENABLE_BASIC 
9525			;	include "nascombasic.asm" 
9525			;	basic: 
9525			;	include "forth/FORTH.ASM" 
9525			;endif 
9525			 
9525			; eof 
9525			 
9525			 
# End of file firmware_diags.asm
9525			  
9525			include "firmware_prompts.asm"  
9525			; Prompts  
9525			 
9525			; boot messages 
9525			 
9525 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
953a .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
954a			 
954a			 
954a			; config menus 
954a			 
954a			;prom_c3: db "Add Dictionary To File",0 
954a			 
954a			if STARTUP_V1 
954a .. 00		prom_c2: db "Select Autoload File",0 
955f .. 00		prom_c2a: db "Disable Autoload File", 0 
9575			endif 
9575			 
9575			if STARTUP_V2 
9575			prom_c2: db "Enable Autoload Files",0 
9575			prom_c2a: db "Disable Autoload Files", 0 
9575			 
9575			crs_s1: db "*ls-word", 0 
9575			crs_s2: db "*ed-word", 0 
9575			crs_s3: db "*Demo-Games", 0 
9575			crs_s4: db "*Utils", 0 
9575			crs_s5: db "*SPI-Util", 0 
9575			crs_s6: db "*Key-Constants", 0 
9575			crs_sound: db "*Sound-Util", 0 
9575			crs_hw: db "*Hello-World",0 
9575			 
9575			 
9575			 
9575			endif 
9575			;prom_c2b: db "Select Storage Bank",0 
9575 .. 00		prom_c4: db "Settings",0 
957e .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9599 .. 00		prom_m4b:   db "Monitor",0 
95a1			;prom_c1: db "Hardware Diags",0 
95a1			 
95a1			 
95a1			if STARTUP_V2 
95a1			prom_c9: db "Create Startup Files",0 
95a1			endif 
95a1			 
95a1 .. 00		prom_notav:    db "Feature not available",0 
95b7 .. 00		prom_empty:    db "",0 
95b8			 
95b8			; eof 
95b8			 
# End of file firmware_prompts.asm
95b8			  
95b8			; eof  
95b8			  
# End of file firmware.asm
95b8			 
95b8			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
95b8			;if BASE_KEV  
95b8			;baseram: equ 08000h 
95b8			;endif 
95b8			 
95b8			;if BASE_SC114 
95b8			;baseram:     equ    endofcode 
95b8			;endif 
95b8			 
95b8			 
95b8			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
95b8			 
95b8			; start system 
95b8			 
95b8			coldstart: 
95b8				; set sp 
95b8				; di/ei 
95b8			 
95b8 f3				di 
95b9 31 00 f0			ld sp, tos 
95bc cd ca e2			call init_nmi 
95bf			;	ei 
95bf			 
95bf				; init spinner 
95bf 3e 00			ld a,0 
95c1 32 bd eb			ld (display_active), a 
95c4			 
95c4				; disable breakpoint by default 
95c4			 
95c4				;ld a,'*' 
95c4			;	ld a,' ' 
95c4			;	ld (os_view_disable),a 
95c4			 
95c4				; set break point vector as new break point on or off 
95c4 cd 56 93			call bp_off 
95c7			 
95c7			 
95c7				; default the parse vector to just a RET 
95c7 3e c9			ld a, $c9 
95c9 32 6c ee			ld (parse_vector), a 
95cc			 
95cc				; init hardware 
95cc			 
95cc				; init keyboard and screen hardware 
95cc			 
95cc cd 1f 80			call hardware_init 
95cf			 
95cf			 
95cf cd f0 89			call delay1s 
95d2 3e 58			ld a, display_row_3+8 
95d4 11 03 80			ld de, buildtime 
95d7 cd be 8a			call str_at_display 
95da cd ce 8a			call update_display 
95dd			 
95dd cd f0 89			call delay1s 
95e0 cd f0 89			call delay1s 
95e3 cd f0 89			call delay1s 
95e6			 
95e6				; detect if any keys are held down to enable breakpoints at start up 
95e6			 
95e6 cd 86 e3			call cin  
95e9 fe 00			cp 0 
95eb 28 03			jr z, .nokeys 
95ed			 
95ed				;call hardware_diags 
95ed cd 3b 92			call config 
95f0			 
95f0			;	ld de, .bpen 
95f0			;	ld a, display_row_4 
95f0			;	call str_at_display 
95f0			;	call update_display 
95f0			; 
95f0			;	ld a,0 
95f0			;	ld (os_view_disable),a 
95f0			; 
95f0			;.bpwait: 
95f0			;	call cin 
95f0			;	cp 0 
95f0			;	jr z, .bpwait 
95f0			;	jr .nokeys 
95f0			; 
95f0			; 
95f0			;.bpen:  db "Break points enabled!",0 
95f0			 
95f0			 
95f0			 
95f0			 
95f0			 
95f0			 
95f0			.nokeys: 
95f0			 
95f0			 
95f0				 
95f0			 
95f0			;jp  testkey 
95f0			 
95f0			;call storage_get_block_0 
95f0			; 
95f0			;ld hl, 0 
95f0			;ld de, store_page 
95f0			;call storage_read_block 
95f0			 
95f0				 
95f0			;ld hl, 10 
95f0			;ld de, store_page 
95f0			;call storage_read_block 
95f0			 
95f0			 
95f0			 
95f0			 
95f0			 
95f0			;stop:	nop 
95f0			;	jp stop 
95f0			 
95f0			 
95f0			 
95f0			main: 
95f0 cd ac 8a			call clear_display 
95f3 cd ce 8a			call update_display 
95f6			 
95f6			 
95f6			 
95f6			;	call testlcd 
95f6			 
95f6			 
95f6			 
95f6 cd 7e 9d			call forth_init 
95f9			 
95f9			 
95f9			warmstart: 
95f9 cd 54 9d			call forth_warmstart 
95fc			 
95fc				; run startup word load 
95fc			        ; TODO prevent this running at warmstart after crash  
95fc			 
95fc				if STARTUP_ENABLE 
95fc			 
95fc					if STARTUP_V1 
95fc			 
95fc						if STORAGE_SE 
95fc							call forth_autoload 
95fc						endif 
95fc cd 1a e2					call forth_startup 
95ff					endif 
95ff			 
95ff					if STARTUP_V2 
95ff			 
95ff						if STORAGE_SE 
95ff							call forth_autoload 
95ff						else 
95ff							call forth_startup 
95ff						endif 
95ff			 
95ff			 
95ff					endif 
95ff			 
95ff				endif 
95ff			 
95ff			warmstart_afterauto: 
95ff			 
95ff				; show free memory after boot 
95ff 11 9c 96			ld de, freeram 
9602 3e 00			ld a, display_row_1 
9604 cd be 8a			call str_at_display 
9607			 
9607				; get current heap start after loading any uwords 
9607			 
9607				;ld de, (os_last_new_uword) 
9607				;ex de, hl 
9607			 
9607			; Or use heap_size word???? 
9607				;ld hl, heap_end 
9607				;ld hl, heap_size 
9607				;ld de, topusermem 
9607				;ld de, heap_start 
9607 ed 5b 9f e3			ld de, (free_list )      
960b 21 93 e2				ld hl, heap_end 
960e ed 52			sbc hl, de 
9610				;push hl 
9610				;ld a,h	         	 
9610				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9610				;call hexout 
9610			   	;pop hl 
9610			; 
9610			;	ld a,l 
9610			;	ld hl, os_word_scratch+2 
9610			;	call hexout 
9610			;	ld hl, os_word_scratch+4 
9610			;	ld a, 0 
9610			;	ld (hl),a 
9610 eb				ex de, hl 
9611 21 bd e5			ld hl, os_word_scratch 
9614 cd dd 8f			call uitoa_16 
9617			 
9617			 
9617 11 bd e5			ld de, os_word_scratch 
961a 3e 0d			ld a, display_row_1 + 13 
961c cd be 8a			call str_at_display 
961f cd ce 8a			call update_display 
9622			 
9622			 
9622				;call demo 
9622			 
9622			 
9622				; init scratch input area for cli commands 
9622			 
9622 21 df e5			ld hl, os_cli_cmd 
9625			;	ld a,0 
9625 36 00			ld (hl),0 
9627 23				inc hl 
9628 36 00			ld (hl),0 
962a			 
962a 3e 00			ld a,0 
962c 32 de e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
962f			 
962f 32 db e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
9632 32 dc e5			ld (os_cur_ptr+1),a	 
9635			 
9635 32 bd e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9638 32 be e5			ld (os_word_scratch+1),a	 
963b				 
963b			 
963b				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
963b 21 df e5			ld hl, os_cli_cmd 
963e			 
963e			;	ld a, 0		 ; init cli input 
963e 36 00			ld (hl), 0 
9640 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9642			cli: 
9642				; show cli prompt 
9642				;push af 
9642				;ld a, 0 
9642				;ld de, prompt 
9642				;call str_at_display 
9642			 
9642				;call update_display 
9642				;pop af 
9642				;inc a 
9642				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9642			 
9642			.lastrecall: 
9642			 
9642 0e 00			ld c, 0 
9644 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9646 1e 28			ld e, 40 
9648			 
9648 21 df e5			ld hl, os_cli_cmd 
964b			 
964b				STACKFRAME OFF $fefe $9f9f 
964b				if DEBUG_STACK_IMB 
964b					if OFF 
964b						exx 
964b						ld de, $fefe 
964b						ld a, d 
964b						ld hl, curframe 
964b						call hexout 
964b						ld a, e 
964b						ld hl, curframe+2 
964b						call hexout 
964b						ld hl, $fefe 
964b						push hl 
964b						ld hl, $9f9f 
964b						push hl 
964b						exx 
964b					endif 
964b				endif 
964b			endm 
# End of macro STACKFRAME
964b			 
964b cd 03 8d			call input_str 
964e			 
964e				STACKFRAMECHK OFF $fefe $9f9f 
964e				if DEBUG_STACK_IMB 
964e					if OFF 
964e						exx 
964e						ld hl, $9f9f 
964e						pop de   ; $9f9f 
964e						call cmp16 
964e						jr nz, .spnosame 
964e						ld hl, $fefe 
964e						pop de   ; $fefe 
964e						call cmp16 
964e						jr z, .spfrsame 
964e						.spnosame: call showsperror 
964e						.spfrsame: nop 
964e						exx 
964e					endif 
964e				endif 
964e			endm 
# End of macro STACKFRAMECHK
964e			 
964e			 
964e				; check to see if last line recall has been requested 
964e			 
964e			if EDIT_V2 
964e fe 05			cp KEY_UP 
9650 20 0f			jr nz, .noexecline 
9652			 
9652 11 df e5			ld de, os_cli_cmd 
9655 21 de e6			ld hl, os_last_cmd 
9658 01 ff 00			ld bc, 255 
965b ed b0			ldir 
965d 3e 00			ld a, 0 
965f 18 e1			jr .lastrecall 
9661			endif 
9661			 
9661			.noexecline: 
9661				; no so exec the line		 
9661			 
9661				; copy input to last command 
9661			 
9661 21 df e5			ld hl, os_cli_cmd 
9664 11 de e6			ld de, os_last_cmd 
9667 01 ff 00			ld bc, 255 
966a ed b0			ldir 
966c			 
966c				; wipe current buffer 
966c			 
966c			;	ld a, 0 
966c			;	ld hl, os_cli_cmd 
966c			;	ld de, os_cli_cmd+1 
966c			;	ld bc, 254 
966c			;	ldir 
966c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
966c			;	call strcpy 
966c			;	ld a, 0 
966c			;	ld (hl), a 
966c			;	inc hl 
966c			;	ld (hl), a 
966c			;	inc hl 
966c			;	ld (hl), a 
966c			 
966c				; switch frame buffer to program  
966c			 
966c 21 07 ed				ld hl, display_fb1 
966f 22 c3 eb				ld (display_fb_active), hl 
9672			 
9672			;	nop 
9672				STACKFRAME ON $fbfe $8f9f 
9672				if DEBUG_STACK_IMB 
9672					if ON 
9672						exx 
9672						ld de, $fbfe 
9672						ld a, d 
9672						ld hl, curframe 
9672						call hexout 
9672						ld a, e 
9672						ld hl, curframe+2 
9672						call hexout 
9672						ld hl, $fbfe 
9672						push hl 
9672						ld hl, $8f9f 
9672						push hl 
9672						exx 
9672					endif 
9672				endif 
9672			endm 
# End of macro STACKFRAME
9672				; first time into the parser so pass over the current scratch pad 
9672 21 df e5			ld hl,os_cli_cmd 
9675				; tokenise the entered statement(s) in HL 
9675 cd f4 9d			call forthparse 
9678			        ; exec forth statements in top of return stack 
9678 cd 2c 9e			call forthexec 
967b				;call forthexec_cleanup 
967b			;	call parsenext 
967b			 
967b				STACKFRAMECHK ON $fbfe $8f9f 
967b				if DEBUG_STACK_IMB 
967b					if ON 
967b						exx 
967b						ld hl, $8f9f 
967b						pop de   ; $8f9f 
967b						call cmp16 
967b						jr nz, .spnosame 
967b						ld hl, $fbfe 
967b						pop de   ; $fbfe 
967b						call cmp16 
967b						jr z, .spfrsame 
967b						.spnosame: call showsperror 
967b						.spfrsame: nop 
967b						exx 
967b					endif 
967b				endif 
967b			endm 
# End of macro STACKFRAMECHK
967b				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
967b			 
967b 3e 78			ld a, display_row_4 
967d 11 ad 96			ld de, endprog 
9680			 
9680 cd ce 8a			call update_display		 
9683			 
9683 cd 43 99			call next_page_prompt 
9686			 
9686				; switch frame buffer to cli 
9686			 
9686 21 a8 ed				ld hl, display_fb0 
9689 22 c3 eb				ld (display_fb_active), hl 
968c			 
968c			 
968c cd ac 8a		        call clear_display 
968f cd ce 8a			call update_display		 
9692			 
9692 21 df e5			ld hl, os_cli_cmd 
9695			 
9695			;	ld a, 0		 ; init cli input 
9695 36 00			ld (hl), 0 
9697			 
9697				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9697			 
9697				; now on last line 
9697			 
9697				; TODO scroll screen up 
9697			 
9697				; TODO instead just clear screen and place at top of screen 
9697			 
9697			;	ld a, 0 
9697			;	ld (f_cursor_ptr),a 
9697			 
9697				;call clear_display 
9697				;call update_display 
9697			 
9697				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9697 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9699 c3 42 96			jp cli 
969c			 
969c .. 00		freeram: db "Free bytes: ",0 
96a9 ..			asc: db "1A2F" 
96ad .. 00		endprog: db "End prog...",0 
96b9			 
96b9			testenter2:   
96b9 21 ea e2			ld hl,scratch+50 
96bc 22 db e5			ld (os_cur_ptr),hl 
96bf c3 42 96			jp cli 
96c2			 
96c2			testenter:  
96c2			 
96c2 21 a9 96			ld hl,asc 
96c5			;	ld a,(hl) 
96c5			;	call nibble2val 
96c5 cd 28 8f			call get_byte 
96c8			 
96c8			 
96c8			;	ld a,(hl) 
96c8			;	call atohex 
96c8			 
96c8			;	call fourehexhl 
96c8 32 ea e2			ld (scratch+50),a 
96cb			 
96cb			 
96cb			 
96cb 21 ab 96			ld hl,asc+2 
96ce			;	ld a, (hl) 
96ce			;	call nibble2val 
96ce cd 28 8f			call get_byte 
96d1			 
96d1			;	call fourehexhl 
96d1 32 ec e2			ld (scratch+52),a 
96d4				 
96d4 21 ea e2			ld hl,scratch+50 
96d7 22 db e5			ld (os_cur_ptr),hl 
96da c3 42 96			jp cli 
96dd			 
96dd			enter:	 
96dd 3a bc e2			ld a,(scratch+4) 
96e0 fe 00			cp 0 
96e2 28 0c			jr z, .entercont 
96e4				; no, not a null term line so has an address to work out.... 
96e4			 
96e4 21 ba e2			ld hl,scratch+2 
96e7 cd 88 8f			call get_word_hl 
96ea			 
96ea 22 db e5			ld (os_cur_ptr),hl	 
96ed c3 42 96			jp cli 
96f0			 
96f0			 
96f0			.entercont:  
96f0			 
96f0 21 ba e2			ld hl, scratch+2 
96f3 cd 28 8f			call get_byte 
96f6			 
96f6 2a db e5		   	ld hl,(os_cur_ptr) 
96f9 77					ld (hl),a 
96fa 23					inc hl 
96fb 22 db e5				ld (os_cur_ptr),hl 
96fe				 
96fe			; get byte  
96fe			 
96fe			 
96fe c3 42 96			jp cli 
9701			 
9701			 
9701			; basic monitor support 
9701			 
9701			monitor: 
9701				;  
9701 cd ac 8a			call clear_display 
9704 3e 00			ld a, 0 
9706 11 5a 97			ld de, .monprompt 
9709 cd be 8a			call str_at_display 
970c cd ce 8a			call update_display 
970f			 
970f				; get a monitor command 
970f			 
970f 0e 00			ld c, 0     ; entry at top left 
9711 16 64			ld d, 100   ; max buffer size 
9713 1e 0f			ld e, 15    ; input scroll area 
9715			;	ld a, 0     ; init string 
9715 21 b6 e4			ld hl, os_input 
9718 36 00			ld (hl), 0 
971a 23				inc hl 
971b 36 00			ld (hl), 0 
971d 21 b6 e4			ld hl, os_input 
9720 3e 01			ld a, 1     ; init string 
9722 cd 03 8d			call input_str 
9725			 
9725 cd ac 8a		        call clear_display 
9728 cd ce 8a			call update_display		 
972b			 
972b 3a b6 e4			ld a, (os_input) 
972e cd 25 90			call toUpper 
9731 fe 48		        cp 'H' 
9733 ca ce 97		        jp z, .monhelp 
9736 fe 44			cp 'D'		; dump 
9738 ca 01 98			jp z, .mondump	 
973b fe 43			cp 'C'		; dump 
973d ca 1b 98			jp z, .moncdump	 
9740 fe 4d			cp 'M'		; dump 
9742 ca 5c 97			jp z, .moneditstart 
9745 fe 55			cp 'U'		; dump 
9747 ca 68 97			jp z, .monedit	 
974a fe 47			cp 'G'		; dump 
974c ca f7 97			jp z, .monjump 
974f fe 42			cp 'B'		; forth breakpoint 
9751 cc 5c 93			call z, break_point_state 
9754 fe 51			cp 'Q'		; dump 
9756 c8				ret z	 
9757			 
9757			 
9757				; TODO "S" to access symbol by name and not need the address 
9757				; TODO "F" to find a string in memory 
9757			 
9757 c3 01 97			jp monitor 
975a			 
975a .. 00		.monprompt: db ">", 0 
975c			 
975c			.moneditstart: 
975c				; get starting address 
975c			 
975c 21 b8 e4			ld hl,os_input+2 
975f cd 88 8f			call get_word_hl 
9762			 
9762 22 db e5			ld (os_cur_ptr),hl	 
9765			 
9765 c3 01 97			jp monitor 
9768			 
9768			.monedit: 
9768				; get byte to load 
9768			 
9768 21 b8 e4			ld hl,os_input+2 
976b cd 28 8f			call get_byte 
976e			 
976e				; get address to update 
976e 2a db e5			ld hl, (os_cur_ptr) 
9771			 
9771				; update byte 
9771			 
9771 77				ld (hl), a 
9772			 
9772				; move to next address and save it 
9772			 
9772 23				inc hl 
9773 22 db e5			ld (os_cur_ptr),hl	 
9776			 
9776 c3 01 97			jp monitor 
9779			 
9779			 
9779 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
978d .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
97a9 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
97c7 .. 00		.monhelptext4:  db "Q-Quit",0 
97ce			        
97ce			.monhelp: 
97ce 3e 00			ld a, display_row_1 
97d0 11 79 97		        ld de, .monhelptext1 
97d3			 
97d3 cd be 8a			call str_at_display 
97d6 3e 28			ld a, display_row_2 
97d8 11 8d 97		        ld de, .monhelptext2 
97db					 
97db cd be 8a			call str_at_display 
97de 3e 50			ld a, display_row_3 
97e0 11 a9 97		        ld de, .monhelptext3 
97e3					 
97e3 cd be 8a			call str_at_display 
97e6 3e 78			ld a, display_row_4 
97e8 11 c7 97		        ld de, .monhelptext4 
97eb cd be 8a			call str_at_display 
97ee			 
97ee cd ce 8a			call update_display		 
97f1			 
97f1 cd 43 99			call next_page_prompt 
97f4 c3 01 97			jp monitor 
97f7			 
97f7			.monjump:    
97f7 21 b8 e4			ld hl,os_input+2 
97fa cd 88 8f			call get_word_hl 
97fd			 
97fd e9				jp (hl) 
97fe c3 01 97			jp monitor 
9801			 
9801			.mondump:    
9801 21 b8 e4			ld hl,os_input+2 
9804 cd 88 8f			call get_word_hl 
9807			 
9807 22 db e5			ld (os_cur_ptr),hl	 
980a cd 4f 98			call dumpcont 
980d 3e 78			ld a, display_row_4 
980f 11 ad 96			ld de, endprog 
9812			 
9812 cd ce 8a			call update_display		 
9815			 
9815 cd 43 99			call next_page_prompt 
9818 c3 01 97			jp monitor 
981b			.moncdump: 
981b cd 4f 98			call dumpcont 
981e 3e 78			ld a, display_row_4 
9820 11 ad 96			ld de, endprog 
9823			 
9823 cd ce 8a			call update_display		 
9826			 
9826 cd 43 99			call next_page_prompt 
9829 c3 01 97			jp monitor 
982c			 
982c			 
982c			; TODO symbol access  
982c			 
982c			.symbols:     ;; A list of symbols that can be called up  
982c a8 ed			dw display_fb0 
982e .. 00			db "fb0",0  
9832 71 ea		     	dw store_page 
9834 .. 00			db "store_page",0 
983f			 
983f			 
983f			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
983f			 
983f 3a b9 e2			ld a,(scratch+1) 
9842 fe 00			cp 0 
9844 28 09			jr z, dumpcont 
9846			 
9846				; no, not a null term line so has an address to work out.... 
9846			 
9846 21 ba e2			ld hl,scratch+2 
9849 cd 88 8f			call get_word_hl 
984c			 
984c 22 db e5			ld (os_cur_ptr),hl	 
984f			 
984f			 
984f			 
984f			dumpcont: 
984f			 
984f				; dump bytes at ptr 
984f			 
984f			 
984f 3e 00			ld a, display_row_1 
9851 2a c3 eb			ld hl, (display_fb_active) 
9854 cd d6 8c			call addatohl 
9857 cd 7f 98			call .dumpbyterow 
985a			 
985a 3e 28			ld a, display_row_2 
985c 2a c3 eb			ld hl, (display_fb_active) 
985f cd d6 8c			call addatohl 
9862 cd 7f 98			call .dumpbyterow 
9865			 
9865			 
9865 3e 50			ld a, display_row_3 
9867 2a c3 eb			ld hl, (display_fb_active) 
986a cd d6 8c			call addatohl 
986d cd 7f 98			call .dumpbyterow 
9870			 
9870 3e 78			ld a, display_row_4 
9872 2a c3 eb			ld hl, (display_fb_active) 
9875 cd d6 8c			call addatohl 
9878 cd 7f 98			call .dumpbyterow 
987b			 
987b cd ce 8a			call update_display 
987e			;		jp cli 
987e c9				ret 
987f			 
987f			.dumpbyterow: 
987f			 
987f				;push af 
987f			 
987f e5				push hl 
9880			 
9880				; calc where to poke the ascii 
9880			if display_cols == 20 
9880				ld a, 16 
9880			else 
9880 3e 1f			ld a, 31 
9882			endif 
9882			 
9882 cd d6 8c			call addatohl 
9885 22 bd e5			ld (os_word_scratch),hl  		; save pos for later 
9888			 
9888			 
9888			; display decoding address 
9888 2a db e5		   	ld hl,(os_cur_ptr) 
988b			 
988b 7c				ld a,h 
988c e1				pop hl 
988d e5				push hl 
988e			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
988e cd d2 8e			call hexout 
9891 2a db e5		   	ld hl,(os_cur_ptr) 
9894			 
9894 7d				ld a,l 
9895 e1				pop hl 
9896 23				inc hl 
9897 23				inc hl 
9898 e5				push hl 
9899			;	ld hl, os_word_scratch+2 
9899 cd d2 8e			call hexout 
989c e1				pop hl 
989d 23				inc hl 
989e 23				inc hl 
989f				;ld hl, os_word_scratch+4 
989f			;	ld a, ':' 
989f 36 3a			ld (hl),':' 
98a1 23				inc hl 
98a2				;ld a, 0 
98a2				;ld (hl),a 
98a2				;ld de, os_word_scratch 
98a2				;pop af 
98a2				;push af 
98a2			;		ld a, display_row_2 
98a2			;		call str_at_display 
98a2			;		call update_display 
98a2			 
98a2			 
98a2			;pop af 
98a2			;	add 5 
98a2			 
98a2			if display_cols == 20 
98a2				ld b, 4 
98a2			else 
98a2 06 08			ld b, 8 
98a4			endif	 
98a4			 
98a4			.dumpbyte: 
98a4 c5				push bc 
98a5 e5				push hl 
98a6			 
98a6			 
98a6 2a db e5		   	ld hl,(os_cur_ptr) 
98a9 7e					ld a,(hl) 
98aa			 
98aa					; poke the ascii to display 
98aa 2a bd e5				ld hl,(os_word_scratch) 
98ad 77					ld (hl),a 
98ae 23					inc hl 
98af 22 bd e5				ld (os_word_scratch),hl 
98b2			 
98b2					 
98b2			 
98b2			 
98b2 e1					pop hl 
98b3 e5					push hl 
98b4			 
98b4 cd d2 8e				call hexout 
98b7			 
98b7					 
98b7 2a db e5		   	ld hl,(os_cur_ptr) 
98ba 23				inc hl 
98bb 22 db e5		   	ld (os_cur_ptr),hl 
98be			 
98be e1					pop hl 
98bf 23					inc hl 
98c0 23					inc hl 
98c1 23					inc hl 
98c2			 
98c2			 
98c2			 
98c2					;ld a,0 
98c2					;ld (os_word_scratch+2),a 
98c2					;pop af 
98c2					;push af 
98c2			 
98c2					;ld de, os_word_scratch 
98c2					;call str_at_display 
98c2			;		call update_display 
98c2			;		pop af 
98c2 c1					pop bc 
98c3 c6 03				add 3 
98c5 10 dd			djnz .dumpbyte 
98c7			 
98c7				 
98c7			 
98c7 c9				ret 
98c8			 
98c8			jump:	 
98c8			 
98c8 21 ba e2			ld hl,scratch+2 
98cb cd 88 8f			call get_word_hl 
98ce				;ld hl,(scratch+2) 
98ce				;call fourehexhl 
98ce			 
98ce 22 db e5			ld (os_cur_ptr),hl	 
98d1			 
98d1 e9				jp (hl) 
98d2			 
98d2			 
98d2			 
98d2			; TODO implement a basic monitor mode to start with 
98d2			 
98d2			 
98d2			 
98d2			 
98d2			 
98d2			 
98d2			 
98d2			 
98d2			 
98d2			; testing and demo code during development 
98d2			 
98d2			 
98d2 .. 00		str1: db "Enter some text...",0 
98e5 .. 00		clear: db "                    ",0 
98fa			 
98fa			demo: 
98fa			 
98fa			 
98fa			 
98fa			;	call update_display 
98fa			 
98fa				; init scratch input area for testing 
98fa 21 b8 e2			ld hl, scratch	 
98fd			;	ld a,0 
98fd 36 00			ld (hl),0 
98ff			 
98ff			 
98ff 3e 28		            LD   A, display_row_2 
9901			;            CALL fLCD_Pos       ;Position cursor to location in A 
9901 11 d2 98		            LD   DE, str1 
9904 cd be 8a			call str_at_display 
9907			 
9907			;            CALL fLCD_Str       ;Display string pointed to by DE 
9907			cloop:	 
9907 3e 50		            LD   A, display_row_3 
9909			;            CALL fLCD_Pos       ;Position cursor to location in A 
9909 11 e5 98		            LD   DE, clear 
990c			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
990c cd be 8a				call str_at_display 
990f 3e 78			ld a, display_row_4 
9911 11 3f 99			ld de, prompt 
9914			 
9914 cd be 8a				call str_at_display 
9917 cd ce 8a			call update_display 
991a			 
991a 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
991c 16 0a			ld d, 10 
991e 21 b8 e2			ld hl, scratch	 
9921 cd 03 8d			call input_str 
9924			 
9924			;	call clear_display 
9924			;'	call update_display 
9924			 
9924 3e 00		            LD   A, display_row_1 
9926			;            CALL fLCD_Pos       ;Position cursor to location in A 
9926 11 e5 98		            LD   DE, clear 
9929 cd be 8a				call str_at_display 
992c			;            CALL fLCD_Str       ;Display string pointed to by DE 
992c 3e 00		            LD   A, display_row_1 
992e			;            CALL fLCD_Pos       ;Position cursor to location in A 
992e 11 b8 e2		            LD   DE, scratch 
9931			;            CALL fLCD_Str       ;Display string pointed to by DE 
9931 cd be 8a				call str_at_display 
9934 cd ce 8a			call update_display 
9937			 
9937			;		ld a,0 
9937 21 b8 e2			ld hl, scratch 
993a 36 00			ld (hl),0 
993c			 
993c			;	nop 
993c c3 07 99			jp cloop 
993f			 
993f			 
993f			 
993f			; OS Prompt 
993f			 
993f .. 00		prompt: db ">",0 
9941 .. 00		endprg: db "?",0 
9943			 
9943			 
9943			; handy next page prompt 
9943			next_page_prompt: 
9943 e5				push hl 
9944 d5				push de 
9945 f5				push af 
9946 c5				push bc 
9947			 
9947 3e 9f			ld a,display_row_4 + display_cols - 1 
9949 11 41 99		        ld de, endprg 
994c cd be 8a			call str_at_display 
994f cd ce 8a			call update_display 
9952 cd 80 e3			call cin_wait 
9955 c1				pop bc 
9956 f1				pop af 
9957 d1				pop de 
9958 e1				pop hl 
9959			 
9959			 
9959 c9				ret 
995a			 
995a			 
995a			; forth parser 
995a			 
995a			; My forth kernel 
995a			include "forth_kernel.asm" 
995a			; 
995a			; kernel to the forth OS 
995a			 
995a			DS_TYPE_STR: equ 1     ; string type 
995a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
995a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
995a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
995a			 
995a			FORTH_PARSEV1: equ 0 
995a			FORTH_PARSEV2: equ 0 
995a			FORTH_PARSEV3: equ 0 
995a			FORTH_PARSEV4: equ 0 
995a			FORTH_PARSEV5: equ 0 
995a			FORTH_PARSEV6: equ 1 
995a			 
995a			;if FORTH_PARSEV5 
995a			;	FORTH_END_BUFFER: equ 0 
995a			;else 
995a			FORTH_END_BUFFER: equ 127 
995a			;endif 
995a			 
995a			FORTH_TRUE: equ 1 
995a			FORTH_FALSE: equ 0 
995a			 
995a			if FORTH_PARSEV4 
995a			include "forth_stackops.asm" 
995a			endif 
995a			 
995a			if FORTH_PARSEV5 
995a			include "forth_stackopsv5.asm" 
995a			endif 
995a			 
995a			if FORTH_PARSEV6 
995a			include "forth_stackopsv5.asm" 
995a			 
995a			; Stack operations for v5 parser on wards 
995a			; * DATA stack 
995a			; * LOOP stack 
995a			; * RETURN stack 
995a			 
995a			 
995a			 
995a			FORTH_CHK_DSP_UNDER: macro 
995a				push hl 
995a				push de 
995a				ld hl,(cli_data_sp) 
995a				ld de, cli_data_stack 
995a				call cmp16 
995a				jp c, fault_dsp_under 
995a				pop de 
995a				pop hl 
995a				endm 
995a			 
995a			 
995a			FORTH_CHK_RSP_UNDER: macro 
995a				push hl 
995a				push de 
995a				ld hl,(cli_ret_sp) 
995a				ld de, cli_ret_stack 
995a				call cmp16 
995a				jp c, fault_rsp_under 
995a				pop de 
995a				pop hl 
995a				endm 
995a			 
995a			FORTH_CHK_LOOP_UNDER: macro 
995a				push hl 
995a				push de 
995a				ld hl,(cli_loop_sp) 
995a				ld de, cli_loop_stack 
995a				call cmp16 
995a				jp c, fault_loop_under 
995a				pop de 
995a				pop hl 
995a				endm 
995a			 
995a			FORTH_ERR_TOS_NOTSTR: macro 
995a				; TOSO might need more for checks when used 
995a				push af 
995a				ld a,(hl) 
995a				cp DS_TYPE_STR 
995a				jp nz, type_faultn   
995a				pop af 
995a				endm 
995a			 
995a			FORTH_ERR_TOS_NOTNUM: macro 
995a				push af 
995a				ld a,(hl) 
995a				cp DS_TYPE_INUM 
995a				jp nz, type_faultn   
995a				pop af 
995a				endm 
995a			 
995a			 
995a			; increase data stack pointer and save hl to it 
995a				 
995a			FORTH_DSP_NEXT: macro 
995a				call macro_forth_dsp_next 
995a				endm 
995a			 
995a			 
995a			macro_forth_dsp_next: 
995a				if DEBUG_FORTH_STACK_GUARD 
995a cd f2 df				call check_stacks 
995d				endif 
995d e5				push hl 
995e d5				push de 
995f eb				ex de,hl 
9960 2a e5 e9			ld hl,(cli_data_sp) 
9963 23				inc hl 
9964 23				inc hl 
9965			 
9965			; PARSEV5 
9965 23				inc hl 
9966 22 e5 e9			ld (cli_data_sp),hl 
9969 73				ld (hl), e 
996a 23				inc hl 
996b 72				ld (hl), d 
996c d1				pop de 
996d e1				pop hl 
996e				if DEBUG_FORTH_STACK_GUARD 
996e cd f2 df				call check_stacks 
9971				endif 
9971 c9				ret 
9972			 
9972			 
9972			; increase ret stack pointer and save hl to it 
9972				 
9972			FORTH_RSP_NEXT: macro 
9972				call macro_forth_rsp_next 
9972				endm 
9972			 
9972			macro_forth_rsp_next: 
9972				if DEBUG_FORTH_STACK_GUARD 
9972 cd f2 df				call check_stacks 
9975				endif 
9975 e5				push hl 
9976 d5				push de 
9977 eb				ex de,hl 
9978 2a e9 e9			ld hl,(cli_ret_sp) 
997b 23				inc hl 
997c 23				inc hl 
997d 22 e9 e9			ld (cli_ret_sp),hl 
9980 73				ld (hl), e 
9981 23				inc hl 
9982 72				ld (hl), d 
9983 d1				pop de 
9984 e1				pop hl 
9985				if DEBUG_FORTH_STACK_GUARD 
9985 cd f2 df				call check_stacks 
9988				endif 
9988 c9				ret 
9989			 
9989			; get current ret stack pointer and save to hl  
9989				 
9989			FORTH_RSP_TOS: macro 
9989				call macro_forth_rsp_tos 
9989				endm 
9989			 
9989			macro_forth_rsp_tos: 
9989				;push de 
9989 2a e9 e9			ld hl,(cli_ret_sp) 
998c cd c4 99			call loadhlptrtohl 
998f				;ld e, (hl) 
998f				;inc hl 
998f				;ld d, (hl) 
998f				;ex de, hl 
998f					if DEBUG_FORTH_WORDS 
998f			;			DMARK "RST" 
998f						CALLMONITOR 
998f cd 6f ee			call debug_vector  
9992				endm  
# End of macro CALLMONITOR
9992					endif 
9992				;pop de 
9992 c9				ret 
9993			 
9993			; pop ret stack pointer 
9993				 
9993			FORTH_RSP_POP: macro 
9993				call macro_forth_rsp_pop 
9993				endm 
9993			 
9993			 
9993			macro_forth_rsp_pop: 
9993				if DEBUG_FORTH_STACK_GUARD 
9993			;		DMARK "RPP" 
9993 cd f2 df				call check_stacks 
9996					FORTH_CHK_RSP_UNDER 
9996 e5				push hl 
9997 d5				push de 
9998 2a e9 e9			ld hl,(cli_ret_sp) 
999b 11 a3 e9			ld de, cli_ret_stack 
999e cd f4 8c			call cmp16 
99a1 da 09 e1			jp c, fault_rsp_under 
99a4 d1				pop de 
99a5 e1				pop hl 
99a6				endm 
# End of macro FORTH_CHK_RSP_UNDER
99a6				endif 
99a6 e5				push hl 
99a7 2a e9 e9			ld hl,(cli_ret_sp) 
99aa			 
99aa			 
99aa				if FORTH_ENABLE_FREE 
99aa			 
99aa					; get pointer 
99aa			 
99aa					push de 
99aa					push hl 
99aa			 
99aa					ld e, (hl) 
99aa					inc hl 
99aa					ld d, (hl) 
99aa			 
99aa					ex de, hl 
99aa					call free 
99aa			 
99aa					pop hl 
99aa					pop de 
99aa			 
99aa			 
99aa				endif 
99aa			 
99aa			 
99aa 2b				dec hl 
99ab 2b				dec hl 
99ac 22 e9 e9			ld (cli_ret_sp), hl 
99af				; do stack underflow checks 
99af e1				pop hl 
99b0				if DEBUG_FORTH_STACK_GUARD 
99b0 cd f2 df				call check_stacks 
99b3					FORTH_CHK_RSP_UNDER 
99b3 e5				push hl 
99b4 d5				push de 
99b5 2a e9 e9			ld hl,(cli_ret_sp) 
99b8 11 a3 e9			ld de, cli_ret_stack 
99bb cd f4 8c			call cmp16 
99be da 09 e1			jp c, fault_rsp_under 
99c1 d1				pop de 
99c2 e1				pop hl 
99c3				endm 
# End of macro FORTH_CHK_RSP_UNDER
99c3				endif 
99c3 c9				ret 
99c4			 
99c4			 
99c4			 
99c4			; routine to load word pointed to by hl into hl 
99c4			 
99c4			loadhlptrtohl: 
99c4			 
99c4 d5				push de 
99c5 5e				ld e, (hl) 
99c6 23				inc hl 
99c7 56				ld d, (hl) 
99c8 eb				ex de, hl 
99c9 d1				pop de 
99ca			 
99ca c9				ret 
99cb			 
99cb			 
99cb			 
99cb			 
99cb			 
99cb			; push a number held in HL onto the data stack 
99cb			; entry point for pushing a value when already in hl used in function above 
99cb			 
99cb			forth_push_numhl: 
99cb			 
99cb e5				push hl    ; save value to push 
99cc			 
99cc			if DEBUG_FORTH_PUSH 
99cc				; see if disabled 
99cc			 
99cc			 
99cc f5				push af 
99cd 3a 6f ee			ld a,(debug_vector) 
99d0 fe c9			cp $c9   ; ret 
99d2			;	ld a, (os_view_disable) 
99d2			;	cp '*' 
99d2 28 33			jr z, .pskip2 
99d4 e5				push hl 
99d5 e5			push hl 
99d6 cd ac 8a			call clear_display 
99d9 e1			pop hl 
99da 7c				ld a,h 
99db 21 bd e5			ld hl, os_word_scratch 
99de cd d2 8e			call hexout 
99e1 e1				pop hl 
99e2 7d				ld a,l 
99e3 21 bf e5			ld hl, os_word_scratch+2 
99e6 cd d2 8e			call hexout 
99e9			 
99e9 21 c1 e5			ld hl, os_word_scratch+4 
99ec			;	ld a,0 
99ec 36 00			ld (hl),0 
99ee 11 bd e5			ld de,os_word_scratch 
99f1 3e 28				ld a, display_row_2 
99f3 cd be 8a				call str_at_display 
99f6 11 ef d1			ld de, .push_num 
99f9 3e 00			ld a, display_row_1 
99fb			 
99fb cd be 8a				call str_at_display 
99fe			 
99fe			 
99fe cd ce 8a			call update_display 
9a01 cd f0 89			call delay1s 
9a04 cd f0 89			call delay1s 
9a07			.pskip2:  
9a07			 
9a07 f1				pop af 
9a08			endif	 
9a08			 
9a08			 
9a08				FORTH_DSP_NEXT 
9a08 cd 5a 99			call macro_forth_dsp_next 
9a0b				endm 
# End of macro FORTH_DSP_NEXT
9a0b			 
9a0b 2a e5 e9			ld hl, (cli_data_sp) 
9a0e			 
9a0e				; save item type 
9a0e			;	ld a,  DS_TYPE_INUM 
9a0e 36 02			ld (hl), DS_TYPE_INUM 
9a10 23				inc hl 
9a11			 
9a11				; get word off stack 
9a11 d1				pop de 
9a12				;ld a,e 
9a12 73				ld (hl), e 
9a13 23				inc hl 
9a14			;	ld a,d 
9a14 72				ld (hl), d 
9a15			 
9a15			if DEBUG_FORTH_PUSH 
9a15 2b				dec hl 
9a16 2b				dec hl 
9a17 2b				dec hl 
9a18						DMARK "PH5" 
9a18 f5				push af  
9a19 3a 2d 9a			ld a, (.dmark)  
9a1c 32 62 ee			ld (debug_mark),a  
9a1f 3a 2e 9a			ld a, (.dmark+1)  
9a22 32 63 ee			ld (debug_mark+1),a  
9a25 3a 2f 9a			ld a, (.dmark+2)  
9a28 32 64 ee			ld (debug_mark+2),a  
9a2b 18 03			jr .pastdmark  
9a2d ..			.dmark: db "PH5"  
9a30 f1			.pastdmark: pop af  
9a31			endm  
# End of macro DMARK
9a31				CALLMONITOR 
9a31 cd 6f ee			call debug_vector  
9a34				endm  
# End of macro CALLMONITOR
9a34			endif	 
9a34			 
9a34 c9				ret 
9a35			 
9a35			 
9a35			; Push a string to stack pointed to by hl 
9a35			 
9a35			forth_push_str: 
9a35			 
9a35			if DEBUG_FORTH_PUSH 
9a35						DMARK "PSQ" 
9a35 f5				push af  
9a36 3a 4a 9a			ld a, (.dmark)  
9a39 32 62 ee			ld (debug_mark),a  
9a3c 3a 4b 9a			ld a, (.dmark+1)  
9a3f 32 63 ee			ld (debug_mark+1),a  
9a42 3a 4c 9a			ld a, (.dmark+2)  
9a45 32 64 ee			ld (debug_mark+2),a  
9a48 18 03			jr .pastdmark  
9a4a ..			.dmark: db "PSQ"  
9a4d f1			.pastdmark: pop af  
9a4e			endm  
# End of macro DMARK
9a4e				CALLMONITOR 
9a4e cd 6f ee			call debug_vector  
9a51				endm  
# End of macro CALLMONITOR
9a51			endif	 
9a51			 
9a51			 
9a51			    
9a51 e5				push hl 
9a52 e5				push hl 
9a53			 
9a53			;	ld a, 0   ; find end of string 
9a53 cd 2e 90			call strlenz 
9a56			if DEBUG_FORTH_PUSH 
9a56						DMARK "PQ2" 
9a56 f5				push af  
9a57 3a 6b 9a			ld a, (.dmark)  
9a5a 32 62 ee			ld (debug_mark),a  
9a5d 3a 6c 9a			ld a, (.dmark+1)  
9a60 32 63 ee			ld (debug_mark+1),a  
9a63 3a 6d 9a			ld a, (.dmark+2)  
9a66 32 64 ee			ld (debug_mark+2),a  
9a69 18 03			jr .pastdmark  
9a6b ..			.dmark: db "PQ2"  
9a6e f1			.pastdmark: pop af  
9a6f			endm  
# End of macro DMARK
9a6f				CALLMONITOR 
9a6f cd 6f ee			call debug_vector  
9a72				endm  
# End of macro CALLMONITOR
9a72			endif	 
9a72 eb				ex de, hl 
9a73 e1				pop hl   ; get ptr to start of string 
9a74			if DEBUG_FORTH_PUSH 
9a74						DMARK "PQ3" 
9a74 f5				push af  
9a75 3a 89 9a			ld a, (.dmark)  
9a78 32 62 ee			ld (debug_mark),a  
9a7b 3a 8a 9a			ld a, (.dmark+1)  
9a7e 32 63 ee			ld (debug_mark+1),a  
9a81 3a 8b 9a			ld a, (.dmark+2)  
9a84 32 64 ee			ld (debug_mark+2),a  
9a87 18 03			jr .pastdmark  
9a89 ..			.dmark: db "PQ3"  
9a8c f1			.pastdmark: pop af  
9a8d			endm  
# End of macro DMARK
9a8d				CALLMONITOR 
9a8d cd 6f ee			call debug_vector  
9a90				endm  
# End of macro CALLMONITOR
9a90			endif	 
9a90 19				add hl,de 
9a91			if DEBUG_FORTH_PUSH 
9a91						DMARK "PQE" 
9a91 f5				push af  
9a92 3a a6 9a			ld a, (.dmark)  
9a95 32 62 ee			ld (debug_mark),a  
9a98 3a a7 9a			ld a, (.dmark+1)  
9a9b 32 63 ee			ld (debug_mark+1),a  
9a9e 3a a8 9a			ld a, (.dmark+2)  
9aa1 32 64 ee			ld (debug_mark+2),a  
9aa4 18 03			jr .pastdmark  
9aa6 ..			.dmark: db "PQE"  
9aa9 f1			.pastdmark: pop af  
9aaa			endm  
# End of macro DMARK
9aaa				CALLMONITOR 
9aaa cd 6f ee			call debug_vector  
9aad				endm  
# End of macro CALLMONITOR
9aad			endif	 
9aad			 
9aad 2b				dec hl    ; see if there is an optional trailing double quote 
9aae 7e				ld a,(hl) 
9aaf fe 22			cp '"' 
9ab1 20 02			jr nz, .strnoq 
9ab3			;	ld a, 0      ; get rid of double quote 
9ab3 36 00			ld (hl), 0 
9ab5 23			.strnoq: inc hl 
9ab6			 
9ab6			;	ld a, 0 
9ab6 36 00			ld (hl), 0     ; add null term and get rid of trailing double quote 
9ab8			 
9ab8 13				inc de ; add one for the type string 
9ab9 13				inc de ; add one for null term??? 
9aba			 
9aba				; tos is get string pointer again 
9aba				; de contains space to allocate 
9aba				 
9aba d5				push de 
9abb			 
9abb eb				ex de, hl 
9abc			 
9abc				;push af 
9abc			 
9abc			if DEBUG_FORTH_PUSH 
9abc						DMARK "PHm" 
9abc f5				push af  
9abd 3a d1 9a			ld a, (.dmark)  
9ac0 32 62 ee			ld (debug_mark),a  
9ac3 3a d2 9a			ld a, (.dmark+1)  
9ac6 32 63 ee			ld (debug_mark+1),a  
9ac9 3a d3 9a			ld a, (.dmark+2)  
9acc 32 64 ee			ld (debug_mark+2),a  
9acf 18 03			jr .pastdmark  
9ad1 ..			.dmark: db "PHm"  
9ad4 f1			.pastdmark: pop af  
9ad5			endm  
# End of macro DMARK
9ad5				CALLMONITOR 
9ad5 cd 6f ee			call debug_vector  
9ad8				endm  
# End of macro CALLMONITOR
9ad8			endif	 
9ad8 cd a2 90			call malloc	; on ret hl now contains allocated memory 
9adb				if DEBUG_FORTH_MALLOC_GUARD 
9adb cc 47 d2				call z,malloc_error 
9ade				endif 
9ade			 
9ade				 
9ade c1				pop bc    ; get length 
9adf d1				pop de   ;  get string start    
9ae0			 
9ae0				; hl has destination from malloc 
9ae0			 
9ae0 eb				ex de, hl    ; prep for ldir 
9ae1			 
9ae1 d5				push de   ; save malloc area for DSP later 
9ae2				;push hl   ; save malloc area for DSP later 
9ae2			 
9ae2			if DEBUG_FORTH_PUSH 
9ae2						DMARK "PHc" 
9ae2 f5				push af  
9ae3 3a f7 9a			ld a, (.dmark)  
9ae6 32 62 ee			ld (debug_mark),a  
9ae9 3a f8 9a			ld a, (.dmark+1)  
9aec 32 63 ee			ld (debug_mark+1),a  
9aef 3a f9 9a			ld a, (.dmark+2)  
9af2 32 64 ee			ld (debug_mark+2),a  
9af5 18 03			jr .pastdmark  
9af7 ..			.dmark: db "PHc"  
9afa f1			.pastdmark: pop af  
9afb			endm  
# End of macro DMARK
9afb				CALLMONITOR 
9afb cd 6f ee			call debug_vector  
9afe				endm  
# End of macro CALLMONITOR
9afe			endif	 
9afe			 
9afe			 
9afe ed b0			ldir 
9b00			 
9b00			 
9b00				; push malloc to data stack     macro?????  
9b00			 
9b00				FORTH_DSP_NEXT 
9b00 cd 5a 99			call macro_forth_dsp_next 
9b03				endm 
# End of macro FORTH_DSP_NEXT
9b03			 
9b03				; save value and type 
9b03			 
9b03 2a e5 e9			ld hl, (cli_data_sp) 
9b06			 
9b06				; save item type 
9b06			;	ld a,  DS_TYPE_STR 
9b06 36 01			ld (hl), DS_TYPE_STR 
9b08 23				inc hl 
9b09			 
9b09				; get malloc word off stack 
9b09 d1				pop de 
9b0a 73				ld (hl), e 
9b0b 23				inc hl 
9b0c 72				ld (hl), d 
9b0d			 
9b0d			 
9b0d			 
9b0d			if DEBUG_FORTH_PUSH 
9b0d 2a e5 e9			ld hl, (cli_data_sp) 
9b10						DMARK "PHS" 
9b10 f5				push af  
9b11 3a 25 9b			ld a, (.dmark)  
9b14 32 62 ee			ld (debug_mark),a  
9b17 3a 26 9b			ld a, (.dmark+1)  
9b1a 32 63 ee			ld (debug_mark+1),a  
9b1d 3a 27 9b			ld a, (.dmark+2)  
9b20 32 64 ee			ld (debug_mark+2),a  
9b23 18 03			jr .pastdmark  
9b25 ..			.dmark: db "PHS"  
9b28 f1			.pastdmark: pop af  
9b29			endm  
# End of macro DMARK
9b29				CALLMONITOR 
9b29 cd 6f ee			call debug_vector  
9b2c				endm  
# End of macro CALLMONITOR
9b2c			;	ex de,hl 
9b2c			endif	 
9b2c				; in case of spaces, skip the ptr past the copied string 
9b2c				;pop af 
9b2c				;ld (cli_origptr),hl 
9b2c			 
9b2c c9				ret 
9b2d			 
9b2d			 
9b2d			 
9b2d			; TODO ascii push input onto stack given hl to start of input 
9b2d			 
9b2d			; identify type 
9b2d			; if starts with a " then a string 
9b2d			; otherwise it is a number 
9b2d			;  
9b2d			; if a string 
9b2d			;     scan for ending " to get length of string to malloc for + 1 
9b2d			;     malloc 
9b2d			;     put pointer to string on stack first byte flags as string 
9b2d			; 
9b2d			; else a number 
9b2d			;    look for number format identifier 
9b2d			;    $xx hex 
9b2d			;    %xxxxx bin 
9b2d			;    xxxxx decimal 
9b2d			;    convert number to 16bit word.  
9b2d			;    malloc word + 1 with flag to identiy as num 
9b2d			;    put pointer to number on stack 
9b2d			;   
9b2d			;  
9b2d			  
9b2d			forth_apush: 
9b2d				; kernel push 
9b2d			 
9b2d			if DEBUG_FORTH_PUSH 
9b2d						DMARK "PSH" 
9b2d f5				push af  
9b2e 3a 42 9b			ld a, (.dmark)  
9b31 32 62 ee			ld (debug_mark),a  
9b34 3a 43 9b			ld a, (.dmark+1)  
9b37 32 63 ee			ld (debug_mark+1),a  
9b3a 3a 44 9b			ld a, (.dmark+2)  
9b3d 32 64 ee			ld (debug_mark+2),a  
9b40 18 03			jr .pastdmark  
9b42 ..			.dmark: db "PSH"  
9b45 f1			.pastdmark: pop af  
9b46			endm  
# End of macro DMARK
9b46				CALLMONITOR 
9b46 cd 6f ee			call debug_vector  
9b49				endm  
# End of macro CALLMONITOR
9b49			endif	 
9b49				; identify input type 
9b49			 
9b49 7e				ld a,(hl) 
9b4a			 
9b4a fe 23			cp '#' 
9b4c ca 84 9b			jp z, .fapdec 
9b4f			 
9b4f			 
9b4f fe 22			cp '"' 
9b51 28 0a			jr z, .fapstr 
9b53 fe 24			cp '$' 
9b55 ca 7c 9b			jp z, .faphex 
9b58 fe 25			cp '%' 
9b5a ca 65 9b			jp z, .fapbin 
9b5d			;	cp 'b' 
9b5d			;	jp z, .fabin 
9b5d				; else decimal 
9b5d			 
9b5d				; TODO do decimal conversion 
9b5d				; decimal is stored as a 16bit word 
9b5d			 
9b5d				; by default everything is a string if type is not detected 
9b5d			.fapstr: ; 
9b5d fe 22			cp '"' 
9b5f 20 01			jr nz, .strnoqu 
9b61 23				inc hl 
9b62			.strnoqu: 
9b62 c3 35 9a			jp forth_push_str 
9b65			 
9b65			 
9b65			 
9b65			.fapbin:    ; push a binary string.  
9b65 11 00 00			ld de, 0   ; hold a 16bit value 
9b68			 
9b68 23			.fapbinshift:	inc hl  
9b69 7e				ld a,(hl) 
9b6a			;	cp 0     ; done scanning  
9b6a b7				or a 
9b6b 28 0b			jr z, .fapbdone  	; got it in HL so push  
9b6d			 
9b6d				; left shift de 
9b6d eb				ex de, hl	 
9b6e 29				add hl, hl 
9b6f			 
9b6f				; is 1 
9b6f fe 31			cp '1' 
9b71 20 02			jr nz, .binzero 
9b73 cb 4d			bit 1, l 
9b75			.binzero: 
9b75 eb				ex de, hl	 ; save current de 
9b76 18 f0			jr .fapbinshift 
9b78			 
9b78			.fapbdone: 
9b78 eb				ex de, hl 
9b79 c3 cb 99			jp forth_push_numhl 
9b7c			 
9b7c			 
9b7c			.faphex:   ; hex is always stored as a 16bit word 
9b7c				; skip number prefix 
9b7c 23				inc hl 
9b7d				; turn ascii into number 
9b7d cd 88 8f			call get_word_hl	; ret 16bit word in hl 
9b80			 
9b80 c3 cb 99			jp forth_push_numhl 
9b83			 
9b83			;	 nop 
9b83			 
9b83			.fabin:   ; TODO bin conversion 
9b83			 
9b83			 
9b83 c9				ret 
9b84			.fapdec:	 
9b84				; string to dec conversion 
9b84 23				inc hl 
9b85 eb				ex de, hl 
9b86 cd c5 8f			call string_to_uint16 
9b89 c3 cb 99			jp forth_push_numhl 
9b8c c9				ret 
9b8d				 
9b8d			;atoui_16: 
9b8d			 
9b8d			; get either a string ptr or a 16bit word from the data stack 
9b8d			 
9b8d			FORTH_DSP: macro 
9b8d				call macro_forth_dsp 
9b8d				endm 
9b8d			 
9b8d			macro_forth_dsp: 
9b8d				; data stack pointer points to current word on tos 
9b8d			 
9b8d 2a e5 e9			ld hl,(cli_data_sp) 
9b90			 
9b90				if DEBUG_FORTH_PUSH 
9b90						DMARK "DSP" 
9b90 f5				push af  
9b91 3a a5 9b			ld a, (.dmark)  
9b94 32 62 ee			ld (debug_mark),a  
9b97 3a a6 9b			ld a, (.dmark+1)  
9b9a 32 63 ee			ld (debug_mark+1),a  
9b9d 3a a7 9b			ld a, (.dmark+2)  
9ba0 32 64 ee			ld (debug_mark+2),a  
9ba3 18 03			jr .pastdmark  
9ba5 ..			.dmark: db "DSP"  
9ba8 f1			.pastdmark: pop af  
9ba9			endm  
# End of macro DMARK
9ba9			 
9ba9 cd 7a d2				call display_data_sp 
9bac				;call break_point_state 
9bac				;rst 030h 
9bac				CALLMONITOR 
9bac cd 6f ee			call debug_vector  
9baf				endm  
# End of macro CALLMONITOR
9baf				endif 
9baf			 
9baf c9				ret 
9bb0			 
9bb0			; return hl to start of value on stack 
9bb0			 
9bb0			FORTH_DSP_VALUE: macro 
9bb0				call macro_forth_dsp_value 
9bb0				endm 
9bb0			 
9bb0			macro_forth_dsp_value: 
9bb0			 
9bb0				FORTH_DSP 
9bb0 cd 8d 9b			call macro_forth_dsp 
9bb3				endm 
# End of macro FORTH_DSP
9bb3			 
9bb3 d5				push de 
9bb4			 
9bb4 23				inc hl ; skip type 
9bb5			 
9bb5 5e				ld e, (hl) 
9bb6 23				inc hl 
9bb7 56				ld d, (hl) 
9bb8 eb				ex de,hl  
9bb9			 
9bb9 d1				pop de 
9bba			 
9bba c9				ret 
9bbb			 
9bbb			; return hl to start of value to second item on stack 
9bbb			 
9bbb			FORTH_DSP_VALUEM1: macro 
9bbb				call macro_forth_dsp_value_m1 
9bbb				endm 
9bbb			 
9bbb			macro_forth_dsp_value_m1: 
9bbb			 
9bbb				FORTH_DSP 
9bbb cd 8d 9b			call macro_forth_dsp 
9bbe				endm 
# End of macro FORTH_DSP
9bbe			 
9bbe 2b				dec hl 
9bbf 2b				dec hl 
9bc0			;	dec hl 
9bc0			 
9bc0 d5				push de 
9bc1			 
9bc1 5e				ld e, (hl) 
9bc2 23				inc hl 
9bc3 56				ld d, (hl) 
9bc4 eb				ex de,hl  
9bc5			 
9bc5 d1				pop de 
9bc6			 
9bc6 c9				ret 
9bc7			 
9bc7				 
9bc7			 
9bc7			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9bc7			 
9bc7			FORTH_DSP_POP: macro 
9bc7				call macro_forth_dsp_pop 
9bc7				endm 
9bc7			 
9bc7			 
9bc7			; get the tos data type 
9bc7			 
9bc7			FORTH_DSP_TYPE:   macro 
9bc7			 
9bc7				;FORTH_DSP_VALUE 
9bc7				FORTH_DSP 
9bc7				 
9bc7				; hl points to value 
9bc7				; check type 
9bc7			 
9bc7				ld a,(hl) 
9bc7			 
9bc7				endm 
9bc7			 
9bc7			; load the tos value into hl 
9bc7			 
9bc7			 
9bc7			FORTH_DSP_VALUEHL:  macro 
9bc7				call macro_dsp_valuehl 
9bc7				endm 
9bc7			 
9bc7			 
9bc7			 
9bc7			macro_dsp_valuehl: 
9bc7				FORTH_DSP_VALUE 
9bc7 cd b0 9b			call macro_forth_dsp_value 
9bca				endm 
# End of macro FORTH_DSP_VALUE
9bca			 
9bca				;FORTH_ERR_TOS_NOTNUM 
9bca			 
9bca				;inc hl   ; skip type id 
9bca			 
9bca			;	push de 
9bca			; 
9bca			;	ld e, (hl) 
9bca			;	inc hl 
9bca			;	ld d, (hl) 
9bca			;	ex de,hl  
9bca			 
9bca			;	pop de 
9bca			 
9bca				if DEBUG_FORTH_PUSH 
9bca						DMARK "DVL" 
9bca f5				push af  
9bcb 3a df 9b			ld a, (.dmark)  
9bce 32 62 ee			ld (debug_mark),a  
9bd1 3a e0 9b			ld a, (.dmark+1)  
9bd4 32 63 ee			ld (debug_mark+1),a  
9bd7 3a e1 9b			ld a, (.dmark+2)  
9bda 32 64 ee			ld (debug_mark+2),a  
9bdd 18 03			jr .pastdmark  
9bdf ..			.dmark: db "DVL"  
9be2 f1			.pastdmark: pop af  
9be3			endm  
# End of macro DMARK
9be3				CALLMONITOR 
9be3 cd 6f ee			call debug_vector  
9be6				endm  
# End of macro CALLMONITOR
9be6				endif 
9be6 c9				ret 
9be7			 
9be7			forth_apushstrhl:      
9be7				; push of string requires use of cli_origptr 
9be7				; bodge use 
9be7			 
9be7				; get current cli_origptr, save, update with temp pointer  
9be7 ed 5b 35 ea		ld de, (cli_origptr) 
9beb 22 35 ea			ld (cli_origptr), hl 
9bee d5				push de 
9bef cd 2d 9b			call forth_apush 
9bf2 d1				pop de 
9bf3 ed 53 35 ea		ld (cli_origptr), de 
9bf7 c9			        ret	 
9bf8			 
9bf8			 
9bf8			; increase loop stack pointer and save hl to it 
9bf8				 
9bf8			FORTH_LOOP_NEXT: macro 
9bf8				call macro_forth_loop_next 
9bf8				;nop 
9bf8				endm 
9bf8			 
9bf8			macro_forth_loop_next: 
9bf8				if DEBUG_FORTH_STACK_GUARD 
9bf8 cd f2 df				call check_stacks 
9bfb				endif 
9bfb e5				push hl 
9bfc d5				push de 
9bfd eb				ex de,hl 
9bfe 2a e7 e9			ld hl,(cli_loop_sp) 
9c01 23				inc hl 
9c02 23				inc hl 
9c03					if DEBUG_FORTH_WORDS 
9c03						DMARK "LNX" 
9c03 f5				push af  
9c04 3a 18 9c			ld a, (.dmark)  
9c07 32 62 ee			ld (debug_mark),a  
9c0a 3a 19 9c			ld a, (.dmark+1)  
9c0d 32 63 ee			ld (debug_mark+1),a  
9c10 3a 1a 9c			ld a, (.dmark+2)  
9c13 32 64 ee			ld (debug_mark+2),a  
9c16 18 03			jr .pastdmark  
9c18 ..			.dmark: db "LNX"  
9c1b f1			.pastdmark: pop af  
9c1c			endm  
# End of macro DMARK
9c1c						CALLMONITOR 
9c1c cd 6f ee			call debug_vector  
9c1f				endm  
# End of macro CALLMONITOR
9c1f					endif 
9c1f 22 e7 e9			ld (cli_loop_sp),hl 
9c22 73				ld (hl), e 
9c23 23				inc hl 
9c24 72				ld (hl), d 
9c25 d1				pop de    ; been reversed so save a swap on restore 
9c26 e1				pop hl 
9c27				if DEBUG_FORTH_STACK_GUARD 
9c27 cd f2 df				call check_stacks 
9c2a				endif 
9c2a c9				ret 
9c2b			 
9c2b			; get current ret stack pointer and save to hl  
9c2b				 
9c2b			FORTH_LOOP_TOS: macro 
9c2b				call macro_forth_loop_tos 
9c2b				endm 
9c2b			 
9c2b			macro_forth_loop_tos: 
9c2b d5				push de 
9c2c 2a e7 e9			ld hl,(cli_loop_sp) 
9c2f 5e				ld e, (hl) 
9c30 23				inc hl 
9c31 56				ld d, (hl) 
9c32 eb				ex de, hl 
9c33 d1				pop de 
9c34 c9				ret 
9c35			 
9c35			; pop loop stack pointer 
9c35				 
9c35			FORTH_LOOP_POP: macro 
9c35				call macro_forth_loop_pop 
9c35				endm 
9c35			 
9c35			 
9c35			macro_forth_loop_pop: 
9c35				if DEBUG_FORTH_STACK_GUARD 
9c35					DMARK "LPP" 
9c35 f5				push af  
9c36 3a 4a 9c			ld a, (.dmark)  
9c39 32 62 ee			ld (debug_mark),a  
9c3c 3a 4b 9c			ld a, (.dmark+1)  
9c3f 32 63 ee			ld (debug_mark+1),a  
9c42 3a 4c 9c			ld a, (.dmark+2)  
9c45 32 64 ee			ld (debug_mark+2),a  
9c48 18 03			jr .pastdmark  
9c4a ..			.dmark: db "LPP"  
9c4d f1			.pastdmark: pop af  
9c4e			endm  
# End of macro DMARK
9c4e cd f2 df				call check_stacks 
9c51					FORTH_CHK_LOOP_UNDER 
9c51 e5				push hl 
9c52 d5				push de 
9c53 2a e7 e9			ld hl,(cli_loop_sp) 
9c56 11 21 e9			ld de, cli_loop_stack 
9c59 cd f4 8c			call cmp16 
9c5c da 0f e1			jp c, fault_loop_under 
9c5f d1				pop de 
9c60 e1				pop hl 
9c61				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9c61				endif 
9c61 e5				push hl 
9c62 2a e7 e9			ld hl,(cli_loop_sp) 
9c65 2b				dec hl 
9c66 2b				dec hl 
9c67 22 e7 e9			ld (cli_loop_sp), hl 
9c6a				; TODO do stack underflow checks 
9c6a e1				pop hl 
9c6b				if DEBUG_FORTH_STACK_GUARD 
9c6b cd f2 df				call check_stacks 
9c6e					FORTH_CHK_LOOP_UNDER 
9c6e e5				push hl 
9c6f d5				push de 
9c70 2a e7 e9			ld hl,(cli_loop_sp) 
9c73 11 21 e9			ld de, cli_loop_stack 
9c76 cd f4 8c			call cmp16 
9c79 da 0f e1			jp c, fault_loop_under 
9c7c d1				pop de 
9c7d e1				pop hl 
9c7e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9c7e				endif 
9c7e c9				ret 
9c7f			 
9c7f			macro_forth_dsp_pop: 
9c7f			 
9c7f e5				push hl 
9c80			 
9c80				; release malloc data 
9c80			 
9c80				if DEBUG_FORTH_STACK_GUARD 
9c80 cd f2 df				call check_stacks 
9c83					FORTH_CHK_DSP_UNDER 
9c83 e5				push hl 
9c84 d5				push de 
9c85 2a e5 e9			ld hl,(cli_data_sp) 
9c88 11 1f e8			ld de, cli_data_stack 
9c8b cd f4 8c			call cmp16 
9c8e da 03 e1			jp c, fault_dsp_under 
9c91 d1				pop de 
9c92 e1				pop hl 
9c93				endm 
# End of macro FORTH_CHK_DSP_UNDER
9c93				endif 
9c93				;ld hl,(cli_data_sp) 
9c93			if DEBUG_FORTH_DOT 
9c93				DMARK "DPP" 
9c93 f5				push af  
9c94 3a a8 9c			ld a, (.dmark)  
9c97 32 62 ee			ld (debug_mark),a  
9c9a 3a a9 9c			ld a, (.dmark+1)  
9c9d 32 63 ee			ld (debug_mark+1),a  
9ca0 3a aa 9c			ld a, (.dmark+2)  
9ca3 32 64 ee			ld (debug_mark+2),a  
9ca6 18 03			jr .pastdmark  
9ca8 ..			.dmark: db "DPP"  
9cab f1			.pastdmark: pop af  
9cac			endm  
# End of macro DMARK
9cac				CALLMONITOR 
9cac cd 6f ee			call debug_vector  
9caf				endm  
# End of macro CALLMONITOR
9caf			endif	 
9caf			 
9caf			 
9caf			if FORTH_ENABLE_DSPPOPFREE 
9caf			 
9caf				FORTH_DSP 
9caf cd 8d 9b			call macro_forth_dsp 
9cb2				endm 
# End of macro FORTH_DSP
9cb2			 
9cb2 7e				ld a, (hl) 
9cb3 fe 01			cp DS_TYPE_STR 
9cb5 20 22			jr nz, .skippopfree 
9cb7			 
9cb7				FORTH_DSP_VALUEHL 
9cb7 cd c7 9b			call macro_dsp_valuehl 
9cba				endm 
# End of macro FORTH_DSP_VALUEHL
9cba			;	nop 
9cba			if DEBUG_FORTH_DOT 
9cba				DMARK "DPf" 
9cba f5				push af  
9cbb 3a cf 9c			ld a, (.dmark)  
9cbe 32 62 ee			ld (debug_mark),a  
9cc1 3a d0 9c			ld a, (.dmark+1)  
9cc4 32 63 ee			ld (debug_mark+1),a  
9cc7 3a d1 9c			ld a, (.dmark+2)  
9cca 32 64 ee			ld (debug_mark+2),a  
9ccd 18 03			jr .pastdmark  
9ccf ..			.dmark: db "DPf"  
9cd2 f1			.pastdmark: pop af  
9cd3			endm  
# End of macro DMARK
9cd3				CALLMONITOR 
9cd3 cd 6f ee			call debug_vector  
9cd6				endm  
# End of macro CALLMONITOR
9cd6			endif	 
9cd6 cd 6c 91			call free 
9cd9			.skippopfree: 
9cd9				 
9cd9			 
9cd9			endif 
9cd9			 
9cd9			if DEBUG_FORTH_DOT_KEY 
9cd9				DMARK "DP2" 
9cd9				CALLMONITOR 
9cd9			endif	 
9cd9			 
9cd9				; move pointer down 
9cd9			 
9cd9 2a e5 e9			ld hl,(cli_data_sp) 
9cdc 2b				dec hl 
9cdd 2b				dec hl 
9cde			; PARSEV5 
9cde 2b				dec hl 
9cdf 22 e5 e9			ld (cli_data_sp), hl 
9ce2			 
9ce2				if DEBUG_FORTH_STACK_GUARD 
9ce2 cd f2 df				call check_stacks 
9ce5					FORTH_CHK_DSP_UNDER 
9ce5 e5				push hl 
9ce6 d5				push de 
9ce7 2a e5 e9			ld hl,(cli_data_sp) 
9cea 11 1f e8			ld de, cli_data_stack 
9ced cd f4 8c			call cmp16 
9cf0 da 03 e1			jp c, fault_dsp_under 
9cf3 d1				pop de 
9cf4 e1				pop hl 
9cf5				endm 
# End of macro FORTH_CHK_DSP_UNDER
9cf5				endif 
9cf5			 
9cf5 e1				pop hl 
9cf6			 
9cf6 c9				ret 
9cf7			 
9cf7			getwordathl: 
9cf7				; hl points to an address 
9cf7				; load hl with the word at that address 
9cf7			 
9cf7 d5				push de 
9cf8			 
9cf8 5e				ld e, (hl) 
9cf9 23				inc hl 
9cfa 56				ld d, (hl) 
9cfb eb				ex de, hl 
9cfc			 
9cfc d1				pop de 
9cfd c9				ret 
9cfe			 
9cfe			 
9cfe			; functions to manuplite stack pointers 
9cfe			 
9cfe			; generate fragment to set hl to be pointer to a stack item 
9cfe			 
9cfe			FORTH_DSP_PTR: macro  x 
9cfe				ld hl,(cli_data_sp) 
9cfe				ld de, x * 3 
9cfe				sbc hl, de 
9cfe				endm 
9cfe			 
9cfe			 
9cfe			 
9cfe			; copy point in hl to stack tmp storage slots 1-4 
9cfe			hltostack1: 
9cfe 11 b5 e2			ld de, os_stack_1  
9d01 c3 2c 9d			jp hltostackmv 
9d04			 
9d04			hltostack2:  
9d04 11 b2 e2			ld de, os_stack_2 
9d07 c3 2c 9d			jp hltostackmv 
9d0a			 
9d0a			hltostack3:  
9d0a 11 af e2			ld de, os_stack_3 
9d0d c3 2c 9d			jp hltostackmv 
9d10			 
9d10			hltostack4:  
9d10 11 ac e2			ld de, os_stack_4  
9d13 c3 2c 9d			jp hltostackmv 
9d16			 
9d16			; copy to point in hl from stack tmp storage slots 1-4 
9d16			hlfromstack1: 
9d16 11 b5 e2			ld de, os_stack_1 
9d19 c3 2b 9d			jp hlfromsttackmv 
9d1c			 
9d1c			hlfromstack2:  
9d1c 11 b2 e2			ld de, os_stack_2 
9d1f c3 2b 9d			jp hlfromsttackmv 
9d22			 
9d22			hlfromstack3:  
9d22 11 af e2			ld de, os_stack_3 
9d25 c3 2b 9d			jp hlfromsttackmv 
9d28			 
9d28			hlfromstack4:  
9d28 11 ac e2			ld de, os_stack_4 
9d2b			 
9d2b			hlfromsttackmv: 
9d2b eb				ex de, hl 
9d2c			 
9d2c			hltostackmv: 
9d2c			 
9d2c				; do stack move 
9d2c c5				push bc 
9d2d 01 03 00			ld bc, 3 
9d30 ed b0			ldir  
9d32 c1				pop bc	 
9d33 c9				ret 
9d34			 
9d34			; eof 
9d34			 
# End of file forth_stackopsv5.asm
9d34			endif 
9d34			loadwordinhl:	 
9d34			 
9d34 d5				push de 
9d35			 
9d35 5e				ld e, (hl) 
9d36 23				inc hl 
9d37 56				ld d, (hl) 
9d38 eb				ex de,hl  
9d39			 
9d39 d1				pop de 
9d3a			 
9d3a c9				ret 
9d3b			 
9d3b			user_word_eol:  
9d3b				; hl contains the pointer to where to create a linked list item from the end 
9d3b				; of the user dict to continue on at the system word dict 
9d3b				 
9d3b				; poke the stub of the word list linked list to repoint to rom words 
9d3b			 
9d3b				; stub format 
9d3b				; db   word id 
9d3b				; dw    link to next word 
9d3b			        ; db char length of token 
9d3b				; db string + 0 term 
9d3b				; db exec code....  
9d3b			 
9d3b			;	ld a, WORD_SYS_ROOT     ; root word 
9d3b 36 00			ld (hl), WORD_SYS_ROOT		; word id 
9d3d 23				inc hl 
9d3e			 
9d3e 11 e7 9e			ld de, sysdict 
9d41 73				ld (hl), e		; next word link ie system dict 
9d42 23				inc hl 
9d43 72				ld (hl), d		; next word link ie system dict 
9d44 23				inc hl	 
9d45			 
9d45			;	ld (hl), sysdict		; next word link ie system dict 
9d45			;	inc hl 
9d45			;	inc hl 
9d45			 
9d45			;	inc hl 
9d45			;	inc hl 
9d45			 
9d45			;	ld a, 2			; word length is 0 
9d45 36 02			ld (hl), 2 
9d47 23				inc hl 
9d48			 
9d48			;	ld a, '~'			; word length is 0 
9d48 36 7e			ld (hl), '~' 
9d4a 23				inc hl 
9d4b			;	ld a, 0			; save empty word 
9d4b 36 00			ld (hl), 0 
9d4d			 
9d4d c9				ret 
9d4e			 
9d4e				 
9d4e			 
9d4e			forthexec_cleanup: 
9d4e				FORTH_RSP_POP 
9d4e cd 93 99			call macro_forth_rsp_pop 
9d51				endm 
# End of macro FORTH_RSP_POP
9d51 c9				ret 
9d52			 
9d52			forth_call_hl: 
9d52				; taking hl 
9d52 e5				push hl 
9d53 c9				ret 
9d54			 
9d54			; this is called to reset Forth system but keep existing uwords etc 
9d54			 
9d54			forth_warmstart: 
9d54				; setup stack over/under flow checks 
9d54				if DEBUG_FORTH_STACK_GUARD 
9d54 cd d8 df				call chk_stk_init 
9d57				endif 
9d57			 
9d57				; init stack pointers  - * these stacks go upwards *  
9d57 21 a3 e9			ld hl, cli_ret_stack 
9d5a 22 e9 e9			ld (cli_ret_sp), hl	 
9d5d				; set bottom of stack 
9d5d			;	ld a,0 
9d5d 36 00			ld (hl),0 
9d5f 23				inc hl 
9d60 36 00			ld (hl),0 
9d62			 
9d62 21 1f e8			ld hl, cli_data_stack 
9d65 22 e5 e9			ld (cli_data_sp), hl	 
9d68				; set bottom of stack 
9d68			;	ld a,0 
9d68 36 00			ld (hl),0 
9d6a 23				inc hl 
9d6b 36 00			ld (hl),0 
9d6d			 
9d6d 21 21 e9			ld hl, cli_loop_stack 
9d70 22 e7 e9			ld (cli_loop_sp), hl	 
9d73				; set bottom of stack 
9d73			;	ld a,0 
9d73 36 00			ld (hl),0 
9d75 23				inc hl 
9d76 36 00			ld (hl),0 
9d78			 
9d78				; init extent of current open file 
9d78			 
9d78 3e 00			ld a, 0 
9d7a 32 61 ea			ld (store_openext), a 
9d7d			 
9d7d c9				ret 
9d7e			 
9d7e			 
9d7e			 
9d7e			; Cold Start - this is called to setup the whole Forth system 
9d7e			 
9d7e			forth_init: 
9d7e			 
9d7e				; setup stack over/under flow checks 
9d7e			 
9d7e			;	if DEBUG_FORTH_STACK_GUARD 
9d7e			;		call chk_stk_init 
9d7e			;	endif 
9d7e			 
9d7e				; enable auto display updates (slow.....) 
9d7e			 
9d7e 3e 01			ld a, 1 
9d80 32 33 ea			ld (cli_autodisplay), a 
9d83			 
9d83				; if storage is in use disable long reads for now 
9d83 3e 00			ld a, 0 
9d85 32 6c ea			ld (store_longread), a 
9d88			 
9d88			 
9d88				; show start up screen 
9d88			 
9d88 cd ac 8a			call clear_display 
9d8b			 
9d8b 3e 00			ld a,0 
9d8d 32 55 ea			ld (f_cursor_ptr), a 
9d90			 
9d90				; set start of word list in start of ram - for use when creating user words 
9d90			 
9d90 21 95 e3			ld hl, baseram 
9d93 22 b5 e5			ld (os_last_new_uword), hl 
9d96 cd 3b 9d			call user_word_eol 
9d99				 
9d99			;		call display_data_sp 
9d99			;		call next_page_prompt 
9d99			 
9d99			 
9d99			 
9d99			 
9d99 c9				ret 
9d9a			 
9d9a .. 00		.bootforth: db " Forth Kernel Init ",0 
9dae			 
9dae			; TODO push to stack 
9dae			 
9dae			;  
9dae			 
9dae			if FORTH_PARSEV2 
9dae			 
9dae			 
9dae				include "forth_parserv2.asm" 
9dae			 
9dae			endif 
9dae			 
9dae			 
9dae			; parse cli version 1 
9dae			 
9dae			if FORTH_PARSEV1 
9dae			 
9dae			 
9dae			 
9dae			      include "forth_parserv1.asm" 
9dae			endif 
9dae				 
9dae			if FORTH_PARSEV3 
9dae			      include "forth_parserv3.asm" 
9dae				include "forth_wordsv3.asm" 
9dae			endif 
9dae			 
9dae			if FORTH_PARSEV4 
9dae			      include "forth_parserv4.asm" 
9dae				include "forth_wordsv4.asm" 
9dae			endif 
9dae			 
9dae			if FORTH_PARSEV5 
9dae			      include "forth_parserv5.asm" 
9dae				include "forth_wordsv4.asm" 
9dae			endif 
9dae			 
9dae			if FORTH_PARSEV6 
9dae			      include "forth_parserv6.asm" 
9dae			 
9dae			 
9dae			; A better parser without using malloc and string copies all over the place.  
9dae			; Exec in situ should be faster 
9dae			 
9dae			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9dae			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9dae			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9dae			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9dae			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9dae			WORD_SYS_END: equ 0   ; Opcode for all user words 
9dae			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9dae			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9dae			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9dae			 
9dae			; Core word preamble macro 
9dae			 
9dae			CWHEAD:   macro nxtword opcode lit len opflags 
9dae				db WORD_SYS_CORE+opcode             
9dae				; internal op code number 
9dae				dw nxtword            
9dae				; link to next dict word block 
9dae				db len + 1 
9dae				; literal length of dict word inc zero term 
9dae				db lit,0              
9dae				; literal dict word 
9dae			        ; TODO db opflags        
9dae				endm 
9dae			 
9dae			 
9dae			NEXTW: macro  
9dae				call parse_vector 
9dae				jp macro_next 
9dae				endm 
9dae			 
9dae			macro_next: 
9dae			if DEBUG_FORTH_PARSE_EXEC 
9dae				DMARK "NXT" 
9dae				CALLMONITOR 
9dae			endif	 
9dae			;	inc hl  ; skip token null term  
9dae ed 4b 37 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9db2 ed 5b 35 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9db6 2a b9 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9db9			if DEBUG_FORTH_PARSE_EXEC 
9db9				DMARK "}AA" 
9db9				CALLMONITOR 
9db9			endif	 
9db9 c3 9e 9e			jp execnext 
9dbc				;jp exec1 
9dbc			       
9dbc			 
9dbc			 
9dbc			; Another go at the parser to compile  
9dbc			 
9dbc			 
9dbc			; TODO rework parser to change all of the string words to byte tokens 
9dbc			; TODO do a search for  
9dbc			 
9dbc			; TODO first run normal parser to zero term sections 
9dbc			; TODO for each word do a token look up to get the op code 
9dbc			; TODO need some means to flag to the exec that this is a byte code form    
9dbc			 
9dbc			 
9dbc			forthcompile: 
9dbc			 
9dbc			; 
9dbc			; line parse: 
9dbc			;       parse raw input buffer 
9dbc			;       tokenise the words 
9dbc			;       malloc new copy (for looping etc) 
9dbc			;       copy to malloc + current pc in line to start of string and add line term 
9dbc			;       save on new rsp 
9dbc			; 
9dbc			 
9dbc			; hl to point to the line to tokenise 
9dbc			 
9dbc			;	push hl 
9dbc 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9dbf			 
9dbf			;	ld a,0		; string term on input 
9dbf			;	call strlent 
9dbf			 
9dbf			;	ld (os_tok_len), hl	 ; save string length 
9dbf			 
9dbf			;if DEBUG_FORTH_TOK 
9dbf			;	ex de,hl		 
9dbf			;endif 
9dbf			 
9dbf			;	pop hl 		; get back string pointer 
9dbf			 
9dbf			if DEBUG_FORTH_TOK 
9dbf						DMARK "TOc" 
9dbf				CALLMONITOR 
9dbf			endif 
9dbf 7e			.cptoken2:    ld a,(hl) 
9dc0 23				inc hl 
9dc1 fe 7f			cp FORTH_END_BUFFER 
9dc3 28 26			jr z, .cptokendone2 
9dc5			;	cp 0 
9dc5 b7				or a 
9dc6 28 23			jr z, .cptokendone2 
9dc8 fe 22			cp '"' 
9dca 28 0a			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9dcc fe 20			cp ' ' 
9dce 20 ef			jr nz,  .cptoken2 
9dd0			 
9dd0			; TODO consume comments held between ( and ) 
9dd0			 
9dd0				; we have a space so change to zero term for dict match later 
9dd0 2b				dec hl 
9dd1			;	ld a,0 
9dd1 36 00			ld (hl), 0 
9dd3 23				inc hl 
9dd4 18 e9			jr .cptoken2 
9dd6				 
9dd6			 
9dd6			.cptokenstr2: 
9dd6				; skip all white space until either eol (because forgot to term) or end double quote 
9dd6			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9dd6				;inc hl ; skip current double quote 
9dd6 7e				ld a,(hl) 
9dd7 23				inc hl 
9dd8 fe 22			cp '"' 
9dda 28 e3			jr z, .cptoken2 
9ddc fe 7f			cp FORTH_END_BUFFER 
9dde 28 0b			jr z, .cptokendone2 
9de0			;	cp 0 
9de0 b7				or a 
9de1 28 08			jr z, .cptokendone2 
9de3 fe 20			cp ' ' 
9de5 28 02			jr z, .cptmp2 
9de7 18 ed			jr .cptokenstr2 
9de9			 
9de9			.cptmp2:	; we have a space so change to zero term for dict match later 
9de9				;dec hl 
9de9				;ld a,"-"	; TODO remove this when working 
9de9				;ld (hl), a 
9de9				;inc hl 
9de9 18 eb			jr .cptokenstr2 
9deb			 
9deb			.cptokendone2: 
9deb				;inc hl 
9deb			;	ld a, FORTH_END_BUFFER 
9deb 36 7f			ld (hl),FORTH_END_BUFFER 
9ded			;	inc hl 
9ded			;	ld a, '!' 
9ded			;	ld (hl),a 
9ded			 
9ded 2a b9 e5			ld hl,(os_tok_ptr) 
9df0			         
9df0			if DEBUG_FORTH_TOK 
9df0						DMARK "Tc1" 
9df0				CALLMONITOR 
9df0			endif 
9df0			 
9df0				; push exec string to top of return stack 
9df0				FORTH_RSP_NEXT 
9df0 cd 72 99			call macro_forth_rsp_next 
9df3				endm 
# End of macro FORTH_RSP_NEXT
9df3 c9				ret 
9df4			 
9df4			; Another go at the parser need to simplify the process 
9df4			 
9df4			forthparse: 
9df4			 
9df4			; 
9df4			; line parse: 
9df4			;       parse raw input buffer 
9df4			;       tokenise the words 
9df4			;       malloc new copy (for looping etc) 
9df4			;       copy to malloc + current pc in line to start of string and add line term 
9df4			;       save on new rsp 
9df4			; 
9df4			 
9df4			; hl to point to the line to tokenise 
9df4			 
9df4			;	push hl 
9df4 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9df7			 
9df7			;	ld a,0		; string term on input 
9df7			;	call strlent 
9df7			 
9df7			;	ld (os_tok_len), hl	 ; save string length 
9df7			 
9df7			;if DEBUG_FORTH_TOK 
9df7			;	ex de,hl		 
9df7			;endif 
9df7			 
9df7			;	pop hl 		; get back string pointer 
9df7			 
9df7			if DEBUG_FORTH_TOK 
9df7						DMARK "TOK" 
9df7				CALLMONITOR 
9df7			endif 
9df7 7e			.ptoken2:    ld a,(hl) 
9df8 23				inc hl 
9df9 fe 7f			cp FORTH_END_BUFFER 
9dfb 28 26			jr z, .ptokendone2 
9dfd			;	cp 0 
9dfd b7				or a 
9dfe 28 23			jr z, .ptokendone2 
9e00 fe 22			cp '"' 
9e02 28 0a			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9e04 fe 20			cp ' ' 
9e06 20 ef			jr nz,  .ptoken2 
9e08			 
9e08			; TODO consume comments held between ( and ) 
9e08			 
9e08				; we have a space so change to zero term for dict match later 
9e08 2b				dec hl 
9e09			;	ld a,0 
9e09 36 00			ld (hl), 0 
9e0b 23				inc hl 
9e0c 18 e9			jr .ptoken2 
9e0e				 
9e0e			 
9e0e			.ptokenstr2: 
9e0e				; skip all white space until either eol (because forgot to term) or end double quote 
9e0e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9e0e				;inc hl ; skip current double quote 
9e0e 7e				ld a,(hl) 
9e0f 23				inc hl 
9e10 fe 22			cp '"' 
9e12 28 e3			jr z, .ptoken2 
9e14 fe 7f			cp FORTH_END_BUFFER 
9e16 28 0b			jr z, .ptokendone2 
9e18			;	cp 0 
9e18 b7				or a 
9e19 28 08			jr z, .ptokendone2 
9e1b fe 20			cp ' ' 
9e1d 28 02			jr z, .ptmp2 
9e1f 18 ed			jr .ptokenstr2 
9e21			 
9e21			.ptmp2:	; we have a space so change to zero term for dict match later 
9e21				;dec hl 
9e21				;ld a,"-"	; TODO remove this when working 
9e21				;ld (hl), a 
9e21				;inc hl 
9e21 18 eb			jr .ptokenstr2 
9e23			 
9e23			.ptokendone2: 
9e23				;inc hl 
9e23			;	ld a, FORTH_END_BUFFER 
9e23 36 7f			ld (hl),FORTH_END_BUFFER 
9e25			;	inc hl 
9e25			;	ld a, '!' 
9e25			;	ld (hl),a 
9e25			 
9e25 2a b9 e5			ld hl,(os_tok_ptr) 
9e28			         
9e28			if DEBUG_FORTH_TOK 
9e28						DMARK "TK1" 
9e28				CALLMONITOR 
9e28			endif 
9e28			 
9e28				; push exec string to top of return stack 
9e28				FORTH_RSP_NEXT 
9e28 cd 72 99			call macro_forth_rsp_next 
9e2b				endm 
# End of macro FORTH_RSP_NEXT
9e2b c9				ret 
9e2c			 
9e2c			; 
9e2c			;	; malloc size + buffer pointer + if is loop flag 
9e2c			;	ld hl,(os_tok_len) 		 ; get string length 
9e2c			; 
9e2c			;	ld a,l 
9e2c			; 
9e2c			;	cp 0			; we dont want to use a null string 
9e2c			;	ret z 
9e2c			; 
9e2c			;;	add 3    ; prefix malloc with buffer for current word ptr 
9e2c			; 
9e2c			;	add 5     ; TODO when certain not over writing memory remove 
9e2c			; 
9e2c			;		 
9e2c			; 
9e2c			;if DEBUG_FORTH_TOK 
9e2c			;			DMARK "TKE" 
9e2c			;	CALLMONITOR 
9e2c			;endif 
9e2c			; 
9e2c			;	ld l,a 
9e2c			;	ld h,0 
9e2c			;;	push hl   ; save required space for the copy later 
9e2c			;	call malloc 
9e2c			;if DEBUG_FORTH_TOK 
9e2c			;			DMARK "TKM" 
9e2c			;	CALLMONITOR 
9e2c			;endif 
9e2c			;	if DEBUG_FORTH_MALLOC_GUARD 
9e2c			;		push af 
9e2c			;		call ishlzero 
9e2c			;;		ld a, l 
9e2c			;;		add h 
9e2c			;;		cp 0 
9e2c			;		pop af 
9e2c			;		 
9e2c			;		call z,malloc_error 
9e2c			;	endif 
9e2c			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9e2c			; 
9e2c			; 
9e2c			;if DEBUG_FORTH_TOK 
9e2c			;			DMARK "TKR" 
9e2c			;	CALLMONITOR 
9e2c			;endif 
9e2c			; 
9e2c			;	FORTH_RSP_NEXT 
9e2c			; 
9e2c			;	;inc hl	 ; go past current buffer pointer 
9e2c			;	;inc hl 
9e2c			;	;inc hl   ; and past if loop flag 
9e2c			;		; TODO Need to set flag  
9e2c			; 
9e2c			;	 
9e2c			;	 
9e2c			;	ex de,hl	; malloc is dest 
9e2c			;	ld hl, (os_tok_len) 
9e2c			;;	pop bc 
9e2c			;	ld c, l                
9e2c			;	ld b,0 
9e2c			;	ld hl, (os_tok_ptr) 
9e2c			; 
9e2c			;if DEBUG_FORTH_TOK 
9e2c			;			DMARK "TKT" 
9e2c			;	CALLMONITOR 
9e2c			;endif 
9e2c			; 
9e2c			;	; do str cpy 
9e2c			; 
9e2c			;	ldir      ; copy byte in hl to de 
9e2c			; 
9e2c			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9e2c			; 
9e2c			;if DEBUG_FORTH_TOK 
9e2c			; 
9e2c			;			DMARK "TKY" 
9e2c			;	CALLMONITOR 
9e2c			;endif 
9e2c			;	;ld a,0 
9e2c			;	;ld a,FORTH_END_BUFFER 
9e2c			;	ex de, hl 
9e2c			;	;dec hl			 ; go back over the space delim at the end of word 
9e2c			;	;ld (hl),a 
9e2c			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9e2c			;	ld a,FORTH_END_BUFFER 
9e2c			;	ld (hl),a 
9e2c			;	inc hl 
9e2c			;	ld a,FORTH_END_BUFFER 
9e2c			;	ld (hl),a 
9e2c			; 
9e2c			;	; init the malloc area data 
9e2c			;	; set pc for in current area 
9e2c			;	;ld hl, (os_tok_malloc) 
9e2c			;	;inc hl 
9e2c			;	;inc hl 
9e2c			;	;inc hl 
9e2c			;	;ex de,hl 
9e2c			;	;ld hl, (os_tok_malloc) 
9e2c			;	;ld (hl),e 
9e2c			;	;inc hl 
9e2c			;	;ld (hl),d 
9e2c			; 
9e2c			; 
9e2c			;	ld hl,(os_tok_malloc) 
9e2c			;if DEBUG_FORTH_PARSE_KEY 
9e2c			;			DMARK "TKU" 
9e2c			;	CALLMONITOR 
9e2c			;endif 
9e2c			; 
9e2c			;	ret 
9e2c			 
9e2c			forthexec: 
9e2c			 
9e2c			; line exec: 
9e2c			; forth parser 
9e2c			 
9e2c			; 
9e2c			;       get current exec line on rsp 
9e2c			 
9e2c				FORTH_RSP_TOS 
9e2c cd 89 99			call macro_forth_rsp_tos 
9e2f				endm 
# End of macro FORTH_RSP_TOS
9e2f			 
9e2f			;       restore current pc - hl points to malloc of data 
9e2f			 
9e2f				;ld e, (hl) 
9e2f				;inc hl 
9e2f				;ld d, (hl) 
9e2f				;ex de,hl 
9e2f			 
9e2f			 
9e2f			exec1: 
9e2f 22 b9 e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
9e32			 
9e32				; copy our PC to working vars  
9e32 22 37 ea			ld (cli_ptr), hl                    ; here 
9e35 22 35 ea			ld (cli_origptr), hl                ; here 
9e38			 
9e38 7e				ld a,(hl)                           ; here make hl be the ram ptr 
9e39 fe 7f			cp FORTH_END_BUFFER 
9e3b c8				ret z 
9e3c			 
9e3c				; skip any nulls 
9e3c			 
9e3c			;	cp 0 
9e3c b7				or a 
9e3d 20 03			jr nz, .execword 
9e3f 23				inc hl 
9e40 18 ed			jr exec1 
9e42			 
9e42			 
9e42			.execword: 
9e42			 
9e42			 
9e42			 
9e42			if DEBUG_FORTH_PARSE_EXEC 
9e42						DMARK "KYQ" 
9e42				CALLMONITOR 
9e42			endif 
9e42			;       while at start of word: 
9e42			; get start of dict (in user area first) 
9e42			 
9e42 21 95 e3		ld hl, baseram 
9e45			;ld hl, sysdict 
9e45 22 39 ea		ld (cli_nextword),hl                            ; here do we need to do this? 
9e48			;           match word at pc 
9e48			;           exec word 
9e48			;           or push to dsp 
9e48			;           forward to next token 
9e48			;           if line term pop rsp and exit 
9e48			;        
9e48			 
9e48			if DEBUG_FORTH_PARSE_EXEC 
9e48						DMARK "KYq" 
9e48				CALLMONITOR 
9e48			endif 
9e48			 
9e48			; 
9e48			; word comp 
9e48			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9e48			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9e48			;    move to start of word  
9e48			;    compare word to cli_token 
9e48			 
9e48			.execpnword:	; HL at start of a word in the dictionary to check 
9e48			 
9e48 2a 39 ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
9e4b			 
9e4b cd e0 9e			call forth_tok_next 
9e4e			; tok next end here 
9e4e 22 39 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9e51 eb				ex de, hl 
9e52			 
9e52			 
9e52				; save the pointer of the current token - 1 to check against 
9e52				 
9e52 22 3d ea			ld (cli_token), hl   
9e55				; TODO maybe remove below save if no debug 
9e55				; save token string ptr for any debug later 
9e55 23				inc hl  
9e56 22 3f ea			ld (cli_origtoken), hl 
9e59 2b				dec hl 
9e5a				; save pointer to the start of the next dictionay word 
9e5a 7e				ld a,(hl)   ; get string length 
9e5b 47				ld b,a 
9e5c			.execpnwordinc:  
9e5c 23				inc hl 
9e5d 10 fd			djnz .execpnwordinc 
9e5f 22 3b ea			ld (cli_execword), hl      ; save start of this words code 
9e62			 
9e62				; now check the word token against the string being parsed 
9e62			 
9e62 2a 3d ea			ld hl,(cli_token) 
9e65 23				inc hl     ; skip string length (use zero term instead to end) 
9e66				;ld (cli_token), hl 
9e66			 
9e66			.execpnchar:    ; compare char between token and string to parse 
9e66			 
9e66			 
9e66				;ld hl, (cli_token)     ; the dict word  
9e66 ed 5b 37 ea		ld de, (cli_ptr)     ; cli to parse 
9e6a			 
9e6a			 
9e6a			.execpncharl:    ; compare char between token and string to parse (loop) 
9e6a			 
9e6a 1a				ld a,(de) 
9e6b cd 25 90			call toUpper 		; make sure the input string matches case 
9e6e be				cp (hl) 
9e6f			 
9e6f c2 87 9e			jp nz, .execpnskipword	 ; no match so move to next word 
9e72				 
9e72			;    if same 
9e72			;       scan for string terms 0 for token and 32 for input 
9e72 46				ld b,(hl) 
9e73 80				add b			 
9e74 23				inc hl 
9e75 13				inc de 
9e76 b7				or a 
9e77			;	cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9e77							; TODO need to make sure last word in zero term string is accounted for 
9e77 20 f1			jr nz, .execpncharl 		 ; not at end of strings yet 
9e79			 
9e79			 
9e79				; at end of both strings so both are exact match 
9e79			 
9e79			;       skip ptr for next word 
9e79			 
9e79 2a 37 ea			ld hl,(cli_ptr) 	; at input string term 
9e7c 23				inc hl			 ; at next char 
9e7d 22 37 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9e80 22 35 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9e83				 
9e83				 
9e83			 
9e83			 
9e83			 
9e83			;       exec code block 
9e83			if DEBUG_FORTH_JP 
9e83				call clear_display 
9e83				call update_display 
9e83				call delay1s 
9e83				ld hl, (cli_execword)     ; save for next check if no match on this word 
9e83				ld a,h 
9e83				ld hl, os_word_scratch 
9e83				call hexout 
9e83				ld hl, (cli_execword)     ; save for next check if no match on this word 
9e83				ld a,l 
9e83				ld hl, os_word_scratch+2 
9e83				call hexout 
9e83				ld hl, os_word_scratch+4 
9e83			;	ld a,0 
9e83				ld (hl),0 
9e83				ld de,os_word_scratch 
9e83				call str_at_display 
9e83					ld a, display_row_2 
9e83					call str_at_display 
9e83				ld de, (cli_origtoken) 
9e83				ld a, display_row_1+10 
9e83					call str_at_display 
9e83			 
9e83				ld a,display_row_1 
9e83				ld de, .foundword 
9e83				ld a, display_row_3 
9e83				call str_at_display 
9e83				call update_display 
9e83				call delay1s 
9e83				call delay1s 
9e83				call delay1s 
9e83			endif 
9e83			 
9e83			if DEBUG_FORTH_PARSE_EXEC 
9e83						DMARK "KYj" 
9e83			endif 
9e83				; TODO save the word pointer in this exec 
9e83			 
9e83 2a 3b ea			ld hl,(cli_execword) 
9e86 e9				jp (hl) 
9e87			 
9e87			 
9e87			;    if not same 
9e87			;	scan for zero term 
9e87			;	get ptr for next word 
9e87			;	goto word comp 
9e87			 
9e87			.execpnskipword:	; get pointer to next word 
9e87 2a 39 ea			ld hl,(cli_nextword) 
9e8a			 
9e8a 7e				ld a,(hl) 
9e8b fe 00			cp WORD_SYS_END 
9e8d			;	cp 0 
9e8d 28 09			jr z, .execendofdict			 ; at end of words 
9e8f			 
9e8f			if DEBUG_FORTH_PARSE_EXEC 
9e8f						DMARK "KY4" 
9e8f			endif 
9e8f			if DEBUG_FORTH_PARSE_EXEC 
9e8f			 
9e8f				; see if disabled 
9e8f			 
9e8f			;	ld a, (os_view_disable) 
9e8f			;	cp '*' 
9e8f				ld a,(debug_vector) 
9e8f				cp $c9   ; RET 
9e8f				jr z, .noskip 
9e8f			 
9e8f			 
9e8f				ld de, .nowordfound 
9e8f				ld a, display_row_3 
9e8f				call str_at_display 
9e8f				call update_display 
9e8f				ld a, 100 
9e8f				call aDelayInMS 
9e8f				 
9e8f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e8f					call delay250ms 
9e8f				endif 
9e8f			.noskip:  
9e8f			 
9e8f			endif	 
9e8f			 
9e8f 2a 35 ea			ld hl,(cli_origptr) 
9e92 22 37 ea			ld (cli_ptr),hl 
9e95			 
9e95			if DEBUG_FORTH_PARSE_EXEC 
9e95						DMARK "KY5" 
9e95			endif 
9e95 c3 48 9e			jp .execpnword			; else go to next word 
9e98			 
9e98			.execendofdict:  
9e98			 
9e98			if DEBUG_FORTH_PARSE_EXEC 
9e98						DMARK "KYe" 
9e98			endif 
9e98			if DEBUG_FORTH_PARSE_EXEC 
9e98				; see if disabled 
9e98			 
9e98			;	ld a, (os_view_disable) 
9e98			;	cp '*' 
9e98				ld a,(debug_vector) 
9e98				cp $c9   ; ret 
9e98				jr z, .ispskip 
9e98			 
9e98				call clear_display 
9e98				call update_display 
9e98				call delay1s 
9e98				ld de, (cli_origptr) 
9e98				ld a, display_row_1 
9e98				call str_at_display 
9e98				 
9e98				ld de, .enddict 
9e98				ld a, display_row_3 
9e98				call str_at_display 
9e98				call update_display 
9e98				ld a, 100 
9e98				call aDelayInMS 
9e98				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9e98				call delay1s 
9e98				call delay1s 
9e98				call delay1s 
9e98				endif 
9e98			.ispskip:  
9e98				 
9e98			endif	 
9e98			 
9e98			 
9e98			 
9e98				; if the word is not a keyword then must be a literal so push it to stack 
9e98			 
9e98			; push token to stack to end of word 
9e98			 
9e98				STACKFRAME ON $1efe $2f9f 
9e98				if DEBUG_STACK_IMB 
9e98					if ON 
9e98						exx 
9e98						ld de, $1efe 
9e98						ld a, d 
9e98						ld hl, curframe 
9e98						call hexout 
9e98						ld a, e 
9e98						ld hl, curframe+2 
9e98						call hexout 
9e98						ld hl, $1efe 
9e98						push hl 
9e98						ld hl, $2f9f 
9e98						push hl 
9e98						exx 
9e98					endif 
9e98				endif 
9e98			endm 
# End of macro STACKFRAME
9e98			 
9e98 2a b9 e5		ld hl,(os_tok_ptr) 
9e9b cd 2d 9b		call forth_apush 
9e9e			 
9e9e				STACKFRAMECHK ON $1efe $2f9f 
9e9e				if DEBUG_STACK_IMB 
9e9e					if ON 
9e9e						exx 
9e9e						ld hl, $2f9f 
9e9e						pop de   ; $2f9f 
9e9e						call cmp16 
9e9e						jr nz, .spnosame 
9e9e						ld hl, $1efe 
9e9e						pop de   ; $1efe 
9e9e						call cmp16 
9e9e						jr z, .spfrsame 
9e9e						.spnosame: call showsperror 
9e9e						.spfrsame: nop 
9e9e						exx 
9e9e					endif 
9e9e				endif 
9e9e			endm 
# End of macro STACKFRAMECHK
9e9e			 
9e9e			execnext: 
9e9e			 
9e9e			if DEBUG_FORTH_PARSE_EXEC 
9e9e						DMARK "KY>" 
9e9e			endif 
9e9e			; move past token to next word 
9e9e			 
9e9e 2a b9 e5		ld hl, (os_tok_ptr) 
9ea1 3e 00		ld a, 0 
9ea3 01 ff 00		ld bc, 255     ; input buffer size 
9ea6 ed b1		cpir 
9ea8			 
9ea8			if DEBUG_FORTH_PARSE_EXEC 
9ea8						DMARK "KY!" 
9ea8				CALLMONITOR 
9ea8			endif	 
9ea8			; TODO this might place hl on the null, so will need to forward on??? 
9ea8			;inc hl   ; see if this gets onto the next item 
9ea8			 
9ea8			 
9ea8			; TODO pass a pointer to the buffer to push 
9ea8			; TODO call function to push 
9ea8			 
9ea8			; look for end of input 
9ea8			 
9ea8			;inc hl 
9ea8			;ld a,(hl) 
9ea8			;cp FORTH_END_BUFFER 
9ea8			;ret z 
9ea8			 
9ea8			 
9ea8 c3 2f 9e		jp exec1 
9eab			 
9eab			 
9eab			 
9eab			 
9eab			 
9eab			 
9eab			 
9eab			 
9eab			 
9eab			findnexttok: 
9eab			 
9eab				; hl is pointer to move 
9eab				; de is the token to locate 
9eab			 
9eab					if DEBUG_FORTH 
9eab						DMARK "NTK" 
9eab						CALLMONITOR 
9eab					endif 
9eab d5				push de 
9eac			 
9eac			.fnt1:	 
9eac				; find first char of token to locate 
9eac			 
9eac 1a				ld a, (de) 
9ead 4f				ld c,a 
9eae 7e				ld a,(hl) 
9eaf cd 25 90			call toUpper 
9eb2					if DEBUG_FORTH 
9eb2						DMARK "NT1" 
9eb2						CALLMONITOR 
9eb2					endif 
9eb2 b9				cp c 
9eb3			 
9eb3 28 03			jr z, .fnt2cmpmorefirst	 
9eb5			 
9eb5				; first char not found move to next char 
9eb5			 
9eb5 23				inc hl 
9eb6 18 f4			jr .fnt1 
9eb8			 
9eb8			.fnt2cmpmorefirst:	 
9eb8				; first char of token found.  
9eb8			 
9eb8 e5				push hl     ; save start of token just in case it is the right one 
9eb9 d9				exx 
9eba e1				pop hl        ; save it to hl' 
9ebb d9				exx 
9ebc			 
9ebc			 
9ebc			.fnt2cmpmore:	 
9ebc				; compare the rest 
9ebc				 
9ebc 23				inc hl 
9ebd 13				inc de 
9ebe				 
9ebe 1a				ld a, (de) 
9ebf 4f				ld c,a 
9ec0 7e				ld a,(hl) 
9ec1 cd 25 90			call toUpper 
9ec4			 
9ec4					if DEBUG_FORTH 
9ec4						DMARK "NT2" 
9ec4						CALLMONITOR 
9ec4					endif 
9ec4				; c has the token to find char 
9ec4				; a has the mem to scan char 
9ec4			 
9ec4 b9				cp c 
9ec5 28 04			jr z,.fntmatch1 
9ec7			 
9ec7				; they are not the same 
9ec7			 
9ec7					if DEBUG_FORTH 
9ec7						DMARK "NT3" 
9ec7						CALLMONITOR 
9ec7					endif 
9ec7 d1				pop de	; reset de token to look for 
9ec8 d5				push de 
9ec9 18 e1			jr .fnt1 
9ecb				 
9ecb			.fntmatch1: 
9ecb			 
9ecb				; is the same char a null which means we might have a full hit? 
9ecb					if DEBUG_FORTH 
9ecb						DMARK "NT4" 
9ecb						CALLMONITOR 
9ecb					endif 
9ecb			 
9ecb			;	cp 0 
9ecb b7				or a 
9ecc 28 0b			jr z, .fntmatchyes 
9ece			 
9ece				; are we at the end of the token to find? 
9ece			 
9ece					if DEBUG_FORTH 
9ece						DMARK "NT5" 
9ece						CALLMONITOR 
9ece					endif 
9ece 3e 00			ld a, 0 
9ed0 b9				cp c 
9ed1			 
9ed1 c2 bc 9e			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9ed4			 
9ed4					if DEBUG_FORTH 
9ed4						DMARK "NT6" 
9ed4						CALLMONITOR 
9ed4					endif 
9ed4				; token to find is exhusted but no match to stream 
9ed4			 
9ed4				; restore tok pointer and continue on 
9ed4 d1				pop de 
9ed5 d5				push de 
9ed6 c3 ac 9e			jp .fnt1 
9ed9			 
9ed9			 
9ed9			.fntmatchyes: 
9ed9			 
9ed9				; hl now contains the end of the found token 
9ed9			 
9ed9				; get rid of saved token pointer to find 
9ed9			 
9ed9 d1				pop de 
9eda			 
9eda					if DEBUG_FORTH 
9eda						DMARK "NT9" 
9eda						CALLMONITOR 
9eda					endif 
9eda			 
9eda				; hl will be on the null term so forward on 
9eda			 
9eda				; get back the saved start of the token 
9eda			 
9eda d9				exx 
9edb e5				push hl     ; save start of token just in case it is the right one 
9edc d9				exx 
9edd e1				pop hl        ; save it to hl 
9ede			 
9ede c9				ret 
9edf			 
9edf			 
9edf			; LIST needs to find a specific token   
9edf			; FORGET needs to find a spefici token 
9edf			 
9edf			; SAVE needs to find all tokens by flag 
9edf			; WORDS just needs to scan through all  by flag 
9edf			; UWORDS needs to scan through all by flag 
9edf			 
9edf			 
9edf			; given hl as pointer to start of dict look up string 
9edf			; return hl as pointer to start of word block 
9edf			; or 0 if not found 
9edf			 
9edf			forth_find_tok: 
9edf c9				ret 
9ee0			 
9ee0			; given hl as pointer to dict structure 
9ee0			; move to the next dict block structure 
9ee0			 
9ee0			forth_tok_next: 
9ee0				; hl now points to the address of the next word pointer  
9ee0				; TODO skip compiled symbol for now 
9ee0			;	push de 
9ee0 23				inc hl 
9ee1 5e				ld e, (hl) 
9ee2 23				inc hl 
9ee3 56				ld d, (hl) 
9ee4 23				inc hl 
9ee5			 
9ee5 eb				ex de,hl 
9ee6			if DEBUG_FORTH_PARSE_NEXTWORD 
9ee6				push bc 
9ee6				ld bc, (cli_nextword) 
9ee6						DMARK "NXW" 
9ee6				CALLMONITOR 
9ee6				pop bc 
9ee6			endif 
9ee6			;	pop de	 
9ee6 c9				ret 
9ee7			 
9ee7			 
9ee7			 
9ee7			; eof 
# End of file forth_parserv6.asm
9ee7				include "forth_wordsv4.asm" 
9ee7			 
9ee7			; the core word dictionary v4 
9ee7			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9ee7			 
9ee7			; this is a linked list for each of the system words used 
9ee7			; user defined words will follow the same format but will be in ram 
9ee7			 
9ee7			 
9ee7			; 
9ee7			; 
9ee7			; define linked list: 
9ee7			; 
9ee7			; 1. compiled byte op code 
9ee7			; 2. len of text word 
9ee7			; 3. text word 
9ee7			; 4. ptr to next dictionary word 
9ee7			; 5. asm, calls etc for the word 
9ee7			; 
9ee7			;  if 1 == 0 then last word in dict  
9ee7			;   
9ee7			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9ee7			;  
9ee7			;  
9ee7			; create basic standard set of words 
9ee7			; 
9ee7			;  
9ee7			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9ee7			; 2DUP 2DROP 2SWAP  
9ee7			; @ C@ - get byte  
9ee7			; ! C! - store byte 
9ee7			; 0< true if less than zero 
9ee7			; 0= true if zero 
9ee7			; < >  
9ee7			; = true if same 
9ee7			; variables 
9ee7			 
9ee7			 
9ee7			; Hardware specific words I may need 
9ee7			; 
9ee7			; IN OUT  
9ee7			; calls to key util functions 
9ee7			; calls to hardward abstraction stuff 
9ee7			; easy control of frame buffers and lcd i/o 
9ee7			; keyboard  
9ee7			 
9ee7			 
9ee7			;DICT: macro 
9ee7			; op_code, len, word, next 
9ee7			;    word: 
9ee7			;    db op_code 
9ee7			;    ds word zero term 
9ee7			;    dw next 
9ee7			;    endm 
9ee7			 
9ee7			 
9ee7			 
9ee7			 
9ee7			; op code 1 is a flag for user define words which are to be handled differently 
9ee7			 
9ee7			 
9ee7			; 
9ee7			; 
9ee7			;    TODO on entry to a word this should be the expected environment 
9ee7			;    hl - tos value if number then held, if string this is the ptr 
9ee7			;    de -  
9ee7			 
9ee7			 
9ee7			; opcode ranges 
9ee7			; 0 - end of word dict 
9ee7			; 255 - user define words 
9ee7			 
9ee7			sysdict: 
9ee7			include "forth_opcodes.asm" 
9ee7			; op codes for forth keywords 
9ee7			 
9ee7			; Changing use of opcodes to flag is the word exists in compiled form or not.  
9ee7			; This provides a means to compile uwords if required for higher performance 
9ee7			; by avoiding the use of the keyword parser and just jumping directly to the code 
9ee7			; Actually there is already a flag for if the code exists as binary thinking about it... 
9ee7			 
9ee7			 
9ee7			 
9ee7			 
9ee7			 
9ee7			; free to use code 0  
9ee7				OPCODE_HEAP: equ  1 
9ee7				OPCODE_EXEC: equ 2 
9ee7				OPCODE_DUP: equ 3 
9ee7				OPCODE_SWAP: equ 4 
9ee7				OPCODE_COLN: equ 5 
9ee7				OPCODE_SCOLN: equ 6 
9ee7				OPCODE_DROP: equ 7 
9ee7				OPCODE_DUP2: equ 8 
9ee7				OPCODE_DROP2: equ 9 
9ee7				OPCODE_SWAP2: equ 10 
9ee7				OPCODE_AT: equ 11 
9ee7				OPCODE_CAT: equ 12 
9ee7				OPCODE_BANG: equ 13 
9ee7				OPCODE_CBANG: equ 14 
9ee7				OPCODE_SCALL: equ 15 
9ee7				OPCODE_DEPTH: equ 16 
9ee7				OPCODE_OVER: equ 17 
9ee7				OPCODE_PAUSE: equ 18 
9ee7				OPCODE_PAUSES: equ 19 
9ee7				OPCODE_ROT: equ 20 
9ee7			;free to reuse	OPCODE_WORDS: equ 21 
9ee7			        OPCODE_NOT: equ 21 
9ee7				OPCODE_UWORDS: equ 22 
9ee7				OPCODE_BP: equ 23 
9ee7				OPCODE_MONITOR: equ 24  
9ee7				OPCODE_MALLOC: equ 25 
9ee7				OPCODE_FREE: equ 26 
9ee7				OPCODE_LIST: equ 27 
9ee7				OPCODE_FORGET: equ 28 
9ee7				OPCODE_NOP: equ 29 
9ee7				OPCODE_COMO: equ 30 
9ee7				OPCODE_COMC: equ 31 
9ee7			;free to reuse	OPCODE_ENDCORE: equ 32 
9ee7				OPCODE_AFTERSOUND: equ 33 
9ee7				OPCODE_GP2: equ 34 
9ee7				OPCODE_GP3: equ 35 
9ee7				OPCODE_GP4: equ 36 
9ee7				OPCODE_SIN: equ 37 
9ee7				OPCODE_SOUT: equ 38 
9ee7				OPCODE_SPIO: equ 39 
9ee7				OPCODE_SPICEH: equ 40 
9ee7				OPCODE_SPIOb: equ 41 
9ee7				OPCODE_SPII: equ 42 
9ee7				OPCODE_SESEL: equ 43 
9ee7				OPCODE_CARTDEV: equ 44 
9ee7			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9ee7				OPCODE_FB: equ 46 
9ee7				OPCODE_EMIT: equ 47 
9ee7				OPCODE_DOTH: equ 48 
9ee7				OPCODE_DOTF: equ 49 
9ee7				OPCODE_DOT: equ 50 
9ee7				OPCODE_CLS: equ 51 
9ee7				OPCODE_DRAW: equ 52 
9ee7				OPCODE_DUMP: equ 53 
9ee7				OPCODE_CDUMP: equ 54 
9ee7				OPCODE_DAT: equ 55 
9ee7				OPCODE_HOME: equ 56 
9ee7				OPCODE_SPACE: equ 57 
9ee7				OPCODE_SPACES: equ 58 
9ee7				OPCODE_SCROLL: equ 59 
9ee7				OPCODE_ATQ: equ 60 
9ee7				OPCODE_AUTODSP: equ 61 
9ee7				OPCODE_MENU: equ 62 
9ee7			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9ee7				OPCODE_THEN: equ 64 
9ee7				OPCODE_ELSE: equ 65 
9ee7				OPCODE_DO: equ 66 
9ee7				OPCODE_LOOP: equ 67 
9ee7				OPCODE_I: equ 68 
9ee7				OPCODE_DLOOP: equ 69  
9ee7				OPCODE_REPEAT: equ 70  
9ee7				OPCODE_UNTIL: equ 71 
9ee7				OPCODE_ENDFLOW: equ 72 
9ee7				OPCODE_WAITK: equ 73 
9ee7				OPCODE_ACCEPT: equ 74 
9ee7				OPCODE_EDIT: equ 75 
9ee7			;free to reuse	OPCODE_ENDKEY: equ 76 
9ee7				OPCODE_LZERO: equ 77 
9ee7				OPCODE_TZERO: equ 78 
9ee7				OPCODE_LESS: equ 79 
9ee7				OPCODE_GT: equ 80 
9ee7				OPCODE_EQUAL: equ 81  
9ee7			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9ee7				OPCODE_NEG: equ 83 
9ee7				OPCODE_DIV: equ 84 
9ee7				OPCODE_MUL: equ 85 
9ee7				OPCODE_MIN: equ 86 
9ee7				OPCODE_MAX: equ 87 
9ee7				OPCODE_RND16: equ 88 
9ee7				OPCODE_RND8: equ 89 
9ee7				OPCODE_RND: equ 90 
9ee7			;free to reuse	OPCODE_ENDMATHS: equ 91  
9ee7				OPCODE_BYNAME: equ 92 
9ee7				OPCODE_DIR: equ 93 
9ee7				OPCODE_SAVE: equ 94 
9ee7				OPCODE_LOAD: equ 95 
9ee7				OPCODE_BSAVE: equ 96 
9ee7				OPCODE_BLOAD: equ 97 
9ee7				OPCODE_SEO: equ 98  
9ee7				OPCODE_SEI: equ 99 
9ee7				OPCODE_SFREE: equ 100 
9ee7				OPCODE_SIZE: equ 101 
9ee7				OPCODE_CREATE: equ 102 
9ee7				OPCODE_APPEND: equ 103 
9ee7				OPCODE_SDEL: equ 104 
9ee7				OPCODE_OPEN: equ 105 
9ee7				OPCODE_READ: equ 106 
9ee7				OPCODE_EOF: equ 106 
9ee7				OPCODE_FORMAT: equ 107 
9ee7				OPCODE_LABEL: equ 108 
9ee7				OPCODE_LABELS: equ 109 
9ee7			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9ee7				OPCODE_UPPER: equ 111 
9ee7				OPCODE_LOWER: equ 112 
9ee7				OPCODE_SUBSTR: equ 113 
9ee7				OPCODE_LEFT: equ 114 
9ee7				OPCODE_RIGHT: equ 115 
9ee7				OPCODE_STR2NUM: equ 116 
9ee7				OPCODE_NUM2STR: equ 117 
9ee7				OPCODE_CONCAT: equ 118 
9ee7				OPCODE_FIND: equ 119 
9ee7				OPCODE_LEN: equ 120 
9ee7				OPCODE_CHAR: equ 121 
9ee7			; free to reuse	OPCODE_STRLEN: equ 122 
9ee7			; free to reuse	OPCODE_ENDSTR: equ 123 
9ee7				OPCODE_V0S: equ 124 
9ee7				OPCODE_V0Q: equ 125 
9ee7				OPCODE_V1S: equ 126 
9ee7				OPCODE_V1Q: equ 127 
9ee7				OPCODE_V2S: equ 128 
9ee7				OPCODE_V2Q: equ 129 
9ee7				OPCODE_V3S: equ 130 
9ee7				OPCODE_V3Q: equ 131 
9ee7			;free to reuse	OPCODE_END: equ 132 
9ee7				OPCODE_ZDUP: equ 133 
9ee7			 
9ee7			; eof 
# End of file forth_opcodes.asm
9ee7			 
9ee7			include "forth_words_core.asm" 
9ee7			 
9ee7			; | ## Core Words 
9ee7			 
9ee7			;if MALLOC_4 
9ee7			 
9ee7			.HEAP: 
9ee7			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9ee7 15				db WORD_SYS_CORE+OPCODE_HEAP             
9ee8 29 9f			dw .EXEC            
9eea 05				db 4 + 1 
9eeb .. 00			db "HEAP",0              
9ef0				endm 
# End of macro CWHEAD
9ef0			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9ef0			; | | u1 - Current number of bytes in the heap 
9ef0			; | | u2 - Remaining bytes left on the heap 
9ef0			; | |  
9ef0			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9ef0			 
9ef0			 
9ef0				if DEBUG_FORTH_WORDS_KEY 
9ef0					DMARK "HEP" 
9ef0 f5				push af  
9ef1 3a 05 9f			ld a, (.dmark)  
9ef4 32 62 ee			ld (debug_mark),a  
9ef7 3a 06 9f			ld a, (.dmark+1)  
9efa 32 63 ee			ld (debug_mark+1),a  
9efd 3a 07 9f			ld a, (.dmark+2)  
9f00 32 64 ee			ld (debug_mark+2),a  
9f03 18 03			jr .pastdmark  
9f05 ..			.dmark: db "HEP"  
9f08 f1			.pastdmark: pop af  
9f09			endm  
# End of macro DMARK
9f09					CALLMONITOR 
9f09 cd 6f ee			call debug_vector  
9f0c				endm  
# End of macro CALLMONITOR
9f0c				endif 
9f0c 2a 9f e3			ld hl, (free_list )      
9f0f 11 a4 e3			ld de, heap_start 
9f12			 
9f12 ed 52			sbc hl, de  
9f14			 
9f14 cd cb 99			call forth_push_numhl 
9f17			 
9f17			 
9f17 ed 5b 9f e3		ld de, (free_list )      
9f1b 21 93 e2			ld hl, heap_end 
9f1e			 
9f1e ed 52			sbc hl, de 
9f20			 
9f20 cd cb 99			call forth_push_numhl 
9f23				 
9f23			 
9f23				 
9f23			 
9f23			 
9f23			 
9f23				NEXTW 
9f23 cd 6c ee			call parse_vector 
9f26 c3 ae 9d			jp macro_next 
9f29				endm 
# End of macro NEXTW
9f29			;endif 
9f29			 
9f29			.EXEC: 
9f29			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9f29			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9f29			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9f29			;; > > 
9f29			;; > >   
9f29			;	STACKFRAME OFF $5efe $5f9f 
9f29			; 
9f29			;		if DEBUG_FORTH_WORDS_KEY 
9f29			;			DMARK "EXE" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			; 
9f29			;	FORTH_DSP_VALUEHL 
9f29			; 
9f29			;	FORTH_DSP_POP 
9f29			; 
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EX1" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			;;	ld e,(hl) 
9f29			;;	inc hl 
9f29			;;	ld d,(hl) 
9f29			;;	ex de,hl 
9f29			; 
9f29			;;		if DEBUG_FORTH_WORDS 
9f29			;;			DMARK "EX2" 
9f29			;;			CALLMONITOR 
9f29			;;		endif 
9f29			;	push hl 
9f29			; 
9f29			;	;ld a, 0 
9f29			;	;ld a, FORTH_END_BUFFER 
9f29			;	call strlenz 
9f29			;	inc hl   ; include zero term to copy 
9f29			;	inc hl   ; include term 
9f29			;	inc hl   ; include term 
9f29			;	ld b,0 
9f29			;	ld c,l 
9f29			;	pop hl 
9f29			;	ld de, execscratch 
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EX3" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			;	ldir 
9f29			; 
9f29			; 
9f29			;	ld hl, execscratch 
9f29			; 
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EXe" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			; 
9f29			;	call forthparse 
9f29			;	call forthexec 
9f29			;;	call forthexec_cleanup 
9f29			;;	call forthparse 
9f29			;;	call forthexec 
9f29			; 
9f29			;	STACKFRAMECHK OFF $5efe $5f9f 
9f29			; 
9f29			;	; an immediate word so no need to process any more words 
9f29			;	ret 
9f29			;	NEXTW 
9f29			 
9f29			; dead code - old version  
9f29			;	FORTH_RSP_NEXT 
9f29			 
9f29			;  
9f29			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9f29			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9f29			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9f29			;	push hl 
9f29			;	push de 
9f29			;	push bc 
9f29			; 
9f29			; 
9f29			;		if DEBUG_FORTH_WORDS_KEY 
9f29			;			DMARK "EXR" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			; 
9f29			; 
9f29			; 
9f29			;	;v5 FORTH_DSP_VALUE 
9f29			;	FORTH_DSP_VALUEHL 
9f29			; 
9f29			;	; TODO do string type checks 
9f29			; 
9f29			;;v5	inc hl   ; skip type 
9f29			; 
9f29			;	push hl  ; source code  
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EX1" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			;	ld a, 0 
9f29			;	call strlent 
9f29			; 
9f29			;	inc hl 
9f29			;	inc hl 
9f29			;	inc hl 
9f29			;	inc hl 
9f29			; 
9f29			;	push hl    ; size 
9f29			; 
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EX2" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			;	call malloc 
9f29			; 
9f29			;	ex de, hl    ; de now contains malloc area 
9f29			;	pop bc   	; get byte count 
9f29			;	pop hl      ; get string to copy 
9f29			; 
9f29			;	push de     ; save malloc for free later 
9f29			; 
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EX3" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			;	ldir       ; duplicate string 
9f29			; 
9f29			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9f29			;	 
9f29			;	; TODO fix the parse would be better than this...  
9f29			;	ex de, hl 
9f29			;	dec hl 
9f29			;	ld a, 0 
9f29			;	ld (hl), a 
9f29			;	dec hl 
9f29			;	ld a, ' ' 
9f29			;	ld (hl), a 
9f29			;	dec hl 
9f29			;	ld (hl), a 
9f29			; 
9f29			;	dec hl 
9f29			;	ld (hl), a 
9f29			; 
9f29			; 
9f29			;	FORTH_DSP_POP  
9f29			; 
9f29			;	pop hl     
9f29			;	push hl    ; save malloc area 
9f29			; 
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EX4" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			; 
9f29			;	call forthparse 
9f29			;	call forthexec 
9f29			;	 
9f29			;	pop hl 
9f29			;	if DEBUG_FORTH_WORDS 
9f29			;		DMARK "EX5" 
9f29			;		CALLMONITOR 
9f29			;	endif 
9f29			; 
9f29			;	if FORTH_ENABLE_FREE 
9f29			;	call free 
9f29			;	endif 
9f29			; 
9f29			;	if DEBUG_FORTH_WORDS 
9f29			;		DMARK "EX6" 
9f29			;		CALLMONITOR 
9f29			;	endif 
9f29			; 
9f29			;	pop bc 
9f29			;	pop de 
9f29			;	pop hl 
9f29			;;	FORTH_RSP_POP	  
9f29			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9f29			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9f29			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9f29			; 
9f29			;	if DEBUG_FORTH_WORDS 
9f29			;		DMARK "EX7" 
9f29			;		CALLMONITOR 
9f29			;	endif 
9f29			;	NEXTW 
9f29			 
9f29			;.STKEXEC: 
9f29			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9f29			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9f29			; 
9f29			; 
9f29			;		if DEBUG_FORTH_WORDS_KEY 
9f29			;			DMARK "STX" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			; 
9f29			;	FORTH_DSP_VALUEHL 
9f29			; 
9f29			;	ld (store_tmp1), hl    ; count 
9f29			; 
9f29			;	FORTH_DSP_POP 
9f29			;.stkexec1: 
9f29			;	ld hl, (store_tmp1)   ; count 
9f29			;	ld a, 0 
9f29			;	cp l 
9f29			;	ret z 
9f29			; 
9f29			;	dec hl 
9f29			;	ld (store_tmp1), hl    ; count 
9f29			;	 
9f29			;	FORTH_DSP_VALUEHL 
9f29			;	push hl 
9f29			;	 
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EXp" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			;	FORTH_DSP_POP 
9f29			; 
9f29			;	call strlenz 
9f29			;	inc hl   ; include zero term to copy 
9f29			;	inc hl   ; include zero term to copy 
9f29			;	inc hl   ; include zero term to copy 
9f29			;	ld b,0 
9f29			;	ld c,l 
9f29			;	pop hl 
9f29			;	ld de, execscratch 
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EX3" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			;	ldir 
9f29			; 
9f29			; 
9f29			;	ld hl, execscratch 
9f29			; 
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EXP" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			; 
9f29			;	call forthparse 
9f29			;	ld hl, execscratch 
9f29			;		if DEBUG_FORTH_WORDS 
9f29			;			DMARK "EXx" 
9f29			;			CALLMONITOR 
9f29			;		endif 
9f29			;	call forthexec 
9f29			; 
9f29			;	jp .stkexec1 
9f29			; 
9f29			;	ret 
9f29			 
9f29			 
9f29			.DUP: 
9f29			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9f29 17				db WORD_SYS_CORE+OPCODE_DUP             
9f2a a5 9f			dw .ZDUP            
9f2c 04				db 3 + 1 
9f2d .. 00			db "DUP",0              
9f31				endm 
# End of macro CWHEAD
9f31			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9f31			; | | >[!NOTE] 
9f31			; | | > If the duplicated item is a string it is safely duplicated 
9f31			 
9f31				if DEBUG_FORTH_WORDS_KEY 
9f31					DMARK "DUP" 
9f31 f5				push af  
9f32 3a 46 9f			ld a, (.dmark)  
9f35 32 62 ee			ld (debug_mark),a  
9f38 3a 47 9f			ld a, (.dmark+1)  
9f3b 32 63 ee			ld (debug_mark+1),a  
9f3e 3a 48 9f			ld a, (.dmark+2)  
9f41 32 64 ee			ld (debug_mark+2),a  
9f44 18 03			jr .pastdmark  
9f46 ..			.dmark: db "DUP"  
9f49 f1			.pastdmark: pop af  
9f4a			endm  
# End of macro DMARK
9f4a					CALLMONITOR 
9f4a cd 6f ee			call debug_vector  
9f4d				endm  
# End of macro CALLMONITOR
9f4d				endif 
9f4d			 
9f4d				FORTH_DSP 
9f4d cd 8d 9b			call macro_forth_dsp 
9f50				endm 
# End of macro FORTH_DSP
9f50			 
9f50 7e				ld a, (HL) 
9f51 fe 01			cp DS_TYPE_STR 
9f53 20 28			jr nz, .dupinum 
9f55			 
9f55				; push another string 
9f55			 
9f55				FORTH_DSP_VALUEHL     		 
9f55 cd c7 9b			call macro_dsp_valuehl 
9f58				endm 
# End of macro FORTH_DSP_VALUEHL
9f58			 
9f58			if DEBUG_FORTH_WORDS 
9f58				DMARK "DUs" 
9f58 f5				push af  
9f59 3a 6d 9f			ld a, (.dmark)  
9f5c 32 62 ee			ld (debug_mark),a  
9f5f 3a 6e 9f			ld a, (.dmark+1)  
9f62 32 63 ee			ld (debug_mark+1),a  
9f65 3a 6f 9f			ld a, (.dmark+2)  
9f68 32 64 ee			ld (debug_mark+2),a  
9f6b 18 03			jr .pastdmark  
9f6d ..			.dmark: db "DUs"  
9f70 f1			.pastdmark: pop af  
9f71			endm  
# End of macro DMARK
9f71				CALLMONITOR 
9f71 cd 6f ee			call debug_vector  
9f74				endm  
# End of macro CALLMONITOR
9f74			endif 
9f74 cd 35 9a			call forth_push_str 
9f77			 
9f77				NEXTW 
9f77 cd 6c ee			call parse_vector 
9f7a c3 ae 9d			jp macro_next 
9f7d				endm 
# End of macro NEXTW
9f7d			 
9f7d			 
9f7d			.dupinum: 
9f7d				 
9f7d			 
9f7d			 
9f7d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f7d cd c7 9b			call macro_dsp_valuehl 
9f80				endm 
# End of macro FORTH_DSP_VALUEHL
9f80			 
9f80			; TODO add floating point number detection 
9f80			 
9f80			if DEBUG_FORTH_WORDS 
9f80				DMARK "DUi" 
9f80 f5				push af  
9f81 3a 95 9f			ld a, (.dmark)  
9f84 32 62 ee			ld (debug_mark),a  
9f87 3a 96 9f			ld a, (.dmark+1)  
9f8a 32 63 ee			ld (debug_mark+1),a  
9f8d 3a 97 9f			ld a, (.dmark+2)  
9f90 32 64 ee			ld (debug_mark+2),a  
9f93 18 03			jr .pastdmark  
9f95 ..			.dmark: db "DUi"  
9f98 f1			.pastdmark: pop af  
9f99			endm  
# End of macro DMARK
9f99				CALLMONITOR 
9f99 cd 6f ee			call debug_vector  
9f9c				endm  
# End of macro CALLMONITOR
9f9c			endif 
9f9c			 
9f9c cd cb 99			call forth_push_numhl 
9f9f				NEXTW 
9f9f cd 6c ee			call parse_vector 
9fa2 c3 ae 9d			jp macro_next 
9fa5				endm 
# End of macro NEXTW
9fa5			.ZDUP: 
9fa5			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9fa5 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9fa6 df 9f			dw .DMRK            
9fa8 05				db 4 + 1 
9fa9 .. 00			db "?DUP",0              
9fae				endm 
# End of macro CWHEAD
9fae			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
9fae			; | | >[!NOTE] 
9fae			; | | > If the duplicated item is a string it is not safely duplicated and remain as pointer to the origin 
9fae			 
9fae				if DEBUG_FORTH_WORDS_KEY 
9fae					DMARK "qDU" 
9fae f5				push af  
9faf 3a c3 9f			ld a, (.dmark)  
9fb2 32 62 ee			ld (debug_mark),a  
9fb5 3a c4 9f			ld a, (.dmark+1)  
9fb8 32 63 ee			ld (debug_mark+1),a  
9fbb 3a c5 9f			ld a, (.dmark+2)  
9fbe 32 64 ee			ld (debug_mark+2),a  
9fc1 18 03			jr .pastdmark  
9fc3 ..			.dmark: db "qDU"  
9fc6 f1			.pastdmark: pop af  
9fc7			endm  
# End of macro DMARK
9fc7					CALLMONITOR 
9fc7 cd 6f ee			call debug_vector  
9fca				endm  
# End of macro CALLMONITOR
9fca				endif 
9fca				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9fca cd c7 9b			call macro_dsp_valuehl 
9fcd				endm 
# End of macro FORTH_DSP_VALUEHL
9fcd			 
9fcd e5				push hl 
9fce			 
9fce				; is it a zero? 
9fce			 
9fce 3e 00			ld a, 0 
9fd0 84				add h 
9fd1 85				add l 
9fd2			 
9fd2 e1				pop hl 
9fd3			 
9fd3			;	cp 0 
9fd3 b7				or a 
9fd4 28 03			jr z, .dup2orig 
9fd6			 
9fd6			 
9fd6 cd cb 99			call forth_push_numhl 
9fd9			 
9fd9			 
9fd9			; TODO add floating point number detection 
9fd9			 
9fd9			.dup2orig: 
9fd9			 
9fd9				NEXTW 
9fd9 cd 6c ee			call parse_vector 
9fdc c3 ae 9d			jp macro_next 
9fdf				endm 
# End of macro NEXTW
9fdf			.DMRK: 
9fdf			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
9fdf 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9fe0 1f a0			dw .LSHIFT            
9fe2 06				db 5 + 1 
9fe3 .. 00			db "DMARK",0              
9fe9				endm 
# End of macro CWHEAD
9fe9			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
9fe9			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
9fe9				if DEBUG_FORTH_WORDS_KEY 
9fe9					DMARK "DMK" 
9fe9 f5				push af  
9fea 3a fe 9f			ld a, (.dmark)  
9fed 32 62 ee			ld (debug_mark),a  
9ff0 3a ff 9f			ld a, (.dmark+1)  
9ff3 32 63 ee			ld (debug_mark+1),a  
9ff6 3a 00 a0			ld a, (.dmark+2)  
9ff9 32 64 ee			ld (debug_mark+2),a  
9ffc 18 03			jr .pastdmark  
9ffe ..			.dmark: db "DMK"  
a001 f1			.pastdmark: pop af  
a002			endm  
# End of macro DMARK
a002					CALLMONITOR 
a002 cd 6f ee			call debug_vector  
a005				endm  
# End of macro CALLMONITOR
a005				endif 
a005				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a005 cd c7 9b			call macro_dsp_valuehl 
a008				endm 
# End of macro FORTH_DSP_VALUEHL
a008			 
a008 7e				ld a, (hl) 
a009 32 62 ee			ld (debug_mark),a 
a00c 23				inc hl 
a00d 7e				ld a, (hl) 
a00e 32 63 ee			ld (debug_mark+1),a 
a011 23				inc hl 
a012 7e				ld a, (hl) 
a013 32 64 ee			ld (debug_mark+2),a 
a016			 
a016			 
a016				FORTH_DSP_POP 
a016 cd 7f 9c			call macro_forth_dsp_pop 
a019				endm 
# End of macro FORTH_DSP_POP
a019				NEXTW 
a019 cd 6c ee			call parse_vector 
a01c c3 ae 9d			jp macro_next 
a01f				endm 
# End of macro NEXTW
a01f			.LSHIFT: 
a01f			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
a01f 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a020 56 a0			dw .RSHIFT            
a022 07				db 6 + 1 
a023 .. 00			db "LSHIFT",0              
a02a				endm 
# End of macro CWHEAD
a02a			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
a02a				if DEBUG_FORTH_WORDS_KEY 
a02a					DMARK "LSH" 
a02a f5				push af  
a02b 3a 3f a0			ld a, (.dmark)  
a02e 32 62 ee			ld (debug_mark),a  
a031 3a 40 a0			ld a, (.dmark+1)  
a034 32 63 ee			ld (debug_mark+1),a  
a037 3a 41 a0			ld a, (.dmark+2)  
a03a 32 64 ee			ld (debug_mark+2),a  
a03d 18 03			jr .pastdmark  
a03f ..			.dmark: db "LSH"  
a042 f1			.pastdmark: pop af  
a043			endm  
# End of macro DMARK
a043					CALLMONITOR 
a043 cd 6f ee			call debug_vector  
a046				endm  
# End of macro CALLMONITOR
a046				endif 
a046				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a046 cd c7 9b			call macro_dsp_valuehl 
a049				endm 
# End of macro FORTH_DSP_VALUEHL
a049				FORTH_DSP_POP 
a049 cd 7f 9c			call macro_forth_dsp_pop 
a04c				endm 
# End of macro FORTH_DSP_POP
a04c			 
a04c 29				add hl, hl 
a04d cd cb 99			call forth_push_numhl 
a050				NEXTW 
a050 cd 6c ee			call parse_vector 
a053 c3 ae 9d			jp macro_next 
a056				endm 
# End of macro NEXTW
a056			.RSHIFT: 
a056			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
a056 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a057 90 a0			dw .SWAP            
a059 07				db 6 + 1 
a05a .. 00			db "RSHIFT",0              
a061				endm 
# End of macro CWHEAD
a061			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
a061				if DEBUG_FORTH_WORDS_KEY 
a061					DMARK "RSH" 
a061 f5				push af  
a062 3a 76 a0			ld a, (.dmark)  
a065 32 62 ee			ld (debug_mark),a  
a068 3a 77 a0			ld a, (.dmark+1)  
a06b 32 63 ee			ld (debug_mark+1),a  
a06e 3a 78 a0			ld a, (.dmark+2)  
a071 32 64 ee			ld (debug_mark+2),a  
a074 18 03			jr .pastdmark  
a076 ..			.dmark: db "RSH"  
a079 f1			.pastdmark: pop af  
a07a			endm  
# End of macro DMARK
a07a					CALLMONITOR 
a07a cd 6f ee			call debug_vector  
a07d				endm  
# End of macro CALLMONITOR
a07d				endif 
a07d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a07d cd c7 9b			call macro_dsp_valuehl 
a080				endm 
# End of macro FORTH_DSP_VALUEHL
a080				FORTH_DSP_POP 
a080 cd 7f 9c			call macro_forth_dsp_pop 
a083				endm 
# End of macro FORTH_DSP_POP
a083 cb 3c			srl h 
a085 cb 1d			rr l 
a087 cd cb 99			call forth_push_numhl 
a08a				NEXTW 
a08a cd 6c ee			call parse_vector 
a08d c3 ae 9d			jp macro_next 
a090				endm 
# End of macro NEXTW
a090			.SWAP: 
a090			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a090 18				db WORD_SYS_CORE+OPCODE_SWAP             
a091 e7 a0			dw .COLN            
a093 05				db 4 + 1 
a094 .. 00			db "SWAP",0              
a099				endm 
# End of macro CWHEAD
a099			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a099				if DEBUG_FORTH_WORDS_KEY 
a099					DMARK "SWP" 
a099 f5				push af  
a09a 3a ae a0			ld a, (.dmark)  
a09d 32 62 ee			ld (debug_mark),a  
a0a0 3a af a0			ld a, (.dmark+1)  
a0a3 32 63 ee			ld (debug_mark+1),a  
a0a6 3a b0 a0			ld a, (.dmark+2)  
a0a9 32 64 ee			ld (debug_mark+2),a  
a0ac 18 03			jr .pastdmark  
a0ae ..			.dmark: db "SWP"  
a0b1 f1			.pastdmark: pop af  
a0b2			endm  
# End of macro DMARK
a0b2					CALLMONITOR 
a0b2 cd 6f ee			call debug_vector  
a0b5				endm  
# End of macro CALLMONITOR
a0b5				endif 
a0b5			 
a0b5			; DONE Use os stack swap memory 
a0b5			 
a0b5				FORTH_DSP_PTR 0     ; TOS 
a0b5 2a e5 e9			ld hl,(cli_data_sp) 
a0b8 11 00 00			ld de, 0 * 3 
a0bb ed 52			sbc hl, de 
a0bd				endm 
# End of macro FORTH_DSP_PTR
a0bd cd fe 9c			call hltostack1 
a0c0			  
a0c0				FORTH_DSP_PTR 1     ; TOS 
a0c0 2a e5 e9			ld hl,(cli_data_sp) 
a0c3 11 03 00			ld de, 1 * 3 
a0c6 ed 52			sbc hl, de 
a0c8				endm 
# End of macro FORTH_DSP_PTR
a0c8 cd 04 9d			call hltostack2 
a0cb			 
a0cb				FORTH_DSP_PTR 0     ; TOS 
a0cb 2a e5 e9			ld hl,(cli_data_sp) 
a0ce 11 00 00			ld de, 0 * 3 
a0d1 ed 52			sbc hl, de 
a0d3				endm 
# End of macro FORTH_DSP_PTR
a0d3 cd 1c 9d			call hlfromstack2 
a0d6			 
a0d6				FORTH_DSP_PTR 1     ; TOS 
a0d6 2a e5 e9			ld hl,(cli_data_sp) 
a0d9 11 03 00			ld de, 1 * 3 
a0dc ed 52			sbc hl, de 
a0de				endm 
# End of macro FORTH_DSP_PTR
a0de cd 16 9d			call hlfromstack1 
a0e1			;	FORTH_DSP_VALUEHL 
a0e1			;	push hl     ; w2 
a0e1			; 
a0e1			;	FORTH_DSP_POP 
a0e1			; 
a0e1			;	FORTH_DSP_VALUEHL 
a0e1			; 
a0e1			;	FORTH_DSP_POP 
a0e1			; 
a0e1			;	pop de     ; w2	, hl = w1 
a0e1			; 
a0e1			;	ex de, hl 
a0e1			;	push de 
a0e1			; 
a0e1			;	call forth_push_numhl 
a0e1			; 
a0e1			;	pop hl 
a0e1			; 
a0e1			;	call forth_push_numhl 
a0e1				 
a0e1			 
a0e1				NEXTW 
a0e1 cd 6c ee			call parse_vector 
a0e4 c3 ae 9d			jp macro_next 
a0e7				endm 
# End of macro NEXTW
a0e7			.COLN: 
a0e7			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a0e7 19				db WORD_SYS_CORE+OPCODE_COLN             
a0e8 72 a2			dw .SCOLN            
a0ea 02				db 1 + 1 
a0eb .. 00			db ":",0              
a0ed				endm 
# End of macro CWHEAD
a0ed			; | : ( -- )         Create new word | DONE 
a0ed			 
a0ed				if DEBUG_FORTH_WORDS_KEY 
a0ed					DMARK "CLN" 
a0ed f5				push af  
a0ee 3a 02 a1			ld a, (.dmark)  
a0f1 32 62 ee			ld (debug_mark),a  
a0f4 3a 03 a1			ld a, (.dmark+1)  
a0f7 32 63 ee			ld (debug_mark+1),a  
a0fa 3a 04 a1			ld a, (.dmark+2)  
a0fd 32 64 ee			ld (debug_mark+2),a  
a100 18 03			jr .pastdmark  
a102 ..			.dmark: db "CLN"  
a105 f1			.pastdmark: pop af  
a106			endm  
# End of macro DMARK
a106					CALLMONITOR 
a106 cd 6f ee			call debug_vector  
a109				endm  
# End of macro CALLMONITOR
a109				endif 
a109			STACKFRAME OFF $8efe $989f 
a109				if DEBUG_STACK_IMB 
a109					if OFF 
a109						exx 
a109						ld de, $8efe 
a109						ld a, d 
a109						ld hl, curframe 
a109						call hexout 
a109						ld a, e 
a109						ld hl, curframe+2 
a109						call hexout 
a109						ld hl, $8efe 
a109						push hl 
a109						ld hl, $989f 
a109						push hl 
a109						exx 
a109					endif 
a109				endif 
a109			endm 
# End of macro STACKFRAME
a109			; get parser buffer length  of new word 
a109			 
a109			 
a109			 
a109				; move tok past this to start of name defintition 
a109				; TODO get word to define 
a109				; TODO Move past word token 
a109				; TODO get length of string up to the ';' 
a109			 
a109 2a b9 e5		ld hl, (os_tok_ptr) 
a10c 23			inc hl 
a10d 23			inc hl 
a10e			 
a10e 3e 3b		ld a, ';' 
a110 cd 39 90		call strlent 
a113			 
a113 7d			ld a,l 
a114 32 a8 e2		ld (os_new_parse_len), a 
a117			 
a117			 
a117			if DEBUG_FORTH_UWORD 
a117 ed 5b b9 e5	ld de, (os_tok_ptr) 
a11b					DMARK ":01" 
a11b f5				push af  
a11c 3a 30 a1			ld a, (.dmark)  
a11f 32 62 ee			ld (debug_mark),a  
a122 3a 31 a1			ld a, (.dmark+1)  
a125 32 63 ee			ld (debug_mark+1),a  
a128 3a 32 a1			ld a, (.dmark+2)  
a12b 32 64 ee			ld (debug_mark+2),a  
a12e 18 03			jr .pastdmark  
a130 ..			.dmark: db ":01"  
a133 f1			.pastdmark: pop af  
a134			endm  
# End of macro DMARK
a134			CALLMONITOR 
a134 cd 6f ee			call debug_vector  
a137				endm  
# End of macro CALLMONITOR
a137			endif 
a137			 
a137			; 
a137			;  new word memory layout: 
a137			;  
a137			;    : adg 6666 ;  
a137			; 
a137			;    db   1     ; user defined word  
a137 23			inc hl    
a138			;    dw   sysdict 
a138 23			inc hl 
a139 23			inc hl 
a13a			;    db <word len>+1 (for null) 
a13a 23			inc hl 
a13b			;    db .... <word> 
a13b			; 
a13b			 
a13b 23			inc hl    ; some extras for the word preamble before the above 
a13c 23			inc hl 
a13d 23			inc hl 
a13e 23			inc hl 
a13f 23			inc hl 
a140 23			inc hl 
a141 23			inc hl  
a142 23			inc hl 
a143 23			inc hl 
a144 23			inc hl 
a145 23			inc hl 
a146 23			inc hl 
a147 23			inc hl 
a148 23			inc hl     ; TODO how many do we really need?     maybe only 6 
a149			;       exec word buffer 
a149			;	<ptr word>   
a149 23			inc hl 
a14a 23			inc hl 
a14b			;       <word list><null term> 7F final term 
a14b			 
a14b			 
a14b			if DEBUG_FORTH_UWORD 
a14b					DMARK ":02" 
a14b f5				push af  
a14c 3a 60 a1			ld a, (.dmark)  
a14f 32 62 ee			ld (debug_mark),a  
a152 3a 61 a1			ld a, (.dmark+1)  
a155 32 63 ee			ld (debug_mark+1),a  
a158 3a 62 a1			ld a, (.dmark+2)  
a15b 32 64 ee			ld (debug_mark+2),a  
a15e 18 03			jr .pastdmark  
a160 ..			.dmark: db ":02"  
a163 f1			.pastdmark: pop af  
a164			endm  
# End of macro DMARK
a164			CALLMONITOR 
a164 cd 6f ee			call debug_vector  
a167				endm  
# End of macro CALLMONITOR
a167			endif 
a167			 
a167			 
a167				; malloc the size 
a167			 
a167 cd a2 90			call malloc 
a16a 22 aa e2			ld (os_new_malloc), hl     ; save malloc start 
a16d			 
a16d			;    db   1     ; user defined word  
a16d			;	ld a, WORD_SYS_UWORD  
a16d 36 01			ld (hl), WORD_SYS_UWORD 
a16f			 
a16f 23			inc hl    
a170			;    dw   sysdict 
a170 11 e7 9e		ld de, sysdict       ; continue on with the scan to the system dict 
a173 73			ld (hl), e 
a174 23			inc hl 
a175 72			ld (hl), d 
a176 23			inc hl 
a177			 
a177			 
a177			;    Setup dict word 
a177			 
a177 23			inc hl 
a178 22 a4 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
a17b			 
a17b			; 1. get length of dict word 
a17b			 
a17b			 
a17b 2a b9 e5		ld hl, (os_tok_ptr) 
a17e 23			inc hl 
a17f 23			inc hl    ; position to start of dict word 
a180 3e 00		ld a, 0 
a182 cd 39 90		call strlent 
a185			 
a185			 
a185 23			inc hl    ; to include null??? 
a186			 
a186			; write length of dict word 
a186			 
a186 ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a18a 1b			dec de 
a18b eb			ex de, hl 
a18c 73			ld (hl), e 
a18d eb			ex de, hl 
a18e			 
a18e			 
a18e			 
a18e			; copy  
a18e 4d			ld c, l 
a18f 06 00		ld b, 0 
a191 ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
a195 2a b9 e5		ld hl, (os_tok_ptr) 
a198 23			inc hl 
a199 23			inc hl    ; position to start of dict word 
a19a			 
a19a			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a19a			 
a19a			; TODO need to convert word to upper case 
a19a			 
a19a			ucasetok:	 
a19a 7e			ld a,(hl) 
a19b cd 25 90		call toUpper 
a19e 77			ld (hl),a 
a19f ed a0		ldi 
a1a1 f2 9a a1		jp p, ucasetok 
a1a4			 
a1a4			 
a1a4			 
a1a4			; de now points to start of where the word body code should be placed 
a1a4 ed 53 a4 e2	ld (os_new_work_ptr), de 
a1a8			; hl now points to the words to throw at forthexec which needs to be copied 
a1a8 22 a2 e2		ld (os_new_src_ptr), hl 
a1ab			 
a1ab			; TODO add 'call to forthexec' 
a1ab			 
a1ab			if DEBUG_FORTH_UWORD 
a1ab c5			push bc 
a1ac ed 4b aa e2	ld bc, (os_new_malloc) 
a1b0					DMARK ":0x" 
a1b0 f5				push af  
a1b1 3a c5 a1			ld a, (.dmark)  
a1b4 32 62 ee			ld (debug_mark),a  
a1b7 3a c6 a1			ld a, (.dmark+1)  
a1ba 32 63 ee			ld (debug_mark+1),a  
a1bd 3a c7 a1			ld a, (.dmark+2)  
a1c0 32 64 ee			ld (debug_mark+2),a  
a1c3 18 03			jr .pastdmark  
a1c5 ..			.dmark: db ":0x"  
a1c8 f1			.pastdmark: pop af  
a1c9			endm  
# End of macro DMARK
a1c9			CALLMONITOR 
a1c9 cd 6f ee			call debug_vector  
a1cc				endm  
# End of macro CALLMONITOR
a1cc c1			pop bc 
a1cd			endif 
a1cd			 
a1cd			 
a1cd			; create word preamble which should be: 
a1cd			 
a1cd			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a1cd			 
a1cd			;    ld hl, <word code> 
a1cd			;    jp user_exec 
a1cd			;    <word code bytes> 
a1cd			 
a1cd			 
a1cd			;	inc de     ; TODO ??? or are we already past the word's null 
a1cd eb			ex de, hl 
a1ce			 
a1ce 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a1d0			 
a1d0 23			inc hl 
a1d1 22 9e e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a1d4 23			inc hl 
a1d5			 
a1d5 23			inc hl 
a1d6 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a1d8			 
a1d8 01 75 d1		ld bc, user_exec 
a1db 23			inc hl 
a1dc 71			ld (hl), c     ; poke address of user_exec 
a1dd 23			inc hl 
a1de 70			ld (hl), b     
a1df			; 
a1df			;	inc hl 
a1df			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1df			; 
a1df			; 
a1df			;	ld bc, macro_forth_rsp_next 
a1df			;	inc hl 
a1df			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a1df			;	inc hl 
a1df			;	ld (hl), b     
a1df			; 
a1df			;	inc hl 
a1df			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1df			; 
a1df			; 
a1df			;	inc hl 
a1df			;	ld bc, forthexec 
a1df			;	ld (hl), c     ; poke address of forthexec 
a1df			;	inc hl 
a1df			;	ld (hl), b      
a1df			; 
a1df			;	inc hl 
a1df			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a1df			; 
a1df			;	ld bc, user_dict_next 
a1df			;	inc hl 
a1df			;	ld (hl), c     ; poke address of forthexec 
a1df			;	inc hl 
a1df			;	ld (hl), b      
a1df			 
a1df			; hl is now where we need to copy the word byte data to save this 
a1df			 
a1df 23			inc hl 
a1e0 22 a0 e2		ld (os_new_exec), hl 
a1e3			 
a1e3			; copy definition 
a1e3			 
a1e3 eb			ex de, hl 
a1e4			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a1e4			;	inc de    ; skip the PC for this parse 
a1e4 3a a8 e2		ld a, (os_new_parse_len) 
a1e7 4f			ld c, a 
a1e8 06 00		ld b, 0 
a1ea ed b0		ldir		 ; copy defintion 
a1ec			 
a1ec			 
a1ec			; poke the address of where the new word bytes live for forthexec 
a1ec			 
a1ec 2a 9e e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a1ef			 
a1ef ed 5b a0 e2	ld de, (os_new_exec)      
a1f3			 
a1f3 73			ld (hl), e 
a1f4 23			inc hl 
a1f5 72			ld (hl), d 
a1f6			 
a1f6				; TODO copy last user dict word next link to this word 
a1f6				; TODO update last user dict word to point to this word 
a1f6			; 
a1f6			; hl f923 de 812a ; bc 811a 
a1f6			 
a1f6			if DEBUG_FORTH_UWORD 
a1f6 c5			push bc 
a1f7 ed 4b aa e2	ld bc, (os_new_malloc) 
a1fb					DMARK ":0A" 
a1fb f5				push af  
a1fc 3a 10 a2			ld a, (.dmark)  
a1ff 32 62 ee			ld (debug_mark),a  
a202 3a 11 a2			ld a, (.dmark+1)  
a205 32 63 ee			ld (debug_mark+1),a  
a208 3a 12 a2			ld a, (.dmark+2)  
a20b 32 64 ee			ld (debug_mark+2),a  
a20e 18 03			jr .pastdmark  
a210 ..			.dmark: db ":0A"  
a213 f1			.pastdmark: pop af  
a214			endm  
# End of macro DMARK
a214			CALLMONITOR 
a214 cd 6f ee			call debug_vector  
a217				endm  
# End of macro CALLMONITOR
a217 c1			pop bc 
a218			endif 
a218			if DEBUG_FORTH_UWORD 
a218 c5			push bc 
a219 ed 4b aa e2	ld bc, (os_new_malloc) 
a21d 03			inc bc 
a21e 03			inc bc 
a21f 03			inc bc 
a220 03			inc bc 
a221 03			inc bc 
a222 03			inc bc 
a223 03			inc bc 
a224 03			inc bc 
a225			 
a225					DMARK ":0B" 
a225 f5				push af  
a226 3a 3a a2			ld a, (.dmark)  
a229 32 62 ee			ld (debug_mark),a  
a22c 3a 3b a2			ld a, (.dmark+1)  
a22f 32 63 ee			ld (debug_mark+1),a  
a232 3a 3c a2			ld a, (.dmark+2)  
a235 32 64 ee			ld (debug_mark+2),a  
a238 18 03			jr .pastdmark  
a23a ..			.dmark: db ":0B"  
a23d f1			.pastdmark: pop af  
a23e			endm  
# End of macro DMARK
a23e			CALLMONITOR 
a23e cd 6f ee			call debug_vector  
a241				endm  
# End of macro CALLMONITOR
a241 c1			pop bc 
a242			endif 
a242			 
a242			; update word dict linked list for new word 
a242			 
a242			 
a242 2a b5 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a245 23			inc hl     ; move to next work linked list ptr 
a246			 
a246 ed 5b aa e2	ld de, (os_new_malloc)		 ; new next word 
a24a 73			ld (hl), e 
a24b 23			inc hl 
a24c 72			ld (hl), d 
a24d			 
a24d			if DEBUG_FORTH_UWORD 
a24d ed 4b b5 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a251			endif 
a251			 
a251 ed 53 b5 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a255			 
a255			 
a255			if DEBUG_FORTH_UWORD 
a255					DMARK ":0+" 
a255 f5				push af  
a256 3a 6a a2			ld a, (.dmark)  
a259 32 62 ee			ld (debug_mark),a  
a25c 3a 6b a2			ld a, (.dmark+1)  
a25f 32 63 ee			ld (debug_mark+1),a  
a262 3a 6c a2			ld a, (.dmark+2)  
a265 32 64 ee			ld (debug_mark+2),a  
a268 18 03			jr .pastdmark  
a26a ..			.dmark: db ":0+"  
a26d f1			.pastdmark: pop af  
a26e			endm  
# End of macro DMARK
a26e			CALLMONITOR 
a26e cd 6f ee			call debug_vector  
a271				endm  
# End of macro CALLMONITOR
a271			endif 
a271			 
a271			STACKFRAMECHK OFF $8efe $989f 
a271				if DEBUG_STACK_IMB 
a271					if OFF 
a271						exx 
a271						ld hl, $989f 
a271						pop de   ; $989f 
a271						call cmp16 
a271						jr nz, .spnosame 
a271						ld hl, $8efe 
a271						pop de   ; $8efe 
a271						call cmp16 
a271						jr z, .spfrsame 
a271						.spnosame: call showsperror 
a271						.spfrsame: nop 
a271						exx 
a271					endif 
a271				endif 
a271			endm 
# End of macro STACKFRAMECHK
a271			 
a271 c9			ret    ; dont process any remaining parser tokens as they form new word 
a272			 
a272			 
a272			 
a272			 
a272			;		NEXT 
a272			.SCOLN: 
a272			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a272 06			db OPCODE_SCOLN 
a273 c1 a2		dw .DROP 
a275 02			db 2 
a276 .. 00		db ";",0           
a278			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a278				if DEBUG_FORTH_WORDS_KEY 
a278					DMARK "SCN" 
a278 f5				push af  
a279 3a 8d a2			ld a, (.dmark)  
a27c 32 62 ee			ld (debug_mark),a  
a27f 3a 8e a2			ld a, (.dmark+1)  
a282 32 63 ee			ld (debug_mark+1),a  
a285 3a 8f a2			ld a, (.dmark+2)  
a288 32 64 ee			ld (debug_mark+2),a  
a28b 18 03			jr .pastdmark  
a28d ..			.dmark: db "SCN"  
a290 f1			.pastdmark: pop af  
a291			endm  
# End of macro DMARK
a291					CALLMONITOR 
a291 cd 6f ee			call debug_vector  
a294				endm  
# End of macro CALLMONITOR
a294				endif 
a294				FORTH_RSP_TOS 
a294 cd 89 99			call macro_forth_rsp_tos 
a297				endm 
# End of macro FORTH_RSP_TOS
a297 e5				push hl 
a298				FORTH_RSP_POP 
a298 cd 93 99			call macro_forth_rsp_pop 
a29b				endm 
# End of macro FORTH_RSP_POP
a29b e1				pop hl 
a29c			;		ex de,hl 
a29c 22 b9 e5			ld (os_tok_ptr),hl 
a29f			 
a29f			if DEBUG_FORTH_UWORD 
a29f					DMARK "SCL" 
a29f f5				push af  
a2a0 3a b4 a2			ld a, (.dmark)  
a2a3 32 62 ee			ld (debug_mark),a  
a2a6 3a b5 a2			ld a, (.dmark+1)  
a2a9 32 63 ee			ld (debug_mark+1),a  
a2ac 3a b6 a2			ld a, (.dmark+2)  
a2af 32 64 ee			ld (debug_mark+2),a  
a2b2 18 03			jr .pastdmark  
a2b4 ..			.dmark: db "SCL"  
a2b7 f1			.pastdmark: pop af  
a2b8			endm  
# End of macro DMARK
a2b8			CALLMONITOR 
a2b8 cd 6f ee			call debug_vector  
a2bb				endm  
# End of macro CALLMONITOR
a2bb			endif 
a2bb				NEXTW 
a2bb cd 6c ee			call parse_vector 
a2be c3 ae 9d			jp macro_next 
a2c1				endm 
# End of macro NEXTW
a2c1			 
a2c1			.DROP: 
a2c1			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a2c1 1b				db WORD_SYS_CORE+OPCODE_DROP             
a2c2 ef a2			dw .DUP2            
a2c4 05				db 4 + 1 
a2c5 .. 00			db "DROP",0              
a2ca				endm 
# End of macro CWHEAD
a2ca			; | DROP ( w -- )   drop the TOS item   | DONE 
a2ca				if DEBUG_FORTH_WORDS_KEY 
a2ca					DMARK "DRP" 
a2ca f5				push af  
a2cb 3a df a2			ld a, (.dmark)  
a2ce 32 62 ee			ld (debug_mark),a  
a2d1 3a e0 a2			ld a, (.dmark+1)  
a2d4 32 63 ee			ld (debug_mark+1),a  
a2d7 3a e1 a2			ld a, (.dmark+2)  
a2da 32 64 ee			ld (debug_mark+2),a  
a2dd 18 03			jr .pastdmark  
a2df ..			.dmark: db "DRP"  
a2e2 f1			.pastdmark: pop af  
a2e3			endm  
# End of macro DMARK
a2e3					CALLMONITOR 
a2e3 cd 6f ee			call debug_vector  
a2e6				endm  
# End of macro CALLMONITOR
a2e6				endif 
a2e6				FORTH_DSP_POP 
a2e6 cd 7f 9c			call macro_forth_dsp_pop 
a2e9				endm 
# End of macro FORTH_DSP_POP
a2e9				NEXTW 
a2e9 cd 6c ee			call parse_vector 
a2ec c3 ae 9d			jp macro_next 
a2ef				endm 
# End of macro NEXTW
a2ef			.DUP2: 
a2ef			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a2ef 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a2f0 37 a3			dw .DROP2            
a2f2 05				db 4 + 1 
a2f3 .. 00			db "2DUP",0              
a2f8				endm 
# End of macro CWHEAD
a2f8			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
a2f8			; | | >[!NOTE] 
a2f8			; | | > If the duplicated items are string pointers, string are not safely duplicated and remain as pointers to the origin 
a2f8				if DEBUG_FORTH_WORDS_KEY 
a2f8					DMARK "2DU" 
a2f8 f5				push af  
a2f9 3a 0d a3			ld a, (.dmark)  
a2fc 32 62 ee			ld (debug_mark),a  
a2ff 3a 0e a3			ld a, (.dmark+1)  
a302 32 63 ee			ld (debug_mark+1),a  
a305 3a 0f a3			ld a, (.dmark+2)  
a308 32 64 ee			ld (debug_mark+2),a  
a30b 18 03			jr .pastdmark  
a30d ..			.dmark: db "2DU"  
a310 f1			.pastdmark: pop af  
a311			endm  
# End of macro DMARK
a311					CALLMONITOR 
a311 cd 6f ee			call debug_vector  
a314				endm  
# End of macro CALLMONITOR
a314				endif 
a314				FORTH_DSP_VALUEHL 
a314 cd c7 9b			call macro_dsp_valuehl 
a317				endm 
# End of macro FORTH_DSP_VALUEHL
a317 e5				push hl      ; 2 
a318			 
a318				FORTH_DSP_POP 
a318 cd 7f 9c			call macro_forth_dsp_pop 
a31b				endm 
# End of macro FORTH_DSP_POP
a31b				 
a31b				FORTH_DSP_VALUEHL 
a31b cd c7 9b			call macro_dsp_valuehl 
a31e				endm 
# End of macro FORTH_DSP_VALUEHL
a31e			;		push hl      ; 1 
a31e			 
a31e				FORTH_DSP_POP 
a31e cd 7f 9c			call macro_forth_dsp_pop 
a321				endm 
# End of macro FORTH_DSP_POP
a321			 
a321			;		pop hl       ; 1 
a321 d1				pop de       ; 2 
a322			 
a322 cd cb 99			call forth_push_numhl 
a325 eb				ex de, hl 
a326 cd cb 99			call forth_push_numhl 
a329			 
a329				 
a329 eb				ex de, hl 
a32a			 
a32a cd cb 99			call forth_push_numhl 
a32d eb				ex de, hl 
a32e cd cb 99			call forth_push_numhl 
a331			 
a331			 
a331				NEXTW 
a331 cd 6c ee			call parse_vector 
a334 c3 ae 9d			jp macro_next 
a337				endm 
# End of macro NEXTW
a337			.DROP2: 
a337			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a337 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a338 69 a3			dw .PICK            
a33a 06				db 5 + 1 
a33b .. 00			db "2DROP",0              
a341				endm 
# End of macro CWHEAD
a341			; | 2DROP ( w w -- )    Double drop | DONE 
a341				if DEBUG_FORTH_WORDS_KEY 
a341					DMARK "2DR" 
a341 f5				push af  
a342 3a 56 a3			ld a, (.dmark)  
a345 32 62 ee			ld (debug_mark),a  
a348 3a 57 a3			ld a, (.dmark+1)  
a34b 32 63 ee			ld (debug_mark+1),a  
a34e 3a 58 a3			ld a, (.dmark+2)  
a351 32 64 ee			ld (debug_mark+2),a  
a354 18 03			jr .pastdmark  
a356 ..			.dmark: db "2DR"  
a359 f1			.pastdmark: pop af  
a35a			endm  
# End of macro DMARK
a35a					CALLMONITOR 
a35a cd 6f ee			call debug_vector  
a35d				endm  
# End of macro CALLMONITOR
a35d				endif 
a35d				FORTH_DSP_POP 
a35d cd 7f 9c			call macro_forth_dsp_pop 
a360				endm 
# End of macro FORTH_DSP_POP
a360				FORTH_DSP_POP 
a360 cd 7f 9c			call macro_forth_dsp_pop 
a363				endm 
# End of macro FORTH_DSP_POP
a363				NEXTW 
a363 cd 6c ee			call parse_vector 
a366 c3 ae 9d			jp macro_next 
a369				endm 
# End of macro NEXTW
a369			.PICK: 
a369			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
a369 77				db WORD_SYS_CORE+99             
a36a 06 a4			dw .SWAP2            
a36c 05				db 4 + 1 
a36d .. 00			db "PICK",0              
a372				endm 
# End of macro CWHEAD
a372			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
a372			; | | >[!NOTE] 
a372			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
a372				if DEBUG_FORTH_WORDS_KEY 
a372					DMARK "PIK" 
a372 f5				push af  
a373 3a 87 a3			ld a, (.dmark)  
a376 32 62 ee			ld (debug_mark),a  
a379 3a 88 a3			ld a, (.dmark+1)  
a37c 32 63 ee			ld (debug_mark+1),a  
a37f 3a 89 a3			ld a, (.dmark+2)  
a382 32 64 ee			ld (debug_mark+2),a  
a385 18 03			jr .pastdmark  
a387 ..			.dmark: db "PIK"  
a38a f1			.pastdmark: pop af  
a38b			endm  
# End of macro DMARK
a38b					CALLMONITOR 
a38b cd 6f ee			call debug_vector  
a38e				endm  
# End of macro CALLMONITOR
a38e				endif 
a38e			 
a38e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a38e cd c7 9b			call macro_dsp_valuehl 
a391				endm 
# End of macro FORTH_DSP_VALUEHL
a391				 
a391				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a391 cd 7f 9c			call macro_forth_dsp_pop 
a394				endm 
# End of macro FORTH_DSP_POP
a394			 
a394				; init from TOS 
a394 e5				push hl 
a395				FORTH_DSP 
a395 cd 8d 9b			call macro_forth_dsp 
a398				endm 
# End of macro FORTH_DSP
a398			;	ld hl, cli_data_sp 
a398				if DEBUG_FORTH_WORDS 
a398					DMARK "PK1" 
a398 f5				push af  
a399 3a ad a3			ld a, (.dmark)  
a39c 32 62 ee			ld (debug_mark),a  
a39f 3a ae a3			ld a, (.dmark+1)  
a3a2 32 63 ee			ld (debug_mark+1),a  
a3a5 3a af a3			ld a, (.dmark+2)  
a3a8 32 64 ee			ld (debug_mark+2),a  
a3ab 18 03			jr .pastdmark  
a3ad ..			.dmark: db "PK1"  
a3b0 f1			.pastdmark: pop af  
a3b1			endm  
# End of macro DMARK
a3b1					CALLMONITOR 
a3b1 cd 6f ee			call debug_vector  
a3b4				endm  
# End of macro CALLMONITOR
a3b4				endif 
a3b4 c1				pop bc 
a3b5 41				ld b,c 
a3b6 3e 00			ld a, 0 
a3b8 b8				cp b 
a3b9 28 21			jr z, .pdone	 
a3bb			.pkl: 
a3bb 2b				dec hl 
a3bc 2b				dec hl 
a3bd 2b				dec hl 
a3be			 
a3be				if DEBUG_FORTH_WORDS 
a3be					DMARK "PKl" 
a3be f5				push af  
a3bf 3a d3 a3			ld a, (.dmark)  
a3c2 32 62 ee			ld (debug_mark),a  
a3c5 3a d4 a3			ld a, (.dmark+1)  
a3c8 32 63 ee			ld (debug_mark+1),a  
a3cb 3a d5 a3			ld a, (.dmark+2)  
a3ce 32 64 ee			ld (debug_mark+2),a  
a3d1 18 03			jr .pastdmark  
a3d3 ..			.dmark: db "PKl"  
a3d6 f1			.pastdmark: pop af  
a3d7			endm  
# End of macro DMARK
a3d7					CALLMONITOR 
a3d7 cd 6f ee			call debug_vector  
a3da				endm  
# End of macro CALLMONITOR
a3da				endif 
a3da 10 df			djnz .pkl 
a3dc			.pdone: 
a3dc				 
a3dc				; TODO do type check with correct push 
a3dc			 
a3dc 23				inc hl 
a3dd				;call loadwordinhl 
a3dd 5e				ld e, (hl) 
a3de 23				inc hl 
a3df 56				ld d, (hl) 
a3e0 eb				ex de,hl 
a3e1				if DEBUG_FORTH_WORDS 
a3e1					DMARK "PKp" 
a3e1 f5				push af  
a3e2 3a f6 a3			ld a, (.dmark)  
a3e5 32 62 ee			ld (debug_mark),a  
a3e8 3a f7 a3			ld a, (.dmark+1)  
a3eb 32 63 ee			ld (debug_mark+1),a  
a3ee 3a f8 a3			ld a, (.dmark+2)  
a3f1 32 64 ee			ld (debug_mark+2),a  
a3f4 18 03			jr .pastdmark  
a3f6 ..			.dmark: db "PKp"  
a3f9 f1			.pastdmark: pop af  
a3fa			endm  
# End of macro DMARK
a3fa					CALLMONITOR 
a3fa cd 6f ee			call debug_vector  
a3fd				endm  
# End of macro CALLMONITOR
a3fd				endif 
a3fd cd cb 99			call forth_push_numhl 
a400			 
a400				NEXTW 
a400 cd 6c ee			call parse_vector 
a403 c3 ae 9d			jp macro_next 
a406				endm 
# End of macro NEXTW
a406			.SWAP2: 
a406			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a406 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a407 8a a4			dw .AT            
a409 06				db 5 + 1 
a40a .. 00			db "2SWAP",0              
a410				endm 
# End of macro CWHEAD
a410			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | DONE 
a410				if DEBUG_FORTH_WORDS_KEY 
a410					DMARK "2SW" 
a410 f5				push af  
a411 3a 25 a4			ld a, (.dmark)  
a414 32 62 ee			ld (debug_mark),a  
a417 3a 26 a4			ld a, (.dmark+1)  
a41a 32 63 ee			ld (debug_mark+1),a  
a41d 3a 27 a4			ld a, (.dmark+2)  
a420 32 64 ee			ld (debug_mark+2),a  
a423 18 03			jr .pastdmark  
a425 ..			.dmark: db "2SW"  
a428 f1			.pastdmark: pop af  
a429			endm  
# End of macro DMARK
a429					CALLMONITOR 
a429 cd 6f ee			call debug_vector  
a42c				endm  
# End of macro CALLMONITOR
a42c				endif 
a42c			; TODO Use os stack swap memory 
a42c			 
a42c				FORTH_DSP_PTR 0     ; TOS    w4 
a42c 2a e5 e9			ld hl,(cli_data_sp) 
a42f 11 00 00			ld de, 0 * 3 
a432 ed 52			sbc hl, de 
a434				endm 
# End of macro FORTH_DSP_PTR
a434 cd fe 9c			call hltostack1 
a437			  
a437				FORTH_DSP_PTR 1     ; TOS    w3 
a437 2a e5 e9			ld hl,(cli_data_sp) 
a43a 11 03 00			ld de, 1 * 3 
a43d ed 52			sbc hl, de 
a43f				endm 
# End of macro FORTH_DSP_PTR
a43f cd 04 9d			call hltostack2 
a442			 
a442			 
a442			 
a442				FORTH_DSP_PTR 2     ; TOS    w2 
a442 2a e5 e9			ld hl,(cli_data_sp) 
a445 11 06 00			ld de, 2 * 3 
a448 ed 52			sbc hl, de 
a44a				endm 
# End of macro FORTH_DSP_PTR
a44a cd 0a 9d			call hltostack3 
a44d			 
a44d				FORTH_DSP_PTR 3     ; TOS   w1 
a44d 2a e5 e9			ld hl,(cli_data_sp) 
a450 11 09 00			ld de, 3 * 3 
a453 ed 52			sbc hl, de 
a455				endm 
# End of macro FORTH_DSP_PTR
a455 cd 10 9d			call hltostack4 
a458			 
a458			 
a458			 
a458			 
a458				FORTH_DSP_PTR 0     ; TOS 
a458 2a e5 e9			ld hl,(cli_data_sp) 
a45b 11 00 00			ld de, 0 * 3 
a45e ed 52			sbc hl, de 
a460				endm 
# End of macro FORTH_DSP_PTR
a460 cd 22 9d			call hlfromstack3 
a463			 
a463				FORTH_DSP_PTR 1     ; TOS 
a463 2a e5 e9			ld hl,(cli_data_sp) 
a466 11 03 00			ld de, 1 * 3 
a469 ed 52			sbc hl, de 
a46b				endm 
# End of macro FORTH_DSP_PTR
a46b cd 28 9d			call hlfromstack4 
a46e			 
a46e			 
a46e			 
a46e				FORTH_DSP_PTR 2     ; TOS 
a46e 2a e5 e9			ld hl,(cli_data_sp) 
a471 11 06 00			ld de, 2 * 3 
a474 ed 52			sbc hl, de 
a476				endm 
# End of macro FORTH_DSP_PTR
a476 cd 16 9d			call hlfromstack1 
a479			 
a479				FORTH_DSP_PTR 3     ; TOS 
a479 2a e5 e9			ld hl,(cli_data_sp) 
a47c 11 09 00			ld de, 3 * 3 
a47f ed 52			sbc hl, de 
a481				endm 
# End of macro FORTH_DSP_PTR
a481 cd 1c 9d			call hlfromstack2 
a484			 
a484				NEXTW 
a484 cd 6c ee			call parse_vector 
a487 c3 ae 9d			jp macro_next 
a48a				endm 
# End of macro NEXTW
a48a			.AT: 
a48a			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a48a 1f				db WORD_SYS_CORE+OPCODE_AT             
a48b bf a4			dw .CAT            
a48d 02				db 1 + 1 
a48e .. 00			db "@",0              
a490				endm 
# End of macro CWHEAD
a490			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a490			 
a490				if DEBUG_FORTH_WORDS_KEY 
a490					DMARK "AT." 
a490 f5				push af  
a491 3a a5 a4			ld a, (.dmark)  
a494 32 62 ee			ld (debug_mark),a  
a497 3a a6 a4			ld a, (.dmark+1)  
a49a 32 63 ee			ld (debug_mark+1),a  
a49d 3a a7 a4			ld a, (.dmark+2)  
a4a0 32 64 ee			ld (debug_mark+2),a  
a4a3 18 03			jr .pastdmark  
a4a5 ..			.dmark: db "AT."  
a4a8 f1			.pastdmark: pop af  
a4a9			endm  
# End of macro DMARK
a4a9					CALLMONITOR 
a4a9 cd 6f ee			call debug_vector  
a4ac				endm  
# End of macro CALLMONITOR
a4ac				endif 
a4ac			.getbyteat:	 
a4ac				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4ac cd c7 9b			call macro_dsp_valuehl 
a4af				endm 
# End of macro FORTH_DSP_VALUEHL
a4af				 
a4af			;		push hl 
a4af			 
a4af				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4af cd 7f 9c			call macro_forth_dsp_pop 
a4b2				endm 
# End of macro FORTH_DSP_POP
a4b2			 
a4b2			;		pop hl 
a4b2			 
a4b2 7e				ld a, (hl) 
a4b3			 
a4b3 6f				ld l, a 
a4b4 26 00			ld h, 0 
a4b6 cd cb 99			call forth_push_numhl 
a4b9			 
a4b9				NEXTW 
a4b9 cd 6c ee			call parse_vector 
a4bc c3 ae 9d			jp macro_next 
a4bf				endm 
# End of macro NEXTW
a4bf			.CAT: 
a4bf			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a4bf 20				db WORD_SYS_CORE+OPCODE_CAT             
a4c0 eb a4			dw .BANG            
a4c2 03				db 2 + 1 
a4c3 .. 00			db "C@",0              
a4c6				endm 
# End of macro CWHEAD
a4c6			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a4c6				if DEBUG_FORTH_WORDS_KEY 
a4c6					DMARK "CAA" 
a4c6 f5				push af  
a4c7 3a db a4			ld a, (.dmark)  
a4ca 32 62 ee			ld (debug_mark),a  
a4cd 3a dc a4			ld a, (.dmark+1)  
a4d0 32 63 ee			ld (debug_mark+1),a  
a4d3 3a dd a4			ld a, (.dmark+2)  
a4d6 32 64 ee			ld (debug_mark+2),a  
a4d9 18 03			jr .pastdmark  
a4db ..			.dmark: db "CAA"  
a4de f1			.pastdmark: pop af  
a4df			endm  
# End of macro DMARK
a4df					CALLMONITOR 
a4df cd 6f ee			call debug_vector  
a4e2				endm  
# End of macro CALLMONITOR
a4e2				endif 
a4e2 c3 ac a4			jp .getbyteat 
a4e5				NEXTW 
a4e5 cd 6c ee			call parse_vector 
a4e8 c3 ae 9d			jp macro_next 
a4eb				endm 
# End of macro NEXTW
a4eb			.BANG: 
a4eb			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a4eb 21				db WORD_SYS_CORE+OPCODE_BANG             
a4ec 24 a5			dw .CBANG            
a4ee 02				db 1 + 1 
a4ef .. 00			db "!",0              
a4f1				endm 
# End of macro CWHEAD
a4f1			; | ! ( x w -- ) Store x at address w      | DONE 
a4f1				if DEBUG_FORTH_WORDS_KEY 
a4f1					DMARK "BNG" 
a4f1 f5				push af  
a4f2 3a 06 a5			ld a, (.dmark)  
a4f5 32 62 ee			ld (debug_mark),a  
a4f8 3a 07 a5			ld a, (.dmark+1)  
a4fb 32 63 ee			ld (debug_mark+1),a  
a4fe 3a 08 a5			ld a, (.dmark+2)  
a501 32 64 ee			ld (debug_mark+2),a  
a504 18 03			jr .pastdmark  
a506 ..			.dmark: db "BNG"  
a509 f1			.pastdmark: pop af  
a50a			endm  
# End of macro DMARK
a50a					CALLMONITOR 
a50a cd 6f ee			call debug_vector  
a50d				endm  
# End of macro CALLMONITOR
a50d				endif 
a50d			 
a50d			.storebyteat:		 
a50d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a50d cd c7 9b			call macro_dsp_valuehl 
a510				endm 
# End of macro FORTH_DSP_VALUEHL
a510				 
a510 e5				push hl 
a511			 
a511				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a511 cd 7f 9c			call macro_forth_dsp_pop 
a514				endm 
# End of macro FORTH_DSP_POP
a514			 
a514				; get byte to poke 
a514			 
a514				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a514 cd c7 9b			call macro_dsp_valuehl 
a517				endm 
# End of macro FORTH_DSP_VALUEHL
a517 e5				push hl 
a518			 
a518			 
a518				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a518 cd 7f 9c			call macro_forth_dsp_pop 
a51b				endm 
# End of macro FORTH_DSP_POP
a51b			 
a51b			 
a51b d1				pop de 
a51c e1				pop hl 
a51d			 
a51d 73				ld (hl),e 
a51e			 
a51e			 
a51e				NEXTW 
a51e cd 6c ee			call parse_vector 
a521 c3 ae 9d			jp macro_next 
a524				endm 
# End of macro NEXTW
a524			.CBANG: 
a524			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a524 22				db WORD_SYS_CORE+OPCODE_CBANG             
a525 50 a5			dw .SCALL            
a527 03				db 2 + 1 
a528 .. 00			db "C!",0              
a52b				endm 
# End of macro CWHEAD
a52b			; | C!  ( x w -- ) Store x at address w  | DONE 
a52b				if DEBUG_FORTH_WORDS_KEY 
a52b					DMARK "CBA" 
a52b f5				push af  
a52c 3a 40 a5			ld a, (.dmark)  
a52f 32 62 ee			ld (debug_mark),a  
a532 3a 41 a5			ld a, (.dmark+1)  
a535 32 63 ee			ld (debug_mark+1),a  
a538 3a 42 a5			ld a, (.dmark+2)  
a53b 32 64 ee			ld (debug_mark+2),a  
a53e 18 03			jr .pastdmark  
a540 ..			.dmark: db "CBA"  
a543 f1			.pastdmark: pop af  
a544			endm  
# End of macro DMARK
a544					CALLMONITOR 
a544 cd 6f ee			call debug_vector  
a547				endm  
# End of macro CALLMONITOR
a547				endif 
a547 c3 0d a5			jp .storebyteat 
a54a				NEXTW 
a54a cd 6c ee			call parse_vector 
a54d c3 ae 9d			jp macro_next 
a550				endm 
# End of macro NEXTW
a550			.SCALL: 
a550			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a550 23				db WORD_SYS_CORE+OPCODE_SCALL             
a551 87 a5			dw .DEPTH            
a553 05				db 4 + 1 
a554 .. 00			db "CALL",0              
a559				endm 
# End of macro CWHEAD
a559			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a559				if DEBUG_FORTH_WORDS_KEY 
a559					DMARK "CLL" 
a559 f5				push af  
a55a 3a 6e a5			ld a, (.dmark)  
a55d 32 62 ee			ld (debug_mark),a  
a560 3a 6f a5			ld a, (.dmark+1)  
a563 32 63 ee			ld (debug_mark+1),a  
a566 3a 70 a5			ld a, (.dmark+2)  
a569 32 64 ee			ld (debug_mark+2),a  
a56c 18 03			jr .pastdmark  
a56e ..			.dmark: db "CLL"  
a571 f1			.pastdmark: pop af  
a572			endm  
# End of macro DMARK
a572					CALLMONITOR 
a572 cd 6f ee			call debug_vector  
a575				endm  
# End of macro CALLMONITOR
a575				endif 
a575			 
a575				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a575 cd c7 9b			call macro_dsp_valuehl 
a578				endm 
# End of macro FORTH_DSP_VALUEHL
a578			 
a578			;		push hl 
a578			 
a578				; destroy value TOS 
a578			 
a578				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a578 cd 7f 9c			call macro_forth_dsp_pop 
a57b				endm 
# End of macro FORTH_DSP_POP
a57b			 
a57b					 
a57b			;		pop hl 
a57b			 
a57b				; how to do a call with hl???? save SP? 
a57b cd 52 9d			call forth_call_hl 
a57e			 
a57e			 
a57e				; TODO push value back onto stack for another op etc 
a57e			 
a57e cd cb 99			call forth_push_numhl 
a581				NEXTW 
a581 cd 6c ee			call parse_vector 
a584 c3 ae 9d			jp macro_next 
a587				endm 
# End of macro NEXTW
a587			.DEPTH: 
a587			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a587 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a588 c7 a5			dw .OVER            
a58a 06				db 5 + 1 
a58b .. 00			db "DEPTH",0              
a591				endm 
# End of macro CWHEAD
a591			; | DEPTH ( -- u ) Push count of stack | DONE 
a591				; take current TOS and remove from base value div by two to get count 
a591				if DEBUG_FORTH_WORDS_KEY 
a591					DMARK "DEP" 
a591 f5				push af  
a592 3a a6 a5			ld a, (.dmark)  
a595 32 62 ee			ld (debug_mark),a  
a598 3a a7 a5			ld a, (.dmark+1)  
a59b 32 63 ee			ld (debug_mark+1),a  
a59e 3a a8 a5			ld a, (.dmark+2)  
a5a1 32 64 ee			ld (debug_mark+2),a  
a5a4 18 03			jr .pastdmark  
a5a6 ..			.dmark: db "DEP"  
a5a9 f1			.pastdmark: pop af  
a5aa			endm  
# End of macro DMARK
a5aa					CALLMONITOR 
a5aa cd 6f ee			call debug_vector  
a5ad				endm  
# End of macro CALLMONITOR
a5ad				endif 
a5ad			 
a5ad			 
a5ad 2a e5 e9		ld hl, (cli_data_sp) 
a5b0 11 1f e8		ld de, cli_data_stack 
a5b3 ed 52		sbc hl,de 
a5b5			 
a5b5			; div by size of stack item 
a5b5			 
a5b5 5d			ld e,l 
a5b6 0e 03		ld c, 3 
a5b8 cd 66 8c		call Div8 
a5bb			 
a5bb 6f			ld l,a 
a5bc 26 00		ld h,0 
a5be			 
a5be			;srl h 
a5be			;rr l 
a5be			 
a5be cd cb 99			call forth_push_numhl 
a5c1				NEXTW 
a5c1 cd 6c ee			call parse_vector 
a5c4 c3 ae 9d			jp macro_next 
a5c7				endm 
# End of macro NEXTW
a5c7			.OVER: 
a5c7			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a5c7 42				db WORD_SYS_CORE+46             
a5c8 17 a6			dw .PAUSE            
a5ca 05				db 4 + 1 
a5cb .. 00			db "OVER",0              
a5d0				endm 
# End of macro CWHEAD
a5d0			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a5d0			; | | >[!NOTE] 
a5d0			; | | > If the copied item is a string it is properly duplicated allowing for a safe release after use.  
a5d0				if DEBUG_FORTH_WORDS_KEY 
a5d0					DMARK "OVR" 
a5d0 f5				push af  
a5d1 3a e5 a5			ld a, (.dmark)  
a5d4 32 62 ee			ld (debug_mark),a  
a5d7 3a e6 a5			ld a, (.dmark+1)  
a5da 32 63 ee			ld (debug_mark+1),a  
a5dd 3a e7 a5			ld a, (.dmark+2)  
a5e0 32 64 ee			ld (debug_mark+2),a  
a5e3 18 03			jr .pastdmark  
a5e5 ..			.dmark: db "OVR"  
a5e8 f1			.pastdmark: pop af  
a5e9			endm  
# End of macro DMARK
a5e9					CALLMONITOR 
a5e9 cd 6f ee			call debug_vector  
a5ec				endm  
# End of macro CALLMONITOR
a5ec				endif 
a5ec			 
a5ec			; TODO Use os stack swap memory 
a5ec			 
a5ec				; work out what type we are looking at 
a5ec			 
a5ec				FORTH_DSP_PTR 1 
a5ec 2a e5 e9			ld hl,(cli_data_sp) 
a5ef 11 03 00			ld de, 1 * 3 
a5f2 ed 52			sbc hl, de 
a5f4				endm 
# End of macro FORTH_DSP_PTR
a5f4			 
a5f4 7e				ld a, (hl) 
a5f5				 
a5f5 f5				push af 
a5f6				; whatever the type lets get the pointer or word 
a5f6 23				inc hl 
a5f7			;; 
a5f7			 
a5f7				; type check now to decide on how to push  
a5f7			 
a5f7 cd 34 9d			call loadwordinhl 
a5fa f1				pop af 
a5fb fe 01			cp DS_TYPE_STR 
a5fd 28 09			jr z, .ovstr 
a5ff			 
a5ff				; we have a numeric so load the word and push 
a5ff			;	ld e, (hl) 
a5ff			;	inc hl 
a5ff			;	ld d, (hl) 
a5ff			;	ex de, hl 
a5ff cd cb 99			call forth_push_numhl 
a602				NEXTW 
a602 cd 6c ee			call parse_vector 
a605 c3 ae 9d			jp macro_next 
a608				endm 
# End of macro NEXTW
a608			 
a608			.ovstr: 
a608				; ok, a string so get the pointer and push as a string 
a608			 
a608			;	call loadwordinhl 
a608 cd 35 9a			call forth_push_str 
a60b				NEXTW 
a60b cd 6c ee			call parse_vector 
a60e c3 ae 9d			jp macro_next 
a611				endm 
# End of macro NEXTW
a611			 
a611			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a611			;	push hl    ; n2 
a611			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a611			; 
a611			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a611			;	push hl    ; n1 
a611			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a611			; 
a611			;	pop de     ; n1 
a611			;	pop hl     ; n2 
a611			; 
a611			;	push de 
a611			;	push hl 
a611			;	push de 
a611			 
a611				; push back  
a611			 
a611			;	pop hl 
a611			;	call forth_push_numhl 
a611			;	pop hl 
a611			;	call forth_push_numhl 
a611			;	pop hl 
a611			;	call forth_push_numhl 
a611				NEXTW 
a611 cd 6c ee			call parse_vector 
a614 c3 ae 9d			jp macro_next 
a617				endm 
# End of macro NEXTW
a617			 
a617			.PAUSE: 
a617			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a617 43				db WORD_SYS_CORE+47             
a618 4f a6			dw .PAUSES            
a61a 08				db 7 + 1 
a61b .. 00			db "PAUSEMS",0              
a623				endm 
# End of macro CWHEAD
a623			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a623				if DEBUG_FORTH_WORDS_KEY 
a623					DMARK "PMS" 
a623 f5				push af  
a624 3a 38 a6			ld a, (.dmark)  
a627 32 62 ee			ld (debug_mark),a  
a62a 3a 39 a6			ld a, (.dmark+1)  
a62d 32 63 ee			ld (debug_mark+1),a  
a630 3a 3a a6			ld a, (.dmark+2)  
a633 32 64 ee			ld (debug_mark+2),a  
a636 18 03			jr .pastdmark  
a638 ..			.dmark: db "PMS"  
a63b f1			.pastdmark: pop af  
a63c			endm  
# End of macro DMARK
a63c					CALLMONITOR 
a63c cd 6f ee			call debug_vector  
a63f				endm  
# End of macro CALLMONITOR
a63f				endif 
a63f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a63f cd c7 9b			call macro_dsp_valuehl 
a642				endm 
# End of macro FORTH_DSP_VALUEHL
a642			;		push hl    ; n2 
a642				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a642 cd 7f 9c			call macro_forth_dsp_pop 
a645				endm 
# End of macro FORTH_DSP_POP
a645			;		pop hl 
a645			 
a645 7d				ld a, l 
a646 cd d5 89			call aDelayInMS 
a649			       NEXTW 
a649 cd 6c ee			call parse_vector 
a64c c3 ae 9d			jp macro_next 
a64f				endm 
# End of macro NEXTW
a64f			.PAUSES:  
a64f			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a64f 44				db WORD_SYS_CORE+48             
a650 c1 a6			dw .ROT            
a652 06				db 5 + 1 
a653 .. 00			db "PAUSE",0              
a659				endm 
# End of macro CWHEAD
a659			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a659				if DEBUG_FORTH_WORDS_KEY 
a659					DMARK "PAU" 
a659 f5				push af  
a65a 3a 6e a6			ld a, (.dmark)  
a65d 32 62 ee			ld (debug_mark),a  
a660 3a 6f a6			ld a, (.dmark+1)  
a663 32 63 ee			ld (debug_mark+1),a  
a666 3a 70 a6			ld a, (.dmark+2)  
a669 32 64 ee			ld (debug_mark+2),a  
a66c 18 03			jr .pastdmark  
a66e ..			.dmark: db "PAU"  
a671 f1			.pastdmark: pop af  
a672			endm  
# End of macro DMARK
a672					CALLMONITOR 
a672 cd 6f ee			call debug_vector  
a675				endm  
# End of macro CALLMONITOR
a675				endif 
a675				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a675 cd c7 9b			call macro_dsp_valuehl 
a678				endm 
# End of macro FORTH_DSP_VALUEHL
a678			;		push hl    ; n2 
a678				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a678 cd 7f 9c			call macro_forth_dsp_pop 
a67b				endm 
# End of macro FORTH_DSP_POP
a67b			;		pop hl 
a67b 45				ld b, l 
a67c				if DEBUG_FORTH_WORDS 
a67c					DMARK "PAU" 
a67c f5				push af  
a67d 3a 91 a6			ld a, (.dmark)  
a680 32 62 ee			ld (debug_mark),a  
a683 3a 92 a6			ld a, (.dmark+1)  
a686 32 63 ee			ld (debug_mark+1),a  
a689 3a 93 a6			ld a, (.dmark+2)  
a68c 32 64 ee			ld (debug_mark+2),a  
a68f 18 03			jr .pastdmark  
a691 ..			.dmark: db "PAU"  
a694 f1			.pastdmark: pop af  
a695			endm  
# End of macro DMARK
a695					CALLMONITOR 
a695 cd 6f ee			call debug_vector  
a698				endm  
# End of macro CALLMONITOR
a698				endif 
a698 c5			.pauses1:	push bc 
a699 cd f0 89			call delay1s 
a69c c1				pop bc 
a69d				if DEBUG_FORTH_WORDS 
a69d					DMARK "PA1" 
a69d f5				push af  
a69e 3a b2 a6			ld a, (.dmark)  
a6a1 32 62 ee			ld (debug_mark),a  
a6a4 3a b3 a6			ld a, (.dmark+1)  
a6a7 32 63 ee			ld (debug_mark+1),a  
a6aa 3a b4 a6			ld a, (.dmark+2)  
a6ad 32 64 ee			ld (debug_mark+2),a  
a6b0 18 03			jr .pastdmark  
a6b2 ..			.dmark: db "PA1"  
a6b5 f1			.pastdmark: pop af  
a6b6			endm  
# End of macro DMARK
a6b6					CALLMONITOR 
a6b6 cd 6f ee			call debug_vector  
a6b9				endm  
# End of macro CALLMONITOR
a6b9				endif 
a6b9 10 dd			djnz .pauses1 
a6bb			 
a6bb			       NEXTW 
a6bb cd 6c ee			call parse_vector 
a6be c3 ae 9d			jp macro_next 
a6c1				endm 
# End of macro NEXTW
a6c1			.ROT: 
a6c1			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a6c1 45				db WORD_SYS_CORE+49             
a6c2 2d a7			dw .UWORDS            
a6c4 04				db 3 + 1 
a6c5 .. 00			db "ROT",0              
a6c9				endm 
# End of macro CWHEAD
a6c9			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a6c9				if DEBUG_FORTH_WORDS_KEY 
a6c9					DMARK "ROT" 
a6c9 f5				push af  
a6ca 3a de a6			ld a, (.dmark)  
a6cd 32 62 ee			ld (debug_mark),a  
a6d0 3a df a6			ld a, (.dmark+1)  
a6d3 32 63 ee			ld (debug_mark+1),a  
a6d6 3a e0 a6			ld a, (.dmark+2)  
a6d9 32 64 ee			ld (debug_mark+2),a  
a6dc 18 03			jr .pastdmark  
a6de ..			.dmark: db "ROT"  
a6e1 f1			.pastdmark: pop af  
a6e2			endm  
# End of macro DMARK
a6e2					CALLMONITOR 
a6e2 cd 6f ee			call debug_vector  
a6e5				endm  
# End of macro CALLMONITOR
a6e5				endif 
a6e5			 
a6e5			; DONE Use os stack swap memory 
a6e5			 
a6e5				FORTH_DSP_PTR 0     ; u3 
a6e5 2a e5 e9			ld hl,(cli_data_sp) 
a6e8 11 00 00			ld de, 0 * 3 
a6eb ed 52			sbc hl, de 
a6ed				endm 
# End of macro FORTH_DSP_PTR
a6ed cd fe 9c			call hltostack1     
a6f0			  
a6f0				FORTH_DSP_PTR 1     ; u2 
a6f0 2a e5 e9			ld hl,(cli_data_sp) 
a6f3 11 03 00			ld de, 1 * 3 
a6f6 ed 52			sbc hl, de 
a6f8				endm 
# End of macro FORTH_DSP_PTR
a6f8 cd 04 9d			call hltostack2      
a6fb			 
a6fb				FORTH_DSP_PTR 2     ; u1 
a6fb 2a e5 e9			ld hl,(cli_data_sp) 
a6fe 11 06 00			ld de, 2 * 3 
a701 ed 52			sbc hl, de 
a703				endm 
# End of macro FORTH_DSP_PTR
a703 cd 0a 9d			call hltostack3 
a706			 
a706			 
a706				FORTH_DSP_PTR 0     ;  
a706 2a e5 e9			ld hl,(cli_data_sp) 
a709 11 00 00			ld de, 0 * 3 
a70c ed 52			sbc hl, de 
a70e				endm 
# End of macro FORTH_DSP_PTR
a70e cd 22 9d			call hlfromstack3 
a711			 
a711				FORTH_DSP_PTR 1     ; TOS 
a711 2a e5 e9			ld hl,(cli_data_sp) 
a714 11 03 00			ld de, 1 * 3 
a717 ed 52			sbc hl, de 
a719				endm 
# End of macro FORTH_DSP_PTR
a719 cd 16 9d			call hlfromstack1 
a71c			 
a71c				FORTH_DSP_PTR 2     ; TOS 
a71c 2a e5 e9			ld hl,(cli_data_sp) 
a71f 11 06 00			ld de, 2 * 3 
a722 ed 52			sbc hl, de 
a724				endm 
# End of macro FORTH_DSP_PTR
a724 cd 1c 9d			call hlfromstack2 
a727			 
a727			 
a727			;	FORTH_DSP_VALUEHL 
a727			;	push hl    ; u3  
a727			; 
a727			;	FORTH_DSP_POP 
a727			; 
a727			;	FORTH_DSP_VALUEHL 
a727			;	push hl     ; u2 
a727			; 
a727			;	FORTH_DSP_POP 
a727			; 
a727			;	FORTH_DSP_VALUEHL 
a727			;	push hl     ; u1 
a727			; 
a727			;	FORTH_DSP_POP 
a727			; 
a727			;	pop bc      ; u1 
a727			;	pop hl      ; u2 
a727			;	pop de      ; u3 
a727			; 
a727			; 
a727			;	push bc 
a727			;	push de 
a727			;	push hl 
a727			; 
a727			; 
a727			;	pop hl 
a727			;	call forth_push_numhl 
a727			; 
a727			;	pop hl 
a727			;	call forth_push_numhl 
a727			; 
a727			;	pop hl 
a727			;	call forth_push_numhl 
a727				 
a727			 
a727			 
a727			 
a727			 
a727			 
a727			       NEXTW 
a727 cd 6c ee			call parse_vector 
a72a c3 ae 9d			jp macro_next 
a72d				endm 
# End of macro NEXTW
a72d			 
a72d			.UWORDS: 
a72d			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a72d 50				db WORD_SYS_CORE+60             
a72e f2 a7			dw .BP            
a730 07				db 6 + 1 
a731 .. 00			db "UWORDS",0              
a738				endm 
# End of macro CWHEAD
a738			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a738			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a738			; | | Following the count are the individual words. 
a738			; | | 
a738			; | | e.g. UWORDS 
a738			; | | BOX DIRLIST 2 
a738			; | |  
a738			; | | Can be used to save the words to storage via: 
a738			; | | UWORDS $01 DO $01 APPEND LOOP 
a738			if DEBUG_FORTH_WORDS_KEY 
a738				DMARK "UWR" 
a738 f5				push af  
a739 3a 4d a7			ld a, (.dmark)  
a73c 32 62 ee			ld (debug_mark),a  
a73f 3a 4e a7			ld a, (.dmark+1)  
a742 32 63 ee			ld (debug_mark+1),a  
a745 3a 4f a7			ld a, (.dmark+2)  
a748 32 64 ee			ld (debug_mark+2),a  
a74b 18 03			jr .pastdmark  
a74d ..			.dmark: db "UWR"  
a750 f1			.pastdmark: pop af  
a751			endm  
# End of macro DMARK
a751				CALLMONITOR 
a751 cd 6f ee			call debug_vector  
a754				endm  
# End of macro CALLMONITOR
a754			endif 
a754 21 95 e3			ld hl, baseram 
a757				;ld hl, baseusermem 
a757 01 00 00			ld bc, 0    ; start a counter 
a75a			 
a75a			; skip dict stub 
a75a			 
a75a cd e0 9e			call forth_tok_next 
a75d			 
a75d			 
a75d			; while we have words to look for 
a75d			 
a75d 7e			.douscan:	ld a, (hl)      
a75e			if DEBUG_FORTH_WORDS 
a75e				DMARK "UWs" 
a75e f5				push af  
a75f 3a 73 a7			ld a, (.dmark)  
a762 32 62 ee			ld (debug_mark),a  
a765 3a 74 a7			ld a, (.dmark+1)  
a768 32 63 ee			ld (debug_mark+1),a  
a76b 3a 75 a7			ld a, (.dmark+2)  
a76e 32 64 ee			ld (debug_mark+2),a  
a771 18 03			jr .pastdmark  
a773 ..			.dmark: db "UWs"  
a776 f1			.pastdmark: pop af  
a777			endm  
# End of macro DMARK
a777				CALLMONITOR 
a777 cd 6f ee			call debug_vector  
a77a				endm  
# End of macro CALLMONITOR
a77a			endif 
a77a fe 00			cp WORD_SYS_END 
a77c 28 4d			jr z, .udone 
a77e fe 01			cp WORD_SYS_UWORD 
a780 20 44			jr nz, .nuword 
a782			 
a782			if DEBUG_FORTH_WORDS 
a782				DMARK "UWu" 
a782 f5				push af  
a783 3a 97 a7			ld a, (.dmark)  
a786 32 62 ee			ld (debug_mark),a  
a789 3a 98 a7			ld a, (.dmark+1)  
a78c 32 63 ee			ld (debug_mark+1),a  
a78f 3a 99 a7			ld a, (.dmark+2)  
a792 32 64 ee			ld (debug_mark+2),a  
a795 18 03			jr .pastdmark  
a797 ..			.dmark: db "UWu"  
a79a f1			.pastdmark: pop af  
a79b			endm  
# End of macro DMARK
a79b				CALLMONITOR 
a79b cd 6f ee			call debug_vector  
a79e				endm  
# End of macro CALLMONITOR
a79e			endif 
a79e				; we have a uword so push its name to the stack 
a79e			 
a79e e5				push hl  ; save so we can move to next dict block 
a79f			 
a79f				; skip opcode 
a79f 23				inc hl  
a7a0				; skip next ptr 
a7a0 23				inc hl  
a7a1 23				inc hl 
a7a2				; skip len 
a7a2 23				inc hl 
a7a3			if DEBUG_FORTH_WORDS 
a7a3				DMARK "UWt" 
a7a3 f5				push af  
a7a4 3a b8 a7			ld a, (.dmark)  
a7a7 32 62 ee			ld (debug_mark),a  
a7aa 3a b9 a7			ld a, (.dmark+1)  
a7ad 32 63 ee			ld (debug_mark+1),a  
a7b0 3a ba a7			ld a, (.dmark+2)  
a7b3 32 64 ee			ld (debug_mark+2),a  
a7b6 18 03			jr .pastdmark  
a7b8 ..			.dmark: db "UWt"  
a7bb f1			.pastdmark: pop af  
a7bc			endm  
# End of macro DMARK
a7bc				CALLMONITOR 
a7bc cd 6f ee			call debug_vector  
a7bf				endm  
# End of macro CALLMONITOR
a7bf			endif 
a7bf 03				inc bc 
a7c0			 
a7c0 c5				push bc 
a7c1 cd 35 9a			call forth_push_str 
a7c4 c1				pop bc 
a7c5			 
a7c5 e1				pop hl 	 
a7c6			 
a7c6 cd e0 9e		.nuword:	call forth_tok_next 
a7c9 18 92			jr .douscan  
a7cb			 
a7cb			.udone:		 ; push count of uwords found 
a7cb c5				push bc 
a7cc e1				pop hl 
a7cd			 
a7cd			if DEBUG_FORTH_WORDS 
a7cd				DMARK "UWc" 
a7cd f5				push af  
a7ce 3a e2 a7			ld a, (.dmark)  
a7d1 32 62 ee			ld (debug_mark),a  
a7d4 3a e3 a7			ld a, (.dmark+1)  
a7d7 32 63 ee			ld (debug_mark+1),a  
a7da 3a e4 a7			ld a, (.dmark+2)  
a7dd 32 64 ee			ld (debug_mark+2),a  
a7e0 18 03			jr .pastdmark  
a7e2 ..			.dmark: db "UWc"  
a7e5 f1			.pastdmark: pop af  
a7e6			endm  
# End of macro DMARK
a7e6				CALLMONITOR 
a7e6 cd 6f ee			call debug_vector  
a7e9				endm  
# End of macro CALLMONITOR
a7e9			endif 
a7e9 cd cb 99			call forth_push_numhl 
a7ec			 
a7ec			 
a7ec			       NEXTW 
a7ec cd 6c ee			call parse_vector 
a7ef c3 ae 9d			jp macro_next 
a7f2				endm 
# End of macro NEXTW
a7f2			 
a7f2			.BP: 
a7f2			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a7f2 54				db WORD_SYS_CORE+64             
a7f3 32 a8			dw .MONITOR            
a7f5 03				db 2 + 1 
a7f6 .. 00			db "BP",0              
a7f9				endm 
# End of macro CWHEAD
a7f9			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a7f9			; | | $00 Will enable the break points within specific code paths 
a7f9			; | | $01 Will disable break points 
a7f9			; | |  
a7f9			; | | By default break points are off. Either the above can be used to enable them 
a7f9			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a7f9			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
a7f9			; | | can disable break points. Exiting will then continue boot process. 
a7f9				; get byte count 
a7f9				if DEBUG_FORTH_WORDS_KEY 
a7f9					DMARK "BP." 
a7f9 f5				push af  
a7fa 3a 0e a8			ld a, (.dmark)  
a7fd 32 62 ee			ld (debug_mark),a  
a800 3a 0f a8			ld a, (.dmark+1)  
a803 32 63 ee			ld (debug_mark+1),a  
a806 3a 10 a8			ld a, (.dmark+2)  
a809 32 64 ee			ld (debug_mark+2),a  
a80c 18 03			jr .pastdmark  
a80e ..			.dmark: db "BP."  
a811 f1			.pastdmark: pop af  
a812			endm  
# End of macro DMARK
a812					CALLMONITOR 
a812 cd 6f ee			call debug_vector  
a815				endm  
# End of macro CALLMONITOR
a815				endif 
a815			 
a815				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a815 cd c7 9b			call macro_dsp_valuehl 
a818				endm 
# End of macro FORTH_DSP_VALUEHL
a818			 
a818			;		push hl 
a818			 
a818				; destroy value TOS 
a818			 
a818				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a818 cd 7f 9c			call macro_forth_dsp_pop 
a81b				endm 
# End of macro FORTH_DSP_POP
a81b			 
a81b			;		pop hl 
a81b			 
a81b 3e 00			ld a,0 
a81d bd				cp l 
a81e 28 09			jr z, .bpset 
a820			;		ld a, '*' 
a820 cd 56 93			call bp_off 
a823				NEXTW 
a823 cd 6c ee			call parse_vector 
a826 c3 ae 9d			jp macro_next 
a829				endm 
# End of macro NEXTW
a829			 
a829			.bpset:	 
a829				;	ld (os_view_disable), a 
a829 cd 4a 93			call bp_on 
a82c			 
a82c			 
a82c				NEXTW 
a82c cd 6c ee			call parse_vector 
a82f c3 ae 9d			jp macro_next 
a832				endm 
# End of macro NEXTW
a832			 
a832			 
a832			.MONITOR: 
a832			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a832 55				db WORD_SYS_CORE+65             
a833 66 a8			dw .MALLOC            
a835 08				db 7 + 1 
a836 .. 00			db "MONITOR",0              
a83e				endm 
# End of macro CWHEAD
a83e			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a83e			; | | At start the current various registers will be displayed with contents. 
a83e			; | | Top right corner will show the most recent debug marker seen. 
a83e			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a83e			; | | and the return stack pointer (RSP). 
a83e			; | | Pressing: 
a83e			; | |  
a83e			; | |    1 - Initial screen 
a83e			; | |  
a83e			; | |    2 - Display a data dump of HL 
a83e			; | |  
a83e			; | |    3 - Display a data dump of DE 
a83e			; | |  
a83e			; | |    4 - Display a data dump of BC 
a83e			; | |  
a83e			; | |    5 - Display a data dump of HL 
a83e			; | |  
a83e			; | |    6 - Display a data dump of DSP 
a83e			; | |  
a83e			; | |    7 - Display a data dump of RSP 
a83e			; | |  
a83e			; | |    8 - Display a data dump of what is at DSP 
a83e			; | |  
a83e			; | |    9 - Display a data dump of what is at RSP 
a83e			; | |  
a83e			; | |    0 - Exit monitor and continue running. This will also enable break points 
a83e			; | |  
a83e			; | |    * - Disable break points 
a83e			; | |  
a83e			; | |    # - Enter traditional monitor mode 
a83e			; | |  
a83e			; | | 
a83e			; | | Monitor Mode 
a83e			; | | ------------ 
a83e			; | | A prompt of '>' will be shown for various commands: 
a83e			; | |  
a83e			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a83e			; | |  
a83e			; | |    C - Continue display a data dump from the last set address 
a83e			; | |  
a83e			; | |    M xxxx - Set start of memory edit at address xx 
a83e			; | |  
a83e			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a83e			; | |  
a83e			; | |    G xxxx - Exec code at specific address 
a83e			; | |  
a83e			; | |    Q - Return to previous 
a83e				if DEBUG_FORTH_WORDS_KEY 
a83e					DMARK "MON" 
a83e f5				push af  
a83f 3a 53 a8			ld a, (.dmark)  
a842 32 62 ee			ld (debug_mark),a  
a845 3a 54 a8			ld a, (.dmark+1)  
a848 32 63 ee			ld (debug_mark+1),a  
a84b 3a 55 a8			ld a, (.dmark+2)  
a84e 32 64 ee			ld (debug_mark+2),a  
a851 18 03			jr .pastdmark  
a853 ..			.dmark: db "MON"  
a856 f1			.pastdmark: pop af  
a857			endm  
# End of macro DMARK
a857					CALLMONITOR 
a857 cd 6f ee			call debug_vector  
a85a				endm  
# End of macro CALLMONITOR
a85a				endif 
a85a			;		ld a, 0 
a85a			;		ld (os_view_disable), a 
a85a cd 4a 93			call bp_on 
a85d			 
a85d				CALLMONITOR 
a85d cd 6f ee			call debug_vector  
a860				endm  
# End of macro CALLMONITOR
a860			 
a860			;	call monitor 
a860			 
a860				NEXTW 
a860 cd 6c ee			call parse_vector 
a863 c3 ae 9d			jp macro_next 
a866				endm 
# End of macro NEXTW
a866			 
a866			 
a866			.MALLOC: 
a866			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a866 56				db WORD_SYS_CORE+66             
a867 8f a8			dw .MALLOC2            
a869 06				db 5 + 1 
a86a .. 00			db "ALLOT",0              
a870				endm 
# End of macro CWHEAD
a870			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a870				if DEBUG_FORTH_WORDS_KEY 
a870					DMARK "ALL" 
a870 f5				push af  
a871 3a 85 a8			ld a, (.dmark)  
a874 32 62 ee			ld (debug_mark),a  
a877 3a 86 a8			ld a, (.dmark+1)  
a87a 32 63 ee			ld (debug_mark+1),a  
a87d 3a 87 a8			ld a, (.dmark+2)  
a880 32 64 ee			ld (debug_mark+2),a  
a883 18 03			jr .pastdmark  
a885 ..			.dmark: db "ALL"  
a888 f1			.pastdmark: pop af  
a889			endm  
# End of macro DMARK
a889					CALLMONITOR 
a889 cd 6f ee			call debug_vector  
a88c				endm  
# End of macro CALLMONITOR
a88c				endif 
a88c c3 b6 a8			jp .mallocc 
a88f			.MALLOC2: 
a88f			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a88f 56				db WORD_SYS_CORE+66             
a890 d0 a8			dw .FREE            
a892 07				db 6 + 1 
a893 .. 00			db "MALLOC",0              
a89a				endm 
# End of macro CWHEAD
a89a			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a89a				; get byte count 
a89a				if DEBUG_FORTH_WORDS_KEY 
a89a					DMARK "MAL" 
a89a f5				push af  
a89b 3a af a8			ld a, (.dmark)  
a89e 32 62 ee			ld (debug_mark),a  
a8a1 3a b0 a8			ld a, (.dmark+1)  
a8a4 32 63 ee			ld (debug_mark+1),a  
a8a7 3a b1 a8			ld a, (.dmark+2)  
a8aa 32 64 ee			ld (debug_mark+2),a  
a8ad 18 03			jr .pastdmark  
a8af ..			.dmark: db "MAL"  
a8b2 f1			.pastdmark: pop af  
a8b3			endm  
# End of macro DMARK
a8b3					CALLMONITOR 
a8b3 cd 6f ee			call debug_vector  
a8b6				endm  
# End of macro CALLMONITOR
a8b6				endif 
a8b6			.mallocc: 
a8b6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a8b6 cd c7 9b			call macro_dsp_valuehl 
a8b9				endm 
# End of macro FORTH_DSP_VALUEHL
a8b9			 
a8b9			;		push hl 
a8b9			 
a8b9				; destroy value TOS 
a8b9			 
a8b9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a8b9 cd 7f 9c			call macro_forth_dsp_pop 
a8bc				endm 
# End of macro FORTH_DSP_POP
a8bc			 
a8bc			;		pop hl 
a8bc cd a2 90			call malloc 
a8bf			if DEBUG_FORTH_MALLOC_GUARD 
a8bf f5				push af 
a8c0 cd ff 8c			call ishlzero 
a8c3			;		ld a, l 
a8c3			;		add h 
a8c3			;		cp 0 
a8c3 f1				pop af 
a8c4				 
a8c4 cc 47 d2			call z,malloc_error 
a8c7			endif 
a8c7			 
a8c7 cd cb 99			call forth_push_numhl 
a8ca				NEXTW 
a8ca cd 6c ee			call parse_vector 
a8cd c3 ae 9d			jp macro_next 
a8d0				endm 
# End of macro NEXTW
a8d0			 
a8d0			.FREE: 
a8d0			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
a8d0 57				db WORD_SYS_CORE+67             
a8d1 04 a9			dw .UPTR            
a8d3 05				db 4 + 1 
a8d4 .. 00			db "FREE",0              
a8d9				endm 
# End of macro CWHEAD
a8d9			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a8d9				if DEBUG_FORTH_WORDS_KEY 
a8d9					DMARK "FRE" 
a8d9 f5				push af  
a8da 3a ee a8			ld a, (.dmark)  
a8dd 32 62 ee			ld (debug_mark),a  
a8e0 3a ef a8			ld a, (.dmark+1)  
a8e3 32 63 ee			ld (debug_mark+1),a  
a8e6 3a f0 a8			ld a, (.dmark+2)  
a8e9 32 64 ee			ld (debug_mark+2),a  
a8ec 18 03			jr .pastdmark  
a8ee ..			.dmark: db "FRE"  
a8f1 f1			.pastdmark: pop af  
a8f2			endm  
# End of macro DMARK
a8f2					CALLMONITOR 
a8f2 cd 6f ee			call debug_vector  
a8f5				endm  
# End of macro CALLMONITOR
a8f5				endif 
a8f5				; get address 
a8f5			 
a8f5				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a8f5 cd c7 9b			call macro_dsp_valuehl 
a8f8				endm 
# End of macro FORTH_DSP_VALUEHL
a8f8			 
a8f8			;		push hl 
a8f8			 
a8f8				; destroy value TOS 
a8f8			 
a8f8				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a8f8 cd 7f 9c			call macro_forth_dsp_pop 
a8fb				endm 
# End of macro FORTH_DSP_POP
a8fb			 
a8fb			;		pop hl 
a8fb			if FORTH_ENABLE_MALLOCFREE 
a8fb cd 6c 91			call free 
a8fe			endif 
a8fe				NEXTW 
a8fe cd 6c ee			call parse_vector 
a901 c3 ae 9d			jp macro_next 
a904				endm 
# End of macro NEXTW
a904			.UPTR: 
a904			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
a904 57				db WORD_SYS_CORE+67             
a905 0a aa			dw .LIST            
a907 05				db 4 + 1 
a908 .. 00			db "UPTR",0              
a90d				endm 
# End of macro CWHEAD
a90d			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
a90d				if DEBUG_FORTH_WORDS_KEY 
a90d					DMARK "UPT" 
a90d f5				push af  
a90e 3a 22 a9			ld a, (.dmark)  
a911 32 62 ee			ld (debug_mark),a  
a914 3a 23 a9			ld a, (.dmark+1)  
a917 32 63 ee			ld (debug_mark+1),a  
a91a 3a 24 a9			ld a, (.dmark+2)  
a91d 32 64 ee			ld (debug_mark+2),a  
a920 18 03			jr .pastdmark  
a922 ..			.dmark: db "UPT"  
a925 f1			.pastdmark: pop af  
a926			endm  
# End of macro DMARK
a926					CALLMONITOR 
a926 cd 6f ee			call debug_vector  
a929				endm  
# End of macro CALLMONITOR
a929				endif 
a929				FORTH_DSP_VALUEHL 
a929 cd c7 9b			call macro_dsp_valuehl 
a92c				endm 
# End of macro FORTH_DSP_VALUEHL
a92c			 
a92c e5				push hl 
a92d				FORTH_DSP_POP 
a92d cd 7f 9c			call macro_forth_dsp_pop 
a930				endm 
# End of macro FORTH_DSP_POP
a930 c1				pop bc 
a931			 
a931			 
a931				; Get ptr to the word we need to look up 
a931			 
a931			;		FORTH_DSP_VALUEHL 
a931				;v5 FORTH_DSP_VALUE 
a931			; TODO type check 
a931			;		inc hl    ; Skip type check  
a931			;		push hl 
a931			;		ex de, hl    ; put into DE 
a931			 
a931			 
a931 21 95 e3			ld hl, baseram 
a934				;ld hl, baseusermem 
a934			 
a934 e5			push hl   ; sacreifical push 
a935			 
a935			.uldouscanm: 
a935 e1			pop hl 
a936			.uldouscan: 
a936			if DEBUG_FORTH_WORDS 
a936				DMARK "LSs" 
a936 f5				push af  
a937 3a 4b a9			ld a, (.dmark)  
a93a 32 62 ee			ld (debug_mark),a  
a93d 3a 4c a9			ld a, (.dmark+1)  
a940 32 63 ee			ld (debug_mark+1),a  
a943 3a 4d a9			ld a, (.dmark+2)  
a946 32 64 ee			ld (debug_mark+2),a  
a949 18 03			jr .pastdmark  
a94b ..			.dmark: db "LSs"  
a94e f1			.pastdmark: pop af  
a94f			endm  
# End of macro DMARK
a94f				CALLMONITOR 
a94f cd 6f ee			call debug_vector  
a952				endm  
# End of macro CALLMONITOR
a952			endif 
a952			; skip dict stub 
a952 cd e0 9e			call forth_tok_next 
a955			 
a955			 
a955			; while we have words to look for 
a955			 
a955 7e			ld a, (hl)      
a956			if DEBUG_FORTH_WORDS 
a956				DMARK "LSk" 
a956 f5				push af  
a957 3a 6b a9			ld a, (.dmark)  
a95a 32 62 ee			ld (debug_mark),a  
a95d 3a 6c a9			ld a, (.dmark+1)  
a960 32 63 ee			ld (debug_mark+1),a  
a963 3a 6d a9			ld a, (.dmark+2)  
a966 32 64 ee			ld (debug_mark+2),a  
a969 18 03			jr .pastdmark  
a96b ..			.dmark: db "LSk"  
a96e f1			.pastdmark: pop af  
a96f			endm  
# End of macro DMARK
a96f				CALLMONITOR 
a96f cd 6f ee			call debug_vector  
a972				endm  
# End of macro CALLMONITOR
a972			endif 
a972				;cp WORD_SYS_END 
a972				;jp z, .lunotfound 
a972			 
a972					; if we hit non uwords then gone too far 
a972 fe 01				cp WORD_SYS_UWORD 
a974 c2 01 aa				jp nz, .ulunotfound 
a977			 
a977				if DEBUG_FORTH_WORDS 
a977					DMARK "LSu" 
a977 f5				push af  
a978 3a 8c a9			ld a, (.dmark)  
a97b 32 62 ee			ld (debug_mark),a  
a97e 3a 8d a9			ld a, (.dmark+1)  
a981 32 63 ee			ld (debug_mark+1),a  
a984 3a 8e a9			ld a, (.dmark+2)  
a987 32 64 ee			ld (debug_mark+2),a  
a98a 18 03			jr .pastdmark  
a98c ..			.dmark: db "LSu"  
a98f f1			.pastdmark: pop af  
a990			endm  
# End of macro DMARK
a990					CALLMONITOR 
a990 cd 6f ee			call debug_vector  
a993				endm  
# End of macro CALLMONITOR
a993				endif 
a993			 
a993					; found a uword but is it the one we want... 
a993			 
a993 c5					push bc     ; uword to find is on bc 
a994 d1					pop de 
a995			 
a995 e5					push hl  ; to save the ptr 
a996			 
a996					; skip opcode 
a996 23					inc hl  
a997					; skip next ptr 
a997 23					inc hl  
a998 23					inc hl 
a999					; skip len 
a999 23					inc hl 
a99a			 
a99a				if DEBUG_FORTH_WORDS 
a99a					DMARK "LSc" 
a99a f5				push af  
a99b 3a af a9			ld a, (.dmark)  
a99e 32 62 ee			ld (debug_mark),a  
a9a1 3a b0 a9			ld a, (.dmark+1)  
a9a4 32 63 ee			ld (debug_mark+1),a  
a9a7 3a b1 a9			ld a, (.dmark+2)  
a9aa 32 64 ee			ld (debug_mark+2),a  
a9ad 18 03			jr .pastdmark  
a9af ..			.dmark: db "LSc"  
a9b2 f1			.pastdmark: pop af  
a9b3			endm  
# End of macro DMARK
a9b3					CALLMONITOR 
a9b3 cd 6f ee			call debug_vector  
a9b6				endm  
# End of macro CALLMONITOR
a9b6				endif 
a9b6			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
a9b6			; ie. If WOO is defined first and then WO. Couldnt list WO. 
a9b6			; Nope that has gone the other way. It needs to be exact not on first zero 
a9b6			;		call strcmp 
a9b6 c5					push bc 
a9b7 cd 72 90				call StrictStrCmp 
a9ba c1					pop bc 
a9bb c2 35 a9				jp nz, .uldouscanm 
a9be				 
a9be			 
a9be			 
a9be					; we have a uword so push its name to the stack 
a9be			 
a9be			;	   	push hl  ; save so we can move to next dict block 
a9be e1			pop hl 
a9bf			 
a9bf				if DEBUG_FORTH_WORDS 
a9bf					DMARK "LSm" 
a9bf f5				push af  
a9c0 3a d4 a9			ld a, (.dmark)  
a9c3 32 62 ee			ld (debug_mark),a  
a9c6 3a d5 a9			ld a, (.dmark+1)  
a9c9 32 63 ee			ld (debug_mark+1),a  
a9cc 3a d6 a9			ld a, (.dmark+2)  
a9cf 32 64 ee			ld (debug_mark+2),a  
a9d2 18 03			jr .pastdmark  
a9d4 ..			.dmark: db "LSm"  
a9d7 f1			.pastdmark: pop af  
a9d8			endm  
# End of macro DMARK
a9d8					CALLMONITOR 
a9d8 cd 6f ee			call debug_vector  
a9db				endm  
# End of macro CALLMONITOR
a9db				endif 
a9db			 
a9db					; skip opcode 
a9db 23					inc hl  
a9dc					; skip next ptr 
a9dc 23					inc hl  
a9dd 23					inc hl 
a9de					; skip len 
a9de 7e					ld a, (hl)   ; save length to add 
a9df				if DEBUG_FORTH_WORDS 
a9df					DMARK "LS2" 
a9df f5				push af  
a9e0 3a f4 a9			ld a, (.dmark)  
a9e3 32 62 ee			ld (debug_mark),a  
a9e6 3a f5 a9			ld a, (.dmark+1)  
a9e9 32 63 ee			ld (debug_mark+1),a  
a9ec 3a f6 a9			ld a, (.dmark+2)  
a9ef 32 64 ee			ld (debug_mark+2),a  
a9f2 18 03			jr .pastdmark  
a9f4 ..			.dmark: db "LS2"  
a9f7 f1			.pastdmark: pop af  
a9f8			endm  
# End of macro DMARK
a9f8					CALLMONITOR 
a9f8 cd 6f ee			call debug_vector  
a9fb				endm  
# End of macro CALLMONITOR
a9fb				endif 
a9fb			 
a9fb				; skip zero term and other uword defs to position right at the exec code 
a9fb 06 04			ld b, 4 
a9fd 80				add a,b 
a9fe			 
a9fe cd d6 8c			call addatohl 
aa01					; save this location 
aa01				 
aa01			.ulunotfound: 
aa01 cd cb 99			call forth_push_numhl 
aa04						 
aa04				NEXTW 
aa04 cd 6c ee			call parse_vector 
aa07 c3 ae 9d			jp macro_next 
aa0a				endm 
# End of macro NEXTW
aa0a			.LIST: 
aa0a			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
aa0a 5c				db WORD_SYS_CORE+72             
aa0b 0c ac			dw .FORGET            
aa0d 05				db 4 + 1 
aa0e .. 00			db "LIST",0              
aa13				endm 
# End of macro CWHEAD
aa13			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
aa13			; | | The quoted word must be in upper case. 
aa13			if DEBUG_FORTH_WORDS_KEY 
aa13				DMARK "LST" 
aa13 f5				push af  
aa14 3a 28 aa			ld a, (.dmark)  
aa17 32 62 ee			ld (debug_mark),a  
aa1a 3a 29 aa			ld a, (.dmark+1)  
aa1d 32 63 ee			ld (debug_mark+1),a  
aa20 3a 2a aa			ld a, (.dmark+2)  
aa23 32 64 ee			ld (debug_mark+2),a  
aa26 18 03			jr .pastdmark  
aa28 ..			.dmark: db "LST"  
aa2b f1			.pastdmark: pop af  
aa2c			endm  
# End of macro DMARK
aa2c				CALLMONITOR 
aa2c cd 6f ee			call debug_vector  
aa2f				endm  
# End of macro CALLMONITOR
aa2f			endif 
aa2f			 
aa2f				FORTH_DSP_VALUEHL 
aa2f cd c7 9b			call macro_dsp_valuehl 
aa32				endm 
# End of macro FORTH_DSP_VALUEHL
aa32			 
aa32 e5				push hl 
aa33				FORTH_DSP_POP 
aa33 cd 7f 9c			call macro_forth_dsp_pop 
aa36				endm 
# End of macro FORTH_DSP_POP
aa36 c1				pop bc 
aa37			 
aa37			; Start format of scratch string 
aa37			 
aa37 21 b8 e2			ld hl, scratch 
aa3a			 
aa3a			;	ld a, ':' 
aa3a 36 3a			ld (hl),':' 
aa3c 23				inc hl 
aa3d			;	ld a, ' ' 
aa3d 36 20			ld (hl), ' ' 
aa3f			 
aa3f				; Get ptr to the word we need to look up 
aa3f			 
aa3f			;		FORTH_DSP_VALUEHL 
aa3f				;v5 FORTH_DSP_VALUE 
aa3f			; TODO type check 
aa3f			;		inc hl    ; Skip type check  
aa3f			;		push hl 
aa3f			;		ex de, hl    ; put into DE 
aa3f			 
aa3f			 
aa3f 21 95 e3			ld hl, baseram 
aa42				;ld hl, baseusermem 
aa42			 
aa42 e5			push hl   ; sacreifical push 
aa43			 
aa43			.ldouscanm: 
aa43 e1			pop hl 
aa44			.ldouscan: 
aa44			if DEBUG_FORTH_WORDS 
aa44				DMARK "LSs" 
aa44 f5				push af  
aa45 3a 59 aa			ld a, (.dmark)  
aa48 32 62 ee			ld (debug_mark),a  
aa4b 3a 5a aa			ld a, (.dmark+1)  
aa4e 32 63 ee			ld (debug_mark+1),a  
aa51 3a 5b aa			ld a, (.dmark+2)  
aa54 32 64 ee			ld (debug_mark+2),a  
aa57 18 03			jr .pastdmark  
aa59 ..			.dmark: db "LSs"  
aa5c f1			.pastdmark: pop af  
aa5d			endm  
# End of macro DMARK
aa5d				CALLMONITOR 
aa5d cd 6f ee			call debug_vector  
aa60				endm  
# End of macro CALLMONITOR
aa60			endif 
aa60			; skip dict stub 
aa60 cd e0 9e			call forth_tok_next 
aa63			 
aa63			 
aa63			; while we have words to look for 
aa63			 
aa63 7e			ld a, (hl)      
aa64			if DEBUG_FORTH_WORDS 
aa64				DMARK "LSk" 
aa64 f5				push af  
aa65 3a 79 aa			ld a, (.dmark)  
aa68 32 62 ee			ld (debug_mark),a  
aa6b 3a 7a aa			ld a, (.dmark+1)  
aa6e 32 63 ee			ld (debug_mark+1),a  
aa71 3a 7b aa			ld a, (.dmark+2)  
aa74 32 64 ee			ld (debug_mark+2),a  
aa77 18 03			jr .pastdmark  
aa79 ..			.dmark: db "LSk"  
aa7c f1			.pastdmark: pop af  
aa7d			endm  
# End of macro DMARK
aa7d				CALLMONITOR 
aa7d cd 6f ee			call debug_vector  
aa80				endm  
# End of macro CALLMONITOR
aa80			endif 
aa80				;cp WORD_SYS_END 
aa80				;jp z, .lunotfound 
aa80			 
aa80					; if we hit non uwords then gone too far 
aa80 fe 01				cp WORD_SYS_UWORD 
aa82 c2 bf ab				jp nz, .lunotfound 
aa85			 
aa85				if DEBUG_FORTH_WORDS 
aa85					DMARK "LSu" 
aa85 f5				push af  
aa86 3a 9a aa			ld a, (.dmark)  
aa89 32 62 ee			ld (debug_mark),a  
aa8c 3a 9b aa			ld a, (.dmark+1)  
aa8f 32 63 ee			ld (debug_mark+1),a  
aa92 3a 9c aa			ld a, (.dmark+2)  
aa95 32 64 ee			ld (debug_mark+2),a  
aa98 18 03			jr .pastdmark  
aa9a ..			.dmark: db "LSu"  
aa9d f1			.pastdmark: pop af  
aa9e			endm  
# End of macro DMARK
aa9e					CALLMONITOR 
aa9e cd 6f ee			call debug_vector  
aaa1				endm  
# End of macro CALLMONITOR
aaa1				endif 
aaa1			 
aaa1					; found a uword but is it the one we want... 
aaa1			 
aaa1 c5					push bc     ; uword to find is on bc 
aaa2 d1					pop de 
aaa3			 
aaa3 e5					push hl  ; to save the ptr 
aaa4			 
aaa4					; skip opcode 
aaa4 23					inc hl  
aaa5					; skip next ptr 
aaa5 23					inc hl  
aaa6 23					inc hl 
aaa7					; skip len 
aaa7 23					inc hl 
aaa8			 
aaa8				if DEBUG_FORTH_WORDS 
aaa8					DMARK "LSc" 
aaa8 f5				push af  
aaa9 3a bd aa			ld a, (.dmark)  
aaac 32 62 ee			ld (debug_mark),a  
aaaf 3a be aa			ld a, (.dmark+1)  
aab2 32 63 ee			ld (debug_mark+1),a  
aab5 3a bf aa			ld a, (.dmark+2)  
aab8 32 64 ee			ld (debug_mark+2),a  
aabb 18 03			jr .pastdmark  
aabd ..			.dmark: db "LSc"  
aac0 f1			.pastdmark: pop af  
aac1			endm  
# End of macro DMARK
aac1					CALLMONITOR 
aac1 cd 6f ee			call debug_vector  
aac4				endm  
# End of macro CALLMONITOR
aac4				endif 
aac4			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
aac4			; ie. If WOO is defined first and then WO. Couldnt list WO. 
aac4			; Nope that has gone the other way. It needs to be exact not on first zero 
aac4			;		call strcmp 
aac4 c5					push bc 
aac5 cd 72 90				call StrictStrCmp 
aac8 c1					pop bc 
aac9 c2 43 aa				jp nz, .ldouscanm 
aacc				 
aacc			 
aacc			 
aacc					; we have a uword so push its name to the stack 
aacc			 
aacc			;	   	push hl  ; save so we can move to next dict block 
aacc e1			pop hl 
aacd			 
aacd				if DEBUG_FORTH_WORDS 
aacd					DMARK "LSm" 
aacd f5				push af  
aace 3a e2 aa			ld a, (.dmark)  
aad1 32 62 ee			ld (debug_mark),a  
aad4 3a e3 aa			ld a, (.dmark+1)  
aad7 32 63 ee			ld (debug_mark+1),a  
aada 3a e4 aa			ld a, (.dmark+2)  
aadd 32 64 ee			ld (debug_mark+2),a  
aae0 18 03			jr .pastdmark  
aae2 ..			.dmark: db "LSm"  
aae5 f1			.pastdmark: pop af  
aae6			endm  
# End of macro DMARK
aae6					CALLMONITOR 
aae6 cd 6f ee			call debug_vector  
aae9				endm  
# End of macro CALLMONITOR
aae9				endif 
aae9			 
aae9					; skip opcode 
aae9 23					inc hl  
aaea					; skip next ptr 
aaea 23					inc hl  
aaeb 23					inc hl 
aaec					; skip len 
aaec 7e					ld a, (hl)   ; save length to add 
aaed				if DEBUG_FORTH_WORDS 
aaed					DMARK "LS2" 
aaed f5				push af  
aaee 3a 02 ab			ld a, (.dmark)  
aaf1 32 62 ee			ld (debug_mark),a  
aaf4 3a 03 ab			ld a, (.dmark+1)  
aaf7 32 63 ee			ld (debug_mark+1),a  
aafa 3a 04 ab			ld a, (.dmark+2)  
aafd 32 64 ee			ld (debug_mark+2),a  
ab00 18 03			jr .pastdmark  
ab02 ..			.dmark: db "LS2"  
ab05 f1			.pastdmark: pop af  
ab06			endm  
# End of macro DMARK
ab06					CALLMONITOR 
ab06 cd 6f ee			call debug_vector  
ab09				endm  
# End of macro CALLMONITOR
ab09				endif 
ab09			 
ab09					; save this location 
ab09				 
ab09 e5					push hl 
ab0a			 
ab0a 23					inc hl 
ab0b 11 ba e2				ld de, scratch+2 
ab0e 4f					ld c, a 
ab0f 06 00				ld b, 0 
ab11			 
ab11				if DEBUG_FORTH_WORDS 
ab11					DMARK "LSn" 
ab11 f5				push af  
ab12 3a 26 ab			ld a, (.dmark)  
ab15 32 62 ee			ld (debug_mark),a  
ab18 3a 27 ab			ld a, (.dmark+1)  
ab1b 32 63 ee			ld (debug_mark+1),a  
ab1e 3a 28 ab			ld a, (.dmark+2)  
ab21 32 64 ee			ld (debug_mark+2),a  
ab24 18 03			jr .pastdmark  
ab26 ..			.dmark: db "LSn"  
ab29 f1			.pastdmark: pop af  
ab2a			endm  
# End of macro DMARK
ab2a					CALLMONITOR 
ab2a cd 6f ee			call debug_vector  
ab2d				endm  
# End of macro CALLMONITOR
ab2d				endif 
ab2d			 
ab2d					; copy uword name to scratch 
ab2d			 
ab2d			;		ldir 
ab2d			.licplw:	; copy uword name to scratch converting to lower case as we go 
ab2d ed a0				ldi 
ab2f 1b					dec de 
ab30 1a					ld a, (de) 
ab31 cd 47 8f				call to_lower 
ab34 12					ld (de),a 
ab35 13					inc de 
ab36 3e 00				ld a, 0 
ab38 b9					cp c 
ab39 20 f2				jr nz, .licplw 
ab3b			 
ab3b			 
ab3b			 
ab3b 1b					dec de 
ab3c 3e 20				ld a, ' '    ; change null to space 
ab3e 12					ld (de), a 
ab3f			 
ab3f 13					inc de 
ab40			 
ab40 d5					push de 
ab41 c1					pop bc     ; move scratch pointer to end of word name and save it 
ab42			 
ab42 e1					pop hl 
ab43 7e					ld a, (hl) 
ab44					;inc hl 
ab44					; skip word string 
ab44 cd d6 8c				call addatohl 
ab47			 
ab47 23					inc hl 
ab48			 
ab48				if DEBUG_FORTH_WORDS 
ab48					DMARK "LS3" 
ab48 f5				push af  
ab49 3a 5d ab			ld a, (.dmark)  
ab4c 32 62 ee			ld (debug_mark),a  
ab4f 3a 5e ab			ld a, (.dmark+1)  
ab52 32 63 ee			ld (debug_mark+1),a  
ab55 3a 5f ab			ld a, (.dmark+2)  
ab58 32 64 ee			ld (debug_mark+2),a  
ab5b 18 03			jr .pastdmark  
ab5d ..			.dmark: db "LS3"  
ab60 f1			.pastdmark: pop af  
ab61			endm  
# End of macro DMARK
ab61					CALLMONITOR 
ab61 cd 6f ee			call debug_vector  
ab64				endm  
# End of macro CALLMONITOR
ab64				endif 
ab64					; should now be at the start of the machine code to setup the eval of the uword 
ab64					; now locate the ptr to the string defintion 
ab64			 
ab64					; skip ld hl, 
ab64					; then load the ptr 
ab64			; TODO use get from hl ptr 
ab64 23					inc hl 
ab65 5e					ld e, (hl) 
ab66 23					inc hl 
ab67 56					ld d, (hl) 
ab68 eb					ex de, hl 
ab69			 
ab69			 
ab69				if DEBUG_FORTH_WORDS 
ab69					DMARK "LSt" 
ab69 f5				push af  
ab6a 3a 7e ab			ld a, (.dmark)  
ab6d 32 62 ee			ld (debug_mark),a  
ab70 3a 7f ab			ld a, (.dmark+1)  
ab73 32 63 ee			ld (debug_mark+1),a  
ab76 3a 80 ab			ld a, (.dmark+2)  
ab79 32 64 ee			ld (debug_mark+2),a  
ab7c 18 03			jr .pastdmark  
ab7e ..			.dmark: db "LSt"  
ab81 f1			.pastdmark: pop af  
ab82			endm  
# End of macro DMARK
ab82					CALLMONITOR 
ab82 cd 6f ee			call debug_vector  
ab85				endm  
# End of macro CALLMONITOR
ab85				endif 
ab85			 
ab85			; cant push right now due to tokenised strings  
ab85			 
ab85			; get the destination of where to copy this definition to. 
ab85			 
ab85 c5					push bc 
ab86 d1					pop de 
ab87			 
ab87 7e			.listl:         ld a,(hl) 
ab88			;		cp 0 
ab88 b7					or a 
ab89 28 09				jr z, .lreplsp     ; replace zero with space 
ab8b					;cp FORTH_END_BUFFER 
ab8b fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
ab8d 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
ab8f				 
ab8f					; just copy this char as is then 
ab8f			 
ab8f 12					ld (de), a 
ab90			 
ab90 23			.listnxt:	inc hl 
ab91 13					inc de 
ab92 18 f3				jr .listl 
ab94			 
ab94 3e 20		.lreplsp:	ld a,' ' 
ab96 12					ld (de), a 
ab97 18 f7				jr .listnxt 
ab99			 
ab99			; close up uword def 
ab99			 
ab99			.listdone: 
ab99 12					ld (de), a 
ab9a 13					inc de 
ab9b 3e 00				ld a, 0 
ab9d 12					ld (de), a 
ab9e			 
ab9e			; now have def so clean up and push to stack 
ab9e			 
ab9e 21 b8 e2				ld hl, scratch 
aba1				if DEBUG_FORTH_WORDS 
aba1					DMARK "Ltp" 
aba1 f5				push af  
aba2 3a b6 ab			ld a, (.dmark)  
aba5 32 62 ee			ld (debug_mark),a  
aba8 3a b7 ab			ld a, (.dmark+1)  
abab 32 63 ee			ld (debug_mark+1),a  
abae 3a b8 ab			ld a, (.dmark+2)  
abb1 32 64 ee			ld (debug_mark+2),a  
abb4 18 03			jr .pastdmark  
abb6 ..			.dmark: db "Ltp"  
abb9 f1			.pastdmark: pop af  
abba			endm  
# End of macro DMARK
abba					CALLMONITOR 
abba cd 6f ee			call debug_vector  
abbd				endm  
# End of macro CALLMONITOR
abbd				endif 
abbd			 
abbd 18 22			jr .listpush 
abbf			 
abbf			;.lnuword:	pop hl 
abbf			;		call forth_tok_next 
abbf			;		jp .ldouscan  
abbf			 
abbf			.lunotfound:		  
abbf			 
abbf				if DEBUG_FORTH_WORDS 
abbf					DMARK "LSn" 
abbf f5				push af  
abc0 3a d4 ab			ld a, (.dmark)  
abc3 32 62 ee			ld (debug_mark),a  
abc6 3a d5 ab			ld a, (.dmark+1)  
abc9 32 63 ee			ld (debug_mark+1),a  
abcc 3a d6 ab			ld a, (.dmark+2)  
abcf 32 64 ee			ld (debug_mark+2),a  
abd2 18 03			jr .pastdmark  
abd4 ..			.dmark: db "LSn"  
abd7 f1			.pastdmark: pop af  
abd8			endm  
# End of macro DMARK
abd8					CALLMONITOR 
abd8 cd 6f ee			call debug_vector  
abdb				endm  
# End of macro CALLMONITOR
abdb				endif 
abdb			 
abdb					 
abdb			;		FORTH_DSP_POP 
abdb			;		ld hl, .luno 
abdb			 
abdb					NEXTW			 
abdb cd 6c ee			call parse_vector 
abde c3 ae 9d			jp macro_next 
abe1				endm 
# End of macro NEXTW
abe1			 
abe1			.listpush: 
abe1				if DEBUG_FORTH_WORDS 
abe1					DMARK "LS>" 
abe1 f5				push af  
abe2 3a f6 ab			ld a, (.dmark)  
abe5 32 62 ee			ld (debug_mark),a  
abe8 3a f7 ab			ld a, (.dmark+1)  
abeb 32 63 ee			ld (debug_mark+1),a  
abee 3a f8 ab			ld a, (.dmark+2)  
abf1 32 64 ee			ld (debug_mark+2),a  
abf4 18 03			jr .pastdmark  
abf6 ..			.dmark: db "LS>"  
abf9 f1			.pastdmark: pop af  
abfa			endm  
# End of macro DMARK
abfa					CALLMONITOR 
abfa cd 6f ee			call debug_vector  
abfd				endm  
# End of macro CALLMONITOR
abfd				endif 
abfd cd 35 9a				call forth_push_str 
ac00			 
ac00			 
ac00			 
ac00					NEXTW 
ac00 cd 6c ee			call parse_vector 
ac03 c3 ae 9d			jp macro_next 
ac06				endm 
# End of macro NEXTW
ac06			 
ac06			;.luno:    db "Word not found",0 
ac06			 
ac06			 
ac06			 
ac06			 
ac06			 
ac06			;		push hl   ; save pointer to start of uword def string 
ac06			; 
ac06			;; look for FORTH_EOL_LINE 
ac06			;		ld a, FORTH_END_BUFFER 
ac06			;		call strlent 
ac06			; 
ac06			;		inc hl		 ; space for coln def 
ac06			;		inc hl 
ac06			;		inc hl          ; space for terms 
ac06			;		inc hl 
ac06			; 
ac06			;		ld a, 20   ; TODO get actual length 
ac06			;		call addatohl    ; include a random amount of room for the uword name 
ac06			; 
ac06			;		 
ac06			;	if DEBUG_FORTH_WORDS 
ac06			;		DMARK "Lt1" 
ac06			;		CALLMONITOR 
ac06			;	endif 
ac06			;		 
ac06			; 
ac06			;; malloc space for the string because we cant change it 
ac06			; 
ac06			;		call malloc 
ac06			;	if DEBUG_FORTH_MALLOC_GUARD 
ac06			;		push af 
ac06			;		call ishlzero 
ac06			;		pop af 
ac06			;		 
ac06			;		call z,malloc_error 
ac06			;	endif 
ac06			; 
ac06			;	if DEBUG_FORTH_WORDS 
ac06			;		DMARK "Lt2" 
ac06			;		CALLMONITOR 
ac06			;	endif 
ac06			;		pop de 
ac06			;		push hl    ; push the malloc to release later 
ac06			;		push hl   ;  push back a copy for the later stack push 
ac06			;		 
ac06			;; copy the string swapping out the zero terms for spaces 
ac06			; 
ac06			;		; de has our source 
ac06			;		; hl has our dest 
ac06			; 
ac06			;; add the coln def 
ac06			; 
ac06			;		ld a, ':' 
ac06			;		ld (hl), a 
ac06			;		inc hl 
ac06			;		ld a, ' ' 
ac06			;		ld (hl), a 
ac06			;		inc hl 
ac06			; 
ac06			;; add the uname word 
ac06			;		push de   ; save our string for now 
ac06			;		ex de, hl 
ac06			; 
ac06			;		FORTH_DSP_VALUE 
ac06			;		;v5 FORTH_DSP_VALUE 
ac06			; 
ac06			;		inc hl   ; skip type but we know by now this is OK 
ac06			; 
ac06			;.luword:	ld a,(hl) 
ac06			;		cp 0 
ac06			;		jr z, .luword2 
ac06			;		ld (de), a 
ac06			;		inc de 
ac06			;		inc hl 
ac06			;		jr .luword 
ac06			; 
ac06			;.luword2:	ld a, ' ' 
ac06			;		ld (de), a 
ac06			;;		inc hl 
ac06			;;		inc de 
ac06			;;		ld (de), a 
ac06			;;		inc hl 
ac06			;		inc de 
ac06			; 
ac06			;		ex de, hl 
ac06			;		pop de 
ac06			;		 
ac06			;		 
ac06			; 
ac06			;; detoken that string and copy it 
ac06			; 
ac06			;	if DEBUG_FORTH_WORDS 
ac06			;		DMARK "Lt2" 
ac06			;		CALLMONITOR 
ac06			;	endif 
ac06			;.ldetok:	ld a, (de) 
ac06			;		cp FORTH_END_BUFFER 
ac06			;		jr z, .ldetokend 
ac06			;		; swap out any zero term for space 
ac06			;		cp 0 
ac06			;		jr nz, .ldetoknext 
ac06			;		ld a, ' ' 
ac06			; 
ac06			;	if DEBUG_FORTH_WORDS 
ac06			;		DMARK "LtS" 
ac06			;		CALLMONITOR 
ac06			;	endif 
ac06			;.ldetoknext:	ld (hl), a 
ac06			;		inc de 
ac06			;		inc hl 
ac06			;		jr .ldetok 
ac06			; 
ac06			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
ac06			;		ld (hl), a  
ac06			; 
ac06			;; free that temp malloc 
ac06			; 
ac06			;		pop hl    
ac06			; 
ac06			;	if DEBUG_FORTH_WORDS 
ac06			;		DMARK "Lt4" 
ac06			;		CALLMONITOR 
ac06			;	endif 
ac06			;		call forth_apushstrhl 
ac06			; 
ac06			;		; get rid of temp malloc area 
ac06			; 
ac06			;		pop hl 
ac06			;		call free 
ac06			; 
ac06			;		jr .ludone 
ac06			; 
ac06			;.lnuword:	pop hl 
ac06			;		call forth_tok_next 
ac06			;		jp .ldouscan  
ac06			; 
ac06			;.ludone:		 pop hl 
ac06			; 
ac06					NEXTW 
ac06 cd 6c ee			call parse_vector 
ac09 c3 ae 9d			jp macro_next 
ac0c				endm 
# End of macro NEXTW
ac0c			 
ac0c			.FORGET: 
ac0c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
ac0c 5d				db WORD_SYS_CORE+73             
ac0d 87 ac			dw .NOP            
ac0f 07				db 6 + 1 
ac10 .. 00			db "FORGET",0              
ac17				endm 
# End of macro CWHEAD
ac17			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
ac17			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
ac17			; | |  
ac17			; | | e.g. "MORE" forget 
ac17					if DEBUG_FORTH_WORDS_KEY 
ac17						DMARK "FRG" 
ac17 f5				push af  
ac18 3a 2c ac			ld a, (.dmark)  
ac1b 32 62 ee			ld (debug_mark),a  
ac1e 3a 2d ac			ld a, (.dmark+1)  
ac21 32 63 ee			ld (debug_mark+1),a  
ac24 3a 2e ac			ld a, (.dmark+2)  
ac27 32 64 ee			ld (debug_mark+2),a  
ac2a 18 03			jr .pastdmark  
ac2c ..			.dmark: db "FRG"  
ac2f f1			.pastdmark: pop af  
ac30			endm  
# End of macro DMARK
ac30						CALLMONITOR 
ac30 cd 6f ee			call debug_vector  
ac33				endm  
# End of macro CALLMONITOR
ac33					endif 
ac33			 
ac33				; find uword 
ac33			        ; update start of word with "_" 
ac33				; replace uword with deleted flag 
ac33			 
ac33			 
ac33			;	if DEBUG_FORTH_WORDS 
ac33			;		DMARK "FOG" 
ac33			;		CALLMONITOR 
ac33			;	endif 
ac33			 
ac33			 
ac33					; Get ptr to the word we need to look up 
ac33			 
ac33					FORTH_DSP_VALUEHL 
ac33 cd c7 9b			call macro_dsp_valuehl 
ac36				endm 
# End of macro FORTH_DSP_VALUEHL
ac36					;v5 FORTH_DSP_VALUE 
ac36				; TODO type check 
ac36			;		inc hl    ; Skip type check  
ac36 e5					push hl 
ac37 c1					pop bc 
ac38			;		ex de, hl    ; put into DE 
ac38			 
ac38			 
ac38 21 95 e3				ld hl, baseram 
ac3b					;ld hl, baseusermem 
ac3b			 
ac3b				; skip dict stub 
ac3b			;	call forth_tok_next 
ac3b e5			push hl   ; sacreifical push 
ac3c			 
ac3c			.fldouscanm: 
ac3c e1				pop hl 
ac3d			.fldouscan: 
ac3d			;	if DEBUG_FORTH_WORDS 
ac3d			;		DMARK "LSs" 
ac3d			;		CALLMONITOR 
ac3d			;	endif 
ac3d				; skip dict stub 
ac3d cd e0 9e				call forth_tok_next 
ac40			 
ac40			 
ac40			; while we have words to look for 
ac40			 
ac40 7e				ld a, (hl)      
ac41			;	if DEBUG_FORTH_WORDS 
ac41			;		DMARK "LSk" 
ac41			;		CALLMONITOR 
ac41			;	endif 
ac41 fe 00				cp WORD_SYS_END 
ac43 ca 7e ac				jp z, .flunotfound 
ac46 fe 01				cp WORD_SYS_UWORD 
ac48 c2 3d ac				jp nz, .fldouscan 
ac4b			 
ac4b			;	if DEBUG_FORTH_WORDS 
ac4b			;		DMARK "LSu" 
ac4b			;		CALLMONITOR 
ac4b			;	endif 
ac4b			 
ac4b					; found a uword but is it the one we want... 
ac4b			 
ac4b c5					push bc     ; uword to find is on bc 
ac4c d1					pop de 
ac4d			 
ac4d e5					push hl  ; to save the ptr 
ac4e			 
ac4e					; skip opcode 
ac4e 23					inc hl  
ac4f					; skip next ptr 
ac4f 23					inc hl  
ac50 23					inc hl 
ac51					; skip len 
ac51 23					inc hl 
ac52			 
ac52			;	if DEBUG_FORTH_WORDS 
ac52			;		DMARK "LSc" 
ac52			;		CALLMONITOR 
ac52			;	endif 
ac52 cd 66 90				call strcmp 
ac55 c2 3c ac				jp nz, .fldouscanm 
ac58			; 
ac58			; 
ac58			;; while we have words to look for 
ac58			; 
ac58			;.fdouscan:	ld a, (hl)      
ac58			;	if DEBUG_FORTH_WORDS 
ac58			;		DMARK "LSs" 
ac58			;		CALLMONITOR 
ac58			;	endif 
ac58			;		cp WORD_SYS_END 
ac58			;		jp z, .fudone 
ac58			;		cp WORD_SYS_UWORD 
ac58			;		jp nz, .fnuword 
ac58			; 
ac58			;	if DEBUG_FORTH_WORDS 
ac58			;		DMARK "FGu" 
ac58			;		CALLMONITOR 
ac58			;	endif 
ac58			; 
ac58			;		; found a uword but is it the one we want... 
ac58			; 
ac58			; 
ac58			;	        pop de   ; get back the dsp name 
ac58			;		push de 
ac58			; 
ac58			;		push hl  ; to save the ptr 
ac58			; 
ac58			;		; skip opcode 
ac58			;		inc hl  
ac58			;		; skip next ptr 
ac58			;		inc hl  
ac58			;		inc hl 
ac58			;		; skip len 
ac58			;		inc hl 
ac58			; 
ac58			;	if DEBUG_FORTH_WORDS 
ac58			;		DMARK "FGc" 
ac58			;		CALLMONITOR 
ac58			;	endif 
ac58			;		call strcmp 
ac58			;		jp nz, .fnuword 
ac58			 
ac58			 
ac58 e1			pop hl 
ac59			 
ac59				 
ac59				if DEBUG_FORTH_WORDS 
ac59					DMARK "FGm" 
ac59 f5				push af  
ac5a 3a 6e ac			ld a, (.dmark)  
ac5d 32 62 ee			ld (debug_mark),a  
ac60 3a 6f ac			ld a, (.dmark+1)  
ac63 32 63 ee			ld (debug_mark+1),a  
ac66 3a 70 ac			ld a, (.dmark+2)  
ac69 32 64 ee			ld (debug_mark+2),a  
ac6c 18 03			jr .pastdmark  
ac6e ..			.dmark: db "FGm"  
ac71 f1			.pastdmark: pop af  
ac72			endm  
# End of macro DMARK
ac72					CALLMONITOR 
ac72 cd 6f ee			call debug_vector  
ac75				endm  
# End of macro CALLMONITOR
ac75				endif 
ac75			 
ac75			 
ac75			 
ac75					; we have a uword so push its name to the stack 
ac75			 
ac75			;	   	push hl  ; save so we can move to next dict block 
ac75			;pop hl 
ac75			 
ac75					; update opcode to deleted 
ac75			;		ld a, WORD_SYS_DELETED 
ac75 36 03				ld (hl), WORD_SYS_DELETED 
ac77			 
ac77 23					inc hl  
ac78					; skip next ptr 
ac78 23					inc hl  
ac79 23					inc hl 
ac7a					; skip len 
ac7a 23					inc hl 
ac7b			 
ac7b					; TODO change parser to skip deleted words but for now mark it out 
ac7b 3e 5f				ld a, "_" 
ac7d 77					ld  (hl),a 
ac7e			 
ac7e			;		jr .fudone 
ac7e			; 
ac7e			;.fnuword:	pop hl 
ac7e			;		call forth_tok_next 
ac7e			;		jp .fdouscan  
ac7e			 
ac7e			.flunotfound:		  
ac7e			 
ac7e			 
ac7e					 
ac7e					FORTH_DSP_POP 
ac7e cd 7f 9c			call macro_forth_dsp_pop 
ac81				endm 
# End of macro FORTH_DSP_POP
ac81			;		ld hl, .luno 
ac81			;.fudone:		 pop hl 
ac81					NEXTW 
ac81 cd 6c ee			call parse_vector 
ac84 c3 ae 9d			jp macro_next 
ac87				endm 
# End of macro NEXTW
ac87			.NOP: 
ac87				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
ac87 61				db WORD_SYS_CORE+77             
ac88 b1 ac			dw .COMO            
ac8a 04				db 3 + 1 
ac8b .. 00			db "NOP",0              
ac8f				endm 
# End of macro CWHEAD
ac8f			; | NOP (  --  ) Do nothing | DONE 
ac8f					if DEBUG_FORTH_WORDS_KEY 
ac8f						DMARK "NOP" 
ac8f f5				push af  
ac90 3a a4 ac			ld a, (.dmark)  
ac93 32 62 ee			ld (debug_mark),a  
ac96 3a a5 ac			ld a, (.dmark+1)  
ac99 32 63 ee			ld (debug_mark+1),a  
ac9c 3a a6 ac			ld a, (.dmark+2)  
ac9f 32 64 ee			ld (debug_mark+2),a  
aca2 18 03			jr .pastdmark  
aca4 ..			.dmark: db "NOP"  
aca7 f1			.pastdmark: pop af  
aca8			endm  
# End of macro DMARK
aca8						CALLMONITOR 
aca8 cd 6f ee			call debug_vector  
acab				endm  
# End of macro CALLMONITOR
acab					endif 
acab				       NEXTW 
acab cd 6c ee			call parse_vector 
acae c3 ae 9d			jp macro_next 
acb1				endm 
# End of macro NEXTW
acb1			.COMO: 
acb1				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
acb1 6e				db WORD_SYS_CORE+90             
acb2 06 ad			dw .COMC            
acb4 02				db 1 + 1 
acb5 .. 00			db "(",0              
acb7				endm 
# End of macro CWHEAD
acb7			; | ( ( -- )  Start of comment | DONE 
acb7			 
acb7			 
acb7 2a b9 e5				ld hl, ( os_tok_ptr) 
acba 11 fe ac			ld de, .closepar 
acbd					 
acbd					if DEBUG_FORTH_WORDS 
acbd						DMARK ").." 
acbd f5				push af  
acbe 3a d2 ac			ld a, (.dmark)  
acc1 32 62 ee			ld (debug_mark),a  
acc4 3a d3 ac			ld a, (.dmark+1)  
acc7 32 63 ee			ld (debug_mark+1),a  
acca 3a d4 ac			ld a, (.dmark+2)  
accd 32 64 ee			ld (debug_mark+2),a  
acd0 18 03			jr .pastdmark  
acd2 ..			.dmark: db ").."  
acd5 f1			.pastdmark: pop af  
acd6			endm  
# End of macro DMARK
acd6						CALLMONITOR 
acd6 cd 6f ee			call debug_vector  
acd9				endm  
# End of macro CALLMONITOR
acd9					endif 
acd9 cd ab 9e			call findnexttok  
acdc			 
acdc					if DEBUG_FORTH_WORDS 
acdc						DMARK "IF5" 
acdc f5				push af  
acdd 3a f1 ac			ld a, (.dmark)  
ace0 32 62 ee			ld (debug_mark),a  
ace3 3a f2 ac			ld a, (.dmark+1)  
ace6 32 63 ee			ld (debug_mark+1),a  
ace9 3a f3 ac			ld a, (.dmark+2)  
acec 32 64 ee			ld (debug_mark+2),a  
acef 18 03			jr .pastdmark  
acf1 ..			.dmark: db "IF5"  
acf4 f1			.pastdmark: pop af  
acf5			endm  
# End of macro DMARK
acf5						CALLMONITOR 
acf5 cd 6f ee			call debug_vector  
acf8				endm  
# End of macro CALLMONITOR
acf8					endif 
acf8				; replace below with ) exec using tok_ptr 
acf8 22 b9 e5			ld (os_tok_ptr), hl 
acfb c3 2f 9e			jp exec1 
acfe			 
acfe .. 00			.closepar:   db ")",0 
ad00			 
ad00				       NEXTW 
ad00 cd 6c ee			call parse_vector 
ad03 c3 ae 9d			jp macro_next 
ad06				endm 
# End of macro NEXTW
ad06			.COMC: 
ad06				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ad06 6f				db WORD_SYS_CORE+91             
ad07 12 ad			dw .SCRATCH            
ad09 02				db 1 + 1 
ad0a .. 00			db ")",0              
ad0c				endm 
# End of macro CWHEAD
ad0c			; | ) ( -- )  End of comment |  DONE  
ad0c				       NEXTW 
ad0c cd 6c ee			call parse_vector 
ad0f c3 ae 9d			jp macro_next 
ad12				endm 
# End of macro NEXTW
ad12			 
ad12			.SCRATCH: 
ad12				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ad12 6f				db WORD_SYS_CORE+91             
ad13 50 ad			dw .INC            
ad15 08				db 7 + 1 
ad16 .. 00			db "SCRATCH",0              
ad1e				endm 
# End of macro CWHEAD
ad1e			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ad1e			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ad1e			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ad1e			; | |  
ad1e			; | | e.g.    : score $00 scratch ; 
ad1e			; | |  
ad1e			; | | $00 score ! 
ad1e			; | | $01 score +! 
ad1e			; | |  
ad1e			; | | e.g.   : varword $0a scratch ;  
ad1e			; | | 
ad1e			; | | $8000 varword ! 
ad1e					if DEBUG_FORTH_WORDS_KEY 
ad1e						DMARK "SCR" 
ad1e f5				push af  
ad1f 3a 33 ad			ld a, (.dmark)  
ad22 32 62 ee			ld (debug_mark),a  
ad25 3a 34 ad			ld a, (.dmark+1)  
ad28 32 63 ee			ld (debug_mark+1),a  
ad2b 3a 35 ad			ld a, (.dmark+2)  
ad2e 32 64 ee			ld (debug_mark+2),a  
ad31 18 03			jr .pastdmark  
ad33 ..			.dmark: db "SCR"  
ad36 f1			.pastdmark: pop af  
ad37			endm  
# End of macro DMARK
ad37						CALLMONITOR 
ad37 cd 6f ee			call debug_vector  
ad3a				endm  
# End of macro CALLMONITOR
ad3a					endif 
ad3a			 
ad3a					FORTH_DSP_VALUEHL 
ad3a cd c7 9b			call macro_dsp_valuehl 
ad3d				endm 
# End of macro FORTH_DSP_VALUEHL
ad3d				 
ad3d					FORTH_DSP_POP 
ad3d cd 7f 9c			call macro_forth_dsp_pop 
ad40				endm 
# End of macro FORTH_DSP_POP
ad40			 
ad40 7d					ld a, l 
ad41 21 dd e7				ld hl, os_var_array 
ad44 cd d6 8c				call addatohl 
ad47			 
ad47 cd cb 99				call forth_push_numhl 
ad4a			 
ad4a				       NEXTW 
ad4a cd 6c ee			call parse_vector 
ad4d c3 ae 9d			jp macro_next 
ad50				endm 
# End of macro NEXTW
ad50			 
ad50			.INC: 
ad50				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ad50 6f				db WORD_SYS_CORE+91             
ad51 a9 ad			dw .DEC            
ad53 03				db 2 + 1 
ad54 .. 00			db "+!",0              
ad57				endm 
# End of macro CWHEAD
ad57			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ad57					if DEBUG_FORTH_WORDS_KEY 
ad57						DMARK "+s_" 
ad57 f5				push af  
ad58 3a 6c ad			ld a, (.dmark)  
ad5b 32 62 ee			ld (debug_mark),a  
ad5e 3a 6d ad			ld a, (.dmark+1)  
ad61 32 63 ee			ld (debug_mark+1),a  
ad64 3a 6e ad			ld a, (.dmark+2)  
ad67 32 64 ee			ld (debug_mark+2),a  
ad6a 18 03			jr .pastdmark  
ad6c ..			.dmark: db "+s_"  
ad6f f1			.pastdmark: pop af  
ad70			endm  
# End of macro DMARK
ad70						CALLMONITOR 
ad70 cd 6f ee			call debug_vector  
ad73				endm  
# End of macro CALLMONITOR
ad73					endif 
ad73			 
ad73					FORTH_DSP_VALUEHL 
ad73 cd c7 9b			call macro_dsp_valuehl 
ad76				endm 
# End of macro FORTH_DSP_VALUEHL
ad76			 
ad76 e5					push hl   ; save address 
ad77			 
ad77					FORTH_DSP_POP 
ad77 cd 7f 9c			call macro_forth_dsp_pop 
ad7a				endm 
# End of macro FORTH_DSP_POP
ad7a			 
ad7a					FORTH_DSP_VALUEHL 
ad7a cd c7 9b			call macro_dsp_valuehl 
ad7d				endm 
# End of macro FORTH_DSP_VALUEHL
ad7d			 
ad7d e5					push hl 
ad7e					FORTH_DSP_POP 
ad7e cd 7f 9c			call macro_forth_dsp_pop 
ad81				endm 
# End of macro FORTH_DSP_POP
ad81 e1					pop hl 
ad82			 
ad82					; hl contains value to add to byte at a 
ad82				 
ad82 eb					ex de, hl 
ad83			 
ad83 e1					pop hl 
ad84			 
ad84					if DEBUG_FORTH_WORDS 
ad84						DMARK "INC" 
ad84 f5				push af  
ad85 3a 99 ad			ld a, (.dmark)  
ad88 32 62 ee			ld (debug_mark),a  
ad8b 3a 9a ad			ld a, (.dmark+1)  
ad8e 32 63 ee			ld (debug_mark+1),a  
ad91 3a 9b ad			ld a, (.dmark+2)  
ad94 32 64 ee			ld (debug_mark+2),a  
ad97 18 03			jr .pastdmark  
ad99 ..			.dmark: db "INC"  
ad9c f1			.pastdmark: pop af  
ad9d			endm  
# End of macro DMARK
ad9d						CALLMONITOR 
ad9d cd 6f ee			call debug_vector  
ada0				endm  
# End of macro CALLMONITOR
ada0					endif 
ada0			 
ada0 7e					ld a,(hl) 
ada1 83					add e 
ada2 77					ld (hl),a 
ada3			 
ada3			 
ada3			 
ada3				       NEXTW 
ada3 cd 6c ee			call parse_vector 
ada6 c3 ae 9d			jp macro_next 
ada9				endm 
# End of macro NEXTW
ada9			 
ada9			.DEC: 
ada9				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ada9 6f				db WORD_SYS_CORE+91             
adaa 00 ae			dw .INC2            
adac 03				db 2 + 1 
adad .. 00			db "-!",0              
adb0				endm 
# End of macro CWHEAD
adb0			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
adb0					if DEBUG_FORTH_WORDS_KEY 
adb0						DMARK "-s_" 
adb0 f5				push af  
adb1 3a c5 ad			ld a, (.dmark)  
adb4 32 62 ee			ld (debug_mark),a  
adb7 3a c6 ad			ld a, (.dmark+1)  
adba 32 63 ee			ld (debug_mark+1),a  
adbd 3a c7 ad			ld a, (.dmark+2)  
adc0 32 64 ee			ld (debug_mark+2),a  
adc3 18 03			jr .pastdmark  
adc5 ..			.dmark: db "-s_"  
adc8 f1			.pastdmark: pop af  
adc9			endm  
# End of macro DMARK
adc9						CALLMONITOR 
adc9 cd 6f ee			call debug_vector  
adcc				endm  
# End of macro CALLMONITOR
adcc					endif 
adcc			 
adcc					FORTH_DSP_VALUEHL 
adcc cd c7 9b			call macro_dsp_valuehl 
adcf				endm 
# End of macro FORTH_DSP_VALUEHL
adcf			 
adcf e5					push hl   ; save address 
add0			 
add0					FORTH_DSP_POP 
add0 cd 7f 9c			call macro_forth_dsp_pop 
add3				endm 
# End of macro FORTH_DSP_POP
add3			 
add3					FORTH_DSP_VALUEHL 
add3 cd c7 9b			call macro_dsp_valuehl 
add6				endm 
# End of macro FORTH_DSP_VALUEHL
add6			 
add6					; hl contains value to add to byte at a 
add6				 
add6 eb					ex de, hl 
add7			 
add7 e1					pop hl 
add8			 
add8					if DEBUG_FORTH_WORDS 
add8						DMARK "DEC" 
add8 f5				push af  
add9 3a ed ad			ld a, (.dmark)  
addc 32 62 ee			ld (debug_mark),a  
addf 3a ee ad			ld a, (.dmark+1)  
ade2 32 63 ee			ld (debug_mark+1),a  
ade5 3a ef ad			ld a, (.dmark+2)  
ade8 32 64 ee			ld (debug_mark+2),a  
adeb 18 03			jr .pastdmark  
aded ..			.dmark: db "DEC"  
adf0 f1			.pastdmark: pop af  
adf1			endm  
# End of macro DMARK
adf1						CALLMONITOR 
adf1 cd 6f ee			call debug_vector  
adf4				endm  
# End of macro CALLMONITOR
adf4					endif 
adf4			 
adf4 7e					ld a,(hl) 
adf5 93					sub e 
adf6 77					ld (hl),a 
adf7			 
adf7			 
adf7					FORTH_DSP_POP 
adf7 cd 7f 9c			call macro_forth_dsp_pop 
adfa				endm 
# End of macro FORTH_DSP_POP
adfa			 
adfa				       NEXTW 
adfa cd 6c ee			call parse_vector 
adfd c3 ae 9d			jp macro_next 
ae00				endm 
# End of macro NEXTW
ae00			 
ae00			.INC2: 
ae00				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ae00 6f				db WORD_SYS_CORE+91             
ae01 b0 ae			dw .DEC2            
ae03 04				db 3 + 1 
ae04 .. 00			db "+2!",0              
ae08				endm 
# End of macro CWHEAD
ae08			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ae08			 
ae08					if DEBUG_FORTH_WORDS_KEY 
ae08						DMARK "+2s" 
ae08 f5				push af  
ae09 3a 1d ae			ld a, (.dmark)  
ae0c 32 62 ee			ld (debug_mark),a  
ae0f 3a 1e ae			ld a, (.dmark+1)  
ae12 32 63 ee			ld (debug_mark+1),a  
ae15 3a 1f ae			ld a, (.dmark+2)  
ae18 32 64 ee			ld (debug_mark+2),a  
ae1b 18 03			jr .pastdmark  
ae1d ..			.dmark: db "+2s"  
ae20 f1			.pastdmark: pop af  
ae21			endm  
# End of macro DMARK
ae21						CALLMONITOR 
ae21 cd 6f ee			call debug_vector  
ae24				endm  
# End of macro CALLMONITOR
ae24					endif 
ae24			 
ae24					; Address 
ae24			 
ae24					FORTH_DSP_VALUEHL 
ae24 cd c7 9b			call macro_dsp_valuehl 
ae27				endm 
# End of macro FORTH_DSP_VALUEHL
ae27			 
ae27 e5					push hl    ; save address 
ae28			 
ae28					; load content into de 
ae28			 
ae28 5e					ld e,(hl) 
ae29 23					inc hl 
ae2a 56					ld d, (hl) 
ae2b			 
ae2b					if DEBUG_FORTH_WORDS 
ae2b						DMARK "+2a" 
ae2b f5				push af  
ae2c 3a 40 ae			ld a, (.dmark)  
ae2f 32 62 ee			ld (debug_mark),a  
ae32 3a 41 ae			ld a, (.dmark+1)  
ae35 32 63 ee			ld (debug_mark+1),a  
ae38 3a 42 ae			ld a, (.dmark+2)  
ae3b 32 64 ee			ld (debug_mark+2),a  
ae3e 18 03			jr .pastdmark  
ae40 ..			.dmark: db "+2a"  
ae43 f1			.pastdmark: pop af  
ae44			endm  
# End of macro DMARK
ae44						CALLMONITOR 
ae44 cd 6f ee			call debug_vector  
ae47				endm  
# End of macro CALLMONITOR
ae47					endif 
ae47			 
ae47					FORTH_DSP_POP 
ae47 cd 7f 9c			call macro_forth_dsp_pop 
ae4a				endm 
# End of macro FORTH_DSP_POP
ae4a			 
ae4a					; Get value to add 
ae4a			 
ae4a					FORTH_DSP_VALUE 
ae4a cd b0 9b			call macro_forth_dsp_value 
ae4d				endm 
# End of macro FORTH_DSP_VALUE
ae4d			 
ae4d					if DEBUG_FORTH_WORDS 
ae4d						DMARK "+2v" 
ae4d f5				push af  
ae4e 3a 62 ae			ld a, (.dmark)  
ae51 32 62 ee			ld (debug_mark),a  
ae54 3a 63 ae			ld a, (.dmark+1)  
ae57 32 63 ee			ld (debug_mark+1),a  
ae5a 3a 64 ae			ld a, (.dmark+2)  
ae5d 32 64 ee			ld (debug_mark+2),a  
ae60 18 03			jr .pastdmark  
ae62 ..			.dmark: db "+2v"  
ae65 f1			.pastdmark: pop af  
ae66			endm  
# End of macro DMARK
ae66						CALLMONITOR 
ae66 cd 6f ee			call debug_vector  
ae69				endm  
# End of macro CALLMONITOR
ae69					endif 
ae69			 
ae69 19					add hl, de 
ae6a			 
ae6a					if DEBUG_FORTH_WORDS 
ae6a						DMARK "+2+" 
ae6a f5				push af  
ae6b 3a 7f ae			ld a, (.dmark)  
ae6e 32 62 ee			ld (debug_mark),a  
ae71 3a 80 ae			ld a, (.dmark+1)  
ae74 32 63 ee			ld (debug_mark+1),a  
ae77 3a 81 ae			ld a, (.dmark+2)  
ae7a 32 64 ee			ld (debug_mark+2),a  
ae7d 18 03			jr .pastdmark  
ae7f ..			.dmark: db "+2+"  
ae82 f1			.pastdmark: pop af  
ae83			endm  
# End of macro DMARK
ae83						CALLMONITOR 
ae83 cd 6f ee			call debug_vector  
ae86				endm  
# End of macro CALLMONITOR
ae86					endif 
ae86			 
ae86					; move result to de 
ae86			 
ae86 eb					ex de, hl 
ae87			 
ae87					; Address 
ae87			 
ae87 e1					pop hl 
ae88			 
ae88					; save it back 
ae88			 
ae88 73					ld (hl), e 
ae89 23					inc hl 
ae8a 72					ld (hl), d 
ae8b			 
ae8b					if DEBUG_FORTH_WORDS 
ae8b						DMARK "+2e" 
ae8b f5				push af  
ae8c 3a a0 ae			ld a, (.dmark)  
ae8f 32 62 ee			ld (debug_mark),a  
ae92 3a a1 ae			ld a, (.dmark+1)  
ae95 32 63 ee			ld (debug_mark+1),a  
ae98 3a a2 ae			ld a, (.dmark+2)  
ae9b 32 64 ee			ld (debug_mark+2),a  
ae9e 18 03			jr .pastdmark  
aea0 ..			.dmark: db "+2e"  
aea3 f1			.pastdmark: pop af  
aea4			endm  
# End of macro DMARK
aea4						CALLMONITOR 
aea4 cd 6f ee			call debug_vector  
aea7				endm  
# End of macro CALLMONITOR
aea7					endif 
aea7			 
aea7			 
aea7			 
aea7					FORTH_DSP_POP 
aea7 cd 7f 9c			call macro_forth_dsp_pop 
aeaa				endm 
# End of macro FORTH_DSP_POP
aeaa			 
aeaa			 
aeaa				       NEXTW 
aeaa cd 6c ee			call parse_vector 
aead c3 ae 9d			jp macro_next 
aeb0				endm 
# End of macro NEXTW
aeb0			 
aeb0			.DEC2: 
aeb0				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aeb0 6f				db WORD_SYS_CORE+91             
aeb1 62 af			dw .GET2            
aeb3 04				db 3 + 1 
aeb4 .. 00			db "-2!",0              
aeb8				endm 
# End of macro CWHEAD
aeb8			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
aeb8			 
aeb8			 
aeb8					if DEBUG_FORTH_WORDS_KEY 
aeb8						DMARK "-2s" 
aeb8 f5				push af  
aeb9 3a cd ae			ld a, (.dmark)  
aebc 32 62 ee			ld (debug_mark),a  
aebf 3a ce ae			ld a, (.dmark+1)  
aec2 32 63 ee			ld (debug_mark+1),a  
aec5 3a cf ae			ld a, (.dmark+2)  
aec8 32 64 ee			ld (debug_mark+2),a  
aecb 18 03			jr .pastdmark  
aecd ..			.dmark: db "-2s"  
aed0 f1			.pastdmark: pop af  
aed1			endm  
# End of macro DMARK
aed1						CALLMONITOR 
aed1 cd 6f ee			call debug_vector  
aed4				endm  
# End of macro CALLMONITOR
aed4					endif 
aed4			 
aed4					; Address 
aed4			 
aed4					FORTH_DSP_VALUEHL 
aed4 cd c7 9b			call macro_dsp_valuehl 
aed7				endm 
# End of macro FORTH_DSP_VALUEHL
aed7			 
aed7 e5					push hl    ; save address 
aed8			 
aed8					; load content into de 
aed8			 
aed8 5e					ld e,(hl) 
aed9 23					inc hl 
aeda 56					ld d, (hl) 
aedb			 
aedb					if DEBUG_FORTH_WORDS 
aedb						DMARK "-2a" 
aedb f5				push af  
aedc 3a f0 ae			ld a, (.dmark)  
aedf 32 62 ee			ld (debug_mark),a  
aee2 3a f1 ae			ld a, (.dmark+1)  
aee5 32 63 ee			ld (debug_mark+1),a  
aee8 3a f2 ae			ld a, (.dmark+2)  
aeeb 32 64 ee			ld (debug_mark+2),a  
aeee 18 03			jr .pastdmark  
aef0 ..			.dmark: db "-2a"  
aef3 f1			.pastdmark: pop af  
aef4			endm  
# End of macro DMARK
aef4						CALLMONITOR 
aef4 cd 6f ee			call debug_vector  
aef7				endm  
# End of macro CALLMONITOR
aef7					endif 
aef7			 
aef7					FORTH_DSP_POP 
aef7 cd 7f 9c			call macro_forth_dsp_pop 
aefa				endm 
# End of macro FORTH_DSP_POP
aefa			 
aefa					; Get value to remove 
aefa			 
aefa					FORTH_DSP_VALUE 
aefa cd b0 9b			call macro_forth_dsp_value 
aefd				endm 
# End of macro FORTH_DSP_VALUE
aefd			 
aefd					if DEBUG_FORTH_WORDS 
aefd						DMARK "-2v" 
aefd f5				push af  
aefe 3a 12 af			ld a, (.dmark)  
af01 32 62 ee			ld (debug_mark),a  
af04 3a 13 af			ld a, (.dmark+1)  
af07 32 63 ee			ld (debug_mark+1),a  
af0a 3a 14 af			ld a, (.dmark+2)  
af0d 32 64 ee			ld (debug_mark+2),a  
af10 18 03			jr .pastdmark  
af12 ..			.dmark: db "-2v"  
af15 f1			.pastdmark: pop af  
af16			endm  
# End of macro DMARK
af16						CALLMONITOR 
af16 cd 6f ee			call debug_vector  
af19				endm  
# End of macro CALLMONITOR
af19					endif 
af19			 
af19 eb					ex de, hl 
af1a ed 52				sbc hl, de 
af1c			 
af1c					if DEBUG_FORTH_WORDS 
af1c						DMARK "-2d" 
af1c f5				push af  
af1d 3a 31 af			ld a, (.dmark)  
af20 32 62 ee			ld (debug_mark),a  
af23 3a 32 af			ld a, (.dmark+1)  
af26 32 63 ee			ld (debug_mark+1),a  
af29 3a 33 af			ld a, (.dmark+2)  
af2c 32 64 ee			ld (debug_mark+2),a  
af2f 18 03			jr .pastdmark  
af31 ..			.dmark: db "-2d"  
af34 f1			.pastdmark: pop af  
af35			endm  
# End of macro DMARK
af35						CALLMONITOR 
af35 cd 6f ee			call debug_vector  
af38				endm  
# End of macro CALLMONITOR
af38					endif 
af38			 
af38					; move result to de 
af38			 
af38 eb					ex de, hl 
af39			 
af39					; Address 
af39			 
af39 e1					pop hl 
af3a			 
af3a					; save it back 
af3a			 
af3a 73					ld (hl), e 
af3b 23					inc hl 
af3c 72					ld (hl), d 
af3d			 
af3d					if DEBUG_FORTH_WORDS 
af3d						DMARK "-2e" 
af3d f5				push af  
af3e 3a 52 af			ld a, (.dmark)  
af41 32 62 ee			ld (debug_mark),a  
af44 3a 53 af			ld a, (.dmark+1)  
af47 32 63 ee			ld (debug_mark+1),a  
af4a 3a 54 af			ld a, (.dmark+2)  
af4d 32 64 ee			ld (debug_mark+2),a  
af50 18 03			jr .pastdmark  
af52 ..			.dmark: db "-2e"  
af55 f1			.pastdmark: pop af  
af56			endm  
# End of macro DMARK
af56						CALLMONITOR 
af56 cd 6f ee			call debug_vector  
af59				endm  
# End of macro CALLMONITOR
af59					endif 
af59			 
af59			 
af59					FORTH_DSP_POP 
af59 cd 7f 9c			call macro_forth_dsp_pop 
af5c				endm 
# End of macro FORTH_DSP_POP
af5c			 
af5c			 
af5c			 
af5c				       NEXTW 
af5c cd 6c ee			call parse_vector 
af5f c3 ae 9d			jp macro_next 
af62				endm 
# End of macro NEXTW
af62			.GET2: 
af62				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
af62 6f				db WORD_SYS_CORE+91             
af63 9a af			dw .BANG2            
af65 03				db 2 + 1 
af66 .. 00			db "2@",0              
af69				endm 
# End of macro CWHEAD
af69			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
af69					if DEBUG_FORTH_WORDS_KEY 
af69						DMARK "2A_" 
af69 f5				push af  
af6a 3a 7e af			ld a, (.dmark)  
af6d 32 62 ee			ld (debug_mark),a  
af70 3a 7f af			ld a, (.dmark+1)  
af73 32 63 ee			ld (debug_mark+1),a  
af76 3a 80 af			ld a, (.dmark+2)  
af79 32 64 ee			ld (debug_mark+2),a  
af7c 18 03			jr .pastdmark  
af7e ..			.dmark: db "2A_"  
af81 f1			.pastdmark: pop af  
af82			endm  
# End of macro DMARK
af82						CALLMONITOR 
af82 cd 6f ee			call debug_vector  
af85				endm  
# End of macro CALLMONITOR
af85					endif 
af85			 
af85					FORTH_DSP_VALUEHL 
af85 cd c7 9b			call macro_dsp_valuehl 
af88				endm 
# End of macro FORTH_DSP_VALUEHL
af88			 
af88 e5					push hl   ; save address 
af89			 
af89					FORTH_DSP_POP 
af89 cd 7f 9c			call macro_forth_dsp_pop 
af8c				endm 
# End of macro FORTH_DSP_POP
af8c			 
af8c e1					pop hl 
af8d			 
af8d 5e					ld e, (hl) 
af8e 23					inc hl 
af8f 56					ld d, (hl) 
af90			 
af90 eb					ex de, hl 
af91			 
af91 cd cb 99				call forth_push_numhl 
af94			 
af94				       NEXTW 
af94 cd 6c ee			call parse_vector 
af97 c3 ae 9d			jp macro_next 
af9a				endm 
# End of macro NEXTW
af9a			.BANG2: 
af9a				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
af9a 6f				db WORD_SYS_CORE+91             
af9b d5 af			dw .CONFIG            
af9d 03				db 2 + 1 
af9e .. 00			db "2!",0              
afa1				endm 
# End of macro CWHEAD
afa1			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
afa1					if DEBUG_FORTH_WORDS_KEY 
afa1						DMARK "2S_" 
afa1 f5				push af  
afa2 3a b6 af			ld a, (.dmark)  
afa5 32 62 ee			ld (debug_mark),a  
afa8 3a b7 af			ld a, (.dmark+1)  
afab 32 63 ee			ld (debug_mark+1),a  
afae 3a b8 af			ld a, (.dmark+2)  
afb1 32 64 ee			ld (debug_mark+2),a  
afb4 18 03			jr .pastdmark  
afb6 ..			.dmark: db "2S_"  
afb9 f1			.pastdmark: pop af  
afba			endm  
# End of macro DMARK
afba						CALLMONITOR 
afba cd 6f ee			call debug_vector  
afbd				endm  
# End of macro CALLMONITOR
afbd					endif 
afbd			 
afbd					FORTH_DSP_VALUEHL 
afbd cd c7 9b			call macro_dsp_valuehl 
afc0				endm 
# End of macro FORTH_DSP_VALUEHL
afc0			 
afc0 e5					push hl   ; save address 
afc1			 
afc1			 
afc1					FORTH_DSP_POP 
afc1 cd 7f 9c			call macro_forth_dsp_pop 
afc4				endm 
# End of macro FORTH_DSP_POP
afc4			 
afc4					 
afc4					FORTH_DSP_VALUEHL 
afc4 cd c7 9b			call macro_dsp_valuehl 
afc7				endm 
# End of macro FORTH_DSP_VALUEHL
afc7			 
afc7					FORTH_DSP_POP 
afc7 cd 7f 9c			call macro_forth_dsp_pop 
afca				endm 
# End of macro FORTH_DSP_POP
afca			 
afca eb					ex de, hl    ; value now in de 
afcb			 
afcb e1					pop hl 
afcc			 
afcc 73					ld (hl), e 
afcd			 
afcd 23					inc hl 
afce			 
afce 72					ld (hl), d 
afcf			 
afcf			 
afcf				       NEXTW 
afcf cd 6c ee			call parse_vector 
afd2 c3 ae 9d			jp macro_next 
afd5				endm 
# End of macro NEXTW
afd5			.CONFIG: 
afd5				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
afd5 6f				db WORD_SYS_CORE+91             
afd6 e9 af			dw .ADTOS            
afd8 07				db 6 + 1 
afd9 .. 00			db "CONFIG",0              
afe0				endm 
# End of macro CWHEAD
afe0			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
afe0			 
afe0 cd 3b 92				call config 
afe3					NEXTW 
afe3 cd 6c ee			call parse_vector 
afe6 c3 ae 9d			jp macro_next 
afe9				endm 
# End of macro NEXTW
afe9			 
afe9			.ADTOS: 
afe9				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
afe9 6f				db WORD_SYS_CORE+91             
afea 02 b0			dw .SBTOS            
afec 03				db 2 + 1 
afed .. 00			db "1+",0              
aff0				endm 
# End of macro CWHEAD
aff0			; | 1+ ( u -- u )  Increment value on TOS | DONE 
aff0			 
aff0					FORTH_DSP_VALUEHL 
aff0 cd c7 9b			call macro_dsp_valuehl 
aff3				endm 
# End of macro FORTH_DSP_VALUEHL
aff3 e5					push hl 
aff4			 
aff4					FORTH_DSP_POP 
aff4 cd 7f 9c			call macro_forth_dsp_pop 
aff7				endm 
# End of macro FORTH_DSP_POP
aff7 e1					pop hl 
aff8			 
aff8 23					inc hl 
aff9 cd cb 99				call forth_push_numhl 
affc					 
affc					NEXTW 
affc cd 6c ee			call parse_vector 
afff c3 ae 9d			jp macro_next 
b002				endm 
# End of macro NEXTW
b002			.SBTOS: 
b002				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
b002 6f				db WORD_SYS_CORE+91             
b003 1b b0			dw .ADSTORE            
b005 03				db 2 + 1 
b006 .. 00			db "1-",0              
b009				endm 
# End of macro CWHEAD
b009			; | 1- ( u -- u )  Decrement value on TOS | DONE 
b009			 
b009					FORTH_DSP_VALUEHL 
b009 cd c7 9b			call macro_dsp_valuehl 
b00c				endm 
# End of macro FORTH_DSP_VALUEHL
b00c e5					push hl 
b00d			 
b00d					FORTH_DSP_POP 
b00d cd 7f 9c			call macro_forth_dsp_pop 
b010				endm 
# End of macro FORTH_DSP_POP
b010 e1					pop hl 
b011			 
b011 2b					dec hl 
b012 cd cb 99				call forth_push_numhl 
b015					 
b015					NEXTW 
b015 cd 6c ee			call parse_vector 
b018 c3 ae 9d			jp macro_next 
b01b				endm 
# End of macro NEXTW
b01b			.ADSTORE: 
b01b				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
b01b 6f				db WORD_SYS_CORE+91             
b01c 34 b0			dw .ADWSTORE            
b01e 04				db 3 + 1 
b01f .. 00			db "1+!",0              
b023				endm 
# End of macro CWHEAD
b023			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
b023			 
b023					FORTH_DSP_VALUEHL 
b023 cd c7 9b			call macro_dsp_valuehl 
b026				endm 
# End of macro FORTH_DSP_VALUEHL
b026 e5					push hl 
b027			 
b027					FORTH_DSP_POP 
b027 cd 7f 9c			call macro_forth_dsp_pop 
b02a				endm 
# End of macro FORTH_DSP_POP
b02a e1					pop hl 
b02b			 
b02b 7e					ld a, (hl) 
b02c 3c					inc a 
b02d 77					ld (hl), a 
b02e					 
b02e					NEXTW 
b02e cd 6c ee			call parse_vector 
b031 c3 ae 9d			jp macro_next 
b034				endm 
# End of macro NEXTW
b034			.ADWSTORE: 
b034				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
b034 6f				db WORD_SYS_CORE+91             
b035 55 b0			dw .SBSTORE            
b037 05				db 4 + 1 
b038 .. 00			db "1+2!",0              
b03d				endm 
# End of macro CWHEAD
b03d			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
b03d			 
b03d					FORTH_DSP_VALUEHL 
b03d cd c7 9b			call macro_dsp_valuehl 
b040				endm 
# End of macro FORTH_DSP_VALUEHL
b040 e5					push hl 
b041			 
b041					FORTH_DSP_POP 
b041 cd 7f 9c			call macro_forth_dsp_pop 
b044				endm 
# End of macro FORTH_DSP_POP
b044 e1					pop hl 
b045			 
b045 e5					push hl 
b046			 
b046 cd 34 9d				call loadwordinhl 
b049 23					inc hl 
b04a			 
b04a d1					pop de 
b04b eb					ex de, hl 
b04c 73					ld (hl), e 
b04d 23					inc hl 
b04e 72					ld (hl), d 
b04f					 
b04f					NEXTW 
b04f cd 6c ee			call parse_vector 
b052 c3 ae 9d			jp macro_next 
b055				endm 
# End of macro NEXTW
b055			.SBSTORE: 
b055				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
b055 6f				db WORD_SYS_CORE+91             
b056 6e b0			dw .SBWSTORE            
b058 04				db 3 + 1 
b059 .. 00			db "1-!",0              
b05d				endm 
# End of macro CWHEAD
b05d			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
b05d			 
b05d					FORTH_DSP_VALUEHL 
b05d cd c7 9b			call macro_dsp_valuehl 
b060				endm 
# End of macro FORTH_DSP_VALUEHL
b060 e5					push hl 
b061			 
b061					FORTH_DSP_POP 
b061 cd 7f 9c			call macro_forth_dsp_pop 
b064				endm 
# End of macro FORTH_DSP_POP
b064 e1					pop hl 
b065			 
b065 7e					ld a, (hl) 
b066 3d					dec a 
b067 77					ld (hl), a 
b068					 
b068					NEXTW 
b068 cd 6c ee			call parse_vector 
b06b c3 ae 9d			jp macro_next 
b06e				endm 
# End of macro NEXTW
b06e			.SBWSTORE: 
b06e				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
b06e 6f				db WORD_SYS_CORE+91             
b06f 8f b0			dw .ENDCORE            
b071 05				db 4 + 1 
b072 .. 00			db "1-2!",0              
b077				endm 
# End of macro CWHEAD
b077			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
b077			 
b077					FORTH_DSP_VALUEHL 
b077 cd c7 9b			call macro_dsp_valuehl 
b07a				endm 
# End of macro FORTH_DSP_VALUEHL
b07a e5					push hl 
b07b			 
b07b					FORTH_DSP_POP 
b07b cd 7f 9c			call macro_forth_dsp_pop 
b07e				endm 
# End of macro FORTH_DSP_POP
b07e e1					pop hl 
b07f			 
b07f e5					push hl 
b080			 
b080 cd 34 9d				call loadwordinhl 
b083 2b					dec hl 
b084			 
b084 d1					pop de 
b085 eb					ex de, hl 
b086 73					ld (hl), e 
b087 23					inc hl 
b088 72					ld (hl), d 
b089					 
b089					NEXTW 
b089 cd 6c ee			call parse_vector 
b08c c3 ae 9d			jp macro_next 
b08f				endm 
# End of macro NEXTW
b08f			.ENDCORE: 
b08f			 
b08f			; eof 
b08f			 
b08f			 
# End of file forth_words_core.asm
b08f			include "forth_words_flow.asm" 
b08f			 
b08f			; | ## Program Flow Words 
b08f			 
b08f			.IF: 
b08f				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
b08f 1e				db WORD_SYS_CORE+10             
b090 8a b1			dw .THEN            
b092 03				db 2 + 1 
b093 .. 00			db "IF",0              
b096				endm 
# End of macro CWHEAD
b096			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
b096			; | | Note: currently not supporting ELSE or nested IF 
b096			; 
b096					if DEBUG_FORTH_WORDS_KEY 
b096						DMARK "IF." 
b096 f5				push af  
b097 3a ab b0			ld a, (.dmark)  
b09a 32 62 ee			ld (debug_mark),a  
b09d 3a ac b0			ld a, (.dmark+1)  
b0a0 32 63 ee			ld (debug_mark+1),a  
b0a3 3a ad b0			ld a, (.dmark+2)  
b0a6 32 64 ee			ld (debug_mark+2),a  
b0a9 18 03			jr .pastdmark  
b0ab ..			.dmark: db "IF."  
b0ae f1			.pastdmark: pop af  
b0af			endm  
# End of macro DMARK
b0af						CALLMONITOR 
b0af cd 6f ee			call debug_vector  
b0b2				endm  
# End of macro CALLMONITOR
b0b2					endif 
b0b2			; eval TOS 
b0b2			 
b0b2				FORTH_DSP_VALUEHL 
b0b2 cd c7 9b			call macro_dsp_valuehl 
b0b5				endm 
# End of macro FORTH_DSP_VALUEHL
b0b5			 
b0b5			;	push hl 
b0b5				FORTH_DSP_POP 
b0b5 cd 7f 9c			call macro_forth_dsp_pop 
b0b8				endm 
# End of macro FORTH_DSP_POP
b0b8			;	pop hl 
b0b8			 
b0b8					if DEBUG_FORTH_WORDS 
b0b8						DMARK "IF1" 
b0b8 f5				push af  
b0b9 3a cd b0			ld a, (.dmark)  
b0bc 32 62 ee			ld (debug_mark),a  
b0bf 3a ce b0			ld a, (.dmark+1)  
b0c2 32 63 ee			ld (debug_mark+1),a  
b0c5 3a cf b0			ld a, (.dmark+2)  
b0c8 32 64 ee			ld (debug_mark+2),a  
b0cb 18 03			jr .pastdmark  
b0cd ..			.dmark: db "IF1"  
b0d0 f1			.pastdmark: pop af  
b0d1			endm  
# End of macro DMARK
b0d1						CALLMONITOR 
b0d1 cd 6f ee			call debug_vector  
b0d4				endm  
# End of macro CALLMONITOR
b0d4					endif 
b0d4 b7				or a        ; clear carry flag 
b0d5 11 00 00			ld de, 0 
b0d8 eb				ex de,hl 
b0d9 ed 52			sbc hl, de 
b0db c2 68 b1			jp nz, .iftrue 
b0de			 
b0de					if DEBUG_FORTH_WORDS 
b0de						DMARK "IF2" 
b0de f5				push af  
b0df 3a f3 b0			ld a, (.dmark)  
b0e2 32 62 ee			ld (debug_mark),a  
b0e5 3a f4 b0			ld a, (.dmark+1)  
b0e8 32 63 ee			ld (debug_mark+1),a  
b0eb 3a f5 b0			ld a, (.dmark+2)  
b0ee 32 64 ee			ld (debug_mark+2),a  
b0f1 18 03			jr .pastdmark  
b0f3 ..			.dmark: db "IF2"  
b0f6 f1			.pastdmark: pop af  
b0f7			endm  
# End of macro DMARK
b0f7						CALLMONITOR 
b0f7 cd 6f ee			call debug_vector  
b0fa				endm  
# End of macro CALLMONITOR
b0fa					endif 
b0fa			 
b0fa			; if not true then skip to THEN 
b0fa			 
b0fa				; TODO get tok_ptr 
b0fa				; TODO consume toks until we get to THEN 
b0fa			 
b0fa 2a b9 e5			ld hl, (os_tok_ptr) 
b0fd					if DEBUG_FORTH_WORDS 
b0fd						DMARK "IF3" 
b0fd f5				push af  
b0fe 3a 12 b1			ld a, (.dmark)  
b101 32 62 ee			ld (debug_mark),a  
b104 3a 13 b1			ld a, (.dmark+1)  
b107 32 63 ee			ld (debug_mark+1),a  
b10a 3a 14 b1			ld a, (.dmark+2)  
b10d 32 64 ee			ld (debug_mark+2),a  
b110 18 03			jr .pastdmark  
b112 ..			.dmark: db "IF3"  
b115 f1			.pastdmark: pop af  
b116			endm  
# End of macro DMARK
b116						CALLMONITOR 
b116 cd 6f ee			call debug_vector  
b119				endm  
# End of macro CALLMONITOR
b119						 
b119					endif 
b119 11 63 b1			ld de, .ifthen 
b11c					if DEBUG_FORTH_WORDS 
b11c						DMARK "IF4" 
b11c f5				push af  
b11d 3a 31 b1			ld a, (.dmark)  
b120 32 62 ee			ld (debug_mark),a  
b123 3a 32 b1			ld a, (.dmark+1)  
b126 32 63 ee			ld (debug_mark+1),a  
b129 3a 33 b1			ld a, (.dmark+2)  
b12c 32 64 ee			ld (debug_mark+2),a  
b12f 18 03			jr .pastdmark  
b131 ..			.dmark: db "IF4"  
b134 f1			.pastdmark: pop af  
b135			endm  
# End of macro DMARK
b135						CALLMONITOR 
b135 cd 6f ee			call debug_vector  
b138				endm  
# End of macro CALLMONITOR
b138					endif 
b138 cd ab 9e			call findnexttok  
b13b			 
b13b					if DEBUG_FORTH_WORDS 
b13b						DMARK "IF5" 
b13b f5				push af  
b13c 3a 50 b1			ld a, (.dmark)  
b13f 32 62 ee			ld (debug_mark),a  
b142 3a 51 b1			ld a, (.dmark+1)  
b145 32 63 ee			ld (debug_mark+1),a  
b148 3a 52 b1			ld a, (.dmark+2)  
b14b 32 64 ee			ld (debug_mark+2),a  
b14e 18 03			jr .pastdmark  
b150 ..			.dmark: db "IF5"  
b153 f1			.pastdmark: pop af  
b154			endm  
# End of macro DMARK
b154						CALLMONITOR 
b154 cd 6f ee			call debug_vector  
b157				endm  
# End of macro CALLMONITOR
b157					endif 
b157				; TODO replace below with ; exec using tok_ptr 
b157 22 b9 e5			ld (os_tok_ptr), hl 
b15a c3 2f 9e			jp exec1 
b15d				NEXTW 
b15d cd 6c ee			call parse_vector 
b160 c3 ae 9d			jp macro_next 
b163				endm 
# End of macro NEXTW
b163			 
b163 .. 00		.ifthen:  db "THEN",0 
b168			 
b168			.iftrue:		 
b168				; Exec next words normally 
b168			 
b168				; if true then exec following IF as normal 
b168					if DEBUG_FORTH_WORDS 
b168						DMARK "IFT" 
b168 f5				push af  
b169 3a 7d b1			ld a, (.dmark)  
b16c 32 62 ee			ld (debug_mark),a  
b16f 3a 7e b1			ld a, (.dmark+1)  
b172 32 63 ee			ld (debug_mark+1),a  
b175 3a 7f b1			ld a, (.dmark+2)  
b178 32 64 ee			ld (debug_mark+2),a  
b17b 18 03			jr .pastdmark  
b17d ..			.dmark: db "IFT"  
b180 f1			.pastdmark: pop af  
b181			endm  
# End of macro DMARK
b181						CALLMONITOR 
b181 cd 6f ee			call debug_vector  
b184				endm  
# End of macro CALLMONITOR
b184					endif 
b184			 
b184					NEXTW 
b184 cd 6c ee			call parse_vector 
b187 c3 ae 9d			jp macro_next 
b18a				endm 
# End of macro NEXTW
b18a			.THEN: 
b18a				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
b18a 1f				db WORD_SYS_CORE+11             
b18b b5 b1			dw .ELSE            
b18d 05				db 4 + 1 
b18e .. 00			db "THEN",0              
b193				endm 
# End of macro CWHEAD
b193			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
b193					if DEBUG_FORTH_WORDS_KEY 
b193						DMARK "THN" 
b193 f5				push af  
b194 3a a8 b1			ld a, (.dmark)  
b197 32 62 ee			ld (debug_mark),a  
b19a 3a a9 b1			ld a, (.dmark+1)  
b19d 32 63 ee			ld (debug_mark+1),a  
b1a0 3a aa b1			ld a, (.dmark+2)  
b1a3 32 64 ee			ld (debug_mark+2),a  
b1a6 18 03			jr .pastdmark  
b1a8 ..			.dmark: db "THN"  
b1ab f1			.pastdmark: pop af  
b1ac			endm  
# End of macro DMARK
b1ac						CALLMONITOR 
b1ac cd 6f ee			call debug_vector  
b1af				endm  
# End of macro CALLMONITOR
b1af					endif 
b1af					NEXTW 
b1af cd 6c ee			call parse_vector 
b1b2 c3 ae 9d			jp macro_next 
b1b5				endm 
# End of macro NEXTW
b1b5			.ELSE: 
b1b5				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
b1b5 20				db WORD_SYS_CORE+12             
b1b6 e0 b1			dw .DO            
b1b8 03				db 2 + 1 
b1b9 .. 00			db "ELSE",0              
b1be				endm 
# End of macro CWHEAD
b1be			; | ELSE ( -- ) Not supported - does nothing | TODO 
b1be			 
b1be					if DEBUG_FORTH_WORDS_KEY 
b1be						DMARK "ELS" 
b1be f5				push af  
b1bf 3a d3 b1			ld a, (.dmark)  
b1c2 32 62 ee			ld (debug_mark),a  
b1c5 3a d4 b1			ld a, (.dmark+1)  
b1c8 32 63 ee			ld (debug_mark+1),a  
b1cb 3a d5 b1			ld a, (.dmark+2)  
b1ce 32 64 ee			ld (debug_mark+2),a  
b1d1 18 03			jr .pastdmark  
b1d3 ..			.dmark: db "ELS"  
b1d6 f1			.pastdmark: pop af  
b1d7			endm  
# End of macro DMARK
b1d7						CALLMONITOR 
b1d7 cd 6f ee			call debug_vector  
b1da				endm  
# End of macro CALLMONITOR
b1da					endif 
b1da			 
b1da			 
b1da					NEXTW 
b1da cd 6c ee			call parse_vector 
b1dd c3 ae 9d			jp macro_next 
b1e0				endm 
# End of macro NEXTW
b1e0			.DO: 
b1e0				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
b1e0 21				db WORD_SYS_CORE+13             
b1e1 0a b3			dw .LOOP            
b1e3 03				db 2 + 1 
b1e4 .. 00			db "DO",0              
b1e7				endm 
# End of macro CWHEAD
b1e7			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
b1e7			 
b1e7					if DEBUG_FORTH_WORDS_KEY 
b1e7						DMARK "DO." 
b1e7 f5				push af  
b1e8 3a fc b1			ld a, (.dmark)  
b1eb 32 62 ee			ld (debug_mark),a  
b1ee 3a fd b1			ld a, (.dmark+1)  
b1f1 32 63 ee			ld (debug_mark+1),a  
b1f4 3a fe b1			ld a, (.dmark+2)  
b1f7 32 64 ee			ld (debug_mark+2),a  
b1fa 18 03			jr .pastdmark  
b1fc ..			.dmark: db "DO."  
b1ff f1			.pastdmark: pop af  
b200			endm  
# End of macro DMARK
b200						CALLMONITOR 
b200 cd 6f ee			call debug_vector  
b203				endm  
# End of macro CALLMONITOR
b203					endif 
b203			;  push pc to rsp stack past the DO 
b203			 
b203 2a b9 e5				ld hl, (os_tok_ptr) 
b206 23					inc hl   ; D 
b207 23					inc hl  ; O 
b208 23					inc hl   ; null 
b209					if DEBUG_FORTH_WORDS 
b209						DMARK "DO2" 
b209 f5				push af  
b20a 3a 1e b2			ld a, (.dmark)  
b20d 32 62 ee			ld (debug_mark),a  
b210 3a 1f b2			ld a, (.dmark+1)  
b213 32 63 ee			ld (debug_mark+1),a  
b216 3a 20 b2			ld a, (.dmark+2)  
b219 32 64 ee			ld (debug_mark+2),a  
b21c 18 03			jr .pastdmark  
b21e ..			.dmark: db "DO2"  
b221 f1			.pastdmark: pop af  
b222			endm  
# End of macro DMARK
b222						CALLMONITOR 
b222 cd 6f ee			call debug_vector  
b225				endm  
# End of macro CALLMONITOR
b225					endif 
b225					FORTH_RSP_NEXT 
b225 cd 72 99			call macro_forth_rsp_next 
b228				endm 
# End of macro FORTH_RSP_NEXT
b228					if DEBUG_FORTH_WORDS 
b228						DMARK "DO3" 
b228 f5				push af  
b229 3a 3d b2			ld a, (.dmark)  
b22c 32 62 ee			ld (debug_mark),a  
b22f 3a 3e b2			ld a, (.dmark+1)  
b232 32 63 ee			ld (debug_mark+1),a  
b235 3a 3f b2			ld a, (.dmark+2)  
b238 32 64 ee			ld (debug_mark+2),a  
b23b 18 03			jr .pastdmark  
b23d ..			.dmark: db "DO3"  
b240 f1			.pastdmark: pop af  
b241			endm  
# End of macro DMARK
b241						CALLMONITOR 
b241 cd 6f ee			call debug_vector  
b244				endm  
# End of macro CALLMONITOR
b244					endif 
b244			 
b244					;if DEBUG_FORTH_WORDS 
b244				;		push hl 
b244			;		endif  
b244			 
b244			; get counters from data stack 
b244			 
b244			 
b244					FORTH_DSP_VALUEHL 
b244 cd c7 9b			call macro_dsp_valuehl 
b247				endm 
# End of macro FORTH_DSP_VALUEHL
b247 e5					push hl		 ; hl now has starting counter which needs to be tos 
b248			 
b248					if DEBUG_FORTH_WORDS 
b248						DMARK "DO4" 
b248 f5				push af  
b249 3a 5d b2			ld a, (.dmark)  
b24c 32 62 ee			ld (debug_mark),a  
b24f 3a 5e b2			ld a, (.dmark+1)  
b252 32 63 ee			ld (debug_mark+1),a  
b255 3a 5f b2			ld a, (.dmark+2)  
b258 32 64 ee			ld (debug_mark+2),a  
b25b 18 03			jr .pastdmark  
b25d ..			.dmark: db "DO4"  
b260 f1			.pastdmark: pop af  
b261			endm  
# End of macro DMARK
b261						CALLMONITOR 
b261 cd 6f ee			call debug_vector  
b264				endm  
# End of macro CALLMONITOR
b264					endif 
b264					FORTH_DSP_POP 
b264 cd 7f 9c			call macro_forth_dsp_pop 
b267				endm 
# End of macro FORTH_DSP_POP
b267			 
b267					if DEBUG_FORTH_WORDS 
b267						DMARK "DO5" 
b267 f5				push af  
b268 3a 7c b2			ld a, (.dmark)  
b26b 32 62 ee			ld (debug_mark),a  
b26e 3a 7d b2			ld a, (.dmark+1)  
b271 32 63 ee			ld (debug_mark+1),a  
b274 3a 7e b2			ld a, (.dmark+2)  
b277 32 64 ee			ld (debug_mark+2),a  
b27a 18 03			jr .pastdmark  
b27c ..			.dmark: db "DO5"  
b27f f1			.pastdmark: pop af  
b280			endm  
# End of macro DMARK
b280						CALLMONITOR 
b280 cd 6f ee			call debug_vector  
b283				endm  
# End of macro CALLMONITOR
b283					endif 
b283			 
b283					FORTH_DSP_VALUEHL 
b283 cd c7 9b			call macro_dsp_valuehl 
b286				endm 
# End of macro FORTH_DSP_VALUEHL
b286			;		push hl		 ; hl now has starting limit counter 
b286			 
b286					if DEBUG_FORTH_WORDS 
b286						DMARK "DO6" 
b286 f5				push af  
b287 3a 9b b2			ld a, (.dmark)  
b28a 32 62 ee			ld (debug_mark),a  
b28d 3a 9c b2			ld a, (.dmark+1)  
b290 32 63 ee			ld (debug_mark+1),a  
b293 3a 9d b2			ld a, (.dmark+2)  
b296 32 64 ee			ld (debug_mark+2),a  
b299 18 03			jr .pastdmark  
b29b ..			.dmark: db "DO6"  
b29e f1			.pastdmark: pop af  
b29f			endm  
# End of macro DMARK
b29f						CALLMONITOR 
b29f cd 6f ee			call debug_vector  
b2a2				endm  
# End of macro CALLMONITOR
b2a2					endif 
b2a2					FORTH_DSP_POP 
b2a2 cd 7f 9c			call macro_forth_dsp_pop 
b2a5				endm 
# End of macro FORTH_DSP_POP
b2a5			 
b2a5			; put counters on the loop stack 
b2a5			 
b2a5			;		pop hl			 ; limit counter 
b2a5 d1					pop de			; start counter 
b2a6			 
b2a6					; push limit counter 
b2a6			 
b2a6					if DEBUG_FORTH_WORDS 
b2a6						DMARK "DO7" 
b2a6 f5				push af  
b2a7 3a bb b2			ld a, (.dmark)  
b2aa 32 62 ee			ld (debug_mark),a  
b2ad 3a bc b2			ld a, (.dmark+1)  
b2b0 32 63 ee			ld (debug_mark+1),a  
b2b3 3a bd b2			ld a, (.dmark+2)  
b2b6 32 64 ee			ld (debug_mark+2),a  
b2b9 18 03			jr .pastdmark  
b2bb ..			.dmark: db "DO7"  
b2be f1			.pastdmark: pop af  
b2bf			endm  
# End of macro DMARK
b2bf						CALLMONITOR 
b2bf cd 6f ee			call debug_vector  
b2c2				endm  
# End of macro CALLMONITOR
b2c2					endif 
b2c2					FORTH_LOOP_NEXT 
b2c2 cd f8 9b			call macro_forth_loop_next 
b2c5				endm 
# End of macro FORTH_LOOP_NEXT
b2c5			 
b2c5					; push start counter 
b2c5			 
b2c5 eb					ex de, hl 
b2c6					if DEBUG_FORTH_WORDS 
b2c6						DMARK "DO7" 
b2c6 f5				push af  
b2c7 3a db b2			ld a, (.dmark)  
b2ca 32 62 ee			ld (debug_mark),a  
b2cd 3a dc b2			ld a, (.dmark+1)  
b2d0 32 63 ee			ld (debug_mark+1),a  
b2d3 3a dd b2			ld a, (.dmark+2)  
b2d6 32 64 ee			ld (debug_mark+2),a  
b2d9 18 03			jr .pastdmark  
b2db ..			.dmark: db "DO7"  
b2de f1			.pastdmark: pop af  
b2df			endm  
# End of macro DMARK
b2df						CALLMONITOR 
b2df cd 6f ee			call debug_vector  
b2e2				endm  
# End of macro CALLMONITOR
b2e2					endif 
b2e2					FORTH_LOOP_NEXT 
b2e2 cd f8 9b			call macro_forth_loop_next 
b2e5				endm 
# End of macro FORTH_LOOP_NEXT
b2e5			 
b2e5			 
b2e5					; init first round of I counter 
b2e5			 
b2e5 22 dd e5				ld (os_current_i), hl 
b2e8			 
b2e8					if DEBUG_FORTH_WORDS 
b2e8						DMARK "DO8" 
b2e8 f5				push af  
b2e9 3a fd b2			ld a, (.dmark)  
b2ec 32 62 ee			ld (debug_mark),a  
b2ef 3a fe b2			ld a, (.dmark+1)  
b2f2 32 63 ee			ld (debug_mark+1),a  
b2f5 3a ff b2			ld a, (.dmark+2)  
b2f8 32 64 ee			ld (debug_mark+2),a  
b2fb 18 03			jr .pastdmark  
b2fd ..			.dmark: db "DO8"  
b300 f1			.pastdmark: pop af  
b301			endm  
# End of macro DMARK
b301						CALLMONITOR 
b301 cd 6f ee			call debug_vector  
b304				endm  
# End of macro CALLMONITOR
b304					endif 
b304			 
b304					NEXTW 
b304 cd 6c ee			call parse_vector 
b307 c3 ae 9d			jp macro_next 
b30a				endm 
# End of macro NEXTW
b30a			.LOOP: 
b30a				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b30a 22				db WORD_SYS_CORE+14             
b30b 28 b4			dw .I            
b30d 05				db 4 + 1 
b30e .. 00			db "LOOP",0              
b313				endm 
# End of macro CWHEAD
b313			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b313			 
b313				; pop tos as current loop count to hl 
b313			 
b313				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b313			 
b313				FORTH_LOOP_TOS 
b313 cd 2b 9c			call macro_forth_loop_tos 
b316				endm 
# End of macro FORTH_LOOP_TOS
b316 e5				push hl 
b317			 
b317					if DEBUG_FORTH_WORDS_KEY 
b317						DMARK "LOP" 
b317 f5				push af  
b318 3a 2c b3			ld a, (.dmark)  
b31b 32 62 ee			ld (debug_mark),a  
b31e 3a 2d b3			ld a, (.dmark+1)  
b321 32 63 ee			ld (debug_mark+1),a  
b324 3a 2e b3			ld a, (.dmark+2)  
b327 32 64 ee			ld (debug_mark+2),a  
b32a 18 03			jr .pastdmark  
b32c ..			.dmark: db "LOP"  
b32f f1			.pastdmark: pop af  
b330			endm  
# End of macro DMARK
b330						CALLMONITOR 
b330 cd 6f ee			call debug_vector  
b333				endm  
# End of macro CALLMONITOR
b333					endif 
b333				; next item on the stack is the limit. get it 
b333			 
b333			 
b333				FORTH_LOOP_POP 
b333 cd 35 9c			call macro_forth_loop_pop 
b336				endm 
# End of macro FORTH_LOOP_POP
b336			 
b336				FORTH_LOOP_TOS 
b336 cd 2b 9c			call macro_forth_loop_tos 
b339				endm 
# End of macro FORTH_LOOP_TOS
b339			 
b339 d1				pop de		 ; de = i, hl = limit 
b33a			 
b33a					if DEBUG_FORTH_WORDS 
b33a						DMARK "LP1" 
b33a f5				push af  
b33b 3a 4f b3			ld a, (.dmark)  
b33e 32 62 ee			ld (debug_mark),a  
b341 3a 50 b3			ld a, (.dmark+1)  
b344 32 63 ee			ld (debug_mark+1),a  
b347 3a 51 b3			ld a, (.dmark+2)  
b34a 32 64 ee			ld (debug_mark+2),a  
b34d 18 03			jr .pastdmark  
b34f ..			.dmark: db "LP1"  
b352 f1			.pastdmark: pop af  
b353			endm  
# End of macro DMARK
b353						CALLMONITOR 
b353 cd 6f ee			call debug_vector  
b356				endm  
# End of macro CALLMONITOR
b356					endif 
b356			 
b356				; go back to previous word 
b356			 
b356 d5				push de    ; save I for inc later 
b357			 
b357			 
b357				; get limit 
b357				;  is I at limit? 
b357			 
b357			 
b357					if DEBUG_FORTH_WORDS 
b357						DMARK "LP1" 
b357 f5				push af  
b358 3a 6c b3			ld a, (.dmark)  
b35b 32 62 ee			ld (debug_mark),a  
b35e 3a 6d b3			ld a, (.dmark+1)  
b361 32 63 ee			ld (debug_mark+1),a  
b364 3a 6e b3			ld a, (.dmark+2)  
b367 32 64 ee			ld (debug_mark+2),a  
b36a 18 03			jr .pastdmark  
b36c ..			.dmark: db "LP1"  
b36f f1			.pastdmark: pop af  
b370			endm  
# End of macro DMARK
b370						CALLMONITOR 
b370 cd 6f ee			call debug_vector  
b373				endm  
# End of macro CALLMONITOR
b373					endif 
b373			 
b373 ed 52			sbc hl, de 
b375			 
b375			 
b375				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b375			 
b375 20 29				jr nz, .loopnotdone 
b377			 
b377 e1				pop hl   ; get rid of saved I 
b378				FORTH_LOOP_POP     ; get rid of limit 
b378 cd 35 9c			call macro_forth_loop_pop 
b37b				endm 
# End of macro FORTH_LOOP_POP
b37b			 
b37b				FORTH_RSP_POP     ; get rid of DO ptr 
b37b cd 93 99			call macro_forth_rsp_pop 
b37e				endm 
# End of macro FORTH_RSP_POP
b37e			 
b37e			if DEBUG_FORTH_WORDS 
b37e						DMARK "LP>" 
b37e f5				push af  
b37f 3a 93 b3			ld a, (.dmark)  
b382 32 62 ee			ld (debug_mark),a  
b385 3a 94 b3			ld a, (.dmark+1)  
b388 32 63 ee			ld (debug_mark+1),a  
b38b 3a 95 b3			ld a, (.dmark+2)  
b38e 32 64 ee			ld (debug_mark+2),a  
b391 18 03			jr .pastdmark  
b393 ..			.dmark: db "LP>"  
b396 f1			.pastdmark: pop af  
b397			endm  
# End of macro DMARK
b397				CALLMONITOR 
b397 cd 6f ee			call debug_vector  
b39a				endm  
# End of macro CALLMONITOR
b39a			endif 
b39a			 
b39a					NEXTW 
b39a cd 6c ee			call parse_vector 
b39d c3 ae 9d			jp macro_next 
b3a0				endm 
# End of macro NEXTW
b3a0				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b3a0			 
b3a0			.loopnotdone: 
b3a0			 
b3a0 e1				pop hl    ; get I 
b3a1 23				inc hl 
b3a2			 
b3a2			   	; save new I 
b3a2			 
b3a2			 
b3a2					; set I counter 
b3a2			 
b3a2 22 dd e5				ld (os_current_i), hl 
b3a5			 
b3a5					if DEBUG_FORTH_WORDS 
b3a5						DMARK "LPN" 
b3a5 f5				push af  
b3a6 3a ba b3			ld a, (.dmark)  
b3a9 32 62 ee			ld (debug_mark),a  
b3ac 3a bb b3			ld a, (.dmark+1)  
b3af 32 63 ee			ld (debug_mark+1),a  
b3b2 3a bc b3			ld a, (.dmark+2)  
b3b5 32 64 ee			ld (debug_mark+2),a  
b3b8 18 03			jr .pastdmark  
b3ba ..			.dmark: db "LPN"  
b3bd f1			.pastdmark: pop af  
b3be			endm  
# End of macro DMARK
b3be					CALLMONITOR 
b3be cd 6f ee			call debug_vector  
b3c1				endm  
# End of macro CALLMONITOR
b3c1					endif 
b3c1					 
b3c1				FORTH_LOOP_NEXT 
b3c1 cd f8 9b			call macro_forth_loop_next 
b3c4				endm 
# End of macro FORTH_LOOP_NEXT
b3c4			 
b3c4			 
b3c4					if DEBUG_FORTH_WORDS 
b3c4 eb						ex de,hl 
b3c5					endif 
b3c5			 
b3c5			;	; get DO ptr 
b3c5			; 
b3c5					if DEBUG_FORTH_WORDS 
b3c5						DMARK "LP7" 
b3c5 f5				push af  
b3c6 3a da b3			ld a, (.dmark)  
b3c9 32 62 ee			ld (debug_mark),a  
b3cc 3a db b3			ld a, (.dmark+1)  
b3cf 32 63 ee			ld (debug_mark+1),a  
b3d2 3a dc b3			ld a, (.dmark+2)  
b3d5 32 64 ee			ld (debug_mark+2),a  
b3d8 18 03			jr .pastdmark  
b3da ..			.dmark: db "LP7"  
b3dd f1			.pastdmark: pop af  
b3de			endm  
# End of macro DMARK
b3de					CALLMONITOR 
b3de cd 6f ee			call debug_vector  
b3e1				endm  
# End of macro CALLMONITOR
b3e1					endif 
b3e1				FORTH_RSP_TOS 
b3e1 cd 89 99			call macro_forth_rsp_tos 
b3e4				endm 
# End of macro FORTH_RSP_TOS
b3e4			 
b3e4					if DEBUG_FORTH_WORDS 
b3e4						DMARK "LP8" 
b3e4 f5				push af  
b3e5 3a f9 b3			ld a, (.dmark)  
b3e8 32 62 ee			ld (debug_mark),a  
b3eb 3a fa b3			ld a, (.dmark+1)  
b3ee 32 63 ee			ld (debug_mark+1),a  
b3f1 3a fb b3			ld a, (.dmark+2)  
b3f4 32 64 ee			ld (debug_mark+2),a  
b3f7 18 03			jr .pastdmark  
b3f9 ..			.dmark: db "LP8"  
b3fc f1			.pastdmark: pop af  
b3fd			endm  
# End of macro DMARK
b3fd					CALLMONITOR 
b3fd cd 6f ee			call debug_vector  
b400				endm  
# End of macro CALLMONITOR
b400					endif 
b400				;push hl 
b400			 
b400				; not going to DO any more 
b400				; get rid of the RSP pointer as DO will add it back in 
b400				;FORTH_RSP_POP 
b400				;pop hl 
b400			 
b400				;ld hl,(cli_ret_sp) 
b400				;ld e, (hl) 
b400				;inc hl 
b400				;ld d, (hl) 
b400				;ex de,hl 
b400 22 b9 e5			ld (os_tok_ptr), hl 
b403					if DEBUG_FORTH_WORDS 
b403						DMARK "LP<" 
b403 f5				push af  
b404 3a 18 b4			ld a, (.dmark)  
b407 32 62 ee			ld (debug_mark),a  
b40a 3a 19 b4			ld a, (.dmark+1)  
b40d 32 63 ee			ld (debug_mark+1),a  
b410 3a 1a b4			ld a, (.dmark+2)  
b413 32 64 ee			ld (debug_mark+2),a  
b416 18 03			jr .pastdmark  
b418 ..			.dmark: db "LP<"  
b41b f1			.pastdmark: pop af  
b41c			endm  
# End of macro DMARK
b41c					CALLMONITOR 
b41c cd 6f ee			call debug_vector  
b41f				endm  
# End of macro CALLMONITOR
b41f				endif 
b41f c3 2f 9e			jp exec1 
b422			 
b422					 
b422			 
b422			 
b422					NEXTW 
b422 cd 6c ee			call parse_vector 
b425 c3 ae 9d			jp macro_next 
b428				endm 
# End of macro NEXTW
b428			.I:  
b428			 
b428				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b428 5e				db WORD_SYS_CORE+74             
b429 56 b4			dw .DLOOP            
b42b 02				db 1 + 1 
b42c .. 00			db "I",0              
b42e				endm 
# End of macro CWHEAD
b42e			; | I ( -- ) Current loop counter | DONE 
b42e					if DEBUG_FORTH_WORDS_KEY 
b42e						DMARK "I.." 
b42e f5				push af  
b42f 3a 43 b4			ld a, (.dmark)  
b432 32 62 ee			ld (debug_mark),a  
b435 3a 44 b4			ld a, (.dmark+1)  
b438 32 63 ee			ld (debug_mark+1),a  
b43b 3a 45 b4			ld a, (.dmark+2)  
b43e 32 64 ee			ld (debug_mark+2),a  
b441 18 03			jr .pastdmark  
b443 ..			.dmark: db "I.."  
b446 f1			.pastdmark: pop af  
b447			endm  
# End of macro DMARK
b447						CALLMONITOR 
b447 cd 6f ee			call debug_vector  
b44a				endm  
# End of macro CALLMONITOR
b44a					endif 
b44a			 
b44a 2a dd e5				ld hl,(os_current_i) 
b44d cd cb 99				call forth_push_numhl 
b450			 
b450					NEXTW 
b450 cd 6c ee			call parse_vector 
b453 c3 ae 9d			jp macro_next 
b456				endm 
# End of macro NEXTW
b456			.DLOOP: 
b456				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b456 5f				db WORD_SYS_CORE+75             
b457 3d b5			dw .REPEAT            
b459 06				db 5 + 1 
b45a .. 00			db "-LOOP",0              
b460				endm 
# End of macro CWHEAD
b460			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b460				; pop tos as current loop count to hl 
b460					if DEBUG_FORTH_WORDS_KEY 
b460						DMARK "-LP" 
b460 f5				push af  
b461 3a 75 b4			ld a, (.dmark)  
b464 32 62 ee			ld (debug_mark),a  
b467 3a 76 b4			ld a, (.dmark+1)  
b46a 32 63 ee			ld (debug_mark+1),a  
b46d 3a 77 b4			ld a, (.dmark+2)  
b470 32 64 ee			ld (debug_mark+2),a  
b473 18 03			jr .pastdmark  
b475 ..			.dmark: db "-LP"  
b478 f1			.pastdmark: pop af  
b479			endm  
# End of macro DMARK
b479						CALLMONITOR 
b479 cd 6f ee			call debug_vector  
b47c				endm  
# End of macro CALLMONITOR
b47c					endif 
b47c			 
b47c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b47c			 
b47c				FORTH_LOOP_TOS 
b47c cd 2b 9c			call macro_forth_loop_tos 
b47f				endm 
# End of macro FORTH_LOOP_TOS
b47f e5				push hl 
b480			 
b480					if DEBUG_FORTH_WORDS 
b480						DMARK "-LP" 
b480 f5				push af  
b481 3a 95 b4			ld a, (.dmark)  
b484 32 62 ee			ld (debug_mark),a  
b487 3a 96 b4			ld a, (.dmark+1)  
b48a 32 63 ee			ld (debug_mark+1),a  
b48d 3a 97 b4			ld a, (.dmark+2)  
b490 32 64 ee			ld (debug_mark+2),a  
b493 18 03			jr .pastdmark  
b495 ..			.dmark: db "-LP"  
b498 f1			.pastdmark: pop af  
b499			endm  
# End of macro DMARK
b499						CALLMONITOR 
b499 cd 6f ee			call debug_vector  
b49c				endm  
# End of macro CALLMONITOR
b49c					endif 
b49c				; next item on the stack is the limit. get it 
b49c			 
b49c			 
b49c				FORTH_LOOP_POP 
b49c cd 35 9c			call macro_forth_loop_pop 
b49f				endm 
# End of macro FORTH_LOOP_POP
b49f			 
b49f				FORTH_LOOP_TOS 
b49f cd 2b 9c			call macro_forth_loop_tos 
b4a2				endm 
# End of macro FORTH_LOOP_TOS
b4a2			 
b4a2 d1				pop de		 ; de = i, hl = limit 
b4a3			 
b4a3					if DEBUG_FORTH_WORDS 
b4a3						DMARK "-L1" 
b4a3 f5				push af  
b4a4 3a b8 b4			ld a, (.dmark)  
b4a7 32 62 ee			ld (debug_mark),a  
b4aa 3a b9 b4			ld a, (.dmark+1)  
b4ad 32 63 ee			ld (debug_mark+1),a  
b4b0 3a ba b4			ld a, (.dmark+2)  
b4b3 32 64 ee			ld (debug_mark+2),a  
b4b6 18 03			jr .pastdmark  
b4b8 ..			.dmark: db "-L1"  
b4bb f1			.pastdmark: pop af  
b4bc			endm  
# End of macro DMARK
b4bc						CALLMONITOR 
b4bc cd 6f ee			call debug_vector  
b4bf				endm  
# End of macro CALLMONITOR
b4bf					endif 
b4bf			 
b4bf				; go back to previous word 
b4bf			 
b4bf d5				push de    ; save I for inc later 
b4c0			 
b4c0			 
b4c0				; get limit 
b4c0				;  is I at limit? 
b4c0			 
b4c0			 
b4c0					if DEBUG_FORTH_WORDS 
b4c0						DMARK "-L1" 
b4c0 f5				push af  
b4c1 3a d5 b4			ld a, (.dmark)  
b4c4 32 62 ee			ld (debug_mark),a  
b4c7 3a d6 b4			ld a, (.dmark+1)  
b4ca 32 63 ee			ld (debug_mark+1),a  
b4cd 3a d7 b4			ld a, (.dmark+2)  
b4d0 32 64 ee			ld (debug_mark+2),a  
b4d3 18 03			jr .pastdmark  
b4d5 ..			.dmark: db "-L1"  
b4d8 f1			.pastdmark: pop af  
b4d9			endm  
# End of macro DMARK
b4d9						CALLMONITOR 
b4d9 cd 6f ee			call debug_vector  
b4dc				endm  
# End of macro CALLMONITOR
b4dc					endif 
b4dc			 
b4dc ed 52			sbc hl, de 
b4de			 
b4de			 
b4de				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b4de			 
b4de 20 29				jr nz, .mloopnotdone 
b4e0			 
b4e0 e1				pop hl   ; get rid of saved I 
b4e1				FORTH_LOOP_POP     ; get rid of limit 
b4e1 cd 35 9c			call macro_forth_loop_pop 
b4e4				endm 
# End of macro FORTH_LOOP_POP
b4e4			 
b4e4				FORTH_RSP_POP     ; get rid of DO ptr 
b4e4 cd 93 99			call macro_forth_rsp_pop 
b4e7				endm 
# End of macro FORTH_RSP_POP
b4e7			 
b4e7			if DEBUG_FORTH_WORDS 
b4e7						DMARK "-L>" 
b4e7 f5				push af  
b4e8 3a fc b4			ld a, (.dmark)  
b4eb 32 62 ee			ld (debug_mark),a  
b4ee 3a fd b4			ld a, (.dmark+1)  
b4f1 32 63 ee			ld (debug_mark+1),a  
b4f4 3a fe b4			ld a, (.dmark+2)  
b4f7 32 64 ee			ld (debug_mark+2),a  
b4fa 18 03			jr .pastdmark  
b4fc ..			.dmark: db "-L>"  
b4ff f1			.pastdmark: pop af  
b500			endm  
# End of macro DMARK
b500				CALLMONITOR 
b500 cd 6f ee			call debug_vector  
b503				endm  
# End of macro CALLMONITOR
b503			endif 
b503			 
b503					NEXTW 
b503 cd 6c ee			call parse_vector 
b506 c3 ae 9d			jp macro_next 
b509				endm 
# End of macro NEXTW
b509				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b509			 
b509			.mloopnotdone: 
b509			 
b509 e1				pop hl    ; get I 
b50a 2b				dec hl 
b50b			 
b50b			   	; save new I 
b50b			 
b50b			 
b50b					; set I counter 
b50b			 
b50b 22 dd e5				ld (os_current_i), hl 
b50e			 
b50e					 
b50e				FORTH_LOOP_NEXT 
b50e cd f8 9b			call macro_forth_loop_next 
b511				endm 
# End of macro FORTH_LOOP_NEXT
b511			 
b511			 
b511					if DEBUG_FORTH_WORDS 
b511 eb						ex de,hl 
b512					endif 
b512			 
b512			;	; get DO ptr 
b512			; 
b512				FORTH_RSP_TOS 
b512 cd 89 99			call macro_forth_rsp_tos 
b515				endm 
# End of macro FORTH_RSP_TOS
b515			 
b515				;push hl 
b515			 
b515				; not going to DO any more 
b515				; get rid of the RSP pointer as DO will add it back in 
b515				;FORTH_RSP_POP 
b515				;pop hl 
b515			 
b515			 
b515 22 b9 e5			ld (os_tok_ptr), hl 
b518					if DEBUG_FORTH_WORDS 
b518						DMARK "-L<" 
b518 f5				push af  
b519 3a 2d b5			ld a, (.dmark)  
b51c 32 62 ee			ld (debug_mark),a  
b51f 3a 2e b5			ld a, (.dmark+1)  
b522 32 63 ee			ld (debug_mark+1),a  
b525 3a 2f b5			ld a, (.dmark+2)  
b528 32 64 ee			ld (debug_mark+2),a  
b52b 18 03			jr .pastdmark  
b52d ..			.dmark: db "-L<"  
b530 f1			.pastdmark: pop af  
b531			endm  
# End of macro DMARK
b531					CALLMONITOR 
b531 cd 6f ee			call debug_vector  
b534				endm  
# End of macro CALLMONITOR
b534				endif 
b534 c3 2f 9e			jp exec1 
b537			 
b537					 
b537			 
b537			 
b537			 
b537				NEXTW 
b537 cd 6c ee			call parse_vector 
b53a c3 ae 9d			jp macro_next 
b53d				endm 
# End of macro NEXTW
b53d			 
b53d			 
b53d			 
b53d			 
b53d			.REPEAT: 
b53d				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b53d 71				db WORD_SYS_CORE+93             
b53e 93 b5			dw .UNTIL            
b540 06				db 5 + 1 
b541 .. 00			db "REPEAT",0              
b548				endm 
# End of macro CWHEAD
b548			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b548			;  push pc to rsp stack past the REPEAT 
b548					if DEBUG_FORTH_WORDS_KEY 
b548						DMARK "REP" 
b548 f5				push af  
b549 3a 5d b5			ld a, (.dmark)  
b54c 32 62 ee			ld (debug_mark),a  
b54f 3a 5e b5			ld a, (.dmark+1)  
b552 32 63 ee			ld (debug_mark+1),a  
b555 3a 5f b5			ld a, (.dmark+2)  
b558 32 64 ee			ld (debug_mark+2),a  
b55b 18 03			jr .pastdmark  
b55d ..			.dmark: db "REP"  
b560 f1			.pastdmark: pop af  
b561			endm  
# End of macro DMARK
b561						CALLMONITOR 
b561 cd 6f ee			call debug_vector  
b564				endm  
# End of macro CALLMONITOR
b564					endif 
b564			 
b564 2a b9 e5				ld hl, (os_tok_ptr) 
b567 23					inc hl   ; R 
b568 23					inc hl  ; E 
b569 23					inc hl   ; P 
b56a 23					inc hl   ; E 
b56b 23					inc hl   ; A 
b56c 23					inc hl   ; T 
b56d 23					inc hl   ; zero 
b56e					FORTH_RSP_NEXT 
b56e cd 72 99			call macro_forth_rsp_next 
b571				endm 
# End of macro FORTH_RSP_NEXT
b571			 
b571			 
b571					if DEBUG_FORTH_WORDS 
b571						DMARK "REP" 
b571 f5				push af  
b572 3a 86 b5			ld a, (.dmark)  
b575 32 62 ee			ld (debug_mark),a  
b578 3a 87 b5			ld a, (.dmark+1)  
b57b 32 63 ee			ld (debug_mark+1),a  
b57e 3a 88 b5			ld a, (.dmark+2)  
b581 32 64 ee			ld (debug_mark+2),a  
b584 18 03			jr .pastdmark  
b586 ..			.dmark: db "REP"  
b589 f1			.pastdmark: pop af  
b58a			endm  
# End of macro DMARK
b58a						;pop bc    ; TODO BUG ?????? what is this for???? 
b58a						CALLMONITOR 
b58a cd 6f ee			call debug_vector  
b58d				endm  
# End of macro CALLMONITOR
b58d					endif 
b58d			 
b58d					NEXTW 
b58d cd 6c ee			call parse_vector 
b590 c3 ae 9d			jp macro_next 
b593				endm 
# End of macro NEXTW
b593			;	       NEXTW 
b593			 
b593			.UNTIL: 
b593				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b593 72				db WORD_SYS_CORE+94             
b594 30 b6			dw .ENDFLOW            
b596 06				db 5 + 1 
b597 .. 00			db "UNTIL",0              
b59d				endm 
# End of macro CWHEAD
b59d			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b59d			 
b59d				; pop tos as check 
b59d			 
b59d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b59d			 
b59d				FORTH_DSP_VALUEHL 
b59d cd c7 9b			call macro_dsp_valuehl 
b5a0				endm 
# End of macro FORTH_DSP_VALUEHL
b5a0			 
b5a0					if DEBUG_FORTH_WORDS_KEY 
b5a0						DMARK "UNT" 
b5a0 f5				push af  
b5a1 3a b5 b5			ld a, (.dmark)  
b5a4 32 62 ee			ld (debug_mark),a  
b5a7 3a b6 b5			ld a, (.dmark+1)  
b5aa 32 63 ee			ld (debug_mark+1),a  
b5ad 3a b7 b5			ld a, (.dmark+2)  
b5b0 32 64 ee			ld (debug_mark+2),a  
b5b3 18 03			jr .pastdmark  
b5b5 ..			.dmark: db "UNT"  
b5b8 f1			.pastdmark: pop af  
b5b9			endm  
# End of macro DMARK
b5b9						CALLMONITOR 
b5b9 cd 6f ee			call debug_vector  
b5bc				endm  
# End of macro CALLMONITOR
b5bc					endif 
b5bc			 
b5bc			;	push hl 
b5bc				FORTH_DSP_POP 
b5bc cd 7f 9c			call macro_forth_dsp_pop 
b5bf				endm 
# End of macro FORTH_DSP_POP
b5bf			 
b5bf			;	pop hl 
b5bf			 
b5bf				; test if true 
b5bf			 
b5bf cd ff 8c			call ishlzero 
b5c2			;	ld a,l 
b5c2			;	add h 
b5c2			; 
b5c2			;	cp 0 
b5c2			 
b5c2 20 41			jr nz, .untilnotdone 
b5c4			 
b5c4					if DEBUG_FORTH_WORDS 
b5c4						DMARK "UNf" 
b5c4 f5				push af  
b5c5 3a d9 b5			ld a, (.dmark)  
b5c8 32 62 ee			ld (debug_mark),a  
b5cb 3a da b5			ld a, (.dmark+1)  
b5ce 32 63 ee			ld (debug_mark+1),a  
b5d1 3a db b5			ld a, (.dmark+2)  
b5d4 32 64 ee			ld (debug_mark+2),a  
b5d7 18 03			jr .pastdmark  
b5d9 ..			.dmark: db "UNf"  
b5dc f1			.pastdmark: pop af  
b5dd			endm  
# End of macro DMARK
b5dd						CALLMONITOR 
b5dd cd 6f ee			call debug_vector  
b5e0				endm  
# End of macro CALLMONITOR
b5e0					endif 
b5e0			 
b5e0			 
b5e0			 
b5e0				FORTH_RSP_POP     ; get rid of DO ptr 
b5e0 cd 93 99			call macro_forth_rsp_pop 
b5e3				endm 
# End of macro FORTH_RSP_POP
b5e3			 
b5e3			if DEBUG_FORTH_WORDS 
b5e3						DMARK "UN>" 
b5e3 f5				push af  
b5e4 3a f8 b5			ld a, (.dmark)  
b5e7 32 62 ee			ld (debug_mark),a  
b5ea 3a f9 b5			ld a, (.dmark+1)  
b5ed 32 63 ee			ld (debug_mark+1),a  
b5f0 3a fa b5			ld a, (.dmark+2)  
b5f3 32 64 ee			ld (debug_mark+2),a  
b5f6 18 03			jr .pastdmark  
b5f8 ..			.dmark: db "UN>"  
b5fb f1			.pastdmark: pop af  
b5fc			endm  
# End of macro DMARK
b5fc				CALLMONITOR 
b5fc cd 6f ee			call debug_vector  
b5ff				endm  
# End of macro CALLMONITOR
b5ff			endif 
b5ff			 
b5ff					NEXTW 
b5ff cd 6c ee			call parse_vector 
b602 c3 ae 9d			jp macro_next 
b605				endm 
# End of macro NEXTW
b605				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b605			 
b605			.untilnotdone: 
b605			 
b605			 
b605			;	; get DO ptr 
b605			; 
b605				FORTH_RSP_TOS 
b605 cd 89 99			call macro_forth_rsp_tos 
b608				endm 
# End of macro FORTH_RSP_TOS
b608			 
b608				;push hl 
b608			 
b608				; not going to DO any more 
b608				; get rid of the RSP pointer as DO will add it back in 
b608				;FORTH_RSP_POP 
b608				;pop hl 
b608			 
b608			 
b608 22 b9 e5			ld (os_tok_ptr), hl 
b60b					if DEBUG_FORTH_WORDS 
b60b						DMARK "UN<" 
b60b f5				push af  
b60c 3a 20 b6			ld a, (.dmark)  
b60f 32 62 ee			ld (debug_mark),a  
b612 3a 21 b6			ld a, (.dmark+1)  
b615 32 63 ee			ld (debug_mark+1),a  
b618 3a 22 b6			ld a, (.dmark+2)  
b61b 32 64 ee			ld (debug_mark+2),a  
b61e 18 03			jr .pastdmark  
b620 ..			.dmark: db "UN<"  
b623 f1			.pastdmark: pop af  
b624			endm  
# End of macro DMARK
b624					CALLMONITOR 
b624 cd 6f ee			call debug_vector  
b627				endm  
# End of macro CALLMONITOR
b627				endif 
b627 c3 2f 9e			jp exec1 
b62a			 
b62a					 
b62a			 
b62a			 
b62a					NEXTW 
b62a cd 6c ee			call parse_vector 
b62d c3 ae 9d			jp macro_next 
b630				endm 
# End of macro NEXTW
b630			 
b630			 
b630			.ENDFLOW: 
b630			 
b630			; eof 
b630			 
# End of file forth_words_flow.asm
b630			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b630			include "forth_words_logic.asm" 
b630			 
b630			; | ## Logic Words 
b630			 
b630			.NOT: 
b630				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b630 2d				db WORD_SYS_CORE+25             
b631 7e b6			dw .IS            
b633 04				db 3 + 1 
b634 .. 00			db "NOT",0              
b638				endm 
# End of macro CWHEAD
b638			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b638					if DEBUG_FORTH_WORDS_KEY 
b638						DMARK "NOT" 
b638 f5				push af  
b639 3a 4d b6			ld a, (.dmark)  
b63c 32 62 ee			ld (debug_mark),a  
b63f 3a 4e b6			ld a, (.dmark+1)  
b642 32 63 ee			ld (debug_mark+1),a  
b645 3a 4f b6			ld a, (.dmark+2)  
b648 32 64 ee			ld (debug_mark+2),a  
b64b 18 03			jr .pastdmark  
b64d ..			.dmark: db "NOT"  
b650 f1			.pastdmark: pop af  
b651			endm  
# End of macro DMARK
b651						CALLMONITOR 
b651 cd 6f ee			call debug_vector  
b654				endm  
# End of macro CALLMONITOR
b654					endif 
b654					FORTH_DSP 
b654 cd 8d 9b			call macro_forth_dsp 
b657				endm 
# End of macro FORTH_DSP
b657 7e					ld a,(hl)	; get type of value on TOS 
b658 fe 02				cp DS_TYPE_INUM  
b65a 28 06				jr z, .noti 
b65c					NEXTW 
b65c cd 6c ee			call parse_vector 
b65f c3 ae 9d			jp macro_next 
b662				endm 
# End of macro NEXTW
b662			.noti:          FORTH_DSP_VALUEHL 
b662 cd c7 9b			call macro_dsp_valuehl 
b665				endm 
# End of macro FORTH_DSP_VALUEHL
b665			;		push hl 
b665					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b665 cd 7f 9c			call macro_forth_dsp_pop 
b668				endm 
# End of macro FORTH_DSP_POP
b668			;		pop hl 
b668 3e 00				ld a,0 
b66a bd					cp l 
b66b 28 04				jr z, .not2t 
b66d 2e 00				ld l, 0 
b66f 18 02				jr .notip 
b671			 
b671 2e ff		.not2t:		ld l, 255 
b673			 
b673 26 00		.notip:		ld h, 0	 
b675			 
b675 cd cb 99				call forth_push_numhl 
b678					NEXTW 
b678 cd 6c ee			call parse_vector 
b67b c3 ae 9d			jp macro_next 
b67e				endm 
# End of macro NEXTW
b67e			 
b67e			.IS: 
b67e				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
b67e 2d				db WORD_SYS_CORE+25             
b67f c2 b6			dw .LZERO            
b681 08				db 7 + 1 
b682 .. 00			db "COMPARE",0              
b68a				endm 
# End of macro CWHEAD
b68a			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
b68a					if DEBUG_FORTH_WORDS_KEY 
b68a						DMARK "CMP" 
b68a f5				push af  
b68b 3a 9f b6			ld a, (.dmark)  
b68e 32 62 ee			ld (debug_mark),a  
b691 3a a0 b6			ld a, (.dmark+1)  
b694 32 63 ee			ld (debug_mark+1),a  
b697 3a a1 b6			ld a, (.dmark+2)  
b69a 32 64 ee			ld (debug_mark+2),a  
b69d 18 03			jr .pastdmark  
b69f ..			.dmark: db "CMP"  
b6a2 f1			.pastdmark: pop af  
b6a3			endm  
# End of macro DMARK
b6a3						CALLMONITOR 
b6a3 cd 6f ee			call debug_vector  
b6a6				endm  
# End of macro CALLMONITOR
b6a6					endif 
b6a6			 
b6a6					FORTH_DSP_VALUEHL 
b6a6 cd c7 9b			call macro_dsp_valuehl 
b6a9				endm 
# End of macro FORTH_DSP_VALUEHL
b6a9			 
b6a9 e5					push hl 
b6aa			 
b6aa					FORTH_DSP_VALUEM1 
b6aa cd bb 9b			call macro_forth_dsp_value_m1 
b6ad				endm 
# End of macro FORTH_DSP_VALUEM1
b6ad			 
b6ad d1					pop de 
b6ae			 
b6ae					; got pointers to both. Now check. 
b6ae			 
b6ae cd 66 90				call strcmp 
b6b1				 
b6b1 26 00				ld h, 0 
b6b3 2e 00				ld l, 0 
b6b5 20 02				jr nz, .compnsame 
b6b7 2e 01				ld l, 1	 
b6b9			.compnsame: 
b6b9 cd cb 99				call forth_push_numhl 
b6bc			 
b6bc					NEXTW 
b6bc cd 6c ee			call parse_vector 
b6bf c3 ae 9d			jp macro_next 
b6c2				endm 
# End of macro NEXTW
b6c2			.LZERO: 
b6c2				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b6c2 2d				db WORD_SYS_CORE+25             
b6c3 cf b6			dw .TZERO            
b6c5 03				db 2 + 1 
b6c6 .. 00			db "0<",0              
b6c9				endm 
# End of macro CWHEAD
b6c9			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b6c9					NEXTW 
b6c9 cd 6c ee			call parse_vector 
b6cc c3 ae 9d			jp macro_next 
b6cf				endm 
# End of macro NEXTW
b6cf			.TZERO: 
b6cf				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b6cf 2e				db WORD_SYS_CORE+26             
b6d0 19 b7			dw .LESS            
b6d2 03				db 2 + 1 
b6d3 .. 00			db "0=",0              
b6d6				endm 
# End of macro CWHEAD
b6d6			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b6d6				; TODO add floating point number detection 
b6d6					;v5 FORTH_DSP_VALUE 
b6d6					if DEBUG_FORTH_WORDS_KEY 
b6d6						DMARK "0=." 
b6d6 f5				push af  
b6d7 3a eb b6			ld a, (.dmark)  
b6da 32 62 ee			ld (debug_mark),a  
b6dd 3a ec b6			ld a, (.dmark+1)  
b6e0 32 63 ee			ld (debug_mark+1),a  
b6e3 3a ed b6			ld a, (.dmark+2)  
b6e6 32 64 ee			ld (debug_mark+2),a  
b6e9 18 03			jr .pastdmark  
b6eb ..			.dmark: db "0=."  
b6ee f1			.pastdmark: pop af  
b6ef			endm  
# End of macro DMARK
b6ef						CALLMONITOR 
b6ef cd 6f ee			call debug_vector  
b6f2				endm  
# End of macro CALLMONITOR
b6f2					endif 
b6f2					FORTH_DSP 
b6f2 cd 8d 9b			call macro_forth_dsp 
b6f5				endm 
# End of macro FORTH_DSP
b6f5 7e					ld a,(hl)	; get type of value on TOS 
b6f6 fe 02				cp DS_TYPE_INUM  
b6f8 28 00				jr z, .tz_inum 
b6fa			 
b6fa				if FORTH_ENABLE_FLOATMATH 
b6fa					jr .tz_done 
b6fa			 
b6fa				endif 
b6fa					 
b6fa			 
b6fa			.tz_inum: 
b6fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6fa cd c7 9b			call macro_dsp_valuehl 
b6fd				endm 
# End of macro FORTH_DSP_VALUEHL
b6fd			 
b6fd			;		push hl 
b6fd			 
b6fd					; destroy value TOS 
b6fd			 
b6fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6fd cd 7f 9c			call macro_forth_dsp_pop 
b700				endm 
# End of macro FORTH_DSP_POP
b700			 
b700			;		pop hl 
b700			 
b700 3e 00				ld a,0 
b702			 
b702 bd					cp l 
b703 20 08				jr nz, .tz_notzero 
b705			 
b705 bc					cp h 
b706			 
b706 20 05				jr nz, .tz_notzero 
b708			 
b708			 
b708 21 01 00				ld hl, FORTH_TRUE 
b70b 18 03				jr .tz_done 
b70d			 
b70d 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b710			 
b710					; push value back onto stack for another op etc 
b710			 
b710			.tz_done: 
b710 cd cb 99				call forth_push_numhl 
b713			 
b713					NEXTW 
b713 cd 6c ee			call parse_vector 
b716 c3 ae 9d			jp macro_next 
b719				endm 
# End of macro NEXTW
b719			.LESS: 
b719				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b719 2f				db WORD_SYS_CORE+27             
b71a 85 b7			dw .GT            
b71c 02				db 1 + 1 
b71d .. 00			db "<",0              
b71f				endm 
# End of macro CWHEAD
b71f			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b71f				; TODO add floating point number detection 
b71f					if DEBUG_FORTH_WORDS_KEY 
b71f						DMARK "LES" 
b71f f5				push af  
b720 3a 34 b7			ld a, (.dmark)  
b723 32 62 ee			ld (debug_mark),a  
b726 3a 35 b7			ld a, (.dmark+1)  
b729 32 63 ee			ld (debug_mark+1),a  
b72c 3a 36 b7			ld a, (.dmark+2)  
b72f 32 64 ee			ld (debug_mark+2),a  
b732 18 03			jr .pastdmark  
b734 ..			.dmark: db "LES"  
b737 f1			.pastdmark: pop af  
b738			endm  
# End of macro DMARK
b738						CALLMONITOR 
b738 cd 6f ee			call debug_vector  
b73b				endm  
# End of macro CALLMONITOR
b73b					endif 
b73b					FORTH_DSP 
b73b cd 8d 9b			call macro_forth_dsp 
b73e				endm 
# End of macro FORTH_DSP
b73e					;v5 FORTH_DSP_VALUE 
b73e 7e					ld a,(hl)	; get type of value on TOS 
b73f fe 02				cp DS_TYPE_INUM  
b741 28 00				jr z, .less_inum 
b743			 
b743				if FORTH_ENABLE_FLOATMATH 
b743					jr .less_done 
b743			 
b743				endif 
b743					 
b743			 
b743			.less_inum: 
b743					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b743 cd c7 9b			call macro_dsp_valuehl 
b746				endm 
# End of macro FORTH_DSP_VALUEHL
b746			 
b746 e5					push hl  ; u2 
b747			 
b747					; destroy value TOS 
b747			 
b747					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b747 cd 7f 9c			call macro_forth_dsp_pop 
b74a				endm 
# End of macro FORTH_DSP_POP
b74a			 
b74a			 
b74a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b74a cd c7 9b			call macro_dsp_valuehl 
b74d				endm 
# End of macro FORTH_DSP_VALUEHL
b74d			 
b74d e5					push hl    ; u1 
b74e			 
b74e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b74e cd 7f 9c			call macro_forth_dsp_pop 
b751				endm 
# End of macro FORTH_DSP_POP
b751			 
b751			 
b751 b7			 or a      ;clear carry flag 
b752 01 00 00		 ld bc, FORTH_FALSE 
b755 e1			  pop hl    ; u1 
b756 d1			  pop de    ; u2 
b757 ed 52		  sbc hl,de 
b759 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b75b			 
b75b 01 01 00		 ld bc, FORTH_TRUE 
b75e			.lscont:  
b75e c5					push bc 
b75f e1					pop hl 
b760			 
b760					if DEBUG_FORTH_WORDS 
b760						DMARK "LT1" 
b760 f5				push af  
b761 3a 75 b7			ld a, (.dmark)  
b764 32 62 ee			ld (debug_mark),a  
b767 3a 76 b7			ld a, (.dmark+1)  
b76a 32 63 ee			ld (debug_mark+1),a  
b76d 3a 77 b7			ld a, (.dmark+2)  
b770 32 64 ee			ld (debug_mark+2),a  
b773 18 03			jr .pastdmark  
b775 ..			.dmark: db "LT1"  
b778 f1			.pastdmark: pop af  
b779			endm  
# End of macro DMARK
b779						CALLMONITOR 
b779 cd 6f ee			call debug_vector  
b77c				endm  
# End of macro CALLMONITOR
b77c					endif 
b77c cd cb 99				call forth_push_numhl 
b77f			 
b77f					NEXTW 
b77f cd 6c ee			call parse_vector 
b782 c3 ae 9d			jp macro_next 
b785				endm 
# End of macro NEXTW
b785			.GT: 
b785				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b785 30				db WORD_SYS_CORE+28             
b786 f1 b7			dw .EQUAL            
b788 02				db 1 + 1 
b789 .. 00			db ">",0              
b78b				endm 
# End of macro CWHEAD
b78b			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b78b				; TODO add floating point number detection 
b78b					if DEBUG_FORTH_WORDS_KEY 
b78b						DMARK "GRT" 
b78b f5				push af  
b78c 3a a0 b7			ld a, (.dmark)  
b78f 32 62 ee			ld (debug_mark),a  
b792 3a a1 b7			ld a, (.dmark+1)  
b795 32 63 ee			ld (debug_mark+1),a  
b798 3a a2 b7			ld a, (.dmark+2)  
b79b 32 64 ee			ld (debug_mark+2),a  
b79e 18 03			jr .pastdmark  
b7a0 ..			.dmark: db "GRT"  
b7a3 f1			.pastdmark: pop af  
b7a4			endm  
# End of macro DMARK
b7a4						CALLMONITOR 
b7a4 cd 6f ee			call debug_vector  
b7a7				endm  
# End of macro CALLMONITOR
b7a7					endif 
b7a7					FORTH_DSP 
b7a7 cd 8d 9b			call macro_forth_dsp 
b7aa				endm 
# End of macro FORTH_DSP
b7aa					;FORTH_DSP_VALUE 
b7aa 7e					ld a,(hl)	; get type of value on TOS 
b7ab fe 02				cp DS_TYPE_INUM  
b7ad 28 00				jr z, .gt_inum 
b7af			 
b7af				if FORTH_ENABLE_FLOATMATH 
b7af					jr .gt_done 
b7af			 
b7af				endif 
b7af					 
b7af			 
b7af			.gt_inum: 
b7af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7af cd c7 9b			call macro_dsp_valuehl 
b7b2				endm 
# End of macro FORTH_DSP_VALUEHL
b7b2			 
b7b2 e5					push hl  ; u2 
b7b3			 
b7b3					; destroy value TOS 
b7b3			 
b7b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7b3 cd 7f 9c			call macro_forth_dsp_pop 
b7b6				endm 
# End of macro FORTH_DSP_POP
b7b6			 
b7b6			 
b7b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b7b6 cd c7 9b			call macro_dsp_valuehl 
b7b9				endm 
# End of macro FORTH_DSP_VALUEHL
b7b9			 
b7b9 e5					push hl    ; u1 
b7ba			 
b7ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7ba cd 7f 9c			call macro_forth_dsp_pop 
b7bd				endm 
# End of macro FORTH_DSP_POP
b7bd			 
b7bd			 
b7bd b7			 or a      ;clear carry flag 
b7be 01 00 00		 ld bc, FORTH_FALSE 
b7c1 e1			  pop hl    ; u1 
b7c2 d1			  pop de    ; u2 
b7c3 ed 52		  sbc hl,de 
b7c5 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b7c7			 
b7c7 01 01 00		 ld bc, FORTH_TRUE 
b7ca			.gtcont:  
b7ca c5					push bc 
b7cb e1					pop hl 
b7cc			 
b7cc					if DEBUG_FORTH_WORDS 
b7cc						DMARK "GT1" 
b7cc f5				push af  
b7cd 3a e1 b7			ld a, (.dmark)  
b7d0 32 62 ee			ld (debug_mark),a  
b7d3 3a e2 b7			ld a, (.dmark+1)  
b7d6 32 63 ee			ld (debug_mark+1),a  
b7d9 3a e3 b7			ld a, (.dmark+2)  
b7dc 32 64 ee			ld (debug_mark+2),a  
b7df 18 03			jr .pastdmark  
b7e1 ..			.dmark: db "GT1"  
b7e4 f1			.pastdmark: pop af  
b7e5			endm  
# End of macro DMARK
b7e5						CALLMONITOR 
b7e5 cd 6f ee			call debug_vector  
b7e8				endm  
# End of macro CALLMONITOR
b7e8					endif 
b7e8 cd cb 99				call forth_push_numhl 
b7eb			 
b7eb					NEXTW 
b7eb cd 6c ee			call parse_vector 
b7ee c3 ae 9d			jp macro_next 
b7f1				endm 
# End of macro NEXTW
b7f1			.EQUAL: 
b7f1				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b7f1 31				db WORD_SYS_CORE+29             
b7f2 5f b8			dw .ENDLOGIC            
b7f4 02				db 1 + 1 
b7f5 .. 00			db "=",0              
b7f7				endm 
# End of macro CWHEAD
b7f7			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b7f7				; TODO add floating point number detection 
b7f7					if DEBUG_FORTH_WORDS_KEY 
b7f7						DMARK "EQ." 
b7f7 f5				push af  
b7f8 3a 0c b8			ld a, (.dmark)  
b7fb 32 62 ee			ld (debug_mark),a  
b7fe 3a 0d b8			ld a, (.dmark+1)  
b801 32 63 ee			ld (debug_mark+1),a  
b804 3a 0e b8			ld a, (.dmark+2)  
b807 32 64 ee			ld (debug_mark+2),a  
b80a 18 03			jr .pastdmark  
b80c ..			.dmark: db "EQ."  
b80f f1			.pastdmark: pop af  
b810			endm  
# End of macro DMARK
b810						CALLMONITOR 
b810 cd 6f ee			call debug_vector  
b813				endm  
# End of macro CALLMONITOR
b813					endif 
b813					FORTH_DSP 
b813 cd 8d 9b			call macro_forth_dsp 
b816				endm 
# End of macro FORTH_DSP
b816					;v5 FORTH_DSP_VALUE 
b816 7e					ld a,(hl)	; get type of value on TOS 
b817 fe 02				cp DS_TYPE_INUM  
b819 28 00				jr z, .eq_inum 
b81b			 
b81b				if FORTH_ENABLE_FLOATMATH 
b81b					jr .eq_done 
b81b			 
b81b				endif 
b81b					 
b81b			 
b81b			.eq_inum: 
b81b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b81b cd c7 9b			call macro_dsp_valuehl 
b81e				endm 
# End of macro FORTH_DSP_VALUEHL
b81e			 
b81e e5					push hl 
b81f			 
b81f					; destroy value TOS 
b81f			 
b81f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b81f cd 7f 9c			call macro_forth_dsp_pop 
b822				endm 
# End of macro FORTH_DSP_POP
b822			 
b822			 
b822					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b822 cd c7 9b			call macro_dsp_valuehl 
b825				endm 
# End of macro FORTH_DSP_VALUEHL
b825			 
b825					; one value on hl get other one back 
b825			 
b825 e5					push hl 
b826			 
b826					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b826 cd 7f 9c			call macro_forth_dsp_pop 
b829				endm 
# End of macro FORTH_DSP_POP
b829			 
b829 0e 00				ld c, FORTH_FALSE 
b82b			 
b82b e1					pop hl 
b82c d1					pop de 
b82d			 
b82d 7b					ld a, e 
b82e bd					cp l 
b82f			 
b82f 20 06				jr nz, .eq_done 
b831			 
b831 7a					ld a, d 
b832 bc					cp h 
b833			 
b833 20 02				jr nz, .eq_done 
b835			 
b835 0e 01				ld c, FORTH_TRUE 
b837					 
b837			 
b837			 
b837			.eq_done: 
b837			 
b837					; TODO push value back onto stack for another op etc 
b837			 
b837 26 00				ld h, 0 
b839 69					ld l, c 
b83a					if DEBUG_FORTH_WORDS 
b83a						DMARK "EQ1" 
b83a f5				push af  
b83b 3a 4f b8			ld a, (.dmark)  
b83e 32 62 ee			ld (debug_mark),a  
b841 3a 50 b8			ld a, (.dmark+1)  
b844 32 63 ee			ld (debug_mark+1),a  
b847 3a 51 b8			ld a, (.dmark+2)  
b84a 32 64 ee			ld (debug_mark+2),a  
b84d 18 03			jr .pastdmark  
b84f ..			.dmark: db "EQ1"  
b852 f1			.pastdmark: pop af  
b853			endm  
# End of macro DMARK
b853						CALLMONITOR 
b853 cd 6f ee			call debug_vector  
b856				endm  
# End of macro CALLMONITOR
b856					endif 
b856 cd cb 99				call forth_push_numhl 
b859			 
b859					NEXTW 
b859 cd 6c ee			call parse_vector 
b85c c3 ae 9d			jp macro_next 
b85f				endm 
# End of macro NEXTW
b85f			 
b85f			 
b85f			.ENDLOGIC: 
b85f			; eof 
b85f			 
b85f			 
# End of file forth_words_logic.asm
b85f			include "forth_words_maths.asm" 
b85f			 
b85f			; | ## Maths Words 
b85f			 
b85f			.PLUS:	 
b85f				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b85f 15				db WORD_SYS_CORE+1             
b860 c3 b8			dw .NEG            
b862 02				db 1 + 1 
b863 .. 00			db "+",0              
b865				endm 
# End of macro CWHEAD
b865			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b865					if DEBUG_FORTH_WORDS_KEY 
b865						DMARK "PLU" 
b865 f5				push af  
b866 3a 7a b8			ld a, (.dmark)  
b869 32 62 ee			ld (debug_mark),a  
b86c 3a 7b b8			ld a, (.dmark+1)  
b86f 32 63 ee			ld (debug_mark+1),a  
b872 3a 7c b8			ld a, (.dmark+2)  
b875 32 64 ee			ld (debug_mark+2),a  
b878 18 03			jr .pastdmark  
b87a ..			.dmark: db "PLU"  
b87d f1			.pastdmark: pop af  
b87e			endm  
# End of macro DMARK
b87e						CALLMONITOR 
b87e cd 6f ee			call debug_vector  
b881				endm  
# End of macro CALLMONITOR
b881					endif 
b881					; add top two values and push back result 
b881			 
b881					;for v5 FORTH_DSP_VALUE 
b881					FORTH_DSP 
b881 cd 8d 9b			call macro_forth_dsp 
b884				endm 
# End of macro FORTH_DSP
b884 7e					ld a,(hl)	; get type of value on TOS 
b885 fe 02				cp DS_TYPE_INUM  
b887 28 06				jr z, .dot_inum 
b889			 
b889					NEXTW 
b889 cd 6c ee			call parse_vector 
b88c c3 ae 9d			jp macro_next 
b88f				endm 
# End of macro NEXTW
b88f			 
b88f			; float maths 
b88f			 
b88f				if FORTH_ENABLE_FLOATMATH 
b88f						inc hl      ; now at start of numeric as string 
b88f			 
b88f					if DEBUG_FORTH_MATHS 
b88f						DMARK "ADD" 
b88f				CALLMONITOR 
b88f					endif 
b88f			 
b88f					;ld ix, hl 
b88f					call CON 
b88f			 
b88f			 
b88f					push hl 
b88f					 
b88f					 
b88f			 
b88f						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b88f			 
b88f					; get next number 
b88f			 
b88f						FORTH_DSP_VALUE 
b88f			 
b88f						inc hl      ; now at start of numeric as string 
b88f			 
b88f					;ld ix, hl 
b88f					call CON 
b88f			 
b88f					push hl 
b88f			 
b88f			 
b88f						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b88f			 
b88f						; TODO do add 
b88f			 
b88f						call IADD 
b88f			 
b88f						; TODO get result back as ascii 
b88f			 
b88f						; TODO push result  
b88f			 
b88f			 
b88f			 
b88f						jr .dot_done 
b88f				endif 
b88f			 
b88f			.dot_inum: 
b88f			 
b88f			 
b88f					if DEBUG_FORTH_DOT 
b88f						DMARK "+IT" 
b88f f5				push af  
b890 3a a4 b8			ld a, (.dmark)  
b893 32 62 ee			ld (debug_mark),a  
b896 3a a5 b8			ld a, (.dmark+1)  
b899 32 63 ee			ld (debug_mark+1),a  
b89c 3a a6 b8			ld a, (.dmark+2)  
b89f 32 64 ee			ld (debug_mark+2),a  
b8a2 18 03			jr .pastdmark  
b8a4 ..			.dmark: db "+IT"  
b8a7 f1			.pastdmark: pop af  
b8a8			endm  
# End of macro DMARK
b8a8				CALLMONITOR 
b8a8 cd 6f ee			call debug_vector  
b8ab				endm  
# End of macro CALLMONITOR
b8ab					endif 
b8ab			 
b8ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8ab cd c7 9b			call macro_dsp_valuehl 
b8ae				endm 
# End of macro FORTH_DSP_VALUEHL
b8ae			 
b8ae				; TODO add floating point number detection 
b8ae			 
b8ae e5					push hl 
b8af			 
b8af					; destroy value TOS 
b8af			 
b8af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8af cd 7f 9c			call macro_forth_dsp_pop 
b8b2				endm 
# End of macro FORTH_DSP_POP
b8b2			 
b8b2			 
b8b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8b2 cd c7 9b			call macro_dsp_valuehl 
b8b5				endm 
# End of macro FORTH_DSP_VALUEHL
b8b5			 
b8b5					; one value on hl get other one back 
b8b5			 
b8b5 d1					pop de 
b8b6			 
b8b6					; do the add 
b8b6			 
b8b6 19					add hl,de 
b8b7			 
b8b7					; save it 
b8b7			 
b8b7			;		push hl	 
b8b7			 
b8b7					; 
b8b7			 
b8b7					; destroy value TOS 
b8b7			 
b8b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8b7 cd 7f 9c			call macro_forth_dsp_pop 
b8ba				endm 
# End of macro FORTH_DSP_POP
b8ba			 
b8ba					; TODO push value back onto stack for another op etc 
b8ba			 
b8ba			;		pop hl 
b8ba			 
b8ba			.dot_done: 
b8ba cd cb 99				call forth_push_numhl 
b8bd			 
b8bd					NEXTW 
b8bd cd 6c ee			call parse_vector 
b8c0 c3 ae 9d			jp macro_next 
b8c3				endm 
# End of macro NEXTW
b8c3			.NEG: 
b8c3			 
b8c3				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b8c3 17				db WORD_SYS_CORE+3             
b8c4 0c b9			dw .DIV            
b8c6 02				db 1 + 1 
b8c7 .. 00			db "-",0              
b8c9				endm 
# End of macro CWHEAD
b8c9			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b8c9					if DEBUG_FORTH_WORDS_KEY 
b8c9						DMARK "SUB" 
b8c9 f5				push af  
b8ca 3a de b8			ld a, (.dmark)  
b8cd 32 62 ee			ld (debug_mark),a  
b8d0 3a df b8			ld a, (.dmark+1)  
b8d3 32 63 ee			ld (debug_mark+1),a  
b8d6 3a e0 b8			ld a, (.dmark+2)  
b8d9 32 64 ee			ld (debug_mark+2),a  
b8dc 18 03			jr .pastdmark  
b8de ..			.dmark: db "SUB"  
b8e1 f1			.pastdmark: pop af  
b8e2			endm  
# End of macro DMARK
b8e2						CALLMONITOR 
b8e2 cd 6f ee			call debug_vector  
b8e5				endm  
# End of macro CALLMONITOR
b8e5					endif 
b8e5			 
b8e5			 
b8e5				; TODO add floating point number detection 
b8e5					; v5 FORTH_DSP_VALUE 
b8e5					FORTH_DSP 
b8e5 cd 8d 9b			call macro_forth_dsp 
b8e8				endm 
# End of macro FORTH_DSP
b8e8 7e					ld a,(hl)	; get type of value on TOS 
b8e9 fe 02				cp DS_TYPE_INUM  
b8eb 28 06				jr z, .neg_inum 
b8ed			 
b8ed					NEXTW 
b8ed cd 6c ee			call parse_vector 
b8f0 c3 ae 9d			jp macro_next 
b8f3				endm 
# End of macro NEXTW
b8f3			 
b8f3			; float maths 
b8f3			 
b8f3				if FORTH_ENABLE_FLOATMATH 
b8f3					jr .neg_done 
b8f3			 
b8f3				endif 
b8f3					 
b8f3			 
b8f3			.neg_inum: 
b8f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8f3 cd c7 9b			call macro_dsp_valuehl 
b8f6				endm 
# End of macro FORTH_DSP_VALUEHL
b8f6			 
b8f6 e5					push hl 
b8f7			 
b8f7					; destroy value TOS 
b8f7			 
b8f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8f7 cd 7f 9c			call macro_forth_dsp_pop 
b8fa				endm 
# End of macro FORTH_DSP_POP
b8fa			 
b8fa			 
b8fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8fa cd c7 9b			call macro_dsp_valuehl 
b8fd				endm 
# End of macro FORTH_DSP_VALUEHL
b8fd			 
b8fd					; one value on hl get other one back 
b8fd			 
b8fd d1					pop de 
b8fe			 
b8fe					; do the sub 
b8fe			;		ex de, hl 
b8fe			 
b8fe ed 52				sbc hl,de 
b900			 
b900					; save it 
b900			 
b900			;		push hl	 
b900			 
b900					; 
b900			 
b900					; destroy value TOS 
b900			 
b900					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b900 cd 7f 9c			call macro_forth_dsp_pop 
b903				endm 
# End of macro FORTH_DSP_POP
b903			 
b903					; TODO push value back onto stack for another op etc 
b903			 
b903			;		pop hl 
b903			 
b903 cd cb 99				call forth_push_numhl 
b906			.neg_done: 
b906			 
b906					NEXTW 
b906 cd 6c ee			call parse_vector 
b909 c3 ae 9d			jp macro_next 
b90c				endm 
# End of macro NEXTW
b90c			.DIV: 
b90c				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b90c 18				db WORD_SYS_CORE+4             
b90d 5f b9			dw .MUL            
b90f 02				db 1 + 1 
b910 .. 00			db "/",0              
b912				endm 
# End of macro CWHEAD
b912			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b912					if DEBUG_FORTH_WORDS_KEY 
b912						DMARK "DIV" 
b912 f5				push af  
b913 3a 27 b9			ld a, (.dmark)  
b916 32 62 ee			ld (debug_mark),a  
b919 3a 28 b9			ld a, (.dmark+1)  
b91c 32 63 ee			ld (debug_mark+1),a  
b91f 3a 29 b9			ld a, (.dmark+2)  
b922 32 64 ee			ld (debug_mark+2),a  
b925 18 03			jr .pastdmark  
b927 ..			.dmark: db "DIV"  
b92a f1			.pastdmark: pop af  
b92b			endm  
# End of macro DMARK
b92b						CALLMONITOR 
b92b cd 6f ee			call debug_vector  
b92e				endm  
# End of macro CALLMONITOR
b92e					endif 
b92e				; TODO add floating point number detection 
b92e					; v5 FORTH_DSP_VALUE 
b92e					FORTH_DSP 
b92e cd 8d 9b			call macro_forth_dsp 
b931				endm 
# End of macro FORTH_DSP
b931 7e					ld a,(hl)	; get type of value on TOS 
b932 fe 02				cp DS_TYPE_INUM  
b934 28 06				jr z, .div_inum 
b936			 
b936				if FORTH_ENABLE_FLOATMATH 
b936					jr .div_done 
b936			 
b936				endif 
b936					NEXTW 
b936 cd 6c ee			call parse_vector 
b939 c3 ae 9d			jp macro_next 
b93c				endm 
# End of macro NEXTW
b93c			.div_inum: 
b93c			 
b93c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b93c cd c7 9b			call macro_dsp_valuehl 
b93f				endm 
# End of macro FORTH_DSP_VALUEHL
b93f			 
b93f e5					push hl    ; to go to bc 
b940			 
b940					; destroy value TOS 
b940			 
b940					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b940 cd 7f 9c			call macro_forth_dsp_pop 
b943				endm 
# End of macro FORTH_DSP_POP
b943			 
b943			 
b943					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b943 cd c7 9b			call macro_dsp_valuehl 
b946				endm 
# End of macro FORTH_DSP_VALUEHL
b946			 
b946					; hl to go to de 
b946			 
b946 e5					push hl 
b947			 
b947 c1					pop bc 
b948 d1					pop de		 
b949			 
b949			 
b949					if DEBUG_FORTH_MATHS 
b949						DMARK "DIV" 
b949				CALLMONITOR 
b949					endif 
b949					; one value on hl but move to a get other one back 
b949			 
b949			        
b949 cd 33 8c			call Div16 
b94c			 
b94c			;	push af	 
b94c e5				push hl 
b94d c5				push bc 
b94e			 
b94e					if DEBUG_FORTH_MATHS 
b94e						DMARK "DI1" 
b94e				CALLMONITOR 
b94e					endif 
b94e			 
b94e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b94e cd 7f 9c			call macro_forth_dsp_pop 
b951				endm 
# End of macro FORTH_DSP_POP
b951			 
b951			 
b951			 
b951 e1					pop hl    ; result 
b952			 
b952 cd cb 99				call forth_push_numhl 
b955			 
b955 e1					pop hl    ; reminder 
b956			;		ld h,0 
b956			;		ld l,d 
b956			 
b956 cd cb 99				call forth_push_numhl 
b959			.div_done: 
b959					NEXTW 
b959 cd 6c ee			call parse_vector 
b95c c3 ae 9d			jp macro_next 
b95f				endm 
# End of macro NEXTW
b95f			.MUL: 
b95f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b95f 19				db WORD_SYS_CORE+5             
b960 aa b9			dw .MIN            
b962 02				db 1 + 1 
b963 .. 00			db "*",0              
b965				endm 
# End of macro CWHEAD
b965			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b965				; TODO add floating point number detection 
b965					if DEBUG_FORTH_WORDS_KEY 
b965						DMARK "MUL" 
b965 f5				push af  
b966 3a 7a b9			ld a, (.dmark)  
b969 32 62 ee			ld (debug_mark),a  
b96c 3a 7b b9			ld a, (.dmark+1)  
b96f 32 63 ee			ld (debug_mark+1),a  
b972 3a 7c b9			ld a, (.dmark+2)  
b975 32 64 ee			ld (debug_mark+2),a  
b978 18 03			jr .pastdmark  
b97a ..			.dmark: db "MUL"  
b97d f1			.pastdmark: pop af  
b97e			endm  
# End of macro DMARK
b97e						CALLMONITOR 
b97e cd 6f ee			call debug_vector  
b981				endm  
# End of macro CALLMONITOR
b981					endif 
b981					FORTH_DSP 
b981 cd 8d 9b			call macro_forth_dsp 
b984				endm 
# End of macro FORTH_DSP
b984					; v5 FORTH_DSP_VALUE 
b984 7e					ld a,(hl)	; get type of value on TOS 
b985 fe 02				cp DS_TYPE_INUM  
b987 28 06				jr z, .mul_inum 
b989			 
b989				if FORTH_ENABLE_FLOATMATH 
b989					jr .mul_done 
b989			 
b989				endif 
b989			 
b989					NEXTW 
b989 cd 6c ee			call parse_vector 
b98c c3 ae 9d			jp macro_next 
b98f				endm 
# End of macro NEXTW
b98f			.mul_inum:	 
b98f			 
b98f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b98f cd c7 9b			call macro_dsp_valuehl 
b992				endm 
# End of macro FORTH_DSP_VALUEHL
b992			 
b992 e5					push hl 
b993			 
b993					; destroy value TOS 
b993			 
b993					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b993 cd 7f 9c			call macro_forth_dsp_pop 
b996				endm 
# End of macro FORTH_DSP_POP
b996			 
b996			 
b996					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b996 cd c7 9b			call macro_dsp_valuehl 
b999				endm 
# End of macro FORTH_DSP_VALUEHL
b999			 
b999					; one value on hl but move to a get other one back 
b999			 
b999 7d					ld a, l 
b99a			 
b99a d1					pop de 
b99b			 
b99b					; do the mull 
b99b			;		ex de, hl 
b99b			 
b99b cd 59 8c				call Mult16 
b99e					; save it 
b99e			 
b99e			;		push hl	 
b99e			 
b99e					; 
b99e			 
b99e					; destroy value TOS 
b99e			 
b99e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b99e cd 7f 9c			call macro_forth_dsp_pop 
b9a1				endm 
# End of macro FORTH_DSP_POP
b9a1			 
b9a1					; TODO push value back onto stack for another op etc 
b9a1			 
b9a1			;		pop hl 
b9a1			 
b9a1 cd cb 99				call forth_push_numhl 
b9a4			 
b9a4			.mul_done: 
b9a4					NEXTW 
b9a4 cd 6c ee			call parse_vector 
b9a7 c3 ae 9d			jp macro_next 
b9aa				endm 
# End of macro NEXTW
b9aa			 
b9aa			 
b9aa			 
b9aa			 
b9aa			.MIN: 
b9aa				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b9aa 49				db WORD_SYS_CORE+53             
b9ab 31 ba			dw .MAX            
b9ad 04				db 3 + 1 
b9ae .. 00			db "MIN",0              
b9b2				endm 
# End of macro CWHEAD
b9b2			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b9b2					if DEBUG_FORTH_WORDS_KEY 
b9b2						DMARK "MIN" 
b9b2 f5				push af  
b9b3 3a c7 b9			ld a, (.dmark)  
b9b6 32 62 ee			ld (debug_mark),a  
b9b9 3a c8 b9			ld a, (.dmark+1)  
b9bc 32 63 ee			ld (debug_mark+1),a  
b9bf 3a c9 b9			ld a, (.dmark+2)  
b9c2 32 64 ee			ld (debug_mark+2),a  
b9c5 18 03			jr .pastdmark  
b9c7 ..			.dmark: db "MIN"  
b9ca f1			.pastdmark: pop af  
b9cb			endm  
# End of macro DMARK
b9cb						CALLMONITOR 
b9cb cd 6f ee			call debug_vector  
b9ce				endm  
# End of macro CALLMONITOR
b9ce					endif 
b9ce					; get u2 
b9ce			 
b9ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9ce cd c7 9b			call macro_dsp_valuehl 
b9d1				endm 
# End of macro FORTH_DSP_VALUEHL
b9d1			 
b9d1 e5					push hl   ; u2 
b9d2			 
b9d2					; destroy value TOS 
b9d2			 
b9d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9d2 cd 7f 9c			call macro_forth_dsp_pop 
b9d5				endm 
# End of macro FORTH_DSP_POP
b9d5			 
b9d5					; get u1 
b9d5			 
b9d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9d5 cd c7 9b			call macro_dsp_valuehl 
b9d8				endm 
# End of macro FORTH_DSP_VALUEHL
b9d8			 
b9d8 e5					push hl  ; u1 
b9d9			 
b9d9					; destroy value TOS 
b9d9			 
b9d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9d9 cd 7f 9c			call macro_forth_dsp_pop 
b9dc				endm 
# End of macro FORTH_DSP_POP
b9dc			 
b9dc b7			 or a      ;clear carry flag 
b9dd e1			  pop hl    ; u1 
b9de d1			  pop de    ; u2 
b9df e5				push hl   ; saved in case hl is lowest 
b9e0 ed 52		  sbc hl,de 
b9e2 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b9e4			 
b9e4 e1				pop hl 
b9e5					if DEBUG_FORTH_WORDS 
b9e5						DMARK "MIN" 
b9e5 f5				push af  
b9e6 3a fa b9			ld a, (.dmark)  
b9e9 32 62 ee			ld (debug_mark),a  
b9ec 3a fb b9			ld a, (.dmark+1)  
b9ef 32 63 ee			ld (debug_mark+1),a  
b9f2 3a fc b9			ld a, (.dmark+2)  
b9f5 32 64 ee			ld (debug_mark+2),a  
b9f8 18 03			jr .pastdmark  
b9fa ..			.dmark: db "MIN"  
b9fd f1			.pastdmark: pop af  
b9fe			endm  
# End of macro DMARK
b9fe						CALLMONITOR 
b9fe cd 6f ee			call debug_vector  
ba01				endm  
# End of macro CALLMONITOR
ba01					endif 
ba01 cd cb 99				call forth_push_numhl 
ba04			 
ba04				       NEXTW 
ba04 cd 6c ee			call parse_vector 
ba07 c3 ae 9d			jp macro_next 
ba0a				endm 
# End of macro NEXTW
ba0a			 
ba0a			.mincont:  
ba0a c1				pop bc   ; tidy up 
ba0b eb				ex de , hl  
ba0c					if DEBUG_FORTH_WORDS 
ba0c						DMARK "MI1" 
ba0c f5				push af  
ba0d 3a 21 ba			ld a, (.dmark)  
ba10 32 62 ee			ld (debug_mark),a  
ba13 3a 22 ba			ld a, (.dmark+1)  
ba16 32 63 ee			ld (debug_mark+1),a  
ba19 3a 23 ba			ld a, (.dmark+2)  
ba1c 32 64 ee			ld (debug_mark+2),a  
ba1f 18 03			jr .pastdmark  
ba21 ..			.dmark: db "MI1"  
ba24 f1			.pastdmark: pop af  
ba25			endm  
# End of macro DMARK
ba25						CALLMONITOR 
ba25 cd 6f ee			call debug_vector  
ba28				endm  
# End of macro CALLMONITOR
ba28					endif 
ba28 cd cb 99				call forth_push_numhl 
ba2b			 
ba2b				       NEXTW 
ba2b cd 6c ee			call parse_vector 
ba2e c3 ae 9d			jp macro_next 
ba31				endm 
# End of macro NEXTW
ba31			.MAX: 
ba31				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
ba31 4a				db WORD_SYS_CORE+54             
ba32 b8 ba			dw .RND16            
ba34 04				db 3 + 1 
ba35 .. 00			db "MAX",0              
ba39				endm 
# End of macro CWHEAD
ba39			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
ba39					if DEBUG_FORTH_WORDS_KEY 
ba39						DMARK "MAX" 
ba39 f5				push af  
ba3a 3a 4e ba			ld a, (.dmark)  
ba3d 32 62 ee			ld (debug_mark),a  
ba40 3a 4f ba			ld a, (.dmark+1)  
ba43 32 63 ee			ld (debug_mark+1),a  
ba46 3a 50 ba			ld a, (.dmark+2)  
ba49 32 64 ee			ld (debug_mark+2),a  
ba4c 18 03			jr .pastdmark  
ba4e ..			.dmark: db "MAX"  
ba51 f1			.pastdmark: pop af  
ba52			endm  
# End of macro DMARK
ba52						CALLMONITOR 
ba52 cd 6f ee			call debug_vector  
ba55				endm  
# End of macro CALLMONITOR
ba55					endif 
ba55					; get u2 
ba55			 
ba55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba55 cd c7 9b			call macro_dsp_valuehl 
ba58				endm 
# End of macro FORTH_DSP_VALUEHL
ba58			 
ba58 e5					push hl   ; u2 
ba59			 
ba59					; destroy value TOS 
ba59			 
ba59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba59 cd 7f 9c			call macro_forth_dsp_pop 
ba5c				endm 
# End of macro FORTH_DSP_POP
ba5c			 
ba5c					; get u1 
ba5c			 
ba5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba5c cd c7 9b			call macro_dsp_valuehl 
ba5f				endm 
# End of macro FORTH_DSP_VALUEHL
ba5f			 
ba5f e5					push hl  ; u1 
ba60			 
ba60					; destroy value TOS 
ba60			 
ba60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba60 cd 7f 9c			call macro_forth_dsp_pop 
ba63				endm 
# End of macro FORTH_DSP_POP
ba63			 
ba63 b7			 or a      ;clear carry flag 
ba64 e1			  pop hl    ; u1 
ba65 d1			  pop de    ; u2 
ba66 e5				push hl   ; saved in case hl is lowest 
ba67 ed 52		  sbc hl,de 
ba69 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
ba6b			 
ba6b e1				pop hl 
ba6c					if DEBUG_FORTH_WORDS 
ba6c						DMARK "MAX" 
ba6c f5				push af  
ba6d 3a 81 ba			ld a, (.dmark)  
ba70 32 62 ee			ld (debug_mark),a  
ba73 3a 82 ba			ld a, (.dmark+1)  
ba76 32 63 ee			ld (debug_mark+1),a  
ba79 3a 83 ba			ld a, (.dmark+2)  
ba7c 32 64 ee			ld (debug_mark+2),a  
ba7f 18 03			jr .pastdmark  
ba81 ..			.dmark: db "MAX"  
ba84 f1			.pastdmark: pop af  
ba85			endm  
# End of macro DMARK
ba85						CALLMONITOR 
ba85 cd 6f ee			call debug_vector  
ba88				endm  
# End of macro CALLMONITOR
ba88					endif 
ba88 cd cb 99				call forth_push_numhl 
ba8b			 
ba8b				       NEXTW 
ba8b cd 6c ee			call parse_vector 
ba8e c3 ae 9d			jp macro_next 
ba91				endm 
# End of macro NEXTW
ba91			 
ba91			.maxcont:  
ba91 c1				pop bc   ; tidy up 
ba92 eb				ex de , hl  
ba93					if DEBUG_FORTH_WORDS 
ba93						DMARK "MA1" 
ba93 f5				push af  
ba94 3a a8 ba			ld a, (.dmark)  
ba97 32 62 ee			ld (debug_mark),a  
ba9a 3a a9 ba			ld a, (.dmark+1)  
ba9d 32 63 ee			ld (debug_mark+1),a  
baa0 3a aa ba			ld a, (.dmark+2)  
baa3 32 64 ee			ld (debug_mark+2),a  
baa6 18 03			jr .pastdmark  
baa8 ..			.dmark: db "MA1"  
baab f1			.pastdmark: pop af  
baac			endm  
# End of macro DMARK
baac						CALLMONITOR 
baac cd 6f ee			call debug_vector  
baaf				endm  
# End of macro CALLMONITOR
baaf					endif 
baaf cd cb 99				call forth_push_numhl 
bab2				       NEXTW 
bab2 cd 6c ee			call parse_vector 
bab5 c3 ae 9d			jp macro_next 
bab8				endm 
# End of macro NEXTW
bab8			 
bab8			.RND16: 
bab8				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
bab8 4e				db WORD_SYS_CORE+58             
bab9 ea ba			dw .RND8            
babb 06				db 5 + 1 
babc .. 00			db "RND16",0              
bac2				endm 
# End of macro CWHEAD
bac2			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
bac2					if DEBUG_FORTH_WORDS_KEY 
bac2						DMARK "R16" 
bac2 f5				push af  
bac3 3a d7 ba			ld a, (.dmark)  
bac6 32 62 ee			ld (debug_mark),a  
bac9 3a d8 ba			ld a, (.dmark+1)  
bacc 32 63 ee			ld (debug_mark+1),a  
bacf 3a d9 ba			ld a, (.dmark+2)  
bad2 32 64 ee			ld (debug_mark+2),a  
bad5 18 03			jr .pastdmark  
bad7 ..			.dmark: db "R16"  
bada f1			.pastdmark: pop af  
badb			endm  
# End of macro DMARK
badb						CALLMONITOR 
badb cd 6f ee			call debug_vector  
bade				endm  
# End of macro CALLMONITOR
bade					endif 
bade cd fd 8b				call prng16  
bae1 cd cb 99				call forth_push_numhl 
bae4				       NEXTW 
bae4 cd 6c ee			call parse_vector 
bae7 c3 ae 9d			jp macro_next 
baea				endm 
# End of macro NEXTW
baea			.RND8: 
baea				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
baea 60				db WORD_SYS_CORE+76             
baeb 22 bb			dw .RND            
baed 05				db 4 + 1 
baee .. 00			db "RND8",0              
baf3				endm 
# End of macro CWHEAD
baf3			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
baf3					if DEBUG_FORTH_WORDS_KEY 
baf3						DMARK "RN8" 
baf3 f5				push af  
baf4 3a 08 bb			ld a, (.dmark)  
baf7 32 62 ee			ld (debug_mark),a  
bafa 3a 09 bb			ld a, (.dmark+1)  
bafd 32 63 ee			ld (debug_mark+1),a  
bb00 3a 0a bb			ld a, (.dmark+2)  
bb03 32 64 ee			ld (debug_mark+2),a  
bb06 18 03			jr .pastdmark  
bb08 ..			.dmark: db "RN8"  
bb0b f1			.pastdmark: pop af  
bb0c			endm  
# End of macro DMARK
bb0c						CALLMONITOR 
bb0c cd 6f ee			call debug_vector  
bb0f				endm  
# End of macro CALLMONITOR
bb0f					endif 
bb0f 2a a0 eb				ld hl,(xrandc) 
bb12 23					inc hl 
bb13 cd 17 8c				call xrnd 
bb16 6f					ld l,a	 
bb17 26 00				ld h,0 
bb19 cd cb 99				call forth_push_numhl 
bb1c				       NEXTW 
bb1c cd 6c ee			call parse_vector 
bb1f c3 ae 9d			jp macro_next 
bb22				endm 
# End of macro NEXTW
bb22			.RND: 
bb22				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
bb22 60				db WORD_SYS_CORE+76             
bb23 2b bc			dw .ENDMATHS            
bb25 04				db 3 + 1 
bb26 .. 00			db "RND",0              
bb2a				endm 
# End of macro CWHEAD
bb2a			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
bb2a			 
bb2a					if DEBUG_FORTH_WORDS_KEY 
bb2a						DMARK "RND" 
bb2a f5				push af  
bb2b 3a 3f bb			ld a, (.dmark)  
bb2e 32 62 ee			ld (debug_mark),a  
bb31 3a 40 bb			ld a, (.dmark+1)  
bb34 32 63 ee			ld (debug_mark+1),a  
bb37 3a 41 bb			ld a, (.dmark+2)  
bb3a 32 64 ee			ld (debug_mark+2),a  
bb3d 18 03			jr .pastdmark  
bb3f ..			.dmark: db "RND"  
bb42 f1			.pastdmark: pop af  
bb43			endm  
# End of macro DMARK
bb43						CALLMONITOR 
bb43 cd 6f ee			call debug_vector  
bb46				endm  
# End of macro CALLMONITOR
bb46					endif 
bb46					 
bb46					FORTH_DSP_VALUEHL    ; upper range 
bb46 cd c7 9b			call macro_dsp_valuehl 
bb49				endm 
# End of macro FORTH_DSP_VALUEHL
bb49			 
bb49 22 a4 eb				ld (LFSRSeed), hl	 
bb4c			 
bb4c					if DEBUG_FORTH_WORDS 
bb4c						DMARK "RN1" 
bb4c f5				push af  
bb4d 3a 61 bb			ld a, (.dmark)  
bb50 32 62 ee			ld (debug_mark),a  
bb53 3a 62 bb			ld a, (.dmark+1)  
bb56 32 63 ee			ld (debug_mark+1),a  
bb59 3a 63 bb			ld a, (.dmark+2)  
bb5c 32 64 ee			ld (debug_mark+2),a  
bb5f 18 03			jr .pastdmark  
bb61 ..			.dmark: db "RN1"  
bb64 f1			.pastdmark: pop af  
bb65			endm  
# End of macro DMARK
bb65						CALLMONITOR 
bb65 cd 6f ee			call debug_vector  
bb68				endm  
# End of macro CALLMONITOR
bb68					endif 
bb68					FORTH_DSP_POP 
bb68 cd 7f 9c			call macro_forth_dsp_pop 
bb6b				endm 
# End of macro FORTH_DSP_POP
bb6b			 
bb6b					FORTH_DSP_VALUEHL    ; low range 
bb6b cd c7 9b			call macro_dsp_valuehl 
bb6e				endm 
# End of macro FORTH_DSP_VALUEHL
bb6e			 
bb6e					if DEBUG_FORTH_WORDS 
bb6e						DMARK "RN2" 
bb6e f5				push af  
bb6f 3a 83 bb			ld a, (.dmark)  
bb72 32 62 ee			ld (debug_mark),a  
bb75 3a 84 bb			ld a, (.dmark+1)  
bb78 32 63 ee			ld (debug_mark+1),a  
bb7b 3a 85 bb			ld a, (.dmark+2)  
bb7e 32 64 ee			ld (debug_mark+2),a  
bb81 18 03			jr .pastdmark  
bb83 ..			.dmark: db "RN2"  
bb86 f1			.pastdmark: pop af  
bb87			endm  
# End of macro DMARK
bb87						CALLMONITOR 
bb87 cd 6f ee			call debug_vector  
bb8a				endm  
# End of macro CALLMONITOR
bb8a					endif 
bb8a 22 a6 eb				ld (LFSRSeed+2), hl 
bb8d			 
bb8d					FORTH_DSP_POP 
bb8d cd 7f 9c			call macro_forth_dsp_pop 
bb90				endm 
# End of macro FORTH_DSP_POP
bb90			 
bb90 e5					push hl 
bb91			 
bb91 e1			.inrange:	pop hl 
bb92 cd fd 8b				call prng16  
bb95					if DEBUG_FORTH_WORDS 
bb95						DMARK "RN3" 
bb95 f5				push af  
bb96 3a aa bb			ld a, (.dmark)  
bb99 32 62 ee			ld (debug_mark),a  
bb9c 3a ab bb			ld a, (.dmark+1)  
bb9f 32 63 ee			ld (debug_mark+1),a  
bba2 3a ac bb			ld a, (.dmark+2)  
bba5 32 64 ee			ld (debug_mark+2),a  
bba8 18 03			jr .pastdmark  
bbaa ..			.dmark: db "RN3"  
bbad f1			.pastdmark: pop af  
bbae			endm  
# End of macro DMARK
bbae						CALLMONITOR 
bbae cd 6f ee			call debug_vector  
bbb1				endm  
# End of macro CALLMONITOR
bbb1					endif 
bbb1					 
bbb1					; if the range is 8bit knock out the high byte 
bbb1			 
bbb1 ed 5b a4 eb			ld de, (LFSRSeed)     ; check high level 
bbb5			 
bbb5 3e 00				ld a, 0 
bbb7 ba					cp d  
bbb8 20 1e				jr nz, .hirange 
bbba 26 00				ld h, 0   ; knock it down to 8bit 
bbbc			 
bbbc					if DEBUG_FORTH_WORDS 
bbbc						DMARK "RNk" 
bbbc f5				push af  
bbbd 3a d1 bb			ld a, (.dmark)  
bbc0 32 62 ee			ld (debug_mark),a  
bbc3 3a d2 bb			ld a, (.dmark+1)  
bbc6 32 63 ee			ld (debug_mark+1),a  
bbc9 3a d3 bb			ld a, (.dmark+2)  
bbcc 32 64 ee			ld (debug_mark+2),a  
bbcf 18 03			jr .pastdmark  
bbd1 ..			.dmark: db "RNk"  
bbd4 f1			.pastdmark: pop af  
bbd5			endm  
# End of macro DMARK
bbd5						CALLMONITOR 
bbd5 cd 6f ee			call debug_vector  
bbd8				endm  
# End of macro CALLMONITOR
bbd8					endif 
bbd8			.hirange:   
bbd8 e5					push hl  
bbd9 b7					or a  
bbda ed 52		                sbc hl, de 
bbdc			 
bbdc					;call cmp16 
bbdc			 
bbdc 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
bbde e1					pop hl 
bbdf e5					push hl 
bbe0			 
bbe0					if DEBUG_FORTH_WORDS 
bbe0						DMARK "RN4" 
bbe0 f5				push af  
bbe1 3a f5 bb			ld a, (.dmark)  
bbe4 32 62 ee			ld (debug_mark),a  
bbe7 3a f6 bb			ld a, (.dmark+1)  
bbea 32 63 ee			ld (debug_mark+1),a  
bbed 3a f7 bb			ld a, (.dmark+2)  
bbf0 32 64 ee			ld (debug_mark+2),a  
bbf3 18 03			jr .pastdmark  
bbf5 ..			.dmark: db "RN4"  
bbf8 f1			.pastdmark: pop af  
bbf9			endm  
# End of macro DMARK
bbf9						CALLMONITOR 
bbf9 cd 6f ee			call debug_vector  
bbfc				endm  
# End of macro CALLMONITOR
bbfc					endif 
bbfc ed 5b a6 eb			ld de, (LFSRSeed+2)   ; check low range 
bc00					;call cmp16 
bc00				 
bc00 b7					or a  
bc01 ed 52		                sbc hl, de 
bc03 38 8c				jr c, .inrange 
bc05			 
bc05 e1					pop hl 
bc06					 
bc06					if DEBUG_FORTH_WORDS 
bc06						DMARK "RNd" 
bc06 f5				push af  
bc07 3a 1b bc			ld a, (.dmark)  
bc0a 32 62 ee			ld (debug_mark),a  
bc0d 3a 1c bc			ld a, (.dmark+1)  
bc10 32 63 ee			ld (debug_mark+1),a  
bc13 3a 1d bc			ld a, (.dmark+2)  
bc16 32 64 ee			ld (debug_mark+2),a  
bc19 18 03			jr .pastdmark  
bc1b ..			.dmark: db "RNd"  
bc1e f1			.pastdmark: pop af  
bc1f			endm  
# End of macro DMARK
bc1f						CALLMONITOR 
bc1f cd 6f ee			call debug_vector  
bc22				endm  
# End of macro CALLMONITOR
bc22					endif 
bc22			 
bc22			 
bc22 cd cb 99				call forth_push_numhl 
bc25				       NEXTW 
bc25 cd 6c ee			call parse_vector 
bc28 c3 ae 9d			jp macro_next 
bc2b				endm 
# End of macro NEXTW
bc2b			 
bc2b			.ENDMATHS: 
bc2b			 
bc2b			; eof 
bc2b			 
# End of file forth_words_maths.asm
bc2b			include "forth_words_display.asm" 
bc2b			 
bc2b			; | ## Display Words 
bc2b			 
bc2b			.ACT: 
bc2b			 
bc2b				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
bc2b 62				db WORD_SYS_CORE+78             
bc2c 7a bc			dw .INFO            
bc2e 07				db 6 + 1 
bc2f .. 00			db "ACTIVE",0              
bc36				endm 
# End of macro CWHEAD
bc36			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
bc36			;  
bc36			; | | To display a pulsing activity indicator in a processing loop do this... 
bc36			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
bc36			 
bc36					if DEBUG_FORTH_WORDS_KEY 
bc36						DMARK "ACT" 
bc36 f5				push af  
bc37 3a 4b bc			ld a, (.dmark)  
bc3a 32 62 ee			ld (debug_mark),a  
bc3d 3a 4c bc			ld a, (.dmark+1)  
bc40 32 63 ee			ld (debug_mark+1),a  
bc43 3a 4d bc			ld a, (.dmark+2)  
bc46 32 64 ee			ld (debug_mark+2),a  
bc49 18 03			jr .pastdmark  
bc4b ..			.dmark: db "ACT"  
bc4e f1			.pastdmark: pop af  
bc4f			endm  
# End of macro DMARK
bc4f						CALLMONITOR 
bc4f cd 6f ee			call debug_vector  
bc52				endm  
# End of macro CALLMONITOR
bc52					endif 
bc52 cd 04 8a				call active 
bc55					if DEBUG_FORTH_WORDS 
bc55						DMARK "ACp" 
bc55 f5				push af  
bc56 3a 6a bc			ld a, (.dmark)  
bc59 32 62 ee			ld (debug_mark),a  
bc5c 3a 6b bc			ld a, (.dmark+1)  
bc5f 32 63 ee			ld (debug_mark+1),a  
bc62 3a 6c bc			ld a, (.dmark+2)  
bc65 32 64 ee			ld (debug_mark+2),a  
bc68 18 03			jr .pastdmark  
bc6a ..			.dmark: db "ACp"  
bc6d f1			.pastdmark: pop af  
bc6e			endm  
# End of macro DMARK
bc6e						CALLMONITOR 
bc6e cd 6f ee			call debug_vector  
bc71				endm  
# End of macro CALLMONITOR
bc71					endif 
bc71 cd 35 9a				call forth_push_str 
bc74			 
bc74					NEXTW 
bc74 cd 6c ee			call parse_vector 
bc77 c3 ae 9d			jp macro_next 
bc7a				endm 
# End of macro NEXTW
bc7a			.INFO: 
bc7a			 
bc7a				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
bc7a 62				db WORD_SYS_CORE+78             
bc7b 9a bc			dw .ATP            
bc7d 05				db 4 + 1 
bc7e .. 00			db "INFO",0              
bc83				endm 
# End of macro CWHEAD
bc83			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
bc83					FORTH_DSP_VALUEHL 
bc83 cd c7 9b			call macro_dsp_valuehl 
bc86				endm 
# End of macro FORTH_DSP_VALUEHL
bc86			 
bc86					FORTH_DSP_POP 
bc86 cd 7f 9c			call macro_forth_dsp_pop 
bc89				endm 
# End of macro FORTH_DSP_POP
bc89			 
bc89 e5					push hl 
bc8a			 
bc8a					FORTH_DSP_VALUEHL 
bc8a cd c7 9b			call macro_dsp_valuehl 
bc8d				endm 
# End of macro FORTH_DSP_VALUEHL
bc8d			 
bc8d					FORTH_DSP_POP 
bc8d cd 7f 9c			call macro_forth_dsp_pop 
bc90				endm 
# End of macro FORTH_DSP_POP
bc90			 
bc90 d1					pop de 
bc91			 
bc91 cd 3e 8a				call info_panel 
bc94			 
bc94			 
bc94					NEXTW 
bc94 cd 6c ee			call parse_vector 
bc97 c3 ae 9d			jp macro_next 
bc9a				endm 
# End of macro NEXTW
bc9a			.ATP: 
bc9a				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
bc9a 62				db WORD_SYS_CORE+78             
bc9b 14 bd			dw .FB            
bc9d 04				db 3 + 1 
bc9e .. 00			db "AT?",0              
bca2				endm 
# End of macro CWHEAD
bca2			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
bca2					if DEBUG_FORTH_WORDS_KEY 
bca2						DMARK "AT?" 
bca2 f5				push af  
bca3 3a b7 bc			ld a, (.dmark)  
bca6 32 62 ee			ld (debug_mark),a  
bca9 3a b8 bc			ld a, (.dmark+1)  
bcac 32 63 ee			ld (debug_mark+1),a  
bcaf 3a b9 bc			ld a, (.dmark+2)  
bcb2 32 64 ee			ld (debug_mark+2),a  
bcb5 18 03			jr .pastdmark  
bcb7 ..			.dmark: db "AT?"  
bcba f1			.pastdmark: pop af  
bcbb			endm  
# End of macro DMARK
bcbb						CALLMONITOR 
bcbb cd 6f ee			call debug_vector  
bcbe				endm  
# End of macro CALLMONITOR
bcbe					endif 
bcbe 3a 55 ea				ld a, (f_cursor_ptr) 
bcc1			 
bcc1			if DEBUG_FORTH_WORDS 
bcc1				DMARK "AT?" 
bcc1 f5				push af  
bcc2 3a d6 bc			ld a, (.dmark)  
bcc5 32 62 ee			ld (debug_mark),a  
bcc8 3a d7 bc			ld a, (.dmark+1)  
bccb 32 63 ee			ld (debug_mark+1),a  
bcce 3a d8 bc			ld a, (.dmark+2)  
bcd1 32 64 ee			ld (debug_mark+2),a  
bcd4 18 03			jr .pastdmark  
bcd6 ..			.dmark: db "AT?"  
bcd9 f1			.pastdmark: pop af  
bcda			endm  
# End of macro DMARK
bcda				CALLMONITOR 
bcda cd 6f ee			call debug_vector  
bcdd				endm  
# End of macro CALLMONITOR
bcdd			endif	 
bcdd					; count the number of rows 
bcdd			 
bcdd 06 00				ld b, 0 
bcdf 4f			.atpr:		ld c, a    ; save in case we go below zero 
bce0 d6 28				sub display_cols 
bce2 f2 e8 bc				jp p, .atprunder 
bce5 04					inc b 
bce6 18 f7				jr .atpr 
bce8			.atprunder:	 
bce8			if DEBUG_FORTH_WORDS 
bce8				DMARK "A?2" 
bce8 f5				push af  
bce9 3a fd bc			ld a, (.dmark)  
bcec 32 62 ee			ld (debug_mark),a  
bcef 3a fe bc			ld a, (.dmark+1)  
bcf2 32 63 ee			ld (debug_mark+1),a  
bcf5 3a ff bc			ld a, (.dmark+2)  
bcf8 32 64 ee			ld (debug_mark+2),a  
bcfb 18 03			jr .pastdmark  
bcfd ..			.dmark: db "A?2"  
bd00 f1			.pastdmark: pop af  
bd01			endm  
# End of macro DMARK
bd01				CALLMONITOR 
bd01 cd 6f ee			call debug_vector  
bd04				endm  
# End of macro CALLMONITOR
bd04			endif	 
bd04 26 00				ld h, 0 
bd06 69					ld l, c 
bd07 cd cb 99				call forth_push_numhl 
bd0a 68					ld l, b  
bd0b cd cb 99				call forth_push_numhl 
bd0e			 
bd0e			 
bd0e				NEXTW 
bd0e cd 6c ee			call parse_vector 
bd11 c3 ae 9d			jp macro_next 
bd14				endm 
# End of macro NEXTW
bd14			 
bd14			.FB: 
bd14				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
bd14 1b				db WORD_SYS_CORE+7             
bd15 65 bd			dw .EMIT            
bd17 03				db 2 + 1 
bd18 .. 00			db "FB",0              
bd1b				endm 
# End of macro CWHEAD
bd1b			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
bd1b			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
bd1b			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
bd1b			; | | If automatic display is off then updates will not be shown until DRAW is used. 
bd1b					if DEBUG_FORTH_WORDS_KEY 
bd1b						DMARK "FB." 
bd1b f5				push af  
bd1c 3a 30 bd			ld a, (.dmark)  
bd1f 32 62 ee			ld (debug_mark),a  
bd22 3a 31 bd			ld a, (.dmark+1)  
bd25 32 63 ee			ld (debug_mark+1),a  
bd28 3a 32 bd			ld a, (.dmark+2)  
bd2b 32 64 ee			ld (debug_mark+2),a  
bd2e 18 03			jr .pastdmark  
bd30 ..			.dmark: db "FB."  
bd33 f1			.pastdmark: pop af  
bd34			endm  
# End of macro DMARK
bd34						CALLMONITOR 
bd34 cd 6f ee			call debug_vector  
bd37				endm  
# End of macro CALLMONITOR
bd37					endif 
bd37			 
bd37					FORTH_DSP_VALUEHL 
bd37 cd c7 9b			call macro_dsp_valuehl 
bd3a				endm 
# End of macro FORTH_DSP_VALUEHL
bd3a			 
bd3a 7d					ld a, l 
bd3b fe 01				cp 1 
bd3d 20 05				jr nz, .fbn1 
bd3f 21 07 ed				ld hl, display_fb1 
bd42 18 15				jr .fbset 
bd44 fe 02		.fbn1:		cp 2 
bd46 20 05				jr nz, .fbn2 
bd48 21 c5 eb				ld hl, display_fb2 
bd4b 18 0c				jr .fbset 
bd4d fe 03		.fbn2:		cp 3 
bd4f 20 05				jr nz, .fbn3 
bd51 21 66 ec				ld hl, display_fb3 
bd54 18 03				jr .fbset 
bd56			.fbn3:		 ; if invalid number select first 
bd56 21 07 ed				ld hl, display_fb1 
bd59 22 c3 eb		.fbset:		ld (display_fb_active), hl 
bd5c			 
bd5c					FORTH_DSP_POP 
bd5c cd 7f 9c			call macro_forth_dsp_pop 
bd5f				endm 
# End of macro FORTH_DSP_POP
bd5f			 
bd5f					NEXTW 
bd5f cd 6c ee			call parse_vector 
bd62 c3 ae 9d			jp macro_next 
bd65				endm 
# End of macro NEXTW
bd65			 
bd65			 
bd65			.EMIT: 
bd65				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
bd65 1b				db WORD_SYS_CORE+7             
bd66 b8 bd			dw .DOTH            
bd68 05				db 4 + 1 
bd69 .. 00			db "EMIT",0              
bd6e				endm 
# End of macro CWHEAD
bd6e			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
bd6e					; get value off TOS and display it 
bd6e			 
bd6e					if DEBUG_FORTH_WORDS_KEY 
bd6e						DMARK "EMT" 
bd6e f5				push af  
bd6f 3a 83 bd			ld a, (.dmark)  
bd72 32 62 ee			ld (debug_mark),a  
bd75 3a 84 bd			ld a, (.dmark+1)  
bd78 32 63 ee			ld (debug_mark+1),a  
bd7b 3a 85 bd			ld a, (.dmark+2)  
bd7e 32 64 ee			ld (debug_mark+2),a  
bd81 18 03			jr .pastdmark  
bd83 ..			.dmark: db "EMT"  
bd86 f1			.pastdmark: pop af  
bd87			endm  
# End of macro DMARK
bd87						CALLMONITOR 
bd87 cd 6f ee			call debug_vector  
bd8a				endm  
# End of macro CALLMONITOR
bd8a					endif 
bd8a			 
bd8a					FORTH_DSP_VALUEHL 
bd8a cd c7 9b			call macro_dsp_valuehl 
bd8d				endm 
# End of macro FORTH_DSP_VALUEHL
bd8d			 
bd8d 7d					ld a,l 
bd8e			 
bd8e					; TODO write to display 
bd8e			 
bd8e 32 b6 e4				ld (os_input), a 
bd91 3e 00				ld a, 0 
bd93 32 b7 e4				ld (os_input+1), a 
bd96					 
bd96 3a 55 ea				ld a, (f_cursor_ptr) 
bd99 11 b6 e4				ld de, os_input 
bd9c cd be 8a				call str_at_display 
bd9f			 
bd9f			 
bd9f 3a 33 ea				ld a,(cli_autodisplay) 
bda2			;		cp 0 
bda2 b7					or a 
bda3 28 03				jr z, .enoupdate 
bda5 cd ce 8a						call update_display 
bda8					.enoupdate: 
bda8			 
bda8 3a 55 ea				ld a, (f_cursor_ptr) 
bdab 3c					inc a 
bdac 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
bdaf			 
bdaf			 
bdaf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdaf cd 7f 9c			call macro_forth_dsp_pop 
bdb2				endm 
# End of macro FORTH_DSP_POP
bdb2			  
bdb2			 
bdb2					NEXTW 
bdb2 cd 6c ee			call parse_vector 
bdb5 c3 ae 9d			jp macro_next 
bdb8				endm 
# End of macro NEXTW
bdb8			.DOTH: 
bdb8				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bdb8 1c				db WORD_SYS_CORE+8             
bdb9 eb bd			dw .DOTF            
bdbb 03				db 2 + 1 
bdbc .. 00			db ".-",0              
bdbf				endm 
# End of macro CWHEAD
bdbf			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bdbf					; get value off TOS and display it 
bdbf					if DEBUG_FORTH_WORDS_KEY 
bdbf						DMARK "DTD" 
bdbf f5				push af  
bdc0 3a d4 bd			ld a, (.dmark)  
bdc3 32 62 ee			ld (debug_mark),a  
bdc6 3a d5 bd			ld a, (.dmark+1)  
bdc9 32 63 ee			ld (debug_mark+1),a  
bdcc 3a d6 bd			ld a, (.dmark+2)  
bdcf 32 64 ee			ld (debug_mark+2),a  
bdd2 18 03			jr .pastdmark  
bdd4 ..			.dmark: db "DTD"  
bdd7 f1			.pastdmark: pop af  
bdd8			endm  
# End of macro DMARK
bdd8						CALLMONITOR 
bdd8 cd 6f ee			call debug_vector  
bddb				endm  
# End of macro CALLMONITOR
bddb					endif 
bddb 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bddd 3e 00			ld a, 0 
bddf 32 34 ea			ld (cli_mvdot), a 
bde2 c3 45 be			jp .dotgo 
bde5				NEXTW 
bde5 cd 6c ee			call parse_vector 
bde8 c3 ae 9d			jp macro_next 
bdeb				endm 
# End of macro NEXTW
bdeb			.DOTF: 
bdeb				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
bdeb 1c				db WORD_SYS_CORE+8             
bdec 1c be			dw .DOT            
bdee 03				db 2 + 1 
bdef .. 00			db ".>",0              
bdf2				endm 
# End of macro CWHEAD
bdf2			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
bdf2					; get value off TOS and display it 
bdf2			        ; TODO BUG adds extra spaces 
bdf2			        ; TODO BUG handle numerics? 
bdf2					if DEBUG_FORTH_WORDS_KEY 
bdf2						DMARK "DTC" 
bdf2 f5				push af  
bdf3 3a 07 be			ld a, (.dmark)  
bdf6 32 62 ee			ld (debug_mark),a  
bdf9 3a 08 be			ld a, (.dmark+1)  
bdfc 32 63 ee			ld (debug_mark+1),a  
bdff 3a 09 be			ld a, (.dmark+2)  
be02 32 64 ee			ld (debug_mark+2),a  
be05 18 03			jr .pastdmark  
be07 ..			.dmark: db "DTC"  
be0a f1			.pastdmark: pop af  
be0b			endm  
# End of macro DMARK
be0b						CALLMONITOR 
be0b cd 6f ee			call debug_vector  
be0e				endm  
# End of macro CALLMONITOR
be0e					endif 
be0e 3e 01			ld a, 1 
be10 32 34 ea			ld (cli_mvdot), a 
be13 c3 45 be			jp .dotgo 
be16				NEXTW 
be16 cd 6c ee			call parse_vector 
be19 c3 ae 9d			jp macro_next 
be1c				endm 
# End of macro NEXTW
be1c			 
be1c			.DOT: 
be1c				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
be1c 1c				db WORD_SYS_CORE+8             
be1d f7 bf			dw .CLS            
be1f 02				db 1 + 1 
be20 .. 00			db ".",0              
be22				endm 
# End of macro CWHEAD
be22			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
be22					; get value off TOS and display it 
be22			 
be22					if DEBUG_FORTH_WORDS_KEY 
be22						DMARK "DOT" 
be22 f5				push af  
be23 3a 37 be			ld a, (.dmark)  
be26 32 62 ee			ld (debug_mark),a  
be29 3a 38 be			ld a, (.dmark+1)  
be2c 32 63 ee			ld (debug_mark+1),a  
be2f 3a 39 be			ld a, (.dmark+2)  
be32 32 64 ee			ld (debug_mark+2),a  
be35 18 03			jr .pastdmark  
be37 ..			.dmark: db "DOT"  
be3a f1			.pastdmark: pop af  
be3b			endm  
# End of macro DMARK
be3b						CALLMONITOR 
be3b cd 6f ee			call debug_vector  
be3e				endm  
# End of macro CALLMONITOR
be3e					endif 
be3e 3e 00			ld a, 0 
be40 32 34 ea			ld (cli_mvdot), a 
be43 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
be45				 
be45			 
be45			.dotgo: 
be45			 
be45			; move up type to on stack for parserv5 
be45					FORTH_DSP 
be45 cd 8d 9b			call macro_forth_dsp 
be48				endm 
# End of macro FORTH_DSP
be48				;FORTH_DSP_VALUE  
be48			 
be48			if DEBUG_FORTH_DOT 
be48				DMARK "DOT" 
be48 f5				push af  
be49 3a 5d be			ld a, (.dmark)  
be4c 32 62 ee			ld (debug_mark),a  
be4f 3a 5e be			ld a, (.dmark+1)  
be52 32 63 ee			ld (debug_mark+1),a  
be55 3a 5f be			ld a, (.dmark+2)  
be58 32 64 ee			ld (debug_mark+2),a  
be5b 18 03			jr .pastdmark  
be5d ..			.dmark: db "DOT"  
be60 f1			.pastdmark: pop af  
be61			endm  
# End of macro DMARK
be61				CALLMONITOR 
be61 cd 6f ee			call debug_vector  
be64				endm  
# End of macro CALLMONITOR
be64			endif	 
be64			;		.print: 
be64			 
be64 7e				ld a,(hl)  ; work out what type of value is on the TOS 
be65 23				inc hl   ; position to the actual value 
be66 fe 01			cp DS_TYPE_STR 
be68 20 06			jr nz, .dotnum1  
be6a			 
be6a			; display string 
be6a				FORTH_DSP_VALUE  
be6a cd b0 9b			call macro_forth_dsp_value 
be6d				endm 
# End of macro FORTH_DSP_VALUE
be6d eb				ex de,hl 
be6e 18 49			jr .dotwrite 
be70			 
be70			.dotnum1: 
be70 fe 02			cp DS_TYPE_INUM 
be72 20 44			jr nz, .dotflot 
be74			 
be74			 
be74			; display number 
be74			 
be74			;	push hl 
be74			;	call clear_display 
be74			;	pop hl 
be74			 
be74 5e				ld e, (hl) 
be75 23				inc hl 
be76 56				ld d, (hl) 
be77 21 b8 e2			ld hl, scratch 
be7a			if DEBUG_FORTH_DOT 
be7a				DMARK "DT1" 
be7a f5				push af  
be7b 3a 8f be			ld a, (.dmark)  
be7e 32 62 ee			ld (debug_mark),a  
be81 3a 90 be			ld a, (.dmark+1)  
be84 32 63 ee			ld (debug_mark+1),a  
be87 3a 91 be			ld a, (.dmark+2)  
be8a 32 64 ee			ld (debug_mark+2),a  
be8d 18 03			jr .pastdmark  
be8f ..			.dmark: db "DT1"  
be92 f1			.pastdmark: pop af  
be93			endm  
# End of macro DMARK
be93				CALLMONITOR 
be93 cd 6f ee			call debug_vector  
be96				endm  
# End of macro CALLMONITOR
be96			endif	 
be96			 
be96 cd dd 8f			call uitoa_16 
be99 eb				ex de,hl 
be9a			 
be9a			if DEBUG_FORTH_DOT 
be9a				DMARK "DT2" 
be9a f5				push af  
be9b 3a af be			ld a, (.dmark)  
be9e 32 62 ee			ld (debug_mark),a  
bea1 3a b0 be			ld a, (.dmark+1)  
bea4 32 63 ee			ld (debug_mark+1),a  
bea7 3a b1 be			ld a, (.dmark+2)  
beaa 32 64 ee			ld (debug_mark+2),a  
bead 18 03			jr .pastdmark  
beaf ..			.dmark: db "DT2"  
beb2 f1			.pastdmark: pop af  
beb3			endm  
# End of macro DMARK
beb3				CALLMONITOR 
beb3 cd 6f ee			call debug_vector  
beb6				endm  
# End of macro CALLMONITOR
beb6			endif	 
beb6			 
beb6			;	ld de, os_word_scratch 
beb6 18 01			jr .dotwrite 
beb8			 
beb8 00			.dotflot:   nop 
beb9			; TODO print floating point number 
beb9			 
beb9			.dotwrite:		 
beb9			 
beb9					; if c is set then set all '-' to spaces 
beb9					; need to also take into account .>  
beb9			 
beb9 3e 01				ld a, 1 
bebb b9					cp c 
bebc 20 65				jr nz, .nodashswap 
bebe			 
bebe					; DE has the string to write, working with HL 
bebe			 
bebe 06 ff				ld b, 255 
bec0 d5					push de 
bec1 e1					pop hl 
bec2			 
bec2			if DEBUG_FORTH_DOT 
bec2				DMARK "DT-" 
bec2 f5				push af  
bec3 3a d7 be			ld a, (.dmark)  
bec6 32 62 ee			ld (debug_mark),a  
bec9 3a d8 be			ld a, (.dmark+1)  
becc 32 63 ee			ld (debug_mark+1),a  
becf 3a d9 be			ld a, (.dmark+2)  
bed2 32 64 ee			ld (debug_mark+2),a  
bed5 18 03			jr .pastdmark  
bed7 ..			.dmark: db "DT-"  
beda f1			.pastdmark: pop af  
bedb			endm  
# End of macro DMARK
bedb				CALLMONITOR 
bedb cd 6f ee			call debug_vector  
bede				endm  
# End of macro CALLMONITOR
bede			endif	 
bede 7e			.dashscan:	ld a, (hl) 
bedf			;		cp 0 
bedf b7					or a 
bee0 28 41				jr z, .nodashswap 
bee2 fe 2d				cp '-' 
bee4 20 02				jr nz, .dashskip 
bee6			;		ld a, ' ' 
bee6 36 20				ld (hl), ' ' 
bee8 23			.dashskip:	inc hl 
bee9			if DEBUG_FORTH_DOT 
bee9				DMARK "D-2" 
bee9 f5				push af  
beea 3a fe be			ld a, (.dmark)  
beed 32 62 ee			ld (debug_mark),a  
bef0 3a ff be			ld a, (.dmark+1)  
bef3 32 63 ee			ld (debug_mark+1),a  
bef6 3a 00 bf			ld a, (.dmark+2)  
bef9 32 64 ee			ld (debug_mark+2),a  
befc 18 03			jr .pastdmark  
befe ..			.dmark: db "D-2"  
bf01 f1			.pastdmark: pop af  
bf02			endm  
# End of macro DMARK
bf02				CALLMONITOR 
bf02 cd 6f ee			call debug_vector  
bf05				endm  
# End of macro CALLMONITOR
bf05			endif	 
bf05 10 d7				djnz .dashscan 
bf07			 
bf07			if DEBUG_FORTH_DOT 
bf07				DMARK "D-1" 
bf07 f5				push af  
bf08 3a 1c bf			ld a, (.dmark)  
bf0b 32 62 ee			ld (debug_mark),a  
bf0e 3a 1d bf			ld a, (.dmark+1)  
bf11 32 63 ee			ld (debug_mark+1),a  
bf14 3a 1e bf			ld a, (.dmark+2)  
bf17 32 64 ee			ld (debug_mark+2),a  
bf1a 18 03			jr .pastdmark  
bf1c ..			.dmark: db "D-1"  
bf1f f1			.pastdmark: pop af  
bf20			endm  
# End of macro DMARK
bf20				CALLMONITOR 
bf20 cd 6f ee			call debug_vector  
bf23				endm  
# End of macro CALLMONITOR
bf23			endif	 
bf23			 
bf23			.nodashswap: 
bf23			 
bf23			if DEBUG_FORTH_DOT 
bf23				DMARK "D-o" 
bf23 f5				push af  
bf24 3a 38 bf			ld a, (.dmark)  
bf27 32 62 ee			ld (debug_mark),a  
bf2a 3a 39 bf			ld a, (.dmark+1)  
bf2d 32 63 ee			ld (debug_mark+1),a  
bf30 3a 3a bf			ld a, (.dmark+2)  
bf33 32 64 ee			ld (debug_mark+2),a  
bf36 18 03			jr .pastdmark  
bf38 ..			.dmark: db "D-o"  
bf3b f1			.pastdmark: pop af  
bf3c			endm  
# End of macro DMARK
bf3c				CALLMONITOR 
bf3c cd 6f ee			call debug_vector  
bf3f				endm  
# End of macro CALLMONITOR
bf3f			endif	 
bf3f			 
bf3f d5					push de   ; save string start in case we need to advance print 
bf40			 
bf40 3a 55 ea				ld a, (f_cursor_ptr) 
bf43 cd be 8a				call str_at_display 
bf46 3a 33 ea				ld a,(cli_autodisplay) 
bf49			;		cp 0 
bf49 b7					or a 
bf4a 28 03				jr z, .noupdate 
bf4c cd ce 8a						call update_display 
bf4f					.noupdate: 
bf4f			 
bf4f			 
bf4f					; see if we need to advance the print position 
bf4f			 
bf4f e1					pop hl   ; get back string 
bf50			;		ex de,hl 
bf50			 
bf50 3a 34 ea				ld a, (cli_mvdot) 
bf53			if DEBUG_FORTH_DOT 
bf53			;		ld e,a 
bf53				DMARK "D>1" 
bf53 f5				push af  
bf54 3a 68 bf			ld a, (.dmark)  
bf57 32 62 ee			ld (debug_mark),a  
bf5a 3a 69 bf			ld a, (.dmark+1)  
bf5d 32 63 ee			ld (debug_mark+1),a  
bf60 3a 6a bf			ld a, (.dmark+2)  
bf63 32 64 ee			ld (debug_mark+2),a  
bf66 18 03			jr .pastdmark  
bf68 ..			.dmark: db "D>1"  
bf6b f1			.pastdmark: pop af  
bf6c			endm  
# End of macro DMARK
bf6c				CALLMONITOR 
bf6c cd 6f ee			call debug_vector  
bf6f				endm  
# End of macro CALLMONITOR
bf6f			endif	 
bf6f			;		cp 0 
bf6f b7					or a 
bf70 28 44				jr z, .noadv 
bf72					; yes, lets advance the print position 
bf72 3e 00				ld a, 0 
bf74 cd 39 90				call strlent 
bf77			if DEBUG_FORTH_DOT 
bf77				DMARK "D-?" 
bf77 f5				push af  
bf78 3a 8c bf			ld a, (.dmark)  
bf7b 32 62 ee			ld (debug_mark),a  
bf7e 3a 8d bf			ld a, (.dmark+1)  
bf81 32 63 ee			ld (debug_mark+1),a  
bf84 3a 8e bf			ld a, (.dmark+2)  
bf87 32 64 ee			ld (debug_mark+2),a  
bf8a 18 03			jr .pastdmark  
bf8c ..			.dmark: db "D-?"  
bf8f f1			.pastdmark: pop af  
bf90			endm  
# End of macro DMARK
bf90				CALLMONITOR 
bf90 cd 6f ee			call debug_vector  
bf93				endm  
# End of macro CALLMONITOR
bf93			endif	 
bf93 3a 55 ea				ld a, (f_cursor_ptr) 
bf96 85					add a,l 
bf97					;call addatohl 
bf97					;ld a, l 
bf97 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
bf9a			 
bf9a			if DEBUG_FORTH_DOT 
bf9a				DMARK "D->" 
bf9a f5				push af  
bf9b 3a af bf			ld a, (.dmark)  
bf9e 32 62 ee			ld (debug_mark),a  
bfa1 3a b0 bf			ld a, (.dmark+1)  
bfa4 32 63 ee			ld (debug_mark+1),a  
bfa7 3a b1 bf			ld a, (.dmark+2)  
bfaa 32 64 ee			ld (debug_mark+2),a  
bfad 18 03			jr .pastdmark  
bfaf ..			.dmark: db "D->"  
bfb2 f1			.pastdmark: pop af  
bfb3			endm  
# End of macro DMARK
bfb3				CALLMONITOR 
bfb3 cd 6f ee			call debug_vector  
bfb6				endm  
# End of macro CALLMONITOR
bfb6			endif	 
bfb6			 
bfb6			.noadv:	 
bfb6			 
bfb6					if DEBUG_FORTH_DOT_WAIT 
bfb6							call next_page_prompt 
bfb6					endif	 
bfb6			; TODO this pop off the stack causes a crash. i dont know why 
bfb6			 
bfb6			 
bfb6			if DEBUG_FORTH_DOT 
bfb6				DMARK "DTh" 
bfb6 f5				push af  
bfb7 3a cb bf			ld a, (.dmark)  
bfba 32 62 ee			ld (debug_mark),a  
bfbd 3a cc bf			ld a, (.dmark+1)  
bfc0 32 63 ee			ld (debug_mark+1),a  
bfc3 3a cd bf			ld a, (.dmark+2)  
bfc6 32 64 ee			ld (debug_mark+2),a  
bfc9 18 03			jr .pastdmark  
bfcb ..			.dmark: db "DTh"  
bfce f1			.pastdmark: pop af  
bfcf			endm  
# End of macro DMARK
bfcf				CALLMONITOR 
bfcf cd 6f ee			call debug_vector  
bfd2				endm  
# End of macro CALLMONITOR
bfd2			endif	 
bfd2			 
bfd2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfd2 cd 7f 9c			call macro_forth_dsp_pop 
bfd5				endm 
# End of macro FORTH_DSP_POP
bfd5			 
bfd5			if DEBUG_FORTH_DOT 
bfd5				DMARK "DTi" 
bfd5 f5				push af  
bfd6 3a ea bf			ld a, (.dmark)  
bfd9 32 62 ee			ld (debug_mark),a  
bfdc 3a eb bf			ld a, (.dmark+1)  
bfdf 32 63 ee			ld (debug_mark+1),a  
bfe2 3a ec bf			ld a, (.dmark+2)  
bfe5 32 64 ee			ld (debug_mark+2),a  
bfe8 18 03			jr .pastdmark  
bfea ..			.dmark: db "DTi"  
bfed f1			.pastdmark: pop af  
bfee			endm  
# End of macro DMARK
bfee				CALLMONITOR 
bfee cd 6f ee			call debug_vector  
bff1				endm  
# End of macro CALLMONITOR
bff1			endif	 
bff1			 
bff1			 
bff1					NEXTW 
bff1 cd 6c ee			call parse_vector 
bff4 c3 ae 9d			jp macro_next 
bff7				endm 
# End of macro NEXTW
bff7			 
bff7			.CLS: 
bff7				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bff7 35				db WORD_SYS_CORE+33             
bff8 27 c0			dw .DRAW            
bffa 04				db 3 + 1 
bffb .. 00			db "CLS",0              
bfff				endm 
# End of macro CWHEAD
bfff			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bfff					if DEBUG_FORTH_WORDS_KEY 
bfff						DMARK "CLS" 
bfff f5				push af  
c000 3a 14 c0			ld a, (.dmark)  
c003 32 62 ee			ld (debug_mark),a  
c006 3a 15 c0			ld a, (.dmark+1)  
c009 32 63 ee			ld (debug_mark+1),a  
c00c 3a 16 c0			ld a, (.dmark+2)  
c00f 32 64 ee			ld (debug_mark+2),a  
c012 18 03			jr .pastdmark  
c014 ..			.dmark: db "CLS"  
c017 f1			.pastdmark: pop af  
c018			endm  
# End of macro DMARK
c018						CALLMONITOR 
c018 cd 6f ee			call debug_vector  
c01b				endm  
# End of macro CALLMONITOR
c01b					endif 
c01b cd ac 8a				call clear_display 
c01e c3 41 c1				jp .home		; and home cursor 
c021					NEXTW 
c021 cd 6c ee			call parse_vector 
c024 c3 ae 9d			jp macro_next 
c027				endm 
# End of macro NEXTW
c027			 
c027			.DRAW: 
c027				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
c027 36				db WORD_SYS_CORE+34             
c028 55 c0			dw .DUMP            
c02a 05				db 4 + 1 
c02b .. 00			db "DRAW",0              
c030				endm 
# End of macro CWHEAD
c030			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
c030					if DEBUG_FORTH_WORDS_KEY 
c030						DMARK "DRW" 
c030 f5				push af  
c031 3a 45 c0			ld a, (.dmark)  
c034 32 62 ee			ld (debug_mark),a  
c037 3a 46 c0			ld a, (.dmark+1)  
c03a 32 63 ee			ld (debug_mark+1),a  
c03d 3a 47 c0			ld a, (.dmark+2)  
c040 32 64 ee			ld (debug_mark+2),a  
c043 18 03			jr .pastdmark  
c045 ..			.dmark: db "DRW"  
c048 f1			.pastdmark: pop af  
c049			endm  
# End of macro DMARK
c049						CALLMONITOR 
c049 cd 6f ee			call debug_vector  
c04c				endm  
# End of macro CALLMONITOR
c04c					endif 
c04c cd ce 8a				call update_display 
c04f					NEXTW 
c04f cd 6c ee			call parse_vector 
c052 c3 ae 9d			jp macro_next 
c055				endm 
# End of macro NEXTW
c055			 
c055			.DUMP: 
c055				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
c055 37				db WORD_SYS_CORE+35             
c056 90 c0			dw .CDUMP            
c058 05				db 4 + 1 
c059 .. 00			db "DUMP",0              
c05e				endm 
# End of macro CWHEAD
c05e			; | DUMP ( x -- ) With address x display dump   | DONE 
c05e			; TODO pop address to use off of the stack 
c05e					if DEBUG_FORTH_WORDS_KEY 
c05e						DMARK "DUM" 
c05e f5				push af  
c05f 3a 73 c0			ld a, (.dmark)  
c062 32 62 ee			ld (debug_mark),a  
c065 3a 74 c0			ld a, (.dmark+1)  
c068 32 63 ee			ld (debug_mark+1),a  
c06b 3a 75 c0			ld a, (.dmark+2)  
c06e 32 64 ee			ld (debug_mark+2),a  
c071 18 03			jr .pastdmark  
c073 ..			.dmark: db "DUM"  
c076 f1			.pastdmark: pop af  
c077			endm  
# End of macro DMARK
c077						CALLMONITOR 
c077 cd 6f ee			call debug_vector  
c07a				endm  
# End of macro CALLMONITOR
c07a					endif 
c07a cd ac 8a				call clear_display 
c07d			 
c07d					; get address 
c07d			 
c07d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c07d cd c7 9b			call macro_dsp_valuehl 
c080				endm 
# End of macro FORTH_DSP_VALUEHL
c080				 
c080					; save it for cdump 
c080			 
c080 22 db e5				ld (os_cur_ptr),hl 
c083			 
c083					; destroy value TOS 
c083			 
c083					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c083 cd 7f 9c			call macro_forth_dsp_pop 
c086				endm 
# End of macro FORTH_DSP_POP
c086			 
c086 cd 4f 98				call dumpcont	; skip old style of param parsing	 
c089 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
c08a					NEXTW 
c08a cd 6c ee			call parse_vector 
c08d c3 ae 9d			jp macro_next 
c090				endm 
# End of macro NEXTW
c090			.CDUMP: 
c090				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
c090 38				db WORD_SYS_CORE+36             
c091 c3 c0			dw .DAT            
c093 06				db 5 + 1 
c094 .. 00			db "CDUMP",0              
c09a				endm 
# End of macro CWHEAD
c09a			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
c09a					if DEBUG_FORTH_WORDS_KEY 
c09a						DMARK "CDP" 
c09a f5				push af  
c09b 3a af c0			ld a, (.dmark)  
c09e 32 62 ee			ld (debug_mark),a  
c0a1 3a b0 c0			ld a, (.dmark+1)  
c0a4 32 63 ee			ld (debug_mark+1),a  
c0a7 3a b1 c0			ld a, (.dmark+2)  
c0aa 32 64 ee			ld (debug_mark+2),a  
c0ad 18 03			jr .pastdmark  
c0af ..			.dmark: db "CDP"  
c0b2 f1			.pastdmark: pop af  
c0b3			endm  
# End of macro DMARK
c0b3						CALLMONITOR 
c0b3 cd 6f ee			call debug_vector  
c0b6				endm  
# End of macro CALLMONITOR
c0b6					endif 
c0b6 cd ac 8a				call clear_display 
c0b9 cd 4f 98				call dumpcont	 
c0bc c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
c0bd					NEXTW 
c0bd cd 6c ee			call parse_vector 
c0c0 c3 ae 9d			jp macro_next 
c0c3				endm 
# End of macro NEXTW
c0c3			 
c0c3			 
c0c3			 
c0c3			 
c0c3			.DAT: 
c0c3				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
c0c3 3d				db WORD_SYS_CORE+41             
c0c4 1c c1			dw .HOME            
c0c6 03				db 2 + 1 
c0c7 .. 00			db "AT",0              
c0ca				endm 
# End of macro CWHEAD
c0ca			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
c0ca					if DEBUG_FORTH_WORDS_KEY 
c0ca						DMARK "AT." 
c0ca f5				push af  
c0cb 3a df c0			ld a, (.dmark)  
c0ce 32 62 ee			ld (debug_mark),a  
c0d1 3a e0 c0			ld a, (.dmark+1)  
c0d4 32 63 ee			ld (debug_mark+1),a  
c0d7 3a e1 c0			ld a, (.dmark+2)  
c0da 32 64 ee			ld (debug_mark+2),a  
c0dd 18 03			jr .pastdmark  
c0df ..			.dmark: db "AT."  
c0e2 f1			.pastdmark: pop af  
c0e3			endm  
# End of macro DMARK
c0e3						CALLMONITOR 
c0e3 cd 6f ee			call debug_vector  
c0e6				endm  
# End of macro CALLMONITOR
c0e6					endif 
c0e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c0e6 cd c7 9b			call macro_dsp_valuehl 
c0e9				endm 
# End of macro FORTH_DSP_VALUEHL
c0e9			 
c0e9			 
c0e9					; TODO save cursor row 
c0e9 7d					ld a,l 
c0ea fe 02				cp 2 
c0ec 20 04				jr nz, .crow3 
c0ee 3e 28				ld a, display_row_2 
c0f0 18 12				jr .ccol1 
c0f2 fe 03		.crow3:		cp 3 
c0f4 20 04				jr nz, .crow4 
c0f6 3e 50				ld a, display_row_3 
c0f8 18 0a				jr .ccol1 
c0fa fe 04		.crow4:		cp 4 
c0fc 20 04				jr nz, .crow1 
c0fe 3e 78				ld a, display_row_4 
c100 18 02				jr .ccol1 
c102 3e 00		.crow1:		ld a,display_row_1 
c104 f5			.ccol1:		push af			; got row offset 
c105 6f					ld l,a 
c106 26 00				ld h,0 
c108					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c108 cd 7f 9c			call macro_forth_dsp_pop 
c10b				endm 
# End of macro FORTH_DSP_POP
c10b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c10b cd c7 9b			call macro_dsp_valuehl 
c10e				endm 
# End of macro FORTH_DSP_VALUEHL
c10e					; TODO save cursor col 
c10e f1					pop af 
c10f 85					add l		; add col offset 
c110 32 55 ea				ld (f_cursor_ptr), a 
c113					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c113 cd 7f 9c			call macro_forth_dsp_pop 
c116				endm 
# End of macro FORTH_DSP_POP
c116			 
c116					; calculate  
c116			 
c116					NEXTW 
c116 cd 6c ee			call parse_vector 
c119 c3 ae 9d			jp macro_next 
c11c				endm 
# End of macro NEXTW
c11c			 
c11c			 
c11c			.HOME: 
c11c				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
c11c 41				db WORD_SYS_CORE+45             
c11d 4c c1			dw .CR            
c11f 05				db 4 + 1 
c120 .. 00			db "HOME",0              
c125				endm 
# End of macro CWHEAD
c125			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
c125					if DEBUG_FORTH_WORDS_KEY 
c125						DMARK "HOM" 
c125 f5				push af  
c126 3a 3a c1			ld a, (.dmark)  
c129 32 62 ee			ld (debug_mark),a  
c12c 3a 3b c1			ld a, (.dmark+1)  
c12f 32 63 ee			ld (debug_mark+1),a  
c132 3a 3c c1			ld a, (.dmark+2)  
c135 32 64 ee			ld (debug_mark+2),a  
c138 18 03			jr .pastdmark  
c13a ..			.dmark: db "HOM"  
c13d f1			.pastdmark: pop af  
c13e			endm  
# End of macro DMARK
c13e						CALLMONITOR 
c13e cd 6f ee			call debug_vector  
c141				endm  
# End of macro CALLMONITOR
c141					endif 
c141 3e 00		.home:		ld a, 0		; and home cursor 
c143 32 55 ea				ld (f_cursor_ptr), a 
c146					NEXTW 
c146 cd 6c ee			call parse_vector 
c149 c3 ae 9d			jp macro_next 
c14c				endm 
# End of macro NEXTW
c14c			 
c14c			 
c14c			.CR: 
c14c				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
c14c 46				db WORD_SYS_CORE+50             
c14d 8a c1			dw .SPACE            
c14f 03				db 2 + 1 
c150 .. 00			db "CR",0              
c153				endm 
# End of macro CWHEAD
c153			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
c153					if DEBUG_FORTH_WORDS_KEY 
c153						DMARK "CR." 
c153 f5				push af  
c154 3a 68 c1			ld a, (.dmark)  
c157 32 62 ee			ld (debug_mark),a  
c15a 3a 69 c1			ld a, (.dmark+1)  
c15d 32 63 ee			ld (debug_mark+1),a  
c160 3a 6a c1			ld a, (.dmark+2)  
c163 32 64 ee			ld (debug_mark+2),a  
c166 18 03			jr .pastdmark  
c168 ..			.dmark: db "CR."  
c16b f1			.pastdmark: pop af  
c16c			endm  
# End of macro DMARK
c16c						CALLMONITOR 
c16c cd 6f ee			call debug_vector  
c16f				endm  
# End of macro CALLMONITOR
c16f					endif 
c16f 3e 0d				ld a, 13 
c171 32 b8 e2				ld (scratch),a 
c174 3e 0a				ld a, 10 
c176 32 b9 e2				ld (scratch+1),a 
c179 3e 00				ld a, 0 
c17b 32 ba e2				ld (scratch+2),a 
c17e 21 b8 e2				ld hl, scratch 
c181 cd 35 9a				call forth_push_str 
c184					 
c184				       NEXTW 
c184 cd 6c ee			call parse_vector 
c187 c3 ae 9d			jp macro_next 
c18a				endm 
# End of macro NEXTW
c18a			.SPACE: 
c18a				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
c18a 46				db WORD_SYS_CORE+50             
c18b c3 c1			dw .SPACES            
c18d 03				db 2 + 1 
c18e .. 00			db "BL",0              
c191				endm 
# End of macro CWHEAD
c191			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
c191					if DEBUG_FORTH_WORDS_KEY 
c191						DMARK "BL." 
c191 f5				push af  
c192 3a a6 c1			ld a, (.dmark)  
c195 32 62 ee			ld (debug_mark),a  
c198 3a a7 c1			ld a, (.dmark+1)  
c19b 32 63 ee			ld (debug_mark+1),a  
c19e 3a a8 c1			ld a, (.dmark+2)  
c1a1 32 64 ee			ld (debug_mark+2),a  
c1a4 18 03			jr .pastdmark  
c1a6 ..			.dmark: db "BL."  
c1a9 f1			.pastdmark: pop af  
c1aa			endm  
# End of macro DMARK
c1aa						CALLMONITOR 
c1aa cd 6f ee			call debug_vector  
c1ad				endm  
# End of macro CALLMONITOR
c1ad					endif 
c1ad 3e 20				ld a, " " 
c1af 32 b8 e2				ld (scratch),a 
c1b2 3e 00				ld a, 0 
c1b4 32 b9 e2				ld (scratch+1),a 
c1b7 21 b8 e2				ld hl, scratch 
c1ba cd 35 9a				call forth_push_str 
c1bd					 
c1bd				       NEXTW 
c1bd cd 6c ee			call parse_vector 
c1c0 c3 ae 9d			jp macro_next 
c1c3				endm 
# End of macro NEXTW
c1c3			 
c1c3			;.blstr: db " ", 0 
c1c3			 
c1c3			.SPACES: 
c1c3				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
c1c3 47				db WORD_SYS_CORE+51             
c1c4 5f c2			dw .SCROLL            
c1c6 07				db 6 + 1 
c1c7 .. 00			db "SPACES",0              
c1ce				endm 
# End of macro CWHEAD
c1ce			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
c1ce					if DEBUG_FORTH_WORDS_KEY 
c1ce						DMARK "SPS" 
c1ce f5				push af  
c1cf 3a e3 c1			ld a, (.dmark)  
c1d2 32 62 ee			ld (debug_mark),a  
c1d5 3a e4 c1			ld a, (.dmark+1)  
c1d8 32 63 ee			ld (debug_mark+1),a  
c1db 3a e5 c1			ld a, (.dmark+2)  
c1de 32 64 ee			ld (debug_mark+2),a  
c1e1 18 03			jr .pastdmark  
c1e3 ..			.dmark: db "SPS"  
c1e6 f1			.pastdmark: pop af  
c1e7			endm  
# End of macro DMARK
c1e7						CALLMONITOR 
c1e7 cd 6f ee			call debug_vector  
c1ea				endm  
# End of macro CALLMONITOR
c1ea					endif 
c1ea			 
c1ea			 
c1ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c1ea cd c7 9b			call macro_dsp_valuehl 
c1ed				endm 
# End of macro FORTH_DSP_VALUEHL
c1ed			 
c1ed e5					push hl    ; u 
c1ee					if DEBUG_FORTH_WORDS 
c1ee						DMARK "SPA" 
c1ee f5				push af  
c1ef 3a 03 c2			ld a, (.dmark)  
c1f2 32 62 ee			ld (debug_mark),a  
c1f5 3a 04 c2			ld a, (.dmark+1)  
c1f8 32 63 ee			ld (debug_mark+1),a  
c1fb 3a 05 c2			ld a, (.dmark+2)  
c1fe 32 64 ee			ld (debug_mark+2),a  
c201 18 03			jr .pastdmark  
c203 ..			.dmark: db "SPA"  
c206 f1			.pastdmark: pop af  
c207			endm  
# End of macro DMARK
c207						CALLMONITOR 
c207 cd 6f ee			call debug_vector  
c20a				endm  
# End of macro CALLMONITOR
c20a					endif 
c20a			 
c20a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c20a cd 7f 9c			call macro_forth_dsp_pop 
c20d				endm 
# End of macro FORTH_DSP_POP
c20d e1					pop hl 
c20e 0e 00				ld c, 0 
c210 45					ld b, l 
c211 21 b8 e2				ld hl, scratch  
c214			 
c214					if DEBUG_FORTH_WORDS 
c214						DMARK "SP2" 
c214 f5				push af  
c215 3a 29 c2			ld a, (.dmark)  
c218 32 62 ee			ld (debug_mark),a  
c21b 3a 2a c2			ld a, (.dmark+1)  
c21e 32 63 ee			ld (debug_mark+1),a  
c221 3a 2b c2			ld a, (.dmark+2)  
c224 32 64 ee			ld (debug_mark+2),a  
c227 18 03			jr .pastdmark  
c229 ..			.dmark: db "SP2"  
c22c f1			.pastdmark: pop af  
c22d			endm  
# End of macro DMARK
c22d						CALLMONITOR 
c22d cd 6f ee			call debug_vector  
c230				endm  
# End of macro CALLMONITOR
c230					endif 
c230			;		ld a, ' ' 
c230			.spaces1:	 
c230 36 20				ld (hl),' ' 
c232 23					inc hl 
c233					 
c233 10 fb				djnz .spaces1 
c235			;		ld a,0 
c235 36 00				ld (hl),0 
c237 21 b8 e2				ld hl, scratch 
c23a					if DEBUG_FORTH_WORDS 
c23a						DMARK "SP3" 
c23a f5				push af  
c23b 3a 4f c2			ld a, (.dmark)  
c23e 32 62 ee			ld (debug_mark),a  
c241 3a 50 c2			ld a, (.dmark+1)  
c244 32 63 ee			ld (debug_mark+1),a  
c247 3a 51 c2			ld a, (.dmark+2)  
c24a 32 64 ee			ld (debug_mark+2),a  
c24d 18 03			jr .pastdmark  
c24f ..			.dmark: db "SP3"  
c252 f1			.pastdmark: pop af  
c253			endm  
# End of macro DMARK
c253						CALLMONITOR 
c253 cd 6f ee			call debug_vector  
c256				endm  
# End of macro CALLMONITOR
c256					endif 
c256 cd 35 9a				call forth_push_str 
c259			 
c259				       NEXTW 
c259 cd 6c ee			call parse_vector 
c25c c3 ae 9d			jp macro_next 
c25f				endm 
# End of macro NEXTW
c25f			 
c25f			 
c25f			 
c25f			.SCROLL: 
c25f				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
c25f 53				db WORD_SYS_CORE+63             
c260 8f c2			dw .SCROLLD            
c262 07				db 6 + 1 
c263 .. 00			db "SCROLL",0              
c26a				endm 
# End of macro CWHEAD
c26a			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
c26a					if DEBUG_FORTH_WORDS_KEY 
c26a						DMARK "SCR" 
c26a f5				push af  
c26b 3a 7f c2			ld a, (.dmark)  
c26e 32 62 ee			ld (debug_mark),a  
c271 3a 80 c2			ld a, (.dmark+1)  
c274 32 63 ee			ld (debug_mark+1),a  
c277 3a 81 c2			ld a, (.dmark+2)  
c27a 32 64 ee			ld (debug_mark+2),a  
c27d 18 03			jr .pastdmark  
c27f ..			.dmark: db "SCR"  
c282 f1			.pastdmark: pop af  
c283			endm  
# End of macro DMARK
c283						CALLMONITOR 
c283 cd 6f ee			call debug_vector  
c286				endm  
# End of macro CALLMONITOR
c286					endif 
c286			 
c286 cd 6f 8a			call scroll_up 
c289			;	call update_display 
c289			 
c289					NEXTW 
c289 cd 6c ee			call parse_vector 
c28c c3 ae 9d			jp macro_next 
c28f				endm 
# End of macro NEXTW
c28f			 
c28f			 
c28f			 
c28f			;		; get dir 
c28f			; 
c28f			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c28f			; 
c28f			;		push hl 
c28f			; 
c28f			;		; destroy value TOS 
c28f			; 
c28f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c28f			; 
c28f			;		; get count 
c28f			; 
c28f			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c28f			; 
c28f			;		push hl 
c28f			; 
c28f			;		; destroy value TOS 
c28f			; 
c28f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c28f			; 
c28f			;		; one value on hl get other one back 
c28f			; 
c28f			;		pop bc    ; count 
c28f			; 
c28f			;		pop de   ; dir 
c28f			; 
c28f			; 
c28f			;		ld b, c 
c28f			; 
c28f			;.scrolldir:     push bc 
c28f			;		push de 
c28f			; 
c28f			;		ld a, 0 
c28f			;		cp e 
c28f			;		jr z, .scrollup  
c28f			;		call scroll_down 
c28f			;		jr .scrollnext 
c28f			;.scrollup:	call scroll_up 
c28f			; 
c28f			;		 
c28f			;.scrollnext: 
c28f			;		pop de 
c28f			;		pop bc 
c28f			;		djnz .scrolldir 
c28f			; 
c28f			; 
c28f			; 
c28f			; 
c28f			; 
c28f			;		NEXTW 
c28f			 
c28f			.SCROLLD: 
c28f				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
c28f 53				db WORD_SYS_CORE+63             
c290 c0 c2			dw .ATQ            
c292 08				db 7 + 1 
c293 .. 00			db "SCROLLD",0              
c29b				endm 
# End of macro CWHEAD
c29b			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
c29b					if DEBUG_FORTH_WORDS_KEY 
c29b						DMARK "SCD" 
c29b f5				push af  
c29c 3a b0 c2			ld a, (.dmark)  
c29f 32 62 ee			ld (debug_mark),a  
c2a2 3a b1 c2			ld a, (.dmark+1)  
c2a5 32 63 ee			ld (debug_mark+1),a  
c2a8 3a b2 c2			ld a, (.dmark+2)  
c2ab 32 64 ee			ld (debug_mark+2),a  
c2ae 18 03			jr .pastdmark  
c2b0 ..			.dmark: db "SCD"  
c2b3 f1			.pastdmark: pop af  
c2b4			endm  
# End of macro DMARK
c2b4						CALLMONITOR 
c2b4 cd 6f ee			call debug_vector  
c2b7				endm  
# End of macro CALLMONITOR
c2b7					endif 
c2b7			 
c2b7 cd 92 8a			call scroll_down 
c2ba			;	call update_display 
c2ba			 
c2ba					NEXTW 
c2ba cd 6c ee			call parse_vector 
c2bd c3 ae 9d			jp macro_next 
c2c0				endm 
# End of macro NEXTW
c2c0			 
c2c0			 
c2c0			.ATQ: 
c2c0				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
c2c0 62				db WORD_SYS_CORE+78             
c2c1 21 c3			dw .AUTODSP            
c2c3 04				db 3 + 1 
c2c4 .. 00			db "AT@",0              
c2c8				endm 
# End of macro CWHEAD
c2c8			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
c2c8					if DEBUG_FORTH_WORDS_KEY 
c2c8						DMARK "ATA" 
c2c8 f5				push af  
c2c9 3a dd c2			ld a, (.dmark)  
c2cc 32 62 ee			ld (debug_mark),a  
c2cf 3a de c2			ld a, (.dmark+1)  
c2d2 32 63 ee			ld (debug_mark+1),a  
c2d5 3a df c2			ld a, (.dmark+2)  
c2d8 32 64 ee			ld (debug_mark+2),a  
c2db 18 03			jr .pastdmark  
c2dd ..			.dmark: db "ATA"  
c2e0 f1			.pastdmark: pop af  
c2e1			endm  
# End of macro DMARK
c2e1						CALLMONITOR 
c2e1 cd 6f ee			call debug_vector  
c2e4				endm  
# End of macro CALLMONITOR
c2e4					endif 
c2e4			 
c2e4			 
c2e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2e4 cd c7 9b			call macro_dsp_valuehl 
c2e7				endm 
# End of macro FORTH_DSP_VALUEHL
c2e7			 
c2e7					; TODO save cursor row 
c2e7 7d					ld a,l 
c2e8 fe 02				cp 2 
c2ea 20 04				jr nz, .crow3aq 
c2ec 3e 28				ld a, display_row_2 
c2ee 18 12				jr .ccol1aq 
c2f0 fe 03		.crow3aq:		cp 3 
c2f2 20 04				jr nz, .crow4aq 
c2f4 3e 50				ld a, display_row_3 
c2f6 18 0a				jr .ccol1aq 
c2f8 fe 04		.crow4aq:		cp 4 
c2fa 20 04				jr nz, .crow1aq 
c2fc 3e 78				ld a, display_row_4 
c2fe 18 02				jr .ccol1aq 
c300 3e 00		.crow1aq:		ld a,display_row_1 
c302 f5			.ccol1aq:		push af			; got row offset 
c303 6f					ld l,a 
c304 26 00				ld h,0 
c306					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c306 cd 7f 9c			call macro_forth_dsp_pop 
c309				endm 
# End of macro FORTH_DSP_POP
c309					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c309 cd c7 9b			call macro_dsp_valuehl 
c30c				endm 
# End of macro FORTH_DSP_VALUEHL
c30c					; TODO save cursor col 
c30c f1					pop af 
c30d 85					add l		; add col offset 
c30e			 
c30e					; add current frame buffer address 
c30e 2a c3 eb				ld hl, (display_fb_active) 
c311 cd d6 8c				call addatohl 
c314			 
c314			 
c314			 
c314			 
c314					; get char frame buffer location offset in hl 
c314			 
c314 7e					ld a,(hl) 
c315 26 00				ld h, 0 
c317 6f					ld l, a 
c318			 
c318 cd cb 99				call forth_push_numhl 
c31b			 
c31b			 
c31b					NEXTW 
c31b cd 6c ee			call parse_vector 
c31e c3 ae 9d			jp macro_next 
c321				endm 
# End of macro NEXTW
c321			 
c321			.AUTODSP: 
c321				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
c321 63				db WORD_SYS_CORE+79             
c322 3a c3			dw .MENU            
c324 05				db 4 + 1 
c325 .. 00			db "ADSP",0              
c32a				endm 
# End of macro CWHEAD
c32a			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
c32a			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
c32a			 
c32a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c32a cd c7 9b			call macro_dsp_valuehl 
c32d				endm 
# End of macro FORTH_DSP_VALUEHL
c32d			 
c32d			;		push hl 
c32d			 
c32d					; destroy value TOS 
c32d			 
c32d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c32d cd 7f 9c			call macro_forth_dsp_pop 
c330				endm 
# End of macro FORTH_DSP_POP
c330			 
c330			;		pop hl 
c330			 
c330 7d					ld a,l 
c331 32 33 ea				ld (cli_autodisplay), a 
c334				       NEXTW 
c334 cd 6c ee			call parse_vector 
c337 c3 ae 9d			jp macro_next 
c33a				endm 
# End of macro NEXTW
c33a			 
c33a			.MENU: 
c33a				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
c33a 70				db WORD_SYS_CORE+92             
c33b e6 c3			dw .ENDDISPLAY            
c33d 05				db 4 + 1 
c33e .. 00			db "MENU",0              
c343				endm 
# End of macro CWHEAD
c343			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
c343			 
c343			;		; get number of items on the stack 
c343			; 
c343				 
c343					FORTH_DSP_VALUEHL 
c343 cd c7 9b			call macro_dsp_valuehl 
c346				endm 
# End of macro FORTH_DSP_VALUEHL
c346				 
c346					if DEBUG_FORTH_WORDS_KEY 
c346						DMARK "MNU" 
c346 f5				push af  
c347 3a 5b c3			ld a, (.dmark)  
c34a 32 62 ee			ld (debug_mark),a  
c34d 3a 5c c3			ld a, (.dmark+1)  
c350 32 63 ee			ld (debug_mark+1),a  
c353 3a 5d c3			ld a, (.dmark+2)  
c356 32 64 ee			ld (debug_mark+2),a  
c359 18 03			jr .pastdmark  
c35b ..			.dmark: db "MNU"  
c35e f1			.pastdmark: pop af  
c35f			endm  
# End of macro DMARK
c35f						CALLMONITOR 
c35f cd 6f ee			call debug_vector  
c362				endm  
# End of macro CALLMONITOR
c362					endif 
c362			 
c362 45					ld b, l	 
c363 05					dec b 
c364			 
c364					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c364 cd 7f 9c			call macro_forth_dsp_pop 
c367				endm 
# End of macro FORTH_DSP_POP
c367			 
c367			 
c367					; go directly through the stack to pluck out the string pointers and build an array 
c367			 
c367			;		FORTH_DSP 
c367			 
c367					; hl contains top most stack item 
c367				 
c367 11 b8 e2				ld de, scratch 
c36a			 
c36a			.mbuild: 
c36a			 
c36a					FORTH_DSP_VALUEHL 
c36a cd c7 9b			call macro_dsp_valuehl 
c36d				endm 
# End of macro FORTH_DSP_VALUEHL
c36d			 
c36d					if DEBUG_FORTH_WORDS 
c36d						DMARK "MN3" 
c36d f5				push af  
c36e 3a 82 c3			ld a, (.dmark)  
c371 32 62 ee			ld (debug_mark),a  
c374 3a 83 c3			ld a, (.dmark+1)  
c377 32 63 ee			ld (debug_mark+1),a  
c37a 3a 84 c3			ld a, (.dmark+2)  
c37d 32 64 ee			ld (debug_mark+2),a  
c380 18 03			jr .pastdmark  
c382 ..			.dmark: db "MN3"  
c385 f1			.pastdmark: pop af  
c386			endm  
# End of macro DMARK
c386						CALLMONITOR 
c386 cd 6f ee			call debug_vector  
c389				endm  
# End of macro CALLMONITOR
c389					endif 
c389 eb					ex de, hl 
c38a 73					ld (hl), e 
c38b 23					inc hl 
c38c 72					ld (hl), d 
c38d 23					inc hl 
c38e eb					ex de, hl 
c38f			 
c38f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c38f cd 7f 9c			call macro_forth_dsp_pop 
c392				endm 
# End of macro FORTH_DSP_POP
c392			 
c392 10 d6				djnz .mbuild 
c394			 
c394					; done add term 
c394			 
c394 eb					ex de, hl 
c395 36 00				ld (hl), 0 
c397 23					inc hl 
c398 36 00				ld (hl), 0 
c39a			 
c39a				 
c39a					 
c39a 21 b8 e2				ld hl, scratch 
c39d			 
c39d					if DEBUG_FORTH_WORDS 
c39d						DMARK "MNx" 
c39d f5				push af  
c39e 3a b2 c3			ld a, (.dmark)  
c3a1 32 62 ee			ld (debug_mark),a  
c3a4 3a b3 c3			ld a, (.dmark+1)  
c3a7 32 63 ee			ld (debug_mark+1),a  
c3aa 3a b4 c3			ld a, (.dmark+2)  
c3ad 32 64 ee			ld (debug_mark+2),a  
c3b0 18 03			jr .pastdmark  
c3b2 ..			.dmark: db "MNx"  
c3b5 f1			.pastdmark: pop af  
c3b6			endm  
# End of macro DMARK
c3b6						CALLMONITOR 
c3b6 cd 6f ee			call debug_vector  
c3b9				endm  
# End of macro CALLMONITOR
c3b9					endif 
c3b9			 
c3b9			 
c3b9			 
c3b9 3e 00				ld a, 0 
c3bb cd dc 8a				call menu 
c3be			 
c3be			 
c3be 6f					ld l, a 
c3bf 26 00				ld h, 0 
c3c1			 
c3c1					if DEBUG_FORTH_WORDS 
c3c1						DMARK "MNr" 
c3c1 f5				push af  
c3c2 3a d6 c3			ld a, (.dmark)  
c3c5 32 62 ee			ld (debug_mark),a  
c3c8 3a d7 c3			ld a, (.dmark+1)  
c3cb 32 63 ee			ld (debug_mark+1),a  
c3ce 3a d8 c3			ld a, (.dmark+2)  
c3d1 32 64 ee			ld (debug_mark+2),a  
c3d4 18 03			jr .pastdmark  
c3d6 ..			.dmark: db "MNr"  
c3d9 f1			.pastdmark: pop af  
c3da			endm  
# End of macro DMARK
c3da						CALLMONITOR 
c3da cd 6f ee			call debug_vector  
c3dd				endm  
# End of macro CALLMONITOR
c3dd					endif 
c3dd			 
c3dd cd cb 99				call forth_push_numhl 
c3e0			 
c3e0			 
c3e0			 
c3e0			 
c3e0				       NEXTW 
c3e0 cd 6c ee			call parse_vector 
c3e3 c3 ae 9d			jp macro_next 
c3e6				endm 
# End of macro NEXTW
c3e6			 
c3e6			 
c3e6			.ENDDISPLAY: 
c3e6			 
c3e6			; eof 
# End of file forth_words_display.asm
c3e6			include "forth_words_str.asm" 
c3e6			 
c3e6			; | ## String Words 
c3e6			 
c3e6			.SPLIT:   
c3e6			 
c3e6				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
c3e6 48				db WORD_SYS_CORE+52             
c3e7 dd c4			dw .PTR            
c3e9 06				db 5 + 1 
c3ea .. 00			db "SPLIT",0              
c3f0				endm 
# End of macro CWHEAD
c3f0			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
c3f0					if DEBUG_FORTH_WORDS_KEY 
c3f0						DMARK "SPT" 
c3f0 f5				push af  
c3f1 3a 05 c4			ld a, (.dmark)  
c3f4 32 62 ee			ld (debug_mark),a  
c3f7 3a 06 c4			ld a, (.dmark+1)  
c3fa 32 63 ee			ld (debug_mark+1),a  
c3fd 3a 07 c4			ld a, (.dmark+2)  
c400 32 64 ee			ld (debug_mark+2),a  
c403 18 03			jr .pastdmark  
c405 ..			.dmark: db "SPT"  
c408 f1			.pastdmark: pop af  
c409			endm  
# End of macro DMARK
c409						CALLMONITOR 
c409 cd 6f ee			call debug_vector  
c40c				endm  
# End of macro CALLMONITOR
c40c					endif 
c40c			 
c40c					; get delim 
c40c					FORTH_DSP_VALUEHL 
c40c cd c7 9b			call macro_dsp_valuehl 
c40f				endm 
# End of macro FORTH_DSP_VALUEHL
c40f			 
c40f					FORTH_DSP_POP 
c40f cd 7f 9c			call macro_forth_dsp_pop 
c412				endm 
# End of macro FORTH_DSP_POP
c412					 
c412			 
c412 45					ld b, l    ; move delim to b 
c413 0e 01				ld c, 1   ; count of poritions 
c415			 
c415 c5					push bc 
c416			 
c416					if DEBUG_FORTH_WORDS 
c416						DMARK "SPa" 
c416 f5				push af  
c417 3a 2b c4			ld a, (.dmark)  
c41a 32 62 ee			ld (debug_mark),a  
c41d 3a 2c c4			ld a, (.dmark+1)  
c420 32 63 ee			ld (debug_mark+1),a  
c423 3a 2d c4			ld a, (.dmark+2)  
c426 32 64 ee			ld (debug_mark+2),a  
c429 18 03			jr .pastdmark  
c42b ..			.dmark: db "SPa"  
c42e f1			.pastdmark: pop af  
c42f			endm  
# End of macro DMARK
c42f						CALLMONITOR 
c42f cd 6f ee			call debug_vector  
c432				endm  
# End of macro CALLMONITOR
c432					endif 
c432					; get pointer to string to chop up 
c432					FORTH_DSP_VALUEHL 
c432 cd c7 9b			call macro_dsp_valuehl 
c435				endm 
# End of macro FORTH_DSP_VALUEHL
c435			 
c435			;		push hl 
c435 11 b8 e2				ld de, scratch 
c438			.spllop: 
c438 c1					pop bc 
c439 c5					push bc 
c43a			;		pop hl 
c43a					if DEBUG_FORTH_WORDS 
c43a						DMARK "SPl" 
c43a f5				push af  
c43b 3a 4f c4			ld a, (.dmark)  
c43e 32 62 ee			ld (debug_mark),a  
c441 3a 50 c4			ld a, (.dmark+1)  
c444 32 63 ee			ld (debug_mark+1),a  
c447 3a 51 c4			ld a, (.dmark+2)  
c44a 32 64 ee			ld (debug_mark+2),a  
c44d 18 03			jr .pastdmark  
c44f ..			.dmark: db "SPl"  
c452 f1			.pastdmark: pop af  
c453			endm  
# End of macro DMARK
c453						CALLMONITOR 
c453 cd 6f ee			call debug_vector  
c456				endm  
# End of macro CALLMONITOR
c456					endif 
c456 7e					ld a, (hl) 
c457 b8					cp b 
c458 28 07				jr z, .splnxt 
c45a			;		cp 0 
c45a b7					or a 
c45b 28 34				jr z, .splend 
c45d ed a0				ldi 
c45f 18 d7				jr .spllop 
c461			 
c461					; hit dlim 
c461			 
c461			.splnxt: 
c461					if DEBUG_FORTH_WORDS 
c461						DMARK "SPx" 
c461 f5				push af  
c462 3a 76 c4			ld a, (.dmark)  
c465 32 62 ee			ld (debug_mark),a  
c468 3a 77 c4			ld a, (.dmark+1)  
c46b 32 63 ee			ld (debug_mark+1),a  
c46e 3a 78 c4			ld a, (.dmark+2)  
c471 32 64 ee			ld (debug_mark+2),a  
c474 18 03			jr .pastdmark  
c476 ..			.dmark: db "SPx"  
c479 f1			.pastdmark: pop af  
c47a			endm  
# End of macro DMARK
c47a						CALLMONITOR 
c47a cd 6f ee			call debug_vector  
c47d				endm  
# End of macro CALLMONITOR
c47d					endif 
c47d 3e 00				ld a, 0 
c47f 12					ld (de), a 
c480					;ex de, hl 
c480 e5					push hl 
c481 21 b8 e2				ld hl, scratch 
c484 cd 35 9a				call forth_push_str 
c487 e1					pop hl 
c488					;ex de, hl 
c488 23					inc hl 
c489 c1					pop bc 
c48a 0c					inc c 
c48b c5					push bc 
c48c 11 b8 e2				ld de, scratch 
c48f 18 a7				jr .spllop 
c491			 
c491			.splend:		 
c491					if DEBUG_FORTH_WORDS 
c491						DMARK "SPe" 
c491 f5				push af  
c492 3a a6 c4			ld a, (.dmark)  
c495 32 62 ee			ld (debug_mark),a  
c498 3a a7 c4			ld a, (.dmark+1)  
c49b 32 63 ee			ld (debug_mark+1),a  
c49e 3a a8 c4			ld a, (.dmark+2)  
c4a1 32 64 ee			ld (debug_mark+2),a  
c4a4 18 03			jr .pastdmark  
c4a6 ..			.dmark: db "SPe"  
c4a9 f1			.pastdmark: pop af  
c4aa			endm  
# End of macro DMARK
c4aa						CALLMONITOR 
c4aa cd 6f ee			call debug_vector  
c4ad				endm  
# End of macro CALLMONITOR
c4ad					endif 
c4ad 12					ld (de), a 
c4ae eb					ex de, hl 
c4af			;		push hl 
c4af 21 b8 e2				ld hl, scratch 
c4b2 cd 35 9a				call forth_push_str 
c4b5					 
c4b5					if DEBUG_FORTH_WORDS 
c4b5						DMARK "SPc" 
c4b5 f5				push af  
c4b6 3a ca c4			ld a, (.dmark)  
c4b9 32 62 ee			ld (debug_mark),a  
c4bc 3a cb c4			ld a, (.dmark+1)  
c4bf 32 63 ee			ld (debug_mark+1),a  
c4c2 3a cc c4			ld a, (.dmark+2)  
c4c5 32 64 ee			ld (debug_mark+2),a  
c4c8 18 03			jr .pastdmark  
c4ca ..			.dmark: db "SPc"  
c4cd f1			.pastdmark: pop af  
c4ce			endm  
# End of macro DMARK
c4ce						CALLMONITOR 
c4ce cd 6f ee			call debug_vector  
c4d1				endm  
# End of macro CALLMONITOR
c4d1					endif 
c4d1			 
c4d1 e1					pop hl    ; get counter from bc which has been push 
c4d2 26 00				ld h, 0 
c4d4			;		ld l, c 
c4d4 cd cb 99				call forth_push_numhl 
c4d7			 
c4d7			 
c4d7				NEXTW 
c4d7 cd 6c ee			call parse_vector 
c4da c3 ae 9d			jp macro_next 
c4dd				endm 
# End of macro NEXTW
c4dd			.PTR:   
c4dd			 
c4dd				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c4dd 48				db WORD_SYS_CORE+52             
c4de 0d c5			dw .STYPE            
c4e0 04				db 3 + 1 
c4e1 .. 00			db "PTR",0              
c4e5				endm 
# End of macro CWHEAD
c4e5			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c4e5			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c4e5			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c4e5			 
c4e5					if DEBUG_FORTH_WORDS_KEY 
c4e5						DMARK "PTR" 
c4e5 f5				push af  
c4e6 3a fa c4			ld a, (.dmark)  
c4e9 32 62 ee			ld (debug_mark),a  
c4ec 3a fb c4			ld a, (.dmark+1)  
c4ef 32 63 ee			ld (debug_mark+1),a  
c4f2 3a fc c4			ld a, (.dmark+2)  
c4f5 32 64 ee			ld (debug_mark+2),a  
c4f8 18 03			jr .pastdmark  
c4fa ..			.dmark: db "PTR"  
c4fd f1			.pastdmark: pop af  
c4fe			endm  
# End of macro DMARK
c4fe						CALLMONITOR 
c4fe cd 6f ee			call debug_vector  
c501				endm  
# End of macro CALLMONITOR
c501					endif 
c501					FORTH_DSP_VALUEHL 
c501 cd c7 9b			call macro_dsp_valuehl 
c504				endm 
# End of macro FORTH_DSP_VALUEHL
c504 cd cb 99				call forth_push_numhl 
c507			 
c507			 
c507					NEXTW 
c507 cd 6c ee			call parse_vector 
c50a c3 ae 9d			jp macro_next 
c50d				endm 
# End of macro NEXTW
c50d			.STYPE: 
c50d				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c50d 48				db WORD_SYS_CORE+52             
c50e 5f c5			dw .UPPER            
c510 06				db 5 + 1 
c511 .. 00			db "STYPE",0              
c517				endm 
# End of macro CWHEAD
c517			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
c517			; | | 's' string or 'i' integer 
c517					if DEBUG_FORTH_WORDS_KEY 
c517						DMARK "STY" 
c517 f5				push af  
c518 3a 2c c5			ld a, (.dmark)  
c51b 32 62 ee			ld (debug_mark),a  
c51e 3a 2d c5			ld a, (.dmark+1)  
c521 32 63 ee			ld (debug_mark+1),a  
c524 3a 2e c5			ld a, (.dmark+2)  
c527 32 64 ee			ld (debug_mark+2),a  
c52a 18 03			jr .pastdmark  
c52c ..			.dmark: db "STY"  
c52f f1			.pastdmark: pop af  
c530			endm  
# End of macro DMARK
c530						CALLMONITOR 
c530 cd 6f ee			call debug_vector  
c533				endm  
# End of macro CALLMONITOR
c533					endif 
c533					FORTH_DSP 
c533 cd 8d 9b			call macro_forth_dsp 
c536				endm 
# End of macro FORTH_DSP
c536					;v5 FORTH_DSP_VALUE 
c536			 
c536 7e					ld a, (hl) 
c537			 
c537 f5					push af 
c538			 
c538			; Dont destroy TOS		FORTH_DSP_POP 
c538			 
c538 f1					pop af 
c539			 
c539 fe 01				cp DS_TYPE_STR 
c53b 28 09				jr z, .typestr 
c53d			 
c53d fe 02				cp DS_TYPE_INUM 
c53f 28 0a				jr z, .typeinum 
c541			 
c541 21 5d c5				ld hl, .tna 
c544 18 0a				jr .tpush 
c546			 
c546 21 59 c5		.typestr:	ld hl, .tstr 
c549 18 05				jr .tpush 
c54b 21 5b c5		.typeinum:	ld hl, .tinum 
c54e 18 00				jr .tpush 
c550			 
c550			.tpush: 
c550			 
c550 cd 35 9a				call forth_push_str 
c553			 
c553					NEXTW 
c553 cd 6c ee			call parse_vector 
c556 c3 ae 9d			jp macro_next 
c559				endm 
# End of macro NEXTW
c559 .. 00		.tstr:	db "s",0 
c55b .. 00		.tinum:  db "i",0 
c55d .. 00		.tna:   db "?", 0 
c55f			 
c55f			 
c55f			.UPPER: 
c55f				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c55f 48				db WORD_SYS_CORE+52             
c560 9c c5			dw .LOWER            
c562 06				db 5 + 1 
c563 .. 00			db "UPPER",0              
c569				endm 
# End of macro CWHEAD
c569			; | UPPER ( s -- s ) Upper case string s  | DONE 
c569					if DEBUG_FORTH_WORDS_KEY 
c569						DMARK "UPR" 
c569 f5				push af  
c56a 3a 7e c5			ld a, (.dmark)  
c56d 32 62 ee			ld (debug_mark),a  
c570 3a 7f c5			ld a, (.dmark+1)  
c573 32 63 ee			ld (debug_mark+1),a  
c576 3a 80 c5			ld a, (.dmark+2)  
c579 32 64 ee			ld (debug_mark+2),a  
c57c 18 03			jr .pastdmark  
c57e ..			.dmark: db "UPR"  
c581 f1			.pastdmark: pop af  
c582			endm  
# End of macro DMARK
c582						CALLMONITOR 
c582 cd 6f ee			call debug_vector  
c585				endm  
# End of macro CALLMONITOR
c585					endif 
c585			 
c585					FORTH_DSP 
c585 cd 8d 9b			call macro_forth_dsp 
c588				endm 
# End of macro FORTH_DSP
c588					 
c588			; TODO check is string type 
c588			 
c588					FORTH_DSP_VALUEHL 
c588 cd c7 9b			call macro_dsp_valuehl 
c58b				endm 
# End of macro FORTH_DSP_VALUEHL
c58b			; get pointer to string in hl 
c58b			 
c58b 7e			.toup:		ld a, (hl) 
c58c			;		cp 0 
c58c b7					or a 
c58d 28 07				jr z, .toupdone 
c58f			 
c58f cd 3e 8f				call to_upper 
c592			 
c592 77					ld (hl), a 
c593 23					inc hl 
c594 18 f5				jr .toup 
c596			 
c596					 
c596			 
c596			 
c596			; for each char convert to upper 
c596					 
c596			.toupdone: 
c596			 
c596			 
c596					NEXTW 
c596 cd 6c ee			call parse_vector 
c599 c3 ae 9d			jp macro_next 
c59c				endm 
# End of macro NEXTW
c59c			.LOWER: 
c59c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c59c 48				db WORD_SYS_CORE+52             
c59d d9 c5			dw .TCASE            
c59f 06				db 5 + 1 
c5a0 .. 00			db "LOWER",0              
c5a6				endm 
# End of macro CWHEAD
c5a6			; | LOWER ( s -- s ) Lower case string s  | DONE 
c5a6					if DEBUG_FORTH_WORDS_KEY 
c5a6						DMARK "LWR" 
c5a6 f5				push af  
c5a7 3a bb c5			ld a, (.dmark)  
c5aa 32 62 ee			ld (debug_mark),a  
c5ad 3a bc c5			ld a, (.dmark+1)  
c5b0 32 63 ee			ld (debug_mark+1),a  
c5b3 3a bd c5			ld a, (.dmark+2)  
c5b6 32 64 ee			ld (debug_mark+2),a  
c5b9 18 03			jr .pastdmark  
c5bb ..			.dmark: db "LWR"  
c5be f1			.pastdmark: pop af  
c5bf			endm  
# End of macro DMARK
c5bf						CALLMONITOR 
c5bf cd 6f ee			call debug_vector  
c5c2				endm  
# End of macro CALLMONITOR
c5c2					endif 
c5c2			 
c5c2					FORTH_DSP 
c5c2 cd 8d 9b			call macro_forth_dsp 
c5c5				endm 
# End of macro FORTH_DSP
c5c5					 
c5c5			; TODO check is string type 
c5c5			 
c5c5					FORTH_DSP_VALUEHL 
c5c5 cd c7 9b			call macro_dsp_valuehl 
c5c8				endm 
# End of macro FORTH_DSP_VALUEHL
c5c8			; get pointer to string in hl 
c5c8			 
c5c8 7e			.tolow:		ld a, (hl) 
c5c9			;		cp 0 
c5c9 b7					or a 
c5ca 28 07				jr z, .tolowdone 
c5cc			 
c5cc cd 47 8f				call to_lower 
c5cf			 
c5cf 77					ld (hl), a 
c5d0 23					inc hl 
c5d1 18 f5				jr .tolow 
c5d3			 
c5d3					 
c5d3			 
c5d3			 
c5d3			; for each char convert to low 
c5d3					 
c5d3			.tolowdone: 
c5d3					NEXTW 
c5d3 cd 6c ee			call parse_vector 
c5d6 c3 ae 9d			jp macro_next 
c5d9				endm 
# End of macro NEXTW
c5d9			.TCASE: 
c5d9				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c5d9 48				db WORD_SYS_CORE+52             
c5da 10 c7			dw .SUBSTR            
c5dc 06				db 5 + 1 
c5dd .. 00			db "TCASE",0              
c5e3				endm 
# End of macro CWHEAD
c5e3			; | TCASE ( s -- s ) Title case string s  | DONE 
c5e3					if DEBUG_FORTH_WORDS_KEY 
c5e3						DMARK "TCS" 
c5e3 f5				push af  
c5e4 3a f8 c5			ld a, (.dmark)  
c5e7 32 62 ee			ld (debug_mark),a  
c5ea 3a f9 c5			ld a, (.dmark+1)  
c5ed 32 63 ee			ld (debug_mark+1),a  
c5f0 3a fa c5			ld a, (.dmark+2)  
c5f3 32 64 ee			ld (debug_mark+2),a  
c5f6 18 03			jr .pastdmark  
c5f8 ..			.dmark: db "TCS"  
c5fb f1			.pastdmark: pop af  
c5fc			endm  
# End of macro DMARK
c5fc						CALLMONITOR 
c5fc cd 6f ee			call debug_vector  
c5ff				endm  
# End of macro CALLMONITOR
c5ff					endif 
c5ff			 
c5ff					FORTH_DSP 
c5ff cd 8d 9b			call macro_forth_dsp 
c602				endm 
# End of macro FORTH_DSP
c602					 
c602			; TODO check is string type 
c602			 
c602					FORTH_DSP_VALUEHL 
c602 cd c7 9b			call macro_dsp_valuehl 
c605				endm 
# End of macro FORTH_DSP_VALUEHL
c605			; get pointer to string in hl 
c605			 
c605					if DEBUG_FORTH_WORDS 
c605						DMARK "TC1" 
c605 f5				push af  
c606 3a 1a c6			ld a, (.dmark)  
c609 32 62 ee			ld (debug_mark),a  
c60c 3a 1b c6			ld a, (.dmark+1)  
c60f 32 63 ee			ld (debug_mark+1),a  
c612 3a 1c c6			ld a, (.dmark+2)  
c615 32 64 ee			ld (debug_mark+2),a  
c618 18 03			jr .pastdmark  
c61a ..			.dmark: db "TC1"  
c61d f1			.pastdmark: pop af  
c61e			endm  
# End of macro DMARK
c61e						CALLMONITOR 
c61e cd 6f ee			call debug_vector  
c621				endm  
# End of macro CALLMONITOR
c621					endif 
c621			 
c621					; first time in turn to upper case first char 
c621			 
c621 7e					ld a, (hl) 
c622 c3 ab c6				jp .totsiptou 
c625			 
c625			 
c625 7e			.tot:		ld a, (hl) 
c626			;		cp 0 
c626 b7					or a 
c627 ca ee c6				jp z, .totdone 
c62a			 
c62a					if DEBUG_FORTH_WORDS 
c62a						DMARK "TC2" 
c62a f5				push af  
c62b 3a 3f c6			ld a, (.dmark)  
c62e 32 62 ee			ld (debug_mark),a  
c631 3a 40 c6			ld a, (.dmark+1)  
c634 32 63 ee			ld (debug_mark+1),a  
c637 3a 41 c6			ld a, (.dmark+2)  
c63a 32 64 ee			ld (debug_mark+2),a  
c63d 18 03			jr .pastdmark  
c63f ..			.dmark: db "TC2"  
c642 f1			.pastdmark: pop af  
c643			endm  
# End of macro DMARK
c643						CALLMONITOR 
c643 cd 6f ee			call debug_vector  
c646				endm  
# End of macro CALLMONITOR
c646					endif 
c646					; check to see if current char is a space 
c646			 
c646 fe 20				cp ' ' 
c648 28 21				jr z, .totsp 
c64a cd 47 8f				call to_lower 
c64d					if DEBUG_FORTH_WORDS 
c64d						DMARK "TC3" 
c64d f5				push af  
c64e 3a 62 c6			ld a, (.dmark)  
c651 32 62 ee			ld (debug_mark),a  
c654 3a 63 c6			ld a, (.dmark+1)  
c657 32 63 ee			ld (debug_mark+1),a  
c65a 3a 64 c6			ld a, (.dmark+2)  
c65d 32 64 ee			ld (debug_mark+2),a  
c660 18 03			jr .pastdmark  
c662 ..			.dmark: db "TC3"  
c665 f1			.pastdmark: pop af  
c666			endm  
# End of macro DMARK
c666						CALLMONITOR 
c666 cd 6f ee			call debug_vector  
c669				endm  
# End of macro CALLMONITOR
c669					endif 
c669 18 62				jr .totnxt 
c66b			 
c66b			.totsp:         ; on a space, find next char which should be upper 
c66b			 
c66b					if DEBUG_FORTH_WORDS 
c66b						DMARK "TC4" 
c66b f5				push af  
c66c 3a 80 c6			ld a, (.dmark)  
c66f 32 62 ee			ld (debug_mark),a  
c672 3a 81 c6			ld a, (.dmark+1)  
c675 32 63 ee			ld (debug_mark+1),a  
c678 3a 82 c6			ld a, (.dmark+2)  
c67b 32 64 ee			ld (debug_mark+2),a  
c67e 18 03			jr .pastdmark  
c680 ..			.dmark: db "TC4"  
c683 f1			.pastdmark: pop af  
c684			endm  
# End of macro DMARK
c684						CALLMONITOR 
c684 cd 6f ee			call debug_vector  
c687				endm  
# End of macro CALLMONITOR
c687					endif 
c687					;; 
c687			 
c687 fe 20				cp ' ' 
c689 20 20				jr nz, .totsiptou 
c68b 23					inc hl 
c68c 7e					ld a, (hl) 
c68d					if DEBUG_FORTH_WORDS 
c68d						DMARK "TC5" 
c68d f5				push af  
c68e 3a a2 c6			ld a, (.dmark)  
c691 32 62 ee			ld (debug_mark),a  
c694 3a a3 c6			ld a, (.dmark+1)  
c697 32 63 ee			ld (debug_mark+1),a  
c69a 3a a4 c6			ld a, (.dmark+2)  
c69d 32 64 ee			ld (debug_mark+2),a  
c6a0 18 03			jr .pastdmark  
c6a2 ..			.dmark: db "TC5"  
c6a5 f1			.pastdmark: pop af  
c6a6			endm  
# End of macro DMARK
c6a6						CALLMONITOR 
c6a6 cd 6f ee			call debug_vector  
c6a9				endm  
# End of macro CALLMONITOR
c6a9					endif 
c6a9 18 c0				jr .totsp 
c6ab			.totsiptou:     
c6ab					;cp 0 
c6ab b7					or a 
c6ac 28 40				jr z, .totdone 
c6ae					; not space and not zero term so upper case it 
c6ae cd 3e 8f				call to_upper 
c6b1			 
c6b1					if DEBUG_FORTH_WORDS 
c6b1						DMARK "TC6" 
c6b1 f5				push af  
c6b2 3a c6 c6			ld a, (.dmark)  
c6b5 32 62 ee			ld (debug_mark),a  
c6b8 3a c7 c6			ld a, (.dmark+1)  
c6bb 32 63 ee			ld (debug_mark+1),a  
c6be 3a c8 c6			ld a, (.dmark+2)  
c6c1 32 64 ee			ld (debug_mark+2),a  
c6c4 18 03			jr .pastdmark  
c6c6 ..			.dmark: db "TC6"  
c6c9 f1			.pastdmark: pop af  
c6ca			endm  
# End of macro DMARK
c6ca						CALLMONITOR 
c6ca cd 6f ee			call debug_vector  
c6cd				endm  
# End of macro CALLMONITOR
c6cd					endif 
c6cd			 
c6cd			 
c6cd			.totnxt: 
c6cd			 
c6cd 77					ld (hl), a 
c6ce 23					inc hl 
c6cf					if DEBUG_FORTH_WORDS 
c6cf						DMARK "TC7" 
c6cf f5				push af  
c6d0 3a e4 c6			ld a, (.dmark)  
c6d3 32 62 ee			ld (debug_mark),a  
c6d6 3a e5 c6			ld a, (.dmark+1)  
c6d9 32 63 ee			ld (debug_mark+1),a  
c6dc 3a e6 c6			ld a, (.dmark+2)  
c6df 32 64 ee			ld (debug_mark+2),a  
c6e2 18 03			jr .pastdmark  
c6e4 ..			.dmark: db "TC7"  
c6e7 f1			.pastdmark: pop af  
c6e8			endm  
# End of macro DMARK
c6e8						CALLMONITOR 
c6e8 cd 6f ee			call debug_vector  
c6eb				endm  
# End of macro CALLMONITOR
c6eb					endif 
c6eb c3 25 c6				jp .tot 
c6ee			 
c6ee					 
c6ee			 
c6ee			 
c6ee			; for each char convert to low 
c6ee					 
c6ee			.totdone: 
c6ee					if DEBUG_FORTH_WORDS 
c6ee						DMARK "TCd" 
c6ee f5				push af  
c6ef 3a 03 c7			ld a, (.dmark)  
c6f2 32 62 ee			ld (debug_mark),a  
c6f5 3a 04 c7			ld a, (.dmark+1)  
c6f8 32 63 ee			ld (debug_mark+1),a  
c6fb 3a 05 c7			ld a, (.dmark+2)  
c6fe 32 64 ee			ld (debug_mark+2),a  
c701 18 03			jr .pastdmark  
c703 ..			.dmark: db "TCd"  
c706 f1			.pastdmark: pop af  
c707			endm  
# End of macro DMARK
c707						CALLMONITOR 
c707 cd 6f ee			call debug_vector  
c70a				endm  
# End of macro CALLMONITOR
c70a					endif 
c70a					NEXTW 
c70a cd 6c ee			call parse_vector 
c70d c3 ae 9d			jp macro_next 
c710				endm 
# End of macro NEXTW
c710			 
c710			.SUBSTR: 
c710				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c710 48				db WORD_SYS_CORE+52             
c711 70 c7			dw .LEFT            
c713 07				db 6 + 1 
c714 .. 00			db "SUBSTR",0              
c71b				endm 
# End of macro CWHEAD
c71b			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c71b			 
c71b					if DEBUG_FORTH_WORDS_KEY 
c71b						DMARK "SST" 
c71b f5				push af  
c71c 3a 30 c7			ld a, (.dmark)  
c71f 32 62 ee			ld (debug_mark),a  
c722 3a 31 c7			ld a, (.dmark+1)  
c725 32 63 ee			ld (debug_mark+1),a  
c728 3a 32 c7			ld a, (.dmark+2)  
c72b 32 64 ee			ld (debug_mark+2),a  
c72e 18 03			jr .pastdmark  
c730 ..			.dmark: db "SST"  
c733 f1			.pastdmark: pop af  
c734			endm  
# End of macro DMARK
c734						CALLMONITOR 
c734 cd 6f ee			call debug_vector  
c737				endm  
# End of macro CALLMONITOR
c737					endif 
c737			; TODO check string type 
c737					FORTH_DSP_VALUEHL 
c737 cd c7 9b			call macro_dsp_valuehl 
c73a				endm 
# End of macro FORTH_DSP_VALUEHL
c73a			 
c73a e5					push hl      ; string length 
c73b			 
c73b					FORTH_DSP_POP 
c73b cd 7f 9c			call macro_forth_dsp_pop 
c73e				endm 
# End of macro FORTH_DSP_POP
c73e			 
c73e					FORTH_DSP_VALUEHL 
c73e cd c7 9b			call macro_dsp_valuehl 
c741				endm 
# End of macro FORTH_DSP_VALUEHL
c741			 
c741 e5					push hl     ; start char 
c742			 
c742					FORTH_DSP_POP 
c742 cd 7f 9c			call macro_forth_dsp_pop 
c745				endm 
# End of macro FORTH_DSP_POP
c745			 
c745			 
c745					FORTH_DSP_VALUE 
c745 cd b0 9b			call macro_forth_dsp_value 
c748				endm 
# End of macro FORTH_DSP_VALUE
c748			 
c748 d1					pop de    ; get start post offset 
c749			 
c749 19					add hl, de    ; starting offset 
c74a			 
c74a c1					pop bc 
c74b c5					push bc      ; grab size of string 
c74c			 
c74c e5					push hl    ; save string start  
c74d			 
c74d 26 00				ld h, 0 
c74f 69					ld l, c 
c750 23					inc hl 
c751 23					inc hl 
c752			 
c752 cd a2 90				call malloc 
c755				if DEBUG_FORTH_MALLOC_GUARD 
c755 cc 47 d2				call z,malloc_error 
c758				endif 
c758			 
c758 eb					ex de, hl      ; save malloc area for string copy 
c759 e1					pop hl    ; get back source 
c75a c1					pop bc    ; get length of string back 
c75b			 
c75b d5					push de    ; save malloc area for after we push 
c75c ed b0				ldir     ; copy substr 
c75e			 
c75e			 
c75e eb					ex de, hl 
c75f			;		ld a, 0 
c75f 36 00				ld (hl), 0   ; term substr 
c761			 
c761					 
c761 e1					pop hl    ; get malloc so we can push it 
c762 e5					push hl   ; save so we can free it afterwards 
c763			 
c763 cd 35 9a				call forth_push_str 
c766			 
c766 e1					pop hl 
c767 cd 6c 91				call free 
c76a			 
c76a					 
c76a					 
c76a			 
c76a			 
c76a					NEXTW 
c76a cd 6c ee			call parse_vector 
c76d c3 ae 9d			jp macro_next 
c770				endm 
# End of macro NEXTW
c770			 
c770			.LEFT: 
c770				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c770 48				db WORD_SYS_CORE+52             
c771 b4 c7			dw .RIGHT            
c773 05				db 4 + 1 
c774 .. 00			db "LEFT",0              
c779				endm 
# End of macro CWHEAD
c779			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
c779					if DEBUG_FORTH_WORDS_KEY 
c779						DMARK "LEF" 
c779 f5				push af  
c77a 3a 8e c7			ld a, (.dmark)  
c77d 32 62 ee			ld (debug_mark),a  
c780 3a 8f c7			ld a, (.dmark+1)  
c783 32 63 ee			ld (debug_mark+1),a  
c786 3a 90 c7			ld a, (.dmark+2)  
c789 32 64 ee			ld (debug_mark+2),a  
c78c 18 03			jr .pastdmark  
c78e ..			.dmark: db "LEF"  
c791 f1			.pastdmark: pop af  
c792			endm  
# End of macro DMARK
c792						CALLMONITOR 
c792 cd 6f ee			call debug_vector  
c795				endm  
# End of macro CALLMONITOR
c795					endif 
c795			 
c795					 
c795			; TODO check string type 
c795					FORTH_DSP_VALUEHL 
c795 cd c7 9b			call macro_dsp_valuehl 
c798				endm 
# End of macro FORTH_DSP_VALUEHL
c798			 
c798 e5					push hl      ; string length 
c799			 
c799					FORTH_DSP_POP 
c799 cd 7f 9c			call macro_forth_dsp_pop 
c79c				endm 
# End of macro FORTH_DSP_POP
c79c			 
c79c					FORTH_DSP_VALUEHL 
c79c cd c7 9b			call macro_dsp_valuehl 
c79f				endm 
# End of macro FORTH_DSP_VALUEHL
c79f			 
c79f c1					pop bc 
c7a0			 
c7a0 11 b8 e2				ld de, scratch 
c7a3 ed b0				ldir 
c7a5 3e 00				ld a, 0 
c7a7 12					ld (de), a 
c7a8					 
c7a8 21 b8 e2				ld hl, scratch 
c7ab cd 35 9a				call forth_push_str 
c7ae			 
c7ae					NEXTW 
c7ae cd 6c ee			call parse_vector 
c7b1 c3 ae 9d			jp macro_next 
c7b4				endm 
# End of macro NEXTW
c7b4			.RIGHT: 
c7b4				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c7b4 48				db WORD_SYS_CORE+52             
c7b5 75 c8			dw .STR2NUM            
c7b7 06				db 5 + 1 
c7b8 .. 00			db "RIGHT",0              
c7be				endm 
# End of macro CWHEAD
c7be			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
c7be					if DEBUG_FORTH_WORDS_KEY 
c7be						DMARK "RIG" 
c7be f5				push af  
c7bf 3a d3 c7			ld a, (.dmark)  
c7c2 32 62 ee			ld (debug_mark),a  
c7c5 3a d4 c7			ld a, (.dmark+1)  
c7c8 32 63 ee			ld (debug_mark+1),a  
c7cb 3a d5 c7			ld a, (.dmark+2)  
c7ce 32 64 ee			ld (debug_mark+2),a  
c7d1 18 03			jr .pastdmark  
c7d3 ..			.dmark: db "RIG"  
c7d6 f1			.pastdmark: pop af  
c7d7			endm  
# End of macro DMARK
c7d7						CALLMONITOR 
c7d7 cd 6f ee			call debug_vector  
c7da				endm  
# End of macro CALLMONITOR
c7da					endif 
c7da			 
c7da			; TODO check string type 
c7da					FORTH_DSP_VALUEHL 
c7da cd c7 9b			call macro_dsp_valuehl 
c7dd				endm 
# End of macro FORTH_DSP_VALUEHL
c7dd			 
c7dd e5					push hl      ; string length 
c7de			 
c7de					FORTH_DSP_POP 
c7de cd 7f 9c			call macro_forth_dsp_pop 
c7e1				endm 
# End of macro FORTH_DSP_POP
c7e1			 
c7e1					FORTH_DSP_VALUEHL 
c7e1 cd c7 9b			call macro_dsp_valuehl 
c7e4				endm 
# End of macro FORTH_DSP_VALUEHL
c7e4			 
c7e4					if DEBUG_FORTH_WORDS 
c7e4						DMARK "RI1" 
c7e4 f5				push af  
c7e5 3a f9 c7			ld a, (.dmark)  
c7e8 32 62 ee			ld (debug_mark),a  
c7eb 3a fa c7			ld a, (.dmark+1)  
c7ee 32 63 ee			ld (debug_mark+1),a  
c7f1 3a fb c7			ld a, (.dmark+2)  
c7f4 32 64 ee			ld (debug_mark+2),a  
c7f7 18 03			jr .pastdmark  
c7f9 ..			.dmark: db "RI1"  
c7fc f1			.pastdmark: pop af  
c7fd			endm  
# End of macro DMARK
c7fd						CALLMONITOR 
c7fd cd 6f ee			call debug_vector  
c800				endm  
# End of macro CALLMONITOR
c800					endif 
c800					; from the pointer to string get to the end of string 
c800			 
c800 01 ff 00				ld bc, 255 
c803 3e 00				ld a, 0 
c805 ed b1				cpir 
c807 2b					dec hl 
c808			 
c808					;  
c808			 
c808					if DEBUG_FORTH_WORDS 
c808						DMARK "RI2" 
c808 f5				push af  
c809 3a 1d c8			ld a, (.dmark)  
c80c 32 62 ee			ld (debug_mark),a  
c80f 3a 1e c8			ld a, (.dmark+1)  
c812 32 63 ee			ld (debug_mark+1),a  
c815 3a 1f c8			ld a, (.dmark+2)  
c818 32 64 ee			ld (debug_mark+2),a  
c81b 18 03			jr .pastdmark  
c81d ..			.dmark: db "RI2"  
c820 f1			.pastdmark: pop af  
c821			endm  
# End of macro DMARK
c821						CALLMONITOR 
c821 cd 6f ee			call debug_vector  
c824				endm  
# End of macro CALLMONITOR
c824					endif 
c824			 
c824 c1					pop bc    ;  length of string to copy 
c825			 
c825 79					ld a, c 
c826 eb					ex de, hl 
c827 21 b8 e2				ld hl, scratch  
c82a cd d6 8c				call addatohl 
c82d			 
c82d eb					ex de, hl 
c82e			 
c82e					if DEBUG_FORTH_WORDS 
c82e						DMARK "RI3" 
c82e f5				push af  
c82f 3a 43 c8			ld a, (.dmark)  
c832 32 62 ee			ld (debug_mark),a  
c835 3a 44 c8			ld a, (.dmark+1)  
c838 32 63 ee			ld (debug_mark+1),a  
c83b 3a 45 c8			ld a, (.dmark+2)  
c83e 32 64 ee			ld (debug_mark+2),a  
c841 18 03			jr .pastdmark  
c843 ..			.dmark: db "RI3"  
c846 f1			.pastdmark: pop af  
c847			endm  
# End of macro DMARK
c847						CALLMONITOR 
c847 cd 6f ee			call debug_vector  
c84a				endm  
# End of macro CALLMONITOR
c84a					endif 
c84a			 
c84a 03					inc bc 
c84b ed b8				lddr 
c84d					 
c84d 21 b8 e2				ld hl, scratch 
c850					if DEBUG_FORTH_WORDS 
c850						DMARK "RI4" 
c850 f5				push af  
c851 3a 65 c8			ld a, (.dmark)  
c854 32 62 ee			ld (debug_mark),a  
c857 3a 66 c8			ld a, (.dmark+1)  
c85a 32 63 ee			ld (debug_mark+1),a  
c85d 3a 67 c8			ld a, (.dmark+2)  
c860 32 64 ee			ld (debug_mark+2),a  
c863 18 03			jr .pastdmark  
c865 ..			.dmark: db "RI4"  
c868 f1			.pastdmark: pop af  
c869			endm  
# End of macro DMARK
c869						CALLMONITOR 
c869 cd 6f ee			call debug_vector  
c86c				endm  
# End of macro CALLMONITOR
c86c					endif 
c86c cd 35 9a				call forth_push_str 
c86f			 
c86f			 
c86f					NEXTW 
c86f cd 6c ee			call parse_vector 
c872 c3 ae 9d			jp macro_next 
c875				endm 
# End of macro NEXTW
c875			 
c875			 
c875			.STR2NUM: 
c875				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c875 48				db WORD_SYS_CORE+52             
c876 04 c9			dw .NUM2STR            
c878 08				db 7 + 1 
c879 .. 00			db "STR2NUM",0              
c881				endm 
# End of macro CWHEAD
c881			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c881			 
c881			 
c881			; TODO STR type check to do 
c881					if DEBUG_FORTH_WORDS_KEY 
c881						DMARK "S2N" 
c881 f5				push af  
c882 3a 96 c8			ld a, (.dmark)  
c885 32 62 ee			ld (debug_mark),a  
c888 3a 97 c8			ld a, (.dmark+1)  
c88b 32 63 ee			ld (debug_mark+1),a  
c88e 3a 98 c8			ld a, (.dmark+2)  
c891 32 64 ee			ld (debug_mark+2),a  
c894 18 03			jr .pastdmark  
c896 ..			.dmark: db "S2N"  
c899 f1			.pastdmark: pop af  
c89a			endm  
# End of macro DMARK
c89a						CALLMONITOR 
c89a cd 6f ee			call debug_vector  
c89d				endm  
# End of macro CALLMONITOR
c89d					endif 
c89d			 
c89d					;FORTH_DSP 
c89d					FORTH_DSP_VALUE 
c89d cd b0 9b			call macro_forth_dsp_value 
c8a0				endm 
# End of macro FORTH_DSP_VALUE
c8a0					;inc hl 
c8a0			 
c8a0 eb					ex de, hl 
c8a1					if DEBUG_FORTH_WORDS 
c8a1						DMARK "S2a" 
c8a1 f5				push af  
c8a2 3a b6 c8			ld a, (.dmark)  
c8a5 32 62 ee			ld (debug_mark),a  
c8a8 3a b7 c8			ld a, (.dmark+1)  
c8ab 32 63 ee			ld (debug_mark+1),a  
c8ae 3a b8 c8			ld a, (.dmark+2)  
c8b1 32 64 ee			ld (debug_mark+2),a  
c8b4 18 03			jr .pastdmark  
c8b6 ..			.dmark: db "S2a"  
c8b9 f1			.pastdmark: pop af  
c8ba			endm  
# End of macro DMARK
c8ba						CALLMONITOR 
c8ba cd 6f ee			call debug_vector  
c8bd				endm  
# End of macro CALLMONITOR
c8bd					endif 
c8bd cd c5 8f				call string_to_uint16 
c8c0			 
c8c0					if DEBUG_FORTH_WORDS 
c8c0						DMARK "S2b" 
c8c0 f5				push af  
c8c1 3a d5 c8			ld a, (.dmark)  
c8c4 32 62 ee			ld (debug_mark),a  
c8c7 3a d6 c8			ld a, (.dmark+1)  
c8ca 32 63 ee			ld (debug_mark+1),a  
c8cd 3a d7 c8			ld a, (.dmark+2)  
c8d0 32 64 ee			ld (debug_mark+2),a  
c8d3 18 03			jr .pastdmark  
c8d5 ..			.dmark: db "S2b"  
c8d8 f1			.pastdmark: pop af  
c8d9			endm  
# End of macro DMARK
c8d9						CALLMONITOR 
c8d9 cd 6f ee			call debug_vector  
c8dc				endm  
# End of macro CALLMONITOR
c8dc					endif 
c8dc			;		push hl 
c8dc					FORTH_DSP_POP 
c8dc cd 7f 9c			call macro_forth_dsp_pop 
c8df				endm 
# End of macro FORTH_DSP_POP
c8df			;		pop hl 
c8df					 
c8df					if DEBUG_FORTH_WORDS 
c8df						DMARK "S2b" 
c8df f5				push af  
c8e0 3a f4 c8			ld a, (.dmark)  
c8e3 32 62 ee			ld (debug_mark),a  
c8e6 3a f5 c8			ld a, (.dmark+1)  
c8e9 32 63 ee			ld (debug_mark+1),a  
c8ec 3a f6 c8			ld a, (.dmark+2)  
c8ef 32 64 ee			ld (debug_mark+2),a  
c8f2 18 03			jr .pastdmark  
c8f4 ..			.dmark: db "S2b"  
c8f7 f1			.pastdmark: pop af  
c8f8			endm  
# End of macro DMARK
c8f8						CALLMONITOR 
c8f8 cd 6f ee			call debug_vector  
c8fb				endm  
# End of macro CALLMONITOR
c8fb					endif 
c8fb cd cb 99				call forth_push_numhl	 
c8fe			 
c8fe				 
c8fe				       NEXTW 
c8fe cd 6c ee			call parse_vector 
c901 c3 ae 9d			jp macro_next 
c904				endm 
# End of macro NEXTW
c904			.NUM2STR: 
c904				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c904 48				db WORD_SYS_CORE+52             
c905 99 c9			dw .CONCAT            
c907 08				db 7 + 1 
c908 .. 00			db "NUM2STR",0              
c910				endm 
# End of macro CWHEAD
c910			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
c910			 
c910			;		; malloc a string to target 
c910			;		ld hl, 10     ; TODO max string size should be fine 
c910			;		call malloc 
c910			;		push hl    ; save malloc location 
c910			; 
c910			; 
c910			;; TODO check int type 
c910					if DEBUG_FORTH_WORDS_KEY 
c910						DMARK "N2S" 
c910 f5				push af  
c911 3a 25 c9			ld a, (.dmark)  
c914 32 62 ee			ld (debug_mark),a  
c917 3a 26 c9			ld a, (.dmark+1)  
c91a 32 63 ee			ld (debug_mark+1),a  
c91d 3a 27 c9			ld a, (.dmark+2)  
c920 32 64 ee			ld (debug_mark+2),a  
c923 18 03			jr .pastdmark  
c925 ..			.dmark: db "N2S"  
c928 f1			.pastdmark: pop af  
c929			endm  
# End of macro DMARK
c929						CALLMONITOR 
c929 cd 6f ee			call debug_vector  
c92c				endm  
# End of macro CALLMONITOR
c92c					endif 
c92c			 
c92c					FORTH_DSP_VALUEHL 
c92c cd c7 9b			call macro_dsp_valuehl 
c92f				endm 
# End of macro FORTH_DSP_VALUEHL
c92f			 
c92f					if DEBUG_FORTH_WORDS 
c92f						DMARK "NS1" 
c92f f5				push af  
c930 3a 44 c9			ld a, (.dmark)  
c933 32 62 ee			ld (debug_mark),a  
c936 3a 45 c9			ld a, (.dmark+1)  
c939 32 63 ee			ld (debug_mark+1),a  
c93c 3a 46 c9			ld a, (.dmark+2)  
c93f 32 64 ee			ld (debug_mark+2),a  
c942 18 03			jr .pastdmark  
c944 ..			.dmark: db "NS1"  
c947 f1			.pastdmark: pop af  
c948			endm  
# End of macro DMARK
c948						CALLMONITOR 
c948 cd 6f ee			call debug_vector  
c94b				endm  
# End of macro CALLMONITOR
c94b					endif 
c94b					FORTH_DSP_POP 
c94b cd 7f 9c			call macro_forth_dsp_pop 
c94e				endm 
# End of macro FORTH_DSP_POP
c94e			 
c94e eb					ex de, hl 
c94f 21 b8 e2				ld hl, scratch 
c952					if DEBUG_FORTH_WORDS 
c952						DMARK "NS2" 
c952 f5				push af  
c953 3a 67 c9			ld a, (.dmark)  
c956 32 62 ee			ld (debug_mark),a  
c959 3a 68 c9			ld a, (.dmark+1)  
c95c 32 63 ee			ld (debug_mark+1),a  
c95f 3a 69 c9			ld a, (.dmark+2)  
c962 32 64 ee			ld (debug_mark+2),a  
c965 18 03			jr .pastdmark  
c967 ..			.dmark: db "NS2"  
c96a f1			.pastdmark: pop af  
c96b			endm  
# End of macro DMARK
c96b						CALLMONITOR 
c96b cd 6f ee			call debug_vector  
c96e				endm  
# End of macro CALLMONITOR
c96e					endif 
c96e cd dd 8f				call uitoa_16 
c971 21 b8 e2				ld hl, scratch 
c974					if DEBUG_FORTH_WORDS 
c974						DMARK "NS3" 
c974 f5				push af  
c975 3a 89 c9			ld a, (.dmark)  
c978 32 62 ee			ld (debug_mark),a  
c97b 3a 8a c9			ld a, (.dmark+1)  
c97e 32 63 ee			ld (debug_mark+1),a  
c981 3a 8b c9			ld a, (.dmark+2)  
c984 32 64 ee			ld (debug_mark+2),a  
c987 18 03			jr .pastdmark  
c989 ..			.dmark: db "NS3"  
c98c f1			.pastdmark: pop af  
c98d			endm  
# End of macro DMARK
c98d						CALLMONITOR 
c98d cd 6f ee			call debug_vector  
c990				endm  
# End of macro CALLMONITOR
c990					endif 
c990 cd 35 9a				call forth_push_str 
c993			;		ld a, l 
c993			;		call DispAToASCII   
c993			;;TODO need to chage above call to dump into string 
c993			; 
c993			; 
c993			 
c993				       NEXTW 
c993 cd 6c ee			call parse_vector 
c996 c3 ae 9d			jp macro_next 
c999				endm 
# End of macro NEXTW
c999			 
c999			.CONCAT: 
c999				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c999 48				db WORD_SYS_CORE+52             
c99a 4f ca			dw .FIND            
c99c 07				db 6 + 1 
c99d .. 00			db "CONCAT",0              
c9a4				endm 
# End of macro CWHEAD
c9a4			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c9a4			 
c9a4			; TODO check string type 
c9a4			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c9a4			 
c9a4					if DEBUG_FORTH_WORDS_KEY 
c9a4						DMARK "CON" 
c9a4 f5				push af  
c9a5 3a b9 c9			ld a, (.dmark)  
c9a8 32 62 ee			ld (debug_mark),a  
c9ab 3a ba c9			ld a, (.dmark+1)  
c9ae 32 63 ee			ld (debug_mark+1),a  
c9b1 3a bb c9			ld a, (.dmark+2)  
c9b4 32 64 ee			ld (debug_mark+2),a  
c9b7 18 03			jr .pastdmark  
c9b9 ..			.dmark: db "CON"  
c9bc f1			.pastdmark: pop af  
c9bd			endm  
# End of macro DMARK
c9bd						CALLMONITOR 
c9bd cd 6f ee			call debug_vector  
c9c0				endm  
# End of macro CALLMONITOR
c9c0					endif 
c9c0			 
c9c0			 
c9c0					FORTH_DSP_VALUE 
c9c0 cd b0 9b			call macro_forth_dsp_value 
c9c3				endm 
# End of macro FORTH_DSP_VALUE
c9c3 e5					push hl   ; s2 
c9c4			 
c9c4					FORTH_DSP_POP 
c9c4 cd 7f 9c			call macro_forth_dsp_pop 
c9c7				endm 
# End of macro FORTH_DSP_POP
c9c7			 
c9c7					FORTH_DSP_VALUE 
c9c7 cd b0 9b			call macro_forth_dsp_value 
c9ca				endm 
# End of macro FORTH_DSP_VALUE
c9ca			 
c9ca e5					push hl   ; s1 
c9cb			 
c9cb					FORTH_DSP_POP 
c9cb cd 7f 9c			call macro_forth_dsp_pop 
c9ce				endm 
# End of macro FORTH_DSP_POP
c9ce					 
c9ce			 
c9ce					; copy s1 
c9ce			 
c9ce				 
c9ce					; save ptr 
c9ce e1					pop hl  
c9cf e5					push hl 
c9d0 3e 00				ld a, 0 
c9d2 cd 39 90				call strlent 
c9d5					;inc hl    ; zer0 
c9d5 06 00				ld b, 0 
c9d7 4d					ld c, l 
c9d8 e1					pop hl		 
c9d9 11 b8 e2				ld de, scratch	 
c9dc					if DEBUG_FORTH_WORDS 
c9dc						DMARK "CO1" 
c9dc f5				push af  
c9dd 3a f1 c9			ld a, (.dmark)  
c9e0 32 62 ee			ld (debug_mark),a  
c9e3 3a f2 c9			ld a, (.dmark+1)  
c9e6 32 63 ee			ld (debug_mark+1),a  
c9e9 3a f3 c9			ld a, (.dmark+2)  
c9ec 32 64 ee			ld (debug_mark+2),a  
c9ef 18 03			jr .pastdmark  
c9f1 ..			.dmark: db "CO1"  
c9f4 f1			.pastdmark: pop af  
c9f5			endm  
# End of macro DMARK
c9f5						CALLMONITOR 
c9f5 cd 6f ee			call debug_vector  
c9f8				endm  
# End of macro CALLMONITOR
c9f8					endif 
c9f8 ed b0				ldir 
c9fa			 
c9fa e1					pop hl 
c9fb e5					push hl 
c9fc d5					push de 
c9fd			 
c9fd			 
c9fd 3e 00				ld a, 0 
c9ff cd 39 90				call strlent 
ca02 23					inc hl    ; zer0 
ca03 23					inc hl 
ca04 06 00				ld b, 0 
ca06 4d					ld c, l 
ca07 d1					pop de 
ca08 e1					pop hl		 
ca09					if DEBUG_FORTH_WORDS 
ca09						DMARK "CO2" 
ca09 f5				push af  
ca0a 3a 1e ca			ld a, (.dmark)  
ca0d 32 62 ee			ld (debug_mark),a  
ca10 3a 1f ca			ld a, (.dmark+1)  
ca13 32 63 ee			ld (debug_mark+1),a  
ca16 3a 20 ca			ld a, (.dmark+2)  
ca19 32 64 ee			ld (debug_mark+2),a  
ca1c 18 03			jr .pastdmark  
ca1e ..			.dmark: db "CO2"  
ca21 f1			.pastdmark: pop af  
ca22			endm  
# End of macro DMARK
ca22						CALLMONITOR 
ca22 cd 6f ee			call debug_vector  
ca25				endm  
# End of macro CALLMONITOR
ca25					endif 
ca25 ed b0				ldir 
ca27			 
ca27			 
ca27			 
ca27 21 b8 e2				ld hl, scratch 
ca2a					if DEBUG_FORTH_WORDS 
ca2a						DMARK "CO5" 
ca2a f5				push af  
ca2b 3a 3f ca			ld a, (.dmark)  
ca2e 32 62 ee			ld (debug_mark),a  
ca31 3a 40 ca			ld a, (.dmark+1)  
ca34 32 63 ee			ld (debug_mark+1),a  
ca37 3a 41 ca			ld a, (.dmark+2)  
ca3a 32 64 ee			ld (debug_mark+2),a  
ca3d 18 03			jr .pastdmark  
ca3f ..			.dmark: db "CO5"  
ca42 f1			.pastdmark: pop af  
ca43			endm  
# End of macro DMARK
ca43						CALLMONITOR 
ca43 cd 6f ee			call debug_vector  
ca46				endm  
# End of macro CALLMONITOR
ca46					endif 
ca46			 
ca46 cd 35 9a				call forth_push_str 
ca49			 
ca49			 
ca49			 
ca49			 
ca49				       NEXTW 
ca49 cd 6c ee			call parse_vector 
ca4c c3 ae 9d			jp macro_next 
ca4f				endm 
# End of macro NEXTW
ca4f			 
ca4f			 
ca4f			.FIND: 
ca4f				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
ca4f 4b				db WORD_SYS_CORE+55             
ca50 0f cb			dw .LEN            
ca52 05				db 4 + 1 
ca53 .. 00			db "FIND",0              
ca58				endm 
# End of macro CWHEAD
ca58			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
ca58			 
ca58					if DEBUG_FORTH_WORDS_KEY 
ca58						DMARK "FND" 
ca58 f5				push af  
ca59 3a 6d ca			ld a, (.dmark)  
ca5c 32 62 ee			ld (debug_mark),a  
ca5f 3a 6e ca			ld a, (.dmark+1)  
ca62 32 63 ee			ld (debug_mark+1),a  
ca65 3a 6f ca			ld a, (.dmark+2)  
ca68 32 64 ee			ld (debug_mark+2),a  
ca6b 18 03			jr .pastdmark  
ca6d ..			.dmark: db "FND"  
ca70 f1			.pastdmark: pop af  
ca71			endm  
# End of macro DMARK
ca71						CALLMONITOR 
ca71 cd 6f ee			call debug_vector  
ca74				endm  
# End of macro CALLMONITOR
ca74					endif 
ca74			 
ca74			; TODO check string type 
ca74					FORTH_DSP_VALUE 
ca74 cd b0 9b			call macro_forth_dsp_value 
ca77				endm 
# End of macro FORTH_DSP_VALUE
ca77			 
ca77 e5					push hl    
ca78 7e					ld a,(hl)    ; char to find   
ca79			; TODO change char to substr 
ca79			 
ca79 f5					push af 
ca7a					 
ca7a			 
ca7a			 
ca7a					if DEBUG_FORTH_WORDS 
ca7a						DMARK "FN1" 
ca7a f5				push af  
ca7b 3a 8f ca			ld a, (.dmark)  
ca7e 32 62 ee			ld (debug_mark),a  
ca81 3a 90 ca			ld a, (.dmark+1)  
ca84 32 63 ee			ld (debug_mark+1),a  
ca87 3a 91 ca			ld a, (.dmark+2)  
ca8a 32 64 ee			ld (debug_mark+2),a  
ca8d 18 03			jr .pastdmark  
ca8f ..			.dmark: db "FN1"  
ca92 f1			.pastdmark: pop af  
ca93			endm  
# End of macro DMARK
ca93						CALLMONITOR 
ca93 cd 6f ee			call debug_vector  
ca96				endm  
# End of macro CALLMONITOR
ca96					endif 
ca96			 
ca96					FORTH_DSP_POP 
ca96 cd 7f 9c			call macro_forth_dsp_pop 
ca99				endm 
# End of macro FORTH_DSP_POP
ca99			 
ca99					; string to search 
ca99			 
ca99					FORTH_DSP_VALUE 
ca99 cd b0 9b			call macro_forth_dsp_value 
ca9c				endm 
# End of macro FORTH_DSP_VALUE
ca9c			 
ca9c d1					pop de  ; d is char to find  
ca9d			 
ca9d					if DEBUG_FORTH_WORDS 
ca9d						DMARK "FN2" 
ca9d f5				push af  
ca9e 3a b2 ca			ld a, (.dmark)  
caa1 32 62 ee			ld (debug_mark),a  
caa4 3a b3 ca			ld a, (.dmark+1)  
caa7 32 63 ee			ld (debug_mark+1),a  
caaa 3a b4 ca			ld a, (.dmark+2)  
caad 32 64 ee			ld (debug_mark+2),a  
cab0 18 03			jr .pastdmark  
cab2 ..			.dmark: db "FN2"  
cab5 f1			.pastdmark: pop af  
cab6			endm  
# End of macro DMARK
cab6						CALLMONITOR 
cab6 cd 6f ee			call debug_vector  
cab9				endm  
# End of macro CALLMONITOR
cab9					endif 
cab9					 
cab9 01 00 00				ld bc, 0 
cabc 7e			.findchar:      ld a,(hl) 
cabd			;		cp 0   		 
cabd b7					or a 
cabe 28 27				jr z, .finddone     
cac0 ba					cp d 
cac1 28 20				jr z, .foundchar 
cac3 03					inc bc 
cac4 23					inc hl 
cac5					if DEBUG_FORTH_WORDS 
cac5						DMARK "FN3" 
cac5 f5				push af  
cac6 3a da ca			ld a, (.dmark)  
cac9 32 62 ee			ld (debug_mark),a  
cacc 3a db ca			ld a, (.dmark+1)  
cacf 32 63 ee			ld (debug_mark+1),a  
cad2 3a dc ca			ld a, (.dmark+2)  
cad5 32 64 ee			ld (debug_mark+2),a  
cad8 18 03			jr .pastdmark  
cada ..			.dmark: db "FN3"  
cadd f1			.pastdmark: pop af  
cade			endm  
# End of macro DMARK
cade						CALLMONITOR 
cade cd 6f ee			call debug_vector  
cae1				endm  
# End of macro CALLMONITOR
cae1					endif 
cae1 18 d9				jr .findchar 
cae3			 
cae3			 
cae3 c5			.foundchar:	push bc 
cae4 e1					pop hl 
cae5 18 03				jr .findexit 
cae7			 
cae7			 
cae7							 
cae7			 
cae7			.finddone:     ; got to end of string with no find 
cae7 21 00 00				ld hl, 0 
caea			.findexit: 
caea			 
caea					if DEBUG_FORTH_WORDS 
caea						DMARK "FNd" 
caea f5				push af  
caeb 3a ff ca			ld a, (.dmark)  
caee 32 62 ee			ld (debug_mark),a  
caf1 3a 00 cb			ld a, (.dmark+1)  
caf4 32 63 ee			ld (debug_mark+1),a  
caf7 3a 01 cb			ld a, (.dmark+2)  
cafa 32 64 ee			ld (debug_mark+2),a  
cafd 18 03			jr .pastdmark  
caff ..			.dmark: db "FNd"  
cb02 f1			.pastdmark: pop af  
cb03			endm  
# End of macro DMARK
cb03						CALLMONITOR 
cb03 cd 6f ee			call debug_vector  
cb06				endm  
# End of macro CALLMONITOR
cb06					endif 
cb06 cd cb 99			call forth_push_numhl 
cb09			 
cb09				       NEXTW 
cb09 cd 6c ee			call parse_vector 
cb0c c3 ae 9d			jp macro_next 
cb0f				endm 
# End of macro NEXTW
cb0f			 
cb0f			.LEN: 
cb0f				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
cb0f 4c				db WORD_SYS_CORE+56             
cb10 7c cb			dw .ASC            
cb12 06				db 5 + 1 
cb13 .. 00			db "COUNT",0              
cb19				endm 
# End of macro CWHEAD
cb19			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
cb19			 
cb19					if DEBUG_FORTH_WORDS_KEY 
cb19						DMARK "CNT" 
cb19 f5				push af  
cb1a 3a 2e cb			ld a, (.dmark)  
cb1d 32 62 ee			ld (debug_mark),a  
cb20 3a 2f cb			ld a, (.dmark+1)  
cb23 32 63 ee			ld (debug_mark+1),a  
cb26 3a 30 cb			ld a, (.dmark+2)  
cb29 32 64 ee			ld (debug_mark+2),a  
cb2c 18 03			jr .pastdmark  
cb2e ..			.dmark: db "CNT"  
cb31 f1			.pastdmark: pop af  
cb32			endm  
# End of macro DMARK
cb32						CALLMONITOR 
cb32 cd 6f ee			call debug_vector  
cb35				endm  
# End of macro CALLMONITOR
cb35					endif 
cb35			; TODO check string type 
cb35					FORTH_DSP_VALUE 
cb35 cd b0 9b			call macro_forth_dsp_value 
cb38				endm 
# End of macro FORTH_DSP_VALUE
cb38			 
cb38			 
cb38					if DEBUG_FORTH_WORDS 
cb38						DMARK "CN?" 
cb38 f5				push af  
cb39 3a 4d cb			ld a, (.dmark)  
cb3c 32 62 ee			ld (debug_mark),a  
cb3f 3a 4e cb			ld a, (.dmark+1)  
cb42 32 63 ee			ld (debug_mark+1),a  
cb45 3a 4f cb			ld a, (.dmark+2)  
cb48 32 64 ee			ld (debug_mark+2),a  
cb4b 18 03			jr .pastdmark  
cb4d ..			.dmark: db "CN?"  
cb50 f1			.pastdmark: pop af  
cb51			endm  
# End of macro DMARK
cb51						CALLMONITOR 
cb51 cd 6f ee			call debug_vector  
cb54				endm  
# End of macro CALLMONITOR
cb54					endif 
cb54 cd 2e 90				call strlenz 
cb57					if DEBUG_FORTH_WORDS 
cb57						DMARK "CNl" 
cb57 f5				push af  
cb58 3a 6c cb			ld a, (.dmark)  
cb5b 32 62 ee			ld (debug_mark),a  
cb5e 3a 6d cb			ld a, (.dmark+1)  
cb61 32 63 ee			ld (debug_mark+1),a  
cb64 3a 6e cb			ld a, (.dmark+2)  
cb67 32 64 ee			ld (debug_mark+2),a  
cb6a 18 03			jr .pastdmark  
cb6c ..			.dmark: db "CNl"  
cb6f f1			.pastdmark: pop af  
cb70			endm  
# End of macro DMARK
cb70						CALLMONITOR 
cb70 cd 6f ee			call debug_vector  
cb73				endm  
# End of macro CALLMONITOR
cb73					endif 
cb73			 
cb73 cd cb 99				call forth_push_numhl 
cb76			 
cb76			 
cb76			 
cb76				       NEXTW 
cb76 cd 6c ee			call parse_vector 
cb79 c3 ae 9d			jp macro_next 
cb7c				endm 
# End of macro NEXTW
cb7c			.ASC: 
cb7c				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
cb7c 4d				db WORD_SYS_CORE+57             
cb7d ed cb			dw .CHR            
cb7f 04				db 3 + 1 
cb80 .. 00			db "ASC",0              
cb84				endm 
# End of macro CWHEAD
cb84			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
cb84					if DEBUG_FORTH_WORDS_KEY 
cb84						DMARK "ASC" 
cb84 f5				push af  
cb85 3a 99 cb			ld a, (.dmark)  
cb88 32 62 ee			ld (debug_mark),a  
cb8b 3a 9a cb			ld a, (.dmark+1)  
cb8e 32 63 ee			ld (debug_mark+1),a  
cb91 3a 9b cb			ld a, (.dmark+2)  
cb94 32 64 ee			ld (debug_mark+2),a  
cb97 18 03			jr .pastdmark  
cb99 ..			.dmark: db "ASC"  
cb9c f1			.pastdmark: pop af  
cb9d			endm  
# End of macro DMARK
cb9d						CALLMONITOR 
cb9d cd 6f ee			call debug_vector  
cba0				endm  
# End of macro CALLMONITOR
cba0					endif 
cba0					FORTH_DSP_VALUE 
cba0 cd b0 9b			call macro_forth_dsp_value 
cba3				endm 
# End of macro FORTH_DSP_VALUE
cba3					;v5 FORTH_DSP_VALUE 
cba3			;		inc hl      ; now at start of numeric as string 
cba3			 
cba3 e5					push hl 
cba4			 
cba4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cba4 cd 7f 9c			call macro_forth_dsp_pop 
cba7				endm 
# End of macro FORTH_DSP_POP
cba7			 
cba7 e1					pop hl 
cba8			 
cba8					if DEBUG_FORTH_WORDS 
cba8						DMARK "AS1" 
cba8 f5				push af  
cba9 3a bd cb			ld a, (.dmark)  
cbac 32 62 ee			ld (debug_mark),a  
cbaf 3a be cb			ld a, (.dmark+1)  
cbb2 32 63 ee			ld (debug_mark+1),a  
cbb5 3a bf cb			ld a, (.dmark+2)  
cbb8 32 64 ee			ld (debug_mark+2),a  
cbbb 18 03			jr .pastdmark  
cbbd ..			.dmark: db "AS1"  
cbc0 f1			.pastdmark: pop af  
cbc1			endm  
# End of macro DMARK
cbc1						CALLMONITOR 
cbc1 cd 6f ee			call debug_vector  
cbc4				endm  
# End of macro CALLMONITOR
cbc4					endif 
cbc4					; push the content of a onto the stack as a value 
cbc4			 
cbc4 7e					ld a,(hl)   ; get char 
cbc5 26 00				ld h,0 
cbc7 6f					ld l,a 
cbc8					if DEBUG_FORTH_WORDS 
cbc8						DMARK "AS2" 
cbc8 f5				push af  
cbc9 3a dd cb			ld a, (.dmark)  
cbcc 32 62 ee			ld (debug_mark),a  
cbcf 3a de cb			ld a, (.dmark+1)  
cbd2 32 63 ee			ld (debug_mark+1),a  
cbd5 3a df cb			ld a, (.dmark+2)  
cbd8 32 64 ee			ld (debug_mark+2),a  
cbdb 18 03			jr .pastdmark  
cbdd ..			.dmark: db "AS2"  
cbe0 f1			.pastdmark: pop af  
cbe1			endm  
# End of macro DMARK
cbe1						CALLMONITOR 
cbe1 cd 6f ee			call debug_vector  
cbe4				endm  
# End of macro CALLMONITOR
cbe4					endif 
cbe4 cd cb 99				call forth_push_numhl 
cbe7			 
cbe7				       NEXTW 
cbe7 cd 6c ee			call parse_vector 
cbea c3 ae 9d			jp macro_next 
cbed				endm 
# End of macro NEXTW
cbed			 
cbed			.CHR: 
cbed				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
cbed 4d				db WORD_SYS_CORE+57             
cbee 2c cc			dw .ENDSTR            
cbf0 04				db 3 + 1 
cbf1 .. 00			db "CHR",0              
cbf5				endm 
# End of macro CWHEAD
cbf5			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
cbf5					if DEBUG_FORTH_WORDS_KEY 
cbf5						DMARK "CHR" 
cbf5 f5				push af  
cbf6 3a 0a cc			ld a, (.dmark)  
cbf9 32 62 ee			ld (debug_mark),a  
cbfc 3a 0b cc			ld a, (.dmark+1)  
cbff 32 63 ee			ld (debug_mark+1),a  
cc02 3a 0c cc			ld a, (.dmark+2)  
cc05 32 64 ee			ld (debug_mark+2),a  
cc08 18 03			jr .pastdmark  
cc0a ..			.dmark: db "CHR"  
cc0d f1			.pastdmark: pop af  
cc0e			endm  
# End of macro DMARK
cc0e						CALLMONITOR 
cc0e cd 6f ee			call debug_vector  
cc11				endm  
# End of macro CALLMONITOR
cc11					endif 
cc11					FORTH_DSP_VALUEHL 
cc11 cd c7 9b			call macro_dsp_valuehl 
cc14				endm 
# End of macro FORTH_DSP_VALUEHL
cc14			 
cc14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cc14 cd 7f 9c			call macro_forth_dsp_pop 
cc17				endm 
# End of macro FORTH_DSP_POP
cc17			 
cc17					; save asci byte as a zero term string and push string 
cc17			 
cc17 7d					ld a,l 
cc18 32 b8 e2				ld (scratch), a 
cc1b			 
cc1b 3e 00				ld a, 0 
cc1d 32 b9 e2				ld (scratch+1), a 
cc20			 
cc20 21 b8 e2				ld hl, scratch 
cc23 cd 35 9a				call forth_push_str 
cc26			 
cc26			 
cc26				       NEXTW 
cc26 cd 6c ee			call parse_vector 
cc29 c3 ae 9d			jp macro_next 
cc2c				endm 
# End of macro NEXTW
cc2c			 
cc2c			 
cc2c			 
cc2c			 
cc2c			.ENDSTR: 
cc2c			; eof 
cc2c			 
# End of file forth_words_str.asm
cc2c			include "forth_words_key.asm" 
cc2c			 
cc2c			; | ## Keyboard Words 
cc2c			 
cc2c			.KEY: 
cc2c				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
cc2c 3e				db WORD_SYS_CORE+42             
cc2d 5f cc			dw .KEYDB            
cc2f 04				db 3 + 1 
cc30 .. 00			db "KEY",0              
cc34				endm 
# End of macro CWHEAD
cc34			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
cc34			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
cc34			; | | Can use something like this to process: 
cc34			; | | > repeat active . key ?dup if emit then #1 until  
cc34			 
cc34					if DEBUG_FORTH_WORDS_KEY 
cc34						DMARK "KEY" 
cc34 f5				push af  
cc35 3a 49 cc			ld a, (.dmark)  
cc38 32 62 ee			ld (debug_mark),a  
cc3b 3a 4a cc			ld a, (.dmark+1)  
cc3e 32 63 ee			ld (debug_mark+1),a  
cc41 3a 4b cc			ld a, (.dmark+2)  
cc44 32 64 ee			ld (debug_mark+2),a  
cc47 18 03			jr .pastdmark  
cc49 ..			.dmark: db "KEY"  
cc4c f1			.pastdmark: pop af  
cc4d			endm  
# End of macro DMARK
cc4d						CALLMONITOR 
cc4d cd 6f ee			call debug_vector  
cc50				endm  
# End of macro CALLMONITOR
cc50					endif 
cc50			; TODO currently waits 
cc50 cd 86 e3				call cinndb 
cc53					;call cin_wait 
cc53 6f					ld l, a 
cc54 26 00				ld h, 0 
cc56 cd cb 99				call forth_push_numhl 
cc59					NEXTW 
cc59 cd 6c ee			call parse_vector 
cc5c c3 ae 9d			jp macro_next 
cc5f				endm 
# End of macro NEXTW
cc5f			.KEYDB: 
cc5f				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
cc5f 3e				db WORD_SYS_CORE+42             
cc60 94 cc			dw .WAITK            
cc62 06				db 5 + 1 
cc63 .. 00			db "KEYDB",0              
cc69				endm 
# End of macro CWHEAD
cc69			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
cc69			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
cc69			; | | Can use something like this to process: 
cc69			; | | > repeat active . key ?dup if emit then #1 until  
cc69			 
cc69					if DEBUG_FORTH_WORDS_KEY 
cc69						DMARK "KEB" 
cc69 f5				push af  
cc6a 3a 7e cc			ld a, (.dmark)  
cc6d 32 62 ee			ld (debug_mark),a  
cc70 3a 7f cc			ld a, (.dmark+1)  
cc73 32 63 ee			ld (debug_mark+1),a  
cc76 3a 80 cc			ld a, (.dmark+2)  
cc79 32 64 ee			ld (debug_mark+2),a  
cc7c 18 03			jr .pastdmark  
cc7e ..			.dmark: db "KEB"  
cc81 f1			.pastdmark: pop af  
cc82			endm  
# End of macro DMARK
cc82						CALLMONITOR 
cc82 cd 6f ee			call debug_vector  
cc85				endm  
# End of macro CALLMONITOR
cc85					endif 
cc85			; TODO currently waits 
cc85 cd 86 e3				call cin 
cc88					;call cin_wait 
cc88 6f					ld l, a 
cc89 26 00				ld h, 0 
cc8b cd cb 99				call forth_push_numhl 
cc8e					NEXTW 
cc8e cd 6c ee			call parse_vector 
cc91 c3 ae 9d			jp macro_next 
cc94				endm 
# End of macro NEXTW
cc94			.WAITK: 
cc94				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
cc94 3f				db WORD_SYS_CORE+43             
cc95 c9 cc			dw .ACCEPT            
cc97 06				db 5 + 1 
cc98 .. 00			db "WAITK",0              
cc9e				endm 
# End of macro CWHEAD
cc9e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
cc9e					if DEBUG_FORTH_WORDS_KEY 
cc9e						DMARK "WAI" 
cc9e f5				push af  
cc9f 3a b3 cc			ld a, (.dmark)  
cca2 32 62 ee			ld (debug_mark),a  
cca5 3a b4 cc			ld a, (.dmark+1)  
cca8 32 63 ee			ld (debug_mark+1),a  
ccab 3a b5 cc			ld a, (.dmark+2)  
ccae 32 64 ee			ld (debug_mark+2),a  
ccb1 18 03			jr .pastdmark  
ccb3 ..			.dmark: db "WAI"  
ccb6 f1			.pastdmark: pop af  
ccb7			endm  
# End of macro DMARK
ccb7						CALLMONITOR 
ccb7 cd 6f ee			call debug_vector  
ccba				endm  
# End of macro CALLMONITOR
ccba					endif 
ccba cd 80 e3				call cin_wait 
ccbd 6f					ld l, a 
ccbe 26 00				ld h, 0 
ccc0 cd cb 99				call forth_push_numhl 
ccc3					NEXTW 
ccc3 cd 6c ee			call parse_vector 
ccc6 c3 ae 9d			jp macro_next 
ccc9				endm 
# End of macro NEXTW
ccc9			.ACCEPT: 
ccc9				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
ccc9 40				db WORD_SYS_CORE+44             
ccca 29 cd			dw .EDIT            
cccc 07				db 6 + 1 
cccd .. 00			db "ACCEPT",0              
ccd4				endm 
# End of macro CWHEAD
ccd4			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
ccd4					; TODO crashes on push 
ccd4					if DEBUG_FORTH_WORDS_KEY 
ccd4						DMARK "ACC" 
ccd4 f5				push af  
ccd5 3a e9 cc			ld a, (.dmark)  
ccd8 32 62 ee			ld (debug_mark),a  
ccdb 3a ea cc			ld a, (.dmark+1)  
ccde 32 63 ee			ld (debug_mark+1),a  
cce1 3a eb cc			ld a, (.dmark+2)  
cce4 32 64 ee			ld (debug_mark+2),a  
cce7 18 03			jr .pastdmark  
cce9 ..			.dmark: db "ACC"  
ccec f1			.pastdmark: pop af  
cced			endm  
# End of macro DMARK
cced						CALLMONITOR 
cced cd 6f ee			call debug_vector  
ccf0				endm  
# End of macro CALLMONITOR
ccf0					endif 
ccf0 21 b6 e4				ld hl, os_input 
ccf3			;		ld a, 0 
ccf3 36 00				ld (hl),0 
ccf5 3a 55 ea				ld a,(f_cursor_ptr) 
ccf8 16 64				ld d, 100 
ccfa 0e 00				ld c, 0 
ccfc 1e 28				ld e, 40 
ccfe cd 03 8d				call input_str 
cd01					; TODO perhaps do a type check and wrap in quotes if not a number 
cd01 21 b6 e4				ld hl, os_input 
cd04					if DEBUG_FORTH_WORDS 
cd04						DMARK "AC1" 
cd04 f5				push af  
cd05 3a 19 cd			ld a, (.dmark)  
cd08 32 62 ee			ld (debug_mark),a  
cd0b 3a 1a cd			ld a, (.dmark+1)  
cd0e 32 63 ee			ld (debug_mark+1),a  
cd11 3a 1b cd			ld a, (.dmark+2)  
cd14 32 64 ee			ld (debug_mark+2),a  
cd17 18 03			jr .pastdmark  
cd19 ..			.dmark: db "AC1"  
cd1c f1			.pastdmark: pop af  
cd1d			endm  
# End of macro DMARK
cd1d						CALLMONITOR 
cd1d cd 6f ee			call debug_vector  
cd20				endm  
# End of macro CALLMONITOR
cd20					endif 
cd20 cd 35 9a				call forth_push_str 
cd23					NEXTW 
cd23 cd 6c ee			call parse_vector 
cd26 c3 ae 9d			jp macro_next 
cd29				endm 
# End of macro NEXTW
cd29			 
cd29			.EDIT: 
cd29				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
cd29 40				db WORD_SYS_CORE+44             
cd2a ce cd			dw .DEDIT            
cd2c 05				db 4 + 1 
cd2d .. 00			db "EDIT",0              
cd32				endm 
# End of macro CWHEAD
cd32			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
cd32			 
cd32					; TODO does not copy from stack 
cd32					if DEBUG_FORTH_WORDS_KEY 
cd32						DMARK "EDT" 
cd32 f5				push af  
cd33 3a 47 cd			ld a, (.dmark)  
cd36 32 62 ee			ld (debug_mark),a  
cd39 3a 48 cd			ld a, (.dmark+1)  
cd3c 32 63 ee			ld (debug_mark+1),a  
cd3f 3a 49 cd			ld a, (.dmark+2)  
cd42 32 64 ee			ld (debug_mark+2),a  
cd45 18 03			jr .pastdmark  
cd47 ..			.dmark: db "EDT"  
cd4a f1			.pastdmark: pop af  
cd4b			endm  
# End of macro DMARK
cd4b						CALLMONITOR 
cd4b cd 6f ee			call debug_vector  
cd4e				endm  
# End of macro CALLMONITOR
cd4e					endif 
cd4e			 
cd4e					;FORTH_DSP 
cd4e					FORTH_DSP_VALUEHL 
cd4e cd c7 9b			call macro_dsp_valuehl 
cd51				endm 
# End of macro FORTH_DSP_VALUEHL
cd51			;		inc hl    ; TODO do type check 
cd51			 
cd51			;		call get_word_hl 
cd51 e5					push hl 
cd52					if DEBUG_FORTH_WORDS 
cd52						DMARK "EDp" 
cd52 f5				push af  
cd53 3a 67 cd			ld a, (.dmark)  
cd56 32 62 ee			ld (debug_mark),a  
cd59 3a 68 cd			ld a, (.dmark+1)  
cd5c 32 63 ee			ld (debug_mark+1),a  
cd5f 3a 69 cd			ld a, (.dmark+2)  
cd62 32 64 ee			ld (debug_mark+2),a  
cd65 18 03			jr .pastdmark  
cd67 ..			.dmark: db "EDp"  
cd6a f1			.pastdmark: pop af  
cd6b			endm  
# End of macro DMARK
cd6b						CALLMONITOR 
cd6b cd 6f ee			call debug_vector  
cd6e				endm  
# End of macro CALLMONITOR
cd6e					endif 
cd6e				;	ld a, 0 
cd6e cd 2e 90				call strlenz 
cd71 23					inc hl 
cd72			 
cd72 06 00				ld b, 0 
cd74 4d					ld c, l 
cd75			 
cd75 e1					pop hl 
cd76 11 b6 e4				ld de, os_input 
cd79					if DEBUG_FORTH_WORDS_KEY 
cd79						DMARK "EDc" 
cd79 f5				push af  
cd7a 3a 8e cd			ld a, (.dmark)  
cd7d 32 62 ee			ld (debug_mark),a  
cd80 3a 8f cd			ld a, (.dmark+1)  
cd83 32 63 ee			ld (debug_mark+1),a  
cd86 3a 90 cd			ld a, (.dmark+2)  
cd89 32 64 ee			ld (debug_mark+2),a  
cd8c 18 03			jr .pastdmark  
cd8e ..			.dmark: db "EDc"  
cd91 f1			.pastdmark: pop af  
cd92			endm  
# End of macro DMARK
cd92						CALLMONITOR 
cd92 cd 6f ee			call debug_vector  
cd95				endm  
# End of macro CALLMONITOR
cd95					endif 
cd95 ed b0				ldir 
cd97			 
cd97			 
cd97 21 b6 e4				ld hl, os_input 
cd9a					;ld a, 0 
cd9a					;ld (hl),a 
cd9a 3a 55 ea				ld a,(f_cursor_ptr) 
cd9d 16 64				ld d, 100 
cd9f 0e 00				ld c, 0 
cda1 1e 28				ld e, 40 
cda3 cd 03 8d				call input_str 
cda6					; TODO perhaps do a type check and wrap in quotes if not a number 
cda6 21 b6 e4				ld hl, os_input 
cda9					if DEBUG_FORTH_WORDS 
cda9						DMARK "ED1" 
cda9 f5				push af  
cdaa 3a be cd			ld a, (.dmark)  
cdad 32 62 ee			ld (debug_mark),a  
cdb0 3a bf cd			ld a, (.dmark+1)  
cdb3 32 63 ee			ld (debug_mark+1),a  
cdb6 3a c0 cd			ld a, (.dmark+2)  
cdb9 32 64 ee			ld (debug_mark+2),a  
cdbc 18 03			jr .pastdmark  
cdbe ..			.dmark: db "ED1"  
cdc1 f1			.pastdmark: pop af  
cdc2			endm  
# End of macro DMARK
cdc2						CALLMONITOR 
cdc2 cd 6f ee			call debug_vector  
cdc5				endm  
# End of macro CALLMONITOR
cdc5					endif 
cdc5 cd 35 9a				call forth_push_str 
cdc8					NEXTW 
cdc8 cd 6c ee			call parse_vector 
cdcb c3 ae 9d			jp macro_next 
cdce				endm 
# End of macro NEXTW
cdce			 
cdce			.DEDIT: 
cdce				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
cdce 40				db WORD_SYS_CORE+44             
cdcf 33 ce			dw .ENDKEY            
cdd1 06				db 5 + 1 
cdd2 .. 00			db "DEDIT",0              
cdd8				endm 
# End of macro CWHEAD
cdd8			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
cdd8			 
cdd8					; TODO does not copy from stack 
cdd8					if DEBUG_FORTH_WORDS_KEY 
cdd8						DMARK "DED" 
cdd8 f5				push af  
cdd9 3a ed cd			ld a, (.dmark)  
cddc 32 62 ee			ld (debug_mark),a  
cddf 3a ee cd			ld a, (.dmark+1)  
cde2 32 63 ee			ld (debug_mark+1),a  
cde5 3a ef cd			ld a, (.dmark+2)  
cde8 32 64 ee			ld (debug_mark+2),a  
cdeb 18 03			jr .pastdmark  
cded ..			.dmark: db "DED"  
cdf0 f1			.pastdmark: pop af  
cdf1			endm  
# End of macro DMARK
cdf1						CALLMONITOR 
cdf1 cd 6f ee			call debug_vector  
cdf4				endm  
# End of macro CALLMONITOR
cdf4					endif 
cdf4			 
cdf4					;FORTH_DSP 
cdf4					FORTH_DSP_VALUEHL 
cdf4 cd c7 9b			call macro_dsp_valuehl 
cdf7				endm 
# End of macro FORTH_DSP_VALUEHL
cdf7			;		inc hl    ; TODO do type check 
cdf7			 
cdf7			;		call get_word_hl 
cdf7 e5					push hl 
cdf8 e5					push hl 
cdf9					FORTH_DSP_POP 
cdf9 cd 7f 9c			call macro_forth_dsp_pop 
cdfc				endm 
# End of macro FORTH_DSP_POP
cdfc e1					pop hl 
cdfd					if DEBUG_FORTH_WORDS 
cdfd						DMARK "EDp" 
cdfd f5				push af  
cdfe 3a 12 ce			ld a, (.dmark)  
ce01 32 62 ee			ld (debug_mark),a  
ce04 3a 13 ce			ld a, (.dmark+1)  
ce07 32 63 ee			ld (debug_mark+1),a  
ce0a 3a 14 ce			ld a, (.dmark+2)  
ce0d 32 64 ee			ld (debug_mark+2),a  
ce10 18 03			jr .pastdmark  
ce12 ..			.dmark: db "EDp"  
ce15 f1			.pastdmark: pop af  
ce16			endm  
# End of macro DMARK
ce16						CALLMONITOR 
ce16 cd 6f ee			call debug_vector  
ce19				endm  
# End of macro CALLMONITOR
ce19					endif 
ce19				;	ld a, 0 
ce19 cd 2e 90				call strlenz 
ce1c 23					inc hl 
ce1d			 
ce1d 06 00				ld b, 0 
ce1f 4d					ld c, l 
ce20			 
ce20 e1					pop hl 
ce21			 
ce21					;ld a, 0 
ce21					;ld (hl),a 
ce21 3a 55 ea				ld a,(f_cursor_ptr) 
ce24 16 64				ld d, 100 
ce26 0e 00				ld c, 0 
ce28 1e 28				ld e, 40 
ce2a cd 03 8d				call input_str 
ce2d					; TODO perhaps do a type check and wrap in quotes if not a number 
ce2d					NEXTW 
ce2d cd 6c ee			call parse_vector 
ce30 c3 ae 9d			jp macro_next 
ce33				endm 
# End of macro NEXTW
ce33			 
ce33			 
ce33			.ENDKEY: 
ce33			; eof 
ce33			 
# End of file forth_words_key.asm
ce33			include "forth_words_const.asm" 
ce33			 
ce33			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
ce33			 
ce33			 
ce33			.SPITIME: 
ce33				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
ce33 77				db WORD_SYS_CORE+99             
ce34 4b ce			dw .VA            
ce36 08				db 7 + 1 
ce37 .. 00			db "SPITIME",0              
ce3f				endm 
# End of macro CWHEAD
ce3f			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
ce3f			; 
ce3f			; | | If using BANK devices then leave as is. 
ce3f			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
ce3f			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
ce3f			 
ce3f 21 5b ea				ld hl, spi_clktime  
ce42 cd cb 99				call forth_push_numhl 
ce45			 
ce45					NEXTW 
ce45 cd 6c ee			call parse_vector 
ce48 c3 ae 9d			jp macro_next 
ce4b				endm 
# End of macro NEXTW
ce4b			 
ce4b			 
ce4b			.VA: 
ce4b				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
ce4b 77				db WORD_SYS_CORE+99             
ce4c 5e ce			dw .SYMBOL            
ce4e 03				db 2 + 1 
ce4f .. 00			db "VA",0              
ce52				endm 
# End of macro CWHEAD
ce52			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
ce52 21 1f ea				ld hl, cli_var_array 
ce55 cd cb 99				call forth_push_numhl 
ce58			 
ce58					NEXTW 
ce58 cd 6c ee			call parse_vector 
ce5b c3 ae 9d			jp macro_next 
ce5e				endm 
# End of macro NEXTW
ce5e			 
ce5e			.SYMBOL: 
ce5e				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
ce5e 77				db WORD_SYS_CORE+99             
ce5f 6d cf			dw .ENDCONST            
ce61 07				db 6 + 1 
ce62 .. 00			db "SYMBOL",0              
ce69				endm 
# End of macro CWHEAD
ce69			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
ce69			; | 
ce69			; | | The value is the number reference and the final address is pushed to stack 
ce69			 
ce69			; | | ``` 
ce69			; | | dw sym_table 
ce69			; | | dw nmi_vector 
ce69			; | | dw cli_autodisplay 
ce69			; | | dw cli_data_sp 
ce69			; | | dw cli_data_stack 
ce69			; | | dw cli_loop_sp 
ce69			; | | dw cli_loop_stack 
ce69			; | | dw cli_var_array 
ce69			; | | dw cursor_col 
ce69			; | | dw cursor_ptr 
ce69			; | | ; 10 
ce69			; | | dw cursor_row 
ce69			; | | dw debug_mark 
ce69			; | | dw display_fb0 
ce69			; | | dw display_fb1 
ce69			; | | dw display_fb2 
ce69			; | | dw display_fb3 
ce69			; | | dw display_fb_active 
ce69			; | | dw execscratch 
ce69			; | | dw f_cursor_ptr 
ce69			; | | dw hardware_word 
ce69			; | | ;20 
ce69			; | | dw input_at_cursor 
ce69			; | | dw input_at_pos 
ce69			; | | dw input_cur_flash 
ce69			; | | dw input_cur_onoff 
ce69			; | | dw input_cursor 
ce69			; | | dw input_display_size 
ce69			; | | dw input_len 
ce69			; | | dw input_ptr 
ce69			; | | dw input_size 
ce69			; | | dw input_start 
ce69			; | | ; 30 
ce69			; | | dw input_str 
ce69			; | | dw input_under_cursor 
ce69			; | | dw os_cli_cmd 
ce69			; | | dw os_cur_ptr 
ce69			; | | dw os_current_i 
ce69			; | | dw os_input 
ce69			; | | dw os_last_cmd 
ce69			; | | dw os_last_new_uword 
ce69			; | | dw debug_vector 
ce69			; | | dw os_view_hl 
ce69			; | | ;40 
ce69			; | | dw os_word_scratch 
ce69			; | | dw portbctl 
ce69			; | | dw portbdata 
ce69			; | | dw spi_cartdev 
ce69			; | | dw spi_cartdev2 
ce69			; | | dw spi_clktime 
ce69			; | | dw spi_device 
ce69			; | | dw spi_device_id 
ce69			; | | dw spi_portbyte 
ce69			; | | dw stackstore 
ce69			; | | ; 50 
ce69			; | | if STORAGE_SE 
ce69			; | | dw storage_actl 
ce69			; | | dw storage_adata 
ce69			; | | else 
ce69			; | | dw 0 
ce69			; | | dw 0 
ce69			; | | endif 
ce69			; | | dw storage_append 
ce69			; | | if STORAGE_SE 
ce69			; | | dw storage_bctl 
ce69			; | | else 
ce69			; | | dw 0 
ce69			; | | endif 
ce69			; | | dw store_bank_active 
ce69			; | | dw store_filecache 
ce69			; | | dw store_longread 
ce69			; | | dw store_openaddr 
ce69			; | | dw store_openext 
ce69			; | | dw store_openmaxext 
ce69			; | | ; 60 
ce69			; | | dw store_page 
ce69			; | | dw store_readbuf 
ce69			; | | dw store_readcont 
ce69			; | | dw store_readptr 
ce69			; | | dw store_tmpext 
ce69			; | | dw store_tmpid 
ce69			; | | dw store_tmppageid 
ce69			; | | dw malloc 
ce69			; | | dw free 
ce69			; | | dw cin 
ce69			; | | ; 70 
ce69			; | | dw cin_wait 
ce69			; | | dw forth_push_numhl 
ce69			; | | dw forth_push_str 
ce69			; | | dw parse_vector 
ce69			; | | ``` 
ce69			 
ce69					if DEBUG_FORTH_WORDS_KEY 
ce69						DMARK "SYM" 
ce69 f5				push af  
ce6a 3a 7e ce			ld a, (.dmark)  
ce6d 32 62 ee			ld (debug_mark),a  
ce70 3a 7f ce			ld a, (.dmark+1)  
ce73 32 63 ee			ld (debug_mark+1),a  
ce76 3a 80 ce			ld a, (.dmark+2)  
ce79 32 64 ee			ld (debug_mark+2),a  
ce7c 18 03			jr .pastdmark  
ce7e ..			.dmark: db "SYM"  
ce81 f1			.pastdmark: pop af  
ce82			endm  
# End of macro DMARK
ce82						CALLMONITOR 
ce82 cd 6f ee			call debug_vector  
ce85				endm  
# End of macro CALLMONITOR
ce85					endif 
ce85			 
ce85					FORTH_DSP_VALUEHL 
ce85 cd c7 9b			call macro_dsp_valuehl 
ce88				endm 
# End of macro FORTH_DSP_VALUEHL
ce88			 
ce88 7d					ld a, l     
ce89			 
ce89			 
ce89					if DEBUG_FORTH_WORDS 
ce89						DMARK "SY1" 
ce89 f5				push af  
ce8a 3a 9e ce			ld a, (.dmark)  
ce8d 32 62 ee			ld (debug_mark),a  
ce90 3a 9f ce			ld a, (.dmark+1)  
ce93 32 63 ee			ld (debug_mark+1),a  
ce96 3a a0 ce			ld a, (.dmark+2)  
ce99 32 64 ee			ld (debug_mark+2),a  
ce9c 18 03			jr .pastdmark  
ce9e ..			.dmark: db "SY1"  
cea1 f1			.pastdmark: pop af  
cea2			endm  
# End of macro DMARK
cea2						CALLMONITOR 
cea2 cd 6f ee			call debug_vector  
cea5				endm  
# End of macro CALLMONITOR
cea5					endif 
cea5					 
cea5 f5					push af	 
cea6					FORTH_DSP_POP 
cea6 cd 7f 9c			call macro_forth_dsp_pop 
cea9				endm 
# End of macro FORTH_DSP_POP
cea9 f1					pop af 
ceaa			 
ceaa cb 27				sla a  
ceac				 
ceac					 
ceac					if DEBUG_FORTH_WORDS 
ceac						DMARK "SY" 
ceac f5				push af  
cead 3a c1 ce			ld a, (.dmark)  
ceb0 32 62 ee			ld (debug_mark),a  
ceb3 3a c2 ce			ld a, (.dmark+1)  
ceb6 32 63 ee			ld (debug_mark+1),a  
ceb9 3a c3 ce			ld a, (.dmark+2)  
cebc 32 64 ee			ld (debug_mark+2),a  
cebf 18 02			jr .pastdmark  
cec1 ..			.dmark: db "SY"  
cec3 f1			.pastdmark: pop af  
cec4			endm  
# End of macro DMARK
cec4						CALLMONITOR 
cec4 cd 6f ee			call debug_vector  
cec7				endm  
# End of macro CALLMONITOR
cec7					endif 
cec7			 
cec7 21 d9 ce				ld hl, sym_table 
ceca cd d6 8c				call addatohl 
cecd cd 34 9d				call loadwordinhl 
ced0 cd cb 99				call forth_push_numhl 
ced3			 
ced3			 
ced3				       NEXTW 
ced3 cd 6c ee			call parse_vector 
ced6 c3 ae 9d			jp macro_next 
ced9				endm 
# End of macro NEXTW
ced9			 
ced9			sym_table: 
ced9			 
ced9			; 0 
ced9 d9 ce		dw sym_table 
cedb 72 ee		dw nmi_vector 
cedd 33 ea		dw cli_autodisplay 
cedf e5 e9		dw cli_data_sp 
cee1 1f e8		dw cli_data_stack 
cee3 e7 e9		dw cli_loop_sp 
cee5 21 e9		dw cli_loop_stack 
cee7 1f ea		dw cli_var_array 
cee9 bc eb		dw cursor_col 
ceeb ba eb		dw cursor_ptr 
ceed			; 10 
ceed bb eb		dw cursor_row 
ceef 62 ee		dw debug_mark 
cef1 a8 ed		dw display_fb0 
cef3 07 ed		dw display_fb1 
cef5 c5 eb		dw display_fb2 
cef7 66 ec		dw display_fb3 
cef9 c3 eb		dw display_fb_active 
cefb b7 e3		dw execscratch 
cefd 55 ea		dw f_cursor_ptr 
ceff 75 ee		dw hardware_word 
cf01			;20 
cf01 59 ee		dw input_at_cursor 
cf03 5b ee		dw input_at_pos 
cf05 57 ee		dw input_cur_flash 
cf07 56 ee		dw input_cur_onoff 
cf09 4c ee		dw input_cursor 
cf0b 5c ee		dw input_display_size 
cf0d 51 ee		dw input_len 
cf0f 60 ee		dw input_ptr 
cf11 5d ee		dw input_size 
cf13 5e ee		dw input_start 
cf15			; 30 
cf15 03 8d		dw input_str 
cf17 5a ee		dw input_under_cursor 
cf19 df e5		dw os_cli_cmd 
cf1b db e5		dw os_cur_ptr 
cf1d dd e5		dw os_current_i 
cf1f b6 e4		dw os_input 
cf21 de e6		dw os_last_cmd 
cf23 b5 e5		dw os_last_new_uword 
cf25 6f ee		dw debug_vector 
cf27 9a e2		dw os_view_hl 
cf29			;40 
cf29 bd e5		dw os_word_scratch 
cf2b c3 00		dw portbctl 
cf2d c1 00		dw portbdata 
cf2f 5a ea		dw spi_cartdev 
cf31 59 ea		dw spi_cartdev2 
cf33 5b ea		dw spi_clktime 
cf35 57 ea		dw spi_device 
cf37 56 ea		dw spi_device_id 
cf39 58 ea		dw spi_portbyte 
cf3b 9e eb		dw stackstore 
cf3d			; 50 
cf3d			if STORAGE_SE 
cf3d			dw storage_actl 
cf3d			dw storage_adata 
cf3d			else 
cf3d 00 00		dw 0 
cf3f 00 00		dw 0 
cf41			endif 
cf41 6b 88		dw storage_append 
cf43			if STORAGE_SE 
cf43			dw storage_bctl 
cf43			else 
cf43 00 00		dw 0 
cf45			endif 
cf45 8a eb		dw store_bank_active 
cf47 5e ea		dw store_filecache 
cf49 6c ea		dw store_longread 
cf4b 62 ea		dw store_openaddr 
cf4d 61 ea		dw store_openext 
cf4f 60 ea		dw store_openmaxext 
cf51			; 60 
cf51 71 ea		dw store_page 
cf53 6d ea		dw store_readbuf 
cf55 64 ea		dw store_readcont 
cf57 6f ea		dw store_readptr 
cf59 64 ea		dw store_tmpext 
cf5b 65 ea		dw store_tmpid 
cf5d 5c ea		dw store_tmppageid 
cf5f a2 90		dw malloc 
cf61 6c 91		dw free 
cf63 86 e3		dw cin 
cf65			; 70 
cf65 80 e3		dw cin_wait 
cf67 cb 99		dw forth_push_numhl 
cf69 35 9a		dw forth_push_str 
cf6b 6c ee		dw parse_vector 
cf6d			 
cf6d			.ENDCONST: 
cf6d			 
cf6d			; eof 
cf6d			 
cf6d			 
# End of file forth_words_const.asm
cf6d			 
cf6d			if STORAGE_SE 
cf6d			   	include "forth_words_storage.asm" 
cf6d			endif 
cf6d				include "forth_words_device.asm" 
cf6d			; Device related words 
cf6d			 
cf6d			; | ## Device Words 
cf6d			 
cf6d			;if SOUND_ENABLE 
cf6d			;.NOTE: 
cf6d			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
cf6d			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
cf6d			;		if DEBUG_FORTH_WORDS_KEY 
cf6d			;			DMARK "NTE" 
cf6d			;			CALLMONITOR 
cf6d			;		endif 
cf6d			; 
cf6d			;	 
cf6d			; 
cf6d			;		NEXTW 
cf6d			;.AFTERSOUND: 
cf6d			;endif 
cf6d			 
cf6d			 
cf6d			USE_GPIO: equ 0 
cf6d			 
cf6d			if USE_GPIO 
cf6d			.GP1: 
cf6d				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
cf6d			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
cf6d					NEXTW 
cf6d			.GP2: 
cf6d				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
cf6d			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
cf6d			 
cf6d					NEXTW 
cf6d			 
cf6d			.GP3: 
cf6d				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
cf6d			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
cf6d			 
cf6d					NEXTW 
cf6d			 
cf6d			.GP4: 
cf6d				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
cf6d			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
cf6d			 
cf6d					NEXTW 
cf6d			.SIN: 
cf6d			 
cf6d			 
cf6d			endif 
cf6d			 
cf6d			 
cf6d				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
cf6d 33				db WORD_SYS_CORE+31             
cf6e a5 cf			dw .SOUT            
cf70 03				db 2 + 1 
cf71 .. 00			db "IN",0              
cf74				endm 
# End of macro CWHEAD
cf74			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
cf74					if DEBUG_FORTH_WORDS_KEY 
cf74						DMARK "IN." 
cf74 f5				push af  
cf75 3a 89 cf			ld a, (.dmark)  
cf78 32 62 ee			ld (debug_mark),a  
cf7b 3a 8a cf			ld a, (.dmark+1)  
cf7e 32 63 ee			ld (debug_mark+1),a  
cf81 3a 8b cf			ld a, (.dmark+2)  
cf84 32 64 ee			ld (debug_mark+2),a  
cf87 18 03			jr .pastdmark  
cf89 ..			.dmark: db "IN."  
cf8c f1			.pastdmark: pop af  
cf8d			endm  
# End of macro DMARK
cf8d						CALLMONITOR 
cf8d cd 6f ee			call debug_vector  
cf90				endm  
# End of macro CALLMONITOR
cf90					endif 
cf90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cf90 cd c7 9b			call macro_dsp_valuehl 
cf93				endm 
# End of macro FORTH_DSP_VALUEHL
cf93			 
cf93 e5					push hl 
cf94			 
cf94					; destroy value TOS 
cf94			 
cf94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cf94 cd 7f 9c			call macro_forth_dsp_pop 
cf97				endm 
# End of macro FORTH_DSP_POP
cf97			 
cf97					; one value on hl get other one back 
cf97			 
cf97 c1					pop bc 
cf98			 
cf98					; do the sub 
cf98			;		ex de, hl 
cf98			 
cf98 ed 68				in l,(c) 
cf9a			 
cf9a					; save it 
cf9a			 
cf9a 26 00				ld h,0 
cf9c			 
cf9c					; TODO push value back onto stack for another op etc 
cf9c			 
cf9c cd cb 99				call forth_push_numhl 
cf9f					NEXTW 
cf9f cd 6c ee			call parse_vector 
cfa2 c3 ae 9d			jp macro_next 
cfa5				endm 
# End of macro NEXTW
cfa5			.SOUT: 
cfa5				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
cfa5 34				db WORD_SYS_CORE+32             
cfa6 fb cf			dw .SPIO            
cfa8 04				db 3 + 1 
cfa9 .. 00			db "OUT",0              
cfad				endm 
# End of macro CWHEAD
cfad			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
cfad					if DEBUG_FORTH_WORDS_KEY 
cfad						DMARK "OUT" 
cfad f5				push af  
cfae 3a c2 cf			ld a, (.dmark)  
cfb1 32 62 ee			ld (debug_mark),a  
cfb4 3a c3 cf			ld a, (.dmark+1)  
cfb7 32 63 ee			ld (debug_mark+1),a  
cfba 3a c4 cf			ld a, (.dmark+2)  
cfbd 32 64 ee			ld (debug_mark+2),a  
cfc0 18 03			jr .pastdmark  
cfc2 ..			.dmark: db "OUT"  
cfc5 f1			.pastdmark: pop af  
cfc6			endm  
# End of macro DMARK
cfc6						CALLMONITOR 
cfc6 cd 6f ee			call debug_vector  
cfc9				endm  
# End of macro CALLMONITOR
cfc9					endif 
cfc9			 
cfc9					; get port 
cfc9			 
cfc9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cfc9 cd c7 9b			call macro_dsp_valuehl 
cfcc				endm 
# End of macro FORTH_DSP_VALUEHL
cfcc			 
cfcc e5					push hl 
cfcd			 
cfcd					; destroy value TOS 
cfcd			 
cfcd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cfcd cd 7f 9c			call macro_forth_dsp_pop 
cfd0				endm 
# End of macro FORTH_DSP_POP
cfd0			 
cfd0					; get byte to send 
cfd0			 
cfd0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cfd0 cd c7 9b			call macro_dsp_valuehl 
cfd3				endm 
# End of macro FORTH_DSP_VALUEHL
cfd3			 
cfd3			;		push hl 
cfd3			 
cfd3					; destroy value TOS 
cfd3			 
cfd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cfd3 cd 7f 9c			call macro_forth_dsp_pop 
cfd6				endm 
# End of macro FORTH_DSP_POP
cfd6			 
cfd6					; one value on hl get other one back 
cfd6			 
cfd6			;		pop hl 
cfd6			 
cfd6 c1					pop bc 
cfd7			 
cfd7					if DEBUG_FORTH_WORDS 
cfd7						DMARK "OUT" 
cfd7 f5				push af  
cfd8 3a ec cf			ld a, (.dmark)  
cfdb 32 62 ee			ld (debug_mark),a  
cfde 3a ed cf			ld a, (.dmark+1)  
cfe1 32 63 ee			ld (debug_mark+1),a  
cfe4 3a ee cf			ld a, (.dmark+2)  
cfe7 32 64 ee			ld (debug_mark+2),a  
cfea 18 03			jr .pastdmark  
cfec ..			.dmark: db "OUT"  
cfef f1			.pastdmark: pop af  
cff0			endm  
# End of macro DMARK
cff0						CALLMONITOR 
cff0 cd 6f ee			call debug_vector  
cff3				endm  
# End of macro CALLMONITOR
cff3					endif 
cff3			 
cff3 ed 69				out (c), l 
cff5			 
cff5					NEXTW 
cff5 cd 6c ee			call parse_vector 
cff8 c3 ae 9d			jp macro_next 
cffb				endm 
# End of macro NEXTW
cffb			 
cffb			 
cffb			.SPIO: 
cffb			 
cffb			if STORAGE_SE 
cffb				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
cffb			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
cffb			 
cffb					call spi_ce_low 
cffb			    NEXTW 
cffb			 
cffb			.SPICEH: 
cffb				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
cffb			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
cffb			 
cffb					call spi_ce_high 
cffb			    NEXTW 
cffb			 
cffb			 
cffb			.SPIOb: 
cffb			 
cffb				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
cffb			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
cffb			 
cffb					if DEBUG_FORTH_WORDS_KEY 
cffb						DMARK "SPo" 
cffb						CALLMONITOR 
cffb					endif 
cffb					; get port 
cffb			 
cffb			 
cffb					; get byte to send 
cffb			 
cffb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cffb			 
cffb			;		push hl    ; u1  
cffb			 
cffb					; destroy value TOS 
cffb			 
cffb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cffb			 
cffb					; one value on hl get other one back 
cffb			 
cffb			;		pop hl   ; u2 - addr 
cffb			 
cffb					; TODO Send SPI byte 
cffb			 
cffb			;		push hl 
cffb			;		call spi_ce_low 
cffb			;		pop hl 
cffb					ld a, l 
cffb					call spi_send_byte 
cffb			;		call spi_ce_high 
cffb			 
cffb					NEXTW 
cffb			 
cffb			.SPII: 
cffb				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
cffb			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
cffb					if DEBUG_FORTH_WORDS_KEY 
cffb						DMARK "SPi" 
cffb						CALLMONITOR 
cffb					endif 
cffb			 
cffb					; TODO Get SPI byte 
cffb			 
cffb					call spi_read_byte 
cffb			 
cffb					if DEBUG_FORTH_WORDS 
cffb						DMARK "Si2" 
cffb						CALLMONITOR 
cffb					endif 
cffb					ld h, 0 
cffb					ld l, a 
cffb					if DEBUG_FORTH_WORDS 
cffb						DMARK "Si3" 
cffb						CALLMONITOR 
cffb					endif 
cffb					call forth_push_numhl 
cffb			 
cffb					NEXTW 
cffb			 
cffb			 
cffb			 
cffb			.SESEL: 
cffb				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
cffb			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV).  | DONE 
cffb			; | | Set to zero to disable storage. 
cffb					if DEBUG_FORTH_WORDS_KEY 
cffb						DMARK "BNK" 
cffb						CALLMONITOR 
cffb					endif 
cffb			 
cffb					ld a, 255 
cffb					ld (spi_cartdev), a 
cffb			 
cffb					; get bank 
cffb			 
cffb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cffb			 
cffb			;		push hl 
cffb			 
cffb					; destroy value TOS 
cffb			 
cffb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cffb			 
cffb					; one value on hl get other one back 
cffb			 
cffb			;		pop hl 
cffb			 
cffb			 
cffb					ld c, SPI_CE_HIGH 
cffb					ld b, '0'    ; human readable bank number 
cffb			 
cffb					ld a, l 
cffb			 
cffb					if DEBUG_FORTH_WORDS 
cffb						DMARK "BNK" 
cffb						CALLMONITOR 
cffb					endif 
cffb			 
cffb					; active low 
cffb			 
cffb			;		cp 0 
cffb					or a 
cffb					jr z, .bset 
cffb					cp 1 
cffb					jr nz, .b2 
cffb					res 0, c 
cffb					ld b, '1'    ; human readable bank number 
cffb			.b2:		cp 2 
cffb					jr nz, .b3 
cffb					res 1, c 
cffb					ld b, '2'    ; human readable bank number 
cffb			.b3:		cp 3 
cffb					jr nz, .b4 
cffb					res 2, c 
cffb					ld b, '3'    ; human readable bank number 
cffb			.b4:		cp 4 
cffb					jr nz, .b5 
cffb					res 3, c 
cffb					ld b, '4'    ; human readable bank number 
cffb			.b5:		cp 5 
cffb					jr nz, .bset 
cffb					res 4, c 
cffb					ld b, '5'    ; human readable bank number 
cffb			 
cffb			.bset: 
cffb					ld a, c 
cffb					ld (spi_device),a 
cffb					ld a, b 
cffb					ld (spi_device_id),a 
cffb					if DEBUG_FORTH_WORDS 
cffb						DMARK "BN2" 
cffb						CALLMONITOR 
cffb					endif 
cffb			 
cffb					; set default SPI clk pulse time as disabled for BANK use 
cffb			 
cffb					ld a, 0 
cffb					ld (spi_clktime), a 
cffb			 
cffb					NEXTW 
cffb			 
cffb			.CARTDEV: 
cffb				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
cffb			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). | DONE 
cffb			; | | Set to zero to disable devices. 
cffb					if DEBUG_FORTH_WORDS_KEY 
cffb						DMARK "CDV" 
cffb						CALLMONITOR 
cffb					endif 
cffb			 
cffb					; disable se storage bank selection 
cffb			 
cffb					ld a, SPI_CE_HIGH		; ce high 
cffb					ld (spi_device), a 
cffb			 
cffb					; get bank 
cffb			 
cffb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cffb			 
cffb			;		push hl 
cffb			 
cffb					; destroy value TOS 
cffb			 
cffb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cffb			 
cffb					; one value on hl get other one back 
cffb			 
cffb			;		pop hl 
cffb			 
cffb					; active low 
cffb			 
cffb					ld c, 255 
cffb			 
cffb					ld a, l 
cffb					if DEBUG_FORTH_WORDS 
cffb						DMARK "CDV" 
cffb						CALLMONITOR 
cffb					endif 
cffb			;		cp 0 
cffb					or a 
cffb					jr z, .cset 
cffb					cp 1 
cffb					jr nz, .c2 
cffb					res 0, c 
cffb			.c2:		cp 2 
cffb					jr nz, .c3 
cffb					res 1, c 
cffb			.c3:		cp 3 
cffb					jr nz, .c4 
cffb					res 2, c 
cffb			.c4:		cp 4 
cffb					jr nz, .c5 
cffb					res 3, c 
cffb			.c5:		cp 5 
cffb					jr nz, .c6 
cffb					res 4, c 
cffb			.c6:		cp 6 
cffb					jr nz, .c7 
cffb					res 5, c 
cffb			.c7:		cp 7 
cffb					jr nz, .c8 
cffb					res 6, c 
cffb			.c8:		cp 8 
cffb					jr nz, .cset 
cffb					res 7, c 
cffb			.cset:		ld a, c 
cffb					ld (spi_cartdev),a 
cffb			 
cffb					if DEBUG_FORTH_WORDS 
cffb						DMARK "CD2" 
cffb						CALLMONITOR 
cffb					endif 
cffb			 
cffb					; set default SPI clk pulse time as 10ms for CARTDEV use 
cffb			 
cffb					ld a, $0a 
cffb					ld (spi_clktime), a 
cffb					NEXTW 
cffb			endif 
cffb			 
cffb			.ENDDEVICE: 
cffb			; eof 
cffb			 
# End of file forth_words_device.asm
cffb			 
cffb			; var handler 
cffb			 
cffb			 
cffb			.VARS: 
cffb				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
cffb 77				db WORD_SYS_CORE+99             
cffc af d0			dw .V0            
cffe 04				db 3 + 1 
cfff .. 00			db "VAR",0              
d003				endm 
# End of macro CWHEAD
d003			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
d003			;| 
d003			;| The variable name should consist of a single letter. e.g. "a" 
d003			;! If a full string is passed then only the first char is looked at 
d003			;| Any other char could exceed bounds checks!  
d003			 
d003					if DEBUG_FORTH_WORDS_KEY 
d003						DMARK "VAR" 
d003 f5				push af  
d004 3a 18 d0			ld a, (.dmark)  
d007 32 62 ee			ld (debug_mark),a  
d00a 3a 19 d0			ld a, (.dmark+1)  
d00d 32 63 ee			ld (debug_mark+1),a  
d010 3a 1a d0			ld a, (.dmark+2)  
d013 32 64 ee			ld (debug_mark+2),a  
d016 18 03			jr .pastdmark  
d018 ..			.dmark: db "VAR"  
d01b f1			.pastdmark: pop af  
d01c			endm  
# End of macro DMARK
d01c						CALLMONITOR 
d01c cd 6f ee			call debug_vector  
d01f				endm  
# End of macro CALLMONITOR
d01f					endif 
d01f			 
d01f					FORTH_DSP_VALUEHL 
d01f cd c7 9b			call macro_dsp_valuehl 
d022				endm 
# End of macro FORTH_DSP_VALUEHL
d022			 
d022 7e					ld a, (hl)    ; get first char on of the string 
d023			 
d023			 
d023					if DEBUG_FORTH_WORDS 
d023						DMARK "VR1" 
d023 f5				push af  
d024 3a 38 d0			ld a, (.dmark)  
d027 32 62 ee			ld (debug_mark),a  
d02a 3a 39 d0			ld a, (.dmark+1)  
d02d 32 63 ee			ld (debug_mark+1),a  
d030 3a 3a d0			ld a, (.dmark+2)  
d033 32 64 ee			ld (debug_mark+2),a  
d036 18 03			jr .pastdmark  
d038 ..			.dmark: db "VR1"  
d03b f1			.pastdmark: pop af  
d03c			endm  
# End of macro DMARK
d03c						CALLMONITOR 
d03c cd 6f ee			call debug_vector  
d03f				endm  
# End of macro CALLMONITOR
d03f					endif 
d03f					 
d03f f5					push af	 
d040					FORTH_DSP_POP 
d040 cd 7f 9c			call macro_forth_dsp_pop 
d043				endm 
# End of macro FORTH_DSP_POP
d043 f1					pop af 
d044			 
d044					; convert to upper 
d044			 
d044 cd 3e 8f				call to_upper 
d047					if DEBUG_FORTH_WORDS 
d047						DMARK "Vaa" 
d047 f5				push af  
d048 3a 5c d0			ld a, (.dmark)  
d04b 32 62 ee			ld (debug_mark),a  
d04e 3a 5d d0			ld a, (.dmark+1)  
d051 32 63 ee			ld (debug_mark+1),a  
d054 3a 5e d0			ld a, (.dmark+2)  
d057 32 64 ee			ld (debug_mark+2),a  
d05a 18 03			jr .pastdmark  
d05c ..			.dmark: db "Vaa"  
d05f f1			.pastdmark: pop af  
d060			endm  
# End of macro DMARK
d060						CALLMONITOR 
d060 cd 6f ee			call debug_vector  
d063				endm  
# End of macro CALLMONITOR
d063					endif 
d063 06 41				ld b, 'A' 
d065 90					sub b			; set offset 
d066					if DEBUG_FORTH_WORDS 
d066						DMARK "Vbb" 
d066 f5				push af  
d067 3a 7b d0			ld a, (.dmark)  
d06a 32 62 ee			ld (debug_mark),a  
d06d 3a 7c d0			ld a, (.dmark+1)  
d070 32 63 ee			ld (debug_mark+1),a  
d073 3a 7d d0			ld a, (.dmark+2)  
d076 32 64 ee			ld (debug_mark+2),a  
d079 18 03			jr .pastdmark  
d07b ..			.dmark: db "Vbb"  
d07e f1			.pastdmark: pop af  
d07f			endm  
# End of macro DMARK
d07f						CALLMONITOR 
d07f cd 6f ee			call debug_vector  
d082				endm  
# End of macro CALLMONITOR
d082					endif 
d082 cb 27				sla a  
d084				 
d084					 
d084					if DEBUG_FORTH_WORDS 
d084						DMARK "VR2" 
d084 f5				push af  
d085 3a 99 d0			ld a, (.dmark)  
d088 32 62 ee			ld (debug_mark),a  
d08b 3a 9a d0			ld a, (.dmark+1)  
d08e 32 63 ee			ld (debug_mark+1),a  
d091 3a 9b d0			ld a, (.dmark+2)  
d094 32 64 ee			ld (debug_mark+2),a  
d097 18 03			jr .pastdmark  
d099 ..			.dmark: db "VR2"  
d09c f1			.pastdmark: pop af  
d09d			endm  
# End of macro DMARK
d09d						CALLMONITOR 
d09d cd 6f ee			call debug_vector  
d0a0				endm  
# End of macro CALLMONITOR
d0a0					endif 
d0a0			 
d0a0 21 eb e9				ld hl, cli_var_array2 
d0a3 cd d6 8c				call addatohl 
d0a6 cd cb 99				call forth_push_numhl 
d0a9			 
d0a9			 
d0a9				       NEXTW 
d0a9 cd 6c ee			call parse_vector 
d0ac c3 ae 9d			jp macro_next 
d0af				endm 
# End of macro NEXTW
d0af			.V0: 
d0af				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
d0af 78				db WORD_SYS_CORE+100             
d0b0 ca d0			dw .V0Q            
d0b2 04				db 3 + 1 
d0b3 .. 00			db "V0!",0              
d0b7				endm 
# End of macro CWHEAD
d0b7			;| V0! ( u1 -- )  Store value to v0  | DONE 
d0b7			 
d0b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0b7 cd c7 9b			call macro_dsp_valuehl 
d0ba				endm 
# End of macro FORTH_DSP_VALUEHL
d0ba			 
d0ba 11 1f ea				ld de, cli_var_array 
d0bd			 
d0bd eb					ex de, hl 
d0be 73					ld (hl), e 
d0bf 23					inc hl 
d0c0 72					ld (hl), d 
d0c1			 
d0c1					; destroy value TOS 
d0c1			 
d0c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0c1 cd 7f 9c			call macro_forth_dsp_pop 
d0c4				endm 
# End of macro FORTH_DSP_POP
d0c4			 
d0c4				       NEXTW 
d0c4 cd 6c ee			call parse_vector 
d0c7 c3 ae 9d			jp macro_next 
d0ca				endm 
# End of macro NEXTW
d0ca			.V0Q: 
d0ca				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
d0ca 79				db WORD_SYS_CORE+101             
d0cb de d0			dw .V1S            
d0cd 04				db 3 + 1 
d0ce .. 00			db "V0@",0              
d0d2				endm 
# End of macro CWHEAD
d0d2			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
d0d2 2a 1f ea				ld hl, (cli_var_array) 
d0d5 cd cb 99				call forth_push_numhl 
d0d8			 
d0d8				       NEXTW 
d0d8 cd 6c ee			call parse_vector 
d0db c3 ae 9d			jp macro_next 
d0de				endm 
# End of macro NEXTW
d0de			.V1S: 
d0de				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
d0de 7a				db WORD_SYS_CORE+102             
d0df f9 d0			dw .V1Q            
d0e1 04				db 3 + 1 
d0e2 .. 00			db "V1!",0              
d0e6				endm 
# End of macro CWHEAD
d0e6			;| V1! ( u1 -- )  Store value to v1 | DONE 
d0e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d0e6 cd c7 9b			call macro_dsp_valuehl 
d0e9				endm 
# End of macro FORTH_DSP_VALUEHL
d0e9			 
d0e9 11 21 ea				ld de, cli_var_array+2 
d0ec				 
d0ec eb					ex de, hl 
d0ed 73					ld (hl), e 
d0ee 23					inc hl 
d0ef 72					ld (hl), d 
d0f0			 
d0f0					; destroy value TOS 
d0f0			 
d0f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d0f0 cd 7f 9c			call macro_forth_dsp_pop 
d0f3				endm 
# End of macro FORTH_DSP_POP
d0f3				       NEXTW 
d0f3 cd 6c ee			call parse_vector 
d0f6 c3 ae 9d			jp macro_next 
d0f9				endm 
# End of macro NEXTW
d0f9			.V1Q: 
d0f9				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
d0f9 7b				db WORD_SYS_CORE+103             
d0fa 0d d1			dw .V2S            
d0fc 04				db 3 + 1 
d0fd .. 00			db "V1@",0              
d101				endm 
# End of macro CWHEAD
d101			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
d101 2a 21 ea				ld hl, (cli_var_array+2) 
d104 cd cb 99				call forth_push_numhl 
d107				       NEXTW 
d107 cd 6c ee			call parse_vector 
d10a c3 ae 9d			jp macro_next 
d10d				endm 
# End of macro NEXTW
d10d			.V2S: 
d10d				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
d10d 7c				db WORD_SYS_CORE+104             
d10e 28 d1			dw .V2Q            
d110 04				db 3 + 1 
d111 .. 00			db "V2!",0              
d115				endm 
# End of macro CWHEAD
d115			;| V2! ( u1 -- )  Store value to v2 | DONE 
d115					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d115 cd c7 9b			call macro_dsp_valuehl 
d118				endm 
# End of macro FORTH_DSP_VALUEHL
d118			 
d118 11 23 ea				ld de, cli_var_array+4 
d11b				 
d11b eb					ex de, hl 
d11c 73					ld (hl), e 
d11d 23					inc hl 
d11e 72					ld (hl), d 
d11f			 
d11f					; destroy value TOS 
d11f			 
d11f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d11f cd 7f 9c			call macro_forth_dsp_pop 
d122				endm 
# End of macro FORTH_DSP_POP
d122				       NEXTW 
d122 cd 6c ee			call parse_vector 
d125 c3 ae 9d			jp macro_next 
d128				endm 
# End of macro NEXTW
d128			.V2Q: 
d128				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
d128 7d				db WORD_SYS_CORE+105             
d129 3c d1			dw .V3S            
d12b 04				db 3 + 1 
d12c .. 00			db "V2@",0              
d130				endm 
# End of macro CWHEAD
d130			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
d130 2a 23 ea				ld hl, (cli_var_array+4) 
d133 cd cb 99				call forth_push_numhl 
d136				       NEXTW 
d136 cd 6c ee			call parse_vector 
d139 c3 ae 9d			jp macro_next 
d13c				endm 
# End of macro NEXTW
d13c			.V3S: 
d13c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
d13c 7c				db WORD_SYS_CORE+104             
d13d 57 d1			dw .V3Q            
d13f 04				db 3 + 1 
d140 .. 00			db "V3!",0              
d144				endm 
# End of macro CWHEAD
d144			;| V3! ( u1 -- )  Store value to v3 | DONE 
d144					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
d144 cd c7 9b			call macro_dsp_valuehl 
d147				endm 
# End of macro FORTH_DSP_VALUEHL
d147			 
d147 11 25 ea				ld de, cli_var_array+6 
d14a				 
d14a eb					ex de, hl 
d14b 73					ld (hl), e 
d14c 23					inc hl 
d14d 72					ld (hl), d 
d14e			 
d14e					; destroy value TOS 
d14e			 
d14e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
d14e cd 7f 9c			call macro_forth_dsp_pop 
d151				endm 
# End of macro FORTH_DSP_POP
d151				       NEXTW 
d151 cd 6c ee			call parse_vector 
d154 c3 ae 9d			jp macro_next 
d157				endm 
# End of macro NEXTW
d157			.V3Q: 
d157				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
d157 7d				db WORD_SYS_CORE+105             
d158 6b d1			dw .END            
d15a 04				db 3 + 1 
d15b .. 00			db "V3@",0              
d15f				endm 
# End of macro CWHEAD
d15f			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
d15f 2a 25 ea				ld hl, (cli_var_array+6) 
d162 cd cb 99				call forth_push_numhl 
d165				       NEXTW 
d165 cd 6c ee			call parse_vector 
d168 c3 ae 9d			jp macro_next 
d16b				endm 
# End of macro NEXTW
d16b			 
d16b			 
d16b			 
d16b			 
d16b			 
d16b			; end of dict marker 
d16b			 
d16b 00			.END:    db WORD_SYS_END 
d16c 00 00			dw 0 
d16e 00				db 0 
d16f			 
d16f			; use to jp here for user dict words to save on macro expansion  
d16f			 
d16f			user_dict_next: 
d16f				NEXTW 
d16f cd 6c ee			call parse_vector 
d172 c3 ae 9d			jp macro_next 
d175				endm 
# End of macro NEXTW
d175			 
d175			 
d175			user_exec: 
d175				;    ld hl, <word code> 
d175				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
d175				;    call forthexec 
d175				;    jp user_dict_next   (NEXT) 
d175			        ;    <word code bytes> 
d175 eb				ex de, hl 
d176 2a b9 e5			ld hl,(os_tok_ptr) 
d179				 
d179				FORTH_RSP_NEXT 
d179 cd 72 99			call macro_forth_rsp_next 
d17c				endm 
# End of macro FORTH_RSP_NEXT
d17c			 
d17c			if DEBUG_FORTH_UWORD 
d17c						DMARK "UEX" 
d17c f5				push af  
d17d 3a 91 d1			ld a, (.dmark)  
d180 32 62 ee			ld (debug_mark),a  
d183 3a 92 d1			ld a, (.dmark+1)  
d186 32 63 ee			ld (debug_mark+1),a  
d189 3a 93 d1			ld a, (.dmark+2)  
d18c 32 64 ee			ld (debug_mark+2),a  
d18f 18 03			jr .pastdmark  
d191 ..			.dmark: db "UEX"  
d194 f1			.pastdmark: pop af  
d195			endm  
# End of macro DMARK
d195				CALLMONITOR 
d195 cd 6f ee			call debug_vector  
d198				endm  
# End of macro CALLMONITOR
d198			endif 
d198			 
d198			 
d198			 
d198 eb				ex de, hl 
d199 22 b9 e5			ld (os_tok_ptr), hl 
d19c				 
d19c				; Don't use next - Skips the first word in uword. 
d19c			 
d19c c3 2f 9e			jp exec1 
d19f			;	NEXT 
d19f			 
d19f			 
d19f			; eof 
# End of file forth_wordsv4.asm
d19f			endif 
d19f			;;;;;;;;;;;;;; Debug code 
d19f			 
d19f			 
d19f			;if DEBUG_FORTH_PARSE 
d19f .. 00		.nowordfound: db "No match",0 
d1a8 .. 00		.compword:	db "Comparing word ",0 
d1b8 .. 00		.nextwordat:	db "Next word at",0 
d1c5 .. 00		.charmatch:	db "Char match",0 
d1d0			;endif 
d1d0			if DEBUG_FORTH_JP 
d1d0			.foundword:	db "Word match. Exec..",0 
d1d0			endif 
d1d0			;if DEBUG_FORTH_PUSH 
d1d0 .. 00		.enddict:	db "Dict end. Push.",0 
d1e0 .. 00		.push_str:	db "Pushing string",0 
d1ef .. 00		.push_num:	db "Pushing number",0 
d1fe .. 00		.data_sp:	db "SP:",0 
d202 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
d214 .. 00		.wordinde:	db "Word in DE (3/0):",0 
d226 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
d238			;endif 
d238			;if DEBUG_FORTH_MALLOC 
d238 .. 00		.push_malloc:	db "Malloc address",0 
d247			;endif 
d247			 
d247			 
d247			 
d247			; display malloc address and current data stack pointer  
d247			 
d247			malloc_error: 
d247 d5				push de 
d248 f5				push af 
d249 e5				push hl 
d24a cd ac 8a			call clear_display 
d24d 11 6d d2			ld de, .mallocerr 
d250 3e 00			ld a,0 
d252			;	ld de,os_word_scratch 
d252 cd be 8a			call str_at_display 
d255 3e 11			ld a, display_row_1+17 
d257 11 62 ee			ld de, debug_mark 
d25a cd be 8a			call str_at_display 
d25d cd ce 8a			call update_display 
d260				;call break_point_state 
d260 cd 80 e3			call cin_wait 
d263			 
d263			;	ld a, ' ' 
d263			;	ld (os_view_disable), a 
d263 cd 4a 93			call bp_on 
d266 e1				pop hl 
d267 f1				pop af 
d268 d1				pop de	 
d269				CALLMONITOR 
d269 cd 6f ee			call debug_vector  
d26c				endm  
# End of macro CALLMONITOR
d26c c9				ret 
d26d			 
d26d .. 00		.mallocerr: 	db "Malloc Error",0 
d27a			;if DEBUG_FORTH_PUSH 
d27a			display_data_sp: 
d27a f5				push af 
d27b			 
d27b				; see if disabled 
d27b			 
d27b			 
d27b 3a 6f ee			ld a, (debug_vector) 
d27e fe c9			cp $C9  ; RET 
d280				;ld a, (os_view_disable) 
d280				;cp '*' 
d280 28 65			jr z, .skipdsp 
d282			 
d282 e5				push hl 
d283 e5				push hl 
d284 e5			push hl 
d285 cd ac 8a			call clear_display 
d288 e1			pop hl 
d289 7c				ld a,h 
d28a 21 bd e5			ld hl, os_word_scratch 
d28d cd d2 8e			call hexout 
d290 e1				pop hl 
d291 7d				ld a,l 
d292 21 bf e5			ld hl, os_word_scratch+2 
d295 cd d2 8e			call hexout 
d298 21 c1 e5			ld hl, os_word_scratch+4 
d29b			;	ld a,0 
d29b 36 00			ld (hl),0 
d29d 11 bd e5			ld de,os_word_scratch 
d2a0 3e 28				ld a, display_row_2 
d2a2 cd be 8a				call str_at_display 
d2a5 11 02 d2			ld de, .wordinhl 
d2a8 3e 00			ld a, display_row_1 
d2aa			 
d2aa cd be 8a				call str_at_display 
d2ad 11 62 ee			ld de, debug_mark 
d2b0 3e 11			ld a, display_row_1+17 
d2b2			 
d2b2 cd be 8a				call str_at_display 
d2b5			 
d2b5				; display current data stack pointer 
d2b5 11 fe d1			ld de,.data_sp 
d2b8 3e 30				ld a, display_row_2 + 8 
d2ba cd be 8a				call str_at_display 
d2bd			 
d2bd 2a e5 e9			ld hl,(cli_data_sp) 
d2c0 e5				push hl 
d2c1 7c				ld a,h 
d2c2 21 bd e5			ld hl, os_word_scratch 
d2c5 cd d2 8e			call hexout 
d2c8 e1				pop hl 
d2c9 7d				ld a,l 
d2ca 21 bf e5			ld hl, os_word_scratch+2 
d2cd cd d2 8e			call hexout 
d2d0 21 c1 e5			ld hl, os_word_scratch+4 
d2d3			;	ld a,0 
d2d3 36 00			ld (hl),0 
d2d5 11 bd e5			ld de,os_word_scratch 
d2d8 3e 33				ld a, display_row_2 + 11 
d2da cd be 8a				call str_at_display 
d2dd			 
d2dd			 
d2dd cd ce 8a			call update_display 
d2e0 cd f0 89			call delay1s 
d2e3 cd f0 89			call delay1s 
d2e6 e1				pop hl 
d2e7			.skipdsp: 
d2e7 f1				pop af 
d2e8 c9				ret 
d2e9			 
d2e9			display_data_malloc: 
d2e9			 
d2e9 f5				push af 
d2ea e5				push hl 
d2eb e5				push hl 
d2ec e5			push hl 
d2ed cd ac 8a			call clear_display 
d2f0 e1			pop hl 
d2f1 7c				ld a,h 
d2f2 21 bd e5			ld hl, os_word_scratch 
d2f5 cd d2 8e			call hexout 
d2f8 e1				pop hl 
d2f9 7d				ld a,l 
d2fa 21 bf e5			ld hl, os_word_scratch+2 
d2fd cd d2 8e			call hexout 
d300 21 c1 e5			ld hl, os_word_scratch+4 
d303			;	ld a,0 
d303 36 00			ld (hl),0 
d305 11 bd e5			ld de,os_word_scratch 
d308 3e 28				ld a, display_row_2 
d30a cd be 8a				call str_at_display 
d30d 11 38 d2			ld de, .push_malloc 
d310 3e 00			ld a, display_row_1 
d312			 
d312 cd be 8a				call str_at_display 
d315			 
d315				; display current data stack pointer 
d315 11 fe d1			ld de,.data_sp 
d318 3e 30				ld a, display_row_2 + 8 
d31a cd be 8a				call str_at_display 
d31d			 
d31d 2a e5 e9			ld hl,(cli_data_sp) 
d320 e5				push hl 
d321 7c				ld a,h 
d322 21 bd e5			ld hl, os_word_scratch 
d325 cd d2 8e			call hexout 
d328 e1				pop hl 
d329 7d				ld a,l 
d32a 21 bf e5			ld hl, os_word_scratch+2 
d32d cd d2 8e			call hexout 
d330 21 c1 e5			ld hl, os_word_scratch+4 
d333			;	ld a,0 
d333 36 00			ld (hl),0 
d335 11 bd e5			ld de,os_word_scratch 
d338 3e 33				ld a, display_row_2 + 11 
d33a cd be 8a				call str_at_display 
d33d			 
d33d cd ce 8a			call update_display 
d340 cd f0 89			call delay1s 
d343 cd f0 89			call delay1s 
d346 e1				pop hl 
d347 f1				pop af 
d348 c9				ret 
d349			;endif 
d349			 
d349			include "forth_autostart.asm" 
d349			; list of commands to perform at system start up 
d349			 
d349			startcmds: 
d349			;	dw test11 
d349			;	dw test12 
d349			;	dw test13 
d349			;	dw test14 
d349			;	dw test15 
d349			;	dw test16 
d349			;	dw test17 
d349			;	dw ifthtest1 
d349			;	dw ifthtest2 
d349			;	dw ifthtest3 
d349			;	dw mmtest1 
d349			;	dw mmtest2 
d349			;	dw mmtest3 
d349			;	dw mmtest4 
d349			;	dw mmtest5 
d349			;	dw mmtest6 
d349			;	dw iftest1 
d349			;	dw iftest2 
d349			;	dw iftest3 
d349			;	dw looptest1 
d349			;	dw looptest2 
d349			;	dw test1 
d349			;	dw test2 
d349			;	dw test3 
d349			;	dw test4 
d349			;	dw game2r 
d349			;	dw game2b1 
d349			;	dw game2b2 
d349			 
d349				; start up words that are actually useful 
d349			 
d349			;    dw spi1 
d349			;    dw spi2 
d349			;    dw spi3 
d349			;    dw spi4 
d349			;    dw spi5 
d349			;    dw spi6 
d349			;    dw spi7 
d349			; 
d349			;    dw spi8 
d349			;    dw spi9 
d349			;    dw spi10 
d349			 
d349			; file editor 
d349			;	dw edit1 
d349			;	dw edit2 
d349			;	dw edit3 
d349			 
d349			;	dw longread 
d349 6b d7			dw clrstack 
d34b 9f d7			dw type 
d34d			;	dw stest 
d34d c4 d7			dw strncpy 
d34f 34 d9			dw list 
d351 25 d8			dw start1 
d353 35 d8			dw start2 
d355			;	dw start3 
d355			;	dw start3b 
d355			;	dw start3c 
d355			 
d355				; (unit) testing words 
d355			 
d355			;	dw mtesta 
d355			;	dw mtestb 
d355			;	dw mtestc 
d355			;	dw mtestd 
d355			;	dw mteste 
d355			 
d355				; demo/game words 
d355			 
d355			;        dw game3w 
d355			;        dw game3p 
d355			;        dw game3sc 
d355			;        dw game3vsi 
d355			;        dw game3vs 
d355				 
d355			;	dw game2b 
d355			;	dw game2bf 
d355			;	dw game2mba 
d355			;	dw game2mbas 
d355			;	dw game2mb 
d355			 
d355 65 db			dw game1 
d357 76 db			dw game1a 
d359 d8 db			dw game1b 
d35b 0d dc			dw game1c 
d35d 43 dc			dw game1d 
d35f 74 dc			dw game1s 
d361 88 dc			dw game1t 
d363 9d dc			dw game1f 
d365 d1 dc			dw game1z 
d367 15 dd			dw game1zz 
d369			 
d369 9e d9			dw test5 
d36b d6 d9			dw test6 
d36d 0e da			dw test7 
d36f 22 da			dw test8 
d371 4e da			dw test9 
d373 64 da			dw test10 
d375				 
d375 ec dd		        dw ssv5 
d377 d0 dd		        dw ssv4 
d379 b4 dd		        dw ssv3 
d37b 7e dd		        dw ssv2 
d37d 05 de		        dw ssv1 
d37f 4d de		        dw ssv1cpm 
d381			;	dw keyup 
d381			;	dw keydown 
d381			;	dw keyleft 
d381			;	dw keyright 
d381			;	dw 	keyf1 
d381			;	dw keyf2 
d381			;	dw keyf3 
d381			;	dw keyf4 
d381			;	dw keyf5 
d381			;	dw keyf6 
d381			;	dw keyf7 
d381			;	dw keyf8 
d381			;	dw keyf9 
d381			;	dw keyf10 
d381			;	dw keyf11 
d381			;	dw keyf12 
d381			;	dw keytab 
d381			;	dw keycr 
d381			;	dw keyhome 
d381			;	dw keyend 
d381			;	dw keybs 
d381 00 00			db 0, 0	 
d383			 
d383			 
d383			; File Editor 
d383			 
d383			; ( id - ) use 'e' to edit the displayed line 
d383 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
d3a4 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d3d9			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
d3d9 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
d411			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
d411			 
d411			; SPI Net support words 
d411			 
d411			; v0! = node to send to 
d411			; ( str count - ) 
d411 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
d46a			 
d46a			; spiputc ( char node - ) 
d46a .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
d49e			; spiputc ( u node - ) 
d49e .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
d4cc			 
d4cc			; spigetc ( - n ) 
d4cc .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
d4f5			 
d4f5			; getnode ( - n ) 
d4f5 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
d522			 
d522			; ( str node - )  
d522 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
d588			; store string ( str i - ) 
d588			 
d588			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
d588 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
d5dd			 
d5dd			; get string ( addr i -  )    TO FIX 
d5dd			 
d5dd .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
d635			 
d635			 
d635			; NETCHAT (TODO) 
d635			; Program to allow two nodes to chat with eachother 
d635			; 
d635			; v0 - target node 
d635			;  
d635			; accept input at 0,0 
d635			; if input is string send spitype to target node 
d635			; starting at row 2,0 , while spigetchr is not zero ->  
d635			; 
d635			; 
d635			; TODO add paging of get request 
d635			 
d635			; ( node - ) 
d635 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d654 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d6ac .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d724			 
d724			 
d724			; Long read of currently open file 
d724 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d76b			 
d76b			; clear stack  
d76b			 
d76b .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d79f			 
d79f			; type ( addr count - ) 
d79f .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d7c4			 
d7c4			; some direct memory words 
d7c4			; strncpy ( len t f -- t ) 
d7c4			 
d7c4 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d825			 
d825 .. 00		start1:     	db ": bpon $00 bp ;",0 
d835 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d846 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d8c1 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d921			 
d921 .. 00		tuck:         db ": tuck swap over ;", 0 
d934			 
d934			; a handy word to list items on the stack 
d934			 
d934 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d99e			 
d99e			 
d99e			; test stack  
d99e			; rnd8 stest 
d99e			 
d99e			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d99e			 
d99e			; random malloc and free cycles 
d99e			 
d99e			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d99e			 
d99e			; fixed malloc and free cycles 
d99e			 
d99e			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d99e			 
d99e			; fixed double string push and drop cycle  
d99e			 
d99e			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d99e			 
d99e			; consistent fixed string push and drop cycle  
d99e			 
d99e			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d99e			 
d99e			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d99e			 
d99e			;test1:		db ": aa 1 2 3 ;", 0 
d99e			;test2:     	db "111 aa 888 999",0 
d99e			;test3:     	db ": bb 77 ;",0 
d99e			;test4:     	db "$02 $01 do i . loop bb",0 
d99e			 
d99e .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d9d6 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
da0e .. 00		test7:     	db ": box hline vline ;",0 
da22 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
da4e .. 00		test9:     	db ": sw $01 adsp world ;",0 
da64 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
da89			;test11:     	db "hello create .",0 
da89			;test12:     	db "hello2 create .",0 
da89			 
da89			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
da89			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
da89			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
da89			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
da89			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
da89			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
da89			 
da89			;iftest1:     	db "$0001 IF cls .",0 
da89			;iftest2:     	db "$0000 IF cls .",0 
da89			;iftest3:     	db "$0002 $0003 - IF cls .",0 
da89			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
da89			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
da89			 
da89			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
da89			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
da89			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
da89			 
da89			 
da89 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
daad .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
dadd .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
db02 .. 00		sound4: db ": cha $00 ; ",0 
db0f .. 00		sound5: db ": chb $20 ; ",0 
db1c .. 00		sound6: db ": chc $40 ; ",0 
db29 .. 00		sound7: db ": chd $60 ; ",0 
db36 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
db4e .. 00		sound9: db ": cvol $90 + + note ; ", 0 
db65			 
db65			 
db65			 
db65			 
db65			; a small guess the number game 
db65			 
db65 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
db76 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
dbd8			 
dbd8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
dc0d .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
dc43 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
dc74 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
dc88 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
dc9d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
dcd1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dd15			 
dd15			; Using 'ga' save a high score across multiple runs using external storage 
dd15			 
dd15 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
dd7e			 
dd7e			 
dd7e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
dd7e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
dd7e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
dd7e			 
dd7e			; simple screen saver to test code memory reuse to destruction 
dd7e			 
dd7e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
ddb4 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
ddd0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
ddec .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
de05 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
de4d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
dea4			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
dea4			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
dea4			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
dea4			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
dea4			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
dea4			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
dea4			 
dea4			 
dea4			 
dea4			; minesweeper/battleship finding game 
dea4			; draws a game board of random ship/mine positions 
dea4			; user enters coords to see if it hits on 
dea4			; game ends when all are hit 
dea4			; when hit or miss says how many may be in the area 
dea4			 
dea4			; setup the game board and then hide it 
dea4			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dea4			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dea4			;; prompt for where to target 
dea4			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dea4			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
dea4			;; TODO see if the entered coords hits or misses pushes char hit of miss 
dea4			;game2mbht:      db ": mbckht nop ;",0 
dea4			;game2mbms:      db ": mbcms nop ;",0 
dea4			; TODO how many might be near by 
dea4			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
dea4			 
dea4			; Game 3 
dea4			 
dea4			; Vert scroller ski game - avoid the trees! 
dea4			 
dea4			; v0 score (ie turns) 
dea4			; v1 player pos 
dea4			; v2 left wall 
dea4			; v3 right wall 
dea4			 
dea4			; Draw side walls randomly 
dea4			 
dea4			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
dea4			 
dea4			; Draw player 
dea4			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
dea4			 
dea4			; TODO Get Key 
dea4			 
dea4			; TODO Move left right 
dea4			 
dea4			; scroll and move walls a bit 
dea4			 
dea4			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
dea4			 
dea4			; main game loop 
dea4			 
dea4			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
dea4			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
dea4			 
dea4			; key board defs 
dea4			 
dea4 .. 00		keyup:       db ": keyup $05 ;",0 
deb2 .. 00		keydown:       db ": keydown $0a ;",0 
dec2 .. 00		keyleft:       db ": keyleft $0b ;",0 
ded2 .. 00		keyright:       db ": keyright $0c ;",0 
dee3 .. 00		keyf1:       db ": keyf1 $10 ;",0 
def1 .. 00		keyf2:       db ": keyf2 $11 ;",0 
deff .. 00		keyf3:       db ": keyf3 $12 ;",0 
df0d .. 00		keyf4:       db ": keyf4 $13 ;",0 
df1b .. 00		keyf5:       db ": keyf5 $14 ;",0 
df29 .. 00		keyf6:       db ": keyf6 $15 ;",0 
df37 .. 00		keyf7:       db ": keyf7 $16 ;",0 
df45 .. 00		keyf8:       db ": keyf8 $17 ;",0 
df53 .. 00		keyf9:       db ": keyf9 $18 ;",0 
df61 .. 00		keyf10:       db ": keyf10 $19 ;",0 
df70 .. 00		keyf11:       db ": keyf11 $1a ;",0 
df7f .. 00		keyf12:       db ": keyf12 $1b ;",0 
df8e			 
df8e .. 00		keytab:       db ": keytab $09 ;",0 
df9d .. 00		keycr:       db ": keycr $0d ;",0 
dfab .. 00		keyhome:       db ": keyhome $0e ;",0 
dfbb .. 00		keyend:       db ": keyend $0f ;",0 
dfca .. 00		keybs:       db ": keybs $08 ;",0 
dfd8			 
dfd8			   
dfd8			 
dfd8			 
dfd8			 
dfd8			; eof 
# End of file forth_autostart.asm
dfd8			 
dfd8			 
dfd8			 
dfd8			; stack over and underflow checks 
dfd8			 
dfd8			; init the words to detect the under/overflow 
dfd8			 
dfd8			chk_stk_init: 
dfd8				; a vague random number to check so we dont get any "lucky" hits 
dfd8 3e 2d			ld a, 45 
dfda 6f				ld l, a 
dfdb 00				nop 
dfdc 3e 17			ld a, 23 
dfde 67				ld h, a 
dfdf			 
dfdf 22 94 e2			ld (chk_word), hl     ; the word we need to check against 
dfe2			 
dfe2			;	ld (chk_stund), hl	; stack points.... 
dfe2 22 00 ef			ld (chk_stovr), hl 
dfe5 22 e3 e9			ld (chk_ret_und), hl 
dfe8 22 a1 e9			ld (chk_ret_ovr), hl 
dfeb 22 1f e9			ld (chk_loop_ovr), hl 
dfee 22 1d e8			ld (chk_data_ovr), hl 
dff1 c9				ret 
dff2				 
dff2			check_stacks: 
dff2				; check all stack words 
dff2			 
dff2 e5				push hl 
dff3 d5				push de 
dff4			 
dff4			;	ld de,(chk_word) 
dff4			;	ld hl, (chk_stund)	; stack points.... 
dff4			;	if DEBUG_STK_FAULT 
dff4			;		DMARK "FAa" 
dff4			;		CALLMONITOR 
dff4			;	endif 
dff4			;	call cmp16 
dff4			;	jp z, .chk_faulta 
dff4			; 
dff4			;	ld de, sfaultsu 
dff4			;	jp .chk_fault 
dff4			 
dff4 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
dff7 ed 5b 94 e2		ld de,(chk_word) 
dffb				if DEBUG_STK_FAULT 
dffb					DMARK "FAb" 
dffb					CALLMONITOR 
dffb				endif 
dffb cd f4 8c			call cmp16 
dffe 28 06			jr z, .chk_fault1 
e000 11 a4 e0			ld de, sfaultso 
e003 c3 55 e0			jp .chk_fault 
e006			.chk_fault1:  
e006 2a e3 e9			ld hl, (chk_ret_und) 
e009 ed 5b 94 e2		ld de,(chk_word) 
e00d				if DEBUG_STK_FAULT 
e00d					DMARK "FAU" 
e00d					CALLMONITOR 
e00d				endif 
e00d cd f4 8c			call cmp16 
e010 ca 19 e0			jp z, .chk_fault2 
e013 11 b4 e0			ld de, sfaultru 
e016 c3 55 e0			jp .chk_fault 
e019			.chk_fault2:  
e019 2a a1 e9			ld hl, (chk_ret_ovr) 
e01c ed 5b 94 e2		ld de,(chk_word) 
e020				if DEBUG_STK_FAULT 
e020					DMARK "FA1" 
e020					CALLMONITOR 
e020				endif 
e020 cd f4 8c			call cmp16 
e023 ca 2c e0			jp z, .chk_fault3 
e026 11 c2 e0			ld de, sfaultro 
e029 c3 55 e0			jp .chk_fault 
e02c			.chk_fault3:  
e02c 2a 1f e9			ld hl, (chk_loop_ovr) 
e02f ed 5b 94 e2		ld de,(chk_word) 
e033				if DEBUG_STK_FAULT 
e033					DMARK "FA2" 
e033					CALLMONITOR 
e033				endif 
e033 cd f4 8c			call cmp16 
e036 ca 3f e0			jp z, .chk_fault4 
e039 11 dc e0			ld de, sfaultlo 
e03c c3 55 e0			jp .chk_fault 
e03f			.chk_fault4:  
e03f 2a 1d e8			ld hl, (chk_data_ovr) 
e042 ed 5b 94 e2		ld de,(chk_word) 
e046				if DEBUG_STK_FAULT 
e046					DMARK "FA3" 
e046					CALLMONITOR 
e046				endif 
e046 cd f4 8c			call cmp16 
e049 ca 52 e0			jp z, .chk_fault5 
e04c 11 f6 e0			ld de, sfaultdo 
e04f c3 55 e0			jp .chk_fault 
e052			 
e052			 
e052			.chk_fault5:  
e052 d1				pop de 
e053 e1				pop hl 
e054			 
e054 c9				ret 
e055			 
e055 cd ac 8a		.chk_fault: 	call clear_display 
e058 3e 28				ld a, display_row_2 
e05a cd be 8a				call str_at_display 
e05d 11 86 e0				   ld de, .stackfault 
e060 3e 00				ld a, display_row_1 
e062 cd be 8a				call str_at_display 
e065 11 62 ee				    ld de, debug_mark 
e068 3e 11				ld a, display_row_1+17 
e06a cd be 8a				call str_at_display 
e06d cd ce 8a				call update_display 
e070			 
e070				; prompt before entering montior for investigating issue 
e070			 
e070 3e 78			ld a, display_row_4 
e072 11 ad 96			ld de, endprog 
e075			 
e075 cd ce 8a			call update_display		 
e078			 
e078 cd 43 99			call next_page_prompt 
e07b			 
e07b d1				pop de 
e07c e1				pop hl 
e07d cd 01 97				call monitor 
e080 cd 54 9d				call forth_warmstart 
e083 c3 ff 95				jp warmstart_afterauto 
e086					;jp 0 
e086					;halt 
e086			 
e086			 
e086			 
e086 .. 00		.stackfault: 	db "Stack fault:",0 
e093			 
e093 .. 00		sfaultsu: 	db	"Stack under flow",0 
e0a4 .. 00		sfaultso: 	db	"Stack over flow",0 
e0b4 .. 00		sfaultru:	db "RTS underflow",0 
e0c2 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e0dc .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e0f6 .. 00		sfaultdo:	db "DTS overflow", 0 
e103			 
e103			 
e103			fault_dsp_under: 
e103 11 15 e1			ld de, .dsp_under 
e106 c3 cb e1			jp .show_fault 
e109			 
e109			fault_rsp_under: 
e109 11 23 e1			ld de, .rsp_under 
e10c c3 cb e1			jp .show_fault 
e10f			fault_loop_under: 
e10f 11 31 e1			ld de, .loop_under 
e112 c3 cb e1			jp .show_fault 
e115			 
e115 .. 00		.dsp_under: db "DSP Underflow",0 
e123 .. 00		.rsp_under: db "RSP Underflow",0 
e131 .. 00		.loop_under: db "LOOP Underflow",0 
e140			 
e140			 
e140 d5			type_faultn: 	push de 
e141 e5					push hl 
e142 cd ac 8a				call clear_display 
e145 11 6f e1				   ld de, .typefaultn 
e148 3e 00				ld a, display_row_1 
e14a cd be 8a				call str_at_display 
e14d 11 62 ee				    ld de, debug_mark 
e150 3e 11				ld a, display_row_1+17 
e152 cd be 8a				call str_at_display 
e155 cd ce 8a				call update_display 
e158			 
e158				; prompt before entering montior for investigating issue 
e158			 
e158 3e 78			ld a, display_row_4 
e15a 11 ad 96			ld de, endprog 
e15d			 
e15d cd ce 8a			call update_display		 
e160			 
e160 cd 43 99			call next_page_prompt 
e163			 
e163 e5					push hl 
e164 d5					push de 
e165 cd 01 97				call monitor 
e168 cd 54 9d				call forth_warmstart 
e16b c3 ff 95				jp warmstart_afterauto 
e16e 76					halt 
e16f			 
e16f			 
e16f .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e186			 
e186 d5			type_faults: 	push de 
e187 e5					push hl 
e188 cd ac 8a				call clear_display 
e18b 11 b4 e1				   ld de, .typefaults 
e18e 3e 00				ld a, display_row_1 
e190 cd be 8a				call str_at_display 
e193 11 62 ee				    ld de, debug_mark 
e196 3e 11				ld a, display_row_1+17 
e198 cd be 8a				call str_at_display 
e19b cd ce 8a				call update_display 
e19e			 
e19e				; prompt before entering montior for investigating issue 
e19e			 
e19e 3e 78			ld a, display_row_4 
e1a0 11 ad 96			ld de, endprog 
e1a3			 
e1a3 cd ce 8a			call update_display		 
e1a6			 
e1a6 cd 43 99			call next_page_prompt 
e1a9			 
e1a9 e1					pop hl 
e1aa d1					pop de 
e1ab cd 01 97				call monitor 
e1ae cd 54 9d				call forth_warmstart 
e1b1 c3 ff 95				jp warmstart_afterauto 
e1b4			 
e1b4			 
e1b4 .. 00		.typefaults: db "STR Type Expected TOS!",0 
e1cb			 
e1cb			.show_fault: 	 
e1cb d5					push de 
e1cc cd ac 8a				call clear_display 
e1cf d1					pop de 
e1d0 3e 00				ld a, display_row_1 
e1d2 cd be 8a				call str_at_display 
e1d5 11 62 ee				    ld de, debug_mark 
e1d8 3e 11				ld a, display_row_1+17 
e1da cd be 8a				call str_at_display 
e1dd cd ce 8a				call update_display 
e1e0			 
e1e0				; prompt before entering montior for investigating issue 
e1e0			 
e1e0 3e 78			ld a, display_row_4 
e1e2 11 ad 96			ld de, endprog 
e1e5			 
e1e5 cd ce 8a			call update_display		 
e1e8			 
e1e8 cd 43 99			call next_page_prompt 
e1eb			 
e1eb e1					pop hl 
e1ec d1					pop de 
e1ed cd 01 97				call monitor 
e1f0			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e1f0			; TODO Make optional fault restart to cli or warm boot? 
e1f0					;jp warmstart 
e1f0 c3 42 96				jp cli 
e1f3 76					halt 
e1f4			 
e1f4			 
e1f4			; handle the auto run of code from files in storage 
e1f4			 
e1f4			 
e1f4			include "forth_startup.asm" 
e1f4			; Which startup method to use? 
e1f4			; 
e1f4			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e1f4			; followed by loading of a list of scripts in eeprom 
e1f4			 
e1f4			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e1f4			; from eeprom 
e1f4			 
e1f4			; Select with define in main stubs 
e1f4			 
e1f4			if STARTUP_V1 
e1f4				include "forth_startupv1.asm" 
e1f4			; Startup script loading version 1 
e1f4			 
e1f4			; If SE storage is available first stage is to use the selected file 
e1f4			; then go through the eeprom list 
e1f4			 
e1f4 .. 00		sprompt1: db "Startup load...",0 
e204 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e21a			 
e21a			 
e21a			 
e21a			 
e21a			forth_startup: 
e21a 21 49 d3			ld hl, startcmds 
e21d 3e 00			ld a, 0 
e21f 32 de e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e222			 
e222 e5			.start1:	push hl 
e223 cd ac 8a			call clear_display 
e226 11 f4 e1			ld de, sprompt1 
e229 3e 00		        ld a, display_row_1 
e22b cd be 8a			call str_at_display 
e22e 11 04 e2			ld de, sprompt2 
e231 3e 28		        ld a, display_row_2 
e233 cd be 8a			call str_at_display 
e236 e1				pop hl 
e237 e5				push hl 
e238 5e				ld e,(hl) 
e239 23				inc hl 
e23a 56				ld d,(hl) 
e23b 3e 50		        ld a, display_row_3 
e23d cd be 8a			call str_at_display 
e240 cd ce 8a			call update_display 
e243			 
e243			 
e243 3a de e6			ld a, (os_last_cmd) 
e246 fe 00			cp 0 
e248 28 05			jr z, .startprompt 
e24a cd e4 89			call delay250ms 
e24d 18 24			jr .startdo 
e24f				 
e24f				 
e24f			 
e24f			.startprompt: 
e24f			 
e24f 3e 9f			ld a,display_row_4 + display_cols - 1 
e251 11 41 99		        ld de, endprg 
e254 cd be 8a			call str_at_display 
e257 cd ce 8a			call update_display 
e25a cd f0 89			call delay1s 
e25d cd 80 e3			call cin_wait 
e260						 
e260 fe 2a			cp '*' 
e262 28 5e			jr z, .startupend1 
e264 fe 23			cp '#' 
e266 20 07			jr nz, .startno 
e268 3e 01			ld a, 1 
e26a 32 de e6			ld (os_last_cmd),a 
e26d 18 04			jr .startdo 
e26f fe 31		.startno:	cp '1' 
e271 28 3a			jr z,.startnxt  
e273			 
e273				; exec startup line 
e273			.startdo:	 
e273 e1				pop hl 
e274 e5				push hl 
e275				 
e275 5e				ld e,(hl) 
e276 23				inc hl 
e277 56				ld d,(hl) 
e278 eb				ex de,hl 
e279			 
e279 e5				push hl 
e27a			 
e27a 3e 00			ld a, 0 
e27c				;ld a, FORTH_END_BUFFER 
e27c cd 39 90			call strlent 
e27f 23				inc hl   ; include zero term to copy 
e280 06 00			ld b,0 
e282 4d				ld c,l 
e283 e1				pop hl 
e284 11 b8 e2			ld de, scratch 
e287 ed b0			ldir 
e289			 
e289			 
e289 21 b8 e2			ld hl, scratch 
e28c cd f4 9d			call forthparse 
e28f cd 2c 9e			call forthexec 
e292 cd 4e 9d			call forthexec_cleanup 
e295			 
e295 3e 78			ld a, display_row_4 
e297 11 ad 96			ld de, endprog 
e29a			 
e29a cd ce 8a			call update_display		 
e29d			 
e29d 3a de e6			ld a, (os_last_cmd) 
e2a0 fe 00			cp 0 
e2a2 20 09			jr nz, .startnxt 
e2a4 cd 43 99			call next_page_prompt 
e2a7 cd ac 8a		        call clear_display 
e2aa cd ce 8a			call update_display		 
e2ad			 
e2ad				; move onto next startup line? 
e2ad			.startnxt: 
e2ad			 
e2ad cd e4 89			call delay250ms 
e2b0 e1				pop hl 
e2b1			 
e2b1 23				inc hl 
e2b2 23				inc hl 
e2b3			 
e2b3 e5				push hl 
e2b4 5e				ld e, (hl) 
e2b5 23				inc hl 
e2b6 56				ld d, (hl) 
e2b7 e1				pop hl 
e2b8				; TODO replace 0 test 
e2b8			 
e2b8 eb				ex de, hl 
e2b9 cd ff 8c			call ishlzero 
e2bc			;	ld a,e 
e2bc			;	add d 
e2bc			;	cp 0    ; any left to do? 
e2bc eb				ex de, hl 
e2bd c2 22 e2			jp nz, .start1 
e2c0 18 01			jr .startupend 
e2c2			 
e2c2 e1			.startupend1: pop hl 
e2c3			.startupend: 
e2c3			 
e2c3 cd ac 8a			call clear_display 
e2c6 cd ce 8a			call update_display 
e2c9 c9				ret 
e2ca			if STORAGE_SE 
e2ca			 
e2ca			sprompt3: db "Loading from start-up file?:",0 
e2ca			sprompt4: db "(Y=Any key/N=No)",0 
e2ca			 
e2ca			 
e2ca			forth_autoload: 
e2ca			 
e2ca				; load block 0 of store 1 
e2ca				 
e2ca				ld a, $fe      ; bit 0 clear 
e2ca				ld (spi_device), a 
e2ca			 
e2ca				call storage_get_block_0 
e2ca			 
e2ca				ld a, (store_page+STORE_0_AUTOFILE) 
e2ca			 
e2ca				cp 0 
e2ca				ret z     ; auto start not enabled 
e2ca			 
e2ca				call clear_display 
e2ca			 
e2ca				; set bank 
e2ca			 
e2ca					ld a, (store_page+STORE_0_BANKRUN) 
e2ca					ld (spi_device), a 
e2ca			 
e2ca				; get file id to load from and get the file name to display 
e2ca			 
e2ca					ld a, (store_page+STORE_0_FILERUN) 
e2ca			 
e2ca					ld l, 0 
e2ca					ld h, a 
e2ca					ld de, store_page 
e2ca			 
e2ca					if DEBUG_FORTH_WORDS 
e2ca						DMARK "ASp" 
e2ca						CALLMONITOR 
e2ca					endif 
e2ca					call storage_read 
e2ca			 
e2ca					if DEBUG_FORTH_WORDS 
e2ca						DMARK "ASr" 
e2ca						CALLMONITOR 
e2ca					endif 
e2ca			 
e2ca					call ishlzero 
e2ca					ret z             ; file not found 
e2ca			 
e2ca					ld a, display_row_2 + 10 
e2ca					ld de, store_page+3 
e2ca					call str_at_display 
e2ca				 
e2ca			; 
e2ca			 
e2ca				ld a, display_row_1+5 
e2ca				ld de, sprompt3 
e2ca				call str_at_display 
e2ca				ld a, display_row_3+15 
e2ca				ld de, sprompt4 
e2ca				call str_at_display 
e2ca			 
e2ca				call update_display 
e2ca			 
e2ca				call cin_wait 
e2ca				cp 'n' 
e2ca				ret z 
e2ca				cp 'N' 
e2ca				ret z 
e2ca			 
e2ca				call delay1s 
e2ca			 
e2ca				ld a, (store_page+2) 
e2ca				ld (store_openmaxext), a    ; save count of ext 
e2ca				ld a, 1  
e2ca				ld (store_openext), a    ; save count of ext 
e2ca			 
e2ca			.autof:  
e2ca				ld l , a 
e2ca				 
e2ca				ld a, (store_page) 
e2ca				ld h, a	 
e2ca				ld de, store_page 
e2ca					if DEBUG_FORTH_WORDS 
e2ca						DMARK "ASl" 
e2ca						CALLMONITOR 
e2ca					endif 
e2ca					call storage_read 
e2ca				call ishlzero 
e2ca				ret z 
e2ca			;	jr z, .autoend 
e2ca			 
e2ca					if DEBUG_FORTH_WORDS 
e2ca						DMARK "ASc" 
e2ca						CALLMONITOR 
e2ca					endif 
e2ca				ld de, store_page+2 
e2ca				ld a, display_row_4 
e2ca				call str_at_display 
e2ca			 
e2ca				call update_display 
e2ca				call delay250ms 
e2ca			 
e2ca			 
e2ca			 
e2ca				ld hl, store_page+2 
e2ca				call forthparse 
e2ca				call forthexec 
e2ca				call forthexec_cleanup 
e2ca			 
e2ca				 
e2ca				ld a, (store_openext) 
e2ca				inc a 
e2ca				ld (store_openext), a    ; save count of ext 
e2ca			 
e2ca				jr .autof 
e2ca			;.autofdone: 
e2ca			; 
e2ca			;		if DEBUG_FORTH_WORDS 
e2ca			;			DMARK "ASx" 
e2ca			;			CALLMONITOR 
e2ca			;		endif 
e2ca			;;	call clear_display 
e2ca			;	ret 
e2ca			 
e2ca			 
e2ca			 
e2ca			endif 
# End of file forth_startupv1.asm
e2ca			endif 
e2ca			if STARTUP_V2 
e2ca				include "forth_startupv2.asm" 
e2ca			endif 
e2ca			 
# End of file forth_startup.asm
e2ca			 
e2ca			; eof 
# End of file forth_kernel.asm
e2ca			;include "nascombasic.asm" 
e2ca			 
e2ca			 
e2ca			; find out where the code ends if loaded into RAM (for SC114) 
e2ca			;endofcode:  
e2ca			;	nop 
e2ca			 
e2ca			 
e2ca			; jump to nmi vector 
e2ca			 
e2ca			init_nmi: 
e2ca 3e c9			ld a, $c9   ; RET 
e2cc 32 72 ee			ld (nmi_vector), a 
e2cf c9				ret 
e2d0			nmi: 
e2d0 e5				push hl 
e2d1 d5				push de 
e2d2 c5				push bc 
e2d3 f5				push af 
e2d4 cd 72 ee			call nmi_vector 
e2d7 f5				push af 
e2d8 c5				push bc 
e2d9 d5				push de 
e2da e5				push hl 
e2db ed 4d			reti 
e2dd			 
e2dd			 
e2dd			; eof 
e2dd			 
# End of file main.asm
e2dd			;include "firmware_lcd_4x40.asm" 
e2dd			;;include "firmware_lcd_4x20.asm" 
e2dd			include "firmware_serial_display.asm" 
e2dd			 
e2dd			; Serial display interface for SC114 
e2dd			 
e2dd			 
e2dd			display_row_1: equ 0 
e2dd			display_row_2: equ display_row_1+display_cols 
e2dd			display_row_3: equ display_row_2 + display_cols 
e2dd			display_row_4: equ display_row_3 + display_cols 
e2dd			 
e2dd			kLCDWidth:  EQU display_cols             ;Width in characters 
e2dd			kLCD_Line1: EQU 0x00  
e2dd			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e2dd			; E1 
e2dd			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e2dd			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e2dd			 
e2dd			lcd_init: 
e2dd				; no init as handled by the SCM bios 
e2dd c9				ret 
e2de			 
e2de			 
e2de			; low level functions for direct screen writes 
e2de			 
e2de			; output char at pos? 
e2de			fLCD_Str: 
e2de			        ;out (SC114_SIO_1_OUT),a 
e2de c5				push bc 
e2df 0e 02			ld c, $02 
e2e1 f7				rst $30 
e2e2 c1				pop bc 
e2e3 c9				ret 
e2e4			 
e2e4			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e2e4			fLCD_Pos: 
e2e4				; use ASCII escape to position 
e2e4			        ;out (SC114_SIO_1_OUT),a 
e2e4 c5				push bc 
e2e5 0e 02			ld c, $02 
e2e7 f7				rst $30 
e2e8 c1				pop bc 
e2e9			 
e2e9 c9				ret 
e2ea			 
e2ea			; output char at pos 
e2ea			fLCD_Data: 
e2ea			      ;  out (SC114_SIO_1_OUT),a 
e2ea c5				push bc 
e2eb 0e 02			ld c, $02 
e2ed f7				rst $30 
e2ee c1				pop bc 
e2ef			 
e2ef c9				ret 
e2f0			 
e2f0			; ascii cls  
e2f0			 
e2f0 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e2f4			 
e2f4			; write the frame buffer given in hl to hardware  
e2f4			write_display: 
e2f4			 
e2f4			API: equ 0 
e2f4			 
e2f4			if API 
e2f4				push bc 
e2f4				ld b, 4 
e2f4			 
e2f4			        ld (display_write_tmp), hl 	  
e2f4			 
e2f4				; clear and home cursor 
e2f4			 
e2f4				ld c, 6 
e2f4				ld de, .cls 
e2f4				rst $30 
e2f4			 
e2f4			 
e2f4			.writeln: 
e2f4			 
e2f4				ld de, (display_write_tmp) 
e2f4				ld c, 6 
e2f4				rst $30 
e2f4				ld c, 7 
e2f4				rst $30 
e2f4			 
e2f4				ld hl, (display_write_tmp) 
e2f4				ld de, display_cols 
e2f4				add hl,de 
e2f4				ld (display_write_tmp),hl 
e2f4			 
e2f4				djnz  .writeln 
e2f4			 
e2f4				pop bc 
e2f4			 
e2f4			 
e2f4				ret 
e2f4			endif 
e2f4 e5				push hl 
e2f5 c5				push bc 
e2f6 d5				push de 
e2f7			 
e2f7			;	ld c, 2 
e2f7			;	;ld de, .cls 
e2f7			;	ld a, 27 
e2f7			;	rst $30 
e2f7			;	ld c, 2 
e2f7			;	;ld de, .cls 
e2f7			;	ld a, '[' 
e2f7			;	rst $30 
e2f7			; 
e2f7			;	ld c, 2 
e2f7			;	;ld de, .cls 
e2f7			;	ld a, 'H' 
e2f7			;	rst $30 
e2f7			; 
e2f7			 
e2f7 0e 02			ld c, 2 
e2f9				;ld de, .cls 
e2f9 3e 1b			ld a, 27 
e2fb f7				rst $30 
e2fc			 
e2fc			 
e2fc 0e 02			ld c, 2 
e2fe				;ld de, .cls 
e2fe 3e 5b			ld a, '[' 
e300 f7				rst $30 
e301 0e 02			ld c, 2 
e303				;ld de, .cls 
e303 3e 32			ld a, '2' 
e305 f7				rst $30 
e306 0e 02			ld c, 2 
e308				;ld de, .cls 
e308 3e 4a			ld a, 'J' 
e30a f7				rst $30 
e30b d1				pop de 
e30c c1				pop bc 
e30d e1				pop hl 
e30e			 
e30e			 
e30e 22 c0 eb		        ld (display_write_tmp), hl 	  
e311 3e 00			ld a, kLCD_Line1 
e313			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e313 06 28			ld b, display_cols 
e315 ed 5b c0 eb		ld de, (display_write_tmp) 
e319 cd 77 e3			call write_len_string 
e31c				 
e31c			 
e31c e5			push hl 
e31d d5			push de 
e31e c5			push bc 
e31f 0e 07			ld c, 7 
e321 f7				rst $30 
e322 c1			pop bc 
e323 d1			pop de 
e324 e1			pop hl 
e325			 
e325				 
e325 2a c0 eb			ld hl, (display_write_tmp) 
e328 11 28 00			ld de, display_cols 
e32b 19				add hl,de 
e32c 22 c0 eb			ld (display_write_tmp),hl 
e32f			 
e32f				 
e32f 3e 28			ld a, kLCD_Line2 
e331			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e331 06 28			ld b, display_cols 
e333 ed 5b c0 eb		ld de, (display_write_tmp) 
e337 cd 77 e3			call write_len_string 
e33a				 
e33a 2a c0 eb			ld hl, (display_write_tmp) 
e33d 11 28 00			ld de, display_cols 
e340 19				add hl,de 
e341 22 c0 eb			ld (display_write_tmp),hl 
e344			 
e344 e5			push hl 
e345 d5			push de 
e346 c5			push bc 
e347 0e 07			ld c, 7 
e349 f7				rst $30 
e34a c1			pop bc 
e34b d1			pop de 
e34c e1			pop hl 
e34d			 
e34d				 
e34d 3e 50			ld a, kLCD_Line3 
e34f			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e34f 06 28			ld b, display_cols 
e351 ed 5b c0 eb		ld de, (display_write_tmp) 
e355 cd 77 e3			call write_len_string 
e358				 
e358 2a c0 eb			ld hl, (display_write_tmp) 
e35b 11 28 00			ld de, display_cols 
e35e 19				add hl,de 
e35f 22 c0 eb			ld (display_write_tmp),hl 
e362			 
e362 e5			push hl 
e363 d5			push de 
e364 c5			push bc 
e365 0e 07			ld c, 7 
e367 f7				rst $30 
e368 c1			pop bc 
e369 d1			pop de 
e36a e1			pop hl 
e36b			 
e36b				 
e36b 3e 78			ld a, kLCD_Line4 
e36d			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e36d 06 28			ld b, display_cols 
e36f ed 5b c0 eb		ld de, (display_write_tmp) 
e373 cd 77 e3			call write_len_string 
e376 c9					ret 
e377			 
e377			 
e377				; write out a fixed length string given in b from de 
e377			 
e377 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e378 cd ea e2		            CALL fLCD_Data      ;Write character to display 
e37b 13				inc de 
e37c 10 f9			djnz write_len_string 
e37e c9				ret 
e37f			 
e37f			 
e37f			; eof 
# End of file firmware_serial_display.asm
e37f			;include "firmware_key_5x10.asm" 
e37f			;;include "firmware_key_4x10.asm" 
e37f			include "firmware_key_serial.asm" 
e37f			; Serial keyboard interface for SC114 
e37f			 
e37f			key_init: 
e37f				; no init as handled by the SCM bios 
e37f c9				ret 
e380			 
e380			 
e380			cin_wait: 
e380			;	ld a, 0 
e380			;	ret 
e380			 
e380				;in a,(SC114_SIO_1_IN) 
e380			        ; Use SCM API to get from whatever console device we are using 
e380 c5				push bc 
e381 0e 01			ld c, $01 
e383 f7				rst $30 
e384 c1				pop bc 
e385 c9				ret 
e386			 
e386			cinndb: 	 
e386			cin: 
e386			 
e386			 
e386 c5				push bc 
e387			 
e387				; any key waiting to process? 
e387 0e 03			ld c, $03 
e389 f7				rst $30 
e38a 28 05			jr z, .cin_skip 
e38c			 
e38c				; yep, get it 
e38c			 
e38c 0e 01			ld c, $01 
e38e f7				rst $30 
e38f c1				pop bc 
e390 c9				ret 
e391			.cin_skip: 
e391 3e 00			ld a, 0 
e393 c1				pop bc 
e394 c9				ret 
e395			 
e395			 
e395			 
e395			 
# End of file firmware_key_serial.asm
e395			endofcode:  
e395			baseram:  
e395 00				nop 
e396			 
e396			heap_start: equ baseram+15  ; Starting address of heap 
e396			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e396			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e396			;VDU:  EQU     endofcode           ; BASIC Work space 
e396			; eof 
e396			 
# End of file os_mega_sc114.asm
e396
